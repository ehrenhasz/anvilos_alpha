{
  "module_name": "adv7511_drv.c",
  "hash_id": "519dfd52a22212b89241aae484e8339dae51f279a3ee2cf0c0da4837da565b65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/adv7511/adv7511_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n\n#include <media/cec.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"adv7511.h\"\n\n \nstatic const struct reg_sequence adv7511_fixed_registers[] = {\n\t{ 0x98, 0x03 },\n\t{ 0x9a, 0xe0 },\n\t{ 0x9c, 0x30 },\n\t{ 0x9d, 0x61 },\n\t{ 0xa2, 0xa4 },\n\t{ 0xa3, 0xa4 },\n\t{ 0xe0, 0xd0 },\n\t{ 0xf9, 0x00 },\n\t{ 0x55, 0x02 },\n};\n\n \n\nstatic const uint8_t adv7511_register_defaults[] = {\n\t0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x01, 0x0e, 0xbc, 0x18, 0x01, 0x13,\n\t0x25, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x46, 0x62, 0x04, 0xa8, 0x00, 0x00, 0x1c, 0x84,\n\t0x1c, 0xbf, 0x04, 0xa8, 0x1e, 0x70, 0x02, 0x1e,  \n\t0x00, 0x00, 0x04, 0xa8, 0x08, 0x12, 0x1b, 0xac,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xb0,\n\t0x00, 0x50, 0x90, 0x7e, 0x79, 0x70, 0x00, 0x00,  \n\t0x00, 0xa8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x02, 0x0d, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x01, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,  \n\t0x0b, 0x02, 0x00, 0x18, 0x5a, 0x60, 0x00, 0x00,\n\t0x00, 0x00, 0x80, 0x80, 0x08, 0x04, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 0x14,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  \n\t0x00, 0x03, 0x00, 0x00, 0x02, 0x00, 0x01, 0x04,\n\t0x30, 0xff, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01,\n\t0x80, 0x75, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,  \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x11, 0x00,  \n\t0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n};\n\nstatic bool adv7511_register_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADV7511_REG_CHIP_REVISION:\n\tcase ADV7511_REG_SPDIF_FREQ:\n\tcase ADV7511_REG_CTS_AUTOMATIC1:\n\tcase ADV7511_REG_CTS_AUTOMATIC2:\n\tcase ADV7511_REG_VIC_DETECTED:\n\tcase ADV7511_REG_VIC_SEND:\n\tcase ADV7511_REG_AUX_VIC_DETECTED:\n\tcase ADV7511_REG_STATUS:\n\tcase ADV7511_REG_GC(1):\n\tcase ADV7511_REG_INT(0):\n\tcase ADV7511_REG_INT(1):\n\tcase ADV7511_REG_PLL_STATUS:\n\tcase ADV7511_REG_AN(0):\n\tcase ADV7511_REG_AN(1):\n\tcase ADV7511_REG_AN(2):\n\tcase ADV7511_REG_AN(3):\n\tcase ADV7511_REG_AN(4):\n\tcase ADV7511_REG_AN(5):\n\tcase ADV7511_REG_AN(6):\n\tcase ADV7511_REG_AN(7):\n\tcase ADV7511_REG_HDCP_STATUS:\n\tcase ADV7511_REG_BCAPS:\n\tcase ADV7511_REG_BKSV(0):\n\tcase ADV7511_REG_BKSV(1):\n\tcase ADV7511_REG_BKSV(2):\n\tcase ADV7511_REG_BKSV(3):\n\tcase ADV7511_REG_BKSV(4):\n\tcase ADV7511_REG_DDC_STATUS:\n\tcase ADV7511_REG_EDID_READ_CTRL:\n\tcase ADV7511_REG_BSTATUS(0):\n\tcase ADV7511_REG_BSTATUS(1):\n\tcase ADV7511_REG_CHIP_ID_HIGH:\n\tcase ADV7511_REG_CHIP_ID_LOW:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config adv7511_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0xff,\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults_raw = adv7511_register_defaults,\n\t.num_reg_defaults_raw = ARRAY_SIZE(adv7511_register_defaults),\n\n\t.volatile_reg = adv7511_register_volatile,\n};\n\n \n\nstatic void adv7511_set_colormap(struct adv7511 *adv7511, bool enable,\n\t\t\t\t const uint16_t *coeff,\n\t\t\t\t unsigned int scaling_factor)\n{\n\tunsigned int i;\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(1),\n\t\t\t   ADV7511_CSC_UPDATE_MODE, ADV7511_CSC_UPDATE_MODE);\n\n\tif (enable) {\n\t\tfor (i = 0; i < 12; ++i) {\n\t\t\tregmap_update_bits(adv7511->regmap,\n\t\t\t\t\t   ADV7511_REG_CSC_UPPER(i),\n\t\t\t\t\t   0x1f, coeff[i] >> 8);\n\t\t\tregmap_write(adv7511->regmap,\n\t\t\t\t     ADV7511_REG_CSC_LOWER(i),\n\t\t\t\t     coeff[i] & 0xff);\n\t\t}\n\t}\n\n\tif (enable)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(0),\n\t\t\t\t   0xe0, 0x80 | (scaling_factor << 5));\n\telse\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(0),\n\t\t\t\t   0x80, 0x00);\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_CSC_UPPER(1),\n\t\t\t   ADV7511_CSC_UPDATE_MODE, 0);\n}\n\nstatic int adv7511_packet_enable(struct adv7511 *adv7511, unsigned int packet)\n{\n\tif (packet & 0xff)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE0,\n\t\t\t\t   packet, 0xff);\n\n\tif (packet & 0xff00) {\n\t\tpacket >>= 8;\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\n\t\t\t\t   packet, 0xff);\n\t}\n\n\treturn 0;\n}\n\nstatic int adv7511_packet_disable(struct adv7511 *adv7511, unsigned int packet)\n{\n\tif (packet & 0xff)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE0,\n\t\t\t\t   packet, 0x00);\n\n\tif (packet & 0xff00) {\n\t\tpacket >>= 8;\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_PACKET_ENABLE1,\n\t\t\t\t   packet, 0x00);\n\t}\n\n\treturn 0;\n}\n\n \nstatic const uint16_t adv7511_csc_ycbcr_to_rgb[] = {\n\t0x0734, 0x04ad, 0x0000, 0x1c1b,\n\t0x1ddc, 0x04ad, 0x1f24, 0x0135,\n\t0x0000, 0x04ad, 0x087c, 0x1b77,\n};\n\nstatic void adv7511_set_config_csc(struct adv7511 *adv7511,\n\t\t\t\t   struct drm_connector *connector,\n\t\t\t\t   bool rgb, bool hdmi_mode)\n{\n\tstruct adv7511_video_config config;\n\tbool output_format_422, output_format_ycbcr;\n\tunsigned int mode;\n\tuint8_t infoframe[17];\n\n\tconfig.hdmi_mode = hdmi_mode;\n\n\thdmi_avi_infoframe_init(&config.avi_infoframe);\n\n\tconfig.avi_infoframe.scan_mode = HDMI_SCAN_MODE_UNDERSCAN;\n\n\tif (rgb) {\n\t\tconfig.csc_enable = false;\n\t\tconfig.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;\n\t} else {\n\t\tconfig.csc_scaling_factor = ADV7511_CSC_SCALING_4;\n\t\tconfig.csc_coefficents = adv7511_csc_ycbcr_to_rgb;\n\n\t\tif ((connector->display_info.color_formats &\n\t\t     DRM_COLOR_FORMAT_YCBCR422) &&\n\t\t    config.hdmi_mode) {\n\t\t\tconfig.csc_enable = false;\n\t\t\tconfig.avi_infoframe.colorspace =\n\t\t\t\tHDMI_COLORSPACE_YUV422;\n\t\t} else {\n\t\t\tconfig.csc_enable = true;\n\t\t\tconfig.avi_infoframe.colorspace = HDMI_COLORSPACE_RGB;\n\t\t}\n\t}\n\n\tif (config.hdmi_mode) {\n\t\tmode = ADV7511_HDMI_CFG_MODE_HDMI;\n\n\t\tswitch (config.avi_infoframe.colorspace) {\n\t\tcase HDMI_COLORSPACE_YUV444:\n\t\t\toutput_format_422 = false;\n\t\t\toutput_format_ycbcr = true;\n\t\t\tbreak;\n\t\tcase HDMI_COLORSPACE_YUV422:\n\t\t\toutput_format_422 = true;\n\t\t\toutput_format_ycbcr = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toutput_format_422 = false;\n\t\t\toutput_format_ycbcr = false;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmode = ADV7511_HDMI_CFG_MODE_DVI;\n\t\toutput_format_422 = false;\n\t\toutput_format_ycbcr = false;\n\t}\n\n\tadv7511_packet_disable(adv7511, ADV7511_PACKET_ENABLE_AVI_INFOFRAME);\n\n\tadv7511_set_colormap(adv7511, config.csc_enable,\n\t\t\t     config.csc_coefficents,\n\t\t\t     config.csc_scaling_factor);\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1, 0x81,\n\t\t\t   (output_format_422 << 7) | output_format_ycbcr);\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_HDCP_HDMI_CFG,\n\t\t\t   ADV7511_HDMI_CFG_MODE_MASK, mode);\n\n\thdmi_avi_infoframe_pack(&config.avi_infoframe, infoframe,\n\t\t\t\tsizeof(infoframe));\n\n\t \n\tregmap_bulk_write(adv7511->regmap, ADV7511_REG_AVI_INFOFRAME_VERSION,\n\t\t\t  infoframe + 1, sizeof(infoframe) - 1);\n\n\tadv7511_packet_enable(adv7511, ADV7511_PACKET_ENABLE_AVI_INFOFRAME);\n}\n\nstatic void adv7511_set_link_config(struct adv7511 *adv7511,\n\t\t\t\t    const struct adv7511_link_config *config)\n{\n\t \n\tstatic const unsigned int input_styles[4] = { 0, 2, 1, 3 };\n\n\tunsigned int clock_delay;\n\tunsigned int color_depth;\n\tunsigned int input_id;\n\n\tclock_delay = (config->clock_delay + 1200) / 400;\n\tcolor_depth = config->input_color_depth == 8 ? 3\n\t\t    : (config->input_color_depth == 10 ? 1 : 2);\n\n\t \n\tif (config->input_colorspace != HDMI_COLORSPACE_YUV422)\n\t\tinput_id = config->input_clock == ADV7511_INPUT_CLOCK_DDR\n\t\t\t ? 5 : 0;\n\telse if (config->input_clock == ADV7511_INPUT_CLOCK_DDR)\n\t\tinput_id = config->embedded_sync ? 8 : 7;\n\telse if (config->input_clock == ADV7511_INPUT_CLOCK_2X)\n\t\tinput_id = config->embedded_sync ? 4 : 3;\n\telse\n\t\tinput_id = config->embedded_sync ? 2 : 1;\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_I2C_FREQ_ID_CFG, 0xf,\n\t\t\t   input_id);\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG1, 0x7e,\n\t\t\t   (color_depth << 4) |\n\t\t\t   (input_styles[config->input_style] << 2));\n\tregmap_write(adv7511->regmap, ADV7511_REG_VIDEO_INPUT_CFG2,\n\t\t     config->input_justification << 3);\n\tregmap_write(adv7511->regmap, ADV7511_REG_TIMING_GEN_SEQ,\n\t\t     config->sync_pulse << 2);\n\n\tregmap_write(adv7511->regmap, 0xba, clock_delay << 5);\n\n\tadv7511->embedded_sync = config->embedded_sync;\n\tadv7511->hsync_polarity = config->hsync_polarity;\n\tadv7511->vsync_polarity = config->vsync_polarity;\n\tadv7511->rgb = config->input_colorspace == HDMI_COLORSPACE_RGB;\n}\n\nstatic void __adv7511_power_on(struct adv7511 *adv7511)\n{\n\tadv7511->current_edid_segment = -1;\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,\n\t\t\t   ADV7511_POWER_POWER_DOWN, 0);\n\tif (adv7511->i2c_main->irq) {\n\t\t \n\t\tregmap_write(adv7511->regmap, ADV7511_REG_INT_ENABLE(0),\n\t\t\t     ADV7511_INT0_EDID_READY | ADV7511_INT0_HPD);\n\t\tregmap_update_bits(adv7511->regmap,\n\t\t\t\t   ADV7511_REG_INT_ENABLE(1),\n\t\t\t\t   ADV7511_INT1_DDC_ERROR,\n\t\t\t\t   ADV7511_INT1_DDC_ERROR);\n\t}\n\n\t \n\tif (adv7511->type == ADV7535)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\n\t\t\t\t   ADV7535_REG_POWER2_HPD_OVERRIDE,\n\t\t\t\t   ADV7535_REG_POWER2_HPD_OVERRIDE);\n\telse\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\n\t\t\t\t   ADV7511_REG_POWER2_HPD_SRC_MASK,\n\t\t\t\t   ADV7511_REG_POWER2_HPD_SRC_NONE);\n}\n\nstatic void adv7511_power_on(struct adv7511 *adv7511)\n{\n\t__adv7511_power_on(adv7511);\n\n\t \n\tregcache_sync(adv7511->regmap);\n\n\tif (adv7511->type == ADV7533 || adv7511->type == ADV7535)\n\t\tadv7533_dsi_power_on(adv7511);\n\tadv7511->powered = true;\n}\n\nstatic void __adv7511_power_off(struct adv7511 *adv7511)\n{\n\t \n\tif (adv7511->type == ADV7535)\n\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\n\t\t\t\t   ADV7535_REG_POWER2_HPD_OVERRIDE, 0);\n\n\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER,\n\t\t\t   ADV7511_POWER_POWER_DOWN,\n\t\t\t   ADV7511_POWER_POWER_DOWN);\n\tregmap_update_bits(adv7511->regmap,\n\t\t\t   ADV7511_REG_INT_ENABLE(1),\n\t\t\t   ADV7511_INT1_DDC_ERROR, 0);\n\tregcache_mark_dirty(adv7511->regmap);\n}\n\nstatic void adv7511_power_off(struct adv7511 *adv7511)\n{\n\t__adv7511_power_off(adv7511);\n\tif (adv7511->type == ADV7533 || adv7511->type == ADV7535)\n\t\tadv7533_dsi_power_off(adv7511);\n\tadv7511->powered = false;\n}\n\n \n\nstatic bool adv7511_hpd(struct adv7511 *adv7511)\n{\n\tunsigned int irq0;\n\tint ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_INT(0), &irq0);\n\tif (ret < 0)\n\t\treturn false;\n\n\tif (irq0 & ADV7511_INT0_HPD) {\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_INT(0),\n\t\t\t     ADV7511_INT0_HPD);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void adv7511_hpd_work(struct work_struct *work)\n{\n\tstruct adv7511 *adv7511 = container_of(work, struct adv7511, hpd_work);\n\tenum drm_connector_status status;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_STATUS, &val);\n\tif (ret < 0)\n\t\tstatus = connector_status_disconnected;\n\telse if (val & ADV7511_STATUS_HPD)\n\t\tstatus = connector_status_connected;\n\telse\n\t\tstatus = connector_status_disconnected;\n\n\t \n\tif (status == connector_status_connected &&\n\t    adv7511->connector.status == connector_status_disconnected &&\n\t    adv7511->powered) {\n\t\tregcache_mark_dirty(adv7511->regmap);\n\t\tadv7511_power_on(adv7511);\n\t}\n\n\tif (adv7511->connector.status != status) {\n\t\tadv7511->connector.status = status;\n\n\t\tif (adv7511->connector.dev) {\n\t\t\tif (status == connector_status_disconnected)\n\t\t\t\tcec_phys_addr_invalidate(adv7511->cec_adap);\n\t\t\tdrm_kms_helper_hotplug_event(adv7511->connector.dev);\n\t\t} else {\n\t\t\tdrm_bridge_hpd_notify(&adv7511->bridge, status);\n\t\t}\n\t}\n}\n\nstatic int adv7511_irq_process(struct adv7511 *adv7511, bool process_hpd)\n{\n\tunsigned int irq0, irq1;\n\tint ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_INT(0), &irq0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_INT(1), &irq1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_INT(0), irq0);\n\tregmap_write(adv7511->regmap, ADV7511_REG_INT(1), irq1);\n\n\tif (process_hpd && irq0 & ADV7511_INT0_HPD && adv7511->bridge.encoder)\n\t\tschedule_work(&adv7511->hpd_work);\n\n\tif (irq0 & ADV7511_INT0_EDID_READY || irq1 & ADV7511_INT1_DDC_ERROR) {\n\t\tadv7511->edid_read = true;\n\n\t\tif (adv7511->i2c_main->irq)\n\t\t\twake_up_all(&adv7511->wq);\n\t}\n\n#ifdef CONFIG_DRM_I2C_ADV7511_CEC\n\tadv7511_cec_irq_process(adv7511, irq1);\n#endif\n\n\treturn 0;\n}\n\nstatic irqreturn_t adv7511_irq_handler(int irq, void *devid)\n{\n\tstruct adv7511 *adv7511 = devid;\n\tint ret;\n\n\tret = adv7511_irq_process(adv7511, true);\n\treturn ret < 0 ? IRQ_NONE : IRQ_HANDLED;\n}\n\n \n\nstatic int adv7511_wait_for_edid(struct adv7511 *adv7511, int timeout)\n{\n\tint ret;\n\n\tif (adv7511->i2c_main->irq) {\n\t\tret = wait_event_interruptible_timeout(adv7511->wq,\n\t\t\t\tadv7511->edid_read, msecs_to_jiffies(timeout));\n\t} else {\n\t\tfor (; timeout > 0; timeout -= 25) {\n\t\t\tret = adv7511_irq_process(adv7511, false);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (adv7511->edid_read)\n\t\t\t\tbreak;\n\n\t\t\tmsleep(25);\n\t\t}\n\t}\n\n\treturn adv7511->edid_read ? 0 : -EIO;\n}\n\nstatic int adv7511_get_edid_block(void *data, u8 *buf, unsigned int block,\n\t\t\t\t  size_t len)\n{\n\tstruct adv7511 *adv7511 = data;\n\tstruct i2c_msg xfer[2];\n\tuint8_t offset;\n\tunsigned int i;\n\tint ret;\n\n\tif (len > 128)\n\t\treturn -EINVAL;\n\n\tif (adv7511->current_edid_segment != block / 2) {\n\t\tunsigned int status;\n\n\t\tret = regmap_read(adv7511->regmap, ADV7511_REG_DDC_STATUS,\n\t\t\t\t  &status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (status != 2) {\n\t\t\tadv7511->edid_read = false;\n\t\t\tregmap_write(adv7511->regmap, ADV7511_REG_EDID_SEGMENT,\n\t\t\t\t     block);\n\t\t\tret = adv7511_wait_for_edid(adv7511, 200);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\n\t\txfer[0].addr = adv7511->i2c_edid->addr;\n\t\txfer[0].flags = 0;\n\t\txfer[0].len = 1;\n\t\txfer[0].buf = &offset;\n\t\txfer[1].addr = adv7511->i2c_edid->addr;\n\t\txfer[1].flags = I2C_M_RD;\n\t\txfer[1].len = 64;\n\t\txfer[1].buf = adv7511->edid_buf;\n\n\t\toffset = 0;\n\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tret = i2c_transfer(adv7511->i2c_edid->adapter, xfer,\n\t\t\t\t\t   ARRAY_SIZE(xfer));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret != 2)\n\t\t\t\treturn -EIO;\n\n\t\t\txfer[1].buf += 64;\n\t\t\toffset += 64;\n\t\t}\n\n\t\tadv7511->current_edid_segment = block / 2;\n\t}\n\n\tif (block % 2 == 0)\n\t\tmemcpy(buf, adv7511->edid_buf, len);\n\telse\n\t\tmemcpy(buf, adv7511->edid_buf + 128, len);\n\n\treturn 0;\n}\n\n \n\nstatic struct edid *adv7511_get_edid(struct adv7511 *adv7511,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\n\t \n\tif (!adv7511->powered) {\n\t\tunsigned int edid_i2c_addr =\n\t\t\t\t\t(adv7511->i2c_edid->addr << 1);\n\n\t\t__adv7511_power_on(adv7511);\n\n\t\t \n\t\tregmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR,\n\t\t\t     edid_i2c_addr);\n\t}\n\n\tedid = drm_do_get_edid(connector, adv7511_get_edid_block, adv7511);\n\n\tif (!adv7511->powered)\n\t\t__adv7511_power_off(adv7511);\n\n\tadv7511_set_config_csc(adv7511, connector, adv7511->rgb,\n\t\t\t       drm_detect_hdmi_monitor(edid));\n\n\tcec_s_phys_addr_from_edid(adv7511->cec_adap, edid);\n\n\treturn edid;\n}\n\nstatic int adv7511_get_modes(struct adv7511 *adv7511,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\tunsigned int count;\n\n\tedid = adv7511_get_edid(adv7511, connector);\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tcount = drm_add_edid_modes(connector, edid);\n\n\tkfree(edid);\n\n\treturn count;\n}\n\nstatic enum drm_connector_status\nadv7511_detect(struct adv7511 *adv7511, struct drm_connector *connector)\n{\n\tenum drm_connector_status status;\n\tunsigned int val;\n\tbool hpd;\n\tint ret;\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_STATUS, &val);\n\tif (ret < 0)\n\t\treturn connector_status_disconnected;\n\n\tif (val & ADV7511_STATUS_HPD)\n\t\tstatus = connector_status_connected;\n\telse\n\t\tstatus = connector_status_disconnected;\n\n\thpd = adv7511_hpd(adv7511);\n\n\t \n\tif (status == connector_status_connected && hpd && adv7511->powered) {\n\t\tregcache_mark_dirty(adv7511->regmap);\n\t\tadv7511_power_on(adv7511);\n\t\tif (connector)\n\t\t\tadv7511_get_modes(adv7511, connector);\n\t\tif (adv7511->status == connector_status_connected)\n\t\t\tstatus = connector_status_disconnected;\n\t} else {\n\t\t \n\t\tif (adv7511->type == ADV7535)\n\t\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\n\t\t\t\t\t   ADV7535_REG_POWER2_HPD_OVERRIDE,\n\t\t\t\t\t   ADV7535_REG_POWER2_HPD_OVERRIDE);\n\t\telse\n\t\t\tregmap_update_bits(adv7511->regmap, ADV7511_REG_POWER2,\n\t\t\t\t\t   ADV7511_REG_POWER2_HPD_SRC_MASK,\n\t\t\t\t\t   ADV7511_REG_POWER2_HPD_SRC_BOTH);\n\t}\n\n\tadv7511->status = status;\n\treturn status;\n}\n\nstatic enum drm_mode_status adv7511_mode_valid(struct adv7511 *adv7511,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tif (mode->clock > 165000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void adv7511_mode_set(struct adv7511 *adv7511,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     const struct drm_display_mode *adj_mode)\n{\n\tunsigned int low_refresh_rate;\n\tunsigned int hsync_polarity = 0;\n\tunsigned int vsync_polarity = 0;\n\n\tif (adv7511->embedded_sync) {\n\t\tunsigned int hsync_offset, hsync_len;\n\t\tunsigned int vsync_offset, vsync_len;\n\n\t\thsync_offset = adj_mode->crtc_hsync_start -\n\t\t\t       adj_mode->crtc_hdisplay;\n\t\tvsync_offset = adj_mode->crtc_vsync_start -\n\t\t\t       adj_mode->crtc_vdisplay;\n\t\thsync_len = adj_mode->crtc_hsync_end -\n\t\t\t    adj_mode->crtc_hsync_start;\n\t\tvsync_len = adj_mode->crtc_vsync_end -\n\t\t\t    adj_mode->crtc_vsync_start;\n\n\t\t \n\t\tvsync_offset += 1;\n\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_HSYNC_PLACEMENT_MSB,\n\t\t\t     ((hsync_offset >> 10) & 0x7) << 5);\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(0),\n\t\t\t     (hsync_offset >> 2) & 0xff);\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(1),\n\t\t\t     ((hsync_offset & 0x3) << 6) |\n\t\t\t     ((hsync_len >> 4) & 0x3f));\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(2),\n\t\t\t     ((hsync_len & 0xf) << 4) |\n\t\t\t     ((vsync_offset >> 6) & 0xf));\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(3),\n\t\t\t     ((vsync_offset & 0x3f) << 2) |\n\t\t\t     ((vsync_len >> 8) & 0x3));\n\t\tregmap_write(adv7511->regmap, ADV7511_REG_SYNC_DECODER(4),\n\t\t\t     vsync_len & 0xff);\n\n\t\thsync_polarity = !(adj_mode->flags & DRM_MODE_FLAG_PHSYNC);\n\t\tvsync_polarity = !(adj_mode->flags & DRM_MODE_FLAG_PVSYNC);\n\t} else {\n\t\tenum adv7511_sync_polarity mode_hsync_polarity;\n\t\tenum adv7511_sync_polarity mode_vsync_polarity;\n\n\t\t \n\t\tif (adj_mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\t\tmode_hsync_polarity = ADV7511_SYNC_POLARITY_LOW;\n\t\telse\n\t\t\tmode_hsync_polarity = ADV7511_SYNC_POLARITY_HIGH;\n\n\t\tif (adj_mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tmode_vsync_polarity = ADV7511_SYNC_POLARITY_LOW;\n\t\telse\n\t\t\tmode_vsync_polarity = ADV7511_SYNC_POLARITY_HIGH;\n\n\t\tif (adv7511->hsync_polarity != mode_hsync_polarity &&\n\t\t    adv7511->hsync_polarity !=\n\t\t    ADV7511_SYNC_POLARITY_PASSTHROUGH)\n\t\t\thsync_polarity = 1;\n\n\t\tif (adv7511->vsync_polarity != mode_vsync_polarity &&\n\t\t    adv7511->vsync_polarity !=\n\t\t    ADV7511_SYNC_POLARITY_PASSTHROUGH)\n\t\t\tvsync_polarity = 1;\n\t}\n\n\tif (drm_mode_vrefresh(mode) <= 24)\n\t\tlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_24HZ;\n\telse if (drm_mode_vrefresh(mode) <= 25)\n\t\tlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_25HZ;\n\telse if (drm_mode_vrefresh(mode) <= 30)\n\t\tlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_30HZ;\n\telse\n\t\tlow_refresh_rate = ADV7511_LOW_REFRESH_RATE_NONE;\n\n\tif (adv7511->type == ADV7511)\n\t\tregmap_update_bits(adv7511->regmap, 0xfb,\n\t\t\t\t   0x6, low_refresh_rate << 1);\n\telse\n\t\tregmap_update_bits(adv7511->regmap, 0x4a,\n\t\t\t\t   0xc, low_refresh_rate << 2);\n\n\tregmap_update_bits(adv7511->regmap, 0x17,\n\t\t0x60, (vsync_polarity << 6) | (hsync_polarity << 5));\n\n\tdrm_mode_copy(&adv7511->curr_mode, adj_mode);\n\n\t \n\n\tadv7511->f_tmds = mode->clock;\n}\n\n \n\nstatic struct adv7511 *connector_to_adv7511(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct adv7511, connector);\n}\n\nstatic int adv7511_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct adv7511 *adv = connector_to_adv7511(connector);\n\n\treturn adv7511_get_modes(adv, connector);\n}\n\nstatic enum drm_mode_status\nadv7511_connector_mode_valid(struct drm_connector *connector,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct adv7511 *adv = connector_to_adv7511(connector);\n\n\treturn adv7511_mode_valid(adv, mode);\n}\n\nstatic struct drm_connector_helper_funcs adv7511_connector_helper_funcs = {\n\t.get_modes = adv7511_connector_get_modes,\n\t.mode_valid = adv7511_connector_mode_valid,\n};\n\nstatic enum drm_connector_status\nadv7511_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct adv7511 *adv = connector_to_adv7511(connector);\n\n\treturn adv7511_detect(adv, connector);\n}\n\nstatic const struct drm_connector_funcs adv7511_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = adv7511_connector_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int adv7511_connector_init(struct adv7511 *adv)\n{\n\tstruct drm_bridge *bridge = &adv->bridge;\n\tint ret;\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (adv->i2c_main->irq)\n\t\tadv->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\telse\n\t\tadv->connector.polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\tDRM_CONNECTOR_POLL_DISCONNECT;\n\n\tret = drm_connector_init(bridge->dev, &adv->connector,\n\t\t\t\t &adv7511_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_HDMIA);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(&adv->connector,\n\t\t\t\t &adv7511_connector_helper_funcs);\n\tdrm_connector_attach_encoder(&adv->connector, bridge->encoder);\n\n\treturn 0;\n}\n\n \n\nstatic struct adv7511 *bridge_to_adv7511(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct adv7511, bridge);\n}\n\nstatic void adv7511_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\tadv7511_power_on(adv);\n}\n\nstatic void adv7511_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\tadv7511_power_off(adv);\n}\n\nstatic void adv7511_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    const struct drm_display_mode *adj_mode)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\tadv7511_mode_set(adv, mode, adj_mode);\n}\n\nstatic enum drm_mode_status adv7511_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t\t      const struct drm_display_info *info,\n\t\tconst struct drm_display_mode *mode)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\tif (adv->type == ADV7533 || adv->type == ADV7535)\n\t\treturn adv7533_mode_valid(adv, mode);\n\telse\n\t\treturn adv7511_mode_valid(adv, mode);\n}\n\nstatic int adv7511_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\tint ret = 0;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tret = adv7511_connector_init(adv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (adv->i2c_main->irq)\n\t\tregmap_write(adv->regmap, ADV7511_REG_INT_ENABLE(0),\n\t\t\t     ADV7511_INT0_HPD);\n\n\treturn ret;\n}\n\nstatic enum drm_connector_status adv7511_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\treturn adv7511_detect(adv, NULL);\n}\n\nstatic struct edid *adv7511_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\treturn adv7511_get_edid(adv, connector);\n}\n\nstatic void adv7511_bridge_hpd_notify(struct drm_bridge *bridge,\n\t\t\t\t      enum drm_connector_status status)\n{\n\tstruct adv7511 *adv = bridge_to_adv7511(bridge);\n\n\tif (status == connector_status_disconnected)\n\t\tcec_phys_addr_invalidate(adv->cec_adap);\n}\n\nstatic const struct drm_bridge_funcs adv7511_bridge_funcs = {\n\t.enable = adv7511_bridge_enable,\n\t.disable = adv7511_bridge_disable,\n\t.mode_set = adv7511_bridge_mode_set,\n\t.mode_valid = adv7511_bridge_mode_valid,\n\t.attach = adv7511_bridge_attach,\n\t.detect = adv7511_bridge_detect,\n\t.get_edid = adv7511_bridge_get_edid,\n\t.hpd_notify = adv7511_bridge_hpd_notify,\n};\n\n \n\nstatic const char * const adv7511_supply_names[] = {\n\t\"avdd\",\n\t\"dvdd\",\n\t\"pvdd\",\n\t\"bgvdd\",\n\t\"dvdd-3v\",\n};\n\nstatic const char * const adv7533_supply_names[] = {\n\t\"avdd\",\n\t\"dvdd\",\n\t\"pvdd\",\n\t\"a2vdd\",\n\t\"v3p3\",\n\t\"v1p2\",\n};\n\nstatic int adv7511_init_regulators(struct adv7511 *adv)\n{\n\tstruct device *dev = &adv->i2c_main->dev;\n\tconst char * const *supply_names;\n\tunsigned int i;\n\tint ret;\n\n\tif (adv->type == ADV7511) {\n\t\tsupply_names = adv7511_supply_names;\n\t\tadv->num_supplies = ARRAY_SIZE(adv7511_supply_names);\n\t} else {\n\t\tsupply_names = adv7533_supply_names;\n\t\tadv->num_supplies = ARRAY_SIZE(adv7533_supply_names);\n\t}\n\n\tadv->supplies = devm_kcalloc(dev, adv->num_supplies,\n\t\t\t\t     sizeof(*adv->supplies), GFP_KERNEL);\n\tif (!adv->supplies)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < adv->num_supplies; i++)\n\t\tadv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, adv->num_supplies, adv->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regulator_bulk_enable(adv->num_supplies, adv->supplies);\n}\n\nstatic void adv7511_uninit_regulators(struct adv7511 *adv)\n{\n\tregulator_bulk_disable(adv->num_supplies, adv->supplies);\n}\n\nstatic bool adv7511_cec_register_volatile(struct device *dev, unsigned int reg)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct adv7511 *adv7511 = i2c_get_clientdata(i2c);\n\n\treg -= adv7511->reg_cec_offset;\n\n\tswitch (reg) {\n\tcase ADV7511_REG_CEC_RX1_FRAME_HDR:\n\tcase ADV7511_REG_CEC_RX1_FRAME_DATA0 ... ADV7511_REG_CEC_RX1_FRAME_DATA0 + 14:\n\tcase ADV7511_REG_CEC_RX1_FRAME_LEN:\n\tcase ADV7511_REG_CEC_RX2_FRAME_HDR:\n\tcase ADV7511_REG_CEC_RX2_FRAME_DATA0 ... ADV7511_REG_CEC_RX2_FRAME_DATA0 + 14:\n\tcase ADV7511_REG_CEC_RX2_FRAME_LEN:\n\tcase ADV7511_REG_CEC_RX3_FRAME_HDR:\n\tcase ADV7511_REG_CEC_RX3_FRAME_DATA0 ... ADV7511_REG_CEC_RX3_FRAME_DATA0 + 14:\n\tcase ADV7511_REG_CEC_RX3_FRAME_LEN:\n\tcase ADV7511_REG_CEC_RX_STATUS:\n\tcase ADV7511_REG_CEC_RX_BUFFERS:\n\tcase ADV7511_REG_CEC_TX_LOW_DRV_CNT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config adv7511_cec_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0xff,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = adv7511_cec_register_volatile,\n};\n\nstatic int adv7511_init_cec_regmap(struct adv7511 *adv)\n{\n\tint ret;\n\n\tadv->i2c_cec = i2c_new_ancillary_device(adv->i2c_main, \"cec\",\n\t\t\t\t\t\tADV7511_CEC_I2C_ADDR_DEFAULT);\n\tif (IS_ERR(adv->i2c_cec))\n\t\treturn PTR_ERR(adv->i2c_cec);\n\n\tregmap_write(adv->regmap, ADV7511_REG_CEC_I2C_ADDR,\n\t\t     adv->i2c_cec->addr << 1);\n\n\ti2c_set_clientdata(adv->i2c_cec, adv);\n\n\tadv->regmap_cec = devm_regmap_init_i2c(adv->i2c_cec,\n\t\t\t\t\t&adv7511_cec_regmap_config);\n\tif (IS_ERR(adv->regmap_cec)) {\n\t\tret = PTR_ERR(adv->regmap_cec);\n\t\tgoto err;\n\t}\n\n\tif (adv->type == ADV7533 || adv->type == ADV7535) {\n\t\tret = adv7533_patch_cec_registers(adv);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tadv->reg_cec_offset = ADV7533_REG_CEC_OFFSET;\n\t}\n\n\treturn 0;\nerr:\n\ti2c_unregister_device(adv->i2c_cec);\n\treturn ret;\n}\n\nstatic int adv7511_parse_dt(struct device_node *np,\n\t\t\t    struct adv7511_link_config *config)\n{\n\tconst char *str;\n\tint ret;\n\n\tof_property_read_u32(np, \"adi,input-depth\", &config->input_color_depth);\n\tif (config->input_color_depth != 8 && config->input_color_depth != 10 &&\n\t    config->input_color_depth != 12)\n\t\treturn -EINVAL;\n\n\tret = of_property_read_string(np, \"adi,input-colorspace\", &str);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!strcmp(str, \"rgb\"))\n\t\tconfig->input_colorspace = HDMI_COLORSPACE_RGB;\n\telse if (!strcmp(str, \"yuv422\"))\n\t\tconfig->input_colorspace = HDMI_COLORSPACE_YUV422;\n\telse if (!strcmp(str, \"yuv444\"))\n\t\tconfig->input_colorspace = HDMI_COLORSPACE_YUV444;\n\telse\n\t\treturn -EINVAL;\n\n\tret = of_property_read_string(np, \"adi,input-clock\", &str);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!strcmp(str, \"1x\"))\n\t\tconfig->input_clock = ADV7511_INPUT_CLOCK_1X;\n\telse if (!strcmp(str, \"2x\"))\n\t\tconfig->input_clock = ADV7511_INPUT_CLOCK_2X;\n\telse if (!strcmp(str, \"ddr\"))\n\t\tconfig->input_clock = ADV7511_INPUT_CLOCK_DDR;\n\telse\n\t\treturn -EINVAL;\n\n\tif (config->input_colorspace == HDMI_COLORSPACE_YUV422 ||\n\t    config->input_clock != ADV7511_INPUT_CLOCK_1X) {\n\t\tret = of_property_read_u32(np, \"adi,input-style\",\n\t\t\t\t\t   &config->input_style);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (config->input_style < 1 || config->input_style > 3)\n\t\t\treturn -EINVAL;\n\n\t\tret = of_property_read_string(np, \"adi,input-justification\",\n\t\t\t\t\t      &str);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!strcmp(str, \"left\"))\n\t\t\tconfig->input_justification =\n\t\t\t\tADV7511_INPUT_JUSTIFICATION_LEFT;\n\t\telse if (!strcmp(str, \"evenly\"))\n\t\t\tconfig->input_justification =\n\t\t\t\tADV7511_INPUT_JUSTIFICATION_EVENLY;\n\t\telse if (!strcmp(str, \"right\"))\n\t\t\tconfig->input_justification =\n\t\t\t\tADV7511_INPUT_JUSTIFICATION_RIGHT;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t} else {\n\t\tconfig->input_style = 1;\n\t\tconfig->input_justification = ADV7511_INPUT_JUSTIFICATION_LEFT;\n\t}\n\n\tof_property_read_u32(np, \"adi,clock-delay\", &config->clock_delay);\n\tif (config->clock_delay < -1200 || config->clock_delay > 1600)\n\t\treturn -EINVAL;\n\n\tconfig->embedded_sync = of_property_read_bool(np, \"adi,embedded-sync\");\n\n\t \n\tconfig->sync_pulse = ADV7511_INPUT_SYNC_PULSE_NONE;\n\tconfig->vsync_polarity = ADV7511_SYNC_POLARITY_PASSTHROUGH;\n\tconfig->hsync_polarity = ADV7511_SYNC_POLARITY_PASSTHROUGH;\n\n\treturn 0;\n}\n\nstatic int adv7511_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(i2c);\n\tstruct adv7511_link_config link_config;\n\tstruct adv7511 *adv7511;\n\tstruct device *dev = &i2c->dev;\n\tunsigned int val;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn -EINVAL;\n\n\tadv7511 = devm_kzalloc(dev, sizeof(*adv7511), GFP_KERNEL);\n\tif (!adv7511)\n\t\treturn -ENOMEM;\n\n\tadv7511->i2c_main = i2c;\n\tadv7511->powered = false;\n\tadv7511->status = connector_status_disconnected;\n\n\tif (dev->of_node)\n\t\tadv7511->type = (enum adv7511_type)of_device_get_match_data(dev);\n\telse\n\t\tadv7511->type = id->driver_data;\n\n\tmemset(&link_config, 0, sizeof(link_config));\n\n\tif (adv7511->type == ADV7511)\n\t\tret = adv7511_parse_dt(dev->of_node, &link_config);\n\telse\n\t\tret = adv7533_parse_dt(dev->of_node, adv7511);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adv7511_init_regulators(adv7511);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to init regulators\\n\");\n\n\t \n\tadv7511->gpio_pd = devm_gpiod_get_optional(dev, \"pd\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(adv7511->gpio_pd)) {\n\t\tret = PTR_ERR(adv7511->gpio_pd);\n\t\tgoto uninit_regulators;\n\t}\n\n\tif (adv7511->gpio_pd) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(adv7511->gpio_pd, 0);\n\t}\n\n\tadv7511->regmap = devm_regmap_init_i2c(i2c, &adv7511_regmap_config);\n\tif (IS_ERR(adv7511->regmap)) {\n\t\tret = PTR_ERR(adv7511->regmap);\n\t\tgoto uninit_regulators;\n\t}\n\n\tret = regmap_read(adv7511->regmap, ADV7511_REG_CHIP_REVISION, &val);\n\tif (ret)\n\t\tgoto uninit_regulators;\n\tdev_dbg(dev, \"Rev. %d\\n\", val);\n\n\tif (adv7511->type == ADV7511)\n\t\tret = regmap_register_patch(adv7511->regmap,\n\t\t\t\t\t    adv7511_fixed_registers,\n\t\t\t\t\t    ARRAY_SIZE(adv7511_fixed_registers));\n\telse\n\t\tret = adv7533_patch_registers(adv7511);\n\tif (ret)\n\t\tgoto uninit_regulators;\n\n\tadv7511_packet_disable(adv7511, 0xffff);\n\n\tadv7511->i2c_edid = i2c_new_ancillary_device(i2c, \"edid\",\n\t\t\t\t\tADV7511_EDID_I2C_ADDR_DEFAULT);\n\tif (IS_ERR(adv7511->i2c_edid)) {\n\t\tret = PTR_ERR(adv7511->i2c_edid);\n\t\tgoto uninit_regulators;\n\t}\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_EDID_I2C_ADDR,\n\t\t     adv7511->i2c_edid->addr << 1);\n\n\tadv7511->i2c_packet = i2c_new_ancillary_device(i2c, \"packet\",\n\t\t\t\t\tADV7511_PACKET_I2C_ADDR_DEFAULT);\n\tif (IS_ERR(adv7511->i2c_packet)) {\n\t\tret = PTR_ERR(adv7511->i2c_packet);\n\t\tgoto err_i2c_unregister_edid;\n\t}\n\n\tregmap_write(adv7511->regmap, ADV7511_REG_PACKET_I2C_ADDR,\n\t\t     adv7511->i2c_packet->addr << 1);\n\n\tret = adv7511_init_cec_regmap(adv7511);\n\tif (ret)\n\t\tgoto err_i2c_unregister_packet;\n\n\tINIT_WORK(&adv7511->hpd_work, adv7511_hpd_work);\n\n\tif (i2c->irq) {\n\t\tinit_waitqueue_head(&adv7511->wq);\n\n\t\tret = devm_request_threaded_irq(dev, i2c->irq, NULL,\n\t\t\t\t\t\tadv7511_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, dev_name(dev),\n\t\t\t\t\t\tadv7511);\n\t\tif (ret)\n\t\t\tgoto err_unregister_cec;\n\t}\n\n\tadv7511_power_off(adv7511);\n\n\ti2c_set_clientdata(i2c, adv7511);\n\n\tif (adv7511->type == ADV7511)\n\t\tadv7511_set_link_config(adv7511, &link_config);\n\n\tret = adv7511_cec_init(dev, adv7511);\n\tif (ret)\n\t\tgoto err_unregister_cec;\n\n\tadv7511->bridge.funcs = &adv7511_bridge_funcs;\n\tadv7511->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID;\n\tif (adv7511->i2c_main->irq)\n\t\tadv7511->bridge.ops |= DRM_BRIDGE_OP_HPD;\n\n\tadv7511->bridge.of_node = dev->of_node;\n\tadv7511->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\n\tdrm_bridge_add(&adv7511->bridge);\n\n\tadv7511_audio_init(dev, adv7511);\n\n\tif (adv7511->type == ADV7533 || adv7511->type == ADV7535) {\n\t\tret = adv7533_attach_dsi(adv7511);\n\t\tif (ret)\n\t\t\tgoto err_unregister_audio;\n\t}\n\n\treturn 0;\n\nerr_unregister_audio:\n\tadv7511_audio_exit(adv7511);\n\tdrm_bridge_remove(&adv7511->bridge);\nerr_unregister_cec:\n\tcec_unregister_adapter(adv7511->cec_adap);\n\ti2c_unregister_device(adv7511->i2c_cec);\n\tclk_disable_unprepare(adv7511->cec_clk);\nerr_i2c_unregister_packet:\n\ti2c_unregister_device(adv7511->i2c_packet);\nerr_i2c_unregister_edid:\n\ti2c_unregister_device(adv7511->i2c_edid);\nuninit_regulators:\n\tadv7511_uninit_regulators(adv7511);\n\n\treturn ret;\n}\n\nstatic void adv7511_remove(struct i2c_client *i2c)\n{\n\tstruct adv7511 *adv7511 = i2c_get_clientdata(i2c);\n\n\tadv7511_uninit_regulators(adv7511);\n\n\tdrm_bridge_remove(&adv7511->bridge);\n\n\tadv7511_audio_exit(adv7511);\n\n\tcec_unregister_adapter(adv7511->cec_adap);\n\ti2c_unregister_device(adv7511->i2c_cec);\n\tclk_disable_unprepare(adv7511->cec_clk);\n\n\ti2c_unregister_device(adv7511->i2c_packet);\n\ti2c_unregister_device(adv7511->i2c_edid);\n}\n\nstatic const struct i2c_device_id adv7511_i2c_ids[] = {\n\t{ \"adv7511\", ADV7511 },\n\t{ \"adv7511w\", ADV7511 },\n\t{ \"adv7513\", ADV7511 },\n\t{ \"adv7533\", ADV7533 },\n\t{ \"adv7535\", ADV7535 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adv7511_i2c_ids);\n\nstatic const struct of_device_id adv7511_of_ids[] = {\n\t{ .compatible = \"adi,adv7511\", .data = (void *)ADV7511 },\n\t{ .compatible = \"adi,adv7511w\", .data = (void *)ADV7511 },\n\t{ .compatible = \"adi,adv7513\", .data = (void *)ADV7511 },\n\t{ .compatible = \"adi,adv7533\", .data = (void *)ADV7533 },\n\t{ .compatible = \"adi,adv7535\", .data = (void *)ADV7535 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adv7511_of_ids);\n\nstatic struct mipi_dsi_driver adv7533_dsi_driver = {\n\t.driver.name = \"adv7533\",\n};\n\nstatic struct i2c_driver adv7511_driver = {\n\t.driver = {\n\t\t.name = \"adv7511\",\n\t\t.of_match_table = adv7511_of_ids,\n\t},\n\t.id_table = adv7511_i2c_ids,\n\t.probe = adv7511_probe,\n\t.remove = adv7511_remove,\n};\n\nstatic int __init adv7511_init(void)\n{\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI)) {\n\t\tret = mipi_dsi_driver_register(&adv7533_dsi_driver);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = i2c_add_driver(&adv7511_driver);\n\tif (ret) {\n\t\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI))\n\t\t\tmipi_dsi_driver_unregister(&adv7533_dsi_driver);\n\t}\n\n\treturn ret;\n}\nmodule_init(adv7511_init);\n\nstatic void __exit adv7511_exit(void)\n{\n\ti2c_del_driver(&adv7511_driver);\n\n\tif (IS_ENABLED(CONFIG_DRM_MIPI_DSI))\n\t\tmipi_dsi_driver_unregister(&adv7533_dsi_driver);\n}\nmodule_exit(adv7511_exit);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"ADV7511 HDMI transmitter driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}