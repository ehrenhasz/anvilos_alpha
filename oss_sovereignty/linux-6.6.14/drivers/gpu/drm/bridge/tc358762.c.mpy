{
  "module_name": "tc358762.c",
  "hash_id": "562908d0c33aa43d5691771b8e6ec1a453273b2de4c332f0732be18e0e4f9dc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/tc358762.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n\n#include <video/mipi_display.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n \n#define PPI_STARTPPI\t\t0x0104  \n#define PPI_LPTXTIMECNT\t\t0x0114  \n#define PPI_D0S_ATMR\t\t0x0144\n#define PPI_D1S_ATMR\t\t0x0148\n#define PPI_D0S_CLRSIPOCOUNT\t0x0164  \n#define PPI_D1S_CLRSIPOCOUNT\t0x0168  \n#define PPI_START_FUNCTION\t1\n\n \n#define DSI_STARTDSI\t\t0x0204  \n#define DSI_LANEENABLE\t\t0x0210  \n#define DSI_RX_START\t\t1\n\n \n#define LCDCTRL\t\t\t0x0420  \n#define LCDCTRL_MSF\t\tBIT(0)  \n#define LCDCTRL_VTGEN\t\tBIT(4) \n#define LCDCTRL_UNK6\t\tBIT(6)  \n#define LCDCTRL_EVTMODE\t\tBIT(5)  \n#define LCDCTRL_RGB888\t\tBIT(8)  \n#define LCDCTRL_HSPOL\t\tBIT(17)  \n#define LCDCTRL_DEPOL\t\tBIT(18)  \n#define LCDCTRL_VSPOL\t\tBIT(19)  \n#define LCDCTRL_VSDELAY(v)\t(((v) & 0xfff) << 20)  \n\n \n#define SPICMR\t\t\t0x0450\n#define SPITCR\t\t\t0x0454\n\n \n#define SYSCTRL\t\t\t0x0464\n\n \n#define LPX_PERIOD\t\t3\n\n \n#define LANEENABLE_CLEN\t\tBIT(0)\n#define LANEENABLE_L0EN\t\tBIT(1)\n#define LANEENABLE_L1EN\t\tBIT(2)\n\nstruct tc358762 {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct regulator *regulator;\n\tstruct drm_bridge *panel_bridge;\n\tstruct gpio_desc *reset_gpio;\n\tstruct drm_display_mode mode;\n\tbool pre_enabled;\n\tint error;\n};\n\nstatic int tc358762_clear_error(struct tc358762 *ctx)\n{\n\tint ret = ctx->error;\n\n\tctx->error = 0;\n\treturn ret;\n}\n\nstatic void tc358762_write(struct tc358762 *ctx, u16 addr, u32 val)\n{\n\tstruct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);\n\tssize_t ret;\n\tu8 data[6];\n\n\tif (ctx->error)\n\t\treturn;\n\n\tdata[0] = addr;\n\tdata[1] = addr >> 8;\n\tdata[2] = val;\n\tdata[3] = val >> 8;\n\tdata[4] = val >> 16;\n\tdata[5] = val >> 24;\n\n\tret = mipi_dsi_generic_write(dsi, data, sizeof(data));\n\tif (ret < 0)\n\t\tctx->error = ret;\n}\n\nstatic inline struct tc358762 *bridge_to_tc358762(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct tc358762, bridge);\n}\n\nstatic int tc358762_init(struct tc358762 *ctx)\n{\n\tu32 lcdctrl;\n\n\ttc358762_write(ctx, DSI_LANEENABLE,\n\t\t       LANEENABLE_L0EN | LANEENABLE_CLEN);\n\ttc358762_write(ctx, PPI_D0S_CLRSIPOCOUNT, 5);\n\ttc358762_write(ctx, PPI_D1S_CLRSIPOCOUNT, 5);\n\ttc358762_write(ctx, PPI_D0S_ATMR, 0);\n\ttc358762_write(ctx, PPI_D1S_ATMR, 0);\n\ttc358762_write(ctx, PPI_LPTXTIMECNT, LPX_PERIOD);\n\n\ttc358762_write(ctx, SPICMR, 0x00);\n\n\tlcdctrl = LCDCTRL_VSDELAY(1) | LCDCTRL_RGB888 |\n\t\t  LCDCTRL_UNK6 | LCDCTRL_VTGEN;\n\n\tif (ctx->mode.flags & DRM_MODE_FLAG_NHSYNC)\n\t\tlcdctrl |= LCDCTRL_HSPOL;\n\n\tif (ctx->mode.flags & DRM_MODE_FLAG_NVSYNC)\n\t\tlcdctrl |= LCDCTRL_VSPOL;\n\n\ttc358762_write(ctx, LCDCTRL, lcdctrl);\n\n\ttc358762_write(ctx, SYSCTRL, 0x040f);\n\tmsleep(100);\n\n\ttc358762_write(ctx, PPI_STARTPPI, PPI_START_FUNCTION);\n\ttc358762_write(ctx, DSI_STARTDSI, DSI_RX_START);\n\n\tmsleep(100);\n\n\treturn tc358762_clear_error(ctx);\n}\n\nstatic void tc358762_post_disable(struct drm_bridge *bridge, struct drm_bridge_state *state)\n{\n\tstruct tc358762 *ctx = bridge_to_tc358762(bridge);\n\tint ret;\n\n\t \n\tif (!ctx->pre_enabled)\n\t\treturn;\n\n\tctx->pre_enabled = false;\n\n\tif (ctx->reset_gpio)\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 0);\n\n\tret = regulator_disable(ctx->regulator);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"error disabling regulators (%d)\\n\", ret);\n}\n\nstatic void tc358762_pre_enable(struct drm_bridge *bridge, struct drm_bridge_state *state)\n{\n\tstruct tc358762 *ctx = bridge_to_tc358762(bridge);\n\tint ret;\n\n\tret = regulator_enable(ctx->regulator);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"error enabling regulators (%d)\\n\", ret);\n\n\tif (ctx->reset_gpio) {\n\t\tgpiod_set_value_cansleep(ctx->reset_gpio, 1);\n\t\tusleep_range(5000, 10000);\n\t}\n\n\tctx->pre_enabled = true;\n}\n\nstatic void tc358762_enable(struct drm_bridge *bridge, struct drm_bridge_state *state)\n{\n\tstruct tc358762 *ctx = bridge_to_tc358762(bridge);\n\tint ret;\n\n\tret = tc358762_init(ctx);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"error initializing bridge (%d)\\n\", ret);\n}\n\nstatic int tc358762_attach(struct drm_bridge *bridge,\n\t\t\t   enum drm_bridge_attach_flags flags)\n{\n\tstruct tc358762 *ctx = bridge_to_tc358762(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, ctx->panel_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic void tc358762_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t     const struct drm_display_mode *mode,\n\t\t\t\t     const struct drm_display_mode *adj)\n{\n\tstruct tc358762 *ctx = bridge_to_tc358762(bridge);\n\n\tdrm_mode_copy(&ctx->mode, mode);\n}\n\nstatic const struct drm_bridge_funcs tc358762_bridge_funcs = {\n\t.atomic_post_disable = tc358762_post_disable,\n\t.atomic_pre_enable = tc358762_pre_enable,\n\t.atomic_enable = tc358762_enable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.attach = tc358762_attach,\n\t.mode_set = tc358762_bridge_mode_set,\n};\n\nstatic int tc358762_parse_dt(struct tc358762 *ctx)\n{\n\tstruct drm_bridge *panel_bridge;\n\tstruct device *dev = ctx->dev;\n\n\tpanel_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 1, 0);\n\tif (IS_ERR(panel_bridge))\n\t\treturn PTR_ERR(panel_bridge);\n\n\tctx->panel_bridge = panel_bridge;\n\n\t \n\tctx->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->reset_gpio))\n\t\treturn PTR_ERR(ctx->reset_gpio);\n\n\treturn 0;\n}\n\nstatic int tc358762_configure_regulators(struct tc358762 *ctx)\n{\n\tctx->regulator = devm_regulator_get(ctx->dev, \"vddc\");\n\tif (IS_ERR(ctx->regulator))\n\t\treturn PTR_ERR(ctx->regulator);\n\n\treturn 0;\n}\n\nstatic int tc358762_probe(struct mipi_dsi_device *dsi)\n{\n\tstruct device *dev = &dsi->dev;\n\tstruct tc358762 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(struct tc358762), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmipi_dsi_set_drvdata(dsi, ctx);\n\n\tctx->dev = dev;\n\tctx->pre_enabled = false;\n\n\t \n\tdsi->lanes = 1;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t  MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_VIDEO_HSE;\n\n\tret = tc358762_parse_dt(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tc358762_configure_regulators(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->bridge.funcs = &tc358762_bridge_funcs;\n\tctx->bridge.type = DRM_MODE_CONNECTOR_DPI;\n\tctx->bridge.of_node = dev->of_node;\n\tctx->bridge.pre_enable_prev_first = true;\n\n\tdrm_bridge_add(&ctx->bridge);\n\n\tret = mipi_dsi_attach(dsi);\n\tif (ret < 0) {\n\t\tdrm_bridge_remove(&ctx->bridge);\n\t\tdev_err(dev, \"failed to attach dsi\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void tc358762_remove(struct mipi_dsi_device *dsi)\n{\n\tstruct tc358762 *ctx = mipi_dsi_get_drvdata(dsi);\n\n\tmipi_dsi_detach(dsi);\n\tdrm_bridge_remove(&ctx->bridge);\n}\n\nstatic const struct of_device_id tc358762_of_match[] = {\n\t{ .compatible = \"toshiba,tc358762\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tc358762_of_match);\n\nstatic struct mipi_dsi_driver tc358762_driver = {\n\t.probe = tc358762_probe,\n\t.remove = tc358762_remove,\n\t.driver = {\n\t\t.name = \"tc358762\",\n\t\t.of_match_table = tc358762_of_match,\n\t},\n};\nmodule_mipi_dsi_driver(tc358762_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"MIPI-DSI based Driver for TC358762 DSI/DPI Bridge\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}