{
  "module_name": "megachips-stdpxxxx-ge-b850v3-fw.c",
  "hash_id": "b15d9bd2ec0fb6e0377b458a0777e92f53b6c5d4c8495d2bf18a12d2f2d82ff7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/megachips-stdpxxxx-ge-b850v3-fw.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define EDID_EXT_BLOCK_CNT 0x7E\n\n#define STDP4028_IRQ_OUT_CONF_REG 0x02\n#define STDP4028_DPTX_IRQ_EN_REG 0x3C\n#define STDP4028_DPTX_IRQ_STS_REG 0x3D\n#define STDP4028_DPTX_STS_REG 0x3E\n\n#define STDP4028_DPTX_DP_IRQ_EN 0x1000\n\n#define STDP4028_DPTX_HOTPLUG_IRQ_EN 0x0400\n#define STDP4028_DPTX_LINK_CH_IRQ_EN 0x2000\n#define STDP4028_DPTX_IRQ_CONFIG \\\n\t\t(STDP4028_DPTX_LINK_CH_IRQ_EN | STDP4028_DPTX_HOTPLUG_IRQ_EN)\n\n#define STDP4028_DPTX_HOTPLUG_STS 0x0200\n#define STDP4028_DPTX_LINK_STS 0x1000\n#define STDP4028_CON_STATE_CONNECTED \\\n\t\t(STDP4028_DPTX_HOTPLUG_STS | STDP4028_DPTX_LINK_STS)\n\n#define STDP4028_DPTX_HOTPLUG_CH_STS 0x0400\n#define STDP4028_DPTX_LINK_CH_STS 0x2000\n#define STDP4028_DPTX_IRQ_CLEAR \\\n\t\t(STDP4028_DPTX_LINK_CH_STS | STDP4028_DPTX_HOTPLUG_CH_STS)\n\nstatic DEFINE_MUTEX(ge_b850v3_lvds_dev_mutex);\n\nstruct ge_b850v3_lvds {\n\tstruct drm_connector connector;\n\tstruct drm_bridge bridge;\n\tstruct i2c_client *stdp4028_i2c;\n\tstruct i2c_client *stdp2690_i2c;\n};\n\nstatic struct ge_b850v3_lvds *ge_b850v3_lvds_ptr;\n\nstatic u8 *stdp2690_get_edid(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tunsigned char start = 0x00;\n\tunsigned int total_size;\n\tu8 *block = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= 0,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &start,\n\t\t}, {\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags\t= I2C_M_RD,\n\t\t\t.len\t= EDID_LENGTH,\n\t\t\t.buf\t= block,\n\t\t}\n\t};\n\n\tif (!block)\n\t\treturn NULL;\n\n\tif (i2c_transfer(adapter, msgs, 2) != 2) {\n\t\tDRM_ERROR(\"Unable to read EDID.\\n\");\n\t\tgoto err;\n\t}\n\n\tif (!drm_edid_block_valid(block, 0, false, NULL)) {\n\t\tDRM_ERROR(\"Invalid EDID data\\n\");\n\t\tgoto err;\n\t}\n\n\ttotal_size = (block[EDID_EXT_BLOCK_CNT] + 1) * EDID_LENGTH;\n\tif (total_size > EDID_LENGTH) {\n\t\tkfree(block);\n\t\tblock = kmalloc(total_size, GFP_KERNEL);\n\t\tif (!block)\n\t\t\treturn NULL;\n\n\t\t \n\t\tstart = 0x00;\n\t\tmsgs[1].len = total_size;\n\t\tmsgs[1].buf = block;\n\n\t\tif (i2c_transfer(adapter, msgs, 2) != 2) {\n\t\t\tDRM_ERROR(\"Unable to read EDID extension blocks.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (!drm_edid_block_valid(block, 1, false, NULL)) {\n\t\t\tDRM_ERROR(\"Invalid EDID data\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn block;\n\nerr:\n\tkfree(block);\n\treturn NULL;\n}\n\nstatic struct edid *ge_b850v3_lvds_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct i2c_client *client;\n\n\tclient = ge_b850v3_lvds_ptr->stdp2690_i2c;\n\n\treturn (struct edid *)stdp2690_get_edid(client);\n}\n\nstatic int ge_b850v3_lvds_get_modes(struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\tint num_modes;\n\n\tedid = ge_b850v3_lvds_get_edid(&ge_b850v3_lvds_ptr->bridge, connector);\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tnum_modes = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn num_modes;\n}\n\nstatic enum drm_mode_status ge_b850v3_lvds_mode_valid(\n\t\tstruct drm_connector *connector, struct drm_display_mode *mode)\n{\n\treturn MODE_OK;\n}\n\nstatic const struct\ndrm_connector_helper_funcs ge_b850v3_lvds_connector_helper_funcs = {\n\t.get_modes = ge_b850v3_lvds_get_modes,\n\t.mode_valid = ge_b850v3_lvds_mode_valid,\n};\n\nstatic enum drm_connector_status ge_b850v3_lvds_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct i2c_client *stdp4028_i2c =\n\t\t\tge_b850v3_lvds_ptr->stdp4028_i2c;\n\ts32 link_state;\n\n\tlink_state = i2c_smbus_read_word_data(stdp4028_i2c,\n\t\t\t\t\t      STDP4028_DPTX_STS_REG);\n\n\tif (link_state == STDP4028_CON_STATE_CONNECTED)\n\t\treturn connector_status_connected;\n\n\tif (link_state == 0)\n\t\treturn connector_status_disconnected;\n\n\treturn connector_status_unknown;\n}\n\nstatic enum drm_connector_status ge_b850v3_lvds_detect(struct drm_connector *connector,\n\t\t\t\t\t\t       bool force)\n{\n\treturn ge_b850v3_lvds_bridge_detect(&ge_b850v3_lvds_ptr->bridge);\n}\n\nstatic const struct drm_connector_funcs ge_b850v3_lvds_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = ge_b850v3_lvds_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ge_b850v3_lvds_create_connector(struct drm_bridge *bridge)\n{\n\tstruct drm_connector *connector = &ge_b850v3_lvds_ptr->connector;\n\tint ret;\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_helper_add(connector,\n\t\t\t\t &ge_b850v3_lvds_connector_helper_funcs);\n\n\tret = drm_connector_init(bridge->dev, connector,\n\t\t\t\t &ge_b850v3_lvds_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\n\treturn drm_connector_attach_encoder(connector, bridge->encoder);\n}\n\nstatic irqreturn_t ge_b850v3_lvds_irq_handler(int irq, void *dev_id)\n{\n\tstruct i2c_client *stdp4028_i2c\n\t\t\t= ge_b850v3_lvds_ptr->stdp4028_i2c;\n\n\ti2c_smbus_write_word_data(stdp4028_i2c,\n\t\t\t\t  STDP4028_DPTX_IRQ_STS_REG,\n\t\t\t\t  STDP4028_DPTX_IRQ_CLEAR);\n\n\tif (ge_b850v3_lvds_ptr->bridge.dev)\n\t\tdrm_kms_helper_hotplug_event(ge_b850v3_lvds_ptr->bridge.dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ge_b850v3_lvds_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct i2c_client *stdp4028_i2c\n\t\t\t= ge_b850v3_lvds_ptr->stdp4028_i2c;\n\n\t \n\ti2c_smbus_write_word_data(stdp4028_i2c,\n\t\t\t\t  STDP4028_IRQ_OUT_CONF_REG,\n\t\t\t\t  STDP4028_DPTX_DP_IRQ_EN);\n\n\t \n\ti2c_smbus_write_word_data(stdp4028_i2c,\n\t\t\t\t  STDP4028_DPTX_IRQ_EN_REG,\n\t\t\t\t  STDP4028_DPTX_IRQ_CONFIG);\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\treturn ge_b850v3_lvds_create_connector(bridge);\n}\n\nstatic const struct drm_bridge_funcs ge_b850v3_lvds_funcs = {\n\t.attach = ge_b850v3_lvds_attach,\n\t.detect = ge_b850v3_lvds_bridge_detect,\n\t.get_edid = ge_b850v3_lvds_get_edid,\n};\n\nstatic int ge_b850v3_lvds_init(struct device *dev)\n{\n\tmutex_lock(&ge_b850v3_lvds_dev_mutex);\n\n\tif (ge_b850v3_lvds_ptr)\n\t\tgoto success;\n\n\tge_b850v3_lvds_ptr = devm_kzalloc(dev,\n\t\t\t\t\t  sizeof(*ge_b850v3_lvds_ptr),\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!ge_b850v3_lvds_ptr) {\n\t\tmutex_unlock(&ge_b850v3_lvds_dev_mutex);\n\t\treturn -ENOMEM;\n\t}\n\nsuccess:\n\tmutex_unlock(&ge_b850v3_lvds_dev_mutex);\n\treturn 0;\n}\n\nstatic void ge_b850v3_lvds_remove(void)\n{\n\tmutex_lock(&ge_b850v3_lvds_dev_mutex);\n\t \n\tif (!ge_b850v3_lvds_ptr ||\n\t    !ge_b850v3_lvds_ptr->stdp2690_i2c ||\n\t\t!ge_b850v3_lvds_ptr->stdp4028_i2c)\n\t\tgoto out;\n\n\tdrm_bridge_remove(&ge_b850v3_lvds_ptr->bridge);\n\n\tge_b850v3_lvds_ptr = NULL;\nout:\n\tmutex_unlock(&ge_b850v3_lvds_dev_mutex);\n}\n\nstatic int ge_b850v3_register(void)\n{\n\tstruct i2c_client *stdp4028_i2c = ge_b850v3_lvds_ptr->stdp4028_i2c;\n\tstruct device *dev = &stdp4028_i2c->dev;\n\n\t \n\tge_b850v3_lvds_ptr->bridge.funcs = &ge_b850v3_lvds_funcs;\n\tge_b850v3_lvds_ptr->bridge.ops = DRM_BRIDGE_OP_DETECT |\n\t\t\t\t\t DRM_BRIDGE_OP_EDID;\n\tge_b850v3_lvds_ptr->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;\n\tge_b850v3_lvds_ptr->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&ge_b850v3_lvds_ptr->bridge);\n\n\t \n\ti2c_smbus_write_word_data(stdp4028_i2c,\n\t\t\t\t  STDP4028_DPTX_IRQ_STS_REG,\n\t\t\t\t  STDP4028_DPTX_IRQ_CLEAR);\n\n\tif (!stdp4028_i2c->irq)\n\t\treturn 0;\n\n\treturn devm_request_threaded_irq(&stdp4028_i2c->dev,\n\t\t\tstdp4028_i2c->irq, NULL,\n\t\t\tge_b850v3_lvds_irq_handler,\n\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\"ge-b850v3-lvds-dp\", ge_b850v3_lvds_ptr);\n}\n\nstatic int stdp4028_ge_b850v3_fw_probe(struct i2c_client *stdp4028_i2c)\n{\n\tstruct device *dev = &stdp4028_i2c->dev;\n\tint ret;\n\n\tret = ge_b850v3_lvds_init(dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tge_b850v3_lvds_ptr->stdp4028_i2c = stdp4028_i2c;\n\ti2c_set_clientdata(stdp4028_i2c, ge_b850v3_lvds_ptr);\n\n\t \n\tif (!ge_b850v3_lvds_ptr->stdp2690_i2c)\n\t\treturn 0;\n\n\treturn ge_b850v3_register();\n}\n\nstatic void stdp4028_ge_b850v3_fw_remove(struct i2c_client *stdp4028_i2c)\n{\n\tge_b850v3_lvds_remove();\n}\n\nstatic const struct i2c_device_id stdp4028_ge_b850v3_fw_i2c_table[] = {\n\t{\"stdp4028_ge_fw\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, stdp4028_ge_b850v3_fw_i2c_table);\n\nstatic const struct of_device_id stdp4028_ge_b850v3_fw_match[] = {\n\t{ .compatible = \"megachips,stdp4028-ge-b850v3-fw\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stdp4028_ge_b850v3_fw_match);\n\nstatic struct i2c_driver stdp4028_ge_b850v3_fw_driver = {\n\t.id_table\t= stdp4028_ge_b850v3_fw_i2c_table,\n\t.probe\t\t= stdp4028_ge_b850v3_fw_probe,\n\t.remove\t\t= stdp4028_ge_b850v3_fw_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"stdp4028-ge-b850v3-fw\",\n\t\t.of_match_table = stdp4028_ge_b850v3_fw_match,\n\t},\n};\n\nstatic int stdp2690_ge_b850v3_fw_probe(struct i2c_client *stdp2690_i2c)\n{\n\tstruct device *dev = &stdp2690_i2c->dev;\n\tint ret;\n\n\tret = ge_b850v3_lvds_init(dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tge_b850v3_lvds_ptr->stdp2690_i2c = stdp2690_i2c;\n\ti2c_set_clientdata(stdp2690_i2c, ge_b850v3_lvds_ptr);\n\n\t \n\tif (!ge_b850v3_lvds_ptr->stdp4028_i2c)\n\t\treturn 0;\n\n\treturn ge_b850v3_register();\n}\n\nstatic void stdp2690_ge_b850v3_fw_remove(struct i2c_client *stdp2690_i2c)\n{\n\tge_b850v3_lvds_remove();\n}\n\nstatic const struct i2c_device_id stdp2690_ge_b850v3_fw_i2c_table[] = {\n\t{\"stdp2690_ge_fw\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, stdp2690_ge_b850v3_fw_i2c_table);\n\nstatic const struct of_device_id stdp2690_ge_b850v3_fw_match[] = {\n\t{ .compatible = \"megachips,stdp2690-ge-b850v3-fw\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stdp2690_ge_b850v3_fw_match);\n\nstatic struct i2c_driver stdp2690_ge_b850v3_fw_driver = {\n\t.id_table\t= stdp2690_ge_b850v3_fw_i2c_table,\n\t.probe\t\t= stdp2690_ge_b850v3_fw_probe,\n\t.remove\t\t= stdp2690_ge_b850v3_fw_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"stdp2690-ge-b850v3-fw\",\n\t\t.of_match_table = stdp2690_ge_b850v3_fw_match,\n\t},\n};\n\nstatic int __init stdpxxxx_ge_b850v3_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&stdp4028_ge_b850v3_fw_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_add_driver(&stdp2690_ge_b850v3_fw_driver);\n\tif (ret)\n\t\ti2c_del_driver(&stdp4028_ge_b850v3_fw_driver);\n\n\treturn ret;\n}\nmodule_init(stdpxxxx_ge_b850v3_init);\n\nstatic void __exit stdpxxxx_ge_b850v3_exit(void)\n{\n\ti2c_del_driver(&stdp2690_ge_b850v3_fw_driver);\n\ti2c_del_driver(&stdp4028_ge_b850v3_fw_driver);\n}\nmodule_exit(stdpxxxx_ge_b850v3_exit);\n\nMODULE_AUTHOR(\"Peter Senna Tschudin <peter.senna@collabora.com>\");\nMODULE_AUTHOR(\"Martyn Welch <martyn.welch@collabora.co.uk>\");\nMODULE_DESCRIPTION(\"GE LVDS to DP++ display bridge)\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}