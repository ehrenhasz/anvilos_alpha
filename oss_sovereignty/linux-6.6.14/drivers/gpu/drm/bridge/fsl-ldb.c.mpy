{
  "module_name": "fsl-ldb.c",
  "hash_id": "8ee01fc58baa7f94ba3d106f09607e0dd0867708c6615ee0e1ff29bac3684d94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/fsl-ldb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n\n#define LDB_CTRL_CH0_ENABLE\t\t\tBIT(0)\n#define LDB_CTRL_CH0_DI_SELECT\t\t\tBIT(1)\n#define LDB_CTRL_CH1_ENABLE\t\t\tBIT(2)\n#define LDB_CTRL_CH1_DI_SELECT\t\t\tBIT(3)\n#define LDB_CTRL_SPLIT_MODE\t\t\tBIT(4)\n#define LDB_CTRL_CH0_DATA_WIDTH\t\t\tBIT(5)\n#define LDB_CTRL_CH0_BIT_MAPPING\t\tBIT(6)\n#define LDB_CTRL_CH1_DATA_WIDTH\t\t\tBIT(7)\n#define LDB_CTRL_CH1_BIT_MAPPING\t\tBIT(8)\n#define LDB_CTRL_DI0_VSYNC_POLARITY\t\tBIT(9)\n#define LDB_CTRL_DI1_VSYNC_POLARITY\t\tBIT(10)\n#define LDB_CTRL_REG_CH0_FIFO_RESET\t\tBIT(11)\n#define LDB_CTRL_REG_CH1_FIFO_RESET\t\tBIT(12)\n#define LDB_CTRL_ASYNC_FIFO_ENABLE\t\tBIT(24)\n#define LDB_CTRL_ASYNC_FIFO_THRESHOLD_MASK\tGENMASK(27, 25)\n\n#define LVDS_CTRL_CH0_EN\t\t\tBIT(0)\n#define LVDS_CTRL_CH1_EN\t\t\tBIT(1)\n \n#define LVDS_CTRL_LVDS_EN\t\t\tBIT(1)\n#define LVDS_CTRL_VBG_EN\t\t\tBIT(2)\n#define LVDS_CTRL_HS_EN\t\t\t\tBIT(3)\n#define LVDS_CTRL_PRE_EMPH_EN\t\t\tBIT(4)\n#define LVDS_CTRL_PRE_EMPH_ADJ(n)\t\t(((n) & 0x7) << 5)\n#define LVDS_CTRL_PRE_EMPH_ADJ_MASK\t\tGENMASK(7, 5)\n#define LVDS_CTRL_CM_ADJ(n)\t\t\t(((n) & 0x7) << 8)\n#define LVDS_CTRL_CM_ADJ_MASK\t\t\tGENMASK(10, 8)\n#define LVDS_CTRL_CC_ADJ(n)\t\t\t(((n) & 0x7) << 11)\n#define LVDS_CTRL_CC_ADJ_MASK\t\t\tGENMASK(13, 11)\n#define LVDS_CTRL_SLEW_ADJ(n)\t\t\t(((n) & 0x7) << 14)\n#define LVDS_CTRL_SLEW_ADJ_MASK\t\t\tGENMASK(16, 14)\n#define LVDS_CTRL_VBG_ADJ(n)\t\t\t(((n) & 0x7) << 17)\n#define LVDS_CTRL_VBG_ADJ_MASK\t\t\tGENMASK(19, 17)\n\nenum fsl_ldb_devtype {\n\tIMX6SX_LDB,\n\tIMX8MP_LDB,\n\tIMX93_LDB,\n};\n\nstruct fsl_ldb_devdata {\n\tu32 ldb_ctrl;\n\tu32 lvds_ctrl;\n\tbool lvds_en_bit;\n\tbool single_ctrl_reg;\n};\n\nstatic const struct fsl_ldb_devdata fsl_ldb_devdata[] = {\n\t[IMX6SX_LDB] = {\n\t\t.ldb_ctrl = 0x18,\n\t\t.single_ctrl_reg = true,\n\t},\n\t[IMX8MP_LDB] = {\n\t\t.ldb_ctrl = 0x5c,\n\t\t.lvds_ctrl = 0x128,\n\t},\n\t[IMX93_LDB] = {\n\t\t.ldb_ctrl = 0x20,\n\t\t.lvds_ctrl = 0x24,\n\t\t.lvds_en_bit = true,\n\t},\n};\n\nstruct fsl_ldb {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *panel_bridge;\n\tstruct clk *clk;\n\tstruct regmap *regmap;\n\tconst struct fsl_ldb_devdata *devdata;\n\tbool ch0_enabled;\n\tbool ch1_enabled;\n};\n\nstatic bool fsl_ldb_is_dual(const struct fsl_ldb *fsl_ldb)\n{\n\treturn (fsl_ldb->ch0_enabled && fsl_ldb->ch1_enabled);\n}\n\nstatic inline struct fsl_ldb *to_fsl_ldb(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct fsl_ldb, bridge);\n}\n\nstatic unsigned long fsl_ldb_link_frequency(struct fsl_ldb *fsl_ldb, int clock)\n{\n\tif (fsl_ldb_is_dual(fsl_ldb))\n\t\treturn clock * 3500;\n\telse\n\t\treturn clock * 7000;\n}\n\nstatic int fsl_ldb_attach(struct drm_bridge *bridge,\n\t\t\t  enum drm_bridge_attach_flags flags)\n{\n\tstruct fsl_ldb *fsl_ldb = to_fsl_ldb(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, fsl_ldb->panel_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic void fsl_ldb_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct fsl_ldb *fsl_ldb = to_fsl_ldb(bridge);\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tconst struct drm_bridge_state *bridge_state;\n\tconst struct drm_crtc_state *crtc_state;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tunsigned long configured_link_freq;\n\tunsigned long requested_link_freq;\n\tbool lvds_format_24bpp;\n\tbool lvds_format_jeida;\n\tu32 reg;\n\n\t \n\tbridge_state = drm_atomic_get_new_bridge_state(state, bridge);\n\n\tswitch (bridge_state->output_bus_cfg.format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tlvds_format_24bpp = false;\n\t\tlvds_format_jeida = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = false;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = false;\n\t\tdev_warn(fsl_ldb->dev,\n\t\t\t \"Unsupported LVDS bus format 0x%04x, please check output bridge driver. Falling back to SPWG24.\\n\",\n\t\t\t bridge_state->output_bus_cfg.format);\n\t\tbreak;\n\t}\n\n\t \n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tmode = &crtc_state->adjusted_mode;\n\n\trequested_link_freq = fsl_ldb_link_frequency(fsl_ldb, mode->clock);\n\tclk_set_rate(fsl_ldb->clk, requested_link_freq);\n\n\tconfigured_link_freq = clk_get_rate(fsl_ldb->clk);\n\tif (configured_link_freq != requested_link_freq)\n\t\tdev_warn(fsl_ldb->dev, \"Configured LDB clock (%lu Hz) does not match requested LVDS clock: %lu Hz\\n\",\n\t\t\t configured_link_freq,\n\t\t\t requested_link_freq);\n\n\tclk_prepare_enable(fsl_ldb->clk);\n\n\t \n\treg =\t(fsl_ldb->ch0_enabled ? LDB_CTRL_CH0_ENABLE : 0) |\n\t\t(fsl_ldb->ch1_enabled ? LDB_CTRL_CH1_ENABLE : 0) |\n\t\t(fsl_ldb_is_dual(fsl_ldb) ? LDB_CTRL_SPLIT_MODE : 0);\n\n\tif (lvds_format_24bpp)\n\t\treg |=\t(fsl_ldb->ch0_enabled ? LDB_CTRL_CH0_DATA_WIDTH : 0) |\n\t\t\t(fsl_ldb->ch1_enabled ? LDB_CTRL_CH1_DATA_WIDTH : 0);\n\n\tif (lvds_format_jeida)\n\t\treg |=\t(fsl_ldb->ch0_enabled ? LDB_CTRL_CH0_BIT_MAPPING : 0) |\n\t\t\t(fsl_ldb->ch1_enabled ? LDB_CTRL_CH1_BIT_MAPPING : 0);\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\treg |=\t(fsl_ldb->ch0_enabled ? LDB_CTRL_DI0_VSYNC_POLARITY : 0) |\n\t\t\t(fsl_ldb->ch1_enabled ? LDB_CTRL_DI1_VSYNC_POLARITY : 0);\n\n\tregmap_write(fsl_ldb->regmap, fsl_ldb->devdata->ldb_ctrl, reg);\n\n\tif (fsl_ldb->devdata->single_ctrl_reg)\n\t\treturn;\n\n\t \n\treg = LVDS_CTRL_CC_ADJ(2) | LVDS_CTRL_PRE_EMPH_EN |\n\t      LVDS_CTRL_PRE_EMPH_ADJ(3) | LVDS_CTRL_VBG_EN;\n\tregmap_write(fsl_ldb->regmap, fsl_ldb->devdata->lvds_ctrl, reg);\n\n\t \n\tusleep_range(15, 20);\n\n\treg |=\t(fsl_ldb->ch0_enabled ? LVDS_CTRL_CH0_EN : 0) |\n\t\t(fsl_ldb->ch1_enabled ? LVDS_CTRL_CH1_EN : 0);\n\n\tregmap_write(fsl_ldb->regmap, fsl_ldb->devdata->lvds_ctrl, reg);\n}\n\nstatic void fsl_ldb_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct fsl_ldb *fsl_ldb = to_fsl_ldb(bridge);\n\n\t \n\tif (fsl_ldb->devdata->lvds_en_bit)\n\t\t \n\t\tregmap_write(fsl_ldb->regmap, fsl_ldb->devdata->lvds_ctrl,\n\t\t\t     LVDS_CTRL_LVDS_EN);\n\telse\n\t\tif (!fsl_ldb->devdata->single_ctrl_reg)\n\t\t\tregmap_write(fsl_ldb->regmap, fsl_ldb->devdata->lvds_ctrl, 0);\n\tregmap_write(fsl_ldb->regmap, fsl_ldb->devdata->ldb_ctrl, 0);\n\n\tclk_disable_unprepare(fsl_ldb->clk);\n}\n\n#define MAX_INPUT_SEL_FORMATS 1\nstatic u32 *\nfsl_ldb_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *bridge_state,\n\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t  struct drm_connector_state *conn_state,\n\t\t\t\t  u32 output_fmt,\n\t\t\t\t  unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = MAX_INPUT_SEL_FORMATS;\n\n\treturn input_fmts;\n}\n\nstatic enum drm_mode_status\nfsl_ldb_mode_valid(struct drm_bridge *bridge,\n\t\t   const struct drm_display_info *info,\n\t\t   const struct drm_display_mode *mode)\n{\n\tstruct fsl_ldb *fsl_ldb = to_fsl_ldb(bridge);\n\n\tif (mode->clock > (fsl_ldb_is_dual(fsl_ldb) ? 160000 : 80000))\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs funcs = {\n\t.attach = fsl_ldb_attach,\n\t.atomic_enable = fsl_ldb_atomic_enable,\n\t.atomic_disable = fsl_ldb_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts = fsl_ldb_atomic_get_input_bus_fmts,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.mode_valid = fsl_ldb_mode_valid,\n};\n\nstatic int fsl_ldb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *panel_node;\n\tstruct device_node *remote1, *remote2;\n\tstruct drm_panel *panel;\n\tstruct fsl_ldb *fsl_ldb;\n\tint dual_link;\n\n\tfsl_ldb = devm_kzalloc(dev, sizeof(*fsl_ldb), GFP_KERNEL);\n\tif (!fsl_ldb)\n\t\treturn -ENOMEM;\n\n\tfsl_ldb->devdata = of_device_get_match_data(dev);\n\tif (!fsl_ldb->devdata)\n\t\treturn -EINVAL;\n\n\tfsl_ldb->dev = &pdev->dev;\n\tfsl_ldb->bridge.funcs = &funcs;\n\tfsl_ldb->bridge.of_node = dev->of_node;\n\n\tfsl_ldb->clk = devm_clk_get(dev, \"ldb\");\n\tif (IS_ERR(fsl_ldb->clk))\n\t\treturn PTR_ERR(fsl_ldb->clk);\n\n\tfsl_ldb->regmap = syscon_node_to_regmap(dev->of_node->parent);\n\tif (IS_ERR(fsl_ldb->regmap))\n\t\treturn PTR_ERR(fsl_ldb->regmap);\n\n\t \n\tremote1 = of_graph_get_remote_node(dev->of_node, 1, 0);\n\tremote2 = of_graph_get_remote_node(dev->of_node, 2, 0);\n\tfsl_ldb->ch0_enabled = (remote1 != NULL);\n\tfsl_ldb->ch1_enabled = (remote2 != NULL);\n\tpanel_node = of_node_get(remote1 ? remote1 : remote2);\n\tof_node_put(remote1);\n\tof_node_put(remote2);\n\n\tif (!fsl_ldb->ch0_enabled && !fsl_ldb->ch1_enabled) {\n\t\tof_node_put(panel_node);\n\t\treturn dev_err_probe(dev, -ENXIO, \"No panel node found\");\n\t}\n\n\tdev_dbg(dev, \"Using %s\\n\",\n\t\tfsl_ldb_is_dual(fsl_ldb) ? \"dual-link mode\" :\n\t\tfsl_ldb->ch0_enabled ? \"channel 0\" : \"channel 1\");\n\n\tpanel = of_drm_find_panel(panel_node);\n\tof_node_put(panel_node);\n\tif (IS_ERR(panel))\n\t\treturn PTR_ERR(panel);\n\n\tfsl_ldb->panel_bridge = devm_drm_panel_bridge_add(dev, panel);\n\tif (IS_ERR(fsl_ldb->panel_bridge))\n\t\treturn PTR_ERR(fsl_ldb->panel_bridge);\n\n\n\tif (fsl_ldb_is_dual(fsl_ldb)) {\n\t\tstruct device_node *port1, *port2;\n\n\t\tport1 = of_graph_get_port_by_id(dev->of_node, 1);\n\t\tport2 = of_graph_get_port_by_id(dev->of_node, 2);\n\t\tdual_link = drm_of_lvds_get_dual_link_pixel_order(port1, port2);\n\t\tof_node_put(port1);\n\t\tof_node_put(port2);\n\n\t\tif (dual_link < 0)\n\t\t\treturn dev_err_probe(dev, dual_link,\n\t\t\t\t\t     \"Error getting dual link configuration\\n\");\n\n\t\t \n\t\tif (dual_link == DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS) {\n\t\t\tdev_err(dev, \"LVDS channel pixel swap not supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, fsl_ldb);\n\n\tdrm_bridge_add(&fsl_ldb->bridge);\n\n\treturn 0;\n}\n\nstatic void fsl_ldb_remove(struct platform_device *pdev)\n{\n\tstruct fsl_ldb *fsl_ldb = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&fsl_ldb->bridge);\n}\n\nstatic const struct of_device_id fsl_ldb_match[] = {\n\t{ .compatible = \"fsl,imx6sx-ldb\",\n\t  .data = &fsl_ldb_devdata[IMX6SX_LDB], },\n\t{ .compatible = \"fsl,imx8mp-ldb\",\n\t  .data = &fsl_ldb_devdata[IMX8MP_LDB], },\n\t{ .compatible = \"fsl,imx93-ldb\",\n\t  .data = &fsl_ldb_devdata[IMX93_LDB], },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, fsl_ldb_match);\n\nstatic struct platform_driver fsl_ldb_driver = {\n\t.probe\t= fsl_ldb_probe,\n\t.remove_new = fsl_ldb_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"fsl-ldb\",\n\t\t.of_match_table\t= fsl_ldb_match,\n\t},\n};\nmodule_platform_driver(fsl_ldb_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Freescale i.MX8MP LDB\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}