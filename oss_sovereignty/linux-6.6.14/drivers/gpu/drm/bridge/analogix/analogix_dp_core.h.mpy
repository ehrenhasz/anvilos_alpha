{
  "module_name": "analogix_dp_core.h",
  "hash_id": "e07bd1ebc768ae6dcd4b2d146e38b1296086e6398cf8d27fed2e241c1808a18e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/analogix_dp_core.h",
  "human_readable_source": " \n \n\n#ifndef _ANALOGIX_DP_CORE_H\n#define _ANALOGIX_DP_CORE_H\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_crtc.h>\n\n#define DP_TIMEOUT_LOOP_COUNT 100\n#define MAX_CR_LOOP 5\n#define MAX_EQ_LOOP 5\n#define MAX_PLL_LOCK_LOOP 5\n\n \n#define DP_TIMEOUT_TRAINING_US\t\t\t22000\n#define DP_TIMEOUT_PSR_LOOP_MS\t\t\t300\n\n \n#define DPCD_ENHANCED_FRAME_CAP(x)\t\t(((x) >> 7) & 0x1)\n#define DPCD_MAX_LANE_COUNT(x)\t\t\t((x) & 0x1f)\n\n \n#define DPCD_LANE_COUNT_SET(x)\t\t\t((x) & 0x1f)\n\n \n#define DPCD_PRE_EMPHASIS_SET(x)\t\t(((x) & 0x3) << 3)\n#define DPCD_PRE_EMPHASIS_GET(x)\t\t(((x) >> 3) & 0x3)\n#define DPCD_VOLTAGE_SWING_SET(x)\t\t(((x) & 0x3) << 0)\n#define DPCD_VOLTAGE_SWING_GET(x)\t\t(((x) >> 0) & 0x3)\n\nstruct gpio_desc;\n\nenum link_lane_count_type {\n\tLANE_COUNT1 = 1,\n\tLANE_COUNT2 = 2,\n\tLANE_COUNT4 = 4\n};\n\nenum link_training_state {\n\tSTART,\n\tCLOCK_RECOVERY,\n\tEQUALIZER_TRAINING,\n\tFINISHED,\n\tFAILED\n};\n\nenum voltage_swing_level {\n\tVOLTAGE_LEVEL_0,\n\tVOLTAGE_LEVEL_1,\n\tVOLTAGE_LEVEL_2,\n\tVOLTAGE_LEVEL_3,\n};\n\nenum pre_emphasis_level {\n\tPRE_EMPHASIS_LEVEL_0,\n\tPRE_EMPHASIS_LEVEL_1,\n\tPRE_EMPHASIS_LEVEL_2,\n\tPRE_EMPHASIS_LEVEL_3,\n};\n\nenum pattern_set {\n\tPRBS7,\n\tD10_2,\n\tTRAINING_PTN1,\n\tTRAINING_PTN2,\n\tDP_NONE\n};\n\nenum color_space {\n\tCOLOR_RGB,\n\tCOLOR_YCBCR422,\n\tCOLOR_YCBCR444\n};\n\nenum color_depth {\n\tCOLOR_6,\n\tCOLOR_8,\n\tCOLOR_10,\n\tCOLOR_12\n};\n\nenum color_coefficient {\n\tCOLOR_YCBCR601,\n\tCOLOR_YCBCR709\n};\n\nenum dynamic_range {\n\tVESA,\n\tCEA\n};\n\nenum pll_status {\n\tPLL_UNLOCKED,\n\tPLL_LOCKED\n};\n\nenum clock_recovery_m_value_type {\n\tCALCULATED_M,\n\tREGISTER_M\n};\n\nenum video_timing_recognition_type {\n\tVIDEO_TIMING_FROM_CAPTURE,\n\tVIDEO_TIMING_FROM_REGISTER\n};\n\nenum analog_power_block {\n\tAUX_BLOCK,\n\tCH0_BLOCK,\n\tCH1_BLOCK,\n\tCH2_BLOCK,\n\tCH3_BLOCK,\n\tANALOG_TOTAL,\n\tPOWER_ALL\n};\n\nenum dp_irq_type {\n\tDP_IRQ_TYPE_HP_CABLE_IN  = BIT(0),\n\tDP_IRQ_TYPE_HP_CABLE_OUT = BIT(1),\n\tDP_IRQ_TYPE_HP_CHANGE    = BIT(2),\n\tDP_IRQ_TYPE_UNKNOWN      = BIT(3),\n};\n\nstruct video_info {\n\tchar *name;\n\n\tbool h_sync_polarity;\n\tbool v_sync_polarity;\n\tbool interlaced;\n\n\tenum color_space color_space;\n\tenum dynamic_range dynamic_range;\n\tenum color_coefficient ycbcr_coeff;\n\tenum color_depth color_depth;\n\n\tint max_link_rate;\n\tenum link_lane_count_type max_lane_count;\n};\n\nstruct link_train {\n\tint eq_loop;\n\tint cr_loop[4];\n\n\tu8 link_rate;\n\tu8 lane_count;\n\tu8 training_lane[4];\n\n\tenum link_training_state lt_state;\n};\n\nstruct analogix_dp_device {\n\tstruct drm_encoder\t*encoder;\n\tstruct device\t\t*dev;\n\tstruct drm_device\t*drm_dev;\n\tstruct drm_connector\tconnector;\n\tstruct drm_bridge\t*bridge;\n\tstruct drm_dp_aux       aux;\n\tstruct clk\t\t*clock;\n\tunsigned int\t\tirq;\n\tvoid __iomem\t\t*reg_base;\n\n\tstruct video_info\tvideo_info;\n\tstruct link_train\tlink_train;\n\tstruct phy\t\t*phy;\n\tint\t\t\tdpms_mode;\n\tstruct gpio_desc\t*hpd_gpiod;\n\tbool                    force_hpd;\n\tbool\t\t\tfast_train_enable;\n\tbool\t\t\tpsr_supported;\n\n\tstruct mutex\t\tpanel_lock;\n\tbool\t\t\tpanel_is_modeset;\n\n\tstruct analogix_dp_plat_data *plat_data;\n};\n\n \nvoid analogix_dp_enable_video_mute(struct analogix_dp_device *dp, bool enable);\nvoid analogix_dp_stop_video(struct analogix_dp_device *dp);\nvoid analogix_dp_lane_swap(struct analogix_dp_device *dp, bool enable);\nvoid analogix_dp_init_analog_param(struct analogix_dp_device *dp);\nvoid analogix_dp_init_interrupt(struct analogix_dp_device *dp);\nvoid analogix_dp_reset(struct analogix_dp_device *dp);\nvoid analogix_dp_swreset(struct analogix_dp_device *dp);\nvoid analogix_dp_config_interrupt(struct analogix_dp_device *dp);\nvoid analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp);\nvoid analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp);\nenum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp);\nvoid analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable);\nvoid analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,\n\t\t\t\t       enum analog_power_block block,\n\t\t\t\t       bool enable);\nint analogix_dp_init_analog_func(struct analogix_dp_device *dp);\nvoid analogix_dp_init_hpd(struct analogix_dp_device *dp);\nvoid analogix_dp_force_hpd(struct analogix_dp_device *dp);\nenum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp);\nvoid analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp);\nvoid analogix_dp_reset_aux(struct analogix_dp_device *dp);\nvoid analogix_dp_init_aux(struct analogix_dp_device *dp);\nint analogix_dp_get_plug_in_status(struct analogix_dp_device *dp);\nvoid analogix_dp_enable_sw_function(struct analogix_dp_device *dp);\nvoid analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype);\nvoid analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype);\nvoid analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count);\nvoid analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count);\nvoid analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp,\n\t\t\t\t      bool enable);\nvoid analogix_dp_set_training_pattern(struct analogix_dp_device *dp,\n\t\t\t\t      enum pattern_set pattern);\nvoid analogix_dp_set_lane0_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level);\nvoid analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level);\nvoid analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level);\nvoid analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level);\nvoid analogix_dp_set_lane0_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane);\nvoid analogix_dp_set_lane1_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane);\nvoid analogix_dp_set_lane2_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane);\nvoid analogix_dp_set_lane3_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane);\nu32 analogix_dp_get_lane0_link_training(struct analogix_dp_device *dp);\nu32 analogix_dp_get_lane1_link_training(struct analogix_dp_device *dp);\nu32 analogix_dp_get_lane2_link_training(struct analogix_dp_device *dp);\nu32 analogix_dp_get_lane3_link_training(struct analogix_dp_device *dp);\nvoid analogix_dp_reset_macro(struct analogix_dp_device *dp);\nvoid analogix_dp_init_video(struct analogix_dp_device *dp);\n\nvoid analogix_dp_set_video_color_format(struct analogix_dp_device *dp);\nint analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp);\nvoid analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,\n\t\t\t\t enum clock_recovery_m_value_type type,\n\t\t\t\t u32 m_value,\n\t\t\t\t u32 n_value);\nvoid analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type);\nvoid analogix_dp_enable_video_master(struct analogix_dp_device *dp,\n\t\t\t\t     bool enable);\nvoid analogix_dp_start_video(struct analogix_dp_device *dp);\nint analogix_dp_is_video_stream_on(struct analogix_dp_device *dp);\nvoid analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp);\nvoid analogix_dp_enable_scrambling(struct analogix_dp_device *dp);\nvoid analogix_dp_disable_scrambling(struct analogix_dp_device *dp);\nvoid analogix_dp_enable_psr_crc(struct analogix_dp_device *dp);\nint analogix_dp_send_psr_spd(struct analogix_dp_device *dp,\n\t\t\t     struct dp_sdp *vsc, bool blocking);\nssize_t analogix_dp_transfer(struct analogix_dp_device *dp,\n\t\t\t     struct drm_dp_aux_msg *msg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}