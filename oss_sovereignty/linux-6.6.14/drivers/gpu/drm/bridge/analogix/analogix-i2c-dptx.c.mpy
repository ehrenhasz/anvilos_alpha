{
  "module_name": "analogix-i2c-dptx.c",
  "hash_id": "21519f4961e41ec787a08a377163113a8c1936dcdceb79a648da8092758ed57a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/analogix-i2c-dptx.c",
  "human_readable_source": " \n \n#include <linux/regmap.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm.h>\n#include <drm/drm_print.h>\n\n#include \"analogix-i2c-dptx.h\"\n\n#define AUX_WAIT_TIMEOUT_MS\t15\n#define AUX_CH_BUFFER_SIZE\t16\n\nstatic int anx_i2c_dp_clear_bits(struct regmap *map, u8 reg, u8 mask)\n{\n\treturn regmap_update_bits(map, reg, mask, 0);\n}\n\nstatic bool anx_dp_aux_op_finished(struct regmap *map_dptx)\n{\n\tunsigned int value;\n\tint err;\n\n\terr = regmap_read(map_dptx, SP_DP_AUX_CH_CTRL2_REG, &value);\n\tif (err < 0)\n\t\treturn false;\n\n\treturn (value & SP_AUX_EN) == 0;\n}\n\nstatic int anx_dp_aux_wait(struct regmap *map_dptx)\n{\n\tunsigned long timeout;\n\tunsigned int status;\n\tint err;\n\n\ttimeout = jiffies + msecs_to_jiffies(AUX_WAIT_TIMEOUT_MS) + 1;\n\n\twhile (!anx_dp_aux_op_finished(map_dptx)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tif (!anx_dp_aux_op_finished(map_dptx)) {\n\t\t\t\tDRM_ERROR(\"Timed out waiting AUX to finish\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\terr = regmap_read(map_dptx, SP_AUX_CH_STATUS_REG, &status);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to read from AUX channel: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (status & SP_AUX_STATUS) {\n\t\tDRM_ERROR(\"Failed to wait for AUX channel (status: %02x)\\n\",\n\t\t\t  status);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int anx_dp_aux_address(struct regmap *map_dptx, unsigned int addr)\n{\n\tint err;\n\n\terr = regmap_write(map_dptx, SP_AUX_ADDR_7_0_REG, addr & 0xff);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(map_dptx, SP_AUX_ADDR_15_8_REG,\n\t\t\t   (addr & 0xff00) >> 8);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(map_dptx, SP_AUX_ADDR_19_16_REG,\n\t\t\t\t SP_AUX_ADDR_19_16_MASK,\n\t\t\t\t (addr & 0xf0000) >> 16);\n\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nssize_t anx_dp_aux_transfer(struct regmap *map_dptx,\n\t\t\t\tstruct drm_dp_aux_msg *msg)\n{\n\tu8 ctrl1 = msg->request;\n\tu8 ctrl2 = SP_AUX_EN;\n\tu8 *buffer = msg->buffer;\n\tint err;\n\n\t \n\tif (WARN_ON(msg->size > AUX_CH_BUFFER_SIZE))\n\t\treturn -E2BIG;\n\n\t \n\tif (msg->size < 1)\n\t\tctrl2 |= SP_ADDR_ONLY;\n\telse\t \n\t\tctrl1 |= (msg->size - 1) << SP_AUX_LENGTH_SHIFT;\n\n\tif ((msg->size > 0) && ((msg->request & DP_AUX_I2C_READ) == 0)) {\n\t\t \n\t\terr = regmap_bulk_write(map_dptx,\n\t\t\t\t\tSP_DP_BUF_DATA0_REG, buffer,\n\t\t\t\t\tmsg->size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = anx_dp_aux_address(map_dptx, msg->address);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(map_dptx, SP_DP_AUX_CH_CTRL1_REG, ctrl1);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_update_bits(map_dptx, SP_DP_AUX_CH_CTRL2_REG,\n\t\t\t\t SP_ADDR_ONLY | SP_AUX_EN, ctrl2);\n\tif (err)\n\t\treturn err;\n\n\terr = anx_dp_aux_wait(map_dptx);\n\tif (err)\n\t\treturn err;\n\n\tmsg->reply = DP_AUX_I2C_REPLY_ACK;\n\n\tif ((msg->size > 0) && (msg->request & DP_AUX_I2C_READ)) {\n\t\t \n\t\terr = regmap_bulk_read(map_dptx,\n\t\t\t\t       SP_DP_BUF_DATA0_REG, buffer,\n\t\t\t\t       msg->size);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = anx_i2c_dp_clear_bits(map_dptx, SP_DP_AUX_CH_CTRL2_REG,\n\t\t\t\t    SP_ADDR_ONLY);\n\tif (err)\n\t\treturn err;\n\n\treturn msg->size;\n}\nEXPORT_SYMBOL_GPL(anx_dp_aux_transfer);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}