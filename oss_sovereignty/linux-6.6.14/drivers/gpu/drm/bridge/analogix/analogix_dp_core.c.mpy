{
  "module_name": "analogix_dp_core.c",
  "hash_id": "cc7e620cc017fe6d024fe395e7a69c37a83de00859dc1bd471f4a28456dfd939",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/analogix_dp_core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#include <drm/bridge/analogix_dp.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"analogix_dp_core.h\"\n#include \"analogix_dp_reg.h\"\n\n#define to_dp(nm)\tcontainer_of(nm, struct analogix_dp_device, nm)\n\nstatic const bool verify_fast_training;\n\nstruct bridge_init {\n\tstruct i2c_client *client;\n\tstruct device_node *node;\n};\n\nstatic int analogix_dp_init_dp(struct analogix_dp_device *dp)\n{\n\tint ret;\n\n\tanalogix_dp_reset(dp);\n\n\tanalogix_dp_swreset(dp);\n\n\tanalogix_dp_init_analog_param(dp);\n\tanalogix_dp_init_interrupt(dp);\n\n\t \n\tanalogix_dp_enable_sw_function(dp);\n\n\tanalogix_dp_config_interrupt(dp);\n\tret = analogix_dp_init_analog_func(dp);\n\tif (ret)\n\t\treturn ret;\n\n\tanalogix_dp_init_hpd(dp);\n\tanalogix_dp_init_aux(dp);\n\treturn 0;\n}\n\nstatic int analogix_dp_detect_hpd(struct analogix_dp_device *dp)\n{\n\tint timeout_loop = 0;\n\n\twhile (timeout_loop < DP_TIMEOUT_LOOP_COUNT) {\n\t\tif (analogix_dp_get_plug_in_status(dp) == 0)\n\t\t\treturn 0;\n\n\t\ttimeout_loop++;\n\t\tusleep_range(1000, 1100);\n\t}\n\n\t \n\tif (!dp->force_hpd)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tdev_dbg(dp->dev, \"failed to get hpd plug status, try to force hpd\\n\");\n\n\tanalogix_dp_force_hpd(dp);\n\n\tif (analogix_dp_get_plug_in_status(dp) != 0) {\n\t\tdev_err(dp->dev, \"failed to get hpd plug in status\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dp->dev, \"success to get plug in status after force hpd\\n\");\n\n\treturn 0;\n}\n\nstatic bool analogix_dp_detect_sink_psr(struct analogix_dp_device *dp)\n{\n\tunsigned char psr_version;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(&dp->aux, DP_PSR_SUPPORT, &psr_version);\n\tif (ret != 1) {\n\t\tdev_err(dp->dev, \"failed to get PSR version, disable it\\n\");\n\t\treturn false;\n\t}\n\n\tdev_dbg(dp->dev, \"Panel PSR version : %x\\n\", psr_version);\n\treturn psr_version & DP_PSR_IS_SUPPORTED;\n}\n\nstatic int analogix_dp_enable_sink_psr(struct analogix_dp_device *dp)\n{\n\tunsigned char psr_en;\n\tint ret;\n\n\t \n\tret = drm_dp_dpcd_readb(&dp->aux, DP_PSR_EN_CFG, &psr_en);\n\tif (ret != 1) {\n\t\tdev_err(dp->dev, \"failed to get psr config\\n\");\n\t\tgoto end;\n\t}\n\n\tpsr_en &= ~DP_PSR_ENABLE;\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_PSR_EN_CFG, psr_en);\n\tif (ret != 1) {\n\t\tdev_err(dp->dev, \"failed to disable panel psr\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\tpsr_en = DP_PSR_CRC_VERIFICATION;\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_PSR_EN_CFG, psr_en);\n\tif (ret != 1) {\n\t\tdev_err(dp->dev, \"failed to set panel psr\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\tpsr_en = DP_PSR_ENABLE | DP_PSR_CRC_VERIFICATION;\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_PSR_EN_CFG, psr_en);\n\tif (ret != 1) {\n\t\tdev_err(dp->dev, \"failed to set panel psr\\n\");\n\t\tgoto end;\n\t}\n\n\tanalogix_dp_enable_psr_crc(dp);\n\n\tdp->psr_supported = true;\n\n\treturn 0;\nend:\n\tdev_err(dp->dev, \"enable psr fail, force to disable psr\\n\");\n\n\treturn ret;\n}\n\nstatic int\nanalogix_dp_enable_rx_to_enhanced_mode(struct analogix_dp_device *dp,\n\t\t\t\t       bool enable)\n{\n\tu8 data;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(&dp->aux, DP_LANE_COUNT_SET, &data);\n\tif (ret != 1)\n\t\treturn ret;\n\n\tif (enable)\n\t\tret = drm_dp_dpcd_writeb(&dp->aux, DP_LANE_COUNT_SET,\n\t\t\t\t\t DP_LANE_COUNT_ENHANCED_FRAME_EN |\n\t\t\t\t\t DPCD_LANE_COUNT_SET(data));\n\telse\n\t\tret = drm_dp_dpcd_writeb(&dp->aux, DP_LANE_COUNT_SET,\n\t\t\t\t\t DPCD_LANE_COUNT_SET(data));\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int analogix_dp_is_enhanced_mode_available(struct analogix_dp_device *dp,\n\t\t\t\t\t\t  u8 *enhanced_mode_support)\n{\n\tu8 data;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(&dp->aux, DP_MAX_LANE_COUNT, &data);\n\tif (ret != 1) {\n\t\t*enhanced_mode_support = 0;\n\t\treturn ret;\n\t}\n\n\t*enhanced_mode_support = DPCD_ENHANCED_FRAME_CAP(data);\n\n\treturn 0;\n}\n\nstatic int analogix_dp_set_enhanced_mode(struct analogix_dp_device *dp)\n{\n\tu8 data;\n\tint ret;\n\n\tret = analogix_dp_is_enhanced_mode_available(dp, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = analogix_dp_enable_rx_to_enhanced_mode(dp, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tanalogix_dp_enable_enhanced_mode(dp, data);\n\n\treturn 0;\n}\n\nstatic int analogix_dp_training_pattern_dis(struct analogix_dp_device *dp)\n{\n\tint ret;\n\n\tanalogix_dp_set_training_pattern(dp, DP_NONE);\n\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t DP_TRAINING_PATTERN_DISABLE);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void\nanalogix_dp_set_lane_lane_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t       int pre_emphasis, int lane)\n{\n\tswitch (lane) {\n\tcase 0:\n\t\tanalogix_dp_set_lane0_pre_emphasis(dp, pre_emphasis);\n\t\tbreak;\n\tcase 1:\n\t\tanalogix_dp_set_lane1_pre_emphasis(dp, pre_emphasis);\n\t\tbreak;\n\n\tcase 2:\n\t\tanalogix_dp_set_lane2_pre_emphasis(dp, pre_emphasis);\n\t\tbreak;\n\n\tcase 3:\n\t\tanalogix_dp_set_lane3_pre_emphasis(dp, pre_emphasis);\n\t\tbreak;\n\t}\n}\n\nstatic int analogix_dp_link_start(struct analogix_dp_device *dp)\n{\n\tu8 buf[4];\n\tint lane, lane_count, pll_tries, retval;\n\n\tlane_count = dp->link_train.lane_count;\n\n\tdp->link_train.lt_state = CLOCK_RECOVERY;\n\tdp->link_train.eq_loop = 0;\n\n\tfor (lane = 0; lane < lane_count; lane++)\n\t\tdp->link_train.cr_loop[lane] = 0;\n\n\t \n\tanalogix_dp_set_link_bandwidth(dp, dp->link_train.link_rate);\n\tanalogix_dp_set_lane_count(dp, dp->link_train.lane_count);\n\n\t \n\tbuf[0] = dp->link_train.link_rate;\n\tbuf[1] = dp->link_train.lane_count;\n\tretval = drm_dp_dpcd_write(&dp->aux, DP_LINK_BW_SET, buf, 2);\n\tif (retval < 0)\n\t\treturn retval;\n\t \n\tretval = analogix_dp_set_enhanced_mode(dp);\n\tif (retval < 0) {\n\t\tdev_err(dp->dev, \"failed to set enhance mode\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tfor (lane = 0; lane < lane_count; lane++)\n\t\tanalogix_dp_set_lane_lane_pre_emphasis(dp,\n\t\t\tPRE_EMPHASIS_LEVEL_0, lane);\n\n\t \n\tpll_tries = 0;\n\twhile (analogix_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\n\t\tif (pll_tries == DP_TIMEOUT_LOOP_COUNT) {\n\t\t\tdev_err(dp->dev, \"Wait for PLL lock timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tpll_tries++;\n\t\tusleep_range(90, 120);\n\t}\n\n\t \n\tanalogix_dp_set_training_pattern(dp, TRAINING_PTN1);\n\n\t \n\tretval = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t    DP_LINK_SCRAMBLING_DISABLE |\n\t\t\t\t\tDP_TRAINING_PATTERN_1);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tfor (lane = 0; lane < lane_count; lane++)\n\t\tbuf[lane] = DP_TRAIN_PRE_EMPH_LEVEL_0 |\n\t\t\t    DP_TRAIN_VOLTAGE_SWING_LEVEL_0;\n\n\tretval = drm_dp_dpcd_write(&dp->aux, DP_TRAINING_LANE0_SET, buf,\n\t\t\t\t   lane_count);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic unsigned char analogix_dp_get_lane_status(u8 link_status[2], int lane)\n{\n\tint shift = (lane & 1) * 4;\n\tu8 link_value = link_status[lane >> 1];\n\n\treturn (link_value >> shift) & 0xf;\n}\n\nstatic int analogix_dp_clock_recovery_ok(u8 link_status[2], int lane_count)\n{\n\tint lane;\n\tu8 lane_status;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = analogix_dp_get_lane_status(link_status, lane);\n\t\tif ((lane_status & DP_LANE_CR_DONE) == 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int analogix_dp_channel_eq_ok(u8 link_status[2], u8 link_align,\n\t\t\t\t     int lane_count)\n{\n\tint lane;\n\tu8 lane_status;\n\n\tif ((link_align & DP_INTERLANE_ALIGN_DONE) == 0)\n\t\treturn -EINVAL;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = analogix_dp_get_lane_status(link_status, lane);\n\t\tlane_status &= DP_CHANNEL_EQ_BITS;\n\t\tif (lane_status != DP_CHANNEL_EQ_BITS)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned char\nanalogix_dp_get_adjust_request_voltage(u8 adjust_request[2], int lane)\n{\n\tint shift = (lane & 1) * 4;\n\tu8 link_value = adjust_request[lane >> 1];\n\n\treturn (link_value >> shift) & 0x3;\n}\n\nstatic unsigned char analogix_dp_get_adjust_request_pre_emphasis(\n\t\t\t\t\tu8 adjust_request[2],\n\t\t\t\t\tint lane)\n{\n\tint shift = (lane & 1) * 4;\n\tu8 link_value = adjust_request[lane >> 1];\n\n\treturn ((link_value >> shift) & 0xc) >> 2;\n}\n\nstatic void analogix_dp_set_lane_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t       u8 training_lane_set, int lane)\n{\n\tswitch (lane) {\n\tcase 0:\n\t\tanalogix_dp_set_lane0_link_training(dp, training_lane_set);\n\t\tbreak;\n\tcase 1:\n\t\tanalogix_dp_set_lane1_link_training(dp, training_lane_set);\n\t\tbreak;\n\n\tcase 2:\n\t\tanalogix_dp_set_lane2_link_training(dp, training_lane_set);\n\t\tbreak;\n\n\tcase 3:\n\t\tanalogix_dp_set_lane3_link_training(dp, training_lane_set);\n\t\tbreak;\n\t}\n}\n\nstatic unsigned int\nanalogix_dp_get_lane_link_training(struct analogix_dp_device *dp,\n\t\t\t\t   int lane)\n{\n\tu32 reg;\n\n\tswitch (lane) {\n\tcase 0:\n\t\treg = analogix_dp_get_lane0_link_training(dp);\n\t\tbreak;\n\tcase 1:\n\t\treg = analogix_dp_get_lane1_link_training(dp);\n\t\tbreak;\n\tcase 2:\n\t\treg = analogix_dp_get_lane2_link_training(dp);\n\t\tbreak;\n\tcase 3:\n\t\treg = analogix_dp_get_lane3_link_training(dp);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn reg;\n}\n\nstatic void analogix_dp_reduce_link_rate(struct analogix_dp_device *dp)\n{\n\tanalogix_dp_training_pattern_dis(dp);\n\tanalogix_dp_set_enhanced_mode(dp);\n\n\tdp->link_train.lt_state = FAILED;\n}\n\nstatic void analogix_dp_get_adjust_training_lane(struct analogix_dp_device *dp,\n\t\t\t\t\t\t u8 adjust_request[2])\n{\n\tint lane, lane_count;\n\tu8 voltage_swing, pre_emphasis, training_lane;\n\n\tlane_count = dp->link_train.lane_count;\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tvoltage_swing = analogix_dp_get_adjust_request_voltage(\n\t\t\t\t\t\tadjust_request, lane);\n\t\tpre_emphasis = analogix_dp_get_adjust_request_pre_emphasis(\n\t\t\t\t\t\tadjust_request, lane);\n\t\ttraining_lane = DPCD_VOLTAGE_SWING_SET(voltage_swing) |\n\t\t\t\tDPCD_PRE_EMPHASIS_SET(pre_emphasis);\n\n\t\tif (voltage_swing == VOLTAGE_LEVEL_3)\n\t\t\ttraining_lane |= DP_TRAIN_MAX_SWING_REACHED;\n\t\tif (pre_emphasis == PRE_EMPHASIS_LEVEL_3)\n\t\t\ttraining_lane |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\t\tdp->link_train.training_lane[lane] = training_lane;\n\t}\n}\n\nstatic int analogix_dp_process_clock_recovery(struct analogix_dp_device *dp)\n{\n\tint lane, lane_count, retval;\n\tu8 voltage_swing, pre_emphasis, training_lane;\n\tu8 link_status[2], adjust_request[2];\n\n\tusleep_range(100, 101);\n\n\tlane_count = dp->link_train.lane_count;\n\n\tretval = drm_dp_dpcd_read(&dp->aux, DP_LANE0_1_STATUS, link_status, 2);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = drm_dp_dpcd_read(&dp->aux, DP_ADJUST_REQUEST_LANE0_1,\n\t\t\t\t  adjust_request, 2);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif (analogix_dp_clock_recovery_ok(link_status, lane_count) == 0) {\n\t\t \n\t\tanalogix_dp_set_training_pattern(dp, TRAINING_PTN2);\n\n\t\tretval = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t\t    DP_LINK_SCRAMBLING_DISABLE |\n\t\t\t\t\t\tDP_TRAINING_PATTERN_2);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tdev_dbg(dp->dev, \"Link Training Clock Recovery success\\n\");\n\t\tdp->link_train.lt_state = EQUALIZER_TRAINING;\n\t} else {\n\t\tfor (lane = 0; lane < lane_count; lane++) {\n\t\t\ttraining_lane = analogix_dp_get_lane_link_training(\n\t\t\t\t\t\t\tdp, lane);\n\t\t\tvoltage_swing = analogix_dp_get_adjust_request_voltage(\n\t\t\t\t\t\t\tadjust_request, lane);\n\t\t\tpre_emphasis = analogix_dp_get_adjust_request_pre_emphasis(\n\t\t\t\t\t\t\tadjust_request, lane);\n\n\t\t\tif (DPCD_VOLTAGE_SWING_GET(training_lane) ==\n\t\t\t\t\tvoltage_swing &&\n\t\t\t    DPCD_PRE_EMPHASIS_GET(training_lane) ==\n\t\t\t\t\tpre_emphasis)\n\t\t\t\tdp->link_train.cr_loop[lane]++;\n\n\t\t\tif (dp->link_train.cr_loop[lane] == MAX_CR_LOOP ||\n\t\t\t    voltage_swing == VOLTAGE_LEVEL_3 ||\n\t\t\t    pre_emphasis == PRE_EMPHASIS_LEVEL_3) {\n\t\t\t\tdev_err(dp->dev, \"CR Max reached (%d,%d,%d)\\n\",\n\t\t\t\t\tdp->link_train.cr_loop[lane],\n\t\t\t\t\tvoltage_swing, pre_emphasis);\n\t\t\t\tanalogix_dp_reduce_link_rate(dp);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\n\tanalogix_dp_get_adjust_training_lane(dp, adjust_request);\n\n\tfor (lane = 0; lane < lane_count; lane++)\n\t\tanalogix_dp_set_lane_link_training(dp,\n\t\t\tdp->link_train.training_lane[lane], lane);\n\n\tretval = drm_dp_dpcd_write(&dp->aux, DP_TRAINING_LANE0_SET,\n\t\t\t\t   dp->link_train.training_lane, lane_count);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic int analogix_dp_process_equalizer_training(struct analogix_dp_device *dp)\n{\n\tint lane, lane_count, retval;\n\tu32 reg;\n\tu8 link_align, link_status[2], adjust_request[2];\n\n\tusleep_range(400, 401);\n\n\tlane_count = dp->link_train.lane_count;\n\n\tretval = drm_dp_dpcd_read(&dp->aux, DP_LANE0_1_STATUS, link_status, 2);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif (analogix_dp_clock_recovery_ok(link_status, lane_count)) {\n\t\tanalogix_dp_reduce_link_rate(dp);\n\t\treturn -EIO;\n\t}\n\n\tretval = drm_dp_dpcd_read(&dp->aux, DP_ADJUST_REQUEST_LANE0_1,\n\t\t\t\t  adjust_request, 2);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = drm_dp_dpcd_readb(&dp->aux, DP_LANE_ALIGN_STATUS_UPDATED,\n\t\t\t\t   &link_align);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tanalogix_dp_get_adjust_training_lane(dp, adjust_request);\n\n\tif (!analogix_dp_channel_eq_ok(link_status, link_align, lane_count)) {\n\t\t \n\t\tretval = analogix_dp_training_pattern_dis(dp);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tdev_dbg(dp->dev, \"Link Training success!\\n\");\n\t\tanalogix_dp_get_link_bandwidth(dp, &reg);\n\t\tdp->link_train.link_rate = reg;\n\t\tdev_dbg(dp->dev, \"final bandwidth = %.2x\\n\",\n\t\t\tdp->link_train.link_rate);\n\n\t\tanalogix_dp_get_lane_count(dp, &reg);\n\t\tdp->link_train.lane_count = reg;\n\t\tdev_dbg(dp->dev, \"final lane count = %.2x\\n\",\n\t\t\tdp->link_train.lane_count);\n\n\t\tdp->link_train.lt_state = FINISHED;\n\n\t\treturn 0;\n\t}\n\n\t \n\tdp->link_train.eq_loop++;\n\n\tif (dp->link_train.eq_loop > MAX_EQ_LOOP) {\n\t\tdev_err(dp->dev, \"EQ Max loop\\n\");\n\t\tanalogix_dp_reduce_link_rate(dp);\n\t\treturn -EIO;\n\t}\n\n\tfor (lane = 0; lane < lane_count; lane++)\n\t\tanalogix_dp_set_lane_link_training(dp,\n\t\t\tdp->link_train.training_lane[lane], lane);\n\n\tretval = drm_dp_dpcd_write(&dp->aux, DP_TRAINING_LANE0_SET,\n\t\t\t\t   dp->link_train.training_lane, lane_count);\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic void analogix_dp_get_max_rx_bandwidth(struct analogix_dp_device *dp,\n\t\t\t\t\t     u8 *bandwidth)\n{\n\tu8 data;\n\n\t \n\tdrm_dp_dpcd_readb(&dp->aux, DP_MAX_LINK_RATE, &data);\n\t*bandwidth = data;\n}\n\nstatic void analogix_dp_get_max_rx_lane_count(struct analogix_dp_device *dp,\n\t\t\t\t\t      u8 *lane_count)\n{\n\tu8 data;\n\n\t \n\tdrm_dp_dpcd_readb(&dp->aux, DP_MAX_LANE_COUNT, &data);\n\t*lane_count = DPCD_MAX_LANE_COUNT(data);\n}\n\nstatic int analogix_dp_full_link_train(struct analogix_dp_device *dp,\n\t\t\t\t       u32 max_lanes, u32 max_rate)\n{\n\tint retval = 0;\n\tbool training_finished = false;\n\n\t \n\tanalogix_dp_reset_macro(dp);\n\n\t \n\tanalogix_dp_get_max_rx_bandwidth(dp, &dp->link_train.link_rate);\n\tanalogix_dp_get_max_rx_lane_count(dp, &dp->link_train.lane_count);\n\n\tif ((dp->link_train.link_rate != DP_LINK_BW_1_62) &&\n\t    (dp->link_train.link_rate != DP_LINK_BW_2_7) &&\n\t    (dp->link_train.link_rate != DP_LINK_BW_5_4)) {\n\t\tdev_err(dp->dev, \"Rx Max Link Rate is abnormal :%x !\\n\",\n\t\t\tdp->link_train.link_rate);\n\t\tdp->link_train.link_rate = DP_LINK_BW_1_62;\n\t}\n\n\tif (dp->link_train.lane_count == 0) {\n\t\tdev_err(dp->dev, \"Rx Max Lane count is abnormal :%x !\\n\",\n\t\t\tdp->link_train.lane_count);\n\t\tdp->link_train.lane_count = (u8)LANE_COUNT1;\n\t}\n\n\t \n\tif (dp->link_train.lane_count > max_lanes)\n\t\tdp->link_train.lane_count = max_lanes;\n\tif (dp->link_train.link_rate > max_rate)\n\t\tdp->link_train.link_rate = max_rate;\n\n\t \n\tanalogix_dp_set_analog_power_down(dp, POWER_ALL, 0);\n\n\tdp->link_train.lt_state = START;\n\n\t \n\twhile (!retval && !training_finished) {\n\t\tswitch (dp->link_train.lt_state) {\n\t\tcase START:\n\t\t\tretval = analogix_dp_link_start(dp);\n\t\t\tif (retval)\n\t\t\t\tdev_err(dp->dev, \"LT link start failed!\\n\");\n\t\t\tbreak;\n\t\tcase CLOCK_RECOVERY:\n\t\t\tretval = analogix_dp_process_clock_recovery(dp);\n\t\t\tif (retval)\n\t\t\t\tdev_err(dp->dev, \"LT CR failed!\\n\");\n\t\t\tbreak;\n\t\tcase EQUALIZER_TRAINING:\n\t\t\tretval = analogix_dp_process_equalizer_training(dp);\n\t\t\tif (retval)\n\t\t\t\tdev_err(dp->dev, \"LT EQ failed!\\n\");\n\t\t\tbreak;\n\t\tcase FINISHED:\n\t\t\ttraining_finished = 1;\n\t\t\tbreak;\n\t\tcase FAILED:\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\tif (retval)\n\t\tdev_err(dp->dev, \"eDP link training failed (%d)\\n\", retval);\n\n\treturn retval;\n}\n\nstatic int analogix_dp_fast_link_train(struct analogix_dp_device *dp)\n{\n\tint i, ret;\n\tu8 link_align, link_status[2];\n\tenum pll_status status;\n\n\tanalogix_dp_reset_macro(dp);\n\n\tanalogix_dp_set_link_bandwidth(dp, dp->link_train.link_rate);\n\tanalogix_dp_set_lane_count(dp, dp->link_train.lane_count);\n\n\tfor (i = 0; i < dp->link_train.lane_count; i++) {\n\t\tanalogix_dp_set_lane_link_training(dp,\n\t\t\tdp->link_train.training_lane[i], i);\n\t}\n\n\tret = readx_poll_timeout(analogix_dp_get_pll_lock_status, dp, status,\n\t\t\t\t status != PLL_UNLOCKED, 120,\n\t\t\t\t 120 * DP_TIMEOUT_LOOP_COUNT);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Wait for pll lock failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tanalogix_dp_set_training_pattern(dp, TRAINING_PTN1);\n\t \n\tusleep_range(500, 600);\n\n\tanalogix_dp_set_training_pattern(dp, TRAINING_PTN2);\n\t \n\tusleep_range(500, 600);\n\n\t \n\tanalogix_dp_set_training_pattern(dp, DP_NONE);\n\n\t \n\tif (verify_fast_training) {\n\t\tret = drm_dp_dpcd_readb(&dp->aux, DP_LANE_ALIGN_STATUS_UPDATED,\n\t\t\t\t\t&link_align);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Read align status failed %d\\n\",\n\t\t\t\t      ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = drm_dp_dpcd_read(&dp->aux, DP_LANE0_1_STATUS, link_status,\n\t\t\t\t       2);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Read link status failed %d\\n\",\n\t\t\t\t      ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (analogix_dp_clock_recovery_ok(link_status,\n\t\t\t\t\t\t  dp->link_train.lane_count)) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Clock recovery failed\\n\");\n\t\t\tanalogix_dp_reduce_link_rate(dp);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (analogix_dp_channel_eq_ok(link_status, link_align,\n\t\t\t\t\t      dp->link_train.lane_count)) {\n\t\t\tDRM_DEV_ERROR(dp->dev, \"Channel EQ failed\\n\");\n\t\t\tanalogix_dp_reduce_link_rate(dp);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int analogix_dp_train_link(struct analogix_dp_device *dp)\n{\n\tif (dp->fast_train_enable)\n\t\treturn analogix_dp_fast_link_train(dp);\n\n\treturn analogix_dp_full_link_train(dp, dp->video_info.max_lane_count,\n\t\t\t\t\t   dp->video_info.max_link_rate);\n}\n\nstatic int analogix_dp_config_video(struct analogix_dp_device *dp)\n{\n\tint timeout_loop = 0;\n\tint done_count = 0;\n\n\tanalogix_dp_config_video_slave_mode(dp);\n\n\tanalogix_dp_set_video_color_format(dp);\n\n\tif (analogix_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\n\t\tdev_err(dp->dev, \"PLL is not locked yet.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (;;) {\n\t\ttimeout_loop++;\n\t\tif (analogix_dp_is_slave_video_stream_clock_on(dp) == 0)\n\t\t\tbreak;\n\t\tif (timeout_loop > DP_TIMEOUT_LOOP_COUNT) {\n\t\t\tdev_err(dp->dev, \"Timeout of slave video streamclk ok\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tusleep_range(1000, 1001);\n\t}\n\n\t \n\tanalogix_dp_set_video_cr_mn(dp, CALCULATED_M, 0, 0);\n\n\t \n\tanalogix_dp_set_video_timing_mode(dp, VIDEO_TIMING_FROM_CAPTURE);\n\n\t \n\tanalogix_dp_enable_video_mute(dp, 0);\n\n\t \n\tanalogix_dp_enable_video_master(dp, 0);\n\n\t \n\tanalogix_dp_start_video(dp);\n\n\ttimeout_loop = 0;\n\n\tfor (;;) {\n\t\ttimeout_loop++;\n\t\tif (analogix_dp_is_video_stream_on(dp) == 0) {\n\t\t\tdone_count++;\n\t\t\tif (done_count > 10)\n\t\t\t\tbreak;\n\t\t} else if (done_count) {\n\t\t\tdone_count = 0;\n\t\t}\n\t\tif (timeout_loop > DP_TIMEOUT_LOOP_COUNT) {\n\t\t\tdev_warn(dp->dev,\n\t\t\t\t \"Ignoring timeout of video streamclk ok\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(1000, 1001);\n\t}\n\n\treturn 0;\n}\n\nstatic int analogix_dp_enable_scramble(struct analogix_dp_device *dp,\n\t\t\t\t       bool enable)\n{\n\tu8 data;\n\tint ret;\n\n\tif (enable) {\n\t\tanalogix_dp_enable_scrambling(dp);\n\n\t\tret = drm_dp_dpcd_readb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t\t&data);\n\t\tif (ret != 1)\n\t\t\treturn ret;\n\t\tret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t   (u8)(data & ~DP_LINK_SCRAMBLING_DISABLE));\n\t} else {\n\t\tanalogix_dp_disable_scrambling(dp);\n\n\t\tret = drm_dp_dpcd_readb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t\t&data);\n\t\tif (ret != 1)\n\t\t\treturn ret;\n\t\tret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t   (u8)(data | DP_LINK_SCRAMBLING_DISABLE));\n\t}\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic irqreturn_t analogix_dp_hardirq(int irq, void *arg)\n{\n\tstruct analogix_dp_device *dp = arg;\n\tirqreturn_t ret = IRQ_NONE;\n\tenum dp_irq_type irq_type;\n\n\tirq_type = analogix_dp_get_irq_type(dp);\n\tif (irq_type != DP_IRQ_TYPE_UNKNOWN) {\n\t\tanalogix_dp_mute_hpd_interrupt(dp);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t analogix_dp_irq_thread(int irq, void *arg)\n{\n\tstruct analogix_dp_device *dp = arg;\n\tenum dp_irq_type irq_type;\n\n\tirq_type = analogix_dp_get_irq_type(dp);\n\tif (irq_type & DP_IRQ_TYPE_HP_CABLE_IN ||\n\t    irq_type & DP_IRQ_TYPE_HP_CABLE_OUT) {\n\t\tdev_dbg(dp->dev, \"Detected cable status changed!\\n\");\n\t\tif (dp->drm_dev)\n\t\t\tdrm_helper_hpd_irq_event(dp->drm_dev);\n\t}\n\n\tif (irq_type != DP_IRQ_TYPE_UNKNOWN) {\n\t\tanalogix_dp_clear_hotplug_interrupts(dp);\n\t\tanalogix_dp_unmute_hpd_interrupt(dp);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int analogix_dp_fast_link_train_detection(struct analogix_dp_device *dp)\n{\n\tint ret;\n\tu8 spread;\n\n\tret = drm_dp_dpcd_readb(&dp->aux, DP_MAX_DOWNSPREAD, &spread);\n\tif (ret != 1) {\n\t\tdev_err(dp->dev, \"failed to read downspread %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdp->fast_train_enable = !!(spread & DP_NO_AUX_HANDSHAKE_LINK_TRAINING);\n\tdev_dbg(dp->dev, \"fast link training %s\\n\",\n\t\tdp->fast_train_enable ? \"supported\" : \"unsupported\");\n\treturn 0;\n}\n\nstatic int analogix_dp_commit(struct analogix_dp_device *dp)\n{\n\tint ret;\n\n\t \n\tif (dp->plat_data->panel) {\n\t\tif (drm_panel_disable(dp->plat_data->panel))\n\t\t\tDRM_ERROR(\"failed to disable the panel\\n\");\n\t}\n\n\tret = analogix_dp_train_link(dp);\n\tif (ret) {\n\t\tdev_err(dp->dev, \"unable to do link train, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = analogix_dp_enable_scramble(dp, 1);\n\tif (ret < 0) {\n\t\tdev_err(dp->dev, \"can not enable scramble\\n\");\n\t\treturn ret;\n\t}\n\n\tanalogix_dp_init_video(dp);\n\tret = analogix_dp_config_video(dp);\n\tif (ret) {\n\t\tdev_err(dp->dev, \"unable to config video\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (dp->plat_data->panel) {\n\t\tret = drm_panel_enable(dp->plat_data->panel);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"failed to enable the panel\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = analogix_dp_fast_link_train_detection(dp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (analogix_dp_detect_sink_psr(dp)) {\n\t\tret = analogix_dp_enable_sink_psr(dp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int analogix_dp_enable_psr(struct analogix_dp_device *dp)\n{\n\tstruct dp_sdp psr_vsc;\n\tint ret;\n\tu8 sink;\n\n\tret = drm_dp_dpcd_readb(&dp->aux, DP_PSR_STATUS, &sink);\n\tif (ret != 1)\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to read psr status %d\\n\", ret);\n\telse if (sink == DP_PSR_SINK_ACTIVE_RFB)\n\t\treturn 0;\n\n\t \n\tmemset(&psr_vsc, 0, sizeof(psr_vsc));\n\tpsr_vsc.sdp_header.HB0 = 0;\n\tpsr_vsc.sdp_header.HB1 = 0x7;\n\tpsr_vsc.sdp_header.HB2 = 0x2;\n\tpsr_vsc.sdp_header.HB3 = 0x8;\n\tpsr_vsc.db[0] = 0;\n\tpsr_vsc.db[1] = EDP_VSC_PSR_STATE_ACTIVE | EDP_VSC_PSR_CRC_VALUES_VALID;\n\n\tret = analogix_dp_send_psr_spd(dp, &psr_vsc, true);\n\tif (!ret)\n\t\tanalogix_dp_set_analog_power_down(dp, POWER_ALL, true);\n\n\treturn ret;\n}\n\nstatic int analogix_dp_disable_psr(struct analogix_dp_device *dp)\n{\n\tstruct dp_sdp psr_vsc;\n\tint ret;\n\tu8 sink;\n\n\tanalogix_dp_set_analog_power_down(dp, POWER_ALL, false);\n\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_SET_POWER, DP_SET_POWER_D0);\n\tif (ret != 1) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to set DP Power0 %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = drm_dp_dpcd_readb(&dp->aux, DP_PSR_STATUS, &sink);\n\tif (ret != 1) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to read psr status %d\\n\", ret);\n\t\treturn ret;\n\t} else if (sink == DP_PSR_SINK_INACTIVE) {\n\t\tDRM_DEV_ERROR(dp->dev, \"sink inactive, skip disable psr\");\n\t\treturn 0;\n\t}\n\n\tret = analogix_dp_train_link(dp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dp->dev, \"Failed to train the link %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmemset(&psr_vsc, 0, sizeof(psr_vsc));\n\tpsr_vsc.sdp_header.HB0 = 0;\n\tpsr_vsc.sdp_header.HB1 = 0x7;\n\tpsr_vsc.sdp_header.HB2 = 0x2;\n\tpsr_vsc.sdp_header.HB3 = 0x8;\n\n\tpsr_vsc.db[0] = 0;\n\tpsr_vsc.db[1] = 0;\n\n\treturn analogix_dp_send_psr_spd(dp, &psr_vsc, true);\n}\n\n \nstatic int analogix_dp_prepare_panel(struct analogix_dp_device *dp,\n\t\t\t\t     bool prepare, bool is_modeset_prepare)\n{\n\tint ret = 0;\n\n\tif (!dp->plat_data->panel)\n\t\treturn 0;\n\n\tmutex_lock(&dp->panel_lock);\n\n\t \n\tif (dp->panel_is_modeset && !is_modeset_prepare)\n\t\tgoto out;\n\n\tif (prepare)\n\t\tret = drm_panel_prepare(dp->plat_data->panel);\n\telse\n\t\tret = drm_panel_unprepare(dp->plat_data->panel);\n\n\tif (ret)\n\t\tgoto out;\n\n\tif (is_modeset_prepare)\n\t\tdp->panel_is_modeset = prepare;\n\nout:\n\tmutex_unlock(&dp->panel_lock);\n\treturn ret;\n}\n\nstatic int analogix_dp_get_modes(struct drm_connector *connector)\n{\n\tstruct analogix_dp_device *dp = to_dp(connector);\n\tstruct edid *edid;\n\tint ret, num_modes = 0;\n\n\tif (dp->plat_data->panel) {\n\t\tnum_modes += drm_panel_get_modes(dp->plat_data->panel, connector);\n\t} else {\n\t\tret = analogix_dp_prepare_panel(dp, true, false);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to prepare panel (%d)\\n\", ret);\n\t\t\treturn 0;\n\t\t}\n\n\t\tedid = drm_get_edid(connector, &dp->aux.ddc);\n\t\tif (edid) {\n\t\t\tdrm_connector_update_edid_property(&dp->connector,\n\t\t\t\t\t\t\t   edid);\n\t\t\tnum_modes += drm_add_edid_modes(&dp->connector, edid);\n\t\t\tkfree(edid);\n\t\t}\n\n\t\tret = analogix_dp_prepare_panel(dp, false, false);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to unprepare panel (%d)\\n\", ret);\n\t}\n\n\tif (dp->plat_data->get_modes)\n\t\tnum_modes += dp->plat_data->get_modes(dp->plat_data, connector);\n\n\treturn num_modes;\n}\n\nstatic struct drm_encoder *\nanalogix_dp_best_encoder(struct drm_connector *connector)\n{\n\tstruct analogix_dp_device *dp = to_dp(connector);\n\n\treturn dp->encoder;\n}\n\n\nstatic int analogix_dp_atomic_check(struct drm_connector *connector,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct analogix_dp_device *dp = to_dp(connector);\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\treturn -ENODEV;\n\n\tconn_state->self_refresh_aware = true;\n\n\tif (!conn_state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (!crtc_state)\n\t\treturn 0;\n\n\tif (crtc_state->self_refresh_active && !dp->psr_supported)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs analogix_dp_connector_helper_funcs = {\n\t.get_modes = analogix_dp_get_modes,\n\t.best_encoder = analogix_dp_best_encoder,\n\t.atomic_check = analogix_dp_atomic_check,\n};\n\nstatic enum drm_connector_status\nanalogix_dp_detect(struct drm_connector *connector, bool force)\n{\n\tstruct analogix_dp_device *dp = to_dp(connector);\n\tenum drm_connector_status status = connector_status_disconnected;\n\tint ret;\n\n\tif (dp->plat_data->panel)\n\t\treturn connector_status_connected;\n\n\tret = analogix_dp_prepare_panel(dp, true, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to prepare panel (%d)\\n\", ret);\n\t\treturn connector_status_disconnected;\n\t}\n\n\tif (!analogix_dp_detect_hpd(dp))\n\t\tstatus = connector_status_connected;\n\n\tret = analogix_dp_prepare_panel(dp, false, false);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to unprepare panel (%d)\\n\", ret);\n\n\treturn status;\n}\n\nstatic const struct drm_connector_funcs analogix_dp_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = analogix_dp_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int analogix_dp_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tstruct drm_encoder *encoder = dp->encoder;\n\tstruct drm_connector *connector = NULL;\n\tint ret = 0;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {\n\t\tDRM_ERROR(\"Fix bridge driver to make connector optional!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!dp->plat_data->skip_connector) {\n\t\tconnector = &dp->connector;\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\t\tret = drm_connector_init(dp->drm_dev, connector,\n\t\t\t\t\t &analogix_dp_connector_funcs,\n\t\t\t\t\t DRM_MODE_CONNECTOR_eDP);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to initialize connector with drm\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdrm_connector_helper_add(connector,\n\t\t\t\t\t &analogix_dp_connector_helper_funcs);\n\t\tdrm_connector_attach_encoder(connector, encoder);\n\t}\n\n\t \n\tif (dp->plat_data->attach) {\n\t\tret = dp->plat_data->attach(dp->plat_data, bridge, connector);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed at platform attach func\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic\nstruct drm_crtc *analogix_dp_get_old_crtc(struct analogix_dp_device *dp,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_encoder *encoder = dp->encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_old_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_old_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\n\nstatic\nstruct drm_crtc *analogix_dp_get_new_crtc(struct analogix_dp_device *dp,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_encoder *encoder = dp->encoder;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, encoder);\n\tif (!connector)\n\t\treturn NULL;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (!conn_state)\n\t\treturn NULL;\n\n\treturn conn_state->crtc;\n}\n\nstatic void\nanalogix_dp_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *old_state = old_bridge_state->base.state;\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tint ret;\n\n\tcrtc = analogix_dp_get_new_crtc(dp, old_state);\n\tif (!crtc)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(old_state, crtc);\n\t \n\tif (old_crtc_state && old_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tret = analogix_dp_prepare_panel(dp, true, true);\n\tif (ret)\n\t\tDRM_ERROR(\"failed to setup the panel ret = %d\\n\", ret);\n}\n\nstatic int analogix_dp_set_bridge(struct analogix_dp_device *dp)\n{\n\tint ret;\n\n\tpm_runtime_get_sync(dp->dev);\n\n\tret = clk_prepare_enable(dp->clock);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to prepare_enable the clock clk [%d]\\n\", ret);\n\t\tgoto out_dp_clk_pre;\n\t}\n\n\tif (dp->plat_data->power_on_start)\n\t\tdp->plat_data->power_on_start(dp->plat_data);\n\n\tphy_power_on(dp->phy);\n\n\tret = analogix_dp_init_dp(dp);\n\tif (ret)\n\t\tgoto out_dp_init;\n\n\t \n\tret = analogix_dp_detect_hpd(dp);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to get hpd single ret = %d\\n\", ret);\n\t\tgoto out_dp_init;\n\t}\n\n\tret = analogix_dp_commit(dp);\n\tif (ret) {\n\t\tDRM_ERROR(\"dp commit error, ret = %d\\n\", ret);\n\t\tgoto out_dp_init;\n\t}\n\n\tif (dp->plat_data->power_on_end)\n\t\tdp->plat_data->power_on_end(dp->plat_data);\n\n\tenable_irq(dp->irq);\n\treturn 0;\n\nout_dp_init:\n\tphy_power_off(dp->phy);\n\tif (dp->plat_data->power_off)\n\t\tdp->plat_data->power_off(dp->plat_data);\n\tclk_disable_unprepare(dp->clock);\nout_dp_clk_pre:\n\tpm_runtime_put_sync(dp->dev);\n\n\treturn ret;\n}\n\nstatic void\nanalogix_dp_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *old_state = old_bridge_state->base.state;\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tint timeout_loop = 0;\n\tint ret;\n\n\tcrtc = analogix_dp_get_new_crtc(dp, old_state);\n\tif (!crtc)\n\t\treturn;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(old_state, crtc);\n\t \n\tif (old_crtc_state && old_crtc_state->self_refresh_active) {\n\t\tret = analogix_dp_disable_psr(dp);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to disable psr %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (dp->dpms_mode == DRM_MODE_DPMS_ON)\n\t\treturn;\n\n\twhile (timeout_loop < MAX_PLL_LOCK_LOOP) {\n\t\tif (analogix_dp_set_bridge(dp) == 0) {\n\t\t\tdp->dpms_mode = DRM_MODE_DPMS_ON;\n\t\t\treturn;\n\t\t}\n\t\tdev_err(dp->dev, \"failed to set bridge, retry: %d\\n\",\n\t\t\ttimeout_loop);\n\t\ttimeout_loop++;\n\t\tusleep_range(10, 11);\n\t}\n\tdev_err(dp->dev, \"too many times retry set bridge, give it up\\n\");\n}\n\nstatic void analogix_dp_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tint ret;\n\n\tif (dp->dpms_mode != DRM_MODE_DPMS_ON)\n\t\treturn;\n\n\tif (dp->plat_data->panel) {\n\t\tif (drm_panel_disable(dp->plat_data->panel)) {\n\t\t\tDRM_ERROR(\"failed to disable the panel\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdisable_irq(dp->irq);\n\n\tif (dp->plat_data->power_off)\n\t\tdp->plat_data->power_off(dp->plat_data);\n\n\tanalogix_dp_set_analog_power_down(dp, POWER_ALL, 1);\n\tphy_power_off(dp->phy);\n\n\tclk_disable_unprepare(dp->clock);\n\n\tpm_runtime_put_sync(dp->dev);\n\n\tret = analogix_dp_prepare_panel(dp, false, true);\n\tif (ret)\n\t\tDRM_ERROR(\"failed to setup the panel ret = %d\\n\", ret);\n\n\tdp->fast_train_enable = false;\n\tdp->psr_supported = false;\n\tdp->dpms_mode = DRM_MODE_DPMS_OFF;\n}\n\nstatic void\nanalogix_dp_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *old_state = old_bridge_state->base.state;\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tstruct drm_crtc *old_crtc, *new_crtc;\n\tstruct drm_crtc_state *old_crtc_state = NULL;\n\tstruct drm_crtc_state *new_crtc_state = NULL;\n\tint ret;\n\n\tnew_crtc = analogix_dp_get_new_crtc(dp, old_state);\n\tif (!new_crtc)\n\t\tgoto out;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(old_state, new_crtc);\n\tif (!new_crtc_state)\n\t\tgoto out;\n\n\t \n\tif (new_crtc_state->self_refresh_active)\n\t\treturn;\n\nout:\n\told_crtc = analogix_dp_get_old_crtc(dp, old_state);\n\tif (old_crtc) {\n\t\told_crtc_state = drm_atomic_get_old_crtc_state(old_state,\n\t\t\t\t\t\t\t       old_crtc);\n\n\t\t \n\t\tif (old_crtc_state && old_crtc_state->self_refresh_active) {\n\t\t\tret = analogix_dp_disable_psr(dp);\n\t\t\tif (ret)\n\t\t\t\tDRM_ERROR(\"Failed to disable psr (%d)\\n\", ret);\n\t\t}\n\t}\n\n\tanalogix_dp_bridge_disable(bridge);\n}\n\nstatic void\nanalogix_dp_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct drm_atomic_state *old_state = old_bridge_state->base.state;\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tint ret;\n\n\tcrtc = analogix_dp_get_new_crtc(dp, old_state);\n\tif (!crtc)\n\t\treturn;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(old_state, crtc);\n\tif (!new_crtc_state || !new_crtc_state->self_refresh_active)\n\t\treturn;\n\n\tret = analogix_dp_enable_psr(dp);\n\tif (ret)\n\t\tDRM_ERROR(\"Failed to enable psr (%d)\\n\", ret);\n}\n\nstatic void analogix_dp_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *orig_mode,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct analogix_dp_device *dp = bridge->driver_private;\n\tstruct drm_display_info *display_info = &dp->connector.display_info;\n\tstruct video_info *video = &dp->video_info;\n\tstruct device_node *dp_node = dp->dev->of_node;\n\tint vic;\n\n\t \n\tvideo->interlaced = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\n\tvideo->v_sync_polarity = !!(mode->flags & DRM_MODE_FLAG_NVSYNC);\n\tvideo->h_sync_polarity = !!(mode->flags & DRM_MODE_FLAG_NHSYNC);\n\n\t \n\tvic = drm_match_cea_mode(mode);\n\tif ((vic == 6) || (vic == 7) || (vic == 21) || (vic == 22) ||\n\t    (vic == 2) || (vic == 3) || (vic == 17) || (vic == 18)) {\n\t\tvideo->dynamic_range = CEA;\n\t\tvideo->ycbcr_coeff = COLOR_YCBCR601;\n\t} else if (vic) {\n\t\tvideo->dynamic_range = CEA;\n\t\tvideo->ycbcr_coeff = COLOR_YCBCR709;\n\t} else {\n\t\tvideo->dynamic_range = VESA;\n\t\tvideo->ycbcr_coeff = COLOR_YCBCR709;\n\t}\n\n\t \n\tswitch (display_info->bpc) {\n\tcase 12:\n\t\tvideo->color_depth = COLOR_12;\n\t\tbreak;\n\tcase 10:\n\t\tvideo->color_depth = COLOR_10;\n\t\tbreak;\n\tcase 8:\n\t\tvideo->color_depth = COLOR_8;\n\t\tbreak;\n\tcase 6:\n\t\tvideo->color_depth = COLOR_6;\n\t\tbreak;\n\tdefault:\n\t\tvideo->color_depth = COLOR_8;\n\t\tbreak;\n\t}\n\tif (display_info->color_formats & DRM_COLOR_FORMAT_YCBCR444)\n\t\tvideo->color_space = COLOR_YCBCR444;\n\telse if (display_info->color_formats & DRM_COLOR_FORMAT_YCBCR422)\n\t\tvideo->color_space = COLOR_YCBCR422;\n\telse\n\t\tvideo->color_space = COLOR_RGB;\n\n\t \n\tof_property_read_u32(dp_node, \"samsung,color-space\",\n\t\t\t     &video->color_space);\n\tof_property_read_u32(dp_node, \"samsung,dynamic-range\",\n\t\t\t     &video->dynamic_range);\n\tof_property_read_u32(dp_node, \"samsung,ycbcr-coeff\",\n\t\t\t     &video->ycbcr_coeff);\n\tof_property_read_u32(dp_node, \"samsung,color-depth\",\n\t\t\t     &video->color_depth);\n\tif (of_property_read_bool(dp_node, \"hsync-active-high\"))\n\t\tvideo->h_sync_polarity = true;\n\tif (of_property_read_bool(dp_node, \"vsync-active-high\"))\n\t\tvideo->v_sync_polarity = true;\n\tif (of_property_read_bool(dp_node, \"interlaced\"))\n\t\tvideo->interlaced = true;\n}\n\nstatic const struct drm_bridge_funcs analogix_dp_bridge_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_pre_enable = analogix_dp_bridge_atomic_pre_enable,\n\t.atomic_enable = analogix_dp_bridge_atomic_enable,\n\t.atomic_disable = analogix_dp_bridge_atomic_disable,\n\t.atomic_post_disable = analogix_dp_bridge_atomic_post_disable,\n\t.mode_set = analogix_dp_bridge_mode_set,\n\t.attach = analogix_dp_bridge_attach,\n};\n\nstatic int analogix_dp_create_bridge(struct drm_device *drm_dev,\n\t\t\t\t     struct analogix_dp_device *dp)\n{\n\tstruct drm_bridge *bridge;\n\n\tbridge = devm_kzalloc(drm_dev->dev, sizeof(*bridge), GFP_KERNEL);\n\tif (!bridge) {\n\t\tDRM_ERROR(\"failed to allocate for drm bridge\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdp->bridge = bridge;\n\n\tbridge->driver_private = dp;\n\tbridge->funcs = &analogix_dp_bridge_funcs;\n\n\treturn drm_bridge_attach(dp->encoder, bridge, NULL, 0);\n}\n\nstatic int analogix_dp_dt_parse_pdata(struct analogix_dp_device *dp)\n{\n\tstruct device_node *dp_node = dp->dev->of_node;\n\tstruct video_info *video_info = &dp->video_info;\n\n\tswitch (dp->plat_data->dev_type) {\n\tcase RK3288_DP:\n\tcase RK3399_EDP:\n\t\t \n\t\tvideo_info->max_link_rate = 0x0A;\n\t\tvideo_info->max_lane_count = 0x04;\n\t\tbreak;\n\tcase EXYNOS_DP:\n\t\t \n\t\tof_property_read_u32(dp_node, \"samsung,link-rate\",\n\t\t\t\t     &video_info->max_link_rate);\n\t\tof_property_read_u32(dp_node, \"samsung,lane-count\",\n\t\t\t\t     &video_info->max_lane_count);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t analogix_dpaux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t       struct drm_dp_aux_msg *msg)\n{\n\tstruct analogix_dp_device *dp = to_dp(aux);\n\tint ret;\n\n\tpm_runtime_get_sync(dp->dev);\n\n\tret = analogix_dp_detect_hpd(dp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = analogix_dp_transfer(dp, msg);\nout:\n\tpm_runtime_mark_last_busy(dp->dev);\n\tpm_runtime_put_autosuspend(dp->dev);\n\n\treturn ret;\n}\n\nstruct analogix_dp_device *\nanalogix_dp_probe(struct device *dev, struct analogix_dp_plat_data *plat_data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct analogix_dp_device *dp;\n\tstruct resource *res;\n\tunsigned int irq_flags;\n\tint ret;\n\n\tif (!plat_data) {\n\t\tdev_err(dev, \"Invalided input plat_data\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdp = devm_kzalloc(dev, sizeof(struct analogix_dp_device), GFP_KERNEL);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdp->dev = &pdev->dev;\n\tdp->dpms_mode = DRM_MODE_DPMS_OFF;\n\n\tmutex_init(&dp->panel_lock);\n\tdp->panel_is_modeset = false;\n\n\t \n\tdp->plat_data = plat_data;\n\n\tret = analogix_dp_dt_parse_pdata(dp);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tdp->phy = devm_phy_get(dp->dev, \"dp\");\n\tif (IS_ERR(dp->phy)) {\n\t\tdev_err(dp->dev, \"no DP phy configured\\n\");\n\t\tret = PTR_ERR(dp->phy);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret == -ENOSYS || ret == -ENODEV)\n\t\t\t\tdp->phy = NULL;\n\t\t\telse\n\t\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tdp->clock = devm_clk_get(&pdev->dev, \"dp\");\n\tif (IS_ERR(dp->clock)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn ERR_CAST(dp->clock);\n\t}\n\n\tclk_prepare_enable(dp->clock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tdp->reg_base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(dp->reg_base)) {\n\t\tret = PTR_ERR(dp->reg_base);\n\t\tgoto err_disable_clk;\n\t}\n\n\tdp->force_hpd = of_property_read_bool(dev->of_node, \"force-hpd\");\n\n\t \n\tdp->hpd_gpiod = devm_gpiod_get_optional(dev, \"hpd\", GPIOD_IN);\n\tif (!dp->hpd_gpiod)\n\t\tdp->hpd_gpiod = devm_gpiod_get_optional(dev, \"samsung,hpd\",\n\t\t\t\t\t\t\tGPIOD_IN);\n\tif (IS_ERR(dp->hpd_gpiod)) {\n\t\tdev_err(dev, \"error getting HDP GPIO: %ld\\n\",\n\t\t\tPTR_ERR(dp->hpd_gpiod));\n\t\tret = PTR_ERR(dp->hpd_gpiod);\n\t\tgoto err_disable_clk;\n\t}\n\n\tif (dp->hpd_gpiod) {\n\t\t \n\t\tdp->irq = gpiod_to_irq(dp->hpd_gpiod);\n\t\tirq_flags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;\n\t} else {\n\t\tdp->irq = platform_get_irq(pdev, 0);\n\t\tirq_flags = 0;\n\t}\n\n\tif (dp->irq == -ENXIO) {\n\t\tdev_err(&pdev->dev, \"failed to get irq\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_disable_clk;\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, dp->irq,\n\t\t\t\t\tanalogix_dp_hardirq,\n\t\t\t\t\tanalogix_dp_irq_thread,\n\t\t\t\t\tirq_flags, \"analogix-dp\", dp);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request irq\\n\");\n\t\tgoto err_disable_clk;\n\t}\n\tdisable_irq(dp->irq);\n\n\treturn dp;\n\nerr_disable_clk:\n\tclk_disable_unprepare(dp->clock);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(analogix_dp_probe);\n\nint analogix_dp_bind(struct analogix_dp_device *dp, struct drm_device *drm_dev)\n{\n\tint ret;\n\n\tdp->drm_dev = drm_dev;\n\tdp->encoder = dp->plat_data->encoder;\n\n\tdp->aux.name = \"DP-AUX\";\n\tdp->aux.transfer = analogix_dpaux_transfer;\n\tdp->aux.dev = dp->dev;\n\tdp->aux.drm_dev = drm_dev;\n\n\tret = drm_dp_aux_register(&dp->aux);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_use_autosuspend(dp->dev);\n\tpm_runtime_set_autosuspend_delay(dp->dev, 100);\n\tpm_runtime_enable(dp->dev);\n\n\tret = analogix_dp_create_bridge(drm_dev, dp);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to create bridge (%d)\\n\", ret);\n\t\tgoto err_disable_pm_runtime;\n\t}\n\n\treturn 0;\n\nerr_disable_pm_runtime:\n\tpm_runtime_dont_use_autosuspend(dp->dev);\n\tpm_runtime_disable(dp->dev);\n\tdrm_dp_aux_unregister(&dp->aux);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(analogix_dp_bind);\n\nvoid analogix_dp_unbind(struct analogix_dp_device *dp)\n{\n\tanalogix_dp_bridge_disable(dp->bridge);\n\tdp->connector.funcs->destroy(&dp->connector);\n\n\tif (dp->plat_data->panel) {\n\t\tif (drm_panel_unprepare(dp->plat_data->panel))\n\t\t\tDRM_ERROR(\"failed to turnoff the panel\\n\");\n\t}\n\n\tdrm_dp_aux_unregister(&dp->aux);\n\tpm_runtime_dont_use_autosuspend(dp->dev);\n\tpm_runtime_disable(dp->dev);\n}\nEXPORT_SYMBOL_GPL(analogix_dp_unbind);\n\nvoid analogix_dp_remove(struct analogix_dp_device *dp)\n{\n\tclk_disable_unprepare(dp->clock);\n}\nEXPORT_SYMBOL_GPL(analogix_dp_remove);\n\n#ifdef CONFIG_PM\nint analogix_dp_suspend(struct analogix_dp_device *dp)\n{\n\tclk_disable_unprepare(dp->clock);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(analogix_dp_suspend);\n\nint analogix_dp_resume(struct analogix_dp_device *dp)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(dp->clock);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to prepare_enable the clock clk [%d]\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(analogix_dp_resume);\n#endif\n\nint analogix_dp_start_crc(struct drm_connector *connector)\n{\n\tstruct analogix_dp_device *dp = to_dp(connector);\n\n\tif (!connector->state->crtc) {\n\t\tDRM_ERROR(\"Connector %s doesn't currently have a CRTC.\\n\",\n\t\t\t  connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn drm_dp_start_crc(&dp->aux, connector->state->crtc);\n}\nEXPORT_SYMBOL_GPL(analogix_dp_start_crc);\n\nint analogix_dp_stop_crc(struct drm_connector *connector)\n{\n\tstruct analogix_dp_device *dp = to_dp(connector);\n\n\treturn drm_dp_stop_crc(&dp->aux);\n}\nEXPORT_SYMBOL_GPL(analogix_dp_stop_crc);\n\nMODULE_AUTHOR(\"Jingoo Han <jg1.han@samsung.com>\");\nMODULE_DESCRIPTION(\"Analogix DP Core Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}