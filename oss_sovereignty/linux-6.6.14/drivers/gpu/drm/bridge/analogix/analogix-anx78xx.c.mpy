{
  "module_name": "analogix-anx78xx.c",
  "hash_id": "24812d205c6a3bd729fcdd0997ff5090cdef20408f347f97f0e51d955056f2a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/analogix-anx78xx.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"analogix-anx78xx.h\"\n\n#define I2C_NUM_ADDRESSES\t5\n#define I2C_IDX_TX_P0\t\t0\n#define I2C_IDX_TX_P1\t\t1\n#define I2C_IDX_TX_P2\t\t2\n#define I2C_IDX_RX_P0\t\t3\n#define I2C_IDX_RX_P1\t\t4\n\n#define XTAL_CLK\t\t270  \n\nstatic const u8 anx7808_i2c_addresses[] = {\n\t[I2C_IDX_TX_P0] = 0x78,\n\t[I2C_IDX_TX_P1] = 0x7a,\n\t[I2C_IDX_TX_P2] = 0x72,\n\t[I2C_IDX_RX_P0] = 0x7e,\n\t[I2C_IDX_RX_P1] = 0x80,\n};\n\nstatic const u8 anx781x_i2c_addresses[] = {\n\t[I2C_IDX_TX_P0] = 0x70,\n\t[I2C_IDX_TX_P1] = 0x7a,\n\t[I2C_IDX_TX_P2] = 0x72,\n\t[I2C_IDX_RX_P0] = 0x7e,\n\t[I2C_IDX_RX_P1] = 0x80,\n};\n\nstruct anx78xx_platform_data {\n\tstruct regulator *dvdd10;\n\tstruct gpio_desc *gpiod_hpd;\n\tstruct gpio_desc *gpiod_pd;\n\tstruct gpio_desc *gpiod_reset;\n\n\tint hpd_irq;\n\tint intp_irq;\n};\n\nstruct anx78xx {\n\tstruct drm_dp_aux aux;\n\tstruct drm_bridge bridge;\n\tstruct i2c_client *client;\n\tstruct edid *edid;\n\tstruct drm_connector connector;\n\tstruct anx78xx_platform_data pdata;\n\tstruct mutex lock;\n\n\t \n\tstruct i2c_client *i2c_dummy[I2C_NUM_ADDRESSES];\n\tstruct regmap *map[I2C_NUM_ADDRESSES];\n\n\tu16 chipid;\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\n\tbool powered;\n};\n\nstatic inline struct anx78xx *connector_to_anx78xx(struct drm_connector *c)\n{\n\treturn container_of(c, struct anx78xx, connector);\n}\n\nstatic inline struct anx78xx *bridge_to_anx78xx(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct anx78xx, bridge);\n}\n\nstatic int anx78xx_set_bits(struct regmap *map, u8 reg, u8 mask)\n{\n\treturn regmap_update_bits(map, reg, mask, mask);\n}\n\nstatic int anx78xx_clear_bits(struct regmap *map, u8 reg, u8 mask)\n{\n\treturn regmap_update_bits(map, reg, mask, 0);\n}\n\nstatic ssize_t anx78xx_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t    struct drm_dp_aux_msg *msg)\n{\n\tstruct anx78xx *anx78xx = container_of(aux, struct anx78xx, aux);\n\treturn anx_dp_aux_transfer(anx78xx->map[I2C_IDX_TX_P0], msg);\n}\n\nstatic int anx78xx_set_hpd(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t\t SP_TMDS_CTRL_BASE + 7, SP_PD_RT);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL3_REG,\n\t\t\t       SP_HPD_OUT);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int anx78xx_clear_hpd(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL3_REG,\n\t\t\t\t SP_HPD_OUT);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t       SP_TMDS_CTRL_BASE + 7, SP_PD_RT);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence tmds_phy_initialization[] = {\n\t{ SP_TMDS_CTRL_BASE +  1, 0x90 },\n\t{ SP_TMDS_CTRL_BASE +  2, 0xa9 },\n\t{ SP_TMDS_CTRL_BASE +  6, 0x92 },\n\t{ SP_TMDS_CTRL_BASE +  7, 0x80 },\n\t{ SP_TMDS_CTRL_BASE + 20, 0xf2 },\n\t{ SP_TMDS_CTRL_BASE + 22, 0xc4 },\n\t{ SP_TMDS_CTRL_BASE + 23, 0x18 },\n};\n\nstatic int anx78xx_rx_initialization(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_HDMI_MUTE_CTRL_REG,\n\t\t\t   SP_AUD_MUTE | SP_VID_MUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0], SP_CHIP_CTRL_REG,\n\t\t\t       SP_MAN_HDMI5V_DET | SP_PLLLOCK_CKDT_EN |\n\t\t\t       SP_DIGITAL_CKDT_EN);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t       SP_SOFTWARE_RESET1_REG, SP_HDCP_MAN_RST |\n\t\t\t       SP_SW_MAN_RST | SP_TMDS_RST | SP_VIDEO_RST);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t\t SP_SOFTWARE_RESET1_REG, SP_HDCP_MAN_RST |\n\t\t\t\t SP_SW_MAN_RST | SP_TMDS_RST | SP_VIDEO_RST);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t       SP_AUD_EXCEPTION_ENABLE_BASE + 1, BIT(5) |\n\t\t\t       BIT(6));\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t       SP_AUD_EXCEPTION_ENABLE_BASE + 3,\n\t\t\t       SP_AEC_EN21);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0], SP_AUDVID_CTRL_REG,\n\t\t\t       SP_AVC_EN | SP_AAC_OE | SP_AAC_EN);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t\t SP_SYSTEM_POWER_DOWN1_REG, SP_PWDN_CTRL);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t       SP_VID_DATA_RANGE_CTRL_REG, SP_R2Y_INPUT_LIMIT);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t   SP_DP_EXTRA_I2C_DEV_ADDR_REG, SP_I2C_EXTRA_ADDR);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_multi_reg_write(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t\t     tmds_phy_initialization,\n\t\t\t\t     ARRAY_SIZE(tmds_phy_initialization));\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_clear_hpd(anx78xx);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const u8 dp_tx_output_precise_tune_bits[20] = {\n\t0x01, 0x03, 0x07, 0x7f, 0x71, 0x6b, 0x7f,\n\t0x73, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00,\n\t0x0c, 0x42, 0x1e, 0x3e, 0x72, 0x7e,\n};\n\nstatic int anx78xx_link_phy_initialization(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_ANALOG_CTRL0_REG,\n\t\t\t   0x02);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_bulk_write(anx78xx->map[I2C_IDX_TX_P1],\n\t\t\t\tSP_DP_TX_LT_CTRL0_REG,\n\t\t\t\tdp_tx_output_precise_tune_bits,\n\t\t\t\tARRAY_SIZE(dp_tx_output_precise_tune_bits));\n\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int anx78xx_xtal_clk_sel(struct anx78xx *anx78xx)\n{\n\tunsigned int value;\n\tint err;\n\n\terr = regmap_update_bits(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t\t SP_ANALOG_DEBUG2_REG,\n\t\t\t\t SP_XTAL_FRQ | SP_FORCE_SW_OFF_BYPASS,\n\t\t\t\t SP_XTAL_FRQ_27M);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL3_REG,\n\t\t\t   XTAL_CLK & SP_WAIT_COUNTER_7_0_MASK);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL4_REG,\n\t\t\t   ((XTAL_CLK & 0xff00) >> 2) | (XTAL_CLK / 10));\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t   SP_I2C_GEN_10US_TIMER0_REG, XTAL_CLK & 0xff);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t   SP_I2C_GEN_10US_TIMER1_REG,\n\t\t\t   (XTAL_CLK & 0xff00) >> 8);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_MISC_CTRL_REG,\n\t\t\t   XTAL_CLK / 10 - 1);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t  SP_HDMI_US_TIMER_CTRL_REG,\n\t\t\t  &value);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t   SP_HDMI_US_TIMER_CTRL_REG,\n\t\t\t   (value & SP_MS_TIMER_MARGIN_10_8_MASK) |\n\t\t\t   ((((XTAL_CLK / 10) >> 1) - 2) << 3));\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence otp_key_protect[] = {\n\t{ SP_OTP_KEY_PROTECT1_REG, SP_OTP_PSW1 },\n\t{ SP_OTP_KEY_PROTECT2_REG, SP_OTP_PSW2 },\n\t{ SP_OTP_KEY_PROTECT3_REG, SP_OTP_PSW3 },\n};\n\nstatic int anx78xx_tx_initialization(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_AUX_CH_CTRL2_REG,\n\t\t\t   0x30);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_AUX_CH_CTRL2_REG, 0x08);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t SP_DP_HDCP_CTRL_REG, SP_AUTO_EN |\n\t\t\t\t SP_AUTO_START);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_multi_reg_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t     otp_key_protect,\n\t\t\t\t     ARRAY_SIZE(otp_key_protect));\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_HDCP_KEY_COMMAND_REG, SP_DISABLE_SYNC_HDCP);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL8_REG,\n\t\t\t   SP_VID_VRES_TH);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_HDCP_AUTO_TIMER_REG,\n\t\t\t   0x00);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_HDCP_CTRL_REG, SP_LINK_POLLING);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_LINK_DEBUG_CTRL_REG, SP_M_VID_DEBUG);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t       SP_ANALOG_DEBUG2_REG, SP_POWERON_TIME_1P5MS);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_xtal_clk_sel(anx78xx);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_AUX_DEFER_CTRL_REG,\n\t\t\t   SP_DEFER_CTRL_EN | 0x0c);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_POLLING_CTRL_REG,\n\t\t\t       SP_AUTO_POLLING_DISABLE);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t   SP_HDCP_LINK_CHECK_TIMER_REG, 0x1d);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_MISC_CTRL_REG, SP_EQ_TRAINING_LOOP);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_ANALOG_POWER_DOWN_REG, SP_CH0_PD);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_link_phy_initialization(anx78xx);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_DP_M_CALCULATION_CTRL_REG, SP_M_GEN_CLK_SEL);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int anx78xx_enable_interrupts(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_INT_CTRL_REG, 0x01);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t   SP_COMMON_INT_MASK4_REG, SP_HPD_LOST | SP_HPD_PLUG);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_DP_INT_MASK1_REG,\n\t\t\t   SP_TRAINING_FINISH);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_INT_MASK1_REG,\n\t\t\t   SP_CKDT_CHG | SP_SCDT_CHG);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void anx78xx_poweron(struct anx78xx *anx78xx)\n{\n\tstruct anx78xx_platform_data *pdata = &anx78xx->pdata;\n\tint err;\n\n\tif (WARN_ON(anx78xx->powered))\n\t\treturn;\n\n\tif (pdata->dvdd10) {\n\t\terr = regulator_enable(pdata->dvdd10);\n\t\tif (err) {\n\t\t\tDRM_ERROR(\"Failed to enable DVDD10 regulator: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tgpiod_set_value_cansleep(pdata->gpiod_reset, 1);\n\tusleep_range(1000, 2000);\n\n\tgpiod_set_value_cansleep(pdata->gpiod_pd, 0);\n\tusleep_range(1000, 2000);\n\n\tgpiod_set_value_cansleep(pdata->gpiod_reset, 0);\n\n\t \n\tanx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_POWERDOWN_CTRL_REG,\n\t\t\t SP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD | SP_LINK_PD);\n\tanx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2], SP_POWERDOWN_CTRL_REG,\n\t\t\t   SP_REGISTER_PD | SP_TOTAL_PD);\n\n\tanx78xx->powered = true;\n}\n\nstatic void anx78xx_poweroff(struct anx78xx *anx78xx)\n{\n\tstruct anx78xx_platform_data *pdata = &anx78xx->pdata;\n\tint err;\n\n\tif (WARN_ON(!anx78xx->powered))\n\t\treturn;\n\n\tgpiod_set_value_cansleep(pdata->gpiod_reset, 1);\n\tusleep_range(1000, 2000);\n\n\tgpiod_set_value_cansleep(pdata->gpiod_pd, 1);\n\tusleep_range(1000, 2000);\n\n\tif (pdata->dvdd10) {\n\t\terr = regulator_disable(pdata->dvdd10);\n\t\tif (err) {\n\t\t\tDRM_ERROR(\"Failed to disable DVDD10 regulator: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tanx78xx->powered = false;\n}\n\nstatic int anx78xx_start(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\t \n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t\t SP_POWERDOWN_CTRL_REG,\n\t\t\t\t SP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD |\n\t\t\t\t SP_LINK_PD);\n\n\terr = anx78xx_enable_interrupts(anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to enable interrupts: %d\\n\", err);\n\t\tgoto err_poweroff;\n\t}\n\n\terr = anx78xx_rx_initialization(anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed receiver initialization: %d\\n\", err);\n\t\tgoto err_poweroff;\n\t}\n\n\terr = anx78xx_tx_initialization(anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed transmitter initialization: %d\\n\", err);\n\t\tgoto err_poweroff;\n\t}\n\n\t \n\tusleep_range(10000, 15000);\n\n\treturn 0;\n\nerr_poweroff:\n\tDRM_ERROR(\"Failed SlimPort transmitter initialization: %d\\n\", err);\n\tanx78xx_poweroff(anx78xx);\n\n\treturn err;\n}\n\nstatic int anx78xx_init_pdata(struct anx78xx *anx78xx)\n{\n\tstruct anx78xx_platform_data *pdata = &anx78xx->pdata;\n\tstruct device *dev = &anx78xx->client->dev;\n\n\t \n\tpdata->dvdd10 = devm_regulator_get(dev, \"dvdd10\");\n\tif (IS_ERR(pdata->dvdd10)) {\n\t\tif (PTR_ERR(pdata->dvdd10) != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"DVDD10 regulator not found\\n\");\n\n\t\treturn PTR_ERR(pdata->dvdd10);\n\t}\n\n\t \n\tpdata->gpiod_hpd = devm_gpiod_get(dev, \"hpd\", GPIOD_IN);\n\tif (IS_ERR(pdata->gpiod_hpd))\n\t\treturn PTR_ERR(pdata->gpiod_hpd);\n\n\t \n\tpdata->gpiod_pd = devm_gpiod_get(dev, \"pd\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(pdata->gpiod_pd))\n\t\treturn PTR_ERR(pdata->gpiod_pd);\n\n\t \n\tpdata->gpiod_reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\n\treturn PTR_ERR_OR_ZERO(pdata->gpiod_reset);\n}\n\nstatic int anx78xx_dp_link_training(struct anx78xx *anx78xx)\n{\n\tu8 dp_bw, dpcd[2];\n\tint err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_HDMI_MUTE_CTRL_REG,\n\t\t\t   0x0);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t\t SP_POWERDOWN_CTRL_REG,\n\t\t\t\t SP_TOTAL_PD);\n\tif (err)\n\t\treturn err;\n\n\terr = drm_dp_dpcd_readb(&anx78xx->aux, DP_MAX_LINK_RATE, &dp_bw);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (dp_bw) {\n\tcase DP_LINK_BW_1_62:\n\tcase DP_LINK_BW_2_7:\n\tcase DP_LINK_BW_5_4:\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"DP bandwidth (%#02x) not supported\\n\", dp_bw);\n\t\treturn -EINVAL;\n\t}\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL1_REG,\n\t\t\t       SP_VIDEO_MUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t\t SP_VID_CTRL1_REG, SP_VIDEO_EN);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = drm_dp_dpcd_read(&anx78xx->aux, DP_DPCD_REV,\n\t\t\t       &anx78xx->dpcd, DP_RECEIVER_CAP_SIZE);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to read DPCD: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t SP_DP_ANALOG_POWER_DOWN_REG, SP_CH0_PD);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (anx78xx->dpcd[DP_DPCD_REV] >= 0x11) {\n\t\terr = drm_dp_dpcd_readb(&anx78xx->aux, DP_SET_POWER, &dpcd[0]);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"Failed to read DP_SET_POWER register: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn err;\n\t\t}\n\n\t\tdpcd[0] &= ~DP_SET_POWER_MASK;\n\t\tdpcd[0] |= DP_SET_POWER_D0;\n\n\t\terr = drm_dp_dpcd_writeb(&anx78xx->aux, DP_SET_POWER, dpcd[0]);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"Failed to power up DisplayPort link: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t   SP_DP_DOWNSPREAD_CTRL1_REG, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (anx78xx->dpcd[DP_MAX_DOWNSPREAD] & DP_MAX_DOWNSPREAD_0_5) {\n\t\tDRM_DEBUG(\"Enable downspread on the sink\\n\");\n\t\t \n\t\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t   SP_DP_DOWNSPREAD_CTRL1_REG, 8);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = drm_dp_dpcd_writeb(&anx78xx->aux, DP_DOWNSPREAD_CTRL,\n\t\t\t\t\t DP_SPREAD_AMP_0_5);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\terr = drm_dp_dpcd_writeb(&anx78xx->aux, DP_DOWNSPREAD_CTRL, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (drm_dp_enhanced_frame_cap(anx78xx->dpcd))\n\t\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t       SP_DP_SYSTEM_CTRL_BASE + 4,\n\t\t\t\t       SP_ENHANCED_MODE);\n\telse\n\t\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t\t SP_DP_SYSTEM_CTRL_BASE + 4,\n\t\t\t\t\t SP_ENHANCED_MODE);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t   SP_DP_MAIN_LINK_BW_SET_REG,\n\t\t\t   anx78xx->dpcd[DP_MAX_LINK_RATE]);\n\tif (err)\n\t\treturn err;\n\n\tdpcd[1] = drm_dp_max_lane_count(anx78xx->dpcd);\n\n\tif (drm_dp_enhanced_frame_cap(anx78xx->dpcd))\n\t\tdpcd[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\terr = drm_dp_dpcd_write(&anx78xx->aux, DP_LINK_BW_SET, dpcd,\n\t\t\t\tsizeof(dpcd));\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to configure link: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P0], SP_DP_LT_CTRL_REG,\n\t\t\t   SP_LT_EN);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int anx78xx_config_dp_output(struct anx78xx *anx78xx)\n{\n\tint err;\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL1_REG,\n\t\t\t\t SP_VIDEO_MUTE);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_VID_CTRL1_REG,\n\t\t\t       SP_VIDEO_EN);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int anx78xx_send_video_infoframe(struct anx78xx *anx78xx,\n\t\t\t\t\tstruct hdmi_avi_infoframe *frame)\n{\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\n\tint err;\n\n\terr = hdmi_avi_infoframe_pack(frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to pack AVI infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = anx78xx_clear_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t\t SP_PACKET_SEND_CTRL_REG, SP_AVI_IF_EN);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_bulk_write(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t\tSP_INFOFRAME_AVI_DB1_REG, buffer,\n\t\t\t\tframe->length);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_PACKET_SEND_CTRL_REG, SP_AVI_IF_UD);\n\tif (err)\n\t\treturn err;\n\n\terr = anx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P0],\n\t\t\t       SP_PACKET_SEND_CTRL_REG, SP_AVI_IF_EN);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int anx78xx_get_downstream_info(struct anx78xx *anx78xx)\n{\n\tu8 value;\n\tint err;\n\n\terr = drm_dp_dpcd_readb(&anx78xx->aux, DP_SINK_COUNT, &value);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Get sink count failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!DP_GET_SINK_COUNT(value)) {\n\t\tDRM_ERROR(\"Downstream disconnected\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int anx78xx_get_modes(struct drm_connector *connector)\n{\n\tstruct anx78xx *anx78xx = connector_to_anx78xx(connector);\n\tint err, num_modes = 0;\n\n\tif (WARN_ON(!anx78xx->powered))\n\t\treturn 0;\n\n\tif (anx78xx->edid)\n\t\treturn drm_add_edid_modes(connector, anx78xx->edid);\n\n\tmutex_lock(&anx78xx->lock);\n\n\terr = anx78xx_get_downstream_info(anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to get downstream info: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\tanx78xx->edid = drm_get_edid(connector, &anx78xx->aux.ddc);\n\tif (!anx78xx->edid) {\n\t\tDRM_ERROR(\"Failed to read EDID\\n\");\n\t\tgoto unlock;\n\t}\n\n\terr = drm_connector_update_edid_property(connector,\n\t\t\t\t\t\t anx78xx->edid);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to update EDID property: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\tnum_modes = drm_add_edid_modes(connector, anx78xx->edid);\n\nunlock:\n\tmutex_unlock(&anx78xx->lock);\n\n\treturn num_modes;\n}\n\nstatic const struct drm_connector_helper_funcs anx78xx_connector_helper_funcs = {\n\t.get_modes = anx78xx_get_modes,\n};\n\nstatic enum drm_connector_status anx78xx_detect(struct drm_connector *connector,\n\t\t\t\t\t\tbool force)\n{\n\tstruct anx78xx *anx78xx = connector_to_anx78xx(connector);\n\n\tif (!gpiod_get_value(anx78xx->pdata.gpiod_hpd))\n\t\treturn connector_status_disconnected;\n\n\treturn connector_status_connected;\n}\n\nstatic const struct drm_connector_funcs anx78xx_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = anx78xx_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int anx78xx_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\n\tint err;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {\n\t\tDRM_ERROR(\"Fix bridge driver to make connector optional!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tanx78xx->aux.name = \"DP-AUX\";\n\tanx78xx->aux.dev = &anx78xx->client->dev;\n\tanx78xx->aux.drm_dev = bridge->dev;\n\tanx78xx->aux.transfer = anx78xx_aux_transfer;\n\n\terr = drm_dp_aux_register(&anx78xx->aux);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to register aux channel: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = drm_connector_init(bridge->dev, &anx78xx->connector,\n\t\t\t\t &anx78xx_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to initialize connector: %d\\n\", err);\n\t\tgoto aux_unregister;\n\t}\n\n\tdrm_connector_helper_add(&anx78xx->connector,\n\t\t\t\t &anx78xx_connector_helper_funcs);\n\n\tanx78xx->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\terr = drm_connector_attach_encoder(&anx78xx->connector,\n\t\t\t\t\t   bridge->encoder);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to link up connector to encoder: %d\\n\", err);\n\t\tgoto connector_cleanup;\n\t}\n\n\terr = drm_connector_register(&anx78xx->connector);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to register connector: %d\\n\", err);\n\t\tgoto connector_cleanup;\n\t}\n\n\treturn 0;\nconnector_cleanup:\n\tdrm_connector_cleanup(&anx78xx->connector);\naux_unregister:\n\tdrm_dp_aux_unregister(&anx78xx->aux);\n\treturn err;\n}\n\nstatic void anx78xx_bridge_detach(struct drm_bridge *bridge)\n{\n\tdrm_dp_aux_unregister(&bridge_to_anx78xx(bridge)->aux);\n}\n\nstatic enum drm_mode_status\nanx78xx_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_info *info,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\t \n\tif (mode->clock > 154000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void anx78xx_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\n\n\t \n\tanx78xx_set_bits(anx78xx->map[I2C_IDX_TX_P2], SP_POWERDOWN_CTRL_REG,\n\t\t\t SP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD | SP_LINK_PD);\n}\n\nstatic void anx78xx_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\n\tstruct hdmi_avi_infoframe frame;\n\tint err;\n\n\tif (WARN_ON(!anx78xx->powered))\n\t\treturn;\n\n\tmutex_lock(&anx78xx->lock);\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       &anx78xx->connector,\n\t\t\t\t\t\t       adjusted_mode);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to setup AVI infoframe: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\terr = anx78xx_send_video_infoframe(anx78xx, &frame);\n\tif (err)\n\t\tDRM_ERROR(\"Failed to send AVI infoframe: %d\\n\", err);\n\nunlock:\n\tmutex_unlock(&anx78xx->lock);\n}\n\nstatic void anx78xx_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct anx78xx *anx78xx = bridge_to_anx78xx(bridge);\n\tint err;\n\n\terr = anx78xx_start(anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to initialize: %d\\n\", err);\n\t\treturn;\n\t}\n\n\terr = anx78xx_set_hpd(anx78xx);\n\tif (err)\n\t\tDRM_ERROR(\"Failed to set HPD: %d\\n\", err);\n}\n\nstatic const struct drm_bridge_funcs anx78xx_bridge_funcs = {\n\t.attach = anx78xx_bridge_attach,\n\t.detach = anx78xx_bridge_detach,\n\t.mode_valid = anx78xx_bridge_mode_valid,\n\t.disable = anx78xx_bridge_disable,\n\t.mode_set = anx78xx_bridge_mode_set,\n\t.enable = anx78xx_bridge_enable,\n};\n\nstatic irqreturn_t anx78xx_hpd_threaded_handler(int irq, void *data)\n{\n\tstruct anx78xx *anx78xx = data;\n\tint err;\n\n\tif (anx78xx->powered)\n\t\treturn IRQ_HANDLED;\n\n\tmutex_lock(&anx78xx->lock);\n\n\t \n\tanx78xx_poweron(anx78xx);\n\n\terr = anx78xx_enable_interrupts(anx78xx);\n\tif (err)\n\t\tDRM_ERROR(\"Failed to enable interrupts: %d\\n\", err);\n\n\tmutex_unlock(&anx78xx->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int anx78xx_handle_dp_int_1(struct anx78xx *anx78xx, u8 irq)\n{\n\tint err;\n\n\tDRM_DEBUG_KMS(\"Handle DP interrupt 1: %02x\\n\", irq);\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2], SP_DP_INT_STATUS1_REG,\n\t\t\t   irq);\n\tif (err)\n\t\treturn err;\n\n\tif (irq & SP_TRAINING_FINISH) {\n\t\tDRM_DEBUG_KMS(\"IRQ: hardware link training finished\\n\");\n\t\terr = anx78xx_config_dp_output(anx78xx);\n\t}\n\n\treturn err;\n}\n\nstatic bool anx78xx_handle_common_int_4(struct anx78xx *anx78xx, u8 irq)\n{\n\tbool event = false;\n\tint err;\n\n\tDRM_DEBUG_KMS(\"Handle common interrupt 4: %02x\\n\", irq);\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t   SP_COMMON_INT_STATUS4_REG, irq);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to write SP_COMMON_INT_STATUS4 %d\\n\", err);\n\t\treturn event;\n\t}\n\n\tif (irq & SP_HPD_LOST) {\n\t\tDRM_DEBUG_KMS(\"IRQ: Hot plug detect - cable is pulled out\\n\");\n\t\tevent = true;\n\t\tanx78xx_poweroff(anx78xx);\n\t\t \n\t\tkfree(anx78xx->edid);\n\t\tanx78xx->edid = NULL;\n\t} else if (irq & SP_HPD_PLUG) {\n\t\tDRM_DEBUG_KMS(\"IRQ: Hot plug detect - cable plug\\n\");\n\t\tevent = true;\n\t}\n\n\treturn event;\n}\n\nstatic void anx78xx_handle_hdmi_int_1(struct anx78xx *anx78xx, u8 irq)\n{\n\tunsigned int value;\n\tint err;\n\n\tDRM_DEBUG_KMS(\"Handle HDMI interrupt 1: %02x\\n\", irq);\n\n\terr = regmap_write(anx78xx->map[I2C_IDX_RX_P0], SP_INT_STATUS1_REG,\n\t\t\t   irq);\n\tif (err) {\n\t\tDRM_ERROR(\"Write HDMI int 1 failed: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tif ((irq & SP_CKDT_CHG) || (irq & SP_SCDT_CHG)) {\n\t\tDRM_DEBUG_KMS(\"IRQ: HDMI input detected\\n\");\n\n\t\terr = regmap_read(anx78xx->map[I2C_IDX_RX_P0],\n\t\t\t\t  SP_SYSTEM_STATUS_REG, &value);\n\t\tif (err) {\n\t\t\tDRM_ERROR(\"Read system status reg failed: %d\\n\", err);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(value & SP_TMDS_CLOCK_DET)) {\n\t\t\tDRM_DEBUG_KMS(\"IRQ: *** Waiting for HDMI clock ***\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(value & SP_TMDS_DE_DET)) {\n\t\t\tDRM_DEBUG_KMS(\"IRQ: *** Waiting for HDMI signal ***\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\terr = anx78xx_dp_link_training(anx78xx);\n\t\tif (err)\n\t\t\tDRM_ERROR(\"Failed to start link training: %d\\n\", err);\n\t}\n}\n\nstatic irqreturn_t anx78xx_intp_threaded_handler(int unused, void *data)\n{\n\tstruct anx78xx *anx78xx = data;\n\tbool event = false;\n\tunsigned int irq;\n\tint err;\n\n\tmutex_lock(&anx78xx->lock);\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DP_INT_STATUS1_REG,\n\t\t\t  &irq);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to read DP interrupt 1 status: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\tif (irq)\n\t\tanx78xx_handle_dp_int_1(anx78xx, irq);\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_TX_P2],\n\t\t\t  SP_COMMON_INT_STATUS4_REG, &irq);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to read common interrupt 4 status: %d\\n\",\n\t\t\t  err);\n\t\tgoto unlock;\n\t}\n\n\tif (irq)\n\t\tevent = anx78xx_handle_common_int_4(anx78xx, irq);\n\n\t \n\tif (!anx78xx->powered)\n\t\tgoto unlock;\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_RX_P0], SP_INT_STATUS1_REG,\n\t\t\t  &irq);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to read HDMI int 1 status: %d\\n\", err);\n\t\tgoto unlock;\n\t}\n\n\tif (irq)\n\t\tanx78xx_handle_hdmi_int_1(anx78xx, irq);\n\nunlock:\n\tmutex_unlock(&anx78xx->lock);\n\n\tif (event)\n\t\tdrm_helper_hpd_irq_event(anx78xx->connector.dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void unregister_i2c_dummy_clients(struct anx78xx *anx78xx)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(anx78xx->i2c_dummy); i++)\n\t\ti2c_unregister_device(anx78xx->i2c_dummy[i]);\n}\n\nstatic const struct regmap_config anx78xx_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstatic const u16 anx78xx_chipid_list[] = {\n\t0x7808,\n\t0x7812,\n\t0x7814,\n\t0x7818,\n};\n\nstatic int anx78xx_i2c_probe(struct i2c_client *client)\n{\n\tstruct anx78xx *anx78xx;\n\tstruct anx78xx_platform_data *pdata;\n\tunsigned int i, idl, idh, version;\n\tconst u8 *i2c_addresses;\n\tbool found = false;\n\tint err;\n\n\tanx78xx = devm_kzalloc(&client->dev, sizeof(*anx78xx), GFP_KERNEL);\n\tif (!anx78xx)\n\t\treturn -ENOMEM;\n\n\tpdata = &anx78xx->pdata;\n\n\tmutex_init(&anx78xx->lock);\n\n#if IS_ENABLED(CONFIG_OF)\n\tanx78xx->bridge.of_node = client->dev.of_node;\n#endif\n\n\tanx78xx->client = client;\n\ti2c_set_clientdata(client, anx78xx);\n\n\terr = anx78xx_init_pdata(anx78xx);\n\tif (err) {\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to initialize pdata: %d\\n\", err);\n\n\t\treturn err;\n\t}\n\n\tpdata->hpd_irq = gpiod_to_irq(pdata->gpiod_hpd);\n\tif (pdata->hpd_irq < 0) {\n\t\tDRM_ERROR(\"Failed to get HPD IRQ: %d\\n\", pdata->hpd_irq);\n\t\treturn -ENODEV;\n\t}\n\n\tpdata->intp_irq = client->irq;\n\tif (!pdata->intp_irq) {\n\t\tDRM_ERROR(\"Failed to get CABLE_DET and INTP IRQ\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\ti2c_addresses = device_get_match_data(&client->dev);\n\tfor (i = 0; i < I2C_NUM_ADDRESSES; i++) {\n\t\tstruct i2c_client *i2c_dummy;\n\n\t\ti2c_dummy = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\t i2c_addresses[i] >> 1);\n\t\tif (IS_ERR(i2c_dummy)) {\n\t\t\terr = PTR_ERR(i2c_dummy);\n\t\t\tDRM_ERROR(\"Failed to reserve I2C bus %02x: %d\\n\",\n\t\t\t\t  i2c_addresses[i], err);\n\t\t\tgoto err_unregister_i2c;\n\t\t}\n\n\t\tanx78xx->i2c_dummy[i] = i2c_dummy;\n\t\tanx78xx->map[i] = devm_regmap_init_i2c(anx78xx->i2c_dummy[i],\n\t\t\t\t\t\t       &anx78xx_regmap_config);\n\t\tif (IS_ERR(anx78xx->map[i])) {\n\t\t\terr = PTR_ERR(anx78xx->map[i]);\n\t\t\tDRM_ERROR(\"Failed regmap initialization %02x\\n\",\n\t\t\t\t  i2c_addresses[i]);\n\t\t\tgoto err_unregister_i2c;\n\t\t}\n\t}\n\n\t \n\tanx78xx_poweron(anx78xx);\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DEVICE_IDL_REG,\n\t\t\t  &idl);\n\tif (err)\n\t\tgoto err_poweroff;\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DEVICE_IDH_REG,\n\t\t\t  &idh);\n\tif (err)\n\t\tgoto err_poweroff;\n\n\tanx78xx->chipid = (u8)idl | ((u8)idh << 8);\n\n\terr = regmap_read(anx78xx->map[I2C_IDX_TX_P2], SP_DEVICE_VERSION_REG,\n\t\t\t  &version);\n\tif (err)\n\t\tgoto err_poweroff;\n\n\tfor (i = 0; i < ARRAY_SIZE(anx78xx_chipid_list); i++) {\n\t\tif (anx78xx->chipid == anx78xx_chipid_list[i]) {\n\t\t\tDRM_INFO(\"Found ANX%x (ver. %d) SlimPort Transmitter\\n\",\n\t\t\t\t anx78xx->chipid, version);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\tDRM_ERROR(\"ANX%x (ver. %d) not supported by this driver\\n\",\n\t\t\t  anx78xx->chipid, version);\n\t\terr = -ENODEV;\n\t\tgoto err_poweroff;\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, pdata->hpd_irq, NULL,\n\t\t\t\t\tanx78xx_hpd_threaded_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"anx78xx-hpd\", anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to request CABLE_DET threaded IRQ: %d\\n\",\n\t\t\t  err);\n\t\tgoto err_poweroff;\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, pdata->intp_irq, NULL,\n\t\t\t\t\tanx78xx_intp_threaded_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"anx78xx-intp\", anx78xx);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to request INTP threaded IRQ: %d\\n\", err);\n\t\tgoto err_poweroff;\n\t}\n\n\tanx78xx->bridge.funcs = &anx78xx_bridge_funcs;\n\n\tdrm_bridge_add(&anx78xx->bridge);\n\n\t \n\tif (!gpiod_get_value(anx78xx->pdata.gpiod_hpd))\n\t\tanx78xx_poweroff(anx78xx);\n\n\treturn 0;\n\nerr_poweroff:\n\tanx78xx_poweroff(anx78xx);\n\nerr_unregister_i2c:\n\tunregister_i2c_dummy_clients(anx78xx);\n\treturn err;\n}\n\nstatic void anx78xx_i2c_remove(struct i2c_client *client)\n{\n\tstruct anx78xx *anx78xx = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&anx78xx->bridge);\n\n\tunregister_i2c_dummy_clients(anx78xx);\n\n\tkfree(anx78xx->edid);\n}\n\nstatic const struct i2c_device_id anx78xx_id[] = {\n\t{ \"anx7814\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, anx78xx_id);\n\nstatic const struct of_device_id anx78xx_match_table[] = {\n\t{ .compatible = \"analogix,anx7808\", .data = anx7808_i2c_addresses },\n\t{ .compatible = \"analogix,anx7812\", .data = anx781x_i2c_addresses },\n\t{ .compatible = \"analogix,anx7814\", .data = anx781x_i2c_addresses },\n\t{ .compatible = \"analogix,anx7818\", .data = anx781x_i2c_addresses },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, anx78xx_match_table);\n\nstatic struct i2c_driver anx78xx_driver = {\n\t.driver = {\n\t\t   .name = \"anx7814\",\n\t\t   .of_match_table = anx78xx_match_table,\n\t\t  },\n\t.probe = anx78xx_i2c_probe,\n\t.remove = anx78xx_i2c_remove,\n\t.id_table = anx78xx_id,\n};\nmodule_i2c_driver(anx78xx_driver);\n\nMODULE_DESCRIPTION(\"ANX78xx SlimPort Transmitter driver\");\nMODULE_AUTHOR(\"Enric Balletbo i Serra <enric.balletbo@collabora.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}