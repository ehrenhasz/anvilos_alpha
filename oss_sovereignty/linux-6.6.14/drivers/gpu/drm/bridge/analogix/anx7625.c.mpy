{
  "module_name": "anx7625.c",
  "hash_id": "3aff53995a368653693ec2beafaf464778d113b2cf35ca7d652e7bd29efb4839",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/anx7625.c",
  "human_readable_source": "\n \n#include <linux/gcd.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include <media/v4l2-fwnode.h>\n#include <sound/hdmi-codec.h>\n#include <video/display_timing.h>\n\n#include \"anx7625.h\"\n\n \nstatic int i2c_access_workaround(struct anx7625_data *ctx,\n\t\t\t\t struct i2c_client *client)\n{\n\tu8 offset;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tif (client == ctx->last_client)\n\t\treturn 0;\n\n\tctx->last_client = client;\n\n\tif (client == ctx->i2c.tcpc_client)\n\t\toffset = RSVD_00_ADDR;\n\telse if (client == ctx->i2c.tx_p0_client)\n\t\toffset = RSVD_D1_ADDR;\n\telse if (client == ctx->i2c.tx_p1_client)\n\t\toffset = RSVD_60_ADDR;\n\telse if (client == ctx->i2c.rx_p0_client)\n\t\toffset = RSVD_39_ADDR;\n\telse if (client == ctx->i2c.rx_p1_client)\n\t\toffset = RSVD_7F_ADDR;\n\telse\n\t\toffset = RSVD_00_ADDR;\n\n\tret = i2c_smbus_write_byte_data(client, offset, 0x00);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"fail to access i2c id=%x\\n:%x\",\n\t\t\t      client->addr, offset);\n\n\treturn ret;\n}\n\nstatic int anx7625_reg_read(struct anx7625_data *ctx,\n\t\t\t    struct i2c_client *client, u8 reg_addr)\n{\n\tint ret;\n\tstruct device *dev = &client->dev;\n\n\ti2c_access_workaround(ctx, client);\n\n\tret = i2c_smbus_read_byte_data(client, reg_addr);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"read i2c fail id=%x:%x\\n\",\n\t\t\t      client->addr, reg_addr);\n\n\treturn ret;\n}\n\nstatic int anx7625_reg_block_read(struct anx7625_data *ctx,\n\t\t\t\t  struct i2c_client *client,\n\t\t\t\t  u8 reg_addr, u8 len, u8 *buf)\n{\n\tint ret;\n\tstruct device *dev = &client->dev;\n\n\ti2c_access_workaround(ctx, client);\n\n\tret = i2c_smbus_read_i2c_block_data(client, reg_addr, len, buf);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"read i2c block fail id=%x:%x\\n\",\n\t\t\t      client->addr, reg_addr);\n\n\treturn ret;\n}\n\nstatic int anx7625_reg_write(struct anx7625_data *ctx,\n\t\t\t     struct i2c_client *client,\n\t\t\t     u8 reg_addr, u8 reg_val)\n{\n\tint ret;\n\tstruct device *dev = &client->dev;\n\n\ti2c_access_workaround(ctx, client);\n\n\tret = i2c_smbus_write_byte_data(client, reg_addr, reg_val);\n\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"fail to write i2c id=%x\\n:%x\",\n\t\t\t      client->addr, reg_addr);\n\n\treturn ret;\n}\n\nstatic int anx7625_reg_block_write(struct anx7625_data *ctx,\n\t\t\t\t   struct i2c_client *client,\n\t\t\t\t   u8 reg_addr, u8 len, u8 *buf)\n{\n\tint ret;\n\tstruct device *dev = &client->dev;\n\n\ti2c_access_workaround(ctx, client);\n\n\tret = i2c_smbus_write_i2c_block_data(client, reg_addr, len, buf);\n\tif (ret < 0)\n\t\tdev_err(dev, \"write i2c block failed id=%x\\n:%x\",\n\t\t\tclient->addr, reg_addr);\n\n\treturn ret;\n}\n\nstatic int anx7625_write_or(struct anx7625_data *ctx,\n\t\t\t    struct i2c_client *client,\n\t\t\t    u8 offset, u8 mask)\n{\n\tint val;\n\n\tval = anx7625_reg_read(ctx, client, offset);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn anx7625_reg_write(ctx, client, offset, (val | (mask)));\n}\n\nstatic int anx7625_write_and(struct anx7625_data *ctx,\n\t\t\t     struct i2c_client *client,\n\t\t\t     u8 offset, u8 mask)\n{\n\tint val;\n\n\tval = anx7625_reg_read(ctx, client, offset);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn anx7625_reg_write(ctx, client, offset, (val & (mask)));\n}\n\nstatic int anx7625_write_and_or(struct anx7625_data *ctx,\n\t\t\t\tstruct i2c_client *client,\n\t\t\t\tu8 offset, u8 and_mask, u8 or_mask)\n{\n\tint val;\n\n\tval = anx7625_reg_read(ctx, client, offset);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn anx7625_reg_write(ctx, client,\n\t\t\t\t offset, (val & and_mask) | (or_mask));\n}\n\nstatic int anx7625_config_bit_matrix(struct anx7625_data *ctx)\n{\n\tint i, ret;\n\n\tret = anx7625_write_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t       AUDIO_CONTROL_REGISTER, 0x80);\n\tfor (i = 0; i < 13; i++)\n\t\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t\t VIDEO_BIT_MATRIX_12 + i,\n\t\t\t\t\t 0x18 + i);\n\n\treturn ret;\n}\n\nstatic int anx7625_read_ctrl_status_p0(struct anx7625_data *ctx)\n{\n\treturn anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, AP_AUX_CTRL_STATUS);\n}\n\nstatic int wait_aux_op_finish(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint val;\n\tint ret;\n\n\tret = readx_poll_timeout(anx7625_read_ctrl_status_p0,\n\t\t\t\t ctx, val,\n\t\t\t\t (!(val & AP_AUX_CTRL_OP_EN) || (val < 0)),\n\t\t\t\t 2000,\n\t\t\t\t 2000 * 150);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"aux operation fail!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tval = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t       AP_AUX_CTRL_STATUS);\n\tif (val < 0 || (val & 0x0F)) {\n\t\tDRM_DEV_ERROR(dev, \"aux status %02x\\n\", val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int anx7625_aux_trans(struct anx7625_data *ctx, u8 op, u32 address,\n\t\t\t     u8 len, u8 *buf)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\tu8 addrh, addrm, addrl;\n\tu8 cmd;\n\tbool is_write = !(op & DP_AUX_I2C_READ);\n\n\tif (len > DP_AUX_MAX_PAYLOAD_BYTES) {\n\t\tdev_err(dev, \"exceed aux buffer len.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!len)\n\t\treturn len;\n\n\taddrl = address & 0xFF;\n\taddrm = (address >> 8) & 0xFF;\n\taddrh = (address >> 16) & 0xFF;\n\n\tif (!is_write)\n\t\top &= ~DP_AUX_I2C_MOT;\n\tcmd = DPCD_CMD(len, op);\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_COMMAND, cmd);\n\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_ADDR_7_0, addrl);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_ADDR_15_8, addrm);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_ADDR_19_16, addrh);\n\n\tif (is_write)\n\t\tret |= anx7625_reg_block_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t\t       AP_AUX_BUFF_START, len, buf);\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_CTRL_STATUS, AP_AUX_CTRL_OP_EN);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot access aux related register.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = wait_aux_op_finish(ctx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"aux IO error: wait aux op finish.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (is_write)\n\t\treturn len;\n\n\t \n\tret = anx7625_reg_block_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t     AP_AUX_BUFF_START, len, buf);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"read dpcd register failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn len;\n}\n\nstatic int anx7625_video_mute_control(struct anx7625_data *ctx,\n\t\t\t\t      u8 status)\n{\n\tint ret;\n\n\tif (status) {\n\t\t \n\t\tret = anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t       AP_AV_STATUS, AP_MIPI_MUTE);\n\t\t \n\t\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t\t AP_AV_STATUS, (u8)~AP_MIPI_RX_EN);\n\t} else {\n\t\t \n\t\tret = anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t\tAP_AV_STATUS, (u8)~AP_MIPI_MUTE);\n\t\t \n\t\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t\tAP_AV_STATUS, AP_MIPI_RX_EN);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void anx7625_reduction_of_a_fraction(unsigned long *a, unsigned long *b)\n{\n\tunsigned long gcd_num;\n\tunsigned long tmp_a, tmp_b;\n\tu32 i = 1;\n\n\tgcd_num = gcd(*a, *b);\n\t*a /= gcd_num;\n\t*b /= gcd_num;\n\n\ttmp_a = *a;\n\ttmp_b = *b;\n\n\twhile ((*a > MAX_UNSIGNED_24BIT) || (*b > MAX_UNSIGNED_24BIT)) {\n\t\ti++;\n\t\t*a = tmp_a / i;\n\t\t*b = tmp_b / i;\n\t}\n\n\t \n\twhile ((*a < MAX_UNSIGNED_24BIT) && (*b < MAX_UNSIGNED_24BIT)) {\n\t\t*a <<= 1;\n\t\t*b <<= 1;\n\t}\n\n\t*a >>= 1;\n\t*b >>= 1;\n}\n\nstatic int anx7625_calculate_m_n(u32 pixelclock,\n\t\t\t\t unsigned long *m,\n\t\t\t\t unsigned long *n,\n\t\t\t\t u8 *post_divider)\n{\n\tif (pixelclock > PLL_OUT_FREQ_ABS_MAX / POST_DIVIDER_MIN) {\n\t\t \n\t\tDRM_ERROR(\"pixelclock too high, act(%d), maximum(%lu)\\n\",\n\t\t\t  pixelclock,\n\t\t\t  PLL_OUT_FREQ_ABS_MAX / POST_DIVIDER_MIN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pixelclock < PLL_OUT_FREQ_ABS_MIN / POST_DIVIDER_MAX) {\n\t\t \n\t\tDRM_ERROR(\"pixelclock too low, act(%d), maximum(%lu)\\n\",\n\t\t\t  pixelclock,\n\t\t\t  PLL_OUT_FREQ_ABS_MIN / POST_DIVIDER_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (*post_divider = 1;\n\t\tpixelclock < (PLL_OUT_FREQ_MIN / (*post_divider));)\n\t\t*post_divider += 1;\n\n\tif (*post_divider > POST_DIVIDER_MAX) {\n\t\tfor (*post_divider = 1;\n\t\t\t(pixelclock <\n\t\t\t (PLL_OUT_FREQ_ABS_MIN / (*post_divider)));)\n\t\t\t*post_divider += 1;\n\n\t\tif (*post_divider > POST_DIVIDER_MAX) {\n\t\t\tDRM_ERROR(\"cannot find property post_divider(%d)\\n\",\n\t\t\t\t  *post_divider);\n\t\t\treturn -EDOM;\n\t\t}\n\t}\n\n\t \n\tif (*post_divider == 7) {\n\t\t \n\t\t*post_divider = 8;\n\t} else if (*post_divider == 11) {\n\t\t \n\t\t*post_divider = 12;\n\t} else if ((*post_divider == 13) || (*post_divider == 14)) {\n\t\t \n\t\t*post_divider = 15;\n\t}\n\n\tif (pixelclock * (*post_divider) > PLL_OUT_FREQ_ABS_MAX) {\n\t\tDRM_ERROR(\"act clock(%u) large than maximum(%lu)\\n\",\n\t\t\t  pixelclock * (*post_divider),\n\t\t\t  PLL_OUT_FREQ_ABS_MAX);\n\t\treturn -EDOM;\n\t}\n\n\t*m = pixelclock;\n\t*n = XTAL_FRQ / (*post_divider);\n\n\tanx7625_reduction_of_a_fraction(m, n);\n\n\treturn 0;\n}\n\nstatic int anx7625_odfc_config(struct anx7625_data *ctx,\n\t\t\t       u8 post_divider)\n{\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_16,\n\t\t\t\t~(REF_CLK_27000KHZ << MIPI_FREF_D_IND));\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_16,\n\t\t\t\t(REF_CLK_27000KHZ << MIPI_FREF_D_IND));\n\t \n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_DIGITAL_PLL_8, 0x0f);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_8,\n\t\t\t\tpost_divider << 4);\n\n\t \n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_7,\n\t\t\t\t ~MIPI_PLL_VCO_TUNE_REG_VAL);\n\n\t \n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_7,\n\t\t\t\t ~MIPI_PLL_RESET_N);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_7,\n\t\t\t\tMIPI_PLL_RESET_N);\n\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"IO error.\\n\");\n\n\treturn ret;\n}\n\n \nstatic int anx7625_set_k_value(struct anx7625_data *ctx)\n{\n\tstruct edid *edid = (struct edid *)ctx->slimport_edid_p.edid_raw_data;\n\n\tif (edid->mfg_id[0] == IVO_MID0 && edid->mfg_id[1] == IVO_MID1)\n\t\treturn anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t\t MIPI_DIGITAL_ADJ_1, 0x3B);\n\n\treturn anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_DIGITAL_ADJ_1, 0x3D);\n}\n\nstatic int anx7625_dsi_video_timing_config(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tunsigned long m, n;\n\tu16 htotal;\n\tint ret;\n\tu8 post_divider = 0;\n\n\tret = anx7625_calculate_m_n(ctx->dt.pixelclock.min * 1000,\n\t\t\t\t    &m, &n, &post_divider);\n\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"cannot get property m n value.\\n\");\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"compute M(%lu), N(%lu), divider(%d).\\n\",\n\t\t\t     m, n, post_divider);\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client, PIXEL_CLOCK_L,\n\t\t\t\t(ctx->dt.pixelclock.min / 1000) & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client, PIXEL_CLOCK_H,\n\t\t\t\t (ctx->dt.pixelclock.min / 1000) >> 8);\n\t \n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p1_client,\n\t\t\tMIPI_LANE_CTRL_0, 0xfc);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\tMIPI_LANE_CTRL_0, ctx->pdata.mipi_lanes - 1);\n\n\t \n\thtotal = ctx->dt.hactive.min + ctx->dt.hfront_porch.min +\n\t\tctx->dt.hback_porch.min + ctx->dt.hsync_len.min;\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_TOTAL_PIXELS_L, htotal & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_TOTAL_PIXELS_H, htotal >> 8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_ACTIVE_PIXELS_L, ctx->dt.hactive.min & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_ACTIVE_PIXELS_H, ctx->dt.hactive.min >> 8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_FRONT_PORCH_L, ctx->dt.hfront_porch.min);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_FRONT_PORCH_H,\n\t\t\tctx->dt.hfront_porch.min >> 8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_SYNC_WIDTH_L, ctx->dt.hsync_len.min);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_SYNC_WIDTH_H, ctx->dt.hsync_len.min >> 8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_BACK_PORCH_L, ctx->dt.hback_porch.min);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tHORIZONTAL_BACK_PORCH_H, ctx->dt.hback_porch.min >> 8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client, ACTIVE_LINES_L,\n\t\t\tctx->dt.vactive.min);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client, ACTIVE_LINES_H,\n\t\t\tctx->dt.vactive.min >> 8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tVERTICAL_FRONT_PORCH, ctx->dt.vfront_porch.min);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tVERTICAL_SYNC_WIDTH, ctx->dt.vsync_len.min);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p2_client,\n\t\t\tVERTICAL_BACK_PORCH, ctx->dt.vback_porch.min);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\tMIPI_PLL_M_NUM_23_16, (m >> 16) & 0xff);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\tMIPI_PLL_M_NUM_15_8, (m >> 8) & 0xff);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\tMIPI_PLL_M_NUM_7_0, (m & 0xff));\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\tMIPI_PLL_N_NUM_23_16, (n >> 16) & 0xff);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\tMIPI_PLL_N_NUM_15_8, (n >> 8) & 0xff);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client, MIPI_PLL_N_NUM_7_0,\n\t\t\t(n & 0xff));\n\n\tanx7625_set_k_value(ctx);\n\n\tret |= anx7625_odfc_config(ctx, post_divider - 1);\n\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"mipi dsi setup IO error.\\n\");\n\n\treturn ret;\n}\n\nstatic int anx7625_swap_dsi_lane3(struct anx7625_data *ctx)\n{\n\tint val;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tval = anx7625_reg_read(ctx, ctx->i2c.rx_p1_client, MIPI_SWAP);\n\tif (val < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : access MIPI_SWAP.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tval |= (1 << MIPI_SWAP_CH3);\n\treturn anx7625_reg_write(ctx, ctx->i2c.rx_p1_client, MIPI_SWAP, val);\n}\n\nstatic int anx7625_api_dsi_config(struct anx7625_data *ctx)\n\n{\n\tint val, ret;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tret = anx7625_swap_dsi_lane3(ctx);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : swap dsi lane 3 fail.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval = (0 << MIPI_HS_PWD_CLK)\t\t|\n\t\t(0 << MIPI_HS_RT_CLK)\t\t|\n\t\t(0 << MIPI_PD_CLK)\t\t|\n\t\t(1 << MIPI_CLK_RT_MANUAL_PD_EN)\t|\n\t\t(1 << MIPI_CLK_HS_MANUAL_PD_EN)\t|\n\t\t(0 << MIPI_CLK_DET_DET_BYPASS)\t|\n\t\t(0 << MIPI_CLK_MISS_CTRL)\t|\n\t\t(0 << MIPI_PD_LPTX_CH_MANUAL_PD_EN);\n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\tMIPI_PHY_CONTROL_3, val);\n\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_TIME_HS_PRPR, 0x10);\n\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_18,\n\t\t\t\tSELECT_DSI << MIPI_DPI_SELECT);\n\n\tret |= anx7625_dsi_video_timing_config(ctx);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"dsi video timing config fail\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_6,\n\t\t\t\t~(MIPI_M_NUM_READY | MIPI_N_NUM_READY));\n\tusleep_range(1000, 1100);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, MIPI_DIGITAL_PLL_6,\n\t\t\t\tMIPI_M_NUM_READY | MIPI_N_NUM_READY);\n\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_VIDEO_STABLE_CNT, 0x02);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_LANE_CTRL_10, 0x00);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_LANE_CTRL_10, 0x80);\n\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"IO error : mipi dsi enable init fail.\\n\");\n\n\treturn ret;\n}\n\nstatic int anx7625_dsi_config(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"config dsi.\\n\");\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tR_DSC_CTRL_0, ~DSC_EN);\n\n\tret |= anx7625_api_dsi_config(ctx);\n\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : api dsi config error.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t       AP_AV_STATUS, AP_MIPI_RX_EN);\n\t \n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AV_STATUS, (u8)~AP_MIPI_MUTE);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"IO error : enable mipi rx fail.\\n\");\n\telse\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"success to config DSI\\n\");\n\n\treturn ret;\n}\n\nstatic int anx7625_api_dpi_config(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tu16 freq = ctx->dt.pixelclock.min / 1000;\n\tint ret;\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tPIXEL_CLOCK_L, freq & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t PIXEL_CLOCK_H, (freq >> 8));\n\n\t \n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_DIGITAL_PLL_9, 0x20);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_LANE_CTRL_10, 0x08);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p1_client,\n\t\t\t\t MIPI_DIGITAL_PLL_18, 0x1C);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t VIDEO_CONTROL_0, 0x06);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"IO error : dpi phy set failed.\\n\");\n\n\treturn ret;\n}\n\nstatic int anx7625_dpi_config(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"config dpi\\n\");\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tR_DSC_CTRL_0, ~DSC_EN);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : disable dsc failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = anx7625_config_bit_matrix(ctx);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"config bit matrix failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = anx7625_api_dpi_config(ctx);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"mipi phy(dpi) setup failed.\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t       AP_AV_STATUS, AP_MIPI_RX_EN);\n\t \n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AV_STATUS, (u8)~AP_MIPI_MUTE);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"IO error : enable mipi rx failed.\\n\");\n\n\treturn ret;\n}\n\nstatic int anx7625_read_flash_status(struct anx7625_data *ctx)\n{\n\treturn anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, R_RAM_CTRL);\n}\n\nstatic int anx7625_hdcp_key_probe(struct anx7625_data *ctx)\n{\n\tint ret, val;\n\tstruct device *dev = ctx->dev;\n\tu8 ident[FLASH_BUF_LEN];\n\n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tFLASH_ADDR_HIGH, 0x91);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t FLASH_ADDR_LOW, 0xA0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"IO error : set key flash address.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tFLASH_LEN_HIGH, (FLASH_BUF_LEN - 1) >> 8);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t FLASH_LEN_LOW, (FLASH_BUF_LEN - 1) & 0xFF);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"IO error : set key flash len.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tR_FLASH_RW_CTRL, FLASH_READ);\n\tret |= readx_poll_timeout(anx7625_read_flash_status,\n\t\t\t\t  ctx, val,\n\t\t\t\t  ((val & FLASH_DONE) || (val < 0)),\n\t\t\t\t  2000,\n\t\t\t\t  2000 * 150);\n\tif (ret) {\n\t\tdev_err(dev, \"flash read access fail!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = anx7625_reg_block_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t     FLASH_BUF_BASE_ADDR,\n\t\t\t\t     FLASH_BUF_LEN, ident);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"read flash data fail!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (ident[29] == 0xFF && ident[30] == 0xFF && ident[31] == 0xFF)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int anx7625_hdcp_key_load(struct anx7625_data *ctx)\n{\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tR_BOOT_RETRY, 0x12);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t FLASH_ADDR_HIGH, HDCP14KEY_START_ADDR >> 8);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t FLASH_ADDR_LOW, HDCP14KEY_START_ADDR & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t R_RAM_LEN_H, HDCP14KEY_SIZE >> 12);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t R_RAM_LEN_L, HDCP14KEY_SIZE >> 4);\n\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t R_RAM_ADDR_H, 0);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t R_RAM_ADDR_L, 0);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t R_RAM_CTRL, DECRYPT_EN | LOAD_START);\n\tdev_dbg(dev, \"load HDCP 1.4 key done\\n\");\n\treturn ret;\n}\n\nstatic int anx7625_hdcp_disable(struct anx7625_data *ctx)\n{\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\tdev_dbg(dev, \"disable HDCP 1.4\\n\");\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.rx_p1_client, 0xee, 0x9f);\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xec, 0x10);\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xff, 0x01);\n\tif (ret < 0)\n\t\tdev_err(dev, \"fail to disable HDCP\\n\");\n\n\treturn anx7625_write_and(ctx, ctx->i2c.tx_p0_client,\n\t\t\t\t TX_HDCP_CTRL0, ~HARD_AUTH_EN & 0xFF);\n}\n\nstatic int anx7625_hdcp_enable(struct anx7625_data *ctx)\n{\n\tu8 bcap;\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\tret = anx7625_hdcp_key_probe(ctx);\n\tif (ret) {\n\t\tdev_dbg(dev, \"no key found, not to do hdcp\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = anx7625_aux_trans(ctx, DP_AUX_NATIVE_READ, DP_AUX_HDCP_BCAPS, 1, &bcap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(bcap & DP_BCAPS_HDCP_CAPABLE)) {\n\t\tpr_warn(\"downstream not support HDCP 1.4, cap(%x).\\n\", bcap);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"enable HDCP 1.4\\n\");\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,\n\t\t\t\tTX_HDCP_CTRL0,\n\t\t\t\tKSVLIST_VLD | BKSV_SRM_PASS | RE_AUTHEN);\n\tusleep_range(1000, 1100);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,\n\t\t\t\t TX_HDCP_CTRL0,\n\t\t\t\t KSVLIST_VLD | BKSV_SRM_PASS | RE_AUTHEN);\n\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,\n\t\t\t\t SP_TX_WAIT_KSVR_TIME, 0xc8);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p0_client,\n\t\t\t\t SP_TX_WAIT_R0_TIME, 0xb0);\n\tret |= anx7625_hdcp_key_load(ctx);\n\tif (ret) {\n\t\tpr_warn(\"prepare HDCP key failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xee, 0x20);\n\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xec, 0x10);\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xff, 0x01);\n\tif (ret < 0)\n\t\tdev_err(dev, \"fail to enable HDCP\\n\");\n\n\treturn anx7625_write_or(ctx, ctx->i2c.tx_p0_client,\n\t\t\t\tTX_HDCP_CTRL0, HARD_AUTH_EN);\n}\n\nstatic void anx7625_dp_start(struct anx7625_data *ctx)\n{\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\tu8 data;\n\n\tif (!ctx->display_timing_valid) {\n\t\tDRM_DEV_ERROR(dev, \"mipi not set display timing yet.\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"set downstream sink into normal\\n\");\n\t \n\tdata = DP_SET_POWER_D0;\n\tret = anx7625_aux_trans(ctx, DP_AUX_NATIVE_WRITE, DP_SET_POWER, 1, &data);\n\tif (ret < 0)\n\t\tdev_err(dev, \"IO error : set sink into normal mode fail\\n\");\n\n\t \n\tanx7625_write_and(ctx, ctx->i2c.rx_p1_client, 0xee, 0x9f);\n\n\tif (ctx->pdata.is_dpi)\n\t\tret = anx7625_dpi_config(ctx);\n\telse\n\t\tret = anx7625_dsi_config(ctx);\n\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"MIPI phy setup error.\\n\");\n\n\tctx->hdcp_cp = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;\n\n\tctx->dp_en = 1;\n}\n\nstatic void anx7625_dp_stop(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\tu8 data;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"stop dp output\\n\");\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.tx_p0_client, 0x87, 0xfe);\n\tret |= anx7625_write_and(ctx, ctx->i2c.tx_p2_client, 0x08, 0x7f);\n\n\tret |= anx7625_video_mute_control(ctx, 1);\n\n\tdev_dbg(dev, \"notify downstream enter into standby\\n\");\n\t \n\tdata = DP_SET_POWER_D3;\n\tret |= anx7625_aux_trans(ctx, DP_AUX_NATIVE_WRITE, DP_SET_POWER, 1, &data);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"IO error : mute video fail\\n\");\n\n\tctx->hdcp_cp = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;\n\n\tctx->dp_en = 0;\n}\n\nstatic int sp_tx_rst_aux(struct anx7625_data *ctx)\n{\n\tint ret;\n\n\tret = anx7625_write_or(ctx, ctx->i2c.tx_p2_client, RST_CTRL2,\n\t\t\t       AUX_RST);\n\tret |= anx7625_write_and(ctx, ctx->i2c.tx_p2_client, RST_CTRL2,\n\t\t\t\t ~AUX_RST);\n\treturn ret;\n}\n\nstatic int sp_tx_aux_wr(struct anx7625_data *ctx, u8 offset)\n{\n\tint ret;\n\n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_BUFF_START, offset);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_COMMAND, 0x04);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_CTRL_STATUS, AP_AUX_CTRL_OP_EN);\n\treturn (ret | wait_aux_op_finish(ctx));\n}\n\nstatic int sp_tx_aux_rd(struct anx7625_data *ctx, u8 len_cmd)\n{\n\tint ret;\n\n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_COMMAND, len_cmd);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_CTRL_STATUS, AP_AUX_CTRL_OP_EN);\n\treturn (ret | wait_aux_op_finish(ctx));\n}\n\nstatic int sp_tx_get_edid_block(struct anx7625_data *ctx)\n{\n\tint c = 0;\n\tstruct device *dev = ctx->dev;\n\n\tsp_tx_aux_wr(ctx, 0x7e);\n\tsp_tx_aux_rd(ctx, 0x01);\n\tc = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, AP_AUX_BUFF_START);\n\tif (c < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : access AUX BUFF.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \" EDID Block = %d\\n\", c + 1);\n\n\tif (c > MAX_EDID_BLOCK)\n\t\tc = 1;\n\n\treturn c;\n}\n\nstatic int edid_read(struct anx7625_data *ctx,\n\t\t     u8 offset, u8 *pblock_buf)\n{\n\tint ret, cnt;\n\tstruct device *dev = ctx->dev;\n\n\tfor (cnt = 0; cnt <= EDID_TRY_CNT; cnt++) {\n\t\tsp_tx_aux_wr(ctx, offset);\n\t\t \n\t\tret = sp_tx_aux_rd(ctx, 0xf1);\n\n\t\tif (ret) {\n\t\t\tret = sp_tx_rst_aux(ctx);\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev, \"edid read fail, reset!\\n\");\n\t\t} else {\n\t\t\tret = anx7625_reg_block_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t\t\t     AP_AUX_BUFF_START,\n\t\t\t\t\t\t     MAX_DPCD_BUFFER_SIZE,\n\t\t\t\t\t\t     pblock_buf);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cnt > EDID_TRY_CNT)\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int segments_edid_read(struct anx7625_data *ctx,\n\t\t\t      u8 segment, u8 *buf, u8 offset)\n{\n\tu8 cnt;\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_ADDR_7_0, 0x30);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_COMMAND, 0x04);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_CTRL_STATUS,\n\t\t\t\t AP_AUX_CTRL_ADDRONLY | AP_AUX_CTRL_OP_EN);\n\n\tret |= wait_aux_op_finish(ctx);\n\t \n\tret |= sp_tx_aux_wr(ctx, segment);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_ADDR_7_0, 0x50);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : aux initial fail.\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (cnt = 0; cnt <= EDID_TRY_CNT; cnt++) {\n\t\tsp_tx_aux_wr(ctx, offset);\n\t\t \n\t\tret = sp_tx_aux_rd(ctx, 0xf1);\n\n\t\tif (ret) {\n\t\t\tret = sp_tx_rst_aux(ctx);\n\t\t\tDRM_DEV_ERROR(dev, \"segment read fail, reset!\\n\");\n\t\t} else {\n\t\t\tret = anx7625_reg_block_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t\t\t     AP_AUX_BUFF_START,\n\t\t\t\t\t\t     MAX_DPCD_BUFFER_SIZE, buf);\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cnt > EDID_TRY_CNT)\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int sp_tx_edid_read(struct anx7625_data *ctx,\n\t\t\t   u8 *pedid_blocks_buf)\n{\n\tu8 offset;\n\tint edid_pos;\n\tint count, blocks_num;\n\tu8 pblock_buf[MAX_DPCD_BUFFER_SIZE];\n\tu8 i, j;\n\tint g_edid_break = 0;\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AUX_ADDR_7_0, 0x50);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_ADDR_15_8, 0);\n\tret |= anx7625_write_and(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AUX_ADDR_19_16, 0xf0);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"access aux channel IO error.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tblocks_num = sp_tx_get_edid_block(ctx);\n\tif (blocks_num < 0)\n\t\treturn blocks_num;\n\n\tcount = 0;\n\n\tdo {\n\t\tswitch (count) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\toffset = (i + count * 8) * MAX_DPCD_BUFFER_SIZE;\n\t\t\t\tg_edid_break = edid_read(ctx, offset,\n\t\t\t\t\t\t\t pblock_buf);\n\n\t\t\t\tif (g_edid_break < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(&pedid_blocks_buf[offset],\n\t\t\t\t       pblock_buf,\n\t\t\t\t       MAX_DPCD_BUFFER_SIZE);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\toffset = 0x00;\n\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tedid_pos = (j + count * 8) *\n\t\t\t\t\tMAX_DPCD_BUFFER_SIZE;\n\n\t\t\t\tif (g_edid_break == 1)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = segments_edid_read(ctx, count / 2,\n\t\t\t\t\t\t\t pblock_buf, offset);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tmemcpy(&pedid_blocks_buf[edid_pos],\n\t\t\t\t       pblock_buf,\n\t\t\t\t       MAX_DPCD_BUFFER_SIZE);\n\t\t\t\toffset = offset + 0x10;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\toffset = 0x80;\n\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tedid_pos = (j + count * 8) *\n\t\t\t\t\tMAX_DPCD_BUFFER_SIZE;\n\t\t\t\tif (g_edid_break == 1)\n\t\t\t\t\tbreak;\n\n\t\t\t\tret = segments_edid_read(ctx, count / 2,\n\t\t\t\t\t\t\t pblock_buf, offset);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tmemcpy(&pedid_blocks_buf[edid_pos],\n\t\t\t\t       pblock_buf,\n\t\t\t\t       MAX_DPCD_BUFFER_SIZE);\n\t\t\t\toffset = offset + 0x10;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t} while (blocks_num >= count);\n\n\t \n\tif (!drm_edid_is_valid((struct edid *)pedid_blocks_buf)) {\n\t\tDRM_DEV_ERROR(dev, \"WARNING! edid check fail!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = sp_tx_rst_aux(ctx);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to reset aux channel!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn (blocks_num + 1);\n}\n\nstatic void anx7625_power_on(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret, i;\n\n\tif (!ctx->pdata.low_power_mode) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"not low power mode!\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx->pdata.supplies); i++) {\n\t\tret = regulator_enable(ctx->pdata.supplies[i].consumer);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev, \"cannot enable supply %d: %d\\n\",\n\t\t\t\t\t     i, ret);\n\t\t\tgoto reg_err;\n\t\t}\n\t\tusleep_range(2000, 2100);\n\t}\n\n\tusleep_range(11000, 12000);\n\n\t \n\tgpiod_set_value(ctx->pdata.gpio_p_on, 1);\n\tusleep_range(10000, 11000);\n\t \n\tgpiod_set_value(ctx->pdata.gpio_reset, 1);\n\tusleep_range(10000, 11000);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"power on !\\n\");\n\treturn;\nreg_err:\n\tfor (--i; i >= 0; i--)\n\t\tregulator_disable(ctx->pdata.supplies[i].consumer);\n}\n\nstatic void anx7625_power_standby(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tif (!ctx->pdata.low_power_mode) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"not low power mode!\\n\");\n\t\treturn;\n\t}\n\n\tgpiod_set_value(ctx->pdata.gpio_reset, 0);\n\tusleep_range(1000, 1100);\n\tgpiod_set_value(ctx->pdata.gpio_p_on, 0);\n\tusleep_range(1000, 1100);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(ctx->pdata.supplies),\n\t\t\t\t     ctx->pdata.supplies);\n\tif (ret < 0)\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"cannot disable supplies %d\\n\", ret);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"power down\\n\");\n}\n\n \nstatic void anx7625_config(struct anx7625_data *ctx)\n{\n\tanx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t  XTAL_FRQ_SEL, XTAL_FRQ_27M);\n}\n\nstatic void anx7625_disable_pd_protocol(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client, 0x88, 0x40);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t AP_AV_STATUS, AP_DISABLE_PD);\n\t \n\tret |= anx7625_reg_write(ctx, ctx->i2c.rx_p0_client, 0x88, 0x00);\n\n\tif (ret < 0)\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"disable PD feature fail.\\n\");\n\telse\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"disable PD feature succeeded.\\n\");\n}\n\nstatic int anx7625_ocm_loading_check(struct anx7625_data *ctx)\n{\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tret = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t       FLASH_LOAD_STA);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : access flash load.\\n\");\n\t\treturn ret;\n\t}\n\tif ((ret & FLASH_LOAD_STA_CHK) != FLASH_LOAD_STA_CHK)\n\t\treturn -ENODEV;\n\n\tanx7625_disable_pd_protocol(ctx);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Firmware ver %02x%02x,\",\n\t\t\t     anx7625_reg_read(ctx,\n\t\t\t\t\t      ctx->i2c.rx_p0_client,\n\t\t\t\t\t      OCM_FW_VERSION),\n\t\t\t     anx7625_reg_read(ctx,\n\t\t\t\t\t      ctx->i2c.rx_p0_client,\n\t\t\t\t\t      OCM_FW_REVERSION));\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Driver version %s\\n\",\n\t\t\t     ANX7625_DRV_VERSION);\n\n\treturn 0;\n}\n\nstatic void anx7625_power_on_init(struct anx7625_data *ctx)\n{\n\tint retry_count, i;\n\n\tfor (retry_count = 0; retry_count < 3; retry_count++) {\n\t\tanx7625_power_on(ctx);\n\t\tanx7625_config(ctx);\n\n\t\tfor (i = 0; i < OCM_LOADING_TIME; i++) {\n\t\t\tif (!anx7625_ocm_loading_check(ctx))\n\t\t\t\treturn;\n\t\t\tusleep_range(1000, 1100);\n\t\t}\n\t\tanx7625_power_standby(ctx);\n\t}\n}\n\nstatic void anx7625_init_gpio(struct anx7625_data *platform)\n{\n\tstruct device *dev = platform->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"init gpio\\n\");\n\n\t \n\tplatform->pdata.gpio_p_on =\n\t\tdevm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR_OR_NULL(platform->pdata.gpio_p_on)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"no enable gpio found\\n\");\n\t\tplatform->pdata.gpio_p_on = NULL;\n\t}\n\n\t \n\tplatform->pdata.gpio_reset =\n\t\tdevm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR_OR_NULL(platform->pdata.gpio_reset)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"no reset gpio found\\n\");\n\t\tplatform->pdata.gpio_reset = NULL;\n\t}\n\n\tif (platform->pdata.gpio_p_on && platform->pdata.gpio_reset) {\n\t\tplatform->pdata.low_power_mode = 1;\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"low power mode, pon %d, reset %d.\\n\",\n\t\t\t\t     desc_to_gpio(platform->pdata.gpio_p_on),\n\t\t\t\t     desc_to_gpio(platform->pdata.gpio_reset));\n\t} else {\n\t\tplatform->pdata.low_power_mode = 0;\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"not low power mode.\\n\");\n\t}\n}\n\nstatic void anx7625_stop_dp_work(struct anx7625_data *ctx)\n{\n\tctx->hpd_status = 0;\n\tctx->hpd_high_cnt = 0;\n}\n\nstatic void anx7625_start_dp_work(struct anx7625_data *ctx)\n{\n\tint ret;\n\tstruct device *dev = ctx->dev;\n\n\tif (ctx->hpd_high_cnt >= 2) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"filter useless HPD\\n\");\n\t\treturn;\n\t}\n\n\tctx->hpd_status = 1;\n\tctx->hpd_high_cnt++;\n\n\t \n\tret = anx7625_write_and(ctx, ctx->i2c.rx_p1_client, 0xee, 0x9f);\n\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xec, 0x10);\n\t \n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p1_client, 0xff, 0x01);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"fail to setting HDCP/auth\\n\");\n\t\treturn;\n\t}\n\n\tret = anx7625_reg_read(ctx, ctx->i2c.rx_p1_client, 0x86);\n\tif (ret < 0)\n\t\treturn;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Secure OCM version=%02x\\n\", ret);\n}\n\nstatic int anx7625_read_hpd_status_p0(struct anx7625_data *ctx)\n{\n\tint ret;\n\n\t \n\tret = anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\tHPD_DET_TIMER_BIT0_7, HPD_TIME & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t HPD_DET_TIMER_BIT8_15,\n\t\t\t\t (HPD_TIME >> 8) & 0xFF);\n\tret |= anx7625_reg_write(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t HPD_DET_TIMER_BIT16_23,\n\t\t\t\t (HPD_TIME >> 16) & 0xFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anx7625_reg_read(ctx, ctx->i2c.rx_p0_client, SYSTEM_STSTUS);\n}\n\nstatic int _anx7625_hpd_polling(struct anx7625_data *ctx,\n\t\t\t\tunsigned long wait_us)\n{\n\tint ret, val;\n\tstruct device *dev = ctx->dev;\n\n\t \n\tif (ctx->pdata.intp_irq)\n\t\treturn 0;\n\n\tret = readx_poll_timeout(anx7625_read_hpd_status_p0,\n\t\t\t\t ctx, val,\n\t\t\t\t ((val & HPD_STATUS) || (val < 0)),\n\t\t\t\t wait_us / 100,\n\t\t\t\t wait_us);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"no hpd.\\n\");\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"system status: 0x%x. HPD raise up.\\n\", val);\n\tanx7625_reg_write(ctx, ctx->i2c.tcpc_client,\n\t\t\t  INTR_ALERT_1, 0xFF);\n\tanx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t  INTERFACE_CHANGE_INT, 0);\n\n\tanx7625_start_dp_work(ctx);\n\n\tif (!ctx->pdata.panel_bridge && ctx->bridge_attached)\n\t\tdrm_helper_hpd_irq_event(ctx->bridge.dev);\n\n\treturn 0;\n}\n\nstatic int anx7625_wait_hpd_asserted(struct drm_dp_aux *aux,\n\t\t\t\t     unsigned long wait_us)\n{\n\tstruct anx7625_data *ctx = container_of(aux, struct anx7625_data, aux);\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tpm_runtime_get_sync(dev);\n\tret = _anx7625_hpd_polling(ctx, wait_us);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic void anx7625_remove_edid(struct anx7625_data *ctx)\n{\n\tctx->slimport_edid_p.edid_block_num = -1;\n}\n\nstatic void anx7625_dp_adjust_swing(struct anx7625_data *ctx)\n{\n\tint i;\n\n\tfor (i = 0; i < ctx->pdata.dp_lane0_swing_reg_cnt; i++)\n\t\tanx7625_reg_write(ctx, ctx->i2c.tx_p1_client,\n\t\t\t\t  DP_TX_LANE0_SWING_REG0 + i,\n\t\t\t\t  ctx->pdata.lane0_reg_data[i]);\n\n\tfor (i = 0; i < ctx->pdata.dp_lane1_swing_reg_cnt; i++)\n\t\tanx7625_reg_write(ctx, ctx->i2c.tx_p1_client,\n\t\t\t\t  DP_TX_LANE1_SWING_REG0 + i,\n\t\t\t\t  ctx->pdata.lane1_reg_data[i]);\n}\n\nstatic void dp_hpd_change_handler(struct anx7625_data *ctx, bool on)\n{\n\tstruct device *dev = ctx->dev;\n\n\t \n\tDRM_DEV_DEBUG_DRIVER(dev, \"dp_hpd_change_default_func: %d\\n\",\n\t\t\t     (u32)on);\n\n\tif (on == 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \" HPD low\\n\");\n\t\tanx7625_remove_edid(ctx);\n\t\tanx7625_stop_dp_work(ctx);\n\t} else {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \" HPD high\\n\");\n\t\tanx7625_start_dp_work(ctx);\n\t\tanx7625_dp_adjust_swing(ctx);\n\t}\n}\n\nstatic int anx7625_hpd_change_detect(struct anx7625_data *ctx)\n{\n\tint intr_vector, status;\n\tstruct device *dev = ctx->dev;\n\n\tstatus = anx7625_reg_write(ctx, ctx->i2c.tcpc_client,\n\t\t\t\t   INTR_ALERT_1, 0xFF);\n\tif (status < 0) {\n\t\tDRM_DEV_ERROR(dev, \"cannot clear alert reg.\\n\");\n\t\treturn status;\n\t}\n\n\tintr_vector = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t       INTERFACE_CHANGE_INT);\n\tif (intr_vector < 0) {\n\t\tDRM_DEV_ERROR(dev, \"cannot access interrupt change reg.\\n\");\n\t\treturn intr_vector;\n\t}\n\tDRM_DEV_DEBUG_DRIVER(dev, \"0x7e:0x44=%x\\n\", intr_vector);\n\tstatus = anx7625_reg_write(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t   INTERFACE_CHANGE_INT,\n\t\t\t\t   intr_vector & (~intr_vector));\n\tif (status < 0) {\n\t\tDRM_DEV_ERROR(dev, \"cannot clear interrupt change reg.\\n\");\n\t\treturn status;\n\t}\n\n\tif (!(intr_vector & HPD_STATUS_CHANGE))\n\t\treturn -ENOENT;\n\n\tstatus = anx7625_reg_read(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\t  SYSTEM_STSTUS);\n\tif (status < 0) {\n\t\tDRM_DEV_ERROR(dev, \"cannot clear interrupt status.\\n\");\n\t\treturn status;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"0x7e:0x45=%x\\n\", status);\n\tdp_hpd_change_handler(ctx, status & HPD_STATUS);\n\n\treturn 0;\n}\n\nstatic void anx7625_work_func(struct work_struct *work)\n{\n\tint event;\n\tstruct anx7625_data *ctx = container_of(work,\n\t\t\t\t\t\tstruct anx7625_data, work);\n\n\tmutex_lock(&ctx->lock);\n\n\tif (pm_runtime_suspended(ctx->dev)) {\n\t\tmutex_unlock(&ctx->lock);\n\t\treturn;\n\t}\n\n\tevent = anx7625_hpd_change_detect(ctx);\n\n\tmutex_unlock(&ctx->lock);\n\n\tif (event < 0)\n\t\treturn;\n\n\tif (ctx->bridge_attached)\n\t\tdrm_helper_hpd_irq_event(ctx->bridge.dev);\n}\n\nstatic irqreturn_t anx7625_intr_hpd_isr(int irq, void *data)\n{\n\tstruct anx7625_data *ctx = (struct anx7625_data *)data;\n\n\tqueue_work(ctx->workqueue, &ctx->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int anx7625_get_swing_setting(struct device *dev,\n\t\t\t\t     struct anx7625_platform_data *pdata)\n{\n\tint num_regs;\n\n\tif (of_get_property(dev->of_node,\n\t\t\t    \"analogix,lane0-swing\", &num_regs)) {\n\t\tif (num_regs > DP_TX_SWING_REG_CNT)\n\t\t\tnum_regs = DP_TX_SWING_REG_CNT;\n\n\t\tpdata->dp_lane0_swing_reg_cnt = num_regs;\n\t\tof_property_read_u8_array(dev->of_node, \"analogix,lane0-swing\",\n\t\t\t\t\t  pdata->lane0_reg_data, num_regs);\n\t}\n\n\tif (of_get_property(dev->of_node,\n\t\t\t    \"analogix,lane1-swing\", &num_regs)) {\n\t\tif (num_regs > DP_TX_SWING_REG_CNT)\n\t\t\tnum_regs = DP_TX_SWING_REG_CNT;\n\n\t\tpdata->dp_lane1_swing_reg_cnt = num_regs;\n\t\tof_property_read_u8_array(dev->of_node, \"analogix,lane1-swing\",\n\t\t\t\t\t  pdata->lane1_reg_data, num_regs);\n\t}\n\n\treturn 0;\n}\n\nstatic int anx7625_parse_dt(struct device *dev,\n\t\t\t    struct anx7625_platform_data *pdata)\n{\n\tstruct device_node *np = dev->of_node, *ep0;\n\tint bus_type, mipi_lanes;\n\n\tanx7625_get_swing_setting(dev, pdata);\n\n\tpdata->is_dpi = 0;  \n\tof_node_put(pdata->mipi_host_node);\n\tpdata->mipi_host_node = of_graph_get_remote_node(np, 0, 0);\n\tif (!pdata->mipi_host_node) {\n\t\tDRM_DEV_ERROR(dev, \"fail to get internal panel.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus_type = 0;\n\tmipi_lanes = MAX_LANES_SUPPORT;\n\tep0 = of_graph_get_endpoint_by_regs(np, 0, 0);\n\tif (ep0) {\n\t\tif (of_property_read_u32(ep0, \"bus-type\", &bus_type))\n\t\t\tbus_type = 0;\n\n\t\tmipi_lanes = drm_of_get_data_lanes_count(ep0, 1, MAX_LANES_SUPPORT);\n\t\tof_node_put(ep0);\n\t}\n\n\tif (bus_type == V4L2_FWNODE_BUS_TYPE_DPI)  \n\t\tpdata->is_dpi = 1;\n\n\tpdata->mipi_lanes = MAX_LANES_SUPPORT;\n\tif (mipi_lanes > 0)\n\t\tpdata->mipi_lanes = mipi_lanes;\n\n\tif (pdata->is_dpi)\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"found MIPI DPI host node.\\n\");\n\telse\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"found MIPI DSI host node.\\n\");\n\n\tif (of_property_read_bool(np, \"analogix,audio-enable\"))\n\t\tpdata->audio_en = 1;\n\n\treturn 0;\n}\n\nstatic int anx7625_parse_dt_panel(struct device *dev,\n\t\t\t\t  struct anx7625_platform_data *pdata)\n{\n\tstruct device_node *np = dev->of_node;\n\n\tpdata->panel_bridge = devm_drm_of_get_bridge(dev, np, 1, 0);\n\tif (IS_ERR(pdata->panel_bridge)) {\n\t\tif (PTR_ERR(pdata->panel_bridge) == -ENODEV) {\n\t\t\tpdata->panel_bridge = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn PTR_ERR(pdata->panel_bridge);\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"get panel node.\\n\");\n\n\treturn 0;\n}\n\nstatic bool anx7625_of_panel_on_aux_bus(struct device *dev)\n{\n\tstruct device_node *bus, *panel;\n\n\tbus = of_get_child_by_name(dev->of_node, \"aux-bus\");\n\tif (!bus)\n\t\treturn false;\n\n\tpanel = of_get_child_by_name(bus, \"panel\");\n\tof_node_put(bus);\n\tif (!panel)\n\t\treturn false;\n\tof_node_put(panel);\n\n\treturn true;\n}\n\nstatic inline struct anx7625_data *bridge_to_anx7625(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct anx7625_data, bridge);\n}\n\nstatic ssize_t anx7625_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t    struct drm_dp_aux_msg *msg)\n{\n\tstruct anx7625_data *ctx = container_of(aux, struct anx7625_data, aux);\n\tstruct device *dev = ctx->dev;\n\tu8 request = msg->request & ~DP_AUX_I2C_MOT;\n\tint ret = 0;\n\n\tpm_runtime_get_sync(dev);\n\tmsg->reply = 0;\n\tswitch (request) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tif (!ret)\n\t\tret = anx7625_aux_trans(ctx, msg->request, msg->address,\n\t\t\t\t\tmsg->size, msg->buffer);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic struct edid *anx7625_get_edid(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct s_edid_data *p_edid = &ctx->slimport_edid_p;\n\tint edid_num;\n\tu8 *edid;\n\n\tedid = kmalloc(FOUR_BLOCK_SIZE, GFP_KERNEL);\n\tif (!edid) {\n\t\tDRM_DEV_ERROR(dev, \"Fail to allocate buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ctx->slimport_edid_p.edid_block_num > 0) {\n\t\tmemcpy(edid, ctx->slimport_edid_p.edid_raw_data,\n\t\t       FOUR_BLOCK_SIZE);\n\t\treturn (struct edid *)edid;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\t_anx7625_hpd_polling(ctx, 5000 * 100);\n\tedid_num = sp_tx_edid_read(ctx, p_edid->edid_raw_data);\n\tpm_runtime_put_sync(dev);\n\n\tif (edid_num < 1) {\n\t\tDRM_DEV_ERROR(dev, \"Fail to read EDID: %d\\n\", edid_num);\n\t\tkfree(edid);\n\t\treturn NULL;\n\t}\n\n\tp_edid->edid_block_num = edid_num;\n\n\tmemcpy(edid, ctx->slimport_edid_p.edid_raw_data, FOUR_BLOCK_SIZE);\n\treturn (struct edid *)edid;\n}\n\nstatic enum drm_connector_status anx7625_sink_detect(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"sink detect\\n\");\n\n\tif (ctx->pdata.panel_bridge)\n\t\treturn connector_status_connected;\n\n\treturn ctx->hpd_status ? connector_status_connected :\n\t\t\t\t     connector_status_disconnected;\n}\n\nstatic int anx7625_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t   struct hdmi_codec_daifmt *fmt,\n\t\t\t\t   struct hdmi_codec_params *params)\n{\n\tstruct anx7625_data *ctx = dev_get_drvdata(dev);\n\tint wl, ch, rate;\n\tint ret = 0;\n\n\tif (anx7625_sink_detect(ctx) == connector_status_disconnected) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"DP not connected\\n\");\n\t\treturn 0;\n\t}\n\n\tif (fmt->fmt != HDMI_DSP_A && fmt->fmt != HDMI_I2S) {\n\t\tDRM_DEV_ERROR(dev, \"only supports DSP_A & I2S\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"setting %d Hz, %d bit, %d channels\\n\",\n\t\t\t     params->sample_rate, params->sample_width,\n\t\t\t     params->cea.channels);\n\n\tif (fmt->fmt == HDMI_DSP_A)\n\t\tret = anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t\t   AUDIO_CHANNEL_STATUS_6,\n\t\t\t\t\t   ~I2S_SLAVE_MODE,\n\t\t\t\t\t   TDM_SLAVE_MODE);\n\telse\n\t\tret = anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t\t   AUDIO_CHANNEL_STATUS_6,\n\t\t\t\t\t   ~TDM_SLAVE_MODE,\n\t\t\t\t\t   I2S_SLAVE_MODE);\n\n\t \n\tswitch (params->sample_width) {\n\tcase 16:\n\t\twl = AUDIO_W_LEN_16_20MAX;\n\t\tbreak;\n\tcase 18:\n\t\twl = AUDIO_W_LEN_18_20MAX;\n\t\tbreak;\n\tcase 20:\n\t\twl = AUDIO_W_LEN_20_20MAX;\n\t\tbreak;\n\tcase 24:\n\t\twl = AUDIO_W_LEN_24_24MAX;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"wordlength: %d bit not support\",\n\t\t\t\t     params->sample_width);\n\t\treturn -EINVAL;\n\t}\n\tret |= anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t    AUDIO_CHANNEL_STATUS_5,\n\t\t\t\t    0xf0, wl);\n\n\t \n\tswitch (params->cea.channels) {\n\tcase 2:\n\t\tch = I2S_CH_2;\n\t\tbreak;\n\tcase 4:\n\t\tch = TDM_CH_4;\n\t\tbreak;\n\tcase 6:\n\t\tch = TDM_CH_6;\n\t\tbreak;\n\tcase 8:\n\t\tch = TDM_CH_8;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"channel number: %d not support\",\n\t\t\t\t     params->cea.channels);\n\t\treturn -EINVAL;\n\t}\n\tret |= anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t       AUDIO_CHANNEL_STATUS_6, 0x1f, ch << 5);\n\tif (ch > I2S_CH_2)\n\t\tret |= anx7625_write_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\tAUDIO_CHANNEL_STATUS_6, AUDIO_LAYOUT);\n\telse\n\t\tret |= anx7625_write_and(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\tAUDIO_CHANNEL_STATUS_6, ~AUDIO_LAYOUT);\n\n\t \n\tswitch (params->sample_rate) {\n\tcase 32000:\n\t\trate = AUDIO_FS_32K;\n\t\tbreak;\n\tcase 44100:\n\t\trate = AUDIO_FS_441K;\n\t\tbreak;\n\tcase 48000:\n\t\trate = AUDIO_FS_48K;\n\t\tbreak;\n\tcase 88200:\n\t\trate = AUDIO_FS_882K;\n\t\tbreak;\n\tcase 96000:\n\t\trate = AUDIO_FS_96K;\n\t\tbreak;\n\tcase 176400:\n\t\trate = AUDIO_FS_1764K;\n\t\tbreak;\n\tcase 192000:\n\t\trate = AUDIO_FS_192K;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"sample rate: %d not support\",\n\t\t\t\t     params->sample_rate);\n\t\treturn -EINVAL;\n\t}\n\tret |= anx7625_write_and_or(ctx, ctx->i2c.tx_p2_client,\n\t\t\t\t    AUDIO_CHANNEL_STATUS_4,\n\t\t\t\t    0xf0, rate);\n\tret |= anx7625_write_or(ctx, ctx->i2c.rx_p0_client,\n\t\t\t\tAP_AV_STATUS, AP_AUDIO_CHG);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"IO error : config audio.\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void anx7625_audio_shutdown(struct device *dev, void *data)\n{\n\tDRM_DEV_DEBUG_DRIVER(dev, \"stop audio\\n\");\n}\n\nstatic int anx7625_hdmi_i2s_get_dai_id(struct snd_soc_component *component,\n\t\t\t\t       struct device_node *endpoint)\n{\n\tstruct of_endpoint of_ep;\n\tint ret;\n\n\tret = of_graph_parse_endpoint(endpoint, &of_ep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn 0;\n}\n\nstatic void\nanx7625_audio_update_connector_status(struct anx7625_data *ctx,\n\t\t\t\t      enum drm_connector_status status)\n{\n\tif (ctx->plugged_cb && ctx->codec_dev) {\n\t\tctx->plugged_cb(ctx->codec_dev,\n\t\t\t\tstatus == connector_status_connected);\n\t}\n}\n\nstatic int anx7625_audio_hook_plugged_cb(struct device *dev, void *data,\n\t\t\t\t\t hdmi_codec_plugged_cb fn,\n\t\t\t\t\t struct device *codec_dev)\n{\n\tstruct anx7625_data *ctx = data;\n\n\tctx->plugged_cb = fn;\n\tctx->codec_dev = codec_dev;\n\tanx7625_audio_update_connector_status(ctx, anx7625_sink_detect(ctx));\n\n\treturn 0;\n}\n\nstatic int anx7625_audio_get_eld(struct device *dev, void *data,\n\t\t\t\t u8 *buf, size_t len)\n{\n\tstruct anx7625_data *ctx = dev_get_drvdata(dev);\n\n\tif (!ctx->connector) {\n\t\t \n\t\tmemset(buf, 0, len);\n\t} else {\n\t\tdev_dbg(dev, \"audio copy eld\\n\");\n\t\tmemcpy(buf, ctx->connector->eld,\n\t\t       min(sizeof(ctx->connector->eld), len));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops anx7625_codec_ops = {\n\t.hw_params\t= anx7625_audio_hw_params,\n\t.audio_shutdown = anx7625_audio_shutdown,\n\t.get_eld\t= anx7625_audio_get_eld,\n\t.get_dai_id\t= anx7625_hdmi_i2s_get_dai_id,\n\t.hook_plugged_cb = anx7625_audio_hook_plugged_cb,\n};\n\nstatic void anx7625_unregister_audio(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\n\tif (ctx->audio_pdev) {\n\t\tplatform_device_unregister(ctx->audio_pdev);\n\t\tctx->audio_pdev = NULL;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"unbound to %s\", HDMI_CODEC_DRV_NAME);\n}\n\nstatic int anx7625_register_audio(struct device *dev, struct anx7625_data *ctx)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &anx7625_codec_ops,\n\t\t.max_i2s_channels = 8,\n\t\t.i2s = 1,\n\t\t.data = ctx,\n\t};\n\n\tctx->audio_pdev = platform_device_register_data(dev,\n\t\t\t\t\t\t\tHDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t\tPLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t&codec_data,\n\t\t\t\t\t\t\tsizeof(codec_data));\n\n\tif (IS_ERR(ctx->audio_pdev))\n\t\treturn PTR_ERR(ctx->audio_pdev);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"bound to %s\", HDMI_CODEC_DRV_NAME);\n\n\treturn 0;\n}\n\nstatic int anx7625_setup_dsi_device(struct anx7625_data *ctx)\n{\n\tstruct mipi_dsi_device *dsi;\n\tstruct device *dev = ctx->dev;\n\tstruct mipi_dsi_host *host;\n\tconst struct mipi_dsi_device_info info = {\n\t\t.type = \"anx7625\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\n\thost = of_find_mipi_dsi_host_by_node(ctx->pdata.mipi_host_node);\n\tif (!host) {\n\t\tDRM_DEV_ERROR(dev, \"fail to find dsi host.\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi)) {\n\t\tDRM_DEV_ERROR(dev, \"fail to create dsi device.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsi->lanes = ctx->pdata.mipi_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO\t|\n\t\tMIPI_DSI_MODE_VIDEO_SYNC_PULSE\t|\n\t\tMIPI_DSI_MODE_VIDEO_HSE\t|\n\t\tMIPI_DSI_HS_PKT_END_ALIGNED;\n\n\tctx->dsi = dsi;\n\n\treturn 0;\n}\n\nstatic int anx7625_attach_dsi(struct anx7625_data *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tint ret;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"attach dsi\\n\");\n\n\tret = devm_mipi_dsi_attach(dev, ctx->dsi);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"fail to attach dsi to host.\\n\");\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"attach dsi succeeded.\\n\");\n\n\treturn 0;\n}\n\nstatic void hdcp_check_work_func(struct work_struct *work)\n{\n\tu8 status;\n\tstruct delayed_work *dwork;\n\tstruct anx7625_data *ctx;\n\tstruct device *dev;\n\tstruct drm_device *drm_dev;\n\n\tdwork = to_delayed_work(work);\n\tctx = container_of(dwork, struct anx7625_data, hdcp_work);\n\tdev = ctx->dev;\n\n\tif (!ctx->connector) {\n\t\tdev_err(dev, \"HDCP connector is null!\");\n\t\treturn;\n\t}\n\n\tdrm_dev = ctx->connector->dev;\n\tdrm_modeset_lock(&drm_dev->mode_config.connection_mutex, NULL);\n\tmutex_lock(&ctx->hdcp_wq_lock);\n\n\tstatus = anx7625_reg_read(ctx, ctx->i2c.tx_p0_client, 0);\n\tdev_dbg(dev, \"sink HDCP status check: %.02x\\n\", status);\n\tif (status & BIT(1)) {\n\t\tctx->hdcp_cp = DRM_MODE_CONTENT_PROTECTION_ENABLED;\n\t\tdrm_hdcp_update_content_protection(ctx->connector,\n\t\t\t\t\t\t   ctx->hdcp_cp);\n\t\tdev_dbg(dev, \"update CP to ENABLE\\n\");\n\t}\n\n\tmutex_unlock(&ctx->hdcp_wq_lock);\n\tdrm_modeset_unlock(&drm_dev->mode_config.connection_mutex);\n}\n\nstatic int anx7625_connector_atomic_check(struct anx7625_data *ctx,\n\t\t\t\t\t  struct drm_connector_state *state)\n{\n\tstruct device *dev = ctx->dev;\n\tint cp;\n\n\tdev_dbg(dev, \"hdcp state check\\n\");\n\tcp = state->content_protection;\n\n\tif (cp == ctx->hdcp_cp)\n\t\treturn 0;\n\n\tif (cp == DRM_MODE_CONTENT_PROTECTION_DESIRED) {\n\t\tif (ctx->dp_en) {\n\t\t\tdev_dbg(dev, \"enable HDCP\\n\");\n\t\t\tanx7625_hdcp_enable(ctx);\n\n\t\t\tqueue_delayed_work(ctx->hdcp_workqueue,\n\t\t\t\t\t   &ctx->hdcp_work,\n\t\t\t\t\t   msecs_to_jiffies(2000));\n\t\t}\n\t}\n\n\tif (cp == DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\tif (ctx->hdcp_cp != DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\t\tdev_err(dev, \"current CP is not ENABLED\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tanx7625_hdcp_disable(ctx);\n\t\tctx->hdcp_cp = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;\n\t\tdrm_hdcp_update_content_protection(ctx->connector,\n\t\t\t\t\t\t   ctx->hdcp_cp);\n\t\tdev_dbg(dev, \"update CP to UNDESIRE\\n\");\n\t}\n\n\tif (cp == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\tdev_err(dev, \"Userspace illegal set to PROTECTION ENABLE\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int anx7625_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tint err;\n\tstruct device *dev = ctx->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm attach\\n\");\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\tif (!bridge->encoder) {\n\t\tDRM_DEV_ERROR(dev, \"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tctx->aux.drm_dev = bridge->dev;\n\terr = drm_dp_aux_register(&ctx->aux);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register aux channel: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (ctx->pdata.panel_bridge) {\n\t\terr = drm_bridge_attach(bridge->encoder,\n\t\t\t\t\tctx->pdata.panel_bridge,\n\t\t\t\t\t&ctx->bridge, flags);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tctx->bridge_attached = 1;\n\n\treturn 0;\n}\n\nstatic void anx7625_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\n\tdrm_dp_aux_unregister(&ctx->aux);\n}\n\nstatic enum drm_mode_status\nanx7625_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_info *info,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm mode checking\\n\");\n\n\t \n\tif (mode->clock > SUPPORT_PIXEL_CLOCK) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev,\n\t\t\t\t     \"drm mode invalid, pixelclock too high.\\n\");\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm mode valid.\\n\");\n\n\treturn MODE_OK;\n}\n\nstatic void anx7625_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t    const struct drm_display_mode *old_mode,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm mode set\\n\");\n\n\tctx->dt.pixelclock.min = mode->clock;\n\tctx->dt.hactive.min = mode->hdisplay;\n\tctx->dt.hsync_len.min = mode->hsync_end - mode->hsync_start;\n\tctx->dt.hfront_porch.min = mode->hsync_start - mode->hdisplay;\n\tctx->dt.hback_porch.min = mode->htotal - mode->hsync_end;\n\tctx->dt.vactive.min = mode->vdisplay;\n\tctx->dt.vsync_len.min = mode->vsync_end - mode->vsync_start;\n\tctx->dt.vfront_porch.min = mode->vsync_start - mode->vdisplay;\n\tctx->dt.vback_porch.min = mode->vtotal - mode->vsync_end;\n\n\tctx->display_timing_valid = 1;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"pixelclock(%d).\\n\", ctx->dt.pixelclock.min);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hactive(%d), hsync(%d), hfp(%d), hbp(%d)\\n\",\n\t\t\t     ctx->dt.hactive.min,\n\t\t\t     ctx->dt.hsync_len.min,\n\t\t\t     ctx->dt.hfront_porch.min,\n\t\t\t     ctx->dt.hback_porch.min);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"vactive(%d), vsync(%d), vfp(%d), vbp(%d)\\n\",\n\t\t\t     ctx->dt.vactive.min,\n\t\t\t     ctx->dt.vsync_len.min,\n\t\t\t     ctx->dt.vfront_porch.min,\n\t\t\t     ctx->dt.vback_porch.min);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hdisplay(%d),hsync_start(%d).\\n\",\n\t\t\t     mode->hdisplay,\n\t\t\t     mode->hsync_start);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hsync_end(%d),htotal(%d).\\n\",\n\t\t\t     mode->hsync_end,\n\t\t\t     mode->htotal);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"vdisplay(%d),vsync_start(%d).\\n\",\n\t\t\t     mode->vdisplay,\n\t\t\t     mode->vsync_start);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"vsync_end(%d),vtotal(%d).\\n\",\n\t\t\t     mode->vsync_end,\n\t\t\t     mode->vtotal);\n}\n\nstatic bool anx7625_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      struct drm_display_mode *adj)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\tu32 hsync, hfp, hbp, hblanking;\n\tu32 adj_hsync, adj_hfp, adj_hbp, adj_hblanking, delta_adj;\n\tu32 vref, adj_clock;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm mode fixup set\\n\");\n\n\t \n\tif (!ctx->pdata.panel_bridge)\n\t\treturn true;\n\n\thsync = mode->hsync_end - mode->hsync_start;\n\thfp = mode->hsync_start - mode->hdisplay;\n\thbp = mode->htotal - mode->hsync_end;\n\thblanking = mode->htotal - mode->hdisplay;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"before mode fixup\\n\");\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hsync(%d), hfp(%d), hbp(%d), clock(%d)\\n\",\n\t\t\t     hsync, hfp, hbp, adj->clock);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hsync_start(%d), hsync_end(%d), htot(%d)\\n\",\n\t\t\t     adj->hsync_start, adj->hsync_end, adj->htotal);\n\n\tadj_hfp = hfp;\n\tadj_hsync = hsync;\n\tadj_hbp = hbp;\n\tadj_hblanking = hblanking;\n\n\t \n\tif (hfp & 0x1) {\n\t\tadj_hfp += 1;\n\t\tadj_hblanking += 1;\n\t}\n\n\t \n\tif (hbp & 0x1) {\n\t\tadj_hbp -= 1;\n\t\tadj_hblanking -= 1;\n\t}\n\n\t \n\tif (hsync & 0x1) {\n\t\tif (adj_hblanking < hblanking)\n\t\t\tadj_hsync += 1;\n\t\telse\n\t\t\tadj_hsync -= 1;\n\t}\n\n\t \n\tif (hblanking < HBLANKING_MIN || (hfp < HP_MIN && hbp < HP_MIN)) {\n\t\tadj_hsync = SYNC_LEN_DEF;\n\t\tadj_hfp = HFP_HBP_DEF;\n\t\tadj_hbp = HFP_HBP_DEF;\n\t\tvref = adj->clock * 1000 / (adj->htotal * adj->vtotal);\n\t\tif (hblanking < HBLANKING_MIN) {\n\t\t\tdelta_adj = HBLANKING_MIN - hblanking;\n\t\t\tadj_clock = vref * delta_adj * adj->vtotal;\n\t\t\tadj->clock += DIV_ROUND_UP(adj_clock, 1000);\n\t\t} else {\n\t\t\tdelta_adj = hblanking - HBLANKING_MIN;\n\t\t\tadj_clock = vref * delta_adj * adj->vtotal;\n\t\t\tadj->clock -= DIV_ROUND_UP(adj_clock, 1000);\n\t\t}\n\n\t\tDRM_WARN(\"illegal hblanking timing, use default.\\n\");\n\t\tDRM_WARN(\"hfp(%d), hbp(%d), hsync(%d).\\n\", hfp, hbp, hsync);\n\t} else if (adj_hfp < HP_MIN) {\n\t\t \n\t\tdelta_adj = HP_MIN - adj_hfp;\n\t\tadj_hfp = HP_MIN;\n\n\t\t \n\t\tif ((adj_hbp - delta_adj) < HP_MIN)\n\t\t\t \n\t\t\tadj_hsync -= delta_adj;\n\t\telse\n\t\t\tadj_hbp -= delta_adj;\n\t} else if (adj_hbp < HP_MIN) {\n\t\tdelta_adj = HP_MIN - adj_hbp;\n\t\tadj_hbp = HP_MIN;\n\n\t\t \n\t\tif ((adj_hfp - delta_adj) < HP_MIN)\n\t\t\t \n\t\t\tadj_hsync -= delta_adj;\n\t\telse\n\t\t\tadj_hfp -= delta_adj;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"after mode fixup\\n\");\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hsync(%d), hfp(%d), hbp(%d), clock(%d)\\n\",\n\t\t\t     adj_hsync, adj_hfp, adj_hbp, adj->clock);\n\n\t \n\tadj->hsync_start = adj->hdisplay + adj_hfp;\n\tadj->hsync_end = adj->hsync_start + adj_hsync;\n\tadj->htotal = adj->hsync_end + adj_hbp;\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hsync_start(%d), hsync_end(%d), htot(%d)\\n\",\n\t\t\t     adj->hsync_start, adj->hsync_end, adj->htotal);\n\n\treturn true;\n}\n\nstatic int anx7625_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\n\tdev_dbg(dev, \"drm bridge atomic check\\n\");\n\n\tanx7625_bridge_mode_fixup(bridge, &crtc_state->mode,\n\t\t\t\t  &crtc_state->adjusted_mode);\n\n\treturn anx7625_connector_atomic_check(ctx, conn_state);\n}\n\nstatic void anx7625_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *state)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\tstruct drm_connector *connector;\n\n\tdev_dbg(dev, \"drm atomic enable\\n\");\n\n\tif (!bridge->encoder) {\n\t\tdev_err(dev, \"Parent encoder object not found\");\n\t\treturn;\n\t}\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state->base.state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tif (!connector)\n\t\treturn;\n\n\tctx->connector = connector;\n\n\tpm_runtime_get_sync(dev);\n\t_anx7625_hpd_polling(ctx, 5000 * 100);\n\n\tanx7625_dp_start(ctx);\n}\n\nstatic void anx7625_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *old)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\n\tdev_dbg(dev, \"drm atomic disable\\n\");\n\n\tctx->connector = NULL;\n\tanx7625_dp_stop(ctx);\n\n\tpm_runtime_put_sync(dev);\n}\n\nstatic enum drm_connector_status\nanx7625_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm bridge detect\\n\");\n\n\treturn anx7625_sink_detect(ctx);\n}\n\nstatic struct edid *anx7625_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct anx7625_data *ctx = bridge_to_anx7625(bridge);\n\tstruct device *dev = ctx->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"drm bridge get edid\\n\");\n\n\treturn anx7625_get_edid(ctx);\n}\n\nstatic const struct drm_bridge_funcs anx7625_bridge_funcs = {\n\t.attach = anx7625_bridge_attach,\n\t.detach = anx7625_bridge_detach,\n\t.mode_valid = anx7625_bridge_mode_valid,\n\t.mode_set = anx7625_bridge_mode_set,\n\t.atomic_check = anx7625_bridge_atomic_check,\n\t.atomic_enable = anx7625_bridge_atomic_enable,\n\t.atomic_disable = anx7625_bridge_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.detect = anx7625_bridge_detect,\n\t.get_edid = anx7625_bridge_get_edid,\n};\n\nstatic int anx7625_register_i2c_dummy_clients(struct anx7625_data *ctx,\n\t\t\t\t\t      struct i2c_client *client)\n{\n\tstruct device *dev = ctx->dev;\n\n\tctx->i2c.tx_p0_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t  TX_P0_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.tx_p0_client))\n\t\treturn PTR_ERR(ctx->i2c.tx_p0_client);\n\n\tctx->i2c.tx_p1_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t  TX_P1_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.tx_p1_client))\n\t\treturn PTR_ERR(ctx->i2c.tx_p1_client);\n\n\tctx->i2c.tx_p2_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t  TX_P2_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.tx_p2_client))\n\t\treturn PTR_ERR(ctx->i2c.tx_p2_client);\n\n\tctx->i2c.rx_p0_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t  RX_P0_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.rx_p0_client))\n\t\treturn PTR_ERR(ctx->i2c.rx_p0_client);\n\n\tctx->i2c.rx_p1_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t  RX_P1_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.rx_p1_client))\n\t\treturn PTR_ERR(ctx->i2c.rx_p1_client);\n\n\tctx->i2c.rx_p2_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t  RX_P2_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.rx_p2_client))\n\t\treturn PTR_ERR(ctx->i2c.rx_p2_client);\n\n\tctx->i2c.tcpc_client = devm_i2c_new_dummy_device(dev, client->adapter,\n\t\t\t\t\t\t\t TCPC_INTERFACE_ADDR >> 1);\n\tif (IS_ERR(ctx->i2c.tcpc_client))\n\t\treturn PTR_ERR(ctx->i2c.tcpc_client);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused anx7625_runtime_pm_suspend(struct device *dev)\n{\n\tstruct anx7625_data *ctx = dev_get_drvdata(dev);\n\n\tmutex_lock(&ctx->lock);\n\n\tanx7625_stop_dp_work(ctx);\n\tanx7625_power_standby(ctx);\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused anx7625_runtime_pm_resume(struct device *dev)\n{\n\tstruct anx7625_data *ctx = dev_get_drvdata(dev);\n\n\tmutex_lock(&ctx->lock);\n\n\tanx7625_power_on_init(ctx);\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops anx7625_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(anx7625_runtime_pm_suspend,\n\t\t\t   anx7625_runtime_pm_resume, NULL)\n};\n\nstatic void anx7625_runtime_disable(void *data)\n{\n\tpm_runtime_dont_use_autosuspend(data);\n\tpm_runtime_disable(data);\n}\n\nstatic int anx7625_link_bridge(struct drm_dp_aux *aux)\n{\n\tstruct anx7625_data *platform = container_of(aux, struct anx7625_data, aux);\n\tstruct device *dev = aux->dev;\n\tint ret;\n\n\tret = anx7625_parse_dt_panel(dev, &platform->pdata);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"fail to parse DT for panel : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform->bridge.funcs = &anx7625_bridge_funcs;\n\tplatform->bridge.of_node = dev->of_node;\n\tif (!anx7625_of_panel_on_aux_bus(dev))\n\t\tplatform->bridge.ops |= DRM_BRIDGE_OP_EDID;\n\tif (!platform->pdata.panel_bridge)\n\t\tplatform->bridge.ops |= DRM_BRIDGE_OP_HPD |\n\t\t\t\t\tDRM_BRIDGE_OP_DETECT;\n\tplatform->bridge.type = platform->pdata.panel_bridge ?\n\t\t\t\t    DRM_MODE_CONNECTOR_eDP :\n\t\t\t\t    DRM_MODE_CONNECTOR_DisplayPort;\n\n\tdrm_bridge_add(&platform->bridge);\n\n\tif (!platform->pdata.is_dpi) {\n\t\tret = anx7625_attach_dsi(platform);\n\t\tif (ret)\n\t\t\tdrm_bridge_remove(&platform->bridge);\n\t}\n\n\treturn ret;\n}\n\nstatic int anx7625_i2c_probe(struct i2c_client *client)\n{\n\tstruct anx7625_data *platform;\n\tstruct anx7625_platform_data *pdata;\n\tint ret = 0;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(client->adapter,\n\t\t\t\t     I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tDRM_DEV_ERROR(dev, \"anx7625's i2c bus doesn't support\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tplatform = devm_kzalloc(dev, sizeof(*platform), GFP_KERNEL);\n\tif (!platform) {\n\t\tDRM_DEV_ERROR(dev, \"fail to allocate driver data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpdata = &platform->pdata;\n\n\tplatform->dev = &client->dev;\n\ti2c_set_clientdata(client, platform);\n\n\tpdata->supplies[0].supply = \"vdd10\";\n\tpdata->supplies[1].supply = \"vdd18\";\n\tpdata->supplies[2].supply = \"vdd33\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(pdata->supplies),\n\t\t\t\t      pdata->supplies);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"fail to get power supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tanx7625_init_gpio(platform);\n\n\tmutex_init(&platform->lock);\n\tmutex_init(&platform->hdcp_wq_lock);\n\n\tINIT_DELAYED_WORK(&platform->hdcp_work, hdcp_check_work_func);\n\tplatform->hdcp_workqueue = create_workqueue(\"hdcp workqueue\");\n\tif (!platform->hdcp_workqueue) {\n\t\tdev_err(dev, \"fail to create work queue\\n\");\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\n\tplatform->pdata.intp_irq = client->irq;\n\tif (platform->pdata.intp_irq) {\n\t\tINIT_WORK(&platform->work, anx7625_work_func);\n\t\tplatform->workqueue = alloc_workqueue(\"anx7625_work\",\n\t\t\t\t\t\t      WQ_FREEZABLE | WQ_MEM_RECLAIM, 1);\n\t\tif (!platform->workqueue) {\n\t\t\tDRM_DEV_ERROR(dev, \"fail to create work queue\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_hdcp_wq;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, platform->pdata.intp_irq,\n\t\t\t\t\t\tNULL, anx7625_intr_hpd_isr,\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"anx7625-intp\", platform);\n\t\tif (ret) {\n\t\t\tDRM_DEV_ERROR(dev, \"fail to request irq\\n\");\n\t\t\tgoto free_wq;\n\t\t}\n\t}\n\n\tplatform->aux.name = \"anx7625-aux\";\n\tplatform->aux.dev = dev;\n\tplatform->aux.transfer = anx7625_aux_transfer;\n\tplatform->aux.wait_hpd_asserted = anx7625_wait_hpd_asserted;\n\tdrm_dp_aux_init(&platform->aux);\n\n\tret = anx7625_parse_dt(dev, pdata);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"fail to parse DT : %d\\n\", ret);\n\t\tgoto free_wq;\n\t}\n\n\tif (!platform->pdata.is_dpi) {\n\t\tret = anx7625_setup_dsi_device(platform);\n\t\tif (ret < 0)\n\t\t\tgoto free_wq;\n\t}\n\n\t \n\tif (anx7625_register_i2c_dummy_clients(platform, client) != 0) {\n\t\tret = -ENOMEM;\n\t\tDRM_DEV_ERROR(dev, \"fail to reserve I2C bus.\\n\");\n\t\tgoto free_wq;\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_suspend_ignore_children(dev, true);\n\tret = devm_add_action_or_reset(dev, anx7625_runtime_disable, dev);\n\tif (ret)\n\t\tgoto free_wq;\n\n\t \n\tret = devm_of_dp_aux_populate_bus(&platform->aux, anx7625_link_bridge);\n\tif (ret) {\n\t\tif (ret != -ENODEV) {\n\t\t\tDRM_DEV_ERROR(dev, \"failed to populate aux bus : %d\\n\", ret);\n\t\t\tgoto free_wq;\n\t\t}\n\n\t\tret = anx7625_link_bridge(&platform->aux);\n\t\tif (ret)\n\t\t\tgoto free_wq;\n\t}\n\n\tif (!platform->pdata.low_power_mode) {\n\t\tanx7625_disable_pd_protocol(platform);\n\t\tpm_runtime_get_sync(dev);\n\t\t_anx7625_hpd_polling(platform, 5000 * 100);\n\t}\n\n\t \n\tif (platform->pdata.intp_irq)\n\t\tqueue_work(platform->workqueue, &platform->work);\n\n\tif (platform->pdata.audio_en)\n\t\tanx7625_register_audio(dev, platform);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"probe done\\n\");\n\n\treturn 0;\n\nfree_wq:\n\tif (platform->workqueue)\n\t\tdestroy_workqueue(platform->workqueue);\n\nfree_hdcp_wq:\n\tif (platform->hdcp_workqueue)\n\t\tdestroy_workqueue(platform->hdcp_workqueue);\n\n\treturn ret;\n}\n\nstatic void anx7625_i2c_remove(struct i2c_client *client)\n{\n\tstruct anx7625_data *platform = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&platform->bridge);\n\n\tif (platform->pdata.intp_irq)\n\t\tdestroy_workqueue(platform->workqueue);\n\n\tif (platform->hdcp_workqueue) {\n\t\tcancel_delayed_work(&platform->hdcp_work);\n\t\tflush_workqueue(platform->hdcp_workqueue);\n\t\tdestroy_workqueue(platform->hdcp_workqueue);\n\t}\n\n\tif (!platform->pdata.low_power_mode)\n\t\tpm_runtime_put_sync_suspend(&client->dev);\n\n\tif (platform->pdata.audio_en)\n\t\tanx7625_unregister_audio(platform);\n}\n\nstatic const struct i2c_device_id anx7625_id[] = {\n\t{\"anx7625\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, anx7625_id);\n\nstatic const struct of_device_id anx_match_table[] = {\n\t{.compatible = \"analogix,anx7625\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, anx_match_table);\n\nstatic struct i2c_driver anx7625_driver = {\n\t.driver = {\n\t\t.name = \"anx7625\",\n\t\t.of_match_table = anx_match_table,\n\t\t.pm = &anx7625_pm_ops,\n\t},\n\t.probe = anx7625_i2c_probe,\n\t.remove = anx7625_i2c_remove,\n\n\t.id_table = anx7625_id,\n};\n\nmodule_i2c_driver(anx7625_driver);\n\nMODULE_DESCRIPTION(\"MIPI2DP anx7625 driver\");\nMODULE_AUTHOR(\"Xin Ji <xji@analogixsemi.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(ANX7625_DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}