{
  "module_name": "analogix-anx6345.c",
  "hash_id": "abf0ebce5b746d958847f8ec2f90a955a11eedf09e25842252237736477bc2bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/analogix-anx6345.c",
  "human_readable_source": " \n \n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"analogix-i2c-dptx.h\"\n#include \"analogix-i2c-txcommon.h\"\n\n#define POLL_DELAY\t\t50000  \n#define POLL_TIMEOUT\t\t5000000  \n\n#define I2C_IDX_DPTX\t\t0\n#define I2C_IDX_TXCOM\t\t1\n\nstatic const u8 anx6345_i2c_addresses[] = {\n\t[I2C_IDX_DPTX]\t= 0x70,\n\t[I2C_IDX_TXCOM]\t= 0x72,\n};\n#define I2C_NUM_ADDRESSES\tARRAY_SIZE(anx6345_i2c_addresses)\n\nstruct anx6345 {\n\tstruct drm_dp_aux aux;\n\tstruct drm_bridge bridge;\n\tstruct i2c_client *client;\n\tstruct edid *edid;\n\tstruct drm_connector connector;\n\tstruct drm_panel *panel;\n\tstruct regulator *dvdd12;\n\tstruct regulator *dvdd25;\n\tstruct gpio_desc *gpiod_reset;\n\tstruct mutex lock;\t \n\n\t \n\tstruct i2c_client *i2c_clients[I2C_NUM_ADDRESSES];\n\tstruct regmap *map[I2C_NUM_ADDRESSES];\n\n\tu16 chipid;\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\n\tbool powered;\n};\n\nstatic inline struct anx6345 *connector_to_anx6345(struct drm_connector *c)\n{\n\treturn container_of(c, struct anx6345, connector);\n}\n\nstatic inline struct anx6345 *bridge_to_anx6345(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct anx6345, bridge);\n}\n\nstatic int anx6345_set_bits(struct regmap *map, u8 reg, u8 mask)\n{\n\treturn regmap_update_bits(map, reg, mask, mask);\n}\n\nstatic int anx6345_clear_bits(struct regmap *map, u8 reg, u8 mask)\n{\n\treturn regmap_update_bits(map, reg, mask, 0);\n}\n\nstatic ssize_t anx6345_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t    struct drm_dp_aux_msg *msg)\n{\n\tstruct anx6345 *anx6345 = container_of(aux, struct anx6345, aux);\n\n\treturn anx_dp_aux_transfer(anx6345->map[I2C_IDX_DPTX], msg);\n}\n\nstatic int anx6345_dp_link_training(struct anx6345 *anx6345)\n{\n\tunsigned int value;\n\tu8 dp_bw, dpcd[2];\n\tint err;\n\n\terr = anx6345_clear_bits(anx6345->map[I2C_IDX_TXCOM],\n\t\t\t\t SP_POWERDOWN_CTRL_REG,\n\t\t\t\t SP_TOTAL_PD);\n\tif (err)\n\t\treturn err;\n\n\terr = drm_dp_dpcd_readb(&anx6345->aux, DP_MAX_LINK_RATE, &dp_bw);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (dp_bw) {\n\tcase DP_LINK_BW_1_62:\n\tcase DP_LINK_BW_2_7:\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"DP bandwidth (%#02x) not supported\\n\", dp_bw);\n\t\treturn -EINVAL;\n\t}\n\n\terr = anx6345_set_bits(anx6345->map[I2C_IDX_TXCOM], SP_VID_CTRL1_REG,\n\t\t\t       SP_VIDEO_MUTE);\n\tif (err)\n\t\treturn err;\n\n\terr = anx6345_clear_bits(anx6345->map[I2C_IDX_TXCOM],\n\t\t\t\t SP_VID_CTRL1_REG, SP_VIDEO_EN);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = drm_dp_dpcd_read(&anx6345->aux, DP_DPCD_REV,\n\t\t\t       &anx6345->dpcd, DP_RECEIVER_CAP_SIZE);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to read DPCD: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = anx6345_clear_bits(anx6345->map[I2C_IDX_DPTX],\n\t\t\t\t SP_DP_ANALOG_POWER_DOWN_REG, SP_CH0_PD);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (anx6345->dpcd[DP_DPCD_REV] >= 0x11) {\n\t\terr = drm_dp_dpcd_readb(&anx6345->aux, DP_SET_POWER, &dpcd[0]);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"Failed to read DP_SET_POWER register: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn err;\n\t\t}\n\n\t\tdpcd[0] &= ~DP_SET_POWER_MASK;\n\t\tdpcd[0] |= DP_SET_POWER_D0;\n\n\t\terr = drm_dp_dpcd_writeb(&anx6345->aux, DP_SET_POWER, dpcd[0]);\n\t\tif (err < 0) {\n\t\t\tDRM_ERROR(\"Failed to power up DisplayPort link: %d\\n\",\n\t\t\t\t  err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t   SP_DP_DOWNSPREAD_CTRL1_REG, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (anx6345->dpcd[DP_MAX_DOWNSPREAD] & DP_MAX_DOWNSPREAD_0_5) {\n\t\tDRM_DEBUG(\"Enable downspread on the sink\\n\");\n\t\t \n\t\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t\t   SP_DP_DOWNSPREAD_CTRL1_REG, 8);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = drm_dp_dpcd_writeb(&anx6345->aux, DP_DOWNSPREAD_CTRL,\n\t\t\t\t\t DP_SPREAD_AMP_0_5);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\terr = drm_dp_dpcd_writeb(&anx6345->aux, DP_DOWNSPREAD_CTRL, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (drm_dp_enhanced_frame_cap(anx6345->dpcd))\n\t\terr = anx6345_set_bits(anx6345->map[I2C_IDX_DPTX],\n\t\t\t\t       SP_DP_SYSTEM_CTRL_BASE + 4,\n\t\t\t\t       SP_ENHANCED_MODE);\n\telse\n\t\terr = anx6345_clear_bits(anx6345->map[I2C_IDX_DPTX],\n\t\t\t\t\t SP_DP_SYSTEM_CTRL_BASE + 4,\n\t\t\t\t\t SP_ENHANCED_MODE);\n\tif (err)\n\t\treturn err;\n\n\tdpcd[0] = dp_bw;\n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t   SP_DP_MAIN_LINK_BW_SET_REG, dpcd[0]);\n\tif (err)\n\t\treturn err;\n\n\tdpcd[1] = drm_dp_max_lane_count(anx6345->dpcd);\n\n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t   SP_DP_LANE_COUNT_SET_REG, dpcd[1]);\n\tif (err)\n\t\treturn err;\n\n\tif (drm_dp_enhanced_frame_cap(anx6345->dpcd))\n\t\tdpcd[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\terr = drm_dp_dpcd_write(&anx6345->aux, DP_LINK_BW_SET, dpcd,\n\t\t\t\tsizeof(dpcd));\n\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to configure link: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX], SP_DP_LT_CTRL_REG,\n\t\t\t   SP_LT_EN);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_read_poll_timeout(anx6345->map[I2C_IDX_DPTX],\n\t\t\t\t       SP_DP_LT_CTRL_REG,\n\t\t\t\t       value, !(value & SP_DP_LT_INPROGRESS),\n\t\t\t\t       POLL_DELAY, POLL_TIMEOUT);\n}\n\nstatic int anx6345_tx_initialization(struct anx6345 *anx6345)\n{\n\tint err, i;\n\n\t \n\terr = regmap_write(anx6345->map[I2C_IDX_TXCOM], SP_VID_CTRL2_REG,\n\t\t\t   SP_IN_BPC_6BIT << SP_IN_BPC_SHIFT);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX], SP_DP_PLL_CTRL_REG, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx6345->map[I2C_IDX_TXCOM],\n\t\t\t   SP_ANALOG_DEBUG1_REG, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t   SP_DP_LINK_DEBUG_CTRL_REG,\n\t\t\t   SP_NEW_PRBS7 | SP_M_VID_DEBUG);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t   SP_DP_ANALOG_POWER_DOWN_REG, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx6345_set_bits(anx6345->map[I2C_IDX_DPTX],\n\t\t\t       SP_DP_SYSTEM_CTRL_BASE + 3,\n\t\t\t       SP_HPD_FORCE | SP_HPD_CTRL);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\terr = regmap_write(anx6345->map[I2C_IDX_DPTX],\n\t\t\t\t   SP_DP_LANE0_LT_CTRL_REG + i, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = anx6345_set_bits(anx6345->map[I2C_IDX_TXCOM],\n\t\t\t       SP_RESET_CTRL2_REG, SP_AUX_RST);\n\tif (err)\n\t\treturn err;\n\n\treturn anx6345_clear_bits(anx6345->map[I2C_IDX_TXCOM],\n\t\t\t\t SP_RESET_CTRL2_REG, SP_AUX_RST);\n}\n\nstatic void anx6345_poweron(struct anx6345 *anx6345)\n{\n\tint err;\n\n\t \n\tgpiod_set_value_cansleep(anx6345->gpiod_reset, 1);\n\tusleep_range(1000, 2000);\n\n\terr = regulator_enable(anx6345->dvdd12);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to enable dvdd12 regulator: %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n\n\t \n\tusleep_range(1000, 2000);\n\n\terr = regulator_enable(anx6345->dvdd25);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to enable dvdd25 regulator: %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n\n\t \n\tusleep_range(2000, 5000);\n\n\tgpiod_set_value_cansleep(anx6345->gpiod_reset, 0);\n\n\t \n\tanx6345_set_bits(anx6345->map[I2C_IDX_TXCOM], SP_POWERDOWN_CTRL_REG,\n\t\t\t SP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD | SP_LINK_PD);\n\tanx6345_clear_bits(anx6345->map[I2C_IDX_TXCOM], SP_POWERDOWN_CTRL_REG,\n\t\t\t   SP_REGISTER_PD | SP_TOTAL_PD);\n\n\tif (anx6345->panel)\n\t\tdrm_panel_prepare(anx6345->panel);\n\n\tanx6345->powered = true;\n}\n\nstatic void anx6345_poweroff(struct anx6345 *anx6345)\n{\n\tint err;\n\n\tgpiod_set_value_cansleep(anx6345->gpiod_reset, 1);\n\tusleep_range(1000, 2000);\n\n\tif (anx6345->panel)\n\t\tdrm_panel_unprepare(anx6345->panel);\n\n\terr = regulator_disable(anx6345->dvdd25);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to disable dvdd25 regulator: %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n\n\tusleep_range(5000, 10000);\n\n\terr = regulator_disable(anx6345->dvdd12);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to disable dvdd12 regulator: %d\\n\",\n\t\t\t  err);\n\t\treturn;\n\t}\n\n\tusleep_range(1000, 2000);\n\n\tanx6345->powered = false;\n}\n\nstatic int anx6345_start(struct anx6345 *anx6345)\n{\n\tint err;\n\n\tif (!anx6345->powered)\n\t\tanx6345_poweron(anx6345);\n\n\t \n\terr = anx6345_clear_bits(anx6345->map[I2C_IDX_TXCOM],\n\t\t\t\tSP_POWERDOWN_CTRL_REG,\n\t\t\t\tSP_VIDEO_PD | SP_LINK_PD);\n\n\terr = anx6345_tx_initialization(anx6345);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed eDP transmitter initialization: %d\\n\", err);\n\t\tanx6345_poweroff(anx6345);\n\t\treturn err;\n\t}\n\n\terr = anx6345_dp_link_training(anx6345);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed link training: %d\\n\", err);\n\t\tanx6345_poweroff(anx6345);\n\t\treturn err;\n\t}\n\n\t \n\tusleep_range(10000, 15000);\n\n\treturn 0;\n}\n\nstatic int anx6345_config_dp_output(struct anx6345 *anx6345)\n{\n\tint err;\n\n\terr = anx6345_clear_bits(anx6345->map[I2C_IDX_TXCOM], SP_VID_CTRL1_REG,\n\t\t\t\t SP_VIDEO_MUTE);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = anx6345_set_bits(anx6345->map[I2C_IDX_TXCOM], SP_VID_CTRL1_REG,\n\t\t\t       SP_VIDEO_EN);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn anx6345_set_bits(anx6345->map[I2C_IDX_DPTX],\n\t\t\t       SP_DP_SYSTEM_CTRL_BASE + 3,\n\t\t\t       SP_STRM_FORCE | SP_STRM_CTRL);\n}\n\nstatic int anx6345_get_downstream_info(struct anx6345 *anx6345)\n{\n\tu8 value;\n\tint err;\n\n\terr = drm_dp_dpcd_readb(&anx6345->aux, DP_SINK_COUNT, &value);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Get sink count failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!DP_GET_SINK_COUNT(value)) {\n\t\tDRM_ERROR(\"Downstream disconnected\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int anx6345_get_modes(struct drm_connector *connector)\n{\n\tstruct anx6345 *anx6345 = connector_to_anx6345(connector);\n\tint err, num_modes = 0;\n\tbool power_off = false;\n\n\tmutex_lock(&anx6345->lock);\n\n\tif (!anx6345->edid) {\n\t\tif (!anx6345->powered) {\n\t\t\tanx6345_poweron(anx6345);\n\t\t\tpower_off = true;\n\t\t}\n\n\t\terr = anx6345_get_downstream_info(anx6345);\n\t\tif (err) {\n\t\t\tDRM_ERROR(\"Failed to get downstream info: %d\\n\", err);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tanx6345->edid = drm_get_edid(connector, &anx6345->aux.ddc);\n\t\tif (!anx6345->edid)\n\t\t\tDRM_ERROR(\"Failed to read EDID from panel\\n\");\n\n\t\terr = drm_connector_update_edid_property(connector,\n\t\t\t\t\t\t\t anx6345->edid);\n\t\tif (err) {\n\t\t\tDRM_ERROR(\"Failed to update EDID property: %d\\n\", err);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tnum_modes += drm_add_edid_modes(connector, anx6345->edid);\n\n\t \n\tconnector->display_info.bpc = 6;\n\nunlock:\n\tif (power_off)\n\t\tanx6345_poweroff(anx6345);\n\n\tmutex_unlock(&anx6345->lock);\n\n\tif (!num_modes && anx6345->panel)\n\t\tnum_modes += drm_panel_get_modes(anx6345->panel, connector);\n\n\treturn num_modes;\n}\n\nstatic const struct drm_connector_helper_funcs anx6345_connector_helper_funcs = {\n\t.get_modes = anx6345_get_modes,\n};\n\nstatic void\nanx6345_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs anx6345_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = anx6345_connector_destroy,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int anx6345_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct anx6345 *anx6345 = bridge_to_anx6345(bridge);\n\tint err;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR) {\n\t\tDRM_ERROR(\"Fix bridge driver to make connector optional!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tanx6345->aux.name = \"DP-AUX\";\n\tanx6345->aux.dev = &anx6345->client->dev;\n\tanx6345->aux.drm_dev = bridge->dev;\n\tanx6345->aux.transfer = anx6345_aux_transfer;\n\n\terr = drm_dp_aux_register(&anx6345->aux);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"Failed to register aux channel: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = drm_connector_init(bridge->dev, &anx6345->connector,\n\t\t\t\t &anx6345_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_eDP);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to initialize connector: %d\\n\", err);\n\t\tgoto aux_unregister;\n\t}\n\n\tdrm_connector_helper_add(&anx6345->connector,\n\t\t\t\t &anx6345_connector_helper_funcs);\n\n\tanx6345->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\terr = drm_connector_attach_encoder(&anx6345->connector,\n\t\t\t\t\t   bridge->encoder);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to link up connector to encoder: %d\\n\", err);\n\t\tgoto connector_cleanup;\n\t}\n\n\terr = drm_connector_register(&anx6345->connector);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to register connector: %d\\n\", err);\n\t\tgoto connector_cleanup;\n\t}\n\n\treturn 0;\nconnector_cleanup:\n\tdrm_connector_cleanup(&anx6345->connector);\naux_unregister:\n\tdrm_dp_aux_unregister(&anx6345->aux);\n\treturn err;\n}\n\nstatic void anx6345_bridge_detach(struct drm_bridge *bridge)\n{\n\tdrm_dp_aux_unregister(&bridge_to_anx6345(bridge)->aux);\n}\n\nstatic enum drm_mode_status\nanx6345_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_info *info,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\t \n\tif (mode->clock > 154000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void anx6345_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct anx6345 *anx6345 = bridge_to_anx6345(bridge);\n\n\t \n\tanx6345_set_bits(anx6345->map[I2C_IDX_TXCOM], SP_POWERDOWN_CTRL_REG,\n\t\t\t SP_HDCP_PD | SP_AUDIO_PD | SP_VIDEO_PD | SP_LINK_PD);\n\tif (anx6345->panel)\n\t\tdrm_panel_disable(anx6345->panel);\n\n\tif (anx6345->powered)\n\t\tanx6345_poweroff(anx6345);\n}\n\nstatic void anx6345_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct anx6345 *anx6345 = bridge_to_anx6345(bridge);\n\tint err;\n\n\tif (anx6345->panel)\n\t\tdrm_panel_enable(anx6345->panel);\n\n\terr = anx6345_start(anx6345);\n\tif (err) {\n\t\tDRM_ERROR(\"Failed to initialize: %d\\n\", err);\n\t\treturn;\n\t}\n\n\terr = anx6345_config_dp_output(anx6345);\n\tif (err)\n\t\tDRM_ERROR(\"Failed to enable DP output: %d\\n\", err);\n}\n\nstatic const struct drm_bridge_funcs anx6345_bridge_funcs = {\n\t.attach = anx6345_bridge_attach,\n\t.detach = anx6345_bridge_detach,\n\t.mode_valid = anx6345_bridge_mode_valid,\n\t.disable = anx6345_bridge_disable,\n\t.enable = anx6345_bridge_enable,\n};\n\nstatic void unregister_i2c_dummy_clients(struct anx6345 *anx6345)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < ARRAY_SIZE(anx6345->i2c_clients); i++)\n\t\tif (anx6345->i2c_clients[i] &&\n\t\t    anx6345->i2c_clients[i]->addr != anx6345->client->addr)\n\t\t\ti2c_unregister_device(anx6345->i2c_clients[i]);\n}\n\nstatic const struct regmap_config anx6345_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const u16 anx6345_chipid_list[] = {\n\t0x6345,\n};\n\nstatic bool anx6345_get_chip_id(struct anx6345 *anx6345)\n{\n\tunsigned int i, idl, idh, version;\n\n\tif (regmap_read(anx6345->map[I2C_IDX_TXCOM], SP_DEVICE_IDL_REG, &idl))\n\t\treturn false;\n\n\tif (regmap_read(anx6345->map[I2C_IDX_TXCOM], SP_DEVICE_IDH_REG, &idh))\n\t\treturn false;\n\n\tanx6345->chipid = (u8)idl | ((u8)idh << 8);\n\n\tif (regmap_read(anx6345->map[I2C_IDX_TXCOM], SP_DEVICE_VERSION_REG,\n\t\t\t&version))\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(anx6345_chipid_list); i++) {\n\t\tif (anx6345->chipid == anx6345_chipid_list[i]) {\n\t\t\tDRM_INFO(\"Found ANX%x (ver. %d) eDP Transmitter\\n\",\n\t\t\t\t anx6345->chipid, version);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tDRM_ERROR(\"ANX%x (ver. %d) not supported by this driver\\n\",\n\t\t  anx6345->chipid, version);\n\n\treturn false;\n}\n\nstatic int anx6345_i2c_probe(struct i2c_client *client)\n{\n\tstruct anx6345 *anx6345;\n\tstruct device *dev;\n\tint i, err;\n\n\tanx6345 = devm_kzalloc(&client->dev, sizeof(*anx6345), GFP_KERNEL);\n\tif (!anx6345)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&anx6345->lock);\n\n\tanx6345->bridge.of_node = client->dev.of_node;\n\n\tanx6345->client = client;\n\ti2c_set_clientdata(client, anx6345);\n\n\tdev = &anx6345->client->dev;\n\n\terr = drm_of_find_panel_or_bridge(client->dev.of_node, 1, 0,\n\t\t\t\t\t  &anx6345->panel, NULL);\n\tif (err == -EPROBE_DEFER)\n\t\treturn err;\n\n\tif (err)\n\t\tDRM_DEBUG(\"No panel found\\n\");\n\n\t \n\tanx6345->dvdd12 = devm_regulator_get(dev, \"dvdd12\");\n\tif (IS_ERR(anx6345->dvdd12)) {\n\t\tif (PTR_ERR(anx6345->dvdd12) != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to get dvdd12 supply (%ld)\\n\",\n\t\t\t\t  PTR_ERR(anx6345->dvdd12));\n\t\treturn PTR_ERR(anx6345->dvdd12);\n\t}\n\n\t \n\tanx6345->dvdd25 = devm_regulator_get(dev, \"dvdd25\");\n\tif (IS_ERR(anx6345->dvdd25)) {\n\t\tif (PTR_ERR(anx6345->dvdd25) != -EPROBE_DEFER)\n\t\t\tDRM_ERROR(\"Failed to get dvdd25 supply (%ld)\\n\",\n\t\t\t\t  PTR_ERR(anx6345->dvdd25));\n\t\treturn PTR_ERR(anx6345->dvdd25);\n\t}\n\n\t \n\tanx6345->gpiod_reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(anx6345->gpiod_reset)) {\n\t\tDRM_ERROR(\"Reset gpio not found\\n\");\n\t\treturn PTR_ERR(anx6345->gpiod_reset);\n\t}\n\n\t \n\tfor (i = 0; i < I2C_NUM_ADDRESSES; i++) {\n\t\tif (anx6345_i2c_addresses[i] >> 1 != client->addr)\n\t\t\tanx6345->i2c_clients[i] = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\tanx6345_i2c_addresses[i] >> 1);\n\t\telse\n\t\t\tanx6345->i2c_clients[i] = client;\n\n\t\tif (IS_ERR(anx6345->i2c_clients[i])) {\n\t\t\terr = PTR_ERR(anx6345->i2c_clients[i]);\n\t\t\tDRM_ERROR(\"Failed to reserve I2C bus %02x\\n\",\n\t\t\t\t  anx6345_i2c_addresses[i]);\n\t\t\tgoto err_unregister_i2c;\n\t\t}\n\n\t\tanx6345->map[i] = devm_regmap_init_i2c(anx6345->i2c_clients[i],\n\t\t\t\t\t\t       &anx6345_regmap_config);\n\t\tif (IS_ERR(anx6345->map[i])) {\n\t\t\terr = PTR_ERR(anx6345->map[i]);\n\t\t\tDRM_ERROR(\"Failed regmap initialization %02x\\n\",\n\t\t\t\t  anx6345_i2c_addresses[i]);\n\t\t\tgoto err_unregister_i2c;\n\t\t}\n\t}\n\n\t \n\tanx6345_poweron(anx6345);\n\tif (anx6345_get_chip_id(anx6345)) {\n\t\tanx6345->bridge.funcs = &anx6345_bridge_funcs;\n\t\tdrm_bridge_add(&anx6345->bridge);\n\n\t\treturn 0;\n\t} else {\n\t\tanx6345_poweroff(anx6345);\n\t\terr = -ENODEV;\n\t}\n\nerr_unregister_i2c:\n\tunregister_i2c_dummy_clients(anx6345);\n\treturn err;\n}\n\nstatic void anx6345_i2c_remove(struct i2c_client *client)\n{\n\tstruct anx6345 *anx6345 = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&anx6345->bridge);\n\n\tunregister_i2c_dummy_clients(anx6345);\n\n\tkfree(anx6345->edid);\n\n\tmutex_destroy(&anx6345->lock);\n}\n\nstatic const struct i2c_device_id anx6345_id[] = {\n\t{ \"anx6345\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, anx6345_id);\n\nstatic const struct of_device_id anx6345_match_table[] = {\n\t{ .compatible = \"analogix,anx6345\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, anx6345_match_table);\n\nstatic struct i2c_driver anx6345_driver = {\n\t.driver = {\n\t\t   .name = \"anx6345\",\n\t\t   .of_match_table = anx6345_match_table,\n\t\t  },\n\t.probe = anx6345_i2c_probe,\n\t.remove = anx6345_i2c_remove,\n\t.id_table = anx6345_id,\n};\nmodule_i2c_driver(anx6345_driver);\n\nMODULE_DESCRIPTION(\"ANX6345 eDP Transmitter driver\");\nMODULE_AUTHOR(\"Icenowy Zheng <icenowy@aosc.io>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}