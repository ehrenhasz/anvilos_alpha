{
  "module_name": "analogix_dp_reg.c",
  "hash_id": "056e1b868f7f8eb24acb018f171bbcb0efc91a0e1798fd89d93aaa50a024dc01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/analogix/analogix_dp_reg.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include <drm/bridge/analogix_dp.h>\n\n#include \"analogix_dp_core.h\"\n#include \"analogix_dp_reg.h\"\n\n#define COMMON_INT_MASK_1\t0\n#define COMMON_INT_MASK_2\t0\n#define COMMON_INT_MASK_3\t0\n#define COMMON_INT_MASK_4\t(HOTPLUG_CHG | HPD_LOST | PLUG)\n#define INT_STA_MASK\t\tINT_HPD\n\nvoid analogix_dp_enable_video_mute(struct analogix_dp_device *dp, bool enable)\n{\n\tu32 reg;\n\n\tif (enable) {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n\t\treg |= HDCP_VIDEO_MUTE;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n\t} else {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n\t\treg &= ~HDCP_VIDEO_MUTE;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n\t}\n}\n\nvoid analogix_dp_stop_video(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n\treg &= ~VIDEO_EN;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n}\n\nvoid analogix_dp_lane_swap(struct analogix_dp_device *dp, bool enable)\n{\n\tu32 reg;\n\n\tif (enable)\n\t\treg = LANE3_MAP_LOGIC_LANE_0 | LANE2_MAP_LOGIC_LANE_1 |\n\t\t      LANE1_MAP_LOGIC_LANE_2 | LANE0_MAP_LOGIC_LANE_3;\n\telse\n\t\treg = LANE3_MAP_LOGIC_LANE_3 | LANE2_MAP_LOGIC_LANE_2 |\n\t\t      LANE1_MAP_LOGIC_LANE_1 | LANE0_MAP_LOGIC_LANE_0;\n\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LANE_MAP);\n}\n\nvoid analogix_dp_init_analog_param(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = TX_TERMINAL_CTRL_50_OHM;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_ANALOG_CTL_1);\n\n\treg = SEL_24M | TX_DVDD_BIT_1_0625V;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_ANALOG_CTL_2);\n\n\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type)) {\n\t\treg = REF_CLK_24M;\n\t\tif (dp->plat_data->dev_type == RK3288_DP)\n\t\t\treg ^= REF_CLK_MASK;\n\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_PLL_REG_1);\n\t\twritel(0x95, dp->reg_base + ANALOGIX_DP_PLL_REG_2);\n\t\twritel(0x40, dp->reg_base + ANALOGIX_DP_PLL_REG_3);\n\t\twritel(0x58, dp->reg_base + ANALOGIX_DP_PLL_REG_4);\n\t\twritel(0x22, dp->reg_base + ANALOGIX_DP_PLL_REG_5);\n\t}\n\n\treg = DRIVE_DVDD_BIT_1_0625V | VCO_BIT_600_MICRO;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_ANALOG_CTL_3);\n\n\treg = PD_RING_OSC | AUX_TERMINAL_CTRL_50_OHM |\n\t\tTX_CUR1_2X | TX_CUR_16_MA;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_PLL_FILTER_CTL_1);\n\n\treg = CH3_AMP_400_MV | CH2_AMP_400_MV |\n\t\tCH1_AMP_400_MV | CH0_AMP_400_MV;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_TX_AMP_TUNING_CTL);\n}\n\nvoid analogix_dp_init_interrupt(struct analogix_dp_device *dp)\n{\n\t \n\twritel(INT_POL1 | INT_POL0, dp->reg_base + ANALOGIX_DP_INT_CTL);\n\n\t \n\twritel(0xff, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_1);\n\twritel(0x4f, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_2);\n\twritel(0xe0, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_3);\n\twritel(0xe7, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_4);\n\twritel(0x63, dp->reg_base + ANALOGIX_DP_INT_STA);\n\n\t \n\twritel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_1);\n\twritel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_2);\n\twritel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_3);\n\twritel(0x00, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);\n\twritel(0x00, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);\n}\n\nvoid analogix_dp_reset(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\tanalogix_dp_stop_video(dp);\n\tanalogix_dp_enable_video_mute(dp, 0);\n\n\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type))\n\t\treg = RK_VID_CAP_FUNC_EN_N | RK_VID_FIFO_FUNC_EN_N |\n\t\t\tSW_FUNC_EN_N;\n\telse\n\t\treg = MASTER_VID_FUNC_EN_N | SLAVE_VID_FUNC_EN_N |\n\t\t\tAUD_FIFO_FUNC_EN_N | AUD_FUNC_EN_N |\n\t\t\tHDCP_FUNC_EN_N | SW_FUNC_EN_N;\n\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_1);\n\n\treg = SSC_FUNC_EN_N | AUX_FUNC_EN_N |\n\t\tSERDES_FIFO_FUNC_EN_N |\n\t\tLS_CLK_DOMAIN_FUNC_EN_N;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n\n\tusleep_range(20, 30);\n\n\tanalogix_dp_lane_swap(dp, 0);\n\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_SYS_CTL_1);\n\twritel(0x40, dp->reg_base + ANALOGIX_DP_SYS_CTL_2);\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_HDCP_CTL);\n\n\twritel(0x5e, dp->reg_base + ANALOGIX_DP_HPD_DEGLITCH_L);\n\twritel(0x1a, dp->reg_base + ANALOGIX_DP_HPD_DEGLITCH_H);\n\n\twritel(0x10, dp->reg_base + ANALOGIX_DP_LINK_DEBUG_CTL);\n\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_PHY_TEST);\n\n\twritel(0x0, dp->reg_base + ANALOGIX_DP_VIDEO_FIFO_THRD);\n\twritel(0x20, dp->reg_base + ANALOGIX_DP_AUDIO_MARGIN);\n\n\twritel(0x4, dp->reg_base + ANALOGIX_DP_M_VID_GEN_FILTER_TH);\n\twritel(0x2, dp->reg_base + ANALOGIX_DP_M_AUD_GEN_FILTER_TH);\n\n\twritel(0x00000101, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);\n}\n\nvoid analogix_dp_swreset(struct analogix_dp_device *dp)\n{\n\twritel(RESET_DP_TX, dp->reg_base + ANALOGIX_DP_TX_SW_RESET);\n}\n\nvoid analogix_dp_config_interrupt(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\t \n\treg = COMMON_INT_MASK_1;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_1);\n\n\treg = COMMON_INT_MASK_2;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_2);\n\n\treg = COMMON_INT_MASK_3;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_3);\n\n\treg = COMMON_INT_MASK_4;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);\n\n\treg = INT_STA_MASK;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);\n}\n\nvoid analogix_dp_mute_hpd_interrupt(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);\n\treg &= ~COMMON_INT_MASK_4;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_INT_STA_MASK);\n\treg &= ~INT_STA_MASK;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);\n}\n\nvoid analogix_dp_unmute_hpd_interrupt(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\t \n\treg = COMMON_INT_MASK_4;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_MASK_4);\n\n\treg = INT_STA_MASK;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_INT_STA_MASK);\n}\n\nenum pll_status analogix_dp_get_pll_lock_status(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_DEBUG_CTL);\n\tif (reg & PLL_LOCK)\n\t\treturn PLL_LOCKED;\n\telse\n\t\treturn PLL_UNLOCKED;\n}\n\nvoid analogix_dp_set_pll_power_down(struct analogix_dp_device *dp, bool enable)\n{\n\tu32 reg;\n\tu32 mask = DP_PLL_PD;\n\tu32 pd_addr = ANALOGIX_DP_PLL_CTL;\n\n\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type)) {\n\t\tpd_addr = ANALOGIX_DP_PD;\n\t\tmask = RK_PLL_PD;\n\t}\n\n\treg = readl(dp->reg_base + pd_addr);\n\tif (enable)\n\t\treg |= mask;\n\telse\n\t\treg &= ~mask;\n\twritel(reg, dp->reg_base + pd_addr);\n}\n\nvoid analogix_dp_set_analog_power_down(struct analogix_dp_device *dp,\n\t\t\t\t       enum analog_power_block block,\n\t\t\t\t       bool enable)\n{\n\tu32 reg;\n\tu32 phy_pd_addr = ANALOGIX_DP_PHY_PD;\n\tu32 mask;\n\n\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type))\n\t\tphy_pd_addr = ANALOGIX_DP_PD;\n\n\tswitch (block) {\n\tcase AUX_BLOCK:\n\t\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type))\n\t\t\tmask = RK_AUX_PD;\n\t\telse\n\t\t\tmask = AUX_PD;\n\n\t\treg = readl(dp->reg_base + phy_pd_addr);\n\t\tif (enable)\n\t\t\treg |= mask;\n\t\telse\n\t\t\treg &= ~mask;\n\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\tbreak;\n\tcase CH0_BLOCK:\n\t\tmask = CH0_PD;\n\t\treg = readl(dp->reg_base + phy_pd_addr);\n\n\t\tif (enable)\n\t\t\treg |= mask;\n\t\telse\n\t\t\treg &= ~mask;\n\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\tbreak;\n\tcase CH1_BLOCK:\n\t\tmask = CH1_PD;\n\t\treg = readl(dp->reg_base + phy_pd_addr);\n\n\t\tif (enable)\n\t\t\treg |= mask;\n\t\telse\n\t\t\treg &= ~mask;\n\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\tbreak;\n\tcase CH2_BLOCK:\n\t\tmask = CH2_PD;\n\t\treg = readl(dp->reg_base + phy_pd_addr);\n\n\t\tif (enable)\n\t\t\treg |= mask;\n\t\telse\n\t\t\treg &= ~mask;\n\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\tbreak;\n\tcase CH3_BLOCK:\n\t\tmask = CH3_PD;\n\t\treg = readl(dp->reg_base + phy_pd_addr);\n\n\t\tif (enable)\n\t\t\treg |= mask;\n\t\telse\n\t\t\treg &= ~mask;\n\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\tbreak;\n\tcase ANALOG_TOTAL:\n\t\t \n\t\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type))\n\t\t\tmask = DP_INC_BG;\n\t\telse\n\t\t\tmask = DP_PHY_PD;\n\n\t\treg = readl(dp->reg_base + phy_pd_addr);\n\t\tif (enable)\n\t\t\treg |= mask;\n\t\telse\n\t\t\treg &= ~mask;\n\n\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type))\n\t\t\tusleep_range(10, 15);\n\t\tbreak;\n\tcase POWER_ALL:\n\t\tif (enable) {\n\t\t\treg = DP_ALL_PD;\n\t\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\t} else {\n\t\t\treg = DP_ALL_PD;\n\t\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\t\tusleep_range(10, 15);\n\t\t\treg &= ~DP_INC_BG;\n\t\t\twritel(reg, dp->reg_base + phy_pd_addr);\n\t\t\tusleep_range(10, 15);\n\n\t\t\twritel(0x00, dp->reg_base + phy_pd_addr);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint analogix_dp_init_analog_func(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\tint timeout_loop = 0;\n\n\tanalogix_dp_set_analog_power_down(dp, POWER_ALL, 0);\n\n\treg = PLL_LOCK_CHG;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_1);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_DEBUG_CTL);\n\treg &= ~(F_PLL_LOCK | PLL_LOCK_CTRL);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_DEBUG_CTL);\n\n\t \n\tif (analogix_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\n\t\tanalogix_dp_set_pll_power_down(dp, 0);\n\n\t\twhile (analogix_dp_get_pll_lock_status(dp) == PLL_UNLOCKED) {\n\t\t\ttimeout_loop++;\n\t\t\tif (DP_TIMEOUT_LOOP_COUNT < timeout_loop) {\n\t\t\t\tdev_err(dp->dev, \"failed to get pll lock status\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tusleep_range(10, 20);\n\t\t}\n\t}\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n\treg &= ~(SERDES_FIFO_FUNC_EN_N | LS_CLK_DOMAIN_FUNC_EN_N\n\t\t| AUX_FUNC_EN_N);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n\treturn 0;\n}\n\nvoid analogix_dp_clear_hotplug_interrupts(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\tif (dp->hpd_gpiod)\n\t\treturn;\n\n\treg = HOTPLUG_CHG | HPD_LOST | PLUG;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_4);\n\n\treg = INT_HPD;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_INT_STA);\n}\n\nvoid analogix_dp_init_hpd(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\tif (dp->hpd_gpiod)\n\t\treturn;\n\n\tanalogix_dp_clear_hotplug_interrupts(dp);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\treg &= ~(F_HPD | HPD_CTRL);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n}\n\nvoid analogix_dp_force_hpd(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\treg = (F_HPD | HPD_CTRL);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n}\n\nenum dp_irq_type analogix_dp_get_irq_type(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\tif (dp->hpd_gpiod) {\n\t\treg = gpiod_get_value(dp->hpd_gpiod);\n\t\tif (reg)\n\t\t\treturn DP_IRQ_TYPE_HP_CABLE_IN;\n\t\telse\n\t\t\treturn DP_IRQ_TYPE_HP_CABLE_OUT;\n\t} else {\n\t\t \n\t\treg = readl(dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_4);\n\n\t\tif (reg & PLUG)\n\t\t\treturn DP_IRQ_TYPE_HP_CABLE_IN;\n\n\t\tif (reg & HPD_LOST)\n\t\t\treturn DP_IRQ_TYPE_HP_CABLE_OUT;\n\n\t\tif (reg & HOTPLUG_CHG)\n\t\t\treturn DP_IRQ_TYPE_HP_CHANGE;\n\n\t\treturn DP_IRQ_TYPE_UNKNOWN;\n\t}\n}\n\nvoid analogix_dp_reset_aux(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n\treg |= AUX_FUNC_EN_N;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n}\n\nvoid analogix_dp_init_aux(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\t \n\treg = RPLY_RECEIV | AUX_ERR;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_INT_STA);\n\n\tanalogix_dp_set_analog_power_down(dp, AUX_BLOCK, true);\n\tusleep_range(10, 11);\n\tanalogix_dp_set_analog_power_down(dp, AUX_BLOCK, false);\n\n\tanalogix_dp_reset_aux(dp);\n\n\t \n\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type))\n\t\treg = 0;\n\telse\n\t\treg = AUX_BIT_PERIOD_EXPECTED_DELAY(3);\n\n\t \n\treg |= AUX_HW_RETRY_COUNT_SEL(0) |\n\t       AUX_HW_RETRY_INTERVAL_600_MICROSECONDS;\n\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_HW_RETRY_CTL);\n\n\t \n\treg = DEFER_CTRL_EN | DEFER_COUNT(1);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_DEFER_CTL);\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n\treg &= ~AUX_FUNC_EN_N;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_2);\n}\n\nint analogix_dp_get_plug_in_status(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\tif (dp->hpd_gpiod) {\n\t\tif (gpiod_get_value(dp->hpd_gpiod))\n\t\t\treturn 0;\n\t} else {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\t\tif (reg & HPD_STATUS)\n\t\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nvoid analogix_dp_enable_sw_function(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_1);\n\treg &= ~SW_FUNC_EN_N;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_1);\n}\n\nvoid analogix_dp_set_link_bandwidth(struct analogix_dp_device *dp, u32 bwtype)\n{\n\tu32 reg;\n\n\treg = bwtype;\n\tif ((bwtype == DP_LINK_BW_2_7) || (bwtype == DP_LINK_BW_1_62))\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_LINK_BW_SET);\n}\n\nvoid analogix_dp_get_link_bandwidth(struct analogix_dp_device *dp, u32 *bwtype)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_LINK_BW_SET);\n\t*bwtype = reg;\n}\n\nvoid analogix_dp_set_lane_count(struct analogix_dp_device *dp, u32 count)\n{\n\tu32 reg;\n\n\treg = count;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LANE_COUNT_SET);\n}\n\nvoid analogix_dp_get_lane_count(struct analogix_dp_device *dp, u32 *count)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_LANE_COUNT_SET);\n\t*count = reg;\n}\n\nvoid analogix_dp_enable_enhanced_mode(struct analogix_dp_device *dp,\n\t\t\t\t      bool enable)\n{\n\tu32 reg;\n\n\tif (enable) {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t\treg |= ENHANCED;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t} else {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t\treg &= ~ENHANCED;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t}\n}\n\nvoid analogix_dp_set_training_pattern(struct analogix_dp_device *dp,\n\t\t\t\t      enum pattern_set pattern)\n{\n\tu32 reg;\n\n\tswitch (pattern) {\n\tcase PRBS7:\n\t\treg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_PRBS7;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\t\tbreak;\n\tcase D10_2:\n\t\treg = SCRAMBLING_ENABLE | LINK_QUAL_PATTERN_SET_D10_2;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\t\tbreak;\n\tcase TRAINING_PTN1:\n\t\treg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN1;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\t\tbreak;\n\tcase TRAINING_PTN2:\n\t\treg = SCRAMBLING_DISABLE | SW_TRAINING_PATTERN_SET_PTN2;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\t\tbreak;\n\tcase DP_NONE:\n\t\treg = SCRAMBLING_ENABLE |\n\t\t\tLINK_QUAL_PATTERN_SET_DISABLE |\n\t\t\tSW_TRAINING_PATTERN_SET_NORMAL;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid analogix_dp_set_lane0_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);\n\treg &= ~PRE_EMPHASIS_SET_MASK;\n\treg |= level << PRE_EMPHASIS_SET_SHIFT;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane1_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);\n\treg &= ~PRE_EMPHASIS_SET_MASK;\n\treg |= level << PRE_EMPHASIS_SET_SHIFT;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane2_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);\n\treg &= ~PRE_EMPHASIS_SET_MASK;\n\treg |= level << PRE_EMPHASIS_SET_SHIFT;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane3_pre_emphasis(struct analogix_dp_device *dp,\n\t\t\t\t\tu32 level)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);\n\treg &= ~PRE_EMPHASIS_SET_MASK;\n\treg |= level << PRE_EMPHASIS_SET_SHIFT;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane0_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane)\n{\n\tu32 reg;\n\n\treg = training_lane;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane1_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane)\n{\n\tu32 reg;\n\n\treg = training_lane;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane2_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane)\n{\n\tu32 reg;\n\n\treg = training_lane;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_set_lane3_link_training(struct analogix_dp_device *dp,\n\t\t\t\t\t u32 training_lane)\n{\n\tu32 reg;\n\n\treg = training_lane;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);\n}\n\nu32 analogix_dp_get_lane0_link_training(struct analogix_dp_device *dp)\n{\n\treturn readl(dp->reg_base + ANALOGIX_DP_LN0_LINK_TRAINING_CTL);\n}\n\nu32 analogix_dp_get_lane1_link_training(struct analogix_dp_device *dp)\n{\n\treturn readl(dp->reg_base + ANALOGIX_DP_LN1_LINK_TRAINING_CTL);\n}\n\nu32 analogix_dp_get_lane2_link_training(struct analogix_dp_device *dp)\n{\n\treturn readl(dp->reg_base + ANALOGIX_DP_LN2_LINK_TRAINING_CTL);\n}\n\nu32 analogix_dp_get_lane3_link_training(struct analogix_dp_device *dp)\n{\n\treturn readl(dp->reg_base + ANALOGIX_DP_LN3_LINK_TRAINING_CTL);\n}\n\nvoid analogix_dp_reset_macro(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_PHY_TEST);\n\treg |= MACRO_RST;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_PHY_TEST);\n\n\t \n\tusleep_range(10, 20);\n\n\treg &= ~MACRO_RST;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_PHY_TEST);\n}\n\nvoid analogix_dp_init_video(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = VSYNC_DET | VID_FORMAT_CHG | VID_CLK_CHG;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_COMMON_INT_STA_1);\n\n\treg = 0x0;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_1);\n\n\treg = CHA_CRI(4) | CHA_CTRL;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_2);\n\n\treg = 0x0;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\n\treg = VID_HRES_TH(2) | VID_VRES_TH(0);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_8);\n}\n\nvoid analogix_dp_set_video_color_format(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\t \n\treg = (dp->video_info.dynamic_range << IN_D_RANGE_SHIFT) |\n\t\t(dp->video_info.color_depth << IN_BPC_SHIFT) |\n\t\t(dp->video_info.color_space << IN_COLOR_F_SHIFT);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_2);\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);\n\treg &= ~IN_YC_COEFFI_MASK;\n\tif (dp->video_info.ycbcr_coeff)\n\t\treg |= IN_YC_COEFFI_ITU709;\n\telse\n\t\treg |= IN_YC_COEFFI_ITU601;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);\n}\n\nint analogix_dp_is_slave_video_stream_clock_on(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_1);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_1);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_1);\n\n\tif (!(reg & DET_STA)) {\n\t\tdev_dbg(dp->dev, \"Input stream clock not detected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_2);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_2);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_2);\n\tdev_dbg(dp->dev, \"wait SYS_CTL_2.\\n\");\n\n\tif (reg & CHA_STA) {\n\t\tdev_dbg(dp->dev, \"Input stream clk is changing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid analogix_dp_set_video_cr_mn(struct analogix_dp_device *dp,\n\t\t\t\t enum clock_recovery_m_value_type type,\n\t\t\t\t u32 m_value, u32 n_value)\n{\n\tu32 reg;\n\n\tif (type == REGISTER_M) {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t\treg |= FIX_M_VID;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t\treg = m_value & 0xff;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_M_VID_0);\n\t\treg = (m_value >> 8) & 0xff;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_M_VID_1);\n\t\treg = (m_value >> 16) & 0xff;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_M_VID_2);\n\n\t\treg = n_value & 0xff;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_N_VID_0);\n\t\treg = (n_value >> 8) & 0xff;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_N_VID_1);\n\t\treg = (n_value >> 16) & 0xff;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_N_VID_2);\n\t} else  {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\t\treg &= ~FIX_M_VID;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_4);\n\n\t\twritel(0x00, dp->reg_base + ANALOGIX_DP_N_VID_0);\n\t\twritel(0x80, dp->reg_base + ANALOGIX_DP_N_VID_1);\n\t\twritel(0x00, dp->reg_base + ANALOGIX_DP_N_VID_2);\n\t}\n}\n\nvoid analogix_dp_set_video_timing_mode(struct analogix_dp_device *dp, u32 type)\n{\n\tu32 reg;\n\n\tif (type == VIDEO_TIMING_FROM_CAPTURE) {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\t\treg &= ~FORMAT_SEL;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\t} else {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\t\treg |= FORMAT_SEL;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\t}\n}\n\nvoid analogix_dp_enable_video_master(struct analogix_dp_device *dp, bool enable)\n{\n\tu32 reg;\n\n\tif (enable) {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);\n\t\treg &= ~VIDEO_MODE_MASK;\n\t\treg |= VIDEO_MASTER_MODE_EN | VIDEO_MODE_MASTER_MODE;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);\n\t} else {\n\t\treg = readl(dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);\n\t\treg &= ~VIDEO_MODE_MASK;\n\t\treg |= VIDEO_MODE_SLAVE_MODE;\n\t\twritel(reg, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);\n\t}\n}\n\nvoid analogix_dp_start_video(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n\treg |= VIDEO_EN;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_1);\n}\n\nint analogix_dp_is_video_stream_on(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_SYS_CTL_3);\n\tif (!(reg & STRM_VALID)) {\n\t\tdev_dbg(dp->dev, \"Input video stream is not detected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid analogix_dp_config_video_slave_mode(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_FUNC_EN_1);\n\tif (dp->plat_data && is_rockchip(dp->plat_data->dev_type)) {\n\t\treg &= ~(RK_VID_CAP_FUNC_EN_N | RK_VID_FIFO_FUNC_EN_N);\n\t} else {\n\t\treg &= ~(MASTER_VID_FUNC_EN_N | SLAVE_VID_FUNC_EN_N);\n\t\treg |= MASTER_VID_FUNC_EN_N;\n\t}\n\twritel(reg, dp->reg_base + ANALOGIX_DP_FUNC_EN_1);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\treg &= ~INTERACE_SCAN_CFG;\n\treg |= (dp->video_info.interlaced << 2);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\treg &= ~VSYNC_POLARITY_CFG;\n\treg |= (dp->video_info.v_sync_polarity << 1);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\treg &= ~HSYNC_POLARITY_CFG;\n\treg |= (dp->video_info.h_sync_polarity << 0);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_10);\n\n\treg = AUDIO_MODE_SPDIF_MODE | VIDEO_MODE_SLAVE_MODE;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_SOC_GENERAL_CTL);\n}\n\nvoid analogix_dp_enable_scrambling(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\treg &= ~SCRAMBLING_DISABLE;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n}\n\nvoid analogix_dp_disable_scrambling(struct analogix_dp_device *dp)\n{\n\tu32 reg;\n\n\treg = readl(dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n\treg |= SCRAMBLING_DISABLE;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_TRAINING_PTN_SET);\n}\n\nvoid analogix_dp_enable_psr_crc(struct analogix_dp_device *dp)\n{\n\twritel(PSR_VID_CRC_ENABLE, dp->reg_base + ANALOGIX_DP_CRC_CON);\n}\n\nstatic ssize_t analogix_dp_get_psr_status(struct analogix_dp_device *dp)\n{\n\tssize_t val;\n\tu8 status;\n\n\tval = drm_dp_dpcd_readb(&dp->aux, DP_PSR_STATUS, &status);\n\tif (val < 0) {\n\t\tdev_err(dp->dev, \"PSR_STATUS read failed ret=%zd\", val);\n\t\treturn val;\n\t}\n\treturn status;\n}\n\nint analogix_dp_send_psr_spd(struct analogix_dp_device *dp,\n\t\t\t     struct dp_sdp *vsc, bool blocking)\n{\n\tunsigned int val;\n\tint ret;\n\tssize_t psr_status;\n\n\t \n\tval = readl(dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\tval &= ~IF_EN;\n\twritel(val, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\n\t \n\twritel(PSR_FRAME_UP_TYPE_BURST | PSR_CRC_SEL_HARDWARE,\n\t       dp->reg_base + ANALOGIX_DP_PSR_FRAME_UPDATE_CTRL);\n\n\t \n\twritel(vsc->sdp_header.HB0, dp->reg_base + ANALOGIX_DP_SPD_HB0);\n\twritel(vsc->sdp_header.HB1, dp->reg_base + ANALOGIX_DP_SPD_HB1);\n\twritel(vsc->sdp_header.HB2, dp->reg_base + ANALOGIX_DP_SPD_HB2);\n\twritel(vsc->sdp_header.HB3, dp->reg_base + ANALOGIX_DP_SPD_HB3);\n\n\t \n\twritel(0x00, dp->reg_base + ANALOGIX_DP_SPD_PB0);\n\twritel(0x16, dp->reg_base + ANALOGIX_DP_SPD_PB1);\n\twritel(0xCE, dp->reg_base + ANALOGIX_DP_SPD_PB2);\n\twritel(0x5D, dp->reg_base + ANALOGIX_DP_SPD_PB3);\n\n\t \n\twritel(vsc->db[0], dp->reg_base + ANALOGIX_DP_VSC_SHADOW_DB0);\n\twritel(vsc->db[1], dp->reg_base + ANALOGIX_DP_VSC_SHADOW_DB1);\n\n\t \n\tval = readl(dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);\n\tval |= REUSE_SPD_EN;\n\twritel(val, dp->reg_base + ANALOGIX_DP_VIDEO_CTL_3);\n\n\t \n\tval = readl(dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\tval = (val | IF_UP) & ~IF_EN;\n\twritel(val, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\n\t \n\tval = readl(dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\tval |= IF_EN;\n\twritel(val, dp->reg_base + ANALOGIX_DP_PKT_SEND_CTL);\n\n\tif (!blocking)\n\t\treturn 0;\n\n\t \n\tret = readx_poll_timeout(analogix_dp_get_psr_status, dp, psr_status,\n\t\tpsr_status >= 0 &&\n\t\t((vsc->db[1] && psr_status == DP_PSR_SINK_ACTIVE_RFB) ||\n\t\t(!vsc->db[1] && (psr_status == DP_PSR_SINK_ACTIVE_RESYNC ||\n\t\t\t\t psr_status == DP_PSR_SINK_INACTIVE))),\n\t\t1500, DP_TIMEOUT_PSR_LOOP_MS * 1000);\n\tif (ret) {\n\t\tdev_warn(dp->dev, \"Failed to apply PSR %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nssize_t analogix_dp_transfer(struct analogix_dp_device *dp,\n\t\t\t     struct drm_dp_aux_msg *msg)\n{\n\tu32 reg;\n\tu32 status_reg;\n\tu8 *buffer = msg->buffer;\n\tunsigned int i;\n\tint num_transferred = 0;\n\tint ret;\n\n\t \n\tif (WARN_ON(msg->size > 16))\n\t\treturn -E2BIG;\n\n\t \n\treg = BUF_CLR;\n\twritel(reg, dp->reg_base + ANALOGIX_DP_BUFFER_DATA_CTL);\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_I2C_WRITE:\n\t\treg = AUX_TX_COMM_WRITE | AUX_TX_COMM_I2C_TRANSACTION;\n\t\tif (msg->request & DP_AUX_I2C_MOT)\n\t\t\treg |= AUX_TX_COMM_MOT;\n\t\tbreak;\n\n\tcase DP_AUX_I2C_READ:\n\t\treg = AUX_TX_COMM_READ | AUX_TX_COMM_I2C_TRANSACTION;\n\t\tif (msg->request & DP_AUX_I2C_MOT)\n\t\t\treg |= AUX_TX_COMM_MOT;\n\t\tbreak;\n\n\tcase DP_AUX_NATIVE_WRITE:\n\t\treg = AUX_TX_COMM_WRITE | AUX_TX_COMM_DP_TRANSACTION;\n\t\tbreak;\n\n\tcase DP_AUX_NATIVE_READ:\n\t\treg = AUX_TX_COMM_READ | AUX_TX_COMM_DP_TRANSACTION;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg |= AUX_LENGTH(msg->size);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_1);\n\n\t \n\treg = AUX_ADDR_7_0(msg->address);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_7_0);\n\treg = AUX_ADDR_15_8(msg->address);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_15_8);\n\treg = AUX_ADDR_19_16(msg->address);\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_ADDR_19_16);\n\n\tif (!(msg->request & DP_AUX_I2C_READ)) {\n\t\tfor (i = 0; i < msg->size; i++) {\n\t\t\treg = buffer[i];\n\t\t\twritel(reg, dp->reg_base + ANALOGIX_DP_BUF_DATA_0 +\n\t\t\t       4 * i);\n\t\t\tnum_transferred++;\n\t\t}\n\t}\n\n\t \n\treg = AUX_EN;\n\n\t \n\tif (msg->size < 1)\n\t\treg |= ADDR_ONLY;\n\n\twritel(reg, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_2);\n\n\tret = readx_poll_timeout(readl, dp->reg_base + ANALOGIX_DP_AUX_CH_CTL_2,\n\t\t\t\t reg, !(reg & AUX_EN), 25, 500 * 1000);\n\tif (ret) {\n\t\tdev_err(dp->dev, \"AUX CH enable timeout!\\n\");\n\t\tgoto aux_error;\n\t}\n\n\t \n\t \n\tret = readx_poll_timeout(readl, dp->reg_base + ANALOGIX_DP_INT_STA,\n\t\t\t\t reg, reg & RPLY_RECEIV, 10, 20 * 1000);\n\tif (ret) {\n\t\tdev_err(dp->dev, \"AUX CH cmd reply timeout!\\n\");\n\t\tgoto aux_error;\n\t}\n\n\t \n\twritel(RPLY_RECEIV, dp->reg_base + ANALOGIX_DP_INT_STA);\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_INT_STA);\n\tstatus_reg = readl(dp->reg_base + ANALOGIX_DP_AUX_CH_STA);\n\tif ((reg & AUX_ERR) || (status_reg & AUX_STATUS_MASK)) {\n\t\twritel(AUX_ERR, dp->reg_base + ANALOGIX_DP_INT_STA);\n\n\t\tdev_warn(dp->dev, \"AUX CH error happened: %#x (%d)\\n\",\n\t\t\t status_reg & AUX_STATUS_MASK, !!(reg & AUX_ERR));\n\t\tgoto aux_error;\n\t}\n\n\tif (msg->request & DP_AUX_I2C_READ) {\n\t\tfor (i = 0; i < msg->size; i++) {\n\t\t\treg = readl(dp->reg_base + ANALOGIX_DP_BUF_DATA_0 +\n\t\t\t\t    4 * i);\n\t\t\tbuffer[i] = (unsigned char)reg;\n\t\t\tnum_transferred++;\n\t\t}\n\t}\n\n\t \n\treg = readl(dp->reg_base + ANALOGIX_DP_AUX_RX_COMM);\n\tif (reg == AUX_RX_COMM_AUX_DEFER)\n\t\tmsg->reply = DP_AUX_NATIVE_REPLY_DEFER;\n\telse if (reg == AUX_RX_COMM_I2C_DEFER)\n\t\tmsg->reply = DP_AUX_I2C_REPLY_DEFER;\n\telse if ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_WRITE ||\n\t\t (msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_READ)\n\t\tmsg->reply = DP_AUX_I2C_REPLY_ACK;\n\telse if ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_NATIVE_WRITE ||\n\t\t (msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_NATIVE_READ)\n\t\tmsg->reply = DP_AUX_NATIVE_REPLY_ACK;\n\n\treturn num_transferred > 0 ? num_transferred : -EBUSY;\n\naux_error:\n\t \n\tanalogix_dp_init_aux(dp);\n\n\treturn -EREMOTEIO;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}