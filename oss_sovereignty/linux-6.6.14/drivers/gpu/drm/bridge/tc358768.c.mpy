{
  "module_name": "tc358768.c",
  "hash_id": "677ce984e65c52330d6512d11bac33233975b46e7c5ca2f7a6614f9f94f9a684",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/tc358768.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <video/mipi_display.h>\n#include <video/videomode.h>\n\n \n#define TC358768_CHIPID\t\t\t0x0000\n#define TC358768_SYSCTL\t\t\t0x0002\n#define TC358768_CONFCTL\t\t0x0004\n#define TC358768_VSDLY\t\t\t0x0006\n#define TC358768_DATAFMT\t\t0x0008\n#define TC358768_GPIOEN\t\t\t0x000E\n#define TC358768_GPIODIR\t\t0x0010\n#define TC358768_GPIOIN\t\t\t0x0012\n#define TC358768_GPIOOUT\t\t0x0014\n#define TC358768_PLLCTL0\t\t0x0016\n#define TC358768_PLLCTL1\t\t0x0018\n#define TC358768_CMDBYTE\t\t0x0022\n#define TC358768_PP_MISC\t\t0x0032\n#define TC358768_DSITX_DT\t\t0x0050\n#define TC358768_FIFOSTATUS\t\t0x00F8\n\n \n#define TC358768_VBUFCTRL\t\t0x00E0\n#define TC358768_DBG_WIDTH\t\t0x00E2\n#define TC358768_DBG_VBLANK\t\t0x00E4\n#define TC358768_DBG_DATA\t\t0x00E8\n\n \n#define TC358768_CLW_DPHYCONTTX\t\t0x0100\n#define TC358768_D0W_DPHYCONTTX\t\t0x0104\n#define TC358768_D1W_DPHYCONTTX\t\t0x0108\n#define TC358768_D2W_DPHYCONTTX\t\t0x010C\n#define TC358768_D3W_DPHYCONTTX\t\t0x0110\n#define TC358768_CLW_CNTRL\t\t0x0140\n#define TC358768_D0W_CNTRL\t\t0x0144\n#define TC358768_D1W_CNTRL\t\t0x0148\n#define TC358768_D2W_CNTRL\t\t0x014C\n#define TC358768_D3W_CNTRL\t\t0x0150\n\n \n#define TC358768_STARTCNTRL\t\t0x0204\n#define TC358768_DSITXSTATUS\t\t0x0208\n#define TC358768_LINEINITCNT\t\t0x0210\n#define TC358768_LPTXTIMECNT\t\t0x0214\n#define TC358768_TCLK_HEADERCNT\t\t0x0218\n#define TC358768_TCLK_TRAILCNT\t\t0x021C\n#define TC358768_THS_HEADERCNT\t\t0x0220\n#define TC358768_TWAKEUP\t\t0x0224\n#define TC358768_TCLK_POSTCNT\t\t0x0228\n#define TC358768_THS_TRAILCNT\t\t0x022C\n#define TC358768_HSTXVREGCNT\t\t0x0230\n#define TC358768_HSTXVREGEN\t\t0x0234\n#define TC358768_TXOPTIONCNTRL\t\t0x0238\n#define TC358768_BTACNTRL1\t\t0x023C\n\n \n#define TC358768_DSI_CONTROL\t\t0x040C\n#define TC358768_DSI_STATUS\t\t0x0410\n#define TC358768_DSI_INT\t\t0x0414\n#define TC358768_DSI_INT_ENA\t\t0x0418\n#define TC358768_DSICMD_RDFIFO\t\t0x0430\n#define TC358768_DSI_ACKERR\t\t0x0434\n#define TC358768_DSI_ACKERR_INTENA\t0x0438\n#define TC358768_DSI_ACKERR_HALT\t0x043c\n#define TC358768_DSI_RXERR\t\t0x0440\n#define TC358768_DSI_RXERR_INTENA\t0x0444\n#define TC358768_DSI_RXERR_HALT\t\t0x0448\n#define TC358768_DSI_ERR\t\t0x044C\n#define TC358768_DSI_ERR_INTENA\t\t0x0450\n#define TC358768_DSI_ERR_HALT\t\t0x0454\n#define TC358768_DSI_CONFW\t\t0x0500\n#define TC358768_DSI_LPCMD\t\t0x0500\n#define TC358768_DSI_RESET\t\t0x0504\n#define TC358768_DSI_INT_CLR\t\t0x050C\n#define TC358768_DSI_START\t\t0x0518\n\n \n#define TC358768_DSICMD_TX\t\t0x0600\n#define TC358768_DSICMD_TYPE\t\t0x0602\n#define TC358768_DSICMD_WC\t\t0x0604\n#define TC358768_DSICMD_WD0\t\t0x0610\n#define TC358768_DSICMD_WD1\t\t0x0612\n#define TC358768_DSICMD_WD2\t\t0x0614\n#define TC358768_DSICMD_WD3\t\t0x0616\n#define TC358768_DSI_EVENT\t\t0x0620\n#define TC358768_DSI_VSW\t\t0x0622\n#define TC358768_DSI_VBPR\t\t0x0624\n#define TC358768_DSI_VACT\t\t0x0626\n#define TC358768_DSI_HSW\t\t0x0628\n#define TC358768_DSI_HBPR\t\t0x062A\n#define TC358768_DSI_HACT\t\t0x062C\n\n \n#define TC358768_DSI_CONTROL_DIS_MODE\tBIT(15)\n#define TC358768_DSI_CONTROL_TXMD\tBIT(7)\n#define TC358768_DSI_CONTROL_HSCKMD\tBIT(5)\n#define TC358768_DSI_CONTROL_EOTDIS\tBIT(0)\n\n \n#define TC358768_DSI_CONFW_MODE_SET\t(5 << 29)\n#define TC358768_DSI_CONFW_MODE_CLR\t(6 << 29)\n#define TC358768_DSI_CONFW_ADDR_DSI_CONTROL\t(0x3 << 24)\n\nstatic const char * const tc358768_supplies[] = {\n\t\"vddc\", \"vddmipi\", \"vddio\"\n};\n\nstruct tc358768_dsi_output {\n\tstruct mipi_dsi_device *dev;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n};\n\nstruct tc358768_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(tc358768_supplies)];\n\tstruct clk *refclk;\n\tint enabled;\n\tint error;\n\n\tstruct mipi_dsi_host dsi_host;\n\tstruct drm_bridge bridge;\n\tstruct tc358768_dsi_output output;\n\n\tu32 pd_lines;  \n\tu32 dsi_lanes;  \n\tu32 dsi_bpp;  \n\n\t \n\tu32 fbd;\t \n\tu32 prd;\t \n\tu32 frs;\t \n\n\tu32 dsiclk;\t \n};\n\nstatic inline struct tc358768_priv *dsi_host_to_tc358768(struct mipi_dsi_host\n\t\t\t\t\t\t\t *host)\n{\n\treturn container_of(host, struct tc358768_priv, dsi_host);\n}\n\nstatic inline struct tc358768_priv *bridge_to_tc358768(struct drm_bridge\n\t\t\t\t\t\t       *bridge)\n{\n\treturn container_of(bridge, struct tc358768_priv, bridge);\n}\n\nstatic int tc358768_clear_error(struct tc358768_priv *priv)\n{\n\tint ret = priv->error;\n\n\tpriv->error = 0;\n\treturn ret;\n}\n\nstatic void tc358768_write(struct tc358768_priv *priv, u32 reg, u32 val)\n{\n\t \n\tif (reg < 0x100 || reg >= 0x600)\n\t\tcount = 1;\n\n\tpriv->error = regmap_bulk_write(priv->regmap, reg, &tmpval, count);\n}\n\nstatic void tc358768_read(struct tc358768_priv *priv, u32 reg, u32 *val)\n{\n\tsize_t count = 2;\n\n\tif (priv->error)\n\t\treturn;\n\n\t \n\tif (reg < 0x100 || reg >= 0x600) {\n\t\t*val = 0;\n\t\tcount = 1;\n\t}\n\n\tpriv->error = regmap_bulk_read(priv->regmap, reg, val, count);\n}\n\nstatic void tc358768_update_bits(struct tc358768_priv *priv, u32 reg, u32 mask,\n\t\t\t\t u32 val)\n{\n\tu32 tmp, orig;\n\n\ttc358768_read(priv, reg, &orig);\n\n\tif (priv->error)\n\t\treturn;\n\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\tif (tmp != orig)\n\t\ttc358768_write(priv, reg, tmp);\n}\n\nstatic int tc358768_sw_reset(struct tc358768_priv *priv)\n{\n\t \n\ttc358768_write(priv, TC358768_SYSCTL, 1);\n\t \n\ttc358768_write(priv, TC358768_SYSCTL, 0);\n\n\treturn tc358768_clear_error(priv);\n}\n\nstatic void tc358768_hw_enable(struct tc358768_priv *priv)\n{\n\tint ret;\n\n\tif (priv->enabled)\n\t\treturn;\n\n\tret = clk_prepare_enable(priv->refclk);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"error enabling refclk (%d)\\n\", ret);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"error enabling regulators (%d)\\n\", ret);\n\n\tif (priv->reset_gpio)\n\t\tusleep_range(200, 300);\n\n\t \n\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\n\t \n\tusleep_range(1000, 2000);\n\n\tpriv->enabled = true;\n}\n\nstatic void tc358768_hw_disable(struct tc358768_priv *priv)\n{\n\tint ret;\n\n\tif (!priv->enabled)\n\t\treturn;\n\n\t \n\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t     priv->supplies);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"error disabling regulators (%d)\\n\", ret);\n\n\tclk_disable_unprepare(priv->refclk);\n\n\tpriv->enabled = false;\n}\n\nstatic u32 tc358768_pll_to_pclk(struct tc358768_priv *priv, u32 pll_clk)\n{\n\treturn (u32)div_u64((u64)pll_clk * priv->dsi_lanes, priv->dsi_bpp);\n}\n\nstatic u32 tc358768_pclk_to_pll(struct tc358768_priv *priv, u32 pclk)\n{\n\treturn (u32)div_u64((u64)pclk * priv->dsi_bpp, priv->dsi_lanes);\n}\n\nstatic int tc358768_calc_pll(struct tc358768_priv *priv,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     bool verify_only)\n{\n\tstatic const u32 frs_limits[] = {\n\t\t1000000000,\n\t\t500000000,\n\t\t250000000,\n\t\t125000000,\n\t\t62500000\n\t};\n\tunsigned long refclk;\n\tu32 prd, target_pll, i, max_pll, min_pll;\n\tu32 frs, best_diff, best_pll, best_prd, best_fbd;\n\n\ttarget_pll = tc358768_pclk_to_pll(priv, mode->clock * 1000);\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(frs_limits); i++)\n\t\tif (target_pll >= frs_limits[i])\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(frs_limits) || i == 0)\n\t\treturn -EINVAL;\n\n\tfrs = i - 1;\n\tmax_pll = frs_limits[i - 1];\n\tmin_pll = frs_limits[i];\n\n\trefclk = clk_get_rate(priv->refclk);\n\n\tbest_diff = UINT_MAX;\n\tbest_pll = 0;\n\tbest_prd = 0;\n\tbest_fbd = 0;\n\n\tfor (prd = 0; prd < 16; ++prd) {\n\t\tu32 divisor = (prd + 1) * (1 << frs);\n\t\tu32 fbd;\n\n\t\tfor (fbd = 0; fbd < 512; ++fbd) {\n\t\t\tu32 pll, diff, pll_in;\n\n\t\t\tpll = (u32)div_u64((u64)refclk * (fbd + 1), divisor);\n\n\t\t\tif (pll >= max_pll || pll < min_pll)\n\t\t\t\tcontinue;\n\n\t\t\tpll_in = (u32)div_u64((u64)refclk, prd + 1);\n\t\t\tif (pll_in < 4000000)\n\t\t\t\tcontinue;\n\n\t\t\tdiff = max(pll, target_pll) - min(pll, target_pll);\n\n\t\t\tif (diff < best_diff) {\n\t\t\t\tbest_diff = diff;\n\t\t\t\tbest_pll = pll;\n\t\t\t\tbest_prd = prd;\n\t\t\t\tbest_fbd = fbd;\n\n\t\t\t\tif (best_diff == 0)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (best_diff == UINT_MAX) {\n\t\tdev_err(priv->dev, \"could not find suitable PLL setup\\n\");\n\t\treturn -EINVAL;\n\t}\n\nfound:\n\tif (verify_only)\n\t\treturn 0;\n\n\tpriv->fbd = best_fbd;\n\tpriv->prd = best_prd;\n\tpriv->frs = frs;\n\tpriv->dsiclk = best_pll / 2;\n\n\treturn 0;\n}\n\nstatic int tc358768_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\t    struct mipi_dsi_device *dev)\n{\n\tstruct tc358768_priv *priv = dsi_host_to_tc358768(host);\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tstruct device_node *ep;\n\tint ret;\n\n\tif (dev->lanes > 4) {\n\t\tdev_err(priv->dev, \"unsupported number of data lanes(%u)\\n\",\n\t\t\tdev->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(dev->mode_flags & MIPI_DSI_MODE_VIDEO)) {\n\t\tdev_err(priv->dev, \"Only MIPI_DSI_MODE_VIDEO is supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tif (dev->format != MIPI_DSI_FMT_RGB888) {\n\t\tdev_warn(priv->dev, \"Only MIPI_DSI_FMT_RGB888 tested!\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = drm_of_find_panel_or_bridge(host->dev->of_node, 1, 0, &panel,\n\t\t\t\t\t  &bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tif (panel) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_DSI);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn PTR_ERR(bridge);\n\t}\n\n\tpriv->output.dev = dev;\n\tpriv->output.bridge = bridge;\n\tpriv->output.panel = panel;\n\n\tpriv->dsi_lanes = dev->lanes;\n\tpriv->dsi_bpp = mipi_dsi_pixel_format_to_bpp(dev->format);\n\n\t \n\tret = -EINVAL;\n\tep = of_graph_get_endpoint_by_regs(host->dev->of_node, 0, 0);\n\tif (ep) {\n\t\tret = of_property_read_u32(ep, \"data-lines\", &priv->pd_lines);\n\n\t\tof_node_put(ep);\n\t}\n\n\tif (ret)\n\t\tpriv->pd_lines = priv->dsi_bpp;\n\n\tdrm_bridge_add(&priv->bridge);\n\n\treturn 0;\n}\n\nstatic int tc358768_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\t    struct mipi_dsi_device *dev)\n{\n\tstruct tc358768_priv *priv = dsi_host_to_tc358768(host);\n\n\tdrm_bridge_remove(&priv->bridge);\n\tif (priv->output.panel)\n\t\tdrm_panel_bridge_remove(priv->output.bridge);\n\n\treturn 0;\n}\n\nstatic ssize_t tc358768_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t\t  const struct mipi_dsi_msg *msg)\n{\n\tstruct tc358768_priv *priv = dsi_host_to_tc358768(host);\n\tstruct mipi_dsi_packet packet;\n\tint ret;\n\n\tif (!priv->enabled) {\n\t\tdev_err(priv->dev, \"Bridge is not enabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (msg->rx_len) {\n\t\tdev_warn(priv->dev, \"MIPI rx is not supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (msg->tx_len > 8) {\n\t\tdev_warn(priv->dev, \"Maximum 8 byte MIPI tx is supported\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = mipi_dsi_create_packet(&packet, msg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mipi_dsi_packet_format_is_short(msg->type)) {\n\t\ttc358768_write(priv, TC358768_DSICMD_TYPE,\n\t\t\t       (0x10 << 8) | (packet.header[0] & 0x3f));\n\t\ttc358768_write(priv, TC358768_DSICMD_WC, 0);\n\t\ttc358768_write(priv, TC358768_DSICMD_WD0,\n\t\t\t       (packet.header[2] << 8) | packet.header[1]);\n\t} else {\n\t\tint i;\n\n\t\ttc358768_write(priv, TC358768_DSICMD_TYPE,\n\t\t\t       (0x40 << 8) | (packet.header[0] & 0x3f));\n\t\ttc358768_write(priv, TC358768_DSICMD_WC, packet.payload_length);\n\t\tfor (i = 0; i < packet.payload_length; i += 2) {\n\t\t\tu16 val = packet.payload[i];\n\n\t\t\tif (i + 1 < packet.payload_length)\n\t\t\t\tval |= packet.payload[i + 1] << 8;\n\n\t\t\ttc358768_write(priv, TC358768_DSICMD_WD0 + i, val);\n\t\t}\n\t}\n\n\t \n\ttc358768_write(priv, TC358768_DSICMD_TX, 1);\n\n\tret = tc358768_clear_error(priv);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"Software disable failed: %d\\n\", ret);\n\telse\n\t\tret = packet.size;\n\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops tc358768_dsi_host_ops = {\n\t.attach = tc358768_dsi_host_attach,\n\t.detach = tc358768_dsi_host_detach,\n\t.transfer = tc358768_dsi_host_transfer,\n};\n\nstatic int tc358768_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t  enum drm_bridge_attach_flags flags)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\n\tif (!drm_core_check_feature(bridge->dev, DRIVER_ATOMIC)) {\n\t\tdev_err(priv->dev, \"needs atomic updates support\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder, priv->output.bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic enum drm_mode_status\ntc358768_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t   const struct drm_display_info *info,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\n\tif (tc358768_calc_pll(priv, mode, true))\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic void tc358768_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\tint ret;\n\n\t \n\ttc358768_update_bits(priv, TC358768_PP_MISC, BIT(15), BIT(15));\n\n\t \n\tmsleep(50);\n\n\t \n\ttc358768_update_bits(priv, TC358768_CONFCTL, BIT(6), 0);\n\n\t \n\ttc358768_update_bits(priv, TC358768_PP_MISC, BIT(14), BIT(14));\n\n\tret = tc358768_clear_error(priv);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"Software disable failed: %d\\n\", ret);\n}\n\nstatic void tc358768_bridge_post_disable(struct drm_bridge *bridge)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\n\ttc358768_hw_disable(priv);\n}\n\nstatic int tc358768_setup_pll(struct tc358768_priv *priv,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tu32 fbd, prd, frs;\n\tint ret;\n\n\tret = tc358768_calc_pll(priv, mode, false);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"PLL calculation failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfbd = priv->fbd;\n\tprd = priv->prd;\n\tfrs = priv->frs;\n\n\tdev_dbg(priv->dev, \"PLL: refclk %lu, fbd %u, prd %u, frs %u\\n\",\n\t\tclk_get_rate(priv->refclk), fbd, prd, frs);\n\tdev_dbg(priv->dev, \"PLL: pll_clk: %u, DSIClk %u, HSByteClk %u\\n\",\n\t\tpriv->dsiclk * 2, priv->dsiclk, priv->dsiclk / 4);\n\tdev_dbg(priv->dev, \"PLL: pclk %u (panel: %u)\\n\",\n\t\ttc358768_pll_to_pclk(priv, priv->dsiclk * 2),\n\t\tmode->clock * 1000);\n\n\t \n\ttc358768_write(priv, TC358768_PLLCTL0, (prd << 12) | fbd);\n\n\t \n\ttc358768_write(priv, TC358768_PLLCTL1,\n\t\t       (frs << 10) | (0x2 << 8) | BIT(1) | BIT(0));\n\n\t \n\tusleep_range(1000, 2000);\n\n\t \n\ttc358768_write(priv, TC358768_PLLCTL1,\n\t\t       (frs << 10) | (0x2 << 8) | BIT(4) | BIT(1) | BIT(0));\n\n\treturn tc358768_clear_error(priv);\n}\n\nstatic u32 tc358768_ns_to_cnt(u32 ns, u32 period_ps)\n{\n\treturn DIV_ROUND_UP(ns * 1000, period_ps);\n}\n\nstatic u32 tc358768_ps_to_ns(u32 ps)\n{\n\treturn ps / 1000;\n}\n\nstatic void tc358768_bridge_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\tstruct mipi_dsi_device *dsi_dev = priv->output.dev;\n\tunsigned long mode_flags = dsi_dev->mode_flags;\n\tu32 val, val2, lptxcnt, hact, data_type;\n\ts32 raw_val;\n\tconst struct drm_display_mode *mode;\n\tu32 hsbyteclk_ps, dsiclk_ps, ui_ps;\n\tu32 dsiclk, hsbyteclk, video_start;\n\tconst u32 internal_delay = 40;\n\tint ret, i;\n\tstruct videomode vm;\n\tstruct device *dev = priv->dev;\n\n\tif (mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) {\n\t\tdev_warn_once(dev, \"Non-continuous mode unimplemented, falling back to continuous\\n\");\n\t\tmode_flags &= ~MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\t}\n\n\ttc358768_hw_enable(priv);\n\n\tret = tc358768_sw_reset(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Software reset failed: %d\\n\", ret);\n\t\ttc358768_hw_disable(priv);\n\t\treturn;\n\t}\n\n\tmode = &bridge->encoder->crtc->state->adjusted_mode;\n\tret = tc358768_setup_pll(priv, mode);\n\tif (ret) {\n\t\tdev_err(dev, \"PLL setup failed: %d\\n\", ret);\n\t\ttc358768_hw_disable(priv);\n\t\treturn;\n\t}\n\n\tdrm_display_mode_to_videomode(mode, &vm);\n\n\tdsiclk = priv->dsiclk;\n\thsbyteclk = dsiclk / 4;\n\n\t \n\tval = BIT(2) | BIT(1) | BIT(0);  \n\tswitch (dsi_dev->format) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tval |= (0x3 << 4);\n\t\thact = vm.hactive * 3;\n\t\tvideo_start = (vm.hsync_len + vm.hback_porch) * 3;\n\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_24;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tval |= (0x4 << 4);\n\t\thact = vm.hactive * 3;\n\t\tvideo_start = (vm.hsync_len + vm.hback_porch) * 3;\n\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_18;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tval |= (0x4 << 4) | BIT(3);\n\t\thact = vm.hactive * 18 / 8;\n\t\tvideo_start = (vm.hsync_len + vm.hback_porch) * 18 / 8;\n\t\tdata_type = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\n\t\tbreak;\n\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tval |= (0x5 << 4);\n\t\thact = vm.hactive * 2;\n\t\tvideo_start = (vm.hsync_len + vm.hback_porch) * 2;\n\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid data format (%u)\\n\",\n\t\t\tdsi_dev->format);\n\t\ttc358768_hw_disable(priv);\n\t\treturn;\n\t}\n\n\t \n\tvideo_start = max(video_start, internal_delay + 1) - internal_delay;\n\ttc358768_write(priv, TC358768_VSDLY, video_start);\n\n\ttc358768_write(priv, TC358768_DATAFMT, val);\n\ttc358768_write(priv, TC358768_DSITX_DT, data_type);\n\n\t \n\ttc358768_write(priv, TC358768_CLW_CNTRL, 0x0000);\n\t \n\tfor (i = 0; i < dsi_dev->lanes; i++)\n\t\ttc358768_write(priv, TC358768_D0W_CNTRL + i * 4, 0x0000);\n\n\t \n\thsbyteclk_ps = (u32)div_u64(PICO, hsbyteclk);\n\tdsiclk_ps = (u32)div_u64(PICO, dsiclk);\n\tui_ps = dsiclk_ps / 2;\n\tdev_dbg(dev, \"dsiclk: %u ps, ui %u ps, hsbyteclk %u ps\\n\", dsiclk_ps,\n\t\tui_ps, hsbyteclk_ps);\n\n\t \n\tval = tc358768_ns_to_cnt(100 * 1000, hsbyteclk_ps) - 1;\n\tdev_dbg(dev, \"LINEINITCNT: %u\\n\", val);\n\ttc358768_write(priv, TC358768_LINEINITCNT, val);\n\n\t \n\tval = tc358768_ns_to_cnt(50, hsbyteclk_ps) - 1;\n\tlptxcnt = val;\n\tdev_dbg(dev, \"LPTXTIMECNT: %u\\n\", val);\n\ttc358768_write(priv, TC358768_LPTXTIMECNT, val);\n\n\t \n\tval = tc358768_ns_to_cnt(65, hsbyteclk_ps) - 1;\n\tdev_dbg(dev, \"TCLK_PREPARECNT %u\\n\", val);\n\t \n\tval2 = tc358768_ns_to_cnt(300 - tc358768_ps_to_ns(2 * ui_ps),\n\t\t\t\t  hsbyteclk_ps) - 2;\n\tdev_dbg(dev, \"TCLK_ZEROCNT %u\\n\", val2);\n\tval |= val2 << 8;\n\ttc358768_write(priv, TC358768_TCLK_HEADERCNT, val);\n\n\t \n\traw_val = tc358768_ns_to_cnt(60 + tc358768_ps_to_ns(2 * ui_ps), hsbyteclk_ps) - 5;\n\tval = clamp(raw_val, 0, 127);\n\tdev_dbg(dev, \"TCLK_TRAILCNT: %u\\n\", val);\n\ttc358768_write(priv, TC358768_TCLK_TRAILCNT, val);\n\n\t \n\tval = 50 + tc358768_ps_to_ns(4 * ui_ps);\n\tval = tc358768_ns_to_cnt(val, hsbyteclk_ps) - 1;\n\tdev_dbg(dev, \"THS_PREPARECNT %u\\n\", val);\n\t \n\traw_val = tc358768_ns_to_cnt(145 - tc358768_ps_to_ns(3 * ui_ps), hsbyteclk_ps) - 10;\n\tval2 = clamp(raw_val, 0, 127);\n\tdev_dbg(dev, \"THS_ZEROCNT %u\\n\", val2);\n\tval |= val2 << 8;\n\ttc358768_write(priv, TC358768_THS_HEADERCNT, val);\n\n\t \n\tval = tc358768_ns_to_cnt(1020000, hsbyteclk_ps);\n\tval = val / (lptxcnt + 1) - 1;\n\tdev_dbg(dev, \"TWAKEUP: %u\\n\", val);\n\ttc358768_write(priv, TC358768_TWAKEUP, val);\n\n\t \n\tval = tc358768_ns_to_cnt(60 + tc358768_ps_to_ns(52 * ui_ps),\n\t\t\t\t hsbyteclk_ps) - 3;\n\tdev_dbg(dev, \"TCLK_POSTCNT: %u\\n\", val);\n\ttc358768_write(priv, TC358768_TCLK_POSTCNT, val);\n\n\t \n\traw_val = tc358768_ns_to_cnt(60 + tc358768_ps_to_ns(18 * ui_ps),\n\t\t\t\t     hsbyteclk_ps) - 4;\n\tval = clamp(raw_val, 0, 15);\n\tdev_dbg(dev, \"THS_TRAILCNT: %u\\n\", val);\n\ttc358768_write(priv, TC358768_THS_TRAILCNT, val);\n\n\tval = BIT(0);\n\tfor (i = 0; i < dsi_dev->lanes; i++)\n\t\tval |= BIT(i + 1);\n\ttc358768_write(priv, TC358768_HSTXVREGEN, val);\n\n\ttc358768_write(priv, TC358768_TXOPTIONCNTRL,\n\t\t       (mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) ? 0 : BIT(0));\n\n\t \n\tval = tc358768_ps_to_ns((lptxcnt + 1) * hsbyteclk_ps * 4);\n\tval = tc358768_ns_to_cnt(val, hsbyteclk_ps) / 4 - 1;\n\tdev_dbg(dev, \"TXTAGOCNT: %u\\n\", val);\n\tval2 = tc358768_ns_to_cnt(tc358768_ps_to_ns((lptxcnt + 1) * hsbyteclk_ps),\n\t\t\t\t  hsbyteclk_ps) - 2;\n\tdev_dbg(dev, \"RXTASURECNT: %u\\n\", val2);\n\tval = val << 16 | val2;\n\ttc358768_write(priv, TC358768_BTACNTRL1, val);\n\n\t \n\ttc358768_write(priv, TC358768_STARTCNTRL, 1);\n\n\tif (dsi_dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) {\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_EVENT, 0);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_VACT, vm.vactive);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_VSW, vm.vsync_len);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_VBPR, vm.vback_porch);\n\n\t\t \n\t\tval = (u32)div_u64(vm.hsync_len *\n\t\t\t\t   (u64)hsbyteclk * priv->dsi_lanes,\n\t\t\t\t   vm.pixelclock);\n\t\ttc358768_write(priv, TC358768_DSI_HSW, val);\n\n\t\t \n\t\tval = (u32)div_u64(vm.hback_porch *\n\t\t\t\t   (u64)hsbyteclk * priv->dsi_lanes,\n\t\t\t\t   vm.pixelclock);\n\t\ttc358768_write(priv, TC358768_DSI_HBPR, val);\n\t} else {\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_EVENT, 1);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_VACT, vm.vactive);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_VSW,\n\t\t\t       vm.vsync_len + vm.vback_porch);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_VBPR, 0);\n\n\t\t \n\t\tval = (u32)div_u64((vm.hsync_len + vm.hback_porch) *\n\t\t\t\t   (u64)hsbyteclk * priv->dsi_lanes,\n\t\t\t\t   vm.pixelclock);\n\t\ttc358768_write(priv, TC358768_DSI_HSW, val);\n\n\t\t \n\t\ttc358768_write(priv, TC358768_DSI_HBPR, 0);\n\t}\n\n\t \n\ttc358768_write(priv, TC358768_DSI_HACT, hact);\n\n\t \n\ttc358768_update_bits(priv, TC358768_CONFCTL, BIT(5),\n\t\t\t     (mode->flags & DRM_MODE_FLAG_PVSYNC) ? BIT(5) : 0);\n\n\t \n\ttc358768_update_bits(priv, TC358768_PP_MISC, BIT(0),\n\t\t\t     (mode->flags & DRM_MODE_FLAG_PHSYNC) ? BIT(0) : 0);\n\n\t \n\ttc358768_write(priv, TC358768_DSI_START, 0x1);\n\n\t \n\tval = TC358768_DSI_CONFW_MODE_CLR | TC358768_DSI_CONFW_ADDR_DSI_CONTROL;\n\tval |= TC358768_DSI_CONTROL_TXMD | TC358768_DSI_CONTROL_HSCKMD |\n\t       0x3 << 1 | TC358768_DSI_CONTROL_EOTDIS;\n\ttc358768_write(priv, TC358768_DSI_CONFW, val);\n\n\tval = TC358768_DSI_CONFW_MODE_SET | TC358768_DSI_CONFW_ADDR_DSI_CONTROL;\n\tval |= (dsi_dev->lanes - 1) << 1;\n\n\tval |= TC358768_DSI_CONTROL_TXMD;\n\n\tif (!(mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS))\n\t\tval |= TC358768_DSI_CONTROL_HSCKMD;\n\n\tif (dsi_dev->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET)\n\t\tval |= TC358768_DSI_CONTROL_EOTDIS;\n\n\ttc358768_write(priv, TC358768_DSI_CONFW, val);\n\n\tval = TC358768_DSI_CONFW_MODE_CLR | TC358768_DSI_CONFW_ADDR_DSI_CONTROL;\n\tval |= TC358768_DSI_CONTROL_DIS_MODE;  \n\ttc358768_write(priv, TC358768_DSI_CONFW, val);\n\n\tret = tc358768_clear_error(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"Bridge pre_enable failed: %d\\n\", ret);\n\t\ttc358768_bridge_disable(bridge);\n\t\ttc358768_bridge_post_disable(bridge);\n\t}\n}\n\nstatic void tc358768_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\tint ret;\n\n\tif (!priv->enabled) {\n\t\tdev_err(priv->dev, \"Bridge is not enabled\\n\");\n\t\treturn;\n\t}\n\n\t \n\ttc358768_update_bits(priv, TC358768_PP_MISC, 0x3 << 14, 0);\n\n\t \n\ttc358768_update_bits(priv, TC358768_CONFCTL, BIT(6), BIT(6));\n\n\tret = tc358768_clear_error(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Bridge enable failed: %d\\n\", ret);\n\t\ttc358768_bridge_disable(bridge);\n\t\ttc358768_bridge_post_disable(bridge);\n\t}\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\ntc358768_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_bridge_state *bridge_state,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state,\n\t\t\t\t   u32 output_fmt,\n\t\t\t\t   unsigned int *num_input_fmts)\n{\n\tstruct tc358768_priv *priv = bridge_to_tc358768(bridge);\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tswitch (priv->pd_lines) {\n\tcase 16:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB565_1X16;\n\t\tbreak;\n\tcase 18:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB666_1X18;\n\t\tbreak;\n\tdefault:\n\tcase 24:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\t}\n\n\t*num_input_fmts = MAX_INPUT_SEL_FORMATS;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs tc358768_bridge_funcs = {\n\t.attach = tc358768_bridge_attach,\n\t.mode_valid = tc358768_bridge_mode_valid,\n\t.pre_enable = tc358768_bridge_pre_enable,\n\t.enable = tc358768_bridge_enable,\n\t.disable = tc358768_bridge_disable,\n\t.post_disable = tc358768_bridge_post_disable,\n\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_get_input_bus_fmts = tc358768_atomic_get_input_bus_fmts,\n};\n\nstatic const struct drm_bridge_timings default_tc358768_timings = {\n\t.input_bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE\n\t\t | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE\n\t\t | DRM_BUS_FLAG_DE_HIGH,\n};\n\nstatic bool tc358768_is_reserved_reg(unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x114 ... 0x13f:\n\tcase 0x200:\n\tcase 0x20c:\n\tcase 0x400 ... 0x408:\n\tcase 0x41c ... 0x42f:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tc358768_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tif (tc358768_is_reserved_reg(reg))\n\t\treturn false;\n\n\tswitch (reg) {\n\tcase TC358768_CHIPID:\n\tcase TC358768_FIFOSTATUS:\n\tcase TC358768_DSITXSTATUS ... (TC358768_DSITXSTATUS + 2):\n\tcase TC358768_DSI_CONTROL ... (TC358768_DSI_INT_ENA + 2):\n\tcase TC358768_DSICMD_RDFIFO ... (TC358768_DSI_ERR_HALT + 2):\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool tc358768_readable_reg(struct device *dev, unsigned int reg)\n{\n\tif (tc358768_is_reserved_reg(reg))\n\t\treturn false;\n\n\tswitch (reg) {\n\tcase TC358768_STARTCNTRL:\n\tcase TC358768_DSI_CONFW ... (TC358768_DSI_CONFW + 2):\n\tcase TC358768_DSI_INT_CLR ... (TC358768_DSI_INT_CLR + 2):\n\tcase TC358768_DSI_START ... (TC358768_DSI_START + 2):\n\tcase TC358768_DBG_DATA:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config tc358768_regmap_config = {\n\t.name = \"tc358768\",\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.max_register = TC358768_DSI_HACT,\n\t.cache_type = REGCACHE_NONE,\n\t.writeable_reg = tc358768_writeable_reg,\n\t.readable_reg = tc358768_readable_reg,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic const struct i2c_device_id tc358768_i2c_ids[] = {\n\t{ \"tc358768\", 0 },\n\t{ \"tc358778\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tc358768_i2c_ids);\n\nstatic const struct of_device_id tc358768_of_ids[] = {\n\t{ .compatible = \"toshiba,tc358768\", },\n\t{ .compatible = \"toshiba,tc358778\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tc358768_of_ids);\n\nstatic int tc358768_get_regulators(struct tc358768_priv *priv)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->supplies); ++i)\n\t\tpriv->supplies[i].supply = tc358768_supplies[i];\n\n\tret = devm_regulator_bulk_get(priv->dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"failed to get regulators: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tc358768_i2c_probe(struct i2c_client *client)\n{\n\tstruct tc358768_priv *priv;\n\tstruct device *dev = &client->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\tpriv->dev = dev;\n\n\tret = tc358768_get_regulators(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->refclk = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(priv->refclk))\n\t\treturn PTR_ERR(priv->refclk);\n\n\t \n\tpriv->reset_gpio  = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset_gpio))\n\t\treturn PTR_ERR(priv->reset_gpio);\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &tc358768_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(dev, \"Failed to init regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->dsi_host.dev = dev;\n\tpriv->dsi_host.ops = &tc358768_dsi_host_ops;\n\n\tpriv->bridge.funcs = &tc358768_bridge_funcs;\n\tpriv->bridge.timings = &default_tc358768_timings;\n\tpriv->bridge.of_node = np;\n\n\ti2c_set_clientdata(client, priv);\n\n\treturn mipi_dsi_host_register(&priv->dsi_host);\n}\n\nstatic void tc358768_i2c_remove(struct i2c_client *client)\n{\n\tstruct tc358768_priv *priv = i2c_get_clientdata(client);\n\n\tmipi_dsi_host_unregister(&priv->dsi_host);\n}\n\nstatic struct i2c_driver tc358768_driver = {\n\t.driver = {\n\t\t.name = \"tc358768\",\n\t\t.of_match_table = tc358768_of_ids,\n\t},\n\t.id_table = tc358768_i2c_ids,\n\t.probe = tc358768_i2c_probe,\n\t.remove\t= tc358768_i2c_remove,\n};\nmodule_i2c_driver(tc358768_driver);\n\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_DESCRIPTION(\"TC358768AXBG/TC358778XBG DSI bridge\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}