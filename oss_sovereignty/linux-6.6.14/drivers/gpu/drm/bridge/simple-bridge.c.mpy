{
  "module_name": "simple-bridge.c",
  "hash_id": "d99e97fb3cb0562ded1e8ccd2baf9ba7a220354e8b5bbc29a93bffebf9283c54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/simple-bridge.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\nstruct simple_bridge_info {\n\tconst struct drm_bridge_timings *timings;\n\tunsigned int connector_type;\n};\n\nstruct simple_bridge {\n\tstruct drm_bridge\tbridge;\n\tstruct drm_connector\tconnector;\n\n\tconst struct simple_bridge_info *info;\n\n\tstruct drm_bridge\t*next_bridge;\n\tstruct regulator\t*vdd;\n\tstruct gpio_desc\t*enable;\n};\n\nstatic inline struct simple_bridge *\ndrm_bridge_to_simple_bridge(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct simple_bridge, bridge);\n}\n\nstatic inline struct simple_bridge *\ndrm_connector_to_simple_bridge(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct simple_bridge, connector);\n}\n\nstatic int simple_bridge_get_modes(struct drm_connector *connector)\n{\n\tstruct simple_bridge *sbridge = drm_connector_to_simple_bridge(connector);\n\tstruct edid *edid;\n\tint ret;\n\n\tif (sbridge->next_bridge->ops & DRM_BRIDGE_OP_EDID) {\n\t\tedid = drm_bridge_get_edid(sbridge->next_bridge, connector);\n\t\tif (!edid)\n\t\t\tDRM_INFO(\"EDID read failed. Fallback to standard modes\\n\");\n\t} else {\n\t\tedid = NULL;\n\t}\n\n\tif (!edid) {\n\t\t \n\t\tret = drm_add_modes_noedid(connector, 1920, 1200);\n\t\tdrm_set_preferred_mode(connector, 1024, 768);\n\t\treturn ret;\n\t}\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tret = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn ret;\n}\n\nstatic const struct drm_connector_helper_funcs simple_bridge_con_helper_funcs = {\n\t.get_modes\t= simple_bridge_get_modes,\n};\n\nstatic enum drm_connector_status\nsimple_bridge_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct simple_bridge *sbridge = drm_connector_to_simple_bridge(connector);\n\n\treturn drm_bridge_detect(sbridge->next_bridge);\n}\n\nstatic const struct drm_connector_funcs simple_bridge_con_funcs = {\n\t.detect\t\t\t= simple_bridge_connector_detect,\n\t.fill_modes\t\t= drm_helper_probe_single_connector_modes,\n\t.destroy\t\t= drm_connector_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int simple_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct simple_bridge *sbridge = drm_bridge_to_simple_bridge(bridge);\n\tint ret;\n\n\tret = drm_bridge_attach(bridge->encoder, sbridge->next_bridge, bridge,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdrm_connector_helper_add(&sbridge->connector,\n\t\t\t\t &simple_bridge_con_helper_funcs);\n\tret = drm_connector_init_with_ddc(bridge->dev, &sbridge->connector,\n\t\t\t\t\t  &simple_bridge_con_funcs,\n\t\t\t\t\t  sbridge->info->connector_type,\n\t\t\t\t\t  sbridge->next_bridge->ddc);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_connector_attach_encoder(&sbridge->connector, bridge->encoder);\n\n\treturn 0;\n}\n\nstatic void simple_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct simple_bridge *sbridge = drm_bridge_to_simple_bridge(bridge);\n\tint ret;\n\n\tif (sbridge->vdd) {\n\t\tret = regulator_enable(sbridge->vdd);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"Failed to enable vdd regulator: %d\\n\", ret);\n\t}\n\n\tgpiod_set_value_cansleep(sbridge->enable, 1);\n}\n\nstatic void simple_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct simple_bridge *sbridge = drm_bridge_to_simple_bridge(bridge);\n\n\tgpiod_set_value_cansleep(sbridge->enable, 0);\n\n\tif (sbridge->vdd)\n\t\tregulator_disable(sbridge->vdd);\n}\n\nstatic const struct drm_bridge_funcs simple_bridge_bridge_funcs = {\n\t.attach\t\t= simple_bridge_attach,\n\t.enable\t\t= simple_bridge_enable,\n\t.disable\t= simple_bridge_disable,\n};\n\nstatic int simple_bridge_probe(struct platform_device *pdev)\n{\n\tstruct simple_bridge *sbridge;\n\tstruct device_node *remote;\n\n\tsbridge = devm_kzalloc(&pdev->dev, sizeof(*sbridge), GFP_KERNEL);\n\tif (!sbridge)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, sbridge);\n\n\tsbridge->info = of_device_get_match_data(&pdev->dev);\n\n\t \n\tremote = of_graph_get_remote_node(pdev->dev.of_node, 1, -1);\n\tif (!remote)\n\t\treturn -EINVAL;\n\n\tsbridge->next_bridge = of_drm_find_bridge(remote);\n\tof_node_put(remote);\n\n\tif (!sbridge->next_bridge) {\n\t\tdev_dbg(&pdev->dev, \"Next bridge not found, deferring probe\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tsbridge->vdd = devm_regulator_get_optional(&pdev->dev, \"vdd\");\n\tif (IS_ERR(sbridge->vdd)) {\n\t\tint ret = PTR_ERR(sbridge->vdd);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tsbridge->vdd = NULL;\n\t\tdev_dbg(&pdev->dev, \"No vdd regulator found: %d\\n\", ret);\n\t}\n\n\tsbridge->enable = devm_gpiod_get_optional(&pdev->dev, \"enable\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(sbridge->enable))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sbridge->enable),\n\t\t\t\t     \"Unable to retrieve enable GPIO\\n\");\n\n\t \n\tsbridge->bridge.funcs = &simple_bridge_bridge_funcs;\n\tsbridge->bridge.of_node = pdev->dev.of_node;\n\tsbridge->bridge.timings = sbridge->info->timings;\n\n\tdrm_bridge_add(&sbridge->bridge);\n\n\treturn 0;\n}\n\nstatic void simple_bridge_remove(struct platform_device *pdev)\n{\n\tstruct simple_bridge *sbridge = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&sbridge->bridge);\n}\n\n \nstatic const struct drm_bridge_timings default_bridge_timings = {\n\t \n\t.input_bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE,\n\t.setup_time_ps = 500,\n\t.hold_time_ps = 1500,\n};\n\n \nstatic const struct drm_bridge_timings ti_ths8134_bridge_timings = {\n\t \n\t.input_bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE,\n\t \n\t.setup_time_ps = 3000,\n\t \n\t.hold_time_ps = 0,\n};\n\n \nstatic const struct drm_bridge_timings ti_ths8135_bridge_timings = {\n\t \n\t.input_bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE,\n\t \n\t.setup_time_ps = 2000,\n\t.hold_time_ps = 500,\n};\n\nstatic const struct of_device_id simple_bridge_match[] = {\n\t{\n\t\t.compatible = \"dumb-vga-dac\",\n\t\t.data = &(const struct simple_bridge_info) {\n\t\t\t.connector_type = DRM_MODE_CONNECTOR_VGA,\n\t\t},\n\t}, {\n\t\t.compatible = \"adi,adv7123\",\n\t\t.data = &(const struct simple_bridge_info) {\n\t\t\t.timings = &default_bridge_timings,\n\t\t\t.connector_type = DRM_MODE_CONNECTOR_VGA,\n\t\t},\n\t}, {\n\t\t.compatible = \"ti,opa362\",\n\t\t.data = &(const struct simple_bridge_info) {\n\t\t\t.connector_type = DRM_MODE_CONNECTOR_Composite,\n\t\t},\n\t}, {\n\t\t.compatible = \"ti,ths8135\",\n\t\t.data = &(const struct simple_bridge_info) {\n\t\t\t.timings = &ti_ths8135_bridge_timings,\n\t\t\t.connector_type = DRM_MODE_CONNECTOR_VGA,\n\t\t},\n\t}, {\n\t\t.compatible = \"ti,ths8134\",\n\t\t.data = &(const struct simple_bridge_info) {\n\t\t\t.timings = &ti_ths8134_bridge_timings,\n\t\t\t.connector_type = DRM_MODE_CONNECTOR_VGA,\n\t\t},\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, simple_bridge_match);\n\nstatic struct platform_driver simple_bridge_driver = {\n\t.probe\t= simple_bridge_probe,\n\t.remove_new = simple_bridge_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"simple-bridge\",\n\t\t.of_match_table\t= simple_bridge_match,\n\t},\n};\nmodule_platform_driver(simple_bridge_driver);\n\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Simple DRM bridge driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}