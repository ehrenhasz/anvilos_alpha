{
  "module_name": "sil-sii8620.c",
  "hash_id": "70340e47b4be199f4725391d7909448b74010b5cf222c2d69d905c2730125f0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/sil-sii8620.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n\n#include <drm/bridge/mhl.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/extcon.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <media/rc-core.h>\n\n#include \"sil-sii8620.h\"\n\n#define SII8620_BURST_BUF_LEN 288\n#define VAL_RX_HDMI_CTRL2_DEFVAL VAL_RX_HDMI_CTRL2_IDLE_CNT(3)\n\n#define MHL1_MAX_PCLK 75000\n#define MHL1_MAX_PCLK_PP_MODE 150000\n#define MHL3_MAX_PCLK 200000\n#define MHL3_MAX_PCLK_PP_MODE 300000\n\nenum sii8620_mode {\n\tCM_DISCONNECTED,\n\tCM_DISCOVERY,\n\tCM_MHL1,\n\tCM_MHL3,\n\tCM_ECBUS_S\n};\n\nenum sii8620_sink_type {\n\tSINK_NONE,\n\tSINK_HDMI,\n\tSINK_DVI\n};\n\nenum sii8620_mt_state {\n\tMT_STATE_READY,\n\tMT_STATE_BUSY,\n\tMT_STATE_DONE\n};\n\nstruct sii8620 {\n\tstruct drm_bridge bridge;\n\tstruct device *dev;\n\tstruct rc_dev *rc_dev;\n\tstruct clk *clk_xtal;\n\tstruct gpio_desc *gpio_reset;\n\tstruct gpio_desc *gpio_int;\n\tstruct regulator_bulk_data supplies[2];\n\tstruct mutex lock;  \n\tint error;\n\tunsigned int use_packed_pixel:1;\n\tenum sii8620_mode mode;\n\tenum sii8620_sink_type sink_type;\n\tu8 cbus_status;\n\tu8 stat[MHL_DST_SIZE];\n\tu8 xstat[MHL_XDS_SIZE];\n\tu8 devcap[MHL_DCAP_SIZE];\n\tu8 xdevcap[MHL_XDC_SIZE];\n\tbool feature_complete;\n\tbool devcap_read;\n\tbool sink_detected;\n\tstruct edid *edid;\n\tunsigned int gen2_write_burst:1;\n\tenum sii8620_mt_state mt_state;\n\tstruct extcon_dev *extcon;\n\tstruct notifier_block extcon_nb;\n\tstruct work_struct extcon_wq;\n\tint cable_state;\n\tstruct list_head mt_queue;\n\tstruct {\n\t\tint r_size;\n\t\tint r_count;\n\t\tint rx_ack;\n\t\tint rx_count;\n\t\tu8 rx_buf[32];\n\t\tint tx_count;\n\t\tu8 tx_buf[32];\n\t} burst;\n};\n\nstruct sii8620_mt_msg;\n\ntypedef void (*sii8620_mt_msg_cb)(struct sii8620 *ctx,\n\t\t\t\t  struct sii8620_mt_msg *msg);\n\ntypedef void (*sii8620_cb)(struct sii8620 *ctx, int ret);\n\nstruct sii8620_mt_msg {\n\tstruct list_head node;\n\tu8 reg[4];\n\tu8 ret;\n\tsii8620_mt_msg_cb send;\n\tsii8620_mt_msg_cb recv;\n\tsii8620_cb continuation;\n};\n\nstatic const u8 sii8620_i2c_page[] = {\n\t0x39,  \n\t0x3d,  \n\t0x49,  \n\t0x4d,  \n\t0x5d,  \n\t0x64,  \n\t0x59,  \n\t0x61,  \n};\n\nstatic void sii8620_fetch_edid(struct sii8620 *ctx);\nstatic void sii8620_set_upstream_edid(struct sii8620 *ctx);\nstatic void sii8620_enable_hpd(struct sii8620 *ctx);\nstatic void sii8620_mhl_disconnected(struct sii8620 *ctx);\nstatic void sii8620_disconnect(struct sii8620 *ctx);\n\nstatic int sii8620_clear_error(struct sii8620 *ctx)\n{\n\tint ret = ctx->error;\n\n\tctx->error = 0;\n\treturn ret;\n}\n\nstatic void sii8620_read_buf(struct sii8620 *ctx, u16 addr, u8 *buf, int len)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 data = addr;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr = sii8620_i2c_page[addr >> 8],\n\t\t\t.flags = client->flags,\n\t\t\t.len = 1,\n\t\t\t.buf = &data\n\t\t},\n\t\t{\n\t\t\t.addr = sii8620_i2c_page[addr >> 8],\n\t\t\t.flags = client->flags | I2C_M_RD,\n\t\t\t.len = len,\n\t\t\t.buf = buf\n\t\t},\n\t};\n\tint ret;\n\n\tif (ctx->error)\n\t\treturn;\n\n\tret = i2c_transfer(client->adapter, msg, 2);\n\tdev_dbg(dev, \"read at %04x: %*ph, %d\\n\", addr, len, buf, ret);\n\n\tif (ret != 2) {\n\t\tdev_err(dev, \"Read at %#06x of %d bytes failed with code %d.\\n\",\n\t\t\taddr, len, ret);\n\t\tctx->error = ret < 0 ? ret : -EIO;\n\t}\n}\n\nstatic u8 sii8620_readb(struct sii8620 *ctx, u16 addr)\n{\n\tu8 ret = 0;\n\n\tsii8620_read_buf(ctx, addr, &ret, 1);\n\treturn ret;\n}\n\nstatic void sii8620_write_buf(struct sii8620 *ctx, u16 addr, const u8 *buf,\n\t\t\t      int len)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tu8 data[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = sii8620_i2c_page[addr >> 8],\n\t\t.flags = client->flags,\n\t\t.len = len + 1,\n\t};\n\tint ret;\n\n\tif (ctx->error)\n\t\treturn;\n\n\tif (len > 1) {\n\t\tmsg.buf = kmalloc(len + 1, GFP_KERNEL);\n\t\tif (!msg.buf) {\n\t\t\tctx->error = -ENOMEM;\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(msg.buf + 1, buf, len);\n\t} else {\n\t\tmsg.buf = data;\n\t\tmsg.buf[1] = *buf;\n\t}\n\n\tmsg.buf[0] = addr;\n\n\tret = i2c_transfer(client->adapter, &msg, 1);\n\tdev_dbg(dev, \"write at %04x: %*ph, %d\\n\", addr, len, buf, ret);\n\n\tif (ret != 1) {\n\t\tdev_err(dev, \"Write at %#06x of %*ph failed with code %d.\\n\",\n\t\t\taddr, len, buf, ret);\n\t\tctx->error = ret ?: -EIO;\n\t}\n\n\tif (len > 1)\n\t\tkfree(msg.buf);\n}\n\n#define sii8620_write(ctx, addr, arr...) \\\n({\\\n\tu8 d[] = { arr }; \\\n\tsii8620_write_buf(ctx, addr, d, ARRAY_SIZE(d)); \\\n})\n\nstatic void __sii8620_write_seq(struct sii8620 *ctx, const u16 *seq, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i += 2)\n\t\tsii8620_write(ctx, seq[i], seq[i + 1]);\n}\n\n#define sii8620_write_seq(ctx, seq...) \\\n({\\\n\tconst u16 d[] = { seq }; \\\n\t__sii8620_write_seq(ctx, d, ARRAY_SIZE(d)); \\\n})\n\n#define sii8620_write_seq_static(ctx, seq...) \\\n({\\\n\tstatic const u16 d[] = { seq }; \\\n\t__sii8620_write_seq(ctx, d, ARRAY_SIZE(d)); \\\n})\n\nstatic void sii8620_setbits(struct sii8620 *ctx, u16 addr, u8 mask, u8 val)\n{\n\tval = (val & mask) | (sii8620_readb(ctx, addr) & ~mask);\n\tsii8620_write(ctx, addr, val);\n}\n\nstatic inline bool sii8620_is_mhl3(struct sii8620 *ctx)\n{\n\treturn ctx->mode >= CM_MHL3;\n}\n\nstatic void sii8620_mt_cleanup(struct sii8620 *ctx)\n{\n\tstruct sii8620_mt_msg *msg, *n;\n\n\tlist_for_each_entry_safe(msg, n, &ctx->mt_queue, node) {\n\t\tlist_del(&msg->node);\n\t\tkfree(msg);\n\t}\n\tctx->mt_state = MT_STATE_READY;\n}\n\nstatic void sii8620_mt_work(struct sii8620 *ctx)\n{\n\tstruct sii8620_mt_msg *msg;\n\n\tif (ctx->error)\n\t\treturn;\n\tif (ctx->mt_state == MT_STATE_BUSY || list_empty(&ctx->mt_queue))\n\t\treturn;\n\n\tif (ctx->mt_state == MT_STATE_DONE) {\n\t\tctx->mt_state = MT_STATE_READY;\n\t\tmsg = list_first_entry(&ctx->mt_queue, struct sii8620_mt_msg,\n\t\t\t\t       node);\n\t\tlist_del(&msg->node);\n\t\tif (msg->recv)\n\t\t\tmsg->recv(ctx, msg);\n\t\tif (msg->continuation)\n\t\t\tmsg->continuation(ctx, msg->ret);\n\t\tkfree(msg);\n\t}\n\n\tif (ctx->mt_state != MT_STATE_READY || list_empty(&ctx->mt_queue))\n\t\treturn;\n\n\tctx->mt_state = MT_STATE_BUSY;\n\tmsg = list_first_entry(&ctx->mt_queue, struct sii8620_mt_msg, node);\n\tif (msg->send)\n\t\tmsg->send(ctx, msg);\n}\n\nstatic void sii8620_enable_gen2_write_burst(struct sii8620 *ctx)\n{\n\tu8 ctrl = BIT_MDT_RCV_CTRL_MDT_RCV_EN;\n\n\tif (ctx->gen2_write_burst)\n\t\treturn;\n\n\tif (ctx->mode >= CM_MHL1)\n\t\tctrl |= BIT_MDT_RCV_CTRL_MDT_DELAY_RCV_EN;\n\n\tsii8620_write_seq(ctx,\n\t\tREG_MDT_RCV_TIMEOUT, 100,\n\t\tREG_MDT_RCV_CTRL, ctrl\n\t);\n\tctx->gen2_write_burst = 1;\n}\n\nstatic void sii8620_disable_gen2_write_burst(struct sii8620 *ctx)\n{\n\tif (!ctx->gen2_write_burst)\n\t\treturn;\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_MDT_XMIT_CTRL, 0,\n\t\tREG_MDT_RCV_CTRL, 0\n\t);\n\tctx->gen2_write_burst = 0;\n}\n\nstatic void sii8620_start_gen2_write_burst(struct sii8620 *ctx)\n{\n\tsii8620_write_seq_static(ctx,\n\t\tREG_MDT_INT_1_MASK, BIT_MDT_RCV_TIMEOUT\n\t\t\t| BIT_MDT_RCV_SM_ABORT_PKT_RCVD | BIT_MDT_RCV_SM_ERROR\n\t\t\t| BIT_MDT_XMIT_TIMEOUT | BIT_MDT_XMIT_SM_ABORT_PKT_RCVD\n\t\t\t| BIT_MDT_XMIT_SM_ERROR,\n\t\tREG_MDT_INT_0_MASK, BIT_MDT_XFIFO_EMPTY\n\t\t\t| BIT_MDT_IDLE_AFTER_HAWB_DISABLE\n\t\t\t| BIT_MDT_RFIFO_DATA_RDY\n\t);\n\tsii8620_enable_gen2_write_burst(ctx);\n}\n\nstatic void sii8620_mt_msc_cmd_send(struct sii8620 *ctx,\n\t\t\t\t    struct sii8620_mt_msg *msg)\n{\n\tif (msg->reg[0] == MHL_SET_INT &&\n\t    msg->reg[1] == MHL_INT_REG(RCHANGE) &&\n\t    msg->reg[2] == MHL_INT_RC_FEAT_REQ)\n\t\tsii8620_enable_gen2_write_burst(ctx);\n\telse\n\t\tsii8620_disable_gen2_write_burst(ctx);\n\n\tswitch (msg->reg[0]) {\n\tcase MHL_WRITE_STAT:\n\tcase MHL_SET_INT:\n\t\tsii8620_write_buf(ctx, REG_MSC_CMD_OR_OFFSET, msg->reg + 1, 2);\n\t\tsii8620_write(ctx, REG_MSC_COMMAND_START,\n\t\t\t      BIT_MSC_COMMAND_START_WRITE_STAT);\n\t\tbreak;\n\tcase MHL_MSC_MSG:\n\t\tsii8620_write_buf(ctx, REG_MSC_CMD_OR_OFFSET, msg->reg, 3);\n\t\tsii8620_write(ctx, REG_MSC_COMMAND_START,\n\t\t\t      BIT_MSC_COMMAND_START_MSC_MSG);\n\t\tbreak;\n\tcase MHL_READ_DEVCAP_REG:\n\tcase MHL_READ_XDEVCAP_REG:\n\t\tsii8620_write(ctx, REG_MSC_CMD_OR_OFFSET, msg->reg[1]);\n\t\tsii8620_write(ctx, REG_MSC_COMMAND_START,\n\t\t\t      BIT_MSC_COMMAND_START_READ_DEVCAP);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctx->dev, \"%s: command %#x not supported\\n\", __func__,\n\t\t\tmsg->reg[0]);\n\t}\n}\n\nstatic struct sii8620_mt_msg *sii8620_mt_msg_new(struct sii8620 *ctx)\n{\n\tstruct sii8620_mt_msg *msg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\n\tif (!msg)\n\t\tctx->error = -ENOMEM;\n\telse\n\t\tlist_add_tail(&msg->node, &ctx->mt_queue);\n\n\treturn msg;\n}\n\nstatic void sii8620_mt_set_cont(struct sii8620 *ctx, sii8620_cb cont)\n{\n\tstruct sii8620_mt_msg *msg;\n\n\tif (ctx->error)\n\t\treturn;\n\n\tif (list_empty(&ctx->mt_queue)) {\n\t\tctx->error = -EINVAL;\n\t\treturn;\n\t}\n\tmsg = list_last_entry(&ctx->mt_queue, struct sii8620_mt_msg, node);\n\tmsg->continuation = cont;\n}\n\nstatic void sii8620_mt_msc_cmd(struct sii8620 *ctx, u8 cmd, u8 arg1, u8 arg2)\n{\n\tstruct sii8620_mt_msg *msg = sii8620_mt_msg_new(ctx);\n\n\tif (!msg)\n\t\treturn;\n\n\tmsg->reg[0] = cmd;\n\tmsg->reg[1] = arg1;\n\tmsg->reg[2] = arg2;\n\tmsg->send = sii8620_mt_msc_cmd_send;\n}\n\nstatic void sii8620_mt_write_stat(struct sii8620 *ctx, u8 reg, u8 val)\n{\n\tsii8620_mt_msc_cmd(ctx, MHL_WRITE_STAT, reg, val);\n}\n\nstatic inline void sii8620_mt_set_int(struct sii8620 *ctx, u8 irq, u8 mask)\n{\n\tsii8620_mt_msc_cmd(ctx, MHL_SET_INT, irq, mask);\n}\n\nstatic void sii8620_mt_msc_msg(struct sii8620 *ctx, u8 cmd, u8 data)\n{\n\tsii8620_mt_msc_cmd(ctx, MHL_MSC_MSG, cmd, data);\n}\n\nstatic void sii8620_mt_rap(struct sii8620 *ctx, u8 code)\n{\n\tsii8620_mt_msc_msg(ctx, MHL_MSC_MSG_RAP, code);\n}\n\nstatic void sii8620_mt_rcpk(struct sii8620 *ctx, u8 code)\n{\n\tsii8620_mt_msc_msg(ctx, MHL_MSC_MSG_RCPK, code);\n}\n\nstatic void sii8620_mt_rcpe(struct sii8620 *ctx, u8 code)\n{\n\tsii8620_mt_msc_msg(ctx, MHL_MSC_MSG_RCPE, code);\n}\n\nstatic void sii8620_mt_read_devcap_send(struct sii8620 *ctx,\n\t\t\t\t\tstruct sii8620_mt_msg *msg)\n{\n\tu8 ctrl = BIT_EDID_CTRL_DEVCAP_SELECT_DEVCAP\n\t\t\t| BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\n\t\t\t| BIT_EDID_CTRL_EDID_MODE_EN;\n\n\tif (msg->reg[0] == MHL_READ_XDEVCAP)\n\t\tctrl |= BIT_EDID_CTRL_XDEVCAP_EN;\n\n\tsii8620_write_seq(ctx,\n\t\tREG_INTR9_MASK, BIT_INTR9_DEVCAP_DONE,\n\t\tREG_EDID_CTRL, ctrl,\n\t\tREG_TPI_CBUS_START, BIT_TPI_CBUS_START_GET_DEVCAP_START\n\t);\n}\n\n \nstatic void sii8620_update_array(u8 *dst, u8 *src, int count)\n{\n\twhile (--count >= 0) {\n\t\t*src ^= *dst;\n\t\t*dst++ ^= *src++;\n\t}\n}\n\nstatic void sii8620_identify_sink(struct sii8620 *ctx)\n{\n\tstatic const char * const sink_str[] = {\n\t\t[SINK_NONE] = \"NONE\",\n\t\t[SINK_HDMI] = \"HDMI\",\n\t\t[SINK_DVI] = \"DVI\"\n\t};\n\n\tchar sink_name[20];\n\tstruct device *dev = ctx->dev;\n\n\tif (!ctx->sink_detected || !ctx->devcap_read)\n\t\treturn;\n\n\tsii8620_fetch_edid(ctx);\n\tif (!ctx->edid) {\n\t\tdev_err(ctx->dev, \"Cannot fetch EDID\\n\");\n\t\tsii8620_mhl_disconnected(ctx);\n\t\treturn;\n\t}\n\tsii8620_set_upstream_edid(ctx);\n\n\tif (drm_detect_hdmi_monitor(ctx->edid))\n\t\tctx->sink_type = SINK_HDMI;\n\telse\n\t\tctx->sink_type = SINK_DVI;\n\n\tdrm_edid_get_monitor_name(ctx->edid, sink_name, ARRAY_SIZE(sink_name));\n\n\tdev_info(dev, \"detected sink(type: %s): %s\\n\",\n\t\t sink_str[ctx->sink_type], sink_name);\n}\n\nstatic void sii8620_mr_devcap(struct sii8620 *ctx)\n{\n\tu8 dcap[MHL_DCAP_SIZE];\n\tstruct device *dev = ctx->dev;\n\n\tsii8620_read_buf(ctx, REG_EDID_FIFO_RD_DATA, dcap, MHL_DCAP_SIZE);\n\tif (ctx->error < 0)\n\t\treturn;\n\n\tdev_info(dev, \"detected dongle MHL %d.%d, ChipID %02x%02x:%02x%02x\\n\",\n\t\t dcap[MHL_DCAP_MHL_VERSION] / 16,\n\t\t dcap[MHL_DCAP_MHL_VERSION] % 16,\n\t\t dcap[MHL_DCAP_ADOPTER_ID_H], dcap[MHL_DCAP_ADOPTER_ID_L],\n\t\t dcap[MHL_DCAP_DEVICE_ID_H], dcap[MHL_DCAP_DEVICE_ID_L]);\n\tsii8620_update_array(ctx->devcap, dcap, MHL_DCAP_SIZE);\n\tctx->devcap_read = true;\n\tsii8620_identify_sink(ctx);\n}\n\nstatic void sii8620_mr_xdevcap(struct sii8620 *ctx)\n{\n\tsii8620_read_buf(ctx, REG_EDID_FIFO_RD_DATA, ctx->xdevcap,\n\t\t\t MHL_XDC_SIZE);\n}\n\nstatic void sii8620_mt_read_devcap_recv(struct sii8620 *ctx,\n\t\t\t\t\tstruct sii8620_mt_msg *msg)\n{\n\tu8 ctrl = BIT_EDID_CTRL_DEVCAP_SELECT_DEVCAP\n\t\t| BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\n\t\t| BIT_EDID_CTRL_EDID_MODE_EN;\n\n\tif (msg->reg[0] == MHL_READ_XDEVCAP)\n\t\tctrl |= BIT_EDID_CTRL_XDEVCAP_EN;\n\n\tsii8620_write_seq(ctx,\n\t\tREG_INTR9_MASK, BIT_INTR9_DEVCAP_DONE | BIT_INTR9_EDID_DONE\n\t\t\t| BIT_INTR9_EDID_ERROR,\n\t\tREG_EDID_CTRL, ctrl,\n\t\tREG_EDID_FIFO_ADDR, 0\n\t);\n\n\tif (msg->reg[0] == MHL_READ_XDEVCAP)\n\t\tsii8620_mr_xdevcap(ctx);\n\telse\n\t\tsii8620_mr_devcap(ctx);\n}\n\nstatic void sii8620_mt_read_devcap(struct sii8620 *ctx, bool xdevcap)\n{\n\tstruct sii8620_mt_msg *msg = sii8620_mt_msg_new(ctx);\n\n\tif (!msg)\n\t\treturn;\n\n\tmsg->reg[0] = xdevcap ? MHL_READ_XDEVCAP : MHL_READ_DEVCAP;\n\tmsg->send = sii8620_mt_read_devcap_send;\n\tmsg->recv = sii8620_mt_read_devcap_recv;\n}\n\nstatic void sii8620_mt_read_devcap_reg_recv(struct sii8620 *ctx,\n\t\tstruct sii8620_mt_msg *msg)\n{\n\tu8 reg = msg->reg[1] & 0x7f;\n\n\tif (msg->reg[1] & 0x80)\n\t\tctx->xdevcap[reg] = msg->ret;\n\telse\n\t\tctx->devcap[reg] = msg->ret;\n}\n\nstatic void sii8620_mt_read_devcap_reg(struct sii8620 *ctx, u8 reg)\n{\n\tstruct sii8620_mt_msg *msg = sii8620_mt_msg_new(ctx);\n\n\tif (!msg)\n\t\treturn;\n\n\tmsg->reg[0] = (reg & 0x80) ? MHL_READ_XDEVCAP_REG : MHL_READ_DEVCAP_REG;\n\tmsg->reg[1] = reg;\n\tmsg->send = sii8620_mt_msc_cmd_send;\n\tmsg->recv = sii8620_mt_read_devcap_reg_recv;\n}\n\nstatic inline void sii8620_mt_read_xdevcap_reg(struct sii8620 *ctx, u8 reg)\n{\n\tsii8620_mt_read_devcap_reg(ctx, reg | 0x80);\n}\n\nstatic void *sii8620_burst_get_tx_buf(struct sii8620 *ctx, int len)\n{\n\tu8 *buf = &ctx->burst.tx_buf[ctx->burst.tx_count];\n\tint size = len + 2;\n\n\tif (ctx->burst.tx_count + size >= ARRAY_SIZE(ctx->burst.tx_buf)) {\n\t\tdev_err(ctx->dev, \"TX-BLK buffer exhausted\\n\");\n\t\tctx->error = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\tctx->burst.tx_count += size;\n\tbuf[1] = len;\n\n\treturn buf + 2;\n}\n\nstatic u8 *sii8620_burst_get_rx_buf(struct sii8620 *ctx, int len)\n{\n\tu8 *buf = &ctx->burst.rx_buf[ctx->burst.rx_count];\n\tint size = len + 1;\n\n\tif (ctx->burst.rx_count + size >= ARRAY_SIZE(ctx->burst.rx_buf)) {\n\t\tdev_err(ctx->dev, \"RX-BLK buffer exhausted\\n\");\n\t\tctx->error = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\tctx->burst.rx_count += size;\n\tbuf[0] = len;\n\n\treturn buf + 1;\n}\n\nstatic void sii8620_burst_send(struct sii8620 *ctx)\n{\n\tint tx_left = ctx->burst.tx_count;\n\tu8 *d = ctx->burst.tx_buf;\n\n\twhile (tx_left > 0) {\n\t\tint len = d[1] + 2;\n\n\t\tif (ctx->burst.r_count + len > ctx->burst.r_size)\n\t\t\tbreak;\n\t\td[0] = min(ctx->burst.rx_ack, 255);\n\t\tctx->burst.rx_ack -= d[0];\n\t\tsii8620_write_buf(ctx, REG_EMSC_XMIT_WRITE_PORT, d, len);\n\t\tctx->burst.r_count += len;\n\t\ttx_left -= len;\n\t\td += len;\n\t}\n\n\tctx->burst.tx_count = tx_left;\n\n\twhile (ctx->burst.rx_ack > 0) {\n\t\tu8 b[2] = { min(ctx->burst.rx_ack, 255), 0 };\n\n\t\tif (ctx->burst.r_count + 2 > ctx->burst.r_size)\n\t\t\tbreak;\n\t\tctx->burst.rx_ack -= b[0];\n\t\tsii8620_write_buf(ctx, REG_EMSC_XMIT_WRITE_PORT, b, 2);\n\t\tctx->burst.r_count += 2;\n\t}\n}\n\nstatic void sii8620_burst_receive(struct sii8620 *ctx)\n{\n\tu8 buf[3], *d;\n\tint count;\n\n\tsii8620_read_buf(ctx, REG_EMSCRFIFOBCNTL, buf, 2);\n\tcount = get_unaligned_le16(buf);\n\twhile (count > 0) {\n\t\tint len = min(count, 3);\n\n\t\tsii8620_read_buf(ctx, REG_EMSC_RCV_READ_PORT, buf, len);\n\t\tcount -= len;\n\t\tctx->burst.rx_ack += len - 1;\n\t\tctx->burst.r_count -= buf[1];\n\t\tif (ctx->burst.r_count < 0)\n\t\t\tctx->burst.r_count = 0;\n\n\t\tif (len < 3 || !buf[2])\n\t\t\tcontinue;\n\n\t\tlen = buf[2];\n\t\td = sii8620_burst_get_rx_buf(ctx, len);\n\t\tif (!d)\n\t\t\tcontinue;\n\t\tsii8620_read_buf(ctx, REG_EMSC_RCV_READ_PORT, d, len);\n\t\tcount -= len;\n\t\tctx->burst.rx_ack += len;\n\t}\n}\n\nstatic void sii8620_burst_tx_rbuf_info(struct sii8620 *ctx, int size)\n{\n\tstruct mhl_burst_blk_rcv_buffer_info *d =\n\t\tsii8620_burst_get_tx_buf(ctx, sizeof(*d));\n\tif (!d)\n\t\treturn;\n\n\td->id = cpu_to_be16(MHL_BURST_ID_BLK_RCV_BUFFER_INFO);\n\td->size = cpu_to_le16(size);\n}\n\nstatic u8 sii8620_checksum(void *ptr, int size)\n{\n\tu8 *d = ptr, sum = 0;\n\n\twhile (size--)\n\t\tsum += *d++;\n\n\treturn sum;\n}\n\nstatic void sii8620_mhl_burst_hdr_set(struct mhl3_burst_header *h,\n\tenum mhl_burst_id id)\n{\n\th->id = cpu_to_be16(id);\n\th->total_entries = 1;\n\th->sequence_index = 1;\n}\n\nstatic void sii8620_burst_tx_bits_per_pixel_fmt(struct sii8620 *ctx, u8 fmt)\n{\n\tstruct mhl_burst_bits_per_pixel_fmt *d;\n\tconst int size = sizeof(*d) + sizeof(d->desc[0]);\n\n\td = sii8620_burst_get_tx_buf(ctx, size);\n\tif (!d)\n\t\treturn;\n\n\tsii8620_mhl_burst_hdr_set(&d->hdr, MHL_BURST_ID_BITS_PER_PIXEL_FMT);\n\td->num_entries = 1;\n\td->desc[0].stream_id = 0;\n\td->desc[0].pixel_format = fmt;\n\td->hdr.checksum -= sii8620_checksum(d, size);\n}\n\nstatic void sii8620_burst_rx_all(struct sii8620 *ctx)\n{\n\tu8 *d = ctx->burst.rx_buf;\n\tint count = ctx->burst.rx_count;\n\n\twhile (count-- > 0) {\n\t\tint len = *d++;\n\t\tint id = get_unaligned_be16(&d[0]);\n\n\t\tswitch (id) {\n\t\tcase MHL_BURST_ID_BLK_RCV_BUFFER_INFO:\n\t\t\tctx->burst.r_size = get_unaligned_le16(&d[2]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tcount -= len;\n\t\td += len;\n\t}\n\tctx->burst.rx_count = 0;\n}\n\nstatic void sii8620_fetch_edid(struct sii8620 *ctx)\n{\n\tu8 lm_ddc, ddc_cmd, int3, cbus;\n\tunsigned long timeout;\n\tint fetched, i;\n\tint edid_len = EDID_LENGTH;\n\tu8 *edid;\n\n\tsii8620_readb(ctx, REG_CBUS_STATUS);\n\tlm_ddc = sii8620_readb(ctx, REG_LM_DDC);\n\tddc_cmd = sii8620_readb(ctx, REG_DDC_CMD);\n\n\tsii8620_write_seq(ctx,\n\t\tREG_INTR9_MASK, 0,\n\t\tREG_EDID_CTRL, BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO,\n\t\tREG_HDCP2X_POLL_CS, 0x71,\n\t\tREG_HDCP2X_CTRL_0, BIT_HDCP2X_CTRL_0_HDCP2X_HDCPTX,\n\t\tREG_LM_DDC, lm_ddc | BIT_LM_DDC_SW_TPI_EN_DISABLED,\n\t);\n\n\tfor (i = 0; i < 256; ++i) {\n\t\tu8 ddc_stat = sii8620_readb(ctx, REG_DDC_STATUS);\n\n\t\tif (!(ddc_stat & BIT_DDC_STATUS_DDC_I2C_IN_PROG))\n\t\t\tbreak;\n\t\tsii8620_write(ctx, REG_DDC_STATUS,\n\t\t\t      BIT_DDC_STATUS_DDC_FIFO_EMPTY);\n\t}\n\n\tsii8620_write(ctx, REG_DDC_ADDR, 0x50 << 1);\n\n\tedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!edid) {\n\t\tctx->error = -ENOMEM;\n\t\treturn;\n\t}\n\n#define FETCH_SIZE 16\n\tfor (fetched = 0; fetched < edid_len; fetched += FETCH_SIZE) {\n\t\tsii8620_readb(ctx, REG_DDC_STATUS);\n\t\tsii8620_write_seq(ctx,\n\t\t\tREG_DDC_CMD, ddc_cmd | VAL_DDC_CMD_DDC_CMD_ABORT,\n\t\t\tREG_DDC_CMD, ddc_cmd | VAL_DDC_CMD_DDC_CMD_CLEAR_FIFO,\n\t\t\tREG_DDC_STATUS, BIT_DDC_STATUS_DDC_FIFO_EMPTY\n\t\t);\n\t\tsii8620_write_seq(ctx,\n\t\t\tREG_DDC_SEGM, fetched >> 8,\n\t\t\tREG_DDC_OFFSET, fetched & 0xff,\n\t\t\tREG_DDC_DIN_CNT1, FETCH_SIZE,\n\t\t\tREG_DDC_DIN_CNT2, 0,\n\t\t\tREG_DDC_CMD, ddc_cmd | VAL_DDC_CMD_ENH_DDC_READ_NO_ACK\n\t\t);\n\n\t\tint3 = 0;\n\t\ttimeout = jiffies + msecs_to_jiffies(200);\n\t\tfor (;;) {\n\t\t\tcbus = sii8620_readb(ctx, REG_CBUS_STATUS);\n\t\t\tif (~cbus & BIT_CBUS_STATUS_CBUS_CONNECTED) {\n\t\t\t\tkfree(edid);\n\t\t\t\tedid = NULL;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tif (int3 & BIT_DDC_CMD_DONE) {\n\t\t\t\tif (sii8620_readb(ctx, REG_DDC_DOUT_CNT)\n\t\t\t\t    >= FETCH_SIZE)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint3 = sii8620_readb(ctx, REG_INTR3);\n\t\t\t}\n\t\t\tif (time_is_before_jiffies(timeout)) {\n\t\t\t\tctx->error = -ETIMEDOUT;\n\t\t\t\tdev_err(ctx->dev, \"timeout during EDID read\\n\");\n\t\t\t\tkfree(edid);\n\t\t\t\tedid = NULL;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tusleep_range(10, 20);\n\t\t}\n\n\t\tsii8620_read_buf(ctx, REG_DDC_DATA, edid + fetched, FETCH_SIZE);\n\t\tif (fetched + FETCH_SIZE == EDID_LENGTH) {\n\t\t\tu8 ext = ((struct edid *)edid)->extensions;\n\n\t\t\tif (ext) {\n\t\t\t\tu8 *new_edid;\n\n\t\t\t\tedid_len += ext * EDID_LENGTH;\n\t\t\t\tnew_edid = krealloc(edid, edid_len, GFP_KERNEL);\n\t\t\t\tif (!new_edid) {\n\t\t\t\t\tkfree(edid);\n\t\t\t\t\tctx->error = -ENOMEM;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tedid = new_edid;\n\t\t\t}\n\t\t}\n\t}\n\n\tsii8620_write_seq(ctx,\n\t\tREG_INTR3_MASK, BIT_DDC_CMD_DONE,\n\t\tREG_LM_DDC, lm_ddc\n\t);\n\nend:\n\tkfree(ctx->edid);\n\tctx->edid = (struct edid *)edid;\n}\n\nstatic void sii8620_set_upstream_edid(struct sii8620 *ctx)\n{\n\tsii8620_setbits(ctx, REG_DPD, BIT_DPD_PDNRX12 | BIT_DPD_PDIDCK_N\n\t\t\t| BIT_DPD_PD_MHL_CLK_N, 0xff);\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_RX_HDMI_CTRL3, 0x00,\n\t\tREG_PKT_FILTER_0, 0xFF,\n\t\tREG_PKT_FILTER_1, 0xFF,\n\t\tREG_ALICE0_BW_I2C, 0x06\n\t);\n\n\tsii8620_setbits(ctx, REG_RX_HDMI_CLR_BUFFER,\n\t\t\tBIT_RX_HDMI_CLR_BUFFER_VSI_CLR_EN, 0xff);\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_EDID_CTRL, BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\n\t\t\t| BIT_EDID_CTRL_EDID_MODE_EN,\n\t\tREG_EDID_FIFO_ADDR, 0,\n\t);\n\n\tsii8620_write_buf(ctx, REG_EDID_FIFO_WR_DATA, (u8 *)ctx->edid,\n\t\t\t  (ctx->edid->extensions + 1) * EDID_LENGTH);\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_EDID_CTRL, BIT_EDID_CTRL_EDID_PRIME_VALID\n\t\t\t| BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO\n\t\t\t| BIT_EDID_CTRL_EDID_MODE_EN,\n\t\tREG_INTR5_MASK, BIT_INTR_SCDT_CHANGE,\n\t\tREG_INTR9_MASK, 0\n\t);\n}\n\nstatic void sii8620_xtal_set_rate(struct sii8620 *ctx)\n{\n\tstatic const struct {\n\t\tunsigned int rate;\n\t\tu8 div;\n\t\tu8 tp1;\n\t} rates[] = {\n\t\t{ 19200, 0x04, 0x53 },\n\t\t{ 20000, 0x04, 0x62 },\n\t\t{ 24000, 0x05, 0x75 },\n\t\t{ 30000, 0x06, 0x92 },\n\t\t{ 38400, 0x0c, 0xbc },\n\t};\n\tunsigned long rate = clk_get_rate(ctx->clk_xtal) / 1000;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rates) - 1; ++i)\n\t\tif (rate <= rates[i].rate)\n\t\t\tbreak;\n\n\tif (rate != rates[i].rate)\n\t\tdev_err(ctx->dev, \"xtal clock rate(%lukHz) not supported, setting MHL for %ukHz.\\n\",\n\t\t\trate, rates[i].rate);\n\n\tsii8620_write(ctx, REG_DIV_CTL_MAIN, rates[i].div);\n\tsii8620_write(ctx, REG_HDCP2X_TP1, rates[i].tp1);\n}\n\nstatic int sii8620_hw_on(struct sii8620 *ctx)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(10000, 20000);\n\tret = clk_prepare_enable(ctx->clk_xtal);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(100);\n\tgpiod_set_value(ctx->gpio_reset, 0);\n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic int sii8620_hw_off(struct sii8620 *ctx)\n{\n\tclk_disable_unprepare(ctx->clk_xtal);\n\tgpiod_set_value(ctx->gpio_reset, 1);\n\treturn regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n}\n\nstatic void sii8620_cbus_reset(struct sii8620 *ctx)\n{\n\tsii8620_write(ctx, REG_PWD_SRST, BIT_PWD_SRST_CBUS_RST\n\t\t      | BIT_PWD_SRST_CBUS_RST_SW_EN);\n\tusleep_range(10000, 20000);\n\tsii8620_write(ctx, REG_PWD_SRST, BIT_PWD_SRST_CBUS_RST_SW_EN);\n}\n\nstatic void sii8620_set_auto_zone(struct sii8620 *ctx)\n{\n\tif (ctx->mode != CM_MHL1) {\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_TX_ZONE_CTL1, 0x0,\n\t\t\tREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\n\t\t\t\t| BIT_MHL_PLL_CTL0_CRYSTAL_CLK_SEL\n\t\t\t\t| BIT_MHL_PLL_CTL0_ZONE_MASK_OE\n\t\t);\n\t} else {\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_TX_ZONE_CTL1, VAL_TX_ZONE_CTL1_TX_ZONE_CTRL_MODE,\n\t\t\tREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\n\t\t\t\t| BIT_MHL_PLL_CTL0_ZONE_MASK_OE\n\t\t);\n\t}\n}\n\nstatic void sii8620_stop_video(struct sii8620 *ctx)\n{\n\tu8 val;\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_TPI_INTR_EN, 0,\n\t\tREG_HDCP2X_INTR0_MASK, 0,\n\t\tREG_TPI_COPP_DATA2, 0,\n\t\tREG_TPI_INTR_ST0, ~0,\n\t);\n\n\tswitch (ctx->sink_type) {\n\tcase SINK_DVI:\n\t\tval = BIT_TPI_SC_REG_TMDS_OE_POWER_DOWN\n\t\t\t| BIT_TPI_SC_TPI_AV_MUTE;\n\t\tbreak;\n\tcase SINK_HDMI:\n\tdefault:\n\t\tval = BIT_TPI_SC_REG_TMDS_OE_POWER_DOWN\n\t\t\t| BIT_TPI_SC_TPI_AV_MUTE\n\t\t\t| BIT_TPI_SC_TPI_OUTPUT_MODE_0_HDMI;\n\t\tbreak;\n\t}\n\n\tsii8620_write(ctx, REG_TPI_SC, val);\n}\n\nstatic void sii8620_set_format(struct sii8620 *ctx)\n{\n\tu8 out_fmt;\n\n\tif (sii8620_is_mhl3(ctx)) {\n\t\tsii8620_setbits(ctx, REG_M3_P0CTRL,\n\t\t\t\tBIT_M3_P0CTRL_MHL3_P0_PIXEL_MODE_PACKED,\n\t\t\t\tctx->use_packed_pixel ? ~0 : 0);\n\t} else {\n\t\tif (ctx->use_packed_pixel) {\n\t\t\tsii8620_write_seq_static(ctx,\n\t\t\t\tREG_VID_MODE, BIT_VID_MODE_M1080P,\n\t\t\t\tREG_MHL_TOP_CTL, BIT_MHL_TOP_CTL_MHL_PP_SEL | 1,\n\t\t\t\tREG_MHLTX_CTL6, 0x60\n\t\t\t);\n\t\t} else {\n\t\t\tsii8620_write_seq_static(ctx,\n\t\t\t\tREG_VID_MODE, 0,\n\t\t\t\tREG_MHL_TOP_CTL, 1,\n\t\t\t\tREG_MHLTX_CTL6, 0xa0\n\t\t\t);\n\t\t}\n\t}\n\n\tif (ctx->use_packed_pixel)\n\t\tout_fmt = VAL_TPI_FORMAT(YCBCR422, FULL);\n\telse\n\t\tout_fmt = VAL_TPI_FORMAT(RGB, FULL);\n\n\tsii8620_write_seq(ctx,\n\t\tREG_TPI_INPUT, VAL_TPI_FORMAT(RGB, FULL),\n\t\tREG_TPI_OUTPUT, out_fmt,\n\t);\n}\n\nstatic int mhl3_infoframe_init(struct mhl3_infoframe *frame)\n{\n\tmemset(frame, 0, sizeof(*frame));\n\n\tframe->version = 3;\n\tframe->hev_format = -1;\n\treturn 0;\n}\n\nstatic ssize_t mhl3_infoframe_pack(struct mhl3_infoframe *frame,\n\t\t void *buffer, size_t size)\n{\n\tconst int frm_len = HDMI_INFOFRAME_HEADER_SIZE + MHL3_INFOFRAME_SIZE;\n\tu8 *ptr = buffer;\n\n\tif (size < frm_len)\n\t\treturn -ENOSPC;\n\n\tmemset(buffer, 0, size);\n\tptr[0] = HDMI_INFOFRAME_TYPE_VENDOR;\n\tptr[1] = frame->version;\n\tptr[2] = MHL3_INFOFRAME_SIZE;\n\tptr[4] = MHL3_IEEE_OUI & 0xff;\n\tptr[5] = (MHL3_IEEE_OUI >> 8) & 0xff;\n\tptr[6] = (MHL3_IEEE_OUI >> 16) & 0xff;\n\tptr[7] = frame->video_format & 0x3;\n\tptr[7] |= (frame->format_type & 0x7) << 2;\n\tptr[7] |= frame->sep_audio ? BIT(5) : 0;\n\tif (frame->hev_format >= 0) {\n\t\tptr[9] = 1;\n\t\tptr[10] = (frame->hev_format >> 8) & 0xff;\n\t\tptr[11] = frame->hev_format & 0xff;\n\t}\n\tif (frame->av_delay) {\n\t\tbool sign = frame->av_delay < 0;\n\t\tint delay = sign ? -frame->av_delay : frame->av_delay;\n\n\t\tptr[12] = (delay >> 16) & 0xf;\n\t\tif (sign)\n\t\t\tptr[12] |= BIT(4);\n\t\tptr[13] = (delay >> 8) & 0xff;\n\t\tptr[14] = delay & 0xff;\n\t}\n\tptr[3] -= sii8620_checksum(buffer, frm_len);\n\treturn frm_len;\n}\n\nstatic void sii8620_set_infoframes(struct sii8620 *ctx,\n\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct mhl3_infoframe mhl_frm;\n\tunion hdmi_infoframe frm;\n\tu8 buf[31];\n\tint ret;\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frm.avi,\n\t\t\t\t\t\t       NULL, mode);\n\tif (ctx->use_packed_pixel)\n\t\tfrm.avi.colorspace = HDMI_COLORSPACE_YUV422;\n\n\tif (!ret)\n\t\tret = hdmi_avi_infoframe_pack(&frm.avi, buf, ARRAY_SIZE(buf));\n\tif (ret > 0)\n\t\tsii8620_write_buf(ctx, REG_TPI_AVI_CHSUM, buf + 3, ret - 3);\n\n\tif (!sii8620_is_mhl3(ctx) || !ctx->use_packed_pixel) {\n\t\tsii8620_write(ctx, REG_TPI_SC,\n\t\t\tBIT_TPI_SC_TPI_OUTPUT_MODE_0_HDMI);\n\t\tsii8620_write(ctx, REG_PKT_FILTER_0,\n\t\t\tBIT_PKT_FILTER_0_DROP_CEA_GAMUT_PKT |\n\t\t\tBIT_PKT_FILTER_0_DROP_MPEG_PKT |\n\t\t\tBIT_PKT_FILTER_0_DROP_GCP_PKT,\n\t\t\tBIT_PKT_FILTER_1_DROP_GEN_PKT);\n\t\treturn;\n\t}\n\n\tsii8620_write(ctx, REG_PKT_FILTER_0,\n\t\tBIT_PKT_FILTER_0_DROP_CEA_GAMUT_PKT |\n\t\tBIT_PKT_FILTER_0_DROP_MPEG_PKT |\n\t\tBIT_PKT_FILTER_0_DROP_AVI_PKT |\n\t\tBIT_PKT_FILTER_0_DROP_GCP_PKT,\n\t\tBIT_PKT_FILTER_1_VSI_OVERRIDE_DIS |\n\t\tBIT_PKT_FILTER_1_DROP_GEN_PKT |\n\t\tBIT_PKT_FILTER_1_DROP_VSIF_PKT);\n\n\tsii8620_write(ctx, REG_TPI_INFO_FSEL, BIT_TPI_INFO_FSEL_EN\n\t\t| BIT_TPI_INFO_FSEL_RPT | VAL_TPI_INFO_FSEL_VSI);\n\tret = mhl3_infoframe_init(&mhl_frm);\n\tif (!ret)\n\t\tret = mhl3_infoframe_pack(&mhl_frm, buf, ARRAY_SIZE(buf));\n\tsii8620_write_buf(ctx, REG_TPI_INFO_B0, buf, ret);\n}\n\nstatic void sii8620_start_video(struct sii8620 *ctx)\n{\n\tstruct drm_display_mode *mode =\n\t\t&ctx->bridge.encoder->crtc->state->adjusted_mode;\n\n\tif (!sii8620_is_mhl3(ctx))\n\t\tsii8620_stop_video(ctx);\n\n\tif (ctx->sink_type == SINK_DVI && !sii8620_is_mhl3(ctx)) {\n\t\tsii8620_write(ctx, REG_RX_HDMI_CTRL2,\n\t\t\t      VAL_RX_HDMI_CTRL2_DEFVAL);\n\t\tsii8620_write(ctx, REG_TPI_SC, 0);\n\t\treturn;\n\t}\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_RX_HDMI_CTRL2, VAL_RX_HDMI_CTRL2_DEFVAL\n\t\t\t| BIT_RX_HDMI_CTRL2_USE_AV_MUTE,\n\t\tREG_VID_OVRRD, BIT_VID_OVRRD_PP_AUTO_DISABLE\n\t\t\t| BIT_VID_OVRRD_M1080P_OVRRD);\n\tsii8620_set_format(ctx);\n\n\tif (!sii8620_is_mhl3(ctx)) {\n\t\tu8 link_mode = MHL_DST_LM_PATH_ENABLED;\n\n\t\tif (ctx->use_packed_pixel)\n\t\t\tlink_mode |= MHL_DST_LM_CLK_MODE_PACKED_PIXEL;\n\t\telse\n\t\t\tlink_mode |= MHL_DST_LM_CLK_MODE_NORMAL;\n\n\t\tsii8620_mt_write_stat(ctx, MHL_DST_REG(LINK_MODE), link_mode);\n\t\tsii8620_set_auto_zone(ctx);\n\t} else {\n\t\tstatic const struct {\n\t\t\tint max_clk;\n\t\t\tu8 zone;\n\t\t\tu8 link_rate;\n\t\t\tu8 rrp_decode;\n\t\t} clk_spec[] = {\n\t\t\t{ 150000, VAL_TX_ZONE_CTL3_TX_ZONE_1_5GBPS,\n\t\t\t  MHL_XDS_LINK_RATE_1_5_GBPS, 0x38 },\n\t\t\t{ 300000, VAL_TX_ZONE_CTL3_TX_ZONE_3GBPS,\n\t\t\t  MHL_XDS_LINK_RATE_3_0_GBPS, 0x40 },\n\t\t\t{ 600000, VAL_TX_ZONE_CTL3_TX_ZONE_6GBPS,\n\t\t\t  MHL_XDS_LINK_RATE_6_0_GBPS, 0x40 },\n\t\t};\n\t\tu8 p0_ctrl = BIT_M3_P0CTRL_MHL3_P0_PORT_EN;\n\t\tint clk = mode->clock * (ctx->use_packed_pixel ? 2 : 3);\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(clk_spec) - 1; ++i)\n\t\t\tif (clk < clk_spec[i].max_clk)\n\t\t\t\tbreak;\n\n\t\tif (100 * clk >= 98 * clk_spec[i].max_clk)\n\t\t\tp0_ctrl |= BIT_M3_P0CTRL_MHL3_P0_UNLIMIT_EN;\n\n\t\tsii8620_burst_tx_bits_per_pixel_fmt(ctx, ctx->use_packed_pixel);\n\t\tsii8620_burst_send(ctx);\n\t\tsii8620_write_seq(ctx,\n\t\t\tREG_MHL_DP_CTL0, 0xf0,\n\t\t\tREG_MHL3_TX_ZONE_CTL, clk_spec[i].zone);\n\t\tsii8620_setbits(ctx, REG_M3_P0CTRL,\n\t\t\tBIT_M3_P0CTRL_MHL3_P0_PORT_EN\n\t\t\t| BIT_M3_P0CTRL_MHL3_P0_UNLIMIT_EN, p0_ctrl);\n\t\tsii8620_setbits(ctx, REG_M3_POSTM, MSK_M3_POSTM_RRP_DECODE,\n\t\t\tclk_spec[i].rrp_decode);\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE\n\t\t\t\t| BIT_M3_CTRL_H2M_SWRST,\n\t\t\tREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE\n\t\t);\n\t\tsii8620_mt_write_stat(ctx, MHL_XDS_REG(AVLINK_MODE_CONTROL),\n\t\t\tclk_spec[i].link_rate);\n\t}\n\n\tsii8620_set_infoframes(ctx, mode);\n}\n\nstatic void sii8620_disable_hpd(struct sii8620 *ctx)\n{\n\tsii8620_setbits(ctx, REG_EDID_CTRL, BIT_EDID_CTRL_EDID_PRIME_VALID, 0);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_HPD_CTRL, BIT_HPD_CTRL_HPD_OUT_OVR_EN,\n\t\tREG_INTR8_MASK, 0\n\t);\n}\n\nstatic void sii8620_enable_hpd(struct sii8620 *ctx)\n{\n\tsii8620_setbits(ctx, REG_TMDS_CSTAT_P3,\n\t\t\tBIT_TMDS_CSTAT_P3_SCDT_CLR_AVI_DIS\n\t\t\t| BIT_TMDS_CSTAT_P3_CLR_AVI, ~0);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_HPD_CTRL, BIT_HPD_CTRL_HPD_OUT_OVR_EN\n\t\t\t| BIT_HPD_CTRL_HPD_HIGH,\n\t);\n}\n\nstatic void sii8620_mhl_discover(struct sii8620 *ctx)\n{\n\tsii8620_write_seq_static(ctx,\n\t\tREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\n\t\t\t| BIT_DISC_CTRL9_DISC_PULSE_PROCEED,\n\t\tREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_5K, VAL_PUP_20K),\n\t\tREG_CBUS_DISC_INTR0_MASK, BIT_MHL3_EST_INT\n\t\t\t| BIT_MHL_EST_INT\n\t\t\t| BIT_NOT_MHL_EST_INT\n\t\t\t| BIT_CBUS_MHL3_DISCON_INT\n\t\t\t| BIT_CBUS_MHL12_DISCON_INT\n\t\t\t| BIT_RGND_READY_INT,\n\t\tREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\n\t\t\t| BIT_MHL_PLL_CTL0_CRYSTAL_CLK_SEL\n\t\t\t| BIT_MHL_PLL_CTL0_ZONE_MASK_OE,\n\t\tREG_MHL_DP_CTL0, BIT_MHL_DP_CTL0_DP_OE\n\t\t\t| BIT_MHL_DP_CTL0_TX_OE_OVR,\n\t\tREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE,\n\t\tREG_MHL_DP_CTL1, 0xA2,\n\t\tREG_MHL_DP_CTL2, 0x03,\n\t\tREG_MHL_DP_CTL3, 0x35,\n\t\tREG_MHL_DP_CTL5, 0x02,\n\t\tREG_MHL_DP_CTL6, 0x02,\n\t\tREG_MHL_DP_CTL7, 0x03,\n\t\tREG_COC_CTLC, 0xFF,\n\t\tREG_DPD, BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12\n\t\t\t| BIT_DPD_OSC_EN | BIT_DPD_PWRON_HSIC,\n\t\tREG_COC_INTR_MASK, BIT_COC_PLL_LOCK_STATUS_CHANGE\n\t\t\t| BIT_COC_CALIBRATION_DONE,\n\t\tREG_CBUS_INT_1_MASK, BIT_CBUS_MSC_ABORT_RCVD\n\t\t\t| BIT_CBUS_CMD_ABORT,\n\t\tREG_CBUS_INT_0_MASK, BIT_CBUS_MSC_MT_DONE\n\t\t\t| BIT_CBUS_HPD_CHG\n\t\t\t| BIT_CBUS_MSC_MR_WRITE_STAT\n\t\t\t| BIT_CBUS_MSC_MR_MSC_MSG\n\t\t\t| BIT_CBUS_MSC_MR_WRITE_BURST\n\t\t\t| BIT_CBUS_MSC_MR_SET_INT\n\t\t\t| BIT_CBUS_MSC_MT_DONE_NACK\n\t);\n}\n\nstatic void sii8620_peer_specific_init(struct sii8620 *ctx)\n{\n\tif (sii8620_is_mhl3(ctx))\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_SYS_CTRL1, BIT_SYS_CTRL1_BLOCK_DDC_BY_HPD,\n\t\t\tREG_EMSCINTRMASK1,\n\t\t\t\tBIT_EMSCINTR1_EMSC_TRAINING_COMMA_ERR\n\t\t);\n\telse\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_HDCP2X_INTR0_MASK, 0x00,\n\t\t\tREG_EMSCINTRMASK1, 0x00,\n\t\t\tREG_HDCP2X_INTR0, 0xFF,\n\t\t\tREG_INTR1, 0xFF,\n\t\t\tREG_SYS_CTRL1, BIT_SYS_CTRL1_BLOCK_DDC_BY_HPD\n\t\t\t\t| BIT_SYS_CTRL1_TX_CTRL_HDMI\n\t\t);\n}\n\n#define SII8620_MHL_VERSION\t\t\t0x32\n#define SII8620_SCRATCHPAD_SIZE\t\t\t16\n#define SII8620_INT_STAT_SIZE\t\t\t0x33\n\nstatic void sii8620_set_dev_cap(struct sii8620 *ctx)\n{\n\tstatic const u8 devcap[MHL_DCAP_SIZE] = {\n\t\t[MHL_DCAP_MHL_VERSION] = SII8620_MHL_VERSION,\n\t\t[MHL_DCAP_CAT] = MHL_DCAP_CAT_SOURCE | MHL_DCAP_CAT_POWER,\n\t\t[MHL_DCAP_ADOPTER_ID_H] = 0x01,\n\t\t[MHL_DCAP_ADOPTER_ID_L] = 0x41,\n\t\t[MHL_DCAP_VID_LINK_MODE] = MHL_DCAP_VID_LINK_RGB444\n\t\t\t| MHL_DCAP_VID_LINK_PPIXEL\n\t\t\t| MHL_DCAP_VID_LINK_16BPP,\n\t\t[MHL_DCAP_AUD_LINK_MODE] = MHL_DCAP_AUD_LINK_2CH,\n\t\t[MHL_DCAP_VIDEO_TYPE] = MHL_DCAP_VT_GRAPHICS,\n\t\t[MHL_DCAP_LOG_DEV_MAP] = MHL_DCAP_LD_GUI,\n\t\t[MHL_DCAP_BANDWIDTH] = 0x0f,\n\t\t[MHL_DCAP_FEATURE_FLAG] = MHL_DCAP_FEATURE_RCP_SUPPORT\n\t\t\t| MHL_DCAP_FEATURE_RAP_SUPPORT\n\t\t\t| MHL_DCAP_FEATURE_SP_SUPPORT,\n\t\t[MHL_DCAP_SCRATCHPAD_SIZE] = SII8620_SCRATCHPAD_SIZE,\n\t\t[MHL_DCAP_INT_STAT_SIZE] = SII8620_INT_STAT_SIZE,\n\t};\n\tstatic const u8 xdcap[MHL_XDC_SIZE] = {\n\t\t[MHL_XDC_ECBUS_SPEEDS] = MHL_XDC_ECBUS_S_075\n\t\t\t| MHL_XDC_ECBUS_S_8BIT,\n\t\t[MHL_XDC_TMDS_SPEEDS] = MHL_XDC_TMDS_150\n\t\t\t| MHL_XDC_TMDS_300 | MHL_XDC_TMDS_600,\n\t\t[MHL_XDC_ECBUS_ROLES] = MHL_XDC_DEV_HOST,\n\t\t[MHL_XDC_LOG_DEV_MAPX] = MHL_XDC_LD_PHONE,\n\t};\n\n\tsii8620_write_buf(ctx, REG_MHL_DEVCAP_0, devcap, ARRAY_SIZE(devcap));\n\tsii8620_write_buf(ctx, REG_MHL_EXTDEVCAP_0, xdcap, ARRAY_SIZE(xdcap));\n}\n\nstatic void sii8620_mhl_init(struct sii8620 *ctx)\n{\n\tsii8620_write_seq_static(ctx,\n\t\tREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_OFF, VAL_PUP_20K),\n\t\tREG_CBUS_MSC_COMPAT_CTRL,\n\t\t\tBIT_CBUS_MSC_COMPAT_CTRL_XDEVCAP_EN,\n\t);\n\n\tsii8620_peer_specific_init(ctx);\n\n\tsii8620_disable_hpd(ctx);\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_EDID_CTRL, BIT_EDID_CTRL_EDID_FIFO_ADDR_AUTO,\n\t\tREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\n\t\t\t| BIT_DISC_CTRL9_WAKE_PULSE_BYPASS,\n\t\tREG_TMDS0_CCTRL1, 0x90,\n\t\tREG_TMDS_CLK_EN, 0x01,\n\t\tREG_TMDS_CH_EN, 0x11,\n\t\tREG_BGR_BIAS, 0x87,\n\t\tREG_ALICE0_ZONE_CTRL, 0xE8,\n\t\tREG_ALICE0_MODE_CTRL, 0x04,\n\t);\n\tsii8620_setbits(ctx, REG_LM_DDC, BIT_LM_DDC_SW_TPI_EN_DISABLED, 0);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_TPI_HW_OPT3, 0x76,\n\t\tREG_TMDS_CCTRL, BIT_TMDS_CCTRL_TMDS_OE,\n\t\tREG_TPI_DTD_B2, 79,\n\t);\n\tsii8620_set_dev_cap(ctx);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_MDT_XMIT_TIMEOUT, 100,\n\t\tREG_MDT_XMIT_CTRL, 0x03,\n\t\tREG_MDT_XFIFO_STAT, 0x00,\n\t\tREG_MDT_RCV_TIMEOUT, 100,\n\t\tREG_CBUS_LINK_CTRL_8, 0x1D,\n\t);\n\n\tsii8620_start_gen2_write_burst(ctx);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_BIST_CTRL, 0x00,\n\t\tREG_COC_CTL1, 0x10,\n\t\tREG_COC_CTL2, 0x18,\n\t\tREG_COC_CTLF, 0x07,\n\t\tREG_COC_CTL11, 0xF8,\n\t\tREG_COC_CTL17, 0x61,\n\t\tREG_COC_CTL18, 0x46,\n\t\tREG_COC_CTL19, 0x15,\n\t\tREG_COC_CTL1A, 0x01,\n\t\tREG_MHL_COC_CTL3, BIT_MHL_COC_CTL3_COC_AECHO_EN,\n\t\tREG_MHL_COC_CTL4, 0x2D,\n\t\tREG_MHL_COC_CTL5, 0xF9,\n\t\tREG_MSC_HEARTBEAT_CTRL, 0x27,\n\t);\n\tsii8620_disable_gen2_write_burst(ctx);\n\n\tsii8620_mt_write_stat(ctx, MHL_DST_REG(VERSION), SII8620_MHL_VERSION);\n\tsii8620_mt_write_stat(ctx, MHL_DST_REG(CONNECTED_RDY),\n\t\t\t      MHL_DST_CONN_DCAP_RDY | MHL_DST_CONN_XDEVCAPP_SUPP\n\t\t\t      | MHL_DST_CONN_POW_STAT);\n\tsii8620_mt_set_int(ctx, MHL_INT_REG(RCHANGE), MHL_INT_RC_DCAP_CHG);\n}\n\nstatic void sii8620_emsc_enable(struct sii8620 *ctx)\n{\n\tu8 reg;\n\n\tsii8620_setbits(ctx, REG_GENCTL, BIT_GENCTL_EMSC_EN\n\t\t\t\t\t | BIT_GENCTL_CLR_EMSC_RFIFO\n\t\t\t\t\t | BIT_GENCTL_CLR_EMSC_XFIFO, ~0);\n\tsii8620_setbits(ctx, REG_GENCTL, BIT_GENCTL_CLR_EMSC_RFIFO\n\t\t\t\t\t | BIT_GENCTL_CLR_EMSC_XFIFO, 0);\n\tsii8620_setbits(ctx, REG_COMMECNT, BIT_COMMECNT_I2C_TO_EMSC_EN, ~0);\n\treg = sii8620_readb(ctx, REG_EMSCINTR);\n\tsii8620_write(ctx, REG_EMSCINTR, reg);\n\tsii8620_write(ctx, REG_EMSCINTRMASK, BIT_EMSCINTR_SPI_DVLD);\n}\n\nstatic int sii8620_wait_for_fsm_state(struct sii8620 *ctx, u8 state)\n{\n\tint i;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tu8 s = sii8620_readb(ctx, REG_COC_STAT_0);\n\n\t\tif ((s & MSK_COC_STAT_0_FSM_STATE) == state)\n\t\t\treturn 0;\n\t\tif (!(s & BIT_COC_STAT_0_PLL_LOCKED))\n\t\t\treturn -EBUSY;\n\t\tusleep_range(4000, 6000);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic void sii8620_set_mode(struct sii8620 *ctx, enum sii8620_mode mode)\n{\n\tint ret;\n\n\tif (ctx->mode == mode)\n\t\treturn;\n\n\tswitch (mode) {\n\tcase CM_MHL1:\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_CBUS_MSC_COMPAT_CTRL, 0x02,\n\t\t\tREG_M3_CTRL, VAL_M3_CTRL_MHL1_2_VALUE,\n\t\t\tREG_DPD, BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12\n\t\t\t\t| BIT_DPD_OSC_EN,\n\t\t\tREG_COC_INTR_MASK, 0\n\t\t);\n\t\tctx->mode = mode;\n\t\tbreak;\n\tcase CM_MHL3:\n\t\tsii8620_write(ctx, REG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE);\n\t\tctx->mode = mode;\n\t\treturn;\n\tcase CM_ECBUS_S:\n\t\tsii8620_emsc_enable(ctx);\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_TTXSPINUMS, 4,\n\t\t\tREG_TRXSPINUMS, 4,\n\t\t\tREG_TTXHSICNUMS, 0x14,\n\t\t\tREG_TRXHSICNUMS, 0x14,\n\t\t\tREG_TTXTOTNUMS, 0x18,\n\t\t\tREG_TRXTOTNUMS, 0x18,\n\t\t\tREG_PWD_SRST, BIT_PWD_SRST_COC_DOC_RST\n\t\t\t\t      | BIT_PWD_SRST_CBUS_RST_SW_EN,\n\t\t\tREG_MHL_COC_CTL1, 0xbd,\n\t\t\tREG_PWD_SRST, BIT_PWD_SRST_CBUS_RST_SW_EN,\n\t\t\tREG_COC_CTLB, 0x01,\n\t\t\tREG_COC_CTL0, 0x5c,\n\t\t\tREG_COC_CTL14, 0x03,\n\t\t\tREG_COC_CTL15, 0x80,\n\t\t\tREG_MHL_DP_CTL6, BIT_MHL_DP_CTL6_DP_TAP1_SGN\n\t\t\t\t\t | BIT_MHL_DP_CTL6_DP_TAP1_EN\n\t\t\t\t\t | BIT_MHL_DP_CTL6_DT_PREDRV_FEEDCAP_EN,\n\t\t\tREG_MHL_DP_CTL8, 0x03\n\t\t);\n\t\tret = sii8620_wait_for_fsm_state(ctx, 0x03);\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_COC_CTL14, 0x00,\n\t\t\tREG_COC_CTL15, 0x80\n\t\t);\n\t\tif (!ret)\n\t\t\tsii8620_write(ctx, REG_CBUS3_CNVT, 0x85);\n\t\telse\n\t\t\tsii8620_disconnect(ctx);\n\t\treturn;\n\tcase CM_DISCONNECTED:\n\t\tctx->mode = mode;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctx->dev, \"%s mode %d not supported\\n\", __func__, mode);\n\t\tbreak;\n\t}\n\n\tsii8620_set_auto_zone(ctx);\n\n\tif (mode != CM_MHL1)\n\t\treturn;\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_MHL_DP_CTL0, 0xBC,\n\t\tREG_MHL_DP_CTL1, 0xBB,\n\t\tREG_MHL_DP_CTL3, 0x48,\n\t\tREG_MHL_DP_CTL5, 0x39,\n\t\tREG_MHL_DP_CTL2, 0x2A,\n\t\tREG_MHL_DP_CTL6, 0x2A,\n\t\tREG_MHL_DP_CTL7, 0x08\n\t);\n}\n\nstatic void sii8620_hpd_unplugged(struct sii8620 *ctx)\n{\n\tsii8620_disable_hpd(ctx);\n\tctx->sink_type = SINK_NONE;\n\tctx->sink_detected = false;\n\tctx->feature_complete = false;\n\tkfree(ctx->edid);\n\tctx->edid = NULL;\n}\n\nstatic void sii8620_disconnect(struct sii8620 *ctx)\n{\n\tsii8620_disable_gen2_write_burst(ctx);\n\tsii8620_stop_video(ctx);\n\tmsleep(100);\n\tsii8620_cbus_reset(ctx);\n\tsii8620_set_mode(ctx, CM_DISCONNECTED);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_TX_ZONE_CTL1, 0,\n\t\tREG_MHL_PLL_CTL0, 0x07,\n\t\tREG_COC_CTL0, 0x40,\n\t\tREG_CBUS3_CNVT, 0x84,\n\t\tREG_COC_CTL14, 0x00,\n\t\tREG_COC_CTL0, 0x40,\n\t\tREG_HRXCTRL3, 0x07,\n\t\tREG_MHL_PLL_CTL0, VAL_MHL_PLL_CTL0_HDMI_CLK_RATIO_1X\n\t\t\t| BIT_MHL_PLL_CTL0_CRYSTAL_CLK_SEL\n\t\t\t| BIT_MHL_PLL_CTL0_ZONE_MASK_OE,\n\t\tREG_MHL_DP_CTL0, BIT_MHL_DP_CTL0_DP_OE\n\t\t\t| BIT_MHL_DP_CTL0_TX_OE_OVR,\n\t\tREG_MHL_DP_CTL1, 0xBB,\n\t\tREG_MHL_DP_CTL3, 0x48,\n\t\tREG_MHL_DP_CTL5, 0x3F,\n\t\tREG_MHL_DP_CTL2, 0x2F,\n\t\tREG_MHL_DP_CTL6, 0x2A,\n\t\tREG_MHL_DP_CTL7, 0x03\n\t);\n\tsii8620_hpd_unplugged(ctx);\n\tsii8620_write_seq_static(ctx,\n\t\tREG_M3_CTRL, VAL_M3_CTRL_MHL3_VALUE,\n\t\tREG_MHL_COC_CTL1, 0x07,\n\t\tREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_OFF, VAL_PUP_20K),\n\t\tREG_DISC_CTRL8, 0x00,\n\t\tREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\n\t\t\t| BIT_DISC_CTRL9_WAKE_PULSE_BYPASS,\n\t\tREG_INT_CTRL, 0x00,\n\t\tREG_MSC_HEARTBEAT_CTRL, 0x27,\n\t\tREG_DISC_CTRL1, 0x25,\n\t\tREG_CBUS_DISC_INTR0, (u8)~BIT_RGND_READY_INT,\n\t\tREG_CBUS_DISC_INTR0_MASK, BIT_RGND_READY_INT,\n\t\tREG_MDT_INT_1, 0xff,\n\t\tREG_MDT_INT_1_MASK, 0x00,\n\t\tREG_MDT_INT_0, 0xff,\n\t\tREG_MDT_INT_0_MASK, 0x00,\n\t\tREG_COC_INTR, 0xff,\n\t\tREG_COC_INTR_MASK, 0x00,\n\t\tREG_TRXINTH, 0xff,\n\t\tREG_TRXINTMH, 0x00,\n\t\tREG_CBUS_INT_0, 0xff,\n\t\tREG_CBUS_INT_0_MASK, 0x00,\n\t\tREG_CBUS_INT_1, 0xff,\n\t\tREG_CBUS_INT_1_MASK, 0x00,\n\t\tREG_EMSCINTR, 0xff,\n\t\tREG_EMSCINTRMASK, 0x00,\n\t\tREG_EMSCINTR1, 0xff,\n\t\tREG_EMSCINTRMASK1, 0x00,\n\t\tREG_INTR8, 0xff,\n\t\tREG_INTR8_MASK, 0x00,\n\t\tREG_TPI_INTR_ST0, 0xff,\n\t\tREG_TPI_INTR_EN, 0x00,\n\t\tREG_HDCP2X_INTR0, 0xff,\n\t\tREG_HDCP2X_INTR0_MASK, 0x00,\n\t\tREG_INTR9, 0xff,\n\t\tREG_INTR9_MASK, 0x00,\n\t\tREG_INTR3, 0xff,\n\t\tREG_INTR3_MASK, 0x00,\n\t\tREG_INTR5, 0xff,\n\t\tREG_INTR5_MASK, 0x00,\n\t\tREG_INTR2, 0xff,\n\t\tREG_INTR2_MASK, 0x00,\n\t);\n\tmemset(ctx->stat, 0, sizeof(ctx->stat));\n\tmemset(ctx->xstat, 0, sizeof(ctx->xstat));\n\tmemset(ctx->devcap, 0, sizeof(ctx->devcap));\n\tmemset(ctx->xdevcap, 0, sizeof(ctx->xdevcap));\n\tctx->devcap_read = false;\n\tctx->cbus_status = 0;\n\tsii8620_mt_cleanup(ctx);\n}\n\nstatic void sii8620_mhl_disconnected(struct sii8620 *ctx)\n{\n\tsii8620_write_seq_static(ctx,\n\t\tREG_DISC_CTRL4, VAL_DISC_CTRL4(VAL_PUP_OFF, VAL_PUP_20K),\n\t\tREG_CBUS_MSC_COMPAT_CTRL,\n\t\t\tBIT_CBUS_MSC_COMPAT_CTRL_XDEVCAP_EN\n\t);\n\tsii8620_disconnect(ctx);\n}\n\nstatic void sii8620_irq_disc(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_CBUS_DISC_INTR0);\n\n\tif (stat & VAL_CBUS_MHL_DISCON)\n\t\tsii8620_mhl_disconnected(ctx);\n\n\tif (stat & BIT_RGND_READY_INT) {\n\t\tu8 stat2 = sii8620_readb(ctx, REG_DISC_STAT2);\n\n\t\tif ((stat2 & MSK_DISC_STAT2_RGND) == VAL_RGND_1K) {\n\t\t\tsii8620_mhl_discover(ctx);\n\t\t} else {\n\t\t\tsii8620_write_seq_static(ctx,\n\t\t\t\tREG_DISC_CTRL9, BIT_DISC_CTRL9_WAKE_DRVFLT\n\t\t\t\t\t| BIT_DISC_CTRL9_NOMHL_EST\n\t\t\t\t\t| BIT_DISC_CTRL9_WAKE_PULSE_BYPASS,\n\t\t\t\tREG_CBUS_DISC_INTR0_MASK, BIT_RGND_READY_INT\n\t\t\t\t\t| BIT_CBUS_MHL3_DISCON_INT\n\t\t\t\t\t| BIT_CBUS_MHL12_DISCON_INT\n\t\t\t\t\t| BIT_NOT_MHL_EST_INT\n\t\t\t);\n\t\t}\n\t}\n\tif (stat & BIT_MHL_EST_INT)\n\t\tsii8620_mhl_init(ctx);\n\n\tsii8620_write(ctx, REG_CBUS_DISC_INTR0, stat);\n}\n\nstatic void sii8620_read_burst(struct sii8620 *ctx)\n{\n\tu8 buf[17];\n\n\tsii8620_read_buf(ctx, REG_MDT_RCV_READ_PORT, buf, ARRAY_SIZE(buf));\n\tsii8620_write(ctx, REG_MDT_RCV_CTRL, BIT_MDT_RCV_CTRL_MDT_RCV_EN |\n\t\t      BIT_MDT_RCV_CTRL_MDT_DELAY_RCV_EN |\n\t\t      BIT_MDT_RCV_CTRL_MDT_RFIFO_CLR_CUR);\n\tsii8620_readb(ctx, REG_MDT_RFIFO_STAT);\n}\n\nstatic void sii8620_irq_g2wb(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_MDT_INT_0);\n\n\tif (stat & BIT_MDT_IDLE_AFTER_HAWB_DISABLE)\n\t\tif (sii8620_is_mhl3(ctx))\n\t\t\tsii8620_mt_set_int(ctx, MHL_INT_REG(RCHANGE),\n\t\t\t\tMHL_INT_RC_FEAT_COMPLETE);\n\n\tif (stat & BIT_MDT_RFIFO_DATA_RDY)\n\t\tsii8620_read_burst(ctx);\n\n\tif (stat & BIT_MDT_XFIFO_EMPTY)\n\t\tsii8620_write(ctx, REG_MDT_XMIT_CTRL, 0);\n\n\tsii8620_write(ctx, REG_MDT_INT_0, stat);\n}\n\nstatic void sii8620_status_dcap_ready(struct sii8620 *ctx)\n{\n\tenum sii8620_mode mode;\n\n\tmode = ctx->stat[MHL_DST_VERSION] >= 0x30 ? CM_MHL3 : CM_MHL1;\n\tif (mode > ctx->mode)\n\t\tsii8620_set_mode(ctx, mode);\n\tsii8620_peer_specific_init(ctx);\n\tsii8620_write(ctx, REG_INTR9_MASK, BIT_INTR9_DEVCAP_DONE\n\t\t      | BIT_INTR9_EDID_DONE | BIT_INTR9_EDID_ERROR);\n}\n\nstatic void sii8620_status_changed_path(struct sii8620 *ctx)\n{\n\tu8 link_mode;\n\n\tif (ctx->use_packed_pixel)\n\t\tlink_mode = MHL_DST_LM_CLK_MODE_PACKED_PIXEL;\n\telse\n\t\tlink_mode = MHL_DST_LM_CLK_MODE_NORMAL;\n\n\tif (ctx->stat[MHL_DST_LINK_MODE] & MHL_DST_LM_PATH_ENABLED)\n\t\tlink_mode |= MHL_DST_LM_PATH_ENABLED;\n\n\tsii8620_mt_write_stat(ctx, MHL_DST_REG(LINK_MODE),\n\t\t\t      link_mode);\n}\n\nstatic void sii8620_msc_mr_write_stat(struct sii8620 *ctx)\n{\n\tu8 st[MHL_DST_SIZE], xst[MHL_XDS_SIZE];\n\n\tsii8620_read_buf(ctx, REG_MHL_STAT_0, st, MHL_DST_SIZE);\n\tsii8620_read_buf(ctx, REG_MHL_EXTSTAT_0, xst, MHL_XDS_SIZE);\n\n\tsii8620_update_array(ctx->stat, st, MHL_DST_SIZE);\n\tsii8620_update_array(ctx->xstat, xst, MHL_XDS_SIZE);\n\n\tif (ctx->stat[MHL_DST_CONNECTED_RDY] & st[MHL_DST_CONNECTED_RDY] &\n\t    MHL_DST_CONN_DCAP_RDY) {\n\t\tsii8620_status_dcap_ready(ctx);\n\n\t\tif (!sii8620_is_mhl3(ctx))\n\t\t\tsii8620_mt_read_devcap(ctx, false);\n\t}\n\n\tif (st[MHL_DST_LINK_MODE] & MHL_DST_LM_PATH_ENABLED)\n\t\tsii8620_status_changed_path(ctx);\n}\n\nstatic void sii8620_ecbus_up(struct sii8620 *ctx, int ret)\n{\n\tif (ret < 0)\n\t\treturn;\n\n\tsii8620_set_mode(ctx, CM_ECBUS_S);\n}\n\nstatic void sii8620_got_ecbus_speed(struct sii8620 *ctx, int ret)\n{\n\tif (ret < 0)\n\t\treturn;\n\n\tsii8620_mt_write_stat(ctx, MHL_XDS_REG(CURR_ECBUS_MODE),\n\t\t\t      MHL_XDS_ECBUS_S | MHL_XDS_SLOT_MODE_8BIT);\n\tsii8620_mt_rap(ctx, MHL_RAP_CBUS_MODE_UP);\n\tsii8620_mt_set_cont(ctx, sii8620_ecbus_up);\n}\n\nstatic void sii8620_mhl_burst_emsc_support_set(struct mhl_burst_emsc_support *d,\n\tenum mhl_burst_id id)\n{\n\tsii8620_mhl_burst_hdr_set(&d->hdr, MHL_BURST_ID_EMSC_SUPPORT);\n\td->num_entries = 1;\n\td->burst_id[0] = cpu_to_be16(id);\n}\n\nstatic void sii8620_send_features(struct sii8620 *ctx)\n{\n\tu8 buf[16];\n\n\tsii8620_write(ctx, REG_MDT_XMIT_CTRL, BIT_MDT_XMIT_CTRL_EN\n\t\t| BIT_MDT_XMIT_CTRL_FIXED_BURST_LEN);\n\tsii8620_mhl_burst_emsc_support_set((void *)buf,\n\t\tMHL_BURST_ID_HID_PAYLOAD);\n\tsii8620_write_buf(ctx, REG_MDT_XMIT_WRITE_PORT, buf, ARRAY_SIZE(buf));\n}\n\nstatic bool sii8620_rcp_consume(struct sii8620 *ctx, u8 scancode)\n{\n\tbool pressed = !(scancode & MHL_RCP_KEY_RELEASED_MASK);\n\n\tscancode &= MHL_RCP_KEY_ID_MASK;\n\n\tif (!IS_ENABLED(CONFIG_RC_CORE) || !ctx->rc_dev)\n\t\treturn false;\n\n\tif (pressed)\n\t\trc_keydown(ctx->rc_dev, RC_PROTO_CEC, scancode, 0);\n\telse\n\t\trc_keyup(ctx->rc_dev);\n\n\treturn true;\n}\n\nstatic void sii8620_msc_mr_set_int(struct sii8620 *ctx)\n{\n\tu8 ints[MHL_INT_SIZE];\n\n\tsii8620_read_buf(ctx, REG_MHL_INT_0, ints, MHL_INT_SIZE);\n\tsii8620_write_buf(ctx, REG_MHL_INT_0, ints, MHL_INT_SIZE);\n\n\tif (ints[MHL_INT_RCHANGE] & MHL_INT_RC_DCAP_CHG) {\n\t\tswitch (ctx->mode) {\n\t\tcase CM_MHL3:\n\t\t\tsii8620_mt_read_xdevcap_reg(ctx, MHL_XDC_ECBUS_SPEEDS);\n\t\t\tsii8620_mt_set_cont(ctx, sii8620_got_ecbus_speed);\n\t\t\tbreak;\n\t\tcase CM_ECBUS_S:\n\t\t\tsii8620_mt_read_devcap(ctx, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ints[MHL_INT_RCHANGE] & MHL_INT_RC_FEAT_REQ)\n\t\tsii8620_send_features(ctx);\n\tif (ints[MHL_INT_RCHANGE] & MHL_INT_RC_FEAT_COMPLETE) {\n\t\tctx->feature_complete = true;\n\t\tif (ctx->edid)\n\t\t\tsii8620_enable_hpd(ctx);\n\t}\n}\n\nstatic struct sii8620_mt_msg *sii8620_msc_msg_first(struct sii8620 *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\n\tif (list_empty(&ctx->mt_queue)) {\n\t\tdev_err(dev, \"unexpected MSC MT response\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn list_first_entry(&ctx->mt_queue, struct sii8620_mt_msg, node);\n}\n\nstatic void sii8620_msc_mt_done(struct sii8620 *ctx)\n{\n\tstruct sii8620_mt_msg *msg = sii8620_msc_msg_first(ctx);\n\n\tif (!msg)\n\t\treturn;\n\n\tmsg->ret = sii8620_readb(ctx, REG_MSC_MT_RCVD_DATA0);\n\tctx->mt_state = MT_STATE_DONE;\n}\n\nstatic void sii8620_msc_mr_msc_msg(struct sii8620 *ctx)\n{\n\tstruct sii8620_mt_msg *msg;\n\tu8 buf[2];\n\n\tsii8620_read_buf(ctx, REG_MSC_MR_MSC_MSG_RCVD_1ST_DATA, buf, 2);\n\n\tswitch (buf[0]) {\n\tcase MHL_MSC_MSG_RAPK:\n\t\tmsg = sii8620_msc_msg_first(ctx);\n\t\tif (!msg)\n\t\t\treturn;\n\t\tmsg->ret = buf[1];\n\t\tctx->mt_state = MT_STATE_DONE;\n\t\tbreak;\n\tcase MHL_MSC_MSG_RCP:\n\t\tif (!sii8620_rcp_consume(ctx, buf[1]))\n\t\t\tsii8620_mt_rcpe(ctx,\n\t\t\t\t\tMHL_RCPE_STATUS_INEFFECTIVE_KEY_CODE);\n\t\tsii8620_mt_rcpk(ctx, buf[1]);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ctx->dev, \"%s message type %d,%d not supported\",\n\t\t\t__func__, buf[0], buf[1]);\n\t}\n}\n\nstatic void sii8620_irq_msc(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_CBUS_INT_0);\n\n\tif (stat & ~BIT_CBUS_HPD_CHG)\n\t\tsii8620_write(ctx, REG_CBUS_INT_0, stat & ~BIT_CBUS_HPD_CHG);\n\n\tif (stat & BIT_CBUS_HPD_CHG) {\n\t\tu8 cbus_stat = sii8620_readb(ctx, REG_CBUS_STATUS);\n\n\t\tif ((cbus_stat ^ ctx->cbus_status) & BIT_CBUS_STATUS_CBUS_HPD) {\n\t\t\tsii8620_write(ctx, REG_CBUS_INT_0, BIT_CBUS_HPD_CHG);\n\t\t} else {\n\t\t\tstat ^= BIT_CBUS_STATUS_CBUS_HPD;\n\t\t\tcbus_stat ^= BIT_CBUS_STATUS_CBUS_HPD;\n\t\t}\n\t\tctx->cbus_status = cbus_stat;\n\t}\n\n\tif (stat & BIT_CBUS_MSC_MR_WRITE_STAT)\n\t\tsii8620_msc_mr_write_stat(ctx);\n\n\tif (stat & BIT_CBUS_HPD_CHG) {\n\t\tif (ctx->cbus_status & BIT_CBUS_STATUS_CBUS_HPD) {\n\t\t\tctx->sink_detected = true;\n\t\t\tsii8620_identify_sink(ctx);\n\t\t} else {\n\t\t\tsii8620_hpd_unplugged(ctx);\n\t\t}\n\t}\n\n\tif (stat & BIT_CBUS_MSC_MR_SET_INT)\n\t\tsii8620_msc_mr_set_int(ctx);\n\n\tif (stat & BIT_CBUS_MSC_MT_DONE)\n\t\tsii8620_msc_mt_done(ctx);\n\n\tif (stat & BIT_CBUS_MSC_MR_MSC_MSG)\n\t\tsii8620_msc_mr_msc_msg(ctx);\n}\n\nstatic void sii8620_irq_coc(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_COC_INTR);\n\n\tif (stat & BIT_COC_CALIBRATION_DONE) {\n\t\tu8 cstat = sii8620_readb(ctx, REG_COC_STAT_0);\n\n\t\tcstat &= BIT_COC_STAT_0_PLL_LOCKED | MSK_COC_STAT_0_FSM_STATE;\n\t\tif (cstat == (BIT_COC_STAT_0_PLL_LOCKED | 0x02)) {\n\t\t\tsii8620_write_seq_static(ctx,\n\t\t\t\tREG_COC_CTLB, 0,\n\t\t\t\tREG_TRXINTMH, BIT_TDM_INTR_SYNC_DATA\n\t\t\t\t\t      | BIT_TDM_INTR_SYNC_WAIT\n\t\t\t);\n\t\t}\n\t}\n\n\tsii8620_write(ctx, REG_COC_INTR, stat);\n}\n\nstatic void sii8620_irq_merr(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_CBUS_INT_1);\n\n\tsii8620_write(ctx, REG_CBUS_INT_1, stat);\n}\n\nstatic void sii8620_irq_edid(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_INTR9);\n\n\tsii8620_write(ctx, REG_INTR9, stat);\n\n\tif (stat & BIT_INTR9_DEVCAP_DONE)\n\t\tctx->mt_state = MT_STATE_DONE;\n}\n\nstatic void sii8620_irq_scdt(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_INTR5);\n\n\tif (stat & BIT_INTR_SCDT_CHANGE) {\n\t\tu8 cstat = sii8620_readb(ctx, REG_TMDS_CSTAT_P3);\n\n\t\tif (cstat & BIT_TMDS_CSTAT_P3_SCDT)\n\t\t\tsii8620_start_video(ctx);\n\t}\n\n\tsii8620_write(ctx, REG_INTR5, stat);\n}\n\nstatic void sii8620_got_xdevcap(struct sii8620 *ctx, int ret)\n{\n\tif (ret < 0)\n\t\treturn;\n\n\tsii8620_mt_read_devcap(ctx, false);\n}\n\nstatic void sii8620_irq_tdm(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_TRXINTH);\n\tu8 tdm = sii8620_readb(ctx, REG_TRXSTA2);\n\n\tif ((tdm & MSK_TDM_SYNCHRONIZED) == VAL_TDM_SYNCHRONIZED) {\n\t\tctx->mode = CM_ECBUS_S;\n\t\tctx->burst.rx_ack = 0;\n\t\tctx->burst.r_size = SII8620_BURST_BUF_LEN;\n\t\tsii8620_burst_tx_rbuf_info(ctx, SII8620_BURST_BUF_LEN);\n\t\tsii8620_mt_read_devcap(ctx, true);\n\t\tsii8620_mt_set_cont(ctx, sii8620_got_xdevcap);\n\t} else {\n\t\tsii8620_write_seq_static(ctx,\n\t\t\tREG_MHL_PLL_CTL2, 0,\n\t\t\tREG_MHL_PLL_CTL2, BIT_MHL_PLL_CTL2_CLKDETECT_EN\n\t\t);\n\t}\n\n\tsii8620_write(ctx, REG_TRXINTH, stat);\n}\n\nstatic void sii8620_irq_block(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_EMSCINTR);\n\n\tif (stat & BIT_EMSCINTR_SPI_DVLD) {\n\t\tu8 bstat = sii8620_readb(ctx, REG_SPIBURSTSTAT);\n\n\t\tif (bstat & BIT_SPIBURSTSTAT_EMSC_NORMAL_MODE)\n\t\t\tsii8620_burst_receive(ctx);\n\t}\n\n\tsii8620_write(ctx, REG_EMSCINTR, stat);\n}\n\nstatic void sii8620_irq_ddc(struct sii8620 *ctx)\n{\n\tu8 stat = sii8620_readb(ctx, REG_INTR3);\n\n\tif (stat & BIT_DDC_CMD_DONE) {\n\t\tsii8620_write(ctx, REG_INTR3_MASK, 0);\n\t\tif (sii8620_is_mhl3(ctx) && !ctx->feature_complete)\n\t\t\tsii8620_mt_set_int(ctx, MHL_INT_REG(RCHANGE),\n\t\t\t\t\t   MHL_INT_RC_FEAT_REQ);\n\t\telse\n\t\t\tsii8620_enable_hpd(ctx);\n\t}\n\tsii8620_write(ctx, REG_INTR3, stat);\n}\n\n \nstatic bool sii8620_test_bit(unsigned int nr, const u8 *addr)\n{\n\treturn 1 & (addr[nr / BITS_PER_BYTE] >> (nr % BITS_PER_BYTE));\n}\n\nstatic irqreturn_t sii8620_irq_thread(int irq, void *data)\n{\n\tstatic const struct {\n\t\tint bit;\n\t\tvoid (*handler)(struct sii8620 *ctx);\n\t} irq_vec[] = {\n\t\t{ BIT_FAST_INTR_STAT_DISC, sii8620_irq_disc },\n\t\t{ BIT_FAST_INTR_STAT_G2WB, sii8620_irq_g2wb },\n\t\t{ BIT_FAST_INTR_STAT_COC, sii8620_irq_coc },\n\t\t{ BIT_FAST_INTR_STAT_TDM, sii8620_irq_tdm },\n\t\t{ BIT_FAST_INTR_STAT_MSC, sii8620_irq_msc },\n\t\t{ BIT_FAST_INTR_STAT_MERR, sii8620_irq_merr },\n\t\t{ BIT_FAST_INTR_STAT_BLOCK, sii8620_irq_block },\n\t\t{ BIT_FAST_INTR_STAT_EDID, sii8620_irq_edid },\n\t\t{ BIT_FAST_INTR_STAT_DDC, sii8620_irq_ddc },\n\t\t{ BIT_FAST_INTR_STAT_SCDT, sii8620_irq_scdt },\n\t};\n\tstruct sii8620 *ctx = data;\n\tu8 stats[LEN_FAST_INTR_STAT];\n\tint i, ret;\n\n\tmutex_lock(&ctx->lock);\n\n\tsii8620_read_buf(ctx, REG_FAST_INTR_STAT, stats, ARRAY_SIZE(stats));\n\tfor (i = 0; i < ARRAY_SIZE(irq_vec); ++i)\n\t\tif (sii8620_test_bit(irq_vec[i].bit, stats))\n\t\t\tirq_vec[i].handler(ctx);\n\n\tsii8620_burst_rx_all(ctx);\n\tsii8620_mt_work(ctx);\n\tsii8620_burst_send(ctx);\n\n\tret = sii8620_clear_error(ctx);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"Error during IRQ handling, %d.\\n\", ret);\n\t\tsii8620_mhl_disconnected(ctx);\n\t}\n\tmutex_unlock(&ctx->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sii8620_cable_in(struct sii8620 *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tu8 ver[5];\n\tint ret;\n\n\tret = sii8620_hw_on(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"Error powering on, %d.\\n\", ret);\n\t\treturn;\n\t}\n\n\tsii8620_read_buf(ctx, REG_VND_IDL, ver, ARRAY_SIZE(ver));\n\tret = sii8620_clear_error(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"Error accessing I2C bus, %d.\\n\", ret);\n\t\treturn;\n\t}\n\n\tdev_info(dev, \"ChipID %02x%02x:%02x%02x rev %02x.\\n\", ver[1], ver[0],\n\t\t ver[3], ver[2], ver[4]);\n\n\tsii8620_write(ctx, REG_DPD,\n\t\t      BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12 | BIT_DPD_OSC_EN);\n\n\tsii8620_xtal_set_rate(ctx);\n\tsii8620_disconnect(ctx);\n\n\tsii8620_write_seq_static(ctx,\n\t\tREG_MHL_CBUS_CTL0, VAL_MHL_CBUS_CTL0_CBUS_DRV_SEL_STRONG\n\t\t\t| VAL_MHL_CBUS_CTL0_CBUS_RGND_VBIAS_734,\n\t\tREG_MHL_CBUS_CTL1, VAL_MHL_CBUS_CTL1_1115_OHM,\n\t\tREG_DPD, BIT_DPD_PWRON_PLL | BIT_DPD_PDNTX12 | BIT_DPD_OSC_EN,\n\t);\n\n\tret = sii8620_clear_error(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"Error accessing I2C bus, %d.\\n\", ret);\n\t\treturn;\n\t}\n\n\tenable_irq(to_i2c_client(ctx->dev)->irq);\n}\n\nstatic void sii8620_init_rcp_input_dev(struct sii8620 *ctx)\n{\n\tstruct rc_dev *rc_dev;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_RC_CORE))\n\t\treturn;\n\n\trc_dev = rc_allocate_device(RC_DRIVER_SCANCODE);\n\tif (!rc_dev) {\n\t\tdev_err(ctx->dev, \"Failed to allocate RC device\\n\");\n\t\tctx->error = -ENOMEM;\n\t\treturn;\n\t}\n\n\trc_dev->input_phys = \"sii8620/input0\";\n\trc_dev->input_id.bustype = BUS_VIRTUAL;\n\trc_dev->map_name = RC_MAP_CEC;\n\trc_dev->allowed_protocols = RC_PROTO_BIT_CEC;\n\trc_dev->driver_name = \"sii8620\";\n\trc_dev->device_name = \"sii8620\";\n\n\tret = rc_register_device(rc_dev);\n\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"Failed to register RC device\\n\");\n\t\tctx->error = ret;\n\t\trc_free_device(rc_dev);\n\t\treturn;\n\t}\n\tctx->rc_dev = rc_dev;\n}\n\nstatic void sii8620_cable_out(struct sii8620 *ctx)\n{\n\tdisable_irq(to_i2c_client(ctx->dev)->irq);\n\tsii8620_hw_off(ctx);\n}\n\nstatic void sii8620_extcon_work(struct work_struct *work)\n{\n\tstruct sii8620 *ctx =\n\t\tcontainer_of(work, struct sii8620, extcon_wq);\n\tint state = extcon_get_state(ctx->extcon, EXTCON_DISP_MHL);\n\n\tif (state == ctx->cable_state)\n\t\treturn;\n\n\tctx->cable_state = state;\n\n\tif (state > 0)\n\t\tsii8620_cable_in(ctx);\n\telse\n\t\tsii8620_cable_out(ctx);\n}\n\nstatic int sii8620_extcon_notifier(struct notifier_block *self,\n\t\t\tunsigned long event, void *ptr)\n{\n\tstruct sii8620 *ctx =\n\t\tcontainer_of(self, struct sii8620, extcon_nb);\n\n\tschedule_work(&ctx->extcon_wq);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int sii8620_extcon_init(struct sii8620 *ctx)\n{\n\tstruct extcon_dev *edev;\n\tstruct device_node *musb, *muic;\n\tint ret;\n\n\t \n\tmusb = of_graph_get_remote_node(ctx->dev->of_node, 1, -1);\n\t \n\tmuic = of_get_next_parent(musb);\n\n\tif (!muic) {\n\t\tdev_info(ctx->dev, \"no extcon found, switching to 'always on' mode\\n\");\n\t\treturn 0;\n\t}\n\n\tedev = extcon_find_edev_by_node(muic);\n\tof_node_put(muic);\n\tif (IS_ERR(edev)) {\n\t\tif (PTR_ERR(edev) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_err(ctx->dev, \"Invalid or missing extcon\\n\");\n\t\treturn PTR_ERR(edev);\n\t}\n\n\tctx->extcon = edev;\n\tctx->extcon_nb.notifier_call = sii8620_extcon_notifier;\n\tINIT_WORK(&ctx->extcon_wq, sii8620_extcon_work);\n\tret = extcon_register_notifier(edev, EXTCON_DISP_MHL, &ctx->extcon_nb);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"failed to register notifier for MHL\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline struct sii8620 *bridge_to_sii8620(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct sii8620, bridge);\n}\n\nstatic int sii8620_attach(struct drm_bridge *bridge,\n\t\t\t  enum drm_bridge_attach_flags flags)\n{\n\tstruct sii8620 *ctx = bridge_to_sii8620(bridge);\n\n\tsii8620_init_rcp_input_dev(ctx);\n\n\treturn sii8620_clear_error(ctx);\n}\n\nstatic void sii8620_detach(struct drm_bridge *bridge)\n{\n\tstruct sii8620 *ctx = bridge_to_sii8620(bridge);\n\n\tif (!IS_ENABLED(CONFIG_RC_CORE))\n\t\treturn;\n\n\trc_unregister_device(ctx->rc_dev);\n}\n\nstatic int sii8620_is_packing_required(struct sii8620 *ctx,\n\t\t\t\t       const struct drm_display_mode *mode)\n{\n\tint max_pclk, max_pclk_pp_mode;\n\n\tif (sii8620_is_mhl3(ctx)) {\n\t\tmax_pclk = MHL3_MAX_PCLK;\n\t\tmax_pclk_pp_mode = MHL3_MAX_PCLK_PP_MODE;\n\t} else {\n\t\tmax_pclk = MHL1_MAX_PCLK;\n\t\tmax_pclk_pp_mode = MHL1_MAX_PCLK_PP_MODE;\n\t}\n\n\tif (mode->clock < max_pclk)\n\t\treturn 0;\n\telse if (mode->clock < max_pclk_pp_mode)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}\n\nstatic enum drm_mode_status sii8620_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t const struct drm_display_info *info,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct sii8620 *ctx = bridge_to_sii8620(bridge);\n\tint pack_required = sii8620_is_packing_required(ctx, mode);\n\tbool can_pack = ctx->devcap[MHL_DCAP_VID_LINK_MODE] &\n\t\t\tMHL_DCAP_VID_LINK_PPIXEL;\n\n\tswitch (pack_required) {\n\tcase 0:\n\t\treturn MODE_OK;\n\tcase 1:\n\t\treturn (can_pack) ? MODE_OK : MODE_CLOCK_HIGH;\n\tdefault:\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n}\n\nstatic bool sii8620_mode_fixup(struct drm_bridge *bridge,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tstruct sii8620 *ctx = bridge_to_sii8620(bridge);\n\n\tmutex_lock(&ctx->lock);\n\n\tctx->use_packed_pixel = sii8620_is_packing_required(ctx, adjusted_mode);\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn true;\n}\n\nstatic const struct drm_bridge_funcs sii8620_bridge_funcs = {\n\t.attach = sii8620_attach,\n\t.detach = sii8620_detach,\n\t.mode_fixup = sii8620_mode_fixup,\n\t.mode_valid = sii8620_mode_valid,\n};\n\nstatic int sii8620_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct sii8620 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tmutex_init(&ctx->lock);\n\tINIT_LIST_HEAD(&ctx->mt_queue);\n\n\tctx->clk_xtal = devm_clk_get(dev, \"xtal\");\n\tif (IS_ERR(ctx->clk_xtal))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->clk_xtal),\n\t\t\t\t     \"failed to get xtal clock from DT\\n\");\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"no irq provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\tirq_set_status_flags(client->irq, IRQ_NOAUTOEN);\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tsii8620_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"sii8620\", ctx);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"failed to install IRQ handler\\n\");\n\n\tctx->gpio_reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ctx->gpio_reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->gpio_reset),\n\t\t\t\t     \"failed to get reset gpio from DT\\n\");\n\n\tctx->supplies[0].supply = \"cvcc10\";\n\tctx->supplies[1].supply = \"iovcc18\";\n\tret = devm_regulator_bulk_get(dev, 2, ctx->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sii8620_extcon_init(ctx);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"failed to initialize EXTCON\\n\");\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(client, ctx);\n\n\tctx->bridge.funcs = &sii8620_bridge_funcs;\n\tctx->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&ctx->bridge);\n\n\tif (!ctx->extcon)\n\t\tsii8620_cable_in(ctx);\n\n\treturn 0;\n}\n\nstatic void sii8620_remove(struct i2c_client *client)\n{\n\tstruct sii8620 *ctx = i2c_get_clientdata(client);\n\n\tif (ctx->extcon) {\n\t\textcon_unregister_notifier(ctx->extcon, EXTCON_DISP_MHL,\n\t\t\t\t\t   &ctx->extcon_nb);\n\t\tflush_work(&ctx->extcon_wq);\n\t\tif (ctx->cable_state > 0)\n\t\t\tsii8620_cable_out(ctx);\n\t} else {\n\t\tsii8620_cable_out(ctx);\n\t}\n\tdrm_bridge_remove(&ctx->bridge);\n}\n\nstatic const struct of_device_id sii8620_dt_match[] = {\n\t{ .compatible = \"sil,sii8620\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sii8620_dt_match);\n\nstatic const struct i2c_device_id sii8620_id[] = {\n\t{ \"sii8620\", 0 },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, sii8620_id);\nstatic struct i2c_driver sii8620_driver = {\n\t.driver = {\n\t\t.name\t= \"sii8620\",\n\t\t.of_match_table = sii8620_dt_match,\n\t},\n\t.probe\t\t= sii8620_probe,\n\t.remove\t\t= sii8620_remove,\n\t.id_table = sii8620_id,\n};\n\nmodule_i2c_driver(sii8620_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}