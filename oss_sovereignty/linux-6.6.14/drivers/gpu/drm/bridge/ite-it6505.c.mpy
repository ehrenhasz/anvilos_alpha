{
  "module_name": "ite-it6505.c",
  "hash_id": "ed719a45d5aa035398288e400f5e2d3036dc81a6bc49492ed523825194471bb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ite-it6505.c",
  "human_readable_source": "\n \n#include <linux/bits.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/extcon.h>\n#include <linux/fs.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\n#include <crypto/hash.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include <sound/hdmi-codec.h>\n\n#define REG_IC_VER 0x04\n\n#define REG_RESET_CTRL 0x05\n#define VIDEO_RESET BIT(0)\n#define AUDIO_RESET BIT(1)\n#define ALL_LOGIC_RESET BIT(2)\n#define AUX_RESET BIT(3)\n#define HDCP_RESET BIT(4)\n\n#define INT_STATUS_01 0x06\n#define INT_MASK_01 0x09\n#define INT_HPD_CHANGE 0\n#define INT_RECEIVE_HPD_IRQ 1\n#define INT_SCDT_CHANGE 2\n#define INT_HDCP_FAIL 3\n#define INT_HDCP_DONE 4\n#define BIT_OFFSET(x) (((x) - INT_STATUS_01) * BITS_PER_BYTE)\n#define BIT_INT_HPD INT_HPD_CHANGE\n#define BIT_INT_HPD_IRQ INT_RECEIVE_HPD_IRQ\n#define BIT_INT_SCDT INT_SCDT_CHANGE\n#define BIT_INT_HDCP_FAIL INT_HDCP_FAIL\n#define BIT_INT_HDCP_DONE INT_HDCP_DONE\n\n#define INT_STATUS_02 0x07\n#define INT_MASK_02 0x0A\n#define INT_AUX_CMD_FAIL 0\n#define INT_HDCP_KSV_CHECK 1\n#define INT_AUDIO_FIFO_ERROR 2\n#define BIT_INT_AUX_CMD_FAIL (BIT_OFFSET(0x07) + INT_AUX_CMD_FAIL)\n#define BIT_INT_HDCP_KSV_CHECK (BIT_OFFSET(0x07) + INT_HDCP_KSV_CHECK)\n#define BIT_INT_AUDIO_FIFO_ERROR (BIT_OFFSET(0x07) + INT_AUDIO_FIFO_ERROR)\n\n#define INT_STATUS_03 0x08\n#define INT_MASK_03 0x0B\n#define INT_LINK_TRAIN_FAIL 4\n#define INT_VID_FIFO_ERROR 5\n#define INT_IO_LATCH_FIFO_OVERFLOW 7\n#define BIT_INT_LINK_TRAIN_FAIL (BIT_OFFSET(0x08) + INT_LINK_TRAIN_FAIL)\n#define BIT_INT_VID_FIFO_ERROR (BIT_OFFSET(0x08) + INT_VID_FIFO_ERROR)\n#define BIT_INT_IO_FIFO_OVERFLOW (BIT_OFFSET(0x08) + INT_IO_LATCH_FIFO_OVERFLOW)\n\n#define REG_SYSTEM_STS 0x0D\n#define INT_STS BIT(0)\n#define HPD_STS BIT(1)\n#define VIDEO_STB BIT(2)\n\n#define REG_LINK_TRAIN_STS 0x0E\n#define LINK_STATE_CR BIT(2)\n#define LINK_STATE_EQ BIT(3)\n#define LINK_STATE_NORP BIT(4)\n\n#define REG_BANK_SEL 0x0F\n#define REG_CLK_CTRL0 0x10\n#define M_PCLK_DELAY 0x03\n\n#define REG_AUX_OPT 0x11\n#define AUX_AUTO_RST BIT(0)\n#define AUX_FIX_FREQ BIT(3)\n\n#define REG_DATA_CTRL0 0x12\n#define VIDEO_LATCH_EDGE BIT(4)\n#define ENABLE_PCLK_COUNTER BIT(7)\n\n#define REG_PCLK_COUNTER_VALUE 0x13\n\n#define REG_501_FIFO_CTRL 0x15\n#define RST_501_FIFO BIT(1)\n\n#define REG_TRAIN_CTRL0 0x16\n#define FORCE_LBR BIT(0)\n#define LANE_COUNT_MASK 0x06\n#define LANE_SWAP BIT(3)\n#define SPREAD_AMP_5 BIT(4)\n#define FORCE_CR_DONE BIT(5)\n#define FORCE_EQ_DONE BIT(6)\n\n#define REG_TRAIN_CTRL1 0x17\n#define AUTO_TRAIN BIT(0)\n#define MANUAL_TRAIN BIT(1)\n#define FORCE_RETRAIN BIT(2)\n\n#define REG_AUX_CTRL 0x23\n#define CLR_EDID_FIFO BIT(0)\n#define AUX_USER_MODE BIT(1)\n#define AUX_NO_SEGMENT_WR BIT(6)\n#define AUX_EN_FIFO_READ BIT(7)\n\n#define REG_AUX_ADR_0_7 0x24\n#define REG_AUX_ADR_8_15 0x25\n#define REG_AUX_ADR_16_19 0x26\n#define REG_AUX_OUT_DATA0 0x27\n\n#define REG_AUX_CMD_REQ 0x2B\n#define AUX_BUSY BIT(5)\n\n#define REG_AUX_DATA_0_7 0x2C\n#define REG_AUX_DATA_8_15 0x2D\n#define REG_AUX_DATA_16_23 0x2E\n#define REG_AUX_DATA_24_31 0x2F\n\n#define REG_AUX_DATA_FIFO 0x2F\n\n#define REG_AUX_ERROR_STS 0x9F\n#define M_AUX_REQ_FAIL 0x03\n\n#define REG_HDCP_CTRL1 0x38\n#define HDCP_CP_ENABLE BIT(0)\n\n#define REG_HDCP_TRIGGER 0x39\n#define HDCP_TRIGGER_START  BIT(0)\n#define HDCP_TRIGGER_CPIRQ  BIT(1)\n#define HDCP_TRIGGER_KSV_DONE  BIT(4)\n#define HDCP_TRIGGER_KSV_FAIL BIT(5)\n\n#define REG_HDCP_CTRL2 0x3A\n#define HDCP_AN_SEL BIT(0)\n#define HDCP_AN_GEN BIT(1)\n#define HDCP_HW_HPDIRQ_ACT BIT(2)\n#define HDCP_EN_M0_READ BIT(5)\n\n#define REG_M0_0_7 0x4C\n#define REG_AN_0_7 0x4C\n#define REG_SP_CTRL0 0x58\n#define REG_IP_CTRL1 0x59\n#define REG_IP_CTRL2 0x5A\n\n#define REG_LINK_DRV 0x5C\n#define DRV_HS BIT(1)\n\n#define REG_DRV_LN_DATA_SEL 0x5D\n\n#define REG_AUX 0x5E\n\n#define REG_VID_BUS_CTRL0 0x60\n#define IN_DDR BIT(2)\n#define DDR_CD (0x01 << 6)\n\n#define REG_VID_BUS_CTRL1 0x61\n#define TX_FIFO_RESET BIT(1)\n\n#define REG_INPUT_CTRL 0xA0\n#define INPUT_HSYNC_POL BIT(0)\n#define INPUT_VSYNC_POL BIT(2)\n#define INPUT_INTERLACED BIT(4)\n\n#define REG_INPUT_HTOTAL 0xA1\n#define REG_INPUT_HACTIVE_START 0xA3\n#define REG_INPUT_HACTIVE_WIDTH 0xA5\n#define REG_INPUT_HFRONT_PORCH 0xA7\n#define REG_INPUT_HSYNC_WIDTH 0xA9\n#define REG_INPUT_VTOTAL 0xAB\n#define REG_INPUT_VACTIVE_START 0xAD\n#define REG_INPUT_VACTIVE_WIDTH 0xAF\n#define REG_INPUT_VFRONT_PORCH 0xB1\n#define REG_INPUT_VSYNC_WIDTH 0xB3\n\n#define REG_AUDIO_SRC_CTRL 0xB8\n#define M_AUDIO_I2S_EN 0x0F\n#define EN_I2S0 BIT(0)\n#define EN_I2S1 BIT(1)\n#define EN_I2S2 BIT(2)\n#define EN_I2S3 BIT(3)\n#define AUDIO_FIFO_RESET BIT(7)\n\n#define REG_AUDIO_FMT 0xB9\n#define REG_AUDIO_FIFO_SEL 0xBA\n\n#define REG_AUDIO_CTRL0 0xBB\n#define AUDIO_FULL_PKT BIT(4)\n#define AUDIO_16B_BOUND BIT(5)\n\n#define REG_AUDIO_CTRL1 0xBC\n#define REG_AUDIO_INPUT_FREQ 0xBE\n\n#define REG_IEC958_STS0 0xBF\n#define REG_IEC958_STS1 0xC0\n#define REG_IEC958_STS2 0xC1\n#define REG_IEC958_STS3 0xC2\n#define REG_IEC958_STS4 0xC3\n\n#define REG_HPD_IRQ_TIME 0xC9\n#define REG_AUX_DEBUG_MODE 0xCA\n#define REG_AUX_OPT2 0xCB\n#define REG_HDCP_OPT 0xCE\n#define REG_USER_DRV_PRE 0xCF\n\n#define REG_DATA_MUTE_CTRL 0xD3\n#define ENABLE_ENHANCED_FRAME BIT(0)\n#define ENABLE_AUTO_VIDEO_FIFO_RESET BIT(1)\n#define EN_VID_MUTE BIT(4)\n#define EN_AUD_MUTE BIT(5)\n\n#define REG_TIME_STMP_CTRL 0xD4\n#define EN_ENHANCE_VID_STMP BIT(0)\n#define EN_ENHANCE_AUD_STMP BIT(2)\n#define M_STAMP_STEP 0x30\n#define EN_SSC_GAT BIT(6)\n\n#define REG_INFOFRAME_CTRL 0xE8\n#define EN_AVI_PKT BIT(0)\n#define EN_AUD_PKT BIT(1)\n#define EN_MPG_PKT BIT(2)\n#define EN_GEN_PKT BIT(3)\n#define EN_VID_TIME_STMP BIT(4)\n#define EN_AUD_TIME_STMP BIT(5)\n#define EN_VID_CTRL_PKT (EN_AVI_PKT | EN_VID_TIME_STMP)\n#define EN_AUD_CTRL_PKT (EN_AUD_PKT | EN_AUD_TIME_STMP)\n\n#define REG_AUDIO_N_0_7 0xDE\n#define REG_AUDIO_N_8_15 0xDF\n#define REG_AUDIO_N_16_23 0xE0\n\n#define REG_AVI_INFO_DB1 0xE9\n#define REG_AVI_INFO_DB2 0xEA\n#define REG_AVI_INFO_DB3 0xEB\n#define REG_AVI_INFO_DB4 0xEC\n#define REG_AVI_INFO_DB5 0xED\n#define REG_AVI_INFO_SUM 0xF6\n\n#define REG_AUD_INFOFRAM_DB1 0xF7\n#define REG_AUD_INFOFRAM_DB2 0xF8\n#define REG_AUD_INFOFRAM_DB3 0xF9\n#define REG_AUD_INFOFRAM_DB4 0xFA\n#define REG_AUD_INFOFRAM_SUM 0xFB\n\n \n#define REG_DRV_0_DB_800_MV 0x17E\n#define REG_PRE_0_DB_800_MV 0x17F\n#define REG_PRE_3P5_DB_800_MV 0x181\n#define REG_SSC_CTRL0 0x188\n#define REG_SSC_CTRL1 0x189\n#define REG_SSC_CTRL2 0x18A\n\n#define RBR DP_LINK_BW_1_62\n#define HBR DP_LINK_BW_2_7\n#define HBR2 DP_LINK_BW_5_4\n#define HBR3 DP_LINK_BW_8_1\n\n#define DPCD_V_1_1 0x11\n#define MISC_VERB 0xF0\n#define MISC_VERC 0x70\n#define I2S_INPUT_FORMAT_STANDARD 0\n#define I2S_INPUT_FORMAT_32BIT 1\n#define I2S_INPUT_LEFT_JUSTIFIED 0\n#define I2S_INPUT_RIGHT_JUSTIFIED 1\n#define I2S_DATA_1T_DELAY 0\n#define I2S_DATA_NO_DELAY 1\n#define I2S_WS_LEFT_CHANNEL 0\n#define I2S_WS_RIGHT_CHANNEL 1\n#define I2S_DATA_MSB_FIRST 0\n#define I2S_DATA_LSB_FIRST 1\n#define WORD_LENGTH_16BIT 0\n#define WORD_LENGTH_18BIT 1\n#define WORD_LENGTH_20BIT 2\n#define WORD_LENGTH_24BIT 3\n#define DEBUGFS_DIR_NAME \"it6505-debugfs\"\n#define READ_BUFFER_SIZE 400\n\n \n#define HDCP_DESIRED 1\n#define MAX_LANE_COUNT 4\n#define MAX_LINK_RATE HBR\n#define AUTO_TRAIN_RETRY 3\n#define MAX_HDCP_DOWN_STREAM_COUNT 10\n#define MAX_CR_LEVEL 0x03\n#define MAX_EQ_LEVEL 0x03\n#define AUX_WAIT_TIMEOUT_MS 15\n#define AUX_FIFO_MAX_SIZE 32\n#define PIXEL_CLK_DELAY 1\n#define PIXEL_CLK_INVERSE 0\n#define ADJUST_PHASE_THRESHOLD 80000\n#define DPI_PIXEL_CLK_MAX 95000\n#define HDCP_SHA1_FIFO_LEN (MAX_HDCP_DOWN_STREAM_COUNT * 5 + 10)\n#define DEFAULT_PWR_ON 0\n#define DEFAULT_DRV_HOLD 0\n\n#define AUDIO_SELECT I2S\n#define AUDIO_TYPE LPCM\n#define AUDIO_SAMPLE_RATE SAMPLE_RATE_48K\n#define AUDIO_CHANNEL_COUNT 2\n#define I2S_INPUT_FORMAT I2S_INPUT_FORMAT_32BIT\n#define I2S_JUSTIFIED I2S_INPUT_LEFT_JUSTIFIED\n#define I2S_DATA_DELAY I2S_DATA_1T_DELAY\n#define I2S_WS_CHANNEL I2S_WS_LEFT_CHANNEL\n#define I2S_DATA_SEQUENCE I2S_DATA_MSB_FIRST\n#define AUDIO_WORD_LENGTH WORD_LENGTH_24BIT\n\nenum aux_cmd_type {\n\tCMD_AUX_NATIVE_READ = 0x0,\n\tCMD_AUX_NATIVE_WRITE = 0x5,\n\tCMD_AUX_I2C_EDID_READ = 0xB,\n};\n\nenum aux_cmd_reply {\n\tREPLY_ACK,\n\tREPLY_NACK,\n\tREPLY_DEFER,\n};\n\nenum link_train_status {\n\tLINK_IDLE,\n\tLINK_BUSY,\n\tLINK_OK,\n};\n\nenum hdcp_state {\n\tHDCP_AUTH_IDLE,\n\tHDCP_AUTH_GOING,\n\tHDCP_AUTH_DONE,\n};\n\nstruct it6505_platform_data {\n\tstruct regulator *pwr18;\n\tstruct regulator *ovdd;\n\tstruct gpio_desc *gpiod_reset;\n};\n\nenum it6505_audio_select {\n\tI2S = 0,\n\tSPDIF,\n};\n\nenum it6505_audio_sample_rate {\n\tSAMPLE_RATE_24K = 0x6,\n\tSAMPLE_RATE_32K = 0x3,\n\tSAMPLE_RATE_48K = 0x2,\n\tSAMPLE_RATE_96K = 0xA,\n\tSAMPLE_RATE_192K = 0xE,\n\tSAMPLE_RATE_44_1K = 0x0,\n\tSAMPLE_RATE_88_2K = 0x8,\n\tSAMPLE_RATE_176_4K = 0xC,\n};\n\nenum it6505_audio_type {\n\tLPCM = 0,\n\tNLPCM,\n\tDSS,\n};\n\nstruct it6505_audio_data {\n\tenum it6505_audio_select select;\n\tenum it6505_audio_sample_rate sample_rate;\n\tenum it6505_audio_type type;\n\tu8 word_length;\n\tu8 channel_count;\n\tu8 i2s_input_format;\n\tu8 i2s_justified;\n\tu8 i2s_data_delay;\n\tu8 i2s_ws_channel;\n\tu8 i2s_data_sequence;\n};\n\nstruct it6505_audio_sample_rate_map {\n\tenum it6505_audio_sample_rate rate;\n\tint sample_rate_value;\n};\n\nstruct it6505_drm_dp_link {\n\tunsigned char revision;\n\tunsigned int rate;\n\tunsigned int num_lanes;\n\tunsigned long capabilities;\n};\n\nstruct debugfs_entries {\n\tchar *name;\n\tconst struct file_operations *fops;\n};\n\nstruct it6505 {\n\tstruct drm_dp_aux aux;\n\tstruct drm_bridge bridge;\n\tstruct device *dev;\n\tstruct it6505_drm_dp_link link;\n\tstruct it6505_platform_data pdata;\n\t \n\tstruct mutex extcon_lock;\n\tstruct mutex mode_lock;  \n\tstruct mutex aux_lock;  \n\tstruct regmap *regmap;\n\tstruct drm_display_mode source_output_mode;\n\tstruct drm_display_mode video_info;\n\tstruct notifier_block event_nb;\n\tstruct extcon_dev *extcon;\n\tstruct work_struct extcon_wq;\n\tint extcon_state;\n\tenum drm_connector_status connector_status;\n\tenum link_train_status link_state;\n\tstruct work_struct link_works;\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\tu8 lane_count;\n\tu8 link_rate_bw_code;\n\tu8 sink_count;\n\tbool step_train;\n\tbool branch_device;\n\tbool enable_ssc;\n\tbool lane_swap_disabled;\n\tbool lane_swap;\n\tbool powered;\n\tbool hpd_state;\n\tu32 afe_setting;\n\tu32 max_dpi_pixel_clock;\n\tu32 max_lane_count;\n\tenum hdcp_state hdcp_status;\n\tstruct delayed_work hdcp_work;\n\tstruct work_struct hdcp_wait_ksv_list;\n\tstruct completion extcon_completion;\n\tu8 auto_train_retry;\n\tbool hdcp_desired;\n\tbool is_repeater;\n\tu8 hdcp_down_stream_count;\n\tu8 bksvs[DRM_HDCP_KSV_LEN];\n\tu8 sha1_input[HDCP_SHA1_FIFO_LEN];\n\tbool enable_enhanced_frame;\n\thdmi_codec_plugged_cb plugged_cb;\n\tstruct device *codec_dev;\n\tstruct delayed_work delayed_audio;\n\tstruct it6505_audio_data audio;\n\tstruct dentry *debugfs;\n\n\t \n\tbool enable_drv_hold;\n\n\tstruct edid *cached_edid;\n};\n\nstruct it6505_step_train_para {\n\tu8 voltage_swing[MAX_LANE_COUNT];\n\tu8 pre_emphasis[MAX_LANE_COUNT];\n};\n\n \n\nstatic const u8 afe_setting_table[][3] = {\n\t{0x82, 0x00, 0x45},\n\t{0x93, 0x2A, 0x85}\n};\n\nstatic const struct it6505_audio_sample_rate_map audio_sample_rate_map[] = {\n\t{SAMPLE_RATE_24K, 24000},\n\t{SAMPLE_RATE_32K, 32000},\n\t{SAMPLE_RATE_48K, 48000},\n\t{SAMPLE_RATE_96K, 96000},\n\t{SAMPLE_RATE_192K, 192000},\n\t{SAMPLE_RATE_44_1K, 44100},\n\t{SAMPLE_RATE_88_2K, 88200},\n\t{SAMPLE_RATE_176_4K, 176400},\n};\n\nstatic const struct regmap_range it6505_bridge_volatile_ranges[] = {\n\t{ .range_min = 0, .range_max = 0x1FF },\n};\n\nstatic const struct regmap_access_table it6505_bridge_volatile_table = {\n\t.yes_ranges = it6505_bridge_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(it6505_bridge_volatile_ranges),\n};\n\nstatic const struct regmap_range_cfg it6505_regmap_banks[] = {\n\t{\n\t\t.name = \"it6505\",\n\t\t.range_min = 0x00,\n\t\t.range_max = 0x1FF,\n\t\t.selector_reg = REG_BANK_SEL,\n\t\t.selector_mask = 0x1,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0x00,\n\t\t.window_len = 0x100,\n\t},\n};\n\nstatic const struct regmap_config it6505_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_table = &it6505_bridge_volatile_table,\n\t.cache_type = REGCACHE_NONE,\n\t.ranges = it6505_regmap_banks,\n\t.num_ranges = ARRAY_SIZE(it6505_regmap_banks),\n\t.max_register = 0x1FF,\n};\n\nstatic int it6505_read(struct it6505 *it6505, unsigned int reg_addr)\n{\n\tunsigned int value;\n\tint err;\n\tstruct device *dev = it6505->dev;\n\n\tif (!it6505->powered)\n\t\treturn -ENODEV;\n\n\terr = regmap_read(it6505->regmap, reg_addr, &value);\n\tif (err < 0) {\n\t\tdev_err(dev, \"read failed reg[0x%x] err: %d\", reg_addr, err);\n\t\treturn err;\n\t}\n\n\treturn value;\n}\n\nstatic int it6505_write(struct it6505 *it6505, unsigned int reg_addr,\n\t\t\tunsigned int reg_val)\n{\n\tint err;\n\tstruct device *dev = it6505->dev;\n\n\tif (!it6505->powered)\n\t\treturn -ENODEV;\n\n\terr = regmap_write(it6505->regmap, reg_addr, reg_val);\n\n\tif (err < 0) {\n\t\tdev_err(dev, \"write failed reg[0x%x] = 0x%x err = %d\",\n\t\t\treg_addr, reg_val, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int it6505_set_bits(struct it6505 *it6505, unsigned int reg,\n\t\t\t   unsigned int mask, unsigned int value)\n{\n\tint err;\n\tstruct device *dev = it6505->dev;\n\n\tif (!it6505->powered)\n\t\treturn -ENODEV;\n\n\terr = regmap_update_bits(it6505->regmap, reg, mask, value);\n\tif (err < 0) {\n\t\tdev_err(dev, \"write reg[0x%x] = 0x%x mask = 0x%x failed err %d\",\n\t\t\treg, value, mask, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void it6505_debug_print(struct it6505 *it6505, unsigned int reg,\n\t\t\t       const char *prefix)\n{\n\tstruct device *dev = it6505->dev;\n\tint val;\n\n\tif (!drm_debug_enabled(DRM_UT_DRIVER))\n\t\treturn;\n\n\tval = it6505_read(it6505, reg);\n\tif (val < 0)\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"%s reg[%02x] read error (%d)\",\n\t\t\t\t     prefix, reg, val);\n\telse\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"%s reg[%02x] = 0x%02x\", prefix, reg,\n\t\t\t\t     val);\n}\n\nstatic int it6505_dpcd_read(struct it6505 *it6505, unsigned long offset)\n{\n\tu8 value;\n\tint ret;\n\tstruct device *dev = it6505->dev;\n\n\tret = drm_dp_dpcd_readb(&it6505->aux, offset, &value);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"DPCD read failed [0x%lx] ret: %d\", offset, ret);\n\t\treturn ret;\n\t}\n\treturn value;\n}\n\nstatic int it6505_dpcd_write(struct it6505 *it6505, unsigned long offset,\n\t\t\t     u8 datain)\n{\n\tint ret;\n\tstruct device *dev = it6505->dev;\n\n\tret = drm_dp_dpcd_writeb(&it6505->aux, offset, datain);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"DPCD write failed [0x%lx] ret: %d\", offset, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int it6505_get_dpcd(struct it6505 *it6505, int offset, u8 *dpcd, int num)\n{\n\tint ret;\n\tstruct device *dev = it6505->dev;\n\n\tret = drm_dp_dpcd_read(&it6505->aux, offset, dpcd, num);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"ret = %d DPCD[0x%x] = 0x%*ph\", ret, offset,\n\t\t\t     num, dpcd);\n\n\treturn 0;\n}\n\nstatic void it6505_dump(struct it6505 *it6505)\n{\n\tunsigned int i, j;\n\tu8 regs[16];\n\tstruct device *dev = it6505->dev;\n\n\tfor (i = 0; i <= 0xff; i += 16) {\n\t\tfor (j = 0; j < 16; j++)\n\t\t\tregs[j] = it6505_read(it6505, i + j);\n\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"[0x%02x] = %16ph\", i, regs);\n\t}\n}\n\nstatic bool it6505_get_sink_hpd_status(struct it6505 *it6505)\n{\n\tint reg_0d;\n\n\treg_0d = it6505_read(it6505, REG_SYSTEM_STS);\n\n\tif (reg_0d < 0)\n\t\treturn false;\n\n\treturn reg_0d & HPD_STS;\n}\n\nstatic int it6505_read_word(struct it6505 *it6505, unsigned int reg)\n{\n\tint val0, val1;\n\n\tval0 = it6505_read(it6505, reg);\n\tif (val0 < 0)\n\t\treturn val0;\n\n\tval1 = it6505_read(it6505, reg + 1);\n\tif (val1 < 0)\n\t\treturn val1;\n\n\treturn (val1 << 8) | val0;\n}\n\nstatic void it6505_calc_video_info(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tint hsync_pol, vsync_pol, interlaced;\n\tint htotal, hdes, hdew, hfph, hsyncw;\n\tint vtotal, vdes, vdew, vfph, vsyncw;\n\tint rddata, i, pclk, sum = 0;\n\n\tusleep_range(10000, 15000);\n\trddata = it6505_read(it6505, REG_INPUT_CTRL);\n\thsync_pol = rddata & INPUT_HSYNC_POL;\n\tvsync_pol = (rddata & INPUT_VSYNC_POL) >> 2;\n\tinterlaced = (rddata & INPUT_INTERLACED) >> 4;\n\n\thtotal = it6505_read_word(it6505, REG_INPUT_HTOTAL) & 0x1FFF;\n\thdes = it6505_read_word(it6505, REG_INPUT_HACTIVE_START) & 0x1FFF;\n\thdew = it6505_read_word(it6505, REG_INPUT_HACTIVE_WIDTH) & 0x1FFF;\n\thfph = it6505_read_word(it6505, REG_INPUT_HFRONT_PORCH) & 0x1FFF;\n\thsyncw = it6505_read_word(it6505, REG_INPUT_HSYNC_WIDTH) & 0x1FFF;\n\n\tvtotal = it6505_read_word(it6505, REG_INPUT_VTOTAL) & 0xFFF;\n\tvdes = it6505_read_word(it6505, REG_INPUT_VACTIVE_START) & 0xFFF;\n\tvdew = it6505_read_word(it6505, REG_INPUT_VACTIVE_WIDTH) & 0xFFF;\n\tvfph = it6505_read_word(it6505, REG_INPUT_VFRONT_PORCH) & 0xFFF;\n\tvsyncw = it6505_read_word(it6505, REG_INPUT_VSYNC_WIDTH) & 0xFFF;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hsync_pol:%d, vsync_pol:%d, interlaced:%d\",\n\t\t\t     hsync_pol, vsync_pol, interlaced);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hactive_start:%d, vactive_start:%d\",\n\t\t\t     hdes, vdes);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tit6505_set_bits(it6505, REG_DATA_CTRL0, ENABLE_PCLK_COUNTER,\n\t\t\t\tENABLE_PCLK_COUNTER);\n\t\tusleep_range(10000, 15000);\n\t\tit6505_set_bits(it6505, REG_DATA_CTRL0, ENABLE_PCLK_COUNTER,\n\t\t\t\t0x00);\n\t\trddata = it6505_read_word(it6505, REG_PCLK_COUNTER_VALUE) &\n\t\t\t 0xFFF;\n\n\t\tsum += rddata;\n\t}\n\n\tif (sum == 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"calc video timing error\");\n\t\treturn;\n\t}\n\n\tsum /= 3;\n\tpclk = 13500 * 2048 / sum;\n\tit6505->video_info.clock = pclk;\n\tit6505->video_info.hdisplay = hdew;\n\tit6505->video_info.hsync_start = hdew + hfph;\n\tit6505->video_info.hsync_end = hdew + hfph + hsyncw;\n\tit6505->video_info.htotal = htotal;\n\tit6505->video_info.vdisplay = vdew;\n\tit6505->video_info.vsync_start = vdew + vfph;\n\tit6505->video_info.vsync_end = vdew + vfph + vsyncw;\n\tit6505->video_info.vtotal = vtotal;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, DRM_MODE_FMT,\n\t\t\t     DRM_MODE_ARG(&it6505->video_info));\n}\n\nstatic int it6505_drm_dp_link_set_power(struct drm_dp_aux *aux,\n\t\t\t\t\tstruct it6505_drm_dp_link *link,\n\t\t\t\t\tu8 mode)\n{\n\tu8 value;\n\tint err;\n\n\t \n\tif (link->revision < DPCD_V_1_1)\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= mode;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (mode == DP_SET_POWER_D0) {\n\t\t \n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn 0;\n}\n\nstatic void it6505_clear_int(struct it6505 *it6505)\n{\n\tit6505_write(it6505, INT_STATUS_01, 0xFF);\n\tit6505_write(it6505, INT_STATUS_02, 0xFF);\n\tit6505_write(it6505, INT_STATUS_03, 0xFF);\n}\n\nstatic void it6505_int_mask_enable(struct it6505 *it6505)\n{\n\tit6505_write(it6505, INT_MASK_01, BIT(INT_HPD_CHANGE) |\n\t\t     BIT(INT_RECEIVE_HPD_IRQ) | BIT(INT_SCDT_CHANGE) |\n\t\t     BIT(INT_HDCP_FAIL) | BIT(INT_HDCP_DONE));\n\n\tit6505_write(it6505, INT_MASK_02, BIT(INT_AUX_CMD_FAIL) |\n\t\t     BIT(INT_HDCP_KSV_CHECK) | BIT(INT_AUDIO_FIFO_ERROR));\n\n\tit6505_write(it6505, INT_MASK_03, BIT(INT_LINK_TRAIN_FAIL) |\n\t\t     BIT(INT_VID_FIFO_ERROR) | BIT(INT_IO_LATCH_FIFO_OVERFLOW));\n}\n\nstatic void it6505_int_mask_disable(struct it6505 *it6505)\n{\n\tit6505_write(it6505, INT_MASK_01, 0x00);\n\tit6505_write(it6505, INT_MASK_02, 0x00);\n\tit6505_write(it6505, INT_MASK_03, 0x00);\n}\n\nstatic void it6505_lane_termination_on(struct it6505 *it6505)\n{\n\tint regcf;\n\n\tregcf = it6505_read(it6505, REG_USER_DRV_PRE);\n\n\tif (regcf == MISC_VERB)\n\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL, 0x80, 0x00);\n\n\tif (regcf == MISC_VERC) {\n\t\tif (it6505->lane_swap) {\n\t\t\tswitch (it6505->lane_count) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL,\n\t\t\t\t\t\t0x0C, 0x08);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL,\n\t\t\t\t\t\t0x0C, 0x0C);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (it6505->lane_count) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL,\n\t\t\t\t\t\t0x0C, 0x04);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL,\n\t\t\t\t\t\t0x0C, 0x0C);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void it6505_lane_termination_off(struct it6505 *it6505)\n{\n\tint regcf;\n\n\tregcf = it6505_read(it6505, REG_USER_DRV_PRE);\n\n\tif (regcf == MISC_VERB)\n\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL, 0x80, 0x80);\n\n\tif (regcf == MISC_VERC)\n\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL, 0x0C, 0x00);\n}\n\nstatic void it6505_lane_power_on(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_LINK_DRV, 0xF1,\n\t\t\t(it6505->lane_swap ?\n\t\t\t\t GENMASK(7, 8 - it6505->lane_count) :\n\t\t\t\t GENMASK(3 + it6505->lane_count, 4)) |\n\t\t\t\t0x01);\n}\n\nstatic void it6505_lane_power_off(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_LINK_DRV, 0xF0, 0x00);\n}\n\nstatic void it6505_lane_off(struct it6505 *it6505)\n{\n\tit6505_lane_power_off(it6505);\n\tit6505_lane_termination_off(it6505);\n}\n\nstatic void it6505_aux_termination_on(struct it6505 *it6505)\n{\n\tint regcf;\n\n\tregcf = it6505_read(it6505, REG_USER_DRV_PRE);\n\n\tif (regcf == MISC_VERB)\n\t\tit6505_lane_termination_on(it6505);\n\n\tif (regcf == MISC_VERC)\n\t\tit6505_set_bits(it6505, REG_DRV_LN_DATA_SEL, 0x80, 0x80);\n}\n\nstatic void it6505_aux_power_on(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_AUX, 0x02, 0x02);\n}\n\nstatic void it6505_aux_on(struct it6505 *it6505)\n{\n\tit6505_aux_power_on(it6505);\n\tit6505_aux_termination_on(it6505);\n}\n\nstatic void it6505_aux_reset(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_RESET_CTRL, AUX_RESET, AUX_RESET);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, AUX_RESET, 0x00);\n}\n\nstatic void it6505_reset_logic(struct it6505 *it6505)\n{\n\tregmap_write(it6505->regmap, REG_RESET_CTRL, ALL_LOGIC_RESET);\n\tusleep_range(1000, 1500);\n}\n\nstatic bool it6505_aux_op_finished(struct it6505 *it6505)\n{\n\tint reg2b = it6505_read(it6505, REG_AUX_CMD_REQ);\n\n\tif (reg2b < 0)\n\t\treturn false;\n\n\treturn (reg2b & AUX_BUSY) == 0;\n}\n\nstatic int it6505_aux_wait(struct it6505 *it6505)\n{\n\tint status;\n\tunsigned long timeout;\n\tstruct device *dev = it6505->dev;\n\n\ttimeout = jiffies + msecs_to_jiffies(AUX_WAIT_TIMEOUT_MS) + 1;\n\n\twhile (!it6505_aux_op_finished(it6505)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tdev_err(dev, \"Timed out waiting AUX to finish\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tstatus = it6505_read(it6505, REG_AUX_ERROR_STS);\n\tif (status < 0) {\n\t\tdev_err(dev, \"Failed to read AUX channel: %d\", status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t it6505_aux_operation(struct it6505 *it6505,\n\t\t\t\t    enum aux_cmd_type cmd,\n\t\t\t\t    unsigned int address, u8 *buffer,\n\t\t\t\t    size_t size, enum aux_cmd_reply *reply)\n{\n\tint i, ret;\n\tbool aux_write_check = false;\n\n\tif (!it6505_get_sink_hpd_status(it6505))\n\t\treturn -EIO;\n\n\t \n\tit6505_set_bits(it6505, REG_AUX_CTRL, AUX_USER_MODE, AUX_USER_MODE);\n\naux_op_start:\n\tif (cmd == CMD_AUX_I2C_EDID_READ) {\n\t\t \n\t\tsize = min_t(size_t, size, AUX_FIFO_MAX_SIZE);\n\t\t \n\t\tit6505_set_bits(it6505, REG_AUX_CTRL,\n\t\t\t\tAUX_EN_FIFO_READ | CLR_EDID_FIFO,\n\t\t\t\tAUX_EN_FIFO_READ | CLR_EDID_FIFO);\n\n\t\tit6505_set_bits(it6505, REG_AUX_CTRL,\n\t\t\t\tAUX_EN_FIFO_READ | CLR_EDID_FIFO,\n\t\t\t\tAUX_EN_FIFO_READ);\n\t} else {\n\t\t \n\t\tsize = min_t(size_t, size, 4);\n\t\tit6505_set_bits(it6505, REG_AUX_CTRL, AUX_NO_SEGMENT_WR,\n\t\t\t\tAUX_NO_SEGMENT_WR);\n\t}\n\n\t \n\tit6505_write(it6505, REG_AUX_ADR_0_7, (address >> 0) & 0xFF);\n\t \n\tit6505_write(it6505, REG_AUX_ADR_8_15, (address >> 8) & 0xFF);\n\t \n\tit6505_write(it6505, REG_AUX_ADR_16_19,\n\t\t     ((address >> 16) & 0x0F) | ((size - 1) << 4));\n\n\tif (cmd == CMD_AUX_NATIVE_WRITE)\n\t\tregmap_bulk_write(it6505->regmap, REG_AUX_OUT_DATA0, buffer,\n\t\t\t\t  size);\n\n\t \n\tit6505_write(it6505, REG_AUX_CMD_REQ, cmd);\n\n\tret = it6505_aux_wait(it6505);\n\tif (ret < 0)\n\t\tgoto aux_op_err;\n\n\tret = it6505_read(it6505, REG_AUX_ERROR_STS);\n\tif (ret < 0)\n\t\tgoto aux_op_err;\n\n\tswitch ((ret >> 6) & 0x3) {\n\tcase 0:\n\t\t*reply = REPLY_ACK;\n\t\tbreak;\n\tcase 1:\n\t\t*reply = REPLY_DEFER;\n\t\tret = -EAGAIN;\n\t\tgoto aux_op_err;\n\tcase 2:\n\t\t*reply = REPLY_NACK;\n\t\tret = -EIO;\n\t\tgoto aux_op_err;\n\tcase 3:\n\t\tret = -ETIMEDOUT;\n\t\tgoto aux_op_err;\n\t}\n\n\t \n\tif (cmd == CMD_AUX_NATIVE_WRITE) {\n\t\taux_write_check = true;\n\t\tcmd = CMD_AUX_NATIVE_READ;\n\t\tgoto aux_op_start;\n\t}\n\n\tif (cmd == CMD_AUX_I2C_EDID_READ) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tret = it6505_read(it6505, REG_AUX_DATA_FIFO);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto aux_op_err;\n\t\t\tbuffer[i] = ret;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tret = it6505_read(it6505, REG_AUX_DATA_0_7 + i);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto aux_op_err;\n\n\t\t\tif (aux_write_check && buffer[size - 1 - i] != ret) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto aux_op_err;\n\t\t\t}\n\n\t\t\tbuffer[size - 1 - i] = ret;\n\t\t}\n\t}\n\n\tret = i;\n\naux_op_err:\n\tif (cmd == CMD_AUX_I2C_EDID_READ) {\n\t\t \n\t\tit6505_set_bits(it6505, REG_AUX_CTRL,\n\t\t\t\tAUX_EN_FIFO_READ | CLR_EDID_FIFO,\n\t\t\t\tAUX_EN_FIFO_READ | CLR_EDID_FIFO);\n\t\tit6505_set_bits(it6505, REG_AUX_CTRL,\n\t\t\t\tAUX_EN_FIFO_READ | CLR_EDID_FIFO, 0x00);\n\t}\n\n\t \n\tit6505_set_bits(it6505, REG_AUX_CTRL, AUX_USER_MODE, 0);\n\n\treturn ret;\n}\n\nstatic ssize_t it6505_aux_do_transfer(struct it6505 *it6505,\n\t\t\t\t      enum aux_cmd_type cmd,\n\t\t\t\t      unsigned int address, u8 *buffer,\n\t\t\t\t      size_t size, enum aux_cmd_reply *reply)\n{\n\tint i, ret_size, ret = 0, request_size;\n\n\tmutex_lock(&it6505->aux_lock);\n\tfor (i = 0; i < size; i += 4) {\n\t\trequest_size = min((int)size - i, 4);\n\t\tret_size = it6505_aux_operation(it6505, cmd, address + i,\n\t\t\t\t\t\tbuffer + i, request_size,\n\t\t\t\t\t\treply);\n\t\tif (ret_size < 0) {\n\t\t\tret = ret_size;\n\t\t\tgoto aux_op_err;\n\t\t}\n\n\t\tret += ret_size;\n\t}\n\naux_op_err:\n\tmutex_unlock(&it6505->aux_lock);\n\treturn ret;\n}\n\nstatic ssize_t it6505_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t   struct drm_dp_aux_msg *msg)\n{\n\tstruct it6505 *it6505 = container_of(aux, struct it6505, aux);\n\tu8 cmd;\n\tbool is_i2c = !(msg->request & DP_AUX_NATIVE_WRITE);\n\tint ret;\n\tenum aux_cmd_reply reply;\n\n\t \n\tif (is_i2c)\n\t\treturn -EINVAL;\n\n\tswitch (msg->request) {\n\tcase DP_AUX_NATIVE_READ:\n\t\tcmd = CMD_AUX_NATIVE_READ;\n\t\tbreak;\n\tcase DP_AUX_NATIVE_WRITE:\n\t\tcmd = CMD_AUX_NATIVE_WRITE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = it6505_aux_do_transfer(it6505, cmd, msg->address, msg->buffer,\n\t\t\t\t     msg->size, &reply);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (reply) {\n\tcase REPLY_ACK:\n\t\tmsg->reply = DP_AUX_NATIVE_REPLY_ACK;\n\t\tbreak;\n\tcase REPLY_NACK:\n\t\tmsg->reply = DP_AUX_NATIVE_REPLY_NACK;\n\t\tbreak;\n\tcase REPLY_DEFER:\n\t\tmsg->reply = DP_AUX_NATIVE_REPLY_DEFER;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int it6505_get_edid_block(void *data, u8 *buf, unsigned int block,\n\t\t\t\t size_t len)\n{\n\tstruct it6505 *it6505 = data;\n\tstruct device *dev = it6505->dev;\n\tenum aux_cmd_reply reply;\n\tint offset, ret, aux_retry = 100;\n\n\tit6505_aux_reset(it6505);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"block number = %d\", block);\n\n\tfor (offset = 0; offset < EDID_LENGTH;) {\n\t\tret = it6505_aux_do_transfer(it6505, CMD_AUX_I2C_EDID_READ,\n\t\t\t\t\t     block * EDID_LENGTH + offset,\n\t\t\t\t\t     buf + offset, 8, &reply);\n\n\t\tif (ret < 0 && ret != -EAGAIN)\n\t\t\treturn ret;\n\n\t\tswitch (reply) {\n\t\tcase REPLY_ACK:\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev, \"[0x%02x]: %8ph\", offset,\n\t\t\t\t\t     buf + offset);\n\t\t\toffset += 8;\n\t\t\taux_retry = 100;\n\t\t\tbreak;\n\t\tcase REPLY_NACK:\n\t\t\treturn -EIO;\n\t\tcase REPLY_DEFER:\n\t\t\tmsleep(20);\n\t\t\tif (!(--aux_retry))\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void it6505_variable_config(struct it6505 *it6505)\n{\n\tit6505->link_rate_bw_code = HBR;\n\tit6505->lane_count = MAX_LANE_COUNT;\n\tit6505->link_state = LINK_IDLE;\n\tit6505->hdcp_desired = HDCP_DESIRED;\n\tit6505->auto_train_retry = AUTO_TRAIN_RETRY;\n\tit6505->audio.select = AUDIO_SELECT;\n\tit6505->audio.sample_rate = AUDIO_SAMPLE_RATE;\n\tit6505->audio.channel_count = AUDIO_CHANNEL_COUNT;\n\tit6505->audio.type = AUDIO_TYPE;\n\tit6505->audio.i2s_input_format = I2S_INPUT_FORMAT;\n\tit6505->audio.i2s_justified = I2S_JUSTIFIED;\n\tit6505->audio.i2s_data_delay = I2S_DATA_DELAY;\n\tit6505->audio.i2s_ws_channel = I2S_WS_CHANNEL;\n\tit6505->audio.i2s_data_sequence = I2S_DATA_SEQUENCE;\n\tit6505->audio.word_length = AUDIO_WORD_LENGTH;\n\tmemset(it6505->sha1_input, 0, sizeof(it6505->sha1_input));\n\tmemset(it6505->bksvs, 0, sizeof(it6505->bksvs));\n}\n\nstatic int it6505_send_video_infoframe(struct it6505 *it6505,\n\t\t\t\t       struct hdmi_avi_infoframe *frame)\n{\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\n\tint err;\n\tstruct device *dev = it6505->dev;\n\n\terr = hdmi_avi_infoframe_pack(frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tdev_err(dev, \"Failed to pack AVI infoframe: %d\", err);\n\t\treturn err;\n\t}\n\n\terr = it6505_set_bits(it6505, REG_INFOFRAME_CTRL, EN_AVI_PKT, 0x00);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_bulk_write(it6505->regmap, REG_AVI_INFO_DB1,\n\t\t\t\tbuffer + HDMI_INFOFRAME_HEADER_SIZE,\n\t\t\t\tframe->length);\n\tif (err)\n\t\treturn err;\n\n\terr = it6505_set_bits(it6505, REG_INFOFRAME_CTRL, EN_AVI_PKT,\n\t\t\t      EN_AVI_PKT);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void it6505_get_extcon_property(struct it6505 *it6505)\n{\n\tint err;\n\tunion extcon_property_value property;\n\tstruct device *dev = it6505->dev;\n\n\tif (it6505->extcon && !it6505->lane_swap_disabled) {\n\t\terr = extcon_get_property(it6505->extcon, EXTCON_DISP_DP,\n\t\t\t\t\t  EXTCON_PROP_USB_TYPEC_POLARITY,\n\t\t\t\t\t  &property);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"get property fail!\");\n\t\t\treturn;\n\t\t}\n\t\tit6505->lane_swap = property.intval;\n\t}\n}\n\nstatic void it6505_clk_phase_adjustment(struct it6505 *it6505,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tint clock = mode->clock;\n\n\tit6505_set_bits(it6505, REG_CLK_CTRL0, M_PCLK_DELAY,\n\t\t\tclock < ADJUST_PHASE_THRESHOLD ? PIXEL_CLK_DELAY : 0);\n\tit6505_set_bits(it6505, REG_DATA_CTRL0, VIDEO_LATCH_EDGE,\n\t\t\tPIXEL_CLK_INVERSE << 4);\n}\n\nstatic void it6505_link_reset_step_train(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_TRAIN_CTRL0,\n\t\t\tFORCE_CR_DONE | FORCE_EQ_DONE, 0x00);\n\tit6505_dpcd_write(it6505, DP_TRAINING_PATTERN_SET,\n\t\t\t  DP_TRAINING_PATTERN_DISABLE);\n}\n\nstatic void it6505_init(struct it6505 *it6505)\n{\n\tit6505_write(it6505, REG_AUX_OPT, AUX_AUTO_RST | AUX_FIX_FREQ);\n\tit6505_write(it6505, REG_AUX_CTRL, AUX_NO_SEGMENT_WR);\n\tit6505_write(it6505, REG_HDCP_CTRL2, HDCP_AN_SEL | HDCP_HW_HPDIRQ_ACT);\n\tit6505_write(it6505, REG_VID_BUS_CTRL0, IN_DDR | DDR_CD);\n\tit6505_write(it6505, REG_VID_BUS_CTRL1, 0x01);\n\tit6505_write(it6505, REG_AUDIO_CTRL0, AUDIO_16B_BOUND);\n\n\t \n\tit6505_write(it6505, REG_HPD_IRQ_TIME, 0xF5);\n\tit6505_write(it6505, REG_AUX_DEBUG_MODE, 0x4D);\n\tit6505_write(it6505, REG_AUX_OPT2, 0x17);\n\tit6505_write(it6505, REG_HDCP_OPT, 0x60);\n\tit6505_write(it6505, REG_DATA_MUTE_CTRL,\n\t\t     EN_VID_MUTE | EN_AUD_MUTE | ENABLE_AUTO_VIDEO_FIFO_RESET);\n\tit6505_write(it6505, REG_TIME_STMP_CTRL,\n\t\t     EN_SSC_GAT | EN_ENHANCE_VID_STMP | EN_ENHANCE_AUD_STMP);\n\tit6505_write(it6505, REG_INFOFRAME_CTRL, 0x00);\n\tit6505_write(it6505, REG_DRV_0_DB_800_MV,\n\t\t     afe_setting_table[it6505->afe_setting][0]);\n\tit6505_write(it6505, REG_PRE_0_DB_800_MV,\n\t\t     afe_setting_table[it6505->afe_setting][1]);\n\tit6505_write(it6505, REG_PRE_3P5_DB_800_MV,\n\t\t     afe_setting_table[it6505->afe_setting][2]);\n\tit6505_write(it6505, REG_SSC_CTRL0, 0x9E);\n\tit6505_write(it6505, REG_SSC_CTRL1, 0x1C);\n\tit6505_write(it6505, REG_SSC_CTRL2, 0x42);\n}\n\nstatic void it6505_video_disable(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_DATA_MUTE_CTRL, EN_VID_MUTE, EN_VID_MUTE);\n\tit6505_set_bits(it6505, REG_INFOFRAME_CTRL, EN_VID_CTRL_PKT, 0x00);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, VIDEO_RESET, VIDEO_RESET);\n}\n\nstatic void it6505_video_reset(struct it6505 *it6505)\n{\n\tit6505_link_reset_step_train(it6505);\n\tit6505_set_bits(it6505, REG_DATA_MUTE_CTRL, EN_VID_MUTE, EN_VID_MUTE);\n\tit6505_set_bits(it6505, REG_INFOFRAME_CTRL, EN_VID_CTRL_PKT, 0x00);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, VIDEO_RESET, VIDEO_RESET);\n\tit6505_set_bits(it6505, REG_501_FIFO_CTRL, RST_501_FIFO, RST_501_FIFO);\n\tit6505_set_bits(it6505, REG_501_FIFO_CTRL, RST_501_FIFO, 0x00);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, VIDEO_RESET, 0x00);\n}\n\nstatic void it6505_update_video_parameter(struct it6505 *it6505,\n\t\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tit6505_clk_phase_adjustment(it6505, mode);\n\tit6505_video_disable(it6505);\n}\n\nstatic bool it6505_audio_input(struct it6505 *it6505)\n{\n\tint reg05, regbe;\n\n\treg05 = it6505_read(it6505, REG_RESET_CTRL);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, AUDIO_RESET, 0x00);\n\tusleep_range(3000, 4000);\n\tregbe = it6505_read(it6505, REG_AUDIO_INPUT_FREQ);\n\tit6505_write(it6505, REG_RESET_CTRL, reg05);\n\n\treturn regbe != 0xFF;\n}\n\nstatic void it6505_setup_audio_channel_status(struct it6505 *it6505)\n{\n\tenum it6505_audio_sample_rate sample_rate = it6505->audio.sample_rate;\n\tu8 audio_word_length_map[] = { 0x02, 0x04, 0x03, 0x0B };\n\n\t \n\tit6505_write(it6505, REG_IEC958_STS0, it6505->audio.type << 1);\n\tit6505_write(it6505, REG_IEC958_STS1, 0x00);\n\tit6505_write(it6505, REG_IEC958_STS2, 0x00);\n\tit6505_write(it6505, REG_IEC958_STS3, sample_rate);\n\tit6505_write(it6505, REG_IEC958_STS4, (~sample_rate << 4) |\n\t\t     audio_word_length_map[it6505->audio.word_length]);\n}\n\nstatic void it6505_setup_audio_format(struct it6505 *it6505)\n{\n\t \n\tit6505_write(it6505, REG_AUDIO_FMT,\n\t\t     (it6505->audio.word_length << 5) |\n\t\t     (it6505->audio.i2s_data_sequence << 4) |\n\t\t     (it6505->audio.i2s_ws_channel << 3) |\n\t\t     (it6505->audio.i2s_data_delay << 2) |\n\t\t     (it6505->audio.i2s_justified << 1) |\n\t\t     it6505->audio.i2s_input_format);\n\tif (it6505->audio.select == SPDIF) {\n\t\tit6505_write(it6505, REG_AUDIO_FIFO_SEL, 0x00);\n\t\t \n\t\tit6505_set_bits(it6505, REG_AUX_OPT, 0xF0, 0x30);\n\t} else {\n\t\tit6505_write(it6505, REG_AUDIO_FIFO_SEL, 0xE4);\n\t}\n\n\tit6505_write(it6505, REG_AUDIO_CTRL0, 0x20);\n\tit6505_write(it6505, REG_AUDIO_CTRL1, 0x00);\n}\n\nstatic void it6505_enable_audio_source(struct it6505 *it6505)\n{\n\tunsigned int audio_source_count;\n\n\taudio_source_count = BIT(DIV_ROUND_UP(it6505->audio.channel_count, 2))\n\t\t\t\t - 1;\n\n\taudio_source_count |= it6505->audio.select << 4;\n\n\tit6505_write(it6505, REG_AUDIO_SRC_CTRL, audio_source_count);\n}\n\nstatic void it6505_enable_audio_infoframe(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tu8 audio_info_ca[] = { 0x00, 0x00, 0x01, 0x03, 0x07, 0x0B, 0x0F, 0x1F };\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"infoframe channel_allocation:0x%02x\",\n\t\t\t     audio_info_ca[it6505->audio.channel_count - 1]);\n\n\tit6505_write(it6505, REG_AUD_INFOFRAM_DB1, it6505->audio.channel_count\n\t\t     - 1);\n\tit6505_write(it6505, REG_AUD_INFOFRAM_DB2, 0x00);\n\tit6505_write(it6505, REG_AUD_INFOFRAM_DB3,\n\t\t     audio_info_ca[it6505->audio.channel_count - 1]);\n\tit6505_write(it6505, REG_AUD_INFOFRAM_DB4, 0x00);\n\tit6505_write(it6505, REG_AUD_INFOFRAM_SUM, 0x00);\n\n\t \n\tit6505_set_bits(it6505, REG_INFOFRAME_CTRL, EN_AUD_CTRL_PKT,\n\t\t\tEN_AUD_CTRL_PKT);\n}\n\nstatic void it6505_disable_audio(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_DATA_MUTE_CTRL, EN_AUD_MUTE, EN_AUD_MUTE);\n\tit6505_set_bits(it6505, REG_AUDIO_SRC_CTRL, M_AUDIO_I2S_EN, 0x00);\n\tit6505_set_bits(it6505, REG_INFOFRAME_CTRL, EN_AUD_CTRL_PKT, 0x00);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, AUDIO_RESET, AUDIO_RESET);\n}\n\nstatic void it6505_enable_audio(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tint regbe;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\tit6505_disable_audio(it6505);\n\n\tit6505_setup_audio_channel_status(it6505);\n\tit6505_setup_audio_format(it6505);\n\tit6505_enable_audio_source(it6505);\n\tit6505_enable_audio_infoframe(it6505);\n\n\tit6505_write(it6505, REG_AUDIO_N_0_7, 0x00);\n\tit6505_write(it6505, REG_AUDIO_N_8_15, 0x80);\n\tit6505_write(it6505, REG_AUDIO_N_16_23, 0x00);\n\n\tit6505_set_bits(it6505, REG_AUDIO_SRC_CTRL, AUDIO_FIFO_RESET,\n\t\t\tAUDIO_FIFO_RESET);\n\tit6505_set_bits(it6505, REG_AUDIO_SRC_CTRL, AUDIO_FIFO_RESET, 0x00);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, AUDIO_RESET, 0x00);\n\tregbe = it6505_read(it6505, REG_AUDIO_INPUT_FREQ);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"regbe:0x%02x audio input fs: %d.%d kHz\",\n\t\t\t     regbe, 6750 / regbe, (6750 % regbe) * 10 / regbe);\n\tit6505_set_bits(it6505, REG_DATA_MUTE_CTRL, EN_AUD_MUTE, 0x00);\n}\n\nstatic bool it6505_use_step_train_check(struct it6505 *it6505)\n{\n\tif (it6505->link.revision >= 0x12)\n\t\treturn it6505->dpcd[DP_TRAINING_AUX_RD_INTERVAL] >= 0x01;\n\n\treturn true;\n}\n\nstatic void it6505_parse_link_capabilities(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tstruct it6505_drm_dp_link *link = &it6505->link;\n\tint bcaps;\n\n\tif (it6505->dpcd[0] == 0) {\n\t\tdev_err(dev, \"DPCD is not initialized\");\n\t\treturn;\n\t}\n\n\tmemset(link, 0, sizeof(*link));\n\n\tlink->revision = it6505->dpcd[0];\n\tlink->rate = drm_dp_bw_code_to_link_rate(it6505->dpcd[1]);\n\tlink->num_lanes = it6505->dpcd[2] & DP_MAX_LANE_COUNT_MASK;\n\n\tif (it6505->dpcd[2] & DP_ENHANCED_FRAME_CAP)\n\t\tlink->capabilities = DP_ENHANCED_FRAME_CAP;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"DPCD Rev.: %d.%d\",\n\t\t\t     link->revision >> 4, link->revision & 0x0F);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Sink max link rate: %d.%02d Gbps per lane\",\n\t\t\t     link->rate / 100000, link->rate / 1000 % 100);\n\n\tit6505->link_rate_bw_code = drm_dp_link_rate_to_bw_code(link->rate);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"link rate bw code:0x%02x\",\n\t\t\t     it6505->link_rate_bw_code);\n\tit6505->link_rate_bw_code = min_t(int, it6505->link_rate_bw_code,\n\t\t\t\t\t  MAX_LINK_RATE);\n\n\tit6505->lane_count = link->num_lanes;\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Sink support %d lanes training\",\n\t\t\t     it6505->lane_count);\n\tit6505->lane_count = min_t(int, it6505->lane_count,\n\t\t\t\t   it6505->max_lane_count);\n\n\tit6505->branch_device = drm_dp_is_branch(it6505->dpcd);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Sink %sbranch device\",\n\t\t\t     it6505->branch_device ? \"\" : \"Not \");\n\n\tit6505->enable_enhanced_frame = link->capabilities;\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Sink %sSupport Enhanced Framing\",\n\t\t\t     it6505->enable_enhanced_frame ? \"\" : \"Not \");\n\n\tit6505->enable_ssc = (it6505->dpcd[DP_MAX_DOWNSPREAD] &\n\t\t\t\tDP_MAX_DOWNSPREAD_0_5);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Maximum Down-Spread: %s, %ssupport SSC!\",\n\t\t\t     it6505->enable_ssc ? \"0.5\" : \"0\",\n\t\t\t     it6505->enable_ssc ? \"\" : \"Not \");\n\n\tit6505->step_train = it6505_use_step_train_check(it6505);\n\tif (it6505->step_train)\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"auto train fail, will step train\");\n\n\tbcaps = it6505_dpcd_read(it6505, DP_AUX_HDCP_BCAPS);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"bcaps:0x%02x\", bcaps);\n\tif (bcaps & DP_BCAPS_HDCP_CAPABLE) {\n\t\tit6505->is_repeater = (bcaps & DP_BCAPS_REPEATER_PRESENT);\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"Support HDCP! Downstream is %s!\",\n\t\t\t\t     it6505->is_repeater ? \"repeater\" :\n\t\t\t\t     \"receiver\");\n\t} else {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"Sink not support HDCP!\");\n\t\tit6505->hdcp_desired = false;\n\t}\n\tDRM_DEV_DEBUG_DRIVER(dev, \"HDCP %s\",\n\t\t\t     it6505->hdcp_desired ? \"desired\" : \"undesired\");\n}\n\nstatic void it6505_setup_ssc(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_TRAIN_CTRL0, SPREAD_AMP_5,\n\t\t\tit6505->enable_ssc ? SPREAD_AMP_5 : 0x00);\n\tif (it6505->enable_ssc) {\n\t\tit6505_write(it6505, REG_SSC_CTRL0, 0x9E);\n\t\tit6505_write(it6505, REG_SSC_CTRL1, 0x1C);\n\t\tit6505_write(it6505, REG_SSC_CTRL2, 0x42);\n\t\tit6505_write(it6505, REG_SP_CTRL0, 0x07);\n\t\tit6505_write(it6505, REG_IP_CTRL1, 0x29);\n\t\tit6505_write(it6505, REG_IP_CTRL2, 0x03);\n\t\t \n\t\tit6505_set_bits(it6505, REG_TIME_STMP_CTRL, M_STAMP_STEP,\n\t\t\t\t0x10);\n\t\tit6505_dpcd_write(it6505, DP_DOWNSPREAD_CTRL,\n\t\t\t\t  DP_SPREAD_AMP_0_5);\n\t} else {\n\t\tit6505_dpcd_write(it6505, DP_DOWNSPREAD_CTRL, 0x00);\n\t\tit6505_set_bits(it6505, REG_TIME_STMP_CTRL, M_STAMP_STEP,\n\t\t\t\t0x00);\n\t}\n}\n\nstatic inline void it6505_link_rate_setup(struct it6505 *it6505)\n{\n\tit6505_set_bits(it6505, REG_TRAIN_CTRL0, FORCE_LBR,\n\t\t\t(it6505->link_rate_bw_code == RBR) ? FORCE_LBR : 0x00);\n\tit6505_set_bits(it6505, REG_LINK_DRV, DRV_HS,\n\t\t\t(it6505->link_rate_bw_code == RBR) ? 0x00 : DRV_HS);\n}\n\nstatic void it6505_lane_count_setup(struct it6505 *it6505)\n{\n\tit6505_get_extcon_property(it6505);\n\tit6505_set_bits(it6505, REG_TRAIN_CTRL0, LANE_SWAP,\n\t\t\tit6505->lane_swap ? LANE_SWAP : 0x00);\n\tit6505_set_bits(it6505, REG_TRAIN_CTRL0, LANE_COUNT_MASK,\n\t\t\t(it6505->lane_count - 1) << 1);\n}\n\nstatic void it6505_link_training_setup(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tif (it6505->enable_enhanced_frame)\n\t\tit6505_set_bits(it6505, REG_DATA_MUTE_CTRL,\n\t\t\t\tENABLE_ENHANCED_FRAME, ENABLE_ENHANCED_FRAME);\n\n\tit6505_link_rate_setup(it6505);\n\tit6505_lane_count_setup(it6505);\n\tit6505_setup_ssc(it6505);\n\tDRM_DEV_DEBUG_DRIVER(dev,\n\t\t\t     \"%s, %d lanes, %sable ssc, %sable enhanced frame\",\n\t\t\t     it6505->link_rate_bw_code != RBR ? \"HBR\" : \"RBR\",\n\t\t\t     it6505->lane_count,\n\t\t\t     it6505->enable_ssc ? \"en\" : \"dis\",\n\t\t\t     it6505->enable_enhanced_frame ? \"en\" : \"dis\");\n}\n\nstatic bool it6505_link_start_auto_train(struct it6505 *it6505)\n{\n\tint timeout = 500, link_training_state;\n\tbool state = false;\n\n\tmutex_lock(&it6505->aux_lock);\n\tit6505_set_bits(it6505, REG_TRAIN_CTRL0,\n\t\t\tFORCE_CR_DONE | FORCE_EQ_DONE, 0x00);\n\tit6505_write(it6505, REG_TRAIN_CTRL1, FORCE_RETRAIN);\n\tit6505_write(it6505, REG_TRAIN_CTRL1, AUTO_TRAIN);\n\n\twhile (timeout > 0) {\n\t\tusleep_range(1000, 2000);\n\t\tlink_training_state = it6505_read(it6505, REG_LINK_TRAIN_STS);\n\n\t\tif (link_training_state > 0 &&\n\t\t    (link_training_state & LINK_STATE_NORP)) {\n\t\t\tstate = true;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\ttimeout--;\n\t}\nunlock:\n\tmutex_unlock(&it6505->aux_lock);\n\n\treturn state;\n}\n\nstatic int it6505_drm_dp_link_configure(struct it6505 *it6505)\n{\n\tu8 values[2];\n\tint err;\n\tstruct drm_dp_aux *aux = &it6505->aux;\n\n\tvalues[0] = it6505->link_rate_bw_code;\n\tvalues[1] = it6505->lane_count;\n\n\tif (it6505->enable_enhanced_frame)\n\t\tvalues[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\terr = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic bool it6505_check_voltage_swing_max(u8 lane_voltage_swing_pre_emphasis)\n{\n\treturn ((lane_voltage_swing_pre_emphasis & 0x03) == MAX_CR_LEVEL);\n}\n\nstatic bool it6505_check_pre_emphasis_max(u8 lane_voltage_swing_pre_emphasis)\n{\n\treturn ((lane_voltage_swing_pre_emphasis & 0x03) == MAX_EQ_LEVEL);\n}\n\nstatic bool it6505_check_max_voltage_swing_reached(u8 *lane_voltage_swing,\n\t\t\t\t\t\t   u8 lane_count)\n{\n\tu8 i;\n\n\tfor (i = 0; i < lane_count; i++) {\n\t\tif (lane_voltage_swing[i] & DP_TRAIN_MAX_SWING_REACHED)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool\nstep_train_lane_voltage_para_set(struct it6505 *it6505,\n\t\t\t\t struct it6505_step_train_para\n\t\t\t\t *lane_voltage_pre_emphasis,\n\t\t\t\t u8 *lane_voltage_pre_emphasis_set)\n{\n\tu8 *voltage_swing = lane_voltage_pre_emphasis->voltage_swing;\n\tu8 *pre_emphasis = lane_voltage_pre_emphasis->pre_emphasis;\n\tu8 i;\n\n\tfor (i = 0; i < it6505->lane_count; i++) {\n\t\tvoltage_swing[i] &= 0x03;\n\t\tlane_voltage_pre_emphasis_set[i] = voltage_swing[i];\n\t\tif (it6505_check_voltage_swing_max(voltage_swing[i]))\n\t\t\tlane_voltage_pre_emphasis_set[i] |=\n\t\t\t\tDP_TRAIN_MAX_SWING_REACHED;\n\n\t\tpre_emphasis[i] &= 0x03;\n\t\tlane_voltage_pre_emphasis_set[i] |= pre_emphasis[i]\n\t\t\t<< DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\t\tif (it6505_check_pre_emphasis_max(pre_emphasis[i]))\n\t\t\tlane_voltage_pre_emphasis_set[i] |=\n\t\t\t\tDP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\t\tit6505_dpcd_write(it6505, DP_TRAINING_LANE0_SET + i,\n\t\t\t\t  lane_voltage_pre_emphasis_set[i]);\n\n\t\tif (lane_voltage_pre_emphasis_set[i] !=\n\t\t    it6505_dpcd_read(it6505, DP_TRAINING_LANE0_SET + i))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nit6505_step_cr_train(struct it6505 *it6505,\n\t\t     struct it6505_step_train_para *lane_voltage_pre_emphasis)\n{\n\tu8 loop_count = 0, i = 0, j;\n\tu8 link_status[DP_LINK_STATUS_SIZE] = { 0 };\n\tu8 lane_level_config[MAX_LANE_COUNT] = { 0 };\n\tint pre_emphasis_adjust = -1, voltage_swing_adjust = -1;\n\tconst struct drm_dp_aux *aux = &it6505->aux;\n\n\tit6505_dpcd_write(it6505, DP_DOWNSPREAD_CTRL,\n\t\t\t  it6505->enable_ssc ? DP_SPREAD_AMP_0_5 : 0x00);\n\tit6505_dpcd_write(it6505, DP_TRAINING_PATTERN_SET,\n\t\t\t  DP_TRAINING_PATTERN_1);\n\n\twhile (loop_count < 5 && i < 10) {\n\t\ti++;\n\t\tif (!step_train_lane_voltage_para_set(it6505,\n\t\t\t\t\t\t      lane_voltage_pre_emphasis,\n\t\t\t\t\t\t      lane_level_config))\n\t\t\tcontinue;\n\t\tdrm_dp_link_train_clock_recovery_delay(aux, it6505->dpcd);\n\t\tdrm_dp_dpcd_read_link_status(&it6505->aux, link_status);\n\n\t\tif (drm_dp_clock_recovery_ok(link_status, it6505->lane_count)) {\n\t\t\tit6505_set_bits(it6505, REG_TRAIN_CTRL0, FORCE_CR_DONE,\n\t\t\t\t\tFORCE_CR_DONE);\n\t\t\treturn true;\n\t\t}\n\t\tDRM_DEV_DEBUG_DRIVER(it6505->dev, \"cr not done\");\n\n\t\tif (it6505_check_max_voltage_swing_reached(lane_level_config,\n\t\t\t\t\t\t\t   it6505->lane_count))\n\t\t\tgoto cr_train_fail;\n\n\t\tfor (j = 0; j < it6505->lane_count; j++) {\n\t\t\tlane_voltage_pre_emphasis->voltage_swing[j] =\n\t\t\t\tdrm_dp_get_adjust_request_voltage(link_status,\n\t\t\t\t\t\t\t\t  j) >>\n\t\t\t\tDP_TRAIN_VOLTAGE_SWING_SHIFT;\n\t\t\tlane_voltage_pre_emphasis->pre_emphasis[j] =\n\t\t\tdrm_dp_get_adjust_request_pre_emphasis(link_status,\n\t\t\t\t\t\t\t       j) >>\n\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_SHIFT;\n\t\t\tif (voltage_swing_adjust ==\n\t\t\t     lane_voltage_pre_emphasis->voltage_swing[j] &&\n\t\t\t    pre_emphasis_adjust ==\n\t\t\t     lane_voltage_pre_emphasis->pre_emphasis[j]) {\n\t\t\t\tloop_count++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvoltage_swing_adjust =\n\t\t\t\tlane_voltage_pre_emphasis->voltage_swing[j];\n\t\t\tpre_emphasis_adjust =\n\t\t\t\tlane_voltage_pre_emphasis->pre_emphasis[j];\n\t\t\tloop_count = 0;\n\n\t\t\tif (voltage_swing_adjust + pre_emphasis_adjust >\n\t\t\t    MAX_EQ_LEVEL)\n\t\t\t\tlane_voltage_pre_emphasis->voltage_swing[j] =\n\t\t\t\t\tMAX_EQ_LEVEL -\n\t\t\t\t\tlane_voltage_pre_emphasis\n\t\t\t\t\t\t->pre_emphasis[j];\n\t\t}\n\t}\n\ncr_train_fail:\n\tit6505_dpcd_write(it6505, DP_TRAINING_PATTERN_SET,\n\t\t\t  DP_TRAINING_PATTERN_DISABLE);\n\n\treturn false;\n}\n\nstatic bool\nit6505_step_eq_train(struct it6505 *it6505,\n\t\t     struct it6505_step_train_para *lane_voltage_pre_emphasis)\n{\n\tu8 loop_count = 0, i, link_status[DP_LINK_STATUS_SIZE] = { 0 };\n\tu8 lane_level_config[MAX_LANE_COUNT] = { 0 };\n\tconst struct drm_dp_aux *aux = &it6505->aux;\n\n\tit6505_dpcd_write(it6505, DP_TRAINING_PATTERN_SET,\n\t\t\t  DP_TRAINING_PATTERN_2);\n\n\twhile (loop_count < 6) {\n\t\tloop_count++;\n\n\t\tif (!step_train_lane_voltage_para_set(it6505,\n\t\t\t\t\t\t      lane_voltage_pre_emphasis,\n\t\t\t\t\t\t      lane_level_config))\n\t\t\tcontinue;\n\n\t\tdrm_dp_link_train_channel_eq_delay(aux, it6505->dpcd);\n\t\tdrm_dp_dpcd_read_link_status(&it6505->aux, link_status);\n\n\t\tif (!drm_dp_clock_recovery_ok(link_status, it6505->lane_count))\n\t\t\tgoto eq_train_fail;\n\n\t\tif (drm_dp_channel_eq_ok(link_status, it6505->lane_count)) {\n\t\t\tit6505_dpcd_write(it6505, DP_TRAINING_PATTERN_SET,\n\t\t\t\t\t  DP_TRAINING_PATTERN_DISABLE);\n\t\t\tit6505_set_bits(it6505, REG_TRAIN_CTRL0, FORCE_EQ_DONE,\n\t\t\t\t\tFORCE_EQ_DONE);\n\t\t\treturn true;\n\t\t}\n\t\tDRM_DEV_DEBUG_DRIVER(it6505->dev, \"eq not done\");\n\n\t\tfor (i = 0; i < it6505->lane_count; i++) {\n\t\t\tlane_voltage_pre_emphasis->voltage_swing[i] =\n\t\t\t\tdrm_dp_get_adjust_request_voltage(link_status,\n\t\t\t\t\t\t\t\t  i) >>\n\t\t\t\tDP_TRAIN_VOLTAGE_SWING_SHIFT;\n\t\t\tlane_voltage_pre_emphasis->pre_emphasis[i] =\n\t\t\tdrm_dp_get_adjust_request_pre_emphasis(link_status,\n\t\t\t\t\t\t\t       i) >>\n\t\t\t\t\tDP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\t\t\tif (lane_voltage_pre_emphasis->voltage_swing[i] +\n\t\t\t\t    lane_voltage_pre_emphasis->pre_emphasis[i] >\n\t\t\t    MAX_EQ_LEVEL)\n\t\t\t\tlane_voltage_pre_emphasis->voltage_swing[i] =\n\t\t\t\t\t0x03 - lane_voltage_pre_emphasis\n\t\t\t\t\t\t       ->pre_emphasis[i];\n\t\t}\n\t}\n\neq_train_fail:\n\tit6505_dpcd_write(it6505, DP_TRAINING_PATTERN_SET,\n\t\t\t  DP_TRAINING_PATTERN_DISABLE);\n\treturn false;\n}\n\nstatic bool it6505_link_start_step_train(struct it6505 *it6505)\n{\n\tint err;\n\tstruct it6505_step_train_para lane_voltage_pre_emphasis = {\n\t\t.voltage_swing = { 0 },\n\t\t.pre_emphasis = { 0 },\n\t};\n\n\tDRM_DEV_DEBUG_DRIVER(it6505->dev, \"start\");\n\terr = it6505_drm_dp_link_configure(it6505);\n\n\tif (err < 0)\n\t\treturn false;\n\tif (!it6505_step_cr_train(it6505, &lane_voltage_pre_emphasis))\n\t\treturn false;\n\tif (!it6505_step_eq_train(it6505, &lane_voltage_pre_emphasis))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool it6505_get_video_status(struct it6505 *it6505)\n{\n\tint reg_0d;\n\n\treg_0d = it6505_read(it6505, REG_SYSTEM_STS);\n\n\tif (reg_0d < 0)\n\t\treturn false;\n\n\treturn reg_0d & VIDEO_STB;\n}\n\nstatic void it6505_reset_hdcp(struct it6505 *it6505)\n{\n\tit6505->hdcp_status = HDCP_AUTH_IDLE;\n\t \n\tit6505_set_bits(it6505, REG_HDCP_CTRL1, HDCP_CP_ENABLE, 0x00);\n\tit6505_set_bits(it6505, REG_RESET_CTRL, HDCP_RESET, HDCP_RESET);\n}\n\nstatic void it6505_start_hdcp(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\tit6505_reset_hdcp(it6505);\n\tqueue_delayed_work(system_wq, &it6505->hdcp_work,\n\t\t\t   msecs_to_jiffies(2400));\n}\n\nstatic void it6505_stop_hdcp(struct it6505 *it6505)\n{\n\tit6505_reset_hdcp(it6505);\n\tcancel_delayed_work(&it6505->hdcp_work);\n}\n\nstatic bool it6505_hdcp_is_ksv_valid(u8 *ksv)\n{\n\tint i, ones = 0;\n\n\t \n\tfor (i = 0; i < DRM_HDCP_KSV_LEN; i++)\n\t\tones += hweight8(ksv[i]);\n\tif (ones != 20)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void it6505_hdcp_part1_auth(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tu8 hdcp_bcaps;\n\n\tit6505_set_bits(it6505, REG_RESET_CTRL, HDCP_RESET, 0x00);\n\t \n\tit6505_set_bits(it6505, REG_HDCP_CTRL1, HDCP_CP_ENABLE, 0x00);\n\n\tusleep_range(1000, 1500);\n\thdcp_bcaps = it6505_dpcd_read(it6505, DP_AUX_HDCP_BCAPS);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"DPCD[0x68028]: 0x%02x\",\n\t\t\t     hdcp_bcaps);\n\n\tif (!hdcp_bcaps)\n\t\treturn;\n\n\t \n\tit6505_set_bits(it6505, REG_HDCP_TRIGGER,\n\t\t\tHDCP_TRIGGER_KSV_DONE | HDCP_TRIGGER_KSV_FAIL,\n\t\t\t0x00);\n\n\t \n\tit6505_set_bits(it6505, REG_HDCP_CTRL2, HDCP_AN_GEN, HDCP_AN_GEN);\n\t \n\tusleep_range(10000, 15000);\n\t \n\tit6505_set_bits(it6505, REG_HDCP_CTRL2, HDCP_AN_GEN, 0x00);\n\n\tit6505_set_bits(it6505, REG_HDCP_CTRL1, HDCP_CP_ENABLE, HDCP_CP_ENABLE);\n\n\tit6505_set_bits(it6505, REG_HDCP_TRIGGER, HDCP_TRIGGER_START,\n\t\t\tHDCP_TRIGGER_START);\n\n\tit6505->hdcp_status = HDCP_AUTH_GOING;\n}\n\nstatic int it6505_sha1_digest(struct it6505 *it6505, u8 *sha1_input,\n\t\t\t      unsigned int size, u8 *output_av)\n{\n\tstruct shash_desc *desc;\n\tstruct crypto_shash *tfm;\n\tint err;\n\tstruct device *dev = it6505->dev;\n\n\ttfm = crypto_alloc_shash(\"sha1\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tdev_err(dev, \"crypto_alloc_shash sha1 failed\");\n\t\treturn PTR_ERR(tfm);\n\t}\n\tdesc = kzalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\n\tif (!desc) {\n\t\tcrypto_free_shash(tfm);\n\t\treturn -ENOMEM;\n\t}\n\n\tdesc->tfm = tfm;\n\terr = crypto_shash_digest(desc, sha1_input, size, output_av);\n\tif (err)\n\t\tdev_err(dev, \"crypto_shash_digest sha1 failed\");\n\n\tcrypto_free_shash(tfm);\n\tkfree(desc);\n\treturn err;\n}\n\nstatic int it6505_setup_sha1_input(struct it6505 *it6505, u8 *sha1_input)\n{\n\tstruct device *dev = it6505->dev;\n\tu8 binfo[2];\n\tint down_stream_count, i, err, msg_count = 0;\n\n\terr = it6505_get_dpcd(it6505, DP_AUX_HDCP_BINFO, binfo,\n\t\t\t      ARRAY_SIZE(binfo));\n\n\tif (err < 0) {\n\t\tdev_err(dev, \"Read binfo value Fail\");\n\t\treturn err;\n\t}\n\n\tdown_stream_count = binfo[0] & 0x7F;\n\tDRM_DEV_DEBUG_DRIVER(dev, \"binfo:0x%*ph\", (int)ARRAY_SIZE(binfo),\n\t\t\t     binfo);\n\n\tif ((binfo[0] & BIT(7)) || (binfo[1] & BIT(3))) {\n\t\tdev_err(dev, \"HDCP max cascade device exceed\");\n\t\treturn 0;\n\t}\n\n\tif (!down_stream_count ||\n\t    down_stream_count > MAX_HDCP_DOWN_STREAM_COUNT) {\n\t\tdev_err(dev, \"HDCP down stream count Error %d\",\n\t\t\tdown_stream_count);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < down_stream_count; i++) {\n\t\terr = it6505_get_dpcd(it6505, DP_AUX_HDCP_KSV_FIFO +\n\t\t\t\t      (i % 3) * DRM_HDCP_KSV_LEN,\n\t\t\t\t      sha1_input + msg_count,\n\t\t\t\t      DRM_HDCP_KSV_LEN);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmsg_count += 5;\n\t}\n\n\tit6505->hdcp_down_stream_count = down_stream_count;\n\tsha1_input[msg_count++] = binfo[0];\n\tsha1_input[msg_count++] = binfo[1];\n\n\tit6505_set_bits(it6505, REG_HDCP_CTRL2, HDCP_EN_M0_READ,\n\t\t\tHDCP_EN_M0_READ);\n\n\terr = regmap_bulk_read(it6505->regmap, REG_M0_0_7,\n\t\t\t       sha1_input + msg_count, 8);\n\n\tit6505_set_bits(it6505, REG_HDCP_CTRL2, HDCP_EN_M0_READ, 0x00);\n\n\tif (err < 0) {\n\t\tdev_err(dev, \" Warning, Read M value Fail\");\n\t\treturn err;\n\t}\n\n\tmsg_count += 8;\n\n\treturn msg_count;\n}\n\nstatic bool it6505_hdcp_part2_ksvlist_check(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tu8 av[5][4], bv[5][4];\n\tint i, err;\n\n\ti = it6505_setup_sha1_input(it6505, it6505->sha1_input);\n\tif (i <= 0) {\n\t\tdev_err(dev, \"SHA-1 Input length error %d\", i);\n\t\treturn false;\n\t}\n\n\tit6505_sha1_digest(it6505, it6505->sha1_input, i, (u8 *)av);\n\n\terr = it6505_get_dpcd(it6505, DP_AUX_HDCP_V_PRIME(0), (u8 *)bv,\n\t\t\t      sizeof(bv));\n\n\tif (err < 0) {\n\t\tdev_err(dev, \"Read V' value Fail\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < 5; i++)\n\t\tif (bv[i][3] != av[i][0] || bv[i][2] != av[i][1] ||\n\t\t    bv[i][1] != av[i][2] || bv[i][0] != av[i][3])\n\t\t\treturn false;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"V' all match!!\");\n\treturn true;\n}\n\nstatic void it6505_hdcp_wait_ksv_list(struct work_struct *work)\n{\n\tstruct it6505 *it6505 = container_of(work, struct it6505,\n\t\t\t\t\t     hdcp_wait_ksv_list);\n\tstruct device *dev = it6505->dev;\n\tunsigned int timeout = 5000;\n\tu8 bstatus = 0;\n\tbool ksv_list_check;\n\n\ttimeout /= 20;\n\twhile (timeout > 0) {\n\t\tif (!it6505_get_sink_hpd_status(it6505))\n\t\t\treturn;\n\n\t\tbstatus = it6505_dpcd_read(it6505, DP_AUX_HDCP_BSTATUS);\n\n\t\tif (bstatus & DP_BSTATUS_READY)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\ttimeout--;\n\t}\n\n\tif (timeout == 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"timeout and ksv list wait failed\");\n\t\tgoto timeout;\n\t}\n\n\tksv_list_check = it6505_hdcp_part2_ksvlist_check(it6505);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"ksv list ready, ksv list check %s\",\n\t\t\t     ksv_list_check ? \"pass\" : \"fail\");\n\tif (ksv_list_check) {\n\t\tit6505_set_bits(it6505, REG_HDCP_TRIGGER,\n\t\t\t\tHDCP_TRIGGER_KSV_DONE, HDCP_TRIGGER_KSV_DONE);\n\t\treturn;\n\t}\ntimeout:\n\tit6505_set_bits(it6505, REG_HDCP_TRIGGER,\n\t\t\tHDCP_TRIGGER_KSV_DONE | HDCP_TRIGGER_KSV_FAIL,\n\t\t\tHDCP_TRIGGER_KSV_DONE | HDCP_TRIGGER_KSV_FAIL);\n}\n\nstatic void it6505_hdcp_work(struct work_struct *work)\n{\n\tstruct it6505 *it6505 = container_of(work, struct it6505,\n\t\t\t\t\t     hdcp_work.work);\n\tstruct device *dev = it6505->dev;\n\tint ret;\n\tu8 link_status[DP_LINK_STATUS_SIZE] = { 0 };\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\n\tif (!it6505_get_sink_hpd_status(it6505))\n\t\treturn;\n\n\tret = drm_dp_dpcd_read_link_status(&it6505->aux, link_status);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"ret: %d link_status: %*ph\", ret,\n\t\t\t     (int)sizeof(link_status), link_status);\n\n\tif (ret < 0 || !drm_dp_channel_eq_ok(link_status, it6505->lane_count) ||\n\t    !it6505_get_video_status(it6505)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"link train not done or no video\");\n\t\treturn;\n\t}\n\n\tret = it6505_get_dpcd(it6505, DP_AUX_HDCP_BKSV, it6505->bksvs,\n\t\t\t      ARRAY_SIZE(it6505->bksvs));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"fail to get bksv  ret: %d\", ret);\n\t\tit6505_set_bits(it6505, REG_HDCP_TRIGGER,\n\t\t\t\tHDCP_TRIGGER_KSV_FAIL, HDCP_TRIGGER_KSV_FAIL);\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"bksv = 0x%*ph\",\n\t\t\t     (int)ARRAY_SIZE(it6505->bksvs), it6505->bksvs);\n\n\tif (!it6505_hdcp_is_ksv_valid(it6505->bksvs)) {\n\t\tdev_err(dev, \"Display Port bksv not valid\");\n\t\tit6505_set_bits(it6505, REG_HDCP_TRIGGER,\n\t\t\t\tHDCP_TRIGGER_KSV_FAIL, HDCP_TRIGGER_KSV_FAIL);\n\t}\n\n\tit6505_hdcp_part1_auth(it6505);\n}\n\nstatic void it6505_show_hdcp_info(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tint i;\n\tu8 *sha1 = it6505->sha1_input;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hdcp_status: %d is_repeater: %d\",\n\t\t\t     it6505->hdcp_status, it6505->is_repeater);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"bksv = 0x%*ph\",\n\t\t\t     (int)ARRAY_SIZE(it6505->bksvs), it6505->bksvs);\n\n\tif (it6505->is_repeater) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"hdcp_down_stream_count: %d\",\n\t\t\t\t     it6505->hdcp_down_stream_count);\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"sha1_input: 0x%*ph\",\n\t\t\t\t     (int)ARRAY_SIZE(it6505->sha1_input),\n\t\t\t\t     it6505->sha1_input);\n\t\tfor (i = 0; i < it6505->hdcp_down_stream_count; i++) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev, \"KSV_%d = 0x%*ph\", i,\n\t\t\t\t\t     DRM_HDCP_KSV_LEN, sha1);\n\t\t\tsha1 += DRM_HDCP_KSV_LEN;\n\t\t}\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"binfo: 0x%2ph M0: 0x%8ph\",\n\t\t\t\t     sha1, sha1 + 2);\n\t}\n}\n\nstatic void it6505_stop_link_train(struct it6505 *it6505)\n{\n\tit6505->link_state = LINK_IDLE;\n\tcancel_work_sync(&it6505->link_works);\n\tit6505_write(it6505, REG_TRAIN_CTRL1, FORCE_RETRAIN);\n}\n\nstatic void it6505_link_train_ok(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tit6505->link_state = LINK_OK;\n\t \n\tit6505_set_bits(it6505, REG_DATA_MUTE_CTRL, EN_VID_MUTE, 0x00);\n\tit6505_set_bits(it6505, REG_INFOFRAME_CTRL,\n\t\t\tEN_VID_CTRL_PKT, EN_VID_CTRL_PKT);\n\n\tif (it6505_audio_input(it6505)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"Enable audio!\");\n\t\tit6505_enable_audio(it6505);\n\t}\n\n\tif (it6505->hdcp_desired)\n\t\tit6505_start_hdcp(it6505);\n}\n\nstatic void it6505_link_step_train_process(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tint ret, i, step_retry = 3;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Start step train\");\n\n\tif (it6505->sink_count == 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505->sink_count:%d, force eq\",\n\t\t\t\t     it6505->sink_count);\n\t\tit6505_set_bits(it6505,\tREG_TRAIN_CTRL0, FORCE_EQ_DONE,\n\t\t\t\tFORCE_EQ_DONE);\n\t\treturn;\n\t}\n\n\tif (!it6505->step_train) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"not support step train\");\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < step_retry; i++) {\n\t\tit6505_link_reset_step_train(it6505);\n\t\tret = it6505_link_start_step_train(it6505);\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"step train %s, retry:%d times\",\n\t\t\t\t     ret ? \"pass\" : \"failed\", i + 1);\n\t\tif (ret) {\n\t\t\tit6505_link_train_ok(it6505);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"training fail\");\n\tit6505->link_state = LINK_IDLE;\n\tit6505_video_reset(it6505);\n}\n\nstatic void it6505_link_training_work(struct work_struct *work)\n{\n\tstruct it6505 *it6505 = container_of(work, struct it6505, link_works);\n\tstruct device *dev = it6505->dev;\n\tint ret;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505->sink_count: %d\",\n\t\t\t     it6505->sink_count);\n\n\tif (!it6505_get_sink_hpd_status(it6505))\n\t\treturn;\n\n\tit6505_link_training_setup(it6505);\n\tit6505_reset_hdcp(it6505);\n\tit6505_aux_reset(it6505);\n\n\tif (it6505->auto_train_retry < 1) {\n\t\tit6505_link_step_train_process(it6505);\n\t\treturn;\n\t}\n\n\tret = it6505_link_start_auto_train(it6505);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"auto train %s, auto_train_retry: %d\",\n\t\t\t     ret ? \"pass\" : \"failed\", it6505->auto_train_retry);\n\tit6505->auto_train_retry--;\n\n\tif (ret) {\n\t\tit6505_link_train_ok(it6505);\n\t\treturn;\n\t}\n\n\tit6505_dump(it6505);\n}\n\nstatic void it6505_plugged_status_to_codec(struct it6505 *it6505)\n{\n\tenum drm_connector_status status = it6505->connector_status;\n\n\tif (it6505->plugged_cb && it6505->codec_dev)\n\t\tit6505->plugged_cb(it6505->codec_dev,\n\t\t\t\t   status == connector_status_connected);\n}\n\nstatic void it6505_remove_edid(struct it6505 *it6505)\n{\n\tkfree(it6505->cached_edid);\n\tit6505->cached_edid = NULL;\n}\n\nstatic int it6505_process_hpd_irq(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tint ret, dpcd_sink_count, dp_irq_vector, bstatus;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\n\tif (!it6505_get_sink_hpd_status(it6505)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"HPD_IRQ HPD low\");\n\t\tit6505->sink_count = 0;\n\t\treturn 0;\n\t}\n\n\tret = it6505_dpcd_read(it6505, DP_SINK_COUNT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdpcd_sink_count = DP_GET_SINK_COUNT(ret);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"dpcd_sink_count: %d it6505->sink_count:%d\",\n\t\t\t     dpcd_sink_count, it6505->sink_count);\n\n\tif (it6505->branch_device && dpcd_sink_count != it6505->sink_count) {\n\t\tmemset(it6505->dpcd, 0, sizeof(it6505->dpcd));\n\t\tit6505->sink_count = dpcd_sink_count;\n\t\tit6505_reset_logic(it6505);\n\t\tit6505_int_mask_enable(it6505);\n\t\tit6505_init(it6505);\n\t\tit6505_remove_edid(it6505);\n\t\treturn 0;\n\t}\n\n\tdp_irq_vector = it6505_dpcd_read(it6505, DP_DEVICE_SERVICE_IRQ_VECTOR);\n\tif (dp_irq_vector < 0)\n\t\treturn dp_irq_vector;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"dp_irq_vector = 0x%02x\", dp_irq_vector);\n\n\tif (dp_irq_vector & DP_CP_IRQ) {\n\t\tit6505_set_bits(it6505, REG_HDCP_TRIGGER, HDCP_TRIGGER_CPIRQ,\n\t\t\t\tHDCP_TRIGGER_CPIRQ);\n\n\t\tbstatus = it6505_dpcd_read(it6505, DP_AUX_HDCP_BSTATUS);\n\t\tif (bstatus < 0)\n\t\t\treturn bstatus;\n\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"Bstatus = 0x%02x\", bstatus);\n\t}\n\n\tret = drm_dp_dpcd_read_link_status(&it6505->aux, link_status);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Fail to read link status ret: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"link status = 0x%*ph\",\n\t\t\t     (int)ARRAY_SIZE(link_status), link_status);\n\n\tif (!drm_dp_channel_eq_ok(link_status, it6505->lane_count)) {\n\t\tit6505->auto_train_retry = AUTO_TRAIN_RETRY;\n\t\tit6505_video_reset(it6505);\n\t}\n\n\treturn 0;\n}\n\nstatic void it6505_irq_hpd(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tint dp_sink_count;\n\n\tit6505->hpd_state = it6505_get_sink_hpd_status(it6505);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hpd change interrupt, change to %s\",\n\t\t\t     it6505->hpd_state ? \"high\" : \"low\");\n\n\tif (it6505->hpd_state) {\n\t\twait_for_completion_timeout(&it6505->extcon_completion,\n\t\t\t\t\t    msecs_to_jiffies(1000));\n\t\tit6505_aux_on(it6505);\n\t\tif (it6505->dpcd[0] == 0) {\n\t\t\tit6505_get_dpcd(it6505, DP_DPCD_REV, it6505->dpcd,\n\t\t\t\t\tARRAY_SIZE(it6505->dpcd));\n\t\t\tit6505_variable_config(it6505);\n\t\t\tit6505_parse_link_capabilities(it6505);\n\t\t}\n\t\tit6505->auto_train_retry = AUTO_TRAIN_RETRY;\n\n\t\tit6505_drm_dp_link_set_power(&it6505->aux, &it6505->link,\n\t\t\t\t\t     DP_SET_POWER_D0);\n\t\tdp_sink_count = it6505_dpcd_read(it6505, DP_SINK_COUNT);\n\t\tit6505->sink_count = DP_GET_SINK_COUNT(dp_sink_count);\n\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505->sink_count: %d\",\n\t\t\t\t     it6505->sink_count);\n\n\t\tit6505_lane_termination_on(it6505);\n\t\tit6505_lane_power_on(it6505);\n\n\t\t \n\n\t\tif (it6505->branch_device && it6505->sink_count == 0)\n\t\t\tschedule_work(&it6505->link_works);\n\n\t\tif (!it6505_get_video_status(it6505))\n\t\t\tit6505_video_reset(it6505);\n\t} else {\n\t\tmemset(it6505->dpcd, 0, sizeof(it6505->dpcd));\n\t\tit6505_remove_edid(it6505);\n\n\t\tif (it6505->hdcp_desired)\n\t\t\tit6505_stop_hdcp(it6505);\n\n\t\tit6505_video_disable(it6505);\n\t\tit6505_disable_audio(it6505);\n\t\tit6505_stop_link_train(it6505);\n\t\tit6505_lane_off(it6505);\n\t\tit6505_link_reset_step_train(it6505);\n\t}\n\n\tif (it6505->bridge.dev)\n\t\tdrm_helper_hpd_irq_event(it6505->bridge.dev);\n}\n\nstatic void it6505_irq_hpd_irq(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hpd_irq interrupt\");\n\n\tif (it6505_process_hpd_irq(it6505) < 0)\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"process hpd_irq fail!\");\n}\n\nstatic void it6505_irq_scdt(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tbool data;\n\n\tdata = it6505_get_video_status(it6505);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"video stable change interrupt, %s\",\n\t\t\t     data ? \"stable\" : \"unstable\");\n\tit6505_calc_video_info(it6505);\n\tit6505_link_reset_step_train(it6505);\n\n\tif (data)\n\t\tschedule_work(&it6505->link_works);\n}\n\nstatic void it6505_irq_hdcp_done(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hdcp done interrupt\");\n\tit6505->hdcp_status = HDCP_AUTH_DONE;\n\tit6505_show_hdcp_info(it6505);\n}\n\nstatic void it6505_irq_hdcp_fail(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"hdcp fail interrupt\");\n\tit6505->hdcp_status = HDCP_AUTH_IDLE;\n\tit6505_show_hdcp_info(it6505);\n\tit6505_start_hdcp(it6505);\n}\n\nstatic void it6505_irq_aux_cmd_fail(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"AUX PC Request Fail Interrupt\");\n}\n\nstatic void it6505_irq_hdcp_ksv_check(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"HDCP event Interrupt\");\n\tschedule_work(&it6505->hdcp_wait_ksv_list);\n}\n\nstatic void it6505_irq_audio_fifo_error(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"audio fifo error Interrupt\");\n\n\tif (it6505_audio_input(it6505))\n\t\tit6505_enable_audio(it6505);\n}\n\nstatic void it6505_irq_link_train_fail(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"link training fail interrupt\");\n\tschedule_work(&it6505->link_works);\n}\n\nstatic void it6505_irq_video_fifo_error(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"video fifo overflow interrupt\");\n\tit6505->auto_train_retry = AUTO_TRAIN_RETRY;\n\tflush_work(&it6505->link_works);\n\tit6505_stop_hdcp(it6505);\n\tit6505_video_reset(it6505);\n}\n\nstatic void it6505_irq_io_latch_fifo_overflow(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"IO latch fifo overflow interrupt\");\n\tit6505->auto_train_retry = AUTO_TRAIN_RETRY;\n\tflush_work(&it6505->link_works);\n\tit6505_stop_hdcp(it6505);\n\tit6505_video_reset(it6505);\n}\n\nstatic bool it6505_test_bit(unsigned int bit, const unsigned int *addr)\n{\n\treturn 1 & (addr[bit / BITS_PER_BYTE] >> (bit % BITS_PER_BYTE));\n}\n\nstatic irqreturn_t it6505_int_threaded_handler(int unused, void *data)\n{\n\tstruct it6505 *it6505 = data;\n\tstruct device *dev = it6505->dev;\n\tstatic const struct {\n\t\tint bit;\n\t\tvoid (*handler)(struct it6505 *it6505);\n\t} irq_vec[] = {\n\t\t{ BIT_INT_HPD, it6505_irq_hpd },\n\t\t{ BIT_INT_HPD_IRQ, it6505_irq_hpd_irq },\n\t\t{ BIT_INT_SCDT, it6505_irq_scdt },\n\t\t{ BIT_INT_HDCP_FAIL, it6505_irq_hdcp_fail },\n\t\t{ BIT_INT_HDCP_DONE, it6505_irq_hdcp_done },\n\t\t{ BIT_INT_AUX_CMD_FAIL, it6505_irq_aux_cmd_fail },\n\t\t{ BIT_INT_HDCP_KSV_CHECK, it6505_irq_hdcp_ksv_check },\n\t\t{ BIT_INT_AUDIO_FIFO_ERROR, it6505_irq_audio_fifo_error },\n\t\t{ BIT_INT_LINK_TRAIN_FAIL, it6505_irq_link_train_fail },\n\t\t{ BIT_INT_VID_FIFO_ERROR, it6505_irq_video_fifo_error },\n\t\t{ BIT_INT_IO_FIFO_OVERFLOW, it6505_irq_io_latch_fifo_overflow },\n\t};\n\tint int_status[3], i;\n\n\tif (it6505->enable_drv_hold || !it6505->powered)\n\t\treturn IRQ_HANDLED;\n\n\tpm_runtime_get_sync(dev);\n\n\tint_status[0] = it6505_read(it6505, INT_STATUS_01);\n\tint_status[1] = it6505_read(it6505, INT_STATUS_02);\n\tint_status[2] = it6505_read(it6505, INT_STATUS_03);\n\n\tit6505_write(it6505, INT_STATUS_01, int_status[0]);\n\tit6505_write(it6505, INT_STATUS_02, int_status[1]);\n\tit6505_write(it6505, INT_STATUS_03, int_status[2]);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"reg06 = 0x%02x\", int_status[0]);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"reg07 = 0x%02x\", int_status[1]);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"reg08 = 0x%02x\", int_status[2]);\n\tit6505_debug_print(it6505, REG_SYSTEM_STS, \"\");\n\n\tif (it6505_test_bit(irq_vec[0].bit, (unsigned int *)int_status))\n\t\tirq_vec[0].handler(it6505);\n\n\tif (it6505->hpd_state) {\n\t\tfor (i = 1; i < ARRAY_SIZE(irq_vec); i++) {\n\t\t\tif (it6505_test_bit(irq_vec[i].bit, (unsigned int *)int_status))\n\t\t\t\tirq_vec[i].handler(it6505);\n\t\t}\n\t}\n\n\tpm_runtime_put_sync(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int it6505_poweron(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tstruct it6505_platform_data *pdata = &it6505->pdata;\n\tint err;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505 start powered on\");\n\n\tif (it6505->powered) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505 already powered on\");\n\t\treturn 0;\n\t}\n\n\tif (pdata->pwr18) {\n\t\terr = regulator_enable(pdata->pwr18);\n\t\tif (err) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev, \"Failed to enable VDD18: %d\",\n\t\t\t\t\t     err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (pdata->ovdd) {\n\t\t \n\t\tusleep_range(1000, 2000);\n\t\terr = regulator_enable(pdata->ovdd);\n\t\tif (err) {\n\t\t\tregulator_disable(pdata->pwr18);\n\t\t\treturn err;\n\t\t}\n\t}\n\t \n\tif (pdata->gpiod_reset) {\n\t\tusleep_range(10000, 20000);\n\t\tgpiod_set_value_cansleep(pdata->gpiod_reset, 0);\n\t\tusleep_range(1000, 2000);\n\t\tgpiod_set_value_cansleep(pdata->gpiod_reset, 1);\n\t\tusleep_range(10000, 20000);\n\t}\n\n\tit6505->powered = true;\n\tit6505_reset_logic(it6505);\n\tit6505_int_mask_enable(it6505);\n\tit6505_init(it6505);\n\tit6505_lane_off(it6505);\n\n\treturn 0;\n}\n\nstatic int it6505_poweroff(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tstruct it6505_platform_data *pdata = &it6505->pdata;\n\tint err;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505 start power off\");\n\n\tif (!it6505->powered) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"power had been already off\");\n\t\treturn 0;\n\t}\n\n\tif (pdata->gpiod_reset)\n\t\tgpiod_set_value_cansleep(pdata->gpiod_reset, 0);\n\n\tif (pdata->pwr18) {\n\t\terr = regulator_disable(pdata->pwr18);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (pdata->ovdd) {\n\t\terr = regulator_disable(pdata->ovdd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tit6505->powered = false;\n\tit6505->sink_count = 0;\n\n\treturn 0;\n}\n\nstatic enum drm_connector_status it6505_detect(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tenum drm_connector_status status = connector_status_disconnected;\n\tint dp_sink_count;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505->sink_count:%d powered:%d\",\n\t\t\t     it6505->sink_count, it6505->powered);\n\n\tmutex_lock(&it6505->mode_lock);\n\n\tif (!it6505->powered)\n\t\tgoto unlock;\n\n\tif (it6505->enable_drv_hold) {\n\t\tstatus = it6505->hpd_state ? connector_status_connected :\n\t\t\t\t\t     connector_status_disconnected;\n\t\tgoto unlock;\n\t}\n\n\tif (it6505->hpd_state) {\n\t\tit6505_drm_dp_link_set_power(&it6505->aux, &it6505->link,\n\t\t\t\t\t     DP_SET_POWER_D0);\n\t\tdp_sink_count = it6505_dpcd_read(it6505, DP_SINK_COUNT);\n\t\tit6505->sink_count = DP_GET_SINK_COUNT(dp_sink_count);\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505->sink_count:%d branch:%d\",\n\t\t\t\t     it6505->sink_count, it6505->branch_device);\n\n\t\tif (it6505->branch_device) {\n\t\t\tstatus = (it6505->sink_count != 0) ?\n\t\t\t\t connector_status_connected :\n\t\t\t\t connector_status_disconnected;\n\t\t} else {\n\t\t\tstatus = connector_status_connected;\n\t\t}\n\t} else {\n\t\tit6505->sink_count = 0;\n\t\tmemset(it6505->dpcd, 0, sizeof(it6505->dpcd));\n\t}\n\nunlock:\n\tif (it6505->connector_status != status) {\n\t\tit6505->connector_status = status;\n\t\tit6505_plugged_status_to_codec(it6505);\n\t}\n\n\tmutex_unlock(&it6505->mode_lock);\n\n\treturn status;\n}\n\nstatic int it6505_extcon_notifier(struct notifier_block *self,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct it6505 *it6505 = container_of(self, struct it6505, event_nb);\n\n\tschedule_work(&it6505->extcon_wq);\n\treturn NOTIFY_DONE;\n}\n\nstatic void it6505_extcon_work(struct work_struct *work)\n{\n\tstruct it6505 *it6505 = container_of(work, struct it6505, extcon_wq);\n\tstruct device *dev = it6505->dev;\n\tint state, ret;\n\n\tif (it6505->enable_drv_hold)\n\t\treturn;\n\n\tmutex_lock(&it6505->extcon_lock);\n\n\tstate = extcon_get_state(it6505->extcon, EXTCON_DISP_DP);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"EXTCON_DISP_DP = 0x%02x\", state);\n\n\tif (state == it6505->extcon_state || unlikely(state < 0))\n\t\tgoto unlock;\n\tit6505->extcon_state = state;\n\tif (state) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"start to power on\");\n\t\tmsleep(100);\n\t\tret = pm_runtime_get_sync(dev);\n\n\t\t \n\t\tif (ret < 0)\n\t\t\tit6505_poweron(it6505);\n\n\t\tcomplete_all(&it6505->extcon_completion);\n\t} else {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"start to power off\");\n\t\tpm_runtime_put_sync(dev);\n\t\treinit_completion(&it6505->extcon_completion);\n\n\t\tdrm_helper_hpd_irq_event(it6505->bridge.dev);\n\t\tmemset(it6505->dpcd, 0, sizeof(it6505->dpcd));\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"power off it6505 success!\");\n\t}\n\nunlock:\n\tmutex_unlock(&it6505->extcon_lock);\n}\n\nstatic int it6505_use_notifier_module(struct it6505 *it6505)\n{\n\tint ret;\n\tstruct device *dev = it6505->dev;\n\n\tit6505->event_nb.notifier_call = it6505_extcon_notifier;\n\tINIT_WORK(&it6505->extcon_wq, it6505_extcon_work);\n\tret = devm_extcon_register_notifier(it6505->dev,\n\t\t\t\t\t    it6505->extcon, EXTCON_DISP_DP,\n\t\t\t\t\t    &it6505->event_nb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register notifier for DP\");\n\t\treturn ret;\n\t}\n\n\tschedule_work(&it6505->extcon_wq);\n\n\treturn 0;\n}\n\nstatic void it6505_remove_notifier_module(struct it6505 *it6505)\n{\n\tif (it6505->extcon) {\n\t\tdevm_extcon_unregister_notifier(it6505->dev,\n\t\t\t\t\t\tit6505->extcon,\tEXTCON_DISP_DP,\n\t\t\t\t\t\t&it6505->event_nb);\n\n\t\tflush_work(&it6505->extcon_wq);\n\t}\n}\n\nstatic void __maybe_unused it6505_delayed_audio(struct work_struct *work)\n{\n\tstruct it6505 *it6505 = container_of(work, struct it6505,\n\t\t\t\t\t     delayed_audio.work);\n\n\tDRM_DEV_DEBUG_DRIVER(it6505->dev, \"start\");\n\n\tif (!it6505->powered)\n\t\treturn;\n\n\tif (!it6505->enable_drv_hold)\n\t\tit6505_enable_audio(it6505);\n}\n\nstatic int __maybe_unused it6505_audio_setup_hw_params(struct it6505 *it6505,\n\t\t\t\t\t\t       struct hdmi_codec_params\n\t\t\t\t\t\t       *params)\n{\n\tstruct device *dev = it6505->dev;\n\tint i = 0;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"%s %d Hz, %d bit, %d channels\\n\", __func__,\n\t\t\t     params->sample_rate, params->sample_width,\n\t\t\t     params->cea.channels);\n\n\tif (!it6505->bridge.encoder)\n\t\treturn -ENODEV;\n\n\tif (params->cea.channels <= 1 || params->cea.channels > 8) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"channel number: %d not support\",\n\t\t\t\t     it6505->audio.channel_count);\n\t\treturn -EINVAL;\n\t}\n\n\tit6505->audio.channel_count = params->cea.channels;\n\n\twhile (i < ARRAY_SIZE(audio_sample_rate_map) &&\n\t       params->sample_rate !=\n\t\t       audio_sample_rate_map[i].sample_rate_value) {\n\t\ti++;\n\t}\n\tif (i == ARRAY_SIZE(audio_sample_rate_map)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"sample rate: %d Hz not support\",\n\t\t\t\t     params->sample_rate);\n\t\treturn -EINVAL;\n\t}\n\tit6505->audio.sample_rate = audio_sample_rate_map[i].rate;\n\n\tswitch (params->sample_width) {\n\tcase 16:\n\t\tit6505->audio.word_length = WORD_LENGTH_16BIT;\n\t\tbreak;\n\tcase 18:\n\t\tit6505->audio.word_length = WORD_LENGTH_18BIT;\n\t\tbreak;\n\tcase 20:\n\t\tit6505->audio.word_length = WORD_LENGTH_20BIT;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tit6505->audio.word_length = WORD_LENGTH_24BIT;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"wordlength: %d bit not support\",\n\t\t\t\t     params->sample_width);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void __maybe_unused it6505_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct it6505 *it6505 = dev_get_drvdata(dev);\n\n\tif (it6505->powered)\n\t\tit6505_disable_audio(it6505);\n}\n\nstatic int __maybe_unused it6505_audio_hook_plugged_cb(struct device *dev,\n\t\t\t\t\t\t       void *data,\n\t\t\t\t\t\t       hdmi_codec_plugged_cb fn,\n\t\t\t\t\t\t       struct device *codec_dev)\n{\n\tstruct it6505 *it6505 = data;\n\n\tit6505->plugged_cb = fn;\n\tit6505->codec_dev = codec_dev;\n\tit6505_plugged_status_to_codec(it6505);\n\n\treturn 0;\n}\n\nstatic inline struct it6505 *bridge_to_it6505(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct it6505, bridge);\n}\n\nstatic int it6505_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\tstruct device *dev = it6505->dev;\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tDRM_ERROR(\"DRM_BRIDGE_ATTACH_NO_CONNECTOR must be supplied\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tdev_err(dev, \"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tit6505->aux.drm_dev = bridge->dev;\n\n\tret = drm_dp_aux_register(&it6505->aux);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register aux: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tif (it6505->extcon) {\n\t\tret = it6505_use_notifier_module(it6505);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"use notifier module failed\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void it6505_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\n\tflush_work(&it6505->link_works);\n\tit6505_remove_notifier_module(it6505);\n}\n\nstatic enum drm_mode_status\nit6505_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t const struct drm_display_info *info,\n\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\tif (mode->clock > it6505->max_dpi_pixel_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tit6505->video_info.clock = mode->clock;\n\n\treturn MODE_OK;\n}\n\nstatic void it6505_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_state)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\tstruct device *dev = it6505->dev;\n\tstruct drm_atomic_state *state = old_state->base.state;\n\tstruct hdmi_avi_infoframe frame;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\n\tif (WARN_ON(!connector))\n\t\treturn;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\n\tif (WARN_ON(!conn_state))\n\t\treturn;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\n\tif (WARN_ON(!crtc_state))\n\t\treturn;\n\n\tmode = &crtc_state->adjusted_mode;\n\n\tif (WARN_ON(!mode))\n\t\treturn;\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       connector,\n\t\t\t\t\t\t       mode);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to setup AVI infoframe: %d\", ret);\n\n\tit6505_update_video_parameter(it6505, mode);\n\n\tret = it6505_send_video_infoframe(it6505, &frame);\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to send AVI infoframe: %d\", ret);\n\n\tit6505_int_mask_enable(it6505);\n\tit6505_video_reset(it6505);\n\n\tit6505_drm_dp_link_set_power(&it6505->aux, &it6505->link,\n\t\t\t\t     DP_SET_POWER_D0);\n}\n\nstatic void it6505_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_state)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\n\tif (it6505->powered) {\n\t\tit6505_drm_dp_link_set_power(&it6505->aux, &it6505->link,\n\t\t\t\t\t     DP_SET_POWER_D3);\n\t\tit6505_video_disable(it6505);\n\t}\n}\n\nstatic void it6505_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *old_state)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\n\tpm_runtime_get_sync(dev);\n}\n\nstatic void it6505_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_bridge_state *old_state)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\tstruct device *dev = it6505->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"start\");\n\n\tpm_runtime_put_sync(dev);\n}\n\nstatic enum drm_connector_status\nit6505_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\n\treturn it6505_detect(it6505);\n}\n\nstatic struct edid *it6505_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct it6505 *it6505 = bridge_to_it6505(bridge);\n\tstruct device *dev = it6505->dev;\n\n\tif (!it6505->cached_edid) {\n\t\tit6505->cached_edid = drm_do_get_edid(connector, it6505_get_edid_block,\n\t\t\t\t\t\t      it6505);\n\n\t\tif (!it6505->cached_edid) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev, \"failed to get edid!\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn drm_edid_duplicate(it6505->cached_edid);\n}\n\nstatic const struct drm_bridge_funcs it6505_bridge_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.attach = it6505_bridge_attach,\n\t.detach = it6505_bridge_detach,\n\t.mode_valid = it6505_bridge_mode_valid,\n\t.atomic_enable = it6505_bridge_atomic_enable,\n\t.atomic_disable = it6505_bridge_atomic_disable,\n\t.atomic_pre_enable = it6505_bridge_atomic_pre_enable,\n\t.atomic_post_disable = it6505_bridge_atomic_post_disable,\n\t.detect = it6505_bridge_detect,\n\t.get_edid = it6505_bridge_get_edid,\n};\n\nstatic __maybe_unused int it6505_bridge_resume(struct device *dev)\n{\n\tstruct it6505 *it6505 = dev_get_drvdata(dev);\n\n\treturn it6505_poweron(it6505);\n}\n\nstatic __maybe_unused int it6505_bridge_suspend(struct device *dev)\n{\n\tstruct it6505 *it6505 = dev_get_drvdata(dev);\n\n\treturn it6505_poweroff(it6505);\n}\n\nstatic const struct dev_pm_ops it6505_bridge_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(it6505_bridge_suspend, it6505_bridge_resume, NULL)\n};\n\nstatic int it6505_init_pdata(struct it6505 *it6505)\n{\n\tstruct it6505_platform_data *pdata = &it6505->pdata;\n\tstruct device *dev = it6505->dev;\n\n\t \n\tpdata->pwr18 = devm_regulator_get(dev, \"pwr18\");\n\tif (IS_ERR(pdata->pwr18)) {\n\t\tdev_err(dev, \"pwr18 regulator not found\");\n\t\treturn PTR_ERR(pdata->pwr18);\n\t}\n\n\tpdata->ovdd = devm_regulator_get(dev, \"ovdd\");\n\tif (IS_ERR(pdata->ovdd)) {\n\t\tdev_err(dev, \"ovdd regulator not found\");\n\t\treturn PTR_ERR(pdata->ovdd);\n\t}\n\n\tpdata->gpiod_reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(pdata->gpiod_reset)) {\n\t\tdev_err(dev, \"gpiod_reset gpio not found\");\n\t\treturn PTR_ERR(pdata->gpiod_reset);\n\t}\n\n\treturn 0;\n}\n\nstatic int it6505_get_data_lanes_count(const struct device_node *endpoint,\n\t\t\t\t       const unsigned int min,\n\t\t\t\t       const unsigned int max)\n{\n\tint ret;\n\n\tret = of_property_count_u32_elems(endpoint, \"data-lanes\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret < min || ret > max)\n\t\treturn -EINVAL;\n\n\treturn ret;\n}\n\nstatic void it6505_parse_dt(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\tstruct device_node *np = dev->of_node, *ep = NULL;\n\tint len;\n\tu64 link_frequencies;\n\tu32 data_lanes[4];\n\tu32 *afe_setting = &it6505->afe_setting;\n\tu32 *max_lane_count = &it6505->max_lane_count;\n\tu32 *max_dpi_pixel_clock = &it6505->max_dpi_pixel_clock;\n\n\tit6505->lane_swap_disabled =\n\t\tdevice_property_read_bool(dev, \"no-laneswap\");\n\n\tif (it6505->lane_swap_disabled)\n\t\tit6505->lane_swap = false;\n\n\tif (device_property_read_u32(dev, \"afe-setting\", afe_setting) == 0) {\n\t\tif (*afe_setting >= ARRAY_SIZE(afe_setting_table)) {\n\t\t\tdev_err(dev, \"afe setting error, use default\");\n\t\t\t*afe_setting = 0;\n\t\t}\n\t} else {\n\t\t*afe_setting = 0;\n\t}\n\n\tep = of_graph_get_endpoint_by_regs(np, 1, 0);\n\tof_node_put(ep);\n\n\tif (ep) {\n\t\tlen = it6505_get_data_lanes_count(ep, 1, 4);\n\n\t\tif (len > 0 && len != 3) {\n\t\t\tof_property_read_u32_array(ep, \"data-lanes\",\n\t\t\t\t\t\t   data_lanes, len);\n\t\t\t*max_lane_count = len;\n\t\t} else {\n\t\t\t*max_lane_count = MAX_LANE_COUNT;\n\t\t\tdev_err(dev, \"error data-lanes, use default\");\n\t\t}\n\t} else {\n\t\t*max_lane_count = MAX_LANE_COUNT;\n\t\tdev_err(dev, \"error endpoint, use default\");\n\t}\n\n\tep = of_graph_get_endpoint_by_regs(np, 0, 0);\n\tof_node_put(ep);\n\n\tif (ep) {\n\t\tlen = of_property_read_variable_u64_array(ep,\n\t\t\t\t\t\t\t  \"link-frequencies\",\n\t\t\t\t\t\t\t  &link_frequencies, 0,\n\t\t\t\t\t\t\t  1);\n\t\tif (len >= 0) {\n\t\t\tdo_div(link_frequencies, 1000);\n\t\t\tif (link_frequencies > 297000) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"max pixel clock error, use default\");\n\t\t\t\t*max_dpi_pixel_clock = DPI_PIXEL_CLK_MAX;\n\t\t\t} else {\n\t\t\t\t*max_dpi_pixel_clock = link_frequencies;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(dev, \"error link frequencies, use default\");\n\t\t\t*max_dpi_pixel_clock = DPI_PIXEL_CLK_MAX;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"error endpoint, use default\");\n\t\t*max_dpi_pixel_clock = DPI_PIXEL_CLK_MAX;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"using afe_setting: %u, max_lane_count: %u\",\n\t\t\t     it6505->afe_setting, it6505->max_lane_count);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"using max_dpi_pixel_clock: %u kHz\",\n\t\t\t     it6505->max_dpi_pixel_clock);\n}\n\nstatic ssize_t receive_timing_debugfs_show(struct file *file, char __user *buf,\n\t\t\t\t\t   size_t len, loff_t *ppos)\n{\n\tstruct it6505 *it6505 = file->private_data;\n\tstruct drm_display_mode *vid;\n\tu8 read_buf[READ_BUFFER_SIZE];\n\tu8 *str = read_buf, *end = read_buf + READ_BUFFER_SIZE;\n\tssize_t ret, count;\n\n\tif (!it6505)\n\t\treturn -ENODEV;\n\n\tit6505_calc_video_info(it6505);\n\tvid = &it6505->video_info;\n\tstr += scnprintf(str, end - str, \"---video timing---\\n\");\n\tstr += scnprintf(str, end - str, \"PCLK:%d.%03dMHz\\n\",\n\t\t\t vid->clock / 1000, vid->clock % 1000);\n\tstr += scnprintf(str, end - str, \"HTotal:%d\\n\", vid->htotal);\n\tstr += scnprintf(str, end - str, \"HActive:%d\\n\", vid->hdisplay);\n\tstr += scnprintf(str, end - str, \"HFrontPorch:%d\\n\",\n\t\t\t vid->hsync_start - vid->hdisplay);\n\tstr += scnprintf(str, end - str, \"HSyncWidth:%d\\n\",\n\t\t\t vid->hsync_end - vid->hsync_start);\n\tstr += scnprintf(str, end - str, \"HBackPorch:%d\\n\",\n\t\t\t vid->htotal - vid->hsync_end);\n\tstr += scnprintf(str, end - str, \"VTotal:%d\\n\", vid->vtotal);\n\tstr += scnprintf(str, end - str, \"VActive:%d\\n\", vid->vdisplay);\n\tstr += scnprintf(str, end - str, \"VFrontPorch:%d\\n\",\n\t\t\t vid->vsync_start - vid->vdisplay);\n\tstr += scnprintf(str, end - str, \"VSyncWidth:%d\\n\",\n\t\t\t vid->vsync_end - vid->vsync_start);\n\tstr += scnprintf(str, end - str, \"VBackPorch:%d\\n\",\n\t\t\t vid->vtotal - vid->vsync_end);\n\n\tcount = str - read_buf;\n\tret = simple_read_from_buffer(buf, len, ppos, read_buf, count);\n\n\treturn ret;\n}\n\nstatic int force_power_on_off_debugfs_write(void *data, u64 value)\n{\n\tstruct it6505 *it6505 = data;\n\n\tif (!it6505)\n\t\treturn -ENODEV;\n\n\tif (value)\n\t\tit6505_poweron(it6505);\n\telse\n\t\tit6505_poweroff(it6505);\n\n\treturn 0;\n}\n\nstatic int enable_drv_hold_debugfs_show(void *data, u64 *buf)\n{\n\tstruct it6505 *it6505 = data;\n\n\tif (!it6505)\n\t\treturn -ENODEV;\n\n\t*buf = it6505->enable_drv_hold;\n\n\treturn 0;\n}\n\nstatic int enable_drv_hold_debugfs_write(void *data, u64 drv_hold)\n{\n\tstruct it6505 *it6505 = data;\n\n\tif (!it6505)\n\t\treturn -ENODEV;\n\n\tit6505->enable_drv_hold = drv_hold;\n\n\tif (it6505->enable_drv_hold) {\n\t\tit6505_int_mask_disable(it6505);\n\t} else {\n\t\tit6505_clear_int(it6505);\n\t\tit6505_int_mask_enable(it6505);\n\n\t\tif (it6505->powered) {\n\t\t\tit6505->connector_status =\n\t\t\t\t\tit6505_get_sink_hpd_status(it6505) ?\n\t\t\t\t\tconnector_status_connected :\n\t\t\t\t\tconnector_status_disconnected;\n\t\t} else {\n\t\t\tit6505->connector_status =\n\t\t\t\t\tconnector_status_disconnected;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations receive_timing_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = receive_timing_debugfs_show,\n\t.llseek = default_llseek,\n};\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_force_power, NULL,\n\t\t\t force_power_on_off_debugfs_write, \"%llu\\n\");\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_enable_drv_hold, enable_drv_hold_debugfs_show,\n\t\t\t enable_drv_hold_debugfs_write, \"%llu\\n\");\n\nstatic const struct debugfs_entries debugfs_entry[] = {\n\t{ \"receive_timing\", &receive_timing_fops },\n\t{ \"force_power_on_off\", &fops_force_power },\n\t{ \"enable_drv_hold\", &fops_enable_drv_hold },\n\t{ NULL, NULL },\n};\n\nstatic void debugfs_create_files(struct it6505 *it6505)\n{\n\tint i = 0;\n\n\twhile (debugfs_entry[i].name && debugfs_entry[i].fops) {\n\t\tdebugfs_create_file(debugfs_entry[i].name, 0644,\n\t\t\t\t    it6505->debugfs, it6505,\n\t\t\t\t    debugfs_entry[i].fops);\n\t\ti++;\n\t}\n}\n\nstatic void debugfs_init(struct it6505 *it6505)\n{\n\tstruct device *dev = it6505->dev;\n\n\tit6505->debugfs = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL);\n\n\tif (IS_ERR(it6505->debugfs)) {\n\t\tdev_err(dev, \"failed to create debugfs root\");\n\t\treturn;\n\t}\n\n\tdebugfs_create_files(it6505);\n}\n\nstatic void it6505_debugfs_remove(struct it6505 *it6505)\n{\n\tdebugfs_remove_recursive(it6505->debugfs);\n}\n\nstatic void it6505_shutdown(struct i2c_client *client)\n{\n\tstruct it6505 *it6505 = dev_get_drvdata(&client->dev);\n\n\tif (it6505->powered)\n\t\tit6505_lane_off(it6505);\n}\n\nstatic int it6505_i2c_probe(struct i2c_client *client)\n{\n\tstruct it6505 *it6505;\n\tstruct device *dev = &client->dev;\n\tstruct extcon_dev *extcon;\n\tint err, intp_irq;\n\n\tit6505 = devm_kzalloc(&client->dev, sizeof(*it6505), GFP_KERNEL);\n\tif (!it6505)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&it6505->extcon_lock);\n\tmutex_init(&it6505->mode_lock);\n\tmutex_init(&it6505->aux_lock);\n\n\tit6505->bridge.of_node = client->dev.of_node;\n\tit6505->connector_status = connector_status_disconnected;\n\tit6505->dev = &client->dev;\n\ti2c_set_clientdata(client, it6505);\n\n\t \n\textcon = extcon_get_edev_by_phandle(dev, 0);\n\tif (PTR_ERR(extcon) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\tif (IS_ERR(extcon)) {\n\t\tdev_err(dev, \"can not get extcon device!\");\n\t\treturn PTR_ERR(extcon);\n\t}\n\n\tit6505->extcon = extcon;\n\n\tit6505->regmap = devm_regmap_init_i2c(client, &it6505_regmap_config);\n\tif (IS_ERR(it6505->regmap)) {\n\t\tdev_err(dev, \"regmap i2c init failed\");\n\t\terr = PTR_ERR(it6505->regmap);\n\t\treturn err;\n\t}\n\n\terr = it6505_init_pdata(it6505);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to initialize pdata: %d\", err);\n\t\treturn err;\n\t}\n\n\tit6505_parse_dt(it6505);\n\n\tintp_irq = client->irq;\n\n\tif (!intp_irq) {\n\t\tdev_err(dev, \"Failed to get INTP IRQ\");\n\t\terr = -ENODEV;\n\t\treturn err;\n\t}\n\n\terr = devm_request_threaded_irq(&client->dev, intp_irq, NULL,\n\t\t\t\t\tit6505_int_threaded_handler,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\"it6505-intp\", it6505);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to request INTP threaded IRQ: %d\", err);\n\t\treturn err;\n\t}\n\n\tINIT_WORK(&it6505->link_works, it6505_link_training_work);\n\tINIT_WORK(&it6505->hdcp_wait_ksv_list, it6505_hdcp_wait_ksv_list);\n\tINIT_DELAYED_WORK(&it6505->hdcp_work, it6505_hdcp_work);\n\tinit_completion(&it6505->extcon_completion);\n\tmemset(it6505->dpcd, 0, sizeof(it6505->dpcd));\n\tit6505->powered = false;\n\tit6505->enable_drv_hold = DEFAULT_DRV_HOLD;\n\n\tif (DEFAULT_PWR_ON)\n\t\tit6505_poweron(it6505);\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"it6505 device name: %s\", dev_name(dev));\n\tdebugfs_init(it6505);\n\tpm_runtime_enable(dev);\n\n\tit6505->aux.name = \"DP-AUX\";\n\tit6505->aux.dev = dev;\n\tit6505->aux.transfer = it6505_aux_transfer;\n\tdrm_dp_aux_init(&it6505->aux);\n\n\tit6505->bridge.funcs = &it6505_bridge_funcs;\n\tit6505->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;\n\tit6505->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID |\n\t\t\t     DRM_BRIDGE_OP_HPD;\n\tdrm_bridge_add(&it6505->bridge);\n\n\treturn 0;\n}\n\nstatic void it6505_i2c_remove(struct i2c_client *client)\n{\n\tstruct it6505 *it6505 = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&it6505->bridge);\n\tdrm_dp_aux_unregister(&it6505->aux);\n\tit6505_debugfs_remove(it6505);\n\tit6505_poweroff(it6505);\n\tit6505_remove_edid(it6505);\n}\n\nstatic const struct i2c_device_id it6505_id[] = {\n\t{ \"it6505\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, it6505_id);\n\nstatic const struct of_device_id it6505_of_match[] = {\n\t{ .compatible = \"ite,it6505\" },\n\t{ }\n};\n\nstatic struct i2c_driver it6505_i2c_driver = {\n\t.driver = {\n\t\t.name = \"it6505\",\n\t\t.of_match_table = it6505_of_match,\n\t\t.pm = &it6505_bridge_pm_ops,\n\t},\n\t.probe = it6505_i2c_probe,\n\t.remove = it6505_i2c_remove,\n\t.shutdown = it6505_shutdown,\n\t.id_table = it6505_id,\n};\n\nmodule_i2c_driver(it6505_i2c_driver);\n\nMODULE_AUTHOR(\"Allen Chen <allen.chen@ite.com.tw>\");\nMODULE_DESCRIPTION(\"IT6505 DisplayPort Transmitter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}