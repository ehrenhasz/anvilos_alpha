{
  "module_name": "sii902x.c",
  "hash_id": "eec6cdf1719188eb0d8532c3094722f31c3680a391c8fe71cc672dc7a6e28e53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/sii902x.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c-mux.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/clk.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include <sound/hdmi-codec.h>\n\n#define SII902X_TPI_VIDEO_DATA\t\t\t0x0\n\n#define SII902X_TPI_PIXEL_REPETITION\t\t0x8\n#define SII902X_TPI_AVI_PIXEL_REP_BUS_24BIT     BIT(5)\n#define SII902X_TPI_AVI_PIXEL_REP_RISING_EDGE   BIT(4)\n#define SII902X_TPI_AVI_PIXEL_REP_4X\t\t3\n#define SII902X_TPI_AVI_PIXEL_REP_2X\t\t1\n#define SII902X_TPI_AVI_PIXEL_REP_NONE\t\t0\n#define SII902X_TPI_CLK_RATIO_HALF\t\t(0 << 6)\n#define SII902X_TPI_CLK_RATIO_1X\t\t(1 << 6)\n#define SII902X_TPI_CLK_RATIO_2X\t\t(2 << 6)\n#define SII902X_TPI_CLK_RATIO_4X\t\t(3 << 6)\n\n#define SII902X_TPI_AVI_IN_FORMAT\t\t0x9\n#define SII902X_TPI_AVI_INPUT_BITMODE_12BIT\tBIT(7)\n#define SII902X_TPI_AVI_INPUT_DITHER\t\tBIT(6)\n#define SII902X_TPI_AVI_INPUT_RANGE_LIMITED\t(2 << 2)\n#define SII902X_TPI_AVI_INPUT_RANGE_FULL\t(1 << 2)\n#define SII902X_TPI_AVI_INPUT_RANGE_AUTO\t(0 << 2)\n#define SII902X_TPI_AVI_INPUT_COLORSPACE_BLACK\t(3 << 0)\n#define SII902X_TPI_AVI_INPUT_COLORSPACE_YUV422\t(2 << 0)\n#define SII902X_TPI_AVI_INPUT_COLORSPACE_YUV444\t(1 << 0)\n#define SII902X_TPI_AVI_INPUT_COLORSPACE_RGB\t(0 << 0)\n\n#define SII902X_TPI_AVI_INFOFRAME\t\t0x0c\n\n#define SII902X_SYS_CTRL_DATA\t\t\t0x1a\n#define SII902X_SYS_CTRL_PWR_DWN\t\tBIT(4)\n#define SII902X_SYS_CTRL_AV_MUTE\t\tBIT(3)\n#define SII902X_SYS_CTRL_DDC_BUS_REQ\t\tBIT(2)\n#define SII902X_SYS_CTRL_DDC_BUS_GRTD\t\tBIT(1)\n#define SII902X_SYS_CTRL_OUTPUT_MODE\t\tBIT(0)\n#define SII902X_SYS_CTRL_OUTPUT_HDMI\t\t1\n#define SII902X_SYS_CTRL_OUTPUT_DVI\t\t0\n\n#define SII902X_REG_CHIPID(n)\t\t\t(0x1b + (n))\n\n#define SII902X_PWR_STATE_CTRL\t\t\t0x1e\n#define SII902X_AVI_POWER_STATE_MSK\t\tGENMASK(1, 0)\n#define SII902X_AVI_POWER_STATE_D(l)\t\t((l) & SII902X_AVI_POWER_STATE_MSK)\n\n \n#define SII902X_TPI_I2S_ENABLE_MAPPING_REG\t0x1f\n#define SII902X_TPI_I2S_CONFIG_FIFO0\t\t\t(0 << 0)\n#define SII902X_TPI_I2S_CONFIG_FIFO1\t\t\t(1 << 0)\n#define SII902X_TPI_I2S_CONFIG_FIFO2\t\t\t(2 << 0)\n#define SII902X_TPI_I2S_CONFIG_FIFO3\t\t\t(3 << 0)\n#define SII902X_TPI_I2S_LEFT_RIGHT_SWAP\t\t\t(1 << 2)\n#define SII902X_TPI_I2S_AUTO_DOWNSAMPLE\t\t\t(1 << 3)\n#define SII902X_TPI_I2S_SELECT_SD0\t\t\t(0 << 4)\n#define SII902X_TPI_I2S_SELECT_SD1\t\t\t(1 << 4)\n#define SII902X_TPI_I2S_SELECT_SD2\t\t\t(2 << 4)\n#define SII902X_TPI_I2S_SELECT_SD3\t\t\t(3 << 4)\n#define SII902X_TPI_I2S_FIFO_ENABLE\t\t\t(1 << 7)\n\n#define SII902X_TPI_I2S_INPUT_CONFIG_REG\t0x20\n#define SII902X_TPI_I2S_FIRST_BIT_SHIFT_YES\t\t(0 << 0)\n#define SII902X_TPI_I2S_FIRST_BIT_SHIFT_NO\t\t(1 << 0)\n#define SII902X_TPI_I2S_SD_DIRECTION_MSB_FIRST\t\t(0 << 1)\n#define SII902X_TPI_I2S_SD_DIRECTION_LSB_FIRST\t\t(1 << 1)\n#define SII902X_TPI_I2S_SD_JUSTIFY_LEFT\t\t\t(0 << 2)\n#define SII902X_TPI_I2S_SD_JUSTIFY_RIGHT\t\t(1 << 2)\n#define SII902X_TPI_I2S_WS_POLARITY_LOW\t\t\t(0 << 3)\n#define SII902X_TPI_I2S_WS_POLARITY_HIGH\t\t(1 << 3)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_128\t\t(0 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_256\t\t(1 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_384\t\t(2 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_512\t\t(3 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_768\t\t(4 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_1024\t\t(5 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_1152\t\t(6 << 4)\n#define SII902X_TPI_I2S_MCLK_MULTIPLIER_192\t\t(7 << 4)\n#define SII902X_TPI_I2S_SCK_EDGE_FALLING\t\t(0 << 7)\n#define SII902X_TPI_I2S_SCK_EDGE_RISING\t\t\t(1 << 7)\n\n#define SII902X_TPI_I2S_STRM_HDR_BASE\t0x21\n#define SII902X_TPI_I2S_STRM_HDR_SIZE\t5\n\n#define SII902X_TPI_AUDIO_CONFIG_BYTE2_REG\t0x26\n#define SII902X_TPI_AUDIO_CODING_STREAM_HEADER\t\t(0 << 0)\n#define SII902X_TPI_AUDIO_CODING_PCM\t\t\t(1 << 0)\n#define SII902X_TPI_AUDIO_CODING_AC3\t\t\t(2 << 0)\n#define SII902X_TPI_AUDIO_CODING_MPEG1\t\t\t(3 << 0)\n#define SII902X_TPI_AUDIO_CODING_MP3\t\t\t(4 << 0)\n#define SII902X_TPI_AUDIO_CODING_MPEG2\t\t\t(5 << 0)\n#define SII902X_TPI_AUDIO_CODING_AAC\t\t\t(6 << 0)\n#define SII902X_TPI_AUDIO_CODING_DTS\t\t\t(7 << 0)\n#define SII902X_TPI_AUDIO_CODING_ATRAC\t\t\t(8 << 0)\n#define SII902X_TPI_AUDIO_MUTE_DISABLE\t\t\t(0 << 4)\n#define SII902X_TPI_AUDIO_MUTE_ENABLE\t\t\t(1 << 4)\n#define SII902X_TPI_AUDIO_LAYOUT_2_CHANNELS\t\t(0 << 5)\n#define SII902X_TPI_AUDIO_LAYOUT_8_CHANNELS\t\t(1 << 5)\n#define SII902X_TPI_AUDIO_INTERFACE_DISABLE\t\t(0 << 6)\n#define SII902X_TPI_AUDIO_INTERFACE_SPDIF\t\t(1 << 6)\n#define SII902X_TPI_AUDIO_INTERFACE_I2S\t\t\t(2 << 6)\n\n#define SII902X_TPI_AUDIO_CONFIG_BYTE3_REG\t0x27\n#define SII902X_TPI_AUDIO_FREQ_STREAM\t\t\t(0 << 3)\n#define SII902X_TPI_AUDIO_FREQ_32KHZ\t\t\t(1 << 3)\n#define SII902X_TPI_AUDIO_FREQ_44KHZ\t\t\t(2 << 3)\n#define SII902X_TPI_AUDIO_FREQ_48KHZ\t\t\t(3 << 3)\n#define SII902X_TPI_AUDIO_FREQ_88KHZ\t\t\t(4 << 3)\n#define SII902X_TPI_AUDIO_FREQ_96KHZ\t\t\t(5 << 3)\n#define SII902X_TPI_AUDIO_FREQ_176KHZ\t\t\t(6 << 3)\n#define SII902X_TPI_AUDIO_FREQ_192KHZ\t\t\t(7 << 3)\n#define SII902X_TPI_AUDIO_SAMPLE_SIZE_STREAM\t\t(0 << 6)\n#define SII902X_TPI_AUDIO_SAMPLE_SIZE_16\t\t(1 << 6)\n#define SII902X_TPI_AUDIO_SAMPLE_SIZE_20\t\t(2 << 6)\n#define SII902X_TPI_AUDIO_SAMPLE_SIZE_24\t\t(3 << 6)\n\n#define SII902X_TPI_AUDIO_CONFIG_BYTE4_REG\t0x28\n\n#define SII902X_INT_ENABLE\t\t\t0x3c\n#define SII902X_INT_STATUS\t\t\t0x3d\n#define SII902X_HOTPLUG_EVENT\t\t\tBIT(0)\n#define SII902X_PLUGGED_STATUS\t\t\tBIT(2)\n\n#define SII902X_REG_TPI_RQB\t\t\t0xc7\n\n \n#define SII902X_IND_SET_PAGE\t\t\t0xbc\n#define SII902X_IND_OFFSET\t\t\t0xbd\n#define SII902X_IND_VALUE\t\t\t0xbe\n\n#define SII902X_TPI_MISC_INFOFRAME_BASE\t\t0xbf\n#define SII902X_TPI_MISC_INFOFRAME_END\t\t0xde\n#define SII902X_TPI_MISC_INFOFRAME_SIZE\t\\\n\t(SII902X_TPI_MISC_INFOFRAME_END - SII902X_TPI_MISC_INFOFRAME_BASE)\n\n#define SII902X_I2C_BUS_ACQUISITION_TIMEOUT_MS\t500\n\n#define SII902X_AUDIO_PORT_INDEX\t\t3\n\nstruct sii902x {\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector connector;\n\tstruct gpio_desc *reset_gpio;\n\tstruct i2c_mux_core *i2cmux;\n\tbool sink_is_hdmi;\n\t \n\tstruct mutex mutex;\n\tstruct sii902x_audio {\n\t\tstruct platform_device *pdev;\n\t\tstruct clk *mclk;\n\t\tu32 i2s_fifo_sequence[4];\n\t} audio;\n};\n\nstatic int sii902x_read_unlocked(struct i2c_client *i2c, u8 reg, u8 *val)\n{\n\tunion i2c_smbus_data data;\n\tint ret;\n\n\tret = __i2c_smbus_xfer(i2c->adapter, i2c->addr, i2c->flags,\n\t\t\t       I2C_SMBUS_READ, reg, I2C_SMBUS_BYTE_DATA, &data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = data.byte;\n\treturn 0;\n}\n\nstatic int sii902x_write_unlocked(struct i2c_client *i2c, u8 reg, u8 val)\n{\n\tunion i2c_smbus_data data;\n\n\tdata.byte = val;\n\n\treturn __i2c_smbus_xfer(i2c->adapter, i2c->addr, i2c->flags,\n\t\t\t\tI2C_SMBUS_WRITE, reg, I2C_SMBUS_BYTE_DATA,\n\t\t\t\t&data);\n}\n\nstatic int sii902x_update_bits_unlocked(struct i2c_client *i2c, u8 reg, u8 mask,\n\t\t\t\t\tu8 val)\n{\n\tint ret;\n\tu8 status;\n\n\tret = sii902x_read_unlocked(i2c, reg, &status);\n\tif (ret)\n\t\treturn ret;\n\tstatus &= ~mask;\n\tstatus |= val & mask;\n\treturn sii902x_write_unlocked(i2c, reg, status);\n}\n\nstatic inline struct sii902x *bridge_to_sii902x(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct sii902x, bridge);\n}\n\nstatic inline struct sii902x *connector_to_sii902x(struct drm_connector *con)\n{\n\treturn container_of(con, struct sii902x, connector);\n}\n\nstatic void sii902x_reset(struct sii902x *sii902x)\n{\n\tif (!sii902x->reset_gpio)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(sii902x->reset_gpio, 1);\n\n\t \n\tusleep_range(150, 200);\n\n\tgpiod_set_value_cansleep(sii902x->reset_gpio, 0);\n}\n\nstatic enum drm_connector_status sii902x_detect(struct sii902x *sii902x)\n{\n\tunsigned int status;\n\n\tmutex_lock(&sii902x->mutex);\n\n\tregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\n\n\tmutex_unlock(&sii902x->mutex);\n\n\treturn (status & SII902X_PLUGGED_STATUS) ?\n\t       connector_status_connected : connector_status_disconnected;\n}\n\nstatic enum drm_connector_status\nsii902x_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct sii902x *sii902x = connector_to_sii902x(connector);\n\n\treturn sii902x_detect(sii902x);\n}\n\nstatic const struct drm_connector_funcs sii902x_connector_funcs = {\n\t.detect = sii902x_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic struct edid *sii902x_get_edid(struct sii902x *sii902x,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\n\tmutex_lock(&sii902x->mutex);\n\n\tedid = drm_get_edid(connector, sii902x->i2cmux->adapter[0]);\n\tif (edid) {\n\t\tif (drm_detect_hdmi_monitor(edid))\n\t\t\tsii902x->sink_is_hdmi = true;\n\t\telse\n\t\t\tsii902x->sink_is_hdmi = false;\n\t}\n\n\tmutex_unlock(&sii902x->mutex);\n\n\treturn edid;\n}\n\nstatic int sii902x_get_modes(struct drm_connector *connector)\n{\n\tstruct sii902x *sii902x = connector_to_sii902x(connector);\n\tstruct edid *edid;\n\tint num = 0;\n\n\tedid = sii902x_get_edid(sii902x, connector);\n\tdrm_connector_update_edid_property(connector, edid);\n\tif (edid) {\n\t\tnum = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t}\n\n\treturn num;\n}\n\nstatic enum drm_mode_status sii902x_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t       struct drm_display_mode *mode)\n{\n\t \n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs sii902x_connector_helper_funcs = {\n\t.get_modes = sii902x_get_modes,\n\t.mode_valid = sii902x_mode_valid,\n};\n\nstatic void sii902x_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct sii902x *sii902x = bridge_to_sii902x(bridge);\n\n\tmutex_lock(&sii902x->mutex);\n\n\tregmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,\n\t\t\t   SII902X_SYS_CTRL_PWR_DWN,\n\t\t\t   SII902X_SYS_CTRL_PWR_DWN);\n\n\tmutex_unlock(&sii902x->mutex);\n}\n\nstatic void sii902x_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct sii902x *sii902x = bridge_to_sii902x(bridge);\n\n\tmutex_lock(&sii902x->mutex);\n\n\tregmap_update_bits(sii902x->regmap, SII902X_PWR_STATE_CTRL,\n\t\t\t   SII902X_AVI_POWER_STATE_MSK,\n\t\t\t   SII902X_AVI_POWER_STATE_D(0));\n\tregmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,\n\t\t\t   SII902X_SYS_CTRL_PWR_DWN, 0);\n\n\tmutex_unlock(&sii902x->mutex);\n}\n\nstatic void sii902x_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t    const struct drm_display_mode *mode,\n\t\t\t\t    const struct drm_display_mode *adj)\n{\n\tstruct sii902x *sii902x = bridge_to_sii902x(bridge);\n\tu8 output_mode = SII902X_SYS_CTRL_OUTPUT_DVI;\n\tstruct regmap *regmap = sii902x->regmap;\n\tu8 buf[HDMI_INFOFRAME_SIZE(AVI)];\n\tstruct hdmi_avi_infoframe frame;\n\tu16 pixel_clock_10kHz = adj->clock / 10;\n\tint ret;\n\n\tif (sii902x->sink_is_hdmi)\n\t\toutput_mode = SII902X_SYS_CTRL_OUTPUT_HDMI;\n\n\tbuf[0] = pixel_clock_10kHz & 0xff;\n\tbuf[1] = pixel_clock_10kHz >> 8;\n\tbuf[2] = drm_mode_vrefresh(adj);\n\tbuf[3] = 0x00;\n\tbuf[4] = adj->hdisplay;\n\tbuf[5] = adj->hdisplay >> 8;\n\tbuf[6] = adj->vdisplay;\n\tbuf[7] = adj->vdisplay >> 8;\n\tbuf[8] = SII902X_TPI_CLK_RATIO_1X | SII902X_TPI_AVI_PIXEL_REP_NONE |\n\t\t SII902X_TPI_AVI_PIXEL_REP_BUS_24BIT;\n\tbuf[9] = SII902X_TPI_AVI_INPUT_RANGE_AUTO |\n\t\t SII902X_TPI_AVI_INPUT_COLORSPACE_RGB;\n\n\tmutex_lock(&sii902x->mutex);\n\n\tret = regmap_update_bits(sii902x->regmap, SII902X_SYS_CTRL_DATA,\n\t\t\t\t SII902X_SYS_CTRL_OUTPUT_MODE, output_mode);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_bulk_write(regmap, SII902X_TPI_VIDEO_DATA, buf, 10);\n\tif (ret)\n\t\tgoto out;\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&frame,\n\t\t\t\t\t\t       &sii902x->connector, adj);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"couldn't fill AVI infoframe\\n\");\n\t\tgoto out;\n\t}\n\n\tret = hdmi_avi_infoframe_pack(&frame, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to pack AVI infoframe: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tregmap_bulk_write(regmap, SII902X_TPI_AVI_INFOFRAME,\n\t\t\t  buf + HDMI_INFOFRAME_HEADER_SIZE - 1,\n\t\t\t  HDMI_AVI_INFOFRAME_SIZE + 1);\n\nout:\n\tmutex_unlock(&sii902x->mutex);\n}\n\nstatic int sii902x_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct sii902x *sii902x = bridge_to_sii902x(bridge);\n\tu32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\tstruct drm_device *drm = bridge->dev;\n\tint ret;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn drm_bridge_attach(bridge->encoder, sii902x->next_bridge,\n\t\t\t\t\t bridge, flags);\n\n\tdrm_connector_helper_add(&sii902x->connector,\n\t\t\t\t &sii902x_connector_helper_funcs);\n\n\tif (!drm_core_check_feature(drm, DRIVER_ATOMIC)) {\n\t\tdev_err(&sii902x->i2c->dev,\n\t\t\t\"sii902x driver is only compatible with DRM devices supporting atomic updates\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tret = drm_connector_init(drm, &sii902x->connector,\n\t\t\t\t &sii902x_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_HDMIA);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sii902x->i2c->irq > 0)\n\t\tsii902x->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\telse\n\t\tsii902x->connector.polled = DRM_CONNECTOR_POLL_CONNECT;\n\n\tret = drm_display_info_set_bus_formats(&sii902x->connector.display_info,\n\t\t\t\t\t       &bus_format, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_connector_attach_encoder(&sii902x->connector, bridge->encoder);\n\n\treturn 0;\n}\n\nstatic enum drm_connector_status sii902x_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct sii902x *sii902x = bridge_to_sii902x(bridge);\n\n\treturn sii902x_detect(sii902x);\n}\n\nstatic struct edid *sii902x_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct sii902x *sii902x = bridge_to_sii902x(bridge);\n\n\treturn sii902x_get_edid(sii902x, connector);\n}\n\nstatic u32 *sii902x_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t\t     u32 output_fmt,\n\t\t\t\t\t\t     unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(1, sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic int sii902x_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\t \n\tbridge_state->input_bus_cfg.flags = bridge->timings->input_bus_flags;\n\n\treturn 0;\n}\n\nstatic const struct drm_bridge_funcs sii902x_bridge_funcs = {\n\t.attach = sii902x_bridge_attach,\n\t.mode_set = sii902x_bridge_mode_set,\n\t.disable = sii902x_bridge_disable,\n\t.enable = sii902x_bridge_enable,\n\t.detect = sii902x_bridge_detect,\n\t.get_edid = sii902x_bridge_get_edid,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts = sii902x_bridge_atomic_get_input_bus_fmts,\n\t.atomic_check = sii902x_bridge_atomic_check,\n};\n\nstatic int sii902x_mute(struct sii902x *sii902x, bool mute)\n{\n\tstruct device *dev = &sii902x->i2c->dev;\n\tunsigned int val = mute ? SII902X_TPI_AUDIO_MUTE_ENABLE :\n\t\tSII902X_TPI_AUDIO_MUTE_DISABLE;\n\n\tdev_dbg(dev, \"%s: %s\\n\", __func__, mute ? \"Muted\" : \"Unmuted\");\n\n\treturn regmap_update_bits(sii902x->regmap,\n\t\t\t\t  SII902X_TPI_AUDIO_CONFIG_BYTE2_REG,\n\t\t\t\t  SII902X_TPI_AUDIO_MUTE_ENABLE, val);\n}\n\nstatic const int sii902x_mclk_div_table[] = {\n\t128, 256, 384, 512, 768, 1024, 1152, 192 };\n\nstatic int sii902x_select_mclk_div(u8 *i2s_config_reg, unsigned int rate,\n\t\t\t\t   unsigned int mclk)\n{\n\tint div = mclk / rate;\n\tint distance = 100000;\n\tu8 i, nearest = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(sii902x_mclk_div_table); i++) {\n\t\tunsigned int d = abs(div - sii902x_mclk_div_table[i]);\n\n\t\tif (d >= distance)\n\t\t\tcontinue;\n\n\t\tnearest = i;\n\t\tdistance = d;\n\t\tif (d == 0)\n\t\t\tbreak;\n\t}\n\n\t*i2s_config_reg |= nearest << 4;\n\n\treturn sii902x_mclk_div_table[nearest];\n}\n\nstatic const struct sii902x_sample_freq {\n\tu32 freq;\n\tu8 val;\n} sii902x_sample_freq[] = {\n\t{ .freq = 32000,\t.val = SII902X_TPI_AUDIO_FREQ_32KHZ },\n\t{ .freq = 44000,\t.val = SII902X_TPI_AUDIO_FREQ_44KHZ },\n\t{ .freq = 48000,\t.val = SII902X_TPI_AUDIO_FREQ_48KHZ },\n\t{ .freq = 88000,\t.val = SII902X_TPI_AUDIO_FREQ_88KHZ },\n\t{ .freq = 96000,\t.val = SII902X_TPI_AUDIO_FREQ_96KHZ },\n\t{ .freq = 176000,\t.val = SII902X_TPI_AUDIO_FREQ_176KHZ },\n\t{ .freq = 192000,\t.val = SII902X_TPI_AUDIO_FREQ_192KHZ },\n};\n\nstatic int sii902x_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t   struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t   struct hdmi_codec_params *params)\n{\n\tstruct sii902x *sii902x = dev_get_drvdata(dev);\n\tu8 i2s_config_reg = SII902X_TPI_I2S_SD_DIRECTION_MSB_FIRST;\n\tu8 config_byte2_reg = (SII902X_TPI_AUDIO_INTERFACE_I2S |\n\t\t\t       SII902X_TPI_AUDIO_MUTE_ENABLE |\n\t\t\t       SII902X_TPI_AUDIO_CODING_PCM);\n\tu8 config_byte3_reg = 0;\n\tu8 infoframe_buf[HDMI_INFOFRAME_SIZE(AUDIO)];\n\tunsigned long mclk_rate;\n\tint i, ret;\n\n\tif (daifmt->bit_clk_provider || daifmt->frame_clk_provider) {\n\t\tdev_dbg(dev, \"%s: I2S clock provider mode not supported\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (daifmt->fmt) {\n\tcase HDMI_I2S:\n\t\ti2s_config_reg |= SII902X_TPI_I2S_FIRST_BIT_SHIFT_YES |\n\t\t\tSII902X_TPI_I2S_SD_JUSTIFY_LEFT;\n\t\tbreak;\n\tcase HDMI_RIGHT_J:\n\t\ti2s_config_reg |= SII902X_TPI_I2S_SD_JUSTIFY_RIGHT;\n\t\tbreak;\n\tcase HDMI_LEFT_J:\n\t\ti2s_config_reg |= SII902X_TPI_I2S_SD_JUSTIFY_LEFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"%s: Unsupported i2s format %u\\n\", __func__,\n\t\t\tdaifmt->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (daifmt->bit_clk_inv)\n\t\ti2s_config_reg |= SII902X_TPI_I2S_SCK_EDGE_FALLING;\n\telse\n\t\ti2s_config_reg |= SII902X_TPI_I2S_SCK_EDGE_RISING;\n\n\tif (daifmt->frame_clk_inv)\n\t\ti2s_config_reg |= SII902X_TPI_I2S_WS_POLARITY_LOW;\n\telse\n\t\ti2s_config_reg |= SII902X_TPI_I2S_WS_POLARITY_HIGH;\n\n\tif (params->channels > 2)\n\t\tconfig_byte2_reg |= SII902X_TPI_AUDIO_LAYOUT_8_CHANNELS;\n\telse\n\t\tconfig_byte2_reg |= SII902X_TPI_AUDIO_LAYOUT_2_CHANNELS;\n\n\tswitch (params->sample_width) {\n\tcase 16:\n\t\tconfig_byte3_reg |= SII902X_TPI_AUDIO_SAMPLE_SIZE_16;\n\t\tbreak;\n\tcase 20:\n\t\tconfig_byte3_reg |= SII902X_TPI_AUDIO_SAMPLE_SIZE_20;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tconfig_byte3_reg |= SII902X_TPI_AUDIO_SAMPLE_SIZE_24;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"%s: Unsupported sample width %u\\n\", __func__,\n\t\t\tparams->sample_width);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sii902x_sample_freq); i++) {\n\t\tif (params->sample_rate == sii902x_sample_freq[i].freq) {\n\t\t\tconfig_byte3_reg |= sii902x_sample_freq[i].val;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(sii902x->audio.mclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Enabling mclk failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (sii902x->audio.mclk) {\n\t\tmclk_rate = clk_get_rate(sii902x->audio.mclk);\n\t\tret = sii902x_select_mclk_div(&i2s_config_reg,\n\t\t\t\t\t      params->sample_rate, mclk_rate);\n\t\tif (mclk_rate != ret * params->sample_rate)\n\t\t\tdev_dbg(dev, \"Inaccurate reference clock (%ld/%d != %u)\\n\",\n\t\t\t\tmclk_rate, ret, params->sample_rate);\n\t}\n\n\tmutex_lock(&sii902x->mutex);\n\n\tret = regmap_write(sii902x->regmap,\n\t\t\t   SII902X_TPI_AUDIO_CONFIG_BYTE2_REG,\n\t\t\t   config_byte2_reg);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = regmap_write(sii902x->regmap, SII902X_TPI_I2S_INPUT_CONFIG_REG,\n\t\t\t   i2s_config_reg);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(sii902x->audio.i2s_fifo_sequence) &&\n\t\t    sii902x->audio.i2s_fifo_sequence[i]; i++)\n\t\tregmap_write(sii902x->regmap,\n\t\t\t     SII902X_TPI_I2S_ENABLE_MAPPING_REG,\n\t\t\t     sii902x->audio.i2s_fifo_sequence[i]);\n\n\tret = regmap_write(sii902x->regmap, SII902X_TPI_AUDIO_CONFIG_BYTE3_REG,\n\t\t\t   config_byte3_reg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_bulk_write(sii902x->regmap, SII902X_TPI_I2S_STRM_HDR_BASE,\n\t\t\t\tparams->iec.status,\n\t\t\t\tmin((size_t) SII902X_TPI_I2S_STRM_HDR_SIZE,\n\t\t\t\t    sizeof(params->iec.status)));\n\tif (ret)\n\t\tgoto out;\n\n\tret = hdmi_audio_infoframe_pack(&params->cea, infoframe_buf,\n\t\t\t\t\tsizeof(infoframe_buf));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: Failed to pack audio infoframe: %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto out;\n\t}\n\n\tret = regmap_bulk_write(sii902x->regmap,\n\t\t\t\tSII902X_TPI_MISC_INFOFRAME_BASE,\n\t\t\t\tinfoframe_buf,\n\t\t\t\tmin(ret, SII902X_TPI_MISC_INFOFRAME_SIZE));\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(sii902x->regmap, SII902X_IND_SET_PAGE, 0x02);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(sii902x->regmap, SII902X_IND_OFFSET, 0x24);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write(sii902x->regmap, SII902X_IND_VALUE, 0x02);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_dbg(dev, \"%s: hdmi audio enabled\\n\", __func__);\nout:\n\tmutex_unlock(&sii902x->mutex);\n\n\tif (ret) {\n\t\tclk_disable_unprepare(sii902x->audio.mclk);\n\t\tdev_err(dev, \"%s: hdmi audio enable failed: %d\\n\", __func__,\n\t\t\tret);\n\t}\n\n\treturn ret;\n}\n\nstatic void sii902x_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct sii902x *sii902x = dev_get_drvdata(dev);\n\n\tmutex_lock(&sii902x->mutex);\n\n\tregmap_write(sii902x->regmap, SII902X_TPI_AUDIO_CONFIG_BYTE2_REG,\n\t\t     SII902X_TPI_AUDIO_INTERFACE_DISABLE);\n\n\tmutex_unlock(&sii902x->mutex);\n\n\tclk_disable_unprepare(sii902x->audio.mclk);\n}\n\nstatic int sii902x_audio_mute(struct device *dev, void *data,\n\t\t\t      bool enable, int direction)\n{\n\tstruct sii902x *sii902x = dev_get_drvdata(dev);\n\n\tmutex_lock(&sii902x->mutex);\n\n\tsii902x_mute(sii902x, enable);\n\n\tmutex_unlock(&sii902x->mutex);\n\n\treturn 0;\n}\n\nstatic int sii902x_audio_get_eld(struct device *dev, void *data,\n\t\t\t\t uint8_t *buf, size_t len)\n{\n\tstruct sii902x *sii902x = dev_get_drvdata(dev);\n\n\tmutex_lock(&sii902x->mutex);\n\n\tmemcpy(buf, sii902x->connector.eld,\n\t       min(sizeof(sii902x->connector.eld), len));\n\n\tmutex_unlock(&sii902x->mutex);\n\n\treturn 0;\n}\n\nstatic int sii902x_audio_get_dai_id(struct snd_soc_component *component,\n\t\t\t\t    struct device_node *endpoint)\n{\n\tstruct of_endpoint of_ep;\n\tint ret;\n\n\tret = of_graph_parse_endpoint(endpoint, &of_ep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (of_ep.port == SII902X_AUDIO_PORT_INDEX)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic const struct hdmi_codec_ops sii902x_audio_codec_ops = {\n\t.hw_params = sii902x_audio_hw_params,\n\t.audio_shutdown = sii902x_audio_shutdown,\n\t.mute_stream = sii902x_audio_mute,\n\t.get_eld = sii902x_audio_get_eld,\n\t.get_dai_id = sii902x_audio_get_dai_id,\n\t.no_capture_mute = 1,\n};\n\nstatic int sii902x_audio_codec_init(struct sii902x *sii902x,\n\t\t\t\t    struct device *dev)\n{\n\tstatic const u8 audio_fifo_id[] = {\n\t\tSII902X_TPI_I2S_CONFIG_FIFO0,\n\t\tSII902X_TPI_I2S_CONFIG_FIFO1,\n\t\tSII902X_TPI_I2S_CONFIG_FIFO2,\n\t\tSII902X_TPI_I2S_CONFIG_FIFO3,\n\t};\n\tstatic const u8 i2s_lane_id[] = {\n\t\tSII902X_TPI_I2S_SELECT_SD0,\n\t\tSII902X_TPI_I2S_SELECT_SD1,\n\t\tSII902X_TPI_I2S_SELECT_SD2,\n\t\tSII902X_TPI_I2S_SELECT_SD3,\n\t};\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &sii902x_audio_codec_ops,\n\t\t.i2s = 1,  \n\t\t.spdif = 0,\n\t\t.max_i2s_channels = 0,\n\t};\n\tu8 lanes[4];\n\tint num_lanes, i;\n\n\tif (!of_property_read_bool(dev->of_node, \"#sound-dai-cells\")) {\n\t\tdev_dbg(dev, \"%s: No \\\"#sound-dai-cells\\\", no audio\\n\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\tnum_lanes = of_property_read_variable_u8_array(dev->of_node,\n\t\t\t\t\t\t       \"sil,i2s-data-lanes\",\n\t\t\t\t\t\t       lanes, 1,\n\t\t\t\t\t\t       ARRAY_SIZE(lanes));\n\n\tif (num_lanes == -EINVAL) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s: No \\\"sil,i2s-data-lanes\\\", use default <0>\\n\",\n\t\t\t__func__);\n\t\tnum_lanes = 1;\n\t\tlanes[0] = 0;\n\t} else if (num_lanes < 0) {\n\t\tdev_err(dev,\n\t\t\t\"%s: Error gettin \\\"sil,i2s-data-lanes\\\": %d\\n\",\n\t\t\t__func__, num_lanes);\n\t\treturn num_lanes;\n\t}\n\tcodec_data.max_i2s_channels = 2 * num_lanes;\n\n\tfor (i = 0; i < num_lanes; i++)\n\t\tsii902x->audio.i2s_fifo_sequence[i] |= audio_fifo_id[i] |\n\t\t\ti2s_lane_id[lanes[i]] |\tSII902X_TPI_I2S_FIFO_ENABLE;\n\n\tsii902x->audio.mclk = devm_clk_get_optional(dev, \"mclk\");\n\tif (IS_ERR(sii902x->audio.mclk)) {\n\t\tdev_err(dev, \"%s: No clock (audio mclk) found: %ld\\n\",\n\t\t\t__func__, PTR_ERR(sii902x->audio.mclk));\n\t\treturn PTR_ERR(sii902x->audio.mclk);\n\t}\n\n\tsii902x->audio.pdev = platform_device_register_data(\n\t\tdev, HDMI_CODEC_DRV_NAME, PLATFORM_DEVID_AUTO,\n\t\t&codec_data, sizeof(codec_data));\n\n\treturn PTR_ERR_OR_ZERO(sii902x->audio.pdev);\n}\n\nstatic const struct regmap_range sii902x_volatile_ranges[] = {\n\t{ .range_min = 0, .range_max = 0xff },\n};\n\nstatic const struct regmap_access_table sii902x_volatile_table = {\n\t.yes_ranges = sii902x_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sii902x_volatile_ranges),\n};\n\nstatic const struct regmap_config sii902x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.disable_locking = true,  \n\t.max_register = SII902X_TPI_MISC_INFOFRAME_END,\n\t.volatile_table = &sii902x_volatile_table,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic irqreturn_t sii902x_interrupt(int irq, void *data)\n{\n\tstruct sii902x *sii902x = data;\n\tunsigned int status = 0;\n\n\tmutex_lock(&sii902x->mutex);\n\n\tregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\n\tregmap_write(sii902x->regmap, SII902X_INT_STATUS, status);\n\n\tmutex_unlock(&sii902x->mutex);\n\n\tif ((status & SII902X_HOTPLUG_EVENT) && sii902x->bridge.dev) {\n\t\tdrm_helper_hpd_irq_event(sii902x->bridge.dev);\n\t\tdrm_bridge_hpd_notify(&sii902x->bridge, (status & SII902X_PLUGGED_STATUS)\n\t\t\t\t\t\t\t\t? connector_status_connected\n\t\t\t\t\t\t\t\t: connector_status_disconnected);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int sii902x_i2c_bypass_select(struct i2c_mux_core *mux, u32 chan_id)\n{\n\tstruct sii902x *sii902x = i2c_mux_priv(mux);\n\tstruct device *dev = &sii902x->i2c->dev;\n\tunsigned long timeout;\n\tu8 status;\n\tint ret;\n\n\tret = sii902x_update_bits_unlocked(sii902x->i2c, SII902X_SYS_CTRL_DATA,\n\t\t\t\t\t   SII902X_SYS_CTRL_DDC_BUS_REQ,\n\t\t\t\t\t   SII902X_SYS_CTRL_DDC_BUS_REQ);\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = jiffies +\n\t\t  msecs_to_jiffies(SII902X_I2C_BUS_ACQUISITION_TIMEOUT_MS);\n\tdo {\n\t\tret = sii902x_read_unlocked(sii902x->i2c, SII902X_SYS_CTRL_DATA,\n\t\t\t\t\t    &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (!(status & SII902X_SYS_CTRL_DDC_BUS_GRTD) &&\n\t\t time_before(jiffies, timeout));\n\n\tif (!(status & SII902X_SYS_CTRL_DDC_BUS_GRTD)) {\n\t\tdev_err(dev, \"Failed to acquire the i2c bus\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn sii902x_write_unlocked(sii902x->i2c, SII902X_SYS_CTRL_DATA,\n\t\t\t\t      status);\n}\n\n \nstatic int sii902x_i2c_bypass_deselect(struct i2c_mux_core *mux, u32 chan_id)\n{\n\tstruct sii902x *sii902x = i2c_mux_priv(mux);\n\tstruct device *dev = &sii902x->i2c->dev;\n\tunsigned long timeout;\n\tunsigned int retries;\n\tu8 status;\n\tint ret;\n\n\t \n\tudelay(30);\n\n\t \n\tretries = 5;\n\tdo {\n\t\tret = sii902x_read_unlocked(sii902x->i2c, SII902X_SYS_CTRL_DATA,\n\t\t\t\t\t    &status);\n\t\tretries--;\n\t} while (ret && retries);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read status (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = sii902x_update_bits_unlocked(sii902x->i2c, SII902X_SYS_CTRL_DATA,\n\t\t\t\t\t   SII902X_SYS_CTRL_DDC_BUS_REQ |\n\t\t\t\t\t   SII902X_SYS_CTRL_DDC_BUS_GRTD, 0);\n\tif (ret)\n\t\treturn ret;\n\n\ttimeout = jiffies +\n\t\t  msecs_to_jiffies(SII902X_I2C_BUS_ACQUISITION_TIMEOUT_MS);\n\tdo {\n\t\tret = sii902x_read_unlocked(sii902x->i2c, SII902X_SYS_CTRL_DATA,\n\t\t\t\t\t    &status);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (status & (SII902X_SYS_CTRL_DDC_BUS_REQ |\n\t\t\t   SII902X_SYS_CTRL_DDC_BUS_GRTD) &&\n\t\t time_before(jiffies, timeout));\n\n\tif (status & (SII902X_SYS_CTRL_DDC_BUS_REQ |\n\t\t      SII902X_SYS_CTRL_DDC_BUS_GRTD)) {\n\t\tdev_err(dev, \"failed to release the i2c bus\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_bridge_timings default_sii902x_timings = {\n\t.input_bus_flags = DRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE\n\t\t | DRM_BUS_FLAG_SYNC_SAMPLE_NEGEDGE\n\t\t | DRM_BUS_FLAG_DE_HIGH,\n};\n\nstatic int sii902x_init(struct sii902x *sii902x)\n{\n\tstruct device *dev = &sii902x->i2c->dev;\n\tunsigned int status = 0;\n\tu8 chipid[4];\n\tint ret;\n\n\tsii902x_reset(sii902x);\n\n\tret = regmap_write(sii902x->regmap, SII902X_REG_TPI_RQB, 0x0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(sii902x->regmap, SII902X_REG_CHIPID(0),\n\t\t\t       &chipid, 4);\n\tif (ret) {\n\t\tdev_err(dev, \"regmap_read failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (chipid[0] != 0xb0) {\n\t\tdev_err(dev, \"Invalid chipid: %02x (expecting 0xb0)\\n\",\n\t\t\tchipid[0]);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_read(sii902x->regmap, SII902X_INT_STATUS, &status);\n\tregmap_write(sii902x->regmap, SII902X_INT_STATUS, status);\n\n\tif (sii902x->i2c->irq > 0) {\n\t\tregmap_write(sii902x->regmap, SII902X_INT_ENABLE,\n\t\t\t     SII902X_HOTPLUG_EVENT);\n\n\t\tret = devm_request_threaded_irq(dev, sii902x->i2c->irq, NULL,\n\t\t\t\t\t\tsii902x_interrupt,\n\t\t\t\t\t\tIRQF_ONESHOT, dev_name(dev),\n\t\t\t\t\t\tsii902x);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsii902x->bridge.funcs = &sii902x_bridge_funcs;\n\tsii902x->bridge.of_node = dev->of_node;\n\tsii902x->bridge.timings = &default_sii902x_timings;\n\tsii902x->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID;\n\n\tif (sii902x->i2c->irq > 0)\n\t\tsii902x->bridge.ops |= DRM_BRIDGE_OP_HPD;\n\n\tdrm_bridge_add(&sii902x->bridge);\n\n\tsii902x_audio_codec_init(sii902x, dev);\n\n\ti2c_set_clientdata(sii902x->i2c, sii902x);\n\n\tsii902x->i2cmux = i2c_mux_alloc(sii902x->i2c->adapter, dev,\n\t\t\t\t\t1, 0, I2C_MUX_GATE,\n\t\t\t\t\tsii902x_i2c_bypass_select,\n\t\t\t\t\tsii902x_i2c_bypass_deselect);\n\tif (!sii902x->i2cmux)\n\t\treturn -ENOMEM;\n\n\tsii902x->i2cmux->priv = sii902x;\n\treturn i2c_mux_add_adapter(sii902x->i2cmux, 0, 0, 0);\n}\n\nstatic int sii902x_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *endpoint;\n\tstruct sii902x *sii902x;\n\tstatic const char * const supplies[] = {\"iovcc\", \"cvcc12\"};\n\tint ret;\n\n\tret = i2c_check_functionality(client->adapter,\n\t\t\t\t      I2C_FUNC_SMBUS_BYTE_DATA);\n\tif (!ret) {\n\t\tdev_err(dev, \"I2C adapter not suitable\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsii902x = devm_kzalloc(dev, sizeof(*sii902x), GFP_KERNEL);\n\tif (!sii902x)\n\t\treturn -ENOMEM;\n\n\tsii902x->i2c = client;\n\tsii902x->regmap = devm_regmap_init_i2c(client, &sii902x_regmap_config);\n\tif (IS_ERR(sii902x->regmap))\n\t\treturn PTR_ERR(sii902x->regmap);\n\n\tsii902x->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(sii902x->reset_gpio)) {\n\t\tdev_err(dev, \"Failed to retrieve/request reset gpio: %ld\\n\",\n\t\t\tPTR_ERR(sii902x->reset_gpio));\n\t\treturn PTR_ERR(sii902x->reset_gpio);\n\t}\n\n\tendpoint = of_graph_get_endpoint_by_regs(dev->of_node, 1, -1);\n\tif (endpoint) {\n\t\tstruct device_node *remote = of_graph_get_remote_port_parent(endpoint);\n\n\t\tof_node_put(endpoint);\n\t\tif (!remote) {\n\t\t\tdev_err(dev, \"Endpoint in port@1 unconnected\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (!of_device_is_available(remote)) {\n\t\t\tdev_err(dev, \"port@1 remote device is disabled\\n\");\n\t\t\tof_node_put(remote);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsii902x->next_bridge = of_drm_find_bridge(remote);\n\t\tof_node_put(remote);\n\t\tif (!sii902x->next_bridge)\n\t\t\treturn dev_err_probe(dev, -EPROBE_DEFER,\n\t\t\t\t\t     \"Failed to find remote bridge\\n\");\n\t}\n\n\tmutex_init(&sii902x->mutex);\n\n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(supplies), supplies);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable supplies\");\n\n\treturn sii902x_init(sii902x);\n}\n\nstatic void sii902x_remove(struct i2c_client *client)\n\n{\n\tstruct sii902x *sii902x = i2c_get_clientdata(client);\n\n\ti2c_mux_del_adapters(sii902x->i2cmux);\n\tdrm_bridge_remove(&sii902x->bridge);\n}\n\nstatic const struct of_device_id sii902x_dt_ids[] = {\n\t{ .compatible = \"sil,sii9022\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sii902x_dt_ids);\n\nstatic const struct i2c_device_id sii902x_i2c_ids[] = {\n\t{ \"sii9022\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sii902x_i2c_ids);\n\nstatic struct i2c_driver sii902x_driver = {\n\t.probe = sii902x_probe,\n\t.remove = sii902x_remove,\n\t.driver = {\n\t\t.name = \"sii902x\",\n\t\t.of_match_table = sii902x_dt_ids,\n\t},\n\t.id_table = sii902x_i2c_ids,\n};\nmodule_i2c_driver(sii902x_driver);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@free-electrons.com>\");\nMODULE_DESCRIPTION(\"SII902x RGB -> HDMI bridges\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}