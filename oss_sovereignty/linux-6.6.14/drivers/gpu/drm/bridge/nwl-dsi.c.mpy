{
  "module_name": "nwl-dsi.c",
  "hash_id": "ea82c2277d5e5755b155a56196d9340dbb9a7bd36af913490f8473920c19ac18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/nwl-dsi.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/math64.h>\n#include <linux/mfd/syscon.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/mux/consumer.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/sys_soc.h>\n#include <linux/time64.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#include <video/mipi_display.h>\n\n#include \"nwl-dsi.h\"\n\n#define DRV_NAME \"nwl-dsi\"\n\n \n \n#define E11418_HS_MODE_QUIRK\tBIT(0)\n\n#define NWL_DSI_MIPI_FIFO_TIMEOUT msecs_to_jiffies(500)\n\nenum transfer_direction {\n\tDSI_PACKET_SEND,\n\tDSI_PACKET_RECEIVE,\n};\n\n#define NWL_DSI_ENDPOINT_LCDIF 0\n#define NWL_DSI_ENDPOINT_DCSS 1\n\nstruct nwl_dsi_transfer {\n\tconst struct mipi_dsi_msg *msg;\n\tstruct mipi_dsi_packet packet;\n\tstruct completion completed;\n\n\tint status;  \n\tenum transfer_direction direction;\n\tbool need_bta;\n\tu8 cmd;\n\tu16 rx_word_count;\n\tsize_t tx_len;  \n\tsize_t rx_len;  \n};\n\nstruct nwl_dsi {\n\tstruct drm_bridge bridge;\n\tstruct mipi_dsi_host dsi_host;\n\tstruct device *dev;\n\tstruct phy *phy;\n\tunion phy_configure_opts phy_cfg;\n\tunsigned int quirks;\n\n\tstruct regmap *regmap;\n\tint irq;\n\t \n\tstruct reset_control *rst_byte;\n\tstruct reset_control *rst_esc;\n\tstruct reset_control *rst_dpi;\n\tstruct reset_control *rst_pclk;\n\tstruct mux_control *mux;\n\n\t \n\tstruct clk *phy_ref_clk;\n\tstruct clk *rx_esc_clk;\n\tstruct clk *tx_esc_clk;\n\tstruct clk *core_clk;\n\t \n\tstruct clk *lcdif_clk;\n\n\t \n\tu32 lanes;\n\tenum mipi_dsi_pixel_format format;\n\tstruct drm_display_mode mode;\n\tunsigned long dsi_mode_flags;\n\tint error;\n\n\tstruct nwl_dsi_transfer *xfer;\n};\n\nstatic const struct regmap_config nwl_dsi_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = NWL_DSI_IRQ_MASK2,\n\t.name = DRV_NAME,\n};\n\nstatic inline struct nwl_dsi *bridge_to_dsi(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct nwl_dsi, bridge);\n}\n\nstatic int nwl_dsi_clear_error(struct nwl_dsi *dsi)\n{\n\tint ret = dsi->error;\n\n\tdsi->error = 0;\n\treturn ret;\n}\n\nstatic void nwl_dsi_write(struct nwl_dsi *dsi, unsigned int reg, u32 val)\n{\n\tint ret;\n\n\tif (dsi->error)\n\t\treturn;\n\n\tret = regmap_write(dsi->regmap, reg, val);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev,\n\t\t\t      \"Failed to write NWL DSI reg 0x%x: %d\\n\", reg,\n\t\t\t      ret);\n\t\tdsi->error = ret;\n\t}\n}\n\nstatic u32 nwl_dsi_read(struct nwl_dsi *dsi, u32 reg)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (dsi->error)\n\t\treturn 0;\n\n\tret = regmap_read(dsi->regmap, reg, &val);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to read NWL DSI reg 0x%x: %d\\n\",\n\t\t\t      reg, ret);\n\t\tdsi->error = ret;\n\t}\n\treturn val;\n}\n\nstatic int nwl_dsi_get_dpi_pixel_format(enum mipi_dsi_pixel_format format)\n{\n\tswitch (format) {\n\tcase MIPI_DSI_FMT_RGB565:\n\t\treturn NWL_DSI_PIXEL_FORMAT_16;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\treturn NWL_DSI_PIXEL_FORMAT_18L;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\treturn NWL_DSI_PIXEL_FORMAT_18;\n\tcase MIPI_DSI_FMT_RGB888:\n\t\treturn NWL_DSI_PIXEL_FORMAT_24;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic u32 ps2bc(struct nwl_dsi *dsi, unsigned long long ps)\n{\n\tu32 bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\n\treturn DIV64_U64_ROUND_UP(ps * dsi->mode.clock * bpp,\n\t\t\t\t  dsi->lanes * 8ULL * NSEC_PER_SEC);\n}\n\n \nstatic u32 ui2bc(unsigned int ui)\n{\n\treturn DIV_ROUND_UP(ui, BITS_PER_BYTE);\n}\n\n \nstatic u32 us2lp(u32 lp_clk_rate, unsigned long us)\n{\n\treturn DIV_ROUND_UP(us * lp_clk_rate, USEC_PER_SEC);\n}\n\nstatic int nwl_dsi_config_host(struct nwl_dsi *dsi)\n{\n\tu32 cycles;\n\tstruct phy_configure_opts_mipi_dphy *cfg = &dsi->phy_cfg.mipi_dphy;\n\n\tif (dsi->lanes < 1 || dsi->lanes > 4)\n\t\treturn -EINVAL;\n\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"DSI Lanes %d\\n\", dsi->lanes);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_NUM_LANES, dsi->lanes - 1);\n\n\tif (dsi->dsi_mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) {\n\t\tnwl_dsi_write(dsi, NWL_DSI_CFG_NONCONTINUOUS_CLK, 0x01);\n\t\tnwl_dsi_write(dsi, NWL_DSI_CFG_AUTOINSERT_EOTP, 0x01);\n\t} else {\n\t\tnwl_dsi_write(dsi, NWL_DSI_CFG_NONCONTINUOUS_CLK, 0x00);\n\t\tnwl_dsi_write(dsi, NWL_DSI_CFG_AUTOINSERT_EOTP, 0x00);\n\t}\n\n\t \n\tcycles = ui2bc(cfg->clk_pre);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"cfg_t_pre: 0x%x\\n\", cycles);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_T_PRE, cycles);\n\tcycles = ps2bc(dsi, cfg->lpx + cfg->clk_prepare + cfg->clk_zero);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"cfg_tx_gap (pre): 0x%x\\n\", cycles);\n\tcycles += ui2bc(cfg->clk_pre);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"cfg_t_post: 0x%x\\n\", cycles);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_T_POST, cycles);\n\tcycles = ps2bc(dsi, cfg->hs_exit);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"cfg_tx_gap: 0x%x\\n\", cycles);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_TX_GAP, cycles);\n\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_EXTRA_CMDS_AFTER_EOTP, 0x01);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_HTX_TO_COUNT, 0x00);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_LRX_H_TO_COUNT, 0x00);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_BTA_H_TO_COUNT, 0x00);\n\t \n\tcycles = us2lp(cfg->lp_clk_rate, cfg->wakeup);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"cfg_twakeup: 0x%x\\n\", cycles);\n\tnwl_dsi_write(dsi, NWL_DSI_CFG_TWAKEUP, cycles);\n\n\treturn nwl_dsi_clear_error(dsi);\n}\n\nstatic int nwl_dsi_config_dpi(struct nwl_dsi *dsi)\n{\n\tu32 mode;\n\tint color_format;\n\tbool burst_mode;\n\tint hfront_porch, hback_porch, vfront_porch, vback_porch;\n\tint hsync_len, vsync_len;\n\n\thfront_porch = dsi->mode.hsync_start - dsi->mode.hdisplay;\n\thsync_len = dsi->mode.hsync_end - dsi->mode.hsync_start;\n\thback_porch = dsi->mode.htotal - dsi->mode.hsync_end;\n\n\tvfront_porch = dsi->mode.vsync_start - dsi->mode.vdisplay;\n\tvsync_len = dsi->mode.vsync_end - dsi->mode.vsync_start;\n\tvback_porch = dsi->mode.vtotal - dsi->mode.vsync_end;\n\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"hfront_porch = %d\\n\", hfront_porch);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"hback_porch = %d\\n\", hback_porch);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"hsync_len = %d\\n\", hsync_len);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"hdisplay = %d\\n\", dsi->mode.hdisplay);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"vfront_porch = %d\\n\", vfront_porch);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"vback_porch = %d\\n\", vback_porch);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"vsync_len = %d\\n\", vsync_len);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"vactive = %d\\n\", dsi->mode.vdisplay);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"clock = %d kHz\\n\", dsi->mode.clock);\n\n\tcolor_format = nwl_dsi_get_dpi_pixel_format(dsi->format);\n\tif (color_format < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Invalid color format 0x%x\\n\",\n\t\t\t      dsi->format);\n\t\treturn color_format;\n\t}\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"pixel fmt = %d\\n\", dsi->format);\n\n\tnwl_dsi_write(dsi, NWL_DSI_INTERFACE_COLOR_CODING, NWL_DSI_DPI_24_BIT);\n\tnwl_dsi_write(dsi, NWL_DSI_PIXEL_FORMAT, color_format);\n\t \n\tnwl_dsi_write(dsi, NWL_DSI_VSYNC_POLARITY,\n\t\t      NWL_DSI_VSYNC_POLARITY_ACTIVE_LOW);\n\tnwl_dsi_write(dsi, NWL_DSI_HSYNC_POLARITY,\n\t\t      NWL_DSI_HSYNC_POLARITY_ACTIVE_LOW);\n\n\tburst_mode = (dsi->dsi_mode_flags & MIPI_DSI_MODE_VIDEO_BURST) &&\n\t\t     !(dsi->dsi_mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE);\n\n\tif (burst_mode) {\n\t\tnwl_dsi_write(dsi, NWL_DSI_VIDEO_MODE, NWL_DSI_VM_BURST_MODE);\n\t\tnwl_dsi_write(dsi, NWL_DSI_PIXEL_FIFO_SEND_LEVEL, 256);\n\t} else {\n\t\tmode = ((dsi->dsi_mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE) ?\n\t\t\t\tNWL_DSI_VM_BURST_MODE_WITH_SYNC_PULSES :\n\t\t\t\tNWL_DSI_VM_NON_BURST_MODE_WITH_SYNC_EVENTS);\n\t\tnwl_dsi_write(dsi, NWL_DSI_VIDEO_MODE, mode);\n\t\tnwl_dsi_write(dsi, NWL_DSI_PIXEL_FIFO_SEND_LEVEL,\n\t\t\t      dsi->mode.hdisplay);\n\t}\n\n\tnwl_dsi_write(dsi, NWL_DSI_HFP, hfront_porch);\n\tnwl_dsi_write(dsi, NWL_DSI_HBP, hback_porch);\n\tnwl_dsi_write(dsi, NWL_DSI_HSA, hsync_len);\n\n\tnwl_dsi_write(dsi, NWL_DSI_ENABLE_MULT_PKTS, 0x0);\n\tnwl_dsi_write(dsi, NWL_DSI_BLLP_MODE, 0x1);\n\tnwl_dsi_write(dsi, NWL_DSI_USE_NULL_PKT_BLLP, 0x0);\n\tnwl_dsi_write(dsi, NWL_DSI_VC, 0x0);\n\n\tnwl_dsi_write(dsi, NWL_DSI_PIXEL_PAYLOAD_SIZE, dsi->mode.hdisplay);\n\tnwl_dsi_write(dsi, NWL_DSI_VACTIVE, dsi->mode.vdisplay - 1);\n\tnwl_dsi_write(dsi, NWL_DSI_VBP, vback_porch);\n\tnwl_dsi_write(dsi, NWL_DSI_VFP, vfront_porch);\n\n\treturn nwl_dsi_clear_error(dsi);\n}\n\nstatic int nwl_dsi_init_interrupts(struct nwl_dsi *dsi)\n{\n\tu32 irq_enable = ~(u32)(NWL_DSI_TX_PKT_DONE_MASK |\n\t\t\t\tNWL_DSI_RX_PKT_HDR_RCVD_MASK |\n\t\t\t\tNWL_DSI_TX_FIFO_OVFLW_MASK |\n\t\t\t\tNWL_DSI_HS_TX_TIMEOUT_MASK);\n\n\tnwl_dsi_write(dsi, NWL_DSI_IRQ_MASK, irq_enable);\n\tnwl_dsi_write(dsi, NWL_DSI_IRQ_MASK2, 0x7);\n\n\treturn nwl_dsi_clear_error(dsi);\n}\n\nstatic int nwl_dsi_host_attach(struct mipi_dsi_host *dsi_host,\n\t\t\t       struct mipi_dsi_device *device)\n{\n\tstruct nwl_dsi *dsi = container_of(dsi_host, struct nwl_dsi, dsi_host);\n\tstruct device *dev = dsi->dev;\n\n\tDRM_DEV_INFO(dev, \"lanes=%u, format=0x%x flags=0x%lx\\n\", device->lanes,\n\t\t     device->format, device->mode_flags);\n\n\tif (device->lanes < 1 || device->lanes > 4)\n\t\treturn -EINVAL;\n\n\tdsi->lanes = device->lanes;\n\tdsi->format = device->format;\n\tdsi->dsi_mode_flags = device->mode_flags;\n\n\treturn 0;\n}\n\nstatic bool nwl_dsi_read_packet(struct nwl_dsi *dsi, u32 status)\n{\n\tstruct device *dev = dsi->dev;\n\tstruct nwl_dsi_transfer *xfer = dsi->xfer;\n\tint err;\n\tu8 *payload = xfer->msg->rx_buf;\n\tu32 val;\n\tu16 word_count;\n\tu8 channel;\n\tu8 data_type;\n\n\txfer->status = 0;\n\n\tif (xfer->rx_word_count == 0) {\n\t\tif (!(status & NWL_DSI_RX_PKT_HDR_RCVD))\n\t\t\treturn false;\n\t\t \n\t\tval = nwl_dsi_read(dsi, NWL_DSI_RX_PKT_HEADER);\n\t\terr = nwl_dsi_clear_error(dsi);\n\t\tif (err)\n\t\t\txfer->status = err;\n\t\tword_count = NWL_DSI_WC(val);\n\t\tchannel = NWL_DSI_RX_VC(val);\n\t\tdata_type = NWL_DSI_RX_DT(val);\n\n\t\tif (channel != xfer->msg->channel) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"[%02X] Channel mismatch (%u != %u)\\n\",\n\t\t\t\t      xfer->cmd, channel, xfer->msg->channel);\n\t\t\txfer->status = -EINVAL;\n\t\t\treturn true;\n\t\t}\n\n\t\tswitch (data_type) {\n\t\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:\n\t\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:\n\t\t\tif (xfer->msg->rx_len > 1) {\n\t\t\t\t \n\t\t\t\tpayload[1] = word_count >> 8;\n\t\t\t\t++xfer->rx_len;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:\n\t\tcase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:\n\t\t\tif (xfer->msg->rx_len > 0) {\n\t\t\t\t \n\t\t\t\tpayload[0] = word_count & 0xff;\n\t\t\t\t++xfer->rx_len;\n\t\t\t}\n\t\t\txfer->status = xfer->rx_len;\n\t\t\treturn true;\n\t\tcase MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:\n\t\t\tword_count &= 0xff;\n\t\t\tDRM_DEV_ERROR(dev, \"[%02X] DSI error report: 0x%02x\\n\",\n\t\t\t\t      xfer->cmd, word_count);\n\t\t\txfer->status = -EPROTO;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (word_count > xfer->msg->rx_len) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\"[%02X] Receive buffer too small: %zu (< %u)\\n\",\n\t\t\t\txfer->cmd, xfer->msg->rx_len, word_count);\n\t\t\txfer->status = -EINVAL;\n\t\t\treturn true;\n\t\t}\n\n\t\txfer->rx_word_count = word_count;\n\t} else {\n\t\t \n\t\tword_count = xfer->rx_word_count;\n\t}\n\n\t \n\tif (!(status & NWL_DSI_RX_PKT_PAYLOAD_DATA_RCVD))\n\t\treturn false;\n\n\t \n\twhile (word_count >= 4) {\n\t\tval = nwl_dsi_read(dsi, NWL_DSI_RX_PAYLOAD);\n\t\tpayload[0] = (val >> 0) & 0xff;\n\t\tpayload[1] = (val >> 8) & 0xff;\n\t\tpayload[2] = (val >> 16) & 0xff;\n\t\tpayload[3] = (val >> 24) & 0xff;\n\t\tpayload += 4;\n\t\txfer->rx_len += 4;\n\t\tword_count -= 4;\n\t}\n\n\tif (word_count > 0) {\n\t\tval = nwl_dsi_read(dsi, NWL_DSI_RX_PAYLOAD);\n\t\tswitch (word_count) {\n\t\tcase 3:\n\t\t\tpayload[2] = (val >> 16) & 0xff;\n\t\t\t++xfer->rx_len;\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\tpayload[1] = (val >> 8) & 0xff;\n\t\t\t++xfer->rx_len;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\tpayload[0] = (val >> 0) & 0xff;\n\t\t\t++xfer->rx_len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txfer->status = xfer->rx_len;\n\terr = nwl_dsi_clear_error(dsi);\n\tif (err)\n\t\txfer->status = err;\n\n\treturn true;\n}\n\nstatic void nwl_dsi_finish_transmission(struct nwl_dsi *dsi, u32 status)\n{\n\tstruct nwl_dsi_transfer *xfer = dsi->xfer;\n\tbool end_packet = false;\n\n\tif (!xfer)\n\t\treturn;\n\n\tif (xfer->direction == DSI_PACKET_SEND &&\n\t    status & NWL_DSI_TX_PKT_DONE) {\n\t\txfer->status = xfer->tx_len;\n\t\tend_packet = true;\n\t} else if (status & NWL_DSI_DPHY_DIRECTION &&\n\t\t   ((status & (NWL_DSI_RX_PKT_HDR_RCVD |\n\t\t\t       NWL_DSI_RX_PKT_PAYLOAD_DATA_RCVD)))) {\n\t\tend_packet = nwl_dsi_read_packet(dsi, status);\n\t}\n\n\tif (end_packet)\n\t\tcomplete(&xfer->completed);\n}\n\nstatic void nwl_dsi_begin_transmission(struct nwl_dsi *dsi)\n{\n\tstruct nwl_dsi_transfer *xfer = dsi->xfer;\n\tstruct mipi_dsi_packet *pkt = &xfer->packet;\n\tconst u8 *payload;\n\tsize_t length;\n\tu16 word_count;\n\tu8 hs_mode;\n\tu32 val;\n\tu32 hs_workaround = 0;\n\n\t \n\tlength = pkt->payload_length;\n\tpayload = pkt->payload;\n\n\twhile (length >= 4) {\n\t\tval = *(u32 *)payload;\n\t\ths_workaround |= !(val & 0xFFFF00);\n\t\tnwl_dsi_write(dsi, NWL_DSI_TX_PAYLOAD, val);\n\t\tpayload += 4;\n\t\tlength -= 4;\n\t}\n\t \n\tval = 0;\n\tswitch (length) {\n\tcase 3:\n\t\tval |= payload[2] << 16;\n\t\tfallthrough;\n\tcase 2:\n\t\tval |= payload[1] << 8;\n\t\ths_workaround |= !(val & 0xFFFF00);\n\t\tfallthrough;\n\tcase 1:\n\t\tval |= payload[0];\n\t\tnwl_dsi_write(dsi, NWL_DSI_TX_PAYLOAD, val);\n\t\tbreak;\n\t}\n\txfer->tx_len = pkt->payload_length;\n\n\t \n\tword_count = pkt->header[1] | (pkt->header[2] << 8);\n\tif (hs_workaround && (dsi->quirks & E11418_HS_MODE_QUIRK)) {\n\t\tDRM_DEV_DEBUG_DRIVER(dsi->dev,\n\t\t\t\t     \"Using hs mode workaround for cmd 0x%x\\n\",\n\t\t\t\t     xfer->cmd);\n\t\ths_mode = 1;\n\t} else {\n\t\ths_mode = (xfer->msg->flags & MIPI_DSI_MSG_USE_LPM) ? 0 : 1;\n\t}\n\tval = NWL_DSI_WC(word_count) | NWL_DSI_TX_VC(xfer->msg->channel) |\n\t      NWL_DSI_TX_DT(xfer->msg->type) | NWL_DSI_HS_SEL(hs_mode) |\n\t      NWL_DSI_BTA_TX(xfer->need_bta);\n\tnwl_dsi_write(dsi, NWL_DSI_PKT_CONTROL, val);\n\n\t \n\tnwl_dsi_write(dsi, NWL_DSI_SEND_PACKET, 0x1);\n}\n\nstatic ssize_t nwl_dsi_host_transfer(struct mipi_dsi_host *dsi_host,\n\t\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\tstruct nwl_dsi *dsi = container_of(dsi_host, struct nwl_dsi, dsi_host);\n\tstruct nwl_dsi_transfer xfer;\n\tssize_t ret = 0;\n\n\t \n\tdsi->xfer = &xfer;\n\tret = mipi_dsi_create_packet(&xfer.packet, msg);\n\tif (ret < 0) {\n\t\tdsi->xfer = NULL;\n\t\treturn ret;\n\t}\n\n\tif ((msg->type & MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM ||\n\t     msg->type & MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM ||\n\t     msg->type & MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM ||\n\t     msg->type & MIPI_DSI_DCS_READ) &&\n\t    msg->rx_len > 0 && msg->rx_buf)\n\t\txfer.direction = DSI_PACKET_RECEIVE;\n\telse\n\t\txfer.direction = DSI_PACKET_SEND;\n\n\txfer.need_bta = (xfer.direction == DSI_PACKET_RECEIVE);\n\txfer.need_bta |= (msg->flags & MIPI_DSI_MSG_REQ_ACK) ? 1 : 0;\n\txfer.msg = msg;\n\txfer.status = -ETIMEDOUT;\n\txfer.rx_word_count = 0;\n\txfer.rx_len = 0;\n\txfer.cmd = 0x00;\n\tif (msg->tx_len > 0)\n\t\txfer.cmd = ((u8 *)(msg->tx_buf))[0];\n\tinit_completion(&xfer.completed);\n\n\tret = clk_prepare_enable(dsi->rx_esc_clk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to enable rx_esc clk: %zd\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"Enabled rx_esc clk @%lu Hz\\n\",\n\t\t\t     clk_get_rate(dsi->rx_esc_clk));\n\n\t \n\tnwl_dsi_begin_transmission(dsi);\n\n\tif (!wait_for_completion_timeout(&xfer.completed,\n\t\t\t\t\t NWL_DSI_MIPI_FIFO_TIMEOUT)) {\n\t\tDRM_DEV_ERROR(dsi_host->dev, \"[%02X] DSI transfer timed out\\n\",\n\t\t\t      xfer.cmd);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = xfer.status;\n\t}\n\n\tclk_disable_unprepare(dsi->rx_esc_clk);\n\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops nwl_dsi_host_ops = {\n\t.attach = nwl_dsi_host_attach,\n\t.transfer = nwl_dsi_host_transfer,\n};\n\nstatic irqreturn_t nwl_dsi_irq_handler(int irq, void *data)\n{\n\tu32 irq_status;\n\tstruct nwl_dsi *dsi = data;\n\n\tirq_status = nwl_dsi_read(dsi, NWL_DSI_IRQ_STATUS);\n\n\tif (irq_status & NWL_DSI_TX_FIFO_OVFLW)\n\t\tDRM_DEV_ERROR_RATELIMITED(dsi->dev, \"tx fifo overflow\\n\");\n\n\tif (irq_status & NWL_DSI_HS_TX_TIMEOUT)\n\t\tDRM_DEV_ERROR_RATELIMITED(dsi->dev, \"HS tx timeout\\n\");\n\n\tif (irq_status & NWL_DSI_TX_PKT_DONE ||\n\t    irq_status & NWL_DSI_RX_PKT_HDR_RCVD ||\n\t    irq_status & NWL_DSI_RX_PKT_PAYLOAD_DATA_RCVD)\n\t\tnwl_dsi_finish_transmission(dsi, irq_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nwl_dsi_mode_set(struct nwl_dsi *dsi)\n{\n\tstruct device *dev = dsi->dev;\n\tunion phy_configure_opts *phy_cfg = &dsi->phy_cfg;\n\tint ret;\n\n\tif (!dsi->lanes) {\n\t\tDRM_DEV_ERROR(dev, \"Need DSI lanes: %d\\n\", dsi->lanes);\n\t\treturn -EINVAL;\n\t}\n\n\tret = phy_init(dsi->phy);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to init DSI phy: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = phy_set_mode(dsi->phy, PHY_MODE_MIPI_DPHY);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to set DSI phy mode: %d\\n\", ret);\n\t\tgoto uninit_phy;\n\t}\n\n\tret = phy_configure(dsi->phy, phy_cfg);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to configure DSI phy: %d\\n\", ret);\n\t\tgoto uninit_phy;\n\t}\n\n\tret = clk_prepare_enable(dsi->tx_esc_clk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to enable tx_esc clk: %d\\n\",\n\t\t\t      ret);\n\t\tgoto uninit_phy;\n\t}\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"Enabled tx_esc clk @%lu Hz\\n\",\n\t\t\t     clk_get_rate(dsi->tx_esc_clk));\n\n\tret = nwl_dsi_config_host(dsi);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to set up DSI: %d\", ret);\n\t\tgoto disable_clock;\n\t}\n\n\tret = nwl_dsi_config_dpi(dsi);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to set up DPI: %d\", ret);\n\t\tgoto disable_clock;\n\t}\n\n\tret = phy_power_on(dsi->phy);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to power on DPHY (%d)\\n\", ret);\n\t\tgoto disable_clock;\n\t}\n\n\tret = nwl_dsi_init_interrupts(dsi);\n\tif (ret < 0)\n\t\tgoto power_off_phy;\n\n\treturn ret;\n\npower_off_phy:\n\tphy_power_off(dsi->phy);\ndisable_clock:\n\tclk_disable_unprepare(dsi->tx_esc_clk);\nuninit_phy:\n\tphy_exit(dsi->phy);\n\n\treturn ret;\n}\n\nstatic int nwl_dsi_disable(struct nwl_dsi *dsi)\n{\n\tstruct device *dev = dsi->dev;\n\n\tDRM_DEV_DEBUG_DRIVER(dev, \"Disabling clocks and phy\\n\");\n\n\tphy_power_off(dsi->phy);\n\tphy_exit(dsi->phy);\n\n\t \n\tclk_disable_unprepare(dsi->tx_esc_clk);\n\n\treturn 0;\n}\n\nstatic void\nnwl_dsi_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t      struct drm_bridge_state *old_bridge_state)\n{\n\tstruct nwl_dsi *dsi = bridge_to_dsi(bridge);\n\tint ret;\n\n\tnwl_dsi_disable(dsi);\n\n\tret = reset_control_assert(dsi->rst_dpi);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to assert DPI: %d\\n\", ret);\n\t\treturn;\n\t}\n\tret = reset_control_assert(dsi->rst_byte);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to assert ESC: %d\\n\", ret);\n\t\treturn;\n\t}\n\tret = reset_control_assert(dsi->rst_esc);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to assert BYTE: %d\\n\", ret);\n\t\treturn;\n\t}\n\tret = reset_control_assert(dsi->rst_pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to assert PCLK: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tclk_disable_unprepare(dsi->core_clk);\n\tclk_disable_unprepare(dsi->lcdif_clk);\n\n\tpm_runtime_put(dsi->dev);\n}\n\nstatic int nwl_dsi_get_dphy_params(struct nwl_dsi *dsi,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   union phy_configure_opts *phy_opts)\n{\n\tunsigned long rate;\n\tint ret;\n\n\tif (dsi->lanes < 1 || dsi->lanes > 4)\n\t\treturn -EINVAL;\n\n\t \n\tret = phy_mipi_dphy_get_default_config(mode->clock * 1000,\n\t\tmipi_dsi_pixel_format_to_bpp(dsi->format), dsi->lanes,\n\t\t&phy_opts->mipi_dphy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trate = clk_get_rate(dsi->tx_esc_clk);\n\tDRM_DEV_DEBUG_DRIVER(dsi->dev, \"LP clk is @%lu Hz\\n\", rate);\n\tphy_opts->mipi_dphy.lp_clk_rate = rate;\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\nnwl_dsi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_info *info,\n\t\t\t  const struct drm_display_mode *mode)\n{\n\tstruct nwl_dsi *dsi = bridge_to_dsi(bridge);\n\tint bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);\n\n\tif (mode->clock * bpp > 15000000 * dsi->lanes)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->clock * bpp < 80000 * dsi->lanes)\n\t\treturn MODE_CLOCK_LOW;\n\n\treturn MODE_OK;\n}\n\nstatic int nwl_dsi_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\n\t \n\tadjusted_mode->flags |= (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);\n\tadjusted_mode->flags &= ~(DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC);\n\n\t \n\tif (crtc_state->active_changed && crtc_state->active)\n\t\tcrtc_state->mode_changed = true;\n\n\treturn 0;\n}\n\nstatic void\nnwl_dsi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\tconst struct drm_display_mode *mode,\n\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct nwl_dsi *dsi = bridge_to_dsi(bridge);\n\tstruct device *dev = dsi->dev;\n\tunion phy_configure_opts new_cfg;\n\tunsigned long phy_ref_rate;\n\tint ret;\n\n\tret = nwl_dsi_get_dphy_params(dsi, adjusted_mode, &new_cfg);\n\tif (ret < 0)\n\t\treturn;\n\n\tphy_ref_rate = clk_get_rate(dsi->phy_ref_clk);\n\tDRM_DEV_DEBUG_DRIVER(dev, \"PHY at ref rate: %lu\\n\", phy_ref_rate);\n\t \n\tmemcpy(&dsi->phy_cfg, &new_cfg, sizeof(new_cfg));\n\n\tdrm_mode_copy(&dsi->mode, adjusted_mode);\n\tdrm_mode_debug_printmodeline(adjusted_mode);\n\n\tif (pm_runtime_resume_and_get(dev) < 0)\n\t\treturn;\n\n\tif (clk_prepare_enable(dsi->lcdif_clk) < 0)\n\t\tgoto runtime_put;\n\tif (clk_prepare_enable(dsi->core_clk) < 0)\n\t\tgoto runtime_put;\n\n\t \n\tret = reset_control_deassert(dsi->rst_pclk);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to deassert PCLK: %d\\n\", ret);\n\t\tgoto runtime_put;\n\t}\n\n\t \n\tnwl_dsi_mode_set(dsi);\n\n\t \n\tret = reset_control_deassert(dsi->rst_esc);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to deassert ESC: %d\\n\", ret);\n\t\tgoto runtime_put;\n\t}\n\tret = reset_control_deassert(dsi->rst_byte);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to deassert BYTE: %d\\n\", ret);\n\t\tgoto runtime_put;\n\t}\n\n\treturn;\n\nruntime_put:\n\tpm_runtime_put_sync(dev);\n}\n\nstatic void\nnwl_dsi_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct nwl_dsi *dsi = bridge_to_dsi(bridge);\n\tint ret;\n\n\t \n\tret = reset_control_deassert(dsi->rst_dpi);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to deassert DPI: %d\\n\", ret);\n}\n\nstatic int nwl_dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct nwl_dsi *dsi = bridge_to_dsi(bridge);\n\tstruct drm_bridge *panel_bridge;\n\n\tpanel_bridge = devm_drm_of_get_bridge(dsi->dev, dsi->dev->of_node, 1, 0);\n\tif (IS_ERR(panel_bridge))\n\t\treturn PTR_ERR(panel_bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, panel_bridge, bridge, flags);\n}\n\nstatic u32 *nwl_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t\t\t u32 output_fmt,\n\t\t\t\t\t\t unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts, input_fmt;\n\n\t*num_input_fmts = 0;\n\n\tswitch (output_fmt) {\n\t \n\tcase MEDIA_BUS_FMT_FIXED:\n\t\tinput_fmt = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\tinput_fmt = output_fmt;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tinput_fmts = kcalloc(1, sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\tinput_fmts[0] = input_fmt;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs nwl_dsi_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_check\t\t= nwl_dsi_bridge_atomic_check,\n\t.atomic_enable\t\t= nwl_dsi_bridge_atomic_enable,\n\t.atomic_disable\t\t= nwl_dsi_bridge_atomic_disable,\n\t.atomic_get_input_bus_fmts = nwl_bridge_atomic_get_input_bus_fmts,\n\t.mode_set\t\t= nwl_dsi_bridge_mode_set,\n\t.mode_valid\t\t= nwl_dsi_bridge_mode_valid,\n\t.attach\t\t\t= nwl_dsi_bridge_attach,\n};\n\nstatic int nwl_dsi_parse_dt(struct nwl_dsi *dsi)\n{\n\tstruct platform_device *pdev = to_platform_device(dsi->dev);\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tint ret;\n\n\tdsi->phy = devm_phy_get(dsi->dev, \"dphy\");\n\tif (IS_ERR(dsi->phy)) {\n\t\tret = PTR_ERR(dsi->phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dsi->dev, \"Could not get PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk = devm_clk_get(dsi->dev, \"lcdif\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get lcdif clock: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tdsi->lcdif_clk = clk;\n\n\tclk = devm_clk_get(dsi->dev, \"core\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get core clock: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tdsi->core_clk = clk;\n\n\tclk = devm_clk_get(dsi->dev, \"phy_ref\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get phy_ref clock: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tdsi->phy_ref_clk = clk;\n\n\tclk = devm_clk_get(dsi->dev, \"rx_esc\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get rx_esc clock: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tdsi->rx_esc_clk = clk;\n\n\tclk = devm_clk_get(dsi->dev, \"tx_esc\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get tx_esc clock: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\tdsi->tx_esc_clk = clk;\n\n\tdsi->mux = devm_mux_control_get(dsi->dev, NULL);\n\tif (IS_ERR(dsi->mux)) {\n\t\tret = PTR_ERR(dsi->mux);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get mux: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdsi->regmap =\n\t\tdevm_regmap_init_mmio(dsi->dev, base, &nwl_dsi_regmap_config);\n\tif (IS_ERR(dsi->regmap)) {\n\t\tret = PTR_ERR(dsi->regmap);\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to create NWL DSI regmap: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tdsi->irq = platform_get_irq(pdev, 0);\n\tif (dsi->irq < 0) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get device IRQ: %d\\n\",\n\t\t\t      dsi->irq);\n\t\treturn dsi->irq;\n\t}\n\n\tdsi->rst_pclk = devm_reset_control_get_exclusive(dsi->dev, \"pclk\");\n\tif (IS_ERR(dsi->rst_pclk)) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get pclk reset: %ld\\n\",\n\t\t\t      PTR_ERR(dsi->rst_pclk));\n\t\treturn PTR_ERR(dsi->rst_pclk);\n\t}\n\tdsi->rst_byte = devm_reset_control_get_exclusive(dsi->dev, \"byte\");\n\tif (IS_ERR(dsi->rst_byte)) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get byte reset: %ld\\n\",\n\t\t\t      PTR_ERR(dsi->rst_byte));\n\t\treturn PTR_ERR(dsi->rst_byte);\n\t}\n\tdsi->rst_esc = devm_reset_control_get_exclusive(dsi->dev, \"esc\");\n\tif (IS_ERR(dsi->rst_esc)) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get esc reset: %ld\\n\",\n\t\t\t      PTR_ERR(dsi->rst_esc));\n\t\treturn PTR_ERR(dsi->rst_esc);\n\t}\n\tdsi->rst_dpi = devm_reset_control_get_exclusive(dsi->dev, \"dpi\");\n\tif (IS_ERR(dsi->rst_dpi)) {\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to get dpi reset: %ld\\n\",\n\t\t\t      PTR_ERR(dsi->rst_dpi));\n\t\treturn PTR_ERR(dsi->rst_dpi);\n\t}\n\treturn 0;\n}\n\nstatic int nwl_dsi_select_input(struct nwl_dsi *dsi)\n{\n\tstruct device_node *remote;\n\tu32 use_dcss = 1;\n\tint ret;\n\n\tremote = of_graph_get_remote_node(dsi->dev->of_node, 0,\n\t\t\t\t\t  NWL_DSI_ENDPOINT_LCDIF);\n\tif (remote) {\n\t\tuse_dcss = 0;\n\t} else {\n\t\tremote = of_graph_get_remote_node(dsi->dev->of_node, 0,\n\t\t\t\t\t\t  NWL_DSI_ENDPOINT_DCSS);\n\t\tif (!remote) {\n\t\t\tDRM_DEV_ERROR(dsi->dev,\n\t\t\t\t      \"No valid input endpoint found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tDRM_DEV_INFO(dsi->dev, \"Using %s as input source\\n\",\n\t\t     (use_dcss) ? \"DCSS\" : \"LCDIF\");\n\tret = mux_control_try_select(dsi->mux, use_dcss);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to select input: %d\\n\", ret);\n\n\tof_node_put(remote);\n\treturn ret;\n}\n\nstatic int nwl_dsi_deselect_input(struct nwl_dsi *dsi)\n{\n\tint ret;\n\n\tret = mux_control_deselect(dsi->mux);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dsi->dev, \"Failed to deselect input: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct drm_bridge_timings nwl_dsi_timings = {\n\t.input_bus_flags = DRM_BUS_FLAG_DE_LOW,\n};\n\nstatic const struct of_device_id nwl_dsi_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8mq-nwl-dsi\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, nwl_dsi_dt_ids);\n\nstatic const struct soc_device_attribute nwl_dsi_quirks_match[] = {\n\t{ .soc_id = \"i.MX8MQ\", .revision = \"2.0\",\n\t  .data = (void *)E11418_HS_MODE_QUIRK },\n\t{   }\n};\n\nstatic int nwl_dsi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct soc_device_attribute *attr;\n\tstruct nwl_dsi *dsi;\n\tint ret;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsi->dev = dev;\n\n\tret = nwl_dsi_parse_dt(dsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_irq(dev, dsi->irq, nwl_dsi_irq_handler, 0,\n\t\t\t       dev_name(dev), dsi);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to request IRQ %d: %d\\n\", dsi->irq,\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tdsi->dsi_host.ops = &nwl_dsi_host_ops;\n\tdsi->dsi_host.dev = dev;\n\tret = mipi_dsi_host_register(&dsi->dsi_host);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"Failed to register MIPI host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tattr = soc_device_match(nwl_dsi_quirks_match);\n\tif (attr)\n\t\tdsi->quirks = (uintptr_t)attr->data;\n\n\tdsi->bridge.driver_private = dsi;\n\tdsi->bridge.funcs = &nwl_dsi_bridge_funcs;\n\tdsi->bridge.of_node = dev->of_node;\n\tdsi->bridge.timings = &nwl_dsi_timings;\n\n\tdev_set_drvdata(dev, dsi);\n\tpm_runtime_enable(dev);\n\n\tret = nwl_dsi_select_input(dsi);\n\tif (ret < 0) {\n\t\tpm_runtime_disable(dev);\n\t\tmipi_dsi_host_unregister(&dsi->dsi_host);\n\t\treturn ret;\n\t}\n\n\tdrm_bridge_add(&dsi->bridge);\n\treturn 0;\n}\n\nstatic void nwl_dsi_remove(struct platform_device *pdev)\n{\n\tstruct nwl_dsi *dsi = platform_get_drvdata(pdev);\n\n\tnwl_dsi_deselect_input(dsi);\n\tmipi_dsi_host_unregister(&dsi->dsi_host);\n\tdrm_bridge_remove(&dsi->bridge);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic struct platform_driver nwl_dsi_driver = {\n\t.probe\t\t= nwl_dsi_probe,\n\t.remove_new\t= nwl_dsi_remove,\n\t.driver\t\t= {\n\t\t.of_match_table = nwl_dsi_dt_ids,\n\t\t.name\t= DRV_NAME,\n\t},\n};\n\nmodule_platform_driver(nwl_dsi_driver);\n\nMODULE_AUTHOR(\"NXP Semiconductor\");\nMODULE_AUTHOR(\"Purism SPC\");\nMODULE_DESCRIPTION(\"Northwest Logic MIPI-DSI driver\");\nMODULE_LICENSE(\"GPL\");  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}