{
  "module_name": "tc358775.c",
  "hash_id": "795dfaccfeb4008831381de4ce191bff25ba9ac8da14c775bef4f1f3f1954460",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/tc358775.c",
  "human_readable_source": "\n \n \n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <asm/unaligned.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n\n#define FLD_VAL(val, start, end) FIELD_PREP(GENMASK(start, end), val)\n\n \n\n \n#define D0W_DPHYCONTTX  0x0004   \n#define CLW_DPHYCONTRX  0x0020   \n#define D0W_DPHYCONTRX  0x0024   \n#define D1W_DPHYCONTRX  0x0028   \n#define D2W_DPHYCONTRX  0x002C   \n#define D3W_DPHYCONTRX  0x0030   \n#define COM_DPHYCONTRX  0x0038   \n#define CLW_CNTRL       0x0040   \n#define D0W_CNTRL       0x0044   \n#define D1W_CNTRL       0x0048   \n#define D2W_CNTRL       0x004C   \n#define D3W_CNTRL       0x0050   \n#define DFTMODE_CNTRL   0x0054   \n\n \n#define PPI_STARTPPI    0x0104   \n#define PPI_START_FUNCTION      1\n\n#define PPI_BUSYPPI     0x0108\n#define PPI_LINEINITCNT 0x0110   \n#define PPI_LPTXTIMECNT 0x0114\n#define PPI_LANEENABLE  0x0134   \n#define PPI_TX_RX_TA    0x013C   \n\n \n#define PPI_CLS_ATMR    0x0140   \n#define PPI_D0S_ATMR    0x0144   \n#define PPI_D1S_ATMR    0x0148   \n#define PPI_D2S_ATMR    0x014C   \n#define PPI_D3S_ATMR    0x0150   \n\n#define PPI_D0S_CLRSIPOCOUNT    0x0164   \n#define PPI_D1S_CLRSIPOCOUNT    0x0168   \n#define PPI_D2S_CLRSIPOCOUNT    0x016C   \n#define PPI_D3S_CLRSIPOCOUNT    0x0170   \n\n#define CLS_PRE         0x0180   \n#define D0S_PRE         0x0184   \n#define D1S_PRE         0x0188   \n#define D2S_PRE         0x018C   \n#define D3S_PRE         0x0190   \n#define CLS_PREP        0x01A0   \n#define D0S_PREP        0x01A4   \n#define D1S_PREP        0x01A8   \n#define D2S_PREP        0x01AC   \n#define D3S_PREP        0x01B0   \n#define CLS_ZERO        0x01C0   \n#define D0S_ZERO        0x01C4   \n#define D1S_ZERO        0x01C8   \n#define D2S_ZERO        0x01CC   \n#define D3S_ZERO        0x01D0   \n\n#define PPI_CLRFLG      0x01E0   \n#define PPI_CLRSIPO     0x01E4   \n#define HSTIMEOUT       0x01F0   \n#define HSTIMEOUTENABLE 0x01F4   \n#define DSI_STARTDSI    0x0204   \n#define DSI_RX_START\t1\n\n#define DSI_BUSYDSI     0x0208\n#define DSI_LANEENABLE  0x0210   \n#define DSI_LANESTATUS0 0x0214   \n#define DSI_LANESTATUS1 0x0218   \n\n#define DSI_INTSTATUS   0x0220   \n#define DSI_INTMASK     0x0224   \n#define DSI_INTCLR      0x0228   \n#define DSI_LPTXTO      0x0230   \n\n#define DSIERRCNT       0x0300   \n#define APLCTRL         0x0400   \n#define RDPKTLN         0x0404   \n\n#define VPCTRL          0x0450   \n#define HTIM1           0x0454   \n#define HTIM2           0x0458   \n#define VTIM1           0x045C   \n#define VTIM2           0x0460   \n#define VFUEN           0x0464   \n#define VFUEN_EN\tBIT(0)   \n\n \n#define LV_MX0003        0x0480   \n#define LV_MX0407        0x0484   \n#define LV_MX0811        0x0488   \n#define LV_MX1215        0x048C   \n#define LV_MX1619        0x0490   \n#define LV_MX2023        0x0494   \n#define LV_MX2427        0x0498   \n#define LV_MX(b0, b1, b2, b3)\t(FLD_VAL(b0, 4, 0) | FLD_VAL(b1, 12, 8) | \\\n\t\t\t\tFLD_VAL(b2, 20, 16) | FLD_VAL(b3, 28, 24))\n\n \nenum {\n\tLVI_R0,\n\tLVI_R1,\n\tLVI_R2,\n\tLVI_R3,\n\tLVI_R4,\n\tLVI_R5,\n\tLVI_R6,\n\tLVI_R7,\n\tLVI_G0,\n\tLVI_G1,\n\tLVI_G2,\n\tLVI_G3,\n\tLVI_G4,\n\tLVI_G5,\n\tLVI_G6,\n\tLVI_G7,\n\tLVI_B0,\n\tLVI_B1,\n\tLVI_B2,\n\tLVI_B3,\n\tLVI_B4,\n\tLVI_B5,\n\tLVI_B6,\n\tLVI_B7,\n\tLVI_HS,\n\tLVI_VS,\n\tLVI_DE,\n\tLVI_L0\n};\n\n#define LVCFG           0x049C   \n#define LVPHY0          0x04A0   \n#define LV_PHY0_RST(v)          FLD_VAL(v, 22, 22)  \n#define LV_PHY0_IS(v)           FLD_VAL(v, 15, 14)\n#define LV_PHY0_ND(v)           FLD_VAL(v, 4, 0)  \n#define LV_PHY0_PRBS_ON(v)      FLD_VAL(v, 20, 16)  \n\n#define LVPHY1          0x04A4   \n#define SYSSTAT         0x0500   \n#define SYSRST          0x0504   \n\n#define SYS_RST_I2CS\tBIT(0)  \n#define SYS_RST_I2CM\tBIT(1)  \n#define SYS_RST_LCD\tBIT(2)  \n#define SYS_RST_BM\tBIT(3)  \n#define SYS_RST_DSIRX\tBIT(4)  \n#define SYS_RST_REG\tBIT(5)  \n\n \n#define GPIOC           0x0520   \n#define GPIOO           0x0524   \n#define GPIOI           0x0528   \n\n \n#define I2CTIMCTRL      0x0540   \n#define I2CMADDR        0x0544   \n#define WDATAQ          0x0548   \n#define RDATAQ          0x054C   \n\n \n#define IDREG           0x0580\n\n#define LPX_PERIOD\t\t4\n#define TTA_GET\t\t\t0x40000\n#define TTA_SURE\t\t6\n#define SINGLE_LINK\t\t1\n#define DUAL_LINK\t\t2\n\n#define TC358775XBG_ID  0x00007500\n\n \n#define DEBUG00         0x05A0   \n#define DEBUG01         0x05A4   \n\n#define DSI_CLEN_BIT\t\tBIT(0)\n#define DIVIDE_BY_3\t\t3  \n#define DIVIDE_BY_6\t\t6  \n#define LVCFG_LVEN_BIT\t\tBIT(0)\n\n#define L0EN BIT(1)\n\n#define TC358775_VPCTRL_VSDELAY__MASK\t0x3FF00000\n#define TC358775_VPCTRL_VSDELAY__SHIFT\t20\nstatic inline u32 TC358775_VPCTRL_VSDELAY(uint32_t val)\n{\n\treturn ((val) << TC358775_VPCTRL_VSDELAY__SHIFT) &\n\t\t\tTC358775_VPCTRL_VSDELAY__MASK;\n}\n\n#define TC358775_VPCTRL_OPXLFMT__MASK\t0x00000100\n#define TC358775_VPCTRL_OPXLFMT__SHIFT\t8\nstatic inline u32 TC358775_VPCTRL_OPXLFMT(uint32_t val)\n{\n\treturn ((val) << TC358775_VPCTRL_OPXLFMT__SHIFT) &\n\t\t\tTC358775_VPCTRL_OPXLFMT__MASK;\n}\n\n#define TC358775_VPCTRL_MSF__MASK\t0x00000001\n#define TC358775_VPCTRL_MSF__SHIFT\t0\nstatic inline u32 TC358775_VPCTRL_MSF(uint32_t val)\n{\n\treturn ((val) << TC358775_VPCTRL_MSF__SHIFT) &\n\t\t\tTC358775_VPCTRL_MSF__MASK;\n}\n\n#define TC358775_LVCFG_PCLKDIV__MASK\t0x000000f0\n#define TC358775_LVCFG_PCLKDIV__SHIFT\t4\nstatic inline u32 TC358775_LVCFG_PCLKDIV(uint32_t val)\n{\n\treturn ((val) << TC358775_LVCFG_PCLKDIV__SHIFT) &\n\t\t\tTC358775_LVCFG_PCLKDIV__MASK;\n}\n\n#define TC358775_LVCFG_LVDLINK__MASK                         0x00000002\n#define TC358775_LVCFG_LVDLINK__SHIFT                        1\nstatic inline u32 TC358775_LVCFG_LVDLINK(uint32_t val)\n{\n\treturn ((val) << TC358775_LVCFG_LVDLINK__SHIFT) &\n\t\t\tTC358775_LVCFG_LVDLINK__MASK;\n}\n\nenum tc358775_ports {\n\tTC358775_DSI_IN,\n\tTC358775_LVDS_OUT0,\n\tTC358775_LVDS_OUT1,\n};\n\nstruct tc_data {\n\tstruct i2c_client\t*i2c;\n\tstruct device\t\t*dev;\n\n\tstruct drm_bridge\tbridge;\n\tstruct drm_bridge\t*panel_bridge;\n\n\tstruct device_node *host_node;\n\tstruct mipi_dsi_device *dsi;\n\tu8 num_dsi_lanes;\n\n\tstruct regulator\t*vdd;\n\tstruct regulator\t*vddio;\n\tstruct gpio_desc\t*reset_gpio;\n\tstruct gpio_desc\t*stby_gpio;\n\tu8\t\t\tlvds_link;  \n\tu8\t\t\tbpc;\n};\n\nstatic inline struct tc_data *bridge_to_tc(struct drm_bridge *b)\n{\n\treturn container_of(b, struct tc_data, bridge);\n}\n\nstatic void tc_bridge_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tstruct device *dev = &tc->dsi->dev;\n\tint ret;\n\n\tret = regulator_enable(tc->vddio);\n\tif (ret < 0)\n\t\tdev_err(dev, \"regulator vddio enable failed, %d\\n\", ret);\n\tusleep_range(10000, 11000);\n\n\tret = regulator_enable(tc->vdd);\n\tif (ret < 0)\n\t\tdev_err(dev, \"regulator vdd enable failed, %d\\n\", ret);\n\tusleep_range(10000, 11000);\n\n\tgpiod_set_value(tc->stby_gpio, 0);\n\tusleep_range(10000, 11000);\n\n\tgpiod_set_value(tc->reset_gpio, 0);\n\tusleep_range(10, 20);\n}\n\nstatic void tc_bridge_post_disable(struct drm_bridge *bridge)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tstruct device *dev = &tc->dsi->dev;\n\tint ret;\n\n\tgpiod_set_value(tc->reset_gpio, 1);\n\tusleep_range(10, 20);\n\n\tgpiod_set_value(tc->stby_gpio, 1);\n\tusleep_range(10000, 11000);\n\n\tret = regulator_disable(tc->vdd);\n\tif (ret < 0)\n\t\tdev_err(dev, \"regulator vdd disable failed, %d\\n\", ret);\n\tusleep_range(10000, 11000);\n\n\tret = regulator_disable(tc->vddio);\n\tif (ret < 0)\n\t\tdev_err(dev, \"regulator vddio disable failed, %d\\n\", ret);\n\tusleep_range(10000, 11000);\n}\n\nstatic void d2l_read(struct i2c_client *i2c, u16 addr, u32 *val)\n{\n\tint ret;\n\tu8 buf_addr[2];\n\n\tput_unaligned_be16(addr, buf_addr);\n\tret = i2c_master_send(i2c, buf_addr, sizeof(buf_addr));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = i2c_master_recv(i2c, (u8 *)val, sizeof(*val));\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tpr_debug(\"d2l: I2C : addr:%04x value:%08x\\n\", addr, *val);\n\treturn;\n\nfail:\n\tdev_err(&i2c->dev, \"Error %d reading from subaddress 0x%x\\n\",\n\t\tret, addr);\n}\n\nstatic void d2l_write(struct i2c_client *i2c, u16 addr, u32 val)\n{\n\tu8 data[6];\n\tint ret;\n\n\tput_unaligned_be16(addr, data);\n\tput_unaligned_le32(val, data + 2);\n\n\tret = i2c_master_send(i2c, data, ARRAY_SIZE(data));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"Error %d writing to subaddress 0x%x\\n\",\n\t\t\tret, addr);\n}\n\n \nstatic struct drm_connector *get_connector(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\n\t\tif (connector->encoder == encoder)\n\t\t\treturn connector;\n\n\treturn NULL;\n}\n\nstatic void tc_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tu32 hback_porch, hsync_len, hfront_porch, hactive, htime1, htime2;\n\tu32 vback_porch, vsync_len, vfront_porch, vactive, vtime1, vtime2;\n\tu32 val = 0;\n\tu16 dsiclk, clkdiv, byteclk, t1, t2, t3, vsdelay;\n\tstruct drm_display_mode *mode;\n\tstruct drm_connector *connector = get_connector(bridge->encoder);\n\n\tmode = &bridge->encoder->crtc->state->adjusted_mode;\n\n\thback_porch = mode->htotal - mode->hsync_end;\n\thsync_len  = mode->hsync_end - mode->hsync_start;\n\tvback_porch = mode->vtotal - mode->vsync_end;\n\tvsync_len  = mode->vsync_end - mode->vsync_start;\n\n\thtime1 = (hback_porch << 16) + hsync_len;\n\tvtime1 = (vback_porch << 16) + vsync_len;\n\n\thfront_porch = mode->hsync_start - mode->hdisplay;\n\thactive = mode->hdisplay;\n\tvfront_porch = mode->vsync_start - mode->vdisplay;\n\tvactive = mode->vdisplay;\n\n\thtime2 = (hfront_porch << 16) + hactive;\n\tvtime2 = (vfront_porch << 16) + vactive;\n\n\td2l_read(tc->i2c, IDREG, &val);\n\n\tdev_info(tc->dev, \"DSI2LVDS Chip ID.%02x Revision ID. %02x **\\n\",\n\t\t (val >> 8) & 0xFF, val & 0xFF);\n\n\td2l_write(tc->i2c, SYSRST, SYS_RST_REG | SYS_RST_DSIRX | SYS_RST_BM |\n\t\t  SYS_RST_LCD | SYS_RST_I2CM);\n\tusleep_range(30000, 40000);\n\n\td2l_write(tc->i2c, PPI_TX_RX_TA, TTA_GET | TTA_SURE);\n\td2l_write(tc->i2c, PPI_LPTXTIMECNT, LPX_PERIOD);\n\td2l_write(tc->i2c, PPI_D0S_CLRSIPOCOUNT, 3);\n\td2l_write(tc->i2c, PPI_D1S_CLRSIPOCOUNT, 3);\n\td2l_write(tc->i2c, PPI_D2S_CLRSIPOCOUNT, 3);\n\td2l_write(tc->i2c, PPI_D3S_CLRSIPOCOUNT, 3);\n\n\tval = ((L0EN << tc->num_dsi_lanes) - L0EN) | DSI_CLEN_BIT;\n\td2l_write(tc->i2c, PPI_LANEENABLE, val);\n\td2l_write(tc->i2c, DSI_LANEENABLE, val);\n\n\td2l_write(tc->i2c, PPI_STARTPPI, PPI_START_FUNCTION);\n\td2l_write(tc->i2c, DSI_STARTDSI, DSI_RX_START);\n\n\tif (tc->bpc == 8)\n\t\tval = TC358775_VPCTRL_OPXLFMT(1);\n\telse  \n\t\tval = TC358775_VPCTRL_MSF(1);\n\n\tdsiclk = mode->crtc_clock * 3 * tc->bpc / tc->num_dsi_lanes / 1000;\n\tclkdiv = dsiclk / (tc->lvds_link == DUAL_LINK ? DIVIDE_BY_6 : DIVIDE_BY_3);\n\tbyteclk = dsiclk / 4;\n\tt1 = hactive * (tc->bpc * 3 / 8) / tc->num_dsi_lanes;\n\tt2 = ((100000 / clkdiv)) * (hactive + hback_porch + hsync_len + hfront_porch) / 1000;\n\tt3 = ((t2 * byteclk) / 100) - (hactive * (tc->bpc * 3 / 8) /\n\t\ttc->num_dsi_lanes);\n\n\tvsdelay = (clkdiv * (t1 + t3) / byteclk) - hback_porch - hsync_len - hactive;\n\n\tval |= TC358775_VPCTRL_VSDELAY(vsdelay);\n\td2l_write(tc->i2c, VPCTRL, val);\n\n\td2l_write(tc->i2c, HTIM1, htime1);\n\td2l_write(tc->i2c, VTIM1, vtime1);\n\td2l_write(tc->i2c, HTIM2, htime2);\n\td2l_write(tc->i2c, VTIM2, vtime2);\n\n\td2l_write(tc->i2c, VFUEN, VFUEN_EN);\n\td2l_write(tc->i2c, SYSRST, SYS_RST_LCD);\n\td2l_write(tc->i2c, LVPHY0, LV_PHY0_PRBS_ON(4) | LV_PHY0_ND(6));\n\n\tdev_dbg(tc->dev, \"bus_formats %04x bpc %d\\n\",\n\t\tconnector->display_info.bus_formats[0],\n\t\ttc->bpc);\n\t \n\tif (connector->display_info.bus_formats[0] ==\n\t\tMEDIA_BUS_FMT_RGB888_1X7X4_SPWG) {\n\t\t \n\t\td2l_write(tc->i2c, LV_MX0003, LV_MX(LVI_R0, LVI_R1, LVI_R2, LVI_R3));\n\t\td2l_write(tc->i2c, LV_MX0407, LV_MX(LVI_R4, LVI_R7, LVI_R5, LVI_G0));\n\t\td2l_write(tc->i2c, LV_MX0811, LV_MX(LVI_G1, LVI_G2, LVI_G6, LVI_G7));\n\t\td2l_write(tc->i2c, LV_MX1215, LV_MX(LVI_G3, LVI_G4, LVI_G5, LVI_B0));\n\t\td2l_write(tc->i2c, LV_MX1619, LV_MX(LVI_B6, LVI_B7, LVI_B1, LVI_B2));\n\t\td2l_write(tc->i2c, LV_MX2023, LV_MX(LVI_B3, LVI_B4, LVI_B5, LVI_L0));\n\t\td2l_write(tc->i2c, LV_MX2427, LV_MX(LVI_HS, LVI_VS, LVI_DE, LVI_R6));\n\t} else {  \n\t\td2l_write(tc->i2c, LV_MX0003, LV_MX(LVI_R0, LVI_R1, LVI_R2, LVI_R3));\n\t\td2l_write(tc->i2c, LV_MX0407, LV_MX(LVI_R4, LVI_L0, LVI_R5, LVI_G0));\n\t\td2l_write(tc->i2c, LV_MX0811, LV_MX(LVI_G1, LVI_G2, LVI_L0, LVI_L0));\n\t\td2l_write(tc->i2c, LV_MX1215, LV_MX(LVI_G3, LVI_G4, LVI_G5, LVI_B0));\n\t\td2l_write(tc->i2c, LV_MX1619, LV_MX(LVI_L0, LVI_L0, LVI_B1, LVI_B2));\n\t\td2l_write(tc->i2c, LV_MX2023, LV_MX(LVI_B3, LVI_B4, LVI_B5, LVI_L0));\n\t\td2l_write(tc->i2c, LV_MX2427, LV_MX(LVI_HS, LVI_VS, LVI_DE, LVI_L0));\n\t}\n\n\td2l_write(tc->i2c, VFUEN, VFUEN_EN);\n\n\tval = LVCFG_LVEN_BIT;\n\tif (tc->lvds_link == DUAL_LINK) {\n\t\tval |= TC358775_LVCFG_LVDLINK(1);\n\t\tval |= TC358775_LVCFG_PCLKDIV(DIVIDE_BY_6);\n\t} else {\n\t\tval |= TC358775_LVCFG_PCLKDIV(DIVIDE_BY_3);\n\t}\n\td2l_write(tc->i2c, LVCFG, val);\n}\n\nstatic enum drm_mode_status\ntc_mode_valid(struct drm_bridge *bridge,\n\t      const struct drm_display_info *info,\n\t      const struct drm_display_mode *mode)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\n\t \n\tif ((mode->clock > 135000 && tc->lvds_link == SINGLE_LINK) ||\n\t    (mode->clock > 270000 && tc->lvds_link == DUAL_LINK))\n\t\treturn MODE_CLOCK_HIGH;\n\n\tswitch (info->bus_formats[0]) {\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\t \n\t\ttc->bpc = 8;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\t \n\t\ttc->bpc = 6;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(tc->dev,\n\t\t\t \"unsupported LVDS bus format 0x%04x\\n\",\n\t\t\t info->bus_formats[0]);\n\t\treturn MODE_NOMODE;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic int tc358775_parse_dt(struct device_node *np, struct tc_data *tc)\n{\n\tstruct device_node *endpoint;\n\tstruct device_node *parent;\n\tstruct device_node *remote;\n\tint dsi_lanes = -1;\n\n\t \n\tendpoint = of_graph_get_endpoint_by_regs(tc->dev->of_node,\n\t\t\t\t\t\t TC358775_DSI_IN, -1);\n\tif (endpoint) {\n\t\t \n\t\tparent = of_graph_get_remote_port_parent(endpoint);\n\t\tof_node_put(endpoint);\n\t\tif (parent) {\n\t\t\t \n\t\t\tdsi_lanes = drm_of_get_data_lanes_count_ep(parent, 1, -1, 1, 4);\n\t\t\tof_node_put(parent);\n\t\t}\n\t}\n\n\tif (dsi_lanes < 0)\n\t\treturn dsi_lanes;\n\n\ttc->num_dsi_lanes = dsi_lanes;\n\n\ttc->host_node = of_graph_get_remote_node(np, 0, 0);\n\tif (!tc->host_node)\n\t\treturn -ENODEV;\n\n\tof_node_put(tc->host_node);\n\n\ttc->lvds_link = SINGLE_LINK;\n\tendpoint = of_graph_get_endpoint_by_regs(tc->dev->of_node,\n\t\t\t\t\t\t TC358775_LVDS_OUT1, -1);\n\tif (endpoint) {\n\t\tremote = of_graph_get_remote_port_parent(endpoint);\n\t\tof_node_put(endpoint);\n\n\t\tif (remote) {\n\t\t\tif (of_device_is_available(remote))\n\t\t\t\ttc->lvds_link = DUAL_LINK;\n\t\t\tof_node_put(remote);\n\t\t}\n\t}\n\n\tdev_dbg(tc->dev, \"no.of dsi lanes: %d\\n\", tc->num_dsi_lanes);\n\tdev_dbg(tc->dev, \"operating in %d-link mode\\n\",\ttc->lvds_link);\n\n\treturn 0;\n}\n\nstatic int tc_bridge_attach(struct drm_bridge *bridge,\n\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\n\t \n\treturn drm_bridge_attach(bridge->encoder, tc->panel_bridge,\n\t\t\t\t &tc->bridge, flags);\n}\n\nstatic const struct drm_bridge_funcs tc_bridge_funcs = {\n\t.attach = tc_bridge_attach,\n\t.pre_enable = tc_bridge_pre_enable,\n\t.enable = tc_bridge_enable,\n\t.mode_valid = tc_mode_valid,\n\t.post_disable = tc_bridge_post_disable,\n};\n\nstatic int tc_attach_host(struct tc_data *tc)\n{\n\tstruct device *dev = &tc->i2c->dev;\n\tstruct mipi_dsi_host *host;\n\tstruct mipi_dsi_device *dsi;\n\tint ret;\n\tconst struct mipi_dsi_device_info info = { .type = \"tc358775\",\n\t\t\t\t\t\t\t.channel = 0,\n\t\t\t\t\t\t\t.node = NULL,\n\t\t\t\t\t\t};\n\n\thost = of_find_mipi_dsi_host_by_node(tc->host_node);\n\tif (!host) {\n\t\tdev_err(dev, \"failed to find dsi host\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi)) {\n\t\tdev_err(dev, \"failed to create dsi device\\n\");\n\t\treturn PTR_ERR(dsi);\n\t}\n\n\ttc->dsi = dsi;\n\n\tdsi->lanes = tc->num_dsi_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tc_data *tc;\n\tint ret;\n\n\ttc = devm_kzalloc(dev, sizeof(*tc), GFP_KERNEL);\n\tif (!tc)\n\t\treturn -ENOMEM;\n\n\ttc->dev = dev;\n\ttc->i2c = client;\n\n\ttc->panel_bridge = devm_drm_of_get_bridge(dev, dev->of_node,\n\t\t\t\t\t\t  TC358775_LVDS_OUT0, 0);\n\tif (IS_ERR(tc->panel_bridge))\n\t\treturn PTR_ERR(tc->panel_bridge);\n\n\tret = tc358775_parse_dt(dev->of_node, tc);\n\tif (ret)\n\t\treturn ret;\n\n\ttc->vddio = devm_regulator_get(dev, \"vddio-supply\");\n\tif (IS_ERR(tc->vddio)) {\n\t\tret = PTR_ERR(tc->vddio);\n\t\tdev_err(dev, \"vddio-supply not found\\n\");\n\t\treturn ret;\n\t}\n\n\ttc->vdd = devm_regulator_get(dev, \"vdd-supply\");\n\tif (IS_ERR(tc->vdd)) {\n\t\tret = PTR_ERR(tc->vdd);\n\t\tdev_err(dev, \"vdd-supply not found\\n\");\n\t\treturn ret;\n\t}\n\n\ttc->stby_gpio = devm_gpiod_get(dev, \"stby\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tc->stby_gpio)) {\n\t\tret = PTR_ERR(tc->stby_gpio);\n\t\tdev_err(dev, \"cannot get stby-gpio %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttc->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tc->reset_gpio)) {\n\t\tret = PTR_ERR(tc->reset_gpio);\n\t\tdev_err(dev, \"cannot get reset-gpios %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttc->bridge.funcs = &tc_bridge_funcs;\n\ttc->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&tc->bridge);\n\n\ti2c_set_clientdata(client, tc);\n\n\tret = tc_attach_host(tc);\n\tif (ret)\n\t\tgoto err_bridge_remove;\n\n\treturn 0;\n\nerr_bridge_remove:\n\tdrm_bridge_remove(&tc->bridge);\n\treturn ret;\n}\n\nstatic void tc_remove(struct i2c_client *client)\n{\n\tstruct tc_data *tc = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&tc->bridge);\n}\n\nstatic const struct i2c_device_id tc358775_i2c_ids[] = {\n\t{ \"tc358775\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tc358775_i2c_ids);\n\nstatic const struct of_device_id tc358775_of_ids[] = {\n\t{ .compatible = \"toshiba,tc358775\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tc358775_of_ids);\n\nstatic struct i2c_driver tc358775_driver = {\n\t.driver = {\n\t\t.name = \"tc358775\",\n\t\t.of_match_table = tc358775_of_ids,\n\t},\n\t.id_table = tc358775_i2c_ids,\n\t.probe = tc_probe,\n\t.remove\t= tc_remove,\n};\nmodule_i2c_driver(tc358775_driver);\n\nMODULE_AUTHOR(\"Vinay Simha BN <simhavcs@gmail.com>\");\nMODULE_DESCRIPTION(\"TC358775 DSI/LVDS bridge driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}