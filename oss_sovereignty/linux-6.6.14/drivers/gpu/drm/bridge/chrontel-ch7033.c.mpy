{
  "module_name": "chrontel-ch7033.c",
  "hash_id": "6a47cef6ff89b829e7f29767ca668f6764026e13b358707329b5b22428d7a449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/chrontel-ch7033.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n \nenum {\n\tDRI_PD\t\t= BIT(3),\n\tIO_PD\t\t= BIT(5),\n};\n\n \nenum {\n\tDRI_PDDRI\t= GENMASK(7, 4),\n\tPDDAC\t\t= GENMASK(3, 1),\n\tPANEN\t\t= BIT(0),\n};\n\n \nenum {\n\tDPD\t\t= BIT(7),\n\tGCKOFF\t\t= BIT(6),\n\tTV_BP\t\t= BIT(5),\n\tSCLPD\t\t= BIT(4),\n\tSDPD\t\t= BIT(3),\n\tVGA_PD\t\t= BIT(2),\n\tHDBKPD\t\t= BIT(1),\n\tHDMI_PD\t\t= BIT(0),\n};\n\n \nenum {\n\tMEMINIT\t\t= BIT(7),\n\tMEMIDLE\t\t= BIT(6),\n\tMEMPD\t\t= BIT(5),\n\tSTOP\t\t= BIT(4),\n\tLVDS_PD\t\t= BIT(3),\n\tHD_DVIB\t\t= BIT(2),\n\tHDCP_PD\t\t= BIT(1),\n\tMCU_PD\t\t= BIT(0),\n};\n\n \nenum {\n\tIDF\t\t= GENMASK(7, 4),\n\tINTEN\t\t= BIT(3),\n\tSWAP\t\t= GENMASK(2, 0),\n};\n\nenum {\n\tBYTE_SWAP_RGB\t= 0,\n\tBYTE_SWAP_RBG\t= 1,\n\tBYTE_SWAP_GRB\t= 2,\n\tBYTE_SWAP_GBR\t= 3,\n\tBYTE_SWAP_BRG\t= 4,\n\tBYTE_SWAP_BGR\t= 5,\n};\n\n \nenum {\n\tHPO_I\t\t= BIT(5),\n\tVPO_I\t\t= BIT(4),\n\tDEPO_I\t\t= BIT(3),\n\tCRYS_EN\t\t= BIT(2),\n\tGCLKFREQ\t= GENMASK(2, 0),\n};\n\n \nenum {\n\tHFLIP\t\t= BIT(7),\n\tVFLIP\t\t= BIT(6),\n\tDEPO_O\t\t= BIT(5),\n\tHPO_O\t\t= BIT(4),\n\tVPO_O\t\t= BIT(3),\n\tTE\t\t= GENMASK(2, 0),\n};\n\n \nenum {\n\tSWAPS\t\t= GENMASK(7, 4),\n\tVFMT\t\t= GENMASK(3, 0),\n};\n\n \nenum {\n\tCOMP_BP\t\t= BIT(7),\n\tDAC_EN_T\t= BIT(6),\n\tHWO_HDMI_HI\t= GENMASK(5, 3),\n\tHOO_HDMI_HI\t= GENMASK(2, 0),\n};\n\n \nenum {\n\tFLDSEN\t\t= BIT(7),\n\tVWO_HDMI_HI\t= GENMASK(5, 3),\n\tVOO_HDMI_HI\t= GENMASK(2, 0),\n};\n\n \nenum {\n\tHDMI_LVDS_SEL\t= BIT(7),\n\tDE_GEN\t\t= BIT(6),\n\tPWM_INDEX_HI\t= BIT(5),\n\tUSE_DE\t\t= BIT(4),\n\tR_INT\t\t= GENMASK(3, 0),\n};\n\n \nenum {\n\tBPCKSEL\t\t= BIT(7),\n\tDRI_CMFB_EN\t= BIT(6),\n\tCEC_PUEN\t= BIT(5),\n\tCEC_T\t\t= BIT(3),\n\tCKINV\t\t= BIT(2),\n\tCK_TVINV\t= BIT(1),\n\tDRI_CKS2\t= BIT(0),\n};\n\n \nenum {\n\tDACG\t\t= BIT(6),\n\tDACKTST\t\t= BIT(5),\n\tDEDGEB\t\t= BIT(4),\n\tSYO\t\t= BIT(3),\n\tDRI_IT_LVDS\t= GENMASK(2, 1),\n\tDISPON\t\t= BIT(0),\n};\n\n \nenum {\n\tDRI_PLL_CP\t= GENMASK(7, 6),\n\tDRI_PLL_DIVSEL\t= BIT(5),\n\tDRI_PLL_N1_1\t= BIT(4),\n\tDRI_PLL_N1_0\t= BIT(3),\n\tDRI_PLL_N3_1\t= BIT(2),\n\tDRI_PLL_N3_0\t= BIT(1),\n\tDRI_PLL_CKTSTEN = BIT(0),\n};\n\n \nenum {\n\tVCO3CS\t\t= GENMASK(7, 6),\n\tICPGBK2_0\t= GENMASK(5, 3),\n\tDRI_VCO357SC\t= BIT(2),\n\tPDPLL2\t\t= BIT(1),\n\tDRI_PD_SER\t= BIT(0),\n};\n\n \nenum {\n\tPLL2N11\t\t= GENMASK(7, 4),\n\tPLL2N5_4\t= BIT(3),\n\tPLL2N5_TOP\t= BIT(2),\n\tDRI_PLL_PD\t= BIT(1),\n\tPD_I2CM\t\t= BIT(0),\n};\n\n \nenum {\n\tDIFF_EN\t\t= GENMASK(7, 6),\n\tCORREC_EN\t= GENMASK(5, 4),\n\tVGACLK_BP\t= BIT(3),\n\tHM_LV_SEL\t= BIT(2),\n\tHD_VGA_SEL\t= BIT(1),\n};\n\n \nenum {\n\tLVDSCLK_BP\t= BIT(7),\n\tHDTVCLK_BP\t= BIT(6),\n\tHDMICLK_BP\t= BIT(5),\n\tHDTV_BP\t\t= BIT(4),\n\tHDMI_BP\t\t= BIT(3),\n\tTHRWL\t\t= GENMASK(2, 0),\n};\n\n \nenum {\n\tPGM_ARSTB\t= BIT(7),\n\tMCU_ARSTB\t= BIT(6),\n\tMCU_RETB\t= BIT(2),\n\tRESETIB\t\t= BIT(1),\n\tRESETDB\t\t= BIT(0),\n};\n\nstruct ch7033_priv {\n\tstruct regmap *regmap;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_bridge bridge;\n\tstruct drm_connector connector;\n};\n\n#define conn_to_ch7033_priv(x) \\\n\tcontainer_of(x, struct ch7033_priv, connector)\n#define bridge_to_ch7033_priv(x) \\\n\tcontainer_of(x, struct ch7033_priv, bridge)\n\n\nstatic enum drm_connector_status ch7033_connector_detect(\n\tstruct drm_connector *connector, bool force)\n{\n\tstruct ch7033_priv *priv = conn_to_ch7033_priv(connector);\n\n\treturn drm_bridge_detect(priv->next_bridge);\n}\n\nstatic const struct drm_connector_funcs ch7033_connector_funcs = {\n\t.reset = drm_atomic_helper_connector_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = ch7033_connector_detect,\n\t.destroy = drm_connector_cleanup,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ch7033_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct ch7033_priv *priv = conn_to_ch7033_priv(connector);\n\tstruct edid *edid;\n\tint ret;\n\n\tedid = drm_bridge_get_edid(priv->next_bridge, connector);\n\tdrm_connector_update_edid_property(connector, edid);\n\tif (edid) {\n\t\tret = drm_add_edid_modes(connector, edid);\n\t\tkfree(edid);\n\t} else {\n\t\tret = drm_add_modes_noedid(connector, 1920, 1080);\n\t\tdrm_set_preferred_mode(connector, 1024, 768);\n\t}\n\n\treturn ret;\n}\n\nstatic struct drm_encoder *ch7033_connector_best_encoder(\n\t\t\tstruct drm_connector *connector)\n{\n\tstruct ch7033_priv *priv = conn_to_ch7033_priv(connector);\n\n\treturn priv->bridge.encoder;\n}\n\nstatic const struct drm_connector_helper_funcs ch7033_connector_helper_funcs = {\n\t.get_modes = ch7033_connector_get_modes,\n\t.best_encoder = ch7033_connector_best_encoder,\n};\n\nstatic void ch7033_hpd_event(void *arg, enum drm_connector_status status)\n{\n\tstruct ch7033_priv *priv = arg;\n\n\tif (priv->bridge.dev)\n\t\tdrm_helper_hpd_irq_event(priv->connector.dev);\n}\n\nstatic int ch7033_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct ch7033_priv *priv = bridge_to_ch7033_priv(bridge);\n\tstruct drm_connector *connector = &priv->connector;\n\tint ret;\n\n\tret = drm_bridge_attach(bridge->encoder, priv->next_bridge, bridge,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret)\n\t\treturn ret;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\tif (priv->next_bridge->ops & DRM_BRIDGE_OP_DETECT) {\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\t} else {\n\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\t    DRM_CONNECTOR_POLL_DISCONNECT;\n\t}\n\n\tif (priv->next_bridge->ops & DRM_BRIDGE_OP_HPD) {\n\t\tdrm_bridge_hpd_enable(priv->next_bridge, ch7033_hpd_event,\n\t\t\t\t      priv);\n\t}\n\n\tdrm_connector_helper_add(connector,\n\t\t\t\t &ch7033_connector_helper_funcs);\n\tret = drm_connector_init_with_ddc(bridge->dev, &priv->connector,\n\t\t\t\t\t  &ch7033_connector_funcs,\n\t\t\t\t\t  priv->next_bridge->type,\n\t\t\t\t\t  priv->next_bridge->ddc);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector\\n\");\n\t\treturn ret;\n\t}\n\n\treturn drm_connector_attach_encoder(&priv->connector, bridge->encoder);\n}\n\nstatic void ch7033_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct ch7033_priv *priv = bridge_to_ch7033_priv(bridge);\n\n\tif (priv->next_bridge->ops & DRM_BRIDGE_OP_HPD)\n\t\tdrm_bridge_hpd_disable(priv->next_bridge);\n\tdrm_connector_cleanup(&priv->connector);\n}\n\nstatic enum drm_mode_status ch7033_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t     const struct drm_display_info *info,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tif (mode->clock > 165000)\n\t\treturn MODE_CLOCK_HIGH;\n\tif (mode->hdisplay >= 1920)\n\t\treturn MODE_BAD_HVALUE;\n\tif (mode->vdisplay >= 1080)\n\t\treturn MODE_BAD_VVALUE;\n\treturn MODE_OK;\n}\n\nstatic void ch7033_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct ch7033_priv *priv = bridge_to_ch7033_priv(bridge);\n\n\tregmap_write(priv->regmap, 0x03, 0x04);\n\tregmap_update_bits(priv->regmap, 0x52, RESETDB, 0x00);\n}\n\nstatic void ch7033_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct ch7033_priv *priv = bridge_to_ch7033_priv(bridge);\n\n\tregmap_write(priv->regmap, 0x03, 0x04);\n\tregmap_update_bits(priv->regmap, 0x52, RESETDB, RESETDB);\n}\n\nstatic void ch7033_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   const struct drm_display_mode *adjusted_mode)\n{\n\tstruct ch7033_priv *priv = bridge_to_ch7033_priv(bridge);\n\tint hbporch = mode->hsync_start - mode->hdisplay;\n\tint hsynclen = mode->hsync_end - mode->hsync_start;\n\tint vbporch = mode->vsync_start - mode->vdisplay;\n\tint vsynclen = mode->vsync_end - mode->vsync_start;\n\n\t \n\tregmap_write(priv->regmap, 0x03, 0x04);\n\n\t \n\tregmap_write(priv->regmap, 0x52, 0x00);\n\t \n\tregmap_write(priv->regmap, 0x52, RESETIB);\n\n\t \n\tregmap_write(priv->regmap, 0x03, 0x00);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x07, DRI_PD | IO_PD, 0);\n\tregmap_update_bits(priv->regmap, 0x08, DRI_PDDRI | PDDAC | PANEN, 0);\n\tregmap_update_bits(priv->regmap, 0x09, DPD | GCKOFF |\n\t\t\t\t\t       HDMI_PD | VGA_PD, 0);\n\tregmap_update_bits(priv->regmap, 0x0a, HD_DVIB, 0);\n\n\t \n\tregmap_write(priv->regmap, 0x0b, (mode->htotal >> 8) << 3 |\n\t\t\t\t\t (mode->hdisplay >> 8));\n\tregmap_write(priv->regmap, 0x0c, mode->hdisplay);\n\tregmap_write(priv->regmap, 0x0d, mode->htotal);\n\tregmap_write(priv->regmap, 0x0e, (hsynclen >> 8) << 3 |\n\t\t\t\t\t (hbporch >> 8));\n\tregmap_write(priv->regmap, 0x0f, hbporch);\n\tregmap_write(priv->regmap, 0x10, hsynclen);\n\n\t \n\tregmap_write(priv->regmap, 0x11, (mode->vtotal >> 8) << 3 |\n\t\t\t\t\t (mode->vdisplay >> 8));\n\tregmap_write(priv->regmap, 0x12, mode->vdisplay);\n\tregmap_write(priv->regmap, 0x13, mode->vtotal);\n\tregmap_write(priv->regmap, 0x14, ((vsynclen >> 8) << 3) |\n\t\t\t\t\t (vbporch >> 8));\n\tregmap_write(priv->regmap, 0x15, vbporch);\n\tregmap_write(priv->regmap, 0x16, vsynclen);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x18, SWAP, BYTE_SWAP_BGR);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x19, 0x1, mode->clock >> 16);\n\tregmap_update_bits(priv->regmap, 0x19, HPO_I | VPO_I | GCLKFREQ,\n\t\t\t   (mode->flags & DRM_MODE_FLAG_PHSYNC) ? HPO_I : 0 |\n\t\t\t   (mode->flags & DRM_MODE_FLAG_PVSYNC) ? VPO_I : 0 |\n\t\t\t   mode->clock >> 16);\n\tregmap_write(priv->regmap, 0x1a, mode->clock >> 8);\n\tregmap_write(priv->regmap, 0x1b, mode->clock);\n\n\t \n\tregmap_write(priv->regmap, 0x1f, (mode->htotal >> 8) << 3 |\n\t\t\t\t\t (mode->hdisplay >> 8));\n\tregmap_write(priv->regmap, 0x20, mode->hdisplay);\n\tregmap_write(priv->regmap, 0x21, mode->htotal);\n\n\t \n\tregmap_write(priv->regmap, 0x25, (mode->vtotal >> 8) << 3 |\n\t\t\t\t\t (mode->vdisplay >> 8));\n\tregmap_write(priv->regmap, 0x26, mode->vdisplay);\n\tregmap_write(priv->regmap, 0x27, mode->vtotal);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x2b, VFMT, 9);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x2e, HPO_O | VPO_O,\n\t\t\t   (mode->flags & DRM_MODE_FLAG_PHSYNC) ? HPO_O : 0 |\n\t\t\t   (mode->flags & DRM_MODE_FLAG_PVSYNC) ? VPO_O : 0);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x54, HWO_HDMI_HI | HOO_HDMI_HI,\n\t\t\t\t\t       (hsynclen >> 8) << 3 |\n\t\t\t\t\t       (hbporch >> 8));\n\tregmap_write(priv->regmap, 0x55, hbporch);\n\tregmap_write(priv->regmap, 0x56, hsynclen);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x57, VWO_HDMI_HI | VOO_HDMI_HI,\n\t\t\t\t\t       (vsynclen >> 8) << 3 |\n\t\t\t\t\t       (vbporch >> 8));\n\tregmap_write(priv->regmap, 0x58, vbporch);\n\tregmap_write(priv->regmap, 0x59, vsynclen);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x7e, HDMI_LVDS_SEL, HDMI_LVDS_SEL);\n\n\t \n\tregmap_write(priv->regmap, 0x03, 0x01);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x07, CKINV, CKINV);\n\tregmap_update_bits(priv->regmap, 0x08, DISPON, DISPON);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x0c, DRI_PLL_DIVSEL, DRI_PLL_DIVSEL);\n\tif (mode->clock <= 40000) {\n\t\tregmap_update_bits(priv->regmap, 0x0c, DRI_PLL_N1_1 |\n\t\t\t\t\t\t       DRI_PLL_N1_0 |\n\t\t\t\t\t\t       DRI_PLL_N3_1 |\n\t\t\t\t\t\t       DRI_PLL_N3_0,\n\t\t\t\t\t\t       0);\n\t} else if (mode->clock < 80000) {\n\t\tregmap_update_bits(priv->regmap, 0x0c, DRI_PLL_N1_1 |\n\t\t\t\t\t\t       DRI_PLL_N1_0 |\n\t\t\t\t\t\t       DRI_PLL_N3_1 |\n\t\t\t\t\t\t       DRI_PLL_N3_0,\n\t\t\t\t\t\t       DRI_PLL_N3_0 |\n\t\t\t\t\t\t       DRI_PLL_N1_0);\n\t} else {\n\t\tregmap_update_bits(priv->regmap, 0x0c, DRI_PLL_N1_1 |\n\t\t\t\t\t\t       DRI_PLL_N1_0 |\n\t\t\t\t\t\t       DRI_PLL_N3_1 |\n\t\t\t\t\t\t       DRI_PLL_N3_0,\n\t\t\t\t\t\t       DRI_PLL_N3_1 |\n\t\t\t\t\t\t       DRI_PLL_N1_1);\n\t}\n\n\t \n\tregmap_write(priv->regmap, 0x64, 0x29);  \n\tregmap_write(priv->regmap, 0x65, 0x29);  \n\tregmap_write(priv->regmap, 0x66, 0x29);  \n\tregmap_write(priv->regmap, 0x67, 0x00);  \n\tregmap_write(priv->regmap, 0x68, 0x00);  \n\tregmap_write(priv->regmap, 0x69, 0x00);  \n\n\tregmap_update_bits(priv->regmap, 0x6b, DRI_PD_SER, 0x00);\n\tregmap_update_bits(priv->regmap, 0x6c, DRI_PLL_PD, 0x00);\n\n\t \n\tregmap_write(priv->regmap, 0x03, 0x03);\n\n\t \n\tregmap_update_bits(priv->regmap, 0x28, VGACLK_BP | HM_LV_SEL,\n\t\t\t\t\t       VGACLK_BP | HM_LV_SEL);\n\tregmap_update_bits(priv->regmap, 0x2a, HDMICLK_BP | HDMI_BP,\n\t\t\t\t\t       HDMICLK_BP | HDMI_BP);\n\n\t \n\tregmap_write(priv->regmap, 0x03, 0x04);\n\n\t \n\tregmap_write(priv->regmap, 0x10, mode->clock >> 16);\n\tregmap_write(priv->regmap, 0x11, mode->clock >> 8);\n\tregmap_write(priv->regmap, 0x12, mode->clock);\n}\n\nstatic const struct drm_bridge_funcs ch7033_bridge_funcs = {\n\t.attach = ch7033_bridge_attach,\n\t.detach = ch7033_bridge_detach,\n\t.mode_valid = ch7033_bridge_mode_valid,\n\t.disable = ch7033_bridge_disable,\n\t.enable = ch7033_bridge_enable,\n\t.mode_set = ch7033_bridge_mode_set,\n};\n\nstatic const struct regmap_config ch7033_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x7f,\n};\n\nstatic int ch7033_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ch7033_priv *priv;\n\tunsigned int val;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\n\tret = drm_of_find_panel_or_bridge(dev->of_node, 1, -1, NULL,\n\t\t\t\t\t  &priv->next_bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->regmap = devm_regmap_init_i2c(client, &ch7033_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&client->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tret = regmap_read(priv->regmap, 0x00, &val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error reading the model id: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif ((val & 0xf7) != 0x56) {\n\t\tdev_err(&client->dev, \"the device is not a ch7033\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregmap_write(priv->regmap, 0x03, 0x04);\n\tret = regmap_read(priv->regmap, 0x51, &val);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"error reading the model id: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif ((val & 0x0f) != 3) {\n\t\tdev_err(&client->dev, \"unknown revision %u\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tINIT_LIST_HEAD(&priv->bridge.list);\n\tpriv->bridge.funcs = &ch7033_bridge_funcs;\n\tpriv->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&priv->bridge);\n\n\tdev_info(dev, \"Chrontel CH7033 Video Encoder\\n\");\n\treturn 0;\n}\n\nstatic void ch7033_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ch7033_priv *priv = dev_get_drvdata(dev);\n\n\tdrm_bridge_remove(&priv->bridge);\n}\n\nstatic const struct of_device_id ch7033_dt_ids[] = {\n\t{ .compatible = \"chrontel,ch7033\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ch7033_dt_ids);\n\nstatic const struct i2c_device_id ch7033_ids[] = {\n\t{ \"ch7033\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ch7033_ids);\n\nstatic struct i2c_driver ch7033_driver = {\n\t.probe = ch7033_probe,\n\t.remove = ch7033_remove,\n\t.driver = {\n\t\t.name = \"ch7033\",\n\t\t.of_match_table = ch7033_dt_ids,\n\t},\n\t.id_table = ch7033_ids,\n};\n\nmodule_i2c_driver(ch7033_driver);\n\nMODULE_AUTHOR(\"Lubomir Rintel <lkundrak@v3.sk>\");\nMODULE_DESCRIPTION(\"Chrontel CH7033 Video Encoder Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}