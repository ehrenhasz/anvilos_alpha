{
  "module_name": "tc358767.c",
  "hash_id": "a0291c44ce4e62bcb4e642a9b8077484ae475edc4447cfd2fa31e3204705e4d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/tc358767.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n \n\n \n#define PPI_STARTPPI\t\t0x0104  \n#define PPI_LPTXTIMECNT\t\t0x0114  \n#define LPX_PERIOD\t\t\t3\n#define PPI_LANEENABLE\t\t0x0134\n#define PPI_TX_RX_TA\t\t0x013c\n#define TTA_GET\t\t\t\t0x40000\n#define TTA_SURE\t\t\t6\n#define PPI_D0S_ATMR\t\t0x0144\n#define PPI_D1S_ATMR\t\t0x0148\n#define PPI_D0S_CLRSIPOCOUNT\t0x0164  \n#define PPI_D1S_CLRSIPOCOUNT\t0x0168  \n#define PPI_D2S_CLRSIPOCOUNT\t0x016c  \n#define PPI_D3S_CLRSIPOCOUNT\t0x0170  \n#define PPI_START_FUNCTION\t\tBIT(0)\n\n \n#define DSI_STARTDSI\t\t0x0204  \n#define DSI_LANEENABLE\t\t0x0210  \n#define DSI_RX_START\t\t\tBIT(0)\n\n \n#define LANEENABLE_CLEN\t\tBIT(0)\n#define LANEENABLE_L0EN\t\tBIT(1)\n#define LANEENABLE_L1EN\t\tBIT(2)\n#define LANEENABLE_L2EN\t\tBIT(1)\n#define LANEENABLE_L3EN\t\tBIT(2)\n\n \n#define DPIPXLFMT\t\t0x0440\n#define VS_POL_ACTIVE_LOW\t\t(1 << 10)\n#define HS_POL_ACTIVE_LOW\t\t(1 << 9)\n#define DE_POL_ACTIVE_HIGH\t\t(0 << 8)\n#define SUB_CFG_TYPE_CONFIG1\t\t(0 << 2)  \n#define SUB_CFG_TYPE_CONFIG2\t\t(1 << 2)  \n#define SUB_CFG_TYPE_CONFIG3\t\t(2 << 2)  \n#define DPI_BPP_RGB888\t\t\t(0 << 0)\n#define DPI_BPP_RGB666\t\t\t(1 << 0)\n#define DPI_BPP_RGB565\t\t\t(2 << 0)\n\n \n#define POCTRL\t\t\t0x0448\n#define POCTRL_S2P\t\t\tBIT(7)\n#define POCTRL_PCLK_POL\t\t\tBIT(3)\n#define POCTRL_VS_POL\t\t\tBIT(2)\n#define POCTRL_HS_POL\t\t\tBIT(1)\n#define POCTRL_DE_POL\t\t\tBIT(0)\n\n \n#define VPCTRL0\t\t\t0x0450\n#define VSDELAY\t\t\tGENMASK(31, 20)\n#define OPXLFMT_RGB666\t\t\t(0 << 8)\n#define OPXLFMT_RGB888\t\t\t(1 << 8)\n#define FRMSYNC_DISABLED\t\t(0 << 4)  \n#define FRMSYNC_ENABLED\t\t\t(1 << 4)  \n#define MSF_DISABLED\t\t\t(0 << 0)  \n#define MSF_ENABLED\t\t\t(1 << 0)  \n#define HTIM01\t\t\t0x0454\n#define HPW\t\t\tGENMASK(8, 0)\n#define HBPR\t\t\tGENMASK(24, 16)\n#define HTIM02\t\t\t0x0458\n#define HDISPR\t\t\tGENMASK(10, 0)\n#define HFPR\t\t\tGENMASK(24, 16)\n#define VTIM01\t\t\t0x045c\n#define VSPR\t\t\tGENMASK(7, 0)\n#define VBPR\t\t\tGENMASK(23, 16)\n#define VTIM02\t\t\t0x0460\n#define VFPR\t\t\tGENMASK(23, 16)\n#define VDISPR\t\t\tGENMASK(10, 0)\n#define VFUEN0\t\t\t0x0464\n#define VFUEN\t\t\t\tBIT(0)    \n\n \n#define TC_IDREG\t\t0x0500\n#define SYSSTAT\t\t\t0x0508\n#define SYSCTRL\t\t\t0x0510\n#define DP0_AUDSRC_NO_INPUT\t\t(0 << 3)\n#define DP0_AUDSRC_I2S_RX\t\t(1 << 3)\n#define DP0_VIDSRC_NO_INPUT\t\t(0 << 0)\n#define DP0_VIDSRC_DSI_RX\t\t(1 << 0)\n#define DP0_VIDSRC_DPI_RX\t\t(2 << 0)\n#define DP0_VIDSRC_COLOR_BAR\t\t(3 << 0)\n#define SYSRSTENB\t\t0x050c\n#define ENBI2C\t\t\t\t(1 << 0)\n#define ENBLCD0\t\t\t\t(1 << 2)\n#define ENBBM\t\t\t\t(1 << 3)\n#define ENBDSIRX\t\t\t(1 << 4)\n#define ENBREG\t\t\t\t(1 << 5)\n#define ENBHDCP\t\t\t\t(1 << 8)\n#define GPIOM\t\t\t0x0540\n#define GPIOC\t\t\t0x0544\n#define GPIOO\t\t\t0x0548\n#define GPIOI\t\t\t0x054c\n#define INTCTL_G\t\t0x0560\n#define INTSTS_G\t\t0x0564\n\n#define INT_SYSERR\t\tBIT(16)\n#define INT_GPIO_H(x)\t\t(1 << (x == 0 ? 2 : 10))\n#define INT_GPIO_LC(x)\t\t(1 << (x == 0 ? 3 : 11))\n\n#define INT_GP0_LCNT\t\t0x0584\n#define INT_GP1_LCNT\t\t0x0588\n\n \n#define DP0CTL\t\t\t0x0600\n#define VID_MN_GEN\t\t\tBIT(6)    \n#define EF_EN\t\t\t\tBIT(5)    \n#define VID_EN\t\t\t\tBIT(1)    \n#define DP_EN\t\t\t\tBIT(0)    \n\n \n#define DP0_VIDMNGEN0\t\t0x0610\n#define DP0_VIDMNGEN1\t\t0x0614\n#define DP0_VMNGENSTATUS\t0x0618\n\n \n#define DP0_SECSAMPLE\t\t0x0640\n#define DP0_VIDSYNCDELAY\t0x0644\n#define VID_SYNC_DLY\t\tGENMASK(15, 0)\n#define THRESH_DLY\t\tGENMASK(31, 16)\n\n#define DP0_TOTALVAL\t\t0x0648\n#define H_TOTAL\t\t\tGENMASK(15, 0)\n#define V_TOTAL\t\t\tGENMASK(31, 16)\n#define DP0_STARTVAL\t\t0x064c\n#define H_START\t\t\tGENMASK(15, 0)\n#define V_START\t\t\tGENMASK(31, 16)\n#define DP0_ACTIVEVAL\t\t0x0650\n#define H_ACT\t\t\tGENMASK(15, 0)\n#define V_ACT\t\t\tGENMASK(31, 16)\n\n#define DP0_SYNCVAL\t\t0x0654\n#define VS_WIDTH\t\tGENMASK(30, 16)\n#define HS_WIDTH\t\tGENMASK(14, 0)\n#define SYNCVAL_HS_POL_ACTIVE_LOW\t(1 << 15)\n#define SYNCVAL_VS_POL_ACTIVE_LOW\t(1 << 31)\n#define DP0_MISC\t\t0x0658\n#define TU_SIZE_RECOMMENDED\t\t(63)  \n#define MAX_TU_SYMBOL\t\tGENMASK(28, 23)\n#define TU_SIZE\t\t\tGENMASK(21, 16)\n#define BPC_6\t\t\t\t(0 << 5)\n#define BPC_8\t\t\t\t(1 << 5)\n\n \n#define DP0_AUXCFG0\t\t0x0660\n#define DP0_AUXCFG0_BSIZE\tGENMASK(11, 8)\n#define DP0_AUXCFG0_ADDR_ONLY\tBIT(4)\n#define DP0_AUXCFG1\t\t0x0664\n#define AUX_RX_FILTER_EN\t\tBIT(16)\n\n#define DP0_AUXADDR\t\t0x0668\n#define DP0_AUXWDATA(i)\t\t(0x066c + (i) * 4)\n#define DP0_AUXRDATA(i)\t\t(0x067c + (i) * 4)\n#define DP0_AUXSTATUS\t\t0x068c\n#define AUX_BYTES\t\tGENMASK(15, 8)\n#define AUX_STATUS\t\tGENMASK(7, 4)\n#define AUX_TIMEOUT\t\tBIT(1)\n#define AUX_BUSY\t\tBIT(0)\n#define DP0_AUXI2CADR\t\t0x0698\n\n \n#define DP0_SRCCTRL\t\t0x06a0\n#define DP0_SRCCTRL_SCRMBLDIS\t\tBIT(13)\n#define DP0_SRCCTRL_EN810B\t\tBIT(12)\n#define DP0_SRCCTRL_NOTP\t\t(0 << 8)\n#define DP0_SRCCTRL_TP1\t\t\t(1 << 8)\n#define DP0_SRCCTRL_TP2\t\t\t(2 << 8)\n#define DP0_SRCCTRL_LANESKEW\t\tBIT(7)\n#define DP0_SRCCTRL_SSCG\t\tBIT(3)\n#define DP0_SRCCTRL_LANES_1\t\t(0 << 2)\n#define DP0_SRCCTRL_LANES_2\t\t(1 << 2)\n#define DP0_SRCCTRL_BW27\t\t(1 << 1)\n#define DP0_SRCCTRL_BW162\t\t(0 << 1)\n#define DP0_SRCCTRL_AUTOCORRECT\t\tBIT(0)\n#define DP0_LTSTAT\t\t0x06d0\n#define LT_LOOPDONE\t\t\tBIT(13)\n#define LT_STATUS_MASK\t\t\t(0x1f << 8)\n#define LT_CHANNEL1_EQ_BITS\t\t(DP_CHANNEL_EQ_BITS << 4)\n#define LT_INTERLANE_ALIGN_DONE\t\tBIT(3)\n#define LT_CHANNEL0_EQ_BITS\t\t(DP_CHANNEL_EQ_BITS)\n#define DP0_SNKLTCHGREQ\t\t0x06d4\n#define DP0_LTLOOPCTRL\t\t0x06d8\n#define DP0_SNKLTCTRL\t\t0x06e4\n\n#define DP1_SRCCTRL\t\t0x07a0\n\n \n#define DP_PHY_CTRL\t\t0x0800\n#define DP_PHY_RST\t\t\tBIT(28)   \n#define BGREN\t\t\t\tBIT(25)   \n#define PWR_SW_EN\t\t\tBIT(24)   \n#define PHY_M1_RST\t\t\tBIT(12)   \n#define PHY_RDY\t\t\t\tBIT(16)   \n#define PHY_M0_RST\t\t\tBIT(8)    \n#define PHY_2LANE\t\t\tBIT(2)    \n#define PHY_A0_EN\t\t\tBIT(1)    \n#define PHY_M0_EN\t\t\tBIT(0)    \n\n \n#define DP0_PLLCTRL\t\t0x0900\n#define DP1_PLLCTRL\t\t0x0904\t \n#define PXL_PLLCTRL\t\t0x0908\n#define PLLUPDATE\t\t\tBIT(2)\n#define PLLBYP\t\t\t\tBIT(1)\n#define PLLEN\t\t\t\tBIT(0)\n#define PXL_PLLPARAM\t\t0x0914\n#define IN_SEL_REFCLK\t\t\t(0 << 14)\n#define SYS_PLLPARAM\t\t0x0918\n#define REF_FREQ_38M4\t\t\t(0 << 8)  \n#define REF_FREQ_19M2\t\t\t(1 << 8)  \n#define REF_FREQ_26M\t\t\t(2 << 8)  \n#define REF_FREQ_13M\t\t\t(3 << 8)  \n#define SYSCLK_SEL_LSCLK\t\t(0 << 4)\n#define LSCLK_DIV_1\t\t\t(0 << 0)\n#define LSCLK_DIV_2\t\t\t(1 << 0)\n\n \n#define TSTCTL\t\t\t0x0a00\n#define COLOR_R\t\t\tGENMASK(31, 24)\n#define COLOR_G\t\t\tGENMASK(23, 16)\n#define COLOR_B\t\t\tGENMASK(15, 8)\n#define ENI2CFILTER\t\tBIT(4)\n#define COLOR_BAR_MODE\t\tGENMASK(1, 0)\n#define COLOR_BAR_MODE_BARS\t2\n#define PLL_DBG\t\t\t0x0a04\n\nstatic bool tc_test_pattern;\nmodule_param_named(test, tc_test_pattern, bool, 0644);\n\nstruct tc_edp_link {\n\tu8\t\t\tdpcd[DP_RECEIVER_CAP_SIZE];\n\tunsigned int\t\trate;\n\tu8\t\t\tnum_lanes;\n\tu8\t\t\tassr;\n\tbool\t\t\tscrambler_dis;\n\tbool\t\t\tspread;\n};\n\nstruct tc_data {\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*regmap;\n\tstruct drm_dp_aux\taux;\n\n\tstruct drm_bridge\tbridge;\n\tstruct drm_bridge\t*panel_bridge;\n\tstruct drm_connector\tconnector;\n\n\tstruct mipi_dsi_device\t*dsi;\n\n\t \n\tstruct tc_edp_link\tlink;\n\n\t \n\tstruct drm_display_mode\tmode;\n\n\tu32\t\t\trev;\n\tu8\t\t\tassr;\n\n\tstruct gpio_desc\t*sd_gpio;\n\tstruct gpio_desc\t*reset_gpio;\n\tstruct clk\t\t*refclk;\n\n\t \n\tbool\t\t\thave_irq;\n\n\t \n\tbool\t\t\tinput_connector_dsi;\n\n\t \n\tint\t\t\thpd_pin;\n};\n\nstatic inline struct tc_data *aux_to_tc(struct drm_dp_aux *a)\n{\n\treturn container_of(a, struct tc_data, aux);\n}\n\nstatic inline struct tc_data *bridge_to_tc(struct drm_bridge *b)\n{\n\treturn container_of(b, struct tc_data, bridge);\n}\n\nstatic inline struct tc_data *connector_to_tc(struct drm_connector *c)\n{\n\treturn container_of(c, struct tc_data, connector);\n}\n\nstatic inline int tc_poll_timeout(struct tc_data *tc, unsigned int addr,\n\t\t\t\t  unsigned int cond_mask,\n\t\t\t\t  unsigned int cond_value,\n\t\t\t\t  unsigned long sleep_us, u64 timeout_us)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(tc->regmap, addr, val,\n\t\t\t\t\t(val & cond_mask) == cond_value,\n\t\t\t\t\tsleep_us, timeout_us);\n}\n\nstatic int tc_aux_wait_busy(struct tc_data *tc)\n{\n\treturn tc_poll_timeout(tc, DP0_AUXSTATUS, AUX_BUSY, 0, 100, 100000);\n}\n\nstatic int tc_aux_write_data(struct tc_data *tc, const void *data,\n\t\t\t     size_t size)\n{\n\tu32 auxwdata[DP_AUX_MAX_PAYLOAD_BYTES / sizeof(u32)] = { 0 };\n\tint ret, count = ALIGN(size, sizeof(u32));\n\n\tmemcpy(auxwdata, data, size);\n\n\tret = regmap_raw_write(tc->regmap, DP0_AUXWDATA(0), auxwdata, count);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic int tc_aux_read_data(struct tc_data *tc, void *data, size_t size)\n{\n\tu32 auxrdata[DP_AUX_MAX_PAYLOAD_BYTES / sizeof(u32)];\n\tint ret, count = ALIGN(size, sizeof(u32));\n\n\tret = regmap_raw_read(tc->regmap, DP0_AUXRDATA(0), auxrdata, count);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(data, auxrdata, size);\n\n\treturn size;\n}\n\nstatic u32 tc_auxcfg0(struct drm_dp_aux_msg *msg, size_t size)\n{\n\tu32 auxcfg0 = msg->request;\n\n\tif (size)\n\t\tauxcfg0 |= FIELD_PREP(DP0_AUXCFG0_BSIZE, size - 1);\n\telse\n\t\tauxcfg0 |= DP0_AUXCFG0_ADDR_ONLY;\n\n\treturn auxcfg0;\n}\n\nstatic ssize_t tc_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t       struct drm_dp_aux_msg *msg)\n{\n\tstruct tc_data *tc = aux_to_tc(aux);\n\tsize_t size = min_t(size_t, DP_AUX_MAX_PAYLOAD_BYTES - 1, msg->size);\n\tu8 request = msg->request & ~DP_AUX_I2C_MOT;\n\tu32 auxstatus;\n\tint ret;\n\n\tret = tc_aux_wait_busy(tc);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (request) {\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\tbreak;\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\t\tif (size) {\n\t\t\tret = tc_aux_write_data(tc, msg->buffer, size);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_write(tc->regmap, DP0_AUXADDR, msg->address);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_write(tc->regmap, DP0_AUXCFG0, tc_auxcfg0(msg, size));\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_aux_wait_busy(tc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(tc->regmap, DP0_AUXSTATUS, &auxstatus);\n\tif (ret)\n\t\treturn ret;\n\n\tif (auxstatus & AUX_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\t \n\tif (size)\n\t\tsize = FIELD_GET(AUX_BYTES, auxstatus);\n\tmsg->reply = FIELD_GET(AUX_STATUS, auxstatus);\n\n\tswitch (request) {\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\tif (size)\n\t\t\treturn tc_aux_read_data(tc, msg->buffer, size);\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic const char * const training_pattern1_errors[] = {\n\t\"No errors\",\n\t\"Aux write error\",\n\t\"Aux read error\",\n\t\"Max voltage reached error\",\n\t\"Loop counter expired error\",\n\t\"res\", \"res\", \"res\"\n};\n\nstatic const char * const training_pattern2_errors[] = {\n\t\"No errors\",\n\t\"Aux write error\",\n\t\"Aux read error\",\n\t\"Clock recovery failed error\",\n\t\"Loop counter expired error\",\n\t\"res\", \"res\", \"res\"\n};\n\nstatic u32 tc_srcctrl(struct tc_data *tc)\n{\n\t \n\tu32 reg = DP0_SRCCTRL_NOTP | DP0_SRCCTRL_LANESKEW | DP0_SRCCTRL_EN810B;\n\n\tif (tc->link.scrambler_dis)\n\t\treg |= DP0_SRCCTRL_SCRMBLDIS;\t \n\tif (tc->link.spread)\n\t\treg |= DP0_SRCCTRL_SSCG;\t \n\tif (tc->link.num_lanes == 2)\n\t\treg |= DP0_SRCCTRL_LANES_2;\t \n\tif (tc->link.rate != 162000)\n\t\treg |= DP0_SRCCTRL_BW27;\t \n\treturn reg;\n}\n\nstatic int tc_pllupdate(struct tc_data *tc, unsigned int pllctrl)\n{\n\tint ret;\n\n\tret = regmap_write(tc->regmap, pllctrl, PLLUPDATE | PLLEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(15000, 20000);\n\n\treturn 0;\n}\n\nstatic int tc_pxl_pll_en(struct tc_data *tc, u32 refclk, u32 pixelclock)\n{\n\tint ret;\n\tint i_pre, best_pre = 1;\n\tint i_post, best_post = 1;\n\tint div, best_div = 1;\n\tint mul, best_mul = 1;\n\tint delta, best_delta;\n\tint ext_div[] = {1, 2, 3, 5, 7};\n\tint clk_min, clk_max;\n\tint best_pixelclock = 0;\n\tint vco_hi = 0;\n\tu32 pxl_pllparam;\n\n\t \n\tif (tc->bridge.type == DRM_MODE_CONNECTOR_DPI) {\n\t\tclk_min = 0;\n\t\tclk_max = 100000000;\n\t} else {\n\t\tclk_min = 150000000;\n\t\tclk_max = 650000000;\n\t}\n\n\tdev_dbg(tc->dev, \"PLL: requested %d pixelclock, ref %d\\n\", pixelclock,\n\t\trefclk);\n\tbest_delta = pixelclock;\n\t \n\tfor (i_pre = 0; i_pre < ARRAY_SIZE(ext_div); i_pre++) {\n\t\t \n\t\tif (refclk / ext_div[i_pre] < 1000000)\n\t\t\tcontinue;\n\t\tfor (i_post = 0; i_post < ARRAY_SIZE(ext_div); i_post++) {\n\t\t\tfor (div = 1; div <= 16; div++) {\n\t\t\t\tu32 clk;\n\t\t\t\tu64 tmp;\n\n\t\t\t\ttmp = pixelclock * ext_div[i_pre] *\n\t\t\t\t      ext_div[i_post] * div;\n\t\t\t\tdo_div(tmp, refclk);\n\t\t\t\tmul = tmp;\n\n\t\t\t\t \n\t\t\t\tif ((mul < 1) || (mul > 128))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tclk = (refclk / ext_div[i_pre] / div) * mul;\n\t\t\t\tif ((clk > clk_max) || (clk < clk_min))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tclk = clk / ext_div[i_post];\n\t\t\t\tdelta = clk - pixelclock;\n\n\t\t\t\tif (abs(delta) < abs(best_delta)) {\n\t\t\t\t\tbest_pre = i_pre;\n\t\t\t\t\tbest_post = i_post;\n\t\t\t\t\tbest_div = div;\n\t\t\t\t\tbest_mul = mul;\n\t\t\t\t\tbest_delta = delta;\n\t\t\t\t\tbest_pixelclock = clk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (best_pixelclock == 0) {\n\t\tdev_err(tc->dev, \"Failed to calc clock for %d pixelclock\\n\",\n\t\t\tpixelclock);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(tc->dev, \"PLL: got %d, delta %d\\n\", best_pixelclock,\n\t\tbest_delta);\n\tdev_dbg(tc->dev, \"PLL: %d / %d / %d * %d / %d\\n\", refclk,\n\t\text_div[best_pre], best_div, best_mul, ext_div[best_post]);\n\n\t \n\tif (refclk / ext_div[best_pre] / best_div * best_mul >= 300000000)\n\t\tvco_hi = 1;\n\t \n\tif (best_div == 16)\n\t\tbest_div = 0;\n\tif (best_mul == 128)\n\t\tbest_mul = 0;\n\n\t \n\tret = regmap_write(tc->regmap, PXL_PLLCTRL, PLLBYP | PLLEN);\n\tif (ret)\n\t\treturn ret;\n\n\tpxl_pllparam  = vco_hi << 24;  \n\tpxl_pllparam |= ext_div[best_pre] << 20;  \n\tpxl_pllparam |= ext_div[best_post] << 16;  \n\tpxl_pllparam |= IN_SEL_REFCLK;  \n\tpxl_pllparam |= best_div << 8;  \n\tpxl_pllparam |= best_mul;  \n\n\tret = regmap_write(tc->regmap, PXL_PLLPARAM, pxl_pllparam);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn tc_pllupdate(tc, PXL_PLLCTRL);\n}\n\nstatic int tc_pxl_pll_dis(struct tc_data *tc)\n{\n\t \n\treturn regmap_write(tc->regmap, PXL_PLLCTRL, PLLBYP);\n}\n\nstatic int tc_stream_clock_calc(struct tc_data *tc)\n{\n\t \n\treturn regmap_write(tc->regmap, DP0_VIDMNGEN1, 32768);\n}\n\nstatic int tc_set_syspllparam(struct tc_data *tc)\n{\n\tunsigned long rate;\n\tu32 pllparam = SYSCLK_SEL_LSCLK | LSCLK_DIV_2;\n\n\trate = clk_get_rate(tc->refclk);\n\tswitch (rate) {\n\tcase 38400000:\n\t\tpllparam |= REF_FREQ_38M4;\n\t\tbreak;\n\tcase 26000000:\n\t\tpllparam |= REF_FREQ_26M;\n\t\tbreak;\n\tcase 19200000:\n\t\tpllparam |= REF_FREQ_19M2;\n\t\tbreak;\n\tcase 13000000:\n\t\tpllparam |= REF_FREQ_13M;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tc->dev, \"Invalid refclk rate: %lu Hz\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(tc->regmap, SYS_PLLPARAM, pllparam);\n}\n\nstatic int tc_aux_link_setup(struct tc_data *tc)\n{\n\tint ret;\n\tu32 dp0_auxcfg1;\n\n\t \n\tret = tc_set_syspllparam(tc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(tc->regmap, DP_PHY_CTRL,\n\t\t\t   BGREN | PWR_SW_EN | PHY_A0_EN);\n\tif (ret)\n\t\tgoto err;\n\t \n\tret = tc_pllupdate(tc, DP0_PLLCTRL);\n\tif (ret)\n\t\tgoto err;\n\n\tret = tc_pllupdate(tc, DP1_PLLCTRL);\n\tif (ret)\n\t\tgoto err;\n\n\tret = tc_poll_timeout(tc, DP_PHY_CTRL, PHY_RDY, PHY_RDY, 100, 100000);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(tc->dev, \"Timeout waiting for PHY to become ready\");\n\t\treturn ret;\n\t} else if (ret) {\n\t\tgoto err;\n\t}\n\n\t \n\tdp0_auxcfg1  = AUX_RX_FILTER_EN;\n\tdp0_auxcfg1 |= 0x06 << 8;  \n\tdp0_auxcfg1 |= 0x3f << 0;  \n\n\tret = regmap_write(tc->regmap, DP0_AUXCFG1, dp0_auxcfg1);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\ttc->aux.name = \"TC358767 AUX i2c adapter\";\n\ttc->aux.dev = tc->dev;\n\ttc->aux.transfer = tc_aux_transfer;\n\tdrm_dp_aux_init(&tc->aux);\n\n\treturn 0;\nerr:\n\tdev_err(tc->dev, \"tc_aux_link_setup failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tc_get_display_props(struct tc_data *tc)\n{\n\tu8 revision, num_lanes;\n\tunsigned int rate;\n\tint ret;\n\tu8 reg;\n\n\t \n\tret = drm_dp_dpcd_read(&tc->aux, DP_DPCD_REV, tc->link.dpcd,\n\t\t\t       DP_RECEIVER_CAP_SIZE);\n\tif (ret < 0)\n\t\tgoto err_dpcd_read;\n\n\trevision = tc->link.dpcd[DP_DPCD_REV];\n\trate = drm_dp_max_link_rate(tc->link.dpcd);\n\tnum_lanes = drm_dp_max_lane_count(tc->link.dpcd);\n\n\tif (rate != 162000 && rate != 270000) {\n\t\tdev_dbg(tc->dev, \"Falling to 2.7 Gbps rate\\n\");\n\t\trate = 270000;\n\t}\n\n\ttc->link.rate = rate;\n\n\tif (num_lanes > 2) {\n\t\tdev_dbg(tc->dev, \"Falling to 2 lanes\\n\");\n\t\tnum_lanes = 2;\n\t}\n\n\ttc->link.num_lanes = num_lanes;\n\n\tret = drm_dp_dpcd_readb(&tc->aux, DP_MAX_DOWNSPREAD, &reg);\n\tif (ret < 0)\n\t\tgoto err_dpcd_read;\n\ttc->link.spread = reg & DP_MAX_DOWNSPREAD_0_5;\n\n\tret = drm_dp_dpcd_readb(&tc->aux, DP_MAIN_LINK_CHANNEL_CODING, &reg);\n\tif (ret < 0)\n\t\tgoto err_dpcd_read;\n\n\ttc->link.scrambler_dis = false;\n\t \n\tret = drm_dp_dpcd_readb(&tc->aux, DP_EDP_CONFIGURATION_SET, &reg);\n\tif (ret < 0)\n\t\tgoto err_dpcd_read;\n\ttc->link.assr = reg & DP_ALTERNATE_SCRAMBLER_RESET_ENABLE;\n\n\tdev_dbg(tc->dev, \"DPCD rev: %d.%d, rate: %s, lanes: %d, framing: %s\\n\",\n\t\trevision >> 4, revision & 0x0f,\n\t\t(tc->link.rate == 162000) ? \"1.62Gbps\" : \"2.7Gbps\",\n\t\ttc->link.num_lanes,\n\t\tdrm_dp_enhanced_frame_cap(tc->link.dpcd) ?\n\t\t\"enhanced\" : \"default\");\n\tdev_dbg(tc->dev, \"Downspread: %s, scrambler: %s\\n\",\n\t\ttc->link.spread ? \"0.5%\" : \"0.0%\",\n\t\ttc->link.scrambler_dis ? \"disabled\" : \"enabled\");\n\tdev_dbg(tc->dev, \"Display ASSR: %d, TC358767 ASSR: %d\\n\",\n\t\ttc->link.assr, tc->assr);\n\n\treturn 0;\n\nerr_dpcd_read:\n\tdev_err(tc->dev, \"failed to read DPCD: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tc_set_common_video_mode(struct tc_data *tc,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tint left_margin = mode->htotal - mode->hsync_end;\n\tint right_margin = mode->hsync_start - mode->hdisplay;\n\tint hsync_len = mode->hsync_end - mode->hsync_start;\n\tint upper_margin = mode->vtotal - mode->vsync_end;\n\tint lower_margin = mode->vsync_start - mode->vdisplay;\n\tint vsync_len = mode->vsync_end - mode->vsync_start;\n\tint ret;\n\n\tdev_dbg(tc->dev, \"set mode %dx%d\\n\",\n\t\tmode->hdisplay, mode->vdisplay);\n\tdev_dbg(tc->dev, \"H margin %d,%d sync %d\\n\",\n\t\tleft_margin, right_margin, hsync_len);\n\tdev_dbg(tc->dev, \"V margin %d,%d sync %d\\n\",\n\t\tupper_margin, lower_margin, vsync_len);\n\tdev_dbg(tc->dev, \"total: %dx%d\\n\", mode->htotal, mode->vtotal);\n\n\n\t \n\tret = regmap_write(tc->regmap, VPCTRL0,\n\t\t\t   FIELD_PREP(VSDELAY, right_margin + 10) |\n\t\t\t   OPXLFMT_RGB888 | FRMSYNC_DISABLED | MSF_DISABLED);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, HTIM01,\n\t\t\t   FIELD_PREP(HBPR, ALIGN(left_margin, 2)) |\n\t\t\t   FIELD_PREP(HPW, ALIGN(hsync_len, 2)));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, HTIM02,\n\t\t\t   FIELD_PREP(HDISPR, ALIGN(mode->hdisplay, 2)) |\n\t\t\t   FIELD_PREP(HFPR, ALIGN(right_margin, 2)));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, VTIM01,\n\t\t\t   FIELD_PREP(VBPR, upper_margin) |\n\t\t\t   FIELD_PREP(VSPR, vsync_len));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, VTIM02,\n\t\t\t   FIELD_PREP(VFPR, lower_margin) |\n\t\t\t   FIELD_PREP(VDISPR, mode->vdisplay));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, VFUEN0, VFUEN);  \n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(tc->regmap, TSTCTL,\n\t\t\t   FIELD_PREP(COLOR_R, 120) |\n\t\t\t   FIELD_PREP(COLOR_G, 20) |\n\t\t\t   FIELD_PREP(COLOR_B, 99) |\n\t\t\t   ENI2CFILTER |\n\t\t\t   FIELD_PREP(COLOR_BAR_MODE, COLOR_BAR_MODE_BARS));\n\n\treturn ret;\n}\n\nstatic int tc_set_dpi_video_mode(struct tc_data *tc,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tu32 value = POCTRL_S2P;\n\n\tif (tc->mode.flags & DRM_MODE_FLAG_NHSYNC)\n\t\tvalue |= POCTRL_HS_POL;\n\n\tif (tc->mode.flags & DRM_MODE_FLAG_NVSYNC)\n\t\tvalue |= POCTRL_VS_POL;\n\n\treturn regmap_write(tc->regmap, POCTRL, value);\n}\n\nstatic int tc_set_edp_video_mode(struct tc_data *tc,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tint ret;\n\tint vid_sync_dly;\n\tint max_tu_symbol;\n\n\tint left_margin = mode->htotal - mode->hsync_end;\n\tint hsync_len = mode->hsync_end - mode->hsync_start;\n\tint upper_margin = mode->vtotal - mode->vsync_end;\n\tint vsync_len = mode->vsync_end - mode->vsync_start;\n\tu32 dp0_syncval;\n\tu32 bits_per_pixel = 24;\n\tu32 in_bw, out_bw;\n\tu32 dpipxlfmt;\n\n\t \n\n\tin_bw = mode->clock * bits_per_pixel / 8;\n\tout_bw = tc->link.num_lanes * tc->link.rate;\n\tmax_tu_symbol = DIV_ROUND_UP(in_bw * TU_SIZE_RECOMMENDED, out_bw);\n\n\t \n\tvid_sync_dly = hsync_len + left_margin + mode->hdisplay;\n\tret = regmap_write(tc->regmap, DP0_VIDSYNCDELAY,\n\t\t FIELD_PREP(THRESH_DLY, max_tu_symbol) |\n\t\t FIELD_PREP(VID_SYNC_DLY, vid_sync_dly));\n\n\tret = regmap_write(tc->regmap, DP0_TOTALVAL,\n\t\t\t   FIELD_PREP(H_TOTAL, mode->htotal) |\n\t\t\t   FIELD_PREP(V_TOTAL, mode->vtotal));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0_STARTVAL,\n\t\t\t   FIELD_PREP(H_START, left_margin + hsync_len) |\n\t\t\t   FIELD_PREP(V_START, upper_margin + vsync_len));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0_ACTIVEVAL,\n\t\t\t   FIELD_PREP(V_ACT, mode->vdisplay) |\n\t\t\t   FIELD_PREP(H_ACT, mode->hdisplay));\n\tif (ret)\n\t\treturn ret;\n\n\tdp0_syncval = FIELD_PREP(VS_WIDTH, vsync_len) |\n\t\t      FIELD_PREP(HS_WIDTH, hsync_len);\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tdp0_syncval |= SYNCVAL_VS_POL_ACTIVE_LOW;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tdp0_syncval |= SYNCVAL_HS_POL_ACTIVE_LOW;\n\n\tret = regmap_write(tc->regmap, DP0_SYNCVAL, dp0_syncval);\n\tif (ret)\n\t\treturn ret;\n\n\tdpipxlfmt = DE_POL_ACTIVE_HIGH | SUB_CFG_TYPE_CONFIG1 | DPI_BPP_RGB888;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tdpipxlfmt |= VS_POL_ACTIVE_LOW;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tdpipxlfmt |= HS_POL_ACTIVE_LOW;\n\n\tret = regmap_write(tc->regmap, DPIPXLFMT, dpipxlfmt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0_MISC,\n\t\t\t   FIELD_PREP(MAX_TU_SYMBOL, max_tu_symbol) |\n\t\t\t   FIELD_PREP(TU_SIZE, TU_SIZE_RECOMMENDED) |\n\t\t\t   BPC_8);\n\treturn ret;\n}\n\nstatic int tc_wait_link_training(struct tc_data *tc)\n{\n\tu32 value;\n\tint ret;\n\n\tret = tc_poll_timeout(tc, DP0_LTSTAT, LT_LOOPDONE,\n\t\t\t      LT_LOOPDONE, 500, 100000);\n\tif (ret) {\n\t\tdev_err(tc->dev, \"Link training timeout waiting for LT_LOOPDONE!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(tc->regmap, DP0_LTSTAT, &value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (value >> 8) & 0x7;\n}\n\nstatic int tc_main_link_enable(struct tc_data *tc)\n{\n\tstruct drm_dp_aux *aux = &tc->aux;\n\tstruct device *dev = tc->dev;\n\tu32 dp_phy_ctrl;\n\tu32 value;\n\tint ret;\n\tu8 tmp[DP_LINK_STATUS_SIZE];\n\n\tdev_dbg(tc->dev, \"link enable\\n\");\n\n\tret = regmap_read(tc->regmap, DP0CTL, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (WARN_ON(value & DP_EN)) {\n\t\tret = regmap_write(tc->regmap, DP0CTL, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_write(tc->regmap, DP0_SRCCTRL, tc_srcctrl(tc));\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = regmap_write(tc->regmap, DP1_SRCCTRL,\n\t\t (tc->link.spread ? DP0_SRCCTRL_SSCG : 0) |\n\t\t ((tc->link.rate != 162000) ? DP0_SRCCTRL_BW27 : 0));\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_set_syspllparam(tc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdp_phy_ctrl = BGREN | PWR_SW_EN | PHY_A0_EN | PHY_M0_EN;\n\tif (tc->link.num_lanes == 2)\n\t\tdp_phy_ctrl |= PHY_2LANE;\n\n\tret = regmap_write(tc->regmap, DP_PHY_CTRL, dp_phy_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = tc_pllupdate(tc, DP0_PLLCTRL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_pllupdate(tc, DP1_PLLCTRL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdp_phy_ctrl |= DP_PHY_RST | PHY_M1_RST | PHY_M0_RST;\n\tret = regmap_write(tc->regmap, DP_PHY_CTRL, dp_phy_ctrl);\n\tusleep_range(100, 200);\n\tdp_phy_ctrl &= ~(DP_PHY_RST | PHY_M1_RST | PHY_M0_RST);\n\tret = regmap_write(tc->regmap, DP_PHY_CTRL, dp_phy_ctrl);\n\n\tret = tc_poll_timeout(tc, DP_PHY_CTRL, PHY_RDY, PHY_RDY, 500, 100000);\n\tif (ret) {\n\t\tdev_err(dev, \"timeout waiting for phy become ready\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(tc->regmap, DP0_MISC, BPC_8, BPC_8);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (tc->assr != tc->link.assr) {\n\t\tdev_dbg(dev, \"Trying to set display to ASSR: %d\\n\",\n\t\t\ttc->assr);\n\t\t \n\t\ttmp[0] = tc->assr;\n\t\tret = drm_dp_dpcd_writeb(aux, DP_EDP_CONFIGURATION_SET, tmp[0]);\n\t\tif (ret < 0)\n\t\t\tgoto err_dpcd_read;\n\t\t \n\t\tret = drm_dp_dpcd_readb(aux, DP_EDP_CONFIGURATION_SET, tmp);\n\t\tif (ret < 0)\n\t\t\tgoto err_dpcd_read;\n\n\t\tif (tmp[0] != tc->assr) {\n\t\t\tdev_dbg(dev, \"Failed to switch display ASSR to %d, falling back to unscrambled mode\\n\",\n\t\t\t\ttc->assr);\n\t\t\t \n\t\t\ttc->link.scrambler_dis = true;\n\t\t}\n\t}\n\n\t \n\ttmp[0] = drm_dp_link_rate_to_bw_code(tc->link.rate);\n\ttmp[1] = tc->link.num_lanes;\n\n\tif (drm_dp_enhanced_frame_cap(tc->link.dpcd))\n\t\ttmp[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\tret = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, tmp, 2);\n\tif (ret < 0)\n\t\tgoto err_dpcd_write;\n\n\t \n\ttmp[0] = tc->link.spread ? DP_SPREAD_AMP_0_5 : 0x00;\n\t \n\ttmp[1] =  DP_SET_ANSI_8B10B;\n\tret = drm_dp_dpcd_write(aux, DP_DOWNSPREAD_CTRL, tmp, 2);\n\tif (ret < 0)\n\t\tgoto err_dpcd_write;\n\n\t \n\ttmp[0] = tmp[1] = DP_TRAIN_VOLTAGE_SWING_LEVEL_0 |\n\t\t\t  DP_TRAIN_PRE_EMPH_LEVEL_0;\n\tret = drm_dp_dpcd_write(aux, DP_TRAINING_LANE0_SET, tmp, 2);\n\tif (ret < 0)\n\t\tgoto err_dpcd_write;\n\n\t \n\n\t \n\tret = regmap_write(tc->regmap, DP0_SNKLTCTRL,\n\t\t\t   DP_LINK_SCRAMBLING_DISABLE |\n\t\t\t   DP_TRAINING_PATTERN_1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0_LTLOOPCTRL,\n\t\t\t   (15 << 28) |\t \n\t\t\t   (15 << 24) |\t \n\t\t\t   (0xd << 0));\t \n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0_SRCCTRL,\n\t\t\t   tc_srcctrl(tc) | DP0_SRCCTRL_SCRMBLDIS |\n\t\t\t   DP0_SRCCTRL_AUTOCORRECT |\n\t\t\t   DP0_SRCCTRL_TP1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(tc->regmap, DP0CTL,\n\t\t\t   (drm_dp_enhanced_frame_cap(tc->link.dpcd) ?\n\t\t\t\tEF_EN : 0) | DP_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = tc_wait_link_training(tc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret) {\n\t\tdev_err(tc->dev, \"Link training phase 1 failed: %s\\n\",\n\t\t\ttraining_pattern1_errors[ret]);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tret = regmap_write(tc->regmap, DP0_SNKLTCTRL,\n\t\t\t   DP_LINK_SCRAMBLING_DISABLE |\n\t\t\t   DP_TRAINING_PATTERN_2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0_SRCCTRL,\n\t\t\t   tc_srcctrl(tc) | DP0_SRCCTRL_SCRMBLDIS |\n\t\t\t   DP0_SRCCTRL_AUTOCORRECT |\n\t\t\t   DP0_SRCCTRL_TP2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = tc_wait_link_training(tc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret) {\n\t\tdev_err(tc->dev, \"Link training phase 2 failed: %s\\n\",\n\t\t\ttraining_pattern2_errors[ret]);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tret = regmap_write(tc->regmap, DP0_SRCCTRL, tc_srcctrl(tc) |\n\t\t\t   DP0_SRCCTRL_AUTOCORRECT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t \n\ttmp[0] = tc->link.scrambler_dis ? DP_LINK_SCRAMBLING_DISABLE : 0x00;\n\tret = drm_dp_dpcd_writeb(aux, DP_TRAINING_PATTERN_SET, tmp[0]);\n\tif (ret < 0)\n\t\tgoto err_dpcd_write;\n\n\t \n\tret = drm_dp_dpcd_read_link_status(aux, tmp);\n\tif (ret < 0)\n\t\tgoto err_dpcd_read;\n\n\tret = 0;\n\n\tvalue = tmp[0] & DP_CHANNEL_EQ_BITS;\n\n\tif (value != DP_CHANNEL_EQ_BITS) {\n\t\tdev_err(tc->dev, \"Lane 0 failed: %x\\n\", value);\n\t\tret = -ENODEV;\n\t}\n\n\tif (tc->link.num_lanes == 2) {\n\t\tvalue = (tmp[0] >> 4) & DP_CHANNEL_EQ_BITS;\n\n\t\tif (value != DP_CHANNEL_EQ_BITS) {\n\t\t\tdev_err(tc->dev, \"Lane 1 failed: %x\\n\", value);\n\t\t\tret = -ENODEV;\n\t\t}\n\n\t\tif (!(tmp[2] & DP_INTERLANE_ALIGN_DONE)) {\n\t\t\tdev_err(tc->dev, \"Interlane align failed\\n\");\n\t\t\tret = -ENODEV;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"0x0202 LANE0_1_STATUS:            0x%02x\\n\", tmp[0]);\n\t\tdev_err(dev, \"0x0203 LANE2_3_STATUS             0x%02x\\n\", tmp[1]);\n\t\tdev_err(dev, \"0x0204 LANE_ALIGN_STATUS_UPDATED: 0x%02x\\n\", tmp[2]);\n\t\tdev_err(dev, \"0x0205 SINK_STATUS:               0x%02x\\n\", tmp[3]);\n\t\tdev_err(dev, \"0x0206 ADJUST_REQUEST_LANE0_1:    0x%02x\\n\", tmp[4]);\n\t\tdev_err(dev, \"0x0207 ADJUST_REQUEST_LANE2_3:    0x%02x\\n\", tmp[5]);\n\t\treturn ret;\n\t}\n\n\treturn 0;\nerr_dpcd_read:\n\tdev_err(tc->dev, \"Failed to read DPCD: %d\\n\", ret);\n\treturn ret;\nerr_dpcd_write:\n\tdev_err(tc->dev, \"Failed to write DPCD: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tc_main_link_disable(struct tc_data *tc)\n{\n\tint ret;\n\n\tdev_dbg(tc->dev, \"link disable\\n\");\n\n\tret = regmap_write(tc->regmap, DP0_SRCCTRL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(tc->regmap, DP0CTL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(tc->regmap, DP_PHY_CTRL,\n\t\t\t\t  PHY_M0_RST | PHY_M1_RST | PHY_M0_EN,\n\t\t\t\t  PHY_M0_RST | PHY_M1_RST);\n}\n\nstatic int tc_dsi_rx_enable(struct tc_data *tc)\n{\n\tu32 value;\n\tint ret;\n\n\tregmap_write(tc->regmap, PPI_D0S_CLRSIPOCOUNT, 25);\n\tregmap_write(tc->regmap, PPI_D1S_CLRSIPOCOUNT, 25);\n\tregmap_write(tc->regmap, PPI_D2S_CLRSIPOCOUNT, 25);\n\tregmap_write(tc->regmap, PPI_D3S_CLRSIPOCOUNT, 25);\n\tregmap_write(tc->regmap, PPI_D0S_ATMR, 0);\n\tregmap_write(tc->regmap, PPI_D1S_ATMR, 0);\n\tregmap_write(tc->regmap, PPI_TX_RX_TA, TTA_GET | TTA_SURE);\n\tregmap_write(tc->regmap, PPI_LPTXTIMECNT, LPX_PERIOD);\n\n\tvalue = ((LANEENABLE_L0EN << tc->dsi->lanes) - LANEENABLE_L0EN) |\n\t\tLANEENABLE_CLEN;\n\tregmap_write(tc->regmap, PPI_LANEENABLE, value);\n\tregmap_write(tc->regmap, DSI_LANEENABLE, value);\n\n\t \n\tvalue = DP0_AUDSRC_NO_INPUT;\n\tif (tc_test_pattern)\n\t\tvalue |= DP0_VIDSRC_COLOR_BAR;\n\telse\n\t\tvalue |= DP0_VIDSRC_DSI_RX;\n\tret = regmap_write(tc->regmap, SYSCTRL, value);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(120, 150);\n\n\tregmap_write(tc->regmap, PPI_STARTPPI, PPI_START_FUNCTION);\n\tregmap_write(tc->regmap, DSI_STARTDSI, DSI_RX_START);\n\n\treturn 0;\n}\n\nstatic int tc_dpi_rx_enable(struct tc_data *tc)\n{\n\tu32 value;\n\n\t \n\tvalue = DP0_AUDSRC_NO_INPUT;\n\tif (tc_test_pattern)\n\t\tvalue |= DP0_VIDSRC_COLOR_BAR;\n\telse\n\t\tvalue |= DP0_VIDSRC_DPI_RX;\n\treturn regmap_write(tc->regmap, SYSCTRL, value);\n}\n\nstatic int tc_dpi_stream_enable(struct tc_data *tc)\n{\n\tint ret;\n\n\tdev_dbg(tc->dev, \"enable video stream\\n\");\n\n\t \n\tret = tc_set_syspllparam(tc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = tc_pllupdate(tc, DP0_PLLCTRL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_pllupdate(tc, DP1_PLLCTRL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = tc_pxl_pll_en(tc, clk_get_rate(tc->refclk),\n\t\t\t    1000 * tc->mode.clock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_set_common_video_mode(tc, &tc->mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_set_dpi_video_mode(tc, &tc->mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tc_dsi_rx_enable(tc);\n}\n\nstatic int tc_dpi_stream_disable(struct tc_data *tc)\n{\n\tdev_dbg(tc->dev, \"disable video stream\\n\");\n\n\ttc_pxl_pll_dis(tc);\n\n\treturn 0;\n}\n\nstatic int tc_edp_stream_enable(struct tc_data *tc)\n{\n\tint ret;\n\tu32 value;\n\n\tdev_dbg(tc->dev, \"enable video stream\\n\");\n\n\t \n\tif (tc->input_connector_dsi || tc_test_pattern) {\n\t\tret = tc_pxl_pll_en(tc, clk_get_rate(tc->refclk),\n\t\t\t\t    1000 * tc->mode.clock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = tc_set_common_video_mode(tc, &tc->mode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tc_set_edp_video_mode(tc, &tc->mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = tc_stream_clock_calc(tc);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue = VID_MN_GEN | DP_EN;\n\tif (drm_dp_enhanced_frame_cap(tc->link.dpcd))\n\t\tvalue |= EF_EN;\n\tret = regmap_write(tc->regmap, DP0CTL, value);\n\tif (ret)\n\t\treturn ret;\n\t \n\tusleep_range(500, 1000);\n\tvalue |= VID_EN;\n\tret = regmap_write(tc->regmap, DP0CTL, value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (tc->input_connector_dsi)\n\t\treturn tc_dsi_rx_enable(tc);\n\telse\n\t\treturn tc_dpi_rx_enable(tc);\n}\n\nstatic int tc_edp_stream_disable(struct tc_data *tc)\n{\n\tint ret;\n\n\tdev_dbg(tc->dev, \"disable video stream\\n\");\n\n\tret = regmap_update_bits(tc->regmap, DP0CTL, VID_EN, 0);\n\tif (ret)\n\t\treturn ret;\n\n\ttc_pxl_pll_dis(tc);\n\n\treturn 0;\n}\n\nstatic void\ntc_dpi_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t    struct drm_bridge_state *old_bridge_state)\n\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tint ret;\n\n\tret = tc_dpi_stream_enable(tc);\n\tif (ret < 0) {\n\t\tdev_err(tc->dev, \"main link stream start error: %d\\n\", ret);\n\t\ttc_main_link_disable(tc);\n\t\treturn;\n\t}\n}\n\nstatic void\ntc_dpi_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tint ret;\n\n\tret = tc_dpi_stream_disable(tc);\n\tif (ret < 0)\n\t\tdev_err(tc->dev, \"main link stream stop error: %d\\n\", ret);\n}\n\nstatic void\ntc_edp_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t    struct drm_bridge_state *old_bridge_state)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tint ret;\n\n\tret = tc_get_display_props(tc);\n\tif (ret < 0) {\n\t\tdev_err(tc->dev, \"failed to read display props: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = tc_main_link_enable(tc);\n\tif (ret < 0) {\n\t\tdev_err(tc->dev, \"main link enable error: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = tc_edp_stream_enable(tc);\n\tif (ret < 0) {\n\t\tdev_err(tc->dev, \"main link stream start error: %d\\n\", ret);\n\t\ttc_main_link_disable(tc);\n\t\treturn;\n\t}\n}\n\nstatic void\ntc_edp_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tint ret;\n\n\tret = tc_edp_stream_disable(tc);\n\tif (ret < 0)\n\t\tdev_err(tc->dev, \"main link stream stop error: %d\\n\", ret);\n\n\tret = tc_main_link_disable(tc);\n\tif (ret < 0)\n\t\tdev_err(tc->dev, \"main link disable error: %d\\n\", ret);\n}\n\nstatic int tc_dpi_atomic_check(struct drm_bridge *bridge,\n\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\t \n\tif (crtc_state->adjusted_mode.clock > 100000)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int tc_edp_atomic_check(struct drm_bridge *bridge,\n\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\t \n\tif (crtc_state->adjusted_mode.clock > 154000)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\ntc_dpi_mode_valid(struct drm_bridge *bridge,\n\t\t  const struct drm_display_info *info,\n\t\t  const struct drm_display_mode *mode)\n{\n\t \n\tif (mode->clock > 100000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_mode_status\ntc_edp_mode_valid(struct drm_bridge *bridge,\n\t\t  const struct drm_display_info *info,\n\t\t  const struct drm_display_mode *mode)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tu32 req, avail;\n\tu32 bits_per_pixel = 24;\n\n\t \n\tif (mode->clock > 154000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treq = mode->clock * bits_per_pixel / 8;\n\tavail = tc->link.num_lanes * tc->link.rate;\n\n\tif (req > avail)\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\nstatic void tc_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       const struct drm_display_mode *adj)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\n\tdrm_mode_copy(&tc->mode, mode);\n}\n\nstatic struct edid *tc_get_edid(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\n\treturn drm_get_edid(connector, &tc->aux.ddc);\n}\n\nstatic int tc_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct tc_data *tc = connector_to_tc(connector);\n\tint num_modes;\n\tstruct edid *edid;\n\tint ret;\n\n\tret = tc_get_display_props(tc);\n\tif (ret < 0) {\n\t\tdev_err(tc->dev, \"failed to read display props: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tif (tc->panel_bridge) {\n\t\tnum_modes = drm_bridge_get_modes(tc->panel_bridge, connector);\n\t\tif (num_modes > 0)\n\t\t\treturn num_modes;\n\t}\n\n\tedid = tc_get_edid(&tc->bridge, connector);\n\tnum_modes = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn num_modes;\n}\n\nstatic const struct drm_connector_helper_funcs tc_connector_helper_funcs = {\n\t.get_modes = tc_connector_get_modes,\n};\n\nstatic enum drm_connector_status tc_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tbool conn;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(tc->regmap, GPIOI, &val);\n\tif (ret)\n\t\treturn connector_status_unknown;\n\n\tconn = val & BIT(tc->hpd_pin);\n\n\tif (conn)\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic enum drm_connector_status\ntc_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct tc_data *tc = connector_to_tc(connector);\n\n\tif (tc->hpd_pin >= 0)\n\t\treturn tc_bridge_detect(&tc->bridge);\n\n\tif (tc->panel_bridge)\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_unknown;\n}\n\nstatic const struct drm_connector_funcs tc_connector_funcs = {\n\t.detect = tc_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int tc_dpi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\n\tif (!tc->panel_bridge)\n\t\treturn 0;\n\n\treturn drm_bridge_attach(tc->bridge.encoder, tc->panel_bridge,\n\t\t\t\t &tc->bridge, flags);\n}\n\nstatic int tc_edp_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tu32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\tstruct tc_data *tc = bridge_to_tc(bridge);\n\tstruct drm_device *drm = bridge->dev;\n\tint ret;\n\n\tif (tc->panel_bridge) {\n\t\t \n\t\tret = drm_bridge_attach(tc->bridge.encoder, tc->panel_bridge,\n\t\t\t\t\t&tc->bridge, flags | DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\ttc->aux.drm_dev = drm;\n\tret = drm_dp_aux_register(&tc->aux);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdrm_connector_helper_add(&tc->connector, &tc_connector_helper_funcs);\n\tret = drm_connector_init(drm, &tc->connector, &tc_connector_funcs, tc->bridge.type);\n\tif (ret)\n\t\tgoto aux_unregister;\n\n\t \n\tif (tc->hpd_pin >= 0) {\n\t\tif (tc->have_irq)\n\t\t\ttc->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\t\telse\n\t\t\ttc->connector.polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\t\t       DRM_CONNECTOR_POLL_DISCONNECT;\n\t}\n\n\tdrm_display_info_set_bus_formats(&tc->connector.display_info,\n\t\t\t\t\t &bus_format, 1);\n\ttc->connector.display_info.bus_flags =\n\t\tDRM_BUS_FLAG_DE_HIGH |\n\t\tDRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE |\n\t\tDRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE;\n\tdrm_connector_attach_encoder(&tc->connector, tc->bridge.encoder);\n\n\treturn 0;\naux_unregister:\n\tdrm_dp_aux_unregister(&tc->aux);\n\treturn ret;\n}\n\nstatic void tc_edp_bridge_detach(struct drm_bridge *bridge)\n{\n\tdrm_dp_aux_unregister(&bridge_to_tc(bridge)->aux);\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\ntc_dpi_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t u32 output_fmt,\n\t\t\t\t unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t \n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs tc_dpi_bridge_funcs = {\n\t.attach = tc_dpi_bridge_attach,\n\t.mode_valid = tc_dpi_mode_valid,\n\t.mode_set = tc_bridge_mode_set,\n\t.atomic_check = tc_dpi_atomic_check,\n\t.atomic_enable = tc_dpi_bridge_atomic_enable,\n\t.atomic_disable = tc_dpi_bridge_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_get_input_bus_fmts = tc_dpi_atomic_get_input_bus_fmts,\n};\n\nstatic const struct drm_bridge_funcs tc_edp_bridge_funcs = {\n\t.attach = tc_edp_bridge_attach,\n\t.detach = tc_edp_bridge_detach,\n\t.mode_valid = tc_edp_mode_valid,\n\t.mode_set = tc_bridge_mode_set,\n\t.atomic_check = tc_edp_atomic_check,\n\t.atomic_enable = tc_edp_bridge_atomic_enable,\n\t.atomic_disable = tc_edp_bridge_atomic_disable,\n\t.detect = tc_bridge_detect,\n\t.get_edid = tc_get_edid,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nstatic bool tc_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\t \n\tcase 0x004:\n\tcase 0x020:\n\tcase 0x024:\n\tcase 0x028:\n\tcase 0x02c:\n\tcase 0x030:\n\tcase 0x038:\n\tcase 0x040:\n\tcase 0x044:\n\tcase 0x048:\n\tcase 0x04c:\n\tcase 0x050:\n\tcase 0x054:\n\t \n\tcase PPI_STARTPPI:\n\tcase 0x108:\n\tcase 0x110:\n\tcase PPI_LPTXTIMECNT:\n\tcase PPI_LANEENABLE:\n\tcase PPI_TX_RX_TA:\n\tcase 0x140:\n\tcase PPI_D0S_ATMR:\n\tcase PPI_D1S_ATMR:\n\tcase 0x14c:\n\tcase 0x150:\n\tcase PPI_D0S_CLRSIPOCOUNT:\n\tcase PPI_D1S_CLRSIPOCOUNT:\n\tcase PPI_D2S_CLRSIPOCOUNT:\n\tcase PPI_D3S_CLRSIPOCOUNT:\n\tcase 0x180:\n\tcase 0x184:\n\tcase 0x188:\n\tcase 0x18c:\n\tcase 0x190:\n\tcase 0x1a0:\n\tcase 0x1a4:\n\tcase 0x1a8:\n\tcase 0x1ac:\n\tcase 0x1b0:\n\tcase 0x1c0:\n\tcase 0x1c4:\n\tcase 0x1c8:\n\tcase 0x1cc:\n\tcase 0x1d0:\n\tcase 0x1e0:\n\tcase 0x1e4:\n\tcase 0x1f0:\n\tcase 0x1f4:\n\t \n\tcase DSI_STARTDSI:\n\tcase 0x208:\n\tcase DSI_LANEENABLE:\n\tcase 0x214:\n\tcase 0x218:\n\tcase 0x220:\n\tcase 0x224:\n\tcase 0x228:\n\tcase 0x230:\n\t \n\tcase 0x300:\n\t \n\tcase 0x400:\n\tcase 0x404:\n\t \n\tcase DPIPXLFMT:\n\t \n\tcase POCTRL:\n\t \n\tcase VPCTRL0:\n\tcase HTIM01:\n\tcase HTIM02:\n\tcase VTIM01:\n\tcase VTIM02:\n\tcase VFUEN0:\n\t \n\tcase TC_IDREG:\n\tcase 0x504:\n\tcase SYSSTAT:\n\tcase SYSRSTENB:\n\tcase SYSCTRL:\n\t \n\tcase 0x520:\n\t \n\tcase GPIOM:\n\tcase GPIOC:\n\tcase GPIOO:\n\tcase GPIOI:\n\t \n\tcase INTCTL_G:\n\tcase INTSTS_G:\n\tcase 0x570:\n\tcase 0x574:\n\tcase INT_GP0_LCNT:\n\tcase INT_GP1_LCNT:\n\t \n\tcase DP0CTL:\n\t \n\tcase DP0_VIDMNGEN0:\n\tcase DP0_VIDMNGEN1:\n\tcase DP0_VMNGENSTATUS:\n\tcase 0x628:\n\tcase 0x62c:\n\tcase 0x630:\n\t \n\tcase DP0_SECSAMPLE:\n\tcase DP0_VIDSYNCDELAY:\n\tcase DP0_TOTALVAL:\n\tcase DP0_STARTVAL:\n\tcase DP0_ACTIVEVAL:\n\tcase DP0_SYNCVAL:\n\tcase DP0_MISC:\n\t \n\tcase DP0_AUXCFG0:\n\tcase DP0_AUXCFG1:\n\tcase DP0_AUXADDR:\n\tcase 0x66c:\n\tcase 0x670:\n\tcase 0x674:\n\tcase 0x678:\n\tcase 0x67c:\n\tcase 0x680:\n\tcase 0x684:\n\tcase 0x688:\n\tcase DP0_AUXSTATUS:\n\tcase DP0_AUXI2CADR:\n\t \n\tcase DP0_SRCCTRL:\n\tcase DP0_LTSTAT:\n\tcase DP0_SNKLTCHGREQ:\n\tcase DP0_LTLOOPCTRL:\n\tcase DP0_SNKLTCTRL:\n\tcase 0x6e8:\n\tcase 0x6ec:\n\tcase 0x6f0:\n\tcase 0x6f4:\n\t \n\tcase 0x700:\n\tcase 0x704:\n\tcase 0x708:\n\tcase 0x70c:\n\tcase 0x710:\n\tcase 0x714:\n\tcase 0x718:\n\tcase 0x71c:\n\tcase 0x720:\n\t \n\tcase DP1_SRCCTRL:\n\t \n\tcase DP_PHY_CTRL:\n\tcase 0x810:\n\tcase 0x814:\n\tcase 0x820:\n\tcase 0x840:\n\t \n\tcase 0x880:\n\tcase 0x888:\n\tcase 0x88c:\n\tcase 0x890:\n\tcase 0x894:\n\tcase 0x898:\n\tcase 0x89c:\n\tcase 0x8a0:\n\tcase 0x8a4:\n\tcase 0x8a8:\n\tcase 0x8ac:\n\tcase 0x8b0:\n\tcase 0x8b4:\n\t \n\tcase DP0_PLLCTRL:\n\tcase DP1_PLLCTRL:\n\tcase PXL_PLLCTRL:\n\tcase PXL_PLLPARAM:\n\tcase SYS_PLLPARAM:\n\t \n\tcase 0x980:\n\tcase 0x984:\n\tcase 0x988:\n\tcase 0x98c:\n\tcase 0x990:\n\tcase 0x994:\n\tcase 0x998:\n\tcase 0x99c:\n\tcase 0x9a0:\n\tcase 0x9a4:\n\tcase 0x9a8:\n\tcase 0x9ac:\n\t \n\tcase TSTCTL:\n\tcase PLL_DBG:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct regmap_range tc_volatile_ranges[] = {\n\tregmap_reg_range(DP0_AUXWDATA(0), DP0_AUXSTATUS),\n\tregmap_reg_range(DP0_LTSTAT, DP0_SNKLTCHGREQ),\n\tregmap_reg_range(DP_PHY_CTRL, DP_PHY_CTRL),\n\tregmap_reg_range(DP0_PLLCTRL, PXL_PLLCTRL),\n\tregmap_reg_range(VFUEN0, VFUEN0),\n\tregmap_reg_range(INTSTS_G, INTSTS_G),\n\tregmap_reg_range(GPIOI, GPIOI),\n};\n\nstatic const struct regmap_access_table tc_volatile_table = {\n\t.yes_ranges = tc_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(tc_volatile_ranges),\n};\n\nstatic bool tc_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg != TC_IDREG) &&\n\t       (reg != DP0_LTSTAT) &&\n\t       (reg != DP0_SNKLTCHGREQ);\n}\n\nstatic const struct regmap_config tc_regmap_config = {\n\t.name = \"tc358767\",\n\t.reg_bits = 16,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = PLL_DBG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.readable_reg = tc_readable_reg,\n\t.volatile_table = &tc_volatile_table,\n\t.writeable_reg = tc_writeable_reg,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_LITTLE,\n};\n\nstatic irqreturn_t tc_irq_handler(int irq, void *arg)\n{\n\tstruct tc_data *tc = arg;\n\tu32 val;\n\tint r;\n\n\tr = regmap_read(tc->regmap, INTSTS_G, &val);\n\tif (r)\n\t\treturn IRQ_NONE;\n\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif (val & INT_SYSERR) {\n\t\tu32 stat = 0;\n\n\t\tregmap_read(tc->regmap, SYSSTAT, &stat);\n\n\t\tdev_err(tc->dev, \"syserr %x\\n\", stat);\n\t}\n\n\tif (tc->hpd_pin >= 0 && tc->bridge.dev) {\n\t\t \n\t\tbool h = val & INT_GPIO_H(tc->hpd_pin);\n\t\tbool lc = val & INT_GPIO_LC(tc->hpd_pin);\n\n\t\tdev_dbg(tc->dev, \"GPIO%d: %s %s\\n\", tc->hpd_pin,\n\t\t\th ? \"H\" : \"\", lc ? \"LC\" : \"\");\n\n\t\tif (h || lc)\n\t\t\tdrm_kms_helper_hotplug_event(tc->bridge.dev);\n\t}\n\n\tregmap_write(tc->regmap, INTSTS_G, val);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tc_mipi_dsi_host_attach(struct tc_data *tc)\n{\n\tstruct device *dev = tc->dev;\n\tstruct device_node *host_node;\n\tstruct device_node *endpoint;\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tconst struct mipi_dsi_device_info info = {\n\t\t.type = \"tc358767\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\tint dsi_lanes, ret;\n\n\tendpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, -1);\n\tdsi_lanes = drm_of_get_data_lanes_count(endpoint, 1, 4);\n\thost_node = of_graph_get_remote_port_parent(endpoint);\n\thost = of_find_mipi_dsi_host_by_node(host_node);\n\tof_node_put(host_node);\n\tof_node_put(endpoint);\n\n\tif (!host)\n\t\treturn -EPROBE_DEFER;\n\n\tif (dsi_lanes < 0)\n\t\treturn dsi_lanes;\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi),\n\t\t\t\t     \"failed to create dsi device\\n\");\n\n\ttc->dsi = dsi;\n\tdsi->lanes = dsi_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_probe_dpi_bridge_endpoint(struct tc_data *tc)\n{\n\tstruct device *dev = tc->dev;\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\t \n\tret = drm_of_find_panel_or_bridge(dev->of_node, 1, 0, &panel, &bridge);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tif (panel) {\n\t\tbridge = devm_drm_panel_bridge_add(dev, panel);\n\t\tif (IS_ERR(bridge))\n\t\t\treturn PTR_ERR(bridge);\n\t}\n\n\tif (bridge) {\n\t\ttc->panel_bridge = bridge;\n\t\ttc->bridge.type = DRM_MODE_CONNECTOR_DPI;\n\t\ttc->bridge.funcs = &tc_dpi_bridge_funcs;\n\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int tc_probe_edp_bridge_endpoint(struct tc_data *tc)\n{\n\tstruct device *dev = tc->dev;\n\tstruct drm_panel *panel;\n\tint ret;\n\n\t \n\tret = drm_of_find_panel_or_bridge(dev->of_node, 2, 0, &panel, NULL);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tif (panel) {\n\t\tstruct drm_bridge *panel_bridge;\n\n\t\tpanel_bridge = devm_drm_panel_bridge_add(dev, panel);\n\t\tif (IS_ERR(panel_bridge))\n\t\t\treturn PTR_ERR(panel_bridge);\n\n\t\ttc->panel_bridge = panel_bridge;\n\t\ttc->bridge.type = DRM_MODE_CONNECTOR_eDP;\n\t} else {\n\t\ttc->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;\n\t}\n\n\ttc->bridge.funcs = &tc_edp_bridge_funcs;\n\tif (tc->hpd_pin >= 0)\n\t\ttc->bridge.ops |= DRM_BRIDGE_OP_DETECT;\n\ttc->bridge.ops |= DRM_BRIDGE_OP_EDID;\n\n\treturn 0;\n}\n\nstatic int tc_probe_bridge_endpoint(struct tc_data *tc)\n{\n\tstruct device *dev = tc->dev;\n\tstruct of_endpoint endpoint;\n\tstruct device_node *node = NULL;\n\tconst u8 mode_dpi_to_edp = BIT(1) | BIT(2);\n\tconst u8 mode_dpi_to_dp = BIT(1);\n\tconst u8 mode_dsi_to_edp = BIT(0) | BIT(2);\n\tconst u8 mode_dsi_to_dp = BIT(0);\n\tconst u8 mode_dsi_to_dpi = BIT(0) | BIT(1);\n\tu8 mode = 0;\n\n\t \n\n\tfor_each_endpoint_of_node(dev->of_node, node) {\n\t\tof_graph_parse_endpoint(node, &endpoint);\n\t\tif (endpoint.port > 2) {\n\t\t\tof_node_put(node);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmode |= BIT(endpoint.port);\n\t}\n\n\tif (mode == mode_dpi_to_edp || mode == mode_dpi_to_dp) {\n\t\ttc->input_connector_dsi = false;\n\t\treturn tc_probe_edp_bridge_endpoint(tc);\n\t} else if (mode == mode_dsi_to_dpi) {\n\t\ttc->input_connector_dsi = true;\n\t\treturn tc_probe_dpi_bridge_endpoint(tc);\n\t} else if (mode == mode_dsi_to_edp || mode == mode_dsi_to_dp) {\n\t\ttc->input_connector_dsi = true;\n\t\treturn tc_probe_edp_bridge_endpoint(tc);\n\t}\n\n\tdev_warn(dev, \"Invalid mode (0x%x) is not supported!\\n\", mode);\n\n\treturn -EINVAL;\n}\n\nstatic int tc_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tc_data *tc;\n\tint ret;\n\n\ttc = devm_kzalloc(dev, sizeof(*tc), GFP_KERNEL);\n\tif (!tc)\n\t\treturn -ENOMEM;\n\n\ttc->dev = dev;\n\n\tret = tc_probe_bridge_endpoint(tc);\n\tif (ret)\n\t\treturn ret;\n\n\ttc->refclk = devm_clk_get_enabled(dev, \"ref\");\n\tif (IS_ERR(tc->refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(tc->refclk),\n\t\t\t\t     \"Failed to get and enable the ref clk\\n\");\n\n\t \n\tusleep_range(10, 15);\n\n\t \n\ttc->sd_gpio = devm_gpiod_get_optional(dev, \"shutdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tc->sd_gpio))\n\t\treturn PTR_ERR(tc->sd_gpio);\n\n\tif (tc->sd_gpio) {\n\t\tgpiod_set_value_cansleep(tc->sd_gpio, 0);\n\t\tusleep_range(5000, 10000);\n\t}\n\n\t \n\ttc->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(tc->reset_gpio))\n\t\treturn PTR_ERR(tc->reset_gpio);\n\n\tif (tc->reset_gpio) {\n\t\tgpiod_set_value_cansleep(tc->reset_gpio, 1);\n\t\tusleep_range(5000, 10000);\n\t}\n\n\ttc->regmap = devm_regmap_init_i2c(client, &tc_regmap_config);\n\tif (IS_ERR(tc->regmap)) {\n\t\tret = PTR_ERR(tc->regmap);\n\t\tdev_err(dev, \"Failed to initialize regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"toshiba,hpd-pin\",\n\t\t\t\t   &tc->hpd_pin);\n\tif (ret) {\n\t\ttc->hpd_pin = -ENODEV;\n\t} else {\n\t\tif (tc->hpd_pin < 0 || tc->hpd_pin > 1) {\n\t\t\tdev_err(dev, \"failed to parse HPD number\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (client->irq > 0) {\n\t\t \n\t\tregmap_write(tc->regmap, INTCTL_G, INT_SYSERR);\n\n\t\tret = devm_request_threaded_irq(dev, client->irq,\n\t\t\t\t\t\tNULL, tc_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"tc358767-irq\", tc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to register dp interrupt\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\ttc->have_irq = true;\n\t}\n\n\tret = regmap_read(tc->regmap, TC_IDREG, &tc->rev);\n\tif (ret) {\n\t\tdev_err(tc->dev, \"can not read device ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif ((tc->rev != 0x6601) && (tc->rev != 0x6603)) {\n\t\tdev_err(tc->dev, \"invalid device ID: 0x%08x\\n\", tc->rev);\n\t\treturn -EINVAL;\n\t}\n\n\ttc->assr = (tc->rev == 0x6601);  \n\n\tif (!tc->reset_gpio) {\n\t\t \n\t\tregmap_update_bits(tc->regmap, SYSRSTENB,\n\t\t\t\tENBLCD0 | ENBBM | ENBDSIRX | ENBREG | ENBHDCP,\n\t\t\t\t0);\n\t\tregmap_update_bits(tc->regmap, SYSRSTENB,\n\t\t\t\tENBLCD0 | ENBBM | ENBDSIRX | ENBREG | ENBHDCP,\n\t\t\t\tENBLCD0 | ENBBM | ENBDSIRX | ENBREG | ENBHDCP);\n\t\tusleep_range(5000, 10000);\n\t}\n\n\tif (tc->hpd_pin >= 0) {\n\t\tu32 lcnt_reg = tc->hpd_pin == 0 ? INT_GP0_LCNT : INT_GP1_LCNT;\n\t\tu32 h_lc = INT_GPIO_H(tc->hpd_pin) | INT_GPIO_LC(tc->hpd_pin);\n\n\t\t \n\t\tregmap_write(tc->regmap, lcnt_reg,\n\t\t\t     clk_get_rate(tc->refclk) * 2 / 1000);\n\t\t \n\t\tregmap_write(tc->regmap, GPIOM, BIT(tc->hpd_pin));\n\n\t\tif (tc->have_irq) {\n\t\t\t \n\t\t\tregmap_update_bits(tc->regmap, INTCTL_G, h_lc, h_lc);\n\t\t}\n\t}\n\n\tif (tc->bridge.type != DRM_MODE_CONNECTOR_DPI) {  \n\t\tret = tc_aux_link_setup(tc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ttc->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&tc->bridge);\n\n\ti2c_set_clientdata(client, tc);\n\n\tif (tc->input_connector_dsi) {\t\t\t \n\t\tret = tc_mipi_dsi_host_attach(tc);\n\t\tif (ret) {\n\t\t\tdrm_bridge_remove(&tc->bridge);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tc_remove(struct i2c_client *client)\n{\n\tstruct tc_data *tc = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&tc->bridge);\n}\n\nstatic const struct i2c_device_id tc358767_i2c_ids[] = {\n\t{ \"tc358767\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tc358767_i2c_ids);\n\nstatic const struct of_device_id tc358767_of_ids[] = {\n\t{ .compatible = \"toshiba,tc358767\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tc358767_of_ids);\n\nstatic struct i2c_driver tc358767_driver = {\n\t.driver = {\n\t\t.name = \"tc358767\",\n\t\t.of_match_table = tc358767_of_ids,\n\t},\n\t.id_table = tc358767_i2c_ids,\n\t.probe = tc_probe,\n\t.remove\t= tc_remove,\n};\nmodule_i2c_driver(tc358767_driver);\n\nMODULE_AUTHOR(\"Andrey Gusakov <andrey.gusakov@cogentembedded.com>\");\nMODULE_DESCRIPTION(\"tc358767 eDP encoder driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}