{
  "module_name": "ti-sn65dsi83.c",
  "hash_id": "10c0529a45258f4e37f276154d87a9591eb98e437354af4fbfee4bbd904722f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ti-sn65dsi83.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n \n#define REG_ID(n)\t\t\t\t(0x00 + (n))\n \n#define REG_RC_RESET\t\t\t\t0x09\n#define  REG_RC_RESET_SOFT_RESET\t\tBIT(0)\n#define REG_RC_LVDS_PLL\t\t\t\t0x0a\n#define  REG_RC_LVDS_PLL_PLL_EN_STAT\t\tBIT(7)\n#define  REG_RC_LVDS_PLL_LVDS_CLK_RANGE(n)\t(((n) & 0x7) << 1)\n#define  REG_RC_LVDS_PLL_HS_CLK_SRC_DPHY\tBIT(0)\n#define REG_RC_DSI_CLK\t\t\t\t0x0b\n#define  REG_RC_DSI_CLK_DSI_CLK_DIVIDER(n)\t(((n) & 0x1f) << 3)\n#define  REG_RC_DSI_CLK_REFCLK_MULTIPLIER(n)\t((n) & 0x3)\n#define REG_RC_PLL_EN\t\t\t\t0x0d\n#define  REG_RC_PLL_EN_PLL_EN\t\t\tBIT(0)\n \n#define REG_DSI_LANE\t\t\t\t0x10\n#define  REG_DSI_LANE_LEFT_RIGHT_PIXELS\t\tBIT(7)\t \n#define  REG_DSI_LANE_DSI_CHANNEL_MODE_DUAL\t0\t \n#define  REG_DSI_LANE_DSI_CHANNEL_MODE_2SINGLE\tBIT(6)\t \n#define  REG_DSI_LANE_DSI_CHANNEL_MODE_SINGLE\tBIT(5)\n#define  REG_DSI_LANE_CHA_DSI_LANES(n)\t\t(((n) & 0x3) << 3)\n#define  REG_DSI_LANE_CHB_DSI_LANES(n)\t\t(((n) & 0x3) << 1)\n#define  REG_DSI_LANE_SOT_ERR_TOL_DIS\t\tBIT(0)\n#define REG_DSI_EQ\t\t\t\t0x11\n#define  REG_DSI_EQ_CHA_DSI_DATA_EQ(n)\t\t(((n) & 0x3) << 6)\n#define  REG_DSI_EQ_CHA_DSI_CLK_EQ(n)\t\t(((n) & 0x3) << 2)\n#define REG_DSI_CLK\t\t\t\t0x12\n#define  REG_DSI_CLK_CHA_DSI_CLK_RANGE(n)\t((n) & 0xff)\n \n#define REG_LVDS_FMT\t\t\t\t0x18\n#define  REG_LVDS_FMT_DE_NEG_POLARITY\t\tBIT(7)\n#define  REG_LVDS_FMT_HS_NEG_POLARITY\t\tBIT(6)\n#define  REG_LVDS_FMT_VS_NEG_POLARITY\t\tBIT(5)\n#define  REG_LVDS_FMT_LVDS_LINK_CFG\t\tBIT(4)\t \n#define  REG_LVDS_FMT_CHA_24BPP_MODE\t\tBIT(3)\n#define  REG_LVDS_FMT_CHB_24BPP_MODE\t\tBIT(2)\n#define  REG_LVDS_FMT_CHA_24BPP_FORMAT1\t\tBIT(1)\n#define  REG_LVDS_FMT_CHB_24BPP_FORMAT1\t\tBIT(0)\n#define REG_LVDS_VCOM\t\t\t\t0x19\n#define  REG_LVDS_VCOM_CHA_LVDS_VOCM\t\tBIT(6)\n#define  REG_LVDS_VCOM_CHB_LVDS_VOCM\t\tBIT(4)\n#define  REG_LVDS_VCOM_CHA_LVDS_VOD_SWING(n)\t(((n) & 0x3) << 2)\n#define  REG_LVDS_VCOM_CHB_LVDS_VOD_SWING(n)\t((n) & 0x3)\n#define REG_LVDS_LANE\t\t\t\t0x1a\n#define  REG_LVDS_LANE_EVEN_ODD_SWAP\t\tBIT(6)\n#define  REG_LVDS_LANE_CHA_REVERSE_LVDS\t\tBIT(5)\n#define  REG_LVDS_LANE_CHB_REVERSE_LVDS\t\tBIT(4)\n#define  REG_LVDS_LANE_CHA_LVDS_TERM\t\tBIT(1)\n#define  REG_LVDS_LANE_CHB_LVDS_TERM\t\tBIT(0)\n#define REG_LVDS_CM\t\t\t\t0x1b\n#define  REG_LVDS_CM_CHA_LVDS_CM_ADJUST(n)\t(((n) & 0x3) << 4)\n#define  REG_LVDS_CM_CHB_LVDS_CM_ADJUST(n)\t((n) & 0x3)\n \n#define REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW\t0x20\n#define REG_VID_CHA_ACTIVE_LINE_LENGTH_HIGH\t0x21\n#define REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW\t0x24\n#define REG_VID_CHA_VERTICAL_DISPLAY_SIZE_HIGH\t0x25\n#define REG_VID_CHA_SYNC_DELAY_LOW\t\t0x28\n#define REG_VID_CHA_SYNC_DELAY_HIGH\t\t0x29\n#define REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW\t0x2c\n#define REG_VID_CHA_HSYNC_PULSE_WIDTH_HIGH\t0x2d\n#define REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW\t0x30\n#define REG_VID_CHA_VSYNC_PULSE_WIDTH_HIGH\t0x31\n#define REG_VID_CHA_HORIZONTAL_BACK_PORCH\t0x34\n#define REG_VID_CHA_VERTICAL_BACK_PORCH\t\t0x36\n#define REG_VID_CHA_HORIZONTAL_FRONT_PORCH\t0x38\n#define REG_VID_CHA_VERTICAL_FRONT_PORCH\t0x3a\n#define REG_VID_CHA_TEST_PATTERN\t\t0x3c\n \n#define REG_IRQ_GLOBAL\t\t\t\t0xe0\n#define  REG_IRQ_GLOBAL_IRQ_EN\t\t\tBIT(0)\n#define REG_IRQ_EN\t\t\t\t0xe1\n#define  REG_IRQ_EN_CHA_SYNCH_ERR_EN\t\tBIT(7)\n#define  REG_IRQ_EN_CHA_CRC_ERR_EN\t\tBIT(6)\n#define  REG_IRQ_EN_CHA_UNC_ECC_ERR_EN\t\tBIT(5)\n#define  REG_IRQ_EN_CHA_COR_ECC_ERR_EN\t\tBIT(4)\n#define  REG_IRQ_EN_CHA_LLP_ERR_EN\t\tBIT(3)\n#define  REG_IRQ_EN_CHA_SOT_BIT_ERR_EN\t\tBIT(2)\n#define  REG_IRQ_EN_CHA_PLL_UNLOCK_EN\t\tBIT(0)\n#define REG_IRQ_STAT\t\t\t\t0xe5\n#define  REG_IRQ_STAT_CHA_SYNCH_ERR\t\tBIT(7)\n#define  REG_IRQ_STAT_CHA_CRC_ERR\t\tBIT(6)\n#define  REG_IRQ_STAT_CHA_UNC_ECC_ERR\t\tBIT(5)\n#define  REG_IRQ_STAT_CHA_COR_ECC_ERR\t\tBIT(4)\n#define  REG_IRQ_STAT_CHA_LLP_ERR\t\tBIT(3)\n#define  REG_IRQ_STAT_CHA_SOT_BIT_ERR\t\tBIT(2)\n#define  REG_IRQ_STAT_CHA_PLL_UNLOCK\t\tBIT(0)\n\nenum sn65dsi83_model {\n\tMODEL_SN65DSI83,\n\tMODEL_SN65DSI84,\n};\n\nstruct sn65dsi83 {\n\tstruct drm_bridge\t\tbridge;\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct mipi_dsi_device\t\t*dsi;\n\tstruct drm_bridge\t\t*panel_bridge;\n\tstruct gpio_desc\t\t*enable_gpio;\n\tstruct regulator\t\t*vcc;\n\tbool\t\t\t\tlvds_dual_link;\n\tbool\t\t\t\tlvds_dual_link_even_odd_swap;\n};\n\nstatic const struct regmap_range sn65dsi83_readable_ranges[] = {\n\tregmap_reg_range(REG_ID(0), REG_ID(8)),\n\tregmap_reg_range(REG_RC_LVDS_PLL, REG_RC_DSI_CLK),\n\tregmap_reg_range(REG_RC_PLL_EN, REG_RC_PLL_EN),\n\tregmap_reg_range(REG_DSI_LANE, REG_DSI_CLK),\n\tregmap_reg_range(REG_LVDS_FMT, REG_LVDS_CM),\n\tregmap_reg_range(REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW,\n\t\t\t REG_VID_CHA_ACTIVE_LINE_LENGTH_HIGH),\n\tregmap_reg_range(REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW,\n\t\t\t REG_VID_CHA_VERTICAL_DISPLAY_SIZE_HIGH),\n\tregmap_reg_range(REG_VID_CHA_SYNC_DELAY_LOW,\n\t\t\t REG_VID_CHA_SYNC_DELAY_HIGH),\n\tregmap_reg_range(REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW,\n\t\t\t REG_VID_CHA_HSYNC_PULSE_WIDTH_HIGH),\n\tregmap_reg_range(REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW,\n\t\t\t REG_VID_CHA_VSYNC_PULSE_WIDTH_HIGH),\n\tregmap_reg_range(REG_VID_CHA_HORIZONTAL_BACK_PORCH,\n\t\t\t REG_VID_CHA_HORIZONTAL_BACK_PORCH),\n\tregmap_reg_range(REG_VID_CHA_VERTICAL_BACK_PORCH,\n\t\t\t REG_VID_CHA_VERTICAL_BACK_PORCH),\n\tregmap_reg_range(REG_VID_CHA_HORIZONTAL_FRONT_PORCH,\n\t\t\t REG_VID_CHA_HORIZONTAL_FRONT_PORCH),\n\tregmap_reg_range(REG_VID_CHA_VERTICAL_FRONT_PORCH,\n\t\t\t REG_VID_CHA_VERTICAL_FRONT_PORCH),\n\tregmap_reg_range(REG_VID_CHA_TEST_PATTERN, REG_VID_CHA_TEST_PATTERN),\n\tregmap_reg_range(REG_IRQ_GLOBAL, REG_IRQ_EN),\n\tregmap_reg_range(REG_IRQ_STAT, REG_IRQ_STAT),\n};\n\nstatic const struct regmap_access_table sn65dsi83_readable_table = {\n\t.yes_ranges = sn65dsi83_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sn65dsi83_readable_ranges),\n};\n\nstatic const struct regmap_range sn65dsi83_writeable_ranges[] = {\n\tregmap_reg_range(REG_RC_RESET, REG_RC_DSI_CLK),\n\tregmap_reg_range(REG_RC_PLL_EN, REG_RC_PLL_EN),\n\tregmap_reg_range(REG_DSI_LANE, REG_DSI_CLK),\n\tregmap_reg_range(REG_LVDS_FMT, REG_LVDS_CM),\n\tregmap_reg_range(REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW,\n\t\t\t REG_VID_CHA_ACTIVE_LINE_LENGTH_HIGH),\n\tregmap_reg_range(REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW,\n\t\t\t REG_VID_CHA_VERTICAL_DISPLAY_SIZE_HIGH),\n\tregmap_reg_range(REG_VID_CHA_SYNC_DELAY_LOW,\n\t\t\t REG_VID_CHA_SYNC_DELAY_HIGH),\n\tregmap_reg_range(REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW,\n\t\t\t REG_VID_CHA_HSYNC_PULSE_WIDTH_HIGH),\n\tregmap_reg_range(REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW,\n\t\t\t REG_VID_CHA_VSYNC_PULSE_WIDTH_HIGH),\n\tregmap_reg_range(REG_VID_CHA_HORIZONTAL_BACK_PORCH,\n\t\t\t REG_VID_CHA_HORIZONTAL_BACK_PORCH),\n\tregmap_reg_range(REG_VID_CHA_VERTICAL_BACK_PORCH,\n\t\t\t REG_VID_CHA_VERTICAL_BACK_PORCH),\n\tregmap_reg_range(REG_VID_CHA_HORIZONTAL_FRONT_PORCH,\n\t\t\t REG_VID_CHA_HORIZONTAL_FRONT_PORCH),\n\tregmap_reg_range(REG_VID_CHA_VERTICAL_FRONT_PORCH,\n\t\t\t REG_VID_CHA_VERTICAL_FRONT_PORCH),\n\tregmap_reg_range(REG_VID_CHA_TEST_PATTERN, REG_VID_CHA_TEST_PATTERN),\n\tregmap_reg_range(REG_IRQ_GLOBAL, REG_IRQ_EN),\n\tregmap_reg_range(REG_IRQ_STAT, REG_IRQ_STAT),\n};\n\nstatic const struct regmap_access_table sn65dsi83_writeable_table = {\n\t.yes_ranges = sn65dsi83_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sn65dsi83_writeable_ranges),\n};\n\nstatic const struct regmap_range sn65dsi83_volatile_ranges[] = {\n\tregmap_reg_range(REG_RC_RESET, REG_RC_RESET),\n\tregmap_reg_range(REG_RC_LVDS_PLL, REG_RC_LVDS_PLL),\n\tregmap_reg_range(REG_IRQ_STAT, REG_IRQ_STAT),\n};\n\nstatic const struct regmap_access_table sn65dsi83_volatile_table = {\n\t.yes_ranges = sn65dsi83_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(sn65dsi83_volatile_ranges),\n};\n\nstatic const struct regmap_config sn65dsi83_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.rd_table = &sn65dsi83_readable_table,\n\t.wr_table = &sn65dsi83_writeable_table,\n\t.volatile_table = &sn65dsi83_volatile_table,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = REG_IRQ_STAT,\n};\n\nstatic struct sn65dsi83 *bridge_to_sn65dsi83(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct sn65dsi83, bridge);\n}\n\nstatic int sn65dsi83_attach(struct drm_bridge *bridge,\n\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, ctx->panel_bridge,\n\t\t\t\t &ctx->bridge, flags);\n}\n\nstatic void sn65dsi83_detach(struct drm_bridge *bridge)\n{\n\tstruct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);\n\n\tif (!ctx->dsi)\n\t\treturn;\n\n\tctx->dsi = NULL;\n}\n\nstatic u8 sn65dsi83_get_lvds_range(struct sn65dsi83 *ctx,\n\t\t\t\t   const struct drm_display_mode *mode)\n{\n\t \n\tint mode_clock = mode->clock;\n\n\tif (ctx->lvds_dual_link)\n\t\tmode_clock /= 2;\n\n\treturn (mode_clock - 12500) / 25000;\n}\n\nstatic u8 sn65dsi83_get_dsi_range(struct sn65dsi83 *ctx,\n\t\t\t\t  const struct drm_display_mode *mode)\n{\n\t \n\treturn DIV_ROUND_UP(clamp((unsigned int)mode->clock *\n\t\t\t    mipi_dsi_pixel_format_to_bpp(ctx->dsi->format) /\n\t\t\t    ctx->dsi->lanes / 2, 40000U, 500000U), 5000U);\n}\n\nstatic u8 sn65dsi83_get_dsi_div(struct sn65dsi83 *ctx)\n{\n\t \n\tunsigned int dsi_div = mipi_dsi_pixel_format_to_bpp(ctx->dsi->format);\n\n\tdsi_div /= ctx->dsi->lanes;\n\n\tif (!ctx->lvds_dual_link)\n\t\tdsi_div /= 2;\n\n\treturn dsi_div - 1;\n}\n\nstatic void sn65dsi83_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tconst struct drm_bridge_state *bridge_state;\n\tconst struct drm_crtc_state *crtc_state;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tbool lvds_format_24bpp;\n\tbool lvds_format_jeida;\n\tunsigned int pval;\n\t__le16 le16val;\n\tu16 val;\n\tint ret;\n\n\tret = regulator_enable(ctx->vcc);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"Failed to enable vcc: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(ctx->enable_gpio, 1);\n\tusleep_range(10000, 11000);\n\n\t \n\tbridge_state = drm_atomic_get_new_bridge_state(state, bridge);\n\n\tswitch (bridge_state->output_bus_cfg.format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tlvds_format_24bpp = false;\n\t\tlvds_format_jeida = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = false;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = false;\n\t\tdev_warn(ctx->dev,\n\t\t\t \"Unsupported LVDS bus format 0x%04x, please check output bridge driver. Falling back to SPWG24.\\n\",\n\t\t\t bridge_state->output_bus_cfg.format);\n\t\tbreak;\n\t}\n\n\t \n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tmode = &crtc_state->adjusted_mode;\n\n\t \n\tregmap_write(ctx->regmap, REG_RC_RESET, 0x00);\n\tregmap_write(ctx->regmap, REG_RC_PLL_EN, 0x00);\n\n\t \n\tregmap_write(ctx->regmap, REG_RC_LVDS_PLL,\n\t\t     REG_RC_LVDS_PLL_LVDS_CLK_RANGE(sn65dsi83_get_lvds_range(ctx, mode)) |\n\t\t     REG_RC_LVDS_PLL_HS_CLK_SRC_DPHY);\n\tregmap_write(ctx->regmap, REG_DSI_CLK,\n\t\t     REG_DSI_CLK_CHA_DSI_CLK_RANGE(sn65dsi83_get_dsi_range(ctx, mode)));\n\tregmap_write(ctx->regmap, REG_RC_DSI_CLK,\n\t\t     REG_RC_DSI_CLK_DSI_CLK_DIVIDER(sn65dsi83_get_dsi_div(ctx)));\n\n\t \n\tregmap_write(ctx->regmap, REG_DSI_LANE,\n\t\t     REG_DSI_LANE_DSI_CHANNEL_MODE_SINGLE |\n\t\t     REG_DSI_LANE_CHA_DSI_LANES(~(ctx->dsi->lanes - 1)) |\n\t\t      \n\t\t     REG_DSI_LANE_CHB_DSI_LANES(3));\n\t \n\tregmap_write(ctx->regmap, REG_DSI_EQ, 0x00);\n\n\t \n\tval = (mode->flags & DRM_MODE_FLAG_NHSYNC ?\n\t       REG_LVDS_FMT_HS_NEG_POLARITY : 0) |\n\t      (mode->flags & DRM_MODE_FLAG_NVSYNC ?\n\t       REG_LVDS_FMT_VS_NEG_POLARITY : 0);\n\n\t \n\tif (lvds_format_24bpp) {\n\t\tval |= REG_LVDS_FMT_CHA_24BPP_MODE;\n\t\tif (ctx->lvds_dual_link)\n\t\t\tval |= REG_LVDS_FMT_CHB_24BPP_MODE;\n\t}\n\n\t \n\tif (lvds_format_jeida) {\n\t\tval |= REG_LVDS_FMT_CHA_24BPP_FORMAT1;\n\t\tif (ctx->lvds_dual_link)\n\t\t\tval |= REG_LVDS_FMT_CHB_24BPP_FORMAT1;\n\t}\n\n\t \n\tif (!ctx->lvds_dual_link)\n\t\tval |= REG_LVDS_FMT_LVDS_LINK_CFG;\n\n\tregmap_write(ctx->regmap, REG_LVDS_FMT, val);\n\tregmap_write(ctx->regmap, REG_LVDS_VCOM, 0x05);\n\tregmap_write(ctx->regmap, REG_LVDS_LANE,\n\t\t     (ctx->lvds_dual_link_even_odd_swap ?\n\t\t      REG_LVDS_LANE_EVEN_ODD_SWAP : 0) |\n\t\t     REG_LVDS_LANE_CHA_LVDS_TERM |\n\t\t     REG_LVDS_LANE_CHB_LVDS_TERM);\n\tregmap_write(ctx->regmap, REG_LVDS_CM, 0x00);\n\n\tle16val = cpu_to_le16(mode->hdisplay);\n\tregmap_bulk_write(ctx->regmap, REG_VID_CHA_ACTIVE_LINE_LENGTH_LOW,\n\t\t\t  &le16val, 2);\n\tle16val = cpu_to_le16(mode->vdisplay);\n\tregmap_bulk_write(ctx->regmap, REG_VID_CHA_VERTICAL_DISPLAY_SIZE_LOW,\n\t\t\t  &le16val, 2);\n\t \n\tle16val = cpu_to_le16(32 + 1);\n\tregmap_bulk_write(ctx->regmap, REG_VID_CHA_SYNC_DELAY_LOW, &le16val, 2);\n\tle16val = cpu_to_le16(mode->hsync_end - mode->hsync_start);\n\tregmap_bulk_write(ctx->regmap, REG_VID_CHA_HSYNC_PULSE_WIDTH_LOW,\n\t\t\t  &le16val, 2);\n\tle16val = cpu_to_le16(mode->vsync_end - mode->vsync_start);\n\tregmap_bulk_write(ctx->regmap, REG_VID_CHA_VSYNC_PULSE_WIDTH_LOW,\n\t\t\t  &le16val, 2);\n\tregmap_write(ctx->regmap, REG_VID_CHA_HORIZONTAL_BACK_PORCH,\n\t\t     mode->htotal - mode->hsync_end);\n\tregmap_write(ctx->regmap, REG_VID_CHA_VERTICAL_BACK_PORCH,\n\t\t     mode->vtotal - mode->vsync_end);\n\tregmap_write(ctx->regmap, REG_VID_CHA_HORIZONTAL_FRONT_PORCH,\n\t\t     mode->hsync_start - mode->hdisplay);\n\tregmap_write(ctx->regmap, REG_VID_CHA_VERTICAL_FRONT_PORCH,\n\t\t     mode->vsync_start - mode->vdisplay);\n\tregmap_write(ctx->regmap, REG_VID_CHA_TEST_PATTERN, 0x00);\n\n\t \n\tregmap_write(ctx->regmap, REG_RC_PLL_EN, REG_RC_PLL_EN_PLL_EN);\n\tusleep_range(3000, 4000);\n\tret = regmap_read_poll_timeout(ctx->regmap, REG_RC_LVDS_PLL, pval,\n\t\t\t\t       pval & REG_RC_LVDS_PLL_PLL_EN_STAT,\n\t\t\t\t       1000, 100000);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"failed to lock PLL, ret=%i\\n\", ret);\n\t\t \n\t\tregmap_write(ctx->regmap, REG_RC_PLL_EN, 0x00);\n\t\tregulator_disable(ctx->vcc);\n\t\treturn;\n\t}\n\n\t \n\tregmap_write(ctx->regmap, REG_RC_RESET, REG_RC_RESET_SOFT_RESET);\n\n\t \n\tusleep_range(10000, 12000);\n}\n\nstatic void sn65dsi83_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_bridge_state *old_bridge_state)\n{\n\tstruct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);\n\tunsigned int pval;\n\n\t \n\tregmap_read(ctx->regmap, REG_IRQ_STAT, &pval);\n\tregmap_write(ctx->regmap, REG_IRQ_STAT, pval);\n\n\t \n\tusleep_range(1000, 1100);\n\tregmap_read(ctx->regmap, REG_IRQ_STAT, &pval);\n\tif (pval)\n\t\tdev_err(ctx->dev, \"Unexpected link status 0x%02x\\n\", pval);\n}\n\nstatic void sn65dsi83_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct sn65dsi83 *ctx = bridge_to_sn65dsi83(bridge);\n\tint ret;\n\n\t \n\tgpiod_set_value_cansleep(ctx->enable_gpio, 0);\n\tusleep_range(10000, 11000);\n\n\tret = regulator_disable(ctx->vcc);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"Failed to disable vcc: %d\\n\", ret);\n\n\tregcache_mark_dirty(ctx->regmap);\n}\n\nstatic enum drm_mode_status\nsn65dsi83_mode_valid(struct drm_bridge *bridge,\n\t\t     const struct drm_display_info *info,\n\t\t     const struct drm_display_mode *mode)\n{\n\t \n\tif (mode->clock < 25000)\n\t\treturn MODE_CLOCK_LOW;\n\tif (mode->clock > 154000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\nsn65dsi83_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t    u32 output_fmt,\n\t\t\t\t    unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t \n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs sn65dsi83_funcs = {\n\t.attach\t\t\t= sn65dsi83_attach,\n\t.detach\t\t\t= sn65dsi83_detach,\n\t.atomic_enable\t\t= sn65dsi83_atomic_enable,\n\t.atomic_pre_enable\t= sn65dsi83_atomic_pre_enable,\n\t.atomic_disable\t\t= sn65dsi83_atomic_disable,\n\t.mode_valid\t\t= sn65dsi83_mode_valid,\n\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_get_input_bus_fmts = sn65dsi83_atomic_get_input_bus_fmts,\n};\n\nstatic int sn65dsi83_parse_dt(struct sn65dsi83 *ctx, enum sn65dsi83_model model)\n{\n\tstruct drm_bridge *panel_bridge;\n\tstruct device *dev = ctx->dev;\n\n\tctx->lvds_dual_link = false;\n\tctx->lvds_dual_link_even_odd_swap = false;\n\tif (model != MODEL_SN65DSI83) {\n\t\tstruct device_node *port2, *port3;\n\t\tint dual_link;\n\n\t\tport2 = of_graph_get_port_by_id(dev->of_node, 2);\n\t\tport3 = of_graph_get_port_by_id(dev->of_node, 3);\n\t\tdual_link = drm_of_lvds_get_dual_link_pixel_order(port2, port3);\n\t\tof_node_put(port2);\n\t\tof_node_put(port3);\n\n\t\tif (dual_link == DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS) {\n\t\t\tctx->lvds_dual_link = true;\n\t\t\t \n\t\t\tctx->lvds_dual_link_even_odd_swap = false;\n\t\t} else if (dual_link == DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS) {\n\t\t\tctx->lvds_dual_link = true;\n\t\t\t \n\t\t\tctx->lvds_dual_link_even_odd_swap = true;\n\t\t}\n\t}\n\n\tpanel_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 2, 0);\n\tif (IS_ERR(panel_bridge))\n\t\treturn PTR_ERR(panel_bridge);\n\n\tctx->panel_bridge = panel_bridge;\n\n\tctx->vcc = devm_regulator_get(dev, \"vcc\");\n\tif (IS_ERR(ctx->vcc))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->vcc),\n\t\t\t\t     \"Failed to get supply 'vcc'\\n\");\n\n\treturn 0;\n}\n\nstatic int sn65dsi83_host_attach(struct sn65dsi83 *ctx)\n{\n\tstruct device *dev = ctx->dev;\n\tstruct device_node *host_node;\n\tstruct device_node *endpoint;\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tconst struct mipi_dsi_device_info info = {\n\t\t.type = \"sn65dsi83\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\tint dsi_lanes, ret;\n\n\tendpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, -1);\n\tdsi_lanes = drm_of_get_data_lanes_count(endpoint, 1, 4);\n\thost_node = of_graph_get_remote_port_parent(endpoint);\n\thost = of_find_mipi_dsi_host_by_node(host_node);\n\tof_node_put(host_node);\n\tof_node_put(endpoint);\n\n\tif (!host)\n\t\treturn -EPROBE_DEFER;\n\n\tif (dsi_lanes < 0)\n\t\treturn dsi_lanes;\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi),\n\t\t\t\t     \"failed to create dsi device\\n\");\n\n\tctx->dsi = dsi;\n\n\tdsi->lanes = dsi_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |\n\t\t\t  MIPI_DSI_MODE_VIDEO_NO_HFP | MIPI_DSI_MODE_VIDEO_NO_HBP |\n\t\t\t  MIPI_DSI_MODE_VIDEO_NO_HSA | MIPI_DSI_MODE_NO_EOT_PACKET;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sn65dsi83_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tenum sn65dsi83_model model;\n\tstruct sn65dsi83 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\n\tif (dev->of_node) {\n\t\tmodel = (enum sn65dsi83_model)(uintptr_t)\n\t\t\tof_device_get_match_data(dev);\n\t} else {\n\t\tmodel = id->driver_data;\n\t}\n\n\t \n\tctx->enable_gpio = devm_gpiod_get_optional(ctx->dev, \"enable\",\n\t\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->enable_gpio), \"failed to get enable GPIO\\n\");\n\n\tusleep_range(10000, 11000);\n\n\tret = sn65dsi83_parse_dt(ctx, model);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->regmap = devm_regmap_init_i2c(client, &sn65dsi83_regmap_config);\n\tif (IS_ERR(ctx->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->regmap), \"failed to get regmap\\n\");\n\n\tdev_set_drvdata(dev, ctx);\n\ti2c_set_clientdata(client, ctx);\n\n\tctx->bridge.funcs = &sn65dsi83_funcs;\n\tctx->bridge.of_node = dev->of_node;\n\tctx->bridge.pre_enable_prev_first = true;\n\tdrm_bridge_add(&ctx->bridge);\n\n\tret = sn65dsi83_host_attach(ctx);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to attach DSI host\\n\");\n\t\tgoto err_remove_bridge;\n\t}\n\n\treturn 0;\n\nerr_remove_bridge:\n\tdrm_bridge_remove(&ctx->bridge);\n\treturn ret;\n}\n\nstatic void sn65dsi83_remove(struct i2c_client *client)\n{\n\tstruct sn65dsi83 *ctx = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&ctx->bridge);\n}\n\nstatic struct i2c_device_id sn65dsi83_id[] = {\n\t{ \"ti,sn65dsi83\", MODEL_SN65DSI83 },\n\t{ \"ti,sn65dsi84\", MODEL_SN65DSI84 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, sn65dsi83_id);\n\nstatic const struct of_device_id sn65dsi83_match_table[] = {\n\t{ .compatible = \"ti,sn65dsi83\", .data = (void *)MODEL_SN65DSI83 },\n\t{ .compatible = \"ti,sn65dsi84\", .data = (void *)MODEL_SN65DSI84 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sn65dsi83_match_table);\n\nstatic struct i2c_driver sn65dsi83_driver = {\n\t.probe = sn65dsi83_probe,\n\t.remove = sn65dsi83_remove,\n\t.id_table = sn65dsi83_id,\n\t.driver = {\n\t\t.name = \"sn65dsi83\",\n\t\t.of_match_table = sn65dsi83_match_table,\n\t},\n};\nmodule_i2c_driver(sn65dsi83_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"TI SN65DSI83 DSI to LVDS bridge driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}