{
  "module_name": "cdns-mhdp8546-hdcp.c",
  "hash_id": "e4036dac414b20cd6ef76ff6fbcdcaa61a5cabe9d0573ef3a150cf0c5330ee8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/cadence/cdns-mhdp8546-hdcp.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include <asm/unaligned.h>\n\n#include <drm/display/drm_hdcp_helper.h>\n\n#include \"cdns-mhdp8546-hdcp.h\"\n\nstatic int cdns_mhdp_secure_mailbox_read(struct cdns_mhdp_device *mhdp)\n{\n\tint ret, empty;\n\n\tWARN_ON(!mutex_is_locked(&mhdp->mbox_mutex));\n\n\tret = readx_poll_timeout(readl, mhdp->sapb_regs + CDNS_MAILBOX_EMPTY,\n\t\t\t\t empty, !empty, MAILBOX_RETRY_US,\n\t\t\t\t MAILBOX_TIMEOUT_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn readl(mhdp->sapb_regs + CDNS_MAILBOX_RX_DATA) & 0xff;\n}\n\nstatic int cdns_mhdp_secure_mailbox_write(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t  u8 val)\n{\n\tint ret, full;\n\n\tWARN_ON(!mutex_is_locked(&mhdp->mbox_mutex));\n\n\tret = readx_poll_timeout(readl, mhdp->sapb_regs + CDNS_MAILBOX_FULL,\n\t\t\t\t full, !full, MAILBOX_RETRY_US,\n\t\t\t\t MAILBOX_TIMEOUT_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(val, mhdp->sapb_regs + CDNS_MAILBOX_TX_DATA);\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_secure_mailbox_recv_header(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t\tu8 module_id,\n\t\t\t\t\t\tu8 opcode,\n\t\t\t\t\t\tu16 req_size)\n{\n\tu32 mbox_size, i;\n\tu8 header[4];\n\tint ret;\n\n\t \n\tfor (i = 0; i < sizeof(header); i++) {\n\t\tret = cdns_mhdp_secure_mailbox_read(mhdp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\theader[i] = ret;\n\t}\n\n\tmbox_size = get_unaligned_be16(header + 2);\n\n\tif (opcode != header[0] || module_id != header[1] ||\n\t    (opcode != HDCP_TRAN_IS_REC_ID_VALID && req_size != mbox_size)) {\n\t\tfor (i = 0; i < mbox_size; i++)\n\t\t\tif (cdns_mhdp_secure_mailbox_read(mhdp) < 0)\n\t\t\t\tbreak;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_secure_mailbox_recv_data(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t      u8 *buff, u16 buff_size)\n{\n\tint ret;\n\tu32 i;\n\n\tfor (i = 0; i < buff_size; i++) {\n\t\tret = cdns_mhdp_secure_mailbox_read(mhdp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuff[i] = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_secure_mailbox_send(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t u8 module_id,\n\t\t\t\t\t u8 opcode,\n\t\t\t\t\t u16 size,\n\t\t\t\t\t u8 *message)\n{\n\tu8 header[4];\n\tint ret;\n\tu32 i;\n\n\theader[0] = opcode;\n\theader[1] = module_id;\n\tput_unaligned_be16(size, header + 2);\n\n\tfor (i = 0; i < sizeof(header); i++) {\n\t\tret = cdns_mhdp_secure_mailbox_write(mhdp, header[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tret = cdns_mhdp_secure_mailbox_write(mhdp, message[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_hdcp_get_status(struct cdns_mhdp_device *mhdp,\n\t\t\t\t     u16 *hdcp_port_status)\n{\n\tu8 hdcp_status[HDCP_STATUS_SIZE];\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP_TRAN_STATUS_CHANGE, 0, NULL);\n\tif (ret)\n\t\tgoto err_get_hdcp_status;\n\n\tret = cdns_mhdp_secure_mailbox_recv_header(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t\t   HDCP_TRAN_STATUS_CHANGE,\n\t\t\t\t\t\t   sizeof(hdcp_status));\n\tif (ret)\n\t\tgoto err_get_hdcp_status;\n\n\tret = cdns_mhdp_secure_mailbox_recv_data(mhdp, hdcp_status,\n\t\t\t\t\t\t sizeof(hdcp_status));\n\tif (ret)\n\t\tgoto err_get_hdcp_status;\n\n\t*hdcp_port_status = ((u16)(hdcp_status[0] << 8) | hdcp_status[1]);\n\nerr_get_hdcp_status:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic u8 cdns_mhdp_hdcp_handle_status(struct cdns_mhdp_device *mhdp,\n\t\t\t\t       u16 status)\n{\n\tu8 err = GET_HDCP_PORT_STS_LAST_ERR(status);\n\n\tif (err)\n\t\tdev_dbg(mhdp->dev, \"HDCP Error = %d\", err);\n\n\treturn err;\n}\n\nstatic int cdns_mhdp_hdcp_rx_id_valid_response(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t       u8 valid)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP_TRAN_RESPOND_RECEIVER_ID_VALID,\n\t\t\t\t\t    1, &valid);\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_hdcp_rx_id_valid(struct cdns_mhdp_device *mhdp,\n\t\t\t\t      u8 *recv_num, u8 *hdcp_rx_id)\n{\n\tu8 rec_id_hdr[2];\n\tu8 status;\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP_TRAN_IS_REC_ID_VALID, 0, NULL);\n\tif (ret)\n\t\tgoto err_rx_id_valid;\n\n\tret = cdns_mhdp_secure_mailbox_recv_header(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t\t   HDCP_TRAN_IS_REC_ID_VALID,\n\t\t\t\t\t\t   sizeof(status));\n\tif (ret)\n\t\tgoto err_rx_id_valid;\n\n\tret = cdns_mhdp_secure_mailbox_recv_data(mhdp, rec_id_hdr, 2);\n\tif (ret)\n\t\tgoto err_rx_id_valid;\n\n\t*recv_num = rec_id_hdr[0];\n\n\tret = cdns_mhdp_secure_mailbox_recv_data(mhdp, hdcp_rx_id, 5 * *recv_num);\n\nerr_rx_id_valid:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_hdcp_km_stored_resp(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t u32 size, u8 *km)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP2X_TX_RESPOND_KM, size, km);\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_hdcp_tx_is_km_stored(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t  u8 *resp, u32 size)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP2X_TX_IS_KM_STORED, 0, NULL);\n\tif (ret)\n\t\tgoto err_is_km_stored;\n\n\tret = cdns_mhdp_secure_mailbox_recv_header(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t\t   HDCP2X_TX_IS_KM_STORED,\n\t\t\t\t\t\t   size);\n\tif (ret)\n\t\tgoto err_is_km_stored;\n\n\tret = cdns_mhdp_secure_mailbox_recv_data(mhdp, resp, size);\nerr_is_km_stored:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_hdcp_tx_config(struct cdns_mhdp_device *mhdp,\n\t\t\t\t    u8 hdcp_cfg)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP_TRAN_CONFIGURATION, 1, &hdcp_cfg);\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_hdcp_set_config(struct cdns_mhdp_device *mhdp,\n\t\t\t\t     u8 hdcp_config, bool enable)\n{\n\tu16 hdcp_port_status;\n\tu32 ret_event;\n\tu8 hdcp_cfg;\n\tint ret;\n\n\thdcp_cfg = hdcp_config | (enable ? 0x04 : 0) |\n\t\t   (HDCP_CONTENT_TYPE_0 << 3);\n\tcdns_mhdp_hdcp_tx_config(mhdp, hdcp_cfg);\n\tret_event = cdns_mhdp_wait_for_sw_event(mhdp, CDNS_HDCP_TX_STATUS);\n\tif (!ret_event)\n\t\treturn -1;\n\n\tret = cdns_mhdp_hdcp_get_status(mhdp, &hdcp_port_status);\n\tif (ret || cdns_mhdp_hdcp_handle_status(mhdp, hdcp_port_status))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_hdcp_auth_check(struct cdns_mhdp_device *mhdp)\n{\n\tu16 hdcp_port_status;\n\tu32 ret_event;\n\tint ret;\n\n\tret_event = cdns_mhdp_wait_for_sw_event(mhdp, CDNS_HDCP_TX_STATUS);\n\tif (!ret_event)\n\t\treturn -1;\n\n\tret = cdns_mhdp_hdcp_get_status(mhdp, &hdcp_port_status);\n\tif (ret || cdns_mhdp_hdcp_handle_status(mhdp, hdcp_port_status))\n\t\treturn -1;\n\n\tif (hdcp_port_status & 1) {\n\t\tdev_dbg(mhdp->dev, \"Authentication completed successfully!\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(mhdp->dev, \"Authentication failed\\n\");\n\n\treturn -1;\n}\n\nstatic int cdns_mhdp_hdcp_check_receviers(struct cdns_mhdp_device *mhdp)\n{\n\tu8 hdcp_rec_id[HDCP_MAX_RECEIVERS][HDCP_RECEIVER_ID_SIZE_BYTES];\n\tu8 hdcp_num_rec;\n\tu32 ret_event;\n\n\tret_event = cdns_mhdp_wait_for_sw_event(mhdp,\n\t\t\t\t\t\tCDNS_HDCP_TX_IS_RCVR_ID_VALID);\n\tif (!ret_event)\n\t\treturn -1;\n\n\thdcp_num_rec = 0;\n\tmemset(&hdcp_rec_id, 0, sizeof(hdcp_rec_id));\n\tcdns_mhdp_hdcp_rx_id_valid(mhdp, &hdcp_num_rec, (u8 *)hdcp_rec_id);\n\tcdns_mhdp_hdcp_rx_id_valid_response(mhdp, 1);\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_hdcp_auth_22(struct cdns_mhdp_device *mhdp)\n{\n\tu8 resp[HDCP_STATUS_SIZE];\n\tu16 hdcp_port_status;\n\tu32 ret_event;\n\tint ret;\n\n\tdev_dbg(mhdp->dev, \"HDCP: Start 2.2 Authentication\\n\");\n\tret_event = cdns_mhdp_wait_for_sw_event(mhdp,\n\t\t\t\t\t\tCDNS_HDCP2_TX_IS_KM_STORED);\n\tif (!ret_event)\n\t\treturn -1;\n\n\tif (ret_event & CDNS_HDCP_TX_STATUS) {\n\t\tmhdp->sw_events &= ~CDNS_HDCP_TX_STATUS;\n\t\tret = cdns_mhdp_hdcp_get_status(mhdp, &hdcp_port_status);\n\t\tif (ret || cdns_mhdp_hdcp_handle_status(mhdp, hdcp_port_status))\n\t\t\treturn -1;\n\t}\n\n\tcdns_mhdp_hdcp_tx_is_km_stored(mhdp, resp, sizeof(resp));\n\tcdns_mhdp_hdcp_km_stored_resp(mhdp, 0, NULL);\n\n\tif (cdns_mhdp_hdcp_check_receviers(mhdp))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic inline int cdns_mhdp_hdcp_auth_14(struct cdns_mhdp_device *mhdp)\n{\n\tdev_dbg(mhdp->dev, \"HDCP: Starting 1.4 Authentication\\n\");\n\treturn cdns_mhdp_hdcp_check_receviers(mhdp);\n}\n\nstatic int cdns_mhdp_hdcp_auth(struct cdns_mhdp_device *mhdp,\n\t\t\t       u8 hdcp_config)\n{\n\tint ret;\n\n\tret = cdns_mhdp_hdcp_set_config(mhdp, hdcp_config, true);\n\tif (ret)\n\t\tgoto auth_failed;\n\n\tif (hdcp_config == HDCP_TX_1)\n\t\tret = cdns_mhdp_hdcp_auth_14(mhdp);\n\telse\n\t\tret = cdns_mhdp_hdcp_auth_22(mhdp);\n\n\tif (ret)\n\t\tgoto auth_failed;\n\n\tret = cdns_mhdp_hdcp_auth_check(mhdp);\n\tif (ret)\n\t\tret = cdns_mhdp_hdcp_auth_check(mhdp);\n\nauth_failed:\n\treturn ret;\n}\n\nstatic int _cdns_mhdp_hdcp_disable(struct cdns_mhdp_device *mhdp)\n{\n\tint ret;\n\n\tdev_dbg(mhdp->dev, \"[%s:%d] HDCP is being disabled...\\n\",\n\t\tmhdp->connector.name, mhdp->connector.base.id);\n\n\tret = cdns_mhdp_hdcp_set_config(mhdp, 0, false);\n\n\treturn ret;\n}\n\nstatic int _cdns_mhdp_hdcp_enable(struct cdns_mhdp_device *mhdp, u8 content_type)\n{\n\tint ret = -EINVAL;\n\tint tries = 3;\n\tu32 i;\n\n\tfor (i = 0; i < tries; i++) {\n\t\tif (content_type == DRM_MODE_HDCP_CONTENT_TYPE0 ||\n\t\t    content_type == DRM_MODE_HDCP_CONTENT_TYPE1) {\n\t\t\tret = cdns_mhdp_hdcp_auth(mhdp, HDCP_TX_2);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\t_cdns_mhdp_hdcp_disable(mhdp);\n\t\t}\n\n\t\tif (content_type == DRM_MODE_HDCP_CONTENT_TYPE0) {\n\t\t\tret = cdns_mhdp_hdcp_auth(mhdp, HDCP_TX_1);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\t_cdns_mhdp_hdcp_disable(mhdp);\n\t\t}\n\t}\n\n\tdev_err(mhdp->dev, \"HDCP authentication failed (%d tries/%d)\\n\",\n\t\ttries, ret);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_hdcp_check_link(struct cdns_mhdp_device *mhdp)\n{\n\tu16 hdcp_port_status;\n\tint ret = 0;\n\n\tmutex_lock(&mhdp->hdcp.mutex);\n\tif (mhdp->hdcp.value == DRM_MODE_CONTENT_PROTECTION_UNDESIRED)\n\t\tgoto out;\n\n\tret = cdns_mhdp_hdcp_get_status(mhdp, &hdcp_port_status);\n\tif (!ret && hdcp_port_status & HDCP_PORT_STS_AUTH)\n\t\tgoto out;\n\n\tdev_err(mhdp->dev,\n\t\t\"[%s:%d] HDCP link failed, retrying authentication\\n\",\n\t\tmhdp->connector.name, mhdp->connector.base.id);\n\n\tret = _cdns_mhdp_hdcp_disable(mhdp);\n\tif (ret) {\n\t\tmhdp->hdcp.value = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\tschedule_work(&mhdp->hdcp.prop_work);\n\t\tgoto out;\n\t}\n\n\tret = _cdns_mhdp_hdcp_enable(mhdp, mhdp->hdcp.hdcp_content_type);\n\tif (ret) {\n\t\tmhdp->hdcp.value = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\tschedule_work(&mhdp->hdcp.prop_work);\n\t}\nout:\n\tmutex_unlock(&mhdp->hdcp.mutex);\n\treturn ret;\n}\n\nstatic void cdns_mhdp_hdcp_check_work(struct work_struct *work)\n{\n\tstruct delayed_work *d_work = to_delayed_work(work);\n\tstruct cdns_mhdp_hdcp *hdcp = container_of(d_work,\n\t\t\t\t\t\t   struct cdns_mhdp_hdcp,\n\t\t\t\t\t\t   check_work);\n\tstruct cdns_mhdp_device *mhdp = container_of(hdcp,\n\t\t\t\t\t\t     struct cdns_mhdp_device,\n\t\t\t\t\t\t     hdcp);\n\n\tif (!cdns_mhdp_hdcp_check_link(mhdp))\n\t\tschedule_delayed_work(&hdcp->check_work,\n\t\t\t\t      DRM_HDCP_CHECK_PERIOD_MS);\n}\n\nstatic void cdns_mhdp_hdcp_prop_work(struct work_struct *work)\n{\n\tstruct cdns_mhdp_hdcp *hdcp = container_of(work,\n\t\t\t\t\t\t   struct cdns_mhdp_hdcp,\n\t\t\t\t\t\t   prop_work);\n\tstruct cdns_mhdp_device *mhdp = container_of(hdcp,\n\t\t\t\t\t\t     struct cdns_mhdp_device,\n\t\t\t\t\t\t     hdcp);\n\tstruct drm_device *dev = mhdp->connector.dev;\n\tstruct drm_connector_state *state;\n\n\tdrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\n\tmutex_lock(&mhdp->hdcp.mutex);\n\tif (mhdp->hdcp.value != DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\tstate = mhdp->connector.state;\n\t\tstate->content_protection = mhdp->hdcp.value;\n\t}\n\tmutex_unlock(&mhdp->hdcp.mutex);\n\tdrm_modeset_unlock(&dev->mode_config.connection_mutex);\n}\n\nint cdns_mhdp_hdcp_set_lc(struct cdns_mhdp_device *mhdp, u8 *val)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_GENERAL,\n\t\t\t\t\t    HDCP_GENERAL_SET_LC_128,\n\t\t\t\t\t    16, val);\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nint\ncdns_mhdp_hdcp_set_public_key_param(struct cdns_mhdp_device *mhdp,\n\t\t\t\t    struct cdns_hdcp_tx_public_key_param *val)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\tret = cdns_mhdp_secure_mailbox_send(mhdp, MB_MODULE_ID_HDCP_TX,\n\t\t\t\t\t    HDCP2X_TX_SET_PUBLIC_KEY_PARAMS,\n\t\t\t\t\t    sizeof(*val), (u8 *)val);\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nint cdns_mhdp_hdcp_enable(struct cdns_mhdp_device *mhdp, u8 content_type)\n{\n\tint ret;\n\n\tmutex_lock(&mhdp->hdcp.mutex);\n\tret = _cdns_mhdp_hdcp_enable(mhdp, content_type);\n\tif (ret)\n\t\tgoto out;\n\n\tmhdp->hdcp.hdcp_content_type = content_type;\n\tmhdp->hdcp.value = DRM_MODE_CONTENT_PROTECTION_ENABLED;\n\tschedule_work(&mhdp->hdcp.prop_work);\n\tschedule_delayed_work(&mhdp->hdcp.check_work,\n\t\t\t      DRM_HDCP_CHECK_PERIOD_MS);\nout:\n\tmutex_unlock(&mhdp->hdcp.mutex);\n\treturn ret;\n}\n\nint cdns_mhdp_hdcp_disable(struct cdns_mhdp_device *mhdp)\n{\n\tint ret = 0;\n\n\tmutex_lock(&mhdp->hdcp.mutex);\n\tif (mhdp->hdcp.value != DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\tmhdp->hdcp.value = DRM_MODE_CONTENT_PROTECTION_UNDESIRED;\n\t\tschedule_work(&mhdp->hdcp.prop_work);\n\t\tret = _cdns_mhdp_hdcp_disable(mhdp);\n\t}\n\tmutex_unlock(&mhdp->hdcp.mutex);\n\tcancel_delayed_work_sync(&mhdp->hdcp.check_work);\n\n\treturn ret;\n}\n\nvoid cdns_mhdp_hdcp_init(struct cdns_mhdp_device *mhdp)\n{\n\tINIT_DELAYED_WORK(&mhdp->hdcp.check_work, cdns_mhdp_hdcp_check_work);\n\tINIT_WORK(&mhdp->hdcp.prop_work, cdns_mhdp_hdcp_prop_work);\n\tmutex_init(&mhdp->hdcp.mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}