{
  "module_name": "cdns-dsi-core.c",
  "hash_id": "a564b03132d88964d5ffb59e64d8c57bf748d9365a93be037222f694da31a177",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/cadence/cdns-dsi-core.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_probe_helper.h>\n#include <video/mipi_display.h>\n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <linux/phy/phy-mipi-dphy.h>\n\n#include \"cdns-dsi-core.h\"\n#ifdef CONFIG_DRM_CDNS_DSI_J721E\n#include \"cdns-dsi-j721e.h\"\n#endif\n\n#define IP_CONF\t\t\t\t0x0\n#define SP_HS_FIFO_DEPTH(x)\t\t(((x) & GENMASK(30, 26)) >> 26)\n#define SP_LP_FIFO_DEPTH(x)\t\t(((x) & GENMASK(25, 21)) >> 21)\n#define VRS_FIFO_DEPTH(x)\t\t(((x) & GENMASK(20, 16)) >> 16)\n#define DIRCMD_FIFO_DEPTH(x)\t\t(((x) & GENMASK(15, 13)) >> 13)\n#define SDI_IFACE_32\t\t\tBIT(12)\n#define INTERNAL_DATAPATH_32\t\t(0 << 10)\n#define INTERNAL_DATAPATH_16\t\t(1 << 10)\n#define INTERNAL_DATAPATH_8\t\t(3 << 10)\n#define INTERNAL_DATAPATH_SIZE\t\t((x) & GENMASK(11, 10))\n#define NUM_IFACE(x)\t\t\t((((x) & GENMASK(9, 8)) >> 8) + 1)\n#define MAX_LANE_NB(x)\t\t\t(((x) & GENMASK(7, 6)) >> 6)\n#define RX_FIFO_DEPTH(x)\t\t((x) & GENMASK(5, 0))\n\n#define MCTL_MAIN_DATA_CTL\t\t0x4\n#define TE_MIPI_POLLING_EN\t\tBIT(25)\n#define TE_HW_POLLING_EN\t\tBIT(24)\n#define DISP_EOT_GEN\t\t\tBIT(18)\n#define HOST_EOT_GEN\t\t\tBIT(17)\n#define DISP_GEN_CHECKSUM\t\tBIT(16)\n#define DISP_GEN_ECC\t\t\tBIT(15)\n#define BTA_EN\t\t\t\tBIT(14)\n#define READ_EN\t\t\t\tBIT(13)\n#define REG_TE_EN\t\t\tBIT(12)\n#define IF_TE_EN(x)\t\t\tBIT(8 + (x))\n#define TVG_SEL\t\t\t\tBIT(6)\n#define VID_EN\t\t\t\tBIT(5)\n#define IF_VID_SELECT(x)\t\t((x) << 2)\n#define IF_VID_SELECT_MASK\t\tGENMASK(3, 2)\n#define IF_VID_MODE\t\t\tBIT(1)\n#define LINK_EN\t\t\t\tBIT(0)\n\n#define MCTL_MAIN_PHY_CTL\t\t0x8\n#define HS_INVERT_DAT(x)\t\tBIT(19 + ((x) * 2))\n#define SWAP_PINS_DAT(x)\t\tBIT(18 + ((x) * 2))\n#define HS_INVERT_CLK\t\t\tBIT(17)\n#define SWAP_PINS_CLK\t\t\tBIT(16)\n#define HS_SKEWCAL_EN\t\t\tBIT(15)\n#define WAIT_BURST_TIME(x)\t\t((x) << 10)\n#define DATA_ULPM_EN(x)\t\t\tBIT(6 + (x))\n#define CLK_ULPM_EN\t\t\tBIT(5)\n#define CLK_CONTINUOUS\t\t\tBIT(4)\n#define DATA_LANE_EN(x)\t\t\tBIT((x) - 1)\n\n#define MCTL_MAIN_EN\t\t\t0xc\n#define DATA_FORCE_STOP\t\t\tBIT(17)\n#define CLK_FORCE_STOP\t\t\tBIT(16)\n#define IF_EN(x)\t\t\tBIT(13 + (x))\n#define DATA_LANE_ULPM_REQ(l)\t\tBIT(9 + (l))\n#define CLK_LANE_ULPM_REQ\t\tBIT(8)\n#define DATA_LANE_START(x)\t\tBIT(4 + (x))\n#define CLK_LANE_EN\t\t\tBIT(3)\n#define PLL_START\t\t\tBIT(0)\n\n#define MCTL_DPHY_CFG0\t\t\t0x10\n#define DPHY_C_RSTB\t\t\tBIT(20)\n#define DPHY_D_RSTB(x)\t\t\tGENMASK(15 + (x), 16)\n#define DPHY_PLL_PDN\t\t\tBIT(10)\n#define DPHY_CMN_PDN\t\t\tBIT(9)\n#define DPHY_C_PDN\t\t\tBIT(8)\n#define DPHY_D_PDN(x)\t\t\tGENMASK(3 + (x), 4)\n#define DPHY_ALL_D_PDN\t\t\tGENMASK(7, 4)\n#define DPHY_PLL_PSO\t\t\tBIT(1)\n#define DPHY_CMN_PSO\t\t\tBIT(0)\n\n#define MCTL_DPHY_TIMEOUT1\t\t0x14\n#define HSTX_TIMEOUT(x)\t\t\t((x) << 4)\n#define HSTX_TIMEOUT_MAX\t\tGENMASK(17, 0)\n#define CLK_DIV(x)\t\t\t(x)\n#define CLK_DIV_MAX\t\t\tGENMASK(3, 0)\n\n#define MCTL_DPHY_TIMEOUT2\t\t0x18\n#define LPRX_TIMEOUT(x)\t\t\t(x)\n\n#define MCTL_ULPOUT_TIME\t\t0x1c\n#define DATA_LANE_ULPOUT_TIME(x)\t((x) << 9)\n#define CLK_LANE_ULPOUT_TIME(x)\t\t(x)\n\n#define MCTL_3DVIDEO_CTL\t\t0x20\n#define VID_VSYNC_3D_EN\t\t\tBIT(7)\n#define VID_VSYNC_3D_LR\t\t\tBIT(5)\n#define VID_VSYNC_3D_SECOND_EN\t\tBIT(4)\n#define VID_VSYNC_3DFORMAT_LINE\t\t(0 << 2)\n#define VID_VSYNC_3DFORMAT_FRAME\t(1 << 2)\n#define VID_VSYNC_3DFORMAT_PIXEL\t(2 << 2)\n#define VID_VSYNC_3DMODE_OFF\t\t0\n#define VID_VSYNC_3DMODE_PORTRAIT\t1\n#define VID_VSYNC_3DMODE_LANDSCAPE\t2\n\n#define MCTL_MAIN_STS\t\t\t0x24\n#define MCTL_MAIN_STS_CTL\t\t0x130\n#define MCTL_MAIN_STS_CLR\t\t0x150\n#define MCTL_MAIN_STS_FLAG\t\t0x170\n#define HS_SKEWCAL_DONE\t\t\tBIT(11)\n#define IF_UNTERM_PKT_ERR(x)\t\tBIT(8 + (x))\n#define LPRX_TIMEOUT_ERR\t\tBIT(7)\n#define HSTX_TIMEOUT_ERR\t\tBIT(6)\n#define DATA_LANE_RDY(l)\t\tBIT(2 + (l))\n#define CLK_LANE_RDY\t\t\tBIT(1)\n#define PLL_LOCKED\t\t\tBIT(0)\n\n#define MCTL_DPHY_ERR\t\t\t0x28\n#define MCTL_DPHY_ERR_CTL1\t\t0x148\n#define MCTL_DPHY_ERR_CLR\t\t0x168\n#define MCTL_DPHY_ERR_FLAG\t\t0x188\n#define ERR_CONT_LP(x, l)\t\tBIT(18 + ((x) * 4) + (l))\n#define ERR_CONTROL(l)\t\t\tBIT(14 + (l))\n#define ERR_SYNESC(l)\t\t\tBIT(10 + (l))\n#define ERR_ESC(l)\t\t\tBIT(6 + (l))\n\n#define MCTL_DPHY_ERR_CTL2\t\t0x14c\n#define ERR_CONT_LP_EDGE(x, l)\t\tBIT(12 + ((x) * 4) + (l))\n#define ERR_CONTROL_EDGE(l)\t\tBIT(8 + (l))\n#define ERR_SYN_ESC_EDGE(l)\t\tBIT(4 + (l))\n#define ERR_ESC_EDGE(l)\t\t\tBIT(0 + (l))\n\n#define MCTL_LANE_STS\t\t\t0x2c\n#define PPI_C_TX_READY_HS\t\tBIT(18)\n#define DPHY_PLL_LOCK\t\t\tBIT(17)\n#define PPI_D_RX_ULPS_ESC(x)\t\t(((x) & GENMASK(15, 12)) >> 12)\n#define LANE_STATE_START\t\t0\n#define LANE_STATE_IDLE\t\t\t1\n#define LANE_STATE_WRITE\t\t2\n#define LANE_STATE_ULPM\t\t\t3\n#define LANE_STATE_READ\t\t\t4\n#define DATA_LANE_STATE(l, val)\t\t\\\n\t(((val) >> (2 + 2 * (l) + ((l) ? 1 : 0))) & GENMASK((l) ? 1 : 2, 0))\n#define CLK_LANE_STATE_HS\t\t2\n#define CLK_LANE_STATE(val)\t\t((val) & GENMASK(1, 0))\n\n#define DSC_MODE_CTL\t\t\t0x30\n#define DSC_MODE_EN\t\t\tBIT(0)\n\n#define DSC_CMD_SEND\t\t\t0x34\n#define DSC_SEND_PPS\t\t\tBIT(0)\n#define DSC_EXECUTE_QUEUE\t\tBIT(1)\n\n#define DSC_PPS_WRDAT\t\t\t0x38\n\n#define DSC_MODE_STS\t\t\t0x3c\n#define DSC_PPS_DONE\t\t\tBIT(1)\n#define DSC_EXEC_DONE\t\t\tBIT(2)\n\n#define CMD_MODE_CTL\t\t\t0x70\n#define IF_LP_EN(x)\t\t\tBIT(9 + (x))\n#define IF_VCHAN_ID(x, c)\t\t((c) << ((x) * 2))\n\n#define CMD_MODE_CTL2\t\t\t0x74\n#define TE_TIMEOUT(x)\t\t\t((x) << 11)\n#define FILL_VALUE(x)\t\t\t((x) << 3)\n#define ARB_IF_WITH_HIGHEST_PRIORITY(x)\t((x) << 1)\n#define ARB_ROUND_ROBIN_MODE\t\tBIT(0)\n\n#define CMD_MODE_STS\t\t\t0x78\n#define CMD_MODE_STS_CTL\t\t0x134\n#define CMD_MODE_STS_CLR\t\t0x154\n#define CMD_MODE_STS_FLAG\t\t0x174\n#define ERR_IF_UNDERRUN(x)\t\tBIT(4 + (x))\n#define ERR_UNWANTED_READ\t\tBIT(3)\n#define ERR_TE_MISS\t\t\tBIT(2)\n#define ERR_NO_TE\t\t\tBIT(1)\n#define CSM_RUNNING\t\t\tBIT(0)\n\n#define DIRECT_CMD_SEND\t\t\t0x80\n\n#define DIRECT_CMD_MAIN_SETTINGS\t0x84\n#define TRIGGER_VAL(x)\t\t\t((x) << 25)\n#define CMD_LP_EN\t\t\tBIT(24)\n#define CMD_SIZE(x)\t\t\t((x) << 16)\n#define CMD_VCHAN_ID(x)\t\t\t((x) << 14)\n#define CMD_DATATYPE(x)\t\t\t((x) << 8)\n#define CMD_LONG\t\t\tBIT(3)\n#define WRITE_CMD\t\t\t0\n#define READ_CMD\t\t\t1\n#define TE_REQ\t\t\t\t4\n#define TRIGGER_REQ\t\t\t5\n#define BTA_REQ\t\t\t\t6\n\n#define DIRECT_CMD_STS\t\t\t0x88\n#define DIRECT_CMD_STS_CTL\t\t0x138\n#define DIRECT_CMD_STS_CLR\t\t0x158\n#define DIRECT_CMD_STS_FLAG\t\t0x178\n#define RCVD_ACK_VAL(val)\t\t((val) >> 16)\n#define RCVD_TRIGGER_VAL(val)\t\t(((val) & GENMASK(14, 11)) >> 11)\n#define READ_COMPLETED_WITH_ERR\t\tBIT(10)\n#define BTA_FINISHED\t\t\tBIT(9)\n#define BTA_COMPLETED\t\t\tBIT(8)\n#define TE_RCVD\t\t\t\tBIT(7)\n#define TRIGGER_RCVD\t\t\tBIT(6)\n#define ACK_WITH_ERR_RCVD\t\tBIT(5)\n#define ACK_RCVD\t\t\tBIT(4)\n#define READ_COMPLETED\t\t\tBIT(3)\n#define TRIGGER_COMPLETED\t\tBIT(2)\n#define WRITE_COMPLETED\t\t\tBIT(1)\n#define SENDING_CMD\t\t\tBIT(0)\n\n#define DIRECT_CMD_STOP_READ\t\t0x8c\n\n#define DIRECT_CMD_WRDATA\t\t0x90\n\n#define DIRECT_CMD_FIFO_RST\t\t0x94\n\n#define DIRECT_CMD_RDDATA\t\t0xa0\n\n#define DIRECT_CMD_RD_PROPS\t\t0xa4\n#define RD_DCS\t\t\t\tBIT(18)\n#define RD_VCHAN_ID(val)\t\t(((val) >> 16) & GENMASK(1, 0))\n#define RD_SIZE(val)\t\t\t((val) & GENMASK(15, 0))\n\n#define DIRECT_CMD_RD_STS\t\t0xa8\n#define DIRECT_CMD_RD_STS_CTL\t\t0x13c\n#define DIRECT_CMD_RD_STS_CLR\t\t0x15c\n#define DIRECT_CMD_RD_STS_FLAG\t\t0x17c\n#define ERR_EOT_WITH_ERR\t\tBIT(8)\n#define ERR_MISSING_EOT\t\t\tBIT(7)\n#define ERR_WRONG_LENGTH\t\tBIT(6)\n#define ERR_OVERSIZE\t\t\tBIT(5)\n#define ERR_RECEIVE\t\t\tBIT(4)\n#define ERR_UNDECODABLE\t\t\tBIT(3)\n#define ERR_CHECKSUM\t\t\tBIT(2)\n#define ERR_UNCORRECTABLE\t\tBIT(1)\n#define ERR_FIXED\t\t\tBIT(0)\n\n#define VID_MAIN_CTL\t\t\t0xb0\n#define VID_IGNORE_MISS_VSYNC\t\tBIT(31)\n#define VID_FIELD_SW\t\t\tBIT(28)\n#define VID_INTERLACED_EN\t\tBIT(27)\n#define RECOVERY_MODE(x)\t\t((x) << 25)\n#define RECOVERY_MODE_NEXT_HSYNC\t0\n#define RECOVERY_MODE_NEXT_STOP_POINT\t2\n#define RECOVERY_MODE_NEXT_VSYNC\t3\n#define REG_BLKEOL_MODE(x)\t\t((x) << 23)\n#define REG_BLKLINE_MODE(x)\t\t((x) << 21)\n#define REG_BLK_MODE_NULL_PKT\t\t0\n#define REG_BLK_MODE_BLANKING_PKT\t1\n#define REG_BLK_MODE_LP\t\t\t2\n#define SYNC_PULSE_HORIZONTAL\t\tBIT(20)\n#define SYNC_PULSE_ACTIVE\t\tBIT(19)\n#define BURST_MODE\t\t\tBIT(18)\n#define VID_PIXEL_MODE_MASK\t\tGENMASK(17, 14)\n#define VID_PIXEL_MODE_RGB565\t\t(0 << 14)\n#define VID_PIXEL_MODE_RGB666_PACKED\t(1 << 14)\n#define VID_PIXEL_MODE_RGB666\t\t(2 << 14)\n#define VID_PIXEL_MODE_RGB888\t\t(3 << 14)\n#define VID_PIXEL_MODE_RGB101010\t(4 << 14)\n#define VID_PIXEL_MODE_RGB121212\t(5 << 14)\n#define VID_PIXEL_MODE_YUV420\t\t(8 << 14)\n#define VID_PIXEL_MODE_YUV422_PACKED\t(9 << 14)\n#define VID_PIXEL_MODE_YUV422\t\t(10 << 14)\n#define VID_PIXEL_MODE_YUV422_24B\t(11 << 14)\n#define VID_PIXEL_MODE_DSC_COMP\t\t(12 << 14)\n#define VID_DATATYPE(x)\t\t\t((x) << 8)\n#define VID_VIRTCHAN_ID(iface, x)\t((x) << (4 + (iface) * 2))\n#define STOP_MODE(x)\t\t\t((x) << 2)\n#define START_MODE(x)\t\t\t(x)\n\n#define VID_VSIZE1\t\t\t0xb4\n#define VFP_LEN(x)\t\t\t((x) << 12)\n#define VBP_LEN(x)\t\t\t((x) << 6)\n#define VSA_LEN(x)\t\t\t(x)\n\n#define VID_VSIZE2\t\t\t0xb8\n#define VACT_LEN(x)\t\t\t(x)\n\n#define VID_HSIZE1\t\t\t0xc0\n#define HBP_LEN(x)\t\t\t((x) << 16)\n#define HSA_LEN(x)\t\t\t(x)\n\n#define VID_HSIZE2\t\t\t0xc4\n#define HFP_LEN(x)\t\t\t((x) << 16)\n#define HACT_LEN(x)\t\t\t(x)\n\n#define VID_BLKSIZE1\t\t\t0xcc\n#define BLK_EOL_PKT_LEN(x)\t\t((x) << 15)\n#define BLK_LINE_EVENT_PKT_LEN(x)\t(x)\n\n#define VID_BLKSIZE2\t\t\t0xd0\n#define BLK_LINE_PULSE_PKT_LEN(x)\t(x)\n\n#define VID_PKT_TIME\t\t\t0xd8\n#define BLK_EOL_DURATION(x)\t\t(x)\n\n#define VID_DPHY_TIME\t\t\t0xdc\n#define REG_WAKEUP_TIME(x)\t\t((x) << 17)\n#define REG_LINE_DURATION(x)\t\t(x)\n\n#define VID_ERR_COLOR1\t\t\t0xe0\n#define COL_GREEN(x)\t\t\t((x) << 12)\n#define COL_RED(x)\t\t\t(x)\n\n#define VID_ERR_COLOR2\t\t\t0xe4\n#define PAD_VAL(x)\t\t\t((x) << 12)\n#define COL_BLUE(x)\t\t\t(x)\n\n#define VID_VPOS\t\t\t0xe8\n#define LINE_VAL(val)\t\t\t(((val) & GENMASK(14, 2)) >> 2)\n#define LINE_POS(val)\t\t\t((val) & GENMASK(1, 0))\n\n#define VID_HPOS\t\t\t0xec\n#define HORIZ_VAL(val)\t\t\t(((val) & GENMASK(17, 3)) >> 3)\n#define HORIZ_POS(val)\t\t\t((val) & GENMASK(2, 0))\n\n#define VID_MODE_STS\t\t\t0xf0\n#define VID_MODE_STS_CTL\t\t0x140\n#define VID_MODE_STS_CLR\t\t0x160\n#define VID_MODE_STS_FLAG\t\t0x180\n#define VSG_RECOVERY\t\t\tBIT(10)\n#define ERR_VRS_WRONG_LEN\t\tBIT(9)\n#define ERR_LONG_READ\t\t\tBIT(8)\n#define ERR_LINE_WRITE\t\t\tBIT(7)\n#define ERR_BURST_WRITE\t\t\tBIT(6)\n#define ERR_SMALL_HEIGHT\t\tBIT(5)\n#define ERR_SMALL_LEN\t\t\tBIT(4)\n#define ERR_MISSING_VSYNC\t\tBIT(3)\n#define ERR_MISSING_HSYNC\t\tBIT(2)\n#define ERR_MISSING_DATA\t\tBIT(1)\n#define VSG_RUNNING\t\t\tBIT(0)\n\n#define VID_VCA_SETTING1\t\t0xf4\n#define BURST_LP\t\t\tBIT(16)\n#define MAX_BURST_LIMIT(x)\t\t(x)\n\n#define VID_VCA_SETTING2\t\t0xf8\n#define MAX_LINE_LIMIT(x)\t\t((x) << 16)\n#define EXACT_BURST_LIMIT(x)\t\t(x)\n\n#define TVG_CTL\t\t\t\t0xfc\n#define TVG_STRIPE_SIZE(x)\t\t((x) << 5)\n#define TVG_MODE_MASK\t\t\tGENMASK(4, 3)\n#define TVG_MODE_SINGLE_COLOR\t\t(0 << 3)\n#define TVG_MODE_VSTRIPES\t\t(2 << 3)\n#define TVG_MODE_HSTRIPES\t\t(3 << 3)\n#define TVG_STOPMODE_MASK\t\tGENMASK(2, 1)\n#define TVG_STOPMODE_EOF\t\t(0 << 1)\n#define TVG_STOPMODE_EOL\t\t(1 << 1)\n#define TVG_STOPMODE_NOW\t\t(2 << 1)\n#define TVG_RUN\t\t\t\tBIT(0)\n\n#define TVG_IMG_SIZE\t\t\t0x100\n#define TVG_NBLINES(x)\t\t\t((x) << 16)\n#define TVG_LINE_SIZE(x)\t\t(x)\n\n#define TVG_COLOR1\t\t\t0x104\n#define TVG_COL1_GREEN(x)\t\t((x) << 12)\n#define TVG_COL1_RED(x)\t\t\t(x)\n\n#define TVG_COLOR1_BIS\t\t\t0x108\n#define TVG_COL1_BLUE(x)\t\t(x)\n\n#define TVG_COLOR2\t\t\t0x10c\n#define TVG_COL2_GREEN(x)\t\t((x) << 12)\n#define TVG_COL2_RED(x)\t\t\t(x)\n\n#define TVG_COLOR2_BIS\t\t\t0x110\n#define TVG_COL2_BLUE(x)\t\t(x)\n\n#define TVG_STS\t\t\t\t0x114\n#define TVG_STS_CTL\t\t\t0x144\n#define TVG_STS_CLR\t\t\t0x164\n#define TVG_STS_FLAG\t\t\t0x184\n#define TVG_STS_RUNNING\t\t\tBIT(0)\n\n#define STS_CTL_EDGE(e)\t\t\t((e) << 16)\n\n#define DPHY_LANES_MAP\t\t\t0x198\n#define DAT_REMAP_CFG(b, l)\t\t((l) << ((b) * 8))\n\n#define DPI_IRQ_EN\t\t\t0x1a0\n#define DPI_IRQ_CLR\t\t\t0x1a4\n#define DPI_IRQ_STS\t\t\t0x1a8\n#define PIXEL_BUF_OVERFLOW\t\tBIT(0)\n\n#define DPI_CFG\t\t\t\t0x1ac\n#define DPI_CFG_FIFO_DEPTH(x)\t\t((x) >> 16)\n#define DPI_CFG_FIFO_LEVEL(x)\t\t((x) & GENMASK(15, 0))\n\n#define TEST_GENERIC\t\t\t0x1f0\n#define TEST_STATUS(x)\t\t\t((x) >> 16)\n#define TEST_CTRL(x)\t\t\t(x)\n\n#define ID_REG\t\t\t\t0x1fc\n#define REV_VENDOR_ID(x)\t\t(((x) & GENMASK(31, 20)) >> 20)\n#define REV_PRODUCT_ID(x)\t\t(((x) & GENMASK(19, 12)) >> 12)\n#define REV_HW(x)\t\t\t(((x) & GENMASK(11, 8)) >> 8)\n#define REV_MAJOR(x)\t\t\t(((x) & GENMASK(7, 4)) >> 4)\n#define REV_MINOR(x)\t\t\t((x) & GENMASK(3, 0))\n\n#define DSI_OUTPUT_PORT\t\t\t0\n#define DSI_INPUT_PORT(inputid)\t\t(1 + (inputid))\n\n#define DSI_HBP_FRAME_OVERHEAD\t\t12\n#define DSI_HSA_FRAME_OVERHEAD\t\t14\n#define DSI_HFP_FRAME_OVERHEAD\t\t6\n#define DSI_HSS_VSS_VSE_FRAME_OVERHEAD\t4\n#define DSI_BLANKING_FRAME_OVERHEAD\t6\n#define DSI_NULL_FRAME_OVERHEAD\t\t6\n#define DSI_EOT_PKT_SIZE\t\t4\n\nstatic inline struct cdns_dsi *input_to_dsi(struct cdns_dsi_input *input)\n{\n\treturn container_of(input, struct cdns_dsi, input);\n}\n\nstatic inline struct cdns_dsi *to_cdns_dsi(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct cdns_dsi, base);\n}\n\nstatic inline struct cdns_dsi_input *\nbridge_to_cdns_dsi_input(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct cdns_dsi_input, bridge);\n}\n\nstatic unsigned int mode_to_dpi_hfp(const struct drm_display_mode *mode,\n\t\t\t\t    bool mode_valid_check)\n{\n\tif (mode_valid_check)\n\t\treturn mode->hsync_start - mode->hdisplay;\n\n\treturn mode->crtc_hsync_start - mode->crtc_hdisplay;\n}\n\nstatic unsigned int dpi_to_dsi_timing(unsigned int dpi_timing,\n\t\t\t\t      unsigned int dpi_bpp,\n\t\t\t\t      unsigned int dsi_pkt_overhead)\n{\n\tunsigned int dsi_timing = DIV_ROUND_UP(dpi_timing * dpi_bpp, 8);\n\n\tif (dsi_timing < dsi_pkt_overhead)\n\t\tdsi_timing = 0;\n\telse\n\t\tdsi_timing -= dsi_pkt_overhead;\n\n\treturn dsi_timing;\n}\n\nstatic int cdns_dsi_mode2cfg(struct cdns_dsi *dsi,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     struct cdns_dsi_cfg *dsi_cfg,\n\t\t\t     bool mode_valid_check)\n{\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tunsigned int tmp;\n\tbool sync_pulse = false;\n\tint bpp;\n\n\tmemset(dsi_cfg, 0, sizeof(*dsi_cfg));\n\n\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\tsync_pulse = true;\n\n\tbpp = mipi_dsi_pixel_format_to_bpp(output->dev->format);\n\n\tif (mode_valid_check)\n\t\ttmp = mode->htotal -\n\t\t      (sync_pulse ? mode->hsync_end : mode->hsync_start);\n\telse\n\t\ttmp = mode->crtc_htotal -\n\t\t      (sync_pulse ?\n\t\t       mode->crtc_hsync_end : mode->crtc_hsync_start);\n\n\tdsi_cfg->hbp = dpi_to_dsi_timing(tmp, bpp, DSI_HBP_FRAME_OVERHEAD);\n\n\tif (sync_pulse) {\n\t\tif (mode_valid_check)\n\t\t\ttmp = mode->hsync_end - mode->hsync_start;\n\t\telse\n\t\t\ttmp = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\n\t\tdsi_cfg->hsa = dpi_to_dsi_timing(tmp, bpp,\n\t\t\t\t\t\t DSI_HSA_FRAME_OVERHEAD);\n\t}\n\n\tdsi_cfg->hact = dpi_to_dsi_timing(mode_valid_check ?\n\t\t\t\t\t  mode->hdisplay : mode->crtc_hdisplay,\n\t\t\t\t\t  bpp, 0);\n\tdsi_cfg->hfp = dpi_to_dsi_timing(mode_to_dpi_hfp(mode, mode_valid_check),\n\t\t\t\t\t bpp, DSI_HFP_FRAME_OVERHEAD);\n\n\treturn 0;\n}\n\nstatic int cdns_dsi_adjust_phy_config(struct cdns_dsi *dsi,\n\t\t\t      struct cdns_dsi_cfg *dsi_cfg,\n\t\t\t      struct phy_configure_opts_mipi_dphy *phy_cfg,\n\t\t\t      const struct drm_display_mode *mode,\n\t\t\t      bool mode_valid_check)\n{\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tunsigned long long dlane_bps;\n\tunsigned long adj_dsi_htotal;\n\tunsigned long dsi_htotal;\n\tunsigned long dpi_htotal;\n\tunsigned long dpi_hz;\n\tunsigned int dsi_hfp_ext;\n\tunsigned int lanes = output->dev->lanes;\n\n\tdsi_htotal = dsi_cfg->hbp + DSI_HBP_FRAME_OVERHEAD;\n\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\tdsi_htotal += dsi_cfg->hsa + DSI_HSA_FRAME_OVERHEAD;\n\n\tdsi_htotal += dsi_cfg->hact;\n\tdsi_htotal += dsi_cfg->hfp + DSI_HFP_FRAME_OVERHEAD;\n\n\t \n\tadj_dsi_htotal = dsi_htotal;\n\tif (dsi_htotal % lanes)\n\t\tadj_dsi_htotal += lanes - (dsi_htotal % lanes);\n\n\tdpi_hz = (mode_valid_check ? mode->clock : mode->crtc_clock) * 1000;\n\tdlane_bps = (unsigned long long)dpi_hz * adj_dsi_htotal;\n\n\t \n\tdpi_htotal = mode_valid_check ? mode->htotal : mode->crtc_htotal;\n\tif (do_div(dlane_bps, lanes * dpi_htotal))\n\t\treturn -EINVAL;\n\n\t \n\tphy_cfg->hs_clk_rate = dlane_bps * 8;\n\n\tdsi_hfp_ext = adj_dsi_htotal - dsi_htotal;\n\tdsi_cfg->hfp += dsi_hfp_ext;\n\tdsi_cfg->htotal = dsi_htotal + dsi_hfp_ext;\n\n\treturn 0;\n}\n\nstatic int cdns_dsi_check_conf(struct cdns_dsi *dsi,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       struct cdns_dsi_cfg *dsi_cfg,\n\t\t\t       bool mode_valid_check)\n{\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tstruct phy_configure_opts_mipi_dphy *phy_cfg = &output->phy_opts.mipi_dphy;\n\tunsigned long dsi_hss_hsa_hse_hbp;\n\tunsigned int nlanes = output->dev->lanes;\n\tint ret;\n\n\tret = cdns_dsi_mode2cfg(dsi, mode, dsi_cfg, mode_valid_check);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_mipi_dphy_get_default_config(mode->crtc_clock * 1000,\n\t\t\t\t\t mipi_dsi_pixel_format_to_bpp(output->dev->format),\n\t\t\t\t\t nlanes, phy_cfg);\n\n\tret = cdns_dsi_adjust_phy_config(dsi, dsi_cfg, phy_cfg, mode, mode_valid_check);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_validate(dsi->dphy, PHY_MODE_MIPI_DPHY, 0, &output->phy_opts);\n\tif (ret)\n\t\treturn ret;\n\n\tdsi_hss_hsa_hse_hbp = dsi_cfg->hbp + DSI_HBP_FRAME_OVERHEAD;\n\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\tdsi_hss_hsa_hse_hbp += dsi_cfg->hsa + DSI_HSA_FRAME_OVERHEAD;\n\n\t \n\tif ((u64)phy_cfg->hs_clk_rate *\n\t    mode_to_dpi_hfp(mode, mode_valid_check) * nlanes <\n\t    (u64)dsi_hss_hsa_hse_hbp *\n\t    (mode_valid_check ? mode->clock : mode->crtc_clock) * 1000)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int cdns_dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t  enum drm_bridge_attach_flags flags)\n{\n\tstruct cdns_dsi_input *input = bridge_to_cdns_dsi_input(bridge);\n\tstruct cdns_dsi *dsi = input_to_dsi(input);\n\tstruct cdns_dsi_output *output = &dsi->output;\n\n\tif (!drm_core_check_feature(bridge->dev, DRIVER_ATOMIC)) {\n\t\tdev_err(dsi->base.dev,\n\t\t\t\"cdns-dsi driver is only compatible with DRM devices supporting atomic updates\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder, output->bridge, bridge,\n\t\t\t\t flags);\n}\n\nstatic enum drm_mode_status\ncdns_dsi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t   const struct drm_display_info *info,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct cdns_dsi_input *input = bridge_to_cdns_dsi_input(bridge);\n\tstruct cdns_dsi *dsi = input_to_dsi(input);\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tstruct cdns_dsi_cfg dsi_cfg;\n\tint bpp, ret;\n\n\t \n\tif (mode->vtotal - mode->vsync_end < 2)\n\t\treturn MODE_V_ILLEGAL;\n\n\t \n\tif (mode->vsync_end - mode->vsync_start < 2)\n\t\treturn MODE_V_ILLEGAL;\n\n\t \n\tbpp = mipi_dsi_pixel_format_to_bpp(output->dev->format);\n\tif ((mode->hdisplay * bpp) % 32)\n\t\treturn MODE_H_ILLEGAL;\n\n\tret = cdns_dsi_check_conf(dsi, mode, &dsi_cfg, true);\n\tif (ret)\n\t\treturn MODE_BAD;\n\n\treturn MODE_OK;\n}\n\nstatic void cdns_dsi_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct cdns_dsi_input *input = bridge_to_cdns_dsi_input(bridge);\n\tstruct cdns_dsi *dsi = input_to_dsi(input);\n\tu32 val;\n\n\tval = readl(dsi->regs + MCTL_MAIN_DATA_CTL);\n\tval &= ~(IF_VID_SELECT_MASK | IF_VID_MODE | VID_EN | HOST_EOT_GEN |\n\t\t DISP_EOT_GEN);\n\twritel(val, dsi->regs + MCTL_MAIN_DATA_CTL);\n\n\tval = readl(dsi->regs + MCTL_MAIN_EN) & ~IF_EN(input->id);\n\twritel(val, dsi->regs + MCTL_MAIN_EN);\n\n\tif (dsi->platform_ops && dsi->platform_ops->disable)\n\t\tdsi->platform_ops->disable(dsi);\n\n\tpm_runtime_put(dsi->base.dev);\n}\n\nstatic void cdns_dsi_bridge_post_disable(struct drm_bridge *bridge)\n{\n\tstruct cdns_dsi_input *input = bridge_to_cdns_dsi_input(bridge);\n\tstruct cdns_dsi *dsi = input_to_dsi(input);\n\n\tpm_runtime_put(dsi->base.dev);\n}\n\nstatic void cdns_dsi_hs_init(struct cdns_dsi *dsi)\n{\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tu32 status;\n\n\tif (dsi->phy_initialized)\n\t\treturn;\n\t \n\twritel(DPHY_CMN_PSO | DPHY_PLL_PSO | DPHY_ALL_D_PDN | DPHY_C_PDN |\n\t       DPHY_CMN_PDN | DPHY_PLL_PDN,\n\t       dsi->regs + MCTL_DPHY_CFG0);\n\n\tphy_init(dsi->dphy);\n\tphy_set_mode(dsi->dphy, PHY_MODE_MIPI_DPHY);\n\tphy_configure(dsi->dphy, &output->phy_opts);\n\tphy_power_on(dsi->dphy);\n\n\t \n\twritel(PLL_LOCKED, dsi->regs + MCTL_MAIN_STS_CLR);\n\twritel(DPHY_CMN_PSO | DPHY_ALL_D_PDN | DPHY_C_PDN | DPHY_CMN_PDN,\n\t       dsi->regs + MCTL_DPHY_CFG0);\n\tWARN_ON_ONCE(readl_poll_timeout(dsi->regs + MCTL_MAIN_STS, status,\n\t\t\t\t\tstatus & PLL_LOCKED, 100, 100));\n\t \n\twritel(DPHY_CMN_PSO | DPHY_ALL_D_PDN | DPHY_C_PDN | DPHY_CMN_PDN |\n\t       DPHY_D_RSTB(output->dev->lanes) | DPHY_C_RSTB,\n\t       dsi->regs + MCTL_DPHY_CFG0);\n\tdsi->phy_initialized = true;\n}\n\nstatic void cdns_dsi_init_link(struct cdns_dsi *dsi)\n{\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tunsigned long sysclk_period, ulpout;\n\tu32 val;\n\tint i;\n\n\tif (dsi->link_initialized)\n\t\treturn;\n\n\tval = 0;\n\tfor (i = 1; i < output->dev->lanes; i++)\n\t\tval |= DATA_LANE_EN(i);\n\n\tif (!(output->dev->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS))\n\t\tval |= CLK_CONTINUOUS;\n\n\twritel(val, dsi->regs + MCTL_MAIN_PHY_CTL);\n\n\t \n\tsysclk_period = NSEC_PER_SEC / clk_get_rate(dsi->dsi_sys_clk);\n\tulpout = DIV_ROUND_UP(NSEC_PER_MSEC, sysclk_period);\n\twritel(CLK_LANE_ULPOUT_TIME(ulpout) | DATA_LANE_ULPOUT_TIME(ulpout),\n\t       dsi->regs + MCTL_ULPOUT_TIME);\n\n\twritel(LINK_EN, dsi->regs + MCTL_MAIN_DATA_CTL);\n\n\tval = CLK_LANE_EN | PLL_START;\n\tfor (i = 0; i < output->dev->lanes; i++)\n\t\tval |= DATA_LANE_START(i);\n\n\twritel(val, dsi->regs + MCTL_MAIN_EN);\n\n\tdsi->link_initialized = true;\n}\n\nstatic void cdns_dsi_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct cdns_dsi_input *input = bridge_to_cdns_dsi_input(bridge);\n\tstruct cdns_dsi *dsi = input_to_dsi(input);\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tstruct drm_display_mode *mode;\n\tstruct phy_configure_opts_mipi_dphy *phy_cfg = &output->phy_opts.mipi_dphy;\n\tunsigned long tx_byte_period;\n\tstruct cdns_dsi_cfg dsi_cfg;\n\tu32 tmp, reg_wakeup, div;\n\tint nlanes;\n\n\tif (WARN_ON(pm_runtime_get_sync(dsi->base.dev) < 0))\n\t\treturn;\n\n\tif (dsi->platform_ops && dsi->platform_ops->enable)\n\t\tdsi->platform_ops->enable(dsi);\n\n\tmode = &bridge->encoder->crtc->state->adjusted_mode;\n\tnlanes = output->dev->lanes;\n\n\tWARN_ON_ONCE(cdns_dsi_check_conf(dsi, mode, &dsi_cfg, false));\n\n\tcdns_dsi_hs_init(dsi);\n\tcdns_dsi_init_link(dsi);\n\n\twritel(HBP_LEN(dsi_cfg.hbp) | HSA_LEN(dsi_cfg.hsa),\n\t       dsi->regs + VID_HSIZE1);\n\twritel(HFP_LEN(dsi_cfg.hfp) | HACT_LEN(dsi_cfg.hact),\n\t       dsi->regs + VID_HSIZE2);\n\n\twritel(VBP_LEN(mode->crtc_vtotal - mode->crtc_vsync_end - 1) |\n\t       VFP_LEN(mode->crtc_vsync_start - mode->crtc_vdisplay) |\n\t       VSA_LEN(mode->crtc_vsync_end - mode->crtc_vsync_start + 1),\n\t       dsi->regs + VID_VSIZE1);\n\twritel(mode->crtc_vdisplay, dsi->regs + VID_VSIZE2);\n\n\ttmp = dsi_cfg.htotal -\n\t      (dsi_cfg.hsa + DSI_BLANKING_FRAME_OVERHEAD +\n\t       DSI_HSA_FRAME_OVERHEAD);\n\twritel(BLK_LINE_PULSE_PKT_LEN(tmp), dsi->regs + VID_BLKSIZE2);\n\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\twritel(MAX_LINE_LIMIT(tmp - DSI_NULL_FRAME_OVERHEAD),\n\t\t       dsi->regs + VID_VCA_SETTING2);\n\n\ttmp = dsi_cfg.htotal -\n\t      (DSI_HSS_VSS_VSE_FRAME_OVERHEAD + DSI_BLANKING_FRAME_OVERHEAD);\n\twritel(BLK_LINE_EVENT_PKT_LEN(tmp), dsi->regs + VID_BLKSIZE1);\n\tif (!(output->dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE))\n\t\twritel(MAX_LINE_LIMIT(tmp - DSI_NULL_FRAME_OVERHEAD),\n\t\t       dsi->regs + VID_VCA_SETTING2);\n\n\ttmp = DIV_ROUND_UP(dsi_cfg.htotal, nlanes) -\n\t      DIV_ROUND_UP(dsi_cfg.hsa, nlanes);\n\n\tif (!(output->dev->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET))\n\t\ttmp -= DIV_ROUND_UP(DSI_EOT_PKT_SIZE, nlanes);\n\n\ttx_byte_period = DIV_ROUND_DOWN_ULL((u64)NSEC_PER_SEC * 8,\n\t\t\t\t\t    phy_cfg->hs_clk_rate);\n\treg_wakeup = (phy_cfg->hs_prepare + phy_cfg->hs_zero) / tx_byte_period;\n\twritel(REG_WAKEUP_TIME(reg_wakeup) | REG_LINE_DURATION(tmp),\n\t       dsi->regs + VID_DPHY_TIME);\n\n\t \n\ttmp = NSEC_PER_SEC / drm_mode_vrefresh(mode);\n\ttmp /= tx_byte_period;\n\n\tfor (div = 0; div <= CLK_DIV_MAX; div++) {\n\t\tif (tmp <= HSTX_TIMEOUT_MAX)\n\t\t\tbreak;\n\n\t\ttmp >>= 1;\n\t}\n\n\tif (tmp > HSTX_TIMEOUT_MAX)\n\t\ttmp = HSTX_TIMEOUT_MAX;\n\n\twritel(CLK_DIV(div) | HSTX_TIMEOUT(tmp),\n\t       dsi->regs + MCTL_DPHY_TIMEOUT1);\n\n\twritel(LPRX_TIMEOUT(tmp), dsi->regs + MCTL_DPHY_TIMEOUT2);\n\n\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tswitch (output->dev->format) {\n\t\tcase MIPI_DSI_FMT_RGB888:\n\t\t\ttmp = VID_PIXEL_MODE_RGB888 |\n\t\t\t      VID_DATATYPE(MIPI_DSI_PACKED_PIXEL_STREAM_24);\n\t\t\tbreak;\n\n\t\tcase MIPI_DSI_FMT_RGB666:\n\t\t\ttmp = VID_PIXEL_MODE_RGB666 |\n\t\t\t      VID_DATATYPE(MIPI_DSI_PIXEL_STREAM_3BYTE_18);\n\t\t\tbreak;\n\n\t\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\t\ttmp = VID_PIXEL_MODE_RGB666_PACKED |\n\t\t\t      VID_DATATYPE(MIPI_DSI_PACKED_PIXEL_STREAM_18);\n\t\t\tbreak;\n\n\t\tcase MIPI_DSI_FMT_RGB565:\n\t\t\ttmp = VID_PIXEL_MODE_RGB565 |\n\t\t\t      VID_DATATYPE(MIPI_DSI_PACKED_PIXEL_STREAM_16);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dsi->base.dev, \"Unsupported DSI format\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\t\ttmp |= SYNC_PULSE_ACTIVE | SYNC_PULSE_HORIZONTAL;\n\n\t\ttmp |= REG_BLKLINE_MODE(REG_BLK_MODE_BLANKING_PKT) |\n\t\t       REG_BLKEOL_MODE(REG_BLK_MODE_BLANKING_PKT) |\n\t\t       RECOVERY_MODE(RECOVERY_MODE_NEXT_HSYNC) |\n\t\t       VID_IGNORE_MISS_VSYNC;\n\n\t\twritel(tmp, dsi->regs + VID_MAIN_CTL);\n\t}\n\n\ttmp = readl(dsi->regs + MCTL_MAIN_DATA_CTL);\n\ttmp &= ~(IF_VID_SELECT_MASK | HOST_EOT_GEN | IF_VID_MODE);\n\n\tif (!(output->dev->mode_flags & MIPI_DSI_MODE_NO_EOT_PACKET))\n\t\ttmp |= HOST_EOT_GEN;\n\n\tif (output->dev->mode_flags & MIPI_DSI_MODE_VIDEO)\n\t\ttmp |= IF_VID_MODE | IF_VID_SELECT(input->id) | VID_EN;\n\n\twritel(tmp, dsi->regs + MCTL_MAIN_DATA_CTL);\n\n\ttmp = readl(dsi->regs + MCTL_MAIN_EN) | IF_EN(input->id);\n\twritel(tmp, dsi->regs + MCTL_MAIN_EN);\n}\n\nstatic void cdns_dsi_bridge_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct cdns_dsi_input *input = bridge_to_cdns_dsi_input(bridge);\n\tstruct cdns_dsi *dsi = input_to_dsi(input);\n\n\tif (WARN_ON(pm_runtime_get_sync(dsi->base.dev) < 0))\n\t\treturn;\n\n\tcdns_dsi_init_link(dsi);\n\tcdns_dsi_hs_init(dsi);\n}\n\nstatic const struct drm_bridge_funcs cdns_dsi_bridge_funcs = {\n\t.attach = cdns_dsi_bridge_attach,\n\t.mode_valid = cdns_dsi_bridge_mode_valid,\n\t.disable = cdns_dsi_bridge_disable,\n\t.pre_enable = cdns_dsi_bridge_pre_enable,\n\t.enable = cdns_dsi_bridge_enable,\n\t.post_disable = cdns_dsi_bridge_post_disable,\n};\n\nstatic int cdns_dsi_attach(struct mipi_dsi_host *host,\n\t\t\t   struct mipi_dsi_device *dev)\n{\n\tstruct cdns_dsi *dsi = to_cdns_dsi(host);\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tstruct cdns_dsi_input *input = &dsi->input;\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tstruct device_node *np;\n\tint ret;\n\n\t \n\tif (output->dev)\n\t\treturn -EBUSY;\n\n\t \n\tif (dev->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\treturn -ENOTSUPP;\n\n\t \n\tnp = of_graph_get_remote_node(dsi->base.dev->of_node, DSI_OUTPUT_PORT,\n\t\t\t\t      dev->channel);\n\tif (!np)\n\t\tnp = of_node_get(dev->dev.of_node);\n\n\tpanel = of_drm_find_panel(np);\n\tif (!IS_ERR(panel)) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_DSI);\n\t} else {\n\t\tbridge = of_drm_find_bridge(dev->dev.of_node);\n\t\tif (!bridge)\n\t\t\tbridge = ERR_PTR(-EINVAL);\n\t}\n\n\tof_node_put(np);\n\n\tif (IS_ERR(bridge)) {\n\t\tret = PTR_ERR(bridge);\n\t\tdev_err(host->dev, \"failed to add DSI device %s (err = %d)\",\n\t\t\tdev->name, ret);\n\t\treturn ret;\n\t}\n\n\toutput->dev = dev;\n\toutput->bridge = bridge;\n\toutput->panel = panel;\n\n\t \n\tdrm_bridge_add(&input->bridge);\n\n\treturn 0;\n}\n\nstatic int cdns_dsi_detach(struct mipi_dsi_host *host,\n\t\t\t   struct mipi_dsi_device *dev)\n{\n\tstruct cdns_dsi *dsi = to_cdns_dsi(host);\n\tstruct cdns_dsi_output *output = &dsi->output;\n\tstruct cdns_dsi_input *input = &dsi->input;\n\n\tdrm_bridge_remove(&input->bridge);\n\tif (output->panel)\n\t\tdrm_panel_bridge_remove(output->bridge);\n\n\treturn 0;\n}\n\nstatic irqreturn_t cdns_dsi_interrupt(int irq, void *data)\n{\n\tstruct cdns_dsi *dsi = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 flag, ctl;\n\n\tflag = readl(dsi->regs + DIRECT_CMD_STS_FLAG);\n\tif (flag) {\n\t\tctl = readl(dsi->regs + DIRECT_CMD_STS_CTL);\n\t\tctl &= ~flag;\n\t\twritel(ctl, dsi->regs + DIRECT_CMD_STS_CTL);\n\t\tcomplete(&dsi->direct_cmd_comp);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t cdns_dsi_transfer(struct mipi_dsi_host *host,\n\t\t\t\t const struct mipi_dsi_msg *msg)\n{\n\tstruct cdns_dsi *dsi = to_cdns_dsi(host);\n\tu32 cmd, sts, val, wait = WRITE_COMPLETED, ctl = 0;\n\tstruct mipi_dsi_packet packet;\n\tint ret, i, tx_len, rx_len;\n\n\tret = pm_runtime_resume_and_get(host->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcdns_dsi_init_link(dsi);\n\n\tret = mipi_dsi_create_packet(&packet, msg);\n\tif (ret)\n\t\tgoto out;\n\n\ttx_len = msg->tx_buf ? msg->tx_len : 0;\n\trx_len = msg->rx_buf ? msg->rx_len : 0;\n\n\t \n\tif (rx_len && tx_len > 2) {\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (tx_len > dsi->direct_cmd_fifo_depth) {\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rx_len > dsi->rx_fifo_depth) {\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tcmd = CMD_SIZE(tx_len) | CMD_VCHAN_ID(msg->channel) |\n\t      CMD_DATATYPE(msg->type);\n\n\tif (msg->flags & MIPI_DSI_MSG_USE_LPM)\n\t\tcmd |= CMD_LP_EN;\n\n\tif (mipi_dsi_packet_format_is_long(msg->type))\n\t\tcmd |= CMD_LONG;\n\n\tif (rx_len) {\n\t\tcmd |= READ_CMD;\n\t\twait = READ_COMPLETED_WITH_ERR | READ_COMPLETED;\n\t\tctl = READ_EN | BTA_EN;\n\t} else if (msg->flags & MIPI_DSI_MSG_REQ_ACK) {\n\t\tcmd |= BTA_REQ;\n\t\twait = ACK_WITH_ERR_RCVD | ACK_RCVD;\n\t\tctl = BTA_EN;\n\t}\n\n\twritel(readl(dsi->regs + MCTL_MAIN_DATA_CTL) | ctl,\n\t       dsi->regs + MCTL_MAIN_DATA_CTL);\n\n\twritel(cmd, dsi->regs + DIRECT_CMD_MAIN_SETTINGS);\n\n\tfor (i = 0; i < tx_len; i += 4) {\n\t\tconst u8 *buf = msg->tx_buf;\n\t\tint j;\n\n\t\tval = 0;\n\t\tfor (j = 0; j < 4 && j + i < tx_len; j++)\n\t\t\tval |= (u32)buf[i + j] << (8 * j);\n\n\t\twritel(val, dsi->regs + DIRECT_CMD_WRDATA);\n\t}\n\n\t \n\twritel(wait, dsi->regs + DIRECT_CMD_STS_CLR);\n\twritel(wait, dsi->regs + DIRECT_CMD_STS_CTL);\n\treinit_completion(&dsi->direct_cmd_comp);\n\twritel(0, dsi->regs + DIRECT_CMD_SEND);\n\n\twait_for_completion_timeout(&dsi->direct_cmd_comp,\n\t\t\t\t    msecs_to_jiffies(1000));\n\n\tsts = readl(dsi->regs + DIRECT_CMD_STS);\n\twritel(wait, dsi->regs + DIRECT_CMD_STS_CLR);\n\twritel(0, dsi->regs + DIRECT_CMD_STS_CTL);\n\n\twritel(readl(dsi->regs + MCTL_MAIN_DATA_CTL) & ~ctl,\n\t       dsi->regs + MCTL_MAIN_DATA_CTL);\n\n\t \n\tif (!(sts & wait)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tif (sts & (READ_COMPLETED_WITH_ERR | ACK_WITH_ERR_RCVD)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < rx_len; i += 4) {\n\t\tu8 *buf = msg->rx_buf;\n\t\tint j;\n\n\t\tval = readl(dsi->regs + DIRECT_CMD_RDDATA);\n\t\tfor (j = 0; j < 4 && j + i < rx_len; j++)\n\t\t\tbuf[i + j] = val >> (8 * j);\n\t}\n\nout:\n\tpm_runtime_put(host->dev);\n\treturn ret;\n}\n\nstatic const struct mipi_dsi_host_ops cdns_dsi_ops = {\n\t.attach = cdns_dsi_attach,\n\t.detach = cdns_dsi_detach,\n\t.transfer = cdns_dsi_transfer,\n};\n\nstatic int __maybe_unused cdns_dsi_resume(struct device *dev)\n{\n\tstruct cdns_dsi *dsi = dev_get_drvdata(dev);\n\n\treset_control_deassert(dsi->dsi_p_rst);\n\tclk_prepare_enable(dsi->dsi_p_clk);\n\tclk_prepare_enable(dsi->dsi_sys_clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cdns_dsi_suspend(struct device *dev)\n{\n\tstruct cdns_dsi *dsi = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(dsi->dsi_sys_clk);\n\tclk_disable_unprepare(dsi->dsi_p_clk);\n\treset_control_assert(dsi->dsi_p_rst);\n\tdsi->link_initialized = false;\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(cdns_dsi_pm_ops, cdns_dsi_suspend, cdns_dsi_resume,\n\t\t\t    NULL);\n\nstatic int cdns_dsi_drm_probe(struct platform_device *pdev)\n{\n\tstruct cdns_dsi *dsi;\n\tstruct cdns_dsi_input *input;\n\tint ret, irq;\n\tu32 val;\n\n\tdsi = devm_kzalloc(&pdev->dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dsi);\n\n\tinput = &dsi->input;\n\n\tdsi->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dsi->regs))\n\t\treturn PTR_ERR(dsi->regs);\n\n\tdsi->dsi_p_clk = devm_clk_get(&pdev->dev, \"dsi_p_clk\");\n\tif (IS_ERR(dsi->dsi_p_clk))\n\t\treturn PTR_ERR(dsi->dsi_p_clk);\n\n\tdsi->dsi_p_rst = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t\"dsi_p_rst\");\n\tif (IS_ERR(dsi->dsi_p_rst))\n\t\treturn PTR_ERR(dsi->dsi_p_rst);\n\n\tdsi->dsi_sys_clk = devm_clk_get(&pdev->dev, \"dsi_sys_clk\");\n\tif (IS_ERR(dsi->dsi_sys_clk))\n\t\treturn PTR_ERR(dsi->dsi_sys_clk);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdsi->dphy = devm_phy_get(&pdev->dev, \"dphy\");\n\tif (IS_ERR(dsi->dphy))\n\t\treturn PTR_ERR(dsi->dphy);\n\n\tret = clk_prepare_enable(dsi->dsi_p_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tval = readl(dsi->regs + ID_REG);\n\tif (REV_VENDOR_ID(val) != 0xcad) {\n\t\tdev_err(&pdev->dev, \"invalid vendor id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_disable_pclk;\n\t}\n\n\tdsi->platform_ops = of_device_get_match_data(&pdev->dev);\n\n\tval = readl(dsi->regs + IP_CONF);\n\tdsi->direct_cmd_fifo_depth = 1 << (DIRCMD_FIFO_DEPTH(val) + 2);\n\tdsi->rx_fifo_depth = RX_FIFO_DEPTH(val);\n\tinit_completion(&dsi->direct_cmd_comp);\n\n\twritel(0, dsi->regs + MCTL_MAIN_DATA_CTL);\n\twritel(0, dsi->regs + MCTL_MAIN_EN);\n\twritel(0, dsi->regs + MCTL_MAIN_PHY_CTL);\n\n\t \n\tinput->id = CDNS_DPI_INPUT;\n\tinput->bridge.funcs = &cdns_dsi_bridge_funcs;\n\tinput->bridge.of_node = pdev->dev.of_node;\n\n\t \n\twritel(0, dsi->regs + MCTL_MAIN_STS_CTL);\n\twritel(0, dsi->regs + MCTL_DPHY_ERR_CTL1);\n\twritel(0, dsi->regs + CMD_MODE_STS_CTL);\n\twritel(0, dsi->regs + DIRECT_CMD_STS_CTL);\n\twritel(0, dsi->regs + DIRECT_CMD_RD_STS_CTL);\n\twritel(0, dsi->regs + VID_MODE_STS_CTL);\n\twritel(0, dsi->regs + TVG_STS_CTL);\n\twritel(0, dsi->regs + DPI_IRQ_EN);\n\tret = devm_request_irq(&pdev->dev, irq, cdns_dsi_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), dsi);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\tpm_runtime_enable(&pdev->dev);\n\tdsi->base.dev = &pdev->dev;\n\tdsi->base.ops = &cdns_dsi_ops;\n\n\tif (dsi->platform_ops && dsi->platform_ops->init) {\n\t\tret = dsi->platform_ops->init(dsi);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&pdev->dev, \"platform initialization failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_disable_runtime_pm;\n\t\t}\n\t}\n\n\tret = mipi_dsi_host_register(&dsi->base);\n\tif (ret)\n\t\tgoto err_deinit_platform;\n\n\tclk_disable_unprepare(dsi->dsi_p_clk);\n\n\treturn 0;\n\nerr_deinit_platform:\n\tif (dsi->platform_ops && dsi->platform_ops->deinit)\n\t\tdsi->platform_ops->deinit(dsi);\n\nerr_disable_runtime_pm:\n\tpm_runtime_disable(&pdev->dev);\n\nerr_disable_pclk:\n\tclk_disable_unprepare(dsi->dsi_p_clk);\n\n\treturn ret;\n}\n\nstatic void cdns_dsi_drm_remove(struct platform_device *pdev)\n{\n\tstruct cdns_dsi *dsi = platform_get_drvdata(pdev);\n\n\tmipi_dsi_host_unregister(&dsi->base);\n\n\tif (dsi->platform_ops && dsi->platform_ops->deinit)\n\t\tdsi->platform_ops->deinit(dsi);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id cdns_dsi_of_match[] = {\n\t{ .compatible = \"cdns,dsi\" },\n#ifdef CONFIG_DRM_CDNS_DSI_J721E\n\t{ .compatible = \"ti,j721e-dsi\", .data = &dsi_ti_j721e_ops, },\n#endif\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, cdns_dsi_of_match);\n\nstatic struct platform_driver cdns_dsi_platform_driver = {\n\t.probe  = cdns_dsi_drm_probe,\n\t.remove_new = cdns_dsi_drm_remove,\n\t.driver = {\n\t\t.name   = \"cdns-dsi\",\n\t\t.of_match_table = cdns_dsi_of_match,\n\t\t.pm = &cdns_dsi_pm_ops,\n\t},\n};\nmodule_platform_driver(cdns_dsi_platform_driver);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@bootlin.com>\");\nMODULE_DESCRIPTION(\"Cadence DSI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:cdns-dsi\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}