{
  "module_name": "cdns-mhdp8546-core.c",
  "hash_id": "2cd171aaa5408bb365fd84e096aefddbde02d175eab46dcac9af803052b9055a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/cadence/cdns-mhdp8546-core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/firmware.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/irq.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/phy-dp.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include <asm/unaligned.h>\n\n#include \"cdns-mhdp8546-core.h\"\n#include \"cdns-mhdp8546-hdcp.h\"\n#include \"cdns-mhdp8546-j721e.h\"\n\nstatic void cdns_mhdp_bridge_hpd_enable(struct drm_bridge *bridge)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\n\t \n\tif (mhdp->bridge_attached)\n\t\twritel(readl(mhdp->regs + CDNS_APB_INT_MASK) &\n\t\t       ~CDNS_APB_INT_MASK_SW_EVENT_INT,\n\t\t       mhdp->regs + CDNS_APB_INT_MASK);\n}\n\nstatic void cdns_mhdp_bridge_hpd_disable(struct drm_bridge *bridge)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\n\twritel(readl(mhdp->regs + CDNS_APB_INT_MASK) |\n\t       CDNS_APB_INT_MASK_SW_EVENT_INT,\n\t       mhdp->regs + CDNS_APB_INT_MASK);\n}\n\nstatic int cdns_mhdp_mailbox_read(struct cdns_mhdp_device *mhdp)\n{\n\tint ret, empty;\n\n\tWARN_ON(!mutex_is_locked(&mhdp->mbox_mutex));\n\n\tret = readx_poll_timeout(readl, mhdp->regs + CDNS_MAILBOX_EMPTY,\n\t\t\t\t empty, !empty, MAILBOX_RETRY_US,\n\t\t\t\t MAILBOX_TIMEOUT_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn readl(mhdp->regs + CDNS_MAILBOX_RX_DATA) & 0xff;\n}\n\nstatic int cdns_mhdp_mailbox_write(struct cdns_mhdp_device *mhdp, u8 val)\n{\n\tint ret, full;\n\n\tWARN_ON(!mutex_is_locked(&mhdp->mbox_mutex));\n\n\tret = readx_poll_timeout(readl, mhdp->regs + CDNS_MAILBOX_FULL,\n\t\t\t\t full, !full, MAILBOX_RETRY_US,\n\t\t\t\t MAILBOX_TIMEOUT_US);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(val, mhdp->regs + CDNS_MAILBOX_TX_DATA);\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_mailbox_recv_header(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t u8 module_id, u8 opcode,\n\t\t\t\t\t u16 req_size)\n{\n\tu32 mbox_size, i;\n\tu8 header[4];\n\tint ret;\n\n\t \n\tfor (i = 0; i < sizeof(header); i++) {\n\t\tret = cdns_mhdp_mailbox_read(mhdp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\theader[i] = ret;\n\t}\n\n\tmbox_size = get_unaligned_be16(header + 2);\n\n\tif (opcode != header[0] || module_id != header[1] ||\n\t    req_size != mbox_size) {\n\t\t \n\t\tfor (i = 0; i < mbox_size; i++)\n\t\t\tif (cdns_mhdp_mailbox_read(mhdp) < 0)\n\t\t\t\tbreak;\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_mailbox_recv_data(struct cdns_mhdp_device *mhdp,\n\t\t\t\t       u8 *buff, u16 buff_size)\n{\n\tu32 i;\n\tint ret;\n\n\tfor (i = 0; i < buff_size; i++) {\n\t\tret = cdns_mhdp_mailbox_read(mhdp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbuff[i] = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns_mhdp_mailbox_send(struct cdns_mhdp_device *mhdp, u8 module_id,\n\t\t\t\t  u8 opcode, u16 size, u8 *message)\n{\n\tu8 header[4];\n\tint ret, i;\n\n\theader[0] = opcode;\n\theader[1] = module_id;\n\tput_unaligned_be16(size, header + 2);\n\n\tfor (i = 0; i < sizeof(header); i++) {\n\t\tret = cdns_mhdp_mailbox_write(mhdp, header[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\tret = cdns_mhdp_mailbox_write(mhdp, message[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic\nint cdns_mhdp_reg_read(struct cdns_mhdp_device *mhdp, u32 addr, u32 *value)\n{\n\tu8 msg[4], resp[8];\n\tint ret;\n\n\tput_unaligned_be32(addr, msg);\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_GENERAL,\n\t\t\t\t     GENERAL_REGISTER_READ,\n\t\t\t\t     sizeof(msg), msg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_GENERAL,\n\t\t\t\t\t    GENERAL_REGISTER_READ,\n\t\t\t\t\t    sizeof(resp));\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, resp, sizeof(resp));\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (memcmp(msg, resp, sizeof(msg))) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*value = get_unaligned_be32(resp + 4);\n\nout:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\tif (ret) {\n\t\tdev_err(mhdp->dev, \"Failed to read register\\n\");\n\t\t*value = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_reg_write(struct cdns_mhdp_device *mhdp, u16 addr, u32 val)\n{\n\tu8 msg[6];\n\tint ret;\n\n\tput_unaligned_be16(addr, msg);\n\tput_unaligned_be32(val, msg + 2);\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_WRITE_REGISTER, sizeof(msg), msg);\n\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_reg_write_bit(struct cdns_mhdp_device *mhdp, u16 addr,\n\t\t\t    u8 start_bit, u8 bits_no, u32 val)\n{\n\tu8 field[8];\n\tint ret;\n\n\tput_unaligned_be16(addr, field);\n\tfield[2] = start_bit;\n\tfield[3] = bits_no;\n\tput_unaligned_be32(val, field + 4);\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_WRITE_FIELD, sizeof(field), field);\n\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_dpcd_read(struct cdns_mhdp_device *mhdp,\n\t\t\tu32 addr, u8 *data, u16 len)\n{\n\tu8 msg[5], reg[5];\n\tint ret;\n\n\tput_unaligned_be16(len, msg);\n\tput_unaligned_be24(addr, msg + 2);\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_READ_DPCD, sizeof(msg), msg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t    DPTX_READ_DPCD,\n\t\t\t\t\t    sizeof(reg) + len);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, reg, sizeof(reg));\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, data, len);\n\nout:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_dpcd_write(struct cdns_mhdp_device *mhdp, u32 addr, u8 value)\n{\n\tu8 msg[6], reg[5];\n\tint ret;\n\n\tput_unaligned_be16(1, msg);\n\tput_unaligned_be24(addr, msg + 2);\n\tmsg[5] = value;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_WRITE_DPCD, sizeof(msg), msg);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t    DPTX_WRITE_DPCD, sizeof(reg));\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, reg, sizeof(reg));\n\tif (ret)\n\t\tgoto out;\n\n\tif (addr != get_unaligned_be24(reg + 2))\n\t\tret = -EINVAL;\n\nout:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\tif (ret)\n\t\tdev_err(mhdp->dev, \"dpcd write failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_set_firmware_active(struct cdns_mhdp_device *mhdp, bool enable)\n{\n\tu8 msg[5];\n\tint ret, i;\n\n\tmsg[0] = GENERAL_MAIN_CONTROL;\n\tmsg[1] = MB_MODULE_ID_GENERAL;\n\tmsg[2] = 0;\n\tmsg[3] = 1;\n\tmsg[4] = enable ? FW_ACTIVE : FW_STANDBY;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tfor (i = 0; i < sizeof(msg); i++) {\n\t\tret = cdns_mhdp_mailbox_write(mhdp, msg[i]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = cdns_mhdp_mailbox_recv_data(mhdp, msg, sizeof(msg));\n\tif (ret)\n\t\tgoto out;\n\n\tret = 0;\n\nout:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\tif (ret < 0)\n\t\tdev_err(mhdp->dev, \"set firmware active failed\\n\");\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_get_hpd_status(struct cdns_mhdp_device *mhdp)\n{\n\tu8 status;\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_HPD_STATE, 0, NULL);\n\tif (ret)\n\t\tgoto err_get_hpd;\n\n\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t    DPTX_HPD_STATE,\n\t\t\t\t\t    sizeof(status));\n\tif (ret)\n\t\tgoto err_get_hpd;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, &status, sizeof(status));\n\tif (ret)\n\t\tgoto err_get_hpd;\n\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\tdev_dbg(mhdp->dev, \"%s: HPD %splugged\\n\", __func__,\n\t\tstatus ? \"\" : \"un\");\n\n\treturn status;\n\nerr_get_hpd:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_get_edid_block(void *data, u8 *edid,\n\t\t\t     unsigned int block, size_t length)\n{\n\tstruct cdns_mhdp_device *mhdp = data;\n\tu8 msg[2], reg[2], i;\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tmsg[0] = block / 2;\n\t\tmsg[1] = block % 2;\n\n\t\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t     DPTX_GET_EDID, sizeof(msg), msg);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t\t    DPTX_GET_EDID,\n\t\t\t\t\t\t    sizeof(reg) + length);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = cdns_mhdp_mailbox_recv_data(mhdp, reg, sizeof(reg));\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret = cdns_mhdp_mailbox_recv_data(mhdp, edid, length);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (reg[0] == length && reg[1] == block / 2)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\tif (ret)\n\t\tdev_err(mhdp->dev, \"get block[%d] edid failed: %d\\n\",\n\t\t\tblock, ret);\n\n\treturn ret;\n}\n\nstatic\nint cdns_mhdp_read_hpd_event(struct cdns_mhdp_device *mhdp)\n{\n\tu8 event = 0;\n\tint ret;\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_READ_EVENT, 0, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t    DPTX_READ_EVENT, sizeof(event));\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, &event, sizeof(event));\nout:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(mhdp->dev, \"%s: %s%s%s%s\\n\", __func__,\n\t\t(event & DPTX_READ_EVENT_HPD_TO_HIGH) ? \"TO_HIGH \" : \"\",\n\t\t(event & DPTX_READ_EVENT_HPD_TO_LOW) ? \"TO_LOW \" : \"\",\n\t\t(event & DPTX_READ_EVENT_HPD_PULSE) ? \"PULSE \" : \"\",\n\t\t(event & DPTX_READ_EVENT_HPD_STATE) ? \"HPD_STATE \" : \"\");\n\n\treturn event;\n}\n\nstatic\nint cdns_mhdp_adjust_lt(struct cdns_mhdp_device *mhdp, unsigned int nlanes,\n\t\t\tunsigned int udelay, const u8 *lanes_data,\n\t\t\tu8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tu8 payload[7];\n\tu8 hdr[5];  \n\tu32 addr;\n\tint ret;\n\n\tif (nlanes != 4 && nlanes != 2 && nlanes != 1) {\n\t\tdev_err(mhdp->dev, \"invalid number of lanes: %u\\n\", nlanes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpayload[0] = nlanes;\n\tput_unaligned_be16(udelay, payload + 1);\n\tmemcpy(payload + 3, lanes_data, nlanes);\n\n\tmutex_lock(&mhdp->mbox_mutex);\n\n\tret = cdns_mhdp_mailbox_send(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t     DPTX_ADJUST_LT,\n\t\t\t\t     sizeof(payload), payload);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = cdns_mhdp_mailbox_recv_header(mhdp, MB_MODULE_ID_DP_TX,\n\t\t\t\t\t    DPTX_READ_DPCD,\n\t\t\t\t\t    sizeof(hdr) + DP_LINK_STATUS_SIZE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, hdr, sizeof(hdr));\n\tif (ret)\n\t\tgoto out;\n\n\taddr = get_unaligned_be24(hdr + 2);\n\tif (addr != DP_LANE0_1_STATUS)\n\t\tgoto out;\n\n\tret = cdns_mhdp_mailbox_recv_data(mhdp, link_status,\n\t\t\t\t\t  DP_LINK_STATUS_SIZE);\n\nout:\n\tmutex_unlock(&mhdp->mbox_mutex);\n\n\tif (ret)\n\t\tdev_err(mhdp->dev, \"Failed to adjust Link Training.\\n\");\n\n\treturn ret;\n}\n\n \nstatic\nint cdns_mhdp_link_power_up(struct drm_dp_aux *aux, struct cdns_mhdp_link *link)\n{\n\tu8 value;\n\tint err;\n\n\t \n\tif (link->revision < 0x11)\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= DP_SET_POWER_D0;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tusleep_range(1000, 2000);\n\n\treturn 0;\n}\n\n \nstatic\nint cdns_mhdp_link_power_down(struct drm_dp_aux *aux,\n\t\t\t      struct cdns_mhdp_link *link)\n{\n\tu8 value;\n\tint err;\n\n\t \n\tif (link->revision < 0x11)\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_SET_POWER, &value);\n\tif (err < 0)\n\t\treturn err;\n\n\tvalue &= ~DP_SET_POWER_MASK;\n\tvalue |= DP_SET_POWER_D3;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_SET_POWER, value);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic\nint cdns_mhdp_link_configure(struct drm_dp_aux *aux,\n\t\t\t     struct cdns_mhdp_link *link)\n{\n\tu8 values[2];\n\tint err;\n\n\tvalues[0] = drm_dp_link_rate_to_bw_code(link->rate);\n\tvalues[1] = link->num_lanes;\n\n\tif (link->capabilities & DP_LINK_CAP_ENHANCED_FRAMING)\n\t\tvalues[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\n\terr = drm_dp_dpcd_write(aux, DP_LINK_BW_SET, values, sizeof(values));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic unsigned int cdns_mhdp_max_link_rate(struct cdns_mhdp_device *mhdp)\n{\n\treturn min(mhdp->host.link_rate, mhdp->sink.link_rate);\n}\n\nstatic u8 cdns_mhdp_max_num_lanes(struct cdns_mhdp_device *mhdp)\n{\n\treturn min(mhdp->sink.lanes_cnt, mhdp->host.lanes_cnt);\n}\n\nstatic u8 cdns_mhdp_eq_training_pattern_supported(struct cdns_mhdp_device *mhdp)\n{\n\treturn fls(mhdp->host.pattern_supp & mhdp->sink.pattern_supp);\n}\n\nstatic bool cdns_mhdp_get_ssc_supported(struct cdns_mhdp_device *mhdp)\n{\n\t \n\treturn mhdp->host.ssc && mhdp->sink.ssc;\n}\n\nstatic enum drm_connector_status cdns_mhdp_detect(struct cdns_mhdp_device *mhdp)\n{\n\tdev_dbg(mhdp->dev, \"%s: %d\\n\", __func__, mhdp->plugged);\n\n\tif (mhdp->plugged)\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic int cdns_mhdp_check_fw_version(struct cdns_mhdp_device *mhdp)\n{\n\tu32 major_num, minor_num, revision;\n\tu32 fw_ver, lib_ver;\n\n\tfw_ver = (readl(mhdp->regs + CDNS_VER_H) << 8)\n\t       | readl(mhdp->regs + CDNS_VER_L);\n\n\tlib_ver = (readl(mhdp->regs + CDNS_LIB_H_ADDR) << 8)\n\t\t| readl(mhdp->regs + CDNS_LIB_L_ADDR);\n\n\tif (lib_ver < 33984) {\n\t\t \n\t\tmajor_num = 1;\n\t\tminor_num = 2;\n\t\tif (fw_ver == 26098) {\n\t\t\trevision = 15;\n\t\t} else if (lib_ver == 0 && fw_ver == 0) {\n\t\t\trevision = 17;\n\t\t} else {\n\t\t\tdev_err(mhdp->dev, \"Unsupported FW version: fw_ver = %u, lib_ver = %u\\n\",\n\t\t\t\tfw_ver, lib_ver);\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\t \n\t\tmajor_num = fw_ver / 10000;\n\t\tminor_num = (fw_ver / 100) % 100;\n\t\trevision = (fw_ver % 10000) % 100;\n\t}\n\n\tdev_dbg(mhdp->dev, \"FW version: v%u.%u.%u\\n\", major_num, minor_num,\n\t\trevision);\n\treturn 0;\n}\n\nstatic int cdns_mhdp_fw_activate(const struct firmware *fw,\n\t\t\t\t struct cdns_mhdp_device *mhdp)\n{\n\tunsigned int reg;\n\tint ret;\n\n\t \n\twritel(CDNS_CPU_STALL, mhdp->regs + CDNS_APB_CTRL);\n\n\tmemcpy_toio(mhdp->regs + CDNS_MHDP_IMEM, fw->data, fw->size);\n\n\t \n\twritel(0, mhdp->regs + CDNS_APB_CTRL);\n\n\t \n\tret = readl_poll_timeout(mhdp->regs + CDNS_KEEP_ALIVE, reg,\n\t\t\t\t reg & CDNS_KEEP_ALIVE_MASK, 500,\n\t\t\t\t CDNS_KEEP_ALIVE_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(mhdp->dev,\n\t\t\t\"device didn't give any life sign: reg %d\\n\", reg);\n\t\treturn ret;\n\t}\n\n\tret = cdns_mhdp_check_fw_version(mhdp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treadl(mhdp->regs + CDNS_SW_EVENT0);\n\treadl(mhdp->regs + CDNS_SW_EVENT1);\n\treadl(mhdp->regs + CDNS_SW_EVENT2);\n\treadl(mhdp->regs + CDNS_SW_EVENT3);\n\n\t \n\tret = cdns_mhdp_set_firmware_active(mhdp, true);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&mhdp->start_lock);\n\n\tmhdp->hw_state = MHDP_HW_READY;\n\n\t \n\tcdns_mhdp_bridge_hpd_enable(&mhdp->bridge);\n\n\tspin_unlock(&mhdp->start_lock);\n\n\twake_up(&mhdp->fw_load_wq);\n\tdev_dbg(mhdp->dev, \"DP FW activated\\n\");\n\n\treturn 0;\n}\n\nstatic void cdns_mhdp_fw_cb(const struct firmware *fw, void *context)\n{\n\tstruct cdns_mhdp_device *mhdp = context;\n\tbool bridge_attached;\n\tint ret;\n\n\tdev_dbg(mhdp->dev, \"firmware callback\\n\");\n\n\tif (!fw || !fw->data) {\n\t\tdev_err(mhdp->dev, \"%s: No firmware.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tret = cdns_mhdp_fw_activate(fw, mhdp);\n\n\trelease_firmware(fw);\n\n\tif (ret)\n\t\treturn;\n\n\t \n\tspin_lock(&mhdp->start_lock);\n\tbridge_attached = mhdp->bridge_attached;\n\tspin_unlock(&mhdp->start_lock);\n\tif (bridge_attached) {\n\t\tif (mhdp->connector.dev)\n\t\t\tdrm_kms_helper_hotplug_event(mhdp->bridge.dev);\n\t\telse\n\t\t\tdrm_bridge_hpd_notify(&mhdp->bridge, cdns_mhdp_detect(mhdp));\n\t}\n}\n\nstatic int cdns_mhdp_load_firmware(struct cdns_mhdp_device *mhdp)\n{\n\tint ret;\n\n\tret = request_firmware_nowait(THIS_MODULE, true, FW_NAME, mhdp->dev,\n\t\t\t\t      GFP_KERNEL, mhdp, cdns_mhdp_fw_cb);\n\tif (ret) {\n\t\tdev_err(mhdp->dev, \"failed to load firmware (%s), ret: %d\\n\",\n\t\t\tFW_NAME, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t cdns_mhdp_transfer(struct drm_dp_aux *aux,\n\t\t\t\t  struct drm_dp_aux_msg *msg)\n{\n\tstruct cdns_mhdp_device *mhdp = dev_get_drvdata(aux->dev);\n\tint ret;\n\n\tif (msg->request != DP_AUX_NATIVE_WRITE &&\n\t    msg->request != DP_AUX_NATIVE_READ)\n\t\treturn -EOPNOTSUPP;\n\n\tif (msg->request == DP_AUX_NATIVE_WRITE) {\n\t\tconst u8 *buf = msg->buffer;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; i < msg->size; ++i) {\n\t\t\tret = cdns_mhdp_dpcd_write(mhdp,\n\t\t\t\t\t\t   msg->address + i, buf[i]);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tdev_err(mhdp->dev,\n\t\t\t\t\"Failed to write DPCD addr %u\\n\",\n\t\t\t\tmsg->address + i);\n\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = cdns_mhdp_dpcd_read(mhdp, msg->address,\n\t\t\t\t\t  msg->buffer, msg->size);\n\t\tif (ret) {\n\t\t\tdev_err(mhdp->dev,\n\t\t\t\t\"Failed to read DPCD addr %u\\n\",\n\t\t\t\tmsg->address);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn msg->size;\n}\n\nstatic int cdns_mhdp_link_training_init(struct cdns_mhdp_device *mhdp)\n{\n\tunion phy_configure_opts phy_cfg;\n\tu32 reg32;\n\tint ret;\n\n\tdrm_dp_dpcd_writeb(&mhdp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\n\t \n\treg32 = CDNS_PHY_COMMON_CONFIG | CDNS_PHY_TRAINING_TYPE(1);\n\tif (!mhdp->host.scrambler)\n\t\treg32 |= CDNS_PHY_SCRAMBLER_BYPASS;\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_PHY_CONFIG, reg32);\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_ENHNCD,\n\t\t\t    mhdp->sink.enhanced & mhdp->host.enhanced);\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_LANE_EN,\n\t\t\t    CDNS_DP_LANE_EN_LANES(mhdp->link.num_lanes));\n\n\tcdns_mhdp_link_configure(&mhdp->aux, &mhdp->link);\n\tphy_cfg.dp.link_rate = mhdp->link.rate / 100;\n\tphy_cfg.dp.lanes = mhdp->link.num_lanes;\n\n\tmemset(phy_cfg.dp.voltage, 0, sizeof(phy_cfg.dp.voltage));\n\tmemset(phy_cfg.dp.pre, 0, sizeof(phy_cfg.dp.pre));\n\n\tphy_cfg.dp.ssc = cdns_mhdp_get_ssc_supported(mhdp);\n\tphy_cfg.dp.set_lanes = true;\n\tphy_cfg.dp.set_rate = true;\n\tphy_cfg.dp.set_voltages = true;\n\tret = phy_configure(mhdp->phy,  &phy_cfg);\n\tif (ret) {\n\t\tdev_err(mhdp->dev, \"%s: phy_configure() failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_PHY_CONFIG,\n\t\t\t    CDNS_PHY_COMMON_CONFIG |\n\t\t\t    CDNS_PHY_TRAINING_EN |\n\t\t\t    CDNS_PHY_TRAINING_TYPE(1) |\n\t\t\t    CDNS_PHY_SCRAMBLER_BYPASS);\n\n\tdrm_dp_dpcd_writeb(&mhdp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_1 | DP_LINK_SCRAMBLING_DISABLE);\n\n\treturn 0;\n}\n\nstatic void cdns_mhdp_get_adjust_train(struct cdns_mhdp_device *mhdp,\n\t\t\t\t       u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t       u8 lanes_data[CDNS_DP_MAX_NUM_LANES],\n\t\t\t\t       union phy_configure_opts *phy_cfg)\n{\n\tu8 adjust, max_pre_emph, max_volt_swing;\n\tu8 set_volt, set_pre;\n\tunsigned int i;\n\n\tmax_pre_emph = CDNS_PRE_EMPHASIS(mhdp->host.pre_emphasis)\n\t\t\t   << DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\tmax_volt_swing = CDNS_VOLT_SWING(mhdp->host.volt_swing);\n\n\tfor (i = 0; i < mhdp->link.num_lanes; i++) {\n\t\t \n\t\tadjust = drm_dp_get_adjust_request_voltage(link_status, i);\n\t\tset_volt = min(adjust, max_volt_swing);\n\n\t\tadjust = drm_dp_get_adjust_request_pre_emphasis(link_status, i);\n\t\tset_pre = min(adjust, max_pre_emph)\n\t\t\t  >> DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\t\t \n\t\tif (set_volt + set_pre > 3)\n\t\t\tset_volt = 3 - set_pre;\n\n\t\tphy_cfg->dp.voltage[i] = set_volt;\n\t\tlanes_data[i] = set_volt;\n\n\t\tif (set_volt == max_volt_swing)\n\t\t\tlanes_data[i] |= DP_TRAIN_MAX_SWING_REACHED;\n\n\t\tphy_cfg->dp.pre[i] = set_pre;\n\t\tlanes_data[i] |= (set_pre << DP_TRAIN_PRE_EMPHASIS_SHIFT);\n\n\t\tif (set_pre == (max_pre_emph >> DP_TRAIN_PRE_EMPHASIS_SHIFT))\n\t\t\tlanes_data[i] |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\t}\n}\n\nstatic\nvoid cdns_mhdp_set_adjust_request_voltage(u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t  unsigned int lane, u8 volt)\n{\n\tunsigned int s = ((lane & 1) ?\n\t\t\t  DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :\n\t\t\t  DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);\n\tunsigned int idx = DP_ADJUST_REQUEST_LANE0_1 - DP_LANE0_1_STATUS + (lane >> 1);\n\n\tlink_status[idx] &= ~(DP_ADJUST_VOLTAGE_SWING_LANE0_MASK << s);\n\tlink_status[idx] |= volt << s;\n}\n\nstatic\nvoid cdns_mhdp_set_adjust_request_pre_emphasis(u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t       unsigned int lane, u8 pre_emphasis)\n{\n\tunsigned int s = ((lane & 1) ?\n\t\t\t  DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :\n\t\t\t  DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);\n\tunsigned int idx = DP_ADJUST_REQUEST_LANE0_1 - DP_LANE0_1_STATUS + (lane >> 1);\n\n\tlink_status[idx] &= ~(DP_ADJUST_PRE_EMPHASIS_LANE0_MASK << s);\n\tlink_status[idx] |= pre_emphasis << s;\n}\n\nstatic void cdns_mhdp_adjust_requested_eq(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t  u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tu8 max_pre = CDNS_PRE_EMPHASIS(mhdp->host.pre_emphasis);\n\tu8 max_volt = CDNS_VOLT_SWING(mhdp->host.volt_swing);\n\tunsigned int i;\n\tu8 volt, pre;\n\n\tfor (i = 0; i < mhdp->link.num_lanes; i++) {\n\t\tvolt = drm_dp_get_adjust_request_voltage(link_status, i);\n\t\tpre = drm_dp_get_adjust_request_pre_emphasis(link_status, i);\n\t\tif (volt + pre > 3)\n\t\t\tcdns_mhdp_set_adjust_request_voltage(link_status, i,\n\t\t\t\t\t\t\t     3 - pre);\n\t\tif (mhdp->host.volt_swing & CDNS_FORCE_VOLT_SWING)\n\t\t\tcdns_mhdp_set_adjust_request_voltage(link_status, i,\n\t\t\t\t\t\t\t     max_volt);\n\t\tif (mhdp->host.pre_emphasis & CDNS_FORCE_PRE_EMPHASIS)\n\t\t\tcdns_mhdp_set_adjust_request_pre_emphasis(link_status,\n\t\t\t\t\t\t\t\t  i, max_pre);\n\t}\n}\n\nstatic void cdns_mhdp_print_lt_status(const char *prefix,\n\t\t\t\t      struct cdns_mhdp_device *mhdp,\n\t\t\t\t      union phy_configure_opts *phy_cfg)\n{\n\tchar vs[8] = \"0/0/0/0\";\n\tchar pe[8] = \"0/0/0/0\";\n\tunsigned int i;\n\n\tfor (i = 0; i < mhdp->link.num_lanes; i++) {\n\t\tvs[i * 2] = '0' + phy_cfg->dp.voltage[i];\n\t\tpe[i * 2] = '0' + phy_cfg->dp.pre[i];\n\t}\n\n\tvs[i * 2 - 1] = '\\0';\n\tpe[i * 2 - 1] = '\\0';\n\n\tdev_dbg(mhdp->dev, \"%s, %u lanes, %u Mbps, vs %s, pe %s\\n\",\n\t\tprefix,\n\t\tmhdp->link.num_lanes, mhdp->link.rate / 100,\n\t\tvs, pe);\n}\n\nstatic bool cdns_mhdp_link_training_channel_eq(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t       u8 eq_tps,\n\t\t\t\t\t       unsigned int training_interval)\n{\n\tu8 lanes_data[CDNS_DP_MAX_NUM_LANES], fail_counter_short = 0;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tunion phy_configure_opts phy_cfg;\n\tu32 reg32;\n\tint ret;\n\tbool r;\n\n\tdev_dbg(mhdp->dev, \"Starting EQ phase\\n\");\n\n\t \n\treg32 = CDNS_PHY_COMMON_CONFIG | CDNS_PHY_TRAINING_EN |\n\t\tCDNS_PHY_TRAINING_TYPE(eq_tps);\n\tif (eq_tps != 4)\n\t\treg32 |= CDNS_PHY_SCRAMBLER_BYPASS;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_PHY_CONFIG, reg32);\n\n\tdrm_dp_dpcd_writeb(&mhdp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   (eq_tps != 4) ? eq_tps | DP_LINK_SCRAMBLING_DISABLE :\n\t\t\t   CDNS_DP_TRAINING_PATTERN_4);\n\n\tdrm_dp_dpcd_read_link_status(&mhdp->aux, link_status);\n\n\tdo {\n\t\tcdns_mhdp_get_adjust_train(mhdp, link_status, lanes_data,\n\t\t\t\t\t   &phy_cfg);\n\t\tphy_cfg.dp.lanes = mhdp->link.num_lanes;\n\t\tphy_cfg.dp.ssc = cdns_mhdp_get_ssc_supported(mhdp);\n\t\tphy_cfg.dp.set_lanes = false;\n\t\tphy_cfg.dp.set_rate = false;\n\t\tphy_cfg.dp.set_voltages = true;\n\t\tret = phy_configure(mhdp->phy,  &phy_cfg);\n\t\tif (ret) {\n\t\t\tdev_err(mhdp->dev, \"%s: phy_configure() failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcdns_mhdp_adjust_lt(mhdp, mhdp->link.num_lanes,\n\t\t\t\t    training_interval, lanes_data, link_status);\n\n\t\tr = drm_dp_clock_recovery_ok(link_status, mhdp->link.num_lanes);\n\t\tif (!r)\n\t\t\tgoto err;\n\n\t\tif (drm_dp_channel_eq_ok(link_status, mhdp->link.num_lanes)) {\n\t\t\tcdns_mhdp_print_lt_status(\"EQ phase ok\", mhdp,\n\t\t\t\t\t\t  &phy_cfg);\n\t\t\treturn true;\n\t\t}\n\n\t\tfail_counter_short++;\n\n\t\tcdns_mhdp_adjust_requested_eq(mhdp, link_status);\n\t} while (fail_counter_short < 5);\n\nerr:\n\tcdns_mhdp_print_lt_status(\"EQ phase failed\", mhdp, &phy_cfg);\n\n\treturn false;\n}\n\nstatic void cdns_mhdp_adjust_requested_cr(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t  u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t  u8 *req_volt, u8 *req_pre)\n{\n\tconst u8 max_volt = CDNS_VOLT_SWING(mhdp->host.volt_swing);\n\tconst u8 max_pre = CDNS_PRE_EMPHASIS(mhdp->host.pre_emphasis);\n\tunsigned int i;\n\n\tfor (i = 0; i < mhdp->link.num_lanes; i++) {\n\t\tu8 val;\n\n\t\tval = mhdp->host.volt_swing & CDNS_FORCE_VOLT_SWING ?\n\t\t      max_volt : req_volt[i];\n\t\tcdns_mhdp_set_adjust_request_voltage(link_status, i, val);\n\n\t\tval = mhdp->host.pre_emphasis & CDNS_FORCE_PRE_EMPHASIS ?\n\t\t      max_pre : req_pre[i];\n\t\tcdns_mhdp_set_adjust_request_pre_emphasis(link_status, i, val);\n\t}\n}\n\nstatic\nvoid cdns_mhdp_validate_cr(struct cdns_mhdp_device *mhdp, bool *cr_done,\n\t\t\t   bool *same_before_adjust, bool *max_swing_reached,\n\t\t\t   u8 before_cr[CDNS_DP_MAX_NUM_LANES],\n\t\t\t   u8 after_cr[DP_LINK_STATUS_SIZE], u8 *req_volt,\n\t\t\t   u8 *req_pre)\n{\n\tconst u8 max_volt = CDNS_VOLT_SWING(mhdp->host.volt_swing);\n\tconst u8 max_pre = CDNS_PRE_EMPHASIS(mhdp->host.pre_emphasis);\n\tbool same_pre, same_volt;\n\tunsigned int i;\n\tu8 adjust;\n\n\t*same_before_adjust = false;\n\t*max_swing_reached = false;\n\t*cr_done = drm_dp_clock_recovery_ok(after_cr, mhdp->link.num_lanes);\n\n\tfor (i = 0; i < mhdp->link.num_lanes; i++) {\n\t\tadjust = drm_dp_get_adjust_request_voltage(after_cr, i);\n\t\treq_volt[i] = min(adjust, max_volt);\n\n\t\tadjust = drm_dp_get_adjust_request_pre_emphasis(after_cr, i) >>\n\t\t      DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\t\treq_pre[i] = min(adjust, max_pre);\n\n\t\tsame_pre = (before_cr[i] & DP_TRAIN_PRE_EMPHASIS_MASK) ==\n\t\t\t   req_pre[i] << DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\t\tsame_volt = (before_cr[i] & DP_TRAIN_VOLTAGE_SWING_MASK) ==\n\t\t\t    req_volt[i];\n\t\tif (same_pre && same_volt)\n\t\t\t*same_before_adjust = true;\n\n\t\t \n\t\tif (!*cr_done && req_volt[i] + req_pre[i] >= 3) {\n\t\t\t*max_swing_reached = true;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic bool cdns_mhdp_link_training_cr(struct cdns_mhdp_device *mhdp)\n{\n\tu8 lanes_data[CDNS_DP_MAX_NUM_LANES],\n\tfail_counter_short = 0, fail_counter_cr_long = 0;\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tbool cr_done;\n\tunion phy_configure_opts phy_cfg;\n\tint ret;\n\n\tdev_dbg(mhdp->dev, \"Starting CR phase\\n\");\n\n\tret = cdns_mhdp_link_training_init(mhdp);\n\tif (ret)\n\t\tgoto err;\n\n\tdrm_dp_dpcd_read_link_status(&mhdp->aux, link_status);\n\n\tdo {\n\t\tu8 requested_adjust_volt_swing[CDNS_DP_MAX_NUM_LANES] = {};\n\t\tu8 requested_adjust_pre_emphasis[CDNS_DP_MAX_NUM_LANES] = {};\n\t\tbool same_before_adjust, max_swing_reached;\n\n\t\tcdns_mhdp_get_adjust_train(mhdp, link_status, lanes_data,\n\t\t\t\t\t   &phy_cfg);\n\t\tphy_cfg.dp.lanes = mhdp->link.num_lanes;\n\t\tphy_cfg.dp.ssc = cdns_mhdp_get_ssc_supported(mhdp);\n\t\tphy_cfg.dp.set_lanes = false;\n\t\tphy_cfg.dp.set_rate = false;\n\t\tphy_cfg.dp.set_voltages = true;\n\t\tret = phy_configure(mhdp->phy,  &phy_cfg);\n\t\tif (ret) {\n\t\t\tdev_err(mhdp->dev, \"%s: phy_configure() failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcdns_mhdp_adjust_lt(mhdp, mhdp->link.num_lanes, 100,\n\t\t\t\t    lanes_data, link_status);\n\n\t\tcdns_mhdp_validate_cr(mhdp, &cr_done, &same_before_adjust,\n\t\t\t\t      &max_swing_reached, lanes_data,\n\t\t\t\t      link_status,\n\t\t\t\t      requested_adjust_volt_swing,\n\t\t\t\t      requested_adjust_pre_emphasis);\n\n\t\tif (max_swing_reached) {\n\t\t\tdev_err(mhdp->dev, \"CR: max swing reached\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cr_done) {\n\t\t\tcdns_mhdp_print_lt_status(\"CR phase ok\", mhdp,\n\t\t\t\t\t\t  &phy_cfg);\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tfail_counter_cr_long++;\n\n\t\tif (same_before_adjust) {\n\t\t\tfail_counter_short++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfail_counter_short = 0;\n\t\t \n\t\tcdns_mhdp_adjust_requested_cr(mhdp, link_status,\n\t\t\t\t\t      requested_adjust_volt_swing,\n\t\t\t\t\t      requested_adjust_pre_emphasis);\n\t} while (fail_counter_short < 5 && fail_counter_cr_long < 10);\n\nerr:\n\tcdns_mhdp_print_lt_status(\"CR phase failed\", mhdp, &phy_cfg);\n\n\treturn false;\n}\n\nstatic void cdns_mhdp_lower_link_rate(struct cdns_mhdp_link *link)\n{\n\tswitch (drm_dp_link_rate_to_bw_code(link->rate)) {\n\tcase DP_LINK_BW_2_7:\n\t\tlink->rate = drm_dp_bw_code_to_link_rate(DP_LINK_BW_1_62);\n\t\tbreak;\n\tcase DP_LINK_BW_5_4:\n\t\tlink->rate = drm_dp_bw_code_to_link_rate(DP_LINK_BW_2_7);\n\t\tbreak;\n\tcase DP_LINK_BW_8_1:\n\t\tlink->rate = drm_dp_bw_code_to_link_rate(DP_LINK_BW_5_4);\n\t\tbreak;\n\t}\n}\n\nstatic int cdns_mhdp_link_training(struct cdns_mhdp_device *mhdp,\n\t\t\t\t   unsigned int training_interval)\n{\n\tu32 reg32;\n\tconst u8 eq_tps = cdns_mhdp_eq_training_pattern_supported(mhdp);\n\tint ret;\n\n\twhile (1) {\n\t\tif (!cdns_mhdp_link_training_cr(mhdp)) {\n\t\t\tif (drm_dp_link_rate_to_bw_code(mhdp->link.rate) !=\n\t\t\t    DP_LINK_BW_1_62) {\n\t\t\t\tdev_dbg(mhdp->dev,\n\t\t\t\t\t\"Reducing link rate during CR phase\\n\");\n\t\t\t\tcdns_mhdp_lower_link_rate(&mhdp->link);\n\n\t\t\t\tcontinue;\n\t\t\t} else if (mhdp->link.num_lanes > 1) {\n\t\t\t\tdev_dbg(mhdp->dev,\n\t\t\t\t\t\"Reducing lanes number during CR phase\\n\");\n\t\t\t\tmhdp->link.num_lanes >>= 1;\n\t\t\t\tmhdp->link.rate = cdns_mhdp_max_link_rate(mhdp);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_err(mhdp->dev,\n\t\t\t\t\"Link training failed during CR phase\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (cdns_mhdp_link_training_channel_eq(mhdp, eq_tps,\n\t\t\t\t\t\t       training_interval))\n\t\t\tbreak;\n\n\t\tif (mhdp->link.num_lanes > 1) {\n\t\t\tdev_dbg(mhdp->dev,\n\t\t\t\t\"Reducing lanes number during EQ phase\\n\");\n\t\t\tmhdp->link.num_lanes >>= 1;\n\n\t\t\tcontinue;\n\t\t} else if (drm_dp_link_rate_to_bw_code(mhdp->link.rate) !=\n\t\t\t   DP_LINK_BW_1_62) {\n\t\t\tdev_dbg(mhdp->dev,\n\t\t\t\t\"Reducing link rate during EQ phase\\n\");\n\t\t\tcdns_mhdp_lower_link_rate(&mhdp->link);\n\t\t\tmhdp->link.num_lanes = cdns_mhdp_max_num_lanes(mhdp);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_err(mhdp->dev, \"Link training failed during EQ phase\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_dbg(mhdp->dev, \"Link training ok. Lanes: %u, Rate %u Mbps\\n\",\n\t\tmhdp->link.num_lanes, mhdp->link.rate / 100);\n\n\tdrm_dp_dpcd_writeb(&mhdp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   mhdp->host.scrambler ? 0 :\n\t\t\t   DP_LINK_SCRAMBLING_DISABLE);\n\n\tret = cdns_mhdp_reg_read(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, &reg32);\n\tif (ret < 0) {\n\t\tdev_err(mhdp->dev,\n\t\t\t\"Failed to read CDNS_DP_FRAMER_GLOBAL_CONFIG %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\treg32 &= ~GENMASK(1, 0);\n\treg32 |= CDNS_DP_NUM_LANES(mhdp->link.num_lanes);\n\treg32 |= CDNS_DP_WR_FAILING_EDGE_VSYNC;\n\treg32 |= CDNS_DP_FRAMER_EN;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, reg32);\n\n\t \n\treg32 = CDNS_PHY_COMMON_CONFIG | CDNS_PHY_TRAINING_TYPE(1);\n\tif (!mhdp->host.scrambler)\n\t\treg32 |= CDNS_PHY_SCRAMBLER_BYPASS;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_PHY_CONFIG, reg32);\n\n\treturn 0;\nerr:\n\t \n\treg32 = CDNS_PHY_COMMON_CONFIG | CDNS_PHY_TRAINING_TYPE(1);\n\tif (!mhdp->host.scrambler)\n\t\treg32 |= CDNS_PHY_SCRAMBLER_BYPASS;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_PHY_CONFIG, reg32);\n\n\tdrm_dp_dpcd_writeb(&mhdp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\n\treturn -EIO;\n}\n\nstatic u32 cdns_mhdp_get_training_interval_us(struct cdns_mhdp_device *mhdp,\n\t\t\t\t\t      u32 interval)\n{\n\tif (interval == 0)\n\t\treturn 400;\n\tif (interval < 5)\n\t\treturn 4000 << (interval - 1);\n\tdev_err(mhdp->dev,\n\t\t\"wrong training interval returned by DPCD: %d\\n\", interval);\n\treturn 0;\n}\n\nstatic void cdns_mhdp_fill_host_caps(struct cdns_mhdp_device *mhdp)\n{\n\tunsigned int link_rate;\n\n\t \n\n\tmhdp->host.lanes_cnt = mhdp->phy->attrs.bus_width;\n\tif (!mhdp->host.lanes_cnt)\n\t\tmhdp->host.lanes_cnt = 4;\n\n\tlink_rate = mhdp->phy->attrs.max_link_rate;\n\tif (!link_rate)\n\t\tlink_rate = drm_dp_bw_code_to_link_rate(DP_LINK_BW_8_1);\n\telse\n\t\t \n\t\tlink_rate *= 100;\n\n\tmhdp->host.link_rate = link_rate;\n\tmhdp->host.volt_swing = CDNS_VOLT_SWING(3);\n\tmhdp->host.pre_emphasis = CDNS_PRE_EMPHASIS(3);\n\tmhdp->host.pattern_supp = CDNS_SUPPORT_TPS(1) |\n\t\t\t\t  CDNS_SUPPORT_TPS(2) | CDNS_SUPPORT_TPS(3) |\n\t\t\t\t  CDNS_SUPPORT_TPS(4);\n\tmhdp->host.lane_mapping = CDNS_LANE_MAPPING_NORMAL;\n\tmhdp->host.fast_link = false;\n\tmhdp->host.enhanced = true;\n\tmhdp->host.scrambler = true;\n\tmhdp->host.ssc = false;\n}\n\nstatic void cdns_mhdp_fill_sink_caps(struct cdns_mhdp_device *mhdp,\n\t\t\t\t     u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tmhdp->sink.link_rate = mhdp->link.rate;\n\tmhdp->sink.lanes_cnt = mhdp->link.num_lanes;\n\tmhdp->sink.enhanced = !!(mhdp->link.capabilities &\n\t\t\t\t DP_LINK_CAP_ENHANCED_FRAMING);\n\n\t \n\tmhdp->sink.ssc = !!(dpcd[DP_MAX_DOWNSPREAD] &\n\t\t\t\t  DP_MAX_DOWNSPREAD_0_5);\n\n\t \n\tmhdp->sink.pattern_supp = CDNS_SUPPORT_TPS(1) | CDNS_SUPPORT_TPS(2);\n\tif (drm_dp_tps3_supported(dpcd))\n\t\tmhdp->sink.pattern_supp |= CDNS_SUPPORT_TPS(3);\n\tif (drm_dp_tps4_supported(dpcd))\n\t\tmhdp->sink.pattern_supp |= CDNS_SUPPORT_TPS(4);\n\n\t \n\tmhdp->sink.fast_link = !!(dpcd[DP_MAX_DOWNSPREAD] &\n\t\t\t\t  DP_NO_AUX_HANDSHAKE_LINK_TRAINING);\n}\n\nstatic int cdns_mhdp_link_up(struct cdns_mhdp_device *mhdp)\n{\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE], amp[2];\n\tu32 resp, interval, interval_us;\n\tu8 ext_cap_chk = 0;\n\tunsigned int addr;\n\tint err;\n\n\tWARN_ON(!mutex_is_locked(&mhdp->link_mutex));\n\n\tdrm_dp_dpcd_readb(&mhdp->aux, DP_TRAINING_AUX_RD_INTERVAL,\n\t\t\t  &ext_cap_chk);\n\n\tif (ext_cap_chk & DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT)\n\t\taddr = DP_DP13_DPCD_REV;\n\telse\n\t\taddr = DP_DPCD_REV;\n\n\terr = drm_dp_dpcd_read(&mhdp->aux, addr, dpcd, DP_RECEIVER_CAP_SIZE);\n\tif (err < 0) {\n\t\tdev_err(mhdp->dev, \"Failed to read receiver capabilities\\n\");\n\t\treturn err;\n\t}\n\n\tmhdp->link.revision = dpcd[0];\n\tmhdp->link.rate = drm_dp_bw_code_to_link_rate(dpcd[1]);\n\tmhdp->link.num_lanes = dpcd[2] & DP_MAX_LANE_COUNT_MASK;\n\n\tif (dpcd[2] & DP_ENHANCED_FRAME_CAP)\n\t\tmhdp->link.capabilities |= DP_LINK_CAP_ENHANCED_FRAMING;\n\n\tdev_dbg(mhdp->dev, \"Set sink device power state via DPCD\\n\");\n\tcdns_mhdp_link_power_up(&mhdp->aux, &mhdp->link);\n\n\tcdns_mhdp_fill_sink_caps(mhdp, dpcd);\n\n\tmhdp->link.rate = cdns_mhdp_max_link_rate(mhdp);\n\tmhdp->link.num_lanes = cdns_mhdp_max_num_lanes(mhdp);\n\n\t \n\terr = cdns_mhdp_reg_read(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, &resp);\n\tif (err < 0) {\n\t\tdev_err(mhdp->dev,\n\t\t\t\"Failed to read CDNS_DP_FRAMER_GLOBAL_CONFIG %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tresp &= ~CDNS_DP_FRAMER_EN;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, resp);\n\n\t \n\tamp[0] = cdns_mhdp_get_ssc_supported(mhdp) ? DP_SPREAD_AMP_0_5 : 0;\n\tamp[1] = DP_SET_ANSI_8B10B;\n\tdrm_dp_dpcd_write(&mhdp->aux, DP_DOWNSPREAD_CTRL, amp, 2);\n\n\tif (mhdp->host.fast_link & mhdp->sink.fast_link) {\n\t\tdev_err(mhdp->dev, \"fastlink not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tinterval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] & DP_TRAINING_AUX_RD_MASK;\n\tinterval_us = cdns_mhdp_get_training_interval_us(mhdp, interval);\n\tif (!interval_us ||\n\t    cdns_mhdp_link_training(mhdp, interval_us)) {\n\t\tdev_err(mhdp->dev, \"Link training failed. Exiting.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tmhdp->link_up = true;\n\n\treturn 0;\n}\n\nstatic void cdns_mhdp_link_down(struct cdns_mhdp_device *mhdp)\n{\n\tWARN_ON(!mutex_is_locked(&mhdp->link_mutex));\n\n\tif (mhdp->plugged)\n\t\tcdns_mhdp_link_power_down(&mhdp->aux, &mhdp->link);\n\n\tmhdp->link_up = false;\n}\n\nstatic struct edid *cdns_mhdp_get_edid(struct cdns_mhdp_device *mhdp,\n\t\t\t\t       struct drm_connector *connector)\n{\n\tif (!mhdp->plugged)\n\t\treturn NULL;\n\n\treturn drm_do_get_edid(connector, cdns_mhdp_get_edid_block, mhdp);\n}\n\nstatic int cdns_mhdp_get_modes(struct drm_connector *connector)\n{\n\tstruct cdns_mhdp_device *mhdp = connector_to_mhdp(connector);\n\tstruct edid *edid;\n\tint num_modes;\n\n\tif (!mhdp->plugged)\n\t\treturn 0;\n\n\tedid = cdns_mhdp_get_edid(mhdp, connector);\n\tif (!edid) {\n\t\tdev_err(mhdp->dev, \"Failed to read EDID\\n\");\n\t\treturn 0;\n\t}\n\n\tdrm_connector_update_edid_property(connector, edid);\n\tnum_modes = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\t \n\tif (connector->display_info.color_formats &&\n\t    !(connector->display_info.color_formats &\n\t      mhdp->display_fmt.color_format))\n\t\tdev_warn(mhdp->dev,\n\t\t\t \"%s: No supported color_format found (0x%08x)\\n\",\n\t\t\t__func__, connector->display_info.color_formats);\n\n\tif (connector->display_info.bpc &&\n\t    connector->display_info.bpc < mhdp->display_fmt.bpc)\n\t\tdev_warn(mhdp->dev, \"%s: Display bpc only %d < %d\\n\",\n\t\t\t __func__, connector->display_info.bpc,\n\t\t\t mhdp->display_fmt.bpc);\n\n\treturn num_modes;\n}\n\nstatic int cdns_mhdp_connector_detect(struct drm_connector *conn,\n\t\t\t\t      struct drm_modeset_acquire_ctx *ctx,\n\t\t\t\t      bool force)\n{\n\tstruct cdns_mhdp_device *mhdp = connector_to_mhdp(conn);\n\n\treturn cdns_mhdp_detect(mhdp);\n}\n\nstatic u32 cdns_mhdp_get_bpp(struct cdns_mhdp_display_fmt *fmt)\n{\n\tu32 bpp;\n\n\tif (fmt->y_only)\n\t\treturn fmt->bpc;\n\n\tswitch (fmt->color_format) {\n\tcase DRM_COLOR_FORMAT_RGB444:\n\tcase DRM_COLOR_FORMAT_YCBCR444:\n\t\tbpp = fmt->bpc * 3;\n\t\tbreak;\n\tcase DRM_COLOR_FORMAT_YCBCR422:\n\t\tbpp = fmt->bpc * 2;\n\t\tbreak;\n\tcase DRM_COLOR_FORMAT_YCBCR420:\n\t\tbpp = fmt->bpc * 3 / 2;\n\t\tbreak;\n\tdefault:\n\t\tbpp = fmt->bpc * 3;\n\t\tWARN_ON(1);\n\t}\n\treturn bpp;\n}\n\nstatic\nbool cdns_mhdp_bandwidth_ok(struct cdns_mhdp_device *mhdp,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    unsigned int lanes, unsigned int rate)\n{\n\tu32 max_bw, req_bw, bpp;\n\n\t \n\n\tbpp = cdns_mhdp_get_bpp(&mhdp->display_fmt);\n\treq_bw = mode->clock * bpp / 8;\n\tmax_bw = lanes * rate;\n\tif (req_bw > max_bw) {\n\t\tdev_dbg(mhdp->dev,\n\t\t\t\"Unsupported Mode: %s, Req BW: %u, Available Max BW:%u\\n\",\n\t\t\tmode->name, req_bw, max_bw);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic\nenum drm_mode_status cdns_mhdp_mode_valid(struct drm_connector *conn,\n\t\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct cdns_mhdp_device *mhdp = connector_to_mhdp(conn);\n\n\tmutex_lock(&mhdp->link_mutex);\n\n\tif (!cdns_mhdp_bandwidth_ok(mhdp, mode, mhdp->link.num_lanes,\n\t\t\t\t    mhdp->link.rate)) {\n\t\tmutex_unlock(&mhdp->link_mutex);\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\tmutex_unlock(&mhdp->link_mutex);\n\treturn MODE_OK;\n}\n\nstatic int cdns_mhdp_connector_atomic_check(struct drm_connector *conn,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct cdns_mhdp_device *mhdp = connector_to_mhdp(conn);\n\tstruct drm_connector_state *old_state, *new_state;\n\tstruct drm_crtc_state *crtc_state;\n\tu64 old_cp, new_cp;\n\n\tif (!mhdp->hdcp_supported)\n\t\treturn 0;\n\n\told_state = drm_atomic_get_old_connector_state(state, conn);\n\tnew_state = drm_atomic_get_new_connector_state(state, conn);\n\told_cp = old_state->content_protection;\n\tnew_cp = new_state->content_protection;\n\n\tif (old_state->hdcp_content_type != new_state->hdcp_content_type &&\n\t    new_cp != DRM_MODE_CONTENT_PROTECTION_UNDESIRED) {\n\t\tnew_state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\tgoto mode_changed;\n\t}\n\n\tif (!new_state->crtc) {\n\t\tif (old_cp == DRM_MODE_CONTENT_PROTECTION_ENABLED)\n\t\t\tnew_state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\treturn 0;\n\t}\n\n\tif (old_cp == new_cp ||\n\t    (old_cp == DRM_MODE_CONTENT_PROTECTION_DESIRED &&\n\t     new_cp == DRM_MODE_CONTENT_PROTECTION_ENABLED))\n\t\treturn 0;\n\nmode_changed:\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, new_state->crtc);\n\tcrtc_state->mode_changed = true;\n\n\treturn 0;\n}\n\nstatic const struct drm_connector_helper_funcs cdns_mhdp_conn_helper_funcs = {\n\t.detect_ctx = cdns_mhdp_connector_detect,\n\t.get_modes = cdns_mhdp_get_modes,\n\t.mode_valid = cdns_mhdp_mode_valid,\n\t.atomic_check = cdns_mhdp_connector_atomic_check,\n};\n\nstatic const struct drm_connector_funcs cdns_mhdp_conn_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.destroy = drm_connector_cleanup,\n};\n\nstatic int cdns_mhdp_connector_init(struct cdns_mhdp_device *mhdp)\n{\n\tu32 bus_format = MEDIA_BUS_FMT_RGB121212_1X36;\n\tstruct drm_connector *conn = &mhdp->connector;\n\tstruct drm_bridge *bridge = &mhdp->bridge;\n\tint ret;\n\n\tif (!bridge->encoder) {\n\t\tdev_err(mhdp->dev, \"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tconn->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tret = drm_connector_init(bridge->dev, conn, &cdns_mhdp_conn_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret) {\n\t\tdev_err(mhdp->dev, \"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(conn, &cdns_mhdp_conn_helper_funcs);\n\n\tret = drm_display_info_set_bus_formats(&conn->display_info,\n\t\t\t\t\t       &bus_format, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_attach_encoder(conn, bridge->encoder);\n\tif (ret) {\n\t\tdev_err(mhdp->dev, \"Failed to attach connector to encoder\\n\");\n\t\treturn ret;\n\t}\n\n\tif (mhdp->hdcp_supported)\n\t\tret = drm_connector_attach_content_protection_property(conn, true);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_attach(struct drm_bridge *bridge,\n\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\tbool hw_ready;\n\tint ret;\n\n\tdev_dbg(mhdp->dev, \"%s\\n\", __func__);\n\n\tmhdp->aux.drm_dev = bridge->dev;\n\tret = drm_dp_aux_register(&mhdp->aux);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tret = cdns_mhdp_connector_init(mhdp);\n\t\tif (ret)\n\t\t\tgoto aux_unregister;\n\t}\n\n\tspin_lock(&mhdp->start_lock);\n\n\tmhdp->bridge_attached = true;\n\thw_ready = mhdp->hw_state == MHDP_HW_READY;\n\n\tspin_unlock(&mhdp->start_lock);\n\n\t \n\tif (hw_ready)\n\t\tcdns_mhdp_bridge_hpd_enable(bridge);\n\n\treturn 0;\naux_unregister:\n\tdrm_dp_aux_unregister(&mhdp->aux);\n\treturn ret;\n}\n\nstatic void cdns_mhdp_configure_video(struct cdns_mhdp_device *mhdp,\n\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tunsigned int dp_framer_sp = 0, msa_horizontal_1,\n\t\tmsa_vertical_1, bnd_hsync2vsync, hsync2vsync_pol_ctrl,\n\t\tmisc0 = 0, misc1 = 0, pxl_repr,\n\t\tfront_porch, back_porch, msa_h0, msa_v0, hsync, vsync,\n\t\tdp_vertical_1;\n\tu8 stream_id = mhdp->stream_id;\n\tu32 bpp, bpc, pxlfmt, framer;\n\tint ret;\n\n\tpxlfmt = mhdp->display_fmt.color_format;\n\tbpc = mhdp->display_fmt.bpc;\n\n\t \n\tif ((pxlfmt == DRM_COLOR_FORMAT_YCBCR444 ||\n\t     pxlfmt == DRM_COLOR_FORMAT_YCBCR422) && mode->crtc_vdisplay >= 720)\n\t\tmisc0 = DP_YCBCR_COEFFICIENTS_ITU709;\n\n\tbpp = cdns_mhdp_get_bpp(&mhdp->display_fmt);\n\n\tswitch (pxlfmt) {\n\tcase DRM_COLOR_FORMAT_RGB444:\n\t\tpxl_repr = CDNS_DP_FRAMER_RGB << CDNS_DP_FRAMER_PXL_FORMAT;\n\t\tmisc0 |= DP_COLOR_FORMAT_RGB;\n\t\tbreak;\n\tcase DRM_COLOR_FORMAT_YCBCR444:\n\t\tpxl_repr = CDNS_DP_FRAMER_YCBCR444 << CDNS_DP_FRAMER_PXL_FORMAT;\n\t\tmisc0 |= DP_COLOR_FORMAT_YCbCr444 | DP_TEST_DYNAMIC_RANGE_CEA;\n\t\tbreak;\n\tcase DRM_COLOR_FORMAT_YCBCR422:\n\t\tpxl_repr = CDNS_DP_FRAMER_YCBCR422 << CDNS_DP_FRAMER_PXL_FORMAT;\n\t\tmisc0 |= DP_COLOR_FORMAT_YCbCr422 | DP_TEST_DYNAMIC_RANGE_CEA;\n\t\tbreak;\n\tcase DRM_COLOR_FORMAT_YCBCR420:\n\t\tpxl_repr = CDNS_DP_FRAMER_YCBCR420 << CDNS_DP_FRAMER_PXL_FORMAT;\n\t\tbreak;\n\tdefault:\n\t\tpxl_repr = CDNS_DP_FRAMER_Y_ONLY << CDNS_DP_FRAMER_PXL_FORMAT;\n\t}\n\n\tswitch (bpc) {\n\tcase 6:\n\t\tmisc0 |= DP_TEST_BIT_DEPTH_6;\n\t\tpxl_repr |= CDNS_DP_FRAMER_6_BPC;\n\t\tbreak;\n\tcase 8:\n\t\tmisc0 |= DP_TEST_BIT_DEPTH_8;\n\t\tpxl_repr |= CDNS_DP_FRAMER_8_BPC;\n\t\tbreak;\n\tcase 10:\n\t\tmisc0 |= DP_TEST_BIT_DEPTH_10;\n\t\tpxl_repr |= CDNS_DP_FRAMER_10_BPC;\n\t\tbreak;\n\tcase 12:\n\t\tmisc0 |= DP_TEST_BIT_DEPTH_12;\n\t\tpxl_repr |= CDNS_DP_FRAMER_12_BPC;\n\t\tbreak;\n\tcase 16:\n\t\tmisc0 |= DP_TEST_BIT_DEPTH_16;\n\t\tpxl_repr |= CDNS_DP_FRAMER_16_BPC;\n\t\tbreak;\n\t}\n\n\tbnd_hsync2vsync = CDNS_IP_BYPASS_V_INTERFACE;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tbnd_hsync2vsync |= CDNS_IP_DET_INTERLACE_FORMAT;\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_BND_HSYNC2VSYNC(stream_id),\n\t\t\t    bnd_hsync2vsync);\n\n\thsync2vsync_pol_ctrl = 0;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\thsync2vsync_pol_ctrl |= CDNS_H2V_HSYNC_POL_ACTIVE_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\thsync2vsync_pol_ctrl |= CDNS_H2V_VSYNC_POL_ACTIVE_LOW;\n\tcdns_mhdp_reg_write(mhdp, CDNS_HSYNC2VSYNC_POL_CTRL(stream_id),\n\t\t\t    hsync2vsync_pol_ctrl);\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_PXL_REPR(stream_id), pxl_repr);\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tdp_framer_sp |= CDNS_DP_FRAMER_INTERLACE;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tdp_framer_sp |= CDNS_DP_FRAMER_HSYNC_POL_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tdp_framer_sp |= CDNS_DP_FRAMER_VSYNC_POL_LOW;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_SP(stream_id), dp_framer_sp);\n\n\tfront_porch = mode->crtc_hsync_start - mode->crtc_hdisplay;\n\tback_porch = mode->crtc_htotal - mode->crtc_hsync_end;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRONT_BACK_PORCH(stream_id),\n\t\t\t    CDNS_DP_FRONT_PORCH(front_porch) |\n\t\t\t    CDNS_DP_BACK_PORCH(back_porch));\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_BYTE_COUNT(stream_id),\n\t\t\t    mode->crtc_hdisplay * bpp / 8);\n\n\tmsa_h0 = mode->crtc_htotal - mode->crtc_hsync_start;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_MSA_HORIZONTAL_0(stream_id),\n\t\t\t    CDNS_DP_MSAH0_H_TOTAL(mode->crtc_htotal) |\n\t\t\t    CDNS_DP_MSAH0_HSYNC_START(msa_h0));\n\n\thsync = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\tmsa_horizontal_1 = CDNS_DP_MSAH1_HSYNC_WIDTH(hsync) |\n\t\t\t   CDNS_DP_MSAH1_HDISP_WIDTH(mode->crtc_hdisplay);\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tmsa_horizontal_1 |= CDNS_DP_MSAH1_HSYNC_POL_LOW;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_MSA_HORIZONTAL_1(stream_id),\n\t\t\t    msa_horizontal_1);\n\n\tmsa_v0 = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_MSA_VERTICAL_0(stream_id),\n\t\t\t    CDNS_DP_MSAV0_V_TOTAL(mode->crtc_vtotal) |\n\t\t\t    CDNS_DP_MSAV0_VSYNC_START(msa_v0));\n\n\tvsync = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tmsa_vertical_1 = CDNS_DP_MSAV1_VSYNC_WIDTH(vsync) |\n\t\t\t CDNS_DP_MSAV1_VDISP_WIDTH(mode->crtc_vdisplay);\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tmsa_vertical_1 |= CDNS_DP_MSAV1_VSYNC_POL_LOW;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_MSA_VERTICAL_1(stream_id),\n\t\t\t    msa_vertical_1);\n\n\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&\n\t    mode->crtc_vtotal % 2 == 0)\n\t\tmisc1 = DP_TEST_INTERLACED;\n\tif (mhdp->display_fmt.y_only)\n\t\tmisc1 |= CDNS_DP_TEST_COLOR_FORMAT_RAW_Y_ONLY;\n\t \n\tif (pxlfmt == DRM_COLOR_FORMAT_YCBCR420)\n\t\tmisc1 = CDNS_DP_TEST_VSC_SDP;\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_MSA_MISC(stream_id),\n\t\t\t    misc0 | (misc1 << 8));\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_HORIZONTAL(stream_id),\n\t\t\t    CDNS_DP_H_HSYNC_WIDTH(hsync) |\n\t\t\t    CDNS_DP_H_H_TOTAL(mode->crtc_hdisplay));\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_VERTICAL_0(stream_id),\n\t\t\t    CDNS_DP_V0_VHEIGHT(mode->crtc_vdisplay) |\n\t\t\t    CDNS_DP_V0_VSTART(msa_v0));\n\n\tdp_vertical_1 = CDNS_DP_V1_VTOTAL(mode->crtc_vtotal);\n\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&\n\t    mode->crtc_vtotal % 2 == 0)\n\t\tdp_vertical_1 |= CDNS_DP_V1_VTOTAL_EVEN;\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_VERTICAL_1(stream_id), dp_vertical_1);\n\n\tcdns_mhdp_reg_write_bit(mhdp, CDNS_DP_VB_ID(stream_id), 2, 1,\n\t\t\t\t(mode->flags & DRM_MODE_FLAG_INTERLACE) ?\n\t\t\t\tCDNS_DP_VB_ID_INTERLACED : 0);\n\n\tret = cdns_mhdp_reg_read(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, &framer);\n\tif (ret < 0) {\n\t\tdev_err(mhdp->dev,\n\t\t\t\"Failed to read CDNS_DP_FRAMER_GLOBAL_CONFIG %d\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\tframer |= CDNS_DP_FRAMER_EN;\n\tframer &= ~CDNS_DP_NO_VIDEO_MODE;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, framer);\n}\n\nstatic void cdns_mhdp_sst_enable(struct cdns_mhdp_device *mhdp,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tu32 rate, vs, required_bandwidth, available_bandwidth;\n\ts32 line_thresh1, line_thresh2, line_thresh = 0;\n\tint pxlclock = mode->crtc_clock;\n\tu32 tu_size = 64;\n\tu32 bpp;\n\n\t \n\trate = mhdp->link.rate / 1000;\n\n\tbpp = cdns_mhdp_get_bpp(&mhdp->display_fmt);\n\n\trequired_bandwidth = pxlclock * bpp / 8;\n\tavailable_bandwidth = mhdp->link.num_lanes * rate;\n\n\tvs = tu_size * required_bandwidth / available_bandwidth;\n\tvs /= 1000;\n\n\tif (vs == tu_size)\n\t\tvs = tu_size - 1;\n\n\tline_thresh1 = ((vs + 1) << 5) * 8 / bpp;\n\tline_thresh2 = (pxlclock << 5) / 1000 / rate * (vs + 1) - (1 << 5);\n\tline_thresh = line_thresh1 - line_thresh2 / (s32)mhdp->link.num_lanes;\n\tline_thresh = (line_thresh >> 5) + 2;\n\n\tmhdp->stream_id = 0;\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_TU,\n\t\t\t    CDNS_DP_FRAMER_TU_VS(vs) |\n\t\t\t    CDNS_DP_FRAMER_TU_SIZE(tu_size) |\n\t\t\t    CDNS_DP_FRAMER_TU_CNT_RST_EN);\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_LINE_THRESH(0),\n\t\t\t    line_thresh & GENMASK(5, 0));\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_STREAM_CONFIG_2(0),\n\t\t\t    CDNS_DP_SC2_TU_VS_DIFF((tu_size - vs > 3) ?\n\t\t\t\t\t\t   0 : tu_size - vs));\n\n\tcdns_mhdp_configure_video(mhdp, mode);\n}\n\nstatic void cdns_mhdp_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_bridge_state *bridge_state)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\tstruct cdns_mhdp_bridge_state *mhdp_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_bridge_state *new_state;\n\tconst struct drm_display_mode *mode;\n\tu32 resp;\n\tint ret;\n\n\tdev_dbg(mhdp->dev, \"bridge enable\\n\");\n\n\tmutex_lock(&mhdp->link_mutex);\n\n\tif (mhdp->plugged && !mhdp->link_up) {\n\t\tret = cdns_mhdp_link_up(mhdp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (mhdp->info && mhdp->info->ops && mhdp->info->ops->enable)\n\t\tmhdp->info->ops->enable(mhdp);\n\n\t \n\tret = cdns_mhdp_reg_read(mhdp, CDNS_DPTX_CAR, &resp);\n\tif (ret < 0) {\n\t\tdev_err(mhdp->dev, \"Failed to read CDNS_DPTX_CAR %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_CAR,\n\t\t\t    resp | CDNS_VIF_CLK_EN | CDNS_VIF_CLK_RSTN);\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tif (WARN_ON(!connector))\n\t\tgoto out;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\tgoto out;\n\n\tif (mhdp->hdcp_supported &&\n\t    mhdp->hw_state == MHDP_HW_READY &&\n\t    conn_state->content_protection ==\n\t    DRM_MODE_CONTENT_PROTECTION_DESIRED) {\n\t\tmutex_unlock(&mhdp->link_mutex);\n\t\tcdns_mhdp_hdcp_enable(mhdp, conn_state->hdcp_content_type);\n\t\tmutex_lock(&mhdp->link_mutex);\n\t}\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\tgoto out;\n\n\tmode = &crtc_state->adjusted_mode;\n\n\tnew_state = drm_atomic_get_new_bridge_state(state, bridge);\n\tif (WARN_ON(!new_state))\n\t\tgoto out;\n\n\tif (!cdns_mhdp_bandwidth_ok(mhdp, mode, mhdp->link.num_lanes,\n\t\t\t\t    mhdp->link.rate)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcdns_mhdp_sst_enable(mhdp, mode);\n\n\tmhdp_state = to_cdns_mhdp_bridge_state(new_state);\n\n\tmhdp_state->current_mode = drm_mode_duplicate(bridge->dev, mode);\n\tdrm_mode_set_name(mhdp_state->current_mode);\n\n\tdev_dbg(mhdp->dev, \"%s: Enabling mode %s\\n\", __func__, mode->name);\n\n\tmhdp->bridge_enabled = true;\n\nout:\n\tmutex_unlock(&mhdp->link_mutex);\n\tif (ret < 0)\n\t\tschedule_work(&mhdp->modeset_retry_work);\n}\n\nstatic void cdns_mhdp_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *bridge_state)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\tu32 resp;\n\n\tdev_dbg(mhdp->dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&mhdp->link_mutex);\n\n\tif (mhdp->hdcp_supported)\n\t\tcdns_mhdp_hdcp_disable(mhdp);\n\n\tmhdp->bridge_enabled = false;\n\tcdns_mhdp_reg_read(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, &resp);\n\tresp &= ~CDNS_DP_FRAMER_EN;\n\tresp |= CDNS_DP_NO_VIDEO_MODE;\n\tcdns_mhdp_reg_write(mhdp, CDNS_DP_FRAMER_GLOBAL_CONFIG, resp);\n\n\tcdns_mhdp_link_down(mhdp);\n\n\t \n\tcdns_mhdp_reg_read(mhdp, CDNS_DPTX_CAR, &resp);\n\tcdns_mhdp_reg_write(mhdp, CDNS_DPTX_CAR,\n\t\t\t    resp & ~(CDNS_VIF_CLK_EN | CDNS_VIF_CLK_RSTN));\n\n\tif (mhdp->info && mhdp->info->ops && mhdp->info->ops->disable)\n\t\tmhdp->info->ops->disable(mhdp);\n\n\tmutex_unlock(&mhdp->link_mutex);\n}\n\nstatic void cdns_mhdp_detach(struct drm_bridge *bridge)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\n\tdev_dbg(mhdp->dev, \"%s\\n\", __func__);\n\n\tdrm_dp_aux_unregister(&mhdp->aux);\n\n\tspin_lock(&mhdp->start_lock);\n\n\tmhdp->bridge_attached = false;\n\n\tspin_unlock(&mhdp->start_lock);\n\n\twritel(~0, mhdp->regs + CDNS_APB_INT_MASK);\n}\n\nstatic struct drm_bridge_state *\ncdns_mhdp_bridge_atomic_duplicate_state(struct drm_bridge *bridge)\n{\n\tstruct cdns_mhdp_bridge_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_bridge_duplicate_state(bridge, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void\ncdns_mhdp_bridge_atomic_destroy_state(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *state)\n{\n\tstruct cdns_mhdp_bridge_state *cdns_mhdp_state;\n\n\tcdns_mhdp_state = to_cdns_mhdp_bridge_state(state);\n\n\tif (cdns_mhdp_state->current_mode) {\n\t\tdrm_mode_destroy(bridge->dev, cdns_mhdp_state->current_mode);\n\t\tcdns_mhdp_state->current_mode = NULL;\n\t}\n\n\tkfree(cdns_mhdp_state);\n}\n\nstatic struct drm_bridge_state *\ncdns_mhdp_bridge_atomic_reset(struct drm_bridge *bridge)\n{\n\tstruct cdns_mhdp_bridge_state *cdns_mhdp_state;\n\n\tcdns_mhdp_state = kzalloc(sizeof(*cdns_mhdp_state), GFP_KERNEL);\n\tif (!cdns_mhdp_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_bridge_reset(bridge, &cdns_mhdp_state->base);\n\n\treturn &cdns_mhdp_state->base;\n}\n\nstatic u32 *cdns_mhdp_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t\t u32 output_fmt,\n\t\t\t\t\t unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kzalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB121212_1X36;\n\n\treturn input_fmts;\n}\n\nstatic int cdns_mhdp_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *bridge_state,\n\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\tconst struct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\n\tmutex_lock(&mhdp->link_mutex);\n\n\tif (!cdns_mhdp_bandwidth_ok(mhdp, mode, mhdp->link.num_lanes,\n\t\t\t\t    mhdp->link.rate)) {\n\t\tdev_err(mhdp->dev, \"%s: Not enough BW for %s (%u lanes at %u Mbps)\\n\",\n\t\t\t__func__, mode->name, mhdp->link.num_lanes,\n\t\t\tmhdp->link.rate / 100);\n\t\tmutex_unlock(&mhdp->link_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mhdp->info)\n\t\tbridge_state->input_bus_cfg.flags = *mhdp->info->input_bus_flags;\n\n\tmutex_unlock(&mhdp->link_mutex);\n\treturn 0;\n}\n\nstatic enum drm_connector_status cdns_mhdp_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\n\treturn cdns_mhdp_detect(mhdp);\n}\n\nstatic struct edid *cdns_mhdp_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_connector *connector)\n{\n\tstruct cdns_mhdp_device *mhdp = bridge_to_mhdp(bridge);\n\n\treturn cdns_mhdp_get_edid(mhdp, connector);\n}\n\nstatic const struct drm_bridge_funcs cdns_mhdp_bridge_funcs = {\n\t.atomic_enable = cdns_mhdp_atomic_enable,\n\t.atomic_disable = cdns_mhdp_atomic_disable,\n\t.atomic_check = cdns_mhdp_atomic_check,\n\t.attach = cdns_mhdp_attach,\n\t.detach = cdns_mhdp_detach,\n\t.atomic_duplicate_state = cdns_mhdp_bridge_atomic_duplicate_state,\n\t.atomic_destroy_state = cdns_mhdp_bridge_atomic_destroy_state,\n\t.atomic_reset = cdns_mhdp_bridge_atomic_reset,\n\t.atomic_get_input_bus_fmts = cdns_mhdp_get_input_bus_fmts,\n\t.detect = cdns_mhdp_bridge_detect,\n\t.get_edid = cdns_mhdp_bridge_get_edid,\n\t.hpd_enable = cdns_mhdp_bridge_hpd_enable,\n\t.hpd_disable = cdns_mhdp_bridge_hpd_disable,\n};\n\nstatic bool cdns_mhdp_detect_hpd(struct cdns_mhdp_device *mhdp, bool *hpd_pulse)\n{\n\tint hpd_event, hpd_status;\n\n\t*hpd_pulse = false;\n\n\thpd_event = cdns_mhdp_read_hpd_event(mhdp);\n\n\t \n\tif (hpd_event < 0) {\n\t\tdev_warn(mhdp->dev, \"%s: read event failed: %d\\n\",\n\t\t\t __func__, hpd_event);\n\t\treturn false;\n\t}\n\n\thpd_status = cdns_mhdp_get_hpd_status(mhdp);\n\tif (hpd_status < 0) {\n\t\tdev_warn(mhdp->dev, \"%s: get hpd status failed: %d\\n\",\n\t\t\t __func__, hpd_status);\n\t\treturn false;\n\t}\n\n\tif (hpd_event & DPTX_READ_EVENT_HPD_PULSE)\n\t\t*hpd_pulse = true;\n\n\treturn !!hpd_status;\n}\n\nstatic int cdns_mhdp_update_link_status(struct cdns_mhdp_device *mhdp)\n{\n\tstruct cdns_mhdp_bridge_state *cdns_bridge_state;\n\tstruct drm_display_mode *current_mode;\n\tbool old_plugged = mhdp->plugged;\n\tstruct drm_bridge_state *state;\n\tu8 status[DP_LINK_STATUS_SIZE];\n\tbool hpd_pulse;\n\tint ret = 0;\n\n\tmutex_lock(&mhdp->link_mutex);\n\n\tmhdp->plugged = cdns_mhdp_detect_hpd(mhdp, &hpd_pulse);\n\n\tif (!mhdp->plugged) {\n\t\tcdns_mhdp_link_down(mhdp);\n\t\tmhdp->link.rate = mhdp->host.link_rate;\n\t\tmhdp->link.num_lanes = mhdp->host.lanes_cnt;\n\t\tgoto out;\n\t}\n\n\t \n\tif (hpd_pulse && old_plugged == mhdp->plugged) {\n\t\tret = drm_dp_dpcd_read_link_status(&mhdp->aux, status);\n\n\t\t \n\t\tif (ret > 0 &&\n\t\t    drm_dp_channel_eq_ok(status, mhdp->link.num_lanes) &&\n\t\t    drm_dp_clock_recovery_ok(status, mhdp->link.num_lanes))\n\t\t\tgoto out;\n\n\t\t \n\t\tmhdp->link_up = false;\n\t}\n\n\tif (!mhdp->link_up) {\n\t\tret = cdns_mhdp_link_up(mhdp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (mhdp->bridge_enabled) {\n\t\tstate = drm_priv_to_bridge_state(mhdp->bridge.base.state);\n\t\tif (!state) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcdns_bridge_state = to_cdns_mhdp_bridge_state(state);\n\t\tif (!cdns_bridge_state) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent_mode = cdns_bridge_state->current_mode;\n\t\tif (!current_mode) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!cdns_mhdp_bandwidth_ok(mhdp, current_mode, mhdp->link.num_lanes,\n\t\t\t\t\t    mhdp->link.rate)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdev_dbg(mhdp->dev, \"%s: Enabling mode %s\\n\", __func__,\n\t\t\tcurrent_mode->name);\n\n\t\tcdns_mhdp_sst_enable(mhdp, current_mode);\n\t}\nout:\n\tmutex_unlock(&mhdp->link_mutex);\n\treturn ret;\n}\n\nstatic void cdns_mhdp_modeset_retry_fn(struct work_struct *work)\n{\n\tstruct cdns_mhdp_device *mhdp;\n\tstruct drm_connector *conn;\n\n\tmhdp = container_of(work, typeof(*mhdp), modeset_retry_work);\n\n\tconn = &mhdp->connector;\n\n\t \n\tmutex_lock(&conn->dev->mode_config.mutex);\n\n\t \n\tdrm_connector_set_link_status_property(conn, DRM_MODE_LINK_STATUS_BAD);\n\tmutex_unlock(&conn->dev->mode_config.mutex);\n\n\t \n\tdrm_kms_helper_hotplug_event(mhdp->bridge.dev);\n}\n\nstatic irqreturn_t cdns_mhdp_irq_handler(int irq, void *data)\n{\n\tstruct cdns_mhdp_device *mhdp = data;\n\tu32 apb_stat, sw_ev0;\n\tbool bridge_attached;\n\n\tapb_stat = readl(mhdp->regs + CDNS_APB_INT_STATUS);\n\tif (!(apb_stat & CDNS_APB_INT_MASK_SW_EVENT_INT))\n\t\treturn IRQ_NONE;\n\n\tsw_ev0 = readl(mhdp->regs + CDNS_SW_EVENT0);\n\n\t \n\tspin_lock(&mhdp->start_lock);\n\tbridge_attached = mhdp->bridge_attached;\n\tspin_unlock(&mhdp->start_lock);\n\n\tif (bridge_attached && (sw_ev0 & CDNS_DPTX_HPD)) {\n\t\tschedule_work(&mhdp->hpd_work);\n\t}\n\n\tif (sw_ev0 & ~CDNS_DPTX_HPD) {\n\t\tmhdp->sw_events |= (sw_ev0 & ~CDNS_DPTX_HPD);\n\t\twake_up(&mhdp->sw_events_wq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nu32 cdns_mhdp_wait_for_sw_event(struct cdns_mhdp_device *mhdp, u32 event)\n{\n\tu32 ret;\n\n\tret = wait_event_timeout(mhdp->sw_events_wq,\n\t\t\t\t mhdp->sw_events & event,\n\t\t\t\t msecs_to_jiffies(500));\n\tif (!ret) {\n\t\tdev_dbg(mhdp->dev, \"SW event 0x%x timeout\\n\", event);\n\t\tgoto sw_event_out;\n\t}\n\n\tret = mhdp->sw_events;\n\tmhdp->sw_events &= ~event;\n\nsw_event_out:\n\treturn ret;\n}\n\nstatic void cdns_mhdp_hpd_work(struct work_struct *work)\n{\n\tstruct cdns_mhdp_device *mhdp = container_of(work,\n\t\t\t\t\t\t     struct cdns_mhdp_device,\n\t\t\t\t\t\t     hpd_work);\n\tint ret;\n\n\tret = cdns_mhdp_update_link_status(mhdp);\n\tif (mhdp->connector.dev) {\n\t\tif (ret < 0)\n\t\t\tschedule_work(&mhdp->modeset_retry_work);\n\t\telse\n\t\t\tdrm_kms_helper_hotplug_event(mhdp->bridge.dev);\n\t} else {\n\t\tdrm_bridge_hpd_notify(&mhdp->bridge, cdns_mhdp_detect(mhdp));\n\t}\n}\n\nstatic int cdns_mhdp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cdns_mhdp_device *mhdp;\n\tunsigned long rate;\n\tstruct clk *clk;\n\tint ret;\n\tint irq;\n\n\tmhdp = devm_kzalloc(dev, sizeof(*mhdp), GFP_KERNEL);\n\tif (!mhdp)\n\t\treturn -ENOMEM;\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"couldn't get clk: %ld\\n\", PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tmhdp->clk = clk;\n\tmhdp->dev = dev;\n\tmutex_init(&mhdp->mbox_mutex);\n\tmutex_init(&mhdp->link_mutex);\n\tspin_lock_init(&mhdp->start_lock);\n\n\tdrm_dp_aux_init(&mhdp->aux);\n\tmhdp->aux.dev = dev;\n\tmhdp->aux.transfer = cdns_mhdp_transfer;\n\n\tmhdp->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mhdp->regs)) {\n\t\tdev_err(dev, \"Failed to get memory resource\\n\");\n\t\treturn PTR_ERR(mhdp->regs);\n\t}\n\n\tmhdp->sapb_regs = devm_platform_ioremap_resource_byname(pdev, \"mhdptx-sapb\");\n\tif (IS_ERR(mhdp->sapb_regs)) {\n\t\tmhdp->hdcp_supported = false;\n\t\tdev_warn(dev,\n\t\t\t \"Failed to get SAPB memory resource, HDCP not supported\\n\");\n\t} else {\n\t\tmhdp->hdcp_supported = true;\n\t}\n\n\tmhdp->phy = devm_of_phy_get_by_index(dev, pdev->dev.of_node, 0);\n\tif (IS_ERR(mhdp->phy)) {\n\t\tdev_err(dev, \"no PHY configured\\n\");\n\t\treturn PTR_ERR(mhdp->phy);\n\t}\n\n\tplatform_set_drvdata(pdev, mhdp);\n\n\tmhdp->info = of_device_get_match_data(dev);\n\n\tclk_prepare_enable(clk);\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_resume_and_get failed\\n\");\n\t\tpm_runtime_disable(dev);\n\t\tgoto clk_disable;\n\t}\n\n\tif (mhdp->info && mhdp->info->ops && mhdp->info->ops->init) {\n\t\tret = mhdp->info->ops->init(mhdp);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"MHDP platform initialization failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto runtime_put;\n\t\t}\n\t}\n\n\trate = clk_get_rate(clk);\n\twritel(rate % 1000000, mhdp->regs + CDNS_SW_CLK_L);\n\twritel(rate / 1000000, mhdp->regs + CDNS_SW_CLK_H);\n\n\tdev_dbg(dev, \"func clk rate %lu Hz\\n\", rate);\n\n\twritel(~0, mhdp->regs + CDNS_APB_INT_MASK);\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_threaded_irq(mhdp->dev, irq, NULL,\n\t\t\t\t\tcdns_mhdp_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"mhdp8546\", mhdp);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot install IRQ %d\\n\", irq);\n\t\tret = -EIO;\n\t\tgoto plat_fini;\n\t}\n\n\tcdns_mhdp_fill_host_caps(mhdp);\n\n\t \n\tmhdp->link.rate = mhdp->host.link_rate;\n\tmhdp->link.num_lanes = mhdp->host.lanes_cnt;\n\n\t \n\tmhdp->display_fmt.y_only = false;\n\tmhdp->display_fmt.color_format = DRM_COLOR_FORMAT_RGB444;\n\tmhdp->display_fmt.bpc = 8;\n\n\tmhdp->bridge.of_node = pdev->dev.of_node;\n\tmhdp->bridge.funcs = &cdns_mhdp_bridge_funcs;\n\tmhdp->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID |\n\t\t\t   DRM_BRIDGE_OP_HPD;\n\tmhdp->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;\n\n\tret = phy_init(mhdp->phy);\n\tif (ret) {\n\t\tdev_err(mhdp->dev, \"Failed to initialize PHY: %d\\n\", ret);\n\t\tgoto plat_fini;\n\t}\n\n\t \n\tINIT_WORK(&mhdp->modeset_retry_work, cdns_mhdp_modeset_retry_fn);\n\tINIT_WORK(&mhdp->hpd_work, cdns_mhdp_hpd_work);\n\n\tinit_waitqueue_head(&mhdp->fw_load_wq);\n\tinit_waitqueue_head(&mhdp->sw_events_wq);\n\n\tret = cdns_mhdp_load_firmware(mhdp);\n\tif (ret)\n\t\tgoto phy_exit;\n\n\tif (mhdp->hdcp_supported)\n\t\tcdns_mhdp_hdcp_init(mhdp);\n\n\tdrm_bridge_add(&mhdp->bridge);\n\n\treturn 0;\n\nphy_exit:\n\tphy_exit(mhdp->phy);\nplat_fini:\n\tif (mhdp->info && mhdp->info->ops && mhdp->info->ops->exit)\n\t\tmhdp->info->ops->exit(mhdp);\nruntime_put:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\nclk_disable:\n\tclk_disable_unprepare(mhdp->clk);\n\n\treturn ret;\n}\n\nstatic int cdns_mhdp_remove(struct platform_device *pdev)\n{\n\tstruct cdns_mhdp_device *mhdp = platform_get_drvdata(pdev);\n\tunsigned long timeout = msecs_to_jiffies(100);\n\tbool stop_fw = false;\n\tint ret;\n\n\tdrm_bridge_remove(&mhdp->bridge);\n\n\tret = wait_event_timeout(mhdp->fw_load_wq,\n\t\t\t\t mhdp->hw_state == MHDP_HW_READY,\n\t\t\t\t timeout);\n\tif (ret == 0)\n\t\tdev_err(mhdp->dev, \"%s: Timeout waiting for fw loading\\n\",\n\t\t\t__func__);\n\telse\n\t\tstop_fw = true;\n\n\tspin_lock(&mhdp->start_lock);\n\tmhdp->hw_state = MHDP_HW_STOPPED;\n\tspin_unlock(&mhdp->start_lock);\n\n\tif (stop_fw)\n\t\tret = cdns_mhdp_set_firmware_active(mhdp, false);\n\n\tphy_exit(mhdp->phy);\n\n\tif (mhdp->info && mhdp->info->ops && mhdp->info->ops->exit)\n\t\tmhdp->info->ops->exit(mhdp);\n\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tcancel_work_sync(&mhdp->modeset_retry_work);\n\tflush_work(&mhdp->hpd_work);\n\t \n\n\tclk_disable_unprepare(mhdp->clk);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id mhdp_ids[] = {\n\t{ .compatible = \"cdns,mhdp8546\", },\n#ifdef CONFIG_DRM_CDNS_MHDP8546_J721E\n\t{ .compatible = \"ti,j721e-mhdp8546\",\n\t  .data = &(const struct cdns_mhdp_platform_info) {\n\t\t  .input_bus_flags = &mhdp_ti_j721e_bridge_input_bus_flags,\n\t\t  .ops = &mhdp_ti_j721e_ops,\n\t  },\n\t},\n#endif\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mhdp_ids);\n\nstatic struct platform_driver mhdp_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"cdns-mhdp8546\",\n\t\t.of_match_table\t= mhdp_ids,\n\t},\n\t.probe\t= cdns_mhdp_probe,\n\t.remove\t= cdns_mhdp_remove,\n};\nmodule_platform_driver(mhdp_driver);\n\nMODULE_FIRMWARE(FW_NAME);\n\nMODULE_AUTHOR(\"Quentin Schulz <quentin.schulz@free-electrons.com>\");\nMODULE_AUTHOR(\"Swapnil Jakhade <sjakhade@cadence.com>\");\nMODULE_AUTHOR(\"Yuti Amonkar <yamonkar@cadence.com>\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_AUTHOR(\"Jyri Sarha <jsarha@ti.com>\");\nMODULE_DESCRIPTION(\"Cadence MHDP8546 DP bridge driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:cdns-mhdp8546\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}