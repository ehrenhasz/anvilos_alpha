{
  "module_name": "lontium-lt8912b.c",
  "hash_id": "cc21a259b0625d7309a099d4e261e1e82f8b4d083f62c5d4463ac0f88a874dd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/lontium-lt8912b.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n\n#include <video/videomode.h>\n\n#define I2C_MAIN 0\n#define I2C_ADDR_MAIN 0x48\n\n#define I2C_CEC_DSI 1\n#define I2C_ADDR_CEC_DSI 0x49\n\n#define I2C_MAX_IDX 2\n\nstruct lt8912 {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_connector connector;\n\n\tstruct i2c_client *i2c_client[I2C_MAX_IDX];\n\tstruct regmap *regmap[I2C_MAX_IDX];\n\n\tstruct device_node *host_node;\n\tstruct drm_bridge *hdmi_port;\n\n\tstruct mipi_dsi_device *dsi;\n\n\tstruct gpio_desc *gp_reset;\n\n\tstruct videomode mode;\n\n\tu8 data_lanes;\n\tbool is_power_on;\n};\n\nstatic int lt8912_write_init_config(struct lt8912 *lt)\n{\n\tconst struct reg_sequence seq[] = {\n\t\t \n\t\t{0x08, 0xff},\n\t\t{0x09, 0xff},\n\t\t{0x0a, 0xff},\n\t\t{0x0b, 0x7c},\n\t\t{0x0c, 0xff},\n\t\t{0x42, 0x04},\n\n\t\t \n\t\t{0x31, 0xb1},\n\t\t{0x32, 0xb1},\n\t\t{0x33, 0x0e},\n\t\t{0x37, 0x00},\n\t\t{0x38, 0x22},\n\t\t{0x60, 0x82},\n\n\t\t \n\t\t{0x39, 0x45},\n\t\t{0x3a, 0x00},\n\t\t{0x3b, 0x00},\n\n\t\t \n\t\t{0x44, 0x31},\n\t\t{0x55, 0x44},\n\t\t{0x57, 0x01},\n\t\t{0x5a, 0x02},\n\n\t\t \n\t\t{0x3e, 0xd6},\n\t\t{0x3f, 0xd4},\n\t\t{0x41, 0x3c},\n\t\t{0xB2, 0x00},\n\t};\n\n\treturn regmap_multi_reg_write(lt->regmap[I2C_MAIN], seq, ARRAY_SIZE(seq));\n}\n\nstatic int lt8912_write_mipi_basic_config(struct lt8912 *lt)\n{\n\tconst struct reg_sequence seq[] = {\n\t\t{0x12, 0x04},\n\t\t{0x14, 0x00},\n\t\t{0x15, 0x00},\n\t\t{0x1a, 0x03},\n\t\t{0x1b, 0x03},\n\t};\n\n\treturn regmap_multi_reg_write(lt->regmap[I2C_CEC_DSI], seq, ARRAY_SIZE(seq));\n};\n\nstatic int lt8912_write_dds_config(struct lt8912 *lt)\n{\n\tconst struct reg_sequence seq[] = {\n\t\t{0x4e, 0xff},\n\t\t{0x4f, 0x56},\n\t\t{0x50, 0x69},\n\t\t{0x51, 0x80},\n\t\t{0x1f, 0x5e},\n\t\t{0x20, 0x01},\n\t\t{0x21, 0x2c},\n\t\t{0x22, 0x01},\n\t\t{0x23, 0xfa},\n\t\t{0x24, 0x00},\n\t\t{0x25, 0xc8},\n\t\t{0x26, 0x00},\n\t\t{0x27, 0x5e},\n\t\t{0x28, 0x01},\n\t\t{0x29, 0x2c},\n\t\t{0x2a, 0x01},\n\t\t{0x2b, 0xfa},\n\t\t{0x2c, 0x00},\n\t\t{0x2d, 0xc8},\n\t\t{0x2e, 0x00},\n\t\t{0x42, 0x64},\n\t\t{0x43, 0x00},\n\t\t{0x44, 0x04},\n\t\t{0x45, 0x00},\n\t\t{0x46, 0x59},\n\t\t{0x47, 0x00},\n\t\t{0x48, 0xf2},\n\t\t{0x49, 0x06},\n\t\t{0x4a, 0x00},\n\t\t{0x4b, 0x72},\n\t\t{0x4c, 0x45},\n\t\t{0x4d, 0x00},\n\t\t{0x52, 0x08},\n\t\t{0x53, 0x00},\n\t\t{0x54, 0xb2},\n\t\t{0x55, 0x00},\n\t\t{0x56, 0xe4},\n\t\t{0x57, 0x0d},\n\t\t{0x58, 0x00},\n\t\t{0x59, 0xe4},\n\t\t{0x5a, 0x8a},\n\t\t{0x5b, 0x00},\n\t\t{0x5c, 0x34},\n\t\t{0x1e, 0x4f},\n\t\t{0x51, 0x00},\n\t};\n\n\treturn regmap_multi_reg_write(lt->regmap[I2C_CEC_DSI], seq, ARRAY_SIZE(seq));\n}\n\nstatic int lt8912_write_rxlogicres_config(struct lt8912 *lt)\n{\n\tint ret;\n\n\tret = regmap_write(lt->regmap[I2C_MAIN], 0x03, 0x7f);\n\tusleep_range(10000, 20000);\n\tret |= regmap_write(lt->regmap[I2C_MAIN], 0x03, 0xff);\n\n\treturn ret;\n};\n\n \nstatic int lt8912_write_lvds_config(struct lt8912 *lt)\n{\n\tconst struct reg_sequence seq[] = {\n\t\t\n\t\t{0x44, 0x30},\n\t\t{0x51, 0x05},\n\n\t\t\n\t\t{0x50, 0x24}, \n\t\t{0x51, 0x2d}, \n\t\t{0x52, 0x04}, \n\t\t{0x69, 0x0e}, \n\t\t{0x69, 0x8e},\n\t\t{0x6a, 0x00},\n\t\t{0x6c, 0xb8}, \n\t\t{0x6b, 0x51},\n\n\t\t{0x04, 0xfb}, \n\t\t{0x04, 0xff},\n\n\t\t\n\t\t{0x7f, 0x00}, \n\t\t{0xa8, 0x13}, \n\n\t\t{0x02, 0xf7}, \n\t\t{0x02, 0xff},\n\t\t{0x03, 0xcf},\n\t\t{0x03, 0xff},\n\t};\n\n\treturn regmap_multi_reg_write(lt->regmap[I2C_MAIN], seq, ARRAY_SIZE(seq));\n};\n\nstatic inline struct lt8912 *bridge_to_lt8912(struct drm_bridge *b)\n{\n\treturn container_of(b, struct lt8912, bridge);\n}\n\nstatic inline struct lt8912 *connector_to_lt8912(struct drm_connector *c)\n{\n\treturn container_of(c, struct lt8912, connector);\n}\n\nstatic const struct regmap_config lt8912_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n};\n\nstatic int lt8912_init_i2c(struct lt8912 *lt, struct i2c_client *client)\n{\n\tunsigned int i;\n\t \n\tstruct i2c_board_info info[] = {\n\t\t{ I2C_BOARD_INFO(\"lt8912p0\", I2C_ADDR_MAIN), },\n\t\t{ I2C_BOARD_INFO(\"lt8912p1\", I2C_ADDR_CEC_DSI), },\n\t};\n\n\tif (!lt)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(info); i++) {\n\t\tif (i > 0) {\n\t\t\tlt->i2c_client[i] = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\t\t\t info[i].addr);\n\t\t\tif (IS_ERR(lt->i2c_client[i]))\n\t\t\t\treturn PTR_ERR(lt->i2c_client[i]);\n\t\t}\n\n\t\tlt->regmap[i] = devm_regmap_init_i2c(lt->i2c_client[i],\n\t\t\t\t\t\t     &lt8912_regmap_config);\n\t\tif (IS_ERR(lt->regmap[i]))\n\t\t\treturn PTR_ERR(lt->regmap[i]);\n\t}\n\treturn 0;\n}\n\nstatic int lt8912_free_i2c(struct lt8912 *lt)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < I2C_MAX_IDX; i++)\n\t\ti2c_unregister_device(lt->i2c_client[i]);\n\n\treturn 0;\n}\n\nstatic int lt8912_hard_power_on(struct lt8912 *lt)\n{\n\tgpiod_set_value_cansleep(lt->gp_reset, 0);\n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic void lt8912_hard_power_off(struct lt8912 *lt)\n{\n\tgpiod_set_value_cansleep(lt->gp_reset, 1);\n\tmsleep(20);\n\tlt->is_power_on = false;\n}\n\nstatic int lt8912_video_setup(struct lt8912 *lt)\n{\n\tu32 hactive, h_total, hpw, hfp, hbp;\n\tu32 vactive, v_total, vpw, vfp, vbp;\n\tu8 settle = 0x08;\n\tint ret, hsync_activehigh, vsync_activehigh;\n\n\tif (!lt)\n\t\treturn -EINVAL;\n\n\thactive = lt->mode.hactive;\n\thfp = lt->mode.hfront_porch;\n\thpw = lt->mode.hsync_len;\n\thbp = lt->mode.hback_porch;\n\th_total = hactive + hfp + hpw + hbp;\n\thsync_activehigh = lt->mode.flags & DISPLAY_FLAGS_HSYNC_HIGH;\n\n\tvactive = lt->mode.vactive;\n\tvfp = lt->mode.vfront_porch;\n\tvpw = lt->mode.vsync_len;\n\tvbp = lt->mode.vback_porch;\n\tv_total = vactive + vfp + vpw + vbp;\n\tvsync_activehigh = lt->mode.flags & DISPLAY_FLAGS_VSYNC_HIGH;\n\n\tif (vactive <= 600)\n\t\tsettle = 0x04;\n\telse if (vactive == 1080)\n\t\tsettle = 0x0a;\n\n\tret = regmap_write(lt->regmap[I2C_CEC_DSI], 0x10, 0x01);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x11, settle);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x18, hpw);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x19, vpw);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x1c, hactive & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x1d, hactive >> 8);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x2f, 0x0c);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x34, h_total & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x35, h_total >> 8);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x36, v_total & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x37, v_total >> 8);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x38, vbp & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x39, vbp >> 8);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3a, vfp & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3b, vfp >> 8);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3c, hbp & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3d, hbp >> 8);\n\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3e, hfp & 0xff);\n\tret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3f, hfp >> 8);\n\n\tret |= regmap_update_bits(lt->regmap[I2C_MAIN], 0xab, BIT(0),\n\t\t\t\t  vsync_activehigh ? BIT(0) : 0);\n\tret |= regmap_update_bits(lt->regmap[I2C_MAIN], 0xab, BIT(1),\n\t\t\t\t  hsync_activehigh ? BIT(1) : 0);\n\tret |= regmap_update_bits(lt->regmap[I2C_MAIN], 0xb2, BIT(0),\n\t\t\t\t  lt->connector.display_info.is_hdmi ? BIT(0) : 0);\n\n\treturn ret;\n}\n\nstatic int lt8912_soft_power_on(struct lt8912 *lt)\n{\n\tif (!lt->is_power_on) {\n\t\tu32 lanes = lt->data_lanes;\n\n\t\tlt8912_write_init_config(lt);\n\t\tregmap_write(lt->regmap[I2C_CEC_DSI], 0x13, lanes & 3);\n\n\t\tlt8912_write_mipi_basic_config(lt);\n\n\t\tlt->is_power_on = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int lt8912_video_on(struct lt8912 *lt)\n{\n\tint ret;\n\n\tret = lt8912_video_setup(lt);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tret = lt8912_write_dds_config(lt);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tret = lt8912_write_rxlogicres_config(lt);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tret = lt8912_write_lvds_config(lt);\n\tif (ret < 0)\n\t\tgoto end;\n\nend:\n\treturn ret;\n}\n\nstatic enum drm_connector_status lt8912_check_cable_status(struct lt8912 *lt)\n{\n\tint ret;\n\tunsigned int reg_val;\n\n\tret = regmap_read(lt->regmap[I2C_MAIN], 0xC1, &reg_val);\n\tif (ret)\n\t\treturn connector_status_unknown;\n\n\tif (reg_val & BIT(7))\n\t\treturn connector_status_connected;\n\n\treturn connector_status_disconnected;\n}\n\nstatic enum drm_connector_status\nlt8912_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct lt8912 *lt = connector_to_lt8912(connector);\n\n\tif (lt->hdmi_port->ops & DRM_BRIDGE_OP_DETECT)\n\t\treturn drm_bridge_detect(lt->hdmi_port);\n\n\treturn lt8912_check_cable_status(lt);\n}\n\nstatic const struct drm_connector_funcs lt8912_connector_funcs = {\n\t.detect = lt8912_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic enum drm_mode_status\nlt8912_connector_mode_valid(struct drm_connector *connector,\n\t\t\t    struct drm_display_mode *mode)\n{\n\tif (mode->clock > 150000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->hdisplay > 1920)\n\t\treturn MODE_BAD_HVALUE;\n\n\tif (mode->vdisplay > 1080)\n\t\treturn MODE_BAD_VVALUE;\n\n\treturn MODE_OK;\n}\n\nstatic int lt8912_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct edid *edid;\n\tint ret = -1;\n\tint num = 0;\n\tstruct lt8912 *lt = connector_to_lt8912(connector);\n\tu32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;\n\n\tedid = drm_bridge_get_edid(lt->hdmi_port, connector);\n\tif (edid) {\n\t\tdrm_connector_update_edid_property(connector, edid);\n\t\tnum = drm_add_edid_modes(connector, edid);\n\t} else {\n\t\treturn ret;\n\t}\n\n\tret = drm_display_info_set_bus_formats(&connector->display_info,\n\t\t\t\t\t       &bus_format, 1);\n\tif (ret)\n\t\tnum = ret;\n\n\tkfree(edid);\n\treturn num;\n}\n\nstatic const struct drm_connector_helper_funcs lt8912_connector_helper_funcs = {\n\t.get_modes = lt8912_connector_get_modes,\n\t.mode_valid = lt8912_connector_mode_valid,\n};\n\nstatic void lt8912_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   const struct drm_display_mode *adj)\n{\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\n\tdrm_display_mode_to_videomode(adj, &lt->mode);\n}\n\nstatic void lt8912_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\n\tlt8912_video_on(lt);\n}\n\nstatic int lt8912_attach_dsi(struct lt8912 *lt)\n{\n\tstruct device *dev = lt->dev;\n\tstruct mipi_dsi_host *host;\n\tstruct mipi_dsi_device *dsi;\n\tint ret = -1;\n\tconst struct mipi_dsi_device_info info = { .type = \"lt8912\",\n\t\t\t\t\t\t   .channel = 0,\n\t\t\t\t\t\t   .node = NULL,\n\t\t\t\t\t\t };\n\n\thost = of_find_mipi_dsi_host_by_node(lt->host_node);\n\tif (!host) {\n\t\tdev_err(dev, \"failed to find dsi host\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi)) {\n\t\tret = PTR_ERR(dsi);\n\t\tdev_err(dev, \"failed to create dsi device (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tlt->dsi = dsi;\n\n\tdsi->lanes = lt->data_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO |\n\t\t\t  MIPI_DSI_MODE_LPM |\n\t\t\t  MIPI_DSI_MODE_NO_EOT_PACKET;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void lt8912_bridge_hpd_cb(void *data, enum drm_connector_status status)\n{\n\tstruct lt8912 *lt = data;\n\n\tif (lt->bridge.dev)\n\t\tdrm_helper_hpd_irq_event(lt->bridge.dev);\n}\n\nstatic int lt8912_bridge_connector_init(struct drm_bridge *bridge)\n{\n\tint ret;\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\tstruct drm_connector *connector = &lt->connector;\n\n\tif (lt->hdmi_port->ops & DRM_BRIDGE_OP_HPD) {\n\t\tdrm_bridge_hpd_enable(lt->hdmi_port, lt8912_bridge_hpd_cb, lt);\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\t} else {\n\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t\t    DRM_CONNECTOR_POLL_DISCONNECT;\n\t}\n\n\tret = drm_connector_init(bridge->dev, connector,\n\t\t\t\t &lt8912_connector_funcs,\n\t\t\t\t lt->hdmi_port->type);\n\tif (ret)\n\t\tgoto exit;\n\n\tdrm_connector_helper_add(connector, &lt8912_connector_helper_funcs);\n\n\tconnector->dpms = DRM_MODE_DPMS_OFF;\n\tdrm_connector_attach_encoder(connector, bridge->encoder);\n\nexit:\n\treturn ret;\n}\n\nstatic int lt8912_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\tint ret;\n\n\tret = drm_bridge_attach(bridge->encoder, lt->hdmi_port, bridge,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret < 0) {\n\t\tdev_err(lt->dev, \"Failed to attach next bridge (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tret = lt8912_bridge_connector_init(bridge);\n\t\tif (ret) {\n\t\t\tdev_err(lt->dev, \"Failed to init bridge ! (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = lt8912_hard_power_on(lt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lt8912_soft_power_on(lt);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tlt8912_hard_power_off(lt);\n\treturn ret;\n}\n\nstatic void lt8912_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\n\tlt8912_hard_power_off(lt);\n\n\tif (lt->connector.dev && lt->hdmi_port->ops & DRM_BRIDGE_OP_HPD)\n\t\tdrm_bridge_hpd_disable(lt->hdmi_port);\n}\n\nstatic enum drm_connector_status\nlt8912_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\n\tif (lt->hdmi_port->ops & DRM_BRIDGE_OP_DETECT)\n\t\treturn drm_bridge_detect(lt->hdmi_port);\n\n\treturn lt8912_check_cable_status(lt);\n}\n\nstatic struct edid *lt8912_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct lt8912 *lt = bridge_to_lt8912(bridge);\n\n\t \n\tif (lt->hdmi_port->ops & DRM_BRIDGE_OP_EDID)\n\t\treturn drm_bridge_get_edid(lt->hdmi_port, connector);\n\n\tdev_warn(lt->dev, \"The connected bridge does not supports DRM_BRIDGE_OP_EDID\\n\");\n\treturn NULL;\n}\n\nstatic const struct drm_bridge_funcs lt8912_bridge_funcs = {\n\t.attach = lt8912_bridge_attach,\n\t.detach = lt8912_bridge_detach,\n\t.mode_set = lt8912_bridge_mode_set,\n\t.enable = lt8912_bridge_enable,\n\t.detect = lt8912_bridge_detect,\n\t.get_edid = lt8912_bridge_get_edid,\n};\n\nstatic int lt8912_parse_dt(struct lt8912 *lt)\n{\n\tstruct gpio_desc *gp_reset;\n\tstruct device *dev = lt->dev;\n\tint ret;\n\tint data_lanes;\n\tstruct device_node *port_node;\n\n\tgp_reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gp_reset)) {\n\t\tret = PTR_ERR(gp_reset);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get reset gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tlt->gp_reset = gp_reset;\n\n\tdata_lanes = drm_of_get_data_lanes_count_ep(dev->of_node, 0, -1, 1, 4);\n\tif (data_lanes < 0) {\n\t\tdev_err(lt->dev, \"%s: Bad data-lanes property\\n\", __func__);\n\t\treturn data_lanes;\n\t}\n\n\tlt->data_lanes = data_lanes;\n\n\tlt->host_node = of_graph_get_remote_node(dev->of_node, 0, -1);\n\tif (!lt->host_node) {\n\t\tdev_err(lt->dev, \"%s: Failed to get remote port\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tport_node = of_graph_get_remote_node(dev->of_node, 1, -1);\n\tif (!port_node) {\n\t\tdev_err(lt->dev, \"%s: Failed to get connector port\\n\", __func__);\n\t\tret = -ENODEV;\n\t\tgoto err_free_host_node;\n\t}\n\n\tlt->hdmi_port = of_drm_find_bridge(port_node);\n\tif (!lt->hdmi_port) {\n\t\tret = -EPROBE_DEFER;\n\t\tdev_err_probe(lt->dev, ret, \"%s: Failed to get hdmi port\\n\", __func__);\n\t\tgoto err_free_host_node;\n\t}\n\n\tif (!of_device_is_compatible(port_node, \"hdmi-connector\")) {\n\t\tdev_err(lt->dev, \"%s: Failed to get hdmi port\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto err_free_host_node;\n\t}\n\n\tof_node_put(port_node);\n\treturn 0;\n\nerr_free_host_node:\n\tof_node_put(port_node);\n\tof_node_put(lt->host_node);\n\treturn ret;\n}\n\nstatic int lt8912_put_dt(struct lt8912 *lt)\n{\n\tof_node_put(lt->host_node);\n\treturn 0;\n}\n\nstatic int lt8912_probe(struct i2c_client *client)\n{\n\tstatic struct lt8912 *lt;\n\tint ret = 0;\n\tstruct device *dev = &client->dev;\n\n\tlt = devm_kzalloc(dev, sizeof(struct lt8912), GFP_KERNEL);\n\tif (!lt)\n\t\treturn -ENOMEM;\n\n\tlt->dev = dev;\n\tlt->i2c_client[0] = client;\n\n\tret = lt8912_parse_dt(lt);\n\tif (ret)\n\t\tgoto err_dt_parse;\n\n\tret = lt8912_init_i2c(lt, client);\n\tif (ret)\n\t\tgoto err_i2c;\n\n\ti2c_set_clientdata(client, lt);\n\n\tlt->bridge.funcs = &lt8912_bridge_funcs;\n\tlt->bridge.of_node = dev->of_node;\n\tlt->bridge.ops = (DRM_BRIDGE_OP_EDID |\n\t\t\t  DRM_BRIDGE_OP_DETECT);\n\n\tdrm_bridge_add(&lt->bridge);\n\n\tret = lt8912_attach_dsi(lt);\n\tif (ret)\n\t\tgoto err_attach;\n\n\treturn 0;\n\nerr_attach:\n\tdrm_bridge_remove(&lt->bridge);\n\tlt8912_free_i2c(lt);\nerr_i2c:\n\tlt8912_put_dt(lt);\nerr_dt_parse:\n\treturn ret;\n}\n\nstatic void lt8912_remove(struct i2c_client *client)\n{\n\tstruct lt8912 *lt = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&lt->bridge);\n\tlt8912_free_i2c(lt);\n\tlt8912_put_dt(lt);\n}\n\nstatic const struct of_device_id lt8912_dt_match[] = {\n\t{.compatible = \"lontium,lt8912b\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lt8912_dt_match);\n\nstatic const struct i2c_device_id lt8912_id[] = {\n\t{\"lt8912\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, lt8912_id);\n\nstatic struct i2c_driver lt8912_i2c_driver = {\n\t.driver = {\n\t\t.name = \"lt8912\",\n\t\t.of_match_table = lt8912_dt_match,\n\t},\n\t.probe = lt8912_probe,\n\t.remove = lt8912_remove,\n\t.id_table = lt8912_id,\n};\nmodule_i2c_driver(lt8912_i2c_driver);\n\nMODULE_AUTHOR(\"Adrien Grassein <adrien.grassein@gmail.com>\");\nMODULE_DESCRIPTION(\"lt8912 drm driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}