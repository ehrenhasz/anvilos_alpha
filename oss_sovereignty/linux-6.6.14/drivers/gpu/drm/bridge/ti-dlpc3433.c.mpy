{
  "module_name": "ti-dlpc3433.c",
  "hash_id": "0480bc99fc26a31769fe20d35c1efb74f182240471866d0cacb6e93fd0dd932b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ti-dlpc3433.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_mipi_dsi.h>\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\nenum cmd_registers {\n\tWR_INPUT_SOURCE\t\t= 0x05,\t \n\tWR_EXT_SOURCE_FMT\t= 0x07,  \n\tWR_IMAGE_CROP\t\t= 0x10,\t \n\tWR_DISPLAY_SIZE\t\t= 0x12,\t \n\tWR_IMAGE_FREEZE\t\t= 0x1A,\t \n\tWR_INPUT_IMAGE_SIZE\t= 0x2E,\t \n\tWR_RGB_LED_EN\t\t= 0x52,\t \n\tWR_RGB_LED_CURRENT\t= 0x54,\t \n\tWR_RGB_LED_MAX_CURRENT\t= 0x5C,\t \n\tWR_DSI_HS_CLK\t\t= 0xBD,\t \n\tRD_DEVICE_ID\t\t= 0xD4,\t \n\tWR_DSI_PORT_EN\t\t= 0xD7,\t \n};\n\nenum input_source {\n\tINPUT_EXTERNAL_VIDEO\t= 0,\n\tINPUT_TEST_PATTERN,\n\tINPUT_SPLASH_SCREEN,\n};\n\n#define DEV_ID_MASK\t\tGENMASK(3, 0)\n#define IMAGE_FREESE_EN\t\tBIT(0)\n#define DSI_PORT_EN\t\t0\n#define EXT_SOURCE_FMT_DSI\t0\n#define RED_LED_EN\t\tBIT(0)\n#define GREEN_LED_EN\t\tBIT(1)\n#define BLUE_LED_EN\t\tBIT(2)\n#define LED_MASK\t\tGENMASK(2, 0)\n#define MAX_BYTE_SIZE\t\t8\n\nstruct dlpc {\n\tstruct device\t\t*dev;\n\tstruct drm_bridge\tbridge;\n\tstruct drm_bridge\t*next_bridge;\n\tstruct device_node\t*host_node;\n\tstruct mipi_dsi_device\t*dsi;\n\tstruct drm_display_mode\tmode;\n\n\tstruct gpio_desc\t*enable_gpio;\n\tstruct regulator\t*vcc_intf;\n\tstruct regulator\t*vcc_flsh;\n\tstruct regmap\t\t*regmap;\n\tunsigned int\t\tdsi_lanes;\n};\n\nstatic inline struct dlpc *bridge_to_dlpc(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct dlpc, bridge);\n}\n\nstatic bool dlpc_writeable_noinc_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WR_IMAGE_CROP:\n\tcase WR_DISPLAY_SIZE:\n\tcase WR_INPUT_IMAGE_SIZE:\n\tcase WR_DSI_HS_CLK:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_range dlpc_volatile_ranges[] = {\n\t{ .range_min = 0x10, .range_max = 0xBF },\n};\n\nstatic const struct regmap_access_table dlpc_volatile_table = {\n\t.yes_ranges = dlpc_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(dlpc_volatile_ranges),\n};\n\nstatic struct regmap_config dlpc_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= WR_DSI_PORT_EN,\n\t.writeable_noinc_reg\t= dlpc_writeable_noinc_reg,\n\t.volatile_table\t\t= &dlpc_volatile_table,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n\t.name\t\t\t= \"dlpc3433\",\n};\n\nstatic void dlpc_atomic_enable(struct drm_bridge *bridge,\n\t\t\t       struct drm_bridge_state *old_bridge_state)\n{\n\tstruct dlpc *dlpc = bridge_to_dlpc(bridge);\n\tstruct device *dev = dlpc->dev;\n\tstruct drm_display_mode *mode = &dlpc->mode;\n\tstruct regmap *regmap = dlpc->regmap;\n\tchar buf[MAX_BYTE_SIZE];\n\tunsigned int devid;\n\n\tregmap_read(regmap, RD_DEVICE_ID, &devid);\n\tdevid &= DEV_ID_MASK;\n\n\tDRM_DEV_DEBUG(dev, \"DLPC3433 device id: 0x%02x\\n\", devid);\n\n\tif (devid != 0x01) {\n\t\tDRM_DEV_ERROR(dev, \"Unsupported DLPC device id: 0x%02x\\n\", devid);\n\t\treturn;\n\t}\n\n\t \n\tregmap_write(regmap, WR_IMAGE_FREEZE, IMAGE_FREESE_EN);\n\n\t \n\tregmap_write(regmap, WR_DSI_PORT_EN, DSI_PORT_EN);\n\n\tmemset(buf, 0, MAX_BYTE_SIZE);\n\n\t \n\tbuf[4] = mode->hdisplay & 0xff;\n\tbuf[5] = (mode->hdisplay & 0xff00) >> 8;\n\tbuf[6] = mode->vdisplay & 0xff;\n\tbuf[7] = (mode->vdisplay & 0xff00) >> 8;\n\tregmap_noinc_write(regmap, WR_IMAGE_CROP, buf, MAX_BYTE_SIZE);\n\n\t \n\tbuf[4] = mode->hdisplay & 0xff;\n\tbuf[5] = (mode->hdisplay & 0xff00) >> 8;\n\tbuf[6] = mode->vdisplay & 0xff;\n\tbuf[7] = (mode->vdisplay & 0xff00) >> 8;\n\tregmap_noinc_write(regmap, WR_DISPLAY_SIZE, buf, MAX_BYTE_SIZE);\n\n\t \n\tbuf[0] = mode->hdisplay & 0xff;\n\tbuf[1] = (mode->hdisplay & 0xff00) >> 8;\n\tbuf[2] = mode->vdisplay & 0xff;\n\tbuf[3] = (mode->vdisplay & 0xff00) >> 8;\n\tregmap_noinc_write(regmap, WR_INPUT_IMAGE_SIZE, buf, 4);\n\n\t \n\tregmap_write(regmap, WR_INPUT_SOURCE, INPUT_EXTERNAL_VIDEO);\n\n\t \n\tregmap_write(regmap, WR_EXT_SOURCE_FMT, EXT_SOURCE_FMT_DSI);\n\n\t \n\tregmap_write(regmap, WR_IMAGE_FREEZE, 0x00);\n\n\t \n\tregmap_update_bits(regmap, WR_RGB_LED_EN, LED_MASK,\n\t\t\t   RED_LED_EN | GREEN_LED_EN | BLUE_LED_EN);\n\n\tmsleep(10);\n}\n\nstatic void dlpc_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct dlpc *dlpc = bridge_to_dlpc(bridge);\n\tint ret;\n\n\tgpiod_set_value(dlpc->enable_gpio, 1);\n\n\tmsleep(500);\n\n\tret = regulator_enable(dlpc->vcc_intf);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dlpc->dev,\n\t\t\t      \"failed to enable VCC_INTF regulator: %d\\n\", ret);\n\n\tret = regulator_enable(dlpc->vcc_flsh);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dlpc->dev,\n\t\t\t      \"failed to enable VCC_FLSH regulator: %d\\n\", ret);\n\n\tmsleep(10);\n}\n\nstatic void dlpc_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct dlpc *dlpc = bridge_to_dlpc(bridge);\n\n\tregulator_disable(dlpc->vcc_flsh);\n\tregulator_disable(dlpc->vcc_intf);\n\n\tmsleep(10);\n\n\tgpiod_set_value(dlpc->enable_gpio, 0);\n\n\tmsleep(500);\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\ndlpc_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t       struct drm_bridge_state *bridge_state,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state,\n\t\t\t       u32 output_fmt,\n\t\t\t       unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t \n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic void dlpc_mode_set(struct drm_bridge *bridge,\n\t\t\t  const struct drm_display_mode *mode,\n\t\t\t  const struct drm_display_mode *adjusted_mode)\n{\n\tstruct dlpc *dlpc = bridge_to_dlpc(bridge);\n\n\tdrm_mode_copy(&dlpc->mode, adjusted_mode);\n}\n\nstatic int dlpc_attach(struct drm_bridge *bridge,\n\t\t       enum drm_bridge_attach_flags flags)\n{\n\tstruct dlpc *dlpc = bridge_to_dlpc(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, dlpc->next_bridge, bridge, flags);\n}\n\nstatic const struct drm_bridge_funcs dlpc_bridge_funcs = {\n\t.atomic_duplicate_state\t\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts\t= dlpc_atomic_get_input_bus_fmts,\n\t.atomic_reset\t\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_pre_enable\t\t= dlpc_atomic_pre_enable,\n\t.atomic_enable\t\t\t= dlpc_atomic_enable,\n\t.atomic_post_disable\t\t= dlpc_atomic_post_disable,\n\t.mode_set\t\t\t= dlpc_mode_set,\n\t.attach\t\t\t\t= dlpc_attach,\n};\n\nstatic int dlpc3433_parse_dt(struct dlpc *dlpc)\n{\n\tstruct device *dev = dlpc->dev;\n\tstruct device_node *endpoint;\n\tint ret;\n\n\tdlpc->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dlpc->enable_gpio))\n\t\treturn PTR_ERR(dlpc->enable_gpio);\n\n\tdlpc->vcc_intf = devm_regulator_get(dlpc->dev, \"vcc_intf\");\n\tif (IS_ERR(dlpc->vcc_intf))\n\t\treturn dev_err_probe(dev, PTR_ERR(dlpc->vcc_intf),\n\t\t\t\t     \"failed to get VCC_INTF supply\\n\");\n\n\tdlpc->vcc_flsh = devm_regulator_get(dlpc->dev, \"vcc_flsh\");\n\tif (IS_ERR(dlpc->vcc_flsh))\n\t\treturn dev_err_probe(dev, PTR_ERR(dlpc->vcc_flsh),\n\t\t\t\t     \"failed to get VCC_FLSH supply\\n\");\n\n\tdlpc->next_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 1, 0);\n\tif (IS_ERR(dlpc->next_bridge))\n\t\treturn PTR_ERR(dlpc->next_bridge);\n\n\tendpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, 0);\n\tdlpc->dsi_lanes = of_property_count_u32_elems(endpoint, \"data-lanes\");\n\tif (dlpc->dsi_lanes < 0 || dlpc->dsi_lanes > 4) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_endpoint;\n\t}\n\n\tdlpc->host_node = of_graph_get_remote_port_parent(endpoint);\n\tif (!dlpc->host_node) {\n\t\tret = -ENODEV;\n\t\tgoto err_put_host;\n\t}\n\n\tof_node_put(endpoint);\n\n\treturn 0;\n\nerr_put_host:\n\tof_node_put(dlpc->host_node);\nerr_put_endpoint:\n\tof_node_put(endpoint);\n\treturn ret;\n}\n\nstatic int dlpc_host_attach(struct dlpc *dlpc)\n{\n\tstruct device *dev = dlpc->dev;\n\tstruct mipi_dsi_host *host;\n\tstruct mipi_dsi_device_info info = {\n\t\t.type = \"dlpc3433\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\n\thost = of_find_mipi_dsi_host_by_node(dlpc->host_node);\n\tif (!host) {\n\t\tDRM_DEV_ERROR(dev, \"failed to find dsi host\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdlpc->dsi = mipi_dsi_device_register_full(host, &info);\n\tif (IS_ERR(dlpc->dsi)) {\n\t\tDRM_DEV_ERROR(dev, \"failed to create dsi device\\n\");\n\t\treturn PTR_ERR(dlpc->dsi);\n\t}\n\n\tdlpc->dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST;\n\tdlpc->dsi->format = MIPI_DSI_FMT_RGB565;\n\tdlpc->dsi->lanes = dlpc->dsi_lanes;\n\n\treturn devm_mipi_dsi_attach(dev, dlpc->dsi);\n}\n\nstatic int dlpc3433_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct dlpc *dlpc;\n\tint ret;\n\n\tdlpc = devm_kzalloc(dev, sizeof(*dlpc), GFP_KERNEL);\n\tif (!dlpc)\n\t\treturn -ENOMEM;\n\n\tdlpc->dev = dev;\n\n\tdlpc->regmap = devm_regmap_init_i2c(client, &dlpc_regmap_config);\n\tif (IS_ERR(dlpc->regmap))\n\t\treturn PTR_ERR(dlpc->regmap);\n\n\tret = dlpc3433_parse_dt(dlpc);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, dlpc);\n\ti2c_set_clientdata(client, dlpc);\n\n\tdlpc->bridge.funcs = &dlpc_bridge_funcs;\n\tdlpc->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&dlpc->bridge);\n\n\tret = dlpc_host_attach(dlpc);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to attach dsi host\\n\");\n\t\tgoto err_remove_bridge;\n\t}\n\n\treturn 0;\n\nerr_remove_bridge:\n\tdrm_bridge_remove(&dlpc->bridge);\n\treturn ret;\n}\n\nstatic void dlpc3433_remove(struct i2c_client *client)\n{\n\tstruct dlpc *dlpc = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&dlpc->bridge);\n\tof_node_put(dlpc->host_node);\n}\n\nstatic const struct i2c_device_id dlpc3433_id[] = {\n\t{ \"ti,dlpc3433\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, dlpc3433_id);\n\nstatic const struct of_device_id dlpc3433_match_table[] = {\n\t{ .compatible = \"ti,dlpc3433\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dlpc3433_match_table);\n\nstatic struct i2c_driver dlpc3433_driver = {\n\t.probe = dlpc3433_probe,\n\t.remove = dlpc3433_remove,\n\t.id_table = dlpc3433_id,\n\t.driver = {\n\t\t.name = \"ti-dlpc3433\",\n\t\t.of_match_table = dlpc3433_match_table,\n\t},\n};\nmodule_i2c_driver(dlpc3433_driver);\n\nMODULE_AUTHOR(\"Jagan Teki <jagan@amarulasolutions.com>\");\nMODULE_AUTHOR(\"Christopher Vollo <chris@renewoutreach.org>\");\nMODULE_DESCRIPTION(\"TI DLPC3433 MIPI DSI Display Controller Bridge\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}