{
  "module_name": "parade-ps8640.c",
  "hash_id": "cad1347178ae592f764980133b80f08e247f0d2a5f22c774de6f3b221170f048",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/parade-ps8640.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n\n#define PAGE0_AUXCH_CFG3\t0x76\n#define  AUXCH_CFG3_RESET\t0xff\n#define PAGE0_SWAUX_ADDR_7_0\t0x7d\n#define PAGE0_SWAUX_ADDR_15_8\t0x7e\n#define PAGE0_SWAUX_ADDR_23_16\t0x7f\n#define  SWAUX_ADDR_MASK\tGENMASK(19, 0)\n#define PAGE0_SWAUX_LENGTH\t0x80\n#define  SWAUX_LENGTH_MASK\tGENMASK(3, 0)\n#define  SWAUX_NO_PAYLOAD\tBIT(7)\n#define PAGE0_SWAUX_WDATA\t0x81\n#define PAGE0_SWAUX_RDATA\t0x82\n#define PAGE0_SWAUX_CTRL\t0x83\n#define  SWAUX_SEND\t\tBIT(0)\n#define PAGE0_SWAUX_STATUS\t0x84\n#define  SWAUX_M_MASK\t\tGENMASK(4, 0)\n#define  SWAUX_STATUS_MASK\tGENMASK(7, 5)\n#define  SWAUX_STATUS_NACK\t(0x1 << 5)\n#define  SWAUX_STATUS_DEFER\t(0x2 << 5)\n#define  SWAUX_STATUS_ACKM\t(0x3 << 5)\n#define  SWAUX_STATUS_INVALID\t(0x4 << 5)\n#define  SWAUX_STATUS_I2C_NACK\t(0x5 << 5)\n#define  SWAUX_STATUS_I2C_DEFER\t(0x6 << 5)\n#define  SWAUX_STATUS_TIMEOUT\t(0x7 << 5)\n\n#define PAGE2_GPIO_H\t\t0xa7\n#define  PS_GPIO9\t\tBIT(1)\n#define PAGE2_I2C_BYPASS\t0xea\n#define  I2C_BYPASS_EN\t\t0xd0\n#define PAGE2_MCS_EN\t\t0xf3\n#define  MCS_EN\t\t\tBIT(0)\n\n#define PAGE3_SET_ADD\t\t0xfe\n#define  VDO_CTL_ADD\t\t0x13\n#define  VDO_DIS\t\t0x18\n#define  VDO_EN\t\t\t0x1c\n\n#define NUM_MIPI_LANES\t\t4\n\n#define COMMON_PS8640_REGMAP_CONFIG \\\n\t.reg_bits = 8, \\\n\t.val_bits = 8, \\\n\t.cache_type = REGCACHE_NONE\n\n \nenum page_addr_offset {\n\tPAGE0_DP_CNTL = 0,\n\tPAGE1_VDO_BDG,\n\tPAGE2_TOP_CNTL,\n\tPAGE3_DSI_CNTL1,\n\tPAGE4_MIPI_PHY,\n\tPAGE5_VPLL,\n\tPAGE6_DSI_CNTL2,\n\tPAGE7_SPI_CNTL,\n\tMAX_DEVS\n};\n\nenum ps8640_vdo_control {\n\tDISABLE = VDO_DIS,\n\tENABLE = VDO_EN,\n};\n\nstruct ps8640 {\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *panel_bridge;\n\tstruct drm_dp_aux aux;\n\tstruct mipi_dsi_device *dsi;\n\tstruct i2c_client *page[MAX_DEVS];\n\tstruct regmap\t*regmap[MAX_DEVS];\n\tstruct regulator_bulk_data supplies[2];\n\tstruct gpio_desc *gpio_reset;\n\tstruct gpio_desc *gpio_powerdown;\n\tstruct device_link *link;\n\tbool pre_enabled;\n\tbool need_post_hpd_delay;\n};\n\nstatic const struct regmap_config ps8640_regmap_config[] = {\n\t[PAGE0_DP_CNTL] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xbf,\n\t},\n\t[PAGE1_VDO_BDG] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xff,\n\t},\n\t[PAGE2_TOP_CNTL] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xff,\n\t},\n\t[PAGE3_DSI_CNTL1] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xff,\n\t},\n\t[PAGE4_MIPI_PHY] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xff,\n\t},\n\t[PAGE5_VPLL] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0x7f,\n\t},\n\t[PAGE6_DSI_CNTL2] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xff,\n\t},\n\t[PAGE7_SPI_CNTL] = {\n\t\tCOMMON_PS8640_REGMAP_CONFIG,\n\t\t.max_register = 0xff,\n\t},\n};\n\nstatic inline struct ps8640 *bridge_to_ps8640(struct drm_bridge *e)\n{\n\treturn container_of(e, struct ps8640, bridge);\n}\n\nstatic inline struct ps8640 *aux_to_ps8640(struct drm_dp_aux *aux)\n{\n\treturn container_of(aux, struct ps8640, aux);\n}\n\nstatic int _ps8640_wait_hpd_asserted(struct ps8640 *ps_bridge, unsigned long wait_us)\n{\n\tstruct regmap *map = ps_bridge->regmap[PAGE2_TOP_CNTL];\n\tint status;\n\tint ret;\n\n\t \n\tret = regmap_read_poll_timeout(map, PAGE2_GPIO_H, status,\n\t\t\t\t       status & PS_GPIO9, 20000, wait_us);\n\n\t \n\tif (!ret && ps_bridge->need_post_hpd_delay) {\n\t\tps_bridge->need_post_hpd_delay = false;\n\t\tmsleep(50);\n\t}\n\n\treturn ret;\n}\n\nstatic int ps8640_wait_hpd_asserted(struct drm_dp_aux *aux, unsigned long wait_us)\n{\n\tstruct ps8640 *ps_bridge = aux_to_ps8640(aux);\n\tstruct device *dev = &ps_bridge->page[PAGE0_DP_CNTL]->dev;\n\tint ret;\n\n\t \n\tpm_runtime_get_sync(dev);\n\tret = _ps8640_wait_hpd_asserted(ps_bridge, wait_us);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic ssize_t ps8640_aux_transfer_msg(struct drm_dp_aux *aux,\n\t\t\t\t       struct drm_dp_aux_msg *msg)\n{\n\tstruct ps8640 *ps_bridge = aux_to_ps8640(aux);\n\tstruct regmap *map = ps_bridge->regmap[PAGE0_DP_CNTL];\n\tstruct device *dev = &ps_bridge->page[PAGE0_DP_CNTL]->dev;\n\tsize_t len = msg->size;\n\tunsigned int data;\n\tunsigned int base;\n\tint ret;\n\tu8 request = msg->request &\n\t\t     ~(DP_AUX_I2C_MOT | DP_AUX_I2C_WRITE_STATUS_UPDATE);\n\tu8 *buf = msg->buffer;\n\tu8 addr_len[PAGE0_SWAUX_LENGTH + 1 - PAGE0_SWAUX_ADDR_7_0];\n\tu8 i;\n\tbool is_native_aux = false;\n\n\tif (len > DP_AUX_MAX_PAYLOAD_BYTES)\n\t\treturn -EINVAL;\n\n\tif (msg->address & ~SWAUX_ADDR_MASK)\n\t\treturn -EINVAL;\n\n\tswitch (request) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_NATIVE_READ:\n\t\tis_native_aux = true;\n\t\tfallthrough;\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_I2C_READ:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(map, PAGE0_AUXCH_CFG3, AUXCH_CFG3_RESET);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to write PAGE0_AUXCH_CFG3: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsg->reply = 0;\n\n\tbase = PAGE0_SWAUX_ADDR_7_0;\n\taddr_len[PAGE0_SWAUX_ADDR_7_0 - base] = msg->address;\n\taddr_len[PAGE0_SWAUX_ADDR_15_8 - base] = msg->address >> 8;\n\taddr_len[PAGE0_SWAUX_ADDR_23_16 - base] = (msg->address >> 16) |\n\t\t\t\t\t\t  (msg->request << 4);\n\taddr_len[PAGE0_SWAUX_LENGTH - base] = (len == 0) ? SWAUX_NO_PAYLOAD :\n\t\t\t\t\t      ((len - 1) & SWAUX_LENGTH_MASK);\n\n\tregmap_bulk_write(map, PAGE0_SWAUX_ADDR_7_0, addr_len,\n\t\t\t  ARRAY_SIZE(addr_len));\n\n\tif (len && (request == DP_AUX_NATIVE_WRITE ||\n\t\t    request == DP_AUX_I2C_WRITE)) {\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = regmap_write(map, PAGE0_SWAUX_WDATA, buf[i]);\n\t\t\tif (ret) {\n\t\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\t      \"failed to write WDATA: %d\\n\",\n\t\t\t\t\t      ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tregmap_write(map, PAGE0_SWAUX_CTRL, SWAUX_SEND);\n\n\t \n\tregmap_read_poll_timeout(map, PAGE0_SWAUX_CTRL, data,\n\t\t\t\t !(data & SWAUX_SEND), 0, 50 * 1000);\n\n\tregmap_read(map, PAGE0_SWAUX_STATUS, &data);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to read PAGE0_SWAUX_STATUS: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tswitch (data & SWAUX_STATUS_MASK) {\n\tcase SWAUX_STATUS_NACK:\n\tcase SWAUX_STATUS_I2C_NACK:\n\t\t \n\t\tif (is_native_aux)\n\t\t\tmsg->reply |= DP_AUX_NATIVE_REPLY_NACK;\n\t\telse\n\t\t\tmsg->reply |= DP_AUX_I2C_REPLY_NACK;\n\n\t\tfallthrough;\n\tcase SWAUX_STATUS_ACKM:\n\t\tlen = data & SWAUX_M_MASK;\n\t\tbreak;\n\tcase SWAUX_STATUS_DEFER:\n\tcase SWAUX_STATUS_I2C_DEFER:\n\t\tif (is_native_aux)\n\t\t\tmsg->reply |= DP_AUX_NATIVE_REPLY_DEFER;\n\t\telse\n\t\t\tmsg->reply |= DP_AUX_I2C_REPLY_DEFER;\n\t\tlen = data & SWAUX_M_MASK;\n\t\tbreak;\n\tcase SWAUX_STATUS_INVALID:\n\t\treturn -EOPNOTSUPP;\n\tcase SWAUX_STATUS_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (len && (request == DP_AUX_NATIVE_READ ||\n\t\t    request == DP_AUX_I2C_READ)) {\n\t\t \n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = regmap_read(map, PAGE0_SWAUX_RDATA, &data);\n\t\t\tif (ret) {\n\t\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\t      \"failed to read RDATA: %d\\n\",\n\t\t\t\t\t      ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (i < msg->size)\n\t\t\t\tbuf[i] = data;\n\t\t}\n\t}\n\n\treturn min(len, msg->size);\n}\n\nstatic ssize_t ps8640_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t   struct drm_dp_aux_msg *msg)\n{\n\tstruct ps8640 *ps_bridge = aux_to_ps8640(aux);\n\tstruct device *dev = &ps_bridge->page[PAGE0_DP_CNTL]->dev;\n\tint ret;\n\n\tpm_runtime_get_sync(dev);\n\tret = ps8640_aux_transfer_msg(aux, msg);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic void ps8640_bridge_vdo_control(struct ps8640 *ps_bridge,\n\t\t\t\t      const enum ps8640_vdo_control ctrl)\n{\n\tstruct regmap *map = ps_bridge->regmap[PAGE3_DSI_CNTL1];\n\tstruct device *dev = &ps_bridge->page[PAGE3_DSI_CNTL1]->dev;\n\tu8 vdo_ctrl_buf[] = { VDO_CTL_ADD, ctrl };\n\tint ret;\n\n\tret = regmap_bulk_write(map, PAGE3_SET_ADD,\n\t\t\t\tvdo_ctrl_buf, sizeof(vdo_ctrl_buf));\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to %sable VDO: %d\\n\",\n\t\t\tctrl == ENABLE ? \"en\" : \"dis\", ret);\n}\n\nstatic int __maybe_unused ps8640_resume(struct device *dev)\n{\n\tstruct ps8640 *ps_bridge = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ps_bridge->supplies),\n\t\t\t\t    ps_bridge->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot enable regulators %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value(ps_bridge->gpio_powerdown, 0);\n\tgpiod_set_value(ps_bridge->gpio_reset, 1);\n\tusleep_range(2000, 2500);\n\tgpiod_set_value(ps_bridge->gpio_reset, 0);\n\t \n\tmsleep(50);\n\tgpiod_set_value(ps_bridge->gpio_reset, 1);\n\tmsleep(50);\n\tgpiod_set_value(ps_bridge->gpio_reset, 0);\n\n\t \n\tps_bridge->need_post_hpd_delay = true;\n\n\t \n\tmsleep(200);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ps8640_suspend(struct device *dev)\n{\n\tstruct ps8640 *ps_bridge = dev_get_drvdata(dev);\n\tint ret;\n\n\tgpiod_set_value(ps_bridge->gpio_reset, 1);\n\tgpiod_set_value(ps_bridge->gpio_powerdown, 1);\n\tret = regulator_bulk_disable(ARRAY_SIZE(ps_bridge->supplies),\n\t\t\t\t     ps_bridge->supplies);\n\tif (ret < 0)\n\t\tdev_err(dev, \"cannot disable regulators %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops ps8640_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ps8640_suspend, ps8640_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic void ps8640_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ps8640 *ps_bridge = bridge_to_ps8640(bridge);\n\tstruct regmap *map = ps_bridge->regmap[PAGE2_TOP_CNTL];\n\tstruct device *dev = &ps_bridge->page[PAGE0_DP_CNTL]->dev;\n\tint ret;\n\n\tpm_runtime_get_sync(dev);\n\tret = _ps8640_wait_hpd_asserted(ps_bridge, 200 * 1000);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"HPD didn't go high: %d\\n\", ret);\n\n\t \n\n\tret = regmap_update_bits(map, PAGE2_MCS_EN, MCS_EN, 0);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"failed write PAGE2_MCS_EN: %d\\n\", ret);\n\n\t \n\tret = regmap_write(map, PAGE2_I2C_BYPASS, I2C_BYPASS_EN);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"failed write PAGE2_MCS_EN: %d\\n\", ret);\n\n\tps8640_bridge_vdo_control(ps_bridge, ENABLE);\n\n\tps_bridge->pre_enabled = true;\n}\n\nstatic void ps8640_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ps8640 *ps_bridge = bridge_to_ps8640(bridge);\n\n\tps_bridge->pre_enabled = false;\n\n\tps8640_bridge_vdo_control(ps_bridge, DISABLE);\n\tpm_runtime_put_sync_suspend(&ps_bridge->page[PAGE0_DP_CNTL]->dev);\n}\n\nstatic int ps8640_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct ps8640 *ps_bridge = bridge_to_ps8640(bridge);\n\tstruct device *dev = &ps_bridge->page[0]->dev;\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\tps_bridge->aux.drm_dev = bridge->dev;\n\tret = drm_dp_aux_register(&ps_bridge->aux);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register DP AUX channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tps_bridge->link = device_link_add(bridge->dev->dev, dev, DL_FLAG_STATELESS);\n\tif (!ps_bridge->link) {\n\t\tdev_err(dev, \"failed to create device link\");\n\t\tret = -EINVAL;\n\t\tgoto err_devlink;\n\t}\n\n\t \n\tret = drm_bridge_attach(bridge->encoder, ps_bridge->panel_bridge,\n\t\t\t\t&ps_bridge->bridge, flags);\n\tif (ret)\n\t\tgoto err_bridge_attach;\n\n\treturn 0;\n\nerr_bridge_attach:\n\tdevice_link_del(ps_bridge->link);\nerr_devlink:\n\tdrm_dp_aux_unregister(&ps_bridge->aux);\n\n\treturn ret;\n}\n\nstatic void ps8640_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct ps8640 *ps_bridge = bridge_to_ps8640(bridge);\n\n\tdrm_dp_aux_unregister(&ps_bridge->aux);\n\tif (ps_bridge->link)\n\t\tdevice_link_del(ps_bridge->link);\n}\n\nstatic void ps8640_runtime_disable(void *data)\n{\n\tpm_runtime_dont_use_autosuspend(data);\n\tpm_runtime_disable(data);\n}\n\nstatic const struct drm_bridge_funcs ps8640_bridge_funcs = {\n\t.attach = ps8640_bridge_attach,\n\t.detach = ps8640_bridge_detach,\n\t.atomic_post_disable = ps8640_atomic_post_disable,\n\t.atomic_pre_enable = ps8640_atomic_pre_enable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nstatic int ps8640_bridge_get_dsi_resources(struct device *dev, struct ps8640 *ps_bridge)\n{\n\tstruct device_node *in_ep, *dsi_node;\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tconst struct mipi_dsi_device_info info = { .type = \"ps8640\",\n\t\t\t\t\t\t   .channel = 0,\n\t\t\t\t\t\t   .node = NULL,\n\t\t\t\t\t\t };\n\n\t \n\tin_ep = of_graph_get_endpoint_by_regs(dev->of_node, 0, -1);\n\tif (!in_ep)\n\t\treturn -ENODEV;\n\n\tdsi_node = of_graph_get_remote_port_parent(in_ep);\n\tof_node_put(in_ep);\n\tif (!dsi_node)\n\t\treturn -ENODEV;\n\n\thost = of_find_mipi_dsi_host_by_node(dsi_node);\n\tof_node_put(dsi_node);\n\tif (!host)\n\t\treturn -EPROBE_DEFER;\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi)) {\n\t\tdev_err(dev, \"failed to create dsi device\\n\");\n\t\treturn PTR_ERR(dsi);\n\t}\n\n\tps_bridge->dsi = dsi;\n\n\tdsi->host = host;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO |\n\t\t\t  MIPI_DSI_MODE_VIDEO_SYNC_PULSE;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->lanes = NUM_MIPI_LANES;\n\n\treturn 0;\n}\n\nstatic int ps8640_bridge_link_panel(struct drm_dp_aux *aux)\n{\n\tstruct ps8640 *ps_bridge = aux_to_ps8640(aux);\n\tstruct device *dev = aux->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\t \n\n\t \n\tps_bridge->panel_bridge = devm_drm_of_get_bridge(dev, np, 1, 0);\n\tif (IS_ERR(ps_bridge->panel_bridge))\n\t\treturn PTR_ERR(ps_bridge->panel_bridge);\n\n\tret = devm_drm_bridge_add(dev, &ps_bridge->bridge);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_mipi_dsi_attach(dev, ps_bridge->dsi);\n}\n\nstatic int ps8640_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ps8640 *ps_bridge;\n\tint ret;\n\tu32 i;\n\n\tps_bridge = devm_kzalloc(dev, sizeof(*ps_bridge), GFP_KERNEL);\n\tif (!ps_bridge)\n\t\treturn -ENOMEM;\n\n\tps_bridge->supplies[0].supply = \"vdd12\";\n\tps_bridge->supplies[1].supply = \"vdd33\";\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(ps_bridge->supplies),\n\t\t\t\t      ps_bridge->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tps_bridge->gpio_powerdown = devm_gpiod_get(&client->dev, \"powerdown\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(ps_bridge->gpio_powerdown))\n\t\treturn PTR_ERR(ps_bridge->gpio_powerdown);\n\n\t \n\tps_bridge->gpio_reset = devm_gpiod_get(&client->dev, \"reset\",\n\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(ps_bridge->gpio_reset))\n\t\treturn PTR_ERR(ps_bridge->gpio_reset);\n\n\tps_bridge->bridge.funcs = &ps8640_bridge_funcs;\n\tps_bridge->bridge.of_node = dev->of_node;\n\tps_bridge->bridge.type = DRM_MODE_CONNECTOR_eDP;\n\n\t \n\tret = ps8640_bridge_get_dsi_resources(&client->dev, ps_bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tps_bridge->page[PAGE0_DP_CNTL] = client;\n\n\tps_bridge->regmap[PAGE0_DP_CNTL] = devm_regmap_init_i2c(client, ps8640_regmap_config);\n\tif (IS_ERR(ps_bridge->regmap[PAGE0_DP_CNTL]))\n\t\treturn PTR_ERR(ps_bridge->regmap[PAGE0_DP_CNTL]);\n\n\tfor (i = 1; i < ARRAY_SIZE(ps_bridge->page); i++) {\n\t\tps_bridge->page[i] = devm_i2c_new_dummy_device(&client->dev,\n\t\t\t\t\t\t\t     client->adapter,\n\t\t\t\t\t\t\t     client->addr + i);\n\t\tif (IS_ERR(ps_bridge->page[i]))\n\t\t\treturn PTR_ERR(ps_bridge->page[i]);\n\n\t\tps_bridge->regmap[i] = devm_regmap_init_i2c(ps_bridge->page[i],\n\t\t\t\t\t\t\t    ps8640_regmap_config + i);\n\t\tif (IS_ERR(ps_bridge->regmap[i]))\n\t\t\treturn PTR_ERR(ps_bridge->regmap[i]);\n\t}\n\n\ti2c_set_clientdata(client, ps_bridge);\n\n\tps_bridge->aux.name = \"parade-ps8640-aux\";\n\tps_bridge->aux.dev = dev;\n\tps_bridge->aux.transfer = ps8640_aux_transfer;\n\tps_bridge->aux.wait_hpd_asserted = ps8640_wait_hpd_asserted;\n\tdrm_dp_aux_init(&ps_bridge->aux);\n\n\tpm_runtime_enable(dev);\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 2000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_suspend_ignore_children(dev, true);\n\tret = devm_add_action_or_reset(dev, ps8640_runtime_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_of_dp_aux_populate_bus(&ps_bridge->aux, ps8640_bridge_link_panel);\n\n\t \n\tif (ret == -ENODEV)\n\t\treturn ps8640_bridge_link_panel(&ps_bridge->aux);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id ps8640_match[] = {\n\t{ .compatible = \"parade,ps8640\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ps8640_match);\n\nstatic struct i2c_driver ps8640_driver = {\n\t.probe = ps8640_probe,\n\t.driver = {\n\t\t.name = \"ps8640\",\n\t\t.of_match_table = ps8640_match,\n\t\t.pm = &ps8640_pm_ops,\n\t},\n};\nmodule_i2c_driver(ps8640_driver);\n\nMODULE_AUTHOR(\"Jitao Shi <jitao.shi@mediatek.com>\");\nMODULE_AUTHOR(\"CK Hu <ck.hu@mediatek.com>\");\nMODULE_AUTHOR(\"Enric Balletbo i Serra <enric.balletbo@collabora.com>\");\nMODULE_DESCRIPTION(\"PARADE ps8640 DSI-eDP converter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}