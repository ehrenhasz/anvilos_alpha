{
  "module_name": "lontium-lt9611.c",
  "hash_id": "daf6c1257e395d3bc4f00ab7effb020980dbc0e180522bee1c677c3ed5372098",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/lontium-lt9611.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <sound/hdmi-codec.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define EDID_SEG_SIZE\t256\n#define EDID_LEN\t32\n#define EDID_LOOP\t8\n#define KEY_DDC_ACCS_DONE 0x02\n#define DDC_NO_ACK\t0x50\n\n#define LT9611_4LANES\t0\n\nstruct lt9611 {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\n\tstruct regmap *regmap;\n\n\tstruct device_node *dsi0_node;\n\tstruct device_node *dsi1_node;\n\tstruct mipi_dsi_device *dsi0;\n\tstruct mipi_dsi_device *dsi1;\n\tstruct platform_device *audio_pdev;\n\n\tbool ac_mode;\n\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *enable_gpio;\n\n\tbool power_on;\n\tbool sleep;\n\n\tstruct regulator_bulk_data supplies[2];\n\n\tstruct i2c_client *client;\n\n\tenum drm_connector_status status;\n\n\tu8 edid_buf[EDID_SEG_SIZE];\n};\n\n#define LT9611_PAGE_CONTROL\t0xff\n\nstatic const struct regmap_range_cfg lt9611_ranges[] = {\n\t{\n\t\t.name = \"register_range\",\n\t\t.range_min =  0,\n\t\t.range_max = 0x85ff,\n\t\t.selector_reg = LT9611_PAGE_CONTROL,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 0x100,\n\t},\n};\n\nstatic const struct regmap_config lt9611_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xffff,\n\t.ranges = lt9611_ranges,\n\t.num_ranges = ARRAY_SIZE(lt9611_ranges),\n};\n\nstatic struct lt9611 *bridge_to_lt9611(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct lt9611, bridge);\n}\n\nstatic int lt9611_mipi_input_analog(struct lt9611 *lt9611)\n{\n\tconst struct reg_sequence reg_cfg[] = {\n\t\t{ 0x8106, 0x40 },  \n\t\t{ 0x810a, 0xfe },  \n\t\t{ 0x810b, 0xbf },  \n\t\t{ 0x8111, 0x40 },  \n\t\t{ 0x8115, 0xfe },  \n\t\t{ 0x8116, 0xbf },  \n\n\t\t{ 0x811c, 0x03 },  \n\t\t{ 0x8120, 0x03 },  \n\t};\n\n\treturn regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));\n}\n\nstatic int lt9611_mipi_input_digital(struct lt9611 *lt9611,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct reg_sequence reg_cfg[] = {\n\t\t{ 0x8300, LT9611_4LANES },\n\t\t{ 0x830a, 0x00 },\n\t\t{ 0x824f, 0x80 },\n\t\t{ 0x8250, 0x10 },\n\t\t{ 0x8302, 0x0a },\n\t\t{ 0x8306, 0x0a },\n\t};\n\n\tif (lt9611->dsi1_node)\n\t\treg_cfg[1].def = 0x03;\n\n\treturn regmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));\n}\n\nstatic void lt9611_mipi_video_setup(struct lt9611 *lt9611,\n\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tu32 h_total, hactive, hsync_len, hfront_porch, hsync_porch;\n\tu32 v_total, vactive, vsync_len, vfront_porch, vsync_porch;\n\n\th_total = mode->htotal;\n\tv_total = mode->vtotal;\n\n\thactive = mode->hdisplay;\n\thsync_len = mode->hsync_end - mode->hsync_start;\n\thfront_porch = mode->hsync_start - mode->hdisplay;\n\thsync_porch = mode->htotal - mode->hsync_start;\n\n\tvactive = mode->vdisplay;\n\tvsync_len = mode->vsync_end - mode->vsync_start;\n\tvfront_porch = mode->vsync_start - mode->vdisplay;\n\tvsync_porch = mode->vtotal - mode->vsync_start;\n\n\tregmap_write(lt9611->regmap, 0x830d, (u8)(v_total / 256));\n\tregmap_write(lt9611->regmap, 0x830e, (u8)(v_total % 256));\n\n\tregmap_write(lt9611->regmap, 0x830f, (u8)(vactive / 256));\n\tregmap_write(lt9611->regmap, 0x8310, (u8)(vactive % 256));\n\n\tregmap_write(lt9611->regmap, 0x8311, (u8)(h_total / 256));\n\tregmap_write(lt9611->regmap, 0x8312, (u8)(h_total % 256));\n\n\tregmap_write(lt9611->regmap, 0x8313, (u8)(hactive / 256));\n\tregmap_write(lt9611->regmap, 0x8314, (u8)(hactive % 256));\n\n\tregmap_write(lt9611->regmap, 0x8315, (u8)(vsync_len % 256));\n\tregmap_write(lt9611->regmap, 0x8316, (u8)(hsync_len % 256));\n\n\tregmap_write(lt9611->regmap, 0x8317, (u8)(vfront_porch % 256));\n\n\tregmap_write(lt9611->regmap, 0x8318, (u8)(vsync_porch % 256));\n\n\tregmap_write(lt9611->regmap, 0x8319, (u8)(hfront_porch % 256));\n\n\tregmap_write(lt9611->regmap, 0x831a, (u8)(hsync_porch / 256) |\n\t\t\t\t\t\t((hfront_porch / 256) << 4));\n\tregmap_write(lt9611->regmap, 0x831b, (u8)(hsync_porch % 256));\n}\n\nstatic void lt9611_pcr_setup(struct lt9611 *lt9611, const struct drm_display_mode *mode, unsigned int postdiv)\n{\n\tunsigned int pcr_m = mode->clock * 5 * postdiv / 27000;\n\tconst struct reg_sequence reg_cfg[] = {\n\t\t{ 0x830b, 0x01 },\n\t\t{ 0x830c, 0x10 },\n\t\t{ 0x8348, 0x00 },\n\t\t{ 0x8349, 0x81 },\n\n\t\t \n\t\t{ 0x8321, 0x4a },\n\t\t{ 0x8324, 0x71 },\n\t\t{ 0x8325, 0x30 },\n\t\t{ 0x832a, 0x01 },\n\n\t\t \n\t\t{ 0x834a, 0x40 },\n\n\t\t \n\t\t{ 0x832d, 0x38 },\n\t\t{ 0x8331, 0x08 },\n\t};\n\tu8 pol = 0x10;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tpol |= 0x2;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tpol |= 0x1;\n\tregmap_write(lt9611->regmap, 0x831d, pol);\n\n\tregmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));\n\tif (lt9611->dsi1_node) {\n\t\tunsigned int hact = mode->hdisplay;\n\n\t\thact >>= 2;\n\t\thact += 0x50;\n\t\thact = min(hact, 0x3e0U);\n\t\tregmap_write(lt9611->regmap, 0x830b, hact / 256);\n\t\tregmap_write(lt9611->regmap, 0x830c, hact % 256);\n\t\tregmap_write(lt9611->regmap, 0x8348, hact / 256);\n\t\tregmap_write(lt9611->regmap, 0x8349, hact % 256);\n\t}\n\n\tregmap_write(lt9611->regmap, 0x8326, pcr_m);\n\n\t \n\tregmap_write(lt9611->regmap, 0x8011, 0x5a);\n\tregmap_write(lt9611->regmap, 0x8011, 0xfa);\n}\n\nstatic int lt9611_pll_setup(struct lt9611 *lt9611, const struct drm_display_mode *mode, unsigned int *postdiv)\n{\n\tunsigned int pclk = mode->clock;\n\tconst struct reg_sequence reg_cfg[] = {\n\t\t \n\t\t{ 0x8123, 0x40 },\n\t\t{ 0x8124, 0x64 },\n\t\t{ 0x8125, 0x80 },\n\t\t{ 0x8126, 0x55 },\n\t\t{ 0x812c, 0x37 },\n\t\t{ 0x812f, 0x01 },\n\t\t{ 0x8126, 0x55 },\n\t\t{ 0x8127, 0x66 },\n\t\t{ 0x8128, 0x88 },\n\t\t{ 0x812a, 0x20 },\n\t};\n\n\tregmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));\n\n\tif (pclk > 150000) {\n\t\tregmap_write(lt9611->regmap, 0x812d, 0x88);\n\t\t*postdiv = 1;\n\t} else if (pclk > 70000) {\n\t\tregmap_write(lt9611->regmap, 0x812d, 0x99);\n\t\t*postdiv = 2;\n\t} else {\n\t\tregmap_write(lt9611->regmap, 0x812d, 0xaa);\n\t\t*postdiv = 4;\n\t}\n\n\t \n\tregmap_write(lt9611->regmap, 0x82e3, pclk >> 17);  \n\tregmap_write(lt9611->regmap, 0x82e4, pclk >> 9);   \n\tregmap_write(lt9611->regmap, 0x82e5, pclk >> 1);   \n\n\tregmap_write(lt9611->regmap, 0x82de, 0x20);\n\tregmap_write(lt9611->regmap, 0x82de, 0xe0);\n\n\tregmap_write(lt9611->regmap, 0x8016, 0xf1);\n\tregmap_write(lt9611->regmap, 0x8016, 0xf3);\n\n\treturn 0;\n}\n\nstatic int lt9611_read_video_check(struct lt9611 *lt9611, unsigned int reg)\n{\n\tunsigned int temp, temp2;\n\tint ret;\n\n\tret = regmap_read(lt9611->regmap, reg, &temp);\n\tif (ret)\n\t\treturn ret;\n\ttemp <<= 8;\n\tret = regmap_read(lt9611->regmap, reg + 1, &temp2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn (temp + temp2);\n}\n\nstatic int lt9611_video_check(struct lt9611 *lt9611)\n{\n\tu32 v_total, vactive, hactive_a, hactive_b, h_total_sysclk;\n\tint temp;\n\n\t \n\n\t \n\ttemp = lt9611_read_video_check(lt9611, 0x8282);\n\tif (temp < 0)\n\t\tgoto end;\n\tvactive = temp;\n\n\t \n\ttemp = lt9611_read_video_check(lt9611, 0x826c);\n\tif (temp < 0)\n\t\tgoto end;\n\tv_total = temp;\n\n\t \n\ttemp = lt9611_read_video_check(lt9611, 0x8286);\n\tif (temp < 0)\n\t\tgoto end;\n\th_total_sysclk = temp;\n\n\t \n\ttemp = lt9611_read_video_check(lt9611, 0x8382);\n\tif (temp < 0)\n\t\tgoto end;\n\thactive_a = temp / 3;\n\n\t \n\ttemp = lt9611_read_video_check(lt9611, 0x8386);\n\tif (temp < 0)\n\t\tgoto end;\n\thactive_b = temp / 3;\n\n\tdev_info(lt9611->dev,\n\t\t \"video check: hactive_a=%d, hactive_b=%d, vactive=%d, v_total=%d, h_total_sysclk=%d\\n\",\n\t\t hactive_a, hactive_b, vactive, v_total, h_total_sysclk);\n\n\treturn 0;\n\nend:\n\tdev_err(lt9611->dev, \"read video check error\\n\");\n\treturn temp;\n}\n\nstatic void lt9611_hdmi_set_infoframes(struct lt9611 *lt9611,\n\t\t\t\t       struct drm_connector *connector,\n\t\t\t\t       struct drm_display_mode *mode)\n{\n\tunion hdmi_infoframe infoframe;\n\tssize_t len;\n\tu8 iframes = 0x0a;  \n\tu8 buf[32];\n\tint ret;\n\tint i;\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&infoframe.avi,\n\t\t\t\t\t\t       connector,\n\t\t\t\t\t\t       mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = hdmi_infoframe_pack(&infoframe, buf, sizeof(buf));\n\tif (len < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++)\n\t\tregmap_write(lt9611->regmap, 0x8440 + i, buf[i]);\n\n\tret = drm_hdmi_vendor_infoframe_from_display_mode(&infoframe.vendor.hdmi,\n\t\t\t\t\t\t\t  connector,\n\t\t\t\t\t\t\t  mode);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = hdmi_infoframe_pack(&infoframe, buf, sizeof(buf));\n\tif (len < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < len; i++)\n\t\tregmap_write(lt9611->regmap, 0x8474 + i, buf[i]);\n\n\tiframes |= 0x20;\n\nout:\n\tregmap_write(lt9611->regmap, 0x843d, iframes);  \n}\n\nstatic void lt9611_hdmi_tx_digital(struct lt9611 *lt9611, bool is_hdmi)\n{\n\tif (is_hdmi)\n\t\tregmap_write(lt9611->regmap, 0x82d6, 0x8c);\n\telse\n\t\tregmap_write(lt9611->regmap, 0x82d6, 0x0c);\n\tregmap_write(lt9611->regmap, 0x82d7, 0x04);\n}\n\nstatic void lt9611_hdmi_tx_phy(struct lt9611 *lt9611)\n{\n\tstruct reg_sequence reg_cfg[] = {\n\t\t{ 0x8130, 0x6a },\n\t\t{ 0x8131, 0x44 },  \n\t\t{ 0x8132, 0x4a },\n\t\t{ 0x8133, 0x0b },\n\t\t{ 0x8134, 0x00 },\n\t\t{ 0x8135, 0x00 },\n\t\t{ 0x8136, 0x00 },\n\t\t{ 0x8137, 0x44 },\n\t\t{ 0x813f, 0x0f },\n\t\t{ 0x8140, 0xa0 },\n\t\t{ 0x8141, 0xa0 },\n\t\t{ 0x8142, 0xa0 },\n\t\t{ 0x8143, 0xa0 },\n\t\t{ 0x8144, 0x0a },\n\t};\n\n\t \n\tif (lt9611->ac_mode)\n\t\treg_cfg[2].def = 0x73;\n\n\tregmap_multi_reg_write(lt9611->regmap, reg_cfg, ARRAY_SIZE(reg_cfg));\n}\n\nstatic irqreturn_t lt9611_irq_thread_handler(int irq, void *dev_id)\n{\n\tstruct lt9611 *lt9611 = dev_id;\n\tunsigned int irq_flag0 = 0;\n\tunsigned int irq_flag3 = 0;\n\n\tregmap_read(lt9611->regmap, 0x820f, &irq_flag3);\n\tregmap_read(lt9611->regmap, 0x820c, &irq_flag0);\n\n\t \n\tif (irq_flag3 & 0x80) {\n\t\tdev_info(lt9611->dev, \"hdmi cable disconnected\\n\");\n\n\t\tregmap_write(lt9611->regmap, 0x8207, 0xbf);\n\t\tregmap_write(lt9611->regmap, 0x8207, 0x3f);\n\t}\n\n\t \n\tif (irq_flag3 & 0x40) {\n\t\tdev_info(lt9611->dev, \"hdmi cable connected\\n\");\n\n\t\tregmap_write(lt9611->regmap, 0x8207, 0x7f);\n\t\tregmap_write(lt9611->regmap, 0x8207, 0x3f);\n\t}\n\n\tif (irq_flag3 & 0xc0 && lt9611->bridge.dev)\n\t\tdrm_kms_helper_hotplug_event(lt9611->bridge.dev);\n\n\t \n\tif (irq_flag0 & 0x01) {\n\t\tdev_info(lt9611->dev, \"video input changed\\n\");\n\t\tregmap_write(lt9611->regmap, 0x829e, 0xff);\n\t\tregmap_write(lt9611->regmap, 0x829e, 0xf7);\n\t\tregmap_write(lt9611->regmap, 0x8204, 0xff);\n\t\tregmap_write(lt9611->regmap, 0x8204, 0xfe);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void lt9611_enable_hpd_interrupts(struct lt9611 *lt9611)\n{\n\tunsigned int val;\n\n\tregmap_read(lt9611->regmap, 0x8203, &val);\n\n\tval &= ~0xc0;\n\tregmap_write(lt9611->regmap, 0x8203, val);\n\tregmap_write(lt9611->regmap, 0x8207, 0xff);  \n\tregmap_write(lt9611->regmap, 0x8207, 0x3f);\n}\n\nstatic void lt9611_sleep_setup(struct lt9611 *lt9611)\n{\n\tconst struct reg_sequence sleep_setup[] = {\n\t\t{ 0x8024, 0x76 },\n\t\t{ 0x8023, 0x01 },\n\t\t{ 0x8157, 0x03 },  \n\t\t{ 0x8149, 0x0b },\n\n\t\t{ 0x8102, 0x48 },  \n\t\t{ 0x8123, 0x80 },\n\t\t{ 0x8130, 0x00 },\n\t\t{ 0x8011, 0x0a },\n\t};\n\n\tregmap_multi_reg_write(lt9611->regmap,\n\t\t\t       sleep_setup, ARRAY_SIZE(sleep_setup));\n\tlt9611->sleep = true;\n}\n\nstatic int lt9611_power_on(struct lt9611 *lt9611)\n{\n\tint ret;\n\tconst struct reg_sequence seq[] = {\n\t\t \n\t\t{ 0x8101, 0x18 },  \n\n\t\t \n\t\t{ 0x821b, 0x69 },  \n\t\t{ 0x821c, 0x78 },\n\t\t{ 0x82cb, 0x69 },  \n\t\t{ 0x82cc, 0x78 },\n\n\t\t \n\t\t{ 0x8251, 0x01 },\n\t\t{ 0x8258, 0x0a },  \n\t\t{ 0x8259, 0x80 },  \n\t\t{ 0x829e, 0xf7 },  \n\n\t\t \n\t\t{ 0x8004, 0xf0 },\n\t\t{ 0x8006, 0xf0 },\n\t\t{ 0x800a, 0x80 },\n\t\t{ 0x800b, 0x40 },\n\t\t{ 0x800d, 0xef },\n\t\t{ 0x8011, 0xfa },\n\t};\n\n\tif (lt9611->power_on)\n\t\treturn 0;\n\n\tret = regmap_multi_reg_write(lt9611->regmap, seq, ARRAY_SIZE(seq));\n\tif (!ret)\n\t\tlt9611->power_on = true;\n\n\treturn ret;\n}\n\nstatic int lt9611_power_off(struct lt9611 *lt9611)\n{\n\tint ret;\n\n\tret = regmap_write(lt9611->regmap, 0x8130, 0x6a);\n\tif (!ret)\n\t\tlt9611->power_on = false;\n\n\treturn ret;\n}\n\nstatic void lt9611_reset(struct lt9611 *lt9611)\n{\n\tgpiod_set_value_cansleep(lt9611->reset_gpio, 1);\n\tmsleep(20);\n\n\tgpiod_set_value_cansleep(lt9611->reset_gpio, 0);\n\tmsleep(20);\n\n\tgpiod_set_value_cansleep(lt9611->reset_gpio, 1);\n\tmsleep(100);\n}\n\nstatic void lt9611_assert_5v(struct lt9611 *lt9611)\n{\n\tif (!lt9611->enable_gpio)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(lt9611->enable_gpio, 1);\n\tmsleep(20);\n}\n\nstatic int lt9611_regulator_init(struct lt9611 *lt9611)\n{\n\tint ret;\n\n\tlt9611->supplies[0].supply = \"vdd\";\n\tlt9611->supplies[1].supply = \"vcc\";\n\n\tret = devm_regulator_bulk_get(lt9611->dev, 2, lt9611->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regulator_set_load(lt9611->supplies[0].consumer, 300000);\n}\n\nstatic int lt9611_regulator_enable(struct lt9611 *lt9611)\n{\n\tint ret;\n\n\tret = regulator_enable(lt9611->supplies[0].consumer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 10000);\n\n\tret = regulator_enable(lt9611->supplies[1].consumer);\n\tif (ret < 0) {\n\t\tregulator_disable(lt9611->supplies[0].consumer);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_connector_status lt9611_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\tunsigned int reg_val = 0;\n\tint connected = 0;\n\n\tregmap_read(lt9611->regmap, 0x825e, &reg_val);\n\tconnected  = (reg_val & (BIT(2) | BIT(0)));\n\n\tlt9611->status = connected ?  connector_status_connected :\n\t\t\t\tconnector_status_disconnected;\n\n\treturn lt9611->status;\n}\n\nstatic int lt9611_read_edid(struct lt9611 *lt9611)\n{\n\tunsigned int temp;\n\tint ret = 0;\n\tint i, j;\n\n\t \n\tmemset(lt9611->edid_buf, 0, sizeof(lt9611->edid_buf));\n\n\tregmap_write(lt9611->regmap, 0x8503, 0xc9);\n\n\t \n\tregmap_write(lt9611->regmap, 0x8504, 0xa0);\n\t \n\tregmap_write(lt9611->regmap, 0x8505, 0x00);\n\n\t \n\tregmap_write(lt9611->regmap, 0x8506, EDID_LEN);\n\tregmap_write(lt9611->regmap, 0x8514, 0x7f);\n\n\tfor (i = 0; i < EDID_LOOP; i++) {\n\t\t \n\t\tregmap_write(lt9611->regmap, 0x8505, i * EDID_LEN);\n\t\tregmap_write(lt9611->regmap, 0x8507, 0x36);\n\t\tregmap_write(lt9611->regmap, 0x8507, 0x31);\n\t\tregmap_write(lt9611->regmap, 0x8507, 0x37);\n\t\tusleep_range(5000, 10000);\n\n\t\tregmap_read(lt9611->regmap, 0x8540, &temp);\n\n\t\tif (temp & KEY_DDC_ACCS_DONE) {\n\t\t\tfor (j = 0; j < EDID_LEN; j++) {\n\t\t\t\tregmap_read(lt9611->regmap, 0x8583, &temp);\n\t\t\t\tlt9611->edid_buf[i * EDID_LEN + j] = temp;\n\t\t\t}\n\n\t\t} else if (temp & DDC_NO_ACK) {  \n\t\t\tdev_err(lt9611->dev, \"read edid failed: no ack\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto end;\n\n\t\t} else {\n\t\t\tdev_err(lt9611->dev, \"read edid failed: access not done\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto end;\n\t\t}\n\t}\n\nend:\n\tregmap_write(lt9611->regmap, 0x8507, 0x1f);\n\treturn ret;\n}\n\nstatic int\nlt9611_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct lt9611 *lt9611 = data;\n\tint ret;\n\n\tif (len > 128)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tif (block > 1)\n\t\treturn -EINVAL;\n\n\tif (block == 0) {\n\t\tret = lt9611_read_edid(lt9611);\n\t\tif (ret) {\n\t\t\tdev_err(lt9611->dev, \"edid read failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tblock %= 2;\n\tmemcpy(buf, lt9611->edid_buf + (block * 128), len);\n\n\treturn 0;\n}\n\n \nstatic void\nlt9611_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t    struct drm_bridge_state *old_bridge_state)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_display_mode *mode;\n\tunsigned int postdiv;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\tif (WARN_ON(!connector))\n\t\treturn;\n\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\treturn;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn;\n\n\tmode = &crtc_state->adjusted_mode;\n\n\tlt9611_mipi_input_digital(lt9611, mode);\n\tlt9611_pll_setup(lt9611, mode, &postdiv);\n\tlt9611_mipi_video_setup(lt9611, mode);\n\tlt9611_pcr_setup(lt9611, mode, postdiv);\n\n\tif (lt9611_power_on(lt9611)) {\n\t\tdev_err(lt9611->dev, \"power on failed\\n\");\n\t\treturn;\n\t}\n\n\tlt9611_mipi_input_analog(lt9611);\n\tlt9611_hdmi_set_infoframes(lt9611, connector, mode);\n\tlt9611_hdmi_tx_digital(lt9611, connector->display_info.is_hdmi);\n\tlt9611_hdmi_tx_phy(lt9611);\n\n\tmsleep(500);\n\n\tlt9611_video_check(lt9611);\n\n\t \n\tregmap_write(lt9611->regmap, 0x8130, 0xea);\n}\n\nstatic void\nlt9611_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\tint ret;\n\n\t \n\tret = regmap_write(lt9611->regmap, 0x8130, 0x6a);\n\tif (ret) {\n\t\tdev_err(lt9611->dev, \"video on failed\\n\");\n\t\treturn;\n\t}\n\n\tif (lt9611_power_off(lt9611)) {\n\t\tdev_err(lt9611->dev, \"power on failed\\n\");\n\t\treturn;\n\t}\n}\n\nstatic struct mipi_dsi_device *lt9611_attach_dsi(struct lt9611 *lt9611,\n\t\t\t\t\t\t struct device_node *dsi_node)\n{\n\tconst struct mipi_dsi_device_info info = { \"lt9611\", 0, lt9611->dev->of_node};\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tstruct device *dev = lt9611->dev;\n\tint ret;\n\n\thost = of_find_mipi_dsi_host_by_node(dsi_node);\n\tif (!host) {\n\t\tdev_err(lt9611->dev, \"failed to find dsi host\\n\");\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi)) {\n\t\tdev_err(lt9611->dev, \"failed to create dsi device\\n\");\n\t\treturn dsi;\n\t}\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t  MIPI_DSI_MODE_VIDEO_HSE;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn dsi;\n}\n\nstatic int lt9611_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, lt9611->next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic enum drm_mode_status lt9611_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t\t     const struct drm_display_info *info,\n\t\t\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\n\tif (mode->hdisplay > 3840)\n\t\treturn MODE_BAD_HVALUE;\n\n\tif (mode->vdisplay > 2160)\n\t\treturn MODE_BAD_VVALUE;\n\n\tif (mode->hdisplay == 3840 &&\n\t    mode->vdisplay == 2160 &&\n\t    drm_mode_vrefresh(mode) > 30)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->hdisplay > 2000 && !lt9611->dsi1_node)\n\t\treturn MODE_PANEL;\n\telse\n\t\treturn MODE_OK;\n}\n\nstatic void lt9611_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *old_bridge_state)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\tstatic const struct reg_sequence reg_cfg[] = {\n\t\t{ 0x8102, 0x12 },\n\t\t{ 0x8123, 0x40 },\n\t\t{ 0x8130, 0xea },\n\t\t{ 0x8011, 0xfa },\n\t};\n\n\tif (!lt9611->sleep)\n\t\treturn;\n\n\tregmap_multi_reg_write(lt9611->regmap,\n\t\t\t       reg_cfg, ARRAY_SIZE(reg_cfg));\n\n\tlt9611->sleep = false;\n}\n\nstatic void\nlt9611_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\n\tlt9611_sleep_setup(lt9611);\n}\n\nstatic struct edid *lt9611_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_connector *connector)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\n\tlt9611_power_on(lt9611);\n\treturn drm_do_get_edid(connector, lt9611_get_edid_block, lt9611);\n}\n\nstatic void lt9611_bridge_hpd_enable(struct drm_bridge *bridge)\n{\n\tstruct lt9611 *lt9611 = bridge_to_lt9611(bridge);\n\n\tlt9611_enable_hpd_interrupts(lt9611);\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\nlt9611_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t u32 output_fmt,\n\t\t\t\t unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t \n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs lt9611_bridge_funcs = {\n\t.attach = lt9611_bridge_attach,\n\t.mode_valid = lt9611_bridge_mode_valid,\n\t.detect = lt9611_bridge_detect,\n\t.get_edid = lt9611_bridge_get_edid,\n\t.hpd_enable = lt9611_bridge_hpd_enable,\n\n\t.atomic_pre_enable = lt9611_bridge_atomic_pre_enable,\n\t.atomic_enable = lt9611_bridge_atomic_enable,\n\t.atomic_disable = lt9611_bridge_atomic_disable,\n\t.atomic_post_disable = lt9611_bridge_atomic_post_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_get_input_bus_fmts = lt9611_atomic_get_input_bus_fmts,\n};\n\nstatic int lt9611_parse_dt(struct device *dev,\n\t\t\t   struct lt9611 *lt9611)\n{\n\tlt9611->dsi0_node = of_graph_get_remote_node(dev->of_node, 0, -1);\n\tif (!lt9611->dsi0_node) {\n\t\tdev_err(lt9611->dev, \"failed to get remote node for primary dsi\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlt9611->dsi1_node = of_graph_get_remote_node(dev->of_node, 1, -1);\n\n\tlt9611->ac_mode = of_property_read_bool(dev->of_node, \"lt,ac-mode\");\n\n\treturn drm_of_find_panel_or_bridge(dev->of_node, 2, -1, NULL, &lt9611->next_bridge);\n}\n\nstatic int lt9611_gpio_init(struct lt9611 *lt9611)\n{\n\tstruct device *dev = lt9611->dev;\n\n\tlt9611->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(lt9611->reset_gpio)) {\n\t\tdev_err(dev, \"failed to acquire reset gpio\\n\");\n\t\treturn PTR_ERR(lt9611->reset_gpio);\n\t}\n\n\tlt9611->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(lt9611->enable_gpio)) {\n\t\tdev_err(dev, \"failed to acquire enable gpio\\n\");\n\t\treturn PTR_ERR(lt9611->enable_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic int lt9611_read_device_rev(struct lt9611 *lt9611)\n{\n\tunsigned int rev;\n\tint ret;\n\n\tregmap_write(lt9611->regmap, 0x80ee, 0x01);\n\tret = regmap_read(lt9611->regmap, 0x8002, &rev);\n\tif (ret)\n\t\tdev_err(lt9611->dev, \"failed to read revision: %d\\n\", ret);\n\telse\n\t\tdev_info(lt9611->dev, \"LT9611 revision: 0x%x\\n\", rev);\n\n\treturn ret;\n}\n\nstatic int lt9611_hdmi_hw_params(struct device *dev, void *data,\n\t\t\t\t struct hdmi_codec_daifmt *fmt,\n\t\t\t\t struct hdmi_codec_params *hparms)\n{\n\tstruct lt9611 *lt9611 = data;\n\n\tif (hparms->sample_rate == 48000)\n\t\tregmap_write(lt9611->regmap, 0x840f, 0x2b);\n\telse if (hparms->sample_rate == 96000)\n\t\tregmap_write(lt9611->regmap, 0x840f, 0xab);\n\telse\n\t\treturn -EINVAL;\n\n\tregmap_write(lt9611->regmap, 0x8435, 0x00);\n\tregmap_write(lt9611->regmap, 0x8436, 0x18);\n\tregmap_write(lt9611->regmap, 0x8437, 0x00);\n\n\treturn 0;\n}\n\nstatic int lt9611_audio_startup(struct device *dev, void *data)\n{\n\tstruct lt9611 *lt9611 = data;\n\n\tregmap_write(lt9611->regmap, 0x82d6, 0x8c);\n\tregmap_write(lt9611->regmap, 0x82d7, 0x04);\n\n\tregmap_write(lt9611->regmap, 0x8406, 0x08);\n\tregmap_write(lt9611->regmap, 0x8407, 0x10);\n\n\tregmap_write(lt9611->regmap, 0x8434, 0xd5);\n\n\treturn 0;\n}\n\nstatic void lt9611_audio_shutdown(struct device *dev, void *data)\n{\n\tstruct lt9611 *lt9611 = data;\n\n\tregmap_write(lt9611->regmap, 0x8406, 0x00);\n\tregmap_write(lt9611->regmap, 0x8407, 0x00);\n}\n\nstatic int lt9611_hdmi_i2s_get_dai_id(struct snd_soc_component *component,\n\t\t\t\t      struct device_node *endpoint)\n{\n\tstruct of_endpoint of_ep;\n\tint ret;\n\n\tret = of_graph_parse_endpoint(endpoint, &of_ep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (of_ep.port == 2)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic const struct hdmi_codec_ops lt9611_codec_ops = {\n\t.hw_params\t= lt9611_hdmi_hw_params,\n\t.audio_shutdown = lt9611_audio_shutdown,\n\t.audio_startup\t= lt9611_audio_startup,\n\t.get_dai_id\t= lt9611_hdmi_i2s_get_dai_id,\n};\n\nstatic struct hdmi_codec_pdata codec_data = {\n\t.ops = &lt9611_codec_ops,\n\t.max_i2s_channels = 8,\n\t.i2s = 1,\n};\n\nstatic int lt9611_audio_init(struct device *dev, struct lt9611 *lt9611)\n{\n\tcodec_data.data = lt9611;\n\tlt9611->audio_pdev =\n\t\tplatform_device_register_data(dev, HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t      PLATFORM_DEVID_AUTO,\n\t\t\t\t\t      &codec_data, sizeof(codec_data));\n\n\treturn PTR_ERR_OR_ZERO(lt9611->audio_pdev);\n}\n\nstatic void lt9611_audio_exit(struct lt9611 *lt9611)\n{\n\tif (lt9611->audio_pdev) {\n\t\tplatform_device_unregister(lt9611->audio_pdev);\n\t\tlt9611->audio_pdev = NULL;\n\t}\n}\n\nstatic int lt9611_probe(struct i2c_client *client)\n{\n\tstruct lt9611 *lt9611;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"device doesn't support I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlt9611 = devm_kzalloc(dev, sizeof(*lt9611), GFP_KERNEL);\n\tif (!lt9611)\n\t\treturn -ENOMEM;\n\n\tlt9611->dev = dev;\n\tlt9611->client = client;\n\tlt9611->sleep = false;\n\n\tlt9611->regmap = devm_regmap_init_i2c(client, &lt9611_regmap_config);\n\tif (IS_ERR(lt9611->regmap)) {\n\t\tdev_err(lt9611->dev, \"regmap i2c init failed\\n\");\n\t\treturn PTR_ERR(lt9611->regmap);\n\t}\n\n\tret = lt9611_parse_dt(dev, lt9611);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse device tree\\n\");\n\t\treturn ret;\n\t}\n\n\tret = lt9611_gpio_init(lt9611);\n\tif (ret < 0)\n\t\tgoto err_of_put;\n\n\tret = lt9611_regulator_init(lt9611);\n\tif (ret < 0)\n\t\tgoto err_of_put;\n\n\tlt9611_assert_5v(lt9611);\n\n\tret = lt9611_regulator_enable(lt9611);\n\tif (ret)\n\t\tgoto err_of_put;\n\n\tlt9611_reset(lt9611);\n\n\tret = lt9611_read_device_rev(lt9611);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read chip rev\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tlt9611_irq_thread_handler,\n\t\t\t\t\tIRQF_ONESHOT, \"lt9611\", lt9611);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\ti2c_set_clientdata(client, lt9611);\n\n\tlt9611->bridge.funcs = &lt9611_bridge_funcs;\n\tlt9611->bridge.of_node = client->dev.of_node;\n\tlt9611->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID |\n\t\t\t     DRM_BRIDGE_OP_HPD | DRM_BRIDGE_OP_MODES;\n\tlt9611->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\n\tdrm_bridge_add(&lt9611->bridge);\n\n\t \n\tlt9611->dsi0 = lt9611_attach_dsi(lt9611, lt9611->dsi0_node);\n\tif (IS_ERR(lt9611->dsi0)) {\n\t\tret = PTR_ERR(lt9611->dsi0);\n\t\tgoto err_remove_bridge;\n\t}\n\n\t \n\tif (lt9611->dsi1_node) {\n\t\tlt9611->dsi1 = lt9611_attach_dsi(lt9611, lt9611->dsi1_node);\n\t\tif (IS_ERR(lt9611->dsi1)) {\n\t\t\tret = PTR_ERR(lt9611->dsi1);\n\t\t\tgoto err_remove_bridge;\n\t\t}\n\t}\n\n\tlt9611_enable_hpd_interrupts(lt9611);\n\n\tret = lt9611_audio_init(dev, lt9611);\n\tif (ret)\n\t\tgoto err_remove_bridge;\n\n\treturn 0;\n\nerr_remove_bridge:\n\tdrm_bridge_remove(&lt9611->bridge);\n\nerr_disable_regulators:\n\tregulator_bulk_disable(ARRAY_SIZE(lt9611->supplies), lt9611->supplies);\n\nerr_of_put:\n\tof_node_put(lt9611->dsi1_node);\n\tof_node_put(lt9611->dsi0_node);\n\n\treturn ret;\n}\n\nstatic void lt9611_remove(struct i2c_client *client)\n{\n\tstruct lt9611 *lt9611 = i2c_get_clientdata(client);\n\n\tdisable_irq(client->irq);\n\tlt9611_audio_exit(lt9611);\n\tdrm_bridge_remove(&lt9611->bridge);\n\n\tregulator_bulk_disable(ARRAY_SIZE(lt9611->supplies), lt9611->supplies);\n\n\tof_node_put(lt9611->dsi1_node);\n\tof_node_put(lt9611->dsi0_node);\n}\n\nstatic struct i2c_device_id lt9611_id[] = {\n\t{ \"lontium,lt9611\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, lt9611_id);\n\nstatic const struct of_device_id lt9611_match_table[] = {\n\t{ .compatible = \"lontium,lt9611\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, lt9611_match_table);\n\nstatic struct i2c_driver lt9611_driver = {\n\t.driver = {\n\t\t.name = \"lt9611\",\n\t\t.of_match_table = lt9611_match_table,\n\t},\n\t.probe = lt9611_probe,\n\t.remove = lt9611_remove,\n\t.id_table = lt9611_id,\n};\nmodule_i2c_driver(lt9611_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}