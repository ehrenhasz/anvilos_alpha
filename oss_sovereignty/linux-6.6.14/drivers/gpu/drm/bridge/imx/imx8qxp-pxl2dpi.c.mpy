{
  "module_name": "imx8qxp-pxl2dpi.c",
  "hash_id": "7084487f534d6f74cec4cfed5d30a27d69b91484a26dc582ad0f52e447b4897f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/imx/imx8qxp-pxl2dpi.c",
  "human_readable_source": "\n\n \n\n#include <linux/firmware/imx/svc/misc.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#include <dt-bindings/firmware/imx/rsrc.h>\n\n#define PXL2DPI_CTRL\t0x40\n#define  CFG1_16BIT\t0x0\n#define  CFG2_16BIT\t0x1\n#define  CFG3_16BIT\t0x2\n#define  CFG1_18BIT\t0x3\n#define  CFG2_18BIT\t0x4\n#define  CFG_24BIT\t0x5\n\n#define DRIVER_NAME\t\"imx8qxp-pxl2dpi\"\n\nstruct imx8qxp_pxl2dpi {\n\tstruct regmap *regmap;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_bridge *companion;\n\tstruct device *dev;\n\tstruct imx_sc_ipc *ipc_handle;\n\tu32 sc_resource;\n\tu32 in_bus_format;\n\tu32 out_bus_format;\n\tu32 pl_sel;\n};\n\n#define bridge_to_p2d(b)\tcontainer_of(b, struct imx8qxp_pxl2dpi, bridge)\n\nstatic int imx8qxp_pxl2dpi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct imx8qxp_pxl2dpi *p2d = bridge->driver_private;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"do not support creating a drm_connector\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_DEV_ERROR(p2d->dev, \"missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder,\n\t\t\t\t p2d->next_bridge, bridge,\n\t\t\t\t DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n}\n\nstatic int\nimx8qxp_pxl2dpi_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t    struct drm_connector_state *conn_state)\n{\n\tstruct imx8qxp_pxl2dpi *p2d = bridge->driver_private;\n\n\tp2d->in_bus_format = bridge_state->input_bus_cfg.format;\n\tp2d->out_bus_format = bridge_state->output_bus_cfg.format;\n\n\treturn 0;\n}\n\nstatic void\nimx8qxp_pxl2dpi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct imx8qxp_pxl2dpi *p2d = bridge->driver_private;\n\tstruct imx8qxp_pxl2dpi *companion_p2d;\n\tint ret;\n\n\tret = pm_runtime_get_sync(p2d->dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"failed to get runtime PM sync: %d\\n\", ret);\n\n\tret = imx_sc_misc_set_control(p2d->ipc_handle, p2d->sc_resource,\n\t\t\t\t      IMX_SC_C_PXL_LINK_SEL, p2d->pl_sel);\n\tif (ret)\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"failed to set pixel link selection(%u): %d\\n\",\n\t\t\t\t\t\t\tp2d->pl_sel, ret);\n\n\tswitch (p2d->out_bus_format) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tregmap_write(p2d->regmap, PXL2DPI_CTRL, CFG_24BIT);\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\t\tregmap_write(p2d->regmap, PXL2DPI_CTRL, CFG2_18BIT);\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"unsupported output bus format 0x%08x\\n\",\n\t\t\t\t\t\t\tp2d->out_bus_format);\n\t}\n\n\tif (p2d->companion) {\n\t\tcompanion_p2d = bridge_to_p2d(p2d->companion);\n\n\t\tcompanion_p2d->in_bus_format = p2d->in_bus_format;\n\t\tcompanion_p2d->out_bus_format = p2d->out_bus_format;\n\n\t\tp2d->companion->funcs->mode_set(p2d->companion, mode,\n\t\t\t\t\t\t\tadjusted_mode);\n\t}\n}\n\nstatic void\nimx8qxp_pxl2dpi_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_bridge_state *old_bridge_state)\n{\n\tstruct imx8qxp_pxl2dpi *p2d = bridge->driver_private;\n\tint ret;\n\n\tret = pm_runtime_put(p2d->dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(p2d->dev, \"failed to put runtime PM: %d\\n\", ret);\n\n\tif (p2d->companion)\n\t\tp2d->companion->funcs->atomic_disable(p2d->companion,\n\t\t\t\t\t\t\told_bridge_state);\n}\n\nstatic const u32 imx8qxp_pxl2dpi_bus_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X24,\n\tMEDIA_BUS_FMT_RGB666_1X24_CPADHI,\n};\n\nstatic bool imx8qxp_pxl2dpi_bus_output_fmt_supported(u32 fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx8qxp_pxl2dpi_bus_output_fmts); i++) {\n\t\tif (imx8qxp_pxl2dpi_bus_output_fmts[i] == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nimx8qxp_pxl2dpi_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t\t\t u32 output_fmt,\n\t\t\t\t\t\t unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\tif (!imx8qxp_pxl2dpi_bus_output_fmt_supported(output_fmt))\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tswitch (output_fmt) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X36_CPADLO;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X24_CPADHI:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB666_1X36_CPADLO;\n\t\tbreak;\n\tdefault:\n\t\tkfree(input_fmts);\n\t\tinput_fmts = NULL;\n\t\tbreak;\n\t}\n\n\treturn input_fmts;\n}\n\nstatic u32 *\nimx8qxp_pxl2dpi_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t  struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t  struct drm_connector_state *conn_state,\n\t\t\t\t\t\t  unsigned int *num_output_fmts)\n{\n\t*num_output_fmts = ARRAY_SIZE(imx8qxp_pxl2dpi_bus_output_fmts);\n\treturn kmemdup(imx8qxp_pxl2dpi_bus_output_fmts,\n\t\t\tsizeof(imx8qxp_pxl2dpi_bus_output_fmts), GFP_KERNEL);\n}\n\nstatic const struct drm_bridge_funcs imx8qxp_pxl2dpi_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.attach\t\t\t= imx8qxp_pxl2dpi_bridge_attach,\n\t.atomic_check\t\t= imx8qxp_pxl2dpi_bridge_atomic_check,\n\t.mode_set\t\t= imx8qxp_pxl2dpi_bridge_mode_set,\n\t.atomic_disable\t\t= imx8qxp_pxl2dpi_bridge_atomic_disable,\n\t.atomic_get_input_bus_fmts =\n\t\t\timx8qxp_pxl2dpi_bridge_atomic_get_input_bus_fmts,\n\t.atomic_get_output_bus_fmts =\n\t\t\timx8qxp_pxl2dpi_bridge_atomic_get_output_bus_fmts,\n};\n\nstatic struct device_node *\nimx8qxp_pxl2dpi_get_available_ep_from_port(struct imx8qxp_pxl2dpi *p2d,\n\t\t\t\t\t   u32 port_id)\n{\n\tstruct device_node *port, *ep;\n\tint ep_cnt;\n\n\tport = of_graph_get_port_by_id(p2d->dev->of_node, port_id);\n\tif (!port) {\n\t\tDRM_DEV_ERROR(p2d->dev, \"failed to get port@%u\\n\", port_id);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tep_cnt = of_get_available_child_count(port);\n\tif (ep_cnt == 0) {\n\t\tDRM_DEV_ERROR(p2d->dev, \"no available endpoints of port@%u\\n\",\n\t\t\t      port_id);\n\t\tep = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t} else if (ep_cnt > 1) {\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"invalid available endpoints of port@%u\\n\",\n\t\t\t      port_id);\n\t\tep = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tep = of_get_next_available_child(port, NULL);\n\tif (!ep) {\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"failed to get available endpoint of port@%u\\n\",\n\t\t\t      port_id);\n\t\tep = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t}\nout:\n\tof_node_put(port);\n\treturn ep;\n}\n\nstatic struct drm_bridge *\nimx8qxp_pxl2dpi_find_next_bridge(struct imx8qxp_pxl2dpi *p2d)\n{\n\tstruct device_node *ep, *remote;\n\tstruct drm_bridge *next_bridge;\n\tint ret;\n\n\tep = imx8qxp_pxl2dpi_get_available_ep_from_port(p2d, 1);\n\tif (IS_ERR(ep)) {\n\t\tret = PTR_ERR(ep);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tremote = of_graph_get_remote_port_parent(ep);\n\tif (!remote || !of_device_is_available(remote)) {\n\t\tDRM_DEV_ERROR(p2d->dev, \"no available remote\\n\");\n\t\tnext_bridge = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t} else if (!of_device_is_available(remote->parent)) {\n\t\tDRM_DEV_ERROR(p2d->dev, \"remote parent is not available\\n\");\n\t\tnext_bridge = ERR_PTR(-ENODEV);\n\t\tgoto out;\n\t}\n\n\tnext_bridge = of_drm_find_bridge(remote);\n\tif (!next_bridge) {\n\t\tnext_bridge = ERR_PTR(-EPROBE_DEFER);\n\t\tgoto out;\n\t}\nout:\n\tof_node_put(remote);\n\tof_node_put(ep);\n\n\treturn next_bridge;\n}\n\nstatic int imx8qxp_pxl2dpi_set_pixel_link_sel(struct imx8qxp_pxl2dpi *p2d)\n{\n\tstruct device_node *ep;\n\tstruct of_endpoint endpoint;\n\tint ret;\n\n\tep = imx8qxp_pxl2dpi_get_available_ep_from_port(p2d, 0);\n\tif (IS_ERR(ep))\n\t\treturn PTR_ERR(ep);\n\n\tret = of_graph_parse_endpoint(ep, &endpoint);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(p2d->dev,\n\t\t\t      \"failed to parse endpoint of port@0: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tp2d->pl_sel = endpoint.id;\nout:\n\tof_node_put(ep);\n\n\treturn ret;\n}\n\nstatic int imx8qxp_pxl2dpi_parse_dt_companion(struct imx8qxp_pxl2dpi *p2d)\n{\n\tstruct imx8qxp_pxl2dpi *companion_p2d;\n\tstruct device *dev = p2d->dev;\n\tstruct device_node *companion;\n\tstruct device_node *port1, *port2;\n\tconst struct of_device_id *match;\n\tint dual_link;\n\tint ret = 0;\n\n\t \n\tcompanion = of_parse_phandle(dev->of_node, \"fsl,companion-pxl2dpi\", 0);\n\tif (!companion)\n\t\treturn 0;\n\n\tif (!of_device_is_available(companion)) {\n\t\tDRM_DEV_ERROR(dev, \"companion PXL2DPI is not available\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!of_device_is_compatible(companion, match->compatible)) {\n\t\tDRM_DEV_ERROR(dev, \"companion PXL2DPI is incompatible\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tp2d->companion = of_drm_find_bridge(companion);\n\tif (!p2d->companion) {\n\t\tret = -EPROBE_DEFER;\n\t\tDRM_DEV_DEBUG_DRIVER(p2d->dev,\n\t\t\t\t     \"failed to find companion bridge: %d\\n\",\n\t\t\t\t     ret);\n\t\tgoto out;\n\t}\n\n\tcompanion_p2d = bridge_to_p2d(p2d->companion);\n\n\t \n\tport1 = of_graph_get_port_by_id(p2d->next_bridge->of_node, 1);\n\tport2 = of_graph_get_port_by_id(companion_p2d->next_bridge->of_node, 1);\n\tdual_link = drm_of_lvds_get_dual_link_pixel_order(port1, port2);\n\tof_node_put(port1);\n\tof_node_put(port2);\n\n\tif (dual_link < 0) {\n\t\tret = dual_link;\n\t\tDRM_DEV_ERROR(dev, \"failed to get dual link pixel order: %d\\n\",\n\t\t\t      ret);\n\t\tgoto out;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev,\n\t\t\t     \"dual-link configuration detected (companion bridge %pOF)\\n\",\n\t\t\t     companion);\nout:\n\tof_node_put(companion);\n\treturn ret;\n}\n\nstatic int imx8qxp_pxl2dpi_bridge_probe(struct platform_device *pdev)\n{\n\tstruct imx8qxp_pxl2dpi *p2d;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tp2d = devm_kzalloc(dev, sizeof(*p2d), GFP_KERNEL);\n\tif (!p2d)\n\t\treturn -ENOMEM;\n\n\tp2d->regmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(p2d->regmap)) {\n\t\tret = PTR_ERR(p2d->regmap);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = imx_scu_get_handle(&p2d->ipc_handle);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get SCU ipc handle: %d\\n\",\n\t\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tp2d->dev = dev;\n\n\tret = of_property_read_u32(np, \"fsl,sc-resource\", &p2d->sc_resource);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get SC resource %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tp2d->next_bridge = imx8qxp_pxl2dpi_find_next_bridge(p2d);\n\tif (IS_ERR(p2d->next_bridge)) {\n\t\tret = PTR_ERR(p2d->next_bridge);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to find next bridge: %d\\n\",\n\t\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tret = imx8qxp_pxl2dpi_set_pixel_link_sel(p2d);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx8qxp_pxl2dpi_parse_dt_companion(p2d);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, p2d);\n\tpm_runtime_enable(dev);\n\n\tp2d->bridge.driver_private = p2d;\n\tp2d->bridge.funcs = &imx8qxp_pxl2dpi_bridge_funcs;\n\tp2d->bridge.of_node = np;\n\n\tdrm_bridge_add(&p2d->bridge);\n\n\treturn ret;\n}\n\nstatic void imx8qxp_pxl2dpi_bridge_remove(struct platform_device *pdev)\n{\n\tstruct imx8qxp_pxl2dpi *p2d = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&p2d->bridge);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id imx8qxp_pxl2dpi_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qxp-pxl2dpi\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8qxp_pxl2dpi_dt_ids);\n\nstatic struct platform_driver imx8qxp_pxl2dpi_bridge_driver = {\n\t.probe\t= imx8qxp_pxl2dpi_bridge_probe,\n\t.remove_new = imx8qxp_pxl2dpi_bridge_remove,\n\t.driver\t= {\n\t\t.of_match_table = imx8qxp_pxl2dpi_dt_ids,\n\t\t.name = DRIVER_NAME,\n\t},\n};\nmodule_platform_driver(imx8qxp_pxl2dpi_bridge_driver);\n\nMODULE_DESCRIPTION(\"i.MX8QXP pixel link to DPI bridge driver\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}