{
  "module_name": "imx8qxp-ldb.c",
  "hash_id": "c9f4f928d0d15d0193358b5acc60ba5a14c30f034e3ecf05484278a248301c78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/imx/imx8qxp-ldb.c",
  "human_readable_source": "\n\n \n\n#include <linux/clk.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#include \"imx-ldb-helper.h\"\n\n#define  LDB_CH_SEL\t\tBIT(28)\n\n#define SS_CTRL\t\t\t0x20\n#define  CH_HSYNC_M(id)\t\tBIT(0 + ((id) * 2))\n#define  CH_VSYNC_M(id)\t\tBIT(1 + ((id) * 2))\n#define  CH_PHSYNC(id)\t\tBIT(0 + ((id) * 2))\n#define  CH_PVSYNC(id)\t\tBIT(1 + ((id) * 2))\n\n#define DRIVER_NAME\t\t\"imx8qxp-ldb\"\n\nstruct imx8qxp_ldb_channel {\n\tstruct ldb_channel base;\n\tstruct phy *phy;\n\tunsigned int di_id;\n};\n\nstruct imx8qxp_ldb {\n\tstruct ldb base;\n\tstruct device *dev;\n\tstruct imx8qxp_ldb_channel channel[MAX_LDB_CHAN_NUM];\n\tstruct clk *clk_pixel;\n\tstruct clk *clk_bypass;\n\tstruct drm_bridge *companion;\n\tint active_chno;\n};\n\nstatic inline struct imx8qxp_ldb_channel *\nbase_to_imx8qxp_ldb_channel(struct ldb_channel *base)\n{\n\treturn container_of(base, struct imx8qxp_ldb_channel, base);\n}\n\nstatic inline struct imx8qxp_ldb *base_to_imx8qxp_ldb(struct ldb *base)\n{\n\treturn container_of(base, struct imx8qxp_ldb, base);\n}\n\nstatic void imx8qxp_ldb_set_phy_cfg(struct imx8qxp_ldb *imx8qxp_ldb,\n\t\t\t\t    unsigned long di_clk, bool is_split,\n\t\t\t\t    struct phy_configure_opts_lvds *phy_cfg)\n{\n\tphy_cfg->bits_per_lane_and_dclk_cycle = 7;\n\tphy_cfg->lanes = 4;\n\n\tif (is_split) {\n\t\tphy_cfg->differential_clk_rate = di_clk / 2;\n\t\tphy_cfg->is_slave = !imx8qxp_ldb->companion;\n\t} else {\n\t\tphy_cfg->differential_clk_rate = di_clk;\n\t\tphy_cfg->is_slave = false;\n\t}\n}\n\nstatic int\nimx8qxp_ldb_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch =\n\t\t\t\t\tbase_to_imx8qxp_ldb_channel(ldb_ch);\n\tstruct imx8qxp_ldb *imx8qxp_ldb = base_to_imx8qxp_ldb(ldb);\n\tstruct drm_bridge *companion = imx8qxp_ldb->companion;\n\tstruct drm_display_mode *adj = &crtc_state->adjusted_mode;\n\tunsigned long di_clk = adj->clock * 1000;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tunion phy_configure_opts opts = { };\n\tstruct phy_configure_opts_lvds *phy_cfg = &opts.lvds;\n\tint ret;\n\n\tret = ldb_bridge_atomic_check_helper(bridge, bridge_state,\n\t\t\t\t\t     crtc_state, conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\timx8qxp_ldb_set_phy_cfg(imx8qxp_ldb, di_clk, is_split, phy_cfg);\n\tret = phy_validate(imx8qxp_ldb_ch->phy, PHY_MODE_LVDS, 0, &opts);\n\tif (ret < 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(imx8qxp_ldb->dev,\n\t\t\t\t     \"failed to validate PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (is_split && companion) {\n\t\tret = companion->funcs->atomic_check(companion,\n\t\t\t\t\tbridge_state, crtc_state, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void\nimx8qxp_ldb_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t    const struct drm_display_mode *mode,\n\t\t\t    const struct drm_display_mode *adjusted_mode)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb_channel *companion_ldb_ch;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch =\n\t\t\t\t\tbase_to_imx8qxp_ldb_channel(ldb_ch);\n\tstruct imx8qxp_ldb *imx8qxp_ldb = base_to_imx8qxp_ldb(ldb);\n\tstruct drm_bridge *companion = imx8qxp_ldb->companion;\n\tstruct device *dev = imx8qxp_ldb->dev;\n\tunsigned long di_clk = adjusted_mode->clock * 1000;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tunion phy_configure_opts opts = { };\n\tstruct phy_configure_opts_lvds *phy_cfg = &opts.lvds;\n\tu32 chno = ldb_ch->chno;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to get runtime PM sync: %d\\n\", ret);\n\n\tret = phy_init(imx8qxp_ldb_ch->phy);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to initialize PHY: %d\\n\", ret);\n\n\tret = phy_set_mode(imx8qxp_ldb_ch->phy, PHY_MODE_LVDS);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to set PHY mode: %d\\n\", ret);\n\n\tif (is_split && companion) {\n\t\tcompanion_ldb_ch = bridge_to_ldb_ch(companion);\n\n\t\tcompanion_ldb_ch->in_bus_format = ldb_ch->in_bus_format;\n\t\tcompanion_ldb_ch->out_bus_format = ldb_ch->out_bus_format;\n\t}\n\n\tclk_set_rate(imx8qxp_ldb->clk_bypass, di_clk);\n\tclk_set_rate(imx8qxp_ldb->clk_pixel, di_clk);\n\n\timx8qxp_ldb_set_phy_cfg(imx8qxp_ldb, di_clk, is_split, phy_cfg);\n\tret = phy_configure(imx8qxp_ldb_ch->phy, &opts);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to configure PHY: %d\\n\", ret);\n\n\tif (chno == 0)\n\t\tldb->ldb_ctrl &= ~LDB_CH_SEL;\n\telse\n\t\tldb->ldb_ctrl |= LDB_CH_SEL;\n\n\t \n\tif (imx8qxp_ldb_ch->di_id == 0)\n\t\tldb->ldb_ctrl |= LDB_DI0_VS_POL_ACT_LOW;\n\telse\n\t\tldb->ldb_ctrl |= LDB_DI1_VS_POL_ACT_LOW;\n\n\t \n\tif (is_split)\n\t\tregmap_write(ldb->regmap, ldb->ctrl_reg, ldb->ldb_ctrl);\n\n\tldb_bridge_mode_set_helper(bridge, mode, adjusted_mode);\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL, CH_VSYNC_M(chno), 0);\n\telse if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL,\n\t\t\t\t   CH_VSYNC_M(chno), CH_PVSYNC(chno));\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL, CH_HSYNC_M(chno), 0);\n\telse if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL,\n\t\t\t\t   CH_HSYNC_M(chno), CH_PHSYNC(chno));\n\n\tif (is_split && companion)\n\t\tcompanion->funcs->mode_set(companion, mode, adjusted_mode);\n}\n\nstatic void\nimx8qxp_ldb_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qxp_ldb *imx8qxp_ldb = base_to_imx8qxp_ldb(ldb);\n\tstruct drm_bridge *companion = imx8qxp_ldb->companion;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\n\tclk_prepare_enable(imx8qxp_ldb->clk_pixel);\n\tclk_prepare_enable(imx8qxp_ldb->clk_bypass);\n\n\tif (is_split && companion)\n\t\tcompanion->funcs->atomic_pre_enable(companion, old_bridge_state);\n}\n\nstatic void\nimx8qxp_ldb_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch =\n\t\t\t\t\tbase_to_imx8qxp_ldb_channel(ldb_ch);\n\tstruct imx8qxp_ldb *imx8qxp_ldb = base_to_imx8qxp_ldb(ldb);\n\tstruct drm_bridge *companion = imx8qxp_ldb->companion;\n\tstruct device *dev = imx8qxp_ldb->dev;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tint ret;\n\n\tif (ldb_ch->chno == 0 || is_split) {\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\t\tldb->ldb_ctrl |= imx8qxp_ldb_ch->di_id == 0 ?\n\t\t\t\tLDB_CH0_MODE_EN_TO_DI0 : LDB_CH0_MODE_EN_TO_DI1;\n\t}\n\tif (ldb_ch->chno == 1 || is_split) {\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\t\tldb->ldb_ctrl |= imx8qxp_ldb_ch->di_id == 0 ?\n\t\t\t\tLDB_CH1_MODE_EN_TO_DI0 : LDB_CH1_MODE_EN_TO_DI1;\n\t}\n\n\tldb_bridge_enable_helper(bridge);\n\n\tret = phy_power_on(imx8qxp_ldb_ch->phy);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dev, \"failed to power on PHY: %d\\n\", ret);\n\n\tif (is_split && companion)\n\t\tcompanion->funcs->atomic_enable(companion, old_bridge_state);\n}\n\nstatic void\nimx8qxp_ldb_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch =\n\t\t\t\t\tbase_to_imx8qxp_ldb_channel(ldb_ch);\n\tstruct imx8qxp_ldb *imx8qxp_ldb = base_to_imx8qxp_ldb(ldb);\n\tstruct drm_bridge *companion = imx8qxp_ldb->companion;\n\tstruct device *dev = imx8qxp_ldb->dev;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tint ret;\n\n\tret = phy_power_off(imx8qxp_ldb_ch->phy);\n\tif (ret)\n\t\tDRM_DEV_ERROR(dev, \"failed to power off PHY: %d\\n\", ret);\n\n\tret = phy_exit(imx8qxp_ldb_ch->phy);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to teardown PHY: %d\\n\", ret);\n\n\tldb_bridge_disable_helper(bridge);\n\n\tclk_disable_unprepare(imx8qxp_ldb->clk_bypass);\n\tclk_disable_unprepare(imx8qxp_ldb->clk_pixel);\n\n\tif (is_split && companion)\n\t\tcompanion->funcs->atomic_disable(companion, old_bridge_state);\n\n\tret = pm_runtime_put(dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to put runtime PM: %d\\n\", ret);\n}\n\nstatic const u32 imx8qxp_ldb_bus_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB666_1X7X3_SPWG,\n\tMEDIA_BUS_FMT_RGB888_1X7X4_SPWG,\n\tMEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,\n\tMEDIA_BUS_FMT_FIXED,\n};\n\nstatic bool imx8qxp_ldb_bus_output_fmt_supported(u32 fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx8qxp_ldb_bus_output_fmts); i++) {\n\t\tif (imx8qxp_ldb_bus_output_fmts[i] == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nimx8qxp_ldb_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t     u32 output_fmt,\n\t\t\t\t\t     unsigned int *num_input_fmts)\n{\n\tstruct drm_display_info *di;\n\tconst struct drm_format_info *finfo;\n\tu32 *input_fmts;\n\n\tif (!imx8qxp_ldb_bus_output_fmt_supported(output_fmt))\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tswitch (output_fmt) {\n\tcase MEDIA_BUS_FMT_FIXED:\n\t\tdi = &conn_state->connector->display_info;\n\n\t\t \n\t\tif (di->num_bus_formats) {\n\t\t\tfinfo = drm_format_info(di->bus_formats[0]);\n\n\t\t\tinput_fmts[0] = finfo->depth == 18 ?\n\t\t\t\t\tMEDIA_BUS_FMT_RGB666_1X24_CPADHI :\n\t\t\t\t\tMEDIA_BUS_FMT_RGB888_1X24;\n\t\t} else {\n\t\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\t}\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB666_1X24_CPADHI;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t\tbreak;\n\tdefault:\n\t\tkfree(input_fmts);\n\t\tinput_fmts = NULL;\n\t\tbreak;\n\t}\n\n\treturn input_fmts;\n}\n\nstatic u32 *\nimx8qxp_ldb_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_bridge_state *bridge_state,\n\t\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t\t      struct drm_connector_state *conn_state,\n\t\t\t\t\t      unsigned int *num_output_fmts)\n{\n\t*num_output_fmts = ARRAY_SIZE(imx8qxp_ldb_bus_output_fmts);\n\treturn kmemdup(imx8qxp_ldb_bus_output_fmts,\n\t\t\tsizeof(imx8qxp_ldb_bus_output_fmts), GFP_KERNEL);\n}\n\nstatic enum drm_mode_status\nimx8qxp_ldb_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t      const struct drm_display_info *info,\n\t\t\t      const struct drm_display_mode *mode)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tbool is_single = ldb_channel_is_single_link(ldb_ch);\n\n\tif (mode->clock > 170000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->clock > 150000 && is_single)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs imx8qxp_ldb_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.mode_valid\t\t= imx8qxp_ldb_bridge_mode_valid,\n\t.attach\t\t\t= ldb_bridge_attach_helper,\n\t.atomic_check\t\t= imx8qxp_ldb_bridge_atomic_check,\n\t.mode_set\t\t= imx8qxp_ldb_bridge_mode_set,\n\t.atomic_pre_enable\t= imx8qxp_ldb_bridge_atomic_pre_enable,\n\t.atomic_enable\t\t= imx8qxp_ldb_bridge_atomic_enable,\n\t.atomic_disable\t\t= imx8qxp_ldb_bridge_atomic_disable,\n\t.atomic_get_input_bus_fmts =\n\t\t\timx8qxp_ldb_bridge_atomic_get_input_bus_fmts,\n\t.atomic_get_output_bus_fmts =\n\t\t\timx8qxp_ldb_bridge_atomic_get_output_bus_fmts,\n};\n\nstatic int imx8qxp_ldb_set_di_id(struct imx8qxp_ldb *imx8qxp_ldb)\n{\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch =\n\t\t\t &imx8qxp_ldb->channel[imx8qxp_ldb->active_chno];\n\tstruct ldb_channel *ldb_ch = &imx8qxp_ldb_ch->base;\n\tstruct device_node *ep, *remote;\n\tstruct device *dev = imx8qxp_ldb->dev;\n\tstruct of_endpoint endpoint;\n\tint ret;\n\n\tep = of_graph_get_endpoint_by_regs(ldb_ch->np, 0, -1);\n\tif (!ep) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get port0 endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tremote = of_graph_get_remote_endpoint(ep);\n\tof_node_put(ep);\n\tif (!remote) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get port0 remote endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_graph_parse_endpoint(remote, &endpoint);\n\tof_node_put(remote);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to parse port0 remote endpoint: %d\\n\",\n\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\timx8qxp_ldb_ch->di_id = endpoint.id;\n\n\treturn 0;\n}\n\nstatic int\nimx8qxp_ldb_check_chno_and_dual_link(struct ldb_channel *ldb_ch, int link)\n{\n\tif ((link == DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS && ldb_ch->chno != 0) ||\n\t    (link == DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS && ldb_ch->chno != 1))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int imx8qxp_ldb_parse_dt_companion(struct imx8qxp_ldb *imx8qxp_ldb)\n{\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch =\n\t\t\t &imx8qxp_ldb->channel[imx8qxp_ldb->active_chno];\n\tstruct ldb_channel *ldb_ch = &imx8qxp_ldb_ch->base;\n\tstruct ldb_channel *companion_ldb_ch;\n\tstruct device_node *companion;\n\tstruct device_node *child;\n\tstruct device_node *companion_port = NULL;\n\tstruct device_node *port1, *port2;\n\tstruct device *dev = imx8qxp_ldb->dev;\n\tconst struct of_device_id *match;\n\tu32 i;\n\tint dual_link;\n\tint ret;\n\n\t \n\tcompanion = of_parse_phandle(dev->of_node, \"fsl,companion-ldb\", 0);\n\tif (!companion)\n\t\treturn 0;\n\n\tif (!of_device_is_available(companion)) {\n\t\tDRM_DEV_ERROR(dev, \"companion LDB is not available\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!of_device_is_compatible(companion, match->compatible)) {\n\t\tDRM_DEV_ERROR(dev, \"companion LDB is incompatible\\n\");\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tfor_each_available_child_of_node(companion, child) {\n\t\tret = of_property_read_u32(child, \"reg\", &i);\n\t\tif (ret || i > MAX_LDB_CHAN_NUM - 1) {\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"invalid channel node address: %u\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tof_node_put(child);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (i == (ldb_ch->chno ^ 0x1)) {\n\t\t\tcompanion_port = child;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!companion_port) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"failed to find companion LDB channel port\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tport1 = of_graph_get_port_by_id(ldb_ch->np, 1);\n\tport2 = of_graph_get_port_by_id(companion_port, 1);\n\tdual_link = drm_of_lvds_get_dual_link_pixel_order(port1, port2);\n\tof_node_put(port1);\n\tof_node_put(port2);\n\n\tswitch (dual_link) {\n\tcase DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS:\n\t\tldb_ch->link_type = LDB_CH_DUAL_LINK_ODD_EVEN_PIXELS;\n\t\tbreak;\n\tcase DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS:\n\t\tldb_ch->link_type = LDB_CH_DUAL_LINK_EVEN_ODD_PIXELS;\n\t\tbreak;\n\tdefault:\n\t\tret = dual_link;\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"failed to get dual link pixel order: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = imx8qxp_ldb_check_chno_and_dual_link(ldb_ch, dual_link);\n\tif (ret < 0) {\n\t\tDRM_DEV_ERROR(dev,\n\t\t\t      \"unmatched channel number(%u) vs dual link(%d)\\n\",\n\t\t\t      ldb_ch->chno, dual_link);\n\t\tgoto out;\n\t}\n\n\timx8qxp_ldb->companion = of_drm_find_bridge(companion_port);\n\tif (!imx8qxp_ldb->companion) {\n\t\tret = -EPROBE_DEFER;\n\t\tDRM_DEV_DEBUG_DRIVER(dev,\n\t\t\t\t     \"failed to find bridge for companion bridge: %d\\n\",\n\t\t\t\t     ret);\n\t\tgoto out;\n\t}\n\n\tDRM_DEV_DEBUG_DRIVER(dev,\n\t\t\t     \"dual-link configuration detected (companion bridge %pOF)\\n\",\n\t\t\t     companion);\n\n\tcompanion_ldb_ch = bridge_to_ldb_ch(imx8qxp_ldb->companion);\n\tcompanion_ldb_ch->link_type = ldb_ch->link_type;\nout:\n\tof_node_put(companion_port);\n\tof_node_put(companion);\n\treturn ret;\n}\n\nstatic int imx8qxp_ldb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx8qxp_ldb *imx8qxp_ldb;\n\tstruct imx8qxp_ldb_channel *imx8qxp_ldb_ch;\n\tstruct ldb *ldb;\n\tstruct ldb_channel *ldb_ch;\n\tint ret, i;\n\n\timx8qxp_ldb = devm_kzalloc(dev, sizeof(*imx8qxp_ldb), GFP_KERNEL);\n\tif (!imx8qxp_ldb)\n\t\treturn -ENOMEM;\n\n\timx8qxp_ldb->clk_pixel = devm_clk_get(dev, \"pixel\");\n\tif (IS_ERR(imx8qxp_ldb->clk_pixel)) {\n\t\tret = PTR_ERR(imx8qxp_ldb->clk_pixel);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to get pixel clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\timx8qxp_ldb->clk_bypass = devm_clk_get(dev, \"bypass\");\n\tif (IS_ERR(imx8qxp_ldb->clk_bypass)) {\n\t\tret = PTR_ERR(imx8qxp_ldb->clk_bypass);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to get bypass clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\timx8qxp_ldb->dev = dev;\n\n\tldb = &imx8qxp_ldb->base;\n\tldb->dev = dev;\n\tldb->ctrl_reg = 0xe0;\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++)\n\t\tldb->channel[i] = &imx8qxp_ldb->channel[i].base;\n\n\tret = ldb_init_helper(ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ldb->available_ch_cnt == 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"no available channel\\n\");\n\t\treturn 0;\n\t} else if (ldb->available_ch_cnt > 1) {\n\t\tDRM_DEV_ERROR(dev, \"invalid available channel number(%u)\\n\",\n\t\t\t      ldb->available_ch_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++) {\n\t\timx8qxp_ldb_ch = &imx8qxp_ldb->channel[i];\n\t\tldb_ch = &imx8qxp_ldb_ch->base;\n\n\t\tif (ldb_ch->is_available) {\n\t\t\timx8qxp_ldb->active_chno = ldb_ch->chno;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\timx8qxp_ldb_ch->phy = devm_of_phy_get(dev, ldb_ch->np, \"lvds_phy\");\n\tif (IS_ERR(imx8qxp_ldb_ch->phy)) {\n\t\tret = PTR_ERR(imx8qxp_ldb_ch->phy);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get channel%d PHY: %d\\n\",\n\t\t\t\t      imx8qxp_ldb->active_chno, ret);\n\t\treturn ret;\n\t}\n\n\tret = ldb_find_next_bridge_helper(ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx8qxp_ldb_set_di_id(imx8qxp_ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx8qxp_ldb_parse_dt_companion(imx8qxp_ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, imx8qxp_ldb);\n\tpm_runtime_enable(dev);\n\n\tldb_add_bridge_helper(ldb, &imx8qxp_ldb_bridge_funcs);\n\n\treturn ret;\n}\n\nstatic void imx8qxp_ldb_remove(struct platform_device *pdev)\n{\n\tstruct imx8qxp_ldb *imx8qxp_ldb = platform_get_drvdata(pdev);\n\tstruct ldb *ldb = &imx8qxp_ldb->base;\n\n\tldb_remove_bridge_helper(ldb);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused imx8qxp_ldb_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused imx8qxp_ldb_runtime_resume(struct device *dev)\n{\n\tstruct imx8qxp_ldb *imx8qxp_ldb = dev_get_drvdata(dev);\n\tstruct ldb *ldb = &imx8qxp_ldb->base;\n\n\t \n\tregmap_write(ldb->regmap, ldb->ctrl_reg, 0);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx8qxp_ldb_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx8qxp_ldb_runtime_suspend,\n\t\t\t   imx8qxp_ldb_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id imx8qxp_ldb_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qxp-ldb\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8qxp_ldb_dt_ids);\n\nstatic struct platform_driver imx8qxp_ldb_driver = {\n\t.probe\t= imx8qxp_ldb_probe,\n\t.remove_new = imx8qxp_ldb_remove,\n\t.driver\t= {\n\t\t.pm = &imx8qxp_ldb_pm_ops,\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = imx8qxp_ldb_dt_ids,\n\t},\n};\nmodule_platform_driver(imx8qxp_ldb_driver);\n\nMODULE_DESCRIPTION(\"i.MX8QXP LVDS Display Bridge(LDB)/Pixel Mapper bridge driver\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}