{
  "module_name": "imx8qxp-pixel-combiner.c",
  "hash_id": "a5b16296e029f5af1390230b147e9a2cd5f8a60a6359de1bd524f4d60e99366b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/imx/imx8qxp-pixel-combiner.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_print.h>\n\n#define PC_CTRL_REG\t\t\t0x0\n#define  PC_COMBINE_ENABLE\t\tBIT(0)\n#define  PC_DISP_BYPASS(n)\t\tBIT(1 + 21 * (n))\n#define  PC_DISP_HSYNC_POLARITY(n)\tBIT(2 + 11 * (n))\n#define  PC_DISP_HSYNC_POLARITY_POS(n)\tDISP_HSYNC_POLARITY(n)\n#define  PC_DISP_VSYNC_POLARITY(n)\tBIT(3 + 11 * (n))\n#define  PC_DISP_VSYNC_POLARITY_POS(n)\tDISP_VSYNC_POLARITY(n)\n#define  PC_DISP_DVALID_POLARITY(n)\tBIT(4 + 11 * (n))\n#define  PC_DISP_DVALID_POLARITY_POS(n)\tDISP_DVALID_POLARITY(n)\n#define  PC_VSYNC_MASK_ENABLE\t\tBIT(5)\n#define  PC_SKIP_MODE\t\t\tBIT(6)\n#define  PC_SKIP_NUMBER_MASK\t\tGENMASK(12, 7)\n#define  PC_SKIP_NUMBER(n)\t\tFIELD_PREP(PC_SKIP_NUMBER_MASK, (n))\n#define  PC_DISP0_PIX_DATA_FORMAT_MASK\tGENMASK(18, 16)\n#define  PC_DISP0_PIX_DATA_FORMAT(fmt)\t\\\n\t\t\t\tFIELD_PREP(PC_DISP0_PIX_DATA_FORMAT_MASK, (fmt))\n#define  PC_DISP1_PIX_DATA_FORMAT_MASK\tGENMASK(21, 19)\n#define  PC_DISP1_PIX_DATA_FORMAT(fmt)\t\\\n\t\t\t\tFIELD_PREP(PC_DISP1_PIX_DATA_FORMAT_MASK, (fmt))\n\n#define PC_SW_RESET_REG\t\t\t0x20\n#define  PC_SW_RESET_N\t\t\tBIT(0)\n#define  PC_DISP_SW_RESET_N(n)\t\tBIT(1 + (n))\n#define  PC_FULL_RESET_N\t\t(PC_SW_RESET_N |\t\t\\\n\t\t\t\t\t PC_DISP_SW_RESET_N(0) |\t\\\n\t\t\t\t\t PC_DISP_SW_RESET_N(1))\n\n#define PC_REG_SET\t\t\t0x4\n#define PC_REG_CLR\t\t\t0x8\n\n#define DRIVER_NAME\t\t\t\"imx8qxp-pixel-combiner\"\n\nenum imx8qxp_pc_pix_data_format {\n\tRGB,\n\tYUV444,\n\tYUV422,\n\tSPLIT_RGB,\n};\n\nstruct imx8qxp_pc_channel {\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct imx8qxp_pc *pc;\n\tunsigned int stream_id;\n\tbool is_available;\n};\n\nstruct imx8qxp_pc {\n\tstruct device *dev;\n\tstruct imx8qxp_pc_channel ch[2];\n\tstruct clk *clk_apb;\n\tvoid __iomem *base;\n};\n\nstatic inline u32 imx8qxp_pc_read(struct imx8qxp_pc *pc, unsigned int offset)\n{\n\treturn readl(pc->base + offset);\n}\n\nstatic inline void\nimx8qxp_pc_write(struct imx8qxp_pc *pc, unsigned int offset, u32 value)\n{\n\twritel(value, pc->base + offset);\n}\n\nstatic inline void\nimx8qxp_pc_write_set(struct imx8qxp_pc *pc, unsigned int offset, u32 value)\n{\n\timx8qxp_pc_write(pc, offset + PC_REG_SET, value);\n}\n\nstatic inline void\nimx8qxp_pc_write_clr(struct imx8qxp_pc *pc, unsigned int offset, u32 value)\n{\n\timx8qxp_pc_write(pc, offset + PC_REG_CLR, value);\n}\n\nstatic enum drm_mode_status\nimx8qxp_pc_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t     const struct drm_display_info *info,\n\t\t\t     const struct drm_display_mode *mode)\n{\n\tif (mode->hdisplay > 2560)\n\t\treturn MODE_BAD_HVALUE;\n\n\treturn MODE_OK;\n}\n\nstatic int imx8qxp_pc_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct imx8qxp_pc_channel *ch = bridge->driver_private;\n\tstruct imx8qxp_pc *pc = ch->pc;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tDRM_DEV_ERROR(pc->dev,\n\t\t\t      \"do not support creating a drm_connector\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_DEV_ERROR(pc->dev, \"missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder,\n\t\t\t\t ch->next_bridge, bridge,\n\t\t\t\t DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n}\n\nstatic void\nimx8qxp_pc_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t   const struct drm_display_mode *mode,\n\t\t\t   const struct drm_display_mode *adjusted_mode)\n{\n\tstruct imx8qxp_pc_channel *ch = bridge->driver_private;\n\tstruct imx8qxp_pc *pc = ch->pc;\n\tu32 val;\n\tint ret;\n\n\tret = pm_runtime_get_sync(pc->dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(pc->dev,\n\t\t\t      \"failed to get runtime PM sync: %d\\n\", ret);\n\n\tret = clk_prepare_enable(pc->clk_apb);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pc->dev, \"%s: failed to enable apb clock: %d\\n\",\n\t\t\t      __func__,  ret);\n\n\t \n\timx8qxp_pc_write_clr(pc, PC_CTRL_REG,\n\t\t\t     PC_DISP_HSYNC_POLARITY(ch->stream_id));\n\n\t \n\timx8qxp_pc_write_clr(pc, PC_CTRL_REG,\n\t\t\t     PC_DISP_VSYNC_POLARITY(ch->stream_id));\n\n\t \n\timx8qxp_pc_write_set(pc, PC_CTRL_REG,\n\t\t\t     PC_DISP_DVALID_POLARITY(ch->stream_id));\n\n\t \n\timx8qxp_pc_write_set(pc, PC_CTRL_REG, PC_VSYNC_MASK_ENABLE);\n\n\t \n\tval = imx8qxp_pc_read(pc, PC_CTRL_REG);\n\tif (ch->stream_id == 0) {\n\t\tval &= ~PC_DISP0_PIX_DATA_FORMAT_MASK;\n\t\tval |= PC_DISP0_PIX_DATA_FORMAT(RGB);\n\t} else {\n\t\tval &= ~PC_DISP1_PIX_DATA_FORMAT_MASK;\n\t\tval |= PC_DISP1_PIX_DATA_FORMAT(RGB);\n\t}\n\timx8qxp_pc_write(pc, PC_CTRL_REG, val);\n\n\t \n\timx8qxp_pc_write_set(pc, PC_CTRL_REG, PC_DISP_BYPASS(ch->stream_id));\n\n\tclk_disable_unprepare(pc->clk_apb);\n}\n\nstatic void\nimx8qxp_pc_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct imx8qxp_pc_channel *ch = bridge->driver_private;\n\tstruct imx8qxp_pc *pc = ch->pc;\n\tint ret;\n\n\tret = pm_runtime_put(pc->dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(pc->dev, \"failed to put runtime PM: %d\\n\", ret);\n}\n\nstatic const u32 imx8qxp_pc_bus_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X36_CPADLO,\n\tMEDIA_BUS_FMT_RGB666_1X36_CPADLO,\n};\n\nstatic bool imx8qxp_pc_bus_output_fmt_supported(u32 fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx8qxp_pc_bus_output_fmts); i++) {\n\t\tif (imx8qxp_pc_bus_output_fmts[i] == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nimx8qxp_pc_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t\t    u32 output_fmt,\n\t\t\t\t\t    unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\tif (!imx8qxp_pc_bus_output_fmt_supported(output_fmt))\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tswitch (output_fmt) {\n\tcase MEDIA_BUS_FMT_RGB888_1X36_CPADLO:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X30_CPADLO;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X36_CPADLO:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB666_1X30_CPADLO;\n\t\tbreak;\n\tdefault:\n\t\tkfree(input_fmts);\n\t\tinput_fmts = NULL;\n\t\tbreak;\n\t}\n\n\treturn input_fmts;\n}\n\nstatic u32 *\nimx8qxp_pc_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t     unsigned int *num_output_fmts)\n{\n\t*num_output_fmts = ARRAY_SIZE(imx8qxp_pc_bus_output_fmts);\n\treturn kmemdup(imx8qxp_pc_bus_output_fmts,\n\t\t\tsizeof(imx8qxp_pc_bus_output_fmts), GFP_KERNEL);\n}\n\nstatic const struct drm_bridge_funcs imx8qxp_pc_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.mode_valid\t\t= imx8qxp_pc_bridge_mode_valid,\n\t.attach\t\t\t= imx8qxp_pc_bridge_attach,\n\t.mode_set\t\t= imx8qxp_pc_bridge_mode_set,\n\t.atomic_disable\t\t= imx8qxp_pc_bridge_atomic_disable,\n\t.atomic_get_input_bus_fmts =\n\t\t\t\timx8qxp_pc_bridge_atomic_get_input_bus_fmts,\n\t.atomic_get_output_bus_fmts =\n\t\t\t\timx8qxp_pc_bridge_atomic_get_output_bus_fmts,\n};\n\nstatic int imx8qxp_pc_bridge_probe(struct platform_device *pdev)\n{\n\tstruct imx8qxp_pc *pc;\n\tstruct imx8qxp_pc_channel *ch;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child, *remote;\n\tu32 i;\n\tint ret;\n\n\tpc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\n\tif (!pc)\n\t\treturn -ENOMEM;\n\n\tpc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(pc->base))\n\t\treturn PTR_ERR(pc->base);\n\n\tpc->dev = dev;\n\n\tpc->clk_apb = devm_clk_get(dev, \"apb\");\n\tif (IS_ERR(pc->clk_apb)) {\n\t\tret = PTR_ERR(pc->clk_apb);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get apb clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pc);\n\tpm_runtime_enable(dev);\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tret = of_property_read_u32(child, \"reg\", &i);\n\t\tif (ret || i > 1) {\n\t\t\tret = -EINVAL;\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"invalid channel(%u) node address\\n\", i);\n\t\t\tgoto free_child;\n\t\t}\n\n\t\tch = &pc->ch[i];\n\t\tch->pc = pc;\n\t\tch->stream_id = i;\n\n\t\tremote = of_graph_get_remote_node(child, 1, 0);\n\t\tif (!remote) {\n\t\t\tret = -ENODEV;\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"channel%u failed to get port1's remote node: %d\\n\",\n\t\t\t\t      i, ret);\n\t\t\tgoto free_child;\n\t\t}\n\n\t\tch->next_bridge = of_drm_find_bridge(remote);\n\t\tif (!ch->next_bridge) {\n\t\t\tof_node_put(remote);\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tDRM_DEV_DEBUG_DRIVER(dev,\n\t\t\t\t\t     \"channel%u failed to find next bridge: %d\\n\",\n\t\t\t\t\t     i, ret);\n\t\t\tgoto free_child;\n\t\t}\n\n\t\tof_node_put(remote);\n\n\t\tch->bridge.driver_private = ch;\n\t\tch->bridge.funcs = &imx8qxp_pc_bridge_funcs;\n\t\tch->bridge.of_node = child;\n\t\tch->is_available = true;\n\n\t\tdrm_bridge_add(&ch->bridge);\n\t}\n\n\treturn 0;\n\nfree_child:\n\tof_node_put(child);\n\n\tif (i == 1 && pc->ch[0].next_bridge)\n\t\tdrm_bridge_remove(&pc->ch[0].bridge);\n\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void imx8qxp_pc_bridge_remove(struct platform_device *pdev)\n{\n\tstruct imx8qxp_pc *pc = platform_get_drvdata(pdev);\n\tstruct imx8qxp_pc_channel *ch;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tch = &pc->ch[i];\n\n\t\tif (!ch->is_available)\n\t\t\tcontinue;\n\n\t\tdrm_bridge_remove(&ch->bridge);\n\t\tch->is_available = false;\n\t}\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused imx8qxp_pc_runtime_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct imx8qxp_pc *pc = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = clk_prepare_enable(pc->clk_apb);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pc->dev, \"%s: failed to enable apb clock: %d\\n\",\n\t\t\t      __func__,  ret);\n\n\t \n\timx8qxp_pc_write_clr(pc, PC_SW_RESET_REG, PC_FULL_RESET_N);\n\n\tclk_disable_unprepare(pc->clk_apb);\n\n\t \n\tusleep_range(10, 20);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused imx8qxp_pc_runtime_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct imx8qxp_pc *pc = platform_get_drvdata(pdev);\n\tint ret;\n\n\tret = clk_prepare_enable(pc->clk_apb);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(pc->dev, \"%s: failed to enable apb clock: %d\\n\",\n\t\t\t      __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\timx8qxp_pc_write_set(pc, PC_SW_RESET_REG, PC_FULL_RESET_N);\n\n\tclk_disable_unprepare(pc->clk_apb);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops imx8qxp_pc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx8qxp_pc_runtime_suspend,\n\t\t\t   imx8qxp_pc_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id imx8qxp_pc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qm-pixel-combiner\", },\n\t{ .compatible = \"fsl,imx8qxp-pixel-combiner\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8qxp_pc_dt_ids);\n\nstatic struct platform_driver imx8qxp_pc_bridge_driver = {\n\t.probe\t= imx8qxp_pc_bridge_probe,\n\t.remove_new = imx8qxp_pc_bridge_remove,\n\t.driver\t= {\n\t\t.pm = &imx8qxp_pc_pm_ops,\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = imx8qxp_pc_dt_ids,\n\t},\n};\nmodule_platform_driver(imx8qxp_pc_bridge_driver);\n\nMODULE_DESCRIPTION(\"i.MX8QM/QXP pixel combiner bridge driver\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}