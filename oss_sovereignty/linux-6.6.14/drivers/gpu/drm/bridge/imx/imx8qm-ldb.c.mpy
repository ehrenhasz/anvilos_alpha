{
  "module_name": "imx8qm-ldb.c",
  "hash_id": "a9430697c6fb15ef80f26a9a40f843218253211efc1557c498d1207999bf2658",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/imx/imx8qm-ldb.c",
  "human_readable_source": "\n\n \n\n#include <linux/clk.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#include \"imx-ldb-helper.h\"\n\n#define  LDB_CH0_10BIT_EN\t\tBIT(22)\n#define  LDB_CH1_10BIT_EN\t\tBIT(23)\n#define  LDB_CH0_DATA_WIDTH_24BIT\tBIT(24)\n#define  LDB_CH1_DATA_WIDTH_24BIT\tBIT(26)\n#define  LDB_CH0_DATA_WIDTH_30BIT\t(2 << 24)\n#define  LDB_CH1_DATA_WIDTH_30BIT\t(2 << 26)\n\n#define SS_CTRL\t\t\t\t0x20\n#define  CH_HSYNC_M(id)\t\t\tBIT(0 + ((id) * 2))\n#define  CH_VSYNC_M(id)\t\t\tBIT(1 + ((id) * 2))\n#define  CH_PHSYNC(id)\t\t\tBIT(0 + ((id) * 2))\n#define  CH_PVSYNC(id)\t\t\tBIT(1 + ((id) * 2))\n\n#define DRIVER_NAME\t\t\t\"imx8qm-ldb\"\n\nstruct imx8qm_ldb_channel {\n\tstruct ldb_channel base;\n\tstruct phy *phy;\n};\n\nstruct imx8qm_ldb {\n\tstruct ldb base;\n\tstruct device *dev;\n\tstruct imx8qm_ldb_channel channel[MAX_LDB_CHAN_NUM];\n\tstruct clk *clk_pixel;\n\tstruct clk *clk_bypass;\n\tint active_chno;\n};\n\nstatic inline struct imx8qm_ldb_channel *\nbase_to_imx8qm_ldb_channel(struct ldb_channel *base)\n{\n\treturn container_of(base, struct imx8qm_ldb_channel, base);\n}\n\nstatic inline struct imx8qm_ldb *base_to_imx8qm_ldb(struct ldb *base)\n{\n\treturn container_of(base, struct imx8qm_ldb, base);\n}\n\nstatic void imx8qm_ldb_set_phy_cfg(struct imx8qm_ldb *imx8qm_ldb,\n\t\t\t\t   unsigned long di_clk,\n\t\t\t\t   bool is_split, bool is_slave,\n\t\t\t\t   struct phy_configure_opts_lvds *phy_cfg)\n{\n\tphy_cfg->bits_per_lane_and_dclk_cycle = 7;\n\tphy_cfg->lanes = 4;\n\tphy_cfg->differential_clk_rate = is_split ? di_clk / 2 : di_clk;\n\tphy_cfg->is_slave = is_slave;\n}\n\nstatic int imx8qm_ldb_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *bridge_state,\n\t\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qm_ldb_channel *imx8qm_ldb_ch =\n\t\t\t\t\tbase_to_imx8qm_ldb_channel(ldb_ch);\n\tstruct imx8qm_ldb *imx8qm_ldb = base_to_imx8qm_ldb(ldb);\n\tstruct drm_display_mode *adj = &crtc_state->adjusted_mode;\n\tunsigned long di_clk = adj->clock * 1000;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tunion phy_configure_opts opts = { };\n\tstruct phy_configure_opts_lvds *phy_cfg = &opts.lvds;\n\tint ret;\n\n\tret = ldb_bridge_atomic_check_helper(bridge, bridge_state,\n\t\t\t\t\t     crtc_state, conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\timx8qm_ldb_set_phy_cfg(imx8qm_ldb, di_clk, is_split, false, phy_cfg);\n\tret = phy_validate(imx8qm_ldb_ch->phy, PHY_MODE_LVDS, 0, &opts);\n\tif (ret < 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(imx8qm_ldb->dev,\n\t\t\t\t     \"failed to validate PHY: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (is_split) {\n\t\timx8qm_ldb_ch =\n\t\t\t&imx8qm_ldb->channel[imx8qm_ldb->active_chno ^ 1];\n\t\timx8qm_ldb_set_phy_cfg(imx8qm_ldb, di_clk, is_split, true,\n\t\t\t\t       phy_cfg);\n\t\tret = phy_validate(imx8qm_ldb_ch->phy, PHY_MODE_LVDS, 0, &opts);\n\t\tif (ret < 0) {\n\t\t\tDRM_DEV_DEBUG_DRIVER(imx8qm_ldb->dev,\n\t\t\t\t\t     \"failed to validate slave PHY: %d\\n\",\n\t\t\t\t\t     ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void\nimx8qm_ldb_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t   const struct drm_display_mode *mode,\n\t\t\t   const struct drm_display_mode *adjusted_mode)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qm_ldb_channel *imx8qm_ldb_ch =\n\t\t\t\t\tbase_to_imx8qm_ldb_channel(ldb_ch);\n\tstruct imx8qm_ldb *imx8qm_ldb = base_to_imx8qm_ldb(ldb);\n\tstruct device *dev = imx8qm_ldb->dev;\n\tunsigned long di_clk = adjusted_mode->clock * 1000;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tunion phy_configure_opts opts = { };\n\tstruct phy_configure_opts_lvds *phy_cfg = &opts.lvds;\n\tu32 chno = ldb_ch->chno;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to get runtime PM sync: %d\\n\", ret);\n\n\tret = phy_init(imx8qm_ldb_ch->phy);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to initialize PHY: %d\\n\", ret);\n\n\tclk_set_rate(imx8qm_ldb->clk_bypass, di_clk);\n\tclk_set_rate(imx8qm_ldb->clk_pixel, di_clk);\n\n\timx8qm_ldb_set_phy_cfg(imx8qm_ldb, di_clk, is_split, false, phy_cfg);\n\tret = phy_configure(imx8qm_ldb_ch->phy, &opts);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to configure PHY: %d\\n\", ret);\n\n\tif (is_split) {\n\t\timx8qm_ldb_ch =\n\t\t\t&imx8qm_ldb->channel[imx8qm_ldb->active_chno ^ 1];\n\t\timx8qm_ldb_set_phy_cfg(imx8qm_ldb, di_clk, is_split, true,\n\t\t\t\t       phy_cfg);\n\t\tret = phy_configure(imx8qm_ldb_ch->phy, &opts);\n\t\tif (ret < 0)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to configure slave PHY: %d\\n\",\n\t\t\t\t      ret);\n\t}\n\n\t \n\tif (ldb_ch->chno == 0 || is_split)\n\t\tldb->ldb_ctrl |= LDB_DI0_VS_POL_ACT_LOW;\n\tif (ldb_ch->chno == 1 || is_split)\n\t\tldb->ldb_ctrl |= LDB_DI1_VS_POL_ACT_LOW;\n\n\tswitch (ldb_ch->out_bus_format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tif (ldb_ch->chno == 0 || is_split)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_DATA_WIDTH_24BIT;\n\t\tif (ldb_ch->chno == 1 || is_split)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_DATA_WIDTH_24BIT;\n\t\tbreak;\n\t}\n\n\tldb_bridge_mode_set_helper(bridge, mode, adjusted_mode);\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL, CH_VSYNC_M(chno), 0);\n\telse if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL,\n\t\t\t\t   CH_VSYNC_M(chno), CH_PVSYNC(chno));\n\n\tif (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL, CH_HSYNC_M(chno), 0);\n\telse if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tregmap_update_bits(ldb->regmap, SS_CTRL,\n\t\t\t\t   CH_HSYNC_M(chno), CH_PHSYNC(chno));\n}\n\nstatic void\nimx8qm_ldb_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qm_ldb_channel *imx8qm_ldb_ch =\n\t\t\t\t\tbase_to_imx8qm_ldb_channel(ldb_ch);\n\tstruct imx8qm_ldb *imx8qm_ldb = base_to_imx8qm_ldb(ldb);\n\tstruct device *dev = imx8qm_ldb->dev;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tint ret;\n\n\tclk_prepare_enable(imx8qm_ldb->clk_pixel);\n\tclk_prepare_enable(imx8qm_ldb->clk_bypass);\n\n\t \n\tif (ldb_ch->chno == 0 || is_split) {\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;\n\t}\n\tif (ldb_ch->chno == 1 || is_split) {\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;\n\t}\n\n\tif (is_split) {\n\t\tret = phy_power_on(imx8qm_ldb->channel[0].phy);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to power on channel0 PHY: %d\\n\",\n\t\t\t\t      ret);\n\n\t\tret = phy_power_on(imx8qm_ldb->channel[1].phy);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to power on channel1 PHY: %d\\n\",\n\t\t\t\t      ret);\n\t} else {\n\t\tret = phy_power_on(imx8qm_ldb_ch->phy);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to power on PHY: %d\\n\", ret);\n\t}\n\n\tldb_bridge_enable_helper(bridge);\n}\n\nstatic void\nimx8qm_ldb_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tstruct imx8qm_ldb_channel *imx8qm_ldb_ch =\n\t\t\t\t\tbase_to_imx8qm_ldb_channel(ldb_ch);\n\tstruct imx8qm_ldb *imx8qm_ldb = base_to_imx8qm_ldb(ldb);\n\tstruct device *dev = imx8qm_ldb->dev;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\tint ret;\n\n\tldb_bridge_disable_helper(bridge);\n\n\tif (is_split) {\n\t\tret = phy_power_off(imx8qm_ldb->channel[0].phy);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to power off channel0 PHY: %d\\n\",\n\t\t\t\t      ret);\n\t\tret = phy_power_off(imx8qm_ldb->channel[1].phy);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to power off channel1 PHY: %d\\n\",\n\t\t\t\t      ret);\n\t} else {\n\t\tret = phy_power_off(imx8qm_ldb_ch->phy);\n\t\tif (ret)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to power off PHY: %d\\n\", ret);\n\t}\n\n\tclk_disable_unprepare(imx8qm_ldb->clk_bypass);\n\tclk_disable_unprepare(imx8qm_ldb->clk_pixel);\n\n\tret = pm_runtime_put(dev);\n\tif (ret < 0)\n\t\tDRM_DEV_ERROR(dev, \"failed to put runtime PM: %d\\n\", ret);\n}\n\nstatic const u32 imx8qm_ldb_bus_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB666_1X7X3_SPWG,\n\tMEDIA_BUS_FMT_RGB888_1X7X4_SPWG,\n\tMEDIA_BUS_FMT_RGB888_1X7X4_JEIDA,\n\tMEDIA_BUS_FMT_FIXED,\n};\n\nstatic bool imx8qm_ldb_bus_output_fmt_supported(u32 fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx8qm_ldb_bus_output_fmts); i++) {\n\t\tif (imx8qm_ldb_bus_output_fmts[i] == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nimx8qm_ldb_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t\t    u32 output_fmt,\n\t\t\t\t\t    unsigned int *num_input_fmts)\n{\n\tstruct drm_display_info *di;\n\tconst struct drm_format_info *finfo;\n\tu32 *input_fmts;\n\n\tif (!imx8qm_ldb_bus_output_fmt_supported(output_fmt))\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tswitch (output_fmt) {\n\tcase MEDIA_BUS_FMT_FIXED:\n\t\tdi = &conn_state->connector->display_info;\n\n\t\t \n\t\tif (di->num_bus_formats) {\n\t\t\tfinfo = drm_format_info(di->bus_formats[0]);\n\n\t\t\tinput_fmts[0] = finfo->depth == 18 ?\n\t\t\t\t\tMEDIA_BUS_FMT_RGB666_1X36_CPADLO :\n\t\t\t\t\tMEDIA_BUS_FMT_RGB888_1X36_CPADLO;\n\t\t} else {\n\t\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X36_CPADLO;\n\t\t}\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB666_1X36_CPADLO;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X36_CPADLO;\n\t\tbreak;\n\tdefault:\n\t\tkfree(input_fmts);\n\t\tinput_fmts = NULL;\n\t\tbreak;\n\t}\n\n\treturn input_fmts;\n}\n\nstatic u32 *\nimx8qm_ldb_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t     unsigned int *num_output_fmts)\n{\n\t*num_output_fmts = ARRAY_SIZE(imx8qm_ldb_bus_output_fmts);\n\treturn kmemdup(imx8qm_ldb_bus_output_fmts,\n\t\t\tsizeof(imx8qm_ldb_bus_output_fmts), GFP_KERNEL);\n}\n\nstatic enum drm_mode_status\nimx8qm_ldb_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t     const struct drm_display_info *info,\n\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tbool is_single = ldb_channel_is_single_link(ldb_ch);\n\n\tif (mode->clock > 300000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->clock > 150000 && is_single)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs imx8qm_ldb_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.mode_valid\t\t= imx8qm_ldb_bridge_mode_valid,\n\t.attach\t\t\t= ldb_bridge_attach_helper,\n\t.atomic_check\t\t= imx8qm_ldb_bridge_atomic_check,\n\t.mode_set\t\t= imx8qm_ldb_bridge_mode_set,\n\t.atomic_enable\t\t= imx8qm_ldb_bridge_atomic_enable,\n\t.atomic_disable\t\t= imx8qm_ldb_bridge_atomic_disable,\n\t.atomic_get_input_bus_fmts =\n\t\t\timx8qm_ldb_bridge_atomic_get_input_bus_fmts,\n\t.atomic_get_output_bus_fmts =\n\t\t\timx8qm_ldb_bridge_atomic_get_output_bus_fmts,\n};\n\nstatic int imx8qm_ldb_get_phy(struct imx8qm_ldb *imx8qm_ldb)\n{\n\tstruct imx8qm_ldb_channel *imx8qm_ldb_ch;\n\tstruct ldb_channel *ldb_ch;\n\tstruct device *dev = imx8qm_ldb->dev;\n\tint i, ret;\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++) {\n\t\timx8qm_ldb_ch = &imx8qm_ldb->channel[i];\n\t\tldb_ch = &imx8qm_ldb_ch->base;\n\n\t\tif (!ldb_ch->is_available)\n\t\t\tcontinue;\n\n\t\timx8qm_ldb_ch->phy = devm_of_phy_get(dev, ldb_ch->np,\n\t\t\t\t\t\t     \"lvds_phy\");\n\t\tif (IS_ERR(imx8qm_ldb_ch->phy)) {\n\t\t\tret = PTR_ERR(imx8qm_ldb_ch->phy);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\t      \"failed to get channel%d PHY: %d\\n\",\n\t\t\t\t\t      i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx8qm_ldb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct imx8qm_ldb *imx8qm_ldb;\n\tstruct imx8qm_ldb_channel *imx8qm_ldb_ch;\n\tstruct ldb *ldb;\n\tstruct ldb_channel *ldb_ch;\n\tstruct device_node *port1, *port2;\n\tint pixel_order;\n\tint ret, i;\n\n\timx8qm_ldb = devm_kzalloc(dev, sizeof(*imx8qm_ldb), GFP_KERNEL);\n\tif (!imx8qm_ldb)\n\t\treturn -ENOMEM;\n\n\timx8qm_ldb->clk_pixel = devm_clk_get(dev, \"pixel\");\n\tif (IS_ERR(imx8qm_ldb->clk_pixel)) {\n\t\tret = PTR_ERR(imx8qm_ldb->clk_pixel);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to get pixel clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\timx8qm_ldb->clk_bypass = devm_clk_get(dev, \"bypass\");\n\tif (IS_ERR(imx8qm_ldb->clk_bypass)) {\n\t\tret = PTR_ERR(imx8qm_ldb->clk_bypass);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"failed to get bypass clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\timx8qm_ldb->dev = dev;\n\n\tldb = &imx8qm_ldb->base;\n\tldb->dev = dev;\n\tldb->ctrl_reg = 0xe0;\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++)\n\t\tldb->channel[i] = &imx8qm_ldb->channel[i].base;\n\n\tret = ldb_init_helper(ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ldb->available_ch_cnt == 0) {\n\t\tDRM_DEV_DEBUG_DRIVER(dev, \"no available channel\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ldb->available_ch_cnt == 2) {\n\t\tport1 = of_graph_get_port_by_id(ldb->channel[0]->np, 1);\n\t\tport2 = of_graph_get_port_by_id(ldb->channel[1]->np, 1);\n\t\tpixel_order =\n\t\t\tdrm_of_lvds_get_dual_link_pixel_order(port1, port2);\n\t\tof_node_put(port1);\n\t\tof_node_put(port2);\n\n\t\tif (pixel_order != DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS) {\n\t\t\tDRM_DEV_ERROR(dev, \"invalid dual link pixel order: %d\\n\",\n\t\t\t\t      pixel_order);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\timx8qm_ldb->active_chno = 0;\n\t\timx8qm_ldb_ch = &imx8qm_ldb->channel[0];\n\t\tldb_ch = &imx8qm_ldb_ch->base;\n\t\tldb_ch->link_type = pixel_order;\n\t} else {\n\t\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++) {\n\t\t\timx8qm_ldb_ch = &imx8qm_ldb->channel[i];\n\t\t\tldb_ch = &imx8qm_ldb_ch->base;\n\n\t\t\tif (ldb_ch->is_available) {\n\t\t\t\timx8qm_ldb->active_chno = ldb_ch->chno;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = imx8qm_ldb_get_phy(imx8qm_ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ldb_find_next_bridge_helper(ldb);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, imx8qm_ldb);\n\tpm_runtime_enable(dev);\n\n\tldb_add_bridge_helper(ldb, &imx8qm_ldb_bridge_funcs);\n\n\treturn ret;\n}\n\nstatic void imx8qm_ldb_remove(struct platform_device *pdev)\n{\n\tstruct imx8qm_ldb *imx8qm_ldb = platform_get_drvdata(pdev);\n\tstruct ldb *ldb = &imx8qm_ldb->base;\n\n\tldb_remove_bridge_helper(ldb);\n\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused imx8qm_ldb_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int __maybe_unused imx8qm_ldb_runtime_resume(struct device *dev)\n{\n\tstruct imx8qm_ldb *imx8qm_ldb = dev_get_drvdata(dev);\n\tstruct ldb *ldb = &imx8qm_ldb->base;\n\n\t \n\tregmap_write(ldb->regmap, ldb->ctrl_reg, 0);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops imx8qm_ldb_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx8qm_ldb_runtime_suspend,\n\t\t\t   imx8qm_ldb_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id imx8qm_ldb_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qm-ldb\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8qm_ldb_dt_ids);\n\nstatic struct platform_driver imx8qm_ldb_driver = {\n\t.probe\t= imx8qm_ldb_probe,\n\t.remove_new = imx8qm_ldb_remove,\n\t.driver\t= {\n\t\t.pm = &imx8qm_ldb_pm_ops,\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = imx8qm_ldb_dt_ids,\n\t},\n};\nmodule_platform_driver(imx8qm_ldb_driver);\n\nMODULE_DESCRIPTION(\"i.MX8QM LVDS Display Bridge(LDB)/Pixel Mapper bridge driver\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}