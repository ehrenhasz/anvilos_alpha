{
  "module_name": "imx8qxp-pixel-link.c",
  "hash_id": "0b1a431c4164e9f4b7f9ecbca046d6c2fbaeb291d59101896455978de97db911",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/imx/imx8qxp-pixel-link.c",
  "human_readable_source": "\n\n \n\n#include <linux/firmware/imx/svc/misc.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_print.h>\n\n#include <dt-bindings/firmware/imx/rsrc.h>\n\n#define DRIVER_NAME\t\t\"imx8qxp-display-pixel-link\"\n#define PL_MAX_MST_ADDR\t\t3\n#define PL_MAX_NEXT_BRIDGES\t2\n\nstruct imx8qxp_pixel_link {\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct device *dev;\n\tstruct imx_sc_ipc *ipc_handle;\n\tu8 stream_id;\n\tu8 dc_id;\n\tu32 sink_rsc;\n\tu32 mst_addr;\n\tu8 mst_addr_ctrl;\n\tu8 mst_en_ctrl;\n\tu8 mst_vld_ctrl;\n\tu8 sync_ctrl;\n};\n\nstatic void imx8qxp_pixel_link_enable_mst_en(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle, pl->sink_rsc,\n\t\t\t\t      pl->mst_en_ctrl, true);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to enable DC%u stream%u pixel link mst_en: %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, ret);\n}\n\nstatic void imx8qxp_pixel_link_enable_mst_vld(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle, pl->sink_rsc,\n\t\t\t\t      pl->mst_vld_ctrl, true);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to enable DC%u stream%u pixel link mst_vld: %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, ret);\n}\n\nstatic void imx8qxp_pixel_link_enable_sync(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle, pl->sink_rsc,\n\t\t\t\t      pl->sync_ctrl, true);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to enable DC%u stream%u pixel link sync: %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, ret);\n}\n\nstatic int imx8qxp_pixel_link_disable_mst_en(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle, pl->sink_rsc,\n\t\t\t\t      pl->mst_en_ctrl, false);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to disable DC%u stream%u pixel link mst_en: %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, ret);\n\n\treturn ret;\n}\n\nstatic int imx8qxp_pixel_link_disable_mst_vld(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle, pl->sink_rsc,\n\t\t\t\t      pl->mst_vld_ctrl, false);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to disable DC%u stream%u pixel link mst_vld: %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, ret);\n\n\treturn ret;\n}\n\nstatic int imx8qxp_pixel_link_disable_sync(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle, pl->sink_rsc,\n\t\t\t\t      pl->sync_ctrl, false);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to disable DC%u stream%u pixel link sync: %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, ret);\n\n\treturn ret;\n}\n\nstatic void imx8qxp_pixel_link_set_mst_addr(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx_sc_misc_set_control(pl->ipc_handle,\n\t\t\t\t      pl->sink_rsc, pl->mst_addr_ctrl,\n\t\t\t\t      pl->mst_addr);\n\tif (ret)\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"failed to set DC%u stream%u pixel link mst addr(%u): %d\\n\",\n\t\t\t      pl->dc_id, pl->stream_id, pl->mst_addr, ret);\n}\n\nstatic int imx8qxp_pixel_link_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct imx8qxp_pixel_link *pl = bridge->driver_private;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tDRM_DEV_ERROR(pl->dev,\n\t\t\t      \"do not support creating a drm_connector\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_DEV_ERROR(pl->dev, \"missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder,\n\t\t\t\t pl->next_bridge, bridge,\n\t\t\t\t DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n}\n\nstatic void\nimx8qxp_pixel_link_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   const struct drm_display_mode *adjusted_mode)\n{\n\tstruct imx8qxp_pixel_link *pl = bridge->driver_private;\n\n\timx8qxp_pixel_link_set_mst_addr(pl);\n}\n\nstatic void\nimx8qxp_pixel_link_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct imx8qxp_pixel_link *pl = bridge->driver_private;\n\n\timx8qxp_pixel_link_enable_mst_en(pl);\n\timx8qxp_pixel_link_enable_mst_vld(pl);\n\timx8qxp_pixel_link_enable_sync(pl);\n}\n\nstatic void\nimx8qxp_pixel_link_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct imx8qxp_pixel_link *pl = bridge->driver_private;\n\n\timx8qxp_pixel_link_disable_mst_en(pl);\n\timx8qxp_pixel_link_disable_mst_vld(pl);\n\timx8qxp_pixel_link_disable_sync(pl);\n}\n\nstatic const u32 imx8qxp_pixel_link_bus_output_fmts[] = {\n\tMEDIA_BUS_FMT_RGB888_1X36_CPADLO,\n\tMEDIA_BUS_FMT_RGB666_1X36_CPADLO,\n};\n\nstatic bool imx8qxp_pixel_link_bus_output_fmt_supported(u32 fmt)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(imx8qxp_pixel_link_bus_output_fmts); i++) {\n\t\tif (imx8qxp_pixel_link_bus_output_fmts[i] == fmt)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u32 *\nimx8qxp_pixel_link_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t    struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t\t\t    u32 output_fmt,\n\t\t\t\t\t\t    unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\tif (!imx8qxp_pixel_link_bus_output_fmt_supported(output_fmt))\n\t\treturn NULL;\n\n\t*num_input_fmts = 1;\n\n\tinput_fmts = kmalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tinput_fmts[0] = output_fmt;\n\n\treturn input_fmts;\n}\n\nstatic u32 *\nimx8qxp_pixel_link_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t\t     unsigned int *num_output_fmts)\n{\n\t*num_output_fmts = ARRAY_SIZE(imx8qxp_pixel_link_bus_output_fmts);\n\treturn kmemdup(imx8qxp_pixel_link_bus_output_fmts,\n\t\t\tsizeof(imx8qxp_pixel_link_bus_output_fmts), GFP_KERNEL);\n}\n\nstatic const struct drm_bridge_funcs imx8qxp_pixel_link_bridge_funcs = {\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.attach\t\t\t= imx8qxp_pixel_link_bridge_attach,\n\t.mode_set\t\t= imx8qxp_pixel_link_bridge_mode_set,\n\t.atomic_enable\t\t= imx8qxp_pixel_link_bridge_atomic_enable,\n\t.atomic_disable\t\t= imx8qxp_pixel_link_bridge_atomic_disable,\n\t.atomic_get_input_bus_fmts =\n\t\t\timx8qxp_pixel_link_bridge_atomic_get_input_bus_fmts,\n\t.atomic_get_output_bus_fmts =\n\t\t\timx8qxp_pixel_link_bridge_atomic_get_output_bus_fmts,\n};\n\nstatic int imx8qxp_pixel_link_disable_all_controls(struct imx8qxp_pixel_link *pl)\n{\n\tint ret;\n\n\tret = imx8qxp_pixel_link_disable_mst_en(pl);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx8qxp_pixel_link_disable_mst_vld(pl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn imx8qxp_pixel_link_disable_sync(pl);\n}\n\nstatic struct drm_bridge *\nimx8qxp_pixel_link_find_next_bridge(struct imx8qxp_pixel_link *pl)\n{\n\tstruct device_node *np = pl->dev->of_node;\n\tstruct device_node *port, *remote;\n\tstruct drm_bridge *next_bridge[PL_MAX_NEXT_BRIDGES];\n\tu32 port_id;\n\tbool found_port = false;\n\tint reg, ep_cnt = 0;\n\t \n\tint bridge_sel = 0;\n\n\tfor (port_id = 1; port_id <= PL_MAX_MST_ADDR + 1; port_id++) {\n\t\tport = of_graph_get_port_by_id(np, port_id);\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tif (of_device_is_available(port)) {\n\t\t\tfound_port = true;\n\t\t\tof_node_put(port);\n\t\t\tbreak;\n\t\t}\n\n\t\tof_node_put(port);\n\t}\n\n\tif (!found_port) {\n\t\tDRM_DEV_ERROR(pl->dev, \"no available output port\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tfor (reg = 0; reg < PL_MAX_NEXT_BRIDGES; reg++) {\n\t\tremote = of_graph_get_remote_node(np, port_id, reg);\n\t\tif (!remote)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(remote->parent)) {\n\t\t\tDRM_DEV_DEBUG(pl->dev,\n\t\t\t\t      \"port%u endpoint%u remote parent is not available\\n\",\n\t\t\t\t      port_id, reg);\n\t\t\tof_node_put(remote);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnext_bridge[ep_cnt] = of_drm_find_bridge(remote);\n\t\tif (!next_bridge[ep_cnt]) {\n\t\t\tof_node_put(remote);\n\t\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t\t}\n\n\t\t \n\t\tif (of_property_present(remote, \"fsl,companion-pxl2dpi\"))\n\t\t\tbridge_sel = ep_cnt;\n\n\t\tep_cnt++;\n\n\t\tof_node_put(remote);\n\t}\n\n\tpl->mst_addr = port_id - 1;\n\n\treturn next_bridge[bridge_sel];\n}\n\nstatic int imx8qxp_pixel_link_bridge_probe(struct platform_device *pdev)\n{\n\tstruct imx8qxp_pixel_link *pl;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tpl = devm_kzalloc(dev, sizeof(*pl), GFP_KERNEL);\n\tif (!pl)\n\t\treturn -ENOMEM;\n\n\tret = imx_scu_get_handle(&pl->ipc_handle);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get SCU ipc handle: %d\\n\",\n\t\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u8(np, \"fsl,dc-id\", &pl->dc_id);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get DC index: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u8(np, \"fsl,dc-stream-id\", &pl->stream_id);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"failed to get DC stream index: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpl->dev = dev;\n\n\tpl->sink_rsc = pl->dc_id ? IMX_SC_R_DC_1 : IMX_SC_R_DC_0;\n\n\tif (pl->stream_id == 0) {\n\t\tpl->mst_addr_ctrl = IMX_SC_C_PXL_LINK_MST1_ADDR;\n\t\tpl->mst_en_ctrl   = IMX_SC_C_PXL_LINK_MST1_ENB;\n\t\tpl->mst_vld_ctrl  = IMX_SC_C_PXL_LINK_MST1_VLD;\n\t\tpl->sync_ctrl     = IMX_SC_C_SYNC_CTRL0;\n\t} else {\n\t\tpl->mst_addr_ctrl = IMX_SC_C_PXL_LINK_MST2_ADDR;\n\t\tpl->mst_en_ctrl   = IMX_SC_C_PXL_LINK_MST2_ENB;\n\t\tpl->mst_vld_ctrl  = IMX_SC_C_PXL_LINK_MST2_VLD;\n\t\tpl->sync_ctrl     = IMX_SC_C_SYNC_CTRL1;\n\t}\n\n\t \n\tret = imx8qxp_pixel_link_disable_all_controls(pl);\n\tif (ret)\n\t\treturn ret;\n\n\tpl->next_bridge = imx8qxp_pixel_link_find_next_bridge(pl);\n\tif (IS_ERR(pl->next_bridge)) {\n\t\tret = PTR_ERR(pl->next_bridge);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to find next bridge: %d\\n\",\n\t\t\t\t      ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, pl);\n\n\tpl->bridge.driver_private = pl;\n\tpl->bridge.funcs = &imx8qxp_pixel_link_bridge_funcs;\n\tpl->bridge.of_node = np;\n\n\tdrm_bridge_add(&pl->bridge);\n\n\treturn ret;\n}\n\nstatic void imx8qxp_pixel_link_bridge_remove(struct platform_device *pdev)\n{\n\tstruct imx8qxp_pixel_link *pl = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&pl->bridge);\n}\n\nstatic const struct of_device_id imx8qxp_pixel_link_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qm-dc-pixel-link\", },\n\t{ .compatible = \"fsl,imx8qxp-dc-pixel-link\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx8qxp_pixel_link_dt_ids);\n\nstatic struct platform_driver imx8qxp_pixel_link_bridge_driver = {\n\t.probe\t= imx8qxp_pixel_link_bridge_probe,\n\t.remove_new = imx8qxp_pixel_link_bridge_remove,\n\t.driver\t= {\n\t\t.of_match_table = imx8qxp_pixel_link_dt_ids,\n\t\t.name = DRIVER_NAME,\n\t},\n};\nmodule_platform_driver(imx8qxp_pixel_link_bridge_driver);\n\nMODULE_DESCRIPTION(\"i.MX8QXP/QM display pixel link bridge driver\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}