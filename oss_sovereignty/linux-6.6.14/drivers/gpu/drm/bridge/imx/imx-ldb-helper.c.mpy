{
  "module_name": "imx-ldb-helper.c",
  "hash_id": "ca87752612caa79453824af563cb81b7746bd241abae19d0b699185c4f1a3b6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/imx/imx-ldb-helper.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/media-bus-format.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#include \"imx-ldb-helper.h\"\n\nbool ldb_channel_is_single_link(struct ldb_channel *ldb_ch)\n{\n\treturn ldb_ch->link_type == LDB_CH_SINGLE_LINK;\n}\nEXPORT_SYMBOL_GPL(ldb_channel_is_single_link);\n\nbool ldb_channel_is_split_link(struct ldb_channel *ldb_ch)\n{\n\treturn ldb_ch->link_type == LDB_CH_DUAL_LINK_EVEN_ODD_PIXELS ||\n\t       ldb_ch->link_type == LDB_CH_DUAL_LINK_ODD_EVEN_PIXELS;\n}\nEXPORT_SYMBOL_GPL(ldb_channel_is_split_link);\n\nint ldb_bridge_atomic_check_helper(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_bridge_state *bridge_state,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\n\tldb_ch->in_bus_format = bridge_state->input_bus_cfg.format;\n\tldb_ch->out_bus_format = bridge_state->output_bus_cfg.format;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ldb_bridge_atomic_check_helper);\n\nvoid ldb_bridge_mode_set_helper(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\n\tif (is_split)\n\t\tldb->ldb_ctrl |= LDB_SPLIT_MODE_EN;\n\n\tswitch (ldb_ch->out_bus_format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tif (ldb_ch->chno == 0 || is_split)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24;\n\t\tif (ldb_ch->chno == 1 || is_split)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tif (ldb_ch->chno == 0 || is_split)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH0_24 |\n\t\t\t\t\t LDB_BIT_MAP_CH0_JEIDA;\n\t\tif (ldb_ch->chno == 1 || is_split)\n\t\t\tldb->ldb_ctrl |= LDB_DATA_WIDTH_CH1_24 |\n\t\t\t\t\t LDB_BIT_MAP_CH1_JEIDA;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(ldb_bridge_mode_set_helper);\n\nvoid ldb_bridge_enable_helper(struct drm_bridge *bridge)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\n\t \n\tregmap_write(ldb->regmap, ldb->ctrl_reg, ldb->ldb_ctrl);\n}\nEXPORT_SYMBOL_GPL(ldb_bridge_enable_helper);\n\nvoid ldb_bridge_disable_helper(struct drm_bridge *bridge)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\tbool is_split = ldb_channel_is_split_link(ldb_ch);\n\n\tif (ldb_ch->chno == 0 || is_split)\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\tif (ldb_ch->chno == 1 || is_split)\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\n\tregmap_write(ldb->regmap, ldb->ctrl_reg, ldb->ldb_ctrl);\n}\nEXPORT_SYMBOL_GPL(ldb_bridge_disable_helper);\n\nint ldb_bridge_attach_helper(struct drm_bridge *bridge,\n\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct ldb_channel *ldb_ch = bridge->driver_private;\n\tstruct ldb *ldb = ldb_ch->ldb;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tDRM_DEV_ERROR(ldb->dev,\n\t\t\t      \"do not support creating a drm_connector\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!bridge->encoder) {\n\t\tDRM_DEV_ERROR(ldb->dev, \"missing encoder\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder,\n\t\t\t\tldb_ch->next_bridge, bridge,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n}\nEXPORT_SYMBOL_GPL(ldb_bridge_attach_helper);\n\nint ldb_init_helper(struct ldb *ldb)\n{\n\tstruct device *dev = ldb->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint ret;\n\tu32 i;\n\n\tldb->regmap = syscon_node_to_regmap(np->parent);\n\tif (IS_ERR(ldb->regmap)) {\n\t\tret = PTR_ERR(ldb->regmap);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tDRM_DEV_ERROR(dev, \"failed to get regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct ldb_channel *ldb_ch;\n\n\t\tret = of_property_read_u32(child, \"reg\", &i);\n\t\tif (ret || i > MAX_LDB_CHAN_NUM - 1) {\n\t\t\tret = -EINVAL;\n\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t      \"invalid channel node address: %u\\n\", i);\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tldb_ch = ldb->channel[i];\n\t\tldb_ch->ldb = ldb;\n\t\tldb_ch->chno = i;\n\t\tldb_ch->is_available = true;\n\t\tldb_ch->np = child;\n\n\t\tldb->available_ch_cnt++;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ldb_init_helper);\n\nint ldb_find_next_bridge_helper(struct ldb *ldb)\n{\n\tstruct device *dev = ldb->dev;\n\tstruct ldb_channel *ldb_ch;\n\tint ret, i;\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++) {\n\t\tldb_ch = ldb->channel[i];\n\n\t\tif (!ldb_ch->is_available)\n\t\t\tcontinue;\n\n\t\tldb_ch->next_bridge = devm_drm_of_get_bridge(dev, ldb_ch->np,\n\t\t\t\t\t\t\t     1, 0);\n\t\tif (IS_ERR(ldb_ch->next_bridge)) {\n\t\t\tret = PTR_ERR(ldb_ch->next_bridge);\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tDRM_DEV_ERROR(dev,\n\t\t\t\t\t      \"failed to get next bridge: %d\\n\",\n\t\t\t\t\t      ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ldb_find_next_bridge_helper);\n\nvoid ldb_add_bridge_helper(struct ldb *ldb,\n\t\t\t   const struct drm_bridge_funcs *bridge_funcs)\n{\n\tstruct ldb_channel *ldb_ch;\n\tint i;\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++) {\n\t\tldb_ch = ldb->channel[i];\n\n\t\tif (!ldb_ch->is_available)\n\t\t\tcontinue;\n\n\t\tldb_ch->bridge.driver_private = ldb_ch;\n\t\tldb_ch->bridge.funcs = bridge_funcs;\n\t\tldb_ch->bridge.of_node = ldb_ch->np;\n\n\t\tdrm_bridge_add(&ldb_ch->bridge);\n\t}\n}\nEXPORT_SYMBOL_GPL(ldb_add_bridge_helper);\n\nvoid ldb_remove_bridge_helper(struct ldb *ldb)\n{\n\tstruct ldb_channel *ldb_ch;\n\tint i;\n\n\tfor (i = 0; i < MAX_LDB_CHAN_NUM; i++) {\n\t\tldb_ch = ldb->channel[i];\n\n\t\tif (!ldb_ch->is_available)\n\t\t\tcontinue;\n\n\t\tdrm_bridge_remove(&ldb_ch->bridge);\n\t}\n}\nEXPORT_SYMBOL_GPL(ldb_remove_bridge_helper);\n\nMODULE_DESCRIPTION(\"i.MX8 LVDS Display Bridge(LDB)/Pixel Mapper bridge helper\");\nMODULE_AUTHOR(\"Liu Ying <victor.liu@nxp.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}