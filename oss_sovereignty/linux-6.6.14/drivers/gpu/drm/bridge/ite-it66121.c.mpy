{
  "module_name": "ite-it66121.c",
  "hash_id": "7f032c14cee38fdbacca191ad1fcae138218e884f13288e0a4d3cd2a176bf3b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ite-it66121.c",
  "human_readable_source": "\n \n\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/bitfield.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/of_graph.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#include <sound/hdmi-codec.h>\n\n#define IT66121_VENDOR_ID0_REG\t\t\t0x00\n#define IT66121_VENDOR_ID1_REG\t\t\t0x01\n#define IT66121_DEVICE_ID0_REG\t\t\t0x02\n#define IT66121_DEVICE_ID1_REG\t\t\t0x03\n\n#define IT66121_REVISION_MASK\t\t\tGENMASK(7, 4)\n#define IT66121_DEVICE_ID1_MASK\t\t\tGENMASK(3, 0)\n\n#define IT66121_MASTER_SEL_REG\t\t\t0x10\n#define IT66121_MASTER_SEL_HOST\t\t\tBIT(0)\n\n#define IT66121_AFE_DRV_REG\t\t\t0x61\n#define IT66121_AFE_DRV_RST\t\t\tBIT(4)\n#define IT66121_AFE_DRV_PWD\t\t\tBIT(5)\n\n#define IT66121_INPUT_MODE_REG\t\t\t0x70\n#define IT66121_INPUT_MODE_RGB\t\t\t(0 << 6)\n#define IT66121_INPUT_MODE_YUV422\t\tBIT(6)\n#define IT66121_INPUT_MODE_YUV444\t\t(2 << 6)\n#define IT66121_INPUT_MODE_CCIR656\t\tBIT(4)\n#define IT66121_INPUT_MODE_SYNCEMB\t\tBIT(3)\n#define IT66121_INPUT_MODE_DDR\t\t\tBIT(2)\n\n#define IT66121_INPUT_CSC_REG\t\t\t0x72\n#define IT66121_INPUT_CSC_ENDITHER\t\tBIT(7)\n#define IT66121_INPUT_CSC_ENUDFILTER\t\tBIT(6)\n#define IT66121_INPUT_CSC_DNFREE_GO\t\tBIT(5)\n#define IT66121_INPUT_CSC_RGB_TO_YUV\t\t0x02\n#define IT66121_INPUT_CSC_YUV_TO_RGB\t\t0x03\n#define IT66121_INPUT_CSC_NO_CONV\t\t0x00\n\n#define IT66121_AFE_XP_REG\t\t\t0x62\n#define IT66121_AFE_XP_GAINBIT\t\t\tBIT(7)\n#define IT66121_AFE_XP_PWDPLL\t\t\tBIT(6)\n#define IT66121_AFE_XP_ENI\t\t\tBIT(5)\n#define IT66121_AFE_XP_ENO\t\t\tBIT(4)\n#define IT66121_AFE_XP_RESETB\t\t\tBIT(3)\n#define IT66121_AFE_XP_PWDI\t\t\tBIT(2)\n#define IT6610_AFE_XP_BYPASS\t\t\tBIT(0)\n\n#define IT66121_AFE_IP_REG\t\t\t0x64\n#define IT66121_AFE_IP_GAINBIT\t\t\tBIT(7)\n#define IT66121_AFE_IP_PWDPLL\t\t\tBIT(6)\n#define IT66121_AFE_IP_CKSEL_05\t\t\t(0 << 4)\n#define IT66121_AFE_IP_CKSEL_1\t\t\tBIT(4)\n#define IT66121_AFE_IP_CKSEL_2\t\t\t(2 << 4)\n#define IT66121_AFE_IP_CKSEL_2OR4\t\t(3 << 4)\n#define IT66121_AFE_IP_ER0\t\t\tBIT(3)\n#define IT66121_AFE_IP_RESETB\t\t\tBIT(2)\n#define IT66121_AFE_IP_ENC\t\t\tBIT(1)\n#define IT66121_AFE_IP_EC1\t\t\tBIT(0)\n\n#define IT66121_AFE_XP_EC1_REG\t\t\t0x68\n#define IT66121_AFE_XP_EC1_LOWCLK\t\tBIT(4)\n\n#define IT66121_SW_RST_REG\t\t\t0x04\n#define IT66121_SW_RST_REF\t\t\tBIT(5)\n#define IT66121_SW_RST_AREF\t\t\tBIT(4)\n#define IT66121_SW_RST_VID\t\t\tBIT(3)\n#define IT66121_SW_RST_AUD\t\t\tBIT(2)\n#define IT66121_SW_RST_HDCP\t\t\tBIT(0)\n\n#define IT66121_DDC_COMMAND_REG\t\t\t0x15\n#define IT66121_DDC_COMMAND_BURST_READ\t\t0x0\n#define IT66121_DDC_COMMAND_EDID_READ\t\t0x3\n#define IT66121_DDC_COMMAND_FIFO_CLR\t\t0x9\n#define IT66121_DDC_COMMAND_SCL_PULSE\t\t0xA\n#define IT66121_DDC_COMMAND_ABORT\t\t0xF\n\n#define IT66121_HDCP_REG\t\t\t0x20\n#define IT66121_HDCP_CPDESIRED\t\t\tBIT(0)\n#define IT66121_HDCP_EN1P1FEAT\t\t\tBIT(1)\n\n#define IT66121_INT_STATUS1_REG\t\t\t0x06\n#define IT66121_INT_STATUS1_AUD_OVF\t\tBIT(7)\n#define IT66121_INT_STATUS1_DDC_NOACK\t\tBIT(5)\n#define IT66121_INT_STATUS1_DDC_FIFOERR\t\tBIT(4)\n#define IT66121_INT_STATUS1_DDC_BUSHANG\t\tBIT(2)\n#define IT66121_INT_STATUS1_RX_SENS_STATUS\tBIT(1)\n#define IT66121_INT_STATUS1_HPD_STATUS\t\tBIT(0)\n\n#define IT66121_DDC_HEADER_REG\t\t\t0x11\n#define IT66121_DDC_HEADER_HDCP\t\t\t0x74\n#define IT66121_DDC_HEADER_EDID\t\t\t0xA0\n\n#define IT66121_DDC_OFFSET_REG\t\t\t0x12\n#define IT66121_DDC_BYTE_REG\t\t\t0x13\n#define IT66121_DDC_SEGMENT_REG\t\t\t0x14\n#define IT66121_DDC_RD_FIFO_REG\t\t\t0x17\n\n#define IT66121_CLK_BANK_REG\t\t\t0x0F\n#define IT66121_CLK_BANK_PWROFF_RCLK\t\tBIT(6)\n#define IT66121_CLK_BANK_PWROFF_ACLK\t\tBIT(5)\n#define IT66121_CLK_BANK_PWROFF_TXCLK\t\tBIT(4)\n#define IT66121_CLK_BANK_PWROFF_CRCLK\t\tBIT(3)\n#define IT66121_CLK_BANK_0\t\t\t0\n#define IT66121_CLK_BANK_1\t\t\t1\n\n#define IT66121_INT_REG\t\t\t\t0x05\n#define IT66121_INT_ACTIVE_HIGH\t\t\tBIT(7)\n#define IT66121_INT_OPEN_DRAIN\t\t\tBIT(6)\n#define IT66121_INT_TX_CLK_OFF\t\t\tBIT(0)\n\n#define IT66121_INT_MASK1_REG\t\t\t0x09\n#define IT66121_INT_MASK1_AUD_OVF\t\tBIT(7)\n#define IT66121_INT_MASK1_DDC_NOACK\t\tBIT(5)\n#define IT66121_INT_MASK1_DDC_FIFOERR\t\tBIT(4)\n#define IT66121_INT_MASK1_DDC_BUSHANG\t\tBIT(2)\n#define IT66121_INT_MASK1_RX_SENS\t\tBIT(1)\n#define IT66121_INT_MASK1_HPD\t\t\tBIT(0)\n\n#define IT66121_INT_CLR1_REG\t\t\t0x0C\n#define IT66121_INT_CLR1_PKTACP\t\t\tBIT(7)\n#define IT66121_INT_CLR1_PKTNULL\t\tBIT(6)\n#define IT66121_INT_CLR1_PKTGEN\t\t\tBIT(5)\n#define IT66121_INT_CLR1_KSVLISTCHK\t\tBIT(4)\n#define IT66121_INT_CLR1_AUTHDONE\t\tBIT(3)\n#define IT66121_INT_CLR1_AUTHFAIL\t\tBIT(2)\n#define IT66121_INT_CLR1_RX_SENS\t\tBIT(1)\n#define IT66121_INT_CLR1_HPD\t\t\tBIT(0)\n\n#define IT66121_AV_MUTE_REG\t\t\t0xC1\n#define IT66121_AV_MUTE_ON\t\t\tBIT(0)\n#define IT66121_AV_MUTE_BLUESCR\t\t\tBIT(1)\n\n#define IT66121_PKT_CTS_CTRL_REG\t\t0xC5\n#define IT66121_PKT_CTS_CTRL_SEL\t\tBIT(1)\n\n#define IT66121_PKT_GEN_CTRL_REG\t\t0xC6\n#define IT66121_PKT_GEN_CTRL_ON\t\t\tBIT(0)\n#define IT66121_PKT_GEN_CTRL_RPT\t\tBIT(1)\n\n#define IT66121_AVIINFO_DB1_REG\t\t\t0x158\n#define IT66121_AVIINFO_DB2_REG\t\t\t0x159\n#define IT66121_AVIINFO_DB3_REG\t\t\t0x15A\n#define IT66121_AVIINFO_DB4_REG\t\t\t0x15B\n#define IT66121_AVIINFO_DB5_REG\t\t\t0x15C\n#define IT66121_AVIINFO_CSUM_REG\t\t0x15D\n#define IT66121_AVIINFO_DB6_REG\t\t\t0x15E\n#define IT66121_AVIINFO_DB7_REG\t\t\t0x15F\n#define IT66121_AVIINFO_DB8_REG\t\t\t0x160\n#define IT66121_AVIINFO_DB9_REG\t\t\t0x161\n#define IT66121_AVIINFO_DB10_REG\t\t0x162\n#define IT66121_AVIINFO_DB11_REG\t\t0x163\n#define IT66121_AVIINFO_DB12_REG\t\t0x164\n#define IT66121_AVIINFO_DB13_REG\t\t0x165\n\n#define IT66121_AVI_INFO_PKT_REG\t\t0xCD\n#define IT66121_AVI_INFO_PKT_ON\t\t\tBIT(0)\n#define IT66121_AVI_INFO_PKT_RPT\t\tBIT(1)\n\n#define IT66121_HDMI_MODE_REG\t\t\t0xC0\n#define IT66121_HDMI_MODE_HDMI\t\t\tBIT(0)\n\n#define IT66121_SYS_STATUS_REG\t\t\t0x0E\n#define IT66121_SYS_STATUS_ACTIVE_IRQ\t\tBIT(7)\n#define IT66121_SYS_STATUS_HPDETECT\t\tBIT(6)\n#define IT66121_SYS_STATUS_SENDECTECT\t\tBIT(5)\n#define IT66121_SYS_STATUS_VID_STABLE\t\tBIT(4)\n#define IT66121_SYS_STATUS_AUD_CTS_CLR\t\tBIT(1)\n#define IT66121_SYS_STATUS_CLEAR_IRQ\t\tBIT(0)\n\n#define IT66121_DDC_STATUS_REG\t\t\t0x16\n#define IT66121_DDC_STATUS_TX_DONE\t\tBIT(7)\n#define IT66121_DDC_STATUS_ACTIVE\t\tBIT(6)\n#define IT66121_DDC_STATUS_NOACK\t\tBIT(5)\n#define IT66121_DDC_STATUS_WAIT_BUS\t\tBIT(4)\n#define IT66121_DDC_STATUS_ARBI_LOSE\t\tBIT(3)\n#define IT66121_DDC_STATUS_FIFO_FULL\t\tBIT(2)\n#define IT66121_DDC_STATUS_FIFO_EMPTY\t\tBIT(1)\n#define IT66121_DDC_STATUS_FIFO_VALID\t\tBIT(0)\n\n#define IT66121_EDID_SLEEP_US\t\t\t20000\n#define IT66121_EDID_TIMEOUT_US\t\t\t200000\n#define IT66121_EDID_FIFO_SIZE\t\t\t32\n\n#define IT66121_CLK_CTRL0_REG\t\t\t0x58\n#define IT66121_CLK_CTRL0_AUTO_OVER_SAMPLING\tBIT(4)\n#define IT66121_CLK_CTRL0_EXT_MCLK_MASK\t\tGENMASK(3, 2)\n#define IT66121_CLK_CTRL0_EXT_MCLK_128FS\t(0 << 2)\n#define IT66121_CLK_CTRL0_EXT_MCLK_256FS\tBIT(2)\n#define IT66121_CLK_CTRL0_EXT_MCLK_512FS\t(2 << 2)\n#define IT66121_CLK_CTRL0_EXT_MCLK_1024FS\t(3 << 2)\n#define IT66121_CLK_CTRL0_AUTO_IPCLK\t\tBIT(0)\n#define IT66121_CLK_STATUS1_REG\t\t\t0x5E\n#define IT66121_CLK_STATUS2_REG\t\t\t0x5F\n\n#define IT66121_AUD_CTRL0_REG\t\t\t0xE0\n#define IT66121_AUD_SWL\t\t\t\t(3 << 6)\n#define IT66121_AUD_16BIT\t\t\t(0 << 6)\n#define IT66121_AUD_18BIT\t\t\tBIT(6)\n#define IT66121_AUD_20BIT\t\t\t(2 << 6)\n#define IT66121_AUD_24BIT\t\t\t(3 << 6)\n#define IT66121_AUD_SPDIFTC\t\t\tBIT(5)\n#define IT66121_AUD_SPDIF\t\t\tBIT(4)\n#define IT66121_AUD_I2S\t\t\t\t(0 << 4)\n#define IT66121_AUD_EN_I2S3\t\t\tBIT(3)\n#define IT66121_AUD_EN_I2S2\t\t\tBIT(2)\n#define IT66121_AUD_EN_I2S1\t\t\tBIT(1)\n#define IT66121_AUD_EN_I2S0\t\t\tBIT(0)\n#define IT66121_AUD_CTRL0_AUD_SEL\t\tBIT(4)\n\n#define IT66121_AUD_CTRL1_REG\t\t\t0xE1\n#define IT66121_AUD_FIFOMAP_REG\t\t\t0xE2\n#define IT66121_AUD_CTRL3_REG\t\t\t0xE3\n#define IT66121_AUD_SRCVALID_FLAT_REG\t\t0xE4\n#define IT66121_AUD_FLAT_SRC0\t\t\tBIT(4)\n#define IT66121_AUD_FLAT_SRC1\t\t\tBIT(5)\n#define IT66121_AUD_FLAT_SRC2\t\t\tBIT(6)\n#define IT66121_AUD_FLAT_SRC3\t\t\tBIT(7)\n#define IT66121_AUD_HDAUDIO_REG\t\t\t0xE5\n\n#define IT66121_AUD_PKT_CTS0_REG\t\t0x130\n#define IT66121_AUD_PKT_CTS1_REG\t\t0x131\n#define IT66121_AUD_PKT_CTS2_REG\t\t0x132\n#define IT66121_AUD_PKT_N0_REG\t\t\t0x133\n#define IT66121_AUD_PKT_N1_REG\t\t\t0x134\n#define IT66121_AUD_PKT_N2_REG\t\t\t0x135\n\n#define IT66121_AUD_CHST_MODE_REG\t\t0x191\n#define IT66121_AUD_CHST_CAT_REG\t\t0x192\n#define IT66121_AUD_CHST_SRCNUM_REG\t\t0x193\n#define IT66121_AUD_CHST_CHTNUM_REG\t\t0x194\n#define IT66121_AUD_CHST_CA_FS_REG\t\t0x198\n#define IT66121_AUD_CHST_OFS_WL_REG\t\t0x199\n\n#define IT66121_AUD_PKT_CTS_CNT0_REG\t\t0x1A0\n#define IT66121_AUD_PKT_CTS_CNT1_REG\t\t0x1A1\n#define IT66121_AUD_PKT_CTS_CNT2_REG\t\t0x1A2\n\n#define IT66121_AUD_FS_22P05K\t\t\t0x4\n#define IT66121_AUD_FS_44P1K\t\t\t0x0\n#define IT66121_AUD_FS_88P2K\t\t\t0x8\n#define IT66121_AUD_FS_176P4K\t\t\t0xC\n#define IT66121_AUD_FS_24K\t\t\t0x6\n#define IT66121_AUD_FS_48K\t\t\t0x2\n#define IT66121_AUD_FS_96K\t\t\t0xA\n#define IT66121_AUD_FS_192K\t\t\t0xE\n#define IT66121_AUD_FS_768K\t\t\t0x9\n#define IT66121_AUD_FS_32K\t\t\t0x3\n#define IT66121_AUD_FS_OTHER\t\t\t0x1\n\n#define IT66121_AUD_SWL_21BIT\t\t\t0xD\n#define IT66121_AUD_SWL_24BIT\t\t\t0xB\n#define IT66121_AUD_SWL_23BIT\t\t\t0x9\n#define IT66121_AUD_SWL_22BIT\t\t\t0x5\n#define IT66121_AUD_SWL_20BIT\t\t\t0x3\n#define IT66121_AUD_SWL_17BIT\t\t\t0xC\n#define IT66121_AUD_SWL_19BIT\t\t\t0x8\n#define IT66121_AUD_SWL_18BIT\t\t\t0x4\n#define IT66121_AUD_SWL_16BIT\t\t\t0x2\n#define IT66121_AUD_SWL_NOT_INDICATED\t\t0x0\n\n#define IT66121_AFE_CLK_HIGH\t\t\t80000  \n\nenum chip_id {\n\tID_IT6610,\n\tID_IT66121,\n};\n\nstruct it66121_chip_info {\n\tenum chip_id id;\n\tu16 vid, pid;\n};\n\nstruct it66121_ctx {\n\tstruct regmap *regmap;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\tstruct drm_connector *connector;\n\tstruct device *dev;\n\tstruct gpio_desc *gpio_reset;\n\tstruct i2c_client *client;\n\tu32 bus_width;\n\tstruct mutex lock;  \n\tstruct hdmi_avi_infoframe hdmi_avi_infoframe;\n\tstruct {\n\t\tstruct platform_device *pdev;\n\t\tu8 ch_enable;\n\t\tu8 fs;\n\t\tu8 swl;\n\t\tbool auto_cts;\n\t} audio;\n\tconst struct it66121_chip_info *info;\n};\n\nstatic const struct regmap_range_cfg it66121_regmap_banks[] = {\n\t{\n\t\t.name = \"it66121\",\n\t\t.range_min = 0x00,\n\t\t.range_max = 0x1FF,\n\t\t.selector_reg = IT66121_CLK_BANK_REG,\n\t\t.selector_mask = 0x1,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0x00,\n\t\t.window_len = 0x100,\n\t},\n};\n\nstatic const struct regmap_config it66121_regmap_config = {\n\t.val_bits = 8,\n\t.reg_bits = 8,\n\t.max_register = 0x1FF,\n\t.ranges = it66121_regmap_banks,\n\t.num_ranges = ARRAY_SIZE(it66121_regmap_banks),\n};\n\nstatic void it66121_hw_reset(struct it66121_ctx *ctx)\n{\n\tgpiod_set_value(ctx->gpio_reset, 1);\n\tmsleep(20);\n\tgpiod_set_value(ctx->gpio_reset, 0);\n}\n\nstatic inline int it66121_preamble_ddc(struct it66121_ctx *ctx)\n{\n\treturn regmap_write(ctx->regmap, IT66121_MASTER_SEL_REG, IT66121_MASTER_SEL_HOST);\n}\n\nstatic inline int it66121_fire_afe(struct it66121_ctx *ctx)\n{\n\treturn regmap_write(ctx->regmap, IT66121_AFE_DRV_REG, 0);\n}\n\n \nstatic int it66121_configure_input(struct it66121_ctx *ctx)\n{\n\tint ret;\n\tu8 mode = IT66121_INPUT_MODE_RGB;\n\n\tif (ctx->bus_width == 12)\n\t\tmode |= IT66121_INPUT_MODE_DDR;\n\n\tret = regmap_write(ctx->regmap, IT66121_INPUT_MODE_REG, mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ctx->regmap, IT66121_INPUT_CSC_REG, IT66121_INPUT_CSC_NO_CONV);\n}\n\n \nstatic int it66121_configure_afe(struct it66121_ctx *ctx,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tint ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AFE_DRV_REG,\n\t\t\t   IT66121_AFE_DRV_RST);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode->clock > IT66121_AFE_CLK_HIGH) {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_REG,\n\t\t\t\t\tIT66121_AFE_XP_GAINBIT |\n\t\t\t\t\tIT66121_AFE_XP_ENO,\n\t\t\t\t\tIT66121_AFE_XP_GAINBIT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_IP_REG,\n\t\t\t\t\tIT66121_AFE_IP_GAINBIT |\n\t\t\t\t\tIT66121_AFE_IP_ER0,\n\t\t\t\t\tIT66121_AFE_IP_GAINBIT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ctx->info->id == ID_IT66121) {\n\t\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_IP_REG,\n\t\t\t\t\t\tIT66121_AFE_IP_EC1, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_EC1_REG,\n\t\t\t\t\t\tIT66121_AFE_XP_EC1_LOWCLK, 0x80);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_REG,\n\t\t\t\t\tIT66121_AFE_XP_GAINBIT |\n\t\t\t\t\tIT66121_AFE_XP_ENO,\n\t\t\t\t\tIT66121_AFE_XP_ENO);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_IP_REG,\n\t\t\t\t\tIT66121_AFE_IP_GAINBIT |\n\t\t\t\t\tIT66121_AFE_IP_ER0,\n\t\t\t\t\tIT66121_AFE_IP_ER0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ctx->info->id == ID_IT66121) {\n\t\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_IP_REG,\n\t\t\t\t\t\tIT66121_AFE_IP_EC1,\n\t\t\t\t\t\tIT66121_AFE_IP_EC1);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_EC1_REG,\n\t\t\t\t\t\tIT66121_AFE_XP_EC1_LOWCLK,\n\t\t\t\t\t\tIT66121_AFE_XP_EC1_LOWCLK);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = regmap_write_bits(ctx->regmap, IT66121_SW_RST_REG,\n\t\t\t\tIT66121_SW_RST_REF | IT66121_SW_RST_VID, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->info->id == ID_IT6610) {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_REG,\n\t\t\t\t\tIT6610_AFE_XP_BYPASS,\n\t\t\t\t\tIT6610_AFE_XP_BYPASS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn it66121_fire_afe(ctx);\n}\n\nstatic inline int it66121_wait_ddc_ready(struct it66121_ctx *ctx)\n{\n\tint ret, val;\n\tu32 error = IT66121_DDC_STATUS_NOACK | IT66121_DDC_STATUS_WAIT_BUS |\n\t\t    IT66121_DDC_STATUS_ARBI_LOSE;\n\tu32 done = IT66121_DDC_STATUS_TX_DONE;\n\n\tret = regmap_read_poll_timeout(ctx->regmap, IT66121_DDC_STATUS_REG, val,\n\t\t\t\t       val & (error | done), IT66121_EDID_SLEEP_US,\n\t\t\t\t       IT66121_EDID_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & error)\n\t\treturn -EAGAIN;\n\n\treturn 0;\n}\n\nstatic int it66121_abort_ddc_ops(struct it66121_ctx *ctx)\n{\n\tint ret;\n\tunsigned int swreset, cpdesire;\n\n\tret = regmap_read(ctx->regmap, IT66121_SW_RST_REG, &swreset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(ctx->regmap, IT66121_HDCP_REG, &cpdesire);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_HDCP_REG,\n\t\t\t   cpdesire & (~IT66121_HDCP_CPDESIRED & 0xFF));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_SW_RST_REG,\n\t\t\t   (swreset | IT66121_SW_RST_HDCP));\n\tif (ret)\n\t\treturn ret;\n\n\tret = it66121_preamble_ddc(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_DDC_COMMAND_REG,\n\t\t\t   IT66121_DDC_COMMAND_ABORT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn it66121_wait_ddc_ready(ctx);\n}\n\nstatic int it66121_get_edid_block(void *context, u8 *buf,\n\t\t\t\t  unsigned int block, size_t len)\n{\n\tstruct it66121_ctx *ctx = context;\n\tint remain = len;\n\tint offset = 0;\n\tint ret, cnt;\n\n\toffset = (block % 2) * len;\n\tblock = block / 2;\n\n\twhile (remain > 0) {\n\t\tcnt = (remain > IT66121_EDID_FIFO_SIZE) ?\n\t\t\t\tIT66121_EDID_FIFO_SIZE : remain;\n\n\t\tret = regmap_write(ctx->regmap, IT66121_DDC_COMMAND_REG,\n\t\t\t\t   IT66121_DDC_COMMAND_FIFO_CLR);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = it66121_wait_ddc_ready(ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(ctx->regmap, IT66121_DDC_OFFSET_REG, offset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(ctx->regmap, IT66121_DDC_BYTE_REG, cnt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(ctx->regmap, IT66121_DDC_SEGMENT_REG, block);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(ctx->regmap, IT66121_DDC_COMMAND_REG,\n\t\t\t\t   IT66121_DDC_COMMAND_EDID_READ);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toffset += cnt;\n\t\tremain -= cnt;\n\n\t\tret = it66121_wait_ddc_ready(ctx);\n\t\tif (ret) {\n\t\t\tit66121_abort_ddc_ops(ctx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_noinc_read(ctx->regmap, IT66121_DDC_RD_FIFO_REG,\n\t\t\t\t\tbuf, cnt);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbuf += cnt;\n\t}\n\n\treturn 0;\n}\n\nstatic bool it66121_is_hpd_detect(struct it66121_ctx *ctx)\n{\n\tint val;\n\n\tif (regmap_read(ctx->regmap, IT66121_SYS_STATUS_REG, &val))\n\t\treturn false;\n\n\treturn val & IT66121_SYS_STATUS_HPDETECT;\n}\n\nstatic int it66121_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\tret = drm_bridge_attach(bridge->encoder, ctx->next_bridge, bridge, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->info->id == ID_IT66121) {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_CLK_BANK_REG,\n\t\t\t\t\tIT66121_CLK_BANK_PWROFF_RCLK, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_INT_REG,\n\t\t\t\tIT66121_INT_TX_CLK_OFF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_DRV_REG,\n\t\t\t\tIT66121_AFE_DRV_PWD, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_REG,\n\t\t\t\tIT66121_AFE_XP_PWDI | IT66121_AFE_XP_PWDPLL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_IP_REG,\n\t\t\t\tIT66121_AFE_IP_PWDPLL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_DRV_REG,\n\t\t\t\tIT66121_AFE_DRV_RST, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_XP_REG,\n\t\t\t\tIT66121_AFE_XP_RESETB, IT66121_AFE_XP_RESETB);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AFE_IP_REG,\n\t\t\t\tIT66121_AFE_IP_RESETB, IT66121_AFE_IP_RESETB);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_SW_RST_REG,\n\t\t\t\tIT66121_SW_RST_REF,\n\t\t\t\tIT66121_SW_RST_REF);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(50);\n\n\treturn 0;\n}\n\nstatic int it66121_set_mute(struct it66121_ctx *ctx, bool mute)\n{\n\tint ret;\n\tunsigned int val = 0;\n\n\tif (mute)\n\t\tval = IT66121_AV_MUTE_ON;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AV_MUTE_REG, IT66121_AV_MUTE_ON, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ctx->regmap, IT66121_PKT_GEN_CTRL_REG,\n\t\t\t    IT66121_PKT_GEN_CTRL_ON | IT66121_PKT_GEN_CTRL_RPT);\n}\n\n#define MAX_OUTPUT_SEL_FORMATS\t1\n\nstatic u32 *it66121_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t      struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t      struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t      struct drm_connector_state *conn_state,\n\t\t\t\t\t\t      unsigned int *num_output_fmts)\n{\n\tu32 *output_fmts;\n\n\toutput_fmts = kcalloc(MAX_OUTPUT_SEL_FORMATS, sizeof(*output_fmts),\n\t\t\t      GFP_KERNEL);\n\tif (!output_fmts)\n\t\treturn NULL;\n\n\t \n\toutput_fmts[0] =  MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_output_fmts = 1;\n\n\treturn output_fmts;\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *it66121_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t\t     u32 output_fmt,\n\t\t\t\t\t\t     unsigned int *num_input_fmts)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tif (ctx->bus_width == 12)\n\t\t \n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_2X12_LE;\n\telse\n\t\t \n\t\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic void it66121_bridge_enable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *bridge_state)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\n\tctx->connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\n\tit66121_set_mute(ctx, false);\n}\n\nstatic void it66121_bridge_disable(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_bridge_state *bridge_state)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\n\tit66121_set_mute(ctx, true);\n\n\tctx->connector = NULL;\n}\n\nstatic int it66121_bridge_check(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\n\tif (ctx->info->id == ID_IT6610) {\n\t\t \n\t\tbridge_state->input_bus_cfg.flags |= DRM_BUS_FLAG_DE_HIGH |\n\t\t\tDRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE;\n\t\tbridge_state->input_bus_cfg.flags &=\n\t\t\t~DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;\n\t}\n\n\treturn 0;\n}\n\nstatic\nvoid it66121_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t     const struct drm_display_mode *mode,\n\t\t\t     const struct drm_display_mode *adjusted_mode)\n{\n\tu8 buf[HDMI_INFOFRAME_SIZE(AVI)];\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tint ret;\n\n\tmutex_lock(&ctx->lock);\n\n\thdmi_avi_infoframe_init(&ctx->hdmi_avi_infoframe);\n\n\tret = drm_hdmi_avi_infoframe_from_display_mode(&ctx->hdmi_avi_infoframe, ctx->connector,\n\t\t\t\t\t\t       adjusted_mode);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to setup AVI infoframe: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tret = hdmi_avi_infoframe_pack(&ctx->hdmi_avi_infoframe, buf, sizeof(buf));\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to pack infoframe: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\t \n\tret = regmap_bulk_write(ctx->regmap, IT66121_AVIINFO_DB1_REG,\n\t\t\t\t&buf[HDMI_INFOFRAME_HEADER_SIZE],\n\t\t\t\tHDMI_AVI_INFOFRAME_SIZE);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (regmap_write(ctx->regmap, IT66121_AVIINFO_CSUM_REG, buf[3]))\n\t\tgoto unlock;\n\n\t \n\tif (regmap_write(ctx->regmap, IT66121_AVI_INFO_PKT_REG,\n\t\t\t IT66121_AVI_INFO_PKT_ON | IT66121_AVI_INFO_PKT_RPT))\n\t\tgoto unlock;\n\n\t \n\tif (regmap_write(ctx->regmap, IT66121_HDMI_MODE_REG, IT66121_HDMI_MODE_HDMI))\n\t\tgoto unlock;\n\n\tif (ctx->info->id == ID_IT66121 &&\n\t    regmap_write_bits(ctx->regmap, IT66121_CLK_BANK_REG,\n\t\t\t      IT66121_CLK_BANK_PWROFF_TXCLK,\n\t\t\t      IT66121_CLK_BANK_PWROFF_TXCLK)) {\n\t\tgoto unlock;\n\t}\n\n\tif (it66121_configure_input(ctx))\n\t\tgoto unlock;\n\n\tif (it66121_configure_afe(ctx, adjusted_mode))\n\t\tgoto unlock;\n\n\tif (ctx->info->id == ID_IT66121 &&\n\t    regmap_write_bits(ctx->regmap, IT66121_CLK_BANK_REG,\n\t\t\t      IT66121_CLK_BANK_PWROFF_TXCLK, 0)) {\n\t\tgoto unlock;\n\t}\n\nunlock:\n\tmutex_unlock(&ctx->lock);\n}\n\nstatic enum drm_mode_status it66121_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t\t      const struct drm_display_info *info,\n\t\t\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tunsigned long max_clock;\n\n\tmax_clock = (ctx->bus_width == 12) ? 74250 : 148500;\n\n\tif (mode->clock > max_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (mode->clock < 25000)\n\t\treturn MODE_CLOCK_LOW;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status it66121_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\n\treturn it66121_is_hpd_detect(ctx) ? connector_status_connected\n\t\t\t\t\t  : connector_status_disconnected;\n}\n\nstatic void it66121_bridge_hpd_enable(struct drm_bridge *bridge)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tint ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_INT_MASK1_REG, IT66121_INT_MASK1_HPD, 0);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"failed to enable HPD IRQ\\n\");\n}\n\nstatic void it66121_bridge_hpd_disable(struct drm_bridge *bridge)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tint ret;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_INT_MASK1_REG,\n\t\t\t\tIT66121_INT_MASK1_HPD, IT66121_INT_MASK1_HPD);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"failed to disable HPD IRQ\\n\");\n}\n\nstatic struct edid *it66121_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct it66121_ctx *ctx = container_of(bridge, struct it66121_ctx, bridge);\n\tstruct edid *edid;\n\tint ret;\n\n\tmutex_lock(&ctx->lock);\n\tret = it66121_preamble_ddc(ctx);\n\tif (ret) {\n\t\tedid = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = regmap_write(ctx->regmap, IT66121_DDC_HEADER_REG,\n\t\t\t   IT66121_DDC_HEADER_EDID);\n\tif (ret) {\n\t\tedid = NULL;\n\t\tgoto out_unlock;\n\t}\n\n\tedid = drm_do_get_edid(connector, it66121_get_edid_block, ctx);\n\nout_unlock:\n\tmutex_unlock(&ctx->lock);\n\n\treturn edid;\n}\n\nstatic const struct drm_bridge_funcs it66121_bridge_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.attach = it66121_bridge_attach,\n\t.atomic_get_output_bus_fmts = it66121_bridge_atomic_get_output_bus_fmts,\n\t.atomic_get_input_bus_fmts = it66121_bridge_atomic_get_input_bus_fmts,\n\t.atomic_enable = it66121_bridge_enable,\n\t.atomic_disable = it66121_bridge_disable,\n\t.atomic_check = it66121_bridge_check,\n\t.mode_set = it66121_bridge_mode_set,\n\t.mode_valid = it66121_bridge_mode_valid,\n\t.detect = it66121_bridge_detect,\n\t.get_edid = it66121_bridge_get_edid,\n\t.hpd_enable = it66121_bridge_hpd_enable,\n\t.hpd_disable = it66121_bridge_hpd_disable,\n};\n\nstatic irqreturn_t it66121_irq_threaded_handler(int irq, void *dev_id)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct it66121_ctx *ctx = dev_id;\n\tstruct device *dev = ctx->dev;\n\tenum drm_connector_status status;\n\tbool event = false;\n\n\tmutex_lock(&ctx->lock);\n\n\tret = regmap_read(ctx->regmap, IT66121_SYS_STATUS_REG, &val);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (!(val & IT66121_SYS_STATUS_ACTIVE_IRQ))\n\t\tgoto unlock;\n\n\tret = regmap_read(ctx->regmap, IT66121_INT_STATUS1_REG, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot read STATUS1_REG %d\\n\", ret);\n\t} else if (val & IT66121_INT_STATUS1_HPD_STATUS) {\n\t\tregmap_write_bits(ctx->regmap, IT66121_INT_CLR1_REG,\n\t\t\t\t  IT66121_INT_CLR1_HPD, IT66121_INT_CLR1_HPD);\n\n\t\tstatus = it66121_is_hpd_detect(ctx) ? connector_status_connected\n\t\t\t: connector_status_disconnected;\n\n\t\tevent = true;\n\t}\n\n\tregmap_write_bits(ctx->regmap, IT66121_SYS_STATUS_REG,\n\t\t\t  IT66121_SYS_STATUS_CLEAR_IRQ,\n\t\t\t  IT66121_SYS_STATUS_CLEAR_IRQ);\n\nunlock:\n\tmutex_unlock(&ctx->lock);\n\n\tif (event)\n\t\tdrm_bridge_hpd_notify(&ctx->bridge, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int it661221_set_chstat(struct it66121_ctx *ctx, u8 iec60958_chstat[])\n{\n\tint ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CHST_MODE_REG, iec60958_chstat[0] & 0x7C);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CHST_CAT_REG, iec60958_chstat[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CHST_SRCNUM_REG, iec60958_chstat[2] & 0x0F);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CHST_CHTNUM_REG,\n\t\t\t   (iec60958_chstat[2] >> 4) & 0x0F);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CHST_CA_FS_REG, iec60958_chstat[3]);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ctx->regmap, IT66121_AUD_CHST_OFS_WL_REG, iec60958_chstat[4]);\n}\n\nstatic int it661221_set_lpcm_audio(struct it66121_ctx *ctx, u8 audio_src_num, u8 audio_swl)\n{\n\tint ret;\n\tunsigned int audio_enable = 0;\n\tunsigned int audio_format = 0;\n\n\tswitch (audio_swl) {\n\tcase 16:\n\t\taudio_enable |= IT66121_AUD_16BIT;\n\t\tbreak;\n\tcase 18:\n\t\taudio_enable |= IT66121_AUD_18BIT;\n\t\tbreak;\n\tcase 20:\n\t\taudio_enable |= IT66121_AUD_20BIT;\n\t\tbreak;\n\tcase 24:\n\tdefault:\n\t\taudio_enable |= IT66121_AUD_24BIT;\n\t\tbreak;\n\t}\n\n\taudio_format |= 0x40;\n\tswitch (audio_src_num) {\n\tcase 4:\n\t\taudio_enable |= IT66121_AUD_EN_I2S3 | IT66121_AUD_EN_I2S2 |\n\t\t\t\tIT66121_AUD_EN_I2S1 | IT66121_AUD_EN_I2S0;\n\t\tbreak;\n\tcase 3:\n\t\taudio_enable |= IT66121_AUD_EN_I2S2 | IT66121_AUD_EN_I2S1 |\n\t\t\t\tIT66121_AUD_EN_I2S0;\n\t\tbreak;\n\tcase 2:\n\t\taudio_enable |= IT66121_AUD_EN_I2S1 | IT66121_AUD_EN_I2S0;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\taudio_format &= ~0x40;\n\t\taudio_enable |= IT66121_AUD_EN_I2S0;\n\t\tbreak;\n\t}\n\n\taudio_format |= 0x01;\n\tctx->audio.ch_enable = audio_enable;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CTRL0_REG, audio_enable & 0xF0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CTRL1_REG, audio_format);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_FIFOMAP_REG, 0xE4);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_CTRL3_REG, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_SRCVALID_FLAT_REG, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ctx->regmap, IT66121_AUD_HDAUDIO_REG, 0x00);\n}\n\nstatic int it661221_set_ncts(struct it66121_ctx *ctx, u8 fs)\n{\n\tint ret;\n\tunsigned int n;\n\n\tswitch (fs) {\n\tcase IT66121_AUD_FS_32K:\n\t\tn = 4096;\n\t\tbreak;\n\tcase IT66121_AUD_FS_44P1K:\n\t\tn = 6272;\n\t\tbreak;\n\tcase IT66121_AUD_FS_48K:\n\t\tn = 6144;\n\t\tbreak;\n\tcase IT66121_AUD_FS_88P2K:\n\t\tn = 12544;\n\t\tbreak;\n\tcase IT66121_AUD_FS_96K:\n\t\tn = 12288;\n\t\tbreak;\n\tcase IT66121_AUD_FS_176P4K:\n\t\tn = 25088;\n\t\tbreak;\n\tcase IT66121_AUD_FS_192K:\n\t\tn = 24576;\n\t\tbreak;\n\tcase IT66121_AUD_FS_768K:\n\t\tn = 24576;\n\t\tbreak;\n\tdefault:\n\t\tn = 6144;\n\t\tbreak;\n\t}\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_PKT_N0_REG, (u8)((n) & 0xFF));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_PKT_N1_REG, (u8)((n >> 8) & 0xFF));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, IT66121_AUD_PKT_N2_REG, (u8)((n >> 16) & 0xF));\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->audio.auto_cts) {\n\t\tu8 loop_cnt = 255;\n\t\tu8 cts_stable_cnt = 0;\n\t\tunsigned int sum_cts = 0;\n\t\tunsigned int cts = 0;\n\t\tunsigned int last_cts = 0;\n\t\tunsigned int diff;\n\t\tunsigned int val;\n\n\t\twhile (loop_cnt--) {\n\t\t\tmsleep(30);\n\t\t\tregmap_read(ctx->regmap, IT66121_AUD_PKT_CTS_CNT2_REG, &val);\n\t\t\tcts = val << 12;\n\t\t\tregmap_read(ctx->regmap, IT66121_AUD_PKT_CTS_CNT1_REG, &val);\n\t\t\tcts |= val << 4;\n\t\t\tregmap_read(ctx->regmap, IT66121_AUD_PKT_CTS_CNT0_REG, &val);\n\t\t\tcts |= val >> 4;\n\t\t\tif (cts == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (last_cts > cts)\n\t\t\t\t\tdiff = last_cts - cts;\n\t\t\t\telse\n\t\t\t\t\tdiff = cts - last_cts;\n\t\t\t\tlast_cts = cts;\n\t\t\t\tif (diff < 5) {\n\t\t\t\t\tcts_stable_cnt++;\n\t\t\t\t\tsum_cts += cts;\n\t\t\t\t} else {\n\t\t\t\t\tcts_stable_cnt = 0;\n\t\t\t\t\tsum_cts = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (cts_stable_cnt >= 32) {\n\t\t\t\t\tlast_cts = (sum_cts >> 5);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tregmap_write(ctx->regmap, IT66121_AUD_PKT_CTS0_REG, (u8)((last_cts) & 0xFF));\n\t\tregmap_write(ctx->regmap, IT66121_AUD_PKT_CTS1_REG, (u8)((last_cts >> 8) & 0xFF));\n\t\tregmap_write(ctx->regmap, IT66121_AUD_PKT_CTS2_REG, (u8)((last_cts >> 16) & 0x0F));\n\t}\n\n\tret = regmap_write(ctx->regmap, 0xF8, 0xC3);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(ctx->regmap, 0xF8, 0xA5);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ctx->audio.auto_cts) {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_PKT_CTS_CTRL_REG,\n\t\t\t\t\tIT66121_PKT_CTS_CTRL_SEL,\n\t\t\t\t\t1);\n\t} else {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_PKT_CTS_CTRL_REG,\n\t\t\t\t\tIT66121_PKT_CTS_CTRL_SEL,\n\t\t\t\t\t0);\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ctx->regmap, 0xF8, 0xFF);\n}\n\nstatic int it661221_audio_output_enable(struct it66121_ctx *ctx, bool enable)\n{\n\tint ret;\n\n\tif (enable) {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_SW_RST_REG,\n\t\t\t\t\tIT66121_SW_RST_AUD | IT66121_SW_RST_AREF,\n\t\t\t\t\t0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AUD_CTRL0_REG,\n\t\t\t\t\tIT66121_AUD_EN_I2S3 | IT66121_AUD_EN_I2S2 |\n\t\t\t\t\tIT66121_AUD_EN_I2S1 | IT66121_AUD_EN_I2S0,\n\t\t\t\t\tctx->audio.ch_enable);\n\t} else {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AUD_CTRL0_REG,\n\t\t\t\t\tIT66121_AUD_EN_I2S3 | IT66121_AUD_EN_I2S2 |\n\t\t\t\t\tIT66121_AUD_EN_I2S1 | IT66121_AUD_EN_I2S0,\n\t\t\t\t\tctx->audio.ch_enable & 0xF0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_SW_RST_REG,\n\t\t\t\t\tIT66121_SW_RST_AUD | IT66121_SW_RST_AREF,\n\t\t\t\t\tIT66121_SW_RST_AUD | IT66121_SW_RST_AREF);\n\t}\n\n\treturn ret;\n}\n\nstatic int it661221_audio_ch_enable(struct it66121_ctx *ctx, bool enable)\n{\n\tint ret;\n\n\tif (enable) {\n\t\tret = regmap_write(ctx->regmap, IT66121_AUD_SRCVALID_FLAT_REG, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(ctx->regmap, IT66121_AUD_CTRL0_REG, ctx->audio.ch_enable);\n\t} else {\n\t\tret = regmap_write(ctx->regmap, IT66121_AUD_CTRL0_REG, ctx->audio.ch_enable & 0xF0);\n\t}\n\n\treturn ret;\n}\n\nstatic int it66121_audio_hw_params(struct device *dev, void *data,\n\t\t\t\t   struct hdmi_codec_daifmt *daifmt,\n\t\t\t\t   struct hdmi_codec_params *params)\n{\n\tu8 fs;\n\tu8 swl;\n\tint ret;\n\tstruct it66121_ctx *ctx = dev_get_drvdata(dev);\n\tstatic u8 iec60958_chstat[5];\n\tunsigned int channels = params->channels;\n\tunsigned int sample_rate = params->sample_rate;\n\tunsigned int sample_width = params->sample_width;\n\n\tmutex_lock(&ctx->lock);\n\tdev_dbg(dev, \"%s: %u, %u, %u, %u\\n\", __func__,\n\t\tdaifmt->fmt, sample_rate, sample_width, channels);\n\n\tswitch (daifmt->fmt) {\n\tcase HDMI_I2S:\n\t\tdev_dbg(dev, \"Using HDMI I2S\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid or unsupported DAI format %d\\n\", daifmt->fmt);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t\n\tret = regmap_write(ctx->regmap, IT66121_CLK_CTRL0_REG,\n\t\t\t   IT66121_CLK_CTRL0_AUTO_OVER_SAMPLING |\n\t\t\t   IT66121_CLK_CTRL0_EXT_MCLK_256FS |\n\t\t\t   IT66121_CLK_CTRL0_AUTO_IPCLK);\n\tif (ret)\n\t\tgoto out;\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_AUD_CTRL0_REG,\n\t\t\t\tIT66121_AUD_CTRL0_AUD_SEL, 0); \n\tif (ret)\n\t\tgoto out;\n\n\tswitch (sample_rate) {\n\tcase 44100L:\n\t\tfs = IT66121_AUD_FS_44P1K;\n\t\tbreak;\n\tcase 88200L:\n\t\tfs = IT66121_AUD_FS_88P2K;\n\t\tbreak;\n\tcase 176400L:\n\t\tfs = IT66121_AUD_FS_176P4K;\n\t\tbreak;\n\tcase 32000L:\n\t\tfs = IT66121_AUD_FS_32K;\n\t\tbreak;\n\tcase 48000L:\n\t\tfs = IT66121_AUD_FS_48K;\n\t\tbreak;\n\tcase 96000L:\n\t\tfs = IT66121_AUD_FS_96K;\n\t\tbreak;\n\tcase 192000L:\n\t\tfs = IT66121_AUD_FS_192K;\n\t\tbreak;\n\tcase 768000L:\n\t\tfs = IT66121_AUD_FS_768K;\n\t\tbreak;\n\tdefault:\n\t\tfs = IT66121_AUD_FS_48K;\n\t\tbreak;\n\t}\n\n\tctx->audio.fs = fs;\n\tret = it661221_set_ncts(ctx, fs);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set N/CTS: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t\n\tret = it661221_set_lpcm_audio(ctx, (channels + 1) / 2, sample_width);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set LPCM audio: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t\n\tiec60958_chstat[0] = 0;\n\tif ((channels + 1) / 2 == 1)\n\t\tiec60958_chstat[0] |= 0x1;\n\tiec60958_chstat[0] &= ~(1 << 1);\n\tiec60958_chstat[1] = 0;\n\tiec60958_chstat[2] = (channels + 1) / 2;\n\tiec60958_chstat[2] |= (channels << 4) & 0xF0;\n\tiec60958_chstat[3] = fs;\n\n\tswitch (sample_width) {\n\tcase 21L:\n\t\tswl = IT66121_AUD_SWL_21BIT;\n\t\tbreak;\n\tcase 24L:\n\t\tswl = IT66121_AUD_SWL_24BIT;\n\t\tbreak;\n\tcase 23L:\n\t\tswl = IT66121_AUD_SWL_23BIT;\n\t\tbreak;\n\tcase 22L:\n\t\tswl = IT66121_AUD_SWL_22BIT;\n\t\tbreak;\n\tcase 20L:\n\t\tswl = IT66121_AUD_SWL_20BIT;\n\t\tbreak;\n\tcase 17L:\n\t\tswl = IT66121_AUD_SWL_17BIT;\n\t\tbreak;\n\tcase 19L:\n\t\tswl = IT66121_AUD_SWL_19BIT;\n\t\tbreak;\n\tcase 18L:\n\t\tswl = IT66121_AUD_SWL_18BIT;\n\t\tbreak;\n\tcase 16L:\n\t\tswl = IT66121_AUD_SWL_16BIT;\n\t\tbreak;\n\tdefault:\n\t\tswl = IT66121_AUD_SWL_NOT_INDICATED;\n\t\tbreak;\n\t}\n\n\tiec60958_chstat[4] = (((~fs) << 4) & 0xF0) | swl;\n\tret = it661221_set_chstat(ctx, iec60958_chstat);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set channel status: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t\n\tret = it661221_audio_ch_enable(ctx, true);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable audio channel: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = regmap_write_bits(ctx->regmap, IT66121_INT_MASK1_REG,\n\t\t\t\tIT66121_INT_MASK1_AUD_OVF,\n\t\t\t\t0);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_dbg(dev, \"HDMI audio enabled.\\n\");\nout:\n\tmutex_unlock(&ctx->lock);\n\n\treturn ret;\n}\n\nstatic int it66121_audio_startup(struct device *dev, void *data)\n{\n\tint ret;\n\tstruct it66121_ctx *ctx = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&ctx->lock);\n\tret = it661221_audio_output_enable(ctx, true);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to enable audio output: %d\\n\", ret);\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn ret;\n}\n\nstatic void it66121_audio_shutdown(struct device *dev, void *data)\n{\n\tint ret;\n\tstruct it66121_ctx *ctx = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&ctx->lock);\n\tret = it661221_audio_output_enable(ctx, false);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable audio output: %d\\n\", ret);\n\n\tmutex_unlock(&ctx->lock);\n}\n\nstatic int it66121_audio_mute(struct device *dev, void *data,\n\t\t\t      bool enable, int direction)\n{\n\tint ret;\n\tstruct it66121_ctx *ctx = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s: enable=%s, direction=%d\\n\",\n\t\t__func__, enable ? \"true\" : \"false\", direction);\n\n\tmutex_lock(&ctx->lock);\n\n\tif (enable) {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AUD_SRCVALID_FLAT_REG,\n\t\t\t\t\tIT66121_AUD_FLAT_SRC0 | IT66121_AUD_FLAT_SRC1 |\n\t\t\t\t\tIT66121_AUD_FLAT_SRC2 | IT66121_AUD_FLAT_SRC3,\n\t\t\t\t\tIT66121_AUD_FLAT_SRC0 | IT66121_AUD_FLAT_SRC1 |\n\t\t\t\t\tIT66121_AUD_FLAT_SRC2 | IT66121_AUD_FLAT_SRC3);\n\t} else {\n\t\tret = regmap_write_bits(ctx->regmap, IT66121_AUD_SRCVALID_FLAT_REG,\n\t\t\t\t\tIT66121_AUD_FLAT_SRC0 | IT66121_AUD_FLAT_SRC1 |\n\t\t\t\t\tIT66121_AUD_FLAT_SRC2 | IT66121_AUD_FLAT_SRC3,\n\t\t\t\t\t0);\n\t}\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn ret;\n}\n\nstatic int it66121_audio_get_eld(struct device *dev, void *data,\n\t\t\t\t u8 *buf, size_t len)\n{\n\tstruct it66121_ctx *ctx = dev_get_drvdata(dev);\n\n\tmutex_lock(&ctx->lock);\n\tif (!ctx->connector) {\n\t\t \n\t\tdev_dbg(dev, \"No connector present, passing empty EDID data\");\n\t\tmemset(buf, 0, len);\n\t} else {\n\t\tmemcpy(buf, ctx->connector->eld,\n\t\t       min(sizeof(ctx->connector->eld), len));\n\t}\n\tmutex_unlock(&ctx->lock);\n\n\treturn 0;\n}\n\nstatic const struct hdmi_codec_ops it66121_audio_codec_ops = {\n\t.hw_params = it66121_audio_hw_params,\n\t.audio_startup = it66121_audio_startup,\n\t.audio_shutdown = it66121_audio_shutdown,\n\t.mute_stream = it66121_audio_mute,\n\t.get_eld = it66121_audio_get_eld,\n\t.no_capture_mute = 1,\n};\n\nstatic int it66121_audio_codec_init(struct it66121_ctx *ctx, struct device *dev)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &it66121_audio_codec_ops,\n\t\t.i2s = 1,  \n\t\t.spdif = 0,\n\t\t.max_i2s_channels = 8,\n\t};\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tif (!of_property_read_bool(dev->of_node, \"#sound-dai-cells\")) {\n\t\tdev_info(dev, \"No \\\"#sound-dai-cells\\\", no audio\\n\");\n\t\treturn 0;\n\t}\n\n\tctx->audio.pdev = platform_device_register_data(dev,\n\t\t\t\t\t\t\tHDMI_CODEC_DRV_NAME,\n\t\t\t\t\t\t\tPLATFORM_DEVID_AUTO,\n\t\t\t\t\t\t\t&codec_data,\n\t\t\t\t\t\t\tsizeof(codec_data));\n\n\tif (IS_ERR(ctx->audio.pdev)) {\n\t\tdev_err(dev, \"Failed to initialize HDMI audio codec: %d\\n\",\n\t\t\tPTR_ERR_OR_ZERO(ctx->audio.pdev));\n\t}\n\n\treturn PTR_ERR_OR_ZERO(ctx->audio.pdev);\n}\n\nstatic const char * const it66121_supplies[] = {\n\t\"vcn33\", \"vcn18\", \"vrf12\"\n};\n\nstatic int it66121_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tu32 revision_id, vendor_ids[2] = { 0 }, device_ids[2] = { 0 };\n\tstruct device_node *ep;\n\tint ret;\n\tstruct it66121_ctx *ctx;\n\tstruct device *dev = &client->dev;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"I2C check functionality failed.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tep = of_graph_get_endpoint_by_regs(dev->of_node, 0, 0);\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tctx->dev = dev;\n\tctx->client = client;\n\tctx->info = (const struct it66121_chip_info *) id->driver_data;\n\n\tof_property_read_u32(ep, \"bus-width\", &ctx->bus_width);\n\tof_node_put(ep);\n\n\tif (ctx->bus_width != 12 && ctx->bus_width != 24)\n\t\treturn -EINVAL;\n\n\tep = of_graph_get_remote_node(dev->of_node, 1, -1);\n\tif (!ep) {\n\t\tdev_err(ctx->dev, \"The endpoint is unconnected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!of_device_is_available(ep)) {\n\t\tof_node_put(ep);\n\t\tdev_err(ctx->dev, \"The remote device is disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tctx->next_bridge = of_drm_find_bridge(ep);\n\tof_node_put(ep);\n\tif (!ctx->next_bridge) {\n\t\tdev_dbg(ctx->dev, \"Next bridge not found, deferring probe\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\ti2c_set_clientdata(client, ctx);\n\tmutex_init(&ctx->lock);\n\n\tret = devm_regulator_bulk_get_enable(dev, ARRAY_SIZE(it66121_supplies),\n\t\t\t\t\t     it66121_supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable power supplies\\n\");\n\t\treturn ret;\n\t}\n\n\tit66121_hw_reset(ctx);\n\n\tctx->regmap = devm_regmap_init_i2c(client, &it66121_regmap_config);\n\tif (IS_ERR(ctx->regmap))\n\t\treturn PTR_ERR(ctx->regmap);\n\n\tregmap_read(ctx->regmap, IT66121_VENDOR_ID0_REG, &vendor_ids[0]);\n\tregmap_read(ctx->regmap, IT66121_VENDOR_ID1_REG, &vendor_ids[1]);\n\tregmap_read(ctx->regmap, IT66121_DEVICE_ID0_REG, &device_ids[0]);\n\tregmap_read(ctx->regmap, IT66121_DEVICE_ID1_REG, &device_ids[1]);\n\n\t \n\trevision_id = FIELD_GET(IT66121_REVISION_MASK, device_ids[1]);\n\tdevice_ids[1] &= IT66121_DEVICE_ID1_MASK;\n\n\tif ((vendor_ids[1] << 8 | vendor_ids[0]) != ctx->info->vid ||\n\t    (device_ids[1] << 8 | device_ids[0]) != ctx->info->pid) {\n\t\treturn -ENODEV;\n\t}\n\n\tctx->bridge.funcs = &it66121_bridge_funcs;\n\tctx->bridge.of_node = dev->of_node;\n\tctx->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\tctx->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID | DRM_BRIDGE_OP_HPD;\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\tit66121_irq_threaded_handler,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), ctx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request irq %d:%d\\n\", client->irq, ret);\n\t\treturn ret;\n\t}\n\n\tit66121_audio_codec_init(ctx, dev);\n\n\tdrm_bridge_add(&ctx->bridge);\n\n\tdev_info(ctx->dev, \"IT66121 revision %d probed\\n\", revision_id);\n\n\treturn 0;\n}\n\nstatic void it66121_remove(struct i2c_client *client)\n{\n\tstruct it66121_ctx *ctx = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&ctx->bridge);\n\tmutex_destroy(&ctx->lock);\n}\n\nstatic const struct of_device_id it66121_dt_match[] = {\n\t{ .compatible = \"ite,it66121\" },\n\t{ .compatible = \"ite,it6610\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, it66121_dt_match);\n\nstatic const struct it66121_chip_info it66121_chip_info = {\n\t.id = ID_IT66121,\n\t.vid = 0x4954,\n\t.pid = 0x0612,\n};\n\nstatic const struct it66121_chip_info it6610_chip_info = {\n\t.id = ID_IT6610,\n\t.vid = 0xca00,\n\t.pid = 0x0611,\n};\n\nstatic const struct i2c_device_id it66121_id[] = {\n\t{ \"it66121\", (kernel_ulong_t) &it66121_chip_info },\n\t{ \"it6610\", (kernel_ulong_t) &it6610_chip_info },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, it66121_id);\n\nstatic struct i2c_driver it66121_driver = {\n\t.driver = {\n\t\t.name\t= \"it66121\",\n\t\t.of_match_table = it66121_dt_match,\n\t},\n\t.probe = it66121_probe,\n\t.remove = it66121_remove,\n\t.id_table = it66121_id,\n};\n\nmodule_i2c_driver(it66121_driver);\n\nMODULE_AUTHOR(\"Phong LE\");\nMODULE_DESCRIPTION(\"IT66121 HDMI transmitter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}