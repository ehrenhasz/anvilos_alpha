{
  "module_name": "parade-ps8622.c",
  "hash_id": "eb057a6ea9ac8c8e5f92f62ae690e4b26a6ba262f84b6c02360c8a8b819e9a53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/parade-ps8622.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n \n#define PS8622_MAX_BRIGHTNESS 0xff\n\n \n#define PS8622_POWER_RISE_T1_MIN_US 10\n#define PS8622_POWER_RISE_T1_MAX_US 10000\n#define PS8622_RST_HIGH_T2_MIN_US 3000\n#define PS8622_RST_HIGH_T2_MAX_US 30000\n#define PS8622_PWMO_END_T12_MS 200\n#define PS8622_POWER_FALL_T16_MAX_US 10000\n#define PS8622_POWER_OFF_T17_MS 500\n\n#if ((PS8622_RST_HIGH_T2_MIN_US + PS8622_POWER_RISE_T1_MAX_US) > \\\n\t(PS8622_RST_HIGH_T2_MAX_US + PS8622_POWER_RISE_T1_MIN_US))\n#error \"T2.min + T1.max must be less than T2.max + T1.min\"\n#endif\n\nstruct ps8622_bridge {\n\tstruct i2c_client *client;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *panel_bridge;\n\tstruct regulator *v12;\n\tstruct backlight_device *bl;\n\n\tstruct gpio_desc *gpio_slp;\n\tstruct gpio_desc *gpio_rst;\n\n\tu32 max_lane_count;\n\tu32 lane_count;\n\n\tbool enabled;\n};\n\nstatic inline struct ps8622_bridge *\n\t\tbridge_to_ps8622(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct ps8622_bridge, bridge);\n}\n\nstatic int ps8622_set(struct i2c_client *client, u8 page, u8 reg, u8 val)\n{\n\tint ret;\n\tstruct i2c_adapter *adap = client->adapter;\n\tstruct i2c_msg msg;\n\tu8 data[] = {reg, val};\n\n\tmsg.addr = client->addr + page;\n\tmsg.flags = 0;\n\tmsg.len = sizeof(data);\n\tmsg.buf = data;\n\n\tret = i2c_transfer(adap, &msg, 1);\n\tif (ret != 1)\n\t\tpr_warn(\"PS8622 I2C write (0x%02x,0x%02x,0x%02x) failed: %d\\n\",\n\t\t\tclient->addr + page, reg, val, ret);\n\treturn !(ret == 1);\n}\n\nstatic int ps8622_send_config(struct ps8622_bridge *ps8622)\n{\n\tstruct i2c_client *cl = ps8622->client;\n\tint err = 0;\n\n\t \n\terr = ps8622_set(cl, 0x02, 0xa1, 0x01);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x14, 0x01);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0xe3, 0x20);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0xe2, 0x80);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x8a, 0x0c);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x89, 0x08);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x71, 0x2d);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x7d, 0x07);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x7b, 0x00);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x7a, 0xfd);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0xc0, 0x12);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0xc1, 0x92);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0xc2, 0x1c);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x32, 0x80);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x00, 0xb0);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x15, 0x40);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x54, 0x10);\n\tif (err)\n\t\tgoto error;\n\n\t \n\t \n\terr = ps8622_set(cl, 0x01, 0x02, 0x80 | ps8622->max_lane_count);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0x21, 0x80 | ps8622->lane_count);\n\tif (err)\n\t\tgoto error;\n\n\terr = ps8622_set(cl, 0x00, 0x52, 0x20);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x00, 0xf1, 0x03);\n\tif (err)\n\t\tgoto error;\n\n\terr = ps8622_set(cl, 0x00, 0x62, 0x41);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x00, 0xf6, 0x01);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x00, 0x77, 0x06);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x00, 0x4c, 0x04);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc0, 0x00);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc1, 0x1c);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc2, 0xf8);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc3, 0x44);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc4, 0x32);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc5, 0x53);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc6, 0x4c);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc7, 0x56);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xc8, 0x35);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xca, 0x01);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xcb, 0x05);\n\tif (err)\n\t\tgoto error;\n\n\n\tif (ps8622->bl) {\n\t\t \n\t\terr = ps8622_set(cl, 0x01, 0xa5, 0xa0);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\t \n\t\terr = ps8622_set(cl, 0x01, 0xa7,\n\t\t\t\tps8622->bl->props.brightness);\n\t\tif (err)\n\t\t\tgoto error;\n\t} else {\n\t\t \n\t\terr = ps8622_set(cl, 0x01, 0xa5, 0x80);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\t \n\terr = ps8622_set(cl, 0x01, 0xcc, 0x13);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x02, 0xb1, 0x20);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x10, 0x16);\n\tif (err)\n\t\tgoto error;\n\n\t \n\t \n\terr = ps8622_set(cl, 0x04, 0x59, 0x60);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x04, 0x54, 0x14);\n\tif (err)\n\t\tgoto error;\n\n\t \n\terr = ps8622_set(cl, 0x02, 0xa1, 0x91);\n\nerror:\n\treturn err ? -EIO : 0;\n}\n\nstatic int ps8622_backlight_update(struct backlight_device *bl)\n{\n\tstruct ps8622_bridge *ps8622 = dev_get_drvdata(&bl->dev);\n\tint ret, brightness = backlight_get_brightness(bl);\n\n\tif (!ps8622->enabled)\n\t\treturn -EINVAL;\n\n\tret = ps8622_set(ps8622->client, 0x01, 0xa7, brightness);\n\n\treturn ret;\n}\n\nstatic const struct backlight_ops ps8622_backlight_ops = {\n\t.update_status\t= ps8622_backlight_update,\n};\n\nstatic void ps8622_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\n\tint ret;\n\n\tif (ps8622->enabled)\n\t\treturn;\n\n\tgpiod_set_value(ps8622->gpio_rst, 0);\n\n\tif (ps8622->v12) {\n\t\tret = regulator_enable(ps8622->v12);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"fails to enable ps8622->v12\");\n\t}\n\n\tgpiod_set_value(ps8622->gpio_slp, 1);\n\n\t \n\tusleep_range(PS8622_RST_HIGH_T2_MIN_US + PS8622_POWER_RISE_T1_MAX_US,\n\t\t     PS8622_RST_HIGH_T2_MAX_US + PS8622_POWER_RISE_T1_MIN_US);\n\n\tgpiod_set_value(ps8622->gpio_rst, 1);\n\n\t \n\tusleep_range(20000, 30000);\n\n\tret = ps8622_send_config(ps8622);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to send config to bridge (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\tps8622->enabled = true;\n}\n\nstatic void ps8622_disable(struct drm_bridge *bridge)\n{\n\t \n\tmsleep(PS8622_PWMO_END_T12_MS);\n}\n\nstatic void ps8622_post_disable(struct drm_bridge *bridge)\n{\n\tstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\n\n\tif (!ps8622->enabled)\n\t\treturn;\n\n\tps8622->enabled = false;\n\n\t \n\tgpiod_set_value(ps8622->gpio_slp, 0);\n\n\tif (ps8622->v12)\n\t\tregulator_disable(ps8622->v12);\n\n\t \n\tusleep_range(PS8622_POWER_FALL_T16_MAX_US,\n\t\t     2 * PS8622_POWER_FALL_T16_MAX_US);\n\tgpiod_set_value(ps8622->gpio_rst, 0);\n\n\tmsleep(PS8622_POWER_OFF_T17_MS);\n}\n\nstatic int ps8622_attach(struct drm_bridge *bridge,\n\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct ps8622_bridge *ps8622 = bridge_to_ps8622(bridge);\n\n\treturn drm_bridge_attach(ps8622->bridge.encoder, ps8622->panel_bridge,\n\t\t\t\t &ps8622->bridge, flags);\n}\n\nstatic const struct drm_bridge_funcs ps8622_bridge_funcs = {\n\t.pre_enable = ps8622_pre_enable,\n\t.disable = ps8622_disable,\n\t.post_disable = ps8622_post_disable,\n\t.attach = ps8622_attach,\n};\n\nstatic const struct of_device_id ps8622_devices[] = {\n\t{.compatible = \"parade,ps8622\",},\n\t{.compatible = \"parade,ps8625\",},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ps8622_devices);\n\nstatic int ps8622_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct device *dev = &client->dev;\n\tstruct ps8622_bridge *ps8622;\n\tstruct drm_bridge *panel_bridge;\n\tint ret;\n\n\tps8622 = devm_kzalloc(dev, sizeof(*ps8622), GFP_KERNEL);\n\tif (!ps8622)\n\t\treturn -ENOMEM;\n\n\tpanel_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, 0);\n\tif (IS_ERR(panel_bridge))\n\t\treturn PTR_ERR(panel_bridge);\n\n\tps8622->panel_bridge = panel_bridge;\n\tps8622->client = client;\n\n\tps8622->v12 = devm_regulator_get(dev, \"vdd12\");\n\tif (IS_ERR(ps8622->v12)) {\n\t\tdev_info(dev, \"no 1.2v regulator found for PS8622\\n\");\n\t\tps8622->v12 = NULL;\n\t}\n\n\tps8622->gpio_slp = devm_gpiod_get(dev, \"sleep\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ps8622->gpio_slp)) {\n\t\tret = PTR_ERR(ps8622->gpio_slp);\n\t\tdev_err(dev, \"cannot get gpio_slp %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tps8622->gpio_rst = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ps8622->gpio_rst)) {\n\t\tret = PTR_ERR(ps8622->gpio_rst);\n\t\tdev_err(dev, \"cannot get gpio_rst %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tps8622->max_lane_count = id->driver_data;\n\n\tif (of_property_read_u32(dev->of_node, \"lane-count\",\n\t\t\t\t\t\t&ps8622->lane_count)) {\n\t\tps8622->lane_count = ps8622->max_lane_count;\n\t} else if (ps8622->lane_count > ps8622->max_lane_count) {\n\t\tdev_info(dev, \"lane-count property is too high,\"\n\t\t\t\t\t\t\"using max_lane_count\\n\");\n\t\tps8622->lane_count = ps8622->max_lane_count;\n\t}\n\n\tif (!of_property_read_bool(dev->of_node, \"use-external-pwm\")) {\n\t\tps8622->bl = backlight_device_register(\"ps8622-backlight\",\n\t\t\t\tdev, ps8622, &ps8622_backlight_ops,\n\t\t\t\tNULL);\n\t\tif (IS_ERR(ps8622->bl)) {\n\t\t\tDRM_ERROR(\"failed to register backlight\\n\");\n\t\t\tret = PTR_ERR(ps8622->bl);\n\t\t\tps8622->bl = NULL;\n\t\t\treturn ret;\n\t\t}\n\t\tps8622->bl->props.max_brightness = PS8622_MAX_BRIGHTNESS;\n\t\tps8622->bl->props.brightness = PS8622_MAX_BRIGHTNESS;\n\t}\n\n\tps8622->bridge.funcs = &ps8622_bridge_funcs;\n\tps8622->bridge.type = DRM_MODE_CONNECTOR_LVDS;\n\tps8622->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&ps8622->bridge);\n\n\ti2c_set_clientdata(client, ps8622);\n\n\treturn 0;\n}\n\nstatic void ps8622_remove(struct i2c_client *client)\n{\n\tstruct ps8622_bridge *ps8622 = i2c_get_clientdata(client);\n\n\tbacklight_device_unregister(ps8622->bl);\n\tdrm_bridge_remove(&ps8622->bridge);\n}\n\nstatic const struct i2c_device_id ps8622_i2c_table[] = {\n\t \n\t{\"ps8622\", 1},\n\t{\"ps8625\", 2},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ps8622_i2c_table);\n\nstatic struct i2c_driver ps8622_driver = {\n\t.id_table\t= ps8622_i2c_table,\n\t.probe\t\t= ps8622_probe,\n\t.remove\t\t= ps8622_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ps8622\",\n\t\t.of_match_table = ps8622_devices,\n\t},\n};\nmodule_i2c_driver(ps8622_driver);\n\nMODULE_AUTHOR(\"Vincent Palatin <vpalatin@chromium.org>\");\nMODULE_DESCRIPTION(\"Parade ps8622/ps8625 eDP-LVDS converter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}