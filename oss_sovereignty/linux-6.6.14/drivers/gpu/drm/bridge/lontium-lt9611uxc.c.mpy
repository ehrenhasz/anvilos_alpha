{
  "module_name": "lontium-lt9611uxc.c",
  "hash_id": "479ce9c90402575cbbecaf1f2d03b183639c1bb1d43bb9309306872b9c65b3e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/lontium-lt9611uxc.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include <sound/hdmi-codec.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define EDID_BLOCK_SIZE\t128\n#define EDID_NUM_BLOCKS\t2\n\n#define FW_FILE \"lt9611uxc_fw.bin\"\n\nstruct lt9611uxc {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_connector connector;\n\n\tstruct regmap *regmap;\n\t \n\tstruct mutex ocm_lock;\n\n\tstruct wait_queue_head wq;\n\tstruct work_struct work;\n\n\tstruct device_node *dsi0_node;\n\tstruct device_node *dsi1_node;\n\tstruct mipi_dsi_device *dsi0;\n\tstruct mipi_dsi_device *dsi1;\n\tstruct platform_device *audio_pdev;\n\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *enable_gpio;\n\n\tstruct regulator_bulk_data supplies[2];\n\n\tstruct i2c_client *client;\n\n\tbool hpd_supported;\n\tbool edid_read;\n\t \n\tbool hdmi_connected;\n\tuint8_t fw_version;\n};\n\n#define LT9611_PAGE_CONTROL\t0xff\n\nstatic const struct regmap_range_cfg lt9611uxc_ranges[] = {\n\t{\n\t\t.name = \"register_range\",\n\t\t.range_min =  0,\n\t\t.range_max = 0xd0ff,\n\t\t.selector_reg = LT9611_PAGE_CONTROL,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 0x100,\n\t},\n};\n\nstatic const struct regmap_config lt9611uxc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xffff,\n\t.ranges = lt9611uxc_ranges,\n\t.num_ranges = ARRAY_SIZE(lt9611uxc_ranges),\n};\n\nstruct lt9611uxc_mode {\n\tu16 hdisplay;\n\tu16 vdisplay;\n\tu8 vrefresh;\n};\n\n \nstatic struct lt9611uxc_mode lt9611uxc_modes[] = {\n\t{ 1920, 1080, 60 },\n\t{ 1920, 1080, 30 },\n\t{ 1920, 1080, 25 },\n\t{ 1366, 768, 60 },\n\t{ 1360, 768, 60 },\n\t{ 1280, 1024, 60 },\n\t{ 1280, 800, 60 },\n\t{ 1280, 720, 60 },\n\t{ 1280, 720, 50 },\n\t{ 1280, 720, 30 },\n\t{ 1152, 864, 60 },\n\t{ 1024, 768, 60 },\n\t{ 800, 600, 60 },\n\t{ 720, 576, 50 },\n\t{ 720, 480, 60 },\n\t{ 640, 480, 60 },\n};\n\nstatic struct lt9611uxc *bridge_to_lt9611uxc(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct lt9611uxc, bridge);\n}\n\nstatic struct lt9611uxc *connector_to_lt9611uxc(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct lt9611uxc, connector);\n}\n\nstatic void lt9611uxc_lock(struct lt9611uxc *lt9611uxc)\n{\n\tmutex_lock(&lt9611uxc->ocm_lock);\n\tregmap_write(lt9611uxc->regmap, 0x80ee, 0x01);\n}\n\nstatic void lt9611uxc_unlock(struct lt9611uxc *lt9611uxc)\n{\n\tregmap_write(lt9611uxc->regmap, 0x80ee, 0x00);\n\tmsleep(50);\n\tmutex_unlock(&lt9611uxc->ocm_lock);\n}\n\nstatic irqreturn_t lt9611uxc_irq_thread_handler(int irq, void *dev_id)\n{\n\tstruct lt9611uxc *lt9611uxc = dev_id;\n\tunsigned int irq_status = 0;\n\tunsigned int hpd_status = 0;\n\n\tlt9611uxc_lock(lt9611uxc);\n\n\tregmap_read(lt9611uxc->regmap, 0xb022, &irq_status);\n\tregmap_read(lt9611uxc->regmap, 0xb023, &hpd_status);\n\tif (irq_status)\n\t\tregmap_write(lt9611uxc->regmap, 0xb022, 0);\n\n\tif (irq_status & BIT(0)) {\n\t\tlt9611uxc->edid_read = !!(hpd_status & BIT(0));\n\t\twake_up_all(&lt9611uxc->wq);\n\t}\n\n\tif (irq_status & BIT(1)) {\n\t\tlt9611uxc->hdmi_connected = hpd_status & BIT(1);\n\t\tschedule_work(&lt9611uxc->work);\n\t}\n\n\tlt9611uxc_unlock(lt9611uxc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void lt9611uxc_hpd_work(struct work_struct *work)\n{\n\tstruct lt9611uxc *lt9611uxc = container_of(work, struct lt9611uxc, work);\n\tbool connected;\n\n\tif (lt9611uxc->connector.dev) {\n\t\tif (lt9611uxc->connector.dev->mode_config.funcs)\n\t\t\tdrm_kms_helper_hotplug_event(lt9611uxc->connector.dev);\n\t} else {\n\n\t\tmutex_lock(&lt9611uxc->ocm_lock);\n\t\tconnected = lt9611uxc->hdmi_connected;\n\t\tmutex_unlock(&lt9611uxc->ocm_lock);\n\n\t\tdrm_bridge_hpd_notify(&lt9611uxc->bridge,\n\t\t\t\t      connected ?\n\t\t\t\t      connector_status_connected :\n\t\t\t\t      connector_status_disconnected);\n\t}\n}\n\nstatic void lt9611uxc_reset(struct lt9611uxc *lt9611uxc)\n{\n\tgpiod_set_value_cansleep(lt9611uxc->reset_gpio, 1);\n\tmsleep(20);\n\n\tgpiod_set_value_cansleep(lt9611uxc->reset_gpio, 0);\n\tmsleep(20);\n\n\tgpiod_set_value_cansleep(lt9611uxc->reset_gpio, 1);\n\tmsleep(300);\n}\n\nstatic void lt9611uxc_assert_5v(struct lt9611uxc *lt9611uxc)\n{\n\tif (!lt9611uxc->enable_gpio)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(lt9611uxc->enable_gpio, 1);\n\tmsleep(20);\n}\n\nstatic int lt9611uxc_regulator_init(struct lt9611uxc *lt9611uxc)\n{\n\tint ret;\n\n\tlt9611uxc->supplies[0].supply = \"vdd\";\n\tlt9611uxc->supplies[1].supply = \"vcc\";\n\n\tret = devm_regulator_bulk_get(lt9611uxc->dev, 2, lt9611uxc->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regulator_set_load(lt9611uxc->supplies[0].consumer, 200000);\n}\n\nstatic int lt9611uxc_regulator_enable(struct lt9611uxc *lt9611uxc)\n{\n\tint ret;\n\n\tret = regulator_enable(lt9611uxc->supplies[0].consumer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 10000);  \n\n\tret = regulator_enable(lt9611uxc->supplies[1].consumer);\n\tif (ret < 0) {\n\t\tregulator_disable(lt9611uxc->supplies[0].consumer);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct lt9611uxc_mode *lt9611uxc_find_mode(const struct drm_display_mode *mode)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lt9611uxc_modes); i++) {\n\t\tif (lt9611uxc_modes[i].hdisplay == mode->hdisplay &&\n\t\t    lt9611uxc_modes[i].vdisplay == mode->vdisplay &&\n\t\t    lt9611uxc_modes[i].vrefresh == drm_mode_vrefresh(mode)) {\n\t\t\treturn &lt9611uxc_modes[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct mipi_dsi_device *lt9611uxc_attach_dsi(struct lt9611uxc *lt9611uxc,\n\t\t\t\t\t\t    struct device_node *dsi_node)\n{\n\tconst struct mipi_dsi_device_info info = { \"lt9611uxc\", 0, NULL };\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tstruct device *dev = lt9611uxc->dev;\n\tint ret;\n\n\thost = of_find_mipi_dsi_host_by_node(dsi_node);\n\tif (!host) {\n\t\tdev_err(dev, \"failed to find dsi host\\n\");\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi)) {\n\t\tdev_err(dev, \"failed to create dsi device\\n\");\n\t\treturn dsi;\n\t}\n\n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t  MIPI_DSI_MODE_VIDEO_HSE;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn dsi;\n}\n\nstatic int lt9611uxc_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct lt9611uxc *lt9611uxc = connector_to_lt9611uxc(connector);\n\tunsigned int count;\n\tstruct edid *edid;\n\n\tedid = lt9611uxc->bridge.funcs->get_edid(&lt9611uxc->bridge, connector);\n\tdrm_connector_update_edid_property(connector, edid);\n\tcount = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn count;\n}\n\nstatic enum drm_connector_status lt9611uxc_connector_detect(struct drm_connector *connector,\n\t\t\t\t\t\t\t    bool force)\n{\n\tstruct lt9611uxc *lt9611uxc = connector_to_lt9611uxc(connector);\n\n\treturn lt9611uxc->bridge.funcs->detect(&lt9611uxc->bridge);\n}\n\nstatic enum drm_mode_status lt9611uxc_connector_mode_valid(struct drm_connector *connector,\n\t\t\t\t\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct lt9611uxc_mode *lt9611uxc_mode = lt9611uxc_find_mode(mode);\n\n\treturn lt9611uxc_mode ? MODE_OK : MODE_BAD;\n}\n\nstatic const struct drm_connector_helper_funcs lt9611uxc_bridge_connector_helper_funcs = {\n\t.get_modes = lt9611uxc_connector_get_modes,\n\t.mode_valid = lt9611uxc_connector_mode_valid,\n};\n\nstatic const struct drm_connector_funcs lt9611uxc_bridge_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.detect = lt9611uxc_connector_detect,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int lt9611uxc_connector_init(struct drm_bridge *bridge, struct lt9611uxc *lt9611uxc)\n{\n\tint ret;\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tlt9611uxc->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\n\tdrm_connector_helper_add(&lt9611uxc->connector,\n\t\t\t\t &lt9611uxc_bridge_connector_helper_funcs);\n\tret = drm_connector_init(bridge->dev, &lt9611uxc->connector,\n\t\t\t\t &lt9611uxc_bridge_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_HDMIA);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\n\treturn drm_connector_attach_encoder(&lt9611uxc->connector, bridge->encoder);\n}\n\nstatic int lt9611uxc_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t   enum drm_bridge_attach_flags flags)\n{\n\tstruct lt9611uxc *lt9611uxc = bridge_to_lt9611uxc(bridge);\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {\n\t\tret = lt9611uxc_connector_init(bridge, lt9611uxc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\nlt9611uxc_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t    const struct drm_display_info *info,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct lt9611uxc_mode *lt9611uxc_mode;\n\n\tlt9611uxc_mode = lt9611uxc_find_mode(mode);\n\n\treturn lt9611uxc_mode ? MODE_OK : MODE_BAD;\n}\n\nstatic void lt9611uxc_video_setup(struct lt9611uxc *lt9611uxc,\n\t\t\t\t  const struct drm_display_mode *mode)\n{\n\tu32 h_total, hactive, hsync_len, hfront_porch;\n\tu32 v_total, vactive, vsync_len, vfront_porch;\n\n\th_total = mode->htotal;\n\tv_total = mode->vtotal;\n\n\thactive = mode->hdisplay;\n\thsync_len = mode->hsync_end - mode->hsync_start;\n\thfront_porch = mode->hsync_start - mode->hdisplay;\n\n\tvactive = mode->vdisplay;\n\tvsync_len = mode->vsync_end - mode->vsync_start;\n\tvfront_porch = mode->vsync_start - mode->vdisplay;\n\n\tregmap_write(lt9611uxc->regmap, 0xd00d, (u8)(v_total / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd00e, (u8)(v_total % 256));\n\n\tregmap_write(lt9611uxc->regmap, 0xd00f, (u8)(vactive / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd010, (u8)(vactive % 256));\n\n\tregmap_write(lt9611uxc->regmap, 0xd011, (u8)(h_total / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd012, (u8)(h_total % 256));\n\n\tregmap_write(lt9611uxc->regmap, 0xd013, (u8)(hactive / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd014, (u8)(hactive % 256));\n\n\tregmap_write(lt9611uxc->regmap, 0xd015, (u8)(vsync_len % 256));\n\n\tregmap_update_bits(lt9611uxc->regmap, 0xd016, 0xf, (u8)(hsync_len / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd017, (u8)(hsync_len % 256));\n\n\tregmap_update_bits(lt9611uxc->regmap, 0xd018, 0xf, (u8)(vfront_porch / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd019, (u8)(vfront_porch % 256));\n\n\tregmap_update_bits(lt9611uxc->regmap, 0xd01a, 0xf, (u8)(hfront_porch / 256));\n\tregmap_write(lt9611uxc->regmap, 0xd01b, (u8)(hfront_porch % 256));\n}\n\nstatic void lt9611uxc_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t      const struct drm_display_mode *adj_mode)\n{\n\tstruct lt9611uxc *lt9611uxc = bridge_to_lt9611uxc(bridge);\n\n\tlt9611uxc_lock(lt9611uxc);\n\tlt9611uxc_video_setup(lt9611uxc, mode);\n\tlt9611uxc_unlock(lt9611uxc);\n}\n\nstatic enum drm_connector_status lt9611uxc_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct lt9611uxc *lt9611uxc = bridge_to_lt9611uxc(bridge);\n\tunsigned int reg_val = 0;\n\tint ret;\n\tbool connected = true;\n\n\tlt9611uxc_lock(lt9611uxc);\n\n\tif (lt9611uxc->hpd_supported) {\n\t\tret = regmap_read(lt9611uxc->regmap, 0xb023, &reg_val);\n\n\t\tif (ret)\n\t\t\tdev_err(lt9611uxc->dev, \"failed to read hpd status: %d\\n\", ret);\n\t\telse\n\t\t\tconnected  = reg_val & BIT(1);\n\t}\n\tlt9611uxc->hdmi_connected = connected;\n\n\tlt9611uxc_unlock(lt9611uxc);\n\n\treturn connected ?  connector_status_connected :\n\t\t\t\tconnector_status_disconnected;\n}\n\nstatic int lt9611uxc_wait_for_edid(struct lt9611uxc *lt9611uxc)\n{\n\treturn wait_event_interruptible_timeout(lt9611uxc->wq, lt9611uxc->edid_read,\n\t\t\tmsecs_to_jiffies(500));\n}\n\nstatic int lt9611uxc_get_edid_block(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct lt9611uxc *lt9611uxc = data;\n\tint ret;\n\n\tif (len > EDID_BLOCK_SIZE)\n\t\treturn -EINVAL;\n\n\tif (block >= EDID_NUM_BLOCKS)\n\t\treturn -EINVAL;\n\n\tlt9611uxc_lock(lt9611uxc);\n\n\tregmap_write(lt9611uxc->regmap, 0xb00b, 0x10);\n\n\tregmap_write(lt9611uxc->regmap, 0xb00a, block * EDID_BLOCK_SIZE);\n\n\tret = regmap_noinc_read(lt9611uxc->regmap, 0xb0b0, buf, len);\n\tif (ret)\n\t\tdev_err(lt9611uxc->dev, \"edid read failed: %d\\n\", ret);\n\n\tlt9611uxc_unlock(lt9611uxc);\n\n\treturn 0;\n};\n\nstatic struct edid *lt9611uxc_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_connector *connector)\n{\n\tstruct lt9611uxc *lt9611uxc = bridge_to_lt9611uxc(bridge);\n\tint ret;\n\n\tret = lt9611uxc_wait_for_edid(lt9611uxc);\n\tif (ret < 0) {\n\t\tdev_err(lt9611uxc->dev, \"wait for EDID failed: %d\\n\", ret);\n\t\treturn NULL;\n\t} else if (ret == 0) {\n\t\tdev_err(lt9611uxc->dev, \"wait for EDID timeout\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn drm_do_get_edid(connector, lt9611uxc_get_edid_block, lt9611uxc);\n}\n\nstatic const struct drm_bridge_funcs lt9611uxc_bridge_funcs = {\n\t.attach = lt9611uxc_bridge_attach,\n\t.mode_valid = lt9611uxc_bridge_mode_valid,\n\t.mode_set = lt9611uxc_bridge_mode_set,\n\t.detect = lt9611uxc_bridge_detect,\n\t.get_edid = lt9611uxc_bridge_get_edid,\n};\n\nstatic int lt9611uxc_parse_dt(struct device *dev,\n\t\t\t      struct lt9611uxc *lt9611uxc)\n{\n\tlt9611uxc->dsi0_node = of_graph_get_remote_node(dev->of_node, 0, -1);\n\tif (!lt9611uxc->dsi0_node) {\n\t\tdev_err(lt9611uxc->dev, \"failed to get remote node for primary dsi\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlt9611uxc->dsi1_node = of_graph_get_remote_node(dev->of_node, 1, -1);\n\n\treturn 0;\n}\n\nstatic int lt9611uxc_gpio_init(struct lt9611uxc *lt9611uxc)\n{\n\tstruct device *dev = lt9611uxc->dev;\n\n\tlt9611uxc->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(lt9611uxc->reset_gpio)) {\n\t\tdev_err(dev, \"failed to acquire reset gpio\\n\");\n\t\treturn PTR_ERR(lt9611uxc->reset_gpio);\n\t}\n\n\tlt9611uxc->enable_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(lt9611uxc->enable_gpio)) {\n\t\tdev_err(dev, \"failed to acquire enable gpio\\n\");\n\t\treturn PTR_ERR(lt9611uxc->enable_gpio);\n\t}\n\n\treturn 0;\n}\n\nstatic int lt9611uxc_read_device_rev(struct lt9611uxc *lt9611uxc)\n{\n\tunsigned int rev0, rev1, rev2;\n\tint ret;\n\n\tlt9611uxc_lock(lt9611uxc);\n\n\tret = regmap_read(lt9611uxc->regmap, 0x8100, &rev0);\n\tret |= regmap_read(lt9611uxc->regmap, 0x8101, &rev1);\n\tret |= regmap_read(lt9611uxc->regmap, 0x8102, &rev2);\n\tif (ret)\n\t\tdev_err(lt9611uxc->dev, \"failed to read revision: %d\\n\", ret);\n\telse\n\t\tdev_info(lt9611uxc->dev, \"LT9611 revision: 0x%02x.%02x.%02x\\n\", rev0, rev1, rev2);\n\n\tlt9611uxc_unlock(lt9611uxc);\n\n\treturn ret;\n}\n\nstatic int lt9611uxc_read_version(struct lt9611uxc *lt9611uxc)\n{\n\tunsigned int rev;\n\tint ret;\n\n\tlt9611uxc_lock(lt9611uxc);\n\n\tret = regmap_read(lt9611uxc->regmap, 0xb021, &rev);\n\tif (ret)\n\t\tdev_err(lt9611uxc->dev, \"failed to read revision: %d\\n\", ret);\n\telse\n\t\tdev_info(lt9611uxc->dev, \"LT9611 version: 0x%02x\\n\", rev);\n\n\tlt9611uxc_unlock(lt9611uxc);\n\n\treturn ret < 0 ? ret : rev;\n}\n\nstatic int lt9611uxc_hdmi_hw_params(struct device *dev, void *data,\n\t\t\t\t    struct hdmi_codec_daifmt *fmt,\n\t\t\t\t    struct hdmi_codec_params *hparms)\n{\n\t \n\treturn 0;\n}\n\nstatic void lt9611uxc_audio_shutdown(struct device *dev, void *data)\n{\n}\n\nstatic int lt9611uxc_hdmi_i2s_get_dai_id(struct snd_soc_component *component,\n\t\t\t\t\t struct device_node *endpoint)\n{\n\tstruct of_endpoint of_ep;\n\tint ret;\n\n\tret = of_graph_parse_endpoint(endpoint, &of_ep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (of_ep.port == 2)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic const struct hdmi_codec_ops lt9611uxc_codec_ops = {\n\t.hw_params\t= lt9611uxc_hdmi_hw_params,\n\t.audio_shutdown = lt9611uxc_audio_shutdown,\n\t.get_dai_id\t= lt9611uxc_hdmi_i2s_get_dai_id,\n};\n\nstatic int lt9611uxc_audio_init(struct device *dev, struct lt9611uxc *lt9611uxc)\n{\n\tstruct hdmi_codec_pdata codec_data = {\n\t\t.ops = &lt9611uxc_codec_ops,\n\t\t.max_i2s_channels = 2,\n\t\t.i2s = 1,\n\t\t.data = lt9611uxc,\n\t};\n\n\tlt9611uxc->audio_pdev =\n\t\tplatform_device_register_data(dev, HDMI_CODEC_DRV_NAME,\n\t\t\t\t\t      PLATFORM_DEVID_AUTO,\n\t\t\t\t\t      &codec_data, sizeof(codec_data));\n\n\treturn PTR_ERR_OR_ZERO(lt9611uxc->audio_pdev);\n}\n\nstatic void lt9611uxc_audio_exit(struct lt9611uxc *lt9611uxc)\n{\n\tif (lt9611uxc->audio_pdev) {\n\t\tplatform_device_unregister(lt9611uxc->audio_pdev);\n\t\tlt9611uxc->audio_pdev = NULL;\n\t}\n}\n\n#define LT9611UXC_FW_PAGE_SIZE 32\nstatic void lt9611uxc_firmware_write_page(struct lt9611uxc *lt9611uxc, u16 addr, const u8 *buf)\n{\n\tstruct reg_sequence seq_write_prepare[] = {\n\t\tREG_SEQ0(0x805a, 0x04),\n\t\tREG_SEQ0(0x805a, 0x00),\n\n\t\tREG_SEQ0(0x805e, 0xdf),\n\t\tREG_SEQ0(0x805a, 0x20),\n\t\tREG_SEQ0(0x805a, 0x00),\n\t\tREG_SEQ0(0x8058, 0x21),\n\t};\n\n\tstruct reg_sequence seq_write_addr[] = {\n\t\tREG_SEQ0(0x805b, (addr >> 16) & 0xff),\n\t\tREG_SEQ0(0x805c, (addr >> 8) & 0xff),\n\t\tREG_SEQ0(0x805d, addr & 0xff),\n\t\tREG_SEQ0(0x805a, 0x10),\n\t\tREG_SEQ0(0x805a, 0x00),\n\t};\n\n\tregmap_write(lt9611uxc->regmap, 0x8108, 0xbf);\n\tmsleep(20);\n\tregmap_write(lt9611uxc->regmap, 0x8108, 0xff);\n\tmsleep(20);\n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_write_prepare, ARRAY_SIZE(seq_write_prepare));\n\tregmap_noinc_write(lt9611uxc->regmap, 0x8059, buf, LT9611UXC_FW_PAGE_SIZE);\n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_write_addr, ARRAY_SIZE(seq_write_addr));\n\tmsleep(20);\n}\n\nstatic void lt9611uxc_firmware_read_page(struct lt9611uxc *lt9611uxc, u16 addr, char *buf)\n{\n\tstruct reg_sequence seq_read_page[] = {\n\t\tREG_SEQ0(0x805a, 0xa0),\n\t\tREG_SEQ0(0x805a, 0x80),\n\t\tREG_SEQ0(0x805b, (addr >> 16) & 0xff),\n\t\tREG_SEQ0(0x805c, (addr >> 8) & 0xff),\n\t\tREG_SEQ0(0x805d, addr & 0xff),\n\t\tREG_SEQ0(0x805a, 0x90),\n\t\tREG_SEQ0(0x805a, 0x80),\n\t\tREG_SEQ0(0x8058, 0x21),\n\t};\n\n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_read_page, ARRAY_SIZE(seq_read_page));\n\tregmap_noinc_read(lt9611uxc->regmap, 0x805f, buf, LT9611UXC_FW_PAGE_SIZE);\n}\n\nstatic char *lt9611uxc_firmware_read(struct lt9611uxc *lt9611uxc, size_t size)\n{\n\tstruct reg_sequence seq_read_setup[] = {\n\t\tREG_SEQ0(0x805a, 0x84),\n\t\tREG_SEQ0(0x805a, 0x80),\n\t};\n\n\tchar *readbuf;\n\tu16 offset;\n\n\treadbuf = kzalloc(ALIGN(size, 32), GFP_KERNEL);\n\tif (!readbuf)\n\t\treturn NULL;\n\n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_read_setup, ARRAY_SIZE(seq_read_setup));\n\n\tfor (offset = 0;\n\t     offset < size;\n\t     offset += LT9611UXC_FW_PAGE_SIZE)\n\t\tlt9611uxc_firmware_read_page(lt9611uxc, offset, &readbuf[offset]);\n\n\treturn readbuf;\n}\n\nstatic int lt9611uxc_firmware_update(struct lt9611uxc *lt9611uxc)\n{\n\tint ret;\n\tu16 offset;\n\tsize_t remain;\n\tchar *readbuf;\n\tconst struct firmware *fw;\n\n\tstruct reg_sequence seq_setup[] = {\n\t\tREG_SEQ0(0x805e, 0xdf),\n\t\tREG_SEQ0(0x8058, 0x00),\n\t\tREG_SEQ0(0x8059, 0x50),\n\t\tREG_SEQ0(0x805a, 0x10),\n\t\tREG_SEQ0(0x805a, 0x00),\n\t};\n\n\n\tstruct reg_sequence seq_block_erase[] = {\n\t\tREG_SEQ0(0x805a, 0x04),\n\t\tREG_SEQ0(0x805a, 0x00),\n\t\tREG_SEQ0(0x805b, 0x00),\n\t\tREG_SEQ0(0x805c, 0x00),\n\t\tREG_SEQ0(0x805d, 0x00),\n\t\tREG_SEQ0(0x805a, 0x01),\n\t\tREG_SEQ0(0x805a, 0x00),\n\t};\n\n\tret = request_firmware(&fw, FW_FILE, lt9611uxc->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(lt9611uxc->dev, \"Updating firmware\\n\");\n\tlt9611uxc_lock(lt9611uxc);\n\n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_setup, ARRAY_SIZE(seq_setup));\n\n\t \n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_block_erase, ARRAY_SIZE(seq_block_erase));\n\tmsleep(3000);\n\tregmap_multi_reg_write(lt9611uxc->regmap, seq_block_erase, ARRAY_SIZE(seq_block_erase));\n\tmsleep(3000);\n\n\tfor (offset = 0, remain = fw->size;\n\t     remain >= LT9611UXC_FW_PAGE_SIZE;\n\t     offset += LT9611UXC_FW_PAGE_SIZE, remain -= LT9611UXC_FW_PAGE_SIZE)\n\t\tlt9611uxc_firmware_write_page(lt9611uxc, offset, fw->data + offset);\n\n\tif (remain > 0) {\n\t\tchar buf[LT9611UXC_FW_PAGE_SIZE];\n\n\t\tmemset(buf, 0xff, LT9611UXC_FW_PAGE_SIZE);\n\t\tmemcpy(buf, fw->data + offset, remain);\n\t\tlt9611uxc_firmware_write_page(lt9611uxc, offset, buf);\n\t}\n\tmsleep(20);\n\n\treadbuf = lt9611uxc_firmware_read(lt9611uxc, fw->size);\n\tif (!readbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (!memcmp(readbuf, fw->data, fw->size)) {\n\t\tdev_err(lt9611uxc->dev, \"Firmware update failed\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"fw: \", DUMP_PREFIX_OFFSET, 16, 1, readbuf, fw->size, false);\n\t\tret = -EINVAL;\n\t} else {\n\t\tdev_info(lt9611uxc->dev, \"Firmware updates successfully\\n\");\n\t\tret = 0;\n\t}\n\tkfree(readbuf);\n\nout:\n\tlt9611uxc_unlock(lt9611uxc);\n\tlt9611uxc_reset(lt9611uxc);\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic ssize_t lt9611uxc_firmware_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)\n{\n\tstruct lt9611uxc *lt9611uxc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = lt9611uxc_firmware_update(lt9611uxc);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic ssize_t lt9611uxc_firmware_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct lt9611uxc *lt9611uxc = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%02x\\n\", lt9611uxc->fw_version);\n}\n\nstatic DEVICE_ATTR_RW(lt9611uxc_firmware);\n\nstatic struct attribute *lt9611uxc_attrs[] = {\n\t&dev_attr_lt9611uxc_firmware.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lt9611uxc_attr_group = {\n\t.attrs = lt9611uxc_attrs,\n};\n\nstatic const struct attribute_group *lt9611uxc_attr_groups[] = {\n\t&lt9611uxc_attr_group,\n\tNULL,\n};\n\nstatic int lt9611uxc_probe(struct i2c_client *client)\n{\n\tstruct lt9611uxc *lt9611uxc;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\tbool fw_updated = false;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(dev, \"device doesn't support I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlt9611uxc = devm_kzalloc(dev, sizeof(*lt9611uxc), GFP_KERNEL);\n\tif (!lt9611uxc)\n\t\treturn -ENOMEM;\n\n\tlt9611uxc->dev = dev;\n\tlt9611uxc->client = client;\n\tmutex_init(&lt9611uxc->ocm_lock);\n\n\tlt9611uxc->regmap = devm_regmap_init_i2c(client, &lt9611uxc_regmap_config);\n\tif (IS_ERR(lt9611uxc->regmap)) {\n\t\tdev_err(lt9611uxc->dev, \"regmap i2c init failed\\n\");\n\t\treturn PTR_ERR(lt9611uxc->regmap);\n\t}\n\n\tret = lt9611uxc_parse_dt(dev, lt9611uxc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse device tree\\n\");\n\t\treturn ret;\n\t}\n\n\tret = lt9611uxc_gpio_init(lt9611uxc);\n\tif (ret < 0)\n\t\tgoto err_of_put;\n\n\tret = lt9611uxc_regulator_init(lt9611uxc);\n\tif (ret < 0)\n\t\tgoto err_of_put;\n\n\tlt9611uxc_assert_5v(lt9611uxc);\n\n\tret = lt9611uxc_regulator_enable(lt9611uxc);\n\tif (ret)\n\t\tgoto err_of_put;\n\n\tlt9611uxc_reset(lt9611uxc);\n\n\tret = lt9611uxc_read_device_rev(lt9611uxc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read chip rev\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\nretry:\n\tret = lt9611uxc_read_version(lt9611uxc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read FW version\\n\");\n\t\tgoto err_disable_regulators;\n\t} else if (ret == 0) {\n\t\tif (!fw_updated) {\n\t\t\tfw_updated = true;\n\t\t\tdev_err(dev, \"FW version 0, enforcing firmware update\\n\");\n\t\t\tret = lt9611uxc_firmware_update(lt9611uxc);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_disable_regulators;\n\t\t\telse\n\t\t\t\tgoto retry;\n\t\t} else {\n\t\t\tdev_err(dev, \"FW version 0, update failed\\n\");\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_disable_regulators;\n\t\t}\n\t} else if (ret < 0x40) {\n\t\tdev_info(dev, \"FW version 0x%x, HPD not supported\\n\", ret);\n\t} else {\n\t\tlt9611uxc->hpd_supported = true;\n\t}\n\tlt9611uxc->fw_version = ret;\n\n\tinit_waitqueue_head(&lt9611uxc->wq);\n\tINIT_WORK(&lt9611uxc->work, lt9611uxc_hpd_work);\n\n\tret = request_threaded_irq(client->irq, NULL,\n\t\t\t\t   lt9611uxc_irq_thread_handler,\n\t\t\t\t   IRQF_ONESHOT, \"lt9611uxc\", lt9611uxc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\ti2c_set_clientdata(client, lt9611uxc);\n\n\tlt9611uxc->bridge.funcs = &lt9611uxc_bridge_funcs;\n\tlt9611uxc->bridge.of_node = client->dev.of_node;\n\tlt9611uxc->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID;\n\tif (lt9611uxc->hpd_supported)\n\t\tlt9611uxc->bridge.ops |= DRM_BRIDGE_OP_HPD;\n\tlt9611uxc->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\n\tdrm_bridge_add(&lt9611uxc->bridge);\n\n\t \n\tlt9611uxc->dsi0 = lt9611uxc_attach_dsi(lt9611uxc, lt9611uxc->dsi0_node);\n\tif (IS_ERR(lt9611uxc->dsi0)) {\n\t\tret = PTR_ERR(lt9611uxc->dsi0);\n\t\tgoto err_remove_bridge;\n\t}\n\n\t \n\tif (lt9611uxc->dsi1_node) {\n\t\tlt9611uxc->dsi1 = lt9611uxc_attach_dsi(lt9611uxc, lt9611uxc->dsi1_node);\n\t\tif (IS_ERR(lt9611uxc->dsi1)) {\n\t\t\tret = PTR_ERR(lt9611uxc->dsi1);\n\t\t\tgoto err_remove_bridge;\n\t\t}\n\t}\n\n\treturn lt9611uxc_audio_init(dev, lt9611uxc);\n\nerr_remove_bridge:\n\tfree_irq(client->irq, lt9611uxc);\n\tcancel_work_sync(&lt9611uxc->work);\n\tdrm_bridge_remove(&lt9611uxc->bridge);\n\nerr_disable_regulators:\n\tregulator_bulk_disable(ARRAY_SIZE(lt9611uxc->supplies), lt9611uxc->supplies);\n\nerr_of_put:\n\tof_node_put(lt9611uxc->dsi1_node);\n\tof_node_put(lt9611uxc->dsi0_node);\n\n\treturn ret;\n}\n\nstatic void lt9611uxc_remove(struct i2c_client *client)\n{\n\tstruct lt9611uxc *lt9611uxc = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, lt9611uxc);\n\tcancel_work_sync(&lt9611uxc->work);\n\tlt9611uxc_audio_exit(lt9611uxc);\n\tdrm_bridge_remove(&lt9611uxc->bridge);\n\n\tmutex_destroy(&lt9611uxc->ocm_lock);\n\n\tregulator_bulk_disable(ARRAY_SIZE(lt9611uxc->supplies), lt9611uxc->supplies);\n\n\tof_node_put(lt9611uxc->dsi1_node);\n\tof_node_put(lt9611uxc->dsi0_node);\n}\n\nstatic struct i2c_device_id lt9611uxc_id[] = {\n\t{ \"lontium,lt9611uxc\", 0 },\n\t{   }\n};\n\nstatic const struct of_device_id lt9611uxc_match_table[] = {\n\t{ .compatible = \"lontium,lt9611uxc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, lt9611uxc_match_table);\n\nstatic struct i2c_driver lt9611uxc_driver = {\n\t.driver = {\n\t\t.name = \"lt9611uxc\",\n\t\t.of_match_table = lt9611uxc_match_table,\n\t\t.dev_groups = lt9611uxc_attr_groups,\n\t},\n\t.probe = lt9611uxc_probe,\n\t.remove = lt9611uxc_remove,\n\t.id_table = lt9611uxc_id,\n};\nmodule_i2c_driver(lt9611uxc_driver);\n\nMODULE_AUTHOR(\"Dmitry Baryshkov <dmitry.baryshkov@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n\nMODULE_FIRMWARE(FW_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}