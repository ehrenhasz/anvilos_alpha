{
  "module_name": "cros-ec-anx7688.c",
  "hash_id": "7b22502fc4ceba24fe4c39549d30c2278a6db701fb9f3f52697620f4bfb1223f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/cros-ec-anx7688.c",
  "human_readable_source": "\n \n\n#include <drm/drm_bridge.h>\n#include <drm/drm_print.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/types.h>\n\n \n#define ANX7688_VENDOR_ID_REG\t\t0x00\n#define ANX7688_DEVICE_ID_REG\t\t0x02\n\n#define ANX7688_FW_VERSION_REG\t\t0x80\n\n#define ANX7688_DP_BANDWIDTH_REG\t0x85\n#define ANX7688_DP_LANE_COUNT_REG\t0x86\n\n#define ANX7688_VENDOR_ID\t\t0x1f29\n#define ANX7688_DEVICE_ID\t\t0x7688\n\n \n#define ANX7688_MINIMUM_FW_VERSION\t0x0085\n\nstatic const struct regmap_config cros_ec_anx7688_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nstruct cros_ec_anx7688 {\n\tstruct i2c_client *client;\n\tstruct regmap *regmap;\n\tstruct drm_bridge bridge;\n\tbool filter;\n};\n\nstatic inline struct cros_ec_anx7688 *\nbridge_to_cros_ec_anx7688(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct cros_ec_anx7688, bridge);\n}\n\nstatic bool cros_ec_anx7688_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t\t      const struct drm_display_mode *mode,\n\t\t\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct cros_ec_anx7688 *anx = bridge_to_cros_ec_anx7688(bridge);\n\tint totalbw, requiredbw;\n\tu8 dpbw, lanecount;\n\tu8 regs[2];\n\tint ret;\n\n\tif (!anx->filter)\n\t\treturn true;\n\n\t \n\tret = regmap_bulk_read(anx->regmap, ANX7688_DP_BANDWIDTH_REG, regs, 2);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to read bandwidth/lane count\\n\");\n\t\treturn false;\n\t}\n\tdpbw = regs[0];\n\tlanecount = regs[1];\n\n\t \n\tif (dpbw > 0x19 || lanecount > 2) {\n\t\tDRM_ERROR(\"Invalid bandwidth/lane count (%02x/%d)\\n\", dpbw,\n\t\t\t  lanecount);\n\t\treturn false;\n\t}\n\n\t \n\ttotalbw = dpbw * lanecount * 270000 * 8 / 10;\n\n\t \n\trequiredbw = mode->clock * 8 * 3;\n\n\tDRM_DEBUG_KMS(\"DP bandwidth: %d kHz (%02x/%d); mode requires %d Khz\\n\",\n\t\t      totalbw, dpbw, lanecount, requiredbw);\n\n\tif (totalbw == 0) {\n\t\tDRM_ERROR(\"Bandwidth/lane count are 0, not rejecting modes\\n\");\n\t\treturn true;\n\t}\n\n\treturn totalbw >= requiredbw;\n}\n\nstatic const struct drm_bridge_funcs cros_ec_anx7688_bridge_funcs = {\n\t.mode_fixup = cros_ec_anx7688_bridge_mode_fixup,\n};\n\nstatic int cros_ec_anx7688_bridge_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct cros_ec_anx7688 *anx7688;\n\tu16 vendor, device, fw_version;\n\tu8 buffer[4];\n\tint ret;\n\n\tanx7688 = devm_kzalloc(dev, sizeof(*anx7688), GFP_KERNEL);\n\tif (!anx7688)\n\t\treturn -ENOMEM;\n\n\tanx7688->client = client;\n\ti2c_set_clientdata(client, anx7688);\n\n\tanx7688->regmap = devm_regmap_init_i2c(client, &cros_ec_anx7688_regmap_config);\n\tif (IS_ERR(anx7688->regmap)) {\n\t\tret = PTR_ERR(anx7688->regmap);\n\t\tdev_err(dev, \"regmap i2c init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_bulk_read(anx7688->regmap, ANX7688_VENDOR_ID_REG,\n\t\t\t       buffer, 4);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read chip vendor/device id\\n\");\n\t\treturn ret;\n\t}\n\n\tvendor = (u16)buffer[1] << 8 | buffer[0];\n\tdevice = (u16)buffer[3] << 8 | buffer[2];\n\tif (vendor != ANX7688_VENDOR_ID || device != ANX7688_DEVICE_ID) {\n\t\tdev_err(dev, \"Invalid vendor/device id %04x/%04x\\n\",\n\t\t\tvendor, device);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_bulk_read(anx7688->regmap, ANX7688_FW_VERSION_REG,\n\t\t\t       buffer, 2);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read firmware version\\n\");\n\t\treturn ret;\n\t}\n\n\tfw_version = (u16)buffer[0] << 8 | buffer[1];\n\tdev_info(dev, \"ANX7688 firmware version 0x%04x\\n\", fw_version);\n\n\tanx7688->bridge.of_node = dev->of_node;\n\n\t \n\tif (fw_version >= ANX7688_MINIMUM_FW_VERSION)\n\t\tanx7688->filter = true;\n\telse\n\t\t \n\t\tDRM_WARN(\"Old ANX7688 FW version (0x%04x), not filtering\\n\",\n\t\t\t fw_version);\n\n\tanx7688->bridge.funcs = &cros_ec_anx7688_bridge_funcs;\n\tdrm_bridge_add(&anx7688->bridge);\n\n\treturn 0;\n}\n\nstatic void cros_ec_anx7688_bridge_remove(struct i2c_client *client)\n{\n\tstruct cros_ec_anx7688 *anx7688 = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&anx7688->bridge);\n}\n\nstatic const struct of_device_id cros_ec_anx7688_bridge_match_table[] = {\n\t{ .compatible = \"google,cros-ec-anx7688\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cros_ec_anx7688_bridge_match_table);\n\nstatic struct i2c_driver cros_ec_anx7688_bridge_driver = {\n\t.probe = cros_ec_anx7688_bridge_probe,\n\t.remove = cros_ec_anx7688_bridge_remove,\n\t.driver = {\n\t\t.name = \"cros-ec-anx7688-bridge\",\n\t\t.of_match_table = cros_ec_anx7688_bridge_match_table,\n\t},\n};\n\nmodule_i2c_driver(cros_ec_anx7688_bridge_driver);\n\nMODULE_DESCRIPTION(\"ChromeOS EC ANX7688 HDMI->DP bridge driver\");\nMODULE_AUTHOR(\"Nicolas Boichat <drinkcat@chromium.org>\");\nMODULE_AUTHOR(\"Enric Balletbo i Serra <enric.balletbo@collabora.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}