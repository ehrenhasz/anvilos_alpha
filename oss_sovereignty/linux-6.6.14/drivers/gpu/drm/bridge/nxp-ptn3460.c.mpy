{
  "module_name": "nxp-ptn3460.c",
  "hash_id": "4a4cac29050c2174f7455db53685e7f2a76a9e3a2a55aea9a9cb3f3b2ef6a5f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/nxp-ptn3460.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define PTN3460_EDID_ADDR\t\t\t0x0\n#define PTN3460_EDID_EMULATION_ADDR\t\t0x84\n#define PTN3460_EDID_ENABLE_EMULATION\t\t0\n#define PTN3460_EDID_EMULATION_SELECTION\t1\n#define PTN3460_EDID_SRAM_LOAD_ADDR\t\t0x85\n\nstruct ptn3460_bridge {\n\tstruct drm_connector connector;\n\tstruct i2c_client *client;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *panel_bridge;\n\tstruct gpio_desc *gpio_pd_n;\n\tstruct gpio_desc *gpio_rst_n;\n\tu32 edid_emulation;\n\tbool enabled;\n};\n\nstatic inline struct ptn3460_bridge *\n\t\tbridge_to_ptn3460(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct ptn3460_bridge, bridge);\n}\n\nstatic inline struct ptn3460_bridge *\n\t\tconnector_to_ptn3460(struct drm_connector *connector)\n{\n\treturn container_of(connector, struct ptn3460_bridge, connector);\n}\n\nstatic int ptn3460_read_bytes(struct ptn3460_bridge *ptn_bridge, char addr,\n\t\tu8 *buf, int len)\n{\n\tint ret;\n\n\tret = i2c_master_send(ptn_bridge->client, &addr, 1);\n\tif (ret <= 0) {\n\t\tDRM_ERROR(\"Failed to send i2c command, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(ptn_bridge->client, buf, len);\n\tif (ret <= 0) {\n\t\tDRM_ERROR(\"Failed to recv i2c data, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptn3460_write_byte(struct ptn3460_bridge *ptn_bridge, char addr,\n\t\tchar val)\n{\n\tint ret;\n\tchar buf[2];\n\n\tbuf[0] = addr;\n\tbuf[1] = val;\n\n\tret = i2c_master_send(ptn_bridge->client, buf, ARRAY_SIZE(buf));\n\tif (ret <= 0) {\n\t\tDRM_ERROR(\"Failed to send i2c command, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptn3460_select_edid(struct ptn3460_bridge *ptn_bridge)\n{\n\tint ret;\n\tchar val;\n\n\t \n\tret = ptn3460_write_byte(ptn_bridge, PTN3460_EDID_SRAM_LOAD_ADDR,\n\t\t\tptn_bridge->edid_emulation);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to transfer EDID to sram, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tval = 1 << PTN3460_EDID_ENABLE_EMULATION |\n\t\tptn_bridge->edid_emulation << PTN3460_EDID_EMULATION_SELECTION;\n\n\tret = ptn3460_write_byte(ptn_bridge, PTN3460_EDID_EMULATION_ADDR, val);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to write EDID value, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ptn3460_pre_enable(struct drm_bridge *bridge)\n{\n\tstruct ptn3460_bridge *ptn_bridge = bridge_to_ptn3460(bridge);\n\tint ret;\n\n\tif (ptn_bridge->enabled)\n\t\treturn;\n\n\tgpiod_set_value(ptn_bridge->gpio_pd_n, 1);\n\n\tgpiod_set_value(ptn_bridge->gpio_rst_n, 0);\n\tusleep_range(10, 20);\n\tgpiod_set_value(ptn_bridge->gpio_rst_n, 1);\n\n\t \n\tmsleep(90);\n\n\tret = ptn3460_select_edid(ptn_bridge);\n\tif (ret)\n\t\tDRM_ERROR(\"Select EDID failed ret=%d\\n\", ret);\n\n\tptn_bridge->enabled = true;\n}\n\nstatic void ptn3460_disable(struct drm_bridge *bridge)\n{\n\tstruct ptn3460_bridge *ptn_bridge = bridge_to_ptn3460(bridge);\n\n\tif (!ptn_bridge->enabled)\n\t\treturn;\n\n\tptn_bridge->enabled = false;\n\n\tgpiod_set_value(ptn_bridge->gpio_rst_n, 1);\n\tgpiod_set_value(ptn_bridge->gpio_pd_n, 0);\n}\n\n\nstatic struct edid *ptn3460_get_edid(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_connector *connector)\n{\n\tstruct ptn3460_bridge *ptn_bridge = bridge_to_ptn3460(bridge);\n\tbool power_off;\n\tu8 *edid;\n\tint ret;\n\n\tpower_off = !ptn_bridge->enabled;\n\tptn3460_pre_enable(&ptn_bridge->bridge);\n\n\tedid = kmalloc(EDID_LENGTH, GFP_KERNEL);\n\tif (!edid) {\n\t\tDRM_ERROR(\"Failed to allocate EDID\\n\");\n\t\tgoto out;\n\t}\n\n\tret = ptn3460_read_bytes(ptn_bridge, PTN3460_EDID_ADDR, edid,\n\t\t\t\t EDID_LENGTH);\n\tif (ret) {\n\t\tkfree(edid);\n\t\tedid = NULL;\n\t\tgoto out;\n\t}\n\nout:\n\tif (power_off)\n\t\tptn3460_disable(&ptn_bridge->bridge);\n\n\treturn (struct edid *)edid;\n}\n\nstatic int ptn3460_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct ptn3460_bridge *ptn_bridge = connector_to_ptn3460(connector);\n\tstruct edid *edid;\n\tint num_modes;\n\n\tedid = ptn3460_get_edid(&ptn_bridge->bridge, connector);\n\tdrm_connector_update_edid_property(connector, edid);\n\tnum_modes = drm_add_edid_modes(connector, edid);\n\tkfree(edid);\n\n\treturn num_modes;\n}\n\nstatic const struct drm_connector_helper_funcs ptn3460_connector_helper_funcs = {\n\t.get_modes = ptn3460_connector_get_modes,\n};\n\nstatic const struct drm_connector_funcs ptn3460_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int ptn3460_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct ptn3460_bridge *ptn_bridge = bridge_to_ptn3460(bridge);\n\tint ret;\n\n\t \n\tret = drm_bridge_attach(bridge->encoder, ptn_bridge->panel_bridge,\n\t\t\t\tbridge, flags | DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\tif (!bridge->encoder) {\n\t\tDRM_ERROR(\"Parent encoder object not found\");\n\t\treturn -ENODEV;\n\t}\n\n\tptn_bridge->connector.polled = DRM_CONNECTOR_POLL_HPD;\n\tret = drm_connector_init(bridge->dev, &ptn_bridge->connector,\n\t\t\t&ptn3460_connector_funcs, DRM_MODE_CONNECTOR_LVDS);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to initialize connector with drm\\n\");\n\t\treturn ret;\n\t}\n\tdrm_connector_helper_add(&ptn_bridge->connector,\n\t\t\t\t\t&ptn3460_connector_helper_funcs);\n\tdrm_connector_register(&ptn_bridge->connector);\n\tdrm_connector_attach_encoder(&ptn_bridge->connector,\n\t\t\t\t\t\t\tbridge->encoder);\n\n\tdrm_helper_hpd_irq_event(ptn_bridge->connector.dev);\n\n\treturn ret;\n}\n\nstatic const struct drm_bridge_funcs ptn3460_bridge_funcs = {\n\t.pre_enable = ptn3460_pre_enable,\n\t.disable = ptn3460_disable,\n\t.attach = ptn3460_bridge_attach,\n\t.get_edid = ptn3460_get_edid,\n};\n\nstatic int ptn3460_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ptn3460_bridge *ptn_bridge;\n\tstruct drm_bridge *panel_bridge;\n\tint ret;\n\n\tptn_bridge = devm_kzalloc(dev, sizeof(*ptn_bridge), GFP_KERNEL);\n\tif (!ptn_bridge) {\n\t\treturn -ENOMEM;\n\t}\n\n\tpanel_bridge = devm_drm_of_get_bridge(dev, dev->of_node, 0, 0);\n\tif (IS_ERR(panel_bridge))\n\t\treturn PTR_ERR(panel_bridge);\n\n\tptn_bridge->panel_bridge = panel_bridge;\n\tptn_bridge->client = client;\n\n\tptn_bridge->gpio_pd_n = devm_gpiod_get(&client->dev, \"powerdown\",\n\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(ptn_bridge->gpio_pd_n)) {\n\t\tret = PTR_ERR(ptn_bridge->gpio_pd_n);\n\t\tdev_err(dev, \"cannot get gpio_pd_n %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tptn_bridge->gpio_rst_n = devm_gpiod_get(&client->dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(ptn_bridge->gpio_rst_n)) {\n\t\tret = PTR_ERR(ptn_bridge->gpio_rst_n);\n\t\tDRM_ERROR(\"cannot get gpio_rst_n %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"edid-emulation\",\n\t\t\t&ptn_bridge->edid_emulation);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't read EDID emulation value\\n\");\n\t\treturn ret;\n\t}\n\n\tptn_bridge->bridge.funcs = &ptn3460_bridge_funcs;\n\tptn_bridge->bridge.ops = DRM_BRIDGE_OP_EDID;\n\tptn_bridge->bridge.type = DRM_MODE_CONNECTOR_LVDS;\n\tptn_bridge->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&ptn_bridge->bridge);\n\n\ti2c_set_clientdata(client, ptn_bridge);\n\n\treturn 0;\n}\n\nstatic void ptn3460_remove(struct i2c_client *client)\n{\n\tstruct ptn3460_bridge *ptn_bridge = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&ptn_bridge->bridge);\n}\n\nstatic const struct i2c_device_id ptn3460_i2c_table[] = {\n\t{\"ptn3460\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ptn3460_i2c_table);\n\nstatic const struct of_device_id ptn3460_match[] = {\n\t{ .compatible = \"nxp,ptn3460\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ptn3460_match);\n\nstatic struct i2c_driver ptn3460_driver = {\n\t.id_table\t= ptn3460_i2c_table,\n\t.probe\t\t= ptn3460_probe,\n\t.remove\t\t= ptn3460_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"nxp,ptn3460\",\n\t\t.of_match_table = ptn3460_match,\n\t},\n};\nmodule_i2c_driver(ptn3460_driver);\n\nMODULE_AUTHOR(\"Sean Paul <seanpaul@chromium.org>\");\nMODULE_DESCRIPTION(\"NXP ptn3460 eDP-LVDS converter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}