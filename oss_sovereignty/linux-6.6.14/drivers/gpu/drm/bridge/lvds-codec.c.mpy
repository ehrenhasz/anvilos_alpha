{
  "module_name": "lvds-codec.c",
  "hash_id": "5ea0a0e445dd11acc247d3777af072c6aada17820b7b5cf979eee011359a0fca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/lvds-codec.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n\nstruct lvds_codec {\n\tstruct device *dev;\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *panel_bridge;\n\tstruct drm_bridge_timings timings;\n\tstruct regulator *vcc;\n\tstruct gpio_desc *powerdown_gpio;\n\tu32 connector_type;\n\tunsigned int bus_format;\n};\n\nstatic inline struct lvds_codec *to_lvds_codec(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct lvds_codec, bridge);\n}\n\nstatic int lvds_codec_attach(struct drm_bridge *bridge,\n\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct lvds_codec *lvds_codec = to_lvds_codec(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, lvds_codec->panel_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic void lvds_codec_enable(struct drm_bridge *bridge)\n{\n\tstruct lvds_codec *lvds_codec = to_lvds_codec(bridge);\n\tint ret;\n\n\tret = regulator_enable(lvds_codec->vcc);\n\tif (ret) {\n\t\tdev_err(lvds_codec->dev,\n\t\t\t\"Failed to enable regulator \\\"vcc\\\": %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (lvds_codec->powerdown_gpio)\n\t\tgpiod_set_value_cansleep(lvds_codec->powerdown_gpio, 0);\n}\n\nstatic void lvds_codec_disable(struct drm_bridge *bridge)\n{\n\tstruct lvds_codec *lvds_codec = to_lvds_codec(bridge);\n\tint ret;\n\n\tif (lvds_codec->powerdown_gpio)\n\t\tgpiod_set_value_cansleep(lvds_codec->powerdown_gpio, 1);\n\n\tret = regulator_disable(lvds_codec->vcc);\n\tif (ret)\n\t\tdev_err(lvds_codec->dev,\n\t\t\t\"Failed to disable regulator \\\"vcc\\\": %d\\n\", ret);\n}\n\nstatic const struct drm_bridge_funcs funcs = {\n\t.attach = lvds_codec_attach,\n\t.enable = lvds_codec_enable,\n\t.disable = lvds_codec_disable,\n};\n\n#define MAX_INPUT_SEL_FORMATS 1\nstatic u32 *\nlvds_codec_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t     u32 output_fmt,\n\t\t\t\t     unsigned int *num_input_fmts)\n{\n\tstruct lvds_codec *lvds_codec = to_lvds_codec(bridge);\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\tinput_fmts[0] = lvds_codec->bus_format;\n\t*num_input_fmts = MAX_INPUT_SEL_FORMATS;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs funcs_decoder = {\n\t.attach = lvds_codec_attach,\n\t.enable = lvds_codec_enable,\n\t.disable = lvds_codec_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_get_input_bus_fmts = lvds_codec_atomic_get_input_bus_fmts,\n};\n\nstatic int lvds_codec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *panel_node;\n\tstruct device_node *bus_node;\n\tstruct drm_panel *panel;\n\tstruct lvds_codec *lvds_codec;\n\tu32 val;\n\tint ret;\n\n\tlvds_codec = devm_kzalloc(dev, sizeof(*lvds_codec), GFP_KERNEL);\n\tif (!lvds_codec)\n\t\treturn -ENOMEM;\n\n\tlvds_codec->dev = &pdev->dev;\n\tlvds_codec->connector_type = (uintptr_t)of_device_get_match_data(dev);\n\n\tlvds_codec->vcc = devm_regulator_get(lvds_codec->dev, \"power\");\n\tif (IS_ERR(lvds_codec->vcc))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvds_codec->vcc),\n\t\t\t\t     \"Unable to get \\\"vcc\\\" supply\\n\");\n\n\tlvds_codec->powerdown_gpio = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(lvds_codec->powerdown_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(lvds_codec->powerdown_gpio),\n\t\t\t\t     \"powerdown GPIO failure\\n\");\n\n\t \n\tpanel_node = of_graph_get_remote_node(dev->of_node, 1, 0);\n\tif (!panel_node) {\n\t\tdev_dbg(dev, \"panel DT node not found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tpanel = of_drm_find_panel(panel_node);\n\tof_node_put(panel_node);\n\tif (IS_ERR(panel)) {\n\t\tdev_dbg(dev, \"panel not found, deferring probe\\n\");\n\t\treturn PTR_ERR(panel);\n\t}\n\n\tlvds_codec->panel_bridge =\n\t\tdevm_drm_panel_bridge_add_typed(dev, panel,\n\t\t\t\t\t\tlvds_codec->connector_type);\n\tif (IS_ERR(lvds_codec->panel_bridge))\n\t\treturn PTR_ERR(lvds_codec->panel_bridge);\n\n\tlvds_codec->bridge.funcs = &funcs;\n\n\t \n\tif (lvds_codec->connector_type != DRM_MODE_CONNECTOR_LVDS) {\n\t\tbus_node = of_graph_get_endpoint_by_regs(dev->of_node, 0, 0);\n\t\tif (!bus_node) {\n\t\t\tdev_dbg(dev, \"bus DT node not found\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\n\t\tret = drm_of_lvds_get_data_mapping(bus_node);\n\t\tof_node_put(bus_node);\n\t\tif (ret == -ENODEV) {\n\t\t\tdev_warn(dev, \"missing 'data-mapping' DT property\\n\");\n\t\t} else if (ret < 0) {\n\t\t\tdev_err(dev, \"invalid 'data-mapping' DT property\\n\");\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tlvds_codec->bus_format = ret;\n\t\t\tlvds_codec->bridge.funcs = &funcs_decoder;\n\t\t}\n\t}\n\n\t \n\tif (lvds_codec->connector_type == DRM_MODE_CONNECTOR_LVDS &&\n\t    !of_property_read_u32(dev->of_node, \"pclk-sample\", &val)) {\n\t\tlvds_codec->timings.input_bus_flags = val ?\n\t\t\tDRM_BUS_FLAG_PIXDATA_SAMPLE_POSEDGE :\n\t\t\tDRM_BUS_FLAG_PIXDATA_SAMPLE_NEGEDGE;\n\t}\n\n\t \n\tlvds_codec->bridge.of_node = dev->of_node;\n\tlvds_codec->bridge.timings = &lvds_codec->timings;\n\tdrm_bridge_add(&lvds_codec->bridge);\n\n\tplatform_set_drvdata(pdev, lvds_codec);\n\n\treturn 0;\n}\n\nstatic void lvds_codec_remove(struct platform_device *pdev)\n{\n\tstruct lvds_codec *lvds_codec = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&lvds_codec->bridge);\n}\n\nstatic const struct of_device_id lvds_codec_match[] = {\n\t{\n\t\t.compatible = \"lvds-decoder\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_DPI,\n\t},\n\t{\n\t\t.compatible = \"lvds-encoder\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_LVDS,\n\t},\n\t{\n\t\t.compatible = \"thine,thc63lvdm83d\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_LVDS,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lvds_codec_match);\n\nstatic struct platform_driver lvds_codec_driver = {\n\t.probe\t= lvds_codec_probe,\n\t.remove_new = lvds_codec_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"lvds-codec\",\n\t\t.of_match_table\t= lvds_codec_match,\n\t},\n};\nmodule_platform_driver(lvds_codec_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"LVDS encoders and decoders\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}