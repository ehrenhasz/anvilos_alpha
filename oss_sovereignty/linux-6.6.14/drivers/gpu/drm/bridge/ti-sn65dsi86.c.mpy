{
  "module_name": "ti-sn65dsi86.c",
  "hash_id": "666a7b6b791890713bc9b1107609958821bfca4faeb20f2d9078927b92b51a88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ti-sn65dsi86.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/auxiliary_bus.h>\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/pm_runtime.h>\n#include <linux/pwm.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <asm/unaligned.h>\n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define SN_DEVICE_REV_REG\t\t\t0x08\n#define SN_DPPLL_SRC_REG\t\t\t0x0A\n#define  DPPLL_CLK_SRC_DSICLK\t\t\tBIT(0)\n#define  REFCLK_FREQ_MASK\t\t\tGENMASK(3, 1)\n#define  REFCLK_FREQ(x)\t\t\t\t((x) << 1)\n#define  DPPLL_SRC_DP_PLL_LOCK\t\t\tBIT(7)\n#define SN_PLL_ENABLE_REG\t\t\t0x0D\n#define SN_DSI_LANES_REG\t\t\t0x10\n#define  CHA_DSI_LANES_MASK\t\t\tGENMASK(4, 3)\n#define  CHA_DSI_LANES(x)\t\t\t((x) << 3)\n#define SN_DSIA_CLK_FREQ_REG\t\t\t0x12\n#define SN_CHA_ACTIVE_LINE_LENGTH_LOW_REG\t0x20\n#define SN_CHA_VERTICAL_DISPLAY_SIZE_LOW_REG\t0x24\n#define SN_CHA_HSYNC_PULSE_WIDTH_LOW_REG\t0x2C\n#define SN_CHA_HSYNC_PULSE_WIDTH_HIGH_REG\t0x2D\n#define  CHA_HSYNC_POLARITY\t\t\tBIT(7)\n#define SN_CHA_VSYNC_PULSE_WIDTH_LOW_REG\t0x30\n#define SN_CHA_VSYNC_PULSE_WIDTH_HIGH_REG\t0x31\n#define  CHA_VSYNC_POLARITY\t\t\tBIT(7)\n#define SN_CHA_HORIZONTAL_BACK_PORCH_REG\t0x34\n#define SN_CHA_VERTICAL_BACK_PORCH_REG\t\t0x36\n#define SN_CHA_HORIZONTAL_FRONT_PORCH_REG\t0x38\n#define SN_CHA_VERTICAL_FRONT_PORCH_REG\t\t0x3A\n#define SN_LN_ASSIGN_REG\t\t\t0x59\n#define  LN_ASSIGN_WIDTH\t\t\t2\n#define SN_ENH_FRAME_REG\t\t\t0x5A\n#define  VSTREAM_ENABLE\t\t\t\tBIT(3)\n#define  LN_POLRS_OFFSET\t\t\t4\n#define  LN_POLRS_MASK\t\t\t\t0xf0\n#define SN_DATA_FORMAT_REG\t\t\t0x5B\n#define  BPP_18_RGB\t\t\t\tBIT(0)\n#define SN_HPD_DISABLE_REG\t\t\t0x5C\n#define  HPD_DISABLE\t\t\t\tBIT(0)\n#define  HPD_DEBOUNCED_STATE\t\t\tBIT(4)\n#define SN_GPIO_IO_REG\t\t\t\t0x5E\n#define  SN_GPIO_INPUT_SHIFT\t\t\t4\n#define  SN_GPIO_OUTPUT_SHIFT\t\t\t0\n#define SN_GPIO_CTRL_REG\t\t\t0x5F\n#define  SN_GPIO_MUX_INPUT\t\t\t0\n#define  SN_GPIO_MUX_OUTPUT\t\t\t1\n#define  SN_GPIO_MUX_SPECIAL\t\t\t2\n#define  SN_GPIO_MUX_MASK\t\t\t0x3\n#define SN_AUX_WDATA_REG(x)\t\t\t(0x64 + (x))\n#define SN_AUX_ADDR_19_16_REG\t\t\t0x74\n#define SN_AUX_ADDR_15_8_REG\t\t\t0x75\n#define SN_AUX_ADDR_7_0_REG\t\t\t0x76\n#define SN_AUX_ADDR_MASK\t\t\tGENMASK(19, 0)\n#define SN_AUX_LENGTH_REG\t\t\t0x77\n#define SN_AUX_CMD_REG\t\t\t\t0x78\n#define  AUX_CMD_SEND\t\t\t\tBIT(0)\n#define  AUX_CMD_REQ(x)\t\t\t\t((x) << 4)\n#define SN_AUX_RDATA_REG(x)\t\t\t(0x79 + (x))\n#define SN_SSC_CONFIG_REG\t\t\t0x93\n#define  DP_NUM_LANES_MASK\t\t\tGENMASK(5, 4)\n#define  DP_NUM_LANES(x)\t\t\t((x) << 4)\n#define SN_DATARATE_CONFIG_REG\t\t\t0x94\n#define  DP_DATARATE_MASK\t\t\tGENMASK(7, 5)\n#define  DP_DATARATE(x)\t\t\t\t((x) << 5)\n#define SN_TRAINING_SETTING_REG\t\t\t0x95\n#define  SCRAMBLE_DISABLE\t\t\tBIT(4)\n#define SN_ML_TX_MODE_REG\t\t\t0x96\n#define  ML_TX_MAIN_LINK_OFF\t\t\t0\n#define  ML_TX_NORMAL_MODE\t\t\tBIT(0)\n#define SN_PWM_PRE_DIV_REG\t\t\t0xA0\n#define SN_BACKLIGHT_SCALE_REG\t\t\t0xA1\n#define  BACKLIGHT_SCALE_MAX\t\t\t0xFFFF\n#define SN_BACKLIGHT_REG\t\t\t0xA3\n#define SN_PWM_EN_INV_REG\t\t\t0xA5\n#define  SN_PWM_INV_MASK\t\t\tBIT(0)\n#define  SN_PWM_EN_MASK\t\t\t\tBIT(1)\n#define SN_AUX_CMD_STATUS_REG\t\t\t0xF4\n#define  AUX_IRQ_STATUS_AUX_RPLY_TOUT\t\tBIT(3)\n#define  AUX_IRQ_STATUS_AUX_SHORT\t\tBIT(5)\n#define  AUX_IRQ_STATUS_NAT_I2C_FAIL\t\tBIT(6)\n\n#define MIN_DSI_CLK_FREQ_MHZ\t40\n\n \n#define DP_CLK_FUDGE_NUM\t10\n#define DP_CLK_FUDGE_DEN\t8\n\n \n#define SN_AUX_MAX_PAYLOAD_BYTES\t16\n\n#define SN_REGULATOR_SUPPLY_NUM\t\t4\n\n#define SN_MAX_DP_LANES\t\t\t4\n#define SN_NUM_GPIOS\t\t\t4\n#define SN_GPIO_PHYSICAL_OFFSET\t\t1\n\n#define SN_LINK_TRAINING_TRIES\t\t10\n\n#define SN_PWM_GPIO_IDX\t\t\t3  \n\n \nstruct ti_sn65dsi86 {\n\tstruct auxiliary_device\t\t*bridge_aux;\n\tstruct auxiliary_device\t\t*gpio_aux;\n\tstruct auxiliary_device\t\t*aux_aux;\n\tstruct auxiliary_device\t\t*pwm_aux;\n\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct drm_dp_aux\t\taux;\n\tstruct drm_bridge\t\tbridge;\n\tstruct drm_connector\t\t*connector;\n\tstruct device_node\t\t*host_node;\n\tstruct mipi_dsi_device\t\t*dsi;\n\tstruct clk\t\t\t*refclk;\n\tstruct drm_bridge\t\t*next_bridge;\n\tstruct gpio_desc\t\t*enable_gpio;\n\tstruct regulator_bulk_data\tsupplies[SN_REGULATOR_SUPPLY_NUM];\n\tint\t\t\t\tdp_lanes;\n\tu8\t\t\t\tln_assign;\n\tu8\t\t\t\tln_polrs;\n\tbool\t\t\t\tcomms_enabled;\n\tstruct mutex\t\t\tcomms_mutex;\n\n#if defined(CONFIG_OF_GPIO)\n\tstruct gpio_chip\t\tgchip;\n\tDECLARE_BITMAP(gchip_output, SN_NUM_GPIOS);\n#endif\n#if defined(CONFIG_PWM)\n\tstruct pwm_chip\t\t\tpchip;\n\tbool\t\t\t\tpwm_enabled;\n\tatomic_t\t\t\tpwm_pin_busy;\n#endif\n\tunsigned int\t\t\tpwm_refclk_freq;\n};\n\nstatic const struct regmap_range ti_sn65dsi86_volatile_ranges[] = {\n\t{ .range_min = 0, .range_max = 0xFF },\n};\n\nstatic const struct regmap_access_table ti_sn_bridge_volatile_table = {\n\t.yes_ranges = ti_sn65dsi86_volatile_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(ti_sn65dsi86_volatile_ranges),\n};\n\nstatic const struct regmap_config ti_sn65dsi86_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_table = &ti_sn_bridge_volatile_table,\n\t.cache_type = REGCACHE_NONE,\n\t.max_register = 0xFF,\n};\n\nstatic int __maybe_unused ti_sn65dsi86_read_u16(struct ti_sn65dsi86 *pdata,\n\t\t\t\t\t\tunsigned int reg, u16 *val)\n{\n\tu8 buf[2];\n\tint ret;\n\n\tret = regmap_bulk_read(pdata->regmap, reg, buf, ARRAY_SIZE(buf));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = buf[0] | (buf[1] << 8);\n\n\treturn 0;\n}\n\nstatic void ti_sn65dsi86_write_u16(struct ti_sn65dsi86 *pdata,\n\t\t\t\t   unsigned int reg, u16 val)\n{\n\tu8 buf[2] = { val & 0xff, val >> 8 };\n\n\tregmap_bulk_write(pdata->regmap, reg, buf, ARRAY_SIZE(buf));\n}\n\nstatic u32 ti_sn_bridge_get_dsi_freq(struct ti_sn65dsi86 *pdata)\n{\n\tu32 bit_rate_khz, clk_freq_khz;\n\tstruct drm_display_mode *mode =\n\t\t&pdata->bridge.encoder->crtc->state->adjusted_mode;\n\n\tbit_rate_khz = mode->clock *\n\t\t\tmipi_dsi_pixel_format_to_bpp(pdata->dsi->format);\n\tclk_freq_khz = bit_rate_khz / (pdata->dsi->lanes * 2);\n\n\treturn clk_freq_khz;\n}\n\n \nstatic const u32 ti_sn_bridge_refclk_lut[] = {\n\t12000000,\n\t19200000,\n\t26000000,\n\t27000000,\n\t38400000,\n};\n\n \nstatic const u32 ti_sn_bridge_dsiclk_lut[] = {\n\t468000000,\n\t384000000,\n\t416000000,\n\t486000000,\n\t460800000,\n};\n\nstatic void ti_sn_bridge_set_refclk_freq(struct ti_sn65dsi86 *pdata)\n{\n\tint i;\n\tu32 refclk_rate;\n\tconst u32 *refclk_lut;\n\tsize_t refclk_lut_size;\n\n\tif (pdata->refclk) {\n\t\trefclk_rate = clk_get_rate(pdata->refclk);\n\t\trefclk_lut = ti_sn_bridge_refclk_lut;\n\t\trefclk_lut_size = ARRAY_SIZE(ti_sn_bridge_refclk_lut);\n\t\tclk_prepare_enable(pdata->refclk);\n\t} else {\n\t\trefclk_rate = ti_sn_bridge_get_dsi_freq(pdata) * 1000;\n\t\trefclk_lut = ti_sn_bridge_dsiclk_lut;\n\t\trefclk_lut_size = ARRAY_SIZE(ti_sn_bridge_dsiclk_lut);\n\t}\n\n\t \n\tfor (i = 0; i < refclk_lut_size; i++)\n\t\tif (refclk_lut[i] == refclk_rate)\n\t\t\tbreak;\n\n\t \n\tif (i >= refclk_lut_size)\n\t\ti = 1;\n\n\tregmap_update_bits(pdata->regmap, SN_DPPLL_SRC_REG, REFCLK_FREQ_MASK,\n\t\t\t   REFCLK_FREQ(i));\n\n\t \n\tpdata->pwm_refclk_freq = ti_sn_bridge_refclk_lut[i];\n}\n\nstatic void ti_sn65dsi86_enable_comms(struct ti_sn65dsi86 *pdata)\n{\n\tmutex_lock(&pdata->comms_mutex);\n\n\t \n\tti_sn_bridge_set_refclk_freq(pdata);\n\n\t \n\tregmap_update_bits(pdata->regmap, SN_HPD_DISABLE_REG, HPD_DISABLE,\n\t\t\t   HPD_DISABLE);\n\n\tpdata->comms_enabled = true;\n\n\tmutex_unlock(&pdata->comms_mutex);\n}\n\nstatic void ti_sn65dsi86_disable_comms(struct ti_sn65dsi86 *pdata)\n{\n\tmutex_lock(&pdata->comms_mutex);\n\n\tpdata->comms_enabled = false;\n\tclk_disable_unprepare(pdata->refclk);\n\n\tmutex_unlock(&pdata->comms_mutex);\n}\n\nstatic int __maybe_unused ti_sn65dsi86_resume(struct device *dev)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(SN_REGULATOR_SUPPLY_NUM, pdata->supplies);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to enable supplies %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(100, 110);\n\n\tgpiod_set_value_cansleep(pdata->enable_gpio, 1);\n\n\t \n\tif (pdata->refclk)\n\t\tti_sn65dsi86_enable_comms(pdata);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused ti_sn65dsi86_suspend(struct device *dev)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (pdata->refclk)\n\t\tti_sn65dsi86_disable_comms(pdata);\n\n\tgpiod_set_value_cansleep(pdata->enable_gpio, 0);\n\n\tret = regulator_bulk_disable(SN_REGULATOR_SUPPLY_NUM, pdata->supplies);\n\tif (ret)\n\t\tDRM_ERROR(\"failed to disable supplies %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops ti_sn65dsi86_pm_ops = {\n\tSET_RUNTIME_PM_OPS(ti_sn65dsi86_suspend, ti_sn65dsi86_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic int status_show(struct seq_file *s, void *data)\n{\n\tstruct ti_sn65dsi86 *pdata = s->private;\n\tunsigned int reg, val;\n\n\tseq_puts(s, \"STATUS REGISTERS:\\n\");\n\n\tpm_runtime_get_sync(pdata->dev);\n\n\t \n\tfor (reg = 0xf0; reg <= 0xf8; reg++) {\n\t\tregmap_read(pdata->regmap, reg, &val);\n\t\tseq_printf(s, \"[0x%02x] = 0x%08x\\n\", reg, val);\n\t}\n\n\tpm_runtime_put_autosuspend(pdata->dev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(status);\n\nstatic void ti_sn65dsi86_debugfs_remove(void *data)\n{\n\tdebugfs_remove_recursive(data);\n}\n\nstatic void ti_sn65dsi86_debugfs_init(struct ti_sn65dsi86 *pdata)\n{\n\tstruct device *dev = pdata->dev;\n\tstruct dentry *debugfs;\n\tint ret;\n\n\tdebugfs = debugfs_create_dir(dev_name(dev), NULL);\n\n\t \n\tif (IS_ERR_OR_NULL(debugfs))\n\t\treturn;\n\n\tret = devm_add_action_or_reset(dev, ti_sn65dsi86_debugfs_remove, debugfs);\n\tif (ret)\n\t\treturn;\n\n\tdebugfs_create_file(\"status\", 0600, debugfs, pdata, &status_fops);\n}\n\n \n\nstatic void ti_sn65dsi86_uninit_aux(void *data)\n{\n\tauxiliary_device_uninit(data);\n}\n\nstatic void ti_sn65dsi86_delete_aux(void *data)\n{\n\tauxiliary_device_delete(data);\n}\n\nstatic void ti_sn65dsi86_aux_device_release(struct device *dev)\n{\n\tstruct auxiliary_device *aux = container_of(dev, struct auxiliary_device, dev);\n\n\tkfree(aux);\n}\n\nstatic int ti_sn65dsi86_add_aux_device(struct ti_sn65dsi86 *pdata,\n\t\t\t\t       struct auxiliary_device **aux_out,\n\t\t\t\t       const char *name)\n{\n\tstruct device *dev = pdata->dev;\n\tstruct auxiliary_device *aux;\n\tint ret;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL);\n\tif (!aux)\n\t\treturn -ENOMEM;\n\n\taux->name = name;\n\taux->dev.parent = dev;\n\taux->dev.release = ti_sn65dsi86_aux_device_release;\n\tdevice_set_of_node_from_dev(&aux->dev, dev);\n\tret = auxiliary_device_init(aux);\n\tif (ret) {\n\t\tkfree(aux);\n\t\treturn ret;\n\t}\n\tret = devm_add_action_or_reset(dev, ti_sn65dsi86_uninit_aux, aux);\n\tif (ret)\n\t\treturn ret;\n\n\tret = auxiliary_device_add(aux);\n\tif (ret)\n\t\treturn ret;\n\tret = devm_add_action_or_reset(dev, ti_sn65dsi86_delete_aux, aux);\n\tif (!ret)\n\t\t*aux_out = aux;\n\n\treturn ret;\n}\n\n \n\nstatic struct ti_sn65dsi86 *aux_to_ti_sn65dsi86(struct drm_dp_aux *aux)\n{\n\treturn container_of(aux, struct ti_sn65dsi86, aux);\n}\n\nstatic ssize_t ti_sn_aux_transfer(struct drm_dp_aux *aux,\n\t\t\t\t  struct drm_dp_aux_msg *msg)\n{\n\tstruct ti_sn65dsi86 *pdata = aux_to_ti_sn65dsi86(aux);\n\tu32 request = msg->request & ~(DP_AUX_I2C_MOT | DP_AUX_I2C_WRITE_STATUS_UPDATE);\n\tu32 request_val = AUX_CMD_REQ(msg->request);\n\tu8 *buf = msg->buffer;\n\tunsigned int len = msg->size;\n\tunsigned int short_len;\n\tunsigned int val;\n\tint ret;\n\tu8 addr_len[SN_AUX_LENGTH_REG + 1 - SN_AUX_ADDR_19_16_REG];\n\n\tif (len > SN_AUX_MAX_PAYLOAD_BYTES)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(pdata->dev);\n\tmutex_lock(&pdata->comms_mutex);\n\n\t \n\tif (!pdata->comms_enabled) {\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\tswitch (request) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\tregmap_write(pdata->regmap, SN_AUX_CMD_REG, request_val);\n\t\t \n\t\tmsg->reply = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tBUILD_BUG_ON(sizeof(addr_len) != sizeof(__be32));\n\tput_unaligned_be32((msg->address & SN_AUX_ADDR_MASK) << 8 | len,\n\t\t\t   addr_len);\n\tregmap_bulk_write(pdata->regmap, SN_AUX_ADDR_19_16_REG, addr_len,\n\t\t\t  ARRAY_SIZE(addr_len));\n\n\tif (request == DP_AUX_NATIVE_WRITE || request == DP_AUX_I2C_WRITE)\n\t\tregmap_bulk_write(pdata->regmap, SN_AUX_WDATA_REG(0), buf, len);\n\n\t \n\tregmap_write(pdata->regmap, SN_AUX_CMD_STATUS_REG,\n\t\t     AUX_IRQ_STATUS_NAT_I2C_FAIL |\n\t\t     AUX_IRQ_STATUS_AUX_RPLY_TOUT |\n\t\t     AUX_IRQ_STATUS_AUX_SHORT);\n\n\tregmap_write(pdata->regmap, SN_AUX_CMD_REG, request_val | AUX_CMD_SEND);\n\n\t \n\tret = regmap_read_poll_timeout(pdata->regmap, SN_AUX_CMD_REG, val,\n\t\t\t\t       !(val & AUX_CMD_SEND), 0, 50 * 1000);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = regmap_read(pdata->regmap, SN_AUX_CMD_STATUS_REG, &val);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (val & AUX_IRQ_STATUS_AUX_RPLY_TOUT) {\n\t\t \n\t\tret = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tif (val & AUX_IRQ_STATUS_AUX_SHORT) {\n\t\tret = regmap_read(pdata->regmap, SN_AUX_LENGTH_REG, &short_len);\n\t\tlen = min(len, short_len);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else if (val & AUX_IRQ_STATUS_NAT_I2C_FAIL) {\n\t\tswitch (request) {\n\t\tcase DP_AUX_I2C_WRITE:\n\t\tcase DP_AUX_I2C_READ:\n\t\t\tmsg->reply |= DP_AUX_I2C_REPLY_NACK;\n\t\t\tbreak;\n\t\tcase DP_AUX_NATIVE_READ:\n\t\tcase DP_AUX_NATIVE_WRITE:\n\t\t\tmsg->reply |= DP_AUX_NATIVE_REPLY_NACK;\n\t\t\tbreak;\n\t\t}\n\t\tlen = 0;\n\t\tgoto exit;\n\t}\n\n\tif (request != DP_AUX_NATIVE_WRITE && request != DP_AUX_I2C_WRITE && len != 0)\n\t\tret = regmap_bulk_read(pdata->regmap, SN_AUX_RDATA_REG(0), buf, len);\n\nexit:\n\tmutex_unlock(&pdata->comms_mutex);\n\tpm_runtime_mark_last_busy(pdata->dev);\n\tpm_runtime_put_autosuspend(pdata->dev);\n\n\tif (ret)\n\t\treturn ret;\n\treturn len;\n}\n\nstatic int ti_sn_aux_wait_hpd_asserted(struct drm_dp_aux *aux, unsigned long wait_us)\n{\n\t \n\tif (wait_us == 0)\n\t\twait_us = 500000;\n\n\tusleep_range(wait_us, wait_us + 1000);\n\n\treturn 0;\n}\n\nstatic int ti_sn_aux_probe(struct auxiliary_device *adev,\n\t\t\t   const struct auxiliary_device_id *id)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(adev->dev.parent);\n\tint ret;\n\n\tpdata->aux.name = \"ti-sn65dsi86-aux\";\n\tpdata->aux.dev = &adev->dev;\n\tpdata->aux.transfer = ti_sn_aux_transfer;\n\tpdata->aux.wait_hpd_asserted = ti_sn_aux_wait_hpd_asserted;\n\tdrm_dp_aux_init(&pdata->aux);\n\n\tret = devm_of_dp_aux_populate_ep_devices(&pdata->aux);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ti_sn65dsi86_add_aux_device(pdata, &pdata->bridge_aux, \"bridge\");\n}\n\nstatic const struct auxiliary_device_id ti_sn_aux_id_table[] = {\n\t{ .name = \"ti_sn65dsi86.aux\", },\n\t{},\n};\n\nstatic struct auxiliary_driver ti_sn_aux_driver = {\n\t.name = \"aux\",\n\t.probe = ti_sn_aux_probe,\n\t.id_table = ti_sn_aux_id_table,\n};\n\n \n\nstatic struct ti_sn65dsi86 *bridge_to_ti_sn65dsi86(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct ti_sn65dsi86, bridge);\n}\n\nstatic int ti_sn_attach_host(struct auxiliary_device *adev, struct ti_sn65dsi86 *pdata)\n{\n\tint val;\n\tstruct mipi_dsi_host *host;\n\tstruct mipi_dsi_device *dsi;\n\tstruct device *dev = pdata->dev;\n\tconst struct mipi_dsi_device_info info = { .type = \"ti_sn_bridge\",\n\t\t\t\t\t\t   .channel = 0,\n\t\t\t\t\t\t   .node = NULL,\n\t};\n\n\thost = of_find_mipi_dsi_host_by_node(pdata->host_node);\n\tif (!host)\n\t\treturn -EPROBE_DEFER;\n\n\tdsi = devm_mipi_dsi_device_register_full(&adev->dev, host, &info);\n\tif (IS_ERR(dsi))\n\t\treturn PTR_ERR(dsi);\n\n\t \n\tdsi->lanes = 4;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO;\n\n\t \n\tpm_runtime_get_sync(dev);\n\tregmap_read(pdata->regmap, SN_DPPLL_SRC_REG, &val);\n\tpm_runtime_put_autosuspend(dev);\n\tif (!(val & DPPLL_CLK_SRC_DSICLK))\n\t\tdsi->mode_flags |= MIPI_DSI_CLOCK_NON_CONTINUOUS;\n\n\tpdata->dsi = dsi;\n\n\treturn devm_mipi_dsi_attach(&adev->dev, dsi);\n}\n\nstatic int ti_sn_bridge_attach(struct drm_bridge *bridge,\n\t\t\t       enum drm_bridge_attach_flags flags)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\tint ret;\n\n\tpdata->aux.drm_dev = bridge->dev;\n\tret = drm_dp_aux_register(&pdata->aux);\n\tif (ret < 0) {\n\t\tdrm_err(bridge->dev, \"Failed to register DP AUX channel: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = drm_bridge_attach(bridge->encoder, pdata->next_bridge,\n\t\t\t\t&pdata->bridge, flags | DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret < 0)\n\t\tgoto err_initted_aux;\n\n\tif (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)\n\t\treturn 0;\n\n\tpdata->connector = drm_bridge_connector_init(pdata->bridge.dev,\n\t\t\t\t\t\t     pdata->bridge.encoder);\n\tif (IS_ERR(pdata->connector)) {\n\t\tret = PTR_ERR(pdata->connector);\n\t\tgoto err_initted_aux;\n\t}\n\n\tdrm_connector_attach_encoder(pdata->connector, pdata->bridge.encoder);\n\n\treturn 0;\n\nerr_initted_aux:\n\tdrm_dp_aux_unregister(&pdata->aux);\n\treturn ret;\n}\n\nstatic void ti_sn_bridge_detach(struct drm_bridge *bridge)\n{\n\tdrm_dp_aux_unregister(&bridge_to_ti_sn65dsi86(bridge)->aux);\n}\n\nstatic enum drm_mode_status\nti_sn_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\tconst struct drm_display_info *info,\n\t\t\tconst struct drm_display_mode *mode)\n{\n\t \n\tif (mode->clock > 594000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\t \n\n\tif ((mode->hsync_start - mode->hdisplay) > 0xff)\n\t\treturn MODE_HBLANK_WIDE;\n\n\tif ((mode->vsync_start - mode->vdisplay) > 0xff)\n\t\treturn MODE_VBLANK_WIDE;\n\n\tif ((mode->hsync_end - mode->hsync_start) > 0x7fff)\n\t\treturn MODE_HSYNC_WIDE;\n\n\tif ((mode->vsync_end - mode->vsync_start) > 0x7fff)\n\t\treturn MODE_VSYNC_WIDE;\n\n\tif ((mode->htotal - mode->hsync_end) > 0xff)\n\t\treturn MODE_HBLANK_WIDE;\n\n\tif ((mode->vtotal - mode->vsync_end) > 0xff)\n\t\treturn MODE_VBLANK_WIDE;\n\n\treturn MODE_OK;\n}\n\nstatic void ti_sn_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *old_bridge_state)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\n\t \n\tregmap_update_bits(pdata->regmap, SN_ENH_FRAME_REG, VSTREAM_ENABLE, 0);\n}\n\nstatic void ti_sn_bridge_set_dsi_rate(struct ti_sn65dsi86 *pdata)\n{\n\tunsigned int bit_rate_mhz, clk_freq_mhz;\n\tunsigned int val;\n\tstruct drm_display_mode *mode =\n\t\t&pdata->bridge.encoder->crtc->state->adjusted_mode;\n\n\t \n\tbit_rate_mhz = (mode->clock / 1000) *\n\t\t\tmipi_dsi_pixel_format_to_bpp(pdata->dsi->format);\n\tclk_freq_mhz = bit_rate_mhz / (pdata->dsi->lanes * 2);\n\n\t \n\tval = (MIN_DSI_CLK_FREQ_MHZ / 5) +\n\t\t(((clk_freq_mhz - MIN_DSI_CLK_FREQ_MHZ) / 5) & 0xFF);\n\tregmap_write(pdata->regmap, SN_DSIA_CLK_FREQ_REG, val);\n}\n\nstatic unsigned int ti_sn_bridge_get_bpp(struct drm_connector *connector)\n{\n\tif (connector->display_info.bpc <= 6)\n\t\treturn 18;\n\telse\n\t\treturn 24;\n}\n\n \nstatic const unsigned int ti_sn_bridge_dp_rate_lut[] = {\n\t0, 1620, 2160, 2430, 2700, 3240, 4320, 5400\n};\n\nstatic int ti_sn_bridge_calc_min_dp_rate_idx(struct ti_sn65dsi86 *pdata, unsigned int bpp)\n{\n\tunsigned int bit_rate_khz, dp_rate_mhz;\n\tunsigned int i;\n\tstruct drm_display_mode *mode =\n\t\t&pdata->bridge.encoder->crtc->state->adjusted_mode;\n\n\t \n\tbit_rate_khz = mode->clock * bpp;\n\n\t \n\tdp_rate_mhz = DIV_ROUND_UP(bit_rate_khz * DP_CLK_FUDGE_NUM,\n\t\t\t\t   1000 * pdata->dp_lanes * DP_CLK_FUDGE_DEN);\n\n\tfor (i = 1; i < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut) - 1; i++)\n\t\tif (ti_sn_bridge_dp_rate_lut[i] >= dp_rate_mhz)\n\t\t\tbreak;\n\n\treturn i;\n}\n\nstatic unsigned int ti_sn_bridge_read_valid_rates(struct ti_sn65dsi86 *pdata)\n{\n\tunsigned int valid_rates = 0;\n\tunsigned int rate_per_200khz;\n\tunsigned int rate_mhz;\n\tu8 dpcd_val;\n\tint ret;\n\tint i, j;\n\n\tret = drm_dp_dpcd_readb(&pdata->aux, DP_EDP_DPCD_REV, &dpcd_val);\n\tif (ret != 1) {\n\t\tDRM_DEV_ERROR(pdata->dev,\n\t\t\t      \"Can't read eDP rev (%d), assuming 1.1\\n\", ret);\n\t\tdpcd_val = DP_EDP_11;\n\t}\n\n\tif (dpcd_val >= DP_EDP_14) {\n\t\t \n\t\t__le16 sink_rates[DP_MAX_SUPPORTED_RATES];\n\n\t\tret = drm_dp_dpcd_read(&pdata->aux, DP_SUPPORTED_LINK_RATES,\n\t\t\t\t       sink_rates, sizeof(sink_rates));\n\n\t\tif (ret != sizeof(sink_rates)) {\n\t\t\tDRM_DEV_ERROR(pdata->dev,\n\t\t\t\t\"Can't read supported rate table (%d)\\n\", ret);\n\n\t\t\t \n\t\t\tmemset(sink_rates, 0, sizeof(sink_rates));\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sink_rates); i++) {\n\t\t\trate_per_200khz = le16_to_cpu(sink_rates[i]);\n\n\t\t\tif (!rate_per_200khz)\n\t\t\t\tbreak;\n\n\t\t\trate_mhz = rate_per_200khz * 200 / 1000;\n\t\t\tfor (j = 0;\n\t\t\t     j < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut);\n\t\t\t     j++) {\n\t\t\t\tif (ti_sn_bridge_dp_rate_lut[j] == rate_mhz)\n\t\t\t\t\tvalid_rates |= BIT(j);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut); i++) {\n\t\t\tif (valid_rates & BIT(i))\n\t\t\t\treturn valid_rates;\n\t\t}\n\t\tDRM_DEV_ERROR(pdata->dev,\n\t\t\t      \"No matching eDP rates in table; falling back\\n\");\n\t}\n\n\t \n\tret = drm_dp_dpcd_readb(&pdata->aux, DP_MAX_LINK_RATE, &dpcd_val);\n\tif (ret != 1) {\n\t\tDRM_DEV_ERROR(pdata->dev,\n\t\t\t      \"Can't read max rate (%d); assuming 5.4 GHz\\n\",\n\t\t\t      ret);\n\t\tdpcd_val = DP_LINK_BW_5_4;\n\t}\n\n\tswitch (dpcd_val) {\n\tdefault:\n\t\tDRM_DEV_ERROR(pdata->dev,\n\t\t\t      \"Unexpected max rate (%#x); assuming 5.4 GHz\\n\",\n\t\t\t      (int)dpcd_val);\n\t\tfallthrough;\n\tcase DP_LINK_BW_5_4:\n\t\tvalid_rates |= BIT(7);\n\t\tfallthrough;\n\tcase DP_LINK_BW_2_7:\n\t\tvalid_rates |= BIT(4);\n\t\tfallthrough;\n\tcase DP_LINK_BW_1_62:\n\t\tvalid_rates |= BIT(1);\n\t\tbreak;\n\t}\n\n\treturn valid_rates;\n}\n\nstatic void ti_sn_bridge_set_video_timings(struct ti_sn65dsi86 *pdata)\n{\n\tstruct drm_display_mode *mode =\n\t\t&pdata->bridge.encoder->crtc->state->adjusted_mode;\n\tu8 hsync_polarity = 0, vsync_polarity = 0;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\thsync_polarity = CHA_HSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tvsync_polarity = CHA_VSYNC_POLARITY;\n\n\tti_sn65dsi86_write_u16(pdata, SN_CHA_ACTIVE_LINE_LENGTH_LOW_REG,\n\t\t\t       mode->hdisplay);\n\tti_sn65dsi86_write_u16(pdata, SN_CHA_VERTICAL_DISPLAY_SIZE_LOW_REG,\n\t\t\t       mode->vdisplay);\n\tregmap_write(pdata->regmap, SN_CHA_HSYNC_PULSE_WIDTH_LOW_REG,\n\t\t     (mode->hsync_end - mode->hsync_start) & 0xFF);\n\tregmap_write(pdata->regmap, SN_CHA_HSYNC_PULSE_WIDTH_HIGH_REG,\n\t\t     (((mode->hsync_end - mode->hsync_start) >> 8) & 0x7F) |\n\t\t     hsync_polarity);\n\tregmap_write(pdata->regmap, SN_CHA_VSYNC_PULSE_WIDTH_LOW_REG,\n\t\t     (mode->vsync_end - mode->vsync_start) & 0xFF);\n\tregmap_write(pdata->regmap, SN_CHA_VSYNC_PULSE_WIDTH_HIGH_REG,\n\t\t     (((mode->vsync_end - mode->vsync_start) >> 8) & 0x7F) |\n\t\t     vsync_polarity);\n\n\tregmap_write(pdata->regmap, SN_CHA_HORIZONTAL_BACK_PORCH_REG,\n\t\t     (mode->htotal - mode->hsync_end) & 0xFF);\n\tregmap_write(pdata->regmap, SN_CHA_VERTICAL_BACK_PORCH_REG,\n\t\t     (mode->vtotal - mode->vsync_end) & 0xFF);\n\n\tregmap_write(pdata->regmap, SN_CHA_HORIZONTAL_FRONT_PORCH_REG,\n\t\t     (mode->hsync_start - mode->hdisplay) & 0xFF);\n\tregmap_write(pdata->regmap, SN_CHA_VERTICAL_FRONT_PORCH_REG,\n\t\t     (mode->vsync_start - mode->vdisplay) & 0xFF);\n\n\tusleep_range(10000, 10500);  \n}\n\nstatic unsigned int ti_sn_get_max_lanes(struct ti_sn65dsi86 *pdata)\n{\n\tu8 data;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(&pdata->aux, DP_MAX_LANE_COUNT, &data);\n\tif (ret != 1) {\n\t\tDRM_DEV_ERROR(pdata->dev,\n\t\t\t      \"Can't read lane count (%d); assuming 4\\n\", ret);\n\t\treturn 4;\n\t}\n\n\treturn data & DP_LANE_COUNT_MASK;\n}\n\nstatic int ti_sn_link_training(struct ti_sn65dsi86 *pdata, int dp_rate_idx,\n\t\t\t       const char **last_err_str)\n{\n\tunsigned int val;\n\tint ret;\n\tint i;\n\n\t \n\tregmap_update_bits(pdata->regmap, SN_DATARATE_CONFIG_REG,\n\t\t\t   DP_DATARATE_MASK, DP_DATARATE(dp_rate_idx));\n\n\t \n\tregmap_write(pdata->regmap, SN_PLL_ENABLE_REG, 1);\n\n\tret = regmap_read_poll_timeout(pdata->regmap, SN_DPPLL_SRC_REG, val,\n\t\t\t\t       val & DPPLL_SRC_DP_PLL_LOCK, 1000,\n\t\t\t\t       50 * 1000);\n\tif (ret) {\n\t\t*last_err_str = \"DP_PLL_LOCK polling failed\";\n\t\tgoto exit;\n\t}\n\n\t \n\tfor (i = 0; i < SN_LINK_TRAINING_TRIES; i++) {\n\t\t \n\t\tregmap_write(pdata->regmap, SN_ML_TX_MODE_REG, 0x0A);\n\t\tret = regmap_read_poll_timeout(pdata->regmap, SN_ML_TX_MODE_REG, val,\n\t\t\t\t\t       val == ML_TX_MAIN_LINK_OFF ||\n\t\t\t\t\t       val == ML_TX_NORMAL_MODE, 1000,\n\t\t\t\t\t       500 * 1000);\n\t\tif (ret) {\n\t\t\t*last_err_str = \"Training complete polling failed\";\n\t\t} else if (val == ML_TX_MAIN_LINK_OFF) {\n\t\t\t*last_err_str = \"Link training failed, link is off\";\n\t\t\tret = -EIO;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t \n\tif (!ret && i > SN_LINK_TRAINING_TRIES / 2)\n\t\tDRM_DEV_INFO(pdata->dev, \"Link training needed %d retries\\n\", i);\n\nexit:\n\t \n\tif (ret)\n\t\tregmap_write(pdata->regmap, SN_PLL_ENABLE_REG, 0);\n\n\treturn ret;\n}\n\nstatic void ti_sn_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t       struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\tstruct drm_connector *connector;\n\tconst char *last_err_str = \"No supported DP rate\";\n\tunsigned int valid_rates;\n\tint dp_rate_idx;\n\tunsigned int val;\n\tint ret = -EINVAL;\n\tint max_dp_lanes;\n\tunsigned int bpp;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(old_bridge_state->base.state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tif (!connector) {\n\t\tdev_err_ratelimited(pdata->dev, \"Could not get the connector\\n\");\n\t\treturn;\n\t}\n\n\tmax_dp_lanes = ti_sn_get_max_lanes(pdata);\n\tpdata->dp_lanes = min(pdata->dp_lanes, max_dp_lanes);\n\n\t \n\tval = CHA_DSI_LANES(SN_MAX_DP_LANES - pdata->dsi->lanes);\n\tregmap_update_bits(pdata->regmap, SN_DSI_LANES_REG,\n\t\t\t   CHA_DSI_LANES_MASK, val);\n\n\tregmap_write(pdata->regmap, SN_LN_ASSIGN_REG, pdata->ln_assign);\n\tregmap_update_bits(pdata->regmap, SN_ENH_FRAME_REG, LN_POLRS_MASK,\n\t\t\t   pdata->ln_polrs << LN_POLRS_OFFSET);\n\n\t \n\tti_sn_bridge_set_dsi_rate(pdata);\n\n\t \n\tif (pdata->bridge.type == DRM_MODE_CONNECTOR_eDP) {\n\t\tdrm_dp_dpcd_writeb(&pdata->aux, DP_EDP_CONFIGURATION_SET,\n\t\t\t\t   DP_ALTERNATE_SCRAMBLER_RESET_ENABLE);\n\n\t\tregmap_update_bits(pdata->regmap, SN_TRAINING_SETTING_REG,\n\t\t\t\t   SCRAMBLE_DISABLE, 0);\n\t} else {\n\t\tregmap_update_bits(pdata->regmap, SN_TRAINING_SETTING_REG,\n\t\t\t\t   SCRAMBLE_DISABLE, SCRAMBLE_DISABLE);\n\t}\n\n\tbpp = ti_sn_bridge_get_bpp(connector);\n\t \n\tval = bpp == 18 ? BPP_18_RGB : 0;\n\tregmap_update_bits(pdata->regmap, SN_DATA_FORMAT_REG, BPP_18_RGB, val);\n\n\t \n\tval = DP_NUM_LANES(min(pdata->dp_lanes, 3));\n\tregmap_update_bits(pdata->regmap, SN_SSC_CONFIG_REG, DP_NUM_LANES_MASK,\n\t\t\t   val);\n\n\tvalid_rates = ti_sn_bridge_read_valid_rates(pdata);\n\n\t \n\tfor (dp_rate_idx = ti_sn_bridge_calc_min_dp_rate_idx(pdata, bpp);\n\t     dp_rate_idx < ARRAY_SIZE(ti_sn_bridge_dp_rate_lut);\n\t     dp_rate_idx++) {\n\t\tif (!(valid_rates & BIT(dp_rate_idx)))\n\t\t\tcontinue;\n\n\t\tret = ti_sn_link_training(pdata, dp_rate_idx, &last_err_str);\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\tif (ret) {\n\t\tDRM_DEV_ERROR(pdata->dev, \"%s (%d)\\n\", last_err_str, ret);\n\t\treturn;\n\t}\n\n\t \n\tti_sn_bridge_set_video_timings(pdata);\n\n\t \n\tregmap_update_bits(pdata->regmap, SN_ENH_FRAME_REG, VSTREAM_ENABLE,\n\t\t\t   VSTREAM_ENABLE);\n}\n\nstatic void ti_sn_bridge_atomic_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\n\tpm_runtime_get_sync(pdata->dev);\n\n\tif (!pdata->refclk)\n\t\tti_sn65dsi86_enable_comms(pdata);\n\n\t \n\tusleep_range(100, 110);\n}\n\nstatic void ti_sn_bridge_atomic_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\n\t \n\tregmap_write(pdata->regmap, SN_ML_TX_MODE_REG, 0);\n\t \n\tregmap_update_bits(pdata->regmap, SN_SSC_CONFIG_REG, DP_NUM_LANES_MASK, 0);\n\t \n\tregmap_write(pdata->regmap, SN_PLL_ENABLE_REG, 0);\n\n\tif (!pdata->refclk)\n\t\tti_sn65dsi86_disable_comms(pdata);\n\n\tpm_runtime_put_sync(pdata->dev);\n}\n\nstatic enum drm_connector_status ti_sn_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\tint val = 0;\n\n\tpm_runtime_get_sync(pdata->dev);\n\tregmap_read(pdata->regmap, SN_HPD_DISABLE_REG, &val);\n\tpm_runtime_put_autosuspend(pdata->dev);\n\n\treturn val & HPD_DEBOUNCED_STATE ? connector_status_connected\n\t\t\t\t\t : connector_status_disconnected;\n}\n\nstatic struct edid *ti_sn_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_connector *connector)\n{\n\tstruct ti_sn65dsi86 *pdata = bridge_to_ti_sn65dsi86(bridge);\n\n\treturn drm_get_edid(connector, &pdata->aux.ddc);\n}\n\nstatic const struct drm_bridge_funcs ti_sn_bridge_funcs = {\n\t.attach = ti_sn_bridge_attach,\n\t.detach = ti_sn_bridge_detach,\n\t.mode_valid = ti_sn_bridge_mode_valid,\n\t.get_edid = ti_sn_bridge_get_edid,\n\t.detect = ti_sn_bridge_detect,\n\t.atomic_pre_enable = ti_sn_bridge_atomic_pre_enable,\n\t.atomic_enable = ti_sn_bridge_atomic_enable,\n\t.atomic_disable = ti_sn_bridge_atomic_disable,\n\t.atomic_post_disable = ti_sn_bridge_atomic_post_disable,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n};\n\nstatic void ti_sn_bridge_parse_lanes(struct ti_sn65dsi86 *pdata,\n\t\t\t\t     struct device_node *np)\n{\n\tu32 lane_assignments[SN_MAX_DP_LANES] = { 0, 1, 2, 3 };\n\tu32 lane_polarities[SN_MAX_DP_LANES] = { };\n\tstruct device_node *endpoint;\n\tu8 ln_assign = 0;\n\tu8 ln_polrs = 0;\n\tint dp_lanes;\n\tint i;\n\n\t \n\tendpoint = of_graph_get_endpoint_by_regs(np, 1, -1);\n\tdp_lanes = drm_of_get_data_lanes_count(endpoint, 1, SN_MAX_DP_LANES);\n\tif (dp_lanes > 0) {\n\t\tof_property_read_u32_array(endpoint, \"data-lanes\",\n\t\t\t\t\t   lane_assignments, dp_lanes);\n\t\tof_property_read_u32_array(endpoint, \"lane-polarities\",\n\t\t\t\t\t   lane_polarities, dp_lanes);\n\t} else {\n\t\tdp_lanes = SN_MAX_DP_LANES;\n\t}\n\tof_node_put(endpoint);\n\n\t \n\tfor (i = SN_MAX_DP_LANES - 1; i >= 0; i--) {\n\t\tln_assign = ln_assign << LN_ASSIGN_WIDTH | lane_assignments[i];\n\t\tln_polrs = ln_polrs << 1 | lane_polarities[i];\n\t}\n\n\t \n\tpdata->dp_lanes = dp_lanes;\n\tpdata->ln_assign = ln_assign;\n\tpdata->ln_polrs = ln_polrs;\n}\n\nstatic int ti_sn_bridge_parse_dsi_host(struct ti_sn65dsi86 *pdata)\n{\n\tstruct device_node *np = pdata->dev->of_node;\n\n\tpdata->host_node = of_graph_get_remote_node(np, 0, 0);\n\n\tif (!pdata->host_node) {\n\t\tDRM_ERROR(\"remote dsi host node not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_sn_bridge_probe(struct auxiliary_device *adev,\n\t\t\t      const struct auxiliary_device_id *id)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(adev->dev.parent);\n\tstruct device_node *np = pdata->dev->of_node;\n\tint ret;\n\n\tpdata->next_bridge = devm_drm_of_get_bridge(&adev->dev, np, 1, 0);\n\tif (IS_ERR(pdata->next_bridge))\n\t\treturn dev_err_probe(&adev->dev, PTR_ERR(pdata->next_bridge),\n\t\t\t\t     \"failed to create panel bridge\\n\");\n\n\tti_sn_bridge_parse_lanes(pdata, np);\n\n\tret = ti_sn_bridge_parse_dsi_host(pdata);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata->bridge.funcs = &ti_sn_bridge_funcs;\n\tpdata->bridge.of_node = np;\n\tpdata->bridge.type = pdata->next_bridge->type == DRM_MODE_CONNECTOR_DisplayPort\n\t\t\t   ? DRM_MODE_CONNECTOR_DisplayPort : DRM_MODE_CONNECTOR_eDP;\n\n\tif (pdata->bridge.type == DRM_MODE_CONNECTOR_DisplayPort)\n\t\tpdata->bridge.ops = DRM_BRIDGE_OP_EDID | DRM_BRIDGE_OP_DETECT;\n\n\tdrm_bridge_add(&pdata->bridge);\n\n\tret = ti_sn_attach_host(adev, pdata);\n\tif (ret) {\n\t\tdev_err_probe(&adev->dev, ret, \"failed to attach dsi host\\n\");\n\t\tgoto err_remove_bridge;\n\t}\n\n\treturn 0;\n\nerr_remove_bridge:\n\tdrm_bridge_remove(&pdata->bridge);\n\treturn ret;\n}\n\nstatic void ti_sn_bridge_remove(struct auxiliary_device *adev)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(adev->dev.parent);\n\n\tif (!pdata)\n\t\treturn;\n\n\tdrm_bridge_remove(&pdata->bridge);\n\n\tof_node_put(pdata->host_node);\n}\n\nstatic const struct auxiliary_device_id ti_sn_bridge_id_table[] = {\n\t{ .name = \"ti_sn65dsi86.bridge\", },\n\t{},\n};\n\nstatic struct auxiliary_driver ti_sn_bridge_driver = {\n\t.name = \"bridge\",\n\t.probe = ti_sn_bridge_probe,\n\t.remove = ti_sn_bridge_remove,\n\t.id_table = ti_sn_bridge_id_table,\n};\n\n \n#if defined(CONFIG_PWM)\nstatic int ti_sn_pwm_pin_request(struct ti_sn65dsi86 *pdata)\n{\n\treturn atomic_xchg(&pdata->pwm_pin_busy, 1) ? -EBUSY : 0;\n}\n\nstatic void ti_sn_pwm_pin_release(struct ti_sn65dsi86 *pdata)\n{\n\tatomic_set(&pdata->pwm_pin_busy, 0);\n}\n\nstatic struct ti_sn65dsi86 *pwm_chip_to_ti_sn_bridge(struct pwm_chip *chip)\n{\n\treturn container_of(chip, struct ti_sn65dsi86, pchip);\n}\n\nstatic int ti_sn_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ti_sn65dsi86 *pdata = pwm_chip_to_ti_sn_bridge(chip);\n\n\treturn ti_sn_pwm_pin_request(pdata);\n}\n\nstatic void ti_sn_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\n{\n\tstruct ti_sn65dsi86 *pdata = pwm_chip_to_ti_sn_bridge(chip);\n\n\tti_sn_pwm_pin_release(pdata);\n}\n\n \nstatic int ti_sn_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t   const struct pwm_state *state)\n{\n\tstruct ti_sn65dsi86 *pdata = pwm_chip_to_ti_sn_bridge(chip);\n\tunsigned int pwm_en_inv;\n\tunsigned int backlight;\n\tunsigned int pre_div;\n\tunsigned int scale;\n\tu64 period_max;\n\tu64 period;\n\tint ret;\n\n\tif (!pdata->pwm_enabled) {\n\t\tret = pm_runtime_get_sync(pdata->dev);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_sync(pdata->dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (state->enabled) {\n\t\tif (!pdata->pwm_enabled) {\n\t\t\t \n\t\t\tret = regmap_update_bits(pdata->regmap, SN_GPIO_CTRL_REG,\n\t\t\t\t\t\t SN_GPIO_MUX_MASK << (2 * SN_PWM_GPIO_IDX),\n\t\t\t\t\t\t SN_GPIO_MUX_SPECIAL << (2 * SN_PWM_GPIO_IDX));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(pdata->dev, \"failed to mux in PWM function\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (state->period <= NSEC_PER_SEC / pdata->pwm_refclk_freq) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tperiod_max = div_u64((u64)NSEC_PER_SEC * 255 * (65535 + 1),\n\t\t\t\t     pdata->pwm_refclk_freq);\n\t\tperiod = min(state->period, period_max);\n\n\t\tpre_div = DIV64_U64_ROUND_UP(period * pdata->pwm_refclk_freq,\n\t\t\t\t\t     (u64)NSEC_PER_SEC * (BACKLIGHT_SCALE_MAX + 1));\n\t\tscale = div64_u64(period * pdata->pwm_refclk_freq, (u64)NSEC_PER_SEC * pre_div) - 1;\n\n\t\t \n\t\tbacklight = div64_u64(state->duty_cycle * pdata->pwm_refclk_freq,\n\t\t\t\t      (u64)NSEC_PER_SEC * pre_div);\n\t\tif (backlight > scale)\n\t\t\tbacklight = scale;\n\n\t\tret = regmap_write(pdata->regmap, SN_PWM_PRE_DIV_REG, pre_div);\n\t\tif (ret) {\n\t\t\tdev_err(pdata->dev, \"failed to update PWM_PRE_DIV\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tti_sn65dsi86_write_u16(pdata, SN_BACKLIGHT_SCALE_REG, scale);\n\t\tti_sn65dsi86_write_u16(pdata, SN_BACKLIGHT_REG, backlight);\n\t}\n\n\tpwm_en_inv = FIELD_PREP(SN_PWM_EN_MASK, state->enabled) |\n\t\t     FIELD_PREP(SN_PWM_INV_MASK, state->polarity == PWM_POLARITY_INVERSED);\n\tret = regmap_write(pdata->regmap, SN_PWM_EN_INV_REG, pwm_en_inv);\n\tif (ret) {\n\t\tdev_err(pdata->dev, \"failed to update PWM_EN/PWM_INV\\n\");\n\t\tgoto out;\n\t}\n\n\tpdata->pwm_enabled = state->enabled;\nout:\n\n\tif (!pdata->pwm_enabled)\n\t\tpm_runtime_put_sync(pdata->dev);\n\n\treturn ret;\n}\n\nstatic int ti_sn_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\n\t\t\t       struct pwm_state *state)\n{\n\tstruct ti_sn65dsi86 *pdata = pwm_chip_to_ti_sn_bridge(chip);\n\tunsigned int pwm_en_inv;\n\tunsigned int pre_div;\n\tu16 backlight;\n\tu16 scale;\n\tint ret;\n\n\tret = regmap_read(pdata->regmap, SN_PWM_EN_INV_REG, &pwm_en_inv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_sn65dsi86_read_u16(pdata, SN_BACKLIGHT_SCALE_REG, &scale);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_sn65dsi86_read_u16(pdata, SN_BACKLIGHT_REG, &backlight);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(pdata->regmap, SN_PWM_PRE_DIV_REG, &pre_div);\n\tif (ret)\n\t\treturn ret;\n\n\tstate->enabled = FIELD_GET(SN_PWM_EN_MASK, pwm_en_inv);\n\tif (FIELD_GET(SN_PWM_INV_MASK, pwm_en_inv))\n\t\tstate->polarity = PWM_POLARITY_INVERSED;\n\telse\n\t\tstate->polarity = PWM_POLARITY_NORMAL;\n\n\tstate->period = DIV_ROUND_UP_ULL((u64)NSEC_PER_SEC * pre_div * (scale + 1),\n\t\t\t\t\t pdata->pwm_refclk_freq);\n\tstate->duty_cycle = DIV_ROUND_UP_ULL((u64)NSEC_PER_SEC * pre_div * backlight,\n\t\t\t\t\t     pdata->pwm_refclk_freq);\n\n\tif (state->duty_cycle > state->period)\n\t\tstate->duty_cycle = state->period;\n\n\treturn 0;\n}\n\nstatic const struct pwm_ops ti_sn_pwm_ops = {\n\t.request = ti_sn_pwm_request,\n\t.free = ti_sn_pwm_free,\n\t.apply = ti_sn_pwm_apply,\n\t.get_state = ti_sn_pwm_get_state,\n\t.owner = THIS_MODULE,\n};\n\nstatic int ti_sn_pwm_probe(struct auxiliary_device *adev,\n\t\t\t   const struct auxiliary_device_id *id)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(adev->dev.parent);\n\n\tpdata->pchip.dev = pdata->dev;\n\tpdata->pchip.ops = &ti_sn_pwm_ops;\n\tpdata->pchip.npwm = 1;\n\tpdata->pchip.of_xlate = of_pwm_single_xlate;\n\tpdata->pchip.of_pwm_n_cells = 1;\n\n\treturn pwmchip_add(&pdata->pchip);\n}\n\nstatic void ti_sn_pwm_remove(struct auxiliary_device *adev)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(adev->dev.parent);\n\n\tpwmchip_remove(&pdata->pchip);\n\n\tif (pdata->pwm_enabled)\n\t\tpm_runtime_put_sync(pdata->dev);\n}\n\nstatic const struct auxiliary_device_id ti_sn_pwm_id_table[] = {\n\t{ .name = \"ti_sn65dsi86.pwm\", },\n\t{},\n};\n\nstatic struct auxiliary_driver ti_sn_pwm_driver = {\n\t.name = \"pwm\",\n\t.probe = ti_sn_pwm_probe,\n\t.remove = ti_sn_pwm_remove,\n\t.id_table = ti_sn_pwm_id_table,\n};\n\nstatic int __init ti_sn_pwm_register(void)\n{\n\treturn auxiliary_driver_register(&ti_sn_pwm_driver);\n}\n\nstatic void ti_sn_pwm_unregister(void)\n{\n\tauxiliary_driver_unregister(&ti_sn_pwm_driver);\n}\n\n#else\nstatic inline int ti_sn_pwm_pin_request(struct ti_sn65dsi86 *pdata) { return 0; }\nstatic inline void ti_sn_pwm_pin_release(struct ti_sn65dsi86 *pdata) {}\n\nstatic inline int ti_sn_pwm_register(void) { return 0; }\nstatic inline void ti_sn_pwm_unregister(void) {}\n#endif\n\n \n#if defined(CONFIG_OF_GPIO)\n\nstatic int tn_sn_bridge_of_xlate(struct gpio_chip *chip,\n\t\t\t\t const struct of_phandle_args *gpiospec,\n\t\t\t\t u32 *flags)\n{\n\tif (WARN_ON(gpiospec->args_count < chip->of_gpio_n_cells))\n\t\treturn -EINVAL;\n\n\tif (gpiospec->args[0] > chip->ngpio || gpiospec->args[0] < 1)\n\t\treturn -EINVAL;\n\n\tif (flags)\n\t\t*flags = gpiospec->args[1];\n\n\treturn gpiospec->args[0] - SN_GPIO_PHYSICAL_OFFSET;\n}\n\nstatic int ti_sn_bridge_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned int offset)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\n\t \n\treturn test_bit(offset, pdata->gchip_output) ?\n\t\tGPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int ti_sn_bridge_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tpm_runtime_get_sync(pdata->dev);\n\tret = regmap_read(pdata->regmap, SN_GPIO_IO_REG, &val);\n\tpm_runtime_put_autosuspend(pdata->dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(SN_GPIO_INPUT_SHIFT + offset));\n}\n\nstatic void ti_sn_bridge_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t  int val)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\tint ret;\n\n\tif (!test_bit(offset, pdata->gchip_output)) {\n\t\tdev_err(pdata->dev, \"Ignoring GPIO set while input\\n\");\n\t\treturn;\n\t}\n\n\tval &= 1;\n\tret = regmap_update_bits(pdata->regmap, SN_GPIO_IO_REG,\n\t\t\t\t BIT(SN_GPIO_OUTPUT_SHIFT + offset),\n\t\t\t\t val << (SN_GPIO_OUTPUT_SHIFT + offset));\n\tif (ret)\n\t\tdev_warn(pdata->dev,\n\t\t\t \"Failed to set bridge GPIO %u: %d\\n\", offset, ret);\n}\n\nstatic int ti_sn_bridge_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\t     unsigned int offset)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\tint shift = offset * 2;\n\tint ret;\n\n\tif (!test_and_clear_bit(offset, pdata->gchip_output))\n\t\treturn 0;\n\n\tret = regmap_update_bits(pdata->regmap, SN_GPIO_CTRL_REG,\n\t\t\t\t SN_GPIO_MUX_MASK << shift,\n\t\t\t\t SN_GPIO_MUX_INPUT << shift);\n\tif (ret) {\n\t\tset_bit(offset, pdata->gchip_output);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_put_autosuspend(pdata->dev);\n\n\treturn 0;\n}\n\nstatic int ti_sn_bridge_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t      unsigned int offset, int val)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\tint shift = offset * 2;\n\tint ret;\n\n\tif (test_and_set_bit(offset, pdata->gchip_output))\n\t\treturn 0;\n\n\tpm_runtime_get_sync(pdata->dev);\n\n\t \n\tti_sn_bridge_gpio_set(chip, offset, val);\n\n\t \n\tret = regmap_update_bits(pdata->regmap, SN_GPIO_CTRL_REG,\n\t\t\t\t SN_GPIO_MUX_MASK << shift,\n\t\t\t\t SN_GPIO_MUX_OUTPUT << shift);\n\tif (ret) {\n\t\tclear_bit(offset, pdata->gchip_output);\n\t\tpm_runtime_put_autosuspend(pdata->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_sn_bridge_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\n\tif (offset == SN_PWM_GPIO_IDX)\n\t\treturn ti_sn_pwm_pin_request(pdata);\n\n\treturn 0;\n}\n\nstatic void ti_sn_bridge_gpio_free(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct ti_sn65dsi86 *pdata = gpiochip_get_data(chip);\n\n\t \n\tti_sn_bridge_gpio_direction_input(chip, offset);\n\n\tif (offset == SN_PWM_GPIO_IDX)\n\t\tti_sn_pwm_pin_release(pdata);\n}\n\nstatic const char * const ti_sn_bridge_gpio_names[SN_NUM_GPIOS] = {\n\t\"GPIO1\", \"GPIO2\", \"GPIO3\", \"GPIO4\"\n};\n\nstatic int ti_sn_gpio_probe(struct auxiliary_device *adev,\n\t\t\t    const struct auxiliary_device_id *id)\n{\n\tstruct ti_sn65dsi86 *pdata = dev_get_drvdata(adev->dev.parent);\n\tint ret;\n\n\t \n\tif (!of_property_read_bool(pdata->dev->of_node, \"gpio-controller\"))\n\t\treturn 0;\n\n\tpdata->gchip.label = dev_name(pdata->dev);\n\tpdata->gchip.parent = pdata->dev;\n\tpdata->gchip.owner = THIS_MODULE;\n\tpdata->gchip.of_xlate = tn_sn_bridge_of_xlate;\n\tpdata->gchip.of_gpio_n_cells = 2;\n\tpdata->gchip.request = ti_sn_bridge_gpio_request;\n\tpdata->gchip.free = ti_sn_bridge_gpio_free;\n\tpdata->gchip.get_direction = ti_sn_bridge_gpio_get_direction;\n\tpdata->gchip.direction_input = ti_sn_bridge_gpio_direction_input;\n\tpdata->gchip.direction_output = ti_sn_bridge_gpio_direction_output;\n\tpdata->gchip.get = ti_sn_bridge_gpio_get;\n\tpdata->gchip.set = ti_sn_bridge_gpio_set;\n\tpdata->gchip.can_sleep = true;\n\tpdata->gchip.names = ti_sn_bridge_gpio_names;\n\tpdata->gchip.ngpio = SN_NUM_GPIOS;\n\tpdata->gchip.base = -1;\n\tret = devm_gpiochip_add_data(&adev->dev, &pdata->gchip, pdata);\n\tif (ret)\n\t\tdev_err(pdata->dev, \"can't add gpio chip\\n\");\n\n\treturn ret;\n}\n\nstatic const struct auxiliary_device_id ti_sn_gpio_id_table[] = {\n\t{ .name = \"ti_sn65dsi86.gpio\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(auxiliary, ti_sn_gpio_id_table);\n\nstatic struct auxiliary_driver ti_sn_gpio_driver = {\n\t.name = \"gpio\",\n\t.probe = ti_sn_gpio_probe,\n\t.id_table = ti_sn_gpio_id_table,\n};\n\nstatic int __init ti_sn_gpio_register(void)\n{\n\treturn auxiliary_driver_register(&ti_sn_gpio_driver);\n}\n\nstatic void ti_sn_gpio_unregister(void)\n{\n\tauxiliary_driver_unregister(&ti_sn_gpio_driver);\n}\n\n#else\n\nstatic inline int ti_sn_gpio_register(void) { return 0; }\nstatic inline void ti_sn_gpio_unregister(void) {}\n\n#endif\n\n \n\nstatic void ti_sn65dsi86_runtime_disable(void *data)\n{\n\tpm_runtime_dont_use_autosuspend(data);\n\tpm_runtime_disable(data);\n}\n\nstatic int ti_sn65dsi86_parse_regulators(struct ti_sn65dsi86 *pdata)\n{\n\tunsigned int i;\n\tconst char * const ti_sn_bridge_supply_names[] = {\n\t\t\"vcca\", \"vcc\", \"vccio\", \"vpll\",\n\t};\n\n\tfor (i = 0; i < SN_REGULATOR_SUPPLY_NUM; i++)\n\t\tpdata->supplies[i].supply = ti_sn_bridge_supply_names[i];\n\n\treturn devm_regulator_bulk_get(pdata->dev, SN_REGULATOR_SUPPLY_NUM,\n\t\t\t\t       pdata->supplies);\n}\n\nstatic int ti_sn65dsi86_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ti_sn65dsi86 *pdata;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\n\t\tDRM_ERROR(\"device doesn't support I2C\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpdata = devm_kzalloc(dev, sizeof(struct ti_sn65dsi86), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, pdata);\n\tpdata->dev = dev;\n\n\tmutex_init(&pdata->comms_mutex);\n\n\tpdata->regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t     &ti_sn65dsi86_regmap_config);\n\tif (IS_ERR(pdata->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(pdata->regmap),\n\t\t\t\t     \"regmap i2c init failed\\n\");\n\n\tpdata->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(pdata->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(pdata->enable_gpio),\n\t\t\t\t     \"failed to get enable gpio from DT\\n\");\n\n\tret = ti_sn65dsi86_parse_regulators(pdata);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"failed to parse regulators\\n\");\n\n\tpdata->refclk = devm_clk_get_optional(dev, \"refclk\");\n\tif (IS_ERR(pdata->refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(pdata->refclk),\n\t\t\t\t     \"failed to get reference clock\\n\");\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_set_autosuspend_delay(pdata->dev, 500);\n\tpm_runtime_use_autosuspend(pdata->dev);\n\tret = devm_add_action_or_reset(dev, ti_sn65dsi86_runtime_disable, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tti_sn65dsi86_debugfs_init(pdata);\n\n\t \n\n\tif (IS_ENABLED(CONFIG_OF_GPIO)) {\n\t\tret = ti_sn65dsi86_add_aux_device(pdata, &pdata->gpio_aux, \"gpio\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PWM)) {\n\t\tret = ti_sn65dsi86_add_aux_device(pdata, &pdata->pwm_aux, \"pwm\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn ti_sn65dsi86_add_aux_device(pdata, &pdata->aux_aux, \"aux\");\n}\n\nstatic struct i2c_device_id ti_sn65dsi86_id[] = {\n\t{ \"ti,sn65dsi86\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ti_sn65dsi86_id);\n\nstatic const struct of_device_id ti_sn65dsi86_match_table[] = {\n\t{.compatible = \"ti,sn65dsi86\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ti_sn65dsi86_match_table);\n\nstatic struct i2c_driver ti_sn65dsi86_driver = {\n\t.driver = {\n\t\t.name = \"ti_sn65dsi86\",\n\t\t.of_match_table = ti_sn65dsi86_match_table,\n\t\t.pm = &ti_sn65dsi86_pm_ops,\n\t},\n\t.probe = ti_sn65dsi86_probe,\n\t.id_table = ti_sn65dsi86_id,\n};\n\nstatic int __init ti_sn65dsi86_init(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&ti_sn65dsi86_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ti_sn_gpio_register();\n\tif (ret)\n\t\tgoto err_main_was_registered;\n\n\tret = ti_sn_pwm_register();\n\tif (ret)\n\t\tgoto err_gpio_was_registered;\n\n\tret = auxiliary_driver_register(&ti_sn_aux_driver);\n\tif (ret)\n\t\tgoto err_pwm_was_registered;\n\n\tret = auxiliary_driver_register(&ti_sn_bridge_driver);\n\tif (ret)\n\t\tgoto err_aux_was_registered;\n\n\treturn 0;\n\nerr_aux_was_registered:\n\tauxiliary_driver_unregister(&ti_sn_aux_driver);\nerr_pwm_was_registered:\n\tti_sn_pwm_unregister();\nerr_gpio_was_registered:\n\tti_sn_gpio_unregister();\nerr_main_was_registered:\n\ti2c_del_driver(&ti_sn65dsi86_driver);\n\n\treturn ret;\n}\nmodule_init(ti_sn65dsi86_init);\n\nstatic void __exit ti_sn65dsi86_exit(void)\n{\n\tauxiliary_driver_unregister(&ti_sn_bridge_driver);\n\tauxiliary_driver_unregister(&ti_sn_aux_driver);\n\tti_sn_pwm_unregister();\n\tti_sn_gpio_unregister();\n\ti2c_del_driver(&ti_sn65dsi86_driver);\n}\nmodule_exit(ti_sn65dsi86_exit);\n\nMODULE_AUTHOR(\"Sandeep Panda <spanda@codeaurora.org>\");\nMODULE_DESCRIPTION(\"sn65dsi86 DSI to eDP bridge driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}