{
  "module_name": "thc63lvd1024.c",
  "hash_id": "bea8fedb6d35da832e0fe237588e50dc51fbd9df580af6d88cd4294099ded5f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/thc63lvd1024.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_panel.h>\n\nenum thc63_ports {\n\tTHC63_LVDS_IN0,\n\tTHC63_LVDS_IN1,\n\tTHC63_RGB_OUT0,\n\tTHC63_RGB_OUT1,\n};\n\nstruct thc63_dev {\n\tstruct device *dev;\n\n\tstruct regulator *vcc;\n\n\tstruct gpio_desc *pdwn;\n\tstruct gpio_desc *oe;\n\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next;\n\n\tstruct drm_bridge_timings timings;\n};\n\nstatic inline struct thc63_dev *to_thc63(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct thc63_dev, bridge);\n}\n\nstatic int thc63_attach(struct drm_bridge *bridge,\n\t\t\tenum drm_bridge_attach_flags flags)\n{\n\tstruct thc63_dev *thc63 = to_thc63(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, thc63->next, bridge, flags);\n}\n\nstatic enum drm_mode_status thc63_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\tconst struct drm_display_info *info,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct thc63_dev *thc63 = to_thc63(bridge);\n\tunsigned int min_freq;\n\tunsigned int max_freq;\n\n\t \n\tif (thc63->timings.dual_link) {\n\t\tmin_freq = 40000;\n\t\tmax_freq = 150000;\n\t} else {\n\t\tmin_freq = 8000;\n\t\tmax_freq = 135000;\n\t}\n\n\tif (mode->clock < min_freq)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (mode->clock > max_freq)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic void thc63_enable(struct drm_bridge *bridge)\n{\n\tstruct thc63_dev *thc63 = to_thc63(bridge);\n\tint ret;\n\n\tret = regulator_enable(thc63->vcc);\n\tif (ret) {\n\t\tdev_err(thc63->dev,\n\t\t\t\"Failed to enable regulator \\\"vcc\\\": %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tgpiod_set_value(thc63->pdwn, 0);\n\tgpiod_set_value(thc63->oe, 1);\n}\n\nstatic void thc63_disable(struct drm_bridge *bridge)\n{\n\tstruct thc63_dev *thc63 = to_thc63(bridge);\n\tint ret;\n\n\tgpiod_set_value(thc63->oe, 0);\n\tgpiod_set_value(thc63->pdwn, 1);\n\n\tret = regulator_disable(thc63->vcc);\n\tif (ret)\n\t\tdev_err(thc63->dev,\n\t\t\t\"Failed to disable regulator \\\"vcc\\\": %d\\n\", ret);\n}\n\nstatic const struct drm_bridge_funcs thc63_bridge_func = {\n\t.attach\t= thc63_attach,\n\t.mode_valid = thc63_mode_valid,\n\t.enable = thc63_enable,\n\t.disable = thc63_disable,\n};\n\nstatic int thc63_parse_dt(struct thc63_dev *thc63)\n{\n\tstruct device_node *endpoint;\n\tstruct device_node *remote;\n\n\tendpoint = of_graph_get_endpoint_by_regs(thc63->dev->of_node,\n\t\t\t\t\t\t THC63_RGB_OUT0, -1);\n\tif (!endpoint) {\n\t\tdev_err(thc63->dev, \"Missing endpoint in port@%u\\n\",\n\t\t\tTHC63_RGB_OUT0);\n\t\treturn -ENODEV;\n\t}\n\n\tremote = of_graph_get_remote_port_parent(endpoint);\n\tof_node_put(endpoint);\n\tif (!remote) {\n\t\tdev_err(thc63->dev, \"Endpoint in port@%u unconnected\\n\",\n\t\t\tTHC63_RGB_OUT0);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!of_device_is_available(remote)) {\n\t\tdev_err(thc63->dev, \"port@%u remote endpoint is disabled\\n\",\n\t\t\tTHC63_RGB_OUT0);\n\t\tof_node_put(remote);\n\t\treturn -ENODEV;\n\t}\n\n\tthc63->next = of_drm_find_bridge(remote);\n\tof_node_put(remote);\n\tif (!thc63->next)\n\t\treturn -EPROBE_DEFER;\n\n\tendpoint = of_graph_get_endpoint_by_regs(thc63->dev->of_node,\n\t\t\t\t\t\t THC63_LVDS_IN1, -1);\n\tif (endpoint) {\n\t\tremote = of_graph_get_remote_port_parent(endpoint);\n\t\tof_node_put(endpoint);\n\n\t\tif (remote) {\n\t\t\tif (of_device_is_available(remote))\n\t\t\t\tthc63->timings.dual_link = true;\n\t\t\tof_node_put(remote);\n\t\t}\n\t}\n\n\tdev_dbg(thc63->dev, \"operating in %s-link mode\\n\",\n\t\tthc63->timings.dual_link ? \"dual\" : \"single\");\n\n\treturn 0;\n}\n\nstatic int thc63_gpio_init(struct thc63_dev *thc63)\n{\n\tthc63->oe = devm_gpiod_get_optional(thc63->dev, \"oe\", GPIOD_OUT_LOW);\n\tif (IS_ERR(thc63->oe)) {\n\t\tdev_err(thc63->dev, \"Unable to get \\\"oe-gpios\\\": %ld\\n\",\n\t\t\tPTR_ERR(thc63->oe));\n\t\treturn PTR_ERR(thc63->oe);\n\t}\n\n\tthc63->pdwn = devm_gpiod_get_optional(thc63->dev, \"powerdown\",\n\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(thc63->pdwn)) {\n\t\tdev_err(thc63->dev, \"Unable to get \\\"powerdown-gpios\\\": %ld\\n\",\n\t\t\tPTR_ERR(thc63->pdwn));\n\t\treturn PTR_ERR(thc63->pdwn);\n\t}\n\n\treturn 0;\n}\n\nstatic int thc63_probe(struct platform_device *pdev)\n{\n\tstruct thc63_dev *thc63;\n\tint ret;\n\n\tthc63 = devm_kzalloc(&pdev->dev, sizeof(*thc63), GFP_KERNEL);\n\tif (!thc63)\n\t\treturn -ENOMEM;\n\n\tthc63->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, thc63);\n\n\tthc63->vcc = devm_regulator_get(thc63->dev, \"vcc\");\n\tif (IS_ERR(thc63->vcc)) {\n\t\tif (PTR_ERR(thc63->vcc) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdev_err(thc63->dev, \"Unable to get \\\"vcc\\\" supply: %ld\\n\",\n\t\t\tPTR_ERR(thc63->vcc));\n\t\treturn PTR_ERR(thc63->vcc);\n\t}\n\n\tret = thc63_gpio_init(thc63);\n\tif (ret)\n\t\treturn ret;\n\n\tret = thc63_parse_dt(thc63);\n\tif (ret)\n\t\treturn ret;\n\n\tthc63->bridge.driver_private = thc63;\n\tthc63->bridge.of_node = pdev->dev.of_node;\n\tthc63->bridge.funcs = &thc63_bridge_func;\n\tthc63->bridge.timings = &thc63->timings;\n\n\tdrm_bridge_add(&thc63->bridge);\n\n\treturn 0;\n}\n\nstatic void thc63_remove(struct platform_device *pdev)\n{\n\tstruct thc63_dev *thc63 = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&thc63->bridge);\n}\n\nstatic const struct of_device_id thc63_match[] = {\n\t{ .compatible = \"thine,thc63lvd1024\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, thc63_match);\n\nstatic struct platform_driver thc63_driver = {\n\t.probe\t= thc63_probe,\n\t.remove_new = thc63_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"thc63lvd1024\",\n\t\t.of_match_table\t= thc63_match,\n\t},\n};\nmodule_platform_driver(thc63_driver);\n\nMODULE_AUTHOR(\"Jacopo Mondi <jacopo@jmondi.org>\");\nMODULE_DESCRIPTION(\"Thine THC63LVD1024 LVDS decoder DRM bridge driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}