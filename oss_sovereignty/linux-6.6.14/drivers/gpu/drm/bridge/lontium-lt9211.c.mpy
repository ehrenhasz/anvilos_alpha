{
  "module_name": "lontium-lt9211.c",
  "hash_id": "7b81cacf2325739cdfdaba3116c8ce61d3581a69305401e5198d0c6cebfe6dce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/lontium-lt9211.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n\n#define REG_PAGE_CONTROL\t\t\t0xff\n#define REG_CHIPID0\t\t\t\t0x8100\n#define REG_CHIPID0_VALUE\t\t\t0x18\n#define REG_CHIPID1\t\t\t\t0x8101\n#define REG_CHIPID1_VALUE\t\t\t0x01\n#define REG_CHIPID2\t\t\t\t0x8102\n#define REG_CHIPID2_VALUE\t\t\t0xe3\n\n#define REG_DSI_LANE\t\t\t\t0xd000\n \n#define REG_DSI_LANE_COUNT(n)\t\t\t((n) & 3)\n\nstruct lt9211 {\n\tstruct drm_bridge\t\tbridge;\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct mipi_dsi_device\t\t*dsi;\n\tstruct drm_bridge\t\t*panel_bridge;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tstruct regulator\t\t*vccio;\n\tbool\t\t\t\tlvds_dual_link;\n\tbool\t\t\t\tlvds_dual_link_even_odd_swap;\n};\n\nstatic const struct regmap_range lt9211_rw_ranges[] = {\n\tregmap_reg_range(0xff, 0xff),\n\tregmap_reg_range(0x8100, 0x816b),\n\tregmap_reg_range(0x8200, 0x82aa),\n\tregmap_reg_range(0x8500, 0x85ff),\n\tregmap_reg_range(0x8600, 0x86a0),\n\tregmap_reg_range(0x8700, 0x8746),\n\tregmap_reg_range(0xd000, 0xd0a7),\n\tregmap_reg_range(0xd400, 0xd42c),\n\tregmap_reg_range(0xd800, 0xd838),\n\tregmap_reg_range(0xd9c0, 0xd9d5),\n};\n\nstatic const struct regmap_access_table lt9211_rw_table = {\n\t.yes_ranges = lt9211_rw_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(lt9211_rw_ranges),\n};\n\nstatic const struct regmap_range_cfg lt9211_range = {\n\t.name = \"lt9211\",\n\t.range_min = 0x0000,\n\t.range_max = 0xda00,\n\t.selector_reg = REG_PAGE_CONTROL,\n\t.selector_mask = 0xff,\n\t.selector_shift = 0,\n\t.window_start = 0,\n\t.window_len = 0x100,\n};\n\nstatic const struct regmap_config lt9211_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.rd_table = &lt9211_rw_table,\n\t.wr_table = &lt9211_rw_table,\n\t.volatile_table\t= &lt9211_rw_table,\n\t.ranges = &lt9211_range,\n\t.num_ranges = 1,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = 0xda00,\n};\n\nstatic struct lt9211 *bridge_to_lt9211(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct lt9211, bridge);\n}\n\nstatic int lt9211_attach(struct drm_bridge *bridge,\n\t\t\t enum drm_bridge_attach_flags flags)\n{\n\tstruct lt9211 *ctx = bridge_to_lt9211(bridge);\n\n\treturn drm_bridge_attach(bridge->encoder, ctx->panel_bridge,\n\t\t\t\t &ctx->bridge, flags);\n}\n\nstatic int lt9211_read_chipid(struct lt9211 *ctx)\n{\n\tu8 chipid[3];\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(ctx->regmap, REG_CHIPID0, chipid, 3);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"Failed to read Chip ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (chipid[0] != REG_CHIPID0_VALUE || chipid[1] != REG_CHIPID1_VALUE ||\n\t    chipid[2] != REG_CHIPID2_VALUE) {\n\t\tdev_err(ctx->dev, \"Unknown Chip ID: 0x%02x 0x%02x 0x%02x\\n\",\n\t\t\tchipid[0], chipid[1], chipid[2]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int lt9211_system_init(struct lt9211 *ctx)\n{\n\tconst struct reg_sequence lt9211_system_init_seq[] = {\n\t\t{ 0x8201, 0x18 },\n\t\t{ 0x8606, 0x61 },\n\t\t{ 0x8607, 0xa8 },\n\t\t{ 0x8714, 0x08 },\n\t\t{ 0x8715, 0x00 },\n\t\t{ 0x8718, 0x0f },\n\t\t{ 0x8722, 0x08 },\n\t\t{ 0x8723, 0x00 },\n\t\t{ 0x8726, 0x0f },\n\t\t{ 0x810b, 0xfe },\n\t};\n\n\treturn regmap_multi_reg_write(ctx->regmap, lt9211_system_init_seq,\n\t\t\t\t      ARRAY_SIZE(lt9211_system_init_seq));\n}\n\nstatic int lt9211_configure_rx(struct lt9211 *ctx)\n{\n\tconst struct reg_sequence lt9211_rx_phy_seq[] = {\n\t\t{ 0x8202, 0x44 },\n\t\t{ 0x8204, 0xa0 },\n\t\t{ 0x8205, 0x22 },\n\t\t{ 0x8207, 0x9f },\n\t\t{ 0x8208, 0xfc },\n\t\t \n\t\t{ 0x8209, 0x01 },\n\t\t{ 0x8217, 0x0c },\n\t\t{ 0x8633, 0x1b },\n\t};\n\n\tconst struct reg_sequence lt9211_rx_cal_reset_seq[] = {\n\t\t{ 0x8120, 0x7f },\n\t\t{ 0x8120, 0xff },\n\t};\n\n\tconst struct reg_sequence lt9211_rx_dig_seq[] = {\n\t\t{ 0x8630, 0x85 },\n\t\t \n\t\t{ 0x8588, 0x40 },\n\t\t{ 0x85ff, 0xd0 },\n\t\t{ REG_DSI_LANE, REG_DSI_LANE_COUNT(ctx->dsi->lanes) },\n\t\t{ 0xd002, 0x05 },\n\t};\n\n\tconst struct reg_sequence lt9211_rx_div_reset_seq[] = {\n\t\t{ 0x810a, 0xc0 },\n\t\t{ 0x8120, 0xbf },\n\t};\n\n\tconst struct reg_sequence lt9211_rx_div_clear_seq[] = {\n\t\t{ 0x810a, 0xc1 },\n\t\t{ 0x8120, 0xff },\n\t};\n\n\tint ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, lt9211_rx_phy_seq,\n\t\t\t\t     ARRAY_SIZE(lt9211_rx_phy_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, lt9211_rx_cal_reset_seq,\n\t\t\t\t     ARRAY_SIZE(lt9211_rx_cal_reset_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, lt9211_rx_dig_seq,\n\t\t\t\t     ARRAY_SIZE(lt9211_rx_dig_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, lt9211_rx_div_reset_seq,\n\t\t\t\t     ARRAY_SIZE(lt9211_rx_div_reset_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(10000, 15000);\n\n\treturn regmap_multi_reg_write(ctx->regmap, lt9211_rx_div_clear_seq,\n\t\t\t\t      ARRAY_SIZE(lt9211_rx_div_clear_seq));\n}\n\nstatic int lt9211_autodetect_rx(struct lt9211 *ctx,\n\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tu16 width, height;\n\tu32 byteclk;\n\tu8 buf[5];\n\tu8 format;\n\tu8 bc[3];\n\tint ret;\n\n\t \n\tret = regmap_write(ctx->regmap, 0x8600, 0x01);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\t \n\tret = regmap_bulk_read(ctx->regmap, 0x8608, bc, sizeof(bc));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbyteclk = ((bc[0] & 0xf) << 16) | (bc[1] << 8) | bc[2];\n\n\t \n\tret = regmap_bulk_read(ctx->regmap, 0xd082, buf, sizeof(buf));\n\tif (ret)\n\t\treturn ret;\n\n\twidth = (buf[0] << 8) | buf[1];\n\theight = (buf[3] << 8) | buf[4];\n\tformat = buf[2] & 0xf;\n\n\tif (format == 0x3) {\t\t \n\t\twidth /= 2;\n\t} else if (format == 0xa) {\t \n\t\twidth /= 3;\n\t} else {\n\t\tdev_err(ctx->dev, \"Unsupported DSI pixel format 0x%01x\\n\",\n\t\t\tformat);\n\t\treturn -EINVAL;\n\t}\n\n\tif (width != mode->hdisplay) {\n\t\tdev_err(ctx->dev,\n\t\t\t\"RX: Detected DSI width (%d) does not match mode hdisplay (%d)\\n\",\n\t\t\twidth, mode->hdisplay);\n\t\treturn -EINVAL;\n\t}\n\n\tif (height != mode->vdisplay) {\n\t\tdev_err(ctx->dev,\n\t\t\t\"RX: Detected DSI height (%d) does not match mode vdisplay (%d)\\n\",\n\t\t\theight, mode->vdisplay);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(ctx->dev, \"RX: %dx%d format=0x%01x byteclock=%d kHz\\n\",\n\t\twidth, height, format, byteclk);\n\n\treturn 0;\n}\n\nstatic int lt9211_configure_timing(struct lt9211 *ctx,\n\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tconst struct reg_sequence lt9211_timing[] = {\n\t\t{ 0xd00d, (mode->vtotal >> 8) & 0xff },\n\t\t{ 0xd00e, mode->vtotal & 0xff },\n\t\t{ 0xd00f, (mode->vdisplay >> 8) & 0xff },\n\t\t{ 0xd010, mode->vdisplay & 0xff },\n\t\t{ 0xd011, (mode->htotal >> 8) & 0xff },\n\t\t{ 0xd012, mode->htotal & 0xff },\n\t\t{ 0xd013, (mode->hdisplay >> 8) & 0xff },\n\t\t{ 0xd014, mode->hdisplay & 0xff },\n\t\t{ 0xd015, (mode->vsync_end - mode->vsync_start) & 0xff },\n\t\t{ 0xd016, (mode->hsync_end - mode->hsync_start) & 0xff },\n\t\t{ 0xd017, ((mode->vsync_start - mode->vdisplay) >> 8) & 0xff },\n\t\t{ 0xd018, (mode->vsync_start - mode->vdisplay) & 0xff },\n\t\t{ 0xd019, ((mode->hsync_start - mode->hdisplay) >> 8) & 0xff },\n\t\t{ 0xd01a, (mode->hsync_start - mode->hdisplay) & 0xff },\n\t};\n\n\treturn regmap_multi_reg_write(ctx->regmap, lt9211_timing,\n\t\t\t\t      ARRAY_SIZE(lt9211_timing));\n}\n\nstatic int lt9211_configure_plls(struct lt9211 *ctx,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tconst struct reg_sequence lt9211_pcr_seq[] = {\n\t\t{ 0xd026, 0x17 },\n\t\t{ 0xd027, 0xc3 },\n\t\t{ 0xd02d, 0x30 },\n\t\t{ 0xd031, 0x10 },\n\t\t{ 0xd023, 0x20 },\n\t\t{ 0xd038, 0x02 },\n\t\t{ 0xd039, 0x10 },\n\t\t{ 0xd03a, 0x20 },\n\t\t{ 0xd03b, 0x60 },\n\t\t{ 0xd03f, 0x04 },\n\t\t{ 0xd040, 0x08 },\n\t\t{ 0xd041, 0x10 },\n\t\t{ 0x810b, 0xee },\n\t\t{ 0x810b, 0xfe },\n\t};\n\n\tunsigned int pval;\n\tint ret;\n\n\t \n\tret = regmap_write(ctx->regmap, 0x822d, 0x48);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mode->clock < 44000) {\n\t\tret = regmap_write(ctx->regmap, 0x8235, 0x83);\n\t} else if (mode->clock < 88000) {\n\t\tret = regmap_write(ctx->regmap, 0x8235, 0x82);\n\t} else if (mode->clock < 176000) {\n\t\tret = regmap_write(ctx->regmap, 0x8235, 0x81);\n\t} else {\n\t\tdev_err(ctx->dev,\n\t\t\t\"Unsupported mode clock (%d kHz) above 176 MHz.\\n\",\n\t\t\tmode->clock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(100);\n\n\tret = regmap_multi_reg_write(ctx->regmap, lt9211_pcr_seq,\n\t\t\t\t     ARRAY_SIZE(lt9211_pcr_seq));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(ctx->regmap, 0xd087, pval, pval & 0x8,\n\t\t\t\t       20000, 10000000);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"PCR unstable, ret=%i\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int lt9211_configure_tx(struct lt9211 *ctx, bool jeida,\n\t\t\t       bool bpp24, bool de)\n{\n\tconst struct reg_sequence system_lt9211_tx_phy_seq[] = {\n\t\t \n\t\t{ 0x8262, 0x00 },\n\t\t \n\t\t{ 0x823b, 0x38 | (ctx->lvds_dual_link ? BIT(7) : 0) },\n\t\t{ 0x823e, 0x92 },\n\t\t{ 0x823f, 0x48 },\n\t\t{ 0x8240, 0x31 },\n\t\t{ 0x8243, 0x80 },\n\t\t{ 0x8244, 0x00 },\n\t\t{ 0x8245, 0x00 },\n\t\t{ 0x8249, 0x00 },\n\t\t{ 0x824a, 0x01 },\n\t\t{ 0x824e, 0x00 },\n\t\t{ 0x824f, 0x00 },\n\t\t{ 0x8250, 0x00 },\n\t\t{ 0x8253, 0x00 },\n\t\t{ 0x8254, 0x01 },\n\t\t \n\t\t{ 0x8646, ctx->lvds_dual_link_even_odd_swap ? 0x40 : 0x10 },\n\t\t{ 0x8120, 0x7b },\n\t\t{ 0x816b, 0xff },\n\t};\n\n\tconst struct reg_sequence system_lt9211_tx_dig_seq[] = {\n\t\t{ 0x8559, 0x40 | (jeida ? BIT(7) : 0) |\n\t\t\t  (de ? BIT(5) : 0) | (bpp24 ? BIT(4) : 0) },\n\t\t{ 0x855a, 0xaa },\n\t\t{ 0x855b, 0xaa },\n\t\t{ 0x855c, ctx->lvds_dual_link ? BIT(0) : 0 },\n\t\t{ 0x85a1, 0x77 },\n\t\t{ 0x8640, 0x40 },\n\t\t{ 0x8641, 0x34 },\n\t\t{ 0x8642, 0x10 },\n\t\t{ 0x8643, 0x23 },\n\t\t{ 0x8644, 0x41 },\n\t\t{ 0x8645, 0x02 },\n\t};\n\n\tconst struct reg_sequence system_lt9211_tx_pll_seq[] = {\n\t\t \n\t\t{ 0x8236, 0x01 },\n\t\t{ 0x8237, ctx->lvds_dual_link ? 0x2a : 0x29 },\n\t\t{ 0x8238, 0x06 },\n\t\t{ 0x8239, 0x30 },\n\t\t{ 0x823a, 0x8e },\n\t\t{ 0x8737, 0x14 },\n\t\t{ 0x8713, 0x00 },\n\t\t{ 0x8713, 0x80 },\n\t};\n\n\tunsigned int pval;\n\tint ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, system_lt9211_tx_phy_seq,\n\t\t\t\t     ARRAY_SIZE(system_lt9211_tx_phy_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, system_lt9211_tx_dig_seq,\n\t\t\t\t     ARRAY_SIZE(system_lt9211_tx_dig_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_multi_reg_write(ctx->regmap, system_lt9211_tx_pll_seq,\n\t\t\t\t     ARRAY_SIZE(system_lt9211_tx_pll_seq));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(ctx->regmap, 0x871f, pval, pval & 0x80,\n\t\t\t\t       10000, 1000000);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"TX PLL unstable, ret=%i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read_poll_timeout(ctx->regmap, 0x8720, pval, pval & 0x80,\n\t\t\t\t       10000, 1000000);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"TX PLL unstable, ret=%i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void lt9211_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *old_bridge_state)\n{\n\tstruct lt9211 *ctx = bridge_to_lt9211(bridge);\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tconst struct drm_bridge_state *bridge_state;\n\tconst struct drm_crtc_state *crtc_state;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tbool lvds_format_24bpp;\n\tbool lvds_format_jeida;\n\tu32 bus_flags;\n\tint ret;\n\n\tret = regulator_enable(ctx->vccio);\n\tif (ret) {\n\t\tdev_err(ctx->dev, \"Failed to enable vccio: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tgpiod_set_value(ctx->reset_gpio, 1);\n\tusleep_range(20000, 21000);\t \n\n\t \n\tbridge_state = drm_atomic_get_new_bridge_state(state, bridge);\n\tbus_flags = bridge_state->output_bus_cfg.flags;\n\n\tswitch (bridge_state->output_bus_cfg.format) {\n\tcase MEDIA_BUS_FMT_RGB666_1X7X3_SPWG:\n\t\tlvds_format_24bpp = false;\n\t\tlvds_format_jeida = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA:\n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = true;\n\t\tbreak;\n\tcase MEDIA_BUS_FMT_RGB888_1X7X4_SPWG:\n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = false;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tlvds_format_24bpp = true;\n\t\tlvds_format_jeida = false;\n\t\tdev_warn(ctx->dev,\n\t\t\t \"Unsupported LVDS bus format 0x%04x, please check output bridge driver. Falling back to SPWG24.\\n\",\n\t\t\t bridge_state->output_bus_cfg.format);\n\t\tbreak;\n\t}\n\n\t \n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tmode = &crtc_state->adjusted_mode;\n\n\tret = lt9211_read_chipid(ctx);\n\tif (ret)\n\t\treturn;\n\n\tret = lt9211_system_init(ctx);\n\tif (ret)\n\t\treturn;\n\n\tret = lt9211_configure_rx(ctx);\n\tif (ret)\n\t\treturn;\n\n\tret = lt9211_autodetect_rx(ctx, mode);\n\tif (ret)\n\t\treturn;\n\n\tret = lt9211_configure_timing(ctx, mode);\n\tif (ret)\n\t\treturn;\n\n\tret = lt9211_configure_plls(ctx, mode);\n\tif (ret)\n\t\treturn;\n\n\tret = lt9211_configure_tx(ctx, lvds_format_jeida, lvds_format_24bpp,\n\t\t\t\t  bus_flags & DRM_BUS_FLAG_DE_HIGH);\n\tif (ret)\n\t\treturn;\n\n\tdev_dbg(ctx->dev, \"LT9211 enabled.\\n\");\n}\n\nstatic void lt9211_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tstruct lt9211 *ctx = bridge_to_lt9211(bridge);\n\tint ret;\n\n\t \n\tgpiod_set_value(ctx->reset_gpio, 0);\n\tusleep_range(10000, 11000);\t \n\n\tret = regulator_disable(ctx->vccio);\n\tif (ret)\n\t\tdev_err(ctx->dev, \"Failed to disable vccio: %d\\n\", ret);\n\n\tregcache_mark_dirty(ctx->regmap);\n}\n\nstatic enum drm_mode_status\nlt9211_mode_valid(struct drm_bridge *bridge,\n\t\t  const struct drm_display_info *info,\n\t\t  const struct drm_display_mode *mode)\n{\n\t \n\tif (mode->clock < 25000)\n\t\treturn MODE_CLOCK_LOW;\n\tif (mode->clock > 176000)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\n#define MAX_INPUT_SEL_FORMATS\t1\n\nstatic u32 *\nlt9211_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t struct drm_connector_state *conn_state,\n\t\t\t\t u32 output_fmt,\n\t\t\t\t unsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\t*num_input_fmts = 0;\n\n\tinput_fmts = kcalloc(MAX_INPUT_SEL_FORMATS, sizeof(*input_fmts),\n\t\t\t     GFP_KERNEL);\n\tif (!input_fmts)\n\t\treturn NULL;\n\n\t \n\tinput_fmts[0] = MEDIA_BUS_FMT_RGB888_1X24;\n\t*num_input_fmts = 1;\n\n\treturn input_fmts;\n}\n\nstatic const struct drm_bridge_funcs lt9211_funcs = {\n\t.attach\t\t\t= lt9211_attach,\n\t.mode_valid\t\t= lt9211_mode_valid,\n\t.atomic_enable\t\t= lt9211_atomic_enable,\n\t.atomic_disable\t\t= lt9211_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts = lt9211_atomic_get_input_bus_fmts,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n};\n\nstatic int lt9211_parse_dt(struct lt9211 *ctx)\n{\n\tstruct device_node *port2, *port3;\n\tstruct drm_bridge *panel_bridge;\n\tstruct device *dev = ctx->dev;\n\tstruct drm_panel *panel;\n\tint dual_link;\n\tint ret;\n\n\tctx->vccio = devm_regulator_get(dev, \"vccio\");\n\tif (IS_ERR(ctx->vccio))\n\t\treturn dev_err_probe(dev, PTR_ERR(ctx->vccio),\n\t\t\t\t     \"Failed to get supply 'vccio'\\n\");\n\n\tctx->lvds_dual_link = false;\n\tctx->lvds_dual_link_even_odd_swap = false;\n\n\tport2 = of_graph_get_port_by_id(dev->of_node, 2);\n\tport3 = of_graph_get_port_by_id(dev->of_node, 3);\n\tdual_link = drm_of_lvds_get_dual_link_pixel_order(port2, port3);\n\tof_node_put(port2);\n\tof_node_put(port3);\n\n\tif (dual_link == DRM_LVDS_DUAL_LINK_ODD_EVEN_PIXELS) {\n\t\tctx->lvds_dual_link = true;\n\t\t \n\t\tctx->lvds_dual_link_even_odd_swap = false;\n\t} else if (dual_link == DRM_LVDS_DUAL_LINK_EVEN_ODD_PIXELS) {\n\t\tctx->lvds_dual_link = true;\n\t\t \n\t\tctx->lvds_dual_link_even_odd_swap = true;\n\t}\n\n\tret = drm_of_find_panel_or_bridge(dev->of_node, 2, 0, &panel, &panel_bridge);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (panel) {\n\t\tpanel_bridge = devm_drm_panel_bridge_add(dev, panel);\n\t\tif (IS_ERR(panel_bridge))\n\t\t\treturn PTR_ERR(panel_bridge);\n\t}\n\n\tctx->panel_bridge = panel_bridge;\n\n\treturn 0;\n}\n\nstatic int lt9211_host_attach(struct lt9211 *ctx)\n{\n\tconst struct mipi_dsi_device_info info = {\n\t\t.type = \"lt9211\",\n\t\t.channel = 0,\n\t\t.node = NULL,\n\t};\n\tstruct device *dev = ctx->dev;\n\tstruct device_node *host_node;\n\tstruct device_node *endpoint;\n\tstruct mipi_dsi_device *dsi;\n\tstruct mipi_dsi_host *host;\n\tint dsi_lanes;\n\tint ret;\n\n\tendpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, -1);\n\tdsi_lanes = drm_of_get_data_lanes_count(endpoint, 1, 4);\n\thost_node = of_graph_get_remote_port_parent(endpoint);\n\thost = of_find_mipi_dsi_host_by_node(host_node);\n\tof_node_put(host_node);\n\tof_node_put(endpoint);\n\n\tif (!host)\n\t\treturn -EPROBE_DEFER;\n\n\tif (dsi_lanes < 0)\n\t\treturn dsi_lanes;\n\n\tdsi = devm_mipi_dsi_device_register_full(dev, host, &info);\n\tif (IS_ERR(dsi))\n\t\treturn dev_err_probe(dev, PTR_ERR(dsi),\n\t\t\t\t     \"failed to create dsi device\\n\");\n\n\tctx->dsi = dsi;\n\n\tdsi->lanes = dsi_lanes;\n\tdsi->format = MIPI_DSI_FMT_RGB888;\n\tdsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |\n\t\t\t  MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO_NO_HSA |\n\t\t\t  MIPI_DSI_MODE_VIDEO_NO_HFP | MIPI_DSI_MODE_VIDEO_NO_HBP |\n\t\t\t  MIPI_DSI_MODE_NO_EOT_PACKET;\n\n\tret = devm_mipi_dsi_attach(dev, dsi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to attach dsi to host: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lt9211_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct lt9211 *ctx;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\n\t \n\tctx->reset_gpio = devm_gpiod_get_optional(ctx->dev, \"reset\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->reset_gpio))\n\t\treturn PTR_ERR(ctx->reset_gpio);\n\n\tusleep_range(10000, 11000);\t \n\n\tret = lt9211_parse_dt(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->regmap = devm_regmap_init_i2c(client, &lt9211_regmap_config);\n\tif (IS_ERR(ctx->regmap))\n\t\treturn PTR_ERR(ctx->regmap);\n\n\tdev_set_drvdata(dev, ctx);\n\ti2c_set_clientdata(client, ctx);\n\n\tctx->bridge.funcs = &lt9211_funcs;\n\tctx->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&ctx->bridge);\n\n\tret = lt9211_host_attach(ctx);\n\tif (ret)\n\t\tdrm_bridge_remove(&ctx->bridge);\n\n\treturn ret;\n}\n\nstatic void lt9211_remove(struct i2c_client *client)\n{\n\tstruct lt9211 *ctx = i2c_get_clientdata(client);\n\n\tdrm_bridge_remove(&ctx->bridge);\n}\n\nstatic struct i2c_device_id lt9211_id[] = {\n\t{ \"lontium,lt9211\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, lt9211_id);\n\nstatic const struct of_device_id lt9211_match_table[] = {\n\t{ .compatible = \"lontium,lt9211\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, lt9211_match_table);\n\nstatic struct i2c_driver lt9211_driver = {\n\t.probe = lt9211_probe,\n\t.remove = lt9211_remove,\n\t.id_table = lt9211_id,\n\t.driver = {\n\t\t.name = \"lt9211\",\n\t\t.of_match_table = lt9211_match_table,\n\t},\n};\nmodule_i2c_driver(lt9211_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"Lontium LT9211 DSI/LVDS/DPI bridge driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}