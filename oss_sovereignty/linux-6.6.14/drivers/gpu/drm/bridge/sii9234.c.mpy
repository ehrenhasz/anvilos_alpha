{
  "module_name": "sii9234.c",
  "hash_id": "1475ae62d1f325c09d255182c33db9414370bfef6575a270214e613c62db9408",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/sii9234.c",
  "human_readable_source": "\n \n#include <drm/bridge/mhl.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#define CBUS_DEVCAP_OFFSET\t\t0x80\n\n#define SII9234_MHL_VERSION\t\t0x11\n#define SII9234_SCRATCHPAD_SIZE\t\t0x10\n#define SII9234_INT_STAT_SIZE\t\t0x33\n\n#define BIT_TMDS_CCTRL_TMDS_OE\t\tBIT(4)\n#define MHL_HPD_OUT_OVR_EN\t\tBIT(4)\n#define MHL_HPD_OUT_OVR_VAL\t\tBIT(5)\n#define MHL_INIT_TIMEOUT\t\t0x0C\n\n \n#define MHL_TX_SRST\t\t\t0x05\n#define MHL_TX_SYSSTAT_REG\t\t0x09\n#define MHL_TX_INTR1_REG\t\t0x71\n#define MHL_TX_INTR4_REG\t\t0x74\n#define MHL_TX_INTR1_ENABLE_REG\t\t0x75\n#define MHL_TX_INTR4_ENABLE_REG\t\t0x78\n#define MHL_TX_INT_CTRL_REG\t\t0x79\n#define MHL_TX_TMDS_CCTRL\t\t0x80\n#define MHL_TX_DISC_CTRL1_REG\t\t0x90\n#define MHL_TX_DISC_CTRL2_REG\t\t0x91\n#define MHL_TX_DISC_CTRL3_REG\t\t0x92\n#define MHL_TX_DISC_CTRL4_REG\t\t0x93\n#define MHL_TX_DISC_CTRL5_REG\t\t0x94\n#define MHL_TX_DISC_CTRL6_REG\t\t0x95\n#define MHL_TX_DISC_CTRL7_REG\t\t0x96\n#define MHL_TX_DISC_CTRL8_REG\t\t0x97\n#define MHL_TX_STAT2_REG\t\t0x99\n#define MHL_TX_MHLTX_CTL1_REG\t\t0xA0\n#define MHL_TX_MHLTX_CTL2_REG\t\t0xA1\n#define MHL_TX_MHLTX_CTL4_REG\t\t0xA3\n#define MHL_TX_MHLTX_CTL6_REG\t\t0xA5\n#define MHL_TX_MHLTX_CTL7_REG\t\t0xA6\n\n#define RSEN_STATUS\t\t\tBIT(2)\n#define HPD_CHANGE_INT\t\t\tBIT(6)\n#define RSEN_CHANGE_INT\t\t\tBIT(5)\n#define RGND_READY_INT\t\t\tBIT(6)\n#define VBUS_LOW_INT\t\t\tBIT(5)\n#define CBUS_LKOUT_INT\t\t\tBIT(4)\n#define MHL_DISC_FAIL_INT\t\tBIT(3)\n#define MHL_EST_INT\t\t\tBIT(2)\n#define HPD_CHANGE_INT_MASK\t\tBIT(6)\n#define RSEN_CHANGE_INT_MASK\t\tBIT(5)\n\n#define RGND_READY_MASK\t\t\tBIT(6)\n#define CBUS_LKOUT_MASK\t\t\tBIT(4)\n#define MHL_DISC_FAIL_MASK\t\tBIT(3)\n#define MHL_EST_MASK\t\t\tBIT(2)\n\n#define SKIP_GND\t\t\tBIT(6)\n\n#define ATT_THRESH_SHIFT\t\t0x04\n#define ATT_THRESH_MASK\t\t\t(0x03 << ATT_THRESH_SHIFT)\n#define USB_D_OEN\t\t\tBIT(3)\n#define DEGLITCH_TIME_MASK\t\t0x07\n#define DEGLITCH_TIME_2MS\t\t0\n#define DEGLITCH_TIME_4MS\t\t1\n#define DEGLITCH_TIME_8MS\t\t2\n#define DEGLITCH_TIME_16MS\t\t3\n#define DEGLITCH_TIME_40MS\t\t4\n#define DEGLITCH_TIME_50MS\t\t5\n#define DEGLITCH_TIME_60MS\t\t6\n#define DEGLITCH_TIME_128MS\t\t7\n\n#define USB_D_OVR\t\t\tBIT(7)\n#define USB_ID_OVR\t\t\tBIT(6)\n#define DVRFLT_SEL\t\t\tBIT(5)\n#define BLOCK_RGND_INT\t\t\tBIT(4)\n#define SKIP_DEG\t\t\tBIT(3)\n#define CI2CA_POL\t\t\tBIT(2)\n#define CI2CA_WKUP\t\t\tBIT(1)\n#define SINGLE_ATT\t\t\tBIT(0)\n\n#define USB_D_ODN\t\t\tBIT(5)\n#define VBUS_CHECK\t\t\tBIT(2)\n#define RGND_INTP_MASK\t\t\t0x03\n#define RGND_INTP_OPEN\t\t\t0\n#define RGND_INTP_2K\t\t\t1\n#define RGND_INTP_1K\t\t\t2\n#define RGND_INTP_SHORT\t\t\t3\n\n \n#define HDMI_RX_TMDS0_CCTRL1_REG\t0x10\n#define HDMI_RX_TMDS_CLK_EN_REG\t\t0x11\n#define HDMI_RX_TMDS_CH_EN_REG\t\t0x12\n#define HDMI_RX_PLL_CALREFSEL_REG\t0x17\n#define HDMI_RX_PLL_VCOCAL_REG\t\t0x1A\n#define HDMI_RX_EQ_DATA0_REG\t\t0x22\n#define HDMI_RX_EQ_DATA1_REG\t\t0x23\n#define HDMI_RX_EQ_DATA2_REG\t\t0x24\n#define HDMI_RX_EQ_DATA3_REG\t\t0x25\n#define HDMI_RX_EQ_DATA4_REG\t\t0x26\n#define HDMI_RX_TMDS_ZONE_CTRL_REG\t0x4C\n#define HDMI_RX_TMDS_MODE_CTRL_REG\t0x4D\n\n \n#define CBUS_INT_STATUS_1_REG\t\t0x08\n#define CBUS_INTR1_ENABLE_REG\t\t0x09\n#define CBUS_MSC_REQ_ABORT_REASON_REG\t0x0D\n#define CBUS_INT_STATUS_2_REG\t\t0x1E\n#define CBUS_INTR2_ENABLE_REG\t\t0x1F\n#define CBUS_LINK_CONTROL_2_REG\t\t0x31\n#define CBUS_MHL_STATUS_REG_0\t\t0xB0\n#define CBUS_MHL_STATUS_REG_1\t\t0xB1\n\n#define BIT_CBUS_RESET\t\t\tBIT(3)\n#define SET_HPD_DOWNSTREAM\t\tBIT(6)\n\n \n#define TPI_DPD_REG\t\t\t0x3D\n\n \n#define T_SRC_VBUS_CBUS_TO_STABLE\t200\n#define T_SRC_CBUS_FLOAT\t\t100\n#define T_SRC_CBUS_DEGLITCH\t\t2\n#define T_SRC_RXSENSE_DEGLITCH\t\t110\n\n#define MHL1_MAX_CLK\t\t\t75000  \n\n#define I2C_TPI_ADDR\t\t\t0x3D\n#define I2C_HDMI_ADDR\t\t\t0x49\n#define I2C_CBUS_ADDR\t\t\t0x64\n\nenum sii9234_state {\n\tST_OFF,\n\tST_D3,\n\tST_RGND_INIT,\n\tST_RGND_1K,\n\tST_RSEN_HIGH,\n\tST_MHL_ESTABLISHED,\n\tST_FAILURE_DISCOVERY,\n\tST_FAILURE,\n};\n\nstruct sii9234 {\n\tstruct i2c_client *client[4];\n\tstruct drm_bridge bridge;\n\tstruct device *dev;\n\tstruct gpio_desc *gpio_reset;\n\tint i2c_error;\n\tstruct regulator_bulk_data supplies[4];\n\n\tstruct mutex lock;  \n\tenum sii9234_state state;\n};\n\nenum sii9234_client_id {\n\tI2C_MHL,\n\tI2C_TPI,\n\tI2C_HDMI,\n\tI2C_CBUS,\n};\n\nstatic const char * const sii9234_client_name[] = {\n\t[I2C_MHL] = \"MHL\",\n\t[I2C_TPI] = \"TPI\",\n\t[I2C_HDMI] = \"HDMI\",\n\t[I2C_CBUS] = \"CBUS\",\n};\n\nstatic int sii9234_writeb(struct sii9234 *ctx, int id, int offset,\n\t\t\t  int value)\n{\n\tint ret;\n\tstruct i2c_client *client = ctx->client[id];\n\n\tif (ctx->i2c_error)\n\t\treturn ctx->i2c_error;\n\n\tret = i2c_smbus_write_byte_data(client, offset, value);\n\tif (ret < 0)\n\t\tdev_err(ctx->dev, \"writeb: %4s[0x%02x] <- 0x%02x\\n\",\n\t\t\tsii9234_client_name[id], offset, value);\n\tctx->i2c_error = ret;\n\n\treturn ret;\n}\n\nstatic int sii9234_writebm(struct sii9234 *ctx, int id, int offset,\n\t\t\t   int value, int mask)\n{\n\tint ret;\n\tstruct i2c_client *client = ctx->client[id];\n\n\tif (ctx->i2c_error)\n\t\treturn ctx->i2c_error;\n\n\tret = i2c_smbus_write_byte(client, offset);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"writebm: %4s[0x%02x] <- 0x%02x\\n\",\n\t\t\tsii9234_client_name[id], offset, value);\n\t\tctx->i2c_error = ret;\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"writebm: %4s[0x%02x] <- 0x%02x\\n\",\n\t\t\tsii9234_client_name[id], offset, value);\n\t\tctx->i2c_error = ret;\n\t\treturn ret;\n\t}\n\n\tvalue = (value & mask) | (ret & ~mask);\n\n\tret = i2c_smbus_write_byte_data(client, offset, value);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"writebm: %4s[0x%02x] <- 0x%02x\\n\",\n\t\t\tsii9234_client_name[id], offset, value);\n\t\tctx->i2c_error = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int sii9234_readb(struct sii9234 *ctx, int id, int offset)\n{\n\tint ret;\n\tstruct i2c_client *client = ctx->client[id];\n\n\tif (ctx->i2c_error)\n\t\treturn ctx->i2c_error;\n\n\tret = i2c_smbus_write_byte(client, offset);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"readb: %4s[0x%02x]\\n\",\n\t\t\tsii9234_client_name[id], offset);\n\t\tctx->i2c_error = ret;\n\t\treturn ret;\n\t}\n\n\tret = i2c_smbus_read_byte(client);\n\tif (ret < 0) {\n\t\tdev_err(ctx->dev, \"readb: %4s[0x%02x]\\n\",\n\t\t\tsii9234_client_name[id], offset);\n\t\tctx->i2c_error = ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int sii9234_clear_error(struct sii9234 *ctx)\n{\n\tint ret = ctx->i2c_error;\n\n\tctx->i2c_error = 0;\n\n\treturn ret;\n}\n\n#define mhl_tx_writeb(sii9234, offset, value) \\\n\tsii9234_writeb(sii9234, I2C_MHL, offset, value)\n#define mhl_tx_writebm(sii9234, offset, value, mask) \\\n\tsii9234_writebm(sii9234, I2C_MHL, offset, value, mask)\n#define mhl_tx_readb(sii9234, offset) \\\n\tsii9234_readb(sii9234, I2C_MHL, offset)\n#define cbus_writeb(sii9234, offset, value) \\\n\tsii9234_writeb(sii9234, I2C_CBUS, offset, value)\n#define cbus_writebm(sii9234, offset, value, mask) \\\n\tsii9234_writebm(sii9234, I2C_CBUS, offset, value, mask)\n#define cbus_readb(sii9234, offset) \\\n\tsii9234_readb(sii9234, I2C_CBUS, offset)\n#define hdmi_writeb(sii9234, offset, value) \\\n\tsii9234_writeb(sii9234, I2C_HDMI, offset, value)\n#define hdmi_writebm(sii9234, offset, value, mask) \\\n\tsii9234_writebm(sii9234, I2C_HDMI, offset, value, mask)\n#define hdmi_readb(sii9234, offset) \\\n\tsii9234_readb(sii9234, I2C_HDMI, offset)\n#define tpi_writeb(sii9234, offset, value) \\\n\tsii9234_writeb(sii9234, I2C_TPI, offset, value)\n#define tpi_writebm(sii9234, offset, value, mask) \\\n\tsii9234_writebm(sii9234, I2C_TPI, offset, value, mask)\n#define tpi_readb(sii9234, offset) \\\n\tsii9234_readb(sii9234, I2C_TPI, offset)\n\nstatic u8 sii9234_tmds_control(struct sii9234 *ctx, bool enable)\n{\n\tmhl_tx_writebm(ctx, MHL_TX_TMDS_CCTRL, enable ? ~0 : 0,\n\t\t       BIT_TMDS_CCTRL_TMDS_OE);\n\tmhl_tx_writebm(ctx, MHL_TX_INT_CTRL_REG, enable ? ~0 : 0,\n\t\t       MHL_HPD_OUT_OVR_EN | MHL_HPD_OUT_OVR_VAL);\n\treturn sii9234_clear_error(ctx);\n}\n\nstatic int sii9234_cbus_reset(struct sii9234 *ctx)\n{\n\tint i;\n\n\tmhl_tx_writebm(ctx, MHL_TX_SRST, ~0, BIT_CBUS_RESET);\n\tmsleep(T_SRC_CBUS_DEGLITCH);\n\tmhl_tx_writebm(ctx, MHL_TX_SRST, 0, BIT_CBUS_RESET);\n\n\tfor (i = 0; i < 4; i++) {\n\t\t \n\t\tcbus_writeb(ctx, 0xE0 + i, 0xF2);\n\t\t \n\t\tcbus_writeb(ctx, 0xF0 + i, 0xF2);\n\t}\n\n\treturn sii9234_clear_error(ctx);\n}\n\n \nstatic int sii9234_cbus_init(struct sii9234 *ctx)\n{\n\tcbus_writeb(ctx, 0x07, 0xF2);\n\tcbus_writeb(ctx, 0x40, 0x03);\n\tcbus_writeb(ctx, 0x42, 0x06);\n\tcbus_writeb(ctx, 0x36, 0x0C);\n\tcbus_writeb(ctx, 0x3D, 0xFD);\n\tcbus_writeb(ctx, 0x1C, 0x01);\n\tcbus_writeb(ctx, 0x1D, 0x0F);\n\tcbus_writeb(ctx, 0x44, 0x02);\n\t \n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_DEV_STATE, 0x00);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_MHL_VERSION,\n\t\t    SII9234_MHL_VERSION);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_CAT,\n\t\t    MHL_DCAP_CAT_SOURCE);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_ADOPTER_ID_H, 0x01);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_ADOPTER_ID_L, 0x41);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_VID_LINK_MODE,\n\t\t    MHL_DCAP_VID_LINK_RGB444 | MHL_DCAP_VID_LINK_YCBCR444);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_VIDEO_TYPE,\n\t\t    MHL_DCAP_VT_GRAPHICS);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_LOG_DEV_MAP,\n\t\t    MHL_DCAP_LD_GUI);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_BANDWIDTH, 0x0F);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_FEATURE_FLAG,\n\t\t    MHL_DCAP_FEATURE_RCP_SUPPORT | MHL_DCAP_FEATURE_RAP_SUPPORT\n\t\t\t| MHL_DCAP_FEATURE_SP_SUPPORT);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_DEVICE_ID_H, 0x0);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_DEVICE_ID_L, 0x0);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_SCRATCHPAD_SIZE,\n\t\t    SII9234_SCRATCHPAD_SIZE);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_INT_STAT_SIZE,\n\t\t    SII9234_INT_STAT_SIZE);\n\tcbus_writeb(ctx, CBUS_DEVCAP_OFFSET + MHL_DCAP_RESERVED, 0);\n\tcbus_writebm(ctx, 0x31, 0x0C, 0x0C);\n\tcbus_writeb(ctx, 0x30, 0x01);\n\tcbus_writebm(ctx, 0x3C, 0x30, 0x38);\n\tcbus_writebm(ctx, 0x22, 0x0D, 0x0F);\n\tcbus_writebm(ctx, 0x2E, 0x15, 0x15);\n\tcbus_writeb(ctx, CBUS_INTR1_ENABLE_REG, 0);\n\tcbus_writeb(ctx, CBUS_INTR2_ENABLE_REG, 0);\n\n\treturn sii9234_clear_error(ctx);\n}\n\nstatic void force_usb_id_switch_open(struct sii9234 *ctx)\n{\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL1_REG, 0, 0x01);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL6_REG, ~0, USB_ID_OVR);\n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL3_REG, ~0, 0x86);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_INT_CTRL_REG, 0, 0x30);\n}\n\nstatic void release_usb_id_switch_open(struct sii9234 *ctx)\n{\n\tmsleep(T_SRC_CBUS_FLOAT);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL6_REG, 0, USB_ID_OVR);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL1_REG, ~0, 0x01);\n}\n\nstatic int sii9234_power_init(struct sii9234 *ctx)\n{\n\t \n\ttpi_writeb(ctx, TPI_DPD_REG, 0x3F);\n\t \n\thdmi_writeb(ctx, HDMI_RX_TMDS_CLK_EN_REG, 0x01);\n\t \n\thdmi_writeb(ctx, HDMI_RX_TMDS_CH_EN_REG, 0x15);\n\t \n\tmhl_tx_writeb(ctx, 0x08, 0x35);\n\treturn sii9234_clear_error(ctx);\n}\n\nstatic int sii9234_hdmi_init(struct sii9234 *ctx)\n{\n\thdmi_writeb(ctx, HDMI_RX_TMDS0_CCTRL1_REG, 0xC1);\n\thdmi_writeb(ctx, HDMI_RX_PLL_CALREFSEL_REG, 0x03);\n\thdmi_writeb(ctx, HDMI_RX_PLL_VCOCAL_REG, 0x20);\n\thdmi_writeb(ctx, HDMI_RX_EQ_DATA0_REG, 0x8A);\n\thdmi_writeb(ctx, HDMI_RX_EQ_DATA1_REG, 0x6A);\n\thdmi_writeb(ctx, HDMI_RX_EQ_DATA2_REG, 0xAA);\n\thdmi_writeb(ctx, HDMI_RX_EQ_DATA3_REG, 0xCA);\n\thdmi_writeb(ctx, HDMI_RX_EQ_DATA4_REG, 0xEA);\n\thdmi_writeb(ctx, HDMI_RX_TMDS_ZONE_CTRL_REG, 0xA0);\n\thdmi_writeb(ctx, HDMI_RX_TMDS_MODE_CTRL_REG, 0x00);\n\tmhl_tx_writeb(ctx, MHL_TX_TMDS_CCTRL, 0x34);\n\thdmi_writeb(ctx, 0x45, 0x44);\n\thdmi_writeb(ctx, 0x31, 0x0A);\n\thdmi_writeb(ctx, HDMI_RX_TMDS0_CCTRL1_REG, 0xC1);\n\n\treturn sii9234_clear_error(ctx);\n}\n\nstatic int sii9234_mhl_tx_ctl_int(struct sii9234 *ctx)\n{\n\tmhl_tx_writeb(ctx, MHL_TX_MHLTX_CTL1_REG, 0xD0);\n\tmhl_tx_writeb(ctx, MHL_TX_MHLTX_CTL2_REG, 0xFC);\n\tmhl_tx_writeb(ctx, MHL_TX_MHLTX_CTL4_REG, 0xEB);\n\tmhl_tx_writeb(ctx, MHL_TX_MHLTX_CTL7_REG, 0x0C);\n\n\treturn sii9234_clear_error(ctx);\n}\n\nstatic int sii9234_reset(struct sii9234 *ctx)\n{\n\tint ret;\n\n\tsii9234_clear_error(ctx);\n\n\tret = sii9234_power_init(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sii9234_cbus_reset(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sii9234_hdmi_init(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sii9234_mhl_tx_ctl_int(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmhl_tx_writeb(ctx, 0x2B, 0x01);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL1_REG, 0x04, 0x06);\n\t \n\tmhl_tx_writeb(ctx, MHL_TX_DISC_CTRL2_REG, (1 << 7)  \n\t\t      | 2 << ATT_THRESH_SHIFT | DEGLITCH_TIME_50MS);\n\t \n\tmhl_tx_writeb(ctx, MHL_TX_DISC_CTRL5_REG, 0x77);\n\tcbus_writebm(ctx, CBUS_LINK_CONTROL_2_REG, ~0, MHL_INIT_TIMEOUT);\n\tmhl_tx_writeb(ctx, MHL_TX_MHLTX_CTL6_REG, 0xA0);\n\t \n\tmhl_tx_writeb(ctx, MHL_TX_DISC_CTRL6_REG, BLOCK_RGND_INT |\n\t\t      DVRFLT_SEL | SINGLE_ATT);\n\t \n\tmhl_tx_writeb(ctx, MHL_TX_DISC_CTRL8_REG, 0);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL6_REG, ~0, USB_ID_OVR);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL3_REG, ~0, 0x86);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL4_REG, ~0, 0x8C);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_INT_CTRL_REG, 0, 0x06);\n\n\tmsleep(25);\n\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL6_REG, 0,  USB_ID_OVR);\n\tmhl_tx_writeb(ctx, MHL_TX_DISC_CTRL1_REG, 0x27);\n\n\tret = sii9234_clear_error(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = sii9234_cbus_init(ctx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmhl_tx_writeb(ctx, 0x05, 0x04);\n\t \n\tmhl_tx_writeb(ctx, 0x0D, 0x1C);\n\tmhl_tx_writeb(ctx, MHL_TX_INTR4_ENABLE_REG,\n\t\t      RGND_READY_MASK | CBUS_LKOUT_MASK\n\t\t\t| MHL_DISC_FAIL_MASK | MHL_EST_MASK);\n\tmhl_tx_writeb(ctx, MHL_TX_INTR1_ENABLE_REG, 0x60);\n\n\t \n\tforce_usb_id_switch_open(ctx);\n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL4_REG, 0, 0xF0);\n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL5_REG, 0, 0x03);\n\trelease_usb_id_switch_open(ctx);\n\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_INT_CTRL_REG, 0, 1 << 5);\n\tmhl_tx_writebm(ctx, MHL_TX_INT_CTRL_REG, ~0, 1 << 4);\n\n\treturn sii9234_clear_error(ctx);\n}\n\nstatic int sii9234_goto_d3(struct sii9234 *ctx)\n{\n\tint ret;\n\n\tdev_dbg(ctx->dev, \"sii9234: detection started d3\\n\");\n\n\tret = sii9234_reset(ctx);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\thdmi_writeb(ctx, 0x01, 0x03);\n\ttpi_writebm(ctx, TPI_DPD_REG, 0, 1);\n\t \n\tsii9234_clear_error(ctx);\n\n\tctx->state = ST_D3;\n\n\treturn 0;\n exit:\n\tdev_err(ctx->dev, \"%s failed\\n\", __func__);\n\treturn -1;\n}\n\nstatic int sii9234_hw_on(struct sii9234 *ctx)\n{\n\treturn regulator_bulk_enable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n}\n\nstatic void sii9234_hw_off(struct sii9234 *ctx)\n{\n\tgpiod_set_value(ctx->gpio_reset, 1);\n\tmsleep(20);\n\tregulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);\n}\n\nstatic void sii9234_hw_reset(struct sii9234 *ctx)\n{\n\tgpiod_set_value(ctx->gpio_reset, 1);\n\tmsleep(20);\n\tgpiod_set_value(ctx->gpio_reset, 0);\n}\n\nstatic void sii9234_cable_in(struct sii9234 *ctx)\n{\n\tint ret;\n\n\tmutex_lock(&ctx->lock);\n\tif (ctx->state != ST_OFF)\n\t\tgoto unlock;\n\tret = sii9234_hw_on(ctx);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tsii9234_hw_reset(ctx);\n\tsii9234_goto_d3(ctx);\n\t \n\tenable_irq(to_i2c_client(ctx->dev)->irq);\n\nunlock:\n\tmutex_unlock(&ctx->lock);\n}\n\nstatic void sii9234_cable_out(struct sii9234 *ctx)\n{\n\tmutex_lock(&ctx->lock);\n\n\tif (ctx->state == ST_OFF)\n\t\tgoto unlock;\n\n\tdisable_irq(to_i2c_client(ctx->dev)->irq);\n\ttpi_writeb(ctx, TPI_DPD_REG, 0);\n\t \n\tsii9234_hw_off(ctx);\n\n\tctx->state = ST_OFF;\n\nunlock:\n\tmutex_unlock(&ctx->lock);\n}\n\nstatic enum sii9234_state sii9234_rgnd_ready_irq(struct sii9234 *ctx)\n{\n\tint value;\n\n\tif (ctx->state == ST_D3) {\n\t\tint ret;\n\n\t\tdev_dbg(ctx->dev, \"RGND_READY_INT\\n\");\n\t\tsii9234_hw_reset(ctx);\n\n\t\tret = sii9234_reset(ctx);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctx->dev, \"sii9234_reset() failed\\n\");\n\t\t\treturn ST_FAILURE;\n\t\t}\n\n\t\treturn ST_RGND_INIT;\n\t}\n\n\t \n\tif (ctx->state != ST_RGND_INIT)\n\t\treturn ST_FAILURE;\n\n\tvalue = mhl_tx_readb(ctx, MHL_TX_STAT2_REG);\n\tif (sii9234_clear_error(ctx))\n\t\treturn ST_FAILURE;\n\n\tif ((value & RGND_INTP_MASK) != RGND_INTP_1K) {\n\t\tdev_warn(ctx->dev, \"RGND is not 1k\\n\");\n\t\treturn ST_RGND_INIT;\n\t}\n\tdev_dbg(ctx->dev, \"RGND 1K!!\\n\");\n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL4_REG, ~0, 0x8C);\n\tmhl_tx_writeb(ctx, MHL_TX_DISC_CTRL5_REG, 0x77);\n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL6_REG, ~0, 0x05);\n\tif (sii9234_clear_error(ctx))\n\t\treturn ST_FAILURE;\n\n\tmsleep(T_SRC_VBUS_CBUS_TO_STABLE);\n\treturn ST_RGND_1K;\n}\n\nstatic enum sii9234_state sii9234_mhl_established(struct sii9234 *ctx)\n{\n\tdev_dbg(ctx->dev, \"mhl est interrupt\\n\");\n\n\t \n\tmhl_tx_writeb(ctx, MHL_TX_MHLTX_CTL1_REG, 0x10);\n\t \n\tcbus_writeb(ctx, 0x07, 0x32);\n\tcbus_writebm(ctx, 0x44, ~0, 1 << 1);\n\t \n\tmhl_tx_writebm(ctx, MHL_TX_DISC_CTRL1_REG, ~0, 1);\n\tmhl_tx_writeb(ctx, MHL_TX_INTR1_ENABLE_REG,\n\t\t      RSEN_CHANGE_INT_MASK | HPD_CHANGE_INT_MASK);\n\n\tif (sii9234_clear_error(ctx))\n\t\treturn ST_FAILURE;\n\n\treturn ST_MHL_ESTABLISHED;\n}\n\nstatic enum sii9234_state sii9234_hpd_change(struct sii9234 *ctx)\n{\n\tint value;\n\n\tvalue = cbus_readb(ctx, CBUS_MSC_REQ_ABORT_REASON_REG);\n\tif (sii9234_clear_error(ctx))\n\t\treturn ST_FAILURE;\n\n\tif (value & SET_HPD_DOWNSTREAM) {\n\t\t \n\t\tsii9234_tmds_control(ctx, true);\n\t} else {\n\t\t \n\t\tsii9234_tmds_control(ctx, false);\n\t}\n\n\treturn ctx->state;\n}\n\nstatic enum sii9234_state sii9234_rsen_change(struct sii9234 *ctx)\n{\n\tint value;\n\n\t \n\tif (ctx->state != ST_RGND_1K) {\n\t\tdev_err(ctx->dev, \"RSEN_HIGH without RGND_1K\\n\");\n\t\treturn ST_FAILURE;\n\t}\n\tvalue = mhl_tx_readb(ctx, MHL_TX_SYSSTAT_REG);\n\tif (value < 0)\n\t\treturn ST_FAILURE;\n\n\tif (value & RSEN_STATUS) {\n\t\tdev_dbg(ctx->dev, \"MHL cable connected.. RSEN High\\n\");\n\t\treturn ST_RSEN_HIGH;\n\t}\n\tdev_dbg(ctx->dev, \"RSEN lost\\n\");\n\t \n\tmsleep(T_SRC_RXSENSE_DEGLITCH);\n\tvalue = mhl_tx_readb(ctx, MHL_TX_SYSSTAT_REG);\n\tif (value < 0)\n\t\treturn ST_FAILURE;\n\tdev_dbg(ctx->dev, \"sys_stat: %x\\n\", value);\n\n\tif (value & RSEN_STATUS) {\n\t\tdev_dbg(ctx->dev, \"RSEN recovery\\n\");\n\t\treturn ST_RSEN_HIGH;\n\t}\n\tdev_dbg(ctx->dev, \"RSEN Really LOW\\n\");\n\t \n\tsii9234_tmds_control(ctx, false);\n\tforce_usb_id_switch_open(ctx);\n\trelease_usb_id_switch_open(ctx);\n\n\treturn ST_FAILURE;\n}\n\nstatic irqreturn_t sii9234_irq_thread(int irq, void *data)\n{\n\tstruct sii9234 *ctx = data;\n\tint intr1, intr4;\n\tint intr1_en, intr4_en;\n\tint cbus_intr1, cbus_intr2;\n\n\tdev_dbg(ctx->dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&ctx->lock);\n\n\tintr1 = mhl_tx_readb(ctx, MHL_TX_INTR1_REG);\n\tintr4 = mhl_tx_readb(ctx, MHL_TX_INTR4_REG);\n\tintr1_en = mhl_tx_readb(ctx, MHL_TX_INTR1_ENABLE_REG);\n\tintr4_en = mhl_tx_readb(ctx, MHL_TX_INTR4_ENABLE_REG);\n\tcbus_intr1 = cbus_readb(ctx, CBUS_INT_STATUS_1_REG);\n\tcbus_intr2 = cbus_readb(ctx, CBUS_INT_STATUS_2_REG);\n\n\tif (sii9234_clear_error(ctx))\n\t\tgoto done;\n\n\tdev_dbg(ctx->dev, \"irq %02x/%02x %02x/%02x %02x/%02x\\n\",\n\t\tintr1, intr1_en, intr4, intr4_en, cbus_intr1, cbus_intr2);\n\n\tif (intr4 & RGND_READY_INT)\n\t\tctx->state = sii9234_rgnd_ready_irq(ctx);\n\tif (intr1 & RSEN_CHANGE_INT)\n\t\tctx->state = sii9234_rsen_change(ctx);\n\tif (intr4 & MHL_EST_INT)\n\t\tctx->state = sii9234_mhl_established(ctx);\n\tif (intr1 & HPD_CHANGE_INT)\n\t\tctx->state = sii9234_hpd_change(ctx);\n\tif (intr4 & CBUS_LKOUT_INT)\n\t\tctx->state = ST_FAILURE;\n\tif (intr4 & MHL_DISC_FAIL_INT)\n\t\tctx->state = ST_FAILURE_DISCOVERY;\n\n done:\n\t \n\tmhl_tx_writeb(ctx, MHL_TX_INTR1_REG, intr1);\n\tmhl_tx_writeb(ctx, MHL_TX_INTR4_REG, intr4);\n\tcbus_writeb(ctx, CBUS_MHL_STATUS_REG_0, 0xFF);\n\tcbus_writeb(ctx, CBUS_MHL_STATUS_REG_1, 0xFF);\n\tcbus_writeb(ctx, CBUS_INT_STATUS_1_REG, cbus_intr1);\n\tcbus_writeb(ctx, CBUS_INT_STATUS_2_REG, cbus_intr2);\n\n\tsii9234_clear_error(ctx);\n\n\tif (ctx->state == ST_FAILURE) {\n\t\tdev_dbg(ctx->dev, \"try to reset after failure\\n\");\n\t\tsii9234_hw_reset(ctx);\n\t\tsii9234_goto_d3(ctx);\n\t}\n\n\tif (ctx->state == ST_FAILURE_DISCOVERY) {\n\t\tdev_err(ctx->dev, \"discovery failed, no power for MHL?\\n\");\n\t\ttpi_writebm(ctx, TPI_DPD_REG, 0, 1);\n\t\tctx->state = ST_D3;\n\t}\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sii9234_init_resources(struct sii9234 *ctx,\n\t\t\t\t  struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tint ret;\n\n\tif (!ctx->dev->of_node) {\n\t\tdev_err(ctx->dev, \"not DT device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tctx->gpio_reset = devm_gpiod_get(ctx->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ctx->gpio_reset)) {\n\t\tdev_err(ctx->dev, \"failed to get reset gpio from DT\\n\");\n\t\treturn PTR_ERR(ctx->gpio_reset);\n\t}\n\n\tctx->supplies[0].supply = \"avcc12\";\n\tctx->supplies[1].supply = \"avcc33\";\n\tctx->supplies[2].supply = \"iovcc18\";\n\tctx->supplies[3].supply = \"cvcc12\";\n\tret = devm_regulator_bulk_get(ctx->dev, 4, ctx->supplies);\n\tif (ret) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(ctx->dev, \"regulator_bulk failed\\n\");\n\t\treturn ret;\n\t}\n\n\tctx->client[I2C_MHL] = client;\n\n\tctx->client[I2C_TPI] = devm_i2c_new_dummy_device(&client->dev, adapter,\n\t\t\t\t\t\t\t I2C_TPI_ADDR);\n\tif (IS_ERR(ctx->client[I2C_TPI])) {\n\t\tdev_err(ctx->dev, \"failed to create TPI client\\n\");\n\t\treturn PTR_ERR(ctx->client[I2C_TPI]);\n\t}\n\n\tctx->client[I2C_HDMI] = devm_i2c_new_dummy_device(&client->dev, adapter,\n\t\t\t\t\t\t\t  I2C_HDMI_ADDR);\n\tif (IS_ERR(ctx->client[I2C_HDMI])) {\n\t\tdev_err(ctx->dev, \"failed to create HDMI RX client\\n\");\n\t\treturn PTR_ERR(ctx->client[I2C_HDMI]);\n\t}\n\n\tctx->client[I2C_CBUS] = devm_i2c_new_dummy_device(&client->dev, adapter,\n\t\t\t\t\t\t\t  I2C_CBUS_ADDR);\n\tif (IS_ERR(ctx->client[I2C_CBUS])) {\n\t\tdev_err(ctx->dev, \"failed to create CBUS client\\n\");\n\t\treturn PTR_ERR(ctx->client[I2C_CBUS]);\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status sii9234_mode_valid(struct drm_bridge *bridge,\n\t\t\t\t\t const struct drm_display_info *info,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tif (mode->clock > MHL1_MAX_CLK)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_bridge_funcs sii9234_bridge_funcs = {\n\t.mode_valid = sii9234_mode_valid,\n};\n\nstatic int sii9234_probe(struct i2c_client *client)\n{\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct sii9234 *ctx;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tmutex_init(&ctx->lock);\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(dev, \"I2C adapter lacks SMBUS feature\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (!client->irq) {\n\t\tdev_err(dev, \"no irq provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_status_flags(client->irq, IRQ_NOAUTOEN);\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\t\t\tsii9234_irq_thread,\n\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t\"sii9234\", ctx);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to install IRQ handler\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sii9234_init_resources(ctx, client);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti2c_set_clientdata(client, ctx);\n\n\tctx->bridge.funcs = &sii9234_bridge_funcs;\n\tctx->bridge.of_node = dev->of_node;\n\tdrm_bridge_add(&ctx->bridge);\n\n\tsii9234_cable_in(ctx);\n\n\treturn 0;\n}\n\nstatic void sii9234_remove(struct i2c_client *client)\n{\n\tstruct sii9234 *ctx = i2c_get_clientdata(client);\n\n\tsii9234_cable_out(ctx);\n\tdrm_bridge_remove(&ctx->bridge);\n}\n\nstatic const struct of_device_id sii9234_dt_match[] = {\n\t{ .compatible = \"sil,sii9234\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sii9234_dt_match);\n\nstatic const struct i2c_device_id sii9234_id[] = {\n\t{ \"SII9234\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, sii9234_id);\n\nstatic struct i2c_driver sii9234_driver = {\n\t.driver = {\n\t\t.name\t= \"sii9234\",\n\t\t.of_match_table = sii9234_dt_match,\n\t},\n\t.probe = sii9234_probe,\n\t.remove = sii9234_remove,\n\t.id_table = sii9234_id,\n};\n\nmodule_i2c_driver(sii9234_driver);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}