{
  "module_name": "ti-tpd12s015.c",
  "hash_id": "c43f3507bbd42c7be9580029729af28ff0b5a398cb63c346df763556f72e9e82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/ti-tpd12s015.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include <drm/drm_bridge.h>\n\nstruct tpd12s015_device {\n\tstruct drm_bridge bridge;\n\n\tstruct gpio_desc *ct_cp_hpd_gpio;\n\tstruct gpio_desc *ls_oe_gpio;\n\tstruct gpio_desc *hpd_gpio;\n\tint hpd_irq;\n\n\tstruct drm_bridge *next_bridge;\n};\n\nstatic inline struct tpd12s015_device *to_tpd12s015(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct tpd12s015_device, bridge);\n}\n\nstatic int tpd12s015_attach(struct drm_bridge *bridge,\n\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct tpd12s015_device *tpd = to_tpd12s015(bridge);\n\tint ret;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\tret = drm_bridge_attach(bridge->encoder, tpd->next_bridge,\n\t\t\t\tbridge, flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(tpd->ls_oe_gpio, 1);\n\n\t \n\tusleep_range(300, 1000);\n\n\treturn 0;\n}\n\nstatic void tpd12s015_detach(struct drm_bridge *bridge)\n{\n\tstruct tpd12s015_device *tpd = to_tpd12s015(bridge);\n\n\tgpiod_set_value_cansleep(tpd->ls_oe_gpio, 0);\n}\n\nstatic enum drm_connector_status tpd12s015_detect(struct drm_bridge *bridge)\n{\n\tstruct tpd12s015_device *tpd = to_tpd12s015(bridge);\n\n\tif (gpiod_get_value_cansleep(tpd->hpd_gpio))\n\t\treturn connector_status_connected;\n\telse\n\t\treturn connector_status_disconnected;\n}\n\nstatic void tpd12s015_hpd_enable(struct drm_bridge *bridge)\n{\n\tstruct tpd12s015_device *tpd = to_tpd12s015(bridge);\n\n\tgpiod_set_value_cansleep(tpd->ct_cp_hpd_gpio, 1);\n}\n\nstatic void tpd12s015_hpd_disable(struct drm_bridge *bridge)\n{\n\tstruct tpd12s015_device *tpd = to_tpd12s015(bridge);\n\n\tgpiod_set_value_cansleep(tpd->ct_cp_hpd_gpio, 0);\n}\n\nstatic const struct drm_bridge_funcs tpd12s015_bridge_funcs = {\n\t.attach\t\t\t= tpd12s015_attach,\n\t.detach\t\t\t= tpd12s015_detach,\n\t.detect\t\t\t= tpd12s015_detect,\n\t.hpd_enable\t\t= tpd12s015_hpd_enable,\n\t.hpd_disable\t\t= tpd12s015_hpd_disable,\n};\n\nstatic irqreturn_t tpd12s015_hpd_isr(int irq, void *data)\n{\n\tstruct tpd12s015_device *tpd = data;\n\tstruct drm_bridge *bridge = &tpd->bridge;\n\n\tdrm_bridge_hpd_notify(bridge, tpd12s015_detect(bridge));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tpd12s015_probe(struct platform_device *pdev)\n{\n\tstruct tpd12s015_device *tpd;\n\tstruct device_node *node;\n\tstruct gpio_desc *gpio;\n\tint ret;\n\n\ttpd = devm_kzalloc(&pdev->dev, sizeof(*tpd), GFP_KERNEL);\n\tif (!tpd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, tpd);\n\n\ttpd->bridge.funcs = &tpd12s015_bridge_funcs;\n\ttpd->bridge.of_node = pdev->dev.of_node;\n\ttpd->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\ttpd->bridge.ops = DRM_BRIDGE_OP_DETECT;\n\n\t \n\tnode = of_graph_get_remote_node(pdev->dev.of_node, 1, -1);\n\tif (!node)\n\t\treturn -ENODEV;\n\n\ttpd->next_bridge = of_drm_find_bridge(node);\n\tof_node_put(node);\n\n\tif (!tpd->next_bridge)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tgpio = devm_gpiod_get_index_optional(&pdev->dev, NULL, 0,\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\ttpd->ct_cp_hpd_gpio = gpio;\n\n\tgpio = devm_gpiod_get_index_optional(&pdev->dev, NULL, 1,\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\ttpd->ls_oe_gpio = gpio;\n\n\tgpio = devm_gpiod_get_index(&pdev->dev, NULL, 2, GPIOD_IN);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\ttpd->hpd_gpio = gpio;\n\n\t \n\ttpd->hpd_irq = gpiod_to_irq(tpd->hpd_gpio);\n\tif (tpd->hpd_irq >= 0) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, tpd->hpd_irq, NULL,\n\t\t\t\t\t\ttpd12s015_hpd_isr,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"tpd12s015 hpd\", tpd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttpd->bridge.ops |= DRM_BRIDGE_OP_HPD;\n\t}\n\n\t \n\tdrm_bridge_add(&tpd->bridge);\n\n\treturn 0;\n}\n\nstatic int tpd12s015_remove(struct platform_device *pdev)\n{\n\tstruct tpd12s015_device *tpd = platform_get_drvdata(pdev);\n\n\tdrm_bridge_remove(&tpd->bridge);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id tpd12s015_of_match[] = {\n\t{ .compatible = \"ti,tpd12s015\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, tpd12s015_of_match);\n\nstatic struct platform_driver tpd12s015_driver = {\n\t.probe\t= tpd12s015_probe,\n\t.remove = tpd12s015_remove,\n\t.driver\t= {\n\t\t.name\t= \"tpd12s015\",\n\t\t.of_match_table = tpd12s015_of_match,\n\t},\n};\n\nmodule_platform_driver(tpd12s015_driver);\n\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"TPD12S015 HDMI level shifter and ESD protection driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}