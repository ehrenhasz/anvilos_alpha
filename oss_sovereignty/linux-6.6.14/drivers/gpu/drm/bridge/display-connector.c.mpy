{
  "module_name": "display-connector.c",
  "hash_id": "e9919b0394a6d69f724970998152f98cfe9fe700736bd2696eeaaf2ea5250469",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/bridge/display-connector.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_edid.h>\n\nstruct display_connector {\n\tstruct drm_bridge\tbridge;\n\n\tstruct gpio_desc\t*hpd_gpio;\n\tint\t\t\thpd_irq;\n\n\tstruct regulator\t*supply;\n\tstruct gpio_desc\t*ddc_en;\n};\n\nstatic inline struct display_connector *\nto_display_connector(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct display_connector, bridge);\n}\n\nstatic int display_connector_attach(struct drm_bridge *bridge,\n\t\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\treturn flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR ? 0 : -EINVAL;\n}\n\nstatic enum drm_connector_status\ndisplay_connector_detect(struct drm_bridge *bridge)\n{\n\tstruct display_connector *conn = to_display_connector(bridge);\n\n\tif (conn->hpd_gpio) {\n\t\tif (gpiod_get_value_cansleep(conn->hpd_gpio))\n\t\t\treturn connector_status_connected;\n\t\telse\n\t\t\treturn connector_status_disconnected;\n\t}\n\n\tif (conn->bridge.ddc && drm_probe_ddc(conn->bridge.ddc))\n\t\treturn connector_status_connected;\n\n\tswitch (conn->bridge.type) {\n\tcase DRM_MODE_CONNECTOR_DVIA:\n\tcase DRM_MODE_CONNECTOR_DVID:\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\t \n\t\treturn connector_status_disconnected;\n\n\tcase DRM_MODE_CONNECTOR_Composite:\n\tcase DRM_MODE_CONNECTOR_SVIDEO:\n\tcase DRM_MODE_CONNECTOR_VGA:\n\tdefault:\n\t\t \n\t\treturn connector_status_unknown;\n\t}\n}\n\nstatic struct edid *display_connector_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t       struct drm_connector *connector)\n{\n\tstruct display_connector *conn = to_display_connector(bridge);\n\n\treturn drm_get_edid(connector, conn->bridge.ddc);\n}\n\n \nstatic u32 *display_connector_get_output_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tunsigned int *num_output_fmts)\n{\n\tstruct drm_bridge *prev_bridge = drm_bridge_get_prev_bridge(bridge);\n\tstruct drm_bridge_state *prev_bridge_state;\n\n\tif (!prev_bridge || !prev_bridge->funcs->atomic_get_output_bus_fmts) {\n\t\tstruct drm_connector *conn = conn_state->connector;\n\t\tu32 *out_bus_fmts;\n\n\t\t*num_output_fmts = 1;\n\t\tout_bus_fmts = kmalloc(sizeof(*out_bus_fmts), GFP_KERNEL);\n\t\tif (!out_bus_fmts)\n\t\t\treturn NULL;\n\n\t\tif (conn->display_info.num_bus_formats &&\n\t\t    conn->display_info.bus_formats)\n\t\t\tout_bus_fmts[0] = conn->display_info.bus_formats[0];\n\t\telse\n\t\t\tout_bus_fmts[0] = MEDIA_BUS_FMT_FIXED;\n\n\t\treturn out_bus_fmts;\n\t}\n\n\tprev_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t\t    prev_bridge);\n\n\treturn prev_bridge->funcs->atomic_get_output_bus_fmts(prev_bridge, prev_bridge_state,\n\t\t\t\t\t\t\t      crtc_state, conn_state,\n\t\t\t\t\t\t\t      num_output_fmts);\n}\n\n \nstatic u32 *display_connector_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tu32 output_fmt,\n\t\t\t\t\tunsigned int *num_input_fmts)\n{\n\tstruct drm_bridge *prev_bridge = drm_bridge_get_prev_bridge(bridge);\n\tstruct drm_bridge_state *prev_bridge_state;\n\n\tif (!prev_bridge || !prev_bridge->funcs->atomic_get_input_bus_fmts) {\n\t\tu32 *in_bus_fmts;\n\n\t\t*num_input_fmts = 1;\n\t\tin_bus_fmts = kmalloc(sizeof(*in_bus_fmts), GFP_KERNEL);\n\t\tif (!in_bus_fmts)\n\t\t\treturn NULL;\n\n\t\tin_bus_fmts[0] = MEDIA_BUS_FMT_FIXED;\n\n\t\treturn in_bus_fmts;\n\t}\n\n\tprev_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t\t    prev_bridge);\n\n\treturn prev_bridge->funcs->atomic_get_input_bus_fmts(prev_bridge, prev_bridge_state,\n\t\t\t\t\t\t\t     crtc_state, conn_state, output_fmt,\n\t\t\t\t\t\t\t     num_input_fmts);\n}\n\nstatic const struct drm_bridge_funcs display_connector_bridge_funcs = {\n\t.attach = display_connector_attach,\n\t.detect = display_connector_detect,\n\t.get_edid = display_connector_get_edid,\n\t.atomic_get_output_bus_fmts = display_connector_get_output_bus_fmts,\n\t.atomic_get_input_bus_fmts = display_connector_get_input_bus_fmts,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n};\n\nstatic irqreturn_t display_connector_hpd_irq(int irq, void *arg)\n{\n\tstruct display_connector *conn = arg;\n\tstruct drm_bridge *bridge = &conn->bridge;\n\n\tdrm_bridge_hpd_notify(bridge, display_connector_detect(bridge));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int display_connector_get_supply(struct platform_device *pdev,\n\t\t\t\t\tstruct display_connector *conn,\n\t\t\t\t\tconst char *name)\n{\n\tconn->supply = devm_regulator_get_optional(&pdev->dev, name);\n\n\tif (conn->supply == ERR_PTR(-ENODEV))\n\t\tconn->supply = NULL;\n\n\treturn PTR_ERR_OR_ZERO(conn->supply);\n}\n\nstatic int display_connector_probe(struct platform_device *pdev)\n{\n\tstruct display_connector *conn;\n\tunsigned int type;\n\tconst char *label = NULL;\n\tint ret;\n\n\tconn = devm_kzalloc(&pdev->dev, sizeof(*conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, conn);\n\n\ttype = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\t \n\tswitch (type) {\n\tcase DRM_MODE_CONNECTOR_DVII: {\n\t\tbool analog, digital;\n\n\t\tanalog = of_property_read_bool(pdev->dev.of_node, \"analog\");\n\t\tdigital = of_property_read_bool(pdev->dev.of_node, \"digital\");\n\t\tif (analog && !digital) {\n\t\t\tconn->bridge.type = DRM_MODE_CONNECTOR_DVIA;\n\t\t} else if (!analog && digital) {\n\t\t\tconn->bridge.type = DRM_MODE_CONNECTOR_DVID;\n\t\t} else if (analog && digital) {\n\t\t\tconn->bridge.type = DRM_MODE_CONNECTOR_DVII;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"DVI connector with no type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase DRM_MODE_CONNECTOR_HDMIA: {\n\t\tconst char *hdmi_type;\n\n\t\tret = of_property_read_string(pdev->dev.of_node, \"type\",\n\t\t\t\t\t      &hdmi_type);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"HDMI connector with no type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!strcmp(hdmi_type, \"a\") || !strcmp(hdmi_type, \"c\") ||\n\t\t    !strcmp(hdmi_type, \"d\") || !strcmp(hdmi_type, \"e\")) {\n\t\t\tconn->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\t\t} else if (!strcmp(hdmi_type, \"b\")) {\n\t\t\tconn->bridge.type = DRM_MODE_CONNECTOR_HDMIB;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unsupported HDMI connector type '%s'\\n\",\n\t\t\t\thdmi_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tconn->bridge.type = type;\n\t\tbreak;\n\t}\n\n\t \n\tconn->bridge.interlace_allowed = true;\n\n\t \n\tof_property_read_string(pdev->dev.of_node, \"label\", &label);\n\n\t \n\tif (type == DRM_MODE_CONNECTOR_DVII ||\n\t    type == DRM_MODE_CONNECTOR_HDMIA ||\n\t    type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\tconn->hpd_gpio = devm_gpiod_get_optional(&pdev->dev, \"hpd\",\n\t\t\t\t\t\t\t GPIOD_IN);\n\t\tif (IS_ERR(conn->hpd_gpio))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(conn->hpd_gpio),\n\t\t\t\t\t     \"Unable to retrieve HPD GPIO\\n\");\n\n\t\tconn->hpd_irq = gpiod_to_irq(conn->hpd_gpio);\n\t} else {\n\t\tconn->hpd_irq = -EINVAL;\n\t}\n\n\tif (conn->hpd_irq >= 0) {\n\t\tret = devm_request_threaded_irq(&pdev->dev, conn->hpd_irq,\n\t\t\t\t\t\tNULL, display_connector_hpd_irq,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\"HPD\", conn);\n\t\tif (ret) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Failed to request HPD edge interrupt, falling back to polling\\n\");\n\t\t\tconn->hpd_irq = -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (type == DRM_MODE_CONNECTOR_DVII ||\n\t    type == DRM_MODE_CONNECTOR_HDMIA ||\n\t    type == DRM_MODE_CONNECTOR_VGA) {\n\t\tstruct device_node *phandle;\n\n\t\tphandle = of_parse_phandle(pdev->dev.of_node, \"ddc-i2c-bus\", 0);\n\t\tif (phandle) {\n\t\t\tconn->bridge.ddc = of_get_i2c_adapter_by_node(phandle);\n\t\t\tof_node_put(phandle);\n\t\t\tif (!conn->bridge.ddc)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t} else {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"No I2C bus specified, disabling EDID readout\\n\");\n\t\t}\n\t}\n\n\t \n\tif (type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\tint ret;\n\n\t\tret = display_connector_get_supply(pdev, conn, \"dp-pwr\");\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to get DP PWR regulator\\n\");\n\t}\n\n\t \n\tif (type == DRM_MODE_CONNECTOR_HDMIA) {\n\t\tint ret;\n\n\t\tconn->ddc_en = devm_gpiod_get_optional(&pdev->dev, \"ddc-en\",\n\t\t\t\t\t\t       GPIOD_OUT_HIGH);\n\n\t\tif (IS_ERR(conn->ddc_en)) {\n\t\t\tdev_err(&pdev->dev, \"Couldn't get ddc-en gpio\\n\");\n\t\t\treturn PTR_ERR(conn->ddc_en);\n\t\t}\n\n\t\tret = display_connector_get_supply(pdev, conn, \"hdmi-pwr\");\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to get HDMI +5V Power regulator\\n\");\n\t}\n\n\tif (conn->supply) {\n\t\tret = regulator_enable(conn->supply);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to enable PWR regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tconn->bridge.funcs = &display_connector_bridge_funcs;\n\tconn->bridge.of_node = pdev->dev.of_node;\n\n\tif (conn->bridge.ddc)\n\t\tconn->bridge.ops |= DRM_BRIDGE_OP_EDID\n\t\t\t\t |  DRM_BRIDGE_OP_DETECT;\n\tif (conn->hpd_gpio)\n\t\tconn->bridge.ops |= DRM_BRIDGE_OP_DETECT;\n\tif (conn->hpd_irq >= 0)\n\t\tconn->bridge.ops |= DRM_BRIDGE_OP_HPD;\n\n\tdev_dbg(&pdev->dev,\n\t\t\"Found %s display connector '%s' %s DDC bus and %s HPD GPIO (ops 0x%x)\\n\",\n\t\tdrm_get_connector_type_name(conn->bridge.type),\n\t\tlabel ? label : \"<unlabelled>\",\n\t\tconn->bridge.ddc ? \"with\" : \"without\",\n\t\tconn->hpd_gpio ? \"with\" : \"without\",\n\t\tconn->bridge.ops);\n\n\tdrm_bridge_add(&conn->bridge);\n\n\treturn 0;\n}\n\nstatic void display_connector_remove(struct platform_device *pdev)\n{\n\tstruct display_connector *conn = platform_get_drvdata(pdev);\n\n\tif (conn->ddc_en)\n\t\tgpiod_set_value(conn->ddc_en, 0);\n\n\tif (conn->supply)\n\t\tregulator_disable(conn->supply);\n\n\tdrm_bridge_remove(&conn->bridge);\n\n\tif (!IS_ERR(conn->bridge.ddc))\n\t\ti2c_put_adapter(conn->bridge.ddc);\n}\n\nstatic const struct of_device_id display_connector_match[] = {\n\t{\n\t\t.compatible = \"composite-video-connector\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_Composite,\n\t}, {\n\t\t.compatible = \"dvi-connector\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_DVII,\n\t}, {\n\t\t.compatible = \"hdmi-connector\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_HDMIA,\n\t}, {\n\t\t.compatible = \"svideo-connector\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_SVIDEO,\n\t}, {\n\t\t.compatible = \"vga-connector\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_VGA,\n\t}, {\n\t\t.compatible = \"dp-connector\",\n\t\t.data = (void *)DRM_MODE_CONNECTOR_DisplayPort,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, display_connector_match);\n\nstatic struct platform_driver display_connector_driver = {\n\t.probe\t= display_connector_probe,\n\t.remove_new = display_connector_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"display-connector\",\n\t\t.of_match_table\t= display_connector_match,\n\t},\n};\nmodule_platform_driver(display_connector_driver);\n\nMODULE_AUTHOR(\"Laurent Pinchart <laurent.pinchart@ideasonboard.com>\");\nMODULE_DESCRIPTION(\"Display connector driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}