{
  "module_name": "drm_displayid.c",
  "hash_id": "b8c1e0fb0f83a282ed332ab766539a3daa25dcb84c2d842878dab93f8c861f8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_displayid.c",
  "human_readable_source": "\n \n\n#include <drm/drm_displayid.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n\nstatic const struct displayid_header *\ndisplayid_get_header(const u8 *displayid, int length, int index)\n{\n\tconst struct displayid_header *base;\n\n\tif (sizeof(*base) > length - index)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbase = (const struct displayid_header *)&displayid[index];\n\n\treturn base;\n}\n\nstatic const struct displayid_header *\nvalidate_displayid(const u8 *displayid, int length, int idx)\n{\n\tint i, dispid_length;\n\tu8 csum = 0;\n\tconst struct displayid_header *base;\n\n\tbase = displayid_get_header(displayid, length, idx);\n\tif (IS_ERR(base))\n\t\treturn base;\n\n\tDRM_DEBUG_KMS(\"base revision 0x%x, length %d, %d %d\\n\",\n\t\t      base->rev, base->bytes, base->prod_id, base->ext_count);\n\n\t \n\tdispid_length = sizeof(*base) + base->bytes + 1;\n\tif (dispid_length > length - idx)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < dispid_length; i++)\n\t\tcsum += displayid[idx + i];\n\tif (csum) {\n\t\tDRM_NOTE(\"DisplayID checksum invalid, remainder is %d\\n\", csum);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn base;\n}\n\nstatic const u8 *drm_find_displayid_extension(const struct drm_edid *drm_edid,\n\t\t\t\t\t      int *length, int *idx,\n\t\t\t\t\t      int *ext_index)\n{\n\tconst u8 *displayid = drm_find_edid_extension(drm_edid, DISPLAYID_EXT, ext_index);\n\tconst struct displayid_header *base;\n\n\tif (!displayid)\n\t\treturn NULL;\n\n\t \n\t*length = EDID_LENGTH - 1;\n\t*idx = 1;\n\n\tbase = validate_displayid(displayid, *length, *idx);\n\tif (IS_ERR(base))\n\t\treturn NULL;\n\n\t*length = *idx + sizeof(*base) + base->bytes;\n\n\treturn displayid;\n}\n\nvoid displayid_iter_edid_begin(const struct drm_edid *drm_edid,\n\t\t\t       struct displayid_iter *iter)\n{\n\tmemset(iter, 0, sizeof(*iter));\n\n\titer->drm_edid = drm_edid;\n}\n\nstatic const struct displayid_block *\ndisplayid_iter_block(const struct displayid_iter *iter)\n{\n\tconst struct displayid_block *block;\n\n\tif (!iter->section)\n\t\treturn NULL;\n\n\tblock = (const struct displayid_block *)&iter->section[iter->idx];\n\n\tif (iter->idx + sizeof(*block) <= iter->length &&\n\t    iter->idx + sizeof(*block) + block->num_bytes <= iter->length)\n\t\treturn block;\n\n\treturn NULL;\n}\n\nconst struct displayid_block *\n__displayid_iter_next(struct displayid_iter *iter)\n{\n\tconst struct displayid_block *block;\n\n\tif (!iter->drm_edid)\n\t\treturn NULL;\n\n\tif (iter->section) {\n\t\t \n\t\tblock = displayid_iter_block(iter);\n\t\tif (WARN_ON(!block)) {\n\t\t\titer->section = NULL;\n\t\t\titer->drm_edid = NULL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\titer->idx += sizeof(*block) + block->num_bytes;\n\n\t\tblock = displayid_iter_block(iter);\n\t\tif (block)\n\t\t\treturn block;\n\t}\n\n\tfor (;;) {\n\t\t \n\t\tbool base_section = !iter->section;\n\n\t\titer->section = drm_find_displayid_extension(iter->drm_edid,\n\t\t\t\t\t\t\t     &iter->length,\n\t\t\t\t\t\t\t     &iter->idx,\n\t\t\t\t\t\t\t     &iter->ext_index);\n\t\tif (!iter->section) {\n\t\t\titer->drm_edid = NULL;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (base_section) {\n\t\t\tconst struct displayid_header *base;\n\n\t\t\tbase = displayid_get_header(iter->section, iter->length,\n\t\t\t\t\t\t    iter->idx);\n\t\t\tif (!IS_ERR(base)) {\n\t\t\t\titer->version = base->rev;\n\t\t\t\titer->primary_use = base->prod_id;\n\t\t\t}\n\t\t}\n\n\t\titer->idx += sizeof(struct displayid_header);\n\n\t\tblock = displayid_iter_block(iter);\n\t\tif (block)\n\t\t\treturn block;\n\t}\n}\n\nvoid displayid_iter_end(struct displayid_iter *iter)\n{\n\tmemset(iter, 0, sizeof(*iter));\n}\n\n \nu8 displayid_version(const struct displayid_iter *iter)\n{\n\treturn iter->version;\n}\n\n \nu8 displayid_primary_use(const struct displayid_iter *iter)\n{\n\treturn iter->primary_use;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}