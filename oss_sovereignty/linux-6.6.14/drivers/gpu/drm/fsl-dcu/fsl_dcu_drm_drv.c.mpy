{
  "module_name": "fsl_dcu_drm_drv.c",
  "hash_id": "18c4cf3defb9e847f678162f666149c1969c0c3876829acafc8b2dcefd3051e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"fsl_dcu_drm_crtc.h\"\n#include \"fsl_dcu_drm_drv.h\"\n#include \"fsl_tcon.h\"\n\nstatic int legacyfb_depth = 24;\nmodule_param(legacyfb_depth, int, 0444);\n\nstatic bool fsl_dcu_drm_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tif (reg == DCU_INT_STATUS || reg == DCU_UPDATE_MODE)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct regmap_config fsl_dcu_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.volatile_reg = fsl_dcu_drm_is_volatile_reg,\n};\n\nstatic void fsl_dcu_irq_reset(struct drm_device *dev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\n\tregmap_write(fsl_dev->regmap, DCU_INT_STATUS, ~0);\n\tregmap_write(fsl_dev->regmap, DCU_INT_MASK, ~0);\n}\n\nstatic irqreturn_t fsl_dcu_drm_irq(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tunsigned int int_status;\n\tint ret;\n\n\tret = regmap_read(fsl_dev->regmap, DCU_INT_STATUS, &int_status);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"read DCU_INT_STATUS failed\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (int_status & DCU_INT_STATUS_VBLANK)\n\t\tdrm_handle_vblank(dev, 0);\n\n\tregmap_write(fsl_dev->regmap, DCU_INT_STATUS, int_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsl_dcu_irq_install(struct drm_device *dev, unsigned int irq)\n{\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tfsl_dcu_irq_reset(dev);\n\n\treturn request_irq(irq, fsl_dcu_drm_irq, 0, dev->driver->name, dev);\n}\n\nstatic void fsl_dcu_irq_uninstall(struct drm_device *dev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\n\tfsl_dcu_irq_reset(dev);\n\tfree_irq(fsl_dev->irq, dev);\n}\n\nstatic int fsl_dcu_load(struct drm_device *dev, unsigned long flags)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tint ret;\n\n\tret = fsl_dcu_drm_modeset_init(fsl_dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to initialize mode setting\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drm_vblank_init(dev, dev->mode_config.num_crtc);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to initialize vblank\\n\");\n\t\tgoto done_vblank;\n\t}\n\n\tret = fsl_dcu_irq_install(dev, fsl_dev->irq);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to install IRQ handler\\n\");\n\t\tgoto done_irq;\n\t}\n\n\tif (legacyfb_depth != 16 && legacyfb_depth != 24 &&\n\t    legacyfb_depth != 32) {\n\t\tdev_warn(dev->dev,\n\t\t\t\"Invalid legacyfb_depth.  Defaulting to 24bpp\\n\");\n\t\tlegacyfb_depth = 24;\n\t}\n\n\treturn 0;\ndone_irq:\n\tdrm_kms_helper_poll_fini(dev);\n\n\tdrm_mode_config_cleanup(dev);\ndone_vblank:\n\tdev->dev_private = NULL;\n\n\treturn ret;\n}\n\nstatic void fsl_dcu_unload(struct drm_device *dev)\n{\n\tdrm_atomic_helper_shutdown(dev);\n\tdrm_kms_helper_poll_fini(dev);\n\n\tdrm_mode_config_cleanup(dev);\n\tfsl_dcu_irq_uninstall(dev);\n\n\tdev->dev_private = NULL;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fsl_dcu_drm_fops);\n\nstatic const struct drm_driver fsl_dcu_drm_driver = {\n\t.driver_features\t= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\t.load\t\t\t= fsl_dcu_load,\n\t.unload\t\t\t= fsl_dcu_unload,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops\t\t\t= &fsl_dcu_drm_fops,\n\t.name\t\t\t= \"fsl-dcu-drm\",\n\t.desc\t\t\t= \"Freescale DCU DRM\",\n\t.date\t\t\t= \"20160425\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 1,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsl_dcu_drm_pm_suspend(struct device *dev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!fsl_dev)\n\t\treturn 0;\n\n\tdisable_irq(fsl_dev->irq);\n\n\tret = drm_mode_config_helper_suspend(fsl_dev->drm);\n\tif (ret) {\n\t\tenable_irq(fsl_dev->irq);\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(fsl_dev->clk);\n\n\treturn 0;\n}\n\nstatic int fsl_dcu_drm_pm_resume(struct device *dev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!fsl_dev)\n\t\treturn 0;\n\n\tret = clk_prepare_enable(fsl_dev->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable dcu clk\\n\");\n\t\treturn ret;\n\t}\n\n\tif (fsl_dev->tcon)\n\t\tfsl_tcon_bypass_enable(fsl_dev->tcon);\n\tfsl_dcu_drm_init_planes(fsl_dev->drm);\n\tenable_irq(fsl_dev->irq);\n\n\tdrm_mode_config_helper_resume(fsl_dev->drm);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops fsl_dcu_drm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fsl_dcu_drm_pm_suspend, fsl_dcu_drm_pm_resume)\n};\n\nstatic const struct fsl_dcu_soc_data fsl_dcu_ls1021a_data = {\n\t.name = \"ls1021a\",\n\t.total_layer = 16,\n\t.max_layer = 4,\n\t.layer_regs = LS1021A_LAYER_REG_NUM,\n};\n\nstatic const struct fsl_dcu_soc_data fsl_dcu_vf610_data = {\n\t.name = \"vf610\",\n\t.total_layer = 64,\n\t.max_layer = 6,\n\t.layer_regs = VF610_LAYER_REG_NUM,\n};\n\nstatic const struct of_device_id fsl_dcu_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,ls1021a-dcu\",\n\t\t.data = &fsl_dcu_ls1021a_data,\n\t}, {\n\t\t.compatible = \"fsl,vf610-dcu\",\n\t\t.data = &fsl_dcu_vf610_data,\n\t}, {\n\t},\n};\nMODULE_DEVICE_TABLE(of, fsl_dcu_of_match);\n\nstatic int fsl_dcu_drm_probe(struct platform_device *pdev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev;\n\tstruct drm_device *drm;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tstruct clk *pix_clk_in;\n\tchar pix_clk_name[32];\n\tconst char *pix_clk_in_name;\n\tconst struct of_device_id *id;\n\tint ret;\n\tu8 div_ratio_shift = 0;\n\n\tfsl_dev = devm_kzalloc(dev, sizeof(*fsl_dev), GFP_KERNEL);\n\tif (!fsl_dev)\n\t\treturn -ENOMEM;\n\n\tid = of_match_node(fsl_dcu_of_match, pdev->dev.of_node);\n\tif (!id)\n\t\treturn -ENODEV;\n\tfsl_dev->soc = id->data;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tbase = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\treturn ret;\n\t}\n\n\tfsl_dev->irq = platform_get_irq(pdev, 0);\n\tif (fsl_dev->irq < 0) {\n\t\tdev_err(dev, \"failed to get irq\\n\");\n\t\treturn fsl_dev->irq;\n\t}\n\n\tfsl_dev->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t&fsl_dcu_regmap_config);\n\tif (IS_ERR(fsl_dev->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(fsl_dev->regmap);\n\t}\n\n\tfsl_dev->clk = devm_clk_get(dev, \"dcu\");\n\tif (IS_ERR(fsl_dev->clk)) {\n\t\tdev_err(dev, \"failed to get dcu clock\\n\");\n\t\treturn PTR_ERR(fsl_dev->clk);\n\t}\n\tret = clk_prepare_enable(fsl_dev->clk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable dcu clk\\n\");\n\t\treturn ret;\n\t}\n\n\tpix_clk_in = devm_clk_get(dev, \"pix\");\n\tif (IS_ERR(pix_clk_in)) {\n\t\t \n\t\tpix_clk_in = fsl_dev->clk;\n\t}\n\n\tif (of_property_read_bool(dev->of_node, \"big-endian\"))\n\t\tdiv_ratio_shift = 24;\n\n\tpix_clk_in_name = __clk_get_name(pix_clk_in);\n\tsnprintf(pix_clk_name, sizeof(pix_clk_name), \"%s_pix\", pix_clk_in_name);\n\tfsl_dev->pix_clk = clk_register_divider(dev, pix_clk_name,\n\t\t\tpix_clk_in_name, 0, base + DCU_DIV_RATIO,\n\t\t\tdiv_ratio_shift, 8, CLK_DIVIDER_ROUND_CLOSEST, NULL);\n\tif (IS_ERR(fsl_dev->pix_clk)) {\n\t\tdev_err(dev, \"failed to register pix clk\\n\");\n\t\tret = PTR_ERR(fsl_dev->pix_clk);\n\t\tgoto disable_clk;\n\t}\n\n\tfsl_dev->tcon = fsl_tcon_init(dev);\n\n\tdrm = drm_dev_alloc(&fsl_dcu_drm_driver, dev);\n\tif (IS_ERR(drm)) {\n\t\tret = PTR_ERR(drm);\n\t\tgoto unregister_pix_clk;\n\t}\n\n\tfsl_dev->dev = dev;\n\tfsl_dev->drm = drm;\n\tfsl_dev->np = dev->of_node;\n\tdrm->dev_private = fsl_dev;\n\tdev_set_drvdata(dev, fsl_dev);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto put;\n\n\tdrm_fbdev_dma_setup(drm, legacyfb_depth);\n\n\treturn 0;\n\nput:\n\tdrm_dev_put(drm);\nunregister_pix_clk:\n\tclk_unregister(fsl_dev->pix_clk);\ndisable_clk:\n\tclk_disable_unprepare(fsl_dev->clk);\n\treturn ret;\n}\n\nstatic void fsl_dcu_drm_remove(struct platform_device *pdev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = platform_get_drvdata(pdev);\n\n\tdrm_dev_unregister(fsl_dev->drm);\n\tdrm_dev_put(fsl_dev->drm);\n\tclk_disable_unprepare(fsl_dev->clk);\n\tclk_unregister(fsl_dev->pix_clk);\n}\n\nstatic struct platform_driver fsl_dcu_drm_platform_driver = {\n\t.probe\t\t= fsl_dcu_drm_probe,\n\t.remove_new\t= fsl_dcu_drm_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"fsl-dcu\",\n\t\t.pm\t= &fsl_dcu_drm_pm_ops,\n\t\t.of_match_table = fsl_dcu_of_match,\n\t},\n};\n\ndrm_module_platform_driver(fsl_dcu_drm_platform_driver);\n\nMODULE_DESCRIPTION(\"Freescale DCU DRM Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}