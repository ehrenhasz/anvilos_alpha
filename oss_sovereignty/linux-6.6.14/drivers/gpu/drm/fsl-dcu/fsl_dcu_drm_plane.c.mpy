{
  "module_name": "fsl_dcu_drm_plane.c",
  "hash_id": "41a7d99a61b7c9f8b4a9905699865f660da53a33a69a351d58e2ba54665d579e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c",
  "human_readable_source": "\n \n\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"fsl_dcu_drm_drv.h\"\n#include \"fsl_dcu_drm_plane.h\"\n\nstatic int fsl_dcu_drm_plane_index(struct drm_plane *plane)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = plane->dev->dev_private;\n\tunsigned int total_layer = fsl_dev->soc->total_layer;\n\tunsigned int index;\n\n\tindex = drm_plane_index(plane);\n\tif (index < total_layer)\n\t\treturn total_layer - index - 1;\n\n\tdev_err(fsl_dev->dev, \"No more layer left\\n\");\n\treturn -EINVAL;\n}\n\nstatic int fsl_dcu_drm_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\n\tif (!new_plane_state->fb || !new_plane_state->crtc)\n\t\treturn 0;\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_YUV422:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void fsl_dcu_drm_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = plane->dev->dev_private;\n\tunsigned int value;\n\tint index;\n\n\tindex = fsl_dcu_drm_plane_index(plane);\n\tif (index < 0)\n\t\treturn;\n\n\tregmap_read(fsl_dev->regmap, DCU_CTRLDESCLN(index, 4), &value);\n\tvalue &= ~DCU_LAYER_EN;\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 4), value);\n}\n\nstatic void fsl_dcu_drm_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t    struct drm_atomic_state *state)\n\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = plane->dev->dev_private;\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\tstruct drm_gem_dma_object *gem;\n\tunsigned int alpha = DCU_LAYER_AB_NONE, bpp;\n\tint index;\n\n\tif (!fb)\n\t\treturn;\n\n\tindex = fsl_dcu_drm_plane_index(plane);\n\tif (index < 0)\n\t\treturn;\n\n\tgem = drm_fb_dma_get_gem_obj(fb, 0);\n\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\t\tbpp = FSL_DCU_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB888:\n\t\tbpp = FSL_DCU_RGB888;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB8888:\n\t\talpha = DCU_LAYER_AB_WHOLE_FRAME;\n\t\tfallthrough;\n\tcase DRM_FORMAT_XRGB8888:\n\t\tbpp = FSL_DCU_ARGB8888;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB4444:\n\t\talpha = DCU_LAYER_AB_WHOLE_FRAME;\n\t\tfallthrough;\n\tcase DRM_FORMAT_XRGB4444:\n\t\tbpp = FSL_DCU_ARGB4444;\n\t\tbreak;\n\tcase DRM_FORMAT_ARGB1555:\n\t\talpha = DCU_LAYER_AB_WHOLE_FRAME;\n\t\tfallthrough;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tbpp = FSL_DCU_ARGB1555;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\tbpp = FSL_DCU_YUV422;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 1),\n\t\t     DCU_LAYER_HEIGHT(new_state->crtc_h) |\n\t\t     DCU_LAYER_WIDTH(new_state->crtc_w));\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 2),\n\t\t     DCU_LAYER_POSY(new_state->crtc_y) |\n\t\t     DCU_LAYER_POSX(new_state->crtc_x));\n\tregmap_write(fsl_dev->regmap,\n\t\t     DCU_CTRLDESCLN(index, 3), gem->dma_addr);\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 4),\n\t\t     DCU_LAYER_EN |\n\t\t     DCU_LAYER_TRANS(0xff) |\n\t\t     DCU_LAYER_BPP(bpp) |\n\t\t     alpha);\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 5),\n\t\t     DCU_LAYER_CKMAX_R(0xFF) |\n\t\t     DCU_LAYER_CKMAX_G(0xFF) |\n\t\t     DCU_LAYER_CKMAX_B(0xFF));\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 6),\n\t\t     DCU_LAYER_CKMIN_R(0) |\n\t\t     DCU_LAYER_CKMIN_G(0) |\n\t\t     DCU_LAYER_CKMIN_B(0));\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 7), 0);\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 8),\n\t\t     DCU_LAYER_FG_FCOLOR(0));\n\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 9),\n\t\t     DCU_LAYER_BG_BCOLOR(0));\n\n\tif (!strcmp(fsl_dev->soc->name, \"ls1021a\")) {\n\t\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(index, 10),\n\t\t\t     DCU_LAYER_POST_SKIP(0) |\n\t\t\t     DCU_LAYER_PRE_SKIP(0));\n\t}\n\n\treturn;\n}\n\nstatic const struct drm_plane_helper_funcs fsl_dcu_drm_plane_helper_funcs = {\n\t.atomic_check = fsl_dcu_drm_plane_atomic_check,\n\t.atomic_disable = fsl_dcu_drm_plane_atomic_disable,\n\t.atomic_update = fsl_dcu_drm_plane_atomic_update,\n};\n\nstatic const struct drm_plane_funcs fsl_dcu_drm_plane_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.destroy = drm_plane_helper_destroy,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.reset = drm_atomic_helper_plane_reset,\n\t.update_plane = drm_atomic_helper_update_plane,\n};\n\nstatic const u32 fsl_dcu_drm_plane_formats[] = {\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_YUV422,\n};\n\nvoid fsl_dcu_drm_init_planes(struct drm_device *dev)\n{\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tint i, j;\n\n\tfor (i = 0; i < fsl_dev->soc->total_layer; i++) {\n\t\tfor (j = 1; j <= fsl_dev->soc->layer_regs; j++)\n\t\t\tregmap_write(fsl_dev->regmap, DCU_CTRLDESCLN(i, j), 0);\n\t}\n}\n\nstruct drm_plane *fsl_dcu_drm_primary_create_plane(struct drm_device *dev)\n{\n\tstruct drm_plane *primary;\n\tint ret;\n\n\tprimary = kzalloc(sizeof(*primary), GFP_KERNEL);\n\tif (!primary) {\n\t\tDRM_DEBUG_KMS(\"Failed to allocate primary plane\\n\");\n\t\treturn NULL;\n\t}\n\n\t \n\tret = drm_universal_plane_init(dev, primary, 0,\n\t\t\t\t       &fsl_dcu_drm_plane_funcs,\n\t\t\t\t       fsl_dcu_drm_plane_formats,\n\t\t\t\t       ARRAY_SIZE(fsl_dcu_drm_plane_formats),\n\t\t\t\t       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tkfree(primary);\n\t\tprimary = NULL;\n\t}\n\tdrm_plane_helper_add(primary, &fsl_dcu_drm_plane_helper_funcs);\n\n\treturn primary;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}