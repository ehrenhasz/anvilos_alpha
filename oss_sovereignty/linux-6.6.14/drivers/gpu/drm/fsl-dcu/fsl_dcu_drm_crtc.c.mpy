{
  "module_name": "fsl_dcu_drm_crtc.c",
  "hash_id": "1b005e7661869fabb632b8a4181dc49c0968f7f297dee7ca347d81573fa894a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/regmap.h>\n\n#include <video/videomode.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"fsl_dcu_drm_crtc.h\"\n#include \"fsl_dcu_drm_drv.h\"\n#include \"fsl_dcu_drm_plane.h\"\n\nstatic void fsl_dcu_drm_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\n\tregmap_write(fsl_dev->regmap,\n\t\t     DCU_UPDATE_MODE, DCU_UPDATE_MODE_READREG);\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic void fsl_dcu_drm_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\n\t \n\tdrm_atomic_helper_disable_planes_on_crtc(old_crtc_state, true);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tregmap_update_bits(fsl_dev->regmap, DCU_DCU_MODE,\n\t\t\t   DCU_MODE_DCU_MODE_MASK,\n\t\t\t   DCU_MODE_DCU_MODE(DCU_MODE_OFF));\n\tregmap_write(fsl_dev->regmap, DCU_UPDATE_MODE,\n\t\t     DCU_UPDATE_MODE_READREG);\n\tclk_disable_unprepare(fsl_dev->pix_clk);\n}\n\nstatic void fsl_dcu_drm_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\n\tclk_prepare_enable(fsl_dev->pix_clk);\n\tregmap_update_bits(fsl_dev->regmap, DCU_DCU_MODE,\n\t\t\t   DCU_MODE_DCU_MODE_MASK,\n\t\t\t   DCU_MODE_DCU_MODE(DCU_MODE_NORMAL));\n\tregmap_write(fsl_dev->regmap, DCU_UPDATE_MODE,\n\t\t     DCU_UPDATE_MODE_READREG);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void fsl_dcu_drm_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tstruct drm_connector *con = &fsl_dev->connector.base;\n\tstruct drm_display_mode *mode = &crtc->state->mode;\n\tunsigned int pol = 0;\n\tstruct videomode vm;\n\n\tclk_set_rate(fsl_dev->pix_clk, mode->clock * 1000);\n\n\tdrm_display_mode_to_videomode(mode, &vm);\n\n\t \n\tif (!(con->display_info.bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE))\n\t\tpol |= DCU_SYN_POL_INV_PXCK;\n\n\tif (vm.flags & DISPLAY_FLAGS_HSYNC_LOW)\n\t\tpol |= DCU_SYN_POL_INV_HS_LOW;\n\n\tif (vm.flags & DISPLAY_FLAGS_VSYNC_LOW)\n\t\tpol |= DCU_SYN_POL_INV_VS_LOW;\n\n\tregmap_write(fsl_dev->regmap, DCU_HSYN_PARA,\n\t\t     DCU_HSYN_PARA_BP(vm.hback_porch) |\n\t\t     DCU_HSYN_PARA_PW(vm.hsync_len) |\n\t\t     DCU_HSYN_PARA_FP(vm.hfront_porch));\n\tregmap_write(fsl_dev->regmap, DCU_VSYN_PARA,\n\t\t     DCU_VSYN_PARA_BP(vm.vback_porch) |\n\t\t     DCU_VSYN_PARA_PW(vm.vsync_len) |\n\t\t     DCU_VSYN_PARA_FP(vm.vfront_porch));\n\tregmap_write(fsl_dev->regmap, DCU_DISP_SIZE,\n\t\t     DCU_DISP_SIZE_DELTA_Y(vm.vactive) |\n\t\t     DCU_DISP_SIZE_DELTA_X(vm.hactive));\n\tregmap_write(fsl_dev->regmap, DCU_SYN_POL, pol);\n\tregmap_write(fsl_dev->regmap, DCU_BGND, DCU_BGND_R(0) |\n\t\t     DCU_BGND_G(0) | DCU_BGND_B(0));\n\tregmap_write(fsl_dev->regmap, DCU_DCU_MODE,\n\t\t     DCU_MODE_BLEND_ITER(1) | DCU_MODE_RASTER_EN);\n\tregmap_write(fsl_dev->regmap, DCU_THRESHOLD,\n\t\t     DCU_THRESHOLD_LS_BF_VS(BF_VS_VAL) |\n\t\t     DCU_THRESHOLD_OUT_BUF_HIGH(BUF_MAX_VAL) |\n\t\t     DCU_THRESHOLD_OUT_BUF_LOW(BUF_MIN_VAL));\n\treturn;\n}\n\nstatic const struct drm_crtc_helper_funcs fsl_dcu_drm_crtc_helper_funcs = {\n\t.atomic_disable = fsl_dcu_drm_crtc_atomic_disable,\n\t.atomic_flush = fsl_dcu_drm_crtc_atomic_flush,\n\t.atomic_enable = fsl_dcu_drm_crtc_atomic_enable,\n\t.mode_set_nofb = fsl_dcu_drm_crtc_mode_set_nofb,\n};\n\nstatic int fsl_dcu_drm_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tunsigned int value;\n\n\tregmap_read(fsl_dev->regmap, DCU_INT_MASK, &value);\n\tvalue &= ~DCU_INT_MASK_VBLANK;\n\tregmap_write(fsl_dev->regmap, DCU_INT_MASK, value);\n\n\treturn 0;\n}\n\nstatic void fsl_dcu_drm_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct fsl_dcu_drm_device *fsl_dev = dev->dev_private;\n\tunsigned int value;\n\n\tregmap_read(fsl_dev->regmap, DCU_INT_MASK, &value);\n\tvalue |= DCU_INT_MASK_VBLANK;\n\tregmap_write(fsl_dev->regmap, DCU_INT_MASK, value);\n}\n\nstatic const struct drm_crtc_funcs fsl_dcu_drm_crtc_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.destroy = drm_crtc_cleanup,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.set_config = drm_atomic_helper_set_config,\n\t.enable_vblank = fsl_dcu_drm_crtc_enable_vblank,\n\t.disable_vblank = fsl_dcu_drm_crtc_disable_vblank,\n};\n\nint fsl_dcu_drm_crtc_create(struct fsl_dcu_drm_device *fsl_dev)\n{\n\tstruct drm_plane *primary;\n\tstruct drm_crtc *crtc = &fsl_dev->crtc;\n\tint ret;\n\n\tfsl_dcu_drm_init_planes(fsl_dev->drm);\n\n\tprimary = fsl_dcu_drm_primary_create_plane(fsl_dev->drm);\n\tif (!primary)\n\t\treturn -ENOMEM;\n\n\tret = drm_crtc_init_with_planes(fsl_dev->drm, crtc, primary, NULL,\n\t\t\t\t\t&fsl_dcu_drm_crtc_funcs, NULL);\n\tif (ret) {\n\t\tprimary->funcs->destroy(primary);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &fsl_dcu_drm_crtc_helper_funcs);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}