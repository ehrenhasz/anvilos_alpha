{
  "module_name": "fsl_dcu_drm_rgb.c",
  "hash_id": "184209da06040aa10fdf9610b5c39251621f1a41be6e8de5952199a9f13994db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c",
  "human_readable_source": "\n \n\n#include <linux/backlight.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n\n#include \"fsl_dcu_drm_drv.h\"\n#include \"fsl_tcon.h\"\n\nint fsl_dcu_drm_encoder_create(struct fsl_dcu_drm_device *fsl_dev,\n\t\t\t       struct drm_crtc *crtc)\n{\n\tstruct drm_encoder *encoder = &fsl_dev->encoder;\n\tint ret;\n\n\tencoder->possible_crtcs = 1;\n\n\t \n\tif (fsl_dev->tcon)\n\t\tfsl_tcon_bypass_enable(fsl_dev->tcon);\n\n\tret = drm_simple_encoder_init(fsl_dev->drm, encoder,\n\t\t\t\t      DRM_MODE_ENCODER_LVDS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void fsl_dcu_drm_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n}\n\nstatic const struct drm_connector_funcs fsl_dcu_drm_connector_funcs = {\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n\t.destroy = fsl_dcu_drm_connector_destroy,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.reset = drm_atomic_helper_connector_reset,\n};\n\nstatic int fsl_dcu_drm_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct fsl_dcu_drm_connector *fsl_connector;\n\n\tfsl_connector = to_fsl_dcu_connector(connector);\n\treturn drm_panel_get_modes(fsl_connector->panel, connector);\n}\n\nstatic enum drm_mode_status\nfsl_dcu_drm_connector_mode_valid(struct drm_connector *connector,\n\t\t\t\t struct drm_display_mode *mode)\n{\n\tif (mode->hdisplay & 0xf)\n\t\treturn MODE_ERROR;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs connector_helper_funcs = {\n\t.get_modes = fsl_dcu_drm_connector_get_modes,\n\t.mode_valid = fsl_dcu_drm_connector_mode_valid,\n};\n\nstatic int fsl_dcu_attach_panel(struct fsl_dcu_drm_device *fsl_dev,\n\t\t\t\t struct drm_panel *panel)\n{\n\tstruct drm_encoder *encoder = &fsl_dev->encoder;\n\tstruct drm_connector *connector = &fsl_dev->connector.base;\n\tint ret;\n\n\tfsl_dev->connector.encoder = encoder;\n\n\tret = drm_connector_init(fsl_dev->drm, connector,\n\t\t\t\t &fsl_dcu_drm_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_LVDS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_connector_helper_add(connector, &connector_helper_funcs);\n\tret = drm_connector_register(connector);\n\tif (ret < 0)\n\t\tgoto err_cleanup;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret < 0)\n\t\tgoto err_sysfs;\n\n\treturn 0;\n\nerr_sysfs:\n\tdrm_connector_unregister(connector);\nerr_cleanup:\n\tdrm_connector_cleanup(connector);\n\treturn ret;\n}\n\nint fsl_dcu_create_outputs(struct fsl_dcu_drm_device *fsl_dev)\n{\n\tstruct device_node *panel_node;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\t \n\tpanel_node = of_parse_phandle(fsl_dev->np, \"fsl,panel\", 0);\n\tif (panel_node) {\n\t\tfsl_dev->connector.panel = of_drm_find_panel(panel_node);\n\t\tof_node_put(panel_node);\n\t\tif (IS_ERR(fsl_dev->connector.panel))\n\t\t\treturn PTR_ERR(fsl_dev->connector.panel);\n\n\t\treturn fsl_dcu_attach_panel(fsl_dev, fsl_dev->connector.panel);\n\t}\n\n\tret = drm_of_find_panel_or_bridge(fsl_dev->np, 0, 0, &panel, &bridge);\n\tif (ret)\n\t\treturn ret;\n\n\tif (panel) {\n\t\tfsl_dev->connector.panel = panel;\n\t\treturn fsl_dcu_attach_panel(fsl_dev, panel);\n\t}\n\n\treturn drm_bridge_attach(&fsl_dev->encoder, bridge, NULL, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}