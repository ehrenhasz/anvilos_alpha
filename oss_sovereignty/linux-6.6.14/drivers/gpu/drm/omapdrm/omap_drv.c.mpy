{
  "module_name": "omap_drv.c",
  "hash_id": "1a139d931b9897c7f54db4fbfa836d6428b79f5977c675de32cd5cd8008f2824",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_drv.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/sort.h>\n#include <linux/sys_soc.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_prime.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"omap_dmm_tiler.h\"\n#include \"omap_drv.h\"\n#include \"omap_fbdev.h\"\n\n#define DRIVER_NAME\t\tMODULE_NAME\n#define DRIVER_DESC\t\t\"OMAP DRM\"\n#define DRIVER_DATE\t\t\"20110917\"\n#define DRIVER_MAJOR\t\t1\n#define DRIVER_MINOR\t\t0\n#define DRIVER_PATCHLEVEL\t0\n\n \n\n \n\nstatic void omap_atomic_wait_for_completion(struct drm_device *dev,\n\t\t\t\t\t    struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_new_crtc_in_state(old_state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tret = omap_crtc_wait_pending(crtc);\n\n\t\tif (!ret)\n\t\t\tdev_warn(dev->dev,\n\t\t\t\t \"atomic complete timeout (pipe %u)!\\n\", i);\n\t}\n}\n\nstatic void omap_atomic_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\n\tdispc_runtime_get(priv->dispc);\n\n\t \n\tdrm_atomic_helper_commit_modeset_disables(dev, old_state);\n\n\tif (priv->omaprev != 0x3430) {\n\t\t \n\t\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\t\tomap_atomic_wait_for_completion(dev, old_state);\n\n\t\tdrm_atomic_helper_commit_planes(dev, old_state, 0);\n\n\t\tdrm_atomic_helper_commit_hw_done(old_state);\n\t} else {\n\t\t \n\t\tdrm_atomic_helper_commit_planes(dev, old_state, 0);\n\n\t\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\n\t\tdrm_atomic_helper_commit_hw_done(old_state);\n\t}\n\n\t \n\tomap_atomic_wait_for_completion(dev, old_state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, old_state);\n\n\tdispc_runtime_put(priv->dispc);\n}\n\nstatic int drm_atomic_state_normalized_zpos_cmp(const void *a, const void *b)\n{\n\tconst struct drm_plane_state *sa = *(struct drm_plane_state **)a;\n\tconst struct drm_plane_state *sb = *(struct drm_plane_state **)b;\n\n\tif (sa->normalized_zpos != sb->normalized_zpos)\n\t\treturn sa->normalized_zpos - sb->normalized_zpos;\n\telse\n\t\treturn sa->plane->base.id - sb->plane->base.id;\n}\n\n \nstatic int omap_atomic_update_normalize_zpos(struct drm_device *dev,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_state, *new_state;\n\tstruct drm_plane *plane;\n\tint c, i, n, inc;\n\tint total_planes = dev->mode_config.num_total_plane;\n\tstruct drm_plane_state **states;\n\tint ret = 0;\n\n\tstates = kmalloc_array(total_planes, sizeof(*states), GFP_KERNEL);\n\tif (!states)\n\t\treturn -ENOMEM;\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_state, new_state, c) {\n\t\tif (old_state->plane_mask == new_state->plane_mask &&\n\t\t    !new_state->zpos_changed)\n\t\t\tcontinue;\n\n\t\t \n\t\tn = 0;\n\n\t\t \n\t\tdrm_for_each_plane_mask(plane, dev, new_state->plane_mask) {\n\t\t\tstruct drm_plane_state *plane_state =\n\t\t\t\tdrm_atomic_get_plane_state(new_state->state,\n\t\t\t\t\t\t\t   plane);\n\t\t\tif (IS_ERR(plane_state)) {\n\t\t\t\tret = PTR_ERR(plane_state);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tstates[n++] = plane_state;\n\t\t}\n\n\t\tsort(states, n, sizeof(*states),\n\t\t     drm_atomic_state_normalized_zpos_cmp, NULL);\n\n\t\tfor (i = 0, inc = 0; i < n; i++) {\n\t\t\tplane = states[i]->plane;\n\n\t\t\tstates[i]->normalized_zpos = i + inc;\n\t\t\tDRM_DEBUG_ATOMIC(\"[PLANE:%d:%s] updated normalized zpos value %d\\n\",\n\t\t\t\t\t plane->base.id, plane->name,\n\t\t\t\t\t states[i]->normalized_zpos);\n\n\t\t\tif (is_omap_plane_dual_overlay(states[i]))\n\t\t\t\tinc++;\n\t\t}\n\t\tnew_state->zpos_changed = true;\n\t}\n\ndone:\n\tkfree(states);\n\treturn ret;\n}\n\nstatic int omap_atomic_check(struct drm_device *dev,\n\t\t\t     struct drm_atomic_state *state)\n{\n\tint ret;\n\n\tret = drm_atomic_helper_check(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev->mode_config.normalize_zpos) {\n\t\tret = omap_atomic_update_normalize_zpos(dev, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_mode_config_helper_funcs omap_mode_config_helper_funcs = {\n\t.atomic_commit_tail = omap_atomic_commit_tail,\n};\n\nstatic const struct drm_mode_config_funcs omap_mode_config_funcs = {\n\t.fb_create = omap_framebuffer_create,\n\t.atomic_check = omap_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\n \n\n \nstruct omap_global_state *\nomap_get_existing_global_state(struct omap_drm_private *priv)\n{\n\treturn to_omap_global_state(priv->glob_obj.state);\n}\n\n \nstruct omap_global_state *__must_check\nomap_get_global_state(struct drm_atomic_state *s)\n{\n\tstruct omap_drm_private *priv = s->dev->dev_private;\n\tstruct drm_private_state *priv_state;\n\n\tpriv_state = drm_atomic_get_private_obj_state(s, &priv->glob_obj);\n\tif (IS_ERR(priv_state))\n\t\treturn ERR_CAST(priv_state);\n\n\treturn to_omap_global_state(priv_state);\n}\n\nstatic struct drm_private_state *\nomap_global_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct omap_global_state *state;\n\n\tstate = kmemdup(obj->state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void omap_global_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t      struct drm_private_state *state)\n{\n\tstruct omap_global_state *omap_state = to_omap_global_state(state);\n\n\tkfree(omap_state);\n}\n\nstatic const struct drm_private_state_funcs omap_global_state_funcs = {\n\t.atomic_duplicate_state = omap_global_duplicate_state,\n\t.atomic_destroy_state = omap_global_destroy_state,\n};\n\nstatic int omap_global_obj_init(struct drm_device *dev)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct omap_global_state *state;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_atomic_private_obj_init(dev, &priv->glob_obj, &state->base,\n\t\t\t\t    &omap_global_state_funcs);\n\treturn 0;\n}\n\nstatic void omap_global_obj_fini(struct omap_drm_private *priv)\n{\n\tdrm_atomic_private_obj_fini(&priv->glob_obj);\n}\n\nstatic void omap_disconnect_pipelines(struct drm_device *ddev)\n{\n\tstruct omap_drm_private *priv = ddev->dev_private;\n\tunsigned int i;\n\n\tfor (i = 0; i < priv->num_pipes; i++) {\n\t\tstruct omap_drm_pipeline *pipe = &priv->pipes[i];\n\n\t\tomapdss_device_disconnect(NULL, pipe->output);\n\n\t\tomapdss_device_put(pipe->output);\n\t\tpipe->output = NULL;\n\t}\n\n\tmemset(&priv->channels, 0, sizeof(priv->channels));\n\n\tpriv->num_pipes = 0;\n}\n\nstatic int omap_connect_pipelines(struct drm_device *ddev)\n{\n\tstruct omap_drm_private *priv = ddev->dev_private;\n\tstruct omap_dss_device *output = NULL;\n\tint r;\n\n\tfor_each_dss_output(output) {\n\t\tr = omapdss_device_connect(priv->dss, NULL, output);\n\t\tif (r == -EPROBE_DEFER) {\n\t\t\tomapdss_device_put(output);\n\t\t\treturn r;\n\t\t} else if (r) {\n\t\t\tdev_warn(output->dev, \"could not connect output %s\\n\",\n\t\t\t\t output->name);\n\t\t} else {\n\t\t\tstruct omap_drm_pipeline *pipe;\n\n\t\t\tpipe = &priv->pipes[priv->num_pipes++];\n\t\t\tpipe->output = omapdss_device_get(output);\n\n\t\t\tif (priv->num_pipes == ARRAY_SIZE(priv->pipes)) {\n\t\t\t\t \n\t\t\t\tomapdss_device_put(output);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_compare_pipelines(const void *a, const void *b)\n{\n\tconst struct omap_drm_pipeline *pipe1 = a;\n\tconst struct omap_drm_pipeline *pipe2 = b;\n\n\tif (pipe1->alias_id > pipe2->alias_id)\n\t\treturn 1;\n\telse if (pipe1->alias_id < pipe2->alias_id)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int omap_modeset_init_properties(struct drm_device *dev)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned int num_planes = dispc_get_num_ovls(priv->dispc);\n\n\tpriv->zorder_prop = drm_property_create_range(dev, 0, \"zorder\", 0,\n\t\t\t\t\t\t      num_planes - 1);\n\tif (!priv->zorder_prop)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int omap_display_id(struct omap_dss_device *output)\n{\n\tstruct device_node *node = NULL;\n\n\tif (output->bridge) {\n\t\tstruct drm_bridge *bridge = output->bridge;\n\n\t\twhile (drm_bridge_get_next_bridge(bridge))\n\t\t\tbridge = drm_bridge_get_next_bridge(bridge);\n\n\t\tnode = bridge->of_node;\n\t}\n\n\treturn node ? of_alias_get_id(node, \"display\") : -ENODEV;\n}\n\nstatic int omap_modeset_init(struct drm_device *dev)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tint num_ovls = dispc_get_num_ovls(priv->dispc);\n\tint num_mgrs = dispc_get_num_mgrs(priv->dispc);\n\tunsigned int i;\n\tint ret;\n\tu32 plane_crtc_mask;\n\n\tif (!omapdss_stack_is_ready())\n\t\treturn -EPROBE_DEFER;\n\n\tret = omap_modeset_init_properties(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = omap_connect_pipelines(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (priv->num_pipes > num_mgrs || priv->num_pipes > num_ovls) {\n\t\tdev_err(dev->dev, \"%s(): Too many connected displays\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tplane_crtc_mask = (1 << priv->num_pipes) - 1;\n\n\tfor (i = 0; i < num_ovls; i++) {\n\t\tenum drm_plane_type type = i < priv->num_pipes\n\t\t\t\t\t ? DRM_PLANE_TYPE_PRIMARY\n\t\t\t\t\t : DRM_PLANE_TYPE_OVERLAY;\n\t\tstruct drm_plane *plane;\n\n\t\tif (WARN_ON(priv->num_planes >= ARRAY_SIZE(priv->planes)))\n\t\t\treturn -EINVAL;\n\n\t\tplane = omap_plane_init(dev, i, type, plane_crtc_mask);\n\t\tif (IS_ERR(plane))\n\t\t\treturn PTR_ERR(plane);\n\n\t\tpriv->planes[priv->num_planes++] = plane;\n\t}\n\n\t \n\tfor (i = 0; i < priv->num_pipes; i++) {\n\t\tstruct omap_drm_pipeline *pipe = &priv->pipes[i];\n\t\tint id;\n\n\t\tpipe->encoder = omap_encoder_init(dev, pipe->output);\n\t\tif (!pipe->encoder)\n\t\t\treturn -ENOMEM;\n\n\t\tif (pipe->output->bridge) {\n\t\t\tret = drm_bridge_attach(pipe->encoder,\n\t\t\t\t\t\tpipe->output->bridge, NULL,\n\t\t\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tid = omap_display_id(pipe->output);\n\t\tpipe->alias_id = id >= 0 ? id : i;\n\t}\n\n\t \n\tsort(priv->pipes, priv->num_pipes, sizeof(priv->pipes[0]),\n\t     omap_compare_pipelines, NULL);\n\n\t \n\tfor (i = 0; i < priv->num_pipes; ++i) {\n\t\tstruct omap_drm_pipeline *pipe = &priv->pipes[i];\n\t\tenum omap_channel channel = pipe->output->dispc_channel;\n\n\t\tif (WARN_ON(priv->channels[channel] != NULL))\n\t\t\treturn -EINVAL;\n\n\t\tpriv->channels[channel] = pipe;\n\t}\n\n\t \n\tfor (i = 0; i < priv->num_pipes; i++) {\n\t\tstruct omap_drm_pipeline *pipe = &priv->pipes[i];\n\t\tstruct drm_encoder *encoder = pipe->encoder;\n\t\tstruct drm_crtc *crtc;\n\n\t\tpipe->connector = drm_bridge_connector_init(dev, encoder);\n\t\tif (IS_ERR(pipe->connector)) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"unable to create bridge connector for %s\\n\",\n\t\t\t\tpipe->output->name);\n\t\t\treturn PTR_ERR(pipe->connector);\n\t\t}\n\n\t\tdrm_connector_attach_encoder(pipe->connector, encoder);\n\n\t\tcrtc = omap_crtc_init(dev, pipe, priv->planes[i]);\n\t\tif (IS_ERR(crtc))\n\t\t\treturn PTR_ERR(crtc);\n\n\t\tencoder->possible_crtcs = 1 << i;\n\t\tpipe->crtc = crtc;\n\t}\n\n\tDBG(\"registered %u planes, %u crtcs/encoders/connectors\\n\",\n\t    priv->num_planes, priv->num_pipes);\n\n\tdev->mode_config.min_width = 8;\n\tdev->mode_config.min_height = 2;\n\n\t \n\tdev->mode_config.max_width = 8192;\n\tdev->mode_config.max_height = 8192;\n\n\t \n\tdev->mode_config.normalize_zpos = true;\n\n\tdev->mode_config.funcs = &omap_mode_config_funcs;\n\tdev->mode_config.helper_private = &omap_mode_config_helper_funcs;\n\n\tdrm_mode_config_reset(dev);\n\n\tomap_drm_irq_install(dev);\n\n\treturn 0;\n}\n\nstatic void omap_modeset_fini(struct drm_device *ddev)\n{\n\tomap_drm_irq_uninstall(ddev);\n\n\tdrm_mode_config_cleanup(ddev);\n}\n\n \n\n\nstatic int ioctl_get_param(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file_priv)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct drm_omap_param *args = data;\n\n\tDBG(\"%p: param=%llu\", dev, args->param);\n\n\tswitch (args->param) {\n\tcase OMAP_PARAM_CHIPSET_ID:\n\t\targs->value = priv->omaprev;\n\t\tbreak;\n\tdefault:\n\t\tDBG(\"unknown parameter %lld\", args->param);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define OMAP_BO_USER_MASK\t0x00ffffff\t \n\nstatic int ioctl_gem_new(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_omap_gem_new *args = data;\n\tu32 flags = args->flags & OMAP_BO_USER_MASK;\n\n\tVERB(\"%p:%p: size=0x%08x, flags=%08x\", dev, file_priv,\n\t     args->size.bytes, flags);\n\n\treturn omap_gem_new_handle(dev, file_priv, args->size, flags,\n\t\t\t\t   &args->handle);\n}\n\nstatic int ioctl_gem_info(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_omap_gem_info *args = data;\n\tstruct drm_gem_object *obj;\n\tint ret = 0;\n\n\tVERB(\"%p:%p: handle=%d\", dev, file_priv, args->handle);\n\n\tobj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!obj)\n\t\treturn -ENOENT;\n\n\targs->size = omap_gem_mmap_size(obj);\n\targs->offset = omap_gem_mmap_offset(obj);\n\n\tdrm_gem_object_put(obj);\n\n\treturn ret;\n}\n\nstatic const struct drm_ioctl_desc ioctls[DRM_COMMAND_END - DRM_COMMAND_BASE] = {\n\tDRM_IOCTL_DEF_DRV(OMAP_GET_PARAM, ioctl_get_param,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(OMAP_SET_PARAM, drm_invalid_op,\n\t\t\t  DRM_AUTH | DRM_MASTER | DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(OMAP_GEM_NEW, ioctl_gem_new,\n\t\t\t  DRM_RENDER_ALLOW),\n\t \n\tDRM_IOCTL_DEF_DRV(OMAP_GEM_CPU_PREP, drm_noop,\n\t\t\t  DRM_RENDER_ALLOW),\n\t \n\tDRM_IOCTL_DEF_DRV(OMAP_GEM_CPU_FINI, drm_noop,\n\t\t\t  DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(OMAP_GEM_INFO, ioctl_gem_info,\n\t\t\t  DRM_RENDER_ALLOW),\n};\n\n \n\nstatic int dev_open(struct drm_device *dev, struct drm_file *file)\n{\n\tfile->driver_priv = NULL;\n\n\tDBG(\"open: dev=%p, file=%p\", dev, file);\n\n\treturn 0;\n}\n\nDEFINE_DRM_GEM_FOPS(omapdriver_fops);\n\nstatic const struct drm_driver omap_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM  |\n\t\tDRIVER_ATOMIC | DRIVER_RENDER,\n\t.open = dev_open,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_init = omap_debugfs_init,\n#endif\n\t.gem_prime_import = omap_gem_prime_import,\n\t.dumb_create = omap_gem_dumb_create,\n\t.dumb_map_offset = omap_gem_dumb_map_offset,\n\t.ioctls = ioctls,\n\t.num_ioctls = DRM_OMAP_NUM_IOCTLS,\n\t.fops = &omapdriver_fops,\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nstatic const struct soc_device_attribute omapdrm_soc_devices[] = {\n\t{ .family = \"OMAP3\", .data = (void *)0x3430 },\n\t{ .family = \"OMAP4\", .data = (void *)0x4430 },\n\t{ .family = \"OMAP5\", .data = (void *)0x5430 },\n\t{ .family = \"DRA7\",  .data = (void *)0x0752 },\n\t{   }\n};\n\nstatic int omapdrm_init(struct omap_drm_private *priv, struct device *dev)\n{\n\tconst struct soc_device_attribute *soc;\n\tstruct dss_pdata *pdata = dev->platform_data;\n\tstruct drm_device *ddev;\n\tint ret;\n\n\tDBG(\"%s\", dev_name(dev));\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\t \n\tddev = drm_dev_alloc(&omap_drm_driver, dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tpriv->ddev = ddev;\n\tddev->dev_private = priv;\n\n\tpriv->dev = dev;\n\tpriv->dss = pdata->dss;\n\tpriv->dispc = dispc_get_dispc(priv->dss);\n\n\tpriv->dss->mgr_ops_priv = priv;\n\n\tsoc = soc_device_match(omapdrm_soc_devices);\n\tpriv->omaprev = soc ? (uintptr_t)soc->data : 0;\n\tpriv->wq = alloc_ordered_workqueue(\"omapdrm\", 0);\n\n\tmutex_init(&priv->list_lock);\n\tINIT_LIST_HEAD(&priv->obj_list);\n\n\t \n\tpriv->max_bandwidth = dispc_get_memory_bandwidth_limit(priv->dispc);\n\n\tomap_gem_init(ddev);\n\n\tdrm_mode_config_init(ddev);\n\n\tret = omap_global_obj_init(ddev);\n\tif (ret)\n\t\tgoto err_gem_deinit;\n\n\tret = omap_hwoverlays_init(priv);\n\tif (ret)\n\t\tgoto err_free_priv_obj;\n\n\tret = omap_modeset_init(ddev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"omap_modeset_init failed: ret=%d\\n\", ret);\n\t\tgoto err_free_overlays;\n\t}\n\n\t \n\tret = drm_vblank_init(ddev, priv->num_pipes);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"could not init vblank\\n\");\n\t\tgoto err_cleanup_modeset;\n\t}\n\n\tdrm_kms_helper_poll_init(ddev);\n\n\t \n\tret = drm_dev_register(ddev, 0);\n\tif (ret)\n\t\tgoto err_cleanup_helpers;\n\n\tomap_fbdev_setup(ddev);\n\n\treturn 0;\n\nerr_cleanup_helpers:\n\tdrm_kms_helper_poll_fini(ddev);\nerr_cleanup_modeset:\n\tomap_modeset_fini(ddev);\nerr_free_overlays:\n\tomap_hwoverlays_destroy(priv);\nerr_free_priv_obj:\n\tomap_global_obj_fini(priv);\nerr_gem_deinit:\n\tdrm_mode_config_cleanup(ddev);\n\tomap_gem_deinit(ddev);\n\tdestroy_workqueue(priv->wq);\n\tomap_disconnect_pipelines(ddev);\n\tdrm_dev_put(ddev);\n\treturn ret;\n}\n\nstatic void omapdrm_cleanup(struct omap_drm_private *priv)\n{\n\tstruct drm_device *ddev = priv->ddev;\n\n\tDBG(\"\");\n\n\tdrm_dev_unregister(ddev);\n\n\tdrm_kms_helper_poll_fini(ddev);\n\n\tdrm_atomic_helper_shutdown(ddev);\n\n\tomap_modeset_fini(ddev);\n\tomap_hwoverlays_destroy(priv);\n\tomap_global_obj_fini(priv);\n\tdrm_mode_config_cleanup(ddev);\n\tomap_gem_deinit(ddev);\n\n\tdestroy_workqueue(priv->wq);\n\n\tomap_disconnect_pipelines(ddev);\n\n\tdrm_dev_put(ddev);\n}\n\nstatic int pdev_probe(struct platform_device *pdev)\n{\n\tstruct omap_drm_private *priv;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to set the DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = omapdrm_init(priv, &pdev->dev);\n\tif (ret < 0)\n\t\tkfree(priv);\n\n\treturn ret;\n}\n\nstatic void pdev_remove(struct platform_device *pdev)\n{\n\tstruct omap_drm_private *priv = platform_get_drvdata(pdev);\n\n\tomapdrm_cleanup(priv);\n\tkfree(priv);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int omap_drm_suspend(struct device *dev)\n{\n\tstruct omap_drm_private *priv = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = priv->ddev;\n\n\treturn drm_mode_config_helper_suspend(drm_dev);\n}\n\nstatic int omap_drm_resume(struct device *dev)\n{\n\tstruct omap_drm_private *priv = dev_get_drvdata(dev);\n\tstruct drm_device *drm_dev = priv->ddev;\n\n\tdrm_mode_config_helper_resume(drm_dev);\n\n\treturn omap_gem_resume(drm_dev);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(omapdrm_pm_ops, omap_drm_suspend, omap_drm_resume);\n\nstatic struct platform_driver pdev = {\n\t.driver = {\n\t\t.name = \"omapdrm\",\n\t\t.pm = &omapdrm_pm_ops,\n\t},\n\t.probe = pdev_probe,\n\t.remove_new = pdev_remove,\n};\n\nstatic struct platform_driver * const drivers[] = {\n\t&omap_dmm_driver,\n\t&pdev,\n};\n\nstatic int __init omap_drm_init(void)\n{\n\tint r;\n\n\tDBG(\"init\");\n\n\tr = omap_dss_init();\n\tif (r)\n\t\treturn r;\n\n\tr = platform_register_drivers(drivers, ARRAY_SIZE(drivers));\n\tif (r) {\n\t\tomap_dss_exit();\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit omap_drm_fini(void)\n{\n\tDBG(\"fini\");\n\n\tplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\n\n\tomap_dss_exit();\n}\n\nmodule_init(omap_drm_init);\nmodule_exit(omap_drm_fini);\n\nMODULE_AUTHOR(\"Rob Clark <rob@ti.com>\");\nMODULE_AUTHOR(\"Tomi Valkeinen <tomi.valkeinen@ti.com>\");\nMODULE_DESCRIPTION(\"OMAP DRM Display Driver\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}