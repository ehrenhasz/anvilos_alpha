{
  "module_name": "omap_gem_dmabuf.c",
  "hash_id": "6725fed1bf7b6249bf86b0a87b3cffbf145a4ee5d4c45b424936c03b0c3e5bfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_gem_dmabuf.c",
  "human_readable_source": "\n \n\n#include <linux/dma-buf.h>\n#include <linux/highmem.h>\n\n#include <drm/drm_prime.h>\n\n#include \"omap_drv.h\"\n\nMODULE_IMPORT_NS(DMA_BUF);\n\n \n\nstatic struct sg_table *omap_gem_map_dma_buf(\n\t\tstruct dma_buf_attachment *attachment,\n\t\tenum dma_data_direction dir)\n{\n\tstruct drm_gem_object *obj = attachment->dmabuf->priv;\n\tstruct sg_table *sg;\n\tsg = omap_gem_get_sg(obj, dir);\n\tif (IS_ERR(sg))\n\t\treturn sg;\n\n\treturn sg;\n}\n\nstatic void omap_gem_unmap_dma_buf(struct dma_buf_attachment *attachment,\n\t\tstruct sg_table *sg, enum dma_data_direction dir)\n{\n\tstruct drm_gem_object *obj = attachment->dmabuf->priv;\n\tomap_gem_put_sg(obj, sg);\n}\n\nstatic int omap_gem_dmabuf_begin_cpu_access(struct dma_buf *buffer,\n\t\tenum dma_data_direction dir)\n{\n\tstruct drm_gem_object *obj = buffer->priv;\n\tstruct page **pages;\n\tif (omap_gem_flags(obj) & OMAP_BO_TILED_MASK) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\t \n\treturn omap_gem_get_pages(obj, &pages, true);\n}\n\nstatic int omap_gem_dmabuf_end_cpu_access(struct dma_buf *buffer,\n\t\t\t\t\t  enum dma_data_direction dir)\n{\n\tstruct drm_gem_object *obj = buffer->priv;\n\tomap_gem_put_pages(obj);\n\treturn 0;\n}\n\nstatic int omap_gem_dmabuf_mmap(struct dma_buf *buffer,\n\t\tstruct vm_area_struct *vma)\n{\n\tstruct drm_gem_object *obj = buffer->priv;\n\n\treturn drm_gem_mmap_obj(obj, omap_gem_mmap_size(obj), vma);\n}\n\nstatic const struct dma_buf_ops omap_dmabuf_ops = {\n\t.map_dma_buf = omap_gem_map_dma_buf,\n\t.unmap_dma_buf = omap_gem_unmap_dma_buf,\n\t.release = drm_gem_dmabuf_release,\n\t.begin_cpu_access = omap_gem_dmabuf_begin_cpu_access,\n\t.end_cpu_access = omap_gem_dmabuf_end_cpu_access,\n\t.mmap = omap_gem_dmabuf_mmap,\n};\n\nstruct dma_buf *omap_gem_prime_export(struct drm_gem_object *obj, int flags)\n{\n\tDEFINE_DMA_BUF_EXPORT_INFO(exp_info);\n\n\texp_info.ops = &omap_dmabuf_ops;\n\texp_info.size = omap_gem_mmap_size(obj);\n\texp_info.flags = flags;\n\texp_info.priv = obj;\n\texp_info.resv = obj->resv;\n\n\treturn drm_gem_dmabuf_export(obj->dev, &exp_info);\n}\n\n \n\nstruct drm_gem_object *omap_gem_prime_import(struct drm_device *dev,\n\t\t\t\t\t     struct dma_buf *dma_buf)\n{\n\tstruct dma_buf_attachment *attach;\n\tstruct drm_gem_object *obj;\n\tstruct sg_table *sgt;\n\tint ret;\n\n\tif (dma_buf->ops == &omap_dmabuf_ops) {\n\t\tobj = dma_buf->priv;\n\t\tif (obj->dev == dev) {\n\t\t\t \n\t\t\tdrm_gem_object_get(obj);\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\tattach = dma_buf_attach(dma_buf, dev->dev);\n\tif (IS_ERR(attach))\n\t\treturn ERR_CAST(attach);\n\n\tget_dma_buf(dma_buf);\n\n\tsgt = dma_buf_map_attachment_unlocked(attach, DMA_TO_DEVICE);\n\tif (IS_ERR(sgt)) {\n\t\tret = PTR_ERR(sgt);\n\t\tgoto fail_detach;\n\t}\n\n\tobj = omap_gem_new_dmabuf(dev, dma_buf->size, sgt);\n\tif (IS_ERR(obj)) {\n\t\tret = PTR_ERR(obj);\n\t\tgoto fail_unmap;\n\t}\n\n\tobj->import_attach = attach;\n\n\treturn obj;\n\nfail_unmap:\n\tdma_buf_unmap_attachment_unlocked(attach, sgt, DMA_TO_DEVICE);\nfail_detach:\n\tdma_buf_detach(dma_buf, attach);\n\tdma_buf_put(dma_buf);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}