{
  "module_name": "omap_crtc.c",
  "hash_id": "3dcda063db857298bda9d1243e676cf8c16c3d3eb24789046c1fee7bdf2ffe70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/math64.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_mode.h>\n#include <drm/drm_vblank.h>\n\n#include \"omap_drv.h\"\n\n#define to_omap_crtc_state(x) container_of(x, struct omap_crtc_state, base)\n\nstruct omap_crtc_state {\n\t \n\tstruct drm_crtc_state base;\n\t \n\tunsigned int rotation;\n\tunsigned int zpos;\n\tbool manually_updated;\n};\n\n#define to_omap_crtc(x) container_of(x, struct omap_crtc, base)\n\nstruct omap_crtc {\n\tstruct drm_crtc base;\n\n\tconst char *name;\n\tstruct omap_drm_pipeline *pipe;\n\tenum omap_channel channel;\n\n\tstruct videomode vm;\n\n\tbool ignore_digit_sync_lost;\n\n\tbool enabled;\n\tbool pending;\n\twait_queue_head_t pending_wait;\n\tstruct drm_pending_vblank_event *event;\n\tstruct delayed_work update_work;\n\n\tvoid (*framedone_handler)(void *);\n\tvoid *framedone_handler_data;\n};\n\n \n\nstruct videomode *omap_crtc_timings(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\treturn &omap_crtc->vm;\n}\n\nenum omap_channel omap_crtc_channel(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\treturn omap_crtc->channel;\n}\n\nstatic bool omap_crtc_is_pending(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tunsigned long flags;\n\tbool pending;\n\n\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\tpending = omap_crtc->pending;\n\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\n\treturn pending;\n}\n\nint omap_crtc_wait_pending(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\t \n\treturn wait_event_timeout(omap_crtc->pending_wait,\n\t\t\t\t  !omap_crtc_is_pending(crtc),\n\t\t\t\t  msecs_to_jiffies(250));\n}\n\n \n\n \n\nvoid omap_crtc_dss_start_update(struct omap_drm_private *priv,\n\t\t\t\t       enum omap_channel channel)\n{\n\tdispc_mgr_enable(priv->dispc, channel, true);\n}\n\n \nvoid omap_crtc_set_enabled(struct drm_crtc *crtc, bool enable)\n{\n\tstruct omap_crtc_state *omap_state = to_omap_crtc_state(crtc->state);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tenum omap_channel channel = omap_crtc->channel;\n\tstruct omap_irq_wait *wait;\n\tu32 framedone_irq, vsync_irq;\n\tint ret;\n\n\tif (WARN_ON(omap_crtc->enabled == enable))\n\t\treturn;\n\n\tif (omap_state->manually_updated) {\n\t\tomap_irq_enable_framedone(crtc, enable);\n\t\tomap_crtc->enabled = enable;\n\t\treturn;\n\t}\n\n\tif (omap_crtc->pipe->output->type == OMAP_DISPLAY_TYPE_HDMI) {\n\t\tdispc_mgr_enable(priv->dispc, channel, enable);\n\t\tomap_crtc->enabled = enable;\n\t\treturn;\n\t}\n\n\tif (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {\n\t\t \n\t\tomap_crtc->ignore_digit_sync_lost = true;\n\t}\n\n\tframedone_irq = dispc_mgr_get_framedone_irq(priv->dispc,\n\t\t\t\t\t\t\t       channel);\n\tvsync_irq = dispc_mgr_get_vsync_irq(priv->dispc, channel);\n\n\tif (enable) {\n\t\twait = omap_irq_wait_init(dev, vsync_irq, 1);\n\t} else {\n\t\t \n\n\t\tif (framedone_irq)\n\t\t\twait = omap_irq_wait_init(dev, framedone_irq, 1);\n\t\telse\n\t\t\twait = omap_irq_wait_init(dev, vsync_irq, 2);\n\t}\n\n\tdispc_mgr_enable(priv->dispc, channel, enable);\n\tomap_crtc->enabled = enable;\n\n\tret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));\n\tif (ret) {\n\t\tdev_err(dev->dev, \"%s: timeout waiting for %s\\n\",\n\t\t\t\tomap_crtc->name, enable ? \"enable\" : \"disable\");\n\t}\n\n\tif (omap_crtc->channel == OMAP_DSS_CHANNEL_DIGIT) {\n\t\tomap_crtc->ignore_digit_sync_lost = false;\n\t\t \n\t\tmb();\n\t}\n}\n\n\nint omap_crtc_dss_enable(struct omap_drm_private *priv, enum omap_channel channel)\n{\n\tstruct drm_crtc *crtc = priv->channels[channel]->crtc;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tdispc_mgr_set_timings(priv->dispc, omap_crtc->channel,\n\t\t\t\t\t &omap_crtc->vm);\n\tomap_crtc_set_enabled(&omap_crtc->base, true);\n\n\treturn 0;\n}\n\nvoid omap_crtc_dss_disable(struct omap_drm_private *priv, enum omap_channel channel)\n{\n\tstruct drm_crtc *crtc = priv->channels[channel]->crtc;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tomap_crtc_set_enabled(&omap_crtc->base, false);\n}\n\nvoid omap_crtc_dss_set_timings(struct omap_drm_private *priv,\n\t\tenum omap_channel channel,\n\t\tconst struct videomode *vm)\n{\n\tstruct drm_crtc *crtc = priv->channels[channel]->crtc;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tDBG(\"%s\", omap_crtc->name);\n\tomap_crtc->vm = *vm;\n}\n\nvoid omap_crtc_dss_set_lcd_config(struct omap_drm_private *priv,\n\t\tenum omap_channel channel,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tstruct drm_crtc *crtc = priv->channels[channel]->crtc;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tDBG(\"%s\", omap_crtc->name);\n\tdispc_mgr_set_lcd_config(priv->dispc, omap_crtc->channel,\n\t\t\t\t\t    config);\n}\n\nint omap_crtc_dss_register_framedone(\n\t\tstruct omap_drm_private *priv, enum omap_channel channel,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tstruct drm_crtc *crtc = priv->channels[channel]->crtc;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct drm_device *dev = omap_crtc->base.dev;\n\n\tif (omap_crtc->framedone_handler)\n\t\treturn -EBUSY;\n\n\tdev_dbg(dev->dev, \"register framedone %s\", omap_crtc->name);\n\n\tomap_crtc->framedone_handler = handler;\n\tomap_crtc->framedone_handler_data = data;\n\n\treturn 0;\n}\n\nvoid omap_crtc_dss_unregister_framedone(\n\t\tstruct omap_drm_private *priv, enum omap_channel channel,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tstruct drm_crtc *crtc = priv->channels[channel]->crtc;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct drm_device *dev = omap_crtc->base.dev;\n\n\tdev_dbg(dev->dev, \"unregister framedone %s\", omap_crtc->name);\n\n\tWARN_ON(omap_crtc->framedone_handler != handler);\n\tWARN_ON(omap_crtc->framedone_handler_data != data);\n\n\tomap_crtc->framedone_handler = NULL;\n\tomap_crtc->framedone_handler_data = NULL;\n}\n\n \n\nvoid omap_crtc_error_irq(struct drm_crtc *crtc, u32 irqstatus)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tif (omap_crtc->ignore_digit_sync_lost) {\n\t\tirqstatus &= ~DISPC_IRQ_SYNC_LOST_DIGIT;\n\t\tif (!irqstatus)\n\t\t\treturn;\n\t}\n\n\tDRM_ERROR_RATELIMITED(\"%s: errors: %08x\\n\", omap_crtc->name, irqstatus);\n}\n\nvoid omap_crtc_vblank_irq(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct drm_device *dev = omap_crtc->base.dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tbool pending;\n\n\tspin_lock(&crtc->dev->event_lock);\n\t \n\tif (dispc_mgr_go_busy(priv->dispc, omap_crtc->channel)) {\n\t\tspin_unlock(&crtc->dev->event_lock);\n\t\treturn;\n\t}\n\n\t \n\tif (omap_crtc->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, omap_crtc->event);\n\t\tomap_crtc->event = NULL;\n\t}\n\n\tpending = omap_crtc->pending;\n\tomap_crtc->pending = false;\n\tspin_unlock(&crtc->dev->event_lock);\n\n\tif (pending)\n\t\tdrm_crtc_vblank_put(crtc);\n\n\t \n\twake_up(&omap_crtc->pending_wait);\n\n\tDBG(\"%s: apply done\", omap_crtc->name);\n}\n\nvoid omap_crtc_framedone_irq(struct drm_crtc *crtc, uint32_t irqstatus)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tif (!omap_crtc->framedone_handler)\n\t\treturn;\n\n\tomap_crtc->framedone_handler(omap_crtc->framedone_handler_data);\n\n\tspin_lock(&crtc->dev->event_lock);\n\t \n\tif (omap_crtc->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, omap_crtc->event);\n\t\tomap_crtc->event = NULL;\n\t}\n\tomap_crtc->pending = false;\n\tspin_unlock(&crtc->dev->event_lock);\n\n\t \n\twake_up(&omap_crtc->pending_wait);\n}\n\nvoid omap_crtc_flush(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct omap_crtc_state *omap_state = to_omap_crtc_state(crtc->state);\n\n\tif (!omap_state->manually_updated)\n\t\treturn;\n\n\tif (!delayed_work_pending(&omap_crtc->update_work))\n\t\tschedule_delayed_work(&omap_crtc->update_work, 0);\n}\n\nstatic void omap_crtc_manual_display_update(struct work_struct *data)\n{\n\tstruct omap_crtc *omap_crtc =\n\t\t\tcontainer_of(data, struct omap_crtc, update_work.work);\n\tstruct omap_dss_device *dssdev = omap_crtc->pipe->output;\n\tstruct drm_device *dev = omap_crtc->base.dev;\n\tint ret;\n\n\tif (!dssdev || !dssdev->dsi_ops || !dssdev->dsi_ops->update)\n\t\treturn;\n\n\tret = dssdev->dsi_ops->update(dssdev);\n\tif (ret < 0) {\n\t\tspin_lock_irq(&dev->event_lock);\n\t\tomap_crtc->pending = false;\n\t\tspin_unlock_irq(&dev->event_lock);\n\t\twake_up(&omap_crtc->pending_wait);\n\t}\n}\n\nstatic s16 omap_crtc_s31_32_to_s2_8(s64 coef)\n{\n\tu64 sign_bit = 1ULL << 63;\n\tu64 cbits = (u64)coef;\n\n\ts16 ret = clamp_val(((cbits & ~sign_bit) >> 24), 0, 0x1ff);\n\n\tif (cbits & sign_bit)\n\t\tret = -ret;\n\n\treturn ret;\n}\n\nstatic void omap_crtc_cpr_coefs_from_ctm(const struct drm_color_ctm *ctm,\n\t\t\t\t\t struct omap_dss_cpr_coefs *cpr)\n{\n\tcpr->rr = omap_crtc_s31_32_to_s2_8(ctm->matrix[0]);\n\tcpr->rg = omap_crtc_s31_32_to_s2_8(ctm->matrix[1]);\n\tcpr->rb = omap_crtc_s31_32_to_s2_8(ctm->matrix[2]);\n\tcpr->gr = omap_crtc_s31_32_to_s2_8(ctm->matrix[3]);\n\tcpr->gg = omap_crtc_s31_32_to_s2_8(ctm->matrix[4]);\n\tcpr->gb = omap_crtc_s31_32_to_s2_8(ctm->matrix[5]);\n\tcpr->br = omap_crtc_s31_32_to_s2_8(ctm->matrix[6]);\n\tcpr->bg = omap_crtc_s31_32_to_s2_8(ctm->matrix[7]);\n\tcpr->bb = omap_crtc_s31_32_to_s2_8(ctm->matrix[8]);\n}\n\nstatic void omap_crtc_write_crtc_properties(struct drm_crtc *crtc)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct omap_overlay_manager_info info;\n\n\tmemset(&info, 0, sizeof(info));\n\n\tinfo.default_color = 0x000000;\n\tinfo.trans_enabled = false;\n\tinfo.partial_alpha_enabled = false;\n\n\tif (crtc->state->ctm) {\n\t\tstruct drm_color_ctm *ctm = crtc->state->ctm->data;\n\n\t\tinfo.cpr_enable = true;\n\t\tomap_crtc_cpr_coefs_from_ctm(ctm, &info.cpr_coefs);\n\t} else {\n\t\tinfo.cpr_enable = false;\n\t}\n\n\tdispc_mgr_setup(priv->dispc, omap_crtc->channel, &info);\n}\n\n \n\nstatic void omap_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tDBG(\"%s\", omap_crtc->name);\n\n\tdrm_crtc_cleanup(crtc);\n\n\tkfree(omap_crtc);\n}\n\nstatic void omap_crtc_arm_event(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\n\tWARN_ON(omap_crtc->pending);\n\tomap_crtc->pending = true;\n\n\tif (crtc->state->event) {\n\t\tomap_crtc->event = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\t}\n}\n\nstatic void omap_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct omap_crtc_state *omap_state = to_omap_crtc_state(crtc->state);\n\tint ret;\n\n\tDBG(\"%s\", omap_crtc->name);\n\n\tdispc_runtime_get(priv->dispc);\n\n\t \n\tif (omap_state->manually_updated)\n\t\treturn;\n\n\tdrm_crtc_vblank_on(crtc);\n\n\tret = drm_crtc_vblank_get(crtc);\n\tWARN_ON(ret != 0);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tomap_crtc_arm_event(crtc);\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic void omap_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\n\tDBG(\"%s\", omap_crtc->name);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\tcancel_delayed_work(&omap_crtc->update_work);\n\n\tif (!omap_crtc_wait_pending(crtc))\n\t\tdev_warn(dev->dev, \"manual display update did not finish!\");\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tdispc_runtime_put(priv->dispc);\n}\n\nstatic enum drm_mode_status omap_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\tconst struct drm_display_mode *mode)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct videomode vm = {0};\n\tint r;\n\n\tdrm_display_mode_to_videomode(mode, &vm);\n\n\t \n\tif (omap_crtc->pipe->output->type != OMAP_DISPLAY_TYPE_DSI) {\n\t\tr = dispc_mgr_check_timings(priv->dispc,\n\t\t\t\t\t\t       omap_crtc->channel,\n\t\t\t\t\t\t       &vm);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tif (priv->max_bandwidth) {\n\t\t \n\t\tuint64_t bandwidth = mode->clock * 1000;\n\t\tunsigned int bpp = 4;\n\n\t\tbandwidth = bandwidth * mode->hdisplay * mode->vdisplay * bpp;\n\t\tbandwidth = div_u64(bandwidth, mode->htotal * mode->vtotal);\n\n\t\t \n\t\tif (priv->max_bandwidth < bandwidth)\n\t\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic void omap_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct drm_display_mode *mode = &crtc->state->adjusted_mode;\n\n\tDBG(\"%s: set mode: \" DRM_MODE_FMT,\n\t    omap_crtc->name, DRM_MODE_ARG(mode));\n\n\tdrm_display_mode_to_videomode(mode, &omap_crtc->vm);\n}\n\nstatic bool omap_crtc_is_manually_updated(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct omap_dss_device *dssdev = omap_crtc->pipe->output;\n\n\tif (!dssdev || !dssdev->dsi_ops || !dssdev->dsi_ops->is_video_mode)\n\t\treturn false;\n\n\tif (dssdev->dsi_ops->is_video_mode(dssdev))\n\t\treturn false;\n\n\tDBG(\"detected manually updated display!\");\n\treturn true;\n}\n\nstatic int omap_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct drm_plane_state *pri_state;\n\n\tif (crtc_state->color_mgmt_changed && crtc_state->degamma_lut) {\n\t\tunsigned int length = crtc_state->degamma_lut->length /\n\t\t\tsizeof(struct drm_color_lut);\n\n\t\tif (length < 2)\n\t\t\treturn -EINVAL;\n\t}\n\n\tpri_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t   crtc->primary);\n\tif (pri_state) {\n\t\tstruct omap_crtc_state *omap_crtc_state =\n\t\t\tto_omap_crtc_state(crtc_state);\n\n\t\t \n\t\tomap_crtc_state->zpos = pri_state->zpos;\n\t\tomap_crtc_state->rotation = pri_state->rotation;\n\n\t\t \n\t\tomap_crtc_state->manually_updated = omap_crtc_is_manually_updated(crtc);\n\t}\n\n\treturn 0;\n}\n\nstatic void omap_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n}\n\nstatic void omap_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\n\tstruct omap_crtc_state *omap_crtc_state = to_omap_crtc_state(crtc->state);\n\tint ret;\n\n\tif (crtc->state->color_mgmt_changed) {\n\t\tstruct drm_color_lut *lut = NULL;\n\t\tunsigned int length = 0;\n\n\t\tif (crtc->state->degamma_lut) {\n\t\t\tlut = (struct drm_color_lut *)\n\t\t\t\tcrtc->state->degamma_lut->data;\n\t\t\tlength = crtc->state->degamma_lut->length /\n\t\t\t\tsizeof(*lut);\n\t\t}\n\t\tdispc_mgr_set_gamma(priv->dispc, omap_crtc->channel,\n\t\t\t\t\t       lut, length);\n\t}\n\n\tomap_crtc_write_crtc_properties(crtc);\n\n\t \n\tif (!omap_crtc->enabled)\n\t\treturn;\n\n\tDBG(\"%s: GO\", omap_crtc->name);\n\n\tif (omap_crtc_state->manually_updated) {\n\t\t \n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tomap_crtc_flush(crtc);\n\t\tomap_crtc_arm_event(crtc);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t\treturn;\n\t}\n\n\tret = drm_crtc_vblank_get(crtc);\n\tWARN_ON(ret != 0);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tdispc_mgr_go(priv->dispc, omap_crtc->channel);\n\tomap_crtc_arm_event(crtc);\n\tspin_unlock_irq(&crtc->dev->event_lock);\n}\n\nstatic int omap_crtc_atomic_set_property(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_crtc_state *state,\n\t\t\t\t\t struct drm_property *property,\n\t\t\t\t\t u64 val)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct drm_plane_state *plane_state;\n\n\t \n\tplane_state = drm_atomic_get_plane_state(state->state, crtc->primary);\n\tif (IS_ERR(plane_state))\n\t\treturn PTR_ERR(plane_state);\n\n\tif (property == crtc->primary->rotation_property)\n\t\tplane_state->rotation = val;\n\telse if (property == priv->zorder_prop)\n\t\tplane_state->zpos = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int omap_crtc_atomic_get_property(struct drm_crtc *crtc,\n\t\t\t\t\t const struct drm_crtc_state *state,\n\t\t\t\t\t struct drm_property *property,\n\t\t\t\t\t u64 *val)\n{\n\tstruct omap_drm_private *priv = crtc->dev->dev_private;\n\tstruct omap_crtc_state *omap_state = to_omap_crtc_state(state);\n\n\tif (property == crtc->primary->rotation_property)\n\t\t*val = omap_state->rotation;\n\telse if (property == priv->zorder_prop)\n\t\t*val = omap_state->zpos;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void omap_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc_state *state;\n\n\tif (crtc->state)\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\n\tkfree(crtc->state);\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *\nomap_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct omap_crtc_state *state, *current_state;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tcurrent_state = to_omap_crtc_state(crtc->state);\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\n\tstate->zpos = current_state->zpos;\n\tstate->rotation = current_state->rotation;\n\tstate->manually_updated = current_state->manually_updated;\n\n\treturn &state->base;\n}\n\nstatic const struct drm_crtc_funcs omap_crtc_funcs = {\n\t.reset = omap_crtc_reset,\n\t.set_config = drm_atomic_helper_set_config,\n\t.destroy = omap_crtc_destroy,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = omap_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.atomic_set_property = omap_crtc_atomic_set_property,\n\t.atomic_get_property = omap_crtc_atomic_get_property,\n\t.enable_vblank = omap_irq_enable_vblank,\n\t.disable_vblank = omap_irq_disable_vblank,\n};\n\nstatic const struct drm_crtc_helper_funcs omap_crtc_helper_funcs = {\n\t.mode_set_nofb = omap_crtc_mode_set_nofb,\n\t.atomic_check = omap_crtc_atomic_check,\n\t.atomic_begin = omap_crtc_atomic_begin,\n\t.atomic_flush = omap_crtc_atomic_flush,\n\t.atomic_enable = omap_crtc_atomic_enable,\n\t.atomic_disable = omap_crtc_atomic_disable,\n\t.mode_valid = omap_crtc_mode_valid,\n};\n\n \n\nstatic const char *channel_names[] = {\n\t[OMAP_DSS_CHANNEL_LCD] = \"lcd\",\n\t[OMAP_DSS_CHANNEL_DIGIT] = \"tv\",\n\t[OMAP_DSS_CHANNEL_LCD2] = \"lcd2\",\n\t[OMAP_DSS_CHANNEL_LCD3] = \"lcd3\",\n};\n\n \nstruct drm_crtc *omap_crtc_init(struct drm_device *dev,\n\t\t\t\tstruct omap_drm_pipeline *pipe,\n\t\t\t\tstruct drm_plane *plane)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct drm_crtc *crtc = NULL;\n\tstruct omap_crtc *omap_crtc;\n\tenum omap_channel channel;\n\tint ret;\n\n\tchannel = pipe->output->dispc_channel;\n\n\tDBG(\"%s\", channel_names[channel]);\n\n\tomap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);\n\tif (!omap_crtc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcrtc = &omap_crtc->base;\n\n\tinit_waitqueue_head(&omap_crtc->pending_wait);\n\n\tomap_crtc->pipe = pipe;\n\tomap_crtc->channel = channel;\n\tomap_crtc->name = channel_names[channel];\n\n\t \n\tINIT_DELAYED_WORK(&omap_crtc->update_work,\n\t\t\t  omap_crtc_manual_display_update);\n\n\tret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,\n\t\t\t\t\t&omap_crtc_funcs, NULL);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"%s(): could not init crtc for: %s\\n\",\n\t\t\t__func__, pipe->output->name);\n\t\tkfree(omap_crtc);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);\n\n\t \n\tif (dispc_mgr_gamma_size(priv->dispc, channel)) {\n\t\tunsigned int gamma_lut_size = 256;\n\n\t\tdrm_crtc_enable_color_mgmt(crtc, gamma_lut_size, true, 0);\n\t\tdrm_mode_crtc_set_gamma_size(crtc, gamma_lut_size);\n\t}\n\n\tomap_plane_install_properties(crtc->primary, &crtc->base);\n\n\treturn crtc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}