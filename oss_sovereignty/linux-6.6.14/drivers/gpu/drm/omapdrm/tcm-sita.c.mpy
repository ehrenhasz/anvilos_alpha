{
  "module_name": "tcm-sita.c",
  "hash_id": "c58ace0df3e4748e56005f9cbbe25e46085fa0b7ebdb18245393d11a0e30b17f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/tcm-sita.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include \"tcm.h\"\n\nstatic unsigned long mask[8];\n \nstatic void free_slots(unsigned long pos, u16 w, u16 h,\n\t\tunsigned long *map, u16 stride)\n{\n\tint i;\n\n\tfor (i = 0; i < h; i++, pos += stride)\n\t\tbitmap_clear(map, pos, w);\n}\n\n \nstatic int r2l_b2t_1d(u16 w, unsigned long *pos, unsigned long *map,\n\t\tsize_t num_bits)\n{\n\tunsigned long search_count = 0;\n\tunsigned long bit;\n\tbool area_found = false;\n\n\t*pos = num_bits - w;\n\n\twhile (search_count < num_bits) {\n\t\tbit = find_next_bit(map, num_bits, *pos);\n\n\t\tif (bit - *pos >= w) {\n\t\t\t \n\t\t\tbitmap_set(map, *pos, w);\n\t\t\tarea_found = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tsearch_count = num_bits - bit + w;\n\t\t*pos = bit - w;\n\t}\n\n\treturn (area_found) ? 0 : -ENOMEM;\n}\n\n \nstatic int l2r_t2b(u16 w, u16 h, u16 a, s16 offset,\n\t\tunsigned long *pos, unsigned long slot_bytes,\n\t\tunsigned long *map, size_t num_bits, size_t slot_stride)\n{\n\tint i;\n\tunsigned long index;\n\tbool area_free = false;\n\tunsigned long slots_per_band = PAGE_SIZE / slot_bytes;\n\tunsigned long bit_offset = (offset > 0) ? offset / slot_bytes : 0;\n\tunsigned long curr_bit = bit_offset;\n\n\t \n\t \n\ta = (offset > 0) ? 0 : a - 1;\n\n\t \n\n\twhile (curr_bit < num_bits) {\n\t\t*pos = bitmap_find_next_zero_area(map, num_bits, curr_bit, w,\n\t\t\t\ta);\n\n\t\t \n\t\tif (bit_offset > 0 && (*pos % slots_per_band != bit_offset)) {\n\t\t\tcurr_bit = ALIGN(*pos, slots_per_band) + bit_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((*pos % slot_stride) + w > slot_stride) {\n\t\t\tcurr_bit = ALIGN(*pos, slot_stride) + bit_offset;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif ((*pos + slot_stride * h) > num_bits)\n\t\t\tbreak;\n\n\t\t \n\t\tbitmap_clear(mask, 0, slot_stride);\n\t\tbitmap_set(mask, (*pos % BITS_PER_LONG), w);\n\n\t\t \n\t\tarea_free = true;\n\n\t\t \n\t\tfor (i = 1; i < h; i++) {\n\t\t\tindex = *pos / BITS_PER_LONG + i * 8;\n\t\t\tif (bitmap_intersects(&map[index], mask,\n\t\t\t\t(*pos % BITS_PER_LONG) + w)) {\n\t\t\t\tarea_free = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (area_free)\n\t\t\tbreak;\n\n\t\t \n\t\tif (bit_offset > 0)\n\t\t\tcurr_bit = ALIGN(*pos, slots_per_band) + bit_offset;\n\t\telse\n\t\t\tcurr_bit = *pos + a + 1;\n\t}\n\n\tif (area_free) {\n\t\t \n\t\tfor (i = 0, index = *pos; i < h; i++, index += slot_stride)\n\t\t\tbitmap_set(map, index, w);\n\t}\n\n\treturn (area_free) ? 0 : -ENOMEM;\n}\n\nstatic s32 sita_reserve_1d(struct tcm *tcm, u32 num_slots,\n\t\t\t   struct tcm_area *area)\n{\n\tunsigned long pos;\n\tint ret;\n\n\tspin_lock(&(tcm->lock));\n\tret = r2l_b2t_1d(num_slots, &pos, tcm->bitmap, tcm->map_size);\n\tif (!ret) {\n\t\tarea->p0.x = pos % tcm->width;\n\t\tarea->p0.y = pos / tcm->width;\n\t\tarea->p1.x = (pos + num_slots - 1) % tcm->width;\n\t\tarea->p1.y = (pos + num_slots - 1) / tcm->width;\n\t}\n\tspin_unlock(&(tcm->lock));\n\n\treturn ret;\n}\n\nstatic s32 sita_reserve_2d(struct tcm *tcm, u16 h, u16 w, u16 align,\n\t\t\t\ts16 offset, u16 slot_bytes,\n\t\t\t\tstruct tcm_area *area)\n{\n\tunsigned long pos;\n\tint ret;\n\n\tspin_lock(&(tcm->lock));\n\tret = l2r_t2b(w, h, align, offset, &pos, slot_bytes, tcm->bitmap,\n\t\t\ttcm->map_size, tcm->width);\n\n\tif (!ret) {\n\t\tarea->p0.x = pos % tcm->width;\n\t\tarea->p0.y = pos / tcm->width;\n\t\tarea->p1.x = area->p0.x + w - 1;\n\t\tarea->p1.y = area->p0.y + h - 1;\n\t}\n\tspin_unlock(&(tcm->lock));\n\n\treturn ret;\n}\n\nstatic void sita_deinit(struct tcm *tcm)\n{\n\tkfree(tcm);\n}\n\nstatic s32 sita_free(struct tcm *tcm, struct tcm_area *area)\n{\n\tunsigned long pos;\n\tu16 w, h;\n\n\tpos = area->p0.x + area->p0.y * tcm->width;\n\tif (area->is2d) {\n\t\tw = area->p1.x - area->p0.x + 1;\n\t\th = area->p1.y - area->p0.y + 1;\n\t} else {\n\t\tw = area->p1.x + area->p1.y * tcm->width - pos + 1;\n\t\th = 1;\n\t}\n\n\tspin_lock(&(tcm->lock));\n\tfree_slots(pos, w, h, tcm->bitmap, tcm->width);\n\tspin_unlock(&(tcm->lock));\n\treturn 0;\n}\n\nstruct tcm *sita_init(u16 width, u16 height)\n{\n\tstruct tcm *tcm;\n\tsize_t map_size = BITS_TO_LONGS(width*height) * sizeof(unsigned long);\n\n\tif (width == 0 || height == 0)\n\t\treturn NULL;\n\n\ttcm = kzalloc(sizeof(*tcm) + map_size, GFP_KERNEL);\n\tif (!tcm)\n\t\tgoto error;\n\n\t \n\ttcm->height = height;\n\ttcm->width = width;\n\ttcm->reserve_2d = sita_reserve_2d;\n\ttcm->reserve_1d = sita_reserve_1d;\n\ttcm->free = sita_free;\n\ttcm->deinit = sita_deinit;\n\n\tspin_lock_init(&tcm->lock);\n\ttcm->bitmap = (unsigned long *)(tcm + 1);\n\tbitmap_clear(tcm->bitmap, 0, width*height);\n\n\ttcm->map_size = width*height;\n\n\treturn tcm;\n\nerror:\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}