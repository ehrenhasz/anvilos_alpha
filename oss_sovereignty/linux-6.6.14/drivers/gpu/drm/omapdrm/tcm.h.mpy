{
  "module_name": "tcm.h",
  "hash_id": "8f186b91225b45605677ba3355cba8947d54c7545198516ebaa99c72e27e16ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/tcm.h",
  "human_readable_source": " \n\n#ifndef TCM_H\n#define TCM_H\n\nstruct tcm;\n\n \nstruct tcm_pt {\n\tu16 x;\n\tu16 y;\n};\n\n \nstruct tcm_area {\n\tbool is2d;\t\t \n\tstruct tcm    *tcm;\t \n\tstruct tcm_pt  p0;\n\tstruct tcm_pt  p1;\n};\n\nstruct tcm {\n\tu16 width, height;\t \n\tint lut_id;\t\t \n\n\tunsigned int y_offset;\t \n\n\tspinlock_t lock;\n\tunsigned long *bitmap;\n\tsize_t map_size;\n\n\t \n\ts32 (*reserve_2d)(struct tcm *tcm, u16 height, u16 width, u16 align,\n\t\t\t  s16 offset, u16 slot_bytes,\n\t\t\t  struct tcm_area *area);\n\ts32 (*reserve_1d)(struct tcm *tcm, u32 slots, struct tcm_area *area);\n\ts32 (*free)(struct tcm *tcm, struct tcm_area *area);\n\tvoid (*deinit)(struct tcm *tcm);\n};\n\n \n\n \n\nstruct tcm *sita_init(u16 width, u16 height);\n\n\n \nstatic inline void tcm_deinit(struct tcm *tcm)\n{\n\tif (tcm)\n\t\ttcm->deinit(tcm);\n}\n\n \nstatic inline s32 tcm_reserve_2d(struct tcm *tcm, u16 width, u16 height,\n\t\t\t\tu16 align, s16 offset, u16 slot_bytes,\n\t\t\t\tstruct tcm_area *area)\n{\n\t \n\ts32 res = tcm  == NULL ? -ENODEV :\n\t\t(area == NULL || width == 0 || height == 0 ||\n\t\t  \n\t\t (align & (align - 1))) ? -EINVAL :\n\t\t(height > tcm->height || width > tcm->width) ? -ENOMEM : 0;\n\n\tif (!res) {\n\t\tarea->is2d = true;\n\t\tres = tcm->reserve_2d(tcm, height, width, align, offset,\n\t\t\t\t\tslot_bytes, area);\n\t\tarea->tcm = res ? NULL : tcm;\n\t}\n\n\treturn res;\n}\n\n \nstatic inline s32 tcm_reserve_1d(struct tcm *tcm, u32 slots,\n\t\t\t\t struct tcm_area *area)\n{\n\t \n\ts32 res = tcm  == NULL ? -ENODEV :\n\t\t(area == NULL || slots == 0) ? -EINVAL :\n\t\tslots > (tcm->width * (u32) tcm->height) ? -ENOMEM : 0;\n\n\tif (!res) {\n\t\tarea->is2d = false;\n\t\tres = tcm->reserve_1d(tcm, slots, area);\n\t\tarea->tcm = res ? NULL : tcm;\n\t}\n\n\treturn res;\n}\n\n \nstatic inline s32 tcm_free(struct tcm_area *area)\n{\n\ts32 res = 0;  \n\n\tif (area && area->tcm) {\n\t\tres = area->tcm->free(area->tcm, area);\n\t\tif (res == 0)\n\t\t\tarea->tcm = NULL;\n\t}\n\n\treturn res;\n}\n\n \n\n \nstatic inline void tcm_slice(struct tcm_area *parent, struct tcm_area *slice)\n{\n\t*slice = *parent;\n\n\t \n\tif (slice->tcm && !slice->is2d &&\n\t\tslice->p0.y != slice->p1.y &&\n\t\t(slice->p0.x || (slice->p1.x != slice->tcm->width - 1))) {\n\t\t \n\t\tslice->p1.x = slice->tcm->width - 1;\n\t\tslice->p1.y = (slice->p0.x) ? slice->p0.y : slice->p1.y - 1;\n\t\t \n\t\tparent->p0.x = 0;\n\t\tparent->p0.y = slice->p1.y + 1;\n\t} else {\n\t\t \n\t\tparent->tcm = NULL;\n\t}\n}\n\n \nstatic inline bool tcm_area_is_valid(struct tcm_area *area)\n{\n\treturn area && area->tcm &&\n\t\t \n\t\tarea->p1.x < area->tcm->width &&\n\t\tarea->p1.y < area->tcm->height &&\n\t\tarea->p0.y <= area->p1.y &&\n\t\t \n\t\t((!area->is2d &&\n\t\t  area->p0.x < area->tcm->width &&\n\t\t  area->p0.x + area->p0.y * area->tcm->width <=\n\t\t  area->p1.x + area->p1.y * area->tcm->width) ||\n\t\t  \n\t\t (area->is2d &&\n\t\t  area->p0.x <= area->p1.x));\n}\n\n \nstatic inline bool __tcm_is_in(struct tcm_pt *p, struct tcm_area *a)\n{\n\tu16 i;\n\n\tif (a->is2d) {\n\t\treturn p->x >= a->p0.x && p->x <= a->p1.x &&\n\t\t       p->y >= a->p0.y && p->y <= a->p1.y;\n\t} else {\n\t\ti = p->x + p->y * a->tcm->width;\n\t\treturn i >= a->p0.x + a->p0.y * a->tcm->width &&\n\t\t       i <= a->p1.x + a->p1.y * a->tcm->width;\n\t}\n}\n\n \nstatic inline u16 __tcm_area_width(struct tcm_area *area)\n{\n\treturn area->p1.x - area->p0.x + 1;\n}\n\n \nstatic inline u16 __tcm_area_height(struct tcm_area *area)\n{\n\treturn area->p1.y - area->p0.y + 1;\n}\n\n \nstatic inline u16 __tcm_sizeof(struct tcm_area *area)\n{\n\treturn area->is2d ?\n\t\t__tcm_area_width(area) * __tcm_area_height(area) :\n\t\t(area->p1.x - area->p0.x + 1) + (area->p1.y - area->p0.y) *\n\t\t\t\t\t\t\tarea->tcm->width;\n}\n#define tcm_sizeof(area) __tcm_sizeof(&(area))\n#define tcm_awidth(area) __tcm_area_width(&(area))\n#define tcm_aheight(area) __tcm_area_height(&(area))\n#define tcm_is_in(pt, area) __tcm_is_in(&(pt), &(area))\n\n \nstatic inline s32 tcm_1d_limit(struct tcm_area *a, u32 num_pg)\n{\n\tif (__tcm_sizeof(a) < num_pg)\n\t\treturn -ENOMEM;\n\tif (!num_pg)\n\t\treturn -EINVAL;\n\n\ta->p1.x = (a->p0.x + num_pg - 1) % a->tcm->width;\n\ta->p1.y = a->p0.y + ((a->p0.x + num_pg - 1) / a->tcm->width);\n\treturn 0;\n}\n\n \n#define tcm_for_each_slice(var, area, safe) \\\n\tfor (safe = area, \\\n\t     tcm_slice(&safe, &var); \\\n\t     var.tcm; tcm_slice(&safe, &var))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}