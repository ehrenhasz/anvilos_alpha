{
  "module_name": "omap_irq.c",
  "hash_id": "5238b738c509b959a9a27d6f2e9005f9c91e3c0f7f250f9021362b079ed5d682",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_irq.c",
  "human_readable_source": "\n \n\n#include <drm/drm_vblank.h>\n\n#include \"omap_drv.h\"\n\nstruct omap_irq_wait {\n\tstruct list_head node;\n\twait_queue_head_t wq;\n\tu32 irqmask;\n\tint count;\n};\n\n \nstatic void omap_irq_update(struct drm_device *dev)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct omap_irq_wait *wait;\n\tu32 irqmask = priv->irq_mask;\n\n\tassert_spin_locked(&priv->wait_lock);\n\n\tlist_for_each_entry(wait, &priv->wait_list, node)\n\t\tirqmask |= wait->irqmask;\n\n\tDBG(\"irqmask=%08x\", irqmask);\n\n\tdispc_write_irqenable(priv->dispc, irqmask);\n}\n\nstatic void omap_irq_wait_handler(struct omap_irq_wait *wait)\n{\n\twait->count--;\n\twake_up(&wait->wq);\n}\n\nstruct omap_irq_wait * omap_irq_wait_init(struct drm_device *dev,\n\t\tu32 irqmask, int count)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct omap_irq_wait *wait = kzalloc(sizeof(*wait), GFP_KERNEL);\n\tunsigned long flags;\n\n\tinit_waitqueue_head(&wait->wq);\n\twait->irqmask = irqmask;\n\twait->count = count;\n\n\tspin_lock_irqsave(&priv->wait_lock, flags);\n\tlist_add(&wait->node, &priv->wait_list);\n\tomap_irq_update(dev);\n\tspin_unlock_irqrestore(&priv->wait_lock, flags);\n\n\treturn wait;\n}\n\nint omap_irq_wait(struct drm_device *dev, struct omap_irq_wait *wait,\n\t\tunsigned long timeout)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned long flags;\n\tint ret;\n\n\tret = wait_event_timeout(wait->wq, (wait->count <= 0), timeout);\n\n\tspin_lock_irqsave(&priv->wait_lock, flags);\n\tlist_del(&wait->node);\n\tomap_irq_update(dev);\n\tspin_unlock_irqrestore(&priv->wait_lock, flags);\n\n\tkfree(wait);\n\n\treturn ret == 0 ? -1 : 0;\n}\n\nint omap_irq_enable_framedone(struct drm_crtc *crtc, bool enable)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned long flags;\n\tenum omap_channel channel = omap_crtc_channel(crtc);\n\tint framedone_irq =\n\t\tdispc_mgr_get_framedone_irq(priv->dispc, channel);\n\n\tDBG(\"dev=%p, crtc=%u, enable=%d\", dev, channel, enable);\n\n\tspin_lock_irqsave(&priv->wait_lock, flags);\n\tif (enable)\n\t\tpriv->irq_mask |= framedone_irq;\n\telse\n\t\tpriv->irq_mask &= ~framedone_irq;\n\tomap_irq_update(dev);\n\tspin_unlock_irqrestore(&priv->wait_lock, flags);\n\n\treturn 0;\n}\n\n \nint omap_irq_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned long flags;\n\tenum omap_channel channel = omap_crtc_channel(crtc);\n\n\tDBG(\"dev=%p, crtc=%u\", dev, channel);\n\n\tspin_lock_irqsave(&priv->wait_lock, flags);\n\tpriv->irq_mask |= dispc_mgr_get_vsync_irq(priv->dispc,\n\t\t\t\t\t\t\t     channel);\n\tomap_irq_update(dev);\n\tspin_unlock_irqrestore(&priv->wait_lock, flags);\n\n\treturn 0;\n}\n\n \nvoid omap_irq_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned long flags;\n\tenum omap_channel channel = omap_crtc_channel(crtc);\n\n\tDBG(\"dev=%p, crtc=%u\", dev, channel);\n\n\tspin_lock_irqsave(&priv->wait_lock, flags);\n\tpriv->irq_mask &= ~dispc_mgr_get_vsync_irq(priv->dispc,\n\t\t\t\t\t\t\t      channel);\n\tomap_irq_update(dev);\n\tspin_unlock_irqrestore(&priv->wait_lock, flags);\n}\n\nstatic void omap_irq_fifo_underflow(struct omap_drm_private *priv,\n\t\t\t\t    u32 irqstatus)\n{\n\tstatic DEFINE_RATELIMIT_STATE(_rs, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t\t      DEFAULT_RATELIMIT_BURST);\n\tstatic const struct {\n\t\tconst char *name;\n\t\tu32 mask;\n\t} sources[] = {\n\t\t{ \"gfx\", DISPC_IRQ_GFX_FIFO_UNDERFLOW },\n\t\t{ \"vid1\", DISPC_IRQ_VID1_FIFO_UNDERFLOW },\n\t\t{ \"vid2\", DISPC_IRQ_VID2_FIFO_UNDERFLOW },\n\t\t{ \"vid3\", DISPC_IRQ_VID3_FIFO_UNDERFLOW },\n\t};\n\n\tconst u32 mask = DISPC_IRQ_GFX_FIFO_UNDERFLOW\n\t\t       | DISPC_IRQ_VID1_FIFO_UNDERFLOW\n\t\t       | DISPC_IRQ_VID2_FIFO_UNDERFLOW\n\t\t       | DISPC_IRQ_VID3_FIFO_UNDERFLOW;\n\tunsigned int i;\n\n\tspin_lock(&priv->wait_lock);\n\tirqstatus &= priv->irq_mask & mask;\n\tspin_unlock(&priv->wait_lock);\n\n\tif (!irqstatus)\n\t\treturn;\n\n\tif (!__ratelimit(&_rs))\n\t\treturn;\n\n\tDRM_ERROR(\"FIFO underflow on \");\n\n\tfor (i = 0; i < ARRAY_SIZE(sources); ++i) {\n\t\tif (sources[i].mask & irqstatus)\n\t\t\tpr_cont(\"%s \", sources[i].name);\n\t}\n\n\tpr_cont(\"(0x%08x)\\n\", irqstatus);\n}\n\nstatic void omap_irq_ocp_error_handler(struct drm_device *dev,\n\tu32 irqstatus)\n{\n\tif (!(irqstatus & DISPC_IRQ_OCP_ERR))\n\t\treturn;\n\n\tdev_err_ratelimited(dev->dev, \"OCP error\\n\");\n}\n\nstatic irqreturn_t omap_irq_handler(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *) arg;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct omap_irq_wait *wait, *n;\n\tunsigned long flags;\n\tunsigned int id;\n\tu32 irqstatus;\n\n\tirqstatus = dispc_read_irqstatus(priv->dispc);\n\tdispc_clear_irqstatus(priv->dispc, irqstatus);\n\tdispc_read_irqstatus(priv->dispc);\t \n\n\tVERB(\"irqs: %08x\", irqstatus);\n\n\tfor (id = 0; id < priv->num_pipes; id++) {\n\t\tstruct drm_crtc *crtc = priv->pipes[id].crtc;\n\t\tenum omap_channel channel = omap_crtc_channel(crtc);\n\n\t\tif (irqstatus & dispc_mgr_get_vsync_irq(priv->dispc, channel)) {\n\t\t\tdrm_handle_vblank(dev, id);\n\t\t\tomap_crtc_vblank_irq(crtc);\n\t\t}\n\n\t\tif (irqstatus & dispc_mgr_get_sync_lost_irq(priv->dispc, channel))\n\t\t\tomap_crtc_error_irq(crtc, irqstatus);\n\n\t\tif (irqstatus & dispc_mgr_get_framedone_irq(priv->dispc, channel))\n\t\t\tomap_crtc_framedone_irq(crtc, irqstatus);\n\t}\n\n\tomap_irq_ocp_error_handler(dev, irqstatus);\n\tomap_irq_fifo_underflow(priv, irqstatus);\n\n\tspin_lock_irqsave(&priv->wait_lock, flags);\n\tlist_for_each_entry_safe(wait, n, &priv->wait_list, node) {\n\t\tif (wait->irqmask & irqstatus)\n\t\t\tomap_irq_wait_handler(wait);\n\t}\n\tspin_unlock_irqrestore(&priv->wait_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const u32 omap_underflow_irqs[] = {\n\t[OMAP_DSS_GFX] = DISPC_IRQ_GFX_FIFO_UNDERFLOW,\n\t[OMAP_DSS_VIDEO1] = DISPC_IRQ_VID1_FIFO_UNDERFLOW,\n\t[OMAP_DSS_VIDEO2] = DISPC_IRQ_VID2_FIFO_UNDERFLOW,\n\t[OMAP_DSS_VIDEO3] = DISPC_IRQ_VID3_FIFO_UNDERFLOW,\n};\n\nint omap_drm_irq_install(struct drm_device *dev)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned int num_mgrs = dispc_get_num_mgrs(priv->dispc);\n\tunsigned int max_planes;\n\tunsigned int i;\n\tint ret;\n\n\tspin_lock_init(&priv->wait_lock);\n\tINIT_LIST_HEAD(&priv->wait_list);\n\n\tpriv->irq_mask = DISPC_IRQ_OCP_ERR;\n\n\tmax_planes = min(ARRAY_SIZE(priv->planes),\n\t\t\t ARRAY_SIZE(omap_underflow_irqs));\n\tfor (i = 0; i < max_planes; ++i) {\n\t\tif (priv->planes[i])\n\t\t\tpriv->irq_mask |= omap_underflow_irqs[i];\n\t}\n\n\tfor (i = 0; i < num_mgrs; ++i)\n\t\tpriv->irq_mask |= dispc_mgr_get_sync_lost_irq(priv->dispc, i);\n\n\tdispc_runtime_get(priv->dispc);\n\tdispc_clear_irqstatus(priv->dispc, 0xffffffff);\n\tdispc_runtime_put(priv->dispc);\n\n\tret = dispc_request_irq(priv->dispc, omap_irq_handler, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->irq_enabled = true;\n\n\treturn 0;\n}\n\nvoid omap_drm_irq_uninstall(struct drm_device *dev)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\n\tif (!priv->irq_enabled)\n\t\treturn;\n\n\tpriv->irq_enabled = false;\n\n\tdispc_free_irq(priv->dispc, dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}