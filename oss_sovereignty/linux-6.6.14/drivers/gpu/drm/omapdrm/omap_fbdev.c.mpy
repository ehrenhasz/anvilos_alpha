{
  "module_name": "omap_fbdev.c",
  "hash_id": "de2f71888ad5797efe99245cc7b6994c16491498e52abf29701f7d5eed8dcf0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_fbdev.c",
  "human_readable_source": "\n \n\n#include <linux/fb.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_util.h>\n\n#include \"omap_drv.h\"\n#include \"omap_fbdev.h\"\n\nMODULE_PARM_DESC(ywrap, \"Enable ywrap scrolling (omap44xx and later, default 'y')\");\nstatic bool ywrap_enabled = true;\nmodule_param_named(ywrap, ywrap_enabled, bool, 0644);\n\n \n\n#define to_omap_fbdev(x) container_of(x, struct omap_fbdev, base)\n\nstruct omap_fbdev {\n\tstruct drm_fb_helper base;\n\tbool ywrap_enabled;\n\n\t \n\tstruct work_struct work;\n};\n\nstatic struct drm_fb_helper *get_fb(struct fb_info *fbi);\n\nstatic void pan_worker(struct work_struct *work)\n{\n\tstruct omap_fbdev *fbdev = container_of(work, struct omap_fbdev, work);\n\tstruct drm_fb_helper *helper = &fbdev->base;\n\tstruct fb_info *fbi = helper->info;\n\tstruct drm_gem_object *bo = drm_gem_fb_get_obj(helper->fb, 0);\n\tint npages;\n\n\t \n\tnpages = fbi->fix.line_length >> PAGE_SHIFT;\n\tomap_gem_roll(bo, fbi->var.yoffset * npages);\n}\n\nstatic int omap_fbdev_pan_display(struct fb_var_screeninfo *var,\n\t\tstruct fb_info *fbi)\n{\n\tstruct drm_fb_helper *helper = get_fb(fbi);\n\tstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\n\n\tif (!helper)\n\t\tgoto fallback;\n\n\tif (!fbdev->ywrap_enabled)\n\t\tgoto fallback;\n\n\tif (drm_can_sleep()) {\n\t\tpan_worker(&fbdev->work);\n\t} else {\n\t\tstruct omap_drm_private *priv = helper->dev->dev_private;\n\t\tqueue_work(priv->wq, &fbdev->work);\n\t}\n\n\treturn 0;\n\nfallback:\n\treturn drm_fb_helper_pan_display(var, fbi);\n}\n\nstatic int omap_fbdev_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tstruct drm_framebuffer *fb = helper->fb;\n\tstruct drm_gem_object *bo = drm_gem_fb_get_obj(fb, 0);\n\n\treturn drm_gem_mmap_obj(bo, omap_gem_mmap_size(bo), vma);\n}\n\nstatic void omap_fbdev_fb_destroy(struct fb_info *info)\n{\n\tstruct drm_fb_helper *helper = info->par;\n\tstruct drm_framebuffer *fb = helper->fb;\n\tstruct drm_gem_object *bo = drm_gem_fb_get_obj(fb, 0);\n\tstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\n\n\tDBG();\n\n\tdrm_fb_helper_fini(helper);\n\n\tomap_gem_unpin(bo);\n\tdrm_framebuffer_remove(fb);\n\n\tdrm_client_release(&helper->client);\n\tdrm_fb_helper_unprepare(helper);\n\tkfree(fbdev);\n}\n\nstatic const struct fb_ops omap_fb_ops = {\n\t.owner = THIS_MODULE,\n\t__FB_DEFAULT_DMAMEM_OPS_RDWR,\n\t.fb_check_var\t= drm_fb_helper_check_var,\n\t.fb_set_par\t= drm_fb_helper_set_par,\n\t.fb_setcmap\t= drm_fb_helper_setcmap,\n\t.fb_blank\t= drm_fb_helper_blank,\n\t.fb_pan_display = omap_fbdev_pan_display,\n\t__FB_DEFAULT_DMAMEM_OPS_DRAW,\n\t.fb_ioctl\t= drm_fb_helper_ioctl,\n\t.fb_mmap\t= omap_fbdev_fb_mmap,\n\t.fb_destroy\t= omap_fbdev_fb_destroy,\n};\n\nstatic int omap_fbdev_create(struct drm_fb_helper *helper,\n\t\tstruct drm_fb_helper_surface_size *sizes)\n{\n\tstruct omap_fbdev *fbdev = to_omap_fbdev(helper);\n\tstruct drm_device *dev = helper->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tstruct drm_framebuffer *fb = NULL;\n\tunion omap_gem_size gsize;\n\tstruct fb_info *fbi = NULL;\n\tstruct drm_mode_fb_cmd2 mode_cmd = {0};\n\tstruct drm_gem_object *bo;\n\tdma_addr_t dma_addr;\n\tint ret;\n\n\tsizes->surface_bpp = 32;\n\tsizes->surface_depth = 24;\n\n\tDBG(\"create fbdev: %dx%d@%d (%dx%d)\", sizes->surface_width,\n\t\t\tsizes->surface_height, sizes->surface_bpp,\n\t\t\tsizes->fb_width, sizes->fb_height);\n\n\tmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\tsizes->surface_depth);\n\n\tmode_cmd.width = sizes->surface_width;\n\tmode_cmd.height = sizes->surface_height;\n\n\tmode_cmd.pitches[0] =\n\t\t\tDIV_ROUND_UP(mode_cmd.width * sizes->surface_bpp, 8);\n\n\tfbdev->ywrap_enabled = priv->has_dmm && ywrap_enabled;\n\tif (fbdev->ywrap_enabled) {\n\t\t \n\t\tmode_cmd.pitches[0] = PAGE_ALIGN(mode_cmd.pitches[0]);\n\t}\n\n\t \n\tgsize = (union omap_gem_size){\n\t\t.bytes = PAGE_ALIGN(mode_cmd.pitches[0] * mode_cmd.height),\n\t};\n\tDBG(\"allocating %d bytes for fb %d\", gsize.bytes, dev->primary->index);\n\tbo = omap_gem_new(dev, gsize, OMAP_BO_SCANOUT | OMAP_BO_WC);\n\tif (!bo) {\n\t\tdev_err(dev->dev, \"failed to allocate buffer object\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfb = omap_framebuffer_init(dev, &mode_cmd, &bo);\n\tif (IS_ERR(fb)) {\n\t\tdev_err(dev->dev, \"failed to allocate fb\\n\");\n\t\t \n\t\tdrm_gem_object_put(bo);\n\t\tret = PTR_ERR(fb);\n\t\tgoto fail;\n\t}\n\n\t \n\tret = omap_gem_pin(bo, &dma_addr);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"could not pin framebuffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfbi = drm_fb_helper_alloc_info(helper);\n\tif (IS_ERR(fbi)) {\n\t\tdev_err(dev->dev, \"failed to allocate fb info\\n\");\n\t\tret = PTR_ERR(fbi);\n\t\tgoto fail;\n\t}\n\n\tDBG(\"fbi=%p, dev=%p\", fbi, dev);\n\n\thelper->fb = fb;\n\n\tfbi->fbops = &omap_fb_ops;\n\n\tdrm_fb_helper_fill_info(fbi, helper, sizes);\n\n\tfbi->flags |= FBINFO_VIRTFB;\n\tfbi->screen_buffer = omap_gem_vaddr(bo);\n\tfbi->screen_size = bo->size;\n\tfbi->fix.smem_start = dma_addr;\n\tfbi->fix.smem_len = bo->size;\n\n\t \n\tif (fbdev->ywrap_enabled) {\n\t\tDRM_INFO(\"Enabling DMM ywrap scrolling\\n\");\n\t\tfbi->flags |= FBINFO_HWACCEL_YWRAP | FBINFO_READS_FAST;\n\t\tfbi->fix.ywrapstep = 1;\n\t}\n\n\n\tDBG(\"par=%p, %dx%d\", fbi->par, fbi->var.xres, fbi->var.yres);\n\tDBG(\"allocated %dx%d fb\", fb->width, fb->height);\n\n\treturn 0;\n\nfail:\n\n\tif (ret) {\n\t\tif (fb)\n\t\t\tdrm_framebuffer_remove(fb);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct drm_fb_helper_funcs omap_fb_helper_funcs = {\n\t.fb_probe = omap_fbdev_create,\n};\n\nstatic struct drm_fb_helper *get_fb(struct fb_info *fbi)\n{\n\tif (!fbi || strcmp(fbi->fix.id, MODULE_NAME)) {\n\t\t \n\t\treturn NULL;\n\t}\n\treturn fbi->par;\n}\n\n \n\nstatic void omap_fbdev_client_unregister(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\n\tif (fb_helper->info) {\n\t\tdrm_fb_helper_unregister_info(fb_helper);\n\t} else {\n\t\tdrm_client_release(&fb_helper->client);\n\t\tdrm_fb_helper_unprepare(fb_helper);\n\t\tkfree(fb_helper);\n\t}\n}\n\nstatic int omap_fbdev_client_restore(struct drm_client_dev *client)\n{\n\tdrm_fb_helper_lastclose(client->dev);\n\n\treturn 0;\n}\n\nstatic int omap_fbdev_client_hotplug(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = client->dev;\n\tint ret;\n\n\tif (dev->fb_helper)\n\t\treturn drm_fb_helper_hotplug_event(dev->fb_helper);\n\n\tret = drm_fb_helper_init(dev, fb_helper);\n\tif (ret)\n\t\tgoto err_drm_err;\n\n\tret = drm_fb_helper_initial_config(fb_helper);\n\tif (ret)\n\t\tgoto err_drm_fb_helper_fini;\n\n\treturn 0;\n\nerr_drm_fb_helper_fini:\n\tdrm_fb_helper_fini(fb_helper);\nerr_drm_err:\n\tdrm_err(dev, \"Failed to setup fbdev emulation (ret=%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct drm_client_funcs omap_fbdev_client_funcs = {\n\t.owner\t\t= THIS_MODULE,\n\t.unregister\t= omap_fbdev_client_unregister,\n\t.restore\t= omap_fbdev_client_restore,\n\t.hotplug\t= omap_fbdev_client_hotplug,\n};\n\nvoid omap_fbdev_setup(struct drm_device *dev)\n{\n\tstruct omap_fbdev *fbdev;\n\tstruct drm_fb_helper *helper;\n\tint ret;\n\n\tdrm_WARN(dev, !dev->registered, \"Device has not been registered.\\n\");\n\tdrm_WARN(dev, dev->fb_helper, \"fb_helper is already set!\\n\");\n\n\tfbdev = kzalloc(sizeof(*fbdev), GFP_KERNEL);\n\tif (!fbdev)\n\t\treturn;\n\thelper = &fbdev->base;\n\n\tdrm_fb_helper_prepare(dev, helper, 32, &omap_fb_helper_funcs);\n\n\tret = drm_client_init(dev, &helper->client, \"fbdev\", &omap_fbdev_client_funcs);\n\tif (ret)\n\t\tgoto err_drm_client_init;\n\n\tINIT_WORK(&fbdev->work, pan_worker);\n\n\tdrm_client_register(&helper->client);\n\n\treturn;\n\nerr_drm_client_init:\n\tdrm_fb_helper_unprepare(helper);\n\tkfree(fbdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}