{
  "module_name": "omap_fb.c",
  "hash_id": "5e7854f7eacc268b70da5ecd53d3ea86f6672f956865cb2ef3e04b6f03a9ca81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_fb.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"omap_dmm_tiler.h\"\n#include \"omap_drv.h\"\n\n \n\nstatic const u32 formats[] = {\n\t \n\tDRM_FORMAT_RGB565,  \n\tDRM_FORMAT_RGBX4444,  \n\tDRM_FORMAT_XRGB4444,  \n\tDRM_FORMAT_RGBA4444,  \n\tDRM_FORMAT_ARGB4444,  \n\tDRM_FORMAT_XRGB1555,  \n\tDRM_FORMAT_ARGB1555,  \n\t \n\tDRM_FORMAT_RGB888,    \n\t \n\tDRM_FORMAT_RGBX8888,  \n\tDRM_FORMAT_XRGB8888,  \n\tDRM_FORMAT_RGBA8888,  \n\tDRM_FORMAT_ARGB8888,  \n\t \n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY,\n};\n\n \nstruct plane {\n\tdma_addr_t dma_addr;\n};\n\n#define to_omap_framebuffer(x) container_of(x, struct omap_framebuffer, base)\n\nstruct omap_framebuffer {\n\tstruct drm_framebuffer base;\n\tint pin_count;\n\tconst struct drm_format_info *format;\n\tstruct plane planes[2];\n\t \n\tstruct mutex lock;\n};\n\nstatic int omap_framebuffer_dirty(struct drm_framebuffer *fb,\n\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t  unsigned flags, unsigned color,\n\t\t\t\t  struct drm_clip_rect *clips,\n\t\t\t\t  unsigned num_clips)\n{\n\tstruct drm_crtc *crtc;\n\n\tdrm_modeset_lock_all(fb->dev);\n\n\tdrm_for_each_crtc(crtc, fb->dev)\n\t\tomap_crtc_flush(crtc);\n\n\tdrm_modeset_unlock_all(fb->dev);\n\n\treturn 0;\n}\n\nstatic const struct drm_framebuffer_funcs omap_framebuffer_funcs = {\n\t.create_handle = drm_gem_fb_create_handle,\n\t.dirty = omap_framebuffer_dirty,\n\t.destroy = drm_gem_fb_destroy,\n};\n\nstatic u32 get_linear_addr(struct drm_framebuffer *fb,\n\t\tconst struct drm_format_info *format, int n, int x, int y)\n{\n\tstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\n\tstruct plane *plane = &omap_fb->planes[n];\n\tu32 offset;\n\n\toffset = fb->offsets[n]\n\t       + (x * format->cpp[n] / (n == 0 ? 1 : format->hsub))\n\t       + (y * fb->pitches[n] / (n == 0 ? 1 : format->vsub));\n\n\treturn plane->dma_addr + offset;\n}\n\nbool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)\n{\n\treturn omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED_MASK;\n}\n\n \nstatic u32 drm_rotation_to_tiler(unsigned int drm_rot)\n{\n\tu32 orient;\n\n\tswitch (drm_rot & DRM_MODE_ROTATE_MASK) {\n\tdefault:\n\tcase DRM_MODE_ROTATE_0:\n\t\torient = 0;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\torient = MASK_XY_FLIP | MASK_X_INVERT;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\torient = MASK_X_INVERT | MASK_Y_INVERT;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\torient = MASK_XY_FLIP | MASK_Y_INVERT;\n\t\tbreak;\n\t}\n\n\tif (drm_rot & DRM_MODE_REFLECT_X)\n\t\torient ^= MASK_X_INVERT;\n\n\tif (drm_rot & DRM_MODE_REFLECT_Y)\n\t\torient ^= MASK_Y_INVERT;\n\n\treturn orient;\n}\n\n \nvoid omap_framebuffer_update_scanout(struct drm_framebuffer *fb,\n\t\tstruct drm_plane_state *state,\n\t\tstruct omap_overlay_info *info,\n\t\tstruct omap_overlay_info *r_info)\n{\n\tstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\n\tconst struct drm_format_info *format = omap_fb->format;\n\tu32 x, y, orient = 0;\n\n\tinfo->fourcc = fb->format->format;\n\n\tinfo->pos_x      = state->crtc_x;\n\tinfo->pos_y      = state->crtc_y;\n\tinfo->out_width  = state->crtc_w;\n\tinfo->out_height = state->crtc_h;\n\tinfo->width      = state->src_w >> 16;\n\tinfo->height     = state->src_h >> 16;\n\n\t \n\tif (drm_rotation_90_or_270(state->rotation))\n\t\tswap(info->width, info->height);\n\n\tx = state->src_x >> 16;\n\ty = state->src_y >> 16;\n\n\tif (omap_gem_flags(fb->obj[0]) & OMAP_BO_TILED_MASK) {\n\t\tu32 w = state->src_w >> 16;\n\t\tu32 h = state->src_h >> 16;\n\n\t\torient = drm_rotation_to_tiler(state->rotation);\n\n\t\t \n\t\tif (fb->format->format == DRM_FORMAT_UYVY ||\n\t\t\t\tfb->format->format == DRM_FORMAT_YUYV) {\n\t\t\tx /= 2;\n\t\t\tw /= 2;\n\t\t}\n\n\t\t \n\t\tif (orient & MASK_Y_INVERT)\n\t\t\ty += h - 1;\n\t\tif (orient & MASK_X_INVERT)\n\t\t\tx += w - 1;\n\n\t\t \n\t\tomap_gem_rotated_dma_addr(fb->obj[0], orient, x, y,\n\t\t\t\t\t  &info->paddr);\n\t\tinfo->rotation_type = OMAP_DSS_ROT_TILER;\n\t\tinfo->rotation = state->rotation ?: DRM_MODE_ROTATE_0;\n\t\t \n\t\tinfo->screen_width  = omap_gem_tiled_stride(fb->obj[0], orient);\n\t} else {\n\t\tswitch (state->rotation & DRM_MODE_ROTATE_MASK) {\n\t\tcase 0:\n\t\tcase DRM_MODE_ROTATE_0:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(fb->dev->dev,\n\t\t\t\t\"rotation '%d' ignored for non-tiled fb\\n\",\n\t\t\t\tstate->rotation);\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->paddr         = get_linear_addr(fb, format, 0, x, y);\n\t\tinfo->rotation_type = OMAP_DSS_ROT_NONE;\n\t\tinfo->rotation      = DRM_MODE_ROTATE_0;\n\t\tinfo->screen_width  = fb->pitches[0];\n\t}\n\n\t \n\tinfo->screen_width /= format->cpp[0];\n\n\tif (fb->format->format == DRM_FORMAT_NV12) {\n\t\tif (info->rotation_type == OMAP_DSS_ROT_TILER) {\n\t\t\tWARN_ON(!(omap_gem_flags(fb->obj[1]) & OMAP_BO_TILED_MASK));\n\t\t\tomap_gem_rotated_dma_addr(fb->obj[1], orient, x/2, y/2,\n\t\t\t\t\t\t  &info->p_uv_addr);\n\t\t} else {\n\t\t\tinfo->p_uv_addr = get_linear_addr(fb, format, 1, x, y);\n\t\t}\n\t} else {\n\t\tinfo->p_uv_addr = 0;\n\t}\n\n\tif (r_info) {\n\t\tinfo->width /= 2;\n\t\tinfo->out_width /= 2;\n\n\t\t*r_info = *info;\n\n\t\tif (fb->format->is_yuv) {\n\t\t\tif (info->width & 1) {\n\t\t\t\tinfo->width++;\n\t\t\t\tr_info->width--;\n\t\t\t}\n\n\t\t\tif (info->out_width & 1) {\n\t\t\t\tinfo->out_width++;\n\t\t\t\tr_info->out_width--;\n\t\t\t}\n\t\t}\n\n\t\tr_info->pos_x = info->pos_x + info->out_width;\n\n\t\tr_info->paddr =\tget_linear_addr(fb, format, 0,\n\t\t\t\t\t\tx + info->width, y);\n\t\tif (fb->format->format == DRM_FORMAT_NV12) {\n\t\t\tr_info->p_uv_addr =\n\t\t\t\tget_linear_addr(fb, format, 1,\n\t\t\t\t\t\tx + info->width, y);\n\t\t}\n\t}\n}\n\n \nint omap_framebuffer_pin(struct drm_framebuffer *fb)\n{\n\tstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\n\tint ret, i, n = fb->format->num_planes;\n\n\tmutex_lock(&omap_fb->lock);\n\n\tif (omap_fb->pin_count > 0) {\n\t\tomap_fb->pin_count++;\n\t\tmutex_unlock(&omap_fb->lock);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct plane *plane = &omap_fb->planes[i];\n\t\tret = omap_gem_pin(fb->obj[i], &plane->dma_addr);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tomap_gem_dma_sync_buffer(fb->obj[i], DMA_TO_DEVICE);\n\t}\n\n\tomap_fb->pin_count++;\n\n\tmutex_unlock(&omap_fb->lock);\n\n\treturn 0;\n\nfail:\n\tfor (i--; i >= 0; i--) {\n\t\tstruct plane *plane = &omap_fb->planes[i];\n\t\tomap_gem_unpin(fb->obj[i]);\n\t\tplane->dma_addr = 0;\n\t}\n\n\tmutex_unlock(&omap_fb->lock);\n\n\treturn ret;\n}\n\n \nvoid omap_framebuffer_unpin(struct drm_framebuffer *fb)\n{\n\tstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\n\tint i, n = fb->format->num_planes;\n\n\tmutex_lock(&omap_fb->lock);\n\n\tomap_fb->pin_count--;\n\n\tif (omap_fb->pin_count > 0) {\n\t\tmutex_unlock(&omap_fb->lock);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct plane *plane = &omap_fb->planes[i];\n\t\tomap_gem_unpin(fb->obj[i]);\n\t\tplane->dma_addr = 0;\n\t}\n\n\tmutex_unlock(&omap_fb->lock);\n}\n\n#ifdef CONFIG_DEBUG_FS\nvoid omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)\n{\n\tint i, n = fb->format->num_planes;\n\n\tseq_printf(m, \"fb: %dx%d@%4.4s\\n\", fb->width, fb->height,\n\t\t\t(char *)&fb->format->format);\n\n\tfor (i = 0; i < n; i++) {\n\t\tseq_printf(m, \"   %d: offset=%d pitch=%d, obj: \",\n\t\t\t\ti, fb->offsets[n], fb->pitches[i]);\n\t\tomap_gem_describe(fb->obj[i], m);\n\t}\n}\n#endif\n\nstruct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,\n\t\tstruct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tconst struct drm_format_info *info = drm_get_format_info(dev,\n\t\t\t\t\t\t\t\t mode_cmd);\n\tunsigned int num_planes = info->num_planes;\n\tstruct drm_gem_object *bos[4];\n\tstruct drm_framebuffer *fb;\n\tint i;\n\n\tfor (i = 0; i < num_planes; i++) {\n\t\tbos[i] = drm_gem_object_lookup(file, mode_cmd->handles[i]);\n\t\tif (!bos[i]) {\n\t\t\tfb = ERR_PTR(-ENOENT);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfb = omap_framebuffer_init(dev, mode_cmd, bos);\n\tif (IS_ERR(fb))\n\t\tgoto error;\n\n\treturn fb;\n\nerror:\n\twhile (--i >= 0)\n\t\tdrm_gem_object_put(bos[i]);\n\n\treturn fb;\n}\n\nstruct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,\n\t\tconst struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)\n{\n\tconst struct drm_format_info *format = NULL;\n\tstruct omap_framebuffer *omap_fb = NULL;\n\tstruct drm_framebuffer *fb = NULL;\n\tunsigned int pitch = mode_cmd->pitches[0];\n\tint ret, i;\n\n\tDBG(\"create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)\",\n\t\t\tdev, mode_cmd, mode_cmd->width, mode_cmd->height,\n\t\t\t(char *)&mode_cmd->pixel_format);\n\n\tformat = drm_get_format_info(dev, mode_cmd);\n\n\tfor (i = 0; i < ARRAY_SIZE(formats); i++) {\n\t\tif (formats[i] == mode_cmd->pixel_format)\n\t\t\tbreak;\n\t}\n\n\tif (!format || i == ARRAY_SIZE(formats)) {\n\t\tdev_dbg(dev->dev, \"unsupported pixel format: %4.4s\\n\",\n\t\t\t(char *)&mode_cmd->pixel_format);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tomap_fb = kzalloc(sizeof(*omap_fb), GFP_KERNEL);\n\tif (!omap_fb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tfb = &omap_fb->base;\n\tomap_fb->format = format;\n\tmutex_init(&omap_fb->lock);\n\n\t \n\tif (format->num_planes == 2 && pitch != mode_cmd->pitches[1]) {\n\t\tdev_dbg(dev->dev, \"pitches differ between planes 0 and 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (pitch % format->cpp[0]) {\n\t\tdev_dbg(dev->dev,\n\t\t\t\"buffer pitch (%u bytes) is not a multiple of pixel size (%u bytes)\\n\",\n\t\t\tpitch, format->cpp[0]);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < format->num_planes; i++) {\n\t\tstruct plane *plane = &omap_fb->planes[i];\n\t\tunsigned int vsub = i == 0 ? 1 : format->vsub;\n\t\tunsigned int size;\n\n\t\tsize = pitch * mode_cmd->height / vsub;\n\n\t\tif (size > omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i]) {\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"provided buffer object is too small! %zu < %d\\n\",\n\t\t\t\tbos[i]->size - mode_cmd->offsets[i], size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfb->obj[i]    = bos[i];\n\t\tplane->dma_addr  = 0;\n\t}\n\n\tdrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\n\n\tret = drm_framebuffer_init(dev, fb, &omap_framebuffer_funcs);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"framebuffer init failed: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\n\tDBG(\"create: FB ID: %d (%p)\", fb->base.id, fb);\n\n\treturn fb;\n\nfail:\n\tkfree(omap_fb);\n\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}