{
  "module_name": "omap_overlay.c",
  "hash_id": "7709a1b59559f93be08410794f14b4b0726d3a37a8063854336ce3e5c72140ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_overlay.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n\n#include \"omap_dmm_tiler.h\"\n#include \"omap_drv.h\"\n\n \nstatic const char * const overlay_id_to_name[] = {\n\t[OMAP_DSS_GFX] = \"gfx\",\n\t[OMAP_DSS_VIDEO1] = \"vid1\",\n\t[OMAP_DSS_VIDEO2] = \"vid2\",\n\t[OMAP_DSS_VIDEO3] = \"vid3\",\n};\n\n \nstatic struct omap_hw_overlay *\nomap_plane_find_free_overlay(struct drm_device *dev, struct drm_plane *hwoverlay_to_plane[],\n\t\t\t     u32 caps, u32 fourcc)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tint i;\n\n\tDBG(\"caps: %x fourcc: %x\", caps, fourcc);\n\n\tfor (i = 0; i < priv->num_ovls; i++) {\n\t\tstruct omap_hw_overlay *cur = priv->overlays[i];\n\n\t\tDBG(\"%d: id: %d cur->caps: %x\",\n\t\t    cur->idx, cur->id, cur->caps);\n\n\t\t \n\t\tif (hwoverlay_to_plane[cur->idx])\n\t\t\tcontinue;\n\n\t\t \n\t\tif (caps & ~cur->caps)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!dispc_ovl_color_mode_supported(priv->dispc,\n\t\t\t\t\t\t    cur->id, fourcc))\n\t\t\tcontinue;\n\n\t\treturn cur;\n\t}\n\n\tDBG(\"no match\");\n\treturn NULL;\n}\n\n \nint omap_overlay_assign(struct drm_atomic_state *s, struct drm_plane *plane,\n\t\t\tu32 caps, u32 fourcc, struct omap_hw_overlay **overlay,\n\t\t\tstruct omap_hw_overlay **r_overlay)\n{\n\t \n\tstruct omap_global_state *state = omap_get_global_state(s);\n\tstruct drm_plane **overlay_map = state->hwoverlay_to_plane;\n\tstruct omap_hw_overlay *ovl, *r_ovl;\n\n\tovl = omap_plane_find_free_overlay(s->dev, overlay_map, caps, fourcc);\n\tif (!ovl)\n\t\treturn -ENOMEM;\n\n\toverlay_map[ovl->idx] = plane;\n\t*overlay = ovl;\n\n\tif (r_overlay) {\n\t\tr_ovl = omap_plane_find_free_overlay(s->dev, overlay_map,\n\t\t\t\t\t\t     caps, fourcc);\n\t\tif (!r_ovl) {\n\t\t\toverlay_map[ovl->idx] = NULL;\n\t\t\t*overlay = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\toverlay_map[r_ovl->idx] = plane;\n\t\t*r_overlay = r_ovl;\n\t}\n\n\tDBG(\"%s: assign to plane %s caps %x\", ovl->name, plane->name, caps);\n\n\tif (r_overlay) {\n\t\tDBG(\"%s: assign to right of plane %s caps %x\",\n\t\t    r_ovl->name, plane->name, caps);\n\t}\n\n\treturn 0;\n}\n\n \nvoid omap_overlay_release(struct drm_atomic_state *s, struct omap_hw_overlay *overlay)\n{\n\t \n\tstruct omap_global_state *state = omap_get_global_state(s);\n\tstruct drm_plane **overlay_map = state->hwoverlay_to_plane;\n\n\tif (!overlay)\n\t\treturn;\n\n\tif (WARN_ON(!overlay_map[overlay->idx]))\n\t\treturn;\n\n\tDBG(\"%s: release from plane %s\", overlay->name, overlay_map[overlay->idx]->name);\n\n\toverlay_map[overlay->idx] = NULL;\n}\n\n \nvoid omap_overlay_update_state(struct omap_drm_private *priv,\n\t\t\t       struct omap_hw_overlay *overlay)\n{\n\tstruct omap_global_state *state = omap_get_existing_global_state(priv);\n\tstruct drm_plane **overlay_map = state->hwoverlay_to_plane;\n\n\t \n\tif (!overlay_map[overlay->idx]) {\n\t\tDBG(\"%s: disabled\", overlay->name);\n\n\t\t \n\t\tdispc_ovl_enable(priv->dispc, overlay->id, false);\n\t}\n}\n\nstatic void omap_overlay_destroy(struct omap_hw_overlay *overlay)\n{\n\tkfree(overlay);\n}\n\nstatic struct omap_hw_overlay *omap_overlay_init(enum omap_plane_id overlay_id,\n\t\t\t\t\t\t enum omap_overlay_caps caps)\n{\n\tstruct omap_hw_overlay *overlay;\n\n\toverlay = kzalloc(sizeof(*overlay), GFP_KERNEL);\n\tif (!overlay)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\toverlay->name = overlay_id_to_name[overlay_id];\n\toverlay->id = overlay_id;\n\toverlay->caps = caps;\n\n\treturn overlay;\n}\n\nint omap_hwoverlays_init(struct omap_drm_private *priv)\n{\n\tstatic const enum omap_plane_id hw_plane_ids[] = {\n\t\t\tOMAP_DSS_GFX, OMAP_DSS_VIDEO1,\n\t\t\tOMAP_DSS_VIDEO2, OMAP_DSS_VIDEO3,\n\t};\n\tu32 num_overlays = dispc_get_num_ovls(priv->dispc);\n\tenum omap_overlay_caps caps;\n\tint i, ret;\n\n\tfor (i = 0; i < num_overlays; i++) {\n\t\tstruct omap_hw_overlay *overlay;\n\n\t\tcaps = dispc_ovl_get_caps(priv->dispc, hw_plane_ids[i]);\n\t\toverlay = omap_overlay_init(hw_plane_ids[i], caps);\n\t\tif (IS_ERR(overlay)) {\n\t\t\tret = PTR_ERR(overlay);\n\t\t\tdev_err(priv->dev, \"failed to construct overlay for %s (%d)\\n\",\n\t\t\t\toverlay_id_to_name[i], ret);\n\t\t\tomap_hwoverlays_destroy(priv);\n\t\t\treturn ret;\n\t\t}\n\t\toverlay->idx = priv->num_ovls;\n\t\tpriv->overlays[priv->num_ovls++] = overlay;\n\t}\n\n\treturn 0;\n}\n\nvoid omap_hwoverlays_destroy(struct omap_drm_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->num_ovls; i++) {\n\t\tomap_overlay_destroy(priv->overlays[i]);\n\t\tpriv->overlays[i] = NULL;\n\t}\n\n\tpriv->num_ovls = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}