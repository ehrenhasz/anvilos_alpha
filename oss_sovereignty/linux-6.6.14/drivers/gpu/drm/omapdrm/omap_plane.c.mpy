{
  "module_name": "omap_plane.c",
  "hash_id": "2df89d2d976bbf88994210d7c1d199a68d99214da30be5276b8225f96671cc9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_plane.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"omap_dmm_tiler.h\"\n#include \"omap_drv.h\"\n\n \n\n#define to_omap_plane_state(x) container_of(x, struct omap_plane_state, base)\n\nstruct omap_plane_state {\n\t \n\tstruct drm_plane_state base;\n\n\tstruct omap_hw_overlay *overlay;\n\tstruct omap_hw_overlay *r_overlay;   \n};\n\n#define to_omap_plane(x) container_of(x, struct omap_plane, base)\n\nstruct omap_plane {\n\tstruct drm_plane base;\n\tenum omap_plane_id id;\n};\n\nbool is_omap_plane_dual_overlay(struct drm_plane_state *state)\n{\n\tstruct omap_plane_state *omap_state = to_omap_plane_state(state);\n\n\treturn !!omap_state->r_overlay;\n}\n\nstatic int omap_plane_prepare_fb(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *new_state)\n{\n\tif (!new_state->fb)\n\t\treturn 0;\n\n\tdrm_gem_plane_helper_prepare_fb(plane, new_state);\n\n\treturn omap_framebuffer_pin(new_state->fb);\n}\n\nstatic void omap_plane_cleanup_fb(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *old_state)\n{\n\tif (old_state->fb)\n\t\tomap_framebuffer_unpin(old_state->fb);\n}\n\nstatic void omap_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct omap_drm_private *priv = plane->dev->dev_private;\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct omap_plane_state *new_omap_state;\n\tstruct omap_plane_state *old_omap_state;\n\tstruct omap_overlay_info info, r_info;\n\tenum omap_plane_id ovl_id, r_ovl_id;\n\tint ret;\n\tbool dual_ovl;\n\n\tnew_omap_state = to_omap_plane_state(new_state);\n\told_omap_state = to_omap_plane_state(old_state);\n\n\tdual_ovl = is_omap_plane_dual_overlay(new_state);\n\n\t \n\tif (old_omap_state->overlay)\n\t\tomap_overlay_update_state(priv, old_omap_state->overlay);\n\tif (old_omap_state->r_overlay)\n\t\tomap_overlay_update_state(priv, old_omap_state->r_overlay);\n\n\tif (!new_omap_state->overlay) {\n\t\tDBG(\"[PLANE:%d:%s] no overlay attached\", plane->base.id, plane->name);\n\t\treturn;\n\t}\n\n\tovl_id = new_omap_state->overlay->id;\n\tDBG(\"%s, crtc=%p fb=%p\", plane->name, new_state->crtc,\n\t    new_state->fb);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.rotation_type = OMAP_DSS_ROT_NONE;\n\tinfo.rotation = DRM_MODE_ROTATE_0;\n\tinfo.global_alpha = new_state->alpha >> 8;\n\tinfo.zorder = new_state->normalized_zpos;\n\tif (new_state->pixel_blend_mode == DRM_MODE_BLEND_PREMULTI)\n\t\tinfo.pre_mult_alpha = 1;\n\telse\n\t\tinfo.pre_mult_alpha = 0;\n\tinfo.color_encoding = new_state->color_encoding;\n\tinfo.color_range = new_state->color_range;\n\n\tr_info = info;\n\n\t \n\tomap_framebuffer_update_scanout(new_state->fb, new_state, &info,\n\t\t\t\t\tdual_ovl ? &r_info : NULL);\n\n\tDBG(\"%s: %dx%d -> %dx%d (%d)\",\n\t\t\tnew_omap_state->overlay->name, info.width, info.height,\n\t\t\tinfo.out_width, info.out_height, info.screen_width);\n\tDBG(\"%d,%d %pad %pad\", info.pos_x, info.pos_y,\n\t\t\t&info.paddr, &info.p_uv_addr);\n\n\tif (dual_ovl) {\n\t\tr_ovl_id = new_omap_state->r_overlay->id;\n\t\t \n\t\tr_info.zorder = info.zorder + 1;\n\n\t\tDBG(\"%s: %dx%d -> %dx%d (%d)\",\n\t\t    new_omap_state->r_overlay->name,\n\t\t    r_info.width, r_info.height,\n\t\t    r_info.out_width, r_info.out_height, r_info.screen_width);\n\t\tDBG(\"%d,%d %pad %pad\", r_info.pos_x, r_info.pos_y,\n\t\t    &r_info.paddr, &r_info.p_uv_addr);\n\t}\n\n\t \n\tret = dispc_ovl_setup(priv->dispc, ovl_id, &info,\n\t\t\t      omap_crtc_timings(new_state->crtc), false,\n\t\t\t      omap_crtc_channel(new_state->crtc));\n\tif (ret) {\n\t\tdev_err(plane->dev->dev, \"Failed to setup plane %s\\n\",\n\t\t\tplane->name);\n\t\tdispc_ovl_enable(priv->dispc, ovl_id, false);\n\t\treturn;\n\t}\n\n\tdispc_ovl_enable(priv->dispc, ovl_id, true);\n\n\tif (dual_ovl) {\n\t\tret = dispc_ovl_setup(priv->dispc, r_ovl_id, &r_info,\n\t\t\t\t      omap_crtc_timings(new_state->crtc), false,\n\t\t\t\t      omap_crtc_channel(new_state->crtc));\n\t\tif (ret) {\n\t\t\tdev_err(plane->dev->dev, \"Failed to setup plane right-overlay %s\\n\",\n\t\t\t\tplane->name);\n\t\t\tdispc_ovl_enable(priv->dispc, r_ovl_id, false);\n\t\t\tdispc_ovl_enable(priv->dispc, ovl_id, false);\n\t\t\treturn;\n\t\t}\n\n\t\tdispc_ovl_enable(priv->dispc, r_ovl_id, true);\n\t}\n}\n\nstatic void omap_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct omap_drm_private *priv = plane->dev->dev_private;\n\tstruct omap_plane *omap_plane = to_omap_plane(plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct omap_plane_state *new_omap_state;\n\tstruct omap_plane_state *old_omap_state;\n\n\tnew_omap_state = to_omap_plane_state(new_state);\n\told_omap_state = to_omap_plane_state(old_state);\n\n\tif (!old_omap_state->overlay)\n\t\treturn;\n\n\tnew_state->rotation = DRM_MODE_ROTATE_0;\n\tnew_state->zpos = plane->type == DRM_PLANE_TYPE_PRIMARY ? 0 : omap_plane->id;\n\n\tomap_overlay_update_state(priv, old_omap_state->overlay);\n\tnew_omap_state->overlay = NULL;\n\n\tif (is_omap_plane_dual_overlay(old_state)) {\n\t\tomap_overlay_update_state(priv, old_omap_state->r_overlay);\n\t\tnew_omap_state->r_overlay = NULL;\n\t}\n}\n\n#define FRAC_16_16(mult, div)    (((mult) << 16) / (div))\n\nstatic int omap_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct omap_drm_private *priv = plane->dev->dev_private;\n\tstruct omap_plane_state *omap_state = to_omap_plane_state(new_plane_state);\n\tstruct omap_global_state *omap_overlay_global_state;\n\tstruct drm_crtc_state *crtc_state;\n\tbool new_r_hw_overlay = false;\n\tbool new_hw_overlay = false;\n\tu32 max_width, max_height;\n\tstruct drm_crtc *crtc;\n\tu16 width, height;\n\tu32 caps = 0;\n\tu32 fourcc;\n\tint ret;\n\n\tomap_overlay_global_state = omap_get_global_state(state);\n\tif (IS_ERR(omap_overlay_global_state))\n\t\treturn PTR_ERR(omap_overlay_global_state);\n\n\tdispc_ovl_get_max_size(priv->dispc, &width, &height);\n\tmax_width = width << 16;\n\tmax_height = height << 16;\n\n\tcrtc = new_plane_state->crtc ? new_plane_state->crtc : plane->state->crtc;\n\tif (!crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, crtc);\n\t \n\tif (WARN_ON(!crtc_state))\n\t\treturn 0;\n\n\t \n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  FRAC_16_16(1, 8), FRAC_16_16(8, 1),\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tDBG(\"%s: visible %d -> %d\", plane->name,\n\t    old_plane_state->visible, new_plane_state->visible);\n\n\tif (!new_plane_state->visible) {\n\t\tomap_overlay_release(state, omap_state->overlay);\n\t\tomap_overlay_release(state, omap_state->r_overlay);\n\t\tomap_state->overlay = NULL;\n\t\tomap_state->r_overlay = NULL;\n\t\treturn 0;\n\t}\n\n\tif (new_plane_state->crtc_x < 0 || new_plane_state->crtc_y < 0)\n\t\treturn -EINVAL;\n\n\tif (new_plane_state->crtc_x + new_plane_state->crtc_w > crtc_state->adjusted_mode.hdisplay)\n\t\treturn -EINVAL;\n\n\tif (new_plane_state->crtc_y + new_plane_state->crtc_h > crtc_state->adjusted_mode.vdisplay)\n\t\treturn -EINVAL;\n\n\t \n\tif (new_plane_state->src_h > max_height || new_plane_state->crtc_h > height)\n\t\treturn -EINVAL;\n\n\n\tif (new_plane_state->src_w > max_width || new_plane_state->crtc_w > width) {\n\t\tbool is_fourcc_yuv = new_plane_state->fb->format->is_yuv;\n\n\t\tif (is_fourcc_yuv && (((new_plane_state->src_w >> 16) / 2 & 1) ||\n\t\t\t\t      new_plane_state->crtc_w / 2 & 1)) {\n\t\t\t \n\t\t\tif (new_plane_state->src_w <= ((2 * width - 1) << 16) &&\n\t\t\t    new_plane_state->crtc_w <= (2 * width - 1))\n\t\t\t\tnew_r_hw_overlay = true;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (new_plane_state->src_w <= (2 * max_width) &&\n\t\t\t    new_plane_state->crtc_w <= (2 * width))\n\t\t\t\tnew_r_hw_overlay = true;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (new_plane_state->rotation != DRM_MODE_ROTATE_0 &&\n\t    !omap_framebuffer_supports_rotation(new_plane_state->fb))\n\t\treturn -EINVAL;\n\n\tif ((new_plane_state->src_w >> 16) != new_plane_state->crtc_w ||\n\t    (new_plane_state->src_h >> 16) != new_plane_state->crtc_h)\n\t\tcaps |= OMAP_DSS_OVL_CAP_SCALE;\n\n\tfourcc = new_plane_state->fb->format->format;\n\n\t \n\tif (!omap_state->overlay || (caps & ~omap_state->overlay->caps)) {\n\t\tnew_hw_overlay = true;\n\t} else {\n\t\t \n\t\tif (!dispc_ovl_color_mode_supported(priv->dispc, omap_state->overlay->id,\n\t\t\t\t\t\t    fourcc))\n\t\t\tnew_hw_overlay = true;\n\t}\n\n\t \n\tif ((new_r_hw_overlay && !omap_state->r_overlay) ||\n\t    (!new_r_hw_overlay && omap_state->r_overlay))\n\t\tnew_hw_overlay = true;\n\n\tif (new_hw_overlay) {\n\t\tstruct omap_hw_overlay *old_ovl = omap_state->overlay;\n\t\tstruct omap_hw_overlay *old_r_ovl = omap_state->r_overlay;\n\t\tstruct omap_hw_overlay *new_ovl = NULL;\n\t\tstruct omap_hw_overlay *new_r_ovl = NULL;\n\n\t\tomap_overlay_release(state, old_ovl);\n\t\tomap_overlay_release(state, old_r_ovl);\n\n\t\tret = omap_overlay_assign(state, plane, caps, fourcc, &new_ovl,\n\t\t\t\t\t  new_r_hw_overlay ? &new_r_ovl : NULL);\n\t\tif (ret) {\n\t\t\tDBG(\"%s: failed to assign hw_overlay\", plane->name);\n\t\t\tomap_state->overlay = NULL;\n\t\t\tomap_state->r_overlay = NULL;\n\t\t\treturn ret;\n\t\t}\n\n\t\tomap_state->overlay = new_ovl;\n\t\tif (new_r_hw_overlay)\n\t\t\tomap_state->r_overlay = new_r_ovl;\n\t\telse\n\t\t\tomap_state->r_overlay = NULL;\n\t}\n\n\tDBG(\"plane: %s overlay_id: %d\", plane->name, omap_state->overlay->id);\n\n\tif (omap_state->r_overlay)\n\t\tDBG(\"plane: %s r_overlay_id: %d\", plane->name, omap_state->r_overlay->id);\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_helper_funcs omap_plane_helper_funcs = {\n\t.prepare_fb = omap_plane_prepare_fb,\n\t.cleanup_fb = omap_plane_cleanup_fb,\n\t.atomic_check = omap_plane_atomic_check,\n\t.atomic_update = omap_plane_atomic_update,\n\t.atomic_disable = omap_plane_atomic_disable,\n};\n\nstatic void omap_plane_destroy(struct drm_plane *plane)\n{\n\tstruct omap_plane *omap_plane = to_omap_plane(plane);\n\n\tDBG(\"%s\", plane->name);\n\n\tdrm_plane_cleanup(plane);\n\n\tkfree(omap_plane);\n}\n\n \nvoid omap_plane_install_properties(struct drm_plane *plane,\n\t\tstruct drm_mode_object *obj)\n{\n\tstruct drm_device *dev = plane->dev;\n\tstruct omap_drm_private *priv = dev->dev_private;\n\n\tif (priv->has_dmm) {\n\t\tif (!plane->rotation_property)\n\t\t\tdrm_plane_create_rotation_property(plane,\n\t\t\t\t\t\t\t   DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t\t   DRM_MODE_ROTATE_0 | DRM_MODE_ROTATE_90 |\n\t\t\t\t\t\t\t   DRM_MODE_ROTATE_180 | DRM_MODE_ROTATE_270 |\n\t\t\t\t\t\t\t   DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y);\n\n\t\t \n\t\tif (plane->rotation_property && obj != &plane->base)\n\t\t\tdrm_object_attach_property(obj, plane->rotation_property,\n\t\t\t\t\t\t   DRM_MODE_ROTATE_0);\n\t}\n\n\tdrm_object_attach_property(obj, priv->zorder_prop, 0);\n}\n\nstatic void omap_plane_reset(struct drm_plane *plane)\n{\n\tstruct omap_plane_state *omap_state;\n\n\tif (plane->state)\n\t\tdrm_atomic_helper_plane_destroy_state(plane, plane->state);\n\n\tomap_state = kzalloc(sizeof(*omap_state), GFP_KERNEL);\n\tif (!omap_state)\n\t\treturn;\n\n\t__drm_atomic_helper_plane_reset(plane, &omap_state->base);\n}\n\nstatic struct drm_plane_state *\nomap_plane_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct omap_plane_state *state, *current_state;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tcurrent_state = to_omap_plane_state(plane->state);\n\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &state->base);\n\n\tstate->overlay = current_state->overlay;\n\tstate->r_overlay = current_state->r_overlay;\n\n\treturn &state->base;\n}\n\nstatic void omap_plane_atomic_print_state(struct drm_printer *p,\n\t\t\t\t\t  const struct drm_plane_state *state)\n{\n\tstruct omap_plane_state *omap_state = to_omap_plane_state(state);\n\n\tif (omap_state->overlay)\n\t\tdrm_printf(p, \"\\toverlay=%s (caps=0x%x)\\n\",\n\t\t\t   omap_state->overlay->name,\n\t\t\t   omap_state->overlay->caps);\n\telse\n\t\tdrm_printf(p, \"\\toverlay=None\\n\");\n\tif (omap_state->r_overlay)\n\t\tdrm_printf(p, \"\\tr_overlay=%s (caps=0x%x)\\n\",\n\t\t\t   omap_state->r_overlay->name,\n\t\t\t   omap_state->r_overlay->caps);\n\telse\n\t\tdrm_printf(p, \"\\tr_overlay=None\\n\");\n}\n\nstatic int omap_plane_atomic_set_property(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_plane_state *state,\n\t\t\t\t\t  struct drm_property *property,\n\t\t\t\t\t  u64 val)\n{\n\tstruct omap_drm_private *priv = plane->dev->dev_private;\n\n\tif (property == priv->zorder_prop)\n\t\tstate->zpos = val;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int omap_plane_atomic_get_property(struct drm_plane *plane,\n\t\t\t\t\t  const struct drm_plane_state *state,\n\t\t\t\t\t  struct drm_property *property,\n\t\t\t\t\t  u64 *val)\n{\n\tstruct omap_drm_private *priv = plane->dev->dev_private;\n\n\tif (property == priv->zorder_prop)\n\t\t*val = state->zpos;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs omap_plane_funcs = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.reset = omap_plane_reset,\n\t.destroy = omap_plane_destroy,\n\t.atomic_duplicate_state = omap_plane_atomic_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,\n\t.atomic_set_property = omap_plane_atomic_set_property,\n\t.atomic_get_property = omap_plane_atomic_get_property,\n\t.atomic_print_state = omap_plane_atomic_print_state,\n};\n\nstatic bool omap_plane_supports_yuv(struct drm_plane *plane)\n{\n\tstruct omap_drm_private *priv = plane->dev->dev_private;\n\tstruct omap_plane *omap_plane = to_omap_plane(plane);\n\tconst u32 *formats = dispc_ovl_get_color_modes(priv->dispc, omap_plane->id);\n\tu32 i;\n\n\tfor (i = 0; formats[i]; i++)\n\t\tif (formats[i] == DRM_FORMAT_YUYV ||\n\t\t    formats[i] == DRM_FORMAT_UYVY ||\n\t\t    formats[i] == DRM_FORMAT_NV12)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstruct drm_plane *omap_plane_init(struct drm_device *dev,\n\t\tint idx, enum drm_plane_type type,\n\t\tu32 possible_crtcs)\n{\n\tstruct omap_drm_private *priv = dev->dev_private;\n\tunsigned int num_planes = dispc_get_num_ovls(priv->dispc);\n\tstruct drm_plane *plane;\n\tstruct omap_plane *omap_plane;\n\tunsigned int zpos;\n\tint ret;\n\tu32 nformats;\n\tconst u32 *formats;\n\n\tif (WARN_ON(idx >= num_planes))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tomap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);\n\tif (!omap_plane)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tomap_plane->id = idx;\n\n\tDBG(\"%d: type=%d\", omap_plane->id, type);\n\tDBG(\"\tcrtc_mask: 0x%04x\", possible_crtcs);\n\n\tformats = dispc_ovl_get_color_modes(priv->dispc, omap_plane->id);\n\tfor (nformats = 0; formats[nformats]; ++nformats)\n\t\t;\n\n\tplane = &omap_plane->base;\n\n\tret = drm_universal_plane_init(dev, plane, possible_crtcs,\n\t\t\t\t       &omap_plane_funcs, formats,\n\t\t\t\t       nformats, NULL, type, NULL);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdrm_plane_helper_add(plane, &omap_plane_helper_funcs);\n\n\tomap_plane_install_properties(plane, &plane->base);\n\n\t \n\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\tzpos = 0;\n\telse\n\t\tzpos = omap_plane->id;\n\tdrm_plane_create_zpos_property(plane, zpos, 0, num_planes - 1);\n\tdrm_plane_create_alpha_property(plane);\n\tdrm_plane_create_blend_mode_property(plane, BIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\t\t     BIT(DRM_MODE_BLEND_COVERAGE));\n\n\tif (omap_plane_supports_yuv(plane))\n\t\tdrm_plane_create_color_properties(plane,\n\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT709),\n\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_FULL_RANGE) |\n\t\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE),\n\t\t\t\t\t\t  DRM_COLOR_YCBCR_BT601,\n\t\t\t\t\t\t  DRM_COLOR_YCBCR_FULL_RANGE);\n\n\treturn plane;\n\nerror:\n\tdev_err(dev->dev, \"%s(): could not create plane: %d\\n\",\n\t\t__func__, omap_plane->id);\n\n\tkfree(omap_plane);\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}