{
  "module_name": "base.c",
  "hash_id": "518d73b8b80b26bf6390c542ef46533dc489195880cbebca11f66f27a4a45fc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/base.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n\n#include \"dss.h\"\n#include \"omapdss.h\"\n\nstruct dispc_device *dispc_get_dispc(struct dss_device *dss)\n{\n\treturn dss->dispc;\n}\n\n \n\nstatic LIST_HEAD(omapdss_devices_list);\nstatic DEFINE_MUTEX(omapdss_devices_lock);\n\nvoid omapdss_device_register(struct omap_dss_device *dssdev)\n{\n\tmutex_lock(&omapdss_devices_lock);\n\tlist_add_tail(&dssdev->list, &omapdss_devices_list);\n\tmutex_unlock(&omapdss_devices_lock);\n}\n\nvoid omapdss_device_unregister(struct omap_dss_device *dssdev)\n{\n\tmutex_lock(&omapdss_devices_lock);\n\tlist_del(&dssdev->list);\n\tmutex_unlock(&omapdss_devices_lock);\n}\n\nstatic bool omapdss_device_is_registered(struct device_node *node)\n{\n\tstruct omap_dss_device *dssdev;\n\tbool found = false;\n\n\tmutex_lock(&omapdss_devices_lock);\n\n\tlist_for_each_entry(dssdev, &omapdss_devices_list, list) {\n\t\tif (dssdev->dev->of_node == node) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&omapdss_devices_lock);\n\treturn found;\n}\n\nstruct omap_dss_device *omapdss_device_get(struct omap_dss_device *dssdev)\n{\n\tif (get_device(dssdev->dev) == NULL)\n\t\treturn NULL;\n\n\treturn dssdev;\n}\n\nvoid omapdss_device_put(struct omap_dss_device *dssdev)\n{\n\tput_device(dssdev->dev);\n}\n\nstruct omap_dss_device *omapdss_find_device_by_node(struct device_node *node)\n{\n\tstruct omap_dss_device *dssdev;\n\n\tlist_for_each_entry(dssdev, &omapdss_devices_list, list) {\n\t\tif (dssdev->dev->of_node == node)\n\t\t\treturn omapdss_device_get(dssdev);\n\t}\n\n\treturn NULL;\n}\n\n \nstruct omap_dss_device *omapdss_device_next_output(struct omap_dss_device *from)\n{\n\tstruct omap_dss_device *dssdev;\n\tstruct list_head *list;\n\n\tmutex_lock(&omapdss_devices_lock);\n\n\tif (list_empty(&omapdss_devices_list)) {\n\t\tdssdev = NULL;\n\t\tgoto done;\n\t}\n\n\t \n\tlist = from ? &from->list : &omapdss_devices_list;\n\n\tlist_for_each_entry(dssdev, list, list) {\n\t\t \n\t\tif (&dssdev->list == &omapdss_devices_list) {\n\t\t\tdssdev = NULL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (dssdev->id && dssdev->bridge)\n\t\t\tgoto done;\n\t}\n\n\tdssdev = NULL;\n\ndone:\n\tif (from)\n\t\tomapdss_device_put(from);\n\tif (dssdev)\n\t\tomapdss_device_get(dssdev);\n\n\tmutex_unlock(&omapdss_devices_lock);\n\treturn dssdev;\n}\n\nstatic bool omapdss_device_is_connected(struct omap_dss_device *dssdev)\n{\n\treturn dssdev->dss;\n}\n\nint omapdss_device_connect(struct dss_device *dss,\n\t\t\t   struct omap_dss_device *src,\n\t\t\t   struct omap_dss_device *dst)\n{\n\tdev_dbg(&dss->pdev->dev, \"connect(%s, %s)\\n\",\n\t\tsrc ? dev_name(src->dev) : \"NULL\",\n\t\tdst ? dev_name(dst->dev) : \"NULL\");\n\n\tif (!dst) {\n\t\t \n\t\treturn src && src->bridge ? 0 : -EINVAL;\n\t}\n\n\tif (omapdss_device_is_connected(dst))\n\t\treturn -EBUSY;\n\n\tdst->dss = dss;\n\n\treturn 0;\n}\n\nvoid omapdss_device_disconnect(struct omap_dss_device *src,\n\t\t\t       struct omap_dss_device *dst)\n{\n\tstruct dss_device *dss = src ? src->dss : dst->dss;\n\n\tdev_dbg(&dss->pdev->dev, \"disconnect(%s, %s)\\n\",\n\t\tsrc ? dev_name(src->dev) : \"NULL\",\n\t\tdst ? dev_name(dst->dev) : \"NULL\");\n\n\tif (!dst) {\n\t\tWARN_ON(!src->bridge);\n\t\treturn;\n\t}\n\n\tif (!dst->id && !omapdss_device_is_connected(dst)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tdst->dss = NULL;\n}\n\n \n\nstatic struct list_head omapdss_comp_list;\n\nstruct omapdss_comp_node {\n\tstruct list_head list;\n\tstruct device_node *node;\n\tbool dss_core_component;\n\tconst char *compat;\n};\n\nstatic bool omapdss_list_contains(const struct device_node *node)\n{\n\tstruct omapdss_comp_node *comp;\n\n\tlist_for_each_entry(comp, &omapdss_comp_list, list) {\n\t\tif (comp->node == node)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void omapdss_walk_device(struct device *dev, struct device_node *node,\n\t\t\t\tbool dss_core)\n{\n\tstruct omapdss_comp_node *comp;\n\tstruct device_node *n;\n\tconst char *compat;\n\tint ret;\n\n\tret = of_property_read_string(node, \"compatible\", &compat);\n\tif (ret < 0)\n\t\treturn;\n\n\tcomp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);\n\tif (comp) {\n\t\tcomp->node = node;\n\t\tcomp->dss_core_component = dss_core;\n\t\tcomp->compat = compat;\n\t\tlist_add(&comp->list, &omapdss_comp_list);\n\t}\n\n\t \n\tn = of_get_child_by_name(node, \"ports\");\n\tif (!n)\n\t\tn = of_get_child_by_name(node, \"port\");\n\tif (!n)\n\t\treturn;\n\n\tof_node_put(n);\n\n\tn = NULL;\n\twhile ((n = of_graph_get_next_endpoint(node, n)) != NULL) {\n\t\tstruct device_node *pn = of_graph_get_remote_port_parent(n);\n\n\t\tif (!pn)\n\t\t\tcontinue;\n\n\t\tif (!of_device_is_available(pn) || omapdss_list_contains(pn)) {\n\t\t\tof_node_put(pn);\n\t\t\tcontinue;\n\t\t}\n\n\t\tomapdss_walk_device(dev, pn, false);\n\t}\n}\n\nvoid omapdss_gather_components(struct device *dev)\n{\n\tstruct device_node *child;\n\n\tINIT_LIST_HEAD(&omapdss_comp_list);\n\n\tomapdss_walk_device(dev, dev->of_node, true);\n\n\tfor_each_available_child_of_node(dev->of_node, child)\n\t\tomapdss_walk_device(dev, child, true);\n}\n\nstatic bool omapdss_component_is_loaded(struct omapdss_comp_node *comp)\n{\n\tif (comp->dss_core_component)\n\t\treturn true;\n\tif (!strstarts(comp->compat, \"omapdss,\"))\n\t\treturn true;\n\tif (omapdss_device_is_registered(comp->node))\n\t\treturn true;\n\n\treturn false;\n}\n\nbool omapdss_stack_is_ready(void)\n{\n\tstruct omapdss_comp_node *comp;\n\n\tlist_for_each_entry(comp, &omapdss_comp_list, list) {\n\t\tif (!omapdss_component_is_loaded(comp))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}