{
  "module_name": "hdmi_pll.c",
  "hash_id": "b30fe9b96732e1787e801592f07c5ef818c27d6340ea9f74b5bca8d3d9e6264f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/hdmi_pll.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"HDMIPLL\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/seq_file.h>\n#include <linux/pm_runtime.h>\n\n#include \"omapdss.h\"\n#include \"dss.h\"\n#include \"hdmi.h\"\n\nvoid hdmi_pll_dump(struct hdmi_pll_data *pll, struct seq_file *s)\n{\n#define DUMPPLL(r) seq_printf(s, \"%-35s %08x\\n\", #r,\\\n\t\thdmi_read_reg(pll->base, r))\n\n\tDUMPPLL(PLLCTRL_PLL_CONTROL);\n\tDUMPPLL(PLLCTRL_PLL_STATUS);\n\tDUMPPLL(PLLCTRL_PLL_GO);\n\tDUMPPLL(PLLCTRL_CFG1);\n\tDUMPPLL(PLLCTRL_CFG2);\n\tDUMPPLL(PLLCTRL_CFG3);\n\tDUMPPLL(PLLCTRL_SSC_CFG1);\n\tDUMPPLL(PLLCTRL_SSC_CFG2);\n\tDUMPPLL(PLLCTRL_CFG4);\n}\n\nstatic int hdmi_pll_enable(struct dss_pll *dsspll)\n{\n\tstruct hdmi_pll_data *pll = container_of(dsspll, struct hdmi_pll_data, pll);\n\tstruct hdmi_wp_data *wp = pll->wp;\n\tint r;\n\n\tr = pm_runtime_get_sync(&pll->pdev->dev);\n\tWARN_ON(r < 0);\n\n\tdss_ctrl_pll_enable(dsspll, true);\n\n\tr = hdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_BOTHON_ALLCLKS);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void hdmi_pll_disable(struct dss_pll *dsspll)\n{\n\tstruct hdmi_pll_data *pll = container_of(dsspll, struct hdmi_pll_data, pll);\n\tstruct hdmi_wp_data *wp = pll->wp;\n\tint r;\n\n\thdmi_wp_set_pll_pwr(wp, HDMI_PLLPWRCMD_ALLOFF);\n\n\tdss_ctrl_pll_enable(dsspll, false);\n\n\tr = pm_runtime_put_sync(&pll->pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic const struct dss_pll_ops hdmi_pll_ops = {\n\t.enable = hdmi_pll_enable,\n\t.disable = hdmi_pll_disable,\n\t.set_config = dss_pll_write_config_type_b,\n};\n\nstatic const struct dss_pll_hw dss_omap4_hdmi_pll_hw = {\n\t.type = DSS_PLL_TYPE_B,\n\n\t.n_max = 255,\n\t.m_min = 20,\n\t.m_max = 4095,\n\t.mX_max = 127,\n\t.fint_min = 500000,\n\t.fint_max = 2500000,\n\n\t.clkdco_min = 500000000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 2000000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 24,\n\t.mX_lsb[0] = 18,\n\n\t.has_selfreqdco = true,\n};\n\nstatic const struct dss_pll_hw dss_omap5_hdmi_pll_hw = {\n\t.type = DSS_PLL_TYPE_B,\n\n\t.n_max = 255,\n\t.m_min = 20,\n\t.m_max = 2045,\n\t.mX_max = 127,\n\t.fint_min = 620000,\n\t.fint_max = 2500000,\n\n\t.clkdco_min = 750000000,\n\t.clkdco_low = 1500000000,\n\t.clkdco_max = 2500000000UL,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 24,\n\t.mX_lsb[0] = 18,\n\n\t.has_selfreqdco = true,\n\t.has_refsel = true,\n};\n\nstatic int hdmi_init_pll_data(struct dss_device *dss,\n\t\t\t      struct platform_device *pdev,\n\t\t\t      struct hdmi_pll_data *hpll)\n{\n\tstruct dss_pll *pll = &hpll->pll;\n\tstruct clk *clk;\n\tint r;\n\n\tclk = devm_clk_get(&pdev->dev, \"sys_clk\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get sys_clk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpll->name = \"hdmi\";\n\tpll->id = DSS_PLL_HDMI;\n\tpll->base = hpll->base;\n\tpll->clkin = clk;\n\n\tif (hpll->wp->version == 4)\n\t\tpll->hw = &dss_omap4_hdmi_pll_hw;\n\telse\n\t\tpll->hw = &dss_omap5_hdmi_pll_hw;\n\n\tpll->ops = &hdmi_pll_ops;\n\n\tr = dss_pll_register(dss, pll);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint hdmi_pll_init(struct dss_device *dss, struct platform_device *pdev,\n\t\t  struct hdmi_pll_data *pll, struct hdmi_wp_data *wp)\n{\n\tint r;\n\n\tpll->pdev = pdev;\n\tpll->wp = wp;\n\n\tpll->base = devm_platform_ioremap_resource_byname(pdev, \"pll\");\n\tif (IS_ERR(pll->base))\n\t\treturn PTR_ERR(pll->base);\n\n\tr = hdmi_init_pll_data(dss, pdev, pll);\n\tif (r) {\n\t\tDSSERR(\"failed to init HDMI PLL\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nvoid hdmi_pll_uninit(struct hdmi_pll_data *hpll)\n{\n\tstruct dss_pll *pll = &hpll->pll;\n\n\tdss_pll_unregister(pll);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}