{
  "module_name": "venc.c",
  "hash_id": "d289443239a17d30692f554d27b6cb5aac8e3bcb4eff1643b25b18c610a1a424",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/venc.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"VENC\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/component.h>\n#include <linux/sys_soc.h>\n\n#include <drm/drm_bridge.h>\n\n#include \"omapdss.h\"\n#include \"dss.h\"\n\n \n#define VENC_REV_ID\t\t\t\t0x00\n#define VENC_STATUS\t\t\t\t0x04\n#define VENC_F_CONTROL\t\t\t\t0x08\n#define VENC_VIDOUT_CTRL\t\t\t0x10\n#define VENC_SYNC_CTRL\t\t\t\t0x14\n#define VENC_LLEN\t\t\t\t0x1C\n#define VENC_FLENS\t\t\t\t0x20\n#define VENC_HFLTR_CTRL\t\t\t\t0x24\n#define VENC_CC_CARR_WSS_CARR\t\t\t0x28\n#define VENC_C_PHASE\t\t\t\t0x2C\n#define VENC_GAIN_U\t\t\t\t0x30\n#define VENC_GAIN_V\t\t\t\t0x34\n#define VENC_GAIN_Y\t\t\t\t0x38\n#define VENC_BLACK_LEVEL\t\t\t0x3C\n#define VENC_BLANK_LEVEL\t\t\t0x40\n#define VENC_X_COLOR\t\t\t\t0x44\n#define VENC_M_CONTROL\t\t\t\t0x48\n#define VENC_BSTAMP_WSS_DATA\t\t\t0x4C\n#define VENC_S_CARR\t\t\t\t0x50\n#define VENC_LINE21\t\t\t\t0x54\n#define VENC_LN_SEL\t\t\t\t0x58\n#define VENC_L21__WC_CTL\t\t\t0x5C\n#define VENC_HTRIGGER_VTRIGGER\t\t\t0x60\n#define VENC_SAVID__EAVID\t\t\t0x64\n#define VENC_FLEN__FAL\t\t\t\t0x68\n#define VENC_LAL__PHASE_RESET\t\t\t0x6C\n#define VENC_HS_INT_START_STOP_X\t\t0x70\n#define VENC_HS_EXT_START_STOP_X\t\t0x74\n#define VENC_VS_INT_START_X\t\t\t0x78\n#define VENC_VS_INT_STOP_X__VS_INT_START_Y\t0x7C\n#define VENC_VS_INT_STOP_Y__VS_EXT_START_X\t0x80\n#define VENC_VS_EXT_STOP_X__VS_EXT_START_Y\t0x84\n#define VENC_VS_EXT_STOP_Y\t\t\t0x88\n#define VENC_AVID_START_STOP_X\t\t\t0x90\n#define VENC_AVID_START_STOP_Y\t\t\t0x94\n#define VENC_FID_INT_START_X__FID_INT_START_Y\t0xA0\n#define VENC_FID_INT_OFFSET_Y__FID_EXT_START_X\t0xA4\n#define VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y\t0xA8\n#define VENC_TVDETGP_INT_START_STOP_X\t\t0xB0\n#define VENC_TVDETGP_INT_START_STOP_Y\t\t0xB4\n#define VENC_GEN_CTRL\t\t\t\t0xB8\n#define VENC_OUTPUT_CONTROL\t\t\t0xC4\n#define VENC_OUTPUT_TEST\t\t\t0xC8\n#define VENC_DAC_B__DAC_C\t\t\t0xC8\n\nstruct venc_config {\n\tu32 f_control;\n\tu32 vidout_ctrl;\n\tu32 sync_ctrl;\n\tu32 llen;\n\tu32 flens;\n\tu32 hfltr_ctrl;\n\tu32 cc_carr_wss_carr;\n\tu32 c_phase;\n\tu32 gain_u;\n\tu32 gain_v;\n\tu32 gain_y;\n\tu32 black_level;\n\tu32 blank_level;\n\tu32 x_color;\n\tu32 m_control;\n\tu32 bstamp_wss_data;\n\tu32 s_carr;\n\tu32 line21;\n\tu32 ln_sel;\n\tu32 l21__wc_ctl;\n\tu32 htrigger_vtrigger;\n\tu32 savid__eavid;\n\tu32 flen__fal;\n\tu32 lal__phase_reset;\n\tu32 hs_int_start_stop_x;\n\tu32 hs_ext_start_stop_x;\n\tu32 vs_int_start_x;\n\tu32 vs_int_stop_x__vs_int_start_y;\n\tu32 vs_int_stop_y__vs_ext_start_x;\n\tu32 vs_ext_stop_x__vs_ext_start_y;\n\tu32 vs_ext_stop_y;\n\tu32 avid_start_stop_x;\n\tu32 avid_start_stop_y;\n\tu32 fid_int_start_x__fid_int_start_y;\n\tu32 fid_int_offset_y__fid_ext_start_x;\n\tu32 fid_ext_start_y__fid_ext_offset_y;\n\tu32 tvdetgp_int_start_stop_x;\n\tu32 tvdetgp_int_start_stop_y;\n\tu32 gen_ctrl;\n};\n\n \nstatic const struct venc_config venc_config_pal_trm = {\n\t.f_control\t\t\t\t= 0,\n\t.vidout_ctrl\t\t\t\t= 1,\n\t.sync_ctrl\t\t\t\t= 0x40,\n\t.llen\t\t\t\t\t= 0x35F,  \n\t.flens\t\t\t\t\t= 0x270,  \n\t.hfltr_ctrl\t\t\t\t= 0,\n\t.cc_carr_wss_carr\t\t\t= 0x2F7225ED,\n\t.c_phase\t\t\t\t= 0,\n\t.gain_u\t\t\t\t\t= 0x111,\n\t.gain_v\t\t\t\t\t= 0x181,\n\t.gain_y\t\t\t\t\t= 0x140,\n\t.black_level\t\t\t\t= 0x3B,\n\t.blank_level\t\t\t\t= 0x3B,\n\t.x_color\t\t\t\t= 0x7,\n\t.m_control\t\t\t\t= 0x2,\n\t.bstamp_wss_data\t\t\t= 0x3F,\n\t.s_carr\t\t\t\t\t= 0x2A098ACB,\n\t.line21\t\t\t\t\t= 0,\n\t.ln_sel\t\t\t\t\t= 0x01290015,\n\t.l21__wc_ctl\t\t\t\t= 0x0000F603,\n\t.htrigger_vtrigger\t\t\t= 0,\n\n\t.savid__eavid\t\t\t\t= 0x06A70108,\n\t.flen__fal\t\t\t\t= 0x00180270,\n\t.lal__phase_reset\t\t\t= 0x00040135,\n\t.hs_int_start_stop_x\t\t\t= 0x00880358,\n\t.hs_ext_start_stop_x\t\t\t= 0x000F035F,\n\t.vs_int_start_x\t\t\t\t= 0x01A70000,\n\t.vs_int_stop_x__vs_int_start_y\t\t= 0x000001A7,\n\t.vs_int_stop_y__vs_ext_start_x\t\t= 0x01AF0000,\n\t.vs_ext_stop_x__vs_ext_start_y\t\t= 0x000101AF,\n\t.vs_ext_stop_y\t\t\t\t= 0x00000025,\n\t.avid_start_stop_x\t\t\t= 0x03530083,\n\t.avid_start_stop_y\t\t\t= 0x026C002E,\n\t.fid_int_start_x__fid_int_start_y\t= 0x0001008A,\n\t.fid_int_offset_y__fid_ext_start_x\t= 0x002E0138,\n\t.fid_ext_start_y__fid_ext_offset_y\t= 0x01380001,\n\n\t.tvdetgp_int_start_stop_x\t\t= 0x00140001,\n\t.tvdetgp_int_start_stop_y\t\t= 0x00010001,\n\t.gen_ctrl\t\t\t\t= 0x00FF0000,\n};\n\n \nstatic const struct venc_config venc_config_ntsc_trm = {\n\t.f_control\t\t\t\t= 0,\n\t.vidout_ctrl\t\t\t\t= 1,\n\t.sync_ctrl\t\t\t\t= 0x8040,\n\t.llen\t\t\t\t\t= 0x359,\n\t.flens\t\t\t\t\t= 0x20C,\n\t.hfltr_ctrl\t\t\t\t= 0,\n\t.cc_carr_wss_carr\t\t\t= 0x043F2631,\n\t.c_phase\t\t\t\t= 0,\n\t.gain_u\t\t\t\t\t= 0x102,\n\t.gain_v\t\t\t\t\t= 0x16C,\n\t.gain_y\t\t\t\t\t= 0x12F,\n\t.black_level\t\t\t\t= 0x43,\n\t.blank_level\t\t\t\t= 0x38,\n\t.x_color\t\t\t\t= 0x7,\n\t.m_control\t\t\t\t= 0x1,\n\t.bstamp_wss_data\t\t\t= 0x38,\n\t.s_carr\t\t\t\t\t= 0x21F07C1F,\n\t.line21\t\t\t\t\t= 0,\n\t.ln_sel\t\t\t\t\t= 0x01310011,\n\t.l21__wc_ctl\t\t\t\t= 0x0000F003,\n\t.htrigger_vtrigger\t\t\t= 0,\n\n\t.savid__eavid\t\t\t\t= 0x069300F4,\n\t.flen__fal\t\t\t\t= 0x0016020C,\n\t.lal__phase_reset\t\t\t= 0x00060107,\n\t.hs_int_start_stop_x\t\t\t= 0x008E0350,\n\t.hs_ext_start_stop_x\t\t\t= 0x000F0359,\n\t.vs_int_start_x\t\t\t\t= 0x01A00000,\n\t.vs_int_stop_x__vs_int_start_y\t\t= 0x020701A0,\n\t.vs_int_stop_y__vs_ext_start_x\t\t= 0x01AC0024,\n\t.vs_ext_stop_x__vs_ext_start_y\t\t= 0x020D01AC,\n\t.vs_ext_stop_y\t\t\t\t= 0x00000006,\n\t.avid_start_stop_x\t\t\t= 0x03480078,\n\t.avid_start_stop_y\t\t\t= 0x02060024,\n\t.fid_int_start_x__fid_int_start_y\t= 0x0001008A,\n\t.fid_int_offset_y__fid_ext_start_x\t= 0x01AC0106,\n\t.fid_ext_start_y__fid_ext_offset_y\t= 0x01060006,\n\n\t.tvdetgp_int_start_stop_x\t\t= 0x00140001,\n\t.tvdetgp_int_start_stop_y\t\t= 0x00010001,\n\t.gen_ctrl\t\t\t\t= 0x00F90000,\n};\n\nenum venc_videomode {\n\tVENC_MODE_UNKNOWN,\n\tVENC_MODE_PAL,\n\tVENC_MODE_NTSC,\n};\n\nstatic const struct drm_display_mode omap_dss_pal_mode = {\n\t.hdisplay\t= 720,\n\t.hsync_start\t= 732,\n\t.hsync_end\t= 796,\n\t.htotal\t\t= 864,\n\t.vdisplay\t= 574,\n\t.vsync_start\t= 579,\n\t.vsync_end\t= 584,\n\t.vtotal\t\t= 625,\n\t.clock\t\t= 13500,\n\n\t.flags\t\t= DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_NHSYNC |\n\t\t\t  DRM_MODE_FLAG_NVSYNC,\n};\n\nstatic const struct drm_display_mode omap_dss_ntsc_mode = {\n\t.hdisplay\t= 720,\n\t.hsync_start\t= 736,\n\t.hsync_end\t= 800,\n\t.htotal\t\t= 858,\n\t.vdisplay\t= 482,\n\t.vsync_start\t= 488,\n\t.vsync_end\t= 494,\n\t.vtotal\t\t= 525,\n\t.clock\t\t= 13500,\n\n\t.flags\t\t= DRM_MODE_FLAG_INTERLACE | DRM_MODE_FLAG_NHSYNC |\n\t\t\t  DRM_MODE_FLAG_NVSYNC,\n};\n\nstruct venc_device {\n\tstruct platform_device *pdev;\n\tvoid __iomem *base;\n\tstruct regulator *vdda_dac_reg;\n\tstruct dss_device *dss;\n\n\tstruct dss_debugfs_entry *debugfs;\n\n\tstruct clk\t*tv_dac_clk;\n\n\tconst struct venc_config *config;\n\tenum omap_dss_venc_type type;\n\tbool invert_polarity;\n\tbool requires_tv_dac_clk;\n\n\tstruct omap_dss_device output;\n\tstruct drm_bridge bridge;\n};\n\n#define drm_bridge_to_venc(b) container_of(b, struct venc_device, bridge)\n\nstatic inline void venc_write_reg(struct venc_device *venc, int idx, u32 val)\n{\n\t__raw_writel(val, venc->base + idx);\n}\n\nstatic inline u32 venc_read_reg(struct venc_device *venc, int idx)\n{\n\tu32 l = __raw_readl(venc->base + idx);\n\treturn l;\n}\n\nstatic void venc_write_config(struct venc_device *venc,\n\t\t\t      const struct venc_config *config)\n{\n\tDSSDBG(\"write venc conf\\n\");\n\n\tvenc_write_reg(venc, VENC_LLEN, config->llen);\n\tvenc_write_reg(venc, VENC_FLENS, config->flens);\n\tvenc_write_reg(venc, VENC_CC_CARR_WSS_CARR, config->cc_carr_wss_carr);\n\tvenc_write_reg(venc, VENC_C_PHASE, config->c_phase);\n\tvenc_write_reg(venc, VENC_GAIN_U, config->gain_u);\n\tvenc_write_reg(venc, VENC_GAIN_V, config->gain_v);\n\tvenc_write_reg(venc, VENC_GAIN_Y, config->gain_y);\n\tvenc_write_reg(venc, VENC_BLACK_LEVEL, config->black_level);\n\tvenc_write_reg(venc, VENC_BLANK_LEVEL, config->blank_level);\n\tvenc_write_reg(venc, VENC_M_CONTROL, config->m_control);\n\tvenc_write_reg(venc, VENC_BSTAMP_WSS_DATA, config->bstamp_wss_data);\n\tvenc_write_reg(venc, VENC_S_CARR, config->s_carr);\n\tvenc_write_reg(venc, VENC_L21__WC_CTL, config->l21__wc_ctl);\n\tvenc_write_reg(venc, VENC_SAVID__EAVID, config->savid__eavid);\n\tvenc_write_reg(venc, VENC_FLEN__FAL, config->flen__fal);\n\tvenc_write_reg(venc, VENC_LAL__PHASE_RESET, config->lal__phase_reset);\n\tvenc_write_reg(venc, VENC_HS_INT_START_STOP_X,\n\t\t       config->hs_int_start_stop_x);\n\tvenc_write_reg(venc, VENC_HS_EXT_START_STOP_X,\n\t\t       config->hs_ext_start_stop_x);\n\tvenc_write_reg(venc, VENC_VS_INT_START_X, config->vs_int_start_x);\n\tvenc_write_reg(venc, VENC_VS_INT_STOP_X__VS_INT_START_Y,\n\t\t       config->vs_int_stop_x__vs_int_start_y);\n\tvenc_write_reg(venc, VENC_VS_INT_STOP_Y__VS_EXT_START_X,\n\t\t       config->vs_int_stop_y__vs_ext_start_x);\n\tvenc_write_reg(venc, VENC_VS_EXT_STOP_X__VS_EXT_START_Y,\n\t\t       config->vs_ext_stop_x__vs_ext_start_y);\n\tvenc_write_reg(venc, VENC_VS_EXT_STOP_Y, config->vs_ext_stop_y);\n\tvenc_write_reg(venc, VENC_AVID_START_STOP_X, config->avid_start_stop_x);\n\tvenc_write_reg(venc, VENC_AVID_START_STOP_Y, config->avid_start_stop_y);\n\tvenc_write_reg(venc, VENC_FID_INT_START_X__FID_INT_START_Y,\n\t\t       config->fid_int_start_x__fid_int_start_y);\n\tvenc_write_reg(venc, VENC_FID_INT_OFFSET_Y__FID_EXT_START_X,\n\t\t       config->fid_int_offset_y__fid_ext_start_x);\n\tvenc_write_reg(venc, VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y,\n\t\t       config->fid_ext_start_y__fid_ext_offset_y);\n\n\tvenc_write_reg(venc, VENC_DAC_B__DAC_C,\n\t\t       venc_read_reg(venc, VENC_DAC_B__DAC_C));\n\tvenc_write_reg(venc, VENC_VIDOUT_CTRL, config->vidout_ctrl);\n\tvenc_write_reg(venc, VENC_HFLTR_CTRL, config->hfltr_ctrl);\n\tvenc_write_reg(venc, VENC_X_COLOR, config->x_color);\n\tvenc_write_reg(venc, VENC_LINE21, config->line21);\n\tvenc_write_reg(venc, VENC_LN_SEL, config->ln_sel);\n\tvenc_write_reg(venc, VENC_HTRIGGER_VTRIGGER, config->htrigger_vtrigger);\n\tvenc_write_reg(venc, VENC_TVDETGP_INT_START_STOP_X,\n\t\t       config->tvdetgp_int_start_stop_x);\n\tvenc_write_reg(venc, VENC_TVDETGP_INT_START_STOP_Y,\n\t\t       config->tvdetgp_int_start_stop_y);\n\tvenc_write_reg(venc, VENC_GEN_CTRL, config->gen_ctrl);\n\tvenc_write_reg(venc, VENC_F_CONTROL, config->f_control);\n\tvenc_write_reg(venc, VENC_SYNC_CTRL, config->sync_ctrl);\n}\n\nstatic void venc_reset(struct venc_device *venc)\n{\n\tint t = 1000;\n\n\tvenc_write_reg(venc, VENC_F_CONTROL, 1<<8);\n\twhile (venc_read_reg(venc, VENC_F_CONTROL) & (1<<8)) {\n\t\tif (--t == 0) {\n\t\t\tDSSERR(\"Failed to reset venc\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n#ifdef CONFIG_OMAP2_DSS_SLEEP_AFTER_VENC_RESET\n\t \n\t \n\tmsleep(20);\n#endif\n}\n\nstatic int venc_runtime_get(struct venc_device *venc)\n{\n\tint r;\n\n\tDSSDBG(\"venc_runtime_get\\n\");\n\n\tr = pm_runtime_get_sync(&venc->pdev->dev);\n\tif (WARN_ON(r < 0)) {\n\t\tpm_runtime_put_noidle(&venc->pdev->dev);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void venc_runtime_put(struct venc_device *venc)\n{\n\tint r;\n\n\tDSSDBG(\"venc_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&venc->pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic int venc_power_on(struct venc_device *venc)\n{\n\tu32 l;\n\tint r;\n\n\tr = venc_runtime_get(venc);\n\tif (r)\n\t\tgoto err0;\n\n\tvenc_reset(venc);\n\tvenc_write_config(venc, venc->config);\n\n\tdss_set_venc_output(venc->dss, venc->type);\n\tdss_set_dac_pwrdn_bgz(venc->dss, 1);\n\n\tl = 0;\n\n\tif (venc->type == OMAP_DSS_VENC_TYPE_COMPOSITE)\n\t\tl |= 1 << 1;\n\telse  \n\t\tl |= (1 << 0) | (1 << 2);\n\n\tif (venc->invert_polarity == false)\n\t\tl |= 1 << 3;\n\n\tvenc_write_reg(venc, VENC_OUTPUT_CONTROL, l);\n\n\tr = regulator_enable(venc->vdda_dac_reg);\n\tif (r)\n\t\tgoto err1;\n\n\tr = dss_mgr_enable(&venc->output);\n\tif (r)\n\t\tgoto err2;\n\n\treturn 0;\n\nerr2:\n\tregulator_disable(venc->vdda_dac_reg);\nerr1:\n\tvenc_write_reg(venc, VENC_OUTPUT_CONTROL, 0);\n\tdss_set_dac_pwrdn_bgz(venc->dss, 0);\n\n\tvenc_runtime_put(venc);\nerr0:\n\treturn r;\n}\n\nstatic void venc_power_off(struct venc_device *venc)\n{\n\tvenc_write_reg(venc, VENC_OUTPUT_CONTROL, 0);\n\tdss_set_dac_pwrdn_bgz(venc->dss, 0);\n\n\tdss_mgr_disable(&venc->output);\n\n\tregulator_disable(venc->vdda_dac_reg);\n\n\tvenc_runtime_put(venc);\n}\n\nstatic enum venc_videomode venc_get_videomode(const struct drm_display_mode *mode)\n{\n\tif (!(mode->flags & DRM_MODE_FLAG_INTERLACE))\n\t\treturn VENC_MODE_UNKNOWN;\n\n\tif (mode->clock == omap_dss_pal_mode.clock &&\n\t    mode->hdisplay == omap_dss_pal_mode.hdisplay &&\n\t    mode->vdisplay == omap_dss_pal_mode.vdisplay)\n\t\treturn VENC_MODE_PAL;\n\n\tif (mode->clock == omap_dss_ntsc_mode.clock &&\n\t    mode->hdisplay == omap_dss_ntsc_mode.hdisplay &&\n\t    mode->vdisplay == omap_dss_ntsc_mode.vdisplay)\n\t\treturn VENC_MODE_NTSC;\n\n\treturn VENC_MODE_UNKNOWN;\n}\n\nstatic int venc_dump_regs(struct seq_file *s, void *p)\n{\n\tstruct venc_device *venc = s->private;\n\n#define DUMPREG(venc, r) \\\n\tseq_printf(s, \"%-35s %08x\\n\", #r, venc_read_reg(venc, r))\n\n\tif (venc_runtime_get(venc))\n\t\treturn 0;\n\n\tDUMPREG(venc, VENC_F_CONTROL);\n\tDUMPREG(venc, VENC_VIDOUT_CTRL);\n\tDUMPREG(venc, VENC_SYNC_CTRL);\n\tDUMPREG(venc, VENC_LLEN);\n\tDUMPREG(venc, VENC_FLENS);\n\tDUMPREG(venc, VENC_HFLTR_CTRL);\n\tDUMPREG(venc, VENC_CC_CARR_WSS_CARR);\n\tDUMPREG(venc, VENC_C_PHASE);\n\tDUMPREG(venc, VENC_GAIN_U);\n\tDUMPREG(venc, VENC_GAIN_V);\n\tDUMPREG(venc, VENC_GAIN_Y);\n\tDUMPREG(venc, VENC_BLACK_LEVEL);\n\tDUMPREG(venc, VENC_BLANK_LEVEL);\n\tDUMPREG(venc, VENC_X_COLOR);\n\tDUMPREG(venc, VENC_M_CONTROL);\n\tDUMPREG(venc, VENC_BSTAMP_WSS_DATA);\n\tDUMPREG(venc, VENC_S_CARR);\n\tDUMPREG(venc, VENC_LINE21);\n\tDUMPREG(venc, VENC_LN_SEL);\n\tDUMPREG(venc, VENC_L21__WC_CTL);\n\tDUMPREG(venc, VENC_HTRIGGER_VTRIGGER);\n\tDUMPREG(venc, VENC_SAVID__EAVID);\n\tDUMPREG(venc, VENC_FLEN__FAL);\n\tDUMPREG(venc, VENC_LAL__PHASE_RESET);\n\tDUMPREG(venc, VENC_HS_INT_START_STOP_X);\n\tDUMPREG(venc, VENC_HS_EXT_START_STOP_X);\n\tDUMPREG(venc, VENC_VS_INT_START_X);\n\tDUMPREG(venc, VENC_VS_INT_STOP_X__VS_INT_START_Y);\n\tDUMPREG(venc, VENC_VS_INT_STOP_Y__VS_EXT_START_X);\n\tDUMPREG(venc, VENC_VS_EXT_STOP_X__VS_EXT_START_Y);\n\tDUMPREG(venc, VENC_VS_EXT_STOP_Y);\n\tDUMPREG(venc, VENC_AVID_START_STOP_X);\n\tDUMPREG(venc, VENC_AVID_START_STOP_Y);\n\tDUMPREG(venc, VENC_FID_INT_START_X__FID_INT_START_Y);\n\tDUMPREG(venc, VENC_FID_INT_OFFSET_Y__FID_EXT_START_X);\n\tDUMPREG(venc, VENC_FID_EXT_START_Y__FID_EXT_OFFSET_Y);\n\tDUMPREG(venc, VENC_TVDETGP_INT_START_STOP_X);\n\tDUMPREG(venc, VENC_TVDETGP_INT_START_STOP_Y);\n\tDUMPREG(venc, VENC_GEN_CTRL);\n\tDUMPREG(venc, VENC_OUTPUT_CONTROL);\n\tDUMPREG(venc, VENC_OUTPUT_TEST);\n\n\tvenc_runtime_put(venc);\n\n#undef DUMPREG\n\treturn 0;\n}\n\nstatic int venc_get_clocks(struct venc_device *venc)\n{\n\tstruct clk *clk;\n\n\tif (venc->requires_tv_dac_clk) {\n\t\tclk = devm_clk_get(&venc->pdev->dev, \"tv_dac_clk\");\n\t\tif (IS_ERR(clk)) {\n\t\t\tDSSERR(\"can't get tv_dac_clk\\n\");\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t} else {\n\t\tclk = NULL;\n\t}\n\n\tvenc->tv_dac_clk = clk;\n\n\treturn 0;\n}\n\n \n\nstatic int venc_bridge_attach(struct drm_bridge *bridge,\n\t\t\t      enum drm_bridge_attach_flags flags)\n{\n\tstruct venc_device *venc = drm_bridge_to_venc(bridge);\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\treturn drm_bridge_attach(bridge->encoder, venc->output.next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic enum drm_mode_status\nvenc_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t       const struct drm_display_info *info,\n\t\t       const struct drm_display_mode *mode)\n{\n\tswitch (venc_get_videomode(mode)) {\n\tcase VENC_MODE_PAL:\n\tcase VENC_MODE_NTSC:\n\t\treturn MODE_OK;\n\n\tdefault:\n\t\treturn MODE_BAD;\n\t}\n}\n\nstatic bool venc_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *adjusted_mode)\n{\n\tconst struct drm_display_mode *venc_mode;\n\n\tswitch (venc_get_videomode(adjusted_mode)) {\n\tcase VENC_MODE_PAL:\n\t\tvenc_mode = &omap_dss_pal_mode;\n\t\tbreak;\n\n\tcase VENC_MODE_NTSC:\n\t\tvenc_mode = &omap_dss_ntsc_mode;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\tdrm_mode_copy(adjusted_mode, venc_mode);\n\tdrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\n\tdrm_mode_set_name(adjusted_mode);\n\n\treturn true;\n}\n\nstatic void venc_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t const struct drm_display_mode *adjusted_mode)\n{\n\tstruct venc_device *venc = drm_bridge_to_venc(bridge);\n\tenum venc_videomode venc_mode = venc_get_videomode(adjusted_mode);\n\n\tswitch (venc_mode) {\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tfallthrough;\n\tcase VENC_MODE_PAL:\n\t\tvenc->config = &venc_config_pal_trm;\n\t\tbreak;\n\n\tcase VENC_MODE_NTSC:\n\t\tvenc->config = &venc_config_ntsc_trm;\n\t\tbreak;\n\t}\n\n\tdispc_set_tv_pclk(venc->dss->dispc, 13500000);\n}\n\nstatic void venc_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct venc_device *venc = drm_bridge_to_venc(bridge);\n\n\tvenc_power_on(venc);\n}\n\nstatic void venc_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct venc_device *venc = drm_bridge_to_venc(bridge);\n\n\tvenc_power_off(venc);\n}\n\nstatic int venc_bridge_get_modes(struct drm_bridge *bridge,\n\t\t\t\t struct drm_connector *connector)\n{\n\tstatic const struct drm_display_mode *modes[] = {\n\t\t&omap_dss_pal_mode,\n\t\t&omap_dss_ntsc_mode,\n\t};\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(modes); ++i) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(connector->dev, modes[i]);\n\t\tif (!mode)\n\t\t\treturn i;\n\n\t\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_set_name(mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n\n\treturn ARRAY_SIZE(modes);\n}\n\nstatic const struct drm_bridge_funcs venc_bridge_funcs = {\n\t.attach = venc_bridge_attach,\n\t.mode_valid = venc_bridge_mode_valid,\n\t.mode_fixup = venc_bridge_mode_fixup,\n\t.mode_set = venc_bridge_mode_set,\n\t.enable = venc_bridge_enable,\n\t.disable = venc_bridge_disable,\n\t.get_modes = venc_bridge_get_modes,\n};\n\nstatic void venc_bridge_init(struct venc_device *venc)\n{\n\tvenc->bridge.funcs = &venc_bridge_funcs;\n\tvenc->bridge.of_node = venc->pdev->dev.of_node;\n\tvenc->bridge.ops = DRM_BRIDGE_OP_MODES;\n\tvenc->bridge.type = DRM_MODE_CONNECTOR_SVIDEO;\n\tvenc->bridge.interlace_allowed = true;\n\n\tdrm_bridge_add(&venc->bridge);\n}\n\nstatic void venc_bridge_cleanup(struct venc_device *venc)\n{\n\tdrm_bridge_remove(&venc->bridge);\n}\n\n \n\nstatic int venc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct dss_device *dss = dss_get_device(master);\n\tstruct venc_device *venc = dev_get_drvdata(dev);\n\tu8 rev_id;\n\tint r;\n\n\tvenc->dss = dss;\n\n\tr = venc_runtime_get(venc);\n\tif (r)\n\t\treturn r;\n\n\trev_id = (u8)(venc_read_reg(venc, VENC_REV_ID) & 0xff);\n\tdev_dbg(dev, \"OMAP VENC rev %d\\n\", rev_id);\n\n\tvenc_runtime_put(venc);\n\n\tvenc->debugfs = dss_debugfs_create_file(dss, \"venc\", venc_dump_regs,\n\t\t\t\t\t\tvenc);\n\n\treturn 0;\n}\n\nstatic void venc_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct venc_device *venc = dev_get_drvdata(dev);\n\n\tdss_debugfs_remove_file(venc->debugfs);\n}\n\nstatic const struct component_ops venc_component_ops = {\n\t.bind\t= venc_bind,\n\t.unbind\t= venc_unbind,\n};\n\n \n\nstatic int venc_init_output(struct venc_device *venc)\n{\n\tstruct omap_dss_device *out = &venc->output;\n\tint r;\n\n\tvenc_bridge_init(venc);\n\n\tout->dev = &venc->pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_VENC;\n\tout->type = OMAP_DISPLAY_TYPE_VENC;\n\tout->name = \"venc.0\";\n\tout->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;\n\tout->of_port = 0;\n\n\tr = omapdss_device_init_output(out, &venc->bridge);\n\tif (r < 0) {\n\t\tvenc_bridge_cleanup(venc);\n\t\treturn r;\n\t}\n\n\tomapdss_device_register(out);\n\n\treturn 0;\n}\n\nstatic void venc_uninit_output(struct venc_device *venc)\n{\n\tomapdss_device_unregister(&venc->output);\n\tomapdss_device_cleanup_output(&venc->output);\n\n\tvenc_bridge_cleanup(venc);\n}\n\nstatic int venc_probe_of(struct venc_device *venc)\n{\n\tstruct device_node *node = venc->pdev->dev.of_node;\n\tstruct device_node *ep;\n\tu32 channels;\n\tint r;\n\n\tep = of_graph_get_endpoint_by_regs(node, 0, 0);\n\tif (!ep)\n\t\treturn 0;\n\n\tvenc->invert_polarity = of_property_read_bool(ep, \"ti,invert-polarity\");\n\n\tr = of_property_read_u32(ep, \"ti,channels\", &channels);\n\tif (r) {\n\t\tdev_err(&venc->pdev->dev,\n\t\t\t\"failed to read property 'ti,channels': %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tswitch (channels) {\n\tcase 1:\n\t\tvenc->type = OMAP_DSS_VENC_TYPE_COMPOSITE;\n\t\tbreak;\n\tcase 2:\n\t\tvenc->type = OMAP_DSS_VENC_TYPE_SVIDEO;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&venc->pdev->dev, \"bad channel property '%d'\\n\",\n\t\t\tchannels);\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tof_node_put(ep);\n\n\treturn 0;\n\nerr:\n\tof_node_put(ep);\n\treturn r;\n}\n\nstatic const struct soc_device_attribute venc_soc_devices[] = {\n\t{ .machine = \"OMAP3[45]*\" },\n\t{ .machine = \"AM35*\" },\n\t{   }\n};\n\nstatic int venc_probe(struct platform_device *pdev)\n{\n\tstruct venc_device *venc;\n\tint r;\n\n\tvenc = kzalloc(sizeof(*venc), GFP_KERNEL);\n\tif (!venc)\n\t\treturn -ENOMEM;\n\n\tvenc->pdev = pdev;\n\n\tplatform_set_drvdata(pdev, venc);\n\n\t \n\tif (soc_device_match(venc_soc_devices))\n\t\tvenc->requires_tv_dac_clk = true;\n\n\tvenc->config = &venc_config_pal_trm;\n\n\tvenc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(venc->base)) {\n\t\tr = PTR_ERR(venc->base);\n\t\tgoto err_free;\n\t}\n\n\tvenc->vdda_dac_reg = devm_regulator_get(&pdev->dev, \"vdda\");\n\tif (IS_ERR(venc->vdda_dac_reg)) {\n\t\tr = PTR_ERR(venc->vdda_dac_reg);\n\t\tif (r != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDA_DAC regulator\\n\");\n\t\tgoto err_free;\n\t}\n\n\tr = venc_get_clocks(venc);\n\tif (r)\n\t\tgoto err_free;\n\n\tr = venc_probe_of(venc);\n\tif (r)\n\t\tgoto err_free;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tr = venc_init_output(venc);\n\tif (r)\n\t\tgoto err_pm_disable;\n\n\tr = component_add(&pdev->dev, &venc_component_ops);\n\tif (r)\n\t\tgoto err_uninit_output;\n\n\treturn 0;\n\nerr_uninit_output:\n\tvenc_uninit_output(venc);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nerr_free:\n\tkfree(venc);\n\treturn r;\n}\n\nstatic void venc_remove(struct platform_device *pdev)\n{\n\tstruct venc_device *venc = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &venc_component_ops);\n\n\tvenc_uninit_output(venc);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tkfree(venc);\n}\n\nstatic __maybe_unused int venc_runtime_suspend(struct device *dev)\n{\n\tstruct venc_device *venc = dev_get_drvdata(dev);\n\n\tif (venc->tv_dac_clk)\n\t\tclk_disable_unprepare(venc->tv_dac_clk);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int venc_runtime_resume(struct device *dev)\n{\n\tstruct venc_device *venc = dev_get_drvdata(dev);\n\n\tif (venc->tv_dac_clk)\n\t\tclk_prepare_enable(venc->tv_dac_clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops venc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(venc_runtime_suspend, venc_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n};\n\nstatic const struct of_device_id venc_of_match[] = {\n\t{ .compatible = \"ti,omap2-venc\", },\n\t{ .compatible = \"ti,omap3-venc\", },\n\t{ .compatible = \"ti,omap4-venc\", },\n\t{},\n};\n\nstruct platform_driver omap_venchw_driver = {\n\t.probe\t\t= venc_probe,\n\t.remove_new\t= venc_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_venc\",\n\t\t.pm\t= &venc_pm_ops,\n\t\t.of_match_table = venc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}