{
  "module_name": "pll.c",
  "hash_id": "2b8ab8535891e9794dca7e19b0dab09fb3c47210e4600cea5e01815b757978cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/pll.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"PLL\"\n\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sched.h>\n\n#include \"omapdss.h\"\n#include \"dss.h\"\n\n#define PLL_CONTROL\t\t\t0x0000\n#define PLL_STATUS\t\t\t0x0004\n#define PLL_GO\t\t\t\t0x0008\n#define PLL_CONFIGURATION1\t\t0x000C\n#define PLL_CONFIGURATION2\t\t0x0010\n#define PLL_CONFIGURATION3\t\t0x0014\n#define PLL_SSC_CONFIGURATION1\t\t0x0018\n#define PLL_SSC_CONFIGURATION2\t\t0x001C\n#define PLL_CONFIGURATION4\t\t0x0020\n\nint dss_pll_register(struct dss_device *dss, struct dss_pll *pll)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dss->plls); ++i) {\n\t\tif (!dss->plls[i]) {\n\t\t\tdss->plls[i] = pll;\n\t\t\tpll->dss = dss;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EBUSY;\n}\n\nvoid dss_pll_unregister(struct dss_pll *pll)\n{\n\tstruct dss_device *dss = pll->dss;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dss->plls); ++i) {\n\t\tif (dss->plls[i] == pll) {\n\t\t\tdss->plls[i] = NULL;\n\t\t\tpll->dss = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstruct dss_pll *dss_pll_find(struct dss_device *dss, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dss->plls); ++i) {\n\t\tif (dss->plls[i] && strcmp(dss->plls[i]->name, name) == 0)\n\t\t\treturn dss->plls[i];\n\t}\n\n\treturn NULL;\n}\n\nstruct dss_pll *dss_pll_find_by_src(struct dss_device *dss,\n\t\t\t\t    enum dss_clk_source src)\n{\n\tstruct dss_pll *pll;\n\n\tswitch (src) {\n\tdefault:\n\tcase DSS_CLK_SRC_FCK:\n\t\treturn NULL;\n\n\tcase DSS_CLK_SRC_HDMI_PLL:\n\t\treturn dss_pll_find(dss, \"hdmi\");\n\n\tcase DSS_CLK_SRC_PLL1_1:\n\tcase DSS_CLK_SRC_PLL1_2:\n\tcase DSS_CLK_SRC_PLL1_3:\n\t\tpll = dss_pll_find(dss, \"dsi0\");\n\t\tif (!pll)\n\t\t\tpll = dss_pll_find(dss, \"video0\");\n\t\treturn pll;\n\n\tcase DSS_CLK_SRC_PLL2_1:\n\tcase DSS_CLK_SRC_PLL2_2:\n\tcase DSS_CLK_SRC_PLL2_3:\n\t\tpll = dss_pll_find(dss, \"dsi1\");\n\t\tif (!pll)\n\t\t\tpll = dss_pll_find(dss, \"video1\");\n\t\treturn pll;\n\t}\n}\n\nunsigned int dss_pll_get_clkout_idx_for_src(enum dss_clk_source src)\n{\n\tswitch (src) {\n\tcase DSS_CLK_SRC_HDMI_PLL:\n\t\treturn 0;\n\n\tcase DSS_CLK_SRC_PLL1_1:\n\tcase DSS_CLK_SRC_PLL2_1:\n\t\treturn 0;\n\n\tcase DSS_CLK_SRC_PLL1_2:\n\tcase DSS_CLK_SRC_PLL2_2:\n\t\treturn 1;\n\n\tcase DSS_CLK_SRC_PLL1_3:\n\tcase DSS_CLK_SRC_PLL2_3:\n\t\treturn 2;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint dss_pll_enable(struct dss_pll *pll)\n{\n\tint r;\n\n\tr = clk_prepare_enable(pll->clkin);\n\tif (r)\n\t\treturn r;\n\n\tif (pll->regulator) {\n\t\tr = regulator_enable(pll->regulator);\n\t\tif (r)\n\t\t\tgoto err_reg;\n\t}\n\n\tr = pll->ops->enable(pll);\n\tif (r)\n\t\tgoto err_enable;\n\n\treturn 0;\n\nerr_enable:\n\tif (pll->regulator)\n\t\tregulator_disable(pll->regulator);\nerr_reg:\n\tclk_disable_unprepare(pll->clkin);\n\treturn r;\n}\n\nvoid dss_pll_disable(struct dss_pll *pll)\n{\n\tpll->ops->disable(pll);\n\n\tif (pll->regulator)\n\t\tregulator_disable(pll->regulator);\n\n\tclk_disable_unprepare(pll->clkin);\n\n\tmemset(&pll->cinfo, 0, sizeof(pll->cinfo));\n}\n\nint dss_pll_set_config(struct dss_pll *pll, const struct dss_pll_clock_info *cinfo)\n{\n\tint r;\n\n\tr = pll->ops->set_config(pll, cinfo);\n\tif (r)\n\t\treturn r;\n\n\tpll->cinfo = *cinfo;\n\n\treturn 0;\n}\n\nbool dss_pll_hsdiv_calc_a(const struct dss_pll *pll, unsigned long clkdco,\n\t\tunsigned long out_min, unsigned long out_max,\n\t\tdss_hsdiv_calc_func func, void *data)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tint m, m_start, m_stop;\n\tunsigned long out;\n\n\tout_min = out_min ? out_min : 1;\n\tout_max = out_max ? out_max : ULONG_MAX;\n\n\tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n\n\tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n\n\tfor (m = m_start; m <= m_stop; ++m) {\n\t\tout = clkdco / m;\n\n\t\tif (func(m, out, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nbool dss_pll_calc_a(const struct dss_pll *pll, unsigned long clkin,\n\t\tunsigned long pll_min, unsigned long pll_max,\n\t\tdss_pll_calc_func func, void *data)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tint n, n_start, n_stop, n_inc;\n\tint m, m_start, m_stop, m_inc;\n\tunsigned long fint, clkdco;\n\tunsigned long pll_hw_max;\n\tunsigned long fint_hw_min, fint_hw_max;\n\n\tpll_hw_max = hw->clkdco_max;\n\n\tfint_hw_min = hw->fint_min;\n\tfint_hw_max = hw->fint_max;\n\n\tn_start = max(DIV_ROUND_UP(clkin, fint_hw_max), 1ul);\n\tn_stop = min((unsigned)(clkin / fint_hw_min), hw->n_max);\n\tn_inc = 1;\n\n\tif (n_start > n_stop)\n\t\treturn false;\n\n\tif (hw->errata_i886) {\n\t\tswap(n_start, n_stop);\n\t\tn_inc = -1;\n\t}\n\n\tpll_max = pll_max ? pll_max : ULONG_MAX;\n\n\tfor (n = n_start; n != n_stop; n += n_inc) {\n\t\tfint = clkin / n;\n\n\t\tm_start = max(DIV_ROUND_UP(DIV_ROUND_UP(pll_min, fint), 2),\n\t\t\t\t1ul);\n\t\tm_stop = min3((unsigned)(pll_max / fint / 2),\n\t\t\t\t(unsigned)(pll_hw_max / fint / 2),\n\t\t\t\thw->m_max);\n\t\tm_inc = 1;\n\n\t\tif (m_start > m_stop)\n\t\t\tcontinue;\n\n\t\tif (hw->errata_i886) {\n\t\t\tswap(m_start, m_stop);\n\t\t\tm_inc = -1;\n\t\t}\n\n\t\tfor (m = m_start; m != m_stop; m += m_inc) {\n\t\t\tclkdco = 2 * m * fint;\n\n\t\t\tif (func(n, m, fint, clkdco, data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nbool dss_pll_calc_b(const struct dss_pll *pll, unsigned long clkin,\n\tunsigned long target_clkout, struct dss_pll_clock_info *cinfo)\n{\n\tunsigned long fint, clkdco, clkout;\n\tunsigned long target_clkdco;\n\tunsigned long min_dco;\n\tunsigned int n, m, mf, m2, sd;\n\tconst struct dss_pll_hw *hw = pll->hw;\n\n\tDSSDBG(\"clkin %lu, target clkout %lu\\n\", clkin, target_clkout);\n\n\t \n\tn = DIV_ROUND_UP(clkin, hw->fint_max);\n\tfint = clkin / n;\n\n\t \n\tmin_dco = roundup(hw->clkdco_min, fint);\n\tm2 = DIV_ROUND_UP(min_dco, target_clkout);\n\tif (m2 == 0)\n\t\tm2 = 1;\n\n\ttarget_clkdco = target_clkout * m2;\n\tm = target_clkdco / fint;\n\n\tclkdco = fint * m;\n\n\t \n\tif (WARN_ON(target_clkdco - clkdco > fint))\n\t\tmf = 0;\n\telse\n\t\tmf = (u32)div_u64(262144ull * (target_clkdco - clkdco), fint);\n\n\tif (mf > 0)\n\t\tclkdco += (u32)div_u64((u64)mf * fint, 262144);\n\n\tclkout = clkdco / m2;\n\n\t \n\tsd = DIV_ROUND_UP(fint * m, 250000000);\n\n\tDSSDBG(\"N = %u, M = %u, M.f = %u, M2 = %u, SD = %u\\n\",\n\t\tn, m, mf, m2, sd);\n\tDSSDBG(\"Fint %lu, clkdco %lu, clkout %lu\\n\", fint, clkdco, clkout);\n\n\tcinfo->n = n;\n\tcinfo->m = m;\n\tcinfo->mf = mf;\n\tcinfo->mX[0] = m2;\n\tcinfo->sd = sd;\n\n\tcinfo->fint = fint;\n\tcinfo->clkdco = clkdco;\n\tcinfo->clkout[0] = clkout;\n\n\treturn true;\n}\n\nstatic int wait_for_bit_change(void __iomem *reg, int bitnum, int value)\n{\n\tunsigned long timeout;\n\tktime_t wait;\n\tint t;\n\n\t \n\tt = 100;\n\twhile (t-- > 0) {\n\t\tif (FLD_GET(readl_relaxed(reg), bitnum, bitnum) == value)\n\t\t\treturn value;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (FLD_GET(readl_relaxed(reg), bitnum, bitnum) == value)\n\t\t\treturn value;\n\n\t\twait = ns_to_ktime(1000 * 1000);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\n\t}\n\n\treturn !value;\n}\n\nint dss_pll_wait_reset_done(struct dss_pll *pll)\n{\n\tvoid __iomem *base = pll->base;\n\n\tif (wait_for_bit_change(base + PLL_STATUS, 0, 1) != 1)\n\t\treturn -ETIMEDOUT;\n\telse\n\t\treturn 0;\n}\n\nstatic int dss_wait_hsdiv_ack(struct dss_pll *pll, u32 hsdiv_ack_mask)\n{\n\tint t = 100;\n\n\twhile (t-- > 0) {\n\t\tu32 v = readl_relaxed(pll->base + PLL_STATUS);\n\t\tv &= hsdiv_ack_mask;\n\t\tif (v == hsdiv_ack_mask)\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic bool pll_is_locked(u32 stat)\n{\n\t \n\treturn ((stat & 0x6f) == 0x3);\n}\n\nint dss_pll_write_config_type_a(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tvoid __iomem *base = pll->base;\n\tint r = 0;\n\tu32 l;\n\n\tl = 0;\n\tif (hw->has_stopmode)\n\t\tl = FLD_MOD(l, 1, 0, 0);\t\t \n\tl = FLD_MOD(l, cinfo->n - 1, hw->n_msb, hw->n_lsb);\t \n\tl = FLD_MOD(l, cinfo->m, hw->m_msb, hw->m_lsb);\t\t \n\t \n\tl = FLD_MOD(l, cinfo->mX[0] ? cinfo->mX[0] - 1 : 0,\n\t\t\thw->mX_msb[0], hw->mX_lsb[0]);\n\t \n\tl = FLD_MOD(l, cinfo->mX[1] ? cinfo->mX[1] - 1 : 0,\n\t\t\thw->mX_msb[1], hw->mX_lsb[1]);\n\twritel_relaxed(l, base + PLL_CONFIGURATION1);\n\n\tl = 0;\n\t \n\tl = FLD_MOD(l, cinfo->mX[2] ? cinfo->mX[2] - 1 : 0,\n\t\t\thw->mX_msb[2], hw->mX_lsb[2]);\n\t \n\tl = FLD_MOD(l, cinfo->mX[3] ? cinfo->mX[3] - 1 : 0,\n\t\t\thw->mX_msb[3], hw->mX_lsb[3]);\n\twritel_relaxed(l, base + PLL_CONFIGURATION3);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION2);\n\tif (hw->has_freqsel) {\n\t\tu32 f = cinfo->fint < 1000000 ? 0x3 :\n\t\t\tcinfo->fint < 1250000 ? 0x4 :\n\t\t\tcinfo->fint < 1500000 ? 0x5 :\n\t\t\tcinfo->fint < 1750000 ? 0x6 :\n\t\t\t0x7;\n\n\t\tl = FLD_MOD(l, f, 4, 1);\t \n\t} else if (hw->has_selfreqdco) {\n\t\tu32 f = cinfo->clkdco < hw->clkdco_low ? 0x2 : 0x4;\n\n\t\tl = FLD_MOD(l, f, 3, 1);\t \n\t}\n\tl = FLD_MOD(l, 1, 13, 13);\t\t \n\tl = FLD_MOD(l, 0, 14, 14);\t\t \n\tl = FLD_MOD(l, 0, 16, 16);\t\t \n\tl = FLD_MOD(l, 0, 18, 18);\t\t \n\tl = FLD_MOD(l, 1, 20, 20);\t\t \n\tif (hw->has_refsel)\n\t\tl = FLD_MOD(l, 3, 22, 21);\t \n\tl = FLD_MOD(l, 0, 23, 23);\t\t \n\tl = FLD_MOD(l, 0, 25, 25);\t\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION2);\n\n\tif (hw->errata_i932) {\n\t\tint cnt = 0;\n\t\tu32 sleep_time;\n\t\tconst u32 max_lock_retries = 20;\n\n\t\t \n\t\tsleep_time = DIV_ROUND_UP(1000*1000*1000, cinfo->fint);\n\n\t\tfor (cnt = 0; cnt < max_lock_retries; cnt++) {\n\t\t\twritel_relaxed(1, base + PLL_GO);\t \n\n\t\t\t \n\t\t\treadl_relaxed(base + PLL_GO);\n\n\t\t\tusleep_range(sleep_time, sleep_time + 5);\n\t\t\tl = readl_relaxed(base + PLL_STATUS);\n\n\t\t\tif (pll_is_locked(l) &&\n\t\t\t    !(readl_relaxed(base + PLL_GO) & 0x1))\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif (cnt == max_lock_retries) {\n\t\t\tDSSERR(\"cannot lock PLL\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\twritel_relaxed(1, base + PLL_GO);\t \n\n\t\tif (wait_for_bit_change(base + PLL_GO, 0, 0) != 0) {\n\t\t\tDSSERR(\"DSS DPLL GO bit not going down.\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (wait_for_bit_change(base + PLL_STATUS, 1, 1) != 1) {\n\t\t\tDSSERR(\"cannot lock DSS DPLL\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION2);\n\tl = FLD_MOD(l, 1, 14, 14);\t\t\t \n\tl = FLD_MOD(l, cinfo->mX[0] ? 1 : 0, 16, 16);\t \n\tl = FLD_MOD(l, cinfo->mX[1] ? 1 : 0, 18, 18);\t \n\tl = FLD_MOD(l, 0, 20, 20);\t\t\t \n\tl = FLD_MOD(l, cinfo->mX[2] ? 1 : 0, 23, 23);\t \n\tl = FLD_MOD(l, cinfo->mX[3] ? 1 : 0, 25, 25);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION2);\n\n\tr = dss_wait_hsdiv_ack(pll,\n\t\t(cinfo->mX[0] ? BIT(7) : 0) |\n\t\t(cinfo->mX[1] ? BIT(8) : 0) |\n\t\t(cinfo->mX[2] ? BIT(10) : 0) |\n\t\t(cinfo->mX[3] ? BIT(11) : 0));\n\tif (r) {\n\t\tDSSERR(\"failed to enable HSDIV clocks\\n\");\n\t\tgoto err;\n\t}\n\nerr:\n\treturn r;\n}\n\nint dss_pll_write_config_type_b(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tvoid __iomem *base = pll->base;\n\tu32 l;\n\n\tl = 0;\n\tl = FLD_MOD(l, cinfo->m, 20, 9);\t \n\tl = FLD_MOD(l, cinfo->n - 1, 8, 1);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION1);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION2);\n\tl = FLD_MOD(l, 0x0, 12, 12);\t \n\tl = FLD_MOD(l, 0x1, 13, 13);\t \n\tl = FLD_MOD(l, 0x0, 14, 14);\t \n\tif (hw->has_refsel)\n\t\tl = FLD_MOD(l, 0x3, 22, 21);\t \n\n\t \n\tif (cinfo->clkdco > hw->clkdco_low)\n\t\tl = FLD_MOD(l, 0x4, 3, 1);\n\telse\n\t\tl = FLD_MOD(l, 0x2, 3, 1);\n\twritel_relaxed(l, base + PLL_CONFIGURATION2);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION3);\n\tl = FLD_MOD(l, cinfo->sd, 17, 10);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION3);\n\n\tl = readl_relaxed(base + PLL_CONFIGURATION4);\n\tl = FLD_MOD(l, cinfo->mX[0], 24, 18);\t \n\tl = FLD_MOD(l, cinfo->mf, 17, 0);\t \n\twritel_relaxed(l, base + PLL_CONFIGURATION4);\n\n\twritel_relaxed(1, base + PLL_GO);\t \n\n\tif (wait_for_bit_change(base + PLL_GO, 0, 0) != 0) {\n\t\tDSSERR(\"DSS DPLL GO bit not going down.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (wait_for_bit_change(base + PLL_STATUS, 1, 1) != 1) {\n\t\tDSSERR(\"cannot lock DSS DPLL\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}