{
  "module_name": "hdmi4.c",
  "hash_id": "a2938bcb2cf1c4f312d42fe0775388ddc0e001d9064b73de4ae9bdf7384d1fb2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/hdmi4.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"HDMI\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/regulator/consumer.h>\n#include <linux/component.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <sound/omap-hdmi-audio.h>\n#include <media/cec.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_edid.h>\n\n#include \"omapdss.h\"\n#include \"hdmi4_core.h\"\n#include \"hdmi4_cec.h\"\n#include \"dss.h\"\n#include \"hdmi.h\"\n\nstatic int hdmi_runtime_get(struct omap_hdmi *hdmi)\n{\n\tint r;\n\n\tDSSDBG(\"hdmi_runtime_get\\n\");\n\n\tr = pm_runtime_get_sync(&hdmi->pdev->dev);\n\tif (WARN_ON(r < 0)) {\n\t\tpm_runtime_put_noidle(&hdmi->pdev->dev);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void hdmi_runtime_put(struct omap_hdmi *hdmi)\n{\n\tint r;\n\n\tDSSDBG(\"hdmi_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&hdmi->pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic irqreturn_t hdmi_irq_handler(int irq, void *data)\n{\n\tstruct omap_hdmi *hdmi = data;\n\tstruct hdmi_wp_data *wp = &hdmi->wp;\n\tu32 irqstatus;\n\n\tirqstatus = hdmi_wp_get_irqstatus(wp);\n\thdmi_wp_set_irqstatus(wp, irqstatus);\n\n\tif ((irqstatus & HDMI_IRQ_LINK_CONNECT) &&\n\t\t\tirqstatus & HDMI_IRQ_LINK_DISCONNECT) {\n\t\t \n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_OFF);\n\n\t\thdmi_wp_set_irqstatus(wp, HDMI_IRQ_LINK_CONNECT |\n\t\t\t\tHDMI_IRQ_LINK_DISCONNECT);\n\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);\n\t} else if (irqstatus & HDMI_IRQ_LINK_CONNECT) {\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_TXON);\n\t} else if (irqstatus & HDMI_IRQ_LINK_DISCONNECT) {\n\t\thdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);\n\t}\n\tif (irqstatus & HDMI_IRQ_CORE) {\n\t\tu32 intr4 = hdmi_read_reg(hdmi->core.base, HDMI_CORE_SYS_INTR4);\n\n\t\thdmi_write_reg(hdmi->core.base, HDMI_CORE_SYS_INTR4, intr4);\n\t\tif (intr4 & 8)\n\t\t\thdmi4_cec_irq(&hdmi->core);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hdmi_power_on_core(struct omap_hdmi *hdmi)\n{\n\tint r;\n\n\tif (hdmi->core.core_pwr_cnt++)\n\t\treturn 0;\n\n\tr = regulator_enable(hdmi->vdda_reg);\n\tif (r)\n\t\tgoto err_reg_enable;\n\n\tr = hdmi_runtime_get(hdmi);\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\thdmi4_core_powerdown_disable(&hdmi->core);\n\n\t \n\tdss_select_hdmi_venc_clk_source(hdmi->dss, DSS_HDMI_M_PCLK);\n\n\thdmi->core_enabled = true;\n\n\treturn 0;\n\nerr_runtime_get:\n\tregulator_disable(hdmi->vdda_reg);\nerr_reg_enable:\n\thdmi->core.core_pwr_cnt--;\n\n\treturn r;\n}\n\nstatic void hdmi_power_off_core(struct omap_hdmi *hdmi)\n{\n\tif (--hdmi->core.core_pwr_cnt)\n\t\treturn;\n\n\thdmi->core_enabled = false;\n\n\thdmi_runtime_put(hdmi);\n\tregulator_disable(hdmi->vdda_reg);\n}\n\nstatic int hdmi_power_on_full(struct omap_hdmi *hdmi)\n{\n\tint r;\n\tconst struct videomode *vm;\n\tstruct hdmi_wp_data *wp = &hdmi->wp;\n\tstruct dss_pll_clock_info hdmi_cinfo = { 0 };\n\tunsigned int pc;\n\n\tr = hdmi_power_on_core(hdmi);\n\tif (r)\n\t\treturn r;\n\n\t \n\thdmi_wp_clear_irqenable(wp, ~HDMI_IRQ_CORE);\n\thdmi_wp_set_irqstatus(wp, ~HDMI_IRQ_CORE);\n\n\tvm = &hdmi->cfg.vm;\n\n\tDSSDBG(\"hdmi_power_on hactive= %d vactive = %d\\n\", vm->hactive,\n\t       vm->vactive);\n\n\tpc = vm->pixelclock;\n\tif (vm->flags & DISPLAY_FLAGS_DOUBLECLK)\n\t\tpc *= 2;\n\n\t \n\tpc *= 10;\n\n\tdss_pll_calc_b(&hdmi->pll.pll, clk_get_rate(hdmi->pll.pll.clkin),\n\t\tpc, &hdmi_cinfo);\n\n\tr = dss_pll_enable(&hdmi->pll.pll);\n\tif (r) {\n\t\tDSSERR(\"Failed to enable PLL\\n\");\n\t\tgoto err_pll_enable;\n\t}\n\n\tr = dss_pll_set_config(&hdmi->pll.pll, &hdmi_cinfo);\n\tif (r) {\n\t\tDSSERR(\"Failed to configure PLL\\n\");\n\t\tgoto err_pll_cfg;\n\t}\n\n\tr = hdmi_phy_configure(&hdmi->phy, hdmi_cinfo.clkdco,\n\t\thdmi_cinfo.clkout[0]);\n\tif (r) {\n\t\tDSSDBG(\"Failed to configure PHY\\n\");\n\t\tgoto err_phy_cfg;\n\t}\n\n\tr = hdmi_wp_set_phy_pwr(wp, HDMI_PHYPWRCMD_LDOON);\n\tif (r)\n\t\tgoto err_phy_pwr;\n\n\thdmi4_configure(&hdmi->core, &hdmi->wp, &hdmi->cfg);\n\n\tr = dss_mgr_enable(&hdmi->output);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\tr = hdmi_wp_video_start(&hdmi->wp);\n\tif (r)\n\t\tgoto err_vid_enable;\n\n\thdmi_wp_set_irqenable(wp,\n\t\tHDMI_IRQ_LINK_CONNECT | HDMI_IRQ_LINK_DISCONNECT);\n\n\treturn 0;\n\nerr_vid_enable:\n\tdss_mgr_disable(&hdmi->output);\nerr_mgr_enable:\n\thdmi_wp_set_phy_pwr(&hdmi->wp, HDMI_PHYPWRCMD_OFF);\nerr_phy_pwr:\nerr_phy_cfg:\nerr_pll_cfg:\n\tdss_pll_disable(&hdmi->pll.pll);\nerr_pll_enable:\n\thdmi_power_off_core(hdmi);\n\treturn -EIO;\n}\n\nstatic void hdmi_power_off_full(struct omap_hdmi *hdmi)\n{\n\thdmi_wp_clear_irqenable(&hdmi->wp, ~HDMI_IRQ_CORE);\n\n\thdmi_wp_video_stop(&hdmi->wp);\n\n\tdss_mgr_disable(&hdmi->output);\n\n\thdmi_wp_set_phy_pwr(&hdmi->wp, HDMI_PHYPWRCMD_OFF);\n\n\tdss_pll_disable(&hdmi->pll.pll);\n\n\thdmi_power_off_core(hdmi);\n}\n\nstatic int hdmi_dump_regs(struct seq_file *s, void *p)\n{\n\tstruct omap_hdmi *hdmi = s->private;\n\n\tmutex_lock(&hdmi->lock);\n\n\tif (hdmi_runtime_get(hdmi)) {\n\t\tmutex_unlock(&hdmi->lock);\n\t\treturn 0;\n\t}\n\n\thdmi_wp_dump(&hdmi->wp, s);\n\thdmi_pll_dump(&hdmi->pll, s);\n\thdmi_phy_dump(&hdmi->phy, s);\n\thdmi4_core_dump(&hdmi->core, s);\n\n\thdmi_runtime_put(hdmi);\n\tmutex_unlock(&hdmi->lock);\n\treturn 0;\n}\n\nstatic void hdmi_start_audio_stream(struct omap_hdmi *hd)\n{\n\thdmi_wp_audio_enable(&hd->wp, true);\n\thdmi4_audio_start(&hd->core, &hd->wp);\n}\n\nstatic void hdmi_stop_audio_stream(struct omap_hdmi *hd)\n{\n\thdmi4_audio_stop(&hd->core, &hd->wp);\n\thdmi_wp_audio_enable(&hd->wp, false);\n}\n\nint hdmi4_core_enable(struct hdmi_core_data *core)\n{\n\tstruct omap_hdmi *hdmi = container_of(core, struct omap_hdmi, core);\n\tint r = 0;\n\n\tDSSDBG(\"ENTER omapdss_hdmi4_core_enable\\n\");\n\n\tmutex_lock(&hdmi->lock);\n\n\tr = hdmi_power_on_core(hdmi);\n\tif (r) {\n\t\tDSSERR(\"failed to power on device\\n\");\n\t\tgoto err0;\n\t}\n\n\tmutex_unlock(&hdmi->lock);\n\treturn 0;\n\nerr0:\n\tmutex_unlock(&hdmi->lock);\n\treturn r;\n}\n\nvoid hdmi4_core_disable(struct hdmi_core_data *core)\n{\n\tstruct omap_hdmi *hdmi = container_of(core, struct omap_hdmi, core);\n\n\tDSSDBG(\"Enter omapdss_hdmi4_core_disable\\n\");\n\n\tmutex_lock(&hdmi->lock);\n\n\thdmi_power_off_core(hdmi);\n\n\tmutex_unlock(&hdmi->lock);\n}\n\n \n\nstatic int hdmi4_bridge_attach(struct drm_bridge *bridge,\n\t\t\t       enum drm_bridge_attach_flags flags)\n{\n\tstruct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\treturn drm_bridge_attach(bridge->encoder, hdmi->output.next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic void hdmi4_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  const struct drm_display_mode *adjusted_mode)\n{\n\tstruct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);\n\n\tmutex_lock(&hdmi->lock);\n\n\tdrm_display_mode_to_videomode(adjusted_mode, &hdmi->cfg.vm);\n\n\tdispc_set_tv_pclk(hdmi->dss->dispc, adjusted_mode->clock * 1000);\n\n\tmutex_unlock(&hdmi->lock);\n}\n\nstatic void hdmi4_bridge_enable(struct drm_bridge *bridge,\n\t\t\t\tstruct drm_bridge_state *bridge_state)\n{\n\tstruct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc_state *crtc_state;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tif (WARN_ON(!connector))\n\t\treturn;\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tif (WARN_ON(!conn_state))\n\t\treturn;\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn;\n\n\thdmi->cfg.hdmi_dvi_mode = connector->display_info.is_hdmi\n\t\t\t\t? HDMI_HDMI : HDMI_DVI;\n\n\tif (connector->display_info.is_hdmi) {\n\t\tconst struct drm_display_mode *mode;\n\t\tstruct hdmi_avi_infoframe avi;\n\n\t\tmode = &crtc_state->adjusted_mode;\n\t\tret = drm_hdmi_avi_infoframe_from_display_mode(&avi, connector,\n\t\t\t\t\t\t\t       mode);\n\t\tif (ret == 0)\n\t\t\thdmi->cfg.infoframe = avi;\n\t}\n\n\tmutex_lock(&hdmi->lock);\n\n\tret = hdmi_power_on_full(hdmi);\n\tif (ret) {\n\t\tDSSERR(\"failed to power on device\\n\");\n\t\tgoto done;\n\t}\n\n\tif (hdmi->audio_configured) {\n\t\tret = hdmi4_audio_config(&hdmi->core, &hdmi->wp,\n\t\t\t\t\t &hdmi->audio_config,\n\t\t\t\t\t hdmi->cfg.vm.pixelclock);\n\t\tif (ret) {\n\t\t\tDSSERR(\"Error restoring audio configuration: %d\", ret);\n\t\t\thdmi->audio_abort_cb(&hdmi->pdev->dev);\n\t\t\thdmi->audio_configured = false;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&hdmi->audio_playing_lock, flags);\n\tif (hdmi->audio_configured && hdmi->audio_playing)\n\t\thdmi_start_audio_stream(hdmi);\n\thdmi->display_enabled = true;\n\tspin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);\n\ndone:\n\tmutex_unlock(&hdmi->lock);\n}\n\nstatic void hdmi4_bridge_disable(struct drm_bridge *bridge,\n\t\t\t\t struct drm_bridge_state *bridge_state)\n{\n\tstruct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);\n\tunsigned long flags;\n\n\tmutex_lock(&hdmi->lock);\n\n\tspin_lock_irqsave(&hdmi->audio_playing_lock, flags);\n\thdmi_stop_audio_stream(hdmi);\n\thdmi->display_enabled = false;\n\tspin_unlock_irqrestore(&hdmi->audio_playing_lock, flags);\n\n\thdmi_power_off_full(hdmi);\n\n\tmutex_unlock(&hdmi->lock);\n}\n\nstatic void hdmi4_bridge_hpd_notify(struct drm_bridge *bridge,\n\t\t\t\t    enum drm_connector_status status)\n{\n\tstruct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);\n\n\tif (status == connector_status_disconnected)\n\t\thdmi4_cec_set_phys_addr(&hdmi->core, CEC_PHYS_ADDR_INVALID);\n}\n\nstatic struct edid *hdmi4_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_connector *connector)\n{\n\tstruct omap_hdmi *hdmi = drm_bridge_to_hdmi(bridge);\n\tstruct edid *edid = NULL;\n\tunsigned int cec_addr;\n\tbool need_enable;\n\tint r;\n\n\tneed_enable = hdmi->core_enabled == false;\n\n\tif (need_enable) {\n\t\tr = hdmi4_core_enable(&hdmi->core);\n\t\tif (r)\n\t\t\treturn NULL;\n\t}\n\n\tmutex_lock(&hdmi->lock);\n\tr = hdmi_runtime_get(hdmi);\n\tBUG_ON(r);\n\n\tr = hdmi4_core_ddc_init(&hdmi->core);\n\tif (r)\n\t\tgoto done;\n\n\tedid = drm_do_get_edid(connector, hdmi4_core_ddc_read, &hdmi->core);\n\ndone:\n\thdmi_runtime_put(hdmi);\n\tmutex_unlock(&hdmi->lock);\n\n\tif (edid && edid->extensions) {\n\t\tunsigned int len = (edid->extensions + 1) * EDID_LENGTH;\n\n\t\tcec_addr = cec_get_edid_phys_addr((u8 *)edid, len, NULL);\n\t} else {\n\t\tcec_addr = CEC_PHYS_ADDR_INVALID;\n\t}\n\n\thdmi4_cec_set_phys_addr(&hdmi->core, cec_addr);\n\n\tif (need_enable)\n\t\thdmi4_core_disable(&hdmi->core);\n\n\treturn edid;\n}\n\nstatic const struct drm_bridge_funcs hdmi4_bridge_funcs = {\n\t.attach = hdmi4_bridge_attach,\n\t.mode_set = hdmi4_bridge_mode_set,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_enable = hdmi4_bridge_enable,\n\t.atomic_disable = hdmi4_bridge_disable,\n\t.hpd_notify = hdmi4_bridge_hpd_notify,\n\t.get_edid = hdmi4_bridge_get_edid,\n};\n\nstatic void hdmi4_bridge_init(struct omap_hdmi *hdmi)\n{\n\thdmi->bridge.funcs = &hdmi4_bridge_funcs;\n\thdmi->bridge.of_node = hdmi->pdev->dev.of_node;\n\thdmi->bridge.ops = DRM_BRIDGE_OP_EDID;\n\thdmi->bridge.type = DRM_MODE_CONNECTOR_HDMIA;\n\n\tdrm_bridge_add(&hdmi->bridge);\n}\n\nstatic void hdmi4_bridge_cleanup(struct omap_hdmi *hdmi)\n{\n\tdrm_bridge_remove(&hdmi->bridge);\n}\n\n \n\nstatic int hdmi_audio_startup(struct device *dev,\n\t\t\t      void (*abort_cb)(struct device *dev))\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\n\tmutex_lock(&hd->lock);\n\n\tWARN_ON(hd->audio_abort_cb != NULL);\n\n\thd->audio_abort_cb = abort_cb;\n\n\tmutex_unlock(&hd->lock);\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_shutdown(struct device *dev)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\n\tmutex_lock(&hd->lock);\n\thd->audio_abort_cb = NULL;\n\thd->audio_configured = false;\n\thd->audio_playing = false;\n\tmutex_unlock(&hd->lock);\n\n\treturn 0;\n}\n\nstatic int hdmi_audio_start(struct device *dev)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hd->audio_playing_lock, flags);\n\n\tif (hd->display_enabled) {\n\t\tif (!hdmi_mode_has_audio(&hd->cfg))\n\t\t\tDSSERR(\"%s: Video mode does not support audio\\n\",\n\t\t\t       __func__);\n\t\thdmi_start_audio_stream(hd);\n\t}\n\thd->audio_playing = true;\n\n\tspin_unlock_irqrestore(&hd->audio_playing_lock, flags);\n\treturn 0;\n}\n\nstatic void hdmi_audio_stop(struct device *dev)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tWARN_ON(!hdmi_mode_has_audio(&hd->cfg));\n\n\tspin_lock_irqsave(&hd->audio_playing_lock, flags);\n\n\tif (hd->display_enabled)\n\t\thdmi_stop_audio_stream(hd);\n\thd->audio_playing = false;\n\n\tspin_unlock_irqrestore(&hd->audio_playing_lock, flags);\n}\n\nstatic int hdmi_audio_config(struct device *dev,\n\t\t\t     struct omap_dss_audio *dss_audio)\n{\n\tstruct omap_hdmi *hd = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tmutex_lock(&hd->lock);\n\n\tif (hd->display_enabled) {\n\t\tret = hdmi4_audio_config(&hd->core, &hd->wp, dss_audio,\n\t\t\t\t\t hd->cfg.vm.pixelclock);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\thd->audio_configured = true;\n\thd->audio_config = *dss_audio;\nout:\n\tmutex_unlock(&hd->lock);\n\n\treturn ret;\n}\n\nstatic const struct omap_hdmi_audio_ops hdmi_audio_ops = {\n\t.audio_startup = hdmi_audio_startup,\n\t.audio_shutdown = hdmi_audio_shutdown,\n\t.audio_start = hdmi_audio_start,\n\t.audio_stop = hdmi_audio_stop,\n\t.audio_config = hdmi_audio_config,\n};\n\nstatic int hdmi_audio_register(struct omap_hdmi *hdmi)\n{\n\tstruct omap_hdmi_audio_pdata pdata = {\n\t\t.dev = &hdmi->pdev->dev,\n\t\t.version = 4,\n\t\t.audio_dma_addr = hdmi_wp_get_audio_dma_addr(&hdmi->wp),\n\t\t.ops = &hdmi_audio_ops,\n\t};\n\n\thdmi->audio_pdev = platform_device_register_data(\n\t\t&hdmi->pdev->dev, \"omap-hdmi-audio\", PLATFORM_DEVID_AUTO,\n\t\t&pdata, sizeof(pdata));\n\n\tif (IS_ERR(hdmi->audio_pdev))\n\t\treturn PTR_ERR(hdmi->audio_pdev);\n\n\treturn 0;\n}\n\n \n\nstatic int hdmi4_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct dss_device *dss = dss_get_device(master);\n\tstruct omap_hdmi *hdmi = dev_get_drvdata(dev);\n\tint r;\n\n\thdmi->dss = dss;\n\n\tr = hdmi_runtime_get(hdmi);\n\tif (r)\n\t\treturn r;\n\n\tr = hdmi_pll_init(dss, hdmi->pdev, &hdmi->pll, &hdmi->wp);\n\tif (r)\n\t\tgoto err_runtime_put;\n\n\tr = hdmi4_cec_init(hdmi->pdev, &hdmi->core, &hdmi->wp);\n\tif (r)\n\t\tgoto err_pll_uninit;\n\n\tr = hdmi_audio_register(hdmi);\n\tif (r) {\n\t\tDSSERR(\"Registering HDMI audio failed\\n\");\n\t\tgoto err_cec_uninit;\n\t}\n\n\thdmi->debugfs = dss_debugfs_create_file(dss, \"hdmi\", hdmi_dump_regs,\n\t\t\t\t\t       hdmi);\n\n\thdmi_runtime_put(hdmi);\n\n\treturn 0;\n\nerr_cec_uninit:\n\thdmi4_cec_uninit(&hdmi->core);\nerr_pll_uninit:\n\thdmi_pll_uninit(&hdmi->pll);\nerr_runtime_put:\n\thdmi_runtime_put(hdmi);\n\treturn r;\n}\n\nstatic void hdmi4_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct omap_hdmi *hdmi = dev_get_drvdata(dev);\n\n\tdss_debugfs_remove_file(hdmi->debugfs);\n\n\tif (hdmi->audio_pdev)\n\t\tplatform_device_unregister(hdmi->audio_pdev);\n\n\thdmi4_cec_uninit(&hdmi->core);\n\thdmi_pll_uninit(&hdmi->pll);\n}\n\nstatic const struct component_ops hdmi4_component_ops = {\n\t.bind\t= hdmi4_bind,\n\t.unbind\t= hdmi4_unbind,\n};\n\n \n\nstatic int hdmi4_init_output(struct omap_hdmi *hdmi)\n{\n\tstruct omap_dss_device *out = &hdmi->output;\n\tint r;\n\n\thdmi4_bridge_init(hdmi);\n\n\tout->dev = &hdmi->pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_HDMI;\n\tout->type = OMAP_DISPLAY_TYPE_HDMI;\n\tout->name = \"hdmi.0\";\n\tout->dispc_channel = OMAP_DSS_CHANNEL_DIGIT;\n\tout->of_port = 0;\n\n\tr = omapdss_device_init_output(out, &hdmi->bridge);\n\tif (r < 0) {\n\t\thdmi4_bridge_cleanup(hdmi);\n\t\treturn r;\n\t}\n\n\tomapdss_device_register(out);\n\n\treturn 0;\n}\n\nstatic void hdmi4_uninit_output(struct omap_hdmi *hdmi)\n{\n\tstruct omap_dss_device *out = &hdmi->output;\n\n\tomapdss_device_unregister(out);\n\tomapdss_device_cleanup_output(out);\n\n\thdmi4_bridge_cleanup(hdmi);\n}\n\nstatic int hdmi4_probe_of(struct omap_hdmi *hdmi)\n{\n\tstruct platform_device *pdev = hdmi->pdev;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device_node *ep;\n\tint r;\n\n\tep = of_graph_get_endpoint_by_regs(node, 0, 0);\n\tif (!ep)\n\t\treturn 0;\n\n\tr = hdmi_parse_lanes_of(pdev, ep, &hdmi->phy);\n\tof_node_put(ep);\n\treturn r;\n}\n\nstatic int hdmi4_probe(struct platform_device *pdev)\n{\n\tstruct omap_hdmi *hdmi;\n\tint irq;\n\tint r;\n\n\thdmi = kzalloc(sizeof(*hdmi), GFP_KERNEL);\n\tif (!hdmi)\n\t\treturn -ENOMEM;\n\n\thdmi->pdev = pdev;\n\n\tdev_set_drvdata(&pdev->dev, hdmi);\n\n\tmutex_init(&hdmi->lock);\n\tspin_lock_init(&hdmi->audio_playing_lock);\n\n\tr = hdmi4_probe_of(hdmi);\n\tif (r)\n\t\tgoto err_free;\n\n\tr = hdmi_wp_init(pdev, &hdmi->wp, 4);\n\tif (r)\n\t\tgoto err_free;\n\n\tr = hdmi_phy_init(pdev, &hdmi->phy, 4);\n\tif (r)\n\t\tgoto err_free;\n\n\tr = hdmi4_core_init(pdev, &hdmi->core);\n\tif (r)\n\t\tgoto err_free;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tDSSERR(\"platform_get_irq failed\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tr = devm_request_threaded_irq(&pdev->dev, irq,\n\t\t\tNULL, hdmi_irq_handler,\n\t\t\tIRQF_ONESHOT, \"OMAP HDMI\", hdmi);\n\tif (r) {\n\t\tDSSERR(\"HDMI IRQ request failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\thdmi->vdda_reg = devm_regulator_get(&pdev->dev, \"vdda\");\n\tif (IS_ERR(hdmi->vdda_reg)) {\n\t\tr = PTR_ERR(hdmi->vdda_reg);\n\t\tif (r != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDA regulator\\n\");\n\t\tgoto err_free;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tr = hdmi4_init_output(hdmi);\n\tif (r)\n\t\tgoto err_pm_disable;\n\n\tr = component_add(&pdev->dev, &hdmi4_component_ops);\n\tif (r)\n\t\tgoto err_uninit_output;\n\n\treturn 0;\n\nerr_uninit_output:\n\thdmi4_uninit_output(hdmi);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\nerr_free:\n\tkfree(hdmi);\n\treturn r;\n}\n\nstatic void hdmi4_remove(struct platform_device *pdev)\n{\n\tstruct omap_hdmi *hdmi = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &hdmi4_component_ops);\n\n\thdmi4_uninit_output(hdmi);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tkfree(hdmi);\n}\n\nstatic const struct of_device_id hdmi_of_match[] = {\n\t{ .compatible = \"ti,omap4-hdmi\", },\n\t{},\n};\n\nstruct platform_driver omapdss_hdmi4hw_driver = {\n\t.probe\t\t= hdmi4_probe,\n\t.remove_new\t= hdmi4_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_hdmi\",\n\t\t.of_match_table = hdmi_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}