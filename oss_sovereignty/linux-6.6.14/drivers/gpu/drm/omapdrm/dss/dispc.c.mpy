{
  "module_name": "dispc.c",
  "hash_id": "a014dab0ac27cdaee50f8d3ee5e33ecaeef5a0aba6d21758fa514b7e8309079a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/dispc.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DISPC\"\n\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/hardirq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/sizes.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/component.h>\n#include <linux/sys_soc.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_blend.h>\n\n#include \"omapdss.h\"\n#include \"dss.h\"\n#include \"dispc.h\"\n\nstruct dispc_device;\n\n \n#define DISPC_SZ_REGS\t\t\tSZ_4K\n\nenum omap_burst_size {\n\tBURST_SIZE_X2 = 0,\n\tBURST_SIZE_X4 = 1,\n\tBURST_SIZE_X8 = 2,\n};\n\n#define REG_GET(dispc, idx, start, end) \\\n\tFLD_GET(dispc_read_reg(dispc, idx), start, end)\n\n#define REG_FLD_MOD(dispc, idx, val, start, end)\t\t\t\\\n\tdispc_write_reg(dispc, idx, \\\n\t\t\tFLD_MOD(dispc_read_reg(dispc, idx), val, start, end))\n\n \nenum dispc_feature_id {\n\tFEAT_LCDENABLEPOL,\n\tFEAT_LCDENABLESIGNAL,\n\tFEAT_PCKFREEENABLE,\n\tFEAT_FUNCGATED,\n\tFEAT_MGR_LCD2,\n\tFEAT_MGR_LCD3,\n\tFEAT_LINEBUFFERSPLIT,\n\tFEAT_ROWREPEATENABLE,\n\tFEAT_RESIZECONF,\n\t \n\tFEAT_CORE_CLK_DIV,\n\tFEAT_HANDLE_UV_SEPARATE,\n\tFEAT_ATTR2,\n\tFEAT_CPR,\n\tFEAT_PRELOAD,\n\tFEAT_FIR_COEF_V,\n\tFEAT_ALPHA_FIXED_ZORDER,\n\tFEAT_ALPHA_FREE_ZORDER,\n\tFEAT_FIFO_MERGE,\n\t \n\tFEAT_OMAP3_DSI_FIFO_BUG,\n\tFEAT_BURST_2D,\n\tFEAT_MFLAG,\n};\n\nstruct dispc_features {\n\tu8 sw_start;\n\tu8 fp_start;\n\tu8 bp_start;\n\tu16 sw_max;\n\tu16 vp_max;\n\tu16 hp_max;\n\tu8 mgr_width_start;\n\tu8 mgr_height_start;\n\tu16 mgr_width_max;\n\tu16 mgr_height_max;\n\tu16 ovl_width_max;\n\tu16 ovl_height_max;\n\tunsigned long max_lcd_pclk;\n\tunsigned long max_tv_pclk;\n\tunsigned int max_downscale;\n\tunsigned int max_line_width;\n\tunsigned int min_pcd;\n\tint (*calc_scaling)(struct dispc_device *dispc,\n\t\tunsigned long pclk, unsigned long lclk,\n\t\tconst struct videomode *vm,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tu32 fourcc, bool *five_taps,\n\t\tint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\n\t\tu16 pos_x, unsigned long *core_clk, bool mem_to_mem);\n\tunsigned long (*calc_core_clk) (unsigned long pclk,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tbool mem_to_mem);\n\tu8 num_fifos;\n\tconst enum dispc_feature_id *features;\n\tunsigned int num_features;\n\tconst struct dss_reg_field *reg_fields;\n\tconst unsigned int num_reg_fields;\n\tconst enum omap_overlay_caps *overlay_caps;\n\tconst u32 **supported_color_modes;\n\tconst u32 *supported_scaler_color_modes;\n\tunsigned int num_mgrs;\n\tunsigned int num_ovls;\n\tunsigned int buffer_size_unit;\n\tunsigned int burst_size_unit;\n\n\t \n\tbool gfx_fifo_workaround:1;\n\n\t \n\tbool no_framedone_tv:1;\n\n\t \n\tbool mstandby_workaround:1;\n\n\tbool set_max_preload:1;\n\n\t \n\tbool last_pixel_inc_missing:1;\n\n\t \n\tbool supports_sync_align:1;\n\n\tbool has_writeback:1;\n\n\tbool supports_double_pixel:1;\n\n\t \n\tbool reverse_ilace_field_order:1;\n\n\tbool has_gamma_table:1;\n\n\tbool has_gamma_i734_bug:1;\n};\n\n#define DISPC_MAX_NR_FIFOS 5\n#define DISPC_MAX_CHANNEL_GAMMA 4\n\nstruct dispc_device {\n\tstruct platform_device *pdev;\n\tvoid __iomem    *base;\n\tstruct dss_device *dss;\n\n\tstruct dss_debugfs_entry *debugfs;\n\n\tint irq;\n\tirq_handler_t user_handler;\n\tvoid *user_data;\n\n\tunsigned long core_clk_rate;\n\tunsigned long tv_pclk_rate;\n\n\tu32 fifo_size[DISPC_MAX_NR_FIFOS];\n\t \n\tint fifo_assignment[DISPC_MAX_NR_FIFOS];\n\n\tbool\t\tctx_valid;\n\tu32\t\tctx[DISPC_SZ_REGS / sizeof(u32)];\n\n\tu32 *gamma_table[DISPC_MAX_CHANNEL_GAMMA];\n\n\tconst struct dispc_features *feat;\n\n\tbool is_enabled;\n\n\tstruct regmap *syscon_pol;\n\tu32 syscon_pol_offset;\n};\n\nenum omap_color_component {\n\t \n\tDISPC_COLOR_COMPONENT_RGB_Y\t\t= 1 << 0,\n\t \n\tDISPC_COLOR_COMPONENT_UV\t\t= 1 << 1,\n};\n\nenum mgr_reg_fields {\n\tDISPC_MGR_FLD_ENABLE,\n\tDISPC_MGR_FLD_STNTFT,\n\tDISPC_MGR_FLD_GO,\n\tDISPC_MGR_FLD_TFTDATALINES,\n\tDISPC_MGR_FLD_STALLMODE,\n\tDISPC_MGR_FLD_TCKENABLE,\n\tDISPC_MGR_FLD_TCKSELECTION,\n\tDISPC_MGR_FLD_CPR,\n\tDISPC_MGR_FLD_FIFOHANDCHECK,\n\t \n\tDISPC_MGR_FLD_NUM,\n};\n\n \nenum dispc_feat_reg_field {\n\tFEAT_REG_FIRHINC,\n\tFEAT_REG_FIRVINC,\n\tFEAT_REG_FIFOHIGHTHRESHOLD,\n\tFEAT_REG_FIFOLOWTHRESHOLD,\n\tFEAT_REG_FIFOSIZE,\n\tFEAT_REG_HORIZONTALACCU,\n\tFEAT_REG_VERTICALACCU,\n};\n\nstruct dispc_reg_field {\n\tu16 reg;\n\tu8 high;\n\tu8 low;\n};\n\nstruct dispc_gamma_desc {\n\tu32 len;\n\tu32 bits;\n\tu16 reg;\n\tbool has_index;\n};\n\nstatic const struct {\n\tconst char *name;\n\tu32 vsync_irq;\n\tu32 framedone_irq;\n\tu32 sync_lost_irq;\n\tstruct dispc_gamma_desc gamma;\n\tstruct dispc_reg_field reg_desc[DISPC_MGR_FLD_NUM];\n} mgr_desc[] = {\n\t[OMAP_DSS_CHANNEL_LCD] = {\n\t\t.name\t\t= \"LCD\",\n\t\t.vsync_irq\t= DISPC_IRQ_VSYNC,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONE,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST,\n\t\t.gamma\t\t= {\n\t\t\t.len\t= 256,\n\t\t\t.bits\t= 8,\n\t\t\t.reg\t= DISPC_GAMMA_TABLE0,\n\t\t\t.has_index = true,\n\t\t},\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL,  0,  0 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { DISPC_CONTROL,  3,  3 },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL,  5,  5 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { DISPC_CONTROL,  9,  8 },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { DISPC_CONTROL, 11, 11 },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG,  10, 10 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG,  11, 11 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { DISPC_CONFIG,  15, 15 },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG,  16, 16 },\n\t\t},\n\t},\n\t[OMAP_DSS_CHANNEL_DIGIT] = {\n\t\t.name\t\t= \"DIGIT\",\n\t\t.vsync_irq\t= DISPC_IRQ_EVSYNC_ODD | DISPC_IRQ_EVSYNC_EVEN,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONETV,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST_DIGIT,\n\t\t.gamma\t\t= {\n\t\t\t.len\t= 1024,\n\t\t\t.bits\t= 10,\n\t\t\t.reg\t= DISPC_GAMMA_TABLE2,\n\t\t\t.has_index = false,\n\t\t},\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL,  1,  1 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL,  6,  6 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG,  12, 12 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG,  13, 13 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG,  16, 16 },\n\t\t},\n\t},\n\t[OMAP_DSS_CHANNEL_LCD2] = {\n\t\t.name\t\t= \"LCD2\",\n\t\t.vsync_irq\t= DISPC_IRQ_VSYNC2,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONE2,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST2,\n\t\t.gamma\t\t= {\n\t\t\t.len\t= 256,\n\t\t\t.bits\t= 8,\n\t\t\t.reg\t= DISPC_GAMMA_TABLE1,\n\t\t\t.has_index = true,\n\t\t},\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL2,  0,  0 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { DISPC_CONTROL2,  3,  3 },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL2,  5,  5 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { DISPC_CONTROL2,  9,  8 },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { DISPC_CONTROL2, 11, 11 },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG2,  10, 10 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG2,  11, 11 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { DISPC_CONFIG2,  15, 15 },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG2,  16, 16 },\n\t\t},\n\t},\n\t[OMAP_DSS_CHANNEL_LCD3] = {\n\t\t.name\t\t= \"LCD3\",\n\t\t.vsync_irq\t= DISPC_IRQ_VSYNC3,\n\t\t.framedone_irq\t= DISPC_IRQ_FRAMEDONE3,\n\t\t.sync_lost_irq\t= DISPC_IRQ_SYNC_LOST3,\n\t\t.gamma\t\t= {\n\t\t\t.len\t= 256,\n\t\t\t.bits\t= 8,\n\t\t\t.reg\t= DISPC_GAMMA_TABLE3,\n\t\t\t.has_index = true,\n\t\t},\n\t\t.reg_desc\t= {\n\t\t\t[DISPC_MGR_FLD_ENABLE]\t\t= { DISPC_CONTROL3,  0,  0 },\n\t\t\t[DISPC_MGR_FLD_STNTFT]\t\t= { DISPC_CONTROL3,  3,  3 },\n\t\t\t[DISPC_MGR_FLD_GO]\t\t= { DISPC_CONTROL3,  5,  5 },\n\t\t\t[DISPC_MGR_FLD_TFTDATALINES]\t= { DISPC_CONTROL3,  9,  8 },\n\t\t\t[DISPC_MGR_FLD_STALLMODE]\t= { DISPC_CONTROL3, 11, 11 },\n\t\t\t[DISPC_MGR_FLD_TCKENABLE]\t= { DISPC_CONFIG3,  10, 10 },\n\t\t\t[DISPC_MGR_FLD_TCKSELECTION]\t= { DISPC_CONFIG3,  11, 11 },\n\t\t\t[DISPC_MGR_FLD_CPR]\t\t= { DISPC_CONFIG3,  15, 15 },\n\t\t\t[DISPC_MGR_FLD_FIFOHANDCHECK]\t= { DISPC_CONFIG3,  16, 16 },\n\t\t},\n\t},\n};\n\nstatic unsigned long dispc_fclk_rate(struct dispc_device *dispc);\nstatic unsigned long dispc_core_clk_rate(struct dispc_device *dispc);\nstatic unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_channel channel);\nstatic unsigned long dispc_mgr_pclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_channel channel);\n\nstatic unsigned long dispc_plane_pclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t   enum omap_plane_id plane);\nstatic unsigned long dispc_plane_lclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t   enum omap_plane_id plane);\n\nstatic inline void dispc_write_reg(struct dispc_device *dispc, u16 idx, u32 val)\n{\n\t__raw_writel(val, dispc->base + idx);\n}\n\nstatic inline u32 dispc_read_reg(struct dispc_device *dispc, u16 idx)\n{\n\treturn __raw_readl(dispc->base + idx);\n}\n\nstatic u32 mgr_fld_read(struct dispc_device *dispc, enum omap_channel channel,\n\t\t\tenum mgr_reg_fields regfld)\n{\n\tconst struct dispc_reg_field *rfld = &mgr_desc[channel].reg_desc[regfld];\n\n\treturn REG_GET(dispc, rfld->reg, rfld->high, rfld->low);\n}\n\nstatic void mgr_fld_write(struct dispc_device *dispc, enum omap_channel channel,\n\t\t\t  enum mgr_reg_fields regfld, int val)\n{\n\tconst struct dispc_reg_field *rfld = &mgr_desc[channel].reg_desc[regfld];\n\n\tREG_FLD_MOD(dispc, rfld->reg, val, rfld->high, rfld->low);\n}\n\nint dispc_get_num_ovls(struct dispc_device *dispc)\n{\n\treturn dispc->feat->num_ovls;\n}\n\nint dispc_get_num_mgrs(struct dispc_device *dispc)\n{\n\treturn dispc->feat->num_mgrs;\n}\n\nstatic void dispc_get_reg_field(struct dispc_device *dispc,\n\t\t\t\tenum dispc_feat_reg_field id,\n\t\t\t\tu8 *start, u8 *end)\n{\n\tBUG_ON(id >= dispc->feat->num_reg_fields);\n\n\t*start = dispc->feat->reg_fields[id].start;\n\t*end = dispc->feat->reg_fields[id].end;\n}\n\nstatic bool dispc_has_feature(struct dispc_device *dispc,\n\t\t\t      enum dispc_feature_id id)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < dispc->feat->num_features; i++) {\n\t\tif (dispc->feat->features[i] == id)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define SR(dispc, reg) \\\n\tdispc->ctx[DISPC_##reg / sizeof(u32)] = dispc_read_reg(dispc, DISPC_##reg)\n#define RR(dispc, reg) \\\n\tdispc_write_reg(dispc, DISPC_##reg, dispc->ctx[DISPC_##reg / sizeof(u32)])\n\nstatic void dispc_save_context(struct dispc_device *dispc)\n{\n\tint i, j;\n\n\tDSSDBG(\"dispc_save_context\\n\");\n\n\tSR(dispc, IRQENABLE);\n\tSR(dispc, CONTROL);\n\tSR(dispc, CONFIG);\n\tSR(dispc, LINE_NUMBER);\n\tif (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||\n\t\t\tdispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))\n\t\tSR(dispc, GLOBAL_ALPHA);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {\n\t\tSR(dispc, CONTROL2);\n\t\tSR(dispc, CONFIG2);\n\t}\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {\n\t\tSR(dispc, CONTROL3);\n\t\tSR(dispc, CONFIG3);\n\t}\n\n\tfor (i = 0; i < dispc_get_num_mgrs(dispc); i++) {\n\t\tSR(dispc, DEFAULT_COLOR(i));\n\t\tSR(dispc, TRANS_COLOR(i));\n\t\tSR(dispc, SIZE_MGR(i));\n\t\tif (i == OMAP_DSS_CHANNEL_DIGIT)\n\t\t\tcontinue;\n\t\tSR(dispc, TIMING_H(i));\n\t\tSR(dispc, TIMING_V(i));\n\t\tSR(dispc, POL_FREQ(i));\n\t\tSR(dispc, DIVISORo(i));\n\n\t\tSR(dispc, DATA_CYCLE1(i));\n\t\tSR(dispc, DATA_CYCLE2(i));\n\t\tSR(dispc, DATA_CYCLE3(i));\n\n\t\tif (dispc_has_feature(dispc, FEAT_CPR)) {\n\t\t\tSR(dispc, CPR_COEF_R(i));\n\t\t\tSR(dispc, CPR_COEF_G(i));\n\t\t\tSR(dispc, CPR_COEF_B(i));\n\t\t}\n\t}\n\n\tfor (i = 0; i < dispc_get_num_ovls(dispc); i++) {\n\t\tSR(dispc, OVL_BA0(i));\n\t\tSR(dispc, OVL_BA1(i));\n\t\tSR(dispc, OVL_POSITION(i));\n\t\tSR(dispc, OVL_SIZE(i));\n\t\tSR(dispc, OVL_ATTRIBUTES(i));\n\t\tSR(dispc, OVL_FIFO_THRESHOLD(i));\n\t\tSR(dispc, OVL_ROW_INC(i));\n\t\tSR(dispc, OVL_PIXEL_INC(i));\n\t\tif (dispc_has_feature(dispc, FEAT_PRELOAD))\n\t\t\tSR(dispc, OVL_PRELOAD(i));\n\t\tif (i == OMAP_DSS_GFX) {\n\t\t\tSR(dispc, OVL_WINDOW_SKIP(i));\n\t\t\tSR(dispc, OVL_TABLE_BA(i));\n\t\t\tcontinue;\n\t\t}\n\t\tSR(dispc, OVL_FIR(i));\n\t\tSR(dispc, OVL_PICTURE_SIZE(i));\n\t\tSR(dispc, OVL_ACCU0(i));\n\t\tSR(dispc, OVL_ACCU1(i));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tSR(dispc, OVL_FIR_COEF_H(i, j));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tSR(dispc, OVL_FIR_COEF_HV(i, j));\n\n\t\tfor (j = 0; j < 5; j++)\n\t\t\tSR(dispc, OVL_CONV_COEF(i, j));\n\n\t\tif (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(dispc, OVL_FIR_COEF_V(i, j));\n\t\t}\n\n\t\tif (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tSR(dispc, OVL_BA0_UV(i));\n\t\t\tSR(dispc, OVL_BA1_UV(i));\n\t\t\tSR(dispc, OVL_FIR2(i));\n\t\t\tSR(dispc, OVL_ACCU2_0(i));\n\t\t\tSR(dispc, OVL_ACCU2_1(i));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(dispc, OVL_FIR_COEF_H2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(dispc, OVL_FIR_COEF_HV2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tSR(dispc, OVL_FIR_COEF_V2(i, j));\n\t\t}\n\t\tif (dispc_has_feature(dispc, FEAT_ATTR2))\n\t\t\tSR(dispc, OVL_ATTRIBUTES2(i));\n\t}\n\n\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n\t\tSR(dispc, DIVISOR);\n\n\tdispc->ctx_valid = true;\n\n\tDSSDBG(\"context saved\\n\");\n}\n\nstatic void dispc_restore_context(struct dispc_device *dispc)\n{\n\tint i, j;\n\n\tDSSDBG(\"dispc_restore_context\\n\");\n\n\tif (!dispc->ctx_valid)\n\t\treturn;\n\n\t \n\t \n\tRR(dispc, CONFIG);\n\tRR(dispc, LINE_NUMBER);\n\tif (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||\n\t\t\tdispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))\n\t\tRR(dispc, GLOBAL_ALPHA);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2))\n\t\tRR(dispc, CONFIG2);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3))\n\t\tRR(dispc, CONFIG3);\n\n\tfor (i = 0; i < dispc_get_num_mgrs(dispc); i++) {\n\t\tRR(dispc, DEFAULT_COLOR(i));\n\t\tRR(dispc, TRANS_COLOR(i));\n\t\tRR(dispc, SIZE_MGR(i));\n\t\tif (i == OMAP_DSS_CHANNEL_DIGIT)\n\t\t\tcontinue;\n\t\tRR(dispc, TIMING_H(i));\n\t\tRR(dispc, TIMING_V(i));\n\t\tRR(dispc, POL_FREQ(i));\n\t\tRR(dispc, DIVISORo(i));\n\n\t\tRR(dispc, DATA_CYCLE1(i));\n\t\tRR(dispc, DATA_CYCLE2(i));\n\t\tRR(dispc, DATA_CYCLE3(i));\n\n\t\tif (dispc_has_feature(dispc, FEAT_CPR)) {\n\t\t\tRR(dispc, CPR_COEF_R(i));\n\t\t\tRR(dispc, CPR_COEF_G(i));\n\t\t\tRR(dispc, CPR_COEF_B(i));\n\t\t}\n\t}\n\n\tfor (i = 0; i < dispc_get_num_ovls(dispc); i++) {\n\t\tRR(dispc, OVL_BA0(i));\n\t\tRR(dispc, OVL_BA1(i));\n\t\tRR(dispc, OVL_POSITION(i));\n\t\tRR(dispc, OVL_SIZE(i));\n\t\tRR(dispc, OVL_ATTRIBUTES(i));\n\t\tRR(dispc, OVL_FIFO_THRESHOLD(i));\n\t\tRR(dispc, OVL_ROW_INC(i));\n\t\tRR(dispc, OVL_PIXEL_INC(i));\n\t\tif (dispc_has_feature(dispc, FEAT_PRELOAD))\n\t\t\tRR(dispc, OVL_PRELOAD(i));\n\t\tif (i == OMAP_DSS_GFX) {\n\t\t\tRR(dispc, OVL_WINDOW_SKIP(i));\n\t\t\tRR(dispc, OVL_TABLE_BA(i));\n\t\t\tcontinue;\n\t\t}\n\t\tRR(dispc, OVL_FIR(i));\n\t\tRR(dispc, OVL_PICTURE_SIZE(i));\n\t\tRR(dispc, OVL_ACCU0(i));\n\t\tRR(dispc, OVL_ACCU1(i));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tRR(dispc, OVL_FIR_COEF_H(i, j));\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tRR(dispc, OVL_FIR_COEF_HV(i, j));\n\n\t\tfor (j = 0; j < 5; j++)\n\t\t\tRR(dispc, OVL_CONV_COEF(i, j));\n\n\t\tif (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(dispc, OVL_FIR_COEF_V(i, j));\n\t\t}\n\n\t\tif (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tRR(dispc, OVL_BA0_UV(i));\n\t\t\tRR(dispc, OVL_BA1_UV(i));\n\t\t\tRR(dispc, OVL_FIR2(i));\n\t\t\tRR(dispc, OVL_ACCU2_0(i));\n\t\t\tRR(dispc, OVL_ACCU2_1(i));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(dispc, OVL_FIR_COEF_H2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(dispc, OVL_FIR_COEF_HV2(i, j));\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tRR(dispc, OVL_FIR_COEF_V2(i, j));\n\t\t}\n\t\tif (dispc_has_feature(dispc, FEAT_ATTR2))\n\t\t\tRR(dispc, OVL_ATTRIBUTES2(i));\n\t}\n\n\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n\t\tRR(dispc, DIVISOR);\n\n\t \n\tRR(dispc, CONTROL);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2))\n\t\tRR(dispc, CONTROL2);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3))\n\t\tRR(dispc, CONTROL3);\n\t \n\tdispc_clear_irqstatus(dispc, DISPC_IRQ_SYNC_LOST_DIGIT);\n\n\t \n\tRR(dispc, IRQENABLE);\n\n\tDSSDBG(\"context restored\\n\");\n}\n\n#undef SR\n#undef RR\n\nint dispc_runtime_get(struct dispc_device *dispc)\n{\n\tint r;\n\n\tDSSDBG(\"dispc_runtime_get\\n\");\n\n\tr = pm_runtime_get_sync(&dispc->pdev->dev);\n\tif (WARN_ON(r < 0)) {\n\t\tpm_runtime_put_noidle(&dispc->pdev->dev);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nvoid dispc_runtime_put(struct dispc_device *dispc)\n{\n\tint r;\n\n\tDSSDBG(\"dispc_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&dispc->pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nu32 dispc_mgr_get_vsync_irq(struct dispc_device *dispc,\n\t\t\t\t   enum omap_channel channel)\n{\n\treturn mgr_desc[channel].vsync_irq;\n}\n\nu32 dispc_mgr_get_framedone_irq(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel)\n{\n\tif (channel == OMAP_DSS_CHANNEL_DIGIT && dispc->feat->no_framedone_tv)\n\t\treturn 0;\n\n\treturn mgr_desc[channel].framedone_irq;\n}\n\nu32 dispc_mgr_get_sync_lost_irq(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel)\n{\n\treturn mgr_desc[channel].sync_lost_irq;\n}\n\nu32 dispc_wb_get_framedone_irq(struct dispc_device *dispc)\n{\n\treturn DISPC_IRQ_FRAMEDONEWB;\n}\n\nvoid dispc_mgr_enable(struct dispc_device *dispc,\n\t\t\t     enum omap_channel channel, bool enable)\n{\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_ENABLE, enable);\n\t \n\tmgr_fld_read(dispc, channel, DISPC_MGR_FLD_ENABLE);\n}\n\nstatic bool dispc_mgr_is_enabled(struct dispc_device *dispc,\n\t\t\t\t enum omap_channel channel)\n{\n\treturn !!mgr_fld_read(dispc, channel, DISPC_MGR_FLD_ENABLE);\n}\n\nbool dispc_mgr_go_busy(struct dispc_device *dispc,\n\t\t\t      enum omap_channel channel)\n{\n\treturn mgr_fld_read(dispc, channel, DISPC_MGR_FLD_GO) == 1;\n}\n\nvoid dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel)\n{\n\tWARN_ON(!dispc_mgr_is_enabled(dispc, channel));\n\tWARN_ON(dispc_mgr_go_busy(dispc, channel));\n\n\tDSSDBG(\"GO %s\\n\", mgr_desc[channel].name);\n\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_GO, 1);\n}\n\nbool dispc_wb_go_busy(struct dispc_device *dispc)\n{\n\treturn REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;\n}\n\nvoid dispc_wb_go(struct dispc_device *dispc)\n{\n\tenum omap_plane_id plane = OMAP_DSS_WB;\n\tbool enable, go;\n\n\tenable = REG_GET(dispc, DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;\n\n\tif (!enable)\n\t\treturn;\n\n\tgo = REG_GET(dispc, DISPC_CONTROL2, 6, 6) == 1;\n\tif (go) {\n\t\tDSSERR(\"GO bit not down for WB\\n\");\n\t\treturn;\n\t}\n\n\tREG_FLD_MOD(dispc, DISPC_CONTROL2, 1, 6, 6);\n}\n\nstatic void dispc_ovl_write_firh_reg(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane, int reg,\n\t\t\t\t     u32 value)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_FIR_COEF_H(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firhv_reg(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane, int reg,\n\t\t\t\t      u32 value)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_FIR_COEF_HV(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firv_reg(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane, int reg,\n\t\t\t\t     u32 value)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_FIR_COEF_V(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firh2_reg(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane, int reg,\n\t\t\t\t      u32 value)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_write_reg(dispc, DISPC_OVL_FIR_COEF_H2(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firhv2_reg(struct dispc_device *dispc,\n\t\t\t\t       enum omap_plane_id plane, int reg,\n\t\t\t\t       u32 value)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_write_reg(dispc, DISPC_OVL_FIR_COEF_HV2(plane, reg), value);\n}\n\nstatic void dispc_ovl_write_firv2_reg(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane, int reg,\n\t\t\t\t      u32 value)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_write_reg(dispc, DISPC_OVL_FIR_COEF_V2(plane, reg), value);\n}\n\nstatic void dispc_ovl_set_scale_coef(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane, int fir_hinc,\n\t\t\t\t     int fir_vinc, int five_taps,\n\t\t\t\t     enum omap_color_component color_comp)\n{\n\tconst struct dispc_coef *h_coef, *v_coef;\n\tint i;\n\n\th_coef = dispc_ovl_get_scale_coef(fir_hinc, true);\n\tv_coef = dispc_ovl_get_scale_coef(fir_vinc, five_taps);\n\n\tif (!h_coef || !v_coef) {\n\t\tdev_err(&dispc->pdev->dev, \"%s: failed to find scale coefs\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tu32 h, hv;\n\n\t\th = FLD_VAL(h_coef[i].hc0_vc00, 7, 0)\n\t\t\t| FLD_VAL(h_coef[i].hc1_vc0, 15, 8)\n\t\t\t| FLD_VAL(h_coef[i].hc2_vc1, 23, 16)\n\t\t\t| FLD_VAL(h_coef[i].hc3_vc2, 31, 24);\n\t\thv = FLD_VAL(h_coef[i].hc4_vc22, 7, 0)\n\t\t\t| FLD_VAL(v_coef[i].hc1_vc0, 15, 8)\n\t\t\t| FLD_VAL(v_coef[i].hc2_vc1, 23, 16)\n\t\t\t| FLD_VAL(v_coef[i].hc3_vc2, 31, 24);\n\n\t\tif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {\n\t\t\tdispc_ovl_write_firh_reg(dispc, plane, i, h);\n\t\t\tdispc_ovl_write_firhv_reg(dispc, plane, i, hv);\n\t\t} else {\n\t\t\tdispc_ovl_write_firh2_reg(dispc, plane, i, h);\n\t\t\tdispc_ovl_write_firhv2_reg(dispc, plane, i, hv);\n\t\t}\n\n\t}\n\n\tif (five_taps) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tu32 v;\n\t\t\tv = FLD_VAL(v_coef[i].hc0_vc00, 7, 0)\n\t\t\t\t| FLD_VAL(v_coef[i].hc4_vc22, 15, 8);\n\t\t\tif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y)\n\t\t\t\tdispc_ovl_write_firv_reg(dispc, plane, i, v);\n\t\t\telse\n\t\t\t\tdispc_ovl_write_firv2_reg(dispc, plane, i, v);\n\t\t}\n\t}\n}\n\nstruct csc_coef_yuv2rgb {\n\tint ry, rcb, rcr, gy, gcb, gcr, by, bcb, bcr;\n\tbool full_range;\n};\n\nstatic void dispc_ovl_write_color_conv_coef(struct dispc_device *dispc,\n\t\t\t\t\t    enum omap_plane_id plane,\n\t\t\t\t\t    const struct csc_coef_yuv2rgb *ct)\n{\n#define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))\n\n\tdispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));\n\tdispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy,  ct->rcb));\n\tdispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));\n\tdispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));\n\tdispc_write_reg(dispc, DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);\n\n#undef CVAL\n}\n\n \nstatic const struct csc_coef_yuv2rgb coefs_yuv2rgb_bt601_full = {\n\t256,   0,  358,\t\t \n\t256, -88, -182,\t\t \n\t256, 452,    0,\t\t \n\ttrue,\t\t\t \n};\n\n \nstatic const struct csc_coef_yuv2rgb coefs_yuv2rgb_bt601_lim = {\n\t298,    0,  409,\t \n\t298, -100, -208,\t \n\t298,  516,    0,\t \n\tfalse,\t\t\t \n};\n\n \nstatic const struct csc_coef_yuv2rgb coefs_yuv2rgb_bt709_full = {\n\t256,    0,  402,         \n\t256,  -48, -120,         \n\t256,  475,    0,         \n\ttrue,                    \n};\n\n \nstatic const struct csc_coef_yuv2rgb coefs_yuv2rgb_bt709_lim = {\n\t298,    0,  459,\t \n\t298,  -55, -136,\t \n\t298,  541,    0,\t \n\tfalse,\t\t\t \n};\n\nstatic void dispc_ovl_set_csc(struct dispc_device *dispc,\n\t\t\t      enum omap_plane_id plane,\n\t\t\t      enum drm_color_encoding color_encoding,\n\t\t\t      enum drm_color_range color_range)\n{\n\tconst struct csc_coef_yuv2rgb *csc;\n\n\tswitch (color_encoding) {\n\tdefault:\n\tcase DRM_COLOR_YCBCR_BT601:\n\t\tif (color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tcsc = &coefs_yuv2rgb_bt601_full;\n\t\telse\n\t\t\tcsc = &coefs_yuv2rgb_bt601_lim;\n\t\tbreak;\n\tcase DRM_COLOR_YCBCR_BT709:\n\t\tif (color_range == DRM_COLOR_YCBCR_FULL_RANGE)\n\t\t\tcsc = &coefs_yuv2rgb_bt709_full;\n\t\telse\n\t\t\tcsc = &coefs_yuv2rgb_bt709_lim;\n\t\tbreak;\n\t}\n\n\tdispc_ovl_write_color_conv_coef(dispc, plane, csc);\n}\n\nstatic void dispc_ovl_set_ba0(struct dispc_device *dispc,\n\t\t\t      enum omap_plane_id plane, u32 paddr)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_BA0(plane), paddr);\n}\n\nstatic void dispc_ovl_set_ba1(struct dispc_device *dispc,\n\t\t\t      enum omap_plane_id plane, u32 paddr)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_BA1(plane), paddr);\n}\n\nstatic void dispc_ovl_set_ba0_uv(struct dispc_device *dispc,\n\t\t\t\t enum omap_plane_id plane, u32 paddr)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_BA0_UV(plane), paddr);\n}\n\nstatic void dispc_ovl_set_ba1_uv(struct dispc_device *dispc,\n\t\t\t\t enum omap_plane_id plane, u32 paddr)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_BA1_UV(plane), paddr);\n}\n\nstatic void dispc_ovl_set_pos(struct dispc_device *dispc,\n\t\t\t      enum omap_plane_id plane,\n\t\t\t      enum omap_overlay_caps caps, int x, int y)\n{\n\tu32 val;\n\n\tif ((caps & OMAP_DSS_OVL_CAP_POS) == 0)\n\t\treturn;\n\n\tval = FLD_VAL(y, 26, 16) | FLD_VAL(x, 10, 0);\n\n\tdispc_write_reg(dispc, DISPC_OVL_POSITION(plane), val);\n}\n\nstatic void dispc_ovl_set_input_size(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane, int width,\n\t\t\t\t     int height)\n{\n\tu32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);\n\n\tif (plane == OMAP_DSS_GFX || plane == OMAP_DSS_WB)\n\t\tdispc_write_reg(dispc, DISPC_OVL_SIZE(plane), val);\n\telse\n\t\tdispc_write_reg(dispc, DISPC_OVL_PICTURE_SIZE(plane), val);\n}\n\nstatic void dispc_ovl_set_output_size(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane, int width,\n\t\t\t\t      int height)\n{\n\tu32 val;\n\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tval = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);\n\n\tif (plane == OMAP_DSS_WB)\n\t\tdispc_write_reg(dispc, DISPC_OVL_PICTURE_SIZE(plane), val);\n\telse\n\t\tdispc_write_reg(dispc, DISPC_OVL_SIZE(plane), val);\n}\n\nstatic void dispc_ovl_set_zorder(struct dispc_device *dispc,\n\t\t\t\t enum omap_plane_id plane,\n\t\t\t\t enum omap_overlay_caps caps, u8 zorder)\n{\n\tif ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\n\t\treturn;\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);\n}\n\nstatic void dispc_ovl_enable_zorder_planes(struct dispc_device *dispc)\n{\n\tint i;\n\n\tif (!dispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))\n\t\treturn;\n\n\tfor (i = 0; i < dispc_get_num_ovls(dispc); i++)\n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);\n}\n\nstatic void dispc_ovl_set_pre_mult_alpha(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_plane_id plane,\n\t\t\t\t\t enum omap_overlay_caps caps,\n\t\t\t\t\t bool enable)\n{\n\tif ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)\n\t\treturn;\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);\n}\n\nstatic void dispc_ovl_setup_global_alpha(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_plane_id plane,\n\t\t\t\t\t enum omap_overlay_caps caps,\n\t\t\t\t\t u8 global_alpha)\n{\n\tstatic const unsigned int shifts[] = { 0, 8, 16, 24, };\n\tint shift;\n\n\tif ((caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\n\t\treturn;\n\n\tshift = shifts[plane];\n\tREG_FLD_MOD(dispc, DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);\n}\n\nstatic void dispc_ovl_set_pix_inc(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane, s32 inc)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_PIXEL_INC(plane), inc);\n}\n\nstatic void dispc_ovl_set_row_inc(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane, s32 inc)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_ROW_INC(plane), inc);\n}\n\nstatic void dispc_ovl_set_color_mode(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane, u32 fourcc)\n{\n\tu32 m = 0;\n\tif (plane != OMAP_DSS_GFX) {\n\t\tswitch (fourcc) {\n\t\tcase DRM_FORMAT_NV12:\n\t\t\tm = 0x0; break;\n\t\tcase DRM_FORMAT_XRGB4444:\n\t\t\tm = 0x1; break;\n\t\tcase DRM_FORMAT_RGBA4444:\n\t\t\tm = 0x2; break;\n\t\tcase DRM_FORMAT_RGBX4444:\n\t\t\tm = 0x4; break;\n\t\tcase DRM_FORMAT_ARGB4444:\n\t\t\tm = 0x5; break;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tm = 0x6; break;\n\t\tcase DRM_FORMAT_ARGB1555:\n\t\t\tm = 0x7; break;\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\tm = 0x8; break;\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\tm = 0x9; break;\n\t\tcase DRM_FORMAT_YUYV:\n\t\t\tm = 0xa; break;\n\t\tcase DRM_FORMAT_UYVY:\n\t\t\tm = 0xb; break;\n\t\tcase DRM_FORMAT_ARGB8888:\n\t\t\tm = 0xc; break;\n\t\tcase DRM_FORMAT_RGBA8888:\n\t\t\tm = 0xd; break;\n\t\tcase DRM_FORMAT_RGBX8888:\n\t\t\tm = 0xe; break;\n\t\tcase DRM_FORMAT_XRGB1555:\n\t\t\tm = 0xf; break;\n\t\tdefault:\n\t\t\tBUG(); return;\n\t\t}\n\t} else {\n\t\tswitch (fourcc) {\n\t\tcase DRM_FORMAT_RGBX4444:\n\t\t\tm = 0x4; break;\n\t\tcase DRM_FORMAT_ARGB4444:\n\t\t\tm = 0x5; break;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tm = 0x6; break;\n\t\tcase DRM_FORMAT_ARGB1555:\n\t\t\tm = 0x7; break;\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\tm = 0x8; break;\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\tm = 0x9; break;\n\t\tcase DRM_FORMAT_XRGB4444:\n\t\t\tm = 0xa; break;\n\t\tcase DRM_FORMAT_RGBA4444:\n\t\t\tm = 0xb; break;\n\t\tcase DRM_FORMAT_ARGB8888:\n\t\t\tm = 0xc; break;\n\t\tcase DRM_FORMAT_RGBA8888:\n\t\t\tm = 0xd; break;\n\t\tcase DRM_FORMAT_RGBX8888:\n\t\t\tm = 0xe; break;\n\t\tcase DRM_FORMAT_XRGB1555:\n\t\t\tm = 0xf; break;\n\t\tdefault:\n\t\t\tBUG(); return;\n\t\t}\n\t}\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);\n}\n\nstatic void dispc_ovl_configure_burst_type(struct dispc_device *dispc,\n\t\t\t\t\t   enum omap_plane_id plane,\n\t\t\t\t\t   enum omap_dss_rotation_type rotation)\n{\n\tif (dispc_has_feature(dispc, FEAT_BURST_2D) == 0)\n\t\treturn;\n\n\tif (rotation == OMAP_DSS_ROT_TILER)\n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);\n\telse\n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);\n}\n\nstatic void dispc_ovl_set_channel_out(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane,\n\t\t\t\t      enum omap_channel channel)\n{\n\tint shift;\n\tu32 val;\n\tint chan = 0, chan2 = 0;\n\n\tswitch (plane) {\n\tcase OMAP_DSS_GFX:\n\t\tshift = 8;\n\t\tbreak;\n\tcase OMAP_DSS_VIDEO1:\n\tcase OMAP_DSS_VIDEO2:\n\tcase OMAP_DSS_VIDEO3:\n\t\tshift = 16;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tval = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\t\tchan = 0;\n\t\t\tchan2 = 0;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_DIGIT:\n\t\t\tchan = 1;\n\t\t\tchan2 = 0;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\t\tchan = 0;\n\t\t\tchan2 = 1;\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\t\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {\n\t\t\t\tchan = 0;\n\t\t\t\tchan2 = 2;\n\t\t\t} else {\n\t\t\t\tBUG();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OMAP_DSS_CHANNEL_WB:\n\t\t\tchan = 0;\n\t\t\tchan2 = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t\treturn;\n\t\t}\n\n\t\tval = FLD_MOD(val, chan, shift, shift);\n\t\tval = FLD_MOD(val, chan2, 31, 30);\n\t} else {\n\t\tval = FLD_MOD(val, channel, shift, shift);\n\t}\n\tdispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), val);\n}\n\nstatic enum omap_channel dispc_ovl_get_channel_out(struct dispc_device *dispc,\n\t\t\t\t\t\t   enum omap_plane_id plane)\n{\n\tint shift;\n\tu32 val;\n\n\tswitch (plane) {\n\tcase OMAP_DSS_GFX:\n\t\tshift = 8;\n\t\tbreak;\n\tcase OMAP_DSS_VIDEO1:\n\tcase OMAP_DSS_VIDEO2:\n\tcase OMAP_DSS_VIDEO3:\n\t\tshift = 16;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n\n\tval = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));\n\n\tif (FLD_GET(val, shift, shift) == 1)\n\t\treturn OMAP_DSS_CHANNEL_DIGIT;\n\n\tif (!dispc_has_feature(dispc, FEAT_MGR_LCD2))\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tswitch (FLD_GET(val, 31, 30)) {\n\tcase 0:\n\tdefault:\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\tcase 1:\n\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\tcase 2:\n\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\tcase 3:\n\t\treturn OMAP_DSS_CHANNEL_WB;\n\t}\n}\n\nstatic void dispc_ovl_set_burst_size(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane,\n\t\t\t\t     enum omap_burst_size burst_size)\n{\n\tstatic const unsigned int shifts[] = { 6, 14, 14, 14, 14, };\n\tint shift;\n\n\tshift = shifts[plane];\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), burst_size,\n\t\t    shift + 1, shift);\n}\n\nstatic void dispc_configure_burst_sizes(struct dispc_device *dispc)\n{\n\tint i;\n\tconst int burst_size = BURST_SIZE_X8;\n\n\t \n\tfor (i = 0; i < dispc_get_num_ovls(dispc); ++i)\n\t\tdispc_ovl_set_burst_size(dispc, i, burst_size);\n\tif (dispc->feat->has_writeback)\n\t\tdispc_ovl_set_burst_size(dispc, OMAP_DSS_WB, burst_size);\n}\n\nstatic u32 dispc_ovl_get_burst_size(struct dispc_device *dispc,\n\t\t\t\t    enum omap_plane_id plane)\n{\n\t \n\treturn dispc->feat->burst_size_unit * 8;\n}\n\nbool dispc_ovl_color_mode_supported(struct dispc_device *dispc,\n\t\t\t\t    enum omap_plane_id plane, u32 fourcc)\n{\n\tconst u32 *modes;\n\tunsigned int i;\n\n\tmodes = dispc->feat->supported_color_modes[plane];\n\n\tfor (i = 0; modes[i]; ++i) {\n\t\tif (modes[i] == fourcc)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nconst u32 *dispc_ovl_get_color_modes(struct dispc_device *dispc,\n\t\t\t\t\t    enum omap_plane_id plane)\n{\n\treturn dispc->feat->supported_color_modes[plane];\n}\n\nstatic void dispc_mgr_enable_cpr(struct dispc_device *dispc,\n\t\t\t\t enum omap_channel channel, bool enable)\n{\n\tif (channel == OMAP_DSS_CHANNEL_DIGIT)\n\t\treturn;\n\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_CPR, enable);\n}\n\nstatic void dispc_mgr_set_cpr_coef(struct dispc_device *dispc,\n\t\t\t\t   enum omap_channel channel,\n\t\t\t\t   const struct omap_dss_cpr_coefs *coefs)\n{\n\tu32 coef_r, coef_g, coef_b;\n\n\tif (!dss_mgr_is_lcd(channel))\n\t\treturn;\n\n\tcoef_r = FLD_VAL(coefs->rr, 31, 22) | FLD_VAL(coefs->rg, 20, 11) |\n\t\tFLD_VAL(coefs->rb, 9, 0);\n\tcoef_g = FLD_VAL(coefs->gr, 31, 22) | FLD_VAL(coefs->gg, 20, 11) |\n\t\tFLD_VAL(coefs->gb, 9, 0);\n\tcoef_b = FLD_VAL(coefs->br, 31, 22) | FLD_VAL(coefs->bg, 20, 11) |\n\t\tFLD_VAL(coefs->bb, 9, 0);\n\n\tdispc_write_reg(dispc, DISPC_CPR_COEF_R(channel), coef_r);\n\tdispc_write_reg(dispc, DISPC_CPR_COEF_G(channel), coef_g);\n\tdispc_write_reg(dispc, DISPC_CPR_COEF_B(channel), coef_b);\n}\n\nstatic void dispc_ovl_set_vid_color_conv(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_plane_id plane, bool enable)\n{\n\tu32 val;\n\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tval = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));\n\tval = FLD_MOD(val, enable, 9, 9);\n\tdispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), val);\n}\n\nstatic void dispc_ovl_enable_replication(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_plane_id plane,\n\t\t\t\t\t enum omap_overlay_caps caps,\n\t\t\t\t\t bool enable)\n{\n\tstatic const unsigned int shifts[] = { 5, 10, 10, 10 };\n\tint shift;\n\n\tif ((caps & OMAP_DSS_OVL_CAP_REPLICATION) == 0)\n\t\treturn;\n\n\tshift = shifts[plane];\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);\n}\n\nstatic void dispc_mgr_set_size(struct dispc_device *dispc,\n\t\t\t       enum omap_channel channel, u16 width, u16 height)\n{\n\tu32 val;\n\n\tval = FLD_VAL(height - 1, dispc->feat->mgr_height_start, 16) |\n\t\tFLD_VAL(width - 1, dispc->feat->mgr_width_start, 0);\n\n\tdispc_write_reg(dispc, DISPC_SIZE_MGR(channel), val);\n}\n\nstatic void dispc_init_fifos(struct dispc_device *dispc)\n{\n\tu32 size;\n\tint fifo;\n\tu8 start, end;\n\tu32 unit;\n\tint i;\n\n\tunit = dispc->feat->buffer_size_unit;\n\n\tdispc_get_reg_field(dispc, FEAT_REG_FIFOSIZE, &start, &end);\n\n\tfor (fifo = 0; fifo < dispc->feat->num_fifos; ++fifo) {\n\t\tsize = REG_GET(dispc, DISPC_OVL_FIFO_SIZE_STATUS(fifo),\n\t\t\t       start, end);\n\t\tsize *= unit;\n\t\tdispc->fifo_size[fifo] = size;\n\n\t\t \n\t\tdispc->fifo_assignment[fifo] = fifo;\n\t}\n\n\t \n\tif (dispc->feat->gfx_fifo_workaround) {\n\t\tu32 v;\n\n\t\tv = dispc_read_reg(dispc, DISPC_GLOBAL_BUFFER);\n\n\t\tv = FLD_MOD(v, 4, 2, 0);  \n\t\tv = FLD_MOD(v, 4, 5, 3);  \n\t\tv = FLD_MOD(v, 0, 26, 24);  \n\t\tv = FLD_MOD(v, 0, 29, 27);  \n\n\t\tdispc_write_reg(dispc, DISPC_GLOBAL_BUFFER, v);\n\n\t\tdispc->fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;\n\t\tdispc->fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;\n\t}\n\n\t \n\tfor (i = 0; i < dispc_get_num_ovls(dispc); ++i) {\n\t\tu32 low, high;\n\t\tconst bool use_fifomerge = false;\n\t\tconst bool manual_update = false;\n\n\t\tdispc_ovl_compute_fifo_thresholds(dispc, i, &low, &high,\n\t\t\t\t\t\t  use_fifomerge, manual_update);\n\n\t\tdispc_ovl_set_fifo_threshold(dispc, i, low, high);\n\t}\n\n\tif (dispc->feat->has_writeback) {\n\t\tu32 low, high;\n\t\tconst bool use_fifomerge = false;\n\t\tconst bool manual_update = false;\n\n\t\tdispc_ovl_compute_fifo_thresholds(dispc, OMAP_DSS_WB,\n\t\t\t\t\t\t  &low, &high, use_fifomerge,\n\t\t\t\t\t\t  manual_update);\n\n\t\tdispc_ovl_set_fifo_threshold(dispc, OMAP_DSS_WB, low, high);\n\t}\n}\n\nstatic u32 dispc_ovl_get_fifo_size(struct dispc_device *dispc,\n\t\t\t\t   enum omap_plane_id plane)\n{\n\tint fifo;\n\tu32 size = 0;\n\n\tfor (fifo = 0; fifo < dispc->feat->num_fifos; ++fifo) {\n\t\tif (dispc->fifo_assignment[fifo] == plane)\n\t\t\tsize += dispc->fifo_size[fifo];\n\t}\n\n\treturn size;\n}\n\nvoid dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane,\n\t\t\t\t  u32 low, u32 high)\n{\n\tu8 hi_start, hi_end, lo_start, lo_end;\n\tu32 unit;\n\n\tunit = dispc->feat->buffer_size_unit;\n\n\tWARN_ON(low % unit != 0);\n\tWARN_ON(high % unit != 0);\n\n\tlow /= unit;\n\thigh /= unit;\n\n\tdispc_get_reg_field(dispc, FEAT_REG_FIFOHIGHTHRESHOLD,\n\t\t\t    &hi_start, &hi_end);\n\tdispc_get_reg_field(dispc, FEAT_REG_FIFOLOWTHRESHOLD,\n\t\t\t    &lo_start, &lo_end);\n\n\tDSSDBG(\"fifo(%d) threshold (bytes), old %u/%u, new %u/%u\\n\",\n\t\t\tplane,\n\t\t\tREG_GET(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),\n\t\t\t\tlo_start, lo_end) * unit,\n\t\t\tREG_GET(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),\n\t\t\t\thi_start, hi_end) * unit,\n\t\t\tlow * unit, high * unit);\n\n\tdispc_write_reg(dispc, DISPC_OVL_FIFO_THRESHOLD(plane),\n\t\t\tFLD_VAL(high, hi_start, hi_end) |\n\t\t\tFLD_VAL(low, lo_start, lo_end));\n\n\t \n\tif (dispc_has_feature(dispc, FEAT_PRELOAD) &&\n\t    dispc->feat->set_max_preload && plane != OMAP_DSS_WB)\n\t\tdispc_write_reg(dispc, DISPC_OVL_PRELOAD(plane),\n\t\t\t\tmin(high, 0xfffu));\n}\n\nvoid dispc_enable_fifomerge(struct dispc_device *dispc, bool enable)\n{\n\tif (!dispc_has_feature(dispc, FEAT_FIFO_MERGE)) {\n\t\tWARN_ON(enable);\n\t\treturn;\n\t}\n\n\tDSSDBG(\"FIFO merge %s\\n\", enable ? \"enabled\" : \"disabled\");\n\tREG_FLD_MOD(dispc, DISPC_CONFIG, enable ? 1 : 0, 14, 14);\n}\n\nvoid dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,\n\t\t\t\t       enum omap_plane_id plane,\n\t\t\t\t       u32 *fifo_low, u32 *fifo_high,\n\t\t\t\t       bool use_fifomerge, bool manual_update)\n{\n\t \n\tunsigned int buf_unit = dispc->feat->buffer_size_unit;\n\tunsigned int ovl_fifo_size, total_fifo_size, burst_size;\n\tint i;\n\n\tburst_size = dispc_ovl_get_burst_size(dispc, plane);\n\tovl_fifo_size = dispc_ovl_get_fifo_size(dispc, plane);\n\n\tif (use_fifomerge) {\n\t\ttotal_fifo_size = 0;\n\t\tfor (i = 0; i < dispc_get_num_ovls(dispc); ++i)\n\t\t\ttotal_fifo_size += dispc_ovl_get_fifo_size(dispc, i);\n\t} else {\n\t\ttotal_fifo_size = ovl_fifo_size;\n\t}\n\n\t \n\n\tif (manual_update && dispc_has_feature(dispc, FEAT_OMAP3_DSI_FIFO_BUG)) {\n\t\t*fifo_low = ovl_fifo_size - burst_size * 2;\n\t\t*fifo_high = total_fifo_size - burst_size;\n\t} else if (plane == OMAP_DSS_WB) {\n\t\t \n\t\t*fifo_low = 0;\n\t\t*fifo_high = burst_size;\n\t} else {\n\t\t*fifo_low = ovl_fifo_size - burst_size;\n\t\t*fifo_high = total_fifo_size - buf_unit;\n\t}\n}\n\nstatic void dispc_ovl_set_mflag(struct dispc_device *dispc,\n\t\t\t\tenum omap_plane_id plane, bool enable)\n{\n\tint bit;\n\n\tif (plane == OMAP_DSS_GFX)\n\t\tbit = 14;\n\telse\n\t\tbit = 23;\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable, bit, bit);\n}\n\nstatic void dispc_ovl_set_mflag_threshold(struct dispc_device *dispc,\n\t\t\t\t\t  enum omap_plane_id plane,\n\t\t\t\t\t  int low, int high)\n{\n\tdispc_write_reg(dispc, DISPC_OVL_MFLAG_THRESHOLD(plane),\n\t\tFLD_VAL(high, 31, 16) |\tFLD_VAL(low, 15, 0));\n}\n\nstatic void dispc_init_mflag(struct dispc_device *dispc)\n{\n\tint i;\n\n\t \n\tdispc_write_reg(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE,\n\t\t(1 << 0) |\t \n\t\t(0 << 2));\t \n\n\tfor (i = 0; i < dispc_get_num_ovls(dispc); ++i) {\n\t\tu32 size = dispc_ovl_get_fifo_size(dispc, i);\n\t\tu32 unit = dispc->feat->buffer_size_unit;\n\t\tu32 low, high;\n\n\t\tdispc_ovl_set_mflag(dispc, i, true);\n\n\t\t \n\n\t\tlow = size * 4 / 8 / unit;\n\t\thigh = size * 5 / 8 / unit;\n\n\t\tdispc_ovl_set_mflag_threshold(dispc, i, low, high);\n\t}\n\n\tif (dispc->feat->has_writeback) {\n\t\tu32 size = dispc_ovl_get_fifo_size(dispc, OMAP_DSS_WB);\n\t\tu32 unit = dispc->feat->buffer_size_unit;\n\t\tu32 low, high;\n\n\t\tdispc_ovl_set_mflag(dispc, OMAP_DSS_WB, true);\n\n\t\t \n\n\t\tlow = size * 4 / 8 / unit;\n\t\thigh = size * 5 / 8 / unit;\n\n\t\tdispc_ovl_set_mflag_threshold(dispc, OMAP_DSS_WB, low, high);\n\t}\n}\n\nstatic void dispc_ovl_set_fir(struct dispc_device *dispc,\n\t\t\t      enum omap_plane_id plane,\n\t\t\t      int hinc, int vinc,\n\t\t\t      enum omap_color_component color_comp)\n{\n\tu32 val;\n\n\tif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {\n\t\tu8 hinc_start, hinc_end, vinc_start, vinc_end;\n\n\t\tdispc_get_reg_field(dispc, FEAT_REG_FIRHINC,\n\t\t\t\t    &hinc_start, &hinc_end);\n\t\tdispc_get_reg_field(dispc, FEAT_REG_FIRVINC,\n\t\t\t\t    &vinc_start, &vinc_end);\n\t\tval = FLD_VAL(vinc, vinc_start, vinc_end) |\n\t\t\t\tFLD_VAL(hinc, hinc_start, hinc_end);\n\n\t\tdispc_write_reg(dispc, DISPC_OVL_FIR(plane), val);\n\t} else {\n\t\tval = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);\n\t\tdispc_write_reg(dispc, DISPC_OVL_FIR2(plane), val);\n\t}\n}\n\nstatic void dispc_ovl_set_vid_accu0(struct dispc_device *dispc,\n\t\t\t\t    enum omap_plane_id plane, int haccu,\n\t\t\t\t    int vaccu)\n{\n\tu32 val;\n\tu8 hor_start, hor_end, vert_start, vert_end;\n\n\tdispc_get_reg_field(dispc, FEAT_REG_HORIZONTALACCU,\n\t\t\t    &hor_start, &hor_end);\n\tdispc_get_reg_field(dispc, FEAT_REG_VERTICALACCU,\n\t\t\t    &vert_start, &vert_end);\n\n\tval = FLD_VAL(vaccu, vert_start, vert_end) |\n\t\t\tFLD_VAL(haccu, hor_start, hor_end);\n\n\tdispc_write_reg(dispc, DISPC_OVL_ACCU0(plane), val);\n}\n\nstatic void dispc_ovl_set_vid_accu1(struct dispc_device *dispc,\n\t\t\t\t    enum omap_plane_id plane, int haccu,\n\t\t\t\t    int vaccu)\n{\n\tu32 val;\n\tu8 hor_start, hor_end, vert_start, vert_end;\n\n\tdispc_get_reg_field(dispc, FEAT_REG_HORIZONTALACCU,\n\t\t\t    &hor_start, &hor_end);\n\tdispc_get_reg_field(dispc, FEAT_REG_VERTICALACCU,\n\t\t\t    &vert_start, &vert_end);\n\n\tval = FLD_VAL(vaccu, vert_start, vert_end) |\n\t\t\tFLD_VAL(haccu, hor_start, hor_end);\n\n\tdispc_write_reg(dispc, DISPC_OVL_ACCU1(plane), val);\n}\n\nstatic void dispc_ovl_set_vid_accu2_0(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane, int haccu,\n\t\t\t\t      int vaccu)\n{\n\tu32 val;\n\n\tval = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);\n\tdispc_write_reg(dispc, DISPC_OVL_ACCU2_0(plane), val);\n}\n\nstatic void dispc_ovl_set_vid_accu2_1(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane, int haccu,\n\t\t\t\t      int vaccu)\n{\n\tu32 val;\n\n\tval = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);\n\tdispc_write_reg(dispc, DISPC_OVL_ACCU2_1(plane), val);\n}\n\nstatic void dispc_ovl_set_scale_param(struct dispc_device *dispc,\n\t\t\t\t      enum omap_plane_id plane,\n\t\t\t\t      u16 orig_width, u16 orig_height,\n\t\t\t\t      u16 out_width, u16 out_height,\n\t\t\t\t      bool five_taps, u8 rotation,\n\t\t\t\t      enum omap_color_component color_comp)\n{\n\tint fir_hinc, fir_vinc;\n\n\tfir_hinc = 1024 * orig_width / out_width;\n\tfir_vinc = 1024 * orig_height / out_height;\n\n\tdispc_ovl_set_scale_coef(dispc, plane, fir_hinc, fir_vinc, five_taps,\n\t\t\t\t color_comp);\n\tdispc_ovl_set_fir(dispc, plane, fir_hinc, fir_vinc, color_comp);\n}\n\nstatic void dispc_ovl_set_accu_uv(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane,\n\t\t\t\t  u16 orig_width, u16 orig_height,\n\t\t\t\t  u16 out_width, u16 out_height,\n\t\t\t\t  bool ilace, u32 fourcc, u8 rotation)\n{\n\tint h_accu2_0, h_accu2_1;\n\tint v_accu2_0, v_accu2_1;\n\tint chroma_hinc, chroma_vinc;\n\tint idx;\n\n\tstruct accu {\n\t\ts8 h0_m, h0_n;\n\t\ts8 h1_m, h1_n;\n\t\ts8 v0_m, v0_n;\n\t\ts8 v1_m, v1_n;\n\t};\n\n\tconst struct accu *accu_table;\n\tconst struct accu *accu_val;\n\n\tstatic const struct accu accu_nv12[4] = {\n\t\t{  0, 1,  0, 1 , -1, 2, 0, 1 },\n\t\t{  1, 2, -3, 4 ,  0, 1, 0, 1 },\n\t\t{ -1, 1,  0, 1 , -1, 2, 0, 1 },\n\t\t{ -1, 2, -1, 2 , -1, 1, 0, 1 },\n\t};\n\n\tstatic const struct accu accu_nv12_ilace[4] = {\n\t\t{  0, 1,  0, 1 , -3, 4, -1, 4 },\n\t\t{ -1, 4, -3, 4 ,  0, 1,  0, 1 },\n\t\t{ -1, 1,  0, 1 , -1, 4, -3, 4 },\n\t\t{ -3, 4, -3, 4 , -1, 1,  0, 1 },\n\t};\n\n\tstatic const struct accu accu_yuv[4] = {\n\t\t{  0, 1, 0, 1,  0, 1, 0, 1 },\n\t\t{  0, 1, 0, 1,  0, 1, 0, 1 },\n\t\t{ -1, 1, 0, 1,  0, 1, 0, 1 },\n\t\t{  0, 1, 0, 1, -1, 1, 0, 1 },\n\t};\n\n\t \n\tswitch (rotation & DRM_MODE_ROTATE_MASK) {\n\tdefault:\n\tcase DRM_MODE_ROTATE_0:\n\t\tidx = 0;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tidx = 3;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tidx = 2;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tidx = 1;\n\t\tbreak;\n\t}\n\n\tswitch (fourcc) {\n\tcase DRM_FORMAT_NV12:\n\t\tif (ilace)\n\t\t\taccu_table = accu_nv12_ilace;\n\t\telse\n\t\t\taccu_table = accu_nv12;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\t\taccu_table = accu_yuv;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\taccu_val = &accu_table[idx];\n\n\tchroma_hinc = 1024 * orig_width / out_width;\n\tchroma_vinc = 1024 * orig_height / out_height;\n\n\th_accu2_0 = (accu_val->h0_m * chroma_hinc / accu_val->h0_n) % 1024;\n\th_accu2_1 = (accu_val->h1_m * chroma_hinc / accu_val->h1_n) % 1024;\n\tv_accu2_0 = (accu_val->v0_m * chroma_vinc / accu_val->v0_n) % 1024;\n\tv_accu2_1 = (accu_val->v1_m * chroma_vinc / accu_val->v1_n) % 1024;\n\n\tdispc_ovl_set_vid_accu2_0(dispc, plane, h_accu2_0, v_accu2_0);\n\tdispc_ovl_set_vid_accu2_1(dispc, plane, h_accu2_1, v_accu2_1);\n}\n\nstatic void dispc_ovl_set_scaling_common(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_plane_id plane,\n\t\t\t\t\t u16 orig_width, u16 orig_height,\n\t\t\t\t\t u16 out_width, u16 out_height,\n\t\t\t\t\t bool ilace, bool five_taps,\n\t\t\t\t\t bool fieldmode, u32 fourcc,\n\t\t\t\t\t u8 rotation)\n{\n\tint accu0 = 0;\n\tint accu1 = 0;\n\tu32 l;\n\n\tdispc_ovl_set_scale_param(dispc, plane, orig_width, orig_height,\n\t\t\t\t  out_width, out_height, five_taps,\n\t\t\t\t  rotation, DISPC_COLOR_COMPONENT_RGB_Y);\n\tl = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));\n\n\t \n\tl &= ~((0x3 << 5) | (0x1 << 21));\n\tl |= (orig_width != out_width) ? (1 << 5) : 0;\n\tl |= (orig_height != out_height) ? (1 << 6) : 0;\n\tl |= five_taps ? (1 << 21) : 0;\n\n\t \n\tif (dispc_has_feature(dispc, FEAT_RESIZECONF)) {\n\t\tl &= ~(0x3 << 7);\n\t\tl |= (orig_width <= out_width) ? 0 : (1 << 7);\n\t\tl |= (orig_height <= out_height) ? 0 : (1 << 8);\n\t}\n\n\t \n\tif (dispc_has_feature(dispc, FEAT_LINEBUFFERSPLIT)) {\n\t\tl &= ~(0x1 << 22);\n\t\tl |= five_taps ? (1 << 22) : 0;\n\t}\n\n\tdispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), l);\n\n\t \n\tif (ilace && !fieldmode) {\n\t\taccu1 = 0;\n\t\taccu0 = ((1024 * orig_height / out_height) / 2) & 0x3ff;\n\t\tif (accu0 >= 1024/2) {\n\t\t\taccu1 = 1024/2;\n\t\t\taccu0 -= accu1;\n\t\t}\n\t}\n\n\tdispc_ovl_set_vid_accu0(dispc, plane, 0, accu0);\n\tdispc_ovl_set_vid_accu1(dispc, plane, 0, accu1);\n}\n\nstatic void dispc_ovl_set_scaling_uv(struct dispc_device *dispc,\n\t\t\t\t     enum omap_plane_id plane,\n\t\t\t\t     u16 orig_width, u16 orig_height,\n\t\t\t\t     u16 out_width, u16 out_height,\n\t\t\t\t     bool ilace, bool five_taps,\n\t\t\t\t     bool fieldmode, u32 fourcc,\n\t\t\t\t     u8 rotation)\n{\n\tint scale_x = out_width != orig_width;\n\tint scale_y = out_height != orig_height;\n\tbool chroma_upscale = plane != OMAP_DSS_WB;\n\tconst struct drm_format_info *info;\n\n\tinfo = drm_format_info(fourcc);\n\n\tif (!dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE))\n\t\treturn;\n\n\tif (!info->is_yuv) {\n\t\t \n\t\tif (plane != OMAP_DSS_WB)\n\t\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),\n\t\t\t\t    0, 8, 8);\n\t\treturn;\n\t}\n\n\tdispc_ovl_set_accu_uv(dispc, plane, orig_width, orig_height, out_width,\n\t\t\t      out_height, ilace, fourcc, rotation);\n\n\tswitch (fourcc) {\n\tcase DRM_FORMAT_NV12:\n\t\tif (chroma_upscale) {\n\t\t\t \n\t\t\torig_height >>= 1;\n\t\t\torig_width >>= 1;\n\t\t} else {\n\t\t\t \n\t\t\torig_height <<= 1;\n\t\t\torig_width <<= 1;\n\t\t}\n\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\t\t \n\t\tif (!drm_rotation_90_or_270(rotation)) {\n\t\t\tif (chroma_upscale)\n\t\t\t\t \n\t\t\t\torig_width >>= 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\torig_width <<= 1;\n\t\t}\n\n\t\t \n\t\tif ((rotation & DRM_MODE_ROTATE_MASK) != DRM_MODE_ROTATE_0)\n\t\t\tscale_x = scale_y = true;\n\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tif (out_width != orig_width)\n\t\tscale_x = true;\n\tif (out_height != orig_height)\n\t\tscale_y = true;\n\n\tdispc_ovl_set_scale_param(dispc, plane, orig_width, orig_height,\n\t\t\t\t  out_width, out_height, five_taps,\n\t\t\t\t  rotation, DISPC_COLOR_COMPONENT_UV);\n\n\tif (plane != OMAP_DSS_WB)\n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane),\n\t\t\t(scale_x || scale_y) ? 1 : 0, 8, 8);\n\n\t \n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);\n\t \n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);\n}\n\nstatic void dispc_ovl_set_scaling(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane,\n\t\t\t\t  u16 orig_width, u16 orig_height,\n\t\t\t\t  u16 out_width, u16 out_height,\n\t\t\t\t  bool ilace, bool five_taps,\n\t\t\t\t  bool fieldmode, u32 fourcc,\n\t\t\t\t  u8 rotation)\n{\n\tBUG_ON(plane == OMAP_DSS_GFX);\n\n\tdispc_ovl_set_scaling_common(dispc, plane, orig_width, orig_height,\n\t\t\t\t     out_width, out_height, ilace, five_taps,\n\t\t\t\t     fieldmode, fourcc, rotation);\n\n\tdispc_ovl_set_scaling_uv(dispc, plane, orig_width, orig_height,\n\t\t\t\t out_width, out_height, ilace, five_taps,\n\t\t\t\t fieldmode, fourcc, rotation);\n}\n\nstatic void dispc_ovl_set_rotation_attrs(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_plane_id plane, u8 rotation,\n\t\t\t\t\t enum omap_dss_rotation_type rotation_type,\n\t\t\t\t\t u32 fourcc)\n{\n\tbool row_repeat = false;\n\tint vidrot = 0;\n\n\t \n\tif (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY) {\n\n\t\tif (rotation & DRM_MODE_REFLECT_X) {\n\t\t\tswitch (rotation & DRM_MODE_ROTATE_MASK) {\n\t\t\tcase DRM_MODE_ROTATE_0:\n\t\t\t\tvidrot = 2;\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_ROTATE_90:\n\t\t\t\tvidrot = 1;\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_ROTATE_180:\n\t\t\t\tvidrot = 0;\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_ROTATE_270:\n\t\t\t\tvidrot = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (rotation & DRM_MODE_ROTATE_MASK) {\n\t\t\tcase DRM_MODE_ROTATE_0:\n\t\t\t\tvidrot = 0;\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_ROTATE_90:\n\t\t\t\tvidrot = 3;\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_ROTATE_180:\n\t\t\t\tvidrot = 2;\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_ROTATE_270:\n\t\t\t\tvidrot = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (drm_rotation_90_or_270(rotation))\n\t\t\trow_repeat = true;\n\t\telse\n\t\t\trow_repeat = false;\n\t}\n\n\t \n\tif (fourcc == DRM_FORMAT_NV12 && rotation_type != OMAP_DSS_ROT_TILER)\n\t\tvidrot = 1;\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);\n\tif (dispc_has_feature(dispc, FEAT_ROWREPEATENABLE))\n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane),\n\t\t\trow_repeat ? 1 : 0, 18, 18);\n\n\tif (dispc_ovl_color_mode_supported(dispc, plane, DRM_FORMAT_NV12)) {\n\t\tbool doublestride =\n\t\t\tfourcc == DRM_FORMAT_NV12 &&\n\t\t\trotation_type == OMAP_DSS_ROT_TILER &&\n\t\t\t!drm_rotation_90_or_270(rotation);\n\n\t\t \n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane),\n\t\t\t    doublestride, 22, 22);\n\t}\n}\n\nstatic int color_mode_to_bpp(u32 fourcc)\n{\n\tswitch (fourcc) {\n\tcase DRM_FORMAT_NV12:\n\t\treturn 8;\n\tcase DRM_FORMAT_RGBX4444:\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_RGBA4444:\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB1555:\n\t\treturn 16;\n\tcase DRM_FORMAT_RGB888:\n\t\treturn 24;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_RGBA8888:\n\tcase DRM_FORMAT_RGBX8888:\n\t\treturn 32;\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\n\nstatic s32 pixinc(int pixels, u8 ps)\n{\n\tif (pixels == 1)\n\t\treturn 1;\n\telse if (pixels > 1)\n\t\treturn 1 + (pixels - 1) * ps;\n\telse if (pixels < 0)\n\t\treturn 1 - (-pixels + 1) * ps;\n\n\tBUG();\n}\n\nstatic void calc_offset(u16 screen_width, u16 width,\n\t\tu32 fourcc, bool fieldmode, unsigned int field_offset,\n\t\tunsigned int *offset0, unsigned int *offset1,\n\t\ts32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim,\n\t\tenum omap_dss_rotation_type rotation_type, u8 rotation)\n{\n\tu8 ps;\n\n\tps = color_mode_to_bpp(fourcc) / 8;\n\n\tDSSDBG(\"scrw %d, width %d\\n\", screen_width, width);\n\n\tif (rotation_type == OMAP_DSS_ROT_TILER &&\n\t    (fourcc == DRM_FORMAT_UYVY || fourcc == DRM_FORMAT_YUYV) &&\n\t    drm_rotation_90_or_270(rotation)) {\n\t\t \n\t\twidth *= 2;\n\t}\n\n\t \n\t*offset0 = field_offset * screen_width * ps;\n\t*offset1 = 0;\n\n\t*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +\n\t\t\t(fieldmode ? screen_width : 0), ps);\n\tif (fourcc == DRM_FORMAT_YUYV || fourcc == DRM_FORMAT_UYVY)\n\t\t*pix_inc = pixinc(x_predecim, 2 * ps);\n\telse\n\t\t*pix_inc = pixinc(x_predecim, ps);\n}\n\n \nstatic int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,\n\t\tconst struct videomode *vm, u16 pos_x,\n\t\tu16 width, u16 height, u16 out_width, u16 out_height,\n\t\tbool five_taps)\n{\n\tconst int ds = DIV_ROUND_UP(height, out_height);\n\tunsigned long nonactive;\n\tstatic const u8 limits[3] = { 8, 10, 20 };\n\tu64 val, blank;\n\tint i;\n\n\tnonactive = vm->hactive + vm->hfront_porch + vm->hsync_len +\n\t\t    vm->hback_porch - out_width;\n\n\ti = 0;\n\tif (out_height < height)\n\t\ti++;\n\tif (out_width < width)\n\t\ti++;\n\tblank = div_u64((u64)(vm->hback_porch + vm->hsync_len + vm->hfront_porch) *\n\t\t\tlclk, pclk);\n\tDSSDBG(\"blanking period + ppl = %llu (limit = %u)\\n\", blank, limits[i]);\n\tif (blank <= limits[i])\n\t\treturn -EINVAL;\n\n\t \n\tif (!five_taps)\n\t\treturn 0;\n\n\t \n\tval = div_u64((u64)(nonactive - pos_x) * lclk, pclk);\n\tDSSDBG(\"(nonactive - pos_x) * pcd = %llu max(0, DS - 2) * width = %d\\n\",\n\t\tval, max(0, ds - 2) * width);\n\tif (val < max(0, ds - 2) * width)\n\t\treturn -EINVAL;\n\n\t \n\tval =  div_u64((u64)nonactive * lclk, pclk);\n\tDSSDBG(\"nonactive * pcd  = %llu, max(0, DS - 1) * width = %d\\n\",\n\t\tval, max(0, ds - 1) * width);\n\tif (val < max(0, ds - 1) * width)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic unsigned long calc_core_clk_five_taps(unsigned long pclk,\n\t\tconst struct videomode *vm, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height,\n\t\tu32 fourcc)\n{\n\tu32 core_clk = 0;\n\tu64 tmp;\n\n\tif (height <= out_height && width <= out_width)\n\t\treturn (unsigned long) pclk;\n\n\tif (height > out_height) {\n\t\tunsigned int ppl = vm->hactive;\n\n\t\ttmp = (u64)pclk * height * out_width;\n\t\tdo_div(tmp, 2 * out_height * ppl);\n\t\tcore_clk = tmp;\n\n\t\tif (height > 2 * out_height) {\n\t\t\tif (ppl == out_width)\n\t\t\t\treturn 0;\n\n\t\t\ttmp = (u64)pclk * (height - 2 * out_height) * out_width;\n\t\t\tdo_div(tmp, 2 * out_height * (ppl - out_width));\n\t\t\tcore_clk = max_t(u32, core_clk, tmp);\n\t\t}\n\t}\n\n\tif (width > out_width) {\n\t\ttmp = (u64)pclk * width;\n\t\tdo_div(tmp, out_width);\n\t\tcore_clk = max_t(u32, core_clk, tmp);\n\n\t\tif (fourcc == DRM_FORMAT_XRGB8888)\n\t\t\tcore_clk <<= 1;\n\t}\n\n\treturn core_clk;\n}\n\nstatic unsigned long calc_core_clk_24xx(unsigned long pclk, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\n{\n\tif (height > out_height && width > out_width)\n\t\treturn pclk * 4;\n\telse\n\t\treturn pclk * 2;\n}\n\nstatic unsigned long calc_core_clk_34xx(unsigned long pclk, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\n{\n\tunsigned int hf, vf;\n\n\t \n\n\tif (width > 3 * out_width)\n\t\thf = 4;\n\telse if (width > 2 * out_width)\n\t\thf = 3;\n\telse if (width > out_width)\n\t\thf = 2;\n\telse\n\t\thf = 1;\n\tif (height > out_height)\n\t\tvf = 2;\n\telse\n\t\tvf = 1;\n\n\treturn pclk * vf * hf;\n}\n\nstatic unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,\n\t\tu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\n{\n\t \n\tif (mem_to_mem)\n\t\treturn 1;\n\n\tif (width > out_width)\n\t\treturn DIV_ROUND_UP(pclk, out_width) * width;\n\telse\n\t\treturn pclk;\n}\n\nstatic int dispc_ovl_calc_scaling_24xx(struct dispc_device *dispc,\n\t\t\t\t       unsigned long pclk, unsigned long lclk,\n\t\t\t\t       const struct videomode *vm,\n\t\t\t\t       u16 width, u16 height,\n\t\t\t\t       u16 out_width, u16 out_height,\n\t\t\t\t       u32 fourcc, bool *five_taps,\n\t\t\t\t       int *x_predecim, int *y_predecim,\n\t\t\t\t       int *decim_x, int *decim_y,\n\t\t\t\t       u16 pos_x, unsigned long *core_clk,\n\t\t\t\t       bool mem_to_mem)\n{\n\tint error;\n\tu16 in_width, in_height;\n\tint min_factor = min(*decim_x, *decim_y);\n\tconst int maxsinglelinewidth = dispc->feat->max_line_width;\n\n\t*five_taps = false;\n\n\tdo {\n\t\tin_height = height / *decim_y;\n\t\tin_width = width / *decim_x;\n\t\t*core_clk = dispc->feat->calc_core_clk(pclk, in_width,\n\t\t\t\tin_height, out_width, out_height, mem_to_mem);\n\t\terror = (in_width > maxsinglelinewidth || !*core_clk ||\n\t\t\t*core_clk > dispc_core_clk_rate(dispc));\n\t\tif (error) {\n\t\t\tif (*decim_x == *decim_y) {\n\t\t\t\t*decim_x = min_factor;\n\t\t\t\t++*decim_y;\n\t\t\t} else {\n\t\t\t\tswap(*decim_x, *decim_y);\n\t\t\t\tif (*decim_x < *decim_y)\n\t\t\t\t\t++*decim_x;\n\t\t\t}\n\t\t}\n\t} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);\n\n\tif (error) {\n\t\tDSSERR(\"failed to find scaling settings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (in_width > maxsinglelinewidth) {\n\t\tDSSERR(\"Cannot scale max input width exceeded\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dispc_ovl_calc_scaling_34xx(struct dispc_device *dispc,\n\t\t\t\t       unsigned long pclk, unsigned long lclk,\n\t\t\t\t       const struct videomode *vm,\n\t\t\t\t       u16 width, u16 height,\n\t\t\t\t       u16 out_width, u16 out_height,\n\t\t\t\t       u32 fourcc, bool *five_taps,\n\t\t\t\t       int *x_predecim, int *y_predecim,\n\t\t\t\t       int *decim_x, int *decim_y,\n\t\t\t\t       u16 pos_x, unsigned long *core_clk,\n\t\t\t\t       bool mem_to_mem)\n{\n\tint error;\n\tu16 in_width, in_height;\n\tconst int maxsinglelinewidth = dispc->feat->max_line_width;\n\n\tdo {\n\t\tin_height = height / *decim_y;\n\t\tin_width = width / *decim_x;\n\t\t*five_taps = in_height > out_height;\n\n\t\tif (in_width > maxsinglelinewidth)\n\t\t\tif (in_height > out_height &&\n\t\t\t\t\t\tin_height < out_height * 2)\n\t\t\t\t*five_taps = false;\nagain:\n\t\tif (*five_taps)\n\t\t\t*core_clk = calc_core_clk_five_taps(pclk, vm,\n\t\t\t\t\t\tin_width, in_height, out_width,\n\t\t\t\t\t\tout_height, fourcc);\n\t\telse\n\t\t\t*core_clk = dispc->feat->calc_core_clk(pclk, in_width,\n\t\t\t\t\tin_height, out_width, out_height,\n\t\t\t\t\tmem_to_mem);\n\n\t\terror = check_horiz_timing_omap3(pclk, lclk, vm,\n\t\t\t\tpos_x, in_width, in_height, out_width,\n\t\t\t\tout_height, *five_taps);\n\t\tif (error && *five_taps) {\n\t\t\t*five_taps = false;\n\t\t\tgoto again;\n\t\t}\n\n\t\terror = (error || in_width > maxsinglelinewidth * 2 ||\n\t\t\t(in_width > maxsinglelinewidth && *five_taps) ||\n\t\t\t!*core_clk || *core_clk > dispc_core_clk_rate(dispc));\n\n\t\tif (!error) {\n\t\t\t \n\t\t\tif (in_width / 4 > out_width)\n\t\t\t\t\terror = 1;\n\n\t\t\tif (*five_taps) {\n\t\t\t\tif (in_height / 4 > out_height)\n\t\t\t\t\terror = 1;\n\t\t\t} else {\n\t\t\t\tif (in_height / 2 > out_height)\n\t\t\t\t\terror = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (error)\n\t\t\t++*decim_y;\n\t} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);\n\n\tif (error) {\n\t\tDSSERR(\"failed to find scaling settings\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (check_horiz_timing_omap3(pclk, lclk, vm, pos_x, in_width,\n\t\t\t\tin_height, out_width, out_height, *five_taps)) {\n\t\t\tDSSERR(\"horizontal timing too tight\\n\");\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (in_width > (maxsinglelinewidth * 2)) {\n\t\tDSSERR(\"Cannot setup scaling\\n\");\n\t\tDSSERR(\"width exceeds maximum width possible\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (in_width > maxsinglelinewidth && *five_taps) {\n\t\tDSSERR(\"cannot setup scaling with five taps\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dispc_ovl_calc_scaling_44xx(struct dispc_device *dispc,\n\t\t\t\t       unsigned long pclk, unsigned long lclk,\n\t\t\t\t       const struct videomode *vm,\n\t\t\t\t       u16 width, u16 height,\n\t\t\t\t       u16 out_width, u16 out_height,\n\t\t\t\t       u32 fourcc, bool *five_taps,\n\t\t\t\t       int *x_predecim, int *y_predecim,\n\t\t\t\t       int *decim_x, int *decim_y,\n\t\t\t\t       u16 pos_x, unsigned long *core_clk,\n\t\t\t\t       bool mem_to_mem)\n{\n\tu16 in_width, in_width_max;\n\tint decim_x_min = *decim_x;\n\tu16 in_height = height / *decim_y;\n\tconst int maxsinglelinewidth = dispc->feat->max_line_width;\n\tconst int maxdownscale = dispc->feat->max_downscale;\n\n\tif (mem_to_mem) {\n\t\tin_width_max = out_width * maxdownscale;\n\t} else {\n\t\tin_width_max = dispc_core_clk_rate(dispc)\n\t\t\t     / DIV_ROUND_UP(pclk, out_width);\n\t}\n\n\t*decim_x = DIV_ROUND_UP(width, in_width_max);\n\n\t*decim_x = max(*decim_x, decim_x_min);\n\tif (*decim_x > *x_predecim)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tin_width = width / *decim_x;\n\t} while (*decim_x <= *x_predecim &&\n\t\t\tin_width > maxsinglelinewidth && ++*decim_x);\n\n\tif (in_width > maxsinglelinewidth) {\n\t\tDSSERR(\"Cannot scale width exceeds max line width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*decim_x > 4 && fourcc != DRM_FORMAT_NV12) {\n\t\t \n\t\tDSSERR(\"Not enough bandwidth, too much downscaling (x-decimation factor %d > 4)\\n\", *decim_x);\n\n\t\treturn -EINVAL;\n\t}\n\n\t*core_clk = dispc->feat->calc_core_clk(pclk, in_width, in_height,\n\t\t\t\tout_width, out_height, mem_to_mem);\n\treturn 0;\n}\n\nenum omap_overlay_caps dispc_ovl_get_caps(struct dispc_device *dispc, enum omap_plane_id plane)\n{\n\treturn dispc->feat->overlay_caps[plane];\n}\n\n#define DIV_FRAC(dividend, divisor) \\\n\t((dividend) * 100 / (divisor) - ((dividend) / (divisor) * 100))\n\nstatic int dispc_ovl_calc_scaling(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane,\n\t\t\t\t  unsigned long pclk, unsigned long lclk,\n\t\t\t\t  enum omap_overlay_caps caps,\n\t\t\t\t  const struct videomode *vm,\n\t\t\t\t  u16 width, u16 height,\n\t\t\t\t  u16 out_width, u16 out_height,\n\t\t\t\t  u32 fourcc, bool *five_taps,\n\t\t\t\t  int *x_predecim, int *y_predecim, u16 pos_x,\n\t\t\t\t  enum omap_dss_rotation_type rotation_type,\n\t\t\t\t  bool mem_to_mem)\n{\n\tint maxhdownscale = dispc->feat->max_downscale;\n\tint maxvdownscale = dispc->feat->max_downscale;\n\tconst int max_decim_limit = 16;\n\tunsigned long core_clk = 0;\n\tint decim_x, decim_y, ret;\n\n\tif (width == out_width && height == out_height)\n\t\treturn 0;\n\n\tif (dispc->feat->supported_scaler_color_modes) {\n\t\tconst u32 *modes = dispc->feat->supported_scaler_color_modes;\n\t\tunsigned int i;\n\n\t\tfor (i = 0; modes[i]; ++i) {\n\t\t\tif (modes[i] == fourcc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (modes[i] == 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (plane == OMAP_DSS_WB) {\n\t\tswitch (fourcc) {\n\t\tcase DRM_FORMAT_NV12:\n\t\t\tmaxhdownscale = maxvdownscale = 2;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_YUYV:\n\t\tcase DRM_FORMAT_UYVY:\n\t\t\tmaxhdownscale = 2;\n\t\t\tmaxvdownscale = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!mem_to_mem && (pclk == 0 || vm->pixelclock == 0)) {\n\t\tDSSERR(\"cannot calculate scaling settings: pclk is zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((caps & OMAP_DSS_OVL_CAP_SCALE) == 0)\n\t\treturn -EINVAL;\n\n\tif (mem_to_mem) {\n\t\t*x_predecim = *y_predecim = 1;\n\t} else {\n\t\t*x_predecim = max_decim_limit;\n\t\t*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&\n\t\t\t\tdispc_has_feature(dispc, FEAT_BURST_2D)) ?\n\t\t\t\t2 : max_decim_limit;\n\t}\n\n\tdecim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxhdownscale);\n\tdecim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxvdownscale);\n\n\tif (decim_x > *x_predecim || out_width > width * 8)\n\t\treturn -EINVAL;\n\n\tif (decim_y > *y_predecim || out_height > height * 8)\n\t\treturn -EINVAL;\n\n\tret = dispc->feat->calc_scaling(dispc, pclk, lclk, vm, width, height,\n\t\t\t\t\tout_width, out_height, fourcc,\n\t\t\t\t\tfive_taps, x_predecim, y_predecim,\n\t\t\t\t\t&decim_x, &decim_y, pos_x, &core_clk,\n\t\t\t\t\tmem_to_mem);\n\tif (ret)\n\t\treturn ret;\n\n\tDSSDBG(\"%dx%d -> %dx%d (%d.%02d x %d.%02d), decim %dx%d %dx%d (%d.%02d x %d.%02d), taps %d, req clk %lu, cur clk %lu\\n\",\n\t\twidth, height,\n\t\tout_width, out_height,\n\t\tout_width / width, DIV_FRAC(out_width, width),\n\t\tout_height / height, DIV_FRAC(out_height, height),\n\n\t\tdecim_x, decim_y,\n\t\twidth / decim_x, height / decim_y,\n\t\tout_width / (width / decim_x), DIV_FRAC(out_width, width / decim_x),\n\t\tout_height / (height / decim_y), DIV_FRAC(out_height, height / decim_y),\n\n\t\t*five_taps ? 5 : 3,\n\t\tcore_clk, dispc_core_clk_rate(dispc));\n\n\tif (!core_clk || core_clk > dispc_core_clk_rate(dispc)) {\n\t\tDSSERR(\"failed to set up scaling, \"\n\t\t\t\"required core clk rate = %lu Hz, \"\n\t\t\t\"current core clk rate = %lu Hz\\n\",\n\t\t\tcore_clk, dispc_core_clk_rate(dispc));\n\t\treturn -EINVAL;\n\t}\n\n\t*x_predecim = decim_x;\n\t*y_predecim = decim_y;\n\treturn 0;\n}\n\nvoid dispc_ovl_get_max_size(struct dispc_device *dispc, u16 *width, u16 *height)\n{\n\t*width = dispc->feat->ovl_width_max;\n\t*height = dispc->feat->ovl_height_max;\n}\n\nstatic int dispc_ovl_setup_common(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane,\n\t\t\t\t  enum omap_overlay_caps caps,\n\t\t\t\t  u32 paddr, u32 p_uv_addr,\n\t\t\t\t  u16 screen_width, int pos_x, int pos_y,\n\t\t\t\t  u16 width, u16 height,\n\t\t\t\t  u16 out_width, u16 out_height,\n\t\t\t\t  u32 fourcc, u8 rotation, u8 zorder,\n\t\t\t\t  u8 pre_mult_alpha, u8 global_alpha,\n\t\t\t\t  enum omap_dss_rotation_type rotation_type,\n\t\t\t\t  bool replication, const struct videomode *vm,\n\t\t\t\t  bool mem_to_mem,\n\t\t\t\t  enum drm_color_encoding color_encoding,\n\t\t\t\t  enum drm_color_range color_range)\n{\n\tbool five_taps = true;\n\tbool fieldmode = false;\n\tint r, cconv = 0;\n\tunsigned int offset0, offset1;\n\ts32 row_inc;\n\ts32 pix_inc;\n\tu16 frame_width;\n\tunsigned int field_offset = 0;\n\tu16 in_height = height;\n\tu16 in_width = width;\n\tint x_predecim = 1, y_predecim = 1;\n\tbool ilace = !!(vm->flags & DISPLAY_FLAGS_INTERLACED);\n\tunsigned long pclk = dispc_plane_pclk_rate(dispc, plane);\n\tunsigned long lclk = dispc_plane_lclk_rate(dispc, plane);\n\tconst struct drm_format_info *info;\n\n\tinfo = drm_format_info(fourcc);\n\n\t \n\tif (plane == OMAP_DSS_WB)\n\t\tpclk = vm->pixelclock;\n\n\tif (paddr == 0 && rotation_type != OMAP_DSS_ROT_TILER)\n\t\treturn -EINVAL;\n\n\tif (info->is_yuv && (in_width & 1)) {\n\t\tDSSERR(\"input width %d is not even for YUV format\\n\", in_width);\n\t\treturn -EINVAL;\n\t}\n\n\tout_width = out_width == 0 ? width : out_width;\n\tout_height = out_height == 0 ? height : out_height;\n\n\tif (plane != OMAP_DSS_WB) {\n\t\tif (ilace && height == out_height)\n\t\t\tfieldmode = true;\n\n\t\tif (ilace) {\n\t\t\tif (fieldmode)\n\t\t\t\tin_height /= 2;\n\t\t\tpos_y /= 2;\n\t\t\tout_height /= 2;\n\n\t\t\tDSSDBG(\"adjusting for ilace: height %d, pos_y %d, out_height %d\\n\",\n\t\t\t\tin_height, pos_y, out_height);\n\t\t}\n\t}\n\n\tif (!dispc_ovl_color_mode_supported(dispc, plane, fourcc))\n\t\treturn -EINVAL;\n\n\tr = dispc_ovl_calc_scaling(dispc, plane, pclk, lclk, caps, vm, in_width,\n\t\t\t\t   in_height, out_width, out_height, fourcc,\n\t\t\t\t   &five_taps, &x_predecim, &y_predecim, pos_x,\n\t\t\t\t   rotation_type, mem_to_mem);\n\tif (r)\n\t\treturn r;\n\n\tin_width = in_width / x_predecim;\n\tin_height = in_height / y_predecim;\n\n\tif (x_predecim > 1 || y_predecim > 1)\n\t\tDSSDBG(\"predecimation %d x %x, new input size %d x %d\\n\",\n\t\t\tx_predecim, y_predecim, in_width, in_height);\n\n\tif (info->is_yuv && (in_width & 1)) {\n\t\tDSSDBG(\"predecimated input width is not even for YUV format\\n\");\n\t\tDSSDBG(\"adjusting input width %d -> %d\\n\",\n\t\t\tin_width, in_width & ~1);\n\n\t\tin_width &= ~1;\n\t}\n\n\tif (info->is_yuv)\n\t\tcconv = 1;\n\n\tif (ilace && !fieldmode) {\n\t\t \n\t\tif (!in_height || in_height == out_height)\n\t\t\tfield_offset = 0;\n\t\telse\n\t\t\tfield_offset = in_height / out_height / 2;\n\t}\n\n\t \n\tif (fieldmode)\n\t\tfield_offset = 1;\n\n\toffset0 = 0;\n\toffset1 = 0;\n\trow_inc = 0;\n\tpix_inc = 0;\n\n\tif (plane == OMAP_DSS_WB)\n\t\tframe_width = out_width;\n\telse\n\t\tframe_width = in_width;\n\n\tcalc_offset(screen_width, frame_width,\n\t\t\tfourcc, fieldmode, field_offset,\n\t\t\t&offset0, &offset1, &row_inc, &pix_inc,\n\t\t\tx_predecim, y_predecim,\n\t\t\trotation_type, rotation);\n\n\tDSSDBG(\"offset0 %u, offset1 %u, row_inc %d, pix_inc %d\\n\",\n\t\t\toffset0, offset1, row_inc, pix_inc);\n\n\tdispc_ovl_set_color_mode(dispc, plane, fourcc);\n\n\tdispc_ovl_configure_burst_type(dispc, plane, rotation_type);\n\n\tif (dispc->feat->reverse_ilace_field_order)\n\t\tswap(offset0, offset1);\n\n\tdispc_ovl_set_ba0(dispc, plane, paddr + offset0);\n\tdispc_ovl_set_ba1(dispc, plane, paddr + offset1);\n\n\tif (fourcc == DRM_FORMAT_NV12) {\n\t\tdispc_ovl_set_ba0_uv(dispc, plane, p_uv_addr + offset0);\n\t\tdispc_ovl_set_ba1_uv(dispc, plane, p_uv_addr + offset1);\n\t}\n\n\tif (dispc->feat->last_pixel_inc_missing)\n\t\trow_inc += pix_inc - 1;\n\n\tdispc_ovl_set_row_inc(dispc, plane, row_inc);\n\tdispc_ovl_set_pix_inc(dispc, plane, pix_inc);\n\n\tDSSDBG(\"%d,%d %dx%d -> %dx%d\\n\", pos_x, pos_y, in_width,\n\t\t\tin_height, out_width, out_height);\n\n\tdispc_ovl_set_pos(dispc, plane, caps, pos_x, pos_y);\n\n\tdispc_ovl_set_input_size(dispc, plane, in_width, in_height);\n\n\tif (caps & OMAP_DSS_OVL_CAP_SCALE) {\n\t\tdispc_ovl_set_scaling(dispc, plane, in_width, in_height,\n\t\t\t\t      out_width, out_height, ilace, five_taps,\n\t\t\t\t      fieldmode, fourcc, rotation);\n\t\tdispc_ovl_set_output_size(dispc, plane, out_width, out_height);\n\t\tdispc_ovl_set_vid_color_conv(dispc, plane, cconv);\n\n\t\tif (plane != OMAP_DSS_WB)\n\t\t\tdispc_ovl_set_csc(dispc, plane, color_encoding, color_range);\n\t}\n\n\tdispc_ovl_set_rotation_attrs(dispc, plane, rotation, rotation_type,\n\t\t\t\t     fourcc);\n\n\tdispc_ovl_set_zorder(dispc, plane, caps, zorder);\n\tdispc_ovl_set_pre_mult_alpha(dispc, plane, caps, pre_mult_alpha);\n\tdispc_ovl_setup_global_alpha(dispc, plane, caps, global_alpha);\n\n\tdispc_ovl_enable_replication(dispc, plane, caps, replication);\n\n\treturn 0;\n}\n\nint dispc_ovl_setup(struct dispc_device *dispc,\n\t\t\t   enum omap_plane_id plane,\n\t\t\t   const struct omap_overlay_info *oi,\n\t\t\t   const struct videomode *vm, bool mem_to_mem,\n\t\t\t   enum omap_channel channel)\n{\n\tint r;\n\tenum omap_overlay_caps caps = dispc->feat->overlay_caps[plane];\n\tconst bool replication = true;\n\n\tDSSDBG(\"dispc_ovl_setup %d, pa %pad, pa_uv %pad, sw %d, %d,%d, %dx%d ->\"\n\t\t\" %dx%d, cmode %x, rot %d, chan %d repl %d\\n\",\n\t\tplane, &oi->paddr, &oi->p_uv_addr, oi->screen_width, oi->pos_x,\n\t\toi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,\n\t\toi->fourcc, oi->rotation, channel, replication);\n\n\tdispc_ovl_set_channel_out(dispc, plane, channel);\n\n\tr = dispc_ovl_setup_common(dispc, plane, caps, oi->paddr, oi->p_uv_addr,\n\t\toi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,\n\t\toi->out_width, oi->out_height, oi->fourcc, oi->rotation,\n\t\toi->zorder, oi->pre_mult_alpha, oi->global_alpha,\n\t\toi->rotation_type, replication, vm, mem_to_mem,\n\t\toi->color_encoding, oi->color_range);\n\n\treturn r;\n}\n\nint dispc_wb_setup(struct dispc_device *dispc,\n\t\t   const struct omap_dss_writeback_info *wi,\n\t\t   bool mem_to_mem, const struct videomode *vm,\n\t\t   enum dss_writeback_channel channel_in)\n{\n\tint r;\n\tu32 l;\n\tenum omap_plane_id plane = OMAP_DSS_WB;\n\tconst int pos_x = 0, pos_y = 0;\n\tconst u8 zorder = 0, global_alpha = 0;\n\tconst bool replication = true;\n\tbool truncation;\n\tint in_width = vm->hactive;\n\tint in_height = vm->vactive;\n\tenum omap_overlay_caps caps =\n\t\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;\n\n\tif (vm->flags & DISPLAY_FLAGS_INTERLACED)\n\t\tin_height /= 2;\n\n\tDSSDBG(\"dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, \"\n\t\t\"rot %d\\n\", wi->paddr, wi->p_uv_addr, in_width,\n\t\tin_height, wi->width, wi->height, wi->fourcc, wi->rotation);\n\n\tr = dispc_ovl_setup_common(dispc, plane, caps, wi->paddr, wi->p_uv_addr,\n\t\twi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,\n\t\twi->height, wi->fourcc, wi->rotation, zorder,\n\t\twi->pre_mult_alpha, global_alpha, wi->rotation_type,\n\t\treplication, vm, mem_to_mem, DRM_COLOR_YCBCR_BT601,\n\t\tDRM_COLOR_YCBCR_LIMITED_RANGE);\n\tif (r)\n\t\treturn r;\n\n\tswitch (wi->fourcc) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_RGB888:\n\tcase DRM_FORMAT_ARGB4444:\n\tcase DRM_FORMAT_RGBA4444:\n\tcase DRM_FORMAT_RGBX4444:\n\tcase DRM_FORMAT_ARGB1555:\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_XRGB4444:\n\t\ttruncation = true;\n\t\tbreak;\n\tdefault:\n\t\ttruncation = false;\n\t\tbreak;\n\t}\n\n\t \n\tl = dispc_read_reg(dispc, DISPC_OVL_ATTRIBUTES(plane));\n\tl = FLD_MOD(l, truncation, 10, 10);\t \n\tl = FLD_MOD(l, channel_in, 18, 16);\t \n\tl = FLD_MOD(l, mem_to_mem, 19, 19);\t \n\tif (mem_to_mem)\n\t\tl = FLD_MOD(l, 1, 26, 24);\t \n\telse\n\t\tl = FLD_MOD(l, 0, 26, 24);\t \n\tdispc_write_reg(dispc, DISPC_OVL_ATTRIBUTES(plane), l);\n\n\tif (mem_to_mem) {\n\t\t \n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), 0, 7, 0);\n\t} else {\n\t\tu32 wbdelay;\n\n\t\tif (channel_in == DSS_WB_TV_MGR)\n\t\t\twbdelay = vm->vsync_len + vm->vback_porch;\n\t\telse\n\t\t\twbdelay = vm->vfront_porch + vm->vsync_len +\n\t\t\t\tvm->vback_porch;\n\n\t\tif (vm->flags & DISPLAY_FLAGS_INTERLACED)\n\t\t\twbdelay /= 2;\n\n\t\twbdelay = min(wbdelay, 255u);\n\n\t\t \n\t\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES2(plane), wbdelay, 7, 0);\n\t}\n\n\treturn 0;\n}\n\nbool dispc_has_writeback(struct dispc_device *dispc)\n{\n\treturn dispc->feat->has_writeback;\n}\n\nint dispc_ovl_enable(struct dispc_device *dispc,\n\t\t\t    enum omap_plane_id plane, bool enable)\n{\n\tDSSDBG(\"dispc_enable_plane %d, %d\\n\", plane, enable);\n\n\tREG_FLD_MOD(dispc, DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);\n\n\treturn 0;\n}\n\nstatic void dispc_lcd_enable_signal_polarity(struct dispc_device *dispc,\n\t\t\t\t\t     bool act_high)\n{\n\tif (!dispc_has_feature(dispc, FEAT_LCDENABLEPOL))\n\t\treturn;\n\n\tREG_FLD_MOD(dispc, DISPC_CONTROL, act_high ? 1 : 0, 29, 29);\n}\n\nvoid dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable)\n{\n\tif (!dispc_has_feature(dispc, FEAT_LCDENABLESIGNAL))\n\t\treturn;\n\n\tREG_FLD_MOD(dispc, DISPC_CONTROL, enable ? 1 : 0, 28, 28);\n}\n\nvoid dispc_pck_free_enable(struct dispc_device *dispc, bool enable)\n{\n\tif (!dispc_has_feature(dispc, FEAT_PCKFREEENABLE))\n\t\treturn;\n\n\tREG_FLD_MOD(dispc, DISPC_CONTROL, enable ? 1 : 0, 27, 27);\n}\n\nstatic void dispc_mgr_enable_fifohandcheck(struct dispc_device *dispc,\n\t\t\t\t\t   enum omap_channel channel,\n\t\t\t\t\t   bool enable)\n{\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);\n}\n\n\nstatic void dispc_mgr_set_lcd_type_tft(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel)\n{\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_STNTFT, 1);\n}\n\nstatic void dispc_set_loadmode(struct dispc_device *dispc,\n\t\t\t       enum omap_dss_load_mode mode)\n{\n\tREG_FLD_MOD(dispc, DISPC_CONFIG, mode, 2, 1);\n}\n\n\nstatic void dispc_mgr_set_default_color(struct dispc_device *dispc,\n\t\t\t\t\tenum omap_channel channel, u32 color)\n{\n\tdispc_write_reg(dispc, DISPC_DEFAULT_COLOR(channel), color);\n}\n\nstatic void dispc_mgr_set_trans_key(struct dispc_device *dispc,\n\t\t\t\t    enum omap_channel ch,\n\t\t\t\t    enum omap_dss_trans_key_type type,\n\t\t\t\t    u32 trans_key)\n{\n\tmgr_fld_write(dispc, ch, DISPC_MGR_FLD_TCKSELECTION, type);\n\n\tdispc_write_reg(dispc, DISPC_TRANS_COLOR(ch), trans_key);\n}\n\nstatic void dispc_mgr_enable_trans_key(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel ch, bool enable)\n{\n\tmgr_fld_write(dispc, ch, DISPC_MGR_FLD_TCKENABLE, enable);\n}\n\nstatic void dispc_mgr_enable_alpha_fixed_zorder(struct dispc_device *dispc,\n\t\t\t\t\t\tenum omap_channel ch,\n\t\t\t\t\t\tbool enable)\n{\n\tif (!dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER))\n\t\treturn;\n\n\tif (ch == OMAP_DSS_CHANNEL_LCD)\n\t\tREG_FLD_MOD(dispc, DISPC_CONFIG, enable, 18, 18);\n\telse if (ch == OMAP_DSS_CHANNEL_DIGIT)\n\t\tREG_FLD_MOD(dispc, DISPC_CONFIG, enable, 19, 19);\n}\n\nvoid dispc_mgr_setup(struct dispc_device *dispc,\n\t\t\t    enum omap_channel channel,\n\t\t\t    const struct omap_overlay_manager_info *info)\n{\n\tdispc_mgr_set_default_color(dispc, channel, info->default_color);\n\tdispc_mgr_set_trans_key(dispc, channel, info->trans_key_type,\n\t\t\t\tinfo->trans_key);\n\tdispc_mgr_enable_trans_key(dispc, channel, info->trans_enabled);\n\tdispc_mgr_enable_alpha_fixed_zorder(dispc, channel,\n\t\t\tinfo->partial_alpha_enabled);\n\tif (dispc_has_feature(dispc, FEAT_CPR)) {\n\t\tdispc_mgr_enable_cpr(dispc, channel, info->cpr_enable);\n\t\tdispc_mgr_set_cpr_coef(dispc, channel, &info->cpr_coefs);\n\t}\n}\n\nstatic void dispc_mgr_set_tft_data_lines(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_channel channel,\n\t\t\t\t\t u8 data_lines)\n{\n\tint code;\n\n\tswitch (data_lines) {\n\tcase 12:\n\t\tcode = 0;\n\t\tbreak;\n\tcase 16:\n\t\tcode = 1;\n\t\tbreak;\n\tcase 18:\n\t\tcode = 2;\n\t\tbreak;\n\tcase 24:\n\t\tcode = 3;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_TFTDATALINES, code);\n}\n\nstatic void dispc_mgr_set_io_pad_mode(struct dispc_device *dispc,\n\t\t\t\t      enum dss_io_pad_mode mode)\n{\n\tu32 l;\n\tint gpout0, gpout1;\n\n\tswitch (mode) {\n\tcase DSS_IO_PAD_MODE_RESET:\n\t\tgpout0 = 0;\n\t\tgpout1 = 0;\n\t\tbreak;\n\tcase DSS_IO_PAD_MODE_RFBI:\n\t\tgpout0 = 1;\n\t\tgpout1 = 0;\n\t\tbreak;\n\tcase DSS_IO_PAD_MODE_BYPASS:\n\t\tgpout0 = 1;\n\t\tgpout1 = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tl = dispc_read_reg(dispc, DISPC_CONTROL);\n\tl = FLD_MOD(l, gpout0, 15, 15);\n\tl = FLD_MOD(l, gpout1, 16, 16);\n\tdispc_write_reg(dispc, DISPC_CONTROL, l);\n}\n\nstatic void dispc_mgr_enable_stallmode(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel, bool enable)\n{\n\tmgr_fld_write(dispc, channel, DISPC_MGR_FLD_STALLMODE, enable);\n}\n\nvoid dispc_mgr_set_lcd_config(struct dispc_device *dispc,\n\t\t\t\t     enum omap_channel channel,\n\t\t\t\t     const struct dss_lcd_mgr_config *config)\n{\n\tdispc_mgr_set_io_pad_mode(dispc, config->io_pad_mode);\n\n\tdispc_mgr_enable_stallmode(dispc, channel, config->stallmode);\n\tdispc_mgr_enable_fifohandcheck(dispc, channel, config->fifohandcheck);\n\n\tdispc_mgr_set_clock_div(dispc, channel, &config->clock_info);\n\n\tdispc_mgr_set_tft_data_lines(dispc, channel, config->video_port_width);\n\n\tdispc_lcd_enable_signal_polarity(dispc, config->lcden_sig_polarity);\n\n\tdispc_mgr_set_lcd_type_tft(dispc, channel);\n}\n\nstatic bool _dispc_mgr_size_ok(struct dispc_device *dispc,\n\t\t\t       u16 width, u16 height)\n{\n\treturn width <= dispc->feat->mgr_width_max &&\n\t\theight <= dispc->feat->mgr_height_max;\n}\n\nstatic bool _dispc_lcd_timings_ok(struct dispc_device *dispc,\n\t\t\t\t  int hsync_len, int hfp, int hbp,\n\t\t\t\t  int vsw, int vfp, int vbp)\n{\n\tif (hsync_len < 1 || hsync_len > dispc->feat->sw_max ||\n\t    hfp < 1 || hfp > dispc->feat->hp_max ||\n\t    hbp < 1 || hbp > dispc->feat->hp_max ||\n\t    vsw < 1 || vsw > dispc->feat->sw_max ||\n\t    vfp < 0 || vfp > dispc->feat->vp_max ||\n\t    vbp < 0 || vbp > dispc->feat->vp_max)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool _dispc_mgr_pclk_ok(struct dispc_device *dispc,\n\t\t\t       enum omap_channel channel,\n\t\t\t       unsigned long pclk)\n{\n\tif (dss_mgr_is_lcd(channel))\n\t\treturn pclk <= dispc->feat->max_lcd_pclk;\n\telse\n\t\treturn pclk <= dispc->feat->max_tv_pclk;\n}\n\nint dispc_mgr_check_timings(struct dispc_device *dispc,\n\t\t\t\t   enum omap_channel channel,\n\t\t\t\t   const struct videomode *vm)\n{\n\tif (!_dispc_mgr_size_ok(dispc, vm->hactive, vm->vactive))\n\t\treturn MODE_BAD;\n\n\tif (!_dispc_mgr_pclk_ok(dispc, channel, vm->pixelclock))\n\t\treturn MODE_BAD;\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\t \n\t\tif (vm->flags & DISPLAY_FLAGS_INTERLACED)\n\t\t\treturn MODE_BAD;\n\n\t\tif (!_dispc_lcd_timings_ok(dispc, vm->hsync_len,\n\t\t\t\tvm->hfront_porch, vm->hback_porch,\n\t\t\t\tvm->vsync_len, vm->vfront_porch,\n\t\t\t\tvm->vback_porch))\n\t\t\treturn MODE_BAD;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic void _dispc_mgr_set_lcd_timings(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel,\n\t\t\t\t       const struct videomode *vm)\n{\n\tu32 timing_h, timing_v, l;\n\tbool onoff, rf, ipc, vs, hs, de;\n\n\ttiming_h = FLD_VAL(vm->hsync_len - 1, dispc->feat->sw_start, 0) |\n\t\t   FLD_VAL(vm->hfront_porch - 1, dispc->feat->fp_start, 8) |\n\t\t   FLD_VAL(vm->hback_porch - 1, dispc->feat->bp_start, 20);\n\ttiming_v = FLD_VAL(vm->vsync_len - 1, dispc->feat->sw_start, 0) |\n\t\t   FLD_VAL(vm->vfront_porch, dispc->feat->fp_start, 8) |\n\t\t   FLD_VAL(vm->vback_porch, dispc->feat->bp_start, 20);\n\n\tdispc_write_reg(dispc, DISPC_TIMING_H(channel), timing_h);\n\tdispc_write_reg(dispc, DISPC_TIMING_V(channel), timing_v);\n\n\tvs = !!(vm->flags & DISPLAY_FLAGS_VSYNC_LOW);\n\ths = !!(vm->flags & DISPLAY_FLAGS_HSYNC_LOW);\n\tde = !!(vm->flags & DISPLAY_FLAGS_DE_LOW);\n\tipc = !!(vm->flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE);\n\tonoff = true;  \n\trf = !!(vm->flags & DISPLAY_FLAGS_SYNC_POSEDGE);\n\n\tl = FLD_VAL(onoff, 17, 17) |\n\t\tFLD_VAL(rf, 16, 16) |\n\t\tFLD_VAL(de, 15, 15) |\n\t\tFLD_VAL(ipc, 14, 14) |\n\t\tFLD_VAL(hs, 13, 13) |\n\t\tFLD_VAL(vs, 12, 12);\n\n\t \n\tif (dispc->feat->supports_sync_align)\n\t\tl |= (1 << 18);\n\n\tdispc_write_reg(dispc, DISPC_POL_FREQ(channel), l);\n\n\tif (dispc->syscon_pol) {\n\t\tconst int shifts[] = {\n\t\t\t[OMAP_DSS_CHANNEL_LCD] = 0,\n\t\t\t[OMAP_DSS_CHANNEL_LCD2] = 1,\n\t\t\t[OMAP_DSS_CHANNEL_LCD3] = 2,\n\t\t};\n\n\t\tu32 mask, val;\n\n\t\tmask = (1 << 0) | (1 << 3) | (1 << 6);\n\t\tval = (rf << 0) | (ipc << 3) | (onoff << 6);\n\n\t\tmask <<= 16 + shifts[channel];\n\t\tval <<= 16 + shifts[channel];\n\n\t\tregmap_update_bits(dispc->syscon_pol, dispc->syscon_pol_offset,\n\t\t\t\t   mask, val);\n\t}\n}\n\nstatic int vm_flag_to_int(enum display_flags flags, enum display_flags high,\n\tenum display_flags low)\n{\n\tif (flags & high)\n\t\treturn 1;\n\tif (flags & low)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nvoid dispc_mgr_set_timings(struct dispc_device *dispc,\n\t\t\t\t  enum omap_channel channel,\n\t\t\t\t  const struct videomode *vm)\n{\n\tunsigned int xtot, ytot;\n\tunsigned long ht, vt;\n\tstruct videomode t = *vm;\n\n\tDSSDBG(\"channel %d xres %u yres %u\\n\", channel, t.hactive, t.vactive);\n\n\tif (dispc_mgr_check_timings(dispc, channel, &t)) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\t_dispc_mgr_set_lcd_timings(dispc, channel, &t);\n\n\t\txtot = t.hactive + t.hfront_porch + t.hsync_len + t.hback_porch;\n\t\tytot = t.vactive + t.vfront_porch + t.vsync_len + t.vback_porch;\n\n\t\tht = vm->pixelclock / xtot;\n\t\tvt = vm->pixelclock / xtot / ytot;\n\n\t\tDSSDBG(\"pck %lu\\n\", vm->pixelclock);\n\t\tDSSDBG(\"hsync_len %d hfp %d hbp %d vsw %d vfp %d vbp %d\\n\",\n\t\t\tt.hsync_len, t.hfront_porch, t.hback_porch,\n\t\t\tt.vsync_len, t.vfront_porch, t.vback_porch);\n\t\tDSSDBG(\"vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\\n\",\n\t\t\tvm_flag_to_int(t.flags, DISPLAY_FLAGS_VSYNC_HIGH, DISPLAY_FLAGS_VSYNC_LOW),\n\t\t\tvm_flag_to_int(t.flags, DISPLAY_FLAGS_HSYNC_HIGH, DISPLAY_FLAGS_HSYNC_LOW),\n\t\t\tvm_flag_to_int(t.flags, DISPLAY_FLAGS_PIXDATA_POSEDGE, DISPLAY_FLAGS_PIXDATA_NEGEDGE),\n\t\t\tvm_flag_to_int(t.flags, DISPLAY_FLAGS_DE_HIGH, DISPLAY_FLAGS_DE_LOW),\n\t\t\tvm_flag_to_int(t.flags, DISPLAY_FLAGS_SYNC_POSEDGE, DISPLAY_FLAGS_SYNC_NEGEDGE));\n\n\t\tDSSDBG(\"hsync %luHz, vsync %luHz\\n\", ht, vt);\n\t} else {\n\t\tif (t.flags & DISPLAY_FLAGS_INTERLACED)\n\t\t\tt.vactive /= 2;\n\n\t\tif (dispc->feat->supports_double_pixel)\n\t\t\tREG_FLD_MOD(dispc, DISPC_CONTROL,\n\t\t\t\t    !!(t.flags & DISPLAY_FLAGS_DOUBLECLK),\n\t\t\t\t    19, 17);\n\t}\n\n\tdispc_mgr_set_size(dispc, channel, t.hactive, t.vactive);\n}\n\nstatic void dispc_mgr_set_lcd_divisor(struct dispc_device *dispc,\n\t\t\t\t      enum omap_channel channel, u16 lck_div,\n\t\t\t\t      u16 pck_div)\n{\n\tBUG_ON(lck_div < 1);\n\tBUG_ON(pck_div < 1);\n\n\tdispc_write_reg(dispc, DISPC_DIVISORo(channel),\n\t\t\tFLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));\n\n\tif (!dispc_has_feature(dispc, FEAT_CORE_CLK_DIV) &&\n\t\t\tchannel == OMAP_DSS_CHANNEL_LCD)\n\t\tdispc->core_clk_rate = dispc_fclk_rate(dispc) / lck_div;\n}\n\nstatic void dispc_mgr_get_lcd_divisor(struct dispc_device *dispc,\n\t\t\t\t      enum omap_channel channel, int *lck_div,\n\t\t\t\t      int *pck_div)\n{\n\tu32 l;\n\tl = dispc_read_reg(dispc, DISPC_DIVISORo(channel));\n\t*lck_div = FLD_GET(l, 23, 16);\n\t*pck_div = FLD_GET(l, 7, 0);\n}\n\nstatic unsigned long dispc_fclk_rate(struct dispc_device *dispc)\n{\n\tunsigned long r;\n\tenum dss_clk_source src;\n\n\tsrc = dss_get_dispc_clk_source(dispc->dss);\n\n\tif (src == DSS_CLK_SRC_FCK) {\n\t\tr = dss_get_dispc_clk_rate(dispc->dss);\n\t} else {\n\t\tstruct dss_pll *pll;\n\t\tunsigned int clkout_idx;\n\n\t\tpll = dss_pll_find_by_src(dispc->dss, src);\n\t\tclkout_idx = dss_pll_get_clkout_idx_for_src(src);\n\n\t\tr = pll->cinfo.clkout[clkout_idx];\n\t}\n\n\treturn r;\n}\n\nstatic unsigned long dispc_mgr_lclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_channel channel)\n{\n\tint lcd;\n\tunsigned long r;\n\tenum dss_clk_source src;\n\n\t \n\tif (!dss_mgr_is_lcd(channel))\n\t\treturn dispc_fclk_rate(dispc);\n\n\tsrc = dss_get_lcd_clk_source(dispc->dss, channel);\n\n\tif (src == DSS_CLK_SRC_FCK) {\n\t\tr = dss_get_dispc_clk_rate(dispc->dss);\n\t} else {\n\t\tstruct dss_pll *pll;\n\t\tunsigned int clkout_idx;\n\n\t\tpll = dss_pll_find_by_src(dispc->dss, src);\n\t\tclkout_idx = dss_pll_get_clkout_idx_for_src(src);\n\n\t\tr = pll->cinfo.clkout[clkout_idx];\n\t}\n\n\tlcd = REG_GET(dispc, DISPC_DIVISORo(channel), 23, 16);\n\n\treturn r / lcd;\n}\n\nstatic unsigned long dispc_mgr_pclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t enum omap_channel channel)\n{\n\tunsigned long r;\n\n\tif (dss_mgr_is_lcd(channel)) {\n\t\tint pcd;\n\t\tu32 l;\n\n\t\tl = dispc_read_reg(dispc, DISPC_DIVISORo(channel));\n\n\t\tpcd = FLD_GET(l, 7, 0);\n\n\t\tr = dispc_mgr_lclk_rate(dispc, channel);\n\n\t\treturn r / pcd;\n\t} else {\n\t\treturn dispc->tv_pclk_rate;\n\t}\n}\n\nvoid dispc_set_tv_pclk(struct dispc_device *dispc, unsigned long pclk)\n{\n\tdispc->tv_pclk_rate = pclk;\n}\n\nstatic unsigned long dispc_core_clk_rate(struct dispc_device *dispc)\n{\n\treturn dispc->core_clk_rate;\n}\n\nstatic unsigned long dispc_plane_pclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t   enum omap_plane_id plane)\n{\n\tenum omap_channel channel;\n\n\tif (plane == OMAP_DSS_WB)\n\t\treturn 0;\n\n\tchannel = dispc_ovl_get_channel_out(dispc, plane);\n\n\treturn dispc_mgr_pclk_rate(dispc, channel);\n}\n\nstatic unsigned long dispc_plane_lclk_rate(struct dispc_device *dispc,\n\t\t\t\t\t   enum omap_plane_id plane)\n{\n\tenum omap_channel channel;\n\n\tif (plane == OMAP_DSS_WB)\n\t\treturn 0;\n\n\tchannel\t= dispc_ovl_get_channel_out(dispc, plane);\n\n\treturn dispc_mgr_lclk_rate(dispc, channel);\n}\n\nstatic void dispc_dump_clocks_channel(struct dispc_device *dispc,\n\t\t\t\t      struct seq_file *s,\n\t\t\t\t      enum omap_channel channel)\n{\n\tint lcd, pcd;\n\tenum dss_clk_source lcd_clk_src;\n\n\tseq_printf(s, \"- %s -\\n\", mgr_desc[channel].name);\n\n\tlcd_clk_src = dss_get_lcd_clk_source(dispc->dss, channel);\n\n\tseq_printf(s, \"%s clk source = %s\\n\", mgr_desc[channel].name,\n\t\tdss_get_clk_source_name(lcd_clk_src));\n\n\tdispc_mgr_get_lcd_divisor(dispc, channel, &lcd, &pcd);\n\n\tseq_printf(s, \"lck\\t\\t%-16lulck div\\t%u\\n\",\n\t\tdispc_mgr_lclk_rate(dispc, channel), lcd);\n\tseq_printf(s, \"pck\\t\\t%-16lupck div\\t%u\\n\",\n\t\tdispc_mgr_pclk_rate(dispc, channel), pcd);\n}\n\nvoid dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s)\n{\n\tenum dss_clk_source dispc_clk_src;\n\tint lcd;\n\tu32 l;\n\n\tif (dispc_runtime_get(dispc))\n\t\treturn;\n\n\tseq_printf(s, \"- DISPC -\\n\");\n\n\tdispc_clk_src = dss_get_dispc_clk_source(dispc->dss);\n\tseq_printf(s, \"dispc fclk source = %s\\n\",\n\t\t\tdss_get_clk_source_name(dispc_clk_src));\n\n\tseq_printf(s, \"fck\\t\\t%-16lu\\n\", dispc_fclk_rate(dispc));\n\n\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV)) {\n\t\tseq_printf(s, \"- DISPC-CORE-CLK -\\n\");\n\t\tl = dispc_read_reg(dispc, DISPC_DIVISOR);\n\t\tlcd = FLD_GET(l, 23, 16);\n\n\t\tseq_printf(s, \"lck\\t\\t%-16lulck div\\t%u\\n\",\n\t\t\t\t(dispc_fclk_rate(dispc)/lcd), lcd);\n\t}\n\n\tdispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD);\n\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2))\n\t\tdispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD2);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3))\n\t\tdispc_dump_clocks_channel(dispc, s, OMAP_DSS_CHANNEL_LCD3);\n\n\tdispc_runtime_put(dispc);\n}\n\nstatic int dispc_dump_regs(struct seq_file *s, void *p)\n{\n\tstruct dispc_device *dispc = s->private;\n\tint i, j;\n\tconst char *mgr_names[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD]\t\t= \"LCD\",\n\t\t[OMAP_DSS_CHANNEL_DIGIT]\t= \"TV\",\n\t\t[OMAP_DSS_CHANNEL_LCD2]\t\t= \"LCD2\",\n\t\t[OMAP_DSS_CHANNEL_LCD3]\t\t= \"LCD3\",\n\t};\n\tconst char *ovl_names[] = {\n\t\t[OMAP_DSS_GFX]\t\t= \"GFX\",\n\t\t[OMAP_DSS_VIDEO1]\t= \"VID1\",\n\t\t[OMAP_DSS_VIDEO2]\t= \"VID2\",\n\t\t[OMAP_DSS_VIDEO3]\t= \"VID3\",\n\t\t[OMAP_DSS_WB]\t\t= \"WB\",\n\t};\n\tconst char **p_names;\n\n#define DUMPREG(dispc, r) \\\n\tseq_printf(s, \"%-50s %08x\\n\", #r, dispc_read_reg(dispc, r))\n\n\tif (dispc_runtime_get(dispc))\n\t\treturn 0;\n\n\t \n\tDUMPREG(dispc, DISPC_REVISION);\n\tDUMPREG(dispc, DISPC_SYSCONFIG);\n\tDUMPREG(dispc, DISPC_SYSSTATUS);\n\tDUMPREG(dispc, DISPC_IRQSTATUS);\n\tDUMPREG(dispc, DISPC_IRQENABLE);\n\tDUMPREG(dispc, DISPC_CONTROL);\n\tDUMPREG(dispc, DISPC_CONFIG);\n\tDUMPREG(dispc, DISPC_CAPABLE);\n\tDUMPREG(dispc, DISPC_LINE_STATUS);\n\tDUMPREG(dispc, DISPC_LINE_NUMBER);\n\tif (dispc_has_feature(dispc, FEAT_ALPHA_FIXED_ZORDER) ||\n\t\t\tdispc_has_feature(dispc, FEAT_ALPHA_FREE_ZORDER))\n\t\tDUMPREG(dispc, DISPC_GLOBAL_ALPHA);\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2)) {\n\t\tDUMPREG(dispc, DISPC_CONTROL2);\n\t\tDUMPREG(dispc, DISPC_CONFIG2);\n\t}\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3)) {\n\t\tDUMPREG(dispc, DISPC_CONTROL3);\n\t\tDUMPREG(dispc, DISPC_CONFIG3);\n\t}\n\tif (dispc_has_feature(dispc, FEAT_MFLAG))\n\t\tDUMPREG(dispc, DISPC_GLOBAL_MFLAG_ATTRIBUTE);\n\n#undef DUMPREG\n\n#define DISPC_REG(i, name) name(i)\n#define DUMPREG(dispc, i, r) seq_printf(s, \"%s(%s)%*s %08x\\n\", #r, p_names[i], \\\n\t(int)(48 - strlen(#r) - strlen(p_names[i])), \" \", \\\n\tdispc_read_reg(dispc, DISPC_REG(i, r)))\n\n\tp_names = mgr_names;\n\n\t \n\tfor (i = 0; i < dispc_get_num_mgrs(dispc); i++) {\n\t\tDUMPREG(dispc, i, DISPC_DEFAULT_COLOR);\n\t\tDUMPREG(dispc, i, DISPC_TRANS_COLOR);\n\t\tDUMPREG(dispc, i, DISPC_SIZE_MGR);\n\n\t\tif (i == OMAP_DSS_CHANNEL_DIGIT)\n\t\t\tcontinue;\n\n\t\tDUMPREG(dispc, i, DISPC_TIMING_H);\n\t\tDUMPREG(dispc, i, DISPC_TIMING_V);\n\t\tDUMPREG(dispc, i, DISPC_POL_FREQ);\n\t\tDUMPREG(dispc, i, DISPC_DIVISORo);\n\n\t\tDUMPREG(dispc, i, DISPC_DATA_CYCLE1);\n\t\tDUMPREG(dispc, i, DISPC_DATA_CYCLE2);\n\t\tDUMPREG(dispc, i, DISPC_DATA_CYCLE3);\n\n\t\tif (dispc_has_feature(dispc, FEAT_CPR)) {\n\t\t\tDUMPREG(dispc, i, DISPC_CPR_COEF_R);\n\t\t\tDUMPREG(dispc, i, DISPC_CPR_COEF_G);\n\t\t\tDUMPREG(dispc, i, DISPC_CPR_COEF_B);\n\t\t}\n\t}\n\n\tp_names = ovl_names;\n\n\tfor (i = 0; i < dispc_get_num_ovls(dispc); i++) {\n\t\tDUMPREG(dispc, i, DISPC_OVL_BA0);\n\t\tDUMPREG(dispc, i, DISPC_OVL_BA1);\n\t\tDUMPREG(dispc, i, DISPC_OVL_POSITION);\n\t\tDUMPREG(dispc, i, DISPC_OVL_SIZE);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES);\n\t\tDUMPREG(dispc, i, DISPC_OVL_FIFO_THRESHOLD);\n\t\tDUMPREG(dispc, i, DISPC_OVL_FIFO_SIZE_STATUS);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ROW_INC);\n\t\tDUMPREG(dispc, i, DISPC_OVL_PIXEL_INC);\n\n\t\tif (dispc_has_feature(dispc, FEAT_PRELOAD))\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_PRELOAD);\n\t\tif (dispc_has_feature(dispc, FEAT_MFLAG))\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_MFLAG_THRESHOLD);\n\n\t\tif (i == OMAP_DSS_GFX) {\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_WINDOW_SKIP);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_TABLE_BA);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDUMPREG(dispc, i, DISPC_OVL_FIR);\n\t\tDUMPREG(dispc, i, DISPC_OVL_PICTURE_SIZE);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU0);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU1);\n\t\tif (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_BA0_UV);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_BA1_UV);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR2);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU2_0);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU2_1);\n\t\t}\n\t\tif (dispc_has_feature(dispc, FEAT_ATTR2))\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES2);\n\t}\n\n\tif (dispc->feat->has_writeback) {\n\t\ti = OMAP_DSS_WB;\n\t\tDUMPREG(dispc, i, DISPC_OVL_BA0);\n\t\tDUMPREG(dispc, i, DISPC_OVL_BA1);\n\t\tDUMPREG(dispc, i, DISPC_OVL_SIZE);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES);\n\t\tDUMPREG(dispc, i, DISPC_OVL_FIFO_THRESHOLD);\n\t\tDUMPREG(dispc, i, DISPC_OVL_FIFO_SIZE_STATUS);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ROW_INC);\n\t\tDUMPREG(dispc, i, DISPC_OVL_PIXEL_INC);\n\n\t\tif (dispc_has_feature(dispc, FEAT_MFLAG))\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_MFLAG_THRESHOLD);\n\n\t\tDUMPREG(dispc, i, DISPC_OVL_FIR);\n\t\tDUMPREG(dispc, i, DISPC_OVL_PICTURE_SIZE);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU0);\n\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU1);\n\t\tif (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_BA0_UV);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_BA1_UV);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR2);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU2_0);\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_ACCU2_1);\n\t\t}\n\t\tif (dispc_has_feature(dispc, FEAT_ATTR2))\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_ATTRIBUTES2);\n\t}\n\n#undef DISPC_REG\n#undef DUMPREG\n\n#define DISPC_REG(plane, name, i) name(plane, i)\n#define DUMPREG(dispc, plane, name, i) \\\n\tseq_printf(s, \"%s_%d(%s)%*s %08x\\n\", #name, i, p_names[plane], \\\n\t(int)(46 - strlen(#name) - strlen(p_names[plane])), \" \", \\\n\tdispc_read_reg(dispc, DISPC_REG(plane, name, i)))\n\n\t \n\n\t \n\tfor (i = 1; i < dispc_get_num_ovls(dispc); i++) {\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR_COEF_H, j);\n\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR_COEF_HV, j);\n\n\t\tfor (j = 0; j < 5; j++)\n\t\t\tDUMPREG(dispc, i, DISPC_OVL_CONV_COEF, j);\n\n\t\tif (dispc_has_feature(dispc, FEAT_FIR_COEF_V)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR_COEF_V, j);\n\t\t}\n\n\t\tif (dispc_has_feature(dispc, FEAT_HANDLE_UV_SEPARATE)) {\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR_COEF_H2, j);\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR_COEF_HV2, j);\n\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tDUMPREG(dispc, i, DISPC_OVL_FIR_COEF_V2, j);\n\t\t}\n\t}\n\n\tdispc_runtime_put(dispc);\n\n#undef DISPC_REG\n#undef DUMPREG\n\n\treturn 0;\n}\n\n \nint dispc_calc_clock_rates(struct dispc_device *dispc,\n\t\t\t   unsigned long dispc_fclk_rate,\n\t\t\t   struct dispc_clock_info *cinfo)\n{\n\tif (cinfo->lck_div > 255 || cinfo->lck_div == 0)\n\t\treturn -EINVAL;\n\tif (cinfo->pck_div < 1 || cinfo->pck_div > 255)\n\t\treturn -EINVAL;\n\n\tcinfo->lck = dispc_fclk_rate / cinfo->lck_div;\n\tcinfo->pck = cinfo->lck / cinfo->pck_div;\n\n\treturn 0;\n}\n\nbool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n\t\t    unsigned long pck_min, unsigned long pck_max,\n\t\t    dispc_div_calc_func func, void *data)\n{\n\tint lckd, lckd_start, lckd_stop;\n\tint pckd, pckd_start, pckd_stop;\n\tunsigned long pck, lck;\n\tunsigned long lck_max;\n\tunsigned long pckd_hw_min, pckd_hw_max;\n\tunsigned int min_fck_per_pck;\n\tunsigned long fck;\n\n#ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n\tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n#else\n\tmin_fck_per_pck = 0;\n#endif\n\n\tpckd_hw_min = dispc->feat->min_pcd;\n\tpckd_hw_max = 255;\n\n\tlck_max = dss_get_max_fck_rate(dispc->dss);\n\n\tpck_min = pck_min ? pck_min : 1;\n\tpck_max = pck_max ? pck_max : ULONG_MAX;\n\n\tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n\tlckd_stop = min(dispc_freq / pck_min, 255ul);\n\n\tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n\t\tlck = dispc_freq / lckd;\n\n\t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n\t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n\n\t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n\t\t\tpck = lck / pckd;\n\n\t\t\t \n\t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n\t\t\t\tfck = dispc_core_clk_rate(dispc);\n\t\t\telse\n\t\t\t\tfck = lck;\n\n\t\t\tif (fck < pck * min_fck_per_pck)\n\t\t\t\tcontinue;\n\n\t\t\tif (func(lckd, pckd, lck, pck, data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid dispc_mgr_set_clock_div(struct dispc_device *dispc,\n\t\t\t     enum omap_channel channel,\n\t\t\t     const struct dispc_clock_info *cinfo)\n{\n\tDSSDBG(\"lck = %lu (%u)\\n\", cinfo->lck, cinfo->lck_div);\n\tDSSDBG(\"pck = %lu (%u)\\n\", cinfo->pck, cinfo->pck_div);\n\n\tdispc_mgr_set_lcd_divisor(dispc, channel, cinfo->lck_div,\n\t\t\t\t  cinfo->pck_div);\n}\n\nint dispc_mgr_get_clock_div(struct dispc_device *dispc,\n\t\t\t    enum omap_channel channel,\n\t\t\t    struct dispc_clock_info *cinfo)\n{\n\tunsigned long fck;\n\n\tfck = dispc_fclk_rate(dispc);\n\n\tcinfo->lck_div = REG_GET(dispc, DISPC_DIVISORo(channel), 23, 16);\n\tcinfo->pck_div = REG_GET(dispc, DISPC_DIVISORo(channel), 7, 0);\n\n\tcinfo->lck = fck / cinfo->lck_div;\n\tcinfo->pck = cinfo->lck / cinfo->pck_div;\n\n\treturn 0;\n}\n\nu32 dispc_read_irqstatus(struct dispc_device *dispc)\n{\n\treturn dispc_read_reg(dispc, DISPC_IRQSTATUS);\n}\n\nvoid dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask)\n{\n\tdispc_write_reg(dispc, DISPC_IRQSTATUS, mask);\n}\n\nvoid dispc_write_irqenable(struct dispc_device *dispc, u32 mask)\n{\n\tu32 old_mask = dispc_read_reg(dispc, DISPC_IRQENABLE);\n\n\t \n\tdispc_clear_irqstatus(dispc, (mask ^ old_mask) & mask);\n\n\tdispc_write_reg(dispc, DISPC_IRQENABLE, mask);\n\n\t \n\tdispc_read_reg(dispc, DISPC_IRQENABLE);\n}\n\nvoid dispc_enable_sidle(struct dispc_device *dispc)\n{\n\t \n\tREG_FLD_MOD(dispc, DISPC_SYSCONFIG, 2, 4, 3);\n}\n\nvoid dispc_disable_sidle(struct dispc_device *dispc)\n{\n\tREG_FLD_MOD(dispc, DISPC_SYSCONFIG, 1, 4, 3);\t \n}\n\nu32 dispc_mgr_gamma_size(struct dispc_device *dispc,\n\t\t\t\tenum omap_channel channel)\n{\n\tconst struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;\n\n\tif (!dispc->feat->has_gamma_table)\n\t\treturn 0;\n\n\treturn gdesc->len;\n}\n\nstatic void dispc_mgr_write_gamma_table(struct dispc_device *dispc,\n\t\t\t\t\tenum omap_channel channel)\n{\n\tconst struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;\n\tu32 *table = dispc->gamma_table[channel];\n\tunsigned int i;\n\n\tDSSDBG(\"%s: channel %d\\n\", __func__, channel);\n\n\tfor (i = 0; i < gdesc->len; ++i) {\n\t\tu32 v = table[i];\n\n\t\tif (gdesc->has_index)\n\t\t\tv |= i << 24;\n\t\telse if (i == 0)\n\t\t\tv |= 1 << 31;\n\n\t\tdispc_write_reg(dispc, gdesc->reg, v);\n\t}\n}\n\nstatic void dispc_restore_gamma_tables(struct dispc_device *dispc)\n{\n\tDSSDBG(\"%s()\\n\", __func__);\n\n\tif (!dispc->feat->has_gamma_table)\n\t\treturn;\n\n\tdispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD);\n\n\tdispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_DIGIT);\n\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD2))\n\t\tdispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD2);\n\n\tif (dispc_has_feature(dispc, FEAT_MGR_LCD3))\n\t\tdispc_mgr_write_gamma_table(dispc, OMAP_DSS_CHANNEL_LCD3);\n}\n\nstatic const struct drm_color_lut dispc_mgr_gamma_default_lut[] = {\n\t{ .red = 0, .green = 0, .blue = 0, },\n\t{ .red = U16_MAX, .green = U16_MAX, .blue = U16_MAX, },\n};\n\nvoid dispc_mgr_set_gamma(struct dispc_device *dispc,\n\t\t\t\tenum omap_channel channel,\n\t\t\t\tconst struct drm_color_lut *lut,\n\t\t\t\tunsigned int length)\n{\n\tconst struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;\n\tu32 *table = dispc->gamma_table[channel];\n\tuint i;\n\n\tDSSDBG(\"%s: channel %d, lut len %u, hw len %u\\n\", __func__,\n\t       channel, length, gdesc->len);\n\n\tif (!dispc->feat->has_gamma_table)\n\t\treturn;\n\n\tif (lut == NULL || length < 2) {\n\t\tlut = dispc_mgr_gamma_default_lut;\n\t\tlength = ARRAY_SIZE(dispc_mgr_gamma_default_lut);\n\t}\n\n\tfor (i = 0; i < length - 1; ++i) {\n\t\tuint first = i * (gdesc->len - 1) / (length - 1);\n\t\tuint last = (i + 1) * (gdesc->len - 1) / (length - 1);\n\t\tuint w = last - first;\n\t\tu16 r, g, b;\n\t\tuint j;\n\n\t\tif (w == 0)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j <= w; j++) {\n\t\t\tr = (lut[i].red * (w - j) + lut[i+1].red * j) / w;\n\t\t\tg = (lut[i].green * (w - j) + lut[i+1].green * j) / w;\n\t\t\tb = (lut[i].blue * (w - j) + lut[i+1].blue * j) / w;\n\n\t\t\tr >>= 16 - gdesc->bits;\n\t\t\tg >>= 16 - gdesc->bits;\n\t\t\tb >>= 16 - gdesc->bits;\n\n\t\t\ttable[first + j] = (r << (gdesc->bits * 2)) |\n\t\t\t\t(g << gdesc->bits) | b;\n\t\t}\n\t}\n\n\tif (dispc->is_enabled)\n\t\tdispc_mgr_write_gamma_table(dispc, channel);\n}\n\nstatic int dispc_init_gamma_tables(struct dispc_device *dispc)\n{\n\tint channel;\n\n\tif (!dispc->feat->has_gamma_table)\n\t\treturn 0;\n\n\tfor (channel = 0; channel < ARRAY_SIZE(dispc->gamma_table); channel++) {\n\t\tconst struct dispc_gamma_desc *gdesc = &mgr_desc[channel].gamma;\n\t\tu32 *gt;\n\n\t\tif (channel == OMAP_DSS_CHANNEL_LCD2 &&\n\t\t    !dispc_has_feature(dispc, FEAT_MGR_LCD2))\n\t\t\tcontinue;\n\n\t\tif (channel == OMAP_DSS_CHANNEL_LCD3 &&\n\t\t    !dispc_has_feature(dispc, FEAT_MGR_LCD3))\n\t\t\tcontinue;\n\n\t\tgt = devm_kmalloc_array(&dispc->pdev->dev, gdesc->len,\n\t\t\t\t\tsizeof(u32), GFP_KERNEL);\n\t\tif (!gt)\n\t\t\treturn -ENOMEM;\n\n\t\tdispc->gamma_table[channel] = gt;\n\n\t\tdispc_mgr_set_gamma(dispc, channel, NULL, 0);\n\t}\n\treturn 0;\n}\n\nstatic void _omap_dispc_initial_config(struct dispc_device *dispc)\n{\n\tu32 l;\n\n\t \n\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV)) {\n\t\tl = dispc_read_reg(dispc, DISPC_DIVISOR);\n\t\t \n\t\tl = FLD_MOD(l, 1, 0, 0);\n\t\tl = FLD_MOD(l, 1, 23, 16);\n\t\tdispc_write_reg(dispc, DISPC_DIVISOR, l);\n\n\t\tdispc->core_clk_rate = dispc_fclk_rate(dispc);\n\t}\n\n\t \n\tif (dispc->feat->has_gamma_table)\n\t\tREG_FLD_MOD(dispc, DISPC_CONFIG, 1, 3, 3);\n\n\t \n\tif (dispc_has_feature(dispc, FEAT_FUNCGATED) ||\n\t    dispc->feat->has_gamma_table)\n\t\tREG_FLD_MOD(dispc, DISPC_CONFIG, 1, 9, 9);\n\n\tdispc_set_loadmode(dispc, OMAP_DSS_LOAD_FRAME_ONLY);\n\n\tdispc_init_fifos(dispc);\n\n\tdispc_configure_burst_sizes(dispc);\n\n\tdispc_ovl_enable_zorder_planes(dispc);\n\n\tif (dispc->feat->mstandby_workaround)\n\t\tREG_FLD_MOD(dispc, DISPC_MSTANDBY_CTRL, 1, 0, 0);\n\n\tif (dispc_has_feature(dispc, FEAT_MFLAG))\n\t\tdispc_init_mflag(dispc);\n}\n\nstatic const enum dispc_feature_id omap2_dispc_features_list[] = {\n\tFEAT_LCDENABLEPOL,\n\tFEAT_LCDENABLESIGNAL,\n\tFEAT_PCKFREEENABLE,\n\tFEAT_FUNCGATED,\n\tFEAT_ROWREPEATENABLE,\n\tFEAT_RESIZECONF,\n};\n\nstatic const enum dispc_feature_id omap3_dispc_features_list[] = {\n\tFEAT_LCDENABLEPOL,\n\tFEAT_LCDENABLESIGNAL,\n\tFEAT_PCKFREEENABLE,\n\tFEAT_FUNCGATED,\n\tFEAT_LINEBUFFERSPLIT,\n\tFEAT_ROWREPEATENABLE,\n\tFEAT_RESIZECONF,\n\tFEAT_CPR,\n\tFEAT_PRELOAD,\n\tFEAT_FIR_COEF_V,\n\tFEAT_ALPHA_FIXED_ZORDER,\n\tFEAT_FIFO_MERGE,\n\tFEAT_OMAP3_DSI_FIFO_BUG,\n};\n\nstatic const enum dispc_feature_id am43xx_dispc_features_list[] = {\n\tFEAT_LCDENABLEPOL,\n\tFEAT_LCDENABLESIGNAL,\n\tFEAT_PCKFREEENABLE,\n\tFEAT_FUNCGATED,\n\tFEAT_LINEBUFFERSPLIT,\n\tFEAT_ROWREPEATENABLE,\n\tFEAT_RESIZECONF,\n\tFEAT_CPR,\n\tFEAT_PRELOAD,\n\tFEAT_FIR_COEF_V,\n\tFEAT_ALPHA_FIXED_ZORDER,\n\tFEAT_FIFO_MERGE,\n};\n\nstatic const enum dispc_feature_id omap4_dispc_features_list[] = {\n\tFEAT_MGR_LCD2,\n\tFEAT_CORE_CLK_DIV,\n\tFEAT_HANDLE_UV_SEPARATE,\n\tFEAT_ATTR2,\n\tFEAT_CPR,\n\tFEAT_PRELOAD,\n\tFEAT_FIR_COEF_V,\n\tFEAT_ALPHA_FREE_ZORDER,\n\tFEAT_FIFO_MERGE,\n\tFEAT_BURST_2D,\n};\n\nstatic const enum dispc_feature_id omap5_dispc_features_list[] = {\n\tFEAT_MGR_LCD2,\n\tFEAT_MGR_LCD3,\n\tFEAT_CORE_CLK_DIV,\n\tFEAT_HANDLE_UV_SEPARATE,\n\tFEAT_ATTR2,\n\tFEAT_CPR,\n\tFEAT_PRELOAD,\n\tFEAT_FIR_COEF_V,\n\tFEAT_ALPHA_FREE_ZORDER,\n\tFEAT_FIFO_MERGE,\n\tFEAT_BURST_2D,\n\tFEAT_MFLAG,\n};\n\nstatic const struct dss_reg_field omap2_dispc_reg_fields[] = {\n\t[FEAT_REG_FIRHINC]\t\t\t= { 11, 0 },\n\t[FEAT_REG_FIRVINC]\t\t\t= { 27, 16 },\n\t[FEAT_REG_FIFOLOWTHRESHOLD]\t\t= { 8, 0 },\n\t[FEAT_REG_FIFOHIGHTHRESHOLD]\t\t= { 24, 16 },\n\t[FEAT_REG_FIFOSIZE]\t\t\t= { 8, 0 },\n\t[FEAT_REG_HORIZONTALACCU]\t\t= { 9, 0 },\n\t[FEAT_REG_VERTICALACCU]\t\t\t= { 25, 16 },\n};\n\nstatic const struct dss_reg_field omap3_dispc_reg_fields[] = {\n\t[FEAT_REG_FIRHINC]\t\t\t= { 12, 0 },\n\t[FEAT_REG_FIRVINC]\t\t\t= { 28, 16 },\n\t[FEAT_REG_FIFOLOWTHRESHOLD]\t\t= { 11, 0 },\n\t[FEAT_REG_FIFOHIGHTHRESHOLD]\t\t= { 27, 16 },\n\t[FEAT_REG_FIFOSIZE]\t\t\t= { 10, 0 },\n\t[FEAT_REG_HORIZONTALACCU]\t\t= { 9, 0 },\n\t[FEAT_REG_VERTICALACCU]\t\t\t= { 25, 16 },\n};\n\nstatic const struct dss_reg_field omap4_dispc_reg_fields[] = {\n\t[FEAT_REG_FIRHINC]\t\t\t= { 12, 0 },\n\t[FEAT_REG_FIRVINC]\t\t\t= { 28, 16 },\n\t[FEAT_REG_FIFOLOWTHRESHOLD]\t\t= { 15, 0 },\n\t[FEAT_REG_FIFOHIGHTHRESHOLD]\t\t= { 31, 16 },\n\t[FEAT_REG_FIFOSIZE]\t\t\t= { 15, 0 },\n\t[FEAT_REG_HORIZONTALACCU]\t\t= { 10, 0 },\n\t[FEAT_REG_VERTICALACCU]\t\t\t= { 26, 16 },\n};\n\nstatic const enum omap_overlay_caps omap2_dispc_overlay_caps[] = {\n\t \n\tOMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n};\n\nstatic const enum omap_overlay_caps omap3430_dispc_overlay_caps[] = {\n\t \n\tOMAP_DSS_OVL_CAP_GLOBAL_ALPHA | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,\n};\n\nstatic const enum omap_overlay_caps omap3630_dispc_overlay_caps[] = {\n\t \n\tOMAP_DSS_OVL_CAP_GLOBAL_ALPHA | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n};\n\nstatic const enum omap_overlay_caps omap4_dispc_overlay_caps[] = {\n\t \n\tOMAP_DSS_OVL_CAP_GLOBAL_ALPHA | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_ZORDER | OMAP_DSS_OVL_CAP_POS |\n\t\tOMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_ZORDER |\n\t\tOMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_ZORDER |\n\t\tOMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,\n\n\t \n\tOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_GLOBAL_ALPHA |\n\t\tOMAP_DSS_OVL_CAP_PRE_MULT_ALPHA | OMAP_DSS_OVL_CAP_ZORDER |\n\t\tOMAP_DSS_OVL_CAP_POS | OMAP_DSS_OVL_CAP_REPLICATION,\n};\n\n#define COLOR_ARRAY(arr...) (const u32[]) { arr, 0 }\n\nstatic const u32 *omap2_dispc_supported_color_modes[] = {\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGBX4444, DRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_RGB888),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY),\n};\n\nstatic const u32 *omap3_dispc_supported_color_modes[] = {\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGBX4444, DRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_RGBX8888),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_RGB888,\n\tDRM_FORMAT_RGBX4444, DRM_FORMAT_RGB565,\n\tDRM_FORMAT_YUYV, DRM_FORMAT_UYVY),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGBX4444, DRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY, DRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_RGBX8888),\n};\n\nstatic const u32 *omap4_dispc_supported_color_modes[] = {\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGBX4444, DRM_FORMAT_ARGB4444,\n\tDRM_FORMAT_RGB565, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_RGBX8888,\n\tDRM_FORMAT_ARGB1555, DRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB1555),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,\n\tDRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,\n\tDRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_UYVY,\n\tDRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_RGBX8888),\n\n        \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,\n\tDRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,\n\tDRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_UYVY,\n\tDRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_RGBX8888),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,\n\tDRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,\n\tDRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_UYVY,\n\tDRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_RGBX8888),\n\n\t \n\tCOLOR_ARRAY(\n\tDRM_FORMAT_RGB565, DRM_FORMAT_RGBX4444,\n\tDRM_FORMAT_YUYV, DRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_RGBA8888, DRM_FORMAT_NV12,\n\tDRM_FORMAT_RGBA4444, DRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_RGB888, DRM_FORMAT_UYVY,\n\tDRM_FORMAT_ARGB4444, DRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB8888, DRM_FORMAT_XRGB4444,\n\tDRM_FORMAT_RGBX8888),\n};\n\nstatic const u32 omap3_dispc_supported_scaler_color_modes[] = {\n\tDRM_FORMAT_XRGB8888, DRM_FORMAT_RGB565, DRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY,\n\t0,\n};\n\nstatic const struct dispc_features omap24xx_dispc_feats = {\n\t.sw_start\t\t=\t5,\n\t.fp_start\t\t=\t15,\n\t.bp_start\t\t=\t27,\n\t.sw_max\t\t\t=\t64,\n\t.vp_max\t\t\t=\t255,\n\t.hp_max\t\t\t=\t256,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t66500000,\n\t.max_downscale\t\t=\t2,\n\t \n\t.max_line_width\t\t=\t768,\n\t.min_pcd\t\t=\t2,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_24xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_24xx,\n\t.num_fifos\t\t=\t3,\n\t.features\t\t=\tomap2_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(omap2_dispc_features_list),\n\t.reg_fields\t\t=\tomap2_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap2_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap2_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap2_dispc_supported_color_modes,\n\t.supported_scaler_color_modes = COLOR_ARRAY(DRM_FORMAT_XRGB8888),\n\t.num_mgrs\t\t=\t2,\n\t.num_ovls\t\t=\t3,\n\t.buffer_size_unit\t=\t1,\n\t.burst_size_unit\t=\t8,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap34xx_rev1_0_dispc_feats = {\n\t.sw_start\t\t=\t5,\n\t.fp_start\t\t=\t15,\n\t.bp_start\t\t=\t27,\n\t.sw_max\t\t\t=\t64,\n\t.vp_max\t\t\t=\t255,\n\t.hp_max\t\t\t=\t256,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t173000000,\n\t.max_tv_pclk\t\t=\t59000000,\n\t.max_downscale\t\t=\t4,\n\t.max_line_width\t\t=\t1024,\n\t.min_pcd\t\t=\t1,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_34xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_34xx,\n\t.num_fifos\t\t=\t3,\n\t.features\t\t=\tomap3_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(omap3_dispc_features_list),\n\t.reg_fields\t\t=\tomap3_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap3_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap3430_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap3_dispc_supported_color_modes,\n\t.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,\n\t.num_mgrs\t\t=\t2,\n\t.num_ovls\t\t=\t3,\n\t.buffer_size_unit\t=\t1,\n\t.burst_size_unit\t=\t8,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap34xx_rev3_0_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t173000000,\n\t.max_tv_pclk\t\t=\t59000000,\n\t.max_downscale\t\t=\t4,\n\t.max_line_width\t\t=\t1024,\n\t.min_pcd\t\t=\t1,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_34xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_34xx,\n\t.num_fifos\t\t=\t3,\n\t.features\t\t=\tomap3_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(omap3_dispc_features_list),\n\t.reg_fields\t\t=\tomap3_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap3_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap3430_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap3_dispc_supported_color_modes,\n\t.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,\n\t.num_mgrs\t\t=\t2,\n\t.num_ovls\t\t=\t3,\n\t.buffer_size_unit\t=\t1,\n\t.burst_size_unit\t=\t8,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap36xx_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t173000000,\n\t.max_tv_pclk\t\t=\t59000000,\n\t.max_downscale\t\t=\t4,\n\t.max_line_width\t\t=\t1024,\n\t.min_pcd\t\t=\t1,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_34xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_34xx,\n\t.num_fifos\t\t=\t3,\n\t.features\t\t=\tomap3_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(omap3_dispc_features_list),\n\t.reg_fields\t\t=\tomap3_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap3_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap3630_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap3_dispc_supported_color_modes,\n\t.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,\n\t.num_mgrs\t\t=\t2,\n\t.num_ovls\t\t=\t3,\n\t.buffer_size_unit\t=\t1,\n\t.burst_size_unit\t=\t8,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features am43xx_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t173000000,\n\t.max_tv_pclk\t\t=\t59000000,\n\t.max_downscale\t\t=\t4,\n\t.max_line_width\t\t=\t1024,\n\t.min_pcd\t\t=\t1,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_34xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_34xx,\n\t.num_fifos\t\t=\t3,\n\t.features\t\t=\tam43xx_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(am43xx_dispc_features_list),\n\t.reg_fields\t\t=\tomap3_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap3_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap3430_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap3_dispc_supported_color_modes,\n\t.supported_scaler_color_modes = omap3_dispc_supported_scaler_color_modes,\n\t.num_mgrs\t\t=\t1,\n\t.num_ovls\t\t=\t3,\n\t.buffer_size_unit\t=\t1,\n\t.burst_size_unit\t=\t8,\n\t.no_framedone_tv\t=\ttrue,\n\t.set_max_preload\t=\tfalse,\n\t.last_pixel_inc_missing\t=\ttrue,\n};\n\nstatic const struct dispc_features omap44xx_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t10,\n\t.mgr_height_start\t=\t26,\n\t.mgr_width_max\t\t=\t2048,\n\t.mgr_height_max\t\t=\t2048,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t2048,\n\t.max_lcd_pclk\t\t=\t170000000,\n\t.max_tv_pclk\t\t=\t185625000,\n\t.max_downscale\t\t=\t4,\n\t.max_line_width\t\t=\t2048,\n\t.min_pcd\t\t=\t1,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_44xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_44xx,\n\t.num_fifos\t\t=\t5,\n\t.features\t\t=\tomap4_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(omap4_dispc_features_list),\n\t.reg_fields\t\t=\tomap4_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap4_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap4_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap4_dispc_supported_color_modes,\n\t.num_mgrs\t\t=\t3,\n\t.num_ovls\t\t=\t4,\n\t.buffer_size_unit\t=\t16,\n\t.burst_size_unit\t=\t16,\n\t.gfx_fifo_workaround\t=\ttrue,\n\t.set_max_preload\t=\ttrue,\n\t.supports_sync_align\t=\ttrue,\n\t.has_writeback\t\t=\ttrue,\n\t.supports_double_pixel\t=\ttrue,\n\t.reverse_ilace_field_order =\ttrue,\n\t.has_gamma_table\t=\ttrue,\n\t.has_gamma_i734_bug\t=\ttrue,\n};\n\nstatic const struct dispc_features omap54xx_dispc_feats = {\n\t.sw_start\t\t=\t7,\n\t.fp_start\t\t=\t19,\n\t.bp_start\t\t=\t31,\n\t.sw_max\t\t\t=\t256,\n\t.vp_max\t\t\t=\t4095,\n\t.hp_max\t\t\t=\t4096,\n\t.mgr_width_start\t=\t11,\n\t.mgr_height_start\t=\t27,\n\t.mgr_width_max\t\t=\t4096,\n\t.mgr_height_max\t\t=\t4096,\n\t.ovl_width_max\t\t=\t2048,\n\t.ovl_height_max\t\t=\t4096,\n\t.max_lcd_pclk\t\t=\t170000000,\n\t.max_tv_pclk\t\t=\t192000000,\n\t.max_downscale\t\t=\t4,\n\t.max_line_width\t\t=\t2048,\n\t.min_pcd\t\t=\t1,\n\t.calc_scaling\t\t=\tdispc_ovl_calc_scaling_44xx,\n\t.calc_core_clk\t\t=\tcalc_core_clk_44xx,\n\t.num_fifos\t\t=\t5,\n\t.features\t\t=\tomap5_dispc_features_list,\n\t.num_features\t\t=\tARRAY_SIZE(omap5_dispc_features_list),\n\t.reg_fields\t\t=\tomap4_dispc_reg_fields,\n\t.num_reg_fields\t\t=\tARRAY_SIZE(omap4_dispc_reg_fields),\n\t.overlay_caps\t\t=\tomap4_dispc_overlay_caps,\n\t.supported_color_modes\t=\tomap4_dispc_supported_color_modes,\n\t.num_mgrs\t\t=\t4,\n\t.num_ovls\t\t=\t4,\n\t.buffer_size_unit\t=\t16,\n\t.burst_size_unit\t=\t16,\n\t.gfx_fifo_workaround\t=\ttrue,\n\t.mstandby_workaround\t=\ttrue,\n\t.set_max_preload\t=\ttrue,\n\t.supports_sync_align\t=\ttrue,\n\t.has_writeback\t\t=\ttrue,\n\t.supports_double_pixel\t=\ttrue,\n\t.reverse_ilace_field_order =\ttrue,\n\t.has_gamma_table\t=\ttrue,\n\t.has_gamma_i734_bug\t=\ttrue,\n};\n\nstatic irqreturn_t dispc_irq_handler(int irq, void *arg)\n{\n\tstruct dispc_device *dispc = arg;\n\n\tif (!dispc->is_enabled)\n\t\treturn IRQ_NONE;\n\n\treturn dispc->user_handler(irq, dispc->user_data);\n}\n\nint dispc_request_irq(struct dispc_device *dispc, irq_handler_t handler,\n\t\t\t     void *dev_id)\n{\n\tint r;\n\n\tif (dispc->user_handler != NULL)\n\t\treturn -EBUSY;\n\n\tdispc->user_handler = handler;\n\tdispc->user_data = dev_id;\n\n\t \n\tsmp_wmb();\n\n\tr = devm_request_irq(&dispc->pdev->dev, dispc->irq, dispc_irq_handler,\n\t\t\t     IRQF_SHARED, \"OMAP DISPC\", dispc);\n\tif (r) {\n\t\tdispc->user_handler = NULL;\n\t\tdispc->user_data = NULL;\n\t}\n\n\treturn r;\n}\n\nvoid dispc_free_irq(struct dispc_device *dispc, void *dev_id)\n{\n\tdevm_free_irq(&dispc->pdev->dev, dispc->irq, dispc);\n\n\tdispc->user_handler = NULL;\n\tdispc->user_data = NULL;\n}\n\nu32 dispc_get_memory_bandwidth_limit(struct dispc_device *dispc)\n{\n\tu32 limit = 0;\n\n\t \n\tof_property_read_u32(dispc->pdev->dev.of_node, \"max-memory-bandwidth\",\n\t\t\t     &limit);\n\n\treturn limit;\n}\n\n \n\nstatic const struct dispc_errata_i734_data {\n\tstruct videomode vm;\n\tstruct omap_overlay_info ovli;\n\tstruct omap_overlay_manager_info mgri;\n\tstruct dss_lcd_mgr_config lcd_conf;\n} i734 = {\n\t.vm = {\n\t\t.hactive = 8, .vactive = 1,\n\t\t.pixelclock = 16000000,\n\t\t.hsync_len = 8, .hfront_porch = 4, .hback_porch = 4,\n\t\t.vsync_len = 1, .vfront_porch = 1, .vback_porch = 1,\n\n\t\t.flags = DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW |\n\t\t\t DISPLAY_FLAGS_DE_HIGH | DISPLAY_FLAGS_SYNC_POSEDGE |\n\t\t\t DISPLAY_FLAGS_PIXDATA_POSEDGE,\n\t},\n\t.ovli = {\n\t\t.screen_width = 1,\n\t\t.width = 1, .height = 1,\n\t\t.fourcc = DRM_FORMAT_XRGB8888,\n\t\t.rotation = DRM_MODE_ROTATE_0,\n\t\t.rotation_type = OMAP_DSS_ROT_NONE,\n\t\t.pos_x = 0, .pos_y = 0,\n\t\t.out_width = 0, .out_height = 0,\n\t\t.global_alpha = 0xff,\n\t\t.pre_mult_alpha = 0,\n\t\t.zorder = 0,\n\t},\n\t.mgri = {\n\t\t.default_color = 0,\n\t\t.trans_enabled = false,\n\t\t.partial_alpha_enabled = false,\n\t\t.cpr_enable = false,\n\t},\n\t.lcd_conf = {\n\t\t.io_pad_mode = DSS_IO_PAD_MODE_BYPASS,\n\t\t.stallmode = false,\n\t\t.fifohandcheck = false,\n\t\t.clock_info = {\n\t\t\t.lck_div = 1,\n\t\t\t.pck_div = 2,\n\t\t},\n\t\t.video_port_width = 24,\n\t\t.lcden_sig_polarity = 0,\n\t},\n};\n\nstatic struct i734_buf {\n\tsize_t size;\n\tdma_addr_t paddr;\n\tvoid *vaddr;\n} i734_buf;\n\nstatic int dispc_errata_i734_wa_init(struct dispc_device *dispc)\n{\n\tif (!dispc->feat->has_gamma_i734_bug)\n\t\treturn 0;\n\n\ti734_buf.size = i734.ovli.width * i734.ovli.height *\n\t\tcolor_mode_to_bpp(i734.ovli.fourcc) / 8;\n\n\ti734_buf.vaddr = dma_alloc_wc(&dispc->pdev->dev, i734_buf.size,\n\t\t\t\t      &i734_buf.paddr, GFP_KERNEL);\n\tif (!i734_buf.vaddr) {\n\t\tdev_err(&dispc->pdev->dev, \"%s: dma_alloc_wc failed\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void dispc_errata_i734_wa_fini(struct dispc_device *dispc)\n{\n\tif (!dispc->feat->has_gamma_i734_bug)\n\t\treturn;\n\n\tdma_free_wc(&dispc->pdev->dev, i734_buf.size, i734_buf.vaddr,\n\t\t    i734_buf.paddr);\n}\n\nstatic void dispc_errata_i734_wa(struct dispc_device *dispc)\n{\n\tu32 framedone_irq = dispc_mgr_get_framedone_irq(dispc,\n\t\t\t\t\t\t\tOMAP_DSS_CHANNEL_LCD);\n\tstruct omap_overlay_info ovli;\n\tstruct dss_lcd_mgr_config lcd_conf;\n\tu32 gatestate;\n\tunsigned int count;\n\n\tif (!dispc->feat->has_gamma_i734_bug)\n\t\treturn;\n\n\tgatestate = REG_GET(dispc, DISPC_CONFIG, 8, 4);\n\n\tovli = i734.ovli;\n\tovli.paddr = i734_buf.paddr;\n\tlcd_conf = i734.lcd_conf;\n\n\t \n\tREG_FLD_MOD(dispc, DISPC_CONFIG, 0x1f, 8, 4);\n\n\t \n\tdispc_ovl_setup(dispc, OMAP_DSS_GFX, &ovli, &i734.vm, false,\n\t\t\tOMAP_DSS_CHANNEL_LCD);\n\tdispc_ovl_enable(dispc, OMAP_DSS_GFX, true);\n\n\t \n\tdispc_mgr_setup(dispc, OMAP_DSS_CHANNEL_LCD, &i734.mgri);\n\tdispc_calc_clock_rates(dispc, dss_get_dispc_clk_rate(dispc->dss),\n\t\t\t       &lcd_conf.clock_info);\n\tdispc_mgr_set_lcd_config(dispc, OMAP_DSS_CHANNEL_LCD, &lcd_conf);\n\tdispc_mgr_set_timings(dispc, OMAP_DSS_CHANNEL_LCD, &i734.vm);\n\n\tdispc_clear_irqstatus(dispc, framedone_irq);\n\n\t \n\tdispc_mgr_enable(dispc, OMAP_DSS_CHANNEL_LCD, true);\n\tdispc_mgr_enable(dispc, OMAP_DSS_CHANNEL_LCD, false);\n\n\t \n\tcount = 0;\n\twhile (!(dispc_read_irqstatus(dispc) & framedone_irq)) {\n\t\tif (count++ > 10000) {\n\t\t\tdev_err(&dispc->pdev->dev, \"%s: framedone timeout\\n\",\n\t\t\t\t__func__);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdispc_ovl_enable(dispc, OMAP_DSS_GFX, false);\n\n\t \n\tdispc_clear_irqstatus(dispc, 0xffffffff);\n\n\t \n\tREG_FLD_MOD(dispc, DISPC_CONFIG, gatestate, 8, 4);\n}\n\n \nstatic const struct of_device_id dispc_of_match[] = {\n\t{ .compatible = \"ti,omap2-dispc\", .data = &omap24xx_dispc_feats },\n\t{ .compatible = \"ti,omap3-dispc\", .data = &omap36xx_dispc_feats },\n\t{ .compatible = \"ti,omap4-dispc\", .data = &omap44xx_dispc_feats },\n\t{ .compatible = \"ti,omap5-dispc\", .data = &omap54xx_dispc_feats },\n\t{ .compatible = \"ti,dra7-dispc\",  .data = &omap54xx_dispc_feats },\n\t{},\n};\n\nstatic const struct soc_device_attribute dispc_soc_devices[] = {\n\t{ .machine = \"OMAP3[45]*\",\n\t  .revision = \"ES[12].?\",\t.data = &omap34xx_rev1_0_dispc_feats },\n\t{ .machine = \"OMAP3[45]*\",\t.data = &omap34xx_rev3_0_dispc_feats },\n\t{ .machine = \"AM35*\",\t\t.data = &omap34xx_rev3_0_dispc_feats },\n\t{ .machine = \"AM43*\",\t\t.data = &am43xx_dispc_feats },\n\t{   }\n};\n\nstatic int dispc_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tconst struct soc_device_attribute *soc;\n\tstruct dss_device *dss = dss_get_device(master);\n\tstruct dispc_device *dispc;\n\tu32 rev;\n\tint r = 0;\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tdispc = kzalloc(sizeof(*dispc), GFP_KERNEL);\n\tif (!dispc)\n\t\treturn -ENOMEM;\n\n\tdispc->pdev = pdev;\n\tplatform_set_drvdata(pdev, dispc);\n\tdispc->dss = dss;\n\n\t \n\tsoc = soc_device_match(dispc_soc_devices);\n\tif (soc)\n\t\tdispc->feat = soc->data;\n\telse\n\t\tdispc->feat = of_match_device(dispc_of_match, &pdev->dev)->data;\n\n\tr = dispc_errata_i734_wa_init(dispc);\n\tif (r)\n\t\tgoto err_free;\n\n\tdispc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dispc->base)) {\n\t\tr = PTR_ERR(dispc->base);\n\t\tgoto err_free;\n\t}\n\n\tdispc->irq = platform_get_irq(dispc->pdev, 0);\n\tif (dispc->irq < 0) {\n\t\tDSSERR(\"platform_get_irq failed\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err_free;\n\t}\n\n\tif (np && of_property_read_bool(np, \"syscon-pol\")) {\n\t\tdispc->syscon_pol = syscon_regmap_lookup_by_phandle(np, \"syscon-pol\");\n\t\tif (IS_ERR(dispc->syscon_pol)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get syscon-pol regmap\\n\");\n\t\t\tr = PTR_ERR(dispc->syscon_pol);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (of_property_read_u32_index(np, \"syscon-pol\", 1,\n\t\t\t\t&dispc->syscon_pol_offset)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get syscon-pol offset\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tr = dispc_init_gamma_tables(dispc);\n\tif (r)\n\t\tgoto err_free;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tr = dispc_runtime_get(dispc);\n\tif (r)\n\t\tgoto err_runtime_get;\n\n\t_omap_dispc_initial_config(dispc);\n\n\trev = dispc_read_reg(dispc, DISPC_REVISION);\n\tdev_dbg(&pdev->dev, \"OMAP DISPC rev %d.%d\\n\",\n\t       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\n\n\tdispc_runtime_put(dispc);\n\n\tdss->dispc = dispc;\n\n\tdispc->debugfs = dss_debugfs_create_file(dss, \"dispc\", dispc_dump_regs,\n\t\t\t\t\t\t dispc);\n\n\treturn 0;\n\nerr_runtime_get:\n\tpm_runtime_disable(&pdev->dev);\nerr_free:\n\tkfree(dispc);\n\treturn r;\n}\n\nstatic void dispc_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct dispc_device *dispc = dev_get_drvdata(dev);\n\tstruct dss_device *dss = dispc->dss;\n\n\tdss_debugfs_remove_file(dispc->debugfs);\n\n\tdss->dispc = NULL;\n\n\tpm_runtime_disable(dev);\n\n\tdispc_errata_i734_wa_fini(dispc);\n\n\tkfree(dispc);\n}\n\nstatic const struct component_ops dispc_component_ops = {\n\t.bind\t= dispc_bind,\n\t.unbind\t= dispc_unbind,\n};\n\nstatic int dispc_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &dispc_component_ops);\n}\n\nstatic void dispc_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &dispc_component_ops);\n}\n\nstatic __maybe_unused int dispc_runtime_suspend(struct device *dev)\n{\n\tstruct dispc_device *dispc = dev_get_drvdata(dev);\n\n\tdispc->is_enabled = false;\n\t \n\tsmp_wmb();\n\t \n\tsynchronize_irq(dispc->irq);\n\n\tdispc_save_context(dispc);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int dispc_runtime_resume(struct device *dev)\n{\n\tstruct dispc_device *dispc = dev_get_drvdata(dev);\n\n\t \n\tif (REG_GET(dispc, DISPC_CONFIG, 2, 1) != OMAP_DSS_LOAD_FRAME_ONLY) {\n\t\t_omap_dispc_initial_config(dispc);\n\n\t\tdispc_errata_i734_wa(dispc);\n\n\t\tdispc_restore_context(dispc);\n\n\t\tdispc_restore_gamma_tables(dispc);\n\t}\n\n\tdispc->is_enabled = true;\n\t \n\tsmp_wmb();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dispc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(dispc_runtime_suspend, dispc_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n};\n\nstruct platform_driver omap_dispchw_driver = {\n\t.probe\t\t= dispc_probe,\n\t.remove_new     = dispc_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_dispc\",\n\t\t.pm\t= &dispc_pm_ops,\n\t\t.of_match_table = dispc_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}