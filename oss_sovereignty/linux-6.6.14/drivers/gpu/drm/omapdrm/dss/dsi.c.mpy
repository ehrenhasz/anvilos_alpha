{
  "module_name": "dsi.c",
  "hash_id": "1a2c647676027d7f72b45c120fba14313b5e8a134c5008da668dddb3ce85f12d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/dsi.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DSI\"\n\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/semaphore.h>\n#include <linux/seq_file.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/component.h>\n#include <linux/sys_soc.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_mipi_dsi.h>\n#include <drm/drm_panel.h>\n#include <video/mipi_display.h>\n\n#include \"omapdss.h\"\n#include \"dss.h\"\n\n#define DSI_CATCH_MISSING_TE\n\n#include \"dsi.h\"\n\n#define REG_GET(dsi, idx, start, end) \\\n\tFLD_GET(dsi_read_reg(dsi, idx), start, end)\n\n#define REG_FLD_MOD(dsi, idx, val, start, end) \\\n\tdsi_write_reg(dsi, idx, FLD_MOD(dsi_read_reg(dsi, idx), val, start, end))\n\nstatic int dsi_init_dispc(struct dsi_data *dsi);\nstatic void dsi_uninit_dispc(struct dsi_data *dsi);\n\nstatic int dsi_vc_send_null(struct dsi_data *dsi, int vc, int channel);\n\nstatic ssize_t _omap_dsi_host_transfer(struct dsi_data *dsi, int vc,\n\t\t\t\t       const struct mipi_dsi_msg *msg);\n\n#ifdef DSI_PERF_MEASURE\nstatic bool dsi_perf;\nmodule_param(dsi_perf, bool, 0644);\n#endif\n\n \n#define VC_VIDEO\t0\n#define VC_CMD\t\t1\n\n#define drm_bridge_to_dsi(bridge) \\\n\tcontainer_of(bridge, struct dsi_data, bridge)\n\nstatic inline struct dsi_data *to_dsi_data(struct omap_dss_device *dssdev)\n{\n\treturn dev_get_drvdata(dssdev->dev);\n}\n\nstatic inline struct dsi_data *host_to_omap(struct mipi_dsi_host *host)\n{\n\treturn container_of(host, struct dsi_data, host);\n}\n\nstatic inline void dsi_write_reg(struct dsi_data *dsi,\n\t\t\t\t const struct dsi_reg idx, u32 val)\n{\n\tvoid __iomem *base;\n\n\tswitch(idx.module) {\n\t\tcase DSI_PROTO: base = dsi->proto_base; break;\n\t\tcase DSI_PHY: base = dsi->phy_base; break;\n\t\tcase DSI_PLL: base = dsi->pll_base; break;\n\t\tdefault: return;\n\t}\n\n\t__raw_writel(val, base + idx.idx);\n}\n\nstatic inline u32 dsi_read_reg(struct dsi_data *dsi, const struct dsi_reg idx)\n{\n\tvoid __iomem *base;\n\n\tswitch(idx.module) {\n\t\tcase DSI_PROTO: base = dsi->proto_base; break;\n\t\tcase DSI_PHY: base = dsi->phy_base; break;\n\t\tcase DSI_PLL: base = dsi->pll_base; break;\n\t\tdefault: return 0;\n\t}\n\n\treturn __raw_readl(base + idx.idx);\n}\n\nstatic void dsi_bus_lock(struct dsi_data *dsi)\n{\n\tdown(&dsi->bus_lock);\n}\n\nstatic void dsi_bus_unlock(struct dsi_data *dsi)\n{\n\tup(&dsi->bus_lock);\n}\n\nstatic bool dsi_bus_is_locked(struct dsi_data *dsi)\n{\n\treturn dsi->bus_lock.count == 0;\n}\n\nstatic void dsi_completion_handler(void *data, u32 mask)\n{\n\tcomplete((struct completion *)data);\n}\n\nstatic inline bool wait_for_bit_change(struct dsi_data *dsi,\n\t\t\t\t       const struct dsi_reg idx,\n\t\t\t\t       int bitnum, int value)\n{\n\tunsigned long timeout;\n\tktime_t wait;\n\tint t;\n\n\t \n\tt = 100;\n\twhile (t-- > 0) {\n\t\tif (REG_GET(dsi, idx, bitnum, bitnum) == value)\n\t\t\treturn true;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (time_before(jiffies, timeout)) {\n\t\tif (REG_GET(dsi, idx, bitnum, bitnum) == value)\n\t\t\treturn true;\n\n\t\twait = ns_to_ktime(1000 * 1000);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\n\t}\n\n\treturn false;\n}\n\n#ifdef DSI_PERF_MEASURE\nstatic void dsi_perf_mark_setup(struct dsi_data *dsi)\n{\n\tdsi->perf_setup_time = ktime_get();\n}\n\nstatic void dsi_perf_mark_start(struct dsi_data *dsi)\n{\n\tdsi->perf_start_time = ktime_get();\n}\n\nstatic void dsi_perf_show(struct dsi_data *dsi, const char *name)\n{\n\tktime_t t, setup_time, trans_time;\n\tu32 total_bytes;\n\tu32 setup_us, trans_us, total_us;\n\n\tif (!dsi_perf)\n\t\treturn;\n\n\tt = ktime_get();\n\n\tsetup_time = ktime_sub(dsi->perf_start_time, dsi->perf_setup_time);\n\tsetup_us = (u32)ktime_to_us(setup_time);\n\tif (setup_us == 0)\n\t\tsetup_us = 1;\n\n\ttrans_time = ktime_sub(t, dsi->perf_start_time);\n\ttrans_us = (u32)ktime_to_us(trans_time);\n\tif (trans_us == 0)\n\t\ttrans_us = 1;\n\n\ttotal_us = setup_us + trans_us;\n\n\ttotal_bytes = dsi->update_bytes;\n\n\tpr_info(\"DSI(%s): %u us + %u us = %u us (%uHz), %u bytes, %u kbytes/sec\\n\",\n\t\tname,\n\t\tsetup_us,\n\t\ttrans_us,\n\t\ttotal_us,\n\t\t1000 * 1000 / total_us,\n\t\ttotal_bytes,\n\t\ttotal_bytes * 1000 / total_us);\n}\n#else\nstatic inline void dsi_perf_mark_setup(struct dsi_data *dsi)\n{\n}\n\nstatic inline void dsi_perf_mark_start(struct dsi_data *dsi)\n{\n}\n\nstatic inline void dsi_perf_show(struct dsi_data *dsi, const char *name)\n{\n}\n#endif\n\nstatic int verbose_irq;\n\nstatic void print_irq_status(u32 status)\n{\n\tif (status == 0)\n\t\treturn;\n\n\tif (!verbose_irq && (status & ~DSI_IRQ_CHANNEL_MASK) == 0)\n\t\treturn;\n\n#define PIS(x) (status & DSI_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DSI IRQ: 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\tstatus,\n\t\tverbose_irq ? PIS(VC0) : \"\",\n\t\tverbose_irq ? PIS(VC1) : \"\",\n\t\tverbose_irq ? PIS(VC2) : \"\",\n\t\tverbose_irq ? PIS(VC3) : \"\",\n\t\tPIS(WAKEUP),\n\t\tPIS(RESYNC),\n\t\tPIS(PLL_LOCK),\n\t\tPIS(PLL_UNLOCK),\n\t\tPIS(PLL_RECALL),\n\t\tPIS(COMPLEXIO_ERR),\n\t\tPIS(HS_TX_TIMEOUT),\n\t\tPIS(LP_RX_TIMEOUT),\n\t\tPIS(TE_TRIGGER),\n\t\tPIS(ACK_TRIGGER),\n\t\tPIS(SYNC_LOST),\n\t\tPIS(LDO_POWER_GOOD),\n\t\tPIS(TA_TIMEOUT));\n#undef PIS\n}\n\nstatic void print_irq_status_vc(int vc, u32 status)\n{\n\tif (status == 0)\n\t\treturn;\n\n\tif (!verbose_irq && (status & ~DSI_VC_IRQ_PACKET_SENT) == 0)\n\t\treturn;\n\n#define PIS(x) (status & DSI_VC_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DSI VC(%d) IRQ 0x%x: %s%s%s%s%s%s%s%s%s\\n\",\n\t\tvc,\n\t\tstatus,\n\t\tPIS(CS),\n\t\tPIS(ECC_CORR),\n\t\tPIS(ECC_NO_CORR),\n\t\tverbose_irq ? PIS(PACKET_SENT) : \"\",\n\t\tPIS(BTA),\n\t\tPIS(FIFO_TX_OVF),\n\t\tPIS(FIFO_RX_OVF),\n\t\tPIS(FIFO_TX_UDF),\n\t\tPIS(PP_BUSY_CHANGE));\n#undef PIS\n}\n\nstatic void print_irq_status_cio(u32 status)\n{\n\tif (status == 0)\n\t\treturn;\n\n#define PIS(x) (status & DSI_CIO_IRQ_##x) ? (#x \" \") : \"\"\n\n\tpr_debug(\"DSI CIO IRQ 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\tstatus,\n\t\tPIS(ERRSYNCESC1),\n\t\tPIS(ERRSYNCESC2),\n\t\tPIS(ERRSYNCESC3),\n\t\tPIS(ERRESC1),\n\t\tPIS(ERRESC2),\n\t\tPIS(ERRESC3),\n\t\tPIS(ERRCONTROL1),\n\t\tPIS(ERRCONTROL2),\n\t\tPIS(ERRCONTROL3),\n\t\tPIS(STATEULPS1),\n\t\tPIS(STATEULPS2),\n\t\tPIS(STATEULPS3),\n\t\tPIS(ERRCONTENTIONLP0_1),\n\t\tPIS(ERRCONTENTIONLP1_1),\n\t\tPIS(ERRCONTENTIONLP0_2),\n\t\tPIS(ERRCONTENTIONLP1_2),\n\t\tPIS(ERRCONTENTIONLP0_3),\n\t\tPIS(ERRCONTENTIONLP1_3),\n\t\tPIS(ULPSACTIVENOT_ALL0),\n\t\tPIS(ULPSACTIVENOT_ALL1));\n#undef PIS\n}\n\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic void dsi_collect_irq_stats(struct dsi_data *dsi, u32 irqstatus,\n\t\t\t\t  u32 *vcstatus, u32 ciostatus)\n{\n\tint i;\n\n\tspin_lock(&dsi->irq_stats_lock);\n\n\tdsi->irq_stats.irq_count++;\n\tdss_collect_irq_stats(irqstatus, dsi->irq_stats.dsi_irqs);\n\n\tfor (i = 0; i < 4; ++i)\n\t\tdss_collect_irq_stats(vcstatus[i], dsi->irq_stats.vc_irqs[i]);\n\n\tdss_collect_irq_stats(ciostatus, dsi->irq_stats.cio_irqs);\n\n\tspin_unlock(&dsi->irq_stats_lock);\n}\n#else\n#define dsi_collect_irq_stats(dsi, irqstatus, vcstatus, ciostatus)\n#endif\n\nstatic int debug_irq;\n\nstatic void dsi_handle_irq_errors(struct dsi_data *dsi, u32 irqstatus,\n\t\t\t\t  u32 *vcstatus, u32 ciostatus)\n{\n\tint i;\n\n\tif (irqstatus & DSI_IRQ_ERROR_MASK) {\n\t\tDSSERR(\"DSI error, irqstatus %x\\n\", irqstatus);\n\t\tprint_irq_status(irqstatus);\n\t\tspin_lock(&dsi->errors_lock);\n\t\tdsi->errors |= irqstatus & DSI_IRQ_ERROR_MASK;\n\t\tspin_unlock(&dsi->errors_lock);\n\t} else if (debug_irq) {\n\t\tprint_irq_status(irqstatus);\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (vcstatus[i] & DSI_VC_IRQ_ERROR_MASK) {\n\t\t\tDSSERR(\"DSI VC(%d) error, vc irqstatus %x\\n\",\n\t\t\t\t       i, vcstatus[i]);\n\t\t\tprint_irq_status_vc(i, vcstatus[i]);\n\t\t} else if (debug_irq) {\n\t\t\tprint_irq_status_vc(i, vcstatus[i]);\n\t\t}\n\t}\n\n\tif (ciostatus & DSI_CIO_IRQ_ERROR_MASK) {\n\t\tDSSERR(\"DSI CIO error, cio irqstatus %x\\n\", ciostatus);\n\t\tprint_irq_status_cio(ciostatus);\n\t} else if (debug_irq) {\n\t\tprint_irq_status_cio(ciostatus);\n\t}\n}\n\nstatic void dsi_call_isrs(struct dsi_isr_data *isr_array,\n\t\tunsigned int isr_array_size, u32 irqstatus)\n{\n\tstruct dsi_isr_data *isr_data;\n\tint i;\n\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\t\tif (isr_data->isr && isr_data->mask & irqstatus)\n\t\t\tisr_data->isr(isr_data->arg, irqstatus);\n\t}\n}\n\nstatic void dsi_handle_isrs(struct dsi_isr_tables *isr_tables,\n\t\tu32 irqstatus, u32 *vcstatus, u32 ciostatus)\n{\n\tint i;\n\n\tdsi_call_isrs(isr_tables->isr_table,\n\t\t\tARRAY_SIZE(isr_tables->isr_table),\n\t\t\tirqstatus);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (vcstatus[i] == 0)\n\t\t\tcontinue;\n\t\tdsi_call_isrs(isr_tables->isr_table_vc[i],\n\t\t\t\tARRAY_SIZE(isr_tables->isr_table_vc[i]),\n\t\t\t\tvcstatus[i]);\n\t}\n\n\tif (ciostatus != 0)\n\t\tdsi_call_isrs(isr_tables->isr_table_cio,\n\t\t\t\tARRAY_SIZE(isr_tables->isr_table_cio),\n\t\t\t\tciostatus);\n}\n\nstatic irqreturn_t omap_dsi_irq_handler(int irq, void *arg)\n{\n\tstruct dsi_data *dsi = arg;\n\tu32 irqstatus, vcstatus[4], ciostatus;\n\tint i;\n\n\tif (!dsi->is_enabled)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dsi->irq_lock);\n\n\tirqstatus = dsi_read_reg(dsi, DSI_IRQSTATUS);\n\n\t \n\tif (!irqstatus) {\n\t\tspin_unlock(&dsi->irq_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tdsi_write_reg(dsi, DSI_IRQSTATUS, irqstatus & ~DSI_IRQ_CHANNEL_MASK);\n\t \n\tdsi_read_reg(dsi, DSI_IRQSTATUS);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif ((irqstatus & (1 << i)) == 0) {\n\t\t\tvcstatus[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcstatus[i] = dsi_read_reg(dsi, DSI_VC_IRQSTATUS(i));\n\n\t\tdsi_write_reg(dsi, DSI_VC_IRQSTATUS(i), vcstatus[i]);\n\t\t \n\t\tdsi_read_reg(dsi, DSI_VC_IRQSTATUS(i));\n\t}\n\n\tif (irqstatus & DSI_IRQ_COMPLEXIO_ERR) {\n\t\tciostatus = dsi_read_reg(dsi, DSI_COMPLEXIO_IRQ_STATUS);\n\n\t\tdsi_write_reg(dsi, DSI_COMPLEXIO_IRQ_STATUS, ciostatus);\n\t\t \n\t\tdsi_read_reg(dsi, DSI_COMPLEXIO_IRQ_STATUS);\n\t} else {\n\t\tciostatus = 0;\n\t}\n\n#ifdef DSI_CATCH_MISSING_TE\n\tif (irqstatus & DSI_IRQ_TE_TRIGGER)\n\t\tdel_timer(&dsi->te_timer);\n#endif\n\n\t \n\tmemcpy(&dsi->isr_tables_copy, &dsi->isr_tables,\n\t\tsizeof(dsi->isr_tables));\n\n\tspin_unlock(&dsi->irq_lock);\n\n\tdsi_handle_isrs(&dsi->isr_tables_copy, irqstatus, vcstatus, ciostatus);\n\n\tdsi_handle_irq_errors(dsi, irqstatus, vcstatus, ciostatus);\n\n\tdsi_collect_irq_stats(dsi, irqstatus, vcstatus, ciostatus);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void _omap_dsi_configure_irqs(struct dsi_data *dsi,\n\t\t\t\t     struct dsi_isr_data *isr_array,\n\t\t\t\t     unsigned int isr_array_size,\n\t\t\t\t     u32 default_mask,\n\t\t\t\t     const struct dsi_reg enable_reg,\n\t\t\t\t     const struct dsi_reg status_reg)\n{\n\tstruct dsi_isr_data *isr_data;\n\tu32 mask;\n\tu32 old_mask;\n\tint i;\n\n\tmask = default_mask;\n\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\n\t\tif (isr_data->isr == NULL)\n\t\t\tcontinue;\n\n\t\tmask |= isr_data->mask;\n\t}\n\n\told_mask = dsi_read_reg(dsi, enable_reg);\n\t \n\tdsi_write_reg(dsi, status_reg, (mask ^ old_mask) & mask);\n\tdsi_write_reg(dsi, enable_reg, mask);\n\n\t \n\tdsi_read_reg(dsi, enable_reg);\n\tdsi_read_reg(dsi, status_reg);\n}\n\n \nstatic void _omap_dsi_set_irqs(struct dsi_data *dsi)\n{\n\tu32 mask = DSI_IRQ_ERROR_MASK;\n#ifdef DSI_CATCH_MISSING_TE\n\tmask |= DSI_IRQ_TE_TRIGGER;\n#endif\n\t_omap_dsi_configure_irqs(dsi, dsi->isr_tables.isr_table,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table), mask,\n\t\t\tDSI_IRQENABLE, DSI_IRQSTATUS);\n}\n\n \nstatic void _omap_dsi_set_irqs_vc(struct dsi_data *dsi, int vc)\n{\n\t_omap_dsi_configure_irqs(dsi, dsi->isr_tables.isr_table_vc[vc],\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_vc[vc]),\n\t\t\tDSI_VC_IRQ_ERROR_MASK,\n\t\t\tDSI_VC_IRQENABLE(vc), DSI_VC_IRQSTATUS(vc));\n}\n\n \nstatic void _omap_dsi_set_irqs_cio(struct dsi_data *dsi)\n{\n\t_omap_dsi_configure_irqs(dsi, dsi->isr_tables.isr_table_cio,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_cio),\n\t\t\tDSI_CIO_IRQ_ERROR_MASK,\n\t\t\tDSI_COMPLEXIO_IRQ_ENABLE, DSI_COMPLEXIO_IRQ_STATUS);\n}\n\nstatic void _dsi_initialize_irq(struct dsi_data *dsi)\n{\n\tunsigned long flags;\n\tint vc;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tmemset(&dsi->isr_tables, 0, sizeof(dsi->isr_tables));\n\n\t_omap_dsi_set_irqs(dsi);\n\tfor (vc = 0; vc < 4; ++vc)\n\t\t_omap_dsi_set_irqs_vc(dsi, vc);\n\t_omap_dsi_set_irqs_cio(dsi);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n}\n\nstatic int _dsi_register_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\n\t\tstruct dsi_isr_data *isr_array, unsigned int isr_array_size)\n{\n\tstruct dsi_isr_data *isr_data;\n\tint free_idx;\n\tint i;\n\n\tBUG_ON(isr == NULL);\n\n\t \n\tfree_idx = -1;\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\n\t\tif (isr_data->isr == isr && isr_data->arg == arg &&\n\t\t\t\tisr_data->mask == mask) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (isr_data->isr == NULL && free_idx == -1)\n\t\t\tfree_idx = i;\n\t}\n\n\tif (free_idx == -1)\n\t\treturn -EBUSY;\n\n\tisr_data = &isr_array[free_idx];\n\tisr_data->isr = isr;\n\tisr_data->arg = arg;\n\tisr_data->mask = mask;\n\n\treturn 0;\n}\n\nstatic int _dsi_unregister_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\n\t\tstruct dsi_isr_data *isr_array, unsigned int isr_array_size)\n{\n\tstruct dsi_isr_data *isr_data;\n\tint i;\n\n\tfor (i = 0; i < isr_array_size; i++) {\n\t\tisr_data = &isr_array[i];\n\t\tif (isr_data->isr != isr || isr_data->arg != arg ||\n\t\t\t\tisr_data->mask != mask)\n\t\t\tcontinue;\n\n\t\tisr_data->isr = NULL;\n\t\tisr_data->arg = NULL;\n\t\tisr_data->mask = 0;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dsi_register_isr(struct dsi_data *dsi, omap_dsi_isr_t isr,\n\t\t\t    void *arg, u32 mask)\n{\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs(dsi);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_unregister_isr(struct dsi_data *dsi, omap_dsi_isr_t isr,\n\t\t\t      void *arg, u32 mask)\n{\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table,\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs(dsi);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_register_isr_vc(struct dsi_data *dsi, int vc,\n\t\t\t       omap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_register_isr(isr, arg, mask,\n\t\t\tdsi->isr_tables.isr_table_vc[vc],\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_vc[vc]));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs_vc(dsi, vc);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic int dsi_unregister_isr_vc(struct dsi_data *dsi, int vc,\n\t\t\t\t omap_dsi_isr_t isr, void *arg, u32 mask)\n{\n\tunsigned long flags;\n\tint r;\n\n\tspin_lock_irqsave(&dsi->irq_lock, flags);\n\n\tr = _dsi_unregister_isr(isr, arg, mask,\n\t\t\tdsi->isr_tables.isr_table_vc[vc],\n\t\t\tARRAY_SIZE(dsi->isr_tables.isr_table_vc[vc]));\n\n\tif (r == 0)\n\t\t_omap_dsi_set_irqs_vc(dsi, vc);\n\n\tspin_unlock_irqrestore(&dsi->irq_lock, flags);\n\n\treturn r;\n}\n\nstatic u32 dsi_get_errors(struct dsi_data *dsi)\n{\n\tunsigned long flags;\n\tu32 e;\n\n\tspin_lock_irqsave(&dsi->errors_lock, flags);\n\te = dsi->errors;\n\tdsi->errors = 0;\n\tspin_unlock_irqrestore(&dsi->errors_lock, flags);\n\treturn e;\n}\n\nstatic int dsi_runtime_get(struct dsi_data *dsi)\n{\n\tint r;\n\n\tDSSDBG(\"dsi_runtime_get\\n\");\n\n\tr = pm_runtime_get_sync(dsi->dev);\n\tif (WARN_ON(r < 0)) {\n\t\tpm_runtime_put_noidle(dsi->dev);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nstatic void dsi_runtime_put(struct dsi_data *dsi)\n{\n\tint r;\n\n\tDSSDBG(\"dsi_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(dsi->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS);\n}\n\nstatic void _dsi_print_reset_status(struct dsi_data *dsi)\n{\n\tint b0, b1, b2;\n\n\t \n\tdsi_read_reg(dsi, DSI_DSIPHY_CFG5);\n\n\tif (dsi->data->quirks & DSI_QUIRK_REVERSE_TXCLKESC) {\n\t\tb0 = 28;\n\t\tb1 = 27;\n\t\tb2 = 26;\n\t} else {\n\t\tb0 = 24;\n\t\tb1 = 25;\n\t\tb2 = 26;\n\t}\n\n#define DSI_FLD_GET(fld, start, end)\\\n\tFLD_GET(dsi_read_reg(dsi, DSI_##fld), start, end)\n\n\tpr_debug(\"DSI resets: PLL (%d) CIO (%d) PHY (%x%x%x, %d, %d, %d)\\n\",\n\t\tDSI_FLD_GET(PLL_STATUS, 0, 0),\n\t\tDSI_FLD_GET(COMPLEXIO_CFG1, 29, 29),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, b0, b0),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, b1, b1),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, b2, b2),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, 29, 29),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, 30, 30),\n\t\tDSI_FLD_GET(DSIPHY_CFG5, 31, 31));\n\n#undef DSI_FLD_GET\n}\n\nstatic inline int dsi_if_enable(struct dsi_data *dsi, bool enable)\n{\n\tDSSDBG(\"dsi_if_enable(%d)\\n\", enable);\n\n\tenable = enable ? 1 : 0;\n\tREG_FLD_MOD(dsi, DSI_CTRL, enable, 0, 0);  \n\n\tif (!wait_for_bit_change(dsi, DSI_CTRL, 0, enable)) {\n\t\tDSSERR(\"Failed to set dsi_if_enable to %d\\n\", enable);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long dsi_get_pll_hsdiv_dispc_rate(struct dsi_data *dsi)\n{\n\treturn dsi->pll.cinfo.clkout[HSDIV_DISPC];\n}\n\nstatic unsigned long dsi_get_pll_hsdiv_dsi_rate(struct dsi_data *dsi)\n{\n\treturn dsi->pll.cinfo.clkout[HSDIV_DSI];\n}\n\nstatic unsigned long dsi_get_txbyteclkhs(struct dsi_data *dsi)\n{\n\treturn dsi->pll.cinfo.clkdco / 16;\n}\n\nstatic unsigned long dsi_fclk_rate(struct dsi_data *dsi)\n{\n\tunsigned long r;\n\tenum dss_clk_source source;\n\n\tsource = dss_get_dsi_clk_source(dsi->dss, dsi->module_id);\n\tif (source == DSS_CLK_SRC_FCK) {\n\t\t \n\t\tr = clk_get_rate(dsi->dss_clk);\n\t} else {\n\t\t \n\t\tr = dsi_get_pll_hsdiv_dsi_rate(dsi);\n\t}\n\n\treturn r;\n}\n\nstatic int dsi_lp_clock_calc(unsigned long dsi_fclk,\n\t\tunsigned long lp_clk_min, unsigned long lp_clk_max,\n\t\tstruct dsi_lp_clock_info *lp_cinfo)\n{\n\tunsigned int lp_clk_div;\n\tunsigned long lp_clk;\n\n\tlp_clk_div = DIV_ROUND_UP(dsi_fclk, lp_clk_max * 2);\n\tlp_clk = dsi_fclk / 2 / lp_clk_div;\n\n\tif (lp_clk < lp_clk_min || lp_clk > lp_clk_max)\n\t\treturn -EINVAL;\n\n\tlp_cinfo->lp_clk_div = lp_clk_div;\n\tlp_cinfo->lp_clk = lp_clk;\n\n\treturn 0;\n}\n\nstatic int dsi_set_lp_clk_divisor(struct dsi_data *dsi)\n{\n\tunsigned long dsi_fclk;\n\tunsigned int lp_clk_div;\n\tunsigned long lp_clk;\n\tunsigned int lpdiv_max = dsi->data->max_pll_lpdiv;\n\n\n\tlp_clk_div = dsi->user_lp_cinfo.lp_clk_div;\n\n\tif (lp_clk_div == 0 || lp_clk_div > lpdiv_max)\n\t\treturn -EINVAL;\n\n\tdsi_fclk = dsi_fclk_rate(dsi);\n\n\tlp_clk = dsi_fclk / 2 / lp_clk_div;\n\n\tDSSDBG(\"LP_CLK_DIV %u, LP_CLK %lu\\n\", lp_clk_div, lp_clk);\n\tdsi->current_lp_cinfo.lp_clk = lp_clk;\n\tdsi->current_lp_cinfo.lp_clk_div = lp_clk_div;\n\n\t \n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, lp_clk_div, 12, 0);\n\n\t \n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, dsi_fclk > 30000000 ? 1 : 0, 21, 21);\n\n\treturn 0;\n}\n\nstatic void dsi_enable_scp_clk(struct dsi_data *dsi)\n{\n\tif (dsi->scp_clk_refcount++ == 0)\n\t\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, 1, 14, 14);  \n}\n\nstatic void dsi_disable_scp_clk(struct dsi_data *dsi)\n{\n\tWARN_ON(dsi->scp_clk_refcount == 0);\n\tif (--dsi->scp_clk_refcount == 0)\n\t\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, 0, 14, 14);  \n}\n\nenum dsi_pll_power_state {\n\tDSI_PLL_POWER_OFF\t= 0x0,\n\tDSI_PLL_POWER_ON_HSCLK\t= 0x1,\n\tDSI_PLL_POWER_ON_ALL\t= 0x2,\n\tDSI_PLL_POWER_ON_DIV\t= 0x3,\n};\n\nstatic int dsi_pll_power(struct dsi_data *dsi, enum dsi_pll_power_state state)\n{\n\tint t = 0;\n\n\t \n\tif ((dsi->data->quirks & DSI_QUIRK_PLL_PWR_BUG) &&\n\t    state == DSI_PLL_POWER_ON_DIV)\n\t\tstate = DSI_PLL_POWER_ON_ALL;\n\n\t \n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, state, 31, 30);\n\n\t \n\twhile (FLD_GET(dsi_read_reg(dsi, DSI_CLK_CTRL), 29, 28) != state) {\n\t\tif (++t > 1000) {\n\t\t\tDSSERR(\"Failed to set DSI PLL power mode to %d\\n\",\n\t\t\t\t\tstate);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void dsi_pll_calc_dsi_fck(struct dsi_data *dsi,\n\t\t\t\t struct dss_pll_clock_info *cinfo)\n{\n\tunsigned long max_dsi_fck;\n\n\tmax_dsi_fck = dsi->data->max_fck_freq;\n\n\tcinfo->mX[HSDIV_DSI] = DIV_ROUND_UP(cinfo->clkdco, max_dsi_fck);\n\tcinfo->clkout[HSDIV_DSI] = cinfo->clkdco / cinfo->mX[HSDIV_DSI];\n}\n\nstatic int dsi_pll_enable(struct dss_pll *pll)\n{\n\tstruct dsi_data *dsi = container_of(pll, struct dsi_data, pll);\n\tint r = 0;\n\n\tDSSDBG(\"PLL init\\n\");\n\n\tr = dsi_runtime_get(dsi);\n\tif (r)\n\t\treturn r;\n\n\t \n\tdsi_enable_scp_clk(dsi);\n\n\tr = regulator_enable(dsi->vdds_dsi_reg);\n\tif (r)\n\t\tgoto err0;\n\n\t \n\tdispc_pck_free_enable(dsi->dss->dispc, 1);\n\n\tif (!wait_for_bit_change(dsi, DSI_PLL_STATUS, 0, 1)) {\n\t\tDSSERR(\"PLL not coming out of reset.\\n\");\n\t\tr = -ENODEV;\n\t\tdispc_pck_free_enable(dsi->dss->dispc, 0);\n\t\tgoto err1;\n\t}\n\n\t \n\tdispc_pck_free_enable(dsi->dss->dispc, 0);\n\n\tr = dsi_pll_power(dsi, DSI_PLL_POWER_ON_ALL);\n\n\tif (r)\n\t\tgoto err1;\n\n\tDSSDBG(\"PLL init done\\n\");\n\n\treturn 0;\nerr1:\n\tregulator_disable(dsi->vdds_dsi_reg);\nerr0:\n\tdsi_disable_scp_clk(dsi);\n\tdsi_runtime_put(dsi);\n\treturn r;\n}\n\nstatic void dsi_pll_disable(struct dss_pll *pll)\n{\n\tstruct dsi_data *dsi = container_of(pll, struct dsi_data, pll);\n\n\tdsi_pll_power(dsi, DSI_PLL_POWER_OFF);\n\n\tregulator_disable(dsi->vdds_dsi_reg);\n\n\tdsi_disable_scp_clk(dsi);\n\tdsi_runtime_put(dsi);\n\n\tDSSDBG(\"PLL disable done\\n\");\n}\n\nstatic int dsi_dump_dsi_clocks(struct seq_file *s, void *p)\n{\n\tstruct dsi_data *dsi = s->private;\n\tstruct dss_pll_clock_info *cinfo = &dsi->pll.cinfo;\n\tenum dss_clk_source dispc_clk_src, dsi_clk_src;\n\tint dsi_module = dsi->module_id;\n\tstruct dss_pll *pll = &dsi->pll;\n\n\tdispc_clk_src = dss_get_dispc_clk_source(dsi->dss);\n\tdsi_clk_src = dss_get_dsi_clk_source(dsi->dss, dsi_module);\n\n\tif (dsi_runtime_get(dsi))\n\t\treturn 0;\n\n\tseq_printf(s,\t\"- DSI%d PLL -\\n\", dsi_module + 1);\n\n\tseq_printf(s,\t\"dsi pll clkin\\t%lu\\n\", clk_get_rate(pll->clkin));\n\n\tseq_printf(s,\t\"Fint\\t\\t%-16lun %u\\n\", cinfo->fint, cinfo->n);\n\n\tseq_printf(s,\t\"CLKIN4DDR\\t%-16lum %u\\n\",\n\t\t\tcinfo->clkdco, cinfo->m);\n\n\tseq_printf(s,\t\"DSI_PLL_HSDIV_DISPC (%s)\\t%-16lum_dispc %u\\t(%s)\\n\",\n\t\t\tdss_get_clk_source_name(dsi_module == 0 ?\n\t\t\t\tDSS_CLK_SRC_PLL1_1 :\n\t\t\t\tDSS_CLK_SRC_PLL2_1),\n\t\t\tcinfo->clkout[HSDIV_DISPC],\n\t\t\tcinfo->mX[HSDIV_DISPC],\n\t\t\tdispc_clk_src == DSS_CLK_SRC_FCK ?\n\t\t\t\"off\" : \"on\");\n\n\tseq_printf(s,\t\"DSI_PLL_HSDIV_DSI (%s)\\t%-16lum_dsi %u\\t(%s)\\n\",\n\t\t\tdss_get_clk_source_name(dsi_module == 0 ?\n\t\t\t\tDSS_CLK_SRC_PLL1_2 :\n\t\t\t\tDSS_CLK_SRC_PLL2_2),\n\t\t\tcinfo->clkout[HSDIV_DSI],\n\t\t\tcinfo->mX[HSDIV_DSI],\n\t\t\tdsi_clk_src == DSS_CLK_SRC_FCK ?\n\t\t\t\"off\" : \"on\");\n\n\tseq_printf(s,\t\"- DSI%d -\\n\", dsi_module + 1);\n\n\tseq_printf(s,\t\"dsi fclk source = %s\\n\",\n\t\t\tdss_get_clk_source_name(dsi_clk_src));\n\n\tseq_printf(s,\t\"DSI_FCLK\\t%lu\\n\", dsi_fclk_rate(dsi));\n\n\tseq_printf(s,\t\"DDR_CLK\\t\\t%lu\\n\",\n\t\t\tcinfo->clkdco / 4);\n\n\tseq_printf(s,\t\"TxByteClkHS\\t%lu\\n\", dsi_get_txbyteclkhs(dsi));\n\n\tseq_printf(s,\t\"LP_CLK\\t\\t%lu\\n\", dsi->current_lp_cinfo.lp_clk);\n\n\tdsi_runtime_put(dsi);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic int dsi_dump_dsi_irqs(struct seq_file *s, void *p)\n{\n\tstruct dsi_data *dsi = s->private;\n\tunsigned long flags;\n\tstruct dsi_irq_stats *stats;\n\n\tstats = kmalloc(sizeof(*stats), GFP_KERNEL);\n\tif (!stats)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&dsi->irq_stats_lock, flags);\n\n\t*stats = dsi->irq_stats;\n\tmemset(&dsi->irq_stats, 0, sizeof(dsi->irq_stats));\n\tdsi->irq_stats.last_reset = jiffies;\n\n\tspin_unlock_irqrestore(&dsi->irq_stats_lock, flags);\n\n\tseq_printf(s, \"period %u ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies - stats->last_reset));\n\n\tseq_printf(s, \"irqs %d\\n\", stats->irq_count);\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d\\n\", #x, stats->dsi_irqs[ffs(DSI_IRQ_##x)-1]);\n\n\tseq_printf(s, \"-- DSI%d interrupts --\\n\", dsi->module_id + 1);\n\tPIS(VC0);\n\tPIS(VC1);\n\tPIS(VC2);\n\tPIS(VC3);\n\tPIS(WAKEUP);\n\tPIS(RESYNC);\n\tPIS(PLL_LOCK);\n\tPIS(PLL_UNLOCK);\n\tPIS(PLL_RECALL);\n\tPIS(COMPLEXIO_ERR);\n\tPIS(HS_TX_TIMEOUT);\n\tPIS(LP_RX_TIMEOUT);\n\tPIS(TE_TRIGGER);\n\tPIS(ACK_TRIGGER);\n\tPIS(SYNC_LOST);\n\tPIS(LDO_POWER_GOOD);\n\tPIS(TA_TIMEOUT);\n#undef PIS\n\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d %10d %10d %10d\\n\", #x, \\\n\t\t\tstats->vc_irqs[0][ffs(DSI_VC_IRQ_##x)-1], \\\n\t\t\tstats->vc_irqs[1][ffs(DSI_VC_IRQ_##x)-1], \\\n\t\t\tstats->vc_irqs[2][ffs(DSI_VC_IRQ_##x)-1], \\\n\t\t\tstats->vc_irqs[3][ffs(DSI_VC_IRQ_##x)-1]);\n\n\tseq_printf(s, \"-- VC interrupts --\\n\");\n\tPIS(CS);\n\tPIS(ECC_CORR);\n\tPIS(PACKET_SENT);\n\tPIS(FIFO_TX_OVF);\n\tPIS(FIFO_RX_OVF);\n\tPIS(BTA);\n\tPIS(ECC_NO_CORR);\n\tPIS(FIFO_TX_UDF);\n\tPIS(PP_BUSY_CHANGE);\n#undef PIS\n\n#define PIS(x) \\\n\tseq_printf(s, \"%-20s %10d\\n\", #x, \\\n\t\t\tstats->cio_irqs[ffs(DSI_CIO_IRQ_##x)-1]);\n\n\tseq_printf(s, \"-- CIO interrupts --\\n\");\n\tPIS(ERRSYNCESC1);\n\tPIS(ERRSYNCESC2);\n\tPIS(ERRSYNCESC3);\n\tPIS(ERRESC1);\n\tPIS(ERRESC2);\n\tPIS(ERRESC3);\n\tPIS(ERRCONTROL1);\n\tPIS(ERRCONTROL2);\n\tPIS(ERRCONTROL3);\n\tPIS(STATEULPS1);\n\tPIS(STATEULPS2);\n\tPIS(STATEULPS3);\n\tPIS(ERRCONTENTIONLP0_1);\n\tPIS(ERRCONTENTIONLP1_1);\n\tPIS(ERRCONTENTIONLP0_2);\n\tPIS(ERRCONTENTIONLP1_2);\n\tPIS(ERRCONTENTIONLP0_3);\n\tPIS(ERRCONTENTIONLP1_3);\n\tPIS(ULPSACTIVENOT_ALL0);\n\tPIS(ULPSACTIVENOT_ALL1);\n#undef PIS\n\n\tkfree(stats);\n\n\treturn 0;\n}\n#endif\n\nstatic int dsi_dump_dsi_regs(struct seq_file *s, void *p)\n{\n\tstruct dsi_data *dsi = s->private;\n\n\tif (dsi_runtime_get(dsi))\n\t\treturn 0;\n\tdsi_enable_scp_clk(dsi);\n\n#define DUMPREG(r) seq_printf(s, \"%-35s %08x\\n\", #r, dsi_read_reg(dsi, r))\n\tDUMPREG(DSI_REVISION);\n\tDUMPREG(DSI_SYSCONFIG);\n\tDUMPREG(DSI_SYSSTATUS);\n\tDUMPREG(DSI_IRQSTATUS);\n\tDUMPREG(DSI_IRQENABLE);\n\tDUMPREG(DSI_CTRL);\n\tDUMPREG(DSI_COMPLEXIO_CFG1);\n\tDUMPREG(DSI_COMPLEXIO_IRQ_STATUS);\n\tDUMPREG(DSI_COMPLEXIO_IRQ_ENABLE);\n\tDUMPREG(DSI_CLK_CTRL);\n\tDUMPREG(DSI_TIMING1);\n\tDUMPREG(DSI_TIMING2);\n\tDUMPREG(DSI_VM_TIMING1);\n\tDUMPREG(DSI_VM_TIMING2);\n\tDUMPREG(DSI_VM_TIMING3);\n\tDUMPREG(DSI_CLK_TIMING);\n\tDUMPREG(DSI_TX_FIFO_VC_SIZE);\n\tDUMPREG(DSI_RX_FIFO_VC_SIZE);\n\tDUMPREG(DSI_COMPLEXIO_CFG2);\n\tDUMPREG(DSI_RX_FIFO_VC_FULLNESS);\n\tDUMPREG(DSI_VM_TIMING4);\n\tDUMPREG(DSI_TX_FIFO_VC_EMPTINESS);\n\tDUMPREG(DSI_VM_TIMING5);\n\tDUMPREG(DSI_VM_TIMING6);\n\tDUMPREG(DSI_VM_TIMING7);\n\tDUMPREG(DSI_STOPCLK_TIMING);\n\n\tDUMPREG(DSI_VC_CTRL(0));\n\tDUMPREG(DSI_VC_TE(0));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(0));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(0));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(0));\n\tDUMPREG(DSI_VC_IRQSTATUS(0));\n\tDUMPREG(DSI_VC_IRQENABLE(0));\n\n\tDUMPREG(DSI_VC_CTRL(1));\n\tDUMPREG(DSI_VC_TE(1));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(1));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(1));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(1));\n\tDUMPREG(DSI_VC_IRQSTATUS(1));\n\tDUMPREG(DSI_VC_IRQENABLE(1));\n\n\tDUMPREG(DSI_VC_CTRL(2));\n\tDUMPREG(DSI_VC_TE(2));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(2));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(2));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(2));\n\tDUMPREG(DSI_VC_IRQSTATUS(2));\n\tDUMPREG(DSI_VC_IRQENABLE(2));\n\n\tDUMPREG(DSI_VC_CTRL(3));\n\tDUMPREG(DSI_VC_TE(3));\n\tDUMPREG(DSI_VC_LONG_PACKET_HEADER(3));\n\tDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(3));\n\tDUMPREG(DSI_VC_SHORT_PACKET_HEADER(3));\n\tDUMPREG(DSI_VC_IRQSTATUS(3));\n\tDUMPREG(DSI_VC_IRQENABLE(3));\n\n\tDUMPREG(DSI_DSIPHY_CFG0);\n\tDUMPREG(DSI_DSIPHY_CFG1);\n\tDUMPREG(DSI_DSIPHY_CFG2);\n\tDUMPREG(DSI_DSIPHY_CFG5);\n\n\tDUMPREG(DSI_PLL_CONTROL);\n\tDUMPREG(DSI_PLL_STATUS);\n\tDUMPREG(DSI_PLL_GO);\n\tDUMPREG(DSI_PLL_CONFIGURATION1);\n\tDUMPREG(DSI_PLL_CONFIGURATION2);\n#undef DUMPREG\n\n\tdsi_disable_scp_clk(dsi);\n\tdsi_runtime_put(dsi);\n\n\treturn 0;\n}\n\nenum dsi_cio_power_state {\n\tDSI_COMPLEXIO_POWER_OFF\t\t= 0x0,\n\tDSI_COMPLEXIO_POWER_ON\t\t= 0x1,\n\tDSI_COMPLEXIO_POWER_ULPS\t= 0x2,\n};\n\nstatic int dsi_cio_power(struct dsi_data *dsi, enum dsi_cio_power_state state)\n{\n\tint t = 0;\n\n\t \n\tREG_FLD_MOD(dsi, DSI_COMPLEXIO_CFG1, state, 28, 27);\n\n\t \n\twhile (FLD_GET(dsi_read_reg(dsi, DSI_COMPLEXIO_CFG1),\n\t\t\t26, 25) != state) {\n\t\tif (++t > 1000) {\n\t\t\tDSSERR(\"failed to set complexio power state to \"\n\t\t\t\t\t\"%d\\n\", state);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int dsi_get_line_buf_size(struct dsi_data *dsi)\n{\n\tint val;\n\n\t \n\t \n\tif (!(dsi->data->quirks & DSI_QUIRK_GNQ))\n\t\treturn 1023 * 3;\n\n\tval = REG_GET(dsi, DSI_GNQ, 14, 12);  \n\n\tswitch (val) {\n\tcase 1:\n\t\treturn 512 * 3;\t\t \n\tcase 2:\n\t\treturn 682 * 3;\t\t \n\tcase 3:\n\t\treturn 853 * 3;\t\t \n\tcase 4:\n\t\treturn 1024 * 3;\t \n\tcase 5:\n\t\treturn 1194 * 3;\t \n\tcase 6:\n\t\treturn 1365 * 3;\t \n\tcase 7:\n\t\treturn 1920 * 3;\t \n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}\n\nstatic int dsi_set_lane_config(struct dsi_data *dsi)\n{\n\tstatic const u8 offsets[] = { 0, 4, 8, 12, 16 };\n\tstatic const enum dsi_lane_function functions[] = {\n\t\tDSI_LANE_CLK,\n\t\tDSI_LANE_DATA1,\n\t\tDSI_LANE_DATA2,\n\t\tDSI_LANE_DATA3,\n\t\tDSI_LANE_DATA4,\n\t};\n\tu32 r;\n\tint i;\n\n\tr = dsi_read_reg(dsi, DSI_COMPLEXIO_CFG1);\n\n\tfor (i = 0; i < dsi->num_lanes_used; ++i) {\n\t\tunsigned int offset = offsets[i];\n\t\tunsigned int polarity, lane_number;\n\t\tunsigned int t;\n\n\t\tfor (t = 0; t < dsi->num_lanes_supported; ++t)\n\t\t\tif (dsi->lanes[t].function == functions[i])\n\t\t\t\tbreak;\n\n\t\tif (t == dsi->num_lanes_supported)\n\t\t\treturn -EINVAL;\n\n\t\tlane_number = t;\n\t\tpolarity = dsi->lanes[t].polarity;\n\n\t\tr = FLD_MOD(r, lane_number + 1, offset + 2, offset);\n\t\tr = FLD_MOD(r, polarity, offset + 3, offset + 3);\n\t}\n\n\t \n\tfor (; i < dsi->num_lanes_supported; ++i) {\n\t\tunsigned int offset = offsets[i];\n\n\t\tr = FLD_MOD(r, 0, offset + 2, offset);\n\t\tr = FLD_MOD(r, 0, offset + 3, offset + 3);\n\t}\n\n\tdsi_write_reg(dsi, DSI_COMPLEXIO_CFG1, r);\n\n\treturn 0;\n}\n\nstatic inline unsigned int ns2ddr(struct dsi_data *dsi, unsigned int ns)\n{\n\t \n\tunsigned long ddr_clk = dsi->pll.cinfo.clkdco / 4;\n\n\treturn (ns * (ddr_clk / 1000 / 1000) + 999) / 1000;\n}\n\nstatic inline unsigned int ddr2ns(struct dsi_data *dsi, unsigned int ddr)\n{\n\tunsigned long ddr_clk = dsi->pll.cinfo.clkdco / 4;\n\n\treturn ddr * 1000 * 1000 / (ddr_clk / 1000);\n}\n\nstatic void dsi_cio_timings(struct dsi_data *dsi)\n{\n\tu32 r;\n\tu32 ths_prepare, ths_prepare_ths_zero, ths_trail, ths_exit;\n\tu32 tlpx_half, tclk_trail, tclk_zero;\n\tu32 tclk_prepare;\n\n\t \n\n\t \n\n\t \n\tths_prepare = ns2ddr(dsi, 70) + 2;\n\n\t \n\tths_prepare_ths_zero = ns2ddr(dsi, 175) + 2;\n\n\t \n\tths_trail = ns2ddr(dsi, 60) + 5;\n\n\t \n\tths_exit = ns2ddr(dsi, 145);\n\n\t \n\ttlpx_half = ns2ddr(dsi, 25);\n\n\t \n\ttclk_trail = ns2ddr(dsi, 60) + 2;\n\n\t \n\ttclk_prepare = ns2ddr(dsi, 65);\n\n\t \n\ttclk_zero = ns2ddr(dsi, 260);\n\n\tDSSDBG(\"ths_prepare %u (%uns), ths_prepare_ths_zero %u (%uns)\\n\",\n\t\tths_prepare, ddr2ns(dsi, ths_prepare),\n\t\tths_prepare_ths_zero, ddr2ns(dsi, ths_prepare_ths_zero));\n\tDSSDBG(\"ths_trail %u (%uns), ths_exit %u (%uns)\\n\",\n\t\t\tths_trail, ddr2ns(dsi, ths_trail),\n\t\t\tths_exit, ddr2ns(dsi, ths_exit));\n\n\tDSSDBG(\"tlpx_half %u (%uns), tclk_trail %u (%uns), \"\n\t\t\t\"tclk_zero %u (%uns)\\n\",\n\t\t\ttlpx_half, ddr2ns(dsi, tlpx_half),\n\t\t\ttclk_trail, ddr2ns(dsi, tclk_trail),\n\t\t\ttclk_zero, ddr2ns(dsi, tclk_zero));\n\tDSSDBG(\"tclk_prepare %u (%uns)\\n\",\n\t\t\ttclk_prepare, ddr2ns(dsi, tclk_prepare));\n\n\t \n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG0);\n\tr = FLD_MOD(r, ths_prepare, 31, 24);\n\tr = FLD_MOD(r, ths_prepare_ths_zero, 23, 16);\n\tr = FLD_MOD(r, ths_trail, 15, 8);\n\tr = FLD_MOD(r, ths_exit, 7, 0);\n\tdsi_write_reg(dsi, DSI_DSIPHY_CFG0, r);\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG1);\n\tr = FLD_MOD(r, tlpx_half, 20, 16);\n\tr = FLD_MOD(r, tclk_trail, 15, 8);\n\tr = FLD_MOD(r, tclk_zero, 7, 0);\n\n\tif (dsi->data->quirks & DSI_QUIRK_PHY_DCC) {\n\t\tr = FLD_MOD(r, 0, 21, 21);\t \n\t\tr = FLD_MOD(r, 1, 22, 22);\t \n\t\tr = FLD_MOD(r, 1, 23, 23);\t \n\t}\n\n\tdsi_write_reg(dsi, DSI_DSIPHY_CFG1, r);\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG2);\n\tr = FLD_MOD(r, tclk_prepare, 7, 0);\n\tdsi_write_reg(dsi, DSI_DSIPHY_CFG2, r);\n}\n\nstatic int dsi_cio_wait_tx_clk_esc_reset(struct dsi_data *dsi)\n{\n\tint t, i;\n\tbool in_use[DSI_MAX_NR_LANES];\n\tstatic const u8 offsets_old[] = { 28, 27, 26 };\n\tstatic const u8 offsets_new[] = { 24, 25, 26, 27, 28 };\n\tconst u8 *offsets;\n\n\tif (dsi->data->quirks & DSI_QUIRK_REVERSE_TXCLKESC)\n\t\toffsets = offsets_old;\n\telse\n\t\toffsets = offsets_new;\n\n\tfor (i = 0; i < dsi->num_lanes_supported; ++i)\n\t\tin_use[i] = dsi->lanes[i].function != DSI_LANE_UNUSED;\n\n\tt = 100000;\n\twhile (true) {\n\t\tu32 l;\n\t\tint ok;\n\n\t\tl = dsi_read_reg(dsi, DSI_DSIPHY_CFG5);\n\n\t\tok = 0;\n\t\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\t\tif (!in_use[i] || (l & (1 << offsets[i])))\n\t\t\t\tok++;\n\t\t}\n\n\t\tif (ok == dsi->num_lanes_supported)\n\t\t\tbreak;\n\n\t\tif (--t == 0) {\n\t\t\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\t\t\tif (!in_use[i] || (l & (1 << offsets[i])))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tDSSERR(\"CIO TXCLKESC%d domain not coming \" \\\n\t\t\t\t\t\t\"out of reset\\n\", i);\n\t\t\t}\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned int dsi_get_lane_mask(struct dsi_data *dsi)\n{\n\tunsigned int mask = 0;\n\tint i;\n\n\tfor (i = 0; i < dsi->num_lanes_supported; ++i) {\n\t\tif (dsi->lanes[i].function != DSI_LANE_UNUSED)\n\t\t\tmask |= 1 << i;\n\t}\n\n\treturn mask;\n}\n\n \n#define OMAP4_DSIPHY_SYSCON_OFFSET\t\t\t0x78\n\n#define OMAP4_DSI2_LANEENABLE_SHIFT\t\t\t29\n#define OMAP4_DSI2_LANEENABLE_MASK\t\t\t(0x7 << 29)\n#define OMAP4_DSI1_LANEENABLE_SHIFT\t\t\t24\n#define OMAP4_DSI1_LANEENABLE_MASK\t\t\t(0x1f << 24)\n#define OMAP4_DSI1_PIPD_SHIFT\t\t\t\t19\n#define OMAP4_DSI1_PIPD_MASK\t\t\t\t(0x1f << 19)\n#define OMAP4_DSI2_PIPD_SHIFT\t\t\t\t14\n#define OMAP4_DSI2_PIPD_MASK\t\t\t\t(0x1f << 14)\n\nstatic int dsi_omap4_mux_pads(struct dsi_data *dsi, unsigned int lanes)\n{\n\tu32 enable_mask, enable_shift;\n\tu32 pipd_mask, pipd_shift;\n\n\tif (dsi->module_id == 0) {\n\t\tenable_mask = OMAP4_DSI1_LANEENABLE_MASK;\n\t\tenable_shift = OMAP4_DSI1_LANEENABLE_SHIFT;\n\t\tpipd_mask = OMAP4_DSI1_PIPD_MASK;\n\t\tpipd_shift = OMAP4_DSI1_PIPD_SHIFT;\n\t} else if (dsi->module_id == 1) {\n\t\tenable_mask = OMAP4_DSI2_LANEENABLE_MASK;\n\t\tenable_shift = OMAP4_DSI2_LANEENABLE_SHIFT;\n\t\tpipd_mask = OMAP4_DSI2_PIPD_MASK;\n\t\tpipd_shift = OMAP4_DSI2_PIPD_SHIFT;\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\treturn regmap_update_bits(dsi->syscon, OMAP4_DSIPHY_SYSCON_OFFSET,\n\t\tenable_mask | pipd_mask,\n\t\t(lanes << enable_shift) | (lanes << pipd_shift));\n}\n\n \n\n#define OMAP5_DSIPHY_SYSCON_OFFSET\t0x74\n\n#define OMAP5_DSI1_LANEENABLE_SHIFT\t24\n#define OMAP5_DSI2_LANEENABLE_SHIFT\t19\n#define OMAP5_DSI_LANEENABLE_MASK\t0x1f\n\nstatic int dsi_omap5_mux_pads(struct dsi_data *dsi, unsigned int lanes)\n{\n\tu32 enable_shift;\n\n\tif (dsi->module_id == 0)\n\t\tenable_shift = OMAP5_DSI1_LANEENABLE_SHIFT;\n\telse if (dsi->module_id == 1)\n\t\tenable_shift = OMAP5_DSI2_LANEENABLE_SHIFT;\n\telse\n\t\treturn -ENODEV;\n\n\treturn regmap_update_bits(dsi->syscon, OMAP5_DSIPHY_SYSCON_OFFSET,\n\t\tOMAP5_DSI_LANEENABLE_MASK << enable_shift,\n\t\tlanes << enable_shift);\n}\n\nstatic int dsi_enable_pads(struct dsi_data *dsi, unsigned int lane_mask)\n{\n\tif (dsi->data->model == DSI_MODEL_OMAP4)\n\t\treturn dsi_omap4_mux_pads(dsi, lane_mask);\n\tif (dsi->data->model == DSI_MODEL_OMAP5)\n\t\treturn dsi_omap5_mux_pads(dsi, lane_mask);\n\treturn 0;\n}\n\nstatic void dsi_disable_pads(struct dsi_data *dsi)\n{\n\tif (dsi->data->model == DSI_MODEL_OMAP4)\n\t\tdsi_omap4_mux_pads(dsi, 0);\n\telse if (dsi->data->model == DSI_MODEL_OMAP5)\n\t\tdsi_omap5_mux_pads(dsi, 0);\n}\n\nstatic int dsi_cio_init(struct dsi_data *dsi)\n{\n\tint r;\n\tu32 l;\n\n\tDSSDBG(\"DSI CIO init starts\");\n\n\tr = dsi_enable_pads(dsi, dsi_get_lane_mask(dsi));\n\tif (r)\n\t\treturn r;\n\n\tdsi_enable_scp_clk(dsi);\n\n\t \n\tdsi_read_reg(dsi, DSI_DSIPHY_CFG5);\n\n\tif (!wait_for_bit_change(dsi, DSI_DSIPHY_CFG5, 30, 1)) {\n\t\tDSSERR(\"CIO SCP Clock domain not coming out of reset.\\n\");\n\t\tr = -EIO;\n\t\tgoto err_scp_clk_dom;\n\t}\n\n\tr = dsi_set_lane_config(dsi);\n\tif (r)\n\t\tgoto err_scp_clk_dom;\n\n\t \n\tl = dsi_read_reg(dsi, DSI_TIMING1);\n\tl = FLD_MOD(l, 1, 15, 15);\t \n\tl = FLD_MOD(l, 1, 14, 14);\t \n\tl = FLD_MOD(l, 1, 13, 13);\t \n\tl = FLD_MOD(l, 0x1fff, 12, 0);\t \n\tdsi_write_reg(dsi, DSI_TIMING1, l);\n\n\tr = dsi_cio_power(dsi, DSI_COMPLEXIO_POWER_ON);\n\tif (r)\n\t\tgoto err_cio_pwr;\n\n\tif (!wait_for_bit_change(dsi, DSI_COMPLEXIO_CFG1, 29, 1)) {\n\t\tDSSERR(\"CIO PWR clock domain not coming out of reset.\\n\");\n\t\tr = -ENODEV;\n\t\tgoto err_cio_pwr_dom;\n\t}\n\n\tdsi_if_enable(dsi, true);\n\tdsi_if_enable(dsi, false);\n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, 1, 20, 20);  \n\n\tr = dsi_cio_wait_tx_clk_esc_reset(dsi);\n\tif (r)\n\t\tgoto err_tx_clk_esc_rst;\n\n\t \n\tREG_FLD_MOD(dsi, DSI_TIMING1, 0, 15, 15);\n\n\tdsi_cio_timings(dsi);\n\n\t \n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL,\n\t\t    !(dsi->dsidev->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS),\n\t\t    13, 13);\n\n\tDSSDBG(\"CIO init done\\n\");\n\n\treturn 0;\n\nerr_tx_clk_esc_rst:\n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, 0, 20, 20);  \nerr_cio_pwr_dom:\n\tdsi_cio_power(dsi, DSI_COMPLEXIO_POWER_OFF);\nerr_cio_pwr:\nerr_scp_clk_dom:\n\tdsi_disable_scp_clk(dsi);\n\tdsi_disable_pads(dsi);\n\treturn r;\n}\n\nstatic void dsi_cio_uninit(struct dsi_data *dsi)\n{\n\t \n\tREG_FLD_MOD(dsi, DSI_CLK_CTRL, 0, 13, 13);\n\n\tdsi_cio_power(dsi, DSI_COMPLEXIO_POWER_OFF);\n\tdsi_disable_scp_clk(dsi);\n\tdsi_disable_pads(dsi);\n}\n\nstatic void dsi_config_tx_fifo(struct dsi_data *dsi,\n\t\t\t       enum fifo_size size1, enum fifo_size size2,\n\t\t\t       enum fifo_size size3, enum fifo_size size4)\n{\n\tu32 r = 0;\n\tint add = 0;\n\tint i;\n\n\tdsi->vc[0].tx_fifo_size = size1;\n\tdsi->vc[1].tx_fifo_size = size2;\n\tdsi->vc[2].tx_fifo_size = size3;\n\tdsi->vc[3].tx_fifo_size = size4;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 v;\n\t\tint size = dsi->vc[i].tx_fifo_size;\n\n\t\tif (add + size > 4) {\n\t\t\tDSSERR(\"Illegal FIFO configuration\\n\");\n\t\t\tBUG();\n\t\t\treturn;\n\t\t}\n\n\t\tv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\n\t\tr |= v << (8 * i);\n\t\t \n\t\tadd += size;\n\t}\n\n\tdsi_write_reg(dsi, DSI_TX_FIFO_VC_SIZE, r);\n}\n\nstatic void dsi_config_rx_fifo(struct dsi_data *dsi,\n\t\tenum fifo_size size1, enum fifo_size size2,\n\t\tenum fifo_size size3, enum fifo_size size4)\n{\n\tu32 r = 0;\n\tint add = 0;\n\tint i;\n\n\tdsi->vc[0].rx_fifo_size = size1;\n\tdsi->vc[1].rx_fifo_size = size2;\n\tdsi->vc[2].rx_fifo_size = size3;\n\tdsi->vc[3].rx_fifo_size = size4;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tu8 v;\n\t\tint size = dsi->vc[i].rx_fifo_size;\n\n\t\tif (add + size > 4) {\n\t\t\tDSSERR(\"Illegal FIFO configuration\\n\");\n\t\t\tBUG();\n\t\t\treturn;\n\t\t}\n\n\t\tv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\n\t\tr |= v << (8 * i);\n\t\t \n\t\tadd += size;\n\t}\n\n\tdsi_write_reg(dsi, DSI_RX_FIFO_VC_SIZE, r);\n}\n\nstatic int dsi_force_tx_stop_mode_io(struct dsi_data *dsi)\n{\n\tu32 r;\n\n\tr = dsi_read_reg(dsi, DSI_TIMING1);\n\tr = FLD_MOD(r, 1, 15, 15);\t \n\tdsi_write_reg(dsi, DSI_TIMING1, r);\n\n\tif (!wait_for_bit_change(dsi, DSI_TIMING1, 15, 0)) {\n\t\tDSSERR(\"TX_STOP bit not going down\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic bool dsi_vc_is_enabled(struct dsi_data *dsi, int vc)\n{\n\treturn REG_GET(dsi, DSI_VC_CTRL(vc), 0, 0);\n}\n\nstatic void dsi_packet_sent_handler_vp(void *data, u32 mask)\n{\n\tstruct dsi_packet_sent_handler_data *vp_data =\n\t\t(struct dsi_packet_sent_handler_data *) data;\n\tstruct dsi_data *dsi = vp_data->dsi;\n\tconst int vc = dsi->update_vc;\n\tu8 bit = dsi->te_enabled ? 30 : 31;\n\n\tif (REG_GET(dsi, DSI_VC_TE(vc), bit, bit) == 0)\n\t\tcomplete(vp_data->completion);\n}\n\nstatic int dsi_sync_vc_vp(struct dsi_data *dsi, int vc)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct dsi_packet_sent_handler_data vp_data = {\n\t\t.dsi = dsi,\n\t\t.completion = &completion\n\t};\n\tint r = 0;\n\tu8 bit;\n\n\tbit = dsi->te_enabled ? 30 : 31;\n\n\tr = dsi_register_isr_vc(dsi, vc, dsi_packet_sent_handler_vp,\n\t\t&vp_data, DSI_VC_IRQ_PACKET_SENT);\n\tif (r)\n\t\tgoto err0;\n\n\t \n\tif (REG_GET(dsi, DSI_VC_TE(vc), bit, bit)) {\n\t\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(10)) == 0) {\n\t\t\tDSSERR(\"Failed to complete previous frame transfer\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tdsi_unregister_isr_vc(dsi, vc, dsi_packet_sent_handler_vp,\n\t\t&vp_data, DSI_VC_IRQ_PACKET_SENT);\n\n\treturn 0;\nerr1:\n\tdsi_unregister_isr_vc(dsi, vc, dsi_packet_sent_handler_vp,\n\t\t&vp_data, DSI_VC_IRQ_PACKET_SENT);\nerr0:\n\treturn r;\n}\n\nstatic void dsi_packet_sent_handler_l4(void *data, u32 mask)\n{\n\tstruct dsi_packet_sent_handler_data *l4_data =\n\t\t(struct dsi_packet_sent_handler_data *) data;\n\tstruct dsi_data *dsi = l4_data->dsi;\n\tconst int vc = dsi->update_vc;\n\n\tif (REG_GET(dsi, DSI_VC_CTRL(vc), 5, 5) == 0)\n\t\tcomplete(l4_data->completion);\n}\n\nstatic int dsi_sync_vc_l4(struct dsi_data *dsi, int vc)\n{\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tstruct dsi_packet_sent_handler_data l4_data = {\n\t\t.dsi = dsi,\n\t\t.completion = &completion\n\t};\n\tint r = 0;\n\n\tr = dsi_register_isr_vc(dsi, vc, dsi_packet_sent_handler_l4,\n\t\t&l4_data, DSI_VC_IRQ_PACKET_SENT);\n\tif (r)\n\t\tgoto err0;\n\n\t \n\tif (REG_GET(dsi, DSI_VC_CTRL(vc), 5, 5)) {\n\t\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(10)) == 0) {\n\t\t\tDSSERR(\"Failed to complete previous l4 transfer\\n\");\n\t\t\tr = -EIO;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tdsi_unregister_isr_vc(dsi, vc, dsi_packet_sent_handler_l4,\n\t\t&l4_data, DSI_VC_IRQ_PACKET_SENT);\n\n\treturn 0;\nerr1:\n\tdsi_unregister_isr_vc(dsi, vc, dsi_packet_sent_handler_l4,\n\t\t&l4_data, DSI_VC_IRQ_PACKET_SENT);\nerr0:\n\treturn r;\n}\n\nstatic int dsi_sync_vc(struct dsi_data *dsi, int vc)\n{\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\tWARN_ON(in_interrupt());\n\n\tif (!dsi_vc_is_enabled(dsi, vc))\n\t\treturn 0;\n\n\tswitch (dsi->vc[vc].source) {\n\tcase DSI_VC_SOURCE_VP:\n\t\treturn dsi_sync_vc_vp(dsi, vc);\n\tcase DSI_VC_SOURCE_L4:\n\t\treturn dsi_sync_vc_l4(dsi, vc);\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int dsi_vc_enable(struct dsi_data *dsi, int vc, bool enable)\n{\n\tDSSDBG(\"dsi_vc_enable vc %d, enable %d\\n\",\n\t\t\tvc, enable);\n\n\tenable = enable ? 1 : 0;\n\n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(vc), enable, 0, 0);\n\n\tif (!wait_for_bit_change(dsi, DSI_VC_CTRL(vc), 0, enable)) {\n\t\tDSSERR(\"Failed to set dsi_vc_enable to %d\\n\", enable);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void dsi_vc_initial_config(struct dsi_data *dsi, int vc)\n{\n\tu32 r;\n\n\tDSSDBG(\"Initial config of VC %d\", vc);\n\n\tr = dsi_read_reg(dsi, DSI_VC_CTRL(vc));\n\n\tif (FLD_GET(r, 15, 15))  \n\t\tDSSERR(\"VC(%d) busy when trying to configure it!\\n\",\n\t\t\t\tvc);\n\n\tr = FLD_MOD(r, 0, 1, 1);  \n\tr = FLD_MOD(r, 0, 2, 2);  \n\tr = FLD_MOD(r, 0, 3, 3);  \n\tr = FLD_MOD(r, 0, 4, 4);  \n\tr = FLD_MOD(r, 1, 7, 7);  \n\tr = FLD_MOD(r, 1, 8, 8);  \n\tr = FLD_MOD(r, 0, 9, 9);  \n\tif (dsi->data->quirks & DSI_QUIRK_VC_OCP_WIDTH)\n\t\tr = FLD_MOD(r, 3, 11, 10);\t \n\n\tr = FLD_MOD(r, 4, 29, 27);  \n\tr = FLD_MOD(r, 4, 23, 21);  \n\n\tdsi_write_reg(dsi, DSI_VC_CTRL(vc), r);\n\n\tdsi->vc[vc].source = DSI_VC_SOURCE_L4;\n}\n\nstatic void dsi_vc_enable_hs(struct omap_dss_device *dssdev, int vc,\n\t\tbool enable)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\n\tDSSDBG(\"dsi_vc_enable_hs(%d, %d)\\n\", vc, enable);\n\n\tif (REG_GET(dsi, DSI_VC_CTRL(vc), 9, 9) == enable)\n\t\treturn;\n\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\tdsi_vc_enable(dsi, vc, 0);\n\tdsi_if_enable(dsi, 0);\n\n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(vc), enable, 9, 9);\n\n\tdsi_vc_enable(dsi, vc, 1);\n\tdsi_if_enable(dsi, 1);\n\n\tdsi_force_tx_stop_mode_io(dsi);\n}\n\nstatic void dsi_vc_flush_long_data(struct dsi_data *dsi, int vc)\n{\n\twhile (REG_GET(dsi, DSI_VC_CTRL(vc), 20, 20)) {\n\t\tu32 val;\n\t\tval = dsi_read_reg(dsi, DSI_VC_SHORT_PACKET_HEADER(vc));\n\t\tDSSDBG(\"\\t\\tb1 %#02x b2 %#02x b3 %#02x b4 %#02x\\n\",\n\t\t\t\t(val >> 0) & 0xff,\n\t\t\t\t(val >> 8) & 0xff,\n\t\t\t\t(val >> 16) & 0xff,\n\t\t\t\t(val >> 24) & 0xff);\n\t}\n}\n\nstatic void dsi_show_rx_ack_with_err(u16 err)\n{\n\tDSSERR(\"\\tACK with ERROR (%#x):\\n\", err);\n\tif (err & (1 << 0))\n\t\tDSSERR(\"\\t\\tSoT Error\\n\");\n\tif (err & (1 << 1))\n\t\tDSSERR(\"\\t\\tSoT Sync Error\\n\");\n\tif (err & (1 << 2))\n\t\tDSSERR(\"\\t\\tEoT Sync Error\\n\");\n\tif (err & (1 << 3))\n\t\tDSSERR(\"\\t\\tEscape Mode Entry Command Error\\n\");\n\tif (err & (1 << 4))\n\t\tDSSERR(\"\\t\\tLP Transmit Sync Error\\n\");\n\tif (err & (1 << 5))\n\t\tDSSERR(\"\\t\\tHS Receive Timeout Error\\n\");\n\tif (err & (1 << 6))\n\t\tDSSERR(\"\\t\\tFalse Control Error\\n\");\n\tif (err & (1 << 7))\n\t\tDSSERR(\"\\t\\t(reserved7)\\n\");\n\tif (err & (1 << 8))\n\t\tDSSERR(\"\\t\\tECC Error, single-bit (corrected)\\n\");\n\tif (err & (1 << 9))\n\t\tDSSERR(\"\\t\\tECC Error, multi-bit (not corrected)\\n\");\n\tif (err & (1 << 10))\n\t\tDSSERR(\"\\t\\tChecksum Error\\n\");\n\tif (err & (1 << 11))\n\t\tDSSERR(\"\\t\\tData type not recognized\\n\");\n\tif (err & (1 << 12))\n\t\tDSSERR(\"\\t\\tInvalid VC ID\\n\");\n\tif (err & (1 << 13))\n\t\tDSSERR(\"\\t\\tInvalid Transmission Length\\n\");\n\tif (err & (1 << 14))\n\t\tDSSERR(\"\\t\\t(reserved14)\\n\");\n\tif (err & (1 << 15))\n\t\tDSSERR(\"\\t\\tDSI Protocol Violation\\n\");\n}\n\nstatic u16 dsi_vc_flush_receive_data(struct dsi_data *dsi, int vc)\n{\n\t \n\twhile (REG_GET(dsi, DSI_VC_CTRL(vc), 20, 20)) {\n\t\tu32 val;\n\t\tu8 dt;\n\t\tval = dsi_read_reg(dsi, DSI_VC_SHORT_PACKET_HEADER(vc));\n\t\tDSSERR(\"\\trawval %#08x\\n\", val);\n\t\tdt = FLD_GET(val, 5, 0);\n\t\tif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\n\t\t\tu16 err = FLD_GET(val, 23, 8);\n\t\t\tdsi_show_rx_ack_with_err(err);\n\t\t} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE) {\n\t\t\tDSSERR(\"\\tDCS short response, 1 byte: %#x\\n\",\n\t\t\t\t\tFLD_GET(val, 23, 8));\n\t\t} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE) {\n\t\t\tDSSERR(\"\\tDCS short response, 2 byte: %#x\\n\",\n\t\t\t\t\tFLD_GET(val, 23, 8));\n\t\t} else if (dt == MIPI_DSI_RX_DCS_LONG_READ_RESPONSE) {\n\t\t\tDSSERR(\"\\tDCS long response, len %d\\n\",\n\t\t\t\t\tFLD_GET(val, 23, 8));\n\t\t\tdsi_vc_flush_long_data(dsi, vc);\n\t\t} else {\n\t\t\tDSSERR(\"\\tunknown datatype 0x%02x\\n\", dt);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dsi_vc_send_bta(struct dsi_data *dsi, int vc)\n{\n\tif (dsi->debug_write || dsi->debug_read)\n\t\tDSSDBG(\"dsi_vc_send_bta %d\\n\", vc);\n\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\t \n\tif (REG_GET(dsi, DSI_VC_CTRL(vc), 20, 20)) {\n\t\tDSSERR(\"rx fifo not empty when sending BTA, dumping data:\\n\");\n\t\tdsi_vc_flush_receive_data(dsi, vc);\n\t}\n\n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(vc), 1, 6, 6);  \n\n\t \n\tdsi_read_reg(dsi, DSI_VC_CTRL(vc));\n\n\treturn 0;\n}\n\nstatic int dsi_vc_send_bta_sync(struct omap_dss_device *dssdev, int vc)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tDECLARE_COMPLETION_ONSTACK(completion);\n\tint r = 0;\n\tu32 err;\n\n\tr = dsi_register_isr_vc(dsi, vc, dsi_completion_handler,\n\t\t\t&completion, DSI_VC_IRQ_BTA);\n\tif (r)\n\t\tgoto err0;\n\n\tr = dsi_register_isr(dsi, dsi_completion_handler, &completion,\n\t\t\tDSI_IRQ_ERROR_MASK);\n\tif (r)\n\t\tgoto err1;\n\n\tr = dsi_vc_send_bta(dsi, vc);\n\tif (r)\n\t\tgoto err2;\n\n\tif (wait_for_completion_timeout(&completion,\n\t\t\t\tmsecs_to_jiffies(500)) == 0) {\n\t\tDSSERR(\"Failed to receive BTA\\n\");\n\t\tr = -EIO;\n\t\tgoto err2;\n\t}\n\n\terr = dsi_get_errors(dsi);\n\tif (err) {\n\t\tDSSERR(\"Error while sending BTA: %x\\n\", err);\n\t\tr = -EIO;\n\t\tgoto err2;\n\t}\nerr2:\n\tdsi_unregister_isr(dsi, dsi_completion_handler, &completion,\n\t\t\tDSI_IRQ_ERROR_MASK);\nerr1:\n\tdsi_unregister_isr_vc(dsi, vc, dsi_completion_handler,\n\t\t\t&completion, DSI_VC_IRQ_BTA);\nerr0:\n\treturn r;\n}\n\nstatic inline void dsi_vc_write_long_header(struct dsi_data *dsi, int vc,\n\t\t\t\t\t    int channel, u8 data_type, u16 len,\n\t\t\t\t\t    u8 ecc)\n{\n\tu32 val;\n\tu8 data_id;\n\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\tdata_id = data_type | channel << 6;\n\n\tval = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |\n\t\tFLD_VAL(ecc, 31, 24);\n\n\tdsi_write_reg(dsi, DSI_VC_LONG_PACKET_HEADER(vc), val);\n}\n\nstatic inline void dsi_vc_write_long_payload(struct dsi_data *dsi, int vc,\n\t\t\t\t\t     u8 b1, u8 b2, u8 b3, u8 b4)\n{\n\tu32 val;\n\n\tval = b4 << 24 | b3 << 16 | b2 << 8  | b1 << 0;\n\n \n\n\tdsi_write_reg(dsi, DSI_VC_LONG_PACKET_PAYLOAD(vc), val);\n}\n\nstatic int dsi_vc_send_long(struct dsi_data *dsi, int vc,\n\t\t\t    const struct mipi_dsi_msg *msg)\n{\n\t \n\tint i;\n\tconst u8 *p;\n\tint r = 0;\n\tu8 b1, b2, b3, b4;\n\n\tif (dsi->debug_write)\n\t\tDSSDBG(\"dsi_vc_send_long, %zu bytes\\n\", msg->tx_len);\n\n\t \n\tif (dsi->vc[vc].tx_fifo_size * 32 * 4 < msg->tx_len + 4) {\n\t\tDSSERR(\"unable to send long packet: packet too long.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_vc_write_long_header(dsi, vc, msg->channel, msg->type, msg->tx_len, 0);\n\n\tp = msg->tx_buf;\n\tfor (i = 0; i < msg->tx_len >> 2; i++) {\n\t\tif (dsi->debug_write)\n\t\t\tDSSDBG(\"\\tsending full packet %d\\n\", i);\n\n\t\tb1 = *p++;\n\t\tb2 = *p++;\n\t\tb3 = *p++;\n\t\tb4 = *p++;\n\n\t\tdsi_vc_write_long_payload(dsi, vc, b1, b2, b3, b4);\n\t}\n\n\ti = msg->tx_len % 4;\n\tif (i) {\n\t\tb1 = 0; b2 = 0; b3 = 0;\n\n\t\tif (dsi->debug_write)\n\t\t\tDSSDBG(\"\\tsending remainder bytes %d\\n\", i);\n\n\t\tswitch (i) {\n\t\tcase 3:\n\t\t\tb1 = *p++;\n\t\t\tb2 = *p++;\n\t\t\tb3 = *p++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb1 = *p++;\n\t\t\tb2 = *p++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tb1 = *p++;\n\t\t\tbreak;\n\t\t}\n\n\t\tdsi_vc_write_long_payload(dsi, vc, b1, b2, b3, 0);\n\t}\n\n\treturn r;\n}\n\nstatic int dsi_vc_send_short(struct dsi_data *dsi, int vc,\n\t\t\t     const struct mipi_dsi_msg *msg)\n{\n\tstruct mipi_dsi_packet pkt;\n\tint ret;\n\tu32 r;\n\n\tret = mipi_dsi_create_packet(&pkt, msg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\tif (dsi->debug_write)\n\t\tDSSDBG(\"dsi_vc_send_short(vc%d, dt %#x, b1 %#x, b2 %#x)\\n\",\n\t\t       vc, msg->type, pkt.header[1], pkt.header[2]);\n\n\tif (FLD_GET(dsi_read_reg(dsi, DSI_VC_CTRL(vc)), 16, 16)) {\n\t\tDSSERR(\"ERROR FIFO FULL, aborting transfer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = pkt.header[3] << 24 | pkt.header[2] << 16 | pkt.header[1] << 8 |\n\t    pkt.header[0];\n\n\tdsi_write_reg(dsi, DSI_VC_SHORT_PACKET_HEADER(vc), r);\n\n\treturn 0;\n}\n\nstatic int dsi_vc_send_null(struct dsi_data *dsi, int vc, int channel)\n{\n\tconst struct mipi_dsi_msg msg = {\n\t\t.channel = channel,\n\t\t.type = MIPI_DSI_NULL_PACKET,\n\t};\n\n\treturn dsi_vc_send_long(dsi, vc, &msg);\n}\n\nstatic int dsi_vc_write_common(struct omap_dss_device *dssdev, int vc,\n\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tint r;\n\n\tif (mipi_dsi_packet_format_is_short(msg->type))\n\t\tr = dsi_vc_send_short(dsi, vc, msg);\n\telse\n\t\tr = dsi_vc_send_long(dsi, vc, msg);\n\n\tif (r < 0)\n\t\treturn r;\n\n\t \n\n\tr = dsi_vc_send_bta_sync(dssdev, vc);\n\tif (r) {\n\t\tDSSERR(\"bta sync failed\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tif (REG_GET(dsi, DSI_VC_CTRL(vc), 20, 20)) {\n\t\tDSSERR(\"rx fifo not empty after write, dumping data:\\n\");\n\t\tdsi_vc_flush_receive_data(dsi, vc);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int dsi_vc_read_rx_fifo(struct dsi_data *dsi, int vc, u8 *buf,\n\t\t\t       int buflen, enum dss_dsi_content_type type)\n{\n\tu32 val;\n\tu8 dt;\n\tint r;\n\n\t \n\tif (REG_GET(dsi, DSI_VC_CTRL(vc), 20, 20) == 0) {\n\t\tDSSERR(\"RX fifo empty when trying to read.\\n\");\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tval = dsi_read_reg(dsi, DSI_VC_SHORT_PACKET_HEADER(vc));\n\tif (dsi->debug_read)\n\t\tDSSDBG(\"\\theader: %08x\\n\", val);\n\tdt = FLD_GET(val, 5, 0);\n\tif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\n\t\tu16 err = FLD_GET(val, 23, 8);\n\t\tdsi_show_rx_ack_with_err(err);\n\t\tr = -EIO;\n\t\tgoto err;\n\n\t} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\n\t\t\tMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE :\n\t\t\tMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE)) {\n\t\tu8 data = FLD_GET(val, 15, 8);\n\t\tif (dsi->debug_read)\n\t\t\tDSSDBG(\"\\t%s short response, 1 byte: %02x\\n\",\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" :\n\t\t\t\t\"DCS\", data);\n\n\t\tif (buflen < 1) {\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuf[0] = data;\n\n\t\treturn 1;\n\t} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\n\t\t\tMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE :\n\t\t\tMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE)) {\n\t\tu16 data = FLD_GET(val, 23, 8);\n\t\tif (dsi->debug_read)\n\t\t\tDSSDBG(\"\\t%s short response, 2 byte: %04x\\n\",\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" :\n\t\t\t\t\"DCS\", data);\n\n\t\tif (buflen < 2) {\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuf[0] = data & 0xff;\n\t\tbuf[1] = (data >> 8) & 0xff;\n\n\t\treturn 2;\n\t} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\n\t\t\tMIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE :\n\t\t\tMIPI_DSI_RX_DCS_LONG_READ_RESPONSE)) {\n\t\tint w;\n\t\tint len = FLD_GET(val, 23, 8);\n\t\tif (dsi->debug_read)\n\t\t\tDSSDBG(\"\\t%s long response, len %d\\n\",\n\t\t\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" :\n\t\t\t\t\"DCS\", len);\n\n\t\tif (len > buflen) {\n\t\t\tr = -EIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tfor (w = 0; w < len + 2;) {\n\t\t\tint b;\n\t\t\tval = dsi_read_reg(dsi,\n\t\t\t\tDSI_VC_SHORT_PACKET_HEADER(vc));\n\t\t\tif (dsi->debug_read)\n\t\t\t\tDSSDBG(\"\\t\\t%02x %02x %02x %02x\\n\",\n\t\t\t\t\t\t(val >> 0) & 0xff,\n\t\t\t\t\t\t(val >> 8) & 0xff,\n\t\t\t\t\t\t(val >> 16) & 0xff,\n\t\t\t\t\t\t(val >> 24) & 0xff);\n\n\t\t\tfor (b = 0; b < 4; ++b) {\n\t\t\t\tif (w < len)\n\t\t\t\t\tbuf[w] = (val >> (b * 8)) & 0xff;\n\t\t\t\t \n\t\t\t\t++w;\n\t\t\t}\n\t\t}\n\n\t\treturn len;\n\t} else {\n\t\tDSSERR(\"\\tunknown datatype 0x%02x\\n\", dt);\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\nerr:\n\tDSSERR(\"dsi_vc_read_rx_fifo(vc %d type %s) failed\\n\", vc,\n\t\ttype == DSS_DSI_CONTENT_GENERIC ? \"GENERIC\" : \"DCS\");\n\n\treturn r;\n}\n\nstatic int dsi_vc_dcs_read(struct omap_dss_device *dssdev, int vc,\n\t\t\t   const struct mipi_dsi_msg *msg)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tu8 cmd = ((u8 *)msg->tx_buf)[0];\n\tint r;\n\n\tif (dsi->debug_read)\n\t\tDSSDBG(\"%s(vc %d, cmd %x)\\n\", __func__, vc, cmd);\n\n\tr = dsi_vc_send_short(dsi, vc, msg);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_send_bta_sync(dssdev, vc);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_read_rx_fifo(dsi, vc, msg->rx_buf, msg->rx_len,\n\t\tDSS_DSI_CONTENT_DCS);\n\tif (r < 0)\n\t\tgoto err;\n\n\tif (r != msg->rx_len) {\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tDSSERR(\"%s(vc %d, cmd 0x%02x) failed\\n\", __func__,  vc, cmd);\n\treturn r;\n}\n\nstatic int dsi_vc_generic_read(struct omap_dss_device *dssdev, int vc,\n\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tint r;\n\n\tr = dsi_vc_send_short(dsi, vc, msg);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_send_bta_sync(dssdev, vc);\n\tif (r)\n\t\tgoto err;\n\n\tr = dsi_vc_read_rx_fifo(dsi, vc, msg->rx_buf, msg->rx_len,\n\t\tDSS_DSI_CONTENT_GENERIC);\n\tif (r < 0)\n\t\tgoto err;\n\n\tif (r != msg->rx_len) {\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tDSSERR(\"%s(vc %d, reqlen %zu) failed\\n\", __func__,  vc, msg->tx_len);\n\treturn r;\n}\n\nstatic void dsi_set_lp_rx_timeout(struct dsi_data *dsi, unsigned int ticks,\n\t\t\t\t  bool x4, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_fclk_rate(dsi);\n\n\tr = dsi_read_reg(dsi, DSI_TIMING2);\n\tr = FLD_MOD(r, 1, 15, 15);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\t \n\tr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\t \n\tr = FLD_MOD(r, ticks, 12, 0);\t \n\tdsi_write_reg(dsi, DSI_TIMING2, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\n\n\tDSSDBG(\"LP_RX_TO %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x4 ? \" x4\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_set_ta_timeout(struct dsi_data *dsi, unsigned int ticks,\n\t\t\t       bool x8, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_fclk_rate(dsi);\n\n\tr = dsi_read_reg(dsi, DSI_TIMING1);\n\tr = FLD_MOD(r, 1, 31, 31);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\t \n\tr = FLD_MOD(r, x8 ? 1 : 0, 29, 29);\t \n\tr = FLD_MOD(r, ticks, 28, 16);\t \n\tdsi_write_reg(dsi, DSI_TIMING1, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x8 ? 8 : 1);\n\n\tDSSDBG(\"TA_TO %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x8 ? \" x8\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_set_stop_state_counter(struct dsi_data *dsi, unsigned int ticks,\n\t\t\t\t       bool x4, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_fclk_rate(dsi);\n\n\tr = dsi_read_reg(dsi, DSI_TIMING1);\n\tr = FLD_MOD(r, 1, 15, 15);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\t \n\tr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\t \n\tr = FLD_MOD(r, ticks, 12, 0);\t \n\tdsi_write_reg(dsi, DSI_TIMING1, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\n\n\tDSSDBG(\"STOP_STATE_COUNTER %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x4 ? \" x4\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_set_hs_tx_timeout(struct dsi_data *dsi, unsigned int ticks,\n\t\t\t\t  bool x4, bool x16)\n{\n\tunsigned long fck;\n\tunsigned long total_ticks;\n\tu32 r;\n\n\tBUG_ON(ticks > 0x1fff);\n\n\t \n\tfck = dsi_get_txbyteclkhs(dsi);\n\n\tr = dsi_read_reg(dsi, DSI_TIMING2);\n\tr = FLD_MOD(r, 1, 31, 31);\t \n\tr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\t \n\tr = FLD_MOD(r, x4 ? 1 : 0, 29, 29);\t \n\tr = FLD_MOD(r, ticks, 28, 16);\t \n\tdsi_write_reg(dsi, DSI_TIMING2, r);\n\n\ttotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\n\n\tDSSDBG(\"HS_TX_TO %lu ticks (%#x%s%s) = %lu ns\\n\",\n\t\t\ttotal_ticks,\n\t\t\tticks, x4 ? \" x4\" : \"\", x16 ? \" x16\" : \"\",\n\t\t\t(total_ticks * 1000) / (fck / 1000 / 1000));\n}\n\nstatic void dsi_config_vp_num_line_buffers(struct dsi_data *dsi)\n{\n\tint num_line_buffers;\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tint bpp = mipi_dsi_pixel_format_to_bpp(dsi->pix_fmt);\n\t\tconst struct videomode *vm = &dsi->vm;\n\t\t \n\t\tif (dsi->line_buffer_size <= vm->hactive * bpp / 8)\n\t\t\tnum_line_buffers = 0;\n\t\telse\n\t\t\tnum_line_buffers = 2;\n\t} else {\n\t\t \n\t\tnum_line_buffers = 2;\n\t}\n\n\t \n\tREG_FLD_MOD(dsi, DSI_CTRL, num_line_buffers, 13, 12);\n}\n\nstatic void dsi_config_vp_sync_events(struct dsi_data *dsi)\n{\n\tbool sync_end;\n\tu32 r;\n\n\tif (dsi->vm_timings.trans_mode == OMAP_DSS_DSI_PULSE_MODE)\n\t\tsync_end = true;\n\telse\n\t\tsync_end = false;\n\n\tr = dsi_read_reg(dsi, DSI_CTRL);\n\tr = FLD_MOD(r, 1, 9, 9);\t\t \n\tr = FLD_MOD(r, 1, 10, 10);\t\t \n\tr = FLD_MOD(r, 1, 11, 11);\t\t \n\tr = FLD_MOD(r, 1, 15, 15);\t\t \n\tr = FLD_MOD(r, sync_end, 16, 16);\t \n\tr = FLD_MOD(r, 1, 17, 17);\t\t \n\tr = FLD_MOD(r, sync_end, 18, 18);\t \n\tdsi_write_reg(dsi, DSI_CTRL, r);\n}\n\nstatic void dsi_config_blanking_modes(struct dsi_data *dsi)\n{\n\tint blanking_mode = dsi->vm_timings.blanking_mode;\n\tint hfp_blanking_mode = dsi->vm_timings.hfp_blanking_mode;\n\tint hbp_blanking_mode = dsi->vm_timings.hbp_blanking_mode;\n\tint hsa_blanking_mode = dsi->vm_timings.hsa_blanking_mode;\n\tu32 r;\n\n\t \n\tr = dsi_read_reg(dsi, DSI_CTRL);\n\tr = FLD_MOD(r, blanking_mode, 20, 20);\t\t \n\tr = FLD_MOD(r, hfp_blanking_mode, 21, 21);\t \n\tr = FLD_MOD(r, hbp_blanking_mode, 22, 22);\t \n\tr = FLD_MOD(r, hsa_blanking_mode, 23, 23);\t \n\tdsi_write_reg(dsi, DSI_CTRL, r);\n}\n\n \nstatic int dsi_compute_interleave_hs(int blank, bool ddr_alwon, int enter_hs,\n\t\tint exit_hs, int exiths_clk, int ddr_pre, int ddr_post)\n{\n\tint transition;\n\n\t \n\tif (ddr_alwon) {\n\t\ttransition = enter_hs + exit_hs + max(enter_hs, 2) + 1;\n\t} else {\n\t\tint trans1, trans2;\n\t\ttrans1 = ddr_pre + enter_hs + exit_hs + max(enter_hs, 2) + 1;\n\t\ttrans2 = ddr_pre + enter_hs + exiths_clk + ddr_post + ddr_pre +\n\t\t\t\tenter_hs + 1;\n\t\ttransition = max(trans1, trans2);\n\t}\n\n\treturn blank > transition ? blank - transition : 0;\n}\n\n \nstatic int dsi_compute_interleave_lp(int blank, int enter_hs, int exit_hs,\n\t\tint lp_clk_div, int tdsi_fclk)\n{\n\tint trans_lp;\t \n\tint tlp_avail;\t \n\tint ttxclkesc;\t \n\tint thsbyte_clk = 16;\t \n\tint lp_inter;\t \n\n\t \n\ttrans_lp = exit_hs + max(enter_hs, 2) + 1;\n\n\t \n\ttlp_avail = thsbyte_clk * (blank - trans_lp);\n\n\tttxclkesc = tdsi_fclk * lp_clk_div;\n\n\tlp_inter = ((tlp_avail - 8 * thsbyte_clk - 5 * tdsi_fclk) / ttxclkesc -\n\t\t\t26) / 16;\n\n\treturn max(lp_inter, 0);\n}\n\nstatic void dsi_config_cmd_mode_interleaving(struct dsi_data *dsi)\n{\n\tint blanking_mode;\n\tint hfp_blanking_mode, hbp_blanking_mode, hsa_blanking_mode;\n\tint hsa, hfp, hbp, width_bytes, bllp, lp_clk_div;\n\tint ddr_clk_pre, ddr_clk_post, enter_hs_mode_lat, exit_hs_mode_lat;\n\tint tclk_trail, ths_exit, exiths_clk;\n\tbool ddr_alwon;\n\tconst struct videomode *vm = &dsi->vm;\n\tint bpp = mipi_dsi_pixel_format_to_bpp(dsi->pix_fmt);\n\tint ndl = dsi->num_lanes_used - 1;\n\tint dsi_fclk_hsdiv = dsi->user_dsi_cinfo.mX[HSDIV_DSI] + 1;\n\tint hsa_interleave_hs = 0, hsa_interleave_lp = 0;\n\tint hfp_interleave_hs = 0, hfp_interleave_lp = 0;\n\tint hbp_interleave_hs = 0, hbp_interleave_lp = 0;\n\tint bl_interleave_hs = 0, bl_interleave_lp = 0;\n\tu32 r;\n\n\tr = dsi_read_reg(dsi, DSI_CTRL);\n\tblanking_mode = FLD_GET(r, 20, 20);\n\thfp_blanking_mode = FLD_GET(r, 21, 21);\n\thbp_blanking_mode = FLD_GET(r, 22, 22);\n\thsa_blanking_mode = FLD_GET(r, 23, 23);\n\n\tr = dsi_read_reg(dsi, DSI_VM_TIMING1);\n\thbp = FLD_GET(r, 11, 0);\n\thfp = FLD_GET(r, 23, 12);\n\thsa = FLD_GET(r, 31, 24);\n\n\tr = dsi_read_reg(dsi, DSI_CLK_TIMING);\n\tddr_clk_post = FLD_GET(r, 7, 0);\n\tddr_clk_pre = FLD_GET(r, 15, 8);\n\n\tr = dsi_read_reg(dsi, DSI_VM_TIMING7);\n\texit_hs_mode_lat = FLD_GET(r, 15, 0);\n\tenter_hs_mode_lat = FLD_GET(r, 31, 16);\n\n\tr = dsi_read_reg(dsi, DSI_CLK_CTRL);\n\tlp_clk_div = FLD_GET(r, 12, 0);\n\tddr_alwon = FLD_GET(r, 13, 13);\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG0);\n\tths_exit = FLD_GET(r, 7, 0);\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG1);\n\ttclk_trail = FLD_GET(r, 15, 8);\n\n\texiths_clk = ths_exit + tclk_trail;\n\n\twidth_bytes = DIV_ROUND_UP(vm->hactive * bpp, 8);\n\tbllp = hbp + hfp + hsa + DIV_ROUND_UP(width_bytes + 6, ndl);\n\n\tif (!hsa_blanking_mode) {\n\t\thsa_interleave_hs = dsi_compute_interleave_hs(hsa, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\t\thsa_interleave_lp = dsi_compute_interleave_lp(hsa,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tif (!hfp_blanking_mode) {\n\t\thfp_interleave_hs = dsi_compute_interleave_hs(hfp, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\t\thfp_interleave_lp = dsi_compute_interleave_lp(hfp,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tif (!hbp_blanking_mode) {\n\t\thbp_interleave_hs = dsi_compute_interleave_hs(hbp, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\n\t\thbp_interleave_lp = dsi_compute_interleave_lp(hbp,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tif (!blanking_mode) {\n\t\tbl_interleave_hs = dsi_compute_interleave_hs(bllp, ddr_alwon,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\texiths_clk, ddr_clk_pre, ddr_clk_post);\n\n\t\tbl_interleave_lp = dsi_compute_interleave_lp(bllp,\n\t\t\t\t\tenter_hs_mode_lat, exit_hs_mode_lat,\n\t\t\t\t\tlp_clk_div, dsi_fclk_hsdiv);\n\t}\n\n\tDSSDBG(\"DSI HS interleaving(TXBYTECLKHS) HSA %d, HFP %d, HBP %d, BLLP %d\\n\",\n\t\thsa_interleave_hs, hfp_interleave_hs, hbp_interleave_hs,\n\t\tbl_interleave_hs);\n\n\tDSSDBG(\"DSI LP interleaving(bytes) HSA %d, HFP %d, HBP %d, BLLP %d\\n\",\n\t\thsa_interleave_lp, hfp_interleave_lp, hbp_interleave_lp,\n\t\tbl_interleave_lp);\n\n\tr = dsi_read_reg(dsi, DSI_VM_TIMING4);\n\tr = FLD_MOD(r, hsa_interleave_hs, 23, 16);\n\tr = FLD_MOD(r, hfp_interleave_hs, 15, 8);\n\tr = FLD_MOD(r, hbp_interleave_hs, 7, 0);\n\tdsi_write_reg(dsi, DSI_VM_TIMING4, r);\n\n\tr = dsi_read_reg(dsi, DSI_VM_TIMING5);\n\tr = FLD_MOD(r, hsa_interleave_lp, 23, 16);\n\tr = FLD_MOD(r, hfp_interleave_lp, 15, 8);\n\tr = FLD_MOD(r, hbp_interleave_lp, 7, 0);\n\tdsi_write_reg(dsi, DSI_VM_TIMING5, r);\n\n\tr = dsi_read_reg(dsi, DSI_VM_TIMING6);\n\tr = FLD_MOD(r, bl_interleave_hs, 31, 15);\n\tr = FLD_MOD(r, bl_interleave_lp, 16, 0);\n\tdsi_write_reg(dsi, DSI_VM_TIMING6, r);\n}\n\nstatic int dsi_proto_config(struct dsi_data *dsi)\n{\n\tu32 r;\n\tint buswidth = 0;\n\n\tdsi_config_tx_fifo(dsi, DSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32);\n\n\tdsi_config_rx_fifo(dsi, DSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32,\n\t\t\tDSI_FIFO_SIZE_32);\n\n\t \n\tdsi_set_stop_state_counter(dsi, 0x1000, false, false);\n\tdsi_set_ta_timeout(dsi, 0x1fff, true, true);\n\tdsi_set_lp_rx_timeout(dsi, 0x1fff, true, true);\n\tdsi_set_hs_tx_timeout(dsi, 0x1fff, true, true);\n\n\tswitch (mipi_dsi_pixel_format_to_bpp(dsi->pix_fmt)) {\n\tcase 16:\n\t\tbuswidth = 0;\n\t\tbreak;\n\tcase 18:\n\t\tbuswidth = 1;\n\t\tbreak;\n\tcase 24:\n\t\tbuswidth = 2;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\n\tr = dsi_read_reg(dsi, DSI_CTRL);\n\tr = FLD_MOD(r, 1, 1, 1);\t \n\tr = FLD_MOD(r, 1, 2, 2);\t \n\tr = FLD_MOD(r, 1, 3, 3);\t \n\tr = FLD_MOD(r, 1, 4, 4);\t \n\tr = FLD_MOD(r, buswidth, 7, 6);  \n\tr = FLD_MOD(r, 0, 8, 8);\t \n\tr = FLD_MOD(r, 1, 14, 14);\t \n\tr = FLD_MOD(r, 1, 19, 19);\t \n\tif (!(dsi->data->quirks & DSI_QUIRK_DCS_CMD_CONFIG_VC)) {\n\t\tr = FLD_MOD(r, 1, 24, 24);\t \n\t\t \n\t\tr = FLD_MOD(r, 0, 25, 25);\n\t}\n\n\tdsi_write_reg(dsi, DSI_CTRL, r);\n\n\tdsi_config_vp_num_line_buffers(dsi);\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tdsi_config_vp_sync_events(dsi);\n\t\tdsi_config_blanking_modes(dsi);\n\t\tdsi_config_cmd_mode_interleaving(dsi);\n\t}\n\n\tdsi_vc_initial_config(dsi, 0);\n\tdsi_vc_initial_config(dsi, 1);\n\tdsi_vc_initial_config(dsi, 2);\n\tdsi_vc_initial_config(dsi, 3);\n\n\treturn 0;\n}\n\nstatic void dsi_proto_timings(struct dsi_data *dsi)\n{\n\tunsigned int tlpx, tclk_zero, tclk_prepare;\n\tunsigned int tclk_pre, tclk_post;\n\tunsigned int ths_prepare, ths_prepare_ths_zero, ths_zero;\n\tunsigned int ths_trail, ths_exit;\n\tunsigned int ddr_clk_pre, ddr_clk_post;\n\tunsigned int enter_hs_mode_lat, exit_hs_mode_lat;\n\tunsigned int ths_eot;\n\tint ndl = dsi->num_lanes_used - 1;\n\tu32 r;\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG0);\n\tths_prepare = FLD_GET(r, 31, 24);\n\tths_prepare_ths_zero = FLD_GET(r, 23, 16);\n\tths_zero = ths_prepare_ths_zero - ths_prepare;\n\tths_trail = FLD_GET(r, 15, 8);\n\tths_exit = FLD_GET(r, 7, 0);\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG1);\n\ttlpx = FLD_GET(r, 20, 16) * 2;\n\ttclk_zero = FLD_GET(r, 7, 0);\n\n\tr = dsi_read_reg(dsi, DSI_DSIPHY_CFG2);\n\ttclk_prepare = FLD_GET(r, 7, 0);\n\n\t \n\ttclk_pre = 20;\n\t \n\ttclk_post = ns2ddr(dsi, 60) + 26;\n\n\tths_eot = DIV_ROUND_UP(4, ndl);\n\n\tddr_clk_pre = DIV_ROUND_UP(tclk_pre + tlpx + tclk_zero + tclk_prepare,\n\t\t\t4);\n\tddr_clk_post = DIV_ROUND_UP(tclk_post + ths_trail, 4) + ths_eot;\n\n\tBUG_ON(ddr_clk_pre == 0 || ddr_clk_pre > 255);\n\tBUG_ON(ddr_clk_post == 0 || ddr_clk_post > 255);\n\n\tr = dsi_read_reg(dsi, DSI_CLK_TIMING);\n\tr = FLD_MOD(r, ddr_clk_pre, 15, 8);\n\tr = FLD_MOD(r, ddr_clk_post, 7, 0);\n\tdsi_write_reg(dsi, DSI_CLK_TIMING, r);\n\n\tDSSDBG(\"ddr_clk_pre %u, ddr_clk_post %u\\n\",\n\t\t\tddr_clk_pre,\n\t\t\tddr_clk_post);\n\n\tenter_hs_mode_lat = 1 + DIV_ROUND_UP(tlpx, 4) +\n\t\tDIV_ROUND_UP(ths_prepare, 4) +\n\t\tDIV_ROUND_UP(ths_zero + 3, 4);\n\n\texit_hs_mode_lat = DIV_ROUND_UP(ths_trail + ths_exit, 4) + 1 + ths_eot;\n\n\tr = FLD_VAL(enter_hs_mode_lat, 31, 16) |\n\t\tFLD_VAL(exit_hs_mode_lat, 15, 0);\n\tdsi_write_reg(dsi, DSI_VM_TIMING7, r);\n\n\tDSSDBG(\"enter_hs_mode_lat %u, exit_hs_mode_lat %u\\n\",\n\t\t\tenter_hs_mode_lat, exit_hs_mode_lat);\n\n\t if (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\t \n\t\tint hsa = dsi->vm_timings.hsa;\n\t\tint hfp = dsi->vm_timings.hfp;\n\t\tint hbp = dsi->vm_timings.hbp;\n\t\tint vsa = dsi->vm_timings.vsa;\n\t\tint vfp = dsi->vm_timings.vfp;\n\t\tint vbp = dsi->vm_timings.vbp;\n\t\tint window_sync = dsi->vm_timings.window_sync;\n\t\tbool hsync_end;\n\t\tconst struct videomode *vm = &dsi->vm;\n\t\tint bpp = mipi_dsi_pixel_format_to_bpp(dsi->pix_fmt);\n\t\tint tl, t_he, width_bytes;\n\n\t\thsync_end = dsi->vm_timings.trans_mode == OMAP_DSS_DSI_PULSE_MODE;\n\t\tt_he = hsync_end ?\n\t\t\t((hsa == 0 && ndl == 3) ? 1 : DIV_ROUND_UP(4, ndl)) : 0;\n\n\t\twidth_bytes = DIV_ROUND_UP(vm->hactive * bpp, 8);\n\n\t\t \n\t\ttl = DIV_ROUND_UP(4, ndl) + (hsync_end ? hsa : 0) + t_he + hfp +\n\t\t\tDIV_ROUND_UP(width_bytes + 6, ndl) + hbp;\n\n\t\tDSSDBG(\"HBP: %d, HFP: %d, HSA: %d, TL: %d TXBYTECLKHS\\n\", hbp,\n\t\t\thfp, hsync_end ? hsa : 0, tl);\n\t\tDSSDBG(\"VBP: %d, VFP: %d, VSA: %d, VACT: %d lines\\n\", vbp, vfp,\n\t\t\tvsa, vm->vactive);\n\n\t\tr = dsi_read_reg(dsi, DSI_VM_TIMING1);\n\t\tr = FLD_MOD(r, hbp, 11, 0);\t \n\t\tr = FLD_MOD(r, hfp, 23, 12);\t \n\t\tr = FLD_MOD(r, hsync_end ? hsa : 0, 31, 24);\t \n\t\tdsi_write_reg(dsi, DSI_VM_TIMING1, r);\n\n\t\tr = dsi_read_reg(dsi, DSI_VM_TIMING2);\n\t\tr = FLD_MOD(r, vbp, 7, 0);\t \n\t\tr = FLD_MOD(r, vfp, 15, 8);\t \n\t\tr = FLD_MOD(r, vsa, 23, 16);\t \n\t\tr = FLD_MOD(r, window_sync, 27, 24);\t \n\t\tdsi_write_reg(dsi, DSI_VM_TIMING2, r);\n\n\t\tr = dsi_read_reg(dsi, DSI_VM_TIMING3);\n\t\tr = FLD_MOD(r, vm->vactive, 14, 0);\t \n\t\tr = FLD_MOD(r, tl, 31, 16);\t\t \n\t\tdsi_write_reg(dsi, DSI_VM_TIMING3, r);\n\t}\n}\n\nstatic int dsi_configure_pins(struct dsi_data *dsi,\n\t\tint num_pins, const u32 *pins)\n{\n\tstruct dsi_lane_config lanes[DSI_MAX_NR_LANES];\n\tint num_lanes;\n\tint i;\n\n\tstatic const enum dsi_lane_function functions[] = {\n\t\tDSI_LANE_CLK,\n\t\tDSI_LANE_DATA1,\n\t\tDSI_LANE_DATA2,\n\t\tDSI_LANE_DATA3,\n\t\tDSI_LANE_DATA4,\n\t};\n\n\tif (num_pins < 4 || num_pins > dsi->num_lanes_supported * 2\n\t\t\t|| num_pins % 2 != 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < DSI_MAX_NR_LANES; ++i)\n\t\tlanes[i].function = DSI_LANE_UNUSED;\n\n\tnum_lanes = 0;\n\n\tfor (i = 0; i < num_pins; i += 2) {\n\t\tu8 lane, pol;\n\t\tu32 dx, dy;\n\n\t\tdx = pins[i];\n\t\tdy = pins[i + 1];\n\n\t\tif (dx >= dsi->num_lanes_supported * 2)\n\t\t\treturn -EINVAL;\n\n\t\tif (dy >= dsi->num_lanes_supported * 2)\n\t\t\treturn -EINVAL;\n\n\t\tif (dx & 1) {\n\t\t\tif (dy != dx - 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tpol = 1;\n\t\t} else {\n\t\t\tif (dy != dx + 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tpol = 0;\n\t\t}\n\n\t\tlane = dx / 2;\n\n\t\tlanes[lane].function = functions[i / 2];\n\t\tlanes[lane].polarity = pol;\n\t\tnum_lanes++;\n\t}\n\n\tmemcpy(dsi->lanes, lanes, sizeof(dsi->lanes));\n\tdsi->num_lanes_used = num_lanes;\n\n\treturn 0;\n}\n\nstatic int dsi_enable_video_mode(struct dsi_data *dsi, int vc)\n{\n\tint bpp = mipi_dsi_pixel_format_to_bpp(dsi->pix_fmt);\n\tu8 data_type;\n\tu16 word_count;\n\n\tswitch (dsi->pix_fmt) {\n\tcase MIPI_DSI_FMT_RGB888:\n\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_24;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666:\n\t\tdata_type = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB666_PACKED:\n\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_18;\n\t\tbreak;\n\tcase MIPI_DSI_FMT_RGB565:\n\t\tdata_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdsi_if_enable(dsi, false);\n\tdsi_vc_enable(dsi, vc, false);\n\n\t \n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(vc), 1, 4, 4);\n\n\tword_count = DIV_ROUND_UP(dsi->vm.hactive * bpp, 8);\n\n\tdsi_vc_write_long_header(dsi, vc, dsi->dsidev->channel, data_type,\n\t\t\tword_count, 0);\n\n\tdsi_vc_enable(dsi, vc, true);\n\tdsi_if_enable(dsi, true);\n\n\treturn 0;\n}\n\nstatic void dsi_disable_video_mode(struct dsi_data *dsi, int vc)\n{\n\tdsi_if_enable(dsi, false);\n\tdsi_vc_enable(dsi, vc, false);\n\n\t \n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(vc), 0, 4, 4);\n\n\tdsi_vc_enable(dsi, vc, true);\n\tdsi_if_enable(dsi, true);\n}\n\nstatic void dsi_enable_video_output(struct omap_dss_device *dssdev, int vc)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tint r;\n\n\tr = dsi_init_dispc(dsi);\n\tif (r) {\n\t\tdev_err(dsi->dev, \"failed to init dispc!\\n\");\n\t\treturn;\n\t}\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tr = dsi_enable_video_mode(dsi, vc);\n\t\tif (r)\n\t\t\tgoto err_video_mode;\n\t}\n\n\tr = dss_mgr_enable(&dsi->output);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\treturn;\n\nerr_mgr_enable:\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\n\t\tdsi_if_enable(dsi, false);\n\t\tdsi_vc_enable(dsi, vc, false);\n\t}\nerr_video_mode:\n\tdsi_uninit_dispc(dsi);\n\tdev_err(dsi->dev, \"failed to enable DSI encoder!\\n\");\n\treturn;\n}\n\nstatic void dsi_disable_video_output(struct omap_dss_device *dssdev, int vc)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE)\n\t\tdsi_disable_video_mode(dsi, vc);\n\n\tdss_mgr_disable(&dsi->output);\n\n\tdsi_uninit_dispc(dsi);\n}\n\nstatic void dsi_update_screen_dispc(struct dsi_data *dsi)\n{\n\tunsigned int bytespp;\n\tunsigned int bytespl;\n\tunsigned int bytespf;\n\tunsigned int total_len;\n\tunsigned int packet_payload;\n\tunsigned int packet_len;\n\tu32 l;\n\tint r;\n\tconst unsigned vc = dsi->update_vc;\n\tconst unsigned int line_buf_size = dsi->line_buffer_size;\n\tu16 w = dsi->vm.hactive;\n\tu16 h = dsi->vm.vactive;\n\n\tDSSDBG(\"dsi_update_screen_dispc(%dx%d)\\n\", w, h);\n\n\tbytespp\t= mipi_dsi_pixel_format_to_bpp(dsi->pix_fmt) / 8;\n\tbytespl = w * bytespp;\n\tbytespf = bytespl * h;\n\n\t \n\n\tif (bytespf < line_buf_size)\n\t\tpacket_payload = bytespf;\n\telse\n\t\tpacket_payload = (line_buf_size) / bytespl * bytespl;\n\n\tpacket_len = packet_payload + 1;\t \n\ttotal_len = (bytespf / packet_payload) * packet_len;\n\n\tif (bytespf % packet_payload)\n\t\ttotal_len += (bytespf % packet_payload) + 1;\n\n\tl = FLD_VAL(total_len, 23, 0);  \n\tdsi_write_reg(dsi, DSI_VC_TE(vc), l);\n\n\tdsi_vc_write_long_header(dsi, vc, dsi->dsidev->channel, MIPI_DSI_DCS_LONG_WRITE,\n\t\tpacket_len, 0);\n\n\tif (dsi->te_enabled)\n\t\tl = FLD_MOD(l, 1, 30, 30);  \n\telse\n\t\tl = FLD_MOD(l, 1, 31, 31);  \n\tdsi_write_reg(dsi, DSI_VC_TE(vc), l);\n\n\t \n\tdispc_disable_sidle(dsi->dss->dispc);\n\n\tdsi_perf_mark_start(dsi);\n\n\tr = schedule_delayed_work(&dsi->framedone_timeout_work,\n\t\tmsecs_to_jiffies(250));\n\tBUG_ON(r == 0);\n\n\tdss_mgr_start_update(&dsi->output);\n\n\tif (dsi->te_enabled) {\n\t\t \n\t\tREG_FLD_MOD(dsi, DSI_TIMING2, 0, 15, 15);  \n\n\t\tdsi_vc_send_bta(dsi, vc);\n\n#ifdef DSI_CATCH_MISSING_TE\n\t\tmod_timer(&dsi->te_timer, jiffies + msecs_to_jiffies(250));\n#endif\n\t}\n}\n\n#ifdef DSI_CATCH_MISSING_TE\nstatic void dsi_te_timeout(struct timer_list *unused)\n{\n\tDSSERR(\"TE not received for 250ms!\\n\");\n}\n#endif\n\nstatic void dsi_handle_framedone(struct dsi_data *dsi, int error)\n{\n\t \n\tdispc_enable_sidle(dsi->dss->dispc);\n\n\tif (dsi->te_enabled) {\n\t\t \n\t\tREG_FLD_MOD(dsi, DSI_TIMING2, 1, 15, 15);  \n\t}\n\n\tdsi_bus_unlock(dsi);\n\n\tif (!error)\n\t\tdsi_perf_show(dsi, \"DISPC\");\n}\n\nstatic void dsi_framedone_timeout_work_callback(struct work_struct *work)\n{\n\tstruct dsi_data *dsi = container_of(work, struct dsi_data,\n\t\t\tframedone_timeout_work.work);\n\t \n\n\tDSSERR(\"Framedone not received for 250ms!\\n\");\n\n\tdsi_handle_framedone(dsi, -ETIMEDOUT);\n}\n\nstatic void dsi_framedone_irq_callback(void *data)\n{\n\tstruct dsi_data *dsi = data;\n\n\t \n\n\tcancel_delayed_work(&dsi->framedone_timeout_work);\n\n\tDSSDBG(\"Framedone received!\\n\");\n\n\tdsi_handle_framedone(dsi, 0);\n}\n\nstatic int _dsi_update(struct dsi_data *dsi)\n{\n\tdsi_perf_mark_setup(dsi);\n\n#ifdef DSI_PERF_MEASURE\n\tdsi->update_bytes = dsi->vm.hactive * dsi->vm.vactive *\n\t\tmipi_dsi_pixel_format_to_bpp(dsi->pix_fmt) / 8;\n#endif\n\tdsi_update_screen_dispc(dsi);\n\n\treturn 0;\n}\n\nstatic int _dsi_send_nop(struct dsi_data *dsi, int vc, int channel)\n{\n\tconst u8 payload[] = { MIPI_DCS_NOP };\n\tconst struct mipi_dsi_msg msg = {\n\t\t.channel = channel,\n\t\t.type = MIPI_DSI_DCS_SHORT_WRITE,\n\t\t.tx_len = 1,\n\t\t.tx_buf = payload,\n\t};\n\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\treturn _omap_dsi_host_transfer(dsi, vc, &msg);\n}\n\nstatic int dsi_update_channel(struct omap_dss_device *dssdev, int vc)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tint r;\n\n\tdsi_bus_lock(dsi);\n\n\tif (!dsi->video_enabled) {\n\t\tr = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (dsi->vm.hactive == 0 || dsi->vm.vactive == 0) {\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tDSSDBG(\"dsi_update_channel: %d\", vc);\n\n\t \n\tr = _dsi_send_nop(dsi, VC_CMD, dsi->dsidev->channel);\n\tif (r < 0) {\n\t\tDSSWARN(\"failed to send nop between frames: %d\\n\", r);\n\t\tgoto err;\n\t}\n\n\tdsi->update_vc = vc;\n\n\tif (dsi->te_enabled && dsi->te_gpio) {\n\t\tschedule_delayed_work(&dsi->te_timeout_work,\n\t\t\t\t      msecs_to_jiffies(250));\n\t\tatomic_set(&dsi->do_ext_te_update, 1);\n\t} else {\n\t\t_dsi_update(dsi);\n\t}\n\n\treturn 0;\n\nerr:\n\tdsi_bus_unlock(dsi);\n\treturn r;\n}\n\nstatic int dsi_update_all(struct omap_dss_device *dssdev)\n{\n\treturn dsi_update_channel(dssdev, VC_VIDEO);\n}\n\n \n\nstatic int dsi_configure_dispc_clocks(struct dsi_data *dsi)\n{\n\tstruct dispc_clock_info dispc_cinfo;\n\tint r;\n\tunsigned long fck;\n\n\tfck = dsi_get_pll_hsdiv_dispc_rate(dsi);\n\n\tdispc_cinfo.lck_div = dsi->user_dispc_cinfo.lck_div;\n\tdispc_cinfo.pck_div = dsi->user_dispc_cinfo.pck_div;\n\n\tr = dispc_calc_clock_rates(dsi->dss->dispc, fck, &dispc_cinfo);\n\tif (r) {\n\t\tDSSERR(\"Failed to calc dispc clocks\\n\");\n\t\treturn r;\n\t}\n\n\tdsi->mgr_config.clock_info = dispc_cinfo;\n\n\treturn 0;\n}\n\nstatic int dsi_init_dispc(struct dsi_data *dsi)\n{\n\tenum omap_channel dispc_channel = dsi->output.dispc_channel;\n\tint r;\n\n\tdss_select_lcd_clk_source(dsi->dss, dispc_channel, dsi->module_id == 0 ?\n\t\t\tDSS_CLK_SRC_PLL1_1 :\n\t\t\tDSS_CLK_SRC_PLL2_1);\n\n\tif (dsi->mode == OMAP_DSS_DSI_CMD_MODE) {\n\t\tr = dss_mgr_register_framedone_handler(&dsi->output,\n\t\t\t\tdsi_framedone_irq_callback, dsi);\n\t\tif (r) {\n\t\t\tDSSERR(\"can't register FRAMEDONE handler\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tdsi->mgr_config.stallmode = true;\n\t\tdsi->mgr_config.fifohandcheck = true;\n\t} else {\n\t\tdsi->mgr_config.stallmode = false;\n\t\tdsi->mgr_config.fifohandcheck = false;\n\t}\n\n\tr = dsi_configure_dispc_clocks(dsi);\n\tif (r)\n\t\tgoto err1;\n\n\tdsi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\n\tdsi->mgr_config.video_port_width =\n\t\t\tmipi_dsi_pixel_format_to_bpp(dsi->pix_fmt);\n\tdsi->mgr_config.lcden_sig_polarity = 0;\n\n\tdss_mgr_set_lcd_config(&dsi->output, &dsi->mgr_config);\n\n\treturn 0;\nerr1:\n\tif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\n\t\tdss_mgr_unregister_framedone_handler(&dsi->output,\n\t\t\t\tdsi_framedone_irq_callback, dsi);\nerr:\n\tdss_select_lcd_clk_source(dsi->dss, dispc_channel, DSS_CLK_SRC_FCK);\n\treturn r;\n}\n\nstatic void dsi_uninit_dispc(struct dsi_data *dsi)\n{\n\tenum omap_channel dispc_channel = dsi->output.dispc_channel;\n\n\tif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\n\t\tdss_mgr_unregister_framedone_handler(&dsi->output,\n\t\t\t\tdsi_framedone_irq_callback, dsi);\n\n\tdss_select_lcd_clk_source(dsi->dss, dispc_channel, DSS_CLK_SRC_FCK);\n}\n\nstatic int dsi_configure_dsi_clocks(struct dsi_data *dsi)\n{\n\tstruct dss_pll_clock_info cinfo;\n\tint r;\n\n\tcinfo = dsi->user_dsi_cinfo;\n\n\tr = dss_pll_set_config(&dsi->pll, &cinfo);\n\tif (r) {\n\t\tDSSERR(\"Failed to set dsi clocks\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic void dsi_setup_dsi_vcs(struct dsi_data *dsi)\n{\n\t \n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(VC_CMD), 0, 9, 9);  \n\n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(VC_CMD), 0, 1, 1);  \n\tdsi->vc[VC_CMD].source = DSI_VC_SOURCE_L4;\n\n\t \n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(VC_VIDEO), 1, 9, 9);  \n\n\tREG_FLD_MOD(dsi, DSI_VC_CTRL(VC_VIDEO), 1, 1, 1);  \n\tdsi->vc[VC_VIDEO].source = DSI_VC_SOURCE_VP;\n\n\tif ((dsi->data->quirks & DSI_QUIRK_DCS_CMD_CONFIG_VC) &&\n\t    !(dsi->dsidev->mode_flags & MIPI_DSI_MODE_VIDEO))\n\t\tREG_FLD_MOD(dsi, DSI_VC_CTRL(VC_VIDEO), 1, 30, 30);  \n\n\tdsi_vc_enable(dsi, VC_CMD, 1);\n\tdsi_vc_enable(dsi, VC_VIDEO, 1);\n\n\tdsi_if_enable(dsi, 1);\n\n\tdsi_force_tx_stop_mode_io(dsi);\n\n\t \n\tif (!(dsi->dsidev->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS))\n\t\tdsi_vc_send_null(dsi, VC_CMD, dsi->dsidev->channel);\n}\n\nstatic int dsi_init_dsi(struct dsi_data *dsi)\n{\n\tint r;\n\n\tr = dss_pll_enable(&dsi->pll);\n\tif (r)\n\t\treturn r;\n\n\tr = dsi_configure_dsi_clocks(dsi);\n\tif (r)\n\t\tgoto err0;\n\n\tdss_select_dsi_clk_source(dsi->dss, dsi->module_id,\n\t\t\t\t  dsi->module_id == 0 ?\n\t\t\t\t  DSS_CLK_SRC_PLL1_2 : DSS_CLK_SRC_PLL2_2);\n\n\tDSSDBG(\"PLL OK\\n\");\n\n\tif (!dsi->vdds_dsi_enabled) {\n\t\tr = regulator_enable(dsi->vdds_dsi_reg);\n\t\tif (r)\n\t\t\tgoto err1;\n\n\t\tdsi->vdds_dsi_enabled = true;\n\t}\n\n\tr = dsi_cio_init(dsi);\n\tif (r)\n\t\tgoto err2;\n\n\t_dsi_print_reset_status(dsi);\n\n\tdsi_proto_timings(dsi);\n\tdsi_set_lp_clk_divisor(dsi);\n\n\tif (1)\n\t\t_dsi_print_reset_status(dsi);\n\n\tr = dsi_proto_config(dsi);\n\tif (r)\n\t\tgoto err3;\n\n\tdsi_setup_dsi_vcs(dsi);\n\n\treturn 0;\nerr3:\n\tdsi_cio_uninit(dsi);\nerr2:\n\tregulator_disable(dsi->vdds_dsi_reg);\n\tdsi->vdds_dsi_enabled = false;\nerr1:\n\tdss_select_dsi_clk_source(dsi->dss, dsi->module_id, DSS_CLK_SRC_FCK);\nerr0:\n\tdss_pll_disable(&dsi->pll);\n\n\treturn r;\n}\n\nstatic void dsi_uninit_dsi(struct dsi_data *dsi)\n{\n\t \n\tdsi_if_enable(dsi, 0);\n\tdsi_vc_enable(dsi, 0, 0);\n\tdsi_vc_enable(dsi, 1, 0);\n\tdsi_vc_enable(dsi, 2, 0);\n\tdsi_vc_enable(dsi, 3, 0);\n\n\tdss_select_dsi_clk_source(dsi->dss, dsi->module_id, DSS_CLK_SRC_FCK);\n\tdsi_cio_uninit(dsi);\n\tdss_pll_disable(&dsi->pll);\n\n\tregulator_disable(dsi->vdds_dsi_reg);\n\tdsi->vdds_dsi_enabled = false;\n}\n\nstatic void dsi_enable(struct dsi_data *dsi)\n{\n\tint r;\n\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\tif (WARN_ON(dsi->iface_enabled))\n\t\treturn;\n\n\tmutex_lock(&dsi->lock);\n\n\tr = dsi_runtime_get(dsi);\n\tif (r)\n\t\tgoto err_get_dsi;\n\n\t_dsi_initialize_irq(dsi);\n\n\tr = dsi_init_dsi(dsi);\n\tif (r)\n\t\tgoto err_init_dsi;\n\n\tdsi->iface_enabled = true;\n\n\tmutex_unlock(&dsi->lock);\n\n\treturn;\n\nerr_init_dsi:\n\tdsi_runtime_put(dsi);\nerr_get_dsi:\n\tmutex_unlock(&dsi->lock);\n\tDSSDBG(\"dsi_enable FAILED\\n\");\n}\n\nstatic void dsi_disable(struct dsi_data *dsi)\n{\n\tWARN_ON(!dsi_bus_is_locked(dsi));\n\n\tif (WARN_ON(!dsi->iface_enabled))\n\t\treturn;\n\n\tmutex_lock(&dsi->lock);\n\n\tdsi_sync_vc(dsi, 0);\n\tdsi_sync_vc(dsi, 1);\n\tdsi_sync_vc(dsi, 2);\n\tdsi_sync_vc(dsi, 3);\n\n\tdsi_uninit_dsi(dsi);\n\n\tdsi_runtime_put(dsi);\n\n\tdsi->iface_enabled = false;\n\n\tmutex_unlock(&dsi->lock);\n}\n\nstatic int dsi_enable_te(struct dsi_data *dsi, bool enable)\n{\n\tdsi->te_enabled = enable;\n\n\tif (dsi->te_gpio) {\n\t\tif (enable)\n\t\t\tenable_irq(dsi->te_irq);\n\t\telse\n\t\t\tdisable_irq(dsi->te_irq);\n\t}\n\n\treturn 0;\n}\n\n#ifdef PRINT_VERBOSE_VM_TIMINGS\nstatic void print_dsi_vm(const char *str,\n\t\tconst struct omap_dss_dsi_videomode_timings *t)\n{\n\tunsigned long byteclk = t->hsclk / 4;\n\tint bl, wc, pps, tot;\n\n\twc = DIV_ROUND_UP(t->hact * t->bitspp, 8);\n\tpps = DIV_ROUND_UP(wc + 6, t->ndl);  \n\tbl = t->hss + t->hsa + t->hse + t->hbp + t->hfp;\n\ttot = bl + pps;\n\n#define TO_DSI_T(x) ((u32)div64_u64((u64)x * 1000000000llu, byteclk))\n\n\tpr_debug(\"%s bck %lu, %u/%u/%u/%u/%u/%u = %u+%u = %u, \"\n\t\t\t\"%u/%u/%u/%u/%u/%u = %u + %u = %u\\n\",\n\t\t\tstr,\n\t\t\tbyteclk,\n\t\t\tt->hss, t->hsa, t->hse, t->hbp, pps, t->hfp,\n\t\t\tbl, pps, tot,\n\t\t\tTO_DSI_T(t->hss),\n\t\t\tTO_DSI_T(t->hsa),\n\t\t\tTO_DSI_T(t->hse),\n\t\t\tTO_DSI_T(t->hbp),\n\t\t\tTO_DSI_T(pps),\n\t\t\tTO_DSI_T(t->hfp),\n\n\t\t\tTO_DSI_T(bl),\n\t\t\tTO_DSI_T(pps),\n\n\t\t\tTO_DSI_T(tot));\n#undef TO_DSI_T\n}\n\nstatic void print_dispc_vm(const char *str, const struct videomode *vm)\n{\n\tunsigned long pck = vm->pixelclock;\n\tint hact, bl, tot;\n\n\thact = vm->hactive;\n\tbl = vm->hsync_len + vm->hback_porch + vm->hfront_porch;\n\ttot = hact + bl;\n\n#define TO_DISPC_T(x) ((u32)div64_u64((u64)x * 1000000000llu, pck))\n\n\tpr_debug(\"%s pck %lu, %u/%u/%u/%u = %u+%u = %u, \"\n\t\t\t\"%u/%u/%u/%u = %u + %u = %u\\n\",\n\t\t\tstr,\n\t\t\tpck,\n\t\t\tvm->hsync_len, vm->hback_porch, hact, vm->hfront_porch,\n\t\t\tbl, hact, tot,\n\t\t\tTO_DISPC_T(vm->hsync_len),\n\t\t\tTO_DISPC_T(vm->hback_porch),\n\t\t\tTO_DISPC_T(hact),\n\t\t\tTO_DISPC_T(vm->hfront_porch),\n\t\t\tTO_DISPC_T(bl),\n\t\t\tTO_DISPC_T(hact),\n\t\t\tTO_DISPC_T(tot));\n#undef TO_DISPC_T\n}\n\n \nstatic void print_dsi_dispc_vm(const char *str,\n\t\tconst struct omap_dss_dsi_videomode_timings *t)\n{\n\tstruct videomode vm = { 0 };\n\tunsigned long byteclk = t->hsclk / 4;\n\tunsigned long pck;\n\tu64 dsi_tput;\n\tint dsi_hact, dsi_htot;\n\n\tdsi_tput = (u64)byteclk * t->ndl * 8;\n\tpck = (u32)div64_u64(dsi_tput, t->bitspp);\n\tdsi_hact = DIV_ROUND_UP(DIV_ROUND_UP(t->hact * t->bitspp, 8) + 6, t->ndl);\n\tdsi_htot = t->hss + t->hsa + t->hse + t->hbp + dsi_hact + t->hfp;\n\n\tvm.pixelclock = pck;\n\tvm.hsync_len = div64_u64((u64)(t->hsa + t->hse) * pck, byteclk);\n\tvm.hback_porch = div64_u64((u64)t->hbp * pck, byteclk);\n\tvm.hfront_porch = div64_u64((u64)t->hfp * pck, byteclk);\n\tvm.hactive = t->hact;\n\n\tprint_dispc_vm(str, &vm);\n}\n#endif  \n\nstatic bool dsi_cm_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\tstruct videomode *vm = &ctx->vm;\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\t*vm = *ctx->config->vm;\n\tvm->pixelclock = pck;\n\tvm->hactive = ctx->config->vm->hactive;\n\tvm->vactive = ctx->config->vm->vactive;\n\tvm->hsync_len = vm->hfront_porch = vm->hback_porch = vm->vsync_len = 1;\n\tvm->vfront_porch = vm->vback_porch = 0;\n\n\treturn true;\n}\n\nstatic bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n\t\tvoid *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\n\tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n\tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n\n\treturn dispc_div_calc(ctx->dsi->dss->dispc, dispc,\n\t\t\t      ctx->req_pck_min, ctx->req_pck_max,\n\t\t\t      dsi_cm_calc_dispc_cb, ctx);\n}\n\nstatic bool dsi_cm_calc_pll_cb(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\tstruct dsi_data *dsi = ctx->dsi;\n\n\tctx->dsi_cinfo.n = n;\n\tctx->dsi_cinfo.m = m;\n\tctx->dsi_cinfo.fint = fint;\n\tctx->dsi_cinfo.clkdco = clkdco;\n\n\treturn dss_pll_hsdiv_calc_a(ctx->pll, clkdco, ctx->req_pck_min,\n\t\t\tdsi->data->max_fck_freq,\n\t\t\tdsi_cm_calc_hsdiv_cb, ctx);\n}\n\nstatic bool dsi_cm_calc(struct dsi_data *dsi,\n\t\tconst struct omap_dss_dsi_config *cfg,\n\t\tstruct dsi_clk_calc_ctx *ctx)\n{\n\tunsigned long clkin;\n\tint bitspp, ndl;\n\tunsigned long pll_min, pll_max;\n\tunsigned long pck, txbyteclk;\n\n\tclkin = clk_get_rate(dsi->pll.clkin);\n\tbitspp = mipi_dsi_pixel_format_to_bpp(cfg->pixel_format);\n\tndl = dsi->num_lanes_used - 1;\n\n\t \n\tpck = cfg->vm->pixelclock;\n\tpck = pck * 3 / 2;\n\ttxbyteclk = pck * bitspp / 8 / ndl;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->dsi = dsi;\n\tctx->pll = &dsi->pll;\n\tctx->config = cfg;\n\tctx->req_pck_min = pck;\n\tctx->req_pck_nom = pck;\n\tctx->req_pck_max = pck * 3 / 2;\n\n\tpll_min = max(cfg->hs_clk_min * 4, txbyteclk * 4 * 4);\n\tpll_max = cfg->hs_clk_max * 4;\n\n\treturn dss_pll_calc_a(ctx->pll, clkin,\n\t\t\tpll_min, pll_max,\n\t\t\tdsi_cm_calc_pll_cb, ctx);\n}\n\nstatic bool dsi_vm_calc_blanking(struct dsi_clk_calc_ctx *ctx)\n{\n\tstruct dsi_data *dsi = ctx->dsi;\n\tconst struct omap_dss_dsi_config *cfg = ctx->config;\n\tint bitspp = mipi_dsi_pixel_format_to_bpp(cfg->pixel_format);\n\tint ndl = dsi->num_lanes_used - 1;\n\tunsigned long hsclk = ctx->dsi_cinfo.clkdco / 4;\n\tunsigned long byteclk = hsclk / 4;\n\n\tunsigned long dispc_pck, req_pck_min, req_pck_nom, req_pck_max;\n\tint xres;\n\tint panel_htot, panel_hbl;  \n\tint dispc_htot, dispc_hbl;  \n\tint dsi_htot, dsi_hact, dsi_hbl, hss, hse;  \n\tint hfp, hsa, hbp;\n\tconst struct videomode *req_vm;\n\tstruct videomode *dispc_vm;\n\tstruct omap_dss_dsi_videomode_timings *dsi_vm;\n\tu64 dsi_tput, dispc_tput;\n\n\tdsi_tput = (u64)byteclk * ndl * 8;\n\n\treq_vm = cfg->vm;\n\treq_pck_min = ctx->req_pck_min;\n\treq_pck_max = ctx->req_pck_max;\n\treq_pck_nom = ctx->req_pck_nom;\n\n\tdispc_pck = ctx->dispc_cinfo.pck;\n\tdispc_tput = (u64)dispc_pck * bitspp;\n\n\txres = req_vm->hactive;\n\n\tpanel_hbl = req_vm->hfront_porch + req_vm->hback_porch +\n\t\t    req_vm->hsync_len;\n\tpanel_htot = xres + panel_hbl;\n\n\tdsi_hact = DIV_ROUND_UP(DIV_ROUND_UP(xres * bitspp, 8) + 6, ndl);\n\n\t \n\tif (dsi->line_buffer_size < xres * bitspp / 8) {\n\t\tif (dispc_tput != dsi_tput)\n\t\t\treturn false;\n\t} else {\n\t\tif (dispc_tput < dsi_tput)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (dsi_tput < (u64)bitspp * req_pck_min)\n\t\treturn false;\n\n\t \n\tif (cfg->trans_mode != OMAP_DSS_DSI_BURST_MODE) {\n\t\tif (dsi_tput > (u64)bitspp * req_pck_max)\n\t\t\treturn false;\n\t}\n\n\thss = DIV_ROUND_UP(4, ndl);\n\n\tif (cfg->trans_mode == OMAP_DSS_DSI_PULSE_MODE) {\n\t\tif (ndl == 3 && req_vm->hsync_len == 0)\n\t\t\thse = 1;\n\t\telse\n\t\t\thse = DIV_ROUND_UP(4, ndl);\n\t} else {\n\t\thse = 0;\n\t}\n\n\t \n\tdsi_htot = div64_u64((u64)panel_htot * byteclk, req_pck_nom);\n\n\t \n\tif (dsi_htot < hss + hse + dsi_hact)\n\t\treturn false;\n\n\t \n\tdsi_hbl = dsi_htot - dsi_hact;\n\n\t \n\tdispc_htot = div64_u64((u64)dsi_htot * dispc_pck, byteclk);\n\n\t \n\tif ((u64)dsi_htot * dispc_pck != (u64)dispc_htot * byteclk)\n\t\treturn false;\n\n\tdispc_hbl = dispc_htot - xres;\n\n\t \n\n\tdsi_vm = &ctx->dsi_vm;\n\tmemset(dsi_vm, 0, sizeof(*dsi_vm));\n\n\tdsi_vm->hsclk = hsclk;\n\n\tdsi_vm->ndl = ndl;\n\tdsi_vm->bitspp = bitspp;\n\n\tif (cfg->trans_mode != OMAP_DSS_DSI_PULSE_MODE) {\n\t\thsa = 0;\n\t} else if (ndl == 3 && req_vm->hsync_len == 0) {\n\t\thsa = 0;\n\t} else {\n\t\thsa = div64_u64((u64)req_vm->hsync_len * byteclk, req_pck_nom);\n\t\thsa = max(hsa - hse, 1);\n\t}\n\n\thbp = div64_u64((u64)req_vm->hback_porch * byteclk, req_pck_nom);\n\thbp = max(hbp, 1);\n\n\thfp = dsi_hbl - (hss + hsa + hse + hbp);\n\tif (hfp < 1) {\n\t\tint t;\n\t\t \n\n\t\tt = 1 - hfp;\n\t\thbp = max(hbp - t, 1);\n\t\thfp = dsi_hbl - (hss + hsa + hse + hbp);\n\n\t\tif (hfp < 1 && hsa > 0) {\n\t\t\t \n\t\t\tt = 1 - hfp;\n\t\t\thsa = max(hsa - t, 1);\n\t\t\thfp = dsi_hbl - (hss + hsa + hse + hbp);\n\t\t}\n\t}\n\n\tif (hfp < 1)\n\t\treturn false;\n\n\tdsi_vm->hss = hss;\n\tdsi_vm->hsa = hsa;\n\tdsi_vm->hse = hse;\n\tdsi_vm->hbp = hbp;\n\tdsi_vm->hact = xres;\n\tdsi_vm->hfp = hfp;\n\n\tdsi_vm->vsa = req_vm->vsync_len;\n\tdsi_vm->vbp = req_vm->vback_porch;\n\tdsi_vm->vact = req_vm->vactive;\n\tdsi_vm->vfp = req_vm->vfront_porch;\n\n\tdsi_vm->trans_mode = cfg->trans_mode;\n\n\tdsi_vm->blanking_mode = 0;\n\tdsi_vm->hsa_blanking_mode = 1;\n\tdsi_vm->hfp_blanking_mode = 1;\n\tdsi_vm->hbp_blanking_mode = 1;\n\n\tdsi_vm->window_sync = 4;\n\n\t \n\n\tdispc_vm = &ctx->vm;\n\t*dispc_vm = *req_vm;\n\tdispc_vm->pixelclock = dispc_pck;\n\n\tif (cfg->trans_mode == OMAP_DSS_DSI_PULSE_MODE) {\n\t\thsa = div64_u64((u64)req_vm->hsync_len * dispc_pck,\n\t\t\t\treq_pck_nom);\n\t\thsa = max(hsa, 1);\n\t} else {\n\t\thsa = 1;\n\t}\n\n\thbp = div64_u64((u64)req_vm->hback_porch * dispc_pck, req_pck_nom);\n\thbp = max(hbp, 1);\n\n\thfp = dispc_hbl - hsa - hbp;\n\tif (hfp < 1) {\n\t\tint t;\n\t\t \n\n\t\tt = 1 - hfp;\n\t\thbp = max(hbp - t, 1);\n\t\thfp = dispc_hbl - hsa - hbp;\n\n\t\tif (hfp < 1) {\n\t\t\t \n\t\t\tt = 1 - hfp;\n\t\t\thsa = max(hsa - t, 1);\n\t\t\thfp = dispc_hbl - hsa - hbp;\n\t\t}\n\t}\n\n\tif (hfp < 1)\n\t\treturn false;\n\n\tdispc_vm->hfront_porch = hfp;\n\tdispc_vm->hsync_len = hsa;\n\tdispc_vm->hback_porch = hbp;\n\n\treturn true;\n}\n\n\nstatic bool dsi_vm_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\tif (dsi_vm_calc_blanking(ctx) == false)\n\t\treturn false;\n\n#ifdef PRINT_VERBOSE_VM_TIMINGS\n\tprint_dispc_vm(\"dispc\", &ctx->vm);\n\tprint_dsi_vm(\"dsi  \", &ctx->dsi_vm);\n\tprint_dispc_vm(\"req  \", ctx->config->vm);\n\tprint_dsi_dispc_vm(\"act  \", &ctx->dsi_vm);\n#endif\n\n\treturn true;\n}\n\nstatic bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n\t\tvoid *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\tunsigned long pck_max;\n\n\tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n\tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n\n\t \n\n\tif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\n\t\tpck_max = ctx->req_pck_max + 10000000;\n\telse\n\t\tpck_max = ctx->req_pck_max;\n\n\treturn dispc_div_calc(ctx->dsi->dss->dispc, dispc,\n\t\t\t      ctx->req_pck_min, pck_max,\n\t\t\t      dsi_vm_calc_dispc_cb, ctx);\n}\n\nstatic bool dsi_vm_calc_pll_cb(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco, void *data)\n{\n\tstruct dsi_clk_calc_ctx *ctx = data;\n\tstruct dsi_data *dsi = ctx->dsi;\n\n\tctx->dsi_cinfo.n = n;\n\tctx->dsi_cinfo.m = m;\n\tctx->dsi_cinfo.fint = fint;\n\tctx->dsi_cinfo.clkdco = clkdco;\n\n\treturn dss_pll_hsdiv_calc_a(ctx->pll, clkdco, ctx->req_pck_min,\n\t\t\tdsi->data->max_fck_freq,\n\t\t\tdsi_vm_calc_hsdiv_cb, ctx);\n}\n\nstatic bool dsi_vm_calc(struct dsi_data *dsi,\n\t\tconst struct omap_dss_dsi_config *cfg,\n\t\tstruct dsi_clk_calc_ctx *ctx)\n{\n\tconst struct videomode *vm = cfg->vm;\n\tunsigned long clkin;\n\tunsigned long pll_min;\n\tunsigned long pll_max;\n\tint ndl = dsi->num_lanes_used - 1;\n\tint bitspp = mipi_dsi_pixel_format_to_bpp(cfg->pixel_format);\n\tunsigned long byteclk_min;\n\n\tclkin = clk_get_rate(dsi->pll.clkin);\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->dsi = dsi;\n\tctx->pll = &dsi->pll;\n\tctx->config = cfg;\n\n\t \n\tctx->req_pck_min = vm->pixelclock - 1000;\n\tctx->req_pck_nom = vm->pixelclock;\n\tctx->req_pck_max = vm->pixelclock + 1000;\n\n\tbyteclk_min = div64_u64((u64)ctx->req_pck_min * bitspp, ndl * 8);\n\tpll_min = max(cfg->hs_clk_min * 4, byteclk_min * 4 * 4);\n\n\tif (cfg->trans_mode == OMAP_DSS_DSI_BURST_MODE) {\n\t\tpll_max = cfg->hs_clk_max * 4;\n\t} else {\n\t\tunsigned long byteclk_max;\n\t\tbyteclk_max = div64_u64((u64)ctx->req_pck_max * bitspp,\n\t\t\t\tndl * 8);\n\n\t\tpll_max = byteclk_max * 4 * 4;\n\t}\n\n\treturn dss_pll_calc_a(ctx->pll, clkin,\n\t\t\tpll_min, pll_max,\n\t\t\tdsi_vm_calc_pll_cb, ctx);\n}\n\nstatic bool dsi_is_video_mode(struct omap_dss_device *dssdev)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\n\treturn dsi->mode == OMAP_DSS_DSI_VIDEO_MODE;\n}\n\nstatic int __dsi_calc_config(struct dsi_data *dsi,\n\t\tconst struct drm_display_mode *mode,\n\t\tstruct dsi_clk_calc_ctx *ctx)\n{\n\tstruct omap_dss_dsi_config cfg = dsi->config;\n\tstruct videomode vm;\n\tbool ok;\n\tint r;\n\n\tdrm_display_mode_to_videomode(mode, &vm);\n\n\tcfg.vm = &vm;\n\tcfg.mode = dsi->mode;\n\tcfg.pixel_format = dsi->pix_fmt;\n\n\tif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE)\n\t\tok = dsi_vm_calc(dsi, &cfg, ctx);\n\telse\n\t\tok = dsi_cm_calc(dsi, &cfg, ctx);\n\n\tif (!ok)\n\t\treturn -EINVAL;\n\n\tdsi_pll_calc_dsi_fck(dsi, &ctx->dsi_cinfo);\n\n\tr = dsi_lp_clock_calc(ctx->dsi_cinfo.clkout[HSDIV_DSI],\n\t\tcfg.lp_clk_min, cfg.lp_clk_max, &ctx->lp_cinfo);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic int dsi_set_config(struct omap_dss_device *dssdev,\n\t\tconst struct drm_display_mode *mode)\n{\n\tstruct dsi_data *dsi = to_dsi_data(dssdev);\n\tstruct dsi_clk_calc_ctx ctx;\n\tint r;\n\n\tmutex_lock(&dsi->lock);\n\n\tr = __dsi_calc_config(dsi, mode, &ctx);\n\tif (r) {\n\t\tDSSERR(\"failed to find suitable DSI clock settings\\n\");\n\t\tgoto err;\n\t}\n\n\tdsi->user_lp_cinfo = ctx.lp_cinfo;\n\tdsi->user_dsi_cinfo = ctx.dsi_cinfo;\n\tdsi->user_dispc_cinfo = ctx.dispc_cinfo;\n\n\tdsi->vm = ctx.vm;\n\n\t \n\tdsi->vm.flags &= ~DISPLAY_FLAGS_INTERLACED;\n\tdsi->vm.flags &= ~DISPLAY_FLAGS_HSYNC_LOW;\n\tdsi->vm.flags |= DISPLAY_FLAGS_HSYNC_HIGH;\n\tdsi->vm.flags &= ~DISPLAY_FLAGS_VSYNC_LOW;\n\tdsi->vm.flags |= DISPLAY_FLAGS_VSYNC_HIGH;\n\t \n\tdsi->vm.flags &= ~DISPLAY_FLAGS_PIXDATA_NEGEDGE;\n\tdsi->vm.flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;\n\tdsi->vm.flags &= ~DISPLAY_FLAGS_DE_LOW;\n\tdsi->vm.flags |= DISPLAY_FLAGS_DE_HIGH;\n\tdsi->vm.flags &= ~DISPLAY_FLAGS_SYNC_POSEDGE;\n\tdsi->vm.flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;\n\n\tdss_mgr_set_timings(&dsi->output, &dsi->vm);\n\n\tdsi->vm_timings = ctx.dsi_vm;\n\n\tmutex_unlock(&dsi->lock);\n\n\treturn 0;\nerr:\n\tmutex_unlock(&dsi->lock);\n\n\treturn r;\n}\n\n \nstatic enum omap_channel dsi_get_dispc_channel(struct dsi_data *dsi)\n{\n\tswitch (dsi->data->model) {\n\tcase DSI_MODEL_OMAP3:\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tcase DSI_MODEL_OMAP4:\n\t\tswitch (dsi->module_id) {\n\t\tcase 0:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\tcase 1:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\t\tdefault:\n\t\t\tDSSWARN(\"unsupported module id\\n\");\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\t}\n\n\tcase DSI_MODEL_OMAP5:\n\t\tswitch (dsi->module_id) {\n\t\tcase 0:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\tcase 1:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\t\tdefault:\n\t\t\tDSSWARN(\"unsupported module id\\n\");\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\t}\n\n\tdefault:\n\t\tDSSWARN(\"unsupported DSS version\\n\");\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t}\n}\n\nstatic ssize_t _omap_dsi_host_transfer(struct dsi_data *dsi, int vc,\n\t\t\t\t       const struct mipi_dsi_msg *msg)\n{\n\tstruct omap_dss_device *dssdev = &dsi->output;\n\tint r;\n\n\tdsi_vc_enable_hs(dssdev, vc, !(msg->flags & MIPI_DSI_MSG_USE_LPM));\n\n\tswitch (msg->type) {\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\n\tcase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\n\tcase MIPI_DSI_GENERIC_LONG_WRITE:\n\tcase MIPI_DSI_DCS_SHORT_WRITE:\n\tcase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\n\tcase MIPI_DSI_DCS_LONG_WRITE:\n\tcase MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE:\n\tcase MIPI_DSI_NULL_PACKET:\n\t\tr = dsi_vc_write_common(dssdev, vc, msg);\n\t\tbreak;\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\n\tcase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\n\t\tr = dsi_vc_generic_read(dssdev, vc, msg);\n\t\tbreak;\n\tcase MIPI_DSI_DCS_READ:\n\t\tr = dsi_vc_dcs_read(dssdev, vc, msg);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (r < 0)\n\t\treturn r;\n\n\tif (msg->type == MIPI_DSI_DCS_SHORT_WRITE ||\n\t    msg->type == MIPI_DSI_DCS_SHORT_WRITE_PARAM) {\n\t\tu8 cmd = ((u8 *)msg->tx_buf)[0];\n\n\t\tif (cmd == MIPI_DCS_SET_TEAR_OFF)\n\t\t\tdsi_enable_te(dsi, false);\n\t\telse if (cmd == MIPI_DCS_SET_TEAR_ON)\n\t\t\tdsi_enable_te(dsi, true);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t omap_dsi_host_transfer(struct mipi_dsi_host *host,\n\t\t\t\t      const struct mipi_dsi_msg *msg)\n{\n\tstruct dsi_data *dsi = host_to_omap(host);\n\tint r;\n\tint vc = VC_CMD;\n\n\tdsi_bus_lock(dsi);\n\n\tif (!dsi->iface_enabled) {\n\t\tdsi_enable(dsi);\n\t\tschedule_delayed_work(&dsi->dsi_disable_work, msecs_to_jiffies(2000));\n\t}\n\n\tr = _omap_dsi_host_transfer(dsi, vc, msg);\n\n\tdsi_bus_unlock(dsi);\n\n\treturn r;\n}\n\nstatic int dsi_get_clocks(struct dsi_data *dsi)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(dsi->dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get fck\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tdsi->dss_clk = clk;\n\n\treturn 0;\n}\n\nstatic const struct omapdss_dsi_ops dsi_ops = {\n\t.update = dsi_update_all,\n\t.is_video_mode = dsi_is_video_mode,\n};\n\nstatic irqreturn_t omap_dsi_te_irq_handler(int irq, void *dev_id)\n{\n\tstruct dsi_data *dsi = (struct dsi_data *)dev_id;\n\tint old;\n\n\told = atomic_cmpxchg(&dsi->do_ext_te_update, 1, 0);\n\tif (old) {\n\t\tcancel_delayed_work(&dsi->te_timeout_work);\n\t\t_dsi_update(dsi);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void omap_dsi_te_timeout_work_callback(struct work_struct *work)\n{\n\tstruct dsi_data *dsi =\n\t\tcontainer_of(work, struct dsi_data, te_timeout_work.work);\n\tint old;\n\n\told = atomic_cmpxchg(&dsi->do_ext_te_update, 1, 0);\n\tif (old) {\n\t\tdev_err(dsi->dev, \"TE not received for 250ms!\\n\");\n\t\t_dsi_update(dsi);\n\t}\n}\n\nstatic int omap_dsi_register_te_irq(struct dsi_data *dsi,\n\t\t\t\t    struct mipi_dsi_device *client)\n{\n\tint err;\n\tint te_irq;\n\n\tdsi->te_gpio = gpiod_get(&client->dev, \"te-gpios\", GPIOD_IN);\n\tif (IS_ERR(dsi->te_gpio)) {\n\t\terr = PTR_ERR(dsi->te_gpio);\n\n\t\tif (err == -ENOENT) {\n\t\t\tdsi->te_gpio = NULL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(dsi->dev, \"Could not get TE gpio: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tte_irq = gpiod_to_irq(dsi->te_gpio);\n\tif (te_irq < 0) {\n\t\tgpiod_put(dsi->te_gpio);\n\t\tdsi->te_gpio = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tdsi->te_irq = te_irq;\n\n\tirq_set_status_flags(te_irq, IRQ_NOAUTOEN);\n\n\terr = request_threaded_irq(te_irq, NULL, omap_dsi_te_irq_handler,\n\t\t\t\t   IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t   \"TE\", dsi);\n\tif (err) {\n\t\tdev_err(dsi->dev, \"request irq failed with %d\\n\", err);\n\t\tgpiod_put(dsi->te_gpio);\n\t\tdsi->te_gpio = NULL;\n\t\treturn err;\n\t}\n\n\tINIT_DEFERRABLE_WORK(&dsi->te_timeout_work,\n\t\t\t     omap_dsi_te_timeout_work_callback);\n\n\tdev_dbg(dsi->dev, \"Using GPIO TE\\n\");\n\n\treturn 0;\n}\n\nstatic void omap_dsi_unregister_te_irq(struct dsi_data *dsi)\n{\n\tif (dsi->te_gpio) {\n\t\tfree_irq(dsi->te_irq, dsi);\n\t\tcancel_delayed_work(&dsi->te_timeout_work);\n\t\tgpiod_put(dsi->te_gpio);\n\t\tdsi->te_gpio = NULL;\n\t}\n}\n\nstatic int omap_dsi_host_attach(struct mipi_dsi_host *host,\n\t\t\t\tstruct mipi_dsi_device *client)\n{\n\tstruct dsi_data *dsi = host_to_omap(host);\n\tint r;\n\n\tif (dsi->dsidev) {\n\t\tDSSERR(\"dsi client already attached\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (mipi_dsi_pixel_format_to_bpp(client->format) < 0) {\n\t\tDSSERR(\"invalid pixel format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tatomic_set(&dsi->do_ext_te_update, 0);\n\n\tif (client->mode_flags & MIPI_DSI_MODE_VIDEO) {\n\t\tdsi->mode = OMAP_DSS_DSI_VIDEO_MODE;\n\t} else {\n\t\tr = omap_dsi_register_te_irq(dsi, client);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tdsi->mode = OMAP_DSS_DSI_CMD_MODE;\n\t}\n\n\tdsi->dsidev = client;\n\tdsi->pix_fmt = client->format;\n\n\tdsi->config.hs_clk_min = 150000000; \n\tdsi->config.hs_clk_max = client->hs_rate;\n\tdsi->config.lp_clk_min = 7000000; \n\tdsi->config.lp_clk_max = client->lp_rate;\n\n\tif (client->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\n\t\tdsi->config.trans_mode = OMAP_DSS_DSI_BURST_MODE;\n\telse if (client->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\n\t\tdsi->config.trans_mode = OMAP_DSS_DSI_PULSE_MODE;\n\telse\n\t\tdsi->config.trans_mode = OMAP_DSS_DSI_EVENT_MODE;\n\n\treturn 0;\n}\n\nstatic int omap_dsi_host_detach(struct mipi_dsi_host *host,\n\t\t\t\tstruct mipi_dsi_device *client)\n{\n\tstruct dsi_data *dsi = host_to_omap(host);\n\n\tif (WARN_ON(dsi->dsidev != client))\n\t\treturn -EINVAL;\n\n\tcancel_delayed_work_sync(&dsi->dsi_disable_work);\n\n\tdsi_bus_lock(dsi);\n\n\tif (dsi->iface_enabled)\n\t\tdsi_disable(dsi);\n\n\tdsi_bus_unlock(dsi);\n\n\tomap_dsi_unregister_te_irq(dsi);\n\tdsi->dsidev = NULL;\n\treturn 0;\n}\n\nstatic const struct mipi_dsi_host_ops omap_dsi_host_ops = {\n\t.attach = omap_dsi_host_attach,\n\t.detach = omap_dsi_host_detach,\n\t.transfer = omap_dsi_host_transfer,\n};\n\n \n\nstatic const struct dss_pll_ops dsi_pll_ops = {\n\t.enable = dsi_pll_enable,\n\t.disable = dsi_pll_disable,\n\t.set_config = dss_pll_write_config_type_a,\n};\n\nstatic const struct dss_pll_hw dss_omap3_dsi_pll_hw = {\n\t.type = DSS_PLL_TYPE_A,\n\n\t.n_max = (1 << 7) - 1,\n\t.m_max = (1 << 11) - 1,\n\t.mX_max = (1 << 4) - 1,\n\t.fint_min = 750000,\n\t.fint_max = 2100000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 7,\n\t.n_lsb = 1,\n\t.m_msb = 18,\n\t.m_lsb = 8,\n\n\t.mX_msb[0] = 22,\n\t.mX_lsb[0] = 19,\n\t.mX_msb[1] = 26,\n\t.mX_lsb[1] = 23,\n\n\t.has_stopmode = true,\n\t.has_freqsel = true,\n\t.has_selfreqdco = false,\n\t.has_refsel = false,\n};\n\nstatic const struct dss_pll_hw dss_omap4_dsi_pll_hw = {\n\t.type = DSS_PLL_TYPE_A,\n\n\t.n_max = (1 << 8) - 1,\n\t.m_max = (1 << 12) - 1,\n\t.mX_max = (1 << 5) - 1,\n\t.fint_min = 500000,\n\t.fint_max = 2500000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 25,\n\t.mX_lsb[0] = 21,\n\t.mX_msb[1] = 30,\n\t.mX_lsb[1] = 26,\n\n\t.has_stopmode = true,\n\t.has_freqsel = false,\n\t.has_selfreqdco = false,\n\t.has_refsel = false,\n};\n\nstatic const struct dss_pll_hw dss_omap5_dsi_pll_hw = {\n\t.type = DSS_PLL_TYPE_A,\n\n\t.n_max = (1 << 8) - 1,\n\t.m_max = (1 << 12) - 1,\n\t.mX_max = (1 << 5) - 1,\n\t.fint_min = 150000,\n\t.fint_max = 52000000,\n\t.clkdco_low = 1000000000,\n\t.clkdco_max = 1800000000,\n\n\t.n_msb = 8,\n\t.n_lsb = 1,\n\t.m_msb = 20,\n\t.m_lsb = 9,\n\n\t.mX_msb[0] = 25,\n\t.mX_lsb[0] = 21,\n\t.mX_msb[1] = 30,\n\t.mX_lsb[1] = 26,\n\n\t.has_stopmode = true,\n\t.has_freqsel = false,\n\t.has_selfreqdco = true,\n\t.has_refsel = true,\n};\n\nstatic int dsi_init_pll_data(struct dss_device *dss, struct dsi_data *dsi)\n{\n\tstruct dss_pll *pll = &dsi->pll;\n\tstruct clk *clk;\n\tint r;\n\n\tclk = devm_clk_get(dsi->dev, \"sys_clk\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get sys_clk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tpll->name = dsi->module_id == 0 ? \"dsi0\" : \"dsi1\";\n\tpll->id = dsi->module_id == 0 ? DSS_PLL_DSI1 : DSS_PLL_DSI2;\n\tpll->clkin = clk;\n\tpll->base = dsi->pll_base;\n\tpll->hw = dsi->data->pll_hw;\n\tpll->ops = &dsi_pll_ops;\n\n\tr = dss_pll_register(dss, pll);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \n\nstatic int dsi_bind(struct device *dev, struct device *master, void *data)\n{\n\tstruct dss_device *dss = dss_get_device(master);\n\tstruct dsi_data *dsi = dev_get_drvdata(dev);\n\tchar name[10];\n\tu32 rev;\n\tint r;\n\n\tdsi->dss = dss;\n\n\tdsi_init_pll_data(dss, dsi);\n\n\tr = dsi_runtime_get(dsi);\n\tif (r)\n\t\treturn r;\n\n\trev = dsi_read_reg(dsi, DSI_REVISION);\n\tdev_dbg(dev, \"OMAP DSI rev %d.%d\\n\",\n\t       FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\n\n\tdsi->line_buffer_size = dsi_get_line_buf_size(dsi);\n\n\tdsi_runtime_put(dsi);\n\n\tsnprintf(name, sizeof(name), \"dsi%u_regs\", dsi->module_id + 1);\n\tdsi->debugfs.regs = dss_debugfs_create_file(dss, name,\n\t\t\t\t\t\t    dsi_dump_dsi_regs, dsi);\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\n\tsnprintf(name, sizeof(name), \"dsi%u_irqs\", dsi->module_id + 1);\n\tdsi->debugfs.irqs = dss_debugfs_create_file(dss, name,\n\t\t\t\t\t\t    dsi_dump_dsi_irqs, dsi);\n#endif\n\tsnprintf(name, sizeof(name), \"dsi%u_clks\", dsi->module_id + 1);\n\tdsi->debugfs.clks = dss_debugfs_create_file(dss, name,\n\t\t\t\t\t\t    dsi_dump_dsi_clocks, dsi);\n\n\treturn 0;\n}\n\nstatic void dsi_unbind(struct device *dev, struct device *master, void *data)\n{\n\tstruct dsi_data *dsi = dev_get_drvdata(dev);\n\n\tdss_debugfs_remove_file(dsi->debugfs.clks);\n\tdss_debugfs_remove_file(dsi->debugfs.irqs);\n\tdss_debugfs_remove_file(dsi->debugfs.regs);\n\n\tWARN_ON(dsi->scp_clk_refcount > 0);\n\n\tdss_pll_unregister(&dsi->pll);\n}\n\nstatic const struct component_ops dsi_component_ops = {\n\t.bind\t= dsi_bind,\n\t.unbind\t= dsi_unbind,\n};\n\n \n\nstatic int dsi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct dsi_data *dsi = drm_bridge_to_dsi(bridge);\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\treturn drm_bridge_attach(bridge->encoder, dsi->output.next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic enum drm_mode_status\ndsi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t      const struct drm_display_info *info,\n\t\t      const struct drm_display_mode *mode)\n{\n\tstruct dsi_data *dsi = drm_bridge_to_dsi(bridge);\n\tstruct dsi_clk_calc_ctx ctx;\n\tint r;\n\n\tmutex_lock(&dsi->lock);\n\tr = __dsi_calc_config(dsi, mode, &ctx);\n\tmutex_unlock(&dsi->lock);\n\n\treturn r ? MODE_CLOCK_RANGE : MODE_OK;\n}\n\nstatic void dsi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct dsi_data *dsi = drm_bridge_to_dsi(bridge);\n\n\tdsi_set_config(&dsi->output, adjusted_mode);\n}\n\nstatic void dsi_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct dsi_data *dsi = drm_bridge_to_dsi(bridge);\n\tstruct omap_dss_device *dssdev = &dsi->output;\n\n\tcancel_delayed_work_sync(&dsi->dsi_disable_work);\n\n\tdsi_bus_lock(dsi);\n\n\tif (!dsi->iface_enabled)\n\t\tdsi_enable(dsi);\n\n\tdsi_enable_video_output(dssdev, VC_VIDEO);\n\n\tdsi->video_enabled = true;\n\n\tdsi_bus_unlock(dsi);\n}\n\nstatic void dsi_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct dsi_data *dsi = drm_bridge_to_dsi(bridge);\n\tstruct omap_dss_device *dssdev = &dsi->output;\n\n\tcancel_delayed_work_sync(&dsi->dsi_disable_work);\n\n\tdsi_bus_lock(dsi);\n\n\tdsi->video_enabled = false;\n\n\tdsi_disable_video_output(dssdev, VC_VIDEO);\n\n\tdsi_disable(dsi);\n\n\tdsi_bus_unlock(dsi);\n}\n\nstatic const struct drm_bridge_funcs dsi_bridge_funcs = {\n\t.attach = dsi_bridge_attach,\n\t.mode_valid = dsi_bridge_mode_valid,\n\t.mode_set = dsi_bridge_mode_set,\n\t.enable = dsi_bridge_enable,\n\t.disable = dsi_bridge_disable,\n};\n\nstatic void dsi_bridge_init(struct dsi_data *dsi)\n{\n\tdsi->bridge.funcs = &dsi_bridge_funcs;\n\tdsi->bridge.of_node = dsi->host.dev->of_node;\n\tdsi->bridge.type = DRM_MODE_CONNECTOR_DSI;\n\n\tdrm_bridge_add(&dsi->bridge);\n}\n\nstatic void dsi_bridge_cleanup(struct dsi_data *dsi)\n{\n\tdrm_bridge_remove(&dsi->bridge);\n}\n\n \n\nstatic int dsi_init_output(struct dsi_data *dsi)\n{\n\tstruct omap_dss_device *out = &dsi->output;\n\tint r;\n\n\tdsi_bridge_init(dsi);\n\n\tout->dev = dsi->dev;\n\tout->id = dsi->module_id == 0 ?\n\t\t\tOMAP_DSS_OUTPUT_DSI1 : OMAP_DSS_OUTPUT_DSI2;\n\n\tout->type = OMAP_DISPLAY_TYPE_DSI;\n\tout->name = dsi->module_id == 0 ? \"dsi.0\" : \"dsi.1\";\n\tout->dispc_channel = dsi_get_dispc_channel(dsi);\n\tout->dsi_ops = &dsi_ops;\n\tout->of_port = 0;\n\tout->bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE\n\t\t       | DRM_BUS_FLAG_DE_HIGH\n\t\t       | DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE;\n\n\tr = omapdss_device_init_output(out, &dsi->bridge);\n\tif (r < 0) {\n\t\tdsi_bridge_cleanup(dsi);\n\t\treturn r;\n\t}\n\n\tomapdss_device_register(out);\n\n\treturn 0;\n}\n\nstatic void dsi_uninit_output(struct dsi_data *dsi)\n{\n\tstruct omap_dss_device *out = &dsi->output;\n\n\tomapdss_device_unregister(out);\n\tomapdss_device_cleanup_output(out);\n\tdsi_bridge_cleanup(dsi);\n}\n\nstatic int dsi_probe_of(struct dsi_data *dsi)\n{\n\tstruct device_node *node = dsi->dev->of_node;\n\tstruct property *prop;\n\tu32 lane_arr[10];\n\tint len, num_pins;\n\tint r;\n\tstruct device_node *ep;\n\n\tep = of_graph_get_endpoint_by_regs(node, 0, 0);\n\tif (!ep)\n\t\treturn 0;\n\n\tprop = of_find_property(ep, \"lanes\", &len);\n\tif (prop == NULL) {\n\t\tdev_err(dsi->dev, \"failed to find lane data\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tnum_pins = len / sizeof(u32);\n\n\tif (num_pins < 4 || num_pins % 2 != 0 ||\n\t\tnum_pins > dsi->num_lanes_supported * 2) {\n\t\tdev_err(dsi->dev, \"bad number of lanes\\n\");\n\t\tr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tr = of_property_read_u32_array(ep, \"lanes\", lane_arr, num_pins);\n\tif (r) {\n\t\tdev_err(dsi->dev, \"failed to read lane data\\n\");\n\t\tgoto err;\n\t}\n\n\tr = dsi_configure_pins(dsi, num_pins, lane_arr);\n\tif (r) {\n\t\tdev_err(dsi->dev, \"failed to configure pins\");\n\t\tgoto err;\n\t}\n\n\tof_node_put(ep);\n\n\treturn 0;\n\nerr:\n\tof_node_put(ep);\n\treturn r;\n}\n\nstatic const struct dsi_of_data dsi_of_data_omap34xx = {\n\t.model = DSI_MODEL_OMAP3,\n\t.pll_hw = &dss_omap3_dsi_pll_hw,\n\t.modules = (const struct dsi_module_id_data[]) {\n\t\t{ .address = 0x4804fc00, .id = 0, },\n\t\t{ },\n\t},\n\t.max_fck_freq = 173000000,\n\t.max_pll_lpdiv = (1 << 13) - 1,\n\t.quirks = DSI_QUIRK_REVERSE_TXCLKESC,\n};\n\nstatic const struct dsi_of_data dsi_of_data_omap36xx = {\n\t.model = DSI_MODEL_OMAP3,\n\t.pll_hw = &dss_omap3_dsi_pll_hw,\n\t.modules = (const struct dsi_module_id_data[]) {\n\t\t{ .address = 0x4804fc00, .id = 0, },\n\t\t{ },\n\t},\n\t.max_fck_freq = 173000000,\n\t.max_pll_lpdiv = (1 << 13) - 1,\n\t.quirks = DSI_QUIRK_PLL_PWR_BUG,\n};\n\nstatic const struct dsi_of_data dsi_of_data_omap4 = {\n\t.model = DSI_MODEL_OMAP4,\n\t.pll_hw = &dss_omap4_dsi_pll_hw,\n\t.modules = (const struct dsi_module_id_data[]) {\n\t\t{ .address = 0x58004000, .id = 0, },\n\t\t{ .address = 0x58005000, .id = 1, },\n\t\t{ },\n\t},\n\t.max_fck_freq = 170000000,\n\t.max_pll_lpdiv = (1 << 13) - 1,\n\t.quirks = DSI_QUIRK_DCS_CMD_CONFIG_VC | DSI_QUIRK_VC_OCP_WIDTH\n\t\t| DSI_QUIRK_GNQ,\n};\n\nstatic const struct dsi_of_data dsi_of_data_omap5 = {\n\t.model = DSI_MODEL_OMAP5,\n\t.pll_hw = &dss_omap5_dsi_pll_hw,\n\t.modules = (const struct dsi_module_id_data[]) {\n\t\t{ .address = 0x58004000, .id = 0, },\n\t\t{ .address = 0x58009000, .id = 1, },\n\t\t{ },\n\t},\n\t.max_fck_freq = 209250000,\n\t.max_pll_lpdiv = (1 << 13) - 1,\n\t.quirks = DSI_QUIRK_DCS_CMD_CONFIG_VC | DSI_QUIRK_VC_OCP_WIDTH\n\t\t| DSI_QUIRK_GNQ | DSI_QUIRK_PHY_DCC,\n};\n\nstatic const struct of_device_id dsi_of_match[] = {\n\t{ .compatible = \"ti,omap3-dsi\", .data = &dsi_of_data_omap36xx, },\n\t{ .compatible = \"ti,omap4-dsi\", .data = &dsi_of_data_omap4, },\n\t{ .compatible = \"ti,omap5-dsi\", .data = &dsi_of_data_omap5, },\n\t{},\n};\n\nstatic const struct soc_device_attribute dsi_soc_devices[] = {\n\t{ .machine = \"OMAP3[45]*\",\t.data = &dsi_of_data_omap34xx },\n\t{ .machine = \"AM35*\",\t\t.data = &dsi_of_data_omap34xx },\n\t{   }\n};\n\nstatic void omap_dsi_disable_work_callback(struct work_struct *work)\n{\n\tstruct dsi_data *dsi = container_of(work, struct dsi_data, dsi_disable_work.work);\n\n\tdsi_bus_lock(dsi);\n\n\tif (dsi->iface_enabled && !dsi->video_enabled)\n\t\tdsi_disable(dsi);\n\n\tdsi_bus_unlock(dsi);\n}\n\nstatic int dsi_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *soc;\n\tconst struct dsi_module_id_data *d;\n\tstruct device *dev = &pdev->dev;\n\tstruct dsi_data *dsi;\n\tstruct resource *dsi_mem;\n\tunsigned int i;\n\tint r;\n\n\tdsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\n\tif (!dsi)\n\t\treturn -ENOMEM;\n\n\tdsi->dev = dev;\n\tdev_set_drvdata(dev, dsi);\n\n\tspin_lock_init(&dsi->irq_lock);\n\tspin_lock_init(&dsi->errors_lock);\n\tdsi->errors = 0;\n\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\n\tspin_lock_init(&dsi->irq_stats_lock);\n\tdsi->irq_stats.last_reset = jiffies;\n#endif\n\n\tmutex_init(&dsi->lock);\n\tsema_init(&dsi->bus_lock, 1);\n\n\tINIT_DEFERRABLE_WORK(&dsi->framedone_timeout_work,\n\t\t\t     dsi_framedone_timeout_work_callback);\n\n\tINIT_DEFERRABLE_WORK(&dsi->dsi_disable_work, omap_dsi_disable_work_callback);\n\n#ifdef DSI_CATCH_MISSING_TE\n\ttimer_setup(&dsi->te_timer, dsi_te_timeout, 0);\n#endif\n\n\tdsi_mem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"proto\");\n\tdsi->proto_base = devm_ioremap_resource(dev, dsi_mem);\n\tif (IS_ERR(dsi->proto_base))\n\t\treturn PTR_ERR(dsi->proto_base);\n\n\tdsi->phy_base = devm_platform_ioremap_resource_byname(pdev, \"phy\");\n\tif (IS_ERR(dsi->phy_base))\n\t\treturn PTR_ERR(dsi->phy_base);\n\n\tdsi->pll_base = devm_platform_ioremap_resource_byname(pdev, \"pll\");\n\tif (IS_ERR(dsi->pll_base))\n\t\treturn PTR_ERR(dsi->pll_base);\n\n\tdsi->irq = platform_get_irq(pdev, 0);\n\tif (dsi->irq < 0) {\n\t\tDSSERR(\"platform_get_irq failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tr = devm_request_irq(dev, dsi->irq, omap_dsi_irq_handler,\n\t\t\t     IRQF_SHARED, dev_name(dev), dsi);\n\tif (r < 0) {\n\t\tDSSERR(\"request_irq failed\\n\");\n\t\treturn r;\n\t}\n\n\tdsi->vdds_dsi_reg = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(dsi->vdds_dsi_reg)) {\n\t\tif (PTR_ERR(dsi->vdds_dsi_reg) != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get DSI VDD regulator\\n\");\n\t\treturn PTR_ERR(dsi->vdds_dsi_reg);\n\t}\n\n\tsoc = soc_device_match(dsi_soc_devices);\n\tif (soc)\n\t\tdsi->data = soc->data;\n\telse\n\t\tdsi->data = of_match_node(dsi_of_match, dev->of_node)->data;\n\n\td = dsi->data->modules;\n\twhile (d->address != 0 && d->address != dsi_mem->start)\n\t\td++;\n\n\tif (d->address == 0) {\n\t\tDSSERR(\"unsupported DSI module\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdsi->module_id = d->id;\n\n\tif (dsi->data->model == DSI_MODEL_OMAP4 ||\n\t    dsi->data->model == DSI_MODEL_OMAP5) {\n\t\tstruct device_node *np;\n\n\t\t \n\t\tnp = of_find_node_by_name(NULL,\n\t\t\tdsi->data->model == DSI_MODEL_OMAP4 ?\n\t\t\t\"omap4_padconf_global\" : \"omap5_padconf_global\");\n\t\tif (!np)\n\t\t\treturn -ENODEV;\n\n\t\tdsi->syscon = syscon_node_to_regmap(np);\n\t\tof_node_put(np);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++)\n\t\tdsi->vc[i].source = DSI_VC_SOURCE_L4;\n\n\tr = dsi_get_clocks(dsi);\n\tif (r)\n\t\treturn r;\n\n\tpm_runtime_enable(dev);\n\n\t \n\tif (dsi->data->quirks & DSI_QUIRK_GNQ) {\n\t\tdsi_runtime_get(dsi);\n\t\t \n\t\tdsi->num_lanes_supported = 1 + REG_GET(dsi, DSI_GNQ, 11, 9);\n\t\tdsi_runtime_put(dsi);\n\t} else {\n\t\tdsi->num_lanes_supported = 3;\n\t}\n\n\tdsi->host.ops = &omap_dsi_host_ops;\n\tdsi->host.dev = &pdev->dev;\n\n\tr = dsi_probe_of(dsi);\n\tif (r) {\n\t\tDSSERR(\"Invalid DSI DT data\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\tr = mipi_dsi_host_register(&dsi->host);\n\tif (r < 0) {\n\t\tdev_err(&pdev->dev, \"failed to register DSI host: %d\\n\", r);\n\t\tgoto err_pm_disable;\n\t}\n\n\tr = dsi_init_output(dsi);\n\tif (r)\n\t\tgoto err_dsi_host_unregister;\n\n\tr = component_add(&pdev->dev, &dsi_component_ops);\n\tif (r)\n\t\tgoto err_uninit_output;\n\n\treturn 0;\n\nerr_uninit_output:\n\tdsi_uninit_output(dsi);\nerr_dsi_host_unregister:\n\tmipi_dsi_host_unregister(&dsi->host);\nerr_pm_disable:\n\tpm_runtime_disable(dev);\n\treturn r;\n}\n\nstatic void dsi_remove(struct platform_device *pdev)\n{\n\tstruct dsi_data *dsi = platform_get_drvdata(pdev);\n\n\tcomponent_del(&pdev->dev, &dsi_component_ops);\n\n\tdsi_uninit_output(dsi);\n\n\tmipi_dsi_host_unregister(&dsi->host);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (dsi->vdds_dsi_reg != NULL && dsi->vdds_dsi_enabled) {\n\t\tregulator_disable(dsi->vdds_dsi_reg);\n\t\tdsi->vdds_dsi_enabled = false;\n\t}\n}\n\nstatic __maybe_unused int dsi_runtime_suspend(struct device *dev)\n{\n\tstruct dsi_data *dsi = dev_get_drvdata(dev);\n\n\tdsi->is_enabled = false;\n\t \n\tsmp_wmb();\n\t \n\tsynchronize_irq(dsi->irq);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int dsi_runtime_resume(struct device *dev)\n{\n\tstruct dsi_data *dsi = dev_get_drvdata(dev);\n\n\tdsi->is_enabled = true;\n\t \n\tsmp_wmb();\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dsi_pm_ops = {\n\tSET_RUNTIME_PM_OPS(dsi_runtime_suspend, dsi_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n};\n\nstruct platform_driver omap_dsihw_driver = {\n\t.probe\t\t= dsi_probe,\n\t.remove_new\t= dsi_remove,\n\t.driver         = {\n\t\t.name   = \"omapdss_dsi\",\n\t\t.pm\t= &dsi_pm_ops,\n\t\t.of_match_table = dsi_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}