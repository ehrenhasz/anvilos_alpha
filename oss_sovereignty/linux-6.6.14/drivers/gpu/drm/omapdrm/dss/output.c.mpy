{
  "module_name": "output.c",
  "hash_id": "13f26117d37789802f03f9a575d4dc643fd21cf2102fb2b015e28755c92d13f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/output.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_panel.h>\n\n#include \"dss.h\"\n#include \"omapdss.h\"\n\nint omapdss_device_init_output(struct omap_dss_device *out,\n\t\t\t       struct drm_bridge *local_bridge)\n{\n\tstruct device_node *remote_node;\n\tint ret;\n\n\tremote_node = of_graph_get_remote_node(out->dev->of_node,\n\t\t\t\t\t       out->of_port, 0);\n\tif (!remote_node) {\n\t\tdev_dbg(out->dev, \"failed to find video sink\\n\");\n\t\treturn 0;\n\t}\n\n\tout->bridge = of_drm_find_bridge(remote_node);\n\tout->panel = of_drm_find_panel(remote_node);\n\tif (IS_ERR(out->panel))\n\t\tout->panel = NULL;\n\n\tof_node_put(remote_node);\n\n\tif (out->panel) {\n\t\tstruct drm_bridge *bridge;\n\n\t\tbridge = drm_panel_bridge_add(out->panel);\n\t\tif (IS_ERR(bridge)) {\n\t\t\tdev_err(out->dev,\n\t\t\t\t\"unable to create panel bridge (%ld)\\n\",\n\t\t\t\tPTR_ERR(bridge));\n\t\t\tret = PTR_ERR(bridge);\n\t\t\tgoto error;\n\t\t}\n\n\t\tout->bridge = bridge;\n\t}\n\n\tif (local_bridge) {\n\t\tif (!out->bridge) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto error;\n\t\t}\n\n\t\tout->next_bridge = out->bridge;\n\t\tout->bridge = local_bridge;\n\t}\n\n\tif (!out->bridge) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tomapdss_device_cleanup_output(out);\n\treturn ret;\n}\n\nvoid omapdss_device_cleanup_output(struct omap_dss_device *out)\n{\n\tif (out->bridge && out->panel)\n\t\tdrm_panel_bridge_remove(out->next_bridge ?\n\t\t\t\t\tout->next_bridge : out->bridge);\n}\n\nvoid dss_mgr_set_timings(struct omap_dss_device *dssdev,\n\t\t\t const struct videomode *vm)\n{\n\tomap_crtc_dss_set_timings(dssdev->dss->mgr_ops_priv,\n\t\t\t\t\t  dssdev->dispc_channel, vm);\n}\n\nvoid dss_mgr_set_lcd_config(struct omap_dss_device *dssdev,\n\t\tconst struct dss_lcd_mgr_config *config)\n{\n\tomap_crtc_dss_set_lcd_config(dssdev->dss->mgr_ops_priv,\n\t\t\t\t\t     dssdev->dispc_channel, config);\n}\n\nint dss_mgr_enable(struct omap_dss_device *dssdev)\n{\n\treturn omap_crtc_dss_enable(dssdev->dss->mgr_ops_priv,\n\t\t\t\t\t    dssdev->dispc_channel);\n}\n\nvoid dss_mgr_disable(struct omap_dss_device *dssdev)\n{\n\tomap_crtc_dss_disable(dssdev->dss->mgr_ops_priv,\n\t\t\t\t      dssdev->dispc_channel);\n}\n\nvoid dss_mgr_start_update(struct omap_dss_device *dssdev)\n{\n\tomap_crtc_dss_start_update(dssdev->dss->mgr_ops_priv,\n\t\t\t\t\t   dssdev->dispc_channel);\n}\n\nint dss_mgr_register_framedone_handler(struct omap_dss_device *dssdev,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tstruct dss_device *dss = dssdev->dss;\n\n\treturn omap_crtc_dss_register_framedone(dss->mgr_ops_priv,\n\t\t\t\t\t\t\tdssdev->dispc_channel,\n\t\t\t\t\t\t\thandler, data);\n}\n\nvoid dss_mgr_unregister_framedone_handler(struct omap_dss_device *dssdev,\n\t\tvoid (*handler)(void *), void *data)\n{\n\tstruct dss_device *dss = dssdev->dss;\n\n\tomap_crtc_dss_unregister_framedone(dss->mgr_ops_priv,\n\t\t\t\t\t\t   dssdev->dispc_channel,\n\t\t\t\t\t\t   handler, data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}