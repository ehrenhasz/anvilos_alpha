{
  "module_name": "dpi.c",
  "hash_id": "adf3c9bed801885fd2993d9a5633c9ca5d1c2269cae20f41ebe00273d6e9f76c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/dpi.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DPI\"\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/string.h>\n#include <linux/sys_soc.h>\n\n#include <drm/drm_bridge.h>\n\n#include \"dss.h\"\n#include \"omapdss.h\"\n\nstruct dpi_data {\n\tstruct platform_device *pdev;\n\tenum dss_model dss_model;\n\tstruct dss_device *dss;\n\tunsigned int id;\n\n\tstruct regulator *vdds_dsi_reg;\n\tenum dss_clk_source clk_src;\n\tstruct dss_pll *pll;\n\n\tstruct dss_lcd_mgr_config mgr_config;\n\tunsigned long pixelclock;\n\tint data_lines;\n\n\tstruct omap_dss_device output;\n\tstruct drm_bridge bridge;\n};\n\n#define drm_bridge_to_dpi(bridge) container_of(bridge, struct dpi_data, bridge)\n\n \n\nstatic enum dss_clk_source dpi_get_clk_src_dra7xx(struct dpi_data *dpi,\n\t\t\t\t\t\t  enum omap_channel channel)\n{\n\t \n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t{\n\t\tif (dss_pll_find_by_src(dpi->dss, DSS_CLK_SRC_PLL1_1))\n\t\t\treturn DSS_CLK_SRC_PLL1_1;\n\t\tbreak;\n\t}\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t{\n\t\tif (dss_pll_find_by_src(dpi->dss, DSS_CLK_SRC_PLL1_3))\n\t\t\treturn DSS_CLK_SRC_PLL1_3;\n\t\tif (dss_pll_find_by_src(dpi->dss, DSS_CLK_SRC_PLL2_3))\n\t\t\treturn DSS_CLK_SRC_PLL2_3;\n\t\tbreak;\n\t}\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t{\n\t\tif (dss_pll_find_by_src(dpi->dss, DSS_CLK_SRC_PLL2_1))\n\t\t\treturn DSS_CLK_SRC_PLL2_1;\n\t\tif (dss_pll_find_by_src(dpi->dss, DSS_CLK_SRC_PLL1_3))\n\t\t\treturn DSS_CLK_SRC_PLL1_3;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn DSS_CLK_SRC_FCK;\n}\n\nstatic enum dss_clk_source dpi_get_clk_src(struct dpi_data *dpi)\n{\n\tenum omap_channel channel = dpi->output.dispc_channel;\n\n\t \n\tswitch (dpi->dss_model) {\n\tcase DSS_MODEL_OMAP2:\n\tcase DSS_MODEL_OMAP3:\n\t\treturn DSS_CLK_SRC_FCK;\n\n\tcase DSS_MODEL_OMAP4:\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\t\treturn DSS_CLK_SRC_PLL1_1;\n\t\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\t\treturn DSS_CLK_SRC_PLL2_1;\n\t\tdefault:\n\t\t\treturn DSS_CLK_SRC_FCK;\n\t\t}\n\n\tcase DSS_MODEL_OMAP5:\n\t\tswitch (channel) {\n\t\tcase OMAP_DSS_CHANNEL_LCD:\n\t\t\treturn DSS_CLK_SRC_PLL1_1;\n\t\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\t\treturn DSS_CLK_SRC_PLL2_1;\n\t\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tdefault:\n\t\t\treturn DSS_CLK_SRC_FCK;\n\t\t}\n\n\tcase DSS_MODEL_DRA7:\n\t\treturn dpi_get_clk_src_dra7xx(dpi, channel);\n\n\tdefault:\n\t\treturn DSS_CLK_SRC_FCK;\n\t}\n}\n\nstruct dpi_clk_calc_ctx {\n\tstruct dpi_data *dpi;\n\tunsigned int clkout_idx;\n\n\t \n\n\tunsigned long pck_min, pck_max;\n\n\t \n\n\tstruct dss_pll_clock_info pll_cinfo;\n\tunsigned long fck;\n\tstruct dispc_clock_info dispc_cinfo;\n};\n\nstatic bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\t \n\tif (ctx->pck_min >= 100000000) {\n\t\tif (lckd > 1 && lckd % 2 != 0)\n\t\t\treturn false;\n\n\t\tif (pckd > 1 && pckd % 2 != 0)\n\t\t\treturn false;\n\t}\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\treturn true;\n}\n\n\nstatic bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n\t\tvoid *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\tctx->pll_cinfo.mX[ctx->clkout_idx] = m_dispc;\n\tctx->pll_cinfo.clkout[ctx->clkout_idx] = dispc;\n\n\treturn dispc_div_calc(ctx->dpi->dss->dispc, dispc,\n\t\t\t      ctx->pck_min, ctx->pck_max,\n\t\t\t      dpi_calc_dispc_cb, ctx);\n}\n\n\nstatic bool dpi_calc_pll_cb(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco,\n\t\tvoid *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\tctx->pll_cinfo.n = n;\n\tctx->pll_cinfo.m = m;\n\tctx->pll_cinfo.fint = fint;\n\tctx->pll_cinfo.clkdco = clkdco;\n\n\treturn dss_pll_hsdiv_calc_a(ctx->dpi->pll, clkdco,\n\t\tctx->pck_min, dss_get_max_fck_rate(ctx->dpi->dss),\n\t\tdpi_calc_hsdiv_cb, ctx);\n}\n\nstatic bool dpi_calc_dss_cb(unsigned long fck, void *data)\n{\n\tstruct dpi_clk_calc_ctx *ctx = data;\n\n\tctx->fck = fck;\n\n\treturn dispc_div_calc(ctx->dpi->dss->dispc, fck,\n\t\t\t      ctx->pck_min, ctx->pck_max,\n\t\t\t      dpi_calc_dispc_cb, ctx);\n}\n\nstatic bool dpi_pll_clk_calc(struct dpi_data *dpi, unsigned long pck,\n\t\tstruct dpi_clk_calc_ctx *ctx)\n{\n\tunsigned long clkin;\n\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->dpi = dpi;\n\tctx->clkout_idx = dss_pll_get_clkout_idx_for_src(dpi->clk_src);\n\n\tclkin = clk_get_rate(dpi->pll->clkin);\n\n\tif (dpi->pll->hw->type == DSS_PLL_TYPE_A) {\n\t\tunsigned long pll_min, pll_max;\n\n\t\tctx->pck_min = pck - 1000;\n\t\tctx->pck_max = pck + 1000;\n\n\t\tpll_min = 0;\n\t\tpll_max = 0;\n\n\t\treturn dss_pll_calc_a(ctx->dpi->pll, clkin,\n\t\t\t\tpll_min, pll_max,\n\t\t\t\tdpi_calc_pll_cb, ctx);\n\t} else {  \n\t\tdss_pll_calc_b(dpi->pll, clkin, pck, &ctx->pll_cinfo);\n\n\t\tctx->dispc_cinfo.lck_div = 1;\n\t\tctx->dispc_cinfo.pck_div = 1;\n\t\tctx->dispc_cinfo.lck = ctx->pll_cinfo.clkout[0];\n\t\tctx->dispc_cinfo.pck = ctx->dispc_cinfo.lck;\n\n\t\treturn true;\n\t}\n}\n\nstatic bool dpi_dss_clk_calc(struct dpi_data *dpi, unsigned long pck,\n\t\t\t     struct dpi_clk_calc_ctx *ctx)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 25; ++i) {\n\t\tbool ok;\n\n\t\tmemset(ctx, 0, sizeof(*ctx));\n\t\tctx->dpi = dpi;\n\t\tif (pck > 1000 * i * i * i)\n\t\t\tctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\n\t\telse\n\t\t\tctx->pck_min = 0;\n\t\tctx->pck_max = pck + 1000 * i * i * i;\n\n\t\tok = dss_div_calc(dpi->dss, pck, ctx->pck_min,\n\t\t\t\t  dpi_calc_dss_cb, ctx);\n\t\tif (ok)\n\t\t\treturn ok;\n\t}\n\n\treturn false;\n}\n\n\n\nstatic int dpi_set_pll_clk(struct dpi_data *dpi, unsigned long pck_req)\n{\n\tstruct dpi_clk_calc_ctx ctx;\n\tint r;\n\tbool ok;\n\n\tok = dpi_pll_clk_calc(dpi, pck_req, &ctx);\n\tif (!ok)\n\t\treturn -EINVAL;\n\n\tr = dss_pll_set_config(dpi->pll, &ctx.pll_cinfo);\n\tif (r)\n\t\treturn r;\n\n\tdss_select_lcd_clk_source(dpi->dss, dpi->output.dispc_channel,\n\t\t\t\t  dpi->clk_src);\n\n\tdpi->mgr_config.clock_info = ctx.dispc_cinfo;\n\n\treturn 0;\n}\n\nstatic int dpi_set_dispc_clk(struct dpi_data *dpi, unsigned long pck_req)\n{\n\tstruct dpi_clk_calc_ctx ctx;\n\tint r;\n\tbool ok;\n\n\tok = dpi_dss_clk_calc(dpi, pck_req, &ctx);\n\tif (!ok)\n\t\treturn -EINVAL;\n\n\tr = dss_set_fck_rate(dpi->dss, ctx.fck);\n\tif (r)\n\t\treturn r;\n\n\tdpi->mgr_config.clock_info = ctx.dispc_cinfo;\n\n\treturn 0;\n}\n\nstatic int dpi_set_mode(struct dpi_data *dpi)\n{\n\tint r;\n\n\tif (dpi->pll)\n\t\tr = dpi_set_pll_clk(dpi, dpi->pixelclock);\n\telse\n\t\tr = dpi_set_dispc_clk(dpi, dpi->pixelclock);\n\n\treturn r;\n}\n\nstatic void dpi_config_lcd_manager(struct dpi_data *dpi)\n{\n\tdpi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\n\n\tdpi->mgr_config.stallmode = false;\n\tdpi->mgr_config.fifohandcheck = false;\n\n\tdpi->mgr_config.video_port_width = dpi->data_lines;\n\n\tdpi->mgr_config.lcden_sig_polarity = 0;\n\n\tdss_mgr_set_lcd_config(&dpi->output, &dpi->mgr_config);\n}\n\nstatic int dpi_clock_update(struct dpi_data *dpi, unsigned long *clock)\n{\n\tint lck_div, pck_div;\n\tunsigned long fck;\n\tstruct dpi_clk_calc_ctx ctx;\n\n\tif (dpi->pll) {\n\t\tif (!dpi_pll_clk_calc(dpi, *clock, &ctx))\n\t\t\treturn -EINVAL;\n\n\t\tfck = ctx.pll_cinfo.clkout[ctx.clkout_idx];\n\t} else {\n\t\tif (!dpi_dss_clk_calc(dpi, *clock, &ctx))\n\t\t\treturn -EINVAL;\n\n\t\tfck = ctx.fck;\n\t}\n\n\tlck_div = ctx.dispc_cinfo.lck_div;\n\tpck_div = ctx.dispc_cinfo.pck_div;\n\n\t*clock = fck / lck_div / pck_div;\n\n\treturn 0;\n}\n\nstatic int dpi_verify_pll(struct dss_pll *pll)\n{\n\tint r;\n\n\t \n\n\tr = dss_pll_enable(pll);\n\tif (r)\n\t\treturn r;\n\n\tdss_pll_disable(pll);\n\n\treturn 0;\n}\n\nstatic void dpi_init_pll(struct dpi_data *dpi)\n{\n\tstruct dss_pll *pll;\n\n\tif (dpi->pll)\n\t\treturn;\n\n\tdpi->clk_src = dpi_get_clk_src(dpi);\n\n\tpll = dss_pll_find_by_src(dpi->dss, dpi->clk_src);\n\tif (!pll)\n\t\treturn;\n\n\tif (dpi_verify_pll(pll)) {\n\t\tDSSWARN(\"PLL not operational\\n\");\n\t\treturn;\n\t}\n\n\tdpi->pll = pll;\n}\n\n \n\nstatic int dpi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct dpi_data *dpi = drm_bridge_to_dpi(bridge);\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\tdpi_init_pll(dpi);\n\n\treturn drm_bridge_attach(bridge->encoder, dpi->output.next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic enum drm_mode_status\ndpi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t       const struct drm_display_info *info,\n\t\t       const struct drm_display_mode *mode)\n{\n\tstruct dpi_data *dpi = drm_bridge_to_dpi(bridge);\n\tunsigned long clock = mode->clock * 1000;\n\tint ret;\n\n\tif (mode->hdisplay % 8 != 0)\n\t\treturn MODE_BAD_WIDTH;\n\n\tif (mode->clock == 0)\n\t\treturn MODE_NOCLOCK;\n\n\tret = dpi_clock_update(dpi, &clock);\n\tif (ret < 0)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic bool dpi_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *adjusted_mode)\n{\n\tstruct dpi_data *dpi = drm_bridge_to_dpi(bridge);\n\tunsigned long clock = mode->clock * 1000;\n\tint ret;\n\n\tret = dpi_clock_update(dpi, &clock);\n\tif (ret < 0)\n\t\treturn false;\n\n\tadjusted_mode->clock = clock / 1000;\n\n\treturn true;\n}\n\nstatic void dpi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t const struct drm_display_mode *adjusted_mode)\n{\n\tstruct dpi_data *dpi = drm_bridge_to_dpi(bridge);\n\n\tdpi->pixelclock = adjusted_mode->clock * 1000;\n}\n\nstatic void dpi_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct dpi_data *dpi = drm_bridge_to_dpi(bridge);\n\tint r;\n\n\tif (dpi->vdds_dsi_reg) {\n\t\tr = regulator_enable(dpi->vdds_dsi_reg);\n\t\tif (r)\n\t\t\treturn;\n\t}\n\n\tr = dispc_runtime_get(dpi->dss->dispc);\n\tif (r)\n\t\tgoto err_get_dispc;\n\n\tr = dss_dpi_select_source(dpi->dss, dpi->id, dpi->output.dispc_channel);\n\tif (r)\n\t\tgoto err_src_sel;\n\n\tif (dpi->pll) {\n\t\tr = dss_pll_enable(dpi->pll);\n\t\tif (r)\n\t\t\tgoto err_pll_init;\n\t}\n\n\tr = dpi_set_mode(dpi);\n\tif (r)\n\t\tgoto err_set_mode;\n\n\tdpi_config_lcd_manager(dpi);\n\n\tmdelay(2);\n\n\tr = dss_mgr_enable(&dpi->output);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\treturn;\n\nerr_mgr_enable:\nerr_set_mode:\n\tif (dpi->pll)\n\t\tdss_pll_disable(dpi->pll);\nerr_pll_init:\nerr_src_sel:\n\tdispc_runtime_put(dpi->dss->dispc);\nerr_get_dispc:\n\tif (dpi->vdds_dsi_reg)\n\t\tregulator_disable(dpi->vdds_dsi_reg);\n}\n\nstatic void dpi_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct dpi_data *dpi = drm_bridge_to_dpi(bridge);\n\n\tdss_mgr_disable(&dpi->output);\n\n\tif (dpi->pll) {\n\t\tdss_select_lcd_clk_source(dpi->dss, dpi->output.dispc_channel,\n\t\t\t\t\t  DSS_CLK_SRC_FCK);\n\t\tdss_pll_disable(dpi->pll);\n\t}\n\n\tdispc_runtime_put(dpi->dss->dispc);\n\n\tif (dpi->vdds_dsi_reg)\n\t\tregulator_disable(dpi->vdds_dsi_reg);\n}\n\nstatic const struct drm_bridge_funcs dpi_bridge_funcs = {\n\t.attach = dpi_bridge_attach,\n\t.mode_valid = dpi_bridge_mode_valid,\n\t.mode_fixup = dpi_bridge_mode_fixup,\n\t.mode_set = dpi_bridge_mode_set,\n\t.enable = dpi_bridge_enable,\n\t.disable = dpi_bridge_disable,\n};\n\nstatic void dpi_bridge_init(struct dpi_data *dpi)\n{\n\tdpi->bridge.funcs = &dpi_bridge_funcs;\n\tdpi->bridge.of_node = dpi->pdev->dev.of_node;\n\tdpi->bridge.type = DRM_MODE_CONNECTOR_DPI;\n\n\tdrm_bridge_add(&dpi->bridge);\n}\n\nstatic void dpi_bridge_cleanup(struct dpi_data *dpi)\n{\n\tdrm_bridge_remove(&dpi->bridge);\n}\n\n \n\n \nstatic enum omap_channel dpi_get_channel(struct dpi_data *dpi)\n{\n\tswitch (dpi->dss_model) {\n\tcase DSS_MODEL_OMAP2:\n\tcase DSS_MODEL_OMAP3:\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\n\tcase DSS_MODEL_DRA7:\n\t\tswitch (dpi->id) {\n\t\tcase 2:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\t\tcase 1:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\t\tcase 0:\n\t\tdefault:\n\t\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t\t}\n\n\tcase DSS_MODEL_OMAP4:\n\t\treturn OMAP_DSS_CHANNEL_LCD2;\n\n\tcase DSS_MODEL_OMAP5:\n\t\treturn OMAP_DSS_CHANNEL_LCD3;\n\n\tdefault:\n\t\tDSSWARN(\"unsupported DSS version\\n\");\n\t\treturn OMAP_DSS_CHANNEL_LCD;\n\t}\n}\n\nstatic int dpi_init_output_port(struct dpi_data *dpi, struct device_node *port)\n{\n\tstruct omap_dss_device *out = &dpi->output;\n\tu32 port_num = 0;\n\tint r;\n\n\tdpi_bridge_init(dpi);\n\n\tof_property_read_u32(port, \"reg\", &port_num);\n\tdpi->id = port_num <= 2 ? port_num : 0;\n\n\tswitch (port_num) {\n\tcase 2:\n\t\tout->name = \"dpi.2\";\n\t\tbreak;\n\tcase 1:\n\t\tout->name = \"dpi.1\";\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tout->name = \"dpi.0\";\n\t\tbreak;\n\t}\n\n\tout->dev = &dpi->pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_DPI;\n\tout->type = OMAP_DISPLAY_TYPE_DPI;\n\tout->dispc_channel = dpi_get_channel(dpi);\n\tout->of_port = port_num;\n\n\tr = omapdss_device_init_output(out, &dpi->bridge);\n\tif (r < 0) {\n\t\tdpi_bridge_cleanup(dpi);\n\t\treturn r;\n\t}\n\n\tomapdss_device_register(out);\n\n\treturn 0;\n}\n\nstatic void dpi_uninit_output_port(struct device_node *port)\n{\n\tstruct dpi_data *dpi = port->data;\n\tstruct omap_dss_device *out = &dpi->output;\n\n\tomapdss_device_unregister(out);\n\tomapdss_device_cleanup_output(out);\n\n\tdpi_bridge_cleanup(dpi);\n}\n\n \n\nstatic const struct soc_device_attribute dpi_soc_devices[] = {\n\t{ .machine = \"OMAP3[456]*\" },\n\t{ .machine = \"[AD]M37*\" },\n\t{   }\n};\n\nstatic int dpi_init_regulator(struct dpi_data *dpi)\n{\n\tstruct regulator *vdds_dsi;\n\n\t \n\tif (!soc_device_match(dpi_soc_devices))\n\t\treturn 0;\n\n\tvdds_dsi = devm_regulator_get(&dpi->pdev->dev, \"vdds_dsi\");\n\tif (IS_ERR(vdds_dsi)) {\n\t\tif (PTR_ERR(vdds_dsi) != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDS_DSI regulator\\n\");\n\t\treturn PTR_ERR(vdds_dsi);\n\t}\n\n\tdpi->vdds_dsi_reg = vdds_dsi;\n\n\treturn 0;\n}\n\nint dpi_init_port(struct dss_device *dss, struct platform_device *pdev,\n\t\t  struct device_node *port, enum dss_model dss_model)\n{\n\tstruct dpi_data *dpi;\n\tstruct device_node *ep;\n\tu32 datalines;\n\tint r;\n\n\tdpi = devm_kzalloc(&pdev->dev, sizeof(*dpi), GFP_KERNEL);\n\tif (!dpi)\n\t\treturn -ENOMEM;\n\n\tep = of_get_next_child(port, NULL);\n\tif (!ep)\n\t\treturn 0;\n\n\tr = of_property_read_u32(ep, \"data-lines\", &datalines);\n\tof_node_put(ep);\n\tif (r) {\n\t\tDSSERR(\"failed to parse datalines\\n\");\n\t\treturn r;\n\t}\n\n\tdpi->data_lines = datalines;\n\n\tdpi->pdev = pdev;\n\tdpi->dss_model = dss_model;\n\tdpi->dss = dss;\n\tport->data = dpi;\n\n\tr = dpi_init_regulator(dpi);\n\tif (r)\n\t\treturn r;\n\n\treturn dpi_init_output_port(dpi, port);\n}\n\nvoid dpi_uninit_port(struct device_node *port)\n{\n\tstruct dpi_data *dpi = port->data;\n\n\tif (!dpi)\n\t\treturn;\n\n\tdpi_uninit_output_port(port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}