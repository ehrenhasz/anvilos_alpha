{
  "module_name": "sdi.c",
  "hash_id": "3db60ba9d8b2234421fb5b904bdf86d82244691cae7624349893d2f64fe182b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/sdi.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"SDI\"\n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/string.h>\n\n#include <drm/drm_bridge.h>\n\n#include \"dss.h\"\n#include \"omapdss.h\"\n\nstruct sdi_device {\n\tstruct platform_device *pdev;\n\tstruct dss_device *dss;\n\n\tbool update_enabled;\n\tstruct regulator *vdds_sdi_reg;\n\n\tstruct dss_lcd_mgr_config mgr_config;\n\tunsigned long pixelclock;\n\tint datapairs;\n\n\tstruct omap_dss_device output;\n\tstruct drm_bridge bridge;\n};\n\n#define drm_bridge_to_sdi(bridge) \\\n\tcontainer_of(bridge, struct sdi_device, bridge)\n\nstruct sdi_clk_calc_ctx {\n\tstruct sdi_device *sdi;\n\tunsigned long pck_min, pck_max;\n\n\tunsigned long fck;\n\tstruct dispc_clock_info dispc_cinfo;\n};\n\nstatic bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data)\n{\n\tstruct sdi_clk_calc_ctx *ctx = data;\n\n\tctx->dispc_cinfo.lck_div = lckd;\n\tctx->dispc_cinfo.pck_div = pckd;\n\tctx->dispc_cinfo.lck = lck;\n\tctx->dispc_cinfo.pck = pck;\n\n\treturn true;\n}\n\nstatic bool dpi_calc_dss_cb(unsigned long fck, void *data)\n{\n\tstruct sdi_clk_calc_ctx *ctx = data;\n\n\tctx->fck = fck;\n\n\treturn dispc_div_calc(ctx->sdi->dss->dispc, fck,\n\t\t\t      ctx->pck_min, ctx->pck_max,\n\t\t\t      dpi_calc_dispc_cb, ctx);\n}\n\nstatic int sdi_calc_clock_div(struct sdi_device *sdi, unsigned long pclk,\n\t\t\t      unsigned long *fck,\n\t\t\t      struct dispc_clock_info *dispc_cinfo)\n{\n\tint i;\n\tstruct sdi_clk_calc_ctx ctx;\n\n\t \n\n\tfor (i = 0; i < 10; ++i) {\n\t\tbool ok;\n\n\t\tmemset(&ctx, 0, sizeof(ctx));\n\n\t\tctx.sdi = sdi;\n\n\t\tif (pclk > 1000 * i * i * i)\n\t\t\tctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\n\t\telse\n\t\t\tctx.pck_min = 0;\n\t\tctx.pck_max = pclk + 1000 * i * i * i;\n\n\t\tok = dss_div_calc(sdi->dss, pclk, ctx.pck_min,\n\t\t\t\t  dpi_calc_dss_cb, &ctx);\n\t\tif (ok) {\n\t\t\t*fck = ctx.fck;\n\t\t\t*dispc_cinfo = ctx.dispc_cinfo;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void sdi_config_lcd_manager(struct sdi_device *sdi)\n{\n\tsdi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\n\n\tsdi->mgr_config.stallmode = false;\n\tsdi->mgr_config.fifohandcheck = false;\n\n\tsdi->mgr_config.video_port_width = 24;\n\tsdi->mgr_config.lcden_sig_polarity = 1;\n\n\tdss_mgr_set_lcd_config(&sdi->output, &sdi->mgr_config);\n}\n\n \n\nstatic int sdi_bridge_attach(struct drm_bridge *bridge,\n\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct sdi_device *sdi = drm_bridge_to_sdi(bridge);\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\treturn drm_bridge_attach(bridge->encoder, sdi->output.next_bridge,\n\t\t\t\t bridge, flags);\n}\n\nstatic enum drm_mode_status\nsdi_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t      const struct drm_display_info *info,\n\t\t      const struct drm_display_mode *mode)\n{\n\tstruct sdi_device *sdi = drm_bridge_to_sdi(bridge);\n\tunsigned long pixelclock = mode->clock * 1000;\n\tstruct dispc_clock_info dispc_cinfo;\n\tunsigned long fck;\n\tint ret;\n\n\tif (pixelclock == 0)\n\t\treturn MODE_NOCLOCK;\n\n\tret = sdi_calc_clock_div(sdi, pixelclock, &fck, &dispc_cinfo);\n\tif (ret < 0)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic bool sdi_bridge_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t  const struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct sdi_device *sdi = drm_bridge_to_sdi(bridge);\n\tunsigned long pixelclock = mode->clock * 1000;\n\tstruct dispc_clock_info dispc_cinfo;\n\tunsigned long fck;\n\tunsigned long pck;\n\tint ret;\n\n\tret = sdi_calc_clock_div(sdi, pixelclock, &fck, &dispc_cinfo);\n\tif (ret < 0)\n\t\treturn false;\n\n\tpck = fck / dispc_cinfo.lck_div / dispc_cinfo.pck_div;\n\n\tif (pck != pixelclock)\n\t\tdev_dbg(&sdi->pdev->dev,\n\t\t\t\"pixel clock adjusted from %lu Hz to %lu Hz\\n\",\n\t\t\tpixelclock, pck);\n\n\tadjusted_mode->clock = pck / 1000;\n\n\treturn true;\n}\n\nstatic void sdi_bridge_mode_set(struct drm_bridge *bridge,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tconst struct drm_display_mode *adjusted_mode)\n{\n\tstruct sdi_device *sdi = drm_bridge_to_sdi(bridge);\n\n\tsdi->pixelclock = adjusted_mode->clock * 1000;\n}\n\nstatic void sdi_bridge_enable(struct drm_bridge *bridge)\n{\n\tstruct sdi_device *sdi = drm_bridge_to_sdi(bridge);\n\tstruct dispc_clock_info dispc_cinfo;\n\tunsigned long fck;\n\tint r;\n\n\tr = regulator_enable(sdi->vdds_sdi_reg);\n\tif (r)\n\t\treturn;\n\n\tr = dispc_runtime_get(sdi->dss->dispc);\n\tif (r)\n\t\tgoto err_get_dispc;\n\n\tr = sdi_calc_clock_div(sdi, sdi->pixelclock, &fck, &dispc_cinfo);\n\tif (r)\n\t\tgoto err_calc_clock_div;\n\n\tsdi->mgr_config.clock_info = dispc_cinfo;\n\n\tr = dss_set_fck_rate(sdi->dss, fck);\n\tif (r)\n\t\tgoto err_set_dss_clock_div;\n\n\tsdi_config_lcd_manager(sdi);\n\n\t \n\tdispc_mgr_set_clock_div(sdi->dss->dispc, sdi->output.dispc_channel,\n\t\t\t\t&sdi->mgr_config.clock_info);\n\n\tdss_sdi_init(sdi->dss, sdi->datapairs);\n\tr = dss_sdi_enable(sdi->dss);\n\tif (r)\n\t\tgoto err_sdi_enable;\n\tmdelay(2);\n\n\tr = dss_mgr_enable(&sdi->output);\n\tif (r)\n\t\tgoto err_mgr_enable;\n\n\treturn;\n\nerr_mgr_enable:\n\tdss_sdi_disable(sdi->dss);\nerr_sdi_enable:\nerr_set_dss_clock_div:\nerr_calc_clock_div:\n\tdispc_runtime_put(sdi->dss->dispc);\nerr_get_dispc:\n\tregulator_disable(sdi->vdds_sdi_reg);\n}\n\nstatic void sdi_bridge_disable(struct drm_bridge *bridge)\n{\n\tstruct sdi_device *sdi = drm_bridge_to_sdi(bridge);\n\n\tdss_mgr_disable(&sdi->output);\n\n\tdss_sdi_disable(sdi->dss);\n\n\tdispc_runtime_put(sdi->dss->dispc);\n\n\tregulator_disable(sdi->vdds_sdi_reg);\n}\n\nstatic const struct drm_bridge_funcs sdi_bridge_funcs = {\n\t.attach = sdi_bridge_attach,\n\t.mode_valid = sdi_bridge_mode_valid,\n\t.mode_fixup = sdi_bridge_mode_fixup,\n\t.mode_set = sdi_bridge_mode_set,\n\t.enable = sdi_bridge_enable,\n\t.disable = sdi_bridge_disable,\n};\n\nstatic void sdi_bridge_init(struct sdi_device *sdi)\n{\n\tsdi->bridge.funcs = &sdi_bridge_funcs;\n\tsdi->bridge.of_node = sdi->pdev->dev.of_node;\n\tsdi->bridge.type = DRM_MODE_CONNECTOR_LVDS;\n\n\tdrm_bridge_add(&sdi->bridge);\n}\n\nstatic void sdi_bridge_cleanup(struct sdi_device *sdi)\n{\n\tdrm_bridge_remove(&sdi->bridge);\n}\n\n \n\nstatic int sdi_init_output(struct sdi_device *sdi)\n{\n\tstruct omap_dss_device *out = &sdi->output;\n\tint r;\n\n\tsdi_bridge_init(sdi);\n\n\tout->dev = &sdi->pdev->dev;\n\tout->id = OMAP_DSS_OUTPUT_SDI;\n\tout->type = OMAP_DISPLAY_TYPE_SDI;\n\tout->name = \"sdi.0\";\n\tout->dispc_channel = OMAP_DSS_CHANNEL_LCD;\n\t \n\tout->of_port = 1;\n\tout->bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE\t \n\t\t       | DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE;\n\n\tr = omapdss_device_init_output(out, &sdi->bridge);\n\tif (r < 0) {\n\t\tsdi_bridge_cleanup(sdi);\n\t\treturn r;\n\t}\n\n\tomapdss_device_register(out);\n\n\treturn 0;\n}\n\nstatic void sdi_uninit_output(struct sdi_device *sdi)\n{\n\tomapdss_device_unregister(&sdi->output);\n\tomapdss_device_cleanup_output(&sdi->output);\n\n\tsdi_bridge_cleanup(sdi);\n}\n\nint sdi_init_port(struct dss_device *dss, struct platform_device *pdev,\n\t\t  struct device_node *port)\n{\n\tstruct sdi_device *sdi;\n\tstruct device_node *ep;\n\tu32 datapairs;\n\tint r;\n\n\tsdi = kzalloc(sizeof(*sdi), GFP_KERNEL);\n\tif (!sdi)\n\t\treturn -ENOMEM;\n\n\tep = of_get_next_child(port, NULL);\n\tif (!ep) {\n\t\tr = 0;\n\t\tgoto err_free;\n\t}\n\n\tr = of_property_read_u32(ep, \"datapairs\", &datapairs);\n\tof_node_put(ep);\n\tif (r) {\n\t\tDSSERR(\"failed to parse datapairs\\n\");\n\t\tgoto err_free;\n\t}\n\n\tsdi->datapairs = datapairs;\n\tsdi->dss = dss;\n\n\tsdi->pdev = pdev;\n\tport->data = sdi;\n\n\tsdi->vdds_sdi_reg = devm_regulator_get(&pdev->dev, \"vdds_sdi\");\n\tif (IS_ERR(sdi->vdds_sdi_reg)) {\n\t\tr = PTR_ERR(sdi->vdds_sdi_reg);\n\t\tif (r != -EPROBE_DEFER)\n\t\t\tDSSERR(\"can't get VDDS_SDI regulator\\n\");\n\t\tgoto err_free;\n\t}\n\n\tr = sdi_init_output(sdi);\n\tif (r)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tkfree(sdi);\n\n\treturn r;\n}\n\nvoid sdi_uninit_port(struct device_node *port)\n{\n\tstruct sdi_device *sdi = port->data;\n\n\tif (!sdi)\n\t\treturn;\n\n\tsdi_uninit_output(sdi);\n\tkfree(sdi);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}