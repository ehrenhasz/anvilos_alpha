{
  "module_name": "dss.c",
  "hash_id": "622727c7c85dd9c67d005daead2387b18780f56f5d4b6b8908eab24eae228de4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/dss.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"DSS\"\n\n#include <linux/debugfs.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/seq_file.h>\n#include <linux/clk.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/gfp.h>\n#include <linux/sizes.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/regulator/consumer.h>\n#include <linux/suspend.h>\n#include <linux/component.h>\n#include <linux/sys_soc.h>\n\n#include \"omapdss.h\"\n#include \"dss.h\"\n\nstruct dss_reg {\n\tu16 idx;\n};\n\n#define DSS_REG(idx)\t\t\t((const struct dss_reg) { idx })\n\n#define DSS_REVISION\t\t\tDSS_REG(0x0000)\n#define DSS_SYSCONFIG\t\t\tDSS_REG(0x0010)\n#define DSS_SYSSTATUS\t\t\tDSS_REG(0x0014)\n#define DSS_CONTROL\t\t\tDSS_REG(0x0040)\n#define DSS_SDI_CONTROL\t\t\tDSS_REG(0x0044)\n#define DSS_PLL_CONTROL\t\t\tDSS_REG(0x0048)\n#define DSS_SDI_STATUS\t\t\tDSS_REG(0x005C)\n\n#define REG_GET(dss, idx, start, end) \\\n\tFLD_GET(dss_read_reg(dss, idx), start, end)\n\n#define REG_FLD_MOD(dss, idx, val, start, end) \\\n\tdss_write_reg(dss, idx, \\\n\t\t      FLD_MOD(dss_read_reg(dss, idx), val, start, end))\n\nstruct dss_ops {\n\tint (*dpi_select_source)(struct dss_device *dss, int port,\n\t\t\t\t enum omap_channel channel);\n\tint (*select_lcd_source)(struct dss_device *dss,\n\t\t\t\t enum omap_channel channel,\n\t\t\t\t enum dss_clk_source clk_src);\n};\n\nstruct dss_features {\n\tenum dss_model model;\n\tu8 fck_div_max;\n\tunsigned int fck_freq_max;\n\tu8 dss_fck_multiplier;\n\tconst char *parent_clk_name;\n\tconst enum omap_display_type *ports;\n\tint num_ports;\n\tconst enum omap_dss_output_id *outputs;\n\tconst struct dss_ops *ops;\n\tstruct dss_reg_field dispc_clk_switch;\n\tbool has_lcd_clk_src;\n};\n\nstatic const char * const dss_generic_clk_source_names[] = {\n\t[DSS_CLK_SRC_FCK]\t= \"FCK\",\n\t[DSS_CLK_SRC_PLL1_1]\t= \"PLL1:1\",\n\t[DSS_CLK_SRC_PLL1_2]\t= \"PLL1:2\",\n\t[DSS_CLK_SRC_PLL1_3]\t= \"PLL1:3\",\n\t[DSS_CLK_SRC_PLL2_1]\t= \"PLL2:1\",\n\t[DSS_CLK_SRC_PLL2_2]\t= \"PLL2:2\",\n\t[DSS_CLK_SRC_PLL2_3]\t= \"PLL2:3\",\n\t[DSS_CLK_SRC_HDMI_PLL]\t= \"HDMI PLL\",\n};\n\nstatic inline void dss_write_reg(struct dss_device *dss,\n\t\t\t\t const struct dss_reg idx, u32 val)\n{\n\t__raw_writel(val, dss->base + idx.idx);\n}\n\nstatic inline u32 dss_read_reg(struct dss_device *dss, const struct dss_reg idx)\n{\n\treturn __raw_readl(dss->base + idx.idx);\n}\n\n#define SR(dss, reg) \\\n\tdss->ctx[(DSS_##reg).idx / sizeof(u32)] = dss_read_reg(dss, DSS_##reg)\n#define RR(dss, reg) \\\n\tdss_write_reg(dss, DSS_##reg, dss->ctx[(DSS_##reg).idx / sizeof(u32)])\n\nstatic void dss_save_context(struct dss_device *dss)\n{\n\tDSSDBG(\"dss_save_context\\n\");\n\n\tSR(dss, CONTROL);\n\n\tif (dss->feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {\n\t\tSR(dss, SDI_CONTROL);\n\t\tSR(dss, PLL_CONTROL);\n\t}\n\n\tdss->ctx_valid = true;\n\n\tDSSDBG(\"context saved\\n\");\n}\n\nstatic void dss_restore_context(struct dss_device *dss)\n{\n\tDSSDBG(\"dss_restore_context\\n\");\n\n\tif (!dss->ctx_valid)\n\t\treturn;\n\n\tRR(dss, CONTROL);\n\n\tif (dss->feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {\n\t\tRR(dss, SDI_CONTROL);\n\t\tRR(dss, PLL_CONTROL);\n\t}\n\n\tDSSDBG(\"context restored\\n\");\n}\n\n#undef SR\n#undef RR\n\nvoid dss_ctrl_pll_enable(struct dss_pll *pll, bool enable)\n{\n\tunsigned int shift;\n\tunsigned int val;\n\n\tif (!pll->dss->syscon_pll_ctrl)\n\t\treturn;\n\n\tval = !enable;\n\n\tswitch (pll->id) {\n\tcase DSS_PLL_VIDEO1:\n\t\tshift = 0;\n\t\tbreak;\n\tcase DSS_PLL_VIDEO2:\n\t\tshift = 1;\n\t\tbreak;\n\tcase DSS_PLL_HDMI:\n\t\tshift = 2;\n\t\tbreak;\n\tdefault:\n\t\tDSSERR(\"illegal DSS PLL ID %d\\n\", pll->id);\n\t\treturn;\n\t}\n\n\tregmap_update_bits(pll->dss->syscon_pll_ctrl,\n\t\t\t   pll->dss->syscon_pll_ctrl_offset,\n\t\t\t   1 << shift, val << shift);\n}\n\nstatic int dss_ctrl_pll_set_control_mux(struct dss_device *dss,\n\t\t\t\t\tenum dss_clk_source clk_src,\n\t\t\t\t\tenum omap_channel channel)\n{\n\tunsigned int shift, val;\n\n\tif (!dss->syscon_pll_ctrl)\n\t\treturn -EINVAL;\n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t\tshift = 3;\n\n\t\tswitch (clk_src) {\n\t\tcase DSS_CLK_SRC_PLL1_1:\n\t\t\tval = 0; break;\n\t\tcase DSS_CLK_SRC_HDMI_PLL:\n\t\t\tval = 1; break;\n\t\tdefault:\n\t\t\tDSSERR(\"error in PLL mux config for LCD\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tshift = 5;\n\n\t\tswitch (clk_src) {\n\t\tcase DSS_CLK_SRC_PLL1_3:\n\t\t\tval = 0; break;\n\t\tcase DSS_CLK_SRC_PLL2_3:\n\t\t\tval = 1; break;\n\t\tcase DSS_CLK_SRC_HDMI_PLL:\n\t\t\tval = 2; break;\n\t\tdefault:\n\t\t\tDSSERR(\"error in PLL mux config for LCD2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\tshift = 7;\n\n\t\tswitch (clk_src) {\n\t\tcase DSS_CLK_SRC_PLL2_1:\n\t\t\tval = 0; break;\n\t\tcase DSS_CLK_SRC_PLL1_3:\n\t\t\tval = 1; break;\n\t\tcase DSS_CLK_SRC_HDMI_PLL:\n\t\t\tval = 2; break;\n\t\tdefault:\n\t\t\tDSSERR(\"error in PLL mux config for LCD3\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tDSSERR(\"error in PLL mux config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(dss->syscon_pll_ctrl, dss->syscon_pll_ctrl_offset,\n\t\t0x3 << shift, val << shift);\n\n\treturn 0;\n}\n\nvoid dss_sdi_init(struct dss_device *dss, int datapairs)\n{\n\tu32 l;\n\n\tBUG_ON(datapairs > 3 || datapairs < 1);\n\n\tl = dss_read_reg(dss, DSS_SDI_CONTROL);\n\tl = FLD_MOD(l, 0xf, 19, 15);\t\t \n\tl = FLD_MOD(l, datapairs-1, 3, 2);\t \n\tl = FLD_MOD(l, 2, 1, 0);\t\t \n\tdss_write_reg(dss, DSS_SDI_CONTROL, l);\n\n\tl = dss_read_reg(dss, DSS_PLL_CONTROL);\n\tl = FLD_MOD(l, 0x7, 25, 22);\t \n\tl = FLD_MOD(l, 0xb, 16, 11);\t \n\tl = FLD_MOD(l, 0xb4, 10, 1);\t \n\tdss_write_reg(dss, DSS_PLL_CONTROL, l);\n}\n\nint dss_sdi_enable(struct dss_device *dss)\n{\n\tunsigned long timeout;\n\n\tdispc_pck_free_enable(dss->dispc, 1);\n\n\t \n\tREG_FLD_MOD(dss, DSS_PLL_CONTROL, 1, 18, 18);  \n\tudelay(1);\t \n\n\t \n\tREG_FLD_MOD(dss, DSS_PLL_CONTROL, 1, 28, 28);  \n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (dss_read_reg(dss, DSS_SDI_STATUS) & (1 << 6)) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tDSSERR(\"PLL lock request timed out\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\t \n\tREG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 28, 28);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (!(dss_read_reg(dss, DSS_SDI_STATUS) & (1 << 5))) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tDSSERR(\"PLL lock timed out\\n\");\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\tdispc_lcd_enable_signal(dss->dispc, 1);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(500);\n\twhile (!(dss_read_reg(dss, DSS_SDI_STATUS) & (1 << 2))) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tDSSERR(\"SDI reset timed out\\n\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\n\treturn 0;\n\n err2:\n\tdispc_lcd_enable_signal(dss->dispc, 0);\n err1:\n\t \n\tREG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18);  \n\n\tdispc_pck_free_enable(dss->dispc, 0);\n\n\treturn -ETIMEDOUT;\n}\n\nvoid dss_sdi_disable(struct dss_device *dss)\n{\n\tdispc_lcd_enable_signal(dss->dispc, 0);\n\n\tdispc_pck_free_enable(dss->dispc, 0);\n\n\t \n\tREG_FLD_MOD(dss, DSS_PLL_CONTROL, 0, 18, 18);  \n}\n\nconst char *dss_get_clk_source_name(enum dss_clk_source clk_src)\n{\n\treturn dss_generic_clk_source_names[clk_src];\n}\n\nstatic void dss_dump_clocks(struct dss_device *dss, struct seq_file *s)\n{\n\tconst char *fclk_name;\n\tunsigned long fclk_rate;\n\n\tif (dss_runtime_get(dss))\n\t\treturn;\n\n\tseq_printf(s, \"- DSS -\\n\");\n\n\tfclk_name = dss_get_clk_source_name(DSS_CLK_SRC_FCK);\n\tfclk_rate = clk_get_rate(dss->dss_clk);\n\n\tseq_printf(s, \"%s = %lu\\n\",\n\t\t\tfclk_name,\n\t\t\tfclk_rate);\n\n\tdss_runtime_put(dss);\n}\n\nstatic int dss_dump_regs(struct seq_file *s, void *p)\n{\n\tstruct dss_device *dss = s->private;\n\n#define DUMPREG(dss, r) seq_printf(s, \"%-35s %08x\\n\", #r, dss_read_reg(dss, r))\n\n\tif (dss_runtime_get(dss))\n\t\treturn 0;\n\n\tDUMPREG(dss, DSS_REVISION);\n\tDUMPREG(dss, DSS_SYSCONFIG);\n\tDUMPREG(dss, DSS_SYSSTATUS);\n\tDUMPREG(dss, DSS_CONTROL);\n\n\tif (dss->feat->outputs[OMAP_DSS_CHANNEL_LCD] & OMAP_DSS_OUTPUT_SDI) {\n\t\tDUMPREG(dss, DSS_SDI_CONTROL);\n\t\tDUMPREG(dss, DSS_PLL_CONTROL);\n\t\tDUMPREG(dss, DSS_SDI_STATUS);\n\t}\n\n\tdss_runtime_put(dss);\n#undef DUMPREG\n\treturn 0;\n}\n\nstatic int dss_debug_dump_clocks(struct seq_file *s, void *p)\n{\n\tstruct dss_device *dss = s->private;\n\n\tdss_dump_clocks(dss, s);\n\tdispc_dump_clocks(dss->dispc, s);\n\treturn 0;\n}\n\nstatic int dss_get_channel_index(enum omap_channel channel)\n{\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t\treturn 0;\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\treturn 1;\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\treturn 2;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n}\n\nstatic void dss_select_dispc_clk_source(struct dss_device *dss,\n\t\t\t\t\tenum dss_clk_source clk_src)\n{\n\tint b;\n\n\t \n\tif (WARN_ON(dss->feat->has_lcd_clk_src && clk_src != DSS_CLK_SRC_FCK))\n\t\treturn;\n\n\tswitch (clk_src) {\n\tcase DSS_CLK_SRC_FCK:\n\t\tb = 0;\n\t\tbreak;\n\tcase DSS_CLK_SRC_PLL1_1:\n\t\tb = 1;\n\t\tbreak;\n\tcase DSS_CLK_SRC_PLL2_1:\n\t\tb = 2;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tREG_FLD_MOD(dss, DSS_CONTROL, b,\t\t \n\t\t    dss->feat->dispc_clk_switch.start,\n\t\t    dss->feat->dispc_clk_switch.end);\n\n\tdss->dispc_clk_source = clk_src;\n}\n\nvoid dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,\n\t\t\t       enum dss_clk_source clk_src)\n{\n\tint b, pos;\n\n\tswitch (clk_src) {\n\tcase DSS_CLK_SRC_FCK:\n\t\tb = 0;\n\t\tbreak;\n\tcase DSS_CLK_SRC_PLL1_2:\n\t\tBUG_ON(dsi_module != 0);\n\t\tb = 1;\n\t\tbreak;\n\tcase DSS_CLK_SRC_PLL2_2:\n\t\tBUG_ON(dsi_module != 1);\n\t\tb = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tpos = dsi_module == 0 ? 1 : 10;\n\tREG_FLD_MOD(dss, DSS_CONTROL, b, pos, pos);\t \n\n\tdss->dsi_clk_source[dsi_module] = clk_src;\n}\n\nstatic int dss_lcd_clk_mux_dra7(struct dss_device *dss,\n\t\t\t\tenum omap_channel channel,\n\t\t\t\tenum dss_clk_source clk_src)\n{\n\tconst u8 ctrl_bits[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD] = 0,\n\t\t[OMAP_DSS_CHANNEL_LCD2] = 12,\n\t\t[OMAP_DSS_CHANNEL_LCD3] = 19,\n\t};\n\n\tu8 ctrl_bit = ctrl_bits[channel];\n\tint r;\n\n\tif (clk_src == DSS_CLK_SRC_FCK) {\n\t\t \n\t\tREG_FLD_MOD(dss, DSS_CONTROL, 0, ctrl_bit, ctrl_bit);\n\t\treturn -EINVAL;\n\t}\n\n\tr = dss_ctrl_pll_set_control_mux(dss, clk_src, channel);\n\tif (r)\n\t\treturn r;\n\n\tREG_FLD_MOD(dss, DSS_CONTROL, 1, ctrl_bit, ctrl_bit);\n\n\treturn 0;\n}\n\nstatic int dss_lcd_clk_mux_omap5(struct dss_device *dss,\n\t\t\t\t enum omap_channel channel,\n\t\t\t\t enum dss_clk_source clk_src)\n{\n\tconst u8 ctrl_bits[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD] = 0,\n\t\t[OMAP_DSS_CHANNEL_LCD2] = 12,\n\t\t[OMAP_DSS_CHANNEL_LCD3] = 19,\n\t};\n\tconst enum dss_clk_source allowed_plls[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD] = DSS_CLK_SRC_PLL1_1,\n\t\t[OMAP_DSS_CHANNEL_LCD2] = DSS_CLK_SRC_FCK,\n\t\t[OMAP_DSS_CHANNEL_LCD3] = DSS_CLK_SRC_PLL2_1,\n\t};\n\n\tu8 ctrl_bit = ctrl_bits[channel];\n\n\tif (clk_src == DSS_CLK_SRC_FCK) {\n\t\t \n\t\tREG_FLD_MOD(dss, DSS_CONTROL, 0, ctrl_bit, ctrl_bit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(allowed_plls[channel] != clk_src))\n\t\treturn -EINVAL;\n\n\tREG_FLD_MOD(dss, DSS_CONTROL, 1, ctrl_bit, ctrl_bit);\n\n\treturn 0;\n}\n\nstatic int dss_lcd_clk_mux_omap4(struct dss_device *dss,\n\t\t\t\t enum omap_channel channel,\n\t\t\t\t enum dss_clk_source clk_src)\n{\n\tconst u8 ctrl_bits[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD] = 0,\n\t\t[OMAP_DSS_CHANNEL_LCD2] = 12,\n\t};\n\tconst enum dss_clk_source allowed_plls[] = {\n\t\t[OMAP_DSS_CHANNEL_LCD] = DSS_CLK_SRC_PLL1_1,\n\t\t[OMAP_DSS_CHANNEL_LCD2] = DSS_CLK_SRC_PLL2_1,\n\t};\n\n\tu8 ctrl_bit = ctrl_bits[channel];\n\n\tif (clk_src == DSS_CLK_SRC_FCK) {\n\t\t \n\t\tREG_FLD_MOD(dss, DSS_CONTROL, 0, ctrl_bit, ctrl_bit);\n\t\treturn 0;\n\t}\n\n\tif (WARN_ON(allowed_plls[channel] != clk_src))\n\t\treturn -EINVAL;\n\n\tREG_FLD_MOD(dss, DSS_CONTROL, 1, ctrl_bit, ctrl_bit);\n\n\treturn 0;\n}\n\nvoid dss_select_lcd_clk_source(struct dss_device *dss,\n\t\t\t       enum omap_channel channel,\n\t\t\t       enum dss_clk_source clk_src)\n{\n\tint idx = dss_get_channel_index(channel);\n\tint r;\n\n\tif (!dss->feat->has_lcd_clk_src) {\n\t\tdss_select_dispc_clk_source(dss, clk_src);\n\t\tdss->lcd_clk_source[idx] = clk_src;\n\t\treturn;\n\t}\n\n\tr = dss->feat->ops->select_lcd_source(dss, channel, clk_src);\n\tif (r)\n\t\treturn;\n\n\tdss->lcd_clk_source[idx] = clk_src;\n}\n\nenum dss_clk_source dss_get_dispc_clk_source(struct dss_device *dss)\n{\n\treturn dss->dispc_clk_source;\n}\n\nenum dss_clk_source dss_get_dsi_clk_source(struct dss_device *dss,\n\t\t\t\t\t   int dsi_module)\n{\n\treturn dss->dsi_clk_source[dsi_module];\n}\n\nenum dss_clk_source dss_get_lcd_clk_source(struct dss_device *dss,\n\t\t\t\t\t   enum omap_channel channel)\n{\n\tif (dss->feat->has_lcd_clk_src) {\n\t\tint idx = dss_get_channel_index(channel);\n\t\treturn dss->lcd_clk_source[idx];\n\t} else {\n\t\t \n\t\treturn dss->dispc_clk_source;\n\t}\n}\n\nbool dss_div_calc(struct dss_device *dss, unsigned long pck,\n\t\t  unsigned long fck_min, dss_div_calc_func func, void *data)\n{\n\tint fckd, fckd_start, fckd_stop;\n\tunsigned long fck;\n\tunsigned long fck_hw_max;\n\tunsigned long fckd_hw_max;\n\tunsigned long prate;\n\tunsigned int m;\n\n\tfck_hw_max = dss->feat->fck_freq_max;\n\n\tif (dss->parent_clk == NULL) {\n\t\tunsigned int pckd;\n\n\t\tpckd = fck_hw_max / pck;\n\n\t\tfck = pck * pckd;\n\n\t\tfck = clk_round_rate(dss->dss_clk, fck);\n\n\t\treturn func(fck, data);\n\t}\n\n\tfckd_hw_max = dss->feat->fck_div_max;\n\n\tm = dss->feat->dss_fck_multiplier;\n\tprate = clk_get_rate(dss->parent_clk);\n\n\tfck_min = fck_min ? fck_min : 1;\n\n\tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n\tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n\n\tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n\t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n\n\t\tif (func(fck, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint dss_set_fck_rate(struct dss_device *dss, unsigned long rate)\n{\n\tint r;\n\n\tDSSDBG(\"set fck to %lu\\n\", rate);\n\n\tr = clk_set_rate(dss->dss_clk, rate);\n\tif (r)\n\t\treturn r;\n\n\tdss->dss_clk_rate = clk_get_rate(dss->dss_clk);\n\n\tWARN_ONCE(dss->dss_clk_rate != rate, \"clk rate mismatch: %lu != %lu\",\n\t\t  dss->dss_clk_rate, rate);\n\n\treturn 0;\n}\n\nunsigned long dss_get_dispc_clk_rate(struct dss_device *dss)\n{\n\treturn dss->dss_clk_rate;\n}\n\nunsigned long dss_get_max_fck_rate(struct dss_device *dss)\n{\n\treturn dss->feat->fck_freq_max;\n}\n\nstatic int dss_setup_default_clock(struct dss_device *dss)\n{\n\tunsigned long max_dss_fck, prate;\n\tunsigned long fck;\n\tunsigned int fck_div;\n\tint r;\n\n\tmax_dss_fck = dss->feat->fck_freq_max;\n\n\tif (dss->parent_clk == NULL) {\n\t\tfck = clk_round_rate(dss->dss_clk, max_dss_fck);\n\t} else {\n\t\tprate = clk_get_rate(dss->parent_clk);\n\n\t\tfck_div = DIV_ROUND_UP(prate * dss->feat->dss_fck_multiplier,\n\t\t\t\tmax_dss_fck);\n\t\tfck = DIV_ROUND_UP(prate, fck_div)\n\t\t    * dss->feat->dss_fck_multiplier;\n\t}\n\n\tr = dss_set_fck_rate(dss, fck);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nvoid dss_set_venc_output(struct dss_device *dss, enum omap_dss_venc_type type)\n{\n\tint l = 0;\n\n\tif (type == OMAP_DSS_VENC_TYPE_COMPOSITE)\n\t\tl = 0;\n\telse if (type == OMAP_DSS_VENC_TYPE_SVIDEO)\n\t\tl = 1;\n\telse\n\t\tBUG();\n\n\t \n\tREG_FLD_MOD(dss, DSS_CONTROL, l, 6, 6);\n}\n\nvoid dss_set_dac_pwrdn_bgz(struct dss_device *dss, bool enable)\n{\n\t \n\tREG_FLD_MOD(dss, DSS_CONTROL, enable, 5, 5);\n}\n\nvoid dss_select_hdmi_venc_clk_source(struct dss_device *dss,\n\t\t\t\t     enum dss_hdmi_venc_clk_source_select src)\n{\n\tenum omap_dss_output_id outputs;\n\n\toutputs = dss->feat->outputs[OMAP_DSS_CHANNEL_DIGIT];\n\n\t \n\tWARN_ON((src == DSS_VENC_TV_CLK) && !(outputs & OMAP_DSS_OUTPUT_VENC));\n\tWARN_ON((src == DSS_HDMI_M_PCLK) && !(outputs & OMAP_DSS_OUTPUT_HDMI));\n\n\t \n\tif ((outputs & OMAP_DSS_OUTPUT_VENC) &&\n\t    (outputs & OMAP_DSS_OUTPUT_HDMI))\n\t\t \n\t\tREG_FLD_MOD(dss, DSS_CONTROL, src, 15, 15);\n}\n\nstatic int dss_dpi_select_source_omap2_omap3(struct dss_device *dss, int port,\n\t\t\t\t\t     enum omap_channel channel)\n{\n\tif (channel != OMAP_DSS_CHANNEL_LCD)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int dss_dpi_select_source_omap4(struct dss_device *dss, int port,\n\t\t\t\t       enum omap_channel channel)\n{\n\tint val;\n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tval = 0;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_DIGIT:\n\t\tval = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tREG_FLD_MOD(dss, DSS_CONTROL, val, 17, 17);\n\n\treturn 0;\n}\n\nstatic int dss_dpi_select_source_omap5(struct dss_device *dss, int port,\n\t\t\t\t       enum omap_channel channel)\n{\n\tint val;\n\n\tswitch (channel) {\n\tcase OMAP_DSS_CHANNEL_LCD:\n\t\tval = 1;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD2:\n\t\tval = 2;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_LCD3:\n\t\tval = 3;\n\t\tbreak;\n\tcase OMAP_DSS_CHANNEL_DIGIT:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tREG_FLD_MOD(dss, DSS_CONTROL, val, 17, 16);\n\n\treturn 0;\n}\n\nstatic int dss_dpi_select_source_dra7xx(struct dss_device *dss, int port,\n\t\t\t\t\tenum omap_channel channel)\n{\n\tswitch (port) {\n\tcase 0:\n\t\treturn dss_dpi_select_source_omap5(dss, port, channel);\n\tcase 1:\n\t\tif (channel != OMAP_DSS_CHANNEL_LCD2)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 2:\n\t\tif (channel != OMAP_DSS_CHANNEL_LCD3)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint dss_dpi_select_source(struct dss_device *dss, int port,\n\t\t\t  enum omap_channel channel)\n{\n\treturn dss->feat->ops->dpi_select_source(dss, port, channel);\n}\n\nstatic int dss_get_clocks(struct dss_device *dss)\n{\n\tstruct clk *clk;\n\n\tclk = devm_clk_get(&dss->pdev->dev, \"fck\");\n\tif (IS_ERR(clk)) {\n\t\tDSSERR(\"can't get clock fck\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tdss->dss_clk = clk;\n\n\tif (dss->feat->parent_clk_name) {\n\t\tclk = clk_get(NULL, dss->feat->parent_clk_name);\n\t\tif (IS_ERR(clk)) {\n\t\t\tDSSERR(\"Failed to get %s\\n\",\n\t\t\t       dss->feat->parent_clk_name);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t} else {\n\t\tclk = NULL;\n\t}\n\n\tdss->parent_clk = clk;\n\n\treturn 0;\n}\n\nstatic void dss_put_clocks(struct dss_device *dss)\n{\n\tif (dss->parent_clk)\n\t\tclk_put(dss->parent_clk);\n}\n\nint dss_runtime_get(struct dss_device *dss)\n{\n\tint r;\n\n\tDSSDBG(\"dss_runtime_get\\n\");\n\n\tr = pm_runtime_get_sync(&dss->pdev->dev);\n\tif (WARN_ON(r < 0)) {\n\t\tpm_runtime_put_noidle(&dss->pdev->dev);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\nvoid dss_runtime_put(struct dss_device *dss)\n{\n\tint r;\n\n\tDSSDBG(\"dss_runtime_put\\n\");\n\n\tr = pm_runtime_put_sync(&dss->pdev->dev);\n\tWARN_ON(r < 0 && r != -ENOSYS && r != -EBUSY);\n}\n\nstruct dss_device *dss_get_device(struct device *dev)\n{\n\treturn dev_get_drvdata(dev);\n}\n\n \n#if defined(CONFIG_OMAP2_DSS_DEBUGFS)\nstatic int dss_initialize_debugfs(struct dss_device *dss)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"omapdss\", NULL);\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tdss->debugfs.root = dir;\n\n\treturn 0;\n}\n\nstatic void dss_uninitialize_debugfs(struct dss_device *dss)\n{\n\tdebugfs_remove_recursive(dss->debugfs.root);\n}\n\nstruct dss_debugfs_entry {\n\tstruct dentry *dentry;\n\tint (*show_fn)(struct seq_file *s, void *data);\n\tvoid *data;\n};\n\nstatic int dss_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct dss_debugfs_entry *entry = inode->i_private;\n\n\treturn single_open(file, entry->show_fn, entry->data);\n}\n\nstatic const struct file_operations dss_debug_fops = {\n\t.open\t\t= dss_debug_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstruct dss_debugfs_entry *\ndss_debugfs_create_file(struct dss_device *dss, const char *name,\n\t\t\tint (*show_fn)(struct seq_file *s, void *data),\n\t\t\tvoid *data)\n{\n\tstruct dss_debugfs_entry *entry;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tentry->show_fn = show_fn;\n\tentry->data = data;\n\tentry->dentry = debugfs_create_file(name, 0444, dss->debugfs.root,\n\t\t\t\t\t    entry, &dss_debug_fops);\n\n\treturn entry;\n}\n\nvoid dss_debugfs_remove_file(struct dss_debugfs_entry *entry)\n{\n\tif (IS_ERR_OR_NULL(entry))\n\t\treturn;\n\n\tdebugfs_remove(entry->dentry);\n\tkfree(entry);\n}\n\n#else  \nstatic inline int dss_initialize_debugfs(struct dss_device *dss)\n{\n\treturn 0;\n}\nstatic inline void dss_uninitialize_debugfs(struct dss_device *dss)\n{\n}\n#endif  \n\nstatic const struct dss_ops dss_ops_omap2_omap3 = {\n\t.dpi_select_source = &dss_dpi_select_source_omap2_omap3,\n};\n\nstatic const struct dss_ops dss_ops_omap4 = {\n\t.dpi_select_source = &dss_dpi_select_source_omap4,\n\t.select_lcd_source = &dss_lcd_clk_mux_omap4,\n};\n\nstatic const struct dss_ops dss_ops_omap5 = {\n\t.dpi_select_source = &dss_dpi_select_source_omap5,\n\t.select_lcd_source = &dss_lcd_clk_mux_omap5,\n};\n\nstatic const struct dss_ops dss_ops_dra7 = {\n\t.dpi_select_source = &dss_dpi_select_source_dra7xx,\n\t.select_lcd_source = &dss_lcd_clk_mux_dra7,\n};\n\nstatic const enum omap_display_type omap2plus_ports[] = {\n\tOMAP_DISPLAY_TYPE_DPI,\n};\n\nstatic const enum omap_display_type omap34xx_ports[] = {\n\tOMAP_DISPLAY_TYPE_DPI,\n\tOMAP_DISPLAY_TYPE_SDI,\n};\n\nstatic const enum omap_display_type dra7xx_ports[] = {\n\tOMAP_DISPLAY_TYPE_DPI,\n\tOMAP_DISPLAY_TYPE_DPI,\n\tOMAP_DISPLAY_TYPE_DPI,\n};\n\nstatic const enum omap_dss_output_id omap2_dss_supported_outputs[] = {\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI,\n\n\t \n\tOMAP_DSS_OUTPUT_VENC,\n};\n\nstatic const enum omap_dss_output_id omap3430_dss_supported_outputs[] = {\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |\n\tOMAP_DSS_OUTPUT_SDI | OMAP_DSS_OUTPUT_DSI1,\n\n\t \n\tOMAP_DSS_OUTPUT_VENC,\n};\n\nstatic const enum omap_dss_output_id omap3630_dss_supported_outputs[] = {\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |\n\tOMAP_DSS_OUTPUT_DSI1,\n\n\t \n\tOMAP_DSS_OUTPUT_VENC,\n};\n\nstatic const enum omap_dss_output_id am43xx_dss_supported_outputs[] = {\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI,\n};\n\nstatic const enum omap_dss_output_id omap4_dss_supported_outputs[] = {\n\t \n\tOMAP_DSS_OUTPUT_DBI | OMAP_DSS_OUTPUT_DSI1,\n\n\t \n\tOMAP_DSS_OUTPUT_VENC | OMAP_DSS_OUTPUT_HDMI,\n\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |\n\tOMAP_DSS_OUTPUT_DSI2,\n};\n\nstatic const enum omap_dss_output_id omap5_dss_supported_outputs[] = {\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |\n\tOMAP_DSS_OUTPUT_DSI1 | OMAP_DSS_OUTPUT_DSI2,\n\n\t \n\tOMAP_DSS_OUTPUT_HDMI,\n\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |\n\tOMAP_DSS_OUTPUT_DSI1,\n\n\t \n\tOMAP_DSS_OUTPUT_DPI | OMAP_DSS_OUTPUT_DBI |\n\tOMAP_DSS_OUTPUT_DSI2,\n};\n\nstatic const struct dss_features omap24xx_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_OMAP2,\n\t \n\t.fck_div_max\t\t=\t6,\n\t.fck_freq_max\t\t=\t133000000,\n\t.dss_fck_multiplier\t=\t2,\n\t.parent_clk_name\t=\t\"core_ck\",\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n\t.outputs\t\t=\tomap2_dss_supported_outputs,\n\t.ops\t\t\t=\t&dss_ops_omap2_omap3,\n\t.dispc_clk_switch\t=\t{ 0, 0 },\n\t.has_lcd_clk_src\t=\tfalse,\n};\n\nstatic const struct dss_features omap34xx_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_OMAP3,\n\t.fck_div_max\t\t=\t16,\n\t.fck_freq_max\t\t=\t173000000,\n\t.dss_fck_multiplier\t=\t2,\n\t.parent_clk_name\t=\t\"dpll4_ck\",\n\t.ports\t\t\t=\tomap34xx_ports,\n\t.outputs\t\t=\tomap3430_dss_supported_outputs,\n\t.num_ports\t\t=\tARRAY_SIZE(omap34xx_ports),\n\t.ops\t\t\t=\t&dss_ops_omap2_omap3,\n\t.dispc_clk_switch\t=\t{ 0, 0 },\n\t.has_lcd_clk_src\t=\tfalse,\n};\n\nstatic const struct dss_features omap3630_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_OMAP3,\n\t.fck_div_max\t\t=\t31,\n\t.fck_freq_max\t\t=\t173000000,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll4_ck\",\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n\t.outputs\t\t=\tomap3630_dss_supported_outputs,\n\t.ops\t\t\t=\t&dss_ops_omap2_omap3,\n\t.dispc_clk_switch\t=\t{ 0, 0 },\n\t.has_lcd_clk_src\t=\tfalse,\n};\n\nstatic const struct dss_features omap44xx_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_OMAP4,\n\t.fck_div_max\t\t=\t32,\n\t.fck_freq_max\t\t=\t186000000,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll_per_x2_ck\",\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n\t.outputs\t\t=\tomap4_dss_supported_outputs,\n\t.ops\t\t\t=\t&dss_ops_omap4,\n\t.dispc_clk_switch\t=\t{ 9, 8 },\n\t.has_lcd_clk_src\t=\ttrue,\n};\n\nstatic const struct dss_features omap54xx_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_OMAP5,\n\t.fck_div_max\t\t=\t64,\n\t.fck_freq_max\t\t=\t209250000,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll_per_x2_ck\",\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n\t.outputs\t\t=\tomap5_dss_supported_outputs,\n\t.ops\t\t\t=\t&dss_ops_omap5,\n\t.dispc_clk_switch\t=\t{ 9, 7 },\n\t.has_lcd_clk_src\t=\ttrue,\n};\n\nstatic const struct dss_features am43xx_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_OMAP3,\n\t.fck_div_max\t\t=\t0,\n\t.fck_freq_max\t\t=\t200000000,\n\t.dss_fck_multiplier\t=\t0,\n\t.parent_clk_name\t=\tNULL,\n\t.ports\t\t\t=\tomap2plus_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(omap2plus_ports),\n\t.outputs\t\t=\tam43xx_dss_supported_outputs,\n\t.ops\t\t\t=\t&dss_ops_omap2_omap3,\n\t.dispc_clk_switch\t=\t{ 0, 0 },\n\t.has_lcd_clk_src\t=\ttrue,\n};\n\nstatic const struct dss_features dra7xx_dss_feats = {\n\t.model\t\t\t=\tDSS_MODEL_DRA7,\n\t.fck_div_max\t\t=\t64,\n\t.fck_freq_max\t\t=\t209250000,\n\t.dss_fck_multiplier\t=\t1,\n\t.parent_clk_name\t=\t\"dpll_per_x2_ck\",\n\t.ports\t\t\t=\tdra7xx_ports,\n\t.num_ports\t\t=\tARRAY_SIZE(dra7xx_ports),\n\t.outputs\t\t=\tomap5_dss_supported_outputs,\n\t.ops\t\t\t=\t&dss_ops_dra7,\n\t.dispc_clk_switch\t=\t{ 9, 7 },\n\t.has_lcd_clk_src\t=\ttrue,\n};\n\nstatic void __dss_uninit_ports(struct dss_device *dss, unsigned int num_ports)\n{\n\tstruct platform_device *pdev = dss->pdev;\n\tstruct device_node *parent = pdev->dev.of_node;\n\tstruct device_node *port;\n\tunsigned int i;\n\n\tfor (i = 0; i < num_ports; i++) {\n\t\tport = of_graph_get_port_by_id(parent, i);\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tswitch (dss->feat->ports[i]) {\n\t\tcase OMAP_DISPLAY_TYPE_DPI:\n\t\t\tdpi_uninit_port(port);\n\t\t\tbreak;\n\t\tcase OMAP_DISPLAY_TYPE_SDI:\n\t\t\tsdi_uninit_port(port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tof_node_put(port);\n\t}\n}\n\nstatic int dss_init_ports(struct dss_device *dss)\n{\n\tstruct platform_device *pdev = dss->pdev;\n\tstruct device_node *parent = pdev->dev.of_node;\n\tstruct device_node *port;\n\tunsigned int i;\n\tint r;\n\n\tfor (i = 0; i < dss->feat->num_ports; i++) {\n\t\tport = of_graph_get_port_by_id(parent, i);\n\t\tif (!port)\n\t\t\tcontinue;\n\n\t\tswitch (dss->feat->ports[i]) {\n\t\tcase OMAP_DISPLAY_TYPE_DPI:\n\t\t\tr = dpi_init_port(dss, pdev, port, dss->feat->model);\n\t\t\tif (r)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tcase OMAP_DISPLAY_TYPE_SDI:\n\t\t\tr = sdi_init_port(dss, pdev, port);\n\t\t\tif (r)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tof_node_put(port);\n\t}\n\n\treturn 0;\n\nerror:\n\tof_node_put(port);\n\t__dss_uninit_ports(dss, i);\n\treturn r;\n}\n\nstatic void dss_uninit_ports(struct dss_device *dss)\n{\n\t__dss_uninit_ports(dss, dss->feat->num_ports);\n}\n\nstatic int dss_video_pll_probe(struct dss_device *dss)\n{\n\tstruct platform_device *pdev = dss->pdev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regulator *pll_regulator;\n\tint r;\n\n\tif (!np)\n\t\treturn 0;\n\n\tif (of_property_read_bool(np, \"syscon-pll-ctrl\")) {\n\t\tdss->syscon_pll_ctrl = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\"syscon-pll-ctrl\");\n\t\tif (IS_ERR(dss->syscon_pll_ctrl)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get syscon-pll-ctrl regmap\\n\");\n\t\t\treturn PTR_ERR(dss->syscon_pll_ctrl);\n\t\t}\n\n\t\tif (of_property_read_u32_index(np, \"syscon-pll-ctrl\", 1,\n\t\t\t\t&dss->syscon_pll_ctrl_offset)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get syscon-pll-ctrl offset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpll_regulator = devm_regulator_get(&pdev->dev, \"vdda_video\");\n\tif (IS_ERR(pll_regulator)) {\n\t\tr = PTR_ERR(pll_regulator);\n\n\t\tswitch (r) {\n\t\tcase -ENOENT:\n\t\t\tpll_regulator = NULL;\n\t\t\tbreak;\n\n\t\tcase -EPROBE_DEFER:\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tdefault:\n\t\t\tDSSERR(\"can't get DPLL VDDA regulator\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (of_property_match_string(np, \"reg-names\", \"pll1\") >= 0) {\n\t\tdss->video1_pll = dss_video_pll_init(dss, pdev, 0,\n\t\t\t\t\t\t     pll_regulator);\n\t\tif (IS_ERR(dss->video1_pll))\n\t\t\treturn PTR_ERR(dss->video1_pll);\n\t}\n\n\tif (of_property_match_string(np, \"reg-names\", \"pll2\") >= 0) {\n\t\tdss->video2_pll = dss_video_pll_init(dss, pdev, 1,\n\t\t\t\t\t\t     pll_regulator);\n\t\tif (IS_ERR(dss->video2_pll)) {\n\t\t\tdss_video_pll_uninit(dss->video1_pll);\n\t\t\treturn PTR_ERR(dss->video2_pll);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id dss_of_match[] = {\n\t{ .compatible = \"ti,omap2-dss\", .data = &omap24xx_dss_feats },\n\t{ .compatible = \"ti,omap3-dss\", .data = &omap3630_dss_feats },\n\t{ .compatible = \"ti,omap4-dss\", .data = &omap44xx_dss_feats },\n\t{ .compatible = \"ti,omap5-dss\", .data = &omap54xx_dss_feats },\n\t{ .compatible = \"ti,dra7-dss\",  .data = &dra7xx_dss_feats },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dss_of_match);\n\nstatic const struct soc_device_attribute dss_soc_devices[] = {\n\t{ .machine = \"OMAP3430/3530\", .data = &omap34xx_dss_feats },\n\t{ .machine = \"AM35??\",        .data = &omap34xx_dss_feats },\n\t{ .family  = \"AM43xx\",        .data = &am43xx_dss_feats },\n\t{   }\n};\n\nstatic int dss_bind(struct device *dev)\n{\n\tstruct dss_device *dss = dev_get_drvdata(dev);\n\tstruct platform_device *drm_pdev;\n\tstruct dss_pdata pdata;\n\tint r;\n\n\tr = component_bind_all(dev, NULL);\n\tif (r)\n\t\treturn r;\n\n\tpm_set_vt_switch(0);\n\n\tpdata.dss = dss;\n\tdrm_pdev = platform_device_register_data(NULL, \"omapdrm\", 0,\n\t\t\t\t\t\t &pdata, sizeof(pdata));\n\tif (IS_ERR(drm_pdev)) {\n\t\tcomponent_unbind_all(dev, NULL);\n\t\treturn PTR_ERR(drm_pdev);\n\t}\n\n\tdss->drm_pdev = drm_pdev;\n\n\treturn 0;\n}\n\nstatic void dss_unbind(struct device *dev)\n{\n\tstruct dss_device *dss = dev_get_drvdata(dev);\n\n\tplatform_device_unregister(dss->drm_pdev);\n\n\tcomponent_unbind_all(dev, NULL);\n}\n\nstatic const struct component_master_ops dss_component_ops = {\n\t.bind = dss_bind,\n\t.unbind = dss_unbind,\n};\n\nstruct dss_component_match_data {\n\tstruct device *dev;\n\tstruct component_match **match;\n};\n\nstatic int dss_add_child_component(struct device *dev, void *data)\n{\n\tstruct dss_component_match_data *cmatch = data;\n\tstruct component_match **match = cmatch->match;\n\n\t \n\tif (strstr(dev_name(dev), \"rfbi\"))\n\t\treturn 0;\n\n\t \n\tif (strstr(dev_name(dev), \"target-module\"))\n\t\treturn device_for_each_child(dev, cmatch,\n\t\t\t\t\t     dss_add_child_component);\n\n\tcomponent_match_add(cmatch->dev, match, component_compare_dev, dev);\n\n\treturn 0;\n}\n\nstatic int dss_probe_hardware(struct dss_device *dss)\n{\n\tu32 rev;\n\tint r;\n\n\tr = dss_runtime_get(dss);\n\tif (r)\n\t\treturn r;\n\n\tdss->dss_clk_rate = clk_get_rate(dss->dss_clk);\n\n\t \n\tREG_FLD_MOD(dss, DSS_CONTROL, 0, 0, 0);\n\n\tdss_select_dispc_clk_source(dss, DSS_CLK_SRC_FCK);\n\n#ifdef CONFIG_OMAP2_DSS_VENC\n\tREG_FLD_MOD(dss, DSS_CONTROL, 1, 4, 4);\t \n\tREG_FLD_MOD(dss, DSS_CONTROL, 1, 3, 3);\t \n\tREG_FLD_MOD(dss, DSS_CONTROL, 0, 2, 2);\t \n#endif\n\tdss->dsi_clk_source[0] = DSS_CLK_SRC_FCK;\n\tdss->dsi_clk_source[1] = DSS_CLK_SRC_FCK;\n\tdss->dispc_clk_source = DSS_CLK_SRC_FCK;\n\tdss->lcd_clk_source[0] = DSS_CLK_SRC_FCK;\n\tdss->lcd_clk_source[1] = DSS_CLK_SRC_FCK;\n\n\trev = dss_read_reg(dss, DSS_REVISION);\n\tpr_info(\"OMAP DSS rev %d.%d\\n\", FLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\n\n\tdss_runtime_put(dss);\n\n\treturn 0;\n}\n\nstatic int dss_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *soc;\n\tstruct dss_component_match_data cmatch;\n\tstruct component_match *match = NULL;\n\tstruct dss_device *dss;\n\tint r;\n\n\tdss = kzalloc(sizeof(*dss), GFP_KERNEL);\n\tif (!dss)\n\t\treturn -ENOMEM;\n\n\tdss->pdev = pdev;\n\tplatform_set_drvdata(pdev, dss);\n\n\tr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (r) {\n\t\tdev_err(&pdev->dev, \"Failed to set the DMA mask\\n\");\n\t\tgoto err_free_dss;\n\t}\n\n\t \n\tsoc = soc_device_match(dss_soc_devices);\n\tif (soc)\n\t\tdss->feat = soc->data;\n\telse\n\t\tdss->feat = of_match_device(dss_of_match, &pdev->dev)->data;\n\n\t \n\tdss->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dss->base)) {\n\t\tr = PTR_ERR(dss->base);\n\t\tgoto err_free_dss;\n\t}\n\n\tr = dss_get_clocks(dss);\n\tif (r)\n\t\tgoto err_free_dss;\n\n\tr = dss_setup_default_clock(dss);\n\tif (r)\n\t\tgoto err_put_clocks;\n\n\t \n\tr = dss_video_pll_probe(dss);\n\tif (r)\n\t\tgoto err_put_clocks;\n\n\tr = dss_init_ports(dss);\n\tif (r)\n\t\tgoto err_uninit_plls;\n\n\t \n\tpm_runtime_enable(&pdev->dev);\n\n\tr = dss_probe_hardware(dss);\n\tif (r)\n\t\tgoto err_pm_runtime_disable;\n\n\t \n\tr = dss_initialize_debugfs(dss);\n\tif (r)\n\t\tgoto err_pm_runtime_disable;\n\n\tdss->debugfs.clk = dss_debugfs_create_file(dss, \"clk\",\n\t\t\t\t\t\t   dss_debug_dump_clocks, dss);\n\tdss->debugfs.dss = dss_debugfs_create_file(dss, \"dss\", dss_dump_regs,\n\t\t\t\t\t\t   dss);\n\n\t \n\tr = of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\n\tif (r)\n\t\tgoto err_uninit_debugfs;\n\n\tomapdss_gather_components(&pdev->dev);\n\n\tcmatch.dev = &pdev->dev;\n\tcmatch.match = &match;\n\tdevice_for_each_child(&pdev->dev, &cmatch, dss_add_child_component);\n\n\tr = component_master_add_with_match(&pdev->dev, &dss_component_ops, match);\n\tif (r)\n\t\tgoto err_of_depopulate;\n\n\treturn 0;\n\nerr_of_depopulate:\n\tof_platform_depopulate(&pdev->dev);\n\nerr_uninit_debugfs:\n\tdss_debugfs_remove_file(dss->debugfs.clk);\n\tdss_debugfs_remove_file(dss->debugfs.dss);\n\tdss_uninitialize_debugfs(dss);\n\nerr_pm_runtime_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tdss_uninit_ports(dss);\n\nerr_uninit_plls:\n\tif (dss->video1_pll)\n\t\tdss_video_pll_uninit(dss->video1_pll);\n\tif (dss->video2_pll)\n\t\tdss_video_pll_uninit(dss->video2_pll);\n\nerr_put_clocks:\n\tdss_put_clocks(dss);\n\nerr_free_dss:\n\tkfree(dss);\n\n\treturn r;\n}\n\nstatic void dss_remove(struct platform_device *pdev)\n{\n\tstruct dss_device *dss = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(&pdev->dev);\n\n\tcomponent_master_del(&pdev->dev, &dss_component_ops);\n\n\tdss_debugfs_remove_file(dss->debugfs.clk);\n\tdss_debugfs_remove_file(dss->debugfs.dss);\n\tdss_uninitialize_debugfs(dss);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tdss_uninit_ports(dss);\n\n\tif (dss->video1_pll)\n\t\tdss_video_pll_uninit(dss->video1_pll);\n\n\tif (dss->video2_pll)\n\t\tdss_video_pll_uninit(dss->video2_pll);\n\n\tdss_put_clocks(dss);\n\n\tkfree(dss);\n}\n\nstatic void dss_shutdown(struct platform_device *pdev)\n{\n\tDSSDBG(\"shutdown\\n\");\n}\n\nstatic __maybe_unused int dss_runtime_suspend(struct device *dev)\n{\n\tstruct dss_device *dss = dev_get_drvdata(dev);\n\n\tdss_save_context(dss);\n\tdss_set_min_bus_tput(dev, 0);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int dss_runtime_resume(struct device *dev)\n{\n\tstruct dss_device *dss = dev_get_drvdata(dev);\n\tint r;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\t \n\n\tr = dss_set_min_bus_tput(dev, 1000000000);\n\tif (r)\n\t\treturn r;\n\n\tdss_restore_context(dss);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dss_pm_ops = {\n\tSET_RUNTIME_PM_OPS(dss_runtime_suspend, dss_runtime_resume, NULL)\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)\n};\n\nstruct platform_driver omap_dsshw_driver = {\n\t.probe\t\t= dss_probe,\n\t.remove_new\t= dss_remove,\n\t.shutdown\t= dss_shutdown,\n\t.driver         = {\n\t\t.name   = \"omapdss_dss\",\n\t\t.pm\t= &dss_pm_ops,\n\t\t.of_match_table = dss_of_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n};\n\n \nstatic struct platform_driver * const omap_dss_drivers[] = {\n\t&omap_dsshw_driver,\n\t&omap_dispchw_driver,\n#ifdef CONFIG_OMAP2_DSS_DSI\n\t&omap_dsihw_driver,\n#endif\n#ifdef CONFIG_OMAP2_DSS_VENC\n\t&omap_venchw_driver,\n#endif\n#ifdef CONFIG_OMAP4_DSS_HDMI\n\t&omapdss_hdmi4hw_driver,\n#endif\n#ifdef CONFIG_OMAP5_DSS_HDMI\n\t&omapdss_hdmi5hw_driver,\n#endif\n};\n\nint __init omap_dss_init(void)\n{\n\treturn platform_register_drivers(omap_dss_drivers,\n\t\t\t\t\t ARRAY_SIZE(omap_dss_drivers));\n}\n\nvoid omap_dss_exit(void)\n{\n\tplatform_unregister_drivers(omap_dss_drivers,\n\t\t\t\t    ARRAY_SIZE(omap_dss_drivers));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}