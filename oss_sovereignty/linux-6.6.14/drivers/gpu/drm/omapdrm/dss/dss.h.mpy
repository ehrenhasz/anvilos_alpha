{
  "module_name": "dss.h",
  "hash_id": "4ba7eae132ade2545365e10655d1075925e1da93168542041ee54628637c5256",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/dss.h",
  "human_readable_source": " \n \n\n#ifndef __OMAP2_DSS_H\n#define __OMAP2_DSS_H\n\n#include <linux/interrupt.h>\n\n#include \"omapdss.h\"\n\nstruct dispc_device;\nstruct dss_debugfs_entry;\nstruct platform_device;\nstruct seq_file;\n\n#define MAX_DSS_LCD_MANAGERS\t3\n#define MAX_NUM_DSI\t\t2\n\n#ifdef pr_fmt\n#undef pr_fmt\n#endif\n\n#ifdef DSS_SUBSYS_NAME\n#define pr_fmt(fmt) DSS_SUBSYS_NAME \": \" fmt\n#else\n#define pr_fmt(fmt) fmt\n#endif\n\n#define DSSDBG(format, ...) \\\n\tpr_debug(format, ## __VA_ARGS__)\n\n#ifdef DSS_SUBSYS_NAME\n#define DSSERR(format, ...) \\\n\tpr_err(\"omapdss \" DSS_SUBSYS_NAME \" error: \" format, ##__VA_ARGS__)\n#else\n#define DSSERR(format, ...) \\\n\tpr_err(\"omapdss error: \" format, ##__VA_ARGS__)\n#endif\n\n#ifdef DSS_SUBSYS_NAME\n#define DSSINFO(format, ...) \\\n\tpr_info(\"omapdss \" DSS_SUBSYS_NAME \": \" format, ##__VA_ARGS__)\n#else\n#define DSSINFO(format, ...) \\\n\tpr_info(\"omapdss: \" format, ## __VA_ARGS__)\n#endif\n\n#ifdef DSS_SUBSYS_NAME\n#define DSSWARN(format, ...) \\\n\tpr_warn(\"omapdss \" DSS_SUBSYS_NAME \": \" format, ##__VA_ARGS__)\n#else\n#define DSSWARN(format, ...) \\\n\tpr_warn(\"omapdss: \" format, ##__VA_ARGS__)\n#endif\n\n \n#define FLD_MASK(start, end)\t(((1 << ((start) - (end) + 1)) - 1) << (end))\n#define FLD_VAL(val, start, end) (((val) << (end)) & FLD_MASK(start, end))\n#define FLD_GET(val, start, end) (((val) & FLD_MASK(start, end)) >> (end))\n#define FLD_MOD(orig, val, start, end) \\\n\t(((orig) & ~FLD_MASK(start, end)) | FLD_VAL(val, start, end))\n\nenum dss_model {\n\tDSS_MODEL_OMAP2,\n\tDSS_MODEL_OMAP3,\n\tDSS_MODEL_OMAP4,\n\tDSS_MODEL_OMAP5,\n\tDSS_MODEL_DRA7,\n};\n\nenum dss_io_pad_mode {\n\tDSS_IO_PAD_MODE_RESET,\n\tDSS_IO_PAD_MODE_RFBI,\n\tDSS_IO_PAD_MODE_BYPASS,\n};\n\nenum dss_hdmi_venc_clk_source_select {\n\tDSS_VENC_TV_CLK = 0,\n\tDSS_HDMI_M_PCLK = 1,\n};\n\nenum dss_dsi_content_type {\n\tDSS_DSI_CONTENT_DCS,\n\tDSS_DSI_CONTENT_GENERIC,\n};\n\nenum dss_clk_source {\n\tDSS_CLK_SRC_FCK = 0,\n\n\tDSS_CLK_SRC_PLL1_1,\n\tDSS_CLK_SRC_PLL1_2,\n\tDSS_CLK_SRC_PLL1_3,\n\n\tDSS_CLK_SRC_PLL2_1,\n\tDSS_CLK_SRC_PLL2_2,\n\tDSS_CLK_SRC_PLL2_3,\n\n\tDSS_CLK_SRC_HDMI_PLL,\n};\n\nenum dss_pll_id {\n\tDSS_PLL_DSI1,\n\tDSS_PLL_DSI2,\n\tDSS_PLL_HDMI,\n\tDSS_PLL_VIDEO1,\n\tDSS_PLL_VIDEO2,\n};\n\nstruct dss_pll;\n\n#define DSS_PLL_MAX_HSDIVS 4\n\nenum dss_pll_type {\n\tDSS_PLL_TYPE_A,\n\tDSS_PLL_TYPE_B,\n};\n\n \nstruct dss_pll_clock_info {\n\t \n\tunsigned long fint;\n\tunsigned long clkdco;\n\tunsigned long clkout[DSS_PLL_MAX_HSDIVS];\n\n\t \n\tu16 n;\n\tu16 m;\n\tu32 mf;\n\tu16 mX[DSS_PLL_MAX_HSDIVS];\n\tu16 sd;\n};\n\nstruct dss_pll_ops {\n\tint (*enable)(struct dss_pll *pll);\n\tvoid (*disable)(struct dss_pll *pll);\n\tint (*set_config)(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\n};\n\nstruct dss_pll_hw {\n\tenum dss_pll_type type;\n\n\tunsigned int n_max;\n\tunsigned int m_min;\n\tunsigned int m_max;\n\tunsigned int mX_max;\n\n\tunsigned long fint_min, fint_max;\n\tunsigned long clkdco_min, clkdco_low, clkdco_max;\n\n\tu8 n_msb, n_lsb;\n\tu8 m_msb, m_lsb;\n\tu8 mX_msb[DSS_PLL_MAX_HSDIVS], mX_lsb[DSS_PLL_MAX_HSDIVS];\n\n\tbool has_stopmode;\n\tbool has_freqsel;\n\tbool has_selfreqdco;\n\tbool has_refsel;\n\n\t \n\tbool errata_i886;\n\n\t \n\tbool errata_i932;\n};\n\nstruct dss_pll {\n\tconst char *name;\n\tenum dss_pll_id id;\n\tstruct dss_device *dss;\n\n\tstruct clk *clkin;\n\tstruct regulator *regulator;\n\n\tvoid __iomem *base;\n\n\tconst struct dss_pll_hw *hw;\n\n\tconst struct dss_pll_ops *ops;\n\n\tstruct dss_pll_clock_info cinfo;\n};\n\n \nstruct dss_reg_field {\n\tu8 start, end;\n};\n\nstruct dispc_clock_info {\n\t \n\tunsigned long lck;\n\tunsigned long pck;\n\n\t \n\tu16 lck_div;\n\tu16 pck_div;\n};\n\nstruct dss_lcd_mgr_config {\n\tenum dss_io_pad_mode io_pad_mode;\n\n\tbool stallmode;\n\tbool fifohandcheck;\n\n\tstruct dispc_clock_info clock_info;\n\n\tint video_port_width;\n\n\tint lcden_sig_polarity;\n};\n\n#define DSS_SZ_REGS\t\t\tSZ_512\n\nstruct dss_device {\n\tstruct platform_device *pdev;\n\tvoid __iomem    *base;\n\tstruct regmap\t*syscon_pll_ctrl;\n\tu32\t\tsyscon_pll_ctrl_offset;\n\n\tstruct platform_device *drm_pdev;\n\n\tstruct clk\t*parent_clk;\n\tstruct clk\t*dss_clk;\n\tunsigned long\tdss_clk_rate;\n\n\tunsigned long\tcache_req_pck;\n\tunsigned long\tcache_prate;\n\tstruct dispc_clock_info cache_dispc_cinfo;\n\n\tenum dss_clk_source dsi_clk_source[MAX_NUM_DSI];\n\tenum dss_clk_source dispc_clk_source;\n\tenum dss_clk_source lcd_clk_source[MAX_DSS_LCD_MANAGERS];\n\n\tbool\t\tctx_valid;\n\tu32\t\tctx[DSS_SZ_REGS / sizeof(u32)];\n\n\tconst struct dss_features *feat;\n\n\tstruct {\n\t\tstruct dentry *root;\n\t\tstruct dss_debugfs_entry *clk;\n\t\tstruct dss_debugfs_entry *dss;\n\t} debugfs;\n\n\tstruct dss_pll *plls[4];\n\tstruct dss_pll\t*video1_pll;\n\tstruct dss_pll\t*video2_pll;\n\n\tstruct dispc_device *dispc;\n\tstruct omap_drm_private *mgr_ops_priv;\n};\n\n \nstatic inline int dss_set_min_bus_tput(struct device *dev, unsigned long tput)\n{\n\t \n\treturn 0;\n}\n\nstatic inline bool dss_mgr_is_lcd(enum omap_channel id)\n{\n\tif (id == OMAP_DSS_CHANNEL_LCD || id == OMAP_DSS_CHANNEL_LCD2 ||\n\t\t\tid == OMAP_DSS_CHANNEL_LCD3)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \n#if defined(CONFIG_OMAP2_DSS_DEBUGFS)\nstruct dss_debugfs_entry *\ndss_debugfs_create_file(struct dss_device *dss, const char *name,\n\t\t\tint (*show_fn)(struct seq_file *s, void *data),\n\t\t\tvoid *data);\nvoid dss_debugfs_remove_file(struct dss_debugfs_entry *entry);\n#else\nstatic inline struct dss_debugfs_entry *\ndss_debugfs_create_file(struct dss_device *dss, const char *name,\n\t\t\tint (*show_fn)(struct seq_file *s, void *data),\n\t\t\tvoid *data)\n{\n\treturn NULL;\n}\n\nstatic inline void dss_debugfs_remove_file(struct dss_debugfs_entry *entry)\n{\n}\n#endif  \n\nstruct dss_device *dss_get_device(struct device *dev);\n\nint dss_runtime_get(struct dss_device *dss);\nvoid dss_runtime_put(struct dss_device *dss);\n\nunsigned long dss_get_dispc_clk_rate(struct dss_device *dss);\nunsigned long dss_get_max_fck_rate(struct dss_device *dss);\nint dss_dpi_select_source(struct dss_device *dss, int port,\n\t\t\t  enum omap_channel channel);\nvoid dss_select_hdmi_venc_clk_source(struct dss_device *dss,\n\t\t\t\t     enum dss_hdmi_venc_clk_source_select src);\nconst char *dss_get_clk_source_name(enum dss_clk_source clk_src);\n\n \nstruct dss_pll *dss_video_pll_init(struct dss_device *dss,\n\t\t\t\t   struct platform_device *pdev, int id,\n\t\t\t\t   struct regulator *regulator);\nvoid dss_video_pll_uninit(struct dss_pll *pll);\n\nvoid dss_ctrl_pll_enable(struct dss_pll *pll, bool enable);\n\nvoid dss_sdi_init(struct dss_device *dss, int datapairs);\nint dss_sdi_enable(struct dss_device *dss);\nvoid dss_sdi_disable(struct dss_device *dss);\n\nvoid dss_select_dsi_clk_source(struct dss_device *dss, int dsi_module,\n\t\t\t       enum dss_clk_source clk_src);\nvoid dss_select_lcd_clk_source(struct dss_device *dss,\n\t\t\t       enum omap_channel channel,\n\t\t\t       enum dss_clk_source clk_src);\nenum dss_clk_source dss_get_dispc_clk_source(struct dss_device *dss);\nenum dss_clk_source dss_get_dsi_clk_source(struct dss_device *dss,\n\t\t\t\t\t   int dsi_module);\nenum dss_clk_source dss_get_lcd_clk_source(struct dss_device *dss,\n\t\t\t\t\t   enum omap_channel channel);\n\nvoid dss_set_venc_output(struct dss_device *dss, enum omap_dss_venc_type type);\nvoid dss_set_dac_pwrdn_bgz(struct dss_device *dss, bool enable);\n\nint dss_set_fck_rate(struct dss_device *dss, unsigned long rate);\n\ntypedef bool (*dss_div_calc_func)(unsigned long fck, void *data);\nbool dss_div_calc(struct dss_device *dss, unsigned long pck,\n\t\t  unsigned long fck_min, dss_div_calc_func func, void *data);\n\n \n#ifdef CONFIG_OMAP2_DSS_SDI\nint sdi_init_port(struct dss_device *dss, struct platform_device *pdev,\n\t\t  struct device_node *port);\nvoid sdi_uninit_port(struct device_node *port);\n#else\nstatic inline int sdi_init_port(struct dss_device *dss,\n\t\t\t\tstruct platform_device *pdev,\n\t\t\t\tstruct device_node *port)\n{\n\treturn 0;\n}\nstatic inline void sdi_uninit_port(struct device_node *port)\n{\n}\n#endif\n\n \n\n#ifdef CONFIG_OMAP2_DSS_DSI\n\nvoid dsi_irq_handler(void);\n\n#endif\n\n \n#ifdef CONFIG_OMAP2_DSS_DPI\nint dpi_init_port(struct dss_device *dss, struct platform_device *pdev,\n\t\t  struct device_node *port, enum dss_model dss_model);\nvoid dpi_uninit_port(struct device_node *port);\n#else\nstatic inline int dpi_init_port(struct dss_device *dss,\n\t\t\t\tstruct platform_device *pdev,\n\t\t\t\tstruct device_node *port,\n\t\t\t\tenum dss_model dss_model)\n{\n\treturn 0;\n}\nstatic inline void dpi_uninit_port(struct device_node *port)\n{\n}\n#endif\n\n \nvoid dispc_dump_clocks(struct dispc_device *dispc, struct seq_file *s);\n\nint dispc_runtime_get(struct dispc_device *dispc);\nvoid dispc_runtime_put(struct dispc_device *dispc);\n\nint dispc_get_num_ovls(struct dispc_device *dispc);\nint dispc_get_num_mgrs(struct dispc_device *dispc);\n\nconst u32 *dispc_ovl_get_color_modes(struct dispc_device *dispc,\n\t\t\t\t\t    enum omap_plane_id plane);\n\nvoid dispc_ovl_get_max_size(struct dispc_device *dispc, u16 *width, u16 *height);\nbool dispc_ovl_color_mode_supported(struct dispc_device *dispc,\n\t\t\t\t    enum omap_plane_id plane, u32 fourcc);\nenum omap_overlay_caps dispc_ovl_get_caps(struct dispc_device *dispc, enum omap_plane_id plane);\n\nu32 dispc_read_irqstatus(struct dispc_device *dispc);\nvoid dispc_clear_irqstatus(struct dispc_device *dispc, u32 mask);\nvoid dispc_write_irqenable(struct dispc_device *dispc, u32 mask);\n\nint dispc_request_irq(struct dispc_device *dispc, irq_handler_t handler,\n\t\t\t     void *dev_id);\nvoid dispc_free_irq(struct dispc_device *dispc, void *dev_id);\n\nu32 dispc_mgr_get_vsync_irq(struct dispc_device *dispc,\n\t\t\t\t   enum omap_channel channel);\nu32 dispc_mgr_get_framedone_irq(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel);\nu32 dispc_mgr_get_sync_lost_irq(struct dispc_device *dispc,\n\t\t\t\t       enum omap_channel channel);\nu32 dispc_wb_get_framedone_irq(struct dispc_device *dispc);\n\nu32 dispc_get_memory_bandwidth_limit(struct dispc_device *dispc);\n\nvoid dispc_mgr_enable(struct dispc_device *dispc,\n\t\t\t     enum omap_channel channel, bool enable);\n\nbool dispc_mgr_go_busy(struct dispc_device *dispc,\n\t\t\t      enum omap_channel channel);\n\nvoid dispc_mgr_go(struct dispc_device *dispc, enum omap_channel channel);\n\nvoid dispc_mgr_set_lcd_config(struct dispc_device *dispc,\n\t\t\t\t     enum omap_channel channel,\n\t\t\t\t     const struct dss_lcd_mgr_config *config);\nvoid dispc_mgr_set_timings(struct dispc_device *dispc,\n\t\t\t\t  enum omap_channel channel,\n\t\t\t\t  const struct videomode *vm);\nvoid dispc_mgr_setup(struct dispc_device *dispc,\n\t\t\t    enum omap_channel channel,\n\t\t\t    const struct omap_overlay_manager_info *info);\n\nint dispc_mgr_check_timings(struct dispc_device *dispc,\n\t\t\t\t   enum omap_channel channel,\n\t\t\t\t   const struct videomode *vm);\n\nu32 dispc_mgr_gamma_size(struct dispc_device *dispc,\n\t\t\t\tenum omap_channel channel);\nvoid dispc_mgr_set_gamma(struct dispc_device *dispc,\n\t\t\t\tenum omap_channel channel,\n\t\t\t\tconst struct drm_color_lut *lut,\n\t\t\t\tunsigned int length);\n\nint dispc_ovl_setup(struct dispc_device *dispc,\n\t\t\t   enum omap_plane_id plane,\n\t\t\t   const struct omap_overlay_info *oi,\n\t\t\t   const struct videomode *vm, bool mem_to_mem,\n\t\t\t   enum omap_channel channel);\n\nint dispc_ovl_enable(struct dispc_device *dispc,\n\t\t\t    enum omap_plane_id plane, bool enable);\n\nbool dispc_has_writeback(struct dispc_device *dispc);\nint dispc_wb_setup(struct dispc_device *dispc,\n\t\t   const struct omap_dss_writeback_info *wi,\n\t\t   bool mem_to_mem, const struct videomode *vm,\n\t\t   enum dss_writeback_channel channel_in);\nbool dispc_wb_go_busy(struct dispc_device *dispc);\nvoid dispc_wb_go(struct dispc_device *dispc);\n\nvoid dispc_enable_sidle(struct dispc_device *dispc);\nvoid dispc_disable_sidle(struct dispc_device *dispc);\n\nvoid dispc_lcd_enable_signal(struct dispc_device *dispc, bool enable);\nvoid dispc_pck_free_enable(struct dispc_device *dispc, bool enable);\nvoid dispc_enable_fifomerge(struct dispc_device *dispc, bool enable);\n\ntypedef bool (*dispc_div_calc_func)(int lckd, int pckd, unsigned long lck,\n\t\tunsigned long pck, void *data);\nbool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n\t\t    unsigned long pck_min, unsigned long pck_max,\n\t\t    dispc_div_calc_func func, void *data);\n\nint dispc_calc_clock_rates(struct dispc_device *dispc,\n\t\t\t   unsigned long dispc_fclk_rate,\n\t\t\t   struct dispc_clock_info *cinfo);\n\n\nvoid dispc_ovl_set_fifo_threshold(struct dispc_device *dispc,\n\t\t\t\t  enum omap_plane_id plane, u32 low, u32 high);\nvoid dispc_ovl_compute_fifo_thresholds(struct dispc_device *dispc,\n\t\t\t\t       enum omap_plane_id plane,\n\t\t\t\t       u32 *fifo_low, u32 *fifo_high,\n\t\t\t\t       bool use_fifomerge, bool manual_update);\n\nvoid dispc_mgr_set_clock_div(struct dispc_device *dispc,\n\t\t\t     enum omap_channel channel,\n\t\t\t     const struct dispc_clock_info *cinfo);\nint dispc_mgr_get_clock_div(struct dispc_device *dispc,\n\t\t\t    enum omap_channel channel,\n\t\t\t    struct dispc_clock_info *cinfo);\nvoid dispc_set_tv_pclk(struct dispc_device *dispc, unsigned long pclk);\n\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\nstatic inline void dss_collect_irq_stats(u32 irqstatus, unsigned int *irq_arr)\n{\n\tint b;\n\tfor (b = 0; b < 32; ++b) {\n\t\tif (irqstatus & (1 << b))\n\t\t\tirq_arr[b]++;\n\t}\n}\n#endif\n\n \ntypedef bool (*dss_pll_calc_func)(int n, int m, unsigned long fint,\n\t\tunsigned long clkdco, void *data);\ntypedef bool (*dss_hsdiv_calc_func)(int m_dispc, unsigned long dispc,\n\t\tvoid *data);\n\nint dss_pll_register(struct dss_device *dss, struct dss_pll *pll);\nvoid dss_pll_unregister(struct dss_pll *pll);\nstruct dss_pll *dss_pll_find(struct dss_device *dss, const char *name);\nstruct dss_pll *dss_pll_find_by_src(struct dss_device *dss,\n\t\t\t\t    enum dss_clk_source src);\nunsigned int dss_pll_get_clkout_idx_for_src(enum dss_clk_source src);\nint dss_pll_enable(struct dss_pll *pll);\nvoid dss_pll_disable(struct dss_pll *pll);\nint dss_pll_set_config(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\n\nbool dss_pll_hsdiv_calc_a(const struct dss_pll *pll, unsigned long clkdco,\n\t\tunsigned long out_min, unsigned long out_max,\n\t\tdss_hsdiv_calc_func func, void *data);\nbool dss_pll_calc_a(const struct dss_pll *pll, unsigned long clkin,\n\t\tunsigned long pll_min, unsigned long pll_max,\n\t\tdss_pll_calc_func func, void *data);\n\nbool dss_pll_calc_b(const struct dss_pll *pll, unsigned long clkin,\n\tunsigned long target_clkout, struct dss_pll_clock_info *cinfo);\n\nint dss_pll_write_config_type_a(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\nint dss_pll_write_config_type_b(struct dss_pll *pll,\n\t\tconst struct dss_pll_clock_info *cinfo);\nint dss_pll_wait_reset_done(struct dss_pll *pll);\n\nextern struct platform_driver omap_dsshw_driver;\nextern struct platform_driver omap_dispchw_driver;\n#ifdef CONFIG_OMAP2_DSS_DSI\nextern struct platform_driver omap_dsihw_driver;\n#endif\n#ifdef CONFIG_OMAP2_DSS_VENC\nextern struct platform_driver omap_venchw_driver;\n#endif\n#ifdef CONFIG_OMAP4_DSS_HDMI\nextern struct platform_driver omapdss_hdmi4hw_driver;\n#endif\n#ifdef CONFIG_OMAP5_DSS_HDMI\nextern struct platform_driver omapdss_hdmi5hw_driver;\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}