{
  "module_name": "hdmi4_core.c",
  "hash_id": "113c35c3a982966ba5b6c459f4e81eb9d7a53886f23cfc95520d01e5d1e15897",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/hdmi4_core.c",
  "human_readable_source": "\n \n\n#define DSS_SUBSYS_NAME \"HDMICORE\"\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/sys_soc.h>\n#include <sound/asound.h>\n#include <sound/asoundef.h>\n\n#include \"hdmi4_core.h\"\n\n#define HDMI_CORE_AV\t\t0x500\n\nstatic inline void __iomem *hdmi_av_base(struct hdmi_core_data *core)\n{\n\treturn core->base + HDMI_CORE_AV;\n}\n\nint hdmi4_core_ddc_init(struct hdmi_core_data *core)\n{\n\tvoid __iomem *base = core->base;\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_AV_DPD, 0x7, 2, 0);\n\n\t \n\tif (REG_GET(base, HDMI_CORE_DDC_STATUS, 4, 4) == 1) {\n\t\t \n\t\tREG_FLD_MOD(base, HDMI_CORE_DDC_CMD, 0xf, 3, 0);\n\t\t \n\t\tif (hdmi_wait_for_bit_change(base, HDMI_CORE_DDC_STATUS,\n\t\t\t\t\t4, 4, 0) != 0) {\n\t\t\tDSSERR(\"Timeout aborting DDC transaction\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_DDC_CMD, 0xA, 3, 0);\n\n\t \n\tif (hdmi_wait_for_bit_change(base, HDMI_CORE_DDC_STATUS,\n\t\t\t\t4, 4, 0) != 0) {\n\t\tDSSERR(\"Timeout starting SCL clock\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_DDC_CMD, 0x9, 3, 0);\n\n\t \n\tif (hdmi_wait_for_bit_change(base, HDMI_CORE_DDC_STATUS,\n\t\t\t\t4, 4, 0) != 0) {\n\t\tDSSERR(\"Timeout clearing DDC fifo\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint hdmi4_core_ddc_read(void *data, u8 *buf, unsigned int block, size_t len)\n{\n\tstruct hdmi_core_data *core = data;\n\tvoid __iomem *base = core->base;\n\tu32 i;\n\n\t \n\tif (hdmi_wait_for_bit_change(base, HDMI_CORE_DDC_STATUS,\n\t\t\t\t4, 4, 0) != 0) {\n\t\tDSSERR(\"Timeout waiting DDC to be ready\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_DDC_SEGM, block / 2, 7, 0);\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_DDC_ADDR, 0xA0 >> 1, 7, 1);\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_DDC_OFFSET, block % 2 ? 0x80 : 0, 7, 0);\n\n\t \n\tREG_FLD_MOD(base, HDMI_CORE_DDC_COUNT1, len, 7, 0);\n\tREG_FLD_MOD(base, HDMI_CORE_DDC_COUNT2, 0x0, 1, 0);\n\n\t \n\tif (block)\n\t\tREG_FLD_MOD(base, HDMI_CORE_DDC_CMD, 0x4, 3, 0);\n\telse\n\t\tREG_FLD_MOD(base, HDMI_CORE_DDC_CMD, 0x2, 3, 0);\n\n\t \n\tif (REG_GET(base, HDMI_CORE_DDC_STATUS, 6, 6) == 1) {\n\t\tDSSERR(\"I2C Bus Low?\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tif (REG_GET(base, HDMI_CORE_DDC_STATUS, 5, 5) == 1) {\n\t\tDSSERR(\"I2C No Ack\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfor (i = 0; i < len; ++i) {\n\t\tint t;\n\n\t\t \n\t\tif (REG_GET(base, HDMI_CORE_DDC_STATUS, 4, 4) == 0) {\n\t\t\tDSSERR(\"operation stopped when reading edid\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tt = 0;\n\t\t \n\t\twhile (REG_GET(base, HDMI_CORE_DDC_STATUS, 2, 2) == 1) {\n\t\t\tif (t++ > 10000) {\n\t\t\t\tDSSERR(\"timeout reading edid\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\n\t\tbuf[i] = REG_GET(base, HDMI_CORE_DDC_DATA, 7, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic void hdmi_core_init(struct hdmi_core_video_config *video_cfg)\n{\n\tDSSDBG(\"Enter hdmi_core_init\\n\");\n\n\t \n\tvideo_cfg->ip_bus_width = HDMI_INPUT_8BIT;\n\tvideo_cfg->op_dither_truc = HDMI_OUTPUTTRUNCATION_8BIT;\n\tvideo_cfg->deep_color_pkt = HDMI_DEEPCOLORPACKECTDISABLE;\n\tvideo_cfg->pkt_mode = HDMI_PACKETMODERESERVEDVALUE;\n\tvideo_cfg->hdmi_dvi = HDMI_DVI;\n\tvideo_cfg->tclk_sel_clkmult = HDMI_FPLL10IDCK;\n}\n\nvoid hdmi4_core_powerdown_disable(struct hdmi_core_data *core)\n{\n\tDSSDBG(\"Enter hdmi4_core_powerdown_disable\\n\");\n\tREG_FLD_MOD(core->base, HDMI_CORE_SYS_SYS_CTRL1, 0x1, 0, 0);\n}\n\nstatic void hdmi_core_swreset_release(struct hdmi_core_data *core)\n{\n\tDSSDBG(\"Enter hdmi_core_swreset_release\\n\");\n\tREG_FLD_MOD(core->base, HDMI_CORE_SYS_SRST, 0x0, 0, 0);\n}\n\nstatic void hdmi_core_swreset_assert(struct hdmi_core_data *core)\n{\n\tDSSDBG(\"Enter hdmi_core_swreset_assert\\n\");\n\tREG_FLD_MOD(core->base, HDMI_CORE_SYS_SRST, 0x1, 0, 0);\n}\n\n \nstatic void hdmi_core_video_config(struct hdmi_core_data *core,\n\t\t\t\tstruct hdmi_core_video_config *cfg)\n{\n\tu32 r = 0;\n\tvoid __iomem *core_sys_base = core->base;\n\tvoid __iomem *core_av_base = hdmi_av_base(core);\n\n\t \n\tr = hdmi_read_reg(core_sys_base, HDMI_CORE_SYS_SYS_CTRL1);\n\tr = FLD_MOD(r, HDMI_CORE_SYS_SYS_CTRL1_VEN_FOLLOWVSYNC, 5, 5);\n\tr = FLD_MOD(r, HDMI_CORE_SYS_SYS_CTRL1_HEN_FOLLOWHSYNC, 4, 4);\n\tr = FLD_MOD(r, HDMI_CORE_SYS_SYS_CTRL1_BSEL_24BITBUS, 2, 2);\n\tr = FLD_MOD(r, HDMI_CORE_SYS_SYS_CTRL1_EDGE_RISINGEDGE, 1, 1);\n\thdmi_write_reg(core_sys_base, HDMI_CORE_SYS_SYS_CTRL1, r);\n\n\tREG_FLD_MOD(core_sys_base,\n\t\t\tHDMI_CORE_SYS_VID_ACEN, cfg->ip_bus_width, 7, 6);\n\n\t \n\tr = hdmi_read_reg(core_sys_base, HDMI_CORE_SYS_VID_MODE);\n\n\t \n\tif (cfg->op_dither_truc > HDMI_OUTPUTTRUNCATION_12BIT) {\n\t\tr = FLD_MOD(r, cfg->op_dither_truc - 3, 7, 6);\n\t\tr = FLD_MOD(r, 1, 5, 5);\n\t} else {\n\t\tr = FLD_MOD(r, cfg->op_dither_truc, 7, 6);\n\t\tr = FLD_MOD(r, 0, 5, 5);\n\t}\n\thdmi_write_reg(core_sys_base, HDMI_CORE_SYS_VID_MODE, r);\n\n\t \n\tr = hdmi_read_reg(core_av_base, HDMI_CORE_AV_HDMI_CTRL);\n\tr = FLD_MOD(r, cfg->deep_color_pkt, 6, 6);\n\tr = FLD_MOD(r, cfg->pkt_mode, 5, 3);\n\tr = FLD_MOD(r, cfg->hdmi_dvi, 0, 0);\n\thdmi_write_reg(core_av_base, HDMI_CORE_AV_HDMI_CTRL, r);\n\n\t \n\tREG_FLD_MOD(core_sys_base,\n\t\t\tHDMI_CORE_SYS_TMDS_CTRL, cfg->tclk_sel_clkmult, 6, 5);\n}\n\nstatic void hdmi_core_write_avi_infoframe(struct hdmi_core_data *core,\n\tstruct hdmi_avi_infoframe *frame)\n{\n\tvoid __iomem *av_base = hdmi_av_base(core);\n\tu8 data[HDMI_INFOFRAME_SIZE(AVI)];\n\tint i;\n\n\thdmi_avi_infoframe_pack(frame, data, sizeof(data));\n\n\tprint_hex_dump_debug(\"AVI: \", DUMP_PREFIX_NONE, 16, 1, data,\n\t\tHDMI_INFOFRAME_SIZE(AVI), false);\n\n\tfor (i = 0; i < sizeof(data); ++i) {\n\t\thdmi_write_reg(av_base, HDMI_CORE_AV_AVI_BASE + i * 4,\n\t\t\tdata[i]);\n\t}\n}\n\nstatic void hdmi_core_av_packet_config(struct hdmi_core_data *core,\n\t\tstruct hdmi_core_packet_enable_repeat repeat_cfg)\n{\n\t \n\thdmi_write_reg(hdmi_av_base(core), HDMI_CORE_AV_PB_CTRL1,\n\t\t(repeat_cfg.audio_pkt << 5) |\n\t\t(repeat_cfg.audio_pkt_repeat << 4) |\n\t\t(repeat_cfg.avi_infoframe << 1) |\n\t\t(repeat_cfg.avi_infoframe_repeat));\n\n\t \n\thdmi_write_reg(hdmi_av_base(core), HDMI_CORE_AV_PB_CTRL2,\n\t\t(repeat_cfg.gen_cntrl_pkt << 3) |\n\t\t(repeat_cfg.gen_cntrl_pkt_repeat << 2) |\n\t\t(repeat_cfg.generic_pkt << 1) |\n\t\t(repeat_cfg.generic_pkt_repeat));\n}\n\nvoid hdmi4_configure(struct hdmi_core_data *core,\n\tstruct hdmi_wp_data *wp, struct hdmi_config *cfg)\n{\n\t \n\tstruct videomode vm;\n\tstruct hdmi_video_format video_format;\n\t \n\tstruct hdmi_core_video_config v_core_cfg;\n\tstruct hdmi_core_packet_enable_repeat repeat_cfg = { 0 };\n\n\thdmi_core_init(&v_core_cfg);\n\n\thdmi_wp_init_vid_fmt_timings(&video_format, &vm, cfg);\n\n\thdmi_wp_video_config_timing(wp, &vm);\n\n\t \n\tvideo_format.packing_mode = HDMI_PACK_24b_RGB_YUV444_YUV422;\n\n\thdmi_wp_video_config_format(wp, &video_format);\n\n\thdmi_wp_video_config_interface(wp, &vm);\n\n\t \n\thdmi_core_swreset_assert(core);\n\n\tv_core_cfg.pkt_mode = HDMI_PACKETMODE24BITPERPIXEL;\n\tv_core_cfg.hdmi_dvi = cfg->hdmi_dvi_mode;\n\n\thdmi_core_video_config(core, &v_core_cfg);\n\n\t \n\thdmi_core_swreset_release(core);\n\n\tif (cfg->hdmi_dvi_mode == HDMI_HDMI) {\n\t\thdmi_core_write_avi_infoframe(core, &cfg->infoframe);\n\n\t\t \n\t\trepeat_cfg.avi_infoframe = HDMI_PACKETENABLE;\n\t\trepeat_cfg.avi_infoframe_repeat = HDMI_PACKETREPEATON;\n\t\t \n\t\trepeat_cfg.audio_pkt = HDMI_PACKETENABLE;\n\t\trepeat_cfg.audio_pkt_repeat = HDMI_PACKETREPEATON;\n\t}\n\n\thdmi_core_av_packet_config(core, repeat_cfg);\n}\n\nvoid hdmi4_core_dump(struct hdmi_core_data *core, struct seq_file *s)\n{\n\tint i;\n\n#define CORE_REG(i, name) name(i)\n#define DUMPCORE(r) seq_printf(s, \"%-35s %08x\\n\", #r,\\\n\t\thdmi_read_reg(core->base, r))\n#define DUMPCOREAV(r) seq_printf(s, \"%-35s %08x\\n\", #r,\\\n\t\thdmi_read_reg(hdmi_av_base(core), r))\n#define DUMPCOREAV2(i, r) seq_printf(s, \"%s[%d]%*s %08x\\n\", #r, i, \\\n\t\t(i < 10) ? 32 - (int)strlen(#r) : 31 - (int)strlen(#r), \" \", \\\n\t\thdmi_read_reg(hdmi_av_base(core), CORE_REG(i, r)))\n\n\tDUMPCORE(HDMI_CORE_SYS_VND_IDL);\n\tDUMPCORE(HDMI_CORE_SYS_DEV_IDL);\n\tDUMPCORE(HDMI_CORE_SYS_DEV_IDH);\n\tDUMPCORE(HDMI_CORE_SYS_DEV_REV);\n\tDUMPCORE(HDMI_CORE_SYS_SRST);\n\tDUMPCORE(HDMI_CORE_SYS_SYS_CTRL1);\n\tDUMPCORE(HDMI_CORE_SYS_SYS_STAT);\n\tDUMPCORE(HDMI_CORE_SYS_SYS_CTRL3);\n\tDUMPCORE(HDMI_CORE_SYS_DE_DLY);\n\tDUMPCORE(HDMI_CORE_SYS_DE_CTRL);\n\tDUMPCORE(HDMI_CORE_SYS_DE_TOP);\n\tDUMPCORE(HDMI_CORE_SYS_DE_CNTL);\n\tDUMPCORE(HDMI_CORE_SYS_DE_CNTH);\n\tDUMPCORE(HDMI_CORE_SYS_DE_LINL);\n\tDUMPCORE(HDMI_CORE_SYS_DE_LINH_1);\n\tDUMPCORE(HDMI_CORE_SYS_HRES_L);\n\tDUMPCORE(HDMI_CORE_SYS_HRES_H);\n\tDUMPCORE(HDMI_CORE_SYS_VRES_L);\n\tDUMPCORE(HDMI_CORE_SYS_VRES_H);\n\tDUMPCORE(HDMI_CORE_SYS_IADJUST);\n\tDUMPCORE(HDMI_CORE_SYS_POLDETECT);\n\tDUMPCORE(HDMI_CORE_SYS_HWIDTH1);\n\tDUMPCORE(HDMI_CORE_SYS_HWIDTH2);\n\tDUMPCORE(HDMI_CORE_SYS_VWIDTH);\n\tDUMPCORE(HDMI_CORE_SYS_VID_CTRL);\n\tDUMPCORE(HDMI_CORE_SYS_VID_ACEN);\n\tDUMPCORE(HDMI_CORE_SYS_VID_MODE);\n\tDUMPCORE(HDMI_CORE_SYS_VID_BLANK1);\n\tDUMPCORE(HDMI_CORE_SYS_VID_BLANK3);\n\tDUMPCORE(HDMI_CORE_SYS_VID_BLANK1);\n\tDUMPCORE(HDMI_CORE_SYS_DC_HEADER);\n\tDUMPCORE(HDMI_CORE_SYS_VID_DITHER);\n\tDUMPCORE(HDMI_CORE_SYS_RGB2XVYCC_CT);\n\tDUMPCORE(HDMI_CORE_SYS_R2Y_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_R2Y_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_G2Y_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_G2Y_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_B2Y_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_B2Y_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_R2CB_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_R2CB_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_G2CB_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_G2CB_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_B2CB_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_B2CB_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_R2CR_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_R2CR_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_G2CR_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_G2CR_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_B2CR_COEFF_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_B2CR_COEFF_UP);\n\tDUMPCORE(HDMI_CORE_SYS_RGB_OFFSET_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_RGB_OFFSET_UP);\n\tDUMPCORE(HDMI_CORE_SYS_Y_OFFSET_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_Y_OFFSET_UP);\n\tDUMPCORE(HDMI_CORE_SYS_CBCR_OFFSET_LOW);\n\tDUMPCORE(HDMI_CORE_SYS_CBCR_OFFSET_UP);\n\tDUMPCORE(HDMI_CORE_SYS_INTR_STATE);\n\tDUMPCORE(HDMI_CORE_SYS_INTR1);\n\tDUMPCORE(HDMI_CORE_SYS_INTR2);\n\tDUMPCORE(HDMI_CORE_SYS_INTR3);\n\tDUMPCORE(HDMI_CORE_SYS_INTR4);\n\tDUMPCORE(HDMI_CORE_SYS_INTR_UNMASK1);\n\tDUMPCORE(HDMI_CORE_SYS_INTR_UNMASK2);\n\tDUMPCORE(HDMI_CORE_SYS_INTR_UNMASK3);\n\tDUMPCORE(HDMI_CORE_SYS_INTR_UNMASK4);\n\tDUMPCORE(HDMI_CORE_SYS_INTR_CTRL);\n\tDUMPCORE(HDMI_CORE_SYS_TMDS_CTRL);\n\n\tDUMPCORE(HDMI_CORE_DDC_ADDR);\n\tDUMPCORE(HDMI_CORE_DDC_SEGM);\n\tDUMPCORE(HDMI_CORE_DDC_OFFSET);\n\tDUMPCORE(HDMI_CORE_DDC_COUNT1);\n\tDUMPCORE(HDMI_CORE_DDC_COUNT2);\n\tDUMPCORE(HDMI_CORE_DDC_STATUS);\n\tDUMPCORE(HDMI_CORE_DDC_CMD);\n\tDUMPCORE(HDMI_CORE_DDC_DATA);\n\n\tDUMPCOREAV(HDMI_CORE_AV_ACR_CTRL);\n\tDUMPCOREAV(HDMI_CORE_AV_FREQ_SVAL);\n\tDUMPCOREAV(HDMI_CORE_AV_N_SVAL1);\n\tDUMPCOREAV(HDMI_CORE_AV_N_SVAL2);\n\tDUMPCOREAV(HDMI_CORE_AV_N_SVAL3);\n\tDUMPCOREAV(HDMI_CORE_AV_CTS_SVAL1);\n\tDUMPCOREAV(HDMI_CORE_AV_CTS_SVAL2);\n\tDUMPCOREAV(HDMI_CORE_AV_CTS_SVAL3);\n\tDUMPCOREAV(HDMI_CORE_AV_CTS_HVAL1);\n\tDUMPCOREAV(HDMI_CORE_AV_CTS_HVAL2);\n\tDUMPCOREAV(HDMI_CORE_AV_CTS_HVAL3);\n\tDUMPCOREAV(HDMI_CORE_AV_AUD_MODE);\n\tDUMPCOREAV(HDMI_CORE_AV_SPDIF_CTRL);\n\tDUMPCOREAV(HDMI_CORE_AV_HW_SPDIF_FS);\n\tDUMPCOREAV(HDMI_CORE_AV_SWAP_I2S);\n\tDUMPCOREAV(HDMI_CORE_AV_SPDIF_ERTH);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_IN_MAP);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_IN_CTRL);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_CHST0);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_CHST1);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_CHST2);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_CHST4);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_CHST5);\n\tDUMPCOREAV(HDMI_CORE_AV_ASRC);\n\tDUMPCOREAV(HDMI_CORE_AV_I2S_IN_LEN);\n\tDUMPCOREAV(HDMI_CORE_AV_HDMI_CTRL);\n\tDUMPCOREAV(HDMI_CORE_AV_AUDO_TXSTAT);\n\tDUMPCOREAV(HDMI_CORE_AV_AUD_PAR_BUSCLK_1);\n\tDUMPCOREAV(HDMI_CORE_AV_AUD_PAR_BUSCLK_2);\n\tDUMPCOREAV(HDMI_CORE_AV_AUD_PAR_BUSCLK_3);\n\tDUMPCOREAV(HDMI_CORE_AV_TEST_TXCTRL);\n\tDUMPCOREAV(HDMI_CORE_AV_DPD);\n\tDUMPCOREAV(HDMI_CORE_AV_PB_CTRL1);\n\tDUMPCOREAV(HDMI_CORE_AV_PB_CTRL2);\n\tDUMPCOREAV(HDMI_CORE_AV_AVI_TYPE);\n\tDUMPCOREAV(HDMI_CORE_AV_AVI_VERS);\n\tDUMPCOREAV(HDMI_CORE_AV_AVI_LEN);\n\tDUMPCOREAV(HDMI_CORE_AV_AVI_CHSUM);\n\n\tfor (i = 0; i < HDMI_CORE_AV_AVI_DBYTE_NELEMS; i++)\n\t\tDUMPCOREAV2(i, HDMI_CORE_AV_AVI_DBYTE);\n\n\tDUMPCOREAV(HDMI_CORE_AV_SPD_TYPE);\n\tDUMPCOREAV(HDMI_CORE_AV_SPD_VERS);\n\tDUMPCOREAV(HDMI_CORE_AV_SPD_LEN);\n\tDUMPCOREAV(HDMI_CORE_AV_SPD_CHSUM);\n\n\tfor (i = 0; i < HDMI_CORE_AV_SPD_DBYTE_NELEMS; i++)\n\t\tDUMPCOREAV2(i, HDMI_CORE_AV_SPD_DBYTE);\n\n\tDUMPCOREAV(HDMI_CORE_AV_AUDIO_TYPE);\n\tDUMPCOREAV(HDMI_CORE_AV_AUDIO_VERS);\n\tDUMPCOREAV(HDMI_CORE_AV_AUDIO_LEN);\n\tDUMPCOREAV(HDMI_CORE_AV_AUDIO_CHSUM);\n\n\tfor (i = 0; i < HDMI_CORE_AV_AUD_DBYTE_NELEMS; i++)\n\t\tDUMPCOREAV2(i, HDMI_CORE_AV_AUD_DBYTE);\n\n\tDUMPCOREAV(HDMI_CORE_AV_MPEG_TYPE);\n\tDUMPCOREAV(HDMI_CORE_AV_MPEG_VERS);\n\tDUMPCOREAV(HDMI_CORE_AV_MPEG_LEN);\n\tDUMPCOREAV(HDMI_CORE_AV_MPEG_CHSUM);\n\n\tfor (i = 0; i < HDMI_CORE_AV_MPEG_DBYTE_NELEMS; i++)\n\t\tDUMPCOREAV2(i, HDMI_CORE_AV_MPEG_DBYTE);\n\n\tfor (i = 0; i < HDMI_CORE_AV_GEN_DBYTE_NELEMS; i++)\n\t\tDUMPCOREAV2(i, HDMI_CORE_AV_GEN_DBYTE);\n\n\tDUMPCOREAV(HDMI_CORE_AV_CP_BYTE1);\n\n\tfor (i = 0; i < HDMI_CORE_AV_GEN2_DBYTE_NELEMS; i++)\n\t\tDUMPCOREAV2(i, HDMI_CORE_AV_GEN2_DBYTE);\n\n\tDUMPCOREAV(HDMI_CORE_AV_CEC_ADDR_ID);\n}\n\nstatic void hdmi_core_audio_config(struct hdmi_core_data *core,\n\t\t\t\t\tstruct hdmi_core_audio_config *cfg)\n{\n\tu32 r;\n\tvoid __iomem *av_base = hdmi_av_base(core);\n\n\t \n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_N_SVAL1, cfg->n, 7, 0);\n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_N_SVAL2, cfg->n >> 8, 7, 0);\n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_N_SVAL3, cfg->n >> 16, 7, 0);\n\n\tif (cfg->cts_mode == HDMI_AUDIO_CTS_MODE_SW) {\n\t\tREG_FLD_MOD(av_base, HDMI_CORE_AV_CTS_SVAL1, cfg->cts, 7, 0);\n\t\tREG_FLD_MOD(av_base,\n\t\t\t\tHDMI_CORE_AV_CTS_SVAL2, cfg->cts >> 8, 7, 0);\n\t\tREG_FLD_MOD(av_base,\n\t\t\t\tHDMI_CORE_AV_CTS_SVAL3, cfg->cts >> 16, 7, 0);\n\t} else {\n\t\tREG_FLD_MOD(av_base, HDMI_CORE_AV_AUD_PAR_BUSCLK_1,\n\t\t\t\tcfg->aud_par_busclk, 7, 0);\n\t\tREG_FLD_MOD(av_base, HDMI_CORE_AV_AUD_PAR_BUSCLK_2,\n\t\t\t\t(cfg->aud_par_busclk >> 8), 7, 0);\n\t\tREG_FLD_MOD(av_base, HDMI_CORE_AV_AUD_PAR_BUSCLK_3,\n\t\t\t\t(cfg->aud_par_busclk >> 16), 7, 0);\n\t}\n\n\t \n\tif (cfg->use_mclk)\n\t\tREG_FLD_MOD(av_base, HDMI_CORE_AV_FREQ_SVAL,\n\t\t\t    cfg->mclk_mode, 2, 0);\n\n\tr = hdmi_read_reg(av_base, HDMI_CORE_AV_ACR_CTRL);\n\t \n\tr = FLD_MOD(r, 0, 2, 2);\n\n\tr = FLD_MOD(r, cfg->en_acr_pkt, 1, 1);\n\tr = FLD_MOD(r, cfg->cts_mode, 0, 0);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_ACR_CTRL, r);\n\n\t \n\tif (cfg->use_mclk)\n\t\tREG_FLD_MOD(av_base, HDMI_CORE_AV_ACR_CTRL, 1, 2, 2);\n\n\t \n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_SPDIF_CTRL,\n\t\t\t\t\t\tcfg->fs_override, 1, 1);\n\n\t \n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_CHST0,\n\t\t       cfg->iec60958_cfg->status[0]);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_CHST1,\n\t\t       cfg->iec60958_cfg->status[1]);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_CHST2,\n\t\t       cfg->iec60958_cfg->status[2]);\n\t \n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_CHST4,\n\t\t       cfg->iec60958_cfg->status[3]);\n\t \n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_CHST5,\n\t\t       cfg->iec60958_cfg->status[4]);\n\n\t \n\tr = hdmi_read_reg(av_base, HDMI_CORE_AV_I2S_IN_CTRL);\n\tr = FLD_MOD(r, cfg->i2s_cfg.sck_edge_mode, 6, 6);\n\tr = FLD_MOD(r, cfg->i2s_cfg.vbit, 4, 4);\n\tr = FLD_MOD(r, cfg->i2s_cfg.justification, 2, 2);\n\tr = FLD_MOD(r, cfg->i2s_cfg.direction, 1, 1);\n\tr = FLD_MOD(r, cfg->i2s_cfg.shift, 0, 0);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_IN_CTRL, r);\n\n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_I2S_IN_LEN,\n\t\t\tcfg->i2s_cfg.in_length_bits, 3, 0);\n\n\t \n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_HDMI_CTRL, cfg->layout, 2, 1);\n\tr = hdmi_read_reg(av_base, HDMI_CORE_AV_AUD_MODE);\n\tr = FLD_MOD(r, cfg->i2s_cfg.active_sds, 7, 4);\n\tr = FLD_MOD(r, cfg->en_dsd_audio, 3, 3);\n\tr = FLD_MOD(r, cfg->en_parallel_aud_input, 2, 2);\n\tr = FLD_MOD(r, cfg->en_spdif, 1, 1);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_MODE, r);\n\n\t \n\t \n\thdmi_write_reg(av_base, HDMI_CORE_AV_I2S_IN_MAP, 0x78);\n\tREG_FLD_MOD(av_base, HDMI_CORE_AV_SWAP_I2S, 1, 5, 5);\n}\n\nstatic void hdmi_core_audio_infoframe_cfg(struct hdmi_core_data *core,\n\t\tstruct snd_cea_861_aud_if *info_aud)\n{\n\tu8 sum = 0, checksum = 0;\n\tvoid __iomem *av_base = hdmi_av_base(core);\n\n\t \n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUDIO_TYPE, 0x84);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUDIO_VERS, 0x01);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUDIO_LEN, 0x0a);\n\tsum += 0x84 + 0x001 + 0x00a;\n\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(0),\n\t\t       info_aud->db1_ct_cc);\n\tsum += info_aud->db1_ct_cc;\n\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(1),\n\t\t       info_aud->db2_sf_ss);\n\tsum += info_aud->db2_sf_ss;\n\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(2), info_aud->db3);\n\tsum += info_aud->db3;\n\n\t \n\tif (info_aud->db4_ca != 0x00)\n\t\tinfo_aud->db4_ca = 0x13;\n\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(3), info_aud->db4_ca);\n\tsum += info_aud->db4_ca;\n\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(4),\n\t\t       info_aud->db5_dminh_lsv);\n\tsum += info_aud->db5_dminh_lsv;\n\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(5), 0x00);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(6), 0x00);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(7), 0x00);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(8), 0x00);\n\thdmi_write_reg(av_base, HDMI_CORE_AV_AUD_DBYTE(9), 0x00);\n\n\tchecksum = 0x100 - sum;\n\thdmi_write_reg(av_base,\n\t\t\t\t\tHDMI_CORE_AV_AUDIO_CHSUM, checksum);\n\n\t \n}\n\nint hdmi4_audio_config(struct hdmi_core_data *core, struct hdmi_wp_data *wp,\n\t\tstruct omap_dss_audio *audio, u32 pclk)\n{\n\tstruct hdmi_audio_format audio_format;\n\tstruct hdmi_audio_dma audio_dma;\n\tstruct hdmi_core_audio_config acore;\n\tint n, cts, channel_count;\n\tunsigned int fs_nr;\n\tbool word_length_16b = false;\n\n\tif (!audio || !audio->iec || !audio->cea || !core)\n\t\treturn -EINVAL;\n\n\tacore.iec60958_cfg = audio->iec;\n\t \n\tif (!(audio->iec->status[4] & IEC958_AES4_CON_MAX_WORDLEN_24))\n\t\tif (audio->iec->status[4] & IEC958_AES4_CON_WORDLEN_20_16)\n\t\t\tword_length_16b = true;\n\n\t \n\tif (word_length_16b)\n\t\tacore.i2s_cfg.justification = HDMI_AUDIO_JUSTIFY_LEFT;\n\telse\n\t\tacore.i2s_cfg.justification = HDMI_AUDIO_JUSTIFY_RIGHT;\n\t \n\tacore.i2s_cfg.in_length_bits = audio->iec->status[4]\n\t\t& IEC958_AES4_CON_WORDLEN;\n\tif (audio->iec->status[4] & IEC958_AES4_CON_MAX_WORDLEN_24)\n\t\tacore.i2s_cfg.in_length_bits++;\n\tacore.i2s_cfg.sck_edge_mode = HDMI_AUDIO_I2S_SCK_EDGE_RISING;\n\tacore.i2s_cfg.vbit = HDMI_AUDIO_I2S_VBIT_FOR_PCM;\n\tacore.i2s_cfg.direction = HDMI_AUDIO_I2S_MSB_SHIFTED_FIRST;\n\tacore.i2s_cfg.shift = HDMI_AUDIO_I2S_FIRST_BIT_SHIFT;\n\n\t \n\tswitch (audio->iec->status[3] & IEC958_AES3_CON_FS) {\n\tcase IEC958_AES3_CON_FS_32000:\n\t\tfs_nr = 32000;\n\t\tbreak;\n\tcase IEC958_AES3_CON_FS_44100:\n\t\tfs_nr = 44100;\n\t\tbreak;\n\tcase IEC958_AES3_CON_FS_48000:\n\t\tfs_nr = 48000;\n\t\tbreak;\n\tcase IEC958_AES3_CON_FS_88200:\n\t\tfs_nr = 88200;\n\t\tbreak;\n\tcase IEC958_AES3_CON_FS_96000:\n\t\tfs_nr = 96000;\n\t\tbreak;\n\tcase IEC958_AES3_CON_FS_176400:\n\t\tfs_nr = 176400;\n\t\tbreak;\n\tcase IEC958_AES3_CON_FS_192000:\n\t\tfs_nr = 192000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thdmi_compute_acr(pclk, fs_nr, &n, &cts);\n\n\t \n\tacore.n = n;\n\tacore.cts = cts;\n\tif (core->cts_swmode) {\n\t\tacore.aud_par_busclk = 0;\n\t\tacore.cts_mode = HDMI_AUDIO_CTS_MODE_SW;\n\t\tacore.use_mclk = core->audio_use_mclk;\n\t} else {\n\t\tacore.aud_par_busclk = (((128 * 31) - 1) << 8);\n\t\tacore.cts_mode = HDMI_AUDIO_CTS_MODE_HW;\n\t\tacore.use_mclk = true;\n\t}\n\n\tif (acore.use_mclk)\n\t\tacore.mclk_mode = HDMI_AUDIO_MCLK_128FS;\n\n\t \n\tchannel_count = (audio->cea->db1_ct_cc &\n\t\t\t CEA861_AUDIO_INFOFRAME_DB1CC) + 1;\n\n\tswitch (channel_count) {\n\tcase 2:\n\t\taudio_format.active_chnnls_msk = 0x03;\n\t\tbreak;\n\tcase 3:\n\t\taudio_format.active_chnnls_msk = 0x07;\n\t\tbreak;\n\tcase 4:\n\t\taudio_format.active_chnnls_msk = 0x0f;\n\t\tbreak;\n\tcase 5:\n\t\taudio_format.active_chnnls_msk = 0x1f;\n\t\tbreak;\n\tcase 6:\n\t\taudio_format.active_chnnls_msk = 0x3f;\n\t\tbreak;\n\tcase 7:\n\t\taudio_format.active_chnnls_msk = 0x7f;\n\t\tbreak;\n\tcase 8:\n\t\taudio_format.active_chnnls_msk = 0xff;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (channel_count == 2) {\n\t\taudio_format.stereo_channels = HDMI_AUDIO_STEREO_ONECHANNEL;\n\t\tacore.i2s_cfg.active_sds = HDMI_AUDIO_I2S_SD0_EN;\n\t\tacore.layout = HDMI_AUDIO_LAYOUT_2CH;\n\t} else {\n\t\taudio_format.stereo_channels = HDMI_AUDIO_STEREO_FOURCHANNELS;\n\t\tacore.i2s_cfg.active_sds = HDMI_AUDIO_I2S_SD0_EN |\n\t\t\t\tHDMI_AUDIO_I2S_SD1_EN | HDMI_AUDIO_I2S_SD2_EN |\n\t\t\t\tHDMI_AUDIO_I2S_SD3_EN;\n\t\tacore.layout = HDMI_AUDIO_LAYOUT_8CH;\n\t\taudio->cea->db1_ct_cc = 7;\n\t}\n\n\tacore.en_spdif = false;\n\t \n\tacore.fs_override = true;\n\t \n\tacore.en_acr_pkt = true;\n\t \n\tacore.en_dsd_audio = false;\n\t \n\tacore.en_parallel_aud_input = true;\n\n\t \n\tif (word_length_16b)\n\t\taudio_dma.transfer_size = 0x10;\n\telse\n\t\taudio_dma.transfer_size = 0x20;\n\taudio_dma.block_size = 0xC0;\n\taudio_dma.mode = HDMI_AUDIO_TRANSF_DMA;\n\taudio_dma.fifo_threshold = 0x20;  \n\n\t \n\tif (word_length_16b) {\n\t\taudio_format.samples_per_word = HDMI_AUDIO_ONEWORD_TWOSAMPLES;\n\t\taudio_format.sample_size = HDMI_AUDIO_SAMPLE_16BITS;\n\t\taudio_format.justification = HDMI_AUDIO_JUSTIFY_LEFT;\n\t} else {\n\t\taudio_format.samples_per_word = HDMI_AUDIO_ONEWORD_ONESAMPLE;\n\t\taudio_format.sample_size = HDMI_AUDIO_SAMPLE_24BITS;\n\t\taudio_format.justification = HDMI_AUDIO_JUSTIFY_RIGHT;\n\t}\n\taudio_format.type = HDMI_AUDIO_TYPE_LPCM;\n\taudio_format.sample_order = HDMI_AUDIO_SAMPLE_LEFT_FIRST;\n\t \n\taudio_format.en_sig_blk_strt_end = HDMI_AUDIO_BLOCK_SIG_STARTEND_ON;\n\n\t \n\thdmi_wp_audio_config_dma(wp, &audio_dma);\n\thdmi_wp_audio_config_format(wp, &audio_format);\n\n\t \n\thdmi_core_audio_config(core, &acore);\n\n\t \n\thdmi_core_audio_infoframe_cfg(core, audio->cea);\n\n\treturn 0;\n}\n\nint hdmi4_audio_start(struct hdmi_core_data *core, struct hdmi_wp_data *wp)\n{\n\tREG_FLD_MOD(hdmi_av_base(core),\n\t\t    HDMI_CORE_AV_AUD_MODE, true, 0, 0);\n\n\thdmi_wp_audio_core_req_enable(wp, true);\n\n\treturn 0;\n}\n\nvoid hdmi4_audio_stop(struct hdmi_core_data *core, struct hdmi_wp_data *wp)\n{\n\tREG_FLD_MOD(hdmi_av_base(core),\n\t\t    HDMI_CORE_AV_AUD_MODE, false, 0, 0);\n\n\thdmi_wp_audio_core_req_enable(wp, false);\n}\n\nstruct hdmi4_features {\n\tbool cts_swmode;\n\tbool audio_use_mclk;\n};\n\nstatic const struct hdmi4_features hdmi4430_es1_features = {\n\t.cts_swmode = false,\n\t.audio_use_mclk = false,\n};\n\nstatic const struct hdmi4_features hdmi4430_es2_features = {\n\t.cts_swmode = true,\n\t.audio_use_mclk = false,\n};\n\nstatic const struct hdmi4_features hdmi4_features = {\n\t.cts_swmode = true,\n\t.audio_use_mclk = true,\n};\n\nstatic const struct soc_device_attribute hdmi4_soc_devices[] = {\n\t{\n\t\t.machine = \"OMAP4430\",\n\t\t.revision = \"ES1.?\",\n\t\t.data = &hdmi4430_es1_features,\n\t},\n\t{\n\t\t.machine = \"OMAP4430\",\n\t\t.revision = \"ES2.?\",\n\t\t.data = &hdmi4430_es2_features,\n\t},\n\t{\n\t\t.family = \"OMAP4\",\n\t\t.data = &hdmi4_features,\n\t},\n\t{   }\n};\n\nint hdmi4_core_init(struct platform_device *pdev, struct hdmi_core_data *core)\n{\n\tconst struct hdmi4_features *features;\n\tconst struct soc_device_attribute *soc;\n\n\tsoc = soc_device_match(hdmi4_soc_devices);\n\tif (!soc)\n\t\treturn -ENODEV;\n\n\tfeatures = soc->data;\n\tcore->cts_swmode = features->cts_swmode;\n\tcore->audio_use_mclk = features->audio_use_mclk;\n\n\tcore->base = devm_platform_ioremap_resource_byname(pdev, \"core\");\n\tif (IS_ERR(core->base))\n\t\treturn PTR_ERR(core->base);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}