{
  "module_name": "hdmi4_cec.c",
  "hash_id": "0f4e13861cda2576a0b4cc9caabbc73b98291a81a158078a623bd10bf71eaed1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/dss/hdmi4_cec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"dss.h\"\n#include \"hdmi.h\"\n#include \"hdmi4_core.h\"\n#include \"hdmi4_cec.h\"\n\n \n#define HDMI_CEC_DEV_ID                         0x900\n#define HDMI_CEC_SPEC                           0x904\n\n \n#define HDMI_CEC_DBG_3                          0x91C\n#define HDMI_CEC_TX_INIT                        0x920\n#define HDMI_CEC_TX_DEST                        0x924\n#define HDMI_CEC_SETUP                          0x938\n#define HDMI_CEC_TX_COMMAND                     0x93C\n#define HDMI_CEC_TX_OPERAND                     0x940\n#define HDMI_CEC_TRANSMIT_DATA                  0x97C\n#define HDMI_CEC_CA_7_0                         0x988\n#define HDMI_CEC_CA_15_8                        0x98C\n#define HDMI_CEC_INT_STATUS_0                   0x998\n#define HDMI_CEC_INT_STATUS_1                   0x99C\n#define HDMI_CEC_INT_ENABLE_0                   0x990\n#define HDMI_CEC_INT_ENABLE_1                   0x994\n#define HDMI_CEC_RX_CONTROL                     0x9B0\n#define HDMI_CEC_RX_COUNT                       0x9B4\n#define HDMI_CEC_RX_CMD_HEADER                  0x9B8\n#define HDMI_CEC_RX_COMMAND                     0x9BC\n#define HDMI_CEC_RX_OPERAND                     0x9C0\n\n#define HDMI_CEC_TX_FIFO_INT_MASK\t\t0x64\n#define HDMI_CEC_RETRANSMIT_CNT_INT_MASK\t0x2\n\n#define HDMI_CORE_CEC_RETRY    200\n\nstatic void hdmi_cec_received_msg(struct hdmi_core_data *core)\n{\n\tu32 cnt = hdmi_read_reg(core->base, HDMI_CEC_RX_COUNT) & 0xff;\n\n\t \n\twhile (cnt & 0x70) {\n\t\t \n\t\tif (!(cnt & 0x80)) {\n\t\t\tstruct cec_msg msg = {};\n\t\t\tunsigned int i;\n\n\t\t\t \n\t\t\tmsg.len = cnt & 0xf;\n\t\t\tif (msg.len > CEC_MAX_MSG_SIZE - 2)\n\t\t\t\tmsg.len = CEC_MAX_MSG_SIZE - 2;\n\t\t\tmsg.msg[0] = hdmi_read_reg(core->base,\n\t\t\t\t\t\t   HDMI_CEC_RX_CMD_HEADER);\n\t\t\tmsg.msg[1] = hdmi_read_reg(core->base,\n\t\t\t\t\t\t   HDMI_CEC_RX_COMMAND);\n\t\t\tfor (i = 0; i < msg.len; i++) {\n\t\t\t\tunsigned int reg = HDMI_CEC_RX_OPERAND + i * 4;\n\n\t\t\t\tmsg.msg[2 + i] =\n\t\t\t\t\thdmi_read_reg(core->base, reg);\n\t\t\t}\n\t\t\tmsg.len += 2;\n\t\t\tcec_received_msg(core->adap, &msg);\n\t\t}\n\t\t \n\t\thdmi_write_reg(core->base, HDMI_CEC_RX_CONTROL, 1);\n\t\t \n\t\twhile (hdmi_read_reg(core->base, HDMI_CEC_RX_CONTROL) & 1)\n\t\t\tudelay(1);\n\t\t \n\t\tcnt = hdmi_read_reg(core->base, HDMI_CEC_RX_COUNT) & 0xff;\n\t}\n}\n\nvoid hdmi4_cec_irq(struct hdmi_core_data *core)\n{\n\tu32 stat0 = hdmi_read_reg(core->base, HDMI_CEC_INT_STATUS_0);\n\tu32 stat1 = hdmi_read_reg(core->base, HDMI_CEC_INT_STATUS_1);\n\n\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_0, stat0);\n\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_1, stat1);\n\n\tif (stat0 & 0x20) {\n\t\tcec_transmit_done(core->adap, CEC_TX_STATUS_OK,\n\t\t\t\t  0, 0, 0, 0);\n\t\tREG_FLD_MOD(core->base, HDMI_CEC_DBG_3, 0x1, 7, 7);\n\t} else if (stat1 & 0x02) {\n\t\tu32 dbg3 = hdmi_read_reg(core->base, HDMI_CEC_DBG_3);\n\n\t\tcec_transmit_done(core->adap,\n\t\t\t\t  CEC_TX_STATUS_NACK |\n\t\t\t\t  CEC_TX_STATUS_MAX_RETRIES,\n\t\t\t\t  0, (dbg3 >> 4) & 7, 0, 0);\n\t\tREG_FLD_MOD(core->base, HDMI_CEC_DBG_3, 0x1, 7, 7);\n\t}\n\tif (stat0 & 0x02)\n\t\thdmi_cec_received_msg(core);\n}\n\nstatic bool hdmi_cec_clear_tx_fifo(struct cec_adapter *adap)\n{\n\tstruct hdmi_core_data *core = cec_get_drvdata(adap);\n\tint retry = HDMI_CORE_CEC_RETRY;\n\tint temp;\n\n\tREG_FLD_MOD(core->base, HDMI_CEC_DBG_3, 0x1, 7, 7);\n\twhile (retry) {\n\t\ttemp = hdmi_read_reg(core->base, HDMI_CEC_DBG_3);\n\t\tif (FLD_GET(temp, 7, 7) == 0)\n\t\t\tbreak;\n\t\tretry--;\n\t}\n\treturn retry != 0;\n}\n\nstatic bool hdmi_cec_clear_rx_fifo(struct cec_adapter *adap)\n{\n\tstruct hdmi_core_data *core = cec_get_drvdata(adap);\n\tint retry = HDMI_CORE_CEC_RETRY;\n\tint temp;\n\n\thdmi_write_reg(core->base, HDMI_CEC_RX_CONTROL, 0x3);\n\tretry = HDMI_CORE_CEC_RETRY;\n\twhile (retry) {\n\t\ttemp = hdmi_read_reg(core->base, HDMI_CEC_RX_CONTROL);\n\t\tif (FLD_GET(temp, 1, 0) == 0)\n\t\t\tbreak;\n\t\tretry--;\n\t}\n\treturn retry != 0;\n}\n\nstatic int hdmi_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct hdmi_core_data *core = cec_get_drvdata(adap);\n\tint temp, err;\n\n\tif (!enable) {\n\t\thdmi_write_reg(core->base, HDMI_CEC_INT_ENABLE_0, 0);\n\t\thdmi_write_reg(core->base, HDMI_CEC_INT_ENABLE_1, 0);\n\t\tREG_FLD_MOD(core->base, HDMI_CORE_SYS_INTR_UNMASK4, 0, 3, 3);\n\t\thdmi_wp_clear_irqenable(core->wp, HDMI_IRQ_CORE);\n\t\thdmi_wp_set_irqstatus(core->wp, HDMI_IRQ_CORE);\n\t\tREG_FLD_MOD(core->wp->base, HDMI_WP_CLK, 0, 5, 0);\n\t\thdmi4_core_disable(core);\n\t\treturn 0;\n\t}\n\terr = hdmi4_core_enable(core);\n\tif (err)\n\t\treturn err;\n\n\t \n\tREG_FLD_MOD(core->wp->base, HDMI_WP_CLK, 0x18, 5, 0);\n\n\t \n\tif (!hdmi_cec_clear_tx_fifo(adap)) {\n\t\tpr_err(\"cec-%s: could not clear TX FIFO\\n\", adap->name);\n\t\terr = -EIO;\n\t\tgoto err_disable_clk;\n\t}\n\n\t \n\tif (!hdmi_cec_clear_rx_fifo(adap)) {\n\t\tpr_err(\"cec-%s: could not clear RX FIFO\\n\", adap->name);\n\t\terr = -EIO;\n\t\tgoto err_disable_clk;\n\t}\n\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_1,\n\t\thdmi_read_reg(core->base, HDMI_CEC_INT_STATUS_1));\n\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_0,\n\t\thdmi_read_reg(core->base, HDMI_CEC_INT_STATUS_0));\n\n\t \n\thdmi_wp_set_irqenable(core->wp, HDMI_IRQ_CORE);\n\t \n\tREG_FLD_MOD(core->base, HDMI_CORE_SYS_INTR_UNMASK4, 0x1, 3, 3);\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_INT_ENABLE_0, 0x22);\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_INT_ENABLE_1, 0x02);\n\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_SETUP, 0x03);\n\tmsleep(20);\n\thdmi_write_reg(core->base, HDMI_CEC_SETUP, 0x04);\n\n\ttemp = hdmi_read_reg(core->base, HDMI_CEC_SETUP);\n\tif (FLD_GET(temp, 4, 4) != 0) {\n\t\ttemp = FLD_MOD(temp, 0, 4, 4);\n\t\thdmi_write_reg(core->base, HDMI_CEC_SETUP, temp);\n\n\t\t \n\t\ttemp = hdmi_read_reg(core->base, HDMI_CEC_INT_STATUS_1);\n\t\ttemp = FLD_MOD(0x0, 0x5, 2, 0);\n\t\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_1, temp);\n\t}\n\treturn 0;\n\nerr_disable_clk:\n\tREG_FLD_MOD(core->wp->base, HDMI_WP_CLK, 0, 5, 0);\n\thdmi4_core_disable(core);\n\n\treturn err;\n}\n\nstatic int hdmi_cec_adap_log_addr(struct cec_adapter *adap, u8 log_addr)\n{\n\tstruct hdmi_core_data *core = cec_get_drvdata(adap);\n\tu32 v;\n\n\tif (log_addr == CEC_LOG_ADDR_INVALID) {\n\t\thdmi_write_reg(core->base, HDMI_CEC_CA_7_0, 0);\n\t\thdmi_write_reg(core->base, HDMI_CEC_CA_15_8, 0);\n\t\treturn 0;\n\t}\n\tif (log_addr <= 7) {\n\t\tv = hdmi_read_reg(core->base, HDMI_CEC_CA_7_0);\n\t\tv |= 1 << log_addr;\n\t\thdmi_write_reg(core->base, HDMI_CEC_CA_7_0, v);\n\t} else {\n\t\tv = hdmi_read_reg(core->base, HDMI_CEC_CA_15_8);\n\t\tv |= 1 << (log_addr - 8);\n\t\thdmi_write_reg(core->base, HDMI_CEC_CA_15_8, v);\n\t}\n\treturn 0;\n}\n\nstatic int hdmi_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t   u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct hdmi_core_data *core = cec_get_drvdata(adap);\n\tint temp;\n\tu32 i;\n\n\t \n\tif (!hdmi_cec_clear_tx_fifo(adap)) {\n\t\tpr_err(\"cec-%s: could not clear TX FIFO for transmit\\n\",\n\t\t       adap->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_0,\n\t\t       HDMI_CEC_TX_FIFO_INT_MASK);\n\n\thdmi_write_reg(core->base, HDMI_CEC_INT_STATUS_1,\n\t\t       HDMI_CEC_RETRANSMIT_CNT_INT_MASK);\n\n\t \n\tREG_FLD_MOD(core->base, HDMI_CEC_DBG_3, attempts - 1, 6, 4);\n\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_TX_INIT, cec_msg_initiator(msg));\n\n\t \n\ttemp = cec_msg_destination(msg);\n\tif (msg->len == 1)\n\t\ttemp |= 0x80;\n\thdmi_write_reg(core->base, HDMI_CEC_TX_DEST, temp);\n\tif (msg->len == 1)\n\t\treturn 0;\n\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_TX_COMMAND, msg->msg[1]);\n\n\tfor (i = 0; i < msg->len - 2; i++)\n\t\thdmi_write_reg(core->base, HDMI_CEC_TX_OPERAND + i * 4,\n\t\t\t       msg->msg[2 + i]);\n\n\t \n\thdmi_write_reg(core->base, HDMI_CEC_TRANSMIT_DATA,\n\t\t       (msg->len - 2) | 0x10);\n\treturn 0;\n}\n\nstatic const struct cec_adap_ops hdmi_cec_adap_ops = {\n\t.adap_enable = hdmi_cec_adap_enable,\n\t.adap_log_addr = hdmi_cec_adap_log_addr,\n\t.adap_transmit = hdmi_cec_adap_transmit,\n};\n\nvoid hdmi4_cec_set_phys_addr(struct hdmi_core_data *core, u16 pa)\n{\n\tcec_s_phys_addr(core->adap, pa, false);\n}\n\nint hdmi4_cec_init(struct platform_device *pdev, struct hdmi_core_data *core,\n\t\t  struct hdmi_wp_data *wp)\n{\n\tconst u32 caps = CEC_CAP_TRANSMIT | CEC_CAP_LOG_ADDRS |\n\t\t\t CEC_CAP_PASSTHROUGH | CEC_CAP_RC;\n\tint ret;\n\n\tcore->adap = cec_allocate_adapter(&hdmi_cec_adap_ops, core,\n\t\t\"omap4\", caps, CEC_MAX_LOG_ADDRS);\n\tret = PTR_ERR_OR_ZERO(core->adap);\n\tif (ret < 0)\n\t\treturn ret;\n\tcore->wp = wp;\n\n\t \n\tREG_FLD_MOD(core->wp->base, HDMI_WP_CLK, 0, 5, 0);\n\n\tret = cec_register_adapter(core->adap, &pdev->dev);\n\tif (ret < 0) {\n\t\tcec_delete_adapter(core->adap);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nvoid hdmi4_cec_uninit(struct hdmi_core_data *core)\n{\n\tcec_unregister_adapter(core->adap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}