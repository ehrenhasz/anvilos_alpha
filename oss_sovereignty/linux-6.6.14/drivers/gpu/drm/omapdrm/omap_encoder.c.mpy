{
  "module_name": "omap_encoder.c",
  "hash_id": "83353c695916262d44fae81ae9bfa61aca4700d8ae7d57dbd6d698d260dd93aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/omapdrm/omap_encoder.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n\n#include <drm/drm_bridge.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_edid.h>\n\n#include \"omap_drv.h\"\n\n \n\n#define to_omap_encoder(x) container_of(x, struct omap_encoder, base)\n\n \nstruct omap_encoder {\n\tstruct drm_encoder base;\n\tstruct omap_dss_device *output;\n};\n\nstatic void omap_encoder_destroy(struct drm_encoder *encoder)\n{\n\tstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(omap_encoder);\n}\n\nstatic const struct drm_encoder_funcs omap_encoder_funcs = {\n\t.destroy = omap_encoder_destroy,\n};\n\nstatic void omap_encoder_update_videomode_flags(struct videomode *vm,\n\t\t\t\t\t\tu32 bus_flags)\n{\n\tif (!(vm->flags & (DISPLAY_FLAGS_DE_LOW |\n\t\t\t   DISPLAY_FLAGS_DE_HIGH))) {\n\t\tif (bus_flags & DRM_BUS_FLAG_DE_LOW)\n\t\t\tvm->flags |= DISPLAY_FLAGS_DE_LOW;\n\t\telse if (bus_flags & DRM_BUS_FLAG_DE_HIGH)\n\t\t\tvm->flags |= DISPLAY_FLAGS_DE_HIGH;\n\t}\n\n\tif (!(vm->flags & (DISPLAY_FLAGS_PIXDATA_POSEDGE |\n\t\t\t   DISPLAY_FLAGS_PIXDATA_NEGEDGE))) {\n\t\tif (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE)\n\t\t\tvm->flags |= DISPLAY_FLAGS_PIXDATA_POSEDGE;\n\t\telse if (bus_flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\t\tvm->flags |= DISPLAY_FLAGS_PIXDATA_NEGEDGE;\n\t}\n\n\tif (!(vm->flags & (DISPLAY_FLAGS_SYNC_POSEDGE |\n\t\t\t   DISPLAY_FLAGS_SYNC_NEGEDGE))) {\n\t\tif (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_POSEDGE)\n\t\t\tvm->flags |= DISPLAY_FLAGS_SYNC_POSEDGE;\n\t\telse if (bus_flags & DRM_BUS_FLAG_SYNC_DRIVE_NEGEDGE)\n\t\t\tvm->flags |= DISPLAY_FLAGS_SYNC_NEGEDGE;\n\t}\n}\n\nstatic void omap_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t\t  struct drm_display_mode *mode,\n\t\t\t\t  struct drm_display_mode *adjusted_mode)\n{\n\tstruct omap_encoder *omap_encoder = to_omap_encoder(encoder);\n\tstruct omap_dss_device *output = omap_encoder->output;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_bridge *bridge;\n\tstruct videomode vm = { 0 };\n\tu32 bus_flags;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tif (connector->encoder == encoder)\n\t\t\tbreak;\n\t}\n\n\tdrm_display_mode_to_videomode(adjusted_mode, &vm);\n\n\t \n\tfor (bridge = output->bridge; bridge;\n\t     bridge = drm_bridge_get_next_bridge(bridge)) {\n\t\tif (!bridge->timings)\n\t\t\tcontinue;\n\n\t\tbus_flags = bridge->timings->input_bus_flags;\n\t\tomap_encoder_update_videomode_flags(&vm, bus_flags);\n\t}\n\n\tbus_flags = connector->display_info.bus_flags;\n\tomap_encoder_update_videomode_flags(&vm, bus_flags);\n\n\t \n\tdss_mgr_set_timings(output, &vm);\n}\n\nstatic const struct drm_encoder_helper_funcs omap_encoder_helper_funcs = {\n\t.mode_set = omap_encoder_mode_set,\n};\n\n \nstruct drm_encoder *omap_encoder_init(struct drm_device *dev,\n\t\t\t\t      struct omap_dss_device *output)\n{\n\tstruct drm_encoder *encoder = NULL;\n\tstruct omap_encoder *omap_encoder;\n\n\tomap_encoder = kzalloc(sizeof(*omap_encoder), GFP_KERNEL);\n\tif (!omap_encoder)\n\t\tgoto fail;\n\n\tomap_encoder->output = output;\n\n\tencoder = &omap_encoder->base;\n\n\tdrm_encoder_init(dev, encoder, &omap_encoder_funcs,\n\t\t\t DRM_MODE_ENCODER_TMDS, NULL);\n\tdrm_encoder_helper_add(encoder, &omap_encoder_helper_funcs);\n\n\treturn encoder;\n\nfail:\n\tif (encoder)\n\t\tomap_encoder_destroy(encoder);\n\n\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}