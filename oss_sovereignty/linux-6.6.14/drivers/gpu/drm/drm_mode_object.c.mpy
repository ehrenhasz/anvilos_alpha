{
  "module_name": "drm_mode_object.c",
  "hash_id": "859e3f9d8fa6332dec76ae462a52092e4da43e43583e973c086b8b4c9246a486",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_mode_object.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\n \nint __drm_mode_object_add(struct drm_device *dev, struct drm_mode_object *obj,\n\t\t\t  uint32_t obj_type, bool register_obj,\n\t\t\t  void (*obj_free_cb)(struct kref *kref))\n{\n\tint ret;\n\n\tWARN_ON(!dev->driver->load && dev->registered && !obj_free_cb);\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tret = idr_alloc(&dev->mode_config.object_idr, register_obj ? obj : NULL,\n\t\t\t1, 0, GFP_KERNEL);\n\tif (ret >= 0) {\n\t\t \n\t\tobj->id = ret;\n\t\tobj->type = obj_type;\n\t\tif (obj_free_cb) {\n\t\t\tobj->free_cb = obj_free_cb;\n\t\t\tkref_init(&obj->refcount);\n\t\t}\n\t}\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\treturn ret < 0 ? ret : 0;\n}\n\n \nint drm_mode_object_add(struct drm_device *dev,\n\t\t\tstruct drm_mode_object *obj, uint32_t obj_type)\n{\n\treturn __drm_mode_object_add(dev, obj, obj_type, true, NULL);\n}\n\nvoid drm_mode_object_register(struct drm_device *dev,\n\t\t\t      struct drm_mode_object *obj)\n{\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tidr_replace(&dev->mode_config.object_idr, obj, obj->id);\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n}\n\n \nvoid drm_mode_object_unregister(struct drm_device *dev,\n\t\t\t\tstruct drm_mode_object *object)\n{\n\tWARN_ON(!dev->driver->load && dev->registered && !object->free_cb);\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tif (object->id) {\n\t\tidr_remove(&dev->mode_config.object_idr, object->id);\n\t\tobject->id = 0;\n\t}\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n}\n\n \nbool drm_mode_object_lease_required(uint32_t type)\n{\n\tswitch(type) {\n\tcase DRM_MODE_OBJECT_CRTC:\n\tcase DRM_MODE_OBJECT_CONNECTOR:\n\tcase DRM_MODE_OBJECT_PLANE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct drm_mode_object *__drm_mode_object_find(struct drm_device *dev,\n\t\t\t\t\t       struct drm_file *file_priv,\n\t\t\t\t\t       uint32_t id, uint32_t type)\n{\n\tstruct drm_mode_object *obj = NULL;\n\n\tmutex_lock(&dev->mode_config.idr_mutex);\n\tobj = idr_find(&dev->mode_config.object_idr, id);\n\tif (obj && type != DRM_MODE_OBJECT_ANY && obj->type != type)\n\t\tobj = NULL;\n\tif (obj && obj->id != id)\n\t\tobj = NULL;\n\n\tif (obj && drm_mode_object_lease_required(obj->type) &&\n\t    !_drm_lease_held(file_priv, obj->id)) {\n\t\tdrm_dbg_kms(dev, \"[OBJECT:%d] not included in lease\", id);\n\t\tobj = NULL;\n\t}\n\n\tif (obj && obj->free_cb) {\n\t\tif (!kref_get_unless_zero(&obj->refcount))\n\t\t\tobj = NULL;\n\t}\n\tmutex_unlock(&dev->mode_config.idr_mutex);\n\n\treturn obj;\n}\n\n \nstruct drm_mode_object *drm_mode_object_find(struct drm_device *dev,\n\t\tstruct drm_file *file_priv,\n\t\tuint32_t id, uint32_t type)\n{\n\tstruct drm_mode_object *obj = NULL;\n\n\tobj = __drm_mode_object_find(dev, file_priv, id, type);\n\treturn obj;\n}\nEXPORT_SYMBOL(drm_mode_object_find);\n\n \nvoid drm_mode_object_put(struct drm_mode_object *obj)\n{\n\tif (obj->free_cb) {\n\t\tDRM_DEBUG(\"OBJ ID: %d (%d)\\n\", obj->id, kref_read(&obj->refcount));\n\t\tkref_put(&obj->refcount, obj->free_cb);\n\t}\n}\nEXPORT_SYMBOL(drm_mode_object_put);\n\n \nvoid drm_mode_object_get(struct drm_mode_object *obj)\n{\n\tif (obj->free_cb) {\n\t\tDRM_DEBUG(\"OBJ ID: %d (%d)\\n\", obj->id, kref_read(&obj->refcount));\n\t\tkref_get(&obj->refcount);\n\t}\n}\nEXPORT_SYMBOL(drm_mode_object_get);\n\n \nvoid drm_object_attach_property(struct drm_mode_object *obj,\n\t\t\t\tstruct drm_property *property,\n\t\t\t\tuint64_t init_val)\n{\n\tint count = obj->properties->count;\n\tstruct drm_device *dev = property->dev;\n\n\n\tif (obj->type == DRM_MODE_OBJECT_CONNECTOR) {\n\t\tstruct drm_connector *connector = obj_to_connector(obj);\n\n\t\tWARN_ON(!dev->driver->load &&\n\t\t\tconnector->registration_state == DRM_CONNECTOR_REGISTERED);\n\t} else {\n\t\tWARN_ON(!dev->driver->load && dev->registered);\n\t}\n\n\tif (count == DRM_OBJECT_MAX_PROPERTY) {\n\t\tWARN(1, \"Failed to attach object property (type: 0x%x). Please \"\n\t\t\t\"increase DRM_OBJECT_MAX_PROPERTY by 1 for each time \"\n\t\t\t\"you see this message on the same object type.\\n\",\n\t\t\tobj->type);\n\t\treturn;\n\t}\n\n\tobj->properties->properties[count] = property;\n\tobj->properties->values[count] = init_val;\n\tobj->properties->count++;\n}\nEXPORT_SYMBOL(drm_object_attach_property);\n\n \nint drm_object_property_set_value(struct drm_mode_object *obj,\n\t\t\t\t  struct drm_property *property, uint64_t val)\n{\n\tint i;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(property->dev) &&\n\t\t!(property->flags & DRM_MODE_PROP_IMMUTABLE));\n\n\tfor (i = 0; i < obj->properties->count; i++) {\n\t\tif (obj->properties->properties[i] == property) {\n\t\t\tobj->properties->values[i] = val;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_object_property_set_value);\n\nstatic int __drm_object_property_get_prop_value(struct drm_mode_object *obj,\n\t\t\t\t\t\tstruct drm_property *property,\n\t\t\t\t\t\tuint64_t *val)\n{\n\tint i;\n\n\tfor (i = 0; i < obj->properties->count; i++) {\n\t\tif (obj->properties->properties[i] == property) {\n\t\t\t*val = obj->properties->values[i];\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int __drm_object_property_get_value(struct drm_mode_object *obj,\n\t\t\t\t\t   struct drm_property *property,\n\t\t\t\t\t   uint64_t *val)\n{\n\n\t \n\tif (drm_drv_uses_atomic_modeset(property->dev) &&\n\t\t\t!(property->flags & DRM_MODE_PROP_IMMUTABLE))\n\t\treturn drm_atomic_get_property(obj, property, val);\n\n\treturn __drm_object_property_get_prop_value(obj, property, val);\n}\n\n \nint drm_object_property_get_value(struct drm_mode_object *obj,\n\t\t\t\t  struct drm_property *property, uint64_t *val)\n{\n\tWARN_ON(drm_drv_uses_atomic_modeset(property->dev));\n\n\treturn __drm_object_property_get_value(obj, property, val);\n}\nEXPORT_SYMBOL(drm_object_property_get_value);\n\n \nint drm_object_property_get_default_value(struct drm_mode_object *obj,\n\t\t\t\t\t  struct drm_property *property,\n\t\t\t\t\t  uint64_t *val)\n{\n\tWARN_ON(!drm_drv_uses_atomic_modeset(property->dev));\n\n\treturn __drm_object_property_get_prop_value(obj, property, val);\n}\nEXPORT_SYMBOL(drm_object_property_get_default_value);\n\n \nint drm_mode_object_get_properties(struct drm_mode_object *obj, bool atomic,\n\t\t\t\t   uint32_t __user *prop_ptr,\n\t\t\t\t   uint64_t __user *prop_values,\n\t\t\t\t   uint32_t *arg_count_props)\n{\n\tint i, ret, count;\n\n\tfor (i = 0, count = 0; i < obj->properties->count; i++) {\n\t\tstruct drm_property *prop = obj->properties->properties[i];\n\t\tuint64_t val;\n\n\t\tif ((prop->flags & DRM_MODE_PROP_ATOMIC) && !atomic)\n\t\t\tcontinue;\n\n\t\tif (*arg_count_props > count) {\n\t\t\tret = __drm_object_property_get_value(obj, prop, &val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (put_user(prop->base.id, prop_ptr + count))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (put_user(val, prop_values + count))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tcount++;\n\t}\n\t*arg_count_props = count;\n\n\treturn 0;\n}\n\n \nint drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_mode_obj_get_properties *arg = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = 0;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, ret);\n\n\tobj = drm_mode_object_find(dev, file_priv, arg->obj_id, arg->obj_type);\n\tif (!obj) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (!obj->properties) {\n\t\tret = -EINVAL;\n\t\tgoto out_unref;\n\t}\n\n\tret = drm_mode_object_get_properties(obj, file_priv->atomic,\n\t\t\t(uint32_t __user *)(unsigned long)(arg->props_ptr),\n\t\t\t(uint64_t __user *)(unsigned long)(arg->prop_values_ptr),\n\t\t\t&arg->count_props);\n\nout_unref:\n\tdrm_mode_object_put(obj);\nout:\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n\treturn ret;\n}\n\nstruct drm_property *drm_mode_obj_find_prop_id(struct drm_mode_object *obj,\n\t\t\t\t\t       uint32_t prop_id)\n{\n\tint i;\n\n\tfor (i = 0; i < obj->properties->count; i++)\n\t\tif (obj->properties->properties[i]->base.id == prop_id)\n\t\t\treturn obj->properties->properties[i];\n\n\treturn NULL;\n}\n\nstatic int set_property_legacy(struct drm_mode_object *obj,\n\t\t\t       struct drm_property *prop,\n\t\t\t       uint64_t prop_value)\n{\n\tstruct drm_device *dev = prop->dev;\n\tstruct drm_mode_object *ref;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = -EINVAL;\n\n\tif (!drm_property_change_valid_get(prop, prop_value, &ref))\n\t\treturn -EINVAL;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, ret);\n\tswitch (obj->type) {\n\tcase DRM_MODE_OBJECT_CONNECTOR:\n\t\tret = drm_connector_set_obj_prop(obj, prop, prop_value);\n\t\tbreak;\n\tcase DRM_MODE_OBJECT_CRTC:\n\t\tret = drm_mode_crtc_set_obj_prop(obj, prop, prop_value);\n\t\tbreak;\n\tcase DRM_MODE_OBJECT_PLANE:\n\t\tret = drm_mode_plane_set_obj_prop(obj_to_plane(obj),\n\t\t\t\t\t\t  prop, prop_value);\n\t\tbreak;\n\t}\n\tdrm_property_change_valid_put(prop, ref);\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n\n\treturn ret;\n}\n\nstatic int set_property_atomic(struct drm_mode_object *obj,\n\t\t\t       struct drm_file *file_priv,\n\t\t\t       struct drm_property *prop,\n\t\t\t       uint64_t prop_value)\n{\n\tstruct drm_device *dev = prop->dev;\n\tstruct drm_atomic_state *state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\tstate->acquire_ctx = &ctx;\n\nretry:\n\tif (prop == state->dev->mode_config.dpms_property) {\n\t\tif (obj->type != DRM_MODE_OBJECT_CONNECTOR) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = drm_atomic_connector_commit_dpms(state,\n\t\t\t\t\t\t       obj_to_connector(obj),\n\t\t\t\t\t\t       prop_value);\n\t} else {\n\t\tret = drm_atomic_set_property(state, file_priv, obj, prop, prop_value);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = drm_atomic_commit(state);\n\t}\nout:\n\tif (ret == -EDEADLK) {\n\t\tdrm_atomic_state_clear(state);\n\t\tdrm_modeset_backoff(&ctx);\n\t\tgoto retry;\n\t}\n\n\tdrm_atomic_state_put(state);\n\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\n\treturn ret;\n}\n\nint drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t    struct drm_file *file_priv)\n{\n\tstruct drm_mode_obj_set_property *arg = data;\n\tstruct drm_mode_object *arg_obj;\n\tstruct drm_property *property;\n\tint ret = -EINVAL;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\targ_obj = drm_mode_object_find(dev, file_priv, arg->obj_id, arg->obj_type);\n\tif (!arg_obj)\n\t\treturn -ENOENT;\n\n\tif (!arg_obj->properties)\n\t\tgoto out_unref;\n\n\tproperty = drm_mode_obj_find_prop_id(arg_obj, arg->prop_id);\n\tif (!property)\n\t\tgoto out_unref;\n\n\tif (drm_drv_uses_atomic_modeset(property->dev))\n\t\tret = set_property_atomic(arg_obj, file_priv, property, arg->value);\n\telse\n\t\tret = set_property_legacy(arg_obj, property, arg->value);\n\nout_unref:\n\tdrm_mode_object_put(arg_obj);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}