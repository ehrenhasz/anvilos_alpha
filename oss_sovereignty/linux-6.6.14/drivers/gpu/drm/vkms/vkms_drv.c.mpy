{
  "module_name": "vkms_drv.c",
  "hash_id": "d4f5be3e31663669c1942fc5dbe2edb95d3e47fa5db490d34ff2d8209738fcb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_drv.c",
  "human_readable_source": "\n\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n\n#include <drm/drm_gem.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"vkms_drv.h\"\n\n#include <drm/drm_print.h>\n#include <drm/drm_debugfs.h>\n\n#define DRIVER_NAME\t\"vkms\"\n#define DRIVER_DESC\t\"Virtual Kernel Mode Setting\"\n#define DRIVER_DATE\t\"20180514\"\n#define DRIVER_MAJOR\t1\n#define DRIVER_MINOR\t0\n\nstatic struct vkms_config *default_config;\n\nstatic bool enable_cursor = true;\nmodule_param_named(enable_cursor, enable_cursor, bool, 0444);\nMODULE_PARM_DESC(enable_cursor, \"Enable/Disable cursor support\");\n\nstatic bool enable_writeback = true;\nmodule_param_named(enable_writeback, enable_writeback, bool, 0444);\nMODULE_PARM_DESC(enable_writeback, \"Enable/Disable writeback connector support\");\n\nstatic bool enable_overlay;\nmodule_param_named(enable_overlay, enable_overlay, bool, 0444);\nMODULE_PARM_DESC(enable_overlay, \"Enable/Disable overlay support\");\n\nDEFINE_DRM_GEM_FOPS(vkms_driver_fops);\n\nstatic void vkms_release(struct drm_device *dev)\n{\n\tstruct vkms_device *vkms = drm_device_to_vkms_device(dev);\n\n\tif (vkms->output.composer_workq)\n\t\tdestroy_workqueue(vkms->output.composer_workq);\n}\n\nstatic void vkms_atomic_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tint i;\n\n\tdrm_atomic_helper_commit_modeset_disables(dev, old_state);\n\n\tdrm_atomic_helper_commit_planes(dev, old_state, 0);\n\n\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\n\tdrm_atomic_helper_fake_vblank(old_state);\n\n\tdrm_atomic_helper_commit_hw_done(old_state);\n\n\tdrm_atomic_helper_wait_for_flip_done(dev, old_state);\n\n\tfor_each_old_crtc_in_state(old_state, crtc, old_crtc_state, i) {\n\t\tstruct vkms_crtc_state *vkms_state =\n\t\t\tto_vkms_crtc_state(old_crtc_state);\n\n\t\tflush_work(&vkms_state->composer_work);\n\t}\n\n\tdrm_atomic_helper_cleanup_planes(dev, old_state);\n}\n\nstatic int vkms_config_show(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct vkms_device *vkmsdev = drm_device_to_vkms_device(dev);\n\n\tseq_printf(m, \"writeback=%d\\n\", vkmsdev->config->writeback);\n\tseq_printf(m, \"cursor=%d\\n\", vkmsdev->config->cursor);\n\tseq_printf(m, \"overlay=%d\\n\", vkmsdev->config->overlay);\n\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info vkms_config_debugfs_list[] = {\n\t{ \"vkms_config\", vkms_config_show, 0 },\n};\n\nstatic const struct drm_driver vkms_driver = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_ATOMIC | DRIVER_GEM,\n\t.release\t\t= vkms_release,\n\t.fops\t\t\t= &vkms_driver_fops,\n\tDRM_GEM_SHMEM_DRIVER_OPS,\n\n\t.name\t\t\t= DRIVER_NAME,\n\t.desc\t\t\t= DRIVER_DESC,\n\t.date\t\t\t= DRIVER_DATE,\n\t.major\t\t\t= DRIVER_MAJOR,\n\t.minor\t\t\t= DRIVER_MINOR,\n};\n\nstatic int vkms_atomic_check(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->gamma_lut || !new_crtc_state->color_mgmt_changed)\n\t\t\tcontinue;\n\n\t\tif (new_crtc_state->gamma_lut->length / sizeof(struct drm_color_lut *)\n\t\t    > VKMS_LUT_SIZE)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn drm_atomic_helper_check(dev, state);\n}\n\nstatic const struct drm_mode_config_funcs vkms_mode_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = vkms_atomic_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic const struct drm_mode_config_helper_funcs vkms_mode_config_helpers = {\n\t.atomic_commit_tail = vkms_atomic_commit_tail,\n};\n\nstatic int vkms_modeset_init(struct vkms_device *vkmsdev)\n{\n\tstruct drm_device *dev = &vkmsdev->drm;\n\tint ret;\n\n\tret = drmm_mode_config_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->mode_config.funcs = &vkms_mode_funcs;\n\tdev->mode_config.min_width = XRES_MIN;\n\tdev->mode_config.min_height = YRES_MIN;\n\tdev->mode_config.max_width = XRES_MAX;\n\tdev->mode_config.max_height = YRES_MAX;\n\tdev->mode_config.cursor_width = 512;\n\tdev->mode_config.cursor_height = 512;\n\t \n\tdev->mode_config.preferred_depth = 0;\n\tdev->mode_config.helper_private = &vkms_mode_config_helpers;\n\n\treturn vkms_output_init(vkmsdev, 0);\n}\n\nstatic int vkms_create(struct vkms_config *config)\n{\n\tint ret;\n\tstruct platform_device *pdev;\n\tstruct vkms_device *vkms_device;\n\n\tpdev = platform_device_register_simple(DRIVER_NAME, -1, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tif (!devres_open_group(&pdev->dev, NULL, GFP_KERNEL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvkms_device = devm_drm_dev_alloc(&pdev->dev, &vkms_driver,\n\t\t\t\t\t struct vkms_device, drm);\n\tif (IS_ERR(vkms_device)) {\n\t\tret = PTR_ERR(vkms_device);\n\t\tgoto out_devres;\n\t}\n\tvkms_device->platform = pdev;\n\tvkms_device->config = config;\n\tconfig->dev = vkms_device;\n\n\tret = dma_coerce_mask_and_coherent(vkms_device->drm.dev,\n\t\t\t\t\t   DMA_BIT_MASK(64));\n\n\tif (ret) {\n\t\tDRM_ERROR(\"Could not initialize DMA support\\n\");\n\t\tgoto out_devres;\n\t}\n\n\tret = drm_vblank_init(&vkms_device->drm, 1);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to vblank\\n\");\n\t\tgoto out_devres;\n\t}\n\n\tret = vkms_modeset_init(vkms_device);\n\tif (ret)\n\t\tgoto out_devres;\n\n\tdrm_debugfs_add_files(&vkms_device->drm, vkms_config_debugfs_list,\n\t\t\t      ARRAY_SIZE(vkms_config_debugfs_list));\n\n\tret = drm_dev_register(&vkms_device->drm, 0);\n\tif (ret)\n\t\tgoto out_devres;\n\n\tdrm_fbdev_generic_setup(&vkms_device->drm, 0);\n\n\treturn 0;\n\nout_devres:\n\tdevres_release_group(&pdev->dev, NULL);\nout_unregister:\n\tplatform_device_unregister(pdev);\n\treturn ret;\n}\n\nstatic int __init vkms_init(void)\n{\n\tint ret;\n\tstruct vkms_config *config;\n\n\tconfig = kmalloc(sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\treturn -ENOMEM;\n\n\tdefault_config = config;\n\n\tconfig->cursor = enable_cursor;\n\tconfig->writeback = enable_writeback;\n\tconfig->overlay = enable_overlay;\n\n\tret = vkms_create(config);\n\tif (ret)\n\t\tkfree(config);\n\n\treturn ret;\n}\n\nstatic void vkms_destroy(struct vkms_config *config)\n{\n\tstruct platform_device *pdev;\n\n\tif (!config->dev) {\n\t\tDRM_INFO(\"vkms_device is NULL.\\n\");\n\t\treturn;\n\t}\n\n\tpdev = config->dev->platform;\n\n\tdrm_dev_unregister(&config->dev->drm);\n\tdrm_atomic_helper_shutdown(&config->dev->drm);\n\tdevres_release_group(&pdev->dev, NULL);\n\tplatform_device_unregister(pdev);\n\n\tconfig->dev = NULL;\n}\n\nstatic void __exit vkms_exit(void)\n{\n\tif (default_config->dev)\n\t\tvkms_destroy(default_config);\n\n\tkfree(default_config);\n}\n\nmodule_init(vkms_init);\nmodule_exit(vkms_exit);\n\nMODULE_AUTHOR(\"Haneen Mohammed <hamohammed.sa@gmail.com>\");\nMODULE_AUTHOR(\"Rodrigo Siqueira <rodrigosiqueiramelo@gmail.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}