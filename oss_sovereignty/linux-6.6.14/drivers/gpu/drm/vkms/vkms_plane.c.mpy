{
  "module_name": "vkms_plane.c",
  "hash_id": "8471766fdd866ab7a2591090aa1114eb328374708dfb48ae012d693ce17f0bdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_plane.c",
  "human_readable_source": "\n\n#include <linux/iosys-map.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"vkms_drv.h\"\n#include \"vkms_formats.h\"\n\nstatic const u32 vkms_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XRGB16161616,\n\tDRM_FORMAT_ARGB16161616,\n\tDRM_FORMAT_RGB565\n};\n\nstatic struct drm_plane_state *\nvkms_plane_duplicate_state(struct drm_plane *plane)\n{\n\tstruct vkms_plane_state *vkms_state;\n\tstruct vkms_frame_info *frame_info;\n\n\tvkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);\n\tif (!vkms_state)\n\t\treturn NULL;\n\n\tframe_info = kzalloc(sizeof(*frame_info), GFP_KERNEL);\n\tif (!frame_info) {\n\t\tDRM_DEBUG_KMS(\"Couldn't allocate frame_info\\n\");\n\t\tkfree(vkms_state);\n\t\treturn NULL;\n\t}\n\n\tvkms_state->frame_info = frame_info;\n\n\t__drm_gem_duplicate_shadow_plane_state(plane, &vkms_state->base);\n\n\treturn &vkms_state->base.base;\n}\n\nstatic void vkms_plane_destroy_state(struct drm_plane *plane,\n\t\t\t\t     struct drm_plane_state *old_state)\n{\n\tstruct vkms_plane_state *vkms_state = to_vkms_plane_state(old_state);\n\tstruct drm_crtc *crtc = vkms_state->base.base.crtc;\n\n\tif (crtc && vkms_state->frame_info->fb) {\n\t\t \n\t\tif (drm_framebuffer_read_refcount(vkms_state->frame_info->fb))\n\t\t\tdrm_framebuffer_put(vkms_state->frame_info->fb);\n\t}\n\n\tkfree(vkms_state->frame_info);\n\tvkms_state->frame_info = NULL;\n\n\t__drm_gem_destroy_shadow_plane_state(&vkms_state->base);\n\tkfree(vkms_state);\n}\n\nstatic void vkms_plane_reset(struct drm_plane *plane)\n{\n\tstruct vkms_plane_state *vkms_state;\n\n\tif (plane->state) {\n\t\tvkms_plane_destroy_state(plane, plane->state);\n\t\tplane->state = NULL;  \n\t}\n\n\tvkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);\n\tif (!vkms_state) {\n\t\tDRM_ERROR(\"Cannot allocate vkms_plane_state\\n\");\n\t\treturn;\n\t}\n\n\t__drm_gem_reset_shadow_plane(plane, &vkms_state->base);\n}\n\nstatic const struct drm_plane_funcs vkms_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= vkms_plane_reset,\n\t.atomic_duplicate_state = vkms_plane_duplicate_state,\n\t.atomic_destroy_state\t= vkms_plane_destroy_state,\n};\n\nstatic void vkms_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct vkms_plane_state *vkms_plane_state;\n\tstruct drm_shadow_plane_state *shadow_plane_state;\n\tstruct drm_framebuffer *fb = new_state->fb;\n\tstruct vkms_frame_info *frame_info;\n\tu32 fmt;\n\n\tif (!new_state->crtc || !fb)\n\t\treturn;\n\n\tfmt = fb->format->format;\n\tvkms_plane_state = to_vkms_plane_state(new_state);\n\tshadow_plane_state = &vkms_plane_state->base;\n\n\tframe_info = vkms_plane_state->frame_info;\n\tmemcpy(&frame_info->src, &new_state->src, sizeof(struct drm_rect));\n\tmemcpy(&frame_info->dst, &new_state->dst, sizeof(struct drm_rect));\n\tmemcpy(&frame_info->rotated, &new_state->dst, sizeof(struct drm_rect));\n\tframe_info->fb = fb;\n\tmemcpy(&frame_info->map, &shadow_plane_state->data, sizeof(frame_info->map));\n\tdrm_framebuffer_get(frame_info->fb);\n\tframe_info->rotation = drm_rotation_simplify(new_state->rotation, DRM_MODE_ROTATE_0 |\n\t\t\t\t\t\t     DRM_MODE_ROTATE_90 |\n\t\t\t\t\t\t     DRM_MODE_ROTATE_270 |\n\t\t\t\t\t\t     DRM_MODE_REFLECT_X |\n\t\t\t\t\t\t     DRM_MODE_REFLECT_Y);\n\n\tdrm_rect_rotate(&frame_info->rotated, drm_rect_width(&frame_info->rotated),\n\t\t\tdrm_rect_height(&frame_info->rotated), frame_info->rotation);\n\n\tframe_info->offset = fb->offsets[0];\n\tframe_info->pitch = fb->pitches[0];\n\tframe_info->cpp = fb->format->cpp[0];\n\tvkms_plane_state->pixel_read = get_pixel_conversion_function(fmt);\n}\n\nstatic int vkms_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc_state *crtc_state;\n\tint ret;\n\n\tif (!new_plane_state->fb || WARN_ON(!new_plane_state->crtc))\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t       new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int vkms_prepare_fb(struct drm_plane *plane,\n\t\t\t   struct drm_plane_state *state)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state;\n\tstruct drm_framebuffer *fb = state->fb;\n\tint ret;\n\n\tif (!fb)\n\t\treturn 0;\n\n\tshadow_plane_state = to_drm_shadow_plane_state(state);\n\n\tret = drm_gem_plane_helper_prepare_fb(plane, state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn drm_gem_fb_vmap(fb, shadow_plane_state->map, shadow_plane_state->data);\n}\n\nstatic void vkms_cleanup_fb(struct drm_plane *plane,\n\t\t\t    struct drm_plane_state *state)\n{\n\tstruct drm_shadow_plane_state *shadow_plane_state;\n\tstruct drm_framebuffer *fb = state->fb;\n\n\tif (!fb)\n\t\treturn;\n\n\tshadow_plane_state = to_drm_shadow_plane_state(state);\n\n\tdrm_gem_fb_vunmap(fb, shadow_plane_state->map);\n}\n\nstatic const struct drm_plane_helper_funcs vkms_plane_helper_funcs = {\n\t.atomic_update\t\t= vkms_plane_atomic_update,\n\t.atomic_check\t\t= vkms_plane_atomic_check,\n\t.prepare_fb\t\t= vkms_prepare_fb,\n\t.cleanup_fb\t\t= vkms_cleanup_fb,\n};\n\nstruct vkms_plane *vkms_plane_init(struct vkms_device *vkmsdev,\n\t\t\t\t   enum drm_plane_type type, int index)\n{\n\tstruct drm_device *dev = &vkmsdev->drm;\n\tstruct vkms_plane *plane;\n\n\tplane = drmm_universal_plane_alloc(dev, struct vkms_plane, base, 1 << index,\n\t\t\t\t\t   &vkms_plane_funcs,\n\t\t\t\t\t   vkms_formats, ARRAY_SIZE(vkms_formats),\n\t\t\t\t\t   NULL, type, NULL);\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tdrm_plane_helper_add(&plane->base, &vkms_plane_helper_funcs);\n\n\tdrm_plane_create_rotation_property(&plane->base, DRM_MODE_ROTATE_0,\n\t\t\t\t\t   DRM_MODE_ROTATE_MASK | DRM_MODE_REFLECT_MASK);\n\n\treturn plane;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}