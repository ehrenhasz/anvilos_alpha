{
  "module_name": "vkms_output.c",
  "hash_id": "eb98b04c6507296313fc12d770bdbea8aa9df1eb46e52e221ca53596e05cfa14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_output.c",
  "human_readable_source": "\n\n#include \"vkms_drv.h\"\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_probe_helper.h>\n\nstatic const struct drm_connector_funcs vkms_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const struct drm_encoder_funcs vkms_encoder_funcs = {\n\t.destroy = drm_encoder_cleanup,\n};\n\nstatic int vkms_conn_get_modes(struct drm_connector *connector)\n{\n\tint count;\n\n\tcount = drm_add_modes_noedid(connector, XRES_MAX, YRES_MAX);\n\tdrm_set_preferred_mode(connector, XRES_DEF, YRES_DEF);\n\n\treturn count;\n}\n\nstatic const struct drm_connector_helper_funcs vkms_conn_helper_funcs = {\n\t.get_modes    = vkms_conn_get_modes,\n};\n\nstatic int vkms_add_overlay_plane(struct vkms_device *vkmsdev, int index,\n\t\t\t\t  struct drm_crtc *crtc)\n{\n\tstruct vkms_plane *overlay;\n\n\toverlay = vkms_plane_init(vkmsdev, DRM_PLANE_TYPE_OVERLAY, index);\n\tif (IS_ERR(overlay))\n\t\treturn PTR_ERR(overlay);\n\n\tif (!overlay->base.possible_crtcs)\n\t\toverlay->base.possible_crtcs = drm_crtc_mask(crtc);\n\n\treturn 0;\n}\n\nint vkms_output_init(struct vkms_device *vkmsdev, int index)\n{\n\tstruct vkms_output *output = &vkmsdev->output;\n\tstruct drm_device *dev = &vkmsdev->drm;\n\tstruct drm_connector *connector = &output->connector;\n\tstruct drm_encoder *encoder = &output->encoder;\n\tstruct drm_crtc *crtc = &output->crtc;\n\tstruct vkms_plane *primary, *cursor = NULL;\n\tint ret;\n\tint writeback;\n\tunsigned int n;\n\n\tprimary = vkms_plane_init(vkmsdev, DRM_PLANE_TYPE_PRIMARY, index);\n\tif (IS_ERR(primary))\n\t\treturn PTR_ERR(primary);\n\n\tif (vkmsdev->config->overlay) {\n\t\tfor (n = 0; n < NUM_OVERLAY_PLANES; n++) {\n\t\t\tret = vkms_add_overlay_plane(vkmsdev, index, crtc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (vkmsdev->config->cursor) {\n\t\tcursor = vkms_plane_init(vkmsdev, DRM_PLANE_TYPE_CURSOR, index);\n\t\tif (IS_ERR(cursor))\n\t\t\treturn PTR_ERR(cursor);\n\t}\n\n\tret = vkms_crtc_init(dev, crtc, &primary->base, &cursor->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_connector_init(dev, connector, &vkms_connector_funcs,\n\t\t\t\t DRM_MODE_CONNECTOR_VIRTUAL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init connector\\n\");\n\t\tgoto err_connector;\n\t}\n\n\tdrm_connector_helper_add(connector, &vkms_conn_helper_funcs);\n\n\tret = drm_encoder_init(dev, encoder, &vkms_encoder_funcs,\n\t\t\t       DRM_MODE_ENCODER_VIRTUAL, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init encoder\\n\");\n\t\tgoto err_encoder;\n\t}\n\tencoder->possible_crtcs = 1;\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to attach connector to encoder\\n\");\n\t\tgoto err_attach;\n\t}\n\n\tif (vkmsdev->config->writeback) {\n\t\twriteback = vkms_enable_writeback_connector(vkmsdev);\n\t\tif (writeback)\n\t\t\tDRM_ERROR(\"Failed to init writeback connector\\n\");\n\t}\n\n\tdrm_mode_config_reset(dev);\n\n\treturn 0;\n\nerr_attach:\n\tdrm_encoder_cleanup(encoder);\n\nerr_encoder:\n\tdrm_connector_cleanup(connector);\n\nerr_connector:\n\tdrm_crtc_cleanup(crtc);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}