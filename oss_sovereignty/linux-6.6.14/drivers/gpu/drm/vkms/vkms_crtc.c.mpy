{
  "module_name": "vkms_crtc.c",
  "hash_id": "23a6e3f410d06a8c6a5d02100ff9785b9c424cfcc33e75857e9384104a31f0ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_crtc.c",
  "human_readable_source": "\n\n#include <linux/dma-fence.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"vkms_drv.h\"\n\nstatic enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)\n{\n\tstruct vkms_output *output = container_of(timer, struct vkms_output,\n\t\t\t\t\t\t  vblank_hrtimer);\n\tstruct drm_crtc *crtc = &output->crtc;\n\tstruct vkms_crtc_state *state;\n\tu64 ret_overrun;\n\tbool ret, fence_cookie;\n\n\tfence_cookie = dma_fence_begin_signalling();\n\n\tret_overrun = hrtimer_forward_now(&output->vblank_hrtimer,\n\t\t\t\t\t  output->period_ns);\n\tif (ret_overrun != 1)\n\t\tpr_warn(\"%s: vblank timer overrun\\n\", __func__);\n\n\tspin_lock(&output->lock);\n\tret = drm_crtc_handle_vblank(crtc);\n\tif (!ret)\n\t\tDRM_ERROR(\"vkms failure on handling vblank\");\n\n\tstate = output->composer_state;\n\tspin_unlock(&output->lock);\n\n\tif (state && output->composer_enabled) {\n\t\tu64 frame = drm_crtc_accurate_vblank_count(crtc);\n\n\t\t \n\t\tspin_lock(&output->composer_lock);\n\t\tif (!state->crc_pending)\n\t\t\tstate->frame_start = frame;\n\t\telse\n\t\t\tDRM_DEBUG_DRIVER(\"crc worker falling behind, frame_start: %llu, frame_end: %llu\\n\",\n\t\t\t\t\t state->frame_start, frame);\n\t\tstate->frame_end = frame;\n\t\tstate->crc_pending = true;\n\t\tspin_unlock(&output->composer_lock);\n\n\t\tret = queue_work(output->composer_workq, &state->composer_work);\n\t\tif (!ret)\n\t\t\tDRM_DEBUG_DRIVER(\"Composer worker already queued\\n\");\n\t}\n\n\tdma_fence_end_signalling(fence_cookie);\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int vkms_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tstruct vkms_output *out = drm_crtc_to_vkms_output(crtc);\n\n\tdrm_calc_timestamping_constants(crtc, &crtc->mode);\n\n\thrtimer_init(&out->vblank_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tout->vblank_hrtimer.function = &vkms_vblank_simulate;\n\tout->period_ns = ktime_set(0, vblank->framedur_ns);\n\thrtimer_start(&out->vblank_hrtimer, out->period_ns, HRTIMER_MODE_REL);\n\n\treturn 0;\n}\n\nstatic void vkms_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct vkms_output *out = drm_crtc_to_vkms_output(crtc);\n\n\thrtimer_cancel(&out->vblank_hrtimer);\n}\n\nstatic bool vkms_get_vblank_timestamp(struct drm_crtc *crtc,\n\t\t\t\t      int *max_error, ktime_t *vblank_time,\n\t\t\t\t      bool in_vblank_irq)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct vkms_device *vkmsdev = drm_device_to_vkms_device(dev);\n\tstruct vkms_output *output = &vkmsdev->output;\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\tif (!READ_ONCE(vblank->enabled)) {\n\t\t*vblank_time = ktime_get();\n\t\treturn true;\n\t}\n\n\t*vblank_time = READ_ONCE(output->vblank_hrtimer.node.expires);\n\n\tif (WARN_ON(*vblank_time == vblank->time))\n\t\treturn true;\n\n\t \n\t*vblank_time -= output->period_ns;\n\n\treturn true;\n}\n\nstatic struct drm_crtc_state *\nvkms_atomic_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct vkms_crtc_state *vkms_state;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\tvkms_state = kzalloc(sizeof(*vkms_state), GFP_KERNEL);\n\tif (!vkms_state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &vkms_state->base);\n\n\tINIT_WORK(&vkms_state->composer_work, vkms_composer_worker);\n\n\treturn &vkms_state->base;\n}\n\nstatic void vkms_atomic_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_crtc_state *state)\n{\n\tstruct vkms_crtc_state *vkms_state = to_vkms_crtc_state(state);\n\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\n\tWARN_ON(work_pending(&vkms_state->composer_work));\n\tkfree(vkms_state->active_planes);\n\tkfree(vkms_state);\n}\n\nstatic void vkms_atomic_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct vkms_crtc_state *vkms_state =\n\t\tkzalloc(sizeof(*vkms_state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tvkms_atomic_crtc_destroy_state(crtc, crtc->state);\n\n\t__drm_atomic_helper_crtc_reset(crtc, &vkms_state->base);\n\tif (vkms_state)\n\t\tINIT_WORK(&vkms_state->composer_work, vkms_composer_worker);\n}\n\nstatic const struct drm_crtc_funcs vkms_crtc_funcs = {\n\t.set_config             = drm_atomic_helper_set_config,\n\t.page_flip              = drm_atomic_helper_page_flip,\n\t.reset                  = vkms_atomic_crtc_reset,\n\t.atomic_duplicate_state = vkms_atomic_crtc_duplicate_state,\n\t.atomic_destroy_state   = vkms_atomic_crtc_destroy_state,\n\t.enable_vblank\t\t= vkms_enable_vblank,\n\t.disable_vblank\t\t= vkms_disable_vblank,\n\t.get_vblank_timestamp\t= vkms_get_vblank_timestamp,\n\t.get_crc_sources\t= vkms_get_crc_sources,\n\t.set_crc_source\t\t= vkms_set_crc_source,\n\t.verify_crc_source\t= vkms_verify_crc_source,\n};\n\nstatic int vkms_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct vkms_crtc_state *vkms_state = to_vkms_crtc_state(crtc_state);\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tint i = 0, ret;\n\n\tif (vkms_state->active_planes)\n\t\treturn 0;\n\n\tret = drm_atomic_add_affected_planes(crtc_state->state, crtc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_for_each_plane_mask(plane, crtc->dev, crtc_state->plane_mask) {\n\t\tplane_state = drm_atomic_get_existing_plane_state(crtc_state->state,\n\t\t\t\t\t\t\t\t  plane);\n\t\tWARN_ON(!plane_state);\n\n\t\tif (!plane_state->visible)\n\t\t\tcontinue;\n\n\t\ti++;\n\t}\n\n\tvkms_state->active_planes = kcalloc(i, sizeof(plane), GFP_KERNEL);\n\tif (!vkms_state->active_planes)\n\t\treturn -ENOMEM;\n\tvkms_state->num_active_planes = i;\n\n\ti = 0;\n\tdrm_for_each_plane_mask(plane, crtc->dev, crtc_state->plane_mask) {\n\t\tplane_state = drm_atomic_get_existing_plane_state(crtc_state->state,\n\t\t\t\t\t\t\t\t  plane);\n\n\t\tif (!plane_state->visible)\n\t\t\tcontinue;\n\n\t\tvkms_state->active_planes[i++] =\n\t\t\tto_vkms_plane_state(plane_state);\n\t}\n\n\treturn 0;\n}\n\nstatic void vkms_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void vkms_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_off(crtc);\n}\n\nstatic void vkms_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);\n\n\t \n\tspin_lock_irq(&vkms_output->lock);\n}\n\nstatic void vkms_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct vkms_output *vkms_output = drm_crtc_to_vkms_output(crtc);\n\n\tif (crtc->state->event) {\n\t\tspin_lock(&crtc->dev->event_lock);\n\n\t\tif (drm_crtc_vblank_get(crtc) != 0)\n\t\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\telse\n\t\t\tdrm_crtc_arm_vblank_event(crtc, crtc->state->event);\n\n\t\tspin_unlock(&crtc->dev->event_lock);\n\n\t\tcrtc->state->event = NULL;\n\t}\n\n\tvkms_output->composer_state = to_vkms_crtc_state(crtc->state);\n\n\tspin_unlock_irq(&vkms_output->lock);\n}\n\nstatic const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs = {\n\t.atomic_check\t= vkms_crtc_atomic_check,\n\t.atomic_begin\t= vkms_crtc_atomic_begin,\n\t.atomic_flush\t= vkms_crtc_atomic_flush,\n\t.atomic_enable\t= vkms_crtc_atomic_enable,\n\t.atomic_disable\t= vkms_crtc_atomic_disable,\n};\n\nint vkms_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,\n\t\t   struct drm_plane *primary, struct drm_plane *cursor)\n{\n\tstruct vkms_output *vkms_out = drm_crtc_to_vkms_output(crtc);\n\tint ret;\n\n\tret = drmm_crtc_init_with_planes(dev, crtc, primary, cursor,\n\t\t\t\t\t &vkms_crtc_funcs, NULL);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to init CRTC\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_helper_add(crtc, &vkms_crtc_helper_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(crtc, VKMS_LUT_SIZE);\n\tdrm_crtc_enable_color_mgmt(crtc, 0, false, VKMS_LUT_SIZE);\n\n\tspin_lock_init(&vkms_out->lock);\n\tspin_lock_init(&vkms_out->composer_lock);\n\n\tvkms_out->composer_workq = alloc_ordered_workqueue(\"vkms_composer\", 0);\n\tif (!vkms_out->composer_workq)\n\t\treturn -ENOMEM;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}