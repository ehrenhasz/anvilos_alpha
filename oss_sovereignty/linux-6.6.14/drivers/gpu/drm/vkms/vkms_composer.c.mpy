{
  "module_name": "vkms_composer.c",
  "hash_id": "3ecf379183da6f9fb38c840a40ae93f9b5d8e09536f16e90b8e8551eb5e09667",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_composer.c",
  "human_readable_source": "\n\n#include <linux/crc32.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_fixed.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_vblank.h>\n#include <linux/minmax.h>\n\n#include \"vkms_drv.h\"\n\nstatic u16 pre_mul_blend_channel(u16 src, u16 dst, u16 alpha)\n{\n\tu32 new_color;\n\n\tnew_color = (src * 0xffff + dst * (0xffff - alpha));\n\n\treturn DIV_ROUND_CLOSEST(new_color, 0xffff);\n}\n\n \nstatic void pre_mul_alpha_blend(struct vkms_frame_info *frame_info,\n\t\t\t\tstruct line_buffer *stage_buffer,\n\t\t\t\tstruct line_buffer *output_buffer)\n{\n\tint x_dst = frame_info->dst.x1;\n\tstruct pixel_argb_u16 *out = output_buffer->pixels + x_dst;\n\tstruct pixel_argb_u16 *in = stage_buffer->pixels;\n\tint x_limit = min_t(size_t, drm_rect_width(&frame_info->dst),\n\t\t\t    stage_buffer->n_pixels);\n\n\tfor (int x = 0; x < x_limit; x++) {\n\t\tout[x].a = (u16)0xffff;\n\t\tout[x].r = pre_mul_blend_channel(in[x].r, out[x].r, in[x].a);\n\t\tout[x].g = pre_mul_blend_channel(in[x].g, out[x].g, in[x].a);\n\t\tout[x].b = pre_mul_blend_channel(in[x].b, out[x].b, in[x].a);\n\t}\n}\n\nstatic int get_y_pos(struct vkms_frame_info *frame_info, int y)\n{\n\tif (frame_info->rotation & DRM_MODE_REFLECT_Y)\n\t\treturn drm_rect_height(&frame_info->rotated) - y - 1;\n\n\tswitch (frame_info->rotation & DRM_MODE_ROTATE_MASK) {\n\tcase DRM_MODE_ROTATE_90:\n\t\treturn frame_info->rotated.x2 - y - 1;\n\tcase DRM_MODE_ROTATE_270:\n\t\treturn y + frame_info->rotated.x1;\n\tdefault:\n\t\treturn y;\n\t}\n}\n\nstatic bool check_limit(struct vkms_frame_info *frame_info, int pos)\n{\n\tif (drm_rotation_90_or_270(frame_info->rotation)) {\n\t\tif (pos >= 0 && pos < drm_rect_width(&frame_info->rotated))\n\t\t\treturn true;\n\t} else {\n\t\tif (pos >= frame_info->rotated.y1 && pos < frame_info->rotated.y2)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void fill_background(const struct pixel_argb_u16 *background_color,\n\t\t\t    struct line_buffer *output_buffer)\n{\n\tfor (size_t i = 0; i < output_buffer->n_pixels; i++)\n\t\toutput_buffer->pixels[i] = *background_color;\n}\n\n \nstatic u16 lerp_u16(u16 a, u16 b, s64 t)\n{\n\ts64 a_fp = drm_int2fixp(a);\n\ts64 b_fp = drm_int2fixp(b);\n\n\ts64 delta = drm_fixp_mul(b_fp - a_fp,  t);\n\n\treturn drm_fixp2int(a_fp + delta);\n}\n\nstatic s64 get_lut_index(const struct vkms_color_lut *lut, u16 channel_value)\n{\n\ts64 color_channel_fp = drm_int2fixp(channel_value);\n\n\treturn drm_fixp_mul(color_channel_fp, lut->channel_value2index_ratio);\n}\n\n \nenum lut_channel {\n\tLUT_RED = 0,\n\tLUT_GREEN,\n\tLUT_BLUE,\n\tLUT_RESERVED\n};\n\nstatic u16 apply_lut_to_channel_value(const struct vkms_color_lut *lut, u16 channel_value,\n\t\t\t\t      enum lut_channel channel)\n{\n\ts64 lut_index = get_lut_index(lut, channel_value);\n\n\t \n\tstatic_assert(sizeof(struct drm_color_lut) == sizeof(__u16) * 4);\n\n\tu16 *floor_lut_value = (__u16 *)&lut->base[drm_fixp2int(lut_index)];\n\tu16 *ceil_lut_value = (__u16 *)&lut->base[drm_fixp2int_ceil(lut_index)];\n\n\tu16 floor_channel_value = floor_lut_value[channel];\n\tu16 ceil_channel_value = ceil_lut_value[channel];\n\n\treturn lerp_u16(floor_channel_value, ceil_channel_value,\n\t\t\tlut_index & DRM_FIXED_DECIMAL_MASK);\n}\n\nstatic void apply_lut(const struct vkms_crtc_state *crtc_state, struct line_buffer *output_buffer)\n{\n\tif (!crtc_state->gamma_lut.base)\n\t\treturn;\n\n\tif (!crtc_state->gamma_lut.lut_length)\n\t\treturn;\n\n\tfor (size_t x = 0; x < output_buffer->n_pixels; x++) {\n\t\tstruct pixel_argb_u16 *pixel = &output_buffer->pixels[x];\n\n\t\tpixel->r = apply_lut_to_channel_value(&crtc_state->gamma_lut, pixel->r, LUT_RED);\n\t\tpixel->g = apply_lut_to_channel_value(&crtc_state->gamma_lut, pixel->g, LUT_GREEN);\n\t\tpixel->b = apply_lut_to_channel_value(&crtc_state->gamma_lut, pixel->b, LUT_BLUE);\n\t}\n}\n\n \nstatic void blend(struct vkms_writeback_job *wb,\n\t\t  struct vkms_crtc_state *crtc_state,\n\t\t  u32 *crc32, struct line_buffer *stage_buffer,\n\t\t  struct line_buffer *output_buffer, size_t row_size)\n{\n\tstruct vkms_plane_state **plane = crtc_state->active_planes;\n\tu32 n_active_planes = crtc_state->num_active_planes;\n\tint y_pos;\n\n\tconst struct pixel_argb_u16 background_color = { .a = 0xffff };\n\n\tsize_t crtc_y_limit = crtc_state->base.crtc->mode.vdisplay;\n\n\tfor (size_t y = 0; y < crtc_y_limit; y++) {\n\t\tfill_background(&background_color, output_buffer);\n\n\t\t \n\t\tfor (size_t i = 0; i < n_active_planes; i++) {\n\t\t\ty_pos = get_y_pos(plane[i]->frame_info, y);\n\n\t\t\tif (!check_limit(plane[i]->frame_info, y_pos))\n\t\t\t\tcontinue;\n\n\t\t\tvkms_compose_row(stage_buffer, plane[i], y_pos);\n\t\t\tpre_mul_alpha_blend(plane[i]->frame_info, stage_buffer,\n\t\t\t\t\t    output_buffer);\n\t\t}\n\n\t\tapply_lut(crtc_state, output_buffer);\n\n\t\t*crc32 = crc32_le(*crc32, (void *)output_buffer->pixels, row_size);\n\n\t\tif (wb)\n\t\t\tvkms_writeback_row(wb, output_buffer, y_pos);\n\t}\n}\n\nstatic int check_format_funcs(struct vkms_crtc_state *crtc_state,\n\t\t\t      struct vkms_writeback_job *active_wb)\n{\n\tstruct vkms_plane_state **planes = crtc_state->active_planes;\n\tu32 n_active_planes = crtc_state->num_active_planes;\n\n\tfor (size_t i = 0; i < n_active_planes; i++)\n\t\tif (!planes[i]->pixel_read)\n\t\t\treturn -1;\n\n\tif (active_wb && !active_wb->pixel_write)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int check_iosys_map(struct vkms_crtc_state *crtc_state)\n{\n\tstruct vkms_plane_state **plane_state = crtc_state->active_planes;\n\tu32 n_active_planes = crtc_state->num_active_planes;\n\n\tfor (size_t i = 0; i < n_active_planes; i++)\n\t\tif (iosys_map_is_null(&plane_state[i]->frame_info->map[0]))\n\t\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int compose_active_planes(struct vkms_writeback_job *active_wb,\n\t\t\t\t struct vkms_crtc_state *crtc_state,\n\t\t\t\t u32 *crc32)\n{\n\tsize_t line_width, pixel_size = sizeof(struct pixel_argb_u16);\n\tstruct line_buffer output_buffer, stage_buffer;\n\tint ret = 0;\n\n\t \n\tstatic_assert(sizeof(struct pixel_argb_u16) == 8);\n\n\tif (WARN_ON(check_iosys_map(crtc_state)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(check_format_funcs(crtc_state, active_wb)))\n\t\treturn -EINVAL;\n\n\tline_width = crtc_state->base.crtc->mode.hdisplay;\n\tstage_buffer.n_pixels = line_width;\n\toutput_buffer.n_pixels = line_width;\n\n\tstage_buffer.pixels = kvmalloc(line_width * pixel_size, GFP_KERNEL);\n\tif (!stage_buffer.pixels) {\n\t\tDRM_ERROR(\"Cannot allocate memory for the output line buffer\");\n\t\treturn -ENOMEM;\n\t}\n\n\toutput_buffer.pixels = kvmalloc(line_width * pixel_size, GFP_KERNEL);\n\tif (!output_buffer.pixels) {\n\t\tDRM_ERROR(\"Cannot allocate memory for intermediate line buffer\");\n\t\tret = -ENOMEM;\n\t\tgoto free_stage_buffer;\n\t}\n\n\tblend(active_wb, crtc_state, crc32, &stage_buffer,\n\t      &output_buffer, line_width * pixel_size);\n\n\tkvfree(output_buffer.pixels);\nfree_stage_buffer:\n\tkvfree(stage_buffer.pixels);\n\n\treturn ret;\n}\n\n \nvoid vkms_composer_worker(struct work_struct *work)\n{\n\tstruct vkms_crtc_state *crtc_state = container_of(work,\n\t\t\t\t\t\tstruct vkms_crtc_state,\n\t\t\t\t\t\tcomposer_work);\n\tstruct drm_crtc *crtc = crtc_state->base.crtc;\n\tstruct vkms_writeback_job *active_wb = crtc_state->active_writeback;\n\tstruct vkms_output *out = drm_crtc_to_vkms_output(crtc);\n\tbool crc_pending, wb_pending;\n\tu64 frame_start, frame_end;\n\tu32 crc32 = 0;\n\tint ret;\n\n\tspin_lock_irq(&out->composer_lock);\n\tframe_start = crtc_state->frame_start;\n\tframe_end = crtc_state->frame_end;\n\tcrc_pending = crtc_state->crc_pending;\n\twb_pending = crtc_state->wb_pending;\n\tcrtc_state->frame_start = 0;\n\tcrtc_state->frame_end = 0;\n\tcrtc_state->crc_pending = false;\n\n\tif (crtc->state->gamma_lut) {\n\t\ts64 max_lut_index_fp;\n\t\ts64 u16_max_fp = drm_int2fixp(0xffff);\n\n\t\tcrtc_state->gamma_lut.base = (struct drm_color_lut *)crtc->state->gamma_lut->data;\n\t\tcrtc_state->gamma_lut.lut_length =\n\t\t\tcrtc->state->gamma_lut->length / sizeof(struct drm_color_lut);\n\t\tmax_lut_index_fp = drm_int2fixp(crtc_state->gamma_lut.lut_length  - 1);\n\t\tcrtc_state->gamma_lut.channel_value2index_ratio = drm_fixp_div(max_lut_index_fp,\n\t\t\t\t\t\t\t\t\t       u16_max_fp);\n\n\t} else {\n\t\tcrtc_state->gamma_lut.base = NULL;\n\t}\n\n\tspin_unlock_irq(&out->composer_lock);\n\n\t \n\tif (!crc_pending)\n\t\treturn;\n\n\tif (wb_pending)\n\t\tret = compose_active_planes(active_wb, crtc_state, &crc32);\n\telse\n\t\tret = compose_active_planes(NULL, crtc_state, &crc32);\n\n\tif (ret)\n\t\treturn;\n\n\tif (wb_pending) {\n\t\tdrm_writeback_signal_completion(&out->wb_connector, 0);\n\t\tspin_lock_irq(&out->composer_lock);\n\t\tcrtc_state->wb_pending = false;\n\t\tspin_unlock_irq(&out->composer_lock);\n\t}\n\n\t \n\twhile (frame_start <= frame_end)\n\t\tdrm_crtc_add_crc_entry(crtc, true, frame_start++, &crc32);\n}\n\nstatic const char * const pipe_crc_sources[] = {\"auto\"};\n\nconst char *const *vkms_get_crc_sources(struct drm_crtc *crtc,\n\t\t\t\t\tsize_t *count)\n{\n\t*count = ARRAY_SIZE(pipe_crc_sources);\n\treturn pipe_crc_sources;\n}\n\nstatic int vkms_crc_parse_source(const char *src_name, bool *enabled)\n{\n\tint ret = 0;\n\n\tif (!src_name) {\n\t\t*enabled = false;\n\t} else if (strcmp(src_name, \"auto\") == 0) {\n\t\t*enabled = true;\n\t} else {\n\t\t*enabled = false;\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nint vkms_verify_crc_source(struct drm_crtc *crtc, const char *src_name,\n\t\t\t   size_t *values_cnt)\n{\n\tbool enabled;\n\n\tif (vkms_crc_parse_source(src_name, &enabled) < 0) {\n\t\tDRM_DEBUG_DRIVER(\"unknown source %s\\n\", src_name);\n\t\treturn -EINVAL;\n\t}\n\n\t*values_cnt = 1;\n\n\treturn 0;\n}\n\nvoid vkms_set_composer(struct vkms_output *out, bool enabled)\n{\n\tbool old_enabled;\n\n\tif (enabled)\n\t\tdrm_crtc_vblank_get(&out->crtc);\n\n\tspin_lock_irq(&out->lock);\n\told_enabled = out->composer_enabled;\n\tout->composer_enabled = enabled;\n\tspin_unlock_irq(&out->lock);\n\n\tif (old_enabled)\n\t\tdrm_crtc_vblank_put(&out->crtc);\n}\n\nint vkms_set_crc_source(struct drm_crtc *crtc, const char *src_name)\n{\n\tstruct vkms_output *out = drm_crtc_to_vkms_output(crtc);\n\tbool enabled = false;\n\tint ret = 0;\n\n\tret = vkms_crc_parse_source(src_name, &enabled);\n\n\tvkms_set_composer(out, enabled);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}