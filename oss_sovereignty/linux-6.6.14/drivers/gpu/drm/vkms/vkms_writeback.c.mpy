{
  "module_name": "vkms_writeback.c",
  "hash_id": "577415b964698eb8e0e0a06ff6492346b6921717d39ba551ce532c8e8986f8dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_writeback.c",
  "human_readable_source": "\n\n#include <linux/iosys-map.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_writeback.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_gem_shmem_helper.h>\n\n#include \"vkms_drv.h\"\n#include \"vkms_formats.h\"\n\nstatic const u32 vkms_wb_formats[] = {\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XRGB16161616,\n\tDRM_FORMAT_ARGB16161616,\n\tDRM_FORMAT_RGB565\n};\n\nstatic const struct drm_connector_funcs vkms_wb_connector_funcs = {\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = drm_connector_cleanup,\n\t.reset = drm_atomic_helper_connector_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int vkms_wb_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct drm_framebuffer *fb;\n\tconst struct drm_display_mode *mode = &crtc_state->mode;\n\tint ret;\n\n\tif (!conn_state->writeback_job || !conn_state->writeback_job->fb)\n\t\treturn 0;\n\n\tfb = conn_state->writeback_job->fb;\n\tif (fb->width != mode->hdisplay || fb->height != mode->vdisplay) {\n\t\tDRM_DEBUG_KMS(\"Invalid framebuffer size %ux%u\\n\",\n\t\t\t      fb->width, fb->height);\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_atomic_helper_check_wb_encoder_state(encoder, conn_state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs vkms_wb_encoder_helper_funcs = {\n\t.atomic_check = vkms_wb_encoder_atomic_check,\n};\n\nstatic int vkms_wb_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\treturn drm_add_modes_noedid(connector, dev->mode_config.max_width,\n\t\t\t\t    dev->mode_config.max_height);\n}\n\nstatic int vkms_wb_prepare_job(struct drm_writeback_connector *wb_connector,\n\t\t\t       struct drm_writeback_job *job)\n{\n\tstruct vkms_writeback_job *vkmsjob;\n\tint ret;\n\n\tif (!job->fb)\n\t\treturn 0;\n\n\tvkmsjob = kzalloc(sizeof(*vkmsjob), GFP_KERNEL);\n\tif (!vkmsjob)\n\t\treturn -ENOMEM;\n\n\tret = drm_gem_fb_vmap(job->fb, vkmsjob->wb_frame_info.map, vkmsjob->data);\n\tif (ret) {\n\t\tDRM_ERROR(\"vmap failed: %d\\n\", ret);\n\t\tgoto err_kfree;\n\t}\n\n\tvkmsjob->wb_frame_info.fb = job->fb;\n\tdrm_framebuffer_get(vkmsjob->wb_frame_info.fb);\n\n\tjob->priv = vkmsjob;\n\n\treturn 0;\n\nerr_kfree:\n\tkfree(vkmsjob);\n\treturn ret;\n}\n\nstatic void vkms_wb_cleanup_job(struct drm_writeback_connector *connector,\n\t\t\t\tstruct drm_writeback_job *job)\n{\n\tstruct vkms_writeback_job *vkmsjob = job->priv;\n\tstruct vkms_device *vkmsdev;\n\n\tif (!job->fb)\n\t\treturn;\n\n\tdrm_gem_fb_vunmap(job->fb, vkmsjob->wb_frame_info.map);\n\n\tdrm_framebuffer_put(vkmsjob->wb_frame_info.fb);\n\n\tvkmsdev = drm_device_to_vkms_device(job->fb->dev);\n\tvkms_set_composer(&vkmsdev->output, false);\n\tkfree(vkmsjob);\n}\n\nstatic void vkms_wb_atomic_commit(struct drm_connector *conn,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *connector_state = drm_atomic_get_new_connector_state(state,\n\t\t\t\t\t\t\t\t\t\t\t conn);\n\tstruct vkms_device *vkmsdev = drm_device_to_vkms_device(conn->dev);\n\tstruct vkms_output *output = &vkmsdev->output;\n\tstruct drm_writeback_connector *wb_conn = &output->wb_connector;\n\tstruct drm_connector_state *conn_state = wb_conn->base.state;\n\tstruct vkms_crtc_state *crtc_state = output->composer_state;\n\tstruct drm_framebuffer *fb = connector_state->writeback_job->fb;\n\tu16 crtc_height = crtc_state->base.crtc->mode.vdisplay;\n\tu16 crtc_width = crtc_state->base.crtc->mode.hdisplay;\n\tstruct vkms_writeback_job *active_wb;\n\tstruct vkms_frame_info *wb_frame_info;\n\tu32 wb_format = fb->format->format;\n\n\tif (!conn_state)\n\t\treturn;\n\n\tvkms_set_composer(&vkmsdev->output, true);\n\n\tactive_wb = conn_state->writeback_job->priv;\n\twb_frame_info = &active_wb->wb_frame_info;\n\n\tspin_lock_irq(&output->composer_lock);\n\tcrtc_state->active_writeback = active_wb;\n\tcrtc_state->wb_pending = true;\n\tspin_unlock_irq(&output->composer_lock);\n\n\twb_frame_info->offset = fb->offsets[0];\n\twb_frame_info->pitch = fb->pitches[0];\n\twb_frame_info->cpp = fb->format->cpp[0];\n\n\tdrm_writeback_queue_job(wb_conn, connector_state);\n\tactive_wb->pixel_write = get_pixel_write_function(wb_format);\n\tdrm_rect_init(&wb_frame_info->src, 0, 0, crtc_width, crtc_height);\n\tdrm_rect_init(&wb_frame_info->dst, 0, 0, crtc_width, crtc_height);\n}\n\nstatic const struct drm_connector_helper_funcs vkms_wb_conn_helper_funcs = {\n\t.get_modes = vkms_wb_connector_get_modes,\n\t.prepare_writeback_job = vkms_wb_prepare_job,\n\t.cleanup_writeback_job = vkms_wb_cleanup_job,\n\t.atomic_commit = vkms_wb_atomic_commit,\n};\n\nint vkms_enable_writeback_connector(struct vkms_device *vkmsdev)\n{\n\tstruct drm_writeback_connector *wb = &vkmsdev->output.wb_connector;\n\n\tdrm_connector_helper_add(&wb->base, &vkms_wb_conn_helper_funcs);\n\n\treturn drm_writeback_connector_init(&vkmsdev->drm, wb,\n\t\t\t\t\t    &vkms_wb_connector_funcs,\n\t\t\t\t\t    &vkms_wb_encoder_helper_funcs,\n\t\t\t\t\t    vkms_wb_formats,\n\t\t\t\t\t    ARRAY_SIZE(vkms_wb_formats),\n\t\t\t\t\t    1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}