{
  "module_name": "vkms_formats.c",
  "hash_id": "c535a7083a32a22005c7b25cce6469b5ab4d8b53366700c23c12c94f466a7b82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/vkms/vkms_formats.c",
  "human_readable_source": "\n\n#include <linux/kernel.h>\n#include <linux/minmax.h>\n\n#include <drm/drm_blend.h>\n#include <drm/drm_rect.h>\n#include <drm/drm_fixed.h>\n\n#include \"vkms_formats.h\"\n\nstatic size_t pixel_offset(const struct vkms_frame_info *frame_info, int x, int y)\n{\n\treturn frame_info->offset + (y * frame_info->pitch)\n\t\t\t\t  + (x * frame_info->cpp);\n}\n\n \nstatic void *packed_pixels_addr(const struct vkms_frame_info *frame_info,\n\t\t\t\tint x, int y)\n{\n\tsize_t offset = pixel_offset(frame_info, x, y);\n\n\treturn (u8 *)frame_info->map[0].vaddr + offset;\n}\n\nstatic void *get_packed_src_addr(const struct vkms_frame_info *frame_info, int y)\n{\n\tint x_src = frame_info->src.x1 >> 16;\n\tint y_src = y - frame_info->rotated.y1 + (frame_info->src.y1 >> 16);\n\n\treturn packed_pixels_addr(frame_info, x_src, y_src);\n}\n\nstatic int get_x_position(const struct vkms_frame_info *frame_info, int limit, int x)\n{\n\tif (frame_info->rotation & (DRM_MODE_REFLECT_X | DRM_MODE_ROTATE_270))\n\t\treturn limit - x - 1;\n\treturn x;\n}\n\nstatic void ARGB8888_to_argb_u16(u8 *src_pixels, struct pixel_argb_u16 *out_pixel)\n{\n\t \n\tout_pixel->a = (u16)src_pixels[3] * 257;\n\tout_pixel->r = (u16)src_pixels[2] * 257;\n\tout_pixel->g = (u16)src_pixels[1] * 257;\n\tout_pixel->b = (u16)src_pixels[0] * 257;\n}\n\nstatic void XRGB8888_to_argb_u16(u8 *src_pixels, struct pixel_argb_u16 *out_pixel)\n{\n\tout_pixel->a = (u16)0xffff;\n\tout_pixel->r = (u16)src_pixels[2] * 257;\n\tout_pixel->g = (u16)src_pixels[1] * 257;\n\tout_pixel->b = (u16)src_pixels[0] * 257;\n}\n\nstatic void ARGB16161616_to_argb_u16(u8 *src_pixels, struct pixel_argb_u16 *out_pixel)\n{\n\tu16 *pixels = (u16 *)src_pixels;\n\n\tout_pixel->a = le16_to_cpu(pixels[3]);\n\tout_pixel->r = le16_to_cpu(pixels[2]);\n\tout_pixel->g = le16_to_cpu(pixels[1]);\n\tout_pixel->b = le16_to_cpu(pixels[0]);\n}\n\nstatic void XRGB16161616_to_argb_u16(u8 *src_pixels, struct pixel_argb_u16 *out_pixel)\n{\n\tu16 *pixels = (u16 *)src_pixels;\n\n\tout_pixel->a = (u16)0xffff;\n\tout_pixel->r = le16_to_cpu(pixels[2]);\n\tout_pixel->g = le16_to_cpu(pixels[1]);\n\tout_pixel->b = le16_to_cpu(pixels[0]);\n}\n\nstatic void RGB565_to_argb_u16(u8 *src_pixels, struct pixel_argb_u16 *out_pixel)\n{\n\tu16 *pixels = (u16 *)src_pixels;\n\n\ts64 fp_rb_ratio = drm_fixp_div(drm_int2fixp(65535), drm_int2fixp(31));\n\ts64 fp_g_ratio = drm_fixp_div(drm_int2fixp(65535), drm_int2fixp(63));\n\n\tu16 rgb_565 = le16_to_cpu(*pixels);\n\ts64 fp_r = drm_int2fixp((rgb_565 >> 11) & 0x1f);\n\ts64 fp_g = drm_int2fixp((rgb_565 >> 5) & 0x3f);\n\ts64 fp_b = drm_int2fixp(rgb_565 & 0x1f);\n\n\tout_pixel->a = (u16)0xffff;\n\tout_pixel->r = drm_fixp2int_round(drm_fixp_mul(fp_r, fp_rb_ratio));\n\tout_pixel->g = drm_fixp2int_round(drm_fixp_mul(fp_g, fp_g_ratio));\n\tout_pixel->b = drm_fixp2int_round(drm_fixp_mul(fp_b, fp_rb_ratio));\n}\n\n \nvoid vkms_compose_row(struct line_buffer *stage_buffer, struct vkms_plane_state *plane, int y)\n{\n\tstruct pixel_argb_u16 *out_pixels = stage_buffer->pixels;\n\tstruct vkms_frame_info *frame_info = plane->frame_info;\n\tu8 *src_pixels = get_packed_src_addr(frame_info, y);\n\tint limit = min_t(size_t, drm_rect_width(&frame_info->dst), stage_buffer->n_pixels);\n\n\tfor (size_t x = 0; x < limit; x++, src_pixels += frame_info->cpp) {\n\t\tint x_pos = get_x_position(frame_info, limit, x);\n\n\t\tif (drm_rotation_90_or_270(frame_info->rotation))\n\t\t\tsrc_pixels = get_packed_src_addr(frame_info, x + frame_info->rotated.y1)\n\t\t\t\t+ frame_info->cpp * y;\n\n\t\tplane->pixel_read(src_pixels, &out_pixels[x_pos]);\n\t}\n}\n\n \nstatic void argb_u16_to_ARGB8888(u8 *dst_pixels, struct pixel_argb_u16 *in_pixel)\n{\n\t \n\tdst_pixels[3] = DIV_ROUND_CLOSEST(in_pixel->a, 257);\n\tdst_pixels[2] = DIV_ROUND_CLOSEST(in_pixel->r, 257);\n\tdst_pixels[1] = DIV_ROUND_CLOSEST(in_pixel->g, 257);\n\tdst_pixels[0] = DIV_ROUND_CLOSEST(in_pixel->b, 257);\n}\n\nstatic void argb_u16_to_XRGB8888(u8 *dst_pixels, struct pixel_argb_u16 *in_pixel)\n{\n\tdst_pixels[3] = 0xff;\n\tdst_pixels[2] = DIV_ROUND_CLOSEST(in_pixel->r, 257);\n\tdst_pixels[1] = DIV_ROUND_CLOSEST(in_pixel->g, 257);\n\tdst_pixels[0] = DIV_ROUND_CLOSEST(in_pixel->b, 257);\n}\n\nstatic void argb_u16_to_ARGB16161616(u8 *dst_pixels, struct pixel_argb_u16 *in_pixel)\n{\n\tu16 *pixels = (u16 *)dst_pixels;\n\n\tpixels[3] = cpu_to_le16(in_pixel->a);\n\tpixels[2] = cpu_to_le16(in_pixel->r);\n\tpixels[1] = cpu_to_le16(in_pixel->g);\n\tpixels[0] = cpu_to_le16(in_pixel->b);\n}\n\nstatic void argb_u16_to_XRGB16161616(u8 *dst_pixels, struct pixel_argb_u16 *in_pixel)\n{\n\tu16 *pixels = (u16 *)dst_pixels;\n\n\tpixels[3] = 0xffff;\n\tpixels[2] = cpu_to_le16(in_pixel->r);\n\tpixels[1] = cpu_to_le16(in_pixel->g);\n\tpixels[0] = cpu_to_le16(in_pixel->b);\n}\n\nstatic void argb_u16_to_RGB565(u8 *dst_pixels, struct pixel_argb_u16 *in_pixel)\n{\n\tu16 *pixels = (u16 *)dst_pixels;\n\n\ts64 fp_rb_ratio = drm_fixp_div(drm_int2fixp(65535), drm_int2fixp(31));\n\ts64 fp_g_ratio = drm_fixp_div(drm_int2fixp(65535), drm_int2fixp(63));\n\n\ts64 fp_r = drm_int2fixp(in_pixel->r);\n\ts64 fp_g = drm_int2fixp(in_pixel->g);\n\ts64 fp_b = drm_int2fixp(in_pixel->b);\n\n\tu16 r = drm_fixp2int(drm_fixp_div(fp_r, fp_rb_ratio));\n\tu16 g = drm_fixp2int(drm_fixp_div(fp_g, fp_g_ratio));\n\tu16 b = drm_fixp2int(drm_fixp_div(fp_b, fp_rb_ratio));\n\n\t*pixels = cpu_to_le16(r << 11 | g << 5 | b);\n}\n\nvoid vkms_writeback_row(struct vkms_writeback_job *wb,\n\t\t\tconst struct line_buffer *src_buffer, int y)\n{\n\tstruct vkms_frame_info *frame_info = &wb->wb_frame_info;\n\tint x_dst = frame_info->dst.x1;\n\tu8 *dst_pixels = packed_pixels_addr(frame_info, x_dst, y);\n\tstruct pixel_argb_u16 *in_pixels = src_buffer->pixels;\n\tint x_limit = min_t(size_t, drm_rect_width(&frame_info->dst), src_buffer->n_pixels);\n\n\tfor (size_t x = 0; x < x_limit; x++, dst_pixels += frame_info->cpp)\n\t\twb->pixel_write(dst_pixels, &in_pixels[x]);\n}\n\nvoid *get_pixel_conversion_function(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn &ARGB8888_to_argb_u16;\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn &XRGB8888_to_argb_u16;\n\tcase DRM_FORMAT_ARGB16161616:\n\t\treturn &ARGB16161616_to_argb_u16;\n\tcase DRM_FORMAT_XRGB16161616:\n\t\treturn &XRGB16161616_to_argb_u16;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn &RGB565_to_argb_u16;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nvoid *get_pixel_write_function(u32 format)\n{\n\tswitch (format) {\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn &argb_u16_to_ARGB8888;\n\tcase DRM_FORMAT_XRGB8888:\n\t\treturn &argb_u16_to_XRGB8888;\n\tcase DRM_FORMAT_ARGB16161616:\n\t\treturn &argb_u16_to_ARGB16161616;\n\tcase DRM_FORMAT_XRGB16161616:\n\t\treturn &argb_u16_to_XRGB16161616;\n\tcase DRM_FORMAT_RGB565:\n\t\treturn &argb_u16_to_RGB565;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}