{
  "module_name": "ingenic-ipu.c",
  "hash_id": "380f0a98bb1fa5465d3cc3e8447399afdbf5301437c27342d3c3df28e9b512ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ingenic/ingenic-ipu.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include \"ingenic-drm.h\"\n#include \"ingenic-ipu.h\"\n\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/gcd.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/time.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_property.h>\n#include <drm/drm_vblank.h>\n\nstruct ingenic_ipu;\n\nstruct soc_info {\n\tconst u32 *formats;\n\tsize_t num_formats;\n\tbool has_bicubic;\n\tbool manual_restart;\n\n\tvoid (*set_coefs)(struct ingenic_ipu *ipu, unsigned int reg,\n\t\t\t  unsigned int sharpness, bool downscale,\n\t\t\t  unsigned int weight, unsigned int offset);\n};\n\nstruct ingenic_ipu_private_state {\n\tstruct drm_private_state base;\n\n\tunsigned int num_w, num_h, denom_w, denom_h;\n};\n\nstruct ingenic_ipu {\n\tstruct drm_plane plane;\n\tstruct drm_device *drm;\n\tstruct device *dev, *master;\n\tstruct regmap *map;\n\tstruct clk *clk;\n\tconst struct soc_info *soc_info;\n\tbool clk_enabled;\n\n\tdma_addr_t addr_y, addr_u, addr_v;\n\n\tstruct drm_property *sharpness_prop;\n\tunsigned int sharpness;\n\n\tstruct drm_private_obj private_obj;\n};\n\n \n#define I2F(i) ((s32)(i) * 65536)\n#define F2I(f) ((f) / 65536)\n#define FMUL(fa, fb) ((s32)(((s64)(fa) * (s64)(fb)) / 65536))\n#define SHARPNESS_INCR (I2F(-1) / 8)\n\nstatic inline struct ingenic_ipu *plane_to_ingenic_ipu(struct drm_plane *plane)\n{\n\treturn container_of(plane, struct ingenic_ipu, plane);\n}\n\nstatic inline struct ingenic_ipu_private_state *\nto_ingenic_ipu_priv_state(struct drm_private_state *state)\n{\n\treturn container_of(state, struct ingenic_ipu_private_state, base);\n}\n\nstatic struct ingenic_ipu_private_state *\ningenic_ipu_get_priv_state(struct ingenic_ipu *priv, struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_state;\n\n\tpriv_state = drm_atomic_get_private_obj_state(state, &priv->private_obj);\n\tif (IS_ERR(priv_state))\n\t\treturn ERR_CAST(priv_state);\n\n\treturn to_ingenic_ipu_priv_state(priv_state);\n}\n\nstatic struct ingenic_ipu_private_state *\ningenic_ipu_get_new_priv_state(struct ingenic_ipu *priv, struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_state;\n\n\tpriv_state = drm_atomic_get_new_private_obj_state(state, &priv->private_obj);\n\tif (!priv_state)\n\t\treturn NULL;\n\n\treturn to_ingenic_ipu_priv_state(priv_state);\n}\n\n \nstatic inline s32 cubic_conv(s32 f_a, s32 f_x)\n{\n\tconst s32 f_1 = I2F(1);\n\tconst s32 f_2 = I2F(2);\n\tconst s32 f_3 = I2F(3);\n\tconst s32 f_4 = I2F(4);\n\tconst s32 f_x2 = FMUL(f_x, f_x);\n\tconst s32 f_x3 = FMUL(f_x, f_x2);\n\n\tif (f_x <= f_1)\n\t\treturn FMUL((f_a + f_2), f_x3) - FMUL((f_a + f_3), f_x2) + f_1;\n\telse if (f_x <= f_2)\n\t\treturn FMUL(f_a, (f_x3 - 5 * f_x2 + 8 * f_x - f_4));\n\telse\n\t\treturn 0;\n}\n\n \nstatic void jz4760_set_coefs(struct ingenic_ipu *ipu, unsigned int reg,\n\t\t\t     unsigned int sharpness, bool downscale,\n\t\t\t     unsigned int weight, unsigned int offset)\n{\n\tu32 val;\n\ts32 w0, w1, w2, w3;  \n\n\tweight = clamp_val(weight, 0, 512);\n\n\tif (sharpness < 2) {\n\t\t \n\n\t\tif (sharpness == 0)\n\t\t\tweight = weight >= 256 ? 512 : 0;\n\t\tw0 = 0;\n\t\tw1 = weight;\n\t\tw2 = 512 - weight;\n\t\tw3 = 0;\n\t} else {\n\t\tconst s32 f_a = SHARPNESS_INCR * sharpness;\n\t\tconst s32 f_h = I2F(1) / 2;  \n\n\t\t \n\n\t\tweight = 512 - weight;\n\t\tw0 = F2I(f_h + 512 * cubic_conv(f_a, I2F(512  + weight) / 512));\n\t\tw1 = F2I(f_h + 512 * cubic_conv(f_a, I2F(0    + weight) / 512));\n\t\tw2 = F2I(f_h + 512 * cubic_conv(f_a, I2F(512  - weight) / 512));\n\t\tw3 = F2I(f_h + 512 * cubic_conv(f_a, I2F(1024 - weight) / 512));\n\t\tw0 = clamp_val(w0, -1024, 1023);\n\t\tw1 = clamp_val(w1, -1024, 1023);\n\t\tw2 = clamp_val(w2, -1024, 1023);\n\t\tw3 = clamp_val(w3, -1024, 1023);\n\t}\n\n\tval = ((w1 & JZ4760_IPU_RSZ_COEF_MASK) << JZ4760_IPU_RSZ_COEF31_LSB) |\n\t\t((w0 & JZ4760_IPU_RSZ_COEF_MASK) << JZ4760_IPU_RSZ_COEF20_LSB);\n\tregmap_write(ipu->map, reg, val);\n\n\tval = ((w3 & JZ4760_IPU_RSZ_COEF_MASK) << JZ4760_IPU_RSZ_COEF31_LSB) |\n\t\t((w2 & JZ4760_IPU_RSZ_COEF_MASK) << JZ4760_IPU_RSZ_COEF20_LSB) |\n\t\t((offset & JZ4760_IPU_RSZ_OFFSET_MASK) << JZ4760_IPU_RSZ_OFFSET_LSB);\n\tregmap_write(ipu->map, reg, val);\n}\n\nstatic void jz4725b_set_coefs(struct ingenic_ipu *ipu, unsigned int reg,\n\t\t\t      unsigned int sharpness, bool downscale,\n\t\t\t      unsigned int weight, unsigned int offset)\n{\n\tu32 val = JZ4725B_IPU_RSZ_LUT_OUT_EN;\n\tunsigned int i;\n\n\tweight = clamp_val(weight, 0, 512);\n\n\tif (sharpness == 0)\n\t\tweight = weight >= 256 ? 512 : 0;\n\n\tval |= (weight & JZ4725B_IPU_RSZ_LUT_COEF_MASK) << JZ4725B_IPU_RSZ_LUT_COEF_LSB;\n\tif (downscale || !!offset)\n\t\tval |= JZ4725B_IPU_RSZ_LUT_IN_EN;\n\n\tregmap_write(ipu->map, reg, val);\n\n\tif (downscale) {\n\t\tfor (i = 1; i < offset; i++)\n\t\t\tregmap_write(ipu->map, reg, JZ4725B_IPU_RSZ_LUT_IN_EN);\n\t}\n}\n\nstatic void ingenic_ipu_set_downscale_coefs(struct ingenic_ipu *ipu,\n\t\t\t\t\t    unsigned int reg,\n\t\t\t\t\t    unsigned int num,\n\t\t\t\t\t    unsigned int denom)\n{\n\tunsigned int i, offset, weight, weight_num = denom;\n\n\tfor (i = 0; i < num; i++) {\n\t\tweight_num = num + (weight_num - num) % (num * 2);\n\t\tweight = 512 - 512 * (weight_num - num) / (num * 2);\n\t\tweight_num += denom * 2;\n\t\toffset = (weight_num - num) / (num * 2);\n\n\t\tipu->soc_info->set_coefs(ipu, reg, ipu->sharpness,\n\t\t\t\t\t true, weight, offset);\n\t}\n}\n\nstatic void ingenic_ipu_set_integer_upscale_coefs(struct ingenic_ipu *ipu,\n\t\t\t\t\t\t  unsigned int reg,\n\t\t\t\t\t\t  unsigned int num)\n{\n\t \n\tunsigned int i;\n\n\tfor (i = 0; i < num; i++)\n\t\tipu->soc_info->set_coefs(ipu, reg, 0, false, 512, i == num - 1);\n}\n\nstatic void ingenic_ipu_set_upscale_coefs(struct ingenic_ipu *ipu,\n\t\t\t\t\t  unsigned int reg,\n\t\t\t\t\t  unsigned int num,\n\t\t\t\t\t  unsigned int denom)\n{\n\tunsigned int i, offset, weight, weight_num = 0;\n\n\tfor (i = 0; i < num; i++) {\n\t\tweight = 512 - 512 * weight_num / num;\n\t\tweight_num += denom;\n\t\toffset = weight_num >= num;\n\n\t\tif (offset)\n\t\t\tweight_num -= num;\n\n\t\tipu->soc_info->set_coefs(ipu, reg, ipu->sharpness,\n\t\t\t\t\t false, weight, offset);\n\t}\n}\n\nstatic void ingenic_ipu_set_coefs(struct ingenic_ipu *ipu, unsigned int reg,\n\t\t\t\t  unsigned int num, unsigned int denom)\n{\n\t \n\tregmap_write(ipu->map, reg, -1);\n\n\tif (denom > num)\n\t\tingenic_ipu_set_downscale_coefs(ipu, reg, num, denom);\n\telse if (denom == 1)\n\t\tingenic_ipu_set_integer_upscale_coefs(ipu, reg, num);\n\telse\n\t\tingenic_ipu_set_upscale_coefs(ipu, reg, num, denom);\n}\n\nstatic int reduce_fraction(unsigned int *num, unsigned int *denom)\n{\n\tunsigned long d = gcd(*num, *denom);\n\n\t \n\tif (*num > 31 * d)\n\t\treturn -EINVAL;\n\n\t*num /= d;\n\t*denom /= d;\n\treturn 0;\n}\n\nstatic inline bool osd_changed(struct drm_plane_state *state,\n\t\t\t       struct drm_plane_state *oldstate)\n{\n\treturn state->src_x != oldstate->src_x ||\n\t\tstate->src_y != oldstate->src_y ||\n\t\tstate->src_w != oldstate->src_w ||\n\t\tstate->src_h != oldstate->src_h ||\n\t\tstate->crtc_x != oldstate->crtc_x ||\n\t\tstate->crtc_y != oldstate->crtc_y ||\n\t\tstate->crtc_w != oldstate->crtc_w ||\n\t\tstate->crtc_h != oldstate->crtc_h;\n}\n\nstatic void ingenic_ipu_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct ingenic_ipu *ipu = plane_to_ingenic_ipu(plane);\n\tstruct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state, plane);\n\tconst struct drm_format_info *finfo;\n\tu32 ctrl, stride = 0, coef_index = 0, format = 0;\n\tbool needs_modeset, upscaling_w, upscaling_h;\n\tstruct ingenic_ipu_private_state *ipu_state;\n\tint err;\n\n\tif (!newstate || !newstate->fb)\n\t\treturn;\n\n\tipu_state = ingenic_ipu_get_new_priv_state(ipu, state);\n\tif (WARN_ON(!ipu_state))\n\t\treturn;\n\n\tfinfo = drm_format_info(newstate->fb->format->format);\n\n\tif (!ipu->clk_enabled) {\n\t\terr = clk_enable(ipu->clk);\n\t\tif (err) {\n\t\t\tdev_err(ipu->dev, \"Unable to enable clock: %d\\n\", err);\n\t\t\treturn;\n\t\t}\n\n\t\tipu->clk_enabled = true;\n\t}\n\n\t \n\tneeds_modeset = drm_atomic_crtc_needs_modeset(newstate->crtc->state);\n\tif (needs_modeset) {\n\t\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_RST);\n\n\t\t \n\t\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL,\n\t\t\t\tJZ_IPU_CTRL_CHIP_EN | JZ_IPU_CTRL_LCDC_SEL);\n\t}\n\n\tif (ingenic_drm_map_noncoherent(ipu->master))\n\t\tdrm_fb_dma_sync_non_coherent(ipu->drm, oldstate, newstate);\n\n\t \n\tipu->addr_y = drm_fb_dma_get_gem_addr(newstate->fb, newstate, 0);\n\tif (finfo->num_planes > 1)\n\t\tipu->addr_u = drm_fb_dma_get_gem_addr(newstate->fb, newstate,\n\t\t\t\t\t\t      1);\n\tif (finfo->num_planes > 2)\n\t\tipu->addr_v = drm_fb_dma_get_gem_addr(newstate->fb, newstate,\n\t\t\t\t\t\t      2);\n\n\tif (!needs_modeset)\n\t\treturn;\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_Y_ADDR, ipu->addr_y);\n\tregmap_write(ipu->map, JZ_REG_IPU_U_ADDR, ipu->addr_u);\n\tregmap_write(ipu->map, JZ_REG_IPU_V_ADDR, ipu->addr_v);\n\n\tif (finfo->num_planes == 1)\n\t\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_SPKG_SEL);\n\n\tingenic_drm_plane_config(ipu->master, plane, DRM_FORMAT_XRGB8888);\n\n\t \n\tif (finfo->num_planes > 2)\n\t\tstride = ((newstate->src_w >> 16) * finfo->cpp[2] / finfo->hsub)\n\t\t\t<< JZ_IPU_UV_STRIDE_V_LSB;\n\n\tif (finfo->num_planes > 1)\n\t\tstride |= ((newstate->src_w >> 16) * finfo->cpp[1] / finfo->hsub)\n\t\t\t<< JZ_IPU_UV_STRIDE_U_LSB;\n\n\tregmap_write(ipu->map, JZ_REG_IPU_UV_STRIDE, stride);\n\n\tstride = ((newstate->src_w >> 16) * finfo->cpp[0]) << JZ_IPU_Y_STRIDE_Y_LSB;\n\tregmap_write(ipu->map, JZ_REG_IPU_Y_STRIDE, stride);\n\n\tregmap_write(ipu->map, JZ_REG_IPU_IN_GS,\n\t\t     (stride << JZ_IPU_IN_GS_W_LSB) |\n\t\t     ((newstate->src_h >> 16) << JZ_IPU_IN_GS_H_LSB));\n\n\tswitch (finfo->format) {\n\tcase DRM_FORMAT_XRGB1555:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_RGB555 |\n\t\t\tJZ_IPU_D_FMT_RGB_OUT_OFT_RGB;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR1555:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_RGB555 |\n\t\t\tJZ_IPU_D_FMT_RGB_OUT_OFT_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_RGB565 |\n\t\t\tJZ_IPU_D_FMT_RGB_OUT_OFT_RGB;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_RGB565 |\n\t\t\tJZ_IPU_D_FMT_RGB_OUT_OFT_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_XYUV8888:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_RGB888 |\n\t\t\tJZ_IPU_D_FMT_RGB_OUT_OFT_RGB;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_RGB888 |\n\t\t\tJZ_IPU_D_FMT_RGB_OUT_OFT_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV422 |\n\t\t\tJZ_IPU_D_FMT_YUV_VY1UY0;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV422 |\n\t\t\tJZ_IPU_D_FMT_YUV_UY1VY0;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV422 |\n\t\t\tJZ_IPU_D_FMT_YUV_Y1VY0U;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV422 |\n\t\t\tJZ_IPU_D_FMT_YUV_Y1UY0V;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV411:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV411;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV420;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV422:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV422;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV444:\n\t\tformat = JZ_IPU_D_FMT_IN_FMT_YUV444;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Unsupported format\");\n\t\tbreak;\n\t}\n\n\t \n\tformat |= JZ_IPU_D_FMT_OUT_FMT_RGB888;\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_D_FMT, format);\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_OUT_GS,\n\t\t     ((newstate->crtc_w * 4) << JZ_IPU_OUT_GS_W_LSB)\n\t\t     | newstate->crtc_h << JZ_IPU_OUT_GS_H_LSB);\n\tregmap_write(ipu->map, JZ_REG_IPU_OUT_STRIDE, newstate->crtc_w * 4);\n\n\tif (finfo->is_yuv) {\n\t\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_CSC_EN);\n\n\t\t \n\t\tregmap_write(ipu->map, JZ_REG_IPU_CSC_OFFSET,\n\t\t\t     128 << JZ_IPU_CSC_OFFSET_CHROMA_LSB |\n\t\t\t     0 << JZ_IPU_CSC_OFFSET_LUMA_LSB);\n\n\t\t \n\t\tregmap_write(ipu->map, JZ_REG_IPU_CSC_C0_COEF, 0x4a8);\n\t\tregmap_write(ipu->map, JZ_REG_IPU_CSC_C1_COEF, 0x662);\n\t\tregmap_write(ipu->map, JZ_REG_IPU_CSC_C2_COEF, 0x191);\n\t\tregmap_write(ipu->map, JZ_REG_IPU_CSC_C3_COEF, 0x341);\n\t\tregmap_write(ipu->map, JZ_REG_IPU_CSC_C4_COEF, 0x811);\n\t}\n\n\tctrl = 0;\n\n\t \n\tif (ipu->soc_info->has_bicubic)\n\t\tctrl |= JZ_IPU_CTRL_ZOOM_SEL;\n\n\tupscaling_w = ipu_state->num_w > ipu_state->denom_w;\n\tif (upscaling_w)\n\t\tctrl |= JZ_IPU_CTRL_HSCALE;\n\n\tif (ipu_state->num_w != 1 || ipu_state->denom_w != 1) {\n\t\tif (!ipu->soc_info->has_bicubic && !upscaling_w)\n\t\t\tcoef_index |= (ipu_state->denom_w - 1) << 16;\n\t\telse\n\t\t\tcoef_index |= (ipu_state->num_w - 1) << 16;\n\t\tctrl |= JZ_IPU_CTRL_HRSZ_EN;\n\t}\n\n\tupscaling_h = ipu_state->num_h > ipu_state->denom_h;\n\tif (upscaling_h)\n\t\tctrl |= JZ_IPU_CTRL_VSCALE;\n\n\tif (ipu_state->num_h != 1 || ipu_state->denom_h != 1) {\n\t\tif (!ipu->soc_info->has_bicubic && !upscaling_h)\n\t\t\tcoef_index |= ipu_state->denom_h - 1;\n\t\telse\n\t\t\tcoef_index |= ipu_state->num_h - 1;\n\t\tctrl |= JZ_IPU_CTRL_VRSZ_EN;\n\t}\n\n\tregmap_update_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_ZOOM_SEL |\n\t\t\t   JZ_IPU_CTRL_HRSZ_EN | JZ_IPU_CTRL_VRSZ_EN |\n\t\t\t   JZ_IPU_CTRL_HSCALE | JZ_IPU_CTRL_VSCALE, ctrl);\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_RSZ_COEF_INDEX, coef_index);\n\n\tif (ipu_state->num_w != 1 || ipu_state->denom_w != 1)\n\t\tingenic_ipu_set_coefs(ipu, JZ_REG_IPU_HRSZ_COEF_LUT,\n\t\t\t\t      ipu_state->num_w, ipu_state->denom_w);\n\n\tif (ipu_state->num_h != 1 || ipu_state->denom_h != 1)\n\t\tingenic_ipu_set_coefs(ipu, JZ_REG_IPU_VRSZ_COEF_LUT,\n\t\t\t\t      ipu_state->num_h, ipu_state->denom_h);\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_STATUS, 0);\n\n\t \n\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL,\n\t\t\tJZ_IPU_CTRL_RUN | JZ_IPU_CTRL_FM_IRQ_EN);\n\n\tdev_dbg(ipu->dev, \"Scaling %ux%u to %ux%u (%u:%u horiz, %u:%u vert)\\n\",\n\t\tnewstate->src_w >> 16, newstate->src_h >> 16,\n\t\tnewstate->crtc_w, newstate->crtc_h,\n\t\tipu_state->num_w, ipu_state->denom_w,\n\t\tipu_state->num_h, ipu_state->denom_h);\n}\n\nstatic int ingenic_ipu_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tunsigned int num_w, denom_w, num_h, denom_h, xres, yres, max_w, max_h;\n\tstruct ingenic_ipu *ipu = plane_to_ingenic_ipu(plane);\n\tstruct drm_crtc *crtc = new_plane_state->crtc ?: old_plane_state->crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct ingenic_ipu_private_state *ipu_state;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state, crtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tipu_state = ingenic_ipu_get_priv_state(ipu, state);\n\tif (IS_ERR(ipu_state))\n\t\treturn PTR_ERR(ipu_state);\n\n\t \n\tif (!old_plane_state->crtc ^ !new_plane_state->crtc)\n\t\tcrtc_state->mode_changed = true;\n\n\tif (!new_plane_state->crtc ||\n\t    !crtc_state->mode.hdisplay || !crtc_state->mode.vdisplay)\n\t\tgoto out_check_damage;\n\n\t \n\tif (new_plane_state->crtc_x < 0 || new_plane_state->crtc_y < 0 ||\n\t    new_plane_state->crtc_x + new_plane_state->crtc_w > crtc_state->mode.hdisplay ||\n\t    new_plane_state->crtc_y + new_plane_state->crtc_h > crtc_state->mode.vdisplay)\n\t\treturn -EINVAL;\n\n\t \n\tif ((new_plane_state->src_w >> 16) < 4 || (new_plane_state->src_h >> 16) < 4)\n\t\treturn -EINVAL;\n\n\t \n\tif (((new_plane_state->src_w >> 16) & 1) || (new_plane_state->crtc_w & 1))\n\t\treturn -EINVAL;\n\n\tif (!osd_changed(new_plane_state, old_plane_state))\n\t\tgoto out_check_damage;\n\n\tcrtc_state->mode_changed = true;\n\n\txres = new_plane_state->src_w >> 16;\n\tyres = new_plane_state->src_h >> 16;\n\n\t \n\tmax_w = crtc_state->mode.hdisplay * 102 / 100;\n\tmax_h = crtc_state->mode.vdisplay * 102 / 100;\n\n\tfor (denom_w = xres, num_w = new_plane_state->crtc_w; num_w <= max_w; num_w++)\n\t\tif (!reduce_fraction(&num_w, &denom_w))\n\t\t\tbreak;\n\tif (num_w > max_w)\n\t\treturn -EINVAL;\n\n\tfor (denom_h = yres, num_h = new_plane_state->crtc_h; num_h <= max_h; num_h++)\n\t\tif (!reduce_fraction(&num_h, &denom_h))\n\t\t\tbreak;\n\tif (num_h > max_h)\n\t\treturn -EINVAL;\n\n\tipu_state->num_w = num_w;\n\tipu_state->num_h = num_h;\n\tipu_state->denom_w = denom_w;\n\tipu_state->denom_h = denom_h;\n\nout_check_damage:\n\tif (ingenic_drm_map_noncoherent(ipu->master))\n\t\tdrm_atomic_helper_check_plane_damage(state, new_plane_state);\n\n\treturn 0;\n}\n\nstatic void ingenic_ipu_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct ingenic_ipu *ipu = plane_to_ingenic_ipu(plane);\n\n\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_STOP);\n\tregmap_clear_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_CHIP_EN);\n\n\tingenic_drm_plane_disable(ipu->master, plane);\n\n\tif (ipu->clk_enabled) {\n\t\tclk_disable(ipu->clk);\n\t\tipu->clk_enabled = false;\n\t}\n}\n\nstatic const struct drm_plane_helper_funcs ingenic_ipu_plane_helper_funcs = {\n\t.atomic_update\t\t= ingenic_ipu_plane_atomic_update,\n\t.atomic_check\t\t= ingenic_ipu_plane_atomic_check,\n\t.atomic_disable\t\t= ingenic_ipu_plane_atomic_disable,\n};\n\nstatic int\ningenic_ipu_plane_atomic_get_property(struct drm_plane *plane,\n\t\t\t\t      const struct drm_plane_state *state,\n\t\t\t\t      struct drm_property *property, u64 *val)\n{\n\tstruct ingenic_ipu *ipu = plane_to_ingenic_ipu(plane);\n\n\tif (property != ipu->sharpness_prop)\n\t\treturn -EINVAL;\n\n\t*val = ipu->sharpness;\n\n\treturn 0;\n}\n\nstatic int\ningenic_ipu_plane_atomic_set_property(struct drm_plane *plane,\n\t\t\t\t      struct drm_plane_state *state,\n\t\t\t\t      struct drm_property *property, u64 val)\n{\n\tstruct ingenic_ipu *ipu = plane_to_ingenic_ipu(plane);\n\tstruct drm_crtc_state *crtc_state;\n\tbool mode_changed;\n\n\tif (property != ipu->sharpness_prop)\n\t\treturn -EINVAL;\n\n\tmode_changed = val != ipu->sharpness;\n\tipu->sharpness = val;\n\n\tif (state->crtc) {\n\t\tcrtc_state = drm_atomic_get_existing_crtc_state(state->state, state->crtc);\n\t\tif (WARN_ON(!crtc_state))\n\t\t\treturn -EINVAL;\n\n\t\tcrtc_state->mode_changed |= mode_changed;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs ingenic_ipu_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.destroy\t\t= drm_plane_cleanup,\n\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n\n\t.atomic_get_property\t= ingenic_ipu_plane_atomic_get_property,\n\t.atomic_set_property\t= ingenic_ipu_plane_atomic_set_property,\n};\n\nstatic struct drm_private_state *\ningenic_ipu_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct ingenic_ipu_private_state *state = to_ingenic_ipu_priv_state(obj->state);\n\n\tstate = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void ingenic_ipu_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t      struct drm_private_state *state)\n{\n\tstruct ingenic_ipu_private_state *priv_state = to_ingenic_ipu_priv_state(state);\n\n\tkfree(priv_state);\n}\n\nstatic const struct drm_private_state_funcs ingenic_ipu_private_state_funcs = {\n\t.atomic_duplicate_state = ingenic_ipu_duplicate_state,\n\t.atomic_destroy_state = ingenic_ipu_destroy_state,\n};\n\nstatic irqreturn_t ingenic_ipu_irq_handler(int irq, void *arg)\n{\n\tstruct ingenic_ipu *ipu = arg;\n\tstruct drm_crtc *crtc = drm_crtc_from_index(ipu->drm, 0);\n\tunsigned int dummy;\n\n\t \n\tif (ipu->soc_info->manual_restart)\n\t\tregmap_read(ipu->map, JZ_REG_IPU_STATUS, &dummy);\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_STATUS, 0);\n\n\t \n\tregmap_write(ipu->map, JZ_REG_IPU_Y_ADDR, ipu->addr_y);\n\tregmap_write(ipu->map, JZ_REG_IPU_U_ADDR, ipu->addr_u);\n\tregmap_write(ipu->map, JZ_REG_IPU_V_ADDR, ipu->addr_v);\n\n\t \n\tif (ipu->soc_info->manual_restart)\n\t\tregmap_set_bits(ipu->map, JZ_REG_IPU_CTRL, JZ_IPU_CTRL_RUN);\n\n\tdrm_crtc_handle_vblank(crtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct regmap_config ingenic_ipu_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\n\t.max_register = JZ_REG_IPU_OUT_PHY_T_ADDR,\n};\n\nstatic int ingenic_ipu_bind(struct device *dev, struct device *master, void *d)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ingenic_ipu_private_state *private_state;\n\tconst struct soc_info *soc_info;\n\tstruct drm_device *drm = d;\n\tstruct drm_plane *plane;\n\tstruct ingenic_ipu *ipu;\n\tvoid __iomem *base;\n\tunsigned int sharpness_max;\n\tint err, irq;\n\n\tipu = devm_kzalloc(dev, sizeof(*ipu), GFP_KERNEL);\n\tif (!ipu)\n\t\treturn -ENOMEM;\n\n\tsoc_info = of_device_get_match_data(dev);\n\tif (!soc_info) {\n\t\tdev_err(dev, \"Missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tipu->dev = dev;\n\tipu->drm = drm;\n\tipu->master = master;\n\tipu->soc_info = soc_info;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tdev_err(dev, \"Failed to get memory resource\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tipu->map = devm_regmap_init_mmio(dev, base, &ingenic_ipu_regmap_config);\n\tif (IS_ERR(ipu->map)) {\n\t\tdev_err(dev, \"Failed to create regmap\\n\");\n\t\treturn PTR_ERR(ipu->map);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tipu->clk = devm_clk_get(dev, \"ipu\");\n\tif (IS_ERR(ipu->clk)) {\n\t\tdev_err(dev, \"Failed to get pixel clock\\n\");\n\t\treturn PTR_ERR(ipu->clk);\n\t}\n\n\terr = devm_request_irq(dev, irq, ingenic_ipu_irq_handler, 0,\n\t\t\t       dev_name(dev), ipu);\n\tif (err) {\n\t\tdev_err(dev, \"Unable to request IRQ\\n\");\n\t\treturn err;\n\t}\n\n\tplane = &ipu->plane;\n\tdev_set_drvdata(dev, plane);\n\n\tdrm_plane_helper_add(plane, &ingenic_ipu_plane_helper_funcs);\n\n\terr = drm_universal_plane_init(drm, plane, 1, &ingenic_ipu_plane_funcs,\n\t\t\t\t       soc_info->formats, soc_info->num_formats,\n\t\t\t\t       NULL, DRM_PLANE_TYPE_OVERLAY, NULL);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to init plane: %i\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (ingenic_drm_map_noncoherent(master))\n\t\tdrm_plane_enable_fb_damage_clips(plane);\n\n\t \n\tsharpness_max = soc_info->has_bicubic ? 32 : 1;\n\tipu->sharpness_prop = drm_property_create_range(drm, 0, \"sharpness\",\n\t\t\t\t\t\t\t0, sharpness_max);\n\tif (!ipu->sharpness_prop) {\n\t\tdev_err(dev, \"Unable to create sharpness property\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tipu->sharpness = soc_info->has_bicubic ? 8 : 1;\n\tdrm_object_attach_property(&plane->base, ipu->sharpness_prop,\n\t\t\t\t   ipu->sharpness);\n\n\terr = clk_prepare(ipu->clk);\n\tif (err) {\n\t\tdev_err(dev, \"Unable to prepare clock\\n\");\n\t\treturn err;\n\t}\n\n\tprivate_state = kzalloc(sizeof(*private_state), GFP_KERNEL);\n\tif (!private_state) {\n\t\terr = -ENOMEM;\n\t\tgoto err_clk_unprepare;\n\t}\n\n\tdrm_atomic_private_obj_init(drm, &ipu->private_obj, &private_state->base,\n\t\t\t\t    &ingenic_ipu_private_state_funcs);\n\n\treturn 0;\n\nerr_clk_unprepare:\n\tclk_unprepare(ipu->clk);\n\treturn err;\n}\n\nstatic void ingenic_ipu_unbind(struct device *dev,\n\t\t\t       struct device *master, void *d)\n{\n\tstruct ingenic_ipu *ipu = dev_get_drvdata(dev);\n\n\tdrm_atomic_private_obj_fini(&ipu->private_obj);\n\tclk_unprepare(ipu->clk);\n}\n\nstatic const struct component_ops ingenic_ipu_ops = {\n\t.bind = ingenic_ipu_bind,\n\t.unbind = ingenic_ipu_unbind,\n};\n\nstatic int ingenic_ipu_probe(struct platform_device *pdev)\n{\n\treturn component_add(&pdev->dev, &ingenic_ipu_ops);\n}\n\nstatic int ingenic_ipu_remove(struct platform_device *pdev)\n{\n\tcomponent_del(&pdev->dev, &ingenic_ipu_ops);\n\treturn 0;\n}\n\nstatic const u32 jz4725b_ipu_formats[] = {\n\t \n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV444,\n};\n\nstatic const struct soc_info jz4725b_soc_info = {\n\t.formats\t= jz4725b_ipu_formats,\n\t.num_formats\t= ARRAY_SIZE(jz4725b_ipu_formats),\n\t.has_bicubic\t= false,\n\t.manual_restart\t= true,\n\t.set_coefs\t= jz4725b_set_coefs,\n};\n\nstatic const u32 jz4760_ipu_formats[] = {\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_XBGR1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_BGR565,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_YVYU,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_VYUY,\n\tDRM_FORMAT_YUV411,\n\tDRM_FORMAT_YUV420,\n\tDRM_FORMAT_YUV422,\n\tDRM_FORMAT_YUV444,\n\tDRM_FORMAT_XYUV8888,\n};\n\nstatic const struct soc_info jz4760_soc_info = {\n\t.formats\t= jz4760_ipu_formats,\n\t.num_formats\t= ARRAY_SIZE(jz4760_ipu_formats),\n\t.has_bicubic\t= true,\n\t.manual_restart\t= false,\n\t.set_coefs\t= jz4760_set_coefs,\n};\n\nstatic const struct of_device_id ingenic_ipu_of_match[] = {\n\t{ .compatible = \"ingenic,jz4725b-ipu\", .data = &jz4725b_soc_info },\n\t{ .compatible = \"ingenic,jz4760-ipu\", .data = &jz4760_soc_info },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ingenic_ipu_of_match);\n\nstatic struct platform_driver ingenic_ipu_driver = {\n\t.driver = {\n\t\t.name = \"ingenic-ipu\",\n\t\t.of_match_table = ingenic_ipu_of_match,\n\t},\n\t.probe = ingenic_ipu_probe,\n\t.remove = ingenic_ipu_remove,\n};\n\nstruct platform_driver *ingenic_ipu_driver_ptr = &ingenic_ipu_driver;\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}