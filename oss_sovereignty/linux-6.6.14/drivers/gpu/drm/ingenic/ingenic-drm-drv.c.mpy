{
  "module_name": "ingenic-drm-drv.c",
  "hash_id": "c14ba74434a3c1a956bf410afb2b704b8cf984874c538b0605ad3b9a9a0d032a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/ingenic/ingenic-drm-drv.c",
  "human_readable_source": "\n\n\n\n\n\n#include \"ingenic-drm.h\"\n\n#include <linux/bitfield.h>\n#include <linux/component.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_color_mgmt.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#define HWDESC_PALETTE 2\n\nstruct ingenic_dma_hwdesc {\n\tu32 next;\n\tu32 addr;\n\tu32 id;\n\tu32 cmd;\n\t \n\tu32 offsize;\n\tu32 pagewidth;\n\tu32 cpos;\n\tu32 dessize;\n} __aligned(16);\n\nstruct ingenic_dma_hwdescs {\n\tstruct ingenic_dma_hwdesc hwdesc[3];\n\tu16 palette[256] __aligned(16);\n};\n\nstruct jz_soc_info {\n\tbool needs_dev_clk;\n\tbool has_osd;\n\tbool has_alpha;\n\tbool map_noncoherent;\n\tbool use_extended_hwdesc;\n\tbool plane_f0_not_working;\n\tu32 max_burst;\n\tunsigned int max_width, max_height;\n\tconst u32 *formats_f0, *formats_f1;\n\tunsigned int num_formats_f0, num_formats_f1;\n};\n\nstruct ingenic_drm_private_state {\n\tstruct drm_private_state base;\n\tbool use_palette;\n};\n\nstruct ingenic_drm {\n\tstruct drm_device drm;\n\t \n\tstruct drm_plane f0, f1, *ipu_plane;\n\tstruct drm_crtc crtc;\n\n\tstruct device *dev;\n\tstruct regmap *map;\n\tstruct clk *lcd_clk, *pix_clk;\n\tconst struct jz_soc_info *soc_info;\n\n\tstruct ingenic_dma_hwdescs *dma_hwdescs;\n\tdma_addr_t dma_hwdescs_phys;\n\n\tbool panel_is_sharp;\n\tbool no_vblank;\n\n\t \n\tstruct mutex clk_mutex;\n\tbool update_clk_rate;\n\tstruct notifier_block clock_nb;\n\n\tstruct drm_private_obj private_obj;\n};\n\nstruct ingenic_drm_bridge {\n\tstruct drm_encoder encoder;\n\tstruct drm_bridge bridge, *next_bridge;\n\n\tstruct drm_bus_cfg bus_cfg;\n};\n\nstatic inline struct ingenic_drm_bridge *\nto_ingenic_drm_bridge(struct drm_encoder *encoder)\n{\n\treturn container_of(encoder, struct ingenic_drm_bridge, encoder);\n}\n\nstatic inline struct ingenic_drm_private_state *\nto_ingenic_drm_priv_state(struct drm_private_state *state)\n{\n\treturn container_of(state, struct ingenic_drm_private_state, base);\n}\n\nstatic struct ingenic_drm_private_state *\ningenic_drm_get_priv_state(struct ingenic_drm *priv, struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_state;\n\n\tpriv_state = drm_atomic_get_private_obj_state(state, &priv->private_obj);\n\tif (IS_ERR(priv_state))\n\t\treturn ERR_CAST(priv_state);\n\n\treturn to_ingenic_drm_priv_state(priv_state);\n}\n\nstatic struct ingenic_drm_private_state *\ningenic_drm_get_new_priv_state(struct ingenic_drm *priv, struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_state;\n\n\tpriv_state = drm_atomic_get_new_private_obj_state(state, &priv->private_obj);\n\tif (!priv_state)\n\t\treturn NULL;\n\n\treturn to_ingenic_drm_priv_state(priv_state);\n}\n\nstatic bool ingenic_drm_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase JZ_REG_LCD_IID:\n\tcase JZ_REG_LCD_SA0:\n\tcase JZ_REG_LCD_FID0:\n\tcase JZ_REG_LCD_CMD0:\n\tcase JZ_REG_LCD_SA1:\n\tcase JZ_REG_LCD_FID1:\n\tcase JZ_REG_LCD_CMD1:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config ingenic_drm_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\n\t.writeable_reg = ingenic_drm_writeable_reg,\n};\n\nstatic inline struct ingenic_drm *drm_device_get_priv(struct drm_device *drm)\n{\n\treturn container_of(drm, struct ingenic_drm, drm);\n}\n\nstatic inline struct ingenic_drm *drm_crtc_get_priv(struct drm_crtc *crtc)\n{\n\treturn container_of(crtc, struct ingenic_drm, crtc);\n}\n\nstatic inline struct ingenic_drm *drm_nb_get_priv(struct notifier_block *nb)\n{\n\treturn container_of(nb, struct ingenic_drm, clock_nb);\n}\n\nstatic inline dma_addr_t dma_hwdesc_addr(const struct ingenic_drm *priv,\n\t\t\t\t\t unsigned int idx)\n{\n\tu32 offset = offsetof(struct ingenic_dma_hwdescs, hwdesc[idx]);\n\n\treturn priv->dma_hwdescs_phys + offset;\n}\n\nstatic int ingenic_drm_update_pixclk(struct notifier_block *nb,\n\t\t\t\t     unsigned long action,\n\t\t\t\t     void *data)\n{\n\tstruct ingenic_drm *priv = drm_nb_get_priv(nb);\n\n\tswitch (action) {\n\tcase PRE_RATE_CHANGE:\n\t\tmutex_lock(&priv->clk_mutex);\n\t\tpriv->update_clk_rate = true;\n\t\tdrm_crtc_wait_one_vblank(&priv->crtc);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\tmutex_unlock(&priv->clk_mutex);\n\t\treturn NOTIFY_OK;\n\t}\n}\n\nstatic void ingenic_drm_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(bridge->dev);\n\n\tregmap_write(priv->map, JZ_REG_LCD_STATE, 0);\n\n\tregmap_update_bits(priv->map, JZ_REG_LCD_CTRL,\n\t\t\t   JZ_LCD_CTRL_ENABLE | JZ_LCD_CTRL_DISABLE,\n\t\t\t   JZ_LCD_CTRL_ENABLE);\n}\n\nstatic void ingenic_drm_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\tstruct ingenic_drm_private_state *priv_state;\n\tunsigned int next_id;\n\n\tpriv_state = ingenic_drm_get_priv_state(priv, state);\n\tif (WARN_ON(IS_ERR(priv_state)))\n\t\treturn;\n\n\t \n\tnext_id = priv_state->use_palette ? HWDESC_PALETTE : 0;\n\tregmap_write(priv->map, JZ_REG_LCD_DA0, dma_hwdesc_addr(priv, next_id));\n\tregmap_write(priv->map, JZ_REG_LCD_DA1, dma_hwdesc_addr(priv, 1));\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void ingenic_drm_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_bridge_state *old_bridge_state)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(bridge->dev);\n\tunsigned int var;\n\n\tregmap_update_bits(priv->map, JZ_REG_LCD_CTRL,\n\t\t\t   JZ_LCD_CTRL_DISABLE, JZ_LCD_CTRL_DISABLE);\n\n\tregmap_read_poll_timeout(priv->map, JZ_REG_LCD_STATE, var,\n\t\t\t\t var & JZ_LCD_STATE_DISABLED,\n\t\t\t\t 1000, 0);\n}\n\nstatic void ingenic_drm_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_off(crtc);\n}\n\nstatic void ingenic_drm_crtc_update_timings(struct ingenic_drm *priv,\n\t\t\t\t\t    struct drm_display_mode *mode)\n{\n\tunsigned int vpe, vds, vde, vt, hpe, hds, hde, ht;\n\n\tvpe = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tvds = mode->crtc_vtotal - mode->crtc_vsync_start;\n\tvde = vds + mode->crtc_vdisplay;\n\tvt = vde + mode->crtc_vsync_start - mode->crtc_vdisplay;\n\n\thpe = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\thds = mode->crtc_htotal - mode->crtc_hsync_start;\n\thde = hds + mode->crtc_hdisplay;\n\tht = hde + mode->crtc_hsync_start - mode->crtc_hdisplay;\n\n\tregmap_write(priv->map, JZ_REG_LCD_VSYNC,\n\t\t     0 << JZ_LCD_VSYNC_VPS_OFFSET |\n\t\t     vpe << JZ_LCD_VSYNC_VPE_OFFSET);\n\n\tregmap_write(priv->map, JZ_REG_LCD_HSYNC,\n\t\t     0 << JZ_LCD_HSYNC_HPS_OFFSET |\n\t\t     hpe << JZ_LCD_HSYNC_HPE_OFFSET);\n\n\tregmap_write(priv->map, JZ_REG_LCD_VAT,\n\t\t     ht << JZ_LCD_VAT_HT_OFFSET |\n\t\t     vt << JZ_LCD_VAT_VT_OFFSET);\n\n\tregmap_write(priv->map, JZ_REG_LCD_DAH,\n\t\t     hds << JZ_LCD_DAH_HDS_OFFSET |\n\t\t     hde << JZ_LCD_DAH_HDE_OFFSET);\n\tregmap_write(priv->map, JZ_REG_LCD_DAV,\n\t\t     vds << JZ_LCD_DAV_VDS_OFFSET |\n\t\t     vde << JZ_LCD_DAV_VDE_OFFSET);\n\n\tif (priv->panel_is_sharp) {\n\t\tregmap_write(priv->map, JZ_REG_LCD_PS, hde << 16 | (hde + 1));\n\t\tregmap_write(priv->map, JZ_REG_LCD_CLS, hde << 16 | (hde + 1));\n\t\tregmap_write(priv->map, JZ_REG_LCD_SPL, hpe << 16 | (hpe + 1));\n\t\tregmap_write(priv->map, JZ_REG_LCD_REV, mode->htotal << 16);\n\t}\n\n\tregmap_update_bits(priv->map, JZ_REG_LCD_CTRL,\n\t\t\t   JZ_LCD_CTRL_OFUP | JZ_LCD_CTRL_BURST_MASK,\n\t\t\t   JZ_LCD_CTRL_OFUP | priv->soc_info->max_burst);\n\n\t \n\tregmap_write(priv->map, JZ_REG_LCD_IPUR, JZ_LCD_IPUR_IPUREN |\n\t\t     (ht * vpe / 3) << JZ_LCD_IPUR_IPUR_LSB);\n}\n\nstatic int ingenic_drm_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\tstruct drm_plane_state *f1_state, *f0_state, *ipu_state = NULL;\n\n\tif (crtc_state->gamma_lut &&\n\t    drm_color_lut_size(crtc_state->gamma_lut) != ARRAY_SIZE(priv->dma_hwdescs->palette)) {\n\t\tdev_dbg(priv->dev, \"Invalid palette size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_atomic_crtc_needs_modeset(crtc_state) && priv->soc_info->has_osd) {\n\t\tf1_state = drm_atomic_get_plane_state(crtc_state->state,\n\t\t\t\t\t\t      &priv->f1);\n\t\tif (IS_ERR(f1_state))\n\t\t\treturn PTR_ERR(f1_state);\n\n\t\tf0_state = drm_atomic_get_plane_state(crtc_state->state,\n\t\t\t\t\t\t      &priv->f0);\n\t\tif (IS_ERR(f0_state))\n\t\t\treturn PTR_ERR(f0_state);\n\n\t\tif (IS_ENABLED(CONFIG_DRM_INGENIC_IPU) && priv->ipu_plane) {\n\t\t\tipu_state = drm_atomic_get_plane_state(crtc_state->state,\n\t\t\t\t\t\t\t       priv->ipu_plane);\n\t\t\tif (IS_ERR(ipu_state))\n\t\t\t\treturn PTR_ERR(ipu_state);\n\n\t\t\t \n\t\t\tif (f1_state->fb && ipu_state->fb) {\n\t\t\t\tdev_dbg(priv->dev, \"Cannot enable both F1 and IPU\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpriv->no_vblank = !f1_state->fb && !f0_state->fb &&\n\t\t\t\t  !(ipu_state && ipu_state->fb);\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status\ningenic_drm_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *mode)\n{\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\tlong rate;\n\n\tif (mode->hdisplay > priv->soc_info->max_width)\n\t\treturn MODE_BAD_HVALUE;\n\tif (mode->vdisplay > priv->soc_info->max_height)\n\t\treturn MODE_BAD_VVALUE;\n\n\trate = clk_round_rate(priv->pix_clk, mode->clock * 1000);\n\tif (rate < 0)\n\t\treturn MODE_CLOCK_RANGE;\n\n\treturn MODE_OK;\n}\n\nstatic void ingenic_drm_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\tu32 ctrl = 0;\n\n\tif (priv->soc_info->has_osd &&\n\t    drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\t \n\t\tif (priv->ipu_plane && priv->ipu_plane->state->fb)\n\t\t\tctrl |= JZ_LCD_OSDCTRL_IPU;\n\n\t\tregmap_update_bits(priv->map, JZ_REG_LCD_OSDCTRL,\n\t\t\t\t   JZ_LCD_OSDCTRL_IPU, ctrl);\n\t}\n}\n\nstatic void ingenic_drm_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct drm_pending_vblank_event *event = crtc_state->event;\n\n\tif (drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\tingenic_drm_crtc_update_timings(priv, &crtc_state->adjusted_mode);\n\t\tpriv->update_clk_rate = true;\n\t}\n\n\tif (priv->update_clk_rate) {\n\t\tmutex_lock(&priv->clk_mutex);\n\t\tclk_set_rate(priv->pix_clk,\n\t\t\t     crtc_state->adjusted_mode.crtc_clock * 1000);\n\t\tpriv->update_clk_rate = false;\n\t\tmutex_unlock(&priv->clk_mutex);\n\t}\n\n\tif (event) {\n\t\tcrtc_state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic int ingenic_drm_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_plane_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct ingenic_drm *priv = drm_device_get_priv(plane->dev);\n\tstruct ingenic_drm_private_state *priv_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc = new_plane_state->crtc ?: old_plane_state->crtc;\n\tint ret;\n\n\tif (!crtc)\n\t\treturn 0;\n\n\tif (priv->soc_info->plane_f0_not_working && plane == &priv->f0)\n\t\treturn -EINVAL;\n\n\tcrtc_state = drm_atomic_get_existing_crtc_state(state,\n\t\t\t\t\t\t\tcrtc);\n\tif (WARN_ON(!crtc_state))\n\t\treturn -EINVAL;\n\n\tpriv_state = ingenic_drm_get_priv_state(priv, state);\n\tif (IS_ERR(priv_state))\n\t\treturn PTR_ERR(priv_state);\n\n\tret = drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  priv->soc_info->has_osd,\n\t\t\t\t\t\t  true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!priv->soc_info->has_osd &&\n\t    (new_plane_state->src_x != 0 ||\n\t     (new_plane_state->src_w >> 16) != new_plane_state->crtc_w ||\n\t     (new_plane_state->src_h >> 16) != new_plane_state->crtc_h))\n\t\treturn -EINVAL;\n\n\tpriv_state->use_palette = new_plane_state->fb &&\n\t\tnew_plane_state->fb->format->format == DRM_FORMAT_C8;\n\n\t \n\tif (priv->soc_info->has_osd &&\n\t    (!old_plane_state->fb || !new_plane_state->fb ||\n\t     old_plane_state->crtc_x != new_plane_state->crtc_x ||\n\t     old_plane_state->crtc_y != new_plane_state->crtc_y ||\n\t     old_plane_state->crtc_w != new_plane_state->crtc_w ||\n\t     old_plane_state->crtc_h != new_plane_state->crtc_h ||\n\t     old_plane_state->fb->format->format != new_plane_state->fb->format->format))\n\t\tcrtc_state->mode_changed = true;\n\n\tif (priv->soc_info->map_noncoherent)\n\t\tdrm_atomic_helper_check_plane_damage(state, new_plane_state);\n\n\treturn 0;\n}\n\nstatic void ingenic_drm_plane_enable(struct ingenic_drm *priv,\n\t\t\t\t     struct drm_plane *plane)\n{\n\tunsigned int en_bit;\n\n\tif (priv->soc_info->has_osd) {\n\t\tif (plane != &priv->f0)\n\t\t\ten_bit = JZ_LCD_OSDC_F1EN;\n\t\telse\n\t\t\ten_bit = JZ_LCD_OSDC_F0EN;\n\n\t\tregmap_set_bits(priv->map, JZ_REG_LCD_OSDC, en_bit);\n\t}\n}\n\nvoid ingenic_drm_plane_disable(struct device *dev, struct drm_plane *plane)\n{\n\tstruct ingenic_drm *priv = dev_get_drvdata(dev);\n\tunsigned int en_bit;\n\n\tif (priv->soc_info->has_osd) {\n\t\tif (plane != &priv->f0)\n\t\t\ten_bit = JZ_LCD_OSDC_F1EN;\n\t\telse\n\t\t\ten_bit = JZ_LCD_OSDC_F0EN;\n\n\t\tregmap_clear_bits(priv->map, JZ_REG_LCD_OSDC, en_bit);\n\t}\n}\n\nstatic void ingenic_drm_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(plane->dev);\n\n\tingenic_drm_plane_disable(priv->dev, plane);\n}\n\nvoid ingenic_drm_plane_config(struct device *dev,\n\t\t\t      struct drm_plane *plane, u32 fourcc)\n{\n\tstruct ingenic_drm *priv = dev_get_drvdata(dev);\n\tstruct drm_plane_state *state = plane->state;\n\tunsigned int xy_reg, size_reg;\n\tunsigned int ctrl = 0;\n\n\tingenic_drm_plane_enable(priv, plane);\n\n\tif (priv->soc_info->has_osd && plane != &priv->f0) {\n\t\tswitch (fourcc) {\n\t\tcase DRM_FORMAT_XRGB1555:\n\t\t\tctrl |= JZ_LCD_OSDCTRL_RGB555;\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tctrl |= JZ_LCD_OSDCTRL_BPP_15_16;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\tctrl |= JZ_LCD_OSDCTRL_BPP_24_COMP;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\tctrl |= JZ_LCD_OSDCTRL_BPP_18_24;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB2101010:\n\t\t\tctrl |= JZ_LCD_OSDCTRL_BPP_30;\n\t\t\tbreak;\n\t\t}\n\n\t\tregmap_update_bits(priv->map, JZ_REG_LCD_OSDCTRL,\n\t\t\t\t   JZ_LCD_OSDCTRL_BPP_MASK, ctrl);\n\t} else {\n\t\tswitch (fourcc) {\n\t\tcase DRM_FORMAT_C8:\n\t\t\tctrl |= JZ_LCD_CTRL_BPP_8;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB1555:\n\t\t\tctrl |= JZ_LCD_CTRL_RGB555;\n\t\t\tfallthrough;\n\t\tcase DRM_FORMAT_RGB565:\n\t\t\tctrl |= JZ_LCD_CTRL_BPP_15_16;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_RGB888:\n\t\t\tctrl |= JZ_LCD_CTRL_BPP_24_COMP;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\tctrl |= JZ_LCD_CTRL_BPP_18_24;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_XRGB2101010:\n\t\t\tctrl |= JZ_LCD_CTRL_BPP_30;\n\t\t\tbreak;\n\t\t}\n\n\t\tregmap_update_bits(priv->map, JZ_REG_LCD_CTRL,\n\t\t\t\t   JZ_LCD_CTRL_BPP_MASK, ctrl);\n\t}\n\n\tif (priv->soc_info->has_osd) {\n\t\tif (plane != &priv->f0) {\n\t\t\txy_reg = JZ_REG_LCD_XYP1;\n\t\t\tsize_reg = JZ_REG_LCD_SIZE1;\n\t\t} else {\n\t\t\txy_reg = JZ_REG_LCD_XYP0;\n\t\t\tsize_reg = JZ_REG_LCD_SIZE0;\n\t\t}\n\n\t\tregmap_write(priv->map, xy_reg,\n\t\t\t     state->crtc_x << JZ_LCD_XYP01_XPOS_LSB |\n\t\t\t     state->crtc_y << JZ_LCD_XYP01_YPOS_LSB);\n\t\tregmap_write(priv->map, size_reg,\n\t\t\t     state->crtc_w << JZ_LCD_SIZE01_WIDTH_LSB |\n\t\t\t     state->crtc_h << JZ_LCD_SIZE01_HEIGHT_LSB);\n\t}\n}\n\nbool ingenic_drm_map_noncoherent(const struct device *dev)\n{\n\tconst struct ingenic_drm *priv = dev_get_drvdata(dev);\n\n\treturn priv->soc_info->map_noncoherent;\n}\n\nstatic void ingenic_drm_update_palette(struct ingenic_drm *priv,\n\t\t\t\t       const struct drm_color_lut *lut)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->dma_hwdescs->palette); i++) {\n\t\tu16 color = drm_color_lut_extract(lut[i].red, 5) << 11\n\t\t\t| drm_color_lut_extract(lut[i].green, 6) << 5\n\t\t\t| drm_color_lut_extract(lut[i].blue, 5);\n\n\t\tpriv->dma_hwdescs->palette[i] = color;\n\t}\n}\n\nstatic void ingenic_drm_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(plane->dev);\n\tstruct drm_plane_state *newstate = drm_atomic_get_new_plane_state(state, plane);\n\tstruct drm_plane_state *oldstate = drm_atomic_get_old_plane_state(state, plane);\n\tunsigned int width, height, cpp, next_id, plane_id;\n\tstruct ingenic_drm_private_state *priv_state;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct ingenic_dma_hwdesc *hwdesc;\n\tdma_addr_t addr;\n\tu32 fourcc;\n\n\tif (newstate && newstate->fb) {\n\t\tif (priv->soc_info->map_noncoherent)\n\t\t\tdrm_fb_dma_sync_non_coherent(&priv->drm, oldstate, newstate);\n\n\t\tcrtc_state = newstate->crtc->state;\n\t\tplane_id = !!(priv->soc_info->has_osd && plane != &priv->f0);\n\n\t\taddr = drm_fb_dma_get_gem_addr(newstate->fb, newstate, 0);\n\t\twidth = newstate->src_w >> 16;\n\t\theight = newstate->src_h >> 16;\n\t\tcpp = newstate->fb->format->cpp[0];\n\n\t\tpriv_state = ingenic_drm_get_new_priv_state(priv, state);\n\t\tnext_id = (priv_state && priv_state->use_palette) ? HWDESC_PALETTE : plane_id;\n\n\t\thwdesc = &priv->dma_hwdescs->hwdesc[plane_id];\n\t\thwdesc->addr = addr;\n\t\thwdesc->cmd = JZ_LCD_CMD_EOF_IRQ | (width * height * cpp / 4);\n\t\thwdesc->next = dma_hwdesc_addr(priv, next_id);\n\n\t\tif (priv->soc_info->use_extended_hwdesc) {\n\t\t\thwdesc->cmd |= JZ_LCD_CMD_FRM_ENABLE;\n\n\t\t\t \n\t\t\thwdesc->cpos = 0;\n\t\t\thwdesc->offsize = 0;\n\t\t\thwdesc->pagewidth = 0;\n\n\t\t\tswitch (newstate->fb->format->format) {\n\t\t\tcase DRM_FORMAT_XRGB1555:\n\t\t\t\thwdesc->cpos |= JZ_LCD_CPOS_RGB555;\n\t\t\t\tfallthrough;\n\t\t\tcase DRM_FORMAT_RGB565:\n\t\t\t\thwdesc->cpos |= JZ_LCD_CPOS_BPP_15_16;\n\t\t\t\tbreak;\n\t\t\tcase DRM_FORMAT_XRGB8888:\n\t\t\t\thwdesc->cpos |= JZ_LCD_CPOS_BPP_18_24;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\thwdesc->cpos |= (JZ_LCD_CPOS_COEFFICIENT_1 <<\n\t\t\t\t\t JZ_LCD_CPOS_COEFFICIENT_OFFSET);\n\t\t\thwdesc->dessize =\n\t\t\t\t(0xff << JZ_LCD_DESSIZE_ALPHA_OFFSET) |\n\t\t\t\tFIELD_PREP(JZ_LCD_DESSIZE_HEIGHT_MASK, height - 1) |\n\t\t\t\tFIELD_PREP(JZ_LCD_DESSIZE_WIDTH_MASK, width - 1);\n\t\t}\n\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state)) {\n\t\t\tfourcc = newstate->fb->format->format;\n\n\t\t\tingenic_drm_plane_config(priv->dev, plane, fourcc);\n\n\t\t\tcrtc_state->color_mgmt_changed = fourcc == DRM_FORMAT_C8;\n\t\t}\n\n\t\tif (crtc_state->color_mgmt_changed)\n\t\t\tingenic_drm_update_palette(priv, crtc_state->gamma_lut->data);\n\t}\n}\n\nstatic void ingenic_drm_encoder_atomic_mode_set(struct drm_encoder *encoder,\n\t\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(encoder->dev);\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tstruct ingenic_drm_bridge *bridge = to_ingenic_drm_bridge(encoder);\n\tunsigned int cfg, rgbcfg = 0;\n\n\tpriv->panel_is_sharp = bridge->bus_cfg.flags & DRM_BUS_FLAG_SHARP_SIGNALS;\n\n\tif (priv->panel_is_sharp) {\n\t\tcfg = JZ_LCD_CFG_MODE_SPECIAL_TFT_1 | JZ_LCD_CFG_REV_POLARITY;\n\t} else {\n\t\tcfg = JZ_LCD_CFG_PS_DISABLE | JZ_LCD_CFG_CLS_DISABLE\n\t\t    | JZ_LCD_CFG_SPL_DISABLE | JZ_LCD_CFG_REV_DISABLE;\n\t}\n\n\tif (priv->soc_info->use_extended_hwdesc)\n\t\tcfg |= JZ_LCD_CFG_DESCRIPTOR_8;\n\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tcfg |= JZ_LCD_CFG_HSYNC_ACTIVE_LOW;\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tcfg |= JZ_LCD_CFG_VSYNC_ACTIVE_LOW;\n\tif (bridge->bus_cfg.flags & DRM_BUS_FLAG_DE_LOW)\n\t\tcfg |= JZ_LCD_CFG_DE_ACTIVE_LOW;\n\tif (bridge->bus_cfg.flags & DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tcfg |= JZ_LCD_CFG_PCLK_FALLING_EDGE;\n\n\tif (!priv->panel_is_sharp) {\n\t\tif (conn_state->connector->connector_type == DRM_MODE_CONNECTOR_TV) {\n\t\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\t\tcfg |= JZ_LCD_CFG_MODE_TV_OUT_I;\n\t\t\telse\n\t\t\t\tcfg |= JZ_LCD_CFG_MODE_TV_OUT_P;\n\t\t} else {\n\t\t\tswitch (bridge->bus_cfg.format) {\n\t\t\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\t\t\t\tcfg |= JZ_LCD_CFG_MODE_GENERIC_16BIT;\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\t\t\t\tcfg |= JZ_LCD_CFG_MODE_GENERIC_18BIT;\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\t\t\tcfg |= JZ_LCD_CFG_MODE_GENERIC_24BIT;\n\t\t\t\tbreak;\n\t\t\tcase MEDIA_BUS_FMT_RGB888_3X8_DELTA:\n\t\t\t\trgbcfg = JZ_LCD_RGBC_EVEN_GBR | JZ_LCD_RGBC_ODD_RGB;\n\t\t\t\tfallthrough;\n\t\t\tcase MEDIA_BUS_FMT_RGB888_3X8:\n\t\t\t\tcfg |= JZ_LCD_CFG_MODE_8BIT_SERIAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tregmap_write(priv->map, JZ_REG_LCD_CFG, cfg);\n\tregmap_write(priv->map, JZ_REG_LCD_RGBC, rgbcfg);\n}\n\nstatic int ingenic_drm_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\tstruct ingenic_drm_bridge *ib = to_ingenic_drm_bridge(bridge->encoder);\n\n\treturn drm_bridge_attach(bridge->encoder, ib->next_bridge,\n\t\t\t\t &ib->bridge, flags);\n}\n\nstatic int ingenic_drm_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_bridge_state *bridge_state,\n\t\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tstruct drm_display_mode *mode = &crtc_state->adjusted_mode;\n\tstruct ingenic_drm_bridge *ib = to_ingenic_drm_bridge(bridge->encoder);\n\n\tib->bus_cfg = bridge_state->output_bus_cfg;\n\n\tif (conn_state->connector->connector_type == DRM_MODE_CONNECTOR_TV)\n\t\treturn 0;\n\n\tswitch (bridge_state->output_bus_cfg.format) {\n\tcase MEDIA_BUS_FMT_RGB888_3X8:\n\tcase MEDIA_BUS_FMT_RGB888_3X8_DELTA:\n\t\t \n\t\tmode->crtc_clock = mode->clock * 3;\n\t\tmode->crtc_hsync_start = mode->hsync_start * 3 - mode->hdisplay * 2;\n\t\tmode->crtc_hsync_end = mode->hsync_end * 3 - mode->hdisplay * 2;\n\t\tmode->crtc_hdisplay = mode->hdisplay;\n\t\tmode->crtc_htotal = mode->htotal * 3 - mode->hdisplay * 2;\n\t\treturn 0;\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 *\ningenic_drm_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\t     struct drm_bridge_state *bridge_state,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state,\n\t\t\t\t\t     u32 output_fmt,\n\t\t\t\t\t     unsigned int *num_input_fmts)\n{\n\tswitch (output_fmt) {\n\tcase MEDIA_BUS_FMT_RGB888_1X24:\n\tcase MEDIA_BUS_FMT_RGB666_1X18:\n\tcase MEDIA_BUS_FMT_RGB565_1X16:\n\tcase MEDIA_BUS_FMT_RGB888_3X8:\n\tcase MEDIA_BUS_FMT_RGB888_3X8_DELTA:\n\t\tbreak;\n\tdefault:\n\t\t*num_input_fmts = 0;\n\t\treturn NULL;\n\t}\n\n\treturn drm_atomic_helper_bridge_propagate_bus_fmt(bridge, bridge_state,\n\t\t\t\t\t\t\t  crtc_state, conn_state,\n\t\t\t\t\t\t\t  output_fmt,\n\t\t\t\t\t\t\t  num_input_fmts);\n}\n\nstatic irqreturn_t ingenic_drm_irq_handler(int irq, void *arg)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(arg);\n\tunsigned int state;\n\n\tregmap_read(priv->map, JZ_REG_LCD_STATE, &state);\n\n\tregmap_update_bits(priv->map, JZ_REG_LCD_STATE,\n\t\t\t   JZ_LCD_STATE_EOF_IRQ, 0);\n\n\tif (state & JZ_LCD_STATE_EOF_IRQ)\n\t\tdrm_crtc_handle_vblank(&priv->crtc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ingenic_drm_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\n\tif (priv->no_vblank)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(priv->map, JZ_REG_LCD_CTRL,\n\t\t\t   JZ_LCD_CTRL_EOF_IRQ, JZ_LCD_CTRL_EOF_IRQ);\n\n\treturn 0;\n}\n\nstatic void ingenic_drm_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct ingenic_drm *priv = drm_crtc_get_priv(crtc);\n\n\tregmap_update_bits(priv->map, JZ_REG_LCD_CTRL, JZ_LCD_CTRL_EOF_IRQ, 0);\n}\n\nstatic struct drm_framebuffer *\ningenic_drm_gem_fb_create(struct drm_device *drm, struct drm_file *file,\n\t\t\t  const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(drm);\n\n\tif (priv->soc_info->map_noncoherent)\n\t\treturn drm_gem_fb_create_with_dirty(drm, file, mode_cmd);\n\n\treturn drm_gem_fb_create(drm, file, mode_cmd);\n}\n\nstatic struct drm_gem_object *\ningenic_drm_gem_create_object(struct drm_device *drm, size_t size)\n{\n\tstruct ingenic_drm *priv = drm_device_get_priv(drm);\n\tstruct drm_gem_dma_object *obj;\n\n\tobj = kzalloc(sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tobj->map_noncoherent = priv->soc_info->map_noncoherent;\n\n\treturn &obj->base;\n}\n\nstatic struct drm_private_state *\ningenic_drm_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct ingenic_drm_private_state *state = to_ingenic_drm_priv_state(obj->state);\n\n\tstate = kmemdup(state, sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &state->base);\n\n\treturn &state->base;\n}\n\nstatic void ingenic_drm_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t      struct drm_private_state *state)\n{\n\tstruct ingenic_drm_private_state *priv_state = to_ingenic_drm_priv_state(state);\n\n\tkfree(priv_state);\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(ingenic_drm_fops);\n\nstatic const struct drm_driver ingenic_drm_driver_data = {\n\t.driver_features\t= DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.name\t\t\t= \"ingenic-drm\",\n\t.desc\t\t\t= \"DRM module for Ingenic SoCs\",\n\t.date\t\t\t= \"20200716\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 1,\n\t.patchlevel\t\t= 0,\n\n\t.fops\t\t\t= &ingenic_drm_fops,\n\t.gem_create_object\t= ingenic_drm_gem_create_object,\n\tDRM_GEM_DMA_DRIVER_OPS,\n};\n\nstatic const struct drm_plane_funcs ingenic_drm_primary_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.destroy\t\t= drm_plane_cleanup,\n\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic const struct drm_crtc_funcs ingenic_drm_crtc_funcs = {\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.page_flip\t\t= drm_atomic_helper_page_flip,\n\t.reset\t\t\t= drm_atomic_helper_crtc_reset,\n\t.destroy\t\t= drm_crtc_cleanup,\n\n\t.atomic_duplicate_state\t= drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_crtc_destroy_state,\n\n\t.enable_vblank\t\t= ingenic_drm_enable_vblank,\n\t.disable_vblank\t\t= ingenic_drm_disable_vblank,\n};\n\nstatic const struct drm_plane_helper_funcs ingenic_drm_plane_helper_funcs = {\n\t.atomic_update\t\t= ingenic_drm_plane_atomic_update,\n\t.atomic_check\t\t= ingenic_drm_plane_atomic_check,\n\t.atomic_disable\t\t= ingenic_drm_plane_atomic_disable,\n};\n\nstatic const struct drm_crtc_helper_funcs ingenic_drm_crtc_helper_funcs = {\n\t.atomic_enable\t\t= ingenic_drm_crtc_atomic_enable,\n\t.atomic_disable\t\t= ingenic_drm_crtc_atomic_disable,\n\t.atomic_begin\t\t= ingenic_drm_crtc_atomic_begin,\n\t.atomic_flush\t\t= ingenic_drm_crtc_atomic_flush,\n\t.atomic_check\t\t= ingenic_drm_crtc_atomic_check,\n\t.mode_valid\t\t= ingenic_drm_crtc_mode_valid,\n};\n\nstatic const struct drm_encoder_helper_funcs ingenic_drm_encoder_helper_funcs = {\n\t.atomic_mode_set        = ingenic_drm_encoder_atomic_mode_set,\n};\n\nstatic const struct drm_bridge_funcs ingenic_drm_bridge_funcs = {\n\t.attach\t\t\t= ingenic_drm_bridge_attach,\n\t.atomic_enable\t\t= ingenic_drm_bridge_atomic_enable,\n\t.atomic_disable\t\t= ingenic_drm_bridge_atomic_disable,\n\t.atomic_check\t\t= ingenic_drm_bridge_atomic_check,\n\t.atomic_reset\t\t= drm_atomic_helper_bridge_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_bridge_destroy_state,\n\t.atomic_get_input_bus_fmts = ingenic_drm_bridge_atomic_get_input_bus_fmts,\n};\n\nstatic const struct drm_mode_config_funcs ingenic_drm_mode_config_funcs = {\n\t.fb_create\t\t= ingenic_drm_gem_fb_create,\n\t.atomic_check\t\t= drm_atomic_helper_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\nstatic struct drm_mode_config_helper_funcs ingenic_drm_mode_config_helpers = {\n\t.atomic_commit_tail = drm_atomic_helper_commit_tail,\n};\n\nstatic const struct drm_private_state_funcs ingenic_drm_private_state_funcs = {\n\t.atomic_duplicate_state = ingenic_drm_duplicate_state,\n\t.atomic_destroy_state = ingenic_drm_destroy_state,\n};\n\nstatic void ingenic_drm_unbind_all(void *d)\n{\n\tstruct ingenic_drm *priv = d;\n\n\tcomponent_unbind_all(priv->dev, &priv->drm);\n}\n\nstatic void __maybe_unused ingenic_drm_release_rmem(void *d)\n{\n\tof_reserved_mem_device_release(d);\n}\n\nstatic void ingenic_drm_configure_hwdesc(struct ingenic_drm *priv,\n\t\t\t\t\t unsigned int hwdesc,\n\t\t\t\t\t unsigned int next_hwdesc, u32 id)\n{\n\tstruct ingenic_dma_hwdesc *desc = &priv->dma_hwdescs->hwdesc[hwdesc];\n\n\tdesc->next = dma_hwdesc_addr(priv, next_hwdesc);\n\tdesc->id = id;\n}\n\nstatic void ingenic_drm_configure_hwdesc_palette(struct ingenic_drm *priv)\n{\n\tstruct ingenic_dma_hwdesc *desc;\n\n\tingenic_drm_configure_hwdesc(priv, HWDESC_PALETTE, 0, 0xc0);\n\n\tdesc = &priv->dma_hwdescs->hwdesc[HWDESC_PALETTE];\n\tdesc->addr = priv->dma_hwdescs_phys\n\t\t+ offsetof(struct ingenic_dma_hwdescs, palette);\n\tdesc->cmd = JZ_LCD_CMD_ENABLE_PAL\n\t\t| (sizeof(priv->dma_hwdescs->palette) / 4);\n}\n\nstatic void ingenic_drm_configure_hwdesc_plane(struct ingenic_drm *priv,\n\t\t\t\t\t       unsigned int plane)\n{\n\tingenic_drm_configure_hwdesc(priv, plane, plane, 0xf0 | plane);\n}\n\nstatic void ingenic_drm_atomic_private_obj_fini(struct drm_device *drm, void *private_obj)\n{\n\tdrm_atomic_private_obj_fini(private_obj);\n}\n\nstatic int ingenic_drm_bind(struct device *dev, bool has_components)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ingenic_drm_private_state *private_state;\n\tconst struct jz_soc_info *soc_info;\n\tstruct ingenic_drm *priv;\n\tstruct clk *parent_clk;\n\tstruct drm_plane *primary;\n\tstruct drm_bridge *bridge;\n\tstruct drm_panel *panel;\n\tstruct drm_connector *connector;\n\tstruct drm_encoder *encoder;\n\tstruct ingenic_drm_bridge *ib;\n\tstruct drm_device *drm;\n\tvoid __iomem *base;\n\tstruct resource *res;\n\tstruct regmap_config regmap_config;\n\tlong parent_rate;\n\tunsigned int i, clone_mask = 0;\n\tint ret, irq;\n\tu32 osdc = 0;\n\n\tsoc_info = of_device_get_match_data(dev);\n\tif (!soc_info) {\n\t\tdev_err(dev, \"Missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_OF_RESERVED_MEM)) {\n\t\tret = of_reserved_mem_device_init(dev);\n\n\t\tif (ret && ret != -ENODEV)\n\t\t\tdev_warn(dev, \"Failed to get reserved memory: %d\\n\", ret);\n\n\t\tif (!ret) {\n\t\t\tret = devm_add_action_or_reset(dev, ingenic_drm_release_rmem, dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpriv = devm_drm_dev_alloc(dev, &ingenic_drm_driver_data,\n\t\t\t\t  struct ingenic_drm, drm);\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tpriv->soc_info = soc_info;\n\tpriv->dev = dev;\n\tdrm = &priv->drm;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = soc_info->max_width;\n\tdrm->mode_config.max_height = 4095;\n\tdrm->mode_config.funcs = &ingenic_drm_mode_config_funcs;\n\tdrm->mode_config.helper_private = &ingenic_drm_mode_config_helpers;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base)) {\n\t\tdev_err(dev, \"Failed to get memory resource\\n\");\n\t\treturn PTR_ERR(base);\n\t}\n\n\tregmap_config = ingenic_drm_regmap_config;\n\tregmap_config.max_register = res->end - res->start;\n\tpriv->map = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t  &regmap_config);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(dev, \"Failed to create regmap\\n\");\n\t\treturn PTR_ERR(priv->map);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (soc_info->needs_dev_clk) {\n\t\tpriv->lcd_clk = devm_clk_get(dev, \"lcd\");\n\t\tif (IS_ERR(priv->lcd_clk)) {\n\t\t\tdev_err(dev, \"Failed to get lcd clock\\n\");\n\t\t\treturn PTR_ERR(priv->lcd_clk);\n\t\t}\n\t}\n\n\tpriv->pix_clk = devm_clk_get(dev, \"lcd_pclk\");\n\tif (IS_ERR(priv->pix_clk)) {\n\t\tdev_err(dev, \"Failed to get pixel clock\\n\");\n\t\treturn PTR_ERR(priv->pix_clk);\n\t}\n\n\tpriv->dma_hwdescs = dmam_alloc_coherent(dev,\n\t\t\t\t\t\tsizeof(*priv->dma_hwdescs),\n\t\t\t\t\t\t&priv->dma_hwdescs_phys,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!priv->dma_hwdescs)\n\t\treturn -ENOMEM;\n\n\t \n\tingenic_drm_configure_hwdesc_plane(priv, 0);\n\n\t \n\tingenic_drm_configure_hwdesc_plane(priv, 1);\n\n\t \n\tingenic_drm_configure_hwdesc_palette(priv);\n\n\tprimary = priv->soc_info->has_osd ? &priv->f1 : &priv->f0;\n\n\tdrm_plane_helper_add(primary, &ingenic_drm_plane_helper_funcs);\n\n\tret = drm_universal_plane_init(drm, primary, 1,\n\t\t\t\t       &ingenic_drm_primary_plane_funcs,\n\t\t\t\t       priv->soc_info->formats_f1,\n\t\t\t\t       priv->soc_info->num_formats_f1,\n\t\t\t\t       NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register plane: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (soc_info->map_noncoherent)\n\t\tdrm_plane_enable_fb_damage_clips(&priv->f1);\n\n\tdrm_crtc_helper_add(&priv->crtc, &ingenic_drm_crtc_helper_funcs);\n\n\tret = drm_crtc_init_with_planes(drm, &priv->crtc, primary,\n\t\t\t\t\tNULL, &ingenic_drm_crtc_funcs, NULL);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to init CRTC: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_enable_color_mgmt(&priv->crtc, 0, false,\n\t\t\t\t   ARRAY_SIZE(priv->dma_hwdescs->palette));\n\n\tif (soc_info->has_osd) {\n\t\tdrm_plane_helper_add(&priv->f0,\n\t\t\t\t     &ingenic_drm_plane_helper_funcs);\n\n\t\tret = drm_universal_plane_init(drm, &priv->f0, 1,\n\t\t\t\t\t       &ingenic_drm_primary_plane_funcs,\n\t\t\t\t\t       priv->soc_info->formats_f0,\n\t\t\t\t\t       priv->soc_info->num_formats_f0,\n\t\t\t\t\t       NULL, DRM_PLANE_TYPE_OVERLAY,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register overlay plane: %i\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (soc_info->map_noncoherent)\n\t\t\tdrm_plane_enable_fb_damage_clips(&priv->f0);\n\n\t\tif (IS_ENABLED(CONFIG_DRM_INGENIC_IPU) && has_components) {\n\t\t\tret = component_bind_all(dev, drm);\n\t\t\tif (ret) {\n\t\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\t\tdev_err(dev, \"Failed to bind components: %i\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = devm_add_action_or_reset(dev, ingenic_drm_unbind_all, priv);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tpriv->ipu_plane = drm_plane_from_index(drm, 2);\n\t\t\tif (!priv->ipu_plane) {\n\t\t\t\tdev_err(dev, \"Failed to retrieve IPU plane\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; ; i++) {\n\t\tret = drm_of_find_panel_or_bridge(dev->of_node, 0, i, &panel, &bridge);\n\t\tif (ret) {\n\t\t\tif (ret == -ENODEV)\n\t\t\t\tbreak;  \n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to get bridge handle\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (panel)\n\t\t\tbridge = devm_drm_panel_bridge_add_typed(dev, panel,\n\t\t\t\t\t\t\t\t DRM_MODE_CONNECTOR_DPI);\n\n\t\tib = drmm_encoder_alloc(drm, struct ingenic_drm_bridge, encoder,\n\t\t\t\t\tNULL, DRM_MODE_ENCODER_DPI, NULL);\n\t\tif (IS_ERR(ib)) {\n\t\t\tret = PTR_ERR(ib);\n\t\t\tdev_err(dev, \"Failed to init encoder: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tencoder = &ib->encoder;\n\t\tencoder->possible_crtcs = drm_crtc_mask(&priv->crtc);\n\n\t\tdrm_encoder_helper_add(encoder, &ingenic_drm_encoder_helper_funcs);\n\n\t\tib->bridge.funcs = &ingenic_drm_bridge_funcs;\n\t\tib->next_bridge = bridge;\n\n\t\tret = drm_bridge_attach(encoder, &ib->bridge, NULL,\n\t\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to attach bridge\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tconnector = drm_bridge_connector_init(drm, encoder);\n\t\tif (IS_ERR(connector)) {\n\t\t\tdev_err(dev, \"Unable to init connector\\n\");\n\t\t\treturn PTR_ERR(connector);\n\t\t}\n\n\t\tdrm_connector_attach_encoder(connector, encoder);\n\t}\n\n\tdrm_for_each_encoder(encoder, drm) {\n\t\tclone_mask |= BIT(drm_encoder_index(encoder));\n\t}\n\n\tdrm_for_each_encoder(encoder, drm) {\n\t\tencoder->possible_clones = clone_mask;\n\t}\n\n\tret = devm_request_irq(dev, irq, ingenic_drm_irq_handler, 0, drm->driver->name, drm);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to install IRQ handler\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drm_vblank_init(drm, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed calling drm_vblank_init()\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_mode_config_reset(drm);\n\n\tret = clk_prepare_enable(priv->pix_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to start pixel clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (priv->lcd_clk) {\n\t\tparent_clk = clk_get_parent(priv->lcd_clk);\n\t\tparent_rate = clk_get_rate(parent_clk);\n\n\t\t \n\t\tret = clk_set_rate(priv->lcd_clk, parent_rate);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to set LCD clock rate\\n\");\n\t\t\tgoto err_pixclk_disable;\n\t\t}\n\n\t\tret = clk_prepare_enable(priv->lcd_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Unable to start lcd clock\\n\");\n\t\t\tgoto err_pixclk_disable;\n\t\t}\n\t}\n\n\t \n\tif (soc_info->has_osd)\n\t\tosdc |= JZ_LCD_OSDC_OSDEN;\n\tif (soc_info->has_alpha)\n\t\tosdc |= JZ_LCD_OSDC_ALPHAEN;\n\tregmap_write(priv->map, JZ_REG_LCD_OSDC, osdc);\n\n\tmutex_init(&priv->clk_mutex);\n\tpriv->clock_nb.notifier_call = ingenic_drm_update_pixclk;\n\n\tparent_clk = clk_get_parent(priv->pix_clk);\n\tret = clk_notifier_register(parent_clk, &priv->clock_nb);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to register clock notifier\\n\");\n\t\tgoto err_devclk_disable;\n\t}\n\n\tprivate_state = kzalloc(sizeof(*private_state), GFP_KERNEL);\n\tif (!private_state) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_notifier_unregister;\n\t}\n\n\tdrm_atomic_private_obj_init(drm, &priv->private_obj, &private_state->base,\n\t\t\t\t    &ingenic_drm_private_state_funcs);\n\n\tret = drmm_add_action_or_reset(drm, ingenic_drm_atomic_private_obj_fini,\n\t\t\t\t       &priv->private_obj);\n\tif (ret)\n\t\tgoto err_private_state_free;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register DRM driver\\n\");\n\t\tgoto err_clk_notifier_unregister;\n\t}\n\n\tdrm_fbdev_generic_setup(drm, 32);\n\n\treturn 0;\n\nerr_private_state_free:\n\tkfree(private_state);\nerr_clk_notifier_unregister:\n\tclk_notifier_unregister(parent_clk, &priv->clock_nb);\nerr_devclk_disable:\n\tif (priv->lcd_clk)\n\t\tclk_disable_unprepare(priv->lcd_clk);\nerr_pixclk_disable:\n\tclk_disable_unprepare(priv->pix_clk);\n\treturn ret;\n}\n\nstatic int ingenic_drm_bind_with_components(struct device *dev)\n{\n\treturn ingenic_drm_bind(dev, true);\n}\n\nstatic void ingenic_drm_unbind(struct device *dev)\n{\n\tstruct ingenic_drm *priv = dev_get_drvdata(dev);\n\tstruct clk *parent_clk = clk_get_parent(priv->pix_clk);\n\n\tclk_notifier_unregister(parent_clk, &priv->clock_nb);\n\tif (priv->lcd_clk)\n\t\tclk_disable_unprepare(priv->lcd_clk);\n\tclk_disable_unprepare(priv->pix_clk);\n\n\tdrm_dev_unregister(&priv->drm);\n\tdrm_atomic_helper_shutdown(&priv->drm);\n}\n\nstatic const struct component_master_ops ingenic_master_ops = {\n\t.bind = ingenic_drm_bind_with_components,\n\t.unbind = ingenic_drm_unbind,\n};\n\nstatic int ingenic_drm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct component_match *match = NULL;\n\tstruct device_node *np;\n\n\tif (!IS_ENABLED(CONFIG_DRM_INGENIC_IPU))\n\t\treturn ingenic_drm_bind(dev, false);\n\n\t \n\tnp = of_graph_get_remote_node(dev->of_node, 8, 0);\n\tif (!np)\n\t\treturn ingenic_drm_bind(dev, false);\n\n\tdrm_of_component_match_add(dev, &match, component_compare_of, np);\n\tof_node_put(np);\n\n\treturn component_master_add_with_match(dev, &ingenic_master_ops, match);\n}\n\nstatic int ingenic_drm_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tif (!IS_ENABLED(CONFIG_DRM_INGENIC_IPU))\n\t\tingenic_drm_unbind(dev);\n\telse\n\t\tcomponent_master_del(dev, &ingenic_master_ops);\n\n\treturn 0;\n}\n\nstatic int ingenic_drm_suspend(struct device *dev)\n{\n\tstruct ingenic_drm *priv = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(&priv->drm);\n}\n\nstatic int ingenic_drm_resume(struct device *dev)\n{\n\tstruct ingenic_drm *priv = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_resume(&priv->drm);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ingenic_drm_pm_ops,\n\t\t\t\tingenic_drm_suspend, ingenic_drm_resume);\n\nstatic const u32 jz4740_formats[] = {\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const u32 jz4725b_formats_f1[] = {\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const u32 jz4725b_formats_f0[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB8888,\n};\n\nstatic const u32 jz4770_formats_f1[] = {\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XRGB2101010,\n};\n\nstatic const u32 jz4770_formats_f0[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_RGB888,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XRGB2101010,\n};\n\nstatic const struct jz_soc_info jz4740_soc_info = {\n\t.needs_dev_clk = true,\n\t.has_osd = false,\n\t.map_noncoherent = false,\n\t.max_width = 800,\n\t.max_height = 600,\n\t.max_burst = JZ_LCD_CTRL_BURST_16,\n\t.formats_f1 = jz4740_formats,\n\t.num_formats_f1 = ARRAY_SIZE(jz4740_formats),\n\t \n};\n\nstatic const struct jz_soc_info jz4725b_soc_info = {\n\t.needs_dev_clk = false,\n\t.has_osd = true,\n\t.map_noncoherent = false,\n\t.max_width = 800,\n\t.max_height = 600,\n\t.max_burst = JZ_LCD_CTRL_BURST_16,\n\t.formats_f1 = jz4725b_formats_f1,\n\t.num_formats_f1 = ARRAY_SIZE(jz4725b_formats_f1),\n\t.formats_f0 = jz4725b_formats_f0,\n\t.num_formats_f0 = ARRAY_SIZE(jz4725b_formats_f0),\n};\n\nstatic const struct jz_soc_info jz4760_soc_info = {\n\t.needs_dev_clk = false,\n\t.has_osd = true,\n\t.map_noncoherent = false,\n\t.max_width = 1280,\n\t.max_height = 720,\n\t.max_burst = JZ_LCD_CTRL_BURST_32,\n\t.formats_f1 = jz4770_formats_f1,\n\t.num_formats_f1 = ARRAY_SIZE(jz4770_formats_f1),\n\t.formats_f0 = jz4770_formats_f0,\n\t.num_formats_f0 = ARRAY_SIZE(jz4770_formats_f0),\n};\n\nstatic const struct jz_soc_info jz4760b_soc_info = {\n\t.needs_dev_clk = false,\n\t.has_osd = true,\n\t.map_noncoherent = false,\n\t.max_width = 1280,\n\t.max_height = 720,\n\t.max_burst = JZ_LCD_CTRL_BURST_64,\n\t.formats_f1 = jz4770_formats_f1,\n\t.num_formats_f1 = ARRAY_SIZE(jz4770_formats_f1),\n\t.formats_f0 = jz4770_formats_f0,\n\t.num_formats_f0 = ARRAY_SIZE(jz4770_formats_f0),\n};\n\nstatic const struct jz_soc_info jz4770_soc_info = {\n\t.needs_dev_clk = false,\n\t.has_osd = true,\n\t.map_noncoherent = true,\n\t.max_width = 1280,\n\t.max_height = 720,\n\t.max_burst = JZ_LCD_CTRL_BURST_64,\n\t.formats_f1 = jz4770_formats_f1,\n\t.num_formats_f1 = ARRAY_SIZE(jz4770_formats_f1),\n\t.formats_f0 = jz4770_formats_f0,\n\t.num_formats_f0 = ARRAY_SIZE(jz4770_formats_f0),\n};\n\nstatic const struct jz_soc_info jz4780_soc_info = {\n\t.needs_dev_clk = true,\n\t.has_osd = true,\n\t.has_alpha = true,\n\t.use_extended_hwdesc = true,\n\t.plane_f0_not_working = true,\t \n\t.max_width = 4096,\n\t.max_height = 2048,\n\t.max_burst = JZ_LCD_CTRL_BURST_64,\n\t.formats_f1 = jz4770_formats_f1,\n\t.num_formats_f1 = ARRAY_SIZE(jz4770_formats_f1),\n\t.formats_f0 = jz4770_formats_f0,\n\t.num_formats_f0 = ARRAY_SIZE(jz4770_formats_f0),\n};\n\nstatic const struct of_device_id ingenic_drm_of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-lcd\", .data = &jz4740_soc_info },\n\t{ .compatible = \"ingenic,jz4725b-lcd\", .data = &jz4725b_soc_info },\n\t{ .compatible = \"ingenic,jz4760-lcd\", .data = &jz4760_soc_info },\n\t{ .compatible = \"ingenic,jz4760b-lcd\", .data = &jz4760b_soc_info },\n\t{ .compatible = \"ingenic,jz4770-lcd\", .data = &jz4770_soc_info },\n\t{ .compatible = \"ingenic,jz4780-lcd\", .data = &jz4780_soc_info },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ingenic_drm_of_match);\n\nstatic struct platform_driver ingenic_drm_driver = {\n\t.driver = {\n\t\t.name = \"ingenic-drm\",\n\t\t.pm = pm_sleep_ptr(&ingenic_drm_pm_ops),\n\t\t.of_match_table = of_match_ptr(ingenic_drm_of_match),\n\t},\n\t.probe = ingenic_drm_probe,\n\t.remove = ingenic_drm_remove,\n};\n\nstatic int ingenic_drm_init(void)\n{\n\tint err;\n\n\tif (drm_firmware_drivers_only())\n\t\treturn -ENODEV;\n\n\tif (IS_ENABLED(CONFIG_DRM_INGENIC_IPU)) {\n\t\terr = platform_driver_register(ingenic_ipu_driver_ptr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = platform_driver_register(&ingenic_drm_driver);\n\tif (IS_ENABLED(CONFIG_DRM_INGENIC_IPU) && err)\n\t\tplatform_driver_unregister(ingenic_ipu_driver_ptr);\n\n\treturn err;\n}\nmodule_init(ingenic_drm_init);\n\nstatic void ingenic_drm_exit(void)\n{\n\tplatform_driver_unregister(&ingenic_drm_driver);\n\n\tif (IS_ENABLED(CONFIG_DRM_INGENIC_IPU))\n\t\tplatform_driver_unregister(ingenic_ipu_driver_ptr);\n}\nmodule_exit(ingenic_drm_exit);\n\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"DRM driver for the Ingenic SoCs\\n\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}