{
  "module_name": "tve200_display.c",
  "hash_id": "4bbd696d51a328ec40c0855212a66a5aecb235419095bb940b073e4d9cf99ebe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tve200/tve200_display.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-buf.h>\n#include <linux/of_graph.h>\n#include <linux/delay.h>\n\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_vblank.h>\n\n#include \"tve200_drm.h\"\n\nirqreturn_t tve200_irq(int irq, void *data)\n{\n\tstruct tve200_drm_dev_private *priv = data;\n\tu32 stat;\n\tu32 val;\n\n\tstat = readl(priv->regs + TVE200_INT_STAT);\n\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (stat & TVE200_INT_V_STATUS) {\n\t\tval = readl(priv->regs + TVE200_CTRL);\n\t\t \n\t\tif (!(val & TVE200_VSTSTYPE_BITS)) {\n\t\t\tdrm_crtc_handle_vblank(&priv->pipe.crtc);\n\t\t\t \n\t\t\tval |= TVE200_VSTSTYPE_VAI;\n\t\t} else {\n\t\t\t \n\t\t\tval &= ~TVE200_VSTSTYPE_BITS;\n\t\t}\n\t\twritel(val, priv->regs + TVE200_CTRL);\n\t} else\n\t\tdev_err(priv->drm->dev, \"stray IRQ %08x\\n\", stat);\n\n\t \n\twritel(stat, priv->regs + TVE200_INT_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tve200_display_check(struct drm_simple_display_pipe *pipe,\n\t\t\t       struct drm_plane_state *pstate,\n\t\t\t       struct drm_crtc_state *cstate)\n{\n\tconst struct drm_display_mode *mode = &cstate->mode;\n\tstruct drm_framebuffer *old_fb = pipe->plane.state->fb;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\n\t \n\tif (!(mode->hdisplay == 352 && mode->vdisplay == 240) &&  \n\t    !(mode->hdisplay == 352 && mode->vdisplay == 288) &&  \n\t    !(mode->hdisplay == 640 && mode->vdisplay == 480) &&  \n\t    !(mode->hdisplay == 720 && mode->vdisplay == 480) &&  \n\t    !(mode->hdisplay == 720 && mode->vdisplay == 576)) {  \n\t\tDRM_DEBUG_KMS(\"unsupported display mode (%u x %u)\\n\",\n\t\t\tmode->hdisplay, mode->vdisplay);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fb) {\n\t\tu32 offset = drm_fb_dma_get_gem_addr(fb, pstate, 0);\n\n\t\t \n\t\tif (offset & 3) {\n\t\t\tDRM_DEBUG_KMS(\"FB not 32-bit aligned\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (fb->pitches[0] != mode->hdisplay * fb->format->cpp[0]) {\n\t\t\tDRM_DEBUG_KMS(\"can't handle pitches\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (old_fb && old_fb->format != fb->format)\n\t\t\tcstate->mode_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void tve200_display_enable(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_crtc_state *cstate,\n\t\t\t\t struct drm_plane_state *plane_state)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\tconst struct drm_display_mode *mode = &cstate->mode;\n\tstruct drm_framebuffer *fb = plane->state->fb;\n\tstruct drm_connector *connector = priv->connector;\n\tu32 format = fb->format->format;\n\tu32 ctrl1 = 0;\n\tint retries;\n\n\tclk_prepare_enable(priv->clk);\n\n\t \n\twritel(TVE200_CTRL_4_RESET, priv->regs + TVE200_CTRL_4);\n\tfor (retries = 0; retries < 5; retries++) {\n\t\tusleep_range(30000, 50000);\n\t\tif (readl(priv->regs + TVE200_CTRL_4) & TVE200_CTRL_4_RESET)\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (retries == 5 &&\n\t    readl(priv->regs + TVE200_CTRL_4) & TVE200_CTRL_4_RESET) {\n\t\tdev_err(drm->dev, \"can't get hardware out of reset\\n\");\n\t\treturn;\n\t}\n\n\t \n\tctrl1 |= TVE200_CTRL_CSMODE;\n\t \n\tctrl1 |= TVE200_CTRL_NONINTERLACE;\n\t \n\tctrl1 |= TVE200_CTRL_BURST_32_WORDS;\n\t \n\tctrl1 |= TVE200_CTRL_RETRYCNT_16;\n\t \n\tctrl1 |= TVE200_CTRL_NTSC;\n\n\t \n\tctrl1 |= TVE200_VSTSTYPE_VSYNC;\n\n\tif (connector->display_info.bus_flags &\n\t    DRM_BUS_FLAG_PIXDATA_DRIVE_NEGEDGE)\n\t\tctrl1 |= TVE200_CTRL_TVCLKP;\n\n\tif ((mode->hdisplay == 352 && mode->vdisplay == 240) ||  \n\t    (mode->hdisplay == 352 && mode->vdisplay == 288)) {  \n\t\tctrl1 |= TVE200_CTRL_IPRESOL_CIF;\n\t\tdev_info(drm->dev, \"CIF mode\\n\");\n\t} else if (mode->hdisplay == 640 && mode->vdisplay == 480) {\n\t\tctrl1 |= TVE200_CTRL_IPRESOL_VGA;\n\t\tdev_info(drm->dev, \"VGA mode\\n\");\n\t} else if ((mode->hdisplay == 720 && mode->vdisplay == 480) ||\n\t\t   (mode->hdisplay == 720 && mode->vdisplay == 576)) {\n\t\tctrl1 |= TVE200_CTRL_IPRESOL_D1;\n\t\tdev_info(drm->dev, \"D1 mode\\n\");\n\t}\n\n\tif (format & DRM_FORMAT_BIG_ENDIAN) {\n\t\tctrl1 |= TVE200_CTRL_BBBP;\n\t\tformat &= ~DRM_FORMAT_BIG_ENDIAN;\n\t}\n\n\tswitch (format) {\n\tcase DRM_FORMAT_XRGB8888:\n\t\tctrl1 |= TVE200_IPDMOD_RGB888;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tctrl1 |= TVE200_IPDMOD_RGB565;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tctrl1 |= TVE200_IPDMOD_RGB555;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\t\tctrl1 |= TVE200_IPDMOD_RGB888 | TVE200_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_BGR565:\n\t\tctrl1 |= TVE200_IPDMOD_RGB565 | TVE200_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR1555:\n\t\tctrl1 |= TVE200_IPDMOD_RGB555 | TVE200_BGR;\n\t\tbreak;\n\tcase DRM_FORMAT_YUYV:\n\t\tctrl1 |= TVE200_IPDMOD_YUV422;\n\t\tctrl1 |= TVE200_CTRL_YCBCRODR_CR0Y1CB0Y0;\n\t\tbreak;\n\tcase DRM_FORMAT_YVYU:\n\t\tctrl1 |= TVE200_IPDMOD_YUV422;\n\t\tctrl1 |= TVE200_CTRL_YCBCRODR_CB0Y1CR0Y0;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tctrl1 |= TVE200_IPDMOD_YUV422;\n\t\tctrl1 |= TVE200_CTRL_YCBCRODR_Y1CR0Y0CB0;\n\t\tbreak;\n\tcase DRM_FORMAT_VYUY:\n\t\tctrl1 |= TVE200_IPDMOD_YUV422;\n\t\tctrl1 |= TVE200_CTRL_YCBCRODR_Y1CB0Y0CR0;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420:\n\t\tctrl1 |= TVE200_CTRL_YUV420;\n\t\tctrl1 |= TVE200_IPDMOD_YUV420;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(drm->dev, \"Unknown FB format 0x%08x\\n\",\n\t\t\tfb->format->format);\n\t\tbreak;\n\t}\n\n\tctrl1 |= TVE200_TVEEN;\n\n\t \n\twritel(ctrl1, priv->regs + TVE200_CTRL);\n\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void tve200_display_disable(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\n\tdrm_crtc_vblank_off(crtc);\n\n\t \n\twritel(0, priv->regs + TVE200_CTRL);\n\twritel(TVE200_CTRL_4_RESET, priv->regs + TVE200_CTRL_4);\n\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic void tve200_display_update(struct drm_simple_display_pipe *pipe,\n\t\t\t\t struct drm_plane_state *old_pstate)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\tstruct drm_plane *plane = &pipe->plane;\n\tstruct drm_plane_state *pstate = plane->state;\n\tstruct drm_framebuffer *fb = pstate->fb;\n\n\tif (fb) {\n\t\t \n\t\twritel(drm_fb_dma_get_gem_addr(fb, pstate, 0),\n\t\t       priv->regs + TVE200_Y_FRAME_BASE_ADDR);\n\n\t\t \n\t\tif (fb->format->format == DRM_FORMAT_YUV420) {\n\t\t\twritel(drm_fb_dma_get_gem_addr(fb, pstate, 1),\n\t\t\t       priv->regs + TVE200_U_FRAME_BASE_ADDR);\n\t\t\twritel(drm_fb_dma_get_gem_addr(fb, pstate, 2),\n\t\t\t       priv->regs + TVE200_V_FRAME_BASE_ADDR);\n\t\t}\n\t}\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (crtc->state->active && drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic int tve200_display_enable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\n\t \n\twritel(0xFF, priv->regs + TVE200_INT_CLR);\n\twritel(TVE200_INT_V_STATUS, priv->regs + TVE200_INT_EN);\n\treturn 0;\n}\n\nstatic void tve200_display_disable_vblank(struct drm_simple_display_pipe *pipe)\n{\n\tstruct drm_crtc *crtc = &pipe->crtc;\n\tstruct drm_device *drm = crtc->dev;\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\n\twritel(0, priv->regs + TVE200_INT_EN);\n}\n\nstatic const struct drm_simple_display_pipe_funcs tve200_display_funcs = {\n\t.check = tve200_display_check,\n\t.enable = tve200_display_enable,\n\t.disable = tve200_display_disable,\n\t.update = tve200_display_update,\n\t.enable_vblank = tve200_display_enable_vblank,\n\t.disable_vblank = tve200_display_disable_vblank,\n};\n\nint tve200_display_init(struct drm_device *drm)\n{\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\tint ret;\n\tstatic const u32 formats[] = {\n\t\tDRM_FORMAT_XRGB8888,\n\t\tDRM_FORMAT_XBGR8888,\n\t\tDRM_FORMAT_RGB565,\n\t\tDRM_FORMAT_BGR565,\n\t\tDRM_FORMAT_XRGB1555,\n\t\tDRM_FORMAT_XBGR1555,\n\t\t \n\t\tDRM_FORMAT_YUYV,\n\t\tDRM_FORMAT_YVYU,\n\t\tDRM_FORMAT_UYVY,\n\t\tDRM_FORMAT_VYUY,\n\t\t \n\t\tDRM_FORMAT_YUV420,\n\t};\n\n\tret = drm_simple_display_pipe_init(drm, &priv->pipe,\n\t\t\t\t\t   &tve200_display_funcs,\n\t\t\t\t\t   formats, ARRAY_SIZE(formats),\n\t\t\t\t\t   NULL,\n\t\t\t\t\t   priv->connector);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}