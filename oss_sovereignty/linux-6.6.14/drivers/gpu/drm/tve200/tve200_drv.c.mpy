{
  "module_name": "tve200_drv.c",
  "hash_id": "aec745d724f21469a1e3bfd38b5d8a006bcd5b7c0360f3f9e1ae50c7da8b5812",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/tve200/tve200_drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/dma-buf.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/shmem_fs.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_panel.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"tve200_drm.h\"\n\n#define DRIVER_DESC      \"DRM module for Faraday TVE200\"\n\nstatic const struct drm_mode_config_funcs mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int tve200_modeset_init(struct drm_device *dev)\n{\n\tstruct drm_mode_config *mode_config;\n\tstruct tve200_drm_dev_private *priv = dev->dev_private;\n\tstruct drm_panel *panel;\n\tstruct drm_bridge *bridge;\n\tint ret;\n\n\tdrm_mode_config_init(dev);\n\tmode_config = &dev->mode_config;\n\tmode_config->funcs = &mode_config_funcs;\n\tmode_config->min_width = 352;\n\tmode_config->max_width = 720;\n\tmode_config->min_height = 240;\n\tmode_config->max_height = 576;\n\n\tret = drm_of_find_panel_or_bridge(dev->dev->of_node,\n\t\t\t\t\t  0, 0, &panel, &bridge);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\tif (panel) {\n\t\tbridge = drm_panel_bridge_add_typed(panel,\n\t\t\t\t\t\t    DRM_MODE_CONNECTOR_Unknown);\n\t\tif (IS_ERR(bridge)) {\n\t\t\tret = PTR_ERR(bridge);\n\t\t\tgoto out_bridge;\n\t\t}\n\t} else {\n\t\t \n\t\tdev_err(dev->dev, \"the bridge is not a panel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_bridge;\n\t}\n\n\tret = tve200_display_init(dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to init display\\n\");\n\t\tgoto out_bridge;\n\t}\n\n\tret = drm_simple_display_pipe_attach_bridge(&priv->pipe,\n\t\t\t\t\t\t    bridge);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to attach bridge\\n\");\n\t\tgoto out_bridge;\n\t}\n\n\tpriv->panel = panel;\n\tpriv->connector = drm_panel_bridge_connector(bridge);\n\tpriv->bridge = bridge;\n\n\tdev_info(dev->dev, \"attached to panel %s\\n\",\n\t\t dev_name(panel->dev));\n\n\tret = drm_vblank_init(dev, 1);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"failed to init vblank\\n\");\n\t\tgoto out_bridge;\n\t}\n\n\tdrm_mode_config_reset(dev);\n\tdrm_kms_helper_poll_init(dev);\n\n\tgoto finish;\n\nout_bridge:\n\tif (panel)\n\t\tdrm_panel_bridge_remove(bridge);\n\tdrm_mode_config_cleanup(dev);\nfinish:\n\treturn ret;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(drm_fops);\n\nstatic const struct drm_driver tve200_drm_driver = {\n\t.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,\n\t.ioctls = NULL,\n\t.fops = &drm_fops,\n\t.name = \"tve200\",\n\t.desc = DRIVER_DESC,\n\t.date = \"20170703\",\n\t.major = 1,\n\t.minor = 0,\n\t.patchlevel = 0,\n\tDRM_GEM_DMA_DRIVER_OPS,\n};\n\nstatic int tve200_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tve200_drm_dev_private *priv;\n\tstruct drm_device *drm;\n\tint irq;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdrm = drm_dev_alloc(&tve200_drm_driver, dev);\n\tif (IS_ERR(drm))\n\t\treturn PTR_ERR(drm);\n\tplatform_set_drvdata(pdev, drm);\n\tpriv->drm = drm;\n\tdrm->dev_private = priv;\n\n\t \n\tpriv->pclk = devm_clk_get(dev, \"PCLK\");\n\tif (IS_ERR(priv->pclk)) {\n\t\tdev_err(dev, \"unable to get PCLK\\n\");\n\t\tret = PTR_ERR(priv->pclk);\n\t\tgoto dev_unref;\n\t}\n\tret = clk_prepare_enable(priv->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable PCLK\\n\");\n\t\tgoto dev_unref;\n\t}\n\n\t \n\tpriv->clk = devm_clk_get(dev, \"TVE\");\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"unable to get TVE clock\\n\");\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto clk_disable;\n\t}\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs)) {\n\t\tdev_err(dev, \"%s failed mmio\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto clk_disable;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto clk_disable;\n\t}\n\n\t \n\twritel(0, priv->regs + TVE200_INT_EN);\n\n\tret = devm_request_irq(dev, irq, tve200_irq, 0, \"tve200\", priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq %d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\tret = tve200_modeset_init(drm);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto clk_disable;\n\n\t \n\tdrm_fbdev_dma_setup(drm, 16);\n\n\treturn 0;\n\nclk_disable:\n\tclk_disable_unprepare(priv->pclk);\ndev_unref:\n\tdrm_dev_put(drm);\n\treturn ret;\n}\n\nstatic void tve200_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\tstruct tve200_drm_dev_private *priv = drm->dev_private;\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tif (priv->panel)\n\t\tdrm_panel_bridge_remove(priv->bridge);\n\tdrm_mode_config_cleanup(drm);\n\tclk_disable_unprepare(priv->pclk);\n\tdrm_dev_put(drm);\n}\n\nstatic void tve200_shutdown(struct platform_device *pdev)\n{\n\tdrm_atomic_helper_shutdown(platform_get_drvdata(pdev));\n}\n\nstatic const struct of_device_id tve200_of_match[] = {\n\t{\n\t\t.compatible = \"faraday,tve200\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver tve200_driver = {\n\t.driver = {\n\t\t.name           = \"tve200\",\n\t\t.of_match_table = tve200_of_match,\n\t},\n\t.probe = tve200_probe,\n\t.remove_new = tve200_remove,\n\t.shutdown = tve200_shutdown,\n};\ndrm_module_platform_driver(tve200_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}