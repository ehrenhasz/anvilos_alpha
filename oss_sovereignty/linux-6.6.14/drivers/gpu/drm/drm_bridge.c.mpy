{
  "module_name": "drm_bridge.c",
  "hash_id": "39503492b0ed4f5527d77d252277bd1a251679961d0df807ff918e9ae47146a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_bridge.c",
  "human_readable_source": " \n\n#include <linux/err.h>\n#include <linux/media-bus-format.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <drm/drm_atomic_state_helper.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_file.h>\n#include <drm/drm_of.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n\n \n\n \n\n \n\n \n\nstatic DEFINE_MUTEX(bridge_lock);\nstatic LIST_HEAD(bridge_list);\n\n \nvoid drm_bridge_add(struct drm_bridge *bridge)\n{\n\tmutex_init(&bridge->hpd_mutex);\n\n\tmutex_lock(&bridge_lock);\n\tlist_add_tail(&bridge->list, &bridge_list);\n\tmutex_unlock(&bridge_lock);\n}\nEXPORT_SYMBOL(drm_bridge_add);\n\nstatic void drm_bridge_remove_void(void *bridge)\n{\n\tdrm_bridge_remove(bridge);\n}\n\n \nint devm_drm_bridge_add(struct device *dev, struct drm_bridge *bridge)\n{\n\tdrm_bridge_add(bridge);\n\treturn devm_add_action_or_reset(dev, drm_bridge_remove_void, bridge);\n}\nEXPORT_SYMBOL(devm_drm_bridge_add);\n\n \nvoid drm_bridge_remove(struct drm_bridge *bridge)\n{\n\tmutex_lock(&bridge_lock);\n\tlist_del_init(&bridge->list);\n\tmutex_unlock(&bridge_lock);\n\n\tmutex_destroy(&bridge->hpd_mutex);\n}\nEXPORT_SYMBOL(drm_bridge_remove);\n\nstatic struct drm_private_state *\ndrm_bridge_atomic_duplicate_priv_state(struct drm_private_obj *obj)\n{\n\tstruct drm_bridge *bridge = drm_priv_to_bridge(obj);\n\tstruct drm_bridge_state *state;\n\n\tstate = bridge->funcs->atomic_duplicate_state(bridge);\n\treturn state ? &state->base : NULL;\n}\n\nstatic void\ndrm_bridge_atomic_destroy_priv_state(struct drm_private_obj *obj,\n\t\t\t\t     struct drm_private_state *s)\n{\n\tstruct drm_bridge_state *state = drm_priv_to_bridge_state(s);\n\tstruct drm_bridge *bridge = drm_priv_to_bridge(obj);\n\n\tbridge->funcs->atomic_destroy_state(bridge, state);\n}\n\nstatic const struct drm_private_state_funcs drm_bridge_priv_state_funcs = {\n\t.atomic_duplicate_state = drm_bridge_atomic_duplicate_priv_state,\n\t.atomic_destroy_state = drm_bridge_atomic_destroy_priv_state,\n};\n\n \nint drm_bridge_attach(struct drm_encoder *encoder, struct drm_bridge *bridge,\n\t\t      struct drm_bridge *previous,\n\t\t      enum drm_bridge_attach_flags flags)\n{\n\tint ret;\n\n\tif (!encoder || !bridge)\n\t\treturn -EINVAL;\n\n\tif (previous && (!previous->dev || previous->encoder != encoder))\n\t\treturn -EINVAL;\n\n\tif (bridge->dev)\n\t\treturn -EBUSY;\n\n\tbridge->dev = encoder->dev;\n\tbridge->encoder = encoder;\n\n\tif (previous)\n\t\tlist_add(&bridge->chain_node, &previous->chain_node);\n\telse\n\t\tlist_add(&bridge->chain_node, &encoder->bridge_chain);\n\n\tif (bridge->funcs->attach) {\n\t\tret = bridge->funcs->attach(bridge, flags);\n\t\tif (ret < 0)\n\t\t\tgoto err_reset_bridge;\n\t}\n\n\tif (bridge->funcs->atomic_reset) {\n\t\tstruct drm_bridge_state *state;\n\n\t\tstate = bridge->funcs->atomic_reset(bridge);\n\t\tif (IS_ERR(state)) {\n\t\t\tret = PTR_ERR(state);\n\t\t\tgoto err_detach_bridge;\n\t\t}\n\n\t\tdrm_atomic_private_obj_init(bridge->dev, &bridge->base,\n\t\t\t\t\t    &state->base,\n\t\t\t\t\t    &drm_bridge_priv_state_funcs);\n\t}\n\n\treturn 0;\n\nerr_detach_bridge:\n\tif (bridge->funcs->detach)\n\t\tbridge->funcs->detach(bridge);\n\nerr_reset_bridge:\n\tbridge->dev = NULL;\n\tbridge->encoder = NULL;\n\tlist_del(&bridge->chain_node);\n\n#ifdef CONFIG_OF\n\tDRM_ERROR(\"failed to attach bridge %pOF to encoder %s: %d\\n\",\n\t\t  bridge->of_node, encoder->name, ret);\n#else\n\tDRM_ERROR(\"failed to attach bridge to encoder %s: %d\\n\",\n\t\t  encoder->name, ret);\n#endif\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_bridge_attach);\n\nvoid drm_bridge_detach(struct drm_bridge *bridge)\n{\n\tif (WARN_ON(!bridge))\n\t\treturn;\n\n\tif (WARN_ON(!bridge->dev))\n\t\treturn;\n\n\tif (bridge->funcs->atomic_reset)\n\t\tdrm_atomic_private_obj_fini(&bridge->base);\n\n\tif (bridge->funcs->detach)\n\t\tbridge->funcs->detach(bridge);\n\n\tlist_del(&bridge->chain_node);\n\tbridge->dev = NULL;\n}\n\n \n\n \nbool drm_bridge_chain_mode_fixup(struct drm_bridge *bridge,\n\t\t\t\t const struct drm_display_mode *mode,\n\t\t\t\t struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_encoder *encoder;\n\n\tif (!bridge)\n\t\treturn true;\n\n\tencoder = bridge->encoder;\n\tlist_for_each_entry_from(bridge, &encoder->bridge_chain, chain_node) {\n\t\tif (!bridge->funcs->mode_fixup)\n\t\t\tcontinue;\n\n\t\tif (!bridge->funcs->mode_fixup(bridge, mode, adjusted_mode))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_bridge_chain_mode_fixup);\n\n \nenum drm_mode_status\ndrm_bridge_chain_mode_valid(struct drm_bridge *bridge,\n\t\t\t    const struct drm_display_info *info,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct drm_encoder *encoder;\n\n\tif (!bridge)\n\t\treturn MODE_OK;\n\n\tencoder = bridge->encoder;\n\tlist_for_each_entry_from(bridge, &encoder->bridge_chain, chain_node) {\n\t\tenum drm_mode_status ret;\n\n\t\tif (!bridge->funcs->mode_valid)\n\t\t\tcontinue;\n\n\t\tret = bridge->funcs->mode_valid(bridge, info, mode);\n\t\tif (ret != MODE_OK)\n\t\t\treturn ret;\n\t}\n\n\treturn MODE_OK;\n}\nEXPORT_SYMBOL(drm_bridge_chain_mode_valid);\n\n \nvoid drm_bridge_chain_mode_set(struct drm_bridge *bridge,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       const struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_encoder *encoder;\n\n\tif (!bridge)\n\t\treturn;\n\n\tencoder = bridge->encoder;\n\tlist_for_each_entry_from(bridge, &encoder->bridge_chain, chain_node) {\n\t\tif (bridge->funcs->mode_set)\n\t\t\tbridge->funcs->mode_set(bridge, mode, adjusted_mode);\n\t}\n}\nEXPORT_SYMBOL(drm_bridge_chain_mode_set);\n\n \nvoid drm_atomic_bridge_chain_disable(struct drm_bridge *bridge,\n\t\t\t\t     struct drm_atomic_state *old_state)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *iter;\n\n\tif (!bridge)\n\t\treturn;\n\n\tencoder = bridge->encoder;\n\tlist_for_each_entry_reverse(iter, &encoder->bridge_chain, chain_node) {\n\t\tif (iter->funcs->atomic_disable) {\n\t\t\tstruct drm_bridge_state *old_bridge_state;\n\n\t\t\told_bridge_state =\n\t\t\t\tdrm_atomic_get_old_bridge_state(old_state,\n\t\t\t\t\t\t\t\titer);\n\t\t\tif (WARN_ON(!old_bridge_state))\n\t\t\t\treturn;\n\n\t\t\titer->funcs->atomic_disable(iter, old_bridge_state);\n\t\t} else if (iter->funcs->disable) {\n\t\t\titer->funcs->disable(iter);\n\t\t}\n\n\t\tif (iter == bridge)\n\t\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_bridge_chain_disable);\n\nstatic void drm_atomic_bridge_call_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t\tstruct drm_atomic_state *old_state)\n{\n\tif (old_state && bridge->funcs->atomic_post_disable) {\n\t\tstruct drm_bridge_state *old_bridge_state;\n\n\t\told_bridge_state =\n\t\t\tdrm_atomic_get_old_bridge_state(old_state,\n\t\t\t\t\t\t\tbridge);\n\t\tif (WARN_ON(!old_bridge_state))\n\t\t\treturn;\n\n\t\tbridge->funcs->atomic_post_disable(bridge,\n\t\t\t\t\t\t   old_bridge_state);\n\t} else if (bridge->funcs->post_disable) {\n\t\tbridge->funcs->post_disable(bridge);\n\t}\n}\n\n \nvoid drm_atomic_bridge_chain_post_disable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_atomic_state *old_state)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *next, *limit;\n\n\tif (!bridge)\n\t\treturn;\n\n\tencoder = bridge->encoder;\n\n\tlist_for_each_entry_from(bridge, &encoder->bridge_chain, chain_node) {\n\t\tlimit = NULL;\n\n\t\tif (!list_is_last(&bridge->chain_node, &encoder->bridge_chain)) {\n\t\t\tnext = list_next_entry(bridge, chain_node);\n\n\t\t\tif (next->pre_enable_prev_first) {\n\t\t\t\t \n\t\t\t\tlimit = next;\n\n\t\t\t\t \n\t\t\t\tlist_for_each_entry_from(next, &encoder->bridge_chain,\n\t\t\t\t\t\t\t chain_node) {\n\t\t\t\t\tif (next->pre_enable_prev_first) {\n\t\t\t\t\t\tnext = list_prev_entry(next, chain_node);\n\t\t\t\t\t\tlimit = next;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tlist_for_each_entry_from_reverse(next, &encoder->bridge_chain,\n\t\t\t\t\t\t\t\t chain_node) {\n\t\t\t\t\tif (next == bridge)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdrm_atomic_bridge_call_post_disable(next,\n\t\t\t\t\t\t\t\t\t    old_state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdrm_atomic_bridge_call_post_disable(bridge, old_state);\n\n\t\tif (limit)\n\t\t\t \n\t\t\tbridge = limit;\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_bridge_chain_post_disable);\n\nstatic void drm_atomic_bridge_call_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_atomic_state *old_state)\n{\n\tif (old_state && bridge->funcs->atomic_pre_enable) {\n\t\tstruct drm_bridge_state *old_bridge_state;\n\n\t\told_bridge_state =\n\t\t\tdrm_atomic_get_old_bridge_state(old_state,\n\t\t\t\t\t\t\tbridge);\n\t\tif (WARN_ON(!old_bridge_state))\n\t\t\treturn;\n\n\t\tbridge->funcs->atomic_pre_enable(bridge, old_bridge_state);\n\t} else if (bridge->funcs->pre_enable) {\n\t\tbridge->funcs->pre_enable(bridge);\n\t}\n}\n\n \nvoid drm_atomic_bridge_chain_pre_enable(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_atomic_state *old_state)\n{\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *iter, *next, *limit;\n\n\tif (!bridge)\n\t\treturn;\n\n\tencoder = bridge->encoder;\n\n\tlist_for_each_entry_reverse(iter, &encoder->bridge_chain, chain_node) {\n\t\tif (iter->pre_enable_prev_first) {\n\t\t\tnext = iter;\n\t\t\tlimit = bridge;\n\t\t\tlist_for_each_entry_from_reverse(next,\n\t\t\t\t\t\t\t &encoder->bridge_chain,\n\t\t\t\t\t\t\t chain_node) {\n\t\t\t\tif (next == bridge)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!next->pre_enable_prev_first) {\n\t\t\t\t\t \n\t\t\t\t\tlimit = list_prev_entry(next, chain_node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlist_for_each_entry_from(next, &encoder->bridge_chain, chain_node) {\n\t\t\t\t \n\t\t\t\tif (next == iter)\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\n\t\t\t\tdrm_atomic_bridge_call_pre_enable(next, old_state);\n\t\t\t}\n\t\t}\n\n\t\tdrm_atomic_bridge_call_pre_enable(iter, old_state);\n\n\t\tif (iter->pre_enable_prev_first)\n\t\t\t \n\t\t\titer = limit;\n\n\t\tif (iter == bridge)\n\t\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_bridge_chain_pre_enable);\n\n \nvoid drm_atomic_bridge_chain_enable(struct drm_bridge *bridge,\n\t\t\t\t    struct drm_atomic_state *old_state)\n{\n\tstruct drm_encoder *encoder;\n\n\tif (!bridge)\n\t\treturn;\n\n\tencoder = bridge->encoder;\n\tlist_for_each_entry_from(bridge, &encoder->bridge_chain, chain_node) {\n\t\tif (bridge->funcs->atomic_enable) {\n\t\t\tstruct drm_bridge_state *old_bridge_state;\n\n\t\t\told_bridge_state =\n\t\t\t\tdrm_atomic_get_old_bridge_state(old_state,\n\t\t\t\t\t\t\t\tbridge);\n\t\t\tif (WARN_ON(!old_bridge_state))\n\t\t\t\treturn;\n\n\t\t\tbridge->funcs->atomic_enable(bridge, old_bridge_state);\n\t\t} else if (bridge->funcs->enable) {\n\t\t\tbridge->funcs->enable(bridge);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_bridge_chain_enable);\n\nstatic int drm_atomic_bridge_check(struct drm_bridge *bridge,\n\t\t\t\t   struct drm_crtc_state *crtc_state,\n\t\t\t\t   struct drm_connector_state *conn_state)\n{\n\tif (bridge->funcs->atomic_check) {\n\t\tstruct drm_bridge_state *bridge_state;\n\t\tint ret;\n\n\t\tbridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t\t       bridge);\n\t\tif (WARN_ON(!bridge_state))\n\t\t\treturn -EINVAL;\n\n\t\tret = bridge->funcs->atomic_check(bridge, bridge_state,\n\t\t\t\t\t\t  crtc_state, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (bridge->funcs->mode_fixup) {\n\t\tif (!bridge->funcs->mode_fixup(bridge, &crtc_state->mode,\n\t\t\t\t\t       &crtc_state->adjusted_mode))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int select_bus_fmt_recursive(struct drm_bridge *first_bridge,\n\t\t\t\t    struct drm_bridge *cur_bridge,\n\t\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t\t    u32 out_bus_fmt)\n{\n\tunsigned int i, num_in_bus_fmts = 0;\n\tstruct drm_bridge_state *cur_state;\n\tstruct drm_bridge *prev_bridge;\n\tu32 *in_bus_fmts;\n\tint ret;\n\n\tprev_bridge = drm_bridge_get_prev_bridge(cur_bridge);\n\tcur_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t    cur_bridge);\n\n\t \n\tif (!cur_bridge->funcs->atomic_get_input_bus_fmts) {\n\t\tif (cur_bridge != first_bridge) {\n\t\t\tret = select_bus_fmt_recursive(first_bridge,\n\t\t\t\t\t\t       prev_bridge, crtc_state,\n\t\t\t\t\t\t       conn_state,\n\t\t\t\t\t\t       MEDIA_BUS_FMT_FIXED);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (cur_state) {\n\t\t\tcur_state->input_bus_cfg.format = MEDIA_BUS_FMT_FIXED;\n\t\t\tcur_state->output_bus_cfg.format = out_bus_fmt;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (WARN_ON(!cur_state))\n\t\treturn -EINVAL;\n\n\tin_bus_fmts = cur_bridge->funcs->atomic_get_input_bus_fmts(cur_bridge,\n\t\t\t\t\t\t\tcur_state,\n\t\t\t\t\t\t\tcrtc_state,\n\t\t\t\t\t\t\tconn_state,\n\t\t\t\t\t\t\tout_bus_fmt,\n\t\t\t\t\t\t\t&num_in_bus_fmts);\n\tif (!num_in_bus_fmts)\n\t\treturn -ENOTSUPP;\n\telse if (!in_bus_fmts)\n\t\treturn -ENOMEM;\n\n\tif (first_bridge == cur_bridge) {\n\t\tcur_state->input_bus_cfg.format = in_bus_fmts[0];\n\t\tcur_state->output_bus_cfg.format = out_bus_fmt;\n\t\tkfree(in_bus_fmts);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < num_in_bus_fmts; i++) {\n\t\tret = select_bus_fmt_recursive(first_bridge, prev_bridge,\n\t\t\t\t\t       crtc_state, conn_state,\n\t\t\t\t\t       in_bus_fmts[i]);\n\t\tif (ret != -ENOTSUPP)\n\t\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tcur_state->input_bus_cfg.format = in_bus_fmts[i];\n\t\tcur_state->output_bus_cfg.format = out_bus_fmt;\n\t}\n\n\tkfree(in_bus_fmts);\n\treturn ret;\n}\n\n \nstatic int\ndrm_atomic_bridge_chain_select_bus_fmts(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *conn = conn_state->connector;\n\tstruct drm_encoder *encoder = bridge->encoder;\n\tstruct drm_bridge_state *last_bridge_state;\n\tunsigned int i, num_out_bus_fmts = 0;\n\tstruct drm_bridge *last_bridge;\n\tu32 *out_bus_fmts;\n\tint ret = 0;\n\n\tlast_bridge = list_last_entry(&encoder->bridge_chain,\n\t\t\t\t      struct drm_bridge, chain_node);\n\tlast_bridge_state = drm_atomic_get_new_bridge_state(crtc_state->state,\n\t\t\t\t\t\t\t    last_bridge);\n\n\tif (last_bridge->funcs->atomic_get_output_bus_fmts) {\n\t\tconst struct drm_bridge_funcs *funcs = last_bridge->funcs;\n\n\t\t \n\t\tif (WARN_ON(!last_bridge_state))\n\t\t\treturn -EINVAL;\n\n\t\tout_bus_fmts = funcs->atomic_get_output_bus_fmts(last_bridge,\n\t\t\t\t\t\t\tlast_bridge_state,\n\t\t\t\t\t\t\tcrtc_state,\n\t\t\t\t\t\t\tconn_state,\n\t\t\t\t\t\t\t&num_out_bus_fmts);\n\t\tif (!num_out_bus_fmts)\n\t\t\treturn -ENOTSUPP;\n\t\telse if (!out_bus_fmts)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tnum_out_bus_fmts = 1;\n\t\tout_bus_fmts = kmalloc(sizeof(*out_bus_fmts), GFP_KERNEL);\n\t\tif (!out_bus_fmts)\n\t\t\treturn -ENOMEM;\n\n\t\tif (conn->display_info.num_bus_formats &&\n\t\t    conn->display_info.bus_formats)\n\t\t\tout_bus_fmts[0] = conn->display_info.bus_formats[0];\n\t\telse\n\t\t\tout_bus_fmts[0] = MEDIA_BUS_FMT_FIXED;\n\t}\n\n\tfor (i = 0; i < num_out_bus_fmts; i++) {\n\t\tret = select_bus_fmt_recursive(bridge, last_bridge, crtc_state,\n\t\t\t\t\t       conn_state, out_bus_fmts[i]);\n\t\tif (ret != -ENOTSUPP)\n\t\t\tbreak;\n\t}\n\n\tkfree(out_bus_fmts);\n\n\treturn ret;\n}\n\nstatic void\ndrm_atomic_bridge_propagate_bus_flags(struct drm_bridge *bridge,\n\t\t\t\t      struct drm_connector *conn,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_bridge_state *bridge_state, *next_bridge_state;\n\tstruct drm_bridge *next_bridge;\n\tu32 output_flags = 0;\n\n\tbridge_state = drm_atomic_get_new_bridge_state(state, bridge);\n\n\t \n\tif (!bridge_state)\n\t\treturn;\n\n\tnext_bridge = drm_bridge_get_next_bridge(bridge);\n\n\t \n\tif (!next_bridge) {\n\t\toutput_flags = conn->display_info.bus_flags;\n\t} else {\n\t\tnext_bridge_state = drm_atomic_get_new_bridge_state(state,\n\t\t\t\t\t\t\t\tnext_bridge);\n\t\t \n\t\tif (next_bridge_state)\n\t\t\toutput_flags = next_bridge_state->input_bus_cfg.flags;\n\t}\n\n\tbridge_state->output_bus_cfg.flags = output_flags;\n\n\t \n\tbridge_state->input_bus_cfg.flags = output_flags;\n}\n\n \nint drm_atomic_bridge_chain_check(struct drm_bridge *bridge,\n\t\t\t\t  struct drm_crtc_state *crtc_state,\n\t\t\t\t  struct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *conn = conn_state->connector;\n\tstruct drm_encoder *encoder;\n\tstruct drm_bridge *iter;\n\tint ret;\n\n\tif (!bridge)\n\t\treturn 0;\n\n\tret = drm_atomic_bridge_chain_select_bus_fmts(bridge, crtc_state,\n\t\t\t\t\t\t      conn_state);\n\tif (ret)\n\t\treturn ret;\n\n\tencoder = bridge->encoder;\n\tlist_for_each_entry_reverse(iter, &encoder->bridge_chain, chain_node) {\n\t\tint ret;\n\n\t\t \n\t\tdrm_atomic_bridge_propagate_bus_flags(iter, conn,\n\t\t\t\t\t\t      crtc_state->state);\n\n\t\tret = drm_atomic_bridge_check(iter, crtc_state, conn_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (iter == bridge)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_bridge_chain_check);\n\n \nenum drm_connector_status drm_bridge_detect(struct drm_bridge *bridge)\n{\n\tif (!(bridge->ops & DRM_BRIDGE_OP_DETECT))\n\t\treturn connector_status_unknown;\n\n\treturn bridge->funcs->detect(bridge);\n}\nEXPORT_SYMBOL_GPL(drm_bridge_detect);\n\n \nint drm_bridge_get_modes(struct drm_bridge *bridge,\n\t\t\t struct drm_connector *connector)\n{\n\tif (!(bridge->ops & DRM_BRIDGE_OP_MODES))\n\t\treturn 0;\n\n\treturn bridge->funcs->get_modes(bridge, connector);\n}\nEXPORT_SYMBOL_GPL(drm_bridge_get_modes);\n\n \nstruct edid *drm_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t struct drm_connector *connector)\n{\n\tif (!(bridge->ops & DRM_BRIDGE_OP_EDID))\n\t\treturn NULL;\n\n\treturn bridge->funcs->get_edid(bridge, connector);\n}\nEXPORT_SYMBOL_GPL(drm_bridge_get_edid);\n\n \nvoid drm_bridge_hpd_enable(struct drm_bridge *bridge,\n\t\t\t   void (*cb)(void *data,\n\t\t\t\t      enum drm_connector_status status),\n\t\t\t   void *data)\n{\n\tif (!(bridge->ops & DRM_BRIDGE_OP_HPD))\n\t\treturn;\n\n\tmutex_lock(&bridge->hpd_mutex);\n\n\tif (WARN(bridge->hpd_cb, \"Hot plug detection already enabled\\n\"))\n\t\tgoto unlock;\n\n\tbridge->hpd_cb = cb;\n\tbridge->hpd_data = data;\n\n\tif (bridge->funcs->hpd_enable)\n\t\tbridge->funcs->hpd_enable(bridge);\n\nunlock:\n\tmutex_unlock(&bridge->hpd_mutex);\n}\nEXPORT_SYMBOL_GPL(drm_bridge_hpd_enable);\n\n \nvoid drm_bridge_hpd_disable(struct drm_bridge *bridge)\n{\n\tif (!(bridge->ops & DRM_BRIDGE_OP_HPD))\n\t\treturn;\n\n\tmutex_lock(&bridge->hpd_mutex);\n\tif (bridge->funcs->hpd_disable)\n\t\tbridge->funcs->hpd_disable(bridge);\n\n\tbridge->hpd_cb = NULL;\n\tbridge->hpd_data = NULL;\n\tmutex_unlock(&bridge->hpd_mutex);\n}\nEXPORT_SYMBOL_GPL(drm_bridge_hpd_disable);\n\n \nvoid drm_bridge_hpd_notify(struct drm_bridge *bridge,\n\t\t\t   enum drm_connector_status status)\n{\n\tmutex_lock(&bridge->hpd_mutex);\n\tif (bridge->hpd_cb)\n\t\tbridge->hpd_cb(bridge->hpd_data, status);\n\tmutex_unlock(&bridge->hpd_mutex);\n}\nEXPORT_SYMBOL_GPL(drm_bridge_hpd_notify);\n\n#ifdef CONFIG_OF\n \nstruct drm_bridge *of_drm_find_bridge(struct device_node *np)\n{\n\tstruct drm_bridge *bridge;\n\n\tmutex_lock(&bridge_lock);\n\n\tlist_for_each_entry(bridge, &bridge_list, list) {\n\t\tif (bridge->of_node == np) {\n\t\t\tmutex_unlock(&bridge_lock);\n\t\t\treturn bridge;\n\t\t}\n\t}\n\n\tmutex_unlock(&bridge_lock);\n\treturn NULL;\n}\nEXPORT_SYMBOL(of_drm_find_bridge);\n#endif\n\n#ifdef CONFIG_DEBUG_FS\nstatic int drm_bridge_chains_info(struct seq_file *m, void *data)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tstruct drm_encoder *encoder;\n\tunsigned int bridge_idx = 0;\n\n\tlist_for_each_entry(encoder, &config->encoder_list, head) {\n\t\tstruct drm_bridge *bridge;\n\n\t\tdrm_printf(&p, \"encoder[%u]\\n\", encoder->base.id);\n\n\t\tdrm_for_each_bridge_in_chain(encoder, bridge) {\n\t\t\tdrm_printf(&p, \"\\tbridge[%u] type: %u, ops: %#x\",\n\t\t\t\t   bridge_idx, bridge->type, bridge->ops);\n\n#ifdef CONFIG_OF\n\t\t\tif (bridge->of_node)\n\t\t\t\tdrm_printf(&p, \", OF: %pOFfc\", bridge->of_node);\n#endif\n\n\t\t\tdrm_printf(&p, \"\\n\");\n\n\t\t\tbridge_idx++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info drm_bridge_debugfs_list[] = {\n\t{ \"bridge_chains\", drm_bridge_chains_info, 0 },\n};\n\nvoid drm_bridge_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, drm_bridge_debugfs_list,\n\t\t\t      ARRAY_SIZE(drm_bridge_debugfs_list));\n}\n#endif\n\nMODULE_AUTHOR(\"Ajay Kumar <ajaykumar.rs@samsung.com>\");\nMODULE_DESCRIPTION(\"DRM bridge infrastructure\");\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}