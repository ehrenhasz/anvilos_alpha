{
  "module_name": "zynqmp_dpsub.c",
  "hash_id": "b818ecb4ffaa5c0509275c133cf398ab1660d09d9df083b474abade219db260f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/xlnx/zynqmp_dpsub.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of_graph.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_module.h>\n\n#include \"zynqmp_disp.h\"\n#include \"zynqmp_dp.h\"\n#include \"zynqmp_dpsub.h\"\n#include \"zynqmp_kms.h\"\n\n \n\nstatic int __maybe_unused zynqmp_dpsub_suspend(struct device *dev)\n{\n\tstruct zynqmp_dpsub *dpsub = dev_get_drvdata(dev);\n\n\tif (!dpsub->drm)\n\t\treturn 0;\n\n\treturn drm_mode_config_helper_suspend(&dpsub->drm->dev);\n}\n\nstatic int __maybe_unused zynqmp_dpsub_resume(struct device *dev)\n{\n\tstruct zynqmp_dpsub *dpsub = dev_get_drvdata(dev);\n\n\tif (!dpsub->drm)\n\t\treturn 0;\n\n\treturn drm_mode_config_helper_resume(&dpsub->drm->dev);\n}\n\nstatic const struct dev_pm_ops zynqmp_dpsub_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(zynqmp_dpsub_suspend, zynqmp_dpsub_resume)\n};\n\n \n\n \nbool zynqmp_dpsub_audio_enabled(struct zynqmp_dpsub *dpsub)\n{\n\treturn !!dpsub->aud_clk;\n}\n\n \nunsigned int zynqmp_dpsub_get_audio_clk_rate(struct zynqmp_dpsub *dpsub)\n{\n\tif (zynqmp_dpsub_audio_enabled(dpsub))\n\t\treturn 0;\n\treturn clk_get_rate(dpsub->aud_clk);\n}\n\n \n\nstatic int zynqmp_dpsub_init_clocks(struct zynqmp_dpsub *dpsub)\n{\n\tint ret;\n\n\tdpsub->apb_clk = devm_clk_get(dpsub->dev, \"dp_apb_clk\");\n\tif (IS_ERR(dpsub->apb_clk))\n\t\treturn PTR_ERR(dpsub->apb_clk);\n\n\tret = clk_prepare_enable(dpsub->apb_clk);\n\tif (ret) {\n\t\tdev_err(dpsub->dev, \"failed to enable the APB clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdpsub->vid_clk = devm_clk_get(dpsub->dev, \"dp_live_video_in_clk\");\n\tif (!IS_ERR(dpsub->vid_clk))\n\t\tdpsub->vid_clk_from_ps = false;\n\telse if (PTR_ERR(dpsub->vid_clk) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(dpsub->vid_clk);\n\n\tif (IS_ERR_OR_NULL(dpsub->vid_clk)) {\n\t\tdpsub->vid_clk = devm_clk_get(dpsub->dev, \"dp_vtc_pixel_clk_in\");\n\t\tif (IS_ERR(dpsub->vid_clk)) {\n\t\t\tdev_err(dpsub->dev, \"failed to init any video clock\\n\");\n\t\t\treturn PTR_ERR(dpsub->vid_clk);\n\t\t}\n\t\tdpsub->vid_clk_from_ps = true;\n\t}\n\n\t \n\tdpsub->aud_clk = devm_clk_get(dpsub->dev, \"dp_live_audio_aclk\");\n\tif (!IS_ERR(dpsub->aud_clk)) {\n\t\tdpsub->aud_clk_from_ps = false;\n\t\treturn 0;\n\t}\n\n\tdpsub->aud_clk = devm_clk_get(dpsub->dev, \"dp_aud_clk\");\n\tif (!IS_ERR(dpsub->aud_clk)) {\n\t\tdpsub->aud_clk_from_ps = true;\n\t\treturn 0;\n\t}\n\n\tdev_info(dpsub->dev, \"audio disabled due to missing clock\\n\");\n\treturn 0;\n}\n\nstatic int zynqmp_dpsub_parse_dt(struct zynqmp_dpsub *dpsub)\n{\n\tstruct device_node *np;\n\tunsigned int i;\n\n\t \n\tnp = of_get_child_by_name(dpsub->dev->of_node, \"ports\");\n\tof_node_put(np);\n\tif (!np) {\n\t\tdev_warn(dpsub->dev, \"missing ports, update DT bindings\\n\");\n\t\tdpsub->connected_ports = BIT(ZYNQMP_DPSUB_PORT_OUT_DP);\n\t\tdpsub->dma_enabled = true;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < ZYNQMP_DPSUB_NUM_PORTS; ++i) {\n\t\tstruct device_node *np;\n\n\t\tnp = of_graph_get_remote_node(dpsub->dev->of_node, i, -1);\n\t\tif (np) {\n\t\t\tdpsub->connected_ports |= BIT(i);\n\t\t\tof_node_put(np);\n\t\t}\n\t}\n\n\t \n\tif ((dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_VIDEO)) &&\n\t    (dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_GFX))) {\n\t\tdev_err(dpsub->dev, \"only one live video input is supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_VIDEO)) ||\n\t    (dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_GFX))) {\n\t\tif (dpsub->vid_clk_from_ps) {\n\t\t\tdev_err(dpsub->dev,\n\t\t\t\t\"live video input requires PL clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tdpsub->dma_enabled = true;\n\t}\n\n\tif (dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_AUDIO))\n\t\tdev_warn(dpsub->dev, \"live audio unsupported, ignoring\\n\");\n\n\tif ((dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_OUT_VIDEO)) ||\n\t    (dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_OUT_AUDIO)))\n\t\tdev_warn(dpsub->dev, \"output to PL unsupported, ignoring\\n\");\n\n\tif (!(dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_OUT_DP))) {\n\t\tdev_err(dpsub->dev, \"DP output port not connected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid zynqmp_dpsub_release(struct zynqmp_dpsub *dpsub)\n{\n\tkfree(dpsub->disp);\n\tkfree(dpsub->dp);\n\tkfree(dpsub);\n}\n\nstatic int zynqmp_dpsub_probe(struct platform_device *pdev)\n{\n\tstruct zynqmp_dpsub *dpsub;\n\tint ret;\n\n\t \n\tdpsub = kzalloc(sizeof(*dpsub), GFP_KERNEL);\n\tif (!dpsub)\n\t\treturn -ENOMEM;\n\n\tdpsub->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, dpsub);\n\n\tret = dma_set_mask(dpsub->dev, DMA_BIT_MASK(ZYNQMP_DISP_MAX_DMA_BIT));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tof_reserved_mem_device_init(&pdev->dev);\n\n\tret = zynqmp_dpsub_init_clocks(dpsub);\n\tif (ret < 0)\n\t\tgoto err_mem;\n\n\tret = zynqmp_dpsub_parse_dt(dpsub);\n\tif (ret < 0)\n\t\tgoto err_mem;\n\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tret = zynqmp_dp_probe(dpsub);\n\tif (ret)\n\t\tgoto err_pm;\n\n\tret = zynqmp_disp_probe(dpsub);\n\tif (ret)\n\t\tgoto err_dp;\n\n\tif (dpsub->dma_enabled) {\n\t\tret = zynqmp_dpsub_drm_init(dpsub);\n\t\tif (ret)\n\t\t\tgoto err_disp;\n\t} else {\n\t\tdrm_bridge_add(dpsub->bridge);\n\t}\n\n\tdev_info(&pdev->dev, \"ZynqMP DisplayPort Subsystem driver probed\");\n\n\treturn 0;\n\nerr_disp:\n\tzynqmp_disp_remove(dpsub);\nerr_dp:\n\tzynqmp_dp_remove(dpsub);\nerr_pm:\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(dpsub->apb_clk);\nerr_mem:\n\tof_reserved_mem_device_release(&pdev->dev);\n\tif (!dpsub->drm)\n\t\tzynqmp_dpsub_release(dpsub);\n\treturn ret;\n}\n\nstatic void zynqmp_dpsub_remove(struct platform_device *pdev)\n{\n\tstruct zynqmp_dpsub *dpsub = platform_get_drvdata(pdev);\n\n\tif (dpsub->drm)\n\t\tzynqmp_dpsub_drm_cleanup(dpsub);\n\telse\n\t\tdrm_bridge_remove(dpsub->bridge);\n\n\tzynqmp_disp_remove(dpsub);\n\tzynqmp_dp_remove(dpsub);\n\n\tpm_runtime_disable(&pdev->dev);\n\tclk_disable_unprepare(dpsub->apb_clk);\n\tof_reserved_mem_device_release(&pdev->dev);\n\n\tif (!dpsub->drm)\n\t\tzynqmp_dpsub_release(dpsub);\n}\n\nstatic void zynqmp_dpsub_shutdown(struct platform_device *pdev)\n{\n\tstruct zynqmp_dpsub *dpsub = platform_get_drvdata(pdev);\n\n\tif (!dpsub->drm)\n\t\treturn;\n\n\tdrm_atomic_helper_shutdown(&dpsub->drm->dev);\n}\n\nstatic const struct of_device_id zynqmp_dpsub_of_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-dpsub-1.7\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, zynqmp_dpsub_of_match);\n\nstatic struct platform_driver zynqmp_dpsub_driver = {\n\t.probe\t\t\t= zynqmp_dpsub_probe,\n\t.remove_new\t\t= zynqmp_dpsub_remove,\n\t.shutdown\t\t= zynqmp_dpsub_shutdown,\n\t.driver\t\t\t= {\n\t\t.name\t\t= \"zynqmp-dpsub\",\n\t\t.pm\t\t= &zynqmp_dpsub_pm_ops,\n\t\t.of_match_table\t= zynqmp_dpsub_of_match,\n\t},\n};\n\ndrm_module_platform_driver(zynqmp_dpsub_driver);\n\nMODULE_AUTHOR(\"Xilinx, Inc.\");\nMODULE_DESCRIPTION(\"ZynqMP DP Subsystem Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}