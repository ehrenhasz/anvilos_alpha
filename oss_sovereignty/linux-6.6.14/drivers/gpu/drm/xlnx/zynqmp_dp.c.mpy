{
  "module_name": "zynqmp_dp.c",
  "hash_id": "d47ba5e9c81244440cdaa512e042734e3f9b117155ffb8a476e6065633593829",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/xlnx/zynqmp_dp.c",
  "human_readable_source": "\n \n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_modes.h>\n#include <drm/drm_of.h>\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/phy/phy.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include \"zynqmp_disp.h\"\n#include \"zynqmp_dp.h\"\n#include \"zynqmp_dpsub.h\"\n#include \"zynqmp_kms.h\"\n\nstatic uint zynqmp_dp_aux_timeout_ms = 50;\nmodule_param_named(aux_timeout_ms, zynqmp_dp_aux_timeout_ms, uint, 0444);\nMODULE_PARM_DESC(aux_timeout_ms, \"DP aux timeout value in msec (default: 50)\");\n\n \nstatic uint zynqmp_dp_power_on_delay_ms = 4;\nmodule_param_named(power_on_delay_ms, zynqmp_dp_power_on_delay_ms, uint, 0444);\nMODULE_PARM_DESC(power_on_delay_ms, \"DP power on delay in msec (default: 4)\");\n\n \n#define ZYNQMP_DP_LINK_BW_SET\t\t\t\t0x0\n#define ZYNQMP_DP_LANE_COUNT_SET\t\t\t0x4\n#define ZYNQMP_DP_ENHANCED_FRAME_EN\t\t\t0x8\n#define ZYNQMP_DP_TRAINING_PATTERN_SET\t\t\t0xc\n#define ZYNQMP_DP_SCRAMBLING_DISABLE\t\t\t0x14\n#define ZYNQMP_DP_DOWNSPREAD_CTL\t\t\t0x18\n#define ZYNQMP_DP_SOFTWARE_RESET\t\t\t0x1c\n#define ZYNQMP_DP_SOFTWARE_RESET_STREAM1\t\tBIT(0)\n#define ZYNQMP_DP_SOFTWARE_RESET_STREAM2\t\tBIT(1)\n#define ZYNQMP_DP_SOFTWARE_RESET_STREAM3\t\tBIT(2)\n#define ZYNQMP_DP_SOFTWARE_RESET_STREAM4\t\tBIT(3)\n#define ZYNQMP_DP_SOFTWARE_RESET_AUX\t\t\tBIT(7)\n#define ZYNQMP_DP_SOFTWARE_RESET_ALL\t\t\t(ZYNQMP_DP_SOFTWARE_RESET_STREAM1 | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_SOFTWARE_RESET_STREAM2 | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_SOFTWARE_RESET_STREAM3 | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_SOFTWARE_RESET_STREAM4 | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_SOFTWARE_RESET_AUX)\n\n \n#define ZYNQMP_DP_TRANSMITTER_ENABLE\t\t\t0x80\n#define ZYNQMP_DP_MAIN_STREAM_ENABLE\t\t\t0x84\n#define ZYNQMP_DP_FORCE_SCRAMBLER_RESET\t\t\t0xc0\n#define ZYNQMP_DP_VERSION\t\t\t\t0xf8\n#define ZYNQMP_DP_VERSION_MAJOR_MASK\t\t\tGENMASK(31, 24)\n#define ZYNQMP_DP_VERSION_MAJOR_SHIFT\t\t\t24\n#define ZYNQMP_DP_VERSION_MINOR_MASK\t\t\tGENMASK(23, 16)\n#define ZYNQMP_DP_VERSION_MINOR_SHIFT\t\t\t16\n#define ZYNQMP_DP_VERSION_REVISION_MASK\t\t\tGENMASK(15, 12)\n#define ZYNQMP_DP_VERSION_REVISION_SHIFT\t\t12\n#define ZYNQMP_DP_VERSION_PATCH_MASK\t\t\tGENMASK(11, 8)\n#define ZYNQMP_DP_VERSION_PATCH_SHIFT\t\t\t8\n#define ZYNQMP_DP_VERSION_INTERNAL_MASK\t\t\tGENMASK(7, 0)\n#define ZYNQMP_DP_VERSION_INTERNAL_SHIFT\t\t0\n\n \n#define ZYNQMP_DP_CORE_ID\t\t\t\t0xfc\n#define ZYNQMP_DP_CORE_ID_MAJOR_MASK\t\t\tGENMASK(31, 24)\n#define ZYNQMP_DP_CORE_ID_MAJOR_SHIFT\t\t\t24\n#define ZYNQMP_DP_CORE_ID_MINOR_MASK\t\t\tGENMASK(23, 16)\n#define ZYNQMP_DP_CORE_ID_MINOR_SHIFT\t\t\t16\n#define ZYNQMP_DP_CORE_ID_REVISION_MASK\t\t\tGENMASK(15, 8)\n#define ZYNQMP_DP_CORE_ID_REVISION_SHIFT\t\t8\n#define ZYNQMP_DP_CORE_ID_DIRECTION\t\t\tGENMASK(1)\n\n \n#define ZYNQMP_DP_AUX_COMMAND\t\t\t\t0x100\n#define ZYNQMP_DP_AUX_COMMAND_CMD_SHIFT\t\t\t8\n#define ZYNQMP_DP_AUX_COMMAND_ADDRESS_ONLY\t\tBIT(12)\n#define ZYNQMP_DP_AUX_COMMAND_BYTES_SHIFT\t\t0\n#define ZYNQMP_DP_AUX_WRITE_FIFO\t\t\t0x104\n#define ZYNQMP_DP_AUX_ADDRESS\t\t\t\t0x108\n#define ZYNQMP_DP_AUX_CLK_DIVIDER\t\t\t0x10c\n#define ZYNQMP_DP_AUX_CLK_DIVIDER_AUX_FILTER_SHIFT\t8\n#define ZYNQMP_DP_INTERRUPT_SIGNAL_STATE\t\t0x130\n#define ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_HPD\t\tBIT(0)\n#define ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_REQUEST\tBIT(1)\n#define ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_REPLY\t\tBIT(2)\n#define ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_REPLY_TIMEOUT\tBIT(3)\n#define ZYNQMP_DP_AUX_REPLY_DATA\t\t\t0x134\n#define ZYNQMP_DP_AUX_REPLY_CODE\t\t\t0x138\n#define ZYNQMP_DP_AUX_REPLY_CODE_AUX_ACK\t\t(0)\n#define ZYNQMP_DP_AUX_REPLY_CODE_AUX_NACK\t\tBIT(0)\n#define ZYNQMP_DP_AUX_REPLY_CODE_AUX_DEFER\t\tBIT(1)\n#define ZYNQMP_DP_AUX_REPLY_CODE_I2C_ACK\t\t(0)\n#define ZYNQMP_DP_AUX_REPLY_CODE_I2C_NACK\t\tBIT(2)\n#define ZYNQMP_DP_AUX_REPLY_CODE_I2C_DEFER\t\tBIT(3)\n#define ZYNQMP_DP_AUX_REPLY_COUNT\t\t\t0x13c\n#define ZYNQMP_DP_REPLY_DATA_COUNT\t\t\t0x148\n#define ZYNQMP_DP_REPLY_DATA_COUNT_MASK\t\t\t0xff\n#define ZYNQMP_DP_INT_STATUS\t\t\t\t0x3a0\n#define ZYNQMP_DP_INT_MASK\t\t\t\t0x3a4\n#define ZYNQMP_DP_INT_EN\t\t\t\t0x3a8\n#define ZYNQMP_DP_INT_DS\t\t\t\t0x3ac\n#define ZYNQMP_DP_INT_HPD_IRQ\t\t\t\tBIT(0)\n#define ZYNQMP_DP_INT_HPD_EVENT\t\t\t\tBIT(1)\n#define ZYNQMP_DP_INT_REPLY_RECEIVED\t\t\tBIT(2)\n#define ZYNQMP_DP_INT_REPLY_TIMEOUT\t\t\tBIT(3)\n#define ZYNQMP_DP_INT_HPD_PULSE_DET\t\t\tBIT(4)\n#define ZYNQMP_DP_INT_EXT_PKT_TXD\t\t\tBIT(5)\n#define ZYNQMP_DP_INT_LIV_ABUF_UNDRFLW\t\t\tBIT(12)\n#define ZYNQMP_DP_INT_VBLANK_START\t\t\tBIT(13)\n#define ZYNQMP_DP_INT_PIXEL1_MATCH\t\t\tBIT(14)\n#define ZYNQMP_DP_INT_PIXEL0_MATCH\t\t\tBIT(15)\n#define ZYNQMP_DP_INT_CHBUF_UNDERFLW_MASK\t\t0x3f0000\n#define ZYNQMP_DP_INT_CHBUF_OVERFLW_MASK\t\t0xfc00000\n#define ZYNQMP_DP_INT_CUST_TS_2\t\t\t\tBIT(28)\n#define ZYNQMP_DP_INT_CUST_TS\t\t\t\tBIT(29)\n#define ZYNQMP_DP_INT_EXT_VSYNC_TS\t\t\tBIT(30)\n#define ZYNQMP_DP_INT_VSYNC_TS\t\t\t\tBIT(31)\n#define ZYNQMP_DP_INT_ALL\t\t\t\t(ZYNQMP_DP_INT_HPD_IRQ | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_INT_HPD_EVENT | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_INT_CHBUF_UNDERFLW_MASK | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_INT_CHBUF_OVERFLW_MASK)\n\n \n#define ZYNQMP_DP_MAIN_STREAM_HTOTAL\t\t\t0x180\n#define ZYNQMP_DP_MAIN_STREAM_VTOTAL\t\t\t0x184\n#define ZYNQMP_DP_MAIN_STREAM_POLARITY\t\t\t0x188\n#define ZYNQMP_DP_MAIN_STREAM_POLARITY_HSYNC_SHIFT\t0\n#define ZYNQMP_DP_MAIN_STREAM_POLARITY_VSYNC_SHIFT\t1\n#define ZYNQMP_DP_MAIN_STREAM_HSWIDTH\t\t\t0x18c\n#define ZYNQMP_DP_MAIN_STREAM_VSWIDTH\t\t\t0x190\n#define ZYNQMP_DP_MAIN_STREAM_HRES\t\t\t0x194\n#define ZYNQMP_DP_MAIN_STREAM_VRES\t\t\t0x198\n#define ZYNQMP_DP_MAIN_STREAM_HSTART\t\t\t0x19c\n#define ZYNQMP_DP_MAIN_STREAM_VSTART\t\t\t0x1a0\n#define ZYNQMP_DP_MAIN_STREAM_MISC0\t\t\t0x1a4\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_SYNC_LOCK\t\tBIT(0)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_RGB\t(0 << 1)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_YCRCB_422\t(5 << 1)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_YCRCB_444\t(6 << 1)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_MASK\t(7 << 1)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_DYNAMIC_RANGE\tBIT(3)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_YCBCR_COLR\t\tBIT(4)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_6\t\t(0 << 5)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_8\t\t(1 << 5)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_10\t\t(2 << 5)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_12\t\t(3 << 5)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_16\t\t(4 << 5)\n#define ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_MASK\t\t(7 << 5)\n#define ZYNQMP_DP_MAIN_STREAM_MISC1\t\t\t0x1a8\n#define ZYNQMP_DP_MAIN_STREAM_MISC1_Y_ONLY_EN\t\tBIT(7)\n#define ZYNQMP_DP_MAIN_STREAM_M_VID\t\t\t0x1ac\n#define ZYNQMP_DP_MSA_TRANSFER_UNIT_SIZE\t\t0x1b0\n#define ZYNQMP_DP_MSA_TRANSFER_UNIT_SIZE_TU_SIZE_DEF\t64\n#define ZYNQMP_DP_MAIN_STREAM_N_VID\t\t\t0x1b4\n#define ZYNQMP_DP_USER_PIX_WIDTH\t\t\t0x1b8\n#define ZYNQMP_DP_USER_DATA_COUNT_PER_LANE\t\t0x1bc\n#define ZYNQMP_DP_MIN_BYTES_PER_TU\t\t\t0x1c4\n#define ZYNQMP_DP_FRAC_BYTES_PER_TU\t\t\t0x1c8\n#define ZYNQMP_DP_INIT_WAIT\t\t\t\t0x1cc\n\n \n#define ZYNQMP_DP_PHY_RESET\t\t\t\t0x200\n#define ZYNQMP_DP_PHY_RESET_PHY_RESET\t\t\tBIT(0)\n#define ZYNQMP_DP_PHY_RESET_GTTX_RESET\t\t\tBIT(1)\n#define ZYNQMP_DP_PHY_RESET_PHY_PMA_RESET\t\tBIT(8)\n#define ZYNQMP_DP_PHY_RESET_PHY_PCS_RESET\t\tBIT(9)\n#define ZYNQMP_DP_PHY_RESET_ALL_RESET\t\t\t(ZYNQMP_DP_PHY_RESET_PHY_RESET | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_PHY_RESET_GTTX_RESET | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_PHY_RESET_PHY_PMA_RESET | \\\n\t\t\t\t\t\t\t ZYNQMP_DP_PHY_RESET_PHY_PCS_RESET)\n#define ZYNQMP_DP_PHY_PREEMPHASIS_LANE_0\t\t0x210\n#define ZYNQMP_DP_PHY_PREEMPHASIS_LANE_1\t\t0x214\n#define ZYNQMP_DP_PHY_PREEMPHASIS_LANE_2\t\t0x218\n#define ZYNQMP_DP_PHY_PREEMPHASIS_LANE_3\t\t0x21c\n#define ZYNQMP_DP_PHY_VOLTAGE_DIFF_LANE_0\t\t0x220\n#define ZYNQMP_DP_PHY_VOLTAGE_DIFF_LANE_1\t\t0x224\n#define ZYNQMP_DP_PHY_VOLTAGE_DIFF_LANE_2\t\t0x228\n#define ZYNQMP_DP_PHY_VOLTAGE_DIFF_LANE_3\t\t0x22c\n#define ZYNQMP_DP_PHY_CLOCK_SELECT\t\t\t0x234\n#define ZYNQMP_DP_PHY_CLOCK_SELECT_1_62G\t\t0x1\n#define ZYNQMP_DP_PHY_CLOCK_SELECT_2_70G\t\t0x3\n#define ZYNQMP_DP_PHY_CLOCK_SELECT_5_40G\t\t0x5\n#define ZYNQMP_DP_TX_PHY_POWER_DOWN\t\t\t0x238\n#define ZYNQMP_DP_TX_PHY_POWER_DOWN_LANE_0\t\tBIT(0)\n#define ZYNQMP_DP_TX_PHY_POWER_DOWN_LANE_1\t\tBIT(1)\n#define ZYNQMP_DP_TX_PHY_POWER_DOWN_LANE_2\t\tBIT(2)\n#define ZYNQMP_DP_TX_PHY_POWER_DOWN_LANE_3\t\tBIT(3)\n#define ZYNQMP_DP_TX_PHY_POWER_DOWN_ALL\t\t\t0xf\n#define ZYNQMP_DP_PHY_PRECURSOR_LANE_0\t\t\t0x23c\n#define ZYNQMP_DP_PHY_PRECURSOR_LANE_1\t\t\t0x240\n#define ZYNQMP_DP_PHY_PRECURSOR_LANE_2\t\t\t0x244\n#define ZYNQMP_DP_PHY_PRECURSOR_LANE_3\t\t\t0x248\n#define ZYNQMP_DP_PHY_POSTCURSOR_LANE_0\t\t\t0x24c\n#define ZYNQMP_DP_PHY_POSTCURSOR_LANE_1\t\t\t0x250\n#define ZYNQMP_DP_PHY_POSTCURSOR_LANE_2\t\t\t0x254\n#define ZYNQMP_DP_PHY_POSTCURSOR_LANE_3\t\t\t0x258\n#define ZYNQMP_DP_SUB_TX_PHY_PRECURSOR_LANE_0\t\t0x24c\n#define ZYNQMP_DP_SUB_TX_PHY_PRECURSOR_LANE_1\t\t0x250\n#define ZYNQMP_DP_PHY_STATUS\t\t\t\t0x280\n#define ZYNQMP_DP_PHY_STATUS_PLL_LOCKED_SHIFT\t\t4\n#define ZYNQMP_DP_PHY_STATUS_FPGA_PLL_LOCKED\t\tBIT(6)\n\n \n#define ZYNQMP_DP_TX_AUDIO_CONTROL\t\t\t0x300\n#define ZYNQMP_DP_TX_AUDIO_CHANNELS\t\t\t0x304\n#define ZYNQMP_DP_TX_AUDIO_INFO_DATA\t\t\t0x308\n#define ZYNQMP_DP_TX_M_AUD\t\t\t\t0x328\n#define ZYNQMP_DP_TX_N_AUD\t\t\t\t0x32c\n#define ZYNQMP_DP_TX_AUDIO_EXT_DATA\t\t\t0x330\n\n#define ZYNQMP_DP_MAX_LANES\t\t\t\t2\n#define ZYNQMP_MAX_FREQ\t\t\t\t\t3000000\n\n#define DP_REDUCED_BIT_RATE\t\t\t\t162000\n#define DP_HIGH_BIT_RATE\t\t\t\t270000\n#define DP_HIGH_BIT_RATE2\t\t\t\t540000\n#define DP_MAX_TRAINING_TRIES\t\t\t\t5\n#define DP_V1_2\t\t\t\t\t\t0x12\n\n \nstruct zynqmp_dp_link_config {\n\tint max_rate;\n\tu8 max_lanes;\n};\n\n \nstruct zynqmp_dp_mode {\n\tu8 bw_code;\n\tu8 lane_cnt;\n\tint pclock;\n\tconst char *fmt;\n};\n\n \nstruct zynqmp_dp_config {\n\tu8 misc0;\n\tu8 misc1;\n\tu8 bpp;\n};\n\n \nstruct zynqmp_dp {\n\tstruct device *dev;\n\tstruct zynqmp_dpsub *dpsub;\n\tvoid __iomem *iomem;\n\tstruct reset_control *reset;\n\tint irq;\n\n\tstruct drm_bridge bridge;\n\tstruct drm_bridge *next_bridge;\n\n\tstruct zynqmp_dp_config config;\n\tstruct drm_dp_aux aux;\n\tstruct phy *phy[ZYNQMP_DP_MAX_LANES];\n\tu8 num_lanes;\n\tstruct delayed_work hpd_work;\n\tenum drm_connector_status status;\n\tbool enabled;\n\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\tstruct zynqmp_dp_link_config link_config;\n\tstruct zynqmp_dp_mode mode;\n\tu8 train_set[ZYNQMP_DP_MAX_LANES];\n};\n\nstatic inline struct zynqmp_dp *bridge_to_dp(struct drm_bridge *bridge)\n{\n\treturn container_of(bridge, struct zynqmp_dp, bridge);\n}\n\nstatic void zynqmp_dp_write(struct zynqmp_dp *dp, int offset, u32 val)\n{\n\twritel(val, dp->iomem + offset);\n}\n\nstatic u32 zynqmp_dp_read(struct zynqmp_dp *dp, int offset)\n{\n\treturn readl(dp->iomem + offset);\n}\n\nstatic void zynqmp_dp_clr(struct zynqmp_dp *dp, int offset, u32 clr)\n{\n\tzynqmp_dp_write(dp, offset, zynqmp_dp_read(dp, offset) & ~clr);\n}\n\nstatic void zynqmp_dp_set(struct zynqmp_dp *dp, int offset, u32 set)\n{\n\tzynqmp_dp_write(dp, offset, zynqmp_dp_read(dp, offset) | set);\n}\n\n \n\n#define RST_TIMEOUT_MS\t\t\t1000\n\nstatic int zynqmp_dp_reset(struct zynqmp_dp *dp, bool assert)\n{\n\tunsigned long timeout;\n\n\tif (assert)\n\t\treset_control_assert(dp->reset);\n\telse\n\t\treset_control_deassert(dp->reset);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(RST_TIMEOUT_MS);\n\twhile (!time_after_eq(jiffies, timeout)) {\n\t\tbool status = !!reset_control_status(dp->reset);\n\n\t\tif (assert == status)\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t}\n\n\tdev_err(dp->dev, \"reset %s timeout\\n\", assert ? \"assert\" : \"deassert\");\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int zynqmp_dp_phy_init(struct zynqmp_dp *dp)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < dp->num_lanes; i++) {\n\t\tret = phy_init(dp->phy[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dp->dev, \"failed to init phy lane %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tzynqmp_dp_clr(dp, ZYNQMP_DP_PHY_RESET, ZYNQMP_DP_PHY_RESET_ALL_RESET);\n\n\t \n\tfor (i = dp->num_lanes - 1; i >= 0; i--) {\n\t\tret = phy_power_on(dp->phy[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dp->dev, \"failed to power on phy lane %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_dp_phy_exit(struct zynqmp_dp *dp)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < dp->num_lanes; i++) {\n\t\tret = phy_power_off(dp->phy[i]);\n\t\tif (ret)\n\t\t\tdev_err(dp->dev, \"failed to power off phy(%d) %d\\n\", i,\n\t\t\t\tret);\n\t}\n\n\tfor (i = 0; i < dp->num_lanes; i++) {\n\t\tret = phy_exit(dp->phy[i]);\n\t\tif (ret)\n\t\t\tdev_err(dp->dev, \"failed to exit phy(%d) %d\\n\", i, ret);\n\t}\n}\n\n \nstatic int zynqmp_dp_phy_probe(struct zynqmp_dp *dp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ZYNQMP_DP_MAX_LANES; i++) {\n\t\tchar phy_name[16];\n\t\tstruct phy *phy;\n\n\t\tsnprintf(phy_name, sizeof(phy_name), \"dp-phy%d\", i);\n\t\tphy = devm_phy_get(dp->dev, phy_name);\n\n\t\tif (IS_ERR(phy)) {\n\t\t\tswitch (PTR_ERR(phy)) {\n\t\t\tcase -ENODEV:\n\t\t\t\tif (dp->num_lanes)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tdev_err(dp->dev, \"no PHY found\\n\");\n\t\t\t\treturn -ENXIO;\n\n\t\t\tcase -EPROBE_DEFER:\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\t\tdefault:\n\t\t\t\tdev_err(dp->dev, \"failed to get PHY lane %u\\n\",\n\t\t\t\t\ti);\n\t\t\t\treturn PTR_ERR(phy);\n\t\t\t}\n\t\t}\n\n\t\tdp->phy[i] = phy;\n\t\tdp->num_lanes++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_dp_phy_ready(struct zynqmp_dp *dp)\n{\n\tu32 i, reg, ready;\n\n\tready = (1 << dp->num_lanes) - 1;\n\n\t \n\tfor (i = 0; ; i++) {\n\t\treg = zynqmp_dp_read(dp, ZYNQMP_DP_PHY_STATUS);\n\t\tif ((reg & ready) == ready)\n\t\t\treturn 0;\n\n\t\tif (i == 100) {\n\t\t\tdev_err(dp->dev, \"PHY isn't ready\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic inline int zynqmp_dp_max_rate(int link_rate, u8 lane_num, u8 bpp)\n{\n\treturn link_rate * lane_num * 8 / bpp;\n}\n\n \nstatic int zynqmp_dp_mode_configure(struct zynqmp_dp *dp, int pclock,\n\t\t\t\t    u8 current_bw)\n{\n\tint max_rate = dp->link_config.max_rate;\n\tu8 bw_code;\n\tu8 max_lanes = dp->link_config.max_lanes;\n\tu8 max_link_rate_code = drm_dp_link_rate_to_bw_code(max_rate);\n\tu8 bpp = dp->config.bpp;\n\tu8 lane_cnt;\n\n\t \n\tswitch (current_bw) {\n\tcase DP_LINK_BW_5_4:\n\t\tbw_code = DP_LINK_BW_2_7;\n\t\tbreak;\n\tcase DP_LINK_BW_2_7:\n\t\tbw_code = DP_LINK_BW_1_62;\n\t\tbreak;\n\tcase DP_LINK_BW_1_62:\n\t\tdev_err(dp->dev, \"can't downshift. already lowest link rate\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\t \n\t\tbw_code = max_link_rate_code;\n\t\tbreak;\n\t}\n\n\tfor (lane_cnt = 1; lane_cnt <= max_lanes; lane_cnt <<= 1) {\n\t\tint bw;\n\t\tu32 rate;\n\n\t\tbw = drm_dp_bw_code_to_link_rate(bw_code);\n\t\trate = zynqmp_dp_max_rate(bw, lane_cnt, bpp);\n\t\tif (pclock <= rate) {\n\t\t\tdp->mode.bw_code = bw_code;\n\t\t\tdp->mode.lane_cnt = lane_cnt;\n\t\t\tdp->mode.pclock = pclock;\n\t\t\treturn dp->mode.bw_code;\n\t\t}\n\t}\n\n\tdev_err(dp->dev, \"failed to configure link values\\n\");\n\n\treturn -EINVAL;\n}\n\n \nstatic void zynqmp_dp_adjust_train(struct zynqmp_dp *dp,\n\t\t\t\t   u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tu8 *train_set = dp->train_set;\n\tu8 voltage = 0, preemphasis = 0;\n\tu8 i;\n\n\tfor (i = 0; i < dp->mode.lane_cnt; i++) {\n\t\tu8 v = drm_dp_get_adjust_request_voltage(link_status, i);\n\t\tu8 p = drm_dp_get_adjust_request_pre_emphasis(link_status, i);\n\n\t\tif (v > voltage)\n\t\t\tvoltage = v;\n\n\t\tif (p > preemphasis)\n\t\t\tpreemphasis = p;\n\t}\n\n\tif (voltage >= DP_TRAIN_VOLTAGE_SWING_LEVEL_3)\n\t\tvoltage |= DP_TRAIN_MAX_SWING_REACHED;\n\n\tif (preemphasis >= DP_TRAIN_PRE_EMPH_LEVEL_2)\n\t\tpreemphasis |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\tfor (i = 0; i < dp->mode.lane_cnt; i++)\n\t\ttrain_set[i] = voltage | preemphasis;\n}\n\n \nstatic int zynqmp_dp_update_vs_emph(struct zynqmp_dp *dp)\n{\n\tunsigned int i;\n\tint ret;\n\n\tret = drm_dp_dpcd_write(&dp->aux, DP_TRAINING_LANE0_SET, dp->train_set,\n\t\t\t\tdp->mode.lane_cnt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < dp->mode.lane_cnt; i++) {\n\t\tu32 reg = ZYNQMP_DP_SUB_TX_PHY_PRECURSOR_LANE_0 + i * 4;\n\t\tunion phy_configure_opts opts = { 0 };\n\t\tu8 train = dp->train_set[i];\n\n\t\topts.dp.voltage[0] = (train & DP_TRAIN_VOLTAGE_SWING_MASK)\n\t\t\t\t   >> DP_TRAIN_VOLTAGE_SWING_SHIFT;\n\t\topts.dp.pre[0] = (train & DP_TRAIN_PRE_EMPHASIS_MASK)\n\t\t\t       >> DP_TRAIN_PRE_EMPHASIS_SHIFT;\n\n\t\tphy_configure(dp->phy[i], &opts);\n\n\t\tzynqmp_dp_write(dp, reg, 0x2);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_dp_link_train_cr(struct zynqmp_dp *dp)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tu8 lane_cnt = dp->mode.lane_cnt;\n\tu8 vs = 0, tries = 0;\n\tu16 max_tries, i;\n\tbool cr_done;\n\tint ret;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TRAINING_PATTERN_SET,\n\t\t\tDP_TRAINING_PATTERN_1);\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t DP_TRAINING_PATTERN_1 |\n\t\t\t\t DP_LINK_SCRAMBLING_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (max_tries = 0; max_tries < 512; max_tries++) {\n\t\tret = zynqmp_dp_update_vs_emph(dp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_dp_link_train_clock_recovery_delay(&dp->aux, dp->dpcd);\n\t\tret = drm_dp_dpcd_read_link_status(&dp->aux, link_status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tcr_done = drm_dp_clock_recovery_ok(link_status, lane_cnt);\n\t\tif (cr_done)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < lane_cnt; i++)\n\t\t\tif (!(dp->train_set[i] & DP_TRAIN_MAX_SWING_REACHED))\n\t\t\t\tbreak;\n\t\tif (i == lane_cnt)\n\t\t\tbreak;\n\n\t\tif ((dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == vs)\n\t\t\ttries++;\n\t\telse\n\t\t\ttries = 0;\n\n\t\tif (tries == DP_MAX_TRAINING_TRIES)\n\t\t\tbreak;\n\n\t\tvs = dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\n\t\tzynqmp_dp_adjust_train(dp, link_status);\n\t}\n\n\tif (!cr_done)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_dp_link_train_ce(struct zynqmp_dp *dp)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tu8 lane_cnt = dp->mode.lane_cnt;\n\tu32 pat, tries;\n\tint ret;\n\tbool ce_done;\n\n\tif (dp->dpcd[DP_DPCD_REV] >= DP_V1_2 &&\n\t    dp->dpcd[DP_MAX_LANE_COUNT] & DP_TPS3_SUPPORTED)\n\t\tpat = DP_TRAINING_PATTERN_3;\n\telse\n\t\tpat = DP_TRAINING_PATTERN_2;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TRAINING_PATTERN_SET, pat);\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t pat | DP_LINK_SCRAMBLING_DISABLE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (tries = 0; tries < DP_MAX_TRAINING_TRIES; tries++) {\n\t\tret = zynqmp_dp_update_vs_emph(dp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_dp_link_train_channel_eq_delay(&dp->aux, dp->dpcd);\n\t\tret = drm_dp_dpcd_read_link_status(&dp->aux, link_status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tce_done = drm_dp_channel_eq_ok(link_status, lane_cnt);\n\t\tif (ce_done)\n\t\t\tbreak;\n\n\t\tzynqmp_dp_adjust_train(dp, link_status);\n\t}\n\n\tif (!ce_done)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_dp_train(struct zynqmp_dp *dp)\n{\n\tu32 reg;\n\tu8 bw_code = dp->mode.bw_code;\n\tu8 lane_cnt = dp->mode.lane_cnt;\n\tu8 aux_lane_cnt = lane_cnt;\n\tbool enhanced;\n\tint ret;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_LANE_COUNT_SET, lane_cnt);\n\tenhanced = drm_dp_enhanced_frame_cap(dp->dpcd);\n\tif (enhanced) {\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_ENHANCED_FRAME_EN, 1);\n\t\taux_lane_cnt |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\t}\n\n\tif (dp->dpcd[3] & 0x1) {\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_DOWNSPREAD_CTL, 1);\n\t\tdrm_dp_dpcd_writeb(&dp->aux, DP_DOWNSPREAD_CTRL,\n\t\t\t\t   DP_SPREAD_AMP_0_5);\n\t} else {\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_DOWNSPREAD_CTL, 0);\n\t\tdrm_dp_dpcd_writeb(&dp->aux, DP_DOWNSPREAD_CTRL, 0);\n\t}\n\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_LANE_COUNT_SET, aux_lane_cnt);\n\tif (ret < 0) {\n\t\tdev_err(dp->dev, \"failed to set lane count\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_MAIN_LINK_CHANNEL_CODING_SET,\n\t\t\t\t DP_SET_ANSI_8B10B);\n\tif (ret < 0) {\n\t\tdev_err(dp->dev, \"failed to set ANSI 8B/10B encoding\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_LINK_BW_SET, bw_code);\n\tif (ret < 0) {\n\t\tdev_err(dp->dev, \"failed to set DP bandwidth\\n\");\n\t\treturn ret;\n\t}\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_LINK_BW_SET, bw_code);\n\tswitch (bw_code) {\n\tcase DP_LINK_BW_1_62:\n\t\treg = ZYNQMP_DP_PHY_CLOCK_SELECT_1_62G;\n\t\tbreak;\n\tcase DP_LINK_BW_2_7:\n\t\treg = ZYNQMP_DP_PHY_CLOCK_SELECT_2_70G;\n\t\tbreak;\n\tcase DP_LINK_BW_5_4:\n\tdefault:\n\t\treg = ZYNQMP_DP_PHY_CLOCK_SELECT_5_40G;\n\t\tbreak;\n\t}\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_PHY_CLOCK_SELECT, reg);\n\tret = zynqmp_dp_phy_ready(dp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_SCRAMBLING_DISABLE, 1);\n\tmemset(dp->train_set, 0, sizeof(dp->train_set));\n\tret = zynqmp_dp_link_train_cr(dp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_dp_link_train_ce(dp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_dp_dpcd_writeb(&dp->aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t DP_TRAINING_PATTERN_DISABLE);\n\tif (ret < 0) {\n\t\tdev_err(dp->dev, \"failed to disable training pattern\\n\");\n\t\treturn ret;\n\t}\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TRAINING_PATTERN_SET,\n\t\t\tDP_TRAINING_PATTERN_DISABLE);\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_SCRAMBLING_DISABLE, 0);\n\n\treturn 0;\n}\n\n \nstatic void zynqmp_dp_train_loop(struct zynqmp_dp *dp)\n{\n\tstruct zynqmp_dp_mode *mode = &dp->mode;\n\tu8 bw = mode->bw_code;\n\tint ret;\n\n\tdo {\n\t\tif (dp->status == connector_status_disconnected ||\n\t\t    !dp->enabled)\n\t\t\treturn;\n\n\t\tret = zynqmp_dp_train(dp);\n\t\tif (!ret)\n\t\t\treturn;\n\n\t\tret = zynqmp_dp_mode_configure(dp, mode->pclock, bw);\n\t\tif (ret < 0)\n\t\t\tgoto err_out;\n\n\t\tbw = ret;\n\t} while (bw >= DP_LINK_BW_1_62);\n\nerr_out:\n\tdev_err(dp->dev, \"failed to train the DP link\\n\");\n}\n\n \n\n#define AUX_READ_BIT\t0x1\n\n \nstatic int zynqmp_dp_aux_cmd_submit(struct zynqmp_dp *dp, u32 cmd, u16 addr,\n\t\t\t\t    u8 *buf, u8 bytes, u8 *reply)\n{\n\tbool is_read = (cmd & AUX_READ_BIT) ? true : false;\n\tu32 reg, i;\n\n\treg = zynqmp_dp_read(dp, ZYNQMP_DP_INTERRUPT_SIGNAL_STATE);\n\tif (reg & ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_REQUEST)\n\t\treturn -EBUSY;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_AUX_ADDRESS, addr);\n\tif (!is_read)\n\t\tfor (i = 0; i < bytes; i++)\n\t\t\tzynqmp_dp_write(dp, ZYNQMP_DP_AUX_WRITE_FIFO,\n\t\t\t\t\tbuf[i]);\n\n\treg = cmd << ZYNQMP_DP_AUX_COMMAND_CMD_SHIFT;\n\tif (!buf || !bytes)\n\t\treg |= ZYNQMP_DP_AUX_COMMAND_ADDRESS_ONLY;\n\telse\n\t\treg |= (bytes - 1) << ZYNQMP_DP_AUX_COMMAND_BYTES_SHIFT;\n\tzynqmp_dp_write(dp, ZYNQMP_DP_AUX_COMMAND, reg);\n\n\t \n\tfor (i = 0; ; i++) {\n\t\treg = zynqmp_dp_read(dp, ZYNQMP_DP_INTERRUPT_SIGNAL_STATE);\n\t\tif (reg & ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_REPLY)\n\t\t\tbreak;\n\n\t\tif (reg & ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_REPLY_TIMEOUT ||\n\t\t    i == 2)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\treg = zynqmp_dp_read(dp, ZYNQMP_DP_AUX_REPLY_CODE);\n\tif (reply)\n\t\t*reply = reg;\n\n\tif (is_read &&\n\t    (reg == ZYNQMP_DP_AUX_REPLY_CODE_AUX_ACK ||\n\t     reg == ZYNQMP_DP_AUX_REPLY_CODE_I2C_ACK)) {\n\t\treg = zynqmp_dp_read(dp, ZYNQMP_DP_REPLY_DATA_COUNT);\n\t\tif ((reg & ZYNQMP_DP_REPLY_DATA_COUNT_MASK) != bytes)\n\t\t\treturn -EIO;\n\n\t\tfor (i = 0; i < bytes; i++)\n\t\t\tbuf[i] = zynqmp_dp_read(dp, ZYNQMP_DP_AUX_REPLY_DATA);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t\nzynqmp_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tstruct zynqmp_dp *dp = container_of(aux, struct zynqmp_dp, aux);\n\tint ret;\n\tunsigned int i, iter;\n\n\t \n\titer = zynqmp_dp_aux_timeout_ms * 1000 / 400;\n\titer = iter ? iter : 1;\n\n\tfor (i = 0; i < iter; i++) {\n\t\tret = zynqmp_dp_aux_cmd_submit(dp, msg->request, msg->address,\n\t\t\t\t\t       msg->buffer, msg->size,\n\t\t\t\t\t       &msg->reply);\n\t\tif (!ret) {\n\t\t\tdev_dbg(dp->dev, \"aux %d retries\\n\", i);\n\t\t\treturn msg->size;\n\t\t}\n\n\t\tif (dp->status == connector_status_disconnected) {\n\t\t\tdev_dbg(dp->dev, \"no connected aux device\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tusleep_range(400, 500);\n\t}\n\n\tdev_dbg(dp->dev, \"failed to do aux transfer (%d)\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int zynqmp_dp_aux_init(struct zynqmp_dp *dp)\n{\n\tunsigned long rate;\n\tunsigned int w;\n\n\t \n\trate = clk_get_rate(dp->dpsub->apb_clk);\n\tw = DIV_ROUND_UP(4 * rate, 1000 * 1000 * 10 * 8) * 8;\n\tif (w > 6 * rate / (1000 * 1000 * 10) || w > 48) {\n\t\tdev_err(dp->dev, \"aclk frequency too high\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_AUX_CLK_DIVIDER,\n\t\t\t(w << ZYNQMP_DP_AUX_CLK_DIVIDER_AUX_FILTER_SHIFT) |\n\t\t\t(rate / (1000 * 1000)));\n\n\tdp->aux.name = \"ZynqMP DP AUX\";\n\tdp->aux.dev = dp->dev;\n\tdp->aux.drm_dev = dp->bridge.dev;\n\tdp->aux.transfer = zynqmp_dp_aux_transfer;\n\n\treturn drm_dp_aux_register(&dp->aux);\n}\n\n \nstatic void zynqmp_dp_aux_cleanup(struct zynqmp_dp *dp)\n{\n\tdrm_dp_aux_unregister(&dp->aux);\n}\n\n \n\n \nstatic void zynqmp_dp_update_misc(struct zynqmp_dp *dp)\n{\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_MISC0, dp->config.misc0);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_MISC1, dp->config.misc1);\n}\n\n \nstatic int zynqmp_dp_set_format(struct zynqmp_dp *dp,\n\t\t\t\tconst struct drm_display_info *info,\n\t\t\t\tenum zynqmp_dpsub_format format,\n\t\t\t\tunsigned int bpc)\n{\n\tstruct zynqmp_dp_config *config = &dp->config;\n\tunsigned int num_colors;\n\n\tconfig->misc0 &= ~ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_MASK;\n\tconfig->misc1 &= ~ZYNQMP_DP_MAIN_STREAM_MISC1_Y_ONLY_EN;\n\n\tswitch (format) {\n\tcase ZYNQMP_DPSUB_FORMAT_RGB:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_RGB;\n\t\tnum_colors = 3;\n\t\tbreak;\n\n\tcase ZYNQMP_DPSUB_FORMAT_YCRCB444:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_YCRCB_444;\n\t\tnum_colors = 3;\n\t\tbreak;\n\n\tcase ZYNQMP_DPSUB_FORMAT_YCRCB422:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_COMP_FORMAT_YCRCB_422;\n\t\tnum_colors = 2;\n\t\tbreak;\n\n\tcase ZYNQMP_DPSUB_FORMAT_YONLY:\n\t\tconfig->misc1 |= ZYNQMP_DP_MAIN_STREAM_MISC1_Y_ONLY_EN;\n\t\tnum_colors = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dp->dev, \"Invalid colormetry in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (info && info->bpc && bpc > info->bpc) {\n\t\tdev_warn(dp->dev,\n\t\t\t \"downgrading requested %ubpc to display limit %ubpc\\n\",\n\t\t\t bpc, info->bpc);\n\t\tbpc = info->bpc;\n\t}\n\n\tconfig->misc0 &= ~ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_MASK;\n\n\tswitch (bpc) {\n\tcase 6:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_6;\n\t\tbreak;\n\tcase 8:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_8;\n\t\tbreak;\n\tcase 10:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_10;\n\t\tbreak;\n\tcase 12:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_12;\n\t\tbreak;\n\tcase 16:\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_16;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dp->dev, \"Not supported bpc (%u). fall back to 8bpc\\n\",\n\t\t\t bpc);\n\t\tconfig->misc0 |= ZYNQMP_DP_MAIN_STREAM_MISC0_BPC_8;\n\t\tbpc = 8;\n\t\tbreak;\n\t}\n\n\t \n\tconfig->bpp = bpc * num_colors;\n\n\treturn 0;\n}\n\n \nstatic void\nzynqmp_dp_encoder_mode_set_transfer_unit(struct zynqmp_dp *dp,\n\t\t\t\t\t const struct drm_display_mode *mode)\n{\n\tu32 tu = ZYNQMP_DP_MSA_TRANSFER_UNIT_SIZE_TU_SIZE_DEF;\n\tu32 bw, vid_kbytes, avg_bytes_per_tu, init_wait;\n\n\t \n\tzynqmp_dp_write(dp, ZYNQMP_DP_MSA_TRANSFER_UNIT_SIZE, tu);\n\n\tvid_kbytes = mode->clock * (dp->config.bpp / 8);\n\tbw = drm_dp_bw_code_to_link_rate(dp->mode.bw_code);\n\tavg_bytes_per_tu = vid_kbytes * tu / (dp->mode.lane_cnt * bw / 1000);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MIN_BYTES_PER_TU,\n\t\t\tavg_bytes_per_tu / 1000);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_FRAC_BYTES_PER_TU,\n\t\t\tavg_bytes_per_tu % 1000);\n\n\t \n\tif (tu < (avg_bytes_per_tu / 1000))\n\t\tinit_wait = 0;\n\telse if ((avg_bytes_per_tu / 1000) <= 4)\n\t\tinit_wait = tu;\n\telse\n\t\tinit_wait = tu - avg_bytes_per_tu / 1000;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INIT_WAIT, init_wait);\n}\n\n \nstatic void zynqmp_dp_encoder_mode_set_stream(struct zynqmp_dp *dp,\n\t\t\t\t\t      const struct drm_display_mode *mode)\n{\n\tu8 lane_cnt = dp->mode.lane_cnt;\n\tu32 reg, wpl;\n\tunsigned int rate;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_HTOTAL, mode->htotal);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_VTOTAL, mode->vtotal);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_POLARITY,\n\t\t\t(!!(mode->flags & DRM_MODE_FLAG_PVSYNC) <<\n\t\t\t ZYNQMP_DP_MAIN_STREAM_POLARITY_VSYNC_SHIFT) |\n\t\t\t(!!(mode->flags & DRM_MODE_FLAG_PHSYNC) <<\n\t\t\t ZYNQMP_DP_MAIN_STREAM_POLARITY_HSYNC_SHIFT));\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_HSWIDTH,\n\t\t\tmode->hsync_end - mode->hsync_start);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_VSWIDTH,\n\t\t\tmode->vsync_end - mode->vsync_start);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_HRES, mode->hdisplay);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_VRES, mode->vdisplay);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_HSTART,\n\t\t\tmode->htotal - mode->hsync_start);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_VSTART,\n\t\t\tmode->vtotal - mode->vsync_start);\n\n\t \n\tif (dp->config.misc0 & ZYNQMP_DP_MAIN_STREAM_MISC0_SYNC_LOCK) {\n\t\treg = drm_dp_bw_code_to_link_rate(dp->mode.bw_code);\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_N_VID, reg);\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_M_VID, mode->clock);\n\t\trate = zynqmp_dpsub_get_audio_clk_rate(dp->dpsub);\n\t\tif (rate) {\n\t\t\tdev_dbg(dp->dev, \"Audio rate: %d\\n\", rate / 512);\n\t\t\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_N_AUD, reg);\n\t\t\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_M_AUD, rate / 1000);\n\t\t}\n\t}\n\n\t \n\tif (zynqmp_dpsub_audio_enabled(dp->dpsub))\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_AUDIO_CHANNELS, 1);\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_USER_PIX_WIDTH, 1);\n\n\t \n\twpl = (mode->hdisplay * dp->config.bpp + 15) / 16;\n\treg = wpl + wpl % lane_cnt - lane_cnt;\n\tzynqmp_dp_write(dp, ZYNQMP_DP_USER_DATA_COUNT_PER_LANE, reg);\n}\n\n \n\nstatic void zynqmp_dp_disp_enable(struct zynqmp_dp *dp,\n\t\t\t\t  struct drm_bridge_state *old_bridge_state)\n{\n\tenum zynqmp_dpsub_layer_id layer_id;\n\tstruct zynqmp_disp_layer *layer;\n\tconst struct drm_format_info *info;\n\n\tif (dp->dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_VIDEO))\n\t\tlayer_id = ZYNQMP_DPSUB_LAYER_VID;\n\telse if (dp->dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_GFX))\n\t\tlayer_id = ZYNQMP_DPSUB_LAYER_GFX;\n\telse\n\t\treturn;\n\n\tlayer = dp->dpsub->layers[layer_id];\n\n\t \n\tinfo = drm_format_info(DRM_FORMAT_YUV422);\n\tzynqmp_disp_layer_set_format(layer, info);\n\tzynqmp_disp_layer_enable(layer, ZYNQMP_DPSUB_LAYER_LIVE);\n\n\tif (layer_id == ZYNQMP_DPSUB_LAYER_GFX)\n\t\tzynqmp_disp_blend_set_global_alpha(dp->dpsub->disp, true, 255);\n\telse\n\t\tzynqmp_disp_blend_set_global_alpha(dp->dpsub->disp, false, 0);\n\n\tzynqmp_disp_enable(dp->dpsub->disp);\n}\n\nstatic void zynqmp_dp_disp_disable(struct zynqmp_dp *dp,\n\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct zynqmp_disp_layer *layer;\n\n\tif (dp->dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_VIDEO))\n\t\tlayer = dp->dpsub->layers[ZYNQMP_DPSUB_LAYER_VID];\n\telse if (dp->dpsub->connected_ports & BIT(ZYNQMP_DPSUB_PORT_LIVE_GFX))\n\t\tlayer = dp->dpsub->layers[ZYNQMP_DPSUB_LAYER_GFX];\n\telse\n\t\treturn;\n\n\tzynqmp_disp_disable(dp->dpsub->disp);\n\tzynqmp_disp_layer_disable(layer);\n}\n\n \n\nstatic int zynqmp_dp_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t   enum drm_bridge_attach_flags flags)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\tint ret;\n\n\t \n\tret = zynqmp_dp_aux_init(dp);\n\tif (ret) {\n\t\tdev_err(dp->dev, \"failed to initialize DP aux\\n\");\n\t\treturn ret;\n\t}\n\n\tif (dp->next_bridge) {\n\t\tret = drm_bridge_attach(bridge->encoder, dp->next_bridge,\n\t\t\t\t\tbridge, flags);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_EN, ZYNQMP_DP_INT_ALL);\n\n\treturn 0;\n\nerror:\n\tzynqmp_dp_aux_cleanup(dp);\n\treturn ret;\n}\n\nstatic void zynqmp_dp_bridge_detach(struct drm_bridge *bridge)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\n\tzynqmp_dp_aux_cleanup(dp);\n}\n\nstatic enum drm_mode_status\nzynqmp_dp_bridge_mode_valid(struct drm_bridge *bridge,\n\t\t\t    const struct drm_display_info *info,\n\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\tint rate;\n\n\tif (mode->clock > ZYNQMP_MAX_FREQ) {\n\t\tdev_dbg(dp->dev, \"filtered mode %s for high pixel rate\\n\",\n\t\t\tmode->name);\n\t\tdrm_mode_debug_printmodeline(mode);\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\t \n\trate = zynqmp_dp_max_rate(dp->link_config.max_rate,\n\t\t\t\t  dp->link_config.max_lanes, dp->config.bpp);\n\tif (mode->clock > rate) {\n\t\tdev_dbg(dp->dev, \"filtered mode %s for high pixel rate\\n\",\n\t\t\tmode->name);\n\t\tdrm_mode_debug_printmodeline(mode);\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic void zynqmp_dp_bridge_atomic_enable(struct drm_bridge *bridge,\n\t\t\t\t\t   struct drm_bridge_state *old_bridge_state)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\tstruct drm_atomic_state *state = old_bridge_state->base.state;\n\tconst struct drm_crtc_state *crtc_state;\n\tconst struct drm_display_mode *adjusted_mode;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc *crtc;\n\tunsigned int i;\n\tint rate;\n\tint ret;\n\n\tpm_runtime_get_sync(dp->dev);\n\n\tzynqmp_dp_disp_enable(dp, old_bridge_state);\n\n\t \n\tconnector = drm_atomic_get_new_connector_for_encoder(state,\n\t\t\t\t\t\t\t     bridge->encoder);\n\tcrtc = drm_atomic_get_new_connector_state(state, connector)->crtc;\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tadjusted_mode = &crtc_state->adjusted_mode;\n\tmode = &crtc_state->mode;\n\n\tzynqmp_dp_set_format(dp, &connector->display_info,\n\t\t\t     ZYNQMP_DPSUB_FORMAT_RGB, 8);\n\n\t \n\trate = zynqmp_dp_max_rate(dp->link_config.max_rate,\n\t\t\t\t  dp->link_config.max_lanes, dp->config.bpp);\n\tif (mode->clock > rate) {\n\t\tdev_err(dp->dev, \"mode %s has too high pixel rate\\n\",\n\t\t\tmode->name);\n\t\tdrm_mode_debug_printmodeline(mode);\n\t}\n\n\t \n\tret = zynqmp_dp_mode_configure(dp, adjusted_mode->clock, 0);\n\tif (ret < 0) {\n\t\tpm_runtime_put_sync(dp->dev);\n\t\treturn;\n\t}\n\n\tzynqmp_dp_encoder_mode_set_transfer_unit(dp, adjusted_mode);\n\tzynqmp_dp_encoder_mode_set_stream(dp, adjusted_mode);\n\n\t \n\tdp->enabled = true;\n\tzynqmp_dp_update_misc(dp);\n\tif (zynqmp_dpsub_audio_enabled(dp->dpsub))\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_AUDIO_CONTROL, 1);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_PHY_POWER_DOWN, 0);\n\tif (dp->status == connector_status_connected) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = drm_dp_dpcd_writeb(&dp->aux, DP_SET_POWER,\n\t\t\t\t\t\t DP_SET_POWER_D0);\n\t\t\tif (ret == 1)\n\t\t\t\tbreak;\n\t\t\tusleep_range(300, 500);\n\t\t}\n\t\t \n\t\tmsleep(zynqmp_dp_power_on_delay_ms);\n\t}\n\tif (ret != 1)\n\t\tdev_dbg(dp->dev, \"DP aux failed\\n\");\n\telse\n\t\tzynqmp_dp_train_loop(dp);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_SOFTWARE_RESET,\n\t\t\tZYNQMP_DP_SOFTWARE_RESET_ALL);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_ENABLE, 1);\n}\n\nstatic void zynqmp_dp_bridge_atomic_disable(struct drm_bridge *bridge,\n\t\t\t\t\t    struct drm_bridge_state *old_bridge_state)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\n\tdp->enabled = false;\n\tcancel_delayed_work(&dp->hpd_work);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_MAIN_STREAM_ENABLE, 0);\n\tdrm_dp_dpcd_writeb(&dp->aux, DP_SET_POWER, DP_SET_POWER_D3);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_PHY_POWER_DOWN,\n\t\t\tZYNQMP_DP_TX_PHY_POWER_DOWN_ALL);\n\tif (zynqmp_dpsub_audio_enabled(dp->dpsub))\n\t\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_AUDIO_CONTROL, 0);\n\n\tzynqmp_dp_disp_disable(dp, old_bridge_state);\n\n\tpm_runtime_put_sync(dp->dev);\n}\n\n#define ZYNQMP_DP_MIN_H_BACKPORCH\t20\n\nstatic int zynqmp_dp_bridge_atomic_check(struct drm_bridge *bridge,\n\t\t\t\t\t struct drm_bridge_state *bridge_state,\n\t\t\t\t\t struct drm_crtc_state *crtc_state,\n\t\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\tint diff = mode->htotal - mode->hsync_end;\n\n\t \n\tif (diff < ZYNQMP_DP_MIN_H_BACKPORCH) {\n\t\tint vrefresh = (adjusted_mode->clock * 1000) /\n\t\t\t       (adjusted_mode->vtotal * adjusted_mode->htotal);\n\n\t\tdev_dbg(dp->dev, \"hbackporch adjusted: %d to %d\",\n\t\t\tdiff, ZYNQMP_DP_MIN_H_BACKPORCH - diff);\n\t\tdiff = ZYNQMP_DP_MIN_H_BACKPORCH - diff;\n\t\tadjusted_mode->htotal += diff;\n\t\tadjusted_mode->clock = adjusted_mode->vtotal *\n\t\t\t\t       adjusted_mode->htotal * vrefresh / 1000;\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_connector_status zynqmp_dp_bridge_detect(struct drm_bridge *bridge)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\tstruct zynqmp_dp_link_config *link_config = &dp->link_config;\n\tu32 state, i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tstate = zynqmp_dp_read(dp, ZYNQMP_DP_INTERRUPT_SIGNAL_STATE);\n\t\tif (state & ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_HPD)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\tif (state & ZYNQMP_DP_INTERRUPT_SIGNAL_STATE_HPD) {\n\t\tret = drm_dp_dpcd_read(&dp->aux, 0x0, dp->dpcd,\n\t\t\t\t       sizeof(dp->dpcd));\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(dp->dev, \"DPCD read failed\");\n\t\t\tgoto disconnected;\n\t\t}\n\n\t\tlink_config->max_rate = min_t(int,\n\t\t\t\t\t      drm_dp_max_link_rate(dp->dpcd),\n\t\t\t\t\t      DP_HIGH_BIT_RATE2);\n\t\tlink_config->max_lanes = min_t(u8,\n\t\t\t\t\t       drm_dp_max_lane_count(dp->dpcd),\n\t\t\t\t\t       dp->num_lanes);\n\n\t\tdp->status = connector_status_connected;\n\t\treturn connector_status_connected;\n\t}\n\ndisconnected:\n\tdp->status = connector_status_disconnected;\n\treturn connector_status_disconnected;\n}\n\nstatic struct edid *zynqmp_dp_bridge_get_edid(struct drm_bridge *bridge,\n\t\t\t\t\t      struct drm_connector *connector)\n{\n\tstruct zynqmp_dp *dp = bridge_to_dp(bridge);\n\n\treturn drm_get_edid(connector, &dp->aux.ddc);\n}\n\nstatic const struct drm_bridge_funcs zynqmp_dp_bridge_funcs = {\n\t.attach = zynqmp_dp_bridge_attach,\n\t.detach = zynqmp_dp_bridge_detach,\n\t.mode_valid = zynqmp_dp_bridge_mode_valid,\n\t.atomic_enable = zynqmp_dp_bridge_atomic_enable,\n\t.atomic_disable = zynqmp_dp_bridge_atomic_disable,\n\t.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,\n\t.atomic_reset = drm_atomic_helper_bridge_reset,\n\t.atomic_check = zynqmp_dp_bridge_atomic_check,\n\t.detect = zynqmp_dp_bridge_detect,\n\t.get_edid = zynqmp_dp_bridge_get_edid,\n};\n\n \n\n \nvoid zynqmp_dp_enable_vblank(struct zynqmp_dp *dp)\n{\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_EN, ZYNQMP_DP_INT_VBLANK_START);\n}\n\n \nvoid zynqmp_dp_disable_vblank(struct zynqmp_dp *dp)\n{\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_DS, ZYNQMP_DP_INT_VBLANK_START);\n}\n\nstatic void zynqmp_dp_hpd_work_func(struct work_struct *work)\n{\n\tstruct zynqmp_dp *dp = container_of(work, struct zynqmp_dp,\n\t\t\t\t\t    hpd_work.work);\n\tenum drm_connector_status status;\n\n\tstatus = zynqmp_dp_bridge_detect(&dp->bridge);\n\tdrm_bridge_hpd_notify(&dp->bridge, status);\n}\n\nstatic irqreturn_t zynqmp_dp_irq_handler(int irq, void *data)\n{\n\tstruct zynqmp_dp *dp = (struct zynqmp_dp *)data;\n\tu32 status, mask;\n\n\tstatus = zynqmp_dp_read(dp, ZYNQMP_DP_INT_STATUS);\n\tmask = zynqmp_dp_read(dp, ZYNQMP_DP_INT_MASK);\n\tif (!(status & ~mask))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (status & ZYNQMP_DP_INT_CHBUF_UNDERFLW_MASK)\n\t\tdev_dbg_ratelimited(dp->dev, \"underflow interrupt\\n\");\n\tif (status & ZYNQMP_DP_INT_CHBUF_OVERFLW_MASK)\n\t\tdev_dbg_ratelimited(dp->dev, \"overflow interrupt\\n\");\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_STATUS, status);\n\n\tif (status & ZYNQMP_DP_INT_VBLANK_START)\n\t\tzynqmp_dpsub_drm_handle_vblank(dp->dpsub);\n\n\tif (status & ZYNQMP_DP_INT_HPD_EVENT)\n\t\tschedule_delayed_work(&dp->hpd_work, 0);\n\n\tif (status & ZYNQMP_DP_INT_HPD_IRQ) {\n\t\tint ret;\n\t\tu8 status[DP_LINK_STATUS_SIZE + 2];\n\n\t\tret = drm_dp_dpcd_read(&dp->aux, DP_SINK_COUNT, status,\n\t\t\t\t       DP_LINK_STATUS_SIZE + 2);\n\t\tif (ret < 0)\n\t\t\tgoto handled;\n\n\t\tif (status[4] & DP_LINK_STATUS_UPDATED ||\n\t\t    !drm_dp_clock_recovery_ok(&status[2], dp->mode.lane_cnt) ||\n\t\t    !drm_dp_channel_eq_ok(&status[2], dp->mode.lane_cnt)) {\n\t\t\tzynqmp_dp_train_loop(dp);\n\t\t}\n\t}\n\nhandled:\n\treturn IRQ_HANDLED;\n}\n\n \n\nint zynqmp_dp_probe(struct zynqmp_dpsub *dpsub)\n{\n\tstruct platform_device *pdev = to_platform_device(dpsub->dev);\n\tstruct drm_bridge *bridge;\n\tstruct zynqmp_dp *dp;\n\tstruct resource *res;\n\tint ret;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tdp->dev = &pdev->dev;\n\tdp->dpsub = dpsub;\n\tdp->status = connector_status_disconnected;\n\n\tINIT_DELAYED_WORK(&dp->hpd_work, zynqmp_dp_hpd_work_func);\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dp\");\n\tdp->iomem = devm_ioremap_resource(dp->dev, res);\n\tif (IS_ERR(dp->iomem)) {\n\t\tret = PTR_ERR(dp->iomem);\n\t\tgoto err_free;\n\t}\n\n\tdp->irq = platform_get_irq(pdev, 0);\n\tif (dp->irq < 0) {\n\t\tret = dp->irq;\n\t\tgoto err_free;\n\t}\n\n\tdp->reset = devm_reset_control_get(dp->dev, NULL);\n\tif (IS_ERR(dp->reset)) {\n\t\tif (PTR_ERR(dp->reset) != -EPROBE_DEFER)\n\t\t\tdev_err(dp->dev, \"failed to get reset: %ld\\n\",\n\t\t\t\tPTR_ERR(dp->reset));\n\t\tret = PTR_ERR(dp->reset);\n\t\tgoto err_free;\n\t}\n\n\tret = zynqmp_dp_reset(dp, false);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tret = zynqmp_dp_phy_probe(dp);\n\tif (ret)\n\t\tgoto err_reset;\n\n\t \n\tbridge = &dp->bridge;\n\tbridge->funcs = &zynqmp_dp_bridge_funcs;\n\tbridge->ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID\n\t\t    | DRM_BRIDGE_OP_HPD;\n\tbridge->type = DRM_MODE_CONNECTOR_DisplayPort;\n\tdpsub->bridge = bridge;\n\n\t \n\tret = drm_of_find_panel_or_bridge(dp->dev->of_node, 5, 0, NULL,\n\t\t\t\t\t  &dp->next_bridge);\n\tif (ret < 0 && ret != -ENODEV)\n\t\tgoto err_reset;\n\n\t \n\tdp->config.misc0 &= ~ZYNQMP_DP_MAIN_STREAM_MISC0_SYNC_LOCK;\n\tzynqmp_dp_set_format(dp, NULL, ZYNQMP_DPSUB_FORMAT_RGB, 8);\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TX_PHY_POWER_DOWN,\n\t\t\tZYNQMP_DP_TX_PHY_POWER_DOWN_ALL);\n\tzynqmp_dp_set(dp, ZYNQMP_DP_PHY_RESET, ZYNQMP_DP_PHY_RESET_ALL_RESET);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_FORCE_SCRAMBLER_RESET, 1);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TRANSMITTER_ENABLE, 0);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_DS, 0xffffffff);\n\n\tret = zynqmp_dp_phy_init(dp);\n\tif (ret)\n\t\tgoto err_reset;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TRANSMITTER_ENABLE, 1);\n\n\t \n\tret = devm_request_threaded_irq(dp->dev, dp->irq, NULL,\n\t\t\t\t\tzynqmp_dp_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dp->dev), dp);\n\tif (ret < 0)\n\t\tgoto err_phy_exit;\n\n\tdpsub->dp = dp;\n\n\tdev_dbg(dp->dev, \"ZynqMP DisplayPort Tx probed with %u lanes\\n\",\n\t\tdp->num_lanes);\n\n\treturn 0;\n\nerr_phy_exit:\n\tzynqmp_dp_phy_exit(dp);\nerr_reset:\n\tzynqmp_dp_reset(dp, true);\nerr_free:\n\tkfree(dp);\n\treturn ret;\n}\n\nvoid zynqmp_dp_remove(struct zynqmp_dpsub *dpsub)\n{\n\tstruct zynqmp_dp *dp = dpsub->dp;\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_DS, ZYNQMP_DP_INT_ALL);\n\tdisable_irq(dp->irq);\n\n\tcancel_delayed_work_sync(&dp->hpd_work);\n\n\tzynqmp_dp_write(dp, ZYNQMP_DP_TRANSMITTER_ENABLE, 0);\n\tzynqmp_dp_write(dp, ZYNQMP_DP_INT_DS, 0xffffffff);\n\n\tzynqmp_dp_phy_exit(dp);\n\tzynqmp_dp_reset(dp, true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}