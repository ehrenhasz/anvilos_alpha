{
  "module_name": "zynqmp_kms.c",
  "hash_id": "667a579e8c565e63e2d0c48fb72c476a1a3abaac802bca25beb75b4779b9a736",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/xlnx/zynqmp_kms.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_bridge_connector.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_mode_config.h>\n#include <drm/drm_plane.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n\n#include \"zynqmp_disp.h\"\n#include \"zynqmp_dp.h\"\n#include \"zynqmp_dpsub.h\"\n#include \"zynqmp_kms.h\"\n\nstatic inline struct zynqmp_dpsub *to_zynqmp_dpsub(struct drm_device *drm)\n{\n\treturn container_of(drm, struct zynqmp_dpsub_drm, dev)->dpsub;\n}\n\n \n\nstatic int zynqmp_dpsub_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (!new_plane_state->crtc)\n\t\treturn 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, new_plane_state->crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   false, false);\n}\n\nstatic void zynqmp_dpsub_plane_atomic_disable(struct drm_plane *plane,\n\t\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state,\n\t\t\t\t\t\t\t\t\t   plane);\n\tstruct zynqmp_dpsub *dpsub = to_zynqmp_dpsub(plane->dev);\n\tstruct zynqmp_disp_layer *layer = dpsub->layers[plane->index];\n\n\tif (!old_state->fb)\n\t\treturn;\n\n\tzynqmp_disp_layer_disable(layer);\n\n\tif (plane->index == ZYNQMP_DPSUB_LAYER_GFX)\n\t\tzynqmp_disp_blend_set_global_alpha(dpsub->disp, false,\n\t\t\t\t\t\t   plane->state->alpha >> 8);\n}\n\nstatic void zynqmp_dpsub_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *old_state = drm_atomic_get_old_plane_state(state, plane);\n\tstruct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state, plane);\n\tstruct zynqmp_dpsub *dpsub = to_zynqmp_dpsub(plane->dev);\n\tstruct zynqmp_disp_layer *layer = dpsub->layers[plane->index];\n\tbool format_changed = false;\n\n\tif (!old_state->fb ||\n\t    old_state->fb->format->format != new_state->fb->format->format)\n\t\tformat_changed = true;\n\n\t \n\tif (format_changed) {\n\t\tif (old_state->fb)\n\t\t\tzynqmp_disp_layer_disable(layer);\n\n\t\tzynqmp_disp_layer_set_format(layer, new_state->fb->format);\n\t}\n\n\tzynqmp_disp_layer_update(layer, new_state);\n\n\tif (plane->index == ZYNQMP_DPSUB_LAYER_GFX)\n\t\tzynqmp_disp_blend_set_global_alpha(dpsub->disp, true,\n\t\t\t\t\t\t   plane->state->alpha >> 8);\n\n\t \n\tif (format_changed)\n\t\tzynqmp_disp_layer_enable(layer, ZYNQMP_DPSUB_LAYER_NONLIVE);\n}\n\nstatic const struct drm_plane_helper_funcs zynqmp_dpsub_plane_helper_funcs = {\n\t.atomic_check\t\t= zynqmp_dpsub_plane_atomic_check,\n\t.atomic_update\t\t= zynqmp_dpsub_plane_atomic_update,\n\t.atomic_disable\t\t= zynqmp_dpsub_plane_atomic_disable,\n};\n\nstatic const struct drm_plane_funcs zynqmp_dpsub_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= drm_plane_cleanup,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic int zynqmp_dpsub_create_planes(struct zynqmp_dpsub *dpsub)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpsub->drm->planes); i++) {\n\t\tstruct zynqmp_disp_layer *layer = dpsub->layers[i];\n\t\tstruct drm_plane *plane = &dpsub->drm->planes[i];\n\t\tenum drm_plane_type type;\n\t\tunsigned int num_formats;\n\t\tu32 *formats;\n\n\t\tformats = zynqmp_disp_layer_drm_formats(layer, &num_formats);\n\t\tif (!formats)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\ttype = i == ZYNQMP_DPSUB_LAYER_VID\n\t\t     ? DRM_PLANE_TYPE_OVERLAY : DRM_PLANE_TYPE_PRIMARY;\n\t\tret = drm_universal_plane_init(&dpsub->drm->dev, plane, 0,\n\t\t\t\t\t       &zynqmp_dpsub_plane_funcs,\n\t\t\t\t\t       formats, num_formats,\n\t\t\t\t\t       NULL, type, NULL);\n\t\tkfree(formats);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_plane_helper_add(plane, &zynqmp_dpsub_plane_helper_funcs);\n\n\t\tdrm_plane_create_zpos_immutable_property(plane, i);\n\t\tif (i == ZYNQMP_DPSUB_LAYER_GFX)\n\t\t\tdrm_plane_create_alpha_property(plane);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic inline struct zynqmp_dpsub *crtc_to_dpsub(struct drm_crtc *crtc)\n{\n\treturn container_of(crtc, struct zynqmp_dpsub_drm, crtc)->dpsub;\n}\n\nstatic void zynqmp_dpsub_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct zynqmp_dpsub *dpsub = crtc_to_dpsub(crtc);\n\tstruct drm_display_mode *adjusted_mode = &crtc->state->adjusted_mode;\n\tint ret, vrefresh;\n\n\tpm_runtime_get_sync(dpsub->dev);\n\n\tzynqmp_disp_setup_clock(dpsub->disp, adjusted_mode->clock * 1000);\n\n\tret = clk_prepare_enable(dpsub->vid_clk);\n\tif (ret) {\n\t\tdev_err(dpsub->dev, \"failed to enable a pixel clock\\n\");\n\t\tpm_runtime_put_sync(dpsub->dev);\n\t\treturn;\n\t}\n\n\tzynqmp_disp_enable(dpsub->disp);\n\n\t \n\tvrefresh = (adjusted_mode->clock * 1000) /\n\t\t   (adjusted_mode->vtotal * adjusted_mode->htotal);\n\tmsleep(3 * 1000 / vrefresh);\n}\n\nstatic void zynqmp_dpsub_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct zynqmp_dpsub *dpsub = crtc_to_dpsub(crtc);\n\tstruct drm_plane_state *old_plane_state;\n\n\t \n\told_plane_state = drm_atomic_get_old_plane_state(state, crtc->primary);\n\tif (old_plane_state)\n\t\tzynqmp_dpsub_plane_atomic_disable(crtc->primary, state);\n\n\tzynqmp_disp_disable(dpsub->disp);\n\n\tdrm_crtc_vblank_off(crtc);\n\n\tspin_lock_irq(&crtc->dev->event_lock);\n\tif (crtc->state->event) {\n\t\tdrm_crtc_send_vblank_event(crtc, crtc->state->event);\n\t\tcrtc->state->event = NULL;\n\t}\n\tspin_unlock_irq(&crtc->dev->event_lock);\n\n\tclk_disable_unprepare(dpsub->vid_clk);\n\tpm_runtime_put_sync(dpsub->dev);\n}\n\nstatic int zynqmp_dpsub_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_atomic_state *state)\n{\n\treturn drm_atomic_add_affected_planes(state, crtc);\n}\n\nstatic void zynqmp_dpsub_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void zynqmp_dpsub_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_atomic_state *state)\n{\n\tif (crtc->state->event) {\n\t\tstruct drm_pending_vblank_event *event;\n\n\t\t \n\t\tevent = crtc->state->event;\n\t\tcrtc->state->event = NULL;\n\n\t\tevent->pipe = drm_crtc_index(crtc);\n\n\t\tWARN_ON(drm_crtc_vblank_get(crtc) != 0);\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs zynqmp_dpsub_crtc_helper_funcs = {\n\t.atomic_enable\t= zynqmp_dpsub_crtc_atomic_enable,\n\t.atomic_disable\t= zynqmp_dpsub_crtc_atomic_disable,\n\t.atomic_check\t= zynqmp_dpsub_crtc_atomic_check,\n\t.atomic_begin\t= zynqmp_dpsub_crtc_atomic_begin,\n\t.atomic_flush\t= zynqmp_dpsub_crtc_atomic_flush,\n};\n\nstatic int zynqmp_dpsub_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct zynqmp_dpsub *dpsub = crtc_to_dpsub(crtc);\n\n\tzynqmp_dp_enable_vblank(dpsub->dp);\n\n\treturn 0;\n}\n\nstatic void zynqmp_dpsub_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct zynqmp_dpsub *dpsub = crtc_to_dpsub(crtc);\n\n\tzynqmp_dp_disable_vblank(dpsub->dp);\n}\n\nstatic const struct drm_crtc_funcs zynqmp_dpsub_crtc_funcs = {\n\t.destroy\t\t= drm_crtc_cleanup,\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.page_flip\t\t= drm_atomic_helper_page_flip,\n\t.reset\t\t\t= drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state\t= drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank\t\t= zynqmp_dpsub_crtc_enable_vblank,\n\t.disable_vblank\t\t= zynqmp_dpsub_crtc_disable_vblank,\n};\n\nstatic int zynqmp_dpsub_create_crtc(struct zynqmp_dpsub *dpsub)\n{\n\tstruct drm_plane *plane = &dpsub->drm->planes[ZYNQMP_DPSUB_LAYER_GFX];\n\tstruct drm_crtc *crtc = &dpsub->drm->crtc;\n\tint ret;\n\n\tret = drm_crtc_init_with_planes(&dpsub->drm->dev, crtc, plane,\n\t\t\t\t\tNULL, &zynqmp_dpsub_crtc_funcs, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_crtc_helper_add(crtc, &zynqmp_dpsub_crtc_helper_funcs);\n\n\t \n\tdrm_crtc_vblank_off(crtc);\n\n\treturn 0;\n}\n\nstatic void zynqmp_dpsub_map_crtc_to_plane(struct zynqmp_dpsub *dpsub)\n{\n\tu32 possible_crtcs = drm_crtc_mask(&dpsub->drm->crtc);\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpsub->drm->planes); i++)\n\t\tdpsub->drm->planes[i].possible_crtcs = possible_crtcs;\n}\n\n \nvoid zynqmp_dpsub_drm_handle_vblank(struct zynqmp_dpsub *dpsub)\n{\n\tdrm_crtc_handle_vblank(&dpsub->drm->crtc);\n}\n\n \n\nstatic int zynqmp_dpsub_dumb_create(struct drm_file *file_priv,\n\t\t\t\t    struct drm_device *drm,\n\t\t\t\t    struct drm_mode_create_dumb *args)\n{\n\tstruct zynqmp_dpsub *dpsub = to_zynqmp_dpsub(drm);\n\tunsigned int pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\n\t \n\targs->pitch = ALIGN(pitch, dpsub->dma_align);\n\n\treturn drm_gem_dma_dumb_create_internal(file_priv, drm, args);\n}\n\nstatic struct drm_framebuffer *\nzynqmp_dpsub_fb_create(struct drm_device *drm, struct drm_file *file_priv,\n\t\t       const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct zynqmp_dpsub *dpsub = to_zynqmp_dpsub(drm);\n\tstruct drm_mode_fb_cmd2 cmd = *mode_cmd;\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cmd.pitches); ++i)\n\t\tcmd.pitches[i] = ALIGN(cmd.pitches[i], dpsub->dma_align);\n\n\treturn drm_gem_fb_create(drm, file_priv, &cmd);\n}\n\nstatic const struct drm_mode_config_funcs zynqmp_dpsub_mode_config_funcs = {\n\t.fb_create\t\t= zynqmp_dpsub_fb_create,\n\t.atomic_check\t\t= drm_atomic_helper_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\n \n\nDEFINE_DRM_GEM_DMA_FOPS(zynqmp_dpsub_drm_fops);\n\nstatic const struct drm_driver zynqmp_dpsub_drm_driver = {\n\t.driver_features\t\t= DRIVER_MODESET | DRIVER_GEM |\n\t\t\t\t\t  DRIVER_ATOMIC,\n\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(zynqmp_dpsub_dumb_create),\n\n\t.fops\t\t\t\t= &zynqmp_dpsub_drm_fops,\n\n\t.name\t\t\t\t= \"zynqmp-dpsub\",\n\t.desc\t\t\t\t= \"Xilinx DisplayPort Subsystem Driver\",\n\t.date\t\t\t\t= \"20130509\",\n\t.major\t\t\t\t= 1,\n\t.minor\t\t\t\t= 0,\n};\n\nstatic int zynqmp_dpsub_kms_init(struct zynqmp_dpsub *dpsub)\n{\n\tstruct drm_encoder *encoder = &dpsub->drm->encoder;\n\tstruct drm_connector *connector;\n\tint ret;\n\n\t \n\tret = zynqmp_dpsub_create_planes(dpsub);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_dpsub_create_crtc(dpsub);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tzynqmp_dpsub_map_crtc_to_plane(dpsub);\n\n\t \n\tencoder->possible_crtcs |= drm_crtc_mask(&dpsub->drm->crtc);\n\tdrm_simple_encoder_init(&dpsub->drm->dev, encoder, DRM_MODE_ENCODER_NONE);\n\n\tret = drm_bridge_attach(encoder, dpsub->bridge, NULL,\n\t\t\t\tDRM_BRIDGE_ATTACH_NO_CONNECTOR);\n\tif (ret) {\n\t\tdev_err(dpsub->dev, \"failed to attach bridge to encoder\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tconnector = drm_bridge_connector_init(&dpsub->drm->dev, encoder);\n\tif (IS_ERR(connector)) {\n\t\tdev_err(dpsub->dev, \"failed to created connector\\n\");\n\t\treturn PTR_ERR(connector);\n\t}\n\n\tret = drm_connector_attach_encoder(connector, encoder);\n\tif (ret < 0) {\n\t\tdev_err(dpsub->dev, \"failed to attach connector to encoder\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void zynqmp_dpsub_drm_release(struct drm_device *drm, void *res)\n{\n\tstruct zynqmp_dpsub_drm *dpdrm = res;\n\n\tzynqmp_dpsub_release(dpdrm->dpsub);\n}\n\nint zynqmp_dpsub_drm_init(struct zynqmp_dpsub *dpsub)\n{\n\tstruct zynqmp_dpsub_drm *dpdrm;\n\tstruct drm_device *drm;\n\tint ret;\n\n\t \n\tdpdrm = devm_drm_dev_alloc(dpsub->dev, &zynqmp_dpsub_drm_driver,\n\t\t\t\t   struct zynqmp_dpsub_drm, dev);\n\tif (IS_ERR(dpdrm))\n\t\treturn PTR_ERR(dpdrm);\n\n\tdpdrm->dpsub = dpsub;\n\tdrm = &dpdrm->dev;\n\n\tret = drmm_add_action(drm, zynqmp_dpsub_drm_release, dpdrm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdpsub->drm = dpdrm;\n\n\t \n\tret = drmm_mode_config_init(drm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm->mode_config.funcs = &zynqmp_dpsub_mode_config_funcs;\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = ZYNQMP_DISP_MAX_WIDTH;\n\tdrm->mode_config.max_height = ZYNQMP_DISP_MAX_HEIGHT;\n\n\tret = drm_vblank_init(drm, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tret = zynqmp_dpsub_kms_init(dpsub);\n\tif (ret < 0)\n\t\tgoto err_poll_fini;\n\n\t \n\tdrm_mode_config_reset(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret < 0)\n\t\tgoto err_poll_fini;\n\n\t \n\tdrm_fbdev_dma_setup(drm, 24);\n\n\treturn 0;\n\nerr_poll_fini:\n\tdrm_kms_helper_poll_fini(drm);\n\treturn ret;\n}\n\nvoid zynqmp_dpsub_drm_cleanup(struct zynqmp_dpsub *dpsub)\n{\n\tstruct drm_device *drm = &dpsub->drm->dev;\n\n\tdrm_dev_unregister(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tdrm_kms_helper_poll_fini(drm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}