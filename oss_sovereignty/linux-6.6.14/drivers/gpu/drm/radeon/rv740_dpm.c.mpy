{
  "module_name": "rv740_dpm.c",
  "hash_id": "545cfc9318154b714991767d21eeba2d663a5aeaf017bbd4c8a9a6e1d7e05e40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rv740_dpm.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"rv740d.h\"\n#include \"r600_dpm.h\"\n#include \"rv770.h\"\n#include \"rv770_dpm.h\"\n#include \"atom.h\"\n\nu32 rv740_get_decoded_reference_divider(u32 encoded_ref)\n{\n\tu32 ref = 0;\n\n\tswitch (encoded_ref) {\n\tcase 0:\n\t\tref = 1;\n\t\tbreak;\n\tcase 16:\n\t\tref = 2;\n\t\tbreak;\n\tcase 17:\n\t\tref = 3;\n\t\tbreak;\n\tcase 18:\n\t\tref = 2;\n\t\tbreak;\n\tcase 19:\n\t\tref = 3;\n\t\tbreak;\n\tcase 20:\n\t\tref = 4;\n\t\tbreak;\n\tcase 21:\n\t\tref = 5;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid encoded Reference Divider\\n\");\n\t\tref = 0;\n\t\tbreak;\n\t}\n\n\treturn ref;\n}\n\nstruct dll_speed_setting {\n\tu16 min;\n\tu16 max;\n\tu32 dll_speed;\n};\n\nstatic struct dll_speed_setting dll_speed_table[16] =\n{\n\t{ 270, 320, 0x0f },\n\t{ 240, 270, 0x0e },\n\t{ 200, 240, 0x0d },\n\t{ 180, 200, 0x0c },\n\t{ 160, 180, 0x0b },\n\t{ 140, 160, 0x0a },\n\t{ 120, 140, 0x09 },\n\t{ 110, 120, 0x08 },\n\t{  95, 110, 0x07 },\n\t{  85,  95, 0x06 },\n\t{  78,  85, 0x05 },\n\t{  70,  78, 0x04 },\n\t{  65,  70, 0x03 },\n\t{  60,  65, 0x02 },\n\t{  42,  60, 0x01 },\n\t{  00,  42, 0x00 }\n};\n\nu32 rv740_get_dll_speed(bool is_gddr5, u32 memory_clock)\n{\n\tint i;\n\tu32 factor;\n\tu16 data_rate;\n\n\tif (is_gddr5)\n\t\tfactor = 4;\n\telse\n\t\tfactor = 2;\n\n\tdata_rate = (u16)(memory_clock * factor / 1000);\n\n\tif (data_rate < dll_speed_table[0].max) {\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tif (data_rate > dll_speed_table[i].min &&\n\t\t\t    data_rate <= dll_speed_table[i].max)\n\t\t\t\treturn dll_speed_table[i].dll_speed;\n\t\t}\n\t}\n\n\tDRM_DEBUG_KMS(\"Target MCLK greater than largest MCLK in DLL speed table\\n\");\n\n\treturn 0x0f;\n}\n\nint rv740_populate_sclk_value(struct radeon_device *rdev, u32 engine_clock,\n\t\t\t      RV770_SMC_SCLK_VALUE *sclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct atom_clock_dividers dividers;\n\tu32 spll_func_cntl = pi->clk_regs.rv770.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 = pi->clk_regs.rv770.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 = pi->clk_regs.rv770.cg_spll_func_cntl_3;\n\tu32 cg_spll_spread_spectrum = pi->clk_regs.rv770.cg_spll_spread_spectrum;\n\tu32 cg_spll_spread_spectrum_2 = pi->clk_regs.rv770.cg_spll_spread_spectrum_2;\n\tu64 tmp;\n\tu32 reference_clock = rdev->clock.spll.reference_freq;\n\tu32 reference_divider;\n\tu32 fbdiv;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     engine_clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\treference_divider = 1 + dividers.ref_div;\n\n\ttmp = (u64) engine_clock * reference_divider * dividers.post_div * 16384;\n\tdo_div(tmp, reference_clock);\n\tfbdiv = (u32) tmp;\n\n\tspll_func_cntl &= ~(SPLL_PDIV_A_MASK | SPLL_REF_DIV_MASK);\n\tspll_func_cntl |= SPLL_REF_DIV(dividers.ref_div);\n\tspll_func_cntl |= SPLL_PDIV_A(dividers.post_div);\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(2);\n\n\tspll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;\n\tspll_func_cntl_3 |= SPLL_FB_DIV(fbdiv);\n\tspll_func_cntl_3 |= SPLL_DITHEN;\n\n\tif (pi->sclk_ss) {\n\t\tstruct radeon_atom_ss ss;\n\t\tu32 vco_freq = engine_clock * dividers.post_div;\n\n\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_ENGINE_SS, vco_freq)) {\n\t\t\tu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\n\t\t\tu32 clk_v = 4 * ss.percentage * fbdiv / (clk_s * 10000);\n\n\t\t\tcg_spll_spread_spectrum &= ~CLK_S_MASK;\n\t\t\tcg_spll_spread_spectrum |= CLK_S(clk_s);\n\t\t\tcg_spll_spread_spectrum |= SSEN;\n\n\t\t\tcg_spll_spread_spectrum_2 &= ~CLK_V_MASK;\n\t\t\tcg_spll_spread_spectrum_2 |= CLK_V(clk_v);\n\t\t}\n\t}\n\n\tsclk->sclk_value = cpu_to_be32(engine_clock);\n\tsclk->vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\n\tsclk->vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\n\tsclk->vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32(cg_spll_spread_spectrum);\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32(cg_spll_spread_spectrum_2);\n\n\treturn 0;\n}\n\nint rv740_populate_mclk_value(struct radeon_device *rdev,\n\t\t\t      u32 engine_clock, u32 memory_clock,\n\t\t\t      RV7XX_SMC_MCLK_VALUE *mclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 mpll_ad_func_cntl = pi->clk_regs.rv770.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 = pi->clk_regs.rv770.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl = pi->clk_regs.rv770.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 = pi->clk_regs.rv770.mpll_dq_func_cntl_2;\n\tu32 mclk_pwrmgt_cntl = pi->clk_regs.rv770.mclk_pwrmgt_cntl;\n\tu32 dll_cntl = pi->clk_regs.rv770.dll_cntl;\n\tu32 mpll_ss1 = pi->clk_regs.rv770.mpll_ss1;\n\tu32 mpll_ss2 = pi->clk_regs.rv770.mpll_ss2;\n\tstruct atom_clock_dividers dividers;\n\tu32 ibias;\n\tu32 dll_speed;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\n\t\t\t\t\t     memory_clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tibias = rv770_map_clkf_to_ibias(rdev, dividers.whole_fb_div);\n\n\tmpll_ad_func_cntl &= ~(CLKR_MASK |\n\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t       CLKF_MASK |\n\t\t\t       CLKFRAC_MASK |\n\t\t\t       IBIAS_MASK);\n\tmpll_ad_func_cntl |= CLKR(dividers.ref_div);\n\tmpll_ad_func_cntl |= YCLK_POST_DIV(dividers.post_div);\n\tmpll_ad_func_cntl |= CLKF(dividers.whole_fb_div);\n\tmpll_ad_func_cntl |= CLKFRAC(dividers.frac_fb_div);\n\tmpll_ad_func_cntl |= IBIAS(ibias);\n\n\tif (dividers.vco_mode)\n\t\tmpll_ad_func_cntl_2 |= VCO_MODE;\n\telse\n\t\tmpll_ad_func_cntl_2 &= ~VCO_MODE;\n\n\tif (pi->mem_gddr5) {\n\t\tmpll_dq_func_cntl &= ~(CLKR_MASK |\n\t\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t\t       CLKF_MASK |\n\t\t\t\t       CLKFRAC_MASK |\n\t\t\t\t       IBIAS_MASK);\n\t\tmpll_dq_func_cntl |= CLKR(dividers.ref_div);\n\t\tmpll_dq_func_cntl |= YCLK_POST_DIV(dividers.post_div);\n\t\tmpll_dq_func_cntl |= CLKF(dividers.whole_fb_div);\n\t\tmpll_dq_func_cntl |= CLKFRAC(dividers.frac_fb_div);\n\t\tmpll_dq_func_cntl |= IBIAS(ibias);\n\n\t\tif (dividers.vco_mode)\n\t\t\tmpll_dq_func_cntl_2 |= VCO_MODE;\n\t\telse\n\t\t\tmpll_dq_func_cntl_2 &= ~VCO_MODE;\n\t}\n\n\tif (pi->mclk_ss) {\n\t\tstruct radeon_atom_ss ss;\n\t\tu32 vco_freq = memory_clock * dividers.post_div;\n\n\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_MEMORY_SS, vco_freq)) {\n\t\t\tu32 reference_clock = rdev->clock.mpll.reference_freq;\n\t\t\tu32 decoded_ref = rv740_get_decoded_reference_divider(dividers.ref_div);\n\t\t\tu32 clk_s, clk_v;\n\n\t\t\tif (!decoded_ref)\n\t\t\t\treturn -EINVAL;\n\t\t\tclk_s = reference_clock * 5 / (decoded_ref * ss.rate);\n\t\t\tclk_v = 0x40000 * ss.percentage *\n\t\t\t\t(dividers.whole_fb_div + (dividers.frac_fb_div / 8)) / (clk_s * 10000);\n\n\t\t\tmpll_ss1 &= ~CLKV_MASK;\n\t\t\tmpll_ss1 |= CLKV(clk_v);\n\n\t\t\tmpll_ss2 &= ~CLKS_MASK;\n\t\t\tmpll_ss2 |= CLKS(clk_s);\n\t\t}\n\t}\n\n\tdll_speed = rv740_get_dll_speed(pi->mem_gddr5,\n\t\t\t\t\tmemory_clock);\n\n\tmclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;\n\tmclk_pwrmgt_cntl |= DLL_SPEED(dll_speed);\n\n\tmclk->mclk770.mclk_value = cpu_to_be32(memory_clock);\n\tmclk->mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\tmclk->mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\tmclk->mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\tmclk->mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\tmclk->mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\tmclk->mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\tmclk->mclk770.vMPLL_SS = cpu_to_be32(mpll_ss1);\n\tmclk->mclk770.vMPLL_SS2 = cpu_to_be32(mpll_ss2);\n\n\treturn 0;\n}\n\nvoid rv740_read_clock_registers(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tpi->clk_regs.rv770.cg_spll_func_cntl =\n\t\tRREG32(CG_SPLL_FUNC_CNTL);\n\tpi->clk_regs.rv770.cg_spll_func_cntl_2 =\n\t\tRREG32(CG_SPLL_FUNC_CNTL_2);\n\tpi->clk_regs.rv770.cg_spll_func_cntl_3 =\n\t\tRREG32(CG_SPLL_FUNC_CNTL_3);\n\tpi->clk_regs.rv770.cg_spll_spread_spectrum =\n\t\tRREG32(CG_SPLL_SPREAD_SPECTRUM);\n\tpi->clk_regs.rv770.cg_spll_spread_spectrum_2 =\n\t\tRREG32(CG_SPLL_SPREAD_SPECTRUM_2);\n\n\tpi->clk_regs.rv770.mpll_ad_func_cntl =\n\t\tRREG32(MPLL_AD_FUNC_CNTL);\n\tpi->clk_regs.rv770.mpll_ad_func_cntl_2 =\n\t\tRREG32(MPLL_AD_FUNC_CNTL_2);\n\tpi->clk_regs.rv770.mpll_dq_func_cntl =\n\t\tRREG32(MPLL_DQ_FUNC_CNTL);\n\tpi->clk_regs.rv770.mpll_dq_func_cntl_2 =\n\t\tRREG32(MPLL_DQ_FUNC_CNTL_2);\n\tpi->clk_regs.rv770.mclk_pwrmgt_cntl =\n\t\tRREG32(MCLK_PWRMGT_CNTL);\n\tpi->clk_regs.rv770.dll_cntl = RREG32(DLL_CNTL);\n\tpi->clk_regs.rv770.mpll_ss1 = RREG32(MPLL_SS1);\n\tpi->clk_regs.rv770.mpll_ss2 = RREG32(MPLL_SS2);\n}\n\nint rv740_populate_smc_acpi_state(struct radeon_device *rdev,\n\t\t\t\t  RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 mpll_ad_func_cntl = pi->clk_regs.rv770.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 = pi->clk_regs.rv770.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl = pi->clk_regs.rv770.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 = pi->clk_regs.rv770.mpll_dq_func_cntl_2;\n\tu32 spll_func_cntl = pi->clk_regs.rv770.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 = pi->clk_regs.rv770.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 = pi->clk_regs.rv770.cg_spll_func_cntl_3;\n\tu32 mclk_pwrmgt_cntl = pi->clk_regs.rv770.mclk_pwrmgt_cntl;\n\tu32 dll_cntl = pi->clk_regs.rv770.dll_cntl;\n\n\ttable->ACPIState = table->initialState;\n\n\ttable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\tif (pi->acpi_vddc) {\n\t\trv770_populate_vddc_value(rdev, pi->acpi_vddc,\n\t\t\t\t\t  &table->ACPIState.levels[0].vddc);\n\t\ttable->ACPIState.levels[0].gen2PCIE =\n\t\t\tpi->pcie_gen2 ?\n\t\t\tpi->acpi_pcie_gen2 : 0;\n\t\ttable->ACPIState.levels[0].gen2XSP =\n\t\t\tpi->acpi_pcie_gen2;\n\t} else {\n\t\trv770_populate_vddc_value(rdev, pi->min_vddc_in_table,\n\t\t\t\t\t  &table->ACPIState.levels[0].vddc);\n\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t}\n\n\tmpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\n\n\tmpll_dq_func_cntl_2 |= BYPASS | BIAS_GEN_PDNB | RESET_EN;\n\n\tmclk_pwrmgt_cntl |= (MRDCKA0_RESET |\n\t\t\t     MRDCKA1_RESET |\n\t\t\t     MRDCKB0_RESET |\n\t\t\t     MRDCKB1_RESET |\n\t\t\t     MRDCKC0_RESET |\n\t\t\t     MRDCKC1_RESET |\n\t\t\t     MRDCKD0_RESET |\n\t\t\t     MRDCKD1_RESET);\n\n\tdll_cntl |= (MRDCKA0_BYPASS |\n\t\t     MRDCKA1_BYPASS |\n\t\t     MRDCKB0_BYPASS |\n\t\t     MRDCKB1_BYPASS |\n\t\t     MRDCKC0_BYPASS |\n\t\t     MRDCKC1_BYPASS |\n\t\t     MRDCKD0_BYPASS |\n\t\t     MRDCKD1_BYPASS);\n\n\tspll_func_cntl |= SPLL_RESET | SPLL_SLEEP | SPLL_BYPASS_EN;\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(4);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.mclk_value = 0;\n\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\n\n\ttable->ACPIState.levels[0].sclk.sclk_value = 0;\n\n\ttable->ACPIState.levels[1] = table->ACPIState.levels[0];\n\ttable->ACPIState.levels[2] = table->ACPIState.levels[0];\n\n\trv770_populate_mvdd_value(rdev, 0, &table->ACPIState.levels[0].mvdd);\n\n\treturn 0;\n}\n\nvoid rv740_enable_mclk_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t       bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(MPLL_CNTL_MODE, SS_SSEN, ~SS_SSEN);\n\telse\n\t\tWREG32_P(MPLL_CNTL_MODE, 0, ~SS_SSEN);\n}\n\nu8 rv740_get_mclk_frequency_ratio(u32 memory_clock)\n{\n\tu8 mc_para_index;\n\n\tif ((memory_clock < 10000) || (memory_clock > 47500))\n\t\tmc_para_index = 0x00;\n\telse\n\t\tmc_para_index = (u8)((memory_clock - 10000) / 2500);\n\n\treturn mc_para_index;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}