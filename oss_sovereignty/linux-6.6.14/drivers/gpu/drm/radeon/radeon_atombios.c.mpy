{
  "module_name": "radeon_atombios.c",
  "hash_id": "adf65a743bf76d8fa00a334d2f1aa87c7fa6526c753ddd5e869a9b77a59fb84a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_atombios.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include <drm/drm_device.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon.h\"\n\n#include \"atom.h\"\n#include \"atom-bits.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_atombios.h\"\n#include \"radeon_legacy_encoders.h\"\n\nunion atom_supported_devices {\n\tstruct _ATOM_SUPPORTED_DEVICES_INFO info;\n\tstruct _ATOM_SUPPORTED_DEVICES_INFO_2 info_2;\n\tstruct _ATOM_SUPPORTED_DEVICES_INFO_2d1 info_2d1;\n};\n\nstatic void radeon_lookup_i2c_gpio_quirks(struct radeon_device *rdev,\n\t\t\t\t\t  ATOM_GPIO_I2C_ASSIGMENT *gpio,\n\t\t\t\t\t  u8 index)\n{\n\t \n\tif ((rdev->family == CHIP_R420) ||\n\t    (rdev->family == CHIP_R423) ||\n\t    (rdev->family == CHIP_RV410)) {\n\t\tif ((le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x0018) ||\n\t\t    (le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x0019) ||\n\t\t    (le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x001a)) {\n\t\t\tgpio->ucClkMaskShift = 0x19;\n\t\t\tgpio->ucDataMaskShift = 0x18;\n\t\t}\n\t}\n\n\t \n\tif (ASIC_IS_DCE4(rdev)) {\n\t\tif ((index == 7) &&\n\t\t    (le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x1936) &&\n\t\t    (gpio->sucI2cId.ucAccess == 0)) {\n\t\t\tgpio->sucI2cId.ucAccess = 0x97;\n\t\t\tgpio->ucDataMaskShift = 8;\n\t\t\tgpio->ucDataEnShift = 8;\n\t\t\tgpio->ucDataY_Shift = 8;\n\t\t\tgpio->ucDataA_Shift = 8;\n\t\t}\n\t}\n\n\t \n\tif (ASIC_IS_DCE3(rdev)) {\n\t\tif ((index == 4) &&\n\t\t    (le16_to_cpu(gpio->usClkMaskRegisterIndex) == 0x1fda) &&\n\t\t    (gpio->sucI2cId.ucAccess == 0x94))\n\t\t\tgpio->sucI2cId.ucAccess = 0x14;\n\t}\n}\n\nstatic struct radeon_i2c_bus_rec radeon_get_bus_rec_for_i2c_gpio(ATOM_GPIO_I2C_ASSIGMENT *gpio)\n{\n\tstruct radeon_i2c_bus_rec i2c;\n\n\tmemset(&i2c, 0, sizeof(struct radeon_i2c_bus_rec));\n\n\ti2c.mask_clk_reg = le16_to_cpu(gpio->usClkMaskRegisterIndex) * 4;\n\ti2c.mask_data_reg = le16_to_cpu(gpio->usDataMaskRegisterIndex) * 4;\n\ti2c.en_clk_reg = le16_to_cpu(gpio->usClkEnRegisterIndex) * 4;\n\ti2c.en_data_reg = le16_to_cpu(gpio->usDataEnRegisterIndex) * 4;\n\ti2c.y_clk_reg = le16_to_cpu(gpio->usClkY_RegisterIndex) * 4;\n\ti2c.y_data_reg = le16_to_cpu(gpio->usDataY_RegisterIndex) * 4;\n\ti2c.a_clk_reg = le16_to_cpu(gpio->usClkA_RegisterIndex) * 4;\n\ti2c.a_data_reg = le16_to_cpu(gpio->usDataA_RegisterIndex) * 4;\n\ti2c.mask_clk_mask = (1 << gpio->ucClkMaskShift);\n\ti2c.mask_data_mask = (1 << gpio->ucDataMaskShift);\n\ti2c.en_clk_mask = (1 << gpio->ucClkEnShift);\n\ti2c.en_data_mask = (1 << gpio->ucDataEnShift);\n\ti2c.y_clk_mask = (1 << gpio->ucClkY_Shift);\n\ti2c.y_data_mask = (1 << gpio->ucDataY_Shift);\n\ti2c.a_clk_mask = (1 << gpio->ucClkA_Shift);\n\ti2c.a_data_mask = (1 << gpio->ucDataA_Shift);\n\n\tif (gpio->sucI2cId.sbfAccess.bfHW_Capable)\n\t\ti2c.hw_capable = true;\n\telse\n\t\ti2c.hw_capable = false;\n\n\tif (gpio->sucI2cId.ucAccess == 0xa0)\n\t\ti2c.mm_i2c = true;\n\telse\n\t\ti2c.mm_i2c = false;\n\n\ti2c.i2c_id = gpio->sucI2cId.ucAccess;\n\n\tif (i2c.mask_clk_reg)\n\t\ti2c.valid = true;\n\telse\n\t\ti2c.valid = false;\n\n\treturn i2c;\n}\n\nstatic struct radeon_i2c_bus_rec radeon_lookup_i2c_gpio(struct radeon_device *rdev,\n\t\t\t\t\t\t\t       uint8_t id)\n{\n\tstruct atom_context *ctx = rdev->mode_info.atom_context;\n\tATOM_GPIO_I2C_ASSIGMENT *gpio;\n\tstruct radeon_i2c_bus_rec i2c;\n\tint index = GetIndexIntoMasterTable(DATA, GPIO_I2C_Info);\n\tstruct _ATOM_GPIO_I2C_INFO *i2c_info;\n\tuint16_t data_offset, size;\n\tint i, num_indices;\n\n\tmemset(&i2c, 0, sizeof(struct radeon_i2c_bus_rec));\n\ti2c.valid = false;\n\n\tif (atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\n\t\ti2c_info = (struct _ATOM_GPIO_I2C_INFO *)(ctx->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_GPIO_I2C_ASSIGMENT);\n\n\t\tgpio = &i2c_info->asGPIO_Info[0];\n\t\tfor (i = 0; i < num_indices; i++) {\n\n\t\t\tradeon_lookup_i2c_gpio_quirks(rdev, gpio, i);\n\n\t\t\tif (gpio->sucI2cId.ucAccess == id) {\n\t\t\t\ti2c = radeon_get_bus_rec_for_i2c_gpio(gpio);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgpio = (ATOM_GPIO_I2C_ASSIGMENT *)\n\t\t\t\t((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));\n\t\t}\n\t}\n\n\treturn i2c;\n}\n\nvoid radeon_atombios_i2c_init(struct radeon_device *rdev)\n{\n\tstruct atom_context *ctx = rdev->mode_info.atom_context;\n\tATOM_GPIO_I2C_ASSIGMENT *gpio;\n\tstruct radeon_i2c_bus_rec i2c;\n\tint index = GetIndexIntoMasterTable(DATA, GPIO_I2C_Info);\n\tstruct _ATOM_GPIO_I2C_INFO *i2c_info;\n\tuint16_t data_offset, size;\n\tint i, num_indices;\n\tchar stmp[32];\n\n\tif (atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\n\t\ti2c_info = (struct _ATOM_GPIO_I2C_INFO *)(ctx->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_GPIO_I2C_ASSIGMENT);\n\n\t\tgpio = &i2c_info->asGPIO_Info[0];\n\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\tradeon_lookup_i2c_gpio_quirks(rdev, gpio, i);\n\n\t\t\ti2c = radeon_get_bus_rec_for_i2c_gpio(gpio);\n\n\t\t\tif (i2c.valid) {\n\t\t\t\tsprintf(stmp, \"0x%x\", i2c.i2c_id);\n\t\t\t\trdev->i2c_bus[i] = radeon_i2c_create(rdev->ddev, &i2c, stmp);\n\t\t\t}\n\t\t\tgpio = (ATOM_GPIO_I2C_ASSIGMENT *)\n\t\t\t\t((u8 *)gpio + sizeof(ATOM_GPIO_I2C_ASSIGMENT));\n\t\t}\n\t}\n}\n\nstruct radeon_gpio_rec radeon_atombios_lookup_gpio(struct radeon_device *rdev,\n\t\t\t\t\t\t   u8 id)\n{\n\tstruct atom_context *ctx = rdev->mode_info.atom_context;\n\tstruct radeon_gpio_rec gpio;\n\tint index = GetIndexIntoMasterTable(DATA, GPIO_Pin_LUT);\n\tstruct _ATOM_GPIO_PIN_LUT *gpio_info;\n\tATOM_GPIO_PIN_ASSIGNMENT *pin;\n\tu16 data_offset, size;\n\tint i, num_indices;\n\n\tmemset(&gpio, 0, sizeof(struct radeon_gpio_rec));\n\tgpio.valid = false;\n\n\tif (atom_parse_data_header(ctx, index, &size, NULL, NULL, &data_offset)) {\n\t\tgpio_info = (struct _ATOM_GPIO_PIN_LUT *)(ctx->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_GPIO_PIN_ASSIGNMENT);\n\n\t\tpin = gpio_info->asGPIO_Pin;\n\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\tif (id == pin->ucGPIO_ID) {\n\t\t\t\tgpio.id = pin->ucGPIO_ID;\n\t\t\t\tgpio.reg = le16_to_cpu(pin->usGpioPin_AIndex) * 4;\n\t\t\t\tgpio.shift = pin->ucGpioPinBitShift;\n\t\t\t\tgpio.mask = (1 << pin->ucGpioPinBitShift);\n\t\t\t\tgpio.valid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpin = (ATOM_GPIO_PIN_ASSIGNMENT *)\n\t\t\t\t((u8 *)pin + sizeof(ATOM_GPIO_PIN_ASSIGNMENT));\n\t\t}\n\t}\n\n\treturn gpio;\n}\n\nstatic struct radeon_hpd radeon_atom_get_hpd_info_from_gpio(struct radeon_device *rdev,\n\t\t\t\t\t\t\t    struct radeon_gpio_rec *gpio)\n{\n\tstruct radeon_hpd hpd;\n\tu32 reg;\n\n\tmemset(&hpd, 0, sizeof(struct radeon_hpd));\n\n\tif (ASIC_IS_DCE6(rdev))\n\t\treg = SI_DC_GPIO_HPD_A;\n\telse if (ASIC_IS_DCE4(rdev))\n\t\treg = EVERGREEN_DC_GPIO_HPD_A;\n\telse\n\t\treg = AVIVO_DC_GPIO_HPD_A;\n\n\thpd.gpio = *gpio;\n\tif (gpio->reg == reg) {\n\t\tswitch(gpio->mask) {\n\t\tcase (1 << 0):\n\t\t\thpd.hpd = RADEON_HPD_1;\n\t\t\tbreak;\n\t\tcase (1 << 8):\n\t\t\thpd.hpd = RADEON_HPD_2;\n\t\t\tbreak;\n\t\tcase (1 << 16):\n\t\t\thpd.hpd = RADEON_HPD_3;\n\t\t\tbreak;\n\t\tcase (1 << 24):\n\t\t\thpd.hpd = RADEON_HPD_4;\n\t\t\tbreak;\n\t\tcase (1 << 26):\n\t\t\thpd.hpd = RADEON_HPD_5;\n\t\t\tbreak;\n\t\tcase (1 << 28):\n\t\t\thpd.hpd = RADEON_HPD_6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thpd.hpd = RADEON_HPD_NONE;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\thpd.hpd = RADEON_HPD_NONE;\n\treturn hpd;\n}\n\nstatic bool radeon_atom_apply_quirks(struct drm_device *dev,\n\t\t\t\t     uint32_t supported_device,\n\t\t\t\t     int *connector_type,\n\t\t\t\t     struct radeon_i2c_bus_rec *i2c_bus,\n\t\t\t\t     uint16_t *line_mux,\n\t\t\t\t     struct radeon_hpd *hpd)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\t \n\tif ((pdev->device == 0x791e) &&\n\t    (pdev->subsystem_vendor == 0x1043) &&\n\t    (pdev->subsystem_device == 0x826d)) {\n\t\tif ((*connector_type == DRM_MODE_CONNECTOR_HDMIA) &&\n\t\t    (supported_device == ATOM_DEVICE_DFP3_SUPPORT))\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVID;\n\t}\n\n\t \n\tif ((pdev->device == 0x7941) &&\n\t    (pdev->subsystem_vendor == 0x1849) &&\n\t    (pdev->subsystem_device == 0x7941)) {\n\t\tif ((*connector_type == DRM_MODE_CONNECTOR_HDMIA) &&\n\t\t    (supported_device == ATOM_DEVICE_DFP3_SUPPORT))\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVID;\n\t}\n\n\t \n\tif ((pdev->device == 0x796e) &&\n\t    (pdev->subsystem_vendor == 0x1462) &&\n\t    (pdev->subsystem_device == 0x7302)) {\n\t\tif ((supported_device == ATOM_DEVICE_DFP2_SUPPORT) ||\n\t\t    (supported_device == ATOM_DEVICE_DFP3_SUPPORT))\n\t\t\treturn false;\n\t}\n\n\t \n\tif ((pdev->device == 0x7941) &&\n\t    (pdev->subsystem_vendor == 0x147b) &&\n\t    (pdev->subsystem_device == 0x2412)) {\n\t\tif (*connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\t\treturn false;\n\t}\n\n\t \n\tif ((pdev->device == 0x5653) &&\n\t    (pdev->subsystem_vendor == 0x1462) &&\n\t    (pdev->subsystem_device == 0x0291)) {\n\t\tif (*connector_type == DRM_MODE_CONNECTOR_LVDS) {\n\t\t\ti2c_bus->valid = false;\n\t\t\t*line_mux = 53;\n\t\t}\n\t}\n\n\t \n\tif ((pdev->device == 0x7146) &&\n\t    (pdev->subsystem_vendor == 0x17af) &&\n\t    (pdev->subsystem_device == 0x2058)) {\n\t\tif (supported_device == ATOM_DEVICE_DFP1_SUPPORT)\n\t\t\treturn false;\n\t}\n\n\t \n\tif ((pdev->device == 0x7142) &&\n\t    (pdev->subsystem_vendor == 0x1458) &&\n\t    (pdev->subsystem_device == 0x2134)) {\n\t\tif (supported_device == ATOM_DEVICE_DFP1_SUPPORT)\n\t\t\treturn false;\n\t}\n\n\n\t \n\tif ((pdev->device == 0x71C5) &&\n\t    (pdev->subsystem_vendor == 0x106b) &&\n\t    (pdev->subsystem_device == 0x0080)) {\n\t\tif ((supported_device == ATOM_DEVICE_CRT1_SUPPORT) ||\n\t\t    (supported_device == ATOM_DEVICE_DFP2_SUPPORT))\n\t\t\treturn false;\n\t\tif (supported_device == ATOM_DEVICE_CRT2_SUPPORT)\n\t\t\t*line_mux = 0x90;\n\t}\n\n\t \n\tif ((supported_device == ATOM_DEVICE_TV1_SUPPORT) &&\n\t    (*connector_type == DRM_MODE_CONNECTOR_DVII)) {\n\t\t*connector_type = DRM_MODE_CONNECTOR_9PinDIN;\n\t\t*line_mux = CONNECTOR_7PIN_DIN_ENUM_ID1;\n\t}\n\n\t \n\tif ((pdev->device == 0x9598) &&\n\t    (pdev->subsystem_vendor == 0x1043) &&\n\t    (pdev->subsystem_device == 0x01da)) {\n\t\tif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVII;\n\t\t}\n\t}\n\n\t \n\tif ((pdev->device == 0x9598) &&\n\t    (pdev->subsystem_vendor == 0x1043) &&\n\t    (pdev->subsystem_device == 0x01e4)) {\n\t\tif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVII;\n\t\t}\n\t}\n\n\t \n\tif ((pdev->device == 0x95C5) &&\n\t    (pdev->subsystem_vendor == 0x1043) &&\n\t    (pdev->subsystem_device == 0x01e2)) {\n\t\tif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVII;\n\t\t}\n\t}\n\n\t \n\tif (*connector_type == DRM_MODE_CONNECTOR_HDMIA) {\n\t\tif (supported_device & (ATOM_DEVICE_CRT_SUPPORT)) {\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_VGA;\n\t\t\t*line_mux = 0;\n\t\t}\n\t}\n\n\t \n\tif (((pdev->device == 0x95c4) || (pdev->device == 0x9591)) &&\n\t    (pdev->subsystem_vendor == 0x1025) &&\n\t    (pdev->subsystem_device == 0x013c)) {\n\t\tif ((*connector_type == DRM_MODE_CONNECTOR_DVII) &&\n\t\t    (supported_device == ATOM_DEVICE_DFP1_SUPPORT)) {\n\t\t\t \n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVID;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif ((pdev->device == 0x9498) &&\n\t    (pdev->subsystem_vendor == 0x1682) &&\n\t    (pdev->subsystem_device == 0x2452) &&\n\t    (i2c_bus->valid == false) &&\n\t    !(supported_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))) {\n\t\tstruct radeon_device *rdev = dev->dev_private;\n\t\t*i2c_bus = radeon_lookup_i2c_gpio(rdev, 0x93);\n\t}\n\n\t \n\tif (((pdev->device == 0x9802) ||\n\t     (pdev->device == 0x9805) ||\n\t     (pdev->device == 0x9806)) &&\n\t    (pdev->subsystem_vendor == 0x1734) &&\n\t    (pdev->subsystem_device == 0x11bd)) {\n\t\tif (*connector_type == DRM_MODE_CONNECTOR_VGA) {\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVII;\n\t\t\t*line_mux = 0x3103;\n\t\t} else if (*connector_type == DRM_MODE_CONNECTOR_DVID) {\n\t\t\t*connector_type = DRM_MODE_CONNECTOR_DVII;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic const int supported_devices_connector_convert[] = {\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_VGA,\n\tDRM_MODE_CONNECTOR_DVII,\n\tDRM_MODE_CONNECTOR_DVID,\n\tDRM_MODE_CONNECTOR_DVIA,\n\tDRM_MODE_CONNECTOR_SVIDEO,\n\tDRM_MODE_CONNECTOR_Composite,\n\tDRM_MODE_CONNECTOR_LVDS,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_HDMIA,\n\tDRM_MODE_CONNECTOR_HDMIB,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_9PinDIN,\n\tDRM_MODE_CONNECTOR_DisplayPort\n};\n\nstatic const uint16_t supported_devices_connector_object_id_convert[] = {\n\tCONNECTOR_OBJECT_ID_NONE,\n\tCONNECTOR_OBJECT_ID_VGA,\n\tCONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I,  \n\tCONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D,  \n\tCONNECTOR_OBJECT_ID_VGA,  \n\tCONNECTOR_OBJECT_ID_COMPOSITE,\n\tCONNECTOR_OBJECT_ID_SVIDEO,\n\tCONNECTOR_OBJECT_ID_LVDS,\n\tCONNECTOR_OBJECT_ID_9PIN_DIN,\n\tCONNECTOR_OBJECT_ID_9PIN_DIN,\n\tCONNECTOR_OBJECT_ID_DISPLAYPORT,\n\tCONNECTOR_OBJECT_ID_HDMI_TYPE_A,\n\tCONNECTOR_OBJECT_ID_HDMI_TYPE_B,\n\tCONNECTOR_OBJECT_ID_SVIDEO\n};\n\nstatic const int object_connector_convert[] = {\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_DVII,\n\tDRM_MODE_CONNECTOR_DVII,\n\tDRM_MODE_CONNECTOR_DVID,\n\tDRM_MODE_CONNECTOR_DVID,\n\tDRM_MODE_CONNECTOR_VGA,\n\tDRM_MODE_CONNECTOR_Composite,\n\tDRM_MODE_CONNECTOR_SVIDEO,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_9PinDIN,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_HDMIA,\n\tDRM_MODE_CONNECTOR_HDMIB,\n\tDRM_MODE_CONNECTOR_LVDS,\n\tDRM_MODE_CONNECTOR_9PinDIN,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_Unknown,\n\tDRM_MODE_CONNECTOR_DisplayPort,\n\tDRM_MODE_CONNECTOR_eDP,\n\tDRM_MODE_CONNECTOR_Unknown\n};\n\nbool radeon_get_atom_connector_info_from_object_table(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct atom_context *ctx = mode_info->atom_context;\n\tint index = GetIndexIntoMasterTable(DATA, Object_Header);\n\tu16 size, data_offset;\n\tu8 frev, crev;\n\tATOM_CONNECTOR_OBJECT_TABLE *con_obj;\n\tATOM_ENCODER_OBJECT_TABLE *enc_obj;\n\tATOM_OBJECT_TABLE *router_obj;\n\tATOM_DISPLAY_OBJECT_PATH_TABLE *path_obj;\n\tATOM_OBJECT_HEADER *obj_header;\n\tint i, j, k, path_size, device_support;\n\tint connector_type;\n\tu16 igp_lane_info, conn_id, connector_object_id;\n\tstruct radeon_i2c_bus_rec ddc_bus;\n\tstruct radeon_router router;\n\tstruct radeon_gpio_rec gpio;\n\tstruct radeon_hpd hpd;\n\n\tif (!atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tif (crev < 2)\n\t\treturn false;\n\n\tobj_header = (ATOM_OBJECT_HEADER *) (ctx->bios + data_offset);\n\tpath_obj = (ATOM_DISPLAY_OBJECT_PATH_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usDisplayPathTableOffset));\n\tcon_obj = (ATOM_CONNECTOR_OBJECT_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usConnectorObjectTableOffset));\n\tenc_obj = (ATOM_ENCODER_OBJECT_TABLE *)\n\t    (ctx->bios + data_offset +\n\t     le16_to_cpu(obj_header->usEncoderObjectTableOffset));\n\trouter_obj = (ATOM_OBJECT_TABLE *)\n\t\t(ctx->bios + data_offset +\n\t\t le16_to_cpu(obj_header->usRouterObjectTableOffset));\n\tdevice_support = le16_to_cpu(obj_header->usDeviceSupport);\n\n\tpath_size = 0;\n\tfor (i = 0; i < path_obj->ucNumOfDispPath; i++) {\n\t\tuint8_t *addr = (uint8_t *) path_obj->asDispPath;\n\t\tATOM_DISPLAY_OBJECT_PATH *path;\n\t\taddr += path_size;\n\t\tpath = (ATOM_DISPLAY_OBJECT_PATH *) addr;\n\t\tpath_size += le16_to_cpu(path->usSize);\n\n\t\tif (device_support & le16_to_cpu(path->usDeviceTag)) {\n\t\t\tuint8_t con_obj_id, con_obj_num;\n\n\t\t\tcon_obj_id =\n\t\t\t    (le16_to_cpu(path->usConnObjectId) & OBJECT_ID_MASK)\n\t\t\t    >> OBJECT_ID_SHIFT;\n\t\t\tcon_obj_num =\n\t\t\t    (le16_to_cpu(path->usConnObjectId) & ENUM_ID_MASK)\n\t\t\t    >> ENUM_ID_SHIFT;\n\n\t\t\t \n\t\t\tif (le16_to_cpu(path->usDeviceTag) ==\n\t\t\t\tATOM_DEVICE_CV_SUPPORT)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif ((rdev->flags & RADEON_IS_IGP) &&\n\t\t\t    (con_obj_id ==\n\t\t\t     CONNECTOR_OBJECT_ID_PCIE_CONNECTOR)) {\n\t\t\t\tuint16_t igp_offset = 0;\n\t\t\t\tATOM_INTEGRATED_SYSTEM_INFO_V2 *igp_obj;\n\n\t\t\t\tindex =\n\t\t\t\t    GetIndexIntoMasterTable(DATA,\n\t\t\t\t\t\t\t    IntegratedSystemInfo);\n\n\t\t\t\tif (atom_parse_data_header(ctx, index, &size, &frev,\n\t\t\t\t\t\t\t   &crev, &igp_offset)) {\n\n\t\t\t\t\tif (crev >= 2) {\n\t\t\t\t\t\tigp_obj =\n\t\t\t\t\t\t\t(ATOM_INTEGRATED_SYSTEM_INFO_V2\n\t\t\t\t\t\t\t *) (ctx->bios + igp_offset);\n\n\t\t\t\t\t\tif (igp_obj) {\n\t\t\t\t\t\t\tuint32_t slot_config, ct;\n\n\t\t\t\t\t\t\tif (con_obj_num == 1)\n\t\t\t\t\t\t\t\tslot_config =\n\t\t\t\t\t\t\t\t\tigp_obj->\n\t\t\t\t\t\t\t\t\tulDDISlot1Config;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tslot_config =\n\t\t\t\t\t\t\t\t\tigp_obj->\n\t\t\t\t\t\t\t\t\tulDDISlot2Config;\n\n\t\t\t\t\t\t\tct = (slot_config >> 16) & 0xff;\n\t\t\t\t\t\t\tconnector_type =\n\t\t\t\t\t\t\t\tobject_connector_convert\n\t\t\t\t\t\t\t\t[ct];\n\t\t\t\t\t\t\tconnector_object_id = ct;\n\t\t\t\t\t\t\tigp_lane_info =\n\t\t\t\t\t\t\t\tslot_config & 0xffff;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tigp_lane_info = 0;\n\t\t\t\t\tconnector_type =\n\t\t\t\t\t\tobject_connector_convert[con_obj_id];\n\t\t\t\t\tconnector_object_id = con_obj_id;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tigp_lane_info = 0;\n\t\t\t\tconnector_type =\n\t\t\t\t    object_connector_convert[con_obj_id];\n\t\t\t\tconnector_object_id = con_obj_id;\n\t\t\t}\n\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_Unknown)\n\t\t\t\tcontinue;\n\n\t\t\trouter.ddc_valid = false;\n\t\t\trouter.cd_valid = false;\n\t\t\tfor (j = 0; j < ((le16_to_cpu(path->usSize) - 8) / 2); j++) {\n\t\t\t\tuint8_t grph_obj_type =\n\t\t\t\t    (le16_to_cpu(path->usGraphicObjIds[j]) &\n\t\t\t\t     OBJECT_TYPE_MASK) >> OBJECT_TYPE_SHIFT;\n\n\t\t\t\tif (grph_obj_type == GRAPH_OBJECT_TYPE_ENCODER) {\n\t\t\t\t\tfor (k = 0; k < enc_obj->ucNumberOfObjects; k++) {\n\t\t\t\t\t\tu16 encoder_obj = le16_to_cpu(enc_obj->asObjects[k].usObjectID);\n\t\t\t\t\t\tif (le16_to_cpu(path->usGraphicObjIds[j]) == encoder_obj) {\n\t\t\t\t\t\t\tATOM_COMMON_RECORD_HEADER *record = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t(ctx->bios + data_offset +\n\t\t\t\t\t\t\t\t le16_to_cpu(enc_obj->asObjects[k].usRecordOffset));\n\t\t\t\t\t\t\tATOM_ENCODER_CAP_RECORD *cap_record;\n\t\t\t\t\t\t\tu16 caps = 0;\n\n\t\t\t\t\t\t\twhile (record->ucRecordSize > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\n\t\t\t\t\t\t\t\tswitch (record->ucRecordType) {\n\t\t\t\t\t\t\t\tcase ATOM_ENCODER_CAP_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\tcap_record =(ATOM_ENCODER_CAP_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\tcaps = le16_to_cpu(cap_record->usEncoderCap);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trecord = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t\t((char *)record + record->ucRecordSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tradeon_add_atom_encoder(dev,\n\t\t\t\t\t\t\t\t\t\tencoder_obj,\n\t\t\t\t\t\t\t\t\t\tle16_to_cpu\n\t\t\t\t\t\t\t\t\t\t(path->\n\t\t\t\t\t\t\t\t\t\t usDeviceTag),\n\t\t\t\t\t\t\t\t\t\tcaps);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (grph_obj_type == GRAPH_OBJECT_TYPE_ROUTER) {\n\t\t\t\t\tfor (k = 0; k < router_obj->ucNumberOfObjects; k++) {\n\t\t\t\t\t\tu16 router_obj_id = le16_to_cpu(router_obj->asObjects[k].usObjectID);\n\t\t\t\t\t\tif (le16_to_cpu(path->usGraphicObjIds[j]) == router_obj_id) {\n\t\t\t\t\t\t\tATOM_COMMON_RECORD_HEADER *record = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t(ctx->bios + data_offset +\n\t\t\t\t\t\t\t\t le16_to_cpu(router_obj->asObjects[k].usRecordOffset));\n\t\t\t\t\t\t\tATOM_I2C_RECORD *i2c_record;\n\t\t\t\t\t\t\tATOM_I2C_ID_CONFIG_ACCESS *i2c_config;\n\t\t\t\t\t\t\tATOM_ROUTER_DDC_PATH_SELECT_RECORD *ddc_path;\n\t\t\t\t\t\t\tATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD *cd_path;\n\t\t\t\t\t\t\tATOM_SRC_DST_TABLE_FOR_ONE_OBJECT *router_src_dst_table =\n\t\t\t\t\t\t\t\t(ATOM_SRC_DST_TABLE_FOR_ONE_OBJECT *)\n\t\t\t\t\t\t\t\t(ctx->bios + data_offset +\n\t\t\t\t\t\t\t\t le16_to_cpu(router_obj->asObjects[k].usSrcDstTableOffset));\n\t\t\t\t\t\t\tu8 *num_dst_objs = (u8 *)\n\t\t\t\t\t\t\t\t((u8 *)router_src_dst_table + 1 +\n\t\t\t\t\t\t\t\t (router_src_dst_table->ucNumberOfSrc * 2));\n\t\t\t\t\t\t\tu16 *dst_objs = (u16 *)(num_dst_objs + 1);\n\t\t\t\t\t\t\tint enum_id;\n\n\t\t\t\t\t\t\trouter.router_id = router_obj_id;\n\t\t\t\t\t\t\tfor (enum_id = 0; enum_id < (*num_dst_objs); enum_id++) {\n\t\t\t\t\t\t\t\tif (le16_to_cpu(path->usConnObjectId) ==\n\t\t\t\t\t\t\t\t    le16_to_cpu(dst_objs[enum_id]))\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twhile (record->ucRecordSize > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType > 0 &&\n\t\t\t\t\t\t\t       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\n\t\t\t\t\t\t\t\tswitch (record->ucRecordType) {\n\t\t\t\t\t\t\t\tcase ATOM_I2C_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\ti2c_record =\n\t\t\t\t\t\t\t\t\t\t(ATOM_I2C_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\ti2c_config =\n\t\t\t\t\t\t\t\t\t\t(ATOM_I2C_ID_CONFIG_ACCESS *)\n\t\t\t\t\t\t\t\t\t\t&i2c_record->sucI2cId;\n\t\t\t\t\t\t\t\t\trouter.i2c_info =\n\t\t\t\t\t\t\t\t\t\tradeon_lookup_i2c_gpio(rdev,\n\t\t\t\t\t\t\t\t\t\t\t\t       i2c_config->\n\t\t\t\t\t\t\t\t\t\t\t\t       ucAccess);\n\t\t\t\t\t\t\t\t\trouter.i2c_addr = i2c_record->ucI2CAddr >> 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase ATOM_ROUTER_DDC_PATH_SELECT_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\tddc_path = (ATOM_ROUTER_DDC_PATH_SELECT_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\trouter.ddc_valid = true;\n\t\t\t\t\t\t\t\t\trouter.ddc_mux_type = ddc_path->ucMuxType;\n\t\t\t\t\t\t\t\t\trouter.ddc_mux_control_pin = ddc_path->ucMuxControlPin;\n\t\t\t\t\t\t\t\t\trouter.ddc_mux_state = ddc_path->ucMuxState[enum_id];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD_TYPE:\n\t\t\t\t\t\t\t\t\tcd_path = (ATOM_ROUTER_DATA_CLOCK_PATH_SELECT_RECORD *)\n\t\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\t\trouter.cd_valid = true;\n\t\t\t\t\t\t\t\t\trouter.cd_mux_type = cd_path->ucMuxType;\n\t\t\t\t\t\t\t\t\trouter.cd_mux_control_pin = cd_path->ucMuxControlPin;\n\t\t\t\t\t\t\t\t\trouter.cd_mux_state = cd_path->ucMuxState[enum_id];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trecord = (ATOM_COMMON_RECORD_HEADER *)\n\t\t\t\t\t\t\t\t\t((char *)record + record->ucRecordSize);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tddc_bus.valid = false;\n\t\t\thpd.hpd = RADEON_HPD_NONE;\n\t\t\tif ((le16_to_cpu(path->usDeviceTag) &\n\t\t\t     (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) == 0) {\n\t\t\t\tfor (j = 0; j < con_obj->ucNumberOfObjects; j++) {\n\t\t\t\t\tif (le16_to_cpu(path->usConnObjectId) ==\n\t\t\t\t\t    le16_to_cpu(con_obj->asObjects[j].\n\t\t\t\t\t\t\tusObjectID)) {\n\t\t\t\t\t\tATOM_COMMON_RECORD_HEADER\n\t\t\t\t\t\t    *record =\n\t\t\t\t\t\t    (ATOM_COMMON_RECORD_HEADER\n\t\t\t\t\t\t     *)\n\t\t\t\t\t\t    (ctx->bios + data_offset +\n\t\t\t\t\t\t     le16_to_cpu(con_obj->\n\t\t\t\t\t\t\t\t asObjects[j].\n\t\t\t\t\t\t\t\t usRecordOffset));\n\t\t\t\t\t\tATOM_I2C_RECORD *i2c_record;\n\t\t\t\t\t\tATOM_HPD_INT_RECORD *hpd_record;\n\t\t\t\t\t\tATOM_I2C_ID_CONFIG_ACCESS *i2c_config;\n\n\t\t\t\t\t\twhile (record->ucRecordSize > 0 &&\n\t\t\t\t\t\t       record->ucRecordType > 0 &&\n\t\t\t\t\t\t       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {\n\t\t\t\t\t\t\tswitch (record->ucRecordType) {\n\t\t\t\t\t\t\tcase ATOM_I2C_RECORD_TYPE:\n\t\t\t\t\t\t\t\ti2c_record =\n\t\t\t\t\t\t\t\t    (ATOM_I2C_RECORD *)\n\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\ti2c_config =\n\t\t\t\t\t\t\t\t\t(ATOM_I2C_ID_CONFIG_ACCESS *)\n\t\t\t\t\t\t\t\t\t&i2c_record->sucI2cId;\n\t\t\t\t\t\t\t\tddc_bus = radeon_lookup_i2c_gpio(rdev,\n\t\t\t\t\t\t\t\t\t\t\t\t i2c_config->\n\t\t\t\t\t\t\t\t\t\t\t\t ucAccess);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ATOM_HPD_INT_RECORD_TYPE:\n\t\t\t\t\t\t\t\thpd_record =\n\t\t\t\t\t\t\t\t\t(ATOM_HPD_INT_RECORD *)\n\t\t\t\t\t\t\t\t\trecord;\n\t\t\t\t\t\t\t\tgpio = radeon_atombios_lookup_gpio(rdev,\n\t\t\t\t\t\t\t\t\t\t\t  hpd_record->ucHPDIntGPIOID);\n\t\t\t\t\t\t\t\thpd = radeon_atom_get_hpd_info_from_gpio(rdev, &gpio);\n\t\t\t\t\t\t\t\thpd.plugged_state = hpd_record->ucPlugged_PinState;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trecord =\n\t\t\t\t\t\t\t    (ATOM_COMMON_RECORD_HEADER\n\t\t\t\t\t\t\t     *) ((char *)record\n\t\t\t\t\t\t\t\t +\n\t\t\t\t\t\t\t\t record->\n\t\t\t\t\t\t\t\t ucRecordSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tddc_bus.hpd = hpd.hpd;\n\n\t\t\tconn_id = le16_to_cpu(path->usConnObjectId);\n\n\t\t\tif (!radeon_atom_apply_quirks\n\t\t\t    (dev, le16_to_cpu(path->usDeviceTag), &connector_type,\n\t\t\t     &ddc_bus, &conn_id, &hpd))\n\t\t\t\tcontinue;\n\n\t\t\tradeon_add_atom_connector(dev,\n\t\t\t\t\t\t  conn_id,\n\t\t\t\t\t\t  le16_to_cpu(path->\n\t\t\t\t\t\t\t      usDeviceTag),\n\t\t\t\t\t\t  connector_type, &ddc_bus,\n\t\t\t\t\t\t  igp_lane_info,\n\t\t\t\t\t\t  connector_object_id,\n\t\t\t\t\t\t  &hpd,\n\t\t\t\t\t\t  &router);\n\n\t\t}\n\t}\n\n\tradeon_link_encoder_connector(dev);\n\treturn true;\n}\n\nstatic uint16_t atombios_get_connector_object_id(struct drm_device *dev,\n\t\t\t\t\t\t int connector_type,\n\t\t\t\t\t\t uint16_t devices)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\treturn supported_devices_connector_object_id_convert\n\t\t\t[connector_type];\n\t} else if (((connector_type == DRM_MODE_CONNECTOR_DVII) ||\n\t\t    (connector_type == DRM_MODE_CONNECTOR_DVID)) &&\n\t\t   (devices & ATOM_DEVICE_DFP2_SUPPORT))  {\n\t\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\t\tstruct atom_context *ctx = mode_info->atom_context;\n\t\tint index = GetIndexIntoMasterTable(DATA, XTMDS_Info);\n\t\tuint16_t size, data_offset;\n\t\tuint8_t frev, crev;\n\t\tATOM_XTMDS_INFO *xtmds;\n\n\t\tif (atom_parse_data_header(ctx, index, &size, &frev, &crev, &data_offset)) {\n\t\t\txtmds = (ATOM_XTMDS_INFO *)(ctx->bios + data_offset);\n\n\t\t\tif (xtmds->ucSupportedLink & ATOM_XTMDS_SUPPORTED_DUALLINK) {\n\t\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\t\t\t\treturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I;\n\t\t\t\telse\n\t\t\t\t\treturn CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D;\n\t\t\t} else {\n\t\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\t\t\t\treturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_I;\n\t\t\t\telse\n\t\t\t\t\treturn CONNECTOR_OBJECT_ID_SINGLE_LINK_DVI_D;\n\t\t\t}\n\t\t} else\n\t\t\treturn supported_devices_connector_object_id_convert\n\t\t\t\t[connector_type];\n\t} else {\n\t\treturn supported_devices_connector_object_id_convert\n\t\t\t[connector_type];\n\t}\n}\n\nstruct bios_connector {\n\tbool valid;\n\tuint16_t line_mux;\n\tuint16_t devices;\n\tint connector_type;\n\tstruct radeon_i2c_bus_rec ddc_bus;\n\tstruct radeon_hpd hpd;\n};\n\nbool radeon_get_atom_connector_info_from_supported_devices_table(struct\n\t\t\t\t\t\t\t\t drm_device\n\t\t\t\t\t\t\t\t *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct atom_context *ctx = mode_info->atom_context;\n\tint index = GetIndexIntoMasterTable(DATA, SupportedDevicesInfo);\n\tuint16_t size, data_offset;\n\tuint8_t frev, crev;\n\tuint16_t device_support;\n\tuint8_t dac;\n\tunion atom_supported_devices *supported_devices;\n\tint i, j, max_device;\n\tstruct bios_connector *bios_connectors;\n\tsize_t bc_size = sizeof(*bios_connectors) * ATOM_MAX_SUPPORTED_DEVICE;\n\tstruct radeon_router router;\n\n\trouter.ddc_valid = false;\n\trouter.cd_valid = false;\n\n\tbios_connectors = kzalloc(bc_size, GFP_KERNEL);\n\tif (!bios_connectors)\n\t\treturn false;\n\n\tif (!atom_parse_data_header(ctx, index, &size, &frev, &crev,\n\t\t\t\t    &data_offset)) {\n\t\tkfree(bios_connectors);\n\t\treturn false;\n\t}\n\n\tsupported_devices =\n\t    (union atom_supported_devices *)(ctx->bios + data_offset);\n\n\tdevice_support = le16_to_cpu(supported_devices->info.usDeviceSupport);\n\n\tif (frev > 1)\n\t\tmax_device = ATOM_MAX_SUPPORTED_DEVICE;\n\telse\n\t\tmax_device = ATOM_MAX_SUPPORTED_DEVICE_INFO;\n\n\tfor (i = 0; i < max_device; i++) {\n\t\tATOM_CONNECTOR_INFO_I2C ci =\n\t\t    supported_devices->info.asConnInfo[i];\n\n\t\tbios_connectors[i].valid = false;\n\n\t\tif (!(device_support & (1 << i))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == ATOM_DEVICE_CV_INDEX) {\n\t\t\tDRM_DEBUG_KMS(\"Skipping Component Video\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tbios_connectors[i].connector_type =\n\t\t    supported_devices_connector_convert[ci.sucConnectorInfo.\n\t\t\t\t\t\t\tsbfAccess.\n\t\t\t\t\t\t\tbfConnectorType];\n\n\t\tif (bios_connectors[i].connector_type ==\n\t\t    DRM_MODE_CONNECTOR_Unknown)\n\t\t\tcontinue;\n\n\t\tdac = ci.sucConnectorInfo.sbfAccess.bfAssociatedDAC;\n\n\t\tbios_connectors[i].line_mux =\n\t\t\tci.sucI2cId.ucAccess;\n\n\t\t \n\t\tif (i == ATOM_DEVICE_TV1_INDEX) {\n\t\t\tbios_connectors[i].ddc_bus.valid = false;\n\t\t\tbios_connectors[i].line_mux = 50;\n\t\t} else if (i == ATOM_DEVICE_TV2_INDEX) {\n\t\t\tbios_connectors[i].ddc_bus.valid = false;\n\t\t\tbios_connectors[i].line_mux = 51;\n\t\t} else if (i == ATOM_DEVICE_CV_INDEX) {\n\t\t\tbios_connectors[i].ddc_bus.valid = false;\n\t\t\tbios_connectors[i].line_mux = 52;\n\t\t} else\n\t\t\tbios_connectors[i].ddc_bus =\n\t\t\t    radeon_lookup_i2c_gpio(rdev,\n\t\t\t\t\t\t   bios_connectors[i].line_mux);\n\n\t\tif ((crev > 1) && (frev > 1)) {\n\t\t\tu8 isb = supported_devices->info_2d1.asIntSrcInfo[i].ucIntSrcBitmap;\n\t\t\tswitch (isb) {\n\t\t\tcase 0x4:\n\t\t\t\tbios_connectors[i].hpd.hpd = RADEON_HPD_1;\n\t\t\t\tbreak;\n\t\t\tcase 0xa:\n\t\t\t\tbios_connectors[i].hpd.hpd = RADEON_HPD_2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbios_connectors[i].hpd.hpd = RADEON_HPD_NONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (i == ATOM_DEVICE_DFP1_INDEX)\n\t\t\t\tbios_connectors[i].hpd.hpd = RADEON_HPD_1;\n\t\t\telse if (i == ATOM_DEVICE_DFP2_INDEX)\n\t\t\t\tbios_connectors[i].hpd.hpd = RADEON_HPD_2;\n\t\t\telse\n\t\t\t\tbios_connectors[i].hpd.hpd = RADEON_HPD_NONE;\n\t\t}\n\n\t\t \n\t\tif (i == ATOM_DEVICE_CRT1_INDEX || i == ATOM_DEVICE_CRT2_INDEX)\n\t\t\tbios_connectors[i].connector_type =\n\t\t\t    DRM_MODE_CONNECTOR_VGA;\n\n\t\tif (!radeon_atom_apply_quirks\n\t\t    (dev, (1 << i), &bios_connectors[i].connector_type,\n\t\t     &bios_connectors[i].ddc_bus, &bios_connectors[i].line_mux,\n\t\t     &bios_connectors[i].hpd))\n\t\t\tcontinue;\n\n\t\tbios_connectors[i].valid = true;\n\t\tbios_connectors[i].devices = (1 << i);\n\n\t\tif (ASIC_IS_AVIVO(rdev) || radeon_r4xx_atom)\n\t\t\tradeon_add_atom_encoder(dev,\n\t\t\t\t\t\tradeon_get_encoder_enum(dev,\n\t\t\t\t\t\t\t\t      (1 << i),\n\t\t\t\t\t\t\t\t      dac),\n\t\t\t\t\t\t(1 << i),\n\t\t\t\t\t\t0);\n\t\telse\n\t\t\tradeon_add_legacy_encoder(dev,\n\t\t\t\t\t\t  radeon_get_encoder_enum(dev,\n\t\t\t\t\t\t\t\t\t(1 << i),\n\t\t\t\t\t\t\t\t\tdac),\n\t\t\t\t\t\t  (1 << i));\n\t}\n\n\t \n\tfor (i = 0; i < max_device; i++) {\n\t\tif (bios_connectors[i].valid) {\n\t\t\tfor (j = 0; j < max_device; j++) {\n\t\t\t\tif (bios_connectors[j].valid && (i != j)) {\n\t\t\t\t\tif (bios_connectors[i].line_mux ==\n\t\t\t\t\t    bios_connectors[j].line_mux) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (bios_connectors[i].devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\t\t\t\t\tbios_connectors[i].line_mux = 53;\n\t\t\t\t\t\t\tbios_connectors[i].ddc_bus.valid = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (bios_connectors[j].devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\t\t\t\t\tbios_connectors[j].line_mux = 53;\n\t\t\t\t\t\t\tbios_connectors[j].ddc_bus.valid = false;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (((bios_connectors[i].devices & (ATOM_DEVICE_DFP_SUPPORT)) &&\n\t\t\t\t\t\t     (bios_connectors[j].devices & (ATOM_DEVICE_CRT_SUPPORT))) ||\n\t\t\t\t\t\t    ((bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT)) &&\n\t\t\t\t\t\t     (bios_connectors[i].devices & (ATOM_DEVICE_CRT_SUPPORT)))) {\n\t\t\t\t\t\t\tbios_connectors[i].devices |=\n\t\t\t\t\t\t\t\tbios_connectors[j].devices;\n\t\t\t\t\t\t\tbios_connectors[i].connector_type =\n\t\t\t\t\t\t\t\tDRM_MODE_CONNECTOR_DVII;\n\t\t\t\t\t\t\tif (bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT))\n\t\t\t\t\t\t\t\tbios_connectors[i].hpd =\n\t\t\t\t\t\t\t\t\tbios_connectors[j].hpd;\n\t\t\t\t\t\t\tbios_connectors[j].valid = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < max_device; i++) {\n\t\tif (bios_connectors[i].valid) {\n\t\t\tuint16_t connector_object_id =\n\t\t\t\tatombios_get_connector_object_id(dev,\n\t\t\t\t\t\t      bios_connectors[i].connector_type,\n\t\t\t\t\t\t      bios_connectors[i].devices);\n\t\t\tradeon_add_atom_connector(dev,\n\t\t\t\t\t\t  bios_connectors[i].line_mux,\n\t\t\t\t\t\t  bios_connectors[i].devices,\n\t\t\t\t\t\t  bios_connectors[i].\n\t\t\t\t\t\t  connector_type,\n\t\t\t\t\t\t  &bios_connectors[i].ddc_bus,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  connector_object_id,\n\t\t\t\t\t\t  &bios_connectors[i].hpd,\n\t\t\t\t\t\t  &router);\n\t\t}\n\t}\n\n\tradeon_link_encoder_connector(dev);\n\n\tkfree(bios_connectors);\n\treturn true;\n}\n\nunion firmware_info {\n\tATOM_FIRMWARE_INFO info;\n\tATOM_FIRMWARE_INFO_V1_2 info_12;\n\tATOM_FIRMWARE_INFO_V1_3 info_13;\n\tATOM_FIRMWARE_INFO_V1_4 info_14;\n\tATOM_FIRMWARE_INFO_V2_1 info_21;\n\tATOM_FIRMWARE_INFO_V2_2 info_22;\n};\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V6 info_6;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_7 info_7;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_8 info_8;\n};\n\nstatic void radeon_atombios_get_dentist_vco_freq(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 data_offset;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t&frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)(mode_info->atom_context->bios +\n\t\t\tdata_offset);\n\t\trdev->clock.vco_freq =\n\t\t\tle32_to_cpu(igp_info->info_6.ulDentistVCOFreq);\n\t}\n}\n\nbool radeon_atom_get_clock_info(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\n\tunion firmware_info *firmware_info;\n\tuint8_t frev, crev;\n\tstruct radeon_pll *p1pll = &rdev->clock.p1pll;\n\tstruct radeon_pll *p2pll = &rdev->clock.p2pll;\n\tstruct radeon_pll *dcpll = &rdev->clock.dcpll;\n\tstruct radeon_pll *spll = &rdev->clock.spll;\n\tstruct radeon_pll *mpll = &rdev->clock.mpll;\n\tuint16_t data_offset;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tfirmware_info =\n\t\t\t(union firmware_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t\tdata_offset);\n\t\t \n\t\tp1pll->reference_freq =\n\t\t    le16_to_cpu(firmware_info->info.usReferenceClock);\n\t\tp1pll->reference_div = 0;\n\n\t\tif ((frev < 2) && (crev < 2))\n\t\t\tp1pll->pll_out_min =\n\t\t\t\tle16_to_cpu(firmware_info->info.usMinPixelClockPLL_Output);\n\t\telse\n\t\t\tp1pll->pll_out_min =\n\t\t\t\tle32_to_cpu(firmware_info->info_12.ulMinPixelClockPLL_Output);\n\t\tp1pll->pll_out_max =\n\t\t    le32_to_cpu(firmware_info->info.ulMaxPixelClockPLL_Output);\n\n\t\tif (((frev < 2) && (crev >= 4)) || (frev >= 2)) {\n\t\t\tp1pll->lcd_pll_out_min =\n\t\t\t\tle16_to_cpu(firmware_info->info_14.usLcdMinPixelClockPLL_Output) * 100;\n\t\t\tif (p1pll->lcd_pll_out_min == 0)\n\t\t\t\tp1pll->lcd_pll_out_min = p1pll->pll_out_min;\n\t\t\tp1pll->lcd_pll_out_max =\n\t\t\t\tle16_to_cpu(firmware_info->info_14.usLcdMaxPixelClockPLL_Output) * 100;\n\t\t\tif (p1pll->lcd_pll_out_max == 0)\n\t\t\t\tp1pll->lcd_pll_out_max = p1pll->pll_out_max;\n\t\t} else {\n\t\t\tp1pll->lcd_pll_out_min = p1pll->pll_out_min;\n\t\t\tp1pll->lcd_pll_out_max = p1pll->pll_out_max;\n\t\t}\n\n\t\tif (p1pll->pll_out_min == 0) {\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tp1pll->pll_out_min = 64800;\n\t\t\telse\n\t\t\t\tp1pll->pll_out_min = 20000;\n\t\t}\n\n\t\tp1pll->pll_in_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinPixelClockPLL_Input);\n\t\tp1pll->pll_in_max =\n\t\t    le16_to_cpu(firmware_info->info.usMaxPixelClockPLL_Input);\n\n\t\t*p2pll = *p1pll;\n\n\t\t \n\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\tspll->reference_freq =\n\t\t\t\tle16_to_cpu(firmware_info->info_21.usCoreReferenceClock);\n\t\telse\n\t\t\tspll->reference_freq =\n\t\t\t\tle16_to_cpu(firmware_info->info.usReferenceClock);\n\t\tspll->reference_div = 0;\n\n\t\tspll->pll_out_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinEngineClockPLL_Output);\n\t\tspll->pll_out_max =\n\t\t    le32_to_cpu(firmware_info->info.ulMaxEngineClockPLL_Output);\n\n\t\t \n\t\tif (spll->pll_out_min == 0) {\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tspll->pll_out_min = 64800;\n\t\t\telse\n\t\t\t\tspll->pll_out_min = 20000;\n\t\t}\n\n\t\tspll->pll_in_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinEngineClockPLL_Input);\n\t\tspll->pll_in_max =\n\t\t    le16_to_cpu(firmware_info->info.usMaxEngineClockPLL_Input);\n\n\t\t \n\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\tmpll->reference_freq =\n\t\t\t\tle16_to_cpu(firmware_info->info_21.usMemoryReferenceClock);\n\t\telse\n\t\t\tmpll->reference_freq =\n\t\t\t\tle16_to_cpu(firmware_info->info.usReferenceClock);\n\t\tmpll->reference_div = 0;\n\n\t\tmpll->pll_out_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinMemoryClockPLL_Output);\n\t\tmpll->pll_out_max =\n\t\t    le32_to_cpu(firmware_info->info.ulMaxMemoryClockPLL_Output);\n\n\t\t \n\t\tif (mpll->pll_out_min == 0) {\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tmpll->pll_out_min = 64800;\n\t\t\telse\n\t\t\t\tmpll->pll_out_min = 20000;\n\t\t}\n\n\t\tmpll->pll_in_min =\n\t\t    le16_to_cpu(firmware_info->info.usMinMemoryClockPLL_Input);\n\t\tmpll->pll_in_max =\n\t\t    le16_to_cpu(firmware_info->info.usMaxMemoryClockPLL_Input);\n\n\t\trdev->clock.default_sclk =\n\t\t    le32_to_cpu(firmware_info->info.ulDefaultEngineClock);\n\t\trdev->clock.default_mclk =\n\t\t    le32_to_cpu(firmware_info->info.ulDefaultMemoryClock);\n\n\t\tif (ASIC_IS_DCE4(rdev)) {\n\t\t\trdev->clock.default_dispclk =\n\t\t\t\tle32_to_cpu(firmware_info->info_21.ulDefaultDispEngineClkFreq);\n\t\t\tif (rdev->clock.default_dispclk == 0) {\n\t\t\t\tif (ASIC_IS_DCE6(rdev))\n\t\t\t\t\trdev->clock.default_dispclk = 60000;  \n\t\t\t\telse if (ASIC_IS_DCE5(rdev))\n\t\t\t\t\trdev->clock.default_dispclk = 54000;  \n\t\t\t\telse\n\t\t\t\t\trdev->clock.default_dispclk = 60000;  \n\t\t\t}\n\t\t\t \n\t\t\tif (ASIC_IS_DCE6(rdev) && (rdev->clock.default_dispclk < 53900)) {\n\t\t\t\tDRM_INFO(\"Changing default dispclk from %dMhz to 600Mhz\\n\",\n\t\t\t\t\t rdev->clock.default_dispclk / 100);\n\t\t\t\trdev->clock.default_dispclk = 60000;\n\t\t\t}\n\t\t\trdev->clock.dp_extclk =\n\t\t\t\tle16_to_cpu(firmware_info->info_21.usUniphyDPModeExtClkFreq);\n\t\t\trdev->clock.current_dispclk = rdev->clock.default_dispclk;\n\t\t}\n\t\t*dcpll = *p1pll;\n\n\t\trdev->clock.max_pixel_clock = le16_to_cpu(firmware_info->info.usMaxPixelClock);\n\t\tif (rdev->clock.max_pixel_clock == 0)\n\t\t\trdev->clock.max_pixel_clock = 40000;\n\n\t\t \n\t\trdev->mode_info.firmware_flags =\n\t\t\tle16_to_cpu(firmware_info->info.usFirmwareCapability.susAccess);\n\n\t\tif (ASIC_IS_DCE8(rdev))\n\t\t\trdev->clock.vco_freq =\n\t\t\t\tle32_to_cpu(firmware_info->info_22.ulGPUPLL_OutputFreq);\n\t\telse if (ASIC_IS_DCE5(rdev))\n\t\t\trdev->clock.vco_freq = rdev->clock.current_dispclk;\n\t\telse if (ASIC_IS_DCE41(rdev))\n\t\t\tradeon_atombios_get_dentist_vco_freq(rdev);\n\t\telse\n\t\t\trdev->clock.vco_freq = rdev->clock.current_dispclk;\n\n\t\tif (rdev->clock.vco_freq == 0)\n\t\t\trdev->clock.vco_freq = 360000;\t \n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool radeon_atombios_sideport_present(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 data_offset;\n\n\t \n\tif (rdev->family == CHIP_RS600)\n\t\treturn false;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)(mode_info->atom_context->bios +\n\t\t\t\t      data_offset);\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tif (le32_to_cpu(igp_info->info.ulBootUpMemoryClock))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (le32_to_cpu(igp_info->info_2.ulBootUpSidePortClock))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool radeon_atombios_get_tmds_info(struct radeon_encoder *encoder,\n\t\t\t\t   struct radeon_encoder_int_tmds *tmds)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, TMDS_Info);\n\tuint16_t data_offset;\n\tstruct _ATOM_TMDS_INFO *tmds_info;\n\tuint8_t frev, crev;\n\tuint16_t maxfreq;\n\tint i;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\ttmds_info =\n\t\t\t(struct _ATOM_TMDS_INFO *)(mode_info->atom_context->bios +\n\t\t\t\t\t\t   data_offset);\n\n\t\tmaxfreq = le16_to_cpu(tmds_info->usMaxFrequency);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\ttmds->tmds_pll[i].freq =\n\t\t\t    le16_to_cpu(tmds_info->asMiscInfo[i].usFrequency);\n\t\t\ttmds->tmds_pll[i].value =\n\t\t\t    tmds_info->asMiscInfo[i].ucPLL_ChargePump & 0x3f;\n\t\t\ttmds->tmds_pll[i].value |=\n\t\t\t    (tmds_info->asMiscInfo[i].\n\t\t\t     ucPLL_VCO_Gain & 0x3f) << 6;\n\t\t\ttmds->tmds_pll[i].value |=\n\t\t\t    (tmds_info->asMiscInfo[i].\n\t\t\t     ucPLL_DutyCycle & 0xf) << 12;\n\t\t\ttmds->tmds_pll[i].value |=\n\t\t\t    (tmds_info->asMiscInfo[i].\n\t\t\t     ucPLL_VoltageSwing & 0xf) << 16;\n\n\t\t\tDRM_DEBUG_KMS(\"TMDS PLL From ATOMBIOS %u %x\\n\",\n\t\t\t\t  tmds->tmds_pll[i].freq,\n\t\t\t\t  tmds->tmds_pll[i].value);\n\n\t\t\tif (maxfreq == tmds->tmds_pll[i].freq) {\n\t\t\t\ttmds->tmds_pll[i].freq = 0xffffffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool radeon_atombios_get_ppll_ss_info(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_atom_ss *ss,\n\t\t\t\t      int id)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, PPLL_SS_Info);\n\tuint16_t data_offset, size;\n\tstruct _ATOM_SPREAD_SPECTRUM_INFO *ss_info;\n\tstruct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT *ss_assign;\n\tuint8_t frev, crev;\n\tint i, num_indices;\n\n\tmemset(ss, 0, sizeof(struct radeon_atom_ss));\n\tif (atom_parse_data_header(mode_info->atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tss_info =\n\t\t\t(struct _ATOM_SPREAD_SPECTRUM_INFO *)(mode_info->atom_context->bios + data_offset);\n\n\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\tsizeof(ATOM_SPREAD_SPECTRUM_ASSIGNMENT);\n\t\tss_assign = (struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT *)\n\t\t\t((u8 *)&ss_info->asSS_Info[0]);\n\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\tif (ss_assign->ucSS_Id == id) {\n\t\t\t\tss->percentage =\n\t\t\t\t\tle16_to_cpu(ss_assign->usSpreadSpectrumPercentage);\n\t\t\t\tss->type = ss_assign->ucSpreadSpectrumType;\n\t\t\t\tss->step = ss_assign->ucSS_Step;\n\t\t\t\tss->delay = ss_assign->ucSS_Delay;\n\t\t\t\tss->range = ss_assign->ucSS_Range;\n\t\t\t\tss->refdiv = ss_assign->ucRecommendedRef_Div;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tss_assign = (struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT *)\n\t\t\t\t((u8 *)ss_assign + sizeof(struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT));\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void radeon_atombios_get_igp_ss_overrides(struct radeon_device *rdev,\n\t\t\t\t\t\t struct radeon_atom_ss *ss,\n\t\t\t\t\t\t int id)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tu16 data_offset, size;\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 percentage = 0, rate = 0;\n\n\t \n\tif (atom_parse_data_header(mode_info->atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\t\tswitch (crev) {\n\t\tcase 6:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_6.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_6.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_6.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_6.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_6.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_6.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_7.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_7.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_7.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_7.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_7.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_7.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tswitch (id) {\n\t\t\tcase ASIC_INTERNAL_SS_ON_TMDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_8.usDVISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_8.usDVISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_HDMI:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_8.usHDMISSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_8.usHDMISSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\tcase ASIC_INTERNAL_SS_ON_LVDS:\n\t\t\t\tpercentage = le16_to_cpu(igp_info->info_8.usLvdsSSPercentage);\n\t\t\t\trate = le16_to_cpu(igp_info->info_8.usLvdsSSpreadRateIn10Hz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t\tif (percentage)\n\t\t\tss->percentage = percentage;\n\t\tif (rate)\n\t\t\tss->rate = rate;\n\t}\n}\n\nunion asic_ss_info {\n\tstruct _ATOM_ASIC_INTERNAL_SS_INFO info;\n\tstruct _ATOM_ASIC_INTERNAL_SS_INFO_V2 info_2;\n\tstruct _ATOM_ASIC_INTERNAL_SS_INFO_V3 info_3;\n};\n\nunion asic_ss_assignment {\n\tstruct _ATOM_ASIC_SS_ASSIGNMENT v1;\n\tstruct _ATOM_ASIC_SS_ASSIGNMENT_V2 v2;\n\tstruct _ATOM_ASIC_SS_ASSIGNMENT_V3 v3;\n};\n\nbool radeon_atombios_get_asic_ss_info(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_atom_ss *ss,\n\t\t\t\t      int id, u32 clock)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, ASIC_InternalSS_Info);\n\tuint16_t data_offset, size;\n\tunion asic_ss_info *ss_info;\n\tunion asic_ss_assignment *ss_assign;\n\tuint8_t frev, crev;\n\tint i, num_indices;\n\n\tif (id == ASIC_INTERNAL_MEMORY_SS) {\n\t\tif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_MEMORY_CLOCK_SS_SUPPORT))\n\t\t\treturn false;\n\t}\n\tif (id == ASIC_INTERNAL_ENGINE_SS) {\n\t\tif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_ENGINE_CLOCK_SS_SUPPORT))\n\t\t\treturn false;\n\t}\n\n\tmemset(ss, 0, sizeof(struct radeon_atom_ss));\n\tif (atom_parse_data_header(mode_info->atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\n\t\tss_info =\n\t\t\t(union asic_ss_info *)(mode_info->atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT);\n\n\t\t\tss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info.asSpreadSpectrum[0]);\n\t\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\t\tif ((ss_assign->v1.ucClockIndication == id) &&\n\t\t\t\t    (clock <= le32_to_cpu(ss_assign->v1.ulTargetClockRange))) {\n\t\t\t\t\tss->percentage =\n\t\t\t\t\t\tle16_to_cpu(ss_assign->v1.usSpreadSpectrumPercentage);\n\t\t\t\t\tss->type = ss_assign->v1.ucSpreadSpectrumMode;\n\t\t\t\t\tss->rate = le16_to_cpu(ss_assign->v1.usSpreadRateInKhz);\n\t\t\t\t\tss->percentage_divider = 100;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tss_assign = (union asic_ss_assignment *)\n\t\t\t\t\t((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT_V2);\n\t\t\tss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info_2.asSpreadSpectrum[0]);\n\t\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\t\tif ((ss_assign->v2.ucClockIndication == id) &&\n\t\t\t\t    (clock <= le32_to_cpu(ss_assign->v2.ulTargetClockRange))) {\n\t\t\t\t\tss->percentage =\n\t\t\t\t\t\tle16_to_cpu(ss_assign->v2.usSpreadSpectrumPercentage);\n\t\t\t\t\tss->type = ss_assign->v2.ucSpreadSpectrumMode;\n\t\t\t\t\tss->rate = le16_to_cpu(ss_assign->v2.usSpreadRateIn10Hz);\n\t\t\t\t\tss->percentage_divider = 100;\n\t\t\t\t\tif ((crev == 2) &&\n\t\t\t\t\t    ((id == ASIC_INTERNAL_ENGINE_SS) ||\n\t\t\t\t\t     (id == ASIC_INTERNAL_MEMORY_SS)))\n\t\t\t\t\t\tss->rate /= 100;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tss_assign = (union asic_ss_assignment *)\n\t\t\t\t\t((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT_V2));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tnum_indices = (size - sizeof(ATOM_COMMON_TABLE_HEADER)) /\n\t\t\t\tsizeof(ATOM_ASIC_SS_ASSIGNMENT_V3);\n\t\t\tss_assign = (union asic_ss_assignment *)((u8 *)&ss_info->info_3.asSpreadSpectrum[0]);\n\t\t\tfor (i = 0; i < num_indices; i++) {\n\t\t\t\tif ((ss_assign->v3.ucClockIndication == id) &&\n\t\t\t\t    (clock <= le32_to_cpu(ss_assign->v3.ulTargetClockRange))) {\n\t\t\t\t\tss->percentage =\n\t\t\t\t\t\tle16_to_cpu(ss_assign->v3.usSpreadSpectrumPercentage);\n\t\t\t\t\tss->type = ss_assign->v3.ucSpreadSpectrumMode;\n\t\t\t\t\tss->rate = le16_to_cpu(ss_assign->v3.usSpreadRateIn10Hz);\n\t\t\t\t\tif (ss_assign->v3.ucSpreadSpectrumMode &\n\t\t\t\t\t    SS_MODE_V3_PERCENTAGE_DIV_BY_1000_MASK)\n\t\t\t\t\t\tss->percentage_divider = 1000;\n\t\t\t\t\telse\n\t\t\t\t\t\tss->percentage_divider = 100;\n\t\t\t\t\tif ((id == ASIC_INTERNAL_ENGINE_SS) ||\n\t\t\t\t\t    (id == ASIC_INTERNAL_MEMORY_SS))\n\t\t\t\t\t\tss->rate /= 100;\n\t\t\t\t\tif (rdev->flags & RADEON_IS_IGP)\n\t\t\t\t\t\tradeon_atombios_get_igp_ss_overrides(rdev, ss, id);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tss_assign = (union asic_ss_assignment *)\n\t\t\t\t\t((u8 *)ss_assign + sizeof(ATOM_ASIC_SS_ASSIGNMENT_V3));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unsupported ASIC_InternalSS_Info table: %d %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nunion lvds_info {\n\tstruct _ATOM_LVDS_INFO info;\n\tstruct _ATOM_LVDS_INFO_V12 info_12;\n};\n\nstruct radeon_encoder_atom_dig *radeon_atombios_get_lvds_info(struct\n\t\t\t\t\t\t\t      radeon_encoder\n\t\t\t\t\t\t\t      *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, LVDS_Info);\n\tuint16_t data_offset, misc;\n\tunion lvds_info *lvds_info;\n\tuint8_t frev, crev;\n\tstruct radeon_encoder_atom_dig *lvds = NULL;\n\tint encoder_enum = (encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tlvds_info =\n\t\t\t(union lvds_info *)(mode_info->atom_context->bios + data_offset);\n\t\tlvds =\n\t\t    kzalloc(sizeof(struct radeon_encoder_atom_dig), GFP_KERNEL);\n\n\t\tif (!lvds)\n\t\t\treturn NULL;\n\n\t\tlvds->native_mode.clock =\n\t\t    le16_to_cpu(lvds_info->info.sLCDTiming.usPixClk) * 10;\n\t\tlvds->native_mode.hdisplay =\n\t\t    le16_to_cpu(lvds_info->info.sLCDTiming.usHActive);\n\t\tlvds->native_mode.vdisplay =\n\t\t    le16_to_cpu(lvds_info->info.sLCDTiming.usVActive);\n\t\tlvds->native_mode.htotal = lvds->native_mode.hdisplay +\n\t\t\tle16_to_cpu(lvds_info->info.sLCDTiming.usHBlanking_Time);\n\t\tlvds->native_mode.hsync_start = lvds->native_mode.hdisplay +\n\t\t\tle16_to_cpu(lvds_info->info.sLCDTiming.usHSyncOffset);\n\t\tlvds->native_mode.hsync_end = lvds->native_mode.hsync_start +\n\t\t\tle16_to_cpu(lvds_info->info.sLCDTiming.usHSyncWidth);\n\t\tlvds->native_mode.vtotal = lvds->native_mode.vdisplay +\n\t\t\tle16_to_cpu(lvds_info->info.sLCDTiming.usVBlanking_Time);\n\t\tlvds->native_mode.vsync_start = lvds->native_mode.vdisplay +\n\t\t\tle16_to_cpu(lvds_info->info.sLCDTiming.usVSyncOffset);\n\t\tlvds->native_mode.vsync_end = lvds->native_mode.vsync_start +\n\t\t\tle16_to_cpu(lvds_info->info.sLCDTiming.usVSyncWidth);\n\t\tlvds->panel_pwr_delay =\n\t\t    le16_to_cpu(lvds_info->info.usOffDelayInMs);\n\t\tlvds->lcd_misc = lvds_info->info.ucLVDS_Misc;\n\n\t\tmisc = le16_to_cpu(lvds_info->info.sLCDTiming.susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tlvds->native_mode.flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tlvds->native_mode.width_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageHSize);\n\t\tlvds->native_mode.height_mm = le16_to_cpu(lvds_info->info.sLCDTiming.usImageVSize);\n\n\t\t \n\t\tdrm_mode_set_crtcinfo(&lvds->native_mode, CRTC_INTERLACE_HALVE_V);\n\n\t\tlvds->lcd_ss_id = lvds_info->info.ucSS_Id;\n\n\t\tencoder->native_mode = lvds->native_mode;\n\n\t\tif (encoder_enum == 2)\n\t\t\tlvds->linkb = true;\n\t\telse\n\t\t\tlvds->linkb = false;\n\n\t\t \n\t\tif (le16_to_cpu(lvds_info->info.usModePatchTableOffset)) {\n\t\t\tATOM_FAKE_EDID_PATCH_RECORD *fake_edid_record;\n\t\t\tATOM_PANEL_RESOLUTION_PATCH_RECORD *panel_res_record;\n\t\t\tbool bad_record = false;\n\t\t\tu8 *record;\n\n\t\t\tif ((frev == 1) && (crev < 2))\n\t\t\t\t \n\t\t\t\trecord = (u8 *)(mode_info->atom_context->bios +\n\t\t\t\t\t\tle16_to_cpu(lvds_info->info.usModePatchTableOffset));\n\t\t\telse\n\t\t\t\t \n\t\t\t\trecord = (u8 *)(mode_info->atom_context->bios +\n\t\t\t\t\t\tdata_offset +\n\t\t\t\t\t\tle16_to_cpu(lvds_info->info.usModePatchTableOffset));\n\t\t\twhile (*record != ATOM_RECORD_END_TYPE) {\n\t\t\t\tswitch (*record) {\n\t\t\t\tcase LCD_MODE_PATCH_RECORD_MODE_TYPE:\n\t\t\t\t\trecord += sizeof(ATOM_PATCH_RECORD_MODE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LCD_RTS_RECORD_TYPE:\n\t\t\t\t\trecord += sizeof(ATOM_LCD_RTS_RECORD);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LCD_CAP_RECORD_TYPE:\n\t\t\t\t\trecord += sizeof(ATOM_LCD_MODE_CONTROL_CAP);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LCD_FAKE_EDID_PATCH_RECORD_TYPE:\n\t\t\t\t\tfake_edid_record = (ATOM_FAKE_EDID_PATCH_RECORD *)record;\n\t\t\t\t\tif (fake_edid_record->ucFakeEDIDLength) {\n\t\t\t\t\t\tstruct edid *edid;\n\t\t\t\t\t\tint edid_size =\n\t\t\t\t\t\t\tmax((int)EDID_LENGTH, (int)fake_edid_record->ucFakeEDIDLength);\n\t\t\t\t\t\tedid = kmalloc(edid_size, GFP_KERNEL);\n\t\t\t\t\t\tif (edid) {\n\t\t\t\t\t\t\tmemcpy((u8 *)edid, (u8 *)&fake_edid_record->ucFakeEDIDString[0],\n\t\t\t\t\t\t\t       fake_edid_record->ucFakeEDIDLength);\n\n\t\t\t\t\t\t\tif (drm_edid_is_valid(edid)) {\n\t\t\t\t\t\t\t\trdev->mode_info.bios_hardcoded_edid = edid;\n\t\t\t\t\t\t\t\trdev->mode_info.bios_hardcoded_edid_size = edid_size;\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tkfree(edid);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trecord += fake_edid_record->ucFakeEDIDLength ?\n\t\t\t\t\t\t  struct_size(fake_edid_record,\n\t\t\t\t\t\t\t      ucFakeEDIDString,\n\t\t\t\t\t\t\t      fake_edid_record->ucFakeEDIDLength) :\n\t\t\t\t\t\t   \n\t\t\t\t\t\t  sizeof(ATOM_FAKE_EDID_PATCH_RECORD) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LCD_PANEL_RESOLUTION_RECORD_TYPE:\n\t\t\t\t\tpanel_res_record = (ATOM_PANEL_RESOLUTION_PATCH_RECORD *)record;\n\t\t\t\t\tlvds->native_mode.width_mm = panel_res_record->usHSize;\n\t\t\t\t\tlvds->native_mode.height_mm = panel_res_record->usVSize;\n\t\t\t\t\trecord += sizeof(ATOM_PANEL_RESOLUTION_PATCH_RECORD);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tDRM_ERROR(\"Bad LCD record %d\\n\", *record);\n\t\t\t\t\tbad_record = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (bad_record)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn lvds;\n}\n\nstruct radeon_encoder_primary_dac *\nradeon_atombios_get_primary_dac_info(struct radeon_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, CompassionateData);\n\tuint16_t data_offset;\n\tstruct _COMPASSIONATE_DATA *dac_info;\n\tuint8_t frev, crev;\n\tuint8_t bg, dac;\n\tstruct radeon_encoder_primary_dac *p_dac = NULL;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tdac_info = (struct _COMPASSIONATE_DATA *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\n\t\tp_dac = kzalloc(sizeof(struct radeon_encoder_primary_dac), GFP_KERNEL);\n\n\t\tif (!p_dac)\n\t\t\treturn NULL;\n\n\t\tbg = dac_info->ucDAC1_BG_Adjustment;\n\t\tdac = dac_info->ucDAC1_DAC_Adjustment;\n\t\tp_dac->ps2_pdac_adj = (bg << 8) | (dac);\n\n\t}\n\treturn p_dac;\n}\n\nbool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tATOM_ANALOG_TV_INFO *tv_info;\n\tATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;\n\tATOM_DTD_FORMAT *dtd_timings;\n\tint data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tu8 frev, crev;\n\tu16 data_offset, misc;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn false;\n\n\tswitch (crev) {\n\tcase 1:\n\t\ttv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING)\n\t\t\treturn false;\n\n\t\tmode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);\n\t\tmode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);\n\t\tmode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);\n\t\tmode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);\n\t\tmode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);\n\t\tmode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);\n\t\tmode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->crtc_clock = mode->clock =\n\t\t\tle16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;\n\n\t\tif (index == 1) {\n\t\t\t \n\t\t\tmode->crtc_htotal -= 1;\n\t\t\tmode->crtc_vtotal -= 1;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\ttv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);\n\t\tif (index >= MAX_SUPPORTED_TV_TIMING_V1_2)\n\t\t\treturn false;\n\n\t\tdtd_timings = &tv_info_v1_2->aModeTimings[index];\n\t\tmode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHBlanking_Time);\n\t\tmode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);\n\t\tmode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncOffset);\n\t\tmode->crtc_hsync_end = mode->crtc_hsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usHSyncWidth);\n\n\t\tmode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVBlanking_Time);\n\t\tmode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);\n\t\tmode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncOffset);\n\t\tmode->crtc_vsync_end = mode->crtc_vsync_start +\n\t\t\tle16_to_cpu(dtd_timings->usVSyncWidth);\n\n\t\tmode->flags = 0;\n\t\tmisc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);\n\t\tif (misc & ATOM_VSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NVSYNC;\n\t\tif (misc & ATOM_HSYNC_POLARITY)\n\t\t\tmode->flags |= DRM_MODE_FLAG_NHSYNC;\n\t\tif (misc & ATOM_COMPOSITESYNC)\n\t\t\tmode->flags |= DRM_MODE_FLAG_CSYNC;\n\t\tif (misc & ATOM_INTERLACE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_INTERLACE;\n\t\tif (misc & ATOM_DOUBLE_CLOCK_MODE)\n\t\t\tmode->flags |= DRM_MODE_FLAG_DBLSCAN;\n\n\t\tmode->crtc_clock = mode->clock =\n\t\t\tle16_to_cpu(dtd_timings->usPixClk) * 10;\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nenum radeon_tv_std\nradeon_atombios_get_tv_info(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);\n\tuint16_t data_offset;\n\tuint8_t frev, crev;\n\tstruct _ATOM_ANALOG_TV_INFO *tv_info;\n\tenum radeon_tv_std tv_std = TV_STD_NTSC;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\n\t\ttv_info = (struct _ATOM_ANALOG_TV_INFO *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\n\t\tswitch (tv_info->ucTV_BootUpDefaultStandard) {\n\t\tcase ATOM_TV_NTSC:\n\t\t\ttv_std = TV_STD_NTSC;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: NTSC\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_NTSCJ:\n\t\t\ttv_std = TV_STD_NTSC_J;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: NTSC-J\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_PAL:\n\t\t\ttv_std = TV_STD_PAL;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: PAL\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_PALM:\n\t\t\ttv_std = TV_STD_PAL_M;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: PAL-M\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_PALN:\n\t\t\ttv_std = TV_STD_PAL_N;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: PAL-N\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_PALCN:\n\t\t\ttv_std = TV_STD_PAL_CN;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: PAL-CN\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_PAL60:\n\t\t\ttv_std = TV_STD_PAL_60;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: PAL-60\\n\");\n\t\t\tbreak;\n\t\tcase ATOM_TV_SECAM:\n\t\t\ttv_std = TV_STD_SECAM;\n\t\t\tDRM_DEBUG_KMS(\"Default TV standard: SECAM\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttv_std = TV_STD_NTSC;\n\t\t\tDRM_DEBUG_KMS(\"Unknown TV standard; defaulting to NTSC\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn tv_std;\n}\n\nstruct radeon_encoder_tv_dac *\nradeon_atombios_get_tv_dac_info(struct radeon_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, CompassionateData);\n\tuint16_t data_offset;\n\tstruct _COMPASSIONATE_DATA *dac_info;\n\tuint8_t frev, crev;\n\tuint8_t bg, dac;\n\tstruct radeon_encoder_tv_dac *tv_dac = NULL;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\n\t\tdac_info = (struct _COMPASSIONATE_DATA *)\n\t\t\t(mode_info->atom_context->bios + data_offset);\n\n\t\ttv_dac = kzalloc(sizeof(struct radeon_encoder_tv_dac), GFP_KERNEL);\n\n\t\tif (!tv_dac)\n\t\t\treturn NULL;\n\n\t\tbg = dac_info->ucDAC2_CRT2_BG_Adjustment;\n\t\tdac = dac_info->ucDAC2_CRT2_DAC_Adjustment;\n\t\ttv_dac->ps2_tvdac_adj = (bg << 16) | (dac << 20);\n\n\t\tbg = dac_info->ucDAC2_PAL_BG_Adjustment;\n\t\tdac = dac_info->ucDAC2_PAL_DAC_Adjustment;\n\t\ttv_dac->pal_tvdac_adj = (bg << 16) | (dac << 20);\n\n\t\tbg = dac_info->ucDAC2_NTSC_BG_Adjustment;\n\t\tdac = dac_info->ucDAC2_NTSC_DAC_Adjustment;\n\t\ttv_dac->ntsc_tvdac_adj = (bg << 16) | (dac << 20);\n\n\t\ttv_dac->tv_std = radeon_atombios_get_tv_info(rdev);\n\t}\n\treturn tv_dac;\n}\n\nstatic const char *thermal_controller_names[] = {\n\t\"NONE\",\n\t\"lm63\",\n\t\"adm1032\",\n\t\"adm1030\",\n\t\"max6649\",\n\t\"lm63\",  \n\t\"f75375\",\n\t\"asc7xxx\",\n};\n\nstatic const char *pp_lib_thermal_controller_names[] = {\n\t\"NONE\",\n\t\"lm63\",\n\t\"adm1032\",\n\t\"adm1030\",\n\t\"max6649\",\n\t\"lm63\",  \n\t\"f75375\",\n\t\"RV6xx\",\n\t\"RV770\",\n\t\"adt7473\",\n\t\"NONE\",\n\t\"External GPIO\",\n\t\"Evergreen\",\n\t\"emc2103\",\n\t\"Sumo\",\n\t\"Northern Islands\",\n\t\"Southern Islands\",\n\t\"lm96163\",\n\t\"Sea Islands\",\n};\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n\tstruct _ATOM_PPLIB_SI_CLOCK_INFO si;\n\tstruct _ATOM_PPLIB_CI_CLOCK_INFO ci;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void radeon_atombios_parse_misc_flags_1_3(struct radeon_device *rdev,\n\t\t\t\t\t\t int state_index,\n\t\t\t\t\t\t u32 misc, u32 misc2)\n{\n\trdev->pm.power_state[state_index].misc = misc;\n\trdev->pm.power_state[state_index].misc2 = misc2;\n\t \n\tif (misc & ATOM_PM_MISCINFO_POWER_SAVING_MODE)\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_POWERSAVE;\n\tif (misc & ATOM_PM_MISCINFO_DEFAULT_DC_STATE_ENTRY_TRUE)\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_BATTERY;\n\tif (misc & ATOM_PM_MISCINFO_DEFAULT_LOW_DC_STATE_ENTRY_TRUE)\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_BATTERY;\n\tif (misc & ATOM_PM_MISCINFO_LOAD_BALANCE_EN)\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_BALANCED;\n\tif (misc & ATOM_PM_MISCINFO_3D_ACCELERATION_EN) {\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_PERFORMANCE;\n\t\trdev->pm.power_state[state_index].flags &=\n\t\t\t~RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\n\t}\n\tif (misc2 & ATOM_PM_MISCINFO2_SYSTEM_AC_LITE_MODE)\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_BALANCED;\n\tif (misc & ATOM_PM_MISCINFO_DRIVER_DEFAULT_MODE) {\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_DEFAULT;\n\t\trdev->pm.default_power_state_index = state_index;\n\t\trdev->pm.power_state[state_index].default_clock_mode =\n\t\t\t&rdev->pm.power_state[state_index].clock_info[0];\n\t} else if (state_index == 0) {\n\t\trdev->pm.power_state[state_index].clock_info[0].flags |=\n\t\t\tRADEON_PM_MODE_NO_DISPLAY;\n\t}\n}\n\nstatic int radeon_atombios_parse_power_table_1_3(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tu32 misc, misc2 = 0;\n\tint num_modes = 0, i;\n\tint state_index = 0;\n\tstruct radeon_i2c_bus_rec i2c_bus;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn state_index;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\t \n\tif ((power_info->info.ucOverdriveThermalController > 0) &&\n\t    (power_info->info.ucOverdriveThermalController < ARRAY_SIZE(thermal_controller_names))) {\n\t\tDRM_INFO(\"Possible %s thermal controller at 0x%02x\\n\",\n\t\t\t thermal_controller_names[power_info->info.ucOverdriveThermalController],\n\t\t\t power_info->info.ucOverdriveControllerAddress >> 1);\n\t\ti2c_bus = radeon_lookup_i2c_gpio(rdev, power_info->info.ucOverdriveI2cLine);\n\t\trdev->pm.i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\n\t\tif (rdev->pm.i2c_bus) {\n\t\t\tstruct i2c_board_info info = { };\n\t\t\tconst char *name = thermal_controller_names[power_info->info.\n\t\t\t\t\t\t\t\t    ucOverdriveThermalController];\n\t\t\tinfo.addr = power_info->info.ucOverdriveControllerAddress >> 1;\n\t\t\tstrscpy(info.type, name, sizeof(info.type));\n\t\t\ti2c_new_client_device(&rdev->pm.i2c_bus->adapter, &info);\n\t\t}\n\t}\n\tnum_modes = power_info->info.ucNumOfPowerModeEntries;\n\tif (num_modes > ATOM_MAX_NUMBEROF_POWER_BLOCK)\n\t\tnum_modes = ATOM_MAX_NUMBEROF_POWER_BLOCK;\n\tif (num_modes == 0)\n\t\treturn state_index;\n\trdev->pm.power_state = kcalloc(num_modes,\n\t\t\t\t       sizeof(struct radeon_power_state),\n\t\t\t\t       GFP_KERNEL);\n\tif (!rdev->pm.power_state)\n\t\treturn state_index;\n\t \n\tfor (i = 0; i < num_modes; i++) {\n\t\t \n\t\tif (!rdev->pm.power_state[state_index].clock_info) {\n\t\t\trdev->pm.power_state[state_index].clock_info =\n\t\t\t\tkzalloc(sizeof(struct radeon_pm_clock_info),\n\t\t\t\t\tGFP_KERNEL);\n\t\t}\n\t\tif (!rdev->pm.power_state[state_index].clock_info)\n\t\t\tgoto out;\n\t\trdev->pm.power_state[state_index].num_clock_modes = 1;\n\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_NONE;\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\trdev->pm.power_state[state_index].clock_info[0].mclk =\n\t\t\t\tle16_to_cpu(power_info->info.asPowerPlayInfo[i].usMemoryClock);\n\t\t\trdev->pm.power_state[state_index].clock_info[0].sclk =\n\t\t\t\tle16_to_cpu(power_info->info.asPowerPlayInfo[i].usEngineClock);\n\t\t\t \n\t\t\tif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\n\t\t\t    (rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\n\t\t\t\tcontinue;\n\t\t\trdev->pm.power_state[state_index].pcie_lanes =\n\t\t\t\tpower_info->info.asPowerPlayInfo[i].ucNumPciELanes;\n\t\t\tmisc = le32_to_cpu(power_info->info.asPowerPlayInfo[i].ulMiscInfo);\n\t\t\tif ((misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) ||\n\t\t\t    (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type =\n\t\t\t\t\tVOLTAGE_GPIO;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.gpio =\n\t\t\t\t\tradeon_atombios_lookup_gpio(rdev,\n\t\t\t\t\t\t\t   power_info->info.asPowerPlayInfo[i].ucVoltageDropIndex);\n\t\t\t\tif (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\n\t\t\t\t\t\ttrue;\n\t\t\t\telse\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\n\t\t\t\t\t\tfalse;\n\t\t\t} else if (misc & ATOM_PM_MISCINFO_PROGRAM_VOLTAGE) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type =\n\t\t\t\t\tVOLTAGE_VDDC;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.vddc_id =\n\t\t\t\t\tpower_info->info.asPowerPlayInfo[i].ucVoltageDropIndex;\n\t\t\t}\n\t\t\trdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\n\t\t\tradeon_atombios_parse_misc_flags_1_3(rdev, state_index, misc, 0);\n\t\t\tstate_index++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trdev->pm.power_state[state_index].clock_info[0].mclk =\n\t\t\t\tle32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulMemoryClock);\n\t\t\trdev->pm.power_state[state_index].clock_info[0].sclk =\n\t\t\t\tle32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulEngineClock);\n\t\t\t \n\t\t\tif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\n\t\t\t    (rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\n\t\t\t\tcontinue;\n\t\t\trdev->pm.power_state[state_index].pcie_lanes =\n\t\t\t\tpower_info->info_2.asPowerPlayInfo[i].ucNumPciELanes;\n\t\t\tmisc = le32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulMiscInfo);\n\t\t\tmisc2 = le32_to_cpu(power_info->info_2.asPowerPlayInfo[i].ulMiscInfo2);\n\t\t\tif ((misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) ||\n\t\t\t    (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type =\n\t\t\t\t\tVOLTAGE_GPIO;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.gpio =\n\t\t\t\t\tradeon_atombios_lookup_gpio(rdev,\n\t\t\t\t\t\t\t   power_info->info_2.asPowerPlayInfo[i].ucVoltageDropIndex);\n\t\t\t\tif (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\n\t\t\t\t\t\ttrue;\n\t\t\t\telse\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\n\t\t\t\t\t\tfalse;\n\t\t\t} else if (misc & ATOM_PM_MISCINFO_PROGRAM_VOLTAGE) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type =\n\t\t\t\t\tVOLTAGE_VDDC;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.vddc_id =\n\t\t\t\t\tpower_info->info_2.asPowerPlayInfo[i].ucVoltageDropIndex;\n\t\t\t}\n\t\t\trdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\n\t\t\tradeon_atombios_parse_misc_flags_1_3(rdev, state_index, misc, misc2);\n\t\t\tstate_index++;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\trdev->pm.power_state[state_index].clock_info[0].mclk =\n\t\t\t\tle32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulMemoryClock);\n\t\t\trdev->pm.power_state[state_index].clock_info[0].sclk =\n\t\t\t\tle32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulEngineClock);\n\t\t\t \n\t\t\tif ((rdev->pm.power_state[state_index].clock_info[0].mclk == 0) ||\n\t\t\t    (rdev->pm.power_state[state_index].clock_info[0].sclk == 0))\n\t\t\t\tcontinue;\n\t\t\trdev->pm.power_state[state_index].pcie_lanes =\n\t\t\t\tpower_info->info_3.asPowerPlayInfo[i].ucNumPciELanes;\n\t\t\tmisc = le32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulMiscInfo);\n\t\t\tmisc2 = le32_to_cpu(power_info->info_3.asPowerPlayInfo[i].ulMiscInfo2);\n\t\t\tif ((misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) ||\n\t\t\t    (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type =\n\t\t\t\t\tVOLTAGE_GPIO;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.gpio =\n\t\t\t\t\tradeon_atombios_lookup_gpio(rdev,\n\t\t\t\t\t\t\t   power_info->info_3.asPowerPlayInfo[i].ucVoltageDropIndex);\n\t\t\t\tif (misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_ACTIVE_HIGH)\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\n\t\t\t\t\t\ttrue;\n\t\t\t\telse\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.active_high =\n\t\t\t\t\t\tfalse;\n\t\t\t} else if (misc & ATOM_PM_MISCINFO_PROGRAM_VOLTAGE) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type =\n\t\t\t\t\tVOLTAGE_VDDC;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.vddc_id =\n\t\t\t\t\tpower_info->info_3.asPowerPlayInfo[i].ucVoltageDropIndex;\n\t\t\t\tif (misc2 & ATOM_PM_MISCINFO2_VDDCI_DYNAMIC_VOLTAGE_EN) {\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.vddci_enabled =\n\t\t\t\t\t\ttrue;\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.vddci_id =\n\t\t\t\t\t\tpower_info->info_3.asPowerPlayInfo[i].ucVDDCI_VoltageDropIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\trdev->pm.power_state[state_index].flags = RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\n\t\t\tradeon_atombios_parse_misc_flags_1_3(rdev, state_index, misc, misc2);\n\t\t\tstate_index++;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\t \n\tif (state_index && state_index < num_modes) {\n\t\tkfree(rdev->pm.power_state[state_index].clock_info);\n\t\trdev->pm.power_state[state_index].clock_info = NULL;\n\t}\n\n\t \n\tif (state_index && rdev->pm.default_power_state_index == -1) {\n\t\trdev->pm.power_state[state_index - 1].type =\n\t\t\tPOWER_STATE_TYPE_DEFAULT;\n\t\trdev->pm.default_power_state_index = state_index - 1;\n\t\trdev->pm.power_state[state_index - 1].default_clock_mode =\n\t\t\t&rdev->pm.power_state[state_index - 1].clock_info[0];\n\t\trdev->pm.power_state[state_index - 1].flags &=\n\t\t\t~RADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\n\t\trdev->pm.power_state[state_index - 1].misc = 0;\n\t\trdev->pm.power_state[state_index - 1].misc2 = 0;\n\t}\n\treturn state_index;\n}\n\nstatic void radeon_atombios_add_pplib_thermal_controller(struct radeon_device *rdev,\n\t\t\t\t\t\t\t ATOM_PPLIB_THERMALCONTROLLER *controller)\n{\n\tstruct radeon_i2c_bus_rec i2c_bus;\n\n\t \n\tif (controller->ucType > 0) {\n\t\tif (controller->ucFanParameters & ATOM_PP_FANPARAMETERS_NOFAN)\n\t\t\trdev->pm.no_fan = true;\n\t\trdev->pm.fan_pulses_per_revolution =\n\t\t\tcontroller->ucFanParameters & ATOM_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\t\tif (rdev->pm.fan_pulses_per_revolution) {\n\t\t\trdev->pm.fan_min_rpm = controller->ucFanMinRPM;\n\t\t\trdev->pm.fan_max_rpm = controller->ucFanMaxRPM;\n\t\t}\n\t\tif (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV6xx) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_RV6XX;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV770) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_RV770;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_EVERGREEN) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_EVERGREEN;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SUMO) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_SUMO;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_NISLANDS) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_NI;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SISLANDS) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_SI;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_CISLANDS) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_CI;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_KAVERI) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_KV;\n\t\t} else if (controller->ucType ==\n\t\t\t   ATOM_PP_THERMALCONTROLLER_EXTERNAL_GPIO) {\n\t\t\tDRM_INFO(\"External GPIO thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_EXTERNAL_GPIO;\n\t\t} else if (controller->ucType ==\n\t\t\t   ATOM_PP_THERMALCONTROLLER_ADT7473_WITH_INTERNAL) {\n\t\t\tDRM_INFO(\"ADT7473 with internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_ADT7473_WITH_INTERNAL;\n\t\t} else if (controller->ucType ==\n\t\t\t   ATOM_PP_THERMALCONTROLLER_EMC2103_WITH_INTERNAL) {\n\t\t\tDRM_INFO(\"EMC2103 with internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_EMC2103_WITH_INTERNAL;\n\t\t} else if (controller->ucType < ARRAY_SIZE(pp_lib_thermal_controller_names)) {\n\t\t\tDRM_INFO(\"Possible %s thermal controller at 0x%02x %s fan control\\n\",\n\t\t\t\t pp_lib_thermal_controller_names[controller->ucType],\n\t\t\t\t controller->ucI2cAddress >> 1,\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\trdev->pm.int_thermal_type = THERMAL_TYPE_EXTERNAL;\n\t\t\ti2c_bus = radeon_lookup_i2c_gpio(rdev, controller->ucI2cLine);\n\t\t\trdev->pm.i2c_bus = radeon_i2c_lookup(rdev, &i2c_bus);\n\t\t\tif (rdev->pm.i2c_bus) {\n\t\t\t\tstruct i2c_board_info info = { };\n\t\t\t\tconst char *name = pp_lib_thermal_controller_names[controller->ucType];\n\t\t\t\tinfo.addr = controller->ucI2cAddress >> 1;\n\t\t\t\tstrscpy(info.type, name, sizeof(info.type));\n\t\t\t\ti2c_new_client_device(&rdev->pm.i2c_bus->adapter, &info);\n\t\t\t}\n\t\t} else {\n\t\t\tDRM_INFO(\"Unknown thermal controller type %d at 0x%02x %s fan control\\n\",\n\t\t\t\t controller->ucType,\n\t\t\t\t controller->ucI2cAddress >> 1,\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t}\n\t}\n}\n\nvoid radeon_atombios_get_default_voltages(struct radeon_device *rdev,\n\t\t\t\t\t  u16 *vddc, u16 *vddci, u16 *mvdd)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, FirmwareInfo);\n\tu8 frev, crev;\n\tu16 data_offset;\n\tunion firmware_info *firmware_info;\n\n\t*vddc = 0;\n\t*vddci = 0;\n\t*mvdd = 0;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tfirmware_info =\n\t\t\t(union firmware_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t\tdata_offset);\n\t\t*vddc = le16_to_cpu(firmware_info->info_14.usBootUpVDDCVoltage);\n\t\tif ((frev == 2) && (crev >= 2)) {\n\t\t\t*vddci = le16_to_cpu(firmware_info->info_22.usBootUpVDDCIVoltage);\n\t\t\t*mvdd = le16_to_cpu(firmware_info->info_22.usBootUpMVDDCVoltage);\n\t\t}\n\t}\n}\n\nstatic void radeon_atombios_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t\t       int state_index, int mode_index,\n\t\t\t\t\t\t       struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info)\n{\n\tint j;\n\tu32 misc = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\tu32 misc2 = le16_to_cpu(non_clock_info->usClassification);\n\tu16 vddc, vddci, mvdd;\n\n\tradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\n\n\trdev->pm.power_state[state_index].misc = misc;\n\trdev->pm.power_state[state_index].misc2 = misc2;\n\trdev->pm.power_state[state_index].pcie_lanes =\n\t\t((misc & ATOM_PPLIB_PCIE_LINK_WIDTH_MASK) >>\n\t\t ATOM_PPLIB_PCIE_LINK_WIDTH_SHIFT) + 1;\n\tswitch (misc2 & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_BATTERY;\n\t\tbreak;\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_BALANCED:\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_BALANCED;\n\t\tbreak;\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_PERFORMANCE;\n\t\tbreak;\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_NONE:\n\t\tif (misc2 & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\n\t\t\trdev->pm.power_state[state_index].type =\n\t\t\t\tPOWER_STATE_TYPE_PERFORMANCE;\n\t\tbreak;\n\t}\n\trdev->pm.power_state[state_index].flags = 0;\n\tif (misc & ATOM_PPLIB_SINGLE_DISPLAY_ONLY)\n\t\trdev->pm.power_state[state_index].flags |=\n\t\t\tRADEON_PM_STATE_SINGLE_DISPLAY_ONLY;\n\tif (misc2 & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\trdev->pm.power_state[state_index].type =\n\t\t\tPOWER_STATE_TYPE_DEFAULT;\n\t\trdev->pm.default_power_state_index = state_index;\n\t\trdev->pm.power_state[state_index].default_clock_mode =\n\t\t\t&rdev->pm.power_state[state_index].clock_info[mode_index - 1];\n\t\tif ((rdev->family >= CHIP_BARTS) && !(rdev->flags & RADEON_IS_IGP)) {\n\t\t\t \n\t\t\trdev->pm.default_sclk = rdev->pm.power_state[state_index].clock_info[0].sclk;\n\t\t\trdev->pm.default_mclk = rdev->pm.power_state[state_index].clock_info[0].mclk;\n\t\t\trdev->pm.default_vddc = rdev->pm.power_state[state_index].clock_info[0].voltage.voltage;\n\t\t\trdev->pm.default_vddci = rdev->pm.power_state[state_index].clock_info[0].voltage.vddci;\n\t\t} else {\n\t\t\tu16 max_vddci = 0;\n\n\t\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\t\tradeon_atom_get_max_voltage(rdev,\n\t\t\t\t\t\t\t    SET_VOLTAGE_TYPE_ASIC_VDDCI,\n\t\t\t\t\t\t\t    &max_vddci);\n\t\t\t \n\t\t\tfor (j = 0; j < mode_index; j++) {\n\t\t\t\trdev->pm.power_state[state_index].clock_info[j].mclk =\n\t\t\t\t\trdev->clock.default_mclk;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[j].sclk =\n\t\t\t\t\trdev->clock.default_sclk;\n\t\t\t\tif (vddc)\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[j].voltage.voltage =\n\t\t\t\t\t\tvddc;\n\t\t\t\tif (max_vddci)\n\t\t\t\t\trdev->pm.power_state[state_index].clock_info[j].voltage.vddci =\n\t\t\t\t\t\tmax_vddci;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool radeon_atombios_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t\t   int state_index, int mode_index,\n\t\t\t\t\t\t   union pplib_clock_info *clock_info)\n{\n\tu32 sclk, mclk;\n\tu16 vddc;\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tif (rdev->family >= CHIP_PALM) {\n\t\t\tsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\n\t\t\tsclk |= clock_info->sumo.ucEngineClockHigh << 16;\n\t\t\trdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\n\t\t} else {\n\t\t\tsclk = le16_to_cpu(clock_info->rs780.usLowEngineClockLow);\n\t\t\tsclk |= clock_info->rs780.ucLowEngineClockHigh << 16;\n\t\t\trdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\n\t\t}\n\t} else if (rdev->family >= CHIP_BONAIRE) {\n\t\tsclk = le16_to_cpu(clock_info->ci.usEngineClockLow);\n\t\tsclk |= clock_info->ci.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->ci.usMemoryClockLow);\n\t\tmclk |= clock_info->ci.ucMemoryClockHigh << 16;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\n\t\t\tVOLTAGE_NONE;\n\t} else if (rdev->family >= CHIP_TAHITI) {\n\t\tsclk = le16_to_cpu(clock_info->si.usEngineClockLow);\n\t\tsclk |= clock_info->si.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->si.usMemoryClockLow);\n\t\tmclk |= clock_info->si.ucMemoryClockHigh << 16;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\n\t\t\tVOLTAGE_SW;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage =\n\t\t\tle16_to_cpu(clock_info->si.usVDDC);\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.vddci =\n\t\t\tle16_to_cpu(clock_info->si.usVDDCI);\n\t} else if (rdev->family >= CHIP_CEDAR) {\n\t\tsclk = le16_to_cpu(clock_info->evergreen.usEngineClockLow);\n\t\tsclk |= clock_info->evergreen.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->evergreen.usMemoryClockLow);\n\t\tmclk |= clock_info->evergreen.ucMemoryClockHigh << 16;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\n\t\t\tVOLTAGE_SW;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage =\n\t\t\tle16_to_cpu(clock_info->evergreen.usVDDC);\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.vddci =\n\t\t\tle16_to_cpu(clock_info->evergreen.usVDDCI);\n\t} else {\n\t\tsclk = le16_to_cpu(clock_info->r600.usEngineClockLow);\n\t\tsclk |= clock_info->r600.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->r600.usMemoryClockLow);\n\t\tmclk |= clock_info->r600.ucMemoryClockHigh << 16;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].mclk = mclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].sclk = sclk;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.type =\n\t\t\tVOLTAGE_SW;\n\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage =\n\t\t\tle16_to_cpu(clock_info->r600.usVDDC);\n\t}\n\n\t \n\tswitch (rdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage) {\n\tcase ATOM_VIRTUAL_VOLTAGE_ID0:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID1:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID2:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID3:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID4:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID5:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID6:\n\tcase ATOM_VIRTUAL_VOLTAGE_ID7:\n\t\tif (radeon_atom_get_max_vddc(rdev, VOLTAGE_TYPE_VDDC,\n\t\t\t\t\t     rdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage,\n\t\t\t\t\t     &vddc) == 0)\n\t\t\trdev->pm.power_state[state_index].clock_info[mode_index].voltage.voltage = vddc;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\t \n\t\tif (rdev->pm.power_state[state_index].clock_info[mode_index].sclk == 0)\n\t\t\treturn false;\n\t} else {\n\t\t \n\t\tif ((rdev->pm.power_state[state_index].clock_info[mode_index].mclk == 0) ||\n\t\t    (rdev->pm.power_state[state_index].clock_info[mode_index].sclk == 0))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int radeon_atombios_parse_power_table_4_5(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j;\n\tint state_index = 0, mode_index = 0;\n\tunion pplib_clock_info *clock_info;\n\tbool valid;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn state_index;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tradeon_atombios_add_pplib_thermal_controller(rdev, &power_info->pplib.sThermalController);\n\tif (power_info->pplib.ucNumStates == 0)\n\t\treturn state_index;\n\trdev->pm.power_state = kcalloc(power_info->pplib.ucNumStates,\n\t\t\t\t       sizeof(struct radeon_power_state),\n\t\t\t\t       GFP_KERNEL);\n\tif (!rdev->pm.power_state)\n\t\treturn state_index;\n\t \n\tfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\n\t\tmode_index = 0;\n\t\tpower_state = (union pplib_power_state *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset) +\n\t\t\t i * power_info->pplib.ucStateEntrySize);\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\n\t\t\t (power_state->v1.ucNonClockStateIndex *\n\t\t\t  power_info->pplib.ucNonClockSize));\n\t\trdev->pm.power_state[i].clock_info =\n\t\t\tkcalloc((power_info->pplib.ucStateEntrySize - 1) ?\n\t\t\t\t(power_info->pplib.ucStateEntrySize - 1) : 1,\n\t\t\t\tsizeof(struct radeon_pm_clock_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!rdev->pm.power_state[i].clock_info)\n\t\t\treturn state_index;\n\t\tif (power_info->pplib.ucStateEntrySize - 1) {\n\t\t\tfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\n\t\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\n\t\t\t\t\t (power_state->v1.ucClockStateIndices[j] *\n\t\t\t\t\t  power_info->pplib.ucClockInfoSize));\n\t\t\t\tvalid = radeon_atombios_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t\t\t\t       state_index, mode_index,\n\t\t\t\t\t\t\t\t\t       clock_info);\n\t\t\t\tif (valid)\n\t\t\t\t\tmode_index++;\n\t\t\t}\n\t\t} else {\n\t\t\trdev->pm.power_state[state_index].clock_info[0].mclk =\n\t\t\t\trdev->clock.default_mclk;\n\t\t\trdev->pm.power_state[state_index].clock_info[0].sclk =\n\t\t\t\trdev->clock.default_sclk;\n\t\t\tmode_index++;\n\t\t}\n\t\trdev->pm.power_state[state_index].num_clock_modes = mode_index;\n\t\tif (mode_index) {\n\t\t\tradeon_atombios_parse_pplib_non_clock_info(rdev, state_index, mode_index,\n\t\t\t\t\t\t\t\t   non_clock_info);\n\t\t\tstate_index++;\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < state_index; i++) {\n\t\tif (rdev->pm.power_state[i].num_clock_modes > 1)\n\t\t\trdev->pm.power_state[i].clock_info[0].flags |=\n\t\t\t\tRADEON_PM_MODE_NO_DISPLAY;\n\t}\n\t \n\tif (rdev->pm.default_power_state_index == -1) {\n\t\trdev->pm.power_state[0].type =\n\t\t\tPOWER_STATE_TYPE_DEFAULT;\n\t\trdev->pm.default_power_state_index = 0;\n\t\trdev->pm.power_state[0].default_clock_mode =\n\t\t\t&rdev->pm.power_state[0].clock_info[0];\n\t}\n\treturn state_index;\n}\n\nstatic int radeon_atombios_parse_power_table_6(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j, non_clock_array_index, clock_array_index;\n\tint state_index = 0, mode_index = 0;\n\tunion pplib_clock_info *clock_info;\n\tstruct _StateArray *state_array;\n\tstruct _ClockInfoArray *clock_info_array;\n\tstruct _NonClockInfoArray *non_clock_info_array;\n\tbool valid;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tu8 *power_state_offset;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn state_index;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tradeon_atombios_add_pplib_thermal_controller(rdev, &power_info->pplib.sThermalController);\n\tstate_array = (struct _StateArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset));\n\tclock_info_array = (struct _ClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\n\tnon_clock_info_array = (struct _NonClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\n\tif (state_array->ucNumEntries == 0)\n\t\treturn state_index;\n\trdev->pm.power_state = kcalloc(state_array->ucNumEntries,\n\t\t\t\t       sizeof(struct radeon_power_state),\n\t\t\t\t       GFP_KERNEL);\n\tif (!rdev->pm.power_state)\n\t\treturn state_index;\n\tpower_state_offset = (u8 *)state_array->states;\n\tfor (i = 0; i < state_array->ucNumEntries; i++) {\n\t\tmode_index = 0;\n\t\tpower_state = (union pplib_power_state *)power_state_offset;\n\t\tnon_clock_array_index = power_state->v2.nonClockInfoIndex;\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t&non_clock_info_array->nonClockInfo[non_clock_array_index];\n\t\trdev->pm.power_state[i].clock_info =\n\t\t\tkcalloc(power_state->v2.ucNumDPMLevels ?\n\t\t\t\tpower_state->v2.ucNumDPMLevels : 1,\n\t\t\t\tsizeof(struct radeon_pm_clock_info),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!rdev->pm.power_state[i].clock_info)\n\t\t\treturn state_index;\n\t\tif (power_state->v2.ucNumDPMLevels) {\n\t\t\tfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\n\t\t\t\tclock_array_index = power_state->v2.clockInfoIndex[j];\n\t\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t\t&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\n\t\t\t\tvalid = radeon_atombios_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t\t\t\t       state_index, mode_index,\n\t\t\t\t\t\t\t\t\t       clock_info);\n\t\t\t\tif (valid)\n\t\t\t\t\tmode_index++;\n\t\t\t}\n\t\t} else {\n\t\t\trdev->pm.power_state[state_index].clock_info[0].mclk =\n\t\t\t\trdev->clock.default_mclk;\n\t\t\trdev->pm.power_state[state_index].clock_info[0].sclk =\n\t\t\t\trdev->clock.default_sclk;\n\t\t\tmode_index++;\n\t\t}\n\t\trdev->pm.power_state[state_index].num_clock_modes = mode_index;\n\t\tif (mode_index) {\n\t\t\tradeon_atombios_parse_pplib_non_clock_info(rdev, state_index, mode_index,\n\t\t\t\t\t\t\t\t   non_clock_info);\n\t\t\tstate_index++;\n\t\t}\n\t\tpower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\n\t}\n\t \n\tfor (i = 0; i < state_index; i++) {\n\t\tif (rdev->pm.power_state[i].num_clock_modes > 1)\n\t\t\trdev->pm.power_state[i].clock_info[0].flags |=\n\t\t\t\tRADEON_PM_MODE_NO_DISPLAY;\n\t}\n\t \n\tif (rdev->pm.default_power_state_index == -1) {\n\t\trdev->pm.power_state[0].type =\n\t\t\tPOWER_STATE_TYPE_DEFAULT;\n\t\trdev->pm.default_power_state_index = 0;\n\t\trdev->pm.power_state[0].default_clock_mode =\n\t\t\t&rdev->pm.power_state[0].clock_info[0];\n\t}\n\treturn state_index;\n}\n\nvoid radeon_atombios_get_power_modes(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tint state_index = 0;\n\n\trdev->pm.default_power_state_index = -1;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tstate_index = radeon_atombios_parse_power_table_1_3(rdev);\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tstate_index = radeon_atombios_parse_power_table_4_5(rdev);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tstate_index = radeon_atombios_parse_power_table_6(rdev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (state_index == 0) {\n\t\trdev->pm.power_state = kzalloc(sizeof(struct radeon_power_state), GFP_KERNEL);\n\t\tif (rdev->pm.power_state) {\n\t\t\trdev->pm.power_state[0].clock_info =\n\t\t\t\tkcalloc(1,\n\t\t\t\t        sizeof(struct radeon_pm_clock_info),\n\t\t\t\t        GFP_KERNEL);\n\t\t\tif (rdev->pm.power_state[0].clock_info) {\n\t\t\t\t \n\t\t\t\trdev->pm.power_state[state_index].type =\n\t\t\t\t\tPOWER_STATE_TYPE_DEFAULT;\n\t\t\t\trdev->pm.power_state[state_index].num_clock_modes = 1;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].mclk = rdev->clock.default_mclk;\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].sclk = rdev->clock.default_sclk;\n\t\t\t\trdev->pm.power_state[state_index].default_clock_mode =\n\t\t\t\t\t&rdev->pm.power_state[state_index].clock_info[0];\n\t\t\t\trdev->pm.power_state[state_index].clock_info[0].voltage.type = VOLTAGE_NONE;\n\t\t\t\trdev->pm.power_state[state_index].pcie_lanes = 16;\n\t\t\t\trdev->pm.default_power_state_index = state_index;\n\t\t\t\trdev->pm.power_state[state_index].flags = 0;\n\t\t\t\tstate_index++;\n\t\t\t}\n\t\t}\n\t}\n\n\trdev->pm.num_power_states = state_index;\n\n\trdev->pm.current_power_state_index = rdev->pm.default_power_state_index;\n\trdev->pm.current_clock_mode_index = 0;\n\tif (rdev->pm.default_power_state_index >= 0)\n\t\trdev->pm.current_vddc =\n\t\t\trdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.voltage;\n\telse\n\t\trdev->pm.current_vddc = 0;\n}\n\nunion get_clock_dividers {\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS v1;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V2 v2;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V3 v3;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V4 v4;\n\tstruct _COMPUTE_MEMORY_ENGINE_PLL_PARAMETERS_V5 v5;\n\tstruct _COMPUTE_GPU_CLOCK_INPUT_PARAMETERS_V1_6 v6_in;\n\tstruct _COMPUTE_GPU_CLOCK_OUTPUT_PARAMETERS_V1_6 v6_out;\n};\n\nint radeon_atom_get_clock_dividers(struct radeon_device *rdev,\n\t\t\t\t   u8 clock_type,\n\t\t\t\t   u32 clock,\n\t\t\t\t   bool strobe_mode,\n\t\t\t\t   struct atom_clock_dividers *dividers)\n{\n\tunion get_clock_dividers args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ComputeMemoryEnginePLL);\n\tu8 frev, crev;\n\n\tmemset(&args, 0, sizeof(args));\n\tmemset(dividers, 0, sizeof(struct atom_clock_dividers));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (crev) {\n\tcase 1:\n\t\t \n\t\targs.v1.ucAction = clock_type;\n\t\targs.v1.ulClock = cpu_to_le32(clock);\t \n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\tdividers->post_div = args.v1.ucPostDiv;\n\t\tdividers->fb_div = args.v1.ucFbDiv;\n\t\tdividers->enable_post_div = true;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t \n\t\tif (rdev->family <= CHIP_RV770) {\n\t\t\targs.v2.ucAction = clock_type;\n\t\t\targs.v2.ulClock = cpu_to_le32(clock);\t \n\n\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\tdividers->post_div = args.v2.ucPostDiv;\n\t\t\tdividers->fb_div = le16_to_cpu(args.v2.usFbDiv);\n\t\t\tdividers->ref_div = args.v2.ucAction;\n\t\t\tif (rdev->family == CHIP_RV770) {\n\t\t\t\tdividers->enable_post_div = (le32_to_cpu(args.v2.ulClock) & (1 << 24)) ?\n\t\t\t\t\ttrue : false;\n\t\t\t\tdividers->vco_mode = (le32_to_cpu(args.v2.ulClock) & (1 << 25)) ? 1 : 0;\n\t\t\t} else\n\t\t\t\tdividers->enable_post_div = (dividers->fb_div & 1) ? true : false;\n\t\t} else {\n\t\t\tif (clock_type == COMPUTE_ENGINE_PLL_PARAM) {\n\t\t\t\targs.v3.ulClockParams = cpu_to_le32((clock_type << 24) | clock);\n\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\t\tdividers->post_div = args.v3.ucPostDiv;\n\t\t\t\tdividers->enable_post_div = (args.v3.ucCntlFlag &\n\t\t\t\t\t\t\t     ATOM_PLL_CNTL_FLAG_PLL_POST_DIV_EN) ? true : false;\n\t\t\t\tdividers->enable_dithen = (args.v3.ucCntlFlag &\n\t\t\t\t\t\t\t   ATOM_PLL_CNTL_FLAG_FRACTION_DISABLE) ? false : true;\n\t\t\t\tdividers->whole_fb_div = le16_to_cpu(args.v3.ulFbDiv.usFbDiv);\n\t\t\t\tdividers->frac_fb_div = le16_to_cpu(args.v3.ulFbDiv.usFbDivFrac);\n\t\t\t\tdividers->ref_div = args.v3.ucRefDiv;\n\t\t\t\tdividers->vco_mode = (args.v3.ucCntlFlag &\n\t\t\t\t\t\t      ATOM_PLL_CNTL_FLAG_MPLL_VCO_MODE) ? 1 : 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (rdev->family >= CHIP_TAHITI)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\targs.v5.ulClockParams = cpu_to_le32((clock_type << 24) | clock);\n\t\t\t\tif (strobe_mode)\n\t\t\t\t\targs.v5.ucInputFlag = ATOM_PLL_INPUT_FLAG_PLL_STROBE_MODE_EN;\n\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\t\tdividers->post_div = args.v5.ucPostDiv;\n\t\t\t\tdividers->enable_post_div = (args.v5.ucCntlFlag &\n\t\t\t\t\t\t\t     ATOM_PLL_CNTL_FLAG_PLL_POST_DIV_EN) ? true : false;\n\t\t\t\tdividers->enable_dithen = (args.v5.ucCntlFlag &\n\t\t\t\t\t\t\t   ATOM_PLL_CNTL_FLAG_FRACTION_DISABLE) ? false : true;\n\t\t\t\tdividers->whole_fb_div = le16_to_cpu(args.v5.ulFbDiv.usFbDiv);\n\t\t\t\tdividers->frac_fb_div = le16_to_cpu(args.v5.ulFbDiv.usFbDivFrac);\n\t\t\t\tdividers->ref_div = args.v5.ucRefDiv;\n\t\t\t\tdividers->vco_mode = (args.v5.ucCntlFlag &\n\t\t\t\t\t\t      ATOM_PLL_CNTL_FLAG_MPLL_VCO_MODE) ? 1 : 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\targs.v4.ulClock = cpu_to_le32(clock);\t \n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\tdividers->post_divider = dividers->post_div = args.v4.ucPostDiv;\n\t\tdividers->real_clock = le32_to_cpu(args.v4.ulClock);\n\t\tbreak;\n\tcase 6:\n\t\t \n\t\t \n\t\targs.v6_in.ulClock.ulComputeClockFlag = clock_type;\n\t\targs.v6_in.ulClock.ulClockFreq = cpu_to_le32(clock);\t \n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\tdividers->whole_fb_div = le16_to_cpu(args.v6_out.ulFbDiv.usFbDiv);\n\t\tdividers->frac_fb_div = le16_to_cpu(args.v6_out.ulFbDiv.usFbDivFrac);\n\t\tdividers->ref_div = args.v6_out.ucPllRefDiv;\n\t\tdividers->post_div = args.v6_out.ucPllPostDiv;\n\t\tdividers->flags = args.v6_out.ucPllCntlFlag;\n\t\tdividers->real_clock = le32_to_cpu(args.v6_out.ulClock.ulClock);\n\t\tdividers->post_divider = args.v6_out.ulClock.ucPostDiv;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint radeon_atom_get_memory_pll_dividers(struct radeon_device *rdev,\n\t\t\t\t\tu32 clock,\n\t\t\t\t\tbool strobe_mode,\n\t\t\t\t\tstruct atom_mpll_param *mpll_param)\n{\n\tCOMPUTE_MEMORY_CLOCK_PARAM_PARAMETERS_V2_1 args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ComputeMemoryClockParam);\n\tu8 frev, crev;\n\n\tmemset(&args, 0, sizeof(args));\n\tmemset(mpll_param, 0, sizeof(struct atom_mpll_param));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (frev) {\n\tcase 2:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\t \n\t\t\targs.ulClock = cpu_to_le32(clock);\t \n\t\t\targs.ucInputFlag = 0;\n\t\t\tif (strobe_mode)\n\t\t\t\targs.ucInputFlag |= MPLL_INPUT_FLAG_STROBE_MODE_EN;\n\n\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t\tmpll_param->clkfrac = le16_to_cpu(args.ulFbDiv.usFbDivFrac);\n\t\t\tmpll_param->clkf = le16_to_cpu(args.ulFbDiv.usFbDiv);\n\t\t\tmpll_param->post_div = args.ucPostDiv;\n\t\t\tmpll_param->dll_speed = args.ucDllSpeed;\n\t\t\tmpll_param->bwcntl = args.ucBWCntl;\n\t\t\tmpll_param->vco_mode =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_VCO_MODE_MASK);\n\t\t\tmpll_param->yclk_sel =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_BYPASS_DQ_PLL) ? 1 : 0;\n\t\t\tmpll_param->qdr =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_QDR_ENABLE) ? 1 : 0;\n\t\t\tmpll_param->half_rate =\n\t\t\t\t(args.ucPllCntlFlag & MPLL_CNTL_FLAG_AD_HALF_RATE) ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid radeon_atom_set_clock_gating(struct radeon_device *rdev, int enable)\n{\n\tDYNAMIC_CLOCK_GATING_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DynamicClockGating);\n\n\targs.ucEnable = enable;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nuint32_t radeon_atom_get_engine_clock(struct radeon_device *rdev)\n{\n\tGET_ENGINE_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, GetEngineClock);\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\treturn le32_to_cpu(args.ulReturnEngineClock);\n}\n\nuint32_t radeon_atom_get_memory_clock(struct radeon_device *rdev)\n{\n\tGET_MEMORY_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, GetMemoryClock);\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\treturn le32_to_cpu(args.ulReturnMemoryClock);\n}\n\nvoid radeon_atom_set_engine_clock(struct radeon_device *rdev,\n\t\t\t\t  uint32_t eng_clock)\n{\n\tSET_ENGINE_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetEngineClock);\n\n\targs.ulTargetEngineClock = cpu_to_le32(eng_clock);\t \n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid radeon_atom_set_memory_clock(struct radeon_device *rdev,\n\t\t\t\t  uint32_t mem_clock)\n{\n\tSET_MEMORY_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetMemoryClock);\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\targs.ulTargetMemoryClock = cpu_to_le32(mem_clock);\t \n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid radeon_atom_set_engine_dram_timings(struct radeon_device *rdev,\n\t\t\t\t\t u32 eng_clock, u32 mem_clock)\n{\n\tSET_ENGINE_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\n\tu32 tmp;\n\n\tmemset(&args, 0, sizeof(args));\n\n\ttmp = eng_clock & SET_CLOCK_FREQ_MASK;\n\ttmp |= (COMPUTE_ENGINE_PLL_PARAM << 24);\n\n\targs.ulTargetEngineClock = cpu_to_le32(tmp);\n\tif (mem_clock)\n\t\targs.sReserved.ulClock = cpu_to_le32(mem_clock & SET_CLOCK_FREQ_MASK);\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid radeon_atom_update_memory_dll(struct radeon_device *rdev,\n\t\t\t\t   u32 mem_clock)\n{\n\tu32 args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\n\n\targs = cpu_to_le32(mem_clock);\t \n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid radeon_atom_set_ac_timing(struct radeon_device *rdev,\n\t\t\t       u32 mem_clock)\n{\n\tSET_MEMORY_CLOCK_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DynamicMemorySettings);\n\tu32 tmp = mem_clock | (COMPUTE_MEMORY_PLL_PARAM << 24);\n\n\targs.ulTargetMemoryClock = cpu_to_le32(tmp);\t \n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nunion set_voltage {\n\tstruct _SET_VOLTAGE_PS_ALLOCATION alloc;\n\tstruct _SET_VOLTAGE_PARAMETERS v1;\n\tstruct _SET_VOLTAGE_PARAMETERS_V2 v2;\n\tstruct _SET_VOLTAGE_PARAMETERS_V1_3 v3;\n};\n\nvoid radeon_atom_set_voltage(struct radeon_device *rdev, u16 voltage_level, u8 voltage_type)\n{\n\tunion set_voltage args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\n\tu8 frev, crev, volt_index = voltage_level;\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\t \n\tif (voltage_level == 0xff01)\n\t\treturn;\n\n\tswitch (crev) {\n\tcase 1:\n\t\targs.v1.ucVoltageType = voltage_type;\n\t\targs.v1.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_ALL_SOURCE;\n\t\targs.v1.ucVoltageIndex = volt_index;\n\t\tbreak;\n\tcase 2:\n\t\targs.v2.ucVoltageType = voltage_type;\n\t\targs.v2.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_SET_VOLTAGE;\n\t\targs.v2.usVoltageLevel = cpu_to_le16(voltage_level);\n\t\tbreak;\n\tcase 3:\n\t\targs.v3.ucVoltageType = voltage_type;\n\t\targs.v3.ucVoltageMode = ATOM_SET_VOLTAGE;\n\t\targs.v3.usVoltageLevel = cpu_to_le16(voltage_level);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nint radeon_atom_get_max_vddc(struct radeon_device *rdev, u8 voltage_type,\n\t\t\t     u16 voltage_id, u16 *voltage)\n{\n\tunion set_voltage args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\n\tu8 frev, crev;\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (crev) {\n\tcase 1:\n\t\treturn -EINVAL;\n\tcase 2:\n\t\targs.v2.ucVoltageType = SET_VOLTAGE_GET_MAX_VOLTAGE;\n\t\targs.v2.ucVoltageMode = 0;\n\t\targs.v2.usVoltageLevel = 0;\n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*voltage = le16_to_cpu(args.v2.usVoltageLevel);\n\t\tbreak;\n\tcase 3:\n\t\targs.v3.ucVoltageType = voltage_type;\n\t\targs.v3.ucVoltageMode = ATOM_GET_VOLTAGE_LEVEL;\n\t\targs.v3.usVoltageLevel = cpu_to_le16(voltage_id);\n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*voltage = le16_to_cpu(args.v3.usVoltageLevel);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint radeon_atom_get_leakage_vddc_based_on_leakage_idx(struct radeon_device *rdev,\n\t\t\t\t\t\t      u16 *voltage,\n\t\t\t\t\t\t      u16 leakage_idx)\n{\n\treturn radeon_atom_get_max_vddc(rdev, VOLTAGE_TYPE_VDDC, leakage_idx, voltage);\n}\n\nint radeon_atom_get_leakage_id_from_vbios(struct radeon_device *rdev,\n\t\t\t\t\t  u16 *leakage_id)\n{\n\tunion set_voltage args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\n\tu8 frev, crev;\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (crev) {\n\tcase 3:\n\tcase 4:\n\t\targs.v3.ucVoltageType = 0;\n\t\targs.v3.ucVoltageMode = ATOM_GET_LEAKAGE_ID;\n\t\targs.v3.usVoltageLevel = 0;\n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*leakage_id = le16_to_cpu(args.v3.usVoltageLevel);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint radeon_atom_get_leakage_vddc_based_on_leakage_params(struct radeon_device *rdev,\n\t\t\t\t\t\t\t u16 *vddc, u16 *vddci,\n\t\t\t\t\t\t\t u16 virtual_voltage_id,\n\t\t\t\t\t\t\t u16 vbios_voltage_id)\n{\n\tint index = GetIndexIntoMasterTable(DATA, ASIC_ProfilingInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tint i, j;\n\tATOM_ASIC_PROFILING_INFO_V2_1 *profile;\n\tu16 *leakage_bin, *vddc_id_buf, *vddc_buf, *vddci_id_buf, *vddci_buf;\n\n\t*vddc = 0;\n\t*vddci = 0;\n\n\tif (!atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t    &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\n\tprofile = (ATOM_ASIC_PROFILING_INFO_V2_1 *)\n\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\tswitch (frev) {\n\tcase 1:\n\t\treturn -EINVAL;\n\tcase 2:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tif (size < sizeof(ATOM_ASIC_PROFILING_INFO_V2_1))\n\t\t\t\treturn -EINVAL;\n\t\t\tleakage_bin = (u16 *)\n\t\t\t\t(rdev->mode_info.atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(profile->usLeakageBinArrayOffset));\n\t\t\tvddc_id_buf = (u16 *)\n\t\t\t\t(rdev->mode_info.atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(profile->usElbVDDC_IdArrayOffset));\n\t\t\tvddc_buf = (u16 *)\n\t\t\t\t(rdev->mode_info.atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(profile->usElbVDDC_LevelArrayOffset));\n\t\t\tvddci_id_buf = (u16 *)\n\t\t\t\t(rdev->mode_info.atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(profile->usElbVDDCI_IdArrayOffset));\n\t\t\tvddci_buf = (u16 *)\n\t\t\t\t(rdev->mode_info.atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(profile->usElbVDDCI_LevelArrayOffset));\n\n\t\t\tif (profile->ucElbVDDC_Num > 0) {\n\t\t\t\tfor (i = 0; i < profile->ucElbVDDC_Num; i++) {\n\t\t\t\t\tif (vddc_id_buf[i] == virtual_voltage_id) {\n\t\t\t\t\t\tfor (j = 0; j < profile->ucLeakageBinNum; j++) {\n\t\t\t\t\t\t\tif (vbios_voltage_id <= leakage_bin[j]) {\n\t\t\t\t\t\t\t\t*vddc = vddc_buf[j * profile->ucElbVDDC_Num + i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (profile->ucElbVDDCI_Num > 0) {\n\t\t\t\tfor (i = 0; i < profile->ucElbVDDCI_Num; i++) {\n\t\t\t\t\tif (vddci_id_buf[i] == virtual_voltage_id) {\n\t\t\t\t\t\tfor (j = 0; j < profile->ucLeakageBinNum; j++) {\n\t\t\t\t\t\t\tif (vbios_voltage_id <= leakage_bin[j]) {\n\t\t\t\t\t\t\t\t*vddci = vddci_buf[j * profile->ucElbVDDCI_Num + i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nunion get_voltage_info {\n\tstruct  _GET_VOLTAGE_INFO_INPUT_PARAMETER_V1_2 in;\n\tstruct  _GET_EVV_VOLTAGE_INFO_OUTPUT_PARAMETER_V1_2 evv_out;\n};\n\nint radeon_atom_get_voltage_evv(struct radeon_device *rdev,\n\t\t\t\tu16 virtual_voltage_id,\n\t\t\t\tu16 *voltage)\n{\n\tint index = GetIndexIntoMasterTable(COMMAND, GetVoltageInfo);\n\tu32 entry_id;\n\tu32 count = rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count;\n\tunion get_voltage_info args;\n\n\tfor (entry_id = 0; entry_id < count; entry_id++) {\n\t\tif (rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[entry_id].v ==\n\t\t    virtual_voltage_id)\n\t\t\tbreak;\n\t}\n\n\tif (entry_id >= count)\n\t\treturn -EINVAL;\n\n\targs.in.ucVoltageType = VOLTAGE_TYPE_VDDC;\n\targs.in.ucVoltageMode = ATOM_GET_VOLTAGE_EVV_VOLTAGE;\n\targs.in.usVoltageLevel = cpu_to_le16(virtual_voltage_id);\n\targs.in.ulSCLKFreq =\n\t\tcpu_to_le32(rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[entry_id].clk);\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t*voltage = le16_to_cpu(args.evv_out.usVoltageLevel);\n\n\treturn 0;\n}\n\nint radeon_atom_get_voltage_gpio_settings(struct radeon_device *rdev,\n\t\t\t\t\t  u16 voltage_level, u8 voltage_type,\n\t\t\t\t\t  u32 *gpio_value, u32 *gpio_mask)\n{\n\tunion set_voltage args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetVoltage);\n\tu8 frev, crev;\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn -EINVAL;\n\n\tswitch (crev) {\n\tcase 1:\n\t\treturn -EINVAL;\n\tcase 2:\n\t\targs.v2.ucVoltageType = voltage_type;\n\t\targs.v2.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_GET_GPIOMASK;\n\t\targs.v2.usVoltageLevel = cpu_to_le16(voltage_level);\n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*gpio_mask = le32_to_cpu(*(u32 *)&args.v2);\n\n\t\targs.v2.ucVoltageType = voltage_type;\n\t\targs.v2.ucVoltageMode = SET_ASIC_VOLTAGE_MODE_GET_GPIOVAL;\n\t\targs.v2.usVoltageLevel = cpu_to_le16(voltage_level);\n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\t*gpio_value = le32_to_cpu(*(u32 *)&args.v2);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nunion voltage_object_info {\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO v1;\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO_V2 v2;\n\tstruct _ATOM_VOLTAGE_OBJECT_INFO_V3_1 v3;\n};\n\nunion voltage_object {\n\tstruct _ATOM_VOLTAGE_OBJECT v1;\n\tstruct _ATOM_VOLTAGE_OBJECT_V2 v2;\n\tunion _ATOM_VOLTAGE_OBJECT_V3 v3;\n};\n\nstatic ATOM_VOLTAGE_OBJECT *atom_lookup_voltage_object_v1(ATOM_VOLTAGE_OBJECT_INFO *v1,\n\t\t\t\t\t\t\t  u8 voltage_type)\n{\n\tu32 size = le16_to_cpu(v1->sHeader.usStructureSize);\n\tu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO, asVoltageObj[0]);\n\tu8 *start = (u8 *)v1;\n\n\twhile (offset < size) {\n\t\tATOM_VOLTAGE_OBJECT *vo = (ATOM_VOLTAGE_OBJECT *)(start + offset);\n\t\tif (vo->ucVoltageType == voltage_type)\n\t\t\treturn vo;\n\t\toffset += offsetof(ATOM_VOLTAGE_OBJECT, asFormula.ucVIDAdjustEntries) +\n\t\t\tvo->asFormula.ucNumOfVoltageEntries;\n\t}\n\treturn NULL;\n}\n\nstatic ATOM_VOLTAGE_OBJECT_V2 *atom_lookup_voltage_object_v2(ATOM_VOLTAGE_OBJECT_INFO_V2 *v2,\n\t\t\t\t\t\t\t     u8 voltage_type)\n{\n\tu32 size = le16_to_cpu(v2->sHeader.usStructureSize);\n\tu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V2, asVoltageObj[0]);\n\tu8 *start = (u8 *)v2;\n\n\twhile (offset < size) {\n\t\tATOM_VOLTAGE_OBJECT_V2 *vo = (ATOM_VOLTAGE_OBJECT_V2 *)(start + offset);\n\t\tif (vo->ucVoltageType == voltage_type)\n\t\t\treturn vo;\n\t\toffset += offsetof(ATOM_VOLTAGE_OBJECT_V2, asFormula.asVIDAdjustEntries) +\n\t\t\t(vo->asFormula.ucNumOfVoltageEntries * sizeof(VOLTAGE_LUT_ENTRY));\n\t}\n\treturn NULL;\n}\n\nstatic ATOM_VOLTAGE_OBJECT_V3 *atom_lookup_voltage_object_v3(ATOM_VOLTAGE_OBJECT_INFO_V3_1 *v3,\n\t\t\t\t\t\t\t     u8 voltage_type, u8 voltage_mode)\n{\n\tu32 size = le16_to_cpu(v3->sHeader.usStructureSize);\n\tu32 offset = offsetof(ATOM_VOLTAGE_OBJECT_INFO_V3_1, asVoltageObj[0]);\n\tu8 *start = (u8 *)v3;\n\n\twhile (offset < size) {\n\t\tATOM_VOLTAGE_OBJECT_V3 *vo = (ATOM_VOLTAGE_OBJECT_V3 *)(start + offset);\n\t\tif ((vo->asGpioVoltageObj.sHeader.ucVoltageType == voltage_type) &&\n\t\t    (vo->asGpioVoltageObj.sHeader.ucVoltageMode == voltage_mode))\n\t\t\treturn vo;\n\t\toffset += le16_to_cpu(vo->asGpioVoltageObj.sHeader.usSize);\n\t}\n\treturn NULL;\n}\n\nbool\nradeon_atom_is_voltage_gpio(struct radeon_device *rdev,\n\t\t\t    u8 voltage_type, u8 voltage_mode)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tatom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\n\t\t\t\tif (voltage_object &&\n\t\t\t\t    (voltage_object->v1.asControl.ucVoltageControlId == VOLTAGE_CONTROLLED_BY_GPIO))\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tatom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\n\t\t\t\tif (voltage_object &&\n\t\t\t\t    (voltage_object->v2.asControl.ucVoltageControlId == VOLTAGE_CONTROLLED_BY_GPIO))\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tif (atom_lookup_voltage_object_v3(&voltage_info->v3,\n\t\t\t\t\t\t\t\t  voltage_type, voltage_mode))\n\t\t\t\t\treturn true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint radeon_atom_get_svi2_info(struct radeon_device *rdev,\n\t\t\t      u8 voltage_type,\n\t\t\t      u8 *svd_gpio_id, u8 *svc_gpio_id)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 3:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tatom_lookup_voltage_object_v3(&voltage_info->v3,\n\t\t\t\t\t\t\t\t      voltage_type,\n\t\t\t\t\t\t\t\t      VOLTAGE_OBJ_SVID2);\n\t\t\t\tif (voltage_object) {\n\t\t\t\t\t*svd_gpio_id = voltage_object->v3.asSVID2Obj.ucSVDGpioId;\n\t\t\t\t\t*svc_gpio_id = voltage_object->v3.asSVID2Obj.ucSVCGpioId;\n\t\t\t\t} else {\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\nint radeon_atom_get_max_voltage(struct radeon_device *rdev,\n\t\t\t\tu8 voltage_type, u16 *max_voltage)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\tatom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\n\t\t\tif (voltage_object) {\n\t\t\t\tATOM_VOLTAGE_FORMULA *formula =\n\t\t\t\t\t&voltage_object->v1.asFormula;\n\t\t\t\tif (formula->ucFlag & 1)\n\t\t\t\t\t*max_voltage =\n\t\t\t\t\t\tle16_to_cpu(formula->usVoltageBaseLevel) +\n\t\t\t\t\t\tformula->ucNumOfVoltageEntries / 2 *\n\t\t\t\t\t\tle16_to_cpu(formula->usVoltageStep);\n\t\t\t\telse\n\t\t\t\t\t*max_voltage =\n\t\t\t\t\t\tle16_to_cpu(formula->usVoltageBaseLevel) +\n\t\t\t\t\t\t(formula->ucNumOfVoltageEntries - 1) *\n\t\t\t\t\t\tle16_to_cpu(formula->usVoltageStep);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\tatom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\n\t\t\tif (voltage_object) {\n\t\t\t\tATOM_VOLTAGE_FORMULA_V2 *formula =\n\t\t\t\t\t&voltage_object->v2.asFormula;\n\t\t\t\tif (formula->ucNumOfVoltageEntries) {\n\t\t\t\t\tVOLTAGE_LUT_ENTRY *lut = (VOLTAGE_LUT_ENTRY *)\n\t\t\t\t\t\t((u8 *)&formula->asVIDAdjustEntries[0] +\n\t\t\t\t\t\t (sizeof(VOLTAGE_LUT_ENTRY) * (formula->ucNumOfVoltageEntries - 1)));\n\t\t\t\t\t*max_voltage =\n\t\t\t\t\t\tle16_to_cpu(lut->usVoltageValue);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}\n\nint radeon_atom_get_min_voltage(struct radeon_device *rdev,\n\t\t\t\tu8 voltage_type, u16 *min_voltage)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\tatom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\n\t\t\tif (voltage_object) {\n\t\t\t\tATOM_VOLTAGE_FORMULA *formula =\n\t\t\t\t\t&voltage_object->v1.asFormula;\n\t\t\t\t*min_voltage =\n\t\t\t\t\tle16_to_cpu(formula->usVoltageBaseLevel);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\tatom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\n\t\t\tif (voltage_object) {\n\t\t\t\tATOM_VOLTAGE_FORMULA_V2 *formula =\n\t\t\t\t\t&voltage_object->v2.asFormula;\n\t\t\t\tif (formula->ucNumOfVoltageEntries) {\n\t\t\t\t\t*min_voltage =\n\t\t\t\t\t\tle16_to_cpu(formula->asVIDAdjustEntries[\n\t\t\t\t\t\t\t\t    0\n\t\t\t\t\t\t\t\t    ].usVoltageValue);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}\n\nint radeon_atom_get_voltage_step(struct radeon_device *rdev,\n\t\t\t\t u8 voltage_type, u16 *voltage_step)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\tatom_lookup_voltage_object_v1(&voltage_info->v1, voltage_type);\n\t\t\tif (voltage_object) {\n\t\t\t\tATOM_VOLTAGE_FORMULA *formula =\n\t\t\t\t\t&voltage_object->v1.asFormula;\n\t\t\t\tif (formula->ucFlag & 1)\n\t\t\t\t\t*voltage_step =\n\t\t\t\t\t\t(le16_to_cpu(formula->usVoltageStep) + 1) / 2;\n\t\t\t\telse\n\t\t\t\t\t*voltage_step =\n\t\t\t\t\t\tle16_to_cpu(formula->usVoltageStep);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\treturn -EINVAL;\n}\n\nint radeon_atom_round_to_true_voltage(struct radeon_device *rdev,\n\t\t\t\t      u8 voltage_type,\n\t\t\t\t      u16 nominal_voltage,\n\t\t\t\t      u16 *true_voltage)\n{\n\tu16 min_voltage, max_voltage, voltage_step;\n\n\tif (radeon_atom_get_max_voltage(rdev, voltage_type, &max_voltage))\n\t\treturn -EINVAL;\n\tif (radeon_atom_get_min_voltage(rdev, voltage_type, &min_voltage))\n\t\treturn -EINVAL;\n\tif (radeon_atom_get_voltage_step(rdev, voltage_type, &voltage_step))\n\t\treturn -EINVAL;\n\n\tif (nominal_voltage <= min_voltage)\n\t\t*true_voltage = min_voltage;\n\telse if (nominal_voltage >= max_voltage)\n\t\t*true_voltage = max_voltage;\n\telse\n\t\t*true_voltage = min_voltage +\n\t\t\t((nominal_voltage - min_voltage) / voltage_step) *\n\t\t\tvoltage_step;\n\n\treturn 0;\n}\n\nint radeon_atom_get_voltage_table(struct radeon_device *rdev,\n\t\t\t\t  u8 voltage_type, u8 voltage_mode,\n\t\t\t\t  struct atom_voltage_table *voltage_table)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VoltageObjectInfo);\n\tu8 frev, crev;\n\tu16 data_offset, size;\n\tint i, ret;\n\tunion voltage_object_info *voltage_info;\n\tunion voltage_object *voltage_object = NULL;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvoltage_info = (union voltage_object_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tDRM_ERROR(\"old table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\tcase 2:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tatom_lookup_voltage_object_v2(&voltage_info->v2, voltage_type);\n\t\t\t\tif (voltage_object) {\n\t\t\t\t\tATOM_VOLTAGE_FORMULA_V2 *formula =\n\t\t\t\t\t\t&voltage_object->v2.asFormula;\n\t\t\t\t\tVOLTAGE_LUT_ENTRY *lut;\n\t\t\t\t\tif (formula->ucNumOfVoltageEntries > MAX_VOLTAGE_ENTRIES)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tlut = &formula->asVIDAdjustEntries[0];\n\t\t\t\t\tfor (i = 0; i < formula->ucNumOfVoltageEntries; i++) {\n\t\t\t\t\t\tvoltage_table->entries[i].value =\n\t\t\t\t\t\t\tle16_to_cpu(lut->usVoltageValue);\n\t\t\t\t\t\tret = radeon_atom_get_voltage_gpio_settings(rdev,\n\t\t\t\t\t\t\t\t\t\t\t    voltage_table->entries[i].value,\n\t\t\t\t\t\t\t\t\t\t\t    voltage_type,\n\t\t\t\t\t\t\t\t\t\t\t    &voltage_table->entries[i].smio_low,\n\t\t\t\t\t\t\t\t\t\t\t    &voltage_table->mask_low);\n\t\t\t\t\t\tif (ret)\n\t\t\t\t\t\t\treturn ret;\n\t\t\t\t\t\tlut = (VOLTAGE_LUT_ENTRY *)\n\t\t\t\t\t\t\t((u8 *)lut + sizeof(VOLTAGE_LUT_ENTRY));\n\t\t\t\t\t}\n\t\t\t\t\tvoltage_table->count = formula->ucNumOfVoltageEntries;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tvoltage_object = (union voltage_object *)\n\t\t\t\t\tatom_lookup_voltage_object_v3(&voltage_info->v3,\n\t\t\t\t\t\t\t\t      voltage_type, voltage_mode);\n\t\t\t\tif (voltage_object) {\n\t\t\t\t\tATOM_GPIO_VOLTAGE_OBJECT_V3 *gpio =\n\t\t\t\t\t\t&voltage_object->v3.asGpioVoltageObj;\n\t\t\t\t\tVOLTAGE_LUT_ENTRY_V2 *lut;\n\t\t\t\t\tif (gpio->ucGpioEntryNum > MAX_VOLTAGE_ENTRIES)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\tlut = &gpio->asVolGpioLut[0];\n\t\t\t\t\tfor (i = 0; i < gpio->ucGpioEntryNum; i++) {\n\t\t\t\t\t\tvoltage_table->entries[i].value =\n\t\t\t\t\t\t\tle16_to_cpu(lut->usVoltageValue);\n\t\t\t\t\t\tvoltage_table->entries[i].smio_low =\n\t\t\t\t\t\t\tle32_to_cpu(lut->ulVoltageId);\n\t\t\t\t\t\tlut = (VOLTAGE_LUT_ENTRY_V2 *)\n\t\t\t\t\t\t\t((u8 *)lut + sizeof(VOLTAGE_LUT_ENTRY_V2));\n\t\t\t\t\t}\n\t\t\t\t\tvoltage_table->mask_low = le32_to_cpu(gpio->ulGpioMaskVal);\n\t\t\t\t\tvoltage_table->count = gpio->ucGpioEntryNum;\n\t\t\t\t\tvoltage_table->phase_delay = gpio->ucPhaseDelay;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown voltage object table\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nunion vram_info {\n\tstruct _ATOM_VRAM_INFO_V3 v1_3;\n\tstruct _ATOM_VRAM_INFO_V4 v1_4;\n\tstruct _ATOM_VRAM_INFO_HEADER_V2_1 v2_1;\n};\n\nint radeon_atom_get_memory_info(struct radeon_device *rdev,\n\t\t\t\tu8 module_index, struct atom_memory_info *mem_info)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\n\tu8 frev, crev, i;\n\tu16 data_offset, size;\n\tunion vram_info *vram_info;\n\n\tmemset(mem_info, 0, sizeof(struct atom_memory_info));\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvram_info = (union vram_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tswitch (crev) {\n\t\t\tcase 3:\n\t\t\t\t \n\t\t\t\tif (module_index < vram_info->v1_3.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_VRAM_MODULE_V3 *vram_module =\n\t\t\t\t\t\t(ATOM_VRAM_MODULE_V3 *)vram_info->v1_3.aVramInfo;\n\n\t\t\t\t\tfor (i = 0; i < module_index; i++) {\n\t\t\t\t\t\tif (le16_to_cpu(vram_module->usSize) == 0)\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\tvram_module = (ATOM_VRAM_MODULE_V3 *)\n\t\t\t\t\t\t\t((u8 *)vram_module + le16_to_cpu(vram_module->usSize));\n\t\t\t\t\t}\n\t\t\t\t\tmem_info->mem_vendor = vram_module->asMemory.ucMemoryVenderID & 0xf;\n\t\t\t\t\tmem_info->mem_type = vram_module->asMemory.ucMemoryType & 0xf0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t \n\t\t\t\tif (module_index < vram_info->v1_4.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_VRAM_MODULE_V4 *vram_module =\n\t\t\t\t\t\t(ATOM_VRAM_MODULE_V4 *)vram_info->v1_4.aVramInfo;\n\n\t\t\t\t\tfor (i = 0; i < module_index; i++) {\n\t\t\t\t\t\tif (le16_to_cpu(vram_module->usModuleSize) == 0)\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\tvram_module = (ATOM_VRAM_MODULE_V4 *)\n\t\t\t\t\t\t\t((u8 *)vram_module + le16_to_cpu(vram_module->usModuleSize));\n\t\t\t\t\t}\n\t\t\t\t\tmem_info->mem_vendor = vram_module->ucMemoryVenderID & 0xf;\n\t\t\t\t\tmem_info->mem_type = vram_module->ucMemoryType & 0xf0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tif (module_index < vram_info->v2_1.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_VRAM_MODULE_V7 *vram_module =\n\t\t\t\t\t\t(ATOM_VRAM_MODULE_V7 *)vram_info->v2_1.aVramInfo;\n\n\t\t\t\t\tfor (i = 0; i < module_index; i++) {\n\t\t\t\t\t\tif (le16_to_cpu(vram_module->usModuleSize) == 0)\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\tvram_module = (ATOM_VRAM_MODULE_V7 *)\n\t\t\t\t\t\t\t((u8 *)vram_module + le16_to_cpu(vram_module->usModuleSize));\n\t\t\t\t\t}\n\t\t\t\t\tmem_info->mem_vendor = vram_module->ucMemoryVenderID & 0xf;\n\t\t\t\t\tmem_info->mem_type = vram_module->ucMemoryType & 0xf0;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nint radeon_atom_get_mclk_range_table(struct radeon_device *rdev,\n\t\t\t\t     bool gddr5, u8 module_index,\n\t\t\t\t     struct atom_memory_clock_range_table *mclk_range_table)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\n\tu8 frev, crev, i;\n\tu16 data_offset, size;\n\tunion vram_info *vram_info;\n\tu32 mem_timing_size = gddr5 ?\n\t\tsizeof(ATOM_MEMORY_TIMING_FORMAT_V2) : sizeof(ATOM_MEMORY_TIMING_FORMAT);\n\n\tmemset(mclk_range_table, 0, sizeof(struct atom_memory_clock_range_table));\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvram_info = (union vram_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tswitch (crev) {\n\t\t\tcase 3:\n\t\t\t\tDRM_ERROR(\"old table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\tcase 4:\n\t\t\t\t \n\t\t\t\tif (module_index < vram_info->v1_4.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_VRAM_MODULE_V4 *vram_module =\n\t\t\t\t\t\t(ATOM_VRAM_MODULE_V4 *)vram_info->v1_4.aVramInfo;\n\t\t\t\t\tATOM_MEMORY_TIMING_FORMAT *format;\n\n\t\t\t\t\tfor (i = 0; i < module_index; i++) {\n\t\t\t\t\t\tif (le16_to_cpu(vram_module->usModuleSize) == 0)\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\tvram_module = (ATOM_VRAM_MODULE_V4 *)\n\t\t\t\t\t\t\t((u8 *)vram_module + le16_to_cpu(vram_module->usModuleSize));\n\t\t\t\t\t}\n\t\t\t\t\tmclk_range_table->num_entries = (u8)\n\t\t\t\t\t\t((le16_to_cpu(vram_module->usModuleSize) - offsetof(ATOM_VRAM_MODULE_V4, asMemTiming)) /\n\t\t\t\t\t\t mem_timing_size);\n\t\t\t\t\tformat = &vram_module->asMemTiming[0];\n\t\t\t\t\tfor (i = 0; i < mclk_range_table->num_entries; i++) {\n\t\t\t\t\t\tmclk_range_table->mclk[i] = le32_to_cpu(format->ulClkRange);\n\t\t\t\t\t\tformat = (ATOM_MEMORY_TIMING_FORMAT *)\n\t\t\t\t\t\t\t((u8 *)format + mem_timing_size);\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tDRM_ERROR(\"new table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n#define MEM_ID_MASK           0xff000000\n#define MEM_ID_SHIFT          24\n#define CLOCK_RANGE_MASK      0x00ffffff\n#define CLOCK_RANGE_SHIFT     0\n#define LOW_NIBBLE_MASK       0xf\n#define DATA_EQU_PREV         0\n#define DATA_FROM_TABLE       4\n\nint radeon_atom_init_mc_reg_table(struct radeon_device *rdev,\n\t\t\t\t  u8 module_index,\n\t\t\t\t  struct atom_mc_reg_table *reg_table)\n{\n\tint index = GetIndexIntoMasterTable(DATA, VRAM_Info);\n\tu8 frev, crev, num_entries, t_mem_id, num_ranges = 0;\n\tu32 i = 0, j;\n\tu16 data_offset, size;\n\tunion vram_info *vram_info;\n\n\tmemset(reg_table, 0, sizeof(struct atom_mc_reg_table));\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, &size,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tvram_info = (union vram_info *)\n\t\t\t(rdev->mode_info.atom_context->bios + data_offset);\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tDRM_ERROR(\"old table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\tcase 2:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\t\tif (module_index < vram_info->v2_1.ucNumOfVRAMModule) {\n\t\t\t\t\tATOM_INIT_REG_BLOCK *reg_block =\n\t\t\t\t\t\t(ATOM_INIT_REG_BLOCK *)\n\t\t\t\t\t\t((u8 *)vram_info + le16_to_cpu(vram_info->v2_1.usMemClkPatchTblOffset));\n\t\t\t\t\tATOM_MEMORY_SETTING_DATA_BLOCK *reg_data =\n\t\t\t\t\t\t(ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t\t\t\t((u8 *)reg_block + (2 * sizeof(u16)) +\n\t\t\t\t\t\t le16_to_cpu(reg_block->usRegIndexTblSize));\n\t\t\t\t\tATOM_INIT_REG_INDEX_FORMAT *format = &reg_block->asRegIndexBuf[0];\n\t\t\t\t\tnum_entries = (u8)((le16_to_cpu(reg_block->usRegIndexTblSize)) /\n\t\t\t\t\t\t\t   sizeof(ATOM_INIT_REG_INDEX_FORMAT)) - 1;\n\t\t\t\t\tif (num_entries > VBIOS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\twhile (i < num_entries) {\n\t\t\t\t\t\tif (format->ucPreRegDataLength & ACCESS_PLACEHOLDER)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\treg_table->mc_reg_address[i].s1 =\n\t\t\t\t\t\t\t(u16)(le16_to_cpu(format->usRegIndex));\n\t\t\t\t\t\treg_table->mc_reg_address[i].pre_reg_data =\n\t\t\t\t\t\t\t(u8)(format->ucPreRegDataLength);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tformat = (ATOM_INIT_REG_INDEX_FORMAT *)\n\t\t\t\t\t\t\t((u8 *)format + sizeof(ATOM_INIT_REG_INDEX_FORMAT));\n\t\t\t\t\t}\n\t\t\t\t\treg_table->last = i;\n\t\t\t\t\twhile ((le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK) &&\n\t\t\t\t\t       (num_ranges < VBIOS_MAX_AC_TIMING_ENTRIES)) {\n\t\t\t\t\t\tt_mem_id = (u8)((le32_to_cpu(*(u32 *)reg_data) & MEM_ID_MASK)\n\t\t\t\t\t\t\t\t>> MEM_ID_SHIFT);\n\t\t\t\t\t\tif (module_index == t_mem_id) {\n\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mclk_max =\n\t\t\t\t\t\t\t\t(u32)((le32_to_cpu(*(u32 *)reg_data) & CLOCK_RANGE_MASK)\n\t\t\t\t\t\t\t\t      >> CLOCK_RANGE_SHIFT);\n\t\t\t\t\t\t\tfor (i = 0, j = 1; i < reg_table->last; i++) {\n\t\t\t\t\t\t\t\tif ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_FROM_TABLE) {\n\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\t\t\t\t(u32)le32_to_cpu(*((u32 *)reg_data + j));\n\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t} else if ((reg_table->mc_reg_address[i].pre_reg_data & LOW_NIBBLE_MASK) == DATA_EQU_PREV) {\n\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i] =\n\t\t\t\t\t\t\t\t\t\treg_table->mc_reg_table_entry[num_ranges].mc_data[i - 1];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum_ranges++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treg_data = (ATOM_MEMORY_SETTING_DATA_BLOCK *)\n\t\t\t\t\t\t\t((u8 *)reg_data + le16_to_cpu(reg_block->usRegDataBlkSize));\n\t\t\t\t\t}\n\t\t\t\t\tif (le32_to_cpu(*(u32 *)reg_data) != END_OF_REG_DATA_BLOCK)\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\treg_table->num_entries = num_ranges;\n\t\t\t\t} else\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nvoid radeon_atom_initialize_bios_scratch_regs(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tuint32_t bios_2_scratch, bios_6_scratch;\n\n\tif (rdev->family >= CHIP_R600) {\n\t\tbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\n\t\tbios_6_scratch = RREG32(R600_BIOS_6_SCRATCH);\n\t} else {\n\t\tbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\n\t\tbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\n\t}\n\n\t \n\tbios_2_scratch &= ~ATOM_S2_VRI_BRIGHT_ENABLE;\n\n\t \n\tbios_6_scratch |= ATOM_S6_ACC_BLOCK_DISPLAY_SWITCH;\n\n\t \n\tif (ASIC_IS_DCE4(rdev))\n\t\tbios_2_scratch &= ~ATOM_S2_DEVICE_DPMS_STATE;\n\n\tif (rdev->family >= CHIP_R600) {\n\t\tWREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);\n\t\tWREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);\n\t} else {\n\t\tWREG32(RADEON_BIOS_2_SCRATCH, bios_2_scratch);\n\t\tWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\n\t}\n\n}\n\nvoid radeon_save_bios_scratch_regs(struct radeon_device *rdev)\n{\n\tuint32_t scratch_reg;\n\tint i;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tscratch_reg = R600_BIOS_0_SCRATCH;\n\telse\n\t\tscratch_reg = RADEON_BIOS_0_SCRATCH;\n\n\tfor (i = 0; i < RADEON_BIOS_NUM_SCRATCH; i++)\n\t\trdev->bios_scratch[i] = RREG32(scratch_reg + (i * 4));\n}\n\nvoid radeon_restore_bios_scratch_regs(struct radeon_device *rdev)\n{\n\tuint32_t scratch_reg;\n\tint i;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tscratch_reg = R600_BIOS_0_SCRATCH;\n\telse\n\t\tscratch_reg = RADEON_BIOS_0_SCRATCH;\n\n\tfor (i = 0; i < RADEON_BIOS_NUM_SCRATCH; i++)\n\t\tWREG32(scratch_reg + (i * 4), rdev->bios_scratch[i]);\n}\n\nvoid radeon_atom_output_lock(struct drm_encoder *encoder, bool lock)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tuint32_t bios_6_scratch;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tbios_6_scratch = RREG32(R600_BIOS_6_SCRATCH);\n\telse\n\t\tbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\n\n\tif (lock) {\n\t\tbios_6_scratch |= ATOM_S6_CRITICAL_STATE;\n\t\tbios_6_scratch &= ~ATOM_S6_ACC_MODE;\n\t} else {\n\t\tbios_6_scratch &= ~ATOM_S6_CRITICAL_STATE;\n\t\tbios_6_scratch |= ATOM_S6_ACC_MODE;\n\t}\n\n\tif (rdev->family >= CHIP_R600)\n\t\tWREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);\n\telse\n\t\tWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\n}\n\n \nvoid\nradeon_atombios_connected_scratch_regs(struct drm_connector *connector,\n\t\t\t\t       struct drm_encoder *encoder,\n\t\t\t\t       bool connected)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector =\n\t    to_radeon_connector(connector);\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tuint32_t bios_0_scratch, bios_3_scratch, bios_6_scratch;\n\n\tif (rdev->family >= CHIP_R600) {\n\t\tbios_0_scratch = RREG32(R600_BIOS_0_SCRATCH);\n\t\tbios_3_scratch = RREG32(R600_BIOS_3_SCRATCH);\n\t\tbios_6_scratch = RREG32(R600_BIOS_6_SCRATCH);\n\t} else {\n\t\tbios_0_scratch = RREG32(RADEON_BIOS_0_SCRATCH);\n\t\tbios_3_scratch = RREG32(RADEON_BIOS_3_SCRATCH);\n\t\tbios_6_scratch = RREG32(RADEON_BIOS_6_SCRATCH);\n\t}\n\n\tif ((radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"TV1 connected\\n\");\n\t\t\tbios_3_scratch |= ATOM_S3_TV1_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_TV1;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"TV1 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_TV1_MASK;\n\t\t\tbios_3_scratch &= ~ATOM_S3_TV1_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_TV1;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_CV_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"CV connected\\n\");\n\t\t\tbios_3_scratch |= ATOM_S3_CV_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_CV;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"CV disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_CV_MASK;\n\t\t\tbios_3_scratch &= ~ATOM_S3_CV_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_CV;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_LCD1_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"LCD1 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_LCD1;\n\t\t\tbios_3_scratch |= ATOM_S3_LCD1_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_LCD1;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"LCD1 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_LCD1;\n\t\t\tbios_3_scratch &= ~ATOM_S3_LCD1_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_LCD1;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"CRT1 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_CRT1_COLOR;\n\t\t\tbios_3_scratch |= ATOM_S3_CRT1_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_CRT1;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"CRT1 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_CRT1_MASK;\n\t\t\tbios_3_scratch &= ~ATOM_S3_CRT1_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_CRT1;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"CRT2 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_CRT2_COLOR;\n\t\t\tbios_3_scratch |= ATOM_S3_CRT2_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_CRT2;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"CRT2 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_CRT2_MASK;\n\t\t\tbios_3_scratch &= ~ATOM_S3_CRT2_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_CRT2;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_DFP1_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"DFP1 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_DFP1;\n\t\t\tbios_3_scratch |= ATOM_S3_DFP1_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_DFP1;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"DFP1 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_DFP1;\n\t\t\tbios_3_scratch &= ~ATOM_S3_DFP1_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP1;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_DFP2_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"DFP2 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_DFP2;\n\t\t\tbios_3_scratch |= ATOM_S3_DFP2_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_DFP2;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"DFP2 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_DFP2;\n\t\t\tbios_3_scratch &= ~ATOM_S3_DFP2_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP2;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_DFP3_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_DFP3_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"DFP3 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_DFP3;\n\t\t\tbios_3_scratch |= ATOM_S3_DFP3_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_DFP3;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"DFP3 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_DFP3;\n\t\t\tbios_3_scratch &= ~ATOM_S3_DFP3_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP3;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_DFP4_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_DFP4_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"DFP4 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_DFP4;\n\t\t\tbios_3_scratch |= ATOM_S3_DFP4_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_DFP4;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"DFP4 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_DFP4;\n\t\t\tbios_3_scratch &= ~ATOM_S3_DFP4_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP4;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_DFP5_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_DFP5_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"DFP5 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_DFP5;\n\t\t\tbios_3_scratch |= ATOM_S3_DFP5_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_DFP5;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"DFP5 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_DFP5;\n\t\t\tbios_3_scratch &= ~ATOM_S3_DFP5_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP5;\n\t\t}\n\t}\n\tif ((radeon_encoder->devices & ATOM_DEVICE_DFP6_SUPPORT) &&\n\t    (radeon_connector->devices & ATOM_DEVICE_DFP6_SUPPORT)) {\n\t\tif (connected) {\n\t\t\tDRM_DEBUG_KMS(\"DFP6 connected\\n\");\n\t\t\tbios_0_scratch |= ATOM_S0_DFP6;\n\t\t\tbios_3_scratch |= ATOM_S3_DFP6_ACTIVE;\n\t\t\tbios_6_scratch |= ATOM_S6_ACC_REQ_DFP6;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"DFP6 disconnected\\n\");\n\t\t\tbios_0_scratch &= ~ATOM_S0_DFP6;\n\t\t\tbios_3_scratch &= ~ATOM_S3_DFP6_ACTIVE;\n\t\t\tbios_6_scratch &= ~ATOM_S6_ACC_REQ_DFP6;\n\t\t}\n\t}\n\n\tif (rdev->family >= CHIP_R600) {\n\t\tWREG32(R600_BIOS_0_SCRATCH, bios_0_scratch);\n\t\tWREG32(R600_BIOS_3_SCRATCH, bios_3_scratch);\n\t\tWREG32(R600_BIOS_6_SCRATCH, bios_6_scratch);\n\t} else {\n\t\tWREG32(RADEON_BIOS_0_SCRATCH, bios_0_scratch);\n\t\tWREG32(RADEON_BIOS_3_SCRATCH, bios_3_scratch);\n\t\tWREG32(RADEON_BIOS_6_SCRATCH, bios_6_scratch);\n\t}\n}\n\nvoid\nradeon_atombios_encoder_crtc_scratch_regs(struct drm_encoder *encoder, int crtc)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tuint32_t bios_3_scratch;\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\treturn;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tbios_3_scratch = RREG32(R600_BIOS_3_SCRATCH);\n\telse\n\t\tbios_3_scratch = RREG32(RADEON_BIOS_3_SCRATCH);\n\n\tif (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_TV1_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 18);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_CV_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_CV_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 24);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_CRT1_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 16);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_CRT2_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 20);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_LCD1_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 17);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_DFP1_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 19);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_DFP2_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 23);\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP3_SUPPORT) {\n\t\tbios_3_scratch &= ~ATOM_S3_DFP3_CRTC_ACTIVE;\n\t\tbios_3_scratch |= (crtc << 25);\n\t}\n\n\tif (rdev->family >= CHIP_R600)\n\t\tWREG32(R600_BIOS_3_SCRATCH, bios_3_scratch);\n\telse\n\t\tWREG32(RADEON_BIOS_3_SCRATCH, bios_3_scratch);\n}\n\nvoid\nradeon_atombios_encoder_dpms_scratch_regs(struct drm_encoder *encoder, bool on)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tuint32_t bios_2_scratch;\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\treturn;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\n\telse\n\t\tbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\n\n\tif (radeon_encoder->devices & ATOM_DEVICE_TV1_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_TV1_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_TV1_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_CV_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_CV_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_CV_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_CRT1_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_CRT1_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_CRT1_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_CRT2_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_CRT2_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_CRT2_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_LCD1_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_LCD1_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP1_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_DFP1_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_DFP1_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_DFP2_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_DFP2_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP3_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_DFP3_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_DFP3_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP4_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_DFP4_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_DFP4_DPMS_STATE;\n\t}\n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP5_SUPPORT) {\n\t\tif (on)\n\t\t\tbios_2_scratch &= ~ATOM_S2_DFP5_DPMS_STATE;\n\t\telse\n\t\t\tbios_2_scratch |= ATOM_S2_DFP5_DPMS_STATE;\n\t}\n\n\tif (rdev->family >= CHIP_R600)\n\t\tWREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);\n\telse\n\t\tWREG32(RADEON_BIOS_2_SCRATCH, bios_2_scratch);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}