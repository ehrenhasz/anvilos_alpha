{
  "module_name": "radeon_acpi.c",
  "hash_id": "27418a6430d02c1f77324fb5c5fe5c92071e4779146d0eb6ee71413dabf388b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_acpi.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/backlight.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/power_supply.h>\n#include <linux/slab.h>\n\n#include <acpi/acpi_bus.h>\n#include <acpi/video.h>\n\n#include <drm/drm_probe_helper.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_acpi.h\"\n#include \"radeon_pm.h\"\n\n#if defined(CONFIG_VGA_SWITCHEROO)\nbool radeon_atpx_dgpu_req_power_for_displays(void);\n#else\nstatic inline bool radeon_atpx_dgpu_req_power_for_displays(void) { return false; }\n#endif\n\n#define ACPI_AC_CLASS           \"ac_adapter\"\n\nstruct atif_verify_interface {\n\tu16 size;\t\t \n\tu16 version;\t\t \n\tu32 notification_mask;\t \n\tu32 function_bits;\t \n} __packed;\n\nstruct atif_system_params {\n\tu16 size;\t\t \n\tu32 valid_mask;\t\t \n\tu32 flags;\t\t \n\tu8 command_code;\t \n} __packed;\n\nstruct atif_sbios_requests {\n\tu16 size;\t\t \n\tu32 pending;\t\t \n\tu8 panel_exp_mode;\t \n\tu8 thermal_gfx;\t\t \n\tu8 thermal_state;\t \n\tu8 forced_power_gfx;\t \n\tu8 forced_power_state;\t \n\tu8 system_power_src;\t \n\tu8 backlight_level;\t \n} __packed;\n\n#define ATIF_NOTIFY_MASK\t0x3\n#define ATIF_NOTIFY_NONE\t0\n#define ATIF_NOTIFY_81\t\t1\n#define ATIF_NOTIFY_N\t\t2\n\nstruct atcs_verify_interface {\n\tu16 size;\t\t \n\tu16 version;\t\t \n\tu32 function_bits;\t \n} __packed;\n\n#define ATCS_VALID_FLAGS_MASK\t0x3\n\nstruct atcs_pref_req_input {\n\tu16 size;\t\t \n\tu16 client_id;\t\t \n\tu16 valid_flags_mask;\t \n\tu16 flags;\t\t \n\tu8 req_type;\t\t \n\tu8 perf_req;\t\t \n} __packed;\n\nstruct atcs_pref_req_output {\n\tu16 size;\t\t \n\tu8 ret_val;\t\t \n} __packed;\n\n \n \nstatic union acpi_object *radeon_atif_call(acpi_handle handle, int function,\n\t\tstruct acpi_buffer *params)\n{\n\tacpi_status status;\n\tunion acpi_object atif_arg_elements[2];\n\tstruct acpi_object_list atif_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tatif_arg.count = 2;\n\tatif_arg.pointer = &atif_arg_elements[0];\n\n\tatif_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatif_arg_elements[0].integer.value = function;\n\n\tif (params) {\n\t\tatif_arg_elements[1].type = ACPI_TYPE_BUFFER;\n\t\tatif_arg_elements[1].buffer.length = params->length;\n\t\tatif_arg_elements[1].buffer.pointer = params->pointer;\n\t} else {\n\t\t \n\t\tatif_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\t\tatif_arg_elements[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, \"ATIF\", &atif_arg, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tDRM_DEBUG_DRIVER(\"failed to evaluate ATIF got %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\n \nstatic void radeon_atif_parse_notification(struct radeon_atif_notifications *n, u32 mask)\n{\n\tn->display_switch = mask & ATIF_DISPLAY_SWITCH_REQUEST_SUPPORTED;\n\tn->expansion_mode_change = mask & ATIF_EXPANSION_MODE_CHANGE_REQUEST_SUPPORTED;\n\tn->thermal_state = mask & ATIF_THERMAL_STATE_CHANGE_REQUEST_SUPPORTED;\n\tn->forced_power_state = mask & ATIF_FORCED_POWER_STATE_CHANGE_REQUEST_SUPPORTED;\n\tn->system_power_state = mask & ATIF_SYSTEM_POWER_SOURCE_CHANGE_REQUEST_SUPPORTED;\n\tn->display_conf_change = mask & ATIF_DISPLAY_CONF_CHANGE_REQUEST_SUPPORTED;\n\tn->px_gfx_switch = mask & ATIF_PX_GFX_SWITCH_REQUEST_SUPPORTED;\n\tn->brightness_change = mask & ATIF_PANEL_BRIGHTNESS_CHANGE_REQUEST_SUPPORTED;\n\tn->dgpu_display_event = mask & ATIF_DGPU_DISPLAY_EVENT_SUPPORTED;\n}\n\n \nstatic void radeon_atif_parse_functions(struct radeon_atif_functions *f, u32 mask)\n{\n\tf->system_params = mask & ATIF_GET_SYSTEM_PARAMETERS_SUPPORTED;\n\tf->sbios_requests = mask & ATIF_GET_SYSTEM_BIOS_REQUESTS_SUPPORTED;\n\tf->select_active_disp = mask & ATIF_SELECT_ACTIVE_DISPLAYS_SUPPORTED;\n\tf->lid_state = mask & ATIF_GET_LID_STATE_SUPPORTED;\n\tf->get_tv_standard = mask & ATIF_GET_TV_STANDARD_FROM_CMOS_SUPPORTED;\n\tf->set_tv_standard = mask & ATIF_SET_TV_STANDARD_IN_CMOS_SUPPORTED;\n\tf->get_panel_expansion_mode = mask & ATIF_GET_PANEL_EXPANSION_MODE_FROM_CMOS_SUPPORTED;\n\tf->set_panel_expansion_mode = mask & ATIF_SET_PANEL_EXPANSION_MODE_IN_CMOS_SUPPORTED;\n\tf->temperature_change = mask & ATIF_TEMPERATURE_CHANGE_NOTIFICATION_SUPPORTED;\n\tf->graphics_device_types = mask & ATIF_GET_GRAPHICS_DEVICE_TYPES_SUPPORTED;\n}\n\n \nstatic int radeon_atif_verify_interface(acpi_handle handle,\n\t\tstruct radeon_atif *atif)\n{\n\tunion acpi_object *info;\n\tstruct atif_verify_interface output;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = radeon_atif_call(handle, ATIF_FUNCTION_VERIFY_INTERFACE, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tmemset(&output, 0, sizeof(output));\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 12) {\n\t\tDRM_INFO(\"ATIF buffer is too small: %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = min(sizeof(output), size);\n\n\tmemcpy(&output, info->buffer.pointer, size);\n\n\t \n\tDRM_DEBUG_DRIVER(\"ATIF version %u\\n\", output.version);\n\n\tradeon_atif_parse_notification(&atif->notifications, output.notification_mask);\n\tradeon_atif_parse_functions(&atif->functions, output.function_bits);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int radeon_atif_get_notification_params(acpi_handle handle,\n\t\tstruct radeon_atif_notification_cfg *n)\n{\n\tunion acpi_object *info;\n\tstruct atif_system_params params;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = radeon_atif_call(handle, ATIF_FUNCTION_GET_SYSTEM_PARAMETERS, NULL);\n\tif (!info) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 10) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\tsize = min(sizeof(params), size);\n\tmemcpy(&params, info->buffer.pointer, size);\n\n\tDRM_DEBUG_DRIVER(\"SYSTEM_PARAMS: mask = %#x, flags = %#x\\n\",\n\t\t\tparams.flags, params.valid_mask);\n\tparams.flags = params.flags & params.valid_mask;\n\n\tif ((params.flags & ATIF_NOTIFY_MASK) == ATIF_NOTIFY_NONE) {\n\t\tn->enabled = false;\n\t\tn->command_code = 0;\n\t} else if ((params.flags & ATIF_NOTIFY_MASK) == ATIF_NOTIFY_81) {\n\t\tn->enabled = true;\n\t\tn->command_code = 0x81;\n\t} else {\n\t\tif (size < 11) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tn->enabled = true;\n\t\tn->command_code = params.command_code;\n\t}\n\nout:\n\tDRM_DEBUG_DRIVER(\"Notification %s, command code = %#x\\n\",\n\t\t\t(n->enabled ? \"enabled\" : \"disabled\"),\n\t\t\tn->command_code);\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int radeon_atif_get_sbios_requests(acpi_handle handle,\n\t\tstruct atif_sbios_requests *req)\n{\n\tunion acpi_object *info;\n\tsize_t size;\n\tint count = 0;\n\n\tinfo = radeon_atif_call(handle, ATIF_FUNCTION_GET_SYSTEM_BIOS_REQUESTS, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tsize = *(u16 *)info->buffer.pointer;\n\tif (size < 0xd) {\n\t\tcount = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemset(req, 0, sizeof(*req));\n\n\tsize = min(sizeof(*req), size);\n\tmemcpy(req, info->buffer.pointer, size);\n\tDRM_DEBUG_DRIVER(\"SBIOS pending requests: %#x\\n\", req->pending);\n\n\tcount = hweight32(req->pending);\n\nout:\n\tkfree(info);\n\treturn count;\n}\n\n \nstatic int radeon_atif_handler(struct radeon_device *rdev,\n\t\tstruct acpi_bus_event *event)\n{\n\tstruct radeon_atif *atif = &rdev->atif;\n\tstruct atif_sbios_requests req;\n\tacpi_handle handle;\n\tint count;\n\n\tDRM_DEBUG_DRIVER(\"event, device_class = %s, type = %#x\\n\",\n\t\t\tevent->device_class, event->type);\n\n\tif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\n\t\treturn NOTIFY_DONE;\n\n\tif (!atif->notification_cfg.enabled ||\n\t\t\tevent->type != atif->notification_cfg.command_code)\n\t\t \n\t\treturn NOTIFY_DONE;\n\n\t \n\thandle = ACPI_HANDLE(&rdev->pdev->dev);\n\tcount = radeon_atif_get_sbios_requests(handle, &req);\n\n\tif (count <= 0)\n\t\treturn NOTIFY_DONE;\n\n\tDRM_DEBUG_DRIVER(\"ATIF: %d pending SBIOS requests\\n\", count);\n\n\tif (req.pending & ATIF_PANEL_BRIGHTNESS_CHANGE_REQUEST) {\n\t\tstruct radeon_encoder *enc = atif->encoder_for_bl;\n\n\t\tif (enc) {\n\t\t\tDRM_DEBUG_DRIVER(\"Changing brightness to %d\\n\",\n\t\t\t\t\treq.backlight_level);\n\n\t\t\tradeon_set_backlight_level(rdev, enc, req.backlight_level);\n\n\t\t\tif (rdev->is_atom_bios) {\n\t\t\t\tstruct radeon_encoder_atom_dig *dig = enc->enc_priv;\n\t\t\t\tbacklight_force_update(dig->bl_dev,\n\t\t\t\t\t\t       BACKLIGHT_UPDATE_HOTKEY);\n\t\t\t} else {\n\t\t\t\tstruct radeon_encoder_lvds *dig = enc->enc_priv;\n\t\t\t\tbacklight_force_update(dig->bl_dev,\n\t\t\t\t\t\t       BACKLIGHT_UPDATE_HOTKEY);\n\t\t\t}\n\t\t}\n\t}\n\tif (req.pending & ATIF_DGPU_DISPLAY_EVENT) {\n\t\tif ((rdev->flags & RADEON_IS_PX) &&\n\t\t    radeon_atpx_dgpu_req_power_for_displays()) {\n\t\t\tpm_runtime_get_sync(rdev->ddev->dev);\n\t\t\t \n\t\t\tdrm_helper_hpd_irq_event(rdev->ddev);\n\t\t\tpm_runtime_mark_last_busy(rdev->ddev->dev);\n\t\t\tpm_runtime_put_autosuspend(rdev->ddev->dev);\n\t\t}\n\t}\n\t \n\n\t \n\treturn NOTIFY_BAD;\n}\n\n \n \nstatic union acpi_object *radeon_atcs_call(acpi_handle handle, int function,\n\t\t\t\t\t   struct acpi_buffer *params)\n{\n\tacpi_status status;\n\tunion acpi_object atcs_arg_elements[2];\n\tstruct acpi_object_list atcs_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tatcs_arg.count = 2;\n\tatcs_arg.pointer = &atcs_arg_elements[0];\n\n\tatcs_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatcs_arg_elements[0].integer.value = function;\n\n\tif (params) {\n\t\tatcs_arg_elements[1].type = ACPI_TYPE_BUFFER;\n\t\tatcs_arg_elements[1].buffer.length = params->length;\n\t\tatcs_arg_elements[1].buffer.pointer = params->pointer;\n\t} else {\n\t\t \n\t\tatcs_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\t\tatcs_arg_elements[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, \"ATCS\", &atcs_arg, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tDRM_DEBUG_DRIVER(\"failed to evaluate ATCS got %s\\n\",\n\t\t\t\t acpi_format_exception(status));\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\n \nstatic void radeon_atcs_parse_functions(struct radeon_atcs_functions *f, u32 mask)\n{\n\tf->get_ext_state = mask & ATCS_GET_EXTERNAL_STATE_SUPPORTED;\n\tf->pcie_perf_req = mask & ATCS_PCIE_PERFORMANCE_REQUEST_SUPPORTED;\n\tf->pcie_dev_rdy = mask & ATCS_PCIE_DEVICE_READY_NOTIFICATION_SUPPORTED;\n\tf->pcie_bus_width = mask & ATCS_SET_PCIE_BUS_WIDTH_SUPPORTED;\n}\n\n \nstatic int radeon_atcs_verify_interface(acpi_handle handle,\n\t\t\t\t\tstruct radeon_atcs *atcs)\n{\n\tunion acpi_object *info;\n\tstruct atcs_verify_interface output;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = radeon_atcs_call(handle, ATCS_FUNCTION_VERIFY_INTERFACE, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tmemset(&output, 0, sizeof(output));\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 8) {\n\t\tDRM_INFO(\"ATCS buffer is too small: %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = min(sizeof(output), size);\n\n\tmemcpy(&output, info->buffer.pointer, size);\n\n\t \n\tDRM_DEBUG_DRIVER(\"ATCS version %u\\n\", output.version);\n\n\tradeon_atcs_parse_functions(&atcs->functions, output.function_bits);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nbool radeon_acpi_is_pcie_performance_request_supported(struct radeon_device *rdev)\n{\n\tstruct radeon_atcs *atcs = &rdev->atcs;\n\n\tif (atcs->functions.pcie_perf_req && atcs->functions.pcie_dev_rdy)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint radeon_acpi_pcie_notify_device_ready(struct radeon_device *rdev)\n{\n\tacpi_handle handle;\n\tunion acpi_object *info;\n\tstruct radeon_atcs *atcs = &rdev->atcs;\n\n\t \n\thandle = ACPI_HANDLE(&rdev->pdev->dev);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tif (!atcs->functions.pcie_dev_rdy)\n\t\treturn -EINVAL;\n\n\tinfo = radeon_atcs_call(handle, ATCS_FUNCTION_PCIE_DEVICE_READY_NOTIFICATION, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tkfree(info);\n\n\treturn 0;\n}\n\n \nint radeon_acpi_pcie_performance_request(struct radeon_device *rdev,\n\t\t\t\t\t u8 perf_req, bool advertise)\n{\n\tacpi_handle handle;\n\tunion acpi_object *info;\n\tstruct radeon_atcs *atcs = &rdev->atcs;\n\tstruct atcs_pref_req_input atcs_input;\n\tstruct atcs_pref_req_output atcs_output;\n\tstruct acpi_buffer params;\n\tsize_t size;\n\tu32 retry = 3;\n\n\t \n\thandle = ACPI_HANDLE(&rdev->pdev->dev);\n\tif (!handle)\n\t\treturn -EINVAL;\n\n\tif (!atcs->functions.pcie_perf_req)\n\t\treturn -EINVAL;\n\n\tatcs_input.size = sizeof(struct atcs_pref_req_input);\n\t \n\tatcs_input.client_id = pci_dev_id(rdev->pdev);\n\tatcs_input.valid_flags_mask = ATCS_VALID_FLAGS_MASK;\n\tatcs_input.flags = ATCS_WAIT_FOR_COMPLETION;\n\tif (advertise)\n\t\tatcs_input.flags |= ATCS_ADVERTISE_CAPS;\n\tatcs_input.req_type = ATCS_PCIE_LINK_SPEED;\n\tatcs_input.perf_req = perf_req;\n\n\tparams.length = sizeof(struct atcs_pref_req_input);\n\tparams.pointer = &atcs_input;\n\n\twhile (retry--) {\n\t\tinfo = radeon_atcs_call(handle, ATCS_FUNCTION_PCIE_PERFORMANCE_REQUEST, &params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\n\t\tmemset(&atcs_output, 0, sizeof(atcs_output));\n\n\t\tsize = *(u16 *) info->buffer.pointer;\n\t\tif (size < 3) {\n\t\t\tDRM_INFO(\"ATCS buffer is too small: %zu\\n\", size);\n\t\t\tkfree(info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = min(sizeof(atcs_output), size);\n\n\t\tmemcpy(&atcs_output, info->buffer.pointer, size);\n\n\t\tkfree(info);\n\n\t\tswitch (atcs_output.ret_val) {\n\t\tcase ATCS_REQUEST_REFUSED:\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\tcase ATCS_REQUEST_COMPLETE:\n\t\t\treturn 0;\n\t\tcase ATCS_REQUEST_IN_PROGRESS:\n\t\t\tudelay(10);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int radeon_acpi_event(struct notifier_block *nb,\n\t\t\t     unsigned long val,\n\t\t\t     void *data)\n{\n\tstruct radeon_device *rdev = container_of(nb, struct radeon_device, acpi_nb);\n\tstruct acpi_bus_event *entry = (struct acpi_bus_event *)data;\n\n\tif (strcmp(entry->device_class, ACPI_AC_CLASS) == 0) {\n\t\tif (power_supply_is_system_supplied() > 0)\n\t\t\tDRM_DEBUG_DRIVER(\"pm: AC\\n\");\n\t\telse\n\t\t\tDRM_DEBUG_DRIVER(\"pm: DC\\n\");\n\n\t\tradeon_pm_acpi_event_handler(rdev);\n\t}\n\n\t \n\treturn radeon_atif_handler(rdev, entry);\n}\n\n \n \nint radeon_acpi_init(struct radeon_device *rdev)\n{\n\tacpi_handle handle;\n\tstruct radeon_atif *atif = &rdev->atif;\n\tstruct radeon_atcs *atcs = &rdev->atcs;\n\tint ret;\n\n\t \n\thandle = ACPI_HANDLE(&rdev->pdev->dev);\n\n\t \n\tif (!ASIC_IS_AVIVO(rdev) || !rdev->bios || !handle)\n\t\treturn 0;\n\n\t \n\tret = radeon_atcs_verify_interface(handle, atcs);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Call to ATCS verify_interface failed: %d\\n\", ret);\n\t}\n\n\t \n\tret = radeon_atif_verify_interface(handle, atif);\n\tif (ret) {\n\t\tDRM_DEBUG_DRIVER(\"Call to ATIF verify_interface failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (atif->notifications.brightness_change) {\n\t\tstruct drm_encoder *tmp;\n\t\tstruct radeon_encoder *target = NULL;\n\n\t\t \n\t\tlist_for_each_entry(tmp, &rdev->ddev->mode_config.encoder_list,\n\t\t\t\thead) {\n\t\t\tstruct radeon_encoder *enc = to_radeon_encoder(tmp);\n\n\t\t\tif ((enc->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\n\t\t\t    enc->enc_priv) {\n\t\t\t\tif (rdev->is_atom_bios) {\n\t\t\t\t\tstruct radeon_encoder_atom_dig *dig = enc->enc_priv;\n\t\t\t\t\tif (dig->bl_dev) {\n\t\t\t\t\t\ttarget = enc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstruct radeon_encoder_lvds *dig = enc->enc_priv;\n\t\t\t\t\tif (dig->bl_dev) {\n\t\t\t\t\t\ttarget = enc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tatif->encoder_for_bl = target;\n\t}\n\n\tif (atif->functions.sbios_requests && !atif->functions.system_params) {\n\t\t \n\t\tatif->functions.system_params = true;\n\t}\n\n\tif (atif->functions.system_params) {\n\t\tret = radeon_atif_get_notification_params(handle,\n\t\t\t\t&atif->notification_cfg);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG_DRIVER(\"Call to GET_SYSTEM_PARAMS failed: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t \n\t\t\tatif->notification_cfg.enabled = false;\n\t\t}\n\t}\n\nout:\n\trdev->acpi_nb.notifier_call = radeon_acpi_event;\n\tregister_acpi_notifier(&rdev->acpi_nb);\n\n\treturn ret;\n}\n\n \nvoid radeon_acpi_fini(struct radeon_device *rdev)\n{\n\tunregister_acpi_notifier(&rdev->acpi_nb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}