{
  "module_name": "rs600.c",
  "hash_id": "bb5175279fe2988622e6243bd14df3a06e00ca9555f0d850034684b45cec3e7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rs600.c",
  "human_readable_source": " \n \n\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/pci.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"rs600_reg_safe.h\"\n#include \"rs600d.h\"\n\nstatic void rs600_gpu_init(struct radeon_device *rdev);\nint rs600_mc_wait_for_idle(struct radeon_device *rdev);\n\nstatic const u32 crtc_offsets[2] =\n{\n\t0,\n\tAVIVO_D2CRTC_H_TOTAL - AVIVO_D1CRTC_H_TOTAL\n};\n\nstatic bool avivo_is_in_vblank(struct radeon_device *rdev, int crtc)\n{\n\tif (RREG32(AVIVO_D1CRTC_STATUS + crtc_offsets[crtc]) & AVIVO_D1CRTC_V_BLANK)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool avivo_is_counter_moving(struct radeon_device *rdev, int crtc)\n{\n\tu32 pos1, pos2;\n\n\tpos1 = RREG32(AVIVO_D1CRTC_STATUS_POSITION + crtc_offsets[crtc]);\n\tpos2 = RREG32(AVIVO_D1CRTC_STATUS_POSITION + crtc_offsets[crtc]);\n\n\tif (pos1 != pos2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nvoid avivo_wait_for_vblank(struct radeon_device *rdev, int crtc)\n{\n\tunsigned i = 0;\n\n\tif (crtc >= rdev->num_crtc)\n\t\treturn;\n\n\tif (!(RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[crtc]) & AVIVO_CRTC_EN))\n\t\treturn;\n\n\t \n\twhile (avivo_is_in_vblank(rdev, crtc)) {\n\t\tif (i++ % 100 == 0) {\n\t\t\tif (!avivo_is_counter_moving(rdev, crtc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (!avivo_is_in_vblank(rdev, crtc)) {\n\t\tif (i++ % 100 == 0) {\n\t\t\tif (!avivo_is_counter_moving(rdev, crtc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rs600_page_flip(struct radeon_device *rdev, int crtc_id, u64 crtc_base, bool async)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\tstruct drm_framebuffer *fb = radeon_crtc->base.primary->fb;\n\tu32 tmp = RREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset);\n\tint i;\n\n\t \n\ttmp |= AVIVO_D1GRPH_UPDATE_LOCK;\n\tWREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, tmp);\n\n\t \n\tWREG32(AVIVO_D1GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset,\n\t       async ? AVIVO_D1GRPH_SURFACE_UPDATE_H_RETRACE_EN : 0);\n\t \n\tWREG32(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset,\n\t       fb->pitches[0] / fb->format->cpp[0]);\n\t \n\tWREG32(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\n\t       (u32)crtc_base);\n\tWREG32(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\n\t       (u32)crtc_base);\n\n\t \n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset) & AVIVO_D1GRPH_SURFACE_UPDATE_PENDING)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tDRM_DEBUG(\"Update pending now high. Unlocking vupdate_lock.\\n\");\n\n\t \n\ttmp &= ~AVIVO_D1GRPH_UPDATE_LOCK;\n\tWREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, tmp);\n}\n\nbool rs600_page_flip_pending(struct radeon_device *rdev, int crtc_id)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\n\t \n\treturn !!(RREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset) &\n\t\tAVIVO_D1GRPH_SURFACE_UPDATE_PENDING);\n}\n\nvoid avivo_program_fmt(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tint bpc = 0;\n\tu32 tmp = 0;\n\tenum radeon_connector_dither dither = RADEON_FMT_DITHER_DISABLE;\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tbpc = radeon_get_monitor_bpc(connector);\n\t\tdither = radeon_connector->dither;\n\t}\n\n\t \n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD_SUPPORT)\n\t\treturn;\n\n\tif (bpc == 0)\n\t\treturn;\n\n\tswitch (bpc) {\n\tcase 6:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= AVIVO_TMDS_BIT_DEPTH_CONTROL_SPATIAL_DITHER_EN;\n\t\telse\n\t\t\ttmp |= AVIVO_TMDS_BIT_DEPTH_CONTROL_TRUNCATE_EN;\n\t\tbreak;\n\tcase 8:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (AVIVO_TMDS_BIT_DEPTH_CONTROL_SPATIAL_DITHER_EN |\n\t\t\t\tAVIVO_TMDS_BIT_DEPTH_CONTROL_SPATIAL_DITHER_DEPTH);\n\t\telse\n\t\t\ttmp |= (AVIVO_TMDS_BIT_DEPTH_CONTROL_TRUNCATE_EN |\n\t\t\t\tAVIVO_TMDS_BIT_DEPTH_CONTROL_TRUNCATE_DEPTH);\n\t\tbreak;\n\tcase 10:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\t\tWREG32(AVIVO_TMDSA_BIT_DEPTH_CONTROL, tmp);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\tWREG32(AVIVO_LVTMA_BIT_DEPTH_CONTROL, tmp);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\tWREG32(AVIVO_DVOA_BIT_DEPTH_CONTROL, tmp);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\t\tWREG32(AVIVO_DDIA_BIT_DEPTH_CONTROL, tmp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid rs600_pm_misc(struct radeon_device *rdev)\n{\n\tint requested_index = rdev->pm.requested_power_state_index;\n\tstruct radeon_power_state *ps = &rdev->pm.power_state[requested_index];\n\tstruct radeon_voltage *voltage = &ps->clock_info[0].voltage;\n\tu32 tmp, dyn_pwrmgt_sclk_length, dyn_sclk_vol_cntl;\n\tu32 hdp_dyn_cntl,   dyn_backbias_cntl;\n\n\tif ((voltage->type == VOLTAGE_GPIO) && (voltage->gpio.valid)) {\n\t\tif (ps->misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) {\n\t\t\ttmp = RREG32(voltage->gpio.reg);\n\t\t\tif (voltage->active_high)\n\t\t\t\ttmp |= voltage->gpio.mask;\n\t\t\telse\n\t\t\t\ttmp &= ~(voltage->gpio.mask);\n\t\t\tWREG32(voltage->gpio.reg, tmp);\n\t\t\tif (voltage->delay)\n\t\t\t\tudelay(voltage->delay);\n\t\t} else {\n\t\t\ttmp = RREG32(voltage->gpio.reg);\n\t\t\tif (voltage->active_high)\n\t\t\t\ttmp &= ~voltage->gpio.mask;\n\t\t\telse\n\t\t\t\ttmp |= voltage->gpio.mask;\n\t\t\tWREG32(voltage->gpio.reg, tmp);\n\t\t\tif (voltage->delay)\n\t\t\t\tudelay(voltage->delay);\n\t\t}\n\t} else if (voltage->type == VOLTAGE_VDDC)\n\t\tradeon_atom_set_voltage(rdev, voltage->vddc_id, SET_VOLTAGE_TYPE_ASIC_VDDC);\n\n\tdyn_pwrmgt_sclk_length = RREG32_PLL(DYN_PWRMGT_SCLK_LENGTH);\n\tdyn_pwrmgt_sclk_length &= ~REDUCED_POWER_SCLK_HILEN(0xf);\n\tdyn_pwrmgt_sclk_length &= ~REDUCED_POWER_SCLK_LOLEN(0xf);\n\tif (ps->misc & ATOM_PM_MISCINFO_ASIC_REDUCED_SPEED_SCLK_EN) {\n\t\tif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_CLOCK_DIVIDER_BY_2) {\n\t\t\tdyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_HILEN(2);\n\t\t\tdyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_LOLEN(2);\n\t\t} else if (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_CLOCK_DIVIDER_BY_4) {\n\t\t\tdyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_HILEN(4);\n\t\t\tdyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_LOLEN(4);\n\t\t}\n\t} else {\n\t\tdyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_HILEN(1);\n\t\tdyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_LOLEN(1);\n\t}\n\tWREG32_PLL(DYN_PWRMGT_SCLK_LENGTH, dyn_pwrmgt_sclk_length);\n\n\tdyn_sclk_vol_cntl = RREG32_PLL(DYN_SCLK_VOL_CNTL);\n\tif (ps->misc & ATOM_PM_MISCINFO_ASIC_DYNAMIC_VOLTAGE_EN) {\n\t\tdyn_sclk_vol_cntl |= IO_CG_VOLTAGE_DROP;\n\t\tif (voltage->delay) {\n\t\t\tdyn_sclk_vol_cntl |= VOLTAGE_DROP_SYNC;\n\t\t\tdyn_sclk_vol_cntl |= VOLTAGE_DELAY_SEL(voltage->delay);\n\t\t} else\n\t\t\tdyn_sclk_vol_cntl &= ~VOLTAGE_DROP_SYNC;\n\t} else\n\t\tdyn_sclk_vol_cntl &= ~IO_CG_VOLTAGE_DROP;\n\tWREG32_PLL(DYN_SCLK_VOL_CNTL, dyn_sclk_vol_cntl);\n\n\thdp_dyn_cntl = RREG32_PLL(HDP_DYN_CNTL);\n\tif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_HDP_BLOCK_EN)\n\t\thdp_dyn_cntl &= ~HDP_FORCEON;\n\telse\n\t\thdp_dyn_cntl |= HDP_FORCEON;\n\tWREG32_PLL(HDP_DYN_CNTL, hdp_dyn_cntl);\n#if 0\n\t \n\tmc_host_dyn_cntl = RREG32_PLL(MC_HOST_DYN_CNTL);\n\tif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_MC_HOST_BLOCK_EN)\n\t\tmc_host_dyn_cntl &= ~MC_HOST_FORCEON;\n\telse\n\t\tmc_host_dyn_cntl |= MC_HOST_FORCEON;\n\tWREG32_PLL(MC_HOST_DYN_CNTL, mc_host_dyn_cntl);\n#endif\n\tdyn_backbias_cntl = RREG32_PLL(DYN_BACKBIAS_CNTL);\n\tif (ps->misc & ATOM_PM_MISCINFO2_DYNAMIC_BACK_BIAS_EN)\n\t\tdyn_backbias_cntl |= IO_CG_BACKBIAS_EN;\n\telse\n\t\tdyn_backbias_cntl &= ~IO_CG_BACKBIAS_EN;\n\tWREG32_PLL(DYN_BACKBIAS_CNTL, dyn_backbias_cntl);\n\n\t \n\tif ((rdev->flags & RADEON_IS_PCIE) &&\n\t    !(rdev->flags & RADEON_IS_IGP) &&\n\t    rdev->asic->pm.set_pcie_lanes &&\n\t    (ps->pcie_lanes !=\n\t     rdev->pm.power_state[rdev->pm.current_power_state_index].pcie_lanes)) {\n\t\tradeon_set_pcie_lanes(rdev,\n\t\t\t\t      ps->pcie_lanes);\n\t\tDRM_DEBUG(\"Setting: p: %d\\n\", ps->pcie_lanes);\n\t}\n}\n\nvoid rs600_pm_prepare(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tu32 tmp;\n\n\t \n\tlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\n\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\tif (radeon_crtc->enabled) {\n\t\t\ttmp = RREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset);\n\t\t\ttmp |= AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\tWREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset, tmp);\n\t\t}\n\t}\n}\n\nvoid rs600_pm_finish(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tu32 tmp;\n\n\t \n\tlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\n\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\tif (radeon_crtc->enabled) {\n\t\t\ttmp = RREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset);\n\t\t\ttmp &= ~AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\tWREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset, tmp);\n\t\t}\n\t}\n}\n\n \nbool rs600_hpd_sense(struct radeon_device *rdev, enum radeon_hpd_id hpd)\n{\n\tu32 tmp;\n\tbool connected = false;\n\n\tswitch (hpd) {\n\tcase RADEON_HPD_1:\n\t\ttmp = RREG32(R_007D04_DC_HOT_PLUG_DETECT1_INT_STATUS);\n\t\tif (G_007D04_DC_HOT_PLUG_DETECT1_SENSE(tmp))\n\t\t\tconnected = true;\n\t\tbreak;\n\tcase RADEON_HPD_2:\n\t\ttmp = RREG32(R_007D14_DC_HOT_PLUG_DETECT2_INT_STATUS);\n\t\tif (G_007D14_DC_HOT_PLUG_DETECT2_SENSE(tmp))\n\t\t\tconnected = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn connected;\n}\n\nvoid rs600_hpd_set_polarity(struct radeon_device *rdev,\n\t\t\t    enum radeon_hpd_id hpd)\n{\n\tu32 tmp;\n\tbool connected = rs600_hpd_sense(rdev, hpd);\n\n\tswitch (hpd) {\n\tcase RADEON_HPD_1:\n\t\ttmp = RREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL);\n\t\tif (connected)\n\t\t\ttmp &= ~S_007D08_DC_HOT_PLUG_DETECT1_INT_POLARITY(1);\n\t\telse\n\t\t\ttmp |= S_007D08_DC_HOT_PLUG_DETECT1_INT_POLARITY(1);\n\t\tWREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\n\t\tbreak;\n\tcase RADEON_HPD_2:\n\t\ttmp = RREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL);\n\t\tif (connected)\n\t\t\ttmp &= ~S_007D18_DC_HOT_PLUG_DETECT2_INT_POLARITY(1);\n\t\telse\n\t\t\ttmp |= S_007D18_DC_HOT_PLUG_DETECT2_INT_POLARITY(1);\n\t\tWREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid rs600_hpd_init(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned enable = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tswitch (radeon_connector->hpd.hpd) {\n\t\tcase RADEON_HPD_1:\n\t\t\tWREG32(R_007D00_DC_HOT_PLUG_DETECT1_CONTROL,\n\t\t\t       S_007D00_DC_HOT_PLUG_DETECT1_EN(1));\n\t\t\tbreak;\n\t\tcase RADEON_HPD_2:\n\t\t\tWREG32(R_007D10_DC_HOT_PLUG_DETECT2_CONTROL,\n\t\t\t       S_007D10_DC_HOT_PLUG_DETECT2_EN(1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tenable |= 1 << radeon_connector->hpd.hpd;\n\t\tradeon_hpd_set_polarity(rdev, radeon_connector->hpd.hpd);\n\t}\n\tradeon_irq_kms_enable_hpd(rdev, enable);\n}\n\nvoid rs600_hpd_fini(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned disable = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tswitch (radeon_connector->hpd.hpd) {\n\t\tcase RADEON_HPD_1:\n\t\t\tWREG32(R_007D00_DC_HOT_PLUG_DETECT1_CONTROL,\n\t\t\t       S_007D00_DC_HOT_PLUG_DETECT1_EN(0));\n\t\t\tbreak;\n\t\tcase RADEON_HPD_2:\n\t\t\tWREG32(R_007D10_DC_HOT_PLUG_DETECT2_CONTROL,\n\t\t\t       S_007D10_DC_HOT_PLUG_DETECT2_EN(0));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tdisable |= 1 << radeon_connector->hpd.hpd;\n\t}\n\tradeon_irq_kms_disable_hpd(rdev, disable);\n}\n\nint rs600_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tstruct rv515_mc_save save;\n\tu32 status, tmp;\n\tint ret = 0;\n\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tif (!G_000E40_GUI_ACTIVE(status)) {\n\t\treturn 0;\n\t}\n\t \n\trv515_mc_stop(rdev, &save);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(RADEON_CP_CSQ_CNTL, 0);\n\ttmp = RREG32(RADEON_CP_RB_CNTL);\n\tWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_RPTR_WR_ENA);\n\tWREG32(RADEON_CP_RB_RPTR_WR, 0);\n\tWREG32(RADEON_CP_RB_WPTR, 0);\n\tWREG32(RADEON_CP_RB_CNTL, tmp);\n\tpci_save_state(rdev->pdev);\n\t \n\tpci_clear_master(rdev->pdev);\n\tmdelay(1);\n\t \n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_VAP(1) |\n\t\t\t\t\tS_0000F0_SOFT_RESET_GA(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_CP(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_MC(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tpci_restore_state(rdev->pdev);\n\t \n\tif (G_000E40_GA_BUSY(status) || G_000E40_VAP_BUSY(status)) {\n\t\tdev_err(rdev->dev, \"failed to reset GPU\\n\");\n\t\tret = -1;\n\t} else\n\t\tdev_info(rdev->dev, \"GPU reset succeed\\n\");\n\trv515_mc_resume(rdev, &save);\n\treturn ret;\n}\n\n \nvoid rs600_gart_tlb_flush(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\n\ttmp = RREG32_MC(R_000100_MC_PT0_CNTL);\n\ttmp &= C_000100_INVALIDATE_ALL_L1_TLBS & C_000100_INVALIDATE_L2_CACHE;\n\tWREG32_MC(R_000100_MC_PT0_CNTL, tmp);\n\n\ttmp = RREG32_MC(R_000100_MC_PT0_CNTL);\n\ttmp |= S_000100_INVALIDATE_ALL_L1_TLBS(1) | S_000100_INVALIDATE_L2_CACHE(1);\n\tWREG32_MC(R_000100_MC_PT0_CNTL, tmp);\n\n\ttmp = RREG32_MC(R_000100_MC_PT0_CNTL);\n\ttmp &= C_000100_INVALIDATE_ALL_L1_TLBS & C_000100_INVALIDATE_L2_CACHE;\n\tWREG32_MC(R_000100_MC_PT0_CNTL, tmp);\n\ttmp = RREG32_MC(R_000100_MC_PT0_CNTL);\n}\n\nstatic int rs600_gart_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->gart.robj) {\n\t\tWARN(1, \"RS600 GART already initialized\\n\");\n\t\treturn 0;\n\t}\n\t \n\tr = radeon_gart_init(rdev);\n\tif (r) {\n\t\treturn r;\n\t}\n\trdev->gart.table_size = rdev->gart.num_gpu_pages * 8;\n\treturn radeon_gart_table_vram_alloc(rdev);\n}\n\nstatic int rs600_gart_enable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint r, i;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\ttmp = RREG32(RADEON_BUS_CNTL) & ~RS600_BUS_MASTER_DIS;\n\tWREG32(RADEON_BUS_CNTL, tmp);\n\t \n\tWREG32_MC(R_000100_MC_PT0_CNTL,\n\t\t  (S_000100_EFFECTIVE_L2_CACHE_SIZE(6) |\n\t\t   S_000100_EFFECTIVE_L2_QUEUE_SIZE(6)));\n\n\tfor (i = 0; i < 19; i++) {\n\t\tWREG32_MC(R_00016C_MC_PT0_CLIENT0_CNTL + i,\n\t\t\t  S_00016C_ENABLE_TRANSLATION_MODE_OVERRIDE(1) |\n\t\t\t  S_00016C_SYSTEM_ACCESS_MODE_MASK(\n\t\t\t\t  V_00016C_SYSTEM_ACCESS_MODE_NOT_IN_SYS) |\n\t\t\t  S_00016C_SYSTEM_APERTURE_UNMAPPED_ACCESS(\n\t\t\t\t  V_00016C_SYSTEM_APERTURE_UNMAPPED_PASSTHROUGH) |\n\t\t\t  S_00016C_EFFECTIVE_L1_CACHE_SIZE(3) |\n\t\t\t  S_00016C_ENABLE_FRAGMENT_PROCESSING(1) |\n\t\t\t  S_00016C_EFFECTIVE_L1_QUEUE_SIZE(3));\n\t}\n\t \n\tWREG32_MC(R_000102_MC_PT0_CONTEXT0_CNTL,\n\t\t  S_000102_ENABLE_PAGE_TABLE(1) |\n\t\t  S_000102_PAGE_TABLE_DEPTH(V_000102_PAGE_TABLE_FLAT));\n\n\t \n\tfor (i = 1; i < 8; i++)\n\t\tWREG32_MC(R_000102_MC_PT0_CONTEXT0_CNTL + i, 0);\n\n\t \n\tWREG32_MC(R_00012C_MC_PT0_CONTEXT0_FLAT_BASE_ADDR,\n\t\t  rdev->gart.table_addr);\n\tWREG32_MC(R_00013C_MC_PT0_CONTEXT0_FLAT_START_ADDR, rdev->mc.gtt_start);\n\tWREG32_MC(R_00014C_MC_PT0_CONTEXT0_FLAT_END_ADDR, rdev->mc.gtt_end);\n\tWREG32_MC(R_00011C_MC_PT0_CONTEXT0_DEFAULT_READ_ADDR, 0);\n\n\t \n\tWREG32_MC(R_000112_MC_PT0_SYSTEM_APERTURE_LOW_ADDR, rdev->mc.vram_start);\n\tWREG32_MC(R_000114_MC_PT0_SYSTEM_APERTURE_HIGH_ADDR, rdev->mc.vram_end);\n\n\t \n\ttmp = RREG32_MC(R_000100_MC_PT0_CNTL);\n\tWREG32_MC(R_000100_MC_PT0_CNTL, (tmp | S_000100_ENABLE_PT(1)));\n\ttmp = RREG32_MC(R_000009_MC_CNTL1);\n\tWREG32_MC(R_000009_MC_CNTL1, (tmp | S_000009_ENABLE_PAGE_TABLES(1)));\n\trs600_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nstatic void rs600_gart_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\t \n\tWREG32_MC(R_000100_MC_PT0_CNTL, 0);\n\ttmp = RREG32_MC(R_000009_MC_CNTL1);\n\tWREG32_MC(R_000009_MC_CNTL1, tmp & C_000009_ENABLE_PAGE_TABLES);\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\nstatic void rs600_gart_fini(struct radeon_device *rdev)\n{\n\tradeon_gart_fini(rdev);\n\trs600_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n}\n\nuint64_t rs600_gart_get_page_entry(uint64_t addr, uint32_t flags)\n{\n\taddr = addr & 0xFFFFFFFFFFFFF000ULL;\n\taddr |= R600_PTE_SYSTEM;\n\tif (flags & RADEON_GART_PAGE_VALID)\n\t\taddr |= R600_PTE_VALID;\n\tif (flags & RADEON_GART_PAGE_READ)\n\t\taddr |= R600_PTE_READABLE;\n\tif (flags & RADEON_GART_PAGE_WRITE)\n\t\taddr |= R600_PTE_WRITEABLE;\n\tif (flags & RADEON_GART_PAGE_SNOOP)\n\t\taddr |= R600_PTE_SNOOPED;\n\treturn addr;\n}\n\nvoid rs600_gart_set_page(struct radeon_device *rdev, unsigned i,\n\t\t\t uint64_t entry)\n{\n\tvoid __iomem *ptr = (void *)rdev->gart.ptr;\n\twriteq(entry, ptr + (i * 8));\n}\n\nint rs600_irq_set(struct radeon_device *rdev)\n{\n\tuint32_t tmp = 0;\n\tuint32_t mode_int = 0;\n\tu32 hpd1 = RREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL) &\n\t\t~S_007D08_DC_HOT_PLUG_DETECT1_INT_EN(1);\n\tu32 hpd2 = RREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL) &\n\t\t~S_007D18_DC_HOT_PLUG_DETECT2_INT_EN(1);\n\tu32 hdmi0;\n\tif (ASIC_IS_DCE2(rdev))\n\t\thdmi0 = RREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL) &\n\t\t\t~S_007408_HDMI0_AZ_FORMAT_WTRIG_MASK(1);\n\telse\n\t\thdmi0 = 0;\n\n\tif (!rdev->irq.installed) {\n\t\tWARN(1, \"Can't enable IRQ/MSI because no handler is installed\\n\");\n\t\tWREG32(R_000040_GEN_INT_CNTL, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\ttmp |= S_000040_SW_INT_EN(1);\n\t}\n\tif (rdev->irq.crtc_vblank_int[0] ||\n\t    atomic_read(&rdev->irq.pflip[0])) {\n\t\tmode_int |= S_006540_D1MODE_VBLANK_INT_MASK(1);\n\t}\n\tif (rdev->irq.crtc_vblank_int[1] ||\n\t    atomic_read(&rdev->irq.pflip[1])) {\n\t\tmode_int |= S_006540_D2MODE_VBLANK_INT_MASK(1);\n\t}\n\tif (rdev->irq.hpd[0]) {\n\t\thpd1 |= S_007D08_DC_HOT_PLUG_DETECT1_INT_EN(1);\n\t}\n\tif (rdev->irq.hpd[1]) {\n\t\thpd2 |= S_007D18_DC_HOT_PLUG_DETECT2_INT_EN(1);\n\t}\n\tif (rdev->irq.afmt[0]) {\n\t\thdmi0 |= S_007408_HDMI0_AZ_FORMAT_WTRIG_MASK(1);\n\t}\n\tWREG32(R_000040_GEN_INT_CNTL, tmp);\n\tWREG32(R_006540_DxMODE_INT_MASK, mode_int);\n\tWREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, hpd1);\n\tWREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, hpd2);\n\tif (ASIC_IS_DCE2(rdev))\n\t\tWREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL, hdmi0);\n\n\t \n\tRREG32(R_000040_GEN_INT_CNTL);\n\n\treturn 0;\n}\n\nstatic inline u32 rs600_irq_ack(struct radeon_device *rdev)\n{\n\tuint32_t irqs = RREG32(R_000044_GEN_INT_STATUS);\n\tuint32_t irq_mask = S_000044_SW_INT(1);\n\tu32 tmp;\n\n\tif (G_000044_DISPLAY_INT_STAT(irqs)) {\n\t\trdev->irq.stat_regs.r500.disp_int = RREG32(R_007EDC_DISP_INTERRUPT_STATUS);\n\t\tif (G_007EDC_LB_D1_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\tWREG32(R_006534_D1MODE_VBLANK_STATUS,\n\t\t\t\tS_006534_D1MODE_VBLANK_ACK(1));\n\t\t}\n\t\tif (G_007EDC_LB_D2_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\tWREG32(R_006D34_D2MODE_VBLANK_STATUS,\n\t\t\t\tS_006D34_D2MODE_VBLANK_ACK(1));\n\t\t}\n\t\tif (G_007EDC_DC_HOT_PLUG_DETECT1_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\ttmp = RREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL);\n\t\t\ttmp |= S_007D08_DC_HOT_PLUG_DETECT1_INT_ACK(1);\n\t\t\tWREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\n\t\t}\n\t\tif (G_007EDC_DC_HOT_PLUG_DETECT2_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\ttmp = RREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL);\n\t\t\ttmp |= S_007D18_DC_HOT_PLUG_DETECT2_INT_ACK(1);\n\t\t\tWREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\n\t\t}\n\t} else {\n\t\trdev->irq.stat_regs.r500.disp_int = 0;\n\t}\n\n\tif (ASIC_IS_DCE2(rdev)) {\n\t\trdev->irq.stat_regs.r500.hdmi0_status = RREG32(R_007404_HDMI0_STATUS) &\n\t\t\tS_007404_HDMI0_AZ_FORMAT_WTRIG(1);\n\t\tif (G_007404_HDMI0_AZ_FORMAT_WTRIG(rdev->irq.stat_regs.r500.hdmi0_status)) {\n\t\t\ttmp = RREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL);\n\t\t\ttmp |= S_007408_HDMI0_AZ_FORMAT_WTRIG_ACK(1);\n\t\t\tWREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL, tmp);\n\t\t}\n\t} else\n\t\trdev->irq.stat_regs.r500.hdmi0_status = 0;\n\n\tif (irqs) {\n\t\tWREG32(R_000044_GEN_INT_STATUS, irqs);\n\t}\n\treturn irqs & irq_mask;\n}\n\nvoid rs600_irq_disable(struct radeon_device *rdev)\n{\n\tu32 hdmi0 = RREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL) &\n\t\t~S_007408_HDMI0_AZ_FORMAT_WTRIG_MASK(1);\n\tWREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL, hdmi0);\n\tWREG32(R_000040_GEN_INT_CNTL, 0);\n\tWREG32(R_006540_DxMODE_INT_MASK, 0);\n\t \n\tmdelay(1);\n\trs600_irq_ack(rdev);\n}\n\nint rs600_irq_process(struct radeon_device *rdev)\n{\n\tu32 status, msi_rearm;\n\tbool queue_hotplug = false;\n\tbool queue_hdmi = false;\n\n\tstatus = rs600_irq_ack(rdev);\n\tif (!status &&\n\t    !rdev->irq.stat_regs.r500.disp_int &&\n\t    !rdev->irq.stat_regs.r500.hdmi0_status) {\n\t\treturn IRQ_NONE;\n\t}\n\twhile (status ||\n\t       rdev->irq.stat_regs.r500.disp_int ||\n\t       rdev->irq.stat_regs.r500.hdmi0_status) {\n\t\t \n\t\tif (G_000044_SW_INT(status)) {\n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t}\n\t\t \n\t\tif (G_007EDC_LB_D1_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\tif (rdev->irq.crtc_vblank_int[0]) {\n\t\t\t\tdrm_handle_vblank(rdev->ddev, 0);\n\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t}\n\t\t\tif (atomic_read(&rdev->irq.pflip[0]))\n\t\t\t\tradeon_crtc_handle_vblank(rdev, 0);\n\t\t}\n\t\tif (G_007EDC_LB_D2_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\tif (rdev->irq.crtc_vblank_int[1]) {\n\t\t\t\tdrm_handle_vblank(rdev->ddev, 1);\n\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t}\n\t\t\tif (atomic_read(&rdev->irq.pflip[1]))\n\t\t\t\tradeon_crtc_handle_vblank(rdev, 1);\n\t\t}\n\t\tif (G_007EDC_DC_HOT_PLUG_DETECT1_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\tqueue_hotplug = true;\n\t\t\tDRM_DEBUG(\"HPD1\\n\");\n\t\t}\n\t\tif (G_007EDC_DC_HOT_PLUG_DETECT2_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\n\t\t\tqueue_hotplug = true;\n\t\t\tDRM_DEBUG(\"HPD2\\n\");\n\t\t}\n\t\tif (G_007404_HDMI0_AZ_FORMAT_WTRIG(rdev->irq.stat_regs.r500.hdmi0_status)) {\n\t\t\tqueue_hdmi = true;\n\t\t\tDRM_DEBUG(\"HDMI0\\n\");\n\t\t}\n\t\tstatus = rs600_irq_ack(rdev);\n\t}\n\tif (queue_hotplug)\n\t\tschedule_delayed_work(&rdev->hotplug_work, 0);\n\tif (queue_hdmi)\n\t\tschedule_work(&rdev->audio_work);\n\tif (rdev->msi_enabled) {\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_RS600:\n\t\tcase CHIP_RS690:\n\t\tcase CHIP_RS740:\n\t\t\tmsi_rearm = RREG32(RADEON_BUS_CNTL) & ~RS600_MSI_REARM;\n\t\t\tWREG32(RADEON_BUS_CNTL, msi_rearm);\n\t\t\tWREG32(RADEON_BUS_CNTL, msi_rearm | RS600_MSI_REARM);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWREG32(RADEON_MSI_REARM_EN, RV370_MSI_REARM_EN);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nu32 rs600_get_vblank_counter(struct radeon_device *rdev, int crtc)\n{\n\tif (crtc == 0)\n\t\treturn RREG32(R_0060A4_D1CRTC_STATUS_FRAME_COUNT);\n\telse\n\t\treturn RREG32(R_0068A4_D2CRTC_STATUS_FRAME_COUNT);\n}\n\nint rs600_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (G_000000_MC_IDLE(RREG32_MC(R_000000_MC_STATUS)))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nstatic void rs600_gpu_init(struct radeon_device *rdev)\n{\n\tr420_pipes_init(rdev);\n\t \n\tif (rs600_mc_wait_for_idle(rdev))\n\t\tdev_warn(rdev->dev, \"Wait MC idle timeout before updating MC.\\n\");\n}\n\nstatic void rs600_mc_init(struct radeon_device *rdev)\n{\n\tu64 base;\n\n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\trdev->mc.vram_is_ddr = true;\n\trdev->mc.vram_width = 128;\n\trdev->mc.real_vram_size = RREG32(RADEON_CONFIG_MEMSIZE);\n\trdev->mc.mc_vram_size = rdev->mc.real_vram_size;\n\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\trdev->mc.igp_sideport_enabled = radeon_atombios_sideport_present(rdev);\n\tbase = RREG32_MC(R_000004_MC_FB_LOCATION);\n\tbase = G_000004_MC_FB_START(base) << 16;\n\tradeon_vram_location(rdev, &rdev->mc, base);\n\trdev->mc.gtt_base_align = 0;\n\tradeon_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n}\n\nvoid rs600_bandwidth_update(struct radeon_device *rdev)\n{\n\tstruct drm_display_mode *mode0 = NULL;\n\tstruct drm_display_mode *mode1 = NULL;\n\tu32 d1mode_priority_a_cnt, d2mode_priority_a_cnt;\n\t \n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tif (rdev->mode_info.crtcs[0]->base.enabled)\n\t\tmode0 = &rdev->mode_info.crtcs[0]->base.mode;\n\tif (rdev->mode_info.crtcs[1]->base.enabled)\n\t\tmode1 = &rdev->mode_info.crtcs[1]->base.mode;\n\n\trs690_line_buffer_adjust(rdev, mode0, mode1);\n\n\tif (rdev->disp_priority == 2) {\n\t\td1mode_priority_a_cnt = RREG32(R_006548_D1MODE_PRIORITY_A_CNT);\n\t\td2mode_priority_a_cnt = RREG32(R_006D48_D2MODE_PRIORITY_A_CNT);\n\t\td1mode_priority_a_cnt |= S_006548_D1MODE_PRIORITY_A_ALWAYS_ON(1);\n\t\td2mode_priority_a_cnt |= S_006D48_D2MODE_PRIORITY_A_ALWAYS_ON(1);\n\t\tWREG32(R_006548_D1MODE_PRIORITY_A_CNT, d1mode_priority_a_cnt);\n\t\tWREG32(R_00654C_D1MODE_PRIORITY_B_CNT, d1mode_priority_a_cnt);\n\t\tWREG32(R_006D48_D2MODE_PRIORITY_A_CNT, d2mode_priority_a_cnt);\n\t\tWREG32(R_006D4C_D2MODE_PRIORITY_B_CNT, d2mode_priority_a_cnt);\n\t}\n}\n\nuint32_t rs600_mc_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(R_000070_MC_IND_INDEX, S_000070_MC_IND_ADDR(reg) |\n\t\tS_000070_MC_IND_CITF_ARB0(1));\n\tr = RREG32(R_000074_MC_IND_DATA);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n\treturn r;\n}\n\nvoid rs600_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(R_000070_MC_IND_INDEX, S_000070_MC_IND_ADDR(reg) |\n\t\tS_000070_MC_IND_CITF_ARB0(1) | S_000070_MC_IND_WR_EN(1));\n\tWREG32(R_000074_MC_IND_DATA, v);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n}\n\nvoid rs600_set_safe_registers(struct radeon_device *rdev)\n{\n\trdev->config.r300.reg_safe_bm = rs600_reg_safe_bm;\n\trdev->config.r300.reg_safe_bm_size = ARRAY_SIZE(rs600_reg_safe_bm);\n}\n\nstatic void rs600_mc_program(struct radeon_device *rdev)\n{\n\tstruct rv515_mc_save save;\n\n\t \n\trv515_mc_stop(rdev, &save);\n\n\t \n\tif (rs600_mc_wait_for_idle(rdev))\n\t\tdev_warn(rdev->dev, \"Wait MC idle timeout before updating MC.\\n\");\n\n\t \n\tWREG32_MC(R_000005_MC_AGP_LOCATION, 0x0FFFFFFF);\n\tWREG32_MC(R_000006_AGP_BASE, 0);\n\tWREG32_MC(R_000007_AGP_BASE_2, 0);\n\t \n\tWREG32_MC(R_000004_MC_FB_LOCATION,\n\t\t\tS_000004_MC_FB_START(rdev->mc.vram_start >> 16) |\n\t\t\tS_000004_MC_FB_TOP(rdev->mc.vram_end >> 16));\n\tWREG32(R_000134_HDP_FB_LOCATION,\n\t\tS_000134_HDP_FB_START(rdev->mc.vram_start >> 16));\n\n\trv515_mc_resume(rdev, &save);\n}\n\nstatic int rs600_startup(struct radeon_device *rdev)\n{\n\tint r;\n\n\trs600_mc_program(rdev);\n\t \n\trv515_clock_startup(rdev);\n\t \n\trs600_gpu_init(rdev);\n\t \n\tr = rs600_gart_enable(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\trs600_irq_set(rdev);\n\trdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\n\t \n\tr = r100_cp_init(rdev, 1024 * 1024);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing audio\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint rs600_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\trs600_gart_disable(rdev);\n\t \n\trv515_clock_startup(rdev);\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev, \"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\t \n\trv515_clock_startup(rdev);\n\t \n\tradeon_surface_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rs600_startup(rdev);\n\tif (r) {\n\t\trdev->accel_working = false;\n\t}\n\treturn r;\n}\n\nint rs600_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tr100_cp_disable(rdev);\n\tradeon_wb_disable(rdev);\n\trs600_irq_disable(rdev);\n\trs600_gart_disable(rdev);\n\treturn 0;\n}\n\nvoid rs600_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tradeon_audio_fini(rdev);\n\tr100_cp_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_gem_fini(rdev);\n\trs600_gart_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nint rs600_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\trv515_vga_render_disable(rdev);\n\t \n\tradeon_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tr100_restore_sanity(rdev);\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rdev->is_atom_bios) {\n\t\tr = radeon_atombios_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tdev_err(rdev->dev, \"Expecting atombios for RS600 GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev,\n\t\t\t\"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tif (radeon_boot_test_post_card(rdev) == false)\n\t\treturn -EINVAL;\n\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\trs600_mc_init(rdev);\n\tr100_debugfs_rbbm_init(rdev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\tr = rs600_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trs600_set_safe_registers(rdev);\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rs600_startup(rdev);\n\tif (r) {\n\t\t \n\t\tdev_err(rdev->dev, \"Disabling GPU acceleration\\n\");\n\t\tr100_cp_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\trs600_gart_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}