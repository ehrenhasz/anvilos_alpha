{
  "module_name": "evergreen_cs.c",
  "hash_id": "e3dc7821fe97083a55e0f8f6c816c669265e14b1300ca14b9c48b0bc9b1af385",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/evergreen_cs.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"r600.h\"\n#include \"evergreend.h\"\n#include \"evergreen_reg_safe.h\"\n#include \"cayman_reg_safe.h\"\n\n#define MAX(a,b)                   (((a)>(b))?(a):(b))\n#define MIN(a,b)                   (((a)<(b))?(a):(b))\n\n#define REG_SAFE_BM_SIZE ARRAY_SIZE(evergreen_reg_safe_bm)\n\nstruct evergreen_cs_track {\n\tu32\t\t\tgroup_size;\n\tu32\t\t\tnbanks;\n\tu32\t\t\tnpipes;\n\tu32\t\t\trow_size;\n\t \n\tu32\t\t\tnsamples;\t\t \n\tstruct radeon_bo\t*cb_color_bo[12];\n\tu32\t\t\tcb_color_bo_offset[12];\n\tstruct radeon_bo\t*cb_color_fmask_bo[8];\t \n\tstruct radeon_bo\t*cb_color_cmask_bo[8];\t \n\tu32\t\t\tcb_color_info[12];\n\tu32\t\t\tcb_color_view[12];\n\tu32\t\t\tcb_color_pitch[12];\n\tu32\t\t\tcb_color_slice[12];\n\tu32\t\t\tcb_color_slice_idx[12];\n\tu32\t\t\tcb_color_attrib[12];\n\tu32\t\t\tcb_color_cmask_slice[8]; \n\tu32\t\t\tcb_color_fmask_slice[8]; \n\tu32\t\t\tcb_target_mask;\n\tu32\t\t\tcb_shader_mask;  \n\tu32\t\t\tvgt_strmout_config;\n\tu32\t\t\tvgt_strmout_buffer_config;\n\tstruct radeon_bo\t*vgt_strmout_bo[4];\n\tu32\t\t\tvgt_strmout_bo_offset[4];\n\tu32\t\t\tvgt_strmout_size[4];\n\tu32\t\t\tdb_depth_control;\n\tu32\t\t\tdb_depth_view;\n\tu32\t\t\tdb_depth_slice;\n\tu32\t\t\tdb_depth_size;\n\tu32\t\t\tdb_z_info;\n\tu32\t\t\tdb_z_read_offset;\n\tu32\t\t\tdb_z_write_offset;\n\tstruct radeon_bo\t*db_z_read_bo;\n\tstruct radeon_bo\t*db_z_write_bo;\n\tu32\t\t\tdb_s_info;\n\tu32\t\t\tdb_s_read_offset;\n\tu32\t\t\tdb_s_write_offset;\n\tstruct radeon_bo\t*db_s_read_bo;\n\tstruct radeon_bo\t*db_s_write_bo;\n\tbool\t\t\tsx_misc_kill_all_prims;\n\tbool\t\t\tcb_dirty;\n\tbool\t\t\tdb_dirty;\n\tbool\t\t\tstreamout_dirty;\n\tu32\t\t\thtile_offset;\n\tu32\t\t\thtile_surface;\n\tstruct radeon_bo\t*htile_bo;\n\tunsigned long\t\tindirect_draw_buffer_size;\n\tconst unsigned\t\t*reg_safe_bm;\n};\n\nstatic u32 evergreen_cs_get_aray_mode(u32 tiling_flags)\n{\n\tif (tiling_flags & RADEON_TILING_MACRO)\n\t\treturn ARRAY_2D_TILED_THIN1;\n\telse if (tiling_flags & RADEON_TILING_MICRO)\n\t\treturn ARRAY_1D_TILED_THIN1;\n\telse\n\t\treturn ARRAY_LINEAR_GENERAL;\n}\n\nstatic u32 evergreen_cs_get_num_banks(u32 nbanks)\n{\n\tswitch (nbanks) {\n\tcase 2:\n\t\treturn ADDR_SURF_2_BANK;\n\tcase 4:\n\t\treturn ADDR_SURF_4_BANK;\n\tcase 8:\n\tdefault:\n\t\treturn ADDR_SURF_8_BANK;\n\tcase 16:\n\t\treturn ADDR_SURF_16_BANK;\n\t}\n}\n\nstatic void evergreen_cs_track_init(struct evergreen_cs_track *track)\n{\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\ttrack->cb_color_fmask_bo[i] = NULL;\n\t\ttrack->cb_color_cmask_bo[i] = NULL;\n\t\ttrack->cb_color_cmask_slice[i] = 0;\n\t\ttrack->cb_color_fmask_slice[i] = 0;\n\t}\n\n\tfor (i = 0; i < 12; i++) {\n\t\ttrack->cb_color_bo[i] = NULL;\n\t\ttrack->cb_color_bo_offset[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_info[i] = 0;\n\t\ttrack->cb_color_view[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_pitch[i] = 0;\n\t\ttrack->cb_color_slice[i] = 0xfffffff;\n\t\ttrack->cb_color_slice_idx[i] = 0;\n\t}\n\ttrack->cb_target_mask = 0xFFFFFFFF;\n\ttrack->cb_shader_mask = 0xFFFFFFFF;\n\ttrack->cb_dirty = true;\n\n\ttrack->db_depth_slice = 0xffffffff;\n\ttrack->db_depth_view = 0xFFFFC000;\n\ttrack->db_depth_size = 0xFFFFFFFF;\n\ttrack->db_depth_control = 0xFFFFFFFF;\n\ttrack->db_z_info = 0xFFFFFFFF;\n\ttrack->db_z_read_offset = 0xFFFFFFFF;\n\ttrack->db_z_write_offset = 0xFFFFFFFF;\n\ttrack->db_z_read_bo = NULL;\n\ttrack->db_z_write_bo = NULL;\n\ttrack->db_s_info = 0xFFFFFFFF;\n\ttrack->db_s_read_offset = 0xFFFFFFFF;\n\ttrack->db_s_write_offset = 0xFFFFFFFF;\n\ttrack->db_s_read_bo = NULL;\n\ttrack->db_s_write_bo = NULL;\n\ttrack->db_dirty = true;\n\ttrack->htile_bo = NULL;\n\ttrack->htile_offset = 0xFFFFFFFF;\n\ttrack->htile_surface = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttrack->vgt_strmout_size[i] = 0;\n\t\ttrack->vgt_strmout_bo[i] = NULL;\n\t\ttrack->vgt_strmout_bo_offset[i] = 0xFFFFFFFF;\n\t}\n\ttrack->streamout_dirty = true;\n\ttrack->sx_misc_kill_all_prims = false;\n}\n\nstruct eg_surface {\n\t \n\tunsigned\tnbx;\n\tunsigned\tnby;\n\tunsigned\tformat;\n\tunsigned\tmode;\n\tunsigned\tnbanks;\n\tunsigned\tbankw;\n\tunsigned\tbankh;\n\tunsigned\ttsplit;\n\tunsigned\tmtilea;\n\tunsigned\tnsamples;\n\t \n\tunsigned\tbpe;\n\tunsigned\tlayer_size;\n\tunsigned\tpalign;\n\tunsigned\thalign;\n\tunsigned long\tbase_align;\n};\n\nstatic int evergreen_surface_check_linear(struct radeon_cs_parser *p,\n\t\t\t\t\t  struct eg_surface *surf,\n\t\t\t\t\t  const char *prefix)\n{\n\tsurf->layer_size = surf->nbx * surf->nby * surf->bpe * surf->nsamples;\n\tsurf->base_align = surf->bpe;\n\tsurf->palign = 1;\n\tsurf->halign = 1;\n\treturn 0;\n}\n\nstatic int evergreen_surface_check_linear_aligned(struct radeon_cs_parser *p,\n\t\t\t\t\t\t  struct eg_surface *surf,\n\t\t\t\t\t\t  const char *prefix)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tunsigned palign;\n\n\tpalign = MAX(64, track->group_size / surf->bpe);\n\tsurf->layer_size = surf->nbx * surf->nby * surf->bpe * surf->nsamples;\n\tsurf->base_align = track->group_size;\n\tsurf->palign = palign;\n\tsurf->halign = 1;\n\tif (surf->nbx & (palign - 1)) {\n\t\tif (prefix) {\n\t\t\tdev_warn(p->dev, \"%s:%d %s pitch %d invalid must be aligned with %d\\n\",\n\t\t\t\t __func__, __LINE__, prefix, surf->nbx, palign);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int evergreen_surface_check_1d(struct radeon_cs_parser *p,\n\t\t\t\t      struct eg_surface *surf,\n\t\t\t\t      const char *prefix)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tunsigned palign;\n\n\tpalign = track->group_size / (8 * surf->bpe * surf->nsamples);\n\tpalign = MAX(8, palign);\n\tsurf->layer_size = surf->nbx * surf->nby * surf->bpe;\n\tsurf->base_align = track->group_size;\n\tsurf->palign = palign;\n\tsurf->halign = 8;\n\tif ((surf->nbx & (palign - 1))) {\n\t\tif (prefix) {\n\t\t\tdev_warn(p->dev, \"%s:%d %s pitch %d invalid must be aligned with %d (%d %d %d)\\n\",\n\t\t\t\t __func__, __LINE__, prefix, surf->nbx, palign,\n\t\t\t\t track->group_size, surf->bpe, surf->nsamples);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tif ((surf->nby & (8 - 1))) {\n\t\tif (prefix) {\n\t\t\tdev_warn(p->dev, \"%s:%d %s height %d invalid must be aligned with 8\\n\",\n\t\t\t\t __func__, __LINE__, prefix, surf->nby);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int evergreen_surface_check_2d(struct radeon_cs_parser *p,\n\t\t\t\t      struct eg_surface *surf,\n\t\t\t\t      const char *prefix)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tunsigned palign, halign, tileb, slice_pt;\n\tunsigned mtile_pr, mtile_ps, mtileb;\n\n\ttileb = 64 * surf->bpe * surf->nsamples;\n\tslice_pt = 1;\n\tif (tileb > surf->tsplit) {\n\t\tslice_pt = tileb / surf->tsplit;\n\t}\n\ttileb = tileb / slice_pt;\n\t \n\tpalign = (8 * surf->bankw * track->npipes) * surf->mtilea;\n\thalign = (8 * surf->bankh * surf->nbanks) / surf->mtilea;\n\tmtileb = (palign / 8) * (halign / 8) * tileb;\n\tmtile_pr = surf->nbx / palign;\n\tmtile_ps = (mtile_pr * surf->nby) / halign;\n\tsurf->layer_size = mtile_ps * mtileb * slice_pt;\n\tsurf->base_align = (palign / 8) * (halign / 8) * tileb;\n\tsurf->palign = palign;\n\tsurf->halign = halign;\n\n\tif ((surf->nbx & (palign - 1))) {\n\t\tif (prefix) {\n\t\t\tdev_warn(p->dev, \"%s:%d %s pitch %d invalid must be aligned with %d\\n\",\n\t\t\t\t __func__, __LINE__, prefix, surf->nbx, palign);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tif ((surf->nby & (halign - 1))) {\n\t\tif (prefix) {\n\t\t\tdev_warn(p->dev, \"%s:%d %s height %d invalid must be aligned with %d\\n\",\n\t\t\t\t __func__, __LINE__, prefix, surf->nby, halign);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int evergreen_surface_check(struct radeon_cs_parser *p,\n\t\t\t\t   struct eg_surface *surf,\n\t\t\t\t   const char *prefix)\n{\n\t \n\tsurf->bpe = r600_fmt_get_blocksize(surf->format);\n\n\tswitch (surf->mode) {\n\tcase ARRAY_LINEAR_GENERAL:\n\t\treturn evergreen_surface_check_linear(p, surf, prefix);\n\tcase ARRAY_LINEAR_ALIGNED:\n\t\treturn evergreen_surface_check_linear_aligned(p, surf, prefix);\n\tcase ARRAY_1D_TILED_THIN1:\n\t\treturn evergreen_surface_check_1d(p, surf, prefix);\n\tcase ARRAY_2D_TILED_THIN1:\n\t\treturn evergreen_surface_check_2d(p, surf, prefix);\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid array mode %d\\n\",\n\t\t\t\t__func__, __LINE__, prefix, surf->mode);\n\t\treturn -EINVAL;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int evergreen_surface_value_conv_check(struct radeon_cs_parser *p,\n\t\t\t\t\t      struct eg_surface *surf,\n\t\t\t\t\t      const char *prefix)\n{\n\tswitch (surf->mode) {\n\tcase ARRAY_2D_TILED_THIN1:\n\t\tbreak;\n\tcase ARRAY_LINEAR_GENERAL:\n\tcase ARRAY_LINEAR_ALIGNED:\n\tcase ARRAY_1D_TILED_THIN1:\n\t\treturn 0;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid array mode %d\\n\",\n\t\t\t\t__func__, __LINE__, prefix, surf->mode);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (surf->nbanks) {\n\tcase 0: surf->nbanks = 2; break;\n\tcase 1: surf->nbanks = 4; break;\n\tcase 2: surf->nbanks = 8; break;\n\tcase 3: surf->nbanks = 16; break;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid number of banks %d\\n\",\n\t\t\t __func__, __LINE__, prefix, surf->nbanks);\n\t\treturn -EINVAL;\n\t}\n\tswitch (surf->bankw) {\n\tcase 0: surf->bankw = 1; break;\n\tcase 1: surf->bankw = 2; break;\n\tcase 2: surf->bankw = 4; break;\n\tcase 3: surf->bankw = 8; break;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid bankw %d\\n\",\n\t\t\t __func__, __LINE__, prefix, surf->bankw);\n\t\treturn -EINVAL;\n\t}\n\tswitch (surf->bankh) {\n\tcase 0: surf->bankh = 1; break;\n\tcase 1: surf->bankh = 2; break;\n\tcase 2: surf->bankh = 4; break;\n\tcase 3: surf->bankh = 8; break;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid bankh %d\\n\",\n\t\t\t __func__, __LINE__, prefix, surf->bankh);\n\t\treturn -EINVAL;\n\t}\n\tswitch (surf->mtilea) {\n\tcase 0: surf->mtilea = 1; break;\n\tcase 1: surf->mtilea = 2; break;\n\tcase 2: surf->mtilea = 4; break;\n\tcase 3: surf->mtilea = 8; break;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid macro tile aspect %d\\n\",\n\t\t\t __func__, __LINE__, prefix, surf->mtilea);\n\t\treturn -EINVAL;\n\t}\n\tswitch (surf->tsplit) {\n\tcase 0: surf->tsplit = 64; break;\n\tcase 1: surf->tsplit = 128; break;\n\tcase 2: surf->tsplit = 256; break;\n\tcase 3: surf->tsplit = 512; break;\n\tcase 4: surf->tsplit = 1024; break;\n\tcase 5: surf->tsplit = 2048; break;\n\tcase 6: surf->tsplit = 4096; break;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d %s invalid tile split %d\\n\",\n\t\t\t __func__, __LINE__, prefix, surf->tsplit);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int evergreen_cs_track_validate_cb(struct radeon_cs_parser *p, unsigned id)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tstruct eg_surface surf;\n\tunsigned pitch, slice, mslice;\n\tunsigned long offset;\n\tint r;\n\n\tmslice = G_028C6C_SLICE_MAX(track->cb_color_view[id]) + 1;\n\tpitch = track->cb_color_pitch[id];\n\tslice = track->cb_color_slice[id];\n\tsurf.nbx = (pitch + 1) * 8;\n\tsurf.nby = ((slice + 1) * 64) / surf.nbx;\n\tsurf.mode = G_028C70_ARRAY_MODE(track->cb_color_info[id]);\n\tsurf.format = G_028C70_FORMAT(track->cb_color_info[id]);\n\tsurf.tsplit = G_028C74_TILE_SPLIT(track->cb_color_attrib[id]);\n\tsurf.nbanks = G_028C74_NUM_BANKS(track->cb_color_attrib[id]);\n\tsurf.bankw = G_028C74_BANK_WIDTH(track->cb_color_attrib[id]);\n\tsurf.bankh = G_028C74_BANK_HEIGHT(track->cb_color_attrib[id]);\n\tsurf.mtilea = G_028C74_MACRO_TILE_ASPECT(track->cb_color_attrib[id]);\n\tsurf.nsamples = 1;\n\n\tif (!r600_fmt_is_valid_color(surf.format)) {\n\t\tdev_warn(p->dev, \"%s:%d cb invalid format %d for %d (0x%08x)\\n\",\n\t\t\t __func__, __LINE__, surf.format,\n\t\t\tid, track->cb_color_info[id]);\n\t\treturn -EINVAL;\n\t}\n\n\tr = evergreen_surface_value_conv_check(p, &surf, \"cb\");\n\tif (r) {\n\t\treturn r;\n\t}\n\n\tr = evergreen_surface_check(p, &surf, \"cb\");\n\tif (r) {\n\t\tdev_warn(p->dev, \"%s:%d cb[%d] invalid (0x%08x 0x%08x 0x%08x 0x%08x)\\n\",\n\t\t\t __func__, __LINE__, id, track->cb_color_pitch[id],\n\t\t\t track->cb_color_slice[id], track->cb_color_attrib[id],\n\t\t\t track->cb_color_info[id]);\n\t\treturn r;\n\t}\n\n\toffset = track->cb_color_bo_offset[id] << 8;\n\tif (offset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d cb[%d] bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, id, offset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\n\toffset += surf.layer_size * mslice;\n\tif (offset > radeon_bo_size(track->cb_color_bo[id])) {\n\t\t \n\t\tif (!surf.mode) {\n\t\t\tuint32_t *ib = p->ib.ptr;\n\t\t\tunsigned long tmp, nby, bsize, size, min = 0;\n\n\t\t\t \n\t\t\tif (surf.nby > 8) {\n\t\t\t\tmin = surf.nby - 8;\n\t\t\t}\n\t\t\tbsize = radeon_bo_size(track->cb_color_bo[id]);\n\t\t\ttmp = track->cb_color_bo_offset[id] << 8;\n\t\t\tfor (nby = surf.nby; nby > min; nby--) {\n\t\t\t\tsize = nby * surf.nbx * surf.bpe * surf.nsamples;\n\t\t\t\tif ((tmp + size * mslice) <= bsize) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nby > min) {\n\t\t\t\tsurf.nby = nby;\n\t\t\t\tslice = ((nby * surf.nbx) / 64) - 1;\n\t\t\t\tif (!evergreen_surface_check(p, &surf, \"cb\")) {\n\t\t\t\t\t \n\t\t\t\t\ttmp += surf.layer_size * mslice;\n\t\t\t\t\tif (tmp <= bsize) {\n\t\t\t\t\t\tib[track->cb_color_slice_idx[id]] = slice;\n\t\t\t\t\t\tgoto old_ddx_ok;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdev_warn(p->dev, \"%s:%d cb[%d] bo too small (layer size %d, \"\n\t\t\t \"offset %d, max layer %d, bo size %ld, slice %d)\\n\",\n\t\t\t __func__, __LINE__, id, surf.layer_size,\n\t\t\ttrack->cb_color_bo_offset[id] << 8, mslice,\n\t\t\tradeon_bo_size(track->cb_color_bo[id]), slice);\n\t\tdev_warn(p->dev, \"%s:%d problematic surf: (%d %d) (%d %d %d %d %d %d %d)\\n\",\n\t\t\t __func__, __LINE__, surf.nbx, surf.nby,\n\t\t\tsurf.mode, surf.bpe, surf.nsamples,\n\t\t\tsurf.bankw, surf.bankh,\n\t\t\tsurf.tsplit, surf.mtilea);\n\t\treturn -EINVAL;\n\t}\nold_ddx_ok:\n\n\treturn 0;\n}\n\nstatic int evergreen_cs_track_validate_htile(struct radeon_cs_parser *p,\n\t\t\t\t\t\tunsigned nbx, unsigned nby)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tunsigned long size;\n\n\tif (track->htile_bo == NULL) {\n\t\tdev_warn(p->dev, \"%s:%d htile enabled without htile surface 0x%08x\\n\",\n\t\t\t\t__func__, __LINE__, track->db_z_info);\n\t\treturn -EINVAL;\n\t}\n\n\tif (G_028ABC_LINEAR(track->htile_surface)) {\n\t\t \n\t\tnbx = round_up(nbx, 16 * 8);\n\t\t \n\t\tnby = round_up(nby, track->npipes * 8);\n\t} else {\n\t\t \n\t\t \n\t\tswitch (track->npipes) {\n\t\tcase 8:\n\t\t\t \n\t\t\tnbx = round_up(nbx, 64 * 8);\n\t\t\tnby = round_up(nby, 64 * 8);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t \n\t\t\tnbx = round_up(nbx, 64 * 8);\n\t\t\tnby = round_up(nby, 32 * 8);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\tnbx = round_up(nbx, 32 * 8);\n\t\t\tnby = round_up(nby, 32 * 8);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tnbx = round_up(nbx, 32 * 8);\n\t\t\tnby = round_up(nby, 16 * 8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(p->dev, \"%s:%d invalid num pipes %d\\n\",\n\t\t\t\t\t__func__, __LINE__, track->npipes);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tnbx = nbx >> 3;\n\tnby = nby >> 3;\n\t \n\tsize = roundup(nbx * nby * 4, track->npipes * (2 << 10));\n\tsize += track->htile_offset;\n\n\tif (size > radeon_bo_size(track->htile_bo)) {\n\t\tdev_warn(p->dev, \"%s:%d htile surface too small %ld for %ld (%d %d)\\n\",\n\t\t\t\t__func__, __LINE__, radeon_bo_size(track->htile_bo),\n\t\t\t\tsize, nbx, nby);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int evergreen_cs_track_validate_stencil(struct radeon_cs_parser *p)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tstruct eg_surface surf;\n\tunsigned pitch, slice, mslice;\n\tunsigned long offset;\n\tint r;\n\n\tmslice = G_028008_SLICE_MAX(track->db_depth_view) + 1;\n\tpitch = G_028058_PITCH_TILE_MAX(track->db_depth_size);\n\tslice = track->db_depth_slice;\n\tsurf.nbx = (pitch + 1) * 8;\n\tsurf.nby = ((slice + 1) * 64) / surf.nbx;\n\tsurf.mode = G_028040_ARRAY_MODE(track->db_z_info);\n\tsurf.format = G_028044_FORMAT(track->db_s_info);\n\tsurf.tsplit = G_028044_TILE_SPLIT(track->db_s_info);\n\tsurf.nbanks = G_028040_NUM_BANKS(track->db_z_info);\n\tsurf.bankw = G_028040_BANK_WIDTH(track->db_z_info);\n\tsurf.bankh = G_028040_BANK_HEIGHT(track->db_z_info);\n\tsurf.mtilea = G_028040_MACRO_TILE_ASPECT(track->db_z_info);\n\tsurf.nsamples = 1;\n\n\tif (surf.format != 1) {\n\t\tdev_warn(p->dev, \"%s:%d stencil invalid format %d\\n\",\n\t\t\t __func__, __LINE__, surf.format);\n\t\treturn -EINVAL;\n\t}\n\t \n\tsurf.format = V_028C70_COLOR_8;\n\n\tr = evergreen_surface_value_conv_check(p, &surf, \"stencil\");\n\tif (r) {\n\t\treturn r;\n\t}\n\n\tr = evergreen_surface_check(p, &surf, NULL);\n\tif (r) {\n\t\t \n\t\tsurf.format = V_028C70_COLOR_8_8_8_8;\n\t\tr = evergreen_surface_check(p, &surf, \"stencil\");\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d stencil invalid (0x%08x 0x%08x 0x%08x 0x%08x)\\n\",\n\t\t\t\t __func__, __LINE__, track->db_depth_size,\n\t\t\t\t track->db_depth_slice, track->db_s_info, track->db_z_info);\n\t\t}\n\t\treturn r;\n\t}\n\n\toffset = track->db_s_read_offset << 8;\n\tif (offset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d stencil read bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, offset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\toffset += surf.layer_size * mslice;\n\tif (offset > radeon_bo_size(track->db_s_read_bo)) {\n\t\tdev_warn(p->dev, \"%s:%d stencil read bo too small (layer size %d, \"\n\t\t\t \"offset %ld, max layer %d, bo size %ld)\\n\",\n\t\t\t __func__, __LINE__, surf.layer_size,\n\t\t\t(unsigned long)track->db_s_read_offset << 8, mslice,\n\t\t\tradeon_bo_size(track->db_s_read_bo));\n\t\tdev_warn(p->dev, \"%s:%d stencil invalid (0x%08x 0x%08x 0x%08x 0x%08x)\\n\",\n\t\t\t __func__, __LINE__, track->db_depth_size,\n\t\t\t track->db_depth_slice, track->db_s_info, track->db_z_info);\n\t\treturn -EINVAL;\n\t}\n\n\toffset = track->db_s_write_offset << 8;\n\tif (offset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d stencil write bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, offset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\toffset += surf.layer_size * mslice;\n\tif (offset > radeon_bo_size(track->db_s_write_bo)) {\n\t\tdev_warn(p->dev, \"%s:%d stencil write bo too small (layer size %d, \"\n\t\t\t \"offset %ld, max layer %d, bo size %ld)\\n\",\n\t\t\t __func__, __LINE__, surf.layer_size,\n\t\t\t(unsigned long)track->db_s_write_offset << 8, mslice,\n\t\t\tradeon_bo_size(track->db_s_write_bo));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (G_028040_TILE_SURFACE_ENABLE(track->db_z_info)) {\n\t\tr = evergreen_cs_track_validate_htile(p, surf.nbx, surf.nby);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int evergreen_cs_track_validate_depth(struct radeon_cs_parser *p)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tstruct eg_surface surf;\n\tunsigned pitch, slice, mslice;\n\tunsigned long offset;\n\tint r;\n\n\tmslice = G_028008_SLICE_MAX(track->db_depth_view) + 1;\n\tpitch = G_028058_PITCH_TILE_MAX(track->db_depth_size);\n\tslice = track->db_depth_slice;\n\tsurf.nbx = (pitch + 1) * 8;\n\tsurf.nby = ((slice + 1) * 64) / surf.nbx;\n\tsurf.mode = G_028040_ARRAY_MODE(track->db_z_info);\n\tsurf.format = G_028040_FORMAT(track->db_z_info);\n\tsurf.tsplit = G_028040_TILE_SPLIT(track->db_z_info);\n\tsurf.nbanks = G_028040_NUM_BANKS(track->db_z_info);\n\tsurf.bankw = G_028040_BANK_WIDTH(track->db_z_info);\n\tsurf.bankh = G_028040_BANK_HEIGHT(track->db_z_info);\n\tsurf.mtilea = G_028040_MACRO_TILE_ASPECT(track->db_z_info);\n\tsurf.nsamples = 1;\n\n\tswitch (surf.format) {\n\tcase V_028040_Z_16:\n\t\tsurf.format = V_028C70_COLOR_16;\n\t\tbreak;\n\tcase V_028040_Z_24:\n\tcase V_028040_Z_32_FLOAT:\n\t\tsurf.format = V_028C70_COLOR_8_8_8_8;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d depth invalid format %d\\n\",\n\t\t\t __func__, __LINE__, surf.format);\n\t\treturn -EINVAL;\n\t}\n\n\tr = evergreen_surface_value_conv_check(p, &surf, \"depth\");\n\tif (r) {\n\t\tdev_warn(p->dev, \"%s:%d depth invalid (0x%08x 0x%08x 0x%08x)\\n\",\n\t\t\t __func__, __LINE__, track->db_depth_size,\n\t\t\t track->db_depth_slice, track->db_z_info);\n\t\treturn r;\n\t}\n\n\tr = evergreen_surface_check(p, &surf, \"depth\");\n\tif (r) {\n\t\tdev_warn(p->dev, \"%s:%d depth invalid (0x%08x 0x%08x 0x%08x)\\n\",\n\t\t\t __func__, __LINE__, track->db_depth_size,\n\t\t\t track->db_depth_slice, track->db_z_info);\n\t\treturn r;\n\t}\n\n\toffset = track->db_z_read_offset << 8;\n\tif (offset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d stencil read bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, offset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\toffset += surf.layer_size * mslice;\n\tif (offset > radeon_bo_size(track->db_z_read_bo)) {\n\t\tdev_warn(p->dev, \"%s:%d depth read bo too small (layer size %d, \"\n\t\t\t \"offset %ld, max layer %d, bo size %ld)\\n\",\n\t\t\t __func__, __LINE__, surf.layer_size,\n\t\t\t(unsigned long)track->db_z_read_offset << 8, mslice,\n\t\t\tradeon_bo_size(track->db_z_read_bo));\n\t\treturn -EINVAL;\n\t}\n\n\toffset = track->db_z_write_offset << 8;\n\tif (offset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d stencil write bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, offset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\toffset += surf.layer_size * mslice;\n\tif (offset > radeon_bo_size(track->db_z_write_bo)) {\n\t\tdev_warn(p->dev, \"%s:%d depth write bo too small (layer size %d, \"\n\t\t\t \"offset %ld, max layer %d, bo size %ld)\\n\",\n\t\t\t __func__, __LINE__, surf.layer_size,\n\t\t\t(unsigned long)track->db_z_write_offset << 8, mslice,\n\t\t\tradeon_bo_size(track->db_z_write_bo));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (G_028040_TILE_SURFACE_ENABLE(track->db_z_info)) {\n\t\tr = evergreen_cs_track_validate_htile(p, surf.nbx, surf.nby);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int evergreen_cs_track_validate_texture(struct radeon_cs_parser *p,\n\t\t\t\t\t       struct radeon_bo *texture,\n\t\t\t\t\t       struct radeon_bo *mipmap,\n\t\t\t\t\t       unsigned idx)\n{\n\tstruct eg_surface surf;\n\tunsigned long toffset, moffset;\n\tunsigned dim, llevel, mslice, width, height, depth, i;\n\tu32 texdw[8];\n\tint r;\n\n\ttexdw[0] = radeon_get_ib_value(p, idx + 0);\n\ttexdw[1] = radeon_get_ib_value(p, idx + 1);\n\ttexdw[2] = radeon_get_ib_value(p, idx + 2);\n\ttexdw[3] = radeon_get_ib_value(p, idx + 3);\n\ttexdw[4] = radeon_get_ib_value(p, idx + 4);\n\ttexdw[5] = radeon_get_ib_value(p, idx + 5);\n\ttexdw[6] = radeon_get_ib_value(p, idx + 6);\n\ttexdw[7] = radeon_get_ib_value(p, idx + 7);\n\tdim = G_030000_DIM(texdw[0]);\n\tllevel = G_030014_LAST_LEVEL(texdw[5]);\n\tmslice = G_030014_LAST_ARRAY(texdw[5]) + 1;\n\twidth = G_030000_TEX_WIDTH(texdw[0]) + 1;\n\theight =  G_030004_TEX_HEIGHT(texdw[1]) + 1;\n\tdepth = G_030004_TEX_DEPTH(texdw[1]) + 1;\n\tsurf.format = G_03001C_DATA_FORMAT(texdw[7]);\n\tsurf.nbx = (G_030000_PITCH(texdw[0]) + 1) * 8;\n\tsurf.nbx = r600_fmt_get_nblocksx(surf.format, surf.nbx);\n\tsurf.nby = r600_fmt_get_nblocksy(surf.format, height);\n\tsurf.mode = G_030004_ARRAY_MODE(texdw[1]);\n\tsurf.tsplit = G_030018_TILE_SPLIT(texdw[6]);\n\tsurf.nbanks = G_03001C_NUM_BANKS(texdw[7]);\n\tsurf.bankw = G_03001C_BANK_WIDTH(texdw[7]);\n\tsurf.bankh = G_03001C_BANK_HEIGHT(texdw[7]);\n\tsurf.mtilea = G_03001C_MACRO_TILE_ASPECT(texdw[7]);\n\tsurf.nsamples = 1;\n\ttoffset = texdw[2] << 8;\n\tmoffset = texdw[3] << 8;\n\n\tif (!r600_fmt_is_valid_texture(surf.format, p->family)) {\n\t\tdev_warn(p->dev, \"%s:%d texture invalid format %d\\n\",\n\t\t\t __func__, __LINE__, surf.format);\n\t\treturn -EINVAL;\n\t}\n\tswitch (dim) {\n\tcase V_030000_SQ_TEX_DIM_1D:\n\tcase V_030000_SQ_TEX_DIM_2D:\n\tcase V_030000_SQ_TEX_DIM_CUBEMAP:\n\tcase V_030000_SQ_TEX_DIM_1D_ARRAY:\n\tcase V_030000_SQ_TEX_DIM_2D_ARRAY:\n\t\tdepth = 1;\n\t\tbreak;\n\tcase V_030000_SQ_TEX_DIM_2D_MSAA:\n\tcase V_030000_SQ_TEX_DIM_2D_ARRAY_MSAA:\n\t\tsurf.nsamples = 1 << llevel;\n\t\tllevel = 0;\n\t\tdepth = 1;\n\t\tbreak;\n\tcase V_030000_SQ_TEX_DIM_3D:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s:%d texture invalid dimension %d\\n\",\n\t\t\t __func__, __LINE__, dim);\n\t\treturn -EINVAL;\n\t}\n\n\tr = evergreen_surface_value_conv_check(p, &surf, \"texture\");\n\tif (r) {\n\t\treturn r;\n\t}\n\n\t \n\tevergreen_surface_check(p, &surf, NULL);\n\tsurf.nby = ALIGN(surf.nby, surf.halign);\n\n\tr = evergreen_surface_check(p, &surf, \"texture\");\n\tif (r) {\n\t\tdev_warn(p->dev, \"%s:%d texture invalid 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t __func__, __LINE__, texdw[0], texdw[1], texdw[4],\n\t\t\t texdw[5], texdw[6], texdw[7]);\n\t\treturn r;\n\t}\n\n\t \n\tif (toffset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d texture bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, toffset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\tif (surf.nsamples <= 1 && moffset & (surf.base_align - 1)) {\n\t\tdev_warn(p->dev, \"%s:%d mipmap bo base %ld not aligned with %ld\\n\",\n\t\t\t __func__, __LINE__, moffset, surf.base_align);\n\t\treturn -EINVAL;\n\t}\n\tif (dim == SQ_TEX_DIM_3D) {\n\t\ttoffset += surf.layer_size * depth;\n\t} else {\n\t\ttoffset += surf.layer_size * mslice;\n\t}\n\tif (toffset > radeon_bo_size(texture)) {\n\t\tdev_warn(p->dev, \"%s:%d texture bo too small (layer size %d, \"\n\t\t\t \"offset %ld, max layer %d, depth %d, bo size %ld) (%d %d)\\n\",\n\t\t\t __func__, __LINE__, surf.layer_size,\n\t\t\t(unsigned long)texdw[2] << 8, mslice,\n\t\t\tdepth, radeon_bo_size(texture),\n\t\t\tsurf.nbx, surf.nby);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!mipmap) {\n\t\tif (llevel) {\n\t\t\tdev_warn(p->dev, \"%s:%i got NULL MIP_ADDRESS relocation\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\treturn 0;  \n\t\t}\n\t}\n\n\t \n\tfor (i = 1; i <= llevel; i++) {\n\t\tunsigned w, h, d;\n\n\t\tw = r600_mip_minify(width, i);\n\t\th = r600_mip_minify(height, i);\n\t\td = r600_mip_minify(depth, i);\n\t\tsurf.nbx = r600_fmt_get_nblocksx(surf.format, w);\n\t\tsurf.nby = r600_fmt_get_nblocksy(surf.format, h);\n\n\t\tswitch (surf.mode) {\n\t\tcase ARRAY_2D_TILED_THIN1:\n\t\t\tif (surf.nbx < surf.palign || surf.nby < surf.halign) {\n\t\t\t\tsurf.mode = ARRAY_1D_TILED_THIN1;\n\t\t\t}\n\t\t\t \n\t\t\tevergreen_surface_check(p, &surf, NULL);\n\t\t\tbreak;\n\t\tcase ARRAY_LINEAR_GENERAL:\n\t\tcase ARRAY_LINEAR_ALIGNED:\n\t\tcase ARRAY_1D_TILED_THIN1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(p->dev, \"%s:%d invalid array mode %d\\n\",\n\t\t\t\t __func__, __LINE__, surf.mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsurf.nbx = ALIGN(surf.nbx, surf.palign);\n\t\tsurf.nby = ALIGN(surf.nby, surf.halign);\n\n\t\tr = evergreen_surface_check(p, &surf, \"mipmap\");\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\n\t\tif (dim == SQ_TEX_DIM_3D) {\n\t\t\tmoffset += surf.layer_size * d;\n\t\t} else {\n\t\t\tmoffset += surf.layer_size * mslice;\n\t\t}\n\t\tif (moffset > radeon_bo_size(mipmap)) {\n\t\t\tdev_warn(p->dev, \"%s:%d mipmap [%d] bo too small (layer size %d, \"\n\t\t\t\t\t\"offset %ld, coffset %ld, max layer %d, depth %d, \"\n\t\t\t\t\t\"bo size %ld) level0 (%d %d %d)\\n\",\n\t\t\t\t\t__func__, __LINE__, i, surf.layer_size,\n\t\t\t\t\t(unsigned long)texdw[3] << 8, moffset, mslice,\n\t\t\t\t\td, radeon_bo_size(mipmap),\n\t\t\t\t\twidth, height, depth);\n\t\t\tdev_warn(p->dev, \"%s:%d problematic surf: (%d %d) (%d %d %d %d %d %d %d)\\n\",\n\t\t\t\t __func__, __LINE__, surf.nbx, surf.nby,\n\t\t\t\tsurf.mode, surf.bpe, surf.nsamples,\n\t\t\t\tsurf.bankw, surf.bankh,\n\t\t\t\tsurf.tsplit, surf.mtilea);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int evergreen_cs_track_check(struct radeon_cs_parser *p)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tunsigned tmp, i;\n\tint r;\n\tunsigned buffer_mask = 0;\n\n\t \n\tif (track->streamout_dirty && track->vgt_strmout_config) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (track->vgt_strmout_config & (1 << i)) {\n\t\t\t\tbuffer_mask |= (track->vgt_strmout_buffer_config >> (i * 4)) & 0xf;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (buffer_mask & (1 << i)) {\n\t\t\t\tif (track->vgt_strmout_bo[i]) {\n\t\t\t\t\tu64 offset = (u64)track->vgt_strmout_bo_offset[i] +\n\t\t\t\t\t\t\t(u64)track->vgt_strmout_size[i];\n\t\t\t\t\tif (offset > radeon_bo_size(track->vgt_strmout_bo[i])) {\n\t\t\t\t\t\tDRM_ERROR(\"streamout %d bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t\t\t  i, offset,\n\t\t\t\t\t\t\t  radeon_bo_size(track->vgt_strmout_bo[i]));\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdev_warn(p->dev, \"No buffer for streamout %d\\n\", i);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrack->streamout_dirty = false;\n\t}\n\n\tif (track->sx_misc_kill_all_prims)\n\t\treturn 0;\n\n\t \n\tif (track->cb_dirty) {\n\t\ttmp = track->cb_target_mask;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tu32 format = G_028C70_FORMAT(track->cb_color_info[i]);\n\n\t\t\tif (format != V_028C70_COLOR_INVALID &&\n\t\t\t    (tmp >> (i * 4)) & 0xF) {\n\t\t\t\t \n\t\t\t\tif (track->cb_color_bo[i] == NULL) {\n\t\t\t\t\tdev_warn(p->dev, \"%s:%d mask 0x%08X | 0x%08X no cb for %d\\n\",\n\t\t\t\t\t\t__func__, __LINE__, track->cb_target_mask, track->cb_shader_mask, i);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tr = evergreen_cs_track_validate_cb(p, i);\n\t\t\t\tif (r) {\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrack->cb_dirty = false;\n\t}\n\n\tif (track->db_dirty) {\n\t\t \n\t\tif (G_028044_FORMAT(track->db_s_info) != V_028044_STENCIL_INVALID &&\n\t\t    G_028800_STENCIL_ENABLE(track->db_depth_control)) {\n\t\t\tr = evergreen_cs_track_validate_stencil(p);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\t \n\t\tif (G_028040_FORMAT(track->db_z_info) != V_028040_Z_INVALID &&\n\t\t    G_028800_Z_ENABLE(track->db_depth_control)) {\n\t\t\tr = evergreen_cs_track_validate_depth(p);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\ttrack->db_dirty = false;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int evergreen_cs_packet_parse_vline(struct radeon_cs_parser *p)\n{\n\n\tstatic uint32_t vline_start_end[6] = {\n\t\tEVERGREEN_VLINE_START_END + EVERGREEN_CRTC0_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_START_END + EVERGREEN_CRTC1_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_START_END + EVERGREEN_CRTC2_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_START_END + EVERGREEN_CRTC3_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_START_END + EVERGREEN_CRTC4_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_START_END + EVERGREEN_CRTC5_REGISTER_OFFSET\n\t};\n\tstatic uint32_t vline_status[6] = {\n\t\tEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC0_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC1_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC2_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC3_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC4_REGISTER_OFFSET,\n\t\tEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC5_REGISTER_OFFSET\n\t};\n\n\treturn r600_cs_common_vline_parse(p, vline_start_end, vline_status);\n}\n\nstatic int evergreen_packet0_check(struct radeon_cs_parser *p,\n\t\t\t\t   struct radeon_cs_packet *pkt,\n\t\t\t\t   unsigned idx, unsigned reg)\n{\n\tint r;\n\n\tswitch (reg) {\n\tcase EVERGREEN_VLINE_START_END:\n\t\tr = evergreen_cs_packet_parse_vline(p);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Forbidden register 0x%04X in cs at %d\\n\", reg, idx);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int evergreen_cs_parse_packet0(struct radeon_cs_parser *p,\n\t\t\t\t      struct radeon_cs_packet *pkt)\n{\n\tunsigned reg, i;\n\tunsigned idx;\n\tint r;\n\n\tidx = pkt->idx + 1;\n\treg = pkt->reg;\n\tfor (i = 0; i <= pkt->count; i++, idx++, reg += 4) {\n\t\tr = evergreen_packet0_check(p, pkt, idx, reg);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int evergreen_cs_handle_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\n{\n\tstruct evergreen_cs_track *track = (struct evergreen_cs_track *)p->track;\n\tstruct radeon_bo_list *reloc;\n\tu32 tmp, *ib;\n\tint r;\n\n\tib = p->ib.ptr;\n\tswitch (reg) {\n\t \n\tcase SQ_ESGS_RING_SIZE:\n\tcase SQ_GSVS_RING_SIZE:\n\tcase SQ_ESTMP_RING_SIZE:\n\tcase SQ_GSTMP_RING_SIZE:\n\tcase SQ_HSTMP_RING_SIZE:\n\tcase SQ_LSTMP_RING_SIZE:\n\tcase SQ_PSTMP_RING_SIZE:\n\tcase SQ_VSTMP_RING_SIZE:\n\tcase SQ_ESGS_RING_ITEMSIZE:\n\tcase SQ_ESTMP_RING_ITEMSIZE:\n\tcase SQ_GSTMP_RING_ITEMSIZE:\n\tcase SQ_GSVS_RING_ITEMSIZE:\n\tcase SQ_GS_VERT_ITEMSIZE:\n\tcase SQ_GS_VERT_ITEMSIZE_1:\n\tcase SQ_GS_VERT_ITEMSIZE_2:\n\tcase SQ_GS_VERT_ITEMSIZE_3:\n\tcase SQ_GSVS_RING_OFFSET_1:\n\tcase SQ_GSVS_RING_OFFSET_2:\n\tcase SQ_GSVS_RING_OFFSET_3:\n\tcase SQ_HSTMP_RING_ITEMSIZE:\n\tcase SQ_LSTMP_RING_ITEMSIZE:\n\tcase SQ_PSTMP_RING_ITEMSIZE:\n\tcase SQ_VSTMP_RING_ITEMSIZE:\n\tcase VGT_TF_RING_SIZE:\n\t\t \n\t\t \n\t\tbreak;\n\tcase SQ_ESGS_RING_BASE:\n\tcase SQ_GSVS_RING_BASE:\n\tcase SQ_ESTMP_RING_BASE:\n\tcase SQ_GSTMP_RING_BASE:\n\tcase SQ_HSTMP_RING_BASE:\n\tcase SQ_LSTMP_RING_BASE:\n\tcase SQ_PSTMP_RING_BASE:\n\tcase SQ_VSTMP_RING_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase DB_DEPTH_CONTROL:\n\t\ttrack->db_depth_control = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase CAYMAN_DB_EQAA:\n\t\tif (p->rdev->family < CHIP_CAYMAN) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase CAYMAN_DB_DEPTH_INFO:\n\t\tif (p->rdev->family < CHIP_CAYMAN) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase DB_Z_INFO:\n\t\ttrack->db_z_info = radeon_get_ib_value(p, idx);\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx] &= ~Z_ARRAY_MODE(0xf);\n\t\t\ttrack->db_z_info &= ~Z_ARRAY_MODE(0xf);\n\t\t\tib[idx] |= Z_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t\ttrack->db_z_info |= Z_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO) {\n\t\t\t\tunsigned bankw, bankh, mtaspect, tile_split;\n\n\t\t\t\tevergreen_tiling_fields(reloc->tiling_flags,\n\t\t\t\t\t\t\t&bankw, &bankh, &mtaspect,\n\t\t\t\t\t\t\t&tile_split);\n\t\t\t\tib[idx] |= DB_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\n\t\t\t\tib[idx] |= DB_TILE_SPLIT(tile_split) |\n\t\t\t\t\t\tDB_BANK_WIDTH(bankw) |\n\t\t\t\t\t\tDB_BANK_HEIGHT(bankh) |\n\t\t\t\t\t\tDB_MACRO_TILE_ASPECT(mtaspect);\n\t\t\t}\n\t\t}\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_STENCIL_INFO:\n\t\ttrack->db_s_info = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_DEPTH_VIEW:\n\t\ttrack->db_depth_view = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_DEPTH_SIZE:\n\t\ttrack->db_depth_size = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase R_02805C_DB_DEPTH_SLICE:\n\t\ttrack->db_depth_slice = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_Z_READ_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->db_z_read_offset = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->db_z_read_bo = reloc->robj;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_Z_WRITE_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->db_z_write_offset = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->db_z_write_bo = reloc->robj;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_STENCIL_READ_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->db_s_read_offset = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->db_s_read_bo = reloc->robj;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_STENCIL_WRITE_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->db_s_write_offset = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->db_s_write_bo = reloc->robj;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase VGT_STRMOUT_CONFIG:\n\t\ttrack->vgt_strmout_config = radeon_get_ib_value(p, idx);\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase VGT_STRMOUT_BUFFER_CONFIG:\n\t\ttrack->vgt_strmout_buffer_config = radeon_get_ib_value(p, idx);\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase VGT_STRMOUT_BUFFER_BASE_0:\n\tcase VGT_STRMOUT_BUFFER_BASE_1:\n\tcase VGT_STRMOUT_BUFFER_BASE_2:\n\tcase VGT_STRMOUT_BUFFER_BASE_3:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = (reg - VGT_STRMOUT_BUFFER_BASE_0) / 16;\n\t\ttrack->vgt_strmout_bo_offset[tmp] = radeon_get_ib_value(p, idx) << 8;\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->vgt_strmout_bo[tmp] = reloc->robj;\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase VGT_STRMOUT_BUFFER_SIZE_0:\n\tcase VGT_STRMOUT_BUFFER_SIZE_1:\n\tcase VGT_STRMOUT_BUFFER_SIZE_2:\n\tcase VGT_STRMOUT_BUFFER_SIZE_3:\n\t\ttmp = (reg - VGT_STRMOUT_BUFFER_SIZE_0) / 16;\n\t\t \n\t\ttrack->vgt_strmout_size[tmp] = radeon_get_ib_value(p, idx) * 4;\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase CP_COHER_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"missing reloc for CP_COHER_BASE \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase CB_TARGET_MASK:\n\t\ttrack->cb_target_mask = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_SHADER_MASK:\n\t\ttrack->cb_shader_mask = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase PA_SC_AA_CONFIG:\n\t\tif (p->rdev->family >= CHIP_CAYMAN) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = radeon_get_ib_value(p, idx) & MSAA_NUM_SAMPLES_MASK;\n\t\ttrack->nsamples = 1 << tmp;\n\t\tbreak;\n\tcase CAYMAN_PA_SC_AA_CONFIG:\n\t\tif (p->rdev->family < CHIP_CAYMAN) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = radeon_get_ib_value(p, idx) & CAYMAN_MSAA_NUM_SAMPLES_MASK;\n\t\ttrack->nsamples = 1 << tmp;\n\t\tbreak;\n\tcase CB_COLOR0_VIEW:\n\tcase CB_COLOR1_VIEW:\n\tcase CB_COLOR2_VIEW:\n\tcase CB_COLOR3_VIEW:\n\tcase CB_COLOR4_VIEW:\n\tcase CB_COLOR5_VIEW:\n\tcase CB_COLOR6_VIEW:\n\tcase CB_COLOR7_VIEW:\n\t\ttmp = (reg - CB_COLOR0_VIEW) / 0x3c;\n\t\ttrack->cb_color_view[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR8_VIEW:\n\tcase CB_COLOR9_VIEW:\n\tcase CB_COLOR10_VIEW:\n\tcase CB_COLOR11_VIEW:\n\t\ttmp = ((reg - CB_COLOR8_VIEW) / 0x1c) + 8;\n\t\ttrack->cb_color_view[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR0_INFO:\n\tcase CB_COLOR1_INFO:\n\tcase CB_COLOR2_INFO:\n\tcase CB_COLOR3_INFO:\n\tcase CB_COLOR4_INFO:\n\tcase CB_COLOR5_INFO:\n\tcase CB_COLOR6_INFO:\n\tcase CB_COLOR7_INFO:\n\t\ttmp = (reg - CB_COLOR0_INFO) / 0x3c;\n\t\ttrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t\ttrack->cb_color_info[tmp] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t}\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR8_INFO:\n\tcase CB_COLOR9_INFO:\n\tcase CB_COLOR10_INFO:\n\tcase CB_COLOR11_INFO:\n\t\ttmp = ((reg - CB_COLOR8_INFO) / 0x1c) + 8;\n\t\ttrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t\ttrack->cb_color_info[tmp] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t}\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR0_PITCH:\n\tcase CB_COLOR1_PITCH:\n\tcase CB_COLOR2_PITCH:\n\tcase CB_COLOR3_PITCH:\n\tcase CB_COLOR4_PITCH:\n\tcase CB_COLOR5_PITCH:\n\tcase CB_COLOR6_PITCH:\n\tcase CB_COLOR7_PITCH:\n\t\ttmp = (reg - CB_COLOR0_PITCH) / 0x3c;\n\t\ttrack->cb_color_pitch[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR8_PITCH:\n\tcase CB_COLOR9_PITCH:\n\tcase CB_COLOR10_PITCH:\n\tcase CB_COLOR11_PITCH:\n\t\ttmp = ((reg - CB_COLOR8_PITCH) / 0x1c) + 8;\n\t\ttrack->cb_color_pitch[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR0_SLICE:\n\tcase CB_COLOR1_SLICE:\n\tcase CB_COLOR2_SLICE:\n\tcase CB_COLOR3_SLICE:\n\tcase CB_COLOR4_SLICE:\n\tcase CB_COLOR5_SLICE:\n\tcase CB_COLOR6_SLICE:\n\tcase CB_COLOR7_SLICE:\n\t\ttmp = (reg - CB_COLOR0_SLICE) / 0x3c;\n\t\ttrack->cb_color_slice[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_color_slice_idx[tmp] = idx;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR8_SLICE:\n\tcase CB_COLOR9_SLICE:\n\tcase CB_COLOR10_SLICE:\n\tcase CB_COLOR11_SLICE:\n\t\ttmp = ((reg - CB_COLOR8_SLICE) / 0x1c) + 8;\n\t\ttrack->cb_color_slice[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_color_slice_idx[tmp] = idx;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR0_ATTRIB:\n\tcase CB_COLOR1_ATTRIB:\n\tcase CB_COLOR2_ATTRIB:\n\tcase CB_COLOR3_ATTRIB:\n\tcase CB_COLOR4_ATTRIB:\n\tcase CB_COLOR5_ATTRIB:\n\tcase CB_COLOR6_ATTRIB:\n\tcase CB_COLOR7_ATTRIB:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO) {\n\t\t\t\tunsigned bankw, bankh, mtaspect, tile_split;\n\n\t\t\t\tevergreen_tiling_fields(reloc->tiling_flags,\n\t\t\t\t\t\t\t&bankw, &bankh, &mtaspect,\n\t\t\t\t\t\t\t&tile_split);\n\t\t\t\tib[idx] |= CB_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\n\t\t\t\tib[idx] |= CB_TILE_SPLIT(tile_split) |\n\t\t\t\t\t   CB_BANK_WIDTH(bankw) |\n\t\t\t\t\t   CB_BANK_HEIGHT(bankh) |\n\t\t\t\t\t   CB_MACRO_TILE_ASPECT(mtaspect);\n\t\t\t}\n\t\t}\n\t\ttmp = ((reg - CB_COLOR0_ATTRIB) / 0x3c);\n\t\ttrack->cb_color_attrib[tmp] = ib[idx];\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR8_ATTRIB:\n\tcase CB_COLOR9_ATTRIB:\n\tcase CB_COLOR10_ATTRIB:\n\tcase CB_COLOR11_ATTRIB:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO) {\n\t\t\t\tunsigned bankw, bankh, mtaspect, tile_split;\n\n\t\t\t\tevergreen_tiling_fields(reloc->tiling_flags,\n\t\t\t\t\t\t\t&bankw, &bankh, &mtaspect,\n\t\t\t\t\t\t\t&tile_split);\n\t\t\t\tib[idx] |= CB_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\n\t\t\t\tib[idx] |= CB_TILE_SPLIT(tile_split) |\n\t\t\t\t\t   CB_BANK_WIDTH(bankw) |\n\t\t\t\t\t   CB_BANK_HEIGHT(bankh) |\n\t\t\t\t\t   CB_MACRO_TILE_ASPECT(mtaspect);\n\t\t\t}\n\t\t}\n\t\ttmp = ((reg - CB_COLOR8_ATTRIB) / 0x1c) + 8;\n\t\ttrack->cb_color_attrib[tmp] = ib[idx];\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR0_FMASK:\n\tcase CB_COLOR1_FMASK:\n\tcase CB_COLOR2_FMASK:\n\tcase CB_COLOR3_FMASK:\n\tcase CB_COLOR4_FMASK:\n\tcase CB_COLOR5_FMASK:\n\tcase CB_COLOR6_FMASK:\n\tcase CB_COLOR7_FMASK:\n\t\ttmp = (reg - CB_COLOR0_FMASK) / 0x3c;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_err(p->dev, \"bad SET_CONTEXT_REG 0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->cb_color_fmask_bo[tmp] = reloc->robj;\n\t\tbreak;\n\tcase CB_COLOR0_CMASK:\n\tcase CB_COLOR1_CMASK:\n\tcase CB_COLOR2_CMASK:\n\tcase CB_COLOR3_CMASK:\n\tcase CB_COLOR4_CMASK:\n\tcase CB_COLOR5_CMASK:\n\tcase CB_COLOR6_CMASK:\n\tcase CB_COLOR7_CMASK:\n\t\ttmp = (reg - CB_COLOR0_CMASK) / 0x3c;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_err(p->dev, \"bad SET_CONTEXT_REG 0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->cb_color_cmask_bo[tmp] = reloc->robj;\n\t\tbreak;\n\tcase CB_COLOR0_FMASK_SLICE:\n\tcase CB_COLOR1_FMASK_SLICE:\n\tcase CB_COLOR2_FMASK_SLICE:\n\tcase CB_COLOR3_FMASK_SLICE:\n\tcase CB_COLOR4_FMASK_SLICE:\n\tcase CB_COLOR5_FMASK_SLICE:\n\tcase CB_COLOR6_FMASK_SLICE:\n\tcase CB_COLOR7_FMASK_SLICE:\n\t\ttmp = (reg - CB_COLOR0_FMASK_SLICE) / 0x3c;\n\t\ttrack->cb_color_fmask_slice[tmp] = radeon_get_ib_value(p, idx);\n\t\tbreak;\n\tcase CB_COLOR0_CMASK_SLICE:\n\tcase CB_COLOR1_CMASK_SLICE:\n\tcase CB_COLOR2_CMASK_SLICE:\n\tcase CB_COLOR3_CMASK_SLICE:\n\tcase CB_COLOR4_CMASK_SLICE:\n\tcase CB_COLOR5_CMASK_SLICE:\n\tcase CB_COLOR6_CMASK_SLICE:\n\tcase CB_COLOR7_CMASK_SLICE:\n\t\ttmp = (reg - CB_COLOR0_CMASK_SLICE) / 0x3c;\n\t\ttrack->cb_color_cmask_slice[tmp] = radeon_get_ib_value(p, idx);\n\t\tbreak;\n\tcase CB_COLOR0_BASE:\n\tcase CB_COLOR1_BASE:\n\tcase CB_COLOR2_BASE:\n\tcase CB_COLOR3_BASE:\n\tcase CB_COLOR4_BASE:\n\tcase CB_COLOR5_BASE:\n\tcase CB_COLOR6_BASE:\n\tcase CB_COLOR7_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = (reg - CB_COLOR0_BASE) / 0x3c;\n\t\ttrack->cb_color_bo_offset[tmp] = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->cb_color_bo[tmp] = reloc->robj;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase CB_COLOR8_BASE:\n\tcase CB_COLOR9_BASE:\n\tcase CB_COLOR10_BASE:\n\tcase CB_COLOR11_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = ((reg - CB_COLOR8_BASE) / 0x1c) + 8;\n\t\ttrack->cb_color_bo_offset[tmp] = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->cb_color_bo[tmp] = reloc->robj;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase DB_HTILE_DATA_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->htile_offset = radeon_get_ib_value(p, idx);\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->htile_bo = reloc->robj;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_HTILE_SURFACE:\n\t\t \n\t\ttrack->htile_surface = radeon_get_ib_value(p, idx);\n\t\t \n\t\tib[idx] |= 3;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase CB_IMMED0_BASE:\n\tcase CB_IMMED1_BASE:\n\tcase CB_IMMED2_BASE:\n\tcase CB_IMMED3_BASE:\n\tcase CB_IMMED4_BASE:\n\tcase CB_IMMED5_BASE:\n\tcase CB_IMMED6_BASE:\n\tcase CB_IMMED7_BASE:\n\tcase CB_IMMED8_BASE:\n\tcase CB_IMMED9_BASE:\n\tcase CB_IMMED10_BASE:\n\tcase CB_IMMED11_BASE:\n\tcase SQ_PGM_START_FS:\n\tcase SQ_PGM_START_ES:\n\tcase SQ_PGM_START_VS:\n\tcase SQ_PGM_START_GS:\n\tcase SQ_PGM_START_PS:\n\tcase SQ_PGM_START_HS:\n\tcase SQ_PGM_START_LS:\n\tcase SQ_CONST_MEM_BASE:\n\tcase SQ_ALU_CONST_CACHE_GS_0:\n\tcase SQ_ALU_CONST_CACHE_GS_1:\n\tcase SQ_ALU_CONST_CACHE_GS_2:\n\tcase SQ_ALU_CONST_CACHE_GS_3:\n\tcase SQ_ALU_CONST_CACHE_GS_4:\n\tcase SQ_ALU_CONST_CACHE_GS_5:\n\tcase SQ_ALU_CONST_CACHE_GS_6:\n\tcase SQ_ALU_CONST_CACHE_GS_7:\n\tcase SQ_ALU_CONST_CACHE_GS_8:\n\tcase SQ_ALU_CONST_CACHE_GS_9:\n\tcase SQ_ALU_CONST_CACHE_GS_10:\n\tcase SQ_ALU_CONST_CACHE_GS_11:\n\tcase SQ_ALU_CONST_CACHE_GS_12:\n\tcase SQ_ALU_CONST_CACHE_GS_13:\n\tcase SQ_ALU_CONST_CACHE_GS_14:\n\tcase SQ_ALU_CONST_CACHE_GS_15:\n\tcase SQ_ALU_CONST_CACHE_PS_0:\n\tcase SQ_ALU_CONST_CACHE_PS_1:\n\tcase SQ_ALU_CONST_CACHE_PS_2:\n\tcase SQ_ALU_CONST_CACHE_PS_3:\n\tcase SQ_ALU_CONST_CACHE_PS_4:\n\tcase SQ_ALU_CONST_CACHE_PS_5:\n\tcase SQ_ALU_CONST_CACHE_PS_6:\n\tcase SQ_ALU_CONST_CACHE_PS_7:\n\tcase SQ_ALU_CONST_CACHE_PS_8:\n\tcase SQ_ALU_CONST_CACHE_PS_9:\n\tcase SQ_ALU_CONST_CACHE_PS_10:\n\tcase SQ_ALU_CONST_CACHE_PS_11:\n\tcase SQ_ALU_CONST_CACHE_PS_12:\n\tcase SQ_ALU_CONST_CACHE_PS_13:\n\tcase SQ_ALU_CONST_CACHE_PS_14:\n\tcase SQ_ALU_CONST_CACHE_PS_15:\n\tcase SQ_ALU_CONST_CACHE_VS_0:\n\tcase SQ_ALU_CONST_CACHE_VS_1:\n\tcase SQ_ALU_CONST_CACHE_VS_2:\n\tcase SQ_ALU_CONST_CACHE_VS_3:\n\tcase SQ_ALU_CONST_CACHE_VS_4:\n\tcase SQ_ALU_CONST_CACHE_VS_5:\n\tcase SQ_ALU_CONST_CACHE_VS_6:\n\tcase SQ_ALU_CONST_CACHE_VS_7:\n\tcase SQ_ALU_CONST_CACHE_VS_8:\n\tcase SQ_ALU_CONST_CACHE_VS_9:\n\tcase SQ_ALU_CONST_CACHE_VS_10:\n\tcase SQ_ALU_CONST_CACHE_VS_11:\n\tcase SQ_ALU_CONST_CACHE_VS_12:\n\tcase SQ_ALU_CONST_CACHE_VS_13:\n\tcase SQ_ALU_CONST_CACHE_VS_14:\n\tcase SQ_ALU_CONST_CACHE_VS_15:\n\tcase SQ_ALU_CONST_CACHE_HS_0:\n\tcase SQ_ALU_CONST_CACHE_HS_1:\n\tcase SQ_ALU_CONST_CACHE_HS_2:\n\tcase SQ_ALU_CONST_CACHE_HS_3:\n\tcase SQ_ALU_CONST_CACHE_HS_4:\n\tcase SQ_ALU_CONST_CACHE_HS_5:\n\tcase SQ_ALU_CONST_CACHE_HS_6:\n\tcase SQ_ALU_CONST_CACHE_HS_7:\n\tcase SQ_ALU_CONST_CACHE_HS_8:\n\tcase SQ_ALU_CONST_CACHE_HS_9:\n\tcase SQ_ALU_CONST_CACHE_HS_10:\n\tcase SQ_ALU_CONST_CACHE_HS_11:\n\tcase SQ_ALU_CONST_CACHE_HS_12:\n\tcase SQ_ALU_CONST_CACHE_HS_13:\n\tcase SQ_ALU_CONST_CACHE_HS_14:\n\tcase SQ_ALU_CONST_CACHE_HS_15:\n\tcase SQ_ALU_CONST_CACHE_LS_0:\n\tcase SQ_ALU_CONST_CACHE_LS_1:\n\tcase SQ_ALU_CONST_CACHE_LS_2:\n\tcase SQ_ALU_CONST_CACHE_LS_3:\n\tcase SQ_ALU_CONST_CACHE_LS_4:\n\tcase SQ_ALU_CONST_CACHE_LS_5:\n\tcase SQ_ALU_CONST_CACHE_LS_6:\n\tcase SQ_ALU_CONST_CACHE_LS_7:\n\tcase SQ_ALU_CONST_CACHE_LS_8:\n\tcase SQ_ALU_CONST_CACHE_LS_9:\n\tcase SQ_ALU_CONST_CACHE_LS_10:\n\tcase SQ_ALU_CONST_CACHE_LS_11:\n\tcase SQ_ALU_CONST_CACHE_LS_12:\n\tcase SQ_ALU_CONST_CACHE_LS_13:\n\tcase SQ_ALU_CONST_CACHE_LS_14:\n\tcase SQ_ALU_CONST_CACHE_LS_15:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase SX_MEMORY_EXPORT_BASE:\n\t\tif (p->rdev->family >= CHIP_CAYMAN) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONFIG_REG \"\n\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONFIG_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase CAYMAN_SX_SCATTER_EXPORT_BASE:\n\t\tif (p->rdev->family < CHIP_CAYMAN) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase SX_MISC:\n\t\ttrack->sx_misc_kill_all_prims = (radeon_get_ib_value(p, idx) & 0x1) != 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\", reg, idx);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic inline bool evergreen_is_safe_reg(struct radeon_cs_parser *p, u32 reg)\n{\n\tstruct evergreen_cs_track *track = p->track;\n\tu32 m, i;\n\n\ti = (reg >> 7);\n\tif (unlikely(i >= REG_SAFE_BM_SIZE)) {\n\t\treturn false;\n\t}\n\tm = 1 << ((reg >> 2) & 31);\n\tif (!(track->reg_safe_bm[i] & m))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int evergreen_packet3_check(struct radeon_cs_parser *p,\n\t\t\t\t   struct radeon_cs_packet *pkt)\n{\n\tstruct radeon_bo_list *reloc;\n\tstruct evergreen_cs_track *track;\n\tuint32_t *ib;\n\tunsigned idx;\n\tunsigned i;\n\tunsigned start_reg, end_reg, reg;\n\tint r;\n\tu32 idx_value;\n\n\ttrack = (struct evergreen_cs_track *)p->track;\n\tib = p->ib.ptr;\n\tidx = pkt->idx + 1;\n\tidx_value = radeon_get_ib_value(p, idx);\n\n\tswitch (pkt->opcode) {\n\tcase PACKET3_SET_PREDICATION:\n\t{\n\t\tint pred_op;\n\t\tint tmp;\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad SET PREDICATION\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttmp = radeon_get_ib_value(p, idx + 1);\n\t\tpred_op = (tmp >> 16) & 0x7;\n\n\t\t \n\t\tif (pred_op == 0)\n\t\t\treturn 0;\n\n\t\tif (pred_op > 2) {\n\t\t\tDRM_ERROR(\"bad SET PREDICATION operation %d\\n\", pred_op);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad SET PREDICATION\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t (idx_value & 0xfffffff0) +\n\t\t\t ((u64)(tmp & 0xff) << 32);\n\n\t\tib[idx + 0] = offset;\n\t\tib[idx + 1] = (tmp & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t}\n\tbreak;\n\tcase PACKET3_CONTEXT_CONTROL:\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad CONTEXT_CONTROL\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_INDEX_TYPE:\n\tcase PACKET3_NUM_INSTANCES:\n\tcase PACKET3_CLEAR_STATE:\n\t\tif (pkt->count) {\n\t\t\tDRM_ERROR(\"bad INDEX_TYPE/NUM_INSTANCES/CLEAR_STATE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase CAYMAN_PACKET3_DEALLOC_STATE:\n\t\tif (p->rdev->family < CHIP_CAYMAN) {\n\t\t\tDRM_ERROR(\"bad PACKET3_DEALLOC_STATE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt->count) {\n\t\t\tDRM_ERROR(\"bad INDEX_TYPE/NUM_INSTANCES/CLEAR_STATE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_INDEX_BASE:\n\t{\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad INDEX_BASE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad INDEX_BASE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t idx_value +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\n\n\t\tib[idx+0] = offset;\n\t\tib[idx+1] = upper_32_bits(offset) & 0xff;\n\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_INDEX_BUFFER_SIZE:\n\t{\n\t\tif (pkt->count != 0) {\n\t\t\tDRM_ERROR(\"bad INDEX_BUFFER_SIZE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_DRAW_INDEX:\n\t{\n\t\tuint64_t offset;\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t idx_value +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\n\n\t\tib[idx+0] = offset;\n\t\tib[idx+1] = upper_32_bits(offset) & 0xff;\n\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_DRAW_INDEX_2:\n\t{\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t radeon_get_ib_value(p, idx+1) +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\tib[idx+1] = offset;\n\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_DRAW_INDEX_AUTO:\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_AUTO\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream %d\\n\", __func__, __LINE__, idx);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DRAW_INDEX_MULTI_AUTO:\n\t\tif (pkt->count != 2) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_MULTI_AUTO\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream %d\\n\", __func__, __LINE__, idx);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DRAW_INDEX_IMMD:\n\t\tif (pkt->count < 2) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_IMMD\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DRAW_INDEX_OFFSET:\n\t\tif (pkt->count != 2) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_OFFSET\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DRAW_INDEX_OFFSET_2:\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_OFFSET_2\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_BASE:\n\t{\n\t\t \n\t\tif (pkt->count != 2) {\n\t\t\tDRM_ERROR(\"bad SET_BASE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (idx_value != 1) {\n\t\t\tDRM_ERROR(\"bad SET_BASE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad SET_BASE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttrack->indirect_draw_buffer_size = radeon_bo_size(reloc->robj);\n\n\t\tib[idx+1] = reloc->gpu_offset;\n\t\tib[idx+2] = upper_32_bits(reloc->gpu_offset) & 0xff;\n\n\t\tbreak;\n\t}\n\tcase PACKET3_DRAW_INDIRECT:\n\tcase PACKET3_DRAW_INDEX_INDIRECT:\n\t{\n\t\tu64 size = pkt->opcode == PACKET3_DRAW_INDIRECT ? 16 : 20;\n\n\t\t \n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDIRECT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (idx_value + size > track->indirect_draw_buffer_size) {\n\t\t\tdev_warn(p->dev, \"DRAW_INDIRECT buffer too small %u + %llu > %lu\\n\",\n\t\t\t\tidx_value, size, track->indirect_draw_buffer_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_DISPATCH_DIRECT:\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad DISPATCH_DIRECT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream %d\\n\", __func__, __LINE__, idx);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DISPATCH_INDIRECT:\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad DISPATCH_INDIRECT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad DISPATCH_INDIRECT\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx+0] = idx_value + (u32)(reloc->gpu_offset & 0xffffffff);\n\t\tr = evergreen_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_WAIT_REG_MEM:\n\t\tif (pkt->count != 5) {\n\t\t\tDRM_ERROR(\"bad WAIT_REG_MEM\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (idx_value & 0x10) {\n\t\t\tuint64_t offset;\n\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad WAIT_REG_MEM\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\toffset = reloc->gpu_offset +\n\t\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\n\t\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\t\tib[idx+1] = (ib[idx+1] & 0x3) | (offset & 0xfffffffc);\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t} else if (idx_value & 0x100) {\n\t\t\tDRM_ERROR(\"cannot use PFP on REG wait\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CP_DMA:\n\t{\n\t\tu32 command, size, info;\n\t\tu64 offset, tmp;\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad CP DMA\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcommand = radeon_get_ib_value(p, idx+4);\n\t\tsize = command & 0x1fffff;\n\t\tinfo = radeon_get_ib_value(p, idx+1);\n\t\tif ((((info & 0x60000000) >> 29) != 0) ||  \n\t\t    (((info & 0x00300000) >> 20) != 0) ||  \n\t\t    ((((info & 0x00300000) >> 20) == 0) &&\n\t\t     (command & PACKET3_CP_DMA_CMD_DAS)) ||  \n\t\t    ((((info & 0x60000000) >> 29) == 0) &&\n\t\t     (command & PACKET3_CP_DMA_CMD_SAS))) {  \n\t\t\t \n\t\t\tif (size % 4) {\n\t\t\t\tDRM_ERROR(\"CP DMA command requires dw count alignment\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (command & PACKET3_CP_DMA_CMD_SAS) {\n\t\t\t \n\t\t\t \n\t\t\tif (((info & 0x60000000) >> 29) != 1) {\n\t\t\t\tDRM_ERROR(\"CP DMA SAS not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (command & PACKET3_CP_DMA_CMD_SAIC) {\n\t\t\t\tDRM_ERROR(\"CP DMA SAIC only supported for registers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tif (((info & 0x60000000) >> 29) == 0) {\n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad CP DMA SRC\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\ttmp = radeon_get_ib_value(p, idx) +\n\t\t\t\t\t((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\n\n\t\t\t\toffset = reloc->gpu_offset + tmp;\n\n\t\t\t\tif ((tmp + size) > radeon_bo_size(reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"CP DMA src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t tmp + size, radeon_bo_size(reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tib[idx] = offset;\n\t\t\t\tib[idx+1] = (ib[idx+1] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t\t\t} else if (((info & 0x60000000) >> 29) != 2) {\n\t\t\t\tDRM_ERROR(\"bad CP DMA SRC_SEL\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (command & PACKET3_CP_DMA_CMD_DAS) {\n\t\t\t \n\t\t\t \n\t\t\tif (((info & 0x00300000) >> 20) != 1) {\n\t\t\t\tDRM_ERROR(\"CP DMA DAS not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (command & PACKET3_CP_DMA_CMD_DAIC) {\n\t\t\t\tDRM_ERROR(\"CP DMA DAIC only supported for registers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (((info & 0x00300000) >> 20) == 0) {\n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad CP DMA DST\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\ttmp = radeon_get_ib_value(p, idx+2) +\n\t\t\t\t\t((u64)(radeon_get_ib_value(p, idx+3) & 0xff) << 32);\n\n\t\t\t\toffset = reloc->gpu_offset + tmp;\n\n\t\t\t\tif ((tmp + size) > radeon_bo_size(reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"CP DMA dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t tmp + size, radeon_bo_size(reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tib[idx+2] = offset;\n\t\t\t\tib[idx+3] = upper_32_bits(offset) & 0xff;\n\t\t\t} else {\n\t\t\t\tDRM_ERROR(\"bad CP DMA DST_SEL\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_PFP_SYNC_ME:\n\t\tif (pkt->count) {\n\t\t\tDRM_ERROR(\"bad PFP_SYNC_ME\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SURFACE_SYNC:\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad SURFACE_SYNC\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (radeon_get_ib_value(p, idx + 1) != 0xffffffff ||\n\t\t    radeon_get_ib_value(p, idx + 2) != 0) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad SURFACE_SYNC\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx+2] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t}\n\t\tbreak;\n\tcase PACKET3_EVENT_WRITE:\n\t\tif (pkt->count != 2 && pkt->count != 0) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt->count) {\n\t\t\tuint64_t offset;\n\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad EVENT_WRITE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = reloc->gpu_offset +\n\t\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffff8) +\n\t\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\t\tib[idx+1] = offset & 0xfffffff8;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_EVENT_WRITE_EOP:\n\t{\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE_EOP\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE_EOP\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\tib[idx+1] = offset & 0xfffffffc;\n\t\tib[idx+2] = (ib[idx+2] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t\tbreak;\n\t}\n\tcase PACKET3_EVENT_WRITE_EOS:\n\t{\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE_EOS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE_EOS\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\tib[idx+1] = offset & 0xfffffffc;\n\t\tib[idx+2] = (ib[idx+2] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t\tbreak;\n\t}\n\tcase PACKET3_SET_CONFIG_REG:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CONFIG_REG_START) ||\n\t\t    (start_reg >= PACKET3_SET_CONFIG_REG_END) ||\n\t\t    (end_reg >= PACKET3_SET_CONFIG_REG_END)) {\n\t\t\tDRM_ERROR(\"bad PACKET3_SET_CONFIG_REG\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (reg = start_reg, idx++; reg <= end_reg; reg += 4, idx++) {\n\t\t\tif (evergreen_is_safe_reg(p, reg))\n\t\t\t\tcontinue;\n\t\t\tr = evergreen_cs_handle_reg(p, reg, idx);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_CONTEXT_REG:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CONTEXT_REG_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CONTEXT_REG_START) ||\n\t\t    (start_reg >= PACKET3_SET_CONTEXT_REG_END) ||\n\t\t    (end_reg >= PACKET3_SET_CONTEXT_REG_END)) {\n\t\t\tDRM_ERROR(\"bad PACKET3_SET_CONTEXT_REG\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (reg = start_reg, idx++; reg <= end_reg; reg += 4, idx++) {\n\t\t\tif (evergreen_is_safe_reg(p, reg))\n\t\t\t\tcontinue;\n\t\t\tr = evergreen_cs_handle_reg(p, reg, idx);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_RESOURCE:\n\t\tif (pkt->count % 8) {\n\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_RESOURCE_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_RESOURCE_START) ||\n\t\t    (start_reg >= PACKET3_SET_RESOURCE_END) ||\n\t\t    (end_reg >= PACKET3_SET_RESOURCE_END)) {\n\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < (pkt->count / 8); i++) {\n\t\t\tstruct radeon_bo *texture, *mipmap;\n\t\t\tu32 toffset, moffset;\n\t\t\tu32 size, offset, mip_address, tex_dim;\n\n\t\t\tswitch (G__SQ_CONSTANT_TYPE(radeon_get_ib_value(p, idx+1+(i*8)+7))) {\n\t\t\tcase SQ_TEX_VTX_VALID_TEXTURE:\n\t\t\t\t \n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE (tex)\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\t\t\tib[idx+1+(i*8)+1] |=\n\t\t\t\t\t\tTEX_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\n\t\t\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO) {\n\t\t\t\t\t\tunsigned bankw, bankh, mtaspect, tile_split;\n\n\t\t\t\t\t\tevergreen_tiling_fields(reloc->tiling_flags,\n\t\t\t\t\t\t\t\t\t&bankw, &bankh, &mtaspect,\n\t\t\t\t\t\t\t\t\t&tile_split);\n\t\t\t\t\t\tib[idx+1+(i*8)+6] |= TEX_TILE_SPLIT(tile_split);\n\t\t\t\t\t\tib[idx+1+(i*8)+7] |=\n\t\t\t\t\t\t\tTEX_BANK_WIDTH(bankw) |\n\t\t\t\t\t\t\tTEX_BANK_HEIGHT(bankh) |\n\t\t\t\t\t\t\tMACRO_TILE_ASPECT(mtaspect) |\n\t\t\t\t\t\t\tTEX_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttexture = reloc->robj;\n\t\t\t\ttoffset = (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\n\t\t\t\t \n\t\t\t\ttex_dim = ib[idx+1+(i*8)+0] & 0x7;\n\t\t\t\tmip_address = ib[idx+1+(i*8)+3];\n\n\t\t\t\tif ((tex_dim == SQ_TEX_DIM_2D_MSAA || tex_dim == SQ_TEX_DIM_2D_ARRAY_MSAA) &&\n\t\t\t\t    !mip_address &&\n\t\t\t\t    !radeon_cs_packet_next_is_pkt3_nop(p)) {\n\t\t\t\t\t \n\t\t\t\t\tmoffset = 0;\n\t\t\t\t\tmipmap = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\t\t\tif (r) {\n\t\t\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE (tex)\\n\");\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\tmoffset = (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t\t\t\tmipmap = reloc->robj;\n\t\t\t\t}\n\n\t\t\t\tr = evergreen_cs_track_validate_texture(p, texture, mipmap, idx+1+(i*8));\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\t\t\t\tib[idx+1+(i*8)+2] += toffset;\n\t\t\t\tib[idx+1+(i*8)+3] += moffset;\n\t\t\t\tbreak;\n\t\t\tcase SQ_TEX_VTX_VALID_BUFFER:\n\t\t\t{\n\t\t\t\tuint64_t offset64;\n\t\t\t\t \n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE (vtx)\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\toffset = radeon_get_ib_value(p, idx+1+(i*8)+0);\n\t\t\t\tsize = radeon_get_ib_value(p, idx+1+(i*8)+1);\n\t\t\t\tif (p->rdev && (size + offset) > radeon_bo_size(reloc->robj)) {\n\t\t\t\t\t \n\t\t\t\t\tdev_warn_ratelimited(p->dev, \"vbo resource seems too big for the bo\\n\");\n\t\t\t\t\tib[idx+1+(i*8)+1] = radeon_bo_size(reloc->robj) - offset;\n\t\t\t\t}\n\n\t\t\t\toffset64 = reloc->gpu_offset + offset;\n\t\t\t\tib[idx+1+(i*8)+0] = offset64;\n\t\t\t\tib[idx+1+(i*8)+2] = (ib[idx+1+(i*8)+2] & 0xffffff00) |\n\t\t\t\t\t\t    (upper_32_bits(offset64) & 0xff);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SQ_TEX_VTX_INVALID_TEXTURE:\n\t\t\tcase SQ_TEX_VTX_INVALID_BUFFER:\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_ALU_CONST:\n\t\t \n\t\tbreak;\n\tcase PACKET3_SET_BOOL_CONST:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_BOOL_CONST_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_BOOL_CONST_START) ||\n\t\t    (start_reg >= PACKET3_SET_BOOL_CONST_END) ||\n\t\t    (end_reg >= PACKET3_SET_BOOL_CONST_END)) {\n\t\t\tDRM_ERROR(\"bad SET_BOOL_CONST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_LOOP_CONST:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_LOOP_CONST_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_LOOP_CONST_START) ||\n\t\t    (start_reg >= PACKET3_SET_LOOP_CONST_END) ||\n\t\t    (end_reg >= PACKET3_SET_LOOP_CONST_END)) {\n\t\t\tDRM_ERROR(\"bad SET_LOOP_CONST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_CTL_CONST:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CTL_CONST_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CTL_CONST_START) ||\n\t\t    (start_reg >= PACKET3_SET_CTL_CONST_END) ||\n\t\t    (end_reg >= PACKET3_SET_CTL_CONST_END)) {\n\t\t\tDRM_ERROR(\"bad SET_CTL_CONST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_SAMPLER:\n\t\tif (pkt->count % 3) {\n\t\t\tDRM_ERROR(\"bad SET_SAMPLER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_SAMPLER_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_SAMPLER_START) ||\n\t\t    (start_reg >= PACKET3_SET_SAMPLER_END) ||\n\t\t    (end_reg >= PACKET3_SET_SAMPLER_END)) {\n\t\t\tDRM_ERROR(\"bad SET_SAMPLER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_STRMOUT_BUFFER_UPDATE:\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (idx_value & 0x1) {\n\t\t\tu64 offset;\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE (missing dst reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+1);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE dst bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+1] = offset;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\t \n\t\tif (((idx_value >> 1) & 0x3) == 2) {\n\t\t\tu64 offset;\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE (missing src reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+3);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE src bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+3] = offset;\n\t\t\tib[idx+4] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_MEM_WRITE:\n\t{\n\t\tu64 offset;\n\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE (missing reloc)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset = radeon_get_ib_value(p, idx+0);\n\t\toffset += ((u64)(radeon_get_ib_value(p, idx+1) & 0xff)) << 32UL;\n\t\tif (offset & 0x7) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE (address not qwords aligned)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((offset + 8) > radeon_bo_size(reloc->robj)) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t  offset + 8, radeon_bo_size(reloc->robj));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset += reloc->gpu_offset;\n\t\tib[idx+0] = offset;\n\t\tib[idx+1] = upper_32_bits(offset) & 0xff;\n\t\tbreak;\n\t}\n\tcase PACKET3_COPY_DW:\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad COPY_DW (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (idx_value & 0x1) {\n\t\t\tu64 offset;\n\t\t\t \n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW (missing src reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+1);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW src bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+1] = offset;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t} else {\n\t\t\t \n\t\t\treg = radeon_get_ib_value(p, idx+1) << 2;\n\t\t\tif (!evergreen_is_safe_reg(p, reg)) {\n\t\t\t\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\",\n\t\t\t\t\t reg, idx + 1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (idx_value & 0x2) {\n\t\t\tu64 offset;\n\t\t\t \n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW (missing dst reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+3);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW dst bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+3] = offset;\n\t\t\tib[idx+4] = upper_32_bits(offset) & 0xff;\n\t\t} else {\n\t\t\t \n\t\t\treg = radeon_get_ib_value(p, idx+3) << 2;\n\t\t\tif (!evergreen_is_safe_reg(p, reg)) {\n\t\t\t\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\",\n\t\t\t\t\t reg, idx + 3);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_APPEND_CNT:\n\t{\n\t\tuint32_t areg;\n\t\tuint32_t allowed_reg_base;\n\t\tuint32_t source_sel;\n\t\tif (pkt->count != 2) {\n\t\t\tDRM_ERROR(\"bad SET_APPEND_CNT (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tallowed_reg_base = GDS_APPEND_COUNT_0;\n\t\tallowed_reg_base -= PACKET3_SET_CONTEXT_REG_START;\n\t\tallowed_reg_base >>= 2;\n\n\t\tareg = idx_value >> 16;\n\t\tif (areg < allowed_reg_base || areg > (allowed_reg_base + 11)) {\n\t\t\tdev_warn(p->dev, \"forbidden register for append cnt 0x%08x at %d\\n\",\n\t\t\t\t areg, idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsource_sel = G_PACKET3_SET_APPEND_CNT_SRC_SELECT(idx_value);\n\t\tif (source_sel == PACKET3_SAC_SRC_SEL_MEM) {\n\t\t\tuint64_t offset;\n\t\t\tuint32_t swap;\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad SET_APPEND_CNT (missing reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx + 1);\n\t\t\tswap = offset & 0x3;\n\t\t\toffset &= ~0x3;\n\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx + 2) & 0xff)) << 32;\n\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+1] = (offset & 0xfffffffc) | swap;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t} else {\n\t\t\tDRM_ERROR(\"bad SET_APPEND_CNT (unsupported operation)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_NOP:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Packet3 opcode %x not supported\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint evergreen_cs_parse(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_packet pkt;\n\tstruct evergreen_cs_track *track;\n\tu32 tmp;\n\tint r;\n\n\tif (p->track == NULL) {\n\t\t \n\t\ttrack = kzalloc(sizeof(*track), GFP_KERNEL);\n\t\tif (track == NULL)\n\t\t\treturn -ENOMEM;\n\t\tevergreen_cs_track_init(track);\n\t\tif (p->rdev->family >= CHIP_CAYMAN) {\n\t\t\ttmp = p->rdev->config.cayman.tile_config;\n\t\t\ttrack->reg_safe_bm = cayman_reg_safe_bm;\n\t\t} else {\n\t\t\ttmp = p->rdev->config.evergreen.tile_config;\n\t\t\ttrack->reg_safe_bm = evergreen_reg_safe_bm;\n\t\t}\n\t\tBUILD_BUG_ON(ARRAY_SIZE(cayman_reg_safe_bm) != REG_SAFE_BM_SIZE);\n\t\tBUILD_BUG_ON(ARRAY_SIZE(evergreen_reg_safe_bm) != REG_SAFE_BM_SIZE);\n\t\tswitch (tmp & 0xf) {\n\t\tcase 0:\n\t\t\ttrack->npipes = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\ttrack->npipes = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrack->npipes = 4;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttrack->npipes = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((tmp & 0xf0) >> 4) {\n\t\tcase 0:\n\t\t\ttrack->nbanks = 4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\ttrack->nbanks = 8;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrack->nbanks = 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((tmp & 0xf00) >> 8) {\n\t\tcase 0:\n\t\t\ttrack->group_size = 256;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\ttrack->group_size = 512;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch ((tmp & 0xf000) >> 12) {\n\t\tcase 0:\n\t\t\ttrack->row_size = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\ttrack->row_size = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrack->row_size = 4;\n\t\t\tbreak;\n\t\t}\n\n\t\tp->track = track;\n\t}\n\tdo {\n\t\tr = radeon_cs_packet_parse(p, &pkt, p->idx);\n\t\tif (r) {\n\t\t\tkfree(p->track);\n\t\t\tp->track = NULL;\n\t\t\treturn r;\n\t\t}\n\t\tp->idx += pkt.count + 2;\n\t\tswitch (pkt.type) {\n\t\tcase RADEON_PACKET_TYPE0:\n\t\t\tr = evergreen_cs_parse_packet0(p, &pkt);\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE2:\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE3:\n\t\t\tr = evergreen_packet3_check(p, &pkt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d !\\n\", pkt.type);\n\t\t\tkfree(p->track);\n\t\t\tp->track = NULL;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (r) {\n\t\t\tkfree(p->track);\n\t\t\tp->track = NULL;\n\t\t\treturn r;\n\t\t}\n\t} while (p->idx < p->chunk_ib->length_dw);\n#if 0\n\tfor (r = 0; r < p->ib.length_dw; r++) {\n\t\tpr_info(\"%05d  0x%08X\\n\", r, p->ib.ptr[r]);\n\t\tmdelay(1);\n\t}\n#endif\n\tkfree(p->track);\n\tp->track = NULL;\n\treturn 0;\n}\n\n \nint evergreen_dma_cs_parse(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_chunk *ib_chunk = p->chunk_ib;\n\tstruct radeon_bo_list *src_reloc, *dst_reloc, *dst2_reloc;\n\tu32 header, cmd, count, sub_cmd;\n\tuint32_t *ib = p->ib.ptr;\n\tu32 idx;\n\tu64 src_offset, dst_offset, dst2_offset;\n\tint r;\n\n\tdo {\n\t\tif (p->idx >= ib_chunk->length_dw) {\n\t\t\tDRM_ERROR(\"Can not parse packet at %d after CS end %d !\\n\",\n\t\t\t\t  p->idx, ib_chunk->length_dw);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tidx = p->idx;\n\t\theader = radeon_get_ib_value(p, idx);\n\t\tcmd = GET_DMA_CMD(header);\n\t\tcount = GET_DMA_COUNT(header);\n\t\tsub_cmd = GET_DMA_SUB_CMD(header);\n\n\t\tswitch (cmd) {\n\t\tcase DMA_PACKET_WRITE:\n\t\t\tr = r600_dma_cs_next_reloc(p, &dst_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_WRITE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tswitch (sub_cmd) {\n\t\t\t \n\t\t\tcase 8:\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset <<= 8;\n\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\tp->idx += count + 7;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0:\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\n\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+2] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += count + 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_WRITE [%6d] 0x%08x sub cmd is not 0 or 8\\n\", idx, header);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"DMA write buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t dst_offset, radeon_bo_size(dst_reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMA_PACKET_COPY:\n\t\t\tr = r600_dma_cs_next_reloc(p, &src_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_COPY\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr = r600_dma_cs_next_reloc(p, &dst_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_COPY\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tswitch (sub_cmd) {\n\t\t\t \n\t\t\tcase 0x00:\n\t\t\t\t \n\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, dw src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, dw dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+2] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+3] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\tib[idx+4] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += 5;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x08:\n\t\t\t\t \n\t\t\t\tif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\n\t\t\t\t\t \n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tsrc_offset <<= 8;\n\t\t\t\t\tib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\n\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx + 7);\n\t\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\n\t\t\t\t\tib[idx+7] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+8] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+7);\n\t\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\n\t\t\t\t\tib[idx+7] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+8] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tdst_offset <<= 8;\n\t\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\t}\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tp->idx += 9;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x40:\n\t\t\t\t \n\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\n\t\t\t\tif ((src_offset + count) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, byte src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + count, radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + count) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, byte dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + count, radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xffffffff);\n\t\t\t\tib[idx+2] += (u32)(src_reloc->gpu_offset & 0xffffffff);\n\t\t\t\tib[idx+3] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\tib[idx+4] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += 5;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x41:\n\t\t\t\t \n\t\t\t\tif (p->family < CHIP_CAYMAN) {\n\t\t\t\t\tDRM_ERROR(\"L2L Partial is cayman only !\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(src_reloc->gpu_offset & 0xffffffff);\n\t\t\t\tib[idx+2] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tib[idx+4] += (u32)(dst_reloc->gpu_offset & 0xffffffff);\n\t\t\t\tib[idx+5] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\n\t\t\t\tp->idx += 9;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x44:\n\t\t\t\t \n\t\t\t\tr = r600_dma_cs_next_reloc(p, &dst2_reloc);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad L2L, dw, broadcast DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\t\tdst2_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\tdst2_offset |= ((u64)(radeon_get_ib_value(p, idx+5) & 0xff)) << 32;\n\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+3);\n\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+6) & 0xff)) << 32;\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, dw, broadcast src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, dw, broadcast dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2L, dw, broadcast dst2 buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+2] += (u32)(dst2_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+3] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+4] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\tib[idx+5] += upper_32_bits(dst2_reloc->gpu_offset) & 0xff;\n\t\t\t\tib[idx+6] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += 7;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x48:\n\t\t\t\tif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\n\t\t\t\t\tDRM_ERROR(\"bad L2T, frame to fields DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tr = r600_dma_cs_next_reloc(p, &dst2_reloc);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad L2T, frame to fields DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset <<= 8;\n\t\t\t\tdst2_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\tdst2_offset <<= 8;\n\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+8);\n\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+9) & 0xff)) << 32;\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, frame to fields src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, frame to fields buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, frame to fields buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+2] += (u32)(dst2_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+8] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+9] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += 10;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x49:\n\t\t\t\t \n\t\t\t\tif (p->family < CHIP_CAYMAN) {\n\t\t\t\t\tDRM_ERROR(\"L2T, T2L Partial is cayman only !\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\n\t\t\t\t\t \n\t\t\t\t\tib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\n\n\t\t\t\t\tib[idx+7] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+8] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tib[idx+7] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+8] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\n\t\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\t}\n\t\t\t\tp->idx += 12;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4b:\n\t\t\t\t \n\t\t\t\tif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\n\t\t\t\t\tDRM_ERROR(\"bad L2T, broadcast DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tr = r600_dma_cs_next_reloc(p, &dst2_reloc);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad L2T, broadcast DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset <<= 8;\n\t\t\t\tdst2_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\tdst2_offset <<= 8;\n\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+8);\n\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+9) & 0xff)) << 32;\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, broadcast src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, broadcast dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, broadcast dst2 buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+2] += (u32)(dst2_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+8] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+9] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += 10;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4c:\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\n\t\t\t\t\t \n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tsrc_offset <<= 8;\n\t\t\t\t\tib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\n\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+7);\n\t\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\n\t\t\t\t\tib[idx+7] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+8] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+7);\n\t\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\n\t\t\t\t\tib[idx+7] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+8] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tdst_offset <<= 8;\n\t\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\t}\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, T2L src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, T2L dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tp->idx += 9;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4d:\n\t\t\t\t \n\t\t\t\tif (p->family < CHIP_CAYMAN) {\n\t\t\t\t\tDRM_ERROR(\"L2T, T2L Partial is cayman only !\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+4] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\tp->idx += 13;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4f:\n\t\t\t\t \n\t\t\t\tif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\n\t\t\t\t\tDRM_ERROR(\"bad L2T, broadcast DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tr = r600_dma_cs_next_reloc(p, &dst2_reloc);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad L2T, broadcast DMA_PACKET_COPY\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset <<= 8;\n\t\t\t\tdst2_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\tdst2_offset <<= 8;\n\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+8);\n\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+9) & 0xff)) << 32;\n\t\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, broadcast src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, broadcast dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\n\t\t\t\t\tdev_warn(p->dev, \"DMA L2T, broadcast dst2 buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t\t\tdst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+2] += (u32)(dst2_reloc->gpu_offset >> 8);\n\t\t\t\tib[idx+8] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+9] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += 10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_COPY [%6d] 0x%08x invalid sub cmd\\n\", idx, header);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMA_PACKET_CONSTANT_FILL:\n\t\t\tr = r600_dma_cs_next_reloc(p, &dst_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_CONSTANT_FILL\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0x00ff0000)) << 16;\n\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"DMA constant fill buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t dst_offset, radeon_bo_size(dst_reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\tib[idx+3] += (upper_32_bits(dst_reloc->gpu_offset) << 16) & 0x00ff0000;\n\t\t\tp->idx += 4;\n\t\t\tbreak;\n\t\tcase DMA_PACKET_NOP:\n\t\t\tp->idx += 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d at %d !\\n\", cmd, idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (p->idx < p->chunk_ib->length_dw);\n#if 0\n\tfor (r = 0; r < p->ib->length_dw; r++) {\n\t\tpr_info(\"%05d  0x%08X\\n\", r, p->ib.ptr[r]);\n\t\tmdelay(1);\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic bool evergreen_vm_reg_valid(u32 reg)\n{\n\t \n\tif (reg >= 0x28000)\n\t\treturn true;\n\n\t \n\tswitch (reg) {\n\tcase WAIT_UNTIL:\n\tcase GRBM_GFX_INDEX:\n\tcase CP_STRMOUT_CNTL:\n\tcase CP_COHER_CNTL:\n\tcase CP_COHER_SIZE:\n\tcase VGT_VTX_VECT_EJECT_REG:\n\tcase VGT_CACHE_INVALIDATION:\n\tcase VGT_GS_VERTEX_REUSE:\n\tcase VGT_PRIMITIVE_TYPE:\n\tcase VGT_INDEX_TYPE:\n\tcase VGT_NUM_INDICES:\n\tcase VGT_NUM_INSTANCES:\n\tcase VGT_COMPUTE_DIM_X:\n\tcase VGT_COMPUTE_DIM_Y:\n\tcase VGT_COMPUTE_DIM_Z:\n\tcase VGT_COMPUTE_START_X:\n\tcase VGT_COMPUTE_START_Y:\n\tcase VGT_COMPUTE_START_Z:\n\tcase VGT_COMPUTE_INDEX:\n\tcase VGT_COMPUTE_THREAD_GROUP_SIZE:\n\tcase VGT_HS_OFFCHIP_PARAM:\n\tcase PA_CL_ENHANCE:\n\tcase PA_SU_LINE_STIPPLE_VALUE:\n\tcase PA_SC_LINE_STIPPLE_STATE:\n\tcase PA_SC_ENHANCE:\n\tcase SQ_DYN_GPR_CNTL_PS_FLUSH_REQ:\n\tcase SQ_DYN_GPR_SIMD_LOCK_EN:\n\tcase SQ_CONFIG:\n\tcase SQ_GPR_RESOURCE_MGMT_1:\n\tcase SQ_GLOBAL_GPR_RESOURCE_MGMT_1:\n\tcase SQ_GLOBAL_GPR_RESOURCE_MGMT_2:\n\tcase SQ_CONST_MEM_BASE:\n\tcase SQ_STATIC_THREAD_MGMT_1:\n\tcase SQ_STATIC_THREAD_MGMT_2:\n\tcase SQ_STATIC_THREAD_MGMT_3:\n\tcase SPI_CONFIG_CNTL:\n\tcase SPI_CONFIG_CNTL_1:\n\tcase TA_CNTL_AUX:\n\tcase DB_DEBUG:\n\tcase DB_DEBUG2:\n\tcase DB_DEBUG3:\n\tcase DB_DEBUG4:\n\tcase DB_WATERMARKS:\n\tcase TD_PS_BORDER_COLOR_INDEX:\n\tcase TD_PS_BORDER_COLOR_RED:\n\tcase TD_PS_BORDER_COLOR_GREEN:\n\tcase TD_PS_BORDER_COLOR_BLUE:\n\tcase TD_PS_BORDER_COLOR_ALPHA:\n\tcase TD_VS_BORDER_COLOR_INDEX:\n\tcase TD_VS_BORDER_COLOR_RED:\n\tcase TD_VS_BORDER_COLOR_GREEN:\n\tcase TD_VS_BORDER_COLOR_BLUE:\n\tcase TD_VS_BORDER_COLOR_ALPHA:\n\tcase TD_GS_BORDER_COLOR_INDEX:\n\tcase TD_GS_BORDER_COLOR_RED:\n\tcase TD_GS_BORDER_COLOR_GREEN:\n\tcase TD_GS_BORDER_COLOR_BLUE:\n\tcase TD_GS_BORDER_COLOR_ALPHA:\n\tcase TD_HS_BORDER_COLOR_INDEX:\n\tcase TD_HS_BORDER_COLOR_RED:\n\tcase TD_HS_BORDER_COLOR_GREEN:\n\tcase TD_HS_BORDER_COLOR_BLUE:\n\tcase TD_HS_BORDER_COLOR_ALPHA:\n\tcase TD_LS_BORDER_COLOR_INDEX:\n\tcase TD_LS_BORDER_COLOR_RED:\n\tcase TD_LS_BORDER_COLOR_GREEN:\n\tcase TD_LS_BORDER_COLOR_BLUE:\n\tcase TD_LS_BORDER_COLOR_ALPHA:\n\tcase TD_CS_BORDER_COLOR_INDEX:\n\tcase TD_CS_BORDER_COLOR_RED:\n\tcase TD_CS_BORDER_COLOR_GREEN:\n\tcase TD_CS_BORDER_COLOR_BLUE:\n\tcase TD_CS_BORDER_COLOR_ALPHA:\n\tcase SQ_ESGS_RING_SIZE:\n\tcase SQ_GSVS_RING_SIZE:\n\tcase SQ_ESTMP_RING_SIZE:\n\tcase SQ_GSTMP_RING_SIZE:\n\tcase SQ_HSTMP_RING_SIZE:\n\tcase SQ_LSTMP_RING_SIZE:\n\tcase SQ_PSTMP_RING_SIZE:\n\tcase SQ_VSTMP_RING_SIZE:\n\tcase SQ_ESGS_RING_ITEMSIZE:\n\tcase SQ_ESTMP_RING_ITEMSIZE:\n\tcase SQ_GSTMP_RING_ITEMSIZE:\n\tcase SQ_GSVS_RING_ITEMSIZE:\n\tcase SQ_GS_VERT_ITEMSIZE:\n\tcase SQ_GS_VERT_ITEMSIZE_1:\n\tcase SQ_GS_VERT_ITEMSIZE_2:\n\tcase SQ_GS_VERT_ITEMSIZE_3:\n\tcase SQ_GSVS_RING_OFFSET_1:\n\tcase SQ_GSVS_RING_OFFSET_2:\n\tcase SQ_GSVS_RING_OFFSET_3:\n\tcase SQ_HSTMP_RING_ITEMSIZE:\n\tcase SQ_LSTMP_RING_ITEMSIZE:\n\tcase SQ_PSTMP_RING_ITEMSIZE:\n\tcase SQ_VSTMP_RING_ITEMSIZE:\n\tcase VGT_TF_RING_SIZE:\n\tcase SQ_ESGS_RING_BASE:\n\tcase SQ_GSVS_RING_BASE:\n\tcase SQ_ESTMP_RING_BASE:\n\tcase SQ_GSTMP_RING_BASE:\n\tcase SQ_HSTMP_RING_BASE:\n\tcase SQ_LSTMP_RING_BASE:\n\tcase SQ_PSTMP_RING_BASE:\n\tcase SQ_VSTMP_RING_BASE:\n\tcase CAYMAN_VGT_OFFCHIP_LDS_BASE:\n\tcase CAYMAN_SQ_EX_ALLOC_TABLE_SLOTS:\n\t\treturn true;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid register 0x%x in CS\\n\", reg);\n\t\treturn false;\n\t}\n}\n\nstatic int evergreen_vm_packet3_check(struct radeon_device *rdev,\n\t\t\t\t      u32 *ib, struct radeon_cs_packet *pkt)\n{\n\tu32 idx = pkt->idx + 1;\n\tu32 idx_value = ib[idx];\n\tu32 start_reg, end_reg, reg, i;\n\tu32 command, info;\n\n\tswitch (pkt->opcode) {\n\tcase PACKET3_NOP:\n\t\tbreak;\n\tcase PACKET3_SET_BASE:\n\t\tif (idx_value != 1) {\n\t\t\tDRM_ERROR(\"bad SET_BASE\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CLEAR_STATE:\n\tcase PACKET3_INDEX_BUFFER_SIZE:\n\tcase PACKET3_DISPATCH_DIRECT:\n\tcase PACKET3_DISPATCH_INDIRECT:\n\tcase PACKET3_MODE_CONTROL:\n\tcase PACKET3_SET_PREDICATION:\n\tcase PACKET3_COND_EXEC:\n\tcase PACKET3_PRED_EXEC:\n\tcase PACKET3_DRAW_INDIRECT:\n\tcase PACKET3_DRAW_INDEX_INDIRECT:\n\tcase PACKET3_INDEX_BASE:\n\tcase PACKET3_DRAW_INDEX_2:\n\tcase PACKET3_CONTEXT_CONTROL:\n\tcase PACKET3_DRAW_INDEX_OFFSET:\n\tcase PACKET3_INDEX_TYPE:\n\tcase PACKET3_DRAW_INDEX:\n\tcase PACKET3_DRAW_INDEX_AUTO:\n\tcase PACKET3_DRAW_INDEX_IMMD:\n\tcase PACKET3_NUM_INSTANCES:\n\tcase PACKET3_DRAW_INDEX_MULTI_AUTO:\n\tcase PACKET3_STRMOUT_BUFFER_UPDATE:\n\tcase PACKET3_DRAW_INDEX_OFFSET_2:\n\tcase PACKET3_DRAW_INDEX_MULTI_ELEMENT:\n\tcase PACKET3_MPEG_INDEX:\n\tcase PACKET3_WAIT_REG_MEM:\n\tcase PACKET3_MEM_WRITE:\n\tcase PACKET3_PFP_SYNC_ME:\n\tcase PACKET3_SURFACE_SYNC:\n\tcase PACKET3_EVENT_WRITE:\n\tcase PACKET3_EVENT_WRITE_EOP:\n\tcase PACKET3_EVENT_WRITE_EOS:\n\tcase PACKET3_SET_CONTEXT_REG:\n\tcase PACKET3_SET_BOOL_CONST:\n\tcase PACKET3_SET_LOOP_CONST:\n\tcase PACKET3_SET_RESOURCE:\n\tcase PACKET3_SET_SAMPLER:\n\tcase PACKET3_SET_CTL_CONST:\n\tcase PACKET3_SET_RESOURCE_OFFSET:\n\tcase PACKET3_SET_CONTEXT_REG_INDIRECT:\n\tcase PACKET3_SET_RESOURCE_INDIRECT:\n\tcase CAYMAN_PACKET3_DEALLOC_STATE:\n\t\tbreak;\n\tcase PACKET3_COND_WRITE:\n\t\tif (idx_value & 0x100) {\n\t\t\treg = ib[idx + 5] * 4;\n\t\t\tif (!evergreen_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_COPY_DW:\n\t\tif (idx_value & 0x2) {\n\t\t\treg = ib[idx + 3] * 4;\n\t\t\tif (!evergreen_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_CONFIG_REG:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CONFIG_REG_START) ||\n\t\t    (start_reg >= PACKET3_SET_CONFIG_REG_END) ||\n\t\t    (end_reg >= PACKET3_SET_CONFIG_REG_END)) {\n\t\t\tDRM_ERROR(\"bad PACKET3_SET_CONFIG_REG\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < pkt->count; i++) {\n\t\t\treg = start_reg + (4 * i);\n\t\t\tif (!evergreen_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CP_DMA:\n\t\tcommand = ib[idx + 4];\n\t\tinfo = ib[idx + 1];\n\t\tif ((((info & 0x60000000) >> 29) != 0) ||  \n\t\t    (((info & 0x00300000) >> 20) != 0) ||  \n\t\t    ((((info & 0x00300000) >> 20) == 0) &&\n\t\t     (command & PACKET3_CP_DMA_CMD_DAS)) ||  \n\t\t    ((((info & 0x60000000) >> 29) == 0) &&\n\t\t     (command & PACKET3_CP_DMA_CMD_SAS))) {  \n\t\t\t \n\t\t\tif ((command & 0x1fffff) % 4) {\n\t\t\t\tDRM_ERROR(\"CP DMA command requires dw count alignment\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (command & PACKET3_CP_DMA_CMD_SAS) {\n\t\t\t \n\t\t\tif (((info & 0x60000000) >> 29) == 0) {\n\t\t\t\tstart_reg = idx_value << 2;\n\t\t\t\tif (command & PACKET3_CP_DMA_CMD_SAIC) {\n\t\t\t\t\treg = start_reg;\n\t\t\t\t\tif (!evergreen_vm_reg_valid(reg)) {\n\t\t\t\t\t\tDRM_ERROR(\"CP DMA Bad SRC register\\n\");\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < (command & 0x1fffff); i++) {\n\t\t\t\t\t\treg = start_reg + (4 * i);\n\t\t\t\t\t\tif (!evergreen_vm_reg_valid(reg)) {\n\t\t\t\t\t\t\tDRM_ERROR(\"CP DMA Bad SRC register\\n\");\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (command & PACKET3_CP_DMA_CMD_DAS) {\n\t\t\t \n\t\t\tif (((info & 0x00300000) >> 20) == 0) {\n\t\t\t\tstart_reg = ib[idx + 2];\n\t\t\t\tif (command & PACKET3_CP_DMA_CMD_DAIC) {\n\t\t\t\t\treg = start_reg;\n\t\t\t\t\tif (!evergreen_vm_reg_valid(reg)) {\n\t\t\t\t\t\tDRM_ERROR(\"CP DMA Bad DST register\\n\");\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < (command & 0x1fffff); i++) {\n\t\t\t\t\t\treg = start_reg + (4 * i);\n\t\t\t\t\t\tif (!evergreen_vm_reg_valid(reg)) {\n\t\t\t\t\t\t\tDRM_ERROR(\"CP DMA Bad DST register\\n\");\n\t\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_APPEND_CNT: {\n\t\tuint32_t areg;\n\t\tuint32_t allowed_reg_base;\n\n\t\tif (pkt->count != 2) {\n\t\t\tDRM_ERROR(\"bad SET_APPEND_CNT (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tallowed_reg_base = GDS_APPEND_COUNT_0;\n\t\tallowed_reg_base -= PACKET3_SET_CONTEXT_REG_START;\n\t\tallowed_reg_base >>= 2;\n\n\t\tareg = idx_value >> 16;\n\t\tif (areg < allowed_reg_base || areg > (allowed_reg_base + 11)) {\n\t\t\tDRM_ERROR(\"forbidden register for append cnt 0x%08x at %d\\n\",\n\t\t\t\t  areg, idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint evergreen_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tint ret = 0;\n\tu32 idx = 0;\n\tstruct radeon_cs_packet pkt;\n\n\tdo {\n\t\tpkt.idx = idx;\n\t\tpkt.type = RADEON_CP_PACKET_GET_TYPE(ib->ptr[idx]);\n\t\tpkt.count = RADEON_CP_PACKET_GET_COUNT(ib->ptr[idx]);\n\t\tpkt.one_reg_wr = 0;\n\t\tswitch (pkt.type) {\n\t\tcase RADEON_PACKET_TYPE0:\n\t\t\tdev_err(rdev->dev, \"Packet0 not allowed!\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE2:\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE3:\n\t\t\tpkt.opcode = RADEON_CP_PACKET3_GET_OPCODE(ib->ptr[idx]);\n\t\t\tret = evergreen_vm_packet3_check(rdev, ib->ptr, &pkt);\n\t\t\tidx += pkt.count + 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(rdev->dev, \"Unknown packet type %d !\\n\", pkt.type);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t} while (idx < ib->length_dw);\n\n\treturn ret;\n}\n\n \nint evergreen_dma_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tu32 idx = 0;\n\tu32 header, cmd, count, sub_cmd;\n\n\tdo {\n\t\theader = ib->ptr[idx];\n\t\tcmd = GET_DMA_CMD(header);\n\t\tcount = GET_DMA_COUNT(header);\n\t\tsub_cmd = GET_DMA_SUB_CMD(header);\n\n\t\tswitch (cmd) {\n\t\tcase DMA_PACKET_WRITE:\n\t\t\tswitch (sub_cmd) {\n\t\t\t \n\t\t\tcase 8:\n\t\t\t\tidx += count + 7;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0:\n\t\t\t\tidx += count + 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_WRITE [%6d] 0x%08x sub cmd is not 0 or 8\\n\", idx, ib->ptr[idx]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMA_PACKET_COPY:\n\t\t\tswitch (sub_cmd) {\n\t\t\t \n\t\t\tcase 0x00:\n\t\t\t\tidx += 5;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x08:\n\t\t\t\tidx += 9;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x40:\n\t\t\t\tidx += 5;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x41:\n\t\t\t\tidx += 9;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x44:\n\t\t\t\tidx += 7;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x48:\n\t\t\t\tidx += 10;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x49:\n\t\t\t\tidx += 12;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4b:\n\t\t\t\tidx += 10;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4c:\n\t\t\t\tidx += 9;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4d:\n\t\t\t\tidx += 13;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase 0x4f:\n\t\t\t\tidx += 10;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_COPY [%6d] 0x%08x invalid sub cmd\\n\", idx, ib->ptr[idx]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMA_PACKET_CONSTANT_FILL:\n\t\t\tidx += 4;\n\t\t\tbreak;\n\t\tcase DMA_PACKET_NOP:\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d at %d !\\n\", cmd, idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (idx < ib->length_dw);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}