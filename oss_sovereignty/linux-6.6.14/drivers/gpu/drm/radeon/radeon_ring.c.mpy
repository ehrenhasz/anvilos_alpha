{
  "module_name": "radeon_ring.c",
  "hash_id": "9bc961320eb3e3e79e74a27e880a332da750e47b86a8c0804d0daf3e780779a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_ring.c",
  "human_readable_source": " \n\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n\n#include \"radeon.h\"\n\n \nstatic void radeon_debugfs_ring_init(struct radeon_device *rdev, struct radeon_ring *ring);\n\n \nbool radeon_ring_supports_scratch_reg(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_ring *ring)\n{\n\tswitch (ring->idx) {\n\tcase RADEON_RING_TYPE_GFX_INDEX:\n\tcase CAYMAN_RING_TYPE_CP1_INDEX:\n\tcase CAYMAN_RING_TYPE_CP2_INDEX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nvoid radeon_ring_free_size(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t rptr = radeon_ring_get_rptr(rdev, ring);\n\n\t \n\tring->ring_free_dw = rptr + (ring->ring_size / 4);\n\tring->ring_free_dw -= ring->wptr;\n\tring->ring_free_dw &= ring->ptr_mask;\n\tif (!ring->ring_free_dw) {\n\t\t \n\t\tring->ring_free_dw = ring->ring_size / 4;\n\t\t \n\t\tradeon_ring_lockup_update(rdev, ring);\n\t}\n}\n\n \nint radeon_ring_alloc(struct radeon_device *rdev, struct radeon_ring *ring, unsigned ndw)\n{\n\tint r;\n\n\t \n\tif (ndw > (ring->ring_size / 4))\n\t\treturn -ENOMEM;\n\t \n\tradeon_ring_free_size(rdev, ring);\n\tndw = (ndw + ring->align_mask) & ~ring->align_mask;\n\twhile (ndw > (ring->ring_free_dw - 1)) {\n\t\tradeon_ring_free_size(rdev, ring);\n\t\tif (ndw < ring->ring_free_dw) {\n\t\t\tbreak;\n\t\t}\n\t\tr = radeon_fence_wait_next(rdev, ring->idx);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tring->count_dw = ndw;\n\tring->wptr_old = ring->wptr;\n\treturn 0;\n}\n\n \nint radeon_ring_lock(struct radeon_device *rdev, struct radeon_ring *ring, unsigned ndw)\n{\n\tint r;\n\n\tmutex_lock(&rdev->ring_lock);\n\tr = radeon_ring_alloc(rdev, ring, ndw);\n\tif (r) {\n\t\tmutex_unlock(&rdev->ring_lock);\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nvoid radeon_ring_commit(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t\tbool hdp_flush)\n{\n\t \n\tif (hdp_flush && rdev->asic->ring[ring->idx]->hdp_flush)\n\t\trdev->asic->ring[ring->idx]->hdp_flush(rdev, ring);\n\t \n\twhile (ring->wptr & ring->align_mask) {\n\t\tradeon_ring_write(ring, ring->nop);\n\t}\n\tmb();\n\t \n\tif (hdp_flush && rdev->asic->mmio_hdp_flush)\n\t\trdev->asic->mmio_hdp_flush(rdev);\n\tradeon_ring_set_wptr(rdev, ring);\n}\n\n \nvoid radeon_ring_unlock_commit(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t\t       bool hdp_flush)\n{\n\tradeon_ring_commit(rdev, ring, hdp_flush);\n\tmutex_unlock(&rdev->ring_lock);\n}\n\n \nvoid radeon_ring_undo(struct radeon_ring *ring)\n{\n\tring->wptr = ring->wptr_old;\n}\n\n \nvoid radeon_ring_unlock_undo(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tradeon_ring_undo(ring);\n\tmutex_unlock(&rdev->ring_lock);\n}\n\n \nvoid radeon_ring_lockup_update(struct radeon_device *rdev,\n\t\t\t       struct radeon_ring *ring)\n{\n\tatomic_set(&ring->last_rptr, radeon_ring_get_rptr(rdev, ring));\n\tatomic64_set(&ring->last_activity, jiffies_64);\n}\n\n \nbool radeon_ring_test_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t rptr = radeon_ring_get_rptr(rdev, ring);\n\tuint64_t last = atomic64_read(&ring->last_activity);\n\tuint64_t elapsed;\n\n\tif (rptr != atomic_read(&ring->last_rptr)) {\n\t\t \n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\n\telapsed = jiffies_to_msecs(jiffies_64 - last);\n\tif (radeon_lockup_timeout && elapsed >= radeon_lockup_timeout) {\n\t\tdev_err(rdev->dev, \"ring %d stalled for more than %llumsec\\n\",\n\t\t\tring->idx, elapsed);\n\t\treturn true;\n\t}\n\t \n\treturn false;\n}\n\n \nunsigned radeon_ring_backup(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t\t    uint32_t **data)\n{\n\tunsigned size, ptr, i;\n\n\t \n\tmutex_lock(&rdev->ring_lock);\n\t*data = NULL;\n\n\tif (ring->ring_obj == NULL) {\n\t\tmutex_unlock(&rdev->ring_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!radeon_fence_count_emitted(rdev, ring->idx)) {\n\t\tmutex_unlock(&rdev->ring_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ring->rptr_save_reg)\n\t\tptr = RREG32(ring->rptr_save_reg);\n\telse if (rdev->wb.enabled)\n\t\tptr = le32_to_cpu(*ring->next_rptr_cpu_addr);\n\telse {\n\t\t \n\t\tmutex_unlock(&rdev->ring_lock);\n\t\treturn 0;\n\t}\n\n\tsize = ring->wptr + (ring->ring_size / 4);\n\tsize -= ptr;\n\tsize &= ring->ptr_mask;\n\tif (size == 0) {\n\t\tmutex_unlock(&rdev->ring_lock);\n\t\treturn 0;\n\t}\n\n\t \n\t*data = kvmalloc_array(size, sizeof(uint32_t), GFP_KERNEL);\n\tif (!*data) {\n\t\tmutex_unlock(&rdev->ring_lock);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < size; ++i) {\n\t\t(*data)[i] = ring->ring[ptr++];\n\t\tptr &= ring->ptr_mask;\n\t}\n\n\tmutex_unlock(&rdev->ring_lock);\n\treturn size;\n}\n\n \nint radeon_ring_restore(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t\tunsigned size, uint32_t *data)\n{\n\tint i, r;\n\n\tif (!size || !data)\n\t\treturn 0;\n\n\t \n\tr = radeon_ring_lock(rdev, ring, size);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < size; ++i) {\n\t\tradeon_ring_write(ring, data[i]);\n\t}\n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tkvfree(data);\n\treturn 0;\n}\n\n \nint radeon_ring_init(struct radeon_device *rdev, struct radeon_ring *ring, unsigned ring_size,\n\t\t     unsigned rptr_offs, u32 nop)\n{\n\tint r;\n\n\tring->ring_size = ring_size;\n\tring->rptr_offs = rptr_offs;\n\tring->nop = nop;\n\tring->rdev = rdev;\n\t \n\tif (ring->ring_obj == NULL) {\n\t\tr = radeon_bo_create(rdev, ring->ring_size, PAGE_SIZE, true,\n\t\t\t\t     RADEON_GEM_DOMAIN_GTT, 0, NULL,\n\t\t\t\t     NULL, &ring->ring_obj);\n\t\tif (r) {\n\t\t\tdev_err(rdev->dev, \"(%d) ring create failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_reserve(ring->ring_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\treturn r;\n\t\tr = radeon_bo_pin(ring->ring_obj, RADEON_GEM_DOMAIN_GTT,\n\t\t\t\t\t&ring->gpu_addr);\n\t\tif (r) {\n\t\t\tradeon_bo_unreserve(ring->ring_obj);\n\t\t\tdev_err(rdev->dev, \"(%d) ring pin failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_kmap(ring->ring_obj,\n\t\t\t\t       (void **)&ring->ring);\n\t\tradeon_bo_unreserve(ring->ring_obj);\n\t\tif (r) {\n\t\t\tdev_err(rdev->dev, \"(%d) ring map failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\tring->ptr_mask = (ring->ring_size / 4) - 1;\n\tring->ring_free_dw = ring->ring_size / 4;\n\tif (rdev->wb.enabled) {\n\t\tu32 index = RADEON_WB_RING0_NEXT_RPTR + (ring->idx * 4);\n\t\tring->next_rptr_gpu_addr = rdev->wb.gpu_addr + index;\n\t\tring->next_rptr_cpu_addr = &rdev->wb.wb[index/4];\n\t}\n\tradeon_debugfs_ring_init(rdev, ring);\n\tradeon_ring_lockup_update(rdev, ring);\n\treturn 0;\n}\n\n \nvoid radeon_ring_fini(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tint r;\n\tstruct radeon_bo *ring_obj;\n\n\tmutex_lock(&rdev->ring_lock);\n\tring_obj = ring->ring_obj;\n\tring->ready = false;\n\tring->ring = NULL;\n\tring->ring_obj = NULL;\n\tmutex_unlock(&rdev->ring_lock);\n\n\tif (ring_obj) {\n\t\tr = radeon_bo_reserve(ring_obj, false);\n\t\tif (likely(r == 0)) {\n\t\t\tradeon_bo_kunmap(ring_obj);\n\t\t\tradeon_bo_unpin(ring_obj);\n\t\t\tradeon_bo_unreserve(ring_obj);\n\t\t}\n\t\tradeon_bo_unref(&ring_obj);\n\t}\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\n\nstatic int radeon_debugfs_ring_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_ring *ring = m->private;\n\tstruct radeon_device *rdev = ring->rdev;\n\n\tuint32_t rptr, wptr, rptr_next;\n\tunsigned count, i, j;\n\n\tradeon_ring_free_size(rdev, ring);\n\tcount = (ring->ring_size / 4) - ring->ring_free_dw;\n\n\twptr = radeon_ring_get_wptr(rdev, ring);\n\tseq_printf(m, \"wptr: 0x%08x [%5d]\\n\",\n\t\t   wptr, wptr);\n\n\trptr = radeon_ring_get_rptr(rdev, ring);\n\tseq_printf(m, \"rptr: 0x%08x [%5d]\\n\",\n\t\t   rptr, rptr);\n\n\tif (ring->rptr_save_reg) {\n\t\trptr_next = RREG32(ring->rptr_save_reg);\n\t\tseq_printf(m, \"rptr next(0x%04x): 0x%08x [%5d]\\n\",\n\t\t\t   ring->rptr_save_reg, rptr_next, rptr_next);\n\t} else\n\t\trptr_next = ~0;\n\n\tseq_printf(m, \"driver's copy of the wptr: 0x%08x [%5d]\\n\",\n\t\t   ring->wptr, ring->wptr);\n\tseq_printf(m, \"last semaphore signal addr : 0x%016llx\\n\",\n\t\t   ring->last_semaphore_signal_addr);\n\tseq_printf(m, \"last semaphore wait addr   : 0x%016llx\\n\",\n\t\t   ring->last_semaphore_wait_addr);\n\tseq_printf(m, \"%u free dwords in ring\\n\", ring->ring_free_dw);\n\tseq_printf(m, \"%u dwords in ring\\n\", count);\n\n\tif (!ring->ring)\n\t\treturn 0;\n\n\t \n\ti = (rptr + ring->ptr_mask + 1 - 32) & ring->ptr_mask;\n\tfor (j = 0; j <= (count + 32); j++) {\n\t\tseq_printf(m, \"r[%5d]=0x%08x\", i, ring->ring[i]);\n\t\tif (rptr == i)\n\t\t\tseq_puts(m, \" *\");\n\t\tif (rptr_next == i)\n\t\t\tseq_puts(m, \" #\");\n\t\tseq_puts(m, \"\\n\");\n\t\ti = (i + 1) & ring->ptr_mask;\n\t}\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(radeon_debugfs_ring_info);\n\nstatic const char *radeon_debugfs_ring_idx_to_name(uint32_t ridx)\n{\n\tswitch (ridx) {\n\tcase RADEON_RING_TYPE_GFX_INDEX:\n\t\treturn \"radeon_ring_gfx\";\n\tcase CAYMAN_RING_TYPE_CP1_INDEX:\n\t\treturn \"radeon_ring_cp1\";\n\tcase CAYMAN_RING_TYPE_CP2_INDEX:\n\t\treturn \"radeon_ring_cp2\";\n\tcase R600_RING_TYPE_DMA_INDEX:\n\t\treturn \"radeon_ring_dma1\";\n\tcase CAYMAN_RING_TYPE_DMA1_INDEX:\n\t\treturn \"radeon_ring_dma2\";\n\tcase R600_RING_TYPE_UVD_INDEX:\n\t\treturn \"radeon_ring_uvd\";\n\tcase TN_RING_TYPE_VCE1_INDEX:\n\t\treturn \"radeon_ring_vce1\";\n\tcase TN_RING_TYPE_VCE2_INDEX:\n\t\treturn \"radeon_ring_vce2\";\n\tdefault:\n\t\treturn NULL;\n\n\t}\n}\n#endif\n\nstatic void radeon_debugfs_ring_init(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tconst char *ring_name = radeon_debugfs_ring_idx_to_name(ring->idx);\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tif (ring_name)\n\t\tdebugfs_create_file(ring_name, 0444, root, ring,\n\t\t\t\t    &radeon_debugfs_ring_info_fops);\n\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}