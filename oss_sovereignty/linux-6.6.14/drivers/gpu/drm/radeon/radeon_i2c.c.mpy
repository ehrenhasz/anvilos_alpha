{
  "module_name": "radeon_i2c.c",
  "hash_id": "b6fb4719cb4391d155574634c7cacbc308ccb9ba89ac787203ad31056e01e67e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_i2c.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/pci.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_edid.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon.h\"\n#include \"atom.h\"\n\nbool radeon_ddc_probe(struct radeon_connector *radeon_connector, bool use_aux)\n{\n\tu8 out = 0x0;\n\tu8 buf[8];\n\tint ret;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = DDC_ADDR,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &out,\n\t\t},\n\t\t{\n\t\t\t.addr = DDC_ADDR,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 8,\n\t\t\t.buf = buf,\n\t\t}\n\t};\n\n\t \n\tif (radeon_connector->router.ddc_valid)\n\t\tradeon_router_select_ddc_port(radeon_connector);\n\n\tif (use_aux) {\n\t\tret = i2c_transfer(&radeon_connector->ddc_bus->aux.ddc, msgs, 2);\n\t} else {\n\t\tret = i2c_transfer(&radeon_connector->ddc_bus->adapter, msgs, 2);\n\t}\n\n\tif (ret != 2)\n\t\t \n\t\treturn false;\n\t \n\tif (drm_edid_header_is_valid(buf) < 6) {\n\t\t \n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \n\nstatic int pre_xfer(struct i2c_adapter *i2c_adap)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t temp;\n\n\tmutex_lock(&i2c->mutex);\n\n\t \n\tif (rec->hw_capable) {\n\t\tif ((rdev->family >= CHIP_R200) && !ASIC_IS_AVIVO(rdev)) {\n\t\t\tu32 reg;\n\n\t\t\tif (rdev->family >= CHIP_RV350)\n\t\t\t\treg = RADEON_GPIO_MONID;\n\t\t\telse if ((rdev->family == CHIP_R300) ||\n\t\t\t\t (rdev->family == CHIP_R350))\n\t\t\t\treg = RADEON_GPIO_DVI_DDC;\n\t\t\telse\n\t\t\t\treg = RADEON_GPIO_CRT2_DDC;\n\n\t\t\tmutex_lock(&rdev->dc_hw_i2c_mutex);\n\t\t\tif (rec->a_clk_reg == reg) {\n\t\t\t\tWREG32(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |\n\t\t\t\t\t\t\t       R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1)));\n\t\t\t} else {\n\t\t\t\tWREG32(RADEON_DVI_I2C_CNTL_0, (RADEON_I2C_SOFT_RST |\n\t\t\t\t\t\t\t       R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3)));\n\t\t\t}\n\t\t\tmutex_unlock(&rdev->dc_hw_i2c_mutex);\n\t\t}\n\t}\n\n\t \n\tif (ASIC_IS_DCE3(rdev) && rec->hw_capable) {\n\t\ttemp = RREG32(rec->mask_clk_reg);\n\t\ttemp &= ~(1 << 16);\n\t\tWREG32(rec->mask_clk_reg, temp);\n\t}\n\n\t \n\ttemp = RREG32(rec->a_clk_reg) & ~rec->a_clk_mask;\n\tWREG32(rec->a_clk_reg, temp);\n\n\ttemp = RREG32(rec->a_data_reg) & ~rec->a_data_mask;\n\tWREG32(rec->a_data_reg, temp);\n\n\t \n\ttemp = RREG32(rec->en_clk_reg) & ~rec->en_clk_mask;\n\tWREG32(rec->en_clk_reg, temp);\n\n\ttemp = RREG32(rec->en_data_reg) & ~rec->en_data_mask;\n\tWREG32(rec->en_data_reg, temp);\n\n\t \n\ttemp = RREG32(rec->mask_clk_reg) | rec->mask_clk_mask;\n\tWREG32(rec->mask_clk_reg, temp);\n\ttemp = RREG32(rec->mask_clk_reg);\n\n\ttemp = RREG32(rec->mask_data_reg) | rec->mask_data_mask;\n\tWREG32(rec->mask_data_reg, temp);\n\ttemp = RREG32(rec->mask_data_reg);\n\n\treturn 0;\n}\n\nstatic void post_xfer(struct i2c_adapter *i2c_adap)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t temp;\n\n\t \n\ttemp = RREG32(rec->mask_clk_reg) & ~rec->mask_clk_mask;\n\tWREG32(rec->mask_clk_reg, temp);\n\ttemp = RREG32(rec->mask_clk_reg);\n\n\ttemp = RREG32(rec->mask_data_reg) & ~rec->mask_data_mask;\n\tWREG32(rec->mask_data_reg, temp);\n\ttemp = RREG32(rec->mask_data_reg);\n\n\tmutex_unlock(&i2c->mutex);\n}\n\nstatic int get_clock(void *i2c_priv)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_priv;\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->y_clk_reg);\n\tval &= rec->y_clk_mask;\n\n\treturn (val != 0);\n}\n\n\nstatic int get_data(void *i2c_priv)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_priv;\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->y_data_reg);\n\tval &= rec->y_data_mask;\n\n\treturn (val != 0);\n}\n\nstatic void set_clock(void *i2c_priv, int clock)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_priv;\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->en_clk_reg) & ~rec->en_clk_mask;\n\tval |= clock ? 0 : rec->en_clk_mask;\n\tWREG32(rec->en_clk_reg, val);\n}\n\nstatic void set_data(void *i2c_priv, int data)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_priv;\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tuint32_t val;\n\n\t \n\tval = RREG32(rec->en_data_reg) & ~rec->en_data_mask;\n\tval |= data ? 0 : rec->en_data_mask;\n\tWREG32(rec->en_data_reg, val);\n}\n\n \n\nstatic u32 radeon_get_i2c_prescale(struct radeon_device *rdev)\n{\n\tu32 sclk = rdev->pm.current_sclk;\n\tu32 prescale = 0;\n\tu32 nm;\n\tu8 n, m, loop;\n\tint i2c_clock;\n\n\tswitch (rdev->family) {\n\tcase CHIP_R100:\n\tcase CHIP_RV100:\n\tcase CHIP_RS100:\n\tcase CHIP_RV200:\n\tcase CHIP_RS200:\n\tcase CHIP_R200:\n\tcase CHIP_RV250:\n\tcase CHIP_RS300:\n\tcase CHIP_RV280:\n\tcase CHIP_R300:\n\tcase CHIP_R350:\n\tcase CHIP_RV350:\n\t\ti2c_clock = 60;\n\t\tnm = (sclk * 10) / (i2c_clock * 4);\n\t\tfor (loop = 1; loop < 255; loop++) {\n\t\t\tif ((nm / loop) < loop)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = loop - 1;\n\t\tm = loop - 2;\n\t\tprescale = m | (n << 8);\n\t\tbreak;\n\tcase CHIP_RV380:\n\tcase CHIP_RS400:\n\tcase CHIP_RS480:\n\tcase CHIP_R420:\n\tcase CHIP_R423:\n\tcase CHIP_RV410:\n\t\tprescale = (((sclk * 10)/(4 * 128 * 100) + 1) << 8) + 128;\n\t\tbreak;\n\tcase CHIP_RS600:\n\tcase CHIP_RS690:\n\tcase CHIP_RS740:\n\t\t \n\t\tbreak;\n\tcase CHIP_RV515:\n\tcase CHIP_R520:\n\tcase CHIP_RV530:\n\tcase CHIP_RV560:\n\tcase CHIP_RV570:\n\tcase CHIP_R580:\n\t\ti2c_clock = 50;\n\t\tif (rdev->family == CHIP_R520)\n\t\t\tprescale = (127 << 8) + ((sclk * 10) / (4 * 127 * i2c_clock));\n\t\telse\n\t\t\tprescale = (((sclk * 10)/(4 * 128 * 100) + 1) << 8) + 128;\n\t\tbreak;\n\tcase CHIP_R600:\n\tcase CHIP_RV610:\n\tcase CHIP_RV630:\n\tcase CHIP_RV670:\n\t\t \n\t\tbreak;\n\tcase CHIP_RV620:\n\tcase CHIP_RV635:\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\tcase CHIP_RV770:\n\tcase CHIP_RV730:\n\tcase CHIP_RV710:\n\tcase CHIP_RV740:\n\t\t \n\t\tbreak;\n\tcase CHIP_CEDAR:\n\tcase CHIP_REDWOOD:\n\tcase CHIP_JUNIPER:\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"i2c: unhandled radeon chip\\n\");\n\t\tbreak;\n\t}\n\treturn prescale;\n}\n\n\n \nstatic int r100_hw_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tstruct i2c_msg *p;\n\tint i, j, k, ret = num;\n\tu32 prescale;\n\tu32 i2c_cntl_0, i2c_cntl_1, i2c_data;\n\tu32 tmp, reg;\n\n\tmutex_lock(&rdev->dc_hw_i2c_mutex);\n\t \n\tmutex_lock(&rdev->pm.mutex);\n\n\tprescale = radeon_get_i2c_prescale(rdev);\n\n\treg = ((prescale << RADEON_I2C_PRESCALE_SHIFT) |\n\t       RADEON_I2C_DRIVE_EN |\n\t       RADEON_I2C_START |\n\t       RADEON_I2C_STOP |\n\t       RADEON_I2C_GO);\n\n\tif (rdev->is_atom_bios) {\n\t\ttmp = RREG32(RADEON_BIOS_6_SCRATCH);\n\t\tWREG32(RADEON_BIOS_6_SCRATCH, tmp | ATOM_S6_HW_I2C_BUSY_STATE);\n\t}\n\n\tif (rec->mm_i2c) {\n\t\ti2c_cntl_0 = RADEON_I2C_CNTL_0;\n\t\ti2c_cntl_1 = RADEON_I2C_CNTL_1;\n\t\ti2c_data = RADEON_I2C_DATA;\n\t} else {\n\t\ti2c_cntl_0 = RADEON_DVI_I2C_CNTL_0;\n\t\ti2c_cntl_1 = RADEON_DVI_I2C_CNTL_1;\n\t\ti2c_data = RADEON_DVI_I2C_DATA;\n\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_R100:\n\t\tcase CHIP_RV100:\n\t\tcase CHIP_RS100:\n\t\tcase CHIP_RV200:\n\t\tcase CHIP_RS200:\n\t\tcase CHIP_RS300:\n\t\t\tswitch (rec->mask_clk_reg) {\n\t\t\tcase RADEON_GPIO_DVI_DDC:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"gpio not supported with hw i2c\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHIP_R200:\n\t\t\t \n\t\t\tswitch (rec->mask_clk_reg) {\n\t\t\tcase RADEON_GPIO_DVI_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_GPIO_MONID:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"gpio not supported with hw i2c\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHIP_RV250:\n\t\tcase CHIP_RV280:\n\t\t\t \n\t\t\tswitch (rec->mask_clk_reg) {\n\t\t\tcase RADEON_GPIO_DVI_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_GPIO_VGA_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC2);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_GPIO_CRT2_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"gpio not supported with hw i2c\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHIP_R300:\n\t\tcase CHIP_R350:\n\t\t\t \n\t\t\tswitch (rec->mask_clk_reg) {\n\t\t\tcase RADEON_GPIO_VGA_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_GPIO_DVI_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"gpio not supported with hw i2c\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CHIP_RV350:\n\t\tcase CHIP_RV380:\n\t\tcase CHIP_R420:\n\t\tcase CHIP_R423:\n\t\tcase CHIP_RV410:\n\t\tcase CHIP_RS400:\n\t\tcase CHIP_RS480:\n\t\t\t \n\t\t\tswitch (rec->mask_clk_reg) {\n\t\t\tcase RADEON_GPIO_VGA_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC1);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_GPIO_DVI_DDC:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC2);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_GPIO_MONID:\n\t\t\t\treg |= R200_DVI_I2C_PIN_SEL(R200_SEL_DDC3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"gpio not supported with hw i2c\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unsupported asic\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tp = &msgs[0];\n\tif ((num == 1) && (p->len == 0)) {\n\t\tWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\n\t\t\t\t    RADEON_I2C_NACK |\n\t\t\t\t    RADEON_I2C_HALT |\n\t\t\t\t    RADEON_I2C_SOFT_RST));\n\t\tWREG32(i2c_data, (p->addr << 1) & 0xff);\n\t\tWREG32(i2c_data, 0);\n\t\tWREG32(i2c_cntl_1, ((1 << RADEON_I2C_DATA_COUNT_SHIFT) |\n\t\t\t\t    (1 << RADEON_I2C_ADDR_COUNT_SHIFT) |\n\t\t\t\t    RADEON_I2C_EN |\n\t\t\t\t    (48 << RADEON_I2C_TIME_LIMIT_SHIFT)));\n\t\tWREG32(i2c_cntl_0, reg);\n\t\tfor (k = 0; k < 32; k++) {\n\t\t\tudelay(10);\n\t\t\ttmp = RREG32(i2c_cntl_0);\n\t\t\tif (tmp & RADEON_I2C_GO)\n\t\t\t\tcontinue;\n\t\t\ttmp = RREG32(i2c_cntl_0);\n\t\t\tif (tmp & RADEON_I2C_DONE)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tDRM_DEBUG(\"i2c write error 0x%08x\\n\", tmp);\n\t\t\t\tWREG32(i2c_cntl_0, tmp | RADEON_I2C_ABORT);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tp = &msgs[i];\n\t\tfor (j = 0; j < p->len; j++) {\n\t\t\tif (p->flags & I2C_M_RD) {\n\t\t\t\tWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\n\t\t\t\t\t\t    RADEON_I2C_NACK |\n\t\t\t\t\t\t    RADEON_I2C_HALT |\n\t\t\t\t\t\t    RADEON_I2C_SOFT_RST));\n\t\t\t\tWREG32(i2c_data, ((p->addr << 1) & 0xff) | 0x1);\n\t\t\t\tWREG32(i2c_cntl_1, ((1 << RADEON_I2C_DATA_COUNT_SHIFT) |\n\t\t\t\t\t\t    (1 << RADEON_I2C_ADDR_COUNT_SHIFT) |\n\t\t\t\t\t\t    RADEON_I2C_EN |\n\t\t\t\t\t\t    (48 << RADEON_I2C_TIME_LIMIT_SHIFT)));\n\t\t\t\tWREG32(i2c_cntl_0, reg | RADEON_I2C_RECEIVE);\n\t\t\t\tfor (k = 0; k < 32; k++) {\n\t\t\t\t\tudelay(10);\n\t\t\t\t\ttmp = RREG32(i2c_cntl_0);\n\t\t\t\t\tif (tmp & RADEON_I2C_GO)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttmp = RREG32(i2c_cntl_0);\n\t\t\t\t\tif (tmp & RADEON_I2C_DONE)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tDRM_DEBUG(\"i2c read error 0x%08x\\n\", tmp);\n\t\t\t\t\t\tWREG32(i2c_cntl_0, tmp | RADEON_I2C_ABORT);\n\t\t\t\t\t\tret = -EIO;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp->buf[j] = RREG32(i2c_data) & 0xff;\n\t\t\t} else {\n\t\t\t\tWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\n\t\t\t\t\t\t    RADEON_I2C_NACK |\n\t\t\t\t\t\t    RADEON_I2C_HALT |\n\t\t\t\t\t\t    RADEON_I2C_SOFT_RST));\n\t\t\t\tWREG32(i2c_data, (p->addr << 1) & 0xff);\n\t\t\t\tWREG32(i2c_data, p->buf[j]);\n\t\t\t\tWREG32(i2c_cntl_1, ((1 << RADEON_I2C_DATA_COUNT_SHIFT) |\n\t\t\t\t\t\t    (1 << RADEON_I2C_ADDR_COUNT_SHIFT) |\n\t\t\t\t\t\t    RADEON_I2C_EN |\n\t\t\t\t\t\t    (48 << RADEON_I2C_TIME_LIMIT_SHIFT)));\n\t\t\t\tWREG32(i2c_cntl_0, reg);\n\t\t\t\tfor (k = 0; k < 32; k++) {\n\t\t\t\t\tudelay(10);\n\t\t\t\t\ttmp = RREG32(i2c_cntl_0);\n\t\t\t\t\tif (tmp & RADEON_I2C_GO)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttmp = RREG32(i2c_cntl_0);\n\t\t\t\t\tif (tmp & RADEON_I2C_DONE)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tDRM_DEBUG(\"i2c write error 0x%08x\\n\", tmp);\n\t\t\t\t\t\tWREG32(i2c_cntl_0, tmp | RADEON_I2C_ABORT);\n\t\t\t\t\t\tret = -EIO;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tWREG32(i2c_cntl_0, 0);\n\tWREG32(i2c_cntl_1, 0);\n\tWREG32(i2c_cntl_0, (RADEON_I2C_DONE |\n\t\t\t    RADEON_I2C_NACK |\n\t\t\t    RADEON_I2C_HALT |\n\t\t\t    RADEON_I2C_SOFT_RST));\n\n\tif (rdev->is_atom_bios) {\n\t\ttmp = RREG32(RADEON_BIOS_6_SCRATCH);\n\t\ttmp &= ~ATOM_S6_HW_I2C_BUSY_STATE;\n\t\tWREG32(RADEON_BIOS_6_SCRATCH, tmp);\n\t}\n\n\tmutex_unlock(&rdev->pm.mutex);\n\tmutex_unlock(&rdev->dc_hw_i2c_mutex);\n\n\treturn ret;\n}\n\n \nstatic int r500_hw_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t    struct i2c_msg *msgs, int num)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tstruct i2c_msg *p;\n\tint i, j, remaining, current_count, buffer_offset, ret = num;\n\tu32 prescale;\n\tu32 tmp, reg;\n\tu32 saved1, saved2;\n\n\tmutex_lock(&rdev->dc_hw_i2c_mutex);\n\t \n\tmutex_lock(&rdev->pm.mutex);\n\n\tprescale = radeon_get_i2c_prescale(rdev);\n\n\t \n\ttmp = RREG32(rec->mask_clk_reg);\n\ttmp &= ~rec->mask_clk_mask;\n\tWREG32(rec->mask_clk_reg, tmp);\n\ttmp = RREG32(rec->mask_clk_reg);\n\n\ttmp = RREG32(rec->mask_data_reg);\n\ttmp &= ~rec->mask_data_mask;\n\tWREG32(rec->mask_data_reg, tmp);\n\ttmp = RREG32(rec->mask_data_reg);\n\n\t \n\ttmp = RREG32(rec->a_clk_reg);\n\ttmp &= ~rec->a_clk_mask;\n\tWREG32(rec->a_clk_reg, tmp);\n\ttmp = RREG32(rec->a_clk_reg);\n\n\ttmp = RREG32(rec->a_data_reg);\n\ttmp &= ~rec->a_data_mask;\n\tWREG32(rec->a_data_reg, tmp);\n\ttmp = RREG32(rec->a_data_reg);\n\n\t \n\ttmp = RREG32(rec->en_clk_reg);\n\ttmp &= ~rec->en_clk_mask;\n\tWREG32(rec->en_clk_reg, tmp);\n\ttmp = RREG32(rec->en_clk_reg);\n\n\ttmp = RREG32(rec->en_data_reg);\n\ttmp &= ~rec->en_data_mask;\n\tWREG32(rec->en_data_reg, tmp);\n\ttmp = RREG32(rec->en_data_reg);\n\n\t \n\ttmp = RREG32(RADEON_BIOS_6_SCRATCH);\n\tWREG32(RADEON_BIOS_6_SCRATCH, tmp | ATOM_S6_HW_I2C_BUSY_STATE);\n\tsaved1 = RREG32(AVIVO_DC_I2C_CONTROL1);\n\tsaved2 = RREG32(0x494);\n\tWREG32(0x494, saved2 | 0x1);\n\n\tWREG32(AVIVO_DC_I2C_ARBITRATION, AVIVO_DC_I2C_SW_WANTS_TO_USE_I2C);\n\tfor (i = 0; i < 50; i++) {\n\t\tudelay(1);\n\t\tif (RREG32(AVIVO_DC_I2C_ARBITRATION) & AVIVO_DC_I2C_SW_CAN_USE_I2C)\n\t\t\tbreak;\n\t}\n\tif (i == 50) {\n\t\tDRM_ERROR(\"failed to get i2c bus\\n\");\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\treg = AVIVO_DC_I2C_START | AVIVO_DC_I2C_STOP | AVIVO_DC_I2C_EN;\n\tswitch (rec->mask_clk_reg) {\n\tcase AVIVO_DC_GPIO_DDC1_MASK:\n\t\treg |= AVIVO_DC_I2C_PIN_SELECT(AVIVO_SEL_DDC1);\n\t\tbreak;\n\tcase AVIVO_DC_GPIO_DDC2_MASK:\n\t\treg |= AVIVO_DC_I2C_PIN_SELECT(AVIVO_SEL_DDC2);\n\t\tbreak;\n\tcase AVIVO_DC_GPIO_DDC3_MASK:\n\t\treg |= AVIVO_DC_I2C_PIN_SELECT(AVIVO_SEL_DDC3);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"gpio not supported with hw i2c\\n\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tp = &msgs[0];\n\tif ((num == 1) && (p->len == 0)) {\n\t\tWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\n\t\t\t\t\t      AVIVO_DC_I2C_NACK |\n\t\t\t\t\t      AVIVO_DC_I2C_HALT));\n\t\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\n\t\tudelay(1);\n\t\tWREG32(AVIVO_DC_I2C_RESET, 0);\n\n\t\tWREG32(AVIVO_DC_I2C_DATA, (p->addr << 1) & 0xff);\n\t\tWREG32(AVIVO_DC_I2C_DATA, 0);\n\n\t\tWREG32(AVIVO_DC_I2C_CONTROL3, AVIVO_DC_I2C_TIME_LIMIT(48));\n\t\tWREG32(AVIVO_DC_I2C_CONTROL2, (AVIVO_DC_I2C_ADDR_COUNT(1) |\n\t\t\t\t\t       AVIVO_DC_I2C_DATA_COUNT(1) |\n\t\t\t\t\t       (prescale << 16)));\n\t\tWREG32(AVIVO_DC_I2C_CONTROL1, reg);\n\t\tWREG32(AVIVO_DC_I2C_STATUS1, AVIVO_DC_I2C_GO);\n\t\tfor (j = 0; j < 200; j++) {\n\t\t\tudelay(50);\n\t\t\ttmp = RREG32(AVIVO_DC_I2C_STATUS1);\n\t\t\tif (tmp & AVIVO_DC_I2C_GO)\n\t\t\t\tcontinue;\n\t\t\ttmp = RREG32(AVIVO_DC_I2C_STATUS1);\n\t\t\tif (tmp & AVIVO_DC_I2C_DONE)\n\t\t\t\tbreak;\n\t\t\telse {\n\t\t\t\tDRM_DEBUG(\"i2c write error 0x%08x\\n\", tmp);\n\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_ABORT);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < num; i++) {\n\t\tp = &msgs[i];\n\t\tremaining = p->len;\n\t\tbuffer_offset = 0;\n\t\tif (p->flags & I2C_M_RD) {\n\t\t\twhile (remaining) {\n\t\t\t\tif (remaining > 15)\n\t\t\t\t\tcurrent_count = 15;\n\t\t\t\telse\n\t\t\t\t\tcurrent_count = remaining;\n\t\t\t\tWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\n\t\t\t\t\t\t\t      AVIVO_DC_I2C_NACK |\n\t\t\t\t\t\t\t      AVIVO_DC_I2C_HALT));\n\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\n\t\t\t\tudelay(1);\n\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, 0);\n\n\t\t\t\tWREG32(AVIVO_DC_I2C_DATA, ((p->addr << 1) & 0xff) | 0x1);\n\t\t\t\tWREG32(AVIVO_DC_I2C_CONTROL3, AVIVO_DC_I2C_TIME_LIMIT(48));\n\t\t\t\tWREG32(AVIVO_DC_I2C_CONTROL2, (AVIVO_DC_I2C_ADDR_COUNT(1) |\n\t\t\t\t\t\t\t       AVIVO_DC_I2C_DATA_COUNT(current_count) |\n\t\t\t\t\t\t\t       (prescale << 16)));\n\t\t\t\tWREG32(AVIVO_DC_I2C_CONTROL1, reg | AVIVO_DC_I2C_RECEIVE);\n\t\t\t\tWREG32(AVIVO_DC_I2C_STATUS1, AVIVO_DC_I2C_GO);\n\t\t\t\tfor (j = 0; j < 200; j++) {\n\t\t\t\t\tudelay(50);\n\t\t\t\t\ttmp = RREG32(AVIVO_DC_I2C_STATUS1);\n\t\t\t\t\tif (tmp & AVIVO_DC_I2C_GO)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttmp = RREG32(AVIVO_DC_I2C_STATUS1);\n\t\t\t\t\tif (tmp & AVIVO_DC_I2C_DONE)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tDRM_DEBUG(\"i2c read error 0x%08x\\n\", tmp);\n\t\t\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_ABORT);\n\t\t\t\t\t\tret = -EIO;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < current_count; j++)\n\t\t\t\t\tp->buf[buffer_offset + j] = RREG32(AVIVO_DC_I2C_DATA) & 0xff;\n\t\t\t\tremaining -= current_count;\n\t\t\t\tbuffer_offset += current_count;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (remaining) {\n\t\t\t\tif (remaining > 15)\n\t\t\t\t\tcurrent_count = 15;\n\t\t\t\telse\n\t\t\t\t\tcurrent_count = remaining;\n\t\t\t\tWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\n\t\t\t\t\t\t\t      AVIVO_DC_I2C_NACK |\n\t\t\t\t\t\t\t      AVIVO_DC_I2C_HALT));\n\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\n\t\t\t\tudelay(1);\n\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, 0);\n\n\t\t\t\tWREG32(AVIVO_DC_I2C_DATA, (p->addr << 1) & 0xff);\n\t\t\t\tfor (j = 0; j < current_count; j++)\n\t\t\t\t\tWREG32(AVIVO_DC_I2C_DATA, p->buf[buffer_offset + j]);\n\n\t\t\t\tWREG32(AVIVO_DC_I2C_CONTROL3, AVIVO_DC_I2C_TIME_LIMIT(48));\n\t\t\t\tWREG32(AVIVO_DC_I2C_CONTROL2, (AVIVO_DC_I2C_ADDR_COUNT(1) |\n\t\t\t\t\t\t\t       AVIVO_DC_I2C_DATA_COUNT(current_count) |\n\t\t\t\t\t\t\t       (prescale << 16)));\n\t\t\t\tWREG32(AVIVO_DC_I2C_CONTROL1, reg);\n\t\t\t\tWREG32(AVIVO_DC_I2C_STATUS1, AVIVO_DC_I2C_GO);\n\t\t\t\tfor (j = 0; j < 200; j++) {\n\t\t\t\t\tudelay(50);\n\t\t\t\t\ttmp = RREG32(AVIVO_DC_I2C_STATUS1);\n\t\t\t\t\tif (tmp & AVIVO_DC_I2C_GO)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttmp = RREG32(AVIVO_DC_I2C_STATUS1);\n\t\t\t\t\tif (tmp & AVIVO_DC_I2C_DONE)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tDRM_DEBUG(\"i2c write error 0x%08x\\n\", tmp);\n\t\t\t\t\t\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_ABORT);\n\t\t\t\t\t\tret = -EIO;\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tremaining -= current_count;\n\t\t\t\tbuffer_offset += current_count;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tWREG32(AVIVO_DC_I2C_STATUS1, (AVIVO_DC_I2C_DONE |\n\t\t\t\t      AVIVO_DC_I2C_NACK |\n\t\t\t\t      AVIVO_DC_I2C_HALT));\n\tWREG32(AVIVO_DC_I2C_RESET, AVIVO_DC_I2C_SOFT_RESET);\n\tudelay(1);\n\tWREG32(AVIVO_DC_I2C_RESET, 0);\n\n\tWREG32(AVIVO_DC_I2C_ARBITRATION, AVIVO_DC_I2C_SW_DONE_USING_I2C);\n\tWREG32(AVIVO_DC_I2C_CONTROL1, saved1);\n\tWREG32(0x494, saved2);\n\ttmp = RREG32(RADEON_BIOS_6_SCRATCH);\n\ttmp &= ~ATOM_S6_HW_I2C_BUSY_STATE;\n\tWREG32(RADEON_BIOS_6_SCRATCH, tmp);\n\n\tmutex_unlock(&rdev->pm.mutex);\n\tmutex_unlock(&rdev->dc_hw_i2c_mutex);\n\n\treturn ret;\n}\n\nstatic int radeon_hw_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t      struct i2c_msg *msgs, int num)\n{\n\tstruct radeon_i2c_chan *i2c = i2c_get_adapdata(i2c_adap);\n\tstruct radeon_device *rdev = i2c->dev->dev_private;\n\tstruct radeon_i2c_bus_rec *rec = &i2c->rec;\n\tint ret = 0;\n\n\tmutex_lock(&i2c->mutex);\n\n\tswitch (rdev->family) {\n\tcase CHIP_R100:\n\tcase CHIP_RV100:\n\tcase CHIP_RS100:\n\tcase CHIP_RV200:\n\tcase CHIP_RS200:\n\tcase CHIP_R200:\n\tcase CHIP_RV250:\n\tcase CHIP_RS300:\n\tcase CHIP_RV280:\n\tcase CHIP_R300:\n\tcase CHIP_R350:\n\tcase CHIP_RV350:\n\tcase CHIP_RV380:\n\tcase CHIP_R420:\n\tcase CHIP_R423:\n\tcase CHIP_RV410:\n\tcase CHIP_RS400:\n\tcase CHIP_RS480:\n\t\tret = r100_hw_i2c_xfer(i2c_adap, msgs, num);\n\t\tbreak;\n\tcase CHIP_RS600:\n\tcase CHIP_RS690:\n\tcase CHIP_RS740:\n\t\t \n\t\tbreak;\n\tcase CHIP_RV515:\n\tcase CHIP_R520:\n\tcase CHIP_RV530:\n\tcase CHIP_RV560:\n\tcase CHIP_RV570:\n\tcase CHIP_R580:\n\t\tif (rec->mm_i2c)\n\t\t\tret = r100_hw_i2c_xfer(i2c_adap, msgs, num);\n\t\telse\n\t\t\tret = r500_hw_i2c_xfer(i2c_adap, msgs, num);\n\t\tbreak;\n\tcase CHIP_R600:\n\tcase CHIP_RV610:\n\tcase CHIP_RV630:\n\tcase CHIP_RV670:\n\t\t \n\t\tbreak;\n\tcase CHIP_RV620:\n\tcase CHIP_RV635:\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\tcase CHIP_RV770:\n\tcase CHIP_RV730:\n\tcase CHIP_RV710:\n\tcase CHIP_RV740:\n\t\t \n\t\tbreak;\n\tcase CHIP_CEDAR:\n\tcase CHIP_REDWOOD:\n\tcase CHIP_JUNIPER:\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"i2c: unhandled radeon chip\\n\");\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&i2c->mutex);\n\n\treturn ret;\n}\n\nstatic u32 radeon_hw_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm radeon_i2c_algo = {\n\t.master_xfer = radeon_hw_i2c_xfer,\n\t.functionality = radeon_hw_i2c_func,\n};\n\nstatic const struct i2c_algorithm radeon_atom_i2c_algo = {\n\t.master_xfer = radeon_atom_hw_i2c_xfer,\n\t.functionality = radeon_atom_hw_i2c_func,\n};\n\nstruct radeon_i2c_chan *radeon_i2c_create(struct drm_device *dev,\n\t\t\t\t\t  struct radeon_i2c_bus_rec *rec,\n\t\t\t\t\t  const char *name)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_i2c_chan *i2c;\n\tint ret;\n\n\t \n\tif (rec->mm_i2c && (radeon_hw_i2c == 0))\n\t\treturn NULL;\n\n\ti2c = kzalloc(sizeof(struct radeon_i2c_chan), GFP_KERNEL);\n\tif (i2c == NULL)\n\t\treturn NULL;\n\n\ti2c->rec = *rec;\n\ti2c->adapter.owner = THIS_MODULE;\n\ti2c->adapter.class = I2C_CLASS_DDC;\n\ti2c->adapter.dev.parent = dev->dev;\n\ti2c->dev = dev;\n\ti2c_set_adapdata(&i2c->adapter, i2c);\n\tmutex_init(&i2c->mutex);\n\tif (rec->mm_i2c ||\n\t    (rec->hw_capable &&\n\t     radeon_hw_i2c &&\n\t     ((rdev->family <= CHIP_RS480) ||\n\t      ((rdev->family >= CHIP_RV515) && (rdev->family <= CHIP_R580))))) {\n\t\t \n\t\tsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\n\t\t\t \"Radeon i2c hw bus %s\", name);\n\t\ti2c->adapter.algo = &radeon_i2c_algo;\n\t\tret = i2c_add_adapter(&i2c->adapter);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t} else if (rec->hw_capable &&\n\t\t   radeon_hw_i2c &&\n\t\t   ASIC_IS_DCE3(rdev)) {\n\t\t \n\t\tsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\n\t\t\t \"Radeon i2c hw bus %s\", name);\n\t\ti2c->adapter.algo = &radeon_atom_i2c_algo;\n\t\tret = i2c_add_adapter(&i2c->adapter);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t} else {\n\t\t \n\t\tsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\n\t\t\t \"Radeon i2c bit bus %s\", name);\n\t\ti2c->adapter.algo_data = &i2c->bit;\n\t\ti2c->bit.pre_xfer = pre_xfer;\n\t\ti2c->bit.post_xfer = post_xfer;\n\t\ti2c->bit.setsda = set_data;\n\t\ti2c->bit.setscl = set_clock;\n\t\ti2c->bit.getsda = get_data;\n\t\ti2c->bit.getscl = get_clock;\n\t\ti2c->bit.udelay = 10;\n\t\ti2c->bit.timeout = usecs_to_jiffies(2200);\t \n\t\ti2c->bit.data = i2c;\n\t\tret = i2c_bit_add_bus(&i2c->adapter);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"Failed to register bit i2c %s\\n\", name);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\treturn i2c;\nout_free:\n\tkfree(i2c);\n\treturn NULL;\n\n}\n\nvoid radeon_i2c_destroy(struct radeon_i2c_chan *i2c)\n{\n\tif (!i2c)\n\t\treturn;\n\tWARN_ON(i2c->has_aux);\n\ti2c_del_adapter(&i2c->adapter);\n\tkfree(i2c);\n}\n\n \nvoid radeon_i2c_init(struct radeon_device *rdev)\n{\n\tif (radeon_hw_i2c)\n\t\tDRM_INFO(\"hw_i2c forced on, you may experience display detection problems!\\n\");\n\n\tif (rdev->is_atom_bios)\n\t\tradeon_atombios_i2c_init(rdev);\n\telse\n\t\tradeon_combios_i2c_init(rdev);\n}\n\n \nvoid radeon_i2c_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < RADEON_MAX_I2C_BUS; i++) {\n\t\tif (rdev->i2c_bus[i]) {\n\t\t\tradeon_i2c_destroy(rdev->i2c_bus[i]);\n\t\t\trdev->i2c_bus[i] = NULL;\n\t\t}\n\t}\n}\n\n \nvoid radeon_i2c_add(struct radeon_device *rdev,\n\t\t    struct radeon_i2c_bus_rec *rec,\n\t\t    const char *name)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tint i;\n\n\tfor (i = 0; i < RADEON_MAX_I2C_BUS; i++) {\n\t\tif (!rdev->i2c_bus[i]) {\n\t\t\trdev->i2c_bus[i] = radeon_i2c_create(dev, rec, name);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstruct radeon_i2c_chan *radeon_i2c_lookup(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_i2c_bus_rec *i2c_bus)\n{\n\tint i;\n\n\tfor (i = 0; i < RADEON_MAX_I2C_BUS; i++) {\n\t\tif (rdev->i2c_bus[i] &&\n\t\t    (rdev->i2c_bus[i]->rec.i2c_id == i2c_bus->i2c_id)) {\n\t\t\treturn rdev->i2c_bus[i];\n\t\t}\n\t}\n\treturn NULL;\n}\n\nvoid radeon_i2c_get_byte(struct radeon_i2c_chan *i2c_bus,\n\t\t\t u8 slave_addr,\n\t\t\t u8 addr,\n\t\t\t u8 *val)\n{\n\tu8 out_buf[2];\n\tu8 in_buf[2];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = slave_addr,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = out_buf,\n\t\t},\n\t\t{\n\t\t\t.addr = slave_addr,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = 1,\n\t\t\t.buf = in_buf,\n\t\t}\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = 0;\n\n\tif (i2c_transfer(&i2c_bus->adapter, msgs, 2) == 2) {\n\t\t*val = in_buf[0];\n\t\tDRM_DEBUG(\"val = 0x%02x\\n\", *val);\n\t} else {\n\t\tDRM_DEBUG(\"i2c 0x%02x 0x%02x read failed\\n\",\n\t\t\t  addr, *val);\n\t}\n}\n\nvoid radeon_i2c_put_byte(struct radeon_i2c_chan *i2c_bus,\n\t\t\t u8 slave_addr,\n\t\t\t u8 addr,\n\t\t\t u8 val)\n{\n\tuint8_t out_buf[2];\n\tstruct i2c_msg msg = {\n\t\t.addr = slave_addr,\n\t\t.flags = 0,\n\t\t.len = 2,\n\t\t.buf = out_buf,\n\t};\n\n\tout_buf[0] = addr;\n\tout_buf[1] = val;\n\n\tif (i2c_transfer(&i2c_bus->adapter, &msg, 1) != 1)\n\t\tDRM_DEBUG(\"i2c 0x%02x 0x%02x write failed\\n\",\n\t\t\t  addr, val);\n}\n\n \nvoid radeon_router_select_ddc_port(struct radeon_connector *radeon_connector)\n{\n\tu8 val;\n\n\tif (!radeon_connector->router.ddc_valid)\n\t\treturn;\n\n\tif (!radeon_connector->router_bus)\n\t\treturn;\n\n\tradeon_i2c_get_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x3, &val);\n\tval &= ~radeon_connector->router.ddc_mux_control_pin;\n\tradeon_i2c_put_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x3, val);\n\tradeon_i2c_get_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x1, &val);\n\tval &= ~radeon_connector->router.ddc_mux_control_pin;\n\tval |= radeon_connector->router.ddc_mux_state;\n\tradeon_i2c_put_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x1, val);\n}\n\n \nvoid radeon_router_select_cd_port(struct radeon_connector *radeon_connector)\n{\n\tu8 val;\n\n\tif (!radeon_connector->router.cd_valid)\n\t\treturn;\n\n\tif (!radeon_connector->router_bus)\n\t\treturn;\n\n\tradeon_i2c_get_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x3, &val);\n\tval &= ~radeon_connector->router.cd_mux_control_pin;\n\tradeon_i2c_put_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x3, val);\n\tradeon_i2c_get_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x1, &val);\n\tval &= ~radeon_connector->router.cd_mux_control_pin;\n\tval |= radeon_connector->router.cd_mux_state;\n\tradeon_i2c_put_byte(radeon_connector->router_bus,\n\t\t\t    radeon_connector->router.i2c_addr,\n\t\t\t    0x1, val);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}