{
  "module_name": "radeon_audio.c",
  "hash_id": "a0376cab0592a28979220de82ac1b1f5c68d43687e86cabdaeda0e9d24662965",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_audio.c",
  "human_readable_source": " \n\n#include <linux/gcd.h>\n#include <linux/component.h>\n\n#include <drm/drm_crtc.h>\n#include \"dce6_afmt.h\"\n#include \"evergreen_hdmi.h\"\n#include \"radeon.h\"\n#include \"atom.h\"\n#include \"r600.h\"\n#include \"radeon_audio.h\"\n\nvoid dce6_audio_enable(struct radeon_device *rdev, struct r600_audio_pin *pin,\n\t\tu8 enable_mask);\nstruct r600_audio_pin* r600_audio_get_pin(struct radeon_device *rdev);\nstruct r600_audio_pin* dce6_audio_get_pin(struct radeon_device *rdev);\nstatic void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,\n\tstruct drm_display_mode *mode);\nstatic void radeon_audio_dp_mode_set(struct drm_encoder *encoder,\n\tstruct drm_display_mode *mode);\n\nstatic const u32 pin_offsets[7] =\n{\n\t(0x5e00 - 0x5e00),\n\t(0x5e18 - 0x5e00),\n\t(0x5e30 - 0x5e00),\n\t(0x5e48 - 0x5e00),\n\t(0x5e60 - 0x5e00),\n\t(0x5e78 - 0x5e00),\n\t(0x5e90 - 0x5e00),\n};\n\nstatic u32 radeon_audio_rreg(struct radeon_device *rdev, u32 offset, u32 reg)\n{\n\treturn RREG32(reg);\n}\n\nstatic void radeon_audio_wreg(struct radeon_device *rdev, u32 offset,\n\t\tu32 reg, u32 v)\n{\n\tWREG32(reg, v);\n}\n\nstatic struct radeon_audio_basic_funcs r600_funcs = {\n\t.endpoint_rreg = radeon_audio_rreg,\n\t.endpoint_wreg = radeon_audio_wreg,\n\t.enable = r600_audio_enable,\n};\n\nstatic struct radeon_audio_basic_funcs dce32_funcs = {\n\t.endpoint_rreg = radeon_audio_rreg,\n\t.endpoint_wreg = radeon_audio_wreg,\n\t.enable = r600_audio_enable,\n};\n\nstatic struct radeon_audio_basic_funcs dce4_funcs = {\n\t.endpoint_rreg = radeon_audio_rreg,\n\t.endpoint_wreg = radeon_audio_wreg,\n\t.enable = dce4_audio_enable,\n};\n\nstatic struct radeon_audio_basic_funcs dce6_funcs = {\n\t.endpoint_rreg = dce6_endpoint_rreg,\n\t.endpoint_wreg = dce6_endpoint_wreg,\n\t.enable = dce6_audio_enable,\n};\n\nstatic struct radeon_audio_funcs r600_hdmi_funcs = {\n\t.get_pin = r600_audio_get_pin,\n\t.set_dto = r600_hdmi_audio_set_dto,\n\t.update_acr = r600_hdmi_update_acr,\n\t.set_vbi_packet = r600_set_vbi_packet,\n\t.set_avi_packet = r600_set_avi_packet,\n\t.set_audio_packet = r600_set_audio_packet,\n\t.set_mute = r600_set_mute,\n\t.mode_set = radeon_audio_hdmi_mode_set,\n\t.dpms = r600_hdmi_enable,\n};\n\nstatic struct radeon_audio_funcs dce32_hdmi_funcs = {\n\t.get_pin = r600_audio_get_pin,\n\t.write_sad_regs = dce3_2_afmt_write_sad_regs,\n\t.write_speaker_allocation = dce3_2_afmt_hdmi_write_speaker_allocation,\n\t.set_dto = dce3_2_audio_set_dto,\n\t.update_acr = dce3_2_hdmi_update_acr,\n\t.set_vbi_packet = r600_set_vbi_packet,\n\t.set_avi_packet = r600_set_avi_packet,\n\t.set_audio_packet = dce3_2_set_audio_packet,\n\t.set_mute = dce3_2_set_mute,\n\t.mode_set = radeon_audio_hdmi_mode_set,\n\t.dpms = r600_hdmi_enable,\n};\n\nstatic struct radeon_audio_funcs dce32_dp_funcs = {\n\t.get_pin = r600_audio_get_pin,\n\t.write_sad_regs = dce3_2_afmt_write_sad_regs,\n\t.write_speaker_allocation = dce3_2_afmt_dp_write_speaker_allocation,\n\t.set_dto = dce3_2_audio_set_dto,\n\t.set_avi_packet = r600_set_avi_packet,\n\t.set_audio_packet = dce3_2_set_audio_packet,\n};\n\nstatic struct radeon_audio_funcs dce4_hdmi_funcs = {\n\t.get_pin = r600_audio_get_pin,\n\t.write_sad_regs = evergreen_hdmi_write_sad_regs,\n\t.write_speaker_allocation = dce4_afmt_hdmi_write_speaker_allocation,\n\t.write_latency_fields = dce4_afmt_write_latency_fields,\n\t.set_dto = dce4_hdmi_audio_set_dto,\n\t.update_acr = evergreen_hdmi_update_acr,\n\t.set_vbi_packet = dce4_set_vbi_packet,\n\t.set_color_depth = dce4_hdmi_set_color_depth,\n\t.set_avi_packet = evergreen_set_avi_packet,\n\t.set_audio_packet = dce4_set_audio_packet,\n\t.set_mute = dce4_set_mute,\n\t.mode_set = radeon_audio_hdmi_mode_set,\n\t.dpms = evergreen_hdmi_enable,\n};\n\nstatic struct radeon_audio_funcs dce4_dp_funcs = {\n\t.get_pin = r600_audio_get_pin,\n\t.write_sad_regs = evergreen_hdmi_write_sad_regs,\n\t.write_speaker_allocation = dce4_afmt_dp_write_speaker_allocation,\n\t.write_latency_fields = dce4_afmt_write_latency_fields,\n\t.set_dto = dce4_dp_audio_set_dto,\n\t.set_avi_packet = evergreen_set_avi_packet,\n\t.set_audio_packet = dce4_set_audio_packet,\n\t.mode_set = radeon_audio_dp_mode_set,\n\t.dpms = evergreen_dp_enable,\n};\n\nstatic struct radeon_audio_funcs dce6_hdmi_funcs = {\n\t.select_pin = dce6_afmt_select_pin,\n\t.get_pin = dce6_audio_get_pin,\n\t.write_sad_regs = dce6_afmt_write_sad_regs,\n\t.write_speaker_allocation = dce6_afmt_hdmi_write_speaker_allocation,\n\t.write_latency_fields = dce6_afmt_write_latency_fields,\n\t.set_dto = dce6_hdmi_audio_set_dto,\n\t.update_acr = evergreen_hdmi_update_acr,\n\t.set_vbi_packet = dce4_set_vbi_packet,\n\t.set_color_depth = dce4_hdmi_set_color_depth,\n\t.set_avi_packet = evergreen_set_avi_packet,\n\t.set_audio_packet = dce4_set_audio_packet,\n\t.set_mute = dce4_set_mute,\n\t.mode_set = radeon_audio_hdmi_mode_set,\n\t.dpms = evergreen_hdmi_enable,\n};\n\nstatic struct radeon_audio_funcs dce6_dp_funcs = {\n\t.select_pin = dce6_afmt_select_pin,\n\t.get_pin = dce6_audio_get_pin,\n\t.write_sad_regs = dce6_afmt_write_sad_regs,\n\t.write_speaker_allocation = dce6_afmt_dp_write_speaker_allocation,\n\t.write_latency_fields = dce6_afmt_write_latency_fields,\n\t.set_dto = dce6_dp_audio_set_dto,\n\t.set_avi_packet = evergreen_set_avi_packet,\n\t.set_audio_packet = dce4_set_audio_packet,\n\t.mode_set = radeon_audio_dp_mode_set,\n\t.dpms = evergreen_dp_enable,\n};\n\nstatic void radeon_audio_component_notify(struct radeon_device *rdev, int port);\n\nstatic void radeon_audio_enable(struct radeon_device *rdev,\n\t\t\t\tstruct r600_audio_pin *pin, u8 enable_mask)\n{\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct radeon_encoder_atom_dig *dig;\n\tint pin_count = 0;\n\n\tif (!pin)\n\t\treturn;\n\n\tif (rdev->mode_info.mode_config_initialized) {\n\t\tlist_for_each_entry(encoder, &rdev->ddev->mode_config.encoder_list, head) {\n\t\t\tif (radeon_encoder_is_digital(encoder)) {\n\t\t\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\t\t\tdig = radeon_encoder->enc_priv;\n\t\t\t\tif (dig->pin == pin)\n\t\t\t\t\tpin_count++;\n\t\t\t}\n\t\t}\n\n\t\tif ((pin_count > 1) && (enable_mask == 0))\n\t\t\treturn;\n\t}\n\n\tif (rdev->audio.funcs->enable)\n\t\trdev->audio.funcs->enable(rdev, pin, enable_mask);\n\n\tradeon_audio_component_notify(rdev, pin->id);\n}\n\nstatic void radeon_audio_interface_init(struct radeon_device *rdev)\n{\n\tif (ASIC_IS_DCE6(rdev)) {\n\t\trdev->audio.funcs = &dce6_funcs;\n\t\trdev->audio.hdmi_funcs = &dce6_hdmi_funcs;\n\t\trdev->audio.dp_funcs = &dce6_dp_funcs;\n\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\trdev->audio.funcs = &dce4_funcs;\n\t\trdev->audio.hdmi_funcs = &dce4_hdmi_funcs;\n\t\trdev->audio.dp_funcs = &dce4_dp_funcs;\n\t} else if (ASIC_IS_DCE32(rdev)) {\n\t\trdev->audio.funcs = &dce32_funcs;\n\t\trdev->audio.hdmi_funcs = &dce32_hdmi_funcs;\n\t\trdev->audio.dp_funcs = &dce32_dp_funcs;\n\t} else {\n\t\trdev->audio.funcs = &r600_funcs;\n\t\trdev->audio.hdmi_funcs = &r600_hdmi_funcs;\n\t\trdev->audio.dp_funcs = NULL;\n\t}\n}\n\nstatic int radeon_audio_chipset_supported(struct radeon_device *rdev)\n{\n\treturn ASIC_IS_DCE2(rdev) && !ASIC_IS_NODCE(rdev);\n}\n\nint radeon_audio_init(struct radeon_device *rdev)\n{\n\tint i;\n\n\tif (!radeon_audio || !radeon_audio_chipset_supported(rdev))\n\t\treturn 0;\n\n\trdev->audio.enabled = true;\n\n\tif (ASIC_IS_DCE83(rdev))\t\t \n\t\trdev->audio.num_pins = 3;\n\telse if (ASIC_IS_DCE81(rdev))\t \n\t\trdev->audio.num_pins = 7;\n\telse if (ASIC_IS_DCE8(rdev))\t \n\t\trdev->audio.num_pins = 7;\n\telse if (ASIC_IS_DCE64(rdev))\t \n\t\trdev->audio.num_pins = 2;\n\telse if (ASIC_IS_DCE61(rdev))\t \n\t\trdev->audio.num_pins = 6;\n\telse if (ASIC_IS_DCE6(rdev))\t \n\t\trdev->audio.num_pins = 6;\n\telse\n\t\trdev->audio.num_pins = 1;\n\n\tfor (i = 0; i < rdev->audio.num_pins; i++) {\n\t\trdev->audio.pin[i].channels = -1;\n\t\trdev->audio.pin[i].rate = -1;\n\t\trdev->audio.pin[i].bits_per_sample = -1;\n\t\trdev->audio.pin[i].status_bits = 0;\n\t\trdev->audio.pin[i].category_code = 0;\n\t\trdev->audio.pin[i].connected = false;\n\t\trdev->audio.pin[i].offset = pin_offsets[i];\n\t\trdev->audio.pin[i].id = i;\n\t}\n\n\tradeon_audio_interface_init(rdev);\n\n\t \n\tfor (i = 0; i < rdev->audio.num_pins; i++)\n\t\tradeon_audio_enable(rdev, &rdev->audio.pin[i], 0);\n\n\treturn 0;\n}\n\nu32 radeon_audio_endpoint_rreg(struct radeon_device *rdev, u32 offset, u32 reg)\n{\n\tif (rdev->audio.funcs->endpoint_rreg)\n\t\treturn rdev->audio.funcs->endpoint_rreg(rdev, offset, reg);\n\n\treturn 0;\n}\n\nvoid radeon_audio_endpoint_wreg(struct radeon_device *rdev, u32 offset,\n\tu32 reg, u32 v)\n{\n\tif (rdev->audio.funcs->endpoint_wreg)\n\t\trdev->audio.funcs->endpoint_wreg(rdev, offset, reg, v);\n}\n\nstatic void radeon_audio_write_sad_regs(struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct cea_sad *sads;\n\tint sad_count;\n\n\tif (!connector)\n\t\treturn;\n\n\tsad_count = drm_edid_to_sad(radeon_connector_edid(connector), &sads);\n\tif (sad_count < 0)\n\t\tDRM_ERROR(\"Couldn't read SADs: %d\\n\", sad_count);\n\tif (sad_count <= 0)\n\t\treturn;\n\tBUG_ON(!sads);\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->write_sad_regs)\n\t\tradeon_encoder->audio->write_sad_regs(encoder, sads, sad_count);\n\n\tkfree(sads);\n}\n\nstatic void radeon_audio_write_speaker_allocation(struct drm_encoder *encoder)\n{\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tu8 *sadb = NULL;\n\tint sad_count;\n\n\tif (!connector)\n\t\treturn;\n\n\tsad_count = drm_edid_to_speaker_allocation(radeon_connector_edid(connector),\n\t\t\t\t\t\t   &sadb);\n\tif (sad_count < 0) {\n\t\tDRM_DEBUG(\"Couldn't read Speaker Allocation Data Block: %d\\n\",\n\t\t\t  sad_count);\n\t\tsad_count = 0;\n\t}\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->write_speaker_allocation)\n\t\tradeon_encoder->audio->write_speaker_allocation(encoder, sadb, sad_count);\n\n\tkfree(sadb);\n}\n\nstatic void radeon_audio_write_latency_fields(struct drm_encoder *encoder,\n\t\t\t\t\t      struct drm_display_mode *mode)\n{\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\n\tif (!connector)\n\t\treturn;\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->write_latency_fields)\n\t\tradeon_encoder->audio->write_latency_fields(encoder, connector, mode);\n}\n\nstruct r600_audio_pin* radeon_audio_get_pin(struct drm_encoder *encoder)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->get_pin)\n\t\treturn radeon_encoder->audio->get_pin(rdev);\n\n\treturn NULL;\n}\n\nstatic void radeon_audio_select_pin(struct drm_encoder *encoder)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->select_pin)\n\t\tradeon_encoder->audio->select_pin(encoder);\n}\n\nvoid radeon_audio_detect(struct drm_connector *connector,\n\t\t\t struct drm_encoder *encoder,\n\t\t\t enum drm_connector_status status)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig;\n\n\tif (!radeon_audio_chipset_supported(rdev))\n\t\treturn;\n\n\tif (!radeon_encoder_is_digital(encoder))\n\t\treturn;\n\n\tdig = radeon_encoder->enc_priv;\n\n\tif (status == connector_status_connected) {\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\t\t\tif (radeon_dp_getsinktype(radeon_connector) ==\n\t\t\t    CONNECTOR_OBJECT_ID_DISPLAYPORT)\n\t\t\t\tradeon_encoder->audio = rdev->audio.dp_funcs;\n\t\t\telse\n\t\t\t\tradeon_encoder->audio = rdev->audio.hdmi_funcs;\n\t\t} else {\n\t\t\tradeon_encoder->audio = rdev->audio.hdmi_funcs;\n\t\t}\n\n\t\tif (drm_detect_monitor_audio(radeon_connector_edid(connector))) {\n\t\t\tif (!dig->pin)\n\t\t\t\tdig->pin = radeon_audio_get_pin(encoder);\n\t\t\tradeon_audio_enable(rdev, dig->pin, 0xf);\n\t\t} else {\n\t\t\tradeon_audio_enable(rdev, dig->pin, 0);\n\t\t\tdig->pin = NULL;\n\t\t}\n\t} else {\n\t\tradeon_audio_enable(rdev, dig->pin, 0);\n\t\tdig->pin = NULL;\n\t}\n}\n\nvoid radeon_audio_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tif (!rdev->audio.enabled)\n\t\treturn;\n\n\tfor (i = 0; i < rdev->audio.num_pins; i++)\n\t\tradeon_audio_enable(rdev, &rdev->audio.pin[i], 0);\n\n\trdev->audio.enabled = false;\n}\n\nstatic void radeon_audio_set_dto(struct drm_encoder *encoder, unsigned int clock)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *crtc = to_radeon_crtc(encoder->crtc);\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->set_dto)\n\t\tradeon_encoder->audio->set_dto(rdev, crtc, clock);\n}\n\nstatic int radeon_audio_set_avi_packet(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tu8 buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AVI_INFOFRAME_SIZE];\n\tstruct hdmi_avi_infoframe frame;\n\tint err;\n\n\tif (!connector)\n\t\treturn -EINVAL;\n\n\terr = drm_hdmi_avi_infoframe_from_display_mode(&frame, connector, mode);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to setup AVI infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (radeon_encoder->output_csc != RADEON_OUTPUT_CSC_BYPASS) {\n\t\tdrm_hdmi_avi_infoframe_quant_range(&frame, connector, mode,\n\t\t\t\t\t\t   radeon_encoder->output_csc == RADEON_OUTPUT_CSC_TVRGB ?\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_LIMITED :\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL);\n\t}\n\n\terr = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to pack AVI infoframe: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (dig && dig->afmt && radeon_encoder->audio &&\n\t    radeon_encoder->audio->set_avi_packet)\n\t\tradeon_encoder->audio->set_avi_packet(rdev, dig->afmt->offset,\n\t\t\tbuffer, sizeof(buffer));\n\n\treturn 0;\n}\n\n \nstatic void radeon_audio_calc_cts(unsigned int clock, int *CTS, int *N, int freq)\n{\n\tint n, cts;\n\tunsigned long div, mul;\n\n\t \n\tn = 128 * freq;\n\tcts = clock * 1000;\n\n\t \n\tdiv = gcd(n, cts);\n\n\tn /= div;\n\tcts /= div;\n\n\t \n\tmul = ((128*freq/1000) + (n-1))/n;\n\n\tn *= mul;\n\tcts *= mul;\n\n\t \n\tif (n < (128*freq/1500))\n\t\tpr_warn(\"Calculated ACR N value is too small. You may experience audio problems.\\n\");\n\tif (n > (128*freq/300))\n\t\tpr_warn(\"Calculated ACR N value is too large. You may experience audio problems.\\n\");\n\n\t*N = n;\n\t*CTS = cts;\n\n\tDRM_DEBUG(\"Calculated ACR timing N=%d CTS=%d for frequency %d\\n\",\n\t\t*N, *CTS, freq);\n}\n\nstatic const struct radeon_hdmi_acr* radeon_audio_acr(unsigned int clock)\n{\n\tstatic struct radeon_hdmi_acr res;\n\tu8 i;\n\n\tstatic const struct radeon_hdmi_acr hdmi_predefined_acr[] = {\n\t\t \n\t\t \n\t\t{  25175,  4096,  25175, 28224, 125875,  6144,  25175 },  \n\t\t{  25200,  4096,  25200,  6272,  28000,  6144,  25200 },  \n\t\t{  27000,  4096,  27000,  6272,  30000,  6144,  27000 },  \n\t\t{  27027,  4096,  27027,  6272,  30030,  6144,  27027 },  \n\t\t{  54000,  4096,  54000,  6272,  60000,  6144,  54000 },  \n\t\t{  54054,  4096,  54054,  6272,  60060,  6144,  54054 },  \n\t\t{  74176,  4096,  74176,  5733,  75335,  6144,  74176 },  \n\t\t{  74250,  4096,  74250,  6272,  82500,  6144,  74250 },  \n\t\t{ 148352,  4096, 148352,  5733, 150670,  6144, 148352 },  \n\t\t{ 148500,  4096, 148500,  6272, 165000,  6144, 148500 },  \n\t};\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(hdmi_predefined_acr); i++)\n\t\tif (hdmi_predefined_acr[i].clock == clock)\n\t\t\treturn &hdmi_predefined_acr[i];\n\n\t \n\tradeon_audio_calc_cts(clock, &res.cts_32khz, &res.n_32khz, 32000);\n\tradeon_audio_calc_cts(clock, &res.cts_44_1khz, &res.n_44_1khz, 44100);\n\tradeon_audio_calc_cts(clock, &res.cts_48khz, &res.n_48khz, 48000);\n\n\treturn &res;\n}\n\n \nstatic void radeon_audio_update_acr(struct drm_encoder *encoder, unsigned int clock)\n{\n\tconst struct radeon_hdmi_acr *acr = radeon_audio_acr(clock);\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->update_acr)\n\t\tradeon_encoder->audio->update_acr(encoder, dig->afmt->offset, acr);\n}\n\nstatic void radeon_audio_set_vbi_packet(struct drm_encoder *encoder)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->set_vbi_packet)\n\t\tradeon_encoder->audio->set_vbi_packet(encoder, dig->afmt->offset);\n}\n\nstatic void radeon_hdmi_set_color_depth(struct drm_encoder *encoder)\n{\n\tint bpc = 8;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (encoder->crtc) {\n\t\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\t\tbpc = radeon_crtc->bpc;\n\t}\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->set_color_depth)\n\t\tradeon_encoder->audio->set_color_depth(encoder, dig->afmt->offset, bpc);\n}\n\nstatic void radeon_audio_set_audio_packet(struct drm_encoder *encoder)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->set_audio_packet)\n\t\tradeon_encoder->audio->set_audio_packet(encoder, dig->afmt->offset);\n}\n\nstatic void radeon_audio_set_mute(struct drm_encoder *encoder, bool mute)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->set_mute)\n\t\tradeon_encoder->audio->set_mute(encoder, dig->afmt->offset, mute);\n}\n\n \nstatic void radeon_audio_hdmi_mode_set(struct drm_encoder *encoder,\n\t\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (!connector)\n\t\treturn;\n\n\tif (drm_detect_monitor_audio(radeon_connector_edid(connector))) {\n\t\tradeon_audio_set_mute(encoder, true);\n\n\t\tradeon_audio_write_speaker_allocation(encoder);\n\t\tradeon_audio_write_sad_regs(encoder);\n\t\tradeon_audio_write_latency_fields(encoder, mode);\n\t\tradeon_audio_set_dto(encoder, mode->clock);\n\t\tradeon_audio_set_vbi_packet(encoder);\n\t\tradeon_hdmi_set_color_depth(encoder);\n\t\tradeon_audio_update_acr(encoder, mode->clock);\n\t\tradeon_audio_set_audio_packet(encoder);\n\t\tradeon_audio_select_pin(encoder);\n\n\t\tif (radeon_audio_set_avi_packet(encoder, mode) < 0)\n\t\t\treturn;\n\n\t\tradeon_audio_set_mute(encoder, false);\n\t} else {\n\t\tradeon_hdmi_set_color_depth(encoder);\n\n\t\tif (radeon_audio_set_avi_packet(encoder, mode) < 0)\n\t\t\treturn;\n\t}\n}\n\nstatic void radeon_audio_dp_mode_set(struct drm_encoder *encoder,\n\t\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (!connector)\n\t\treturn;\n\n\tif (drm_detect_monitor_audio(radeon_connector_edid(connector))) {\n\t\tradeon_audio_write_speaker_allocation(encoder);\n\t\tradeon_audio_write_sad_regs(encoder);\n\t\tradeon_audio_write_latency_fields(encoder, mode);\n\t\tradeon_audio_set_dto(encoder, rdev->clock.vco_freq * 10);\n\t\tradeon_audio_set_audio_packet(encoder);\n\t\tradeon_audio_select_pin(encoder);\n\n\t\tif (radeon_audio_set_avi_packet(encoder, mode) < 0)\n\t\t\treturn;\n\t}\n}\n\nvoid radeon_audio_mode_set(struct drm_encoder *encoder,\n\t\t\t   struct drm_display_mode *mode)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->mode_set)\n\t\tradeon_encoder->audio->mode_set(encoder, mode);\n}\n\nvoid radeon_audio_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\n\tif (radeon_encoder->audio && radeon_encoder->audio->dpms)\n\t\tradeon_encoder->audio->dpms(encoder, mode == DRM_MODE_DPMS_ON);\n}\n\nunsigned int radeon_audio_decode_dfs_div(unsigned int div)\n{\n\tif (div >= 8 && div < 64)\n\t\treturn (div - 8) * 25 + 200;\n\telse if (div >= 64 && div < 96)\n\t\treturn (div - 64) * 50 + 1600;\n\telse if (div >= 96 && div < 128)\n\t\treturn (div - 96) * 100 + 3200;\n\telse\n\t\treturn 0;\n}\n\n \nstatic void radeon_audio_component_notify(struct radeon_device *rdev, int port)\n{\n\tstruct drm_audio_component *acomp;\n\n\tmutex_lock(&rdev->audio.component_mutex);\n\tacomp = rdev->audio.component;\n\tif (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify)\n\t\tacomp->audio_ops->pin_eld_notify(acomp->audio_ops->audio_ptr,\n\t\t\t\t\t\t port, -1);\n\tmutex_unlock(&rdev->audio.component_mutex);\n}\n\nstatic int radeon_audio_component_get_eld(struct device *kdev, int port,\n\t\t\t\t\t  int pipe, bool *enabled,\n\t\t\t\t\t  unsigned char *buf, int max_bytes)\n{\n\tstruct drm_device *dev = dev_get_drvdata(kdev);\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct radeon_encoder_atom_dig *dig;\n\tstruct drm_connector *connector;\n\tint ret = 0;\n\n\t*enabled = false;\n\tif (!rdev->audio.enabled || !rdev->mode_info.mode_config_initialized)\n\t\treturn 0;\n\n\tlist_for_each_entry(encoder, &rdev->ddev->mode_config.encoder_list, head) {\n\t\tif (!radeon_encoder_is_digital(encoder))\n\t\t\tcontinue;\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\tdig = radeon_encoder->enc_priv;\n\t\tif (!dig->pin || dig->pin->id != port)\n\t\t\tcontinue;\n\t\tconnector = radeon_get_connector_for_encoder(encoder);\n\t\tif (!connector)\n\t\t\tcontinue;\n\t\t*enabled = true;\n\t\tret = drm_eld_size(connector->eld);\n\t\tmemcpy(buf, connector->eld, min(max_bytes, ret));\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct drm_audio_component_ops radeon_audio_component_ops = {\n\t.get_eld = radeon_audio_component_get_eld,\n};\n\nstatic int radeon_audio_component_bind(struct device *kdev,\n\t\t\t\t       struct device *hda_kdev, void *data)\n{\n\tstruct drm_device *dev = dev_get_drvdata(kdev);\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_audio_component *acomp = data;\n\n\tif (WARN_ON(!device_link_add(hda_kdev, kdev, DL_FLAG_STATELESS)))\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&rdev->audio.component_mutex);\n\tacomp->ops = &radeon_audio_component_ops;\n\tacomp->dev = kdev;\n\trdev->audio.component = acomp;\n\tmutex_unlock(&rdev->audio.component_mutex);\n\n\treturn 0;\n}\n\nstatic void radeon_audio_component_unbind(struct device *kdev,\n\t\t\t\t\t  struct device *hda_kdev, void *data)\n{\n\tstruct drm_device *dev = dev_get_drvdata(kdev);\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_audio_component *acomp = data;\n\n\tdevice_link_remove(hda_kdev, kdev);\n\n\tmutex_lock(&rdev->audio.component_mutex);\n\trdev->audio.component = NULL;\n\tacomp->ops = NULL;\n\tacomp->dev = NULL;\n\tmutex_unlock(&rdev->audio.component_mutex);\n}\n\nstatic const struct component_ops radeon_audio_component_bind_ops = {\n\t.bind\t= radeon_audio_component_bind,\n\t.unbind\t= radeon_audio_component_unbind,\n};\n\nvoid radeon_audio_component_init(struct radeon_device *rdev)\n{\n\tif (rdev->audio.component_registered ||\n\t    !radeon_audio || !radeon_audio_chipset_supported(rdev))\n\t\treturn;\n\n\tif (!component_add(rdev->dev, &radeon_audio_component_bind_ops))\n\t\trdev->audio.component_registered = true;\n}\n\nvoid radeon_audio_component_fini(struct radeon_device *rdev)\n{\n\tif (rdev->audio.component_registered) {\n\t\tcomponent_del(rdev->dev, &radeon_audio_component_bind_ops);\n\t\trdev->audio.component_registered = false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}