{
  "module_name": "r600_hdmi.c",
  "hash_id": "c94f8bae15e752a3d8fcce6dfb05698cd66cd215821dd6d61bf933adde2d75de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/r600_hdmi.c",
  "human_readable_source": " \n#include <linux/hdmi.h>\n#include <linux/gcd.h>\n\n#include <drm/radeon_drm.h>\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"r600.h\"\n#include \"r600d.h\"\n#include \"atom.h\"\n\n \nenum r600_hdmi_color_format {\n\tRGB = 0,\n\tYCC_422 = 1,\n\tYCC_444 = 2\n};\n\n \nenum r600_hdmi_iec_status_bits {\n\tAUDIO_STATUS_DIG_ENABLE   = 0x01,\n\tAUDIO_STATUS_V            = 0x02,\n\tAUDIO_STATUS_VCFG         = 0x04,\n\tAUDIO_STATUS_EMPHASIS     = 0x08,\n\tAUDIO_STATUS_COPYRIGHT    = 0x10,\n\tAUDIO_STATUS_NONAUDIO     = 0x20,\n\tAUDIO_STATUS_PROFESSIONAL = 0x40,\n\tAUDIO_STATUS_LEVEL        = 0x80\n};\n\nstatic struct r600_audio_pin r600_audio_status(struct radeon_device *rdev)\n{\n\tstruct r600_audio_pin status = {};\n\tuint32_t value;\n\n\tvalue = RREG32(R600_AUDIO_RATE_BPS_CHANNEL);\n\n\t \n\tstatus.channels = (value & 0x7) + 1;\n\n\t \n\tswitch ((value & 0xF0) >> 4) {\n\tcase 0x0:\n\t\tstatus.bits_per_sample = 8;\n\t\tbreak;\n\tcase 0x1:\n\t\tstatus.bits_per_sample = 16;\n\t\tbreak;\n\tcase 0x2:\n\t\tstatus.bits_per_sample = 20;\n\t\tbreak;\n\tcase 0x3:\n\t\tstatus.bits_per_sample = 24;\n\t\tbreak;\n\tcase 0x4:\n\t\tstatus.bits_per_sample = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rdev->dev, \"Unknown bits per sample 0x%x, using 16\\n\",\n\t\t\t(int)value);\n\t\tstatus.bits_per_sample = 16;\n\t}\n\n\t \n\tif (value & 0x4000)\n\t\tstatus.rate = 44100;\n\telse\n\t\tstatus.rate = 48000;\n\tstatus.rate *= ((value >> 11) & 0x7) + 1;\n\tstatus.rate /= ((value >> 8) & 0x7) + 1;\n\n\tvalue = RREG32(R600_AUDIO_STATUS_BITS);\n\n\t \n\tstatus.status_bits = value & 0xff;\n\n\t \n\tstatus.category_code = (value >> 8) & 0xff;\n\n\treturn status;\n}\n\n \nvoid r600_audio_update_hdmi(struct work_struct *work)\n{\n\tstruct radeon_device *rdev = container_of(work, struct radeon_device,\n\t\t\t\t\t\t  audio_work);\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct r600_audio_pin audio_status = r600_audio_status(rdev);\n\tstruct drm_encoder *encoder;\n\tbool changed = false;\n\n\tif (rdev->audio.pin[0].channels != audio_status.channels ||\n\t    rdev->audio.pin[0].rate != audio_status.rate ||\n\t    rdev->audio.pin[0].bits_per_sample != audio_status.bits_per_sample ||\n\t    rdev->audio.pin[0].status_bits != audio_status.status_bits ||\n\t    rdev->audio.pin[0].category_code != audio_status.category_code) {\n\t\trdev->audio.pin[0] = audio_status;\n\t\tchanged = true;\n\t}\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (!radeon_encoder_is_digital(encoder))\n\t\t\tcontinue;\n\t\tif (changed || r600_hdmi_buffer_status_changed(encoder))\n\t\t\tr600_hdmi_update_audio_settings(encoder);\n\t}\n}\n\n \nvoid r600_audio_enable(struct radeon_device *rdev,\n\t\t       struct r600_audio_pin *pin,\n\t\t       u8 enable_mask)\n{\n\tu32 tmp = RREG32(AZ_HOT_PLUG_CONTROL);\n\n\tif (!pin)\n\t\treturn;\n\n\tif (enable_mask) {\n\t\ttmp |= AUDIO_ENABLED;\n\t\tif (enable_mask & 1)\n\t\t\ttmp |= PIN0_AUDIO_ENABLED;\n\t\tif (enable_mask & 2)\n\t\t\ttmp |= PIN1_AUDIO_ENABLED;\n\t\tif (enable_mask & 4)\n\t\t\ttmp |= PIN2_AUDIO_ENABLED;\n\t\tif (enable_mask & 8)\n\t\t\ttmp |= PIN3_AUDIO_ENABLED;\n\t} else {\n\t\ttmp &= ~(AUDIO_ENABLED |\n\t\t\t PIN0_AUDIO_ENABLED |\n\t\t\t PIN1_AUDIO_ENABLED |\n\t\t\t PIN2_AUDIO_ENABLED |\n\t\t\t PIN3_AUDIO_ENABLED);\n\t}\n\n\tWREG32(AZ_HOT_PLUG_CONTROL, tmp);\n}\n\nstruct r600_audio_pin *r600_audio_get_pin(struct radeon_device *rdev)\n{\n\t \n\treturn &rdev->audio.pin[0];\n}\n\nvoid r600_hdmi_update_acr(struct drm_encoder *encoder, long offset,\n\tconst struct radeon_hdmi_acr *acr)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\t \n\tuint32_t acr_ctl = ASIC_IS_DCE3(rdev) ? DCE3_HDMI0_ACR_PACKET_CONTROL :\n\t\t\t\t       HDMI0_ACR_PACKET_CONTROL;\n\tWREG32_P(acr_ctl + offset,\n\t\tHDMI0_ACR_SOURCE |\t\t \n\t\tHDMI0_ACR_AUTO_SEND,\t \n\t\t~(HDMI0_ACR_SOURCE |\n\t\tHDMI0_ACR_AUTO_SEND));\n\n\tWREG32_P(HDMI0_ACR_32_0 + offset,\n\t\tHDMI0_ACR_CTS_32(acr->cts_32khz),\n\t\t~HDMI0_ACR_CTS_32_MASK);\n\tWREG32_P(HDMI0_ACR_32_1 + offset,\n\t\tHDMI0_ACR_N_32(acr->n_32khz),\n\t\t~HDMI0_ACR_N_32_MASK);\n\n\tWREG32_P(HDMI0_ACR_44_0 + offset,\n\t\tHDMI0_ACR_CTS_44(acr->cts_44_1khz),\n\t\t~HDMI0_ACR_CTS_44_MASK);\n\tWREG32_P(HDMI0_ACR_44_1 + offset,\n\t\tHDMI0_ACR_N_44(acr->n_44_1khz),\n\t\t~HDMI0_ACR_N_44_MASK);\n\n\tWREG32_P(HDMI0_ACR_48_0 + offset,\n\t\tHDMI0_ACR_CTS_48(acr->cts_48khz),\n\t\t~HDMI0_ACR_CTS_48_MASK);\n\tWREG32_P(HDMI0_ACR_48_1 + offset,\n\t\tHDMI0_ACR_N_48(acr->n_48khz),\n\t\t~HDMI0_ACR_N_48_MASK);\n}\n\n \nvoid r600_set_avi_packet(struct radeon_device *rdev, u32 offset,\n\t\t\t unsigned char *buffer, size_t size)\n{\n\tuint8_t *frame = buffer + 3;\n\n\tWREG32(HDMI0_AVI_INFO0 + offset,\n\t\tframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\n\tWREG32(HDMI0_AVI_INFO1 + offset,\n\t\tframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\n\tWREG32(HDMI0_AVI_INFO2 + offset,\n\t\tframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\n\tWREG32(HDMI0_AVI_INFO3 + offset,\n\t\tframe[0xC] | (frame[0xD] << 8) | (buffer[1] << 24));\n\n\tWREG32_OR(HDMI0_INFOFRAME_CONTROL1 + offset,\n\t\t  HDMI0_AVI_INFO_LINE(2));\t \n\n\tWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\n\t\t  HDMI0_AVI_INFO_SEND |\t \n\t\t  HDMI0_AVI_INFO_CONT);\t \n\n}\n\n \nstatic void r600_hdmi_update_audio_infoframe(struct drm_encoder *encoder,\n\t\t\t\t\t     const void *buffer, size_t size)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tuint32_t offset = dig->afmt->offset;\n\tconst u8 *frame = buffer + 3;\n\n\tWREG32(HDMI0_AUDIO_INFO0 + offset,\n\t\tframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\n\tWREG32(HDMI0_AUDIO_INFO1 + offset,\n\t\tframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x8] << 24));\n}\n\n \nstatic bool r600_hdmi_is_audio_buffer_filled(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tuint32_t offset = dig->afmt->offset;\n\n\treturn (RREG32(HDMI0_STATUS + offset) & 0x10) != 0;\n}\n\n \nint r600_hdmi_buffer_status_changed(struct drm_encoder *encoder)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tint status, result;\n\n\tif (!dig->afmt || !dig->afmt->enabled)\n\t\treturn 0;\n\n\tstatus = r600_hdmi_is_audio_buffer_filled(encoder);\n\tresult = dig->afmt->last_buffer_filled_status != status;\n\tdig->afmt->last_buffer_filled_status = status;\n\n\treturn result;\n}\n\n \nvoid r600_hdmi_audio_workaround(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tuint32_t offset = dig->afmt->offset;\n\tbool hdmi_audio_workaround = false;  \n\tu32 value;\n\n\tif (!hdmi_audio_workaround ||\n\t    r600_hdmi_is_audio_buffer_filled(encoder))\n\t\tvalue = 0;  \n\telse\n\t\tvalue = HDMI0_AUDIO_TEST_EN;  \n\tWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\n\t\t value, ~HDMI0_AUDIO_TEST_EN);\n}\n\nvoid r600_hdmi_audio_set_dto(struct radeon_device *rdev,\n\t\t\t     struct radeon_crtc *crtc, unsigned int clock)\n{\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct radeon_encoder_atom_dig *dig;\n\n\tif (!crtc)\n\t\treturn;\n\n\tradeon_encoder = to_radeon_encoder(crtc->encoder);\n\tdig = radeon_encoder->enc_priv;\n\n\tif (!dig)\n\t\treturn;\n\n\tif (dig->dig_encoder == 0) {\n\t\tWREG32(DCCG_AUDIO_DTO0_PHASE, 24000 * 100);\n\t\tWREG32(DCCG_AUDIO_DTO0_MODULE, clock * 100);\n\t\tWREG32(DCCG_AUDIO_DTO_SELECT, 0);  \n\t} else {\n\t\tWREG32(DCCG_AUDIO_DTO1_PHASE, 24000 * 100);\n\t\tWREG32(DCCG_AUDIO_DTO1_MODULE, clock * 100);\n\t\tWREG32(DCCG_AUDIO_DTO_SELECT, 1);  \n\t}\n}\n\nvoid r600_set_vbi_packet(struct drm_encoder *encoder, u32 offset)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tWREG32_OR(HDMI0_VBI_PACKET_CONTROL + offset,\n\t\tHDMI0_NULL_SEND |\t \n\t\tHDMI0_GC_SEND |\t\t \n\t\tHDMI0_GC_CONT);\t\t \n}\n\nvoid r600_set_audio_packet(struct drm_encoder *encoder, u32 offset)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tWREG32_P(HDMI0_AUDIO_PACKET_CONTROL + offset,\n\t\tHDMI0_AUDIO_SAMPLE_SEND |\t\t\t \n\t\tHDMI0_AUDIO_DELAY_EN(1) |\t\t\t \n\t\tHDMI0_AUDIO_PACKETS_PER_LINE(3) |\t \n\t\tHDMI0_60958_CS_UPDATE,\t\t\t\t \n\t\t~(HDMI0_AUDIO_SAMPLE_SEND |\n\t\tHDMI0_AUDIO_DELAY_EN_MASK |\n\t\tHDMI0_AUDIO_PACKETS_PER_LINE_MASK |\n\t\tHDMI0_60958_CS_UPDATE));\n\n\tWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\n\t\tHDMI0_AUDIO_INFO_SEND |\t\t \n\t\tHDMI0_AUDIO_INFO_UPDATE);\t \n\n\tWREG32_P(HDMI0_INFOFRAME_CONTROL1 + offset,\n\t\tHDMI0_AUDIO_INFO_LINE(2),\t \n\t\t~HDMI0_AUDIO_INFO_LINE_MASK);\n\n\tWREG32_AND(HDMI0_GENERIC_PACKET_CONTROL + offset,\n\t\t~(HDMI0_GENERIC0_SEND |\n\t\tHDMI0_GENERIC0_CONT |\n\t\tHDMI0_GENERIC0_UPDATE |\n\t\tHDMI0_GENERIC1_SEND |\n\t\tHDMI0_GENERIC1_CONT |\n\t\tHDMI0_GENERIC0_LINE_MASK |\n\t\tHDMI0_GENERIC1_LINE_MASK));\n\n\tWREG32_P(HDMI0_60958_0 + offset,\n\t\tHDMI0_60958_CS_CHANNEL_NUMBER_L(1),\n\t\t~(HDMI0_60958_CS_CHANNEL_NUMBER_L_MASK |\n\t\tHDMI0_60958_CS_CLOCK_ACCURACY_MASK));\n\n\tWREG32_P(HDMI0_60958_1 + offset,\n\t\tHDMI0_60958_CS_CHANNEL_NUMBER_R(2),\n\t\t~HDMI0_60958_CS_CHANNEL_NUMBER_R_MASK);\n}\n\nvoid r600_set_mute(struct drm_encoder *encoder, u32 offset, bool mute)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (mute)\n\t\tWREG32_OR(HDMI0_GC + offset, HDMI0_GC_AVMUTE);\n\telse\n\t\tWREG32_AND(HDMI0_GC + offset, ~HDMI0_GC_AVMUTE);\n}\n\n \nvoid r600_hdmi_update_audio_settings(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct r600_audio_pin audio = r600_audio_status(rdev);\n\tuint8_t buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AUDIO_INFOFRAME_SIZE];\n\tstruct hdmi_audio_infoframe frame;\n\tuint32_t offset;\n\tuint32_t value;\n\tssize_t err;\n\n\tif (!dig->afmt || !dig->afmt->enabled)\n\t\treturn;\n\toffset = dig->afmt->offset;\n\n\tDRM_DEBUG(\"%s with %d channels, %d Hz sampling rate, %d bits per sample,\\n\",\n\t\t r600_hdmi_is_audio_buffer_filled(encoder) ? \"playing\" : \"stopped\",\n\t\t  audio.channels, audio.rate, audio.bits_per_sample);\n\tDRM_DEBUG(\"0x%02X IEC60958 status bits and 0x%02X category code\\n\",\n\t\t  (int)audio.status_bits, (int)audio.category_code);\n\n\terr = hdmi_audio_infoframe_init(&frame);\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to setup audio infoframe\\n\");\n\t\treturn;\n\t}\n\n\tframe.channels = audio.channels;\n\n\terr = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\n\tif (err < 0) {\n\t\tDRM_ERROR(\"failed to pack audio infoframe\\n\");\n\t\treturn;\n\t}\n\n\tvalue = RREG32(HDMI0_AUDIO_PACKET_CONTROL + offset);\n\tif (value & HDMI0_AUDIO_TEST_EN)\n\t\tWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\n\t\t       value & ~HDMI0_AUDIO_TEST_EN);\n\n\tWREG32_OR(HDMI0_CONTROL + offset,\n\t\t  HDMI0_ERROR_ACK);\n\n\tWREG32_AND(HDMI0_INFOFRAME_CONTROL0 + offset,\n\t\t   ~HDMI0_AUDIO_INFO_SOURCE);\n\n\tr600_hdmi_update_audio_infoframe(encoder, buffer, sizeof(buffer));\n\n\tWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\n\t\t  HDMI0_AUDIO_INFO_CONT |\n\t\t  HDMI0_AUDIO_INFO_UPDATE);\n}\n\n \nvoid r600_hdmi_enable(struct drm_encoder *encoder, bool enable)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tu32 hdmi = HDMI0_ERROR_ACK;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\t \n\tif (!ASIC_IS_DCE3(rdev)) {\n\t\tif (enable)\n\t\t\thdmi |= HDMI0_ENABLE;\n\t\tswitch (radeon_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\t\t\tif (enable) {\n\t\t\t\tWREG32_OR(AVIVO_TMDSA_CNTL, AVIVO_TMDSA_CNTL_HDMI_EN);\n\t\t\t\thdmi |= HDMI0_STREAM(HDMI0_STREAM_TMDSA);\n\t\t\t} else {\n\t\t\t\tWREG32_AND(AVIVO_TMDSA_CNTL, ~AVIVO_TMDSA_CNTL_HDMI_EN);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\t\tif (enable) {\n\t\t\t\tWREG32_OR(AVIVO_LVTMA_CNTL, AVIVO_LVTMA_CNTL_HDMI_EN);\n\t\t\t\thdmi |= HDMI0_STREAM(HDMI0_STREAM_LVTMA);\n\t\t\t} else {\n\t\t\t\tWREG32_AND(AVIVO_LVTMA_CNTL, ~AVIVO_LVTMA_CNTL_HDMI_EN);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\t\t\tif (enable) {\n\t\t\t\tWREG32_OR(DDIA_CNTL, DDIA_HDMI_EN);\n\t\t\t\thdmi |= HDMI0_STREAM(HDMI0_STREAM_DDIA);\n\t\t\t} else {\n\t\t\t\tWREG32_AND(DDIA_CNTL, ~DDIA_HDMI_EN);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\t\tif (enable)\n\t\t\t\thdmi |= HDMI0_STREAM(HDMI0_STREAM_DVOA);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(rdev->dev, \"Invalid encoder for HDMI: 0x%X\\n\",\n\t\t\t\tradeon_encoder->encoder_id);\n\t\t\tbreak;\n\t\t}\n\t\tWREG32(HDMI0_CONTROL + dig->afmt->offset, hdmi);\n\t}\n\n\tif (rdev->irq.installed) {\n\t\t \n\t\t \n\t\tif (enable)\n\t\t\tradeon_irq_kms_enable_afmt(rdev, dig->afmt->id);\n\t\telse\n\t\t\tradeon_irq_kms_disable_afmt(rdev, dig->afmt->id);\n\t}\n\n\tdig->afmt->enabled = enable;\n\n\tDRM_DEBUG(\"%sabling HDMI interface @ 0x%04X for encoder 0x%x\\n\",\n\t\t  enable ? \"En\" : \"Dis\", dig->afmt->offset, radeon_encoder->encoder_id);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}