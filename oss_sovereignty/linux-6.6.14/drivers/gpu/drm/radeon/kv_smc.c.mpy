{
  "module_name": "kv_smc.c",
  "hash_id": "bb69fc73d55b19c01d9b9ef90581ca3d05c216034507f9612e60accb63678107",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/kv_smc.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"cikd.h\"\n#include \"kv_dpm.h\"\n\nint kv_notify_message_to_smu(struct radeon_device *rdev, u32 id)\n{\n\tu32 i;\n\tu32 tmp = 0;\n\n\tWREG32(SMC_MESSAGE_0, id & SMC_MSG_MASK);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(SMC_RESP_0) & SMC_RESP_MASK) != 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\ttmp = RREG32(SMC_RESP_0) & SMC_RESP_MASK;\n\n\tif (tmp != 1) {\n\t\tif (tmp == 0xFF)\n\t\t\treturn -EINVAL;\n\t\telse if (tmp == 0xFE)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint kv_dpm_get_enable_mask(struct radeon_device *rdev, u32 *enable_mask)\n{\n\tint ret;\n\n\tret = kv_notify_message_to_smu(rdev, PPSMC_MSG_SCLKDPM_GetEnabledMask);\n\n\tif (ret == 0)\n\t\t*enable_mask = RREG32_SMC(SMC_SYSCON_MSG_ARG_0);\n\n\treturn ret;\n}\n\nint kv_send_msg_to_smc_with_parameter(struct radeon_device *rdev,\n\t\t\t\t      PPSMC_Msg msg, u32 parameter)\n{\n\n\tWREG32(SMC_MSG_ARG_0, parameter);\n\n\treturn kv_notify_message_to_smu(rdev, msg);\n}\n\nstatic int kv_set_smc_sram_address(struct radeon_device *rdev,\n\t\t\t\t   u32 smc_address, u32 limit)\n{\n\tif (smc_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_address + 3) > limit)\n\t\treturn -EINVAL;\n\n\tWREG32(SMC_IND_INDEX_0, smc_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\n\treturn 0;\n}\n\nint kv_read_smc_sram_dword(struct radeon_device *rdev, u32 smc_address,\n\t\t\t   u32 *value, u32 limit)\n{\n\tint ret;\n\n\tret = kv_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = RREG32(SMC_IND_DATA_0);\n\treturn 0;\n}\n\nint kv_smc_dpm_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\treturn kv_notify_message_to_smu(rdev, PPSMC_MSG_DPM_Enable);\n\telse\n\t\treturn kv_notify_message_to_smu(rdev, PPSMC_MSG_DPM_Disable);\n}\n\nint kv_smc_bapm_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\treturn kv_notify_message_to_smu(rdev, PPSMC_MSG_EnableBAPM);\n\telse\n\t\treturn kv_notify_message_to_smu(rdev, PPSMC_MSG_DisableBAPM);\n}\n\nint kv_copy_bytes_to_smc(struct radeon_device *rdev,\n\t\t\t u32 smc_start_address,\n\t\t\t const u8 *src, u32 byte_count, u32 limit)\n{\n\tint ret;\n\tu32 data, original_data, addr, extra_shift, t_byte, count, mask;\n\n\tif ((smc_start_address + byte_count) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_start_address;\n\tt_byte = addr & 3;\n\n\t \n\tif  (t_byte != 0) {\n\t\taddr -= t_byte;\n\n\t\tret = kv_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toriginal_data = RREG32(SMC_IND_DATA_0);\n\n\t\tdata = 0;\n\t\tmask = 0;\n\t\tcount = 4;\n\t\twhile (count > 0) {\n\t\t\tif (t_byte > 0) {\n\t\t\t\tmask = (mask << 8) | 0xff;\n\t\t\t\tt_byte--;\n\t\t\t} else if (byte_count > 0) {\n\t\t\t\tdata = (data << 8) + *src++;\n\t\t\t\tbyte_count--;\n\t\t\t\tmask <<= 8;\n\t\t\t} else {\n\t\t\t\tdata <<= 8;\n\t\t\t\tmask = (mask << 8) | 0xff;\n\t\t\t}\n\t\t\tcount--;\n\t\t}\n\n\t\tdata |= original_data & mask;\n\n\t\tret = kv_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\taddr += 4;\n\t}\n\n\twhile (byte_count >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];\n\n\t\tret = kv_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\t \n\tif (byte_count > 0) {\n\t\tdata = 0;\n\n\t\tret = kv_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toriginal_data= RREG32(SMC_IND_DATA_0);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (data << 8) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tret = kv_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}