{
  "module_name": "rv770_smc.c",
  "hash_id": "80b0b197eae29a960d3f3caea9051d654fe9b5560e5a628a269e915f4b994278",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rv770_smc.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"radeon.h\"\n#include \"rv770d.h\"\n#include \"rv770_dpm.h\"\n#include \"rv770_smc.h\"\n#include \"atom.h\"\n#include \"radeon_ucode.h\"\n\n#define FIRST_SMC_INT_VECT_REG 0xFFD8\n#define FIRST_INT_VECT_S19     0xFFC0\n\nstatic const u8 rv770_smc_int_vectors[] = {\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x0C, 0xD7,\n\t0x08, 0x2B, 0x08, 0x10,\n\t0x03, 0x51, 0x03, 0x51,\n\t0x03, 0x51, 0x03, 0x51\n};\n\nstatic const u8 rv730_smc_int_vectors[] = {\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x08, 0x15,\n\t0x08, 0x15, 0x0C, 0xBB,\n\t0x08, 0x30, 0x08, 0x15,\n\t0x03, 0x56, 0x03, 0x56,\n\t0x03, 0x56, 0x03, 0x56\n};\n\nstatic const u8 rv710_smc_int_vectors[] = {\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x08, 0x04,\n\t0x08, 0x04, 0x0C, 0xCB,\n\t0x08, 0x1F, 0x08, 0x04,\n\t0x03, 0x51, 0x03, 0x51,\n\t0x03, 0x51, 0x03, 0x51\n};\n\nstatic const u8 rv740_smc_int_vectors[] = {\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x08, 0x10,\n\t0x08, 0x10, 0x0C, 0xD7,\n\t0x08, 0x2B, 0x08, 0x10,\n\t0x03, 0x51, 0x03, 0x51,\n\t0x03, 0x51, 0x03, 0x51\n};\n\nstatic const u8 cedar_smc_int_vectors[] = {\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x11, 0x8B,\n\t0x0B, 0x20, 0x0B, 0x05,\n\t0x04, 0xF6, 0x04, 0xF6,\n\t0x04, 0xF6, 0x04, 0xF6\n};\n\nstatic const u8 redwood_smc_int_vectors[] = {\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x11, 0x8B,\n\t0x0B, 0x20, 0x0B, 0x05,\n\t0x04, 0xF6, 0x04, 0xF6,\n\t0x04, 0xF6, 0x04, 0xF6\n};\n\nstatic const u8 juniper_smc_int_vectors[] = {\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x11, 0x8B,\n\t0x0B, 0x20, 0x0B, 0x05,\n\t0x04, 0xF6, 0x04, 0xF6,\n\t0x04, 0xF6, 0x04, 0xF6\n};\n\nstatic const u8 cypress_smc_int_vectors[] = {\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x0B, 0x05,\n\t0x0B, 0x05, 0x11, 0x8B,\n\t0x0B, 0x20, 0x0B, 0x05,\n\t0x04, 0xF6, 0x04, 0xF6,\n\t0x04, 0xF6, 0x04, 0xF6\n};\n\nstatic const u8 barts_smc_int_vectors[] = {\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x12, 0xAA,\n\t0x0C, 0x2F, 0x15, 0xF6,\n\t0x15, 0xF6, 0x05, 0x0A,\n\t0x05, 0x0A, 0x05, 0x0A\n};\n\nstatic const u8 turks_smc_int_vectors[] = {\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x12, 0xAA,\n\t0x0C, 0x2F, 0x15, 0xF6,\n\t0x15, 0xF6, 0x05, 0x0A,\n\t0x05, 0x0A, 0x05, 0x0A\n};\n\nstatic const u8 caicos_smc_int_vectors[] = {\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x0C, 0x14,\n\t0x0C, 0x14, 0x12, 0xAA,\n\t0x0C, 0x2F, 0x15, 0xF6,\n\t0x15, 0xF6, 0x05, 0x0A,\n\t0x05, 0x0A, 0x05, 0x0A\n};\n\nstatic const u8 cayman_smc_int_vectors[] = {\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x12, 0x05,\n\t0x12, 0x05, 0x18, 0xEA,\n\t0x12, 0x20, 0x1C, 0x34,\n\t0x1C, 0x34, 0x08, 0x72,\n\t0x08, 0x72, 0x08, 0x72\n};\n\nstatic int rv770_set_smc_sram_address(struct radeon_device *rdev,\n\t\t\t\t      u16 smc_address, u16 limit)\n{\n\tu32 addr;\n\n\tif (smc_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_address + 3) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_address;\n\taddr |= SMC_SRAM_AUTO_INC_DIS;\n\n\tWREG32(SMC_SRAM_ADDR, addr);\n\n\treturn 0;\n}\n\nint rv770_copy_bytes_to_smc(struct radeon_device *rdev,\n\t\t\t    u16 smc_start_address, const u8 *src,\n\t\t\t    u16 byte_count, u16 limit)\n{\n\tunsigned long flags;\n\tu32 data, original_data, extra_shift;\n\tu16 addr;\n\tint ret = 0;\n\n\tif (smc_start_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_start_address + byte_count) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_start_address;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\twhile (byte_count >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tret = rv770_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_SRAM_DATA, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\t \n\tif (byte_count > 0) {\n\t\tdata = 0;\n\n\t\tret = rv770_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\toriginal_data = RREG32(SMC_SRAM_DATA);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (data << 8) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tret = rv770_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_SRAM_DATA, data);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nstatic int rv770_program_interrupt_vectors(struct radeon_device *rdev,\n\t\t\t\t\t   u32 smc_first_vector, const u8 *src,\n\t\t\t\t\t   u32 byte_count)\n{\n\tu32 tmp, i;\n\n\tif (byte_count % 4)\n\t\treturn -EINVAL;\n\n\tif (smc_first_vector < FIRST_SMC_INT_VECT_REG) {\n\t\ttmp = FIRST_SMC_INT_VECT_REG - smc_first_vector;\n\n\t\tif (tmp > byte_count)\n\t\t\treturn 0;\n\n\t\tbyte_count -= tmp;\n\t\tsrc += tmp;\n\t\tsmc_first_vector = FIRST_SMC_INT_VECT_REG;\n\t}\n\n\tfor (i = 0; i < byte_count; i += 4) {\n\t\t \n\t\ttmp = (src[i] << 24) | (src[i + 1] << 16) | (src[i + 2] << 8) | src[i + 3];\n\n\t\tWREG32(SMC_ISR_FFD8_FFDB + i, tmp);\n\t}\n\n\treturn 0;\n}\n\nvoid rv770_start_smc(struct radeon_device *rdev)\n{\n\tWREG32_P(SMC_IO, SMC_RST_N, ~SMC_RST_N);\n}\n\nvoid rv770_reset_smc(struct radeon_device *rdev)\n{\n\tWREG32_P(SMC_IO, 0, ~SMC_RST_N);\n}\n\nvoid rv770_stop_smc_clock(struct radeon_device *rdev)\n{\n\tWREG32_P(SMC_IO, 0, ~SMC_CLK_EN);\n}\n\nvoid rv770_start_smc_clock(struct radeon_device *rdev)\n{\n\tWREG32_P(SMC_IO, SMC_CLK_EN, ~SMC_CLK_EN);\n}\n\nbool rv770_is_smc_running(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(SMC_IO);\n\n\tif ((tmp & SMC_RST_N) && (tmp & SMC_CLK_EN))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nPPSMC_Result rv770_send_msg_to_smc(struct radeon_device *rdev, PPSMC_Msg msg)\n{\n\tu32 tmp;\n\tint i;\n\tPPSMC_Result result;\n\n\tif (!rv770_is_smc_running(rdev))\n\t\treturn PPSMC_Result_Failed;\n\n\tWREG32_P(SMC_MSG, HOST_SMC_MSG(msg), ~HOST_SMC_MSG_MASK);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(SMC_MSG) & HOST_SMC_RESP_MASK;\n\t\ttmp >>= HOST_SMC_RESP_SHIFT;\n\t\tif (tmp != 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\ttmp = RREG32(SMC_MSG) & HOST_SMC_RESP_MASK;\n\ttmp >>= HOST_SMC_RESP_SHIFT;\n\n\tresult = (PPSMC_Result)tmp;\n\treturn result;\n}\n\nPPSMC_Result rv770_wait_for_smc_inactive(struct radeon_device *rdev)\n{\n\tint i;\n\tPPSMC_Result result = PPSMC_Result_OK;\n\n\tif (!rv770_is_smc_running(rdev))\n\t\treturn result;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(SMC_IO) & SMC_STOP_MODE)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn result;\n}\n\nstatic void rv770_clear_smc_sram(struct radeon_device *rdev, u16 limit)\n{\n\tunsigned long flags;\n\tu16 i;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tfor (i = 0;  i < limit; i += 4) {\n\t\trv770_set_smc_sram_address(rdev, i, limit);\n\t\tWREG32(SMC_SRAM_DATA, 0);\n\t}\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n}\n\nint rv770_load_smc_ucode(struct radeon_device *rdev,\n\t\t\t u16 limit)\n{\n\tint ret;\n\tconst u8 *int_vect;\n\tu16 int_vect_start_address;\n\tu16 int_vect_size;\n\tconst u8 *ucode_data;\n\tu16 ucode_start_address;\n\tu16 ucode_size;\n\n\tif (!rdev->smc_fw)\n\t\treturn -EINVAL;\n\n\trv770_clear_smc_sram(rdev, limit);\n\n\tswitch (rdev->family) {\n\tcase CHIP_RV770:\n\t\tucode_start_address = RV770_SMC_UCODE_START;\n\t\tucode_size = RV770_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&rv770_smc_int_vectors;\n\t\tint_vect_start_address = RV770_SMC_INT_VECTOR_START;\n\t\tint_vect_size = RV770_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_RV730:\n\t\tucode_start_address = RV730_SMC_UCODE_START;\n\t\tucode_size = RV730_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&rv730_smc_int_vectors;\n\t\tint_vect_start_address = RV730_SMC_INT_VECTOR_START;\n\t\tint_vect_size = RV730_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_RV710:\n\t\tucode_start_address = RV710_SMC_UCODE_START;\n\t\tucode_size = RV710_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&rv710_smc_int_vectors;\n\t\tint_vect_start_address = RV710_SMC_INT_VECTOR_START;\n\t\tint_vect_size = RV710_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_RV740:\n\t\tucode_start_address = RV740_SMC_UCODE_START;\n\t\tucode_size = RV740_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&rv740_smc_int_vectors;\n\t\tint_vect_start_address = RV740_SMC_INT_VECTOR_START;\n\t\tint_vect_size = RV740_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_CEDAR:\n\t\tucode_start_address = CEDAR_SMC_UCODE_START;\n\t\tucode_size = CEDAR_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&cedar_smc_int_vectors;\n\t\tint_vect_start_address = CEDAR_SMC_INT_VECTOR_START;\n\t\tint_vect_size = CEDAR_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_REDWOOD:\n\t\tucode_start_address = REDWOOD_SMC_UCODE_START;\n\t\tucode_size = REDWOOD_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&redwood_smc_int_vectors;\n\t\tint_vect_start_address = REDWOOD_SMC_INT_VECTOR_START;\n\t\tint_vect_size = REDWOOD_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_JUNIPER:\n\t\tucode_start_address = JUNIPER_SMC_UCODE_START;\n\t\tucode_size = JUNIPER_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&juniper_smc_int_vectors;\n\t\tint_vect_start_address = JUNIPER_SMC_INT_VECTOR_START;\n\t\tint_vect_size = JUNIPER_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\t\tucode_start_address = CYPRESS_SMC_UCODE_START;\n\t\tucode_size = CYPRESS_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&cypress_smc_int_vectors;\n\t\tint_vect_start_address = CYPRESS_SMC_INT_VECTOR_START;\n\t\tint_vect_size = CYPRESS_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_BARTS:\n\t\tucode_start_address = BARTS_SMC_UCODE_START;\n\t\tucode_size = BARTS_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&barts_smc_int_vectors;\n\t\tint_vect_start_address = BARTS_SMC_INT_VECTOR_START;\n\t\tint_vect_size = BARTS_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_TURKS:\n\t\tucode_start_address = TURKS_SMC_UCODE_START;\n\t\tucode_size = TURKS_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&turks_smc_int_vectors;\n\t\tint_vect_start_address = TURKS_SMC_INT_VECTOR_START;\n\t\tint_vect_size = TURKS_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_CAICOS:\n\t\tucode_start_address = CAICOS_SMC_UCODE_START;\n\t\tucode_size = CAICOS_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&caicos_smc_int_vectors;\n\t\tint_vect_start_address = CAICOS_SMC_INT_VECTOR_START;\n\t\tint_vect_size = CAICOS_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tcase CHIP_CAYMAN:\n\t\tucode_start_address = CAYMAN_SMC_UCODE_START;\n\t\tucode_size = CAYMAN_SMC_UCODE_SIZE;\n\t\tint_vect = (const u8 *)&cayman_smc_int_vectors;\n\t\tint_vect_start_address = CAYMAN_SMC_INT_VECTOR_START;\n\t\tint_vect_size = CAYMAN_SMC_INT_VECTOR_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"unknown asic in smc ucode loader\\n\");\n\t\tBUG();\n\t}\n\n\t \n\tucode_data = (const u8 *)rdev->smc_fw->data;\n\tret = rv770_copy_bytes_to_smc(rdev, ucode_start_address,\n\t\t\t\t      ucode_data, ucode_size, limit);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rv770_program_interrupt_vectors(rdev, int_vect_start_address,\n\t\t\t\t\t      int_vect, int_vect_size);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint rv770_read_smc_sram_dword(struct radeon_device *rdev,\n\t\t\t      u16 smc_address, u32 *value, u16 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tret = rv770_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret == 0)\n\t\t*value = RREG32(SMC_SRAM_DATA);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nint rv770_write_smc_sram_dword(struct radeon_device *rdev,\n\t\t\t       u16 smc_address, u32 value, u16 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tret = rv770_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret == 0)\n\t\tWREG32(SMC_SRAM_DATA, value);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}