{
  "module_name": "atombios_dp.c",
  "hash_id": "a150dfae0bc3352694f60155aa8a3e2f130428e26280f899cdd280545a455030",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/atombios_dp.c",
  "human_readable_source": " \n\n#include <drm/radeon_drm.h>\n#include \"radeon.h\"\n\n#include \"atom.h\"\n#include \"atom-bits.h\"\n#include <drm/display/drm_dp_helper.h>\n\n \n#define DP_LINK_CONFIGURATION_SIZE 9\n#define DP_DPCD_SIZE DP_RECEIVER_CAP_SIZE\n\nstatic char *voltage_names[] = {\n\t\"0.4V\", \"0.6V\", \"0.8V\", \"1.2V\"\n};\nstatic char *pre_emph_names[] = {\n\t\"0dB\", \"3.5dB\", \"6dB\", \"9.5dB\"\n};\n\n \n\n \nvoid radeon_atom_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)\n{\n#ifdef __BIG_ENDIAN\n\tu32 src_tmp[5], dst_tmp[5];\n\tint i;\n\tu8 align_num_bytes = ALIGN(num_bytes, 4);\n\n\tif (to_le) {\n\t\tmemcpy(src_tmp, src, num_bytes);\n\t\tfor (i = 0; i < align_num_bytes / 4; i++)\n\t\t\tdst_tmp[i] = cpu_to_le32(src_tmp[i]);\n\t\tmemcpy(dst, dst_tmp, align_num_bytes);\n\t} else {\n\t\tmemcpy(src_tmp, src, align_num_bytes);\n\t\tfor (i = 0; i < align_num_bytes / 4; i++)\n\t\t\tdst_tmp[i] = le32_to_cpu(src_tmp[i]);\n\t\tmemcpy(dst, dst_tmp, num_bytes);\n\t}\n#else\n\tmemcpy(dst, src, num_bytes);\n#endif\n}\n\nunion aux_channel_transaction {\n\tPROCESS_AUX_CHANNEL_TRANSACTION_PS_ALLOCATION v1;\n\tPROCESS_AUX_CHANNEL_TRANSACTION_PARAMETERS_V2 v2;\n};\n\nstatic int radeon_process_aux_ch(struct radeon_i2c_chan *chan,\n\t\t\t\t u8 *send, int send_bytes,\n\t\t\t\t u8 *recv, int recv_size,\n\t\t\t\t u8 delay, u8 *ack)\n{\n\tstruct drm_device *dev = chan->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tunion aux_channel_transaction args;\n\tint index = GetIndexIntoMasterTable(COMMAND, ProcessAuxChannelTransaction);\n\tunsigned char *base;\n\tint recv_bytes;\n\tint r = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tmutex_lock(&chan->mutex);\n\tmutex_lock(&rdev->mode_info.atom_context->scratch_mutex);\n\n\tbase = (unsigned char *)(rdev->mode_info.atom_context->scratch + 1);\n\n\tradeon_atom_copy_swap(base, send, send_bytes, true);\n\n\targs.v1.lpAuxRequest = cpu_to_le16((u16)(0 + 4));\n\targs.v1.lpDataOut = cpu_to_le16((u16)(16 + 4));\n\targs.v1.ucDataOutLen = 0;\n\targs.v1.ucChannelID = chan->rec.i2c_id;\n\targs.v1.ucDelay = delay / 10;\n\tif (ASIC_IS_DCE4(rdev))\n\t\targs.v2.ucHPD_ID = chan->rec.hpd;\n\n\tatom_execute_table_scratch_unlocked(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t*ack = args.v1.ucReplyStatus;\n\n\t \n\tif (args.v1.ucReplyStatus == 1) {\n\t\tDRM_DEBUG_KMS(\"dp_aux_ch timeout\\n\");\n\t\tr = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\t \n\tif (args.v1.ucReplyStatus == 2) {\n\t\tDRM_DEBUG_KMS(\"dp_aux_ch flags not zero\\n\");\n\t\tr = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tif (args.v1.ucReplyStatus == 3) {\n\t\tDRM_DEBUG_KMS(\"dp_aux_ch error\\n\");\n\t\tr = -EIO;\n\t\tgoto done;\n\t}\n\n\trecv_bytes = args.v1.ucDataOutLen;\n\tif (recv_bytes > recv_size)\n\t\trecv_bytes = recv_size;\n\n\tif (recv && recv_size)\n\t\tradeon_atom_copy_swap(recv, base + 16, recv_bytes, false);\n\n\tr = recv_bytes;\ndone:\n\tmutex_unlock(&rdev->mode_info.atom_context->scratch_mutex);\n\tmutex_unlock(&chan->mutex);\n\n\treturn r;\n}\n\n#define BARE_ADDRESS_SIZE 3\n#define HEADER_SIZE (BARE_ADDRESS_SIZE + 1)\n\nstatic ssize_t\nradeon_dp_aux_transfer_atom(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tstruct radeon_i2c_chan *chan =\n\t\tcontainer_of(aux, struct radeon_i2c_chan, aux);\n\tint ret;\n\tu8 tx_buf[20];\n\tsize_t tx_size;\n\tu8 ack, delay = 0;\n\n\tif (WARN_ON(msg->size > 16))\n\t\treturn -E2BIG;\n\n\ttx_buf[0] = msg->address & 0xff;\n\ttx_buf[1] = (msg->address >> 8) & 0xff;\n\ttx_buf[2] = (msg->request << 4) |\n\t\t((msg->address >> 16) & 0xf);\n\ttx_buf[3] = msg->size ? (msg->size - 1) : 0;\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\tcase DP_AUX_I2C_WRITE_STATUS_UPDATE:\n\t\t \n\t\tif (WARN_ON_ONCE(msg->size > 12))\n\t\t\treturn -E2BIG;\n\t\t \n\t\ttx_size = HEADER_SIZE + msg->size;\n\t\tif (msg->size == 0)\n\t\t\ttx_buf[3] |= BARE_ADDRESS_SIZE << 4;\n\t\telse\n\t\t\ttx_buf[3] |= tx_size << 4;\n\t\tmemcpy(tx_buf + HEADER_SIZE, msg->buffer, msg->size);\n\t\tret = radeon_process_aux_ch(chan,\n\t\t\t\t\t    tx_buf, tx_size, NULL, 0, delay, &ack);\n\t\tif (ret >= 0)\n\t\t\t \n\t\t\tret = msg->size;\n\t\tbreak;\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\t \n\t\ttx_size = HEADER_SIZE;\n\t\tif (msg->size == 0)\n\t\t\ttx_buf[3] |= BARE_ADDRESS_SIZE << 4;\n\t\telse\n\t\t\ttx_buf[3] |= tx_size << 4;\n\t\tret = radeon_process_aux_ch(chan,\n\t\t\t\t\t    tx_buf, tx_size, msg->buffer, msg->size, delay, &ack);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret >= 0)\n\t\tmsg->reply = ack >> 4;\n\n\treturn ret;\n}\n\nvoid radeon_dp_aux_init(struct radeon_connector *radeon_connector)\n{\n\tstruct drm_device *dev = radeon_connector->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint ret;\n\n\tradeon_connector->ddc_bus->rec.hpd = radeon_connector->hpd.hpd;\n\tradeon_connector->ddc_bus->aux.dev = radeon_connector->base.kdev;\n\tradeon_connector->ddc_bus->aux.drm_dev = radeon_connector->base.dev;\n\tif (ASIC_IS_DCE5(rdev)) {\n\t\tif (radeon_auxch)\n\t\t\tradeon_connector->ddc_bus->aux.transfer = radeon_dp_aux_transfer_native;\n\t\telse\n\t\t\tradeon_connector->ddc_bus->aux.transfer = radeon_dp_aux_transfer_atom;\n\t} else {\n\t\tradeon_connector->ddc_bus->aux.transfer = radeon_dp_aux_transfer_atom;\n\t}\n\n\tret = drm_dp_aux_register(&radeon_connector->ddc_bus->aux);\n\tif (!ret)\n\t\tradeon_connector->ddc_bus->has_aux = true;\n\n\tWARN(ret, \"drm_dp_aux_register() failed with error %d\\n\", ret);\n}\n\n \n\n#define DP_VOLTAGE_MAX         DP_TRAIN_VOLTAGE_SWING_LEVEL_3\n#define DP_PRE_EMPHASIS_MAX    DP_TRAIN_PRE_EMPH_LEVEL_3\n\nstatic void dp_get_adjust_train(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\tint lane_count,\n\t\t\t\tu8 train_set[4])\n{\n\tu8 v = 0;\n\tu8 p = 0;\n\tint lane;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tu8 this_v = drm_dp_get_adjust_request_voltage(link_status, lane);\n\t\tu8 this_p = drm_dp_get_adjust_request_pre_emphasis(link_status, lane);\n\n\t\tDRM_DEBUG_KMS(\"requested signal parameters: lane %d voltage %s pre_emph %s\\n\",\n\t\t\t  lane,\n\t\t\t  voltage_names[this_v >> DP_TRAIN_VOLTAGE_SWING_SHIFT],\n\t\t\t  pre_emph_names[this_p >> DP_TRAIN_PRE_EMPHASIS_SHIFT]);\n\n\t\tif (this_v > v)\n\t\t\tv = this_v;\n\t\tif (this_p > p)\n\t\t\tp = this_p;\n\t}\n\n\tif (v >= DP_VOLTAGE_MAX)\n\t\tv |= DP_TRAIN_MAX_SWING_REACHED;\n\n\tif (p >= DP_PRE_EMPHASIS_MAX)\n\t\tp |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\n\n\tDRM_DEBUG_KMS(\"using signal parameters: voltage %s pre_emph %s\\n\",\n\t\t  voltage_names[(v & DP_TRAIN_VOLTAGE_SWING_MASK) >> DP_TRAIN_VOLTAGE_SWING_SHIFT],\n\t\t  pre_emph_names[(p & DP_TRAIN_PRE_EMPHASIS_MASK) >> DP_TRAIN_PRE_EMPHASIS_SHIFT]);\n\n\tfor (lane = 0; lane < 4; lane++)\n\t\ttrain_set[lane] = v | p;\n}\n\n \n \nstatic int convert_bpc_to_bpp(int bpc)\n{\n\tif (bpc == 0)\n\t\treturn 24;\n\telse\n\t\treturn bpc * 3;\n}\n\n \n\nstatic int radeon_dp_get_dp_link_config(struct drm_connector *connector,\n\t\t\t\t\tconst u8 dpcd[DP_DPCD_SIZE],\n\t\t\t\t\tunsigned pix_clock,\n\t\t\t\t\tunsigned *dp_lanes, unsigned *dp_rate)\n{\n\tint bpp = convert_bpc_to_bpp(radeon_get_monitor_bpc(connector));\n\tstatic const unsigned link_rates[3] = { 162000, 270000, 540000 };\n\tunsigned max_link_rate = drm_dp_max_link_rate(dpcd);\n\tunsigned max_lane_num = drm_dp_max_lane_count(dpcd);\n\tunsigned lane_num, i, max_pix_clock;\n\n\tif (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) ==\n\t    ENCODER_OBJECT_ID_NUTMEG) {\n\t\tfor (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {\n\t\t\tmax_pix_clock = (lane_num * 270000 * 8) / bpp;\n\t\t\tif (max_pix_clock >= pix_clock) {\n\t\t\t\t*dp_lanes = lane_num;\n\t\t\t\t*dp_rate = 270000;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(link_rates) && link_rates[i] <= max_link_rate; i++) {\n\t\t\tfor (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {\n\t\t\t\tmax_pix_clock = (lane_num * link_rates[i] * 8) / bpp;\n\t\t\t\tif (max_pix_clock >= pix_clock) {\n\t\t\t\t\t*dp_lanes = lane_num;\n\t\t\t\t\t*dp_rate = link_rates[i];\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u8 radeon_dp_encoder_service(struct radeon_device *rdev,\n\t\t\t\t    int action, int dp_clock,\n\t\t\t\t    u8 ucconfig, u8 lane_num)\n{\n\tDP_ENCODER_SERVICE_PARAMETERS args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DPEncoderService);\n\n\tmemset(&args, 0, sizeof(args));\n\targs.ucLinkClock = dp_clock / 10;\n\targs.ucConfig = ucconfig;\n\targs.ucAction = action;\n\targs.ucLaneNum = lane_num;\n\targs.ucStatus = 0;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\treturn args.ucStatus;\n}\n\nu8 radeon_dp_getsinktype(struct radeon_connector *radeon_connector)\n{\n\tstruct drm_device *dev = radeon_connector->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\treturn radeon_dp_encoder_service(rdev, ATOM_DP_ACTION_GET_SINK_TYPE, 0,\n\t\t\t\t\t radeon_connector->ddc_bus->rec.i2c_id, 0);\n}\n\nstatic void radeon_dp_probe_oui(struct radeon_connector *radeon_connector)\n{\n\tstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\n\tu8 buf[3];\n\n\tif (!(dig_connector->dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_OUI_SUPPORT))\n\t\treturn;\n\n\tif (drm_dp_dpcd_read(&radeon_connector->ddc_bus->aux, DP_SINK_OUI, buf, 3) == 3)\n\t\tDRM_DEBUG_KMS(\"Sink OUI: %02hx%02hx%02hx\\n\",\n\t\t\t      buf[0], buf[1], buf[2]);\n\n\tif (drm_dp_dpcd_read(&radeon_connector->ddc_bus->aux, DP_BRANCH_OUI, buf, 3) == 3)\n\t\tDRM_DEBUG_KMS(\"Branch OUI: %02hx%02hx%02hx\\n\",\n\t\t\t      buf[0], buf[1], buf[2]);\n}\n\nbool radeon_dp_getdpcd(struct radeon_connector *radeon_connector)\n{\n\tstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\n\tu8 msg[DP_DPCD_SIZE];\n\tint ret;\n\n\tret = drm_dp_dpcd_read(&radeon_connector->ddc_bus->aux, DP_DPCD_REV, msg,\n\t\t\t       DP_DPCD_SIZE);\n\tif (ret == DP_DPCD_SIZE) {\n\t\tmemcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE);\n\n\t\tDRM_DEBUG_KMS(\"DPCD: %*ph\\n\", (int)sizeof(dig_connector->dpcd),\n\t\t\t      dig_connector->dpcd);\n\n\t\tradeon_dp_probe_oui(radeon_connector);\n\n\t\treturn true;\n\t}\n\n\tdig_connector->dpcd[0] = 0;\n\treturn false;\n}\n\nint radeon_dp_get_panel_mode(struct drm_encoder *encoder,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tint panel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\n\tu16 dp_bridge = radeon_connector_encoder_get_dp_bridge_encoder_id(connector);\n\tu8 tmp;\n\n\tif (!ASIC_IS_DCE4(rdev))\n\t\treturn panel_mode;\n\n\tif (!radeon_connector->con_priv)\n\t\treturn panel_mode;\n\n\tif (dp_bridge != ENCODER_OBJECT_ID_NONE) {\n\t\t \n\t\tif (drm_dp_dpcd_readb(&radeon_connector->ddc_bus->aux,\n\t\t\t\t      DP_EDP_CONFIGURATION_CAP, &tmp) == 1) {\n\t\t\tif (tmp & 1)\n\t\t\t\tpanel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;\n\t\t\telse if ((dp_bridge == ENCODER_OBJECT_ID_NUTMEG) ||\n\t\t\t\t (dp_bridge == ENCODER_OBJECT_ID_TRAVIS))\n\t\t\t\tpanel_mode = DP_PANEL_MODE_INTERNAL_DP1_MODE;\n\t\t\telse\n\t\t\t\tpanel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\n\t\t}\n\t} else if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t \n\t\tif (drm_dp_dpcd_readb(&radeon_connector->ddc_bus->aux,\n\t\t\t\t      DP_EDP_CONFIGURATION_CAP, &tmp) == 1) {\n\t\t\tif (tmp & 1)\n\t\t\t\tpanel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;\n\t\t}\n\t}\n\n\treturn panel_mode;\n}\n\nvoid radeon_dp_set_link_config(struct drm_connector *connector,\n\t\t\t       const struct drm_display_mode *mode)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *dig_connector;\n\tint ret;\n\n\tif (!radeon_connector->con_priv)\n\t\treturn;\n\tdig_connector = radeon_connector->con_priv;\n\n\tif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t    (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\n\t\tret = radeon_dp_get_dp_link_config(connector, dig_connector->dpcd,\n\t\t\t\t\t\t   mode->clock,\n\t\t\t\t\t\t   &dig_connector->dp_lane_count,\n\t\t\t\t\t\t   &dig_connector->dp_clock);\n\t\tif (ret) {\n\t\t\tdig_connector->dp_clock = 0;\n\t\t\tdig_connector->dp_lane_count = 0;\n\t\t}\n\t}\n}\n\nint radeon_dp_mode_valid_helper(struct drm_connector *connector,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *dig_connector;\n\tunsigned dp_clock, dp_lanes;\n\tint ret;\n\n\tif ((mode->clock > 340000) &&\n\t    (!radeon_connector_is_dp12_capable(connector)))\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (!radeon_connector->con_priv)\n\t\treturn MODE_CLOCK_HIGH;\n\tdig_connector = radeon_connector->con_priv;\n\n\tret = radeon_dp_get_dp_link_config(connector, dig_connector->dpcd,\n\t\t\t\t\t   mode->clock,\n\t\t\t\t\t   &dp_lanes,\n\t\t\t\t\t   &dp_clock);\n\tif (ret)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif ((dp_clock == 540000) &&\n\t    (!radeon_connector_is_dp12_capable(connector)))\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nbool radeon_dp_needs_link_train(struct radeon_connector *radeon_connector)\n{\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tstruct radeon_connector_atom_dig *dig = radeon_connector->con_priv;\n\n\tif (drm_dp_dpcd_read_link_status(&radeon_connector->ddc_bus->aux, link_status)\n\t    <= 0)\n\t\treturn false;\n\tif (drm_dp_channel_eq_ok(link_status, dig->dp_lane_count))\n\t\treturn false;\n\treturn true;\n}\n\nvoid radeon_dp_set_rx_power_state(struct drm_connector *connector,\n\t\t\t\t  u8 power_state)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *dig_connector;\n\n\tif (!radeon_connector->con_priv)\n\t\treturn;\n\n\tdig_connector = radeon_connector->con_priv;\n\n\t \n\tif (dig_connector->dpcd[0] >= 0x11) {\n\t\tdrm_dp_dpcd_writeb(&radeon_connector->ddc_bus->aux,\n\t\t\t\t   DP_SET_POWER, power_state);\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\n\nstruct radeon_dp_link_train_info {\n\tstruct radeon_device *rdev;\n\tstruct drm_encoder *encoder;\n\tstruct drm_connector *connector;\n\tint enc_id;\n\tint dp_clock;\n\tint dp_lane_count;\n\tbool tp3_supported;\n\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\tu8 train_set[4];\n\tu8 link_status[DP_LINK_STATUS_SIZE];\n\tu8 tries;\n\tbool use_dpencoder;\n\tstruct drm_dp_aux *aux;\n};\n\nstatic void radeon_dp_update_vs_emph(struct radeon_dp_link_train_info *dp_info)\n{\n\t \n\tatombios_dig_transmitter_setup(dp_info->encoder,\n\t\t\t\t       ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH,\n\t\t\t\t       0, dp_info->train_set[0]);  \n\n\t \n\tdrm_dp_dpcd_write(dp_info->aux, DP_TRAINING_LANE0_SET,\n\t\t\t  dp_info->train_set, dp_info->dp_lane_count);\n}\n\nstatic void radeon_dp_set_tp(struct radeon_dp_link_train_info *dp_info, int tp)\n{\n\tint rtp = 0;\n\n\t \n\tif (ASIC_IS_DCE4(dp_info->rdev) || !dp_info->use_dpencoder) {\n\t\tswitch (tp) {\n\t\tcase DP_TRAINING_PATTERN_1:\n\t\t\trtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN1;\n\t\t\tbreak;\n\t\tcase DP_TRAINING_PATTERN_2:\n\t\t\trtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN2;\n\t\t\tbreak;\n\t\tcase DP_TRAINING_PATTERN_3:\n\t\t\trtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN3;\n\t\t\tbreak;\n\t\t}\n\t\tatombios_dig_encoder_setup(dp_info->encoder, rtp, 0);\n\t} else {\n\t\tswitch (tp) {\n\t\tcase DP_TRAINING_PATTERN_1:\n\t\t\trtp = 0;\n\t\t\tbreak;\n\t\tcase DP_TRAINING_PATTERN_2:\n\t\t\trtp = 1;\n\t\t\tbreak;\n\t\t}\n\t\tradeon_dp_encoder_service(dp_info->rdev, ATOM_DP_ACTION_TRAINING_PATTERN_SEL,\n\t\t\t\t\t  dp_info->dp_clock, dp_info->enc_id, rtp);\n\t}\n\n\t \n\tdrm_dp_dpcd_writeb(dp_info->aux, DP_TRAINING_PATTERN_SET, tp);\n}\n\nstatic int radeon_dp_link_train_init(struct radeon_dp_link_train_info *dp_info)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(dp_info->encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tu8 tmp;\n\n\t \n\tradeon_dp_set_rx_power_state(dp_info->connector, DP_SET_POWER_D0);\n\n\t \n\tif (dp_info->dpcd[3] & 0x1)\n\t\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t\t   DP_DOWNSPREAD_CTRL, DP_SPREAD_AMP_0_5);\n\telse\n\t\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t\t   DP_DOWNSPREAD_CTRL, 0);\n\n\tif (dig->panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)\n\t\tdrm_dp_dpcd_writeb(dp_info->aux, DP_EDP_CONFIGURATION_SET, 1);\n\n\t \n\ttmp = dp_info->dp_lane_count;\n\tif (drm_dp_enhanced_frame_cap(dp_info->dpcd))\n\t\ttmp |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\n\tdrm_dp_dpcd_writeb(dp_info->aux, DP_LANE_COUNT_SET, tmp);\n\n\t \n\ttmp = drm_dp_link_rate_to_bw_code(dp_info->dp_clock);\n\tdrm_dp_dpcd_writeb(dp_info->aux, DP_LINK_BW_SET, tmp);\n\n\t \n\tif (ASIC_IS_DCE4(dp_info->rdev) || !dp_info->use_dpencoder)\n\t\tatombios_dig_encoder_setup(dp_info->encoder,\n\t\t\t\t\t   ATOM_ENCODER_CMD_DP_LINK_TRAINING_START, 0);\n\telse\n\t\tradeon_dp_encoder_service(dp_info->rdev, ATOM_DP_ACTION_TRAINING_START,\n\t\t\t\t\t  dp_info->dp_clock, dp_info->enc_id, 0);\n\n\t \n\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t   DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\n\treturn 0;\n}\n\nstatic int radeon_dp_link_train_finish(struct radeon_dp_link_train_info *dp_info)\n{\n\tudelay(400);\n\n\t \n\tdrm_dp_dpcd_writeb(dp_info->aux,\n\t\t\t   DP_TRAINING_PATTERN_SET,\n\t\t\t   DP_TRAINING_PATTERN_DISABLE);\n\n\t \n\tif (ASIC_IS_DCE4(dp_info->rdev) || !dp_info->use_dpencoder)\n\t\tatombios_dig_encoder_setup(dp_info->encoder,\n\t\t\t\t\t   ATOM_ENCODER_CMD_DP_LINK_TRAINING_COMPLETE, 0);\n\telse\n\t\tradeon_dp_encoder_service(dp_info->rdev, ATOM_DP_ACTION_TRAINING_COMPLETE,\n\t\t\t\t\t  dp_info->dp_clock, dp_info->enc_id, 0);\n\n\treturn 0;\n}\n\nstatic int radeon_dp_link_train_cr(struct radeon_dp_link_train_info *dp_info)\n{\n\tbool clock_recovery;\n \tu8 voltage;\n\tint i;\n\n\tradeon_dp_set_tp(dp_info, DP_TRAINING_PATTERN_1);\n\tmemset(dp_info->train_set, 0, 4);\n\tradeon_dp_update_vs_emph(dp_info);\n\n\tudelay(400);\n\n\t \n\tclock_recovery = false;\n\tdp_info->tries = 0;\n\tvoltage = 0xff;\n\twhile (1) {\n\t\tdrm_dp_link_train_clock_recovery_delay(dp_info->aux, dp_info->dpcd);\n\n\t\tif (drm_dp_dpcd_read_link_status(dp_info->aux,\n\t\t\t\t\t\t dp_info->link_status) <= 0) {\n\t\t\tDRM_ERROR(\"displayport link status failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (drm_dp_clock_recovery_ok(dp_info->link_status, dp_info->dp_lane_count)) {\n\t\t\tclock_recovery = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; i < dp_info->dp_lane_count; i++) {\n\t\t\tif ((dp_info->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == dp_info->dp_lane_count) {\n\t\t\tDRM_ERROR(\"clock recovery reached max voltage\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {\n\t\t\t++dp_info->tries;\n\t\t\tif (dp_info->tries == 5) {\n\t\t\t\tDRM_ERROR(\"clock recovery tried 5 times\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tdp_info->tries = 0;\n\n\t\tvoltage = dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\n\n\t\t \n\t\tdp_get_adjust_train(dp_info->link_status, dp_info->dp_lane_count, dp_info->train_set);\n\n\t\tradeon_dp_update_vs_emph(dp_info);\n\t}\n\tif (!clock_recovery) {\n\t\tDRM_ERROR(\"clock recovery failed\\n\");\n\t\treturn -1;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"clock recovery at voltage %d pre-emphasis %d\\n\",\n\t\t\t  dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK,\n\t\t\t  (dp_info->train_set[0] & DP_TRAIN_PRE_EMPHASIS_MASK) >>\n\t\t\t  DP_TRAIN_PRE_EMPHASIS_SHIFT);\n\t\treturn 0;\n\t}\n}\n\nstatic int radeon_dp_link_train_ce(struct radeon_dp_link_train_info *dp_info)\n{\n\tbool channel_eq;\n\n\tif (dp_info->tp3_supported)\n\t\tradeon_dp_set_tp(dp_info, DP_TRAINING_PATTERN_3);\n\telse\n\t\tradeon_dp_set_tp(dp_info, DP_TRAINING_PATTERN_2);\n\n\t \n\tdp_info->tries = 0;\n\tchannel_eq = false;\n\twhile (1) {\n\t\tdrm_dp_link_train_channel_eq_delay(dp_info->aux, dp_info->dpcd);\n\n\t\tif (drm_dp_dpcd_read_link_status(dp_info->aux,\n\t\t\t\t\t\t dp_info->link_status) <= 0) {\n\t\t\tDRM_ERROR(\"displayport link status failed\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (drm_dp_channel_eq_ok(dp_info->link_status, dp_info->dp_lane_count)) {\n\t\t\tchannel_eq = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dp_info->tries > 5) {\n\t\t\tDRM_ERROR(\"channel eq failed: 5 tries\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tdp_get_adjust_train(dp_info->link_status, dp_info->dp_lane_count, dp_info->train_set);\n\n\t\tradeon_dp_update_vs_emph(dp_info);\n\t\tdp_info->tries++;\n\t}\n\n\tif (!channel_eq) {\n\t\tDRM_ERROR(\"channel eq failed\\n\");\n\t\treturn -1;\n\t} else {\n\t\tDRM_DEBUG_KMS(\"channel eq at voltage %d pre-emphasis %d\\n\",\n\t\t\t  dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK,\n\t\t\t  (dp_info->train_set[0] & DP_TRAIN_PRE_EMPHASIS_MASK)\n\t\t\t  >> DP_TRAIN_PRE_EMPHASIS_SHIFT);\n\t\treturn 0;\n\t}\n}\n\nvoid radeon_dp_link_train(struct drm_encoder *encoder,\n\t\t\t  struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig;\n\tstruct radeon_connector *radeon_connector;\n\tstruct radeon_connector_atom_dig *dig_connector;\n\tstruct radeon_dp_link_train_info dp_info;\n\tint index;\n\tu8 tmp, frev, crev;\n\n\tif (!radeon_encoder->enc_priv)\n\t\treturn;\n\tdig = radeon_encoder->enc_priv;\n\n\tradeon_connector = to_radeon_connector(connector);\n\tif (!radeon_connector->con_priv)\n\t\treturn;\n\tdig_connector = radeon_connector->con_priv;\n\n\tif ((dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT) &&\n\t    (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_eDP))\n\t\treturn;\n\n\t \n\tdp_info.use_dpencoder = true;\n\tindex = GetIndexIntoMasterTable(COMMAND, DPEncoderService);\n\tif (atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev)) {\n\t\tif (crev > 1)\n\t\t\tdp_info.use_dpencoder = false;\n\t}\n\n\tdp_info.enc_id = 0;\n\tif (dig->dig_encoder)\n\t\tdp_info.enc_id |= ATOM_DP_CONFIG_DIG2_ENCODER;\n\telse\n\t\tdp_info.enc_id |= ATOM_DP_CONFIG_DIG1_ENCODER;\n\tif (dig->linkb)\n\t\tdp_info.enc_id |= ATOM_DP_CONFIG_LINK_B;\n\telse\n\t\tdp_info.enc_id |= ATOM_DP_CONFIG_LINK_A;\n\n\tif (drm_dp_dpcd_readb(&radeon_connector->ddc_bus->aux, DP_MAX_LANE_COUNT, &tmp)\n\t    == 1) {\n\t\tif (ASIC_IS_DCE5(rdev) && (tmp & DP_TPS3_SUPPORTED))\n\t\t\tdp_info.tp3_supported = true;\n\t\telse\n\t\t\tdp_info.tp3_supported = false;\n\t} else {\n\t\tdp_info.tp3_supported = false;\n\t}\n\n\tmemcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE);\n\tdp_info.rdev = rdev;\n\tdp_info.encoder = encoder;\n\tdp_info.connector = connector;\n\tdp_info.dp_lane_count = dig_connector->dp_lane_count;\n\tdp_info.dp_clock = dig_connector->dp_clock;\n\tdp_info.aux = &radeon_connector->ddc_bus->aux;\n\n\tif (radeon_dp_link_train_init(&dp_info))\n\t\tgoto done;\n\tif (radeon_dp_link_train_cr(&dp_info))\n\t\tgoto done;\n\tif (radeon_dp_link_train_ce(&dp_info))\n\t\tgoto done;\ndone:\n\tif (radeon_dp_link_train_finish(&dp_info))\n\t\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}