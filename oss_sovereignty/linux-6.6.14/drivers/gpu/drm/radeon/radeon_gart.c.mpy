{
  "module_name": "radeon_gart.c",
  "hash_id": "9ba4597cab91c7aec271f803bb2f01b2eda21ec2af942ee6f16b2eb0f786cc2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_gart.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include <drm/radeon_drm.h>\n#ifdef CONFIG_X86\n#include <asm/set_memory.h>\n#endif\n#include \"radeon.h\"\n\n \n\n \n \nint radeon_gart_table_ram_alloc(struct radeon_device *rdev)\n{\n\tvoid *ptr;\n\n\tptr = dma_alloc_coherent(&rdev->pdev->dev, rdev->gart.table_size,\n\t\t\t\t &rdev->gart.table_addr, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_X86\n\tif (rdev->family == CHIP_RS400 || rdev->family == CHIP_RS480 ||\n\t    rdev->family == CHIP_RS690 || rdev->family == CHIP_RS740) {\n\t\tset_memory_uc((unsigned long)ptr,\n\t\t\t      rdev->gart.table_size >> PAGE_SHIFT);\n\t}\n#endif\n\trdev->gart.ptr = ptr;\n\treturn 0;\n}\n\n \nvoid radeon_gart_table_ram_free(struct radeon_device *rdev)\n{\n\tif (!rdev->gart.ptr)\n\t\treturn;\n\n#ifdef CONFIG_X86\n\tif (rdev->family == CHIP_RS400 || rdev->family == CHIP_RS480 ||\n\t    rdev->family == CHIP_RS690 || rdev->family == CHIP_RS740) {\n\t\tset_memory_wb((unsigned long)rdev->gart.ptr,\n\t\t\t      rdev->gart.table_size >> PAGE_SHIFT);\n\t}\n#endif\n\tdma_free_coherent(&rdev->pdev->dev, rdev->gart.table_size,\n\t\t\t  (void *)rdev->gart.ptr, rdev->gart.table_addr);\n\trdev->gart.ptr = NULL;\n\trdev->gart.table_addr = 0;\n}\n\n \nint radeon_gart_table_vram_alloc(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tr = radeon_bo_create(rdev, rdev->gart.table_size,\n\t\t\t\t     PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t     0, NULL, NULL, &rdev->gart.robj);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nint radeon_gart_table_vram_pin(struct radeon_device *rdev)\n{\n\tuint64_t gpu_addr;\n\tint r;\n\n\tr = radeon_bo_reserve(rdev->gart.robj, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\tr = radeon_bo_pin(rdev->gart.robj,\n\t\t\t\tRADEON_GEM_DOMAIN_VRAM, &gpu_addr);\n\tif (r) {\n\t\tradeon_bo_unreserve(rdev->gart.robj);\n\t\treturn r;\n\t}\n\tr = radeon_bo_kmap(rdev->gart.robj, &rdev->gart.ptr);\n\tif (r)\n\t\tradeon_bo_unpin(rdev->gart.robj);\n\tradeon_bo_unreserve(rdev->gart.robj);\n\trdev->gart.table_addr = gpu_addr;\n\n\tif (!r) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < rdev->gart.num_gpu_pages; i++)\n\t\t\tradeon_gart_set_page(rdev, i, rdev->gart.pages_entry[i]);\n\t\tmb();\n\t\tradeon_gart_tlb_flush(rdev);\n\t}\n\n\treturn r;\n}\n\n \nvoid radeon_gart_table_vram_unpin(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->gart.robj)\n\t\treturn;\n\n\tr = radeon_bo_reserve(rdev->gart.robj, false);\n\tif (likely(r == 0)) {\n\t\tradeon_bo_kunmap(rdev->gart.robj);\n\t\tradeon_bo_unpin(rdev->gart.robj);\n\t\tradeon_bo_unreserve(rdev->gart.robj);\n\t\trdev->gart.ptr = NULL;\n\t}\n}\n\n \nvoid radeon_gart_table_vram_free(struct radeon_device *rdev)\n{\n\tif (!rdev->gart.robj)\n\t\treturn;\n\n\tradeon_bo_unref(&rdev->gart.robj);\n}\n\n \n \nvoid radeon_gart_unbind(struct radeon_device *rdev, unsigned int offset,\n\t\t\tint pages)\n{\n\tunsigned int t, p;\n\tint i, j;\n\n\tif (!rdev->gart.ready) {\n\t\tWARN(1, \"trying to unbind memory from uninitialized GART !\\n\");\n\t\treturn;\n\t}\n\tt = offset / RADEON_GPU_PAGE_SIZE;\n\tp = t / (PAGE_SIZE / RADEON_GPU_PAGE_SIZE);\n\tfor (i = 0; i < pages; i++, p++) {\n\t\tif (rdev->gart.pages[p]) {\n\t\t\trdev->gart.pages[p] = NULL;\n\t\t\tfor (j = 0; j < (PAGE_SIZE / RADEON_GPU_PAGE_SIZE); j++, t++) {\n\t\t\t\trdev->gart.pages_entry[t] = rdev->dummy_page.entry;\n\t\t\t\tif (rdev->gart.ptr) {\n\t\t\t\t\tradeon_gart_set_page(rdev, t,\n\t\t\t\t\t\t\t     rdev->dummy_page.entry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (rdev->gart.ptr) {\n\t\tmb();\n\t\tradeon_gart_tlb_flush(rdev);\n\t}\n}\n\n \nint radeon_gart_bind(struct radeon_device *rdev, unsigned int offset,\n\t\t     int pages, struct page **pagelist, dma_addr_t *dma_addr,\n\t\t     uint32_t flags)\n{\n\tunsigned int t, p;\n\tuint64_t page_base, page_entry;\n\tint i, j;\n\n\tif (!rdev->gart.ready) {\n\t\tWARN(1, \"trying to bind memory to uninitialized GART !\\n\");\n\t\treturn -EINVAL;\n\t}\n\tt = offset / RADEON_GPU_PAGE_SIZE;\n\tp = t / (PAGE_SIZE / RADEON_GPU_PAGE_SIZE);\n\n\tfor (i = 0; i < pages; i++, p++) {\n\t\trdev->gart.pages[p] = pagelist ? pagelist[i] :\n\t\t\trdev->dummy_page.page;\n\t\tpage_base = dma_addr[i];\n\t\tfor (j = 0; j < (PAGE_SIZE / RADEON_GPU_PAGE_SIZE); j++, t++) {\n\t\t\tpage_entry = radeon_gart_get_page_entry(page_base, flags);\n\t\t\trdev->gart.pages_entry[t] = page_entry;\n\t\t\tif (rdev->gart.ptr)\n\t\t\t\tradeon_gart_set_page(rdev, t, page_entry);\n\n\t\t\tpage_base += RADEON_GPU_PAGE_SIZE;\n\t\t}\n\t}\n\tif (rdev->gart.ptr) {\n\t\tmb();\n\t\tradeon_gart_tlb_flush(rdev);\n\t}\n\treturn 0;\n}\n\n \nint radeon_gart_init(struct radeon_device *rdev)\n{\n\tint r, i;\n\n\tif (rdev->gart.pages)\n\t\treturn 0;\n\n\t \n\tif (PAGE_SIZE < RADEON_GPU_PAGE_SIZE) {\n\t\tDRM_ERROR(\"Page size is smaller than GPU page size!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_dummy_page_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\trdev->gart.num_cpu_pages = rdev->mc.gtt_size / PAGE_SIZE;\n\trdev->gart.num_gpu_pages = rdev->mc.gtt_size / RADEON_GPU_PAGE_SIZE;\n\tDRM_INFO(\"GART: num cpu pages %u, num gpu pages %u\\n\",\n\t\t rdev->gart.num_cpu_pages, rdev->gart.num_gpu_pages);\n\t \n\trdev->gart.pages = vzalloc(array_size(sizeof(void *),\n\t\t\t\t   rdev->gart.num_cpu_pages));\n\tif (rdev->gart.pages == NULL) {\n\t\tradeon_gart_fini(rdev);\n\t\treturn -ENOMEM;\n\t}\n\trdev->gart.pages_entry = vmalloc(array_size(sizeof(uint64_t),\n\t\t\t\t\t\t    rdev->gart.num_gpu_pages));\n\tif (rdev->gart.pages_entry == NULL) {\n\t\tradeon_gart_fini(rdev);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tfor (i = 0; i < rdev->gart.num_gpu_pages; i++)\n\t\trdev->gart.pages_entry[i] = rdev->dummy_page.entry;\n\treturn 0;\n}\n\n \nvoid radeon_gart_fini(struct radeon_device *rdev)\n{\n\tif (rdev->gart.ready) {\n\t\t \n\t\tradeon_gart_unbind(rdev, 0, rdev->gart.num_cpu_pages);\n\t}\n\trdev->gart.ready = false;\n\tvfree(rdev->gart.pages);\n\tvfree(rdev->gart.pages_entry);\n\trdev->gart.pages = NULL;\n\trdev->gart.pages_entry = NULL;\n\n\tradeon_dummy_page_fini(rdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}