{
  "module_name": "ni_dpm.c",
  "hash_id": "ac1b880030790051ef43706e6d6bda53d5e15a79feebe954aa9e5df89bcadc62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/ni_dpm.c",
  "human_readable_source": " \n\n#include <linux/math64.h>\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n\n#include \"atom.h\"\n#include \"evergreen.h\"\n#include \"ni_dpm.h\"\n#include \"nid.h\"\n#include \"r600_dpm.h\"\n#include \"rv770.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n\n#define MC_CG_ARB_FREQ_F0           0x0a\n#define MC_CG_ARB_FREQ_F1           0x0b\n#define MC_CG_ARB_FREQ_F2           0x0c\n#define MC_CG_ARB_FREQ_F3           0x0d\n\n#define SMC_RAM_END 0xC000\n\nstatic const struct ni_cac_weights cac_weights_cayman_xt =\n{\n\t0x15,\n\t0x2,\n\t0x19,\n\t0x2,\n\t0x8,\n\t0x14,\n\t0x2,\n\t0x16,\n\t0xE,\n\t0x17,\n\t0x13,\n\t0x2B,\n\t0x10,\n\t0x7,\n\t0x5,\n\t0x5,\n\t0x5,\n\t0x2,\n\t0x3,\n\t0x9,\n\t0x10,\n\t0x10,\n\t0x2B,\n\t0xA,\n\t0x9,\n\t0x4,\n\t0xD,\n\t0xD,\n\t0x3E,\n\t0x18,\n\t0x14,\n\t0,\n\t0x3,\n\t0x3,\n\t0x5,\n\t0,\n\t0x2,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0x1CC,\n\t0,\n\t0x164,\n\t1,\n\t1,\n\t1,\n\t1,\n\t12,\n\t12,\n\t12,\n\t0x12,\n\t0x1F,\n\t132,\n\t5,\n\t7,\n\t0,\n\t{ 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0 },\n\ttrue\n};\n\nstatic const struct ni_cac_weights cac_weights_cayman_pro =\n{\n\t0x16,\n\t0x4,\n\t0x10,\n\t0x2,\n\t0xA,\n\t0x16,\n\t0x2,\n\t0x18,\n\t0x10,\n\t0x1A,\n\t0x16,\n\t0x2D,\n\t0x12,\n\t0xA,\n\t0x6,\n\t0x6,\n\t0x6,\n\t0x2,\n\t0x4,\n\t0xB,\n\t0x11,\n\t0x11,\n\t0x2D,\n\t0xC,\n\t0xC,\n\t0x7,\n\t0x10,\n\t0x10,\n\t0x3F,\n\t0x1A,\n\t0x16,\n\t0,\n\t0x7,\n\t0x4,\n\t0x6,\n\t1,\n\t0x2,\n\t0x1,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0x30,\n\t0,\n\t0x1CF,\n\t0,\n\t0x166,\n\t1,\n\t1,\n\t1,\n\t1,\n\t12,\n\t12,\n\t12,\n\t0x15,\n\t0x1F,\n\t132,\n\t6,\n\t6,\n\t0,\n\t{ 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0 },\n\ttrue\n};\n\nstatic const struct ni_cac_weights cac_weights_cayman_le =\n{\n\t0x7,\n\t0xE,\n\t0x1,\n\t0xA,\n\t0x1,\n\t0x3F,\n\t0x2,\n\t0x18,\n\t0x10,\n\t0x1A,\n\t0x1,\n\t0x3F,\n\t0x1,\n\t0xE,\n\t0x6,\n\t0x6,\n\t0x6,\n\t0x2,\n\t0x4,\n\t0x9,\n\t0x1A,\n\t0x1A,\n\t0x2C,\n\t0xA,\n\t0x11,\n\t0x8,\n\t0x19,\n\t0x19,\n\t0x1,\n\t0x1,\n\t0x1A,\n\t0,\n\t0x8,\n\t0x5,\n\t0x8,\n\t0x1,\n\t0x3,\n\t0x1,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0x38,\n\t0x38,\n\t0x239,\n\t0x3,\n\t0x18A,\n\t1,\n\t1,\n\t1,\n\t1,\n\t12,\n\t12,\n\t12,\n\t0x15,\n\t0x22,\n\t132,\n\t6,\n\t6,\n\t0,\n\t{ 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0 },\n\ttrue\n};\n\n#define NISLANDS_MGCG_SEQUENCE  300\n\nstatic const u32 cayman_cgcg_cgls_default[] =\n{\n\t0x000008f8, 0x00000010, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000011, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000012, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000013, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000014, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000015, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000016, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000017, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000018, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000019, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000001a, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000001b, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000020, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000021, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000022, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000023, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000024, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000025, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000026, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000027, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000028, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000029, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000002a, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000002b, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff\n};\n#define CAYMAN_CGCG_CGLS_DEFAULT_LENGTH sizeof(cayman_cgcg_cgls_default) / (3 * sizeof(u32))\n\nstatic const u32 cayman_cgcg_cgls_disable[] =\n{\n\t0x000008f8, 0x00000010, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000011, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000012, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000013, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000014, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000015, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000016, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000017, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000018, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000019, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x0000001a, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x0000001b, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000020, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000021, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000022, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000023, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000024, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000025, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000026, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000027, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000028, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000029, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000002a, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000002b, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x00000644, 0x000f7902, 0x001f4180,\n\t0x00000644, 0x000f3802, 0x001f4180\n};\n#define CAYMAN_CGCG_CGLS_DISABLE_LENGTH sizeof(cayman_cgcg_cgls_disable) / (3 * sizeof(u32))\n\nstatic const u32 cayman_cgcg_cgls_enable[] =\n{\n\t0x00000644, 0x000f7882, 0x001f4080,\n\t0x000008f8, 0x00000010, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000011, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000012, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000013, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000014, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000015, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000016, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000017, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000018, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000019, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000001a, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000001b, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000020, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000021, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000022, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000023, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000024, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000025, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000026, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000027, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000028, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000029, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x0000002a, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x0000002b, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff\n};\n#define CAYMAN_CGCG_CGLS_ENABLE_LENGTH  sizeof(cayman_cgcg_cgls_enable) / (3 * sizeof(u32))\n\nstatic const u32 cayman_mgcg_default[] =\n{\n\t0x0000802c, 0xc0000000, 0xffffffff,\n\t0x00003fc4, 0xc0000000, 0xffffffff,\n\t0x00005448, 0x00000100, 0xffffffff,\n\t0x000055e4, 0x00000100, 0xffffffff,\n\t0x0000160c, 0x00000100, 0xffffffff,\n\t0x00008984, 0x06000100, 0xffffffff,\n\t0x0000c164, 0x00000100, 0xffffffff,\n\t0x00008a18, 0x00000100, 0xffffffff,\n\t0x0000897c, 0x06000100, 0xffffffff,\n\t0x00008b28, 0x00000100, 0xffffffff,\n\t0x00009144, 0x00800200, 0xffffffff,\n\t0x00009a60, 0x00000100, 0xffffffff,\n\t0x00009868, 0x00000100, 0xffffffff,\n\t0x00008d58, 0x00000100, 0xffffffff,\n\t0x00009510, 0x00000100, 0xffffffff,\n\t0x0000949c, 0x00000100, 0xffffffff,\n\t0x00009654, 0x00000100, 0xffffffff,\n\t0x00009030, 0x00000100, 0xffffffff,\n\t0x00009034, 0x00000100, 0xffffffff,\n\t0x00009038, 0x00000100, 0xffffffff,\n\t0x0000903c, 0x00000100, 0xffffffff,\n\t0x00009040, 0x00000100, 0xffffffff,\n\t0x0000a200, 0x00000100, 0xffffffff,\n\t0x0000a204, 0x00000100, 0xffffffff,\n\t0x0000a208, 0x00000100, 0xffffffff,\n\t0x0000a20c, 0x00000100, 0xffffffff,\n\t0x00009744, 0x00000100, 0xffffffff,\n\t0x00003f80, 0x00000100, 0xffffffff,\n\t0x0000a210, 0x00000100, 0xffffffff,\n\t0x0000a214, 0x00000100, 0xffffffff,\n\t0x000004d8, 0x00000100, 0xffffffff,\n\t0x00009664, 0x00000100, 0xffffffff,\n\t0x00009698, 0x00000100, 0xffffffff,\n\t0x000004d4, 0x00000200, 0xffffffff,\n\t0x000004d0, 0x00000000, 0xffffffff,\n\t0x000030cc, 0x00000104, 0xffffffff,\n\t0x0000d0c0, 0x00000100, 0xffffffff,\n\t0x0000d8c0, 0x00000100, 0xffffffff,\n\t0x0000802c, 0x40000000, 0xffffffff,\n\t0x00003fc4, 0x40000000, 0xffffffff,\n\t0x0000915c, 0x00010000, 0xffffffff,\n\t0x00009160, 0x00030002, 0xffffffff,\n\t0x00009164, 0x00050004, 0xffffffff,\n\t0x00009168, 0x00070006, 0xffffffff,\n\t0x00009178, 0x00070000, 0xffffffff,\n\t0x0000917c, 0x00030002, 0xffffffff,\n\t0x00009180, 0x00050004, 0xffffffff,\n\t0x0000918c, 0x00010006, 0xffffffff,\n\t0x00009190, 0x00090008, 0xffffffff,\n\t0x00009194, 0x00070000, 0xffffffff,\n\t0x00009198, 0x00030002, 0xffffffff,\n\t0x0000919c, 0x00050004, 0xffffffff,\n\t0x000091a8, 0x00010006, 0xffffffff,\n\t0x000091ac, 0x00090008, 0xffffffff,\n\t0x000091b0, 0x00070000, 0xffffffff,\n\t0x000091b4, 0x00030002, 0xffffffff,\n\t0x000091b8, 0x00050004, 0xffffffff,\n\t0x000091c4, 0x00010006, 0xffffffff,\n\t0x000091c8, 0x00090008, 0xffffffff,\n\t0x000091cc, 0x00070000, 0xffffffff,\n\t0x000091d0, 0x00030002, 0xffffffff,\n\t0x000091d4, 0x00050004, 0xffffffff,\n\t0x000091e0, 0x00010006, 0xffffffff,\n\t0x000091e4, 0x00090008, 0xffffffff,\n\t0x000091e8, 0x00000000, 0xffffffff,\n\t0x000091ec, 0x00070000, 0xffffffff,\n\t0x000091f0, 0x00030002, 0xffffffff,\n\t0x000091f4, 0x00050004, 0xffffffff,\n\t0x00009200, 0x00010006, 0xffffffff,\n\t0x00009204, 0x00090008, 0xffffffff,\n\t0x00009208, 0x00070000, 0xffffffff,\n\t0x0000920c, 0x00030002, 0xffffffff,\n\t0x00009210, 0x00050004, 0xffffffff,\n\t0x0000921c, 0x00010006, 0xffffffff,\n\t0x00009220, 0x00090008, 0xffffffff,\n\t0x00009224, 0x00070000, 0xffffffff,\n\t0x00009228, 0x00030002, 0xffffffff,\n\t0x0000922c, 0x00050004, 0xffffffff,\n\t0x00009238, 0x00010006, 0xffffffff,\n\t0x0000923c, 0x00090008, 0xffffffff,\n\t0x00009240, 0x00070000, 0xffffffff,\n\t0x00009244, 0x00030002, 0xffffffff,\n\t0x00009248, 0x00050004, 0xffffffff,\n\t0x00009254, 0x00010006, 0xffffffff,\n\t0x00009258, 0x00090008, 0xffffffff,\n\t0x0000925c, 0x00070000, 0xffffffff,\n\t0x00009260, 0x00030002, 0xffffffff,\n\t0x00009264, 0x00050004, 0xffffffff,\n\t0x00009270, 0x00010006, 0xffffffff,\n\t0x00009274, 0x00090008, 0xffffffff,\n\t0x00009278, 0x00070000, 0xffffffff,\n\t0x0000927c, 0x00030002, 0xffffffff,\n\t0x00009280, 0x00050004, 0xffffffff,\n\t0x0000928c, 0x00010006, 0xffffffff,\n\t0x00009290, 0x00090008, 0xffffffff,\n\t0x000092a8, 0x00070000, 0xffffffff,\n\t0x000092ac, 0x00030002, 0xffffffff,\n\t0x000092b0, 0x00050004, 0xffffffff,\n\t0x000092bc, 0x00010006, 0xffffffff,\n\t0x000092c0, 0x00090008, 0xffffffff,\n\t0x000092c4, 0x00070000, 0xffffffff,\n\t0x000092c8, 0x00030002, 0xffffffff,\n\t0x000092cc, 0x00050004, 0xffffffff,\n\t0x000092d8, 0x00010006, 0xffffffff,\n\t0x000092dc, 0x00090008, 0xffffffff,\n\t0x00009294, 0x00000000, 0xffffffff,\n\t0x0000802c, 0x40010000, 0xffffffff,\n\t0x00003fc4, 0x40010000, 0xffffffff,\n\t0x0000915c, 0x00010000, 0xffffffff,\n\t0x00009160, 0x00030002, 0xffffffff,\n\t0x00009164, 0x00050004, 0xffffffff,\n\t0x00009168, 0x00070006, 0xffffffff,\n\t0x00009178, 0x00070000, 0xffffffff,\n\t0x0000917c, 0x00030002, 0xffffffff,\n\t0x00009180, 0x00050004, 0xffffffff,\n\t0x0000918c, 0x00010006, 0xffffffff,\n\t0x00009190, 0x00090008, 0xffffffff,\n\t0x00009194, 0x00070000, 0xffffffff,\n\t0x00009198, 0x00030002, 0xffffffff,\n\t0x0000919c, 0x00050004, 0xffffffff,\n\t0x000091a8, 0x00010006, 0xffffffff,\n\t0x000091ac, 0x00090008, 0xffffffff,\n\t0x000091b0, 0x00070000, 0xffffffff,\n\t0x000091b4, 0x00030002, 0xffffffff,\n\t0x000091b8, 0x00050004, 0xffffffff,\n\t0x000091c4, 0x00010006, 0xffffffff,\n\t0x000091c8, 0x00090008, 0xffffffff,\n\t0x000091cc, 0x00070000, 0xffffffff,\n\t0x000091d0, 0x00030002, 0xffffffff,\n\t0x000091d4, 0x00050004, 0xffffffff,\n\t0x000091e0, 0x00010006, 0xffffffff,\n\t0x000091e4, 0x00090008, 0xffffffff,\n\t0x000091e8, 0x00000000, 0xffffffff,\n\t0x000091ec, 0x00070000, 0xffffffff,\n\t0x000091f0, 0x00030002, 0xffffffff,\n\t0x000091f4, 0x00050004, 0xffffffff,\n\t0x00009200, 0x00010006, 0xffffffff,\n\t0x00009204, 0x00090008, 0xffffffff,\n\t0x00009208, 0x00070000, 0xffffffff,\n\t0x0000920c, 0x00030002, 0xffffffff,\n\t0x00009210, 0x00050004, 0xffffffff,\n\t0x0000921c, 0x00010006, 0xffffffff,\n\t0x00009220, 0x00090008, 0xffffffff,\n\t0x00009224, 0x00070000, 0xffffffff,\n\t0x00009228, 0x00030002, 0xffffffff,\n\t0x0000922c, 0x00050004, 0xffffffff,\n\t0x00009238, 0x00010006, 0xffffffff,\n\t0x0000923c, 0x00090008, 0xffffffff,\n\t0x00009240, 0x00070000, 0xffffffff,\n\t0x00009244, 0x00030002, 0xffffffff,\n\t0x00009248, 0x00050004, 0xffffffff,\n\t0x00009254, 0x00010006, 0xffffffff,\n\t0x00009258, 0x00090008, 0xffffffff,\n\t0x0000925c, 0x00070000, 0xffffffff,\n\t0x00009260, 0x00030002, 0xffffffff,\n\t0x00009264, 0x00050004, 0xffffffff,\n\t0x00009270, 0x00010006, 0xffffffff,\n\t0x00009274, 0x00090008, 0xffffffff,\n\t0x00009278, 0x00070000, 0xffffffff,\n\t0x0000927c, 0x00030002, 0xffffffff,\n\t0x00009280, 0x00050004, 0xffffffff,\n\t0x0000928c, 0x00010006, 0xffffffff,\n\t0x00009290, 0x00090008, 0xffffffff,\n\t0x000092a8, 0x00070000, 0xffffffff,\n\t0x000092ac, 0x00030002, 0xffffffff,\n\t0x000092b0, 0x00050004, 0xffffffff,\n\t0x000092bc, 0x00010006, 0xffffffff,\n\t0x000092c0, 0x00090008, 0xffffffff,\n\t0x000092c4, 0x00070000, 0xffffffff,\n\t0x000092c8, 0x00030002, 0xffffffff,\n\t0x000092cc, 0x00050004, 0xffffffff,\n\t0x000092d8, 0x00010006, 0xffffffff,\n\t0x000092dc, 0x00090008, 0xffffffff,\n\t0x00009294, 0x00000000, 0xffffffff,\n\t0x0000802c, 0xc0000000, 0xffffffff,\n\t0x00003fc4, 0xc0000000, 0xffffffff,\n\t0x000008f8, 0x00000010, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000011, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000012, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000013, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000014, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000015, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000016, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000017, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000018, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000019, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000001a, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x0000001b, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff\n};\n#define CAYMAN_MGCG_DEFAULT_LENGTH sizeof(cayman_mgcg_default) / (3 * sizeof(u32))\n\nstatic const u32 cayman_mgcg_disable[] =\n{\n\t0x0000802c, 0xc0000000, 0xffffffff,\n\t0x000008f8, 0x00000000, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000001, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000002, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x000008f8, 0x00000003, 0xffffffff,\n\t0x000008fc, 0xffffffff, 0xffffffff,\n\t0x00009150, 0x00600000, 0xffffffff\n};\n#define CAYMAN_MGCG_DISABLE_LENGTH   sizeof(cayman_mgcg_disable) / (3 * sizeof(u32))\n\nstatic const u32 cayman_mgcg_enable[] =\n{\n\t0x0000802c, 0xc0000000, 0xffffffff,\n\t0x000008f8, 0x00000000, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000001, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x000008f8, 0x00000002, 0xffffffff,\n\t0x000008fc, 0x00600000, 0xffffffff,\n\t0x000008f8, 0x00000003, 0xffffffff,\n\t0x000008fc, 0x00000000, 0xffffffff,\n\t0x00009150, 0x96944200, 0xffffffff\n};\n\n#define CAYMAN_MGCG_ENABLE_LENGTH   sizeof(cayman_mgcg_enable) / (3 * sizeof(u32))\n\n#define NISLANDS_SYSLS_SEQUENCE  100\n\nstatic const u32 cayman_sysls_default[] =\n{\n\t \n\t0x000055e8, 0x00000000, 0xffffffff,\n\t0x0000d0bc, 0x00000000, 0xffffffff,\n\t0x0000d8bc, 0x00000000, 0xffffffff,\n\t0x000015c0, 0x000c1401, 0xffffffff,\n\t0x0000264c, 0x000c0400, 0xffffffff,\n\t0x00002648, 0x000c0400, 0xffffffff,\n\t0x00002650, 0x000c0400, 0xffffffff,\n\t0x000020b8, 0x000c0400, 0xffffffff,\n\t0x000020bc, 0x000c0400, 0xffffffff,\n\t0x000020c0, 0x000c0c80, 0xffffffff,\n\t0x0000f4a0, 0x000000c0, 0xffffffff,\n\t0x0000f4a4, 0x00680fff, 0xffffffff,\n\t0x00002f50, 0x00000404, 0xffffffff,\n\t0x000004c8, 0x00000001, 0xffffffff,\n\t0x000064ec, 0x00000000, 0xffffffff,\n\t0x00000c7c, 0x00000000, 0xffffffff,\n\t0x00008dfc, 0x00000000, 0xffffffff\n};\n#define CAYMAN_SYSLS_DEFAULT_LENGTH sizeof(cayman_sysls_default) / (3 * sizeof(u32))\n\nstatic const u32 cayman_sysls_disable[] =\n{\n\t \n\t0x0000d0c0, 0x00000000, 0xffffffff,\n\t0x0000d8c0, 0x00000000, 0xffffffff,\n\t0x000055e8, 0x00000000, 0xffffffff,\n\t0x0000d0bc, 0x00000000, 0xffffffff,\n\t0x0000d8bc, 0x00000000, 0xffffffff,\n\t0x000015c0, 0x00041401, 0xffffffff,\n\t0x0000264c, 0x00040400, 0xffffffff,\n\t0x00002648, 0x00040400, 0xffffffff,\n\t0x00002650, 0x00040400, 0xffffffff,\n\t0x000020b8, 0x00040400, 0xffffffff,\n\t0x000020bc, 0x00040400, 0xffffffff,\n\t0x000020c0, 0x00040c80, 0xffffffff,\n\t0x0000f4a0, 0x000000c0, 0xffffffff,\n\t0x0000f4a4, 0x00680000, 0xffffffff,\n\t0x00002f50, 0x00000404, 0xffffffff,\n\t0x000004c8, 0x00000001, 0xffffffff,\n\t0x000064ec, 0x00007ffd, 0xffffffff,\n\t0x00000c7c, 0x0000ff00, 0xffffffff,\n\t0x00008dfc, 0x0000007f, 0xffffffff\n};\n#define CAYMAN_SYSLS_DISABLE_LENGTH sizeof(cayman_sysls_disable) / (3 * sizeof(u32))\n\nstatic const u32 cayman_sysls_enable[] =\n{\n\t \n\t0x000055e8, 0x00000001, 0xffffffff,\n\t0x0000d0bc, 0x00000100, 0xffffffff,\n\t0x0000d8bc, 0x00000100, 0xffffffff,\n\t0x000015c0, 0x000c1401, 0xffffffff,\n\t0x0000264c, 0x000c0400, 0xffffffff,\n\t0x00002648, 0x000c0400, 0xffffffff,\n\t0x00002650, 0x000c0400, 0xffffffff,\n\t0x000020b8, 0x000c0400, 0xffffffff,\n\t0x000020bc, 0x000c0400, 0xffffffff,\n\t0x000020c0, 0x000c0c80, 0xffffffff,\n\t0x0000f4a0, 0x000000c0, 0xffffffff,\n\t0x0000f4a4, 0x00680fff, 0xffffffff,\n\t0x00002f50, 0x00000903, 0xffffffff,\n\t0x000004c8, 0x00000000, 0xffffffff,\n\t0x000064ec, 0x00000000, 0xffffffff,\n\t0x00000c7c, 0x00000000, 0xffffffff,\n\t0x00008dfc, 0x00000000, 0xffffffff\n};\n#define CAYMAN_SYSLS_ENABLE_LENGTH sizeof(cayman_sysls_enable) / (3 * sizeof(u32))\n\nextern int ni_mc_load_microcode(struct radeon_device *rdev);\n\nstruct ni_power_info *ni_get_pi(struct radeon_device *rdev)\n{\n\tstruct ni_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstruct ni_ps *ni_get_ps(struct radeon_ps *rps)\n{\n\tstruct ni_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstatic void ni_calculate_leakage_for_v_and_t_formula(const struct ni_leakage_coeffients *coeff,\n\t\t\t\t\t\t     u16 v, s32 t,\n\t\t\t\t\t\t     u32 ileakage,\n\t\t\t\t\t\t     u32 *leakage)\n{\n\ts64 kt, kv, leakage_w, i_leakage, vddc, temperature;\n\n\ti_leakage = div64_s64(drm_int2fixp(ileakage), 1000);\n\tvddc = div64_s64(drm_int2fixp(v), 1000);\n\ttemperature = div64_s64(drm_int2fixp(t), 1000);\n\n\tkt = drm_fixp_mul(div64_s64(drm_int2fixp(coeff->at), 1000),\n\t\t\t  drm_fixp_exp(drm_fixp_mul(div64_s64(drm_int2fixp(coeff->bt), 1000), temperature)));\n\tkv = drm_fixp_mul(div64_s64(drm_int2fixp(coeff->av), 1000),\n\t\t\t  drm_fixp_exp(drm_fixp_mul(div64_s64(drm_int2fixp(coeff->bv), 1000), vddc)));\n\n\tleakage_w = drm_fixp_mul(drm_fixp_mul(drm_fixp_mul(i_leakage, kt), kv), vddc);\n\n\t*leakage = drm_fixp2int(leakage_w * 1000);\n}\n\nstatic void ni_calculate_leakage_for_v_and_t(struct radeon_device *rdev,\n\t\t\t\t\t     const struct ni_leakage_coeffients *coeff,\n\t\t\t\t\t     u16 v,\n\t\t\t\t\t     s32 t,\n\t\t\t\t\t     u32 i_leakage,\n\t\t\t\t\t     u32 *leakage)\n{\n\tni_calculate_leakage_for_v_and_t_formula(coeff, v, t, i_leakage, leakage);\n}\n\nbool ni_dpm_vblank_too_short(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 vblank_time = r600_dpm_get_vblank_time(rdev);\n\t \n\tu32 switch_limit = pi->mem_gddr5 ? 450 : 0;\n\n\tif (vblank_time < switch_limit)\n\t\treturn true;\n\telse\n\t\treturn false;\n\n}\n\nstatic void ni_apply_state_adjust_rules(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_ps *rps)\n{\n\tstruct ni_ps *ps = ni_get_ps(rps);\n\tstruct radeon_clock_and_voltage_limits *max_limits;\n\tbool disable_mclk_switching;\n\tu32 mclk;\n\tu16 vddci;\n\tint i;\n\n\tif ((rdev->pm.dpm.new_active_crtc_count > 1) ||\n\t    ni_dpm_vblank_too_short(rdev))\n\t\tdisable_mclk_switching = true;\n\telse\n\t\tdisable_mclk_switching = false;\n\n\tif (rdev->pm.dpm.ac_power)\n\t\tmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\n\telse\n\t\tmax_limits = &rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\n\n\tif (rdev->pm.dpm.ac_power == false) {\n\t\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\t\tif (ps->performance_levels[i].mclk > max_limits->mclk)\n\t\t\t\tps->performance_levels[i].mclk = max_limits->mclk;\n\t\t\tif (ps->performance_levels[i].sclk > max_limits->sclk)\n\t\t\t\tps->performance_levels[i].sclk = max_limits->sclk;\n\t\t\tif (ps->performance_levels[i].vddc > max_limits->vddc)\n\t\t\t\tps->performance_levels[i].vddc = max_limits->vddc;\n\t\t\tif (ps->performance_levels[i].vddci > max_limits->vddci)\n\t\t\t\tps->performance_levels[i].vddci = max_limits->vddci;\n\t\t}\n\t}\n\n\t \n\n\t \n\tif (disable_mclk_switching) {\n\t\tps->performance_levels[0].mclk =\n\t\t\tps->performance_levels[ps->performance_level_count - 1].mclk;\n\t\tps->performance_levels[0].vddci =\n\t\t\tps->performance_levels[ps->performance_level_count - 1].vddci;\n\t}\n\n\tbtc_skip_blacklist_clocks(rdev, max_limits->sclk, max_limits->mclk,\n\t\t\t\t  &ps->performance_levels[0].sclk,\n\t\t\t\t  &ps->performance_levels[0].mclk);\n\n\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\tif (ps->performance_levels[i].sclk < ps->performance_levels[i - 1].sclk)\n\t\t\tps->performance_levels[i].sclk = ps->performance_levels[i - 1].sclk;\n\t\tif (ps->performance_levels[i].vddc < ps->performance_levels[i - 1].vddc)\n\t\t\tps->performance_levels[i].vddc = ps->performance_levels[i - 1].vddc;\n\t}\n\n\t \n\tif (disable_mclk_switching) {\n\t\tmclk = ps->performance_levels[0].mclk;\n\t\tvddci = ps->performance_levels[0].vddci;\n\t\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\t\tif (mclk < ps->performance_levels[i].mclk)\n\t\t\t\tmclk = ps->performance_levels[i].mclk;\n\t\t\tif (vddci < ps->performance_levels[i].vddci)\n\t\t\t\tvddci = ps->performance_levels[i].vddci;\n\t\t}\n\t\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\t\tps->performance_levels[i].mclk = mclk;\n\t\t\tps->performance_levels[i].vddci = vddci;\n\t\t}\n\t} else {\n\t\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\t\tif (ps->performance_levels[i].mclk < ps->performance_levels[i - 1].mclk)\n\t\t\t\tps->performance_levels[i].mclk = ps->performance_levels[i - 1].mclk;\n\t\t\tif (ps->performance_levels[i].vddci < ps->performance_levels[i - 1].vddci)\n\t\t\t\tps->performance_levels[i].vddci = ps->performance_levels[i - 1].vddci;\n\t\t}\n\t}\n\n\tfor (i = 1; i < ps->performance_level_count; i++)\n\t\tbtc_skip_blacklist_clocks(rdev, max_limits->sclk, max_limits->mclk,\n\t\t\t\t\t  &ps->performance_levels[i].sclk,\n\t\t\t\t\t  &ps->performance_levels[i].mclk);\n\n\tfor (i = 0; i < ps->performance_level_count; i++)\n\t\tbtc_adjust_clock_combinations(rdev, max_limits,\n\t\t\t\t\t      &ps->performance_levels[i]);\n\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\n\t\t\t\t\t\t   ps->performance_levels[i].sclk,\n\t\t\t\t\t\t   max_limits->vddc,  &ps->performance_levels[i].vddc);\n\t\tbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\n\t\t\t\t\t\t   ps->performance_levels[i].mclk,\n\t\t\t\t\t\t   max_limits->vddci, &ps->performance_levels[i].vddci);\n\t\tbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\n\t\t\t\t\t\t   ps->performance_levels[i].mclk,\n\t\t\t\t\t\t   max_limits->vddc,  &ps->performance_levels[i].vddc);\n\t\tbtc_apply_voltage_dependency_rules(&rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,\n\t\t\t\t\t\t   rdev->clock.current_dispclk,\n\t\t\t\t\t\t   max_limits->vddc,  &ps->performance_levels[i].vddc);\n\t}\n\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tbtc_apply_voltage_delta_rules(rdev,\n\t\t\t\t\t      max_limits->vddc, max_limits->vddci,\n\t\t\t\t\t      &ps->performance_levels[i].vddc,\n\t\t\t\t\t      &ps->performance_levels[i].vddci);\n\t}\n\n\tps->dc_compatible = true;\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tif (ps->performance_levels[i].vddc > rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc)\n\t\t\tps->dc_compatible = false;\n\n\t\tif (ps->performance_levels[i].vddc < rdev->pm.dpm.dyn_state.min_vddc_for_pcie_gen2)\n\t\t\tps->performance_levels[i].flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;\n\t}\n}\n\nstatic void ni_cg_clockgating_default(struct radeon_device *rdev)\n{\n\tu32 count;\n\tconst u32 *ps = NULL;\n\n\tps = (const u32 *)&cayman_cgcg_cgls_default;\n\tcount = CAYMAN_CGCG_CGLS_DEFAULT_LENGTH;\n\n\tbtc_program_mgcg_hw_sequence(rdev, ps, count);\n}\n\nstatic void ni_gfx_clockgating_enable(struct radeon_device *rdev,\n\t\t\t\t      bool enable)\n{\n\tu32 count;\n\tconst u32 *ps = NULL;\n\n\tif (enable) {\n\t\tps = (const u32 *)&cayman_cgcg_cgls_enable;\n\t\tcount = CAYMAN_CGCG_CGLS_ENABLE_LENGTH;\n\t} else {\n\t\tps = (const u32 *)&cayman_cgcg_cgls_disable;\n\t\tcount = CAYMAN_CGCG_CGLS_DISABLE_LENGTH;\n\t}\n\n\tbtc_program_mgcg_hw_sequence(rdev, ps, count);\n}\n\nstatic void ni_mg_clockgating_default(struct radeon_device *rdev)\n{\n\tu32 count;\n\tconst u32 *ps = NULL;\n\n\tps = (const u32 *)&cayman_mgcg_default;\n\tcount = CAYMAN_MGCG_DEFAULT_LENGTH;\n\n\tbtc_program_mgcg_hw_sequence(rdev, ps, count);\n}\n\nstatic void ni_mg_clockgating_enable(struct radeon_device *rdev,\n\t\t\t\t     bool enable)\n{\n\tu32 count;\n\tconst u32 *ps = NULL;\n\n\tif (enable) {\n\t\tps = (const u32 *)&cayman_mgcg_enable;\n\t\tcount = CAYMAN_MGCG_ENABLE_LENGTH;\n\t} else {\n\t\tps = (const u32 *)&cayman_mgcg_disable;\n\t\tcount = CAYMAN_MGCG_DISABLE_LENGTH;\n\t}\n\n\tbtc_program_mgcg_hw_sequence(rdev, ps, count);\n}\n\nstatic void ni_ls_clockgating_default(struct radeon_device *rdev)\n{\n\tu32 count;\n\tconst u32 *ps = NULL;\n\n\tps = (const u32 *)&cayman_sysls_default;\n\tcount = CAYMAN_SYSLS_DEFAULT_LENGTH;\n\n\tbtc_program_mgcg_hw_sequence(rdev, ps, count);\n}\n\nstatic void ni_ls_clockgating_enable(struct radeon_device *rdev,\n\t\t\t\t     bool enable)\n{\n\tu32 count;\n\tconst u32 *ps = NULL;\n\n\tif (enable) {\n\t\tps = (const u32 *)&cayman_sysls_enable;\n\t\tcount = CAYMAN_SYSLS_ENABLE_LENGTH;\n\t} else {\n\t\tps = (const u32 *)&cayman_sysls_disable;\n\t\tcount = CAYMAN_SYSLS_DISABLE_LENGTH;\n\t}\n\n\tbtc_program_mgcg_hw_sequence(rdev, ps, count);\n\n}\n\nstatic int ni_patch_single_dependency_table_based_on_leakage(struct radeon_device *rdev,\n\t\t\t\t\t\t\t     struct radeon_clock_voltage_dependency_table *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 i;\n\n\tif (table) {\n\t\tfor (i = 0; i < table->count; i++) {\n\t\t\tif (0xff01 == table->entries[i].v) {\n\t\t\t\tif (pi->max_vddc == 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\ttable->entries[i].v = pi->max_vddc;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ni_patch_dependency_tables_based_on_leakage(struct radeon_device *rdev)\n{\n\tint ret = 0;\n\n\tret = ni_patch_single_dependency_table_based_on_leakage(rdev,\n\t\t\t\t\t\t\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk);\n\n\tret = ni_patch_single_dependency_table_based_on_leakage(rdev,\n\t\t\t\t\t\t\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_mclk);\n\treturn ret;\n}\n\nstatic void ni_stop_dpm(struct radeon_device *rdev)\n{\n\tWREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);\n}\n\n#if 0\nstatic int ni_notify_hw_of_power_source(struct radeon_device *rdev,\n\t\t\t\t\tbool ac_power)\n{\n\tif (ac_power)\n\t\treturn (rv770_send_msg_to_smc(rdev, PPSMC_MSG_RunningOnAC) == PPSMC_Result_OK) ?\n\t\t\t0 : -EINVAL;\n\n\treturn 0;\n}\n#endif\n\nstatic PPSMC_Result ni_send_msg_to_smc_with_parameter(struct radeon_device *rdev,\n\t\t\t\t\t\t      PPSMC_Msg msg, u32 parameter)\n{\n\tWREG32(SMC_SCRATCH0, parameter);\n\treturn rv770_send_msg_to_smc(rdev, msg);\n}\n\nstatic int ni_restrict_performance_levels_before_switch(struct radeon_device *rdev)\n{\n\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 1) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nint ni_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t   enum radeon_dpm_forced_level level)\n{\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\tif (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 0) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\n\t\tif (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetForcedLevels, 1) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tif (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetForcedLevels, 0) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\n\t\tif (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 1) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_AUTO) {\n\t\tif (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetForcedLevels, 0) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\n\t\tif (ni_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_SetEnabledLevels, 0) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t}\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n\nstatic void ni_stop_smc(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(LB_SYNC_RESET_SEL) & LB_SYNC_RESET_SEL_MASK;\n\t\tif (tmp != 1)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tudelay(100);\n\n\tr7xx_stop_smc(rdev);\n}\n\nstatic int ni_process_firmware_header(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 tmp;\n\tint ret;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_stateTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpi->state_table_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_softRegisters,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tpi->soft_regs_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_mcRegisterTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\teg_pi->mc_reg_table_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_fanTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tni_pi->fan_table_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_mcArbDramAutoRefreshTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tni_pi->arb_table_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_cacTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tni_pi->cac_table_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tNISLANDS_SMC_FIRMWARE_HEADER_spllTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tni_pi->spll_table_start = (u16)tmp;\n\n\n\treturn ret;\n}\n\nstatic void ni_read_clock_registers(struct radeon_device *rdev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\n\tni_pi->clock_registers.cg_spll_func_cntl = RREG32(CG_SPLL_FUNC_CNTL);\n\tni_pi->clock_registers.cg_spll_func_cntl_2 = RREG32(CG_SPLL_FUNC_CNTL_2);\n\tni_pi->clock_registers.cg_spll_func_cntl_3 = RREG32(CG_SPLL_FUNC_CNTL_3);\n\tni_pi->clock_registers.cg_spll_func_cntl_4 = RREG32(CG_SPLL_FUNC_CNTL_4);\n\tni_pi->clock_registers.cg_spll_spread_spectrum = RREG32(CG_SPLL_SPREAD_SPECTRUM);\n\tni_pi->clock_registers.cg_spll_spread_spectrum_2 = RREG32(CG_SPLL_SPREAD_SPECTRUM_2);\n\tni_pi->clock_registers.mpll_ad_func_cntl = RREG32(MPLL_AD_FUNC_CNTL);\n\tni_pi->clock_registers.mpll_ad_func_cntl_2 = RREG32(MPLL_AD_FUNC_CNTL_2);\n\tni_pi->clock_registers.mpll_dq_func_cntl = RREG32(MPLL_DQ_FUNC_CNTL);\n\tni_pi->clock_registers.mpll_dq_func_cntl_2 = RREG32(MPLL_DQ_FUNC_CNTL_2);\n\tni_pi->clock_registers.mclk_pwrmgt_cntl = RREG32(MCLK_PWRMGT_CNTL);\n\tni_pi->clock_registers.dll_cntl = RREG32(DLL_CNTL);\n\tni_pi->clock_registers.mpll_ss1 = RREG32(MPLL_SS1);\n\tni_pi->clock_registers.mpll_ss2 = RREG32(MPLL_SS2);\n}\n\n#if 0\nstatic int ni_enter_ulp_state(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (pi->gfx_clock_gating) {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\t\tRREG32(GB_ADDR_CONFIG);\n\t}\n\n\tWREG32_P(SMC_MSG, HOST_SMC_MSG(PPSMC_MSG_SwitchToMinimumPower),\n\t\t ~HOST_SMC_MSG_MASK);\n\n\tudelay(25000);\n\n\treturn 0;\n}\n#endif\n\nstatic void ni_program_response_times(struct radeon_device *rdev)\n{\n\tu32 voltage_response_time, backbias_response_time, acpi_delay_time, vbi_time_out;\n\tu32 vddc_dly, bb_dly, acpi_dly, vbi_dly, mclk_switch_limit;\n\tu32 reference_clock;\n\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_mvdd_chg_time, 1);\n\n\tvoltage_response_time = (u32)rdev->pm.dpm.voltage_response_time;\n\tbackbias_response_time = (u32)rdev->pm.dpm.backbias_response_time;\n\n\tif (voltage_response_time == 0)\n\t\tvoltage_response_time = 1000;\n\n\tif (backbias_response_time == 0)\n\t\tbackbias_response_time = 1000;\n\n\tacpi_delay_time = 15000;\n\tvbi_time_out = 100000;\n\n\treference_clock = radeon_get_xclk(rdev);\n\n\tvddc_dly = (voltage_response_time  * reference_clock) / 1600;\n\tbb_dly   = (backbias_response_time * reference_clock) / 1600;\n\tacpi_dly = (acpi_delay_time * reference_clock) / 1600;\n\tvbi_dly  = (vbi_time_out * reference_clock) / 1600;\n\n\tmclk_switch_limit = (460 * reference_clock) / 100;\n\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_delay_vreg,  vddc_dly);\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_delay_bbias, bb_dly);\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_delay_acpi,  acpi_dly);\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_mclk_chg_timeout, vbi_dly);\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_mc_block_delay, 0xAA);\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_mclk_switch_lim, mclk_switch_limit);\n}\n\nstatic void ni_populate_smc_voltage_table(struct radeon_device *rdev,\n\t\t\t\t\t  struct atom_voltage_table *voltage_table,\n\t\t\t\t\t  NISLANDS_SMC_STATETABLE *table)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < voltage_table->count; i++) {\n\t\ttable->highSMIO[i] = 0;\n\t\ttable->lowSMIO[i] |= cpu_to_be32(voltage_table->entries[i].smio_low);\n\t}\n}\n\nstatic void ni_populate_smc_voltage_tables(struct radeon_device *rdev,\n\t\t\t\t\t   NISLANDS_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tunsigned char i;\n\n\tif (eg_pi->vddc_voltage_table.count) {\n\t\tni_populate_smc_voltage_table(rdev, &eg_pi->vddc_voltage_table, table);\n\t\ttable->voltageMaskTable.highMask[NISLANDS_SMC_VOLTAGEMASK_VDDC] = 0;\n\t\ttable->voltageMaskTable.lowMask[NISLANDS_SMC_VOLTAGEMASK_VDDC] =\n\t\t\tcpu_to_be32(eg_pi->vddc_voltage_table.mask_low);\n\n\t\tfor (i = 0; i < eg_pi->vddc_voltage_table.count; i++) {\n\t\t\tif (pi->max_vddc_in_table <= eg_pi->vddc_voltage_table.entries[i].value) {\n\t\t\t\ttable->maxVDDCIndexInPPTable = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (eg_pi->vddci_voltage_table.count) {\n\t\tni_populate_smc_voltage_table(rdev, &eg_pi->vddci_voltage_table, table);\n\n\t\ttable->voltageMaskTable.highMask[NISLANDS_SMC_VOLTAGEMASK_VDDCI] = 0;\n\t\ttable->voltageMaskTable.lowMask[NISLANDS_SMC_VOLTAGEMASK_VDDCI] =\n\t\t\tcpu_to_be32(eg_pi->vddci_voltage_table.mask_low);\n\t}\n}\n\nstatic int ni_populate_voltage_value(struct radeon_device *rdev,\n\t\t\t\t     struct atom_voltage_table *table,\n\t\t\t\t     u16 value,\n\t\t\t\t     NISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (value <= table->entries[i].value) {\n\t\t\tvoltage->index = (u8)i;\n\t\t\tvoltage->value = cpu_to_be16(table->entries[i].value);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= table->count)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void ni_populate_mvdd_value(struct radeon_device *rdev,\n\t\t\t\t   u32 mclk,\n\t\t\t\t   NISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tif (!pi->mvdd_control) {\n\t\tvoltage->index = eg_pi->mvdd_high_index;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t\treturn;\n\t}\n\n\tif (mclk <= pi->mvdd_split_frequency) {\n\t\tvoltage->index = eg_pi->mvdd_low_index;\n\t\tvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\n\t} else {\n\t\tvoltage->index = eg_pi->mvdd_high_index;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t}\n}\n\nstatic int ni_get_std_voltage_value(struct radeon_device *rdev,\n\t\t\t\t    NISLANDS_SMC_VOLTAGE_VALUE *voltage,\n\t\t\t\t    u16 *std_voltage)\n{\n\tif (rdev->pm.dpm.dyn_state.cac_leakage_table.entries &&\n\t    ((u32)voltage->index < rdev->pm.dpm.dyn_state.cac_leakage_table.count))\n\t\t*std_voltage = rdev->pm.dpm.dyn_state.cac_leakage_table.entries[voltage->index].vddc;\n\telse\n\t\t*std_voltage = be16_to_cpu(voltage->value);\n\n\treturn 0;\n}\n\nstatic void ni_populate_std_voltage_value(struct radeon_device *rdev,\n\t\t\t\t\t  u16 value, u8 index,\n\t\t\t\t\t  NISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tvoltage->index = index;\n\tvoltage->value = cpu_to_be16(value);\n}\n\nstatic u32 ni_get_smc_power_scaling_factor(struct radeon_device *rdev)\n{\n\tu32 xclk_period;\n\tu32 xclk = radeon_get_xclk(rdev);\n\tu32 tmp = RREG32(CG_CAC_CTRL) & TID_CNT_MASK;\n\n\txclk_period = (1000000000UL / xclk);\n\txclk_period /= 10000UL;\n\n\treturn tmp * xclk_period;\n}\n\nstatic u32 ni_scale_power_for_smc(u32 power_in_watts, u32 scaling_factor)\n{\n\treturn (power_in_watts * scaling_factor) << 2;\n}\n\nstatic u32 ni_calculate_power_boost_limit(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *radeon_state,\n\t\t\t\t\t  u32 near_tdp_limit)\n{\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 power_boost_limit = 0;\n\tint ret;\n\n\tif (ni_pi->enable_power_containment &&\n\t    ni_pi->use_power_boost_limit) {\n\t\tNISLANDS_SMC_VOLTAGE_VALUE vddc;\n\t\tu16 std_vddc_med;\n\t\tu16 std_vddc_high;\n\t\tu64 tmp, n, d;\n\n\t\tif (state->performance_level_count < 3)\n\t\t\treturn 0;\n\n\t\tret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tstate->performance_levels[state->performance_level_count - 2].vddc,\n\t\t\t\t\t\t&vddc);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tret = ni_get_std_voltage_value(rdev, &vddc, &std_vddc_med);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tstate->performance_levels[state->performance_level_count - 1].vddc,\n\t\t\t\t\t\t&vddc);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tret = ni_get_std_voltage_value(rdev, &vddc, &std_vddc_high);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tn = ((u64)near_tdp_limit * ((u64)std_vddc_med * (u64)std_vddc_med) * 90);\n\t\td = ((u64)std_vddc_high * (u64)std_vddc_high * 100);\n\t\ttmp = div64_u64(n, d);\n\n\t\tif (tmp >> 32)\n\t\t\treturn 0;\n\t\tpower_boost_limit = (u32)tmp;\n\t}\n\n\treturn power_boost_limit;\n}\n\nstatic int ni_calculate_adjusted_tdp_limits(struct radeon_device *rdev,\n\t\t\t\t\t    bool adjust_polarity,\n\t\t\t\t\t    u32 tdp_adjustment,\n\t\t\t\t\t    u32 *tdp_limit,\n\t\t\t\t\t    u32 *near_tdp_limit)\n{\n\tif (tdp_adjustment > (u32)rdev->pm.dpm.tdp_od_limit)\n\t\treturn -EINVAL;\n\n\tif (adjust_polarity) {\n\t\t*tdp_limit = ((100 + tdp_adjustment) * rdev->pm.dpm.tdp_limit) / 100;\n\t\t*near_tdp_limit = rdev->pm.dpm.near_tdp_limit + (*tdp_limit - rdev->pm.dpm.tdp_limit);\n\t} else {\n\t\t*tdp_limit = ((100 - tdp_adjustment) * rdev->pm.dpm.tdp_limit) / 100;\n\t\t*near_tdp_limit = rdev->pm.dpm.near_tdp_limit - (rdev->pm.dpm.tdp_limit - *tdp_limit);\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_populate_smc_tdp_limits(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_ps *radeon_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\n\tif (ni_pi->enable_power_containment) {\n\t\tNISLANDS_SMC_STATETABLE *smc_table = &ni_pi->smc_statetable;\n\t\tu32 scaling_factor = ni_get_smc_power_scaling_factor(rdev);\n\t\tu32 tdp_limit;\n\t\tu32 near_tdp_limit;\n\t\tu32 power_boost_limit;\n\t\tint ret;\n\n\t\tif (scaling_factor == 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(smc_table, 0, sizeof(NISLANDS_SMC_STATETABLE));\n\n\t\tret = ni_calculate_adjusted_tdp_limits(rdev,\n\t\t\t\t\t\t       false,  \n\t\t\t\t\t\t       rdev->pm.dpm.tdp_adjustment,\n\t\t\t\t\t\t       &tdp_limit,\n\t\t\t\t\t\t       &near_tdp_limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpower_boost_limit = ni_calculate_power_boost_limit(rdev, radeon_state,\n\t\t\t\t\t\t\t\t   near_tdp_limit);\n\n\t\tsmc_table->dpm2Params.TDPLimit =\n\t\t\tcpu_to_be32(ni_scale_power_for_smc(tdp_limit, scaling_factor));\n\t\tsmc_table->dpm2Params.NearTDPLimit =\n\t\t\tcpu_to_be32(ni_scale_power_for_smc(near_tdp_limit, scaling_factor));\n\t\tsmc_table->dpm2Params.SafePowerLimit =\n\t\t\tcpu_to_be32(ni_scale_power_for_smc((near_tdp_limit * NISLANDS_DPM2_TDP_SAFE_LIMIT_PERCENT) / 100,\n\t\t\t\t\t\t\t   scaling_factor));\n\t\tsmc_table->dpm2Params.PowerBoostLimit =\n\t\t\tcpu_to_be32(ni_scale_power_for_smc(power_boost_limit, scaling_factor));\n\n\t\tret = rv770_copy_bytes_to_smc(rdev,\n\t\t\t\t\t      (u16)(pi->state_table_start + offsetof(NISLANDS_SMC_STATETABLE, dpm2Params) +\n\t\t\t\t\t\t    offsetof(PP_NIslands_DPM2Parameters, TDPLimit)),\n\t\t\t\t\t      (u8 *)(&smc_table->dpm2Params.TDPLimit),\n\t\t\t\t\t      sizeof(u32) * 4, pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ni_copy_and_switch_arb_sets(struct radeon_device *rdev,\n\t\t\t\tu32 arb_freq_src, u32 arb_freq_dest)\n{\n\tu32 mc_arb_dram_timing;\n\tu32 mc_arb_dram_timing2;\n\tu32 burst_time;\n\tu32 mc_cg_config;\n\n\tswitch (arb_freq_src) {\n\tcase MC_CG_ARB_FREQ_F0:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE0_MASK) >> STATE0_SHIFT;\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F1:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_1);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_1);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE1_MASK) >> STATE1_SHIFT;\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F2:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_2);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_2);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE2_MASK) >> STATE2_SHIFT;\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F3:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_3);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_3);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE3_MASK) >> STATE3_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (arb_freq_dest) {\n\tcase MC_CG_ARB_FREQ_F0:\n\t\tWREG32(MC_ARB_DRAM_TIMING, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE0(burst_time), ~STATE0_MASK);\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F1:\n\t\tWREG32(MC_ARB_DRAM_TIMING_1, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2_1, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE1(burst_time), ~STATE1_MASK);\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F2:\n\t\tWREG32(MC_ARB_DRAM_TIMING_2, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2_2, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE2(burst_time), ~STATE2_MASK);\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F3:\n\t\tWREG32(MC_ARB_DRAM_TIMING_3, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2_3, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE3(burst_time), ~STATE3_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmc_cg_config = RREG32(MC_CG_CONFIG) | 0x0000000F;\n\tWREG32(MC_CG_CONFIG, mc_cg_config);\n\tWREG32_P(MC_ARB_CG, CG_ARB_REQ(arb_freq_dest), ~CG_ARB_REQ_MASK);\n\n\treturn 0;\n}\n\nstatic int ni_init_arb_table_index(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 tmp;\n\tint ret;\n\n\tret = rv770_read_smc_sram_dword(rdev, ni_pi->arb_table_start,\n\t\t\t\t\t&tmp, pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= 0x00FFFFFF;\n\ttmp |= ((u32)MC_CG_ARB_FREQ_F1) << 24;\n\n\treturn rv770_write_smc_sram_dword(rdev, ni_pi->arb_table_start,\n\t\t\t\t\t  tmp, pi->sram_end);\n}\n\nstatic int ni_initial_switch_from_arb_f0_to_f1(struct radeon_device *rdev)\n{\n\treturn ni_copy_and_switch_arb_sets(rdev, MC_CG_ARB_FREQ_F0, MC_CG_ARB_FREQ_F1);\n}\n\nstatic int ni_force_switch_to_arb_f0(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 tmp;\n\tint ret;\n\n\tret = rv770_read_smc_sram_dword(rdev, ni_pi->arb_table_start,\n\t\t\t\t\t&tmp, pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = (tmp >> 24) & 0xff;\n\n\tif (tmp == MC_CG_ARB_FREQ_F0)\n\t\treturn 0;\n\n\treturn ni_copy_and_switch_arb_sets(rdev, tmp, MC_CG_ARB_FREQ_F0);\n}\n\nstatic int ni_populate_memory_timing_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct rv7xx_pl *pl,\n\t\t\t\t\t\tSMC_NIslands_MCArbDramTimingRegisterSet *arb_regs)\n{\n\tu32 dram_timing;\n\tu32 dram_timing2;\n\n\tarb_regs->mc_arb_rfsh_rate =\n\t\t(u8)rv770_calculate_memory_refresh_rate(rdev, pl->sclk);\n\n\n\tradeon_atom_set_engine_dram_timings(rdev, pl->sclk, pl->mclk);\n\n\tdram_timing = RREG32(MC_ARB_DRAM_TIMING);\n\tdram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);\n\n\tarb_regs->mc_arb_dram_timing  = cpu_to_be32(dram_timing);\n\tarb_regs->mc_arb_dram_timing2 = cpu_to_be32(dram_timing2);\n\n\treturn 0;\n}\n\nstatic int ni_do_program_memory_timing_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\t  struct radeon_ps *radeon_state,\n\t\t\t\t\t\t  unsigned int first_arb_set)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tSMC_NIslands_MCArbDramTimingRegisterSet arb_regs = { 0 };\n\tint i, ret = 0;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tret = ni_populate_memory_timing_parameters(rdev, &state->performance_levels[i], &arb_regs);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = rv770_copy_bytes_to_smc(rdev,\n\t\t\t\t\t      (u16)(ni_pi->arb_table_start +\n\t\t\t\t\t\t    offsetof(SMC_NIslands_MCArbDramTimingRegisters, data) +\n\t\t\t\t\t\t    sizeof(SMC_NIslands_MCArbDramTimingRegisterSet) * (first_arb_set + i)),\n\t\t\t\t\t      (u8 *)&arb_regs,\n\t\t\t\t\t      (u16)sizeof(SMC_NIslands_MCArbDramTimingRegisterSet),\n\t\t\t\t\t      pi->sram_end);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ni_program_memory_timing_parameters(struct radeon_device *rdev,\n\t\t\t\t\t       struct radeon_ps *radeon_new_state)\n{\n\treturn ni_do_program_memory_timing_parameters(rdev, radeon_new_state,\n\t\t\t\t\t\t      NISLANDS_DRIVER_STATE_ARB_INDEX);\n}\n\nstatic void ni_populate_initial_mvdd_value(struct radeon_device *rdev,\n\t\t\t\t\t   struct NISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tvoltage->index = eg_pi->mvdd_high_index;\n\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n}\n\nstatic int ni_populate_smc_initial_state(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *radeon_initial_state,\n\t\t\t\t\t NISLANDS_SMC_STATETABLE *table)\n{\n\tstruct ni_ps *initial_state = ni_get_ps(radeon_initial_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 reg;\n\tint ret;\n\n\ttable->initialState.level.mclk.vMPLL_AD_FUNC_CNTL =\n\t\tcpu_to_be32(ni_pi->clock_registers.mpll_ad_func_cntl);\n\ttable->initialState.level.mclk.vMPLL_AD_FUNC_CNTL_2 =\n\t\tcpu_to_be32(ni_pi->clock_registers.mpll_ad_func_cntl_2);\n\ttable->initialState.level.mclk.vMPLL_DQ_FUNC_CNTL =\n\t\tcpu_to_be32(ni_pi->clock_registers.mpll_dq_func_cntl);\n\ttable->initialState.level.mclk.vMPLL_DQ_FUNC_CNTL_2 =\n\t\tcpu_to_be32(ni_pi->clock_registers.mpll_dq_func_cntl_2);\n\ttable->initialState.level.mclk.vMCLK_PWRMGT_CNTL =\n\t\tcpu_to_be32(ni_pi->clock_registers.mclk_pwrmgt_cntl);\n\ttable->initialState.level.mclk.vDLL_CNTL =\n\t\tcpu_to_be32(ni_pi->clock_registers.dll_cntl);\n\ttable->initialState.level.mclk.vMPLL_SS =\n\t\tcpu_to_be32(ni_pi->clock_registers.mpll_ss1);\n\ttable->initialState.level.mclk.vMPLL_SS2 =\n\t\tcpu_to_be32(ni_pi->clock_registers.mpll_ss2);\n\ttable->initialState.level.mclk.mclk_value =\n\t\tcpu_to_be32(initial_state->performance_levels[0].mclk);\n\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL =\n\t\tcpu_to_be32(ni_pi->clock_registers.cg_spll_func_cntl);\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(ni_pi->clock_registers.cg_spll_func_cntl_2);\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_3 =\n\t\tcpu_to_be32(ni_pi->clock_registers.cg_spll_func_cntl_3);\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_4 =\n\t\tcpu_to_be32(ni_pi->clock_registers.cg_spll_func_cntl_4);\n\ttable->initialState.level.sclk.vCG_SPLL_SPREAD_SPECTRUM =\n\t\tcpu_to_be32(ni_pi->clock_registers.cg_spll_spread_spectrum);\n\ttable->initialState.level.sclk.vCG_SPLL_SPREAD_SPECTRUM_2 =\n\t\tcpu_to_be32(ni_pi->clock_registers.cg_spll_spread_spectrum_2);\n\ttable->initialState.level.sclk.sclk_value =\n\t\tcpu_to_be32(initial_state->performance_levels[0].sclk);\n\ttable->initialState.level.arbRefreshState =\n\t\tNISLANDS_INITIAL_STATE_ARB_INDEX;\n\n\ttable->initialState.level.ACIndex = 0;\n\n\tret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\tinitial_state->performance_levels[0].vddc,\n\t\t\t\t\t&table->initialState.level.vddc);\n\tif (!ret) {\n\t\tu16 std_vddc;\n\n\t\tret = ni_get_std_voltage_value(rdev,\n\t\t\t\t\t       &table->initialState.level.vddc,\n\t\t\t\t\t       &std_vddc);\n\t\tif (!ret)\n\t\t\tni_populate_std_voltage_value(rdev, std_vddc,\n\t\t\t\t\t\t      table->initialState.level.vddc.index,\n\t\t\t\t\t\t      &table->initialState.level.std_vddc);\n\t}\n\n\tif (eg_pi->vddci_control)\n\t\tni_populate_voltage_value(rdev,\n\t\t\t\t\t  &eg_pi->vddci_voltage_table,\n\t\t\t\t\t  initial_state->performance_levels[0].vddci,\n\t\t\t\t\t  &table->initialState.level.vddci);\n\n\tni_populate_initial_mvdd_value(rdev, &table->initialState.level.mvdd);\n\n\treg = CG_R(0xffff) | CG_L(0);\n\ttable->initialState.level.aT = cpu_to_be32(reg);\n\n\ttable->initialState.level.bSP = cpu_to_be32(pi->dsp);\n\n\tif (pi->boot_in_gen2)\n\t\ttable->initialState.level.gen2PCIE = 1;\n\telse\n\t\ttable->initialState.level.gen2PCIE = 0;\n\n\tif (pi->mem_gddr5) {\n\t\ttable->initialState.level.strobeMode =\n\t\t\tcypress_get_strobe_mode_settings(rdev,\n\t\t\t\t\t\t\t initial_state->performance_levels[0].mclk);\n\n\t\tif (initial_state->performance_levels[0].mclk > pi->mclk_edc_enable_threshold)\n\t\t\ttable->initialState.level.mcFlags = NISLANDS_SMC_MC_EDC_RD_FLAG | NISLANDS_SMC_MC_EDC_WR_FLAG;\n\t\telse\n\t\t\ttable->initialState.level.mcFlags =  0;\n\t}\n\n\ttable->initialState.levelCount = 1;\n\n\ttable->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\ttable->initialState.level.dpm2.MaxPS = 0;\n\ttable->initialState.level.dpm2.NearTDPDec = 0;\n\ttable->initialState.level.dpm2.AboveSafeInc = 0;\n\ttable->initialState.level.dpm2.BelowSafeInc = 0;\n\n\treg = MIN_POWER_MASK | MAX_POWER_MASK;\n\ttable->initialState.level.SQPowerThrottle = cpu_to_be32(reg);\n\n\treg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;\n\ttable->initialState.level.SQPowerThrottle_2 = cpu_to_be32(reg);\n\n\treturn 0;\n}\n\nstatic int ni_populate_smc_acpi_state(struct radeon_device *rdev,\n\t\t\t\t      NISLANDS_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 mpll_ad_func_cntl   = ni_pi->clock_registers.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 = ni_pi->clock_registers.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl   = ni_pi->clock_registers.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 = ni_pi->clock_registers.mpll_dq_func_cntl_2;\n\tu32 spll_func_cntl      = ni_pi->clock_registers.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2    = ni_pi->clock_registers.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3    = ni_pi->clock_registers.cg_spll_func_cntl_3;\n\tu32 spll_func_cntl_4    = ni_pi->clock_registers.cg_spll_func_cntl_4;\n\tu32 mclk_pwrmgt_cntl    = ni_pi->clock_registers.mclk_pwrmgt_cntl;\n\tu32 dll_cntl            = ni_pi->clock_registers.dll_cntl;\n\tu32 reg;\n\tint ret;\n\n\ttable->ACPIState = table->initialState;\n\n\ttable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\tif (pi->acpi_vddc) {\n\t\tret = ni_populate_voltage_value(rdev,\n\t\t\t\t\t\t&eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tpi->acpi_vddc, &table->ACPIState.level.vddc);\n\t\tif (!ret) {\n\t\t\tu16 std_vddc;\n\n\t\t\tret = ni_get_std_voltage_value(rdev,\n\t\t\t\t\t\t       &table->ACPIState.level.vddc, &std_vddc);\n\t\t\tif (!ret)\n\t\t\t\tni_populate_std_voltage_value(rdev, std_vddc,\n\t\t\t\t\t\t\t      table->ACPIState.level.vddc.index,\n\t\t\t\t\t\t\t      &table->ACPIState.level.std_vddc);\n\t\t}\n\n\t\tif (pi->pcie_gen2) {\n\t\t\tif (pi->acpi_pcie_gen2)\n\t\t\t\ttable->ACPIState.level.gen2PCIE = 1;\n\t\t\telse\n\t\t\t\ttable->ACPIState.level.gen2PCIE = 0;\n\t\t} else {\n\t\t\ttable->ACPIState.level.gen2PCIE = 0;\n\t\t}\n\t} else {\n\t\tret = ni_populate_voltage_value(rdev,\n\t\t\t\t\t\t&eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tpi->min_vddc_in_table,\n\t\t\t\t\t\t&table->ACPIState.level.vddc);\n\t\tif (!ret) {\n\t\t\tu16 std_vddc;\n\n\t\t\tret = ni_get_std_voltage_value(rdev,\n\t\t\t\t\t\t       &table->ACPIState.level.vddc,\n\t\t\t\t\t\t       &std_vddc);\n\t\t\tif (!ret)\n\t\t\t\tni_populate_std_voltage_value(rdev, std_vddc,\n\t\t\t\t\t\t\t      table->ACPIState.level.vddc.index,\n\t\t\t\t\t\t\t      &table->ACPIState.level.std_vddc);\n\t\t}\n\t\ttable->ACPIState.level.gen2PCIE = 0;\n\t}\n\n\tif (eg_pi->acpi_vddci) {\n\t\tif (eg_pi->vddci_control)\n\t\t\tni_populate_voltage_value(rdev,\n\t\t\t\t\t\t  &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\t  eg_pi->acpi_vddci,\n\t\t\t\t\t\t  &table->ACPIState.level.vddci);\n\t}\n\n\n\tmpll_ad_func_cntl &= ~PDNB;\n\n\tmpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\n\n\tif (pi->mem_gddr5)\n\t\tmpll_dq_func_cntl &= ~PDNB;\n\tmpll_dq_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN | BYPASS;\n\n\n\tmclk_pwrmgt_cntl |= (MRDCKA0_RESET |\n\t\t\t     MRDCKA1_RESET |\n\t\t\t     MRDCKB0_RESET |\n\t\t\t     MRDCKB1_RESET |\n\t\t\t     MRDCKC0_RESET |\n\t\t\t     MRDCKC1_RESET |\n\t\t\t     MRDCKD0_RESET |\n\t\t\t     MRDCKD1_RESET);\n\n\tmclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |\n\t\t\t      MRDCKA1_PDNB |\n\t\t\t      MRDCKB0_PDNB |\n\t\t\t      MRDCKB1_PDNB |\n\t\t\t      MRDCKC0_PDNB |\n\t\t\t      MRDCKC1_PDNB |\n\t\t\t      MRDCKD0_PDNB |\n\t\t\t      MRDCKD1_PDNB);\n\n\tdll_cntl |= (MRDCKA0_BYPASS |\n\t\t     MRDCKA1_BYPASS |\n\t\t     MRDCKB0_BYPASS |\n\t\t     MRDCKB1_BYPASS |\n\t\t     MRDCKC0_BYPASS |\n\t\t     MRDCKC1_BYPASS |\n\t\t     MRDCKD0_BYPASS |\n\t\t     MRDCKD1_BYPASS);\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(4);\n\n\ttable->ACPIState.level.mclk.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\ttable->ACPIState.level.mclk.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\ttable->ACPIState.level.mclk.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\ttable->ACPIState.level.mclk.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\ttable->ACPIState.level.mclk.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\ttable->ACPIState.level.mclk.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\n\ttable->ACPIState.level.mclk.mclk_value = 0;\n\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_4 = cpu_to_be32(spll_func_cntl_4);\n\n\ttable->ACPIState.level.sclk.sclk_value = 0;\n\n\tni_populate_mvdd_value(rdev, 0, &table->ACPIState.level.mvdd);\n\n\tif (eg_pi->dynamic_ac_timing)\n\t\ttable->ACPIState.level.ACIndex = 1;\n\n\ttable->ACPIState.level.dpm2.MaxPS = 0;\n\ttable->ACPIState.level.dpm2.NearTDPDec = 0;\n\ttable->ACPIState.level.dpm2.AboveSafeInc = 0;\n\ttable->ACPIState.level.dpm2.BelowSafeInc = 0;\n\n\treg = MIN_POWER_MASK | MAX_POWER_MASK;\n\ttable->ACPIState.level.SQPowerThrottle = cpu_to_be32(reg);\n\n\treg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;\n\ttable->ACPIState.level.SQPowerThrottle_2 = cpu_to_be32(reg);\n\n\treturn 0;\n}\n\nstatic int ni_init_smc_table(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tint ret;\n\tstruct radeon_ps *radeon_boot_state = rdev->pm.dpm.boot_ps;\n\tNISLANDS_SMC_STATETABLE *table = &ni_pi->smc_statetable;\n\n\tmemset(table, 0, sizeof(NISLANDS_SMC_STATETABLE));\n\n\tni_populate_smc_voltage_tables(rdev, table);\n\n\tswitch (rdev->pm.int_thermal_type) {\n\tcase THERMAL_TYPE_NI:\n\tcase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\n\t\tbreak;\n\tcase THERMAL_TYPE_NONE:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\n\t\tbreak;\n\tdefault:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT;\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\n\n\tif (pi->mem_gddr5)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\n\n\tret = ni_populate_smc_initial_state(rdev, radeon_boot_state, table);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni_populate_smc_acpi_state(rdev, table);\n\tif (ret)\n\t\treturn ret;\n\n\ttable->driverState.flags = table->initialState.flags;\n\ttable->driverState.levelCount = table->initialState.levelCount;\n\ttable->driverState.levels[0] = table->initialState.level;\n\n\ttable->ULVState = table->initialState;\n\n\tret = ni_do_program_memory_timing_parameters(rdev, radeon_boot_state,\n\t\t\t\t\t\t     NISLANDS_INITIAL_STATE_ARB_INDEX);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rv770_copy_bytes_to_smc(rdev, pi->state_table_start, (u8 *)table,\n\t\t\t\t       sizeof(NISLANDS_SMC_STATETABLE), pi->sram_end);\n}\n\nstatic int ni_calculate_sclk_params(struct radeon_device *rdev,\n\t\t\t\t    u32 engine_clock,\n\t\t\t\t    NISLANDS_SMC_SCLK_VALUE *sclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct atom_clock_dividers dividers;\n\tu32 spll_func_cntl = ni_pi->clock_registers.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 = ni_pi->clock_registers.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 = ni_pi->clock_registers.cg_spll_func_cntl_3;\n\tu32 spll_func_cntl_4 = ni_pi->clock_registers.cg_spll_func_cntl_4;\n\tu32 cg_spll_spread_spectrum = ni_pi->clock_registers.cg_spll_spread_spectrum;\n\tu32 cg_spll_spread_spectrum_2 = ni_pi->clock_registers.cg_spll_spread_spectrum_2;\n\tu64 tmp;\n\tu32 reference_clock = rdev->clock.spll.reference_freq;\n\tu32 reference_divider;\n\tu32 fbdiv;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     engine_clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\treference_divider = 1 + dividers.ref_div;\n\n\n\ttmp = (u64) engine_clock * reference_divider * dividers.post_div * 16834;\n\tdo_div(tmp, reference_clock);\n\tfbdiv = (u32) tmp;\n\n\tspll_func_cntl &= ~(SPLL_PDIV_A_MASK | SPLL_REF_DIV_MASK);\n\tspll_func_cntl |= SPLL_REF_DIV(dividers.ref_div);\n\tspll_func_cntl |= SPLL_PDIV_A(dividers.post_div);\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(2);\n\n\tspll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;\n\tspll_func_cntl_3 |= SPLL_FB_DIV(fbdiv);\n\tspll_func_cntl_3 |= SPLL_DITHEN;\n\n\tif (pi->sclk_ss) {\n\t\tstruct radeon_atom_ss ss;\n\t\tu32 vco_freq = engine_clock * dividers.post_div;\n\n\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_ENGINE_SS, vco_freq)) {\n\t\t\tu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\n\t\t\tu32 clk_v = 4 * ss.percentage * fbdiv / (clk_s * 10000);\n\n\t\t\tcg_spll_spread_spectrum &= ~CLK_S_MASK;\n\t\t\tcg_spll_spread_spectrum |= CLK_S(clk_s);\n\t\t\tcg_spll_spread_spectrum |= SSEN;\n\n\t\t\tcg_spll_spread_spectrum_2 &= ~CLK_V_MASK;\n\t\t\tcg_spll_spread_spectrum_2 |= CLK_V(clk_v);\n\t\t}\n\t}\n\n\tsclk->sclk_value = engine_clock;\n\tsclk->vCG_SPLL_FUNC_CNTL = spll_func_cntl;\n\tsclk->vCG_SPLL_FUNC_CNTL_2 = spll_func_cntl_2;\n\tsclk->vCG_SPLL_FUNC_CNTL_3 = spll_func_cntl_3;\n\tsclk->vCG_SPLL_FUNC_CNTL_4 = spll_func_cntl_4;\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM = cg_spll_spread_spectrum;\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cg_spll_spread_spectrum_2;\n\n\treturn 0;\n}\n\nstatic int ni_populate_sclk_value(struct radeon_device *rdev,\n\t\t\t\t  u32 engine_clock,\n\t\t\t\t  NISLANDS_SMC_SCLK_VALUE *sclk)\n{\n\tNISLANDS_SMC_SCLK_VALUE sclk_tmp;\n\tint ret;\n\n\tret = ni_calculate_sclk_params(rdev, engine_clock, &sclk_tmp);\n\tif (!ret) {\n\t\tsclk->sclk_value = cpu_to_be32(sclk_tmp.sclk_value);\n\t\tsclk->vCG_SPLL_FUNC_CNTL = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL);\n\t\tsclk->vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL_2);\n\t\tsclk->vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL_3);\n\t\tsclk->vCG_SPLL_FUNC_CNTL_4 = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL_4);\n\t\tsclk->vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32(sclk_tmp.vCG_SPLL_SPREAD_SPECTRUM);\n\t\tsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32(sclk_tmp.vCG_SPLL_SPREAD_SPECTRUM_2);\n\t}\n\n\treturn ret;\n}\n\nstatic int ni_init_smc_spll_table(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tSMC_NISLANDS_SPLL_DIV_TABLE *spll_table;\n\tNISLANDS_SMC_SCLK_VALUE sclk_params;\n\tu32 fb_div;\n\tu32 p_div;\n\tu32 clk_s;\n\tu32 clk_v;\n\tu32 sclk = 0;\n\tint i, ret;\n\tu32 tmp;\n\n\tif (ni_pi->spll_table_start == 0)\n\t\treturn -EINVAL;\n\n\tspll_table = kzalloc(sizeof(SMC_NISLANDS_SPLL_DIV_TABLE), GFP_KERNEL);\n\tif (spll_table == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tret = ni_calculate_sclk_params(rdev, sclk, &sclk_params);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tp_div = (sclk_params.vCG_SPLL_FUNC_CNTL & SPLL_PDIV_A_MASK) >> SPLL_PDIV_A_SHIFT;\n\t\tfb_div = (sclk_params.vCG_SPLL_FUNC_CNTL_3 & SPLL_FB_DIV_MASK) >> SPLL_FB_DIV_SHIFT;\n\t\tclk_s = (sclk_params.vCG_SPLL_SPREAD_SPECTRUM & CLK_S_MASK) >> CLK_S_SHIFT;\n\t\tclk_v = (sclk_params.vCG_SPLL_SPREAD_SPECTRUM_2 & CLK_V_MASK) >> CLK_V_SHIFT;\n\n\t\tfb_div &= ~0x00001FFF;\n\t\tfb_div >>= 1;\n\t\tclk_v >>= 6;\n\n\t\tif (p_div & ~(SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_SHIFT))\n\t\t\tret = -EINVAL;\n\n\t\tif (clk_s & ~(SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_SHIFT))\n\t\t\tret = -EINVAL;\n\n\t\tif (fb_div & ~(SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_SHIFT))\n\t\t\tret = -EINVAL;\n\n\t\tif (clk_v & ~(SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_MASK >> SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_SHIFT))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ttmp = ((fb_div << SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_FBDIV_MASK) |\n\t\t\t((p_div << SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_PDIV_MASK);\n\t\tspll_table->freq[i] = cpu_to_be32(tmp);\n\n\t\ttmp = ((clk_v << SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_CLKV_MASK) |\n\t\t\t((clk_s << SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_SHIFT) & SMC_NISLANDS_SPLL_DIV_TABLE_CLKS_MASK);\n\t\tspll_table->ss[i] = cpu_to_be32(tmp);\n\n\t\tsclk += 512;\n\t}\n\n\tif (!ret)\n\t\tret = rv770_copy_bytes_to_smc(rdev, ni_pi->spll_table_start, (u8 *)spll_table,\n\t\t\t\t\t      sizeof(SMC_NISLANDS_SPLL_DIV_TABLE), pi->sram_end);\n\n\tkfree(spll_table);\n\n\treturn ret;\n}\n\nstatic int ni_populate_mclk_value(struct radeon_device *rdev,\n\t\t\t\t  u32 engine_clock,\n\t\t\t\t  u32 memory_clock,\n\t\t\t\t  NISLANDS_SMC_MCLK_VALUE *mclk,\n\t\t\t\t  bool strobe_mode,\n\t\t\t\t  bool dll_state_on)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 mpll_ad_func_cntl = ni_pi->clock_registers.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 = ni_pi->clock_registers.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl = ni_pi->clock_registers.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 = ni_pi->clock_registers.mpll_dq_func_cntl_2;\n\tu32 mclk_pwrmgt_cntl = ni_pi->clock_registers.mclk_pwrmgt_cntl;\n\tu32 dll_cntl = ni_pi->clock_registers.dll_cntl;\n\tu32 mpll_ss1 = ni_pi->clock_registers.mpll_ss1;\n\tu32 mpll_ss2 = ni_pi->clock_registers.mpll_ss2;\n\tstruct atom_clock_dividers dividers;\n\tu32 ibias;\n\tu32 dll_speed;\n\tint ret;\n\tu32 mc_seq_misc7;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\n\t\t\t\t\t     memory_clock, strobe_mode, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!strobe_mode) {\n\t\tmc_seq_misc7 = RREG32(MC_SEQ_MISC7);\n\n\t\tif (mc_seq_misc7 & 0x8000000)\n\t\t\tdividers.post_div = 1;\n\t}\n\n\tibias = cypress_map_clkf_to_ibias(rdev, dividers.whole_fb_div);\n\n\tmpll_ad_func_cntl &= ~(CLKR_MASK |\n\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t       CLKF_MASK |\n\t\t\t       CLKFRAC_MASK |\n\t\t\t       IBIAS_MASK);\n\tmpll_ad_func_cntl |= CLKR(dividers.ref_div);\n\tmpll_ad_func_cntl |= YCLK_POST_DIV(dividers.post_div);\n\tmpll_ad_func_cntl |= CLKF(dividers.whole_fb_div);\n\tmpll_ad_func_cntl |= CLKFRAC(dividers.frac_fb_div);\n\tmpll_ad_func_cntl |= IBIAS(ibias);\n\n\tif (dividers.vco_mode)\n\t\tmpll_ad_func_cntl_2 |= VCO_MODE;\n\telse\n\t\tmpll_ad_func_cntl_2 &= ~VCO_MODE;\n\n\tif (pi->mem_gddr5) {\n\t\tmpll_dq_func_cntl &= ~(CLKR_MASK |\n\t\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t\t       CLKF_MASK |\n\t\t\t\t       CLKFRAC_MASK |\n\t\t\t\t       IBIAS_MASK);\n\t\tmpll_dq_func_cntl |= CLKR(dividers.ref_div);\n\t\tmpll_dq_func_cntl |= YCLK_POST_DIV(dividers.post_div);\n\t\tmpll_dq_func_cntl |= CLKF(dividers.whole_fb_div);\n\t\tmpll_dq_func_cntl |= CLKFRAC(dividers.frac_fb_div);\n\t\tmpll_dq_func_cntl |= IBIAS(ibias);\n\n\t\tif (strobe_mode)\n\t\t\tmpll_dq_func_cntl &= ~PDNB;\n\t\telse\n\t\t\tmpll_dq_func_cntl |= PDNB;\n\n\t\tif (dividers.vco_mode)\n\t\t\tmpll_dq_func_cntl_2 |= VCO_MODE;\n\t\telse\n\t\t\tmpll_dq_func_cntl_2 &= ~VCO_MODE;\n\t}\n\n\tif (pi->mclk_ss) {\n\t\tstruct radeon_atom_ss ss;\n\t\tu32 vco_freq = memory_clock * dividers.post_div;\n\n\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_MEMORY_SS, vco_freq)) {\n\t\t\tu32 reference_clock = rdev->clock.mpll.reference_freq;\n\t\t\tu32 decoded_ref = rv740_get_decoded_reference_divider(dividers.ref_div);\n\t\t\tu32 clk_s, clk_v;\n\n\t\t\tif (!decoded_ref)\n\t\t\t\treturn -EINVAL;\n\t\t\tclk_s = reference_clock * 5 / (decoded_ref * ss.rate);\n\t\t\tclk_v = ss.percentage *\n\t\t\t\t(0x4000 * dividers.whole_fb_div + 0x800 * dividers.frac_fb_div) / (clk_s * 625);\n\n\t\t\tmpll_ss1 &= ~CLKV_MASK;\n\t\t\tmpll_ss1 |= CLKV(clk_v);\n\n\t\t\tmpll_ss2 &= ~CLKS_MASK;\n\t\t\tmpll_ss2 |= CLKS(clk_s);\n\t\t}\n\t}\n\n\tdll_speed = rv740_get_dll_speed(pi->mem_gddr5,\n\t\t\t\t\tmemory_clock);\n\n\tmclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;\n\tmclk_pwrmgt_cntl |= DLL_SPEED(dll_speed);\n\tif (dll_state_on)\n\t\tmclk_pwrmgt_cntl |= (MRDCKA0_PDNB |\n\t\t\t\t     MRDCKA1_PDNB |\n\t\t\t\t     MRDCKB0_PDNB |\n\t\t\t\t     MRDCKB1_PDNB |\n\t\t\t\t     MRDCKC0_PDNB |\n\t\t\t\t     MRDCKC1_PDNB |\n\t\t\t\t     MRDCKD0_PDNB |\n\t\t\t\t     MRDCKD1_PDNB);\n\telse\n\t\tmclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |\n\t\t\t\t      MRDCKA1_PDNB |\n\t\t\t\t      MRDCKB0_PDNB |\n\t\t\t\t      MRDCKB1_PDNB |\n\t\t\t\t      MRDCKC0_PDNB |\n\t\t\t\t      MRDCKC1_PDNB |\n\t\t\t\t      MRDCKD0_PDNB |\n\t\t\t\t      MRDCKD1_PDNB);\n\n\n\tmclk->mclk_value = cpu_to_be32(memory_clock);\n\tmclk->vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\tmclk->vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\tmclk->vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\tmclk->vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\tmclk->vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\tmclk->vDLL_CNTL = cpu_to_be32(dll_cntl);\n\tmclk->vMPLL_SS = cpu_to_be32(mpll_ss1);\n\tmclk->vMPLL_SS2 = cpu_to_be32(mpll_ss2);\n\n\treturn 0;\n}\n\nstatic void ni_populate_smc_sp(struct radeon_device *rdev,\n\t\t\t       struct radeon_ps *radeon_state,\n\t\t\t       NISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct ni_ps *ps = ni_get_ps(radeon_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint i;\n\n\tfor (i = 0; i < ps->performance_level_count - 1; i++)\n\t\tsmc_state->levels[i].bSP = cpu_to_be32(pi->dsp);\n\n\tsmc_state->levels[ps->performance_level_count - 1].bSP =\n\t\tcpu_to_be32(pi->psp);\n}\n\nstatic int ni_convert_power_level_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t struct rv7xx_pl *pl,\n\t\t\t\t\t NISLANDS_SMC_HW_PERFORMANCE_LEVEL *level)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tint ret;\n\tbool dll_state_on;\n\tu16 std_vddc;\n\tu32 tmp = RREG32(DC_STUTTER_CNTL);\n\n\tlevel->gen2PCIE = pi->pcie_gen2 ?\n\t\t((pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0) : 0;\n\n\tret = ni_populate_sclk_value(rdev, pl->sclk, &level->sclk);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel->mcFlags =  0;\n\tif (pi->mclk_stutter_mode_threshold &&\n\t    (pl->mclk <= pi->mclk_stutter_mode_threshold) &&\n\t    !eg_pi->uvd_enabled &&\n\t    (tmp & DC_STUTTER_ENABLE_A) &&\n\t    (tmp & DC_STUTTER_ENABLE_B))\n\t\tlevel->mcFlags |= NISLANDS_SMC_MC_STUTTER_EN;\n\n\tif (pi->mem_gddr5) {\n\t\tif (pl->mclk > pi->mclk_edc_enable_threshold)\n\t\t\tlevel->mcFlags |= NISLANDS_SMC_MC_EDC_RD_FLAG;\n\t\tif (pl->mclk > eg_pi->mclk_edc_wr_enable_threshold)\n\t\t\tlevel->mcFlags |= NISLANDS_SMC_MC_EDC_WR_FLAG;\n\n\t\tlevel->strobeMode = cypress_get_strobe_mode_settings(rdev, pl->mclk);\n\n\t\tif (level->strobeMode & NISLANDS_SMC_STROBE_ENABLE) {\n\t\t\tif (cypress_get_mclk_frequency_ratio(rdev, pl->mclk, true) >=\n\t\t\t    ((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))\n\t\t\t\tdll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\n\t\t\telse\n\t\t\t\tdll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;\n\t\t} else {\n\t\t\tdll_state_on = false;\n\t\t\tif (pl->mclk > ni_pi->mclk_rtt_mode_threshold)\n\t\t\t\tlevel->mcFlags |= NISLANDS_SMC_MC_RTT_ENABLE;\n\t\t}\n\n\t\tret = ni_populate_mclk_value(rdev, pl->sclk, pl->mclk,\n\t\t\t\t\t     &level->mclk,\n\t\t\t\t\t     (level->strobeMode & NISLANDS_SMC_STROBE_ENABLE) != 0,\n\t\t\t\t\t     dll_state_on);\n\t} else\n\t\tret = ni_populate_mclk_value(rdev, pl->sclk, pl->mclk, &level->mclk, 1, 1);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni_populate_voltage_value(rdev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\tpl->vddc, &level->vddc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni_get_std_voltage_value(rdev, &level->vddc, &std_vddc);\n\tif (ret)\n\t\treturn ret;\n\n\tni_populate_std_voltage_value(rdev, std_vddc,\n\t\t\t\t      level->vddc.index, &level->std_vddc);\n\n\tif (eg_pi->vddci_control) {\n\t\tret = ni_populate_voltage_value(rdev, &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\tpl->vddci, &level->vddci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tni_populate_mvdd_value(rdev, pl->mclk, &level->mvdd);\n\n\treturn ret;\n}\n\nstatic int ni_populate_smc_t(struct radeon_device *rdev,\n\t\t\t     struct radeon_ps *radeon_state,\n\t\t\t     NISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tu32 a_t;\n\tu32 t_l, t_h;\n\tu32 high_bsp;\n\tint i, ret;\n\n\tif (state->performance_level_count >= 9)\n\t\treturn -EINVAL;\n\n\tif (state->performance_level_count < 2) {\n\t\ta_t = CG_R(0xffff) | CG_L(0);\n\t\tsmc_state->levels[0].aT = cpu_to_be32(a_t);\n\t\treturn 0;\n\t}\n\n\tsmc_state->levels[0].aT = cpu_to_be32(0);\n\n\tfor (i = 0; i <= state->performance_level_count - 2; i++) {\n\t\tif (eg_pi->uvd_enabled)\n\t\t\tret = r600_calculate_at(\n\t\t\t\t1000 * (i * (eg_pi->smu_uvd_hs ? 2 : 8) + 2),\n\t\t\t\t100 * R600_AH_DFLT,\n\t\t\t\tstate->performance_levels[i + 1].sclk,\n\t\t\t\tstate->performance_levels[i].sclk,\n\t\t\t\t&t_l,\n\t\t\t\t&t_h);\n\t\telse\n\t\t\tret = r600_calculate_at(\n\t\t\t\t1000 * (i + 1),\n\t\t\t\t100 * R600_AH_DFLT,\n\t\t\t\tstate->performance_levels[i + 1].sclk,\n\t\t\t\tstate->performance_levels[i].sclk,\n\t\t\t\t&t_l,\n\t\t\t\t&t_h);\n\n\t\tif (ret) {\n\t\t\tt_h = (i + 1) * 1000 - 50 * R600_AH_DFLT;\n\t\t\tt_l = (i + 1) * 1000 + 50 * R600_AH_DFLT;\n\t\t}\n\n\t\ta_t = be32_to_cpu(smc_state->levels[i].aT) & ~CG_R_MASK;\n\t\ta_t |= CG_R(t_l * pi->bsp / 20000);\n\t\tsmc_state->levels[i].aT = cpu_to_be32(a_t);\n\n\t\thigh_bsp = (i == state->performance_level_count - 2) ?\n\t\t\tpi->pbsp : pi->bsp;\n\n\t\ta_t = CG_R(0xffff) | CG_L(t_h * high_bsp / 20000);\n\t\tsmc_state->levels[i + 1].aT = cpu_to_be32(a_t);\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_populate_power_containment_values(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct radeon_ps *radeon_state,\n\t\t\t\t\t\tNISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tu32 prev_sclk;\n\tu32 max_sclk;\n\tu32 min_sclk;\n\tint i, ret;\n\tu32 tdp_limit;\n\tu32 near_tdp_limit;\n\tu32 power_boost_limit;\n\tu8 max_ps_percent;\n\n\tif (ni_pi->enable_power_containment == false)\n\t\treturn 0;\n\n\tif (state->performance_level_count == 0)\n\t\treturn -EINVAL;\n\n\tif (smc_state->levelCount != state->performance_level_count)\n\t\treturn -EINVAL;\n\n\tret = ni_calculate_adjusted_tdp_limits(rdev,\n\t\t\t\t\t       false,  \n\t\t\t\t\t       rdev->pm.dpm.tdp_adjustment,\n\t\t\t\t\t       &tdp_limit,\n\t\t\t\t\t       &near_tdp_limit);\n\tif (ret)\n\t\treturn ret;\n\n\tpower_boost_limit = ni_calculate_power_boost_limit(rdev, radeon_state, near_tdp_limit);\n\n\tret = rv770_write_smc_sram_dword(rdev,\n\t\t\t\t\t pi->state_table_start +\n\t\t\t\t\t offsetof(NISLANDS_SMC_STATETABLE, dpm2Params) +\n\t\t\t\t\t offsetof(PP_NIslands_DPM2Parameters, PowerBoostLimit),\n\t\t\t\t\t ni_scale_power_for_smc(power_boost_limit, ni_get_smc_power_scaling_factor(rdev)),\n\t\t\t\t\t pi->sram_end);\n\tif (ret)\n\t\tpower_boost_limit = 0;\n\n\tsmc_state->levels[0].dpm2.MaxPS = 0;\n\tsmc_state->levels[0].dpm2.NearTDPDec = 0;\n\tsmc_state->levels[0].dpm2.AboveSafeInc = 0;\n\tsmc_state->levels[0].dpm2.BelowSafeInc = 0;\n\tsmc_state->levels[0].stateFlags |= power_boost_limit ? PPSMC_STATEFLAG_POWERBOOST : 0;\n\n\tfor (i = 1; i < state->performance_level_count; i++) {\n\t\tprev_sclk = state->performance_levels[i-1].sclk;\n\t\tmax_sclk  = state->performance_levels[i].sclk;\n\t\tmax_ps_percent = (i != (state->performance_level_count - 1)) ?\n\t\t\tNISLANDS_DPM2_MAXPS_PERCENT_M : NISLANDS_DPM2_MAXPS_PERCENT_H;\n\n\t\tif (max_sclk < prev_sclk)\n\t\t\treturn -EINVAL;\n\n\t\tif ((max_ps_percent == 0) || (prev_sclk == max_sclk) || eg_pi->uvd_enabled)\n\t\t\tmin_sclk = max_sclk;\n\t\telse if (1 == i)\n\t\t\tmin_sclk = prev_sclk;\n\t\telse\n\t\t\tmin_sclk = (prev_sclk * (u32)max_ps_percent) / 100;\n\n\t\tif (min_sclk < state->performance_levels[0].sclk)\n\t\t\tmin_sclk = state->performance_levels[0].sclk;\n\n\t\tif (min_sclk == 0)\n\t\t\treturn -EINVAL;\n\n\t\tsmc_state->levels[i].dpm2.MaxPS =\n\t\t\t(u8)((NISLANDS_DPM2_MAX_PULSE_SKIP * (max_sclk - min_sclk)) / max_sclk);\n\t\tsmc_state->levels[i].dpm2.NearTDPDec = NISLANDS_DPM2_NEAR_TDP_DEC;\n\t\tsmc_state->levels[i].dpm2.AboveSafeInc = NISLANDS_DPM2_ABOVE_SAFE_INC;\n\t\tsmc_state->levels[i].dpm2.BelowSafeInc = NISLANDS_DPM2_BELOW_SAFE_INC;\n\t\tsmc_state->levels[i].stateFlags |=\n\t\t\t((i != (state->performance_level_count - 1)) && power_boost_limit) ?\n\t\t\tPPSMC_STATEFLAG_POWERBOOST : 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_populate_sq_ramping_values(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *radeon_state,\n\t\t\t\t\t NISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tu32 sq_power_throttle;\n\tu32 sq_power_throttle2;\n\tbool enable_sq_ramping = ni_pi->enable_sq_ramping;\n\tint i;\n\n\tif (state->performance_level_count == 0)\n\t\treturn -EINVAL;\n\n\tif (smc_state->levelCount != state->performance_level_count)\n\t\treturn -EINVAL;\n\n\tif (rdev->pm.dpm.sq_ramping_threshold == 0)\n\t\treturn -EINVAL;\n\n\tif (NISLANDS_DPM2_SQ_RAMP_MAX_POWER > (MAX_POWER_MASK >> MAX_POWER_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (NISLANDS_DPM2_SQ_RAMP_MIN_POWER > (MIN_POWER_MASK >> MIN_POWER_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (NISLANDS_DPM2_SQ_RAMP_MAX_POWER_DELTA > (MAX_POWER_DELTA_MASK >> MAX_POWER_DELTA_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (NISLANDS_DPM2_SQ_RAMP_STI_SIZE > (STI_SIZE_MASK >> STI_SIZE_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (NISLANDS_DPM2_SQ_RAMP_LTI_RATIO > (LTI_RATIO_MASK >> LTI_RATIO_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tsq_power_throttle  = 0;\n\t\tsq_power_throttle2 = 0;\n\n\t\tif ((state->performance_levels[i].sclk >= rdev->pm.dpm.sq_ramping_threshold) &&\n\t\t    enable_sq_ramping) {\n\t\t\tsq_power_throttle |= MAX_POWER(NISLANDS_DPM2_SQ_RAMP_MAX_POWER);\n\t\t\tsq_power_throttle |= MIN_POWER(NISLANDS_DPM2_SQ_RAMP_MIN_POWER);\n\t\t\tsq_power_throttle2 |= MAX_POWER_DELTA(NISLANDS_DPM2_SQ_RAMP_MAX_POWER_DELTA);\n\t\t\tsq_power_throttle2 |= STI_SIZE(NISLANDS_DPM2_SQ_RAMP_STI_SIZE);\n\t\t\tsq_power_throttle2 |= LTI_RATIO(NISLANDS_DPM2_SQ_RAMP_LTI_RATIO);\n\t\t} else {\n\t\t\tsq_power_throttle |= MAX_POWER_MASK | MIN_POWER_MASK;\n\t\t\tsq_power_throttle2 |= MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;\n\t\t}\n\n\t\tsmc_state->levels[i].SQPowerThrottle   = cpu_to_be32(sq_power_throttle);\n\t\tsmc_state->levels[i].SQPowerThrottle_2 = cpu_to_be32(sq_power_throttle2);\n\t}\n\n\treturn 0;\n}\n\nstatic int ni_enable_power_containment(struct radeon_device *rdev,\n\t\t\t\t       struct radeon_ps *radeon_new_state,\n\t\t\t\t       bool enable)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tPPSMC_Result smc_result;\n\tint ret = 0;\n\n\tif (ni_pi->enable_power_containment) {\n\t\tif (enable) {\n\t\t\tif (!r600_is_uvd_state(radeon_new_state->class, radeon_new_state->class2)) {\n\t\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_TDPClampingActive);\n\t\t\t\tif (smc_result != PPSMC_Result_OK) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tni_pi->pc_enabled = false;\n\t\t\t\t} else {\n\t\t\t\t\tni_pi->pc_enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_TDPClampingInactive);\n\t\t\tif (smc_result != PPSMC_Result_OK)\n\t\t\t\tret = -EINVAL;\n\t\t\tni_pi->pc_enabled = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ni_convert_power_state_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *radeon_state,\n\t\t\t\t\t NISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tint i, ret;\n\tu32 threshold = state->performance_levels[state->performance_level_count - 1].sclk * 100 / 100;\n\n\tif (!(radeon_state->caps & ATOM_PPLIB_DISALLOW_ON_DC))\n\t\tsmc_state->flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\tsmc_state->levelCount = 0;\n\n\tif (state->performance_level_count > NISLANDS_MAX_SMC_PERFORMANCE_LEVELS_PER_SWSTATE)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tret = ni_convert_power_level_to_smc(rdev, &state->performance_levels[i],\n\t\t\t\t\t\t    &smc_state->levels[i]);\n\t\tsmc_state->levels[i].arbRefreshState =\n\t\t\t(u8)(NISLANDS_DRIVER_STATE_ARB_INDEX + i);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ni_pi->enable_power_containment)\n\t\t\tsmc_state->levels[i].displayWatermark =\n\t\t\t\t(state->performance_levels[i].sclk < threshold) ?\n\t\t\t\tPPSMC_DISPLAY_WATERMARK_LOW : PPSMC_DISPLAY_WATERMARK_HIGH;\n\t\telse\n\t\t\tsmc_state->levels[i].displayWatermark = (i < 2) ?\n\t\t\t\tPPSMC_DISPLAY_WATERMARK_LOW : PPSMC_DISPLAY_WATERMARK_HIGH;\n\n\t\tif (eg_pi->dynamic_ac_timing)\n\t\t\tsmc_state->levels[i].ACIndex = NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT + i;\n\t\telse\n\t\t\tsmc_state->levels[i].ACIndex = 0;\n\n\t\tsmc_state->levelCount++;\n\t}\n\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_watermark_threshold,\n\t\t\t\t      cpu_to_be32(threshold / 512));\n\n\tni_populate_smc_sp(rdev, radeon_state, smc_state);\n\n\tret = ni_populate_power_containment_values(rdev, radeon_state, smc_state);\n\tif (ret)\n\t\tni_pi->enable_power_containment = false;\n\n\tret = ni_populate_sq_ramping_values(rdev, radeon_state, smc_state);\n\tif (ret)\n\t\tni_pi->enable_sq_ramping = false;\n\n\treturn ni_populate_smc_t(rdev, radeon_state, smc_state);\n}\n\nstatic int ni_upload_sw_state(struct radeon_device *rdev,\n\t\t\t      struct radeon_ps *radeon_new_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu16 address = pi->state_table_start +\n\t\toffsetof(NISLANDS_SMC_STATETABLE, driverState);\n\tNISLANDS_SMC_SWSTATE *smc_state;\n\tsize_t state_size = struct_size(smc_state, levels,\n\t\t\tNISLANDS_MAX_SMC_PERFORMANCE_LEVELS_PER_SWSTATE);\n\tint ret;\n\n\tsmc_state = kzalloc(state_size, GFP_KERNEL);\n\tif (smc_state == NULL)\n\t\treturn -ENOMEM;\n\n\tret = ni_convert_power_state_to_smc(rdev, radeon_new_state, smc_state);\n\tif (ret)\n\t\tgoto done;\n\n\tret = rv770_copy_bytes_to_smc(rdev, address, (u8 *)smc_state, state_size, pi->sram_end);\n\ndone:\n\tkfree(smc_state);\n\n\treturn ret;\n}\n\nstatic int ni_set_mc_special_registers(struct radeon_device *rdev,\n\t\t\t\t       struct ni_mc_reg_table *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu8 i, j, k;\n\tu32 temp_reg;\n\n\tfor (i = 0, j = table->last; i < table->last; i++) {\n\t\tswitch (table->mc_reg_address[i].s1) {\n\t\tcase MC_SEQ_MISC1 >> 2:\n\t\t\tif (j >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\ttemp_reg = RREG32(MC_PMG_CMD_EMRS);\n\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_CMD_EMRS >> 2;\n\t\t\ttable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\n\t\t\tfor (k = 0; k < table->num_entries; k++)\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t((temp_reg & 0xffff0000)) |\n\t\t\t\t\t((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\n\t\t\tj++;\n\t\t\tif (j >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\treturn -EINVAL;\n\n\t\t\ttemp_reg = RREG32(MC_PMG_CMD_MRS);\n\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS >> 2;\n\t\t\ttable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;\n\t\t\tfor(k = 0; k < table->num_entries; k++) {\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t(temp_reg & 0xffff0000) |\n\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\n\t\t\t\tif (!pi->mem_gddr5)\n\t\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\n\t\t\t}\n\t\t\tj++;\n\t\t\tbreak;\n\t\tcase MC_SEQ_RESERVE_M >> 2:\n\t\t\tif (j >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\ttemp_reg = RREG32(MC_PMG_CMD_MRS1);\n\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS1 >> 2;\n\t\t\ttable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\n\t\t\tfor (k = 0; k < table->num_entries; k++)\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t(temp_reg & 0xffff0000) |\n\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttable->last = j;\n\n\treturn 0;\n}\n\nstatic bool ni_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)\n{\n\tbool result = true;\n\n\tswitch (in_reg) {\n\tcase  MC_SEQ_RAS_TIMING >> 2:\n\t\t*out_reg = MC_SEQ_RAS_TIMING_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_CAS_TIMING >> 2:\n\t\t*out_reg = MC_SEQ_CAS_TIMING_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_MISC_TIMING >> 2:\n\t\t*out_reg = MC_SEQ_MISC_TIMING_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_MISC_TIMING2 >> 2:\n\t\t*out_reg = MC_SEQ_MISC_TIMING2_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_RD_CTL_D0 >> 2:\n\t\t*out_reg = MC_SEQ_RD_CTL_D0_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_RD_CTL_D1 >> 2:\n\t\t*out_reg = MC_SEQ_RD_CTL_D1_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_WR_CTL_D0 >> 2:\n\t\t*out_reg = MC_SEQ_WR_CTL_D0_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_WR_CTL_D1 >> 2:\n\t\t*out_reg = MC_SEQ_WR_CTL_D1_LP >> 2;\n\t\tbreak;\n\tcase MC_PMG_CMD_EMRS >> 2:\n\t\t*out_reg = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\n\t\tbreak;\n\tcase MC_PMG_CMD_MRS >> 2:\n\t\t*out_reg = MC_SEQ_PMG_CMD_MRS_LP >> 2;\n\t\tbreak;\n\tcase MC_PMG_CMD_MRS1 >> 2:\n\t\t*out_reg = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\n\t\tbreak;\n\tcase MC_SEQ_PMG_TIMING >> 2:\n\t\t*out_reg = MC_SEQ_PMG_TIMING_LP >> 2;\n\t\tbreak;\n\tcase MC_PMG_CMD_MRS2 >> 2:\n\t\t*out_reg = MC_SEQ_PMG_CMD_MRS2_LP >> 2;\n\t\tbreak;\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic void ni_set_valid_flag(struct ni_mc_reg_table *table)\n{\n\tu8 i, j;\n\n\tfor (i = 0; i < table->last; i++) {\n\t\tfor (j = 1; j < table->num_entries; j++) {\n\t\t\tif (table->mc_reg_table_entry[j-1].mc_data[i] != table->mc_reg_table_entry[j].mc_data[i]) {\n\t\t\t\ttable->valid_flag |= 1 << i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ni_set_s0_mc_reg_index(struct ni_mc_reg_table *table)\n{\n\tu32 i;\n\tu16 address;\n\n\tfor (i = 0; i < table->last; i++)\n\t\ttable->mc_reg_address[i].s0 =\n\t\t\tni_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?\n\t\t\taddress : table->mc_reg_address[i].s1;\n}\n\nstatic int ni_copy_vbios_mc_reg_table(struct atom_mc_reg_table *table,\n\t\t\t\t      struct ni_mc_reg_table *ni_table)\n{\n\tu8 i, j;\n\n\tif (table->last > SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\treturn -EINVAL;\n\tif (table->num_entries > MAX_AC_TIMING_ENTRIES)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < table->last; i++)\n\t\tni_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\n\tni_table->last = table->last;\n\n\tfor (i = 0; i < table->num_entries; i++) {\n\t\tni_table->mc_reg_table_entry[i].mclk_max =\n\t\t\ttable->mc_reg_table_entry[i].mclk_max;\n\t\tfor (j = 0; j < table->last; j++)\n\t\t\tni_table->mc_reg_table_entry[i].mc_data[j] =\n\t\t\t\ttable->mc_reg_table_entry[i].mc_data[j];\n\t}\n\tni_table->num_entries = table->num_entries;\n\n\treturn 0;\n}\n\nstatic int ni_initialize_mc_reg_table(struct radeon_device *rdev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tint ret;\n\tstruct atom_mc_reg_table *table;\n\tstruct ni_mc_reg_table *ni_table = &ni_pi->mc_reg_table;\n\tu8 module_index = rv770_get_memory_module_index(rdev);\n\n\ttable = kzalloc(sizeof(struct atom_mc_reg_table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tWREG32(MC_SEQ_RAS_TIMING_LP, RREG32(MC_SEQ_RAS_TIMING));\n\tWREG32(MC_SEQ_CAS_TIMING_LP, RREG32(MC_SEQ_CAS_TIMING));\n\tWREG32(MC_SEQ_MISC_TIMING_LP, RREG32(MC_SEQ_MISC_TIMING));\n\tWREG32(MC_SEQ_MISC_TIMING2_LP, RREG32(MC_SEQ_MISC_TIMING2));\n\tWREG32(MC_SEQ_PMG_CMD_EMRS_LP, RREG32(MC_PMG_CMD_EMRS));\n\tWREG32(MC_SEQ_PMG_CMD_MRS_LP, RREG32(MC_PMG_CMD_MRS));\n\tWREG32(MC_SEQ_PMG_CMD_MRS1_LP, RREG32(MC_PMG_CMD_MRS1));\n\tWREG32(MC_SEQ_WR_CTL_D0_LP, RREG32(MC_SEQ_WR_CTL_D0));\n\tWREG32(MC_SEQ_WR_CTL_D1_LP, RREG32(MC_SEQ_WR_CTL_D1));\n\tWREG32(MC_SEQ_RD_CTL_D0_LP, RREG32(MC_SEQ_RD_CTL_D0));\n\tWREG32(MC_SEQ_RD_CTL_D1_LP, RREG32(MC_SEQ_RD_CTL_D1));\n\tWREG32(MC_SEQ_PMG_TIMING_LP, RREG32(MC_SEQ_PMG_TIMING));\n\tWREG32(MC_SEQ_PMG_CMD_MRS2_LP, RREG32(MC_PMG_CMD_MRS2));\n\n\tret = radeon_atom_init_mc_reg_table(rdev, module_index, table);\n\n\tif (ret)\n\t\tgoto init_mc_done;\n\n\tret = ni_copy_vbios_mc_reg_table(table, ni_table);\n\n\tif (ret)\n\t\tgoto init_mc_done;\n\n\tni_set_s0_mc_reg_index(ni_table);\n\n\tret = ni_set_mc_special_registers(rdev, ni_table);\n\n\tif (ret)\n\t\tgoto init_mc_done;\n\n\tni_set_valid_flag(ni_table);\n\ninit_mc_done:\n\tkfree(table);\n\n\treturn ret;\n}\n\nstatic void ni_populate_mc_reg_addresses(struct radeon_device *rdev,\n\t\t\t\t\t SMC_NIslands_MCRegisters *mc_reg_table)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 i, j;\n\n\tfor (i = 0, j = 0; j < ni_pi->mc_reg_table.last; j++) {\n\t\tif (ni_pi->mc_reg_table.valid_flag & (1 << j)) {\n\t\t\tif (i >= SMC_NISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\tbreak;\n\t\t\tmc_reg_table->address[i].s0 =\n\t\t\t\tcpu_to_be16(ni_pi->mc_reg_table.mc_reg_address[j].s0);\n\t\t\tmc_reg_table->address[i].s1 =\n\t\t\t\tcpu_to_be16(ni_pi->mc_reg_table.mc_reg_address[j].s1);\n\t\t\ti++;\n\t\t}\n\t}\n\tmc_reg_table->last = (u8)i;\n}\n\n\nstatic void ni_convert_mc_registers(struct ni_mc_reg_entry *entry,\n\t\t\t\t    SMC_NIslands_MCRegisterSet *data,\n\t\t\t\t    u32 num_entries, u32 valid_flag)\n{\n\tu32 i, j;\n\n\tfor (i = 0, j = 0; j < num_entries; j++) {\n\t\tif (valid_flag & (1 << j)) {\n\t\t\tdata->value[i] = cpu_to_be32(entry->mc_data[j]);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic void ni_convert_mc_reg_table_entry_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t\t struct rv7xx_pl *pl,\n\t\t\t\t\t\t SMC_NIslands_MCRegisterSet *mc_reg_table_data)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 i = 0;\n\n\tfor (i = 0; i < ni_pi->mc_reg_table.num_entries; i++) {\n\t\tif (pl->mclk <= ni_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)\n\t\t\tbreak;\n\t}\n\n\tif ((i == ni_pi->mc_reg_table.num_entries) && (i > 0))\n\t\t--i;\n\n\tni_convert_mc_registers(&ni_pi->mc_reg_table.mc_reg_table_entry[i],\n\t\t\t\tmc_reg_table_data,\n\t\t\t\tni_pi->mc_reg_table.last,\n\t\t\t\tni_pi->mc_reg_table.valid_flag);\n}\n\nstatic void ni_convert_mc_reg_table_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *radeon_state,\n\t\t\t\t\t   SMC_NIslands_MCRegisters *mc_reg_table)\n{\n\tstruct ni_ps *state = ni_get_ps(radeon_state);\n\tint i;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tni_convert_mc_reg_table_entry_to_smc(rdev,\n\t\t\t\t\t\t     &state->performance_levels[i],\n\t\t\t\t\t\t     &mc_reg_table->data[NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT + i]);\n\t}\n}\n\nstatic int ni_populate_mc_reg_table(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_ps *radeon_boot_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct ni_ps *boot_state = ni_get_ps(radeon_boot_state);\n\tSMC_NIslands_MCRegisters *mc_reg_table = &ni_pi->smc_mc_reg_table;\n\n\tmemset(mc_reg_table, 0, sizeof(SMC_NIslands_MCRegisters));\n\n\trv770_write_smc_soft_register(rdev, NI_SMC_SOFT_REGISTER_seq_index, 1);\n\n\tni_populate_mc_reg_addresses(rdev, mc_reg_table);\n\n\tni_convert_mc_reg_table_entry_to_smc(rdev, &boot_state->performance_levels[0],\n\t\t\t\t\t     &mc_reg_table->data[0]);\n\n\tni_convert_mc_registers(&ni_pi->mc_reg_table.mc_reg_table_entry[0],\n\t\t\t\t&mc_reg_table->data[1],\n\t\t\t\tni_pi->mc_reg_table.last,\n\t\t\t\tni_pi->mc_reg_table.valid_flag);\n\n\tni_convert_mc_reg_table_to_smc(rdev, radeon_boot_state, mc_reg_table);\n\n\treturn rv770_copy_bytes_to_smc(rdev, eg_pi->mc_reg_table_start,\n\t\t\t\t       (u8 *)mc_reg_table,\n\t\t\t\t       sizeof(SMC_NIslands_MCRegisters),\n\t\t\t\t       pi->sram_end);\n}\n\nstatic int ni_upload_mc_reg_table(struct radeon_device *rdev,\n\t\t\t\t  struct radeon_ps *radeon_new_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct ni_ps *ni_new_state = ni_get_ps(radeon_new_state);\n\tSMC_NIslands_MCRegisters *mc_reg_table = &ni_pi->smc_mc_reg_table;\n\tu16 address;\n\n\tmemset(mc_reg_table, 0, sizeof(SMC_NIslands_MCRegisters));\n\n\tni_convert_mc_reg_table_to_smc(rdev, radeon_new_state, mc_reg_table);\n\n\taddress = eg_pi->mc_reg_table_start +\n\t\t(u16)offsetof(SMC_NIslands_MCRegisters, data[NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT]);\n\n\treturn rv770_copy_bytes_to_smc(rdev, address,\n\t\t\t\t       (u8 *)&mc_reg_table->data[NISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT],\n\t\t\t\t       sizeof(SMC_NIslands_MCRegisterSet) * ni_new_state->performance_level_count,\n\t\t\t\t       pi->sram_end);\n}\n\nstatic int ni_init_driver_calculated_leakage_table(struct radeon_device *rdev,\n\t\t\t\t\t\t   PP_NIslands_CACTABLES *cac_tables)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 leakage = 0;\n\tunsigned int i, j, table_size;\n\ts32 t;\n\tu32 smc_leakage, max_leakage = 0;\n\tu32 scaling_factor;\n\n\ttable_size = eg_pi->vddc_voltage_table.count;\n\n\tif (SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES < table_size)\n\t\ttable_size = SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES;\n\n\tscaling_factor = ni_get_smc_power_scaling_factor(rdev);\n\n\tfor (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++) {\n\t\tfor (j = 0; j < table_size; j++) {\n\t\t\tt = (1000 * ((i + 1) * 8));\n\n\t\t\tif (t < ni_pi->cac_data.leakage_minimum_temperature)\n\t\t\t\tt = ni_pi->cac_data.leakage_minimum_temperature;\n\n\t\t\tni_calculate_leakage_for_v_and_t(rdev,\n\t\t\t\t\t\t\t &ni_pi->cac_data.leakage_coefficients,\n\t\t\t\t\t\t\t eg_pi->vddc_voltage_table.entries[j].value,\n\t\t\t\t\t\t\t t,\n\t\t\t\t\t\t\t ni_pi->cac_data.i_leakage,\n\t\t\t\t\t\t\t &leakage);\n\n\t\t\tsmc_leakage = ni_scale_power_for_smc(leakage, scaling_factor) / 1000;\n\t\t\tif (smc_leakage > max_leakage)\n\t\t\t\tmax_leakage = smc_leakage;\n\n\t\t\tcac_tables->cac_lkge_lut[i][j] = cpu_to_be32(smc_leakage);\n\t\t}\n\t}\n\n\tfor (j = table_size; j < SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES; j++) {\n\t\tfor (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++)\n\t\t\tcac_tables->cac_lkge_lut[i][j] = cpu_to_be32(max_leakage);\n\t}\n\treturn 0;\n}\n\nstatic int ni_init_simplified_leakage_table(struct radeon_device *rdev,\n\t\t\t\t\t    PP_NIslands_CACTABLES *cac_tables)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_cac_leakage_table *leakage_table =\n\t\t&rdev->pm.dpm.dyn_state.cac_leakage_table;\n\tu32 i, j, table_size;\n\tu32 smc_leakage, max_leakage = 0;\n\tu32 scaling_factor;\n\n\tif (!leakage_table)\n\t\treturn -EINVAL;\n\n\ttable_size = leakage_table->count;\n\n\tif (eg_pi->vddc_voltage_table.count != table_size)\n\t\ttable_size = (eg_pi->vddc_voltage_table.count < leakage_table->count) ?\n\t\t\teg_pi->vddc_voltage_table.count : leakage_table->count;\n\n\tif (SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES < table_size)\n\t\ttable_size = SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES;\n\n\tif (table_size == 0)\n\t\treturn -EINVAL;\n\n\tscaling_factor = ni_get_smc_power_scaling_factor(rdev);\n\n\tfor (j = 0; j < table_size; j++) {\n\t\tsmc_leakage = leakage_table->entries[j].leakage;\n\n\t\tif (smc_leakage > max_leakage)\n\t\t\tmax_leakage = smc_leakage;\n\n\t\tfor (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++)\n\t\t\tcac_tables->cac_lkge_lut[i][j] =\n\t\t\t\tcpu_to_be32(ni_scale_power_for_smc(smc_leakage, scaling_factor));\n\t}\n\n\tfor (j = table_size; j < SMC_NISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES; j++) {\n\t\tfor (i = 0; i < SMC_NISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES; i++)\n\t\t\tcac_tables->cac_lkge_lut[i][j] =\n\t\t\t\tcpu_to_be32(ni_scale_power_for_smc(max_leakage, scaling_factor));\n\t}\n\treturn 0;\n}\n\nstatic int ni_initialize_smc_cac_tables(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tPP_NIslands_CACTABLES *cac_tables = NULL;\n\tint i, ret;\n\tu32 reg;\n\n\tif (ni_pi->enable_cac == false)\n\t\treturn 0;\n\n\tcac_tables = kzalloc(sizeof(PP_NIslands_CACTABLES), GFP_KERNEL);\n\tif (!cac_tables)\n\t\treturn -ENOMEM;\n\n\treg = RREG32(CG_CAC_CTRL) & ~(TID_CNT_MASK | TID_UNIT_MASK);\n\treg |= (TID_CNT(ni_pi->cac_weights->tid_cnt) |\n\t\tTID_UNIT(ni_pi->cac_weights->tid_unit));\n\tWREG32(CG_CAC_CTRL, reg);\n\n\tfor (i = 0; i < NISLANDS_DCCAC_MAX_LEVELS; i++)\n\t\tni_pi->dc_cac_table[i] = ni_pi->cac_weights->dc_cac[i];\n\n\tfor (i = 0; i < SMC_NISLANDS_BIF_LUT_NUM_OF_ENTRIES; i++)\n\t\tcac_tables->cac_bif_lut[i] = ni_pi->cac_weights->pcie_cac[i];\n\n\tni_pi->cac_data.i_leakage = rdev->pm.dpm.cac_leakage;\n\tni_pi->cac_data.pwr_const = 0;\n\tni_pi->cac_data.dc_cac_value = ni_pi->dc_cac_table[NISLANDS_DCCAC_LEVEL_0];\n\tni_pi->cac_data.bif_cac_value = 0;\n\tni_pi->cac_data.mc_wr_weight = ni_pi->cac_weights->mc_write_weight;\n\tni_pi->cac_data.mc_rd_weight = ni_pi->cac_weights->mc_read_weight;\n\tni_pi->cac_data.allow_ovrflw = 0;\n\tni_pi->cac_data.l2num_win_tdp = ni_pi->lta_window_size;\n\tni_pi->cac_data.num_win_tdp = 0;\n\tni_pi->cac_data.lts_truncate_n = ni_pi->lts_truncate;\n\n\tif (ni_pi->driver_calculate_cac_leakage)\n\t\tret = ni_init_driver_calculated_leakage_table(rdev, cac_tables);\n\telse\n\t\tret = ni_init_simplified_leakage_table(rdev, cac_tables);\n\n\tif (ret)\n\t\tgoto done_free;\n\n\tcac_tables->pwr_const      = cpu_to_be32(ni_pi->cac_data.pwr_const);\n\tcac_tables->dc_cacValue    = cpu_to_be32(ni_pi->cac_data.dc_cac_value);\n\tcac_tables->bif_cacValue   = cpu_to_be32(ni_pi->cac_data.bif_cac_value);\n\tcac_tables->AllowOvrflw    = ni_pi->cac_data.allow_ovrflw;\n\tcac_tables->MCWrWeight     = ni_pi->cac_data.mc_wr_weight;\n\tcac_tables->MCRdWeight     = ni_pi->cac_data.mc_rd_weight;\n\tcac_tables->numWin_TDP     = ni_pi->cac_data.num_win_tdp;\n\tcac_tables->l2numWin_TDP   = ni_pi->cac_data.l2num_win_tdp;\n\tcac_tables->lts_truncate_n = ni_pi->cac_data.lts_truncate_n;\n\n\tret = rv770_copy_bytes_to_smc(rdev, ni_pi->cac_table_start, (u8 *)cac_tables,\n\t\t\t\t      sizeof(PP_NIslands_CACTABLES), pi->sram_end);\n\ndone_free:\n\tif (ret) {\n\t\tni_pi->enable_cac = false;\n\t\tni_pi->enable_power_containment = false;\n\t}\n\n\tkfree(cac_tables);\n\n\treturn 0;\n}\n\nstatic int ni_initialize_hardware_cac_manager(struct radeon_device *rdev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tu32 reg;\n\n\tif (!ni_pi->enable_cac ||\n\t    !ni_pi->cac_configuration_required)\n\t\treturn 0;\n\n\tif (ni_pi->cac_weights == NULL)\n\t\treturn -EINVAL;\n\n\treg = RREG32_CG(CG_CAC_REGION_1_WEIGHT_0) & ~(WEIGHT_TCP_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_TCP_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_TA_SIG_MASK);\n\treg |= (WEIGHT_TCP_SIG0(ni_pi->cac_weights->weight_tcp_sig0) |\n\t\tWEIGHT_TCP_SIG1(ni_pi->cac_weights->weight_tcp_sig1) |\n\t\tWEIGHT_TA_SIG(ni_pi->cac_weights->weight_ta_sig));\n\tWREG32_CG(CG_CAC_REGION_1_WEIGHT_0, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_1_WEIGHT_1) & ~(WEIGHT_TCC_EN0_MASK |\n\t\t\t\t\t\t      WEIGHT_TCC_EN1_MASK |\n\t\t\t\t\t\t      WEIGHT_TCC_EN2_MASK);\n\treg |= (WEIGHT_TCC_EN0(ni_pi->cac_weights->weight_tcc_en0) |\n\t\tWEIGHT_TCC_EN1(ni_pi->cac_weights->weight_tcc_en1) |\n\t\tWEIGHT_TCC_EN2(ni_pi->cac_weights->weight_tcc_en2));\n\tWREG32_CG(CG_CAC_REGION_1_WEIGHT_1, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_2_WEIGHT_0) & ~(WEIGHT_CB_EN0_MASK |\n\t\t\t\t\t\t      WEIGHT_CB_EN1_MASK |\n\t\t\t\t\t\t      WEIGHT_CB_EN2_MASK |\n\t\t\t\t\t\t      WEIGHT_CB_EN3_MASK);\n\treg |= (WEIGHT_CB_EN0(ni_pi->cac_weights->weight_cb_en0) |\n\t\tWEIGHT_CB_EN1(ni_pi->cac_weights->weight_cb_en1) |\n\t\tWEIGHT_CB_EN2(ni_pi->cac_weights->weight_cb_en2) |\n\t\tWEIGHT_CB_EN3(ni_pi->cac_weights->weight_cb_en3));\n\tWREG32_CG(CG_CAC_REGION_2_WEIGHT_0, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_2_WEIGHT_1) & ~(WEIGHT_DB_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_DB_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_DB_SIG2_MASK |\n\t\t\t\t\t\t      WEIGHT_DB_SIG3_MASK);\n\treg |= (WEIGHT_DB_SIG0(ni_pi->cac_weights->weight_db_sig0) |\n\t\tWEIGHT_DB_SIG1(ni_pi->cac_weights->weight_db_sig1) |\n\t\tWEIGHT_DB_SIG2(ni_pi->cac_weights->weight_db_sig2) |\n\t\tWEIGHT_DB_SIG3(ni_pi->cac_weights->weight_db_sig3));\n\tWREG32_CG(CG_CAC_REGION_2_WEIGHT_1, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_2_WEIGHT_2) & ~(WEIGHT_SXM_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_SXM_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_SXM_SIG2_MASK |\n\t\t\t\t\t\t      WEIGHT_SXS_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_SXS_SIG1_MASK);\n\treg |= (WEIGHT_SXM_SIG0(ni_pi->cac_weights->weight_sxm_sig0) |\n\t\tWEIGHT_SXM_SIG1(ni_pi->cac_weights->weight_sxm_sig1) |\n\t\tWEIGHT_SXM_SIG2(ni_pi->cac_weights->weight_sxm_sig2) |\n\t\tWEIGHT_SXS_SIG0(ni_pi->cac_weights->weight_sxs_sig0) |\n\t\tWEIGHT_SXS_SIG1(ni_pi->cac_weights->weight_sxs_sig1));\n\tWREG32_CG(CG_CAC_REGION_2_WEIGHT_2, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_3_WEIGHT_0) & ~(WEIGHT_XBR_0_MASK |\n\t\t\t\t\t\t      WEIGHT_XBR_1_MASK |\n\t\t\t\t\t\t      WEIGHT_XBR_2_MASK |\n\t\t\t\t\t\t      WEIGHT_SPI_SIG0_MASK);\n\treg |= (WEIGHT_XBR_0(ni_pi->cac_weights->weight_xbr_0) |\n\t\tWEIGHT_XBR_1(ni_pi->cac_weights->weight_xbr_1) |\n\t\tWEIGHT_XBR_2(ni_pi->cac_weights->weight_xbr_2) |\n\t\tWEIGHT_SPI_SIG0(ni_pi->cac_weights->weight_spi_sig0));\n\tWREG32_CG(CG_CAC_REGION_3_WEIGHT_0, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_3_WEIGHT_1) & ~(WEIGHT_SPI_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_SPI_SIG2_MASK |\n\t\t\t\t\t\t      WEIGHT_SPI_SIG3_MASK |\n\t\t\t\t\t\t      WEIGHT_SPI_SIG4_MASK |\n\t\t\t\t\t\t      WEIGHT_SPI_SIG5_MASK);\n\treg |= (WEIGHT_SPI_SIG1(ni_pi->cac_weights->weight_spi_sig1) |\n\t\tWEIGHT_SPI_SIG2(ni_pi->cac_weights->weight_spi_sig2) |\n\t\tWEIGHT_SPI_SIG3(ni_pi->cac_weights->weight_spi_sig3) |\n\t\tWEIGHT_SPI_SIG4(ni_pi->cac_weights->weight_spi_sig4) |\n\t\tWEIGHT_SPI_SIG5(ni_pi->cac_weights->weight_spi_sig5));\n\tWREG32_CG(CG_CAC_REGION_3_WEIGHT_1, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_0) & ~(WEIGHT_LDS_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_LDS_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_SC_MASK);\n\treg |= (WEIGHT_LDS_SIG0(ni_pi->cac_weights->weight_lds_sig0) |\n\t\tWEIGHT_LDS_SIG1(ni_pi->cac_weights->weight_lds_sig1) |\n\t\tWEIGHT_SC(ni_pi->cac_weights->weight_sc));\n\tWREG32_CG(CG_CAC_REGION_4_WEIGHT_0, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_1) & ~(WEIGHT_BIF_MASK |\n\t\t\t\t\t\t      WEIGHT_CP_MASK |\n\t\t\t\t\t\t      WEIGHT_PA_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_PA_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_VGT_SIG0_MASK);\n\treg |= (WEIGHT_BIF(ni_pi->cac_weights->weight_bif) |\n\t\tWEIGHT_CP(ni_pi->cac_weights->weight_cp) |\n\t\tWEIGHT_PA_SIG0(ni_pi->cac_weights->weight_pa_sig0) |\n\t\tWEIGHT_PA_SIG1(ni_pi->cac_weights->weight_pa_sig1) |\n\t\tWEIGHT_VGT_SIG0(ni_pi->cac_weights->weight_vgt_sig0));\n\tWREG32_CG(CG_CAC_REGION_4_WEIGHT_1, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_2) & ~(WEIGHT_VGT_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_VGT_SIG2_MASK |\n\t\t\t\t\t\t      WEIGHT_DC_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_DC_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_DC_SIG2_MASK);\n\treg |= (WEIGHT_VGT_SIG1(ni_pi->cac_weights->weight_vgt_sig1) |\n\t\tWEIGHT_VGT_SIG2(ni_pi->cac_weights->weight_vgt_sig2) |\n\t\tWEIGHT_DC_SIG0(ni_pi->cac_weights->weight_dc_sig0) |\n\t\tWEIGHT_DC_SIG1(ni_pi->cac_weights->weight_dc_sig1) |\n\t\tWEIGHT_DC_SIG2(ni_pi->cac_weights->weight_dc_sig2));\n\tWREG32_CG(CG_CAC_REGION_4_WEIGHT_2, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_4_WEIGHT_3) & ~(WEIGHT_DC_SIG3_MASK |\n\t\t\t\t\t\t      WEIGHT_UVD_SIG0_MASK |\n\t\t\t\t\t\t      WEIGHT_UVD_SIG1_MASK |\n\t\t\t\t\t\t      WEIGHT_SPARE0_MASK |\n\t\t\t\t\t\t      WEIGHT_SPARE1_MASK);\n\treg |= (WEIGHT_DC_SIG3(ni_pi->cac_weights->weight_dc_sig3) |\n\t\tWEIGHT_UVD_SIG0(ni_pi->cac_weights->weight_uvd_sig0) |\n\t\tWEIGHT_UVD_SIG1(ni_pi->cac_weights->weight_uvd_sig1) |\n\t\tWEIGHT_SPARE0(ni_pi->cac_weights->weight_spare0) |\n\t\tWEIGHT_SPARE1(ni_pi->cac_weights->weight_spare1));\n\tWREG32_CG(CG_CAC_REGION_4_WEIGHT_3, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_5_WEIGHT_0) & ~(WEIGHT_SQ_VSP_MASK |\n\t\t\t\t\t\t      WEIGHT_SQ_VSP0_MASK);\n\treg |= (WEIGHT_SQ_VSP(ni_pi->cac_weights->weight_sq_vsp) |\n\t\tWEIGHT_SQ_VSP0(ni_pi->cac_weights->weight_sq_vsp0));\n\tWREG32_CG(CG_CAC_REGION_5_WEIGHT_0, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_5_WEIGHT_1) & ~(WEIGHT_SQ_GPR_MASK);\n\treg |= WEIGHT_SQ_GPR(ni_pi->cac_weights->weight_sq_gpr);\n\tWREG32_CG(CG_CAC_REGION_5_WEIGHT_1, reg);\n\n\treg = RREG32_CG(CG_CAC_REGION_4_OVERRIDE_4) & ~(OVR_MODE_SPARE_0_MASK |\n\t\t\t\t\t\t\tOVR_VAL_SPARE_0_MASK |\n\t\t\t\t\t\t\tOVR_MODE_SPARE_1_MASK |\n\t\t\t\t\t\t\tOVR_VAL_SPARE_1_MASK);\n\treg |= (OVR_MODE_SPARE_0(ni_pi->cac_weights->ovr_mode_spare_0) |\n\t\tOVR_VAL_SPARE_0(ni_pi->cac_weights->ovr_val_spare_0) |\n\t\tOVR_MODE_SPARE_1(ni_pi->cac_weights->ovr_mode_spare_1) |\n\t\tOVR_VAL_SPARE_1(ni_pi->cac_weights->ovr_val_spare_1));\n\tWREG32_CG(CG_CAC_REGION_4_OVERRIDE_4, reg);\n\n\treg = RREG32(SQ_CAC_THRESHOLD) & ~(VSP_MASK |\n\t\t\t\t\t   VSP0_MASK |\n\t\t\t\t\t   GPR_MASK);\n\treg |= (VSP(ni_pi->cac_weights->vsp) |\n\t\tVSP0(ni_pi->cac_weights->vsp0) |\n\t\tGPR(ni_pi->cac_weights->gpr));\n\tWREG32(SQ_CAC_THRESHOLD, reg);\n\n\treg = (MCDW_WR_ENABLE |\n\t       MCDX_WR_ENABLE |\n\t       MCDY_WR_ENABLE |\n\t       MCDZ_WR_ENABLE |\n\t       INDEX(0x09D4));\n\tWREG32(MC_CG_CONFIG, reg);\n\n\treg = (READ_WEIGHT(ni_pi->cac_weights->mc_read_weight) |\n\t       WRITE_WEIGHT(ni_pi->cac_weights->mc_write_weight) |\n\t       ALLOW_OVERFLOW);\n\tWREG32(MC_CG_DATAPORT, reg);\n\n\treturn 0;\n}\n\nstatic int ni_enable_smc_cac(struct radeon_device *rdev,\n\t\t\t     struct radeon_ps *radeon_new_state,\n\t\t\t     bool enable)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\tint ret = 0;\n\tPPSMC_Result smc_result;\n\n\tif (ni_pi->enable_cac) {\n\t\tif (enable) {\n\t\t\tif (!r600_is_uvd_state(radeon_new_state->class, radeon_new_state->class2)) {\n\t\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_CollectCAC_PowerCorreln);\n\n\t\t\t\tif (ni_pi->support_cac_long_term_average) {\n\t\t\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_CACLongTermAvgEnable);\n\t\t\t\t\tif (PPSMC_Result_OK != smc_result)\n\t\t\t\t\t\tni_pi->support_cac_long_term_average = false;\n\t\t\t\t}\n\n\t\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_EnableCac);\n\t\t\t\tif (PPSMC_Result_OK != smc_result)\n\t\t\t\t\tret = -EINVAL;\n\n\t\t\t\tni_pi->cac_enabled = (PPSMC_Result_OK == smc_result) ? true : false;\n\t\t\t}\n\t\t} else if (ni_pi->cac_enabled) {\n\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_MSG_DisableCac);\n\n\t\t\tni_pi->cac_enabled = false;\n\n\t\t\tif (ni_pi->support_cac_long_term_average) {\n\t\t\t\tsmc_result = rv770_send_msg_to_smc(rdev, PPSMC_CACLongTermAvgDisable);\n\t\t\t\tif (PPSMC_Result_OK != smc_result)\n\t\t\t\t\tni_pi->support_cac_long_term_average = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ni_pcie_performance_request(struct radeon_device *rdev,\n\t\t\t\t       u8 perf_req, bool advertise)\n{\n#if defined(CONFIG_ACPI)\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tif ((perf_req == PCIE_PERF_REQ_PECI_GEN1) ||\n\t    (perf_req == PCIE_PERF_REQ_PECI_GEN2)) {\n\t\tif (eg_pi->pcie_performance_request_registered == false)\n\t\t\tradeon_acpi_pcie_notify_device_ready(rdev);\n\t\teg_pi->pcie_performance_request_registered = true;\n\t\treturn radeon_acpi_pcie_performance_request(rdev, perf_req, advertise);\n\t} else if ((perf_req == PCIE_PERF_REQ_REMOVE_REGISTRY) &&\n\t\t    eg_pi->pcie_performance_request_registered) {\n\t\teg_pi->pcie_performance_request_registered = false;\n\t\treturn radeon_acpi_pcie_performance_request(rdev, perf_req, advertise);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int ni_advertise_gen2_capability(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\n\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\n\t\tpi->pcie_gen2 = true;\n\telse\n\t\tpi->pcie_gen2 = false;\n\n\tif (!pi->pcie_gen2)\n\t\tni_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, true);\n\n\treturn 0;\n}\n\nstatic void ni_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t    bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp, bif;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\n\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\n\t\tif (enable) {\n\t\t\tif (!pi->boot_in_gen2) {\n\t\t\t\tbif = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;\n\t\t\t\tbif |= CG_CLIENT_REQ(0xd);\n\t\t\t\tWREG32(CG_BIF_REQ_AND_RSP, bif);\n\t\t\t}\n\t\t\ttmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\t\t\ttmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\n\t\t\ttmp |= LC_GEN2_EN_STRAP;\n\n\t\t\ttmp |= LC_CLR_FAILED_SPD_CHANGE_CNT;\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t\t\tudelay(10);\n\t\t\ttmp &= ~LC_CLR_FAILED_SPD_CHANGE_CNT;\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t\t} else {\n\t\t\tif (!pi->boot_in_gen2) {\n\t\t\t\tbif = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;\n\t\t\t\tbif |= CG_CLIENT_REQ(0xd);\n\t\t\t\tWREG32(CG_BIF_REQ_AND_RSP, bif);\n\n\t\t\t\ttmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\t\t\t\ttmp &= ~LC_GEN2_EN_STRAP;\n\t\t\t}\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t\t}\n\t}\n}\n\nstatic void ni_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\tbool enable)\n{\n\tni_enable_bif_dynamic_pcie_gen2(rdev, enable);\n\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\n}\n\nvoid ni_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *new_ps,\n\t\t\t\t\t   struct radeon_ps *old_ps)\n{\n\tstruct ni_ps *new_state = ni_get_ps(new_ps);\n\tstruct ni_ps *current_state = ni_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->performance_levels[new_state->performance_level_count - 1].sclk >=\n\t    current_state->performance_levels[current_state->performance_level_count - 1].sclk)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nvoid ni_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *new_ps,\n\t\t\t\t\t  struct radeon_ps *old_ps)\n{\n\tstruct ni_ps *new_state = ni_get_ps(new_ps);\n\tstruct ni_ps *current_state = ni_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->performance_levels[new_state->performance_level_count - 1].sclk <\n\t    current_state->performance_levels[current_state->performance_level_count - 1].sclk)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nvoid ni_dpm_setup_asic(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tint r;\n\n\tr = ni_mc_load_microcode(rdev);\n\tif (r)\n\t\tDRM_ERROR(\"Failed to load MC firmware!\\n\");\n\tni_read_clock_registers(rdev);\n\tbtc_read_arb_registers(rdev);\n\trv770_get_memory_type(rdev);\n\tif (eg_pi->pcie_performance_request)\n\t\tni_advertise_gen2_capability(rdev);\n\trv770_get_pcie_gen2_status(rdev);\n\trv770_enable_acpi_pm(rdev);\n}\n\nvoid ni_update_current_ps(struct radeon_device *rdev,\n\t\t\t  struct radeon_ps *rps)\n{\n\tstruct ni_ps *new_ps = ni_get_ps(rps);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\n\teg_pi->current_rps = *rps;\n\tni_pi->current_ps = *new_ps;\n\teg_pi->current_rps.ps_priv = &ni_pi->current_ps;\n}\n\nvoid ni_update_requested_ps(struct radeon_device *rdev,\n\t\t\t    struct radeon_ps *rps)\n{\n\tstruct ni_ps *new_ps = ni_get_ps(rps);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(rdev);\n\n\teg_pi->requested_rps = *rps;\n\tni_pi->requested_ps = *new_ps;\n\teg_pi->requested_rps.ps_priv = &ni_pi->requested_ps;\n}\n\nint ni_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\tint ret;\n\n\tif (pi->gfx_clock_gating)\n\t\tni_cg_clockgating_default(rdev);\n\tif (btc_dpm_enabled(rdev))\n\t\treturn -EINVAL;\n\tif (pi->mg_clock_gating)\n\t\tni_mg_clockgating_default(rdev);\n\tif (eg_pi->ls_clock_gating)\n\t\tni_ls_clockgating_default(rdev);\n\tif (pi->voltage_control) {\n\t\trv770_enable_voltage_control(rdev, true);\n\t\tret = cypress_construct_voltage_tables(rdev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"cypress_construct_voltage_tables failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = ni_initialize_mc_reg_table(rdev);\n\t\tif (ret)\n\t\t\teg_pi->dynamic_ac_timing = false;\n\t}\n\tif (pi->dynamic_ss)\n\t\tcypress_enable_spread_spectrum(rdev, true);\n\tif (pi->thermal_protection)\n\t\trv770_enable_thermal_protection(rdev, true);\n\trv770_setup_bsp(rdev);\n\trv770_program_git(rdev);\n\trv770_program_tp(rdev);\n\trv770_program_tpp(rdev);\n\trv770_program_sstp(rdev);\n\tcypress_enable_display_gap(rdev);\n\trv770_program_vc(rdev);\n\tif (pi->dynamic_pcie_gen2)\n\t\tni_enable_dynamic_pcie_gen2(rdev, true);\n\tret = rv770_upload_firmware(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_upload_firmware failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_process_firmware_header(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_process_firmware_header failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_initial_switch_from_arb_f0_to_f1(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_initial_switch_from_arb_f0_to_f1 failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_init_smc_table(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_init_smc_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_init_smc_spll_table(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_init_smc_spll_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_init_arb_table_index(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_init_arb_table_index failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = ni_populate_mc_reg_table(rdev, boot_ps);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"ni_populate_mc_reg_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = ni_initialize_smc_cac_tables(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_initialize_smc_cac_tables failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_initialize_hardware_cac_manager(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_initialize_hardware_cac_manager failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_populate_smc_tdp_limits(rdev, boot_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_populate_smc_tdp_limits failed\\n\");\n\t\treturn ret;\n\t}\n\tni_program_response_times(rdev);\n\tr7xx_start_smc(rdev);\n\tret = cypress_notify_smc_display_change(rdev, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"cypress_notify_smc_display_change failed\\n\");\n\t\treturn ret;\n\t}\n\tcypress_enable_sclk_control(rdev, true);\n\tif (eg_pi->memory_transition)\n\t\tcypress_enable_mclk_control(rdev, true);\n\tcypress_start_dpm(rdev);\n\tif (pi->gfx_clock_gating)\n\t\tni_gfx_clockgating_enable(rdev, true);\n\tif (pi->mg_clock_gating)\n\t\tni_mg_clockgating_enable(rdev, true);\n\tif (eg_pi->ls_clock_gating)\n\t\tni_ls_clockgating_enable(rdev, true);\n\n\trv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\n\n\tni_update_current_ps(rdev, boot_ps);\n\n\treturn 0;\n}\n\nvoid ni_dpm_disable(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\n\tif (!btc_dpm_enabled(rdev))\n\t\treturn;\n\trv770_clear_vc(rdev);\n\tif (pi->thermal_protection)\n\t\trv770_enable_thermal_protection(rdev, false);\n\tni_enable_power_containment(rdev, boot_ps, false);\n\tni_enable_smc_cac(rdev, boot_ps, false);\n\tcypress_enable_spread_spectrum(rdev, false);\n\trv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, false);\n\tif (pi->dynamic_pcie_gen2)\n\t\tni_enable_dynamic_pcie_gen2(rdev, false);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\tif (pi->gfx_clock_gating)\n\t\tni_gfx_clockgating_enable(rdev, false);\n\tif (pi->mg_clock_gating)\n\t\tni_mg_clockgating_enable(rdev, false);\n\tif (eg_pi->ls_clock_gating)\n\t\tni_ls_clockgating_enable(rdev, false);\n\tni_stop_dpm(rdev);\n\tbtc_reset_to_default(rdev);\n\tni_stop_smc(rdev);\n\tni_force_switch_to_arb_f0(rdev);\n\n\tni_update_current_ps(rdev, boot_ps);\n}\n\nstatic int ni_power_control_set_level(struct radeon_device *rdev)\n{\n\tstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\n\tint ret;\n\n\tret = ni_restrict_performance_levels_before_switch(rdev);\n\tif (ret)\n\t\treturn ret;\n\tret = rv770_halt_smc(rdev);\n\tif (ret)\n\t\treturn ret;\n\tret = ni_populate_smc_tdp_limits(rdev, new_ps);\n\tif (ret)\n\t\treturn ret;\n\tret = rv770_resume_smc(rdev);\n\tif (ret)\n\t\treturn ret;\n\tret = rv770_set_sw_state(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint ni_dpm_pre_set_power_state(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *new_ps = &requested_ps;\n\n\tni_update_requested_ps(rdev, new_ps);\n\n\tni_apply_state_adjust_rules(rdev, &eg_pi->requested_rps);\n\n\treturn 0;\n}\n\nint ni_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &eg_pi->requested_rps;\n\tstruct radeon_ps *old_ps = &eg_pi->current_rps;\n\tint ret;\n\n\tret = ni_restrict_performance_levels_before_switch(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_restrict_performance_levels_before_switch failed\\n\");\n\t\treturn ret;\n\t}\n\tni_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\tret = ni_enable_power_containment(rdev, new_ps, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_enable_power_containment failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_enable_smc_cac(rdev, new_ps, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_enable_smc_cac failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_halt_smc(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_halt_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->smu_uvd_hs)\n\t\tbtc_notify_uvd_to_smc(rdev, new_ps);\n\tret = ni_upload_sw_state(rdev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_upload_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = ni_upload_mc_reg_table(rdev, new_ps);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"ni_upload_mc_reg_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = ni_program_memory_timing_parameters(rdev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_program_memory_timing_parameters failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_resume_smc(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_resume_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_set_sw_state(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_set_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tni_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\tret = ni_enable_smc_cac(rdev, new_ps, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_enable_smc_cac failed\\n\");\n\t\treturn ret;\n\t}\n\tret = ni_enable_power_containment(rdev, new_ps, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_enable_power_containment failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ni_power_control_set_level(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"ni_power_control_set_level failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ni_dpm_post_set_power_state(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &eg_pi->requested_rps;\n\n\tni_update_current_ps(rdev, new_ps);\n}\n\n#if 0\nvoid ni_dpm_reset_asic(struct radeon_device *rdev)\n{\n\tni_restrict_performance_levels_before_switch(rdev);\n\trv770_set_boot_state(rdev);\n}\n#endif\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void ni_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *rps,\n\t\t\t\t\t  struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t  u8 table_rev)\n{\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else if (r600_is_uvd_state(rps->class, rps->class2)) {\n\t\trps->vclk = RV770_DEFAULT_VCLK_FREQ;\n\t\trps->dclk = RV770_DEFAULT_DCLK_FREQ;\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\trdev->pm.dpm.boot_ps = rps;\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void ni_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_ps *rps, int index,\n\t\t\t\t      union pplib_clock_info *clock_info)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_ps *ps = ni_get_ps(rps);\n\tstruct rv7xx_pl *pl = &ps->performance_levels[index];\n\n\tps->performance_level_count = index + 1;\n\n\tpl->sclk = le16_to_cpu(clock_info->evergreen.usEngineClockLow);\n\tpl->sclk |= clock_info->evergreen.ucEngineClockHigh << 16;\n\tpl->mclk = le16_to_cpu(clock_info->evergreen.usMemoryClockLow);\n\tpl->mclk |= clock_info->evergreen.ucMemoryClockHigh << 16;\n\n\tpl->vddc = le16_to_cpu(clock_info->evergreen.usVDDC);\n\tpl->vddci = le16_to_cpu(clock_info->evergreen.usVDDCI);\n\tpl->flags = le32_to_cpu(clock_info->evergreen.ulFlags);\n\n\t \n\tif (pl->vddc == 0xff01) {\n\t\tif (pi->max_vddc)\n\t\t\tpl->vddc = pi->max_vddc;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) {\n\t\tpi->acpi_vddc = pl->vddc;\n\t\teg_pi->acpi_vddci = pl->vddci;\n\t\tif (ps->performance_levels[0].flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\n\t\t\tpi->acpi_pcie_gen2 = true;\n\t\telse\n\t\t\tpi->acpi_pcie_gen2 = false;\n\t}\n\n\tif (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) {\n\t\teg_pi->ulv.supported = true;\n\t\teg_pi->ulv.pl = pl;\n\t}\n\n\tif (pi->min_vddc_in_table > pl->vddc)\n\t\tpi->min_vddc_in_table = pl->vddc;\n\n\tif (pi->max_vddc_in_table < pl->vddc)\n\t\tpi->max_vddc_in_table = pl->vddc;\n\n\t \n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\tu16 vddc, vddci, mvdd;\n\t\tradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\n\t\tpl->mclk = rdev->clock.default_mclk;\n\t\tpl->sclk = rdev->clock.default_sclk;\n\t\tpl->vddc = vddc;\n\t\tpl->vddci = vddci;\n\t}\n\n\tif ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==\n\t    ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk = pl->sclk;\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.mclk = pl->mclk;\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddc = pl->vddc;\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddci = pl->vddci;\n\t}\n}\n\nstatic int ni_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j;\n\tunion pplib_clock_info *clock_info;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tstruct ni_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\trdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\n\t\tpower_state = (union pplib_power_state *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset) +\n\t\t\t i * power_info->pplib.ucStateEntrySize);\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\n\t\t\t (power_state->v1.ucNonClockStateIndex *\n\t\t\t  power_info->pplib.ucNonClockSize));\n\t\tif (power_info->pplib.ucStateEntrySize - 1) {\n\t\t\tu8 *idx;\n\t\t\tps = kzalloc(sizeof(struct ni_ps), GFP_KERNEL);\n\t\t\tif (ps == NULL) {\n\t\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\t\tni_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\t\t non_clock_info,\n\t\t\t\t\t\t\t power_info->pplib.ucNonClockSize);\n\t\t\tidx = (u8 *)&power_state->v1.ucClockStateIndices[0];\n\t\t\tfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\n\t\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\n\t\t\t\t\t (idx[j] * power_info->pplib.ucClockInfoSize));\n\t\t\t\tni_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t\t  &rdev->pm.dpm.ps[i], j,\n\t\t\t\t\t\t\t  clock_info);\n\t\t\t}\n\t\t}\n\t}\n\trdev->pm.dpm.num_ps = power_info->pplib.ucNumStates;\n\treturn 0;\n}\n\nint ni_dpm_init(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi;\n\tstruct evergreen_power_info *eg_pi;\n\tstruct ni_power_info *ni_pi;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\tni_pi = kzalloc(sizeof(struct ni_power_info), GFP_KERNEL);\n\tif (ni_pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = ni_pi;\n\teg_pi = &ni_pi->eg;\n\tpi = &eg_pi->rv7xx;\n\n\trv770_get_max_vddc(rdev);\n\n\teg_pi->ulv.supported = false;\n\tpi->acpi_vddc = 0;\n\teg_pi->acpi_vddci = 0;\n\tpi->min_vddc_in_table = 0;\n\tpi->max_vddc_in_table = 0;\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ni_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\tret = r600_parse_extended_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =\n\t\tkcalloc(4,\n\t\t\tsizeof(struct radeon_clock_voltage_dependency_entry),\n\t\t\tGFP_KERNEL);\n\tif (!rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {\n\t\tr600_free_extended_power_table(rdev);\n\t\treturn -ENOMEM;\n\t}\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 720;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 810;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;\n\trdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 900;\n\n\tni_patch_dependency_tables_based_on_leakage(rdev);\n\n\tif (rdev->pm.dpm.voltage_response_time == 0)\n\t\trdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\n\tif (rdev->pm.dpm.backbias_response_time == 0)\n\t\trdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     0, false, &dividers);\n\tif (ret)\n\t\tpi->ref_div = dividers.ref_div + 1;\n\telse\n\t\tpi->ref_div = R600_REFERENCEDIVIDER_DFLT;\n\n\tpi->rlp = RV770_RLP_DFLT;\n\tpi->rmp = RV770_RMP_DFLT;\n\tpi->lhp = RV770_LHP_DFLT;\n\tpi->lmp = RV770_LMP_DFLT;\n\n\teg_pi->ats[0].rlp = RV770_RLP_DFLT;\n\teg_pi->ats[0].rmp = RV770_RMP_DFLT;\n\teg_pi->ats[0].lhp = RV770_LHP_DFLT;\n\teg_pi->ats[0].lmp = RV770_LMP_DFLT;\n\n\teg_pi->ats[1].rlp = BTC_RLP_UVD_DFLT;\n\teg_pi->ats[1].rmp = BTC_RMP_UVD_DFLT;\n\teg_pi->ats[1].lhp = BTC_LHP_UVD_DFLT;\n\teg_pi->ats[1].lmp = BTC_LMP_UVD_DFLT;\n\n\teg_pi->smu_uvd_hs = true;\n\n\tif (rdev->pdev->device == 0x6707) {\n\t\tpi->mclk_strobe_mode_threshold = 55000;\n\t\tpi->mclk_edc_enable_threshold = 55000;\n\t\teg_pi->mclk_edc_wr_enable_threshold = 55000;\n\t} else {\n\t\tpi->mclk_strobe_mode_threshold = 40000;\n\t\tpi->mclk_edc_enable_threshold = 40000;\n\t\teg_pi->mclk_edc_wr_enable_threshold = 40000;\n\t}\n\tni_pi->mclk_rtt_mode_threshold = eg_pi->mclk_edc_wr_enable_threshold;\n\n\tpi->voltage_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\n\n\tpi->mvdd_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);\n\n\teg_pi->vddci_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0);\n\n\trv770_get_engine_memory_ss(rdev);\n\n\tpi->asi = RV770_ASI_DFLT;\n\tpi->pasi = CYPRESS_HASI_DFLT;\n\tpi->vrc = CYPRESS_VRC_DFLT;\n\n\tpi->power_gating = false;\n\n\tpi->gfx_clock_gating = true;\n\n\tpi->mg_clock_gating = true;\n\tpi->mgcgtssm = true;\n\teg_pi->ls_clock_gating = false;\n\teg_pi->sclk_deep_sleep = false;\n\n\tpi->dynamic_pcie_gen2 = true;\n\n\tif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\n\t\tpi->thermal_protection = true;\n\telse\n\t\tpi->thermal_protection = false;\n\n\tpi->display_gap = true;\n\n\tpi->dcodt = true;\n\n\tpi->ulps = true;\n\n\teg_pi->dynamic_ac_timing = true;\n\teg_pi->abm = true;\n\teg_pi->mcls = true;\n\teg_pi->light_sleep = true;\n\teg_pi->memory_transition = true;\n#if defined(CONFIG_ACPI)\n\teg_pi->pcie_performance_request =\n\t\tradeon_acpi_is_pcie_performance_request_supported(rdev);\n#else\n\teg_pi->pcie_performance_request = false;\n#endif\n\n\teg_pi->dll_default_on = false;\n\n\teg_pi->sclk_deep_sleep = false;\n\n\tpi->mclk_stutter_mode_threshold = 0;\n\n\tpi->sram_end = SMC_RAM_END;\n\n\trdev->pm.dpm.dyn_state.mclk_sclk_ratio = 3;\n\trdev->pm.dpm.dyn_state.vddc_vddci_delta = 200;\n\trdev->pm.dpm.dyn_state.min_vddc_for_pcie_gen2 = 900;\n\trdev->pm.dpm.dyn_state.valid_sclk_values.count = ARRAY_SIZE(btc_valid_sclk);\n\trdev->pm.dpm.dyn_state.valid_sclk_values.values = btc_valid_sclk;\n\trdev->pm.dpm.dyn_state.valid_mclk_values.count = 0;\n\trdev->pm.dpm.dyn_state.valid_mclk_values.values = NULL;\n\trdev->pm.dpm.dyn_state.sclk_mclk_delta = 12500;\n\n\tni_pi->cac_data.leakage_coefficients.at = 516;\n\tni_pi->cac_data.leakage_coefficients.bt = 18;\n\tni_pi->cac_data.leakage_coefficients.av = 51;\n\tni_pi->cac_data.leakage_coefficients.bv = 2957;\n\n\tswitch (rdev->pdev->device) {\n\tcase 0x6700:\n\tcase 0x6701:\n\tcase 0x6702:\n\tcase 0x6703:\n\tcase 0x6718:\n\t\tni_pi->cac_weights = &cac_weights_cayman_xt;\n\t\tbreak;\n\tcase 0x6705:\n\tcase 0x6719:\n\tcase 0x671D:\n\tcase 0x671C:\n\tdefault:\n\t\tni_pi->cac_weights = &cac_weights_cayman_pro;\n\t\tbreak;\n\tcase 0x6704:\n\tcase 0x6706:\n\tcase 0x6707:\n\tcase 0x6708:\n\tcase 0x6709:\n\t\tni_pi->cac_weights = &cac_weights_cayman_le;\n\t\tbreak;\n\t}\n\n\tif (ni_pi->cac_weights->enable_power_containment_by_default) {\n\t\tni_pi->enable_power_containment = true;\n\t\tni_pi->enable_cac = true;\n\t\tni_pi->enable_sq_ramping = true;\n\t} else {\n\t\tni_pi->enable_power_containment = false;\n\t\tni_pi->enable_cac = false;\n\t\tni_pi->enable_sq_ramping = false;\n\t}\n\n\tni_pi->driver_calculate_cac_leakage = false;\n\tni_pi->cac_configuration_required = true;\n\n\tif (ni_pi->cac_configuration_required) {\n\t\tni_pi->support_cac_long_term_average = true;\n\t\tni_pi->lta_window_size = ni_pi->cac_weights->l2_lta_window_size;\n\t\tni_pi->lts_truncate = ni_pi->cac_weights->lts_truncate;\n\t} else {\n\t\tni_pi->support_cac_long_term_average = false;\n\t\tni_pi->lta_window_size = 0;\n\t\tni_pi->lts_truncate = 0;\n\t}\n\n\tni_pi->use_power_boost_limit = true;\n\n\t \n\tif ((rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk == 0) ||\n\t    (rdev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk == 0))\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_dc =\n\t\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\n\n\treturn 0;\n}\n\nvoid ni_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n\tkfree(rdev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);\n\tr600_free_extended_power_table(rdev);\n}\n\nvoid ni_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t      struct radeon_ps *rps)\n{\n\tstruct ni_ps *ps = ni_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tint i;\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tpl = &ps->performance_levels[i];\n\t\tif (rdev->family >= CHIP_TAHITI)\n\t\t\tprintk(\"\\t\\tpower level %d    sclk: %u mclk: %u vddc: %u vddci: %u pcie gen: %u\\n\",\n\t\t\t       i, pl->sclk, pl->mclk, pl->vddc, pl->vddci, pl->pcie_gen + 1);\n\t\telse\n\t\t\tprintk(\"\\t\\tpower level %d    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t\t       i, pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t}\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid ni_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t    struct seq_file *m)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *rps = &eg_pi->current_rps;\n\tstruct ni_ps *ps = ni_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_INDEX_MASK) >>\n\t\tCURRENT_STATE_INDEX_SHIFT;\n\n\tif (current_index >= ps->performance_level_count) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tpl = &ps->performance_levels[current_index];\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tseq_printf(m, \"power level %d    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t\t   current_index, pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t}\n}\n\nu32 ni_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *rps = &eg_pi->current_rps;\n\tstruct ni_ps *ps = ni_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_INDEX_MASK) >>\n\t\tCURRENT_STATE_INDEX_SHIFT;\n\n\tif (current_index >= ps->performance_level_count) {\n\t\treturn 0;\n\t} else {\n\t\tpl = &ps->performance_levels[current_index];\n\t\treturn pl->sclk;\n\t}\n}\n\nu32 ni_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *rps = &eg_pi->current_rps;\n\tstruct ni_ps *ps = ni_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_INDEX_MASK) >>\n\t\tCURRENT_STATE_INDEX_SHIFT;\n\n\tif (current_index >= ps->performance_level_count) {\n\t\treturn 0;\n\t} else {\n\t\tpl = &ps->performance_levels[current_index];\n\t\treturn pl->mclk;\n\t}\n}\n\nu32 ni_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_ps *requested_state = ni_get_ps(&eg_pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->performance_levels[0].sclk;\n\telse\n\t\treturn requested_state->performance_levels[requested_state->performance_level_count - 1].sclk;\n}\n\nu32 ni_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct ni_ps *requested_state = ni_get_ps(&eg_pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->performance_levels[0].mclk;\n\telse\n\t\treturn requested_state->performance_levels[requested_state->performance_level_count - 1].mclk;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}