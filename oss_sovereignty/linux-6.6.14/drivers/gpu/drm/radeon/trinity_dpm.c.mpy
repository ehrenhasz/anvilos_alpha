{
  "module_name": "trinity_dpm.c",
  "hash_id": "9dc665a358b630ef24363c2cf760cd06c1add1f3d6fb0c546c9e4f166450a4fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/trinity_dpm.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n\n#include \"r600_dpm.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"trinity_dpm.h\"\n#include \"trinityd.h\"\n#include \"vce.h\"\n\n#define TRINITY_MAX_DEEPSLEEP_DIVIDER_ID 5\n#define TRINITY_MINIMUM_ENGINE_CLOCK 800\n#define SCLK_MIN_DIV_INTV_SHIFT     12\n#define TRINITY_DISPCLK_BYPASS_THRESHOLD 10000\n\n#ifndef TRINITY_MGCG_SEQUENCE\n#define TRINITY_MGCG_SEQUENCE  100\n\nstatic const u32 trinity_mgcg_shls_default[] =\n{\n\t \n\t0x0000802c, 0xc0000000, 0xffffffff,\n\t0x00003fc4, 0xc0000000, 0xffffffff,\n\t0x00005448, 0x00000100, 0xffffffff,\n\t0x000055e4, 0x00000100, 0xffffffff,\n\t0x0000160c, 0x00000100, 0xffffffff,\n\t0x00008984, 0x06000100, 0xffffffff,\n\t0x0000c164, 0x00000100, 0xffffffff,\n\t0x00008a18, 0x00000100, 0xffffffff,\n\t0x0000897c, 0x06000100, 0xffffffff,\n\t0x00008b28, 0x00000100, 0xffffffff,\n\t0x00009144, 0x00800200, 0xffffffff,\n\t0x00009a60, 0x00000100, 0xffffffff,\n\t0x00009868, 0x00000100, 0xffffffff,\n\t0x00008d58, 0x00000100, 0xffffffff,\n\t0x00009510, 0x00000100, 0xffffffff,\n\t0x0000949c, 0x00000100, 0xffffffff,\n\t0x00009654, 0x00000100, 0xffffffff,\n\t0x00009030, 0x00000100, 0xffffffff,\n\t0x00009034, 0x00000100, 0xffffffff,\n\t0x00009038, 0x00000100, 0xffffffff,\n\t0x0000903c, 0x00000100, 0xffffffff,\n\t0x00009040, 0x00000100, 0xffffffff,\n\t0x0000a200, 0x00000100, 0xffffffff,\n\t0x0000a204, 0x00000100, 0xffffffff,\n\t0x0000a208, 0x00000100, 0xffffffff,\n\t0x0000a20c, 0x00000100, 0xffffffff,\n\t0x00009744, 0x00000100, 0xffffffff,\n\t0x00003f80, 0x00000100, 0xffffffff,\n\t0x0000a210, 0x00000100, 0xffffffff,\n\t0x0000a214, 0x00000100, 0xffffffff,\n\t0x000004d8, 0x00000100, 0xffffffff,\n\t0x00009664, 0x00000100, 0xffffffff,\n\t0x00009698, 0x00000100, 0xffffffff,\n\t0x000004d4, 0x00000200, 0xffffffff,\n\t0x000004d0, 0x00000000, 0xffffffff,\n\t0x000030cc, 0x00000104, 0xffffffff,\n\t0x0000d0c0, 0x00000100, 0xffffffff,\n\t0x0000d8c0, 0x00000100, 0xffffffff,\n\t0x0000951c, 0x00010000, 0xffffffff,\n\t0x00009160, 0x00030002, 0xffffffff,\n\t0x00009164, 0x00050004, 0xffffffff,\n\t0x00009168, 0x00070006, 0xffffffff,\n\t0x00009178, 0x00070000, 0xffffffff,\n\t0x0000917c, 0x00030002, 0xffffffff,\n\t0x00009180, 0x00050004, 0xffffffff,\n\t0x0000918c, 0x00010006, 0xffffffff,\n\t0x00009190, 0x00090008, 0xffffffff,\n\t0x00009194, 0x00070000, 0xffffffff,\n\t0x00009198, 0x00030002, 0xffffffff,\n\t0x0000919c, 0x00050004, 0xffffffff,\n\t0x000091a8, 0x00010006, 0xffffffff,\n\t0x000091ac, 0x00090008, 0xffffffff,\n\t0x000091b0, 0x00070000, 0xffffffff,\n\t0x000091b4, 0x00030002, 0xffffffff,\n\t0x000091b8, 0x00050004, 0xffffffff,\n\t0x000091c4, 0x00010006, 0xffffffff,\n\t0x000091c8, 0x00090008, 0xffffffff,\n\t0x000091cc, 0x00070000, 0xffffffff,\n\t0x000091d0, 0x00030002, 0xffffffff,\n\t0x000091d4, 0x00050004, 0xffffffff,\n\t0x000091e0, 0x00010006, 0xffffffff,\n\t0x000091e4, 0x00090008, 0xffffffff,\n\t0x000091e8, 0x00000000, 0xffffffff,\n\t0x000091ec, 0x00070000, 0xffffffff,\n\t0x000091f0, 0x00030002, 0xffffffff,\n\t0x000091f4, 0x00050004, 0xffffffff,\n\t0x00009200, 0x00010006, 0xffffffff,\n\t0x00009204, 0x00090008, 0xffffffff,\n\t0x00009208, 0x00070000, 0xffffffff,\n\t0x0000920c, 0x00030002, 0xffffffff,\n\t0x00009210, 0x00050004, 0xffffffff,\n\t0x0000921c, 0x00010006, 0xffffffff,\n\t0x00009220, 0x00090008, 0xffffffff,\n\t0x00009294, 0x00000000, 0xffffffff\n};\n#endif\n\n#ifndef TRINITY_SYSLS_SEQUENCE\n#define TRINITY_SYSLS_SEQUENCE  100\n\nstatic const u32 trinity_sysls_disable[] =\n{\n\t \n\t0x0000d0c0, 0x00000000, 0xffffffff,\n\t0x0000d8c0, 0x00000000, 0xffffffff,\n\t0x000055e8, 0x00000000, 0xffffffff,\n\t0x0000d0bc, 0x00000000, 0xffffffff,\n\t0x0000d8bc, 0x00000000, 0xffffffff,\n\t0x000015c0, 0x00041401, 0xffffffff,\n\t0x0000264c, 0x00040400, 0xffffffff,\n\t0x00002648, 0x00040400, 0xffffffff,\n\t0x00002650, 0x00040400, 0xffffffff,\n\t0x000020b8, 0x00040400, 0xffffffff,\n\t0x000020bc, 0x00040400, 0xffffffff,\n\t0x000020c0, 0x00040c80, 0xffffffff,\n\t0x0000f4a0, 0x000000c0, 0xffffffff,\n\t0x0000f4a4, 0x00680000, 0xffffffff,\n\t0x00002f50, 0x00000404, 0xffffffff,\n\t0x000004c8, 0x00000001, 0xffffffff,\n\t0x0000641c, 0x00007ffd, 0xffffffff,\n\t0x00000c7c, 0x0000ff00, 0xffffffff,\n\t0x00006dfc, 0x0000007f, 0xffffffff\n};\n\nstatic const u32 trinity_sysls_enable[] =\n{\n\t \n\t0x000055e8, 0x00000001, 0xffffffff,\n\t0x0000d0bc, 0x00000100, 0xffffffff,\n\t0x0000d8bc, 0x00000100, 0xffffffff,\n\t0x000015c0, 0x000c1401, 0xffffffff,\n\t0x0000264c, 0x000c0400, 0xffffffff,\n\t0x00002648, 0x000c0400, 0xffffffff,\n\t0x00002650, 0x000c0400, 0xffffffff,\n\t0x000020b8, 0x000c0400, 0xffffffff,\n\t0x000020bc, 0x000c0400, 0xffffffff,\n\t0x000020c0, 0x000c0c80, 0xffffffff,\n\t0x0000f4a0, 0x000000c0, 0xffffffff,\n\t0x0000f4a4, 0x00680fff, 0xffffffff,\n\t0x00002f50, 0x00000903, 0xffffffff,\n\t0x000004c8, 0x00000000, 0xffffffff,\n\t0x0000641c, 0x00000000, 0xffffffff,\n\t0x00000c7c, 0x00000000, 0xffffffff,\n\t0x00006dfc, 0x00000000, 0xffffffff\n};\n#endif\n\nstatic const u32 trinity_override_mgpg_sequences[] =\n{\n\t \n\t0x00000200, 0xE030032C,\n\t0x00000204, 0x00000FFF,\n\t0x00000200, 0xE0300058,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE0300054,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE0300074,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE0300070,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE0300090,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE030008C,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE03000AC,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE03000A8,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE03000C8,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE03000C4,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE03000E4,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE03000E0,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE0300100,\n\t0x00000204, 0x00030301,\n\t0x00000200, 0xE03000FC,\n\t0x00000204, 0x500010FF,\n\t0x00000200, 0xE0300058,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE0300054,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE0300074,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE0300070,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE0300090,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE030008C,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE03000AC,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000A8,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE03000C8,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000C4,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE03000E4,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000E0,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE0300100,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000FC,\n\t0x00000204, 0x600010FF,\n\t0x00000200, 0xE0300058,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE0300054,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE0300074,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE0300070,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE0300090,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE030008C,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE03000AC,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000A8,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE03000C8,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000C4,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE03000E4,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000E0,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE0300100,\n\t0x00000204, 0x00030303,\n\t0x00000200, 0xE03000FC,\n\t0x00000204, 0x700010FF,\n\t0x00000200, 0xE0300058,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE0300054,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0xE0300074,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE0300070,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0xE0300090,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE030008C,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0xE03000AC,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE03000A8,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0xE03000C4,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0xE03000C8,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE03000E4,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE03000E0,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0xE0300100,\n\t0x00000204, 0x00010303,\n\t0x00000200, 0xE03000FC,\n\t0x00000204, 0x800010FF,\n\t0x00000200, 0x0001f198,\n\t0x00000204, 0x0003ffff,\n\t0x00000200, 0x0001f19C,\n\t0x00000204, 0x3fffffff,\n\t0x00000200, 0xE030032C,\n\t0x00000204, 0x00000000,\n};\n\nstatic void trinity_program_clk_gating_hw_sequence(struct radeon_device *rdev,\n\t\t\t\t\t\t   const u32 *seq, u32 count);\nstatic void trinity_override_dynamic_mg_powergating(struct radeon_device *rdev);\nstatic void trinity_apply_state_adjust_rules(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *new_rps,\n\t\t\t\t\t     struct radeon_ps *old_rps);\n\nstatic struct trinity_ps *trinity_get_ps(struct radeon_ps *rps)\n{\n\tstruct trinity_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstatic struct trinity_power_info *trinity_get_pi(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic void trinity_gfx_powergating_initialize(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 p, u;\n\tu32 value;\n\tstruct atom_clock_dividers dividers;\n\tu32 xclk = radeon_get_xclk(rdev);\n\tu32 sssd = 1;\n\tint ret;\n\tu32 hw_rev = (RREG32(HW_REV) & ATI_REV_ID_MASK) >> ATI_REV_ID_SHIFT;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     25000, false, &dividers);\n\tif (ret)\n\t\treturn;\n\n\tvalue = RREG32_SMC(GFX_POWER_GATING_CNTL);\n\tvalue &= ~(SSSD_MASK | PDS_DIV_MASK);\n\tif (sssd)\n\t\tvalue |= SSSD(1);\n\tvalue |= PDS_DIV(dividers.post_div);\n\tWREG32_SMC(GFX_POWER_GATING_CNTL, value);\n\n\tr600_calculate_u_and_p(500, xclk, 16, &p, &u);\n\n\tWREG32(CG_PG_CTRL, SP(p) | SU(u));\n\n\tWREG32_P(CG_GIPOTS, CG_GIPOT(p), ~CG_GIPOT_MASK);\n\n\t \n\tif (pi->override_dynamic_mgpg && (hw_rev == 0))\n\t\ttrinity_override_dynamic_mg_powergating(rdev);\n\n}\n\n#define CGCG_CGTT_LOCAL0_MASK       0xFFFF33FF\n#define CGCG_CGTT_LOCAL1_MASK       0xFFFB0FFE\n#define CGTS_SM_CTRL_REG_DISABLE    0x00600000\n#define CGTS_SM_CTRL_REG_ENABLE     0x96944200\n\nstatic void trinity_mg_clockgating_enable(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tu32 local0;\n\tu32 local1;\n\n\tif (enable) {\n\t\tlocal0 = RREG32_CG(CG_CGTT_LOCAL_0);\n\t\tlocal1 = RREG32_CG(CG_CGTT_LOCAL_1);\n\n\t\tWREG32_CG(CG_CGTT_LOCAL_0,\n\t\t\t  (0x00380000 & CGCG_CGTT_LOCAL0_MASK) | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\n\t\tWREG32_CG(CG_CGTT_LOCAL_1,\n\t\t\t  (0x0E000000 & CGCG_CGTT_LOCAL1_MASK) | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\n\n\t\tWREG32(CGTS_SM_CTRL_REG, CGTS_SM_CTRL_REG_ENABLE);\n\t} else {\n\t\tWREG32(CGTS_SM_CTRL_REG, CGTS_SM_CTRL_REG_DISABLE);\n\n\t\tlocal0 = RREG32_CG(CG_CGTT_LOCAL_0);\n\t\tlocal1 = RREG32_CG(CG_CGTT_LOCAL_1);\n\n\t\tWREG32_CG(CG_CGTT_LOCAL_0,\n\t\t\t  CGCG_CGTT_LOCAL0_MASK | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\n\t\tWREG32_CG(CG_CGTT_LOCAL_1,\n\t\t\t  CGCG_CGTT_LOCAL1_MASK | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\n\t}\n}\n\nstatic void trinity_mg_clockgating_initialize(struct radeon_device *rdev)\n{\n\tu32 count;\n\tconst u32 *seq = NULL;\n\n\tseq = &trinity_mgcg_shls_default[0];\n\tcount = sizeof(trinity_mgcg_shls_default) / (3 * sizeof(u32));\n\n\ttrinity_program_clk_gating_hw_sequence(rdev, seq, count);\n}\n\nstatic void trinity_gfx_clockgating_enable(struct radeon_device *rdev,\n\t\t\t\t\t   bool enable)\n{\n\tif (enable) {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\n\t} else {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\t\tRREG32(GB_ADDR_CONFIG);\n\t}\n}\n\nstatic void trinity_program_clk_gating_hw_sequence(struct radeon_device *rdev,\n\t\t\t\t\t\t   const u32 *seq, u32 count)\n{\n\tu32 i, length = count * 3;\n\n\tfor (i = 0; i < length; i += 3)\n\t\tWREG32_P(seq[i], seq[i+1], ~seq[i+2]);\n}\n\nstatic void trinity_program_override_mgpg_sequences(struct radeon_device *rdev,\n\t\t\t\t\t\t    const u32 *seq, u32 count)\n{\n\tu32  i, length = count * 2;\n\n\tfor (i = 0; i < length; i += 2)\n\t\tWREG32(seq[i], seq[i+1]);\n\n}\n\nstatic void trinity_override_dynamic_mg_powergating(struct radeon_device *rdev)\n{\n\tu32 count;\n\tconst u32 *seq = NULL;\n\n\tseq = &trinity_override_mgpg_sequences[0];\n\tcount = sizeof(trinity_override_mgpg_sequences) / (2 * sizeof(u32));\n\n\ttrinity_program_override_mgpg_sequences(rdev, seq, count);\n}\n\nstatic void trinity_ls_clockgating_enable(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tu32 count;\n\tconst u32 *seq = NULL;\n\n\tif (enable) {\n\t\tseq = &trinity_sysls_enable[0];\n\t\tcount = sizeof(trinity_sysls_enable) / (3 * sizeof(u32));\n\t} else {\n\t\tseq = &trinity_sysls_disable[0];\n\t\tcount = sizeof(trinity_sysls_disable) / (3 * sizeof(u32));\n\t}\n\n\ttrinity_program_clk_gating_hw_sequence(rdev, seq, count);\n}\n\nstatic void trinity_gfx_powergating_enable(struct radeon_device *rdev,\n\t\t\t\t\t   bool enable)\n{\n\tif (enable) {\n\t\tif (RREG32_SMC(CC_SMU_TST_EFUSE1_MISC) & RB_BACKEND_DISABLE_MASK)\n\t\t\tWREG32_SMC(SMU_SCRATCH_A, (RREG32_SMC(SMU_SCRATCH_A) | 0x01));\n\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_PWR_DOWN_EN, ~DYN_PWR_DOWN_EN);\n\t} else {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_PWR_DOWN_EN);\n\t\tRREG32(GB_ADDR_CONFIG);\n\t}\n}\n\nstatic void trinity_gfx_dynamic_mgpg_enable(struct radeon_device *rdev,\n\t\t\t\t\t    bool enable)\n{\n\tu32 value;\n\n\tif (enable) {\n\t\tvalue = RREG32_SMC(PM_I_CNTL_1);\n\t\tvalue &= ~DS_PG_CNTL_MASK;\n\t\tvalue |= DS_PG_CNTL(1);\n\t\tWREG32_SMC(PM_I_CNTL_1, value);\n\n\t\tvalue = RREG32_SMC(SMU_S_PG_CNTL);\n\t\tvalue &= ~DS_PG_EN_MASK;\n\t\tvalue |= DS_PG_EN(1);\n\t\tWREG32_SMC(SMU_S_PG_CNTL, value);\n\t} else {\n\t\tvalue = RREG32_SMC(SMU_S_PG_CNTL);\n\t\tvalue &= ~DS_PG_EN_MASK;\n\t\tWREG32_SMC(SMU_S_PG_CNTL, value);\n\n\t\tvalue = RREG32_SMC(PM_I_CNTL_1);\n\t\tvalue &= ~DS_PG_CNTL_MASK;\n\t\tWREG32_SMC(PM_I_CNTL_1, value);\n\t}\n\n\ttrinity_gfx_dynamic_mgpg_config(rdev);\n\n}\n\nstatic void trinity_enable_clock_power_gating(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (pi->enable_gfx_clock_gating)\n\t\tsumo_gfx_clockgating_initialize(rdev);\n\tif (pi->enable_mg_clock_gating)\n\t\ttrinity_mg_clockgating_initialize(rdev);\n\tif (pi->enable_gfx_power_gating)\n\t\ttrinity_gfx_powergating_initialize(rdev);\n\tif (pi->enable_mg_clock_gating) {\n\t\ttrinity_ls_clockgating_enable(rdev, true);\n\t\ttrinity_mg_clockgating_enable(rdev, true);\n\t}\n\tif (pi->enable_gfx_clock_gating)\n\t\ttrinity_gfx_clockgating_enable(rdev, true);\n\tif (pi->enable_gfx_dynamic_mgpg)\n\t\ttrinity_gfx_dynamic_mgpg_enable(rdev, true);\n\tif (pi->enable_gfx_power_gating)\n\t\ttrinity_gfx_powergating_enable(rdev, true);\n}\n\nstatic void trinity_disable_clock_power_gating(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (pi->enable_gfx_power_gating)\n\t\ttrinity_gfx_powergating_enable(rdev, false);\n\tif (pi->enable_gfx_dynamic_mgpg)\n\t\ttrinity_gfx_dynamic_mgpg_enable(rdev, false);\n\tif (pi->enable_gfx_clock_gating)\n\t\ttrinity_gfx_clockgating_enable(rdev, false);\n\tif (pi->enable_mg_clock_gating) {\n\t\ttrinity_mg_clockgating_enable(rdev, false);\n\t\ttrinity_ls_clockgating_enable(rdev, false);\n\t}\n}\n\nstatic void trinity_set_divider_value(struct radeon_device *rdev,\n\t\t\t\t      u32 index, u32 sclk)\n{\n\tstruct atom_clock_dividers  dividers;\n\tint ret;\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     sclk, false, &dividers);\n\tif (ret)\n\t\treturn;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\n\tvalue &= ~CLK_DIVIDER_MASK;\n\tvalue |= CLK_DIVIDER(dividers.post_div);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     sclk/2, false, &dividers);\n\tif (ret)\n\t\treturn;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_PG_CNTL + ix);\n\tvalue &= ~PD_SCLK_DIVIDER_MASK;\n\tvalue |= PD_SCLK_DIVIDER(dividers.post_div);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_PG_CNTL + ix, value);\n}\n\nstatic void trinity_set_ds_dividers(struct radeon_device *rdev,\n\t\t\t\t    u32 index, u32 divider)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\n\tvalue &= ~DS_DIV_MASK;\n\tvalue |= DS_DIV(divider);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\n}\n\nstatic void trinity_set_ss_dividers(struct radeon_device *rdev,\n\t\t\t\t    u32 index, u32 divider)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\n\tvalue &= ~DS_SH_DIV_MASK;\n\tvalue |= DS_SH_DIV(divider);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\n}\n\nstatic void trinity_set_vid(struct radeon_device *rdev, u32 index, u32 vid)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 vid_7bit = sumo_convert_vid2_to_vid7(rdev, &pi->sys_info.vid_mapping_table, vid);\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\n\tvalue &= ~VID_MASK;\n\tvalue |= VID(vid_7bit);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\n\tvalue &= ~LVRT_MASK;\n\tvalue |= LVRT(0);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\n}\n\nstatic void trinity_set_allos_gnb_slow(struct radeon_device *rdev,\n\t\t\t\t       u32 index, u32 gnb_slow)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix);\n\tvalue &= ~GNB_SLOW_MASK;\n\tvalue |= GNB_SLOW(gnb_slow);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix, value);\n}\n\nstatic void trinity_set_force_nbp_state(struct radeon_device *rdev,\n\t\t\t\t\tu32 index, u32 force_nbp_state)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix);\n\tvalue &= ~FORCE_NBPS1_MASK;\n\tvalue |= FORCE_NBPS1(force_nbp_state);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_3 + ix, value);\n}\n\nstatic void trinity_set_display_wm(struct radeon_device *rdev,\n\t\t\t\t   u32 index, u32 wm)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\n\tvalue &= ~DISPLAY_WM_MASK;\n\tvalue |= DISPLAY_WM(wm);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\n}\n\nstatic void trinity_set_vce_wm(struct radeon_device *rdev,\n\t\t\t       u32 index, u32 wm)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix);\n\tvalue &= ~VCE_WM_MASK;\n\tvalue |= VCE_WM(wm);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_1 + ix, value);\n}\n\nstatic void trinity_set_at(struct radeon_device *rdev,\n\t\t\t   u32 index, u32 at)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_AT + ix);\n\tvalue &= ~AT_MASK;\n\tvalue |= AT(at);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_AT + ix, value);\n}\n\nstatic void trinity_program_power_level(struct radeon_device *rdev,\n\t\t\t\t\tstruct trinity_pl *pl, u32 index)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (index >= SUMO_MAX_HARDWARE_POWERLEVELS)\n\t\treturn;\n\n\ttrinity_set_divider_value(rdev, index, pl->sclk);\n\ttrinity_set_vid(rdev, index, pl->vddc_index);\n\ttrinity_set_ss_dividers(rdev, index, pl->ss_divider_index);\n\ttrinity_set_ds_dividers(rdev, index, pl->ds_divider_index);\n\ttrinity_set_allos_gnb_slow(rdev, index, pl->allow_gnb_slow);\n\ttrinity_set_force_nbp_state(rdev, index, pl->force_nbp_state);\n\ttrinity_set_display_wm(rdev, index, pl->display_wm);\n\ttrinity_set_vce_wm(rdev, index, pl->vce_wm);\n\ttrinity_set_at(rdev, index, pi->at[index]);\n}\n\nstatic void trinity_power_level_enable_disable(struct radeon_device *rdev,\n\t\t\t\t\t       u32 index, bool enable)\n{\n\tu32 value;\n\tu32 ix = index * TRINITY_SIZEOF_DPM_STATE_TABLE;\n\n\tvalue = RREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix);\n\tvalue &= ~STATE_VALID_MASK;\n\tif (enable)\n\t\tvalue |= STATE_VALID(1);\n\tWREG32_SMC(SMU_SCLK_DPM_STATE_0_CNTL_0 + ix, value);\n}\n\nstatic bool trinity_dpm_enabled(struct radeon_device *rdev)\n{\n\tif (RREG32_SMC(SMU_SCLK_DPM_CNTL) & SCLK_DPM_EN(1))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void trinity_start_dpm(struct radeon_device *rdev)\n{\n\tu32 value = RREG32_SMC(SMU_SCLK_DPM_CNTL);\n\n\tvalue &= ~(SCLK_DPM_EN_MASK | SCLK_DPM_BOOT_STATE_MASK | VOLTAGE_CHG_EN_MASK);\n\tvalue |= SCLK_DPM_EN(1) | SCLK_DPM_BOOT_STATE(0) | VOLTAGE_CHG_EN(1);\n\tWREG32_SMC(SMU_SCLK_DPM_CNTL, value);\n\n\tWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\n\tWREG32_P(CG_CG_VOLTAGE_CNTL, 0, ~EN);\n\n\ttrinity_dpm_config(rdev, true);\n}\n\nstatic void trinity_wait_for_dpm_enabled(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(SCLK_PWRMGT_CNTL) & DYNAMIC_PM_EN)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & TARGET_STATE_MASK) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void trinity_stop_dpm(struct radeon_device *rdev)\n{\n\tu32 sclk_dpm_cntl;\n\n\tWREG32_P(CG_CG_VOLTAGE_CNTL, EN, ~EN);\n\n\tsclk_dpm_cntl = RREG32_SMC(SMU_SCLK_DPM_CNTL);\n\tsclk_dpm_cntl &= ~(SCLK_DPM_EN_MASK | VOLTAGE_CHG_EN_MASK);\n\tWREG32_SMC(SMU_SCLK_DPM_CNTL, sclk_dpm_cntl);\n\n\ttrinity_dpm_config(rdev, false);\n}\n\nstatic void trinity_start_am(struct radeon_device *rdev)\n{\n\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~(RESET_SCLK_CNT | RESET_BUSY_CNT));\n}\n\nstatic void trinity_reset_am(struct radeon_device *rdev)\n{\n\tWREG32_P(SCLK_PWRMGT_CNTL, RESET_SCLK_CNT | RESET_BUSY_CNT,\n\t\t ~(RESET_SCLK_CNT | RESET_BUSY_CNT));\n}\n\nstatic void trinity_wait_for_level_0(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void trinity_enable_power_level_0(struct radeon_device *rdev)\n{\n\ttrinity_power_level_enable_disable(rdev, 0, true);\n}\n\nstatic void trinity_force_level_0(struct radeon_device *rdev)\n{\n\ttrinity_dpm_force_state(rdev, 0);\n}\n\nstatic void trinity_unforce_levels(struct radeon_device *rdev)\n{\n\ttrinity_dpm_no_forced_level(rdev);\n}\n\nstatic void trinity_program_power_levels_0_to_n(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct radeon_ps *new_rps,\n\t\t\t\t\t\tstruct radeon_ps *old_rps)\n{\n\tstruct trinity_ps *new_ps = trinity_get_ps(new_rps);\n\tstruct trinity_ps *old_ps = trinity_get_ps(old_rps);\n\tu32 i;\n\tu32 n_current_state_levels = (old_ps == NULL) ? 1 : old_ps->num_levels;\n\n\tfor (i = 0; i < new_ps->num_levels; i++) {\n\t\ttrinity_program_power_level(rdev, &new_ps->levels[i], i);\n\t\ttrinity_power_level_enable_disable(rdev, i, true);\n\t}\n\n\tfor (i = new_ps->num_levels; i < n_current_state_levels; i++)\n\t\ttrinity_power_level_enable_disable(rdev, i, false);\n}\n\nstatic void trinity_program_bootup_state(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 i;\n\n\ttrinity_program_power_level(rdev, &pi->boot_pl, 0);\n\ttrinity_power_level_enable_disable(rdev, 0, true);\n\n\tfor (i = 1; i < 8; i++)\n\t\ttrinity_power_level_enable_disable(rdev, i, false);\n}\n\nstatic void trinity_setup_uvd_clock_table(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *rps)\n{\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\tu32 uvdstates = (ps->vclk_low_divider |\n\t\t\t ps->vclk_high_divider << 8 |\n\t\t\t ps->dclk_low_divider << 16 |\n\t\t\t ps->dclk_high_divider << 24);\n\n\tWREG32_SMC(SMU_UVD_DPM_STATES, uvdstates);\n}\n\nstatic void trinity_setup_uvd_dpm_interval(struct radeon_device *rdev,\n\t\t\t\t\t   u32 interval)\n{\n\tu32 p, u;\n\tu32 tp = RREG32_SMC(PM_TP);\n\tu32 val;\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tr600_calculate_u_and_p(interval, xclk, 16, &p, &u);\n\n\tval = (p + tp - 1) / tp;\n\n\tWREG32_SMC(SMU_UVD_DPM_CNTL, val);\n}\n\nstatic bool trinity_uvd_clocks_zero(struct radeon_ps *rps)\n{\n\tif ((rps->vclk == 0) && (rps->dclk == 0))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool trinity_uvd_clocks_equal(struct radeon_ps *rps1,\n\t\t\t\t     struct radeon_ps *rps2)\n{\n\tstruct trinity_ps *ps1 = trinity_get_ps(rps1);\n\tstruct trinity_ps *ps2 = trinity_get_ps(rps2);\n\n\tif ((rps1->vclk == rps2->vclk) &&\n\t    (rps1->dclk == rps2->dclk) &&\n\t    (ps1->vclk_low_divider == ps2->vclk_low_divider) &&\n\t    (ps1->vclk_high_divider == ps2->vclk_high_divider) &&\n\t    (ps1->dclk_low_divider == ps2->dclk_low_divider) &&\n\t    (ps1->dclk_high_divider == ps2->dclk_high_divider))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void trinity_setup_uvd_clocks(struct radeon_device *rdev,\n\t\t\t\t     struct radeon_ps *new_rps,\n\t\t\t\t     struct radeon_ps *old_rps)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (pi->enable_gfx_power_gating) {\n\t\ttrinity_gfx_powergating_enable(rdev, false);\n\t}\n\n\tif (pi->uvd_dpm) {\n\t\tif (trinity_uvd_clocks_zero(new_rps) &&\n\t\t    !trinity_uvd_clocks_zero(old_rps)) {\n\t\t\ttrinity_setup_uvd_dpm_interval(rdev, 0);\n\t\t} else if (!trinity_uvd_clocks_zero(new_rps)) {\n\t\t\ttrinity_setup_uvd_clock_table(rdev, new_rps);\n\n\t\t\tif (trinity_uvd_clocks_zero(old_rps)) {\n\t\t\t\tu32 tmp = RREG32(CG_MISC_REG);\n\t\t\t\ttmp &= 0xfffffffd;\n\t\t\t\tWREG32(CG_MISC_REG, tmp);\n\n\t\t\t\tradeon_set_uvd_clocks(rdev, new_rps->vclk, new_rps->dclk);\n\n\t\t\t\ttrinity_setup_uvd_dpm_interval(rdev, 3000);\n\t\t\t}\n\t\t}\n\t\ttrinity_uvd_dpm_config(rdev);\n\t} else {\n\t\tif (trinity_uvd_clocks_zero(new_rps) ||\n\t\t    trinity_uvd_clocks_equal(new_rps, old_rps))\n\t\t\treturn;\n\n\t\tradeon_set_uvd_clocks(rdev, new_rps->vclk, new_rps->dclk);\n\t}\n\n\tif (pi->enable_gfx_power_gating) {\n\t\ttrinity_gfx_powergating_enable(rdev, true);\n\t}\n}\n\nstatic void trinity_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t       struct radeon_ps *new_rps,\n\t\t\t\t\t\t       struct radeon_ps *old_rps)\n{\n\tstruct trinity_ps *new_ps = trinity_get_ps(new_rps);\n\tstruct trinity_ps *current_ps = trinity_get_ps(new_rps);\n\n\tif (new_ps->levels[new_ps->num_levels - 1].sclk >=\n\t    current_ps->levels[current_ps->num_levels - 1].sclk)\n\t\treturn;\n\n\ttrinity_setup_uvd_clocks(rdev, new_rps, old_rps);\n}\n\nstatic void trinity_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t      struct radeon_ps *new_rps,\n\t\t\t\t\t\t      struct radeon_ps *old_rps)\n{\n\tstruct trinity_ps *new_ps = trinity_get_ps(new_rps);\n\tstruct trinity_ps *current_ps = trinity_get_ps(old_rps);\n\n\tif (new_ps->levels[new_ps->num_levels - 1].sclk <\n\t    current_ps->levels[current_ps->num_levels - 1].sclk)\n\t\treturn;\n\n\ttrinity_setup_uvd_clocks(rdev, new_rps, old_rps);\n}\n\nstatic void trinity_set_vce_clock(struct radeon_device *rdev,\n\t\t\t\t  struct radeon_ps *new_rps,\n\t\t\t\t  struct radeon_ps *old_rps)\n{\n\tif ((old_rps->evclk != new_rps->evclk) ||\n\t    (old_rps->ecclk != new_rps->ecclk)) {\n\t\t \n\t\tif (new_rps->evclk || new_rps->ecclk)\n\t\t\tvce_v1_0_enable_mgcg(rdev, false);\n\t\telse\n\t\t\tvce_v1_0_enable_mgcg(rdev, true);\n\t\tradeon_set_vce_clocks(rdev, new_rps->evclk, new_rps->ecclk);\n\t}\n}\n\nstatic void trinity_program_ttt(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 value = RREG32_SMC(SMU_SCLK_DPM_TTT);\n\n\tvalue &= ~(HT_MASK | LT_MASK);\n\tvalue |= HT((pi->thermal_auto_throttling + 49) * 8);\n\tvalue |= LT((pi->thermal_auto_throttling + 49 - pi->sys_info.htc_hyst_lmt) * 8);\n\tWREG32_SMC(SMU_SCLK_DPM_TTT, value);\n}\n\nstatic void trinity_enable_att(struct radeon_device *rdev)\n{\n\tu32 value = RREG32_SMC(SMU_SCLK_DPM_TT_CNTL);\n\n\tvalue &= ~SCLK_TT_EN_MASK;\n\tvalue |= SCLK_TT_EN(1);\n\tWREG32_SMC(SMU_SCLK_DPM_TT_CNTL, value);\n}\n\nstatic void trinity_program_sclk_dpm(struct radeon_device *rdev)\n{\n\tu32 p, u;\n\tu32 tp = RREG32_SMC(PM_TP);\n\tu32 ni;\n\tu32 xclk = radeon_get_xclk(rdev);\n\tu32 value;\n\n\tr600_calculate_u_and_p(400, xclk, 16, &p, &u);\n\n\tni = (p + tp - 1) / tp;\n\n\tvalue = RREG32_SMC(PM_I_CNTL_1);\n\tvalue &= ~SCLK_DPM_MASK;\n\tvalue |= SCLK_DPM(ni);\n\tWREG32_SMC(PM_I_CNTL_1, value);\n}\n\nstatic int trinity_set_thermal_temperature_range(struct radeon_device *rdev,\n\t\t\t\t\t\t int min_temp, int max_temp)\n{\n\tint low_temp = 0 * 1000;\n\tint high_temp = 255 * 1000;\n\n\tif (low_temp < min_temp)\n\t\tlow_temp = min_temp;\n\tif (high_temp > max_temp)\n\t\thigh_temp = max_temp;\n\tif (high_temp < low_temp) {\n\t\tDRM_ERROR(\"invalid thermal range: %d - %d\\n\", low_temp, high_temp);\n\t\treturn -EINVAL;\n\t}\n\n\tWREG32_P(CG_THERMAL_INT_CTRL, DIG_THERM_INTH(49 + (high_temp / 1000)), ~DIG_THERM_INTH_MASK);\n\tWREG32_P(CG_THERMAL_INT_CTRL, DIG_THERM_INTL(49 + (low_temp / 1000)), ~DIG_THERM_INTL_MASK);\n\n\trdev->pm.dpm.thermal.min_temp = low_temp;\n\trdev->pm.dpm.thermal.max_temp = high_temp;\n\n\treturn 0;\n}\n\nstatic void trinity_update_current_ps(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_ps *rps)\n{\n\tstruct trinity_ps *new_ps = trinity_get_ps(rps);\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tpi->current_rps = *rps;\n\tpi->current_ps = *new_ps;\n\tpi->current_rps.ps_priv = &pi->current_ps;\n}\n\nstatic void trinity_update_requested_ps(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_ps *rps)\n{\n\tstruct trinity_ps *new_ps = trinity_get_ps(rps);\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tpi->requested_rps = *rps;\n\tpi->requested_ps = *new_ps;\n\tpi->requested_rps.ps_priv = &pi->requested_ps;\n}\n\nvoid trinity_dpm_enable_bapm(struct radeon_device *rdev, bool enable)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (pi->enable_bapm) {\n\t\ttrinity_acquire_mutex(rdev);\n\t\ttrinity_dpm_bapm_enable(rdev, enable);\n\t\ttrinity_release_mutex(rdev);\n\t}\n}\n\nint trinity_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\ttrinity_acquire_mutex(rdev);\n\n\tif (trinity_dpm_enabled(rdev)) {\n\t\ttrinity_release_mutex(rdev);\n\t\treturn -EINVAL;\n\t}\n\n\ttrinity_program_bootup_state(rdev);\n\tsumo_program_vc(rdev, 0x00C00033);\n\ttrinity_start_am(rdev);\n\tif (pi->enable_auto_thermal_throttling) {\n\t\ttrinity_program_ttt(rdev);\n\t\ttrinity_enable_att(rdev);\n\t}\n\ttrinity_program_sclk_dpm(rdev);\n\ttrinity_start_dpm(rdev);\n\ttrinity_wait_for_dpm_enabled(rdev);\n\ttrinity_dpm_bapm_enable(rdev, false);\n\ttrinity_release_mutex(rdev);\n\n\ttrinity_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\n\n\treturn 0;\n}\n\nint trinity_dpm_late_enable(struct radeon_device *rdev)\n{\n\tint ret;\n\n\ttrinity_acquire_mutex(rdev);\n\ttrinity_enable_clock_power_gating(rdev);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\tret = trinity_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\n\t\tif (ret) {\n\t\t\ttrinity_release_mutex(rdev);\n\t\t\treturn ret;\n\t\t}\n\t\trdev->irq.dpm_thermal = true;\n\t\tradeon_irq_set(rdev);\n\t}\n\ttrinity_release_mutex(rdev);\n\n\treturn 0;\n}\n\nvoid trinity_dpm_disable(struct radeon_device *rdev)\n{\n\ttrinity_acquire_mutex(rdev);\n\tif (!trinity_dpm_enabled(rdev)) {\n\t\ttrinity_release_mutex(rdev);\n\t\treturn;\n\t}\n\ttrinity_dpm_bapm_enable(rdev, false);\n\ttrinity_disable_clock_power_gating(rdev);\n\tsumo_clear_vc(rdev);\n\ttrinity_wait_for_level_0(rdev);\n\ttrinity_stop_dpm(rdev);\n\ttrinity_reset_am(rdev);\n\ttrinity_release_mutex(rdev);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\ttrinity_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\n}\n\nstatic void trinity_get_min_sclk_divider(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tpi->min_sclk_did =\n\t\t(RREG32_SMC(CC_SMU_MISC_FUSES) & MinSClkDid_MASK) >> MinSClkDid_SHIFT;\n}\n\nstatic void trinity_setup_nbp_sim(struct radeon_device *rdev,\n\t\t\t\t  struct radeon_ps *rps)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct trinity_ps *new_ps = trinity_get_ps(rps);\n\tu32 nbpsconfig;\n\n\tif (pi->sys_info.nb_dpm_enable) {\n\t\tnbpsconfig = RREG32_SMC(NB_PSTATE_CONFIG);\n\t\tnbpsconfig &= ~(Dpm0PgNbPsLo_MASK | Dpm0PgNbPsHi_MASK | DpmXNbPsLo_MASK | DpmXNbPsHi_MASK);\n\t\tnbpsconfig |= (Dpm0PgNbPsLo(new_ps->Dpm0PgNbPsLo) |\n\t\t\t       Dpm0PgNbPsHi(new_ps->Dpm0PgNbPsHi) |\n\t\t\t       DpmXNbPsLo(new_ps->DpmXNbPsLo) |\n\t\t\t       DpmXNbPsHi(new_ps->DpmXNbPsHi));\n\t\tWREG32_SMC(NB_PSTATE_CONFIG, nbpsconfig);\n\t}\n}\n\nint trinity_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t\tenum radeon_dpm_forced_level level)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\tint i, ret;\n\n\tif (ps->num_levels <= 1)\n\t\treturn 0;\n\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\t \n\t\treturn -EINVAL;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tret = trinity_dpm_n_levels_disabled(rdev, ps->num_levels - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tfor (i = 0; i < ps->num_levels; i++) {\n\t\t\tret = trinity_dpm_n_levels_disabled(rdev, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n\nint trinity_dpm_pre_set_power_state(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *new_ps = &requested_ps;\n\n\ttrinity_update_requested_ps(rdev, new_ps);\n\n\ttrinity_apply_state_adjust_rules(rdev,\n\t\t\t\t\t &pi->requested_rps,\n\t\t\t\t\t &pi->current_rps);\n\n\treturn 0;\n}\n\nint trinity_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &pi->requested_rps;\n\tstruct radeon_ps *old_ps = &pi->current_rps;\n\n\ttrinity_acquire_mutex(rdev);\n\tif (pi->enable_dpm) {\n\t\tif (pi->enable_bapm)\n\t\t\ttrinity_dpm_bapm_enable(rdev, rdev->pm.dpm.ac_power);\n\t\ttrinity_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\t\ttrinity_enable_power_level_0(rdev);\n\t\ttrinity_force_level_0(rdev);\n\t\ttrinity_wait_for_level_0(rdev);\n\t\ttrinity_setup_nbp_sim(rdev, new_ps);\n\t\ttrinity_program_power_levels_0_to_n(rdev, new_ps, old_ps);\n\t\ttrinity_force_level_0(rdev);\n\t\ttrinity_unforce_levels(rdev);\n\t\ttrinity_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\t\ttrinity_set_vce_clock(rdev, new_ps, old_ps);\n\t}\n\ttrinity_release_mutex(rdev);\n\n\treturn 0;\n}\n\nvoid trinity_dpm_post_set_power_state(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &pi->requested_rps;\n\n\ttrinity_update_current_ps(rdev, new_ps);\n}\n\nvoid trinity_dpm_setup_asic(struct radeon_device *rdev)\n{\n\ttrinity_acquire_mutex(rdev);\n\tsumo_program_sstp(rdev);\n\tsumo_take_smu_control(rdev, true);\n\ttrinity_get_min_sclk_divider(rdev);\n\ttrinity_release_mutex(rdev);\n}\n\n#if 0\nvoid trinity_dpm_reset_asic(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\ttrinity_acquire_mutex(rdev);\n\tif (pi->enable_dpm) {\n\t\ttrinity_enable_power_level_0(rdev);\n\t\ttrinity_force_level_0(rdev);\n\t\ttrinity_wait_for_level_0(rdev);\n\t\ttrinity_program_bootup_state(rdev);\n\t\ttrinity_force_level_0(rdev);\n\t\ttrinity_unforce_levels(rdev);\n\t}\n\ttrinity_release_mutex(rdev);\n}\n#endif\n\nstatic u16 trinity_convert_voltage_index_to_value(struct radeon_device *rdev,\n\t\t\t\t\t\t  u32 vid_2bit)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 vid_7bit = sumo_convert_vid2_to_vid7(rdev, &pi->sys_info.vid_mapping_table, vid_2bit);\n\tu32 svi_mode = (RREG32_SMC(PM_CONFIG) & SVI_Mode) ? 1 : 0;\n\tu32 step = (svi_mode == 0) ? 1250 : 625;\n\tu32 delta = vid_7bit * step + 50;\n\n\tif (delta > 155000)\n\t\treturn 0;\n\n\treturn (155000 - delta) / 100;\n}\n\nstatic void trinity_patch_boot_state(struct radeon_device *rdev,\n\t\t\t\t     struct trinity_ps *ps)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tps->num_levels = 1;\n\tps->nbps_flags = 0;\n\tps->bapm_flags = 0;\n\tps->levels[0] = pi->boot_pl;\n}\n\nstatic u8 trinity_calculate_vce_wm(struct radeon_device *rdev, u32 sclk)\n{\n\tif (sclk < 20000)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void trinity_construct_boot_state(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tpi->boot_pl.sclk = pi->sys_info.bootup_sclk;\n\tpi->boot_pl.vddc_index = pi->sys_info.bootup_nb_voltage_index;\n\tpi->boot_pl.ds_divider_index = 0;\n\tpi->boot_pl.ss_divider_index = 0;\n\tpi->boot_pl.allow_gnb_slow = 1;\n\tpi->boot_pl.force_nbp_state = 0;\n\tpi->boot_pl.display_wm = 0;\n\tpi->boot_pl.vce_wm = 0;\n\tpi->current_ps.num_levels = 1;\n\tpi->current_ps.levels[0] = pi->boot_pl;\n}\n\nstatic u8 trinity_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t  u32 sclk, u32 min_sclk_in_sr)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 i;\n\tu32 temp;\n\tu32 min = (min_sclk_in_sr > TRINITY_MINIMUM_ENGINE_CLOCK) ?\n\t\tmin_sclk_in_sr : TRINITY_MINIMUM_ENGINE_CLOCK;\n\n\tif (sclk < min)\n\t\treturn 0;\n\n\tif (!pi->enable_sclk_ds)\n\t\treturn 0;\n\n\tfor (i = TRINITY_MAX_DEEPSLEEP_DIVIDER_ID;  ; i--) {\n\t\ttemp = sclk / sumo_get_sleep_divider_from_id(i);\n\t\tif (temp >= min || i == 0)\n\t\t\tbreak;\n\t}\n\n\treturn (u8)i;\n}\n\nstatic u32 trinity_get_valid_engine_clock(struct radeon_device *rdev,\n\t\t\t\t\t  u32 lower_limit)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 i;\n\n\tfor (i = 0; i < pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries; i++) {\n\t\tif (pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency >= lower_limit)\n\t\t\treturn pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency;\n\t}\n\n\tif (i == pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries)\n\t\tDRM_ERROR(\"engine clock out of range!\");\n\n\treturn 0;\n}\n\nstatic void trinity_patch_thermal_state(struct radeon_device *rdev,\n\t\t\t\t\tstruct trinity_ps *ps,\n\t\t\t\t\tstruct trinity_ps *current_ps)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 sclk_in_sr = pi->sys_info.min_sclk;  \n\tu32 current_vddc;\n\tu32 current_sclk;\n\tu32 current_index = 0;\n\n\tif (current_ps) {\n\t\tcurrent_vddc = current_ps->levels[current_index].vddc_index;\n\t\tcurrent_sclk = current_ps->levels[current_index].sclk;\n\t} else {\n\t\tcurrent_vddc = pi->boot_pl.vddc_index;\n\t\tcurrent_sclk = pi->boot_pl.sclk;\n\t}\n\n\tps->levels[0].vddc_index = current_vddc;\n\n\tif (ps->levels[0].sclk > current_sclk)\n\t\tps->levels[0].sclk = current_sclk;\n\n\tps->levels[0].ds_divider_index =\n\t\ttrinity_get_sleep_divider_id_from_clock(rdev, ps->levels[0].sclk, sclk_in_sr);\n\tps->levels[0].ss_divider_index = ps->levels[0].ds_divider_index;\n\tps->levels[0].allow_gnb_slow = 1;\n\tps->levels[0].force_nbp_state = 0;\n\tps->levels[0].display_wm = 0;\n\tps->levels[0].vce_wm =\n\t\ttrinity_calculate_vce_wm(rdev, ps->levels[0].sclk);\n}\n\nstatic u8 trinity_calculate_display_wm(struct radeon_device *rdev,\n\t\t\t\t       struct trinity_ps *ps, u32 index)\n{\n\tif (ps == NULL || ps->num_levels <= 1)\n\t\treturn 0;\n\telse if (ps->num_levels == 2) {\n\t\tif (index == 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t} else {\n\t\tif (index == 0)\n\t\t\treturn 0;\n\t\telse if (ps->levels[index].sclk < 30000)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n}\n\nstatic u32 trinity_get_uvd_clock_index(struct radeon_device *rdev,\n\t\t\t\t       struct radeon_ps *rps)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 i = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif ((rps->vclk == pi->sys_info.uvd_clock_table_entries[i].vclk) &&\n\t\t    (rps->dclk == pi->sys_info.uvd_clock_table_entries[i].dclk))\n\t\t    break;\n\t}\n\n\tif (i >= 4) {\n\t\tDRM_ERROR(\"UVD clock index not found!\\n\");\n\t\ti = 3;\n\t}\n\treturn i;\n}\n\nstatic void trinity_adjust_uvd_state(struct radeon_device *rdev,\n\t\t\t\t     struct radeon_ps *rps)\n{\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 high_index = 0;\n\tu32 low_index = 0;\n\n\tif (pi->uvd_dpm && r600_is_uvd_state(rps->class, rps->class2)) {\n\t\thigh_index = trinity_get_uvd_clock_index(rdev, rps);\n\n\t\tswitch(high_index) {\n\t\tcase 3:\n\t\tcase 2:\n\t\t\tlow_index = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tcase 0:\n\t\tdefault:\n\t\t\tlow_index = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tps->vclk_low_divider =\n\t\t\tpi->sys_info.uvd_clock_table_entries[high_index].vclk_did;\n\t\tps->dclk_low_divider =\n\t\t\tpi->sys_info.uvd_clock_table_entries[high_index].dclk_did;\n\t\tps->vclk_high_divider =\n\t\t\tpi->sys_info.uvd_clock_table_entries[low_index].vclk_did;\n\t\tps->dclk_high_divider =\n\t\t\tpi->sys_info.uvd_clock_table_entries[low_index].dclk_did;\n\t}\n}\n\nstatic int trinity_get_vce_clock_voltage(struct radeon_device *rdev,\n\t\t\t\t\t u32 evclk, u32 ecclk, u16 *voltage)\n{\n\tu32 i;\n\tint ret = -EINVAL;\n\tstruct radeon_vce_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\n\n\tif (((evclk == 0) && (ecclk == 0)) ||\n\t    (table && (table->count == 0))) {\n\t\t*voltage = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif ((evclk <= table->entries[i].evclk) &&\n\t\t    (ecclk <= table->entries[i].ecclk)) {\n\t\t\t*voltage = table->entries[i].v;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ret)\n\t\t*voltage = table->entries[table->count - 1].v;\n\n\treturn ret;\n}\n\nstatic void trinity_apply_state_adjust_rules(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *new_rps,\n\t\t\t\t\t     struct radeon_ps *old_rps)\n{\n\tstruct trinity_ps *ps = trinity_get_ps(new_rps);\n\tstruct trinity_ps *current_ps = trinity_get_ps(old_rps);\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 min_voltage = 0;  \n\tu32 min_sclk = pi->sys_info.min_sclk;  \n\tu32 sclk_in_sr = pi->sys_info.min_sclk;  \n\tu32 i;\n\tu16 min_vce_voltage;\n\tbool force_high;\n\tu32 num_active_displays = rdev->pm.dpm.new_active_crtc_count;\n\n\tif (new_rps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\treturn trinity_patch_thermal_state(rdev, ps, current_ps);\n\n\ttrinity_adjust_uvd_state(rdev, new_rps);\n\n\tif (new_rps->vce_active) {\n\t\tnew_rps->evclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].evclk;\n\t\tnew_rps->ecclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].ecclk;\n\t} else {\n\t\tnew_rps->evclk = 0;\n\t\tnew_rps->ecclk = 0;\n\t}\n\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tif (ps->levels[i].vddc_index < min_voltage)\n\t\t\tps->levels[i].vddc_index = min_voltage;\n\n\t\tif (ps->levels[i].sclk < min_sclk)\n\t\t\tps->levels[i].sclk =\n\t\t\t\ttrinity_get_valid_engine_clock(rdev, min_sclk);\n\n\t\t \n\t\tif (new_rps->vce_active) {\n\t\t\t \n\t\t\tif (ps->levels[i].sclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk)\n\t\t\t\tps->levels[i].sclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk;\n\t\t\t \n\t\t\ttrinity_get_vce_clock_voltage(rdev, new_rps->evclk, new_rps->ecclk, &min_vce_voltage);\n\t\t\tif (ps->levels[i].vddc_index < min_vce_voltage)\n\t\t\t\tps->levels[i].vddc_index = min_vce_voltage;\n\t\t}\n\n\t\tps->levels[i].ds_divider_index =\n\t\t\tsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[i].sclk, sclk_in_sr);\n\n\t\tps->levels[i].ss_divider_index = ps->levels[i].ds_divider_index;\n\n\t\tps->levels[i].allow_gnb_slow = 1;\n\t\tps->levels[i].force_nbp_state = 0;\n\t\tps->levels[i].display_wm =\n\t\t\ttrinity_calculate_display_wm(rdev, ps, i);\n\t\tps->levels[i].vce_wm =\n\t\t\ttrinity_calculate_vce_wm(rdev, ps->levels[0].sclk);\n\t}\n\n\tif ((new_rps->class & (ATOM_PPLIB_CLASSIFICATION_HDSTATE | ATOM_PPLIB_CLASSIFICATION_SDSTATE)) ||\n\t    ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY))\n\t\tps->bapm_flags |= TRINITY_POWERSTATE_FLAGS_BAPM_DISABLE;\n\n\tif (pi->sys_info.nb_dpm_enable) {\n\t\tps->Dpm0PgNbPsLo = 0x1;\n\t\tps->Dpm0PgNbPsHi = 0x0;\n\t\tps->DpmXNbPsLo = 0x2;\n\t\tps->DpmXNbPsHi = 0x1;\n\n\t\tif ((new_rps->class & (ATOM_PPLIB_CLASSIFICATION_HDSTATE | ATOM_PPLIB_CLASSIFICATION_SDSTATE)) ||\n\t\t    ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY)) {\n\t\t\tforce_high = ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE) ||\n\t\t\t\t      ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE) &&\n\t\t\t\t       (pi->sys_info.uma_channel_number == 1)));\n\t\t\tforce_high = (num_active_displays >= 3) || force_high;\n\t\t\tps->Dpm0PgNbPsLo = force_high ? 0x2 : 0x3;\n\t\t\tps->Dpm0PgNbPsHi = 0x1;\n\t\t\tps->DpmXNbPsLo = force_high ? 0x2 : 0x3;\n\t\t\tps->DpmXNbPsHi = 0x2;\n\t\t\tps->levels[ps->num_levels - 1].allow_gnb_slow = 0;\n\t\t}\n\t}\n}\n\nstatic void trinity_cleanup_asic(struct radeon_device *rdev)\n{\n\tsumo_take_smu_control(rdev, false);\n}\n\n#if 0\nstatic void trinity_pre_display_configuration_change(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (pi->voltage_drop_in_dce)\n\t\ttrinity_dce_enable_voltage_adjustment(rdev, false);\n}\n#endif\n\nstatic void trinity_add_dccac_value(struct radeon_device *rdev)\n{\n\tu32 gpu_cac_avrg_cntl_window_size;\n\tu32 num_active_displays = rdev->pm.dpm.new_active_crtc_count;\n\tu64 disp_clk = rdev->clock.default_dispclk / 100;\n\tu32 dc_cac_value;\n\n\tgpu_cac_avrg_cntl_window_size =\n\t\t(RREG32_SMC(GPU_CAC_AVRG_CNTL) & WINDOW_SIZE_MASK) >> WINDOW_SIZE_SHIFT;\n\n\tdc_cac_value = (u32)((14213 * disp_clk * disp_clk * (u64)num_active_displays) >>\n\t\t\t     (32 - gpu_cac_avrg_cntl_window_size));\n\n\tWREG32_SMC(DC_CAC_VALUE, dc_cac_value);\n}\n\nvoid trinity_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\tif (pi->voltage_drop_in_dce)\n\t\ttrinity_dce_enable_voltage_adjustment(rdev, true);\n\ttrinity_add_dccac_value(rdev);\n}\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void trinity_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t       struct radeon_ps *rps,\n\t\t\t\t\t       struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t       u8 table_rev)\n{\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\trdev->pm.dpm.boot_ps = rps;\n\t\ttrinity_patch_boot_state(rdev, ps);\n\t}\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void trinity_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *rps, int index,\n\t\t\t\t\t   union pplib_clock_info *clock_info)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\tstruct trinity_pl *pl = &ps->levels[index];\n\tu32 sclk;\n\n\tsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\n\tsclk |= clock_info->sumo.ucEngineClockHigh << 16;\n\tpl->sclk = sclk;\n\tpl->vddc_index = clock_info->sumo.vddcIndex;\n\n\tps->num_levels = index + 1;\n\n\tif (pi->enable_sclk_ds) {\n\t\tpl->ds_divider_index = 5;\n\t\tpl->ss_divider_index = 5;\n\t}\n}\n\nstatic int trinity_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j, k, non_clock_array_index, clock_array_index;\n\tunion pplib_clock_info *clock_info;\n\tstruct _StateArray *state_array;\n\tstruct _ClockInfoArray *clock_info_array;\n\tstruct _NonClockInfoArray *non_clock_info_array;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tu8 *power_state_offset;\n\tstruct sumo_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tstate_array = (struct _StateArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset));\n\tclock_info_array = (struct _ClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\n\tnon_clock_info_array = (struct _NonClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\n\n\trdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\tpower_state_offset = (u8 *)state_array->states;\n\tfor (i = 0; i < state_array->ucNumEntries; i++) {\n\t\tu8 *idx;\n\t\tpower_state = (union pplib_power_state *)power_state_offset;\n\t\tnon_clock_array_index = power_state->v2.nonClockInfoIndex;\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t&non_clock_info_array->nonClockInfo[non_clock_array_index];\n\t\tif (!rdev->pm.power_state[i].clock_info) {\n\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tps = kzalloc(sizeof(struct sumo_ps), GFP_KERNEL);\n\t\tif (ps == NULL) {\n\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\tk = 0;\n\t\tidx = (u8 *)&power_state->v2.clockInfoIndex[0];\n\t\tfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\n\t\t\tclock_array_index = idx[j];\n\t\t\tif (clock_array_index >= clock_info_array->ucNumEntries)\n\t\t\t\tcontinue;\n\t\t\tif (k >= SUMO_MAX_HARDWARE_POWERLEVELS)\n\t\t\t\tbreak;\n\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t((u8 *)&clock_info_array->clockInfo[0] +\n\t\t\t\t (clock_array_index * clock_info_array->ucEntrySize));\n\t\t\ttrinity_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t       &rdev->pm.dpm.ps[i], k,\n\t\t\t\t\t\t       clock_info);\n\t\t\tk++;\n\t\t}\n\t\ttrinity_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\t   non_clock_info,\n\t\t\t\t\t\t   non_clock_info_array->ucEntrySize);\n\t\tpower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\n\t}\n\trdev->pm.dpm.num_ps = state_array->ucNumEntries;\n\n\t \n\tfor (i = 0; i < RADEON_MAX_VCE_LEVELS; i++) {\n\t\tu32 sclk;\n\t\tclock_array_index = rdev->pm.dpm.vce_states[i].clk_idx;\n\t\tclock_info = (union pplib_clock_info *)\n\t\t\t&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\n\t\tsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\n\t\tsclk |= clock_info->sumo.ucEngineClockHigh << 16;\n\t\trdev->pm.dpm.vce_states[i].sclk = sclk;\n\t\trdev->pm.dpm.vce_states[i].mclk = 0;\n\t}\n\n\treturn 0;\n}\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V5 info_5;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V6 info_6;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_7 info_7;\n};\n\nstatic u32 trinity_convert_did_to_freq(struct radeon_device *rdev, u8 did)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tu32 divider;\n\n\tif (did >= 8 && did <= 0x3f)\n\t\tdivider = did * 25;\n\telse if (did > 0x3f && did <= 0x5f)\n\t\tdivider = (did - 64) * 50 + 1600;\n\telse if (did > 0x5f && did <= 0x7e)\n\t\tdivider = (did - 96) * 100 + 3200;\n\telse if (did == 0x7f)\n\t\tdivider = 128 * 100;\n\telse\n\t\treturn 10000;\n\n\treturn ((pi->sys_info.dentist_vco_freq * 100) + (divider - 1)) / divider;\n}\n\nstatic int trinity_parse_sys_info_table(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 data_offset;\n\tint i;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t      data_offset);\n\n\t\tif (crev != 7) {\n\t\t\tDRM_ERROR(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpi->sys_info.bootup_sclk = le32_to_cpu(igp_info->info_7.ulBootUpEngineClock);\n\t\tpi->sys_info.min_sclk = le32_to_cpu(igp_info->info_7.ulMinEngineClock);\n\t\tpi->sys_info.bootup_uma_clk = le32_to_cpu(igp_info->info_7.ulBootUpUMAClock);\n\t\tpi->sys_info.dentist_vco_freq = le32_to_cpu(igp_info->info_7.ulDentistVCOFreq);\n\t\tpi->sys_info.bootup_nb_voltage_index =\n\t\t\tle16_to_cpu(igp_info->info_7.usBootUpNBVoltage);\n\t\tif (igp_info->info_7.ucHtcTmpLmt == 0)\n\t\t\tpi->sys_info.htc_tmp_lmt = 203;\n\t\telse\n\t\t\tpi->sys_info.htc_tmp_lmt = igp_info->info_7.ucHtcTmpLmt;\n\t\tif (igp_info->info_7.ucHtcHystLmt == 0)\n\t\t\tpi->sys_info.htc_hyst_lmt = 5;\n\t\telse\n\t\t\tpi->sys_info.htc_hyst_lmt = igp_info->info_7.ucHtcHystLmt;\n\t\tif (pi->sys_info.htc_tmp_lmt <= pi->sys_info.htc_hyst_lmt) {\n\t\t\tDRM_ERROR(\"The htcTmpLmt should be larger than htcHystLmt.\\n\");\n\t\t}\n\n\t\tif (pi->enable_nbps_policy)\n\t\t\tpi->sys_info.nb_dpm_enable = igp_info->info_7.ucNBDPMEnable;\n\t\telse\n\t\t\tpi->sys_info.nb_dpm_enable = 0;\n\n\t\tfor (i = 0; i < TRINITY_NUM_NBPSTATES; i++) {\n\t\t\tpi->sys_info.nbp_mclk[i] = le32_to_cpu(igp_info->info_7.ulNbpStateMemclkFreq[i]);\n\t\t\tpi->sys_info.nbp_nclk[i] = le32_to_cpu(igp_info->info_7.ulNbpStateNClkFreq[i]);\n\t\t}\n\n\t\tpi->sys_info.nbp_voltage_index[0] = le16_to_cpu(igp_info->info_7.usNBP0Voltage);\n\t\tpi->sys_info.nbp_voltage_index[1] = le16_to_cpu(igp_info->info_7.usNBP1Voltage);\n\t\tpi->sys_info.nbp_voltage_index[2] = le16_to_cpu(igp_info->info_7.usNBP2Voltage);\n\t\tpi->sys_info.nbp_voltage_index[3] = le16_to_cpu(igp_info->info_7.usNBP3Voltage);\n\n\t\tif (!pi->sys_info.nb_dpm_enable) {\n\t\t\tfor (i = 1; i < TRINITY_NUM_NBPSTATES; i++) {\n\t\t\t\tpi->sys_info.nbp_mclk[i] = pi->sys_info.nbp_mclk[0];\n\t\t\t\tpi->sys_info.nbp_nclk[i] = pi->sys_info.nbp_nclk[0];\n\t\t\t\tpi->sys_info.nbp_voltage_index[i] = pi->sys_info.nbp_voltage_index[0];\n\t\t\t}\n\t\t}\n\n\t\tpi->sys_info.uma_channel_number = igp_info->info_7.ucUMAChannelNumber;\n\n\t\tsumo_construct_sclk_voltage_mapping_table(rdev,\n\t\t\t\t\t\t\t  &pi->sys_info.sclk_voltage_mapping_table,\n\t\t\t\t\t\t\t  igp_info->info_7.sAvail_SCLK);\n\t\tsumo_construct_vid_mapping_table(rdev, &pi->sys_info.vid_mapping_table,\n\t\t\t\t\t\t igp_info->info_7.sAvail_SCLK);\n\n\t\tpi->sys_info.uvd_clock_table_entries[0].vclk_did =\n\t\t\tigp_info->info_7.ucDPMState0VclkFid;\n\t\tpi->sys_info.uvd_clock_table_entries[1].vclk_did =\n\t\t\tigp_info->info_7.ucDPMState1VclkFid;\n\t\tpi->sys_info.uvd_clock_table_entries[2].vclk_did =\n\t\t\tigp_info->info_7.ucDPMState2VclkFid;\n\t\tpi->sys_info.uvd_clock_table_entries[3].vclk_did =\n\t\t\tigp_info->info_7.ucDPMState3VclkFid;\n\n\t\tpi->sys_info.uvd_clock_table_entries[0].dclk_did =\n\t\t\tigp_info->info_7.ucDPMState0DclkFid;\n\t\tpi->sys_info.uvd_clock_table_entries[1].dclk_did =\n\t\t\tigp_info->info_7.ucDPMState1DclkFid;\n\t\tpi->sys_info.uvd_clock_table_entries[2].dclk_did =\n\t\t\tigp_info->info_7.ucDPMState2DclkFid;\n\t\tpi->sys_info.uvd_clock_table_entries[3].dclk_did =\n\t\t\tigp_info->info_7.ucDPMState3DclkFid;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tpi->sys_info.uvd_clock_table_entries[i].vclk =\n\t\t\t\ttrinity_convert_did_to_freq(rdev,\n\t\t\t\t\t\t\t    pi->sys_info.uvd_clock_table_entries[i].vclk_did);\n\t\t\tpi->sys_info.uvd_clock_table_entries[i].dclk =\n\t\t\t\ttrinity_convert_did_to_freq(rdev,\n\t\t\t\t\t\t\t    pi->sys_info.uvd_clock_table_entries[i].dclk_did);\n\t\t}\n\n\n\n\t}\n\treturn 0;\n}\n\nint trinity_dpm_init(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi;\n\tint ret, i;\n\n\tpi = kzalloc(sizeof(struct trinity_power_info), GFP_KERNEL);\n\tif (pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = pi;\n\n\tfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++)\n\t\tpi->at[i] = TRINITY_AT_DFLT;\n\n\tif (radeon_bapm == -1) {\n\t\t \n\t\tif (rdev->pdev->subsystem_vendor == 0x1462)\n\t\t\tpi->enable_bapm = true;\n\t\telse\n\t\t\tpi->enable_bapm = false;\n\t} else if (radeon_bapm == 0) {\n\t\tpi->enable_bapm = false;\n\t} else {\n\t\tpi->enable_bapm = true;\n\t}\n\tpi->enable_nbps_policy = true;\n\tpi->enable_sclk_ds = true;\n\tpi->enable_gfx_power_gating = true;\n\tpi->enable_gfx_clock_gating = true;\n\tpi->enable_mg_clock_gating = false;\n\tpi->enable_gfx_dynamic_mgpg = false;\n\tpi->override_dynamic_mgpg = false;\n\tpi->enable_auto_thermal_throttling = true;\n\tpi->voltage_drop_in_dce = false;  \n\tpi->uvd_dpm = true;  \n\n\tret = trinity_parse_sys_info_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\ttrinity_construct_boot_state(rdev);\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = r600_parse_extended_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = trinity_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->thermal_auto_throttling = pi->sys_info.htc_tmp_lmt;\n\tpi->enable_dpm = true;\n\n\treturn 0;\n}\n\nvoid trinity_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_ps *rps)\n{\n\tint i;\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tstruct trinity_pl *pl = &ps->levels[i];\n\t\tprintk(\"\\t\\tpower level %d    sclk: %u vddc: %u\\n\",\n\t\t       i, pl->sclk,\n\t\t       trinity_convert_voltage_index_to_value(rdev, pl->vddc_index));\n\t}\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid trinity_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t\t struct seq_file *m)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\tstruct trinity_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) >>\n\t\tCURRENT_STATE_SHIFT;\n\n\tif (current_index >= ps->num_levels) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tpl = &ps->levels[current_index];\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tseq_printf(m, \"power level %d    sclk: %u vddc: %u\\n\",\n\t\t\t   current_index, pl->sclk,\n\t\t\t   trinity_convert_voltage_index_to_value(rdev, pl->vddc_index));\n\t}\n}\n\nu32 trinity_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct trinity_ps *ps = trinity_get_ps(rps);\n\tstruct trinity_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_MASK) >>\n\t\tCURRENT_STATE_SHIFT;\n\n\tif (current_index >= ps->num_levels) {\n\t\treturn 0;\n\t} else {\n\t\tpl = &ps->levels[current_index];\n\t\treturn pl->sclk;\n\t}\n}\n\nu32 trinity_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\treturn pi->sys_info.bootup_uma_clk;\n}\n\nvoid trinity_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\ttrinity_cleanup_asic(rdev);  \n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n\tr600_free_extended_power_table(rdev);\n}\n\nu32 trinity_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\tstruct trinity_ps *requested_state = trinity_get_ps(&pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->levels[0].sclk;\n\telse\n\t\treturn requested_state->levels[requested_state->num_levels - 1].sclk;\n}\n\nu32 trinity_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct trinity_power_info *pi = trinity_get_pi(rdev);\n\n\treturn pi->sys_info.bootup_uma_clk;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}