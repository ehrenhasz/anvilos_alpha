{
  "module_name": "r300.c",
  "hash_id": "b1daf89e27ef2cf4c70064ec4467f6eaeb82d917e257c1410af9863477edded5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/r300.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <drm/drm.h>\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/radeon_drm.h>\n\n#include \"r100_track.h\"\n#include \"r300_reg_safe.h\"\n#include \"r300d.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_reg.h\"\n#include \"rv350d.h\"\n\n \n\n \nuint32_t rv370_pcie_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t r;\n\n\tspin_lock_irqsave(&rdev->pcie_idx_lock, flags);\n\tWREG32(RADEON_PCIE_INDEX, ((reg) & rdev->pcie_reg_mask));\n\tr = RREG32(RADEON_PCIE_DATA);\n\tspin_unlock_irqrestore(&rdev->pcie_idx_lock, flags);\n\treturn r;\n}\n\nvoid rv370_pcie_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->pcie_idx_lock, flags);\n\tWREG32(RADEON_PCIE_INDEX, ((reg) & rdev->pcie_reg_mask));\n\tWREG32(RADEON_PCIE_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->pcie_idx_lock, flags);\n}\n\n \nstatic void rv370_debugfs_pcie_gart_info_init(struct radeon_device *rdev);\n\nvoid rv370_pcie_gart_tlb_flush(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\n\t\tWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp | RADEON_PCIE_TX_GART_INVALIDATE_TLB);\n\t\t(void)RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\n\t\tWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp);\n\t}\n\tmb();\n}\n\n#define R300_PTE_UNSNOOPED (1 << 0)\n#define R300_PTE_WRITEABLE (1 << 2)\n#define R300_PTE_READABLE  (1 << 3)\n\nuint64_t rv370_pcie_gart_get_page_entry(uint64_t addr, uint32_t flags)\n{\n\taddr = (lower_32_bits(addr) >> 8) |\n\t\t((upper_32_bits(addr) & 0xff) << 24);\n\tif (flags & RADEON_GART_PAGE_READ)\n\t\taddr |= R300_PTE_READABLE;\n\tif (flags & RADEON_GART_PAGE_WRITE)\n\t\taddr |= R300_PTE_WRITEABLE;\n\tif (!(flags & RADEON_GART_PAGE_SNOOP))\n\t\taddr |= R300_PTE_UNSNOOPED;\n\treturn addr;\n}\n\nvoid rv370_pcie_gart_set_page(struct radeon_device *rdev, unsigned i,\n\t\t\t      uint64_t entry)\n{\n\tvoid __iomem *ptr = rdev->gart.ptr;\n\n\t \n\twritel(entry, ((void __iomem *)ptr) + (i * 4));\n}\n\nint rv370_pcie_gart_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->gart.robj) {\n\t\tWARN(1, \"RV370 PCIE GART already initialized\\n\");\n\t\treturn 0;\n\t}\n\t \n\tr = radeon_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trv370_debugfs_pcie_gart_info_init(rdev);\n\n\trdev->gart.table_size = rdev->gart.num_gpu_pages * 4;\n\trdev->asic->gart.tlb_flush = &rv370_pcie_gart_tlb_flush;\n\trdev->asic->gart.get_page_entry = &rv370_pcie_gart_get_page_entry;\n\trdev->asic->gart.set_page = &rv370_pcie_gart_set_page;\n\treturn radeon_gart_table_vram_alloc(rdev);\n}\n\nint rv370_pcie_gart_enable(struct radeon_device *rdev)\n{\n\tuint32_t table_addr;\n\tuint32_t tmp;\n\tint r;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\ttmp = RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD;\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp);\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_START_LO, rdev->mc.gtt_start);\n\ttmp = rdev->mc.gtt_end & ~RADEON_GPU_PAGE_MASK;\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_END_LO, tmp);\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_START_HI, 0);\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_END_HI, 0);\n\ttable_addr = rdev->gart.table_addr;\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_BASE, table_addr);\n\t \n\tWREG32_PCIE(RADEON_PCIE_TX_DISCARD_RD_ADDR_LO, rdev->mc.vram_start);\n\tWREG32_PCIE(RADEON_PCIE_TX_DISCARD_RD_ADDR_HI, 0);\n\t \n\tWREG32_PCIE(RADEON_PCIE_TX_GART_ERROR, 0);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\n\ttmp |= RADEON_PCIE_TX_GART_EN;\n\ttmp |= RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD;\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp);\n\trv370_pcie_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nvoid rv370_pcie_gart_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_START_LO, 0);\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_END_LO, 0);\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_START_HI, 0);\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_END_HI, 0);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\n\ttmp |= RADEON_PCIE_TX_GART_UNMAPPED_ACCESS_DISCARD;\n\tWREG32_PCIE(RADEON_PCIE_TX_GART_CNTL, tmp & ~RADEON_PCIE_TX_GART_EN);\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\nvoid rv370_pcie_gart_fini(struct radeon_device *rdev)\n{\n\tradeon_gart_fini(rdev);\n\trv370_pcie_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n}\n\nvoid r300_fence_ring_emit(struct radeon_device *rdev,\n\t\t\t  struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\n\t \n\t \n\tradeon_ring_write(ring, PACKET0(R300_RE_SCISSORS_TL, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(R300_RE_SCISSORS_BR, 0));\n\tradeon_ring_write(ring, 0);\n\t \n\tradeon_ring_write(ring, PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, R300_RB3D_DC_FLUSH);\n\tradeon_ring_write(ring, PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, R300_ZC_FLUSH);\n\t \n\tradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\n\tradeon_ring_write(ring, (RADEON_WAIT_3D_IDLECLEAN |\n\t\t\t\t RADEON_WAIT_2D_IDLECLEAN |\n\t\t\t\t RADEON_WAIT_DMA_GUI_IDLE));\n\tradeon_ring_write(ring, PACKET0(RADEON_HOST_PATH_CNTL, 0));\n\tradeon_ring_write(ring, rdev->config.r300.hdp_cntl |\n\t\t\t\tRADEON_HDP_READ_BUFFER_INVALIDATE);\n\tradeon_ring_write(ring, PACKET0(RADEON_HOST_PATH_CNTL, 0));\n\tradeon_ring_write(ring, rdev->config.r300.hdp_cntl);\n\t \n\tradeon_ring_write(ring, PACKET0(rdev->fence_drv[fence->ring].scratch_reg, 0));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, PACKET0(RADEON_GEN_INT_STATUS, 0));\n\tradeon_ring_write(ring, RADEON_SW_INT_FIRE);\n}\n\nvoid r300_ring_start(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tunsigned gb_tile_config;\n\tint r;\n\n\t \n\tgb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);\n\tswitch (rdev->num_gb_pipes) {\n\tcase 2:\n\t\tgb_tile_config |= R300_PIPE_COUNT_R300;\n\t\tbreak;\n\tcase 3:\n\t\tgb_tile_config |= R300_PIPE_COUNT_R420_3P;\n\t\tbreak;\n\tcase 4:\n\t\tgb_tile_config |= R300_PIPE_COUNT_R420;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\tgb_tile_config |= R300_PIPE_COUNT_RV350;\n\t\tbreak;\n\t}\n\n\tr = radeon_ring_lock(rdev, ring, 64);\n\tif (r) {\n\t\treturn;\n\t}\n\tradeon_ring_write(ring, PACKET0(RADEON_ISYNC_CNTL, 0));\n\tradeon_ring_write(ring,\n\t\t\t  RADEON_ISYNC_ANY2D_IDLE3D |\n\t\t\t  RADEON_ISYNC_ANY3D_IDLE2D |\n\t\t\t  RADEON_ISYNC_WAIT_IDLEGUI |\n\t\t\t  RADEON_ISYNC_CPSCRATCH_IDLEGUI);\n\tradeon_ring_write(ring, PACKET0(R300_GB_TILE_CONFIG, 0));\n\tradeon_ring_write(ring, gb_tile_config);\n\tradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\n\tradeon_ring_write(ring,\n\t\t\t  RADEON_WAIT_2D_IDLECLEAN |\n\t\t\t  RADEON_WAIT_3D_IDLECLEAN);\n\tradeon_ring_write(ring, PACKET0(R300_DST_PIPE_CONFIG, 0));\n\tradeon_ring_write(ring, R300_PIPE_AUTO_CONFIG);\n\tradeon_ring_write(ring, PACKET0(R300_GB_SELECT, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(R300_GB_ENABLE, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, R300_RB3D_DC_FLUSH | R300_RB3D_DC_FREE);\n\tradeon_ring_write(ring, PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, R300_ZC_FLUSH | R300_ZC_FREE);\n\tradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\n\tradeon_ring_write(ring,\n\t\t\t  RADEON_WAIT_2D_IDLECLEAN |\n\t\t\t  RADEON_WAIT_3D_IDLECLEAN);\n\tradeon_ring_write(ring, PACKET0(R300_GB_AA_CONFIG, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(R300_RB3D_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, R300_RB3D_DC_FLUSH | R300_RB3D_DC_FREE);\n\tradeon_ring_write(ring, PACKET0(R300_RB3D_ZCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, R300_ZC_FLUSH | R300_ZC_FREE);\n\tradeon_ring_write(ring, PACKET0(R300_GB_MSPOS0, 0));\n\tradeon_ring_write(ring,\n\t\t\t  ((6 << R300_MS_X0_SHIFT) |\n\t\t\t   (6 << R300_MS_Y0_SHIFT) |\n\t\t\t   (6 << R300_MS_X1_SHIFT) |\n\t\t\t   (6 << R300_MS_Y1_SHIFT) |\n\t\t\t   (6 << R300_MS_X2_SHIFT) |\n\t\t\t   (6 << R300_MS_Y2_SHIFT) |\n\t\t\t   (6 << R300_MSBD0_Y_SHIFT) |\n\t\t\t   (6 << R300_MSBD0_X_SHIFT)));\n\tradeon_ring_write(ring, PACKET0(R300_GB_MSPOS1, 0));\n\tradeon_ring_write(ring,\n\t\t\t  ((6 << R300_MS_X3_SHIFT) |\n\t\t\t   (6 << R300_MS_Y3_SHIFT) |\n\t\t\t   (6 << R300_MS_X4_SHIFT) |\n\t\t\t   (6 << R300_MS_Y4_SHIFT) |\n\t\t\t   (6 << R300_MS_X5_SHIFT) |\n\t\t\t   (6 << R300_MS_Y5_SHIFT) |\n\t\t\t   (6 << R300_MSBD1_SHIFT)));\n\tradeon_ring_write(ring, PACKET0(R300_GA_ENHANCE, 0));\n\tradeon_ring_write(ring, R300_GA_DEADLOCK_CNTL | R300_GA_FASTSYNC_CNTL);\n\tradeon_ring_write(ring, PACKET0(R300_GA_POLY_MODE, 0));\n\tradeon_ring_write(ring,\n\t\t\t  R300_FRONT_PTYPE_TRIANGE | R300_BACK_PTYPE_TRIANGE);\n\tradeon_ring_write(ring, PACKET0(R300_GA_ROUND_MODE, 0));\n\tradeon_ring_write(ring,\n\t\t\t  R300_GEOMETRY_ROUND_NEAREST |\n\t\t\t  R300_COLOR_ROUND_NEAREST);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n}\n\nstatic void r300_errata(struct radeon_device *rdev)\n{\n\trdev->pll_errata = 0;\n\n\tif (rdev->family == CHIP_R300 &&\n\t    (RREG32(RADEON_CONFIG_CNTL) & RADEON_CFG_ATI_REV_ID_MASK) == RADEON_CFG_ATI_REV_A11) {\n\t\trdev->pll_errata |= CHIP_ERRATA_R300_CG;\n\t}\n}\n\nint r300_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(RADEON_MC_STATUS);\n\t\tif (tmp & R300_MC_IDLE) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nstatic void r300_gpu_init(struct radeon_device *rdev)\n{\n\tuint32_t gb_tile_config, tmp;\n\n\tif ((rdev->family == CHIP_R300 && rdev->pdev->device != 0x4144) ||\n\t    (rdev->family == CHIP_R350 && rdev->pdev->device != 0x4148)) {\n\t\t \n\t\trdev->num_gb_pipes = 2;\n\t} else {\n\t\t \n\t\trdev->num_gb_pipes = 1;\n\t}\n\trdev->num_z_pipes = 1;\n\tgb_tile_config = (R300_ENABLE_TILING | R300_TILE_SIZE_16);\n\tswitch (rdev->num_gb_pipes) {\n\tcase 2:\n\t\tgb_tile_config |= R300_PIPE_COUNT_R300;\n\t\tbreak;\n\tcase 3:\n\t\tgb_tile_config |= R300_PIPE_COUNT_R420_3P;\n\t\tbreak;\n\tcase 4:\n\t\tgb_tile_config |= R300_PIPE_COUNT_R420;\n\t\tbreak;\n\tdefault:\n\tcase 1:\n\t\tgb_tile_config |= R300_PIPE_COUNT_RV350;\n\t\tbreak;\n\t}\n\tWREG32(R300_GB_TILE_CONFIG, gb_tile_config);\n\n\tif (r100_gui_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait GUI idle while programming pipes. Bad things might happen.\\n\");\n\t}\n\n\ttmp = RREG32(R300_DST_PIPE_CONFIG);\n\tWREG32(R300_DST_PIPE_CONFIG, tmp | R300_PIPE_AUTO_CONFIG);\n\n\tWREG32(R300_RB2D_DSTCACHE_MODE,\n\t       R300_DC_AUTOFLUSH_ENABLE |\n\t       R300_DC_DC_DISABLE_IGNORE_PE);\n\n\tif (r100_gui_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait GUI idle while programming pipes. Bad things might happen.\\n\");\n\t}\n\tif (r300_mc_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait MC idle while programming pipes. Bad things might happen.\\n\");\n\t}\n\tDRM_INFO(\"radeon: %d quad pipes, %d Z pipes initialized\\n\",\n\t\t rdev->num_gb_pipes, rdev->num_z_pipes);\n}\n\nint r300_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tstruct r100_mc_save save;\n\tu32 status, tmp;\n\tint ret = 0;\n\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tif (!G_000E40_GUI_ACTIVE(status)) {\n\t\treturn 0;\n\t}\n\tr100_mc_stop(rdev, &save);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(RADEON_CP_CSQ_CNTL, 0);\n\ttmp = RREG32(RADEON_CP_RB_CNTL);\n\tWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_RPTR_WR_ENA);\n\tWREG32(RADEON_CP_RB_RPTR_WR, 0);\n\tWREG32(RADEON_CP_RB_WPTR, 0);\n\tWREG32(RADEON_CP_RB_CNTL, tmp);\n\t \n\tpci_save_state(rdev->pdev);\n\t \n\tr100_bm_disable(rdev);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_VAP(1) |\n\t\t\t\t\tS_0000F0_SOFT_RESET_GA(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_CP(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tpci_restore_state(rdev->pdev);\n\tr100_enable_bm(rdev);\n\t \n\tif (G_000E40_GA_BUSY(status) || G_000E40_VAP_BUSY(status)) {\n\t\tdev_err(rdev->dev, \"failed to reset GPU\\n\");\n\t\tret = -1;\n\t} else\n\t\tdev_info(rdev->dev, \"GPU reset succeed\\n\");\n\tr100_mc_resume(rdev, &save);\n\treturn ret;\n}\n\n \nvoid r300_mc_init(struct radeon_device *rdev)\n{\n\tu64 base;\n\tu32 tmp;\n\n\t \n\trdev->mc.vram_is_ddr = true;\n\ttmp = RREG32(RADEON_MEM_CNTL);\n\ttmp &= R300_MEM_NUM_CHANNELS_MASK;\n\tswitch (tmp) {\n\tcase 0: rdev->mc.vram_width = 64; break;\n\tcase 1: rdev->mc.vram_width = 128; break;\n\tcase 2: rdev->mc.vram_width = 256; break;\n\tdefault:  rdev->mc.vram_width = 128; break;\n\t}\n\tr100_vram_init_sizes(rdev);\n\tbase = rdev->mc.aper_base;\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tbase = (RREG32(RADEON_NB_TOM) & 0xffff) << 16;\n\tradeon_vram_location(rdev, &rdev->mc, base);\n\trdev->mc.gtt_base_align = 0;\n\tif (!(rdev->flags & RADEON_IS_AGP))\n\t\tradeon_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n}\n\nvoid rv370_set_pcie_lanes(struct radeon_device *rdev, int lanes)\n{\n\tuint32_t link_width_cntl, mask;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\t \n\n\tswitch (lanes) {\n\tcase 0:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X0;\n\t\tbreak;\n\tcase 1:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X1;\n\t\tbreak;\n\tcase 2:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X2;\n\t\tbreak;\n\tcase 4:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X4;\n\t\tbreak;\n\tcase 8:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X8;\n\t\tbreak;\n\tcase 12:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X12;\n\t\tbreak;\n\tcase 16:\n\tdefault:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X16;\n\t\tbreak;\n\t}\n\n\tlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\n\n\tif ((link_width_cntl & RADEON_PCIE_LC_LINK_WIDTH_RD_MASK) ==\n\t    (mask << RADEON_PCIE_LC_LINK_WIDTH_RD_SHIFT))\n\t\treturn;\n\n\tlink_width_cntl &= ~(RADEON_PCIE_LC_LINK_WIDTH_MASK |\n\t\t\t     RADEON_PCIE_LC_RECONFIG_NOW |\n\t\t\t     RADEON_PCIE_LC_RECONFIG_LATER |\n\t\t\t     RADEON_PCIE_LC_SHORT_RECONFIG_EN);\n\tlink_width_cntl |= mask;\n\tWREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\tWREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL, (link_width_cntl |\n\t\t\t\t\t\t     RADEON_PCIE_LC_RECONFIG_NOW));\n\n\t \n\tlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\n\twhile (link_width_cntl == 0xffffffff)\n\t\tlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\n\n}\n\nint rv370_get_pcie_lanes(struct radeon_device *rdev)\n{\n\tu32 link_width_cntl;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn 0;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn 0;\n\n\t \n\n\tlink_width_cntl = RREG32_PCIE(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\n\n\tswitch ((link_width_cntl & RADEON_PCIE_LC_LINK_WIDTH_RD_MASK) >> RADEON_PCIE_LC_LINK_WIDTH_RD_SHIFT) {\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X0:\n\t\treturn 0;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X1:\n\t\treturn 1;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X2:\n\t\treturn 2;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X4:\n\t\treturn 4;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X8:\n\t\treturn 8;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X16:\n\tdefault:\n\t\treturn 16;\n\t}\n}\n\n#if defined(CONFIG_DEBUG_FS)\nstatic int rv370_debugfs_pcie_gart_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t tmp;\n\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_CNTL);\n\tseq_printf(m, \"PCIE_TX_GART_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_BASE);\n\tseq_printf(m, \"PCIE_TX_GART_BASE 0x%08x\\n\", tmp);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_START_LO);\n\tseq_printf(m, \"PCIE_TX_GART_START_LO 0x%08x\\n\", tmp);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_START_HI);\n\tseq_printf(m, \"PCIE_TX_GART_START_HI 0x%08x\\n\", tmp);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_END_LO);\n\tseq_printf(m, \"PCIE_TX_GART_END_LO 0x%08x\\n\", tmp);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_END_HI);\n\tseq_printf(m, \"PCIE_TX_GART_END_HI 0x%08x\\n\", tmp);\n\ttmp = RREG32_PCIE(RADEON_PCIE_TX_GART_ERROR);\n\tseq_printf(m, \"PCIE_TX_GART_ERROR 0x%08x\\n\", tmp);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rv370_debugfs_pcie_gart_info);\n#endif\n\nstatic void rv370_debugfs_pcie_gart_info_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"rv370_pcie_gart_info\", 0444, root, rdev,\n\t\t\t    &rv370_debugfs_pcie_gart_info_fops);\n#endif\n}\n\nstatic int r300_packet0_check(struct radeon_cs_parser *p,\n\t\tstruct radeon_cs_packet *pkt,\n\t\tunsigned idx, unsigned reg)\n{\n\tstruct radeon_bo_list *reloc;\n\tstruct r100_cs_track *track;\n\tvolatile uint32_t *ib;\n\tuint32_t tmp, tile_flags = 0;\n\tunsigned i;\n\tint r;\n\tu32 idx_value;\n\n\tib = p->ib.ptr;\n\ttrack = (struct r100_cs_track *)p->track;\n\tidx_value = radeon_get_ib_value(p, idx);\n\n\tswitch (reg) {\n\tcase AVIVO_D1MODE_VLINE_START_END:\n\tcase RADEON_CRTC_GUI_TRIG_VLINE:\n\t\tr = r100_cs_packet_parse_vline(p);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase RADEON_DST_PITCH_OFFSET:\n\tcase RADEON_SRC_PITCH_OFFSET:\n\t\tr = r100_reloc_pitch_offset(p, pkt, idx, reg);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tcase R300_RB3D_COLOROFFSET0:\n\tcase R300_RB3D_COLOROFFSET1:\n\tcase R300_RB3D_COLOROFFSET2:\n\tcase R300_RB3D_COLOROFFSET3:\n\t\ti = (reg - R300_RB3D_COLOROFFSET0) >> 2;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->cb[i].robj = reloc->robj;\n\t\ttrack->cb[i].offset = idx_value;\n\t\ttrack->cb_dirty = true;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase R300_ZB_DEPTHOFFSET:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->zb.robj = reloc->robj;\n\t\ttrack->zb.offset = idx_value;\n\t\ttrack->zb_dirty = true;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase R300_TX_OFFSET_0:\n\tcase R300_TX_OFFSET_0+4:\n\tcase R300_TX_OFFSET_0+8:\n\tcase R300_TX_OFFSET_0+12:\n\tcase R300_TX_OFFSET_0+16:\n\tcase R300_TX_OFFSET_0+20:\n\tcase R300_TX_OFFSET_0+24:\n\tcase R300_TX_OFFSET_0+28:\n\tcase R300_TX_OFFSET_0+32:\n\tcase R300_TX_OFFSET_0+36:\n\tcase R300_TX_OFFSET_0+40:\n\tcase R300_TX_OFFSET_0+44:\n\tcase R300_TX_OFFSET_0+48:\n\tcase R300_TX_OFFSET_0+52:\n\tcase R300_TX_OFFSET_0+56:\n\tcase R300_TX_OFFSET_0+60:\n\t\ti = (reg - R300_TX_OFFSET_0) >> 2;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\n\t\tif (p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS) {\n\t\t\tib[idx] = (idx_value & 31) |  \n\t\t\t\t  ((idx_value & ~31) + (u32)reloc->gpu_offset);\n\t\t} else {\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\t\ttile_flags |= R300_TXO_MACRO_TILE;\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MICRO)\n\t\t\t\ttile_flags |= R300_TXO_MICRO_TILE;\n\t\t\telse if (reloc->tiling_flags & RADEON_TILING_MICRO_SQUARE)\n\t\t\t\ttile_flags |= R300_TXO_MICRO_TILE_SQUARE;\n\n\t\t\ttmp = idx_value + ((u32)reloc->gpu_offset);\n\t\t\ttmp |= tile_flags;\n\t\t\tib[idx] = tmp;\n\t\t}\n\t\ttrack->textures[i].robj = reloc->robj;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\t \n\tcase 0x2084:\n\t\t \n\t\ttrack->vap_vf_cntl = idx_value;\n\t\tbreak;\n\tcase 0x20B4:\n\t\t \n\t\ttrack->vtx_size = idx_value & 0x7F;\n\t\tbreak;\n\tcase 0x2134:\n\t\t \n\t\ttrack->max_indx = idx_value & 0x00FFFFFFUL;\n\t\tbreak;\n\tcase 0x2088:\n\t\t \n\t\tif (p->rdev->family < CHIP_RV515)\n\t\t\tgoto fail;\n\t\ttrack->vap_alt_nverts = idx_value & 0xFFFFFF;\n\t\tbreak;\n\tcase 0x43E4:\n\t\t \n\t\ttrack->maxy = ((idx_value >> 13) & 0x1FFF) + 1;\n\t\tif (p->rdev->family < CHIP_RV515) {\n\t\t\ttrack->maxy -= 1440;\n\t\t}\n\t\ttrack->cb_dirty = true;\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase 0x4E00:\n\t\t \n\t\tif ((idx_value & (1 << 10)) &&  \n\t\t    p->rdev->cmask_filp != p->filp) {\n\t\t\tDRM_ERROR(\"Invalid RB3D_CCTL: Cannot enable CMASK.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->num_cb = ((idx_value >> 5) & 0x3) + 1;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase 0x4E38:\n\tcase 0x4E3C:\n\tcase 0x4E40:\n\tcase 0x4E44:\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\t  idx, reg);\n\t\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\t\ttile_flags |= R300_COLOR_TILE_ENABLE;\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MICRO)\n\t\t\t\ttile_flags |= R300_COLOR_MICROTILE_ENABLE;\n\t\t\telse if (reloc->tiling_flags & RADEON_TILING_MICRO_SQUARE)\n\t\t\t\ttile_flags |= R300_COLOR_MICROTILE_SQUARE_ENABLE;\n\n\t\t\ttmp = idx_value & ~(0x7 << 16);\n\t\t\ttmp |= tile_flags;\n\t\t\tib[idx] = tmp;\n\t\t}\n\t\ti = (reg - 0x4E38) >> 2;\n\t\ttrack->cb[i].pitch = idx_value & 0x3FFE;\n\t\tswitch (((idx_value >> 21) & 0xF)) {\n\t\tcase 9:\n\t\tcase 11:\n\t\tcase 12:\n\t\t\ttrack->cb[i].cpp = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 13:\n\t\tcase 15:\n\t\t\ttrack->cb[i].cpp = 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (p->rdev->family < CHIP_RV515) {\n\t\t\t\tDRM_ERROR(\"Invalid color buffer format (%d)!\\n\",\n\t\t\t\t\t  ((idx_value >> 21) & 0xF));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 6:\n\t\t\ttrack->cb[i].cpp = 4;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\ttrack->cb[i].cpp = 8;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\ttrack->cb[i].cpp = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Invalid color buffer format (%d) !\\n\",\n\t\t\t\t  ((idx_value >> 21) & 0xF));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase 0x4F00:\n\t\t \n\t\tif (idx_value & 2) {\n\t\t\ttrack->z_enabled = true;\n\t\t} else {\n\t\t\ttrack->z_enabled = false;\n\t\t}\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase 0x4F10:\n\t\t \n\t\tswitch ((idx_value & 0xF)) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\ttrack->zb.cpp = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrack->zb.cpp = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Invalid z buffer format (%d) !\\n\",\n\t\t\t\t  (idx_value & 0xF));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase 0x4F24:\n\t\t \n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\t  idx, reg);\n\t\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\t\ttile_flags |= R300_DEPTHMACROTILE_ENABLE;\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MICRO)\n\t\t\t\ttile_flags |= R300_DEPTHMICROTILE_TILED;\n\t\t\telse if (reloc->tiling_flags & RADEON_TILING_MICRO_SQUARE)\n\t\t\t\ttile_flags |= R300_DEPTHMICROTILE_TILED_SQUARE;\n\n\t\t\ttmp = idx_value & ~(0x7 << 16);\n\t\t\ttmp |= tile_flags;\n\t\t\tib[idx] = tmp;\n\t\t}\n\t\ttrack->zb.pitch = idx_value & 0x3FFC;\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase 0x4104:\n\t\t \n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tbool enabled;\n\n\t\t\tenabled = !!(idx_value & (1 << i));\n\t\t\ttrack->textures[i].enabled = enabled;\n\t\t}\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase 0x44C0:\n\tcase 0x44C4:\n\tcase 0x44C8:\n\tcase 0x44CC:\n\tcase 0x44D0:\n\tcase 0x44D4:\n\tcase 0x44D8:\n\tcase 0x44DC:\n\tcase 0x44E0:\n\tcase 0x44E4:\n\tcase 0x44E8:\n\tcase 0x44EC:\n\tcase 0x44F0:\n\tcase 0x44F4:\n\tcase 0x44F8:\n\tcase 0x44FC:\n\t\t \n\t\ti = (reg - 0x44C0) >> 2;\n\t\ttmp = (idx_value >> 25) & 0x3;\n\t\ttrack->textures[i].tex_coord_type = tmp;\n\t\tswitch ((idx_value & 0x1F)) {\n\t\tcase R300_TX_FORMAT_X8:\n\t\tcase R300_TX_FORMAT_Y4X4:\n\t\tcase R300_TX_FORMAT_Z3Y3X2:\n\t\t\ttrack->textures[i].cpp = 1;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase R300_TX_FORMAT_X16:\n\t\tcase R300_TX_FORMAT_FL_I16:\n\t\tcase R300_TX_FORMAT_Y8X8:\n\t\tcase R300_TX_FORMAT_Z5Y6X5:\n\t\tcase R300_TX_FORMAT_Z6Y5X5:\n\t\tcase R300_TX_FORMAT_W4Z4Y4X4:\n\t\tcase R300_TX_FORMAT_W1Z5Y5X5:\n\t\tcase R300_TX_FORMAT_D3DMFT_CxV8U8:\n\t\tcase R300_TX_FORMAT_B8G8_B8G8:\n\t\tcase R300_TX_FORMAT_G8R8_G8B8:\n\t\t\ttrack->textures[i].cpp = 2;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase R300_TX_FORMAT_Y16X16:\n\t\tcase R300_TX_FORMAT_FL_I16A16:\n\t\tcase R300_TX_FORMAT_Z11Y11X10:\n\t\tcase R300_TX_FORMAT_Z10Y11X11:\n\t\tcase R300_TX_FORMAT_W8Z8Y8X8:\n\t\tcase R300_TX_FORMAT_W2Z10Y10X10:\n\t\tcase 0x17:\n\t\tcase R300_TX_FORMAT_FL_I32:\n\t\tcase 0x1e:\n\t\t\ttrack->textures[i].cpp = 4;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase R300_TX_FORMAT_W16Z16Y16X16:\n\t\tcase R300_TX_FORMAT_FL_R16G16B16A16:\n\t\tcase R300_TX_FORMAT_FL_I32A32:\n\t\t\ttrack->textures[i].cpp = 8;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase R300_TX_FORMAT_FL_R32G32B32A32:\n\t\t\ttrack->textures[i].cpp = 16;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase R300_TX_FORMAT_DXT1:\n\t\t\ttrack->textures[i].cpp = 1;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_DXT1;\n\t\t\tbreak;\n\t\tcase R300_TX_FORMAT_ATI2N:\n\t\t\tif (p->rdev->family < CHIP_R420) {\n\t\t\t\tDRM_ERROR(\"Invalid texture format %u\\n\",\n\t\t\t\t\t  (idx_value & 0x1F));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase R300_TX_FORMAT_DXT3:\n\t\tcase R300_TX_FORMAT_DXT5:\n\t\t\ttrack->textures[i].cpp = 1;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_DXT35;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Invalid texture format %u\\n\",\n\t\t\t\t  (idx_value & 0x1F));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase 0x4400:\n\tcase 0x4404:\n\tcase 0x4408:\n\tcase 0x440C:\n\tcase 0x4410:\n\tcase 0x4414:\n\tcase 0x4418:\n\tcase 0x441C:\n\tcase 0x4420:\n\tcase 0x4424:\n\tcase 0x4428:\n\tcase 0x442C:\n\tcase 0x4430:\n\tcase 0x4434:\n\tcase 0x4438:\n\tcase 0x443C:\n\t\t \n\t\ti = (reg - 0x4400) >> 2;\n\t\ttmp = idx_value & 0x7;\n\t\tif (tmp == 2 || tmp == 4 || tmp == 6) {\n\t\t\ttrack->textures[i].roundup_w = false;\n\t\t}\n\t\ttmp = (idx_value >> 3) & 0x7;\n\t\tif (tmp == 2 || tmp == 4 || tmp == 6) {\n\t\t\ttrack->textures[i].roundup_h = false;\n\t\t}\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase 0x4500:\n\tcase 0x4504:\n\tcase 0x4508:\n\tcase 0x450C:\n\tcase 0x4510:\n\tcase 0x4514:\n\tcase 0x4518:\n\tcase 0x451C:\n\tcase 0x4520:\n\tcase 0x4524:\n\tcase 0x4528:\n\tcase 0x452C:\n\tcase 0x4530:\n\tcase 0x4534:\n\tcase 0x4538:\n\tcase 0x453C:\n\t\t \n\t\ti = (reg - 0x4500) >> 2;\n\t\ttmp = idx_value & 0x3FFF;\n\t\ttrack->textures[i].pitch = tmp + 1;\n\t\tif (p->rdev->family >= CHIP_RV515) {\n\t\t\ttmp = ((idx_value >> 15) & 1) << 11;\n\t\t\ttrack->textures[i].width_11 = tmp;\n\t\t\ttmp = ((idx_value >> 16) & 1) << 11;\n\t\t\ttrack->textures[i].height_11 = tmp;\n\n\t\t\t \n\t\t\tif (idx_value & (1 << 14)) {\n\t\t\t\t \n\t\t\t\ttrack->textures[i].compress_format =\n\t\t\t\t\tR100_TRACK_COMP_DXT1;\n\t\t\t}\n\t\t} else if (idx_value & (1 << 14)) {\n\t\t\tDRM_ERROR(\"Forbidden bit TXFORMAT_MSB\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase 0x4480:\n\tcase 0x4484:\n\tcase 0x4488:\n\tcase 0x448C:\n\tcase 0x4490:\n\tcase 0x4494:\n\tcase 0x4498:\n\tcase 0x449C:\n\tcase 0x44A0:\n\tcase 0x44A4:\n\tcase 0x44A8:\n\tcase 0x44AC:\n\tcase 0x44B0:\n\tcase 0x44B4:\n\tcase 0x44B8:\n\tcase 0x44BC:\n\t\t \n\t\ti = (reg - 0x4480) >> 2;\n\t\ttmp = idx_value & 0x7FF;\n\t\ttrack->textures[i].width = tmp + 1;\n\t\ttmp = (idx_value >> 11) & 0x7FF;\n\t\ttrack->textures[i].height = tmp + 1;\n\t\ttmp = (idx_value >> 26) & 0xF;\n\t\ttrack->textures[i].num_levels = tmp;\n\t\ttmp = idx_value & (1 << 31);\n\t\ttrack->textures[i].use_pitch = !!tmp;\n\t\ttmp = (idx_value >> 22) & 0xF;\n\t\ttrack->textures[i].txdepth = tmp;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase R300_ZB_ZPASS_ADDR:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase 0x4e0c:\n\t\t \n\t\ttrack->color_channel_mask = idx_value;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase 0x43a4:\n\t\t \n\t\t \n\t\tif (p->rdev->hyperz_filp != p->filp) {\n\t\t\tif (idx_value & 0x1)\n\t\t\t\tib[idx] = idx_value & ~1;\n\t\t}\n\t\tbreak;\n\tcase 0x4f1c:\n\t\t \n\t\ttrack->zb_cb_clear = !!(idx_value & (1 << 5));\n\t\ttrack->cb_dirty = true;\n\t\ttrack->zb_dirty = true;\n\t\tif (p->rdev->hyperz_filp != p->filp) {\n\t\t\tif (idx_value & (R300_HIZ_ENABLE |\n\t\t\t\t\t R300_RD_COMP_ENABLE |\n\t\t\t\t\t R300_WR_COMP_ENABLE |\n\t\t\t\t\t R300_FAST_FILL_ENABLE))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tcase 0x4e04:\n\t\t \n\t\ttrack->blend_read_enable = !!(idx_value & (1 << 2));\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase R300_RB3D_AARESOLVE_OFFSET:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->aa.robj = reloc->robj;\n\t\ttrack->aa.offset = idx_value;\n\t\ttrack->aa_dirty = true;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase R300_RB3D_AARESOLVE_PITCH:\n\t\ttrack->aa.pitch = idx_value & 0x3FFE;\n\t\ttrack->aa_dirty = true;\n\t\tbreak;\n\tcase R300_RB3D_AARESOLVE_CTL:\n\t\ttrack->aaresolve = idx_value & 0x1;\n\t\ttrack->aa_dirty = true;\n\t\tbreak;\n\tcase 0x4f30:  \n\tcase 0x4f34:  \n\tcase 0x4f44:  \n\tcase 0x4f54:  \n\t\tif (idx_value && (p->rdev->hyperz_filp != p->filp))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase 0x4028:\n\t\tif (idx_value && (p->rdev->hyperz_filp != p->filp))\n\t\t\tgoto fail;\n\t\t \n\t\tif (p->rdev->family >= CHIP_RV350)\n\t\t\tbreak;\n\t\tgoto fail;\n\t\tbreak;\n\tcase 0x4be8:\n\t\t \n\t\tif (p->rdev->family == CHIP_RV530)\n\t\t\tbreak;\n\t\tfallthrough;\n\t\t \n\tdefault:\n\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\tpr_err(\"Forbidden register 0x%04X in cs at %d (val=%08x)\\n\",\n\t       reg, idx, idx_value);\n\treturn -EINVAL;\n}\n\nstatic int r300_packet3_check(struct radeon_cs_parser *p,\n\t\t\t      struct radeon_cs_packet *pkt)\n{\n\tstruct radeon_bo_list *reloc;\n\tstruct r100_cs_track *track;\n\tvolatile uint32_t *ib;\n\tunsigned idx;\n\tint r;\n\n\tib = p->ib.ptr;\n\tidx = pkt->idx + 1;\n\ttrack = (struct r100_cs_track *)p->track;\n\tswitch (pkt->opcode) {\n\tcase PACKET3_3D_LOAD_VBPNTR:\n\t\tr = r100_packet3_load_vbpntr(p, pkt, idx);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tcase PACKET3_INDX_BUFFER:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for packet3 %d\\n\", pkt->opcode);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tib[idx+1] = radeon_get_ib_value(p, idx + 1) + ((u32)reloc->gpu_offset);\n\t\tr = r100_cs_track_check_pkt3_indx_buffer(p, pkt, reloc->robj);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t \n\tcase PACKET3_3D_DRAW_IMMD:\n\t\t \n\t\tif (((radeon_get_ib_value(p, idx + 1) >> 4) & 0x3) != 3) {\n\t\t\tDRM_ERROR(\"PRIM_WALK must be 3 for IMMD draw\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\n\t\ttrack->immd_dwords = pkt->count - 1;\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_3D_DRAW_IMMD_2:\n\t\t \n\t\tif (((radeon_get_ib_value(p, idx) >> 4) & 0x3) != 3) {\n\t\t\tDRM_ERROR(\"PRIM_WALK must be 3 for IMMD draw\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\n\t\ttrack->immd_dwords = pkt->count;\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_3D_DRAW_VBUF:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_3D_DRAW_VBUF_2:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_3D_DRAW_INDX:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_3D_DRAW_INDX_2:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_3D_CLEAR_HIZ:\n\tcase PACKET3_3D_CLEAR_ZMASK:\n\t\tif (p->rdev->hyperz_filp != p->filp)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PACKET3_3D_CLEAR_CMASK:\n\t\tif (p->rdev->cmask_filp != p->filp)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PACKET3_NOP:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Packet3 opcode %x not supported\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint r300_cs_parse(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_packet pkt;\n\tstruct r100_cs_track *track;\n\tint r;\n\n\ttrack = kzalloc(sizeof(*track), GFP_KERNEL);\n\tif (track == NULL)\n\t\treturn -ENOMEM;\n\tr100_cs_track_clear(p->rdev, track);\n\tp->track = track;\n\tdo {\n\t\tr = radeon_cs_packet_parse(p, &pkt, p->idx);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tp->idx += pkt.count + 2;\n\t\tswitch (pkt.type) {\n\t\tcase RADEON_PACKET_TYPE0:\n\t\t\tr = r100_cs_parse_packet0(p, &pkt,\n\t\t\t\t\t\t  p->rdev->config.r300.reg_safe_bm,\n\t\t\t\t\t\t  p->rdev->config.r300.reg_safe_bm_size,\n\t\t\t\t\t\t  &r300_packet0_check);\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE2:\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE3:\n\t\t\tr = r300_packet3_check(p, &pkt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d !\\n\", pkt.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t} while (p->idx < p->chunk_ib->length_dw);\n\treturn 0;\n}\n\nvoid r300_set_reg_safe(struct radeon_device *rdev)\n{\n\trdev->config.r300.reg_safe_bm = r300_reg_safe_bm;\n\trdev->config.r300.reg_safe_bm_size = ARRAY_SIZE(r300_reg_safe_bm);\n}\n\nvoid r300_mc_program(struct radeon_device *rdev)\n{\n\tstruct r100_mc_save save;\n\n\tr100_debugfs_mc_info_init(rdev);\n\n\t \n\tr100_mc_stop(rdev, &save);\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tWREG32(R_00014C_MC_AGP_LOCATION,\n\t\t\tS_00014C_MC_AGP_START(rdev->mc.gtt_start >> 16) |\n\t\t\tS_00014C_MC_AGP_TOP(rdev->mc.gtt_end >> 16));\n\t\tWREG32(R_000170_AGP_BASE, lower_32_bits(rdev->mc.agp_base));\n\t\tWREG32(R_00015C_AGP_BASE_2,\n\t\t\tupper_32_bits(rdev->mc.agp_base) & 0xff);\n\t} else {\n\t\tWREG32(R_00014C_MC_AGP_LOCATION, 0x0FFFFFFF);\n\t\tWREG32(R_000170_AGP_BASE, 0);\n\t\tWREG32(R_00015C_AGP_BASE_2, 0);\n\t}\n\t \n\tif (r300_mc_wait_for_idle(rdev))\n\t\tDRM_INFO(\"Failed to wait MC idle before programming MC.\\n\");\n\t \n\tWREG32(R_000148_MC_FB_LOCATION,\n\t\tS_000148_MC_FB_START(rdev->mc.vram_start >> 16) |\n\t\tS_000148_MC_FB_TOP(rdev->mc.vram_end >> 16));\n\tr100_mc_resume(rdev, &save);\n}\n\nvoid r300_clock_startup(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tif (radeon_dynclks != -1 && radeon_dynclks)\n\t\tradeon_legacy_set_clock_gating(rdev, 1);\n\t \n\ttmp = RREG32_PLL(R_00000D_SCLK_CNTL);\n\ttmp |= S_00000D_FORCE_CP(1) | S_00000D_FORCE_VIP(1);\n\tif ((rdev->family == CHIP_RV350) || (rdev->family == CHIP_RV380))\n\t\ttmp |= S_00000D_FORCE_VAP(1);\n\tWREG32_PLL(R_00000D_SCLK_CNTL, tmp);\n}\n\nstatic int r300_startup(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tr100_set_common_regs(rdev);\n\t \n\tr300_mc_program(rdev);\n\t \n\tr300_clock_startup(rdev);\n\t \n\tr300_gpu_init(rdev);\n\t \n\tif (rdev->flags & RADEON_IS_PCIE) {\n\t\tr = rv370_pcie_gart_enable(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tif (rdev->family == CHIP_R300 ||\n\t    rdev->family == CHIP_R350 ||\n\t    rdev->family == CHIP_RV350)\n\t\tr100_enable_bm(rdev);\n\n\tif (rdev->flags & RADEON_IS_PCI) {\n\t\tr = r100_pci_gart_enable(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr100_irq_set(rdev);\n\trdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\n\t \n\tr = r100_cp_init(rdev, 1024 * 1024);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint r300_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\trv370_pcie_gart_disable(rdev);\n\tif (rdev->flags & RADEON_IS_PCI)\n\t\tr100_pci_gart_disable(rdev);\n\t \n\tr300_clock_startup(rdev);\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev, \"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tradeon_combios_asic_init(rdev->ddev);\n\t \n\tr300_clock_startup(rdev);\n\t \n\tradeon_surface_init(rdev);\n\n\trdev->accel_working = true;\n\tr = r300_startup(rdev);\n\tif (r) {\n\t\trdev->accel_working = false;\n\t}\n\treturn r;\n}\n\nint r300_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tr100_cp_disable(rdev);\n\tradeon_wb_disable(rdev);\n\tr100_irq_disable(rdev);\n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\trv370_pcie_gart_disable(rdev);\n\tif (rdev->flags & RADEON_IS_PCI)\n\t\tr100_pci_gart_disable(rdev);\n\treturn 0;\n}\n\nvoid r300_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tr100_cp_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\trv370_pcie_gart_fini(rdev);\n\tif (rdev->flags & RADEON_IS_PCI)\n\t\tr100_pci_gart_fini(rdev);\n\tradeon_agp_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nint r300_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tr100_vga_render_disable(rdev);\n\t \n\tradeon_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\t \n\tr100_restore_sanity(rdev);\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting combios for RS400/RS480 GPU\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tr = radeon_combios_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev,\n\t\t\t\"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tif (radeon_boot_test_post_card(rdev) == false)\n\t\treturn -EINVAL;\n\t \n\tr300_errata(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr = radeon_agp_init(rdev);\n\t\tif (r) {\n\t\t\tradeon_agp_disable(rdev);\n\t\t}\n\t}\n\t \n\tr300_mc_init(rdev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\tif (rdev->flags & RADEON_IS_PCIE) {\n\t\tr = rv370_pcie_gart_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tif (rdev->flags & RADEON_IS_PCI) {\n\t\tr = r100_pci_gart_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tr300_set_reg_safe(rdev);\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->accel_working = true;\n\tr = r300_startup(rdev);\n\tif (r) {\n\t\t \n\t\tdev_err(rdev->dev, \"Disabling GPU acceleration\\n\");\n\t\tr100_cp_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tif (rdev->flags & RADEON_IS_PCIE)\n\t\t\trv370_pcie_gart_fini(rdev);\n\t\tif (rdev->flags & RADEON_IS_PCI)\n\t\t\tr100_pci_gart_fini(rdev);\n\t\tradeon_agp_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}