{
  "module_name": "r600_cs.c",
  "hash_id": "f9306972f5c5176acac03c544dca4ce9d9dd3d9a365fdffb0d59a66362df3d71",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/r600_cs.c",
  "human_readable_source": " \n#include <linux/kernel.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"r600.h\"\n#include \"r600d.h\"\n#include \"r600_reg_safe.h\"\n\nstatic int r600_nomm;\n\nstruct r600_cs_track {\n\t \n\tu32\t\t\tgroup_size;\n\tu32\t\t\tnbanks;\n\tu32\t\t\tnpipes;\n\t \n\tu32\t\t\tsq_config;\n\tu32\t\t\tlog_nsamples;\n\tu32\t\t\tnsamples;\n\tu32\t\t\tcb_color_base_last[8];\n\tstruct radeon_bo\t*cb_color_bo[8];\n\tu64\t\t\tcb_color_bo_mc[8];\n\tu64\t\t\tcb_color_bo_offset[8];\n\tstruct radeon_bo\t*cb_color_frag_bo[8];\n\tu64\t\t\tcb_color_frag_offset[8];\n\tstruct radeon_bo\t*cb_color_tile_bo[8];\n\tu64\t\t\tcb_color_tile_offset[8];\n\tu32\t\t\tcb_color_mask[8];\n\tu32\t\t\tcb_color_info[8];\n\tu32\t\t\tcb_color_view[8];\n\tu32\t\t\tcb_color_size_idx[8];  \n\tu32\t\t\tcb_target_mask;\n\tu32\t\t\tcb_shader_mask;   \n\tbool\t\t\tis_resolve;\n\tu32\t\t\tcb_color_size[8];\n\tu32\t\t\tvgt_strmout_en;\n\tu32\t\t\tvgt_strmout_buffer_en;\n\tstruct radeon_bo\t*vgt_strmout_bo[4];\n\tu64\t\t\tvgt_strmout_bo_mc[4];  \n\tu32\t\t\tvgt_strmout_bo_offset[4];\n\tu32\t\t\tvgt_strmout_size[4];\n\tu32\t\t\tdb_depth_control;\n\tu32\t\t\tdb_depth_info;\n\tu32\t\t\tdb_depth_size_idx;\n\tu32\t\t\tdb_depth_view;\n\tu32\t\t\tdb_depth_size;\n\tu32\t\t\tdb_offset;\n\tstruct radeon_bo\t*db_bo;\n\tu64\t\t\tdb_bo_mc;\n\tbool\t\t\tsx_misc_kill_all_prims;\n\tbool\t\t\tcb_dirty;\n\tbool\t\t\tdb_dirty;\n\tbool\t\t\tstreamout_dirty;\n\tstruct radeon_bo\t*htile_bo;\n\tu64\t\t\thtile_offset;\n\tu32\t\t\thtile_surface;\n};\n\n#define FMT_8_BIT(fmt, vc)   [fmt] = { 1, 1, 1, vc, CHIP_R600 }\n#define FMT_16_BIT(fmt, vc)  [fmt] = { 1, 1, 2, vc, CHIP_R600 }\n#define FMT_24_BIT(fmt)      [fmt] = { 1, 1, 4,  0, CHIP_R600 }\n#define FMT_32_BIT(fmt, vc)  [fmt] = { 1, 1, 4, vc, CHIP_R600 }\n#define FMT_48_BIT(fmt)      [fmt] = { 1, 1, 8,  0, CHIP_R600 }\n#define FMT_64_BIT(fmt, vc)  [fmt] = { 1, 1, 8, vc, CHIP_R600 }\n#define FMT_96_BIT(fmt)      [fmt] = { 1, 1, 12, 0, CHIP_R600 }\n#define FMT_128_BIT(fmt, vc) [fmt] = { 1, 1, 16,vc, CHIP_R600 }\n\nstruct gpu_formats {\n\tunsigned blockwidth;\n\tunsigned blockheight;\n\tunsigned blocksize;\n\tunsigned valid_color;\n\tenum radeon_family min_family;\n};\n\nstatic const struct gpu_formats color_formats_table[] = {\n\t \n\tFMT_8_BIT(V_038004_COLOR_8, 1),\n\tFMT_8_BIT(V_038004_COLOR_4_4, 1),\n\tFMT_8_BIT(V_038004_COLOR_3_3_2, 1),\n\tFMT_8_BIT(V_038004_FMT_1, 0),\n\n\t \n\tFMT_16_BIT(V_038004_COLOR_16, 1),\n\tFMT_16_BIT(V_038004_COLOR_16_FLOAT, 1),\n\tFMT_16_BIT(V_038004_COLOR_8_8, 1),\n\tFMT_16_BIT(V_038004_COLOR_5_6_5, 1),\n\tFMT_16_BIT(V_038004_COLOR_6_5_5, 1),\n\tFMT_16_BIT(V_038004_COLOR_1_5_5_5, 1),\n\tFMT_16_BIT(V_038004_COLOR_4_4_4_4, 1),\n\tFMT_16_BIT(V_038004_COLOR_5_5_5_1, 1),\n\n\t \n\tFMT_24_BIT(V_038004_FMT_8_8_8),\n\n\t \n\tFMT_32_BIT(V_038004_COLOR_32, 1),\n\tFMT_32_BIT(V_038004_COLOR_32_FLOAT, 1),\n\tFMT_32_BIT(V_038004_COLOR_16_16, 1),\n\tFMT_32_BIT(V_038004_COLOR_16_16_FLOAT, 1),\n\tFMT_32_BIT(V_038004_COLOR_8_24, 1),\n\tFMT_32_BIT(V_038004_COLOR_8_24_FLOAT, 1),\n\tFMT_32_BIT(V_038004_COLOR_24_8, 1),\n\tFMT_32_BIT(V_038004_COLOR_24_8_FLOAT, 1),\n\tFMT_32_BIT(V_038004_COLOR_10_11_11, 1),\n\tFMT_32_BIT(V_038004_COLOR_10_11_11_FLOAT, 1),\n\tFMT_32_BIT(V_038004_COLOR_11_11_10, 1),\n\tFMT_32_BIT(V_038004_COLOR_11_11_10_FLOAT, 1),\n\tFMT_32_BIT(V_038004_COLOR_2_10_10_10, 1),\n\tFMT_32_BIT(V_038004_COLOR_8_8_8_8, 1),\n\tFMT_32_BIT(V_038004_COLOR_10_10_10_2, 1),\n\tFMT_32_BIT(V_038004_FMT_5_9_9_9_SHAREDEXP, 0),\n\tFMT_32_BIT(V_038004_FMT_32_AS_8, 0),\n\tFMT_32_BIT(V_038004_FMT_32_AS_8_8, 0),\n\n\t \n\tFMT_48_BIT(V_038004_FMT_16_16_16),\n\tFMT_48_BIT(V_038004_FMT_16_16_16_FLOAT),\n\n\t \n\tFMT_64_BIT(V_038004_COLOR_X24_8_32_FLOAT, 1),\n\tFMT_64_BIT(V_038004_COLOR_32_32, 1),\n\tFMT_64_BIT(V_038004_COLOR_32_32_FLOAT, 1),\n\tFMT_64_BIT(V_038004_COLOR_16_16_16_16, 1),\n\tFMT_64_BIT(V_038004_COLOR_16_16_16_16_FLOAT, 1),\n\n\tFMT_96_BIT(V_038004_FMT_32_32_32),\n\tFMT_96_BIT(V_038004_FMT_32_32_32_FLOAT),\n\n\t \n\tFMT_128_BIT(V_038004_COLOR_32_32_32_32, 1),\n\tFMT_128_BIT(V_038004_COLOR_32_32_32_32_FLOAT, 1),\n\n\t[V_038004_FMT_GB_GR] = { 2, 1, 4, 0 },\n\t[V_038004_FMT_BG_RG] = { 2, 1, 4, 0 },\n\n\t \n\t[V_038004_FMT_BC1] = { 4, 4, 8, 0 },\n\t[V_038004_FMT_BC2] = { 4, 4, 16, 0 },\n\t[V_038004_FMT_BC3] = { 4, 4, 16, 0 },\n\t[V_038004_FMT_BC4] = { 4, 4, 8, 0 },\n\t[V_038004_FMT_BC5] = { 4, 4, 16, 0},\n\t[V_038004_FMT_BC6] = { 4, 4, 16, 0, CHIP_CEDAR},  \n\t[V_038004_FMT_BC7] = { 4, 4, 16, 0, CHIP_CEDAR},  \n\n\t \n\t[V_038004_FMT_32_AS_32_32_32_32] = { 1, 1, 4, 0, CHIP_CEDAR},\n};\n\nbool r600_fmt_is_valid_color(u32 format)\n{\n\tif (format >= ARRAY_SIZE(color_formats_table))\n\t\treturn false;\n\n\tif (color_formats_table[format].valid_color)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool r600_fmt_is_valid_texture(u32 format, enum radeon_family family)\n{\n\tif (format >= ARRAY_SIZE(color_formats_table))\n\t\treturn false;\n\n\tif (family < color_formats_table[format].min_family)\n\t\treturn false;\n\n\tif (color_formats_table[format].blockwidth > 0)\n\t\treturn true;\n\n\treturn false;\n}\n\nint r600_fmt_get_blocksize(u32 format)\n{\n\tif (format >= ARRAY_SIZE(color_formats_table))\n\t\treturn 0;\n\n\treturn color_formats_table[format].blocksize;\n}\n\nint r600_fmt_get_nblocksx(u32 format, u32 w)\n{\n\tunsigned bw;\n\n\tif (format >= ARRAY_SIZE(color_formats_table))\n\t\treturn 0;\n\n\tbw = color_formats_table[format].blockwidth;\n\tif (bw == 0)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(w, bw);\n}\n\nint r600_fmt_get_nblocksy(u32 format, u32 h)\n{\n\tunsigned bh;\n\n\tif (format >= ARRAY_SIZE(color_formats_table))\n\t\treturn 0;\n\n\tbh = color_formats_table[format].blockheight;\n\tif (bh == 0)\n\t\treturn 0;\n\n\treturn DIV_ROUND_UP(h, bh);\n}\n\nstruct array_mode_checker {\n\tint array_mode;\n\tu32 group_size;\n\tu32 nbanks;\n\tu32 npipes;\n\tu32 nsamples;\n\tu32 blocksize;\n};\n\n \nstatic int r600_get_array_mode_alignment(struct array_mode_checker *values,\n\t\t\t\t\t\tu32 *pitch_align,\n\t\t\t\t\t\tu32 *height_align,\n\t\t\t\t\t\tu32 *depth_align,\n\t\t\t\t\t\tu64 *base_align)\n{\n\tu32 tile_width = 8;\n\tu32 tile_height = 8;\n\tu32 macro_tile_width = values->nbanks;\n\tu32 macro_tile_height = values->npipes;\n\tu32 tile_bytes = tile_width * tile_height * values->blocksize * values->nsamples;\n\tu32 macro_tile_bytes = macro_tile_width * macro_tile_height * tile_bytes;\n\n\tswitch (values->array_mode) {\n\tcase ARRAY_LINEAR_GENERAL:\n\t\t \n\t\t*pitch_align = 1;  \n\t\t*height_align = 1;  \n\t\t*depth_align = 1;\n\t\t*base_align = 1;\n\t\tbreak;\n\tcase ARRAY_LINEAR_ALIGNED:\n\t\t*pitch_align = max((u32)64, (u32)(values->group_size / values->blocksize));\n\t\t*height_align = 1;\n\t\t*depth_align = 1;\n\t\t*base_align = values->group_size;\n\t\tbreak;\n\tcase ARRAY_1D_TILED_THIN1:\n\t\t*pitch_align = max((u32)tile_width,\n\t\t\t\t   (u32)(values->group_size /\n\t\t\t\t\t (tile_height * values->blocksize * values->nsamples)));\n\t\t*height_align = tile_height;\n\t\t*depth_align = 1;\n\t\t*base_align = values->group_size;\n\t\tbreak;\n\tcase ARRAY_2D_TILED_THIN1:\n\t\t*pitch_align = max((u32)macro_tile_width * tile_width,\n\t\t\t\t(u32)((values->group_size * values->nbanks) /\n\t\t\t\t(values->blocksize * values->nsamples * tile_width)));\n\t\t*height_align = macro_tile_height * tile_height;\n\t\t*depth_align = 1;\n\t\t*base_align = max(macro_tile_bytes,\n\t\t\t\t  (*pitch_align) * values->blocksize * (*height_align) * values->nsamples);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void r600_cs_track_init(struct r600_cs_track *track)\n{\n\tint i;\n\n\t \n\ttrack->sq_config = DX9_CONSTS;\n\tfor (i = 0; i < 8; i++) {\n\t\ttrack->cb_color_base_last[i] = 0;\n\t\ttrack->cb_color_size[i] = 0;\n\t\ttrack->cb_color_size_idx[i] = 0;\n\t\ttrack->cb_color_info[i] = 0;\n\t\ttrack->cb_color_view[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_bo[i] = NULL;\n\t\ttrack->cb_color_bo_offset[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_bo_mc[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_frag_bo[i] = NULL;\n\t\ttrack->cb_color_frag_offset[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_tile_bo[i] = NULL;\n\t\ttrack->cb_color_tile_offset[i] = 0xFFFFFFFF;\n\t\ttrack->cb_color_mask[i] = 0xFFFFFFFF;\n\t}\n\ttrack->is_resolve = false;\n\ttrack->nsamples = 16;\n\ttrack->log_nsamples = 4;\n\ttrack->cb_target_mask = 0xFFFFFFFF;\n\ttrack->cb_shader_mask = 0xFFFFFFFF;\n\ttrack->cb_dirty = true;\n\ttrack->db_bo = NULL;\n\ttrack->db_bo_mc = 0xFFFFFFFF;\n\t \n\ttrack->db_depth_info = 7 | (1 << 25);\n\ttrack->db_depth_view = 0xFFFFC000;\n\ttrack->db_depth_size = 0xFFFFFFFF;\n\ttrack->db_depth_size_idx = 0;\n\ttrack->db_depth_control = 0xFFFFFFFF;\n\ttrack->db_dirty = true;\n\ttrack->htile_bo = NULL;\n\ttrack->htile_offset = 0xFFFFFFFF;\n\ttrack->htile_surface = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\ttrack->vgt_strmout_size[i] = 0;\n\t\ttrack->vgt_strmout_bo[i] = NULL;\n\t\ttrack->vgt_strmout_bo_offset[i] = 0xFFFFFFFF;\n\t\ttrack->vgt_strmout_bo_mc[i] = 0xFFFFFFFF;\n\t}\n\ttrack->streamout_dirty = true;\n\ttrack->sx_misc_kill_all_prims = false;\n}\n\nstatic int r600_cs_track_validate_cb(struct radeon_cs_parser *p, int i)\n{\n\tstruct r600_cs_track *track = p->track;\n\tu32 slice_tile_max, tmp;\n\tu32 height, height_align, pitch, pitch_align, depth_align;\n\tu64 base_offset, base_align;\n\tstruct array_mode_checker array_check;\n\tvolatile u32 *ib = p->ib.ptr;\n\tunsigned array_mode;\n\tu32 format;\n\t \n\tunsigned nsamples = track->is_resolve && i == 1 ? 1 : track->nsamples;\n\n\tformat = G_0280A0_FORMAT(track->cb_color_info[i]);\n\tif (!r600_fmt_is_valid_color(format)) {\n\t\tdev_warn(p->dev, \"%s:%d cb invalid format %d for %d (0x%08X)\\n\",\n\t\t\t __func__, __LINE__, format,\n\t\t\ti, track->cb_color_info[i]);\n\t\treturn -EINVAL;\n\t}\n\t \n\tpitch = (G_028060_PITCH_TILE_MAX(track->cb_color_size[i]) + 1) * 8;\n\tslice_tile_max = G_028060_SLICE_TILE_MAX(track->cb_color_size[i]) + 1;\n\tslice_tile_max *= 64;\n\theight = slice_tile_max / pitch;\n\tif (height > 8192)\n\t\theight = 8192;\n\tarray_mode = G_0280A0_ARRAY_MODE(track->cb_color_info[i]);\n\n\tbase_offset = track->cb_color_bo_mc[i] + track->cb_color_bo_offset[i];\n\tarray_check.array_mode = array_mode;\n\tarray_check.group_size = track->group_size;\n\tarray_check.nbanks = track->nbanks;\n\tarray_check.npipes = track->npipes;\n\tarray_check.nsamples = nsamples;\n\tarray_check.blocksize = r600_fmt_get_blocksize(format);\n\tif (r600_get_array_mode_alignment(&array_check,\n\t\t\t\t\t  &pitch_align, &height_align, &depth_align, &base_align)) {\n\t\tdev_warn(p->dev, \"%s invalid tiling %d for %d (0x%08X)\\n\", __func__,\n\t\t\t G_0280A0_ARRAY_MODE(track->cb_color_info[i]), i,\n\t\t\t track->cb_color_info[i]);\n\t\treturn -EINVAL;\n\t}\n\tswitch (array_mode) {\n\tcase V_0280A0_ARRAY_LINEAR_GENERAL:\n\t\tbreak;\n\tcase V_0280A0_ARRAY_LINEAR_ALIGNED:\n\t\tbreak;\n\tcase V_0280A0_ARRAY_1D_TILED_THIN1:\n\t\t \n\t\tif (height > 7)\n\t\t\theight &= ~0x7;\n\t\tbreak;\n\tcase V_0280A0_ARRAY_2D_TILED_THIN1:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"%s invalid tiling %d for %d (0x%08X)\\n\", __func__,\n\t\t\tG_0280A0_ARRAY_MODE(track->cb_color_info[i]), i,\n\t\t\ttrack->cb_color_info[i]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!IS_ALIGNED(pitch, pitch_align)) {\n\t\tdev_warn(p->dev, \"%s:%d cb pitch (%d, 0x%x, %d) invalid\\n\",\n\t\t\t __func__, __LINE__, pitch, pitch_align, array_mode);\n\t\treturn -EINVAL;\n\t}\n\tif (!IS_ALIGNED(height, height_align)) {\n\t\tdev_warn(p->dev, \"%s:%d cb height (%d, 0x%x, %d) invalid\\n\",\n\t\t\t __func__, __LINE__, height, height_align, array_mode);\n\t\treturn -EINVAL;\n\t}\n\tif (!IS_ALIGNED(base_offset, base_align)) {\n\t\tdev_warn(p->dev, \"%s offset[%d] 0x%llx 0x%llx, %d not aligned\\n\", __func__, i,\n\t\t\t base_offset, base_align, array_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttmp = r600_fmt_get_nblocksy(format, height) * r600_fmt_get_nblocksx(format, pitch) *\n\t      r600_fmt_get_blocksize(format) * nsamples;\n\tswitch (array_mode) {\n\tdefault:\n\tcase V_0280A0_ARRAY_LINEAR_GENERAL:\n\tcase V_0280A0_ARRAY_LINEAR_ALIGNED:\n\t\ttmp += track->cb_color_view[i] & 0xFF;\n\t\tbreak;\n\tcase V_0280A0_ARRAY_1D_TILED_THIN1:\n\tcase V_0280A0_ARRAY_2D_TILED_THIN1:\n\t\ttmp += G_028080_SLICE_MAX(track->cb_color_view[i]) * tmp;\n\t\tbreak;\n\t}\n\tif ((tmp + track->cb_color_bo_offset[i]) > radeon_bo_size(track->cb_color_bo[i])) {\n\t\tif (array_mode == V_0280A0_ARRAY_LINEAR_GENERAL) {\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t} else {\n\t\t\tdev_warn(p->dev, \"%s offset[%d] %d %llu %d %lu too big (%d %d) (%d %d %d)\\n\",\n\t\t\t\t __func__, i, array_mode,\n\t\t\t\t track->cb_color_bo_offset[i], tmp,\n\t\t\t\t radeon_bo_size(track->cb_color_bo[i]),\n\t\t\t\t pitch, height, r600_fmt_get_nblocksx(format, pitch),\n\t\t\t\t r600_fmt_get_nblocksy(format, height),\n\t\t\t\t r600_fmt_get_blocksize(format));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\ttmp = (height * pitch) >> 6;\n\tif (tmp < slice_tile_max)\n\t\tslice_tile_max = tmp;\n\ttmp = S_028060_PITCH_TILE_MAX((pitch / 8) - 1) |\n\t\tS_028060_SLICE_TILE_MAX(slice_tile_max - 1);\n\tib[track->cb_color_size_idx[i]] = tmp;\n\n\t \n\tswitch (G_0280A0_TILE_MODE(track->cb_color_info[i])) {\n\tcase V_0280A0_TILE_DISABLE:\n\t\tbreak;\n\tcase V_0280A0_FRAG_ENABLE:\n\t\tif (track->nsamples > 1) {\n\t\t\tuint32_t tile_max = G_028100_FMASK_TILE_MAX(track->cb_color_mask[i]);\n\t\t\t \n\t\t\tuint32_t bytes = track->nsamples * track->log_nsamples * 8 * (tile_max + 1);\n\n\t\t\tif (bytes + track->cb_color_frag_offset[i] >\n\t\t\t    radeon_bo_size(track->cb_color_frag_bo[i])) {\n\t\t\t\tdev_warn(p->dev, \"%s FMASK_TILE_MAX too large \"\n\t\t\t\t\t \"(tile_max=%u, bytes=%u, offset=%llu, bo_size=%lu)\\n\",\n\t\t\t\t\t __func__, tile_max, bytes,\n\t\t\t\t\t track->cb_color_frag_offset[i],\n\t\t\t\t\t radeon_bo_size(track->cb_color_frag_bo[i]));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tcase V_0280A0_CLEAR_ENABLE:\n\t{\n\t\tuint32_t block_max = G_028100_CMASK_BLOCK_MAX(track->cb_color_mask[i]);\n\t\t \n\t\tuint32_t bytes = (block_max + 1) * 128;\n\n\t\tif (bytes + track->cb_color_tile_offset[i] >\n\t\t    radeon_bo_size(track->cb_color_tile_bo[i])) {\n\t\t\tdev_warn(p->dev, \"%s CMASK_BLOCK_MAX too large \"\n\t\t\t\t \"(block_max=%u, bytes=%u, offset=%llu, bo_size=%lu)\\n\",\n\t\t\t\t __func__, block_max, bytes,\n\t\t\t\t track->cb_color_tile_offset[i],\n\t\t\t\t radeon_bo_size(track->cb_color_tile_bo[i]));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdev_warn(p->dev, \"%s invalid tile mode\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int r600_cs_track_validate_db(struct radeon_cs_parser *p)\n{\n\tstruct r600_cs_track *track = p->track;\n\tu32 nviews, bpe, ntiles, slice_tile_max, tmp;\n\tu32 height_align, pitch_align, depth_align;\n\tu32 pitch = 8192;\n\tu32 height = 8192;\n\tu64 base_offset, base_align;\n\tstruct array_mode_checker array_check;\n\tint array_mode;\n\tvolatile u32 *ib = p->ib.ptr;\n\n\n\tif (track->db_bo == NULL) {\n\t\tdev_warn(p->dev, \"z/stencil with no depth buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\tswitch (G_028010_FORMAT(track->db_depth_info)) {\n\tcase V_028010_DEPTH_16:\n\t\tbpe = 2;\n\t\tbreak;\n\tcase V_028010_DEPTH_X8_24:\n\tcase V_028010_DEPTH_8_24:\n\tcase V_028010_DEPTH_X8_24_FLOAT:\n\tcase V_028010_DEPTH_8_24_FLOAT:\n\tcase V_028010_DEPTH_32_FLOAT:\n\t\tbpe = 4;\n\t\tbreak;\n\tcase V_028010_DEPTH_X24_8_32_FLOAT:\n\t\tbpe = 8;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"z/stencil with invalid format %d\\n\", G_028010_FORMAT(track->db_depth_info));\n\t\treturn -EINVAL;\n\t}\n\tif ((track->db_depth_size & 0xFFFFFC00) == 0xFFFFFC00) {\n\t\tif (!track->db_depth_size_idx) {\n\t\t\tdev_warn(p->dev, \"z/stencil buffer size not set\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = radeon_bo_size(track->db_bo) - track->db_offset;\n\t\ttmp = (tmp / bpe) >> 6;\n\t\tif (!tmp) {\n\t\t\tdev_warn(p->dev, \"z/stencil buffer too small (0x%08X %d %d %ld)\\n\",\n\t\t\t\t\ttrack->db_depth_size, bpe, track->db_offset,\n\t\t\t\t\tradeon_bo_size(track->db_bo));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[track->db_depth_size_idx] = S_028000_SLICE_TILE_MAX(tmp - 1) | (track->db_depth_size & 0x3FF);\n\t} else {\n\t\t \n\t\tpitch = (G_028000_PITCH_TILE_MAX(track->db_depth_size) + 1) * 8;\n\t\tslice_tile_max = G_028000_SLICE_TILE_MAX(track->db_depth_size) + 1;\n\t\tslice_tile_max *= 64;\n\t\theight = slice_tile_max / pitch;\n\t\tif (height > 8192)\n\t\t\theight = 8192;\n\t\tbase_offset = track->db_bo_mc + track->db_offset;\n\t\tarray_mode = G_028010_ARRAY_MODE(track->db_depth_info);\n\t\tarray_check.array_mode = array_mode;\n\t\tarray_check.group_size = track->group_size;\n\t\tarray_check.nbanks = track->nbanks;\n\t\tarray_check.npipes = track->npipes;\n\t\tarray_check.nsamples = track->nsamples;\n\t\tarray_check.blocksize = bpe;\n\t\tif (r600_get_array_mode_alignment(&array_check,\n\t\t\t\t\t&pitch_align, &height_align, &depth_align, &base_align)) {\n\t\t\tdev_warn(p->dev, \"%s invalid tiling %d (0x%08X)\\n\", __func__,\n\t\t\t\t\tG_028010_ARRAY_MODE(track->db_depth_info),\n\t\t\t\t\ttrack->db_depth_info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (array_mode) {\n\t\tcase V_028010_ARRAY_1D_TILED_THIN1:\n\t\t\t \n\t\t\theight &= ~0x7;\n\t\t\tbreak;\n\t\tcase V_028010_ARRAY_2D_TILED_THIN1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(p->dev, \"%s invalid tiling %d (0x%08X)\\n\", __func__,\n\t\t\t\t\tG_028010_ARRAY_MODE(track->db_depth_info),\n\t\t\t\t\ttrack->db_depth_info);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!IS_ALIGNED(pitch, pitch_align)) {\n\t\t\tdev_warn(p->dev, \"%s:%d db pitch (%d, 0x%x, %d) invalid\\n\",\n\t\t\t\t\t__func__, __LINE__, pitch, pitch_align, array_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!IS_ALIGNED(height, height_align)) {\n\t\t\tdev_warn(p->dev, \"%s:%d db height (%d, 0x%x, %d) invalid\\n\",\n\t\t\t\t\t__func__, __LINE__, height, height_align, array_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!IS_ALIGNED(base_offset, base_align)) {\n\t\t\tdev_warn(p->dev, \"%s offset 0x%llx, 0x%llx, %d not aligned\\n\", __func__,\n\t\t\t\t\tbase_offset, base_align, array_mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tntiles = G_028000_SLICE_TILE_MAX(track->db_depth_size) + 1;\n\t\tnviews = G_028004_SLICE_MAX(track->db_depth_view) + 1;\n\t\ttmp = ntiles * bpe * 64 * nviews * track->nsamples;\n\t\tif ((tmp + track->db_offset) > radeon_bo_size(track->db_bo)) {\n\t\t\tdev_warn(p->dev, \"z/stencil buffer (%d) too small (0x%08X %d %d %d -> %u have %lu)\\n\",\n\t\t\t\t\tarray_mode,\n\t\t\t\t\ttrack->db_depth_size, ntiles, nviews, bpe, tmp + track->db_offset,\n\t\t\t\t\tradeon_bo_size(track->db_bo));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (G_028010_TILE_SURFACE_ENABLE(track->db_depth_info)) {\n\t\tunsigned long size;\n\t\tunsigned nbx, nby;\n\n\t\tif (track->htile_bo == NULL) {\n\t\t\tdev_warn(p->dev, \"%s:%d htile enabled without htile surface 0x%08x\\n\",\n\t\t\t\t __func__, __LINE__, track->db_depth_info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((track->db_depth_size & 0xFFFFFC00) == 0xFFFFFC00) {\n\t\t\tdev_warn(p->dev, \"%s:%d htile can't be enabled with bogus db_depth_size 0x%08x\\n\",\n\t\t\t\t __func__, __LINE__, track->db_depth_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnbx = pitch;\n\t\tnby = height;\n\t\tif (G_028D24_LINEAR(track->htile_surface)) {\n\t\t\t \n\t\t\tnbx = round_up(nbx, 16 * 8);\n\t\t\t \n\t\t\tnby = round_up(nby, track->npipes * 8);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tswitch (track->npipes) {\n\t\t\tcase 8:\n\t\t\t\t \n\t\t\t\tnbx = round_up(nbx, 64 * 8);\n\t\t\t\tnby = round_up(nby, 64 * 8);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t \n\t\t\t\tnbx = round_up(nbx, 64 * 8);\n\t\t\t\tnby = round_up(nby, 32 * 8);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tnbx = round_up(nbx, 32 * 8);\n\t\t\t\tnby = round_up(nby, 32 * 8);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tnbx = round_up(nbx, 32 * 8);\n\t\t\t\tnby = round_up(nby, 16 * 8);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(p->dev, \"%s:%d invalid num pipes %d\\n\",\n\t\t\t\t\t __func__, __LINE__, track->npipes);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\t \n\t\tnbx = nbx >> 3;\n\t\tnby = nby >> 3;\n\t\t \n\t\tsize = roundup(nbx * nby * 4, track->npipes * (2 << 10));\n\t\tsize += track->htile_offset;\n\n\t\tif (size > radeon_bo_size(track->htile_bo)) {\n\t\t\tdev_warn(p->dev, \"%s:%d htile surface too small %ld for %ld (%d %d)\\n\",\n\t\t\t\t __func__, __LINE__, radeon_bo_size(track->htile_bo),\n\t\t\t\t size, nbx, nby);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttrack->db_dirty = false;\n\treturn 0;\n}\n\nstatic int r600_cs_track_check(struct radeon_cs_parser *p)\n{\n\tstruct r600_cs_track *track = p->track;\n\tu32 tmp;\n\tint r, i;\n\n\t \n\tif (p->rdev == NULL)\n\t\treturn 0;\n\n\t \n\tif (track->streamout_dirty && track->vgt_strmout_en) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (track->vgt_strmout_buffer_en & (1 << i)) {\n\t\t\t\tif (track->vgt_strmout_bo[i]) {\n\t\t\t\t\tu64 offset = (u64)track->vgt_strmout_bo_offset[i] +\n\t\t\t\t\t\t(u64)track->vgt_strmout_size[i];\n\t\t\t\t\tif (offset > radeon_bo_size(track->vgt_strmout_bo[i])) {\n\t\t\t\t\t\tDRM_ERROR(\"streamout %d bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t\t\t  i, offset,\n\t\t\t\t\t\t\t  radeon_bo_size(track->vgt_strmout_bo[i]));\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdev_warn(p->dev, \"No buffer for streamout %d\\n\", i);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrack->streamout_dirty = false;\n\t}\n\n\tif (track->sx_misc_kill_all_prims)\n\t\treturn 0;\n\n\t \n\tif (track->cb_dirty) {\n\t\ttmp = track->cb_target_mask;\n\n\t\t \n\t\tif (track->is_resolve) {\n\t\t\ttmp |= 0xff;\n\t\t}\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tu32 format = G_0280A0_FORMAT(track->cb_color_info[i]);\n\n\t\t\tif (format != V_0280A0_COLOR_INVALID &&\n\t\t\t    (tmp >> (i * 4)) & 0xF) {\n\t\t\t\t \n\t\t\t\tif (track->cb_color_bo[i] == NULL) {\n\t\t\t\t\tdev_warn(p->dev, \"%s:%d mask 0x%08X | 0x%08X no cb for %d\\n\",\n\t\t\t\t\t\t__func__, __LINE__, track->cb_target_mask, track->cb_shader_mask, i);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tr = r600_cs_track_validate_cb(p, i);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\ttrack->cb_dirty = false;\n\t}\n\n\t \n\tif (track->db_dirty &&\n\t    G_028010_FORMAT(track->db_depth_info) != V_028010_DEPTH_INVALID &&\n\t    (G_028800_STENCIL_ENABLE(track->db_depth_control) ||\n\t     G_028800_Z_ENABLE(track->db_depth_control))) {\n\t\tr = r600_cs_track_validate_db(p);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int r600_cs_packet_parse_vline(struct radeon_cs_parser *p)\n{\n\tstatic uint32_t vline_start_end[2] = {AVIVO_D1MODE_VLINE_START_END,\n\t\t\t\t\t      AVIVO_D2MODE_VLINE_START_END};\n\tstatic uint32_t vline_status[2] = {AVIVO_D1MODE_VLINE_STATUS,\n\t\t\t\t\t   AVIVO_D2MODE_VLINE_STATUS};\n\n\treturn r600_cs_common_vline_parse(p, vline_start_end, vline_status);\n}\n\n \nint r600_cs_common_vline_parse(struct radeon_cs_parser *p,\n\t\t\t       uint32_t *vline_start_end,\n\t\t\t       uint32_t *vline_status)\n{\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tstruct radeon_cs_packet p3reloc, wait_reg_mem;\n\tint crtc_id;\n\tint r;\n\tuint32_t header, h_idx, reg, wait_reg_mem_info;\n\tvolatile uint32_t *ib;\n\n\tib = p->ib.ptr;\n\n\t \n\tr = radeon_cs_packet_parse(p, &wait_reg_mem, p->idx);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (wait_reg_mem.type != RADEON_PACKET_TYPE3 ||\n\t    wait_reg_mem.opcode != PACKET3_WAIT_REG_MEM) {\n\t\tDRM_ERROR(\"vline wait missing WAIT_REG_MEM segment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twait_reg_mem_info = radeon_get_ib_value(p, wait_reg_mem.idx + 1);\n\t \n\tif (wait_reg_mem_info & 0x10) {\n\t\tDRM_ERROR(\"vline WAIT_REG_MEM waiting on MEM instead of REG\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (wait_reg_mem_info & 0x100) {\n\t\tDRM_ERROR(\"vline WAIT_REG_MEM waiting on PFP instead of ME\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif ((wait_reg_mem_info & 0x7) != 0x3) {\n\t\tDRM_ERROR(\"vline WAIT_REG_MEM function not equal\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif ((radeon_get_ib_value(p, wait_reg_mem.idx + 2) << 2) != vline_status[0]) {\n\t\tDRM_ERROR(\"vline WAIT_REG_MEM bad reg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (radeon_get_ib_value(p, wait_reg_mem.idx + 5) != RADEON_VLINE_STAT) {\n\t\tDRM_ERROR(\"vline WAIT_REG_MEM bad bit mask\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tr = radeon_cs_packet_parse(p, &p3reloc, p->idx + wait_reg_mem.count + 2);\n\tif (r)\n\t\treturn r;\n\n\th_idx = p->idx - 2;\n\tp->idx += wait_reg_mem.count + 2;\n\tp->idx += p3reloc.count + 2;\n\n\theader = radeon_get_ib_value(p, h_idx);\n\tcrtc_id = radeon_get_ib_value(p, h_idx + 2 + 7 + 1);\n\treg = R600_CP_PACKET0_GET_REG(header);\n\n\tcrtc = drm_crtc_find(p->rdev->ddev, p->filp, crtc_id);\n\tif (!crtc) {\n\t\tDRM_ERROR(\"cannot find crtc %d\\n\", crtc_id);\n\t\treturn -ENOENT;\n\t}\n\tradeon_crtc = to_radeon_crtc(crtc);\n\tcrtc_id = radeon_crtc->crtc_id;\n\n\tif (!crtc->enabled) {\n\t\t \n\t\tib[h_idx + 2] = PACKET2(0);\n\t\tib[h_idx + 3] = PACKET2(0);\n\t\tib[h_idx + 4] = PACKET2(0);\n\t\tib[h_idx + 5] = PACKET2(0);\n\t\tib[h_idx + 6] = PACKET2(0);\n\t\tib[h_idx + 7] = PACKET2(0);\n\t\tib[h_idx + 8] = PACKET2(0);\n\t} else if (reg == vline_start_end[0]) {\n\t\theader &= ~R600_CP_PACKET0_REG_MASK;\n\t\theader |= vline_start_end[crtc_id] >> 2;\n\t\tib[h_idx] = header;\n\t\tib[h_idx + 4] = vline_status[crtc_id] >> 2;\n\t} else {\n\t\tDRM_ERROR(\"unknown crtc reloc\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int r600_packet0_check(struct radeon_cs_parser *p,\n\t\t\t\tstruct radeon_cs_packet *pkt,\n\t\t\t\tunsigned idx, unsigned reg)\n{\n\tint r;\n\n\tswitch (reg) {\n\tcase AVIVO_D1MODE_VLINE_START_END:\n\t\tr = r600_cs_packet_parse_vline(p);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t\tidx, reg);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Forbidden register 0x%04X in cs at %d\\n\", reg, idx);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int r600_cs_parse_packet0(struct radeon_cs_parser *p,\n\t\t\t\tstruct radeon_cs_packet *pkt)\n{\n\tunsigned reg, i;\n\tunsigned idx;\n\tint r;\n\n\tidx = pkt->idx + 1;\n\treg = pkt->reg;\n\tfor (i = 0; i <= pkt->count; i++, idx++, reg += 4) {\n\t\tr = r600_packet0_check(p, pkt, idx, reg);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int r600_cs_check_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\n{\n\tstruct r600_cs_track *track = (struct r600_cs_track *)p->track;\n\tstruct radeon_bo_list *reloc;\n\tu32 m, i, tmp, *ib;\n\tint r;\n\n\ti = (reg >> 7);\n\tif (i >= ARRAY_SIZE(r600_reg_safe_bm)) {\n\t\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\", reg, idx);\n\t\treturn -EINVAL;\n\t}\n\tm = 1 << ((reg >> 2) & 31);\n\tif (!(r600_reg_safe_bm[i] & m))\n\t\treturn 0;\n\tib = p->ib.ptr;\n\tswitch (reg) {\n\t \n\tcase R_0288A8_SQ_ESGS_RING_ITEMSIZE:\n\tcase R_008C44_SQ_ESGS_RING_SIZE:\n\tcase R_0288B0_SQ_ESTMP_RING_ITEMSIZE:\n\tcase R_008C54_SQ_ESTMP_RING_SIZE:\n\tcase R_0288C0_SQ_FBUF_RING_ITEMSIZE:\n\tcase R_008C74_SQ_FBUF_RING_SIZE:\n\tcase R_0288B4_SQ_GSTMP_RING_ITEMSIZE:\n\tcase R_008C5C_SQ_GSTMP_RING_SIZE:\n\tcase R_0288AC_SQ_GSVS_RING_ITEMSIZE:\n\tcase R_008C4C_SQ_GSVS_RING_SIZE:\n\tcase R_0288BC_SQ_PSTMP_RING_ITEMSIZE:\n\tcase R_008C6C_SQ_PSTMP_RING_SIZE:\n\tcase R_0288C4_SQ_REDUC_RING_ITEMSIZE:\n\tcase R_008C7C_SQ_REDUC_RING_SIZE:\n\tcase R_0288B8_SQ_VSTMP_RING_ITEMSIZE:\n\tcase R_008C64_SQ_VSTMP_RING_SIZE:\n\tcase R_0288C8_SQ_GS_VERT_ITEMSIZE:\n\t\t \n\t\t \n\t\tbreak;\n\tcase SQ_ESGS_RING_BASE:\n\tcase SQ_GSVS_RING_BASE:\n\tcase SQ_ESTMP_RING_BASE:\n\tcase SQ_GSTMP_RING_BASE:\n\tcase SQ_PSTMP_RING_BASE:\n\tcase SQ_VSTMP_RING_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase SQ_CONFIG:\n\t\ttrack->sq_config = radeon_get_ib_value(p, idx);\n\t\tbreak;\n\tcase R_028800_DB_DEPTH_CONTROL:\n\t\ttrack->db_depth_control = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase R_028010_DB_DEPTH_INFO:\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS) &&\n\t\t    radeon_cs_packet_next_is_pkt3_nop(p)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t \"0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttrack->db_depth_info = radeon_get_ib_value(p, idx);\n\t\t\tib[idx] &= C_028010_ARRAY_MODE;\n\t\t\ttrack->db_depth_info &= C_028010_ARRAY_MODE;\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO) {\n\t\t\t\tib[idx] |= S_028010_ARRAY_MODE(V_028010_ARRAY_2D_TILED_THIN1);\n\t\t\t\ttrack->db_depth_info |= S_028010_ARRAY_MODE(V_028010_ARRAY_2D_TILED_THIN1);\n\t\t\t} else {\n\t\t\t\tib[idx] |= S_028010_ARRAY_MODE(V_028010_ARRAY_1D_TILED_THIN1);\n\t\t\t\ttrack->db_depth_info |= S_028010_ARRAY_MODE(V_028010_ARRAY_1D_TILED_THIN1);\n\t\t\t}\n\t\t} else {\n\t\t\ttrack->db_depth_info = radeon_get_ib_value(p, idx);\n\t\t}\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase R_028004_DB_DEPTH_VIEW:\n\t\ttrack->db_depth_view = radeon_get_ib_value(p, idx);\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase R_028000_DB_DEPTH_SIZE:\n\t\ttrack->db_depth_size = radeon_get_ib_value(p, idx);\n\t\ttrack->db_depth_size_idx = idx;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase R_028AB0_VGT_STRMOUT_EN:\n\t\ttrack->vgt_strmout_en = radeon_get_ib_value(p, idx);\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase R_028B20_VGT_STRMOUT_BUFFER_EN:\n\t\ttrack->vgt_strmout_buffer_en = radeon_get_ib_value(p, idx);\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase VGT_STRMOUT_BUFFER_BASE_0:\n\tcase VGT_STRMOUT_BUFFER_BASE_1:\n\tcase VGT_STRMOUT_BUFFER_BASE_2:\n\tcase VGT_STRMOUT_BUFFER_BASE_3:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = (reg - VGT_STRMOUT_BUFFER_BASE_0) / 16;\n\t\ttrack->vgt_strmout_bo_offset[tmp] = radeon_get_ib_value(p, idx) << 8;\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->vgt_strmout_bo[tmp] = reloc->robj;\n\t\ttrack->vgt_strmout_bo_mc[tmp] = reloc->gpu_offset;\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase VGT_STRMOUT_BUFFER_SIZE_0:\n\tcase VGT_STRMOUT_BUFFER_SIZE_1:\n\tcase VGT_STRMOUT_BUFFER_SIZE_2:\n\tcase VGT_STRMOUT_BUFFER_SIZE_3:\n\t\ttmp = (reg - VGT_STRMOUT_BUFFER_SIZE_0) / 16;\n\t\t \n\t\ttrack->vgt_strmout_size[tmp] = radeon_get_ib_value(p, idx) * 4;\n\t\ttrack->streamout_dirty = true;\n\t\tbreak;\n\tcase CP_COHER_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"missing reloc for CP_COHER_BASE \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase R_028238_CB_TARGET_MASK:\n\t\ttrack->cb_target_mask = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase R_02823C_CB_SHADER_MASK:\n\t\ttrack->cb_shader_mask = radeon_get_ib_value(p, idx);\n\t\tbreak;\n\tcase R_028C04_PA_SC_AA_CONFIG:\n\t\ttmp = G_028C04_MSAA_NUM_SAMPLES(radeon_get_ib_value(p, idx));\n\t\ttrack->log_nsamples = tmp;\n\t\ttrack->nsamples = 1 << tmp;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase R_028808_CB_COLOR_CONTROL:\n\t\ttmp = G_028808_SPECIAL_OP(radeon_get_ib_value(p, idx));\n\t\ttrack->is_resolve = tmp == V_028808_SPECIAL_RESOLVE_BOX;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase R_0280A0_CB_COLOR0_INFO:\n\tcase R_0280A4_CB_COLOR1_INFO:\n\tcase R_0280A8_CB_COLOR2_INFO:\n\tcase R_0280AC_CB_COLOR3_INFO:\n\tcase R_0280B0_CB_COLOR4_INFO:\n\tcase R_0280B4_CB_COLOR5_INFO:\n\tcase R_0280B8_CB_COLOR6_INFO:\n\tcase R_0280BC_CB_COLOR7_INFO:\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS) &&\n\t\t     radeon_cs_packet_next_is_pkt3_nop(p)) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tdev_err(p->dev, \"bad SET_CONTEXT_REG 0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttmp = (reg - R_0280A0_CB_COLOR0_INFO) / 4;\n\t\t\ttrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO) {\n\t\t\t\tib[idx] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_2D_TILED_THIN1);\n\t\t\t\ttrack->cb_color_info[tmp] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_2D_TILED_THIN1);\n\t\t\t} else if (reloc->tiling_flags & RADEON_TILING_MICRO) {\n\t\t\t\tib[idx] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_1D_TILED_THIN1);\n\t\t\t\ttrack->cb_color_info[tmp] |= S_0280A0_ARRAY_MODE(V_0280A0_ARRAY_1D_TILED_THIN1);\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = (reg - R_0280A0_CB_COLOR0_INFO) / 4;\n\t\t\ttrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\n\t\t}\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase R_028080_CB_COLOR0_VIEW:\n\tcase R_028084_CB_COLOR1_VIEW:\n\tcase R_028088_CB_COLOR2_VIEW:\n\tcase R_02808C_CB_COLOR3_VIEW:\n\tcase R_028090_CB_COLOR4_VIEW:\n\tcase R_028094_CB_COLOR5_VIEW:\n\tcase R_028098_CB_COLOR6_VIEW:\n\tcase R_02809C_CB_COLOR7_VIEW:\n\t\ttmp = (reg - R_028080_CB_COLOR0_VIEW) / 4;\n\t\ttrack->cb_color_view[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase R_028060_CB_COLOR0_SIZE:\n\tcase R_028064_CB_COLOR1_SIZE:\n\tcase R_028068_CB_COLOR2_SIZE:\n\tcase R_02806C_CB_COLOR3_SIZE:\n\tcase R_028070_CB_COLOR4_SIZE:\n\tcase R_028074_CB_COLOR5_SIZE:\n\tcase R_028078_CB_COLOR6_SIZE:\n\tcase R_02807C_CB_COLOR7_SIZE:\n\t\ttmp = (reg - R_028060_CB_COLOR0_SIZE) / 4;\n\t\ttrack->cb_color_size[tmp] = radeon_get_ib_value(p, idx);\n\t\ttrack->cb_color_size_idx[tmp] = idx;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\t\t \n\tcase R_0280E0_CB_COLOR0_FRAG:\n\tcase R_0280E4_CB_COLOR1_FRAG:\n\tcase R_0280E8_CB_COLOR2_FRAG:\n\tcase R_0280EC_CB_COLOR3_FRAG:\n\tcase R_0280F0_CB_COLOR4_FRAG:\n\tcase R_0280F4_CB_COLOR5_FRAG:\n\tcase R_0280F8_CB_COLOR6_FRAG:\n\tcase R_0280FC_CB_COLOR7_FRAG:\n\t\ttmp = (reg - R_0280E0_CB_COLOR0_FRAG) / 4;\n\t\tif (!radeon_cs_packet_next_is_pkt3_nop(p)) {\n\t\t\tif (!track->cb_color_base_last[tmp]) {\n\t\t\t\tdev_err(p->dev, \"Broken old userspace ? no cb_color0_base supplied before trying to write 0x%08X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttrack->cb_color_frag_bo[tmp] = track->cb_color_bo[tmp];\n\t\t\ttrack->cb_color_frag_offset[tmp] = track->cb_color_bo_offset[tmp];\n\t\t\tib[idx] = track->cb_color_base_last[tmp];\n\t\t} else {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tdev_err(p->dev, \"bad SET_CONTEXT_REG 0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttrack->cb_color_frag_bo[tmp] = reloc->robj;\n\t\t\ttrack->cb_color_frag_offset[tmp] = (u64)ib[idx] << 8;\n\t\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t}\n\t\tif (G_0280A0_TILE_MODE(track->cb_color_info[tmp])) {\n\t\t\ttrack->cb_dirty = true;\n\t\t}\n\t\tbreak;\n\tcase R_0280C0_CB_COLOR0_TILE:\n\tcase R_0280C4_CB_COLOR1_TILE:\n\tcase R_0280C8_CB_COLOR2_TILE:\n\tcase R_0280CC_CB_COLOR3_TILE:\n\tcase R_0280D0_CB_COLOR4_TILE:\n\tcase R_0280D4_CB_COLOR5_TILE:\n\tcase R_0280D8_CB_COLOR6_TILE:\n\tcase R_0280DC_CB_COLOR7_TILE:\n\t\ttmp = (reg - R_0280C0_CB_COLOR0_TILE) / 4;\n\t\tif (!radeon_cs_packet_next_is_pkt3_nop(p)) {\n\t\t\tif (!track->cb_color_base_last[tmp]) {\n\t\t\t\tdev_err(p->dev, \"Broken old userspace ? no cb_color0_base supplied before trying to write 0x%08X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttrack->cb_color_tile_bo[tmp] = track->cb_color_bo[tmp];\n\t\t\ttrack->cb_color_tile_offset[tmp] = track->cb_color_bo_offset[tmp];\n\t\t\tib[idx] = track->cb_color_base_last[tmp];\n\t\t} else {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tdev_err(p->dev, \"bad SET_CONTEXT_REG 0x%04X\\n\", reg);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttrack->cb_color_tile_bo[tmp] = reloc->robj;\n\t\t\ttrack->cb_color_tile_offset[tmp] = (u64)ib[idx] << 8;\n\t\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t}\n\t\tif (G_0280A0_TILE_MODE(track->cb_color_info[tmp])) {\n\t\t\ttrack->cb_dirty = true;\n\t\t}\n\t\tbreak;\n\tcase R_028100_CB_COLOR0_MASK:\n\tcase R_028104_CB_COLOR1_MASK:\n\tcase R_028108_CB_COLOR2_MASK:\n\tcase R_02810C_CB_COLOR3_MASK:\n\tcase R_028110_CB_COLOR4_MASK:\n\tcase R_028114_CB_COLOR5_MASK:\n\tcase R_028118_CB_COLOR6_MASK:\n\tcase R_02811C_CB_COLOR7_MASK:\n\t\ttmp = (reg - R_028100_CB_COLOR0_MASK) / 4;\n\t\ttrack->cb_color_mask[tmp] = radeon_get_ib_value(p, idx);\n\t\tif (G_0280A0_TILE_MODE(track->cb_color_info[tmp])) {\n\t\t\ttrack->cb_dirty = true;\n\t\t}\n\t\tbreak;\n\tcase CB_COLOR0_BASE:\n\tcase CB_COLOR1_BASE:\n\tcase CB_COLOR2_BASE:\n\tcase CB_COLOR3_BASE:\n\tcase CB_COLOR4_BASE:\n\tcase CB_COLOR5_BASE:\n\tcase CB_COLOR6_BASE:\n\tcase CB_COLOR7_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttmp = (reg - CB_COLOR0_BASE) / 4;\n\t\ttrack->cb_color_bo_offset[tmp] = (u64)radeon_get_ib_value(p, idx) << 8;\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->cb_color_base_last[tmp] = ib[idx];\n\t\ttrack->cb_color_bo[tmp] = reloc->robj;\n\t\ttrack->cb_color_bo_mc[tmp] = reloc->gpu_offset;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase DB_DEPTH_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->db_offset = radeon_get_ib_value(p, idx) << 8;\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->db_bo = reloc->robj;\n\t\ttrack->db_bo_mc = reloc->gpu_offset;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_HTILE_DATA_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->htile_offset = (u64)radeon_get_ib_value(p, idx) << 8;\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\ttrack->htile_bo = reloc->robj;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase DB_HTILE_SURFACE:\n\t\ttrack->htile_surface = radeon_get_ib_value(p, idx);\n\t\t \n\t\tib[idx] |= 3;\n\t\ttrack->db_dirty = true;\n\t\tbreak;\n\tcase SQ_PGM_START_FS:\n\tcase SQ_PGM_START_ES:\n\tcase SQ_PGM_START_VS:\n\tcase SQ_PGM_START_GS:\n\tcase SQ_PGM_START_PS:\n\tcase SQ_ALU_CONST_CACHE_GS_0:\n\tcase SQ_ALU_CONST_CACHE_GS_1:\n\tcase SQ_ALU_CONST_CACHE_GS_2:\n\tcase SQ_ALU_CONST_CACHE_GS_3:\n\tcase SQ_ALU_CONST_CACHE_GS_4:\n\tcase SQ_ALU_CONST_CACHE_GS_5:\n\tcase SQ_ALU_CONST_CACHE_GS_6:\n\tcase SQ_ALU_CONST_CACHE_GS_7:\n\tcase SQ_ALU_CONST_CACHE_GS_8:\n\tcase SQ_ALU_CONST_CACHE_GS_9:\n\tcase SQ_ALU_CONST_CACHE_GS_10:\n\tcase SQ_ALU_CONST_CACHE_GS_11:\n\tcase SQ_ALU_CONST_CACHE_GS_12:\n\tcase SQ_ALU_CONST_CACHE_GS_13:\n\tcase SQ_ALU_CONST_CACHE_GS_14:\n\tcase SQ_ALU_CONST_CACHE_GS_15:\n\tcase SQ_ALU_CONST_CACHE_PS_0:\n\tcase SQ_ALU_CONST_CACHE_PS_1:\n\tcase SQ_ALU_CONST_CACHE_PS_2:\n\tcase SQ_ALU_CONST_CACHE_PS_3:\n\tcase SQ_ALU_CONST_CACHE_PS_4:\n\tcase SQ_ALU_CONST_CACHE_PS_5:\n\tcase SQ_ALU_CONST_CACHE_PS_6:\n\tcase SQ_ALU_CONST_CACHE_PS_7:\n\tcase SQ_ALU_CONST_CACHE_PS_8:\n\tcase SQ_ALU_CONST_CACHE_PS_9:\n\tcase SQ_ALU_CONST_CACHE_PS_10:\n\tcase SQ_ALU_CONST_CACHE_PS_11:\n\tcase SQ_ALU_CONST_CACHE_PS_12:\n\tcase SQ_ALU_CONST_CACHE_PS_13:\n\tcase SQ_ALU_CONST_CACHE_PS_14:\n\tcase SQ_ALU_CONST_CACHE_PS_15:\n\tcase SQ_ALU_CONST_CACHE_VS_0:\n\tcase SQ_ALU_CONST_CACHE_VS_1:\n\tcase SQ_ALU_CONST_CACHE_VS_2:\n\tcase SQ_ALU_CONST_CACHE_VS_3:\n\tcase SQ_ALU_CONST_CACHE_VS_4:\n\tcase SQ_ALU_CONST_CACHE_VS_5:\n\tcase SQ_ALU_CONST_CACHE_VS_6:\n\tcase SQ_ALU_CONST_CACHE_VS_7:\n\tcase SQ_ALU_CONST_CACHE_VS_8:\n\tcase SQ_ALU_CONST_CACHE_VS_9:\n\tcase SQ_ALU_CONST_CACHE_VS_10:\n\tcase SQ_ALU_CONST_CACHE_VS_11:\n\tcase SQ_ALU_CONST_CACHE_VS_12:\n\tcase SQ_ALU_CONST_CACHE_VS_13:\n\tcase SQ_ALU_CONST_CACHE_VS_14:\n\tcase SQ_ALU_CONST_CACHE_VS_15:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONTEXT_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase SX_MEMORY_EXPORT_BASE:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"bad SET_CONFIG_REG \"\n\t\t\t\t\t\"0x%04X\\n\", reg);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\tbreak;\n\tcase SX_MISC:\n\t\ttrack->sx_misc_kill_all_prims = (radeon_get_ib_value(p, idx) & 0x1) != 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\", reg, idx);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nunsigned r600_mip_minify(unsigned size, unsigned level)\n{\n\tunsigned val;\n\n\tval = max(1U, size >> level);\n\tif (level > 0)\n\t\tval = roundup_pow_of_two(val);\n\treturn val;\n}\n\nstatic void r600_texture_size(unsigned nfaces, unsigned blevel, unsigned llevel,\n\t\t\t      unsigned w0, unsigned h0, unsigned d0, unsigned nsamples, unsigned format,\n\t\t\t      unsigned block_align, unsigned height_align, unsigned base_align,\n\t\t\t      unsigned *l0_size, unsigned *mipmap_size)\n{\n\tunsigned offset, i, level;\n\tunsigned width, height, depth, size;\n\tunsigned blocksize;\n\tunsigned nbx, nby;\n\tunsigned nlevels = llevel - blevel + 1;\n\n\t*l0_size = -1;\n\tblocksize = r600_fmt_get_blocksize(format);\n\n\tw0 = r600_mip_minify(w0, 0);\n\th0 = r600_mip_minify(h0, 0);\n\td0 = r600_mip_minify(d0, 0);\n\tfor(i = 0, offset = 0, level = blevel; i < nlevels; i++, level++) {\n\t\twidth = r600_mip_minify(w0, i);\n\t\tnbx = r600_fmt_get_nblocksx(format, width);\n\n\t\tnbx = round_up(nbx, block_align);\n\n\t\theight = r600_mip_minify(h0, i);\n\t\tnby = r600_fmt_get_nblocksy(format, height);\n\t\tnby = round_up(nby, height_align);\n\n\t\tdepth = r600_mip_minify(d0, i);\n\n\t\tsize = nbx * nby * blocksize * nsamples;\n\t\tif (nfaces)\n\t\t\tsize *= nfaces;\n\t\telse\n\t\t\tsize *= depth;\n\n\t\tif (i == 0)\n\t\t\t*l0_size = size;\n\n\t\tif (i == 0 || i == 1)\n\t\t\toffset = round_up(offset, base_align);\n\n\t\toffset += size;\n\t}\n\t*mipmap_size = offset;\n\tif (llevel == 0)\n\t\t*mipmap_size = *l0_size;\n\tif (!blevel)\n\t\t*mipmap_size -= *l0_size;\n}\n\n \nstatic int r600_check_texture_resource(struct radeon_cs_parser *p,  u32 idx,\n\t\t\t\t\t      struct radeon_bo *texture,\n\t\t\t\t\t      struct radeon_bo *mipmap,\n\t\t\t\t\t      u64 base_offset,\n\t\t\t\t\t      u64 mip_offset,\n\t\t\t\t\t      u32 tiling_flags)\n{\n\tstruct r600_cs_track *track = p->track;\n\tu32 dim, nfaces, llevel, blevel, w0, h0, d0;\n\tu32 word0, word1, l0_size, mipmap_size, word2, word3, word4, word5;\n\tu32 height_align, pitch, pitch_align, depth_align;\n\tu32 barray, larray;\n\tu64 base_align;\n\tstruct array_mode_checker array_check;\n\tu32 format;\n\tbool is_array;\n\n\t \n\tif (p->rdev == NULL)\n\t\treturn 0;\n\n\t \n\tbase_offset <<= 8;\n\tmip_offset <<= 8;\n\n\tword0 = radeon_get_ib_value(p, idx + 0);\n\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\tif (tiling_flags & RADEON_TILING_MACRO)\n\t\t\tword0 |= S_038000_TILE_MODE(V_038000_ARRAY_2D_TILED_THIN1);\n\t\telse if (tiling_flags & RADEON_TILING_MICRO)\n\t\t\tword0 |= S_038000_TILE_MODE(V_038000_ARRAY_1D_TILED_THIN1);\n\t}\n\tword1 = radeon_get_ib_value(p, idx + 1);\n\tword2 = radeon_get_ib_value(p, idx + 2) << 8;\n\tword3 = radeon_get_ib_value(p, idx + 3) << 8;\n\tword4 = radeon_get_ib_value(p, idx + 4);\n\tword5 = radeon_get_ib_value(p, idx + 5);\n\tdim = G_038000_DIM(word0);\n\tw0 = G_038000_TEX_WIDTH(word0) + 1;\n\tpitch = (G_038000_PITCH(word0) + 1) * 8;\n\th0 = G_038004_TEX_HEIGHT(word1) + 1;\n\td0 = G_038004_TEX_DEPTH(word1);\n\tformat = G_038004_DATA_FORMAT(word1);\n\tblevel = G_038010_BASE_LEVEL(word4);\n\tllevel = G_038014_LAST_LEVEL(word5);\n\t \n\tarray_check.array_mode = G_038000_TILE_MODE(word0);\n\tarray_check.group_size = track->group_size;\n\tarray_check.nbanks = track->nbanks;\n\tarray_check.npipes = track->npipes;\n\tarray_check.nsamples = 1;\n\tarray_check.blocksize = r600_fmt_get_blocksize(format);\n\tnfaces = 1;\n\tis_array = false;\n\tswitch (dim) {\n\tcase V_038000_SQ_TEX_DIM_1D:\n\tcase V_038000_SQ_TEX_DIM_2D:\n\tcase V_038000_SQ_TEX_DIM_3D:\n\t\tbreak;\n\tcase V_038000_SQ_TEX_DIM_CUBEMAP:\n\t\tif (p->family >= CHIP_RV770)\n\t\t\tnfaces = 8;\n\t\telse\n\t\t\tnfaces = 6;\n\t\tbreak;\n\tcase V_038000_SQ_TEX_DIM_1D_ARRAY:\n\tcase V_038000_SQ_TEX_DIM_2D_ARRAY:\n\t\tis_array = true;\n\t\tbreak;\n\tcase V_038000_SQ_TEX_DIM_2D_ARRAY_MSAA:\n\t\tis_array = true;\n\t\tfallthrough;\n\tcase V_038000_SQ_TEX_DIM_2D_MSAA:\n\t\tarray_check.nsamples = 1 << llevel;\n\t\tllevel = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(p->dev, \"this kernel doesn't support %d texture dim\\n\", G_038000_DIM(word0));\n\t\treturn -EINVAL;\n\t}\n\tif (!r600_fmt_is_valid_texture(format, p->family)) {\n\t\tdev_warn(p->dev, \"%s:%d texture invalid format %d\\n\",\n\t\t\t __func__, __LINE__, format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (r600_get_array_mode_alignment(&array_check,\n\t\t\t\t\t  &pitch_align, &height_align, &depth_align, &base_align)) {\n\t\tdev_warn(p->dev, \"%s:%d tex array mode (%d) invalid\\n\",\n\t\t\t __func__, __LINE__, G_038000_TILE_MODE(word0));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tif (!IS_ALIGNED(pitch, pitch_align)) {\n\t\tdev_warn(p->dev, \"%s:%d tex pitch (%d, 0x%x, %d) invalid\\n\",\n\t\t\t __func__, __LINE__, pitch, pitch_align, G_038000_TILE_MODE(word0));\n\t\treturn -EINVAL;\n\t}\n\tif (!IS_ALIGNED(base_offset, base_align)) {\n\t\tdev_warn(p->dev, \"%s:%d tex base offset (0x%llx, 0x%llx, %d) invalid\\n\",\n\t\t\t __func__, __LINE__, base_offset, base_align, G_038000_TILE_MODE(word0));\n\t\treturn -EINVAL;\n\t}\n\tif (!IS_ALIGNED(mip_offset, base_align)) {\n\t\tdev_warn(p->dev, \"%s:%d tex mip offset (0x%llx, 0x%llx, %d) invalid\\n\",\n\t\t\t __func__, __LINE__, mip_offset, base_align, G_038000_TILE_MODE(word0));\n\t\treturn -EINVAL;\n\t}\n\n\tif (blevel > llevel) {\n\t\tdev_warn(p->dev, \"texture blevel %d > llevel %d\\n\",\n\t\t\t blevel, llevel);\n\t}\n\tif (is_array) {\n\t\tbarray = G_038014_BASE_ARRAY(word5);\n\t\tlarray = G_038014_LAST_ARRAY(word5);\n\n\t\tnfaces = larray - barray + 1;\n\t}\n\tr600_texture_size(nfaces, blevel, llevel, w0, h0, d0, array_check.nsamples, format,\n\t\t\t  pitch_align, height_align, base_align,\n\t\t\t  &l0_size, &mipmap_size);\n\t \n\tif ((l0_size + word2) > radeon_bo_size(texture)) {\n\t\tdev_warn(p->dev, \"texture bo too small ((%d %d) (%d %d) %d %d %d -> %d have %ld)\\n\",\n\t\t\t w0, h0, pitch_align, height_align,\n\t\t\t array_check.array_mode, format, word2,\n\t\t\t l0_size, radeon_bo_size(texture));\n\t\tdev_warn(p->dev, \"alignments %d %d %d %lld\\n\", pitch, pitch_align, height_align, base_align);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif ((mipmap_size + word3) > radeon_bo_size(mipmap)) {\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic bool r600_is_safe_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\n{\n\tu32 m, i;\n\n\ti = (reg >> 7);\n\tif (i >= ARRAY_SIZE(r600_reg_safe_bm)) {\n\t\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\", reg, idx);\n\t\treturn false;\n\t}\n\tm = 1 << ((reg >> 2) & 31);\n\tif (!(r600_reg_safe_bm[i] & m))\n\t\treturn true;\n\tdev_warn(p->dev, \"forbidden register 0x%08x at %d\\n\", reg, idx);\n\treturn false;\n}\n\nstatic int r600_packet3_check(struct radeon_cs_parser *p,\n\t\t\t\tstruct radeon_cs_packet *pkt)\n{\n\tstruct radeon_bo_list *reloc;\n\tstruct r600_cs_track *track;\n\tvolatile u32 *ib;\n\tunsigned idx;\n\tunsigned i;\n\tunsigned start_reg, end_reg, reg;\n\tint r;\n\tu32 idx_value;\n\n\ttrack = (struct r600_cs_track *)p->track;\n\tib = p->ib.ptr;\n\tidx = pkt->idx + 1;\n\tidx_value = radeon_get_ib_value(p, idx);\n\n\tswitch (pkt->opcode) {\n\tcase PACKET3_SET_PREDICATION:\n\t{\n\t\tint pred_op;\n\t\tint tmp;\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad SET PREDICATION\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttmp = radeon_get_ib_value(p, idx + 1);\n\t\tpred_op = (tmp >> 16) & 0x7;\n\n\t\t \n\t\tif (pred_op == 0)\n\t\t\treturn 0;\n\n\t\tif (pred_op > 2) {\n\t\t\tDRM_ERROR(\"bad SET PREDICATION operation %d\\n\", pred_op);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad SET PREDICATION\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t (idx_value & 0xfffffff0) +\n\t\t\t ((u64)(tmp & 0xff) << 32);\n\n\t\tib[idx + 0] = offset;\n\t\tib[idx + 1] = (tmp & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t}\n\tbreak;\n\n\tcase PACKET3_START_3D_CMDBUF:\n\t\tif (p->family >= CHIP_RV770 || pkt->count) {\n\t\t\tDRM_ERROR(\"bad START_3D\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CONTEXT_CONTROL:\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad CONTEXT_CONTROL\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_INDEX_TYPE:\n\tcase PACKET3_NUM_INSTANCES:\n\t\tif (pkt->count) {\n\t\t\tDRM_ERROR(\"bad INDEX_TYPE/NUM_INSTANCES\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DRAW_INDEX:\n\t{\n\t\tuint64_t offset;\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t idx_value +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\n\n\t\tib[idx+0] = offset;\n\t\tib[idx+1] = upper_32_bits(offset) & 0xff;\n\n\t\tr = r600_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_DRAW_INDEX_AUTO:\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_AUTO\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = r600_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream %d\\n\", __func__, __LINE__, idx);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_DRAW_INDEX_IMMD_BE:\n\tcase PACKET3_DRAW_INDEX_IMMD:\n\t\tif (pkt->count < 2) {\n\t\t\tDRM_ERROR(\"bad DRAW_INDEX_IMMD\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = r600_cs_track_check(p);\n\t\tif (r) {\n\t\t\tdev_warn(p->dev, \"%s:%d invalid cmd stream\\n\", __func__, __LINE__);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_WAIT_REG_MEM:\n\t\tif (pkt->count != 5) {\n\t\t\tDRM_ERROR(\"bad WAIT_REG_MEM\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (idx_value & 0x10) {\n\t\t\tuint64_t offset;\n\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad WAIT_REG_MEM\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\toffset = reloc->gpu_offset +\n\t\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffff0) +\n\t\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\t\tib[idx+1] = (ib[idx+1] & 0x3) | (offset & 0xfffffff0);\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t} else if (idx_value & 0x100) {\n\t\t\tDRM_ERROR(\"cannot use PFP on REG wait\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CP_DMA:\n\t{\n\t\tu32 command, size;\n\t\tu64 offset, tmp;\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad CP DMA\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcommand = radeon_get_ib_value(p, idx+4);\n\t\tsize = command & 0x1fffff;\n\t\tif (command & PACKET3_CP_DMA_CMD_SAS) {\n\t\t\t \n\t\t\tDRM_ERROR(\"CP DMA SAS not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (command & PACKET3_CP_DMA_CMD_SAIC) {\n\t\t\t\tDRM_ERROR(\"CP DMA SAIC only supported for registers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t \n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad CP DMA SRC\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\ttmp = radeon_get_ib_value(p, idx) +\n\t\t\t\t((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\n\n\t\t\toffset = reloc->gpu_offset + tmp;\n\n\t\t\tif ((tmp + size) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"CP DMA src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t tmp + size, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tib[idx] = offset;\n\t\t\tib[idx+1] = (ib[idx+1] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t\t}\n\t\tif (command & PACKET3_CP_DMA_CMD_DAS) {\n\t\t\t \n\t\t\tDRM_ERROR(\"CP DMA DAS not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\tif (command & PACKET3_CP_DMA_CMD_DAIC) {\n\t\t\t\tDRM_ERROR(\"CP DMA DAIC only supported for registers\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad CP DMA DST\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\ttmp = radeon_get_ib_value(p, idx+2) +\n\t\t\t\t((u64)(radeon_get_ib_value(p, idx+3) & 0xff) << 32);\n\n\t\t\toffset = reloc->gpu_offset + tmp;\n\n\t\t\tif ((tmp + size) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"CP DMA dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t tmp + size, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tib[idx+2] = offset;\n\t\t\tib[idx+3] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\tbreak;\n\t}\n\tcase PACKET3_SURFACE_SYNC:\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad SURFACE_SYNC\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (radeon_get_ib_value(p, idx + 1) != 0xffffffff ||\n\t\t    radeon_get_ib_value(p, idx + 2) != 0) {\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad SURFACE_SYNC\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx+2] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t}\n\t\tbreak;\n\tcase PACKET3_EVENT_WRITE:\n\t\tif (pkt->count != 2 && pkt->count != 0) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt->count) {\n\t\t\tuint64_t offset;\n\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad EVENT_WRITE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = reloc->gpu_offset +\n\t\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffff8) +\n\t\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\t\tib[idx+1] = offset & 0xfffffff8;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_EVENT_WRITE_EOP:\n\t{\n\t\tuint64_t offset;\n\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE_EOP\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad EVENT_WRITE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\toffset = reloc->gpu_offset +\n\t\t\t (radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\n\t\t\t ((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\n\n\t\tib[idx+1] = offset & 0xfffffffc;\n\t\tib[idx+2] = (ib[idx+2] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\n\t\tbreak;\n\t}\n\tcase PACKET3_SET_CONFIG_REG:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CONFIG_REG_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_CONFIG_REG_END) ||\n\t\t    (end_reg >= PACKET3_SET_CONFIG_REG_END)) {\n\t\t\tDRM_ERROR(\"bad PACKET3_SET_CONFIG_REG\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < pkt->count; i++) {\n\t\t\treg = start_reg + (4 * i);\n\t\t\tr = r600_cs_check_reg(p, reg, idx+1+i);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_CONTEXT_REG:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CONTEXT_REG_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CONTEXT_REG_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_CONTEXT_REG_END) ||\n\t\t    (end_reg >= PACKET3_SET_CONTEXT_REG_END)) {\n\t\t\tDRM_ERROR(\"bad PACKET3_SET_CONTEXT_REG\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < pkt->count; i++) {\n\t\t\treg = start_reg + (4 * i);\n\t\t\tr = r600_cs_check_reg(p, reg, idx+1+i);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_RESOURCE:\n\t\tif (pkt->count % 7) {\n\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_RESOURCE_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_RESOURCE_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_RESOURCE_END) ||\n\t\t    (end_reg >= PACKET3_SET_RESOURCE_END)) {\n\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < (pkt->count / 7); i++) {\n\t\t\tstruct radeon_bo *texture, *mipmap;\n\t\t\tu32 size, offset, base_offset, mip_offset;\n\n\t\t\tswitch (G__SQ_VTX_CONSTANT_TYPE(radeon_get_ib_value(p, idx+(i*7)+6+1))) {\n\t\t\tcase SQ_TEX_VTX_VALID_TEXTURE:\n\t\t\t\t \n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbase_offset = (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\t\t\t\tib[idx+1+(i*7)+0] |= S_038000_TILE_MODE(V_038000_ARRAY_2D_TILED_THIN1);\n\t\t\t\t\telse if (reloc->tiling_flags & RADEON_TILING_MICRO)\n\t\t\t\t\t\tib[idx+1+(i*7)+0] |= S_038000_TILE_MODE(V_038000_ARRAY_1D_TILED_THIN1);\n\t\t\t\t}\n\t\t\t\ttexture = reloc->robj;\n\t\t\t\t \n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tmip_offset = (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t\t\tmipmap = reloc->robj;\n\t\t\t\tr = r600_check_texture_resource(p,  idx+(i*7)+1,\n\t\t\t\t\t\t\t\ttexture, mipmap,\n\t\t\t\t\t\t\t\tbase_offset + radeon_get_ib_value(p, idx+1+(i*7)+2),\n\t\t\t\t\t\t\t\tmip_offset + radeon_get_ib_value(p, idx+1+(i*7)+3),\n\t\t\t\t\t\t\t\treloc->tiling_flags);\n\t\t\t\tif (r)\n\t\t\t\t\treturn r;\n\t\t\t\tib[idx+1+(i*7)+2] += base_offset;\n\t\t\t\tib[idx+1+(i*7)+3] += mip_offset;\n\t\t\t\tbreak;\n\t\t\tcase SQ_TEX_VTX_VALID_BUFFER:\n\t\t\t{\n\t\t\t\tuint64_t offset64;\n\t\t\t\t \n\t\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\t\tif (r) {\n\t\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\toffset = radeon_get_ib_value(p, idx+1+(i*7)+0);\n\t\t\t\tsize = radeon_get_ib_value(p, idx+1+(i*7)+1) + 1;\n\t\t\t\tif (p->rdev && (size + offset) > radeon_bo_size(reloc->robj)) {\n\t\t\t\t\t \n\t\t\t\t\tdev_warn(p->dev, \"vbo resource seems too big (%d) for the bo (%ld)\\n\",\n\t\t\t\t\t\t size + offset, radeon_bo_size(reloc->robj));\n\t\t\t\t\tib[idx+1+(i*7)+1] = radeon_bo_size(reloc->robj) - offset;\n\t\t\t\t}\n\n\t\t\t\toffset64 = reloc->gpu_offset + offset;\n\t\t\t\tib[idx+1+(i*8)+0] = offset64;\n\t\t\t\tib[idx+1+(i*8)+2] = (ib[idx+1+(i*8)+2] & 0xffffff00) |\n\t\t\t\t\t\t    (upper_32_bits(offset64) & 0xff);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase SQ_TEX_VTX_INVALID_TEXTURE:\n\t\t\tcase SQ_TEX_VTX_INVALID_BUFFER:\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"bad SET_RESOURCE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_ALU_CONST:\n\t\tif (track->sq_config & DX9_CONSTS) {\n\t\t\tstart_reg = (idx_value << 2) + PACKET3_SET_ALU_CONST_OFFSET;\n\t\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\t\tif ((start_reg < PACKET3_SET_ALU_CONST_OFFSET) ||\n\t\t\t    (start_reg >= PACKET3_SET_ALU_CONST_END) ||\n\t\t\t    (end_reg >= PACKET3_SET_ALU_CONST_END)) {\n\t\t\t\tDRM_ERROR(\"bad SET_ALU_CONST\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_BOOL_CONST:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_BOOL_CONST_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_BOOL_CONST_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_BOOL_CONST_END) ||\n\t\t    (end_reg >= PACKET3_SET_BOOL_CONST_END)) {\n\t\t\tDRM_ERROR(\"bad SET_BOOL_CONST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_LOOP_CONST:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_LOOP_CONST_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_LOOP_CONST_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_LOOP_CONST_END) ||\n\t\t    (end_reg >= PACKET3_SET_LOOP_CONST_END)) {\n\t\t\tDRM_ERROR(\"bad SET_LOOP_CONST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_CTL_CONST:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CTL_CONST_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CTL_CONST_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_CTL_CONST_END) ||\n\t\t    (end_reg >= PACKET3_SET_CTL_CONST_END)) {\n\t\t\tDRM_ERROR(\"bad SET_CTL_CONST\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_SAMPLER:\n\t\tif (pkt->count % 3) {\n\t\t\tDRM_ERROR(\"bad SET_SAMPLER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_SAMPLER_OFFSET;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_SAMPLER_OFFSET) ||\n\t\t    (start_reg >= PACKET3_SET_SAMPLER_END) ||\n\t\t    (end_reg >= PACKET3_SET_SAMPLER_END)) {\n\t\t\tDRM_ERROR(\"bad SET_SAMPLER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_STRMOUT_BASE_UPDATE:\n\t\t \n\t\tif (p->family < CHIP_RS780) {\n\t\t\tDRM_ERROR(\"STRMOUT_BASE_UPDATE only supported on 7xx\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt->count != 1) {\n\t\t\tDRM_ERROR(\"bad STRMOUT_BASE_UPDATE packet count\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (idx_value > 3) {\n\t\t\tDRM_ERROR(\"bad STRMOUT_BASE_UPDATE index\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t{\n\t\t\tu64 offset;\n\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BASE_UPDATE reloc\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (reloc->robj != track->vgt_strmout_bo[idx_value]) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BASE_UPDATE, bo does not match\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\toffset = radeon_get_ib_value(p, idx+1) << 8;\n\t\t\tif (offset != track->vgt_strmout_bo_offset[idx_value]) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BASE_UPDATE, bo offset does not match: 0x%llx, 0x%x\\n\",\n\t\t\t\t\t  offset, track->vgt_strmout_bo_offset[idx_value]);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BASE_UPDATE bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx+1] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SURFACE_BASE_UPDATE:\n\t\tif (p->family >= CHIP_RV770 || p->family == CHIP_R600) {\n\t\t\tDRM_ERROR(\"bad SURFACE_BASE_UPDATE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pkt->count) {\n\t\t\tDRM_ERROR(\"bad SURFACE_BASE_UPDATE\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_STRMOUT_BUFFER_UPDATE:\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tif (idx_value & 0x1) {\n\t\t\tu64 offset;\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE (missing dst reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+1);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE dst bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+1] = offset;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\t \n\t\tif (((idx_value >> 1) & 0x3) == 2) {\n\t\t\tu64 offset;\n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE (missing src reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+3);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad STRMOUT_BUFFER_UPDATE src bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+3] = offset;\n\t\t\tib[idx+4] = upper_32_bits(offset) & 0xff;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_MEM_WRITE:\n\t{\n\t\tu64 offset;\n\n\t\tif (pkt->count != 3) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE (missing reloc)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset = radeon_get_ib_value(p, idx+0);\n\t\toffset += ((u64)(radeon_get_ib_value(p, idx+1) & 0xff)) << 32UL;\n\t\tif (offset & 0x7) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE (address not qwords aligned)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((offset + 8) > radeon_bo_size(reloc->robj)) {\n\t\t\tDRM_ERROR(\"bad MEM_WRITE bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t  offset + 8, radeon_bo_size(reloc->robj));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset += reloc->gpu_offset;\n\t\tib[idx+0] = offset;\n\t\tib[idx+1] = upper_32_bits(offset) & 0xff;\n\t\tbreak;\n\t}\n\tcase PACKET3_COPY_DW:\n\t\tif (pkt->count != 4) {\n\t\t\tDRM_ERROR(\"bad COPY_DW (invalid count)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (idx_value & 0x1) {\n\t\t\tu64 offset;\n\t\t\t \n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW (missing src reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+1);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW src bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+1] = offset;\n\t\t\tib[idx+2] = upper_32_bits(offset) & 0xff;\n\t\t} else {\n\t\t\t \n\t\t\treg = radeon_get_ib_value(p, idx+1) << 2;\n\t\t\tif (!r600_is_safe_reg(p, reg, idx+1))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (idx_value & 0x2) {\n\t\t\tu64 offset;\n\t\t\t \n\t\t\tr = radeon_cs_packet_next_reloc(p, &reloc, r600_nomm);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW (missing dst reloc)\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset = radeon_get_ib_value(p, idx+3);\n\t\t\toffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\tif ((offset + 4) > radeon_bo_size(reloc->robj)) {\n\t\t\t\tDRM_ERROR(\"bad COPY_DW dst bo too small: 0x%llx, 0x%lx\\n\",\n\t\t\t\t\t  offset + 4, radeon_bo_size(reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\toffset += reloc->gpu_offset;\n\t\t\tib[idx+3] = offset;\n\t\t\tib[idx+4] = upper_32_bits(offset) & 0xff;\n\t\t} else {\n\t\t\t \n\t\t\treg = radeon_get_ib_value(p, idx+3) << 2;\n\t\t\tif (!r600_is_safe_reg(p, reg, idx+3))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_NOP:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Packet3 opcode %x not supported\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint r600_cs_parse(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_packet pkt;\n\tstruct r600_cs_track *track;\n\tint r;\n\n\tif (p->track == NULL) {\n\t\t \n\t\ttrack = kzalloc(sizeof(*track), GFP_KERNEL);\n\t\tif (track == NULL)\n\t\t\treturn -ENOMEM;\n\t\tr600_cs_track_init(track);\n\t\tif (p->rdev->family < CHIP_RV770) {\n\t\t\ttrack->npipes = p->rdev->config.r600.tiling_npipes;\n\t\t\ttrack->nbanks = p->rdev->config.r600.tiling_nbanks;\n\t\t\ttrack->group_size = p->rdev->config.r600.tiling_group_size;\n\t\t} else if (p->rdev->family <= CHIP_RV740) {\n\t\t\ttrack->npipes = p->rdev->config.rv770.tiling_npipes;\n\t\t\ttrack->nbanks = p->rdev->config.rv770.tiling_nbanks;\n\t\t\ttrack->group_size = p->rdev->config.rv770.tiling_group_size;\n\t\t}\n\t\tp->track = track;\n\t}\n\tdo {\n\t\tr = radeon_cs_packet_parse(p, &pkt, p->idx);\n\t\tif (r) {\n\t\t\tkfree(p->track);\n\t\t\tp->track = NULL;\n\t\t\treturn r;\n\t\t}\n\t\tp->idx += pkt.count + 2;\n\t\tswitch (pkt.type) {\n\t\tcase RADEON_PACKET_TYPE0:\n\t\t\tr = r600_cs_parse_packet0(p, &pkt);\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE2:\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE3:\n\t\t\tr = r600_packet3_check(p, &pkt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d !\\n\", pkt.type);\n\t\t\tkfree(p->track);\n\t\t\tp->track = NULL;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (r) {\n\t\t\tkfree(p->track);\n\t\t\tp->track = NULL;\n\t\t\treturn r;\n\t\t}\n\t} while (p->idx < p->chunk_ib->length_dw);\n#if 0\n\tfor (r = 0; r < p->ib.length_dw; r++) {\n\t\tpr_info(\"%05d  0x%08X\\n\", r, p->ib.ptr[r]);\n\t\tmdelay(1);\n\t}\n#endif\n\tkfree(p->track);\n\tp->track = NULL;\n\treturn 0;\n}\n\n \n \nint r600_dma_cs_next_reloc(struct radeon_cs_parser *p,\n\t\t\t   struct radeon_bo_list **cs_reloc)\n{\n\tunsigned idx;\n\n\t*cs_reloc = NULL;\n\tif (p->chunk_relocs == NULL) {\n\t\tDRM_ERROR(\"No relocation chunk !\\n\");\n\t\treturn -EINVAL;\n\t}\n\tidx = p->dma_reloc_idx;\n\tif (idx >= p->nrelocs) {\n\t\tDRM_ERROR(\"Relocs at %d after relocations chunk end %d !\\n\",\n\t\t\t  idx, p->nrelocs);\n\t\treturn -EINVAL;\n\t}\n\t*cs_reloc = &p->relocs[idx];\n\tp->dma_reloc_idx++;\n\treturn 0;\n}\n\n#define GET_DMA_CMD(h) (((h) & 0xf0000000) >> 28)\n#define GET_DMA_COUNT(h) ((h) & 0x0000ffff)\n#define GET_DMA_T(h) (((h) & 0x00800000) >> 23)\n\n \nint r600_dma_cs_parse(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_chunk *ib_chunk = p->chunk_ib;\n\tstruct radeon_bo_list *src_reloc, *dst_reloc;\n\tu32 header, cmd, count, tiled;\n\tvolatile u32 *ib = p->ib.ptr;\n\tu32 idx, idx_value;\n\tu64 src_offset, dst_offset;\n\tint r;\n\n\tdo {\n\t\tif (p->idx >= ib_chunk->length_dw) {\n\t\t\tDRM_ERROR(\"Can not parse packet at %d after CS end %d !\\n\",\n\t\t\t\t  p->idx, ib_chunk->length_dw);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tidx = p->idx;\n\t\theader = radeon_get_ib_value(p, idx);\n\t\tcmd = GET_DMA_CMD(header);\n\t\tcount = GET_DMA_COUNT(header);\n\t\ttiled = GET_DMA_T(header);\n\n\t\tswitch (cmd) {\n\t\tcase DMA_PACKET_WRITE:\n\t\t\tr = r600_dma_cs_next_reloc(p, &dst_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_WRITE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (tiled) {\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset <<= 8;\n\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\tp->idx += count + 5;\n\t\t\t} else {\n\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\n\n\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\tib[idx+2] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\tp->idx += count + 3;\n\t\t\t}\n\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"DMA write buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t dst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMA_PACKET_COPY:\n\t\t\tr = r600_dma_cs_next_reloc(p, &src_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_COPY\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr = r600_dma_cs_next_reloc(p, &dst_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_COPY\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (tiled) {\n\t\t\t\tidx_value = radeon_get_ib_value(p, idx + 2);\n\t\t\t\t \n\t\t\t\tif (idx_value & (1 << 31)) {\n\t\t\t\t\t \n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tsrc_offset <<= 8;\n\t\t\t\t\tib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\n\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+5);\n\t\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+6) & 0xff)) << 32;\n\t\t\t\t\tib[idx+5] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+6] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+5);\n\t\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+6) & 0xff)) << 32;\n\t\t\t\t\tib[idx+5] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+6] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tdst_offset <<= 8;\n\t\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\n\t\t\t\t}\n\t\t\t\tp->idx += 7;\n\t\t\t} else {\n\t\t\t\tif (p->family >= CHIP_RV770) {\n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\n\n\t\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+2] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+3] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\n\t\t\t\t\tib[idx+4] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\t\tp->idx += 5;\n\t\t\t\t} else {\n\t\t\t\t\tsrc_offset = radeon_get_ib_value(p, idx+2);\n\t\t\t\t\tsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\n\t\t\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff0000)) << 16;\n\n\t\t\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+2] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\n\t\t\t\t\tib[idx+3] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\n\t\t\t\t\tib[idx+3] += (upper_32_bits(dst_reloc->gpu_offset) & 0xff) << 16;\n\t\t\t\t\tp->idx += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"DMA copy src buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t src_offset + (count * 4), radeon_bo_size(src_reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"DMA write dst buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t dst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DMA_PACKET_CONSTANT_FILL:\n\t\t\tif (p->family < CHIP_RV770) {\n\t\t\t\tDRM_ERROR(\"Constant Fill is 7xx only !\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr = r600_dma_cs_next_reloc(p, &dst_reloc);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"bad DMA_PACKET_WRITE\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tdst_offset = radeon_get_ib_value(p, idx+1);\n\t\t\tdst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0x00ff0000)) << 16;\n\t\t\tif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\n\t\t\t\tdev_warn(p->dev, \"DMA constant fill buffer too small (%llu %lu)\\n\",\n\t\t\t\t\t dst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\n\t\t\tib[idx+3] += (upper_32_bits(dst_reloc->gpu_offset) << 16) & 0x00ff0000;\n\t\t\tp->idx += 4;\n\t\t\tbreak;\n\t\tcase DMA_PACKET_NOP:\n\t\t\tp->idx += 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d at %d !\\n\", cmd, idx);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (p->idx < p->chunk_ib->length_dw);\n#if 0\n\tfor (r = 0; r < p->ib->length_dw; r++) {\n\t\tpr_info(\"%05d  0x%08X\\n\", r, p->ib.ptr[r]);\n\t\tmdelay(1);\n\t}\n#endif\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}