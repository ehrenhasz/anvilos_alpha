{
  "module_name": "evergreen_dma.c",
  "hash_id": "d8d1ace2435bc03a39190724e240ce71985515cdd97cb770d21969cfd6dfdf43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/evergreen_dma.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"evergreen.h\"\n#include \"evergreend.h\"\n\n \nvoid evergreen_dma_fence_ring_emit(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\n\t \n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_FENCE, 0, 0));\n\tradeon_ring_write(ring, addr & 0xfffffffc);\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xff));\n\tradeon_ring_write(ring, fence->seq);\n\t \n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_TRAP, 0, 0));\n\t \n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0));\n\tradeon_ring_write(ring, (0xf << 16) | (HDP_MEM_COHERENCY_FLUSH_CNTL >> 2));\n\tradeon_ring_write(ring, 1);\n}\n\n \nvoid evergreen_dma_ring_ib_execute(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\n\tif (rdev->wb.enabled) {\n\t\tu32 next_rptr = ring->wptr + 4;\n\t\twhile ((next_rptr & 7) != 5)\n\t\t\tnext_rptr++;\n\t\tnext_rptr += 3;\n\t\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_WRITE, 0, 1));\n\t\tradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\n\t\tradeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr) & 0xff);\n\t\tradeon_ring_write(ring, next_rptr);\n\t}\n\n\t \n\twhile ((ring->wptr & 7) != 5)\n\t\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_NOP, 0, 0));\n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_INDIRECT_BUFFER, 0, 0));\n\tradeon_ring_write(ring, (ib->gpu_addr & 0xFFFFFFE0));\n\tradeon_ring_write(ring, (ib->length_dw << 12) | (upper_32_bits(ib->gpu_addr) & 0xFF));\n\n}\n\n \nstruct radeon_fence *evergreen_copy_dma(struct radeon_device *rdev,\n\t\t\t\t\tuint64_t src_offset,\n\t\t\t\t\tuint64_t dst_offset,\n\t\t\t\t\tunsigned num_gpu_pages,\n\t\t\t\t\tstruct dma_resv *resv)\n{\n\tstruct radeon_fence *fence;\n\tstruct radeon_sync sync;\n\tint ring_index = rdev->asic->copy.dma_ring_index;\n\tstruct radeon_ring *ring = &rdev->ring[ring_index];\n\tu32 size_in_dw, cur_size_in_dw;\n\tint i, num_loops;\n\tint r = 0;\n\n\tradeon_sync_create(&sync);\n\n\tsize_in_dw = (num_gpu_pages << RADEON_GPU_PAGE_SHIFT) / 4;\n\tnum_loops = DIV_ROUND_UP(size_in_dw, 0xfffff);\n\tr = radeon_ring_lock(rdev, ring, num_loops * 5 + 11);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: moving bo (%d).\\n\", r);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_sync_resv(rdev, &sync, resv, false);\n\tradeon_sync_rings(rdev, &sync, ring->idx);\n\n\tfor (i = 0; i < num_loops; i++) {\n\t\tcur_size_in_dw = size_in_dw;\n\t\tif (cur_size_in_dw > 0xFFFFF)\n\t\t\tcur_size_in_dw = 0xFFFFF;\n\t\tsize_in_dw -= cur_size_in_dw;\n\t\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_COPY, 0, cur_size_in_dw));\n\t\tradeon_ring_write(ring, dst_offset & 0xfffffffc);\n\t\tradeon_ring_write(ring, src_offset & 0xfffffffc);\n\t\tradeon_ring_write(ring, upper_32_bits(dst_offset) & 0xff);\n\t\tradeon_ring_write(ring, upper_32_bits(src_offset) & 0xff);\n\t\tsrc_offset += cur_size_in_dw * 4;\n\t\tdst_offset += cur_size_in_dw * 4;\n\t}\n\n\tr = radeon_fence_emit(rdev, &fence, ring->idx);\n\tif (r) {\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tradeon_sync_free(rdev, &sync, fence);\n\n\treturn fence;\n}\n\n \nbool evergreen_dma_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = evergreen_gpu_check_soft_reset(rdev);\n\n\tif (!(reset_mask & RADEON_RESET_DMA)) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}