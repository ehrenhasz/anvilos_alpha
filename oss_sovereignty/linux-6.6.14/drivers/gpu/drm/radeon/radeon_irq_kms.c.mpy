{
  "module_name": "radeon_irq_kms.c",
  "hash_id": "cd2636530a87511423d71917eb5355091c2117f241f062baa78c30049f322bd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_irq_kms.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_kms.h\"\n#include \"radeon_reg.h\"\n\n\n#define RADEON_WAIT_IDLE_TIMEOUT 200\n\n \nstatic irqreturn_t radeon_driver_irq_handler_kms(int irq, void *arg)\n{\n\tstruct drm_device *dev = (struct drm_device *) arg;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tirqreturn_t ret;\n\n\tret = radeon_irq_process(rdev);\n\tif (ret == IRQ_HANDLED)\n\t\tpm_runtime_mark_last_busy(dev->dev);\n\treturn ret;\n}\n\n \n \nstatic void radeon_hotplug_work_func(struct work_struct *work)\n{\n\tstruct radeon_device *rdev = container_of(work, struct radeon_device,\n\t\t\t\t\t\t  hotplug_work.work);\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tstruct drm_connector *connector;\n\n\t \n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tmutex_lock(&mode_config->mutex);\n\tlist_for_each_entry(connector, &mode_config->connector_list, head)\n\t\tradeon_connector_hotplug(connector);\n\tmutex_unlock(&mode_config->mutex);\n\t \n\tdrm_helper_hpd_irq_event(dev);\n}\n\nstatic void radeon_dp_work_func(struct work_struct *work)\n{\n\tstruct radeon_device *rdev = container_of(work, struct radeon_device,\n\t\t\t\t\t\t  dp_work);\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tstruct drm_connector *connector;\n\n\tmutex_lock(&mode_config->mutex);\n\tlist_for_each_entry(connector, &mode_config->connector_list, head)\n\t\tradeon_connector_hotplug(connector);\n\tmutex_unlock(&mode_config->mutex);\n}\n\n \nstatic void radeon_driver_irq_preinstall_kms(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tunsigned long irqflags;\n\tunsigned i;\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t \n\tfor (i = 0; i < RADEON_NUM_RINGS; i++)\n\t\tatomic_set(&rdev->irq.ring_int[i], 0);\n\trdev->irq.dpm_thermal = false;\n\tfor (i = 0; i < RADEON_MAX_HPD_PINS; i++)\n\t\trdev->irq.hpd[i] = false;\n\tfor (i = 0; i < RADEON_MAX_CRTCS; i++) {\n\t\trdev->irq.crtc_vblank_int[i] = false;\n\t\tatomic_set(&rdev->irq.pflip[i], 0);\n\t\trdev->irq.afmt[i] = false;\n\t}\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\t \n\tradeon_irq_process(rdev);\n}\n\n \nstatic int radeon_driver_irq_postinstall_kms(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (ASIC_IS_AVIVO(rdev))\n\t\tdev->max_vblank_count = 0x00ffffff;\n\telse\n\t\tdev->max_vblank_count = 0x001fffff;\n\n\treturn 0;\n}\n\n \nstatic void radeon_driver_irq_uninstall_kms(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tunsigned long irqflags;\n\tunsigned i;\n\n\tif (rdev == NULL) {\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t \n\tfor (i = 0; i < RADEON_NUM_RINGS; i++)\n\t\tatomic_set(&rdev->irq.ring_int[i], 0);\n\trdev->irq.dpm_thermal = false;\n\tfor (i = 0; i < RADEON_MAX_HPD_PINS; i++)\n\t\trdev->irq.hpd[i] = false;\n\tfor (i = 0; i < RADEON_MAX_CRTCS; i++) {\n\t\trdev->irq.crtc_vblank_int[i] = false;\n\t\tatomic_set(&rdev->irq.pflip[i], 0);\n\t\trdev->irq.afmt[i] = false;\n\t}\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n}\n\nstatic int radeon_irq_install(struct radeon_device *rdev, int irq)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tint ret;\n\n\tif (irq == IRQ_NOTCONNECTED)\n\t\treturn -ENOTCONN;\n\n\tradeon_driver_irq_preinstall_kms(dev);\n\n\t \n\tret = request_irq(irq, radeon_driver_irq_handler_kms,\n\t\t\t  IRQF_SHARED, dev->driver->name, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tradeon_driver_irq_postinstall_kms(dev);\n\n\treturn 0;\n}\n\nstatic void radeon_irq_uninstall(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tradeon_driver_irq_uninstall_kms(dev);\n\tfree_irq(pdev->irq, dev);\n}\n\n \nstatic bool radeon_msi_ok(struct radeon_device *rdev)\n{\n\t \n\tif (rdev->family < CHIP_RV380)\n\t\treturn false;\n\n\t \n\tif (rdev->flags & RADEON_IS_AGP)\n\t\treturn false;\n\n\t \n\tif (rdev->family < CHIP_BONAIRE) {\n\t\tdev_info(rdev->dev, \"radeon: MSI limited to 32-bit\\n\");\n\t\trdev->pdev->no_64bit_msi = 1;\n\t}\n\n\t \n\tif (radeon_msi == 1)\n\t\treturn true;\n\telse if (radeon_msi == 0)\n\t\treturn false;\n\n\t \n\t \n\tif ((rdev->pdev->device == 0x791f) &&\n\t    (rdev->pdev->subsystem_vendor == 0x103c) &&\n\t    (rdev->pdev->subsystem_device == 0x30c2))\n\t\treturn true;\n\n\t \n\tif ((rdev->pdev->device == 0x791f) &&\n\t    (rdev->pdev->subsystem_vendor == 0x1028) &&\n\t    (rdev->pdev->subsystem_device == 0x01fc))\n\t\treturn true;\n\n\t \n\tif ((rdev->pdev->device == 0x791f) &&\n\t    (rdev->pdev->subsystem_vendor == 0x1028) &&\n\t    (rdev->pdev->subsystem_device == 0x01fd))\n\t\treturn true;\n\n\t \n\tif ((rdev->pdev->device == 0x791f) &&\n\t    (rdev->pdev->subsystem_vendor == 0x107b) &&\n\t    (rdev->pdev->subsystem_device == 0x0185))\n\t\treturn true;\n\n\t \n\tif (rdev->family == CHIP_RS690)\n\t\treturn true;\n\n\t \n\tif (rdev->family == CHIP_RV515)\n\t\treturn false;\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\t \n\t\tif (rdev->family >= CHIP_PALM)\n\t\t\treturn true;\n\t\t \n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint radeon_irq_kms_init(struct radeon_device *rdev)\n{\n\tint r = 0;\n\n\tspin_lock_init(&rdev->irq.lock);\n\n\t \n\trdev->ddev->vblank_disable_immediate = true;\n\n\tr = drm_vblank_init(rdev->ddev, rdev->num_crtc);\n\tif (r) {\n\t\treturn r;\n\t}\n\n\t \n\trdev->msi_enabled = 0;\n\n\tif (radeon_msi_ok(rdev)) {\n\t\tint ret = pci_enable_msi(rdev->pdev);\n\t\tif (!ret) {\n\t\t\trdev->msi_enabled = 1;\n\t\t\tdev_info(rdev->dev, \"radeon: using MSI.\\n\");\n\t\t}\n\t}\n\n\tINIT_DELAYED_WORK(&rdev->hotplug_work, radeon_hotplug_work_func);\n\tINIT_WORK(&rdev->dp_work, radeon_dp_work_func);\n\tINIT_WORK(&rdev->audio_work, r600_audio_update_hdmi);\n\n\trdev->irq.installed = true;\n\tr = radeon_irq_install(rdev, rdev->pdev->irq);\n\tif (r) {\n\t\trdev->irq.installed = false;\n\t\tflush_delayed_work(&rdev->hotplug_work);\n\t\treturn r;\n\t}\n\n\tDRM_INFO(\"radeon: irq initialized.\\n\");\n\treturn 0;\n}\n\n \nvoid radeon_irq_kms_fini(struct radeon_device *rdev)\n{\n\tif (rdev->irq.installed) {\n\t\tradeon_irq_uninstall(rdev);\n\t\trdev->irq.installed = false;\n\t\tif (rdev->msi_enabled)\n\t\t\tpci_disable_msi(rdev->pdev);\n\t\tflush_delayed_work(&rdev->hotplug_work);\n\t}\n}\n\n \nvoid radeon_irq_kms_sw_irq_get(struct radeon_device *rdev, int ring)\n{\n\tunsigned long irqflags;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tif (atomic_inc_return(&rdev->irq.ring_int[ring]) == 1) {\n\t\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t\tradeon_irq_set(rdev);\n\t\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\t}\n}\n\n \nbool radeon_irq_kms_sw_irq_get_delayed(struct radeon_device *rdev, int ring)\n{\n\treturn atomic_inc_return(&rdev->irq.ring_int[ring]) == 1;\n}\n\n \nvoid radeon_irq_kms_sw_irq_put(struct radeon_device *rdev, int ring)\n{\n\tunsigned long irqflags;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tif (atomic_dec_and_test(&rdev->irq.ring_int[ring])) {\n\t\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t\tradeon_irq_set(rdev);\n\t\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\t}\n}\n\n \nvoid radeon_irq_kms_pflip_irq_get(struct radeon_device *rdev, int crtc)\n{\n\tunsigned long irqflags;\n\n\tif (crtc < 0 || crtc >= rdev->num_crtc)\n\t\treturn;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tif (atomic_inc_return(&rdev->irq.pflip[crtc]) == 1) {\n\t\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t\tradeon_irq_set(rdev);\n\t\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\t}\n}\n\n \nvoid radeon_irq_kms_pflip_irq_put(struct radeon_device *rdev, int crtc)\n{\n\tunsigned long irqflags;\n\n\tif (crtc < 0 || crtc >= rdev->num_crtc)\n\t\treturn;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tif (atomic_dec_and_test(&rdev->irq.pflip[crtc])) {\n\t\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t\tradeon_irq_set(rdev);\n\t\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\t}\n}\n\n \nvoid radeon_irq_kms_enable_afmt(struct radeon_device *rdev, int block)\n{\n\tunsigned long irqflags;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\trdev->irq.afmt[block] = true;\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\n}\n\n \nvoid radeon_irq_kms_disable_afmt(struct radeon_device *rdev, int block)\n{\n\tunsigned long irqflags;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\trdev->irq.afmt[block] = false;\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n}\n\n \nvoid radeon_irq_kms_enable_hpd(struct radeon_device *rdev, unsigned hpd_mask)\n{\n\tunsigned long irqflags;\n\tint i;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\tfor (i = 0; i < RADEON_MAX_HPD_PINS; ++i)\n\t\trdev->irq.hpd[i] |= !!(hpd_mask & (1 << i));\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n}\n\n \nvoid radeon_irq_kms_disable_hpd(struct radeon_device *rdev, unsigned hpd_mask)\n{\n\tunsigned long irqflags;\n\tint i;\n\n\tif (!rdev->irq.installed)\n\t\treturn;\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\tfor (i = 0; i < RADEON_MAX_HPD_PINS; ++i)\n\t\trdev->irq.hpd[i] &= !(hpd_mask & (1 << i));\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n}\n\n \nvoid radeon_irq_kms_set_irq_n_enabled(struct radeon_device *rdev,\n\t\t\t\t      u32 reg, u32 mask,\n\t\t\t\t      bool enable, const char *name, unsigned n)\n{\n\tu32 tmp = RREG32(reg);\n\n\t \n\tif (!!(tmp & mask) == enable)\n\t\treturn;\n\n\tif (enable) {\n\t\tDRM_DEBUG(\"%s%d interrupts enabled\\n\", name, n);\n\t\tWREG32(reg, tmp |= mask);\n\t} else {\n\t\tDRM_DEBUG(\"%s%d interrupts disabled\\n\", name, n);\n\t\tWREG32(reg, tmp & ~mask);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}