{
  "module_name": "cypress_dpm.c",
  "hash_id": "a064487ead37295b874d88a7608de0c5740bb75fd60759988f2d4d4d1a76d490",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/cypress_dpm.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"atom.h\"\n#include \"cypress_dpm.h\"\n#include \"evergreen.h\"\n#include \"evergreend.h\"\n#include \"r600_dpm.h\"\n#include \"rv770.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n\n#define SMC_RAM_END 0x8000\n\n#define MC_CG_ARB_FREQ_F0           0x0a\n#define MC_CG_ARB_FREQ_F1           0x0b\n#define MC_CG_ARB_FREQ_F2           0x0c\n#define MC_CG_ARB_FREQ_F3           0x0d\n\n#define MC_CG_SEQ_DRAMCONF_S0       0x05\n#define MC_CG_SEQ_DRAMCONF_S1       0x06\n#define MC_CG_SEQ_YCLK_SUSPEND      0x04\n#define MC_CG_SEQ_YCLK_RESUME       0x0a\n\nstatic void cypress_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t\t bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp, bif;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tif (enable) {\n\t\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\n\t\t\tif (!pi->boot_in_gen2) {\n\t\t\t\tbif = RREG32(CG_BIF_REQ_AND_RSP) & ~CG_CLIENT_REQ_MASK;\n\t\t\t\tbif |= CG_CLIENT_REQ(0xd);\n\t\t\t\tWREG32(CG_BIF_REQ_AND_RSP, bif);\n\n\t\t\t\ttmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\t\t\t\ttmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\n\t\t\t\ttmp |= LC_GEN2_EN_STRAP;\n\n\t\t\t\ttmp |= LC_CLR_FAILED_SPD_CHANGE_CNT;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t\t\t\tudelay(10);\n\t\t\t\ttmp &= ~LC_CLR_FAILED_SPD_CHANGE_CNT;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!pi->boot_in_gen2) {\n\t\t\ttmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\t\t\ttmp &= ~LC_GEN2_EN_STRAP;\n\t\t}\n\t\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) ||\n\t\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t}\n}\n\nstatic void cypress_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t     bool enable)\n{\n\tcypress_enable_bif_dynamic_pcie_gen2(rdev, enable);\n\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\n}\n\n#if 0\nstatic int cypress_enter_ulp_state(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (pi->gfx_clock_gating) {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\n\t\tRREG32(GB_ADDR_CONFIG);\n\t}\n\n\tWREG32_P(SMC_MSG, HOST_SMC_MSG(PPSMC_MSG_SwitchToMinimumPower),\n\t\t ~HOST_SMC_MSG_MASK);\n\n\tudelay(7000);\n\n\treturn 0;\n}\n#endif\n\nstatic void cypress_gfx_clock_gating_enable(struct radeon_device *rdev,\n\t\t\t\t\t    bool enable)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tif (enable) {\n\t\tif (eg_pi->light_sleep) {\n\t\t\tWREG32(GRBM_GFX_INDEX, 0xC0000000);\n\n\t\t\tWREG32_CG(CG_CGLS_TILE_0, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_1, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_2, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_3, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_4, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_5, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_6, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_7, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_8, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_9, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_10, 0xFFFFFFFF);\n\t\t\tWREG32_CG(CG_CGLS_TILE_11, 0xFFFFFFFF);\n\n\t\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_LIGHT_SLEEP_EN, ~DYN_LIGHT_SLEEP_EN);\n\t\t}\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\n\t} else {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\t\tRREG32(GB_ADDR_CONFIG);\n\n\t\tif (eg_pi->light_sleep) {\n\t\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_LIGHT_SLEEP_EN);\n\n\t\t\tWREG32(GRBM_GFX_INDEX, 0xC0000000);\n\n\t\t\tWREG32_CG(CG_CGLS_TILE_0, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_1, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_2, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_3, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_4, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_5, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_6, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_7, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_8, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_9, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_10, 0);\n\t\t\tWREG32_CG(CG_CGLS_TILE_11, 0);\n\t\t}\n\t}\n}\n\nstatic void cypress_mg_clock_gating_enable(struct radeon_device *rdev,\n\t\t\t\t\t   bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tif (enable) {\n\t\tu32 cgts_sm_ctrl_reg;\n\n\t\tif (rdev->family == CHIP_CEDAR)\n\t\t\tcgts_sm_ctrl_reg = CEDAR_MGCGCGTSSMCTRL_DFLT;\n\t\telse if (rdev->family == CHIP_REDWOOD)\n\t\t\tcgts_sm_ctrl_reg = REDWOOD_MGCGCGTSSMCTRL_DFLT;\n\t\telse\n\t\t\tcgts_sm_ctrl_reg = CYPRESS_MGCGCGTSSMCTRL_DFLT;\n\n\t\tWREG32(GRBM_GFX_INDEX, 0xC0000000);\n\n\t\tWREG32_CG(CG_CGTT_LOCAL_0, CYPRESS_MGCGTTLOCAL0_DFLT);\n\t\tWREG32_CG(CG_CGTT_LOCAL_1, CYPRESS_MGCGTTLOCAL1_DFLT & 0xFFFFCFFF);\n\t\tWREG32_CG(CG_CGTT_LOCAL_2, CYPRESS_MGCGTTLOCAL2_DFLT);\n\t\tWREG32_CG(CG_CGTT_LOCAL_3, CYPRESS_MGCGTTLOCAL3_DFLT);\n\n\t\tif (pi->mgcgtssm)\n\t\t\tWREG32(CGTS_SM_CTRL_REG, cgts_sm_ctrl_reg);\n\n\t\tif (eg_pi->mcls) {\n\t\t\tWREG32_P(MC_CITF_MISC_RD_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(MC_CITF_MISC_WR_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(MC_CITF_MISC_VM_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(MC_HUB_MISC_HUB_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(MC_HUB_MISC_VM_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(MC_HUB_MISC_SIP_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(MC_XPB_CLK_GAT, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t\tWREG32_P(VM_L2_CG, MEM_LS_ENABLE, ~MEM_LS_ENABLE);\n\t\t}\n\t} else {\n\t\tWREG32(GRBM_GFX_INDEX, 0xC0000000);\n\n\t\tWREG32_CG(CG_CGTT_LOCAL_0, 0xFFFFFFFF);\n\t\tWREG32_CG(CG_CGTT_LOCAL_1, 0xFFFFFFFF);\n\t\tWREG32_CG(CG_CGTT_LOCAL_2, 0xFFFFFFFF);\n\t\tWREG32_CG(CG_CGTT_LOCAL_3, 0xFFFFFFFF);\n\n\t\tif (pi->mgcgtssm)\n\t\t\tWREG32(CGTS_SM_CTRL_REG, 0x81f44bc0);\n\t}\n}\n\nvoid cypress_enable_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t    bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (enable) {\n\t\tif (pi->sclk_ss)\n\t\t\tWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\n\n\t\tif (pi->mclk_ss)\n\t\t\tWREG32_P(MPLL_CNTL_MODE, SS_SSEN, ~SS_SSEN);\n\t} else {\n\t\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM, 0, ~SSEN);\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\n\t\tWREG32_P(MPLL_CNTL_MODE, 0, ~SS_SSEN);\n\t\tWREG32_P(MPLL_CNTL_MODE, 0, ~SS_DSMODE_EN);\n\t}\n}\n\nvoid cypress_start_dpm(struct radeon_device *rdev)\n{\n\tWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\n}\n\nvoid cypress_enable_sclk_control(struct radeon_device *rdev,\n\t\t\t\t bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~SCLK_PWRMGT_OFF);\n\telse\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, SCLK_PWRMGT_OFF, ~SCLK_PWRMGT_OFF);\n}\n\nvoid cypress_enable_mclk_control(struct radeon_device *rdev,\n\t\t\t\t bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(MCLK_PWRMGT_CNTL, 0, ~MPLL_PWRMGT_OFF);\n\telse\n\t\tWREG32_P(MCLK_PWRMGT_CNTL, MPLL_PWRMGT_OFF, ~MPLL_PWRMGT_OFF);\n}\n\nint cypress_notify_smc_display_change(struct radeon_device *rdev,\n\t\t\t\t      bool has_display)\n{\n\tPPSMC_Msg msg = has_display ?\n\t\t(PPSMC_Msg)PPSMC_MSG_HasDisplay : (PPSMC_Msg)PPSMC_MSG_NoDisplay;\n\n\tif (rv770_send_msg_to_smc(rdev, msg) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nvoid cypress_program_response_times(struct radeon_device *rdev)\n{\n\tu32 reference_clock;\n\tu32 mclk_switch_limit;\n\n\treference_clock = radeon_get_xclk(rdev);\n\tmclk_switch_limit = (460 * reference_clock) / 100;\n\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_mclk_switch_lim,\n\t\t\t\t      mclk_switch_limit);\n\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_mvdd_chg_time, 1);\n\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_mc_block_delay, 0xAA);\n\n\trv770_program_response_times(rdev);\n\n\tif (ASIC_IS_LOMBOK(rdev))\n\t\trv770_write_smc_soft_register(rdev,\n\t\t\t\t\t      RV770_SMC_SOFT_REGISTER_is_asic_lombok, 1);\n\n}\n\nstatic int cypress_pcie_performance_request(struct radeon_device *rdev,\n\t\t\t\t\t    u8 perf_req, bool advertise)\n{\n#if defined(CONFIG_ACPI)\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n#endif\n\tu32 tmp;\n\n\tudelay(10);\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tif ((perf_req == PCIE_PERF_REQ_PECI_GEN1) && (tmp & LC_CURRENT_DATA_RATE))\n\t\treturn 0;\n\n#if defined(CONFIG_ACPI)\n\tif ((perf_req == PCIE_PERF_REQ_PECI_GEN1) ||\n\t    (perf_req == PCIE_PERF_REQ_PECI_GEN2)) {\n\t\teg_pi->pcie_performance_request_registered = true;\n\t\treturn radeon_acpi_pcie_performance_request(rdev, perf_req, advertise);\n\t} else if ((perf_req == PCIE_PERF_REQ_REMOVE_REGISTRY) &&\n\t\t   eg_pi->pcie_performance_request_registered) {\n\t\teg_pi->pcie_performance_request_registered = false;\n\t\treturn radeon_acpi_pcie_performance_request(rdev, perf_req, advertise);\n\t}\n#endif\n\n\treturn 0;\n}\n\nvoid cypress_advertise_gen2_capability(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp;\n\n#if defined(CONFIG_ACPI)\n\tradeon_acpi_pcie_notify_device_ready(rdev);\n#endif\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\n\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\n\t\tpi->pcie_gen2 = true;\n\telse\n\t\tpi->pcie_gen2 = false;\n\n\tif (!pi->pcie_gen2)\n\t\tcypress_pcie_performance_request(rdev, PCIE_PERF_REQ_PECI_GEN2, true);\n\n}\n\nstatic enum radeon_pcie_gen cypress_get_maximum_link_speed(struct radeon_ps *radeon_state)\n{\n\tstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\n\n\tif (state->high.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid cypress_notify_link_speed_change_after_state_change(struct radeon_device *rdev,\n\t\t\t\t\t\t\t struct radeon_ps *radeon_new_state,\n\t\t\t\t\t\t\t struct radeon_ps *radeon_current_state)\n{\n\tenum radeon_pcie_gen pcie_link_speed_target =\n\t\tcypress_get_maximum_link_speed(radeon_new_state);\n\tenum radeon_pcie_gen pcie_link_speed_current =\n\t\tcypress_get_maximum_link_speed(radeon_current_state);\n\tu8 request;\n\n\tif (pcie_link_speed_target < pcie_link_speed_current) {\n\t\tif (pcie_link_speed_target == RADEON_PCIE_GEN1)\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN1;\n\t\telse if (pcie_link_speed_target == RADEON_PCIE_GEN2)\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN2;\n\t\telse\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN3;\n\n\t\tcypress_pcie_performance_request(rdev, request, false);\n\t}\n}\n\nvoid cypress_notify_link_speed_change_before_state_change(struct radeon_device *rdev,\n\t\t\t\t\t\t\t  struct radeon_ps *radeon_new_state,\n\t\t\t\t\t\t\t  struct radeon_ps *radeon_current_state)\n{\n\tenum radeon_pcie_gen pcie_link_speed_target =\n\t\tcypress_get_maximum_link_speed(radeon_new_state);\n\tenum radeon_pcie_gen pcie_link_speed_current =\n\t\tcypress_get_maximum_link_speed(radeon_current_state);\n\tu8 request;\n\n\tif (pcie_link_speed_target > pcie_link_speed_current) {\n\t\tif (pcie_link_speed_target == RADEON_PCIE_GEN1)\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN1;\n\t\telse if (pcie_link_speed_target == RADEON_PCIE_GEN2)\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN2;\n\t\telse\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN3;\n\n\t\tcypress_pcie_performance_request(rdev, request, false);\n\t}\n}\n\nstatic int cypress_populate_voltage_value(struct radeon_device *rdev,\n\t\t\t\t\t  struct atom_voltage_table *table,\n\t\t\t\t\t  u16 value, RV770_SMC_VOLTAGE_VALUE *voltage)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (value <= table->entries[i].value) {\n\t\t\tvoltage->index = (u8)i;\n\t\t\tvoltage->value = cpu_to_be16(table->entries[i].value);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == table->count)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nu8 cypress_get_strobe_mode_settings(struct radeon_device *rdev, u32 mclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu8 result = 0;\n\tbool strobe_mode = false;\n\n\tif (pi->mem_gddr5) {\n\t\tif (mclk <= pi->mclk_strobe_mode_threshold)\n\t\t\tstrobe_mode = true;\n\t\tresult = cypress_get_mclk_frequency_ratio(rdev, mclk, strobe_mode);\n\n\t\tif (strobe_mode)\n\t\t\tresult |= SMC_STROBE_ENABLE;\n\t}\n\n\treturn result;\n}\n\nu32 cypress_map_clkf_to_ibias(struct radeon_device *rdev, u32 clkf)\n{\n\tu32 ref_clk = rdev->clock.mpll.reference_freq;\n\tu32 vco = clkf * ref_clk;\n\n\t \n\tif (ref_clk == 10000) {\n\t\tif (vco > 500000)\n\t\t\treturn 0xC6;\n\t\tif (vco > 400000)\n\t\t\treturn 0x9D;\n\t\tif (vco > 330000)\n\t\t\treturn 0x6C;\n\t\tif (vco > 250000)\n\t\t\treturn 0x2B;\n\t\tif (vco >  160000)\n\t\t\treturn 0x5B;\n\t\tif (vco > 120000)\n\t\t\treturn 0x0A;\n\t\treturn 0x4B;\n\t}\n\n\t \n\tif (vco > 250000)\n\t\treturn 0x8B;\n\tif (vco > 200000)\n\t\treturn 0xCC;\n\tif (vco > 150000)\n\t\treturn 0x9B;\n\treturn 0x6B;\n}\n\nstatic int cypress_populate_mclk_value(struct radeon_device *rdev,\n\t\t\t\t       u32 engine_clock, u32 memory_clock,\n\t\t\t\t       RV7XX_SMC_MCLK_VALUE *mclk,\n\t\t\t\t       bool strobe_mode, bool dll_state_on)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tu32 mpll_ad_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl_2;\n\tu32 mclk_pwrmgt_cntl =\n\t\tpi->clk_regs.rv770.mclk_pwrmgt_cntl;\n\tu32 dll_cntl =\n\t\tpi->clk_regs.rv770.dll_cntl;\n\tu32 mpll_ss1 = pi->clk_regs.rv770.mpll_ss1;\n\tu32 mpll_ss2 = pi->clk_regs.rv770.mpll_ss2;\n\tstruct atom_clock_dividers dividers;\n\tu32 ibias;\n\tu32 dll_speed;\n\tint ret;\n\tu32 mc_seq_misc7;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\n\t\t\t\t\t     memory_clock, strobe_mode, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!strobe_mode) {\n\t\tmc_seq_misc7 = RREG32(MC_SEQ_MISC7);\n\n\t\tif(mc_seq_misc7 & 0x8000000)\n\t\t\tdividers.post_div = 1;\n\t}\n\n\tibias = cypress_map_clkf_to_ibias(rdev, dividers.whole_fb_div);\n\n\tmpll_ad_func_cntl &= ~(CLKR_MASK |\n\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t       CLKF_MASK |\n\t\t\t       CLKFRAC_MASK |\n\t\t\t       IBIAS_MASK);\n\tmpll_ad_func_cntl |= CLKR(dividers.ref_div);\n\tmpll_ad_func_cntl |= YCLK_POST_DIV(dividers.post_div);\n\tmpll_ad_func_cntl |= CLKF(dividers.whole_fb_div);\n\tmpll_ad_func_cntl |= CLKFRAC(dividers.frac_fb_div);\n\tmpll_ad_func_cntl |= IBIAS(ibias);\n\n\tif (dividers.vco_mode)\n\t\tmpll_ad_func_cntl_2 |= VCO_MODE;\n\telse\n\t\tmpll_ad_func_cntl_2 &= ~VCO_MODE;\n\n\tif (pi->mem_gddr5) {\n\t\tmpll_dq_func_cntl &= ~(CLKR_MASK |\n\t\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t\t       CLKF_MASK |\n\t\t\t\t       CLKFRAC_MASK |\n\t\t\t\t       IBIAS_MASK);\n\t\tmpll_dq_func_cntl |= CLKR(dividers.ref_div);\n\t\tmpll_dq_func_cntl |= YCLK_POST_DIV(dividers.post_div);\n\t\tmpll_dq_func_cntl |= CLKF(dividers.whole_fb_div);\n\t\tmpll_dq_func_cntl |= CLKFRAC(dividers.frac_fb_div);\n\t\tmpll_dq_func_cntl |= IBIAS(ibias);\n\n\t\tif (strobe_mode)\n\t\t\tmpll_dq_func_cntl &= ~PDNB;\n\t\telse\n\t\t\tmpll_dq_func_cntl |= PDNB;\n\n\t\tif (dividers.vco_mode)\n\t\t\tmpll_dq_func_cntl_2 |= VCO_MODE;\n\t\telse\n\t\t\tmpll_dq_func_cntl_2 &= ~VCO_MODE;\n\t}\n\n\tif (pi->mclk_ss) {\n\t\tstruct radeon_atom_ss ss;\n\t\tu32 vco_freq = memory_clock * dividers.post_div;\n\n\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_MEMORY_SS, vco_freq)) {\n\t\t\tu32 reference_clock = rdev->clock.mpll.reference_freq;\n\t\t\tu32 decoded_ref = rv740_get_decoded_reference_divider(dividers.ref_div);\n\t\t\tu32 clk_s, clk_v;\n\n\t\t\tif (!decoded_ref)\n\t\t\t\treturn -EINVAL;\n\t\t\tclk_s = reference_clock * 5 / (decoded_ref * ss.rate);\n\t\t\tclk_v = ss.percentage *\n\t\t\t\t(0x4000 * dividers.whole_fb_div + 0x800 * dividers.frac_fb_div) / (clk_s * 625);\n\n\t\t\tmpll_ss1 &= ~CLKV_MASK;\n\t\t\tmpll_ss1 |= CLKV(clk_v);\n\n\t\t\tmpll_ss2 &= ~CLKS_MASK;\n\t\t\tmpll_ss2 |= CLKS(clk_s);\n\t\t}\n\t}\n\n\tdll_speed = rv740_get_dll_speed(pi->mem_gddr5,\n\t\t\t\t\tmemory_clock);\n\n\tmclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;\n\tmclk_pwrmgt_cntl |= DLL_SPEED(dll_speed);\n\tif (dll_state_on)\n\t\tmclk_pwrmgt_cntl |= (MRDCKA0_PDNB |\n\t\t\t\t     MRDCKA1_PDNB |\n\t\t\t\t     MRDCKB0_PDNB |\n\t\t\t\t     MRDCKB1_PDNB |\n\t\t\t\t     MRDCKC0_PDNB |\n\t\t\t\t     MRDCKC1_PDNB |\n\t\t\t\t     MRDCKD0_PDNB |\n\t\t\t\t     MRDCKD1_PDNB);\n\telse\n\t\tmclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |\n\t\t\t\t      MRDCKA1_PDNB |\n\t\t\t\t      MRDCKB0_PDNB |\n\t\t\t\t      MRDCKB1_PDNB |\n\t\t\t\t      MRDCKC0_PDNB |\n\t\t\t\t      MRDCKC1_PDNB |\n\t\t\t\t      MRDCKD0_PDNB |\n\t\t\t\t      MRDCKD1_PDNB);\n\n\tmclk->mclk770.mclk_value = cpu_to_be32(memory_clock);\n\tmclk->mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\tmclk->mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\tmclk->mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\tmclk->mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\tmclk->mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\tmclk->mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\tmclk->mclk770.vMPLL_SS = cpu_to_be32(mpll_ss1);\n\tmclk->mclk770.vMPLL_SS2 = cpu_to_be32(mpll_ss2);\n\n\treturn 0;\n}\n\nu8 cypress_get_mclk_frequency_ratio(struct radeon_device *rdev,\n\t\t\t\t    u32 memory_clock, bool strobe_mode)\n{\n\tu8 mc_para_index;\n\n\tif (rdev->family >= CHIP_BARTS) {\n\t\tif (strobe_mode) {\n\t\t\tif (memory_clock < 10000)\n\t\t\t\tmc_para_index = 0x00;\n\t\t\telse if (memory_clock > 47500)\n\t\t\t\tmc_para_index = 0x0f;\n\t\t\telse\n\t\t\t\tmc_para_index = (u8)((memory_clock - 10000) / 2500);\n\t\t} else {\n\t\t\tif (memory_clock < 65000)\n\t\t\t\tmc_para_index = 0x00;\n\t\t\telse if (memory_clock > 135000)\n\t\t\t\tmc_para_index = 0x0f;\n\t\t\telse\n\t\t\t\tmc_para_index = (u8)((memory_clock - 60000) / 5000);\n\t\t}\n\t} else {\n\t\tif (strobe_mode) {\n\t\t\tif (memory_clock < 10000)\n\t\t\t\tmc_para_index = 0x00;\n\t\t\telse if (memory_clock > 47500)\n\t\t\t\tmc_para_index = 0x0f;\n\t\t\telse\n\t\t\t\tmc_para_index = (u8)((memory_clock - 10000) / 2500);\n\t\t} else {\n\t\t\tif (memory_clock < 40000)\n\t\t\t\tmc_para_index = 0x00;\n\t\t\telse if (memory_clock > 115000)\n\t\t\t\tmc_para_index = 0x0f;\n\t\t\telse\n\t\t\t\tmc_para_index = (u8)((memory_clock - 40000) / 5000);\n\t\t}\n\t}\n\treturn mc_para_index;\n}\n\nstatic int cypress_populate_mvdd_value(struct radeon_device *rdev,\n\t\t\t\t       u32 mclk,\n\t\t\t\t       RV770_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tif (!pi->mvdd_control) {\n\t\tvoltage->index = eg_pi->mvdd_high_index;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t\treturn 0;\n\t}\n\n\tif (mclk <= pi->mvdd_split_frequency) {\n\t\tvoltage->index = eg_pi->mvdd_low_index;\n\t\tvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\n\t} else {\n\t\tvoltage->index = eg_pi->mvdd_high_index;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t}\n\n\treturn 0;\n}\n\nint cypress_convert_power_level_to_smc(struct radeon_device *rdev,\n\t\t\t\t       struct rv7xx_pl *pl,\n\t\t\t\t       RV770_SMC_HW_PERFORMANCE_LEVEL *level,\n\t\t\t\t       u8 watermark_level)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tint ret;\n\tbool dll_state_on;\n\n\tlevel->gen2PCIE = pi->pcie_gen2 ?\n\t\t((pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0) : 0;\n\tlevel->gen2XSP  = (pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0;\n\tlevel->backbias = (pl->flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? 1 : 0;\n\tlevel->displayWatermark = watermark_level;\n\n\tret = rv740_populate_sclk_value(rdev, pl->sclk, &level->sclk);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel->mcFlags =  0;\n\tif (pi->mclk_stutter_mode_threshold &&\n\t    (pl->mclk <= pi->mclk_stutter_mode_threshold) &&\n\t    !eg_pi->uvd_enabled) {\n\t\tlevel->mcFlags |= SMC_MC_STUTTER_EN;\n\t\tif (eg_pi->sclk_deep_sleep)\n\t\t\tlevel->stateFlags |= PPSMC_STATEFLAG_AUTO_PULSE_SKIP;\n\t\telse\n\t\t\tlevel->stateFlags &= ~PPSMC_STATEFLAG_AUTO_PULSE_SKIP;\n\t}\n\n\tif (pi->mem_gddr5) {\n\t\tif (pl->mclk > pi->mclk_edc_enable_threshold)\n\t\t\tlevel->mcFlags |= SMC_MC_EDC_RD_FLAG;\n\n\t\tif (pl->mclk > eg_pi->mclk_edc_wr_enable_threshold)\n\t\t\tlevel->mcFlags |= SMC_MC_EDC_WR_FLAG;\n\n\t\tlevel->strobeMode = cypress_get_strobe_mode_settings(rdev, pl->mclk);\n\n\t\tif (level->strobeMode & SMC_STROBE_ENABLE) {\n\t\t\tif (cypress_get_mclk_frequency_ratio(rdev, pl->mclk, true) >=\n\t\t\t    ((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))\n\t\t\t\tdll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\n\t\t\telse\n\t\t\t\tdll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;\n\t\t} else\n\t\t\tdll_state_on = eg_pi->dll_default_on;\n\n\t\tret = cypress_populate_mclk_value(rdev,\n\t\t\t\t\t\t  pl->sclk,\n\t\t\t\t\t\t  pl->mclk,\n\t\t\t\t\t\t  &level->mclk,\n\t\t\t\t\t\t  (level->strobeMode & SMC_STROBE_ENABLE) != 0,\n\t\t\t\t\t\t  dll_state_on);\n\t} else {\n\t\tret = cypress_populate_mclk_value(rdev,\n\t\t\t\t\t\t  pl->sclk,\n\t\t\t\t\t\t  pl->mclk,\n\t\t\t\t\t\t  &level->mclk,\n\t\t\t\t\t\t  true,\n\t\t\t\t\t\t  true);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tret = cypress_populate_voltage_value(rdev,\n\t\t\t\t\t     &eg_pi->vddc_voltage_table,\n\t\t\t\t\t     pl->vddc,\n\t\t\t\t\t     &level->vddc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (eg_pi->vddci_control) {\n\t\tret = cypress_populate_voltage_value(rdev,\n\t\t\t\t\t\t     &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\t     pl->vddci,\n\t\t\t\t\t\t     &level->vddci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = cypress_populate_mvdd_value(rdev, pl->mclk, &level->mvdd);\n\n\treturn ret;\n}\n\nstatic int cypress_convert_power_state_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t      struct radeon_ps *radeon_state,\n\t\t\t\t\t      RV770_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tint ret;\n\n\tif (!(radeon_state->caps & ATOM_PPLIB_DISALLOW_ON_DC))\n\t\tsmc_state->flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\tret = cypress_convert_power_level_to_smc(rdev,\n\t\t\t\t\t\t &state->low,\n\t\t\t\t\t\t &smc_state->levels[0],\n\t\t\t\t\t\t PPSMC_DISPLAY_WATERMARK_LOW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cypress_convert_power_level_to_smc(rdev,\n\t\t\t\t\t\t &state->medium,\n\t\t\t\t\t\t &smc_state->levels[1],\n\t\t\t\t\t\t PPSMC_DISPLAY_WATERMARK_LOW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cypress_convert_power_level_to_smc(rdev,\n\t\t\t\t\t\t &state->high,\n\t\t\t\t\t\t &smc_state->levels[2],\n\t\t\t\t\t\t PPSMC_DISPLAY_WATERMARK_HIGH);\n\tif (ret)\n\t\treturn ret;\n\n\tsmc_state->levels[0].arbValue = MC_CG_ARB_FREQ_F1;\n\tsmc_state->levels[1].arbValue = MC_CG_ARB_FREQ_F2;\n\tsmc_state->levels[2].arbValue = MC_CG_ARB_FREQ_F3;\n\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tsmc_state->levels[0].ACIndex = 2;\n\t\tsmc_state->levels[1].ACIndex = 3;\n\t\tsmc_state->levels[2].ACIndex = 4;\n\t} else {\n\t\tsmc_state->levels[0].ACIndex = 0;\n\t\tsmc_state->levels[1].ACIndex = 0;\n\t\tsmc_state->levels[2].ACIndex = 0;\n\t}\n\n\trv770_populate_smc_sp(rdev, radeon_state, smc_state);\n\n\treturn rv770_populate_smc_t(rdev, radeon_state, smc_state);\n}\n\nstatic void cypress_convert_mc_registers(struct evergreen_mc_reg_entry *entry,\n\t\t\t\t\t SMC_Evergreen_MCRegisterSet *data,\n\t\t\t\t\t u32 num_entries, u32 valid_flag)\n{\n\tu32 i, j;\n\n\tfor (i = 0, j = 0; j < num_entries; j++) {\n\t\tif (valid_flag & (1 << j)) {\n\t\t\tdata->value[i] = cpu_to_be32(entry->mc_data[j]);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic void cypress_convert_mc_reg_table_entry_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t\t      struct rv7xx_pl *pl,\n\t\t\t\t\t\t      SMC_Evergreen_MCRegisterSet *mc_reg_table_data)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 i = 0;\n\n\tfor (i = 0; i < eg_pi->mc_reg_table.num_entries; i++) {\n\t\tif (pl->mclk <=\n\t\t    eg_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)\n\t\t\tbreak;\n\t}\n\n\tif ((i == eg_pi->mc_reg_table.num_entries) && (i > 0))\n\t\t--i;\n\n\tcypress_convert_mc_registers(&eg_pi->mc_reg_table.mc_reg_table_entry[i],\n\t\t\t\t     mc_reg_table_data,\n\t\t\t\t     eg_pi->mc_reg_table.last,\n\t\t\t\t     eg_pi->mc_reg_table.valid_flag);\n}\n\nstatic void cypress_convert_mc_reg_table_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct radeon_ps *radeon_state,\n\t\t\t\t\t\tSMC_Evergreen_MCRegisters *mc_reg_table)\n{\n\tstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\n\n\tcypress_convert_mc_reg_table_entry_to_smc(rdev,\n\t\t\t\t\t\t  &state->low,\n\t\t\t\t\t\t  &mc_reg_table->data[2]);\n\tcypress_convert_mc_reg_table_entry_to_smc(rdev,\n\t\t\t\t\t\t  &state->medium,\n\t\t\t\t\t\t  &mc_reg_table->data[3]);\n\tcypress_convert_mc_reg_table_entry_to_smc(rdev,\n\t\t\t\t\t\t  &state->high,\n\t\t\t\t\t\t  &mc_reg_table->data[4]);\n}\n\nint cypress_upload_sw_state(struct radeon_device *rdev,\n\t\t\t    struct radeon_ps *radeon_new_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu16 address = pi->state_table_start +\n\t\toffsetof(RV770_SMC_STATETABLE, driverState);\n\tRV770_SMC_SWSTATE state = { 0 };\n\tint ret;\n\n\tret = cypress_convert_power_state_to_smc(rdev, radeon_new_state, &state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rv770_copy_bytes_to_smc(rdev, address, (u8 *)&state,\n\t\t\t\t    sizeof(RV770_SMC_SWSTATE),\n\t\t\t\t    pi->sram_end);\n}\n\nint cypress_upload_mc_reg_table(struct radeon_device *rdev,\n\t\t\t\tstruct radeon_ps *radeon_new_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tSMC_Evergreen_MCRegisters mc_reg_table = { 0 };\n\tu16 address;\n\n\tcypress_convert_mc_reg_table_to_smc(rdev, radeon_new_state, &mc_reg_table);\n\n\taddress = eg_pi->mc_reg_table_start +\n\t\t(u16)offsetof(SMC_Evergreen_MCRegisters, data[2]);\n\n\treturn rv770_copy_bytes_to_smc(rdev, address,\n\t\t\t\t       (u8 *)&mc_reg_table.data[2],\n\t\t\t\t       sizeof(SMC_Evergreen_MCRegisterSet) * 3,\n\t\t\t\t       pi->sram_end);\n}\n\nu32 cypress_calculate_burst_time(struct radeon_device *rdev,\n\t\t\t\t u32 engine_clock, u32 memory_clock)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 multiplier = pi->mem_gddr5 ? 1 : 2;\n\tu32 result = (4 * multiplier * engine_clock) / (memory_clock / 2);\n\tu32 burst_time;\n\n\tif (result <= 4)\n\t\tburst_time = 0;\n\telse if (result < 8)\n\t\tburst_time = result - 4;\n\telse {\n\t\tburst_time = result / 2 ;\n\t\tif (burst_time > 18)\n\t\t\tburst_time = 18;\n\t}\n\n\treturn burst_time;\n}\n\nvoid cypress_program_memory_timing_parameters(struct radeon_device *rdev,\n\t\t\t\t\t      struct radeon_ps *radeon_new_state)\n{\n\tstruct rv7xx_ps *new_state = rv770_get_ps(radeon_new_state);\n\tu32 mc_arb_burst_time = RREG32(MC_ARB_BURST_TIME);\n\n\tmc_arb_burst_time &= ~(STATE1_MASK | STATE2_MASK | STATE3_MASK);\n\n\tmc_arb_burst_time |= STATE1(cypress_calculate_burst_time(rdev,\n\t\t\t\t\t\t\t\t new_state->low.sclk,\n\t\t\t\t\t\t\t\t new_state->low.mclk));\n\tmc_arb_burst_time |= STATE2(cypress_calculate_burst_time(rdev,\n\t\t\t\t\t\t\t\t new_state->medium.sclk,\n\t\t\t\t\t\t\t\t new_state->medium.mclk));\n\tmc_arb_burst_time |= STATE3(cypress_calculate_burst_time(rdev,\n\t\t\t\t\t\t\t\t new_state->high.sclk,\n\t\t\t\t\t\t\t\t new_state->high.mclk));\n\n\trv730_program_memory_timing_parameters(rdev, radeon_new_state);\n\n\tWREG32(MC_ARB_BURST_TIME, mc_arb_burst_time);\n}\n\nstatic void cypress_populate_mc_reg_addresses(struct radeon_device *rdev,\n\t\t\t\t\t      SMC_Evergreen_MCRegisters *mc_reg_table)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 i, j;\n\n\tfor (i = 0, j = 0; j < eg_pi->mc_reg_table.last; j++) {\n\t\tif (eg_pi->mc_reg_table.valid_flag & (1 << j)) {\n\t\t\tmc_reg_table->address[i].s0 =\n\t\t\t\tcpu_to_be16(eg_pi->mc_reg_table.mc_reg_address[j].s0);\n\t\t\tmc_reg_table->address[i].s1 =\n\t\t\t\tcpu_to_be16(eg_pi->mc_reg_table.mc_reg_address[j].s1);\n\t\t\ti++;\n\t\t}\n\t}\n\n\tmc_reg_table->last = (u8)i;\n}\n\nstatic void cypress_set_mc_reg_address_table(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 i = 0;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RAS_TIMING_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RAS_TIMING >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_CAS_TIMING_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_CAS_TIMING >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC_TIMING_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC_TIMING >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC_TIMING2_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC_TIMING2 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RD_CTL_D0_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RD_CTL_D0 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RD_CTL_D1_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RD_CTL_D1 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_WR_CTL_D0_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_WR_CTL_D0 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_WR_CTL_D1_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_WR_CTL_D1 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_PMG_CMD_EMRS_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_PMG_CMD_EMRS >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_PMG_CMD_MRS_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_PMG_CMD_MRS >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_PMG_CMD_MRS1_LP >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_PMG_CMD_MRS1 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC1 >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC1 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_RESERVE_M >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_RESERVE_M >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.mc_reg_address[i].s0 = MC_SEQ_MISC3 >> 2;\n\teg_pi->mc_reg_table.mc_reg_address[i].s1 = MC_SEQ_MISC3 >> 2;\n\ti++;\n\n\teg_pi->mc_reg_table.last = (u8)i;\n}\n\nstatic void cypress_retrieve_ac_timing_for_one_entry(struct radeon_device *rdev,\n\t\t\t\t\t\t     struct evergreen_mc_reg_entry *entry)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 i;\n\n\tfor (i = 0; i < eg_pi->mc_reg_table.last; i++)\n\t\tentry->mc_data[i] =\n\t\t\tRREG32(eg_pi->mc_reg_table.mc_reg_address[i].s1 << 2);\n\n}\n\nstatic void cypress_retrieve_ac_timing_for_all_ranges(struct radeon_device *rdev,\n\t\t\t\t\t\t      struct atom_memory_clock_range_table *range_table)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 i, j;\n\n\tfor (i = 0; i < range_table->num_entries; i++) {\n\t\teg_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max =\n\t\t\trange_table->mclk[i];\n\t\tradeon_atom_set_ac_timing(rdev, range_table->mclk[i]);\n\t\tcypress_retrieve_ac_timing_for_one_entry(rdev,\n\t\t\t\t\t\t\t &eg_pi->mc_reg_table.mc_reg_table_entry[i]);\n\t}\n\n\teg_pi->mc_reg_table.num_entries = range_table->num_entries;\n\teg_pi->mc_reg_table.valid_flag = 0;\n\n\tfor (i = 0; i < eg_pi->mc_reg_table.last; i++) {\n\t\tfor (j = 1; j < range_table->num_entries; j++) {\n\t\t\tif (eg_pi->mc_reg_table.mc_reg_table_entry[j-1].mc_data[i] !=\n\t\t\t    eg_pi->mc_reg_table.mc_reg_table_entry[j].mc_data[i]) {\n\t\t\t\teg_pi->mc_reg_table.valid_flag |= (1 << i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int cypress_initialize_mc_reg_table(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu8 module_index = rv770_get_memory_module_index(rdev);\n\tstruct atom_memory_clock_range_table range_table = { 0 };\n\tint ret;\n\n\tret = radeon_atom_get_mclk_range_table(rdev,\n\t\t\t\t\t       pi->mem_gddr5,\n\t\t\t\t\t       module_index, &range_table);\n\tif (ret)\n\t\treturn ret;\n\n\tcypress_retrieve_ac_timing_for_all_ranges(rdev, &range_table);\n\n\treturn 0;\n}\n\nstatic void cypress_wait_for_mc_sequencer(struct radeon_device *rdev, u8 value)\n{\n\tu32 i, j;\n\tu32 channels = 2;\n\n\tif ((rdev->family == CHIP_CYPRESS) ||\n\t    (rdev->family == CHIP_HEMLOCK))\n\t\tchannels = 4;\n\telse if (rdev->family == CHIP_CEDAR)\n\t\tchannels = 1;\n\n\tfor (i = 0; i < channels; i++) {\n\t\tif ((rdev->family == CHIP_CYPRESS) ||\n\t\t    (rdev->family == CHIP_HEMLOCK)) {\n\t\t\tWREG32_P(MC_CONFIG_MCD, MC_RD_ENABLE_MCD(i), ~MC_RD_ENABLE_MCD_MASK);\n\t\t\tWREG32_P(MC_CG_CONFIG_MCD, MC_RD_ENABLE_MCD(i), ~MC_RD_ENABLE_MCD_MASK);\n\t\t} else {\n\t\t\tWREG32_P(MC_CONFIG, MC_RD_ENABLE(i), ~MC_RD_ENABLE_MASK);\n\t\t\tWREG32_P(MC_CG_CONFIG, MC_RD_ENABLE(i), ~MC_RD_ENABLE_MASK);\n\t\t}\n\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\tif (((RREG32(MC_SEQ_CG) & CG_SEQ_RESP_MASK) >> CG_SEQ_RESP_SHIFT) == value)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n}\n\nstatic void cypress_force_mc_use_s1(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_ps *radeon_boot_state)\n{\n\tstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\n\tu32 strobe_mode;\n\tu32 mc_seq_cg;\n\tint i;\n\n\tif (RREG32(MC_SEQ_STATUS_M) & PMG_PWRSTATE)\n\t\treturn;\n\n\tradeon_atom_set_ac_timing(rdev, boot_state->low.mclk);\n\tradeon_mc_wait_for_idle(rdev);\n\n\tif ((rdev->family == CHIP_CYPRESS) ||\n\t    (rdev->family == CHIP_HEMLOCK)) {\n\t\tWREG32(MC_CONFIG_MCD, 0xf);\n\t\tWREG32(MC_CG_CONFIG_MCD, 0xf);\n\t} else {\n\t\tWREG32(MC_CONFIG, 0xf);\n\t\tWREG32(MC_CG_CONFIG, 0xf);\n\t}\n\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tradeon_wait_for_vblank(rdev, i);\n\n\tWREG32(MC_SEQ_CG, MC_CG_SEQ_YCLK_SUSPEND);\n\tcypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_SUSPEND);\n\n\tstrobe_mode = cypress_get_strobe_mode_settings(rdev,\n\t\t\t\t\t\t       boot_state->low.mclk);\n\n\tmc_seq_cg = CG_SEQ_REQ(MC_CG_SEQ_DRAMCONF_S1);\n\tmc_seq_cg |= SEQ_CG_RESP(strobe_mode);\n\tWREG32(MC_SEQ_CG, mc_seq_cg);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(MC_SEQ_STATUS_M) & PMG_PWRSTATE)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tmc_seq_cg &= ~CG_SEQ_REQ_MASK;\n\tmc_seq_cg |= CG_SEQ_REQ(MC_CG_SEQ_YCLK_RESUME);\n\tWREG32(MC_SEQ_CG, mc_seq_cg);\n\n\tcypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_RESUME);\n}\n\nstatic void cypress_copy_ac_timing_from_s1_to_s0(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 value;\n\tu32 i;\n\n\tfor (i = 0; i < eg_pi->mc_reg_table.last; i++) {\n\t\tvalue = RREG32(eg_pi->mc_reg_table.mc_reg_address[i].s1 << 2);\n\t\tWREG32(eg_pi->mc_reg_table.mc_reg_address[i].s0 << 2, value);\n\t}\n}\n\nstatic void cypress_force_mc_use_s0(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_ps *radeon_boot_state)\n{\n\tstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\n\tu32 strobe_mode;\n\tu32 mc_seq_cg;\n\tint i;\n\n\tcypress_copy_ac_timing_from_s1_to_s0(rdev);\n\tradeon_mc_wait_for_idle(rdev);\n\n\tif ((rdev->family == CHIP_CYPRESS) ||\n\t    (rdev->family == CHIP_HEMLOCK)) {\n\t\tWREG32(MC_CONFIG_MCD, 0xf);\n\t\tWREG32(MC_CG_CONFIG_MCD, 0xf);\n\t} else {\n\t\tWREG32(MC_CONFIG, 0xf);\n\t\tWREG32(MC_CG_CONFIG, 0xf);\n\t}\n\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tradeon_wait_for_vblank(rdev, i);\n\n\tWREG32(MC_SEQ_CG, MC_CG_SEQ_YCLK_SUSPEND);\n\tcypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_SUSPEND);\n\n\tstrobe_mode = cypress_get_strobe_mode_settings(rdev,\n\t\t\t\t\t\t       boot_state->low.mclk);\n\n\tmc_seq_cg = CG_SEQ_REQ(MC_CG_SEQ_DRAMCONF_S0);\n\tmc_seq_cg |= SEQ_CG_RESP(strobe_mode);\n\tWREG32(MC_SEQ_CG, mc_seq_cg);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (!(RREG32(MC_SEQ_STATUS_M) & PMG_PWRSTATE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tmc_seq_cg &= ~CG_SEQ_REQ_MASK;\n\tmc_seq_cg |= CG_SEQ_REQ(MC_CG_SEQ_YCLK_RESUME);\n\tWREG32(MC_SEQ_CG, mc_seq_cg);\n\n\tcypress_wait_for_mc_sequencer(rdev, MC_CG_SEQ_YCLK_RESUME);\n}\n\nstatic int cypress_populate_initial_mvdd_value(struct radeon_device *rdev,\n\t\t\t\t\t       RV770_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\tvoltage->index = eg_pi->mvdd_high_index;\n\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\n\treturn 0;\n}\n\nint cypress_populate_smc_initial_state(struct radeon_device *rdev,\n\t\t\t\t       struct radeon_ps *radeon_initial_state,\n\t\t\t\t       RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_ps *initial_state = rv770_get_ps(radeon_initial_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 a_t;\n\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl_2);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl_2);\n\ttable->initialState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mclk_pwrmgt_cntl);\n\ttable->initialState.levels[0].mclk.mclk770.vDLL_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.dll_cntl);\n\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_SS =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ss1);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_SS2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ss2);\n\n\ttable->initialState.levels[0].mclk.mclk770.mclk_value =\n\t\tcpu_to_be32(initial_state->low.mclk);\n\n\ttable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_2);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_3);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum_2);\n\n\ttable->initialState.levels[0].sclk.sclk_value =\n\t\tcpu_to_be32(initial_state->low.sclk);\n\n\ttable->initialState.levels[0].arbValue = MC_CG_ARB_FREQ_F0;\n\n\ttable->initialState.levels[0].ACIndex = 0;\n\n\tcypress_populate_voltage_value(rdev,\n\t\t\t\t       &eg_pi->vddc_voltage_table,\n\t\t\t\t       initial_state->low.vddc,\n\t\t\t\t       &table->initialState.levels[0].vddc);\n\n\tif (eg_pi->vddci_control)\n\t\tcypress_populate_voltage_value(rdev,\n\t\t\t\t\t       &eg_pi->vddci_voltage_table,\n\t\t\t\t\t       initial_state->low.vddci,\n\t\t\t\t\t       &table->initialState.levels[0].vddci);\n\n\tcypress_populate_initial_mvdd_value(rdev,\n\t\t\t\t\t    &table->initialState.levels[0].mvdd);\n\n\ta_t = CG_R(0xffff) | CG_L(0);\n\ttable->initialState.levels[0].aT = cpu_to_be32(a_t);\n\n\ttable->initialState.levels[0].bSP = cpu_to_be32(pi->dsp);\n\n\n\tif (pi->boot_in_gen2)\n\t\ttable->initialState.levels[0].gen2PCIE = 1;\n\telse\n\t\ttable->initialState.levels[0].gen2PCIE = 0;\n\tif (initial_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\n\t\ttable->initialState.levels[0].gen2XSP = 1;\n\telse\n\t\ttable->initialState.levels[0].gen2XSP = 0;\n\n\tif (pi->mem_gddr5) {\n\t\ttable->initialState.levels[0].strobeMode =\n\t\t\tcypress_get_strobe_mode_settings(rdev,\n\t\t\t\t\t\t\t initial_state->low.mclk);\n\n\t\tif (initial_state->low.mclk > pi->mclk_edc_enable_threshold)\n\t\t\ttable->initialState.levels[0].mcFlags = SMC_MC_EDC_RD_FLAG | SMC_MC_EDC_WR_FLAG;\n\t\telse\n\t\t\ttable->initialState.levels[0].mcFlags =  0;\n\t}\n\n\ttable->initialState.levels[1] = table->initialState.levels[0];\n\ttable->initialState.levels[2] = table->initialState.levels[0];\n\n\ttable->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\treturn 0;\n}\n\nint cypress_populate_smc_acpi_state(struct radeon_device *rdev,\n\t\t\t\t    RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 mpll_ad_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl_2;\n\tu32 spll_func_cntl =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl_3;\n\tu32 mclk_pwrmgt_cntl =\n\t\tpi->clk_regs.rv770.mclk_pwrmgt_cntl;\n\tu32 dll_cntl =\n\t\tpi->clk_regs.rv770.dll_cntl;\n\n\ttable->ACPIState = table->initialState;\n\n\ttable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\tif (pi->acpi_vddc) {\n\t\tcypress_populate_voltage_value(rdev,\n\t\t\t\t\t       &eg_pi->vddc_voltage_table,\n\t\t\t\t\t       pi->acpi_vddc,\n\t\t\t\t\t       &table->ACPIState.levels[0].vddc);\n\t\tif (pi->pcie_gen2) {\n\t\t\tif (pi->acpi_pcie_gen2)\n\t\t\t\ttable->ACPIState.levels[0].gen2PCIE = 1;\n\t\t\telse\n\t\t\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t\t} else\n\t\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t\tif (pi->acpi_pcie_gen2)\n\t\t\ttable->ACPIState.levels[0].gen2XSP = 1;\n\t\telse\n\t\t\ttable->ACPIState.levels[0].gen2XSP = 0;\n\t} else {\n\t\tcypress_populate_voltage_value(rdev,\n\t\t\t\t\t       &eg_pi->vddc_voltage_table,\n\t\t\t\t\t       pi->min_vddc_in_table,\n\t\t\t\t\t       &table->ACPIState.levels[0].vddc);\n\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t}\n\n\tif (eg_pi->acpi_vddci) {\n\t\tif (eg_pi->vddci_control) {\n\t\t\tcypress_populate_voltage_value(rdev,\n\t\t\t\t\t\t       &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\t       eg_pi->acpi_vddci,\n\t\t\t\t\t\t       &table->ACPIState.levels[0].vddci);\n\t\t}\n\t}\n\n\tmpll_ad_func_cntl &= ~PDNB;\n\n\tmpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\n\n\tif (pi->mem_gddr5)\n\t\tmpll_dq_func_cntl &= ~PDNB;\n\tmpll_dq_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN | BYPASS;\n\n\tmclk_pwrmgt_cntl |= (MRDCKA0_RESET |\n\t\t\t     MRDCKA1_RESET |\n\t\t\t     MRDCKB0_RESET |\n\t\t\t     MRDCKB1_RESET |\n\t\t\t     MRDCKC0_RESET |\n\t\t\t     MRDCKC1_RESET |\n\t\t\t     MRDCKD0_RESET |\n\t\t\t     MRDCKD1_RESET);\n\n\tmclk_pwrmgt_cntl &= ~(MRDCKA0_PDNB |\n\t\t\t      MRDCKA1_PDNB |\n\t\t\t      MRDCKB0_PDNB |\n\t\t\t      MRDCKB1_PDNB |\n\t\t\t      MRDCKC0_PDNB |\n\t\t\t      MRDCKC1_PDNB |\n\t\t\t      MRDCKD0_PDNB |\n\t\t\t      MRDCKD1_PDNB);\n\n\tdll_cntl |= (MRDCKA0_BYPASS |\n\t\t     MRDCKA1_BYPASS |\n\t\t     MRDCKB0_BYPASS |\n\t\t     MRDCKB1_BYPASS |\n\t\t     MRDCKC0_BYPASS |\n\t\t     MRDCKC1_BYPASS |\n\t\t     MRDCKD0_BYPASS |\n\t\t     MRDCKD1_BYPASS);\n\n\t \n\tif (rdev->family <= CHIP_HEMLOCK)\n\t\tspll_func_cntl |= SPLL_RESET | SPLL_SLEEP | SPLL_BYPASS_EN;\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(4);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL =\n\t\tcpu_to_be32(mpll_ad_func_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 =\n\t\tcpu_to_be32(mpll_ad_func_cntl_2);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL =\n\t\tcpu_to_be32(mpll_dq_func_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 =\n\t\tcpu_to_be32(mpll_dq_func_cntl_2);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL =\n\t\tcpu_to_be32(mclk_pwrmgt_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.mclk_value = 0;\n\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL =\n\t\tcpu_to_be32(spll_func_cntl);\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(spll_func_cntl_2);\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 =\n\t\tcpu_to_be32(spll_func_cntl_3);\n\n\ttable->ACPIState.levels[0].sclk.sclk_value = 0;\n\n\tcypress_populate_mvdd_value(rdev, 0, &table->ACPIState.levels[0].mvdd);\n\n\tif (eg_pi->dynamic_ac_timing)\n\t\ttable->ACPIState.levels[0].ACIndex = 1;\n\n\ttable->ACPIState.levels[1] = table->ACPIState.levels[0];\n\ttable->ACPIState.levels[2] = table->ACPIState.levels[0];\n\n\treturn 0;\n}\n\nstatic void cypress_trim_voltage_table_to_fit_state_table(struct radeon_device *rdev,\n\t\t\t\t\t\t\t  struct atom_voltage_table *voltage_table)\n{\n\tunsigned int i, diff;\n\n\tif (voltage_table->count <= MAX_NO_VREG_STEPS)\n\t\treturn;\n\n\tdiff = voltage_table->count - MAX_NO_VREG_STEPS;\n\n\tfor (i= 0; i < MAX_NO_VREG_STEPS; i++)\n\t\tvoltage_table->entries[i] = voltage_table->entries[i + diff];\n\n\tvoltage_table->count = MAX_NO_VREG_STEPS;\n}\n\nint cypress_construct_voltage_tables(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tint ret;\n\n\tret = radeon_atom_get_voltage_table(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0,\n\t\t\t\t\t    &eg_pi->vddc_voltage_table);\n\tif (ret)\n\t\treturn ret;\n\n\tif (eg_pi->vddc_voltage_table.count > MAX_NO_VREG_STEPS)\n\t\tcypress_trim_voltage_table_to_fit_state_table(rdev,\n\t\t\t\t\t\t\t      &eg_pi->vddc_voltage_table);\n\n\tif (eg_pi->vddci_control) {\n\t\tret = radeon_atom_get_voltage_table(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0,\n\t\t\t\t\t\t    &eg_pi->vddci_voltage_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (eg_pi->vddci_voltage_table.count > MAX_NO_VREG_STEPS)\n\t\t\tcypress_trim_voltage_table_to_fit_state_table(rdev,\n\t\t\t\t\t\t\t\t      &eg_pi->vddci_voltage_table);\n\t}\n\n\treturn 0;\n}\n\nstatic void cypress_populate_smc_voltage_table(struct radeon_device *rdev,\n\t\t\t\t\t       struct atom_voltage_table *voltage_table,\n\t\t\t\t\t       RV770_SMC_STATETABLE *table)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < voltage_table->count; i++) {\n\t\ttable->highSMIO[i] = 0;\n\t\ttable->lowSMIO[i] |= cpu_to_be32(voltage_table->entries[i].smio_low);\n\t}\n}\n\nint cypress_populate_smc_voltage_tables(struct radeon_device *rdev,\n\t\t\t\t\tRV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tunsigned char i;\n\n\tif (eg_pi->vddc_voltage_table.count) {\n\t\tcypress_populate_smc_voltage_table(rdev,\n\t\t\t\t\t\t   &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\t   table);\n\n\t\ttable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_VDDC] = 0;\n\t\ttable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_VDDC] =\n\t\t\tcpu_to_be32(eg_pi->vddc_voltage_table.mask_low);\n\n\t\tfor (i = 0; i < eg_pi->vddc_voltage_table.count; i++) {\n\t\t\tif (pi->max_vddc_in_table <=\n\t\t\t    eg_pi->vddc_voltage_table.entries[i].value) {\n\t\t\t\ttable->maxVDDCIndexInPPTable = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (eg_pi->vddci_voltage_table.count) {\n\t\tcypress_populate_smc_voltage_table(rdev,\n\t\t\t\t\t\t   &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\t   table);\n\n\t\ttable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_VDDCI] = 0;\n\t\ttable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_VDDCI] =\n\t\t\tcpu_to_be32(eg_pi->vddci_voltage_table.mask_low);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 cypress_get_mclk_split_point(struct atom_memory_info *memory_info)\n{\n\tif ((memory_info->mem_type == MEM_TYPE_GDDR3) ||\n\t    (memory_info->mem_type == MEM_TYPE_DDR3))\n\t\treturn 30000;\n\n\treturn 0;\n}\n\nint cypress_get_mvdd_configuration(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu8 module_index;\n\tstruct atom_memory_info memory_info;\n\tu32 tmp = RREG32(GENERAL_PWRMGT);\n\n\tif (!(tmp & BACKBIAS_PAD_EN)) {\n\t\teg_pi->mvdd_high_index = 0;\n\t\teg_pi->mvdd_low_index = 1;\n\t\tpi->mvdd_control = false;\n\t\treturn 0;\n\t}\n\n\tif (tmp & BACKBIAS_VALUE)\n\t\teg_pi->mvdd_high_index = 1;\n\telse\n\t\teg_pi->mvdd_high_index = 0;\n\n\teg_pi->mvdd_low_index =\n\t\t(eg_pi->mvdd_high_index == 0) ? 1 : 0;\n\n\tmodule_index = rv770_get_memory_module_index(rdev);\n\n\tif (radeon_atom_get_memory_info(rdev, module_index, &memory_info)) {\n\t\tpi->mvdd_control = false;\n\t\treturn 0;\n\t}\n\n\tpi->mvdd_split_frequency =\n\t\tcypress_get_mclk_split_point(&memory_info);\n\n\tif (pi->mvdd_split_frequency == 0) {\n\t\tpi->mvdd_control = false;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int cypress_init_smc_table(struct radeon_device *rdev,\n\t\t\t\t  struct radeon_ps *radeon_boot_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tRV770_SMC_STATETABLE *table = &pi->smc_statetable;\n\tint ret;\n\n\tmemset(table, 0, sizeof(RV770_SMC_STATETABLE));\n\n\tcypress_populate_smc_voltage_tables(rdev, table);\n\n\tswitch (rdev->pm.int_thermal_type) {\n\tcase THERMAL_TYPE_EVERGREEN:\n\tcase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\n\t\tbreak;\n\tcase THERMAL_TYPE_NONE:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\n\t\tbreak;\n\tdefault:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT;\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\n\n\tif (pi->mem_gddr5)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\n\n\tret = cypress_populate_smc_initial_state(rdev, radeon_boot_state, table);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cypress_populate_smc_acpi_state(rdev, table);\n\tif (ret)\n\t\treturn ret;\n\n\ttable->driverState = table->initialState;\n\n\treturn rv770_copy_bytes_to_smc(rdev,\n\t\t\t\t       pi->state_table_start,\n\t\t\t\t       (u8 *)table, sizeof(RV770_SMC_STATETABLE),\n\t\t\t\t       pi->sram_end);\n}\n\nint cypress_populate_mc_reg_table(struct radeon_device *rdev,\n\t\t\t\t  struct radeon_ps *radeon_boot_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\n\tSMC_Evergreen_MCRegisters mc_reg_table = { 0 };\n\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_seq_index, 1);\n\n\tcypress_populate_mc_reg_addresses(rdev, &mc_reg_table);\n\n\tcypress_convert_mc_reg_table_entry_to_smc(rdev,\n\t\t\t\t\t\t  &boot_state->low,\n\t\t\t\t\t\t  &mc_reg_table.data[0]);\n\n\tcypress_convert_mc_registers(&eg_pi->mc_reg_table.mc_reg_table_entry[0],\n\t\t\t\t     &mc_reg_table.data[1], eg_pi->mc_reg_table.last,\n\t\t\t\t     eg_pi->mc_reg_table.valid_flag);\n\n\tcypress_convert_mc_reg_table_to_smc(rdev, radeon_boot_state, &mc_reg_table);\n\n\treturn rv770_copy_bytes_to_smc(rdev, eg_pi->mc_reg_table_start,\n\t\t\t\t       (u8 *)&mc_reg_table, sizeof(SMC_Evergreen_MCRegisters),\n\t\t\t\t       pi->sram_end);\n}\n\nint cypress_get_table_locations(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tu32 tmp;\n\tint ret;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tEVERGREEN_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tEVERGREEN_SMC_FIRMWARE_HEADER_stateTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->state_table_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tEVERGREEN_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tEVERGREEN_SMC_FIRMWARE_HEADER_softRegisters,\n\t\t\t\t\t&tmp, pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->soft_regs_start = (u16)tmp;\n\n\tret = rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\tEVERGREEN_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\tEVERGREEN_SMC_FIRMWARE_HEADER_mcRegisterTable,\n\t\t\t\t\t&tmp, pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\teg_pi->mc_reg_table_start = (u16)tmp;\n\n\treturn 0;\n}\n\nvoid cypress_enable_display_gap(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\n\n\ttmp &= ~(DISP1_GAP_MASK | DISP2_GAP_MASK);\n\ttmp |= (DISP1_GAP(R600_PM_DISPLAY_GAP_IGNORE) |\n\t\tDISP2_GAP(R600_PM_DISPLAY_GAP_IGNORE));\n\n\ttmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\n\ttmp |= (DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK) |\n\t\tDISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE));\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n}\n\nstatic void cypress_program_display_gap(struct radeon_device *rdev)\n{\n\tu32 tmp, pipe;\n\tint i;\n\n\ttmp = RREG32(CG_DISPLAY_GAP_CNTL) & ~(DISP1_GAP_MASK | DISP2_GAP_MASK);\n\tif (rdev->pm.dpm.new_active_crtc_count > 0)\n\t\ttmp |= DISP1_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\n\telse\n\t\ttmp |= DISP1_GAP(R600_PM_DISPLAY_GAP_IGNORE);\n\n\tif (rdev->pm.dpm.new_active_crtc_count > 1)\n\t\ttmp |= DISP2_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\n\telse\n\t\ttmp |= DISP2_GAP(R600_PM_DISPLAY_GAP_IGNORE);\n\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n\n\ttmp = RREG32(DCCG_DISP_SLOW_SELECT_REG);\n\tpipe = (tmp & DCCG_DISP1_SLOW_SELECT_MASK) >> DCCG_DISP1_SLOW_SELECT_SHIFT;\n\n\tif ((rdev->pm.dpm.new_active_crtc_count > 0) &&\n\t    (!(rdev->pm.dpm.new_active_crtcs & (1 << pipe)))) {\n\t\t \n\t\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\t\tif (rdev->pm.dpm.new_active_crtcs & (1 << i))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == rdev->num_crtc)\n\t\t\tpipe = 0;\n\t\telse\n\t\t\tpipe = i;\n\n\t\ttmp &= ~DCCG_DISP1_SLOW_SELECT_MASK;\n\t\ttmp |= DCCG_DISP1_SLOW_SELECT(pipe);\n\t\tWREG32(DCCG_DISP_SLOW_SELECT_REG, tmp);\n\t}\n\n\tcypress_notify_smc_display_change(rdev, rdev->pm.dpm.new_active_crtc_count > 0);\n}\n\nvoid cypress_dpm_setup_asic(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\n\trv740_read_clock_registers(rdev);\n\trv770_read_voltage_smio_registers(rdev);\n\trv770_get_max_vddc(rdev);\n\trv770_get_memory_type(rdev);\n\n\tif (eg_pi->pcie_performance_request)\n\t\teg_pi->pcie_performance_request_registered = false;\n\n\tif (eg_pi->pcie_performance_request)\n\t\tcypress_advertise_gen2_capability(rdev);\n\n\trv770_get_pcie_gen2_status(rdev);\n\n\trv770_enable_acpi_pm(rdev);\n}\n\nint cypress_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\tint ret;\n\n\tif (pi->gfx_clock_gating)\n\t\trv770_restore_cgcg(rdev);\n\n\tif (rv770_dpm_enabled(rdev))\n\t\treturn -EINVAL;\n\n\tif (pi->voltage_control) {\n\t\trv770_enable_voltage_control(rdev, true);\n\t\tret = cypress_construct_voltage_tables(rdev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"cypress_construct_voltage_tables failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pi->mvdd_control) {\n\t\tret = cypress_get_mvdd_configuration(rdev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"cypress_get_mvdd_configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tcypress_set_mc_reg_address_table(rdev);\n\t\tcypress_force_mc_use_s0(rdev, boot_ps);\n\t\tret = cypress_initialize_mc_reg_table(rdev);\n\t\tif (ret)\n\t\t\teg_pi->dynamic_ac_timing = false;\n\t\tcypress_force_mc_use_s1(rdev, boot_ps);\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv770_enable_backbias(rdev, true);\n\n\tif (pi->dynamic_ss)\n\t\tcypress_enable_spread_spectrum(rdev, true);\n\n\tif (pi->thermal_protection)\n\t\trv770_enable_thermal_protection(rdev, true);\n\n\trv770_setup_bsp(rdev);\n\trv770_program_git(rdev);\n\trv770_program_tp(rdev);\n\trv770_program_tpp(rdev);\n\trv770_program_sstp(rdev);\n\trv770_program_engine_speed_parameters(rdev);\n\tcypress_enable_display_gap(rdev);\n\trv770_program_vc(rdev);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\tcypress_enable_dynamic_pcie_gen2(rdev, true);\n\n\tret = rv770_upload_firmware(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_upload_firmware failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = cypress_get_table_locations(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"cypress_get_table_locations failed\\n\");\n\t\treturn ret;\n\t}\n\tret = cypress_init_smc_table(rdev, boot_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"cypress_init_smc_table failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = cypress_populate_mc_reg_table(rdev, boot_ps);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"cypress_populate_mc_reg_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcypress_program_response_times(rdev);\n\n\tr7xx_start_smc(rdev);\n\n\tret = cypress_notify_smc_display_change(rdev, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"cypress_notify_smc_display_change failed\\n\");\n\t\treturn ret;\n\t}\n\tcypress_enable_sclk_control(rdev, true);\n\n\tif (eg_pi->memory_transition)\n\t\tcypress_enable_mclk_control(rdev, true);\n\n\tcypress_start_dpm(rdev);\n\n\tif (pi->gfx_clock_gating)\n\t\tcypress_gfx_clock_gating_enable(rdev, true);\n\n\tif (pi->mg_clock_gating)\n\t\tcypress_mg_clock_gating_enable(rdev, true);\n\n\trv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\n\n\treturn 0;\n}\n\nvoid cypress_dpm_disable(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\n\tif (!rv770_dpm_enabled(rdev))\n\t\treturn;\n\n\trv770_clear_vc(rdev);\n\n\tif (pi->thermal_protection)\n\t\trv770_enable_thermal_protection(rdev, false);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\tcypress_enable_dynamic_pcie_gen2(rdev, false);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\tif (pi->gfx_clock_gating)\n\t\tcypress_gfx_clock_gating_enable(rdev, false);\n\n\tif (pi->mg_clock_gating)\n\t\tcypress_mg_clock_gating_enable(rdev, false);\n\n\trv770_stop_dpm(rdev);\n\tr7xx_stop_smc(rdev);\n\n\tcypress_enable_spread_spectrum(rdev, false);\n\n\tif (eg_pi->dynamic_ac_timing)\n\t\tcypress_force_mc_use_s1(rdev, boot_ps);\n\n\trv770_reset_smio_status(rdev);\n}\n\nint cypress_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\n\tint ret;\n\n\tret = rv770_restrict_performance_levels_before_switch(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_restrict_performance_levels_before_switch failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->pcie_performance_request)\n\t\tcypress_notify_link_speed_change_before_state_change(rdev, new_ps, old_ps);\n\n\trv770_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\tret = rv770_halt_smc(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_halt_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = cypress_upload_sw_state(rdev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"cypress_upload_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = cypress_upload_mc_reg_table(rdev, new_ps);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"cypress_upload_mc_reg_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcypress_program_memory_timing_parameters(rdev, new_ps);\n\n\tret = rv770_resume_smc(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_resume_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_set_sw_state(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_set_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\trv770_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\n\tif (eg_pi->pcie_performance_request)\n\t\tcypress_notify_link_speed_change_after_state_change(rdev, new_ps, old_ps);\n\n\treturn 0;\n}\n\n#if 0\nvoid cypress_dpm_reset_asic(struct radeon_device *rdev)\n{\n\trv770_restrict_performance_levels_before_switch(rdev);\n\trv770_set_boot_state(rdev);\n}\n#endif\n\nvoid cypress_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\tcypress_program_display_gap(rdev);\n}\n\nint cypress_dpm_init(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi;\n\tstruct evergreen_power_info *eg_pi;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\teg_pi = kzalloc(sizeof(struct evergreen_power_info), GFP_KERNEL);\n\tif (eg_pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = eg_pi;\n\tpi = &eg_pi->rv7xx;\n\n\trv770_get_max_vddc(rdev);\n\n\teg_pi->ulv.supported = false;\n\tpi->acpi_vddc = 0;\n\teg_pi->acpi_vddci = 0;\n\tpi->min_vddc_in_table = 0;\n\tpi->max_vddc_in_table = 0;\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv7xx_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->pm.dpm.voltage_response_time == 0)\n\t\trdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\n\tif (rdev->pm.dpm.backbias_response_time == 0)\n\t\trdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     0, false, &dividers);\n\tif (ret)\n\t\tpi->ref_div = dividers.ref_div + 1;\n\telse\n\t\tpi->ref_div = R600_REFERENCEDIVIDER_DFLT;\n\n\tpi->mclk_strobe_mode_threshold = 40000;\n\tpi->mclk_edc_enable_threshold = 40000;\n\teg_pi->mclk_edc_wr_enable_threshold = 40000;\n\n\tpi->rlp = RV770_RLP_DFLT;\n\tpi->rmp = RV770_RMP_DFLT;\n\tpi->lhp = RV770_LHP_DFLT;\n\tpi->lmp = RV770_LMP_DFLT;\n\n\tpi->voltage_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\n\n\tpi->mvdd_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);\n\n\teg_pi->vddci_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDCI, 0);\n\n\trv770_get_engine_memory_ss(rdev);\n\n\tpi->asi = RV770_ASI_DFLT;\n\tpi->pasi = CYPRESS_HASI_DFLT;\n\tpi->vrc = CYPRESS_VRC_DFLT;\n\n\tpi->power_gating = false;\n\n\tif ((rdev->family == CHIP_CYPRESS) ||\n\t    (rdev->family == CHIP_HEMLOCK))\n\t\tpi->gfx_clock_gating = false;\n\telse\n\t\tpi->gfx_clock_gating = true;\n\n\tpi->mg_clock_gating = true;\n\tpi->mgcgtssm = true;\n\teg_pi->ls_clock_gating = false;\n\teg_pi->sclk_deep_sleep = false;\n\n\tpi->dynamic_pcie_gen2 = true;\n\n\tif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\n\t\tpi->thermal_protection = true;\n\telse\n\t\tpi->thermal_protection = false;\n\n\tpi->display_gap = true;\n\n\tif (rdev->flags & RADEON_IS_MOBILITY)\n\t\tpi->dcodt = true;\n\telse\n\t\tpi->dcodt = false;\n\n\tpi->ulps = true;\n\n\teg_pi->dynamic_ac_timing = true;\n\teg_pi->abm = true;\n\teg_pi->mcls = true;\n\teg_pi->light_sleep = true;\n\teg_pi->memory_transition = true;\n#if defined(CONFIG_ACPI)\n\teg_pi->pcie_performance_request =\n\t\tradeon_acpi_is_pcie_performance_request_supported(rdev);\n#else\n\teg_pi->pcie_performance_request = false;\n#endif\n\n\tif ((rdev->family == CHIP_CYPRESS) ||\n\t    (rdev->family == CHIP_HEMLOCK) ||\n\t    (rdev->family == CHIP_JUNIPER))\n\t\teg_pi->dll_default_on = true;\n\telse\n\t\teg_pi->dll_default_on = false;\n\n\teg_pi->sclk_deep_sleep = false;\n\tpi->mclk_stutter_mode_threshold = 0;\n\n\tpi->sram_end = SMC_RAM_END;\n\n\treturn 0;\n}\n\nvoid cypress_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n}\n\nbool cypress_dpm_vblank_too_short(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 vblank_time = r600_dpm_get_vblank_time(rdev);\n\t \n\tu32 switch_limit = pi->mem_gddr5 ? 450 : 0;\n\n\tif (vblank_time < switch_limit)\n\t\treturn true;\n\telse\n\t\treturn false;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}