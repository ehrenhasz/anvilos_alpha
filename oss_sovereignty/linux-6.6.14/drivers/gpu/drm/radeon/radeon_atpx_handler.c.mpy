{
  "module_name": "radeon_atpx_handler.c",
  "hash_id": "27e6f088746d111ce18816d289feef4f48f66112f88b7cd2866941333ad05a56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_atpx_handler.c",
  "human_readable_source": "\n \n#include <linux/vga_switcheroo.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include \"radeon_acpi.h\"\n\nstruct radeon_atpx_functions {\n\tbool px_params;\n\tbool power_cntl;\n\tbool disp_mux_cntl;\n\tbool i2c_mux_cntl;\n\tbool switch_start;\n\tbool switch_end;\n\tbool disp_connectors_mapping;\n\tbool disp_detetion_ports;\n};\n\nstruct radeon_atpx {\n\tacpi_handle handle;\n\tstruct radeon_atpx_functions functions;\n\tbool is_hybrid;\n\tbool dgpu_req_power_for_displays;\n};\n\nstatic struct radeon_atpx_priv {\n\tbool atpx_detected;\n\tbool bridge_pm_usable;\n\t \n\tacpi_handle dhandle;\n\tstruct radeon_atpx atpx;\n} radeon_atpx_priv;\n\nstruct atpx_verify_interface {\n\tu16 size;\t\t \n\tu16 version;\t\t \n\tu32 function_bits;\t \n} __packed;\n\nstruct atpx_px_params {\n\tu16 size;\t\t \n\tu32 valid_flags;\t \n\tu32 flags;\t\t \n} __packed;\n\nstruct atpx_power_control {\n\tu16 size;\n\tu8 dgpu_state;\n} __packed;\n\nstruct atpx_mux {\n\tu16 size;\n\tu16 mux;\n} __packed;\n\nbool radeon_has_atpx(void) {\n\treturn radeon_atpx_priv.atpx_detected;\n}\n\nbool radeon_has_atpx_dgpu_power_cntl(void) {\n\treturn radeon_atpx_priv.atpx.functions.power_cntl;\n}\n\nbool radeon_is_atpx_hybrid(void) {\n\treturn radeon_atpx_priv.atpx.is_hybrid;\n}\n\nbool radeon_atpx_dgpu_req_power_for_displays(void) {\n\treturn radeon_atpx_priv.atpx.dgpu_req_power_for_displays;\n}\n\n \nstatic union acpi_object *radeon_atpx_call(acpi_handle handle, int function,\n\t\t\t\t\t   struct acpi_buffer *params)\n{\n\tacpi_status status;\n\tunion acpi_object atpx_arg_elements[2];\n\tstruct acpi_object_list atpx_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tatpx_arg.count = 2;\n\tatpx_arg.pointer = &atpx_arg_elements[0];\n\n\tatpx_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatpx_arg_elements[0].integer.value = function;\n\n\tif (params) {\n\t\tatpx_arg_elements[1].type = ACPI_TYPE_BUFFER;\n\t\tatpx_arg_elements[1].buffer.length = params->length;\n\t\tatpx_arg_elements[1].buffer.pointer = params->pointer;\n\t} else {\n\t\t \n\t\tatpx_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\t\tatpx_arg_elements[1].integer.value = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, NULL, &atpx_arg, &buffer);\n\n\t \n\tif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\n\t\tpr_err(\"failed to evaluate ATPX got %s\\n\",\n\t\t       acpi_format_exception(status));\n\t\tkfree(buffer.pointer);\n\t\treturn NULL;\n\t}\n\n\treturn buffer.pointer;\n}\n\n \nstatic void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mask)\n{\n\tf->px_params = mask & ATPX_GET_PX_PARAMETERS_SUPPORTED;\n\tf->power_cntl = mask & ATPX_POWER_CONTROL_SUPPORTED;\n\tf->disp_mux_cntl = mask & ATPX_DISPLAY_MUX_CONTROL_SUPPORTED;\n\tf->i2c_mux_cntl = mask & ATPX_I2C_MUX_CONTROL_SUPPORTED;\n\tf->switch_start = mask & ATPX_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION_SUPPORTED;\n\tf->switch_end = mask & ATPX_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION_SUPPORTED;\n\tf->disp_connectors_mapping = mask & ATPX_GET_DISPLAY_CONNECTORS_MAPPING_SUPPORTED;\n\tf->disp_detetion_ports = mask & ATPX_GET_DISPLAY_DETECTION_PORTS_SUPPORTED;\n}\n\n \nstatic int radeon_atpx_validate(struct radeon_atpx *atpx)\n{\n\tu32 valid_bits = 0;\n\n\tif (atpx->functions.px_params) {\n\t\tunion acpi_object *info;\n\t\tstruct atpx_px_params output;\n\t\tsize_t size;\n\n\t\tinfo = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_GET_PX_PARAMETERS, NULL);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\n\t\tmemset(&output, 0, sizeof(output));\n\n\t\tsize = *(u16 *) info->buffer.pointer;\n\t\tif (size < 10) {\n\t\t\tpr_err(\"ATPX buffer is too small: %zu\\n\", size);\n\t\t\tkfree(info);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = min(sizeof(output), size);\n\n\t\tmemcpy(&output, info->buffer.pointer, size);\n\n\t\tvalid_bits = output.flags & output.valid_flags;\n\n\t\tkfree(info);\n\t}\n\n\t \n\tif (valid_bits & ATPX_SEPARATE_MUX_FOR_I2C) {\n\t\tatpx->functions.i2c_mux_cntl = true;\n\t\tatpx->functions.disp_mux_cntl = true;\n\t}\n\t \n\tif (valid_bits & (ATPX_CRT1_RGB_SIGNAL_MUXED |\n\t\t\t  ATPX_TV_SIGNAL_MUXED |\n\t\t\t  ATPX_DFP_SIGNAL_MUXED))\n\t\tatpx->functions.disp_mux_cntl = true;\n\n\t \n\tif (valid_bits & (ATPX_DYNAMIC_PX_SUPPORTED |\n\t\t\t  ATPX_DYNAMIC_DGPU_POWER_OFF_SUPPORTED))\n\t\tatpx->functions.power_cntl = true;\n\n\tatpx->is_hybrid = false;\n\tif (valid_bits & ATPX_MS_HYBRID_GFX_SUPPORTED) {\n\t\tpr_info(\"ATPX Hybrid Graphics\\n\");\n\t\t \n\t\tatpx->functions.power_cntl = !radeon_atpx_priv.bridge_pm_usable;\n\t\tatpx->is_hybrid = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_verify_interface(struct radeon_atpx *atpx)\n{\n\tunion acpi_object *info;\n\tstruct atpx_verify_interface output;\n\tsize_t size;\n\tint err = 0;\n\n\tinfo = radeon_atpx_call(atpx->handle, ATPX_FUNCTION_VERIFY_INTERFACE, NULL);\n\tif (!info)\n\t\treturn -EIO;\n\n\tmemset(&output, 0, sizeof(output));\n\n\tsize = *(u16 *) info->buffer.pointer;\n\tif (size < 8) {\n\t\tpr_err(\"ATPX buffer is too small: %zu\\n\", size);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tsize = min(sizeof(output), size);\n\n\tmemcpy(&output, info->buffer.pointer, size);\n\n\t \n\tpr_info(\"ATPX version %u, functions 0x%08x\\n\",\n\t\toutput.version, output.function_bits);\n\n\tradeon_atpx_parse_functions(&atpx->functions, output.function_bits);\n\nout:\n\tkfree(info);\n\treturn err;\n}\n\n \nstatic int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_power_control input;\n\n\tif (atpx->functions.power_cntl) {\n\t\tinput.size = 3;\n\t\tinput.dgpu_state = state;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = radeon_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_POWER_CONTROL,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\n\t\t \n\t\tif (state == 0)\n\t\t\tmsleep(200);\n\t}\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_switch_disp_mux(struct radeon_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.disp_mux_cntl) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = radeon_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_DISPLAY_MUX_CONTROL,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_switch_i2c_mux(struct radeon_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.i2c_mux_cntl) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = radeon_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_I2C_MUX_CONTROL,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_switch_start(struct radeon_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.switch_start) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = radeon_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_START_NOTIFICATION,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_switch_end(struct radeon_atpx *atpx, u16 mux_id)\n{\n\tstruct acpi_buffer params;\n\tunion acpi_object *info;\n\tstruct atpx_mux input;\n\n\tif (atpx->functions.switch_end) {\n\t\tinput.size = 4;\n\t\tinput.mux = mux_id;\n\t\tparams.length = input.size;\n\t\tparams.pointer = &input;\n\t\tinfo = radeon_atpx_call(atpx->handle,\n\t\t\t\t\tATPX_FUNCTION_GRAPHICS_DEVICE_SWITCH_END_NOTIFICATION,\n\t\t\t\t\t&params);\n\t\tif (!info)\n\t\t\treturn -EIO;\n\t\tkfree(info);\n\t}\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_switchto(enum vga_switcheroo_client_id id)\n{\n\tu16 gpu_id;\n\n\tif (id == VGA_SWITCHEROO_IGD)\n\t\tgpu_id = ATPX_INTEGRATED_GPU;\n\telse\n\t\tgpu_id = ATPX_DISCRETE_GPU;\n\n\tradeon_atpx_switch_start(&radeon_atpx_priv.atpx, gpu_id);\n\tradeon_atpx_switch_disp_mux(&radeon_atpx_priv.atpx, gpu_id);\n\tradeon_atpx_switch_i2c_mux(&radeon_atpx_priv.atpx, gpu_id);\n\tradeon_atpx_switch_end(&radeon_atpx_priv.atpx, gpu_id);\n\n\treturn 0;\n}\n\n \nstatic int radeon_atpx_power_state(enum vga_switcheroo_client_id id,\n\t\t\t\t   enum vga_switcheroo_state state)\n{\n\t \n\tif (id == VGA_SWITCHEROO_IGD)\n\t\treturn 0;\n\n\tradeon_atpx_set_discrete_state(&radeon_atpx_priv.atpx, state);\n\treturn 0;\n}\n\n \nstatic bool radeon_atpx_pci_probe_handle(struct pci_dev *pdev)\n{\n\tacpi_handle dhandle, atpx_handle;\n\tacpi_status status;\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn false;\n\n\tstatus = acpi_get_handle(dhandle, \"ATPX\", &atpx_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tradeon_atpx_priv.dhandle = dhandle;\n\tradeon_atpx_priv.atpx.handle = atpx_handle;\n\treturn true;\n}\n\n \nstatic int radeon_atpx_init(void)\n{\n\tint r;\n\n\t \n\tr = radeon_atpx_verify_interface(&radeon_atpx_priv.atpx);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = radeon_atpx_validate(&radeon_atpx_priv.atpx);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nstatic enum vga_switcheroo_client_id radeon_atpx_get_client_id(struct pci_dev *pdev)\n{\n\tif (radeon_atpx_priv.dhandle == ACPI_HANDLE(&pdev->dev))\n\t\treturn VGA_SWITCHEROO_IGD;\n\telse\n\t\treturn VGA_SWITCHEROO_DIS;\n}\n\nstatic const struct vga_switcheroo_handler radeon_atpx_handler = {\n\t.switchto = radeon_atpx_switchto,\n\t.power_state = radeon_atpx_power_state,\n\t.get_client_id = radeon_atpx_get_client_id,\n};\n\n \nstatic bool radeon_atpx_detect(void)\n{\n\tchar acpi_method_name[255] = { 0 };\n\tstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\n\tstruct pci_dev *pdev = NULL;\n\tbool has_atpx = false;\n\tint vga_count = 0;\n\tbool d3_supported = false;\n\tstruct pci_dev *parent_pdev;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\n\t\thas_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);\n\n\t\tparent_pdev = pci_upstream_bridge(pdev);\n\t\td3_supported |= parent_pdev && parent_pdev->bridge_d3;\n\t}\n\n\t \n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\n\t\thas_atpx |= (radeon_atpx_pci_probe_handle(pdev) == true);\n\n\t\tparent_pdev = pci_upstream_bridge(pdev);\n\t\td3_supported |= parent_pdev && parent_pdev->bridge_d3;\n\t}\n\n\tif (has_atpx && vga_count == 2) {\n\t\tacpi_get_name(radeon_atpx_priv.atpx.handle, ACPI_FULL_PATHNAME, &buffer);\n\t\tpr_info(\"vga_switcheroo: detected switching method %s handle\\n\",\n\t\t\tacpi_method_name);\n\t\tradeon_atpx_priv.atpx_detected = true;\n\t\tradeon_atpx_priv.bridge_pm_usable = d3_supported;\n\t\tradeon_atpx_init();\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nvoid radeon_register_atpx_handler(void)\n{\n\tbool r;\n\tenum vga_switcheroo_handler_flags_t handler_flags = 0;\n\n\t \n\tr = radeon_atpx_detect();\n\tif (!r)\n\t\treturn;\n\n\tvga_switcheroo_register_handler(&radeon_atpx_handler, handler_flags);\n}\n\n \nvoid radeon_unregister_atpx_handler(void)\n{\n\tvga_switcheroo_unregister_handler();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}