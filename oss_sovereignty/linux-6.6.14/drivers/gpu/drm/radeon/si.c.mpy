{
  "module_name": "si.c",
  "hash_id": "faecff883ef67175ae24ca6fe0e10507a4eb3d8a52dcf8ce3a1c2c7c357a176a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/si.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"atom.h\"\n#include \"clearstate_si.h\"\n#include \"evergreen.h\"\n#include \"r600.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"radeon_ucode.h\"\n#include \"si_blit_shaders.h\"\n#include \"si.h\"\n#include \"sid.h\"\n\n\nMODULE_FIRMWARE(\"radeon/TAHITI_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/TAHITI_me.bin\");\nMODULE_FIRMWARE(\"radeon/TAHITI_ce.bin\");\nMODULE_FIRMWARE(\"radeon/TAHITI_mc.bin\");\nMODULE_FIRMWARE(\"radeon/TAHITI_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/TAHITI_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/TAHITI_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/tahiti_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/tahiti_me.bin\");\nMODULE_FIRMWARE(\"radeon/tahiti_ce.bin\");\nMODULE_FIRMWARE(\"radeon/tahiti_mc.bin\");\nMODULE_FIRMWARE(\"radeon/tahiti_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/tahiti_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/PITCAIRN_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/PITCAIRN_me.bin\");\nMODULE_FIRMWARE(\"radeon/PITCAIRN_ce.bin\");\nMODULE_FIRMWARE(\"radeon/PITCAIRN_mc.bin\");\nMODULE_FIRMWARE(\"radeon/PITCAIRN_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/PITCAIRN_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/PITCAIRN_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/pitcairn_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/pitcairn_me.bin\");\nMODULE_FIRMWARE(\"radeon/pitcairn_ce.bin\");\nMODULE_FIRMWARE(\"radeon/pitcairn_mc.bin\");\nMODULE_FIRMWARE(\"radeon/pitcairn_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/pitcairn_smc.bin\");\nMODULE_FIRMWARE(\"radeon/pitcairn_k_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/VERDE_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/VERDE_me.bin\");\nMODULE_FIRMWARE(\"radeon/VERDE_ce.bin\");\nMODULE_FIRMWARE(\"radeon/VERDE_mc.bin\");\nMODULE_FIRMWARE(\"radeon/VERDE_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/VERDE_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/VERDE_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/verde_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/verde_me.bin\");\nMODULE_FIRMWARE(\"radeon/verde_ce.bin\");\nMODULE_FIRMWARE(\"radeon/verde_mc.bin\");\nMODULE_FIRMWARE(\"radeon/verde_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/verde_smc.bin\");\nMODULE_FIRMWARE(\"radeon/verde_k_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/OLAND_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/OLAND_me.bin\");\nMODULE_FIRMWARE(\"radeon/OLAND_ce.bin\");\nMODULE_FIRMWARE(\"radeon/OLAND_mc.bin\");\nMODULE_FIRMWARE(\"radeon/OLAND_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/OLAND_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/OLAND_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/oland_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/oland_me.bin\");\nMODULE_FIRMWARE(\"radeon/oland_ce.bin\");\nMODULE_FIRMWARE(\"radeon/oland_mc.bin\");\nMODULE_FIRMWARE(\"radeon/oland_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/oland_smc.bin\");\nMODULE_FIRMWARE(\"radeon/oland_k_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/HAINAN_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/HAINAN_me.bin\");\nMODULE_FIRMWARE(\"radeon/HAINAN_ce.bin\");\nMODULE_FIRMWARE(\"radeon/HAINAN_mc.bin\");\nMODULE_FIRMWARE(\"radeon/HAINAN_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/HAINAN_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/HAINAN_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/hainan_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/hainan_me.bin\");\nMODULE_FIRMWARE(\"radeon/hainan_ce.bin\");\nMODULE_FIRMWARE(\"radeon/hainan_mc.bin\");\nMODULE_FIRMWARE(\"radeon/hainan_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/hainan_smc.bin\");\nMODULE_FIRMWARE(\"radeon/hainan_k_smc.bin\");\nMODULE_FIRMWARE(\"radeon/banks_k_2_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/si58_mc.bin\");\n\nstatic u32 si_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh);\nstatic void si_pcie_gen3_enable(struct radeon_device *rdev);\nstatic void si_program_aspm(struct radeon_device *rdev);\nextern void sumo_rlc_fini(struct radeon_device *rdev);\nextern int sumo_rlc_init(struct radeon_device *rdev);\nstatic void si_enable_gui_idle_interrupt(struct radeon_device *rdev,\n\t\t\t\t\t bool enable);\nstatic void si_init_pg(struct radeon_device *rdev);\nstatic void si_init_cg(struct radeon_device *rdev);\nstatic void si_fini_pg(struct radeon_device *rdev);\nstatic void si_fini_cg(struct radeon_device *rdev);\nstatic void si_rlc_stop(struct radeon_device *rdev);\n\nstatic const u32 crtc_offsets[] =\n{\n\tEVERGREEN_CRTC0_REGISTER_OFFSET,\n\tEVERGREEN_CRTC1_REGISTER_OFFSET,\n\tEVERGREEN_CRTC2_REGISTER_OFFSET,\n\tEVERGREEN_CRTC3_REGISTER_OFFSET,\n\tEVERGREEN_CRTC4_REGISTER_OFFSET,\n\tEVERGREEN_CRTC5_REGISTER_OFFSET\n};\n\nstatic const u32 si_disp_int_status[] =\n{\n\tDISP_INTERRUPT_STATUS,\n\tDISP_INTERRUPT_STATUS_CONTINUE,\n\tDISP_INTERRUPT_STATUS_CONTINUE2,\n\tDISP_INTERRUPT_STATUS_CONTINUE3,\n\tDISP_INTERRUPT_STATUS_CONTINUE4,\n\tDISP_INTERRUPT_STATUS_CONTINUE5\n};\n\n#define DC_HPDx_CONTROL(x)        (DC_HPD1_CONTROL     + (x * 0xc))\n#define DC_HPDx_INT_CONTROL(x)    (DC_HPD1_INT_CONTROL + (x * 0xc))\n#define DC_HPDx_INT_STATUS_REG(x) (DC_HPD1_INT_STATUS  + (x * 0xc))\n\nstatic const u32 verde_rlc_save_restore_register_list[] =\n{\n\t(0x8000 << 16) | (0x98f4 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x98f4 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0xe80 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0xe80 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x89bc >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x89bc >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x8c1c >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x8c1c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x98f0 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xe7c >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x9148 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x9148 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9150 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x897c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8d8c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xac54 >> 2),\n\t0X00000000,\n\t0x3,\n\t(0x9c00 << 16) | (0x98f8 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9910 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9914 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9918 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x991c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9920 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9924 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9928 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x992c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9930 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9934 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9938 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x993c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9940 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9944 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9948 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x994c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9950 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9954 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9958 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x995c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9960 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9964 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9968 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x996c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9970 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9974 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9978 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x997c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9980 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9984 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9988 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x998c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8c00 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8c14 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8c04 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8c08 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x9b7c >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x9b7c >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0xe84 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0xe84 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x89c0 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x89c0 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x914c >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x914c >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x8c20 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x8c20 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x9354 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x9354 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9060 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9364 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9100 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x913c >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x90e0 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x90e4 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x90e8 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x90e0 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x90e4 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x90e8 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8bcc >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8b24 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x88c4 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8e50 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8c0c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8e58 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8e5c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9508 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x950c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9494 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xac0c >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xac10 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xac14 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xae00 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0xac08 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x88d4 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x88c8 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x88cc >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x89b0 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8b10 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x8a14 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9830 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9834 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9838 >> 2),\n\t0x00000000,\n\t(0x9c00 << 16) | (0x9a10 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x9870 >> 2),\n\t0x00000000,\n\t(0x8000 << 16) | (0x9874 >> 2),\n\t0x00000000,\n\t(0x8001 << 16) | (0x9870 >> 2),\n\t0x00000000,\n\t(0x8001 << 16) | (0x9874 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x9870 >> 2),\n\t0x00000000,\n\t(0x8040 << 16) | (0x9874 >> 2),\n\t0x00000000,\n\t(0x8041 << 16) | (0x9870 >> 2),\n\t0x00000000,\n\t(0x8041 << 16) | (0x9874 >> 2),\n\t0x00000000,\n\t0x00000000\n};\n\nstatic const u32 tahiti_golden_rlc_registers[] =\n{\n\t0xc424, 0xffffffff, 0x00601005,\n\t0xc47c, 0xffffffff, 0x10104040,\n\t0xc488, 0xffffffff, 0x0100000a,\n\t0xc314, 0xffffffff, 0x00000800,\n\t0xc30c, 0xffffffff, 0x800000f4,\n\t0xf4a8, 0xffffffff, 0x00000000\n};\n\nstatic const u32 tahiti_golden_registers[] =\n{\n\t0x9a10, 0x00010000, 0x00018208,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xc78, 0x00000080, 0x00000000,\n\t0xd030, 0x000300c0, 0x00800040,\n\t0xd830, 0x000300c0, 0x00800040,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x277c, 0x00000003, 0x000007ff,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x4e000000,\n\t0x28350, 0x3f3f3fff, 0x2a00126a,\n\t0x30, 0x000000ff, 0x0040,\n\t0x34, 0x00000040, 0x00004040,\n\t0x9100, 0x07ffffff, 0x03000000,\n\t0x8e88, 0x01ff1f3f, 0x00000000,\n\t0x8e84, 0x01ff1f3f, 0x00000000,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac14, 0x00000200, 0x000002fb,\n\t0xac10, 0xffffffff, 0x0000543b,\n\t0xac0c, 0xffffffff, 0xa9210876,\n\t0x88d0, 0xffffffff, 0x000fff40,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x1410, 0x20000000, 0x20fffed8,\n\t0x15c0, 0x000c0fc0, 0x000c0400\n};\n\nstatic const u32 tahiti_golden_registers2[] =\n{\n\t0xc64, 0x00000001, 0x00000001\n};\n\nstatic const u32 pitcairn_golden_rlc_registers[] =\n{\n\t0xc424, 0xffffffff, 0x00601004,\n\t0xc47c, 0xffffffff, 0x10102020,\n\t0xc488, 0xffffffff, 0x01000020,\n\t0xc314, 0xffffffff, 0x00000800,\n\t0xc30c, 0xffffffff, 0x800000a4\n};\n\nstatic const u32 pitcairn_golden_registers[] =\n{\n\t0x9a10, 0x00010000, 0x00018208,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xc78, 0x00000080, 0x00000000,\n\t0xd030, 0x000300c0, 0x00800040,\n\t0xd830, 0x000300c0, 0x00800040,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x4e000000,\n\t0x28350, 0x3f3f3fff, 0x2a00126a,\n\t0x30, 0x000000ff, 0x0040,\n\t0x34, 0x00000040, 0x00004040,\n\t0x9100, 0x07ffffff, 0x03000000,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac14, 0x000003ff, 0x000000f7,\n\t0xac10, 0xffffffff, 0x00000000,\n\t0xac0c, 0xffffffff, 0x32761054,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x15c0, 0x000c0fc0, 0x000c0400\n};\n\nstatic const u32 verde_golden_rlc_registers[] =\n{\n\t0xc424, 0xffffffff, 0x033f1005,\n\t0xc47c, 0xffffffff, 0x10808020,\n\t0xc488, 0xffffffff, 0x00800008,\n\t0xc314, 0xffffffff, 0x00001000,\n\t0xc30c, 0xffffffff, 0x80010014\n};\n\nstatic const u32 verde_golden_registers[] =\n{\n\t0x9a10, 0x00010000, 0x00018208,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xc78, 0x00000080, 0x00000000,\n\t0xd030, 0x000300c0, 0x00800040,\n\t0xd030, 0x000300c0, 0x00800040,\n\t0xd830, 0x000300c0, 0x00800040,\n\t0xd830, 0x000300c0, 0x00800040,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x4e000000,\n\t0x28350, 0x3f3f3fff, 0x0000124a,\n\t0x28350, 0x3f3f3fff, 0x0000124a,\n\t0x28350, 0x3f3f3fff, 0x0000124a,\n\t0x30, 0x000000ff, 0x0040,\n\t0x34, 0x00000040, 0x00004040,\n\t0x9100, 0x07ffffff, 0x03000000,\n\t0x9100, 0x07ffffff, 0x03000000,\n\t0x8e88, 0x01ff1f3f, 0x00000000,\n\t0x8e88, 0x01ff1f3f, 0x00000000,\n\t0x8e88, 0x01ff1f3f, 0x00000000,\n\t0x8e84, 0x01ff1f3f, 0x00000000,\n\t0x8e84, 0x01ff1f3f, 0x00000000,\n\t0x8e84, 0x01ff1f3f, 0x00000000,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac14, 0x000003ff, 0x00000003,\n\t0xac14, 0x000003ff, 0x00000003,\n\t0xac14, 0x000003ff, 0x00000003,\n\t0xac10, 0xffffffff, 0x00000000,\n\t0xac10, 0xffffffff, 0x00000000,\n\t0xac10, 0xffffffff, 0x00000000,\n\t0xac0c, 0xffffffff, 0x00001032,\n\t0xac0c, 0xffffffff, 0x00001032,\n\t0xac0c, 0xffffffff, 0x00001032,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x15c0, 0x000c0fc0, 0x000c0400\n};\n\nstatic const u32 oland_golden_rlc_registers[] =\n{\n\t0xc424, 0xffffffff, 0x00601005,\n\t0xc47c, 0xffffffff, 0x10104040,\n\t0xc488, 0xffffffff, 0x0100000a,\n\t0xc314, 0xffffffff, 0x00000800,\n\t0xc30c, 0xffffffff, 0x800000f4\n};\n\nstatic const u32 oland_golden_registers[] =\n{\n\t0x9a10, 0x00010000, 0x00018208,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xc78, 0x00000080, 0x00000000,\n\t0xd030, 0x000300c0, 0x00800040,\n\t0xd830, 0x000300c0, 0x00800040,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x4e000000,\n\t0x28350, 0x3f3f3fff, 0x00000082,\n\t0x30, 0x000000ff, 0x0040,\n\t0x34, 0x00000040, 0x00004040,\n\t0x9100, 0x07ffffff, 0x03000000,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac14, 0x000003ff, 0x000000f3,\n\t0xac10, 0xffffffff, 0x00000000,\n\t0xac0c, 0xffffffff, 0x00003210,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x15c0, 0x000c0fc0, 0x000c0400\n};\n\nstatic const u32 hainan_golden_registers[] =\n{\n\t0x9a10, 0x00010000, 0x00018208,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xd0c0, 0xff000fff, 0x00000100,\n\t0xd030, 0x000300c0, 0x00800040,\n\t0xd8c0, 0xff000fff, 0x00000100,\n\t0xd830, 0x000300c0, 0x00800040,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x4e000000,\n\t0x28350, 0x3f3f3fff, 0x00000000,\n\t0x30, 0x000000ff, 0x0040,\n\t0x34, 0x00000040, 0x00004040,\n\t0x9100, 0x03e00000, 0x03600000,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac14, 0x000003ff, 0x000000f1,\n\t0xac10, 0xffffffff, 0x00000000,\n\t0xac0c, 0xffffffff, 0x00003210,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x15c0, 0x000c0fc0, 0x000c0400\n};\n\nstatic const u32 hainan_golden_registers2[] =\n{\n\t0x98f8, 0xffffffff, 0x02010001\n};\n\nstatic const u32 tahiti_mgcg_cgcg_init[] =\n{\n\t0xc400, 0xffffffff, 0xfffffffc,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x92a4, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x9774, 0xffffffff, 0x00000100,\n\t0x8984, 0xffffffff, 0x06000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x92a0, 0xffffffff, 0x00000100,\n\t0xc380, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x8d88, 0xffffffff, 0x00000100,\n\t0x8d8c, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0xad80, 0xffffffff, 0x00000100,\n\t0xac54, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0xaf04, 0xffffffff, 0x00000100,\n\t0xae04, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9160, 0xffffffff, 0x00010000,\n\t0x9164, 0xffffffff, 0x00030002,\n\t0x9168, 0xffffffff, 0x00040007,\n\t0x916c, 0xffffffff, 0x00060005,\n\t0x9170, 0xffffffff, 0x00090008,\n\t0x9174, 0xffffffff, 0x00020001,\n\t0x9178, 0xffffffff, 0x00040003,\n\t0x917c, 0xffffffff, 0x00000007,\n\t0x9180, 0xffffffff, 0x00060005,\n\t0x9184, 0xffffffff, 0x00090008,\n\t0x9188, 0xffffffff, 0x00030002,\n\t0x918c, 0xffffffff, 0x00050004,\n\t0x9190, 0xffffffff, 0x00000008,\n\t0x9194, 0xffffffff, 0x00070006,\n\t0x9198, 0xffffffff, 0x000a0009,\n\t0x919c, 0xffffffff, 0x00040003,\n\t0x91a0, 0xffffffff, 0x00060005,\n\t0x91a4, 0xffffffff, 0x00000009,\n\t0x91a8, 0xffffffff, 0x00080007,\n\t0x91ac, 0xffffffff, 0x000b000a,\n\t0x91b0, 0xffffffff, 0x00050004,\n\t0x91b4, 0xffffffff, 0x00070006,\n\t0x91b8, 0xffffffff, 0x0008000b,\n\t0x91bc, 0xffffffff, 0x000a0009,\n\t0x91c0, 0xffffffff, 0x000d000c,\n\t0x91c4, 0xffffffff, 0x00060005,\n\t0x91c8, 0xffffffff, 0x00080007,\n\t0x91cc, 0xffffffff, 0x0000000b,\n\t0x91d0, 0xffffffff, 0x000a0009,\n\t0x91d4, 0xffffffff, 0x000d000c,\n\t0x91d8, 0xffffffff, 0x00070006,\n\t0x91dc, 0xffffffff, 0x00090008,\n\t0x91e0, 0xffffffff, 0x0000000c,\n\t0x91e4, 0xffffffff, 0x000b000a,\n\t0x91e8, 0xffffffff, 0x000e000d,\n\t0x91ec, 0xffffffff, 0x00080007,\n\t0x91f0, 0xffffffff, 0x000a0009,\n\t0x91f4, 0xffffffff, 0x0000000d,\n\t0x91f8, 0xffffffff, 0x000c000b,\n\t0x91fc, 0xffffffff, 0x000f000e,\n\t0x9200, 0xffffffff, 0x00090008,\n\t0x9204, 0xffffffff, 0x000b000a,\n\t0x9208, 0xffffffff, 0x000c000f,\n\t0x920c, 0xffffffff, 0x000e000d,\n\t0x9210, 0xffffffff, 0x00110010,\n\t0x9214, 0xffffffff, 0x000a0009,\n\t0x9218, 0xffffffff, 0x000c000b,\n\t0x921c, 0xffffffff, 0x0000000f,\n\t0x9220, 0xffffffff, 0x000e000d,\n\t0x9224, 0xffffffff, 0x00110010,\n\t0x9228, 0xffffffff, 0x000b000a,\n\t0x922c, 0xffffffff, 0x000d000c,\n\t0x9230, 0xffffffff, 0x00000010,\n\t0x9234, 0xffffffff, 0x000f000e,\n\t0x9238, 0xffffffff, 0x00120011,\n\t0x923c, 0xffffffff, 0x000c000b,\n\t0x9240, 0xffffffff, 0x000e000d,\n\t0x9244, 0xffffffff, 0x00000011,\n\t0x9248, 0xffffffff, 0x0010000f,\n\t0x924c, 0xffffffff, 0x00130012,\n\t0x9250, 0xffffffff, 0x000d000c,\n\t0x9254, 0xffffffff, 0x000f000e,\n\t0x9258, 0xffffffff, 0x00100013,\n\t0x925c, 0xffffffff, 0x00120011,\n\t0x9260, 0xffffffff, 0x00150014,\n\t0x9264, 0xffffffff, 0x000e000d,\n\t0x9268, 0xffffffff, 0x0010000f,\n\t0x926c, 0xffffffff, 0x00000013,\n\t0x9270, 0xffffffff, 0x00120011,\n\t0x9274, 0xffffffff, 0x00150014,\n\t0x9278, 0xffffffff, 0x000f000e,\n\t0x927c, 0xffffffff, 0x00110010,\n\t0x9280, 0xffffffff, 0x00000014,\n\t0x9284, 0xffffffff, 0x00130012,\n\t0x9288, 0xffffffff, 0x00160015,\n\t0x928c, 0xffffffff, 0x0010000f,\n\t0x9290, 0xffffffff, 0x00120011,\n\t0x9294, 0xffffffff, 0x00000015,\n\t0x9298, 0xffffffff, 0x00140013,\n\t0x929c, 0xffffffff, 0x00170016,\n\t0x9150, 0xffffffff, 0x96940200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc478, 0xffffffff, 0x00000080,\n\t0xc404, 0xffffffff, 0x0020003f,\n\t0x30, 0xffffffff, 0x0000001c,\n\t0x34, 0x000f0000, 0x000f0000,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x1024, 0xffffffff, 0x00000100,\n\t0x102c, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x264c, 0x000c0000, 0x000c0000,\n\t0x2648, 0x000c0000, 0x000c0000,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x55e8, 0x00000001, 0x00000001,\n\t0x2f50, 0x00000001, 0x00000001,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd0c0, 0xfffffff0, 0x00000100,\n\t0xd8c0, 0xfffffff0, 0x00000100\n};\n\nstatic const u32 pitcairn_mgcg_cgcg_init[] =\n{\n\t0xc400, 0xffffffff, 0xfffffffc,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x92a4, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x9774, 0xffffffff, 0x00000100,\n\t0x8984, 0xffffffff, 0x06000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x92a0, 0xffffffff, 0x00000100,\n\t0xc380, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x8d88, 0xffffffff, 0x00000100,\n\t0x8d8c, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0xad80, 0xffffffff, 0x00000100,\n\t0xac54, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0xaf04, 0xffffffff, 0x00000100,\n\t0xae04, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9160, 0xffffffff, 0x00010000,\n\t0x9164, 0xffffffff, 0x00030002,\n\t0x9168, 0xffffffff, 0x00040007,\n\t0x916c, 0xffffffff, 0x00060005,\n\t0x9170, 0xffffffff, 0x00090008,\n\t0x9174, 0xffffffff, 0x00020001,\n\t0x9178, 0xffffffff, 0x00040003,\n\t0x917c, 0xffffffff, 0x00000007,\n\t0x9180, 0xffffffff, 0x00060005,\n\t0x9184, 0xffffffff, 0x00090008,\n\t0x9188, 0xffffffff, 0x00030002,\n\t0x918c, 0xffffffff, 0x00050004,\n\t0x9190, 0xffffffff, 0x00000008,\n\t0x9194, 0xffffffff, 0x00070006,\n\t0x9198, 0xffffffff, 0x000a0009,\n\t0x919c, 0xffffffff, 0x00040003,\n\t0x91a0, 0xffffffff, 0x00060005,\n\t0x91a4, 0xffffffff, 0x00000009,\n\t0x91a8, 0xffffffff, 0x00080007,\n\t0x91ac, 0xffffffff, 0x000b000a,\n\t0x91b0, 0xffffffff, 0x00050004,\n\t0x91b4, 0xffffffff, 0x00070006,\n\t0x91b8, 0xffffffff, 0x0008000b,\n\t0x91bc, 0xffffffff, 0x000a0009,\n\t0x91c0, 0xffffffff, 0x000d000c,\n\t0x9200, 0xffffffff, 0x00090008,\n\t0x9204, 0xffffffff, 0x000b000a,\n\t0x9208, 0xffffffff, 0x000c000f,\n\t0x920c, 0xffffffff, 0x000e000d,\n\t0x9210, 0xffffffff, 0x00110010,\n\t0x9214, 0xffffffff, 0x000a0009,\n\t0x9218, 0xffffffff, 0x000c000b,\n\t0x921c, 0xffffffff, 0x0000000f,\n\t0x9220, 0xffffffff, 0x000e000d,\n\t0x9224, 0xffffffff, 0x00110010,\n\t0x9228, 0xffffffff, 0x000b000a,\n\t0x922c, 0xffffffff, 0x000d000c,\n\t0x9230, 0xffffffff, 0x00000010,\n\t0x9234, 0xffffffff, 0x000f000e,\n\t0x9238, 0xffffffff, 0x00120011,\n\t0x923c, 0xffffffff, 0x000c000b,\n\t0x9240, 0xffffffff, 0x000e000d,\n\t0x9244, 0xffffffff, 0x00000011,\n\t0x9248, 0xffffffff, 0x0010000f,\n\t0x924c, 0xffffffff, 0x00130012,\n\t0x9250, 0xffffffff, 0x000d000c,\n\t0x9254, 0xffffffff, 0x000f000e,\n\t0x9258, 0xffffffff, 0x00100013,\n\t0x925c, 0xffffffff, 0x00120011,\n\t0x9260, 0xffffffff, 0x00150014,\n\t0x9150, 0xffffffff, 0x96940200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc478, 0xffffffff, 0x00000080,\n\t0xc404, 0xffffffff, 0x0020003f,\n\t0x30, 0xffffffff, 0x0000001c,\n\t0x34, 0x000f0000, 0x000f0000,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x1024, 0xffffffff, 0x00000100,\n\t0x102c, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x55e8, 0x00000001, 0x00000001,\n\t0x2f50, 0x00000001, 0x00000001,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd0c0, 0xfffffff0, 0x00000100,\n\t0xd8c0, 0xfffffff0, 0x00000100\n};\n\nstatic const u32 verde_mgcg_cgcg_init[] =\n{\n\t0xc400, 0xffffffff, 0xfffffffc,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x92a4, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x9774, 0xffffffff, 0x00000100,\n\t0x8984, 0xffffffff, 0x06000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x92a0, 0xffffffff, 0x00000100,\n\t0xc380, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x8d88, 0xffffffff, 0x00000100,\n\t0x8d8c, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0xad80, 0xffffffff, 0x00000100,\n\t0xac54, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0xaf04, 0xffffffff, 0x00000100,\n\t0xae04, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9160, 0xffffffff, 0x00010000,\n\t0x9164, 0xffffffff, 0x00030002,\n\t0x9168, 0xffffffff, 0x00040007,\n\t0x916c, 0xffffffff, 0x00060005,\n\t0x9170, 0xffffffff, 0x00090008,\n\t0x9174, 0xffffffff, 0x00020001,\n\t0x9178, 0xffffffff, 0x00040003,\n\t0x917c, 0xffffffff, 0x00000007,\n\t0x9180, 0xffffffff, 0x00060005,\n\t0x9184, 0xffffffff, 0x00090008,\n\t0x9188, 0xffffffff, 0x00030002,\n\t0x918c, 0xffffffff, 0x00050004,\n\t0x9190, 0xffffffff, 0x00000008,\n\t0x9194, 0xffffffff, 0x00070006,\n\t0x9198, 0xffffffff, 0x000a0009,\n\t0x919c, 0xffffffff, 0x00040003,\n\t0x91a0, 0xffffffff, 0x00060005,\n\t0x91a4, 0xffffffff, 0x00000009,\n\t0x91a8, 0xffffffff, 0x00080007,\n\t0x91ac, 0xffffffff, 0x000b000a,\n\t0x91b0, 0xffffffff, 0x00050004,\n\t0x91b4, 0xffffffff, 0x00070006,\n\t0x91b8, 0xffffffff, 0x0008000b,\n\t0x91bc, 0xffffffff, 0x000a0009,\n\t0x91c0, 0xffffffff, 0x000d000c,\n\t0x9200, 0xffffffff, 0x00090008,\n\t0x9204, 0xffffffff, 0x000b000a,\n\t0x9208, 0xffffffff, 0x000c000f,\n\t0x920c, 0xffffffff, 0x000e000d,\n\t0x9210, 0xffffffff, 0x00110010,\n\t0x9214, 0xffffffff, 0x000a0009,\n\t0x9218, 0xffffffff, 0x000c000b,\n\t0x921c, 0xffffffff, 0x0000000f,\n\t0x9220, 0xffffffff, 0x000e000d,\n\t0x9224, 0xffffffff, 0x00110010,\n\t0x9228, 0xffffffff, 0x000b000a,\n\t0x922c, 0xffffffff, 0x000d000c,\n\t0x9230, 0xffffffff, 0x00000010,\n\t0x9234, 0xffffffff, 0x000f000e,\n\t0x9238, 0xffffffff, 0x00120011,\n\t0x923c, 0xffffffff, 0x000c000b,\n\t0x9240, 0xffffffff, 0x000e000d,\n\t0x9244, 0xffffffff, 0x00000011,\n\t0x9248, 0xffffffff, 0x0010000f,\n\t0x924c, 0xffffffff, 0x00130012,\n\t0x9250, 0xffffffff, 0x000d000c,\n\t0x9254, 0xffffffff, 0x000f000e,\n\t0x9258, 0xffffffff, 0x00100013,\n\t0x925c, 0xffffffff, 0x00120011,\n\t0x9260, 0xffffffff, 0x00150014,\n\t0x9150, 0xffffffff, 0x96940200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc478, 0xffffffff, 0x00000080,\n\t0xc404, 0xffffffff, 0x0020003f,\n\t0x30, 0xffffffff, 0x0000001c,\n\t0x34, 0x000f0000, 0x000f0000,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x1024, 0xffffffff, 0x00000100,\n\t0x102c, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x264c, 0x000c0000, 0x000c0000,\n\t0x2648, 0x000c0000, 0x000c0000,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x55e8, 0x00000001, 0x00000001,\n\t0x2f50, 0x00000001, 0x00000001,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd0c0, 0xfffffff0, 0x00000100,\n\t0xd8c0, 0xfffffff0, 0x00000100\n};\n\nstatic const u32 oland_mgcg_cgcg_init[] =\n{\n\t0xc400, 0xffffffff, 0xfffffffc,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x92a4, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x9774, 0xffffffff, 0x00000100,\n\t0x8984, 0xffffffff, 0x06000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x92a0, 0xffffffff, 0x00000100,\n\t0xc380, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x8d88, 0xffffffff, 0x00000100,\n\t0x8d8c, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0xad80, 0xffffffff, 0x00000100,\n\t0xac54, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0xaf04, 0xffffffff, 0x00000100,\n\t0xae04, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9160, 0xffffffff, 0x00010000,\n\t0x9164, 0xffffffff, 0x00030002,\n\t0x9168, 0xffffffff, 0x00040007,\n\t0x916c, 0xffffffff, 0x00060005,\n\t0x9170, 0xffffffff, 0x00090008,\n\t0x9174, 0xffffffff, 0x00020001,\n\t0x9178, 0xffffffff, 0x00040003,\n\t0x917c, 0xffffffff, 0x00000007,\n\t0x9180, 0xffffffff, 0x00060005,\n\t0x9184, 0xffffffff, 0x00090008,\n\t0x9188, 0xffffffff, 0x00030002,\n\t0x918c, 0xffffffff, 0x00050004,\n\t0x9190, 0xffffffff, 0x00000008,\n\t0x9194, 0xffffffff, 0x00070006,\n\t0x9198, 0xffffffff, 0x000a0009,\n\t0x919c, 0xffffffff, 0x00040003,\n\t0x91a0, 0xffffffff, 0x00060005,\n\t0x91a4, 0xffffffff, 0x00000009,\n\t0x91a8, 0xffffffff, 0x00080007,\n\t0x91ac, 0xffffffff, 0x000b000a,\n\t0x91b0, 0xffffffff, 0x00050004,\n\t0x91b4, 0xffffffff, 0x00070006,\n\t0x91b8, 0xffffffff, 0x0008000b,\n\t0x91bc, 0xffffffff, 0x000a0009,\n\t0x91c0, 0xffffffff, 0x000d000c,\n\t0x91c4, 0xffffffff, 0x00060005,\n\t0x91c8, 0xffffffff, 0x00080007,\n\t0x91cc, 0xffffffff, 0x0000000b,\n\t0x91d0, 0xffffffff, 0x000a0009,\n\t0x91d4, 0xffffffff, 0x000d000c,\n\t0x9150, 0xffffffff, 0x96940200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc478, 0xffffffff, 0x00000080,\n\t0xc404, 0xffffffff, 0x0020003f,\n\t0x30, 0xffffffff, 0x0000001c,\n\t0x34, 0x000f0000, 0x000f0000,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x1024, 0xffffffff, 0x00000100,\n\t0x102c, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x264c, 0x000c0000, 0x000c0000,\n\t0x2648, 0x000c0000, 0x000c0000,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x55e8, 0x00000001, 0x00000001,\n\t0x2f50, 0x00000001, 0x00000001,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd0c0, 0xfffffff0, 0x00000100,\n\t0xd8c0, 0xfffffff0, 0x00000100\n};\n\nstatic const u32 hainan_mgcg_cgcg_init[] =\n{\n\t0xc400, 0xffffffff, 0xfffffffc,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x92a4, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x9774, 0xffffffff, 0x00000100,\n\t0x8984, 0xffffffff, 0x06000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x92a0, 0xffffffff, 0x00000100,\n\t0xc380, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x8d88, 0xffffffff, 0x00000100,\n\t0x8d8c, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0xad80, 0xffffffff, 0x00000100,\n\t0xac54, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0xaf04, 0xffffffff, 0x00000100,\n\t0xae04, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x802c, 0xffffffff, 0xe0000000,\n\t0x9160, 0xffffffff, 0x00010000,\n\t0x9164, 0xffffffff, 0x00030002,\n\t0x9168, 0xffffffff, 0x00040007,\n\t0x916c, 0xffffffff, 0x00060005,\n\t0x9170, 0xffffffff, 0x00090008,\n\t0x9174, 0xffffffff, 0x00020001,\n\t0x9178, 0xffffffff, 0x00040003,\n\t0x917c, 0xffffffff, 0x00000007,\n\t0x9180, 0xffffffff, 0x00060005,\n\t0x9184, 0xffffffff, 0x00090008,\n\t0x9188, 0xffffffff, 0x00030002,\n\t0x918c, 0xffffffff, 0x00050004,\n\t0x9190, 0xffffffff, 0x00000008,\n\t0x9194, 0xffffffff, 0x00070006,\n\t0x9198, 0xffffffff, 0x000a0009,\n\t0x919c, 0xffffffff, 0x00040003,\n\t0x91a0, 0xffffffff, 0x00060005,\n\t0x91a4, 0xffffffff, 0x00000009,\n\t0x91a8, 0xffffffff, 0x00080007,\n\t0x91ac, 0xffffffff, 0x000b000a,\n\t0x91b0, 0xffffffff, 0x00050004,\n\t0x91b4, 0xffffffff, 0x00070006,\n\t0x91b8, 0xffffffff, 0x0008000b,\n\t0x91bc, 0xffffffff, 0x000a0009,\n\t0x91c0, 0xffffffff, 0x000d000c,\n\t0x91c4, 0xffffffff, 0x00060005,\n\t0x91c8, 0xffffffff, 0x00080007,\n\t0x91cc, 0xffffffff, 0x0000000b,\n\t0x91d0, 0xffffffff, 0x000a0009,\n\t0x91d4, 0xffffffff, 0x000d000c,\n\t0x9150, 0xffffffff, 0x96940200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc478, 0xffffffff, 0x00000080,\n\t0xc404, 0xffffffff, 0x0020003f,\n\t0x30, 0xffffffff, 0x0000001c,\n\t0x34, 0x000f0000, 0x000f0000,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x1024, 0xffffffff, 0x00000100,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x264c, 0x000c0000, 0x000c0000,\n\t0x2648, 0x000c0000, 0x000c0000,\n\t0x2f50, 0x00000001, 0x00000001,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd0c0, 0xfffffff0, 0x00000100,\n\t0xd8c0, 0xfffffff0, 0x00000100\n};\n\nstatic u32 verde_pg_init[] =\n{\n\t0x353c, 0xffffffff, 0x40000,\n\t0x3538, 0xffffffff, 0x200010ff,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x7007,\n\t0x3538, 0xffffffff, 0x300010ff,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x400000,\n\t0x3538, 0xffffffff, 0x100010ff,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x120200,\n\t0x3538, 0xffffffff, 0x500010ff,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x1e1e16,\n\t0x3538, 0xffffffff, 0x600010ff,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x171f1e,\n\t0x3538, 0xffffffff, 0x700010ff,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x353c, 0xffffffff, 0x0,\n\t0x3538, 0xffffffff, 0x9ff,\n\t0x3500, 0xffffffff, 0x0,\n\t0x3504, 0xffffffff, 0x10000800,\n\t0x3504, 0xffffffff, 0xf,\n\t0x3504, 0xffffffff, 0xf,\n\t0x3500, 0xffffffff, 0x4,\n\t0x3504, 0xffffffff, 0x1000051e,\n\t0x3504, 0xffffffff, 0xffff,\n\t0x3504, 0xffffffff, 0xffff,\n\t0x3500, 0xffffffff, 0x8,\n\t0x3504, 0xffffffff, 0x80500,\n\t0x3500, 0xffffffff, 0x12,\n\t0x3504, 0xffffffff, 0x9050c,\n\t0x3500, 0xffffffff, 0x1d,\n\t0x3504, 0xffffffff, 0xb052c,\n\t0x3500, 0xffffffff, 0x2a,\n\t0x3504, 0xffffffff, 0x1053e,\n\t0x3500, 0xffffffff, 0x2d,\n\t0x3504, 0xffffffff, 0x10546,\n\t0x3500, 0xffffffff, 0x30,\n\t0x3504, 0xffffffff, 0xa054e,\n\t0x3500, 0xffffffff, 0x3c,\n\t0x3504, 0xffffffff, 0x1055f,\n\t0x3500, 0xffffffff, 0x3f,\n\t0x3504, 0xffffffff, 0x10567,\n\t0x3500, 0xffffffff, 0x42,\n\t0x3504, 0xffffffff, 0x1056f,\n\t0x3500, 0xffffffff, 0x45,\n\t0x3504, 0xffffffff, 0x10572,\n\t0x3500, 0xffffffff, 0x48,\n\t0x3504, 0xffffffff, 0x20575,\n\t0x3500, 0xffffffff, 0x4c,\n\t0x3504, 0xffffffff, 0x190801,\n\t0x3500, 0xffffffff, 0x67,\n\t0x3504, 0xffffffff, 0x1082a,\n\t0x3500, 0xffffffff, 0x6a,\n\t0x3504, 0xffffffff, 0x1b082d,\n\t0x3500, 0xffffffff, 0x87,\n\t0x3504, 0xffffffff, 0x310851,\n\t0x3500, 0xffffffff, 0xba,\n\t0x3504, 0xffffffff, 0x891,\n\t0x3500, 0xffffffff, 0xbc,\n\t0x3504, 0xffffffff, 0x893,\n\t0x3500, 0xffffffff, 0xbe,\n\t0x3504, 0xffffffff, 0x20895,\n\t0x3500, 0xffffffff, 0xc2,\n\t0x3504, 0xffffffff, 0x20899,\n\t0x3500, 0xffffffff, 0xc6,\n\t0x3504, 0xffffffff, 0x2089d,\n\t0x3500, 0xffffffff, 0xca,\n\t0x3504, 0xffffffff, 0x8a1,\n\t0x3500, 0xffffffff, 0xcc,\n\t0x3504, 0xffffffff, 0x8a3,\n\t0x3500, 0xffffffff, 0xce,\n\t0x3504, 0xffffffff, 0x308a5,\n\t0x3500, 0xffffffff, 0xd3,\n\t0x3504, 0xffffffff, 0x6d08cd,\n\t0x3500, 0xffffffff, 0x142,\n\t0x3504, 0xffffffff, 0x2000095a,\n\t0x3504, 0xffffffff, 0x1,\n\t0x3500, 0xffffffff, 0x144,\n\t0x3504, 0xffffffff, 0x301f095b,\n\t0x3500, 0xffffffff, 0x165,\n\t0x3504, 0xffffffff, 0xc094d,\n\t0x3500, 0xffffffff, 0x173,\n\t0x3504, 0xffffffff, 0xf096d,\n\t0x3500, 0xffffffff, 0x184,\n\t0x3504, 0xffffffff, 0x15097f,\n\t0x3500, 0xffffffff, 0x19b,\n\t0x3504, 0xffffffff, 0xc0998,\n\t0x3500, 0xffffffff, 0x1a9,\n\t0x3504, 0xffffffff, 0x409a7,\n\t0x3500, 0xffffffff, 0x1af,\n\t0x3504, 0xffffffff, 0xcdc,\n\t0x3500, 0xffffffff, 0x1b1,\n\t0x3504, 0xffffffff, 0x800,\n\t0x3508, 0xffffffff, 0x6c9b2000,\n\t0x3510, 0xfc00, 0x2000,\n\t0x3544, 0xffffffff, 0xfc0,\n\t0x28d4, 0x00000100, 0x100\n};\n\nstatic void si_init_golden_registers(struct radeon_device *rdev)\n{\n\tswitch (rdev->family) {\n\tcase CHIP_TAHITI:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t tahiti_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(tahiti_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t tahiti_golden_rlc_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(tahiti_golden_rlc_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t tahiti_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(tahiti_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t tahiti_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(tahiti_golden_registers2));\n\t\tbreak;\n\tcase CHIP_PITCAIRN:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t pitcairn_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(pitcairn_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t pitcairn_golden_rlc_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(pitcairn_golden_rlc_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t pitcairn_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(pitcairn_mgcg_cgcg_init));\n\t\tbreak;\n\tcase CHIP_VERDE:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t verde_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(verde_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t verde_golden_rlc_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(verde_golden_rlc_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t verde_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(verde_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t verde_pg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(verde_pg_init));\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t oland_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(oland_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t oland_golden_rlc_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(oland_golden_rlc_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t oland_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(oland_mgcg_cgcg_init));\n\t\tbreak;\n\tcase CHIP_HAINAN:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hainan_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hainan_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hainan_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hainan_golden_registers2));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hainan_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hainan_mgcg_cgcg_init));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nint si_get_allowed_info_register(struct radeon_device *rdev,\n\t\t\t\t u32 reg, u32 *val)\n{\n\tswitch (reg) {\n\tcase GRBM_STATUS:\n\tcase GRBM_STATUS2:\n\tcase GRBM_STATUS_SE0:\n\tcase GRBM_STATUS_SE1:\n\tcase SRBM_STATUS:\n\tcase SRBM_STATUS2:\n\tcase (DMA_STATUS_REG + DMA0_REGISTER_OFFSET):\n\tcase (DMA_STATUS_REG + DMA1_REGISTER_OFFSET):\n\tcase UVD_STATUS:\n\t\t*val = RREG32(reg);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define PCIE_BUS_CLK                10000\n#define TCLK                        (PCIE_BUS_CLK / 10)\n\n \nu32 si_get_xclk(struct radeon_device *rdev)\n{\n\tu32 reference_clock = rdev->clock.spll.reference_freq;\n\tu32 tmp;\n\n\ttmp = RREG32(CG_CLKPIN_CNTL_2);\n\tif (tmp & MUX_TCLK_TO_XCLK)\n\t\treturn TCLK;\n\n\ttmp = RREG32(CG_CLKPIN_CNTL);\n\tif (tmp & XTALIN_DIVIDE)\n\t\treturn reference_clock / 4;\n\n\treturn reference_clock;\n}\n\n \nint si_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp;\n\tint actual_temp = 0;\n\n\ttemp = (RREG32(CG_MULT_THERMAL_STATUS) & CTF_TEMP_MASK) >>\n\t\tCTF_TEMP_SHIFT;\n\n\tif (temp & 0x200)\n\t\tactual_temp = 255;\n\telse\n\t\tactual_temp = temp & 0x1ff;\n\n\tactual_temp = (actual_temp * 1000);\n\n\treturn actual_temp;\n}\n\n#define TAHITI_IO_MC_REGS_SIZE 36\n\nstatic const u32 tahiti_io_mc_regs[TAHITI_IO_MC_REGS_SIZE][2] = {\n\t{0x0000006f, 0x03044000},\n\t{0x00000070, 0x0480c018},\n\t{0x00000071, 0x00000040},\n\t{0x00000072, 0x01000000},\n\t{0x00000074, 0x000000ff},\n\t{0x00000075, 0x00143400},\n\t{0x00000076, 0x08ec0800},\n\t{0x00000077, 0x040000cc},\n\t{0x00000079, 0x00000000},\n\t{0x0000007a, 0x21000409},\n\t{0x0000007c, 0x00000000},\n\t{0x0000007d, 0xe8000000},\n\t{0x0000007e, 0x044408a8},\n\t{0x0000007f, 0x00000003},\n\t{0x00000080, 0x00000000},\n\t{0x00000081, 0x01000000},\n\t{0x00000082, 0x02000000},\n\t{0x00000083, 0x00000000},\n\t{0x00000084, 0xe3f3e4f4},\n\t{0x00000085, 0x00052024},\n\t{0x00000087, 0x00000000},\n\t{0x00000088, 0x66036603},\n\t{0x00000089, 0x01000000},\n\t{0x0000008b, 0x1c0a0000},\n\t{0x0000008c, 0xff010000},\n\t{0x0000008e, 0xffffefff},\n\t{0x0000008f, 0xfff3efff},\n\t{0x00000090, 0xfff3efbf},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00a77400}\n};\n\nstatic const u32 pitcairn_io_mc_regs[TAHITI_IO_MC_REGS_SIZE][2] = {\n\t{0x0000006f, 0x03044000},\n\t{0x00000070, 0x0480c018},\n\t{0x00000071, 0x00000040},\n\t{0x00000072, 0x01000000},\n\t{0x00000074, 0x000000ff},\n\t{0x00000075, 0x00143400},\n\t{0x00000076, 0x08ec0800},\n\t{0x00000077, 0x040000cc},\n\t{0x00000079, 0x00000000},\n\t{0x0000007a, 0x21000409},\n\t{0x0000007c, 0x00000000},\n\t{0x0000007d, 0xe8000000},\n\t{0x0000007e, 0x044408a8},\n\t{0x0000007f, 0x00000003},\n\t{0x00000080, 0x00000000},\n\t{0x00000081, 0x01000000},\n\t{0x00000082, 0x02000000},\n\t{0x00000083, 0x00000000},\n\t{0x00000084, 0xe3f3e4f4},\n\t{0x00000085, 0x00052024},\n\t{0x00000087, 0x00000000},\n\t{0x00000088, 0x66036603},\n\t{0x00000089, 0x01000000},\n\t{0x0000008b, 0x1c0a0000},\n\t{0x0000008c, 0xff010000},\n\t{0x0000008e, 0xffffefff},\n\t{0x0000008f, 0xfff3efff},\n\t{0x00000090, 0xfff3efbf},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00a47400}\n};\n\nstatic const u32 verde_io_mc_regs[TAHITI_IO_MC_REGS_SIZE][2] = {\n\t{0x0000006f, 0x03044000},\n\t{0x00000070, 0x0480c018},\n\t{0x00000071, 0x00000040},\n\t{0x00000072, 0x01000000},\n\t{0x00000074, 0x000000ff},\n\t{0x00000075, 0x00143400},\n\t{0x00000076, 0x08ec0800},\n\t{0x00000077, 0x040000cc},\n\t{0x00000079, 0x00000000},\n\t{0x0000007a, 0x21000409},\n\t{0x0000007c, 0x00000000},\n\t{0x0000007d, 0xe8000000},\n\t{0x0000007e, 0x044408a8},\n\t{0x0000007f, 0x00000003},\n\t{0x00000080, 0x00000000},\n\t{0x00000081, 0x01000000},\n\t{0x00000082, 0x02000000},\n\t{0x00000083, 0x00000000},\n\t{0x00000084, 0xe3f3e4f4},\n\t{0x00000085, 0x00052024},\n\t{0x00000087, 0x00000000},\n\t{0x00000088, 0x66036603},\n\t{0x00000089, 0x01000000},\n\t{0x0000008b, 0x1c0a0000},\n\t{0x0000008c, 0xff010000},\n\t{0x0000008e, 0xffffefff},\n\t{0x0000008f, 0xfff3efff},\n\t{0x00000090, 0xfff3efbf},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00a37400}\n};\n\nstatic const u32 oland_io_mc_regs[TAHITI_IO_MC_REGS_SIZE][2] = {\n\t{0x0000006f, 0x03044000},\n\t{0x00000070, 0x0480c018},\n\t{0x00000071, 0x00000040},\n\t{0x00000072, 0x01000000},\n\t{0x00000074, 0x000000ff},\n\t{0x00000075, 0x00143400},\n\t{0x00000076, 0x08ec0800},\n\t{0x00000077, 0x040000cc},\n\t{0x00000079, 0x00000000},\n\t{0x0000007a, 0x21000409},\n\t{0x0000007c, 0x00000000},\n\t{0x0000007d, 0xe8000000},\n\t{0x0000007e, 0x044408a8},\n\t{0x0000007f, 0x00000003},\n\t{0x00000080, 0x00000000},\n\t{0x00000081, 0x01000000},\n\t{0x00000082, 0x02000000},\n\t{0x00000083, 0x00000000},\n\t{0x00000084, 0xe3f3e4f4},\n\t{0x00000085, 0x00052024},\n\t{0x00000087, 0x00000000},\n\t{0x00000088, 0x66036603},\n\t{0x00000089, 0x01000000},\n\t{0x0000008b, 0x1c0a0000},\n\t{0x0000008c, 0xff010000},\n\t{0x0000008e, 0xffffefff},\n\t{0x0000008f, 0xfff3efff},\n\t{0x00000090, 0xfff3efbf},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00a17730}\n};\n\nstatic const u32 hainan_io_mc_regs[TAHITI_IO_MC_REGS_SIZE][2] = {\n\t{0x0000006f, 0x03044000},\n\t{0x00000070, 0x0480c018},\n\t{0x00000071, 0x00000040},\n\t{0x00000072, 0x01000000},\n\t{0x00000074, 0x000000ff},\n\t{0x00000075, 0x00143400},\n\t{0x00000076, 0x08ec0800},\n\t{0x00000077, 0x040000cc},\n\t{0x00000079, 0x00000000},\n\t{0x0000007a, 0x21000409},\n\t{0x0000007c, 0x00000000},\n\t{0x0000007d, 0xe8000000},\n\t{0x0000007e, 0x044408a8},\n\t{0x0000007f, 0x00000003},\n\t{0x00000080, 0x00000000},\n\t{0x00000081, 0x01000000},\n\t{0x00000082, 0x02000000},\n\t{0x00000083, 0x00000000},\n\t{0x00000084, 0xe3f3e4f4},\n\t{0x00000085, 0x00052024},\n\t{0x00000087, 0x00000000},\n\t{0x00000088, 0x66036603},\n\t{0x00000089, 0x01000000},\n\t{0x0000008b, 0x1c0a0000},\n\t{0x0000008c, 0xff010000},\n\t{0x0000008e, 0xffffefff},\n\t{0x0000008f, 0xfff3efff},\n\t{0x00000090, 0xfff3efbf},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00a07730}\n};\n\n \nint si_mc_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data = NULL;\n\tconst __le32 *new_fw_data = NULL;\n\tu32 running;\n\tu32 *io_mc_regs = NULL;\n\tconst __le32 *new_io_mc_regs = NULL;\n\tint i, regs_size, ucode_size;\n\n\tif (!rdev->mc_fw)\n\t\treturn -EINVAL;\n\n\tif (rdev->new_fw) {\n\t\tconst struct mc_firmware_header_v1_0 *hdr =\n\t\t\t(const struct mc_firmware_header_v1_0 *)rdev->mc_fw->data;\n\n\t\tradeon_ucode_print_mc_hdr(&hdr->header);\n\t\tregs_size = le32_to_cpu(hdr->io_debug_size_bytes) / (4 * 2);\n\t\tnew_io_mc_regs = (const __le32 *)\n\t\t\t(rdev->mc_fw->data + le32_to_cpu(hdr->io_debug_array_offset_bytes));\n\t\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\t\tnew_fw_data = (const __le32 *)\n\t\t\t(rdev->mc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t} else {\n\t\tucode_size = rdev->mc_fw->size / 4;\n\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_TAHITI:\n\t\t\tio_mc_regs = (u32 *)&tahiti_io_mc_regs;\n\t\t\tregs_size = TAHITI_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_PITCAIRN:\n\t\t\tio_mc_regs = (u32 *)&pitcairn_io_mc_regs;\n\t\t\tregs_size = TAHITI_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_VERDE:\n\t\tdefault:\n\t\t\tio_mc_regs = (u32 *)&verde_io_mc_regs;\n\t\t\tregs_size = TAHITI_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_OLAND:\n\t\t\tio_mc_regs = (u32 *)&oland_io_mc_regs;\n\t\t\tregs_size = TAHITI_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_HAINAN:\n\t\t\tio_mc_regs = (u32 *)&hainan_io_mc_regs;\n\t\t\tregs_size = TAHITI_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\t}\n\t\tfw_data = (const __be32 *)rdev->mc_fw->data;\n\t}\n\n\trunning = RREG32(MC_SEQ_SUP_CNTL) & RUN_MASK;\n\n\tif (running == 0) {\n\t\t \n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000008);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000010);\n\n\t\t \n\t\tfor (i = 0; i < regs_size; i++) {\n\t\t\tif (rdev->new_fw) {\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, le32_to_cpup(new_io_mc_regs++));\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, le32_to_cpup(new_io_mc_regs++));\n\t\t\t} else {\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, io_mc_regs[(i << 1)]);\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, io_mc_regs[(i << 1) + 1]);\n\t\t\t}\n\t\t}\n\t\t \n\t\tfor (i = 0; i < ucode_size; i++) {\n\t\t\tif (rdev->new_fw)\n\t\t\t\tWREG32(MC_SEQ_SUP_PGM, le32_to_cpup(new_fw_data++));\n\t\t\telse\n\t\t\t\tWREG32(MC_SEQ_SUP_PGM, be32_to_cpup(fw_data++));\n\t\t}\n\n\t\t \n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000008);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000004);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000001);\n\n\t\t \n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif (RREG32(MC_SEQ_TRAIN_WAKEUP_CNTL) & TRAIN_DONE_D0)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif (RREG32(MC_SEQ_TRAIN_WAKEUP_CNTL) & TRAIN_DONE_D1)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int si_init_microcode(struct radeon_device *rdev)\n{\n\tconst char *chip_name;\n\tconst char *new_chip_name;\n\tsize_t pfp_req_size, me_req_size, ce_req_size, rlc_req_size, mc_req_size;\n\tsize_t smc_req_size, mc2_req_size;\n\tchar fw_name[30];\n\tint err;\n\tint new_fw = 0;\n\tbool new_smc = false;\n\tbool si58_fw = false;\n\tbool banks2_fw = false;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tswitch (rdev->family) {\n\tcase CHIP_TAHITI:\n\t\tchip_name = \"TAHITI\";\n\t\tnew_chip_name = \"tahiti\";\n\t\tpfp_req_size = SI_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = SI_PM4_UCODE_SIZE * 4;\n\t\tce_req_size = SI_CE_UCODE_SIZE * 4;\n\t\trlc_req_size = SI_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = SI_MC_UCODE_SIZE * 4;\n\t\tmc2_req_size = TAHITI_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(TAHITI_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_PITCAIRN:\n\t\tchip_name = \"PITCAIRN\";\n\t\tif ((rdev->pdev->revision == 0x81) &&\n\t\t    ((rdev->pdev->device == 0x6810) ||\n\t\t     (rdev->pdev->device == 0x6811)))\n\t\t\tnew_smc = true;\n\t\tnew_chip_name = \"pitcairn\";\n\t\tpfp_req_size = SI_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = SI_PM4_UCODE_SIZE * 4;\n\t\tce_req_size = SI_CE_UCODE_SIZE * 4;\n\t\trlc_req_size = SI_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = SI_MC_UCODE_SIZE * 4;\n\t\tmc2_req_size = PITCAIRN_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(PITCAIRN_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_VERDE:\n\t\tchip_name = \"VERDE\";\n\t\tif (((rdev->pdev->device == 0x6820) &&\n\t\t     ((rdev->pdev->revision == 0x81) ||\n\t\t      (rdev->pdev->revision == 0x83))) ||\n\t\t    ((rdev->pdev->device == 0x6821) &&\n\t\t     ((rdev->pdev->revision == 0x83) ||\n\t\t      (rdev->pdev->revision == 0x87))) ||\n\t\t    ((rdev->pdev->revision == 0x87) &&\n\t\t     ((rdev->pdev->device == 0x6823) ||\n\t\t      (rdev->pdev->device == 0x682b))))\n\t\t\tnew_smc = true;\n\t\tnew_chip_name = \"verde\";\n\t\tpfp_req_size = SI_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = SI_PM4_UCODE_SIZE * 4;\n\t\tce_req_size = SI_CE_UCODE_SIZE * 4;\n\t\trlc_req_size = SI_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = SI_MC_UCODE_SIZE * 4;\n\t\tmc2_req_size = VERDE_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(VERDE_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\tchip_name = \"OLAND\";\n\t\tif (((rdev->pdev->revision == 0x81) &&\n\t\t     ((rdev->pdev->device == 0x6600) ||\n\t\t      (rdev->pdev->device == 0x6604) ||\n\t\t      (rdev->pdev->device == 0x6605) ||\n\t\t      (rdev->pdev->device == 0x6610))) ||\n\t\t    ((rdev->pdev->revision == 0x83) &&\n\t\t     (rdev->pdev->device == 0x6610)))\n\t\t\tnew_smc = true;\n\t\tnew_chip_name = \"oland\";\n\t\tpfp_req_size = SI_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = SI_PM4_UCODE_SIZE * 4;\n\t\tce_req_size = SI_CE_UCODE_SIZE * 4;\n\t\trlc_req_size = SI_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = mc2_req_size = OLAND_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(OLAND_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_HAINAN:\n\t\tchip_name = \"HAINAN\";\n\t\tif (((rdev->pdev->revision == 0x81) &&\n\t\t     (rdev->pdev->device == 0x6660)) ||\n\t\t    ((rdev->pdev->revision == 0x83) &&\n\t\t     ((rdev->pdev->device == 0x6660) ||\n\t\t      (rdev->pdev->device == 0x6663) ||\n\t\t      (rdev->pdev->device == 0x6665) ||\n\t\t      (rdev->pdev->device == 0x6667))))\n\t\t\tnew_smc = true;\n\t\telse if ((rdev->pdev->revision == 0xc3) &&\n\t\t\t (rdev->pdev->device == 0x6665))\n\t\t\tbanks2_fw = true;\n\t\tnew_chip_name = \"hainan\";\n\t\tpfp_req_size = SI_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = SI_PM4_UCODE_SIZE * 4;\n\t\tce_req_size = SI_CE_UCODE_SIZE * 4;\n\t\trlc_req_size = SI_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = mc2_req_size = OLAND_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(HAINAN_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\n\t \n\tif (((RREG32(MC_SEQ_MISC0) & 0xff000000) >> 24) == 0x58)\n\t\tsi58_fw = true;\n\n\tDRM_INFO(\"Loading %s Microcode\\n\", new_chip_name);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_pfp.bin\", new_chip_name);\n\terr = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_pfp.bin\", chip_name);\n\t\terr = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->pfp_fw->size != pfp_req_size) {\n\t\t\tpr_err(\"si_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->pfp_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->pfp_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"si_cp: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_me.bin\", new_chip_name);\n\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_me.bin\", chip_name);\n\t\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->me_fw->size != me_req_size) {\n\t\t\tpr_err(\"si_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->me_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->me_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"si_cp: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_ce.bin\", new_chip_name);\n\terr = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_ce.bin\", chip_name);\n\t\terr = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->ce_fw->size != ce_req_size) {\n\t\t\tpr_err(\"si_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->ce_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->ce_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"si_cp: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_rlc.bin\", new_chip_name);\n\terr = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_rlc.bin\", chip_name);\n\t\terr = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->rlc_fw->size != rlc_req_size) {\n\t\t\tpr_err(\"si_rlc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->rlc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->rlc_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"si_cp: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tif (si58_fw)\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/si58_mc.bin\");\n\telse\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc.bin\", new_chip_name);\n\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc2.bin\", chip_name);\n\t\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc.bin\", chip_name);\n\t\t\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif ((rdev->mc_fw->size != mc_req_size) &&\n\t\t    (rdev->mc_fw->size != mc2_req_size)) {\n\t\t\tpr_err(\"si_mc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->mc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tDRM_INFO(\"%s: %zu bytes\\n\", fw_name, rdev->mc_fw->size);\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->mc_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"si_cp: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tif (banks2_fw)\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/banks_k_2_smc.bin\");\n\telse if (new_smc)\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_k_smc.bin\", new_chip_name);\n\telse\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_smc.bin\", new_chip_name);\n\terr = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_smc.bin\", chip_name);\n\t\terr = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tpr_err(\"smc: error loading firmware \\\"%s\\\"\\n\", fw_name);\n\t\t\trelease_firmware(rdev->smc_fw);\n\t\t\trdev->smc_fw = NULL;\n\t\t\terr = 0;\n\t\t} else if (rdev->smc_fw->size != smc_req_size) {\n\t\t\tpr_err(\"si_smc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->smc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->smc_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"si_cp: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tif (new_fw == 0) {\n\t\trdev->new_fw = false;\n\t} else if (new_fw < 6) {\n\t\tpr_err(\"si_fw: mixing new and old firmware!\\n\");\n\t\terr = -EINVAL;\n\t} else {\n\t\trdev->new_fw = true;\n\t}\nout:\n\tif (err) {\n\t\tif (err != -EINVAL)\n\t\t\tpr_err(\"si_cp: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\trelease_firmware(rdev->pfp_fw);\n\t\trdev->pfp_fw = NULL;\n\t\trelease_firmware(rdev->me_fw);\n\t\trdev->me_fw = NULL;\n\t\trelease_firmware(rdev->ce_fw);\n\t\trdev->ce_fw = NULL;\n\t\trelease_firmware(rdev->rlc_fw);\n\t\trdev->rlc_fw = NULL;\n\t\trelease_firmware(rdev->mc_fw);\n\t\trdev->mc_fw = NULL;\n\t\trelease_firmware(rdev->smc_fw);\n\t\trdev->smc_fw = NULL;\n\t}\n\treturn err;\n}\n\n \nstatic u32 dce6_line_buffer_adjust(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_crtc *radeon_crtc,\n\t\t\t\t   struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *other_mode)\n{\n\tu32 tmp, buffer_alloc, i;\n\tu32 pipe_offset = radeon_crtc->crtc_id * 0x20;\n\t \n\t \n\tif (radeon_crtc->base.enabled && mode) {\n\t\tif (other_mode) {\n\t\t\ttmp = 0;  \n\t\t\tbuffer_alloc = 1;\n\t\t} else {\n\t\t\ttmp = 2;  \n\t\t\tbuffer_alloc = 2;\n\t\t}\n\t} else {\n\t\ttmp = 0;\n\t\tbuffer_alloc = 0;\n\t}\n\n\tWREG32(DC_LB_MEMORY_SPLIT + radeon_crtc->crtc_offset,\n\t       DC_LB_MEMORY_CONFIG(tmp));\n\n\tWREG32(PIPE0_DMIF_BUFFER_CONTROL + pipe_offset,\n\t       DMIF_BUFFERS_ALLOCATED(buffer_alloc));\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(PIPE0_DMIF_BUFFER_CONTROL + pipe_offset) &\n\t\t    DMIF_BUFFERS_ALLOCATED_COMPLETED)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (radeon_crtc->base.enabled && mode) {\n\t\tswitch (tmp) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\treturn 4096 * 2;\n\t\tcase 2:\n\t\t\treturn 8192 * 2;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic u32 si_get_number_of_dram_channels(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(MC_SHARED_CHMAP);\n\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\treturn 1;\n\tcase 1:\n\t\treturn 2;\n\tcase 2:\n\t\treturn 4;\n\tcase 3:\n\t\treturn 8;\n\tcase 4:\n\t\treturn 3;\n\tcase 5:\n\t\treturn 6;\n\tcase 6:\n\t\treturn 10;\n\tcase 7:\n\t\treturn 12;\n\tcase 8:\n\t\treturn 16;\n\t}\n}\n\nstruct dce6_wm_params {\n\tu32 dram_channels;  \n\tu32 yclk;           \n\tu32 sclk;           \n\tu32 disp_clk;       \n\tu32 src_width;      \n\tu32 active_time;    \n\tu32 blank_time;     \n\tbool interlaced;     \n\tfixed20_12 vsc;     \n\tu32 num_heads;      \n\tu32 bytes_per_pixel;  \n\tu32 lb_size;        \n\tu32 vtaps;          \n};\n\nstatic u32 dce6_dram_bandwidth(struct dce6_wm_params *wm)\n{\n\t \n\tfixed20_12 dram_efficiency;  \n\tfixed20_12 yclk, dram_channels, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tyclk.full = dfixed_const(wm->yclk);\n\tyclk.full = dfixed_div(yclk, a);\n\tdram_channels.full = dfixed_const(wm->dram_channels * 4);\n\ta.full = dfixed_const(10);\n\tdram_efficiency.full = dfixed_const(7);\n\tdram_efficiency.full = dfixed_div(dram_efficiency, a);\n\tbandwidth.full = dfixed_mul(dram_channels, yclk);\n\tbandwidth.full = dfixed_mul(bandwidth, dram_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 dce6_dram_bandwidth_for_display(struct dce6_wm_params *wm)\n{\n\t \n\tfixed20_12 disp_dram_allocation;  \n\tfixed20_12 yclk, dram_channels, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tyclk.full = dfixed_const(wm->yclk);\n\tyclk.full = dfixed_div(yclk, a);\n\tdram_channels.full = dfixed_const(wm->dram_channels * 4);\n\ta.full = dfixed_const(10);\n\tdisp_dram_allocation.full = dfixed_const(3);  \n\tdisp_dram_allocation.full = dfixed_div(disp_dram_allocation, a);\n\tbandwidth.full = dfixed_mul(dram_channels, yclk);\n\tbandwidth.full = dfixed_mul(bandwidth, disp_dram_allocation);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 dce6_data_return_bandwidth(struct dce6_wm_params *wm)\n{\n\t \n\tfixed20_12 return_efficiency;  \n\tfixed20_12 sclk, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tsclk.full = dfixed_const(wm->sclk);\n\tsclk.full = dfixed_div(sclk, a);\n\ta.full = dfixed_const(10);\n\treturn_efficiency.full = dfixed_const(8);\n\treturn_efficiency.full = dfixed_div(return_efficiency, a);\n\ta.full = dfixed_const(32);\n\tbandwidth.full = dfixed_mul(a, sclk);\n\tbandwidth.full = dfixed_mul(bandwidth, return_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 dce6_get_dmif_bytes_per_request(struct dce6_wm_params *wm)\n{\n\treturn 32;\n}\n\nstatic u32 dce6_dmif_request_bandwidth(struct dce6_wm_params *wm)\n{\n\t \n\tfixed20_12 disp_clk_request_efficiency;  \n\tfixed20_12 disp_clk, sclk, bandwidth;\n\tfixed20_12 a, b1, b2;\n\tu32 min_bandwidth;\n\n\ta.full = dfixed_const(1000);\n\tdisp_clk.full = dfixed_const(wm->disp_clk);\n\tdisp_clk.full = dfixed_div(disp_clk, a);\n\ta.full = dfixed_const(dce6_get_dmif_bytes_per_request(wm) / 2);\n\tb1.full = dfixed_mul(a, disp_clk);\n\n\ta.full = dfixed_const(1000);\n\tsclk.full = dfixed_const(wm->sclk);\n\tsclk.full = dfixed_div(sclk, a);\n\ta.full = dfixed_const(dce6_get_dmif_bytes_per_request(wm));\n\tb2.full = dfixed_mul(a, sclk);\n\n\ta.full = dfixed_const(10);\n\tdisp_clk_request_efficiency.full = dfixed_const(8);\n\tdisp_clk_request_efficiency.full = dfixed_div(disp_clk_request_efficiency, a);\n\n\tmin_bandwidth = min(dfixed_trunc(b1), dfixed_trunc(b2));\n\n\ta.full = dfixed_const(min_bandwidth);\n\tbandwidth.full = dfixed_mul(a, disp_clk_request_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 dce6_available_bandwidth(struct dce6_wm_params *wm)\n{\n\t \n\tu32 dram_bandwidth = dce6_dram_bandwidth(wm);\n\tu32 data_return_bandwidth = dce6_data_return_bandwidth(wm);\n\tu32 dmif_req_bandwidth = dce6_dmif_request_bandwidth(wm);\n\n\treturn min(dram_bandwidth, min(data_return_bandwidth, dmif_req_bandwidth));\n}\n\nstatic u32 dce6_average_bandwidth(struct dce6_wm_params *wm)\n{\n\t \n\tfixed20_12 bpp;\n\tfixed20_12 line_time;\n\tfixed20_12 src_width;\n\tfixed20_12 bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tline_time.full = dfixed_const(wm->active_time + wm->blank_time);\n\tline_time.full = dfixed_div(line_time, a);\n\tbpp.full = dfixed_const(wm->bytes_per_pixel);\n\tsrc_width.full = dfixed_const(wm->src_width);\n\tbandwidth.full = dfixed_mul(src_width, bpp);\n\tbandwidth.full = dfixed_mul(bandwidth, wm->vsc);\n\tbandwidth.full = dfixed_div(bandwidth, line_time);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 dce6_latency_watermark(struct dce6_wm_params *wm)\n{\n\t \n\tu32 mc_latency = 2000;  \n\tu32 available_bandwidth = dce6_available_bandwidth(wm);\n\tu32 worst_chunk_return_time = (512 * 8 * 1000) / available_bandwidth;\n\tu32 cursor_line_pair_return_time = (128 * 4 * 1000) / available_bandwidth;\n\tu32 dc_latency = 40000000 / wm->disp_clk;  \n\tu32 other_heads_data_return_time = ((wm->num_heads + 1) * worst_chunk_return_time) +\n\t\t(wm->num_heads * cursor_line_pair_return_time);\n\tu32 latency = mc_latency + other_heads_data_return_time + dc_latency;\n\tu32 max_src_lines_per_dst_line, lb_fill_bw, line_fill_time;\n\tu32 tmp, dmif_size = 12288;\n\tfixed20_12 a, b, c;\n\n\tif (wm->num_heads == 0)\n\t\treturn 0;\n\n\ta.full = dfixed_const(2);\n\tb.full = dfixed_const(1);\n\tif ((wm->vsc.full > a.full) ||\n\t    ((wm->vsc.full > b.full) && (wm->vtaps >= 3)) ||\n\t    (wm->vtaps >= 5) ||\n\t    ((wm->vsc.full >= a.full) && wm->interlaced))\n\t\tmax_src_lines_per_dst_line = 4;\n\telse\n\t\tmax_src_lines_per_dst_line = 2;\n\n\ta.full = dfixed_const(available_bandwidth);\n\tb.full = dfixed_const(wm->num_heads);\n\ta.full = dfixed_div(a, b);\n\ttmp = div_u64((u64) dmif_size * (u64) wm->disp_clk, mc_latency + 512);\n\ttmp = min(dfixed_trunc(a), tmp);\n\n\tlb_fill_bw = min(tmp, wm->disp_clk * wm->bytes_per_pixel / 1000);\n\n\ta.full = dfixed_const(max_src_lines_per_dst_line * wm->src_width * wm->bytes_per_pixel);\n\tb.full = dfixed_const(1000);\n\tc.full = dfixed_const(lb_fill_bw);\n\tb.full = dfixed_div(c, b);\n\ta.full = dfixed_div(a, b);\n\tline_fill_time = dfixed_trunc(a);\n\n\tif (line_fill_time < wm->active_time)\n\t\treturn latency;\n\telse\n\t\treturn latency + (line_fill_time - wm->active_time);\n\n}\n\nstatic bool dce6_average_bandwidth_vs_dram_bandwidth_for_display(struct dce6_wm_params *wm)\n{\n\tif (dce6_average_bandwidth(wm) <=\n\t    (dce6_dram_bandwidth_for_display(wm) / wm->num_heads))\n\t\treturn true;\n\telse\n\t\treturn false;\n};\n\nstatic bool dce6_average_bandwidth_vs_available_bandwidth(struct dce6_wm_params *wm)\n{\n\tif (dce6_average_bandwidth(wm) <=\n\t    (dce6_available_bandwidth(wm) / wm->num_heads))\n\t\treturn true;\n\telse\n\t\treturn false;\n};\n\nstatic bool dce6_check_latency_hiding(struct dce6_wm_params *wm)\n{\n\tu32 lb_partitions = wm->lb_size / wm->src_width;\n\tu32 line_time = wm->active_time + wm->blank_time;\n\tu32 latency_tolerant_lines;\n\tu32 latency_hiding;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1);\n\tif (wm->vsc.full > a.full)\n\t\tlatency_tolerant_lines = 1;\n\telse {\n\t\tif (lb_partitions <= (wm->vtaps + 1))\n\t\t\tlatency_tolerant_lines = 1;\n\t\telse\n\t\t\tlatency_tolerant_lines = 2;\n\t}\n\n\tlatency_hiding = (latency_tolerant_lines * line_time + wm->blank_time);\n\n\tif (dce6_latency_watermark(wm) <= latency_hiding)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void dce6_program_watermarks(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_crtc *radeon_crtc,\n\t\t\t\t\t u32 lb_size, u32 num_heads)\n{\n\tstruct drm_display_mode *mode = &radeon_crtc->base.mode;\n\tstruct dce6_wm_params wm_low, wm_high;\n\tu32 dram_channels;\n\tu32 active_time;\n\tu32 line_time = 0;\n\tu32 latency_watermark_a = 0, latency_watermark_b = 0;\n\tu32 priority_a_mark = 0, priority_b_mark = 0;\n\tu32 priority_a_cnt = PRIORITY_OFF;\n\tu32 priority_b_cnt = PRIORITY_OFF;\n\tu32 tmp, arb_control3;\n\tfixed20_12 a, b, c;\n\n\tif (radeon_crtc->base.enabled && num_heads && mode) {\n\t\tactive_time = (u32) div_u64((u64)mode->crtc_hdisplay * 1000000,\n\t\t\t\t\t    (u32)mode->clock);\n\t\tline_time = (u32) div_u64((u64)mode->crtc_htotal * 1000000,\n\t\t\t\t\t  (u32)mode->clock);\n\t\tline_time = min(line_time, (u32)65535);\n\t\tpriority_a_cnt = 0;\n\t\tpriority_b_cnt = 0;\n\n\t\tif (rdev->family == CHIP_ARUBA)\n\t\t\tdram_channels = evergreen_get_number_of_dram_channels(rdev);\n\t\telse\n\t\t\tdram_channels = si_get_number_of_dram_channels(rdev);\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t\twm_high.yclk =\n\t\t\t\tradeon_dpm_get_mclk(rdev, false) * 10;\n\t\t\twm_high.sclk =\n\t\t\t\tradeon_dpm_get_sclk(rdev, false) * 10;\n\t\t} else {\n\t\t\twm_high.yclk = rdev->pm.current_mclk * 10;\n\t\t\twm_high.sclk = rdev->pm.current_sclk * 10;\n\t\t}\n\n\t\twm_high.disp_clk = mode->clock;\n\t\twm_high.src_width = mode->crtc_hdisplay;\n\t\twm_high.active_time = active_time;\n\t\twm_high.blank_time = line_time - wm_high.active_time;\n\t\twm_high.interlaced = false;\n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\twm_high.interlaced = true;\n\t\twm_high.vsc = radeon_crtc->vsc;\n\t\twm_high.vtaps = 1;\n\t\tif (radeon_crtc->rmx_type != RMX_OFF)\n\t\t\twm_high.vtaps = 2;\n\t\twm_high.bytes_per_pixel = 4;  \n\t\twm_high.lb_size = lb_size;\n\t\twm_high.dram_channels = dram_channels;\n\t\twm_high.num_heads = num_heads;\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t\twm_low.yclk =\n\t\t\t\tradeon_dpm_get_mclk(rdev, true) * 10;\n\t\t\twm_low.sclk =\n\t\t\t\tradeon_dpm_get_sclk(rdev, true) * 10;\n\t\t} else {\n\t\t\twm_low.yclk = rdev->pm.current_mclk * 10;\n\t\t\twm_low.sclk = rdev->pm.current_sclk * 10;\n\t\t}\n\n\t\twm_low.disp_clk = mode->clock;\n\t\twm_low.src_width = mode->crtc_hdisplay;\n\t\twm_low.active_time = active_time;\n\t\twm_low.blank_time = line_time - wm_low.active_time;\n\t\twm_low.interlaced = false;\n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\twm_low.interlaced = true;\n\t\twm_low.vsc = radeon_crtc->vsc;\n\t\twm_low.vtaps = 1;\n\t\tif (radeon_crtc->rmx_type != RMX_OFF)\n\t\t\twm_low.vtaps = 2;\n\t\twm_low.bytes_per_pixel = 4;  \n\t\twm_low.lb_size = lb_size;\n\t\twm_low.dram_channels = dram_channels;\n\t\twm_low.num_heads = num_heads;\n\n\t\t \n\t\tlatency_watermark_a = min(dce6_latency_watermark(&wm_high), (u32)65535);\n\t\t \n\t\tlatency_watermark_b = min(dce6_latency_watermark(&wm_low), (u32)65535);\n\n\t\t \n\t\t \n\t\tif (!dce6_average_bandwidth_vs_dram_bandwidth_for_display(&wm_high) ||\n\t\t    !dce6_average_bandwidth_vs_available_bandwidth(&wm_high) ||\n\t\t    !dce6_check_latency_hiding(&wm_high) ||\n\t\t    (rdev->disp_priority == 2)) {\n\t\t\tDRM_DEBUG_KMS(\"force priority to high\\n\");\n\t\t\tpriority_a_cnt |= PRIORITY_ALWAYS_ON;\n\t\t\tpriority_b_cnt |= PRIORITY_ALWAYS_ON;\n\t\t}\n\t\tif (!dce6_average_bandwidth_vs_dram_bandwidth_for_display(&wm_low) ||\n\t\t    !dce6_average_bandwidth_vs_available_bandwidth(&wm_low) ||\n\t\t    !dce6_check_latency_hiding(&wm_low) ||\n\t\t    (rdev->disp_priority == 2)) {\n\t\t\tDRM_DEBUG_KMS(\"force priority to high\\n\");\n\t\t\tpriority_a_cnt |= PRIORITY_ALWAYS_ON;\n\t\t\tpriority_b_cnt |= PRIORITY_ALWAYS_ON;\n\t\t}\n\n\t\ta.full = dfixed_const(1000);\n\t\tb.full = dfixed_const(mode->clock);\n\t\tb.full = dfixed_div(b, a);\n\t\tc.full = dfixed_const(latency_watermark_a);\n\t\tc.full = dfixed_mul(c, b);\n\t\tc.full = dfixed_mul(c, radeon_crtc->hsc);\n\t\tc.full = dfixed_div(c, a);\n\t\ta.full = dfixed_const(16);\n\t\tc.full = dfixed_div(c, a);\n\t\tpriority_a_mark = dfixed_trunc(c);\n\t\tpriority_a_cnt |= priority_a_mark & PRIORITY_MARK_MASK;\n\n\t\ta.full = dfixed_const(1000);\n\t\tb.full = dfixed_const(mode->clock);\n\t\tb.full = dfixed_div(b, a);\n\t\tc.full = dfixed_const(latency_watermark_b);\n\t\tc.full = dfixed_mul(c, b);\n\t\tc.full = dfixed_mul(c, radeon_crtc->hsc);\n\t\tc.full = dfixed_div(c, a);\n\t\ta.full = dfixed_const(16);\n\t\tc.full = dfixed_div(c, a);\n\t\tpriority_b_mark = dfixed_trunc(c);\n\t\tpriority_b_cnt |= priority_b_mark & PRIORITY_MARK_MASK;\n\n\t\t \n\t\tradeon_crtc->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode->crtc_hdisplay);\n\t}\n\n\t \n\tarb_control3 = RREG32(DPG_PIPE_ARBITRATION_CONTROL3 + radeon_crtc->crtc_offset);\n\ttmp = arb_control3;\n\ttmp &= ~LATENCY_WATERMARK_MASK(3);\n\ttmp |= LATENCY_WATERMARK_MASK(1);\n\tWREG32(DPG_PIPE_ARBITRATION_CONTROL3 + radeon_crtc->crtc_offset, tmp);\n\tWREG32(DPG_PIPE_LATENCY_CONTROL + radeon_crtc->crtc_offset,\n\t       (LATENCY_LOW_WATERMARK(latency_watermark_a) |\n\t\tLATENCY_HIGH_WATERMARK(line_time)));\n\t \n\ttmp = RREG32(DPG_PIPE_ARBITRATION_CONTROL3 + radeon_crtc->crtc_offset);\n\ttmp &= ~LATENCY_WATERMARK_MASK(3);\n\ttmp |= LATENCY_WATERMARK_MASK(2);\n\tWREG32(DPG_PIPE_ARBITRATION_CONTROL3 + radeon_crtc->crtc_offset, tmp);\n\tWREG32(DPG_PIPE_LATENCY_CONTROL + radeon_crtc->crtc_offset,\n\t       (LATENCY_LOW_WATERMARK(latency_watermark_b) |\n\t\tLATENCY_HIGH_WATERMARK(line_time)));\n\t \n\tWREG32(DPG_PIPE_ARBITRATION_CONTROL3 + radeon_crtc->crtc_offset, arb_control3);\n\n\t \n\tWREG32(PRIORITY_A_CNT + radeon_crtc->crtc_offset, priority_a_cnt);\n\tWREG32(PRIORITY_B_CNT + radeon_crtc->crtc_offset, priority_b_cnt);\n\n\t \n\tradeon_crtc->line_time = line_time;\n\tradeon_crtc->wm_high = latency_watermark_a;\n\tradeon_crtc->wm_low = latency_watermark_b;\n}\n\nvoid dce6_bandwidth_update(struct radeon_device *rdev)\n{\n\tstruct drm_display_mode *mode0 = NULL;\n\tstruct drm_display_mode *mode1 = NULL;\n\tu32 num_heads = 0, lb_size;\n\tint i;\n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (rdev->mode_info.crtcs[i]->base.enabled)\n\t\t\tnum_heads++;\n\t}\n\tfor (i = 0; i < rdev->num_crtc; i += 2) {\n\t\tmode0 = &rdev->mode_info.crtcs[i]->base.mode;\n\t\tmode1 = &rdev->mode_info.crtcs[i+1]->base.mode;\n\t\tlb_size = dce6_line_buffer_adjust(rdev, rdev->mode_info.crtcs[i], mode0, mode1);\n\t\tdce6_program_watermarks(rdev, rdev->mode_info.crtcs[i], lb_size, num_heads);\n\t\tlb_size = dce6_line_buffer_adjust(rdev, rdev->mode_info.crtcs[i+1], mode1, mode0);\n\t\tdce6_program_watermarks(rdev, rdev->mode_info.crtcs[i+1], lb_size, num_heads);\n\t}\n}\n\n \nstatic void si_tiling_mode_table_init(struct radeon_device *rdev)\n{\n\tu32 *tile = rdev->config.si.tile_mode_array;\n\tconst u32 num_tile_mode_states =\n\t\t\tARRAY_SIZE(rdev->config.si.tile_mode_array);\n\tu32 reg_offset, split_equal_to_row_size;\n\n\tswitch (rdev->config.si.mem_row_size_in_kb) {\n\tcase 1:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_1KB;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_2KB;\n\t\tbreak;\n\tcase 4:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_4KB;\n\t\tbreak;\n\t}\n\n\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\ttile[reg_offset] = 0;\n\n\tswitch(rdev->family) {\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\t\t \n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[4] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[5] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[6] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\t\t \n\t\ttile[7] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[11] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[12] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\t\t \n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\t\t \n\t\ttile[15] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\t\t \n\t\ttile[16] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\t\t \n\t\ttile[17] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\t\t \n\t\ttile[21] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[22] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[23] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[24] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[25] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_1KB) |\n\t\t\t   NUM_BANKS(ADDR_SURF_8_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_TILE_MODE0 + (reg_offset * 4), tile[reg_offset]);\n\t\tbreak;\n\n\tcase CHIP_VERDE:\n\tcase CHIP_OLAND:\n\tcase CHIP_HAINAN:\n\t\t \n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[4] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[5] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[6] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[7] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[11] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[12] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[15] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[16] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[17] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[21] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[22] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4));\n\t\t \n\t\ttile[23] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[24] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2));\n\t\t \n\t\ttile[25] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_1KB) |\n\t\t\t   NUM_BANKS(ADDR_SURF_8_BANK) |\n\t\t\t   BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_TILE_MODE0 + (reg_offset * 4), tile[reg_offset]);\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_ERROR(\"unknown asic: 0x%x\\n\", rdev->family);\n\t}\n}\n\nstatic void si_select_se_sh(struct radeon_device *rdev,\n\t\t\t    u32 se_num, u32 sh_num)\n{\n\tu32 data = INSTANCE_BROADCAST_WRITES;\n\n\tif ((se_num == 0xffffffff) && (sh_num == 0xffffffff))\n\t\tdata |= SH_BROADCAST_WRITES | SE_BROADCAST_WRITES;\n\telse if (se_num == 0xffffffff)\n\t\tdata |= SE_BROADCAST_WRITES | SH_INDEX(sh_num);\n\telse if (sh_num == 0xffffffff)\n\t\tdata |= SH_BROADCAST_WRITES | SE_INDEX(se_num);\n\telse\n\t\tdata |= SH_INDEX(sh_num) | SE_INDEX(se_num);\n\tWREG32(GRBM_GFX_INDEX, data);\n}\n\nstatic u32 si_create_bitmask(u32 bit_width)\n{\n\tu32 i, mask = 0;\n\n\tfor (i = 0; i < bit_width; i++) {\n\t\tmask <<= 1;\n\t\tmask |= 1;\n\t}\n\treturn mask;\n}\n\nstatic u32 si_get_cu_enabled(struct radeon_device *rdev, u32 cu_per_sh)\n{\n\tu32 data, mask;\n\n\tdata = RREG32(CC_GC_SHADER_ARRAY_CONFIG);\n\tif (data & 1)\n\t\tdata &= INACTIVE_CUS_MASK;\n\telse\n\t\tdata = 0;\n\tdata |= RREG32(GC_USER_SHADER_ARRAY_CONFIG);\n\n\tdata >>= INACTIVE_CUS_SHIFT;\n\n\tmask = si_create_bitmask(cu_per_sh);\n\n\treturn ~data & mask;\n}\n\nstatic void si_setup_spi(struct radeon_device *rdev,\n\t\t\t u32 se_num, u32 sh_per_se,\n\t\t\t u32 cu_per_sh)\n{\n\tint i, j, k;\n\tu32 data, mask, active_cu;\n\n\tfor (i = 0; i < se_num; i++) {\n\t\tfor (j = 0; j < sh_per_se; j++) {\n\t\t\tsi_select_se_sh(rdev, i, j);\n\t\t\tdata = RREG32(SPI_STATIC_THREAD_MGMT_3);\n\t\t\tactive_cu = si_get_cu_enabled(rdev, cu_per_sh);\n\n\t\t\tmask = 1;\n\t\t\tfor (k = 0; k < 16; k++) {\n\t\t\t\tmask <<= k;\n\t\t\t\tif (active_cu & mask) {\n\t\t\t\t\tdata &= ~mask;\n\t\t\t\t\tWREG32(SPI_STATIC_THREAD_MGMT_3, data);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsi_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n}\n\nstatic u32 si_get_rb_disabled(struct radeon_device *rdev,\n\t\t\t      u32 max_rb_num_per_se,\n\t\t\t      u32 sh_per_se)\n{\n\tu32 data, mask;\n\n\tdata = RREG32(CC_RB_BACKEND_DISABLE);\n\tif (data & 1)\n\t\tdata &= BACKEND_DISABLE_MASK;\n\telse\n\t\tdata = 0;\n\tdata |= RREG32(GC_USER_RB_BACKEND_DISABLE);\n\n\tdata >>= BACKEND_DISABLE_SHIFT;\n\n\tmask = si_create_bitmask(max_rb_num_per_se / sh_per_se);\n\n\treturn data & mask;\n}\n\nstatic void si_setup_rb(struct radeon_device *rdev,\n\t\t\tu32 se_num, u32 sh_per_se,\n\t\t\tu32 max_rb_num_per_se)\n{\n\tint i, j;\n\tu32 data, mask;\n\tu32 disabled_rbs = 0;\n\tu32 enabled_rbs = 0;\n\n\tfor (i = 0; i < se_num; i++) {\n\t\tfor (j = 0; j < sh_per_se; j++) {\n\t\t\tsi_select_se_sh(rdev, i, j);\n\t\t\tdata = si_get_rb_disabled(rdev, max_rb_num_per_se, sh_per_se);\n\t\t\tdisabled_rbs |= data << ((i * sh_per_se + j) * TAHITI_RB_BITMAP_WIDTH_PER_SH);\n\t\t}\n\t}\n\tsi_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\n\tmask = 1;\n\tfor (i = 0; i < max_rb_num_per_se * se_num; i++) {\n\t\tif (!(disabled_rbs & mask))\n\t\t\tenabled_rbs |= mask;\n\t\tmask <<= 1;\n\t}\n\n\trdev->config.si.backend_enable_mask = enabled_rbs;\n\n\tfor (i = 0; i < se_num; i++) {\n\t\tsi_select_se_sh(rdev, i, 0xffffffff);\n\t\tdata = 0;\n\t\tfor (j = 0; j < sh_per_se; j++) {\n\t\t\tswitch (enabled_rbs & 3) {\n\t\t\tcase 1:\n\t\t\t\tdata |= (RASTER_CONFIG_RB_MAP_0 << (i * sh_per_se + j) * 2);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdata |= (RASTER_CONFIG_RB_MAP_3 << (i * sh_per_se + j) * 2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tdefault:\n\t\t\t\tdata |= (RASTER_CONFIG_RB_MAP_2 << (i * sh_per_se + j) * 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenabled_rbs >>= 2;\n\t\t}\n\t\tWREG32(PA_SC_RASTER_CONFIG, data);\n\t}\n\tsi_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n}\n\nstatic void si_gpu_init(struct radeon_device *rdev)\n{\n\tu32 gb_addr_config = 0;\n\tu32 mc_arb_ramcfg;\n\tu32 sx_debug_1;\n\tu32 hdp_host_path_cntl;\n\tu32 tmp;\n\tint i, j;\n\n\tswitch (rdev->family) {\n\tcase CHIP_TAHITI:\n\t\trdev->config.si.max_shader_engines = 2;\n\t\trdev->config.si.max_tile_pipes = 12;\n\t\trdev->config.si.max_cu_per_sh = 8;\n\t\trdev->config.si.max_sh_per_se = 2;\n\t\trdev->config.si.max_backends_per_se = 4;\n\t\trdev->config.si.max_texture_channel_caches = 12;\n\t\trdev->config.si.max_gprs = 256;\n\t\trdev->config.si.max_gs_threads = 32;\n\t\trdev->config.si.max_hw_contexts = 8;\n\n\t\trdev->config.si.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.si.sc_prim_fifo_size_backend = 0x100;\n\t\trdev->config.si.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.si.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TAHITI_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_PITCAIRN:\n\t\trdev->config.si.max_shader_engines = 2;\n\t\trdev->config.si.max_tile_pipes = 8;\n\t\trdev->config.si.max_cu_per_sh = 5;\n\t\trdev->config.si.max_sh_per_se = 2;\n\t\trdev->config.si.max_backends_per_se = 4;\n\t\trdev->config.si.max_texture_channel_caches = 8;\n\t\trdev->config.si.max_gprs = 256;\n\t\trdev->config.si.max_gs_threads = 32;\n\t\trdev->config.si.max_hw_contexts = 8;\n\n\t\trdev->config.si.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.si.sc_prim_fifo_size_backend = 0x100;\n\t\trdev->config.si.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.si.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TAHITI_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_VERDE:\n\tdefault:\n\t\trdev->config.si.max_shader_engines = 1;\n\t\trdev->config.si.max_tile_pipes = 4;\n\t\trdev->config.si.max_cu_per_sh = 5;\n\t\trdev->config.si.max_sh_per_se = 2;\n\t\trdev->config.si.max_backends_per_se = 4;\n\t\trdev->config.si.max_texture_channel_caches = 4;\n\t\trdev->config.si.max_gprs = 256;\n\t\trdev->config.si.max_gs_threads = 32;\n\t\trdev->config.si.max_hw_contexts = 8;\n\n\t\trdev->config.si.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.si.sc_prim_fifo_size_backend = 0x40;\n\t\trdev->config.si.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.si.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = VERDE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\trdev->config.si.max_shader_engines = 1;\n\t\trdev->config.si.max_tile_pipes = 4;\n\t\trdev->config.si.max_cu_per_sh = 6;\n\t\trdev->config.si.max_sh_per_se = 1;\n\t\trdev->config.si.max_backends_per_se = 2;\n\t\trdev->config.si.max_texture_channel_caches = 4;\n\t\trdev->config.si.max_gprs = 256;\n\t\trdev->config.si.max_gs_threads = 16;\n\t\trdev->config.si.max_hw_contexts = 8;\n\n\t\trdev->config.si.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.si.sc_prim_fifo_size_backend = 0x40;\n\t\trdev->config.si.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.si.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = VERDE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_HAINAN:\n\t\trdev->config.si.max_shader_engines = 1;\n\t\trdev->config.si.max_tile_pipes = 4;\n\t\trdev->config.si.max_cu_per_sh = 5;\n\t\trdev->config.si.max_sh_per_se = 1;\n\t\trdev->config.si.max_backends_per_se = 1;\n\t\trdev->config.si.max_texture_channel_caches = 2;\n\t\trdev->config.si.max_gprs = 256;\n\t\trdev->config.si.max_gs_threads = 16;\n\t\trdev->config.si.max_hw_contexts = 8;\n\n\t\trdev->config.si.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.si.sc_prim_fifo_size_backend = 0x40;\n\t\trdev->config.si.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.si.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = HAINAN_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\n\tWREG32(GRBM_CNTL, GRBM_READ_TIMEOUT(0xff));\n\tWREG32(SRBM_INT_CNTL, 1);\n\tWREG32(SRBM_INT_ACK, 1);\n\n\tevergreen_fix_pci_max_read_req_size(rdev);\n\n\tWREG32(BIF_FB_EN, FB_READ_EN | FB_WRITE_EN);\n\n\tRREG32(MC_SHARED_CHMAP);\n\tmc_arb_ramcfg = RREG32(MC_ARB_RAMCFG);\n\n\trdev->config.si.num_tile_pipes = rdev->config.si.max_tile_pipes;\n\trdev->config.si.mem_max_burst_length_bytes = 256;\n\ttmp = (mc_arb_ramcfg & NOOFCOLS_MASK) >> NOOFCOLS_SHIFT;\n\trdev->config.si.mem_row_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;\n\tif (rdev->config.si.mem_row_size_in_kb > 4)\n\t\trdev->config.si.mem_row_size_in_kb = 4;\n\t \n\trdev->config.si.shader_engine_tile_size = 32;\n\trdev->config.si.num_gpus = 1;\n\trdev->config.si.multi_gpu_tile_size = 64;\n\n\t \n\tgb_addr_config &= ~ROW_SIZE_MASK;\n\tswitch (rdev->config.si.mem_row_size_in_kb) {\n\tcase 1:\n\tdefault:\n\t\tgb_addr_config |= ROW_SIZE(0);\n\t\tbreak;\n\tcase 2:\n\t\tgb_addr_config |= ROW_SIZE(1);\n\t\tbreak;\n\tcase 4:\n\t\tgb_addr_config |= ROW_SIZE(2);\n\t\tbreak;\n\t}\n\n\t \n\trdev->config.si.tile_config = 0;\n\tswitch (rdev->config.si.num_tile_pipes) {\n\tcase 1:\n\t\trdev->config.si.tile_config |= (0 << 0);\n\t\tbreak;\n\tcase 2:\n\t\trdev->config.si.tile_config |= (1 << 0);\n\t\tbreak;\n\tcase 4:\n\t\trdev->config.si.tile_config |= (2 << 0);\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\t \n\t\trdev->config.si.tile_config |= (3 << 0);\n\t\tbreak;\n\t}\n\tswitch ((mc_arb_ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) {\n\tcase 0:  \n\t\trdev->config.si.tile_config |= 0 << 4;\n\t\tbreak;\n\tcase 1:  \n\t\trdev->config.si.tile_config |= 1 << 4;\n\t\tbreak;\n\tcase 2:  \n\tdefault:\n\t\trdev->config.si.tile_config |= 2 << 4;\n\t\tbreak;\n\t}\n\trdev->config.si.tile_config |=\n\t\t((gb_addr_config & PIPE_INTERLEAVE_SIZE_MASK) >> PIPE_INTERLEAVE_SIZE_SHIFT) << 8;\n\trdev->config.si.tile_config |=\n\t\t((gb_addr_config & ROW_SIZE_MASK) >> ROW_SIZE_SHIFT) << 12;\n\n\tWREG32(GB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMIF_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMIF_ADDR_CALC, gb_addr_config);\n\tWREG32(HDP_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMA_TILING_CONFIG + DMA0_REGISTER_OFFSET, gb_addr_config);\n\tWREG32(DMA_TILING_CONFIG + DMA1_REGISTER_OFFSET, gb_addr_config);\n\tif (rdev->has_uvd) {\n\t\tWREG32(UVD_UDEC_ADDR_CONFIG, gb_addr_config);\n\t\tWREG32(UVD_UDEC_DB_ADDR_CONFIG, gb_addr_config);\n\t\tWREG32(UVD_UDEC_DBW_ADDR_CONFIG, gb_addr_config);\n\t}\n\n\tsi_tiling_mode_table_init(rdev);\n\n\tsi_setup_rb(rdev, rdev->config.si.max_shader_engines,\n\t\t    rdev->config.si.max_sh_per_se,\n\t\t    rdev->config.si.max_backends_per_se);\n\n\tsi_setup_spi(rdev, rdev->config.si.max_shader_engines,\n\t\t     rdev->config.si.max_sh_per_se,\n\t\t     rdev->config.si.max_cu_per_sh);\n\n\trdev->config.si.active_cus = 0;\n\tfor (i = 0; i < rdev->config.si.max_shader_engines; i++) {\n\t\tfor (j = 0; j < rdev->config.si.max_sh_per_se; j++) {\n\t\t\trdev->config.si.active_cus +=\n\t\t\t\thweight32(si_get_cu_active_bitmap(rdev, i, j));\n\t\t}\n\t}\n\n\t \n\tWREG32(CP_QUEUE_THRESHOLDS, (ROQ_IB1_START(0x16) |\n\t\t\t\t     ROQ_IB2_START(0x2b)));\n\tWREG32(CP_MEQ_THRESHOLDS, MEQ1_START(0x30) | MEQ2_START(0x60));\n\n\tsx_debug_1 = RREG32(SX_DEBUG_1);\n\tWREG32(SX_DEBUG_1, sx_debug_1);\n\n\tWREG32(SPI_CONFIG_CNTL_1, VTX_DONE_DELAY(4));\n\n\tWREG32(PA_SC_FIFO_SIZE, (SC_FRONTEND_PRIM_FIFO_SIZE(rdev->config.si.sc_prim_fifo_size_frontend) |\n\t\t\t\t SC_BACKEND_PRIM_FIFO_SIZE(rdev->config.si.sc_prim_fifo_size_backend) |\n\t\t\t\t SC_HIZ_TILE_FIFO_SIZE(rdev->config.si.sc_hiz_tile_fifo_size) |\n\t\t\t\t SC_EARLYZ_TILE_FIFO_SIZE(rdev->config.si.sc_earlyz_tile_fifo_size)));\n\n\tWREG32(VGT_NUM_INSTANCES, 1);\n\n\tWREG32(CP_PERFMON_CNTL, 0);\n\n\tWREG32(SQ_CONFIG, 0);\n\n\tWREG32(PA_SC_FORCE_EOV_MAX_CNTS, (FORCE_EOV_MAX_CLK_CNT(4095) |\n\t\t\t\t\t  FORCE_EOV_MAX_REZ_CNT(255)));\n\n\tWREG32(VGT_CACHE_INVALIDATION, CACHE_INVALIDATION(VC_AND_TC) |\n\t       AUTO_INVLD_EN(ES_AND_GS_AUTO));\n\n\tWREG32(VGT_GS_VERTEX_REUSE, 16);\n\tWREG32(PA_SC_LINE_STIPPLE_STATE, 0);\n\n\tWREG32(CB_PERFCOUNTER0_SELECT0, 0);\n\tWREG32(CB_PERFCOUNTER0_SELECT1, 0);\n\tWREG32(CB_PERFCOUNTER1_SELECT0, 0);\n\tWREG32(CB_PERFCOUNTER1_SELECT1, 0);\n\tWREG32(CB_PERFCOUNTER2_SELECT0, 0);\n\tWREG32(CB_PERFCOUNTER2_SELECT1, 0);\n\tWREG32(CB_PERFCOUNTER3_SELECT0, 0);\n\tWREG32(CB_PERFCOUNTER3_SELECT1, 0);\n\n\ttmp = RREG32(HDP_MISC_CNTL);\n\ttmp |= HDP_FLUSH_INVALIDATE_CACHE;\n\tWREG32(HDP_MISC_CNTL, tmp);\n\n\thdp_host_path_cntl = RREG32(HDP_HOST_PATH_CNTL);\n\tWREG32(HDP_HOST_PATH_CNTL, hdp_host_path_cntl);\n\n\tWREG32(PA_CL_ENHANCE, CLIP_VTX_REORDER_ENA | NUM_CLIP_SEQ(3));\n\n\tudelay(50);\n}\n\n \nstatic void si_scratch_init(struct radeon_device *rdev)\n{\n\tint i;\n\n\trdev->scratch.num_reg = 7;\n\trdev->scratch.reg_base = SCRATCH_REG0;\n\tfor (i = 0; i < rdev->scratch.num_reg; i++) {\n\t\trdev->scratch.free[i] = true;\n\t\trdev->scratch.reg[i] = rdev->scratch.reg_base + (i * 4);\n\t}\n}\n\nvoid si_fence_ring_emit(struct radeon_device *rdev,\n\t\t\tstruct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\tradeon_ring_write(ring, (CP_COHER_CNTL2 - PACKET3_SET_CONFIG_REG_START) >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\tradeon_ring_write(ring, PACKET3_TCL1_ACTION_ENA |\n\t\t\t  PACKET3_TC_ACTION_ENA |\n\t\t\t  PACKET3_SH_KCACHE_ACTION_ENA |\n\t\t\t  PACKET3_SH_ICACHE_ACTION_ENA);\n\tradeon_ring_write(ring, 0xFFFFFFFF);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 10);  \n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tradeon_ring_write(ring, EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) | EVENT_INDEX(5));\n\tradeon_ring_write(ring, lower_32_bits(addr));\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xff) | DATA_SEL(1) | INT_SEL(2));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, 0);\n}\n\n \nvoid si_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tunsigned vm_id = ib->vm ? ib->vm->ids[ib->ring].id : 0;\n\tu32 header;\n\n\tif (ib->is_const_ib) {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tradeon_ring_write(ring, 0);\n\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER_CONST, 2);\n\t} else {\n\t\tu32 next_rptr;\n\t\tif (ring->rptr_save_reg) {\n\t\t\tnext_rptr = ring->wptr + 3 + 4 + 8;\n\t\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\t\tradeon_ring_write(ring, ((ring->rptr_save_reg -\n\t\t\t\t\t\t  PACKET3_SET_CONFIG_REG_START) >> 2));\n\t\t\tradeon_ring_write(ring, next_rptr);\n\t\t} else if (rdev->wb.enabled) {\n\t\t\tnext_rptr = ring->wptr + 5 + 4 + 8;\n\t\t\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\t\t\tradeon_ring_write(ring, (1 << 8));\n\t\t\tradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\n\t\t\tradeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));\n\t\t\tradeon_ring_write(ring, next_rptr);\n\t\t}\n\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER, 2);\n\t}\n\n\tradeon_ring_write(ring, header);\n\tradeon_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t  (2 << 0) |\n#endif\n\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tradeon_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFFFF);\n\tradeon_ring_write(ring, ib->length_dw | (vm_id << 24));\n\n\tif (!ib->is_const_ib) {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tradeon_ring_write(ring, (CP_COHER_CNTL2 - PACKET3_SET_CONFIG_REG_START) >> 2);\n\t\tradeon_ring_write(ring, vm_id);\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\t\tradeon_ring_write(ring, PACKET3_TCL1_ACTION_ENA |\n\t\t\t\t  PACKET3_TC_ACTION_ENA |\n\t\t\t\t  PACKET3_SH_KCACHE_ACTION_ENA |\n\t\t\t\t  PACKET3_SH_ICACHE_ACTION_ENA);\n\t\tradeon_ring_write(ring, 0xFFFFFFFF);\n\t\tradeon_ring_write(ring, 0);\n\t\tradeon_ring_write(ring, 10);  \n\t}\n}\n\n \nstatic void si_cp_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32(CP_ME_CNTL, 0);\n\telse {\n\t\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\n\t\tWREG32(CP_ME_CNTL, (CP_ME_HALT | CP_PFP_HALT | CP_CE_HALT));\n\t\tWREG32(SCRATCH_UMSK, 0);\n\t\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;\n\t}\n\tudelay(50);\n}\n\nstatic int si_cp_load_microcode(struct radeon_device *rdev)\n{\n\tint i;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->ce_fw)\n\t\treturn -EINVAL;\n\n\tsi_cp_enable(rdev, false);\n\n\tif (rdev->new_fw) {\n\t\tconst struct gfx_firmware_header_v1_0 *pfp_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->pfp_fw->data;\n\t\tconst struct gfx_firmware_header_v1_0 *ce_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->ce_fw->data;\n\t\tconst struct gfx_firmware_header_v1_0 *me_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->me_fw->data;\n\t\tconst __le32 *fw_data;\n\t\tu32 fw_size;\n\n\t\tradeon_ucode_print_gfx_hdr(&pfp_hdr->header);\n\t\tradeon_ucode_print_gfx_hdr(&ce_hdr->header);\n\t\tradeon_ucode_print_gfx_hdr(&me_hdr->header);\n\n\t\t \n\t\tfw_data = (const __le32 *)\n\t\t\t(rdev->pfp_fw->data + le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_PFP_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\n\t\t \n\t\tfw_data = (const __le32 *)\n\t\t\t(rdev->ce_fw->data + le32_to_cpu(ce_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_CE_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\n\t\t \n\t\tfw_data = (const __be32 *)\n\t\t\t(rdev->me_fw->data + le32_to_cpu(me_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_ME_RAM_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t} else {\n\t\tconst __be32 *fw_data;\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->pfp_fw->data;\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < SI_PFP_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->ce_fw->data;\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < SI_CE_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_CE_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->me_fw->data;\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t\tfor (i = 0; i < SI_PM4_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_ME_RAM_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t}\n\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tWREG32(CP_CE_UCODE_ADDR, 0);\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tWREG32(CP_ME_RAM_RADDR, 0);\n\treturn 0;\n}\n\nstatic int si_cp_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r, i;\n\n\tr = radeon_ring_lock(rdev, ring, 7 + 4);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_ME_INITIALIZE, 5));\n\tradeon_ring_write(ring, 0x1);\n\tradeon_ring_write(ring, 0x0);\n\tradeon_ring_write(ring, rdev->config.si.max_hw_contexts - 1);\n\tradeon_ring_write(ring, PACKET3_ME_INITIALIZE_DEVICE_ID(1));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_BASE, 2));\n\tradeon_ring_write(ring, PACKET3_BASE_INDEX(CE_PARTITION_BASE));\n\tradeon_ring_write(ring, 0xc000);\n\tradeon_ring_write(ring, 0xe000);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tsi_cp_enable(rdev, true);\n\n\tr = radeon_ring_lock(rdev, ring, si_default_size + 10);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tfor (i = 0; i < si_default_size; i++)\n\t\tradeon_ring_write(ring, si_default_state[i]);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tradeon_ring_write(ring, 0);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tradeon_ring_write(ring, 0x00000316);\n\tradeon_ring_write(ring, 0x0000000e);  \n\tradeon_ring_write(ring, 0x00000010);  \n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tfor (i = RADEON_RING_TYPE_GFX_INDEX; i <= CAYMAN_RING_TYPE_CP2_INDEX; ++i) {\n\t\tring = &rdev->ring[i];\n\t\tr = radeon_ring_lock(rdev, ring, 2);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\t\treturn r;\n\t\t}\n\n\t\t \n\t\tradeon_ring_write(ring, PACKET3_COMPUTE(PACKET3_CLEAR_STATE, 0));\n\t\tradeon_ring_write(ring, 0);\n\n\t\tradeon_ring_unlock_commit(rdev, ring, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void si_cp_fini(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tsi_cp_enable(rdev, false);\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tradeon_ring_fini(rdev, ring);\n\tradeon_scratch_free(rdev, ring->rptr_save_reg);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\tradeon_ring_fini(rdev, ring);\n\tradeon_scratch_free(rdev, ring->rptr_save_reg);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\tradeon_ring_fini(rdev, ring);\n\tradeon_scratch_free(rdev, ring->rptr_save_reg);\n}\n\nstatic int si_cp_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tint r;\n\n\tsi_enable_gui_idle_interrupt(rdev, false);\n\n\tWREG32(CP_SEM_WAIT_TIMER, 0x0);\n\tWREG32(CP_SEM_INCOMPLETE_TIMER_CNTL, 0x0);\n\n\t \n\tWREG32(CP_RB_WPTR_DELAY, 0);\n\n\tWREG32(CP_DEBUG, 0);\n\tWREG32(SCRATCH_ADDR, ((rdev->wb.gpu_addr + RADEON_WB_SCRATCH_OFFSET) >> 8) & 0xFFFFFFFF);\n\n\t \n\t \n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= BUF_SWAP_32BIT;\n#endif\n\tWREG32(CP_RB0_CNTL, tmp);\n\n\t \n\tWREG32(CP_RB0_CNTL, tmp | RB_RPTR_WR_ENA);\n\tring->wptr = 0;\n\tWREG32(CP_RB0_WPTR, ring->wptr);\n\n\t \n\tWREG32(CP_RB0_RPTR_ADDR, (rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(CP_RB0_RPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFF);\n\n\tif (rdev->wb.enabled)\n\t\tWREG32(SCRATCH_UMSK, 0xff);\n\telse {\n\t\ttmp |= RB_NO_UPDATE;\n\t\tWREG32(SCRATCH_UMSK, 0);\n\t}\n\n\tmdelay(1);\n\tWREG32(CP_RB0_CNTL, tmp);\n\n\tWREG32(CP_RB0_BASE, ring->gpu_addr >> 8);\n\n\t \n\t \n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= BUF_SWAP_32BIT;\n#endif\n\tWREG32(CP_RB1_CNTL, tmp);\n\n\t \n\tWREG32(CP_RB1_CNTL, tmp | RB_RPTR_WR_ENA);\n\tring->wptr = 0;\n\tWREG32(CP_RB1_WPTR, ring->wptr);\n\n\t \n\tWREG32(CP_RB1_RPTR_ADDR, (rdev->wb.gpu_addr + RADEON_WB_CP1_RPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(CP_RB1_RPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + RADEON_WB_CP1_RPTR_OFFSET) & 0xFF);\n\n\tmdelay(1);\n\tWREG32(CP_RB1_CNTL, tmp);\n\n\tWREG32(CP_RB1_BASE, ring->gpu_addr >> 8);\n\n\t \n\t \n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= BUF_SWAP_32BIT;\n#endif\n\tWREG32(CP_RB2_CNTL, tmp);\n\n\t \n\tWREG32(CP_RB2_CNTL, tmp | RB_RPTR_WR_ENA);\n\tring->wptr = 0;\n\tWREG32(CP_RB2_WPTR, ring->wptr);\n\n\t \n\tWREG32(CP_RB2_RPTR_ADDR, (rdev->wb.gpu_addr + RADEON_WB_CP2_RPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(CP_RB2_RPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + RADEON_WB_CP2_RPTR_OFFSET) & 0xFF);\n\n\tmdelay(1);\n\tWREG32(CP_RB2_CNTL, tmp);\n\n\tWREG32(CP_RB2_BASE, ring->gpu_addr >> 8);\n\n\t \n\tsi_cp_start(rdev);\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = true;\n\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = true;\n\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = true;\n\tr = radeon_ring_test(rdev, RADEON_RING_TYPE_GFX_INDEX, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX]);\n\tif (r) {\n\t\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;\n\t\treturn r;\n\t}\n\tr = radeon_ring_test(rdev, CAYMAN_RING_TYPE_CP1_INDEX, &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX]);\n\tif (r) {\n\t\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;\n\t}\n\tr = radeon_ring_test(rdev, CAYMAN_RING_TYPE_CP2_INDEX, &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX]);\n\tif (r) {\n\t\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;\n\t}\n\n\tsi_enable_gui_idle_interrupt(rdev, true);\n\n\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\n\n\treturn 0;\n}\n\nu32 si_gpu_check_soft_reset(struct radeon_device *rdev)\n{\n\tu32 reset_mask = 0;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(GRBM_STATUS);\n\tif (tmp & (PA_BUSY | SC_BUSY |\n\t\t   BCI_BUSY | SX_BUSY |\n\t\t   TA_BUSY | VGT_BUSY |\n\t\t   DB_BUSY | CB_BUSY |\n\t\t   GDS_BUSY | SPI_BUSY |\n\t\t   IA_BUSY | IA_BUSY_NO_DMA))\n\t\treset_mask |= RADEON_RESET_GFX;\n\n\tif (tmp & (CF_RQ_PENDING | PF_RQ_PENDING |\n\t\t   CP_BUSY | CP_COHERENCY_BUSY))\n\t\treset_mask |= RADEON_RESET_CP;\n\n\tif (tmp & GRBM_EE_BUSY)\n\t\treset_mask |= RADEON_RESET_GRBM | RADEON_RESET_GFX | RADEON_RESET_CP;\n\n\t \n\ttmp = RREG32(GRBM_STATUS2);\n\tif (tmp & (RLC_RQ_PENDING | RLC_BUSY))\n\t\treset_mask |= RADEON_RESET_RLC;\n\n\t \n\ttmp = RREG32(DMA_STATUS_REG + DMA0_REGISTER_OFFSET);\n\tif (!(tmp & DMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\t \n\ttmp = RREG32(DMA_STATUS_REG + DMA1_REGISTER_OFFSET);\n\tif (!(tmp & DMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA1;\n\n\t \n\ttmp = RREG32(SRBM_STATUS2);\n\tif (tmp & DMA_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\tif (tmp & DMA1_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA1;\n\n\t \n\ttmp = RREG32(SRBM_STATUS);\n\n\tif (tmp & IH_BUSY)\n\t\treset_mask |= RADEON_RESET_IH;\n\n\tif (tmp & SEM_BUSY)\n\t\treset_mask |= RADEON_RESET_SEM;\n\n\tif (tmp & GRBM_RQ_PENDING)\n\t\treset_mask |= RADEON_RESET_GRBM;\n\n\tif (tmp & VMC_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\tif (tmp & (MCB_BUSY | MCB_NON_DISPLAY_BUSY |\n\t\t   MCC_BUSY | MCD_BUSY))\n\t\treset_mask |= RADEON_RESET_MC;\n\n\tif (evergreen_is_display_hung(rdev))\n\t\treset_mask |= RADEON_RESET_DISPLAY;\n\n\t \n\ttmp = RREG32(VM_L2_STATUS);\n\tif (tmp & L2_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\t \n\tif (reset_mask & RADEON_RESET_MC) {\n\t\tDRM_DEBUG(\"MC busy: 0x%08X, clearing.\\n\", reset_mask);\n\t\treset_mask &= ~RADEON_RESET_MC;\n\t}\n\n\treturn reset_mask;\n}\n\nstatic void si_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)\n{\n\tstruct evergreen_mc_save save;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif (reset_mask == 0)\n\t\treturn;\n\n\tdev_info(rdev->dev, \"GPU softreset: 0x%08X\\n\", reset_mask);\n\n\tevergreen_print_gpu_status_regs(rdev);\n\tdev_info(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR));\n\tdev_info(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS));\n\n\t \n\tsi_fini_pg(rdev);\n\tsi_fini_cg(rdev);\n\n\t \n\tsi_rlc_stop(rdev);\n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT | CP_CE_HALT);\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\t \n\t\ttmp = RREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET, tmp);\n\t}\n\tif (reset_mask & RADEON_RESET_DMA1) {\n\t\t \n\t\ttmp = RREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET, tmp);\n\t}\n\n\tudelay(50);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\n\tif (reset_mask & (RADEON_RESET_GFX | RADEON_RESET_COMPUTE | RADEON_RESET_CP)) {\n\t\tgrbm_soft_reset = SOFT_RESET_CB |\n\t\t\tSOFT_RESET_DB |\n\t\t\tSOFT_RESET_GDS |\n\t\t\tSOFT_RESET_PA |\n\t\t\tSOFT_RESET_SC |\n\t\t\tSOFT_RESET_BCI |\n\t\t\tSOFT_RESET_SPI |\n\t\t\tSOFT_RESET_SX |\n\t\t\tSOFT_RESET_TC |\n\t\t\tSOFT_RESET_TA |\n\t\t\tSOFT_RESET_VGT |\n\t\t\tSOFT_RESET_IA;\n\t}\n\n\tif (reset_mask & RADEON_RESET_CP) {\n\t\tgrbm_soft_reset |= SOFT_RESET_CP | SOFT_RESET_VGT;\n\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA)\n\t\tsrbm_soft_reset |= SOFT_RESET_DMA;\n\n\tif (reset_mask & RADEON_RESET_DMA1)\n\t\tsrbm_soft_reset |= SOFT_RESET_DMA1;\n\n\tif (reset_mask & RADEON_RESET_DISPLAY)\n\t\tsrbm_soft_reset |= SOFT_RESET_DC;\n\n\tif (reset_mask & RADEON_RESET_RLC)\n\t\tgrbm_soft_reset |= SOFT_RESET_RLC;\n\n\tif (reset_mask & RADEON_RESET_SEM)\n\t\tsrbm_soft_reset |= SOFT_RESET_SEM;\n\n\tif (reset_mask & RADEON_RESET_IH)\n\t\tsrbm_soft_reset |= SOFT_RESET_IH;\n\n\tif (reset_mask & RADEON_RESET_GRBM)\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\n\tif (reset_mask & RADEON_RESET_VMC)\n\t\tsrbm_soft_reset |= SOFT_RESET_VMC;\n\n\tif (reset_mask & RADEON_RESET_MC)\n\t\tsrbm_soft_reset |= SOFT_RESET_MC;\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(rdev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(rdev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t}\n\n\t \n\tudelay(50);\n\n\tevergreen_mc_resume(rdev, &save);\n\tudelay(50);\n\n\tevergreen_print_gpu_status_regs(rdev);\n}\n\nstatic void si_set_clk_bypass_mode(struct radeon_device *rdev)\n{\n\tu32 tmp, i;\n\n\ttmp = RREG32(CG_SPLL_FUNC_CNTL);\n\ttmp |= SPLL_BYPASS_EN;\n\tWREG32(CG_SPLL_FUNC_CNTL, tmp);\n\n\ttmp = RREG32(CG_SPLL_FUNC_CNTL_2);\n\ttmp |= SPLL_CTLREQ_CHG;\n\tWREG32(CG_SPLL_FUNC_CNTL_2, tmp);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(SPLL_STATUS) & SPLL_CHG_STATUS)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\ttmp = RREG32(CG_SPLL_FUNC_CNTL_2);\n\ttmp &= ~(SPLL_CTLREQ_CHG | SCLK_MUX_UPDATE);\n\tWREG32(CG_SPLL_FUNC_CNTL_2, tmp);\n\n\ttmp = RREG32(MPLL_CNTL_MODE);\n\ttmp &= ~MPLL_MCLK_SEL;\n\tWREG32(MPLL_CNTL_MODE, tmp);\n}\n\nstatic void si_spll_powerdown(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(SPLL_CNTL_MODE);\n\ttmp |= SPLL_SW_DIR_CONTROL;\n\tWREG32(SPLL_CNTL_MODE, tmp);\n\n\ttmp = RREG32(CG_SPLL_FUNC_CNTL);\n\ttmp |= SPLL_RESET;\n\tWREG32(CG_SPLL_FUNC_CNTL, tmp);\n\n\ttmp = RREG32(CG_SPLL_FUNC_CNTL);\n\ttmp |= SPLL_SLEEP;\n\tWREG32(CG_SPLL_FUNC_CNTL, tmp);\n\n\ttmp = RREG32(SPLL_CNTL_MODE);\n\ttmp &= ~SPLL_SW_DIR_CONTROL;\n\tWREG32(SPLL_CNTL_MODE, tmp);\n}\n\nstatic void si_gpu_pci_config_reset(struct radeon_device *rdev)\n{\n\tstruct evergreen_mc_save save;\n\tu32 tmp, i;\n\n\tdev_info(rdev->dev, \"GPU pci config reset\\n\");\n\n\t \n\n\t \n\tsi_fini_pg(rdev);\n\tsi_fini_cg(rdev);\n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT | CP_CE_HALT);\n\t \n\ttmp = RREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET);\n\ttmp &= ~DMA_RB_ENABLE;\n\tWREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET, tmp);\n\t \n\ttmp = RREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET);\n\ttmp &= ~DMA_RB_ENABLE;\n\tWREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET, tmp);\n\t \n\n\t \n\tsi_rlc_stop(rdev);\n\n\tudelay(50);\n\n\t \n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timed out !\\n\");\n\t}\n\n\t \n\tsi_set_clk_bypass_mode(rdev);\n\t \n\tsi_spll_powerdown(rdev);\n\t \n\tpci_clear_master(rdev->pdev);\n\t \n\tradeon_pci_config_reset(rdev);\n\t \n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(CONFIG_MEMSIZE) != 0xffffffff)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nint si_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tu32 reset_mask;\n\n\tif (hard) {\n\t\tsi_gpu_pci_config_reset(rdev);\n\t\treturn 0;\n\t}\n\n\treset_mask = si_gpu_check_soft_reset(rdev);\n\n\tif (reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, true);\n\n\t \n\tsi_gpu_soft_reset(rdev, reset_mask);\n\n\treset_mask = si_gpu_check_soft_reset(rdev);\n\n\t \n\tif (reset_mask && radeon_hard_reset)\n\t\tsi_gpu_pci_config_reset(rdev);\n\n\treset_mask = si_gpu_check_soft_reset(rdev);\n\n\tif (!reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, false);\n\n\treturn 0;\n}\n\n \nbool si_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = si_gpu_check_soft_reset(rdev);\n\n\tif (!(reset_mask & (RADEON_RESET_GFX |\n\t\t\t    RADEON_RESET_COMPUTE |\n\t\t\t    RADEON_RESET_CP))) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\n \nstatic void si_mc_program(struct radeon_device *rdev)\n{\n\tstruct evergreen_mc_save save;\n\tu32 tmp;\n\tint i, j;\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\tWREG32(HDP_REG_COHERENCY_FLUSH_CNTL, 0);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (radeon_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\tif (!ASIC_IS_NODCE(rdev))\n\t\t \n\t\tWREG32(VGA_HDP_CONTROL, VGA_MEMORY_DISABLE);\n\t \n\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t       rdev->mc.vram_start >> 12);\n\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t       rdev->mc.vram_end >> 12);\n\tWREG32(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR,\n\t       rdev->vram_scratch.gpu_addr >> 12);\n\ttmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;\n\ttmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);\n\tWREG32(MC_VM_FB_LOCATION, tmp);\n\t \n\tWREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));\n\tWREG32(HDP_NONSURFACE_INFO, (2 << 7) | (1 << 30));\n\tWREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);\n\tWREG32(MC_VM_AGP_BASE, 0);\n\tWREG32(MC_VM_AGP_TOP, 0x0FFFFFFF);\n\tWREG32(MC_VM_AGP_BOT, 0x0FFFFFFF);\n\tif (radeon_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\tevergreen_mc_resume(rdev, &save);\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\t \n\t\trv515_vga_render_disable(rdev);\n\t}\n}\n\nvoid si_vram_gtt_location(struct radeon_device *rdev,\n\t\t\t  struct radeon_mc *mc)\n{\n\tif (mc->mc_vram_size > 0xFFC0000000ULL) {\n\t\t \n\t\tdev_warn(rdev->dev, \"limiting VRAM\\n\");\n\t\tmc->real_vram_size = 0xFFC0000000ULL;\n\t\tmc->mc_vram_size = 0xFFC0000000ULL;\n\t}\n\tradeon_vram_location(rdev, &rdev->mc, 0);\n\trdev->mc.gtt_base_align = 0;\n\tradeon_gtt_location(rdev, mc);\n}\n\nstatic int si_mc_init(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint chansize, numchan;\n\n\t \n\trdev->mc.vram_is_ddr = true;\n\ttmp = RREG32(MC_ARB_RAMCFG);\n\tif (tmp & CHANSIZE_OVERRIDE) {\n\t\tchansize = 16;\n\t} else if (tmp & CHANSIZE_MASK) {\n\t\tchansize = 64;\n\t} else {\n\t\tchansize = 32;\n\t}\n\ttmp = RREG32(MC_SHARED_CHMAP);\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\tnumchan = 1;\n\t\tbreak;\n\tcase 1:\n\t\tnumchan = 2;\n\t\tbreak;\n\tcase 2:\n\t\tnumchan = 4;\n\t\tbreak;\n\tcase 3:\n\t\tnumchan = 8;\n\t\tbreak;\n\tcase 4:\n\t\tnumchan = 3;\n\t\tbreak;\n\tcase 5:\n\t\tnumchan = 6;\n\t\tbreak;\n\tcase 6:\n\t\tnumchan = 10;\n\t\tbreak;\n\tcase 7:\n\t\tnumchan = 12;\n\t\tbreak;\n\tcase 8:\n\t\tnumchan = 16;\n\t\tbreak;\n\t}\n\trdev->mc.vram_width = numchan * chansize;\n\t \n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\t \n\ttmp = RREG32(CONFIG_MEMSIZE);\n\t \n\tif (tmp & 0xffff0000) {\n\t\tDRM_INFO(\"Probable bad vram size: 0x%08x\\n\", tmp);\n\t\tif (tmp & 0xffff)\n\t\t\ttmp &= 0xffff;\n\t}\n\trdev->mc.mc_vram_size = tmp * 1024ULL * 1024ULL;\n\trdev->mc.real_vram_size = rdev->mc.mc_vram_size;\n\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\tsi_vram_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n\n\treturn 0;\n}\n\n \nvoid si_pcie_gart_tlb_flush(struct radeon_device *rdev)\n{\n\t \n\tWREG32(HDP_MEM_COHERENCY_FLUSH_CNTL, 0x1);\n\n\t \n\tWREG32(VM_INVALIDATE_REQUEST, 1);\n}\n\nstatic int si_pcie_gart_enable(struct radeon_device *rdev)\n{\n\tint r, i;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tWREG32(MC_VM_MX_L1_TLB_CNTL,\n\t       (0xA << 7) |\n\t       ENABLE_L1_TLB |\n\t       ENABLE_L1_FRAGMENT_PROCESSING |\n\t       SYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t       ENABLE_ADVANCED_DRIVER_MODEL |\n\t       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE |\n\t       ENABLE_L2_FRAGMENT_PROCESSING |\n\t       ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |\n\t       EFFECTIVE_L2_QUEUE_SIZE(7) |\n\t       CONTEXT1_IDENTITY_ACCESS_MODE(1));\n\tWREG32(VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS | INVALIDATE_L2_CACHE);\n\tWREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |\n\t       BANK_SELECT(4) |\n\t       L2_CACHE_BIGK_FRAGMENT_SIZE(4));\n\t \n\tWREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev->gart.table_addr >> 12);\n\tWREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,\n\t\t\t(u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT0_CNTL2, 0);\n\tWREG32(VM_CONTEXT0_CNTL, (ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |\n\t\t\t\t  RANGE_PROTECTION_FAULT_ENABLE_DEFAULT));\n\n\tWREG32(0x15D4, 0);\n\tWREG32(0x15D8, 0);\n\tWREG32(0x15DC, 0);\n\n\t \n\t \n\tWREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);\n\tWREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev->vm_manager.max_pfn - 1);\n\t \n\tfor (i = 1; i < 16; i++) {\n\t\tif (i < 8)\n\t\t\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2),\n\t\t\t       rdev->vm_manager.saved_table_addr[i]);\n\t\telse\n\t\t\tWREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((i - 8) << 2),\n\t\t\t       rdev->vm_manager.saved_table_addr[i]);\n\t}\n\n\t \n\tWREG32(VM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,\n\t       (u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT1_CNTL2, 4);\n\tWREG32(VM_CONTEXT1_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(1) |\n\t\t\t\tPAGE_TABLE_BLOCK_SIZE(radeon_vm_block_size - 9) |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tDUMMY_PAGE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tDUMMY_PAGE_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tPDE0_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tPDE0_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tVALID_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tVALID_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tREAD_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tREAD_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tWRITE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tWRITE_PROTECTION_FAULT_ENABLE_DEFAULT);\n\n\tsi_pcie_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nstatic void si_pcie_gart_disable(struct radeon_device *rdev)\n{\n\tunsigned i;\n\n\tfor (i = 1; i < 16; ++i) {\n\t\tuint32_t reg;\n\t\tif (i < 8)\n\t\t\treg = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2);\n\t\telse\n\t\t\treg = VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((i - 8) << 2);\n\t\trdev->vm_manager.saved_table_addr[i] = RREG32(reg);\n\t}\n\n\t \n\tWREG32(VM_CONTEXT0_CNTL, 0);\n\tWREG32(VM_CONTEXT1_CNTL, 0);\n\t \n\tWREG32(MC_VM_MX_L1_TLB_CNTL, SYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |\n\t       EFFECTIVE_L2_QUEUE_SIZE(7) |\n\t       CONTEXT1_IDENTITY_ACCESS_MODE(1));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |\n\t       L2_CACHE_BIGK_FRAGMENT_SIZE(0));\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\nstatic void si_pcie_gart_fini(struct radeon_device *rdev)\n{\n\tsi_pcie_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n\tradeon_gart_fini(rdev);\n}\n\n \nstatic bool si_vm_reg_valid(u32 reg)\n{\n\t \n\tif (reg >= 0x28000)\n\t\treturn true;\n\n\t \n\tif (reg >= 0xB000 && reg < 0xC000)\n\t\treturn true;\n\n\t \n\tswitch (reg) {\n\tcase GRBM_GFX_INDEX:\n\tcase CP_STRMOUT_CNTL:\n\tcase VGT_VTX_VECT_EJECT_REG:\n\tcase VGT_CACHE_INVALIDATION:\n\tcase VGT_ESGS_RING_SIZE:\n\tcase VGT_GSVS_RING_SIZE:\n\tcase VGT_GS_VERTEX_REUSE:\n\tcase VGT_PRIMITIVE_TYPE:\n\tcase VGT_INDEX_TYPE:\n\tcase VGT_NUM_INDICES:\n\tcase VGT_NUM_INSTANCES:\n\tcase VGT_TF_RING_SIZE:\n\tcase VGT_HS_OFFCHIP_PARAM:\n\tcase VGT_TF_MEMORY_BASE:\n\tcase PA_CL_ENHANCE:\n\tcase PA_SU_LINE_STIPPLE_VALUE:\n\tcase PA_SC_LINE_STIPPLE_STATE:\n\tcase PA_SC_ENHANCE:\n\tcase SQC_CACHES:\n\tcase SPI_STATIC_THREAD_MGMT_1:\n\tcase SPI_STATIC_THREAD_MGMT_2:\n\tcase SPI_STATIC_THREAD_MGMT_3:\n\tcase SPI_PS_MAX_WAVE_ID:\n\tcase SPI_CONFIG_CNTL:\n\tcase SPI_CONFIG_CNTL_1:\n\tcase TA_CNTL_AUX:\n\tcase TA_CS_BC_BASE_ADDR:\n\t\treturn true;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid register 0x%x in CS\\n\", reg);\n\t\treturn false;\n\t}\n}\n\nstatic int si_vm_packet3_ce_check(struct radeon_device *rdev,\n\t\t\t\t  u32 *ib, struct radeon_cs_packet *pkt)\n{\n\tswitch (pkt->opcode) {\n\tcase PACKET3_NOP:\n\tcase PACKET3_SET_BASE:\n\tcase PACKET3_SET_CE_DE_COUNTERS:\n\tcase PACKET3_LOAD_CONST_RAM:\n\tcase PACKET3_WRITE_CONST_RAM:\n\tcase PACKET3_WRITE_CONST_RAM_OFFSET:\n\tcase PACKET3_DUMP_CONST_RAM:\n\tcase PACKET3_INCREMENT_CE_COUNTER:\n\tcase PACKET3_WAIT_ON_DE_COUNTER:\n\tcase PACKET3_CE_WRITE:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid CE packet3: 0x%x\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int si_vm_packet3_cp_dma_check(u32 *ib, u32 idx)\n{\n\tu32 start_reg, reg, i;\n\tu32 command = ib[idx + 4];\n\tu32 info = ib[idx + 1];\n\tu32 idx_value = ib[idx];\n\tif (command & PACKET3_CP_DMA_CMD_SAS) {\n\t\t \n\t\tif (((info & 0x60000000) >> 29) == 0) {\n\t\t\tstart_reg = idx_value << 2;\n\t\t\tif (command & PACKET3_CP_DMA_CMD_SAIC) {\n\t\t\t\treg = start_reg;\n\t\t\t\tif (!si_vm_reg_valid(reg)) {\n\t\t\t\t\tDRM_ERROR(\"CP DMA Bad SRC register\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < (command & 0x1fffff); i++) {\n\t\t\t\t\treg = start_reg + (4 * i);\n\t\t\t\t\tif (!si_vm_reg_valid(reg)) {\n\t\t\t\t\t\tDRM_ERROR(\"CP DMA Bad SRC register\\n\");\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (command & PACKET3_CP_DMA_CMD_DAS) {\n\t\t \n\t\tif (((info & 0x00300000) >> 20) == 0) {\n\t\t\tstart_reg = ib[idx + 2];\n\t\t\tif (command & PACKET3_CP_DMA_CMD_DAIC) {\n\t\t\t\treg = start_reg;\n\t\t\t\tif (!si_vm_reg_valid(reg)) {\n\t\t\t\t\tDRM_ERROR(\"CP DMA Bad DST register\\n\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < (command & 0x1fffff); i++) {\n\t\t\t\t\treg = start_reg + (4 * i);\n\t\t\t\t\tif (!si_vm_reg_valid(reg)) {\n\t\t\t\t\t\tDRM_ERROR(\"CP DMA Bad DST register\\n\");\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int si_vm_packet3_gfx_check(struct radeon_device *rdev,\n\t\t\t\t   u32 *ib, struct radeon_cs_packet *pkt)\n{\n\tint r;\n\tu32 idx = pkt->idx + 1;\n\tu32 idx_value = ib[idx];\n\tu32 start_reg, end_reg, reg, i;\n\n\tswitch (pkt->opcode) {\n\tcase PACKET3_NOP:\n\tcase PACKET3_SET_BASE:\n\tcase PACKET3_CLEAR_STATE:\n\tcase PACKET3_INDEX_BUFFER_SIZE:\n\tcase PACKET3_DISPATCH_DIRECT:\n\tcase PACKET3_DISPATCH_INDIRECT:\n\tcase PACKET3_ALLOC_GDS:\n\tcase PACKET3_WRITE_GDS_RAM:\n\tcase PACKET3_ATOMIC_GDS:\n\tcase PACKET3_ATOMIC:\n\tcase PACKET3_OCCLUSION_QUERY:\n\tcase PACKET3_SET_PREDICATION:\n\tcase PACKET3_COND_EXEC:\n\tcase PACKET3_PRED_EXEC:\n\tcase PACKET3_DRAW_INDIRECT:\n\tcase PACKET3_DRAW_INDEX_INDIRECT:\n\tcase PACKET3_INDEX_BASE:\n\tcase PACKET3_DRAW_INDEX_2:\n\tcase PACKET3_CONTEXT_CONTROL:\n\tcase PACKET3_INDEX_TYPE:\n\tcase PACKET3_DRAW_INDIRECT_MULTI:\n\tcase PACKET3_DRAW_INDEX_AUTO:\n\tcase PACKET3_DRAW_INDEX_IMMD:\n\tcase PACKET3_NUM_INSTANCES:\n\tcase PACKET3_DRAW_INDEX_MULTI_AUTO:\n\tcase PACKET3_STRMOUT_BUFFER_UPDATE:\n\tcase PACKET3_DRAW_INDEX_OFFSET_2:\n\tcase PACKET3_DRAW_INDEX_MULTI_ELEMENT:\n\tcase PACKET3_DRAW_INDEX_INDIRECT_MULTI:\n\tcase PACKET3_MPEG_INDEX:\n\tcase PACKET3_WAIT_REG_MEM:\n\tcase PACKET3_MEM_WRITE:\n\tcase PACKET3_PFP_SYNC_ME:\n\tcase PACKET3_SURFACE_SYNC:\n\tcase PACKET3_EVENT_WRITE:\n\tcase PACKET3_EVENT_WRITE_EOP:\n\tcase PACKET3_EVENT_WRITE_EOS:\n\tcase PACKET3_SET_CONTEXT_REG:\n\tcase PACKET3_SET_CONTEXT_REG_INDIRECT:\n\tcase PACKET3_SET_SH_REG:\n\tcase PACKET3_SET_SH_REG_OFFSET:\n\tcase PACKET3_INCREMENT_DE_COUNTER:\n\tcase PACKET3_WAIT_ON_CE_COUNTER:\n\tcase PACKET3_WAIT_ON_AVAIL_BUFFER:\n\tcase PACKET3_ME_WRITE:\n\t\tbreak;\n\tcase PACKET3_COPY_DATA:\n\t\tif ((idx_value & 0xf00) == 0) {\n\t\t\treg = ib[idx + 3] * 4;\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_WRITE_DATA:\n\t\tif ((idx_value & 0xf00) == 0) {\n\t\t\tstart_reg = ib[idx + 1] * 4;\n\t\t\tif (idx_value & 0x10000) {\n\t\t\t\tif (!si_vm_reg_valid(start_reg))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < (pkt->count - 2); i++) {\n\t\t\t\t\treg = start_reg + (4 * i);\n\t\t\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_COND_WRITE:\n\t\tif (idx_value & 0x100) {\n\t\t\treg = ib[idx + 5] * 4;\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_COPY_DW:\n\t\tif (idx_value & 0x2) {\n\t\t\treg = ib[idx + 3] * 4;\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_SET_CONFIG_REG:\n\t\tstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_START;\n\t\tend_reg = 4 * pkt->count + start_reg - 4;\n\t\tif ((start_reg < PACKET3_SET_CONFIG_REG_START) ||\n\t\t    (start_reg >= PACKET3_SET_CONFIG_REG_END) ||\n\t\t    (end_reg >= PACKET3_SET_CONFIG_REG_END)) {\n\t\t\tDRM_ERROR(\"bad PACKET3_SET_CONFIG_REG\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < pkt->count; i++) {\n\t\t\treg = start_reg + (4 * i);\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CP_DMA:\n\t\tr = si_vm_packet3_cp_dma_check(ib, idx);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid GFX packet3: 0x%x\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int si_vm_packet3_compute_check(struct radeon_device *rdev,\n\t\t\t\t       u32 *ib, struct radeon_cs_packet *pkt)\n{\n\tint r;\n\tu32 idx = pkt->idx + 1;\n\tu32 idx_value = ib[idx];\n\tu32 start_reg, reg, i;\n\n\tswitch (pkt->opcode) {\n\tcase PACKET3_NOP:\n\tcase PACKET3_SET_BASE:\n\tcase PACKET3_CLEAR_STATE:\n\tcase PACKET3_DISPATCH_DIRECT:\n\tcase PACKET3_DISPATCH_INDIRECT:\n\tcase PACKET3_ALLOC_GDS:\n\tcase PACKET3_WRITE_GDS_RAM:\n\tcase PACKET3_ATOMIC_GDS:\n\tcase PACKET3_ATOMIC:\n\tcase PACKET3_OCCLUSION_QUERY:\n\tcase PACKET3_SET_PREDICATION:\n\tcase PACKET3_COND_EXEC:\n\tcase PACKET3_PRED_EXEC:\n\tcase PACKET3_CONTEXT_CONTROL:\n\tcase PACKET3_STRMOUT_BUFFER_UPDATE:\n\tcase PACKET3_WAIT_REG_MEM:\n\tcase PACKET3_MEM_WRITE:\n\tcase PACKET3_PFP_SYNC_ME:\n\tcase PACKET3_SURFACE_SYNC:\n\tcase PACKET3_EVENT_WRITE:\n\tcase PACKET3_EVENT_WRITE_EOP:\n\tcase PACKET3_EVENT_WRITE_EOS:\n\tcase PACKET3_SET_CONTEXT_REG:\n\tcase PACKET3_SET_CONTEXT_REG_INDIRECT:\n\tcase PACKET3_SET_SH_REG:\n\tcase PACKET3_SET_SH_REG_OFFSET:\n\tcase PACKET3_INCREMENT_DE_COUNTER:\n\tcase PACKET3_WAIT_ON_CE_COUNTER:\n\tcase PACKET3_WAIT_ON_AVAIL_BUFFER:\n\tcase PACKET3_ME_WRITE:\n\t\tbreak;\n\tcase PACKET3_COPY_DATA:\n\t\tif ((idx_value & 0xf00) == 0) {\n\t\t\treg = ib[idx + 3] * 4;\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_WRITE_DATA:\n\t\tif ((idx_value & 0xf00) == 0) {\n\t\t\tstart_reg = ib[idx + 1] * 4;\n\t\t\tif (idx_value & 0x10000) {\n\t\t\t\tif (!si_vm_reg_valid(start_reg))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < (pkt->count - 2); i++) {\n\t\t\t\t\treg = start_reg + (4 * i);\n\t\t\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PACKET3_COND_WRITE:\n\t\tif (idx_value & 0x100) {\n\t\t\treg = ib[idx + 5] * 4;\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_COPY_DW:\n\t\tif (idx_value & 0x2) {\n\t\t\treg = ib[idx + 3] * 4;\n\t\t\tif (!si_vm_reg_valid(reg))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PACKET3_CP_DMA:\n\t\tr = si_vm_packet3_cp_dma_check(ib, idx);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Invalid Compute packet3: 0x%x\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint si_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tint ret = 0;\n\tu32 idx = 0, i;\n\tstruct radeon_cs_packet pkt;\n\n\tdo {\n\t\tpkt.idx = idx;\n\t\tpkt.type = RADEON_CP_PACKET_GET_TYPE(ib->ptr[idx]);\n\t\tpkt.count = RADEON_CP_PACKET_GET_COUNT(ib->ptr[idx]);\n\t\tpkt.one_reg_wr = 0;\n\t\tswitch (pkt.type) {\n\t\tcase RADEON_PACKET_TYPE0:\n\t\t\tdev_err(rdev->dev, \"Packet0 not allowed!\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE2:\n\t\t\tidx += 1;\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE3:\n\t\t\tpkt.opcode = RADEON_CP_PACKET3_GET_OPCODE(ib->ptr[idx]);\n\t\t\tif (ib->is_const_ib)\n\t\t\t\tret = si_vm_packet3_ce_check(rdev, ib->ptr, &pkt);\n\t\t\telse {\n\t\t\t\tswitch (ib->ring) {\n\t\t\t\tcase RADEON_RING_TYPE_GFX_INDEX:\n\t\t\t\t\tret = si_vm_packet3_gfx_check(rdev, ib->ptr, &pkt);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CAYMAN_RING_TYPE_CP1_INDEX:\n\t\t\t\tcase CAYMAN_RING_TYPE_CP2_INDEX:\n\t\t\t\t\tret = si_vm_packet3_compute_check(rdev, ib->ptr, &pkt);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdev_err(rdev->dev, \"Non-PM4 ring %d !\\n\", ib->ring);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx += pkt.count + 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(rdev->dev, \"Unknown packet type %d !\\n\", pkt.type);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\tfor (i = 0; i < ib->length_dw; i++) {\n\t\t\t\tif (i == idx)\n\t\t\t\t\tprintk(\"\\t0x%08x <---\\n\", ib->ptr[i]);\n\t\t\t\telse\n\t\t\t\t\tprintk(\"\\t0x%08x\\n\", ib->ptr[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (idx < ib->length_dw);\n\n\treturn ret;\n}\n\n \nint si_vm_init(struct radeon_device *rdev)\n{\n\t \n\trdev->vm_manager.nvm = 16;\n\t \n\trdev->vm_manager.vram_base_offset = 0;\n\n\treturn 0;\n}\n\nvoid si_vm_fini(struct radeon_device *rdev)\n{\n}\n\n \nstatic void si_vm_decode_fault(struct radeon_device *rdev,\n\t\t\t       u32 status, u32 addr)\n{\n\tu32 mc_id = (status & MEMORY_CLIENT_ID_MASK) >> MEMORY_CLIENT_ID_SHIFT;\n\tu32 vmid = (status & FAULT_VMID_MASK) >> FAULT_VMID_SHIFT;\n\tu32 protections = (status & PROTECTIONS_MASK) >> PROTECTIONS_SHIFT;\n\tchar *block;\n\n\tif (rdev->family == CHIP_TAHITI) {\n\t\tswitch (mc_id) {\n\t\tcase 160:\n\t\tcase 144:\n\t\tcase 96:\n\t\tcase 80:\n\t\tcase 224:\n\t\tcase 208:\n\t\tcase 32:\n\t\tcase 16:\n\t\t\tblock = \"CB\";\n\t\t\tbreak;\n\t\tcase 161:\n\t\tcase 145:\n\t\tcase 97:\n\t\tcase 81:\n\t\tcase 225:\n\t\tcase 209:\n\t\tcase 33:\n\t\tcase 17:\n\t\t\tblock = \"CB_FMASK\";\n\t\t\tbreak;\n\t\tcase 162:\n\t\tcase 146:\n\t\tcase 98:\n\t\tcase 82:\n\t\tcase 226:\n\t\tcase 210:\n\t\tcase 34:\n\t\tcase 18:\n\t\t\tblock = \"CB_CMASK\";\n\t\t\tbreak;\n\t\tcase 163:\n\t\tcase 147:\n\t\tcase 99:\n\t\tcase 83:\n\t\tcase 227:\n\t\tcase 211:\n\t\tcase 35:\n\t\tcase 19:\n\t\t\tblock = \"CB_IMMED\";\n\t\t\tbreak;\n\t\tcase 164:\n\t\tcase 148:\n\t\tcase 100:\n\t\tcase 84:\n\t\tcase 228:\n\t\tcase 212:\n\t\tcase 36:\n\t\tcase 20:\n\t\t\tblock = \"DB\";\n\t\t\tbreak;\n\t\tcase 165:\n\t\tcase 149:\n\t\tcase 101:\n\t\tcase 85:\n\t\tcase 229:\n\t\tcase 213:\n\t\tcase 37:\n\t\tcase 21:\n\t\t\tblock = \"DB_HTILE\";\n\t\t\tbreak;\n\t\tcase 167:\n\t\tcase 151:\n\t\tcase 103:\n\t\tcase 87:\n\t\tcase 231:\n\t\tcase 215:\n\t\tcase 39:\n\t\tcase 23:\n\t\t\tblock = \"DB_STEN\";\n\t\t\tbreak;\n\t\tcase 72:\n\t\tcase 68:\n\t\tcase 64:\n\t\tcase 8:\n\t\tcase 4:\n\t\tcase 0:\n\t\tcase 136:\n\t\tcase 132:\n\t\tcase 128:\n\t\tcase 200:\n\t\tcase 196:\n\t\tcase 192:\n\t\t\tblock = \"TC\";\n\t\t\tbreak;\n\t\tcase 112:\n\t\tcase 48:\n\t\t\tblock = \"CP\";\n\t\t\tbreak;\n\t\tcase 49:\n\t\tcase 177:\n\t\tcase 50:\n\t\tcase 178:\n\t\t\tblock = \"SH\";\n\t\t\tbreak;\n\t\tcase 53:\n\t\tcase 190:\n\t\t\tblock = \"VGT\";\n\t\t\tbreak;\n\t\tcase 117:\n\t\t\tblock = \"IH\";\n\t\t\tbreak;\n\t\tcase 51:\n\t\tcase 115:\n\t\t\tblock = \"RLC\";\n\t\t\tbreak;\n\t\tcase 119:\n\t\tcase 183:\n\t\t\tblock = \"DMA0\";\n\t\t\tbreak;\n\t\tcase 61:\n\t\t\tblock = \"DMA1\";\n\t\t\tbreak;\n\t\tcase 248:\n\t\tcase 120:\n\t\t\tblock = \"HDP\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tblock = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (mc_id) {\n\t\tcase 32:\n\t\tcase 16:\n\t\tcase 96:\n\t\tcase 80:\n\t\tcase 160:\n\t\tcase 144:\n\t\tcase 224:\n\t\tcase 208:\n\t\t\tblock = \"CB\";\n\t\t\tbreak;\n\t\tcase 33:\n\t\tcase 17:\n\t\tcase 97:\n\t\tcase 81:\n\t\tcase 161:\n\t\tcase 145:\n\t\tcase 225:\n\t\tcase 209:\n\t\t\tblock = \"CB_FMASK\";\n\t\t\tbreak;\n\t\tcase 34:\n\t\tcase 18:\n\t\tcase 98:\n\t\tcase 82:\n\t\tcase 162:\n\t\tcase 146:\n\t\tcase 226:\n\t\tcase 210:\n\t\t\tblock = \"CB_CMASK\";\n\t\t\tbreak;\n\t\tcase 35:\n\t\tcase 19:\n\t\tcase 99:\n\t\tcase 83:\n\t\tcase 163:\n\t\tcase 147:\n\t\tcase 227:\n\t\tcase 211:\n\t\t\tblock = \"CB_IMMED\";\n\t\t\tbreak;\n\t\tcase 36:\n\t\tcase 20:\n\t\tcase 100:\n\t\tcase 84:\n\t\tcase 164:\n\t\tcase 148:\n\t\tcase 228:\n\t\tcase 212:\n\t\t\tblock = \"DB\";\n\t\t\tbreak;\n\t\tcase 37:\n\t\tcase 21:\n\t\tcase 101:\n\t\tcase 85:\n\t\tcase 165:\n\t\tcase 149:\n\t\tcase 229:\n\t\tcase 213:\n\t\t\tblock = \"DB_HTILE\";\n\t\t\tbreak;\n\t\tcase 39:\n\t\tcase 23:\n\t\tcase 103:\n\t\tcase 87:\n\t\tcase 167:\n\t\tcase 151:\n\t\tcase 231:\n\t\tcase 215:\n\t\t\tblock = \"DB_STEN\";\n\t\t\tbreak;\n\t\tcase 72:\n\t\tcase 68:\n\t\tcase 8:\n\t\tcase 4:\n\t\tcase 136:\n\t\tcase 132:\n\t\tcase 200:\n\t\tcase 196:\n\t\t\tblock = \"TC\";\n\t\t\tbreak;\n\t\tcase 112:\n\t\tcase 48:\n\t\t\tblock = \"CP\";\n\t\t\tbreak;\n\t\tcase 49:\n\t\tcase 177:\n\t\tcase 50:\n\t\tcase 178:\n\t\t\tblock = \"SH\";\n\t\t\tbreak;\n\t\tcase 53:\n\t\t\tblock = \"VGT\";\n\t\t\tbreak;\n\t\tcase 117:\n\t\t\tblock = \"IH\";\n\t\t\tbreak;\n\t\tcase 51:\n\t\tcase 115:\n\t\t\tblock = \"RLC\";\n\t\t\tbreak;\n\t\tcase 119:\n\t\tcase 183:\n\t\t\tblock = \"DMA0\";\n\t\t\tbreak;\n\t\tcase 61:\n\t\t\tblock = \"DMA1\";\n\t\t\tbreak;\n\t\tcase 248:\n\t\tcase 120:\n\t\t\tblock = \"HDP\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tblock = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintk(\"VM fault (0x%02x, vmid %d) at page %u, %s from %s (%d)\\n\",\n\t       protections, vmid, addr,\n\t       (status & MEMORY_CLIENT_RW_MASK) ? \"write\" : \"read\",\n\t       block, mc_id);\n}\n\nvoid si_vm_flush(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t unsigned vm_id, uint64_t pd_addr)\n{\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(1) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\n\tif (vm_id < 8) {\n\t\tradeon_ring_write(ring,\n\t\t\t\t  (VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (vm_id << 2)) >> 2);\n\t} else {\n\t\tradeon_ring_write(ring,\n\t\t\t\t  (VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((vm_id - 8) << 2)) >> 2);\n\t}\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, pd_addr >> 12);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(1) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tradeon_ring_write(ring, HDP_MEM_COHERENCY_FLUSH_CNTL >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0x1);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(1) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tradeon_ring_write(ring, VM_INVALIDATE_REQUEST >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 1 << vm_id);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tradeon_ring_write(ring, (WAIT_REG_MEM_FUNCTION(0) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(0)));  \n\tradeon_ring_write(ring, VM_INVALIDATE_REQUEST >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, 0x20);  \n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\tradeon_ring_write(ring, 0x0);\n}\n\n \nstatic void si_wait_for_rlc_serdes(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(RLC_SERDES_MASTER_BUSY_0) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(RLC_SERDES_MASTER_BUSY_1) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void si_enable_gui_idle_interrupt(struct radeon_device *rdev,\n\t\t\t\t\t bool enable)\n{\n\tu32 tmp = RREG32(CP_INT_CNTL_RING0);\n\tu32 mask;\n\tint i;\n\n\tif (enable)\n\t\ttmp |= (CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\telse\n\t\ttmp &= ~(CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\tWREG32(CP_INT_CNTL_RING0, tmp);\n\n\tif (!enable) {\n\t\t \n\t\ttmp = RREG32(DB_DEPTH_INFO);\n\n\t\tmask = RLC_BUSY_STATUS | GFX_POWER_STATUS | GFX_CLOCK_STATUS | GFX_LS_STATUS;\n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif ((RREG32(RLC_STAT) & mask) == (GFX_CLOCK_STATUS | GFX_POWER_STATUS))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n}\n\nstatic void si_set_uvd_dcm(struct radeon_device *rdev,\n\t\t\t   bool sw_mode)\n{\n\tu32 tmp, tmp2;\n\n\ttmp = RREG32(UVD_CGC_CTRL);\n\ttmp &= ~(CLK_OD_MASK | CG_DT_MASK);\n\ttmp |= DCM | CG_DT(1) | CLK_OD(4);\n\n\tif (sw_mode) {\n\t\ttmp &= ~0x7ffff800;\n\t\ttmp2 = DYN_OR_EN | DYN_RR_EN | G_DIV_ID(7);\n\t} else {\n\t\ttmp |= 0x7ffff800;\n\t\ttmp2 = 0;\n\t}\n\n\tWREG32(UVD_CGC_CTRL, tmp);\n\tWREG32_UVD_CTX(UVD_CGC_CTRL2, tmp2);\n}\n\nvoid si_init_uvd_internal_cg(struct radeon_device *rdev)\n{\n\tbool hw_mode = true;\n\n\tif (hw_mode) {\n\t\tsi_set_uvd_dcm(rdev, false);\n\t} else {\n\t\tu32 tmp = RREG32(UVD_CGC_CTRL);\n\t\ttmp &= ~DCM;\n\t\tWREG32(UVD_CGC_CTRL, tmp);\n\t}\n}\n\nstatic u32 si_halt_rlc(struct radeon_device *rdev)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_CNTL);\n\n\tif (data & RLC_ENABLE) {\n\t\tdata &= ~RLC_ENABLE;\n\t\tWREG32(RLC_CNTL, data);\n\n\t\tsi_wait_for_rlc_serdes(rdev);\n\t}\n\n\treturn orig;\n}\n\nstatic void si_update_rlc(struct radeon_device *rdev, u32 rlc)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(RLC_CNTL);\n\tif (tmp != rlc)\n\t\tWREG32(RLC_CNTL, rlc);\n}\n\nstatic void si_enable_dma_pg(struct radeon_device *rdev, bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(DMA_PG);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_SDMA))\n\t\tdata |= PG_CNTL_ENABLE;\n\telse\n\t\tdata &= ~PG_CNTL_ENABLE;\n\tif (orig != data)\n\t\tWREG32(DMA_PG, data);\n}\n\nstatic void si_init_dma_pg(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tWREG32(DMA_PGFSM_WRITE,  0x00002000);\n\tWREG32(DMA_PGFSM_CONFIG, 0x100010ff);\n\n\tfor (tmp = 0; tmp < 5; tmp++)\n\t\tWREG32(DMA_PGFSM_WRITE, 0);\n}\n\nstatic void si_enable_gfx_cgpg(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tu32 tmp;\n\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_PG)) {\n\t\ttmp = RLC_PUD(0x10) | RLC_PDD(0x10) | RLC_TTPD(0x10) | RLC_MSD(0x10);\n\t\tWREG32(RLC_TTOP_D, tmp);\n\n\t\ttmp = RREG32(RLC_PG_CNTL);\n\t\ttmp |= GFX_PG_ENABLE;\n\t\tWREG32(RLC_PG_CNTL, tmp);\n\n\t\ttmp = RREG32(RLC_AUTO_PG_CTRL);\n\t\ttmp |= AUTO_PG_EN;\n\t\tWREG32(RLC_AUTO_PG_CTRL, tmp);\n\t} else {\n\t\ttmp = RREG32(RLC_AUTO_PG_CTRL);\n\t\ttmp &= ~AUTO_PG_EN;\n\t\tWREG32(RLC_AUTO_PG_CTRL, tmp);\n\n\t\ttmp = RREG32(DB_RENDER_CONTROL);\n\t}\n}\n\nstatic void si_init_gfx_cgpg(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tWREG32(RLC_SAVE_AND_RESTORE_BASE, rdev->rlc.save_restore_gpu_addr >> 8);\n\n\ttmp = RREG32(RLC_PG_CNTL);\n\ttmp |= GFX_PG_SRC;\n\tWREG32(RLC_PG_CNTL, tmp);\n\n\tWREG32(RLC_CLEAR_STATE_RESTORE_BASE, rdev->rlc.clear_state_gpu_addr >> 8);\n\n\ttmp = RREG32(RLC_AUTO_PG_CTRL);\n\n\ttmp &= ~GRBM_REG_SGIT_MASK;\n\ttmp |= GRBM_REG_SGIT(0x700);\n\ttmp &= ~PG_AFTER_GRBM_REG_ST_MASK;\n\tWREG32(RLC_AUTO_PG_CTRL, tmp);\n}\n\nstatic u32 si_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh)\n{\n\tu32 mask = 0, tmp, tmp1;\n\tint i;\n\n\tsi_select_se_sh(rdev, se, sh);\n\ttmp = RREG32(CC_GC_SHADER_ARRAY_CONFIG);\n\ttmp1 = RREG32(GC_USER_SHADER_ARRAY_CONFIG);\n\tsi_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\n\ttmp &= 0xffff0000;\n\n\ttmp |= tmp1;\n\ttmp >>= 16;\n\n\tfor (i = 0; i < rdev->config.si.max_cu_per_sh; i ++) {\n\t\tmask <<= 1;\n\t\tmask |= 1;\n\t}\n\n\treturn (~tmp) & mask;\n}\n\nstatic void si_init_ao_cu_mask(struct radeon_device *rdev)\n{\n\tu32 i, j, k, active_cu_number = 0;\n\tu32 mask, counter, cu_bitmap;\n\tu32 tmp = 0;\n\n\tfor (i = 0; i < rdev->config.si.max_shader_engines; i++) {\n\t\tfor (j = 0; j < rdev->config.si.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tcu_bitmap = 0;\n\t\t\tcounter  = 0;\n\t\t\tfor (k = 0; k < rdev->config.si.max_cu_per_sh; k++) {\n\t\t\t\tif (si_get_cu_active_bitmap(rdev, i, j) & mask) {\n\t\t\t\t\tif (counter < 2)\n\t\t\t\t\t\tcu_bitmap |= mask;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\n\t\t\tactive_cu_number += counter;\n\t\t\ttmp |= (cu_bitmap << (i * 16 + j * 8));\n\t\t}\n\t}\n\n\tWREG32(RLC_PG_AO_CU_MASK, tmp);\n\n\ttmp = RREG32(RLC_MAX_PG_CU);\n\ttmp &= ~MAX_PU_CU_MASK;\n\ttmp |= MAX_PU_CU(active_cu_number);\n\tWREG32(RLC_MAX_PG_CU, tmp);\n}\n\nstatic void si_enable_cgcg(struct radeon_device *rdev,\n\t\t\t   bool enable)\n{\n\tu32 data, orig, tmp;\n\n\torig = data = RREG32(RLC_CGCG_CGLS_CTRL);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_CGCG)) {\n\t\tsi_enable_gui_idle_interrupt(rdev, true);\n\n\t\tWREG32(RLC_GCPM_GENERAL_3, 0x00000080);\n\n\t\ttmp = si_halt_rlc(rdev);\n\n\t\tWREG32(RLC_SERDES_WR_MASTER_MASK_0, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_MASTER_MASK_1, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_CTRL, 0x00b000ff);\n\n\t\tsi_wait_for_rlc_serdes(rdev);\n\n\t\tsi_update_rlc(rdev, tmp);\n\n\t\tWREG32(RLC_SERDES_WR_CTRL, 0x007000ff);\n\n\t\tdata |= CGCG_EN | CGLS_EN;\n\t} else {\n\t\tsi_enable_gui_idle_interrupt(rdev, false);\n\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\n\t\tdata &= ~(CGCG_EN | CGLS_EN);\n\t}\n\n\tif (orig != data)\n\t\tWREG32(RLC_CGCG_CGLS_CTRL, data);\n}\n\nstatic void si_enable_mgcg(struct radeon_device *rdev,\n\t\t\t   bool enable)\n{\n\tu32 data, orig, tmp = 0;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_MGCG)) {\n\t\torig = data = RREG32(CGTS_SM_CTRL_REG);\n\t\tdata = 0x96940200;\n\t\tif (orig != data)\n\t\t\tWREG32(CGTS_SM_CTRL_REG, data);\n\n\t\tif (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_CP_LS) {\n\t\t\torig = data = RREG32(CP_MEM_SLP_CNTL);\n\t\t\tdata |= CP_MEM_LS_EN;\n\t\t\tif (orig != data)\n\t\t\t\tWREG32(CP_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\torig = data = RREG32(RLC_CGTT_MGCG_OVERRIDE);\n\t\tdata &= 0xffffffc0;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\ttmp = si_halt_rlc(rdev);\n\n\t\tWREG32(RLC_SERDES_WR_MASTER_MASK_0, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_MASTER_MASK_1, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_CTRL, 0x00d000ff);\n\n\t\tsi_update_rlc(rdev, tmp);\n\t} else {\n\t\torig = data = RREG32(RLC_CGTT_MGCG_OVERRIDE);\n\t\tdata |= 0x00000003;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\tdata = RREG32(CP_MEM_SLP_CNTL);\n\t\tif (data & CP_MEM_LS_EN) {\n\t\t\tdata &= ~CP_MEM_LS_EN;\n\t\t\tWREG32(CP_MEM_SLP_CNTL, data);\n\t\t}\n\t\torig = data = RREG32(CGTS_SM_CTRL_REG);\n\t\tdata |= LS_OVERRIDE | OVERRIDE;\n\t\tif (orig != data)\n\t\t\tWREG32(CGTS_SM_CTRL_REG, data);\n\n\t\ttmp = si_halt_rlc(rdev);\n\n\t\tWREG32(RLC_SERDES_WR_MASTER_MASK_0, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_MASTER_MASK_1, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_CTRL, 0x00e000ff);\n\n\t\tsi_update_rlc(rdev, tmp);\n\t}\n}\n\nstatic void si_enable_uvd_mgcg(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tu32 orig, data, tmp;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_UVD_MGCG)) {\n\t\ttmp = RREG32_UVD_CTX(UVD_CGC_MEM_CTRL);\n\t\ttmp |= 0x3fff;\n\t\tWREG32_UVD_CTX(UVD_CGC_MEM_CTRL, tmp);\n\n\t\torig = data = RREG32(UVD_CGC_CTRL);\n\t\tdata |= DCM;\n\t\tif (orig != data)\n\t\t\tWREG32(UVD_CGC_CTRL, data);\n\n\t\tWREG32_SMC(SMC_CG_IND_START + CG_CGTT_LOCAL_0, 0);\n\t\tWREG32_SMC(SMC_CG_IND_START + CG_CGTT_LOCAL_1, 0);\n\t} else {\n\t\ttmp = RREG32_UVD_CTX(UVD_CGC_MEM_CTRL);\n\t\ttmp &= ~0x3fff;\n\t\tWREG32_UVD_CTX(UVD_CGC_MEM_CTRL, tmp);\n\n\t\torig = data = RREG32(UVD_CGC_CTRL);\n\t\tdata &= ~DCM;\n\t\tif (orig != data)\n\t\t\tWREG32(UVD_CGC_CTRL, data);\n\n\t\tWREG32_SMC(SMC_CG_IND_START + CG_CGTT_LOCAL_0, 0xffffffff);\n\t\tWREG32_SMC(SMC_CG_IND_START + CG_CGTT_LOCAL_1, 0xffffffff);\n\t}\n}\n\nstatic const u32 mc_cg_registers[] =\n{\n\tMC_HUB_MISC_HUB_CG,\n\tMC_HUB_MISC_SIP_CG,\n\tMC_HUB_MISC_VM_CG,\n\tMC_XPB_CLK_GAT,\n\tATC_MISC_CG,\n\tMC_CITF_MISC_WR_CG,\n\tMC_CITF_MISC_RD_CG,\n\tMC_CITF_MISC_VM_CG,\n\tVM_L2_CG,\n};\n\nstatic void si_enable_mc_ls(struct radeon_device *rdev,\n\t\t\t    bool enable)\n{\n\tint i;\n\tu32 orig, data;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_cg_registers); i++) {\n\t\torig = data = RREG32(mc_cg_registers[i]);\n\t\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_MC_LS))\n\t\t\tdata |= MC_LS_ENABLE;\n\t\telse\n\t\t\tdata &= ~MC_LS_ENABLE;\n\t\tif (data != orig)\n\t\t\tWREG32(mc_cg_registers[i], data);\n\t}\n}\n\nstatic void si_enable_mc_mgcg(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tint i;\n\tu32 orig, data;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_cg_registers); i++) {\n\t\torig = data = RREG32(mc_cg_registers[i]);\n\t\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_MC_MGCG))\n\t\t\tdata |= MC_CG_ENABLE;\n\t\telse\n\t\t\tdata &= ~MC_CG_ENABLE;\n\t\tif (data != orig)\n\t\t\tWREG32(mc_cg_registers[i], data);\n\t}\n}\n\nstatic void si_enable_dma_mgcg(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tu32 orig, data, offset;\n\tint i;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_SDMA_MGCG)) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tif (i == 0)\n\t\t\t\toffset = DMA0_REGISTER_OFFSET;\n\t\t\telse\n\t\t\t\toffset = DMA1_REGISTER_OFFSET;\n\t\t\torig = data = RREG32(DMA_POWER_CNTL + offset);\n\t\t\tdata &= ~MEM_POWER_OVERRIDE;\n\t\t\tif (data != orig)\n\t\t\t\tWREG32(DMA_POWER_CNTL + offset, data);\n\t\t\tWREG32(DMA_CLK_CTRL + offset, 0x00000100);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tif (i == 0)\n\t\t\t\toffset = DMA0_REGISTER_OFFSET;\n\t\t\telse\n\t\t\t\toffset = DMA1_REGISTER_OFFSET;\n\t\t\torig = data = RREG32(DMA_POWER_CNTL + offset);\n\t\t\tdata |= MEM_POWER_OVERRIDE;\n\t\t\tif (data != orig)\n\t\t\t\tWREG32(DMA_POWER_CNTL + offset, data);\n\n\t\t\torig = data = RREG32(DMA_CLK_CTRL + offset);\n\t\t\tdata = 0xff000000;\n\t\t\tif (data != orig)\n\t\t\t\tWREG32(DMA_CLK_CTRL + offset, data);\n\t\t}\n\t}\n}\n\nstatic void si_enable_bif_mgls(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tu32 orig, data;\n\n\torig = data = RREG32_PCIE(PCIE_CNTL2);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_BIF_LS))\n\t\tdata |= SLV_MEM_LS_EN | MST_MEM_LS_EN |\n\t\t\tREPLAY_MEM_LS_EN | SLV_MEM_AGGRESSIVE_LS_EN;\n\telse\n\t\tdata &= ~(SLV_MEM_LS_EN | MST_MEM_LS_EN |\n\t\t\t  REPLAY_MEM_LS_EN | SLV_MEM_AGGRESSIVE_LS_EN);\n\n\tif (orig != data)\n\t\tWREG32_PCIE(PCIE_CNTL2, data);\n}\n\nstatic void si_enable_hdp_mgcg(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tu32 orig, data;\n\n\torig = data = RREG32(HDP_HOST_PATH_CNTL);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_HDP_MGCG))\n\t\tdata &= ~CLOCK_GATING_DIS;\n\telse\n\t\tdata |= CLOCK_GATING_DIS;\n\n\tif (orig != data)\n\t\tWREG32(HDP_HOST_PATH_CNTL, data);\n}\n\nstatic void si_enable_hdp_ls(struct radeon_device *rdev,\n\t\t\t     bool enable)\n{\n\tu32 orig, data;\n\n\torig = data = RREG32(HDP_MEM_POWER_LS);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_HDP_LS))\n\t\tdata |= HDP_LS_ENABLE;\n\telse\n\t\tdata &= ~HDP_LS_ENABLE;\n\n\tif (orig != data)\n\t\tWREG32(HDP_MEM_POWER_LS, data);\n}\n\nstatic void si_update_cg(struct radeon_device *rdev,\n\t\t\t u32 block, bool enable)\n{\n\tif (block & RADEON_CG_BLOCK_GFX) {\n\t\tsi_enable_gui_idle_interrupt(rdev, false);\n\t\t \n\t\tif (enable) {\n\t\t\tsi_enable_mgcg(rdev, true);\n\t\t\tsi_enable_cgcg(rdev, true);\n\t\t} else {\n\t\t\tsi_enable_cgcg(rdev, false);\n\t\t\tsi_enable_mgcg(rdev, false);\n\t\t}\n\t\tsi_enable_gui_idle_interrupt(rdev, true);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_MC) {\n\t\tsi_enable_mc_mgcg(rdev, enable);\n\t\tsi_enable_mc_ls(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_SDMA) {\n\t\tsi_enable_dma_mgcg(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_BIF) {\n\t\tsi_enable_bif_mgls(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_UVD) {\n\t\tif (rdev->has_uvd) {\n\t\t\tsi_enable_uvd_mgcg(rdev, enable);\n\t\t}\n\t}\n\n\tif (block & RADEON_CG_BLOCK_HDP) {\n\t\tsi_enable_hdp_mgcg(rdev, enable);\n\t\tsi_enable_hdp_ls(rdev, enable);\n\t}\n}\n\nstatic void si_init_cg(struct radeon_device *rdev)\n{\n\tsi_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\n\t\t\t    RADEON_CG_BLOCK_MC |\n\t\t\t    RADEON_CG_BLOCK_SDMA |\n\t\t\t    RADEON_CG_BLOCK_BIF |\n\t\t\t    RADEON_CG_BLOCK_HDP), true);\n\tif (rdev->has_uvd) {\n\t\tsi_update_cg(rdev, RADEON_CG_BLOCK_UVD, true);\n\t\tsi_init_uvd_internal_cg(rdev);\n\t}\n}\n\nstatic void si_fini_cg(struct radeon_device *rdev)\n{\n\tif (rdev->has_uvd) {\n\t\tsi_update_cg(rdev, RADEON_CG_BLOCK_UVD, false);\n\t}\n\tsi_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\n\t\t\t    RADEON_CG_BLOCK_MC |\n\t\t\t    RADEON_CG_BLOCK_SDMA |\n\t\t\t    RADEON_CG_BLOCK_BIF |\n\t\t\t    RADEON_CG_BLOCK_HDP), false);\n}\n\nu32 si_get_csb_size(struct radeon_device *rdev)\n{\n\tu32 count = 0;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (rdev->rlc.cs_data == NULL)\n\t\treturn 0;\n\n\t \n\tcount += 2;\n\t \n\tcount += 3;\n\n\tfor (sect = rdev->rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT)\n\t\t\t\tcount += 2 + ext->reg_count;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tcount += 3;\n\t \n\tcount += 2;\n\t \n\tcount += 2;\n\n\treturn count;\n}\n\nvoid si_get_csb_buffer(struct radeon_device *rdev, volatile u32 *buffer)\n{\n\tu32 count = 0, i;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (rdev->rlc.cs_data == NULL)\n\t\treturn;\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\n\tfor (sect = rdev->rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tbuffer[count++] =\n\t\t\t\t\tcpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tbuffer[count++] = cpu_to_le32(ext->reg_index - 0xa000);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tbuffer[count++] = cpu_to_le32(ext->extent[i]);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, 1));\n\tbuffer[count++] = cpu_to_le32(PA_SC_RASTER_CONFIG - PACKET3_SET_CONTEXT_REG_START);\n\tswitch (rdev->family) {\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\t\tbuffer[count++] = cpu_to_le32(0x2a00126a);\n\t\tbreak;\n\tcase CHIP_VERDE:\n\t\tbuffer[count++] = cpu_to_le32(0x0000124a);\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\tbuffer[count++] = cpu_to_le32(0x00000082);\n\t\tbreak;\n\tcase CHIP_HAINAN:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tdefault:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));\n\tbuffer[count++] = cpu_to_le32(0);\n}\n\nstatic void si_init_pg(struct radeon_device *rdev)\n{\n\tif (rdev->pg_flags) {\n\t\tif (rdev->pg_flags & RADEON_PG_SUPPORT_SDMA) {\n\t\t\tsi_init_dma_pg(rdev);\n\t\t}\n\t\tsi_init_ao_cu_mask(rdev);\n\t\tif (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_PG) {\n\t\t\tsi_init_gfx_cgpg(rdev);\n\t\t} else {\n\t\t\tWREG32(RLC_SAVE_AND_RESTORE_BASE, rdev->rlc.save_restore_gpu_addr >> 8);\n\t\t\tWREG32(RLC_CLEAR_STATE_RESTORE_BASE, rdev->rlc.clear_state_gpu_addr >> 8);\n\t\t}\n\t\tsi_enable_dma_pg(rdev, true);\n\t\tsi_enable_gfx_cgpg(rdev, true);\n\t} else {\n\t\tWREG32(RLC_SAVE_AND_RESTORE_BASE, rdev->rlc.save_restore_gpu_addr >> 8);\n\t\tWREG32(RLC_CLEAR_STATE_RESTORE_BASE, rdev->rlc.clear_state_gpu_addr >> 8);\n\t}\n}\n\nstatic void si_fini_pg(struct radeon_device *rdev)\n{\n\tif (rdev->pg_flags) {\n\t\tsi_enable_dma_pg(rdev, false);\n\t\tsi_enable_gfx_cgpg(rdev, false);\n\t}\n}\n\n \nvoid si_rlc_reset(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(GRBM_SOFT_RESET);\n\n\ttmp |= SOFT_RESET_RLC;\n\tWREG32(GRBM_SOFT_RESET, tmp);\n\tudelay(50);\n\ttmp &= ~SOFT_RESET_RLC;\n\tWREG32(GRBM_SOFT_RESET, tmp);\n\tudelay(50);\n}\n\nstatic void si_rlc_stop(struct radeon_device *rdev)\n{\n\tWREG32(RLC_CNTL, 0);\n\n\tsi_enable_gui_idle_interrupt(rdev, false);\n\n\tsi_wait_for_rlc_serdes(rdev);\n}\n\nstatic void si_rlc_start(struct radeon_device *rdev)\n{\n\tWREG32(RLC_CNTL, RLC_ENABLE);\n\n\tsi_enable_gui_idle_interrupt(rdev, true);\n\n\tudelay(50);\n}\n\nstatic bool si_lbpw_supported(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(MC_SEQ_MISC0);\n\tif ((tmp & 0xF0000000) == 0xB0000000)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void si_enable_lbpw(struct radeon_device *rdev, bool enable)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(RLC_LB_CNTL);\n\tif (enable)\n\t\ttmp |= LOAD_BALANCE_ENABLE;\n\telse\n\t\ttmp &= ~LOAD_BALANCE_ENABLE;\n\tWREG32(RLC_LB_CNTL, tmp);\n\n\tif (!enable) {\n\t\tsi_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\t\tWREG32(SPI_LB_CU_MASK, 0x00ff);\n\t}\n}\n\nstatic int si_rlc_resume(struct radeon_device *rdev)\n{\n\tu32 i;\n\n\tif (!rdev->rlc_fw)\n\t\treturn -EINVAL;\n\n\tsi_rlc_stop(rdev);\n\n\tsi_rlc_reset(rdev);\n\n\tsi_init_pg(rdev);\n\n\tsi_init_cg(rdev);\n\n\tWREG32(RLC_RL_BASE, 0);\n\tWREG32(RLC_RL_SIZE, 0);\n\tWREG32(RLC_LB_CNTL, 0);\n\tWREG32(RLC_LB_CNTR_MAX, 0xffffffff);\n\tWREG32(RLC_LB_CNTR_INIT, 0);\n\tWREG32(RLC_LB_INIT_CU_MASK, 0xffffffff);\n\n\tWREG32(RLC_MC_CNTL, 0);\n\tWREG32(RLC_UCODE_CNTL, 0);\n\n\tif (rdev->new_fw) {\n\t\tconst struct rlc_firmware_header_v1_0 *hdr =\n\t\t\t(const struct rlc_firmware_header_v1_0 *)rdev->rlc_fw->data;\n\t\tu32 fw_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\t\tconst __le32 *fw_data = (const __le32 *)\n\t\t\t(rdev->rlc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\n\t\tradeon_ucode_print_rlc_hdr(&hdr->header);\n\n\t\tfor (i = 0; i < fw_size; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\t}\n\t} else {\n\t\tconst __be32 *fw_data =\n\t\t\t(const __be32 *)rdev->rlc_fw->data;\n\t\tfor (i = 0; i < SI_RLC_UCODE_SIZE; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t}\n\t}\n\tWREG32(RLC_UCODE_ADDR, 0);\n\n\tsi_enable_lbpw(rdev, si_lbpw_supported(rdev));\n\n\tsi_rlc_start(rdev);\n\n\treturn 0;\n}\n\nstatic void si_enable_interrupts(struct radeon_device *rdev)\n{\n\tu32 ih_cntl = RREG32(IH_CNTL);\n\tu32 ih_rb_cntl = RREG32(IH_RB_CNTL);\n\n\tih_cntl |= ENABLE_INTR;\n\tih_rb_cntl |= IH_RB_ENABLE;\n\tWREG32(IH_CNTL, ih_cntl);\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\trdev->ih.enabled = true;\n}\n\nstatic void si_disable_interrupts(struct radeon_device *rdev)\n{\n\tu32 ih_rb_cntl = RREG32(IH_RB_CNTL);\n\tu32 ih_cntl = RREG32(IH_CNTL);\n\n\tih_rb_cntl &= ~IH_RB_ENABLE;\n\tih_cntl &= ~ENABLE_INTR;\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\tWREG32(IH_CNTL, ih_cntl);\n\t \n\tWREG32(IH_RB_RPTR, 0);\n\tWREG32(IH_RB_WPTR, 0);\n\trdev->ih.enabled = false;\n\trdev->ih.rptr = 0;\n}\n\nstatic void si_disable_interrupt_state(struct radeon_device *rdev)\n{\n\tint i;\n\tu32 tmp;\n\n\ttmp = RREG32(CP_INT_CNTL_RING0) &\n\t\t(CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\tWREG32(CP_INT_CNTL_RING0, tmp);\n\tWREG32(CP_INT_CNTL_RING1, 0);\n\tWREG32(CP_INT_CNTL_RING2, 0);\n\ttmp = RREG32(DMA_CNTL + DMA0_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\tWREG32(DMA_CNTL + DMA0_REGISTER_OFFSET, tmp);\n\ttmp = RREG32(DMA_CNTL + DMA1_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\tWREG32(DMA_CNTL + DMA1_REGISTER_OFFSET, tmp);\n\tWREG32(GRBM_INT_CNTL, 0);\n\tWREG32(SRBM_INT_CNTL, 0);\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tWREG32(INT_MASK + crtc_offsets[i], 0);\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tWREG32(GRPH_INT_CONTROL + crtc_offsets[i], 0);\n\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\tWREG32(DAC_AUTODETECT_INT_CONTROL, 0);\n\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tWREG32_AND(DC_HPDx_INT_CONTROL(i),\n\t\t\t\t   DC_HPDx_INT_POLARITY);\n\t}\n}\n\nstatic int si_irq_init(struct radeon_device *rdev)\n{\n\tint ret = 0;\n\tint rb_bufsz;\n\tu32 interrupt_cntl, ih_cntl, ih_rb_cntl;\n\n\t \n\tret = r600_ih_ring_alloc(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsi_disable_interrupts(rdev);\n\n\t \n\tret = si_rlc_resume(rdev);\n\tif (ret) {\n\t\tr600_ih_ring_fini(rdev);\n\t\treturn ret;\n\t}\n\n\t \n\t \n\tWREG32(INTERRUPT_CNTL2, rdev->dummy_page.addr >> 8);\n\tinterrupt_cntl = RREG32(INTERRUPT_CNTL);\n\t \n\tinterrupt_cntl &= ~IH_DUMMY_RD_OVERRIDE;\n\t \n\tinterrupt_cntl &= ~IH_REQ_NONSNOOP_EN;\n\tWREG32(INTERRUPT_CNTL, interrupt_cntl);\n\n\tWREG32(IH_RB_BASE, rdev->ih.gpu_addr >> 8);\n\trb_bufsz = order_base_2(rdev->ih.ring_size / 4);\n\n\tih_rb_cntl = (IH_WPTR_OVERFLOW_ENABLE |\n\t\t      IH_WPTR_OVERFLOW_CLEAR |\n\t\t      (rb_bufsz << 1));\n\n\tif (rdev->wb.enabled)\n\t\tih_rb_cntl |= IH_WPTR_WRITEBACK_ENABLE;\n\n\t \n\tWREG32(IH_RB_WPTR_ADDR_LO, (rdev->wb.gpu_addr + R600_WB_IH_WPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(IH_RB_WPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + R600_WB_IH_WPTR_OFFSET) & 0xFF);\n\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\n\t \n\tWREG32(IH_RB_RPTR, 0);\n\tWREG32(IH_RB_WPTR, 0);\n\n\t \n\tih_cntl = MC_WRREQ_CREDIT(0x10) | MC_WR_CLEAN_CNT(0x10) | MC_VMID(0);\n\t \n\tif (rdev->msi_enabled)\n\t\tih_cntl |= RPTR_REARM;\n\tWREG32(IH_CNTL, ih_cntl);\n\n\t \n\tsi_disable_interrupt_state(rdev);\n\n\tpci_set_master(rdev->pdev);\n\n\t \n\tsi_enable_interrupts(rdev);\n\n\treturn ret;\n}\n\n \nint si_irq_set(struct radeon_device *rdev)\n{\n\tint i;\n\tu32 cp_int_cntl;\n\tu32 cp_int_cntl1 = 0, cp_int_cntl2 = 0;\n\tu32 grbm_int_cntl = 0;\n\tu32 dma_cntl, dma_cntl1;\n\tu32 thermal_int = 0;\n\n\tif (!rdev->irq.installed) {\n\t\tWARN(1, \"Can't enable IRQ/MSI because no handler is installed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->ih.enabled) {\n\t\tsi_disable_interrupts(rdev);\n\t\t \n\t\tsi_disable_interrupt_state(rdev);\n\t\treturn 0;\n\t}\n\n\tcp_int_cntl = RREG32(CP_INT_CNTL_RING0) &\n\t\t(CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\n\tdma_cntl = RREG32(DMA_CNTL + DMA0_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\tdma_cntl1 = RREG32(DMA_CNTL + DMA1_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\n\tthermal_int = RREG32(CG_THERMAL_INT) &\n\t\t~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\n\n\t \n\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\tDRM_DEBUG(\"si_irq_set: sw int gfx\\n\");\n\t\tcp_int_cntl |= TIME_STAMP_INT_ENABLE;\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_CP1_INDEX])) {\n\t\tDRM_DEBUG(\"si_irq_set: sw int cp1\\n\");\n\t\tcp_int_cntl1 |= TIME_STAMP_INT_ENABLE;\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_CP2_INDEX])) {\n\t\tDRM_DEBUG(\"si_irq_set: sw int cp2\\n\");\n\t\tcp_int_cntl2 |= TIME_STAMP_INT_ENABLE;\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[R600_RING_TYPE_DMA_INDEX])) {\n\t\tDRM_DEBUG(\"si_irq_set: sw int dma\\n\");\n\t\tdma_cntl |= TRAP_ENABLE;\n\t}\n\n\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_DMA1_INDEX])) {\n\t\tDRM_DEBUG(\"si_irq_set: sw int dma1\\n\");\n\t\tdma_cntl1 |= TRAP_ENABLE;\n\t}\n\n\tWREG32(CP_INT_CNTL_RING0, cp_int_cntl);\n\tWREG32(CP_INT_CNTL_RING1, cp_int_cntl1);\n\tWREG32(CP_INT_CNTL_RING2, cp_int_cntl2);\n\n\tWREG32(DMA_CNTL + DMA0_REGISTER_OFFSET, dma_cntl);\n\tWREG32(DMA_CNTL + DMA1_REGISTER_OFFSET, dma_cntl1);\n\n\tWREG32(GRBM_INT_CNTL, grbm_int_cntl);\n\n\tif (rdev->irq.dpm_thermal) {\n\t\tDRM_DEBUG(\"dpm thermal\\n\");\n\t\tthermal_int |= THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW;\n\t}\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tradeon_irq_kms_set_irq_n_enabled(\n\t\t    rdev, INT_MASK + crtc_offsets[i], VBLANK_INT_MASK,\n\t\t    rdev->irq.crtc_vblank_int[i] ||\n\t\t    atomic_read(&rdev->irq.pflip[i]), \"vblank\", i);\n\t}\n\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tWREG32(GRPH_INT_CONTROL + crtc_offsets[i], GRPH_PFLIP_INT_MASK);\n\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tradeon_irq_kms_set_irq_n_enabled(\n\t\t\t    rdev, DC_HPDx_INT_CONTROL(i),\n\t\t\t    DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN,\n\t\t\t    rdev->irq.hpd[i], \"HPD\", i);\n\t\t}\n\t}\n\n\tWREG32(CG_THERMAL_INT, thermal_int);\n\n\t \n\tRREG32(SRBM_STATUS);\n\n\treturn 0;\n}\n\n \nstatic inline void si_irq_ack(struct radeon_device *rdev)\n{\n\tint i, j;\n\tu32 *disp_int = rdev->irq.stat_regs.evergreen.disp_int;\n\tu32 *grph_int = rdev->irq.stat_regs.evergreen.grph_int;\n\n\tif (ASIC_IS_NODCE(rdev))\n\t\treturn;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tdisp_int[i] = RREG32(si_disp_int_status[i]);\n\t\tif (i < rdev->num_crtc)\n\t\t\tgrph_int[i] = RREG32(GRPH_INT_STATUS + crtc_offsets[i]);\n\t}\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i += 2) {\n\t\tfor (j = i; j < (i + 2); j++) {\n\t\t\tif (grph_int[j] & GRPH_PFLIP_INT_OCCURRED)\n\t\t\t\tWREG32(GRPH_INT_STATUS + crtc_offsets[j],\n\t\t\t\t       GRPH_PFLIP_INT_CLEAR);\n\t\t}\n\n\t\tfor (j = i; j < (i + 2); j++) {\n\t\t\tif (disp_int[j] & LB_D1_VBLANK_INTERRUPT)\n\t\t\t\tWREG32(VBLANK_STATUS + crtc_offsets[j],\n\t\t\t\t       VBLANK_ACK);\n\t\t\tif (disp_int[j] & LB_D1_VLINE_INTERRUPT)\n\t\t\t\tWREG32(VLINE_STATUS + crtc_offsets[j],\n\t\t\t\t       VLINE_ACK);\n\t\t}\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (disp_int[i] & DC_HPD1_INTERRUPT)\n\t\t\tWREG32_OR(DC_HPDx_INT_CONTROL(i), DC_HPDx_INT_ACK);\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (disp_int[i] & DC_HPD1_RX_INTERRUPT)\n\t\t\tWREG32_OR(DC_HPDx_INT_CONTROL(i), DC_HPDx_RX_INT_ACK);\n\t}\n}\n\nstatic void si_irq_disable(struct radeon_device *rdev)\n{\n\tsi_disable_interrupts(rdev);\n\t \n\tmdelay(1);\n\tsi_irq_ack(rdev);\n\tsi_disable_interrupt_state(rdev);\n}\n\nstatic void si_irq_suspend(struct radeon_device *rdev)\n{\n\tsi_irq_disable(rdev);\n\tsi_rlc_stop(rdev);\n}\n\nstatic void si_irq_fini(struct radeon_device *rdev)\n{\n\tsi_irq_suspend(rdev);\n\tr600_ih_ring_fini(rdev);\n}\n\nstatic inline u32 si_get_ih_wptr(struct radeon_device *rdev)\n{\n\tu32 wptr, tmp;\n\n\tif (rdev->wb.enabled)\n\t\twptr = le32_to_cpu(rdev->wb.wb[R600_WB_IH_WPTR_OFFSET/4]);\n\telse\n\t\twptr = RREG32(IH_RB_WPTR);\n\n\tif (wptr & RB_OVERFLOW) {\n\t\twptr &= ~RB_OVERFLOW;\n\t\t \n\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);\n\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;\n\t\ttmp = RREG32(IH_RB_CNTL);\n\t\ttmp |= IH_WPTR_OVERFLOW_CLEAR;\n\t\tWREG32(IH_RB_CNTL, tmp);\n\t}\n\treturn (wptr & rdev->ih.ptr_mask);\n}\n\n \nint si_irq_process(struct radeon_device *rdev)\n{\n\tu32 *disp_int = rdev->irq.stat_regs.evergreen.disp_int;\n\tu32 crtc_idx, hpd_idx;\n\tu32 mask;\n\tu32 wptr;\n\tu32 rptr;\n\tu32 src_id, src_data, ring_id;\n\tu32 ring_index;\n\tbool queue_hotplug = false;\n\tbool queue_dp = false;\n\tbool queue_thermal = false;\n\tu32 status, addr;\n\tconst char *event_name;\n\n\tif (!rdev->ih.enabled || rdev->shutdown)\n\t\treturn IRQ_NONE;\n\n\twptr = si_get_ih_wptr(rdev);\n\nrestart_ih:\n\t \n\tif (atomic_xchg(&rdev->ih.lock, 1))\n\t\treturn IRQ_NONE;\n\n\trptr = rdev->ih.rptr;\n\tDRM_DEBUG(\"si_irq_process start: rptr %d, wptr %d\\n\", rptr, wptr);\n\n\t \n\trmb();\n\n\t \n\tsi_irq_ack(rdev);\n\n\twhile (rptr != wptr) {\n\t\t \n\t\tring_index = rptr / 4;\n\t\tsrc_id =  le32_to_cpu(rdev->ih.ring[ring_index]) & 0xff;\n\t\tsrc_data = le32_to_cpu(rdev->ih.ring[ring_index + 1]) & 0xfffffff;\n\t\tring_id = le32_to_cpu(rdev->ih.ring[ring_index + 2]) & 0xff;\n\n\t\tswitch (src_id) {\n\t\tcase 1:  \n\t\tcase 2:  \n\t\tcase 3:  \n\t\tcase 4:  \n\t\tcase 5:  \n\t\tcase 6:  \n\t\t\tcrtc_idx = src_id - 1;\n\n\t\t\tif (src_data == 0) {  \n\t\t\t\tmask = LB_D1_VBLANK_INTERRUPT;\n\t\t\t\tevent_name = \"vblank\";\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[crtc_idx]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, crtc_idx);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[crtc_idx])) {\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev,\n\t\t\t\t\t\t\t\t  crtc_idx);\n\t\t\t\t}\n\n\t\t\t} else if (src_data == 1) {  \n\t\t\t\tmask = LB_D1_VLINE_INTERRUPT;\n\t\t\t\tevent_name = \"vline\";\n\t\t\t} else {\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t\t\t  src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(disp_int[crtc_idx] & mask)) {\n\t\t\t\tDRM_DEBUG(\"IH: D%d %s - IH event w/o asserted irq bit?\\n\",\n\t\t\t\t\t  crtc_idx + 1, event_name);\n\t\t\t}\n\n\t\t\tdisp_int[crtc_idx] &= ~mask;\n\t\t\tDRM_DEBUG(\"IH: D%d %s\\n\", crtc_idx + 1, event_name);\n\n\t\t\tbreak;\n\t\tcase 8:  \n\t\tcase 10:  \n\t\tcase 12:  \n\t\tcase 14:  \n\t\tcase 16:  \n\t\tcase 18:  \n\t\t\tDRM_DEBUG(\"IH: D%d flip\\n\", ((src_id - 8) >> 1) + 1);\n\t\t\tif (radeon_use_pflipirq > 0)\n\t\t\t\tradeon_crtc_handle_flip(rdev, (src_id - 8) >> 1);\n\t\t\tbreak;\n\t\tcase 42:  \n\t\t\tif (src_data <= 5) {\n\t\t\t\thpd_idx = src_data;\n\t\t\t\tmask = DC_HPD1_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tevent_name = \"HPD\";\n\n\t\t\t} else if (src_data <= 11) {\n\t\t\t\thpd_idx = src_data - 6;\n\t\t\t\tmask = DC_HPD1_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tevent_name = \"HPD_RX\";\n\n\t\t\t} else {\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t\t\t  src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(disp_int[hpd_idx] & mask))\n\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\tdisp_int[hpd_idx] &= ~mask;\n\t\t\tDRM_DEBUG(\"IH: %s%d\\n\", event_name, hpd_idx + 1);\n\t\t\tbreak;\n\t\tcase 96:\n\t\t\tDRM_ERROR(\"SRBM_READ_ERROR: 0x%x\\n\", RREG32(SRBM_READ_ERROR));\n\t\t\tWREG32(SRBM_INT_ACK, 0x1);\n\t\t\tbreak;\n\t\tcase 124:  \n\t\t\tDRM_DEBUG(\"IH: UVD int: 0x%08x\\n\", src_data);\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_UVD_INDEX);\n\t\t\tbreak;\n\t\tcase 146:\n\t\tcase 147:\n\t\t\taddr = RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR);\n\t\t\tstatus = RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS);\n\t\t\t \n\t\t\tWREG32_P(VM_CONTEXT1_CNTL2, 1, ~1);\n\t\t\tif (addr == 0x0 && status == 0x0)\n\t\t\t\tbreak;\n\t\t\tdev_err(rdev->dev, \"GPU fault detected: %d 0x%08x\\n\", src_id, src_data);\n\t\t\tdev_err(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t\t\taddr);\n\t\t\tdev_err(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t\t\tstatus);\n\t\t\tsi_vm_decode_fault(rdev, status, addr);\n\t\t\tbreak;\n\t\tcase 176:  \n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\tbreak;\n\t\tcase 177:  \n\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\t\t\tbreak;\n\t\tcase 178:  \n\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\t\t\tbreak;\n\t\tcase 181:  \n\t\t\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\t\t\tswitch (ring_id) {\n\t\t\tcase 0:\n\t\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 224:  \n\t\t\tDRM_DEBUG(\"IH: DMA trap\\n\");\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_DMA_INDEX);\n\t\t\tbreak;\n\t\tcase 230:  \n\t\t\tDRM_DEBUG(\"IH: thermal low to high\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = false;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 231:  \n\t\t\tDRM_DEBUG(\"IH: thermal high to low\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = true;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 233:  \n\t\t\tDRM_DEBUG(\"IH: GUI idle\\n\");\n\t\t\tbreak;\n\t\tcase 244:  \n\t\t\tDRM_DEBUG(\"IH: DMA1 trap\\n\");\n\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_DMA1_INDEX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trptr += 16;\n\t\trptr &= rdev->ih.ptr_mask;\n\t\tWREG32(IH_RB_RPTR, rptr);\n\t}\n\tif (queue_dp)\n\t\tschedule_work(&rdev->dp_work);\n\tif (queue_hotplug)\n\t\tschedule_delayed_work(&rdev->hotplug_work, 0);\n\tif (queue_thermal && rdev->pm.dpm_enabled)\n\t\tschedule_work(&rdev->pm.dpm.thermal.work);\n\trdev->ih.rptr = rptr;\n\tatomic_set(&rdev->ih.lock, 0);\n\n\t \n\twptr = si_get_ih_wptr(rdev);\n\tif (wptr != rptr)\n\t\tgoto restart_ih;\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void si_uvd_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = radeon_uvd_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_uvd = false;\n\t\treturn;\n\t}\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[R600_RING_TYPE_UVD_INDEX], 4096);\n}\n\nstatic void si_uvd_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = uvd_v2_2_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_UVD_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size = 0;\n}\n\nstatic void si_uvd_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_uvd || !rdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, PACKET0(UVD_NO_OP, 0));\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = uvd_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic void si_vce_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_vce)\n\t\treturn;\n\n\tr = radeon_vce_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_vce = false;\n\t\treturn;\n\t}\n\trdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[TN_RING_TYPE_VCE1_INDEX], 4096);\n\trdev->ring[TN_RING_TYPE_VCE2_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[TN_RING_TYPE_VCE2_INDEX], 4096);\n}\n\nstatic void si_vce_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_vce)\n\t\treturn;\n\n\tr = radeon_vce_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = vce_v1_0_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, TN_RING_TYPE_VCE1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, TN_RING_TYPE_VCE2_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE2 fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_size = 0;\n\trdev->ring[TN_RING_TYPE_VCE2_INDEX].ring_size = 0;\n}\n\nstatic void si_vce_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_vce || !rdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, VCE_CMD_NO_OP);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, VCE_CMD_NO_OP);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = vce_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic int si_startup(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\t \n\tsi_pcie_gen3_enable(rdev);\n\t \n\tsi_program_aspm(rdev);\n\n\t \n\tr = r600_vram_scratch_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tsi_mc_program(rdev);\n\n\tif (!rdev->pm.dpm_enabled) {\n\t\tr = si_mc_load_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load MC firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = si_pcie_gart_enable(rdev);\n\tif (r)\n\t\treturn r;\n\tsi_gpu_init(rdev);\n\n\t \n\tif (rdev->family == CHIP_VERDE) {\n\t\trdev->rlc.reg_list = verde_rlc_save_restore_register_list;\n\t\trdev->rlc.reg_list_size =\n\t\t\t(u32)ARRAY_SIZE(verde_rlc_save_restore_register_list);\n\t}\n\trdev->rlc.cs_data = si_cs_data;\n\tr = sumo_rlc_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_DMA_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_DMA1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tsi_uvd_start(rdev);\n\tsi_vce_start(rdev);\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = si_irq_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: IH init failed (%d).\\n\", r);\n\t\tradeon_irq_kms_fini(rdev);\n\t\treturn r;\n\t}\n\tsi_irq_set(rdev);\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP1_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP2_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,\n\t\t\t     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, CAYMAN_WB_DMA1_RPTR_OFFSET,\n\t\t\t     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tr = si_cp_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\tr = si_cp_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = cayman_dma_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tsi_uvd_resume(rdev);\n\tsi_vce_resume(rdev);\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_vm_manager_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"vm manager initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint si_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\n\t \n\tsi_init_golden_registers(rdev);\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_resume(rdev);\n\n\trdev->accel_working = true;\n\tr = si_startup(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"si startup failed on resume\\n\");\n\t\trdev->accel_working = false;\n\t\treturn r;\n\t}\n\n\treturn r;\n\n}\n\nint si_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tradeon_vm_manager_fini(rdev);\n\tsi_cp_enable(rdev, false);\n\tcayman_dma_stop(rdev);\n\tif (rdev->has_uvd) {\n\t\tradeon_uvd_suspend(rdev);\n\t\tuvd_v1_0_fini(rdev);\n\t}\n\tif (rdev->has_vce)\n\t\tradeon_vce_suspend(rdev);\n\tsi_fini_pg(rdev);\n\tsi_fini_cg(rdev);\n\tsi_irq_suspend(rdev);\n\tradeon_wb_disable(rdev);\n\tsi_pcie_gart_disable(rdev);\n\treturn 0;\n}\n\n \nint si_init(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r;\n\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting atombios for cayman GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_atombios_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (!radeon_card_posted(rdev)) {\n\t\tif (!rdev->bios) {\n\t\t\tdev_err(rdev->dev, \"Card not posted and no BIOS - ignoring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDRM_INFO(\"GPU not posted. posting now...\\n\");\n\t\tatom_asic_init(rdev->mode_info.atom_context);\n\t}\n\t \n\tsi_init_golden_registers(rdev);\n\t \n\tsi_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\n\t \n\tradeon_fence_driver_init(rdev);\n\n\t \n\tr = si_mc_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->ce_fw ||\n\t    !rdev->rlc_fw || !rdev->mc_fw) {\n\t\tr = si_init_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\tradeon_pm_init(rdev);\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 64 * 1024);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 64 * 1024);\n\n\tsi_uvd_init(rdev);\n\tsi_vce_init(rdev);\n\n\trdev->ih.ring_obj = NULL;\n\tr600_ih_ring_init(rdev, 64 * 1024);\n\n\tr = r600_pcie_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\trdev->accel_working = true;\n\tr = si_startup(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"disabling GPU acceleration\\n\");\n\t\tsi_cp_fini(rdev);\n\t\tcayman_dma_fini(rdev);\n\t\tsi_irq_fini(rdev);\n\t\tsumo_rlc_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_vm_manager_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tsi_pcie_gart_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\n\t \n\tif (!rdev->mc_fw) {\n\t\tDRM_ERROR(\"radeon: MC ucode required for NI+.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid si_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tsi_cp_fini(rdev);\n\tcayman_dma_fini(rdev);\n\tsi_fini_pg(rdev);\n\tsi_fini_cg(rdev);\n\tsi_irq_fini(rdev);\n\tsumo_rlc_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_vm_manager_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tif (rdev->has_uvd) {\n\t\tuvd_v1_0_fini(rdev);\n\t\tradeon_uvd_fini(rdev);\n\t}\n\tif (rdev->has_vce)\n\t\tradeon_vce_fini(rdev);\n\tsi_pcie_gart_fini(rdev);\n\tr600_vram_scratch_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\n \nuint64_t si_get_gpu_clock_counter(struct radeon_device *rdev)\n{\n\tuint64_t clock;\n\n\tmutex_lock(&rdev->gpu_clock_mutex);\n\tWREG32(RLC_CAPTURE_GPU_CLOCK_COUNT, 1);\n\tclock = (uint64_t)RREG32(RLC_GPU_CLOCK_COUNT_LSB) |\n\t\t((uint64_t)RREG32(RLC_GPU_CLOCK_COUNT_MSB) << 32ULL);\n\tmutex_unlock(&rdev->gpu_clock_mutex);\n\treturn clock;\n}\n\nint si_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk)\n{\n\tunsigned fb_div = 0, vclk_div = 0, dclk_div = 0;\n\tint r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\tVCLK_SRC_SEL(1) | DCLK_SRC_SEL(1),\n\t\t~(VCLK_SRC_SEL_MASK | DCLK_SRC_SEL_MASK));\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_BYPASS_EN_MASK, ~UPLL_BYPASS_EN_MASK);\n\n\tif (!vclk || !dclk) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tr = radeon_uvd_calc_upll_dividers(rdev, vclk, dclk, 125000, 250000,\n\t\t\t\t\t  16384, 0x03FFFFFF, 0, 128, 5,\n\t\t\t\t\t  &fb_div, &vclk_div, &dclk_div);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_5, 0, ~RESET_ANTI_MUX_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_VCO_MODE_MASK, ~UPLL_VCO_MODE_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_SLEEP_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_RESET_MASK);\n\n\tmdelay(1);\n\n\tr = radeon_uvd_send_upll_ctlreq(rdev, CG_UPLL_FUNC_CNTL);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_RESET_MASK, ~UPLL_RESET_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_SPREAD_SPECTRUM, 0, ~SSEN_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_3, UPLL_FB_DIV(fb_div), ~UPLL_FB_DIV_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_REF_DIV_MASK);\n\n\tif (fb_div < 307200)\n\t\tWREG32_P(CG_UPLL_FUNC_CNTL_4, 0, ~UPLL_SPARE_ISPARE9);\n\telse\n\t\tWREG32_P(CG_UPLL_FUNC_CNTL_4, UPLL_SPARE_ISPARE9, ~UPLL_SPARE_ISPARE9);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\tUPLL_PDIV_A(vclk_div) | UPLL_PDIV_B(dclk_div),\n\t\t~(UPLL_PDIV_A_MASK | UPLL_PDIV_B_MASK));\n\n\t \n\tmdelay(15);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_RESET_MASK);\n\n\tmdelay(15);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_BYPASS_EN_MASK);\n\n\tr = radeon_uvd_send_upll_ctlreq(rdev, CG_UPLL_FUNC_CNTL);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\tVCLK_SRC_SEL(2) | DCLK_SRC_SEL(2),\n\t\t~(VCLK_SRC_SEL_MASK | DCLK_SRC_SEL_MASK));\n\n\tmdelay(100);\n\n\treturn 0;\n}\n\nstatic void si_pcie_gen3_enable(struct radeon_device *rdev)\n{\n\tstruct pci_dev *root = rdev->pdev->bus->self;\n\tenum pci_bus_speed speed_cap;\n\tu32 speed_cntl, current_data_rate;\n\tint i;\n\tu16 tmp16;\n\n\tif (pci_is_root_bus(rdev->pdev->bus))\n\t\treturn;\n\n\tif (radeon_pcie_gen2 == 0)\n\t\treturn;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\tspeed_cap = pcie_get_speed_cap(root);\n\tif (speed_cap == PCI_SPEED_UNKNOWN)\n\t\treturn;\n\n\tif ((speed_cap != PCIE_SPEED_8_0GT) &&\n\t    (speed_cap != PCIE_SPEED_5_0GT))\n\t\treturn;\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tcurrent_data_rate = (speed_cntl & LC_CURRENT_DATA_RATE_MASK) >>\n\t\tLC_CURRENT_DATA_RATE_SHIFT;\n\tif (speed_cap == PCIE_SPEED_8_0GT) {\n\t\tif (current_data_rate == 2) {\n\t\t\tDRM_INFO(\"PCIE gen 3 link speeds already enabled\\n\");\n\t\t\treturn;\n\t\t}\n\t\tDRM_INFO(\"enabling PCIE gen 3 link speeds, disable with radeon.pcie_gen2=0\\n\");\n\t} else if (speed_cap == PCIE_SPEED_5_0GT) {\n\t\tif (current_data_rate == 1) {\n\t\t\tDRM_INFO(\"PCIE gen 2 link speeds already enabled\\n\");\n\t\t\treturn;\n\t\t}\n\t\tDRM_INFO(\"enabling PCIE gen 2 link speeds, disable with radeon.pcie_gen2=0\\n\");\n\t}\n\n\tif (!pci_is_pcie(root) || !pci_is_pcie(rdev->pdev))\n\t\treturn;\n\n\tif (speed_cap == PCIE_SPEED_8_0GT) {\n\t\t \n\t\tif (current_data_rate != 2) {\n\t\t\tu16 bridge_cfg, gpu_cfg;\n\t\t\tu16 bridge_cfg2, gpu_cfg2;\n\t\t\tu32 max_lw, current_lw, tmp;\n\n\t\t\tpcie_capability_set_word(root, PCI_EXP_LNKCTL, PCI_EXP_LNKCTL_HAWD);\n\t\t\tpcie_capability_set_word(rdev->pdev, PCI_EXP_LNKCTL, PCI_EXP_LNKCTL_HAWD);\n\n\t\t\ttmp = RREG32_PCIE(PCIE_LC_STATUS1);\n\t\t\tmax_lw = (tmp & LC_DETECTED_LINK_WIDTH_MASK) >> LC_DETECTED_LINK_WIDTH_SHIFT;\n\t\t\tcurrent_lw = (tmp & LC_OPERATING_LINK_WIDTH_MASK) >> LC_OPERATING_LINK_WIDTH_SHIFT;\n\n\t\t\tif (current_lw < max_lw) {\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t\t\tif (tmp & LC_RENEGOTIATION_SUPPORT) {\n\t\t\t\t\ttmp &= ~(LC_LINK_WIDTH_MASK | LC_UPCONFIGURE_DIS);\n\t\t\t\t\ttmp |= (max_lw << LC_LINK_WIDTH_SHIFT);\n\t\t\t\t\ttmp |= LC_UPCONFIGURE_SUPPORT | LC_RENEGOTIATE_EN | LC_RECONFIG_NOW;\n\t\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t \n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_DEVSTA,\n\t\t\t\t\t\t\t  &tmp16);\n\t\t\t\tif (tmp16 & PCI_EXP_DEVSTA_TRPND)\n\t\t\t\t\tbreak;\n\n\t\t\t\tpcie_capability_read_word(root, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t  &bridge_cfg);\n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t  &gpu_cfg);\n\n\t\t\t\tpcie_capability_read_word(root, PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &bridge_cfg2);\n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &gpu_cfg2);\n\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL4);\n\t\t\t\ttmp |= LC_SET_QUIESCE;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL4, tmp);\n\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL4);\n\t\t\t\ttmp |= LC_REDO_EQ;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL4, tmp);\n\n\t\t\t\tmsleep(100);\n\n\t\t\t\t \n\t\t\t\tpcie_capability_clear_and_set_word(root, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD,\n\t\t\t\t\t\t\t\t   bridge_cfg &\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD);\n\t\t\t\tpcie_capability_clear_and_set_word(rdev->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD,\n\t\t\t\t\t\t\t\t   gpu_cfg &\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD);\n\n\t\t\t\t \n\t\t\t\tpcie_capability_read_word(root, PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &tmp16);\n\t\t\t\ttmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN);\n\t\t\t\ttmp16 |= (bridge_cfg2 &\n\t\t\t\t\t  (PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN));\n\t\t\t\tpcie_capability_write_word(root,\n\t\t\t\t\t\t\t   PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t   tmp16);\n\n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &tmp16);\n\t\t\t\ttmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN);\n\t\t\t\ttmp16 |= (gpu_cfg2 &\n\t\t\t\t\t  (PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN));\n\t\t\t\tpcie_capability_write_word(rdev->pdev,\n\t\t\t\t\t\t\t   PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t   tmp16);\n\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL4);\n\t\t\t\ttmp &= ~LC_SET_QUIESCE;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL4, tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tspeed_cntl |= LC_FORCE_EN_SW_SPEED_CHANGE | LC_FORCE_DIS_HW_SPEED_CHANGE;\n\tspeed_cntl &= ~LC_FORCE_DIS_SW_SPEED_CHANGE;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\tpcie_capability_read_word(rdev->pdev, PCI_EXP_LNKCTL2, &tmp16);\n\ttmp16 &= ~PCI_EXP_LNKCTL2_TLS;\n\tif (speed_cap == PCIE_SPEED_8_0GT)\n\t\ttmp16 |= PCI_EXP_LNKCTL2_TLS_8_0GT;  \n\telse if (speed_cap == PCIE_SPEED_5_0GT)\n\t\ttmp16 |= PCI_EXP_LNKCTL2_TLS_5_0GT;  \n\telse\n\t\ttmp16 |= PCI_EXP_LNKCTL2_TLS_2_5GT;  \n\tpcie_capability_write_word(rdev->pdev, PCI_EXP_LNKCTL2, tmp16);\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tspeed_cntl |= LC_INITIATE_LINK_SPEED_CHANGE;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tif ((speed_cntl & LC_INITIATE_LINK_SPEED_CHANGE) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void si_program_aspm(struct radeon_device *rdev)\n{\n\tu32 data, orig;\n\tbool disable_l0s = false, disable_l1 = false, disable_plloff_in_l1 = false;\n\tbool disable_clkreq = false;\n\n\tif (radeon_aspm == 0)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\torig = data = RREG32_PCIE_PORT(PCIE_LC_N_FTS_CNTL);\n\tdata &= ~LC_XMIT_N_FTS_MASK;\n\tdata |= LC_XMIT_N_FTS(0x24) | LC_XMIT_N_FTS_OVERRIDE_EN;\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_LC_N_FTS_CNTL, data);\n\n\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL3);\n\tdata |= LC_GO_TO_RECOVERY;\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL3, data);\n\n\torig = data = RREG32_PCIE(PCIE_P_CNTL);\n\tdata |= P_IGNORE_EDB_ERR;\n\tif (orig != data)\n\t\tWREG32_PCIE(PCIE_P_CNTL, data);\n\n\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\tdata &= ~(LC_L0S_INACTIVITY_MASK | LC_L1_INACTIVITY_MASK);\n\tdata |= LC_PMI_TO_L1_DIS;\n\tif (!disable_l0s)\n\t\tdata |= LC_L0S_INACTIVITY(7);\n\n\tif (!disable_l1) {\n\t\tdata |= LC_L1_INACTIVITY(7);\n\t\tdata &= ~LC_PMI_TO_L1_DIS;\n\t\tif (orig != data)\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, data);\n\n\t\tif (!disable_plloff_in_l1) {\n\t\t\tbool clk_req_support;\n\n\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_0_MASK | PLL_POWER_STATE_IN_TXS2_0_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_0(7) | PLL_POWER_STATE_IN_TXS2_0(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0, data);\n\n\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_1_MASK | PLL_POWER_STATE_IN_TXS2_1_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_1(7) | PLL_POWER_STATE_IN_TXS2_1(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1, data);\n\n\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_0_MASK | PLL_POWER_STATE_IN_TXS2_0_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_0(7) | PLL_POWER_STATE_IN_TXS2_0(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0, data);\n\n\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_1_MASK | PLL_POWER_STATE_IN_TXS2_1_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_1(7) | PLL_POWER_STATE_IN_TXS2_1(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1, data);\n\n\t\t\tif ((rdev->family != CHIP_OLAND) && (rdev->family != CHIP_HAINAN)) {\n\t\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_0_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_1_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_2);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_2_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_2, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_3);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_3_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_3, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_0_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_1_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_2);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_2_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_2, data);\n\n\t\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_3);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_3_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_3, data);\n\t\t\t}\n\t\t\torig = data = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t\tdata &= ~LC_DYN_LANES_PWR_STATE_MASK;\n\t\t\tdata |= LC_DYN_LANES_PWR_STATE(3);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, data);\n\n\t\t\torig = data = RREG32_PIF_PHY0(PB0_PIF_CNTL);\n\t\t\tdata &= ~LS2_EXIT_TIME_MASK;\n\t\t\tif ((rdev->family == CHIP_OLAND) || (rdev->family == CHIP_HAINAN))\n\t\t\t\tdata |= LS2_EXIT_TIME(5);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_CNTL, data);\n\n\t\t\torig = data = RREG32_PIF_PHY1(PB1_PIF_CNTL);\n\t\t\tdata &= ~LS2_EXIT_TIME_MASK;\n\t\t\tif ((rdev->family == CHIP_OLAND) || (rdev->family == CHIP_HAINAN))\n\t\t\t\tdata |= LS2_EXIT_TIME(5);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_CNTL, data);\n\n\t\t\tif (!disable_clkreq &&\n\t\t\t    !pci_is_root_bus(rdev->pdev->bus)) {\n\t\t\t\tstruct pci_dev *root = rdev->pdev->bus->self;\n\t\t\t\tu32 lnkcap;\n\n\t\t\t\tclk_req_support = false;\n\t\t\t\tpcie_capability_read_dword(root, PCI_EXP_LNKCAP, &lnkcap);\n\t\t\t\tif (lnkcap & PCI_EXP_LNKCAP_CLKPM)\n\t\t\t\t\tclk_req_support = true;\n\t\t\t} else {\n\t\t\t\tclk_req_support = false;\n\t\t\t}\n\n\t\t\tif (clk_req_support) {\n\t\t\t\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL2);\n\t\t\t\tdata |= LC_ALLOW_PDWN_IN_L1 | LC_ALLOW_PDWN_IN_L23;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL2, data);\n\n\t\t\t\torig = data = RREG32(THM_CLK_CNTL);\n\t\t\t\tdata &= ~(CMON_CLK_SEL_MASK | TMON_CLK_SEL_MASK);\n\t\t\t\tdata |= CMON_CLK_SEL(1) | TMON_CLK_SEL(1);\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(THM_CLK_CNTL, data);\n\n\t\t\t\torig = data = RREG32(MISC_CLK_CNTL);\n\t\t\t\tdata &= ~(DEEP_SLEEP_CLK_SEL_MASK | ZCLK_SEL_MASK);\n\t\t\t\tdata |= DEEP_SLEEP_CLK_SEL(1) | ZCLK_SEL(1);\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(MISC_CLK_CNTL, data);\n\n\t\t\t\torig = data = RREG32(CG_CLKPIN_CNTL);\n\t\t\t\tdata &= ~BCLK_AS_XCLK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(CG_CLKPIN_CNTL, data);\n\n\t\t\t\torig = data = RREG32(CG_CLKPIN_CNTL_2);\n\t\t\t\tdata &= ~FORCE_BIF_REFCLK_EN;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(CG_CLKPIN_CNTL_2, data);\n\n\t\t\t\torig = data = RREG32(MPLL_BYPASSCLK_SEL);\n\t\t\t\tdata &= ~MPLL_CLKOUT_SEL_MASK;\n\t\t\t\tdata |= MPLL_CLKOUT_SEL(4);\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(MPLL_BYPASSCLK_SEL, data);\n\n\t\t\t\torig = data = RREG32(SPLL_CNTL_MODE);\n\t\t\t\tdata &= ~SPLL_REFCLK_SEL_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(SPLL_CNTL_MODE, data);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (orig != data)\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, data);\n\t}\n\n\torig = data = RREG32_PCIE(PCIE_CNTL2);\n\tdata |= SLV_MEM_LS_EN | MST_MEM_LS_EN | REPLAY_MEM_LS_EN;\n\tif (orig != data)\n\t\tWREG32_PCIE(PCIE_CNTL2, data);\n\n\tif (!disable_l0s) {\n\t\tdata = RREG32_PCIE_PORT(PCIE_LC_N_FTS_CNTL);\n\t\tif((data & LC_N_FTS_MASK) == LC_N_FTS_MASK) {\n\t\t\tdata = RREG32_PCIE(PCIE_LC_STATUS1);\n\t\t\tif ((data & LC_REVERSE_XMIT) && (data & LC_REVERSE_RCVR)) {\n\t\t\t\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\t\t\t\tdata &= ~LC_L0S_INACTIVITY_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, data);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int si_vce_send_vcepll_ctlreq(struct radeon_device *rdev)\n{\n\tunsigned i;\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~UPLL_CTLREQ_MASK);\n\n\tmdelay(10);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, UPLL_CTLREQ_MASK, ~UPLL_CTLREQ_MASK);\n\n\t \n\tfor (i = 0; i < 100; ++i) {\n\t\tuint32_t mask = UPLL_CTLACK_MASK | UPLL_CTLACK2_MASK;\n\t\tif ((RREG32_SMC(CG_VCEPLL_FUNC_CNTL) & mask) == mask)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~UPLL_CTLREQ_MASK);\n\n\tif (i == 100) {\n\t\tDRM_ERROR(\"Timeout setting UVD clocks!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint si_set_vce_clocks(struct radeon_device *rdev, u32 evclk, u32 ecclk)\n{\n\tunsigned fb_div = 0, evclk_div = 0, ecclk_div = 0;\n\tint r;\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL_2,\n\t\t     EVCLK_SRC_SEL(1) | ECCLK_SRC_SEL(1),\n\t\t     ~(EVCLK_SRC_SEL_MASK | ECCLK_SRC_SEL_MASK));\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, VCEPLL_BYPASS_EN_MASK,\n\t\t     ~VCEPLL_BYPASS_EN_MASK);\n\n\tif (!evclk || !ecclk) {\n\t\t \n\t\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, VCEPLL_SLEEP_MASK,\n\t\t\t     ~VCEPLL_SLEEP_MASK);\n\t\treturn 0;\n\t}\n\n\tr = radeon_uvd_calc_upll_dividers(rdev, evclk, ecclk, 125000, 250000,\n\t\t\t\t\t  16384, 0x03FFFFFF, 0, 128, 5,\n\t\t\t\t\t  &fb_div, &evclk_div, &ecclk_div);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL_5, 0, ~RESET_ANTI_MUX_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, VCEPLL_VCO_MODE_MASK,\n\t\t     ~VCEPLL_VCO_MODE_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, VCEPLL_SLEEP_MASK,\n\t\t     ~VCEPLL_SLEEP_MASK);\n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~VCEPLL_SLEEP_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~VCEPLL_RESET_MASK);\n\n\tmdelay(1);\n\n\tr = si_vce_send_vcepll_ctlreq(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, VCEPLL_RESET_MASK, ~VCEPLL_RESET_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_SPREAD_SPECTRUM, 0, ~SSEN_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL_3, VCEPLL_FB_DIV(fb_div), ~VCEPLL_FB_DIV_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~VCEPLL_REF_DIV_MASK);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL_2,\n\t\t     VCEPLL_PDIV_A(evclk_div) | VCEPLL_PDIV_B(ecclk_div),\n\t\t     ~(VCEPLL_PDIV_A_MASK | VCEPLL_PDIV_B_MASK));\n\n\t \n\tmdelay(15);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~VCEPLL_RESET_MASK);\n\n\tmdelay(15);\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL, 0, ~VCEPLL_BYPASS_EN_MASK);\n\n\tr = si_vce_send_vcepll_ctlreq(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_SMC_P(CG_VCEPLL_FUNC_CNTL_2,\n\t\t     EVCLK_SRC_SEL(16) | ECCLK_SRC_SEL(16),\n\t\t     ~(EVCLK_SRC_SEL_MASK | ECCLK_SRC_SEL_MASK));\n\n\tmdelay(100);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}