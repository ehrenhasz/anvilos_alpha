{
  "module_name": "rv515.c",
  "hash_id": "c8d390ac652847d16247631e2827fabd1dafe543a46316e20160b7a2d43d76ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rv515.c",
  "human_readable_source": " \n\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"rv515_reg_safe.h\"\n#include \"rv515d.h\"\n\n \nstatic void rv515_gpu_init(struct radeon_device *rdev);\nint rv515_mc_wait_for_idle(struct radeon_device *rdev);\n\nstatic const u32 crtc_offsets[2] =\n{\n\t0,\n\tAVIVO_D2CRTC_H_TOTAL - AVIVO_D1CRTC_H_TOTAL\n};\n\nvoid rv515_ring_start(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tint r;\n\n\tr = radeon_ring_lock(rdev, ring, 64);\n\tif (r) {\n\t\treturn;\n\t}\n\tradeon_ring_write(ring, PACKET0(ISYNC_CNTL, 0));\n\tradeon_ring_write(ring,\n\t\t\t  ISYNC_ANY2D_IDLE3D |\n\t\t\t  ISYNC_ANY3D_IDLE2D |\n\t\t\t  ISYNC_WAIT_IDLEGUI |\n\t\t\t  ISYNC_CPSCRATCH_IDLEGUI);\n\tradeon_ring_write(ring, PACKET0(WAIT_UNTIL, 0));\n\tradeon_ring_write(ring, WAIT_2D_IDLECLEAN | WAIT_3D_IDLECLEAN);\n\tradeon_ring_write(ring, PACKET0(R300_DST_PIPE_CONFIG, 0));\n\tradeon_ring_write(ring, R300_PIPE_AUTO_CONFIG);\n\tradeon_ring_write(ring, PACKET0(GB_SELECT, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(GB_ENABLE, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(R500_SU_REG_DEST, 0));\n\tradeon_ring_write(ring, (1 << rdev->num_gb_pipes) - 1);\n\tradeon_ring_write(ring, PACKET0(VAP_INDEX_OFFSET, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(RB3D_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, RB3D_DC_FLUSH | RB3D_DC_FREE);\n\tradeon_ring_write(ring, PACKET0(ZB_ZCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, ZC_FLUSH | ZC_FREE);\n\tradeon_ring_write(ring, PACKET0(WAIT_UNTIL, 0));\n\tradeon_ring_write(ring, WAIT_2D_IDLECLEAN | WAIT_3D_IDLECLEAN);\n\tradeon_ring_write(ring, PACKET0(GB_AA_CONFIG, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(RB3D_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, RB3D_DC_FLUSH | RB3D_DC_FREE);\n\tradeon_ring_write(ring, PACKET0(ZB_ZCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, ZC_FLUSH | ZC_FREE);\n\tradeon_ring_write(ring, PACKET0(GB_MSPOS0, 0));\n\tradeon_ring_write(ring,\n\t\t\t  ((6 << MS_X0_SHIFT) |\n\t\t\t   (6 << MS_Y0_SHIFT) |\n\t\t\t   (6 << MS_X1_SHIFT) |\n\t\t\t   (6 << MS_Y1_SHIFT) |\n\t\t\t   (6 << MS_X2_SHIFT) |\n\t\t\t   (6 << MS_Y2_SHIFT) |\n\t\t\t   (6 << MSBD0_Y_SHIFT) |\n\t\t\t   (6 << MSBD0_X_SHIFT)));\n\tradeon_ring_write(ring, PACKET0(GB_MSPOS1, 0));\n\tradeon_ring_write(ring,\n\t\t\t  ((6 << MS_X3_SHIFT) |\n\t\t\t   (6 << MS_Y3_SHIFT) |\n\t\t\t   (6 << MS_X4_SHIFT) |\n\t\t\t   (6 << MS_Y4_SHIFT) |\n\t\t\t   (6 << MS_X5_SHIFT) |\n\t\t\t   (6 << MS_Y5_SHIFT) |\n\t\t\t   (6 << MSBD1_SHIFT)));\n\tradeon_ring_write(ring, PACKET0(GA_ENHANCE, 0));\n\tradeon_ring_write(ring, GA_DEADLOCK_CNTL | GA_FASTSYNC_CNTL);\n\tradeon_ring_write(ring, PACKET0(GA_POLY_MODE, 0));\n\tradeon_ring_write(ring, FRONT_PTYPE_TRIANGE | BACK_PTYPE_TRIANGE);\n\tradeon_ring_write(ring, PACKET0(GA_ROUND_MODE, 0));\n\tradeon_ring_write(ring, GEOMETRY_ROUND_NEAREST | COLOR_ROUND_NEAREST);\n\tradeon_ring_write(ring, PACKET0(0x20C8, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n}\n\nint rv515_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32_MC(MC_STATUS);\n\t\tif (tmp & MC_STATUS_IDLE) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nvoid rv515_vga_render_disable(struct radeon_device *rdev)\n{\n\tWREG32(R_000300_VGA_RENDER_CONTROL,\n\t\tRREG32(R_000300_VGA_RENDER_CONTROL) & C_000300_VGA_VSTATUS_CNTL);\n}\n\nstatic void rv515_gpu_init(struct radeon_device *rdev)\n{\n\tunsigned pipe_select_current, gb_pipe_select, tmp;\n\n\tif (r100_gui_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait GUI idle while resetting GPU. Bad things might happen.\\n\");\n\t}\n\trv515_vga_render_disable(rdev);\n\tr420_pipes_init(rdev);\n\tgb_pipe_select = RREG32(R400_GB_PIPE_SELECT);\n\ttmp = RREG32(R300_DST_PIPE_CONFIG);\n\tpipe_select_current = (tmp >> 2) & 3;\n\ttmp = (1 << pipe_select_current) |\n\t      (((gb_pipe_select >> 8) & 0xF) << 4);\n\tWREG32_PLL(0x000D, tmp);\n\tif (r100_gui_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait GUI idle while resetting GPU. Bad things might happen.\\n\");\n\t}\n\tif (rv515_mc_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait MC idle while programming pipes. Bad things might happen.\\n\");\n\t}\n}\n\nstatic void rv515_vram_get_type(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\n\trdev->mc.vram_width = 128;\n\trdev->mc.vram_is_ddr = true;\n\ttmp = RREG32_MC(RV515_MC_CNTL) & MEM_NUM_CHANNELS_MASK;\n\tswitch (tmp) {\n\tcase 0:\n\t\trdev->mc.vram_width = 64;\n\t\tbreak;\n\tcase 1:\n\t\trdev->mc.vram_width = 128;\n\t\tbreak;\n\tdefault:\n\t\trdev->mc.vram_width = 128;\n\t\tbreak;\n\t}\n}\n\nstatic void rv515_mc_init(struct radeon_device *rdev)\n{\n\n\trv515_vram_get_type(rdev);\n\tr100_vram_init_sizes(rdev);\n\tradeon_vram_location(rdev, &rdev->mc, 0);\n\trdev->mc.gtt_base_align = 0;\n\tif (!(rdev->flags & RADEON_IS_AGP))\n\t\tradeon_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n}\n\nuint32_t rv515_mc_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t r;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(MC_IND_INDEX, 0x7f0000 | (reg & 0xffff));\n\tr = RREG32(MC_IND_DATA);\n\tWREG32(MC_IND_INDEX, 0);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n\n\treturn r;\n}\n\nvoid rv515_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(MC_IND_INDEX, 0xff0000 | ((reg) & 0xffff));\n\tWREG32(MC_IND_DATA, (v));\n\tWREG32(MC_IND_INDEX, 0);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n}\n\n#if defined(CONFIG_DEBUG_FS)\nstatic int rv515_debugfs_pipes_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t tmp;\n\n\ttmp = RREG32(GB_PIPE_SELECT);\n\tseq_printf(m, \"GB_PIPE_SELECT 0x%08x\\n\", tmp);\n\ttmp = RREG32(SU_REG_DEST);\n\tseq_printf(m, \"SU_REG_DEST 0x%08x\\n\", tmp);\n\ttmp = RREG32(GB_TILE_CONFIG);\n\tseq_printf(m, \"GB_TILE_CONFIG 0x%08x\\n\", tmp);\n\ttmp = RREG32(DST_PIPE_CONFIG);\n\tseq_printf(m, \"DST_PIPE_CONFIG 0x%08x\\n\", tmp);\n\treturn 0;\n}\n\nstatic int rv515_debugfs_ga_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t tmp;\n\n\ttmp = RREG32(0x2140);\n\tseq_printf(m, \"VAP_CNTL_STATUS 0x%08x\\n\", tmp);\n\tradeon_asic_reset(rdev);\n\ttmp = RREG32(0x425C);\n\tseq_printf(m, \"GA_IDLE 0x%08x\\n\", tmp);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rv515_debugfs_pipes_info);\nDEFINE_SHOW_ATTRIBUTE(rv515_debugfs_ga_info);\n#endif\n\nvoid rv515_debugfs(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"rv515_pipes_info\", 0444, root, rdev,\n\t\t\t    &rv515_debugfs_pipes_info_fops);\n\tdebugfs_create_file(\"rv515_ga_info\", 0444, root, rdev,\n\t\t\t    &rv515_debugfs_ga_info_fops);\n#endif\n\tr100_debugfs_rbbm_init(rdev);\n}\n\nvoid rv515_mc_stop(struct radeon_device *rdev, struct rv515_mc_save *save)\n{\n\tu32 crtc_enabled, tmp, frame_count, blackout;\n\tint i, j;\n\n\tsave->vga_render_control = RREG32(R_000300_VGA_RENDER_CONTROL);\n\tsave->vga_hdp_control = RREG32(R_000328_VGA_HDP_CONTROL);\n\n\t \n\tWREG32(R_000300_VGA_RENDER_CONTROL, 0);\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tcrtc_enabled = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]) & AVIVO_CRTC_EN;\n\t\tif (crtc_enabled) {\n\t\t\tsave->crtc_enabled[i] = true;\n\t\t\ttmp = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]);\n\t\t\tif (!(tmp & AVIVO_CRTC_DISP_READ_REQUEST_DISABLE)) {\n\t\t\t\tradeon_wait_for_vblank(rdev, i);\n\t\t\t\tWREG32(AVIVO_D1CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\t\ttmp |= AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\t\tWREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i], tmp);\n\t\t\t\tWREG32(AVIVO_D1CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\t}\n\t\t\t \n\t\t\tframe_count = radeon_get_vblank_counter(rdev, i);\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\tif (radeon_get_vblank_counter(rdev, i) != frame_count)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\n\t\t\t \n\t\t\tWREG32(AVIVO_D1CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\ttmp = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]);\n\t\t\ttmp &= ~AVIVO_CRTC_EN;\n\t\t\tWREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i], tmp);\n\t\t\tWREG32(AVIVO_D1CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\tsave->crtc_enabled[i] = false;\n\t\t\t \n\t\t} else {\n\t\t\tsave->crtc_enabled[i] = false;\n\t\t}\n\t}\n\n\tradeon_mc_wait_for_idle(rdev);\n\n\tif (rdev->family >= CHIP_R600) {\n\t\tif (rdev->family >= CHIP_RV770)\n\t\t\tblackout = RREG32(R700_MC_CITF_CNTL);\n\t\telse\n\t\t\tblackout = RREG32(R600_CITF_CNTL);\n\t\tif ((blackout & R600_BLACKOUT_MASK) != R600_BLACKOUT_MASK) {\n\t\t\t \n\t\t\tWREG32(R600_BIF_FB_EN, 0);\n\t\t\t \n\t\t\tblackout |= R600_BLACKOUT_MASK;\n\t\t\tif (rdev->family >= CHIP_RV770)\n\t\t\t\tWREG32(R700_MC_CITF_CNTL, blackout);\n\t\t\telse\n\t\t\t\tWREG32(R600_CITF_CNTL, blackout);\n\t\t}\n\t}\n\t \n\tudelay(100);\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (save->crtc_enabled[i]) {\n\t\t\ttmp = RREG32(AVIVO_D1GRPH_UPDATE + crtc_offsets[i]);\n\t\t\tif (!(tmp & AVIVO_D1GRPH_UPDATE_LOCK)) {\n\t\t\t\ttmp |= AVIVO_D1GRPH_UPDATE_LOCK;\n\t\t\t\tWREG32(AVIVO_D1GRPH_UPDATE + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\ttmp = RREG32(AVIVO_D1MODE_MASTER_UPDATE_LOCK + crtc_offsets[i]);\n\t\t\tif (!(tmp & 1)) {\n\t\t\t\ttmp |= 1;\n\t\t\t\tWREG32(AVIVO_D1MODE_MASTER_UPDATE_LOCK + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rv515_mc_resume(struct radeon_device *rdev, struct rv515_mc_save *save)\n{\n\tu32 tmp, frame_count;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (rdev->family >= CHIP_RV770) {\n\t\t\tif (i == 0) {\n\t\t\t\tWREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,\n\t\t\t\t       upper_32_bits(rdev->mc.vram_start));\n\t\t\t\tWREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,\n\t\t\t\t       upper_32_bits(rdev->mc.vram_start));\n\t\t\t} else {\n\t\t\t\tWREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,\n\t\t\t\t       upper_32_bits(rdev->mc.vram_start));\n\t\t\t\tWREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,\n\t\t\t\t       upper_32_bits(rdev->mc.vram_start));\n\t\t\t}\n\t\t}\n\t\tWREG32(R_006110_D1GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],\n\t\t       (u32)rdev->mc.vram_start);\n\t\tWREG32(R_006118_D1GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],\n\t\t       (u32)rdev->mc.vram_start);\n\t}\n\tWREG32(R_000310_VGA_MEMORY_BASE_ADDRESS, (u32)rdev->mc.vram_start);\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (save->crtc_enabled[i]) {\n\t\t\ttmp = RREG32(AVIVO_D1MODE_MASTER_UPDATE_MODE + crtc_offsets[i]);\n\t\t\tif ((tmp & 0x7) != 3) {\n\t\t\t\ttmp &= ~0x7;\n\t\t\t\ttmp |= 0x3;\n\t\t\t\tWREG32(AVIVO_D1MODE_MASTER_UPDATE_MODE + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\ttmp = RREG32(AVIVO_D1GRPH_UPDATE + crtc_offsets[i]);\n\t\t\tif (tmp & AVIVO_D1GRPH_UPDATE_LOCK) {\n\t\t\t\ttmp &= ~AVIVO_D1GRPH_UPDATE_LOCK;\n\t\t\t\tWREG32(AVIVO_D1GRPH_UPDATE + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\ttmp = RREG32(AVIVO_D1MODE_MASTER_UPDATE_LOCK + crtc_offsets[i]);\n\t\t\tif (tmp & 1) {\n\t\t\t\ttmp &= ~1;\n\t\t\t\tWREG32(AVIVO_D1MODE_MASTER_UPDATE_LOCK + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\ttmp = RREG32(AVIVO_D1GRPH_UPDATE + crtc_offsets[i]);\n\t\t\t\tif ((tmp & AVIVO_D1GRPH_SURFACE_UPDATE_PENDING) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rdev->family >= CHIP_R600) {\n\t\t \n\t\tif (rdev->family >= CHIP_RV770)\n\t\t\ttmp = RREG32(R700_MC_CITF_CNTL);\n\t\telse\n\t\t\ttmp = RREG32(R600_CITF_CNTL);\n\t\ttmp &= ~R600_BLACKOUT_MASK;\n\t\tif (rdev->family >= CHIP_RV770)\n\t\t\tWREG32(R700_MC_CITF_CNTL, tmp);\n\t\telse\n\t\t\tWREG32(R600_CITF_CNTL, tmp);\n\t\t \n\t\tWREG32(R600_BIF_FB_EN, R600_FB_READ_EN | R600_FB_WRITE_EN);\n\t}\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (save->crtc_enabled[i]) {\n\t\t\ttmp = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]);\n\t\t\ttmp &= ~AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\tWREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i], tmp);\n\t\t\t \n\t\t\tframe_count = radeon_get_vblank_counter(rdev, i);\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\tif (radeon_get_vblank_counter(rdev, i) != frame_count)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\t \n\tWREG32(R_000328_VGA_HDP_CONTROL, save->vga_hdp_control);\n\tmdelay(1);\n\tWREG32(R_000300_VGA_RENDER_CONTROL, save->vga_render_control);\n}\n\nstatic void rv515_mc_program(struct radeon_device *rdev)\n{\n\tstruct rv515_mc_save save;\n\n\t \n\trv515_mc_stop(rdev, &save);\n\n\t \n\tif (rv515_mc_wait_for_idle(rdev))\n\t\tdev_warn(rdev->dev, \"Wait MC idle timeout before updating MC.\\n\");\n\t \n\tWREG32(R_0000F8_CONFIG_MEMSIZE, rdev->mc.real_vram_size);\n\t \n\tWREG32_MC(R_000001_MC_FB_LOCATION,\n\t\t\tS_000001_MC_FB_START(rdev->mc.vram_start >> 16) |\n\t\t\tS_000001_MC_FB_TOP(rdev->mc.vram_end >> 16));\n\tWREG32(R_000134_HDP_FB_LOCATION,\n\t\tS_000134_HDP_FB_START(rdev->mc.vram_start >> 16));\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tWREG32_MC(R_000002_MC_AGP_LOCATION,\n\t\t\tS_000002_MC_AGP_START(rdev->mc.gtt_start >> 16) |\n\t\t\tS_000002_MC_AGP_TOP(rdev->mc.gtt_end >> 16));\n\t\tWREG32_MC(R_000003_MC_AGP_BASE, lower_32_bits(rdev->mc.agp_base));\n\t\tWREG32_MC(R_000004_MC_AGP_BASE_2,\n\t\t\tS_000004_AGP_BASE_ADDR_2(upper_32_bits(rdev->mc.agp_base)));\n\t} else {\n\t\tWREG32_MC(R_000002_MC_AGP_LOCATION, 0xFFFFFFFF);\n\t\tWREG32_MC(R_000003_MC_AGP_BASE, 0);\n\t\tWREG32_MC(R_000004_MC_AGP_BASE_2, 0);\n\t}\n\n\trv515_mc_resume(rdev, &save);\n}\n\nvoid rv515_clock_startup(struct radeon_device *rdev)\n{\n\tif (radeon_dynclks != -1 && radeon_dynclks)\n\t\tradeon_atom_set_clock_gating(rdev, 1);\n\t \n\tWREG32_PLL(R_00000F_CP_DYN_CNTL,\n\t\tRREG32_PLL(R_00000F_CP_DYN_CNTL) | S_00000F_CP_FORCEON(1));\n\tWREG32_PLL(R_000011_E2_DYN_CNTL,\n\t\tRREG32_PLL(R_000011_E2_DYN_CNTL) | S_000011_E2_FORCEON(1));\n\tWREG32_PLL(R_000013_IDCT_DYN_CNTL,\n\t\tRREG32_PLL(R_000013_IDCT_DYN_CNTL) | S_000013_IDCT_FORCEON(1));\n}\n\nstatic int rv515_startup(struct radeon_device *rdev)\n{\n\tint r;\n\n\trv515_mc_program(rdev);\n\t \n\trv515_clock_startup(rdev);\n\t \n\trv515_gpu_init(rdev);\n\t \n\tif (rdev->flags & RADEON_IS_PCIE) {\n\t\tr = rv370_pcie_gart_enable(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\trs600_irq_set(rdev);\n\trdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\n\t \n\tr = r100_cp_init(rdev, 1024 * 1024);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint rv515_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\trv370_pcie_gart_disable(rdev);\n\t \n\trv515_clock_startup(rdev);\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev, \"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\t \n\trv515_clock_startup(rdev);\n\t \n\tradeon_surface_init(rdev);\n\n\trdev->accel_working = true;\n\tr =  rv515_startup(rdev);\n\tif (r) {\n\t\trdev->accel_working = false;\n\t}\n\treturn r;\n}\n\nint rv515_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tr100_cp_disable(rdev);\n\tradeon_wb_disable(rdev);\n\trs600_irq_disable(rdev);\n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\trv370_pcie_gart_disable(rdev);\n\treturn 0;\n}\n\nvoid rv515_set_safe_registers(struct radeon_device *rdev)\n{\n\trdev->config.r300.reg_safe_bm = rv515_reg_safe_bm;\n\trdev->config.r300.reg_safe_bm_size = ARRAY_SIZE(rv515_reg_safe_bm);\n}\n\nvoid rv515_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tr100_cp_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_gem_fini(rdev);\n\trv370_pcie_gart_fini(rdev);\n\tradeon_agp_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nint rv515_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tradeon_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\t \n\tr100_restore_sanity(rdev);\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rdev->is_atom_bios) {\n\t\tr = radeon_atombios_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tdev_err(rdev->dev, \"Expecting atombios for RV515 GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev,\n\t\t\t\"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tif (radeon_boot_test_post_card(rdev) == false)\n\t\treturn -EINVAL;\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr = radeon_agp_init(rdev);\n\t\tif (r) {\n\t\t\tradeon_agp_disable(rdev);\n\t\t}\n\t}\n\t \n\trv515_mc_init(rdev);\n\trv515_debugfs(rdev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\tr = rv370_pcie_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trv515_set_safe_registers(rdev);\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rv515_startup(rdev);\n\tif (r) {\n\t\t \n\t\tdev_err(rdev->dev, \"Disabling GPU acceleration\\n\");\n\t\tr100_cp_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\trv370_pcie_gart_fini(rdev);\n\t\tradeon_agp_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\treturn 0;\n}\n\nvoid atom_rv515_force_tv_scaler(struct radeon_device *rdev, struct radeon_crtc *crtc)\n{\n\tint index_reg = 0x6578 + crtc->crtc_offset;\n\tint data_reg = 0x657c + crtc->crtc_offset;\n\n\tWREG32(0x659C + crtc->crtc_offset, 0x0);\n\tWREG32(0x6594 + crtc->crtc_offset, 0x705);\n\tWREG32(0x65A4 + crtc->crtc_offset, 0x10001);\n\tWREG32(0x65D8 + crtc->crtc_offset, 0x0);\n\tWREG32(0x65B0 + crtc->crtc_offset, 0x0);\n\tWREG32(0x65C0 + crtc->crtc_offset, 0x0);\n\tWREG32(0x65D4 + crtc->crtc_offset, 0x0);\n\tWREG32(index_reg, 0x0);\n\tWREG32(data_reg, 0x841880A8);\n\tWREG32(index_reg, 0x1);\n\tWREG32(data_reg, 0x84208680);\n\tWREG32(index_reg, 0x2);\n\tWREG32(data_reg, 0xBFF880B0);\n\tWREG32(index_reg, 0x100);\n\tWREG32(data_reg, 0x83D88088);\n\tWREG32(index_reg, 0x101);\n\tWREG32(data_reg, 0x84608680);\n\tWREG32(index_reg, 0x102);\n\tWREG32(data_reg, 0xBFF080D0);\n\tWREG32(index_reg, 0x200);\n\tWREG32(data_reg, 0x83988068);\n\tWREG32(index_reg, 0x201);\n\tWREG32(data_reg, 0x84A08680);\n\tWREG32(index_reg, 0x202);\n\tWREG32(data_reg, 0xBFF080F8);\n\tWREG32(index_reg, 0x300);\n\tWREG32(data_reg, 0x83588058);\n\tWREG32(index_reg, 0x301);\n\tWREG32(data_reg, 0x84E08660);\n\tWREG32(index_reg, 0x302);\n\tWREG32(data_reg, 0xBFF88120);\n\tWREG32(index_reg, 0x400);\n\tWREG32(data_reg, 0x83188040);\n\tWREG32(index_reg, 0x401);\n\tWREG32(data_reg, 0x85008660);\n\tWREG32(index_reg, 0x402);\n\tWREG32(data_reg, 0xBFF88150);\n\tWREG32(index_reg, 0x500);\n\tWREG32(data_reg, 0x82D88030);\n\tWREG32(index_reg, 0x501);\n\tWREG32(data_reg, 0x85408640);\n\tWREG32(index_reg, 0x502);\n\tWREG32(data_reg, 0xBFF88180);\n\tWREG32(index_reg, 0x600);\n\tWREG32(data_reg, 0x82A08018);\n\tWREG32(index_reg, 0x601);\n\tWREG32(data_reg, 0x85808620);\n\tWREG32(index_reg, 0x602);\n\tWREG32(data_reg, 0xBFF081B8);\n\tWREG32(index_reg, 0x700);\n\tWREG32(data_reg, 0x82608010);\n\tWREG32(index_reg, 0x701);\n\tWREG32(data_reg, 0x85A08600);\n\tWREG32(index_reg, 0x702);\n\tWREG32(data_reg, 0x800081F0);\n\tWREG32(index_reg, 0x800);\n\tWREG32(data_reg, 0x8228BFF8);\n\tWREG32(index_reg, 0x801);\n\tWREG32(data_reg, 0x85E085E0);\n\tWREG32(index_reg, 0x802);\n\tWREG32(data_reg, 0xBFF88228);\n\tWREG32(index_reg, 0x10000);\n\tWREG32(data_reg, 0x82A8BF00);\n\tWREG32(index_reg, 0x10001);\n\tWREG32(data_reg, 0x82A08CC0);\n\tWREG32(index_reg, 0x10002);\n\tWREG32(data_reg, 0x8008BEF8);\n\tWREG32(index_reg, 0x10100);\n\tWREG32(data_reg, 0x81F0BF28);\n\tWREG32(index_reg, 0x10101);\n\tWREG32(data_reg, 0x83608CA0);\n\tWREG32(index_reg, 0x10102);\n\tWREG32(data_reg, 0x8018BED0);\n\tWREG32(index_reg, 0x10200);\n\tWREG32(data_reg, 0x8148BF38);\n\tWREG32(index_reg, 0x10201);\n\tWREG32(data_reg, 0x84408C80);\n\tWREG32(index_reg, 0x10202);\n\tWREG32(data_reg, 0x8008BEB8);\n\tWREG32(index_reg, 0x10300);\n\tWREG32(data_reg, 0x80B0BF78);\n\tWREG32(index_reg, 0x10301);\n\tWREG32(data_reg, 0x85008C20);\n\tWREG32(index_reg, 0x10302);\n\tWREG32(data_reg, 0x8020BEA0);\n\tWREG32(index_reg, 0x10400);\n\tWREG32(data_reg, 0x8028BF90);\n\tWREG32(index_reg, 0x10401);\n\tWREG32(data_reg, 0x85E08BC0);\n\tWREG32(index_reg, 0x10402);\n\tWREG32(data_reg, 0x8018BE90);\n\tWREG32(index_reg, 0x10500);\n\tWREG32(data_reg, 0xBFB8BFB0);\n\tWREG32(index_reg, 0x10501);\n\tWREG32(data_reg, 0x86C08B40);\n\tWREG32(index_reg, 0x10502);\n\tWREG32(data_reg, 0x8010BE90);\n\tWREG32(index_reg, 0x10600);\n\tWREG32(data_reg, 0xBF58BFC8);\n\tWREG32(index_reg, 0x10601);\n\tWREG32(data_reg, 0x87A08AA0);\n\tWREG32(index_reg, 0x10602);\n\tWREG32(data_reg, 0x8010BE98);\n\tWREG32(index_reg, 0x10700);\n\tWREG32(data_reg, 0xBF10BFF0);\n\tWREG32(index_reg, 0x10701);\n\tWREG32(data_reg, 0x886089E0);\n\tWREG32(index_reg, 0x10702);\n\tWREG32(data_reg, 0x8018BEB0);\n\tWREG32(index_reg, 0x10800);\n\tWREG32(data_reg, 0xBED8BFE8);\n\tWREG32(index_reg, 0x10801);\n\tWREG32(data_reg, 0x89408940);\n\tWREG32(index_reg, 0x10802);\n\tWREG32(data_reg, 0xBFE8BED8);\n\tWREG32(index_reg, 0x20000);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x20001);\n\tWREG32(data_reg, 0x90008000);\n\tWREG32(index_reg, 0x20002);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x20003);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x20100);\n\tWREG32(data_reg, 0x80108000);\n\tWREG32(index_reg, 0x20101);\n\tWREG32(data_reg, 0x8FE0BF70);\n\tWREG32(index_reg, 0x20102);\n\tWREG32(data_reg, 0xBFE880C0);\n\tWREG32(index_reg, 0x20103);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x20200);\n\tWREG32(data_reg, 0x8018BFF8);\n\tWREG32(index_reg, 0x20201);\n\tWREG32(data_reg, 0x8F80BF08);\n\tWREG32(index_reg, 0x20202);\n\tWREG32(data_reg, 0xBFD081A0);\n\tWREG32(index_reg, 0x20203);\n\tWREG32(data_reg, 0xBFF88000);\n\tWREG32(index_reg, 0x20300);\n\tWREG32(data_reg, 0x80188000);\n\tWREG32(index_reg, 0x20301);\n\tWREG32(data_reg, 0x8EE0BEC0);\n\tWREG32(index_reg, 0x20302);\n\tWREG32(data_reg, 0xBFB082A0);\n\tWREG32(index_reg, 0x20303);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x20400);\n\tWREG32(data_reg, 0x80188000);\n\tWREG32(index_reg, 0x20401);\n\tWREG32(data_reg, 0x8E00BEA0);\n\tWREG32(index_reg, 0x20402);\n\tWREG32(data_reg, 0xBF8883C0);\n\tWREG32(index_reg, 0x20403);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x20500);\n\tWREG32(data_reg, 0x80188000);\n\tWREG32(index_reg, 0x20501);\n\tWREG32(data_reg, 0x8D00BE90);\n\tWREG32(index_reg, 0x20502);\n\tWREG32(data_reg, 0xBF588500);\n\tWREG32(index_reg, 0x20503);\n\tWREG32(data_reg, 0x80008008);\n\tWREG32(index_reg, 0x20600);\n\tWREG32(data_reg, 0x80188000);\n\tWREG32(index_reg, 0x20601);\n\tWREG32(data_reg, 0x8BC0BE98);\n\tWREG32(index_reg, 0x20602);\n\tWREG32(data_reg, 0xBF308660);\n\tWREG32(index_reg, 0x20603);\n\tWREG32(data_reg, 0x80008008);\n\tWREG32(index_reg, 0x20700);\n\tWREG32(data_reg, 0x80108000);\n\tWREG32(index_reg, 0x20701);\n\tWREG32(data_reg, 0x8A80BEB0);\n\tWREG32(index_reg, 0x20702);\n\tWREG32(data_reg, 0xBF0087C0);\n\tWREG32(index_reg, 0x20703);\n\tWREG32(data_reg, 0x80008008);\n\tWREG32(index_reg, 0x20800);\n\tWREG32(data_reg, 0x80108000);\n\tWREG32(index_reg, 0x20801);\n\tWREG32(data_reg, 0x8920BED0);\n\tWREG32(index_reg, 0x20802);\n\tWREG32(data_reg, 0xBED08920);\n\tWREG32(index_reg, 0x20803);\n\tWREG32(data_reg, 0x80008010);\n\tWREG32(index_reg, 0x30000);\n\tWREG32(data_reg, 0x90008000);\n\tWREG32(index_reg, 0x30001);\n\tWREG32(data_reg, 0x80008000);\n\tWREG32(index_reg, 0x30100);\n\tWREG32(data_reg, 0x8FE0BF90);\n\tWREG32(index_reg, 0x30101);\n\tWREG32(data_reg, 0xBFF880A0);\n\tWREG32(index_reg, 0x30200);\n\tWREG32(data_reg, 0x8F60BF40);\n\tWREG32(index_reg, 0x30201);\n\tWREG32(data_reg, 0xBFE88180);\n\tWREG32(index_reg, 0x30300);\n\tWREG32(data_reg, 0x8EC0BF00);\n\tWREG32(index_reg, 0x30301);\n\tWREG32(data_reg, 0xBFC88280);\n\tWREG32(index_reg, 0x30400);\n\tWREG32(data_reg, 0x8DE0BEE0);\n\tWREG32(index_reg, 0x30401);\n\tWREG32(data_reg, 0xBFA083A0);\n\tWREG32(index_reg, 0x30500);\n\tWREG32(data_reg, 0x8CE0BED0);\n\tWREG32(index_reg, 0x30501);\n\tWREG32(data_reg, 0xBF7884E0);\n\tWREG32(index_reg, 0x30600);\n\tWREG32(data_reg, 0x8BA0BED8);\n\tWREG32(index_reg, 0x30601);\n\tWREG32(data_reg, 0xBF508640);\n\tWREG32(index_reg, 0x30700);\n\tWREG32(data_reg, 0x8A60BEE8);\n\tWREG32(index_reg, 0x30701);\n\tWREG32(data_reg, 0xBF2087A0);\n\tWREG32(index_reg, 0x30800);\n\tWREG32(data_reg, 0x8900BF00);\n\tWREG32(index_reg, 0x30801);\n\tWREG32(data_reg, 0xBF008900);\n}\n\nstruct rv515_watermark {\n\tu32        lb_request_fifo_depth;\n\tfixed20_12 num_line_pair;\n\tfixed20_12 estimated_width;\n\tfixed20_12 worst_case_latency;\n\tfixed20_12 consumption_rate;\n\tfixed20_12 active_time;\n\tfixed20_12 dbpp;\n\tfixed20_12 priority_mark_max;\n\tfixed20_12 priority_mark;\n\tfixed20_12 sclk;\n};\n\nstatic void rv515_crtc_bandwidth_compute(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_crtc *crtc,\n\t\t\t\t\t struct rv515_watermark *wm,\n\t\t\t\t\t bool low)\n{\n\tstruct drm_display_mode *mode = &crtc->base.mode;\n\tfixed20_12 a, b, c;\n\tfixed20_12 pclk, request_fifo_depth, tolerable_latency, estimated_width;\n\tfixed20_12 consumption_time, line_time, chunk_time, read_delay_latency;\n\tfixed20_12 sclk;\n\tu32 selected_sclk;\n\n\tif (!crtc->base.enabled) {\n\t\t \n\t\twm->lb_request_fifo_depth = 4;\n\t\treturn;\n\t}\n\n\t \n\tif ((rdev->family >= CHIP_RV610) &&\n\t    (rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled)\n\t\tselected_sclk = radeon_dpm_get_sclk(rdev, low);\n\telse\n\t\tselected_sclk = rdev->pm.current_sclk;\n\n\t \n\ta.full = dfixed_const(100);\n\tsclk.full = dfixed_const(selected_sclk);\n\tsclk.full = dfixed_div(sclk, a);\n\n\tif (crtc->vsc.full > dfixed_const(2))\n\t\twm->num_line_pair.full = dfixed_const(2);\n\telse\n\t\twm->num_line_pair.full = dfixed_const(1);\n\n\tb.full = dfixed_const(mode->crtc_hdisplay);\n\tc.full = dfixed_const(256);\n\ta.full = dfixed_div(b, c);\n\trequest_fifo_depth.full = dfixed_mul(a, wm->num_line_pair);\n\trequest_fifo_depth.full = dfixed_ceil(request_fifo_depth);\n\tif (a.full < dfixed_const(4)) {\n\t\twm->lb_request_fifo_depth = 4;\n\t} else {\n\t\twm->lb_request_fifo_depth = dfixed_trunc(request_fifo_depth);\n\t}\n\n\t \n\ta.full = dfixed_const(mode->clock);\n\tb.full = dfixed_const(1000);\n\ta.full = dfixed_div(a, b);\n\tpclk.full = dfixed_div(b, a);\n\tif (crtc->rmx_type != RMX_OFF) {\n\t\tb.full = dfixed_const(2);\n\t\tif (crtc->vsc.full > b.full)\n\t\t\tb.full = crtc->vsc.full;\n\t\tb.full = dfixed_mul(b, crtc->hsc);\n\t\tc.full = dfixed_const(2);\n\t\tb.full = dfixed_div(b, c);\n\t\tconsumption_time.full = dfixed_div(pclk, b);\n\t} else {\n\t\tconsumption_time.full = pclk.full;\n\t}\n\ta.full = dfixed_const(1);\n\twm->consumption_rate.full = dfixed_div(a, consumption_time);\n\n\n\t \n\ta.full = dfixed_const(crtc->base.mode.crtc_htotal);\n\tline_time.full = dfixed_mul(a, pclk);\n\n\t \n\ta.full = dfixed_const(crtc->base.mode.crtc_htotal);\n\tb.full = dfixed_const(crtc->base.mode.crtc_hdisplay);\n\twm->active_time.full = dfixed_mul(line_time, b);\n\twm->active_time.full = dfixed_div(wm->active_time, a);\n\n\t \n\ta.full = dfixed_const(600 * 1000);\n\tchunk_time.full = dfixed_div(a, sclk);\n\tread_delay_latency.full = dfixed_const(1000);\n\n\t \n\tif (dfixed_trunc(wm->num_line_pair) > 1) {\n\t\ta.full = dfixed_const(3);\n\t\twm->worst_case_latency.full = dfixed_mul(a, chunk_time);\n\t\twm->worst_case_latency.full += read_delay_latency.full;\n\t} else {\n\t\twm->worst_case_latency.full = chunk_time.full + read_delay_latency.full;\n\t}\n\n\t \n\tif ((2+wm->lb_request_fifo_depth) >= dfixed_trunc(request_fifo_depth)) {\n\t\ttolerable_latency.full = line_time.full;\n\t} else {\n\t\ttolerable_latency.full = dfixed_const(wm->lb_request_fifo_depth - 2);\n\t\ttolerable_latency.full = request_fifo_depth.full - tolerable_latency.full;\n\t\ttolerable_latency.full = dfixed_mul(tolerable_latency, chunk_time);\n\t\ttolerable_latency.full = line_time.full - tolerable_latency.full;\n\t}\n\t \n\twm->dbpp.full = dfixed_const(2 * 16);\n\n\t \n\ta.full = dfixed_const(16);\n\twm->priority_mark_max.full = dfixed_const(crtc->base.mode.crtc_hdisplay);\n\twm->priority_mark_max.full = dfixed_div(wm->priority_mark_max, a);\n\twm->priority_mark_max.full = dfixed_ceil(wm->priority_mark_max);\n\n\t \n\testimated_width.full = tolerable_latency.full - wm->worst_case_latency.full;\n\testimated_width.full = dfixed_div(estimated_width, consumption_time);\n\tif (dfixed_trunc(estimated_width) > crtc->base.mode.crtc_hdisplay) {\n\t\twm->priority_mark.full = wm->priority_mark_max.full;\n\t} else {\n\t\ta.full = dfixed_const(16);\n\t\twm->priority_mark.full = dfixed_div(estimated_width, a);\n\t\twm->priority_mark.full = dfixed_ceil(wm->priority_mark);\n\t\twm->priority_mark.full = wm->priority_mark_max.full - wm->priority_mark.full;\n\t}\n}\n\nstatic void rv515_compute_mode_priority(struct radeon_device *rdev,\n\t\t\t\t\tstruct rv515_watermark *wm0,\n\t\t\t\t\tstruct rv515_watermark *wm1,\n\t\t\t\t\tstruct drm_display_mode *mode0,\n\t\t\t\t\tstruct drm_display_mode *mode1,\n\t\t\t\t\tu32 *d1mode_priority_a_cnt,\n\t\t\t\t\tu32 *d2mode_priority_a_cnt)\n{\n\tfixed20_12 priority_mark02, priority_mark12, fill_rate;\n\tfixed20_12 a, b;\n\n\t*d1mode_priority_a_cnt = MODE_PRIORITY_OFF;\n\t*d2mode_priority_a_cnt = MODE_PRIORITY_OFF;\n\n\tif (mode0 && mode1) {\n\t\tif (dfixed_trunc(wm0->dbpp) > 64)\n\t\t\ta.full = dfixed_div(wm0->dbpp, wm0->num_line_pair);\n\t\telse\n\t\t\ta.full = wm0->num_line_pair.full;\n\t\tif (dfixed_trunc(wm1->dbpp) > 64)\n\t\t\tb.full = dfixed_div(wm1->dbpp, wm1->num_line_pair);\n\t\telse\n\t\t\tb.full = wm1->num_line_pair.full;\n\t\ta.full += b.full;\n\t\tfill_rate.full = dfixed_div(wm0->sclk, a);\n\t\tif (wm0->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm0->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm0->active_time);\n\t\t\ta.full = dfixed_const(16);\n\t\t\tb.full = dfixed_div(b, a);\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\tpriority_mark02.full = a.full + b.full;\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark02.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm1->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm1->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm1->active_time);\n\t\t\ta.full = dfixed_const(16);\n\t\t\tb.full = dfixed_div(b, a);\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\tpriority_mark12.full = a.full + b.full;\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark12.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm0->priority_mark.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark.full;\n\t\tif (wm0->priority_mark_max.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark_max.full;\n\t\tif (wm1->priority_mark.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark.full;\n\t\tif (wm1->priority_mark_max.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark_max.full;\n\t\t*d1mode_priority_a_cnt = dfixed_trunc(priority_mark02);\n\t\t*d2mode_priority_a_cnt = dfixed_trunc(priority_mark12);\n\t\tif (rdev->disp_priority == 2) {\n\t\t\t*d1mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\n\t\t\t*d2mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\n\t\t}\n\t} else if (mode0) {\n\t\tif (dfixed_trunc(wm0->dbpp) > 64)\n\t\t\ta.full = dfixed_div(wm0->dbpp, wm0->num_line_pair);\n\t\telse\n\t\t\ta.full = wm0->num_line_pair.full;\n\t\tfill_rate.full = dfixed_div(wm0->sclk, a);\n\t\tif (wm0->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm0->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm0->active_time);\n\t\t\ta.full = dfixed_const(16);\n\t\t\tb.full = dfixed_div(b, a);\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\tpriority_mark02.full = a.full + b.full;\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\tb.full = dfixed_const(16);\n\t\t\tpriority_mark02.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm0->priority_mark.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark.full;\n\t\tif (wm0->priority_mark_max.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark_max.full;\n\t\t*d1mode_priority_a_cnt = dfixed_trunc(priority_mark02);\n\t\tif (rdev->disp_priority == 2)\n\t\t\t*d1mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\n\t} else if (mode1) {\n\t\tif (dfixed_trunc(wm1->dbpp) > 64)\n\t\t\ta.full = dfixed_div(wm1->dbpp, wm1->num_line_pair);\n\t\telse\n\t\t\ta.full = wm1->num_line_pair.full;\n\t\tfill_rate.full = dfixed_div(wm1->sclk, a);\n\t\tif (wm1->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm1->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm1->active_time);\n\t\t\ta.full = dfixed_const(16);\n\t\t\tb.full = dfixed_div(b, a);\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\tpriority_mark12.full = a.full + b.full;\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark12.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm1->priority_mark.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark.full;\n\t\tif (wm1->priority_mark_max.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark_max.full;\n\t\t*d2mode_priority_a_cnt = dfixed_trunc(priority_mark12);\n\t\tif (rdev->disp_priority == 2)\n\t\t\t*d2mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\n\t}\n}\n\nvoid rv515_bandwidth_avivo_update(struct radeon_device *rdev)\n{\n\tstruct drm_display_mode *mode0 = NULL;\n\tstruct drm_display_mode *mode1 = NULL;\n\tstruct rv515_watermark wm0_high, wm0_low;\n\tstruct rv515_watermark wm1_high, wm1_low;\n\tu32 tmp;\n\tu32 d1mode_priority_a_cnt, d1mode_priority_b_cnt;\n\tu32 d2mode_priority_a_cnt, d2mode_priority_b_cnt;\n\n\tif (rdev->mode_info.crtcs[0]->base.enabled)\n\t\tmode0 = &rdev->mode_info.crtcs[0]->base.mode;\n\tif (rdev->mode_info.crtcs[1]->base.enabled)\n\t\tmode1 = &rdev->mode_info.crtcs[1]->base.mode;\n\trs690_line_buffer_adjust(rdev, mode0, mode1);\n\n\trv515_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[0], &wm0_high, false);\n\trv515_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[1], &wm1_high, false);\n\n\trv515_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[0], &wm0_low, false);\n\trv515_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[1], &wm1_low, false);\n\n\ttmp = wm0_high.lb_request_fifo_depth;\n\ttmp |= wm1_high.lb_request_fifo_depth << 16;\n\tWREG32(LB_MAX_REQ_OUTSTANDING, tmp);\n\n\trv515_compute_mode_priority(rdev,\n\t\t\t\t    &wm0_high, &wm1_high,\n\t\t\t\t    mode0, mode1,\n\t\t\t\t    &d1mode_priority_a_cnt, &d2mode_priority_a_cnt);\n\trv515_compute_mode_priority(rdev,\n\t\t\t\t    &wm0_low, &wm1_low,\n\t\t\t\t    mode0, mode1,\n\t\t\t\t    &d1mode_priority_b_cnt, &d2mode_priority_b_cnt);\n\n\tWREG32(D1MODE_PRIORITY_A_CNT, d1mode_priority_a_cnt);\n\tWREG32(D1MODE_PRIORITY_B_CNT, d1mode_priority_b_cnt);\n\tWREG32(D2MODE_PRIORITY_A_CNT, d2mode_priority_a_cnt);\n\tWREG32(D2MODE_PRIORITY_B_CNT, d2mode_priority_b_cnt);\n}\n\nvoid rv515_bandwidth_update(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\tstruct drm_display_mode *mode0 = NULL;\n\tstruct drm_display_mode *mode1 = NULL;\n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tif (rdev->mode_info.crtcs[0]->base.enabled)\n\t\tmode0 = &rdev->mode_info.crtcs[0]->base.mode;\n\tif (rdev->mode_info.crtcs[1]->base.enabled)\n\t\tmode1 = &rdev->mode_info.crtcs[1]->base.mode;\n\t \n\tif ((rdev->disp_priority == 2) &&\n\t    (rdev->family == CHIP_RV515)) {\n\t\ttmp = RREG32_MC(MC_MISC_LAT_TIMER);\n\t\ttmp &= ~MC_DISP1R_INIT_LAT_MASK;\n\t\ttmp &= ~MC_DISP0R_INIT_LAT_MASK;\n\t\tif (mode1)\n\t\t\ttmp |= (1 << MC_DISP1R_INIT_LAT_SHIFT);\n\t\tif (mode0)\n\t\t\ttmp |= (1 << MC_DISP0R_INIT_LAT_SHIFT);\n\t\tWREG32_MC(MC_MISC_LAT_TIMER, tmp);\n\t}\n\trv515_bandwidth_avivo_update(rdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}