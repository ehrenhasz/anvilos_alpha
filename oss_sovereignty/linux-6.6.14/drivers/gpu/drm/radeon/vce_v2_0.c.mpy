{
  "module_name": "vce_v2_0.c",
  "hash_id": "8816e3c507087134e50b8747322805adf3a66e8683363d2a6642ee6433b4ac63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/vce_v2_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"cikd.h\"\n#include \"vce.h\"\n\n#define VCE_V2_0_FW_SIZE\t(256 * 1024)\n#define VCE_V2_0_STACK_SIZE\t(64 * 1024)\n#define VCE_V2_0_DATA_SIZE\t(23552 * RADEON_MAX_VCE_HANDLES)\n\nstatic void vce_v2_0_set_sw_cg(struct radeon_device *rdev, bool gated)\n{\n\tu32 tmp;\n\n\tif (gated) {\n\t\ttmp = RREG32(VCE_CLOCK_GATING_B);\n\t\ttmp |= 0xe70000;\n\t\tWREG32(VCE_CLOCK_GATING_B, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_CLOCK_GATING);\n\t\ttmp |= 0xff000000;\n\t\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\n\t\ttmp &= ~0x3fc;\n\t\tWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\n\n\t\tWREG32(VCE_CGTT_CLK_OVERRIDE, 0);\n\t} else {\n\t\ttmp = RREG32(VCE_CLOCK_GATING_B);\n\t\ttmp |= 0xe7;\n\t\ttmp &= ~0xe70000;\n\t\tWREG32(VCE_CLOCK_GATING_B, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_CLOCK_GATING);\n\t\ttmp |= 0x1fe000;\n\t\ttmp &= ~0xff000000;\n\t\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\n\t\ttmp |= 0x3fc;\n\t\tWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\n\t}\n}\n\nstatic void vce_v2_0_set_dyn_cg(struct radeon_device *rdev, bool gated)\n{\n\tu32 orig, tmp;\n\n\ttmp = RREG32(VCE_CLOCK_GATING_B);\n\ttmp &= ~0x00060006;\n\tif (gated) {\n\t\ttmp |= 0xe10000;\n\t} else {\n\t\ttmp |= 0xe1;\n\t\ttmp &= ~0xe10000;\n\t}\n\tWREG32(VCE_CLOCK_GATING_B, tmp);\n\n\torig = tmp = RREG32(VCE_UENC_CLOCK_GATING);\n\ttmp &= ~0x1fe000;\n\ttmp &= ~0xff000000;\n\tif (tmp != orig)\n\t\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\torig = tmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\n\ttmp &= ~0x3fc;\n\tif (tmp != orig)\n\t\tWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\n\n\tif (gated)\n\t\tWREG32(VCE_CGTT_CLK_OVERRIDE, 0);\n}\n\nstatic void vce_v2_0_disable_cg(struct radeon_device *rdev)\n{\n\tWREG32(VCE_CGTT_CLK_OVERRIDE, 7);\n}\n\n \nvoid vce_v2_0_enable_mgcg(struct radeon_device *rdev, bool enable)\n{\n\tbool sw_cg = false;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_VCE_MGCG)) {\n\t\tif (sw_cg)\n\t\t\tvce_v2_0_set_sw_cg(rdev, true);\n\t\telse\n\t\t\tvce_v2_0_set_dyn_cg(rdev, true);\n\t} else {\n\t\tvce_v2_0_disable_cg(rdev);\n\n\t\tif (sw_cg)\n\t\t\tvce_v2_0_set_sw_cg(rdev, false);\n\t\telse\n\t\t\tvce_v2_0_set_dyn_cg(rdev, false);\n\t}\n}\n\nstatic void vce_v2_0_init_cg(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(VCE_CLOCK_GATING_A);\n\ttmp &= ~(CGC_CLK_GATE_DLY_TIMER_MASK | CGC_CLK_GATER_OFF_DLY_TIMER_MASK);\n\ttmp |= (CGC_CLK_GATE_DLY_TIMER(0) | CGC_CLK_GATER_OFF_DLY_TIMER(4));\n\ttmp |= CGC_UENC_WAIT_AWAKE;\n\tWREG32(VCE_CLOCK_GATING_A, tmp);\n\n\ttmp = RREG32(VCE_UENC_CLOCK_GATING);\n\ttmp &= ~(CLOCK_ON_DELAY_MASK | CLOCK_OFF_DELAY_MASK);\n\ttmp |= (CLOCK_ON_DELAY(0) | CLOCK_OFF_DELAY(4));\n\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\ttmp = RREG32(VCE_CLOCK_GATING_B);\n\ttmp |= 0x10;\n\ttmp &= ~0x100000;\n\tWREG32(VCE_CLOCK_GATING_B, tmp);\n}\n\nunsigned vce_v2_0_bo_size(struct radeon_device *rdev)\n{\n\tWARN_ON(rdev->vce_fw->size > VCE_V2_0_FW_SIZE);\n\treturn VCE_V2_0_FW_SIZE + VCE_V2_0_STACK_SIZE + VCE_V2_0_DATA_SIZE;\n}\n\nint vce_v2_0_resume(struct radeon_device *rdev)\n{\n\tuint64_t addr = rdev->vce.gpu_addr;\n\tuint32_t size;\n\n\tWREG32_P(VCE_CLOCK_GATING_A, 0, ~(1 << 16));\n\tWREG32_P(VCE_UENC_CLOCK_GATING, 0x1FF000, ~0xFF9FF000);\n\tWREG32_P(VCE_UENC_REG_CLOCK_GATING, 0x3F, ~0x3F);\n\tWREG32(VCE_CLOCK_GATING_B, 0xf7);\n\n\tWREG32(VCE_LMI_CTRL, 0x00398000);\n\tWREG32_P(VCE_LMI_CACHE_CTRL, 0x0, ~0x1);\n\tWREG32(VCE_LMI_SWAP_CNTL, 0);\n\tWREG32(VCE_LMI_SWAP_CNTL1, 0);\n\tWREG32(VCE_LMI_VM_CTRL, 0);\n\n\tWREG32(VCE_LMI_VCPU_CACHE_40BIT_BAR, addr >> 8);\n\n\taddr &= 0xff;\n\tsize = VCE_V2_0_FW_SIZE;\n\tWREG32(VCE_VCPU_CACHE_OFFSET0, addr & 0x7fffffff);\n\tWREG32(VCE_VCPU_CACHE_SIZE0, size);\n\n\taddr += size;\n\tsize = VCE_V2_0_STACK_SIZE;\n\tWREG32(VCE_VCPU_CACHE_OFFSET1, addr & 0x7fffffff);\n\tWREG32(VCE_VCPU_CACHE_SIZE1, size);\n\n\taddr += size;\n\tsize = VCE_V2_0_DATA_SIZE;\n\tWREG32(VCE_VCPU_CACHE_OFFSET2, addr & 0x7fffffff);\n\tWREG32(VCE_VCPU_CACHE_SIZE2, size);\n\n\tWREG32_P(VCE_LMI_CTRL2, 0x0, ~0x100);\n\n\tWREG32_P(VCE_SYS_INT_EN, VCE_SYS_INT_TRAP_INTERRUPT_EN,\n\t\t ~VCE_SYS_INT_TRAP_INTERRUPT_EN);\n\n\tvce_v2_0_init_cg(rdev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}