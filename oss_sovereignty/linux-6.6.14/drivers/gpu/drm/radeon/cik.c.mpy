{
  "module_name": "cik.c",
  "hash_id": "458dde1c8cb1c2a0da9b8f6268560ec0861e95f2717f2ea3996ee0da60473ff0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/cik.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <drm/drm_vblank.h>\n\n#include \"atom.h\"\n#include \"evergreen.h\"\n#include \"cik_blit_shaders.h\"\n#include \"cik.h\"\n#include \"cikd.h\"\n#include \"clearstate_ci.h\"\n#include \"r600.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"radeon_ucode.h\"\n#include \"si.h\"\n#include \"vce.h\"\n\n#define SH_MEM_CONFIG_GFX_DEFAULT \\\n\tALIGNMENT_MODE(SH_MEM_ALIGNMENT_MODE_UNALIGNED)\n\nMODULE_FIRMWARE(\"radeon/BONAIRE_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_me.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_ce.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_mec.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_mc.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_sdma.bin\");\nMODULE_FIRMWARE(\"radeon/BONAIRE_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/bonaire_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_me.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_ce.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_mec.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_mc.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_sdma.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_smc.bin\");\nMODULE_FIRMWARE(\"radeon/bonaire_k_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/HAWAII_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_me.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_ce.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_mec.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_mc.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_mc2.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_sdma.bin\");\nMODULE_FIRMWARE(\"radeon/HAWAII_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/hawaii_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_me.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_ce.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_mec.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_mc.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_sdma.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_smc.bin\");\nMODULE_FIRMWARE(\"radeon/hawaii_k_smc.bin\");\n\nMODULE_FIRMWARE(\"radeon/KAVERI_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/KAVERI_me.bin\");\nMODULE_FIRMWARE(\"radeon/KAVERI_ce.bin\");\nMODULE_FIRMWARE(\"radeon/KAVERI_mec.bin\");\nMODULE_FIRMWARE(\"radeon/KAVERI_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/KAVERI_sdma.bin\");\n\nMODULE_FIRMWARE(\"radeon/kaveri_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/kaveri_me.bin\");\nMODULE_FIRMWARE(\"radeon/kaveri_ce.bin\");\nMODULE_FIRMWARE(\"radeon/kaveri_mec.bin\");\nMODULE_FIRMWARE(\"radeon/kaveri_mec2.bin\");\nMODULE_FIRMWARE(\"radeon/kaveri_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/kaveri_sdma.bin\");\n\nMODULE_FIRMWARE(\"radeon/KABINI_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/KABINI_me.bin\");\nMODULE_FIRMWARE(\"radeon/KABINI_ce.bin\");\nMODULE_FIRMWARE(\"radeon/KABINI_mec.bin\");\nMODULE_FIRMWARE(\"radeon/KABINI_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/KABINI_sdma.bin\");\n\nMODULE_FIRMWARE(\"radeon/kabini_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/kabini_me.bin\");\nMODULE_FIRMWARE(\"radeon/kabini_ce.bin\");\nMODULE_FIRMWARE(\"radeon/kabini_mec.bin\");\nMODULE_FIRMWARE(\"radeon/kabini_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/kabini_sdma.bin\");\n\nMODULE_FIRMWARE(\"radeon/MULLINS_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/MULLINS_me.bin\");\nMODULE_FIRMWARE(\"radeon/MULLINS_ce.bin\");\nMODULE_FIRMWARE(\"radeon/MULLINS_mec.bin\");\nMODULE_FIRMWARE(\"radeon/MULLINS_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/MULLINS_sdma.bin\");\n\nMODULE_FIRMWARE(\"radeon/mullins_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/mullins_me.bin\");\nMODULE_FIRMWARE(\"radeon/mullins_ce.bin\");\nMODULE_FIRMWARE(\"radeon/mullins_mec.bin\");\nMODULE_FIRMWARE(\"radeon/mullins_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/mullins_sdma.bin\");\n\nstatic u32 cik_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh);\nstatic void cik_rlc_stop(struct radeon_device *rdev);\nstatic void cik_pcie_gen3_enable(struct radeon_device *rdev);\nstatic void cik_program_aspm(struct radeon_device *rdev);\nstatic void cik_init_pg(struct radeon_device *rdev);\nstatic void cik_init_cg(struct radeon_device *rdev);\nstatic void cik_fini_pg(struct radeon_device *rdev);\nstatic void cik_fini_cg(struct radeon_device *rdev);\nstatic void cik_enable_gui_idle_interrupt(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable);\n\n \nint cik_get_allowed_info_register(struct radeon_device *rdev,\n\t\t\t\t  u32 reg, u32 *val)\n{\n\tswitch (reg) {\n\tcase GRBM_STATUS:\n\tcase GRBM_STATUS2:\n\tcase GRBM_STATUS_SE0:\n\tcase GRBM_STATUS_SE1:\n\tcase GRBM_STATUS_SE2:\n\tcase GRBM_STATUS_SE3:\n\tcase SRBM_STATUS:\n\tcase SRBM_STATUS2:\n\tcase (SDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET):\n\tcase (SDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET):\n\tcase UVD_STATUS:\n\t \n\t\t*val = RREG32(reg);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nu32 cik_didt_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->didt_idx_lock, flags);\n\tWREG32(CIK_DIDT_IND_INDEX, (reg));\n\tr = RREG32(CIK_DIDT_IND_DATA);\n\tspin_unlock_irqrestore(&rdev->didt_idx_lock, flags);\n\treturn r;\n}\n\nvoid cik_didt_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->didt_idx_lock, flags);\n\tWREG32(CIK_DIDT_IND_INDEX, (reg));\n\tWREG32(CIK_DIDT_IND_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->didt_idx_lock, flags);\n}\n\n \nint ci_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp;\n\tint actual_temp = 0;\n\n\ttemp = (RREG32_SMC(CG_MULT_THERMAL_STATUS) & CTF_TEMP_MASK) >>\n\t\tCTF_TEMP_SHIFT;\n\n\tif (temp & 0x200)\n\t\tactual_temp = 255;\n\telse\n\t\tactual_temp = temp & 0x1ff;\n\n\treturn actual_temp * 1000;\n}\n\n \nint kv_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp;\n\tint actual_temp = 0;\n\n\ttemp = RREG32_SMC(0xC0300E0C);\n\n\tif (temp)\n\t\tactual_temp = (temp / 8) - 49;\n\telse\n\t\tactual_temp = 0;\n\n\treturn actual_temp * 1000;\n}\n\n \nu32 cik_pciep_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->pciep_idx_lock, flags);\n\tWREG32(PCIE_INDEX, reg);\n\t(void)RREG32(PCIE_INDEX);\n\tr = RREG32(PCIE_DATA);\n\tspin_unlock_irqrestore(&rdev->pciep_idx_lock, flags);\n\treturn r;\n}\n\nvoid cik_pciep_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->pciep_idx_lock, flags);\n\tWREG32(PCIE_INDEX, reg);\n\t(void)RREG32(PCIE_INDEX);\n\tWREG32(PCIE_DATA, v);\n\t(void)RREG32(PCIE_DATA);\n\tspin_unlock_irqrestore(&rdev->pciep_idx_lock, flags);\n}\n\nstatic const u32 spectre_rlc_save_restore_register_list[] =\n{\n\t(0x0e00 << 16) | (0xc12c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc140 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc150 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc15c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc168 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc170 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc178 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc204 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8228 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x829c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x869c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x98f4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x98f8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc260 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x90e8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c000 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c00c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c1c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8900 >> 2),\n\t0x00000000,\n\t0x3,\n\t(0x0e00 << 16) | (0xc130 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc134 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc1fc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc208 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc264 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc268 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc26c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc270 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc274 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc278 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc27c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc280 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc284 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc288 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc28c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc290 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc294 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc298 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc29c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2ac  >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x301d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30238 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30250 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30254 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30258 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3025c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc99c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9834 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f00 >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f00 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f04 >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f04 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f08 >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f08 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f0c >> 2),\n\t0x00000000,\n\t(0x0001 << 16) | (0x30f0c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x9b7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bf0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bcc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8b24 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30a04 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a10 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a14 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a2c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc704 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc708 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc768 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc770 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc774 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc778 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc77c >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc780 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc784 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc788 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc78c >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc798 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc79c >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7a0 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7a4 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7a8 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7ac >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7b0 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc7b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9100 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c010 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92a8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92ac >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92c4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92c8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92cc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x92d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c04 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c38 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c3c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xae00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9604 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac08 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac0c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac58 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac68 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac6c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac70 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac74 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac78 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac80 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac84 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac88 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac8c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x970c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9714 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9718 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x971c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x8e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x9e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0xae00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0xbe00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88bc >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0x89c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8980 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30938 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3093c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30940 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30904 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c210 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c214 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c218 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8904 >> 2),\n\t0x00000000,\n\t0x5,\n\t(0x0e00 << 16) | (0x8c28 >> 2),\n\t(0x0e00 << 16) | (0x8c2c >> 2),\n\t(0x0e00 << 16) | (0x8c30 >> 2),\n\t(0x0e00 << 16) | (0x8c34 >> 2),\n\t(0x0e00 << 16) | (0x9600 >> 2),\n};\n\nstatic const u32 kalindi_rlc_save_restore_register_list[] =\n{\n\t(0x0e00 << 16) | (0xc12c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc140 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc150 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc15c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc168 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc170 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc204 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8228 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x829c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x869c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x98f4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x98f8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc260 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x90e8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c000 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c00c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c1c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xcd20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89bc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8900 >> 2),\n\t0x00000000,\n\t0x3,\n\t(0x0e00 << 16) | (0xc130 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc134 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc1fc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc208 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc264 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc268 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc26c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc270 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc274 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc28c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc290 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc294 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc298 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2a8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc2ac >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x301d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30238 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30250 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30254 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30258 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3025c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc900 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc904 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc908 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc90c >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0xc910 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc99c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9834 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f00 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f04 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f08 >> 2),\n\t0x00000000,\n\t(0x0000 << 16) | (0x30f0c >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x9b7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bf0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8bcc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8b24 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30a04 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a10 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a14 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a18 >> 2),\n\t0x00000000,\n\t(0x0600 << 16) | (0x30a2c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc700 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc704 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc708 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xc768 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc770 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc774 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc798 >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0xc79c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9100 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c010 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c04 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c20 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c38 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8c3c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xae00 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9604 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac08 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac0c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac58 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac68 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac6c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac70 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac74 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac78 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac7c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac80 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac84 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac88 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xac8c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x970c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9714 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x9718 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x971c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x4e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x5e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x6e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x7e00 << 16) | (0x31068 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd10 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0xcd14 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88b8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88bc >> 2),\n\t0x00000000,\n\t(0x0400 << 16) | (0x89c0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88c8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x88d8 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8980 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30938 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3093c >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30940 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89a0 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30900 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x30904 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x89b4 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3e1fc >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c210 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c214 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x3c218 >> 2),\n\t0x00000000,\n\t(0x0e00 << 16) | (0x8904 >> 2),\n\t0x00000000,\n\t0x5,\n\t(0x0e00 << 16) | (0x8c28 >> 2),\n\t(0x0e00 << 16) | (0x8c2c >> 2),\n\t(0x0e00 << 16) | (0x8c30 >> 2),\n\t(0x0e00 << 16) | (0x8c34 >> 2),\n\t(0x0e00 << 16) | (0x9600 >> 2),\n};\n\nstatic const u32 bonaire_golden_spm_registers[] =\n{\n\t0x30800, 0xe0ffffff, 0xe0000000\n};\n\nstatic const u32 bonaire_golden_common_registers[] =\n{\n\t0xc770, 0xffffffff, 0x00000800,\n\t0xc774, 0xffffffff, 0x00000800,\n\t0xc798, 0xffffffff, 0x00007fbf,\n\t0xc79c, 0xffffffff, 0x00007faf\n};\n\nstatic const u32 bonaire_golden_registers[] =\n{\n\t0x3354, 0x00000333, 0x00000333,\n\t0x3350, 0x000c0fc0, 0x00040200,\n\t0x9a10, 0x00010000, 0x00058208,\n\t0x3c000, 0xffff1fff, 0x00140000,\n\t0x3c200, 0xfdfc0fff, 0x00000100,\n\t0x3c234, 0x40000000, 0x40000200,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xc78, 0x00000080, 0x00000000,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0xf0311fff, 0x80300000,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x350c, 0x00810000, 0x408af000,\n\t0x7030, 0x31000111, 0x00000011,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x220c, 0x00007fb6, 0x0021a1b1,\n\t0x2210, 0x00007fb6, 0x002021b1,\n\t0x2180, 0x00007fb6, 0x00002191,\n\t0x2218, 0x00007fb6, 0x002121b1,\n\t0x221c, 0x00007fb6, 0x002021b1,\n\t0x21dc, 0x00007fb6, 0x00002191,\n\t0x21e0, 0x00007fb6, 0x00002191,\n\t0x3628, 0x0000003f, 0x0000000a,\n\t0x362c, 0x0000003f, 0x0000000a,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8bf0, 0x00002001, 0x00000001,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x30a04, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x4d8, 0x00000fff, 0x00000100,\n\t0x3e78, 0x00000001, 0x00000002,\n\t0x9100, 0x03000000, 0x0362c688,\n\t0x8c00, 0x000000ff, 0x00000001,\n\t0xe40, 0x00001fff, 0x00001fff,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac14, 0x000003ff, 0x000000f3,\n\t0xac0c, 0xffffffff, 0x00001032\n};\n\nstatic const u32 bonaire_mgcg_cgcg_init[] =\n{\n\t0xc420, 0xffffffff, 0xfffffffc,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c2a0, 0xffffffff, 0x00000100,\n\t0x3c208, 0xffffffff, 0x00000100,\n\t0x3c2c0, 0xffffffff, 0xc0000100,\n\t0x3c2c8, 0xffffffff, 0xc0000100,\n\t0x3c2c4, 0xffffffff, 0xc0000100,\n\t0x55e4, 0xffffffff, 0x00600100,\n\t0x3c280, 0xffffffff, 0x00000100,\n\t0x3c214, 0xffffffff, 0x06000100,\n\t0x3c220, 0xffffffff, 0x00000100,\n\t0x3c218, 0xffffffff, 0x06000100,\n\t0x3c204, 0xffffffff, 0x00000100,\n\t0x3c2e0, 0xffffffff, 0x00000100,\n\t0x3c224, 0xffffffff, 0x00000100,\n\t0x3c200, 0xffffffff, 0x00000100,\n\t0x3c230, 0xffffffff, 0x00000100,\n\t0x3c234, 0xffffffff, 0x00000100,\n\t0x3c250, 0xffffffff, 0x00000100,\n\t0x3c254, 0xffffffff, 0x00000100,\n\t0x3c258, 0xffffffff, 0x00000100,\n\t0x3c25c, 0xffffffff, 0x00000100,\n\t0x3c260, 0xffffffff, 0x00000100,\n\t0x3c27c, 0xffffffff, 0x00000100,\n\t0x3c278, 0xffffffff, 0x00000100,\n\t0x3c210, 0xffffffff, 0x06000100,\n\t0x3c290, 0xffffffff, 0x00000100,\n\t0x3c274, 0xffffffff, 0x00000100,\n\t0x3c2b4, 0xffffffff, 0x00000100,\n\t0x3c2b0, 0xffffffff, 0x00000100,\n\t0x3c270, 0xffffffff, 0x00000100,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c020, 0xffffffff, 0x00010000,\n\t0x3c024, 0xffffffff, 0x00030002,\n\t0x3c028, 0xffffffff, 0x00040007,\n\t0x3c02c, 0xffffffff, 0x00060005,\n\t0x3c030, 0xffffffff, 0x00090008,\n\t0x3c034, 0xffffffff, 0x00010000,\n\t0x3c038, 0xffffffff, 0x00030002,\n\t0x3c03c, 0xffffffff, 0x00040007,\n\t0x3c040, 0xffffffff, 0x00060005,\n\t0x3c044, 0xffffffff, 0x00090008,\n\t0x3c048, 0xffffffff, 0x00010000,\n\t0x3c04c, 0xffffffff, 0x00030002,\n\t0x3c050, 0xffffffff, 0x00040007,\n\t0x3c054, 0xffffffff, 0x00060005,\n\t0x3c058, 0xffffffff, 0x00090008,\n\t0x3c05c, 0xffffffff, 0x00010000,\n\t0x3c060, 0xffffffff, 0x00030002,\n\t0x3c064, 0xffffffff, 0x00040007,\n\t0x3c068, 0xffffffff, 0x00060005,\n\t0x3c06c, 0xffffffff, 0x00090008,\n\t0x3c070, 0xffffffff, 0x00010000,\n\t0x3c074, 0xffffffff, 0x00030002,\n\t0x3c078, 0xffffffff, 0x00040007,\n\t0x3c07c, 0xffffffff, 0x00060005,\n\t0x3c080, 0xffffffff, 0x00090008,\n\t0x3c084, 0xffffffff, 0x00010000,\n\t0x3c088, 0xffffffff, 0x00030002,\n\t0x3c08c, 0xffffffff, 0x00040007,\n\t0x3c090, 0xffffffff, 0x00060005,\n\t0x3c094, 0xffffffff, 0x00090008,\n\t0x3c098, 0xffffffff, 0x00010000,\n\t0x3c09c, 0xffffffff, 0x00030002,\n\t0x3c0a0, 0xffffffff, 0x00040007,\n\t0x3c0a4, 0xffffffff, 0x00060005,\n\t0x3c0a8, 0xffffffff, 0x00090008,\n\t0x3c000, 0xffffffff, 0x96e00200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc424, 0xffffffff, 0x0020003f,\n\t0x38, 0xffffffff, 0x0140001c,\n\t0x3c, 0x000f0000, 0x000f0000,\n\t0x220, 0xffffffff, 0xC060000C,\n\t0x224, 0xc0000fff, 0x00000100,\n\t0xf90, 0xffffffff, 0x00000100,\n\t0xf98, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd00c, 0xff000ff0, 0x00000100,\n\t0xd80c, 0xff000ff0, 0x00000100\n};\n\nstatic const u32 spectre_golden_spm_registers[] =\n{\n\t0x30800, 0xe0ffffff, 0xe0000000\n};\n\nstatic const u32 spectre_golden_common_registers[] =\n{\n\t0xc770, 0xffffffff, 0x00000800,\n\t0xc774, 0xffffffff, 0x00000800,\n\t0xc798, 0xffffffff, 0x00007fbf,\n\t0xc79c, 0xffffffff, 0x00007faf\n};\n\nstatic const u32 spectre_golden_registers[] =\n{\n\t0x3c000, 0xffff1fff, 0x96940200,\n\t0x3c00c, 0xffff0001, 0xff000000,\n\t0x3c200, 0xfffc0fff, 0x00000100,\n\t0x6ed8, 0x00010101, 0x00010000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0xfffffffc, 0x00020200,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0xf0311fff, 0x80300000,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x9b7c, 0x00ff0000, 0x00fc0000,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x28350, 0x3f3f3fff, 0x00000082,\n\t0x28354, 0x0000003f, 0x00000000,\n\t0x3e78, 0x00000001, 0x00000002,\n\t0x913c, 0xffff03df, 0x00000004,\n\t0xc768, 0x00000008, 0x00000008,\n\t0x8c00, 0x000008ff, 0x00000800,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xac0c, 0xffffffff, 0x54763210,\n\t0x214f8, 0x01ff01ff, 0x00000002,\n\t0x21498, 0x007ff800, 0x00200000,\n\t0x2015c, 0xffffffff, 0x00000f40,\n\t0x30934, 0xffffffff, 0x00000001\n};\n\nstatic const u32 spectre_mgcg_cgcg_init[] =\n{\n\t0xc420, 0xffffffff, 0xfffffffc,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c2a0, 0xffffffff, 0x00000100,\n\t0x3c208, 0xffffffff, 0x00000100,\n\t0x3c2c0, 0xffffffff, 0x00000100,\n\t0x3c2c8, 0xffffffff, 0x00000100,\n\t0x3c2c4, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00600100,\n\t0x3c280, 0xffffffff, 0x00000100,\n\t0x3c214, 0xffffffff, 0x06000100,\n\t0x3c220, 0xffffffff, 0x00000100,\n\t0x3c218, 0xffffffff, 0x06000100,\n\t0x3c204, 0xffffffff, 0x00000100,\n\t0x3c2e0, 0xffffffff, 0x00000100,\n\t0x3c224, 0xffffffff, 0x00000100,\n\t0x3c200, 0xffffffff, 0x00000100,\n\t0x3c230, 0xffffffff, 0x00000100,\n\t0x3c234, 0xffffffff, 0x00000100,\n\t0x3c250, 0xffffffff, 0x00000100,\n\t0x3c254, 0xffffffff, 0x00000100,\n\t0x3c258, 0xffffffff, 0x00000100,\n\t0x3c25c, 0xffffffff, 0x00000100,\n\t0x3c260, 0xffffffff, 0x00000100,\n\t0x3c27c, 0xffffffff, 0x00000100,\n\t0x3c278, 0xffffffff, 0x00000100,\n\t0x3c210, 0xffffffff, 0x06000100,\n\t0x3c290, 0xffffffff, 0x00000100,\n\t0x3c274, 0xffffffff, 0x00000100,\n\t0x3c2b4, 0xffffffff, 0x00000100,\n\t0x3c2b0, 0xffffffff, 0x00000100,\n\t0x3c270, 0xffffffff, 0x00000100,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c020, 0xffffffff, 0x00010000,\n\t0x3c024, 0xffffffff, 0x00030002,\n\t0x3c028, 0xffffffff, 0x00040007,\n\t0x3c02c, 0xffffffff, 0x00060005,\n\t0x3c030, 0xffffffff, 0x00090008,\n\t0x3c034, 0xffffffff, 0x00010000,\n\t0x3c038, 0xffffffff, 0x00030002,\n\t0x3c03c, 0xffffffff, 0x00040007,\n\t0x3c040, 0xffffffff, 0x00060005,\n\t0x3c044, 0xffffffff, 0x00090008,\n\t0x3c048, 0xffffffff, 0x00010000,\n\t0x3c04c, 0xffffffff, 0x00030002,\n\t0x3c050, 0xffffffff, 0x00040007,\n\t0x3c054, 0xffffffff, 0x00060005,\n\t0x3c058, 0xffffffff, 0x00090008,\n\t0x3c05c, 0xffffffff, 0x00010000,\n\t0x3c060, 0xffffffff, 0x00030002,\n\t0x3c064, 0xffffffff, 0x00040007,\n\t0x3c068, 0xffffffff, 0x00060005,\n\t0x3c06c, 0xffffffff, 0x00090008,\n\t0x3c070, 0xffffffff, 0x00010000,\n\t0x3c074, 0xffffffff, 0x00030002,\n\t0x3c078, 0xffffffff, 0x00040007,\n\t0x3c07c, 0xffffffff, 0x00060005,\n\t0x3c080, 0xffffffff, 0x00090008,\n\t0x3c084, 0xffffffff, 0x00010000,\n\t0x3c088, 0xffffffff, 0x00030002,\n\t0x3c08c, 0xffffffff, 0x00040007,\n\t0x3c090, 0xffffffff, 0x00060005,\n\t0x3c094, 0xffffffff, 0x00090008,\n\t0x3c098, 0xffffffff, 0x00010000,\n\t0x3c09c, 0xffffffff, 0x00030002,\n\t0x3c0a0, 0xffffffff, 0x00040007,\n\t0x3c0a4, 0xffffffff, 0x00060005,\n\t0x3c0a8, 0xffffffff, 0x00090008,\n\t0x3c0ac, 0xffffffff, 0x00010000,\n\t0x3c0b0, 0xffffffff, 0x00030002,\n\t0x3c0b4, 0xffffffff, 0x00040007,\n\t0x3c0b8, 0xffffffff, 0x00060005,\n\t0x3c0bc, 0xffffffff, 0x00090008,\n\t0x3c000, 0xffffffff, 0x96e00200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc424, 0xffffffff, 0x0020003f,\n\t0x38, 0xffffffff, 0x0140001c,\n\t0x3c, 0x000f0000, 0x000f0000,\n\t0x220, 0xffffffff, 0xC060000C,\n\t0x224, 0xc0000fff, 0x00000100,\n\t0xf90, 0xffffffff, 0x00000100,\n\t0xf98, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd00c, 0xff000ff0, 0x00000100,\n\t0xd80c, 0xff000ff0, 0x00000100\n};\n\nstatic const u32 kalindi_golden_spm_registers[] =\n{\n\t0x30800, 0xe0ffffff, 0xe0000000\n};\n\nstatic const u32 kalindi_golden_common_registers[] =\n{\n\t0xc770, 0xffffffff, 0x00000800,\n\t0xc774, 0xffffffff, 0x00000800,\n\t0xc798, 0xffffffff, 0x00007fbf,\n\t0xc79c, 0xffffffff, 0x00007faf\n};\n\nstatic const u32 kalindi_golden_registers[] =\n{\n\t0x3c000, 0xffffdfff, 0x6e944040,\n\t0x55e4, 0xff607fff, 0xfc000100,\n\t0x3c220, 0xff000fff, 0x00000100,\n\t0x3c224, 0xff000fff, 0x00000100,\n\t0x3c200, 0xfffc0fff, 0x00000100,\n\t0x6ed8, 0x00010101, 0x00010000,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0xf0311fff, 0x80300000,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x98fc, 0xffffffff, 0x00000010,\n\t0x9b7c, 0x00ff0000, 0x00fc0000,\n\t0x8030, 0x00001f0f, 0x0000100a,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x2408, 0x000fffff, 0x000c007f,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8b24, 0x3fff3fff, 0x00ffcfff,\n\t0x30a04, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x4d8, 0x00000fff, 0x00000100,\n\t0x3e78, 0x00000001, 0x00000002,\n\t0xc768, 0x00000008, 0x00000008,\n\t0x8c00, 0x000000ff, 0x00000003,\n\t0x214f8, 0x01ff01ff, 0x00000002,\n\t0x21498, 0x007ff800, 0x00200000,\n\t0x2015c, 0xffffffff, 0x00000f40,\n\t0x88c4, 0x001f3ae3, 0x00000082,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x30934, 0xffffffff, 0x00000000\n};\n\nstatic const u32 kalindi_mgcg_cgcg_init[] =\n{\n\t0xc420, 0xffffffff, 0xfffffffc,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c2a0, 0xffffffff, 0x00000100,\n\t0x3c208, 0xffffffff, 0x00000100,\n\t0x3c2c0, 0xffffffff, 0x00000100,\n\t0x3c2c8, 0xffffffff, 0x00000100,\n\t0x3c2c4, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00600100,\n\t0x3c280, 0xffffffff, 0x00000100,\n\t0x3c214, 0xffffffff, 0x06000100,\n\t0x3c220, 0xffffffff, 0x00000100,\n\t0x3c218, 0xffffffff, 0x06000100,\n\t0x3c204, 0xffffffff, 0x00000100,\n\t0x3c2e0, 0xffffffff, 0x00000100,\n\t0x3c224, 0xffffffff, 0x00000100,\n\t0x3c200, 0xffffffff, 0x00000100,\n\t0x3c230, 0xffffffff, 0x00000100,\n\t0x3c234, 0xffffffff, 0x00000100,\n\t0x3c250, 0xffffffff, 0x00000100,\n\t0x3c254, 0xffffffff, 0x00000100,\n\t0x3c258, 0xffffffff, 0x00000100,\n\t0x3c25c, 0xffffffff, 0x00000100,\n\t0x3c260, 0xffffffff, 0x00000100,\n\t0x3c27c, 0xffffffff, 0x00000100,\n\t0x3c278, 0xffffffff, 0x00000100,\n\t0x3c210, 0xffffffff, 0x06000100,\n\t0x3c290, 0xffffffff, 0x00000100,\n\t0x3c274, 0xffffffff, 0x00000100,\n\t0x3c2b4, 0xffffffff, 0x00000100,\n\t0x3c2b0, 0xffffffff, 0x00000100,\n\t0x3c270, 0xffffffff, 0x00000100,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c020, 0xffffffff, 0x00010000,\n\t0x3c024, 0xffffffff, 0x00030002,\n\t0x3c028, 0xffffffff, 0x00040007,\n\t0x3c02c, 0xffffffff, 0x00060005,\n\t0x3c030, 0xffffffff, 0x00090008,\n\t0x3c034, 0xffffffff, 0x00010000,\n\t0x3c038, 0xffffffff, 0x00030002,\n\t0x3c03c, 0xffffffff, 0x00040007,\n\t0x3c040, 0xffffffff, 0x00060005,\n\t0x3c044, 0xffffffff, 0x00090008,\n\t0x3c000, 0xffffffff, 0x96e00200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc424, 0xffffffff, 0x0020003f,\n\t0x38, 0xffffffff, 0x0140001c,\n\t0x3c, 0x000f0000, 0x000f0000,\n\t0x220, 0xffffffff, 0xC060000C,\n\t0x224, 0xc0000fff, 0x00000100,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd00c, 0xff000ff0, 0x00000100,\n\t0xd80c, 0xff000ff0, 0x00000100\n};\n\nstatic const u32 hawaii_golden_spm_registers[] =\n{\n\t0x30800, 0xe0ffffff, 0xe0000000\n};\n\nstatic const u32 hawaii_golden_common_registers[] =\n{\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x28350, 0xffffffff, 0x3a00161a,\n\t0x28354, 0xffffffff, 0x0000002e,\n\t0x9a10, 0xffffffff, 0x00018208,\n\t0x98f8, 0xffffffff, 0x12011003\n};\n\nstatic const u32 hawaii_golden_registers[] =\n{\n\t0x3354, 0x00000333, 0x00000333,\n\t0x9a10, 0x00010000, 0x00058208,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0x0002021c, 0x00020200,\n\t0xc78, 0x00000080, 0x00000000,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0xf0311fff, 0x80300000,\n\t0x350c, 0x00810000, 0x408af000,\n\t0x7030, 0x31000111, 0x00000011,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x2120, 0x0000007f, 0x0000001b,\n\t0x21dc, 0x00007fb6, 0x00002191,\n\t0x3628, 0x0000003f, 0x0000000a,\n\t0x362c, 0x0000003f, 0x0000000a,\n\t0x2ae4, 0x00073ffe, 0x000022a2,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8bf0, 0x00002001, 0x00000001,\n\t0x8b24, 0xffffffff, 0x00ffffff,\n\t0x30a04, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x3e78, 0x00000001, 0x00000002,\n\t0xc768, 0x00000008, 0x00000008,\n\t0xc770, 0x00000f00, 0x00000800,\n\t0xc774, 0x00000f00, 0x00000800,\n\t0xc798, 0x00ffffff, 0x00ff7fbf,\n\t0xc79c, 0x00ffffff, 0x00ff7faf,\n\t0x8c00, 0x000000ff, 0x00000800,\n\t0xe40, 0x00001fff, 0x00001fff,\n\t0x9060, 0x0000007f, 0x00000020,\n\t0x9508, 0x00010000, 0x00010000,\n\t0xae00, 0x00100000, 0x000ff07c,\n\t0xac14, 0x000003ff, 0x0000000f,\n\t0xac10, 0xffffffff, 0x7564fdec,\n\t0xac0c, 0xffffffff, 0x3120b9a8,\n\t0xac08, 0x20000000, 0x0f9c0000\n};\n\nstatic const u32 hawaii_mgcg_cgcg_init[] =\n{\n\t0xc420, 0xffffffff, 0xfffffffd,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c2a0, 0xffffffff, 0x00000100,\n\t0x3c208, 0xffffffff, 0x00000100,\n\t0x3c2c0, 0xffffffff, 0x00000100,\n\t0x3c2c8, 0xffffffff, 0x00000100,\n\t0x3c2c4, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00200100,\n\t0x3c280, 0xffffffff, 0x00000100,\n\t0x3c214, 0xffffffff, 0x06000100,\n\t0x3c220, 0xffffffff, 0x00000100,\n\t0x3c218, 0xffffffff, 0x06000100,\n\t0x3c204, 0xffffffff, 0x00000100,\n\t0x3c2e0, 0xffffffff, 0x00000100,\n\t0x3c224, 0xffffffff, 0x00000100,\n\t0x3c200, 0xffffffff, 0x00000100,\n\t0x3c230, 0xffffffff, 0x00000100,\n\t0x3c234, 0xffffffff, 0x00000100,\n\t0x3c250, 0xffffffff, 0x00000100,\n\t0x3c254, 0xffffffff, 0x00000100,\n\t0x3c258, 0xffffffff, 0x00000100,\n\t0x3c25c, 0xffffffff, 0x00000100,\n\t0x3c260, 0xffffffff, 0x00000100,\n\t0x3c27c, 0xffffffff, 0x00000100,\n\t0x3c278, 0xffffffff, 0x00000100,\n\t0x3c210, 0xffffffff, 0x06000100,\n\t0x3c290, 0xffffffff, 0x00000100,\n\t0x3c274, 0xffffffff, 0x00000100,\n\t0x3c2b4, 0xffffffff, 0x00000100,\n\t0x3c2b0, 0xffffffff, 0x00000100,\n\t0x3c270, 0xffffffff, 0x00000100,\n\t0x30800, 0xffffffff, 0xe0000000,\n\t0x3c020, 0xffffffff, 0x00010000,\n\t0x3c024, 0xffffffff, 0x00030002,\n\t0x3c028, 0xffffffff, 0x00040007,\n\t0x3c02c, 0xffffffff, 0x00060005,\n\t0x3c030, 0xffffffff, 0x00090008,\n\t0x3c034, 0xffffffff, 0x00010000,\n\t0x3c038, 0xffffffff, 0x00030002,\n\t0x3c03c, 0xffffffff, 0x00040007,\n\t0x3c040, 0xffffffff, 0x00060005,\n\t0x3c044, 0xffffffff, 0x00090008,\n\t0x3c048, 0xffffffff, 0x00010000,\n\t0x3c04c, 0xffffffff, 0x00030002,\n\t0x3c050, 0xffffffff, 0x00040007,\n\t0x3c054, 0xffffffff, 0x00060005,\n\t0x3c058, 0xffffffff, 0x00090008,\n\t0x3c05c, 0xffffffff, 0x00010000,\n\t0x3c060, 0xffffffff, 0x00030002,\n\t0x3c064, 0xffffffff, 0x00040007,\n\t0x3c068, 0xffffffff, 0x00060005,\n\t0x3c06c, 0xffffffff, 0x00090008,\n\t0x3c070, 0xffffffff, 0x00010000,\n\t0x3c074, 0xffffffff, 0x00030002,\n\t0x3c078, 0xffffffff, 0x00040007,\n\t0x3c07c, 0xffffffff, 0x00060005,\n\t0x3c080, 0xffffffff, 0x00090008,\n\t0x3c084, 0xffffffff, 0x00010000,\n\t0x3c088, 0xffffffff, 0x00030002,\n\t0x3c08c, 0xffffffff, 0x00040007,\n\t0x3c090, 0xffffffff, 0x00060005,\n\t0x3c094, 0xffffffff, 0x00090008,\n\t0x3c098, 0xffffffff, 0x00010000,\n\t0x3c09c, 0xffffffff, 0x00030002,\n\t0x3c0a0, 0xffffffff, 0x00040007,\n\t0x3c0a4, 0xffffffff, 0x00060005,\n\t0x3c0a8, 0xffffffff, 0x00090008,\n\t0x3c0ac, 0xffffffff, 0x00010000,\n\t0x3c0b0, 0xffffffff, 0x00030002,\n\t0x3c0b4, 0xffffffff, 0x00040007,\n\t0x3c0b8, 0xffffffff, 0x00060005,\n\t0x3c0bc, 0xffffffff, 0x00090008,\n\t0x3c0c0, 0xffffffff, 0x00010000,\n\t0x3c0c4, 0xffffffff, 0x00030002,\n\t0x3c0c8, 0xffffffff, 0x00040007,\n\t0x3c0cc, 0xffffffff, 0x00060005,\n\t0x3c0d0, 0xffffffff, 0x00090008,\n\t0x3c0d4, 0xffffffff, 0x00010000,\n\t0x3c0d8, 0xffffffff, 0x00030002,\n\t0x3c0dc, 0xffffffff, 0x00040007,\n\t0x3c0e0, 0xffffffff, 0x00060005,\n\t0x3c0e4, 0xffffffff, 0x00090008,\n\t0x3c0e8, 0xffffffff, 0x00010000,\n\t0x3c0ec, 0xffffffff, 0x00030002,\n\t0x3c0f0, 0xffffffff, 0x00040007,\n\t0x3c0f4, 0xffffffff, 0x00060005,\n\t0x3c0f8, 0xffffffff, 0x00090008,\n\t0xc318, 0xffffffff, 0x00020200,\n\t0x3350, 0xffffffff, 0x00000200,\n\t0x15c0, 0xffffffff, 0x00000400,\n\t0x55e8, 0xffffffff, 0x00000000,\n\t0x2f50, 0xffffffff, 0x00000902,\n\t0x3c000, 0xffffffff, 0x96940200,\n\t0x8708, 0xffffffff, 0x00900100,\n\t0xc424, 0xffffffff, 0x0020003f,\n\t0x38, 0xffffffff, 0x0140001c,\n\t0x3c, 0x000f0000, 0x000f0000,\n\t0x220, 0xffffffff, 0xc060000c,\n\t0x224, 0xc0000fff, 0x00000100,\n\t0xf90, 0xffffffff, 0x00000100,\n\t0xf98, 0x00000101, 0x00000000,\n\t0x20a8, 0xffffffff, 0x00000104,\n\t0x55e4, 0xff000fff, 0x00000100,\n\t0x30cc, 0xc0000fff, 0x00000104,\n\t0xc1e4, 0x00000001, 0x00000001,\n\t0xd00c, 0xff000ff0, 0x00000100,\n\t0xd80c, 0xff000ff0, 0x00000100\n};\n\nstatic const u32 godavari_golden_registers[] =\n{\n\t0x55e4, 0xff607fff, 0xfc000100,\n\t0x6ed8, 0x00010101, 0x00010000,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x98302, 0xf00fffff, 0x00000400,\n\t0x6130, 0xffffffff, 0x00010000,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x5bc0, 0xf0311fff, 0x80300000,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x98fc, 0xffffffff, 0x00000010,\n\t0x8030, 0x00001f0f, 0x0000100a,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x2408, 0x000fffff, 0x000c007f,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ff0fff,\n\t0x30a04, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x4d8, 0x00000fff, 0x00000100,\n\t0xd014, 0x00010000, 0x00810001,\n\t0xd814, 0x00010000, 0x00810001,\n\t0x3e78, 0x00000001, 0x00000002,\n\t0xc768, 0x00000008, 0x00000008,\n\t0xc770, 0x00000f00, 0x00000800,\n\t0xc774, 0x00000f00, 0x00000800,\n\t0xc798, 0x00ffffff, 0x00ff7fbf,\n\t0xc79c, 0x00ffffff, 0x00ff7faf,\n\t0x8c00, 0x000000ff, 0x00000001,\n\t0x214f8, 0x01ff01ff, 0x00000002,\n\t0x21498, 0x007ff800, 0x00200000,\n\t0x2015c, 0xffffffff, 0x00000f40,\n\t0x88c4, 0x001f3ae3, 0x00000082,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x30934, 0xffffffff, 0x00000000\n};\n\n\nstatic void cik_init_golden_registers(struct radeon_device *rdev)\n{\n\tswitch (rdev->family) {\n\tcase CHIP_BONAIRE:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t bonaire_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(bonaire_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t bonaire_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(bonaire_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t bonaire_golden_common_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(bonaire_golden_common_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t bonaire_golden_spm_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(bonaire_golden_spm_registers));\n\t\tbreak;\n\tcase CHIP_KABINI:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_golden_common_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_golden_common_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_golden_spm_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_golden_spm_registers));\n\t\tbreak;\n\tcase CHIP_MULLINS:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t godavari_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(godavari_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_golden_common_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_golden_common_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t kalindi_golden_spm_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(kalindi_golden_spm_registers));\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t spectre_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(spectre_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t spectre_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(spectre_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t spectre_golden_common_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(spectre_golden_common_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t spectre_golden_spm_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(spectre_golden_spm_registers));\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hawaii_mgcg_cgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hawaii_mgcg_cgcg_init));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hawaii_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hawaii_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hawaii_golden_common_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hawaii_golden_common_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t hawaii_golden_spm_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(hawaii_golden_spm_registers));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nu32 cik_get_xclk(struct radeon_device *rdev)\n{\n\tu32 reference_clock = rdev->clock.spll.reference_freq;\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tif (RREG32_SMC(GENERAL_PWRMGT) & GPU_COUNTER_CLK)\n\t\t\treturn reference_clock / 2;\n\t} else {\n\t\tif (RREG32_SMC(CG_CLKPIN_CNTL) & XTALIN_DIVIDE)\n\t\t\treturn reference_clock / 4;\n\t}\n\treturn reference_clock;\n}\n\n \nu32 cik_mm_rdoorbell(struct radeon_device *rdev, u32 index)\n{\n\tif (index < rdev->doorbell.num_doorbells) {\n\t\treturn readl(rdev->doorbell.ptr + index);\n\t} else {\n\t\tDRM_ERROR(\"reading beyond doorbell aperture: 0x%08x!\\n\", index);\n\t\treturn 0;\n\t}\n}\n\n \nvoid cik_mm_wdoorbell(struct radeon_device *rdev, u32 index, u32 v)\n{\n\tif (index < rdev->doorbell.num_doorbells) {\n\t\twritel(v, rdev->doorbell.ptr + index);\n\t} else {\n\t\tDRM_ERROR(\"writing beyond doorbell aperture: 0x%08x!\\n\", index);\n\t}\n}\n\n#define BONAIRE_IO_MC_REGS_SIZE 36\n\nstatic const u32 bonaire_io_mc_regs[BONAIRE_IO_MC_REGS_SIZE][2] =\n{\n\t{0x00000070, 0x04400000},\n\t{0x00000071, 0x80c01803},\n\t{0x00000072, 0x00004004},\n\t{0x00000073, 0x00000100},\n\t{0x00000074, 0x00ff0000},\n\t{0x00000075, 0x34000000},\n\t{0x00000076, 0x08000014},\n\t{0x00000077, 0x00cc08ec},\n\t{0x00000078, 0x00000400},\n\t{0x00000079, 0x00000000},\n\t{0x0000007a, 0x04090000},\n\t{0x0000007c, 0x00000000},\n\t{0x0000007e, 0x4408a8e8},\n\t{0x0000007f, 0x00000304},\n\t{0x00000080, 0x00000000},\n\t{0x00000082, 0x00000001},\n\t{0x00000083, 0x00000002},\n\t{0x00000084, 0xf3e4f400},\n\t{0x00000085, 0x052024e3},\n\t{0x00000087, 0x00000000},\n\t{0x00000088, 0x01000000},\n\t{0x0000008a, 0x1c0a0000},\n\t{0x0000008b, 0xff010000},\n\t{0x0000008d, 0xffffefff},\n\t{0x0000008e, 0xfff3efff},\n\t{0x0000008f, 0xfff3efbf},\n\t{0x00000092, 0xf7ffffff},\n\t{0x00000093, 0xffffff7f},\n\t{0x00000095, 0x00101101},\n\t{0x00000096, 0x00000fff},\n\t{0x00000097, 0x00116fff},\n\t{0x00000098, 0x60010000},\n\t{0x00000099, 0x10010000},\n\t{0x0000009a, 0x00006000},\n\t{0x0000009b, 0x00001000},\n\t{0x0000009f, 0x00b48000}\n};\n\n#define HAWAII_IO_MC_REGS_SIZE 22\n\nstatic const u32 hawaii_io_mc_regs[HAWAII_IO_MC_REGS_SIZE][2] =\n{\n\t{0x0000007d, 0x40000000},\n\t{0x0000007e, 0x40180304},\n\t{0x0000007f, 0x0000ff00},\n\t{0x00000081, 0x00000000},\n\t{0x00000083, 0x00000800},\n\t{0x00000086, 0x00000000},\n\t{0x00000087, 0x00000100},\n\t{0x00000088, 0x00020100},\n\t{0x00000089, 0x00000000},\n\t{0x0000008b, 0x00040000},\n\t{0x0000008c, 0x00000100},\n\t{0x0000008e, 0xff010000},\n\t{0x00000090, 0xffffefff},\n\t{0x00000091, 0xfff3efff},\n\t{0x00000092, 0xfff3efbf},\n\t{0x00000093, 0xf7ffffff},\n\t{0x00000094, 0xffffff7f},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x0000009f, 0x00c79000}\n};\n\n\n \nstatic void cik_srbm_select(struct radeon_device *rdev,\n\t\t\t    u32 me, u32 pipe, u32 queue, u32 vmid)\n{\n\tu32 srbm_gfx_cntl = (PIPEID(pipe & 0x3) |\n\t\t\t     MEID(me & 0x3) |\n\t\t\t     VMID(vmid & 0xf) |\n\t\t\t     QUEUEID(queue & 0x7));\n\tWREG32(SRBM_GFX_CNTL, srbm_gfx_cntl);\n}\n\n \n \nint ci_mc_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data = NULL;\n\tconst __le32 *new_fw_data = NULL;\n\tu32 running, tmp;\n\tu32 *io_mc_regs = NULL;\n\tconst __le32 *new_io_mc_regs = NULL;\n\tint i, regs_size, ucode_size;\n\n\tif (!rdev->mc_fw)\n\t\treturn -EINVAL;\n\n\tif (rdev->new_fw) {\n\t\tconst struct mc_firmware_header_v1_0 *hdr =\n\t\t\t(const struct mc_firmware_header_v1_0 *)rdev->mc_fw->data;\n\n\t\tradeon_ucode_print_mc_hdr(&hdr->header);\n\n\t\tregs_size = le32_to_cpu(hdr->io_debug_size_bytes) / (4 * 2);\n\t\tnew_io_mc_regs = (const __le32 *)\n\t\t\t(rdev->mc_fw->data + le32_to_cpu(hdr->io_debug_array_offset_bytes));\n\t\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\t\tnew_fw_data = (const __le32 *)\n\t\t\t(rdev->mc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t} else {\n\t\tucode_size = rdev->mc_fw->size / 4;\n\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_BONAIRE:\n\t\t\tio_mc_regs = (u32 *)&bonaire_io_mc_regs;\n\t\t\tregs_size = BONAIRE_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_HAWAII:\n\t\t\tio_mc_regs = (u32 *)&hawaii_io_mc_regs;\n\t\t\tregs_size = HAWAII_IO_MC_REGS_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfw_data = (const __be32 *)rdev->mc_fw->data;\n\t}\n\n\trunning = RREG32(MC_SEQ_SUP_CNTL) & RUN_MASK;\n\n\tif (running == 0) {\n\t\t \n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000008);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000010);\n\n\t\t \n\t\tfor (i = 0; i < regs_size; i++) {\n\t\t\tif (rdev->new_fw) {\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, le32_to_cpup(new_io_mc_regs++));\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, le32_to_cpup(new_io_mc_regs++));\n\t\t\t} else {\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, io_mc_regs[(i << 1)]);\n\t\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, io_mc_regs[(i << 1) + 1]);\n\t\t\t}\n\t\t}\n\n\t\ttmp = RREG32(MC_SEQ_MISC0);\n\t\tif ((rdev->pdev->device == 0x6649) && ((tmp & 0xff00) == 0x5600)) {\n\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, 5);\n\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, 0x00000023);\n\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, 9);\n\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, 0x000001f0);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < ucode_size; i++) {\n\t\t\tif (rdev->new_fw)\n\t\t\t\tWREG32(MC_SEQ_SUP_PGM, le32_to_cpup(new_fw_data++));\n\t\t\telse\n\t\t\t\tWREG32(MC_SEQ_SUP_PGM, be32_to_cpup(fw_data++));\n\t\t}\n\n\t\t \n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000008);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000004);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000001);\n\n\t\t \n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif (RREG32(MC_SEQ_TRAIN_WAKEUP_CNTL) & TRAIN_DONE_D0)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif (RREG32(MC_SEQ_TRAIN_WAKEUP_CNTL) & TRAIN_DONE_D1)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cik_init_microcode(struct radeon_device *rdev)\n{\n\tconst char *chip_name;\n\tconst char *new_chip_name;\n\tsize_t pfp_req_size, me_req_size, ce_req_size,\n\t\tmec_req_size, rlc_req_size, mc_req_size = 0,\n\t\tsdma_req_size, smc_req_size = 0, mc2_req_size = 0;\n\tchar fw_name[30];\n\tint new_fw = 0;\n\tint err;\n\tint num_fw;\n\tbool new_smc = false;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tswitch (rdev->family) {\n\tcase CHIP_BONAIRE:\n\t\tchip_name = \"BONAIRE\";\n\t\tif ((rdev->pdev->revision == 0x80) ||\n\t\t    (rdev->pdev->revision == 0x81) ||\n\t\t    (rdev->pdev->device == 0x665f))\n\t\t\tnew_smc = true;\n\t\tnew_chip_name = \"bonaire\";\n\t\tpfp_req_size = CIK_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CIK_ME_UCODE_SIZE * 4;\n\t\tce_req_size = CIK_CE_UCODE_SIZE * 4;\n\t\tmec_req_size = CIK_MEC_UCODE_SIZE * 4;\n\t\trlc_req_size = BONAIRE_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = BONAIRE_MC_UCODE_SIZE * 4;\n\t\tmc2_req_size = BONAIRE_MC2_UCODE_SIZE * 4;\n\t\tsdma_req_size = CIK_SDMA_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(BONAIRE_SMC_UCODE_SIZE, 4);\n\t\tnum_fw = 8;\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tchip_name = \"HAWAII\";\n\t\tif (rdev->pdev->revision == 0x80)\n\t\t\tnew_smc = true;\n\t\tnew_chip_name = \"hawaii\";\n\t\tpfp_req_size = CIK_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CIK_ME_UCODE_SIZE * 4;\n\t\tce_req_size = CIK_CE_UCODE_SIZE * 4;\n\t\tmec_req_size = CIK_MEC_UCODE_SIZE * 4;\n\t\trlc_req_size = BONAIRE_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = HAWAII_MC_UCODE_SIZE * 4;\n\t\tmc2_req_size = HAWAII_MC2_UCODE_SIZE * 4;\n\t\tsdma_req_size = CIK_SDMA_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(HAWAII_SMC_UCODE_SIZE, 4);\n\t\tnum_fw = 8;\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tchip_name = \"KAVERI\";\n\t\tnew_chip_name = \"kaveri\";\n\t\tpfp_req_size = CIK_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CIK_ME_UCODE_SIZE * 4;\n\t\tce_req_size = CIK_CE_UCODE_SIZE * 4;\n\t\tmec_req_size = CIK_MEC_UCODE_SIZE * 4;\n\t\trlc_req_size = KV_RLC_UCODE_SIZE * 4;\n\t\tsdma_req_size = CIK_SDMA_UCODE_SIZE * 4;\n\t\tnum_fw = 7;\n\t\tbreak;\n\tcase CHIP_KABINI:\n\t\tchip_name = \"KABINI\";\n\t\tnew_chip_name = \"kabini\";\n\t\tpfp_req_size = CIK_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CIK_ME_UCODE_SIZE * 4;\n\t\tce_req_size = CIK_CE_UCODE_SIZE * 4;\n\t\tmec_req_size = CIK_MEC_UCODE_SIZE * 4;\n\t\trlc_req_size = KB_RLC_UCODE_SIZE * 4;\n\t\tsdma_req_size = CIK_SDMA_UCODE_SIZE * 4;\n\t\tnum_fw = 6;\n\t\tbreak;\n\tcase CHIP_MULLINS:\n\t\tchip_name = \"MULLINS\";\n\t\tnew_chip_name = \"mullins\";\n\t\tpfp_req_size = CIK_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CIK_ME_UCODE_SIZE * 4;\n\t\tce_req_size = CIK_CE_UCODE_SIZE * 4;\n\t\tmec_req_size = CIK_MEC_UCODE_SIZE * 4;\n\t\trlc_req_size = ML_RLC_UCODE_SIZE * 4;\n\t\tsdma_req_size = CIK_SDMA_UCODE_SIZE * 4;\n\t\tnum_fw = 6;\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\n\tDRM_INFO(\"Loading %s Microcode\\n\", new_chip_name);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_pfp.bin\", new_chip_name);\n\terr = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_pfp.bin\", chip_name);\n\t\terr = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->pfp_fw->size != pfp_req_size) {\n\t\t\tpr_err(\"cik_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->pfp_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->pfp_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_me.bin\", new_chip_name);\n\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_me.bin\", chip_name);\n\t\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->me_fw->size != me_req_size) {\n\t\t\tpr_err(\"cik_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->me_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->me_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_ce.bin\", new_chip_name);\n\terr = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_ce.bin\", chip_name);\n\t\terr = request_firmware(&rdev->ce_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->ce_fw->size != ce_req_size) {\n\t\t\tpr_err(\"cik_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->ce_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->ce_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mec.bin\", new_chip_name);\n\terr = request_firmware(&rdev->mec_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mec.bin\", chip_name);\n\t\terr = request_firmware(&rdev->mec_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->mec_fw->size != mec_req_size) {\n\t\t\tpr_err(\"cik_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->mec_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->mec_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tif (rdev->family == CHIP_KAVERI) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mec2.bin\", new_chip_name);\n\t\terr = request_firmware(&rdev->mec2_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tgoto out;\n\t\t} else {\n\t\t\terr = radeon_ucode_validate(rdev->mec2_fw);\n\t\t\tif (err) {\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tnew_fw++;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_rlc.bin\", new_chip_name);\n\terr = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_rlc.bin\", chip_name);\n\t\terr = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->rlc_fw->size != rlc_req_size) {\n\t\t\tpr_err(\"cik_rlc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->rlc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->rlc_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_sdma.bin\", new_chip_name);\n\terr = request_firmware(&rdev->sdma_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_sdma.bin\", chip_name);\n\t\terr = request_firmware(&rdev->sdma_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->sdma_fw->size != sdma_req_size) {\n\t\t\tpr_err(\"cik_sdma: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->sdma_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\terr = radeon_ucode_validate(rdev->sdma_fw);\n\t\tif (err) {\n\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tnew_fw++;\n\t\t}\n\t}\n\n\t \n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc.bin\", new_chip_name);\n\t\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc2.bin\", chip_name);\n\t\t\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\t\t\tif (err) {\n\t\t\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc.bin\", chip_name);\n\t\t\t\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((rdev->mc_fw->size != mc_req_size) &&\n\t\t\t    (rdev->mc_fw->size != mc2_req_size)){\n\t\t\t\tpr_err(\"cik_mc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t\t       rdev->mc_fw->size, fw_name);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tDRM_INFO(\"%s: %zu bytes\\n\", fw_name, rdev->mc_fw->size);\n\t\t} else {\n\t\t\terr = radeon_ucode_validate(rdev->mc_fw);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t\t       fw_name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tnew_fw++;\n\t\t\t}\n\t\t}\n\n\t\tif (new_smc)\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_k_smc.bin\", new_chip_name);\n\t\telse\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_smc.bin\", new_chip_name);\n\t\terr = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_smc.bin\", chip_name);\n\t\t\terr = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"smc: error loading firmware \\\"%s\\\"\\n\",\n\t\t\t\t       fw_name);\n\t\t\t\trelease_firmware(rdev->smc_fw);\n\t\t\t\trdev->smc_fw = NULL;\n\t\t\t\terr = 0;\n\t\t\t} else if (rdev->smc_fw->size != smc_req_size) {\n\t\t\t\tpr_err(\"cik_smc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t\t       rdev->smc_fw->size, fw_name);\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\terr = radeon_ucode_validate(rdev->smc_fw);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"cik_fw: validation failed for firmware \\\"%s\\\"\\n\",\n\t\t\t\t       fw_name);\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tnew_fw++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (new_fw == 0) {\n\t\trdev->new_fw = false;\n\t} else if (new_fw < num_fw) {\n\t\tpr_err(\"ci_fw: mixing new and old firmware!\\n\");\n\t\terr = -EINVAL;\n\t} else {\n\t\trdev->new_fw = true;\n\t}\n\nout:\n\tif (err) {\n\t\tif (err != -EINVAL)\n\t\t\tpr_err(\"cik_cp: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\trelease_firmware(rdev->pfp_fw);\n\t\trdev->pfp_fw = NULL;\n\t\trelease_firmware(rdev->me_fw);\n\t\trdev->me_fw = NULL;\n\t\trelease_firmware(rdev->ce_fw);\n\t\trdev->ce_fw = NULL;\n\t\trelease_firmware(rdev->mec_fw);\n\t\trdev->mec_fw = NULL;\n\t\trelease_firmware(rdev->mec2_fw);\n\t\trdev->mec2_fw = NULL;\n\t\trelease_firmware(rdev->rlc_fw);\n\t\trdev->rlc_fw = NULL;\n\t\trelease_firmware(rdev->sdma_fw);\n\t\trdev->sdma_fw = NULL;\n\t\trelease_firmware(rdev->mc_fw);\n\t\trdev->mc_fw = NULL;\n\t\trelease_firmware(rdev->smc_fw);\n\t\trdev->smc_fw = NULL;\n\t}\n\treturn err;\n}\n\n \n \nstatic void cik_tiling_mode_table_init(struct radeon_device *rdev)\n{\n\tu32 *tile = rdev->config.cik.tile_mode_array;\n\tu32 *macrotile = rdev->config.cik.macrotile_mode_array;\n\tconst u32 num_tile_mode_states =\n\t\t\tARRAY_SIZE(rdev->config.cik.tile_mode_array);\n\tconst u32 num_secondary_tile_mode_states =\n\t\t\tARRAY_SIZE(rdev->config.cik.macrotile_mode_array);\n\tu32 reg_offset, split_equal_to_row_size;\n\tu32 num_pipe_configs;\n\tu32 num_rbs = rdev->config.cik.max_backends_per_se *\n\t\trdev->config.cik.max_shader_engines;\n\n\tswitch (rdev->config.cik.mem_row_size_in_kb) {\n\tcase 1:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_1KB;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_2KB;\n\t\tbreak;\n\tcase 4:\n\t\tsplit_equal_to_row_size = ADDR_SURF_TILE_SPLIT_4KB;\n\t\tbreak;\n\t}\n\n\tnum_pipe_configs = rdev->config.cik.max_tile_pipes;\n\tif (num_pipe_configs > 8)\n\t\tnum_pipe_configs = 16;\n\n\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\ttile[reg_offset] = 0;\n\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\tmacrotile[reg_offset] = 0;\n\n\tswitch(num_pipe_configs) {\n\tcase 16:\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t   NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t   NUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t   NUM_BANKS(ADDR_SURF_2_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t   BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t   MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t   NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t    BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t    MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t    NUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t    BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t    MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t    NUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t    BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t    MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t    NUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t    BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t    MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t    NUM_BANKS(ADDR_SURF_2_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t    BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t    MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t    NUM_BANKS(ADDR_SURF_2_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_TILE_MODE0 + (reg_offset * 4), tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_MACROTILE_MODE0 + (reg_offset * 4), macrotile[reg_offset]);\n\t\tbreak;\n\n\tcase 8:\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_2_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_2_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_TILE_MODE0 + (reg_offset * 4), tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_MACROTILE_MODE0 + (reg_offset * 4), macrotile[reg_offset]);\n\t\tbreak;\n\n\tcase 4:\n\t\tif (num_rbs == 4) {\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_16x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\n\t\t} else if (num_rbs < 4) {\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16));\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P4_8x16) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\t}\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_4_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_TILE_MODE0 + (reg_offset * 4), tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_MACROTILE_MODE0 + (reg_offset * 4), macrotile[reg_offset]);\n\t\tbreak;\n\n\tcase 2:\n\t\ttile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));\n\t\ttile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));\n\t\ttile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));\n\t\ttile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));\n\t\ttile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));\n\t\ttile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t   TILE_SPLIT(split_equal_to_row_size));\n\t\ttile[8] = ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2);\n\t\ttile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t   PIPE_CONFIG(ADDR_SURF_P2));\n\t\ttile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));\n\t\ttile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2));\n\t\ttile[28] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\t\ttile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |\n\t\t\t    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |\n\t\t\t    PIPE_CONFIG(ADDR_SURF_P2) |\n\t\t\t    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));\n\n\t\tmacrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\t\tmacrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_4) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_2) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_16_BANK));\n\t\tmacrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |\n\t\t\t\tBANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |\n\t\t\t\tMACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |\n\t\t\t\tNUM_BANKS(ADDR_SURF_8_BANK));\n\n\t\tfor (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_TILE_MODE0 + (reg_offset * 4), tile[reg_offset]);\n\t\tfor (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)\n\t\t\tWREG32(GB_MACROTILE_MODE0 + (reg_offset * 4), macrotile[reg_offset]);\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_ERROR(\"unknown num pipe config: 0x%x\\n\", num_pipe_configs);\n\t}\n}\n\n \nstatic void cik_select_se_sh(struct radeon_device *rdev,\n\t\t\t     u32 se_num, u32 sh_num)\n{\n\tu32 data = INSTANCE_BROADCAST_WRITES;\n\n\tif ((se_num == 0xffffffff) && (sh_num == 0xffffffff))\n\t\tdata |= SH_BROADCAST_WRITES | SE_BROADCAST_WRITES;\n\telse if (se_num == 0xffffffff)\n\t\tdata |= SE_BROADCAST_WRITES | SH_INDEX(sh_num);\n\telse if (sh_num == 0xffffffff)\n\t\tdata |= SH_BROADCAST_WRITES | SE_INDEX(se_num);\n\telse\n\t\tdata |= SH_INDEX(sh_num) | SE_INDEX(se_num);\n\tWREG32(GRBM_GFX_INDEX, data);\n}\n\n \nstatic u32 cik_create_bitmask(u32 bit_width)\n{\n\tu32 i, mask = 0;\n\n\tfor (i = 0; i < bit_width; i++) {\n\t\tmask <<= 1;\n\t\tmask |= 1;\n\t}\n\treturn mask;\n}\n\n \nstatic u32 cik_get_rb_disabled(struct radeon_device *rdev,\n\t\t\t      u32 max_rb_num_per_se,\n\t\t\t      u32 sh_per_se)\n{\n\tu32 data, mask;\n\n\tdata = RREG32(CC_RB_BACKEND_DISABLE);\n\tif (data & 1)\n\t\tdata &= BACKEND_DISABLE_MASK;\n\telse\n\t\tdata = 0;\n\tdata |= RREG32(GC_USER_RB_BACKEND_DISABLE);\n\n\tdata >>= BACKEND_DISABLE_SHIFT;\n\n\tmask = cik_create_bitmask(max_rb_num_per_se / sh_per_se);\n\n\treturn data & mask;\n}\n\n \nstatic void cik_setup_rb(struct radeon_device *rdev,\n\t\t\t u32 se_num, u32 sh_per_se,\n\t\t\t u32 max_rb_num_per_se)\n{\n\tint i, j;\n\tu32 data, mask;\n\tu32 disabled_rbs = 0;\n\tu32 enabled_rbs = 0;\n\n\tfor (i = 0; i < se_num; i++) {\n\t\tfor (j = 0; j < sh_per_se; j++) {\n\t\t\tcik_select_se_sh(rdev, i, j);\n\t\t\tdata = cik_get_rb_disabled(rdev, max_rb_num_per_se, sh_per_se);\n\t\t\tif (rdev->family == CHIP_HAWAII)\n\t\t\t\tdisabled_rbs |= data << ((i * sh_per_se + j) * HAWAII_RB_BITMAP_WIDTH_PER_SH);\n\t\t\telse\n\t\t\t\tdisabled_rbs |= data << ((i * sh_per_se + j) * CIK_RB_BITMAP_WIDTH_PER_SH);\n\t\t}\n\t}\n\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\n\tmask = 1;\n\tfor (i = 0; i < max_rb_num_per_se * se_num; i++) {\n\t\tif (!(disabled_rbs & mask))\n\t\t\tenabled_rbs |= mask;\n\t\tmask <<= 1;\n\t}\n\n\trdev->config.cik.backend_enable_mask = enabled_rbs;\n\n\tfor (i = 0; i < se_num; i++) {\n\t\tcik_select_se_sh(rdev, i, 0xffffffff);\n\t\tdata = 0;\n\t\tfor (j = 0; j < sh_per_se; j++) {\n\t\t\tswitch (enabled_rbs & 3) {\n\t\t\tcase 0:\n\t\t\t\tif (j == 0)\n\t\t\t\t\tdata |= PKR_MAP(RASTER_CONFIG_RB_MAP_3);\n\t\t\t\telse\n\t\t\t\t\tdata |= PKR_MAP(RASTER_CONFIG_RB_MAP_0);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tdata |= (RASTER_CONFIG_RB_MAP_0 << (i * sh_per_se + j) * 2);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tdata |= (RASTER_CONFIG_RB_MAP_3 << (i * sh_per_se + j) * 2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tdefault:\n\t\t\t\tdata |= (RASTER_CONFIG_RB_MAP_2 << (i * sh_per_se + j) * 2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tenabled_rbs >>= 2;\n\t\t}\n\t\tWREG32(PA_SC_RASTER_CONFIG, data);\n\t}\n\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n}\n\n \nstatic void cik_gpu_init(struct radeon_device *rdev)\n{\n\tu32 gb_addr_config = RREG32(GB_ADDR_CONFIG);\n\tu32 mc_arb_ramcfg;\n\tu32 hdp_host_path_cntl;\n\tu32 tmp;\n\tint i, j;\n\n\tswitch (rdev->family) {\n\tcase CHIP_BONAIRE:\n\t\trdev->config.cik.max_shader_engines = 2;\n\t\trdev->config.cik.max_tile_pipes = 4;\n\t\trdev->config.cik.max_cu_per_sh = 7;\n\t\trdev->config.cik.max_sh_per_se = 1;\n\t\trdev->config.cik.max_backends_per_se = 2;\n\t\trdev->config.cik.max_texture_channel_caches = 4;\n\t\trdev->config.cik.max_gprs = 256;\n\t\trdev->config.cik.max_gs_threads = 32;\n\t\trdev->config.cik.max_hw_contexts = 8;\n\n\t\trdev->config.cik.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.cik.sc_prim_fifo_size_backend = 0x100;\n\t\trdev->config.cik.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\trdev->config.cik.max_shader_engines = 4;\n\t\trdev->config.cik.max_tile_pipes = 16;\n\t\trdev->config.cik.max_cu_per_sh = 11;\n\t\trdev->config.cik.max_sh_per_se = 1;\n\t\trdev->config.cik.max_backends_per_se = 4;\n\t\trdev->config.cik.max_texture_channel_caches = 16;\n\t\trdev->config.cik.max_gprs = 256;\n\t\trdev->config.cik.max_gs_threads = 32;\n\t\trdev->config.cik.max_hw_contexts = 8;\n\n\t\trdev->config.cik.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.cik.sc_prim_fifo_size_backend = 0x100;\n\t\trdev->config.cik.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\trdev->config.cik.max_shader_engines = 1;\n\t\trdev->config.cik.max_tile_pipes = 4;\n\t\trdev->config.cik.max_cu_per_sh = 8;\n\t\trdev->config.cik.max_backends_per_se = 2;\n\t\trdev->config.cik.max_sh_per_se = 1;\n\t\trdev->config.cik.max_texture_channel_caches = 4;\n\t\trdev->config.cik.max_gprs = 256;\n\t\trdev->config.cik.max_gs_threads = 16;\n\t\trdev->config.cik.max_hw_contexts = 8;\n\n\t\trdev->config.cik.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.cik.sc_prim_fifo_size_backend = 0x100;\n\t\trdev->config.cik.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\tdefault:\n\t\trdev->config.cik.max_shader_engines = 1;\n\t\trdev->config.cik.max_tile_pipes = 2;\n\t\trdev->config.cik.max_cu_per_sh = 2;\n\t\trdev->config.cik.max_sh_per_se = 1;\n\t\trdev->config.cik.max_backends_per_se = 1;\n\t\trdev->config.cik.max_texture_channel_caches = 2;\n\t\trdev->config.cik.max_gprs = 256;\n\t\trdev->config.cik.max_gs_threads = 16;\n\t\trdev->config.cik.max_hw_contexts = 8;\n\n\t\trdev->config.cik.sc_prim_fifo_size_frontend = 0x20;\n\t\trdev->config.cik.sc_prim_fifo_size_backend = 0x100;\n\t\trdev->config.cik.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\n\tWREG32(GRBM_CNTL, GRBM_READ_TIMEOUT(0xff));\n\tWREG32(SRBM_INT_CNTL, 0x1);\n\tWREG32(SRBM_INT_ACK, 0x1);\n\n\tWREG32(BIF_FB_EN, FB_READ_EN | FB_WRITE_EN);\n\n\tRREG32(MC_SHARED_CHMAP);\n\tmc_arb_ramcfg = RREG32(MC_ARB_RAMCFG);\n\n\trdev->config.cik.num_tile_pipes = rdev->config.cik.max_tile_pipes;\n\trdev->config.cik.mem_max_burst_length_bytes = 256;\n\ttmp = (mc_arb_ramcfg & NOOFCOLS_MASK) >> NOOFCOLS_SHIFT;\n\trdev->config.cik.mem_row_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;\n\tif (rdev->config.cik.mem_row_size_in_kb > 4)\n\t\trdev->config.cik.mem_row_size_in_kb = 4;\n\t \n\trdev->config.cik.shader_engine_tile_size = 32;\n\trdev->config.cik.num_gpus = 1;\n\trdev->config.cik.multi_gpu_tile_size = 64;\n\n\t \n\tgb_addr_config &= ~ROW_SIZE_MASK;\n\tswitch (rdev->config.cik.mem_row_size_in_kb) {\n\tcase 1:\n\tdefault:\n\t\tgb_addr_config |= ROW_SIZE(0);\n\t\tbreak;\n\tcase 2:\n\t\tgb_addr_config |= ROW_SIZE(1);\n\t\tbreak;\n\tcase 4:\n\t\tgb_addr_config |= ROW_SIZE(2);\n\t\tbreak;\n\t}\n\n\t \n\trdev->config.cik.tile_config = 0;\n\tswitch (rdev->config.cik.num_tile_pipes) {\n\tcase 1:\n\t\trdev->config.cik.tile_config |= (0 << 0);\n\t\tbreak;\n\tcase 2:\n\t\trdev->config.cik.tile_config |= (1 << 0);\n\t\tbreak;\n\tcase 4:\n\t\trdev->config.cik.tile_config |= (2 << 0);\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\t \n\t\trdev->config.cik.tile_config |= (3 << 0);\n\t\tbreak;\n\t}\n\trdev->config.cik.tile_config |=\n\t\t((mc_arb_ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) << 4;\n\trdev->config.cik.tile_config |=\n\t\t((gb_addr_config & PIPE_INTERLEAVE_SIZE_MASK) >> PIPE_INTERLEAVE_SIZE_SHIFT) << 8;\n\trdev->config.cik.tile_config |=\n\t\t((gb_addr_config & ROW_SIZE_MASK) >> ROW_SIZE_SHIFT) << 12;\n\n\tWREG32(GB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(HDP_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMIF_ADDR_CALC, gb_addr_config);\n\tWREG32(SDMA0_TILING_CONFIG + SDMA0_REGISTER_OFFSET, gb_addr_config & 0x70);\n\tWREG32(SDMA0_TILING_CONFIG + SDMA1_REGISTER_OFFSET, gb_addr_config & 0x70);\n\tWREG32(UVD_UDEC_ADDR_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_DB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_DBW_ADDR_CONFIG, gb_addr_config);\n\n\tcik_tiling_mode_table_init(rdev);\n\n\tcik_setup_rb(rdev, rdev->config.cik.max_shader_engines,\n\t\t     rdev->config.cik.max_sh_per_se,\n\t\t     rdev->config.cik.max_backends_per_se);\n\n\trdev->config.cik.active_cus = 0;\n\tfor (i = 0; i < rdev->config.cik.max_shader_engines; i++) {\n\t\tfor (j = 0; j < rdev->config.cik.max_sh_per_se; j++) {\n\t\t\trdev->config.cik.active_cus +=\n\t\t\t\thweight32(cik_get_cu_active_bitmap(rdev, i, j));\n\t\t}\n\t}\n\n\t \n\tWREG32(CP_MEQ_THRESHOLDS, MEQ1_START(0x30) | MEQ2_START(0x60));\n\n\tWREG32(SX_DEBUG_1, 0x20);\n\n\tWREG32(TA_CNTL_AUX, 0x00010000);\n\n\ttmp = RREG32(SPI_CONFIG_CNTL);\n\ttmp |= 0x03000000;\n\tWREG32(SPI_CONFIG_CNTL, tmp);\n\n\tWREG32(SQ_CONFIG, 1);\n\n\tWREG32(DB_DEBUG, 0);\n\n\ttmp = RREG32(DB_DEBUG2) & ~0xf00fffff;\n\ttmp |= 0x00000400;\n\tWREG32(DB_DEBUG2, tmp);\n\n\ttmp = RREG32(DB_DEBUG3) & ~0x0002021c;\n\ttmp |= 0x00020200;\n\tWREG32(DB_DEBUG3, tmp);\n\n\ttmp = RREG32(CB_HW_CONTROL) & ~0x00010000;\n\ttmp |= 0x00018208;\n\tWREG32(CB_HW_CONTROL, tmp);\n\n\tWREG32(SPI_CONFIG_CNTL_1, VTX_DONE_DELAY(4));\n\n\tWREG32(PA_SC_FIFO_SIZE, (SC_FRONTEND_PRIM_FIFO_SIZE(rdev->config.cik.sc_prim_fifo_size_frontend) |\n\t\t\t\t SC_BACKEND_PRIM_FIFO_SIZE(rdev->config.cik.sc_prim_fifo_size_backend) |\n\t\t\t\t SC_HIZ_TILE_FIFO_SIZE(rdev->config.cik.sc_hiz_tile_fifo_size) |\n\t\t\t\t SC_EARLYZ_TILE_FIFO_SIZE(rdev->config.cik.sc_earlyz_tile_fifo_size)));\n\n\tWREG32(VGT_NUM_INSTANCES, 1);\n\n\tWREG32(CP_PERFMON_CNTL, 0);\n\n\tWREG32(SQ_CONFIG, 0);\n\n\tWREG32(PA_SC_FORCE_EOV_MAX_CNTS, (FORCE_EOV_MAX_CLK_CNT(4095) |\n\t\t\t\t\t  FORCE_EOV_MAX_REZ_CNT(255)));\n\n\tWREG32(VGT_CACHE_INVALIDATION, CACHE_INVALIDATION(VC_AND_TC) |\n\t       AUTO_INVLD_EN(ES_AND_GS_AUTO));\n\n\tWREG32(VGT_GS_VERTEX_REUSE, 16);\n\tWREG32(PA_SC_LINE_STIPPLE_STATE, 0);\n\n\ttmp = RREG32(HDP_MISC_CNTL);\n\ttmp |= HDP_FLUSH_INVALIDATE_CACHE;\n\tWREG32(HDP_MISC_CNTL, tmp);\n\n\thdp_host_path_cntl = RREG32(HDP_HOST_PATH_CNTL);\n\tWREG32(HDP_HOST_PATH_CNTL, hdp_host_path_cntl);\n\n\tWREG32(PA_CL_ENHANCE, CLIP_VTX_REORDER_ENA | NUM_CLIP_SEQ(3));\n\tWREG32(PA_SC_ENHANCE, ENABLE_PA_SC_OUT_OF_ORDER);\n\n\tudelay(50);\n}\n\n \n \nstatic void cik_scratch_init(struct radeon_device *rdev)\n{\n\tint i;\n\n\trdev->scratch.num_reg = 7;\n\trdev->scratch.reg_base = SCRATCH_REG0;\n\tfor (i = 0; i < rdev->scratch.num_reg; i++) {\n\t\trdev->scratch.free[i] = true;\n\t\trdev->scratch.reg[i] = rdev->scratch.reg_base + (i * 4);\n\t}\n}\n\n \nint cik_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to get scratch reg (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ring_lock(rdev, ring, 3);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring %d (%d).\\n\", ring->idx, r);\n\t\tradeon_scratch_free(rdev, scratch);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));\n\tradeon_ring_write(ring, ((scratch - PACKET3_SET_UCONFIG_REG_START) >> 2));\n\tradeon_ring_write(ring, 0xDEADBEEF);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ring test on %d succeeded in %d usecs\\n\", ring->idx, i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ring %d test failed (scratch(0x%04X)=0x%08X)\\n\",\n\t\t\t  ring->idx, scratch, tmp);\n\t\tr = -EINVAL;\n\t}\n\tradeon_scratch_free(rdev, scratch);\n\treturn r;\n}\n\n \nstatic void cik_hdp_flush_cp_ring_emit(struct radeon_device *rdev,\n\t\t\t\t       int ridx)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ridx];\n\tu32 ref_and_mask;\n\n\tswitch (ring->idx) {\n\tcase CAYMAN_RING_TYPE_CP1_INDEX:\n\tcase CAYMAN_RING_TYPE_CP2_INDEX:\n\tdefault:\n\t\tswitch (ring->me) {\n\t\tcase 0:\n\t\t\tref_and_mask = CP2 << ring->pipe;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tref_and_mask = CP6 << ring->pipe;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase RADEON_RING_TYPE_GFX_INDEX:\n\t\tref_and_mask = CP0;\n\t\tbreak;\n\t}\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tradeon_ring_write(ring, (WAIT_REG_MEM_OPERATION(1) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(3) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(1)));    \n\tradeon_ring_write(ring, GPU_HDP_FLUSH_REQ >> 2);\n\tradeon_ring_write(ring, GPU_HDP_FLUSH_DONE >> 2);\n\tradeon_ring_write(ring, ref_and_mask);\n\tradeon_ring_write(ring, ref_and_mask);\n\tradeon_ring_write(ring, 0x20);  \n}\n\n \nvoid cik_fence_gfx_ring_emit(struct radeon_device *rdev,\n\t\t\t     struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tradeon_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tradeon_ring_write(ring, addr & 0xfffffffc);\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xffff) |\n\t\t\t\tDATA_SEL(1) | INT_SEL(0));\n\tradeon_ring_write(ring, fence->seq - 1);\n\tradeon_ring_write(ring, 0);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tradeon_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tradeon_ring_write(ring, addr & 0xfffffffc);\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xffff) | DATA_SEL(1) | INT_SEL(2));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, 0);\n}\n\n \nvoid cik_fence_compute_ring_emit(struct radeon_device *rdev,\n\t\t\t\t struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_RELEASE_MEM, 5));\n\tradeon_ring_write(ring, (EOP_TCL1_ACTION_EN |\n\t\t\t\t EOP_TC_ACTION_EN |\n\t\t\t\t EVENT_TYPE(CACHE_FLUSH_AND_INV_TS_EVENT) |\n\t\t\t\t EVENT_INDEX(5)));\n\tradeon_ring_write(ring, DATA_SEL(1) | INT_SEL(2));\n\tradeon_ring_write(ring, addr & 0xfffffffc);\n\tradeon_ring_write(ring, upper_32_bits(addr));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, 0);\n}\n\n \nbool cik_semaphore_ring_emit(struct radeon_device *rdev,\n\t\t\t     struct radeon_ring *ring,\n\t\t\t     struct radeon_semaphore *semaphore,\n\t\t\t     bool emit_wait)\n{\n\tuint64_t addr = semaphore->gpu_addr;\n\tunsigned sel = emit_wait ? PACKET3_SEM_SEL_WAIT : PACKET3_SEM_SEL_SIGNAL;\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_MEM_SEMAPHORE, 1));\n\tradeon_ring_write(ring, lower_32_bits(addr));\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xffff) | sel);\n\n\tif (emit_wait && ring->idx == RADEON_RING_TYPE_GFX_INDEX) {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tradeon_ring_write(ring, 0x0);\n\t}\n\n\treturn true;\n}\n\n \nstruct radeon_fence *cik_copy_cpdma(struct radeon_device *rdev,\n\t\t\t\t    uint64_t src_offset, uint64_t dst_offset,\n\t\t\t\t    unsigned num_gpu_pages,\n\t\t\t\t    struct dma_resv *resv)\n{\n\tstruct radeon_fence *fence;\n\tstruct radeon_sync sync;\n\tint ring_index = rdev->asic->copy.blit_ring_index;\n\tstruct radeon_ring *ring = &rdev->ring[ring_index];\n\tu32 size_in_bytes, cur_size_in_bytes, control;\n\tint i, num_loops;\n\tint r = 0;\n\n\tradeon_sync_create(&sync);\n\n\tsize_in_bytes = (num_gpu_pages << RADEON_GPU_PAGE_SHIFT);\n\tnum_loops = DIV_ROUND_UP(size_in_bytes, 0x1fffff);\n\tr = radeon_ring_lock(rdev, ring, num_loops * 7 + 18);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: moving bo (%d).\\n\", r);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_sync_resv(rdev, &sync, resv, false);\n\tradeon_sync_rings(rdev, &sync, ring->idx);\n\n\tfor (i = 0; i < num_loops; i++) {\n\t\tcur_size_in_bytes = size_in_bytes;\n\t\tif (cur_size_in_bytes > 0x1fffff)\n\t\t\tcur_size_in_bytes = 0x1fffff;\n\t\tsize_in_bytes -= cur_size_in_bytes;\n\t\tcontrol = 0;\n\t\tif (size_in_bytes == 0)\n\t\t\tcontrol |= PACKET3_DMA_DATA_CP_SYNC;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_DMA_DATA, 5));\n\t\tradeon_ring_write(ring, control);\n\t\tradeon_ring_write(ring, lower_32_bits(src_offset));\n\t\tradeon_ring_write(ring, upper_32_bits(src_offset));\n\t\tradeon_ring_write(ring, lower_32_bits(dst_offset));\n\t\tradeon_ring_write(ring, upper_32_bits(dst_offset));\n\t\tradeon_ring_write(ring, cur_size_in_bytes);\n\t\tsrc_offset += cur_size_in_bytes;\n\t\tdst_offset += cur_size_in_bytes;\n\t}\n\n\tr = radeon_fence_emit(rdev, &fence, ring->idx);\n\tif (r) {\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tradeon_sync_free(rdev, &sync, fence);\n\n\treturn fence;\n}\n\n \n \nvoid cik_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tunsigned vm_id = ib->vm ? ib->vm->ids[ib->ring].id : 0;\n\tu32 header, control = INDIRECT_BUFFER_VALID;\n\n\tif (ib->is_const_ib) {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SWITCH_BUFFER, 0));\n\t\tradeon_ring_write(ring, 0);\n\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER_CONST, 2);\n\t} else {\n\t\tu32 next_rptr;\n\t\tif (ring->rptr_save_reg) {\n\t\t\tnext_rptr = ring->wptr + 3 + 4;\n\t\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_UCONFIG_REG, 1));\n\t\t\tradeon_ring_write(ring, ((ring->rptr_save_reg -\n\t\t\t\t\t\t  PACKET3_SET_UCONFIG_REG_START) >> 2));\n\t\t\tradeon_ring_write(ring, next_rptr);\n\t\t} else if (rdev->wb.enabled) {\n\t\t\tnext_rptr = ring->wptr + 5 + 4;\n\t\t\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\t\t\tradeon_ring_write(ring, WRITE_DATA_DST_SEL(1));\n\t\t\tradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\n\t\t\tradeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));\n\t\t\tradeon_ring_write(ring, next_rptr);\n\t\t}\n\n\t\theader = PACKET3(PACKET3_INDIRECT_BUFFER, 2);\n\t}\n\n\tcontrol |= ib->length_dw | (vm_id << 24);\n\n\tradeon_ring_write(ring, header);\n\tradeon_ring_write(ring, (ib->gpu_addr & 0xFFFFFFFC));\n\tradeon_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFFFF);\n\tradeon_ring_write(ring, control);\n}\n\n \nint cik_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tstruct radeon_ib ib;\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get scratch reg (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ib_get(rdev, ring->idx, &ib, NULL, 256);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get ib (%d).\\n\", r);\n\t\tradeon_scratch_free(rdev, scratch);\n\t\treturn r;\n\t}\n\tib.ptr[0] = PACKET3(PACKET3_SET_UCONFIG_REG, 1);\n\tib.ptr[1] = ((scratch - PACKET3_SET_UCONFIG_REG_START) >> 2);\n\tib.ptr[2] = 0xDEADBEEF;\n\tib.length_dw = 3;\n\tr = radeon_ib_schedule(rdev, &ib, NULL, false);\n\tif (r) {\n\t\tradeon_scratch_free(rdev, scratch);\n\t\tradeon_ib_free(rdev, &ib);\n\t\tDRM_ERROR(\"radeon: failed to schedule ib (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tr = radeon_fence_wait_timeout(ib.fence, false, usecs_to_jiffies(\n\t\tRADEON_USEC_IB_TEST_TIMEOUT));\n\tif (r < 0) {\n\t\tDRM_ERROR(\"radeon: fence wait failed (%d).\\n\", r);\n\t\tradeon_scratch_free(rdev, scratch);\n\t\tradeon_ib_free(rdev, &ib);\n\t\treturn r;\n\t} else if (r == 0) {\n\t\tDRM_ERROR(\"radeon: fence wait timed out.\\n\");\n\t\tradeon_scratch_free(rdev, scratch);\n\t\tradeon_ib_free(rdev, &ib);\n\t\treturn -ETIMEDOUT;\n\t}\n\tr = 0;\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ib test on ring %d succeeded in %u usecs\\n\", ib.fence->ring, i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ib test failed (scratch(0x%04X)=0x%08X)\\n\",\n\t\t\t  scratch, tmp);\n\t\tr = -EINVAL;\n\t}\n\tradeon_scratch_free(rdev, scratch);\n\tradeon_ib_free(rdev, &ib);\n\treturn r;\n}\n\n \n \nstatic void cik_cp_gfx_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32(CP_ME_CNTL, 0);\n\telse {\n\t\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\n\t\tWREG32(CP_ME_CNTL, (CP_ME_HALT | CP_PFP_HALT | CP_CE_HALT));\n\t\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\t}\n\tudelay(50);\n}\n\n \nstatic int cik_cp_gfx_load_microcode(struct radeon_device *rdev)\n{\n\tint i;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->ce_fw)\n\t\treturn -EINVAL;\n\n\tcik_cp_gfx_enable(rdev, false);\n\n\tif (rdev->new_fw) {\n\t\tconst struct gfx_firmware_header_v1_0 *pfp_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->pfp_fw->data;\n\t\tconst struct gfx_firmware_header_v1_0 *ce_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->ce_fw->data;\n\t\tconst struct gfx_firmware_header_v1_0 *me_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->me_fw->data;\n\t\tconst __le32 *fw_data;\n\t\tu32 fw_size;\n\n\t\tradeon_ucode_print_gfx_hdr(&pfp_hdr->header);\n\t\tradeon_ucode_print_gfx_hdr(&ce_hdr->header);\n\t\tradeon_ucode_print_gfx_hdr(&me_hdr->header);\n\n\t\t \n\t\tfw_data = (const __le32 *)\n\t\t\t(rdev->pfp_fw->data + le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(pfp_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_PFP_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_PFP_UCODE_ADDR, le32_to_cpu(pfp_hdr->header.ucode_version));\n\n\t\t \n\t\tfw_data = (const __le32 *)\n\t\t\t(rdev->ce_fw->data + le32_to_cpu(ce_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(ce_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_CE_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_CE_UCODE_ADDR, le32_to_cpu(ce_hdr->header.ucode_version));\n\n\t\t \n\t\tfw_data = (const __be32 *)\n\t\t\t(rdev->me_fw->data + le32_to_cpu(me_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(me_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_ME_RAM_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_ME_RAM_WADDR, le32_to_cpu(me_hdr->header.ucode_version));\n\t\tWREG32(CP_ME_RAM_RADDR, le32_to_cpu(me_hdr->header.ucode_version));\n\t} else {\n\t\tconst __be32 *fw_data;\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->pfp_fw->data;\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < CIK_PFP_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->ce_fw->data;\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < CIK_CE_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_CE_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_CE_UCODE_ADDR, 0);\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->me_fw->data;\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t\tfor (i = 0; i < CIK_ME_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_ME_RAM_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_ME_RAM_WADDR, 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cik_cp_gfx_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r, i;\n\n\t \n\tWREG32(CP_MAX_CONTEXT, rdev->config.cik.max_hw_contexts - 1);\n\tWREG32(CP_ENDIAN_SWAP, 0);\n\tWREG32(CP_DEVICE_ID, 1);\n\n\tcik_cp_gfx_enable(rdev, true);\n\n\tr = radeon_ring_lock(rdev, ring, cik_default_size + 17);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_BASE, 2));\n\tradeon_ring_write(ring, PACKET3_BASE_INDEX(CE_PARTITION_BASE));\n\tradeon_ring_write(ring, 0x8000);\n\tradeon_ring_write(ring, 0x8000);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tradeon_ring_write(ring, 0x80000000);\n\tradeon_ring_write(ring, 0x80000000);\n\n\tfor (i = 0; i < cik_default_size; i++)\n\t\tradeon_ring_write(ring, cik_default_state[i]);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tradeon_ring_write(ring, 0);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tradeon_ring_write(ring, 0x00000316);\n\tradeon_ring_write(ring, 0x0000000e);  \n\tradeon_ring_write(ring, 0x00000010);  \n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\treturn 0;\n}\n\n \nstatic void cik_cp_gfx_fini(struct radeon_device *rdev)\n{\n\tcik_cp_gfx_enable(rdev, false);\n\tradeon_ring_fini(rdev, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX]);\n}\n\n \nstatic int cik_cp_gfx_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tu64 rb_addr;\n\tint r;\n\n\tWREG32(CP_SEM_WAIT_TIMER, 0x0);\n\tif (rdev->family != CHIP_HAWAII)\n\t\tWREG32(CP_SEM_INCOMPLETE_TIMER_CNTL, 0x0);\n\n\t \n\tWREG32(CP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32(CP_RB_VMID, 0);\n\n\tWREG32(SCRATCH_ADDR, ((rdev->wb.gpu_addr + RADEON_WB_SCRATCH_OFFSET) >> 8) & 0xFFFFFFFF);\n\n\t \n\t \n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= BUF_SWAP_32BIT;\n#endif\n\tWREG32(CP_RB0_CNTL, tmp);\n\n\t \n\tWREG32(CP_RB0_CNTL, tmp | RB_RPTR_WR_ENA);\n\tring->wptr = 0;\n\tWREG32(CP_RB0_WPTR, ring->wptr);\n\n\t \n\tWREG32(CP_RB0_RPTR_ADDR, (rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(CP_RB0_RPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFF);\n\n\t \n\tWREG32(SCRATCH_UMSK, 0);\n\n\tif (!rdev->wb.enabled)\n\t\ttmp |= RB_NO_UPDATE;\n\n\tmdelay(1);\n\tWREG32(CP_RB0_CNTL, tmp);\n\n\trb_addr = ring->gpu_addr >> 8;\n\tWREG32(CP_RB0_BASE, rb_addr);\n\tWREG32(CP_RB0_BASE_HI, upper_32_bits(rb_addr));\n\n\t \n\tcik_cp_gfx_start(rdev);\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = true;\n\tr = radeon_ring_test(rdev, RADEON_RING_TYPE_GFX_INDEX, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX]);\n\tif (r) {\n\t\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\t\treturn r;\n\t}\n\n\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\n\n\treturn 0;\n}\n\nu32 cik_gfx_get_rptr(struct radeon_device *rdev,\n\t\t     struct radeon_ring *ring)\n{\n\tu32 rptr;\n\n\tif (rdev->wb.enabled)\n\t\trptr = rdev->wb.wb[ring->rptr_offs/4];\n\telse\n\t\trptr = RREG32(CP_RB0_RPTR);\n\n\treturn rptr;\n}\n\nu32 cik_gfx_get_wptr(struct radeon_device *rdev,\n\t\t     struct radeon_ring *ring)\n{\n\treturn RREG32(CP_RB0_WPTR);\n}\n\nvoid cik_gfx_set_wptr(struct radeon_device *rdev,\n\t\t      struct radeon_ring *ring)\n{\n\tWREG32(CP_RB0_WPTR, ring->wptr);\n\t(void)RREG32(CP_RB0_WPTR);\n}\n\nu32 cik_compute_get_rptr(struct radeon_device *rdev,\n\t\t\t struct radeon_ring *ring)\n{\n\tu32 rptr;\n\n\tif (rdev->wb.enabled) {\n\t\trptr = rdev->wb.wb[ring->rptr_offs/4];\n\t} else {\n\t\tmutex_lock(&rdev->srbm_mutex);\n\t\tcik_srbm_select(rdev, ring->me, ring->pipe, ring->queue, 0);\n\t\trptr = RREG32(CP_HQD_PQ_RPTR);\n\t\tcik_srbm_select(rdev, 0, 0, 0, 0);\n\t\tmutex_unlock(&rdev->srbm_mutex);\n\t}\n\n\treturn rptr;\n}\n\nu32 cik_compute_get_wptr(struct radeon_device *rdev,\n\t\t\t struct radeon_ring *ring)\n{\n\tu32 wptr;\n\n\tif (rdev->wb.enabled) {\n\t\t \n\t\twptr = rdev->wb.wb[ring->wptr_offs/4];\n\t} else {\n\t\tmutex_lock(&rdev->srbm_mutex);\n\t\tcik_srbm_select(rdev, ring->me, ring->pipe, ring->queue, 0);\n\t\twptr = RREG32(CP_HQD_PQ_WPTR);\n\t\tcik_srbm_select(rdev, 0, 0, 0, 0);\n\t\tmutex_unlock(&rdev->srbm_mutex);\n\t}\n\n\treturn wptr;\n}\n\nvoid cik_compute_set_wptr(struct radeon_device *rdev,\n\t\t\t  struct radeon_ring *ring)\n{\n\t \n\trdev->wb.wb[ring->wptr_offs/4] = ring->wptr;\n\tWDOORBELL32(ring->doorbell_index, ring->wptr);\n}\n\nstatic void cik_compute_stop(struct radeon_device *rdev,\n\t\t\t     struct radeon_ring *ring)\n{\n\tu32 j, tmp;\n\n\tcik_srbm_select(rdev, ring->me, ring->pipe, ring->queue, 0);\n\t \n\ttmp = RREG32(CP_PQ_WPTR_POLL_CNTL);\n\ttmp &= ~WPTR_POLL_EN;\n\tWREG32(CP_PQ_WPTR_POLL_CNTL, tmp);\n\t \n\tif (RREG32(CP_HQD_ACTIVE) & 1) {\n\t\tWREG32(CP_HQD_DEQUEUE_REQUEST, 1);\n\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\tif (!(RREG32(CP_HQD_ACTIVE) & 1))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t\tWREG32(CP_HQD_DEQUEUE_REQUEST, 0);\n\t\tWREG32(CP_HQD_PQ_RPTR, 0);\n\t\tWREG32(CP_HQD_PQ_WPTR, 0);\n\t}\n\tcik_srbm_select(rdev, 0, 0, 0, 0);\n}\n\n \nstatic void cik_cp_compute_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32(CP_MEC_CNTL, 0);\n\telse {\n\t\t \n\t\tmutex_lock(&rdev->srbm_mutex);\n\t\tcik_compute_stop(rdev,&rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX]);\n\t\tcik_compute_stop(rdev,&rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX]);\n\t\tmutex_unlock(&rdev->srbm_mutex);\n\n\t\tWREG32(CP_MEC_CNTL, (MEC_ME1_HALT | MEC_ME2_HALT));\n\t\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;\n\t}\n\tudelay(50);\n}\n\n \nstatic int cik_cp_compute_load_microcode(struct radeon_device *rdev)\n{\n\tint i;\n\n\tif (!rdev->mec_fw)\n\t\treturn -EINVAL;\n\n\tcik_cp_compute_enable(rdev, false);\n\n\tif (rdev->new_fw) {\n\t\tconst struct gfx_firmware_header_v1_0 *mec_hdr =\n\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->mec_fw->data;\n\t\tconst __le32 *fw_data;\n\t\tu32 fw_size;\n\n\t\tradeon_ucode_print_gfx_hdr(&mec_hdr->header);\n\n\t\t \n\t\tfw_data = (const __le32 *)\n\t\t\t(rdev->mec_fw->data + le32_to_cpu(mec_hdr->header.ucode_array_offset_bytes));\n\t\tfw_size = le32_to_cpu(mec_hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(CP_MEC_ME1_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < fw_size; i++)\n\t\t\tWREG32(CP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(CP_MEC_ME1_UCODE_ADDR, le32_to_cpu(mec_hdr->header.ucode_version));\n\n\t\t \n\t\tif (rdev->family == CHIP_KAVERI) {\n\t\t\tconst struct gfx_firmware_header_v1_0 *mec2_hdr =\n\t\t\t\t(const struct gfx_firmware_header_v1_0 *)rdev->mec2_fw->data;\n\n\t\t\tfw_data = (const __le32 *)\n\t\t\t\t(rdev->mec2_fw->data +\n\t\t\t\t le32_to_cpu(mec2_hdr->header.ucode_array_offset_bytes));\n\t\t\tfw_size = le32_to_cpu(mec2_hdr->header.ucode_size_bytes) / 4;\n\t\t\tWREG32(CP_MEC_ME2_UCODE_ADDR, 0);\n\t\t\tfor (i = 0; i < fw_size; i++)\n\t\t\t\tWREG32(CP_MEC_ME2_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\t\tWREG32(CP_MEC_ME2_UCODE_ADDR, le32_to_cpu(mec2_hdr->header.ucode_version));\n\t\t}\n\t} else {\n\t\tconst __be32 *fw_data;\n\n\t\t \n\t\tfw_data = (const __be32 *)rdev->mec_fw->data;\n\t\tWREG32(CP_MEC_ME1_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < CIK_MEC_UCODE_SIZE; i++)\n\t\t\tWREG32(CP_MEC_ME1_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(CP_MEC_ME1_UCODE_ADDR, 0);\n\n\t\tif (rdev->family == CHIP_KAVERI) {\n\t\t\t \n\t\t\tfw_data = (const __be32 *)rdev->mec_fw->data;\n\t\t\tWREG32(CP_MEC_ME2_UCODE_ADDR, 0);\n\t\t\tfor (i = 0; i < CIK_MEC_UCODE_SIZE; i++)\n\t\t\t\tWREG32(CP_MEC_ME2_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t\tWREG32(CP_MEC_ME2_UCODE_ADDR, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cik_cp_compute_start(struct radeon_device *rdev)\n{\n\tcik_cp_compute_enable(rdev, true);\n\n\treturn 0;\n}\n\n \nstatic void cik_cp_compute_fini(struct radeon_device *rdev)\n{\n\tint i, idx, r;\n\n\tcik_cp_compute_enable(rdev, false);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (i == 0)\n\t\t\tidx = CAYMAN_RING_TYPE_CP1_INDEX;\n\t\telse\n\t\t\tidx = CAYMAN_RING_TYPE_CP2_INDEX;\n\n\t\tif (rdev->ring[idx].mqd_obj) {\n\t\t\tr = radeon_bo_reserve(rdev->ring[idx].mqd_obj, false);\n\t\t\tif (unlikely(r != 0))\n\t\t\t\tdev_warn(rdev->dev, \"(%d) reserve MQD bo failed\\n\", r);\n\n\t\t\tradeon_bo_unpin(rdev->ring[idx].mqd_obj);\n\t\t\tradeon_bo_unreserve(rdev->ring[idx].mqd_obj);\n\n\t\t\tradeon_bo_unref(&rdev->ring[idx].mqd_obj);\n\t\t\trdev->ring[idx].mqd_obj = NULL;\n\t\t}\n\t}\n}\n\nstatic void cik_mec_fini(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->mec.hpd_eop_obj) {\n\t\tr = radeon_bo_reserve(rdev->mec.hpd_eop_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tdev_warn(rdev->dev, \"(%d) reserve HPD EOP bo failed\\n\", r);\n\t\tradeon_bo_unpin(rdev->mec.hpd_eop_obj);\n\t\tradeon_bo_unreserve(rdev->mec.hpd_eop_obj);\n\n\t\tradeon_bo_unref(&rdev->mec.hpd_eop_obj);\n\t\trdev->mec.hpd_eop_obj = NULL;\n\t}\n}\n\n#define MEC_HPD_SIZE 2048\n\nstatic int cik_mec_init(struct radeon_device *rdev)\n{\n\tint r;\n\tu32 *hpd;\n\n\t \n\tif (rdev->family == CHIP_KAVERI)\n\t\trdev->mec.num_mec = 2;\n\telse\n\t\trdev->mec.num_mec = 1;\n\trdev->mec.num_pipe = 4;\n\trdev->mec.num_queue = rdev->mec.num_mec * rdev->mec.num_pipe * 8;\n\n\tif (rdev->mec.hpd_eop_obj == NULL) {\n\t\tr = radeon_bo_create(rdev,\n\t\t\t\t     rdev->mec.num_mec *rdev->mec.num_pipe * MEC_HPD_SIZE * 2,\n\t\t\t\t     PAGE_SIZE, true,\n\t\t\t\t     RADEON_GEM_DOMAIN_GTT, 0, NULL, NULL,\n\t\t\t\t     &rdev->mec.hpd_eop_obj);\n\t\tif (r) {\n\t\t\tdev_warn(rdev->dev, \"(%d) create HDP EOP bo failed\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = radeon_bo_reserve(rdev->mec.hpd_eop_obj, false);\n\tif (unlikely(r != 0)) {\n\t\tcik_mec_fini(rdev);\n\t\treturn r;\n\t}\n\tr = radeon_bo_pin(rdev->mec.hpd_eop_obj, RADEON_GEM_DOMAIN_GTT,\n\t\t\t  &rdev->mec.hpd_eop_gpu_addr);\n\tif (r) {\n\t\tdev_warn(rdev->dev, \"(%d) pin HDP EOP bo failed\\n\", r);\n\t\tcik_mec_fini(rdev);\n\t\treturn r;\n\t}\n\tr = radeon_bo_kmap(rdev->mec.hpd_eop_obj, (void **)&hpd);\n\tif (r) {\n\t\tdev_warn(rdev->dev, \"(%d) map HDP EOP bo failed\\n\", r);\n\t\tcik_mec_fini(rdev);\n\t\treturn r;\n\t}\n\n\t \n\tmemset(hpd, 0, rdev->mec.num_mec *rdev->mec.num_pipe * MEC_HPD_SIZE * 2);\n\n\tradeon_bo_kunmap(rdev->mec.hpd_eop_obj);\n\tradeon_bo_unreserve(rdev->mec.hpd_eop_obj);\n\n\treturn 0;\n}\n\nstruct hqd_registers\n{\n\tu32 cp_mqd_base_addr;\n\tu32 cp_mqd_base_addr_hi;\n\tu32 cp_hqd_active;\n\tu32 cp_hqd_vmid;\n\tu32 cp_hqd_persistent_state;\n\tu32 cp_hqd_pipe_priority;\n\tu32 cp_hqd_queue_priority;\n\tu32 cp_hqd_quantum;\n\tu32 cp_hqd_pq_base;\n\tu32 cp_hqd_pq_base_hi;\n\tu32 cp_hqd_pq_rptr;\n\tu32 cp_hqd_pq_rptr_report_addr;\n\tu32 cp_hqd_pq_rptr_report_addr_hi;\n\tu32 cp_hqd_pq_wptr_poll_addr;\n\tu32 cp_hqd_pq_wptr_poll_addr_hi;\n\tu32 cp_hqd_pq_doorbell_control;\n\tu32 cp_hqd_pq_wptr;\n\tu32 cp_hqd_pq_control;\n\tu32 cp_hqd_ib_base_addr;\n\tu32 cp_hqd_ib_base_addr_hi;\n\tu32 cp_hqd_ib_rptr;\n\tu32 cp_hqd_ib_control;\n\tu32 cp_hqd_iq_timer;\n\tu32 cp_hqd_iq_rptr;\n\tu32 cp_hqd_dequeue_request;\n\tu32 cp_hqd_dma_offload;\n\tu32 cp_hqd_sema_cmd;\n\tu32 cp_hqd_msg_type;\n\tu32 cp_hqd_atomic0_preop_lo;\n\tu32 cp_hqd_atomic0_preop_hi;\n\tu32 cp_hqd_atomic1_preop_lo;\n\tu32 cp_hqd_atomic1_preop_hi;\n\tu32 cp_hqd_hq_scheduler0;\n\tu32 cp_hqd_hq_scheduler1;\n\tu32 cp_mqd_control;\n};\n\nstruct bonaire_mqd\n{\n\tu32 header;\n\tu32 dispatch_initiator;\n\tu32 dimensions[3];\n\tu32 start_idx[3];\n\tu32 num_threads[3];\n\tu32 pipeline_stat_enable;\n\tu32 perf_counter_enable;\n\tu32 pgm[2];\n\tu32 tba[2];\n\tu32 tma[2];\n\tu32 pgm_rsrc[2];\n\tu32 vmid;\n\tu32 resource_limits;\n\tu32 static_thread_mgmt01[2];\n\tu32 tmp_ring_size;\n\tu32 static_thread_mgmt23[2];\n\tu32 restart[3];\n\tu32 thread_trace_enable;\n\tu32 reserved1;\n\tu32 user_data[16];\n\tu32 vgtcs_invoke_count[2];\n\tstruct hqd_registers queue_state;\n\tu32 dequeue_cntr;\n\tu32 interrupt_queue[64];\n};\n\n \nstatic int cik_cp_compute_resume(struct radeon_device *rdev)\n{\n\tint r, i, j, idx;\n\tu32 tmp;\n\tbool use_doorbell = true;\n\tu64 hqd_gpu_addr;\n\tu64 mqd_gpu_addr;\n\tu64 eop_gpu_addr;\n\tu64 wb_gpu_addr;\n\tu32 *buf;\n\tstruct bonaire_mqd *mqd;\n\n\tr = cik_cp_compute_start(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\ttmp = RREG32(CP_CPF_DEBUG);\n\ttmp |= (1 << 23);\n\tWREG32(CP_CPF_DEBUG, tmp);\n\n\t \n\tmutex_lock(&rdev->srbm_mutex);\n\n\tfor (i = 0; i < (rdev->mec.num_pipe * rdev->mec.num_mec); ++i) {\n\t\tint me = (i < 4) ? 1 : 2;\n\t\tint pipe = (i < 4) ? i : (i - 4);\n\n\t\tcik_srbm_select(rdev, me, pipe, 0, 0);\n\n\t\teop_gpu_addr = rdev->mec.hpd_eop_gpu_addr + (i * MEC_HPD_SIZE * 2) ;\n\t\t \n\t\tWREG32(CP_HPD_EOP_BASE_ADDR, eop_gpu_addr >> 8);\n\t\tWREG32(CP_HPD_EOP_BASE_ADDR_HI, upper_32_bits(eop_gpu_addr) >> 8);\n\n\t\t \n\t\tWREG32(CP_HPD_EOP_VMID, 0);\n\n\t\t \n\t\ttmp = RREG32(CP_HPD_EOP_CONTROL);\n\t\ttmp &= ~EOP_SIZE_MASK;\n\t\ttmp |= order_base_2(MEC_HPD_SIZE / 8);\n\t\tWREG32(CP_HPD_EOP_CONTROL, tmp);\n\n\t}\n\tcik_srbm_select(rdev, 0, 0, 0, 0);\n\tmutex_unlock(&rdev->srbm_mutex);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (i == 0)\n\t\t\tidx = CAYMAN_RING_TYPE_CP1_INDEX;\n\t\telse\n\t\t\tidx = CAYMAN_RING_TYPE_CP2_INDEX;\n\n\t\tif (rdev->ring[idx].mqd_obj == NULL) {\n\t\t\tr = radeon_bo_create(rdev,\n\t\t\t\t\t     sizeof(struct bonaire_mqd),\n\t\t\t\t\t     PAGE_SIZE, true,\n\t\t\t\t\t     RADEON_GEM_DOMAIN_GTT, 0, NULL,\n\t\t\t\t\t     NULL, &rdev->ring[idx].mqd_obj);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(rdev->dev, \"(%d) create MQD bo failed\\n\", r);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tr = radeon_bo_reserve(rdev->ring[idx].mqd_obj, false);\n\t\tif (unlikely(r != 0)) {\n\t\t\tcik_cp_compute_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_pin(rdev->ring[idx].mqd_obj, RADEON_GEM_DOMAIN_GTT,\n\t\t\t\t  &mqd_gpu_addr);\n\t\tif (r) {\n\t\t\tdev_warn(rdev->dev, \"(%d) pin MQD bo failed\\n\", r);\n\t\t\tcik_cp_compute_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_kmap(rdev->ring[idx].mqd_obj, (void **)&buf);\n\t\tif (r) {\n\t\t\tdev_warn(rdev->dev, \"(%d) map MQD bo failed\\n\", r);\n\t\t\tcik_cp_compute_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\n\t\t \n\t\tmemset(buf, 0, sizeof(struct bonaire_mqd));\n\n\t\tmqd = (struct bonaire_mqd *)buf;\n\t\tmqd->header = 0xC0310800;\n\t\tmqd->static_thread_mgmt01[0] = 0xffffffff;\n\t\tmqd->static_thread_mgmt01[1] = 0xffffffff;\n\t\tmqd->static_thread_mgmt23[0] = 0xffffffff;\n\t\tmqd->static_thread_mgmt23[1] = 0xffffffff;\n\n\t\tmutex_lock(&rdev->srbm_mutex);\n\t\tcik_srbm_select(rdev, rdev->ring[idx].me,\n\t\t\t\trdev->ring[idx].pipe,\n\t\t\t\trdev->ring[idx].queue, 0);\n\n\t\t \n\t\ttmp = RREG32(CP_PQ_WPTR_POLL_CNTL);\n\t\ttmp &= ~WPTR_POLL_EN;\n\t\tWREG32(CP_PQ_WPTR_POLL_CNTL, tmp);\n\n\t\t \n\t\tmqd->queue_state.cp_hqd_pq_doorbell_control =\n\t\t\tRREG32(CP_HQD_PQ_DOORBELL_CONTROL);\n\t\tif (use_doorbell)\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control |= DOORBELL_EN;\n\t\telse\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control &= ~DOORBELL_EN;\n\t\tWREG32(CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t       mqd->queue_state.cp_hqd_pq_doorbell_control);\n\n\t\t \n\t\tmqd->queue_state.cp_hqd_dequeue_request = 0;\n\t\tmqd->queue_state.cp_hqd_pq_rptr = 0;\n\t\tmqd->queue_state.cp_hqd_pq_wptr= 0;\n\t\tif (RREG32(CP_HQD_ACTIVE) & 1) {\n\t\t\tWREG32(CP_HQD_DEQUEUE_REQUEST, 1);\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\tif (!(RREG32(CP_HQD_ACTIVE) & 1))\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\tWREG32(CP_HQD_DEQUEUE_REQUEST, mqd->queue_state.cp_hqd_dequeue_request);\n\t\t\tWREG32(CP_HQD_PQ_RPTR, mqd->queue_state.cp_hqd_pq_rptr);\n\t\t\tWREG32(CP_HQD_PQ_WPTR, mqd->queue_state.cp_hqd_pq_wptr);\n\t\t}\n\n\t\t \n\t\tmqd->queue_state.cp_mqd_base_addr = mqd_gpu_addr & 0xfffffffc;\n\t\tmqd->queue_state.cp_mqd_base_addr_hi = upper_32_bits(mqd_gpu_addr);\n\t\tWREG32(CP_MQD_BASE_ADDR, mqd->queue_state.cp_mqd_base_addr);\n\t\tWREG32(CP_MQD_BASE_ADDR_HI, mqd->queue_state.cp_mqd_base_addr_hi);\n\t\t \n\t\tmqd->queue_state.cp_mqd_control = RREG32(CP_MQD_CONTROL);\n\t\tmqd->queue_state.cp_mqd_control &= ~MQD_VMID_MASK;\n\t\tWREG32(CP_MQD_CONTROL, mqd->queue_state.cp_mqd_control);\n\n\t\t \n\t\thqd_gpu_addr = rdev->ring[idx].gpu_addr >> 8;\n\t\tmqd->queue_state.cp_hqd_pq_base = hqd_gpu_addr;\n\t\tmqd->queue_state.cp_hqd_pq_base_hi = upper_32_bits(hqd_gpu_addr);\n\t\tWREG32(CP_HQD_PQ_BASE, mqd->queue_state.cp_hqd_pq_base);\n\t\tWREG32(CP_HQD_PQ_BASE_HI, mqd->queue_state.cp_hqd_pq_base_hi);\n\n\t\t \n\t\tmqd->queue_state.cp_hqd_pq_control = RREG32(CP_HQD_PQ_CONTROL);\n\t\tmqd->queue_state.cp_hqd_pq_control &=\n\t\t\t~(QUEUE_SIZE_MASK | RPTR_BLOCK_SIZE_MASK);\n\n\t\tmqd->queue_state.cp_hqd_pq_control |=\n\t\t\torder_base_2(rdev->ring[idx].ring_size / 8);\n\t\tmqd->queue_state.cp_hqd_pq_control |=\n\t\t\t(order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8);\n#ifdef __BIG_ENDIAN\n\t\tmqd->queue_state.cp_hqd_pq_control |= BUF_SWAP_32BIT;\n#endif\n\t\tmqd->queue_state.cp_hqd_pq_control &=\n\t\t\t~(UNORD_DISPATCH | ROQ_PQ_IB_FLIP | PQ_VOLATILE);\n\t\tmqd->queue_state.cp_hqd_pq_control |=\n\t\t\tPRIV_STATE | KMD_QUEUE;  \n\t\tWREG32(CP_HQD_PQ_CONTROL, mqd->queue_state.cp_hqd_pq_control);\n\n\t\t \n\t\tif (i == 0)\n\t\t\twb_gpu_addr = rdev->wb.gpu_addr + CIK_WB_CP1_WPTR_OFFSET;\n\t\telse\n\t\t\twb_gpu_addr = rdev->wb.gpu_addr + CIK_WB_CP2_WPTR_OFFSET;\n\t\tmqd->queue_state.cp_hqd_pq_wptr_poll_addr = wb_gpu_addr & 0xfffffffc;\n\t\tmqd->queue_state.cp_hqd_pq_wptr_poll_addr_hi = upper_32_bits(wb_gpu_addr) & 0xffff;\n\t\tWREG32(CP_HQD_PQ_WPTR_POLL_ADDR, mqd->queue_state.cp_hqd_pq_wptr_poll_addr);\n\t\tWREG32(CP_HQD_PQ_WPTR_POLL_ADDR_HI,\n\t\t       mqd->queue_state.cp_hqd_pq_wptr_poll_addr_hi);\n\n\t\t \n\t\tif (i == 0)\n\t\t\twb_gpu_addr = rdev->wb.gpu_addr + RADEON_WB_CP1_RPTR_OFFSET;\n\t\telse\n\t\t\twb_gpu_addr = rdev->wb.gpu_addr + RADEON_WB_CP2_RPTR_OFFSET;\n\t\tmqd->queue_state.cp_hqd_pq_rptr_report_addr = wb_gpu_addr & 0xfffffffc;\n\t\tmqd->queue_state.cp_hqd_pq_rptr_report_addr_hi =\n\t\t\tupper_32_bits(wb_gpu_addr) & 0xffff;\n\t\tWREG32(CP_HQD_PQ_RPTR_REPORT_ADDR,\n\t\t       mqd->queue_state.cp_hqd_pq_rptr_report_addr);\n\t\tWREG32(CP_HQD_PQ_RPTR_REPORT_ADDR_HI,\n\t\t       mqd->queue_state.cp_hqd_pq_rptr_report_addr_hi);\n\n\t\t \n\t\tif (use_doorbell) {\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control =\n\t\t\t\tRREG32(CP_HQD_PQ_DOORBELL_CONTROL);\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control &= ~DOORBELL_OFFSET_MASK;\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control |=\n\t\t\t\tDOORBELL_OFFSET(rdev->ring[idx].doorbell_index);\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control |= DOORBELL_EN;\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control &=\n\t\t\t\t~(DOORBELL_SOURCE | DOORBELL_HIT);\n\n\t\t} else {\n\t\t\tmqd->queue_state.cp_hqd_pq_doorbell_control = 0;\n\t\t}\n\t\tWREG32(CP_HQD_PQ_DOORBELL_CONTROL,\n\t\t       mqd->queue_state.cp_hqd_pq_doorbell_control);\n\n\t\t \n\t\trdev->ring[idx].wptr = 0;\n\t\tmqd->queue_state.cp_hqd_pq_wptr = rdev->ring[idx].wptr;\n\t\tWREG32(CP_HQD_PQ_WPTR, mqd->queue_state.cp_hqd_pq_wptr);\n\t\tmqd->queue_state.cp_hqd_pq_rptr = RREG32(CP_HQD_PQ_RPTR);\n\n\t\t \n\t\tmqd->queue_state.cp_hqd_vmid = 0;\n\t\tWREG32(CP_HQD_VMID, mqd->queue_state.cp_hqd_vmid);\n\n\t\t \n\t\tmqd->queue_state.cp_hqd_active = 1;\n\t\tWREG32(CP_HQD_ACTIVE, mqd->queue_state.cp_hqd_active);\n\n\t\tcik_srbm_select(rdev, 0, 0, 0, 0);\n\t\tmutex_unlock(&rdev->srbm_mutex);\n\n\t\tradeon_bo_kunmap(rdev->ring[idx].mqd_obj);\n\t\tradeon_bo_unreserve(rdev->ring[idx].mqd_obj);\n\n\t\trdev->ring[idx].ready = true;\n\t\tr = radeon_ring_test(rdev, idx, &rdev->ring[idx]);\n\t\tif (r)\n\t\t\trdev->ring[idx].ready = false;\n\t}\n\n\treturn 0;\n}\n\nstatic void cik_cp_enable(struct radeon_device *rdev, bool enable)\n{\n\tcik_cp_gfx_enable(rdev, enable);\n\tcik_cp_compute_enable(rdev, enable);\n}\n\nstatic int cik_cp_load_microcode(struct radeon_device *rdev)\n{\n\tint r;\n\n\tr = cik_cp_gfx_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\tr = cik_cp_compute_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void cik_cp_fini(struct radeon_device *rdev)\n{\n\tcik_cp_gfx_fini(rdev);\n\tcik_cp_compute_fini(rdev);\n}\n\nstatic int cik_cp_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\tcik_enable_gui_idle_interrupt(rdev, false);\n\n\tr = cik_cp_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = cik_cp_gfx_resume(rdev);\n\tif (r)\n\t\treturn r;\n\tr = cik_cp_compute_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tcik_enable_gui_idle_interrupt(rdev, true);\n\n\treturn 0;\n}\n\nstatic void cik_print_gpu_status_regs(struct radeon_device *rdev)\n{\n\tdev_info(rdev->dev, \"  GRBM_STATUS=0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS));\n\tdev_info(rdev->dev, \"  GRBM_STATUS2=0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS2));\n\tdev_info(rdev->dev, \"  GRBM_STATUS_SE0=0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS_SE0));\n\tdev_info(rdev->dev, \"  GRBM_STATUS_SE1=0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS_SE1));\n\tdev_info(rdev->dev, \"  GRBM_STATUS_SE2=0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS_SE2));\n\tdev_info(rdev->dev, \"  GRBM_STATUS_SE3=0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS_SE3));\n\tdev_info(rdev->dev, \"  SRBM_STATUS=0x%08X\\n\",\n\t\tRREG32(SRBM_STATUS));\n\tdev_info(rdev->dev, \"  SRBM_STATUS2=0x%08X\\n\",\n\t\tRREG32(SRBM_STATUS2));\n\tdev_info(rdev->dev, \"  SDMA0_STATUS_REG   = 0x%08X\\n\",\n\t\tRREG32(SDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET));\n\tdev_info(rdev->dev, \"  SDMA1_STATUS_REG   = 0x%08X\\n\",\n\t\t RREG32(SDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET));\n\tdev_info(rdev->dev, \"  CP_STAT = 0x%08x\\n\", RREG32(CP_STAT));\n\tdev_info(rdev->dev, \"  CP_STALLED_STAT1 = 0x%08x\\n\",\n\t\t RREG32(CP_STALLED_STAT1));\n\tdev_info(rdev->dev, \"  CP_STALLED_STAT2 = 0x%08x\\n\",\n\t\t RREG32(CP_STALLED_STAT2));\n\tdev_info(rdev->dev, \"  CP_STALLED_STAT3 = 0x%08x\\n\",\n\t\t RREG32(CP_STALLED_STAT3));\n\tdev_info(rdev->dev, \"  CP_CPF_BUSY_STAT = 0x%08x\\n\",\n\t\t RREG32(CP_CPF_BUSY_STAT));\n\tdev_info(rdev->dev, \"  CP_CPF_STALLED_STAT1 = 0x%08x\\n\",\n\t\t RREG32(CP_CPF_STALLED_STAT1));\n\tdev_info(rdev->dev, \"  CP_CPF_STATUS = 0x%08x\\n\", RREG32(CP_CPF_STATUS));\n\tdev_info(rdev->dev, \"  CP_CPC_BUSY_STAT = 0x%08x\\n\", RREG32(CP_CPC_BUSY_STAT));\n\tdev_info(rdev->dev, \"  CP_CPC_STALLED_STAT1 = 0x%08x\\n\",\n\t\t RREG32(CP_CPC_STALLED_STAT1));\n\tdev_info(rdev->dev, \"  CP_CPC_STATUS = 0x%08x\\n\", RREG32(CP_CPC_STATUS));\n}\n\n \nu32 cik_gpu_check_soft_reset(struct radeon_device *rdev)\n{\n\tu32 reset_mask = 0;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(GRBM_STATUS);\n\tif (tmp & (PA_BUSY | SC_BUSY |\n\t\t   BCI_BUSY | SX_BUSY |\n\t\t   TA_BUSY | VGT_BUSY |\n\t\t   DB_BUSY | CB_BUSY |\n\t\t   GDS_BUSY | SPI_BUSY |\n\t\t   IA_BUSY | IA_BUSY_NO_DMA))\n\t\treset_mask |= RADEON_RESET_GFX;\n\n\tif (tmp & (CP_BUSY | CP_COHERENCY_BUSY))\n\t\treset_mask |= RADEON_RESET_CP;\n\n\t \n\ttmp = RREG32(GRBM_STATUS2);\n\tif (tmp & RLC_BUSY)\n\t\treset_mask |= RADEON_RESET_RLC;\n\n\t \n\ttmp = RREG32(SDMA0_STATUS_REG + SDMA0_REGISTER_OFFSET);\n\tif (!(tmp & SDMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\t \n\ttmp = RREG32(SDMA0_STATUS_REG + SDMA1_REGISTER_OFFSET);\n\tif (!(tmp & SDMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA1;\n\n\t \n\ttmp = RREG32(SRBM_STATUS2);\n\tif (tmp & SDMA_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\tif (tmp & SDMA1_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA1;\n\n\t \n\ttmp = RREG32(SRBM_STATUS);\n\n\tif (tmp & IH_BUSY)\n\t\treset_mask |= RADEON_RESET_IH;\n\n\tif (tmp & SEM_BUSY)\n\t\treset_mask |= RADEON_RESET_SEM;\n\n\tif (tmp & GRBM_RQ_PENDING)\n\t\treset_mask |= RADEON_RESET_GRBM;\n\n\tif (tmp & VMC_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\tif (tmp & (MCB_BUSY | MCB_NON_DISPLAY_BUSY |\n\t\t   MCC_BUSY | MCD_BUSY))\n\t\treset_mask |= RADEON_RESET_MC;\n\n\tif (evergreen_is_display_hung(rdev))\n\t\treset_mask |= RADEON_RESET_DISPLAY;\n\n\t \n\tif (reset_mask & RADEON_RESET_MC) {\n\t\tDRM_DEBUG(\"MC busy: 0x%08X, clearing.\\n\", reset_mask);\n\t\treset_mask &= ~RADEON_RESET_MC;\n\t}\n\n\treturn reset_mask;\n}\n\n \nstatic void cik_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)\n{\n\tstruct evergreen_mc_save save;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif (reset_mask == 0)\n\t\treturn;\n\n\tdev_info(rdev->dev, \"GPU softreset: 0x%08X\\n\", reset_mask);\n\n\tcik_print_gpu_status_regs(rdev);\n\tdev_info(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR));\n\tdev_info(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS));\n\n\t \n\tcik_fini_pg(rdev);\n\tcik_fini_cg(rdev);\n\n\t \n\tcik_rlc_stop(rdev);\n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT | CP_CE_HALT);\n\n\t \n\tWREG32(CP_MEC_CNTL, MEC_ME1_HALT | MEC_ME2_HALT);\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\t \n\t\ttmp = RREG32(SDMA0_ME_CNTL + SDMA0_REGISTER_OFFSET);\n\t\ttmp |= SDMA_HALT;\n\t\tWREG32(SDMA0_ME_CNTL + SDMA0_REGISTER_OFFSET, tmp);\n\t}\n\tif (reset_mask & RADEON_RESET_DMA1) {\n\t\t \n\t\ttmp = RREG32(SDMA0_ME_CNTL + SDMA1_REGISTER_OFFSET);\n\t\ttmp |= SDMA_HALT;\n\t\tWREG32(SDMA0_ME_CNTL + SDMA1_REGISTER_OFFSET, tmp);\n\t}\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\n\tif (reset_mask & (RADEON_RESET_GFX | RADEON_RESET_COMPUTE | RADEON_RESET_CP))\n\t\tgrbm_soft_reset = SOFT_RESET_CP | SOFT_RESET_GFX;\n\n\tif (reset_mask & RADEON_RESET_CP) {\n\t\tgrbm_soft_reset |= SOFT_RESET_CP;\n\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA)\n\t\tsrbm_soft_reset |= SOFT_RESET_SDMA;\n\n\tif (reset_mask & RADEON_RESET_DMA1)\n\t\tsrbm_soft_reset |= SOFT_RESET_SDMA1;\n\n\tif (reset_mask & RADEON_RESET_DISPLAY)\n\t\tsrbm_soft_reset |= SOFT_RESET_DC;\n\n\tif (reset_mask & RADEON_RESET_RLC)\n\t\tgrbm_soft_reset |= SOFT_RESET_RLC;\n\n\tif (reset_mask & RADEON_RESET_SEM)\n\t\tsrbm_soft_reset |= SOFT_RESET_SEM;\n\n\tif (reset_mask & RADEON_RESET_IH)\n\t\tsrbm_soft_reset |= SOFT_RESET_IH;\n\n\tif (reset_mask & RADEON_RESET_GRBM)\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\n\tif (reset_mask & RADEON_RESET_VMC)\n\t\tsrbm_soft_reset |= SOFT_RESET_VMC;\n\n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tif (reset_mask & RADEON_RESET_MC)\n\t\t\tsrbm_soft_reset |= SOFT_RESET_MC;\n\t}\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(rdev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(rdev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t}\n\n\t \n\tudelay(50);\n\n\tevergreen_mc_resume(rdev, &save);\n\tudelay(50);\n\n\tcik_print_gpu_status_regs(rdev);\n}\n\nstruct kv_reset_save_regs {\n\tu32 gmcon_reng_execute;\n\tu32 gmcon_misc;\n\tu32 gmcon_misc3;\n};\n\nstatic void kv_save_regs_for_reset(struct radeon_device *rdev,\n\t\t\t\t   struct kv_reset_save_regs *save)\n{\n\tsave->gmcon_reng_execute = RREG32(GMCON_RENG_EXECUTE);\n\tsave->gmcon_misc = RREG32(GMCON_MISC);\n\tsave->gmcon_misc3 = RREG32(GMCON_MISC3);\n\n\tWREG32(GMCON_RENG_EXECUTE, save->gmcon_reng_execute & ~RENG_EXECUTE_ON_PWR_UP);\n\tWREG32(GMCON_MISC, save->gmcon_misc & ~(RENG_EXECUTE_ON_REG_UPDATE |\n\t\t\t\t\t\tSTCTRL_STUTTER_EN));\n}\n\nstatic void kv_restore_regs_for_reset(struct radeon_device *rdev,\n\t\t\t\t      struct kv_reset_save_regs *save)\n{\n\tint i;\n\n\tWREG32(GMCON_PGFSM_WRITE, 0);\n\tWREG32(GMCON_PGFSM_CONFIG, 0x200010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0);\n\tWREG32(GMCON_PGFSM_CONFIG, 0x300010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x210000);\n\tWREG32(GMCON_PGFSM_CONFIG, 0xa00010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x21003);\n\tWREG32(GMCON_PGFSM_CONFIG, 0xb00010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x2b00);\n\tWREG32(GMCON_PGFSM_CONFIG, 0xc00010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0);\n\tWREG32(GMCON_PGFSM_CONFIG, 0xd00010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x420000);\n\tWREG32(GMCON_PGFSM_CONFIG, 0x100010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x120202);\n\tWREG32(GMCON_PGFSM_CONFIG, 0x500010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x3e3e36);\n\tWREG32(GMCON_PGFSM_CONFIG, 0x600010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x373f3e);\n\tWREG32(GMCON_PGFSM_CONFIG, 0x700010ff);\n\n\tfor (i = 0; i < 5; i++)\n\t\tWREG32(GMCON_PGFSM_WRITE, 0);\n\n\tWREG32(GMCON_PGFSM_WRITE, 0x3e1332);\n\tWREG32(GMCON_PGFSM_CONFIG, 0xe00010ff);\n\n\tWREG32(GMCON_MISC3, save->gmcon_misc3);\n\tWREG32(GMCON_MISC, save->gmcon_misc);\n\tWREG32(GMCON_RENG_EXECUTE, save->gmcon_reng_execute);\n}\n\nstatic void cik_gpu_pci_config_reset(struct radeon_device *rdev)\n{\n\tstruct evergreen_mc_save save;\n\tstruct kv_reset_save_regs kv_save = { 0 };\n\tu32 tmp, i;\n\n\tdev_info(rdev->dev, \"GPU pci config reset\\n\");\n\n\t \n\n\t \n\tcik_fini_pg(rdev);\n\tcik_fini_cg(rdev);\n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT | CP_CE_HALT);\n\n\t \n\tWREG32(CP_MEC_CNTL, MEC_ME1_HALT | MEC_ME2_HALT);\n\n\t \n\ttmp = RREG32(SDMA0_ME_CNTL + SDMA0_REGISTER_OFFSET);\n\ttmp |= SDMA_HALT;\n\tWREG32(SDMA0_ME_CNTL + SDMA0_REGISTER_OFFSET, tmp);\n\t \n\ttmp = RREG32(SDMA0_ME_CNTL + SDMA1_REGISTER_OFFSET);\n\ttmp |= SDMA_HALT;\n\tWREG32(SDMA0_ME_CNTL + SDMA1_REGISTER_OFFSET, tmp);\n\t \n\n\t \n\tcik_rlc_stop(rdev);\n\n\tudelay(50);\n\n\t \n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timed out !\\n\");\n\t}\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tkv_save_regs_for_reset(rdev, &kv_save);\n\n\t \n\tpci_clear_master(rdev->pdev);\n\t \n\tradeon_pci_config_reset(rdev);\n\n\tudelay(100);\n\n\t \n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(CONFIG_MEMSIZE) != 0xffffffff)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tkv_restore_regs_for_reset(rdev, &kv_save);\n}\n\n \nint cik_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tu32 reset_mask;\n\n\tif (hard) {\n\t\tcik_gpu_pci_config_reset(rdev);\n\t\treturn 0;\n\t}\n\n\treset_mask = cik_gpu_check_soft_reset(rdev);\n\n\tif (reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, true);\n\n\t \n\tcik_gpu_soft_reset(rdev, reset_mask);\n\n\treset_mask = cik_gpu_check_soft_reset(rdev);\n\n\t \n\tif (reset_mask && radeon_hard_reset)\n\t\tcik_gpu_pci_config_reset(rdev);\n\n\treset_mask = cik_gpu_check_soft_reset(rdev);\n\n\tif (!reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, false);\n\n\treturn 0;\n}\n\n \nbool cik_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = cik_gpu_check_soft_reset(rdev);\n\n\tif (!(reset_mask & (RADEON_RESET_GFX |\n\t\t\t    RADEON_RESET_COMPUTE |\n\t\t\t    RADEON_RESET_CP))) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\n \n \nstatic void cik_mc_program(struct radeon_device *rdev)\n{\n\tstruct evergreen_mc_save save;\n\tu32 tmp;\n\tint i, j;\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\tWREG32(HDP_REG_COHERENCY_FLUSH_CNTL, 0);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (radeon_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\t \n\tWREG32(VGA_HDP_CONTROL, VGA_MEMORY_DISABLE);\n\t \n\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t       rdev->mc.vram_start >> 12);\n\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t       rdev->mc.vram_end >> 12);\n\tWREG32(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR,\n\t       rdev->vram_scratch.gpu_addr >> 12);\n\ttmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;\n\ttmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);\n\tWREG32(MC_VM_FB_LOCATION, tmp);\n\t \n\tWREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));\n\tWREG32(HDP_NONSURFACE_INFO, (2 << 7) | (1 << 30));\n\tWREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);\n\tWREG32(MC_VM_AGP_BASE, 0);\n\tWREG32(MC_VM_AGP_TOP, 0x0FFFFFFF);\n\tWREG32(MC_VM_AGP_BOT, 0x0FFFFFFF);\n\tif (radeon_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\tevergreen_mc_resume(rdev, &save);\n\t \n\trv515_vga_render_disable(rdev);\n}\n\n \nstatic int cik_mc_init(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint chansize, numchan;\n\n\t \n\trdev->mc.vram_is_ddr = true;\n\ttmp = RREG32(MC_ARB_RAMCFG);\n\tif (tmp & CHANSIZE_MASK) {\n\t\tchansize = 64;\n\t} else {\n\t\tchansize = 32;\n\t}\n\ttmp = RREG32(MC_SHARED_CHMAP);\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\tnumchan = 1;\n\t\tbreak;\n\tcase 1:\n\t\tnumchan = 2;\n\t\tbreak;\n\tcase 2:\n\t\tnumchan = 4;\n\t\tbreak;\n\tcase 3:\n\t\tnumchan = 8;\n\t\tbreak;\n\tcase 4:\n\t\tnumchan = 3;\n\t\tbreak;\n\tcase 5:\n\t\tnumchan = 6;\n\t\tbreak;\n\tcase 6:\n\t\tnumchan = 10;\n\t\tbreak;\n\tcase 7:\n\t\tnumchan = 12;\n\t\tbreak;\n\tcase 8:\n\t\tnumchan = 16;\n\t\tbreak;\n\t}\n\trdev->mc.vram_width = numchan * chansize;\n\t \n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\t \n\trdev->mc.mc_vram_size = RREG32(CONFIG_MEMSIZE) * 1024ULL * 1024ULL;\n\trdev->mc.real_vram_size = RREG32(CONFIG_MEMSIZE) * 1024ULL * 1024ULL;\n\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\tsi_vram_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n\n\treturn 0;\n}\n\n \n \nvoid cik_pcie_gart_tlb_flush(struct radeon_device *rdev)\n{\n\t \n\tWREG32(HDP_MEM_COHERENCY_FLUSH_CNTL, 0);\n\n\t \n\tWREG32(VM_INVALIDATE_REQUEST, 0x1);\n}\n\n \nstatic int cik_pcie_gart_enable(struct radeon_device *rdev)\n{\n\tint r, i;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tWREG32(MC_VM_MX_L1_TLB_CNTL,\n\t       (0xA << 7) |\n\t       ENABLE_L1_TLB |\n\t       ENABLE_L1_FRAGMENT_PROCESSING |\n\t       SYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t       ENABLE_ADVANCED_DRIVER_MODEL |\n\t       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE |\n\t       ENABLE_L2_FRAGMENT_PROCESSING |\n\t       ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |\n\t       EFFECTIVE_L2_QUEUE_SIZE(7) |\n\t       CONTEXT1_IDENTITY_ACCESS_MODE(1));\n\tWREG32(VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS | INVALIDATE_L2_CACHE);\n\tWREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |\n\t       BANK_SELECT(4) |\n\t       L2_CACHE_BIGK_FRAGMENT_SIZE(4));\n\t \n\tWREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev->gart.table_addr >> 12);\n\tWREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,\n\t\t\t(u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT0_CNTL2, 0);\n\tWREG32(VM_CONTEXT0_CNTL, (ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |\n\t\t\t\t  RANGE_PROTECTION_FAULT_ENABLE_DEFAULT));\n\n\tWREG32(0x15D4, 0);\n\tWREG32(0x15D8, 0);\n\tWREG32(0x15DC, 0);\n\n\t \n\t \n\tWREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);\n\tWREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev->vm_manager.max_pfn - 1);\n\tfor (i = 1; i < 16; i++) {\n\t\tif (i < 8)\n\t\t\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2),\n\t\t\t       rdev->vm_manager.saved_table_addr[i]);\n\t\telse\n\t\t\tWREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((i - 8) << 2),\n\t\t\t       rdev->vm_manager.saved_table_addr[i]);\n\t}\n\n\t \n\tWREG32(VM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,\n\t       (u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT1_CNTL2, 4);\n\tWREG32(VM_CONTEXT1_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(1) |\n\t\t\t\tPAGE_TABLE_BLOCK_SIZE(radeon_vm_block_size - 9) |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tDUMMY_PAGE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tDUMMY_PAGE_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tPDE0_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tPDE0_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tVALID_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tVALID_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tREAD_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tREAD_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tWRITE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tWRITE_PROTECTION_FAULT_ENABLE_DEFAULT);\n\n\tif (rdev->family == CHIP_KAVERI) {\n\t\tu32 tmp = RREG32(CHUB_CONTROL);\n\t\ttmp &= ~BYPASS_VM;\n\t\tWREG32(CHUB_CONTROL, tmp);\n\t}\n\n\t \n\t \n\tmutex_lock(&rdev->srbm_mutex);\n\tfor (i = 0; i < 16; i++) {\n\t\tcik_srbm_select(rdev, 0, 0, 0, i);\n\t\t \n\t\tWREG32(SH_MEM_CONFIG, SH_MEM_CONFIG_GFX_DEFAULT);\n\t\tWREG32(SH_MEM_APE1_BASE, 1);\n\t\tWREG32(SH_MEM_APE1_LIMIT, 0);\n\t\tWREG32(SH_MEM_BASES, 0);\n\t\t \n\t\tWREG32(SDMA0_GFX_VIRTUAL_ADDR + SDMA0_REGISTER_OFFSET, 0);\n\t\tWREG32(SDMA0_GFX_APE1_CNTL + SDMA0_REGISTER_OFFSET, 0);\n\t\tWREG32(SDMA0_GFX_VIRTUAL_ADDR + SDMA1_REGISTER_OFFSET, 0);\n\t\tWREG32(SDMA0_GFX_APE1_CNTL + SDMA1_REGISTER_OFFSET, 0);\n\t\t \n\t}\n\tcik_srbm_select(rdev, 0, 0, 0, 0);\n\tmutex_unlock(&rdev->srbm_mutex);\n\n\tcik_pcie_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\n \nstatic void cik_pcie_gart_disable(struct radeon_device *rdev)\n{\n\tunsigned i;\n\n\tfor (i = 1; i < 16; ++i) {\n\t\tuint32_t reg;\n\t\tif (i < 8)\n\t\t\treg = VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2);\n\t\telse\n\t\t\treg = VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((i - 8) << 2);\n\t\trdev->vm_manager.saved_table_addr[i] = RREG32(reg);\n\t}\n\n\t \n\tWREG32(VM_CONTEXT0_CNTL, 0);\n\tWREG32(VM_CONTEXT1_CNTL, 0);\n\t \n\tWREG32(MC_VM_MX_L1_TLB_CNTL, SYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);\n\t \n\tWREG32(VM_L2_CNTL,\n\t       ENABLE_L2_FRAGMENT_PROCESSING |\n\t       ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |\n\t       EFFECTIVE_L2_QUEUE_SIZE(7) |\n\t       CONTEXT1_IDENTITY_ACCESS_MODE(1));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |\n\t       L2_CACHE_BIGK_FRAGMENT_SIZE(6));\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\n \nstatic void cik_pcie_gart_fini(struct radeon_device *rdev)\n{\n\tcik_pcie_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n\tradeon_gart_fini(rdev);\n}\n\n \n \nint cik_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\treturn 0;\n}\n\n \n \nint cik_vm_init(struct radeon_device *rdev)\n{\n\t \n\trdev->vm_manager.nvm = 16;\n\t \n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tu64 tmp = RREG32(MC_VM_FB_OFFSET);\n\t\ttmp <<= 22;\n\t\trdev->vm_manager.vram_base_offset = tmp;\n\t} else\n\t\trdev->vm_manager.vram_base_offset = 0;\n\n\treturn 0;\n}\n\n \nvoid cik_vm_fini(struct radeon_device *rdev)\n{\n}\n\n \nstatic void cik_vm_decode_fault(struct radeon_device *rdev,\n\t\t\t\tu32 status, u32 addr, u32 mc_client)\n{\n\tu32 mc_id;\n\tu32 vmid = (status & FAULT_VMID_MASK) >> FAULT_VMID_SHIFT;\n\tu32 protections = (status & PROTECTIONS_MASK) >> PROTECTIONS_SHIFT;\n\tchar block[5] = { mc_client >> 24, (mc_client >> 16) & 0xff,\n\t\t(mc_client >> 8) & 0xff, mc_client & 0xff, 0 };\n\n\tif (rdev->family == CHIP_HAWAII)\n\t\tmc_id = (status & HAWAII_MEMORY_CLIENT_ID_MASK) >> MEMORY_CLIENT_ID_SHIFT;\n\telse\n\t\tmc_id = (status & MEMORY_CLIENT_ID_MASK) >> MEMORY_CLIENT_ID_SHIFT;\n\n\tprintk(\"VM fault (0x%02x, vmid %d) at page %u, %s from '%s' (0x%08x) (%d)\\n\",\n\t       protections, vmid, addr,\n\t       (status & MEMORY_CLIENT_RW_MASK) ? \"write\" : \"read\",\n\t       block, mc_client, mc_id);\n}\n\n \nvoid cik_vm_flush(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t  unsigned vm_id, uint64_t pd_addr)\n{\n\tint usepfp = (ring->idx == RADEON_RING_TYPE_GFX_INDEX);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(usepfp) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tif (vm_id < 8) {\n\t\tradeon_ring_write(ring,\n\t\t\t\t  (VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (vm_id << 2)) >> 2);\n\t} else {\n\t\tradeon_ring_write(ring,\n\t\t\t\t  (VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((vm_id - 8) << 2)) >> 2);\n\t}\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, pd_addr >> 12);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(usepfp) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tradeon_ring_write(ring, SRBM_GFX_CNTL >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, VMID(vm_id));\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 6));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(usepfp) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tradeon_ring_write(ring, SH_MEM_BASES >> 2);\n\tradeon_ring_write(ring, 0);\n\n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, SH_MEM_CONFIG_GFX_DEFAULT);  \n\tradeon_ring_write(ring, 1);  \n\tradeon_ring_write(ring, 0);  \n\n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(usepfp) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tradeon_ring_write(ring, SRBM_GFX_CNTL >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, VMID(0));\n\n\t \n\tcik_hdp_flush_cp_ring_emit(rdev, ring->idx);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WRITE_DATA, 3));\n\tradeon_ring_write(ring, (WRITE_DATA_ENGINE_SEL(usepfp) |\n\t\t\t\t WRITE_DATA_DST_SEL(0)));\n\tradeon_ring_write(ring, VM_INVALIDATE_REQUEST >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 1 << vm_id);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tradeon_ring_write(ring, (WAIT_REG_MEM_OPERATION(0) |  \n\t\t\t\t WAIT_REG_MEM_FUNCTION(0) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(0)));  \n\tradeon_ring_write(ring, VM_INVALIDATE_REQUEST >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, 0x20);  \n\n\t \n\tif (usepfp) {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tradeon_ring_write(ring, 0x0);\n\t}\n}\n\n \nstatic void cik_enable_gui_idle_interrupt(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tu32 tmp = RREG32(CP_INT_CNTL_RING0);\n\n\tif (enable)\n\t\ttmp |= (CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\telse\n\t\ttmp &= ~(CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\tWREG32(CP_INT_CNTL_RING0, tmp);\n}\n\nstatic void cik_enable_lbpw(struct radeon_device *rdev, bool enable)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(RLC_LB_CNTL);\n\tif (enable)\n\t\ttmp |= LOAD_BALANCE_ENABLE;\n\telse\n\t\ttmp &= ~LOAD_BALANCE_ENABLE;\n\tWREG32(RLC_LB_CNTL, tmp);\n}\n\nstatic void cik_wait_for_rlc_serdes(struct radeon_device *rdev)\n{\n\tu32 i, j, k;\n\tu32 mask;\n\n\tfor (i = 0; i < rdev->config.cik.max_shader_engines; i++) {\n\t\tfor (j = 0; j < rdev->config.cik.max_sh_per_se; j++) {\n\t\t\tcik_select_se_sh(rdev, i, j);\n\t\t\tfor (k = 0; k < rdev->usec_timeout; k++) {\n\t\t\t\tif (RREG32(RLC_SERDES_CU_MASTER_BUSY) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\n\tmask = SE_MASTER_BUSY_MASK | GC_MASTER_BUSY | TC0_MASTER_BUSY | TC1_MASTER_BUSY;\n\tfor (k = 0; k < rdev->usec_timeout; k++) {\n\t\tif ((RREG32(RLC_SERDES_NONCU_MASTER_BUSY) & mask) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void cik_update_rlc(struct radeon_device *rdev, u32 rlc)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(RLC_CNTL);\n\tif (tmp != rlc)\n\t\tWREG32(RLC_CNTL, rlc);\n}\n\nstatic u32 cik_halt_rlc(struct radeon_device *rdev)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_CNTL);\n\n\tif (data & RLC_ENABLE) {\n\t\tu32 i;\n\n\t\tdata &= ~RLC_ENABLE;\n\t\tWREG32(RLC_CNTL, data);\n\n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif ((RREG32(RLC_GPM_STAT) & RLC_GPM_BUSY) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tcik_wait_for_rlc_serdes(rdev);\n\t}\n\n\treturn orig;\n}\n\nvoid cik_enter_rlc_safe_mode(struct radeon_device *rdev)\n{\n\tu32 tmp, i, mask;\n\n\ttmp = REQ | MESSAGE(MSG_ENTER_RLC_SAFE_MODE);\n\tWREG32(RLC_GPR_REG2, tmp);\n\n\tmask = GFX_POWER_STATUS | GFX_CLOCK_STATUS;\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(RLC_GPM_STAT) & mask) == mask)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(RLC_GPR_REG2) & REQ) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nvoid cik_exit_rlc_safe_mode(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = REQ | MESSAGE(MSG_EXIT_RLC_SAFE_MODE);\n\tWREG32(RLC_GPR_REG2, tmp);\n}\n\n \nstatic void cik_rlc_stop(struct radeon_device *rdev)\n{\n\tWREG32(RLC_CNTL, 0);\n\n\tcik_enable_gui_idle_interrupt(rdev, false);\n\n\tcik_wait_for_rlc_serdes(rdev);\n}\n\n \nstatic void cik_rlc_start(struct radeon_device *rdev)\n{\n\tWREG32(RLC_CNTL, RLC_ENABLE);\n\n\tcik_enable_gui_idle_interrupt(rdev, true);\n\n\tudelay(50);\n}\n\n \nstatic int cik_rlc_resume(struct radeon_device *rdev)\n{\n\tu32 i, size, tmp;\n\n\tif (!rdev->rlc_fw)\n\t\treturn -EINVAL;\n\n\tcik_rlc_stop(rdev);\n\n\t \n\ttmp = RREG32(RLC_CGCG_CGLS_CTRL) & 0xfffffffc;\n\tWREG32(RLC_CGCG_CGLS_CTRL, tmp);\n\n\tsi_rlc_reset(rdev);\n\n\tcik_init_pg(rdev);\n\n\tcik_init_cg(rdev);\n\n\tWREG32(RLC_LB_CNTR_INIT, 0);\n\tWREG32(RLC_LB_CNTR_MAX, 0x00008000);\n\n\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\tWREG32(RLC_LB_INIT_CU_MASK, 0xffffffff);\n\tWREG32(RLC_LB_PARAMS, 0x00600408);\n\tWREG32(RLC_LB_CNTL, 0x80000004);\n\n\tWREG32(RLC_MC_CNTL, 0);\n\tWREG32(RLC_UCODE_CNTL, 0);\n\n\tif (rdev->new_fw) {\n\t\tconst struct rlc_firmware_header_v1_0 *hdr =\n\t\t\t(const struct rlc_firmware_header_v1_0 *)rdev->rlc_fw->data;\n\t\tconst __le32 *fw_data = (const __le32 *)\n\t\t\t(rdev->rlc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\n\t\tradeon_ucode_print_rlc_hdr(&hdr->header);\n\n\t\tsize = le32_to_cpu(hdr->header.ucode_size_bytes) / 4;\n\t\tWREG32(RLC_GPM_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tWREG32(RLC_GPM_UCODE_DATA, le32_to_cpup(fw_data++));\n\t\tWREG32(RLC_GPM_UCODE_ADDR, le32_to_cpu(hdr->header.ucode_version));\n\t} else {\n\t\tconst __be32 *fw_data;\n\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_BONAIRE:\n\t\tcase CHIP_HAWAII:\n\t\tdefault:\n\t\t\tsize = BONAIRE_RLC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_KAVERI:\n\t\t\tsize = KV_RLC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_KABINI:\n\t\t\tsize = KB_RLC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_MULLINS:\n\t\t\tsize = ML_RLC_UCODE_SIZE;\n\t\t\tbreak;\n\t\t}\n\n\t\tfw_data = (const __be32 *)rdev->rlc_fw->data;\n\t\tWREG32(RLC_GPM_UCODE_ADDR, 0);\n\t\tfor (i = 0; i < size; i++)\n\t\t\tWREG32(RLC_GPM_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\tWREG32(RLC_GPM_UCODE_ADDR, 0);\n\t}\n\n\t \n\tcik_enable_lbpw(rdev, false);\n\n\tif (rdev->family == CHIP_BONAIRE)\n\t\tWREG32(RLC_DRIVER_DMA_STATUS, 0);\n\n\tcik_rlc_start(rdev);\n\n\treturn 0;\n}\n\nstatic void cik_enable_cgcg(struct radeon_device *rdev, bool enable)\n{\n\tu32 data, orig, tmp, tmp2;\n\n\torig = data = RREG32(RLC_CGCG_CGLS_CTRL);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_CGCG)) {\n\t\tcik_enable_gui_idle_interrupt(rdev, true);\n\n\t\ttmp = cik_halt_rlc(rdev);\n\n\t\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\t\ttmp2 = BPM_ADDR_MASK | CGCG_OVERRIDE_0 | CGLS_ENABLE;\n\t\tWREG32(RLC_SERDES_WR_CTRL, tmp2);\n\n\t\tcik_update_rlc(rdev, tmp);\n\n\t\tdata |= CGCG_EN | CGLS_EN;\n\t} else {\n\t\tcik_enable_gui_idle_interrupt(rdev, false);\n\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\t\tRREG32(CB_CGTT_SCLK_CTRL);\n\n\t\tdata &= ~(CGCG_EN | CGLS_EN);\n\t}\n\n\tif (orig != data)\n\t\tWREG32(RLC_CGCG_CGLS_CTRL, data);\n\n}\n\nstatic void cik_enable_mgcg(struct radeon_device *rdev, bool enable)\n{\n\tu32 data, orig, tmp = 0;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_MGCG)) {\n\t\tif (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_MGLS) {\n\t\t\tif (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_CP_LS) {\n\t\t\t\torig = data = RREG32(CP_MEM_SLP_CNTL);\n\t\t\t\tdata |= CP_MEM_LS_EN;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32(CP_MEM_SLP_CNTL, data);\n\t\t\t}\n\t\t}\n\n\t\torig = data = RREG32(RLC_CGTT_MGCG_OVERRIDE);\n\t\tdata |= 0x00000001;\n\t\tdata &= 0xfffffffd;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\ttmp = cik_halt_rlc(rdev);\n\n\t\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\t\tdata = BPM_ADDR_MASK | MGCG_OVERRIDE_0;\n\t\tWREG32(RLC_SERDES_WR_CTRL, data);\n\n\t\tcik_update_rlc(rdev, tmp);\n\n\t\tif (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_CGTS) {\n\t\t\torig = data = RREG32(CGTS_SM_CTRL_REG);\n\t\t\tdata &= ~SM_MODE_MASK;\n\t\t\tdata |= SM_MODE(0x2);\n\t\t\tdata |= SM_MODE_ENABLE;\n\t\t\tdata &= ~CGTS_OVERRIDE;\n\t\t\tif ((rdev->cg_flags & RADEON_CG_SUPPORT_GFX_MGLS) &&\n\t\t\t    (rdev->cg_flags & RADEON_CG_SUPPORT_GFX_CGTS_LS))\n\t\t\t\tdata &= ~CGTS_LS_OVERRIDE;\n\t\t\tdata &= ~ON_MONITOR_ADD_MASK;\n\t\t\tdata |= ON_MONITOR_ADD_EN;\n\t\t\tdata |= ON_MONITOR_ADD(0x96);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32(CGTS_SM_CTRL_REG, data);\n\t\t}\n\t} else {\n\t\torig = data = RREG32(RLC_CGTT_MGCG_OVERRIDE);\n\t\tdata |= 0x00000003;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_CGTT_MGCG_OVERRIDE, data);\n\n\t\tdata = RREG32(RLC_MEM_SLP_CNTL);\n\t\tif (data & RLC_MEM_LS_EN) {\n\t\t\tdata &= ~RLC_MEM_LS_EN;\n\t\t\tWREG32(RLC_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\tdata = RREG32(CP_MEM_SLP_CNTL);\n\t\tif (data & CP_MEM_LS_EN) {\n\t\t\tdata &= ~CP_MEM_LS_EN;\n\t\t\tWREG32(CP_MEM_SLP_CNTL, data);\n\t\t}\n\n\t\torig = data = RREG32(CGTS_SM_CTRL_REG);\n\t\tdata |= CGTS_OVERRIDE | CGTS_LS_OVERRIDE;\n\t\tif (orig != data)\n\t\t\tWREG32(CGTS_SM_CTRL_REG, data);\n\n\t\ttmp = cik_halt_rlc(rdev);\n\n\t\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_CU_MASTER_MASK, 0xffffffff);\n\t\tWREG32(RLC_SERDES_WR_NONCU_MASTER_MASK, 0xffffffff);\n\t\tdata = BPM_ADDR_MASK | MGCG_OVERRIDE_1;\n\t\tWREG32(RLC_SERDES_WR_CTRL, data);\n\n\t\tcik_update_rlc(rdev, tmp);\n\t}\n}\n\nstatic const u32 mc_cg_registers[] =\n{\n\tMC_HUB_MISC_HUB_CG,\n\tMC_HUB_MISC_SIP_CG,\n\tMC_HUB_MISC_VM_CG,\n\tMC_XPB_CLK_GAT,\n\tATC_MISC_CG,\n\tMC_CITF_MISC_WR_CG,\n\tMC_CITF_MISC_RD_CG,\n\tMC_CITF_MISC_VM_CG,\n\tVM_L2_CG,\n};\n\nstatic void cik_enable_mc_ls(struct radeon_device *rdev,\n\t\t\t     bool enable)\n{\n\tint i;\n\tu32 orig, data;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_cg_registers); i++) {\n\t\torig = data = RREG32(mc_cg_registers[i]);\n\t\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_MC_LS))\n\t\t\tdata |= MC_LS_ENABLE;\n\t\telse\n\t\t\tdata &= ~MC_LS_ENABLE;\n\t\tif (data != orig)\n\t\t\tWREG32(mc_cg_registers[i], data);\n\t}\n}\n\nstatic void cik_enable_mc_mgcg(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tint i;\n\tu32 orig, data;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc_cg_registers); i++) {\n\t\torig = data = RREG32(mc_cg_registers[i]);\n\t\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_MC_MGCG))\n\t\t\tdata |= MC_CG_ENABLE;\n\t\telse\n\t\t\tdata &= ~MC_CG_ENABLE;\n\t\tif (data != orig)\n\t\t\tWREG32(mc_cg_registers[i], data);\n\t}\n}\n\nstatic void cik_enable_sdma_mgcg(struct radeon_device *rdev,\n\t\t\t\t bool enable)\n{\n\tu32 orig, data;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_SDMA_MGCG)) {\n\t\tWREG32(SDMA0_CLK_CTRL + SDMA0_REGISTER_OFFSET, 0x00000100);\n\t\tWREG32(SDMA0_CLK_CTRL + SDMA1_REGISTER_OFFSET, 0x00000100);\n\t} else {\n\t\torig = data = RREG32(SDMA0_CLK_CTRL + SDMA0_REGISTER_OFFSET);\n\t\tdata |= 0xff000000;\n\t\tif (data != orig)\n\t\t\tWREG32(SDMA0_CLK_CTRL + SDMA0_REGISTER_OFFSET, data);\n\n\t\torig = data = RREG32(SDMA0_CLK_CTRL + SDMA1_REGISTER_OFFSET);\n\t\tdata |= 0xff000000;\n\t\tif (data != orig)\n\t\t\tWREG32(SDMA0_CLK_CTRL + SDMA1_REGISTER_OFFSET, data);\n\t}\n}\n\nstatic void cik_enable_sdma_mgls(struct radeon_device *rdev,\n\t\t\t\t bool enable)\n{\n\tu32 orig, data;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_SDMA_LS)) {\n\t\torig = data = RREG32(SDMA0_POWER_CNTL + SDMA0_REGISTER_OFFSET);\n\t\tdata |= 0x100;\n\t\tif (orig != data)\n\t\t\tWREG32(SDMA0_POWER_CNTL + SDMA0_REGISTER_OFFSET, data);\n\n\t\torig = data = RREG32(SDMA0_POWER_CNTL + SDMA1_REGISTER_OFFSET);\n\t\tdata |= 0x100;\n\t\tif (orig != data)\n\t\t\tWREG32(SDMA0_POWER_CNTL + SDMA1_REGISTER_OFFSET, data);\n\t} else {\n\t\torig = data = RREG32(SDMA0_POWER_CNTL + SDMA0_REGISTER_OFFSET);\n\t\tdata &= ~0x100;\n\t\tif (orig != data)\n\t\t\tWREG32(SDMA0_POWER_CNTL + SDMA0_REGISTER_OFFSET, data);\n\n\t\torig = data = RREG32(SDMA0_POWER_CNTL + SDMA1_REGISTER_OFFSET);\n\t\tdata &= ~0x100;\n\t\tif (orig != data)\n\t\t\tWREG32(SDMA0_POWER_CNTL + SDMA1_REGISTER_OFFSET, data);\n\t}\n}\n\nstatic void cik_enable_uvd_mgcg(struct radeon_device *rdev,\n\t\t\t\tbool enable)\n{\n\tu32 orig, data;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_UVD_MGCG)) {\n\t\tdata = RREG32_UVD_CTX(UVD_CGC_MEM_CTRL);\n\t\tdata = 0xfff;\n\t\tWREG32_UVD_CTX(UVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(UVD_CGC_CTRL);\n\t\tdata |= DCM;\n\t\tif (orig != data)\n\t\t\tWREG32(UVD_CGC_CTRL, data);\n\t} else {\n\t\tdata = RREG32_UVD_CTX(UVD_CGC_MEM_CTRL);\n\t\tdata &= ~0xfff;\n\t\tWREG32_UVD_CTX(UVD_CGC_MEM_CTRL, data);\n\n\t\torig = data = RREG32(UVD_CGC_CTRL);\n\t\tdata &= ~DCM;\n\t\tif (orig != data)\n\t\t\tWREG32(UVD_CGC_CTRL, data);\n\t}\n}\n\nstatic void cik_enable_bif_mgls(struct radeon_device *rdev,\n\t\t\t       bool enable)\n{\n\tu32 orig, data;\n\n\torig = data = RREG32_PCIE_PORT(PCIE_CNTL2);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_BIF_LS))\n\t\tdata |= SLV_MEM_LS_EN | MST_MEM_LS_EN |\n\t\t\tREPLAY_MEM_LS_EN | SLV_MEM_AGGRESSIVE_LS_EN;\n\telse\n\t\tdata &= ~(SLV_MEM_LS_EN | MST_MEM_LS_EN |\n\t\t\t  REPLAY_MEM_LS_EN | SLV_MEM_AGGRESSIVE_LS_EN);\n\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_CNTL2, data);\n}\n\nstatic void cik_enable_hdp_mgcg(struct radeon_device *rdev,\n\t\t\t\tbool enable)\n{\n\tu32 orig, data;\n\n\torig = data = RREG32(HDP_HOST_PATH_CNTL);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_HDP_MGCG))\n\t\tdata &= ~CLOCK_GATING_DIS;\n\telse\n\t\tdata |= CLOCK_GATING_DIS;\n\n\tif (orig != data)\n\t\tWREG32(HDP_HOST_PATH_CNTL, data);\n}\n\nstatic void cik_enable_hdp_ls(struct radeon_device *rdev,\n\t\t\t      bool enable)\n{\n\tu32 orig, data;\n\n\torig = data = RREG32(HDP_MEM_POWER_LS);\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_HDP_LS))\n\t\tdata |= HDP_LS_ENABLE;\n\telse\n\t\tdata &= ~HDP_LS_ENABLE;\n\n\tif (orig != data)\n\t\tWREG32(HDP_MEM_POWER_LS, data);\n}\n\nvoid cik_update_cg(struct radeon_device *rdev,\n\t\t   u32 block, bool enable)\n{\n\n\tif (block & RADEON_CG_BLOCK_GFX) {\n\t\tcik_enable_gui_idle_interrupt(rdev, false);\n\t\t \n\t\tif (enable) {\n\t\t\tcik_enable_mgcg(rdev, true);\n\t\t\tcik_enable_cgcg(rdev, true);\n\t\t} else {\n\t\t\tcik_enable_cgcg(rdev, false);\n\t\t\tcik_enable_mgcg(rdev, false);\n\t\t}\n\t\tcik_enable_gui_idle_interrupt(rdev, true);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_MC) {\n\t\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\t\tcik_enable_mc_mgcg(rdev, enable);\n\t\t\tcik_enable_mc_ls(rdev, enable);\n\t\t}\n\t}\n\n\tif (block & RADEON_CG_BLOCK_SDMA) {\n\t\tcik_enable_sdma_mgcg(rdev, enable);\n\t\tcik_enable_sdma_mgls(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_BIF) {\n\t\tcik_enable_bif_mgls(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_UVD) {\n\t\tif (rdev->has_uvd)\n\t\t\tcik_enable_uvd_mgcg(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_HDP) {\n\t\tcik_enable_hdp_mgcg(rdev, enable);\n\t\tcik_enable_hdp_ls(rdev, enable);\n\t}\n\n\tif (block & RADEON_CG_BLOCK_VCE) {\n\t\tvce_v2_0_enable_mgcg(rdev, enable);\n\t}\n}\n\nstatic void cik_init_cg(struct radeon_device *rdev)\n{\n\n\tcik_update_cg(rdev, RADEON_CG_BLOCK_GFX, true);\n\n\tif (rdev->has_uvd)\n\t\tsi_init_uvd_internal_cg(rdev);\n\n\tcik_update_cg(rdev, (RADEON_CG_BLOCK_MC |\n\t\t\t     RADEON_CG_BLOCK_SDMA |\n\t\t\t     RADEON_CG_BLOCK_BIF |\n\t\t\t     RADEON_CG_BLOCK_UVD |\n\t\t\t     RADEON_CG_BLOCK_HDP), true);\n}\n\nstatic void cik_fini_cg(struct radeon_device *rdev)\n{\n\tcik_update_cg(rdev, (RADEON_CG_BLOCK_MC |\n\t\t\t     RADEON_CG_BLOCK_SDMA |\n\t\t\t     RADEON_CG_BLOCK_BIF |\n\t\t\t     RADEON_CG_BLOCK_UVD |\n\t\t\t     RADEON_CG_BLOCK_HDP), false);\n\n\tcik_update_cg(rdev, RADEON_CG_BLOCK_GFX, false);\n}\n\nstatic void cik_enable_sck_slowdown_on_pu(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_RLC_SMU_HS))\n\t\tdata |= SMU_CLK_SLOWDOWN_ON_PU_ENABLE;\n\telse\n\t\tdata &= ~SMU_CLK_SLOWDOWN_ON_PU_ENABLE;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n}\n\nstatic void cik_enable_sck_slowdown_on_pd(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_RLC_SMU_HS))\n\t\tdata |= SMU_CLK_SLOWDOWN_ON_PD_ENABLE;\n\telse\n\t\tdata &= ~SMU_CLK_SLOWDOWN_ON_PD_ENABLE;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n}\n\nstatic void cik_enable_cp_pg(struct radeon_device *rdev, bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_CP))\n\t\tdata &= ~DISABLE_CP_PG;\n\telse\n\t\tdata |= DISABLE_CP_PG;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n}\n\nstatic void cik_enable_gds_pg(struct radeon_device *rdev, bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_GDS))\n\t\tdata &= ~DISABLE_GDS_PG;\n\telse\n\t\tdata |= DISABLE_GDS_PG;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n}\n\n#define CP_ME_TABLE_SIZE    96\n#define CP_ME_TABLE_OFFSET  2048\n#define CP_MEC_TABLE_OFFSET 4096\n\nvoid cik_init_cp_pg_table(struct radeon_device *rdev)\n{\n\tvolatile u32 *dst_ptr;\n\tint me, i, max_me = 4;\n\tu32 bo_offset = 0;\n\tu32 table_offset, table_size;\n\n\tif (rdev->family == CHIP_KAVERI)\n\t\tmax_me = 5;\n\n\tif (rdev->rlc.cp_table_ptr == NULL)\n\t\treturn;\n\n\t \n\tdst_ptr = rdev->rlc.cp_table_ptr;\n\tfor (me = 0; me < max_me; me++) {\n\t\tif (rdev->new_fw) {\n\t\t\tconst __le32 *fw_data;\n\t\t\tconst struct gfx_firmware_header_v1_0 *hdr;\n\n\t\t\tif (me == 0) {\n\t\t\t\thdr = (const struct gfx_firmware_header_v1_0 *)rdev->ce_fw->data;\n\t\t\t\tfw_data = (const __le32 *)\n\t\t\t\t\t(rdev->ce_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t\t} else if (me == 1) {\n\t\t\t\thdr = (const struct gfx_firmware_header_v1_0 *)rdev->pfp_fw->data;\n\t\t\t\tfw_data = (const __le32 *)\n\t\t\t\t\t(rdev->pfp_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t\t} else if (me == 2) {\n\t\t\t\thdr = (const struct gfx_firmware_header_v1_0 *)rdev->me_fw->data;\n\t\t\t\tfw_data = (const __le32 *)\n\t\t\t\t\t(rdev->me_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t\t} else if (me == 3) {\n\t\t\t\thdr = (const struct gfx_firmware_header_v1_0 *)rdev->mec_fw->data;\n\t\t\t\tfw_data = (const __le32 *)\n\t\t\t\t\t(rdev->mec_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t\t} else {\n\t\t\t\thdr = (const struct gfx_firmware_header_v1_0 *)rdev->mec2_fw->data;\n\t\t\t\tfw_data = (const __le32 *)\n\t\t\t\t\t(rdev->mec2_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t\t\t\ttable_offset = le32_to_cpu(hdr->jt_offset);\n\t\t\t\ttable_size = le32_to_cpu(hdr->jt_size);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < table_size; i ++) {\n\t\t\t\tdst_ptr[bo_offset + i] =\n\t\t\t\t\tcpu_to_le32(le32_to_cpu(fw_data[table_offset + i]));\n\t\t\t}\n\t\t\tbo_offset += table_size;\n\t\t} else {\n\t\t\tconst __be32 *fw_data;\n\t\t\ttable_size = CP_ME_TABLE_SIZE;\n\n\t\t\tif (me == 0) {\n\t\t\t\tfw_data = (const __be32 *)rdev->ce_fw->data;\n\t\t\t\ttable_offset = CP_ME_TABLE_OFFSET;\n\t\t\t} else if (me == 1) {\n\t\t\t\tfw_data = (const __be32 *)rdev->pfp_fw->data;\n\t\t\t\ttable_offset = CP_ME_TABLE_OFFSET;\n\t\t\t} else if (me == 2) {\n\t\t\t\tfw_data = (const __be32 *)rdev->me_fw->data;\n\t\t\t\ttable_offset = CP_ME_TABLE_OFFSET;\n\t\t\t} else {\n\t\t\t\tfw_data = (const __be32 *)rdev->mec_fw->data;\n\t\t\t\ttable_offset = CP_MEC_TABLE_OFFSET;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < table_size; i ++) {\n\t\t\t\tdst_ptr[bo_offset + i] =\n\t\t\t\t\tcpu_to_le32(be32_to_cpu(fw_data[table_offset + i]));\n\t\t\t}\n\t\t\tbo_offset += table_size;\n\t\t}\n\t}\n}\n\nstatic void cik_enable_gfx_cgpg(struct radeon_device *rdev,\n\t\t\t\tbool enable)\n{\n\tu32 data, orig;\n\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_PG)) {\n\t\torig = data = RREG32(RLC_PG_CNTL);\n\t\tdata |= GFX_PG_ENABLE;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_PG_CNTL, data);\n\n\t\torig = data = RREG32(RLC_AUTO_PG_CTRL);\n\t\tdata |= AUTO_PG_EN;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_AUTO_PG_CTRL, data);\n\t} else {\n\t\torig = data = RREG32(RLC_PG_CNTL);\n\t\tdata &= ~GFX_PG_ENABLE;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_PG_CNTL, data);\n\n\t\torig = data = RREG32(RLC_AUTO_PG_CTRL);\n\t\tdata &= ~AUTO_PG_EN;\n\t\tif (orig != data)\n\t\t\tWREG32(RLC_AUTO_PG_CTRL, data);\n\n\t\tdata = RREG32(DB_RENDER_CONTROL);\n\t}\n}\n\nstatic u32 cik_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh)\n{\n\tu32 mask = 0, tmp, tmp1;\n\tint i;\n\n\tcik_select_se_sh(rdev, se, sh);\n\ttmp = RREG32(CC_GC_SHADER_ARRAY_CONFIG);\n\ttmp1 = RREG32(GC_USER_SHADER_ARRAY_CONFIG);\n\tcik_select_se_sh(rdev, 0xffffffff, 0xffffffff);\n\n\ttmp &= 0xffff0000;\n\n\ttmp |= tmp1;\n\ttmp >>= 16;\n\n\tfor (i = 0; i < rdev->config.cik.max_cu_per_sh; i ++) {\n\t\tmask <<= 1;\n\t\tmask |= 1;\n\t}\n\n\treturn (~tmp) & mask;\n}\n\nstatic void cik_init_ao_cu_mask(struct radeon_device *rdev)\n{\n\tu32 i, j, k, active_cu_number = 0;\n\tu32 mask, counter, cu_bitmap;\n\tu32 tmp = 0;\n\n\tfor (i = 0; i < rdev->config.cik.max_shader_engines; i++) {\n\t\tfor (j = 0; j < rdev->config.cik.max_sh_per_se; j++) {\n\t\t\tmask = 1;\n\t\t\tcu_bitmap = 0;\n\t\t\tcounter = 0;\n\t\t\tfor (k = 0; k < rdev->config.cik.max_cu_per_sh; k ++) {\n\t\t\t\tif (cik_get_cu_active_bitmap(rdev, i, j) & mask) {\n\t\t\t\t\tif (counter < 2)\n\t\t\t\t\t\tcu_bitmap |= mask;\n\t\t\t\t\tcounter ++;\n\t\t\t\t}\n\t\t\t\tmask <<= 1;\n\t\t\t}\n\n\t\t\tactive_cu_number += counter;\n\t\t\ttmp |= (cu_bitmap << (i * 16 + j * 8));\n\t\t}\n\t}\n\n\tWREG32(RLC_PG_AO_CU_MASK, tmp);\n\n\ttmp = RREG32(RLC_MAX_PG_CU);\n\ttmp &= ~MAX_PU_CU_MASK;\n\ttmp |= MAX_PU_CU(active_cu_number);\n\tWREG32(RLC_MAX_PG_CU, tmp);\n}\n\nstatic void cik_enable_gfx_static_mgpg(struct radeon_device *rdev,\n\t\t\t\t       bool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_SMG))\n\t\tdata |= STATIC_PER_CU_PG_ENABLE;\n\telse\n\t\tdata &= ~STATIC_PER_CU_PG_ENABLE;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n}\n\nstatic void cik_enable_gfx_dynamic_mgpg(struct radeon_device *rdev,\n\t\t\t\t\tbool enable)\n{\n\tu32 data, orig;\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tif (enable && (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_DMG))\n\t\tdata |= DYN_PER_CU_PG_ENABLE;\n\telse\n\t\tdata &= ~DYN_PER_CU_PG_ENABLE;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n}\n\n#define RLC_SAVE_AND_RESTORE_STARTING_OFFSET 0x90\n#define RLC_CLEAR_STATE_DESCRIPTOR_OFFSET    0x3D\n\nstatic void cik_init_gfx_cgpg(struct radeon_device *rdev)\n{\n\tu32 data, orig;\n\tu32 i;\n\n\tif (rdev->rlc.cs_data) {\n\t\tWREG32(RLC_GPM_SCRATCH_ADDR, RLC_CLEAR_STATE_DESCRIPTOR_OFFSET);\n\t\tWREG32(RLC_GPM_SCRATCH_DATA, upper_32_bits(rdev->rlc.clear_state_gpu_addr));\n\t\tWREG32(RLC_GPM_SCRATCH_DATA, lower_32_bits(rdev->rlc.clear_state_gpu_addr));\n\t\tWREG32(RLC_GPM_SCRATCH_DATA, rdev->rlc.clear_state_size);\n\t} else {\n\t\tWREG32(RLC_GPM_SCRATCH_ADDR, RLC_CLEAR_STATE_DESCRIPTOR_OFFSET);\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tWREG32(RLC_GPM_SCRATCH_DATA, 0);\n\t}\n\tif (rdev->rlc.reg_list) {\n\t\tWREG32(RLC_GPM_SCRATCH_ADDR, RLC_SAVE_AND_RESTORE_STARTING_OFFSET);\n\t\tfor (i = 0; i < rdev->rlc.reg_list_size; i++)\n\t\t\tWREG32(RLC_GPM_SCRATCH_DATA, rdev->rlc.reg_list[i]);\n\t}\n\n\torig = data = RREG32(RLC_PG_CNTL);\n\tdata |= GFX_PG_SRC;\n\tif (orig != data)\n\t\tWREG32(RLC_PG_CNTL, data);\n\n\tWREG32(RLC_SAVE_AND_RESTORE_BASE, rdev->rlc.save_restore_gpu_addr >> 8);\n\tWREG32(RLC_CP_TABLE_RESTORE, rdev->rlc.cp_table_gpu_addr >> 8);\n\n\tdata = RREG32(CP_RB_WPTR_POLL_CNTL);\n\tdata &= ~IDLE_POLL_COUNT_MASK;\n\tdata |= IDLE_POLL_COUNT(0x60);\n\tWREG32(CP_RB_WPTR_POLL_CNTL, data);\n\n\tdata = 0x10101010;\n\tWREG32(RLC_PG_DELAY, data);\n\n\tdata = RREG32(RLC_PG_DELAY_2);\n\tdata &= ~0xff;\n\tdata |= 0x3;\n\tWREG32(RLC_PG_DELAY_2, data);\n\n\tdata = RREG32(RLC_AUTO_PG_CTRL);\n\tdata &= ~GRBM_REG_SGIT_MASK;\n\tdata |= GRBM_REG_SGIT(0x700);\n\tWREG32(RLC_AUTO_PG_CTRL, data);\n\n}\n\nstatic void cik_update_gfx_pg(struct radeon_device *rdev, bool enable)\n{\n\tcik_enable_gfx_cgpg(rdev, enable);\n\tcik_enable_gfx_static_mgpg(rdev, enable);\n\tcik_enable_gfx_dynamic_mgpg(rdev, enable);\n}\n\nu32 cik_get_csb_size(struct radeon_device *rdev)\n{\n\tu32 count = 0;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (rdev->rlc.cs_data == NULL)\n\t\treturn 0;\n\n\t \n\tcount += 2;\n\t \n\tcount += 3;\n\n\tfor (sect = rdev->rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT)\n\t\t\t\tcount += 2 + ext->reg_count;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tcount += 4;\n\t \n\tcount += 2;\n\t \n\tcount += 2;\n\n\treturn count;\n}\n\nvoid cik_get_csb_buffer(struct radeon_device *rdev, volatile u32 *buffer)\n{\n\tu32 count = 0, i;\n\tconst struct cs_section_def *sect = NULL;\n\tconst struct cs_extent_def *ext = NULL;\n\n\tif (rdev->rlc.cs_data == NULL)\n\t\treturn;\n\tif (buffer == NULL)\n\t\treturn;\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CONTEXT_CONTROL, 1));\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\tbuffer[count++] = cpu_to_le32(0x80000000);\n\n\tfor (sect = rdev->rlc.cs_data; sect->section != NULL; ++sect) {\n\t\tfor (ext = sect->section; ext->extent != NULL; ++ext) {\n\t\t\tif (sect->id == SECT_CONTEXT) {\n\t\t\t\tbuffer[count++] =\n\t\t\t\t\tcpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, ext->reg_count));\n\t\t\t\tbuffer[count++] = cpu_to_le32(ext->reg_index - 0xa000);\n\t\t\t\tfor (i = 0; i < ext->reg_count; i++)\n\t\t\t\t\tbuffer[count++] = cpu_to_le32(ext->extent[i]);\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_SET_CONTEXT_REG, 2));\n\tbuffer[count++] = cpu_to_le32(PA_SC_RASTER_CONFIG - PACKET3_SET_CONTEXT_REG_START);\n\tswitch (rdev->family) {\n\tcase CHIP_BONAIRE:\n\t\tbuffer[count++] = cpu_to_le32(0x16000012);\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tcase CHIP_KAVERI:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);  \n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tcase CHIP_KABINI:\n\tcase CHIP_MULLINS:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);  \n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\tcase CHIP_HAWAII:\n\t\tbuffer[count++] = cpu_to_le32(0x3a00161a);\n\t\tbuffer[count++] = cpu_to_le32(0x0000002e);\n\t\tbreak;\n\tdefault:\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbuffer[count++] = cpu_to_le32(0x00000000);\n\t\tbreak;\n\t}\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tbuffer[count++] = cpu_to_le32(PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\tbuffer[count++] = cpu_to_le32(PACKET3(PACKET3_CLEAR_STATE, 0));\n\tbuffer[count++] = cpu_to_le32(0);\n}\n\nstatic void cik_init_pg(struct radeon_device *rdev)\n{\n\tif (rdev->pg_flags) {\n\t\tcik_enable_sck_slowdown_on_pu(rdev, true);\n\t\tcik_enable_sck_slowdown_on_pd(rdev, true);\n\t\tif (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_PG) {\n\t\t\tcik_init_gfx_cgpg(rdev);\n\t\t\tcik_enable_cp_pg(rdev, true);\n\t\t\tcik_enable_gds_pg(rdev, true);\n\t\t}\n\t\tcik_init_ao_cu_mask(rdev);\n\t\tcik_update_gfx_pg(rdev, true);\n\t}\n}\n\nstatic void cik_fini_pg(struct radeon_device *rdev)\n{\n\tif (rdev->pg_flags) {\n\t\tcik_update_gfx_pg(rdev, false);\n\t\tif (rdev->pg_flags & RADEON_PG_SUPPORT_GFX_PG) {\n\t\t\tcik_enable_cp_pg(rdev, false);\n\t\t\tcik_enable_gds_pg(rdev, false);\n\t\t}\n\t}\n}\n\n \n\n \nstatic void cik_enable_interrupts(struct radeon_device *rdev)\n{\n\tu32 ih_cntl = RREG32(IH_CNTL);\n\tu32 ih_rb_cntl = RREG32(IH_RB_CNTL);\n\n\tih_cntl |= ENABLE_INTR;\n\tih_rb_cntl |= IH_RB_ENABLE;\n\tWREG32(IH_CNTL, ih_cntl);\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\trdev->ih.enabled = true;\n}\n\n \nstatic void cik_disable_interrupts(struct radeon_device *rdev)\n{\n\tu32 ih_rb_cntl = RREG32(IH_RB_CNTL);\n\tu32 ih_cntl = RREG32(IH_CNTL);\n\n\tih_rb_cntl &= ~IH_RB_ENABLE;\n\tih_cntl &= ~ENABLE_INTR;\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\tWREG32(IH_CNTL, ih_cntl);\n\t \n\tWREG32(IH_RB_RPTR, 0);\n\tWREG32(IH_RB_WPTR, 0);\n\trdev->ih.enabled = false;\n\trdev->ih.rptr = 0;\n}\n\n \nstatic void cik_disable_interrupt_state(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(CP_INT_CNTL_RING0) &\n\t\t(CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\tWREG32(CP_INT_CNTL_RING0, tmp);\n\t \n\ttmp = RREG32(SDMA0_CNTL + SDMA0_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\tWREG32(SDMA0_CNTL + SDMA0_REGISTER_OFFSET, tmp);\n\ttmp = RREG32(SDMA0_CNTL + SDMA1_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\tWREG32(SDMA0_CNTL + SDMA1_REGISTER_OFFSET, tmp);\n\t \n\tWREG32(CP_ME1_PIPE0_INT_CNTL, 0);\n\tWREG32(CP_ME1_PIPE1_INT_CNTL, 0);\n\tWREG32(CP_ME1_PIPE2_INT_CNTL, 0);\n\tWREG32(CP_ME1_PIPE3_INT_CNTL, 0);\n\tWREG32(CP_ME2_PIPE0_INT_CNTL, 0);\n\tWREG32(CP_ME2_PIPE1_INT_CNTL, 0);\n\tWREG32(CP_ME2_PIPE2_INT_CNTL, 0);\n\tWREG32(CP_ME2_PIPE3_INT_CNTL, 0);\n\t \n\tWREG32(GRBM_INT_CNTL, 0);\n\t \n\tWREG32(SRBM_INT_CNTL, 0);\n\t \n\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC0_REGISTER_OFFSET, 0);\n\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC1_REGISTER_OFFSET, 0);\n\tif (rdev->num_crtc >= 4) {\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC2_REGISTER_OFFSET, 0);\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC3_REGISTER_OFFSET, 0);\n\t}\n\tif (rdev->num_crtc >= 6) {\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC4_REGISTER_OFFSET, 0);\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC5_REGISTER_OFFSET, 0);\n\t}\n\t \n\tif (rdev->num_crtc >= 2) {\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC0_REGISTER_OFFSET, 0);\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC1_REGISTER_OFFSET, 0);\n\t}\n\tif (rdev->num_crtc >= 4) {\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC2_REGISTER_OFFSET, 0);\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC3_REGISTER_OFFSET, 0);\n\t}\n\tif (rdev->num_crtc >= 6) {\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC4_REGISTER_OFFSET, 0);\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC5_REGISTER_OFFSET, 0);\n\t}\n\n\t \n\tWREG32(DAC_AUTODETECT_INT_CONTROL, 0);\n\n\t \n\ttmp = RREG32(DC_HPD1_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\tWREG32(DC_HPD1_INT_CONTROL, tmp);\n\ttmp = RREG32(DC_HPD2_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\tWREG32(DC_HPD2_INT_CONTROL, tmp);\n\ttmp = RREG32(DC_HPD3_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\tWREG32(DC_HPD3_INT_CONTROL, tmp);\n\ttmp = RREG32(DC_HPD4_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\tWREG32(DC_HPD4_INT_CONTROL, tmp);\n\ttmp = RREG32(DC_HPD5_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\tWREG32(DC_HPD5_INT_CONTROL, tmp);\n\ttmp = RREG32(DC_HPD6_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\tWREG32(DC_HPD6_INT_CONTROL, tmp);\n\n}\n\n \nstatic int cik_irq_init(struct radeon_device *rdev)\n{\n\tint ret = 0;\n\tint rb_bufsz;\n\tu32 interrupt_cntl, ih_cntl, ih_rb_cntl;\n\n\t \n\tret = r600_ih_ring_alloc(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcik_disable_interrupts(rdev);\n\n\t \n\tret = cik_rlc_resume(rdev);\n\tif (ret) {\n\t\tr600_ih_ring_fini(rdev);\n\t\treturn ret;\n\t}\n\n\t \n\t \n\tWREG32(INTERRUPT_CNTL2, rdev->dummy_page.addr >> 8);\n\tinterrupt_cntl = RREG32(INTERRUPT_CNTL);\n\t \n\tinterrupt_cntl &= ~IH_DUMMY_RD_OVERRIDE;\n\t \n\tinterrupt_cntl &= ~IH_REQ_NONSNOOP_EN;\n\tWREG32(INTERRUPT_CNTL, interrupt_cntl);\n\n\tWREG32(IH_RB_BASE, rdev->ih.gpu_addr >> 8);\n\trb_bufsz = order_base_2(rdev->ih.ring_size / 4);\n\n\tih_rb_cntl = (IH_WPTR_OVERFLOW_ENABLE |\n\t\t      IH_WPTR_OVERFLOW_CLEAR |\n\t\t      (rb_bufsz << 1));\n\n\tif (rdev->wb.enabled)\n\t\tih_rb_cntl |= IH_WPTR_WRITEBACK_ENABLE;\n\n\t \n\tWREG32(IH_RB_WPTR_ADDR_LO, (rdev->wb.gpu_addr + R600_WB_IH_WPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(IH_RB_WPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + R600_WB_IH_WPTR_OFFSET) & 0xFF);\n\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\n\t \n\tWREG32(IH_RB_RPTR, 0);\n\tWREG32(IH_RB_WPTR, 0);\n\n\t \n\tih_cntl = MC_WRREQ_CREDIT(0x10) | MC_WR_CLEAN_CNT(0x10) | MC_VMID(0);\n\t \n\tif (rdev->msi_enabled)\n\t\tih_cntl |= RPTR_REARM;\n\tWREG32(IH_CNTL, ih_cntl);\n\n\t \n\tcik_disable_interrupt_state(rdev);\n\n\tpci_set_master(rdev->pdev);\n\n\t \n\tcik_enable_interrupts(rdev);\n\n\treturn ret;\n}\n\n \nint cik_irq_set(struct radeon_device *rdev)\n{\n\tu32 cp_int_cntl;\n\tu32 cp_m1p0, cp_m1p1, cp_m1p2, cp_m1p3;\n\tu32 cp_m2p0, cp_m2p1, cp_m2p2, cp_m2p3;\n\tu32 crtc1 = 0, crtc2 = 0, crtc3 = 0, crtc4 = 0, crtc5 = 0, crtc6 = 0;\n\tu32 hpd1, hpd2, hpd3, hpd4, hpd5, hpd6;\n\tu32 grbm_int_cntl = 0;\n\tu32 dma_cntl, dma_cntl1;\n\n\tif (!rdev->irq.installed) {\n\t\tWARN(1, \"Can't enable IRQ/MSI because no handler is installed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->ih.enabled) {\n\t\tcik_disable_interrupts(rdev);\n\t\t \n\t\tcik_disable_interrupt_state(rdev);\n\t\treturn 0;\n\t}\n\n\tcp_int_cntl = RREG32(CP_INT_CNTL_RING0) &\n\t\t(CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\tcp_int_cntl |= PRIV_INSTR_INT_ENABLE | PRIV_REG_INT_ENABLE;\n\n\thpd1 = RREG32(DC_HPD1_INT_CONTROL) & ~(DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN);\n\thpd2 = RREG32(DC_HPD2_INT_CONTROL) & ~(DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN);\n\thpd3 = RREG32(DC_HPD3_INT_CONTROL) & ~(DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN);\n\thpd4 = RREG32(DC_HPD4_INT_CONTROL) & ~(DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN);\n\thpd5 = RREG32(DC_HPD5_INT_CONTROL) & ~(DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN);\n\thpd6 = RREG32(DC_HPD6_INT_CONTROL) & ~(DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN);\n\n\tdma_cntl = RREG32(SDMA0_CNTL + SDMA0_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\tdma_cntl1 = RREG32(SDMA0_CNTL + SDMA1_REGISTER_OFFSET) & ~TRAP_ENABLE;\n\n\tcp_m1p0 = RREG32(CP_ME1_PIPE0_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m1p1 = RREG32(CP_ME1_PIPE1_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m1p2 = RREG32(CP_ME1_PIPE2_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m1p3 = RREG32(CP_ME1_PIPE3_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m2p0 = RREG32(CP_ME2_PIPE0_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m2p1 = RREG32(CP_ME2_PIPE1_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m2p2 = RREG32(CP_ME2_PIPE2_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\tcp_m2p3 = RREG32(CP_ME2_PIPE3_INT_CNTL) & ~TIME_STAMP_INT_ENABLE;\n\n\t \n\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\tDRM_DEBUG(\"cik_irq_set: sw int gfx\\n\");\n\t\tcp_int_cntl |= TIME_STAMP_INT_ENABLE;\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_CP1_INDEX])) {\n\t\tstruct radeon_ring *ring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\t\tDRM_DEBUG(\"si_irq_set: sw int cp1\\n\");\n\t\tif (ring->me == 1) {\n\t\t\tswitch (ring->pipe) {\n\t\t\tcase 0:\n\t\t\t\tcp_m1p0 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcp_m1p1 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcp_m1p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcp_m1p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"si_irq_set: sw int cp1 invalid pipe %d\\n\", ring->pipe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ring->me == 2) {\n\t\t\tswitch (ring->pipe) {\n\t\t\tcase 0:\n\t\t\t\tcp_m2p0 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcp_m2p1 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcp_m2p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcp_m2p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"si_irq_set: sw int cp1 invalid pipe %d\\n\", ring->pipe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tDRM_DEBUG(\"si_irq_set: sw int cp1 invalid me %d\\n\", ring->me);\n\t\t}\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_CP2_INDEX])) {\n\t\tstruct radeon_ring *ring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\t\tDRM_DEBUG(\"si_irq_set: sw int cp2\\n\");\n\t\tif (ring->me == 1) {\n\t\t\tswitch (ring->pipe) {\n\t\t\tcase 0:\n\t\t\t\tcp_m1p0 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcp_m1p1 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcp_m1p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcp_m1p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"si_irq_set: sw int cp2 invalid pipe %d\\n\", ring->pipe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ring->me == 2) {\n\t\t\tswitch (ring->pipe) {\n\t\t\tcase 0:\n\t\t\t\tcp_m2p0 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcp_m2p1 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcp_m2p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcp_m2p2 |= TIME_STAMP_INT_ENABLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"si_irq_set: sw int cp2 invalid pipe %d\\n\", ring->pipe);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tDRM_DEBUG(\"si_irq_set: sw int cp2 invalid me %d\\n\", ring->me);\n\t\t}\n\t}\n\n\tif (atomic_read(&rdev->irq.ring_int[R600_RING_TYPE_DMA_INDEX])) {\n\t\tDRM_DEBUG(\"cik_irq_set: sw int dma\\n\");\n\t\tdma_cntl |= TRAP_ENABLE;\n\t}\n\n\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_DMA1_INDEX])) {\n\t\tDRM_DEBUG(\"cik_irq_set: sw int dma1\\n\");\n\t\tdma_cntl1 |= TRAP_ENABLE;\n\t}\n\n\tif (rdev->irq.crtc_vblank_int[0] ||\n\t    atomic_read(&rdev->irq.pflip[0])) {\n\t\tDRM_DEBUG(\"cik_irq_set: vblank 0\\n\");\n\t\tcrtc1 |= VBLANK_INTERRUPT_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[1] ||\n\t    atomic_read(&rdev->irq.pflip[1])) {\n\t\tDRM_DEBUG(\"cik_irq_set: vblank 1\\n\");\n\t\tcrtc2 |= VBLANK_INTERRUPT_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[2] ||\n\t    atomic_read(&rdev->irq.pflip[2])) {\n\t\tDRM_DEBUG(\"cik_irq_set: vblank 2\\n\");\n\t\tcrtc3 |= VBLANK_INTERRUPT_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[3] ||\n\t    atomic_read(&rdev->irq.pflip[3])) {\n\t\tDRM_DEBUG(\"cik_irq_set: vblank 3\\n\");\n\t\tcrtc4 |= VBLANK_INTERRUPT_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[4] ||\n\t    atomic_read(&rdev->irq.pflip[4])) {\n\t\tDRM_DEBUG(\"cik_irq_set: vblank 4\\n\");\n\t\tcrtc5 |= VBLANK_INTERRUPT_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[5] ||\n\t    atomic_read(&rdev->irq.pflip[5])) {\n\t\tDRM_DEBUG(\"cik_irq_set: vblank 5\\n\");\n\t\tcrtc6 |= VBLANK_INTERRUPT_MASK;\n\t}\n\tif (rdev->irq.hpd[0]) {\n\t\tDRM_DEBUG(\"cik_irq_set: hpd 1\\n\");\n\t\thpd1 |= DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN;\n\t}\n\tif (rdev->irq.hpd[1]) {\n\t\tDRM_DEBUG(\"cik_irq_set: hpd 2\\n\");\n\t\thpd2 |= DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN;\n\t}\n\tif (rdev->irq.hpd[2]) {\n\t\tDRM_DEBUG(\"cik_irq_set: hpd 3\\n\");\n\t\thpd3 |= DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN;\n\t}\n\tif (rdev->irq.hpd[3]) {\n\t\tDRM_DEBUG(\"cik_irq_set: hpd 4\\n\");\n\t\thpd4 |= DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN;\n\t}\n\tif (rdev->irq.hpd[4]) {\n\t\tDRM_DEBUG(\"cik_irq_set: hpd 5\\n\");\n\t\thpd5 |= DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN;\n\t}\n\tif (rdev->irq.hpd[5]) {\n\t\tDRM_DEBUG(\"cik_irq_set: hpd 6\\n\");\n\t\thpd6 |= DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN;\n\t}\n\n\tWREG32(CP_INT_CNTL_RING0, cp_int_cntl);\n\n\tWREG32(SDMA0_CNTL + SDMA0_REGISTER_OFFSET, dma_cntl);\n\tWREG32(SDMA0_CNTL + SDMA1_REGISTER_OFFSET, dma_cntl1);\n\n\tWREG32(CP_ME1_PIPE0_INT_CNTL, cp_m1p0);\n\tWREG32(CP_ME1_PIPE1_INT_CNTL, cp_m1p1);\n\tWREG32(CP_ME1_PIPE2_INT_CNTL, cp_m1p2);\n\tWREG32(CP_ME1_PIPE3_INT_CNTL, cp_m1p3);\n\tWREG32(CP_ME2_PIPE0_INT_CNTL, cp_m2p0);\n\tWREG32(CP_ME2_PIPE1_INT_CNTL, cp_m2p1);\n\tWREG32(CP_ME2_PIPE2_INT_CNTL, cp_m2p2);\n\tWREG32(CP_ME2_PIPE3_INT_CNTL, cp_m2p3);\n\n\tWREG32(GRBM_INT_CNTL, grbm_int_cntl);\n\n\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC0_REGISTER_OFFSET, crtc1);\n\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC1_REGISTER_OFFSET, crtc2);\n\tif (rdev->num_crtc >= 4) {\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC2_REGISTER_OFFSET, crtc3);\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC3_REGISTER_OFFSET, crtc4);\n\t}\n\tif (rdev->num_crtc >= 6) {\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC4_REGISTER_OFFSET, crtc5);\n\t\tWREG32(LB_INTERRUPT_MASK + EVERGREEN_CRTC5_REGISTER_OFFSET, crtc6);\n\t}\n\n\tif (rdev->num_crtc >= 2) {\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC0_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_MASK);\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC1_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_MASK);\n\t}\n\tif (rdev->num_crtc >= 4) {\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC2_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_MASK);\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC3_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_MASK);\n\t}\n\tif (rdev->num_crtc >= 6) {\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC4_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_MASK);\n\t\tWREG32(GRPH_INT_CONTROL + EVERGREEN_CRTC5_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_MASK);\n\t}\n\n\tWREG32(DC_HPD1_INT_CONTROL, hpd1);\n\tWREG32(DC_HPD2_INT_CONTROL, hpd2);\n\tWREG32(DC_HPD3_INT_CONTROL, hpd3);\n\tWREG32(DC_HPD4_INT_CONTROL, hpd4);\n\tWREG32(DC_HPD5_INT_CONTROL, hpd5);\n\tWREG32(DC_HPD6_INT_CONTROL, hpd6);\n\n\t \n\tRREG32(SRBM_STATUS);\n\n\treturn 0;\n}\n\n \nstatic inline void cik_irq_ack(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\trdev->irq.stat_regs.cik.disp_int = RREG32(DISP_INTERRUPT_STATUS);\n\trdev->irq.stat_regs.cik.disp_int_cont = RREG32(DISP_INTERRUPT_STATUS_CONTINUE);\n\trdev->irq.stat_regs.cik.disp_int_cont2 = RREG32(DISP_INTERRUPT_STATUS_CONTINUE2);\n\trdev->irq.stat_regs.cik.disp_int_cont3 = RREG32(DISP_INTERRUPT_STATUS_CONTINUE3);\n\trdev->irq.stat_regs.cik.disp_int_cont4 = RREG32(DISP_INTERRUPT_STATUS_CONTINUE4);\n\trdev->irq.stat_regs.cik.disp_int_cont5 = RREG32(DISP_INTERRUPT_STATUS_CONTINUE5);\n\trdev->irq.stat_regs.cik.disp_int_cont6 = RREG32(DISP_INTERRUPT_STATUS_CONTINUE6);\n\n\trdev->irq.stat_regs.cik.d1grph_int = RREG32(GRPH_INT_STATUS +\n\t\tEVERGREEN_CRTC0_REGISTER_OFFSET);\n\trdev->irq.stat_regs.cik.d2grph_int = RREG32(GRPH_INT_STATUS +\n\t\tEVERGREEN_CRTC1_REGISTER_OFFSET);\n\tif (rdev->num_crtc >= 4) {\n\t\trdev->irq.stat_regs.cik.d3grph_int = RREG32(GRPH_INT_STATUS +\n\t\t\tEVERGREEN_CRTC2_REGISTER_OFFSET);\n\t\trdev->irq.stat_regs.cik.d4grph_int = RREG32(GRPH_INT_STATUS +\n\t\t\tEVERGREEN_CRTC3_REGISTER_OFFSET);\n\t}\n\tif (rdev->num_crtc >= 6) {\n\t\trdev->irq.stat_regs.cik.d5grph_int = RREG32(GRPH_INT_STATUS +\n\t\t\tEVERGREEN_CRTC4_REGISTER_OFFSET);\n\t\trdev->irq.stat_regs.cik.d6grph_int = RREG32(GRPH_INT_STATUS +\n\t\t\tEVERGREEN_CRTC5_REGISTER_OFFSET);\n\t}\n\n\tif (rdev->irq.stat_regs.cik.d1grph_int & GRPH_PFLIP_INT_OCCURRED)\n\t\tWREG32(GRPH_INT_STATUS + EVERGREEN_CRTC0_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_CLEAR);\n\tif (rdev->irq.stat_regs.cik.d2grph_int & GRPH_PFLIP_INT_OCCURRED)\n\t\tWREG32(GRPH_INT_STATUS + EVERGREEN_CRTC1_REGISTER_OFFSET,\n\t\t       GRPH_PFLIP_INT_CLEAR);\n\tif (rdev->irq.stat_regs.cik.disp_int & LB_D1_VBLANK_INTERRUPT)\n\t\tWREG32(LB_VBLANK_STATUS + EVERGREEN_CRTC0_REGISTER_OFFSET, VBLANK_ACK);\n\tif (rdev->irq.stat_regs.cik.disp_int & LB_D1_VLINE_INTERRUPT)\n\t\tWREG32(LB_VLINE_STATUS + EVERGREEN_CRTC0_REGISTER_OFFSET, VLINE_ACK);\n\tif (rdev->irq.stat_regs.cik.disp_int_cont & LB_D2_VBLANK_INTERRUPT)\n\t\tWREG32(LB_VBLANK_STATUS + EVERGREEN_CRTC1_REGISTER_OFFSET, VBLANK_ACK);\n\tif (rdev->irq.stat_regs.cik.disp_int_cont & LB_D2_VLINE_INTERRUPT)\n\t\tWREG32(LB_VLINE_STATUS + EVERGREEN_CRTC1_REGISTER_OFFSET, VLINE_ACK);\n\n\tif (rdev->num_crtc >= 4) {\n\t\tif (rdev->irq.stat_regs.cik.d3grph_int & GRPH_PFLIP_INT_OCCURRED)\n\t\t\tWREG32(GRPH_INT_STATUS + EVERGREEN_CRTC2_REGISTER_OFFSET,\n\t\t\t       GRPH_PFLIP_INT_CLEAR);\n\t\tif (rdev->irq.stat_regs.cik.d4grph_int & GRPH_PFLIP_INT_OCCURRED)\n\t\t\tWREG32(GRPH_INT_STATUS + EVERGREEN_CRTC3_REGISTER_OFFSET,\n\t\t\t       GRPH_PFLIP_INT_CLEAR);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont2 & LB_D3_VBLANK_INTERRUPT)\n\t\t\tWREG32(LB_VBLANK_STATUS + EVERGREEN_CRTC2_REGISTER_OFFSET, VBLANK_ACK);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont2 & LB_D3_VLINE_INTERRUPT)\n\t\t\tWREG32(LB_VLINE_STATUS + EVERGREEN_CRTC2_REGISTER_OFFSET, VLINE_ACK);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont3 & LB_D4_VBLANK_INTERRUPT)\n\t\t\tWREG32(LB_VBLANK_STATUS + EVERGREEN_CRTC3_REGISTER_OFFSET, VBLANK_ACK);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont3 & LB_D4_VLINE_INTERRUPT)\n\t\t\tWREG32(LB_VLINE_STATUS + EVERGREEN_CRTC3_REGISTER_OFFSET, VLINE_ACK);\n\t}\n\n\tif (rdev->num_crtc >= 6) {\n\t\tif (rdev->irq.stat_regs.cik.d5grph_int & GRPH_PFLIP_INT_OCCURRED)\n\t\t\tWREG32(GRPH_INT_STATUS + EVERGREEN_CRTC4_REGISTER_OFFSET,\n\t\t\t       GRPH_PFLIP_INT_CLEAR);\n\t\tif (rdev->irq.stat_regs.cik.d6grph_int & GRPH_PFLIP_INT_OCCURRED)\n\t\t\tWREG32(GRPH_INT_STATUS + EVERGREEN_CRTC5_REGISTER_OFFSET,\n\t\t\t       GRPH_PFLIP_INT_CLEAR);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont4 & LB_D5_VBLANK_INTERRUPT)\n\t\t\tWREG32(LB_VBLANK_STATUS + EVERGREEN_CRTC4_REGISTER_OFFSET, VBLANK_ACK);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont4 & LB_D5_VLINE_INTERRUPT)\n\t\t\tWREG32(LB_VLINE_STATUS + EVERGREEN_CRTC4_REGISTER_OFFSET, VLINE_ACK);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont5 & LB_D6_VBLANK_INTERRUPT)\n\t\t\tWREG32(LB_VBLANK_STATUS + EVERGREEN_CRTC5_REGISTER_OFFSET, VBLANK_ACK);\n\t\tif (rdev->irq.stat_regs.cik.disp_int_cont5 & LB_D6_VLINE_INTERRUPT)\n\t\t\tWREG32(LB_VLINE_STATUS + EVERGREEN_CRTC5_REGISTER_OFFSET, VLINE_ACK);\n\t}\n\n\tif (rdev->irq.stat_regs.cik.disp_int & DC_HPD1_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD1_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD1_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD2_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD2_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD3_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD3_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD4_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD4_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD5_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD5_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD6_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD6_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int & DC_HPD1_RX_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD1_INT_CONTROL);\n\t\ttmp |= DC_HPDx_RX_INT_ACK;\n\t\tWREG32(DC_HPD1_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_RX_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD2_INT_CONTROL);\n\t\ttmp |= DC_HPDx_RX_INT_ACK;\n\t\tWREG32(DC_HPD2_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_RX_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD3_INT_CONTROL);\n\t\ttmp |= DC_HPDx_RX_INT_ACK;\n\t\tWREG32(DC_HPD3_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_RX_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD4_INT_CONTROL);\n\t\ttmp |= DC_HPDx_RX_INT_ACK;\n\t\tWREG32(DC_HPD4_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_RX_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD5_INT_CONTROL);\n\t\ttmp |= DC_HPDx_RX_INT_ACK;\n\t\tWREG32(DC_HPD5_INT_CONTROL, tmp);\n\t}\n\tif (rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_RX_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD6_INT_CONTROL);\n\t\ttmp |= DC_HPDx_RX_INT_ACK;\n\t\tWREG32(DC_HPD6_INT_CONTROL, tmp);\n\t}\n}\n\n \nstatic void cik_irq_disable(struct radeon_device *rdev)\n{\n\tcik_disable_interrupts(rdev);\n\t \n\tmdelay(1);\n\tcik_irq_ack(rdev);\n\tcik_disable_interrupt_state(rdev);\n}\n\n \nstatic void cik_irq_suspend(struct radeon_device *rdev)\n{\n\tcik_irq_disable(rdev);\n\tcik_rlc_stop(rdev);\n}\n\n \nstatic void cik_irq_fini(struct radeon_device *rdev)\n{\n\tcik_irq_suspend(rdev);\n\tr600_ih_ring_fini(rdev);\n}\n\n \nstatic inline u32 cik_get_ih_wptr(struct radeon_device *rdev)\n{\n\tu32 wptr, tmp;\n\n\tif (rdev->wb.enabled)\n\t\twptr = le32_to_cpu(rdev->wb.wb[R600_WB_IH_WPTR_OFFSET/4]);\n\telse\n\t\twptr = RREG32(IH_RB_WPTR);\n\n\tif (wptr & RB_OVERFLOW) {\n\t\twptr &= ~RB_OVERFLOW;\n\t\t \n\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);\n\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;\n\t\ttmp = RREG32(IH_RB_CNTL);\n\t\ttmp |= IH_WPTR_OVERFLOW_CLEAR;\n\t\tWREG32(IH_RB_CNTL, tmp);\n\t}\n\treturn (wptr & rdev->ih.ptr_mask);\n}\n\n \n \nint cik_irq_process(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *cp1_ring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\tstruct radeon_ring *cp2_ring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\tu32 wptr;\n\tu32 rptr;\n\tu32 src_id, src_data, ring_id;\n\tu8 me_id, pipe_id, queue_id;\n\tu32 ring_index;\n\tbool queue_hotplug = false;\n\tbool queue_dp = false;\n\tbool queue_reset = false;\n\tu32 addr, status, mc_client;\n\tbool queue_thermal = false;\n\n\tif (!rdev->ih.enabled || rdev->shutdown)\n\t\treturn IRQ_NONE;\n\n\twptr = cik_get_ih_wptr(rdev);\n\nrestart_ih:\n\t \n\tif (atomic_xchg(&rdev->ih.lock, 1))\n\t\treturn IRQ_NONE;\n\n\trptr = rdev->ih.rptr;\n\tDRM_DEBUG(\"cik_irq_process start: rptr %d, wptr %d\\n\", rptr, wptr);\n\n\t \n\trmb();\n\n\t \n\tcik_irq_ack(rdev);\n\n\twhile (rptr != wptr) {\n\t\t \n\t\tring_index = rptr / 4;\n\n\t\tsrc_id =  le32_to_cpu(rdev->ih.ring[ring_index]) & 0xff;\n\t\tsrc_data = le32_to_cpu(rdev->ih.ring[ring_index + 1]) & 0xfffffff;\n\t\tring_id = le32_to_cpu(rdev->ih.ring[ring_index + 2]) & 0xff;\n\n\t\tswitch (src_id) {\n\t\tcase 1:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int & LB_D1_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[0]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 0);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[0]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 0);\n\t\t\t\trdev->irq.stat_regs.cik.disp_int &= ~LB_D1_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D1 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int & LB_D1_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int &= ~LB_D1_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D1 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont & LB_D2_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[1]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 1);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[1]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 1);\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont &= ~LB_D2_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D2 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont & LB_D2_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont &= ~LB_D2_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D2 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont2 & LB_D3_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[2]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 2);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[2]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 2);\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont2 &= ~LB_D3_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D3 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont2 & LB_D3_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont2 &= ~LB_D3_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D3 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont3 & LB_D4_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[3]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 3);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[3]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 3);\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont3 &= ~LB_D4_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D4 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont3 & LB_D4_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont3 &= ~LB_D4_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D4 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont4 & LB_D5_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[4]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 4);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[4]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 4);\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont4 &= ~LB_D5_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D5 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont4 & LB_D5_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont4 &= ~LB_D5_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D5 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 6:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont5 & LB_D6_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[5]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 5);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[5]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 5);\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont5 &= ~LB_D6_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D6 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont5 & LB_D6_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont5 &= ~LB_D6_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D6 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:  \n\t\tcase 10:  \n\t\tcase 12:  \n\t\tcase 14:  \n\t\tcase 16:  \n\t\tcase 18:  \n\t\t\tDRM_DEBUG(\"IH: D%d flip\\n\", ((src_id - 8) >> 1) + 1);\n\t\t\tif (radeon_use_pflipirq > 0)\n\t\t\t\tradeon_crtc_handle_flip(rdev, (src_id - 8) >> 1);\n\t\t\tbreak;\n\t\tcase 42:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int & DC_HPD1_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int &= ~DC_HPD1_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD1\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont &= ~DC_HPD2_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD2\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD3\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD4\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD5\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD6\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int & DC_HPD1_RX_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int &= ~DC_HPD1_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD_RX 1\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_RX_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont &= ~DC_HPD2_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD_RX 2\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_RX_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont2 &= ~DC_HPD3_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD_RX 3\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_RX_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont3 &= ~DC_HPD4_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD_RX 4\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_RX_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont4 &= ~DC_HPD5_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD_RX 5\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tif (!(rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_RX_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.cik.disp_int_cont5 &= ~DC_HPD6_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD_RX 6\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 96:\n\t\t\tDRM_ERROR(\"SRBM_READ_ERROR: 0x%x\\n\", RREG32(SRBM_READ_ERROR));\n\t\t\tWREG32(SRBM_INT_ACK, 0x1);\n\t\t\tbreak;\n\t\tcase 124:  \n\t\t\tDRM_DEBUG(\"IH: UVD int: 0x%08x\\n\", src_data);\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_UVD_INDEX);\n\t\t\tbreak;\n\t\tcase 146:\n\t\tcase 147:\n\t\t\taddr = RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR);\n\t\t\tstatus = RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS);\n\t\t\tmc_client = RREG32(VM_CONTEXT1_PROTECTION_FAULT_MCCLIENT);\n\t\t\t \n\t\t\tWREG32_P(VM_CONTEXT1_CNTL2, 1, ~1);\n\t\t\tif (addr == 0x0 && status == 0x0)\n\t\t\t\tbreak;\n\t\t\tdev_err(rdev->dev, \"GPU fault detected: %d 0x%08x\\n\", src_id, src_data);\n\t\t\tdev_err(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t\t\taddr);\n\t\t\tdev_err(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t\t\tstatus);\n\t\t\tcik_vm_decode_fault(rdev, status, addr, mc_client);\n\t\t\tbreak;\n\t\tcase 167:  \n\t\t\tDRM_DEBUG(\"IH: VCE int: 0x%08x\\n\", src_data);\n\t\t\tswitch (src_data) {\n\t\t\tcase 0:\n\t\t\t\tradeon_fence_process(rdev, TN_RING_TYPE_VCE1_INDEX);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tradeon_fence_process(rdev, TN_RING_TYPE_VCE2_INDEX);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 176:  \n\t\tcase 177:  \n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\tbreak;\n\t\tcase 181:  \n\t\t\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\t\t\t \n\t\t\tme_id = (ring_id & 0x60) >> 5;\n\t\t\tpipe_id = (ring_id & 0x18) >> 3;\n\t\t\tqueue_id = (ring_id & 0x7) >> 0;\n\t\t\tswitch (me_id) {\n\t\t\tcase 0:\n\t\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\tif ((cp1_ring->me == me_id) & (cp1_ring->pipe == pipe_id))\n\t\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\t\t\t\tif ((cp2_ring->me == me_id) & (cp2_ring->pipe == pipe_id))\n\t\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 184:  \n\t\t\tDRM_ERROR(\"Illegal register access in command stream\\n\");\n\t\t\t \n\t\t\tme_id = (ring_id & 0x60) >> 5;\n\t\t\tswitch (me_id) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tqueue_reset = true;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tqueue_reset = true;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tqueue_reset = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 185:  \n\t\t\tDRM_ERROR(\"Illegal instruction in command stream\\n\");\n\t\t\t \n\t\t\tme_id = (ring_id & 0x60) >> 5;\n\t\t\tswitch (me_id) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tqueue_reset = true;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tqueue_reset = true;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tqueue_reset = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 224:  \n\t\t\t \n\t\t\tme_id = (ring_id & 0x3) >> 0;\n\t\t\tqueue_id = (ring_id & 0xc) >> 2;\n\t\t\tDRM_DEBUG(\"IH: SDMA trap\\n\");\n\t\t\tswitch (me_id) {\n\t\t\tcase 0:\n\t\t\t\tswitch (queue_id) {\n\t\t\t\tcase 0:\n\t\t\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_DMA_INDEX);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tswitch (queue_id) {\n\t\t\t\tcase 0:\n\t\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_DMA1_INDEX);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 230:  \n\t\t\tDRM_DEBUG(\"IH: thermal low to high\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = false;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 231:  \n\t\t\tDRM_DEBUG(\"IH: thermal high to low\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = true;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 233:  \n\t\t\tDRM_DEBUG(\"IH: GUI idle\\n\");\n\t\t\tbreak;\n\t\tcase 241:  \n\t\tcase 247:  \n\t\t\tDRM_ERROR(\"Illegal instruction in SDMA command stream\\n\");\n\t\t\t \n\t\t\tme_id = (ring_id & 0x3) >> 0;\n\t\t\tqueue_id = (ring_id & 0xc) >> 2;\n\t\t\tswitch (me_id) {\n\t\t\tcase 0:\n\t\t\t\tswitch (queue_id) {\n\t\t\t\tcase 0:\n\t\t\t\t\tqueue_reset = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t \n\t\t\t\t\tqueue_reset = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t \n\t\t\t\t\tqueue_reset = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tswitch (queue_id) {\n\t\t\t\tcase 0:\n\t\t\t\t\tqueue_reset = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\t \n\t\t\t\t\tqueue_reset = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t \n\t\t\t\t\tqueue_reset = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trptr += 16;\n\t\trptr &= rdev->ih.ptr_mask;\n\t\tWREG32(IH_RB_RPTR, rptr);\n\t}\n\tif (queue_dp)\n\t\tschedule_work(&rdev->dp_work);\n\tif (queue_hotplug)\n\t\tschedule_delayed_work(&rdev->hotplug_work, 0);\n\tif (queue_reset) {\n\t\trdev->needs_reset = true;\n\t\twake_up_all(&rdev->fence_queue);\n\t}\n\tif (queue_thermal)\n\t\tschedule_work(&rdev->pm.dpm.thermal.work);\n\trdev->ih.rptr = rptr;\n\tatomic_set(&rdev->ih.lock, 0);\n\n\t \n\twptr = cik_get_ih_wptr(rdev);\n\tif (wptr != rptr)\n\t\tgoto restart_ih;\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void cik_uvd_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = radeon_uvd_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_uvd = false;\n\t\treturn;\n\t}\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[R600_RING_TYPE_UVD_INDEX], 4096);\n}\n\nstatic void cik_uvd_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = radeon_uvd_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = uvd_v4_2_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD 4.2 resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_UVD_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size = 0;\n}\n\nstatic void cik_uvd_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_uvd || !rdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, PACKET0(UVD_NO_OP, 0));\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = uvd_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic void cik_vce_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_vce)\n\t\treturn;\n\n\tr = radeon_vce_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_vce = false;\n\t\treturn;\n\t}\n\trdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[TN_RING_TYPE_VCE1_INDEX], 4096);\n\trdev->ring[TN_RING_TYPE_VCE2_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[TN_RING_TYPE_VCE2_INDEX], 4096);\n}\n\nstatic void cik_vce_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_vce)\n\t\treturn;\n\n\tr = radeon_vce_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = vce_v2_0_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, TN_RING_TYPE_VCE1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, TN_RING_TYPE_VCE2_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE2 fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_size = 0;\n\trdev->ring[TN_RING_TYPE_VCE2_INDEX].ring_size = 0;\n}\n\nstatic void cik_vce_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_vce || !rdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, VCE_CMD_NO_OP);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, VCE_CMD_NO_OP);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = vce_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\n \nstatic int cik_startup(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tu32 nop;\n\tint r;\n\n\t \n\tcik_pcie_gen3_enable(rdev);\n\t \n\tcik_program_aspm(rdev);\n\n\t \n\tr = r600_vram_scratch_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tcik_mc_program(rdev);\n\n\tif (!(rdev->flags & RADEON_IS_IGP) && !rdev->pm.dpm_enabled) {\n\t\tr = ci_mc_load_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load MC firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = cik_pcie_gart_enable(rdev);\n\tif (r)\n\t\treturn r;\n\tcik_gpu_init(rdev);\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tif (rdev->family == CHIP_KAVERI) {\n\t\t\trdev->rlc.reg_list = spectre_rlc_save_restore_register_list;\n\t\t\trdev->rlc.reg_list_size =\n\t\t\t\t(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);\n\t\t} else {\n\t\t\trdev->rlc.reg_list = kalindi_rlc_save_restore_register_list;\n\t\t\trdev->rlc.reg_list_size =\n\t\t\t\t(u32)ARRAY_SIZE(kalindi_rlc_save_restore_register_list);\n\t\t}\n\t}\n\trdev->rlc.cs_data = ci_cs_data;\n\trdev->rlc.cp_table_size = ALIGN(CP_ME_TABLE_SIZE * 5 * 4, 2048);  \n\trdev->rlc.cp_table_size += 64 * 1024;  \n\tr = sumo_rlc_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = cik_mec_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to init MEC BOs!\\n\");\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_DMA_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_DMA1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tcik_uvd_start(rdev);\n\tcik_vce_start(rdev);\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = cik_irq_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: IH init failed (%d).\\n\", r);\n\t\tradeon_irq_kms_fini(rdev);\n\t\treturn r;\n\t}\n\tcik_irq_set(rdev);\n\n\tif (rdev->family == CHIP_HAWAII) {\n\t\tif (rdev->new_fw)\n\t\t\tnop = PACKET3(PACKET3_NOP, 0x3FFF);\n\t\telse\n\t\t\tnop = RADEON_CP_PACKET2;\n\t} else {\n\t\tnop = PACKET3(PACKET3_NOP, 0x3FFF);\n\t}\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,\n\t\t\t     nop);\n\tif (r)\n\t\treturn r;\n\n\t \n\t \n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP1_RPTR_OFFSET,\n\t\t\t     nop);\n\tif (r)\n\t\treturn r;\n\tring->me = 1;  \n\tring->pipe = 0;  \n\tring->queue = 0;  \n\tring->wptr_offs = CIK_WB_CP1_WPTR_OFFSET;\n\n\t \n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP2_RPTR_OFFSET,\n\t\t\t     nop);\n\tif (r)\n\t\treturn r;\n\t \n\tring->me = 1;  \n\tring->pipe = 0;  \n\tring->queue = 1;  \n\tring->wptr_offs = CIK_WB_CP2_WPTR_OFFSET;\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,\n\t\t\t     SDMA_PACKET(SDMA_OPCODE_NOP, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, CAYMAN_WB_DMA1_RPTR_OFFSET,\n\t\t\t     SDMA_PACKET(SDMA_OPCODE_NOP, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tr = cik_cp_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = cik_sdma_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tcik_uvd_resume(rdev);\n\tcik_vce_resume(rdev);\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_vm_manager_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"vm manager initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\n \nint cik_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\n\t \n\tcik_init_golden_registers(rdev);\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_resume(rdev);\n\n\trdev->accel_working = true;\n\tr = cik_startup(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"cik startup failed on resume\\n\");\n\t\trdev->accel_working = false;\n\t\treturn r;\n\t}\n\n\treturn r;\n\n}\n\n \nint cik_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tradeon_vm_manager_fini(rdev);\n\tcik_cp_enable(rdev, false);\n\tcik_sdma_enable(rdev, false);\n\tif (rdev->has_uvd) {\n\t\tradeon_uvd_suspend(rdev);\n\t\tuvd_v1_0_fini(rdev);\n\t}\n\tif (rdev->has_vce)\n\t\tradeon_vce_suspend(rdev);\n\tcik_fini_pg(rdev);\n\tcik_fini_cg(rdev);\n\tcik_irq_suspend(rdev);\n\tradeon_wb_disable(rdev);\n\tcik_pcie_gart_disable(rdev);\n\treturn 0;\n}\n\n \n \nint cik_init(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting atombios for cayman GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_atombios_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (!radeon_card_posted(rdev)) {\n\t\tif (!rdev->bios) {\n\t\t\tdev_err(rdev->dev, \"Card not posted and no BIOS - ignoring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDRM_INFO(\"GPU not posted. posting now...\\n\");\n\t\tatom_asic_init(rdev->mode_info.atom_context);\n\t}\n\t \n\tcik_init_golden_registers(rdev);\n\t \n\tcik_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\n\t \n\tradeon_fence_driver_init(rdev);\n\n\t \n\tr = cik_mc_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->ce_fw ||\n\t\t    !rdev->mec_fw || !rdev->sdma_fw || !rdev->rlc_fw) {\n\t\t\tr = cik_init_microcode(rdev);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->ce_fw ||\n\t\t    !rdev->mec_fw || !rdev->sdma_fw || !rdev->rlc_fw ||\n\t\t    !rdev->mc_fw) {\n\t\t\tr = cik_init_microcode(rdev);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tradeon_pm_init(rdev);\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP1_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\tr = radeon_doorbell_get(rdev, &ring->doorbell_index);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_CP2_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\tr = radeon_doorbell_get(rdev, &ring->doorbell_index);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 256 * 1024);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 256 * 1024);\n\n\tcik_uvd_init(rdev);\n\tcik_vce_init(rdev);\n\n\trdev->ih.ring_obj = NULL;\n\tr600_ih_ring_init(rdev, 64 * 1024);\n\n\tr = r600_pcie_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\trdev->accel_working = true;\n\tr = cik_startup(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"disabling GPU acceleration\\n\");\n\t\tcik_cp_fini(rdev);\n\t\tcik_sdma_fini(rdev);\n\t\tcik_irq_fini(rdev);\n\t\tsumo_rlc_fini(rdev);\n\t\tcik_mec_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_vm_manager_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tcik_pcie_gart_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\n\t \n\tif (!rdev->mc_fw && !(rdev->flags & RADEON_IS_IGP)) {\n\t\tDRM_ERROR(\"radeon: MC ucode required for NI+.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid cik_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tcik_cp_fini(rdev);\n\tcik_sdma_fini(rdev);\n\tcik_fini_pg(rdev);\n\tcik_fini_cg(rdev);\n\tcik_irq_fini(rdev);\n\tsumo_rlc_fini(rdev);\n\tcik_mec_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_vm_manager_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tuvd_v1_0_fini(rdev);\n\tradeon_uvd_fini(rdev);\n\tradeon_vce_fini(rdev);\n\tcik_pcie_gart_fini(rdev);\n\tr600_vram_scratch_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nvoid dce8_program_fmt(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tint bpc = 0;\n\tu32 tmp = 0;\n\tenum radeon_connector_dither dither = RADEON_FMT_DITHER_DISABLE;\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tbpc = radeon_get_monitor_bpc(connector);\n\t\tdither = radeon_connector->dither;\n\t}\n\n\t \n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD_SUPPORT)\n\t\treturn;\n\n\t \n\tif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1) ||\n\t    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2))\n\t\treturn;\n\n\tif (bpc == 0)\n\t\treturn;\n\n\tswitch (bpc) {\n\tcase 6:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (FMT_FRAME_RANDOM_ENABLE | FMT_HIGHPASS_RANDOM_ENABLE |\n\t\t\t\tFMT_SPATIAL_DITHER_EN | FMT_SPATIAL_DITHER_DEPTH(0));\n\t\telse\n\t\t\ttmp |= (FMT_TRUNCATE_EN | FMT_TRUNCATE_DEPTH(0));\n\t\tbreak;\n\tcase 8:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (FMT_FRAME_RANDOM_ENABLE | FMT_HIGHPASS_RANDOM_ENABLE |\n\t\t\t\tFMT_RGB_RANDOM_ENABLE |\n\t\t\t\tFMT_SPATIAL_DITHER_EN | FMT_SPATIAL_DITHER_DEPTH(1));\n\t\telse\n\t\t\ttmp |= (FMT_TRUNCATE_EN | FMT_TRUNCATE_DEPTH(1));\n\t\tbreak;\n\tcase 10:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (FMT_FRAME_RANDOM_ENABLE | FMT_HIGHPASS_RANDOM_ENABLE |\n\t\t\t\tFMT_RGB_RANDOM_ENABLE |\n\t\t\t\tFMT_SPATIAL_DITHER_EN | FMT_SPATIAL_DITHER_DEPTH(2));\n\t\telse\n\t\t\ttmp |= (FMT_TRUNCATE_EN | FMT_TRUNCATE_DEPTH(2));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tWREG32(FMT_BIT_DEPTH_CONTROL + radeon_crtc->crtc_offset, tmp);\n}\n\n \n \nstatic u32 dce8_line_buffer_adjust(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_crtc *radeon_crtc,\n\t\t\t\t   struct drm_display_mode *mode)\n{\n\tu32 tmp, buffer_alloc, i;\n\tu32 pipe_offset = radeon_crtc->crtc_id * 0x20;\n\t \n\tif (radeon_crtc->base.enabled && mode) {\n\t\tif (mode->crtc_hdisplay < 1920) {\n\t\t\ttmp = 1;\n\t\t\tbuffer_alloc = 2;\n\t\t} else if (mode->crtc_hdisplay < 2560) {\n\t\t\ttmp = 2;\n\t\t\tbuffer_alloc = 2;\n\t\t} else if (mode->crtc_hdisplay < 4096) {\n\t\t\ttmp = 0;\n\t\t\tbuffer_alloc = (rdev->flags & RADEON_IS_IGP) ? 2 : 4;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"Mode too big for LB!\\n\");\n\t\t\ttmp = 0;\n\t\t\tbuffer_alloc = (rdev->flags & RADEON_IS_IGP) ? 2 : 4;\n\t\t}\n\t} else {\n\t\ttmp = 1;\n\t\tbuffer_alloc = 0;\n\t}\n\n\tWREG32(LB_MEMORY_CTRL + radeon_crtc->crtc_offset,\n\t       LB_MEMORY_CONFIG(tmp) | LB_MEMORY_SIZE(0x6B0));\n\n\tWREG32(PIPE0_DMIF_BUFFER_CONTROL + pipe_offset,\n\t       DMIF_BUFFERS_ALLOCATED(buffer_alloc));\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(PIPE0_DMIF_BUFFER_CONTROL + pipe_offset) &\n\t\t    DMIF_BUFFERS_ALLOCATED_COMPLETED)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (radeon_crtc->base.enabled && mode) {\n\t\tswitch (tmp) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\treturn 4096 * 2;\n\t\tcase 1:\n\t\t\treturn 1920 * 2;\n\t\tcase 2:\n\t\t\treturn 2560 * 2;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic u32 cik_get_number_of_dram_channels(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(MC_SHARED_CHMAP);\n\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\treturn 1;\n\tcase 1:\n\t\treturn 2;\n\tcase 2:\n\t\treturn 4;\n\tcase 3:\n\t\treturn 8;\n\tcase 4:\n\t\treturn 3;\n\tcase 5:\n\t\treturn 6;\n\tcase 6:\n\t\treturn 10;\n\tcase 7:\n\t\treturn 12;\n\tcase 8:\n\t\treturn 16;\n\t}\n}\n\nstruct dce8_wm_params {\n\tu32 dram_channels;  \n\tu32 yclk;           \n\tu32 sclk;           \n\tu32 disp_clk;       \n\tu32 src_width;      \n\tu32 active_time;    \n\tu32 blank_time;     \n\tbool interlaced;     \n\tfixed20_12 vsc;     \n\tu32 num_heads;      \n\tu32 bytes_per_pixel;  \n\tu32 lb_size;        \n\tu32 vtaps;          \n};\n\n \nstatic u32 dce8_dram_bandwidth(struct dce8_wm_params *wm)\n{\n\t \n\tfixed20_12 dram_efficiency;  \n\tfixed20_12 yclk, dram_channels, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tyclk.full = dfixed_const(wm->yclk);\n\tyclk.full = dfixed_div(yclk, a);\n\tdram_channels.full = dfixed_const(wm->dram_channels * 4);\n\ta.full = dfixed_const(10);\n\tdram_efficiency.full = dfixed_const(7);\n\tdram_efficiency.full = dfixed_div(dram_efficiency, a);\n\tbandwidth.full = dfixed_mul(dram_channels, yclk);\n\tbandwidth.full = dfixed_mul(bandwidth, dram_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\n \nstatic u32 dce8_dram_bandwidth_for_display(struct dce8_wm_params *wm)\n{\n\t \n\tfixed20_12 disp_dram_allocation;  \n\tfixed20_12 yclk, dram_channels, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tyclk.full = dfixed_const(wm->yclk);\n\tyclk.full = dfixed_div(yclk, a);\n\tdram_channels.full = dfixed_const(wm->dram_channels * 4);\n\ta.full = dfixed_const(10);\n\tdisp_dram_allocation.full = dfixed_const(3);  \n\tdisp_dram_allocation.full = dfixed_div(disp_dram_allocation, a);\n\tbandwidth.full = dfixed_mul(dram_channels, yclk);\n\tbandwidth.full = dfixed_mul(bandwidth, disp_dram_allocation);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\n \nstatic u32 dce8_data_return_bandwidth(struct dce8_wm_params *wm)\n{\n\t \n\tfixed20_12 return_efficiency;  \n\tfixed20_12 sclk, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tsclk.full = dfixed_const(wm->sclk);\n\tsclk.full = dfixed_div(sclk, a);\n\ta.full = dfixed_const(10);\n\treturn_efficiency.full = dfixed_const(8);\n\treturn_efficiency.full = dfixed_div(return_efficiency, a);\n\ta.full = dfixed_const(32);\n\tbandwidth.full = dfixed_mul(a, sclk);\n\tbandwidth.full = dfixed_mul(bandwidth, return_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\n \nstatic u32 dce8_dmif_request_bandwidth(struct dce8_wm_params *wm)\n{\n\t \n\tfixed20_12 disp_clk_request_efficiency;  \n\tfixed20_12 disp_clk, bandwidth;\n\tfixed20_12 a, b;\n\n\ta.full = dfixed_const(1000);\n\tdisp_clk.full = dfixed_const(wm->disp_clk);\n\tdisp_clk.full = dfixed_div(disp_clk, a);\n\ta.full = dfixed_const(32);\n\tb.full = dfixed_mul(a, disp_clk);\n\n\ta.full = dfixed_const(10);\n\tdisp_clk_request_efficiency.full = dfixed_const(8);\n\tdisp_clk_request_efficiency.full = dfixed_div(disp_clk_request_efficiency, a);\n\n\tbandwidth.full = dfixed_mul(b, disp_clk_request_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\n \nstatic u32 dce8_available_bandwidth(struct dce8_wm_params *wm)\n{\n\t \n\tu32 dram_bandwidth = dce8_dram_bandwidth(wm);\n\tu32 data_return_bandwidth = dce8_data_return_bandwidth(wm);\n\tu32 dmif_req_bandwidth = dce8_dmif_request_bandwidth(wm);\n\n\treturn min(dram_bandwidth, min(data_return_bandwidth, dmif_req_bandwidth));\n}\n\n \nstatic u32 dce8_average_bandwidth(struct dce8_wm_params *wm)\n{\n\t \n\tfixed20_12 bpp;\n\tfixed20_12 line_time;\n\tfixed20_12 src_width;\n\tfixed20_12 bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tline_time.full = dfixed_const(wm->active_time + wm->blank_time);\n\tline_time.full = dfixed_div(line_time, a);\n\tbpp.full = dfixed_const(wm->bytes_per_pixel);\n\tsrc_width.full = dfixed_const(wm->src_width);\n\tbandwidth.full = dfixed_mul(src_width, bpp);\n\tbandwidth.full = dfixed_mul(bandwidth, wm->vsc);\n\tbandwidth.full = dfixed_div(bandwidth, line_time);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\n \nstatic u32 dce8_latency_watermark(struct dce8_wm_params *wm)\n{\n\t \n\tu32 mc_latency = 2000;  \n\tu32 available_bandwidth = dce8_available_bandwidth(wm);\n\tu32 worst_chunk_return_time = (512 * 8 * 1000) / available_bandwidth;\n\tu32 cursor_line_pair_return_time = (128 * 4 * 1000) / available_bandwidth;\n\tu32 dc_latency = 40000000 / wm->disp_clk;  \n\tu32 other_heads_data_return_time = ((wm->num_heads + 1) * worst_chunk_return_time) +\n\t\t(wm->num_heads * cursor_line_pair_return_time);\n\tu32 latency = mc_latency + other_heads_data_return_time + dc_latency;\n\tu32 max_src_lines_per_dst_line, lb_fill_bw, line_fill_time;\n\tu32 tmp, dmif_size = 12288;\n\tfixed20_12 a, b, c;\n\n\tif (wm->num_heads == 0)\n\t\treturn 0;\n\n\ta.full = dfixed_const(2);\n\tb.full = dfixed_const(1);\n\tif ((wm->vsc.full > a.full) ||\n\t    ((wm->vsc.full > b.full) && (wm->vtaps >= 3)) ||\n\t    (wm->vtaps >= 5) ||\n\t    ((wm->vsc.full >= a.full) && wm->interlaced))\n\t\tmax_src_lines_per_dst_line = 4;\n\telse\n\t\tmax_src_lines_per_dst_line = 2;\n\n\ta.full = dfixed_const(available_bandwidth);\n\tb.full = dfixed_const(wm->num_heads);\n\ta.full = dfixed_div(a, b);\n\ttmp = div_u64((u64) dmif_size * (u64) wm->disp_clk, mc_latency + 512);\n\ttmp = min(dfixed_trunc(a), tmp);\n\n\tlb_fill_bw = min(tmp, wm->disp_clk * wm->bytes_per_pixel / 1000);\n\n\ta.full = dfixed_const(max_src_lines_per_dst_line * wm->src_width * wm->bytes_per_pixel);\n\tb.full = dfixed_const(1000);\n\tc.full = dfixed_const(lb_fill_bw);\n\tb.full = dfixed_div(c, b);\n\ta.full = dfixed_div(a, b);\n\tline_fill_time = dfixed_trunc(a);\n\n\tif (line_fill_time < wm->active_time)\n\t\treturn latency;\n\telse\n\t\treturn latency + (line_fill_time - wm->active_time);\n\n}\n\n \nstatic bool dce8_average_bandwidth_vs_dram_bandwidth_for_display(struct dce8_wm_params *wm)\n{\n\tif (dce8_average_bandwidth(wm) <=\n\t    (dce8_dram_bandwidth_for_display(wm) / wm->num_heads))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic bool dce8_average_bandwidth_vs_available_bandwidth(struct dce8_wm_params *wm)\n{\n\tif (dce8_average_bandwidth(wm) <=\n\t    (dce8_available_bandwidth(wm) / wm->num_heads))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic bool dce8_check_latency_hiding(struct dce8_wm_params *wm)\n{\n\tu32 lb_partitions = wm->lb_size / wm->src_width;\n\tu32 line_time = wm->active_time + wm->blank_time;\n\tu32 latency_tolerant_lines;\n\tu32 latency_hiding;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1);\n\tif (wm->vsc.full > a.full)\n\t\tlatency_tolerant_lines = 1;\n\telse {\n\t\tif (lb_partitions <= (wm->vtaps + 1))\n\t\t\tlatency_tolerant_lines = 1;\n\t\telse\n\t\t\tlatency_tolerant_lines = 2;\n\t}\n\n\tlatency_hiding = (latency_tolerant_lines * line_time + wm->blank_time);\n\n\tif (dce8_latency_watermark(wm) <= latency_hiding)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nstatic void dce8_program_watermarks(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_crtc *radeon_crtc,\n\t\t\t\t    u32 lb_size, u32 num_heads)\n{\n\tstruct drm_display_mode *mode = &radeon_crtc->base.mode;\n\tstruct dce8_wm_params wm_low, wm_high;\n\tu32 active_time;\n\tu32 line_time = 0;\n\tu32 latency_watermark_a = 0, latency_watermark_b = 0;\n\tu32 tmp, wm_mask;\n\n\tif (radeon_crtc->base.enabled && num_heads && mode) {\n\t\tactive_time = (u32) div_u64((u64)mode->crtc_hdisplay * 1000000,\n\t\t\t\t\t    (u32)mode->clock);\n\t\tline_time = (u32) div_u64((u64)mode->crtc_htotal * 1000000,\n\t\t\t\t\t  (u32)mode->clock);\n\t\tline_time = min(line_time, (u32)65535);\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) &&\n\t\t    rdev->pm.dpm_enabled) {\n\t\t\twm_high.yclk =\n\t\t\t\tradeon_dpm_get_mclk(rdev, false) * 10;\n\t\t\twm_high.sclk =\n\t\t\t\tradeon_dpm_get_sclk(rdev, false) * 10;\n\t\t} else {\n\t\t\twm_high.yclk = rdev->pm.current_mclk * 10;\n\t\t\twm_high.sclk = rdev->pm.current_sclk * 10;\n\t\t}\n\n\t\twm_high.disp_clk = mode->clock;\n\t\twm_high.src_width = mode->crtc_hdisplay;\n\t\twm_high.active_time = active_time;\n\t\twm_high.blank_time = line_time - wm_high.active_time;\n\t\twm_high.interlaced = false;\n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\twm_high.interlaced = true;\n\t\twm_high.vsc = radeon_crtc->vsc;\n\t\twm_high.vtaps = 1;\n\t\tif (radeon_crtc->rmx_type != RMX_OFF)\n\t\t\twm_high.vtaps = 2;\n\t\twm_high.bytes_per_pixel = 4;  \n\t\twm_high.lb_size = lb_size;\n\t\twm_high.dram_channels = cik_get_number_of_dram_channels(rdev);\n\t\twm_high.num_heads = num_heads;\n\n\t\t \n\t\tlatency_watermark_a = min(dce8_latency_watermark(&wm_high), (u32)65535);\n\n\t\t \n\t\t \n\t\tif (!dce8_average_bandwidth_vs_dram_bandwidth_for_display(&wm_high) ||\n\t\t    !dce8_average_bandwidth_vs_available_bandwidth(&wm_high) ||\n\t\t    !dce8_check_latency_hiding(&wm_high) ||\n\t\t    (rdev->disp_priority == 2)) {\n\t\t\tDRM_DEBUG_KMS(\"force priority to high\\n\");\n\t\t}\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) &&\n\t\t    rdev->pm.dpm_enabled) {\n\t\t\twm_low.yclk =\n\t\t\t\tradeon_dpm_get_mclk(rdev, true) * 10;\n\t\t\twm_low.sclk =\n\t\t\t\tradeon_dpm_get_sclk(rdev, true) * 10;\n\t\t} else {\n\t\t\twm_low.yclk = rdev->pm.current_mclk * 10;\n\t\t\twm_low.sclk = rdev->pm.current_sclk * 10;\n\t\t}\n\n\t\twm_low.disp_clk = mode->clock;\n\t\twm_low.src_width = mode->crtc_hdisplay;\n\t\twm_low.active_time = active_time;\n\t\twm_low.blank_time = line_time - wm_low.active_time;\n\t\twm_low.interlaced = false;\n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\twm_low.interlaced = true;\n\t\twm_low.vsc = radeon_crtc->vsc;\n\t\twm_low.vtaps = 1;\n\t\tif (radeon_crtc->rmx_type != RMX_OFF)\n\t\t\twm_low.vtaps = 2;\n\t\twm_low.bytes_per_pixel = 4;  \n\t\twm_low.lb_size = lb_size;\n\t\twm_low.dram_channels = cik_get_number_of_dram_channels(rdev);\n\t\twm_low.num_heads = num_heads;\n\n\t\t \n\t\tlatency_watermark_b = min(dce8_latency_watermark(&wm_low), (u32)65535);\n\n\t\t \n\t\t \n\t\tif (!dce8_average_bandwidth_vs_dram_bandwidth_for_display(&wm_low) ||\n\t\t    !dce8_average_bandwidth_vs_available_bandwidth(&wm_low) ||\n\t\t    !dce8_check_latency_hiding(&wm_low) ||\n\t\t    (rdev->disp_priority == 2)) {\n\t\t\tDRM_DEBUG_KMS(\"force priority to high\\n\");\n\t\t}\n\n\t\t \n\t\tradeon_crtc->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode->crtc_hdisplay);\n\t}\n\n\t \n\twm_mask = RREG32(DPG_WATERMARK_MASK_CONTROL + radeon_crtc->crtc_offset);\n\ttmp = wm_mask;\n\ttmp &= ~LATENCY_WATERMARK_MASK(3);\n\ttmp |= LATENCY_WATERMARK_MASK(1);\n\tWREG32(DPG_WATERMARK_MASK_CONTROL + radeon_crtc->crtc_offset, tmp);\n\tWREG32(DPG_PIPE_LATENCY_CONTROL + radeon_crtc->crtc_offset,\n\t       (LATENCY_LOW_WATERMARK(latency_watermark_a) |\n\t\tLATENCY_HIGH_WATERMARK(line_time)));\n\t \n\ttmp = RREG32(DPG_WATERMARK_MASK_CONTROL + radeon_crtc->crtc_offset);\n\ttmp &= ~LATENCY_WATERMARK_MASK(3);\n\ttmp |= LATENCY_WATERMARK_MASK(2);\n\tWREG32(DPG_WATERMARK_MASK_CONTROL + radeon_crtc->crtc_offset, tmp);\n\tWREG32(DPG_PIPE_LATENCY_CONTROL + radeon_crtc->crtc_offset,\n\t       (LATENCY_LOW_WATERMARK(latency_watermark_b) |\n\t\tLATENCY_HIGH_WATERMARK(line_time)));\n\t \n\tWREG32(DPG_WATERMARK_MASK_CONTROL + radeon_crtc->crtc_offset, wm_mask);\n\n\t \n\tradeon_crtc->line_time = line_time;\n\tradeon_crtc->wm_high = latency_watermark_a;\n\tradeon_crtc->wm_low = latency_watermark_b;\n}\n\n \nvoid dce8_bandwidth_update(struct radeon_device *rdev)\n{\n\tstruct drm_display_mode *mode = NULL;\n\tu32 num_heads = 0, lb_size;\n\tint i;\n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (rdev->mode_info.crtcs[i]->base.enabled)\n\t\t\tnum_heads++;\n\t}\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tmode = &rdev->mode_info.crtcs[i]->base.mode;\n\t\tlb_size = dce8_line_buffer_adjust(rdev, rdev->mode_info.crtcs[i], mode);\n\t\tdce8_program_watermarks(rdev, rdev->mode_info.crtcs[i], lb_size, num_heads);\n\t}\n}\n\n \nuint64_t cik_get_gpu_clock_counter(struct radeon_device *rdev)\n{\n\tuint64_t clock;\n\n\tmutex_lock(&rdev->gpu_clock_mutex);\n\tWREG32(RLC_CAPTURE_GPU_CLOCK_COUNT, 1);\n\tclock = (uint64_t)RREG32(RLC_GPU_CLOCK_COUNT_LSB) |\n\t\t((uint64_t)RREG32(RLC_GPU_CLOCK_COUNT_MSB) << 32ULL);\n\tmutex_unlock(&rdev->gpu_clock_mutex);\n\treturn clock;\n}\n\nstatic int cik_set_uvd_clock(struct radeon_device *rdev, u32 clock,\n\t\t\t     u32 cntl_reg, u32 status_reg)\n{\n\tint r, i;\n\tstruct atom_clock_dividers dividers;\n\tuint32_t tmp;\n\n\tr = radeon_atom_get_clock_dividers(rdev, COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\t\t\t   clock, false, &dividers);\n\tif (r)\n\t\treturn r;\n\n\ttmp = RREG32_SMC(cntl_reg);\n\ttmp &= ~(DCLK_DIR_CNTL_EN|DCLK_DIVIDER_MASK);\n\ttmp |= dividers.post_divider;\n\tWREG32_SMC(cntl_reg, tmp);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (RREG32_SMC(status_reg) & DCLK_STATUS)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (i == 100)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint cik_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk)\n{\n\tint r = 0;\n\n\tr = cik_set_uvd_clock(rdev, vclk, CG_VCLK_CNTL, CG_VCLK_STATUS);\n\tif (r)\n\t\treturn r;\n\n\tr = cik_set_uvd_clock(rdev, dclk, CG_DCLK_CNTL, CG_DCLK_STATUS);\n\treturn r;\n}\n\nint cik_set_vce_clocks(struct radeon_device *rdev, u32 evclk, u32 ecclk)\n{\n\tint r, i;\n\tstruct atom_clock_dividers dividers;\n\tu32 tmp;\n\n\tr = radeon_atom_get_clock_dividers(rdev, COMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\t\t\t   ecclk, false, &dividers);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (RREG32_SMC(CG_ECLK_STATUS) & ECLK_STATUS)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (i == 100)\n\t\treturn -ETIMEDOUT;\n\n\ttmp = RREG32_SMC(CG_ECLK_CNTL);\n\ttmp &= ~(ECLK_DIR_CNTL_EN|ECLK_DIVIDER_MASK);\n\ttmp |= dividers.post_divider;\n\tWREG32_SMC(CG_ECLK_CNTL, tmp);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (RREG32_SMC(CG_ECLK_STATUS) & ECLK_STATUS)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (i == 100)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void cik_pcie_gen3_enable(struct radeon_device *rdev)\n{\n\tstruct pci_dev *root = rdev->pdev->bus->self;\n\tenum pci_bus_speed speed_cap;\n\tu32 speed_cntl, current_data_rate;\n\tint i;\n\tu16 tmp16;\n\n\tif (pci_is_root_bus(rdev->pdev->bus))\n\t\treturn;\n\n\tif (radeon_pcie_gen2 == 0)\n\t\treturn;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\tspeed_cap = pcie_get_speed_cap(root);\n\tif (speed_cap == PCI_SPEED_UNKNOWN)\n\t\treturn;\n\n\tif ((speed_cap != PCIE_SPEED_8_0GT) &&\n\t    (speed_cap != PCIE_SPEED_5_0GT))\n\t\treturn;\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tcurrent_data_rate = (speed_cntl & LC_CURRENT_DATA_RATE_MASK) >>\n\t\tLC_CURRENT_DATA_RATE_SHIFT;\n\tif (speed_cap == PCIE_SPEED_8_0GT) {\n\t\tif (current_data_rate == 2) {\n\t\t\tDRM_INFO(\"PCIE gen 3 link speeds already enabled\\n\");\n\t\t\treturn;\n\t\t}\n\t\tDRM_INFO(\"enabling PCIE gen 3 link speeds, disable with radeon.pcie_gen2=0\\n\");\n\t} else if (speed_cap == PCIE_SPEED_5_0GT) {\n\t\tif (current_data_rate == 1) {\n\t\t\tDRM_INFO(\"PCIE gen 2 link speeds already enabled\\n\");\n\t\t\treturn;\n\t\t}\n\t\tDRM_INFO(\"enabling PCIE gen 2 link speeds, disable with radeon.pcie_gen2=0\\n\");\n\t}\n\n\tif (!pci_is_pcie(root) || !pci_is_pcie(rdev->pdev))\n\t\treturn;\n\n\tif (speed_cap == PCIE_SPEED_8_0GT) {\n\t\t \n\t\tif (current_data_rate != 2) {\n\t\t\tu16 bridge_cfg, gpu_cfg;\n\t\t\tu16 bridge_cfg2, gpu_cfg2;\n\t\t\tu32 max_lw, current_lw, tmp;\n\n\t\t\tpcie_capability_set_word(root, PCI_EXP_LNKCTL, PCI_EXP_LNKCTL_HAWD);\n\t\t\tpcie_capability_set_word(rdev->pdev, PCI_EXP_LNKCTL, PCI_EXP_LNKCTL_HAWD);\n\n\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_STATUS1);\n\t\t\tmax_lw = (tmp & LC_DETECTED_LINK_WIDTH_MASK) >> LC_DETECTED_LINK_WIDTH_SHIFT;\n\t\t\tcurrent_lw = (tmp & LC_OPERATING_LINK_WIDTH_MASK) >> LC_OPERATING_LINK_WIDTH_SHIFT;\n\n\t\t\tif (current_lw < max_lw) {\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t\t\tif (tmp & LC_RENEGOTIATION_SUPPORT) {\n\t\t\t\t\ttmp &= ~(LC_LINK_WIDTH_MASK | LC_UPCONFIGURE_DIS);\n\t\t\t\t\ttmp |= (max_lw << LC_LINK_WIDTH_SHIFT);\n\t\t\t\t\ttmp |= LC_UPCONFIGURE_SUPPORT | LC_RENEGOTIATE_EN | LC_RECONFIG_NOW;\n\t\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 10; i++) {\n\t\t\t\t \n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_DEVSTA,\n\t\t\t\t\t\t\t  &tmp16);\n\t\t\t\tif (tmp16 & PCI_EXP_DEVSTA_TRPND)\n\t\t\t\t\tbreak;\n\n\t\t\t\tpcie_capability_read_word(root, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t  &bridge_cfg);\n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t  &gpu_cfg);\n\n\t\t\t\tpcie_capability_read_word(root, PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &bridge_cfg2);\n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &gpu_cfg2);\n\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL4);\n\t\t\t\ttmp |= LC_SET_QUIESCE;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL4, tmp);\n\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL4);\n\t\t\t\ttmp |= LC_REDO_EQ;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL4, tmp);\n\n\t\t\t\tmsleep(100);\n\n\t\t\t\t \n\t\t\t\tpcie_capability_clear_and_set_word(root, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD,\n\t\t\t\t\t\t\t\t   bridge_cfg &\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD);\n\t\t\t\tpcie_capability_clear_and_set_word(rdev->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD,\n\t\t\t\t\t\t\t\t   gpu_cfg &\n\t\t\t\t\t\t\t\t   PCI_EXP_LNKCTL_HAWD);\n\n\t\t\t\t \n\t\t\t\tpcie_capability_read_word(root, PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &tmp16);\n\t\t\t\ttmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN);\n\t\t\t\ttmp16 |= (bridge_cfg2 &\n\t\t\t\t\t  (PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN));\n\t\t\t\tpcie_capability_write_word(root,\n\t\t\t\t\t\t\t   PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t   tmp16);\n\n\t\t\t\tpcie_capability_read_word(rdev->pdev,\n\t\t\t\t\t\t\t  PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t  &tmp16);\n\t\t\t\ttmp16 &= ~(PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN);\n\t\t\t\ttmp16 |= (gpu_cfg2 &\n\t\t\t\t\t  (PCI_EXP_LNKCTL2_ENTER_COMP |\n\t\t\t\t\t   PCI_EXP_LNKCTL2_TX_MARGIN));\n\t\t\t\tpcie_capability_write_word(rdev->pdev,\n\t\t\t\t\t\t\t   PCI_EXP_LNKCTL2,\n\t\t\t\t\t\t\t   tmp16);\n\n\t\t\t\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL4);\n\t\t\t\ttmp &= ~LC_SET_QUIESCE;\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL4, tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tspeed_cntl |= LC_FORCE_EN_SW_SPEED_CHANGE | LC_FORCE_DIS_HW_SPEED_CHANGE;\n\tspeed_cntl &= ~LC_FORCE_DIS_SW_SPEED_CHANGE;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\tpcie_capability_read_word(rdev->pdev, PCI_EXP_LNKCTL2, &tmp16);\n\ttmp16 &= ~PCI_EXP_LNKCTL2_TLS;\n\tif (speed_cap == PCIE_SPEED_8_0GT)\n\t\ttmp16 |= PCI_EXP_LNKCTL2_TLS_8_0GT;  \n\telse if (speed_cap == PCIE_SPEED_5_0GT)\n\t\ttmp16 |= PCI_EXP_LNKCTL2_TLS_5_0GT;  \n\telse\n\t\ttmp16 |= PCI_EXP_LNKCTL2_TLS_2_5GT;  \n\tpcie_capability_write_word(rdev->pdev, PCI_EXP_LNKCTL2, tmp16);\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tspeed_cntl |= LC_INITIATE_LINK_SPEED_CHANGE;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tif ((speed_cntl & LC_INITIATE_LINK_SPEED_CHANGE) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void cik_program_aspm(struct radeon_device *rdev)\n{\n\tu32 data, orig;\n\tbool disable_l0s = false, disable_l1 = false, disable_plloff_in_l1 = false;\n\tbool disable_clkreq = false;\n\n\tif (radeon_aspm == 0)\n\t\treturn;\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\torig = data = RREG32_PCIE_PORT(PCIE_LC_N_FTS_CNTL);\n\tdata &= ~LC_XMIT_N_FTS_MASK;\n\tdata |= LC_XMIT_N_FTS(0x24) | LC_XMIT_N_FTS_OVERRIDE_EN;\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_LC_N_FTS_CNTL, data);\n\n\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL3);\n\tdata |= LC_GO_TO_RECOVERY;\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL3, data);\n\n\torig = data = RREG32_PCIE_PORT(PCIE_P_CNTL);\n\tdata |= P_IGNORE_EDB_ERR;\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_P_CNTL, data);\n\n\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\tdata &= ~(LC_L0S_INACTIVITY_MASK | LC_L1_INACTIVITY_MASK);\n\tdata |= LC_PMI_TO_L1_DIS;\n\tif (!disable_l0s)\n\t\tdata |= LC_L0S_INACTIVITY(7);\n\n\tif (!disable_l1) {\n\t\tdata |= LC_L1_INACTIVITY(7);\n\t\tdata &= ~LC_PMI_TO_L1_DIS;\n\t\tif (orig != data)\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, data);\n\n\t\tif (!disable_plloff_in_l1) {\n\t\t\tbool clk_req_support;\n\n\t\t\torig = data = RREG32_PCIE_PORT(PB0_PIF_PWRDOWN_0);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_0_MASK | PLL_POWER_STATE_IN_TXS2_0_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_0(7) | PLL_POWER_STATE_IN_TXS2_0(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PCIE_PORT(PB0_PIF_PWRDOWN_0, data);\n\n\t\t\torig = data = RREG32_PCIE_PORT(PB0_PIF_PWRDOWN_1);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_1_MASK | PLL_POWER_STATE_IN_TXS2_1_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_1(7) | PLL_POWER_STATE_IN_TXS2_1(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PCIE_PORT(PB0_PIF_PWRDOWN_1, data);\n\n\t\t\torig = data = RREG32_PCIE_PORT(PB1_PIF_PWRDOWN_0);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_0_MASK | PLL_POWER_STATE_IN_TXS2_0_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_0(7) | PLL_POWER_STATE_IN_TXS2_0(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PCIE_PORT(PB1_PIF_PWRDOWN_0, data);\n\n\t\t\torig = data = RREG32_PCIE_PORT(PB1_PIF_PWRDOWN_1);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_1_MASK | PLL_POWER_STATE_IN_TXS2_1_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_1(7) | PLL_POWER_STATE_IN_TXS2_1(7);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PCIE_PORT(PB1_PIF_PWRDOWN_1, data);\n\n\t\t\torig = data = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t\tdata &= ~LC_DYN_LANES_PWR_STATE_MASK;\n\t\t\tdata |= LC_DYN_LANES_PWR_STATE(3);\n\t\t\tif (orig != data)\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, data);\n\n\t\t\tif (!disable_clkreq &&\n\t\t\t    !pci_is_root_bus(rdev->pdev->bus)) {\n\t\t\t\tstruct pci_dev *root = rdev->pdev->bus->self;\n\t\t\t\tu32 lnkcap;\n\n\t\t\t\tclk_req_support = false;\n\t\t\t\tpcie_capability_read_dword(root, PCI_EXP_LNKCAP, &lnkcap);\n\t\t\t\tif (lnkcap & PCI_EXP_LNKCAP_CLKPM)\n\t\t\t\t\tclk_req_support = true;\n\t\t\t} else {\n\t\t\t\tclk_req_support = false;\n\t\t\t}\n\n\t\t\tif (clk_req_support) {\n\t\t\t\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL2);\n\t\t\t\tdata |= LC_ALLOW_PDWN_IN_L1 | LC_ALLOW_PDWN_IN_L23;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL2, data);\n\n\t\t\t\torig = data = RREG32_SMC(THM_CLK_CNTL);\n\t\t\t\tdata &= ~(CMON_CLK_SEL_MASK | TMON_CLK_SEL_MASK);\n\t\t\t\tdata |= CMON_CLK_SEL(1) | TMON_CLK_SEL(1);\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_SMC(THM_CLK_CNTL, data);\n\n\t\t\t\torig = data = RREG32_SMC(MISC_CLK_CTRL);\n\t\t\t\tdata &= ~(DEEP_SLEEP_CLK_SEL_MASK | ZCLK_SEL_MASK);\n\t\t\t\tdata |= DEEP_SLEEP_CLK_SEL(1) | ZCLK_SEL(1);\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_SMC(MISC_CLK_CTRL, data);\n\n\t\t\t\torig = data = RREG32_SMC(CG_CLKPIN_CNTL);\n\t\t\t\tdata &= ~BCLK_AS_XCLK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_SMC(CG_CLKPIN_CNTL, data);\n\n\t\t\t\torig = data = RREG32_SMC(CG_CLKPIN_CNTL_2);\n\t\t\t\tdata &= ~FORCE_BIF_REFCLK_EN;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_SMC(CG_CLKPIN_CNTL_2, data);\n\n\t\t\t\torig = data = RREG32_SMC(MPLL_BYPASSCLK_SEL);\n\t\t\t\tdata &= ~MPLL_CLKOUT_SEL_MASK;\n\t\t\t\tdata |= MPLL_CLKOUT_SEL(4);\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_SMC(MPLL_BYPASSCLK_SEL, data);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (orig != data)\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, data);\n\t}\n\n\torig = data = RREG32_PCIE_PORT(PCIE_CNTL2);\n\tdata |= SLV_MEM_LS_EN | MST_MEM_LS_EN | REPLAY_MEM_LS_EN;\n\tif (orig != data)\n\t\tWREG32_PCIE_PORT(PCIE_CNTL2, data);\n\n\tif (!disable_l0s) {\n\t\tdata = RREG32_PCIE_PORT(PCIE_LC_N_FTS_CNTL);\n\t\tif((data & LC_N_FTS_MASK) == LC_N_FTS_MASK) {\n\t\t\tdata = RREG32_PCIE_PORT(PCIE_LC_STATUS1);\n\t\t\tif ((data & LC_REVERSE_XMIT) && (data & LC_REVERSE_RCVR)) {\n\t\t\t\torig = data = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\t\t\t\tdata &= ~LC_L0S_INACTIVITY_MASK;\n\t\t\t\tif (orig != data)\n\t\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, data);\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}