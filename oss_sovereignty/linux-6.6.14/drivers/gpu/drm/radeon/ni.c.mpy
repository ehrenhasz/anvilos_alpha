{
  "module_name": "ni.c",
  "hash_id": "1dba1b2e02fbcb9b963dcecb3df71373b25a7b2be516d90f61f99ba9c13b99e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/ni.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <drm/radeon_drm.h>\n\n#include \"atom.h\"\n#include \"cayman_blit_shaders.h\"\n#include \"clearstate_cayman.h\"\n#include \"evergreen.h\"\n#include \"ni.h\"\n#include \"ni_reg.h\"\n#include \"nid.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"radeon_ucode.h\"\n\n \nu32 tn_smc_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tWREG32(TN_SMC_IND_INDEX_0, (reg));\n\tr = RREG32(TN_SMC_IND_DATA_0);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\treturn r;\n}\n\nvoid tn_smc_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tWREG32(TN_SMC_IND_INDEX_0, (reg));\n\tWREG32(TN_SMC_IND_DATA_0, (v));\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n}\n\nstatic const u32 tn_rlc_save_restore_register_list[] =\n{\n\t0x98fc,\n\t0x98f0,\n\t0x9834,\n\t0x9838,\n\t0x9870,\n\t0x9874,\n\t0x8a14,\n\t0x8b24,\n\t0x8bcc,\n\t0x8b10,\n\t0x8c30,\n\t0x8d00,\n\t0x8d04,\n\t0x8c00,\n\t0x8c04,\n\t0x8c10,\n\t0x8c14,\n\t0x8d8c,\n\t0x8cf0,\n\t0x8e38,\n\t0x9508,\n\t0x9688,\n\t0x9608,\n\t0x960c,\n\t0x9610,\n\t0x9614,\n\t0x88c4,\n\t0x8978,\n\t0x88d4,\n\t0x900c,\n\t0x9100,\n\t0x913c,\n\t0x90e8,\n\t0x9354,\n\t0xa008,\n\t0x98f8,\n\t0x9148,\n\t0x914c,\n\t0x3f94,\n\t0x98f4,\n\t0x9b7c,\n\t0x3f8c,\n\t0x8950,\n\t0x8954,\n\t0x8a18,\n\t0x8b28,\n\t0x9144,\n\t0x3f90,\n\t0x915c,\n\t0x9160,\n\t0x9178,\n\t0x917c,\n\t0x9180,\n\t0x918c,\n\t0x9190,\n\t0x9194,\n\t0x9198,\n\t0x919c,\n\t0x91a8,\n\t0x91ac,\n\t0x91b0,\n\t0x91b4,\n\t0x91b8,\n\t0x91c4,\n\t0x91c8,\n\t0x91cc,\n\t0x91d0,\n\t0x91d4,\n\t0x91e0,\n\t0x91e4,\n\t0x91ec,\n\t0x91f0,\n\t0x91f4,\n\t0x9200,\n\t0x9204,\n\t0x929c,\n\t0x8030,\n\t0x9150,\n\t0x9a60,\n\t0x920c,\n\t0x9210,\n\t0x9228,\n\t0x922c,\n\t0x9244,\n\t0x9248,\n\t0x91e8,\n\t0x9294,\n\t0x9208,\n\t0x9224,\n\t0x9240,\n\t0x9220,\n\t0x923c,\n\t0x9258,\n\t0x9744,\n\t0xa200,\n\t0xa204,\n\t0xa208,\n\t0xa20c,\n\t0x8d58,\n\t0x9030,\n\t0x9034,\n\t0x9038,\n\t0x903c,\n\t0x9040,\n\t0x9654,\n\t0x897c,\n\t0xa210,\n\t0xa214,\n\t0x9868,\n\t0xa02c,\n\t0x9664,\n\t0x9698,\n\t0x949c,\n\t0x8e10,\n\t0x8e18,\n\t0x8c50,\n\t0x8c58,\n\t0x8c60,\n\t0x8c68,\n\t0x89b4,\n\t0x9830,\n\t0x802c,\n};\n\n \nMODULE_FIRMWARE(\"radeon/BARTS_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/BARTS_me.bin\");\nMODULE_FIRMWARE(\"radeon/BARTS_mc.bin\");\nMODULE_FIRMWARE(\"radeon/BARTS_smc.bin\");\nMODULE_FIRMWARE(\"radeon/BTC_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/TURKS_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/TURKS_me.bin\");\nMODULE_FIRMWARE(\"radeon/TURKS_mc.bin\");\nMODULE_FIRMWARE(\"radeon/TURKS_smc.bin\");\nMODULE_FIRMWARE(\"radeon/CAICOS_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/CAICOS_me.bin\");\nMODULE_FIRMWARE(\"radeon/CAICOS_mc.bin\");\nMODULE_FIRMWARE(\"radeon/CAICOS_smc.bin\");\nMODULE_FIRMWARE(\"radeon/CAYMAN_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/CAYMAN_me.bin\");\nMODULE_FIRMWARE(\"radeon/CAYMAN_mc.bin\");\nMODULE_FIRMWARE(\"radeon/CAYMAN_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/CAYMAN_smc.bin\");\nMODULE_FIRMWARE(\"radeon/ARUBA_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/ARUBA_me.bin\");\nMODULE_FIRMWARE(\"radeon/ARUBA_rlc.bin\");\n\n\nstatic const u32 cayman_golden_registers2[] =\n{\n\t0x3e5c, 0xffffffff, 0x00000000,\n\t0x3e48, 0xffffffff, 0x00000000,\n\t0x3e4c, 0xffffffff, 0x00000000,\n\t0x3e64, 0xffffffff, 0x00000000,\n\t0x3e50, 0xffffffff, 0x00000000,\n\t0x3e60, 0xffffffff, 0x00000000\n};\n\nstatic const u32 cayman_golden_registers[] =\n{\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5e78, 0x8f311ff1, 0x001000f0,\n\t0x3f90, 0xffff0000, 0xff000000,\n\t0x9148, 0xffff0000, 0xff000000,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0xbd4, 0x70073777, 0x00011003,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd0b8, 0x73773777, 0x02011003,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x98f8, 0x33773777, 0x02011003,\n\t0x98fc, 0xffffffff, 0x76541032,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2f48, 0x33773777, 0x42010001,\n\t0x6b28, 0x00000010, 0x00000012,\n\t0x7728, 0x00000010, 0x00000012,\n\t0x10328, 0x00000010, 0x00000012,\n\t0x10f28, 0x00000010, 0x00000012,\n\t0x11b28, 0x00000010, 0x00000012,\n\t0x12728, 0x00000010, 0x00000012,\n\t0x240c, 0x000007ff, 0x00000000,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x10c, 0x00000001, 0x00010003,\n\t0xa02c, 0xffffffff, 0x0000009b,\n\t0x913c, 0x0000010f, 0x01000100,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x9508, 0x3700001f, 0x00000002,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0x001f3ae3, 0x00000082,\n\t0x88d0, 0xffffffff, 0x0f40df40,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000\n};\n\nstatic const u32 dvst_golden_registers2[] =\n{\n\t0x8f8, 0xffffffff, 0,\n\t0x8fc, 0x00380000, 0,\n\t0x8f8, 0xffffffff, 1,\n\t0x8fc, 0x0e000000, 0\n};\n\nstatic const u32 dvst_golden_registers[] =\n{\n\t0x690, 0x3fff3fff, 0x20c00033,\n\t0x918c, 0x0fff0fff, 0x00010006,\n\t0x91a8, 0x0fff0fff, 0x00010006,\n\t0x9150, 0xffffdfff, 0x6e944040,\n\t0x917c, 0x0fff0fff, 0x00030002,\n\t0x9198, 0x0fff0fff, 0x00030002,\n\t0x915c, 0x0fff0fff, 0x00010000,\n\t0x3f90, 0xffff0001, 0xff000000,\n\t0x9178, 0x0fff0fff, 0x00070000,\n\t0x9194, 0x0fff0fff, 0x00070000,\n\t0x9148, 0xffff0001, 0xff000000,\n\t0x9190, 0x0fff0fff, 0x00090008,\n\t0x91ac, 0x0fff0fff, 0x00090008,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x929c, 0x00000fff, 0x00000001,\n\t0x55e4, 0xff607fff, 0xfc000100,\n\t0x8a18, 0xff000fff, 0x00000100,\n\t0x8b28, 0xff000fff, 0x00000100,\n\t0x9144, 0xfffc0fff, 0x00000100,\n\t0x6ed8, 0x00010101, 0x00010000,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0xfffffffe, 0x00000000,\n\t0xd0c0, 0xff000fff, 0x00000100,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd0b8, 0x73773777, 0x12010001,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x98fc, 0xffffffff, 0x00000010,\n\t0x9b7c, 0x00ff0000, 0x00fc0000,\n\t0x8030, 0x00001f0f, 0x0000100a,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x2408, 0x00030000, 0x000c007f,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x4d8, 0x00000fff, 0x00000100,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0x913c, 0xffff03ff, 0x01000100,\n\t0x8c00, 0x000000ff, 0x00000003,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x8cf0, 0x1fff1fff, 0x08e00410,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x9508, 0xf700071f, 0x00000002,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x20ef8, 0x01ff01ff, 0x00000002,\n\t0x20e98, 0xfffffbff, 0x00200000,\n\t0x2015c, 0xffffffff, 0x00000f40,\n\t0x88c4, 0x001f3ae3, 0x00000082,\n\t0x8978, 0x3fffffff, 0x04050140,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000\n};\n\nstatic const u32 scrapper_golden_registers[] =\n{\n\t0x690, 0x3fff3fff, 0x20c00033,\n\t0x918c, 0x0fff0fff, 0x00010006,\n\t0x918c, 0x0fff0fff, 0x00010006,\n\t0x91a8, 0x0fff0fff, 0x00010006,\n\t0x91a8, 0x0fff0fff, 0x00010006,\n\t0x9150, 0xffffdfff, 0x6e944040,\n\t0x9150, 0xffffdfff, 0x6e944040,\n\t0x917c, 0x0fff0fff, 0x00030002,\n\t0x917c, 0x0fff0fff, 0x00030002,\n\t0x9198, 0x0fff0fff, 0x00030002,\n\t0x9198, 0x0fff0fff, 0x00030002,\n\t0x915c, 0x0fff0fff, 0x00010000,\n\t0x915c, 0x0fff0fff, 0x00010000,\n\t0x3f90, 0xffff0001, 0xff000000,\n\t0x3f90, 0xffff0001, 0xff000000,\n\t0x9178, 0x0fff0fff, 0x00070000,\n\t0x9178, 0x0fff0fff, 0x00070000,\n\t0x9194, 0x0fff0fff, 0x00070000,\n\t0x9194, 0x0fff0fff, 0x00070000,\n\t0x9148, 0xffff0001, 0xff000000,\n\t0x9148, 0xffff0001, 0xff000000,\n\t0x9190, 0x0fff0fff, 0x00090008,\n\t0x9190, 0x0fff0fff, 0x00090008,\n\t0x91ac, 0x0fff0fff, 0x00090008,\n\t0x91ac, 0x0fff0fff, 0x00090008,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x929c, 0x00000fff, 0x00000001,\n\t0x929c, 0x00000fff, 0x00000001,\n\t0x55e4, 0xff607fff, 0xfc000100,\n\t0x8a18, 0xff000fff, 0x00000100,\n\t0x8a18, 0xff000fff, 0x00000100,\n\t0x8b28, 0xff000fff, 0x00000100,\n\t0x8b28, 0xff000fff, 0x00000100,\n\t0x9144, 0xfffc0fff, 0x00000100,\n\t0x9144, 0xfffc0fff, 0x00000100,\n\t0x6ed8, 0x00010101, 0x00010000,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9830, 0xffffffff, 0x00000000,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9834, 0xf00fffff, 0x00000400,\n\t0x9838, 0xfffffffe, 0x00000000,\n\t0x9838, 0xfffffffe, 0x00000000,\n\t0xd0c0, 0xff000fff, 0x00000100,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd0b8, 0x73773777, 0x12010001,\n\t0xd0b8, 0x73773777, 0x12010001,\n\t0x5bb0, 0x000000f0, 0x00000070,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x98f8, 0x73773777, 0x12010001,\n\t0x98fc, 0xffffffff, 0x00000010,\n\t0x98fc, 0xffffffff, 0x00000010,\n\t0x9b7c, 0x00ff0000, 0x00fc0000,\n\t0x9b7c, 0x00ff0000, 0x00fc0000,\n\t0x8030, 0x00001f0f, 0x0000100a,\n\t0x8030, 0x00001f0f, 0x0000100a,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x2f48, 0x73773777, 0x12010001,\n\t0x2408, 0x00030000, 0x000c007f,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8a14, 0xf000003f, 0x00000007,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x4d8, 0x00000fff, 0x00000100,\n\t0x4d8, 0x00000fff, 0x00000100,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0x913c, 0xffff03ff, 0x01000100,\n\t0x913c, 0xffff03ff, 0x01000100,\n\t0x90e8, 0x001fffff, 0x010400c0,\n\t0x8c00, 0x000000ff, 0x00000003,\n\t0x8c00, 0x000000ff, 0x00000003,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x8c30, 0x0000000f, 0x00040005,\n\t0x8cf0, 0x1fff1fff, 0x08e00410,\n\t0x8cf0, 0x1fff1fff, 0x08e00410,\n\t0x900c, 0x00ffffff, 0x0017071f,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x9508, 0xf700071f, 0x00000002,\n\t0x9508, 0xf700071f, 0x00000002,\n\t0x9688, 0x00300000, 0x0017000f,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x20ef8, 0x01ff01ff, 0x00000002,\n\t0x20e98, 0xfffffbff, 0x00200000,\n\t0x2015c, 0xffffffff, 0x00000f40,\n\t0x88c4, 0x001f3ae3, 0x00000082,\n\t0x88c4, 0x001f3ae3, 0x00000082,\n\t0x8978, 0x3fffffff, 0x04050140,\n\t0x8978, 0x3fffffff, 0x04050140,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000,\n\t0x8974, 0xffffffff, 0x00000000\n};\n\nstatic void ni_init_golden_registers(struct radeon_device *rdev)\n{\n\tswitch (rdev->family) {\n\tcase CHIP_CAYMAN:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t cayman_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(cayman_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t cayman_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(cayman_golden_registers2));\n\t\tbreak;\n\tcase CHIP_ARUBA:\n\t\tif ((rdev->pdev->device == 0x9900) ||\n\t\t    (rdev->pdev->device == 0x9901) ||\n\t\t    (rdev->pdev->device == 0x9903) ||\n\t\t    (rdev->pdev->device == 0x9904) ||\n\t\t    (rdev->pdev->device == 0x9905) ||\n\t\t    (rdev->pdev->device == 0x9906) ||\n\t\t    (rdev->pdev->device == 0x9907) ||\n\t\t    (rdev->pdev->device == 0x9908) ||\n\t\t    (rdev->pdev->device == 0x9909) ||\n\t\t    (rdev->pdev->device == 0x990A) ||\n\t\t    (rdev->pdev->device == 0x990B) ||\n\t\t    (rdev->pdev->device == 0x990C) ||\n\t\t    (rdev->pdev->device == 0x990D) ||\n\t\t    (rdev->pdev->device == 0x990E) ||\n\t\t    (rdev->pdev->device == 0x990F) ||\n\t\t    (rdev->pdev->device == 0x9910) ||\n\t\t    (rdev->pdev->device == 0x9913) ||\n\t\t    (rdev->pdev->device == 0x9917) ||\n\t\t    (rdev->pdev->device == 0x9918)) {\n\t\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t\t dvst_golden_registers,\n\t\t\t\t\t\t\t (const u32)ARRAY_SIZE(dvst_golden_registers));\n\t\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t\t dvst_golden_registers2,\n\t\t\t\t\t\t\t (const u32)ARRAY_SIZE(dvst_golden_registers2));\n\t\t} else {\n\t\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t\t scrapper_golden_registers,\n\t\t\t\t\t\t\t (const u32)ARRAY_SIZE(scrapper_golden_registers));\n\t\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t\t dvst_golden_registers2,\n\t\t\t\t\t\t\t (const u32)ARRAY_SIZE(dvst_golden_registers2));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#define BTC_IO_MC_REGS_SIZE 29\n\nstatic const u32 barts_io_mc_regs[BTC_IO_MC_REGS_SIZE][2] = {\n\t{0x00000077, 0xff010100},\n\t{0x00000078, 0x00000000},\n\t{0x00000079, 0x00001434},\n\t{0x0000007a, 0xcc08ec08},\n\t{0x0000007b, 0x00040000},\n\t{0x0000007c, 0x000080c0},\n\t{0x0000007d, 0x09000000},\n\t{0x0000007e, 0x00210404},\n\t{0x00000081, 0x08a8e800},\n\t{0x00000082, 0x00030444},\n\t{0x00000083, 0x00000000},\n\t{0x00000085, 0x00000001},\n\t{0x00000086, 0x00000002},\n\t{0x00000087, 0x48490000},\n\t{0x00000088, 0x20244647},\n\t{0x00000089, 0x00000005},\n\t{0x0000008b, 0x66030000},\n\t{0x0000008c, 0x00006603},\n\t{0x0000008d, 0x00000100},\n\t{0x0000008f, 0x00001c0a},\n\t{0x00000090, 0xff000001},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00946a00}\n};\n\nstatic const u32 turks_io_mc_regs[BTC_IO_MC_REGS_SIZE][2] = {\n\t{0x00000077, 0xff010100},\n\t{0x00000078, 0x00000000},\n\t{0x00000079, 0x00001434},\n\t{0x0000007a, 0xcc08ec08},\n\t{0x0000007b, 0x00040000},\n\t{0x0000007c, 0x000080c0},\n\t{0x0000007d, 0x09000000},\n\t{0x0000007e, 0x00210404},\n\t{0x00000081, 0x08a8e800},\n\t{0x00000082, 0x00030444},\n\t{0x00000083, 0x00000000},\n\t{0x00000085, 0x00000001},\n\t{0x00000086, 0x00000002},\n\t{0x00000087, 0x48490000},\n\t{0x00000088, 0x20244647},\n\t{0x00000089, 0x00000005},\n\t{0x0000008b, 0x66030000},\n\t{0x0000008c, 0x00006603},\n\t{0x0000008d, 0x00000100},\n\t{0x0000008f, 0x00001c0a},\n\t{0x00000090, 0xff000001},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00936a00}\n};\n\nstatic const u32 caicos_io_mc_regs[BTC_IO_MC_REGS_SIZE][2] = {\n\t{0x00000077, 0xff010100},\n\t{0x00000078, 0x00000000},\n\t{0x00000079, 0x00001434},\n\t{0x0000007a, 0xcc08ec08},\n\t{0x0000007b, 0x00040000},\n\t{0x0000007c, 0x000080c0},\n\t{0x0000007d, 0x09000000},\n\t{0x0000007e, 0x00210404},\n\t{0x00000081, 0x08a8e800},\n\t{0x00000082, 0x00030444},\n\t{0x00000083, 0x00000000},\n\t{0x00000085, 0x00000001},\n\t{0x00000086, 0x00000002},\n\t{0x00000087, 0x48490000},\n\t{0x00000088, 0x20244647},\n\t{0x00000089, 0x00000005},\n\t{0x0000008b, 0x66030000},\n\t{0x0000008c, 0x00006603},\n\t{0x0000008d, 0x00000100},\n\t{0x0000008f, 0x00001c0a},\n\t{0x00000090, 0xff000001},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00916a00}\n};\n\nstatic const u32 cayman_io_mc_regs[BTC_IO_MC_REGS_SIZE][2] = {\n\t{0x00000077, 0xff010100},\n\t{0x00000078, 0x00000000},\n\t{0x00000079, 0x00001434},\n\t{0x0000007a, 0xcc08ec08},\n\t{0x0000007b, 0x00040000},\n\t{0x0000007c, 0x000080c0},\n\t{0x0000007d, 0x09000000},\n\t{0x0000007e, 0x00210404},\n\t{0x00000081, 0x08a8e800},\n\t{0x00000082, 0x00030444},\n\t{0x00000083, 0x00000000},\n\t{0x00000085, 0x00000001},\n\t{0x00000086, 0x00000002},\n\t{0x00000087, 0x48490000},\n\t{0x00000088, 0x20244647},\n\t{0x00000089, 0x00000005},\n\t{0x0000008b, 0x66030000},\n\t{0x0000008c, 0x00006603},\n\t{0x0000008d, 0x00000100},\n\t{0x0000008f, 0x00001c0a},\n\t{0x00000090, 0xff000001},\n\t{0x00000094, 0x00101101},\n\t{0x00000095, 0x00000fff},\n\t{0x00000096, 0x00116fff},\n\t{0x00000097, 0x60010000},\n\t{0x00000098, 0x10010000},\n\t{0x00000099, 0x00006000},\n\t{0x0000009a, 0x00001000},\n\t{0x0000009f, 0x00976b00}\n};\n\nint ni_mc_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data;\n\tu32 mem_type, running, blackout = 0;\n\tu32 *io_mc_regs;\n\tint i, ucode_size, regs_size;\n\n\tif (!rdev->mc_fw)\n\t\treturn -EINVAL;\n\n\tswitch (rdev->family) {\n\tcase CHIP_BARTS:\n\t\tio_mc_regs = (u32 *)&barts_io_mc_regs;\n\t\tucode_size = BTC_MC_UCODE_SIZE;\n\t\tregs_size = BTC_IO_MC_REGS_SIZE;\n\t\tbreak;\n\tcase CHIP_TURKS:\n\t\tio_mc_regs = (u32 *)&turks_io_mc_regs;\n\t\tucode_size = BTC_MC_UCODE_SIZE;\n\t\tregs_size = BTC_IO_MC_REGS_SIZE;\n\t\tbreak;\n\tcase CHIP_CAICOS:\n\tdefault:\n\t\tio_mc_regs = (u32 *)&caicos_io_mc_regs;\n\t\tucode_size = BTC_MC_UCODE_SIZE;\n\t\tregs_size = BTC_IO_MC_REGS_SIZE;\n\t\tbreak;\n\tcase CHIP_CAYMAN:\n\t\tio_mc_regs = (u32 *)&cayman_io_mc_regs;\n\t\tucode_size = CAYMAN_MC_UCODE_SIZE;\n\t\tregs_size = BTC_IO_MC_REGS_SIZE;\n\t\tbreak;\n\t}\n\n\tmem_type = (RREG32(MC_SEQ_MISC0) & MC_SEQ_MISC0_GDDR5_MASK) >> MC_SEQ_MISC0_GDDR5_SHIFT;\n\trunning = RREG32(MC_SEQ_SUP_CNTL) & RUN_MASK;\n\n\tif ((mem_type == MC_SEQ_MISC0_GDDR5_VALUE) && (running == 0)) {\n\t\tif (running) {\n\t\t\tblackout = RREG32(MC_SHARED_BLACKOUT_CNTL);\n\t\t\tWREG32(MC_SHARED_BLACKOUT_CNTL, 1);\n\t\t}\n\n\t\t \n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000008);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000010);\n\n\t\t \n\t\tfor (i = 0; i < regs_size; i++) {\n\t\t\tWREG32(MC_SEQ_IO_DEBUG_INDEX, io_mc_regs[(i << 1)]);\n\t\t\tWREG32(MC_SEQ_IO_DEBUG_DATA, io_mc_regs[(i << 1) + 1]);\n\t\t}\n\t\t \n\t\tfw_data = (const __be32 *)rdev->mc_fw->data;\n\t\tfor (i = 0; i < ucode_size; i++)\n\t\t\tWREG32(MC_SEQ_SUP_PGM, be32_to_cpup(fw_data++));\n\n\t\t \n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000008);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000004);\n\t\tWREG32(MC_SEQ_SUP_CNTL, 0x00000001);\n\n\t\t \n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif (RREG32(MC_IO_PAD_CNTL_D0) & MEM_FALL_OUT_CMD)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\n\t\tif (running)\n\t\t\tWREG32(MC_SHARED_BLACKOUT_CNTL, blackout);\n\t}\n\n\treturn 0;\n}\n\nint ni_init_microcode(struct radeon_device *rdev)\n{\n\tconst char *chip_name;\n\tconst char *rlc_chip_name;\n\tsize_t pfp_req_size, me_req_size, rlc_req_size, mc_req_size;\n\tsize_t smc_req_size = 0;\n\tchar fw_name[30];\n\tint err;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tswitch (rdev->family) {\n\tcase CHIP_BARTS:\n\t\tchip_name = \"BARTS\";\n\t\trlc_chip_name = \"BTC\";\n\t\tpfp_req_size = EVERGREEN_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = EVERGREEN_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = EVERGREEN_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = BTC_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(BARTS_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_TURKS:\n\t\tchip_name = \"TURKS\";\n\t\trlc_chip_name = \"BTC\";\n\t\tpfp_req_size = EVERGREEN_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = EVERGREEN_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = EVERGREEN_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = BTC_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(TURKS_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_CAICOS:\n\t\tchip_name = \"CAICOS\";\n\t\trlc_chip_name = \"BTC\";\n\t\tpfp_req_size = EVERGREEN_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = EVERGREEN_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = EVERGREEN_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = BTC_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(CAICOS_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_CAYMAN:\n\t\tchip_name = \"CAYMAN\";\n\t\trlc_chip_name = \"CAYMAN\";\n\t\tpfp_req_size = CAYMAN_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CAYMAN_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = CAYMAN_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = CAYMAN_MC_UCODE_SIZE * 4;\n\t\tsmc_req_size = ALIGN(CAYMAN_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_ARUBA:\n\t\tchip_name = \"ARUBA\";\n\t\trlc_chip_name = \"ARUBA\";\n\t\t \n\t\tpfp_req_size = CAYMAN_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = CAYMAN_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = ARUBA_RLC_UCODE_SIZE * 4;\n\t\tmc_req_size = 0;\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\n\tDRM_INFO(\"Loading %s Microcode\\n\", chip_name);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_pfp.bin\", chip_name);\n\terr = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);\n\tif (err)\n\t\tgoto out;\n\tif (rdev->pfp_fw->size != pfp_req_size) {\n\t\tpr_err(\"ni_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->pfp_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_me.bin\", chip_name);\n\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\tif (err)\n\t\tgoto out;\n\tif (rdev->me_fw->size != me_req_size) {\n\t\tpr_err(\"ni_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->me_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_rlc.bin\", rlc_chip_name);\n\terr = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);\n\tif (err)\n\t\tgoto out;\n\tif (rdev->rlc_fw->size != rlc_req_size) {\n\t\tpr_err(\"ni_rlc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->rlc_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_mc.bin\", chip_name);\n\t\terr = request_firmware(&rdev->mc_fw, fw_name, rdev->dev);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (rdev->mc_fw->size != mc_req_size) {\n\t\t\tpr_err(\"ni_mc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->mc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\tif ((rdev->family >= CHIP_BARTS) && (rdev->family <= CHIP_CAYMAN)) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_smc.bin\", chip_name);\n\t\terr = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tpr_err(\"smc: error loading firmware \\\"%s\\\"\\n\", fw_name);\n\t\t\trelease_firmware(rdev->smc_fw);\n\t\t\trdev->smc_fw = NULL;\n\t\t\terr = 0;\n\t\t} else if (rdev->smc_fw->size != smc_req_size) {\n\t\t\tpr_err(\"ni_mc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->mc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\nout:\n\tif (err) {\n\t\tif (err != -EINVAL)\n\t\t\tpr_err(\"ni_cp: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\trelease_firmware(rdev->pfp_fw);\n\t\trdev->pfp_fw = NULL;\n\t\trelease_firmware(rdev->me_fw);\n\t\trdev->me_fw = NULL;\n\t\trelease_firmware(rdev->rlc_fw);\n\t\trdev->rlc_fw = NULL;\n\t\trelease_firmware(rdev->mc_fw);\n\t\trdev->mc_fw = NULL;\n\t}\n\treturn err;\n}\n\n \nint cayman_get_allowed_info_register(struct radeon_device *rdev,\n\t\t\t\t     u32 reg, u32 *val)\n{\n\tswitch (reg) {\n\tcase GRBM_STATUS:\n\tcase GRBM_STATUS_SE0:\n\tcase GRBM_STATUS_SE1:\n\tcase SRBM_STATUS:\n\tcase SRBM_STATUS2:\n\tcase (DMA_STATUS_REG + DMA0_REGISTER_OFFSET):\n\tcase (DMA_STATUS_REG + DMA1_REGISTER_OFFSET):\n\tcase UVD_STATUS:\n\t\t*val = RREG32(reg);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint tn_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp = RREG32_SMC(TN_CURRENT_GNB_TEMP) & 0x7ff;\n\tint actual_temp = (temp / 8) - 49;\n\n\treturn actual_temp * 1000;\n}\n\n \nstatic void cayman_gpu_init(struct radeon_device *rdev)\n{\n\tu32 gb_addr_config = 0;\n\tu32 mc_arb_ramcfg;\n\tu32 cgts_tcc_disable;\n\tu32 sx_debug_1;\n\tu32 smx_dc_ctl0;\n\tu32 cgts_sm_ctrl_reg;\n\tu32 hdp_host_path_cntl;\n\tu32 tmp;\n\tu32 disabled_rb_mask;\n\tint i, j;\n\n\tswitch (rdev->family) {\n\tcase CHIP_CAYMAN:\n\t\trdev->config.cayman.max_shader_engines = 2;\n\t\trdev->config.cayman.max_pipes_per_simd = 4;\n\t\trdev->config.cayman.max_tile_pipes = 8;\n\t\trdev->config.cayman.max_simds_per_se = 12;\n\t\trdev->config.cayman.max_backends_per_se = 4;\n\t\trdev->config.cayman.max_texture_channel_caches = 8;\n\t\trdev->config.cayman.max_gprs = 256;\n\t\trdev->config.cayman.max_threads = 256;\n\t\trdev->config.cayman.max_gs_threads = 32;\n\t\trdev->config.cayman.max_stack_entries = 512;\n\t\trdev->config.cayman.sx_num_of_sets = 8;\n\t\trdev->config.cayman.sx_max_export_size = 256;\n\t\trdev->config.cayman.sx_max_export_pos_size = 64;\n\t\trdev->config.cayman.sx_max_export_smx_size = 192;\n\t\trdev->config.cayman.max_hw_contexts = 8;\n\t\trdev->config.cayman.sq_num_cf_insts = 2;\n\n\t\trdev->config.cayman.sc_prim_fifo_size = 0x100;\n\t\trdev->config.cayman.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.cayman.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CAYMAN_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_ARUBA:\n\tdefault:\n\t\trdev->config.cayman.max_shader_engines = 1;\n\t\trdev->config.cayman.max_pipes_per_simd = 4;\n\t\trdev->config.cayman.max_tile_pipes = 2;\n\t\tif ((rdev->pdev->device == 0x9900) ||\n\t\t    (rdev->pdev->device == 0x9901) ||\n\t\t    (rdev->pdev->device == 0x9905) ||\n\t\t    (rdev->pdev->device == 0x9906) ||\n\t\t    (rdev->pdev->device == 0x9907) ||\n\t\t    (rdev->pdev->device == 0x9908) ||\n\t\t    (rdev->pdev->device == 0x9909) ||\n\t\t    (rdev->pdev->device == 0x990B) ||\n\t\t    (rdev->pdev->device == 0x990C) ||\n\t\t    (rdev->pdev->device == 0x990F) ||\n\t\t    (rdev->pdev->device == 0x9910) ||\n\t\t    (rdev->pdev->device == 0x9917) ||\n\t\t    (rdev->pdev->device == 0x9999) ||\n\t\t    (rdev->pdev->device == 0x999C)) {\n\t\t\trdev->config.cayman.max_simds_per_se = 6;\n\t\t\trdev->config.cayman.max_backends_per_se = 2;\n\t\t\trdev->config.cayman.max_hw_contexts = 8;\n\t\t\trdev->config.cayman.sx_max_export_size = 256;\n\t\t\trdev->config.cayman.sx_max_export_pos_size = 64;\n\t\t\trdev->config.cayman.sx_max_export_smx_size = 192;\n\t\t} else if ((rdev->pdev->device == 0x9903) ||\n\t\t\t   (rdev->pdev->device == 0x9904) ||\n\t\t\t   (rdev->pdev->device == 0x990A) ||\n\t\t\t   (rdev->pdev->device == 0x990D) ||\n\t\t\t   (rdev->pdev->device == 0x990E) ||\n\t\t\t   (rdev->pdev->device == 0x9913) ||\n\t\t\t   (rdev->pdev->device == 0x9918) ||\n\t\t\t   (rdev->pdev->device == 0x999D)) {\n\t\t\trdev->config.cayman.max_simds_per_se = 4;\n\t\t\trdev->config.cayman.max_backends_per_se = 2;\n\t\t\trdev->config.cayman.max_hw_contexts = 8;\n\t\t\trdev->config.cayman.sx_max_export_size = 256;\n\t\t\trdev->config.cayman.sx_max_export_pos_size = 64;\n\t\t\trdev->config.cayman.sx_max_export_smx_size = 192;\n\t\t} else if ((rdev->pdev->device == 0x9919) ||\n\t\t\t   (rdev->pdev->device == 0x9990) ||\n\t\t\t   (rdev->pdev->device == 0x9991) ||\n\t\t\t   (rdev->pdev->device == 0x9994) ||\n\t\t\t   (rdev->pdev->device == 0x9995) ||\n\t\t\t   (rdev->pdev->device == 0x9996) ||\n\t\t\t   (rdev->pdev->device == 0x999A) ||\n\t\t\t   (rdev->pdev->device == 0x99A0)) {\n\t\t\trdev->config.cayman.max_simds_per_se = 3;\n\t\t\trdev->config.cayman.max_backends_per_se = 1;\n\t\t\trdev->config.cayman.max_hw_contexts = 4;\n\t\t\trdev->config.cayman.sx_max_export_size = 128;\n\t\t\trdev->config.cayman.sx_max_export_pos_size = 32;\n\t\t\trdev->config.cayman.sx_max_export_smx_size = 96;\n\t\t} else {\n\t\t\trdev->config.cayman.max_simds_per_se = 2;\n\t\t\trdev->config.cayman.max_backends_per_se = 1;\n\t\t\trdev->config.cayman.max_hw_contexts = 4;\n\t\t\trdev->config.cayman.sx_max_export_size = 128;\n\t\t\trdev->config.cayman.sx_max_export_pos_size = 32;\n\t\t\trdev->config.cayman.sx_max_export_smx_size = 96;\n\t\t}\n\t\trdev->config.cayman.max_texture_channel_caches = 2;\n\t\trdev->config.cayman.max_gprs = 256;\n\t\trdev->config.cayman.max_threads = 256;\n\t\trdev->config.cayman.max_gs_threads = 32;\n\t\trdev->config.cayman.max_stack_entries = 512;\n\t\trdev->config.cayman.sx_num_of_sets = 8;\n\t\trdev->config.cayman.sq_num_cf_insts = 2;\n\n\t\trdev->config.cayman.sc_prim_fifo_size = 0x40;\n\t\trdev->config.cayman.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.cayman.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = ARUBA_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\n\tWREG32(GRBM_CNTL, GRBM_READ_TIMEOUT(0xff));\n\tWREG32(SRBM_INT_CNTL, 0x1);\n\tWREG32(SRBM_INT_ACK, 0x1);\n\n\tevergreen_fix_pci_max_read_req_size(rdev);\n\n\tRREG32(MC_SHARED_CHMAP);\n\tmc_arb_ramcfg = RREG32(MC_ARB_RAMCFG);\n\n\ttmp = (mc_arb_ramcfg & NOOFCOLS_MASK) >> NOOFCOLS_SHIFT;\n\trdev->config.cayman.mem_row_size_in_kb = (4 * (1 << (8 + tmp))) / 1024;\n\tif (rdev->config.cayman.mem_row_size_in_kb > 4)\n\t\trdev->config.cayman.mem_row_size_in_kb = 4;\n\t \n\trdev->config.cayman.shader_engine_tile_size = 32;\n\trdev->config.cayman.num_gpus = 1;\n\trdev->config.cayman.multi_gpu_tile_size = 64;\n\n\ttmp = (gb_addr_config & NUM_PIPES_MASK) >> NUM_PIPES_SHIFT;\n\trdev->config.cayman.num_tile_pipes = (1 << tmp);\n\ttmp = (gb_addr_config & PIPE_INTERLEAVE_SIZE_MASK) >> PIPE_INTERLEAVE_SIZE_SHIFT;\n\trdev->config.cayman.mem_max_burst_length_bytes = (tmp + 1) * 256;\n\ttmp = (gb_addr_config & NUM_SHADER_ENGINES_MASK) >> NUM_SHADER_ENGINES_SHIFT;\n\trdev->config.cayman.num_shader_engines = tmp + 1;\n\ttmp = (gb_addr_config & NUM_GPUS_MASK) >> NUM_GPUS_SHIFT;\n\trdev->config.cayman.num_gpus = tmp + 1;\n\ttmp = (gb_addr_config & MULTI_GPU_TILE_SIZE_MASK) >> MULTI_GPU_TILE_SIZE_SHIFT;\n\trdev->config.cayman.multi_gpu_tile_size = 1 << tmp;\n\ttmp = (gb_addr_config & ROW_SIZE_MASK) >> ROW_SIZE_SHIFT;\n\trdev->config.cayman.mem_row_size_in_kb = 1 << tmp;\n\n\n\t \n\trdev->config.cayman.tile_config = 0;\n\tswitch (rdev->config.cayman.num_tile_pipes) {\n\tcase 1:\n\tdefault:\n\t\trdev->config.cayman.tile_config |= (0 << 0);\n\t\tbreak;\n\tcase 2:\n\t\trdev->config.cayman.tile_config |= (1 << 0);\n\t\tbreak;\n\tcase 4:\n\t\trdev->config.cayman.tile_config |= (2 << 0);\n\t\tbreak;\n\tcase 8:\n\t\trdev->config.cayman.tile_config |= (3 << 0);\n\t\tbreak;\n\t}\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP)\n\t\trdev->config.cayman.tile_config |= 1 << 4;\n\telse {\n\t\tswitch ((mc_arb_ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) {\n\t\tcase 0:  \n\t\t\trdev->config.cayman.tile_config |= 0 << 4;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\trdev->config.cayman.tile_config |= 1 << 4;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\tdefault:\n\t\t\trdev->config.cayman.tile_config |= 2 << 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\trdev->config.cayman.tile_config |=\n\t\t((gb_addr_config & PIPE_INTERLEAVE_SIZE_MASK) >> PIPE_INTERLEAVE_SIZE_SHIFT) << 8;\n\trdev->config.cayman.tile_config |=\n\t\t((gb_addr_config & ROW_SIZE_MASK) >> ROW_SIZE_SHIFT) << 12;\n\n\ttmp = 0;\n\tfor (i = (rdev->config.cayman.max_shader_engines - 1); i >= 0; i--) {\n\t\tu32 rb_disable_bitmap;\n\n\t\tWREG32(GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\tWREG32(RLC_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\trb_disable_bitmap = (RREG32(CC_RB_BACKEND_DISABLE) & 0x00ff0000) >> 16;\n\t\ttmp <<= 4;\n\t\ttmp |= rb_disable_bitmap;\n\t}\n\t \n\tdisabled_rb_mask = tmp;\n\ttmp = 0;\n\tfor (i = 0; i < (rdev->config.cayman.max_backends_per_se * rdev->config.cayman.max_shader_engines); i++)\n\t\ttmp |= (1 << i);\n\t \n\tif ((disabled_rb_mask & tmp) == tmp) {\n\t\tfor (i = 0; i < (rdev->config.cayman.max_backends_per_se * rdev->config.cayman.max_shader_engines); i++)\n\t\t\tdisabled_rb_mask &= ~(1 << i);\n\t}\n\n\tfor (i = 0; i < rdev->config.cayman.max_shader_engines; i++) {\n\t\tu32 simd_disable_bitmap;\n\n\t\tWREG32(GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\tWREG32(RLC_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\tsimd_disable_bitmap = (RREG32(CC_GC_SHADER_PIPE_CONFIG) & 0xffff0000) >> 16;\n\t\tsimd_disable_bitmap |= 0xffffffff << rdev->config.cayman.max_simds_per_se;\n\t\ttmp <<= 16;\n\t\ttmp |= simd_disable_bitmap;\n\t}\n\trdev->config.cayman.active_simds = hweight32(~tmp);\n\n\tWREG32(GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_BROADCAST_WRITES);\n\tWREG32(RLC_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_BROADCAST_WRITES);\n\n\tWREG32(GB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMIF_ADDR_CONFIG, gb_addr_config);\n\tif (ASIC_IS_DCE6(rdev))\n\t\tWREG32(DMIF_ADDR_CALC, gb_addr_config);\n\tWREG32(HDP_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMA_TILING_CONFIG + DMA0_REGISTER_OFFSET, gb_addr_config);\n\tWREG32(DMA_TILING_CONFIG + DMA1_REGISTER_OFFSET, gb_addr_config);\n\tWREG32(UVD_UDEC_ADDR_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_DB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_DBW_ADDR_CONFIG, gb_addr_config);\n\n\tif ((rdev->config.cayman.max_backends_per_se == 1) &&\n\t    (rdev->flags & RADEON_IS_IGP)) {\n\t\tif ((disabled_rb_mask & 3) == 2) {\n\t\t\t \n\t\t\ttmp = 0x00000000;\n\t\t} else {\n\t\t\t \n\t\t\ttmp = 0x11111111;\n\t\t}\n\t} else {\n\t\ttmp = gb_addr_config & NUM_PIPES_MASK;\n\t\ttmp = r6xx_remap_render_backend(rdev, tmp,\n\t\t\t\t\t\trdev->config.cayman.max_backends_per_se *\n\t\t\t\t\t\trdev->config.cayman.max_shader_engines,\n\t\t\t\t\t\tCAYMAN_MAX_BACKENDS, disabled_rb_mask);\n\t}\n\trdev->config.cayman.backend_map = tmp;\n\tWREG32(GB_BACKEND_MAP, tmp);\n\n\tcgts_tcc_disable = 0xffff0000;\n\tfor (i = 0; i < rdev->config.cayman.max_texture_channel_caches; i++)\n\t\tcgts_tcc_disable &= ~(1 << (16 + i));\n\tWREG32(CGTS_TCC_DISABLE, cgts_tcc_disable);\n\tWREG32(CGTS_SYS_TCC_DISABLE, cgts_tcc_disable);\n\tWREG32(CGTS_USER_SYS_TCC_DISABLE, cgts_tcc_disable);\n\tWREG32(CGTS_USER_TCC_DISABLE, cgts_tcc_disable);\n\n\t \n\tcgts_sm_ctrl_reg = RREG32(CGTS_SM_CTRL_REG);\n\tfor (i = 0; i < 16; i++)\n\t\tWREG32(CGTS_SM_CTRL_REG, OVERRIDE);\n\tWREG32(CGTS_SM_CTRL_REG, cgts_sm_ctrl_reg);\n\n\t \n\tWREG32(CP_MEQ_THRESHOLDS, MEQ1_START(0x30) | MEQ2_START(0x60));\n\n\tsx_debug_1 = RREG32(SX_DEBUG_1);\n\tsx_debug_1 |= ENABLE_NEW_SMX_ADDRESS;\n\tWREG32(SX_DEBUG_1, sx_debug_1);\n\n\tsmx_dc_ctl0 = RREG32(SMX_DC_CTL0);\n\tsmx_dc_ctl0 &= ~NUMBER_OF_SETS(0x1ff);\n\tsmx_dc_ctl0 |= NUMBER_OF_SETS(rdev->config.cayman.sx_num_of_sets);\n\tWREG32(SMX_DC_CTL0, smx_dc_ctl0);\n\n\tWREG32(SPI_CONFIG_CNTL_1, VTX_DONE_DELAY(4) | CRC_SIMD_ID_WADDR_DISABLE);\n\n\t \n\tWREG32(VGT_OFFCHIP_LDS_BASE, 0);\n\tWREG32(SQ_LSTMP_RING_BASE, 0);\n\tWREG32(SQ_HSTMP_RING_BASE, 0);\n\tWREG32(SQ_ESTMP_RING_BASE, 0);\n\tWREG32(SQ_GSTMP_RING_BASE, 0);\n\tWREG32(SQ_VSTMP_RING_BASE, 0);\n\tWREG32(SQ_PSTMP_RING_BASE, 0);\n\n\tWREG32(TA_CNTL_AUX, DISABLE_CUBE_ANISO);\n\n\tWREG32(SX_EXPORT_BUFFER_SIZES, (COLOR_BUFFER_SIZE((rdev->config.cayman.sx_max_export_size / 4) - 1) |\n\t\t\t\t\tPOSITION_BUFFER_SIZE((rdev->config.cayman.sx_max_export_pos_size / 4) - 1) |\n\t\t\t\t\tSMX_BUFFER_SIZE((rdev->config.cayman.sx_max_export_smx_size / 4) - 1)));\n\n\tWREG32(PA_SC_FIFO_SIZE, (SC_PRIM_FIFO_SIZE(rdev->config.cayman.sc_prim_fifo_size) |\n\t\t\t\t SC_HIZ_TILE_FIFO_SIZE(rdev->config.cayman.sc_hiz_tile_fifo_size) |\n\t\t\t\t SC_EARLYZ_TILE_FIFO_SIZE(rdev->config.cayman.sc_earlyz_tile_fifo_size)));\n\n\n\tWREG32(VGT_NUM_INSTANCES, 1);\n\n\tWREG32(CP_PERFMON_CNTL, 0);\n\n\tWREG32(SQ_MS_FIFO_SIZES, (CACHE_FIFO_SIZE(16 * rdev->config.cayman.sq_num_cf_insts) |\n\t\t\t\t  FETCH_FIFO_HIWATER(0x4) |\n\t\t\t\t  DONE_FIFO_HIWATER(0xe0) |\n\t\t\t\t  ALU_UPDATE_FIFO_HIWATER(0x8)));\n\n\tWREG32(SQ_GPR_RESOURCE_MGMT_1, NUM_CLAUSE_TEMP_GPRS(4));\n\tWREG32(SQ_CONFIG, (VC_ENABLE |\n\t\t\t   EXPORT_SRC_C |\n\t\t\t   GFX_PRIO(0) |\n\t\t\t   CS1_PRIO(0) |\n\t\t\t   CS2_PRIO(1)));\n\tWREG32(SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, DYN_GPR_ENABLE);\n\n\tWREG32(PA_SC_FORCE_EOV_MAX_CNTS, (FORCE_EOV_MAX_CLK_CNT(4095) |\n\t\t\t\t\t  FORCE_EOV_MAX_REZ_CNT(255)));\n\n\tWREG32(VGT_CACHE_INVALIDATION, CACHE_INVALIDATION(VC_AND_TC) |\n\t       AUTO_INVLD_EN(ES_AND_GS_AUTO));\n\n\tWREG32(VGT_GS_VERTEX_REUSE, 16);\n\tWREG32(PA_SC_LINE_STIPPLE_STATE, 0);\n\n\tWREG32(CB_PERF_CTR0_SEL_0, 0);\n\tWREG32(CB_PERF_CTR0_SEL_1, 0);\n\tWREG32(CB_PERF_CTR1_SEL_0, 0);\n\tWREG32(CB_PERF_CTR1_SEL_1, 0);\n\tWREG32(CB_PERF_CTR2_SEL_0, 0);\n\tWREG32(CB_PERF_CTR2_SEL_1, 0);\n\tWREG32(CB_PERF_CTR3_SEL_0, 0);\n\tWREG32(CB_PERF_CTR3_SEL_1, 0);\n\n\ttmp = RREG32(HDP_MISC_CNTL);\n\ttmp |= HDP_FLUSH_INVALIDATE_CACHE;\n\tWREG32(HDP_MISC_CNTL, tmp);\n\n\thdp_host_path_cntl = RREG32(HDP_HOST_PATH_CNTL);\n\tWREG32(HDP_HOST_PATH_CNTL, hdp_host_path_cntl);\n\n\tWREG32(PA_CL_ENHANCE, CLIP_VTX_REORDER_ENA | NUM_CLIP_SEQ(3));\n\n\tudelay(50);\n\n\t \n\tif (rdev->family == CHIP_ARUBA) {\n\t\ttmp = RREG32_CG(CG_CGTT_LOCAL_0);\n\t\ttmp &= ~0x00380000;\n\t\tWREG32_CG(CG_CGTT_LOCAL_0, tmp);\n\t\ttmp = RREG32_CG(CG_CGTT_LOCAL_1);\n\t\ttmp &= ~0x0e000000;\n\t\tWREG32_CG(CG_CGTT_LOCAL_1, tmp);\n\t}\n}\n\n \nvoid cayman_pcie_gart_tlb_flush(struct radeon_device *rdev)\n{\n\t \n\tWREG32(HDP_MEM_COHERENCY_FLUSH_CNTL, 0x1);\n\n\t \n\tWREG32(VM_INVALIDATE_REQUEST, 1);\n}\n\nstatic int cayman_pcie_gart_enable(struct radeon_device *rdev)\n{\n\tint i, r;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tWREG32(MC_VM_MX_L1_TLB_CNTL,\n\t       (0xA << 7) |\n\t       ENABLE_L1_TLB |\n\t       ENABLE_L1_FRAGMENT_PROCESSING |\n\t       SYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t       ENABLE_ADVANCED_DRIVER_MODEL |\n\t       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE |\n\t       ENABLE_L2_FRAGMENT_PROCESSING |\n\t       ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |\n\t       EFFECTIVE_L2_QUEUE_SIZE(7) |\n\t       CONTEXT1_IDENTITY_ACCESS_MODE(1));\n\tWREG32(VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS | INVALIDATE_L2_CACHE);\n\tWREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |\n\t       BANK_SELECT(6) |\n\t       L2_CACHE_BIGK_FRAGMENT_SIZE(6));\n\t \n\tWREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev->gart.table_addr >> 12);\n\tWREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,\n\t\t\t(u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT0_CNTL2, 0);\n\tWREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_DEFAULT);\n\n\tWREG32(0x15D4, 0);\n\tWREG32(0x15D8, 0);\n\tWREG32(0x15DC, 0);\n\n\t \n\t \n\tfor (i = 1; i < 8; i++) {\n\t\tWREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR + (i << 2), 0);\n\t\tWREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i << 2),\n\t\t\trdev->vm_manager.max_pfn - 1);\n\t\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2),\n\t\t       rdev->vm_manager.saved_table_addr[i]);\n\t}\n\n\t \n\tWREG32(VM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,\n\t       (u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT1_CNTL2, 4);\n\tWREG32(VM_CONTEXT1_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(1) |\n\t\t\t\tPAGE_TABLE_BLOCK_SIZE(radeon_vm_block_size - 9) |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tDUMMY_PAGE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tDUMMY_PAGE_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tPDE0_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tPDE0_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tVALID_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tVALID_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tREAD_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tREAD_PROTECTION_FAULT_ENABLE_DEFAULT |\n\t\t\t\tWRITE_PROTECTION_FAULT_ENABLE_INTERRUPT |\n\t\t\t\tWRITE_PROTECTION_FAULT_ENABLE_DEFAULT);\n\n\tcayman_pcie_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nstatic void cayman_pcie_gart_disable(struct radeon_device *rdev)\n{\n\tunsigned i;\n\n\tfor (i = 1; i < 8; ++i) {\n\t\trdev->vm_manager.saved_table_addr[i] = RREG32(\n\t\t\tVM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i << 2));\n\t}\n\n\t \n\tWREG32(VM_CONTEXT0_CNTL, 0);\n\tWREG32(VM_CONTEXT1_CNTL, 0);\n\t \n\tWREG32(MC_VM_MX_L1_TLB_CNTL, ENABLE_L1_FRAGMENT_PROCESSING |\n\t       SYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t       SYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU);\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t       ENABLE_L2_PDE0_CACHE_LRU_UPDATE_BY_WRITE |\n\t       EFFECTIVE_L2_QUEUE_SIZE(7) |\n\t       CONTEXT1_IDENTITY_ACCESS_MODE(1));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |\n\t       L2_CACHE_BIGK_FRAGMENT_SIZE(6));\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\nstatic void cayman_pcie_gart_fini(struct radeon_device *rdev)\n{\n\tcayman_pcie_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n\tradeon_gart_fini(rdev);\n}\n\nvoid cayman_cp_int_cntl_setup(struct radeon_device *rdev,\n\t\t\t      int ring, u32 cp_int_cntl)\n{\n\tWREG32(SRBM_GFX_CNTL, RINGID(ring));\n\tWREG32(CP_INT_CNTL, cp_int_cntl);\n}\n\n \nvoid cayman_fence_ring_emit(struct radeon_device *rdev,\n\t\t\t    struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\n\tu32 cp_coher_cntl = PACKET3_FULL_CACHE_ENA | PACKET3_TC_ACTION_ENA |\n\t\tPACKET3_SH_ACTION_ENA;\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\tradeon_ring_write(ring, PACKET3_ENGINE_ME | cp_coher_cntl);\n\tradeon_ring_write(ring, 0xFFFFFFFF);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 10);  \n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\tradeon_ring_write(ring, EVENT_TYPE(CACHE_FLUSH_AND_INV_EVENT_TS) | EVENT_INDEX(5));\n\tradeon_ring_write(ring, lower_32_bits(addr));\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xff) | DATA_SEL(1) | INT_SEL(2));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, 0);\n}\n\nvoid cayman_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tunsigned vm_id = ib->vm ? ib->vm->ids[ib->ring].id : 0;\n\tu32 cp_coher_cntl = PACKET3_FULL_CACHE_ENA | PACKET3_TC_ACTION_ENA |\n\t\tPACKET3_SH_ACTION_ENA;\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_MODE_CONTROL, 0));\n\tradeon_ring_write(ring, 1);\n\n\tif (ring->rptr_save_reg) {\n\t\tuint32_t next_rptr = ring->wptr + 3 + 4 + 8;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tradeon_ring_write(ring, ((ring->rptr_save_reg - \n\t\t\t\t\t  PACKET3_SET_CONFIG_REG_START) >> 2));\n\t\tradeon_ring_write(ring, next_rptr);\n\t}\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tradeon_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t  (2 << 0) |\n#endif\n\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tradeon_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFF);\n\tradeon_ring_write(ring, ib->length_dw | (vm_id << 24));\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\tradeon_ring_write(ring, PACKET3_ENGINE_ME | cp_coher_cntl);\n\tradeon_ring_write(ring, 0xFFFFFFFF);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, (vm_id << 24) | 10);  \n}\n\nstatic void cayman_cp_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32(CP_ME_CNTL, 0);\n\telse {\n\t\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\n\t\tWREG32(CP_ME_CNTL, (CP_ME_HALT | CP_PFP_HALT));\n\t\tWREG32(SCRATCH_UMSK, 0);\n\t\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\t}\n}\n\nu32 cayman_gfx_get_rptr(struct radeon_device *rdev,\n\t\t\tstruct radeon_ring *ring)\n{\n\tu32 rptr;\n\n\tif (rdev->wb.enabled)\n\t\trptr = rdev->wb.wb[ring->rptr_offs/4];\n\telse {\n\t\tif (ring->idx == RADEON_RING_TYPE_GFX_INDEX)\n\t\t\trptr = RREG32(CP_RB0_RPTR);\n\t\telse if (ring->idx == CAYMAN_RING_TYPE_CP1_INDEX)\n\t\t\trptr = RREG32(CP_RB1_RPTR);\n\t\telse\n\t\t\trptr = RREG32(CP_RB2_RPTR);\n\t}\n\n\treturn rptr;\n}\n\nu32 cayman_gfx_get_wptr(struct radeon_device *rdev,\n\t\t\tstruct radeon_ring *ring)\n{\n\tu32 wptr;\n\n\tif (ring->idx == RADEON_RING_TYPE_GFX_INDEX)\n\t\twptr = RREG32(CP_RB0_WPTR);\n\telse if (ring->idx == CAYMAN_RING_TYPE_CP1_INDEX)\n\t\twptr = RREG32(CP_RB1_WPTR);\n\telse\n\t\twptr = RREG32(CP_RB2_WPTR);\n\n\treturn wptr;\n}\n\nvoid cayman_gfx_set_wptr(struct radeon_device *rdev,\n\t\t\t struct radeon_ring *ring)\n{\n\tif (ring->idx == RADEON_RING_TYPE_GFX_INDEX) {\n\t\tWREG32(CP_RB0_WPTR, ring->wptr);\n\t\t(void)RREG32(CP_RB0_WPTR);\n\t} else if (ring->idx == CAYMAN_RING_TYPE_CP1_INDEX) {\n\t\tWREG32(CP_RB1_WPTR, ring->wptr);\n\t\t(void)RREG32(CP_RB1_WPTR);\n\t} else {\n\t\tWREG32(CP_RB2_WPTR, ring->wptr);\n\t\t(void)RREG32(CP_RB2_WPTR);\n\t}\n}\n\nstatic int cayman_cp_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data;\n\tint i;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw)\n\t\treturn -EINVAL;\n\n\tcayman_cp_enable(rdev, false);\n\n\tfw_data = (const __be32 *)rdev->pfp_fw->data;\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tfor (i = 0; i < CAYMAN_PFP_UCODE_SIZE; i++)\n\t\tWREG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\n\tfw_data = (const __be32 *)rdev->me_fw->data;\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tfor (i = 0; i < CAYMAN_PM4_UCODE_SIZE; i++)\n\t\tWREG32(CP_ME_RAM_DATA, be32_to_cpup(fw_data++));\n\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tWREG32(CP_ME_RAM_RADDR, 0);\n\treturn 0;\n}\n\nstatic int cayman_cp_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r, i;\n\n\tr = radeon_ring_lock(rdev, ring, 7);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET3(PACKET3_ME_INITIALIZE, 5));\n\tradeon_ring_write(ring, 0x1);\n\tradeon_ring_write(ring, 0x0);\n\tradeon_ring_write(ring, rdev->config.cayman.max_hw_contexts - 1);\n\tradeon_ring_write(ring, PACKET3_ME_INITIALIZE_DEVICE_ID(1));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tcayman_cp_enable(rdev, true);\n\n\tr = radeon_ring_lock(rdev, ring, cayman_default_size + 19);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tfor (i = 0; i < cayman_default_size; i++)\n\t\tradeon_ring_write(ring, cayman_default_state[i]);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tradeon_ring_write(ring, 0);\n\n\t \n\tradeon_ring_write(ring, 0xc0026f00);\n\tradeon_ring_write(ring, 0x00000000);\n\tradeon_ring_write(ring, 0x00000000);\n\tradeon_ring_write(ring, 0x00000000);\n\n\t \n\tradeon_ring_write(ring, 0xc0036f00);\n\tradeon_ring_write(ring, 0x00000bc4);\n\tradeon_ring_write(ring, 0xffffffff);\n\tradeon_ring_write(ring, 0xffffffff);\n\tradeon_ring_write(ring, 0xffffffff);\n\n\tradeon_ring_write(ring, 0xc0026900);\n\tradeon_ring_write(ring, 0x00000316);\n\tradeon_ring_write(ring, 0x0000000e);  \n\tradeon_ring_write(ring, 0x00000010);  \n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\t \n\n\treturn 0;\n}\n\nstatic void cayman_cp_fini(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tcayman_cp_enable(rdev, false);\n\tradeon_ring_fini(rdev, ring);\n\tradeon_scratch_free(rdev, ring->rptr_save_reg);\n}\n\nstatic int cayman_cp_resume(struct radeon_device *rdev)\n{\n\tstatic const int ridx[] = {\n\t\tRADEON_RING_TYPE_GFX_INDEX,\n\t\tCAYMAN_RING_TYPE_CP1_INDEX,\n\t\tCAYMAN_RING_TYPE_CP2_INDEX\n\t};\n\tstatic const unsigned cp_rb_cntl[] = {\n\t\tCP_RB0_CNTL,\n\t\tCP_RB1_CNTL,\n\t\tCP_RB2_CNTL,\n\t};\n\tstatic const unsigned cp_rb_rptr_addr[] = {\n\t\tCP_RB0_RPTR_ADDR,\n\t\tCP_RB1_RPTR_ADDR,\n\t\tCP_RB2_RPTR_ADDR\n\t};\n\tstatic const unsigned cp_rb_rptr_addr_hi[] = {\n\t\tCP_RB0_RPTR_ADDR_HI,\n\t\tCP_RB1_RPTR_ADDR_HI,\n\t\tCP_RB2_RPTR_ADDR_HI\n\t};\n\tstatic const unsigned cp_rb_base[] = {\n\t\tCP_RB0_BASE,\n\t\tCP_RB1_BASE,\n\t\tCP_RB2_BASE\n\t};\n\tstatic const unsigned cp_rb_rptr[] = {\n\t\tCP_RB0_RPTR,\n\t\tCP_RB1_RPTR,\n\t\tCP_RB2_RPTR\n\t};\n\tstatic const unsigned cp_rb_wptr[] = {\n\t\tCP_RB0_WPTR,\n\t\tCP_RB1_WPTR,\n\t\tCP_RB2_WPTR\n\t};\n\tstruct radeon_ring *ring;\n\tint i, r;\n\n\t \n\tWREG32(GRBM_SOFT_RESET, (SOFT_RESET_CP |\n\t\t\t\t SOFT_RESET_PA |\n\t\t\t\t SOFT_RESET_SH |\n\t\t\t\t SOFT_RESET_VGT |\n\t\t\t\t SOFT_RESET_SPI |\n\t\t\t\t SOFT_RESET_SX));\n\tRREG32(GRBM_SOFT_RESET);\n\tmdelay(15);\n\tWREG32(GRBM_SOFT_RESET, 0);\n\tRREG32(GRBM_SOFT_RESET);\n\n\tWREG32(CP_SEM_WAIT_TIMER, 0x0);\n\tWREG32(CP_SEM_INCOMPLETE_TIMER_CNTL, 0x0);\n\n\t \n\tWREG32(CP_RB_WPTR_DELAY, 0);\n\n\tWREG32(CP_DEBUG, (1 << 27));\n\n\t \n\tWREG32(SCRATCH_ADDR, ((rdev->wb.gpu_addr + RADEON_WB_SCRATCH_OFFSET) >> 8) & 0xFFFFFFFF);\n\tWREG32(SCRATCH_UMSK, 0xff);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tuint32_t rb_cntl;\n\t\tuint64_t addr;\n\n\t\t \n\t\tring = &rdev->ring[ridx[i]];\n\t\trb_cntl = order_base_2(ring->ring_size / 8);\n\t\trb_cntl |= order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8;\n#ifdef __BIG_ENDIAN\n\t\trb_cntl |= BUF_SWAP_32BIT;\n#endif\n\t\tWREG32(cp_rb_cntl[i], rb_cntl);\n\n\t\t \n\t\taddr = rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET;\n\t\tWREG32(cp_rb_rptr_addr[i], addr & 0xFFFFFFFC);\n\t\tWREG32(cp_rb_rptr_addr_hi[i], upper_32_bits(addr) & 0xFF);\n\t}\n\n\t \n\tfor (i = 0; i < 3; ++i) {\n\t\tring = &rdev->ring[ridx[i]];\n\t\tWREG32(cp_rb_base[i], ring->gpu_addr >> 8);\n\t}\n\n\tfor (i = 0; i < 3; ++i) {\n\t\t \n\t\tring = &rdev->ring[ridx[i]];\n\t\tWREG32_P(cp_rb_cntl[i], RB_RPTR_WR_ENA, ~RB_RPTR_WR_ENA);\n\n\t\tring->wptr = 0;\n\t\tWREG32(cp_rb_rptr[i], 0);\n\t\tWREG32(cp_rb_wptr[i], ring->wptr);\n\n\t\tmdelay(1);\n\t\tWREG32_P(cp_rb_cntl[i], 0, ~RB_RPTR_WR_ENA);\n\t}\n\n\t \n\tcayman_cp_start(rdev);\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = true;\n\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;\n\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;\n\t \n\tr = radeon_ring_test(rdev, RADEON_RING_TYPE_GFX_INDEX, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX]);\n\tif (r) {\n\t\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;\n\t\trdev->ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;\n\t\treturn r;\n\t}\n\n\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\n\n\treturn 0;\n}\n\nu32 cayman_gpu_check_soft_reset(struct radeon_device *rdev)\n{\n\tu32 reset_mask = 0;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(GRBM_STATUS);\n\tif (tmp & (PA_BUSY | SC_BUSY |\n\t\t   SH_BUSY | SX_BUSY |\n\t\t   TA_BUSY | VGT_BUSY |\n\t\t   DB_BUSY | CB_BUSY |\n\t\t   GDS_BUSY | SPI_BUSY |\n\t\t   IA_BUSY | IA_BUSY_NO_DMA))\n\t\treset_mask |= RADEON_RESET_GFX;\n\n\tif (tmp & (CF_RQ_PENDING | PF_RQ_PENDING |\n\t\t   CP_BUSY | CP_COHERENCY_BUSY))\n\t\treset_mask |= RADEON_RESET_CP;\n\n\tif (tmp & GRBM_EE_BUSY)\n\t\treset_mask |= RADEON_RESET_GRBM | RADEON_RESET_GFX | RADEON_RESET_CP;\n\n\t \n\ttmp = RREG32(DMA_STATUS_REG + DMA0_REGISTER_OFFSET);\n\tif (!(tmp & DMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\t \n\ttmp = RREG32(DMA_STATUS_REG + DMA1_REGISTER_OFFSET);\n\tif (!(tmp & DMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA1;\n\n\t \n\ttmp = RREG32(SRBM_STATUS2);\n\tif (tmp & DMA_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\tif (tmp & DMA1_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA1;\n\n\t \n\ttmp = RREG32(SRBM_STATUS);\n\tif (tmp & (RLC_RQ_PENDING | RLC_BUSY))\n\t\treset_mask |= RADEON_RESET_RLC;\n\n\tif (tmp & IH_BUSY)\n\t\treset_mask |= RADEON_RESET_IH;\n\n\tif (tmp & SEM_BUSY)\n\t\treset_mask |= RADEON_RESET_SEM;\n\n\tif (tmp & GRBM_RQ_PENDING)\n\t\treset_mask |= RADEON_RESET_GRBM;\n\n\tif (tmp & VMC_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\tif (tmp & (MCB_BUSY | MCB_NON_DISPLAY_BUSY |\n\t\t   MCC_BUSY | MCD_BUSY))\n\t\treset_mask |= RADEON_RESET_MC;\n\n\tif (evergreen_is_display_hung(rdev))\n\t\treset_mask |= RADEON_RESET_DISPLAY;\n\n\t \n\ttmp = RREG32(VM_L2_STATUS);\n\tif (tmp & L2_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\t \n\tif (reset_mask & RADEON_RESET_MC) {\n\t\tDRM_DEBUG(\"MC busy: 0x%08X, clearing.\\n\", reset_mask);\n\t\treset_mask &= ~RADEON_RESET_MC;\n\t}\n\n\treturn reset_mask;\n}\n\nstatic void cayman_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)\n{\n\tstruct evergreen_mc_save save;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif (reset_mask == 0)\n\t\treturn;\n\n\tdev_info(rdev->dev, \"GPU softreset: 0x%08X\\n\", reset_mask);\n\n\tevergreen_print_gpu_status_regs(rdev);\n\tdev_info(rdev->dev, \"  VM_CONTEXT0_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t RREG32(0x14F8));\n\tdev_info(rdev->dev, \"  VM_CONTEXT0_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t RREG32(0x14D8));\n\tdev_info(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t RREG32(0x14FC));\n\tdev_info(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t RREG32(0x14DC));\n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT);\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\t \n\t\ttmp = RREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET, tmp);\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA1) {\n\t\t \n\t\ttmp = RREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET, tmp);\n\t}\n\n\tudelay(50);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\n\tif (reset_mask & (RADEON_RESET_GFX | RADEON_RESET_COMPUTE)) {\n\t\tgrbm_soft_reset = SOFT_RESET_CB |\n\t\t\tSOFT_RESET_DB |\n\t\t\tSOFT_RESET_GDS |\n\t\t\tSOFT_RESET_PA |\n\t\t\tSOFT_RESET_SC |\n\t\t\tSOFT_RESET_SPI |\n\t\t\tSOFT_RESET_SH |\n\t\t\tSOFT_RESET_SX |\n\t\t\tSOFT_RESET_TC |\n\t\t\tSOFT_RESET_TA |\n\t\t\tSOFT_RESET_VGT |\n\t\t\tSOFT_RESET_IA;\n\t}\n\n\tif (reset_mask & RADEON_RESET_CP) {\n\t\tgrbm_soft_reset |= SOFT_RESET_CP | SOFT_RESET_VGT;\n\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA)\n\t\tsrbm_soft_reset |= SOFT_RESET_DMA;\n\n\tif (reset_mask & RADEON_RESET_DMA1)\n\t\tsrbm_soft_reset |= SOFT_RESET_DMA1;\n\n\tif (reset_mask & RADEON_RESET_DISPLAY)\n\t\tsrbm_soft_reset |= SOFT_RESET_DC;\n\n\tif (reset_mask & RADEON_RESET_RLC)\n\t\tsrbm_soft_reset |= SOFT_RESET_RLC;\n\n\tif (reset_mask & RADEON_RESET_SEM)\n\t\tsrbm_soft_reset |= SOFT_RESET_SEM;\n\n\tif (reset_mask & RADEON_RESET_IH)\n\t\tsrbm_soft_reset |= SOFT_RESET_IH;\n\n\tif (reset_mask & RADEON_RESET_GRBM)\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\n\tif (reset_mask & RADEON_RESET_VMC)\n\t\tsrbm_soft_reset |= SOFT_RESET_VMC;\n\n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tif (reset_mask & RADEON_RESET_MC)\n\t\t\tsrbm_soft_reset |= SOFT_RESET_MC;\n\t}\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(rdev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(rdev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t}\n\n\t \n\tudelay(50);\n\n\tevergreen_mc_resume(rdev, &save);\n\tudelay(50);\n\n\tevergreen_print_gpu_status_regs(rdev);\n}\n\nint cayman_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tu32 reset_mask;\n\n\tif (hard) {\n\t\tevergreen_gpu_pci_config_reset(rdev);\n\t\treturn 0;\n\t}\n\n\treset_mask = cayman_gpu_check_soft_reset(rdev);\n\n\tif (reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, true);\n\n\tcayman_gpu_soft_reset(rdev, reset_mask);\n\n\treset_mask = cayman_gpu_check_soft_reset(rdev);\n\n\tif (reset_mask)\n\t\tevergreen_gpu_pci_config_reset(rdev);\n\n\tr600_set_bios_scratch_engine_hung(rdev, false);\n\n\treturn 0;\n}\n\n \nbool cayman_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = cayman_gpu_check_soft_reset(rdev);\n\n\tif (!(reset_mask & (RADEON_RESET_GFX |\n\t\t\t    RADEON_RESET_COMPUTE |\n\t\t\t    RADEON_RESET_CP))) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\nstatic void cayman_uvd_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = radeon_uvd_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_uvd = false;\n\t\treturn;\n\t}\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[R600_RING_TYPE_UVD_INDEX], 4096);\n}\n\nstatic void cayman_uvd_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = uvd_v2_2_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_UVD_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size = 0;\n}\n\nstatic void cayman_uvd_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_uvd || !rdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, PACKET0(UVD_NO_OP, 0));\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = uvd_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic void cayman_vce_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (!rdev->has_vce)\n\t\treturn;\n\n\tr = radeon_vce_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_vce = false;\n\t\treturn;\n\t}\n\trdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[TN_RING_TYPE_VCE1_INDEX], 4096);\n\trdev->ring[TN_RING_TYPE_VCE2_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[TN_RING_TYPE_VCE2_INDEX], 4096);\n}\n\nstatic void cayman_vce_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_vce)\n\t\treturn;\n\n\tr = radeon_vce_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = vce_v1_0_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed VCE resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, TN_RING_TYPE_VCE1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, TN_RING_TYPE_VCE2_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE2 fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_size = 0;\n\trdev->ring[TN_RING_TYPE_VCE2_INDEX].ring_size = 0;\n}\n\nstatic void cayman_vce_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_vce || !rdev->ring[TN_RING_TYPE_VCE1_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, 0x0);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, 0x0);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE1 ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = vce_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing VCE (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic int cayman_startup(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r;\n\n\t \n\tevergreen_pcie_gen2_enable(rdev);\n\t \n\tevergreen_program_aspm(rdev);\n\n\t \n\tr = r600_vram_scratch_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tevergreen_mc_program(rdev);\n\n\tif (!(rdev->flags & RADEON_IS_IGP) && !rdev->pm.dpm_enabled) {\n\t\tr = ni_mc_load_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load MC firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = cayman_pcie_gart_enable(rdev);\n\tif (r)\n\t\treturn r;\n\tcayman_gpu_init(rdev);\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\trdev->rlc.reg_list = tn_rlc_save_restore_register_list;\n\t\trdev->rlc.reg_list_size =\n\t\t\t(u32)ARRAY_SIZE(tn_rlc_save_restore_register_list);\n\t\trdev->rlc.cs_data = cayman_cs_data;\n\t\tr = sumo_rlc_init(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tcayman_uvd_start(rdev);\n\tcayman_vce_start(rdev);\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_DMA_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, CAYMAN_RING_TYPE_DMA1_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = r600_irq_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: IH init failed (%d).\\n\", r);\n\t\tradeon_irq_kms_fini(rdev);\n\t\treturn r;\n\t}\n\tevergreen_irq_set(rdev);\n\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,\n\t\t\t     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, CAYMAN_WB_DMA1_RPTR_OFFSET,\n\t\t\t     DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tr = cayman_cp_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\tr = cayman_cp_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = cayman_dma_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tcayman_uvd_resume(rdev);\n\tcayman_vce_resume(rdev);\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_vm_manager_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"vm manager initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nint cayman_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\n\t \n\tni_init_golden_registers(rdev);\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_resume(rdev);\n\n\trdev->accel_working = true;\n\tr = cayman_startup(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"cayman startup failed on resume\\n\");\n\t\trdev->accel_working = false;\n\t\treturn r;\n\t}\n\treturn r;\n}\n\nint cayman_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tradeon_vm_manager_fini(rdev);\n\tcayman_cp_enable(rdev, false);\n\tcayman_dma_stop(rdev);\n\tif (rdev->has_uvd) {\n\t\tradeon_uvd_suspend(rdev);\n\t\tuvd_v1_0_fini(rdev);\n\t}\n\tevergreen_irq_suspend(rdev);\n\tradeon_wb_disable(rdev);\n\tcayman_pcie_gart_disable(rdev);\n\treturn 0;\n}\n\n \nint cayman_init(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r;\n\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting atombios for cayman GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_atombios_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (!radeon_card_posted(rdev)) {\n\t\tif (!rdev->bios) {\n\t\t\tdev_err(rdev->dev, \"Card not posted and no BIOS - ignoring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDRM_INFO(\"GPU not posted. posting now...\\n\");\n\t\tatom_asic_init(rdev->mode_info.atom_context);\n\t}\n\t \n\tni_init_golden_registers(rdev);\n\t \n\tr600_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = evergreen_mc_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->rlc_fw) {\n\t\t\tr = ni_init_microcode(rdev);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->rlc_fw || !rdev->mc_fw) {\n\t\t\tr = ni_init_microcode(rdev);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tradeon_pm_init(rdev);\n\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 1024 * 1024);\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 64 * 1024);\n\n\tring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\n\tring->ring_obj = NULL;\n\tr600_ring_init(rdev, ring, 64 * 1024);\n\n\tcayman_uvd_init(rdev);\n\tcayman_vce_init(rdev);\n\n\trdev->ih.ring_obj = NULL;\n\tr600_ih_ring_init(rdev, 64 * 1024);\n\n\tr = r600_pcie_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\trdev->accel_working = true;\n\tr = cayman_startup(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"disabling GPU acceleration\\n\");\n\t\tcayman_cp_fini(rdev);\n\t\tcayman_dma_fini(rdev);\n\t\tr600_irq_fini(rdev);\n\t\tif (rdev->flags & RADEON_IS_IGP)\n\t\t\tsumo_rlc_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_vm_manager_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tcayman_pcie_gart_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\n\t \n\tif (!rdev->mc_fw && !(rdev->flags & RADEON_IS_IGP)) {\n\t\tDRM_ERROR(\"radeon: MC ucode required for NI+.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid cayman_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tcayman_cp_fini(rdev);\n\tcayman_dma_fini(rdev);\n\tr600_irq_fini(rdev);\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tsumo_rlc_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_vm_manager_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tuvd_v1_0_fini(rdev);\n\tradeon_uvd_fini(rdev);\n\tif (rdev->has_vce)\n\t\tradeon_vce_fini(rdev);\n\tcayman_pcie_gart_fini(rdev);\n\tr600_vram_scratch_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\n \nint cayman_vm_init(struct radeon_device *rdev)\n{\n\t \n\trdev->vm_manager.nvm = 8;\n\t \n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tu64 tmp = RREG32(FUS_MC_VM_FB_OFFSET);\n\t\ttmp <<= 22;\n\t\trdev->vm_manager.vram_base_offset = tmp;\n\t} else\n\t\trdev->vm_manager.vram_base_offset = 0;\n\treturn 0;\n}\n\nvoid cayman_vm_fini(struct radeon_device *rdev)\n{\n}\n\n \nvoid cayman_vm_decode_fault(struct radeon_device *rdev,\n\t\t\t    u32 status, u32 addr)\n{\n\tu32 mc_id = (status & MEMORY_CLIENT_ID_MASK) >> MEMORY_CLIENT_ID_SHIFT;\n\tu32 vmid = (status & FAULT_VMID_MASK) >> FAULT_VMID_SHIFT;\n\tu32 protections = (status & PROTECTIONS_MASK) >> PROTECTIONS_SHIFT;\n\tchar *block;\n\n\tswitch (mc_id) {\n\tcase 32:\n\tcase 16:\n\tcase 96:\n\tcase 80:\n\tcase 160:\n\tcase 144:\n\tcase 224:\n\tcase 208:\n\t\tblock = \"CB\";\n\t\tbreak;\n\tcase 33:\n\tcase 17:\n\tcase 97:\n\tcase 81:\n\tcase 161:\n\tcase 145:\n\tcase 225:\n\tcase 209:\n\t\tblock = \"CB_FMASK\";\n\t\tbreak;\n\tcase 34:\n\tcase 18:\n\tcase 98:\n\tcase 82:\n\tcase 162:\n\tcase 146:\n\tcase 226:\n\tcase 210:\n\t\tblock = \"CB_CMASK\";\n\t\tbreak;\n\tcase 35:\n\tcase 19:\n\tcase 99:\n\tcase 83:\n\tcase 163:\n\tcase 147:\n\tcase 227:\n\tcase 211:\n\t\tblock = \"CB_IMMED\";\n\t\tbreak;\n\tcase 36:\n\tcase 20:\n\tcase 100:\n\tcase 84:\n\tcase 164:\n\tcase 148:\n\tcase 228:\n\tcase 212:\n\t\tblock = \"DB\";\n\t\tbreak;\n\tcase 37:\n\tcase 21:\n\tcase 101:\n\tcase 85:\n\tcase 165:\n\tcase 149:\n\tcase 229:\n\tcase 213:\n\t\tblock = \"DB_HTILE\";\n\t\tbreak;\n\tcase 38:\n\tcase 22:\n\tcase 102:\n\tcase 86:\n\tcase 166:\n\tcase 150:\n\tcase 230:\n\tcase 214:\n\t\tblock = \"SX\";\n\t\tbreak;\n\tcase 39:\n\tcase 23:\n\tcase 103:\n\tcase 87:\n\tcase 167:\n\tcase 151:\n\tcase 231:\n\tcase 215:\n\t\tblock = \"DB_STEN\";\n\t\tbreak;\n\tcase 40:\n\tcase 24:\n\tcase 104:\n\tcase 88:\n\tcase 232:\n\tcase 216:\n\tcase 168:\n\tcase 152:\n\t\tblock = \"TC_TFETCH\";\n\t\tbreak;\n\tcase 41:\n\tcase 25:\n\tcase 105:\n\tcase 89:\n\tcase 233:\n\tcase 217:\n\tcase 169:\n\tcase 153:\n\t\tblock = \"TC_VFETCH\";\n\t\tbreak;\n\tcase 42:\n\tcase 26:\n\tcase 106:\n\tcase 90:\n\tcase 234:\n\tcase 218:\n\tcase 170:\n\tcase 154:\n\t\tblock = \"VC\";\n\t\tbreak;\n\tcase 112:\n\t\tblock = \"CP\";\n\t\tbreak;\n\tcase 113:\n\tcase 114:\n\t\tblock = \"SH\";\n\t\tbreak;\n\tcase 115:\n\t\tblock = \"VGT\";\n\t\tbreak;\n\tcase 178:\n\t\tblock = \"IH\";\n\t\tbreak;\n\tcase 51:\n\t\tblock = \"RLC\";\n\t\tbreak;\n\tcase 55:\n\t\tblock = \"DMA\";\n\t\tbreak;\n\tcase 56:\n\t\tblock = \"HDP\";\n\t\tbreak;\n\tdefault:\n\t\tblock = \"unknown\";\n\t\tbreak;\n\t}\n\n\tprintk(\"VM fault (0x%02x, vmid %d) at page %u, %s from %s (%d)\\n\",\n\t       protections, vmid, addr,\n\t       (status & MEMORY_CLIENT_RW_MASK) ? \"write\" : \"read\",\n\t       block, mc_id);\n}\n\n \nvoid cayman_vm_flush(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t     unsigned vm_id, uint64_t pd_addr)\n{\n\tradeon_ring_write(ring, PACKET0(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (vm_id << 2), 0));\n\tradeon_ring_write(ring, pd_addr >> 12);\n\n\t \n\tradeon_ring_write(ring, PACKET0(HDP_MEM_COHERENCY_FLUSH_CNTL, 0));\n\tradeon_ring_write(ring, 0x1);\n\n\t \n\tradeon_ring_write(ring, PACKET0(VM_INVALIDATE_REQUEST, 0));\n\tradeon_ring_write(ring, 1 << vm_id);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_WAIT_REG_MEM, 5));\n\tradeon_ring_write(ring, (WAIT_REG_MEM_FUNCTION(0) |   \n\t\t\t\t WAIT_REG_MEM_ENGINE(0)));  \n\tradeon_ring_write(ring, VM_INVALIDATE_REQUEST >> 2);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, 0x20);  \n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\tradeon_ring_write(ring, 0x0);\n}\n\nint tn_set_vce_clocks(struct radeon_device *rdev, u32 evclk, u32 ecclk)\n{\n\tstruct atom_clock_dividers dividers;\n\tint r, i;\n\n\tr = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t   ecclk, false, &dividers);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (RREG32(CG_ECLK_STATUS) & ECLK_STATUS)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (i == 100)\n\t\treturn -ETIMEDOUT;\n\n\tWREG32_P(CG_ECLK_CNTL, dividers.post_div, ~(ECLK_DIR_CNTL_EN|ECLK_DIVIDER_MASK));\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (RREG32(CG_ECLK_STATUS) & ECLK_STATUS)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (i == 100)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}