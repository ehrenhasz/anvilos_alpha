{
  "module_name": "evergreen.c",
  "hash_id": "a41b330a722c8eff8ad1d4b5bb911244120ec12afa7a32280eabc0695a2cd81d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/evergreen.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n\n#include \"atom.h\"\n#include \"avivod.h\"\n#include \"cik.h\"\n#include \"ni.h\"\n#include \"rv770.h\"\n#include \"evergreen.h\"\n#include \"evergreen_blit_shaders.h\"\n#include \"evergreen_reg.h\"\n#include \"evergreend.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"radeon_ucode.h\"\n#include \"si.h\"\n\n#define DC_HPDx_CONTROL(x)        (DC_HPD1_CONTROL     + (x * 0xc))\n#define DC_HPDx_INT_CONTROL(x)    (DC_HPD1_INT_CONTROL + (x * 0xc))\n#define DC_HPDx_INT_STATUS_REG(x) (DC_HPD1_INT_STATUS  + (x * 0xc))\n\n \nu32 eg_cg_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->cg_idx_lock, flags);\n\tWREG32(EVERGREEN_CG_IND_ADDR, ((reg) & 0xffff));\n\tr = RREG32(EVERGREEN_CG_IND_DATA);\n\tspin_unlock_irqrestore(&rdev->cg_idx_lock, flags);\n\treturn r;\n}\n\nvoid eg_cg_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->cg_idx_lock, flags);\n\tWREG32(EVERGREEN_CG_IND_ADDR, ((reg) & 0xffff));\n\tWREG32(EVERGREEN_CG_IND_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->cg_idx_lock, flags);\n}\n\nu32 eg_pif_phy0_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->pif_idx_lock, flags);\n\tWREG32(EVERGREEN_PIF_PHY0_INDEX, ((reg) & 0xffff));\n\tr = RREG32(EVERGREEN_PIF_PHY0_DATA);\n\tspin_unlock_irqrestore(&rdev->pif_idx_lock, flags);\n\treturn r;\n}\n\nvoid eg_pif_phy0_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->pif_idx_lock, flags);\n\tWREG32(EVERGREEN_PIF_PHY0_INDEX, ((reg) & 0xffff));\n\tWREG32(EVERGREEN_PIF_PHY0_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->pif_idx_lock, flags);\n}\n\nu32 eg_pif_phy1_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->pif_idx_lock, flags);\n\tWREG32(EVERGREEN_PIF_PHY1_INDEX, ((reg) & 0xffff));\n\tr = RREG32(EVERGREEN_PIF_PHY1_DATA);\n\tspin_unlock_irqrestore(&rdev->pif_idx_lock, flags);\n\treturn r;\n}\n\nvoid eg_pif_phy1_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->pif_idx_lock, flags);\n\tWREG32(EVERGREEN_PIF_PHY1_INDEX, ((reg) & 0xffff));\n\tWREG32(EVERGREEN_PIF_PHY1_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->pif_idx_lock, flags);\n}\n\nstatic const u32 crtc_offsets[6] =\n{\n\tEVERGREEN_CRTC0_REGISTER_OFFSET,\n\tEVERGREEN_CRTC1_REGISTER_OFFSET,\n\tEVERGREEN_CRTC2_REGISTER_OFFSET,\n\tEVERGREEN_CRTC3_REGISTER_OFFSET,\n\tEVERGREEN_CRTC4_REGISTER_OFFSET,\n\tEVERGREEN_CRTC5_REGISTER_OFFSET\n};\n\n#include \"clearstate_evergreen.h\"\n\nstatic const u32 sumo_rlc_save_restore_register_list[] =\n{\n\t0x98fc,\n\t0x9830,\n\t0x9834,\n\t0x9838,\n\t0x9870,\n\t0x9874,\n\t0x8a14,\n\t0x8b24,\n\t0x8bcc,\n\t0x8b10,\n\t0x8d00,\n\t0x8d04,\n\t0x8c00,\n\t0x8c04,\n\t0x8c08,\n\t0x8c0c,\n\t0x8d8c,\n\t0x8c20,\n\t0x8c24,\n\t0x8c28,\n\t0x8c18,\n\t0x8c1c,\n\t0x8cf0,\n\t0x8e2c,\n\t0x8e38,\n\t0x8c30,\n\t0x9508,\n\t0x9688,\n\t0x9608,\n\t0x960c,\n\t0x9610,\n\t0x9614,\n\t0x88c4,\n\t0x88d4,\n\t0xa008,\n\t0x900c,\n\t0x9100,\n\t0x913c,\n\t0x98f8,\n\t0x98f4,\n\t0x9b7c,\n\t0x3f8c,\n\t0x8950,\n\t0x8954,\n\t0x8a18,\n\t0x8b28,\n\t0x9144,\n\t0x9148,\n\t0x914c,\n\t0x3f90,\n\t0x3f94,\n\t0x915c,\n\t0x9160,\n\t0x9178,\n\t0x917c,\n\t0x9180,\n\t0x918c,\n\t0x9190,\n\t0x9194,\n\t0x9198,\n\t0x919c,\n\t0x91a8,\n\t0x91ac,\n\t0x91b0,\n\t0x91b4,\n\t0x91b8,\n\t0x91c4,\n\t0x91c8,\n\t0x91cc,\n\t0x91d0,\n\t0x91d4,\n\t0x91e0,\n\t0x91e4,\n\t0x91ec,\n\t0x91f0,\n\t0x91f4,\n\t0x9200,\n\t0x9204,\n\t0x929c,\n\t0x9150,\n\t0x802c,\n};\n\nstatic void evergreen_gpu_init(struct radeon_device *rdev);\nvoid evergreen_fini(struct radeon_device *rdev);\nvoid evergreen_pcie_gen2_enable(struct radeon_device *rdev);\nvoid evergreen_program_aspm(struct radeon_device *rdev);\n\nstatic const u32 evergreen_golden_registers[] =\n{\n\t0x3f90, 0xffff0000, 0xff000000,\n\t0x9148, 0xffff0000, 0xff000000,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x9b7c, 0xffffffff, 0x00000000,\n\t0x8a14, 0xffffffff, 0x00000007,\n\t0x8b10, 0xffffffff, 0x00000000,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0xffffffff, 0x000000c2,\n\t0x88d4, 0xffffffff, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5e78, 0xffffffff, 0x001000f0,\n\t0x6104, 0x01000300, 0x00000000,\n\t0x5bc0, 0x00300000, 0x00000000,\n\t0x7030, 0xffffffff, 0x00000011,\n\t0x7c30, 0xffffffff, 0x00000011,\n\t0x10830, 0xffffffff, 0x00000011,\n\t0x11430, 0xffffffff, 0x00000011,\n\t0x12030, 0xffffffff, 0x00000011,\n\t0x12c30, 0xffffffff, 0x00000011,\n\t0xd02c, 0xffffffff, 0x08421000,\n\t0x240c, 0xffffffff, 0x00000380,\n\t0x8b24, 0xffffffff, 0x00ff0fff,\n\t0x28a4c, 0x06000000, 0x06000000,\n\t0x10c, 0x00000001, 0x00000001,\n\t0x8d00, 0xffffffff, 0x100e4848,\n\t0x8d04, 0xffffffff, 0x00164745,\n\t0x8c00, 0xffffffff, 0xe4000003,\n\t0x8c04, 0xffffffff, 0x40600060,\n\t0x8c08, 0xffffffff, 0x001c001c,\n\t0x8cf0, 0xffffffff, 0x08e00620,\n\t0x8c20, 0xffffffff, 0x00800080,\n\t0x8c24, 0xffffffff, 0x00800080,\n\t0x8c18, 0xffffffff, 0x20202078,\n\t0x8c1c, 0xffffffff, 0x00001010,\n\t0x28350, 0xffffffff, 0x00000000,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0x5c4, 0xffffffff, 0x00000001,\n\t0x9508, 0xffffffff, 0x00000002,\n\t0x913c, 0x0000000f, 0x0000000a\n};\n\nstatic const u32 evergreen_golden_registers2[] =\n{\n\t0x2f4c, 0xffffffff, 0x00000000,\n\t0x54f4, 0xffffffff, 0x00000000,\n\t0x54f0, 0xffffffff, 0x00000000,\n\t0x5498, 0xffffffff, 0x00000000,\n\t0x549c, 0xffffffff, 0x00000000,\n\t0x5494, 0xffffffff, 0x00000000,\n\t0x53cc, 0xffffffff, 0x00000000,\n\t0x53c8, 0xffffffff, 0x00000000,\n\t0x53c4, 0xffffffff, 0x00000000,\n\t0x53c0, 0xffffffff, 0x00000000,\n\t0x53bc, 0xffffffff, 0x00000000,\n\t0x53b8, 0xffffffff, 0x00000000,\n\t0x53b4, 0xffffffff, 0x00000000,\n\t0x53b0, 0xffffffff, 0x00000000\n};\n\nstatic const u32 cypress_mgcg_init[] =\n{\n\t0x802c, 0xffffffff, 0xc0000000,\n\t0x5448, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00000100,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x5644, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x8d58, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x9654, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0x9040, 0xffffffff, 0x00000100,\n\t0xa200, 0xffffffff, 0x00000100,\n\t0xa204, 0xffffffff, 0x00000100,\n\t0xa208, 0xffffffff, 0x00000100,\n\t0xa20c, 0xffffffff, 0x00000100,\n\t0x971c, 0xffffffff, 0x00000100,\n\t0x977c, 0xffffffff, 0x00000100,\n\t0x3f80, 0xffffffff, 0x00000100,\n\t0xa210, 0xffffffff, 0x00000100,\n\t0xa214, 0xffffffff, 0x00000100,\n\t0x4d8, 0xffffffff, 0x00000100,\n\t0x9784, 0xffffffff, 0x00000100,\n\t0x9698, 0xffffffff, 0x00000100,\n\t0x4d4, 0xffffffff, 0x00000200,\n\t0x30cc, 0xffffffff, 0x00000100,\n\t0xd0c0, 0xffffffff, 0xff000100,\n\t0x802c, 0xffffffff, 0x40000000,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x9160, 0xffffffff, 0x00030002,\n\t0x9178, 0xffffffff, 0x00070000,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x9180, 0xffffffff, 0x00050004,\n\t0x918c, 0xffffffff, 0x00010006,\n\t0x9190, 0xffffffff, 0x00090008,\n\t0x9194, 0xffffffff, 0x00070000,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x919c, 0xffffffff, 0x00050004,\n\t0x91a8, 0xffffffff, 0x00010006,\n\t0x91ac, 0xffffffff, 0x00090008,\n\t0x91b0, 0xffffffff, 0x00070000,\n\t0x91b4, 0xffffffff, 0x00030002,\n\t0x91b8, 0xffffffff, 0x00050004,\n\t0x91c4, 0xffffffff, 0x00010006,\n\t0x91c8, 0xffffffff, 0x00090008,\n\t0x91cc, 0xffffffff, 0x00070000,\n\t0x91d0, 0xffffffff, 0x00030002,\n\t0x91d4, 0xffffffff, 0x00050004,\n\t0x91e0, 0xffffffff, 0x00010006,\n\t0x91e4, 0xffffffff, 0x00090008,\n\t0x91e8, 0xffffffff, 0x00000000,\n\t0x91ec, 0xffffffff, 0x00070000,\n\t0x91f0, 0xffffffff, 0x00030002,\n\t0x91f4, 0xffffffff, 0x00050004,\n\t0x9200, 0xffffffff, 0x00010006,\n\t0x9204, 0xffffffff, 0x00090008,\n\t0x9208, 0xffffffff, 0x00070000,\n\t0x920c, 0xffffffff, 0x00030002,\n\t0x9210, 0xffffffff, 0x00050004,\n\t0x921c, 0xffffffff, 0x00010006,\n\t0x9220, 0xffffffff, 0x00090008,\n\t0x9224, 0xffffffff, 0x00070000,\n\t0x9228, 0xffffffff, 0x00030002,\n\t0x922c, 0xffffffff, 0x00050004,\n\t0x9238, 0xffffffff, 0x00010006,\n\t0x923c, 0xffffffff, 0x00090008,\n\t0x9240, 0xffffffff, 0x00070000,\n\t0x9244, 0xffffffff, 0x00030002,\n\t0x9248, 0xffffffff, 0x00050004,\n\t0x9254, 0xffffffff, 0x00010006,\n\t0x9258, 0xffffffff, 0x00090008,\n\t0x925c, 0xffffffff, 0x00070000,\n\t0x9260, 0xffffffff, 0x00030002,\n\t0x9264, 0xffffffff, 0x00050004,\n\t0x9270, 0xffffffff, 0x00010006,\n\t0x9274, 0xffffffff, 0x00090008,\n\t0x9278, 0xffffffff, 0x00070000,\n\t0x927c, 0xffffffff, 0x00030002,\n\t0x9280, 0xffffffff, 0x00050004,\n\t0x928c, 0xffffffff, 0x00010006,\n\t0x9290, 0xffffffff, 0x00090008,\n\t0x9294, 0xffffffff, 0x00000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x802c, 0xffffffff, 0x40010000,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x9160, 0xffffffff, 0x00030002,\n\t0x9178, 0xffffffff, 0x00070000,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x9180, 0xffffffff, 0x00050004,\n\t0x918c, 0xffffffff, 0x00010006,\n\t0x9190, 0xffffffff, 0x00090008,\n\t0x9194, 0xffffffff, 0x00070000,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x919c, 0xffffffff, 0x00050004,\n\t0x91a8, 0xffffffff, 0x00010006,\n\t0x91ac, 0xffffffff, 0x00090008,\n\t0x91b0, 0xffffffff, 0x00070000,\n\t0x91b4, 0xffffffff, 0x00030002,\n\t0x91b8, 0xffffffff, 0x00050004,\n\t0x91c4, 0xffffffff, 0x00010006,\n\t0x91c8, 0xffffffff, 0x00090008,\n\t0x91cc, 0xffffffff, 0x00070000,\n\t0x91d0, 0xffffffff, 0x00030002,\n\t0x91d4, 0xffffffff, 0x00050004,\n\t0x91e0, 0xffffffff, 0x00010006,\n\t0x91e4, 0xffffffff, 0x00090008,\n\t0x91e8, 0xffffffff, 0x00000000,\n\t0x91ec, 0xffffffff, 0x00070000,\n\t0x91f0, 0xffffffff, 0x00030002,\n\t0x91f4, 0xffffffff, 0x00050004,\n\t0x9200, 0xffffffff, 0x00010006,\n\t0x9204, 0xffffffff, 0x00090008,\n\t0x9208, 0xffffffff, 0x00070000,\n\t0x920c, 0xffffffff, 0x00030002,\n\t0x9210, 0xffffffff, 0x00050004,\n\t0x921c, 0xffffffff, 0x00010006,\n\t0x9220, 0xffffffff, 0x00090008,\n\t0x9224, 0xffffffff, 0x00070000,\n\t0x9228, 0xffffffff, 0x00030002,\n\t0x922c, 0xffffffff, 0x00050004,\n\t0x9238, 0xffffffff, 0x00010006,\n\t0x923c, 0xffffffff, 0x00090008,\n\t0x9240, 0xffffffff, 0x00070000,\n\t0x9244, 0xffffffff, 0x00030002,\n\t0x9248, 0xffffffff, 0x00050004,\n\t0x9254, 0xffffffff, 0x00010006,\n\t0x9258, 0xffffffff, 0x00090008,\n\t0x925c, 0xffffffff, 0x00070000,\n\t0x9260, 0xffffffff, 0x00030002,\n\t0x9264, 0xffffffff, 0x00050004,\n\t0x9270, 0xffffffff, 0x00010006,\n\t0x9274, 0xffffffff, 0x00090008,\n\t0x9278, 0xffffffff, 0x00070000,\n\t0x927c, 0xffffffff, 0x00030002,\n\t0x9280, 0xffffffff, 0x00050004,\n\t0x928c, 0xffffffff, 0x00010006,\n\t0x9290, 0xffffffff, 0x00090008,\n\t0x9294, 0xffffffff, 0x00000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x802c, 0xffffffff, 0xc0000000\n};\n\nstatic const u32 redwood_mgcg_init[] =\n{\n\t0x802c, 0xffffffff, 0xc0000000,\n\t0x5448, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00000100,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x5644, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x8d58, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x9654, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0x9040, 0xffffffff, 0x00000100,\n\t0xa200, 0xffffffff, 0x00000100,\n\t0xa204, 0xffffffff, 0x00000100,\n\t0xa208, 0xffffffff, 0x00000100,\n\t0xa20c, 0xffffffff, 0x00000100,\n\t0x971c, 0xffffffff, 0x00000100,\n\t0x977c, 0xffffffff, 0x00000100,\n\t0x3f80, 0xffffffff, 0x00000100,\n\t0xa210, 0xffffffff, 0x00000100,\n\t0xa214, 0xffffffff, 0x00000100,\n\t0x4d8, 0xffffffff, 0x00000100,\n\t0x9784, 0xffffffff, 0x00000100,\n\t0x9698, 0xffffffff, 0x00000100,\n\t0x4d4, 0xffffffff, 0x00000200,\n\t0x30cc, 0xffffffff, 0x00000100,\n\t0xd0c0, 0xffffffff, 0xff000100,\n\t0x802c, 0xffffffff, 0x40000000,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x9160, 0xffffffff, 0x00030002,\n\t0x9178, 0xffffffff, 0x00070000,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x9180, 0xffffffff, 0x00050004,\n\t0x918c, 0xffffffff, 0x00010006,\n\t0x9190, 0xffffffff, 0x00090008,\n\t0x9194, 0xffffffff, 0x00070000,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x919c, 0xffffffff, 0x00050004,\n\t0x91a8, 0xffffffff, 0x00010006,\n\t0x91ac, 0xffffffff, 0x00090008,\n\t0x91b0, 0xffffffff, 0x00070000,\n\t0x91b4, 0xffffffff, 0x00030002,\n\t0x91b8, 0xffffffff, 0x00050004,\n\t0x91c4, 0xffffffff, 0x00010006,\n\t0x91c8, 0xffffffff, 0x00090008,\n\t0x91cc, 0xffffffff, 0x00070000,\n\t0x91d0, 0xffffffff, 0x00030002,\n\t0x91d4, 0xffffffff, 0x00050004,\n\t0x91e0, 0xffffffff, 0x00010006,\n\t0x91e4, 0xffffffff, 0x00090008,\n\t0x91e8, 0xffffffff, 0x00000000,\n\t0x91ec, 0xffffffff, 0x00070000,\n\t0x91f0, 0xffffffff, 0x00030002,\n\t0x91f4, 0xffffffff, 0x00050004,\n\t0x9200, 0xffffffff, 0x00010006,\n\t0x9204, 0xffffffff, 0x00090008,\n\t0x9294, 0xffffffff, 0x00000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x802c, 0xffffffff, 0xc0000000\n};\n\nstatic const u32 cedar_golden_registers[] =\n{\n\t0x3f90, 0xffff0000, 0xff000000,\n\t0x9148, 0xffff0000, 0xff000000,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x9b7c, 0xffffffff, 0x00000000,\n\t0x8a14, 0xffffffff, 0x00000007,\n\t0x8b10, 0xffffffff, 0x00000000,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0xffffffff, 0x000000c2,\n\t0x88d4, 0xffffffff, 0x00000000,\n\t0x8974, 0xffffffff, 0x00000000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5e78, 0xffffffff, 0x001000f0,\n\t0x6104, 0x01000300, 0x00000000,\n\t0x5bc0, 0x00300000, 0x00000000,\n\t0x7030, 0xffffffff, 0x00000011,\n\t0x7c30, 0xffffffff, 0x00000011,\n\t0x10830, 0xffffffff, 0x00000011,\n\t0x11430, 0xffffffff, 0x00000011,\n\t0xd02c, 0xffffffff, 0x08421000,\n\t0x240c, 0xffffffff, 0x00000380,\n\t0x8b24, 0xffffffff, 0x00ff0fff,\n\t0x28a4c, 0x06000000, 0x06000000,\n\t0x10c, 0x00000001, 0x00000001,\n\t0x8d00, 0xffffffff, 0x100e4848,\n\t0x8d04, 0xffffffff, 0x00164745,\n\t0x8c00, 0xffffffff, 0xe4000003,\n\t0x8c04, 0xffffffff, 0x40600060,\n\t0x8c08, 0xffffffff, 0x001c001c,\n\t0x8cf0, 0xffffffff, 0x08e00410,\n\t0x8c20, 0xffffffff, 0x00800080,\n\t0x8c24, 0xffffffff, 0x00800080,\n\t0x8c18, 0xffffffff, 0x20202078,\n\t0x8c1c, 0xffffffff, 0x00001010,\n\t0x28350, 0xffffffff, 0x00000000,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0x5c4, 0xffffffff, 0x00000001,\n\t0x9508, 0xffffffff, 0x00000002\n};\n\nstatic const u32 cedar_mgcg_init[] =\n{\n\t0x802c, 0xffffffff, 0xc0000000,\n\t0x5448, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00000100,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x5644, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x8d58, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x9654, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0x9040, 0xffffffff, 0x00000100,\n\t0xa200, 0xffffffff, 0x00000100,\n\t0xa204, 0xffffffff, 0x00000100,\n\t0xa208, 0xffffffff, 0x00000100,\n\t0xa20c, 0xffffffff, 0x00000100,\n\t0x971c, 0xffffffff, 0x00000100,\n\t0x977c, 0xffffffff, 0x00000100,\n\t0x3f80, 0xffffffff, 0x00000100,\n\t0xa210, 0xffffffff, 0x00000100,\n\t0xa214, 0xffffffff, 0x00000100,\n\t0x4d8, 0xffffffff, 0x00000100,\n\t0x9784, 0xffffffff, 0x00000100,\n\t0x9698, 0xffffffff, 0x00000100,\n\t0x4d4, 0xffffffff, 0x00000200,\n\t0x30cc, 0xffffffff, 0x00000100,\n\t0xd0c0, 0xffffffff, 0xff000100,\n\t0x802c, 0xffffffff, 0x40000000,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x9178, 0xffffffff, 0x00050000,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x918c, 0xffffffff, 0x00010004,\n\t0x9190, 0xffffffff, 0x00070006,\n\t0x9194, 0xffffffff, 0x00050000,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x91a8, 0xffffffff, 0x00010004,\n\t0x91ac, 0xffffffff, 0x00070006,\n\t0x91e8, 0xffffffff, 0x00000000,\n\t0x9294, 0xffffffff, 0x00000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x802c, 0xffffffff, 0xc0000000\n};\n\nstatic const u32 juniper_mgcg_init[] =\n{\n\t0x802c, 0xffffffff, 0xc0000000,\n\t0x5448, 0xffffffff, 0x00000100,\n\t0x55e4, 0xffffffff, 0x00000100,\n\t0x160c, 0xffffffff, 0x00000100,\n\t0x5644, 0xffffffff, 0x00000100,\n\t0xc164, 0xffffffff, 0x00000100,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x897c, 0xffffffff, 0x06000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x9a60, 0xffffffff, 0x00000100,\n\t0x9868, 0xffffffff, 0x00000100,\n\t0x8d58, 0xffffffff, 0x00000100,\n\t0x9510, 0xffffffff, 0x00000100,\n\t0x949c, 0xffffffff, 0x00000100,\n\t0x9654, 0xffffffff, 0x00000100,\n\t0x9030, 0xffffffff, 0x00000100,\n\t0x9034, 0xffffffff, 0x00000100,\n\t0x9038, 0xffffffff, 0x00000100,\n\t0x903c, 0xffffffff, 0x00000100,\n\t0x9040, 0xffffffff, 0x00000100,\n\t0xa200, 0xffffffff, 0x00000100,\n\t0xa204, 0xffffffff, 0x00000100,\n\t0xa208, 0xffffffff, 0x00000100,\n\t0xa20c, 0xffffffff, 0x00000100,\n\t0x971c, 0xffffffff, 0x00000100,\n\t0xd0c0, 0xffffffff, 0xff000100,\n\t0x802c, 0xffffffff, 0x40000000,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x9160, 0xffffffff, 0x00030002,\n\t0x9178, 0xffffffff, 0x00070000,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x9180, 0xffffffff, 0x00050004,\n\t0x918c, 0xffffffff, 0x00010006,\n\t0x9190, 0xffffffff, 0x00090008,\n\t0x9194, 0xffffffff, 0x00070000,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x919c, 0xffffffff, 0x00050004,\n\t0x91a8, 0xffffffff, 0x00010006,\n\t0x91ac, 0xffffffff, 0x00090008,\n\t0x91b0, 0xffffffff, 0x00070000,\n\t0x91b4, 0xffffffff, 0x00030002,\n\t0x91b8, 0xffffffff, 0x00050004,\n\t0x91c4, 0xffffffff, 0x00010006,\n\t0x91c8, 0xffffffff, 0x00090008,\n\t0x91cc, 0xffffffff, 0x00070000,\n\t0x91d0, 0xffffffff, 0x00030002,\n\t0x91d4, 0xffffffff, 0x00050004,\n\t0x91e0, 0xffffffff, 0x00010006,\n\t0x91e4, 0xffffffff, 0x00090008,\n\t0x91e8, 0xffffffff, 0x00000000,\n\t0x91ec, 0xffffffff, 0x00070000,\n\t0x91f0, 0xffffffff, 0x00030002,\n\t0x91f4, 0xffffffff, 0x00050004,\n\t0x9200, 0xffffffff, 0x00010006,\n\t0x9204, 0xffffffff, 0x00090008,\n\t0x9208, 0xffffffff, 0x00070000,\n\t0x920c, 0xffffffff, 0x00030002,\n\t0x9210, 0xffffffff, 0x00050004,\n\t0x921c, 0xffffffff, 0x00010006,\n\t0x9220, 0xffffffff, 0x00090008,\n\t0x9224, 0xffffffff, 0x00070000,\n\t0x9228, 0xffffffff, 0x00030002,\n\t0x922c, 0xffffffff, 0x00050004,\n\t0x9238, 0xffffffff, 0x00010006,\n\t0x923c, 0xffffffff, 0x00090008,\n\t0x9240, 0xffffffff, 0x00070000,\n\t0x9244, 0xffffffff, 0x00030002,\n\t0x9248, 0xffffffff, 0x00050004,\n\t0x9254, 0xffffffff, 0x00010006,\n\t0x9258, 0xffffffff, 0x00090008,\n\t0x925c, 0xffffffff, 0x00070000,\n\t0x9260, 0xffffffff, 0x00030002,\n\t0x9264, 0xffffffff, 0x00050004,\n\t0x9270, 0xffffffff, 0x00010006,\n\t0x9274, 0xffffffff, 0x00090008,\n\t0x9278, 0xffffffff, 0x00070000,\n\t0x927c, 0xffffffff, 0x00030002,\n\t0x9280, 0xffffffff, 0x00050004,\n\t0x928c, 0xffffffff, 0x00010006,\n\t0x9290, 0xffffffff, 0x00090008,\n\t0x9294, 0xffffffff, 0x00000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x802c, 0xffffffff, 0xc0000000,\n\t0x977c, 0xffffffff, 0x00000100,\n\t0x3f80, 0xffffffff, 0x00000100,\n\t0xa210, 0xffffffff, 0x00000100,\n\t0xa214, 0xffffffff, 0x00000100,\n\t0x4d8, 0xffffffff, 0x00000100,\n\t0x9784, 0xffffffff, 0x00000100,\n\t0x9698, 0xffffffff, 0x00000100,\n\t0x4d4, 0xffffffff, 0x00000200,\n\t0x30cc, 0xffffffff, 0x00000100,\n\t0x802c, 0xffffffff, 0xc0000000\n};\n\nstatic const u32 supersumo_golden_registers[] =\n{\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5c4, 0xffffffff, 0x00000001,\n\t0x7030, 0xffffffff, 0x00000011,\n\t0x7c30, 0xffffffff, 0x00000011,\n\t0x6104, 0x01000300, 0x00000000,\n\t0x5bc0, 0x00300000, 0x00000000,\n\t0x8c04, 0xffffffff, 0x40600060,\n\t0x8c08, 0xffffffff, 0x001c001c,\n\t0x8c20, 0xffffffff, 0x00800080,\n\t0x8c24, 0xffffffff, 0x00800080,\n\t0x8c18, 0xffffffff, 0x20202078,\n\t0x8c1c, 0xffffffff, 0x00001010,\n\t0x918c, 0xffffffff, 0x00010006,\n\t0x91a8, 0xffffffff, 0x00010006,\n\t0x91c4, 0xffffffff, 0x00010006,\n\t0x91e0, 0xffffffff, 0x00010006,\n\t0x9200, 0xffffffff, 0x00010006,\n\t0x9150, 0xffffffff, 0x6e944040,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x9180, 0xffffffff, 0x00050004,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x919c, 0xffffffff, 0x00050004,\n\t0x91b4, 0xffffffff, 0x00030002,\n\t0x91b8, 0xffffffff, 0x00050004,\n\t0x91d0, 0xffffffff, 0x00030002,\n\t0x91d4, 0xffffffff, 0x00050004,\n\t0x91f0, 0xffffffff, 0x00030002,\n\t0x91f4, 0xffffffff, 0x00050004,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x9160, 0xffffffff, 0x00030002,\n\t0x3f90, 0xffff0000, 0xff000000,\n\t0x9178, 0xffffffff, 0x00070000,\n\t0x9194, 0xffffffff, 0x00070000,\n\t0x91b0, 0xffffffff, 0x00070000,\n\t0x91cc, 0xffffffff, 0x00070000,\n\t0x91ec, 0xffffffff, 0x00070000,\n\t0x9148, 0xffff0000, 0xff000000,\n\t0x9190, 0xffffffff, 0x00090008,\n\t0x91ac, 0xffffffff, 0x00090008,\n\t0x91c8, 0xffffffff, 0x00090008,\n\t0x91e4, 0xffffffff, 0x00090008,\n\t0x9204, 0xffffffff, 0x00090008,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x5644, 0xffffffff, 0x00000100,\n\t0x9b7c, 0xffffffff, 0x00000000,\n\t0x8030, 0xffffffff, 0x0000100a,\n\t0x8a14, 0xffffffff, 0x00000007,\n\t0x8b24, 0xffffffff, 0x00ff0fff,\n\t0x8b10, 0xffffffff, 0x00000000,\n\t0x28a4c, 0x06000000, 0x06000000,\n\t0x4d8, 0xffffffff, 0x00000100,\n\t0x913c, 0xffff000f, 0x0100000a,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0xffffffff, 0x000000c2,\n\t0x88d4, 0xffffffff, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0x5e78, 0xffffffff, 0x001000f0,\n\t0xd02c, 0xffffffff, 0x08421000,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0x8d00, 0xffffffff, 0x100e4848,\n\t0x8d04, 0xffffffff, 0x00164745,\n\t0x8c00, 0xffffffff, 0xe4000003,\n\t0x8cf0, 0x1fffffff, 0x08e00620,\n\t0x28350, 0xffffffff, 0x00000000,\n\t0x9508, 0xffffffff, 0x00000002\n};\n\nstatic const u32 sumo_golden_registers[] =\n{\n\t0x900c, 0x00ffffff, 0x0017071f,\n\t0x8c18, 0xffffffff, 0x10101060,\n\t0x8c1c, 0xffffffff, 0x00001010,\n\t0x8c30, 0x0000000f, 0x00000005,\n\t0x9688, 0x0000000f, 0x00000007\n};\n\nstatic const u32 wrestler_golden_registers[] =\n{\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5c4, 0xffffffff, 0x00000001,\n\t0x7030, 0xffffffff, 0x00000011,\n\t0x7c30, 0xffffffff, 0x00000011,\n\t0x6104, 0x01000300, 0x00000000,\n\t0x5bc0, 0x00300000, 0x00000000,\n\t0x918c, 0xffffffff, 0x00010006,\n\t0x91a8, 0xffffffff, 0x00010006,\n\t0x9150, 0xffffffff, 0x6e944040,\n\t0x917c, 0xffffffff, 0x00030002,\n\t0x9198, 0xffffffff, 0x00030002,\n\t0x915c, 0xffffffff, 0x00010000,\n\t0x3f90, 0xffff0000, 0xff000000,\n\t0x9178, 0xffffffff, 0x00070000,\n\t0x9194, 0xffffffff, 0x00070000,\n\t0x9148, 0xffff0000, 0xff000000,\n\t0x9190, 0xffffffff, 0x00090008,\n\t0x91ac, 0xffffffff, 0x00090008,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0x929c, 0xffffffff, 0x00000001,\n\t0x8a18, 0xffffffff, 0x00000100,\n\t0x8b28, 0xffffffff, 0x00000100,\n\t0x9144, 0xffffffff, 0x00000100,\n\t0x9b7c, 0xffffffff, 0x00000000,\n\t0x8030, 0xffffffff, 0x0000100a,\n\t0x8a14, 0xffffffff, 0x00000001,\n\t0x8b24, 0xffffffff, 0x00ff0fff,\n\t0x8b10, 0xffffffff, 0x00000000,\n\t0x28a4c, 0x06000000, 0x06000000,\n\t0x4d8, 0xffffffff, 0x00000100,\n\t0x913c, 0xffff000f, 0x0100000a,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0xffffffff, 0x000000c2,\n\t0x88d4, 0xffffffff, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0x5e78, 0xffffffff, 0x001000f0,\n\t0xd02c, 0xffffffff, 0x08421000,\n\t0xa008, 0xffffffff, 0x00010000,\n\t0x8d00, 0xffffffff, 0x100e4848,\n\t0x8d04, 0xffffffff, 0x00164745,\n\t0x8c00, 0xffffffff, 0xe4000003,\n\t0x8cf0, 0x1fffffff, 0x08e00410,\n\t0x28350, 0xffffffff, 0x00000000,\n\t0x9508, 0xffffffff, 0x00000002,\n\t0x900c, 0xffffffff, 0x0017071f,\n\t0x8c18, 0xffffffff, 0x10101060,\n\t0x8c1c, 0xffffffff, 0x00001010\n};\n\nstatic const u32 barts_golden_registers[] =\n{\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5e78, 0x8f311ff1, 0x001000f0,\n\t0x3f90, 0xffff0000, 0xff000000,\n\t0x9148, 0xffff0000, 0xff000000,\n\t0x3f94, 0xffff0000, 0xff000000,\n\t0x914c, 0xffff0000, 0xff000000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0xbd4, 0x70073777, 0x00010001,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd0b8, 0x03773777, 0x02011003,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x98f8, 0x33773777, 0x02011003,\n\t0x98fc, 0xffffffff, 0x76543210,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2f48, 0x00000007, 0x02011003,\n\t0x6b28, 0x00000010, 0x00000012,\n\t0x7728, 0x00000010, 0x00000012,\n\t0x10328, 0x00000010, 0x00000012,\n\t0x10f28, 0x00000010, 0x00000012,\n\t0x11b28, 0x00000010, 0x00000012,\n\t0x12728, 0x00000010, 0x00000012,\n\t0x240c, 0x000007ff, 0x00000380,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x10c, 0x00000001, 0x00010003,\n\t0xa02c, 0xffffffff, 0x0000009b,\n\t0x913c, 0x0000000f, 0x0100000a,\n\t0x8d00, 0xffff7f7f, 0x100e4848,\n\t0x8d04, 0x00ffffff, 0x00164745,\n\t0x8c00, 0xfffc0003, 0xe4000003,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x8c08, 0x00ff00ff, 0x001c001c,\n\t0x8cf0, 0x1fff1fff, 0x08e00620,\n\t0x8c20, 0x0fff0fff, 0x00800080,\n\t0x8c24, 0x0fff0fff, 0x00800080,\n\t0x8c18, 0xffffffff, 0x20202078,\n\t0x8c1c, 0x0000ffff, 0x00001010,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x9508, 0x3700001f, 0x00000002,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0x001f3ae3, 0x000000c2,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000\n};\n\nstatic const u32 turks_golden_registers[] =\n{\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5e78, 0x8f311ff1, 0x001000f0,\n\t0x8c8, 0x00003000, 0x00001070,\n\t0x8cc, 0x000fffff, 0x00040035,\n\t0x3f90, 0xffff0000, 0xfff00000,\n\t0x9148, 0xffff0000, 0xfff00000,\n\t0x3f94, 0xffff0000, 0xfff00000,\n\t0x914c, 0xffff0000, 0xfff00000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0xbd4, 0x00073007, 0x00010002,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd0b8, 0x03773777, 0x02010002,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x98f8, 0x33773777, 0x00010002,\n\t0x98fc, 0xffffffff, 0x33221100,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2f48, 0x33773777, 0x00010002,\n\t0x6b28, 0x00000010, 0x00000012,\n\t0x7728, 0x00000010, 0x00000012,\n\t0x10328, 0x00000010, 0x00000012,\n\t0x10f28, 0x00000010, 0x00000012,\n\t0x11b28, 0x00000010, 0x00000012,\n\t0x12728, 0x00000010, 0x00000012,\n\t0x240c, 0x000007ff, 0x00000380,\n\t0x8a14, 0xf000001f, 0x00000007,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x10c, 0x00000001, 0x00010003,\n\t0xa02c, 0xffffffff, 0x0000009b,\n\t0x913c, 0x0000000f, 0x0100000a,\n\t0x8d00, 0xffff7f7f, 0x100e4848,\n\t0x8d04, 0x00ffffff, 0x00164745,\n\t0x8c00, 0xfffc0003, 0xe4000003,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x8c08, 0x00ff00ff, 0x001c001c,\n\t0x8cf0, 0x1fff1fff, 0x08e00410,\n\t0x8c20, 0x0fff0fff, 0x00800080,\n\t0x8c24, 0x0fff0fff, 0x00800080,\n\t0x8c18, 0xffffffff, 0x20202078,\n\t0x8c1c, 0x0000ffff, 0x00001010,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x9508, 0x3700001f, 0x00000002,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0x001f3ae3, 0x000000c2,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000\n};\n\nstatic const u32 caicos_golden_registers[] =\n{\n\t0x5eb4, 0xffffffff, 0x00000002,\n\t0x5e78, 0x8f311ff1, 0x001000f0,\n\t0x8c8, 0x00003420, 0x00001450,\n\t0x8cc, 0x000fffff, 0x00040035,\n\t0x3f90, 0xffff0000, 0xfffc0000,\n\t0x9148, 0xffff0000, 0xfffc0000,\n\t0x3f94, 0xffff0000, 0xfffc0000,\n\t0x914c, 0xffff0000, 0xfffc0000,\n\t0xc78, 0x00000080, 0x00000080,\n\t0xbd4, 0x00073007, 0x00010001,\n\t0xd02c, 0xbfffff1f, 0x08421000,\n\t0xd0b8, 0x03773777, 0x02010001,\n\t0x5bc0, 0x00200000, 0x50100000,\n\t0x98f8, 0x33773777, 0x02010001,\n\t0x98fc, 0xffffffff, 0x33221100,\n\t0x7030, 0x31000311, 0x00000011,\n\t0x2f48, 0x33773777, 0x02010001,\n\t0x6b28, 0x00000010, 0x00000012,\n\t0x7728, 0x00000010, 0x00000012,\n\t0x10328, 0x00000010, 0x00000012,\n\t0x10f28, 0x00000010, 0x00000012,\n\t0x11b28, 0x00000010, 0x00000012,\n\t0x12728, 0x00000010, 0x00000012,\n\t0x240c, 0x000007ff, 0x00000380,\n\t0x8a14, 0xf000001f, 0x00000001,\n\t0x8b24, 0x3fff3fff, 0x00ff0fff,\n\t0x8b10, 0x0000ff0f, 0x00000000,\n\t0x28a4c, 0x07ffffff, 0x06000000,\n\t0x10c, 0x00000001, 0x00010003,\n\t0xa02c, 0xffffffff, 0x0000009b,\n\t0x913c, 0x0000000f, 0x0100000a,\n\t0x8d00, 0xffff7f7f, 0x100e4848,\n\t0x8d04, 0x00ffffff, 0x00164745,\n\t0x8c00, 0xfffc0003, 0xe4000003,\n\t0x8c04, 0xf8ff00ff, 0x40600060,\n\t0x8c08, 0x00ff00ff, 0x001c001c,\n\t0x8cf0, 0x1fff1fff, 0x08e00410,\n\t0x8c20, 0x0fff0fff, 0x00800080,\n\t0x8c24, 0x0fff0fff, 0x00800080,\n\t0x8c18, 0xffffffff, 0x20202078,\n\t0x8c1c, 0x0000ffff, 0x00001010,\n\t0x28350, 0x00000f01, 0x00000000,\n\t0x9508, 0x3700001f, 0x00000002,\n\t0x960c, 0xffffffff, 0x54763210,\n\t0x88c4, 0x001f3ae3, 0x000000c2,\n\t0x88d4, 0x0000001f, 0x00000010,\n\t0x8974, 0xffffffff, 0x00000000\n};\n\nstatic void evergreen_init_golden_registers(struct radeon_device *rdev)\n{\n\tswitch (rdev->family) {\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers2));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t cypress_mgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(cypress_mgcg_init));\n\t\tbreak;\n\tcase CHIP_JUNIPER:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers2));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t juniper_mgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(juniper_mgcg_init));\n\t\tbreak;\n\tcase CHIP_REDWOOD:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers2));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t redwood_mgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(redwood_mgcg_init));\n\t\tbreak;\n\tcase CHIP_CEDAR:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t cedar_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(cedar_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t evergreen_golden_registers2,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(evergreen_golden_registers2));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t cedar_mgcg_init,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(cedar_mgcg_init));\n\t\tbreak;\n\tcase CHIP_PALM:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t wrestler_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(wrestler_golden_registers));\n\t\tbreak;\n\tcase CHIP_SUMO:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t supersumo_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(supersumo_golden_registers));\n\t\tbreak;\n\tcase CHIP_SUMO2:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t supersumo_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(supersumo_golden_registers));\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t sumo_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(sumo_golden_registers));\n\t\tbreak;\n\tcase CHIP_BARTS:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t barts_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(barts_golden_registers));\n\t\tbreak;\n\tcase CHIP_TURKS:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t turks_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(turks_golden_registers));\n\t\tbreak;\n\tcase CHIP_CAICOS:\n\t\tradeon_program_register_sequence(rdev,\n\t\t\t\t\t\t caicos_golden_registers,\n\t\t\t\t\t\t (const u32)ARRAY_SIZE(caicos_golden_registers));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nint evergreen_get_allowed_info_register(struct radeon_device *rdev,\n\t\t\t\t\tu32 reg, u32 *val)\n{\n\tswitch (reg) {\n\tcase GRBM_STATUS:\n\tcase GRBM_STATUS_SE0:\n\tcase GRBM_STATUS_SE1:\n\tcase SRBM_STATUS:\n\tcase SRBM_STATUS2:\n\tcase DMA_STATUS_REG:\n\tcase UVD_STATUS:\n\t\t*val = RREG32(reg);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid evergreen_tiling_fields(unsigned tiling_flags, unsigned *bankw,\n\t\t\t     unsigned *bankh, unsigned *mtaspect,\n\t\t\t     unsigned *tile_split)\n{\n\t*bankw = (tiling_flags >> RADEON_TILING_EG_BANKW_SHIFT) & RADEON_TILING_EG_BANKW_MASK;\n\t*bankh = (tiling_flags >> RADEON_TILING_EG_BANKH_SHIFT) & RADEON_TILING_EG_BANKH_MASK;\n\t*mtaspect = (tiling_flags >> RADEON_TILING_EG_MACRO_TILE_ASPECT_SHIFT) & RADEON_TILING_EG_MACRO_TILE_ASPECT_MASK;\n\t*tile_split = (tiling_flags >> RADEON_TILING_EG_TILE_SPLIT_SHIFT) & RADEON_TILING_EG_TILE_SPLIT_MASK;\n\tswitch (*bankw) {\n\tdefault:\n\tcase 1: *bankw = EVERGREEN_ADDR_SURF_BANK_WIDTH_1; break;\n\tcase 2: *bankw = EVERGREEN_ADDR_SURF_BANK_WIDTH_2; break;\n\tcase 4: *bankw = EVERGREEN_ADDR_SURF_BANK_WIDTH_4; break;\n\tcase 8: *bankw = EVERGREEN_ADDR_SURF_BANK_WIDTH_8; break;\n\t}\n\tswitch (*bankh) {\n\tdefault:\n\tcase 1: *bankh = EVERGREEN_ADDR_SURF_BANK_HEIGHT_1; break;\n\tcase 2: *bankh = EVERGREEN_ADDR_SURF_BANK_HEIGHT_2; break;\n\tcase 4: *bankh = EVERGREEN_ADDR_SURF_BANK_HEIGHT_4; break;\n\tcase 8: *bankh = EVERGREEN_ADDR_SURF_BANK_HEIGHT_8; break;\n\t}\n\tswitch (*mtaspect) {\n\tdefault:\n\tcase 1: *mtaspect = EVERGREEN_ADDR_SURF_MACRO_TILE_ASPECT_1; break;\n\tcase 2: *mtaspect = EVERGREEN_ADDR_SURF_MACRO_TILE_ASPECT_2; break;\n\tcase 4: *mtaspect = EVERGREEN_ADDR_SURF_MACRO_TILE_ASPECT_4; break;\n\tcase 8: *mtaspect = EVERGREEN_ADDR_SURF_MACRO_TILE_ASPECT_8; break;\n\t}\n}\n\nstatic int sumo_set_uvd_clock(struct radeon_device *rdev, u32 clock,\n\t\t\t      u32 cntl_reg, u32 status_reg)\n{\n\tint r, i;\n\tstruct atom_clock_dividers dividers;\n\n\tr = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t   clock, false, &dividers);\n\tif (r)\n\t\treturn r;\n\n\tWREG32_P(cntl_reg, dividers.post_div, ~(DCLK_DIR_CNTL_EN|DCLK_DIVIDER_MASK));\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (RREG32(status_reg) & DCLK_STATUS)\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (i == 100)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint sumo_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk)\n{\n\tint r = 0;\n\tu32 cg_scratch = RREG32(CG_SCRATCH1);\n\n\tr = sumo_set_uvd_clock(rdev, vclk, CG_VCLK_CNTL, CG_VCLK_STATUS);\n\tif (r)\n\t\tgoto done;\n\tcg_scratch &= 0xffff0000;\n\tcg_scratch |= vclk / 100;  \n\n\tr = sumo_set_uvd_clock(rdev, dclk, CG_DCLK_CNTL, CG_DCLK_STATUS);\n\tif (r)\n\t\tgoto done;\n\tcg_scratch &= 0x0000ffff;\n\tcg_scratch |= (dclk / 100) << 16;  \n\ndone:\n\tWREG32(CG_SCRATCH1, cg_scratch);\n\n\treturn r;\n}\n\nint evergreen_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk)\n{\n\t \n\tunsigned fb_div = 0, vclk_div = 0, dclk_div = 0;\n\tint r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\tVCLK_SRC_SEL(1) | DCLK_SRC_SEL(1),\n\t\t~(VCLK_SRC_SEL_MASK | DCLK_SRC_SEL_MASK));\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_BYPASS_EN_MASK, ~UPLL_BYPASS_EN_MASK);\n\n\tif (!vclk || !dclk) {\n\t\t \n\t\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_SLEEP_MASK, ~UPLL_SLEEP_MASK);\n\t\treturn 0;\n\t}\n\n\tr = radeon_uvd_calc_upll_dividers(rdev, vclk, dclk, 125000, 250000,\n\t\t\t\t\t  16384, 0x03FFFFFF, 0, 128, 5,\n\t\t\t\t\t  &fb_div, &vclk_div, &dclk_div);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_VCO_MODE_MASK, ~UPLL_VCO_MODE_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_SLEEP_MASK, ~UPLL_SLEEP_MASK);\n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_SLEEP_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_RESET_MASK);\n\n\tmdelay(1);\n\n\tr = radeon_uvd_send_upll_ctlreq(rdev, CG_UPLL_FUNC_CNTL);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_RESET_MASK, ~UPLL_RESET_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_SPREAD_SPECTRUM, 0, ~SSEN_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_3, UPLL_FB_DIV(fb_div), ~UPLL_FB_DIV_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_REF_DIV_MASK);\n\n\tif (fb_div < 307200)\n\t\tWREG32_P(CG_UPLL_FUNC_CNTL_4, 0, ~UPLL_SPARE_ISPARE9);\n\telse\n\t\tWREG32_P(CG_UPLL_FUNC_CNTL_4, UPLL_SPARE_ISPARE9, ~UPLL_SPARE_ISPARE9);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\tUPLL_PDIV_A(vclk_div) | UPLL_PDIV_B(dclk_div),\n\t\t~(UPLL_PDIV_A_MASK | UPLL_PDIV_B_MASK));\n\n\t \n\tmdelay(15);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_RESET_MASK);\n\n\tmdelay(15);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_BYPASS_EN_MASK);\n\n\tr = radeon_uvd_send_upll_ctlreq(rdev, CG_UPLL_FUNC_CNTL);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\tVCLK_SRC_SEL(2) | DCLK_SRC_SEL(2),\n\t\t~(VCLK_SRC_SEL_MASK | DCLK_SRC_SEL_MASK));\n\n\tmdelay(100);\n\n\treturn 0;\n}\n\nvoid evergreen_fix_pci_max_read_req_size(struct radeon_device *rdev)\n{\n\tint readrq;\n\tu16 v;\n\n\treadrq = pcie_get_readrq(rdev->pdev);\n\tv = ffs(readrq) - 8;\n\t \n\tif ((v == 0) || (v == 6) || (v == 7))\n\t\tpcie_set_readrq(rdev->pdev, 512);\n}\n\nvoid dce4_program_fmt(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tint bpc = 0;\n\tu32 tmp = 0;\n\tenum radeon_connector_dither dither = RADEON_FMT_DITHER_DISABLE;\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tbpc = radeon_get_monitor_bpc(connector);\n\t\tdither = radeon_connector->dither;\n\t}\n\n\t \n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD_SUPPORT)\n\t\treturn;\n\n\t \n\tif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1) ||\n\t    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2))\n\t\treturn;\n\n\tif (bpc == 0)\n\t\treturn;\n\n\tswitch (bpc) {\n\tcase 6:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (FMT_FRAME_RANDOM_ENABLE | FMT_HIGHPASS_RANDOM_ENABLE |\n\t\t\t\tFMT_SPATIAL_DITHER_EN);\n\t\telse\n\t\t\ttmp |= FMT_TRUNCATE_EN;\n\t\tbreak;\n\tcase 8:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (FMT_FRAME_RANDOM_ENABLE | FMT_HIGHPASS_RANDOM_ENABLE |\n\t\t\t\tFMT_RGB_RANDOM_ENABLE |\n\t\t\t\tFMT_SPATIAL_DITHER_EN | FMT_SPATIAL_DITHER_DEPTH);\n\t\telse\n\t\t\ttmp |= (FMT_TRUNCATE_EN | FMT_TRUNCATE_DEPTH);\n\t\tbreak;\n\tcase 10:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tWREG32(FMT_BIT_DEPTH_CONTROL + radeon_crtc->crtc_offset, tmp);\n}\n\nstatic bool dce4_is_in_vblank(struct radeon_device *rdev, int crtc)\n{\n\tif (RREG32(EVERGREEN_CRTC_STATUS + crtc_offsets[crtc]) & EVERGREEN_CRTC_V_BLANK)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool dce4_is_counter_moving(struct radeon_device *rdev, int crtc)\n{\n\tu32 pos1, pos2;\n\n\tpos1 = RREG32(EVERGREEN_CRTC_STATUS_POSITION + crtc_offsets[crtc]);\n\tpos2 = RREG32(EVERGREEN_CRTC_STATUS_POSITION + crtc_offsets[crtc]);\n\n\tif (pos1 != pos2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nvoid dce4_wait_for_vblank(struct radeon_device *rdev, int crtc)\n{\n\tunsigned i = 0;\n\n\tif (crtc >= rdev->num_crtc)\n\t\treturn;\n\n\tif (!(RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[crtc]) & EVERGREEN_CRTC_MASTER_EN))\n\t\treturn;\n\n\t \n\twhile (dce4_is_in_vblank(rdev, crtc)) {\n\t\tif (i++ % 100 == 0) {\n\t\t\tif (!dce4_is_counter_moving(rdev, crtc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (!dce4_is_in_vblank(rdev, crtc)) {\n\t\tif (i++ % 100 == 0) {\n\t\t\tif (!dce4_is_counter_moving(rdev, crtc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid evergreen_page_flip(struct radeon_device *rdev, int crtc_id, u64 crtc_base,\n\t\t\t bool async)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\tstruct drm_framebuffer *fb = radeon_crtc->base.primary->fb;\n\n\t \n\tWREG32(EVERGREEN_GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset,\n\t       async ? EVERGREEN_GRPH_SURFACE_UPDATE_H_RETRACE_EN : 0);\n\t \n\tWREG32(EVERGREEN_GRPH_PITCH + radeon_crtc->crtc_offset,\n\t       fb->pitches[0] / fb->format->cpp[0]);\n\t \n\tWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,\n\t       upper_32_bits(crtc_base));\n\tWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\n\t       (u32)crtc_base);\n\t \n\tRREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset);\n}\n\n \nbool evergreen_page_flip_pending(struct radeon_device *rdev, int crtc_id)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\n\t \n\treturn !!(RREG32(EVERGREEN_GRPH_UPDATE + radeon_crtc->crtc_offset) &\n\t\tEVERGREEN_GRPH_SURFACE_UPDATE_PENDING);\n}\n\n \nint evergreen_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp, toffset;\n\tint actual_temp = 0;\n\n\tif (rdev->family == CHIP_JUNIPER) {\n\t\ttoffset = (RREG32(CG_THERMAL_CTRL) & TOFFSET_MASK) >>\n\t\t\tTOFFSET_SHIFT;\n\t\ttemp = (RREG32(CG_TS0_STATUS) & TS0_ADC_DOUT_MASK) >>\n\t\t\tTS0_ADC_DOUT_SHIFT;\n\n\t\tif (toffset & 0x100)\n\t\t\tactual_temp = temp / 2 - (0x200 - toffset);\n\t\telse\n\t\t\tactual_temp = temp / 2 + toffset;\n\n\t\tactual_temp = actual_temp * 1000;\n\n\t} else {\n\t\ttemp = (RREG32(CG_MULT_THERMAL_STATUS) & ASIC_T_MASK) >>\n\t\t\tASIC_T_SHIFT;\n\n\t\tif (temp & 0x400)\n\t\t\tactual_temp = -256;\n\t\telse if (temp & 0x200)\n\t\t\tactual_temp = 255;\n\t\telse if (temp & 0x100) {\n\t\t\tactual_temp = temp & 0x1ff;\n\t\t\tactual_temp |= ~0x1ff;\n\t\t} else\n\t\t\tactual_temp = temp & 0xff;\n\n\t\tactual_temp = (actual_temp * 1000) / 2;\n\t}\n\n\treturn actual_temp;\n}\n\nint sumo_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp = RREG32(CG_THERMAL_STATUS) & 0xff;\n\tint actual_temp = temp - 49;\n\n\treturn actual_temp * 1000;\n}\n\n \nvoid sumo_pm_init_profile(struct radeon_device *rdev)\n{\n\tint idx;\n\n\t \n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 0;\n\n\t \n\tif (rdev->flags & RADEON_IS_MOBILITY)\n\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_BATTERY, 0);\n\telse\n\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 0);\n\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 0;\n\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 0;\n\n\t \n\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 0);\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx =\n\t\trdev->pm.power_state[idx].num_clock_modes - 1;\n\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx =\n\t\trdev->pm.power_state[idx].num_clock_modes - 1;\n}\n\n \nvoid btc_pm_init_profile(struct radeon_device *rdev)\n{\n\tint idx;\n\n\t \n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 2;\n\t \n\tif (rdev->flags & RADEON_IS_MOBILITY)\n\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_BATTERY, 0);\n\telse\n\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 0);\n\t \n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 1;\n\t \n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 2;\n\t \n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 1;\n\t \n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = idx;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 2;\n}\n\n \nvoid evergreen_pm_misc(struct radeon_device *rdev)\n{\n\tint req_ps_idx = rdev->pm.requested_power_state_index;\n\tint req_cm_idx = rdev->pm.requested_clock_mode_index;\n\tstruct radeon_power_state *ps = &rdev->pm.power_state[req_ps_idx];\n\tstruct radeon_voltage *voltage = &ps->clock_info[req_cm_idx].voltage;\n\n\tif (voltage->type == VOLTAGE_SW) {\n\t\t \n\t\tif ((voltage->voltage & 0xff00) == 0xff00)\n\t\t\treturn;\n\t\tif (voltage->voltage && (voltage->voltage != rdev->pm.current_vddc)) {\n\t\t\tradeon_atom_set_voltage(rdev, voltage->voltage, SET_VOLTAGE_TYPE_ASIC_VDDC);\n\t\t\trdev->pm.current_vddc = voltage->voltage;\n\t\t\tDRM_DEBUG(\"Setting: vddc: %d\\n\", voltage->voltage);\n\t\t}\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_PROFILE) &&\n\t\t    (rdev->family >= CHIP_BARTS) &&\n\t\t    rdev->pm.active_crtc_count &&\n\t\t    ((rdev->pm.profile_index == PM_PROFILE_MID_MH_IDX) ||\n\t\t     (rdev->pm.profile_index == PM_PROFILE_LOW_MH_IDX)))\n\t\t\tvoltage = &rdev->pm.power_state[req_ps_idx].\n\t\t\t\tclock_info[rdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx].voltage;\n\n\t\t \n\t\tif ((voltage->vddci & 0xff00) == 0xff00)\n\t\t\treturn;\n\t\tif (voltage->vddci && (voltage->vddci != rdev->pm.current_vddci)) {\n\t\t\tradeon_atom_set_voltage(rdev, voltage->vddci, SET_VOLTAGE_TYPE_ASIC_VDDCI);\n\t\t\trdev->pm.current_vddci = voltage->vddci;\n\t\t\tDRM_DEBUG(\"Setting: vddci: %d\\n\", voltage->vddci);\n\t\t}\n\t}\n}\n\n \nvoid evergreen_pm_prepare(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tu32 tmp;\n\n\t \n\tlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\n\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\tif (radeon_crtc->enabled) {\n\t\t\ttmp = RREG32(EVERGREEN_CRTC_CONTROL + radeon_crtc->crtc_offset);\n\t\t\ttmp |= EVERGREEN_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\tWREG32(EVERGREEN_CRTC_CONTROL + radeon_crtc->crtc_offset, tmp);\n\t\t}\n\t}\n}\n\n \nvoid evergreen_pm_finish(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tu32 tmp;\n\n\t \n\tlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\n\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\tif (radeon_crtc->enabled) {\n\t\t\ttmp = RREG32(EVERGREEN_CRTC_CONTROL + radeon_crtc->crtc_offset);\n\t\t\ttmp &= ~EVERGREEN_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\tWREG32(EVERGREEN_CRTC_CONTROL + radeon_crtc->crtc_offset, tmp);\n\t\t}\n\t}\n}\n\n \nbool evergreen_hpd_sense(struct radeon_device *rdev, enum radeon_hpd_id hpd)\n{\n\tif (hpd == RADEON_HPD_NONE)\n\t\treturn false;\n\n\treturn !!(RREG32(DC_HPDx_INT_STATUS_REG(hpd)) & DC_HPDx_SENSE);\n}\n\n \nvoid evergreen_hpd_set_polarity(struct radeon_device *rdev,\n\t\t\t\tenum radeon_hpd_id hpd)\n{\n\tbool connected = evergreen_hpd_sense(rdev, hpd);\n\n\tif (hpd == RADEON_HPD_NONE)\n\t\treturn;\n\n\tif (connected)\n\t\tWREG32_AND(DC_HPDx_INT_CONTROL(hpd), ~DC_HPDx_INT_POLARITY);\n\telse\n\t\tWREG32_OR(DC_HPDx_INT_CONTROL(hpd), DC_HPDx_INT_POLARITY);\n}\n\n \nvoid evergreen_hpd_init(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned enabled = 0;\n\tu32 tmp = DC_HPDx_CONNECTION_TIMER(0x9c4) |\n\t\tDC_HPDx_RX_INT_TIMER(0xfa) | DC_HPDx_EN;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tenum radeon_hpd_id hpd =\n\t\t\tto_radeon_connector(connector)->hpd.hpd;\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP ||\n\t\t    connector->connector_type == DRM_MODE_CONNECTOR_LVDS) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hpd == RADEON_HPD_NONE)\n\t\t\tcontinue;\n\n\t\tWREG32(DC_HPDx_CONTROL(hpd), tmp);\n\t\tenabled |= 1 << hpd;\n\n\t\tradeon_hpd_set_polarity(rdev, hpd);\n\t}\n\tradeon_irq_kms_enable_hpd(rdev, enabled);\n}\n\n \nvoid evergreen_hpd_fini(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned disabled = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tenum radeon_hpd_id hpd =\n\t\t\tto_radeon_connector(connector)->hpd.hpd;\n\n\t\tif (hpd == RADEON_HPD_NONE)\n\t\t\tcontinue;\n\n\t\tWREG32(DC_HPDx_CONTROL(hpd), 0);\n\t\tdisabled |= 1 << hpd;\n\t}\n\tradeon_irq_kms_disable_hpd(rdev, disabled);\n}\n\n \n\nstatic u32 evergreen_line_buffer_adjust(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_crtc *radeon_crtc,\n\t\t\t\t\tstruct drm_display_mode *mode,\n\t\t\t\t\tstruct drm_display_mode *other_mode)\n{\n\tu32 tmp, buffer_alloc, i;\n\tu32 pipe_offset = radeon_crtc->crtc_id * 0x20;\n\t \n\t \n\tif (radeon_crtc->base.enabled && mode) {\n\t\tif (other_mode) {\n\t\t\ttmp = 0;  \n\t\t\tbuffer_alloc = 1;\n\t\t} else {\n\t\t\ttmp = 2;  \n\t\t\tbuffer_alloc = 2;\n\t\t}\n\t} else {\n\t\ttmp = 0;\n\t\tbuffer_alloc = 0;\n\t}\n\n\t \n\tif (radeon_crtc->crtc_id % 2)\n\t\ttmp += 4;\n\tWREG32(DC_LB_MEMORY_SPLIT + radeon_crtc->crtc_offset, tmp);\n\n\tif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE5(rdev)) {\n\t\tWREG32(PIPE0_DMIF_BUFFER_CONTROL + pipe_offset,\n\t\t       DMIF_BUFFERS_ALLOCATED(buffer_alloc));\n\t\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t\tif (RREG32(PIPE0_DMIF_BUFFER_CONTROL + pipe_offset) &\n\t\t\t    DMIF_BUFFERS_ALLOCATED_COMPLETED)\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\tif (radeon_crtc->base.enabled && mode) {\n\t\tswitch (tmp) {\n\t\tcase 0:\n\t\tcase 4:\n\t\tdefault:\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\treturn 4096 * 2;\n\t\t\telse\n\t\t\t\treturn 3840 * 2;\n\t\tcase 1:\n\t\tcase 5:\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\treturn 6144 * 2;\n\t\t\telse\n\t\t\t\treturn 5760 * 2;\n\t\tcase 2:\n\t\tcase 6:\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\treturn 8192 * 2;\n\t\t\telse\n\t\t\t\treturn 7680 * 2;\n\t\tcase 3:\n\t\tcase 7:\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\treturn 2048 * 2;\n\t\t\telse\n\t\t\t\treturn 1920 * 2;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nu32 evergreen_get_number_of_dram_channels(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(MC_SHARED_CHMAP);\n\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\treturn 1;\n\tcase 1:\n\t\treturn 2;\n\tcase 2:\n\t\treturn 4;\n\tcase 3:\n\t\treturn 8;\n\t}\n}\n\nstruct evergreen_wm_params {\n\tu32 dram_channels;  \n\tu32 yclk;           \n\tu32 sclk;           \n\tu32 disp_clk;       \n\tu32 src_width;      \n\tu32 active_time;    \n\tu32 blank_time;     \n\tbool interlaced;     \n\tfixed20_12 vsc;     \n\tu32 num_heads;      \n\tu32 bytes_per_pixel;  \n\tu32 lb_size;        \n\tu32 vtaps;          \n};\n\nstatic u32 evergreen_dram_bandwidth(struct evergreen_wm_params *wm)\n{\n\t \n\tfixed20_12 dram_efficiency;  \n\tfixed20_12 yclk, dram_channels, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tyclk.full = dfixed_const(wm->yclk);\n\tyclk.full = dfixed_div(yclk, a);\n\tdram_channels.full = dfixed_const(wm->dram_channels * 4);\n\ta.full = dfixed_const(10);\n\tdram_efficiency.full = dfixed_const(7);\n\tdram_efficiency.full = dfixed_div(dram_efficiency, a);\n\tbandwidth.full = dfixed_mul(dram_channels, yclk);\n\tbandwidth.full = dfixed_mul(bandwidth, dram_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 evergreen_dram_bandwidth_for_display(struct evergreen_wm_params *wm)\n{\n\t \n\tfixed20_12 disp_dram_allocation;  \n\tfixed20_12 yclk, dram_channels, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tyclk.full = dfixed_const(wm->yclk);\n\tyclk.full = dfixed_div(yclk, a);\n\tdram_channels.full = dfixed_const(wm->dram_channels * 4);\n\ta.full = dfixed_const(10);\n\tdisp_dram_allocation.full = dfixed_const(3);  \n\tdisp_dram_allocation.full = dfixed_div(disp_dram_allocation, a);\n\tbandwidth.full = dfixed_mul(dram_channels, yclk);\n\tbandwidth.full = dfixed_mul(bandwidth, disp_dram_allocation);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 evergreen_data_return_bandwidth(struct evergreen_wm_params *wm)\n{\n\t \n\tfixed20_12 return_efficiency;  \n\tfixed20_12 sclk, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tsclk.full = dfixed_const(wm->sclk);\n\tsclk.full = dfixed_div(sclk, a);\n\ta.full = dfixed_const(10);\n\treturn_efficiency.full = dfixed_const(8);\n\treturn_efficiency.full = dfixed_div(return_efficiency, a);\n\ta.full = dfixed_const(32);\n\tbandwidth.full = dfixed_mul(a, sclk);\n\tbandwidth.full = dfixed_mul(bandwidth, return_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 evergreen_dmif_request_bandwidth(struct evergreen_wm_params *wm)\n{\n\t \n\tfixed20_12 disp_clk_request_efficiency;  \n\tfixed20_12 disp_clk, bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tdisp_clk.full = dfixed_const(wm->disp_clk);\n\tdisp_clk.full = dfixed_div(disp_clk, a);\n\ta.full = dfixed_const(10);\n\tdisp_clk_request_efficiency.full = dfixed_const(8);\n\tdisp_clk_request_efficiency.full = dfixed_div(disp_clk_request_efficiency, a);\n\ta.full = dfixed_const(32);\n\tbandwidth.full = dfixed_mul(a, disp_clk);\n\tbandwidth.full = dfixed_mul(bandwidth, disp_clk_request_efficiency);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 evergreen_available_bandwidth(struct evergreen_wm_params *wm)\n{\n\t \n\tu32 dram_bandwidth = evergreen_dram_bandwidth(wm);\n\tu32 data_return_bandwidth = evergreen_data_return_bandwidth(wm);\n\tu32 dmif_req_bandwidth = evergreen_dmif_request_bandwidth(wm);\n\n\treturn min(dram_bandwidth, min(data_return_bandwidth, dmif_req_bandwidth));\n}\n\nstatic u32 evergreen_average_bandwidth(struct evergreen_wm_params *wm)\n{\n\t \n\tfixed20_12 bpp;\n\tfixed20_12 line_time;\n\tfixed20_12 src_width;\n\tfixed20_12 bandwidth;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1000);\n\tline_time.full = dfixed_const(wm->active_time + wm->blank_time);\n\tline_time.full = dfixed_div(line_time, a);\n\tbpp.full = dfixed_const(wm->bytes_per_pixel);\n\tsrc_width.full = dfixed_const(wm->src_width);\n\tbandwidth.full = dfixed_mul(src_width, bpp);\n\tbandwidth.full = dfixed_mul(bandwidth, wm->vsc);\n\tbandwidth.full = dfixed_div(bandwidth, line_time);\n\n\treturn dfixed_trunc(bandwidth);\n}\n\nstatic u32 evergreen_latency_watermark(struct evergreen_wm_params *wm)\n{\n\t \n\tu32 mc_latency = 2000;  \n\tu32 available_bandwidth = evergreen_available_bandwidth(wm);\n\tu32 worst_chunk_return_time = (512 * 8 * 1000) / available_bandwidth;\n\tu32 cursor_line_pair_return_time = (128 * 4 * 1000) / available_bandwidth;\n\tu32 dc_latency = 40000000 / wm->disp_clk;  \n\tu32 other_heads_data_return_time = ((wm->num_heads + 1) * worst_chunk_return_time) +\n\t\t(wm->num_heads * cursor_line_pair_return_time);\n\tu32 latency = mc_latency + other_heads_data_return_time + dc_latency;\n\tu32 max_src_lines_per_dst_line, lb_fill_bw, line_fill_time;\n\tfixed20_12 a, b, c;\n\n\tif (wm->num_heads == 0)\n\t\treturn 0;\n\n\ta.full = dfixed_const(2);\n\tb.full = dfixed_const(1);\n\tif ((wm->vsc.full > a.full) ||\n\t    ((wm->vsc.full > b.full) && (wm->vtaps >= 3)) ||\n\t    (wm->vtaps >= 5) ||\n\t    ((wm->vsc.full >= a.full) && wm->interlaced))\n\t\tmax_src_lines_per_dst_line = 4;\n\telse\n\t\tmax_src_lines_per_dst_line = 2;\n\n\ta.full = dfixed_const(available_bandwidth);\n\tb.full = dfixed_const(wm->num_heads);\n\ta.full = dfixed_div(a, b);\n\n\tlb_fill_bw = min(dfixed_trunc(a), wm->disp_clk * wm->bytes_per_pixel / 1000);\n\n\ta.full = dfixed_const(max_src_lines_per_dst_line * wm->src_width * wm->bytes_per_pixel);\n\tb.full = dfixed_const(1000);\n\tc.full = dfixed_const(lb_fill_bw);\n\tb.full = dfixed_div(c, b);\n\ta.full = dfixed_div(a, b);\n\tline_fill_time = dfixed_trunc(a);\n\n\tif (line_fill_time < wm->active_time)\n\t\treturn latency;\n\telse\n\t\treturn latency + (line_fill_time - wm->active_time);\n\n}\n\nstatic bool evergreen_average_bandwidth_vs_dram_bandwidth_for_display(struct evergreen_wm_params *wm)\n{\n\tif (evergreen_average_bandwidth(wm) <=\n\t    (evergreen_dram_bandwidth_for_display(wm) / wm->num_heads))\n\t\treturn true;\n\telse\n\t\treturn false;\n};\n\nstatic bool evergreen_average_bandwidth_vs_available_bandwidth(struct evergreen_wm_params *wm)\n{\n\tif (evergreen_average_bandwidth(wm) <=\n\t    (evergreen_available_bandwidth(wm) / wm->num_heads))\n\t\treturn true;\n\telse\n\t\treturn false;\n};\n\nstatic bool evergreen_check_latency_hiding(struct evergreen_wm_params *wm)\n{\n\tu32 lb_partitions = wm->lb_size / wm->src_width;\n\tu32 line_time = wm->active_time + wm->blank_time;\n\tu32 latency_tolerant_lines;\n\tu32 latency_hiding;\n\tfixed20_12 a;\n\n\ta.full = dfixed_const(1);\n\tif (wm->vsc.full > a.full)\n\t\tlatency_tolerant_lines = 1;\n\telse {\n\t\tif (lb_partitions <= (wm->vtaps + 1))\n\t\t\tlatency_tolerant_lines = 1;\n\t\telse\n\t\t\tlatency_tolerant_lines = 2;\n\t}\n\n\tlatency_hiding = (latency_tolerant_lines * line_time + wm->blank_time);\n\n\tif (evergreen_latency_watermark(wm) <= latency_hiding)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void evergreen_program_watermarks(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_crtc *radeon_crtc,\n\t\t\t\t\t u32 lb_size, u32 num_heads)\n{\n\tstruct drm_display_mode *mode = &radeon_crtc->base.mode;\n\tstruct evergreen_wm_params wm_low, wm_high;\n\tu32 dram_channels;\n\tu32 active_time;\n\tu32 line_time = 0;\n\tu32 latency_watermark_a = 0, latency_watermark_b = 0;\n\tu32 priority_a_mark = 0, priority_b_mark = 0;\n\tu32 priority_a_cnt = PRIORITY_OFF;\n\tu32 priority_b_cnt = PRIORITY_OFF;\n\tu32 pipe_offset = radeon_crtc->crtc_id * 16;\n\tu32 tmp, arb_control3;\n\tfixed20_12 a, b, c;\n\n\tif (radeon_crtc->base.enabled && num_heads && mode) {\n\t\tactive_time = (u32) div_u64((u64)mode->crtc_hdisplay * 1000000,\n\t\t\t\t\t    (u32)mode->clock);\n\t\tline_time = (u32) div_u64((u64)mode->crtc_htotal * 1000000,\n\t\t\t\t\t  (u32)mode->clock);\n\t\tline_time = min(line_time, (u32)65535);\n\t\tpriority_a_cnt = 0;\n\t\tpriority_b_cnt = 0;\n\t\tdram_channels = evergreen_get_number_of_dram_channels(rdev);\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t\twm_high.yclk =\n\t\t\t\tradeon_dpm_get_mclk(rdev, false) * 10;\n\t\t\twm_high.sclk =\n\t\t\t\tradeon_dpm_get_sclk(rdev, false) * 10;\n\t\t} else {\n\t\t\twm_high.yclk = rdev->pm.current_mclk * 10;\n\t\t\twm_high.sclk = rdev->pm.current_sclk * 10;\n\t\t}\n\n\t\twm_high.disp_clk = mode->clock;\n\t\twm_high.src_width = mode->crtc_hdisplay;\n\t\twm_high.active_time = active_time;\n\t\twm_high.blank_time = line_time - wm_high.active_time;\n\t\twm_high.interlaced = false;\n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\twm_high.interlaced = true;\n\t\twm_high.vsc = radeon_crtc->vsc;\n\t\twm_high.vtaps = 1;\n\t\tif (radeon_crtc->rmx_type != RMX_OFF)\n\t\t\twm_high.vtaps = 2;\n\t\twm_high.bytes_per_pixel = 4;  \n\t\twm_high.lb_size = lb_size;\n\t\twm_high.dram_channels = dram_channels;\n\t\twm_high.num_heads = num_heads;\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t\twm_low.yclk =\n\t\t\t\tradeon_dpm_get_mclk(rdev, true) * 10;\n\t\t\twm_low.sclk =\n\t\t\t\tradeon_dpm_get_sclk(rdev, true) * 10;\n\t\t} else {\n\t\t\twm_low.yclk = rdev->pm.current_mclk * 10;\n\t\t\twm_low.sclk = rdev->pm.current_sclk * 10;\n\t\t}\n\n\t\twm_low.disp_clk = mode->clock;\n\t\twm_low.src_width = mode->crtc_hdisplay;\n\t\twm_low.active_time = active_time;\n\t\twm_low.blank_time = line_time - wm_low.active_time;\n\t\twm_low.interlaced = false;\n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\twm_low.interlaced = true;\n\t\twm_low.vsc = radeon_crtc->vsc;\n\t\twm_low.vtaps = 1;\n\t\tif (radeon_crtc->rmx_type != RMX_OFF)\n\t\t\twm_low.vtaps = 2;\n\t\twm_low.bytes_per_pixel = 4;  \n\t\twm_low.lb_size = lb_size;\n\t\twm_low.dram_channels = dram_channels;\n\t\twm_low.num_heads = num_heads;\n\n\t\t \n\t\tlatency_watermark_a = min(evergreen_latency_watermark(&wm_high), (u32)65535);\n\t\t \n\t\tlatency_watermark_b = min(evergreen_latency_watermark(&wm_low), (u32)65535);\n\n\t\t \n\t\t \n\t\tif (!evergreen_average_bandwidth_vs_dram_bandwidth_for_display(&wm_high) ||\n\t\t    !evergreen_average_bandwidth_vs_available_bandwidth(&wm_high) ||\n\t\t    !evergreen_check_latency_hiding(&wm_high) ||\n\t\t    (rdev->disp_priority == 2)) {\n\t\t\tDRM_DEBUG_KMS(\"force priority a to high\\n\");\n\t\t\tpriority_a_cnt |= PRIORITY_ALWAYS_ON;\n\t\t}\n\t\tif (!evergreen_average_bandwidth_vs_dram_bandwidth_for_display(&wm_low) ||\n\t\t    !evergreen_average_bandwidth_vs_available_bandwidth(&wm_low) ||\n\t\t    !evergreen_check_latency_hiding(&wm_low) ||\n\t\t    (rdev->disp_priority == 2)) {\n\t\t\tDRM_DEBUG_KMS(\"force priority b to high\\n\");\n\t\t\tpriority_b_cnt |= PRIORITY_ALWAYS_ON;\n\t\t}\n\n\t\ta.full = dfixed_const(1000);\n\t\tb.full = dfixed_const(mode->clock);\n\t\tb.full = dfixed_div(b, a);\n\t\tc.full = dfixed_const(latency_watermark_a);\n\t\tc.full = dfixed_mul(c, b);\n\t\tc.full = dfixed_mul(c, radeon_crtc->hsc);\n\t\tc.full = dfixed_div(c, a);\n\t\ta.full = dfixed_const(16);\n\t\tc.full = dfixed_div(c, a);\n\t\tpriority_a_mark = dfixed_trunc(c);\n\t\tpriority_a_cnt |= priority_a_mark & PRIORITY_MARK_MASK;\n\n\t\ta.full = dfixed_const(1000);\n\t\tb.full = dfixed_const(mode->clock);\n\t\tb.full = dfixed_div(b, a);\n\t\tc.full = dfixed_const(latency_watermark_b);\n\t\tc.full = dfixed_mul(c, b);\n\t\tc.full = dfixed_mul(c, radeon_crtc->hsc);\n\t\tc.full = dfixed_div(c, a);\n\t\ta.full = dfixed_const(16);\n\t\tc.full = dfixed_div(c, a);\n\t\tpriority_b_mark = dfixed_trunc(c);\n\t\tpriority_b_cnt |= priority_b_mark & PRIORITY_MARK_MASK;\n\n\t\t \n\t\tradeon_crtc->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode->crtc_hdisplay);\n\t}\n\n\t \n\tarb_control3 = RREG32(PIPE0_ARBITRATION_CONTROL3 + pipe_offset);\n\ttmp = arb_control3;\n\ttmp &= ~LATENCY_WATERMARK_MASK(3);\n\ttmp |= LATENCY_WATERMARK_MASK(1);\n\tWREG32(PIPE0_ARBITRATION_CONTROL3 + pipe_offset, tmp);\n\tWREG32(PIPE0_LATENCY_CONTROL + pipe_offset,\n\t       (LATENCY_LOW_WATERMARK(latency_watermark_a) |\n\t\tLATENCY_HIGH_WATERMARK(line_time)));\n\t \n\ttmp = RREG32(PIPE0_ARBITRATION_CONTROL3 + pipe_offset);\n\ttmp &= ~LATENCY_WATERMARK_MASK(3);\n\ttmp |= LATENCY_WATERMARK_MASK(2);\n\tWREG32(PIPE0_ARBITRATION_CONTROL3 + pipe_offset, tmp);\n\tWREG32(PIPE0_LATENCY_CONTROL + pipe_offset,\n\t       (LATENCY_LOW_WATERMARK(latency_watermark_b) |\n\t\tLATENCY_HIGH_WATERMARK(line_time)));\n\t \n\tWREG32(PIPE0_ARBITRATION_CONTROL3 + pipe_offset, arb_control3);\n\n\t \n\tWREG32(PRIORITY_A_CNT + radeon_crtc->crtc_offset, priority_a_cnt);\n\tWREG32(PRIORITY_B_CNT + radeon_crtc->crtc_offset, priority_b_cnt);\n\n\t \n\tradeon_crtc->line_time = line_time;\n\tradeon_crtc->wm_high = latency_watermark_a;\n\tradeon_crtc->wm_low = latency_watermark_b;\n}\n\n \nvoid evergreen_bandwidth_update(struct radeon_device *rdev)\n{\n\tstruct drm_display_mode *mode0 = NULL;\n\tstruct drm_display_mode *mode1 = NULL;\n\tu32 num_heads = 0, lb_size;\n\tint i;\n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (rdev->mode_info.crtcs[i]->base.enabled)\n\t\t\tnum_heads++;\n\t}\n\tfor (i = 0; i < rdev->num_crtc; i += 2) {\n\t\tmode0 = &rdev->mode_info.crtcs[i]->base.mode;\n\t\tmode1 = &rdev->mode_info.crtcs[i+1]->base.mode;\n\t\tlb_size = evergreen_line_buffer_adjust(rdev, rdev->mode_info.crtcs[i], mode0, mode1);\n\t\tevergreen_program_watermarks(rdev, rdev->mode_info.crtcs[i], lb_size, num_heads);\n\t\tlb_size = evergreen_line_buffer_adjust(rdev, rdev->mode_info.crtcs[i+1], mode1, mode0);\n\t\tevergreen_program_watermarks(rdev, rdev->mode_info.crtcs[i+1], lb_size, num_heads);\n\t}\n}\n\n \nint evergreen_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tu32 tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(SRBM_STATUS) & 0x1F00;\n\t\tif (!tmp)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\n \nvoid evergreen_pcie_gart_tlb_flush(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tu32 tmp;\n\n\tWREG32(HDP_MEM_COHERENCY_FLUSH_CNTL, 0x1);\n\n\tWREG32(VM_CONTEXT0_REQUEST_RESPONSE, REQUEST_TYPE(1));\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(VM_CONTEXT0_REQUEST_RESPONSE);\n\t\ttmp = (tmp & RESPONSE_TYPE_MASK) >> RESPONSE_TYPE_SHIFT;\n\t\tif (tmp == 2) {\n\t\t\tpr_warn(\"[drm] r600 flush TLB failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (tmp) {\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t}\n}\n\nstatic int evergreen_pcie_gart_enable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint r;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE | ENABLE_L2_FRAGMENT_PROCESSING |\n\t\t\t\tENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t\t\t\tEFFECTIVE_L2_QUEUE_SIZE(7));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, BANK_SELECT(0) | CACHE_UPDATE_MODE(2));\n\t \n\ttmp = ENABLE_L1_TLB | ENABLE_L1_FRAGMENT_PROCESSING |\n\t\tSYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t\tSYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU |\n\t\tEFFECTIVE_L1_TLB_SIZE(5) | EFFECTIVE_L1_QUEUE_SIZE(5);\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tWREG32(FUS_MC_VM_MD_L1_TLB0_CNTL, tmp);\n\t\tWREG32(FUS_MC_VM_MD_L1_TLB1_CNTL, tmp);\n\t\tWREG32(FUS_MC_VM_MD_L1_TLB2_CNTL, tmp);\n\t} else {\n\t\tWREG32(MC_VM_MD_L1_TLB0_CNTL, tmp);\n\t\tWREG32(MC_VM_MD_L1_TLB1_CNTL, tmp);\n\t\tWREG32(MC_VM_MD_L1_TLB2_CNTL, tmp);\n\t\tif ((rdev->family == CHIP_JUNIPER) ||\n\t\t    (rdev->family == CHIP_CYPRESS) ||\n\t\t    (rdev->family == CHIP_HEMLOCK) ||\n\t\t    (rdev->family == CHIP_BARTS))\n\t\t\tWREG32(MC_VM_MD_L1_TLB3_CNTL, tmp);\n\t}\n\tWREG32(MC_VM_MB_L1_TLB0_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB1_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB2_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB3_CNTL, tmp);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev->gart.table_addr >> 12);\n\tWREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_DEFAULT);\n\tWREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,\n\t\t\t(u32)(rdev->dummy_page.addr >> 12));\n\tWREG32(VM_CONTEXT1_CNTL, 0);\n\n\tevergreen_pcie_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nstatic void evergreen_pcie_gart_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\t \n\tWREG32(VM_CONTEXT0_CNTL, 0);\n\tWREG32(VM_CONTEXT1_CNTL, 0);\n\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_FRAGMENT_PROCESSING |\n\t\t\t\tEFFECTIVE_L2_QUEUE_SIZE(7));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, BANK_SELECT(0) | CACHE_UPDATE_MODE(2));\n\t \n\ttmp = EFFECTIVE_L1_TLB_SIZE(5) | EFFECTIVE_L1_QUEUE_SIZE(5);\n\tWREG32(MC_VM_MD_L1_TLB0_CNTL, tmp);\n\tWREG32(MC_VM_MD_L1_TLB1_CNTL, tmp);\n\tWREG32(MC_VM_MD_L1_TLB2_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB0_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB1_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB2_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB3_CNTL, tmp);\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\nstatic void evergreen_pcie_gart_fini(struct radeon_device *rdev)\n{\n\tevergreen_pcie_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n\tradeon_gart_fini(rdev);\n}\n\n\nstatic void evergreen_agp_enable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE | ENABLE_L2_FRAGMENT_PROCESSING |\n\t\t\t\tENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t\t\t\tEFFECTIVE_L2_QUEUE_SIZE(7));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, BANK_SELECT(0) | CACHE_UPDATE_MODE(2));\n\t \n\ttmp = ENABLE_L1_TLB | ENABLE_L1_FRAGMENT_PROCESSING |\n\t\tSYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t\tSYSTEM_APERTURE_UNMAPPED_ACCESS_PASS_THRU |\n\t\tEFFECTIVE_L1_TLB_SIZE(5) | EFFECTIVE_L1_QUEUE_SIZE(5);\n\tWREG32(MC_VM_MD_L1_TLB0_CNTL, tmp);\n\tWREG32(MC_VM_MD_L1_TLB1_CNTL, tmp);\n\tWREG32(MC_VM_MD_L1_TLB2_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB0_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB1_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB2_CNTL, tmp);\n\tWREG32(MC_VM_MB_L1_TLB3_CNTL, tmp);\n\tWREG32(VM_CONTEXT0_CNTL, 0);\n\tWREG32(VM_CONTEXT1_CNTL, 0);\n}\n\nstatic const unsigned ni_dig_offsets[] =\n{\n\tNI_DIG0_REGISTER_OFFSET,\n\tNI_DIG1_REGISTER_OFFSET,\n\tNI_DIG2_REGISTER_OFFSET,\n\tNI_DIG3_REGISTER_OFFSET,\n\tNI_DIG4_REGISTER_OFFSET,\n\tNI_DIG5_REGISTER_OFFSET\n};\n\nstatic const unsigned ni_tx_offsets[] =\n{\n\tNI_DCIO_UNIPHY0_UNIPHY_TX_CONTROL1,\n\tNI_DCIO_UNIPHY1_UNIPHY_TX_CONTROL1,\n\tNI_DCIO_UNIPHY2_UNIPHY_TX_CONTROL1,\n\tNI_DCIO_UNIPHY3_UNIPHY_TX_CONTROL1,\n\tNI_DCIO_UNIPHY4_UNIPHY_TX_CONTROL1,\n\tNI_DCIO_UNIPHY5_UNIPHY_TX_CONTROL1\n};\n\nstatic const unsigned evergreen_dp_offsets[] =\n{\n\tEVERGREEN_DP0_REGISTER_OFFSET,\n\tEVERGREEN_DP1_REGISTER_OFFSET,\n\tEVERGREEN_DP2_REGISTER_OFFSET,\n\tEVERGREEN_DP3_REGISTER_OFFSET,\n\tEVERGREEN_DP4_REGISTER_OFFSET,\n\tEVERGREEN_DP5_REGISTER_OFFSET\n};\n\nstatic const unsigned evergreen_disp_int_status[] =\n{\n\tDISP_INTERRUPT_STATUS,\n\tDISP_INTERRUPT_STATUS_CONTINUE,\n\tDISP_INTERRUPT_STATUS_CONTINUE2,\n\tDISP_INTERRUPT_STATUS_CONTINUE3,\n\tDISP_INTERRUPT_STATUS_CONTINUE4,\n\tDISP_INTERRUPT_STATUS_CONTINUE5\n};\n\n \nstatic bool evergreen_is_dp_sst_stream_enabled(struct radeon_device *rdev,\n\t\t\t\t\t       unsigned crtc_id, unsigned *ret_dig_fe)\n{\n\tunsigned i;\n\tunsigned dig_fe;\n\tunsigned dig_be;\n\tunsigned dig_en_be;\n\tunsigned uniphy_pll;\n\tunsigned digs_fe_selected;\n\tunsigned dig_be_mode;\n\tunsigned dig_fe_mask;\n\tbool is_enabled = false;\n\tbool found_crtc = false;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ni_dig_offsets); i++) {\n\t\tdig_fe = RREG32(NI_DIG_FE_CNTL + ni_dig_offsets[i]);\n\t\tif (dig_fe & NI_DIG_FE_CNTL_SYMCLK_FE_ON &&\n\t\t    crtc_id == NI_DIG_FE_CNTL_SOURCE_SELECT(dig_fe)) {\n\t\t\t \n\t\t\tfound_crtc = true;\n\t\t\tdig_fe_mask = 1 << i;\n\t\t\tdig_fe = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_crtc) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(ni_dig_offsets); i++) {\n\t\t\tdig_be = RREG32(NI_DIG_BE_CNTL + ni_dig_offsets[i]);\n\t\t\t \n\t\t\tdigs_fe_selected = NI_DIG_BE_CNTL_FE_SOURCE_SELECT(dig_be);\n\t\t\tdig_be_mode = NI_DIG_FE_CNTL_MODE(dig_be);\n\t\t\tif (dig_fe_mask &  digs_fe_selected &&\n\t\t\t     \n\t\t\t    dig_be_mode == NI_DIG_BE_DPSST) {\n\t\t\t\tdig_en_be = RREG32(NI_DIG_BE_EN_CNTL +\n\t\t\t\t\t\t   ni_dig_offsets[i]);\n\t\t\t\tuniphy_pll = RREG32(NI_DCIO_UNIPHY0_PLL_CONTROL1 +\n\t\t\t\t\t\t    ni_tx_offsets[i]);\n\t\t\t\t \n\t\t\t\tif (dig_en_be & NI_DIG_BE_EN_CNTL_ENABLE &&\n\t\t\t\t    dig_en_be & NI_DIG_BE_EN_CNTL_SYMBCLK_ON &&\n\t\t\t\t    uniphy_pll & NI_DCIO_UNIPHY0_PLL_CONTROL1_ENABLE) {\n\t\t\t\t\tis_enabled = true;\n\t\t\t\t\t*ret_dig_fe = dig_fe;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn is_enabled;\n}\n\n \nstatic void evergreen_blank_dp_output(struct radeon_device *rdev,\n\t\t\t\t      unsigned dig_fe)\n{\n\tunsigned stream_ctrl;\n\tunsigned fifo_ctrl;\n\tunsigned counter = 0;\n\n\tif (dig_fe >= ARRAY_SIZE(evergreen_dp_offsets)) {\n\t\tDRM_ERROR(\"invalid dig_fe %d\\n\", dig_fe);\n\t\treturn;\n\t}\n\n\tstream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +\n\t\t\t     evergreen_dp_offsets[dig_fe]);\n\tif (!(stream_ctrl & EVERGREEN_DP_VID_STREAM_CNTL_ENABLE)) {\n\t\tDRM_ERROR(\"dig %d , should be enable\\n\", dig_fe);\n\t\treturn;\n\t}\n\n\tstream_ctrl &=~EVERGREEN_DP_VID_STREAM_CNTL_ENABLE;\n\tWREG32(EVERGREEN_DP_VID_STREAM_CNTL +\n\t       evergreen_dp_offsets[dig_fe], stream_ctrl);\n\n\tstream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +\n\t\t\t     evergreen_dp_offsets[dig_fe]);\n\twhile (counter < 32 && stream_ctrl & EVERGREEN_DP_VID_STREAM_STATUS) {\n\t\tmsleep(1);\n\t\tcounter++;\n\t\tstream_ctrl = RREG32(EVERGREEN_DP_VID_STREAM_CNTL +\n\t\t\t\t     evergreen_dp_offsets[dig_fe]);\n\t}\n\tif (counter >= 32 )\n\t\tDRM_ERROR(\"counter exceeds %d\\n\", counter);\n\n\tfifo_ctrl = RREG32(EVERGREEN_DP_STEER_FIFO + evergreen_dp_offsets[dig_fe]);\n\tfifo_ctrl |= EVERGREEN_DP_STEER_FIFO_RESET;\n\tWREG32(EVERGREEN_DP_STEER_FIFO + evergreen_dp_offsets[dig_fe], fifo_ctrl);\n\n}\n\nvoid evergreen_mc_stop(struct radeon_device *rdev, struct evergreen_mc_save *save)\n{\n\tu32 crtc_enabled, tmp, frame_count, blackout;\n\tint i, j;\n\tunsigned dig_fe;\n\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\tsave->vga_render_control = RREG32(VGA_RENDER_CONTROL);\n\t\tsave->vga_hdp_control = RREG32(VGA_HDP_CONTROL);\n\n\t\t \n\t\tWREG32(VGA_RENDER_CONTROL, 0);\n\t}\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tcrtc_enabled = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]) & EVERGREEN_CRTC_MASTER_EN;\n\t\tif (crtc_enabled) {\n\t\t\tsave->crtc_enabled[i] = true;\n\t\t\tif (ASIC_IS_DCE6(rdev)) {\n\t\t\t\ttmp = RREG32(EVERGREEN_CRTC_BLANK_CONTROL + crtc_offsets[i]);\n\t\t\t\tif (!(tmp & EVERGREEN_CRTC_BLANK_DATA_EN)) {\n\t\t\t\t\tradeon_wait_for_vblank(rdev, i);\n\t\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\t\t\ttmp |= EVERGREEN_CRTC_BLANK_DATA_EN;\n\t\t\t\t\tWREG32(EVERGREEN_CRTC_BLANK_CONTROL + crtc_offsets[i], tmp);\n\t\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttmp = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]);\n\t\t\t\tif (!(tmp & EVERGREEN_CRTC_DISP_READ_REQUEST_DISABLE)) {\n\t\t\t\t\tradeon_wait_for_vblank(rdev, i);\n\t\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\t\t\ttmp |= EVERGREEN_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\t\t\tWREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i], tmp);\n\t\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tframe_count = radeon_get_vblank_counter(rdev, i);\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\tif (radeon_get_vblank_counter(rdev, i) != frame_count)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\t \n\t\t\tif (ASIC_IS_DCE5(rdev) &&\n\t\t\t    evergreen_is_dp_sst_stream_enabled(rdev, i ,&dig_fe))\n\t\t\t\tevergreen_blank_dp_output(rdev, dig_fe);\n\t\t\t \n\t\t\t \n\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\ttmp = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]);\n\t\t\ttmp &= ~EVERGREEN_CRTC_MASTER_EN;\n\t\t\tWREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i], tmp);\n\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\tsave->crtc_enabled[i] = false;\n\t\t\t \n\t\t} else {\n\t\t\tsave->crtc_enabled[i] = false;\n\t\t}\n\t}\n\n\tradeon_mc_wait_for_idle(rdev);\n\n\tblackout = RREG32(MC_SHARED_BLACKOUT_CNTL);\n\tif ((blackout & BLACKOUT_MODE_MASK) != 1) {\n\t\t \n\t\tWREG32(BIF_FB_EN, 0);\n\t\t \n\t\tblackout &= ~BLACKOUT_MODE_MASK;\n\t\tWREG32(MC_SHARED_BLACKOUT_CNTL, blackout | 1);\n\t}\n\t \n\tudelay(100);\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (save->crtc_enabled[i]) {\n\t\t\ttmp = RREG32(EVERGREEN_GRPH_UPDATE + crtc_offsets[i]);\n\t\t\tif (!(tmp & EVERGREEN_GRPH_UPDATE_LOCK)) {\n\t\t\t\ttmp |= EVERGREEN_GRPH_UPDATE_LOCK;\n\t\t\t\tWREG32(EVERGREEN_GRPH_UPDATE + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\ttmp = RREG32(EVERGREEN_MASTER_UPDATE_LOCK + crtc_offsets[i]);\n\t\t\tif (!(tmp & 1)) {\n\t\t\t\ttmp |= 1;\n\t\t\t\tWREG32(EVERGREEN_MASTER_UPDATE_LOCK + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid evergreen_mc_resume(struct radeon_device *rdev, struct evergreen_mc_save *save)\n{\n\tu32 tmp, frame_count;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i],\n\t\t       upper_32_bits(rdev->mc.vram_start));\n\t\tWREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + crtc_offsets[i],\n\t\t       upper_32_bits(rdev->mc.vram_start));\n\t\tWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],\n\t\t       (u32)rdev->mc.vram_start);\n\t\tWREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],\n\t\t       (u32)rdev->mc.vram_start);\n\t}\n\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\tWREG32(EVERGREEN_VGA_MEMORY_BASE_ADDRESS_HIGH, upper_32_bits(rdev->mc.vram_start));\n\t\tWREG32(EVERGREEN_VGA_MEMORY_BASE_ADDRESS, (u32)rdev->mc.vram_start);\n\t}\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (save->crtc_enabled[i]) {\n\t\t\ttmp = RREG32(EVERGREEN_MASTER_UPDATE_MODE + crtc_offsets[i]);\n\t\t\tif ((tmp & 0x7) != 0) {\n\t\t\t\ttmp &= ~0x7;\n\t\t\t\tWREG32(EVERGREEN_MASTER_UPDATE_MODE + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\ttmp = RREG32(EVERGREEN_GRPH_UPDATE + crtc_offsets[i]);\n\t\t\tif (tmp & EVERGREEN_GRPH_UPDATE_LOCK) {\n\t\t\t\ttmp &= ~EVERGREEN_GRPH_UPDATE_LOCK;\n\t\t\t\tWREG32(EVERGREEN_GRPH_UPDATE + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\ttmp = RREG32(EVERGREEN_MASTER_UPDATE_LOCK + crtc_offsets[i]);\n\t\t\tif (tmp & 1) {\n\t\t\t\ttmp &= ~1;\n\t\t\t\tWREG32(EVERGREEN_MASTER_UPDATE_LOCK + crtc_offsets[i], tmp);\n\t\t\t}\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\ttmp = RREG32(EVERGREEN_GRPH_UPDATE + crtc_offsets[i]);\n\t\t\t\tif ((tmp & EVERGREEN_GRPH_SURFACE_UPDATE_PENDING) == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttmp = RREG32(MC_SHARED_BLACKOUT_CNTL);\n\ttmp &= ~BLACKOUT_MODE_MASK;\n\tWREG32(MC_SHARED_BLACKOUT_CNTL, tmp);\n\t \n\tWREG32(BIF_FB_EN, FB_READ_EN | FB_WRITE_EN);\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (save->crtc_enabled[i]) {\n\t\t\tif (ASIC_IS_DCE6(rdev)) {\n\t\t\t\ttmp = RREG32(EVERGREEN_CRTC_BLANK_CONTROL + crtc_offsets[i]);\n\t\t\t\ttmp &= ~EVERGREEN_CRTC_BLANK_DATA_EN;\n\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\t\tWREG32(EVERGREEN_CRTC_BLANK_CONTROL + crtc_offsets[i], tmp);\n\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\t} else {\n\t\t\t\ttmp = RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]);\n\t\t\t\ttmp &= ~EVERGREEN_CRTC_DISP_READ_REQUEST_DISABLE;\n\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 1);\n\t\t\t\tWREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i], tmp);\n\t\t\t\tWREG32(EVERGREEN_CRTC_UPDATE_LOCK + crtc_offsets[i], 0);\n\t\t\t}\n\t\t\t \n\t\t\tframe_count = radeon_get_vblank_counter(rdev, i);\n\t\t\tfor (j = 0; j < rdev->usec_timeout; j++) {\n\t\t\t\tif (radeon_get_vblank_counter(rdev, i) != frame_count)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\t \n\t\tWREG32(VGA_HDP_CONTROL, save->vga_hdp_control);\n\t\tmdelay(1);\n\t\tWREG32(VGA_RENDER_CONTROL, save->vga_render_control);\n\t}\n}\n\nvoid evergreen_mc_program(struct radeon_device *rdev)\n{\n\tstruct evergreen_mc_save save;\n\tu32 tmp;\n\tint i, j;\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\tWREG32(HDP_REG_COHERENCY_FLUSH_CNTL, 0);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\t \n\tWREG32(VGA_HDP_CONTROL, VGA_MEMORY_DISABLE);\n\t \n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tif (rdev->mc.vram_start < rdev->mc.gtt_start) {\n\t\t\t \n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t\t\t\trdev->mc.vram_start >> 12);\n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t\t\t\trdev->mc.gtt_end >> 12);\n\t\t} else {\n\t\t\t \n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t\t\t\trdev->mc.gtt_start >> 12);\n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t\t\t\trdev->mc.vram_end >> 12);\n\t\t}\n\t} else {\n\t\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t\t\trdev->mc.vram_start >> 12);\n\t\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t\t\trdev->mc.vram_end >> 12);\n\t}\n\tWREG32(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR, rdev->vram_scratch.gpu_addr >> 12);\n\t \n\tif ((rdev->family == CHIP_PALM) ||\n\t    (rdev->family == CHIP_SUMO) ||\n\t    (rdev->family == CHIP_SUMO2)) {\n\t\ttmp = RREG32(MC_FUS_VM_FB_OFFSET) & 0x000FFFFF;\n\t\ttmp |= ((rdev->mc.vram_end >> 20) & 0xF) << 24;\n\t\ttmp |= ((rdev->mc.vram_start >> 20) & 0xF) << 20;\n\t\tWREG32(MC_FUS_VM_FB_OFFSET, tmp);\n\t}\n\ttmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;\n\ttmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);\n\tWREG32(MC_VM_FB_LOCATION, tmp);\n\tWREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));\n\tWREG32(HDP_NONSURFACE_INFO, (2 << 7) | (1 << 30));\n\tWREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tWREG32(MC_VM_AGP_TOP, rdev->mc.gtt_end >> 16);\n\t\tWREG32(MC_VM_AGP_BOT, rdev->mc.gtt_start >> 16);\n\t\tWREG32(MC_VM_AGP_BASE, rdev->mc.agp_base >> 22);\n\t} else {\n\t\tWREG32(MC_VM_AGP_BASE, 0);\n\t\tWREG32(MC_VM_AGP_TOP, 0x0FFFFFFF);\n\t\tWREG32(MC_VM_AGP_BOT, 0x0FFFFFFF);\n\t}\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\tevergreen_mc_resume(rdev, &save);\n\t \n\trv515_vga_render_disable(rdev);\n}\n\n \nvoid evergreen_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tu32 next_rptr;\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_MODE_CONTROL, 0));\n\tradeon_ring_write(ring, 1);\n\n\tif (ring->rptr_save_reg) {\n\t\tnext_rptr = ring->wptr + 3 + 4;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tradeon_ring_write(ring, ((ring->rptr_save_reg - \n\t\t\t\t\t  PACKET3_SET_CONFIG_REG_START) >> 2));\n\t\tradeon_ring_write(ring, next_rptr);\n\t} else if (rdev->wb.enabled) {\n\t\tnext_rptr = ring->wptr + 5 + 4;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_MEM_WRITE, 3));\n\t\tradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\n\t\tradeon_ring_write(ring, (upper_32_bits(ring->next_rptr_gpu_addr) & 0xff) | (1 << 18));\n\t\tradeon_ring_write(ring, next_rptr);\n\t\tradeon_ring_write(ring, 0);\n\t}\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tradeon_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t  (2 << 0) |\n#endif\n\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tradeon_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFF);\n\tradeon_ring_write(ring, ib->length_dw);\n}\n\n\nstatic int evergreen_cp_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data;\n\tint i;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw)\n\t\treturn -EINVAL;\n\n\tr700_cp_stop(rdev);\n\tWREG32(CP_RB_CNTL,\n#ifdef __BIG_ENDIAN\n\t       BUF_SWAP_32BIT |\n#endif\n\t       RB_NO_UPDATE | RB_BLKSZ(15) | RB_BUFSZ(3));\n\n\tfw_data = (const __be32 *)rdev->pfp_fw->data;\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tfor (i = 0; i < EVERGREEN_PFP_UCODE_SIZE; i++)\n\t\tWREG32(CP_PFP_UCODE_DATA, be32_to_cpup(fw_data++));\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\n\tfw_data = (const __be32 *)rdev->me_fw->data;\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tfor (i = 0; i < EVERGREEN_PM4_UCODE_SIZE; i++)\n\t\tWREG32(CP_ME_RAM_DATA, be32_to_cpup(fw_data++));\n\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tWREG32(CP_ME_RAM_RADDR, 0);\n\treturn 0;\n}\n\nstatic int evergreen_cp_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r, i;\n\tuint32_t cp_me;\n\n\tr = radeon_ring_lock(rdev, ring, 7);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET3(PACKET3_ME_INITIALIZE, 5));\n\tradeon_ring_write(ring, 0x1);\n\tradeon_ring_write(ring, 0x0);\n\tradeon_ring_write(ring, rdev->config.evergreen.max_hw_contexts - 1);\n\tradeon_ring_write(ring, PACKET3_ME_INITIALIZE_DEVICE_ID(1));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tcp_me = 0xff;\n\tWREG32(CP_ME_CNTL, cp_me);\n\n\tr = radeon_ring_lock(rdev, ring, evergreen_default_size + 19);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_BEGIN_CLEAR_STATE);\n\n\tfor (i = 0; i < evergreen_default_size; i++)\n\t\tradeon_ring_write(ring, evergreen_default_state[i]);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_PREAMBLE_CNTL, 0));\n\tradeon_ring_write(ring, PACKET3_PREAMBLE_END_CLEAR_STATE);\n\n\t \n\tradeon_ring_write(ring, PACKET3(PACKET3_CLEAR_STATE, 0));\n\tradeon_ring_write(ring, 0);\n\n\t \n\tradeon_ring_write(ring, 0xc0026f00);\n\tradeon_ring_write(ring, 0x00000000);\n\tradeon_ring_write(ring, 0x00000000);\n\tradeon_ring_write(ring, 0x00000000);\n\n\t \n\tradeon_ring_write(ring, 0xc0036f00);\n\tradeon_ring_write(ring, 0x00000bc4);\n\tradeon_ring_write(ring, 0xffffffff);\n\tradeon_ring_write(ring, 0xffffffff);\n\tradeon_ring_write(ring, 0xffffffff);\n\n\tradeon_ring_write(ring, 0xc0026900);\n\tradeon_ring_write(ring, 0x00000316);\n\tradeon_ring_write(ring, 0x0000000e);  \n\tradeon_ring_write(ring, 0x00000010);  \n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\treturn 0;\n}\n\nstatic int evergreen_cp_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tint r;\n\n\t \n\tWREG32(GRBM_SOFT_RESET, (SOFT_RESET_CP |\n\t\t\t\t SOFT_RESET_PA |\n\t\t\t\t SOFT_RESET_SH |\n\t\t\t\t SOFT_RESET_VGT |\n\t\t\t\t SOFT_RESET_SPI |\n\t\t\t\t SOFT_RESET_SX));\n\tRREG32(GRBM_SOFT_RESET);\n\tmdelay(15);\n\tWREG32(GRBM_SOFT_RESET, 0);\n\tRREG32(GRBM_SOFT_RESET);\n\n\t \n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= BUF_SWAP_32BIT;\n#endif\n\tWREG32(CP_RB_CNTL, tmp);\n\tWREG32(CP_SEM_WAIT_TIMER, 0x0);\n\tWREG32(CP_SEM_INCOMPLETE_TIMER_CNTL, 0x0);\n\n\t \n\tWREG32(CP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32(CP_RB_CNTL, tmp | RB_RPTR_WR_ENA);\n\tWREG32(CP_RB_RPTR_WR, 0);\n\tring->wptr = 0;\n\tWREG32(CP_RB_WPTR, ring->wptr);\n\n\t \n\tWREG32(CP_RB_RPTR_ADDR,\n\t       ((rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFFFFFFFC));\n\tWREG32(CP_RB_RPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFF);\n\tWREG32(SCRATCH_ADDR, ((rdev->wb.gpu_addr + RADEON_WB_SCRATCH_OFFSET) >> 8) & 0xFFFFFFFF);\n\n\tif (rdev->wb.enabled)\n\t\tWREG32(SCRATCH_UMSK, 0xff);\n\telse {\n\t\ttmp |= RB_NO_UPDATE;\n\t\tWREG32(SCRATCH_UMSK, 0);\n\t}\n\n\tmdelay(1);\n\tWREG32(CP_RB_CNTL, tmp);\n\n\tWREG32(CP_RB_BASE, ring->gpu_addr >> 8);\n\tWREG32(CP_DEBUG, (1 << 27) | (1 << 28));\n\n\tevergreen_cp_start(rdev);\n\tring->ready = true;\n\tr = radeon_ring_test(rdev, RADEON_RING_TYPE_GFX_INDEX, ring);\n\tif (r) {\n\t\tring->ready = false;\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nstatic void evergreen_gpu_init(struct radeon_device *rdev)\n{\n\tu32 gb_addr_config;\n\tu32 mc_arb_ramcfg;\n\tu32 sx_debug_1;\n\tu32 smx_dc_ctl0;\n\tu32 sq_config;\n\tu32 sq_lds_resource_mgmt;\n\tu32 sq_gpr_resource_mgmt_1;\n\tu32 sq_gpr_resource_mgmt_2;\n\tu32 sq_gpr_resource_mgmt_3;\n\tu32 sq_thread_resource_mgmt;\n\tu32 sq_thread_resource_mgmt_2;\n\tu32 sq_stack_resource_mgmt_1;\n\tu32 sq_stack_resource_mgmt_2;\n\tu32 sq_stack_resource_mgmt_3;\n\tu32 vgt_cache_invalidation;\n\tu32 hdp_host_path_cntl, tmp;\n\tu32 disabled_rb_mask;\n\tint i, j, ps_thread_count;\n\n\tswitch (rdev->family) {\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\t\trdev->config.evergreen.num_ses = 2;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 8;\n\t\trdev->config.evergreen.max_simds = 10;\n\t\trdev->config.evergreen.max_backends = 4 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 512;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 8;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x100;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CYPRESS_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_JUNIPER:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 4;\n\t\trdev->config.evergreen.max_simds = 10;\n\t\trdev->config.evergreen.max_backends = 4 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 512;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 8;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x100;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = JUNIPER_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_REDWOOD:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 4;\n\t\trdev->config.evergreen.max_simds = 5;\n\t\trdev->config.evergreen.max_backends = 2 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 256;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 8;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x100;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = REDWOOD_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_CEDAR:\n\tdefault:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 2;\n\t\trdev->config.evergreen.max_tile_pipes = 2;\n\t\trdev->config.evergreen.max_simds = 2;\n\t\trdev->config.evergreen.max_backends = 1 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 192;\n\t\trdev->config.evergreen.max_gs_threads = 16;\n\t\trdev->config.evergreen.max_stack_entries = 256;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 128;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 32;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 96;\n\t\trdev->config.evergreen.max_hw_contexts = 4;\n\t\trdev->config.evergreen.sq_num_cf_insts = 1;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x40;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CEDAR_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_PALM:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 2;\n\t\trdev->config.evergreen.max_tile_pipes = 2;\n\t\trdev->config.evergreen.max_simds = 2;\n\t\trdev->config.evergreen.max_backends = 1 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 192;\n\t\trdev->config.evergreen.max_gs_threads = 16;\n\t\trdev->config.evergreen.max_stack_entries = 256;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 128;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 32;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 96;\n\t\trdev->config.evergreen.max_hw_contexts = 4;\n\t\trdev->config.evergreen.sq_num_cf_insts = 1;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x40;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CEDAR_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_SUMO:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 4;\n\t\tif (rdev->pdev->device == 0x9648)\n\t\t\trdev->config.evergreen.max_simds = 3;\n\t\telse if ((rdev->pdev->device == 0x9647) ||\n\t\t\t (rdev->pdev->device == 0x964a))\n\t\t\trdev->config.evergreen.max_simds = 4;\n\t\telse\n\t\t\trdev->config.evergreen.max_simds = 5;\n\t\trdev->config.evergreen.max_backends = 2 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 256;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 8;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x40;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = SUMO_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_SUMO2:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 4;\n\t\trdev->config.evergreen.max_simds = 2;\n\t\trdev->config.evergreen.max_backends = 1 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 512;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 4;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x40;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = SUMO2_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_BARTS:\n\t\trdev->config.evergreen.num_ses = 2;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 8;\n\t\trdev->config.evergreen.max_simds = 7;\n\t\trdev->config.evergreen.max_backends = 4 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 512;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 8;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x100;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = BARTS_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_TURKS:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 4;\n\t\trdev->config.evergreen.max_tile_pipes = 4;\n\t\trdev->config.evergreen.max_simds = 6;\n\t\trdev->config.evergreen.max_backends = 2 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 248;\n\t\trdev->config.evergreen.max_gs_threads = 32;\n\t\trdev->config.evergreen.max_stack_entries = 256;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 256;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 64;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 192;\n\t\trdev->config.evergreen.max_hw_contexts = 8;\n\t\trdev->config.evergreen.sq_num_cf_insts = 2;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x100;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = TURKS_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\tcase CHIP_CAICOS:\n\t\trdev->config.evergreen.num_ses = 1;\n\t\trdev->config.evergreen.max_pipes = 2;\n\t\trdev->config.evergreen.max_tile_pipes = 2;\n\t\trdev->config.evergreen.max_simds = 2;\n\t\trdev->config.evergreen.max_backends = 1 * rdev->config.evergreen.num_ses;\n\t\trdev->config.evergreen.max_gprs = 256;\n\t\trdev->config.evergreen.max_threads = 192;\n\t\trdev->config.evergreen.max_gs_threads = 16;\n\t\trdev->config.evergreen.max_stack_entries = 256;\n\t\trdev->config.evergreen.sx_num_of_sets = 4;\n\t\trdev->config.evergreen.sx_max_export_size = 128;\n\t\trdev->config.evergreen.sx_max_export_pos_size = 32;\n\t\trdev->config.evergreen.sx_max_export_smx_size = 96;\n\t\trdev->config.evergreen.max_hw_contexts = 4;\n\t\trdev->config.evergreen.sq_num_cf_insts = 1;\n\n\t\trdev->config.evergreen.sc_prim_fifo_size = 0x40;\n\t\trdev->config.evergreen.sc_hiz_tile_fifo_size = 0x30;\n\t\trdev->config.evergreen.sc_earlyz_tile_fifo_size = 0x130;\n\t\tgb_addr_config = CAICOS_GB_ADDR_CONFIG_GOLDEN;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\n\tWREG32(GRBM_CNTL, GRBM_READ_TIMEOUT(0xff));\n\tWREG32(SRBM_INT_CNTL, 0x1);\n\tWREG32(SRBM_INT_ACK, 0x1);\n\n\tevergreen_fix_pci_max_read_req_size(rdev);\n\n\tRREG32(MC_SHARED_CHMAP);\n\tif ((rdev->family == CHIP_PALM) ||\n\t    (rdev->family == CHIP_SUMO) ||\n\t    (rdev->family == CHIP_SUMO2))\n\t\tmc_arb_ramcfg = RREG32(FUS_MC_ARB_RAMCFG);\n\telse\n\t\tmc_arb_ramcfg = RREG32(MC_ARB_RAMCFG);\n\n\t \n\trdev->config.evergreen.tile_config = 0;\n\tswitch (rdev->config.evergreen.max_tile_pipes) {\n\tcase 1:\n\tdefault:\n\t\trdev->config.evergreen.tile_config |= (0 << 0);\n\t\tbreak;\n\tcase 2:\n\t\trdev->config.evergreen.tile_config |= (1 << 0);\n\t\tbreak;\n\tcase 4:\n\t\trdev->config.evergreen.tile_config |= (2 << 0);\n\t\tbreak;\n\tcase 8:\n\t\trdev->config.evergreen.tile_config |= (3 << 0);\n\t\tbreak;\n\t}\n\t \n\tif (rdev->flags & RADEON_IS_IGP)\n\t\trdev->config.evergreen.tile_config |= 1 << 4;\n\telse {\n\t\tswitch ((mc_arb_ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT) {\n\t\tcase 0:  \n\t\t\trdev->config.evergreen.tile_config |= 0 << 4;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\trdev->config.evergreen.tile_config |= 1 << 4;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\tdefault:\n\t\t\trdev->config.evergreen.tile_config |= 2 << 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\trdev->config.evergreen.tile_config |= 0 << 8;\n\trdev->config.evergreen.tile_config |=\n\t\t((gb_addr_config & 0x30000000) >> 28) << 12;\n\n\tif ((rdev->family >= CHIP_CEDAR) && (rdev->family <= CHIP_HEMLOCK)) {\n\t\tu32 efuse_straps_4;\n\t\tu32 efuse_straps_3;\n\n\t\tefuse_straps_4 = RREG32_RCU(0x204);\n\t\tefuse_straps_3 = RREG32_RCU(0x203);\n\t\ttmp = (((efuse_straps_4 & 0xf) << 4) |\n\t\t      ((efuse_straps_3 & 0xf0000000) >> 28));\n\t} else {\n\t\ttmp = 0;\n\t\tfor (i = (rdev->config.evergreen.num_ses - 1); i >= 0; i--) {\n\t\t\tu32 rb_disable_bitmap;\n\n\t\t\tWREG32(GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\t\tWREG32(RLC_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\t\trb_disable_bitmap = (RREG32(CC_RB_BACKEND_DISABLE) & 0x00ff0000) >> 16;\n\t\t\ttmp <<= 4;\n\t\t\ttmp |= rb_disable_bitmap;\n\t\t}\n\t}\n\t \n\tdisabled_rb_mask = tmp;\n\ttmp = 0;\n\tfor (i = 0; i < rdev->config.evergreen.max_backends; i++)\n\t\ttmp |= (1 << i);\n\t \n\tif ((disabled_rb_mask & tmp) == tmp) {\n\t\tfor (i = 0; i < rdev->config.evergreen.max_backends; i++)\n\t\t\tdisabled_rb_mask &= ~(1 << i);\n\t}\n\n\tfor (i = 0; i < rdev->config.evergreen.num_ses; i++) {\n\t\tu32 simd_disable_bitmap;\n\n\t\tWREG32(GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\tWREG32(RLC_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_INDEX(i));\n\t\tsimd_disable_bitmap = (RREG32(CC_GC_SHADER_PIPE_CONFIG) & 0xffff0000) >> 16;\n\t\tsimd_disable_bitmap |= 0xffffffff << rdev->config.evergreen.max_simds;\n\t\ttmp <<= 16;\n\t\ttmp |= simd_disable_bitmap;\n\t}\n\trdev->config.evergreen.active_simds = hweight32(~tmp);\n\n\tWREG32(GRBM_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_BROADCAST_WRITES);\n\tWREG32(RLC_GFX_INDEX, INSTANCE_BROADCAST_WRITES | SE_BROADCAST_WRITES);\n\n\tWREG32(GB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMIF_ADDR_CONFIG, gb_addr_config);\n\tWREG32(HDP_ADDR_CONFIG, gb_addr_config);\n\tWREG32(DMA_TILING_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_ADDR_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_DB_ADDR_CONFIG, gb_addr_config);\n\tWREG32(UVD_UDEC_DBW_ADDR_CONFIG, gb_addr_config);\n\n\tif ((rdev->config.evergreen.max_backends == 1) &&\n\t    (rdev->flags & RADEON_IS_IGP)) {\n\t\tif ((disabled_rb_mask & 3) == 1) {\n\t\t\t \n\t\t\ttmp = 0x11111111;\n\t\t} else {\n\t\t\t \n\t\t\ttmp = 0x00000000;\n\t\t}\n\t} else {\n\t\ttmp = gb_addr_config & NUM_PIPES_MASK;\n\t\ttmp = r6xx_remap_render_backend(rdev, tmp, rdev->config.evergreen.max_backends,\n\t\t\t\t\t\tEVERGREEN_MAX_BACKENDS, disabled_rb_mask);\n\t}\n\trdev->config.evergreen.backend_map = tmp;\n\tWREG32(GB_BACKEND_MAP, tmp);\n\n\tWREG32(CGTS_SYS_TCC_DISABLE, 0);\n\tWREG32(CGTS_TCC_DISABLE, 0);\n\tWREG32(CGTS_USER_SYS_TCC_DISABLE, 0);\n\tWREG32(CGTS_USER_TCC_DISABLE, 0);\n\n\t \n\tWREG32(CP_QUEUE_THRESHOLDS, (ROQ_IB1_START(0x16) |\n\t\t\t\t     ROQ_IB2_START(0x2b)));\n\n\tWREG32(CP_MEQ_THRESHOLDS, STQ_SPLIT(0x30));\n\n\tWREG32(TA_CNTL_AUX, (DISABLE_CUBE_ANISO |\n\t\t\t     SYNC_GRADIENT |\n\t\t\t     SYNC_WALKER |\n\t\t\t     SYNC_ALIGNER));\n\n\tsx_debug_1 = RREG32(SX_DEBUG_1);\n\tsx_debug_1 |= ENABLE_NEW_SMX_ADDRESS;\n\tWREG32(SX_DEBUG_1, sx_debug_1);\n\n\n\tsmx_dc_ctl0 = RREG32(SMX_DC_CTL0);\n\tsmx_dc_ctl0 &= ~NUMBER_OF_SETS(0x1ff);\n\tsmx_dc_ctl0 |= NUMBER_OF_SETS(rdev->config.evergreen.sx_num_of_sets);\n\tWREG32(SMX_DC_CTL0, smx_dc_ctl0);\n\n\tif (rdev->family <= CHIP_SUMO2)\n\t\tWREG32(SMX_SAR_CTL0, 0x00010000);\n\n\tWREG32(SX_EXPORT_BUFFER_SIZES, (COLOR_BUFFER_SIZE((rdev->config.evergreen.sx_max_export_size / 4) - 1) |\n\t\t\t\t\tPOSITION_BUFFER_SIZE((rdev->config.evergreen.sx_max_export_pos_size / 4) - 1) |\n\t\t\t\t\tSMX_BUFFER_SIZE((rdev->config.evergreen.sx_max_export_smx_size / 4) - 1)));\n\n\tWREG32(PA_SC_FIFO_SIZE, (SC_PRIM_FIFO_SIZE(rdev->config.evergreen.sc_prim_fifo_size) |\n\t\t\t\t SC_HIZ_TILE_FIFO_SIZE(rdev->config.evergreen.sc_hiz_tile_fifo_size) |\n\t\t\t\t SC_EARLYZ_TILE_FIFO_SIZE(rdev->config.evergreen.sc_earlyz_tile_fifo_size)));\n\n\tWREG32(VGT_NUM_INSTANCES, 1);\n\tWREG32(SPI_CONFIG_CNTL, 0);\n\tWREG32(SPI_CONFIG_CNTL_1, VTX_DONE_DELAY(4));\n\tWREG32(CP_PERFMON_CNTL, 0);\n\n\tWREG32(SQ_MS_FIFO_SIZES, (CACHE_FIFO_SIZE(16 * rdev->config.evergreen.sq_num_cf_insts) |\n\t\t\t\t  FETCH_FIFO_HIWATER(0x4) |\n\t\t\t\t  DONE_FIFO_HIWATER(0xe0) |\n\t\t\t\t  ALU_UPDATE_FIFO_HIWATER(0x8)));\n\n\tsq_config = RREG32(SQ_CONFIG);\n\tsq_config &= ~(PS_PRIO(3) |\n\t\t       VS_PRIO(3) |\n\t\t       GS_PRIO(3) |\n\t\t       ES_PRIO(3));\n\tsq_config |= (VC_ENABLE |\n\t\t      EXPORT_SRC_C |\n\t\t      PS_PRIO(0) |\n\t\t      VS_PRIO(1) |\n\t\t      GS_PRIO(2) |\n\t\t      ES_PRIO(3));\n\n\tswitch (rdev->family) {\n\tcase CHIP_CEDAR:\n\tcase CHIP_PALM:\n\tcase CHIP_SUMO:\n\tcase CHIP_SUMO2:\n\tcase CHIP_CAICOS:\n\t\t \n\t\tsq_config &= ~VC_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsq_lds_resource_mgmt = RREG32(SQ_LDS_RESOURCE_MGMT);\n\n\tsq_gpr_resource_mgmt_1 = NUM_PS_GPRS((rdev->config.evergreen.max_gprs - (4 * 2))* 12 / 32);\n\tsq_gpr_resource_mgmt_1 |= NUM_VS_GPRS((rdev->config.evergreen.max_gprs - (4 * 2)) * 6 / 32);\n\tsq_gpr_resource_mgmt_1 |= NUM_CLAUSE_TEMP_GPRS(4);\n\tsq_gpr_resource_mgmt_2 = NUM_GS_GPRS((rdev->config.evergreen.max_gprs - (4 * 2)) * 4 / 32);\n\tsq_gpr_resource_mgmt_2 |= NUM_ES_GPRS((rdev->config.evergreen.max_gprs - (4 * 2)) * 4 / 32);\n\tsq_gpr_resource_mgmt_3 = NUM_HS_GPRS((rdev->config.evergreen.max_gprs - (4 * 2)) * 3 / 32);\n\tsq_gpr_resource_mgmt_3 |= NUM_LS_GPRS((rdev->config.evergreen.max_gprs - (4 * 2)) * 3 / 32);\n\n\tswitch (rdev->family) {\n\tcase CHIP_CEDAR:\n\tcase CHIP_PALM:\n\tcase CHIP_SUMO:\n\tcase CHIP_SUMO2:\n\t\tps_thread_count = 96;\n\t\tbreak;\n\tdefault:\n\t\tps_thread_count = 128;\n\t\tbreak;\n\t}\n\n\tsq_thread_resource_mgmt = NUM_PS_THREADS(ps_thread_count);\n\tsq_thread_resource_mgmt |= NUM_VS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);\n\tsq_thread_resource_mgmt |= NUM_GS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);\n\tsq_thread_resource_mgmt |= NUM_ES_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);\n\tsq_thread_resource_mgmt_2 = NUM_HS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);\n\tsq_thread_resource_mgmt_2 |= NUM_LS_THREADS((((rdev->config.evergreen.max_threads - ps_thread_count) / 6) / 8) * 8);\n\n\tsq_stack_resource_mgmt_1 = NUM_PS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);\n\tsq_stack_resource_mgmt_1 |= NUM_VS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);\n\tsq_stack_resource_mgmt_2 = NUM_GS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);\n\tsq_stack_resource_mgmt_2 |= NUM_ES_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);\n\tsq_stack_resource_mgmt_3 = NUM_HS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);\n\tsq_stack_resource_mgmt_3 |= NUM_LS_STACK_ENTRIES((rdev->config.evergreen.max_stack_entries * 1) / 6);\n\n\tWREG32(SQ_CONFIG, sq_config);\n\tWREG32(SQ_GPR_RESOURCE_MGMT_1, sq_gpr_resource_mgmt_1);\n\tWREG32(SQ_GPR_RESOURCE_MGMT_2, sq_gpr_resource_mgmt_2);\n\tWREG32(SQ_GPR_RESOURCE_MGMT_3, sq_gpr_resource_mgmt_3);\n\tWREG32(SQ_THREAD_RESOURCE_MGMT, sq_thread_resource_mgmt);\n\tWREG32(SQ_THREAD_RESOURCE_MGMT_2, sq_thread_resource_mgmt_2);\n\tWREG32(SQ_STACK_RESOURCE_MGMT_1, sq_stack_resource_mgmt_1);\n\tWREG32(SQ_STACK_RESOURCE_MGMT_2, sq_stack_resource_mgmt_2);\n\tWREG32(SQ_STACK_RESOURCE_MGMT_3, sq_stack_resource_mgmt_3);\n\tWREG32(SQ_DYN_GPR_CNTL_PS_FLUSH_REQ, 0);\n\tWREG32(SQ_LDS_RESOURCE_MGMT, sq_lds_resource_mgmt);\n\n\tWREG32(PA_SC_FORCE_EOV_MAX_CNTS, (FORCE_EOV_MAX_CLK_CNT(4095) |\n\t\t\t\t\t  FORCE_EOV_MAX_REZ_CNT(255)));\n\n\tswitch (rdev->family) {\n\tcase CHIP_CEDAR:\n\tcase CHIP_PALM:\n\tcase CHIP_SUMO:\n\tcase CHIP_SUMO2:\n\tcase CHIP_CAICOS:\n\t\tvgt_cache_invalidation = CACHE_INVALIDATION(TC_ONLY);\n\t\tbreak;\n\tdefault:\n\t\tvgt_cache_invalidation = CACHE_INVALIDATION(VC_AND_TC);\n\t\tbreak;\n\t}\n\tvgt_cache_invalidation |= AUTO_INVLD_EN(ES_AND_GS_AUTO);\n\tWREG32(VGT_CACHE_INVALIDATION, vgt_cache_invalidation);\n\n\tWREG32(VGT_GS_VERTEX_REUSE, 16);\n\tWREG32(PA_SU_LINE_STIPPLE_VALUE, 0);\n\tWREG32(PA_SC_LINE_STIPPLE_STATE, 0);\n\n\tWREG32(VGT_VERTEX_REUSE_BLOCK_CNTL, 14);\n\tWREG32(VGT_OUT_DEALLOC_CNTL, 16);\n\n\tWREG32(CB_PERF_CTR0_SEL_0, 0);\n\tWREG32(CB_PERF_CTR0_SEL_1, 0);\n\tWREG32(CB_PERF_CTR1_SEL_0, 0);\n\tWREG32(CB_PERF_CTR1_SEL_1, 0);\n\tWREG32(CB_PERF_CTR2_SEL_0, 0);\n\tWREG32(CB_PERF_CTR2_SEL_1, 0);\n\tWREG32(CB_PERF_CTR3_SEL_0, 0);\n\tWREG32(CB_PERF_CTR3_SEL_1, 0);\n\n\t \n\tWREG32(CB_COLOR0_BASE, 0);\n\tWREG32(CB_COLOR1_BASE, 0);\n\tWREG32(CB_COLOR2_BASE, 0);\n\tWREG32(CB_COLOR3_BASE, 0);\n\tWREG32(CB_COLOR4_BASE, 0);\n\tWREG32(CB_COLOR5_BASE, 0);\n\tWREG32(CB_COLOR6_BASE, 0);\n\tWREG32(CB_COLOR7_BASE, 0);\n\tWREG32(CB_COLOR8_BASE, 0);\n\tWREG32(CB_COLOR9_BASE, 0);\n\tWREG32(CB_COLOR10_BASE, 0);\n\tWREG32(CB_COLOR11_BASE, 0);\n\n\t \n\tfor (i = SQ_ALU_CONST_BUFFER_SIZE_PS_0; i < 0x28200; i += 4)\n\t\tWREG32(i, 0);\n\tfor (i = SQ_ALU_CONST_BUFFER_SIZE_HS_0; i < 0x29000; i += 4)\n\t\tWREG32(i, 0);\n\n\ttmp = RREG32(HDP_MISC_CNTL);\n\ttmp |= HDP_FLUSH_INVALIDATE_CACHE;\n\tWREG32(HDP_MISC_CNTL, tmp);\n\n\thdp_host_path_cntl = RREG32(HDP_HOST_PATH_CNTL);\n\tWREG32(HDP_HOST_PATH_CNTL, hdp_host_path_cntl);\n\n\tWREG32(PA_CL_ENHANCE, CLIP_VTX_REORDER_ENA | NUM_CLIP_SEQ(3));\n\n\tudelay(50);\n\n}\n\nint evergreen_mc_init(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint chansize, numchan;\n\n\t \n\trdev->mc.vram_is_ddr = true;\n\tif ((rdev->family == CHIP_PALM) ||\n\t    (rdev->family == CHIP_SUMO) ||\n\t    (rdev->family == CHIP_SUMO2))\n\t\ttmp = RREG32(FUS_MC_ARB_RAMCFG);\n\telse\n\t\ttmp = RREG32(MC_ARB_RAMCFG);\n\tif (tmp & CHANSIZE_OVERRIDE) {\n\t\tchansize = 16;\n\t} else if (tmp & CHANSIZE_MASK) {\n\t\tchansize = 64;\n\t} else {\n\t\tchansize = 32;\n\t}\n\ttmp = RREG32(MC_SHARED_CHMAP);\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\tnumchan = 1;\n\t\tbreak;\n\tcase 1:\n\t\tnumchan = 2;\n\t\tbreak;\n\tcase 2:\n\t\tnumchan = 4;\n\t\tbreak;\n\tcase 3:\n\t\tnumchan = 8;\n\t\tbreak;\n\t}\n\trdev->mc.vram_width = numchan * chansize;\n\t \n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\t \n\tif ((rdev->family == CHIP_PALM) ||\n\t    (rdev->family == CHIP_SUMO) ||\n\t    (rdev->family == CHIP_SUMO2)) {\n\t\t \n\t\trdev->mc.mc_vram_size = RREG32(CONFIG_MEMSIZE);\n\t\trdev->mc.real_vram_size = RREG32(CONFIG_MEMSIZE);\n\t} else {\n\t\t \n\t\trdev->mc.mc_vram_size = RREG32(CONFIG_MEMSIZE) * 1024ULL * 1024ULL;\n\t\trdev->mc.real_vram_size = RREG32(CONFIG_MEMSIZE) * 1024ULL * 1024ULL;\n\t}\n\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\tr700_vram_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n\n\treturn 0;\n}\n\nvoid evergreen_print_gpu_status_regs(struct radeon_device *rdev)\n{\n\tdev_info(rdev->dev, \"  GRBM_STATUS               = 0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS));\n\tdev_info(rdev->dev, \"  GRBM_STATUS_SE0           = 0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS_SE0));\n\tdev_info(rdev->dev, \"  GRBM_STATUS_SE1           = 0x%08X\\n\",\n\t\tRREG32(GRBM_STATUS_SE1));\n\tdev_info(rdev->dev, \"  SRBM_STATUS               = 0x%08X\\n\",\n\t\tRREG32(SRBM_STATUS));\n\tdev_info(rdev->dev, \"  SRBM_STATUS2              = 0x%08X\\n\",\n\t\tRREG32(SRBM_STATUS2));\n\tdev_info(rdev->dev, \"  R_008674_CP_STALLED_STAT1 = 0x%08X\\n\",\n\t\tRREG32(CP_STALLED_STAT1));\n\tdev_info(rdev->dev, \"  R_008678_CP_STALLED_STAT2 = 0x%08X\\n\",\n\t\tRREG32(CP_STALLED_STAT2));\n\tdev_info(rdev->dev, \"  R_00867C_CP_BUSY_STAT     = 0x%08X\\n\",\n\t\tRREG32(CP_BUSY_STAT));\n\tdev_info(rdev->dev, \"  R_008680_CP_STAT          = 0x%08X\\n\",\n\t\tRREG32(CP_STAT));\n\tdev_info(rdev->dev, \"  R_00D034_DMA_STATUS_REG   = 0x%08X\\n\",\n\t\tRREG32(DMA_STATUS_REG));\n\tif (rdev->family >= CHIP_CAYMAN) {\n\t\tdev_info(rdev->dev, \"  R_00D834_DMA_STATUS_REG   = 0x%08X\\n\",\n\t\t\t RREG32(DMA_STATUS_REG + 0x800));\n\t}\n}\n\nbool evergreen_is_display_hung(struct radeon_device *rdev)\n{\n\tu32 crtc_hung = 0;\n\tu32 crtc_status[6];\n\tu32 i, j, tmp;\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (RREG32(EVERGREEN_CRTC_CONTROL + crtc_offsets[i]) & EVERGREEN_CRTC_MASTER_EN) {\n\t\t\tcrtc_status[i] = RREG32(EVERGREEN_CRTC_STATUS_HV_COUNT + crtc_offsets[i]);\n\t\t\tcrtc_hung |= (1 << i);\n\t\t}\n\t}\n\n\tfor (j = 0; j < 10; j++) {\n\t\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\t\tif (crtc_hung & (1 << i)) {\n\t\t\t\ttmp = RREG32(EVERGREEN_CRTC_STATUS_HV_COUNT + crtc_offsets[i]);\n\t\t\t\tif (tmp != crtc_status[i])\n\t\t\t\t\tcrtc_hung &= ~(1 << i);\n\t\t\t}\n\t\t}\n\t\tif (crtc_hung == 0)\n\t\t\treturn false;\n\t\tudelay(100);\n\t}\n\n\treturn true;\n}\n\nu32 evergreen_gpu_check_soft_reset(struct radeon_device *rdev)\n{\n\tu32 reset_mask = 0;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(GRBM_STATUS);\n\tif (tmp & (PA_BUSY | SC_BUSY |\n\t\t   SH_BUSY | SX_BUSY |\n\t\t   TA_BUSY | VGT_BUSY |\n\t\t   DB_BUSY | CB_BUSY |\n\t\t   SPI_BUSY | VGT_BUSY_NO_DMA))\n\t\treset_mask |= RADEON_RESET_GFX;\n\n\tif (tmp & (CF_RQ_PENDING | PF_RQ_PENDING |\n\t\t   CP_BUSY | CP_COHERENCY_BUSY))\n\t\treset_mask |= RADEON_RESET_CP;\n\n\tif (tmp & GRBM_EE_BUSY)\n\t\treset_mask |= RADEON_RESET_GRBM | RADEON_RESET_GFX | RADEON_RESET_CP;\n\n\t \n\ttmp = RREG32(DMA_STATUS_REG);\n\tif (!(tmp & DMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\t \n\ttmp = RREG32(SRBM_STATUS2);\n\tif (tmp & DMA_BUSY)\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\t \n\ttmp = RREG32(SRBM_STATUS);\n\tif (tmp & (RLC_RQ_PENDING | RLC_BUSY))\n\t\treset_mask |= RADEON_RESET_RLC;\n\n\tif (tmp & IH_BUSY)\n\t\treset_mask |= RADEON_RESET_IH;\n\n\tif (tmp & SEM_BUSY)\n\t\treset_mask |= RADEON_RESET_SEM;\n\n\tif (tmp & GRBM_RQ_PENDING)\n\t\treset_mask |= RADEON_RESET_GRBM;\n\n\tif (tmp & VMC_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\tif (tmp & (MCB_BUSY | MCB_NON_DISPLAY_BUSY |\n\t\t   MCC_BUSY | MCD_BUSY))\n\t\treset_mask |= RADEON_RESET_MC;\n\n\tif (evergreen_is_display_hung(rdev))\n\t\treset_mask |= RADEON_RESET_DISPLAY;\n\n\t \n\ttmp = RREG32(VM_L2_STATUS);\n\tif (tmp & L2_BUSY)\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\t \n\tif (reset_mask & RADEON_RESET_MC) {\n\t\tDRM_DEBUG(\"MC busy: 0x%08X, clearing.\\n\", reset_mask);\n\t\treset_mask &= ~RADEON_RESET_MC;\n\t}\n\n\treturn reset_mask;\n}\n\nstatic void evergreen_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)\n{\n\tstruct evergreen_mc_save save;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif (reset_mask == 0)\n\t\treturn;\n\n\tdev_info(rdev->dev, \"GPU softreset: 0x%08X\\n\", reset_mask);\n\n\tevergreen_print_gpu_status_regs(rdev);\n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT);\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\t \n\t\ttmp = RREG32(DMA_RB_CNTL);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL, tmp);\n\t}\n\n\tudelay(50);\n\n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\n\tif (reset_mask & (RADEON_RESET_GFX | RADEON_RESET_COMPUTE)) {\n\t\tgrbm_soft_reset |= SOFT_RESET_DB |\n\t\t\tSOFT_RESET_CB |\n\t\t\tSOFT_RESET_PA |\n\t\t\tSOFT_RESET_SC |\n\t\t\tSOFT_RESET_SPI |\n\t\t\tSOFT_RESET_SX |\n\t\t\tSOFT_RESET_SH |\n\t\t\tSOFT_RESET_TC |\n\t\t\tSOFT_RESET_TA |\n\t\t\tSOFT_RESET_VC |\n\t\t\tSOFT_RESET_VGT;\n\t}\n\n\tif (reset_mask & RADEON_RESET_CP) {\n\t\tgrbm_soft_reset |= SOFT_RESET_CP |\n\t\t\tSOFT_RESET_VGT;\n\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA)\n\t\tsrbm_soft_reset |= SOFT_RESET_DMA;\n\n\tif (reset_mask & RADEON_RESET_DISPLAY)\n\t\tsrbm_soft_reset |= SOFT_RESET_DC;\n\n\tif (reset_mask & RADEON_RESET_RLC)\n\t\tsrbm_soft_reset |= SOFT_RESET_RLC;\n\n\tif (reset_mask & RADEON_RESET_SEM)\n\t\tsrbm_soft_reset |= SOFT_RESET_SEM;\n\n\tif (reset_mask & RADEON_RESET_IH)\n\t\tsrbm_soft_reset |= SOFT_RESET_IH;\n\n\tif (reset_mask & RADEON_RESET_GRBM)\n\t\tsrbm_soft_reset |= SOFT_RESET_GRBM;\n\n\tif (reset_mask & RADEON_RESET_VMC)\n\t\tsrbm_soft_reset |= SOFT_RESET_VMC;\n\n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tif (reset_mask & RADEON_RESET_MC)\n\t\t\tsrbm_soft_reset |= SOFT_RESET_MC;\n\t}\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(rdev->dev, \"GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(GRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(rdev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t}\n\n\t \n\tudelay(50);\n\n\tevergreen_mc_resume(rdev, &save);\n\tudelay(50);\n\n\tevergreen_print_gpu_status_regs(rdev);\n}\n\nvoid evergreen_gpu_pci_config_reset(struct radeon_device *rdev)\n{\n\tstruct evergreen_mc_save save;\n\tu32 tmp, i;\n\n\tdev_info(rdev->dev, \"GPU pci config reset\\n\");\n\n\t \n\n\t \n\tWREG32(CP_ME_CNTL, CP_ME_HALT | CP_PFP_HALT);\n\tudelay(50);\n\t \n\ttmp = RREG32(DMA_RB_CNTL);\n\ttmp &= ~DMA_RB_ENABLE;\n\tWREG32(DMA_RB_CNTL, tmp);\n\t \n\n\t \n\tr600_rlc_stop(rdev);\n\n\tudelay(50);\n\n\t \n\trv770_set_clk_bypass_mode(rdev);\n\t \n\tpci_clear_master(rdev->pdev);\n\t \n\tevergreen_mc_stop(rdev, &save);\n\tif (evergreen_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timed out !\\n\");\n\t}\n\t \n\tradeon_pci_config_reset(rdev);\n\t \n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(CONFIG_MEMSIZE) != 0xffffffff)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nint evergreen_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tu32 reset_mask;\n\n\tif (hard) {\n\t\tevergreen_gpu_pci_config_reset(rdev);\n\t\treturn 0;\n\t}\n\n\treset_mask = evergreen_gpu_check_soft_reset(rdev);\n\n\tif (reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, true);\n\n\t \n\tevergreen_gpu_soft_reset(rdev, reset_mask);\n\n\treset_mask = evergreen_gpu_check_soft_reset(rdev);\n\n\t \n\tif (reset_mask && radeon_hard_reset)\n\t\tevergreen_gpu_pci_config_reset(rdev);\n\n\treset_mask = evergreen_gpu_check_soft_reset(rdev);\n\n\tif (!reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, false);\n\n\treturn 0;\n}\n\n \nbool evergreen_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = evergreen_gpu_check_soft_reset(rdev);\n\n\tif (!(reset_mask & (RADEON_RESET_GFX |\n\t\t\t    RADEON_RESET_COMPUTE |\n\t\t\t    RADEON_RESET_CP))) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\n \n#define RLC_SAVE_RESTORE_LIST_END_MARKER    0x00000000\n#define RLC_CLEAR_STATE_END_MARKER          0x00000001\n\nvoid sumo_rlc_fini(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (rdev->rlc.save_restore_obj) {\n\t\tr = radeon_bo_reserve(rdev->rlc.save_restore_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tdev_warn(rdev->dev, \"(%d) reserve RLC sr bo failed\\n\", r);\n\t\tradeon_bo_unpin(rdev->rlc.save_restore_obj);\n\t\tradeon_bo_unreserve(rdev->rlc.save_restore_obj);\n\n\t\tradeon_bo_unref(&rdev->rlc.save_restore_obj);\n\t\trdev->rlc.save_restore_obj = NULL;\n\t}\n\n\t \n\tif (rdev->rlc.clear_state_obj) {\n\t\tr = radeon_bo_reserve(rdev->rlc.clear_state_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tdev_warn(rdev->dev, \"(%d) reserve RLC c bo failed\\n\", r);\n\t\tradeon_bo_unpin(rdev->rlc.clear_state_obj);\n\t\tradeon_bo_unreserve(rdev->rlc.clear_state_obj);\n\n\t\tradeon_bo_unref(&rdev->rlc.clear_state_obj);\n\t\trdev->rlc.clear_state_obj = NULL;\n\t}\n\n\t \n\tif (rdev->rlc.cp_table_obj) {\n\t\tr = radeon_bo_reserve(rdev->rlc.cp_table_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\tdev_warn(rdev->dev, \"(%d) reserve RLC cp table bo failed\\n\", r);\n\t\tradeon_bo_unpin(rdev->rlc.cp_table_obj);\n\t\tradeon_bo_unreserve(rdev->rlc.cp_table_obj);\n\n\t\tradeon_bo_unref(&rdev->rlc.cp_table_obj);\n\t\trdev->rlc.cp_table_obj = NULL;\n\t}\n}\n\n#define CP_ME_TABLE_SIZE    96\n\nint sumo_rlc_init(struct radeon_device *rdev)\n{\n\tconst u32 *src_ptr;\n\tvolatile u32 *dst_ptr;\n\tu32 dws, data, i, j, k, reg_num;\n\tu32 reg_list_num, reg_list_hdr_blk_index, reg_list_blk_index = 0;\n\tu64 reg_list_mc_addr;\n\tconst struct cs_section_def *cs_data;\n\tint r;\n\n\tsrc_ptr = rdev->rlc.reg_list;\n\tdws = rdev->rlc.reg_list_size;\n\tif (rdev->family >= CHIP_BONAIRE) {\n\t\tdws += (5 * 16) + 48 + 48 + 64;\n\t}\n\tcs_data = rdev->rlc.cs_data;\n\n\tif (src_ptr) {\n\t\t \n\t\tif (rdev->rlc.save_restore_obj == NULL) {\n\t\t\tr = radeon_bo_create(rdev, dws * 4, PAGE_SIZE, true,\n\t\t\t\t\t     RADEON_GEM_DOMAIN_VRAM, 0, NULL,\n\t\t\t\t\t     NULL, &rdev->rlc.save_restore_obj);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(rdev->dev, \"(%d) create RLC sr bo failed\\n\", r);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tr = radeon_bo_reserve(rdev->rlc.save_restore_obj, false);\n\t\tif (unlikely(r != 0)) {\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_pin(rdev->rlc.save_restore_obj, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t  &rdev->rlc.save_restore_gpu_addr);\n\t\tif (r) {\n\t\t\tradeon_bo_unreserve(rdev->rlc.save_restore_obj);\n\t\t\tdev_warn(rdev->dev, \"(%d) pin RLC sr bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = radeon_bo_kmap(rdev->rlc.save_restore_obj, (void **)&rdev->rlc.sr_ptr);\n\t\tif (r) {\n\t\t\tdev_warn(rdev->dev, \"(%d) map RLC sr bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\t \n\t\tdst_ptr = rdev->rlc.sr_ptr;\n\t\tif (rdev->family >= CHIP_TAHITI) {\n\t\t\t \n\t\t\tfor (i = 0; i < rdev->rlc.reg_list_size; i++)\n\t\t\t\tdst_ptr[i] = cpu_to_le32(src_ptr[i]);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tfor (i = 0; i < dws; i++) {\n\t\t\t\tdata = src_ptr[i] >> 2;\n\t\t\t\ti++;\n\t\t\t\tif (i < dws)\n\t\t\t\t\tdata |= (src_ptr[i] >> 2) << 16;\n\t\t\t\tj = (((i - 1) * 3) / 2);\n\t\t\t\tdst_ptr[j] = cpu_to_le32(data);\n\t\t\t}\n\t\t\tj = ((i * 3) / 2);\n\t\t\tdst_ptr[j] = cpu_to_le32(RLC_SAVE_RESTORE_LIST_END_MARKER);\n\t\t}\n\t\tradeon_bo_kunmap(rdev->rlc.save_restore_obj);\n\t\tradeon_bo_unreserve(rdev->rlc.save_restore_obj);\n\t}\n\n\tif (cs_data) {\n\t\t \n\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\trdev->rlc.clear_state_size = dws = cik_get_csb_size(rdev);\n\t\t} else if (rdev->family >= CHIP_TAHITI) {\n\t\t\trdev->rlc.clear_state_size = si_get_csb_size(rdev);\n\t\t\tdws = rdev->rlc.clear_state_size + (256 / 4);\n\t\t} else {\n\t\t\treg_list_num = 0;\n\t\t\tdws = 0;\n\t\t\tfor (i = 0; cs_data[i].section != NULL; i++) {\n\t\t\t\tfor (j = 0; cs_data[i].section[j].extent != NULL; j++) {\n\t\t\t\t\treg_list_num++;\n\t\t\t\t\tdws += cs_data[i].section[j].reg_count;\n\t\t\t\t}\n\t\t\t}\n\t\t\treg_list_blk_index = (3 * reg_list_num + 2);\n\t\t\tdws += reg_list_blk_index;\n\t\t\trdev->rlc.clear_state_size = dws;\n\t\t}\n\n\t\tif (rdev->rlc.clear_state_obj == NULL) {\n\t\t\tr = radeon_bo_create(rdev, dws * 4, PAGE_SIZE, true,\n\t\t\t\t\t     RADEON_GEM_DOMAIN_VRAM, 0, NULL,\n\t\t\t\t\t     NULL, &rdev->rlc.clear_state_obj);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(rdev->dev, \"(%d) create RLC c bo failed\\n\", r);\n\t\t\t\tsumo_rlc_fini(rdev);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\tr = radeon_bo_reserve(rdev->rlc.clear_state_obj, false);\n\t\tif (unlikely(r != 0)) {\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_pin(rdev->rlc.clear_state_obj, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t  &rdev->rlc.clear_state_gpu_addr);\n\t\tif (r) {\n\t\t\tradeon_bo_unreserve(rdev->rlc.clear_state_obj);\n\t\t\tdev_warn(rdev->dev, \"(%d) pin RLC c bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\n\t\tr = radeon_bo_kmap(rdev->rlc.clear_state_obj, (void **)&rdev->rlc.cs_ptr);\n\t\tif (r) {\n\t\t\tdev_warn(rdev->dev, \"(%d) map RLC c bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\t \n\t\tdst_ptr = rdev->rlc.cs_ptr;\n\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\tcik_get_csb_buffer(rdev, dst_ptr);\n\t\t} else if (rdev->family >= CHIP_TAHITI) {\n\t\t\treg_list_mc_addr = rdev->rlc.clear_state_gpu_addr + 256;\n\t\t\tdst_ptr[0] = cpu_to_le32(upper_32_bits(reg_list_mc_addr));\n\t\t\tdst_ptr[1] = cpu_to_le32(lower_32_bits(reg_list_mc_addr));\n\t\t\tdst_ptr[2] = cpu_to_le32(rdev->rlc.clear_state_size);\n\t\t\tsi_get_csb_buffer(rdev, &dst_ptr[(256/4)]);\n\t\t} else {\n\t\t\treg_list_hdr_blk_index = 0;\n\t\t\treg_list_mc_addr = rdev->rlc.clear_state_gpu_addr + (reg_list_blk_index * 4);\n\t\t\tdata = upper_32_bits(reg_list_mc_addr);\n\t\t\tdst_ptr[reg_list_hdr_blk_index] = cpu_to_le32(data);\n\t\t\treg_list_hdr_blk_index++;\n\t\t\tfor (i = 0; cs_data[i].section != NULL; i++) {\n\t\t\t\tfor (j = 0; cs_data[i].section[j].extent != NULL; j++) {\n\t\t\t\t\treg_num = cs_data[i].section[j].reg_count;\n\t\t\t\t\tdata = reg_list_mc_addr & 0xffffffff;\n\t\t\t\t\tdst_ptr[reg_list_hdr_blk_index] = cpu_to_le32(data);\n\t\t\t\t\treg_list_hdr_blk_index++;\n\n\t\t\t\t\tdata = (cs_data[i].section[j].reg_index * 4) & 0xffffffff;\n\t\t\t\t\tdst_ptr[reg_list_hdr_blk_index] = cpu_to_le32(data);\n\t\t\t\t\treg_list_hdr_blk_index++;\n\n\t\t\t\t\tdata = 0x08000000 | (reg_num * 4);\n\t\t\t\t\tdst_ptr[reg_list_hdr_blk_index] = cpu_to_le32(data);\n\t\t\t\t\treg_list_hdr_blk_index++;\n\n\t\t\t\t\tfor (k = 0; k < reg_num; k++) {\n\t\t\t\t\t\tdata = cs_data[i].section[j].extent[k];\n\t\t\t\t\t\tdst_ptr[reg_list_blk_index + k] = cpu_to_le32(data);\n\t\t\t\t\t}\n\t\t\t\t\treg_list_mc_addr += reg_num * 4;\n\t\t\t\t\treg_list_blk_index += reg_num;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst_ptr[reg_list_hdr_blk_index] = cpu_to_le32(RLC_CLEAR_STATE_END_MARKER);\n\t\t}\n\t\tradeon_bo_kunmap(rdev->rlc.clear_state_obj);\n\t\tradeon_bo_unreserve(rdev->rlc.clear_state_obj);\n\t}\n\n\tif (rdev->rlc.cp_table_size) {\n\t\tif (rdev->rlc.cp_table_obj == NULL) {\n\t\t\tr = radeon_bo_create(rdev, rdev->rlc.cp_table_size,\n\t\t\t\t\t     PAGE_SIZE, true,\n\t\t\t\t\t     RADEON_GEM_DOMAIN_VRAM, 0, NULL,\n\t\t\t\t\t     NULL, &rdev->rlc.cp_table_obj);\n\t\t\tif (r) {\n\t\t\t\tdev_warn(rdev->dev, \"(%d) create RLC cp table bo failed\\n\", r);\n\t\t\t\tsumo_rlc_fini(rdev);\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\n\t\tr = radeon_bo_reserve(rdev->rlc.cp_table_obj, false);\n\t\tif (unlikely(r != 0)) {\n\t\t\tdev_warn(rdev->dev, \"(%d) reserve RLC cp table bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_pin(rdev->rlc.cp_table_obj, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t  &rdev->rlc.cp_table_gpu_addr);\n\t\tif (r) {\n\t\t\tradeon_bo_unreserve(rdev->rlc.cp_table_obj);\n\t\t\tdev_warn(rdev->dev, \"(%d) pin RLC cp_table bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_kmap(rdev->rlc.cp_table_obj, (void **)&rdev->rlc.cp_table_ptr);\n\t\tif (r) {\n\t\t\tdev_warn(rdev->dev, \"(%d) map RLC cp table bo failed\\n\", r);\n\t\t\tsumo_rlc_fini(rdev);\n\t\t\treturn r;\n\t\t}\n\n\t\tcik_init_cp_pg_table(rdev);\n\n\t\tradeon_bo_kunmap(rdev->rlc.cp_table_obj);\n\t\tradeon_bo_unreserve(rdev->rlc.cp_table_obj);\n\n\t}\n\n\treturn 0;\n}\n\nstatic void evergreen_rlc_start(struct radeon_device *rdev)\n{\n\tu32 mask = RLC_ENABLE;\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tmask |= GFX_POWER_GATING_ENABLE | GFX_POWER_GATING_SRC;\n\t}\n\n\tWREG32(RLC_CNTL, mask);\n}\n\nint evergreen_rlc_resume(struct radeon_device *rdev)\n{\n\tu32 i;\n\tconst __be32 *fw_data;\n\n\tif (!rdev->rlc_fw)\n\t\treturn -EINVAL;\n\n\tr600_rlc_stop(rdev);\n\n\tWREG32(RLC_HB_CNTL, 0);\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tif (rdev->family == CHIP_ARUBA) {\n\t\t\tu32 always_on_bitmap =\n\t\t\t\t3 | (3 << (16 * rdev->config.cayman.max_shader_engines));\n\t\t\t \n\t\t\tu32 tmp = (RREG32(CC_GC_SHADER_PIPE_CONFIG) & 0xffff0000) >> 16;\n\t\t\ttmp |= 0xffffffff << rdev->config.cayman.max_simds_per_se;\n\t\t\ttmp = hweight32(~tmp);\n\t\t\tif (tmp == rdev->config.cayman.max_simds_per_se) {\n\t\t\t\tWREG32(TN_RLC_LB_ALWAYS_ACTIVE_SIMD_MASK, always_on_bitmap);\n\t\t\t\tWREG32(TN_RLC_LB_PARAMS, 0x00601004);\n\t\t\t\tWREG32(TN_RLC_LB_INIT_SIMD_MASK, 0xffffffff);\n\t\t\t\tWREG32(TN_RLC_LB_CNTR_INIT, 0x00000000);\n\t\t\t\tWREG32(TN_RLC_LB_CNTR_MAX, 0x00002000);\n\t\t\t}\n\t\t} else {\n\t\t\tWREG32(RLC_HB_WPTR_LSB_ADDR, 0);\n\t\t\tWREG32(RLC_HB_WPTR_MSB_ADDR, 0);\n\t\t}\n\t\tWREG32(TN_RLC_SAVE_AND_RESTORE_BASE, rdev->rlc.save_restore_gpu_addr >> 8);\n\t\tWREG32(TN_RLC_CLEAR_STATE_RESTORE_BASE, rdev->rlc.clear_state_gpu_addr >> 8);\n\t} else {\n\t\tWREG32(RLC_HB_BASE, 0);\n\t\tWREG32(RLC_HB_RPTR, 0);\n\t\tWREG32(RLC_HB_WPTR, 0);\n\t\tWREG32(RLC_HB_WPTR_LSB_ADDR, 0);\n\t\tWREG32(RLC_HB_WPTR_MSB_ADDR, 0);\n\t}\n\tWREG32(RLC_MC_CNTL, 0);\n\tWREG32(RLC_UCODE_CNTL, 0);\n\n\tfw_data = (const __be32 *)rdev->rlc_fw->data;\n\tif (rdev->family >= CHIP_ARUBA) {\n\t\tfor (i = 0; i < ARUBA_RLC_UCODE_SIZE; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t}\n\t} else if (rdev->family >= CHIP_CAYMAN) {\n\t\tfor (i = 0; i < CAYMAN_RLC_UCODE_SIZE; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < EVERGREEN_RLC_UCODE_SIZE; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t}\n\t}\n\tWREG32(RLC_UCODE_ADDR, 0);\n\n\tevergreen_rlc_start(rdev);\n\n\treturn 0;\n}\n\n \n\nu32 evergreen_get_vblank_counter(struct radeon_device *rdev, int crtc)\n{\n\tif (crtc >= rdev->num_crtc)\n\t\treturn 0;\n\telse\n\t\treturn RREG32(CRTC_STATUS_FRAME_COUNT + crtc_offsets[crtc]);\n}\n\nvoid evergreen_disable_interrupt_state(struct radeon_device *rdev)\n{\n\tint i;\n\tu32 tmp;\n\n\tif (rdev->family >= CHIP_CAYMAN) {\n\t\tcayman_cp_int_cntl_setup(rdev, 0,\n\t\t\t\t\t CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\t\tcayman_cp_int_cntl_setup(rdev, 1, 0);\n\t\tcayman_cp_int_cntl_setup(rdev, 2, 0);\n\t\ttmp = RREG32(CAYMAN_DMA1_CNTL) & ~TRAP_ENABLE;\n\t\tWREG32(CAYMAN_DMA1_CNTL, tmp);\n\t} else\n\t\tWREG32(CP_INT_CNTL, CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\ttmp = RREG32(DMA_CNTL) & ~TRAP_ENABLE;\n\tWREG32(DMA_CNTL, tmp);\n\tWREG32(GRBM_INT_CNTL, 0);\n\tWREG32(SRBM_INT_CNTL, 0);\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tWREG32(INT_MASK + crtc_offsets[i], 0);\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tWREG32(GRPH_INT_CONTROL + crtc_offsets[i], 0);\n\n\t \n\tif (!ASIC_IS_DCE5(rdev))\n\t\tWREG32(DACA_AUTODETECT_INT_CONTROL, 0);\n\tWREG32(DACB_AUTODETECT_INT_CONTROL, 0);\n\n\tfor (i = 0; i < 6; i++)\n\t\tWREG32_AND(DC_HPDx_INT_CONTROL(i), DC_HPDx_INT_POLARITY);\n}\n\n \nint evergreen_irq_set(struct radeon_device *rdev)\n{\n\tint i;\n\tu32 cp_int_cntl = CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE;\n\tu32 cp_int_cntl1 = 0, cp_int_cntl2 = 0;\n\tu32 grbm_int_cntl = 0;\n\tu32 dma_cntl, dma_cntl1 = 0;\n\tu32 thermal_int = 0;\n\n\tif (!rdev->irq.installed) {\n\t\tWARN(1, \"Can't enable IRQ/MSI because no handler is installed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->ih.enabled) {\n\t\tr600_disable_interrupts(rdev);\n\t\t \n\t\tevergreen_disable_interrupt_state(rdev);\n\t\treturn 0;\n\t}\n\n\tif (rdev->family == CHIP_ARUBA)\n\t\tthermal_int = RREG32(TN_CG_THERMAL_INT_CTRL) &\n\t\t\t~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\n\telse\n\t\tthermal_int = RREG32(CG_THERMAL_INT) &\n\t\t\t~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\n\n\tdma_cntl = RREG32(DMA_CNTL) & ~TRAP_ENABLE;\n\n\tif (rdev->family >= CHIP_CAYMAN) {\n\t\t \n\t\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\t\tDRM_DEBUG(\"evergreen_irq_set: sw int gfx\\n\");\n\t\t\tcp_int_cntl |= TIME_STAMP_INT_ENABLE;\n\t\t}\n\t\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_CP1_INDEX])) {\n\t\t\tDRM_DEBUG(\"evergreen_irq_set: sw int cp1\\n\");\n\t\t\tcp_int_cntl1 |= TIME_STAMP_INT_ENABLE;\n\t\t}\n\t\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_CP2_INDEX])) {\n\t\t\tDRM_DEBUG(\"evergreen_irq_set: sw int cp2\\n\");\n\t\t\tcp_int_cntl2 |= TIME_STAMP_INT_ENABLE;\n\t\t}\n\t} else {\n\t\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\t\tDRM_DEBUG(\"evergreen_irq_set: sw int gfx\\n\");\n\t\t\tcp_int_cntl |= RB_INT_ENABLE;\n\t\t\tcp_int_cntl |= TIME_STAMP_INT_ENABLE;\n\t\t}\n\t}\n\n\tif (atomic_read(&rdev->irq.ring_int[R600_RING_TYPE_DMA_INDEX])) {\n\t\tDRM_DEBUG(\"r600_irq_set: sw int dma\\n\");\n\t\tdma_cntl |= TRAP_ENABLE;\n\t}\n\n\tif (rdev->family >= CHIP_CAYMAN) {\n\t\tdma_cntl1 = RREG32(CAYMAN_DMA1_CNTL) & ~TRAP_ENABLE;\n\t\tif (atomic_read(&rdev->irq.ring_int[CAYMAN_RING_TYPE_DMA1_INDEX])) {\n\t\t\tDRM_DEBUG(\"r600_irq_set: sw int dma1\\n\");\n\t\t\tdma_cntl1 |= TRAP_ENABLE;\n\t\t}\n\t}\n\n\tif (rdev->irq.dpm_thermal) {\n\t\tDRM_DEBUG(\"dpm thermal\\n\");\n\t\tthermal_int |= THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW;\n\t}\n\n\tif (rdev->family >= CHIP_CAYMAN) {\n\t\tcayman_cp_int_cntl_setup(rdev, 0, cp_int_cntl);\n\t\tcayman_cp_int_cntl_setup(rdev, 1, cp_int_cntl1);\n\t\tcayman_cp_int_cntl_setup(rdev, 2, cp_int_cntl2);\n\t} else\n\t\tWREG32(CP_INT_CNTL, cp_int_cntl);\n\n\tWREG32(DMA_CNTL, dma_cntl);\n\n\tif (rdev->family >= CHIP_CAYMAN)\n\t\tWREG32(CAYMAN_DMA1_CNTL, dma_cntl1);\n\n\tWREG32(GRBM_INT_CNTL, grbm_int_cntl);\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tradeon_irq_kms_set_irq_n_enabled(\n\t\t    rdev, INT_MASK + crtc_offsets[i],\n\t\t    VBLANK_INT_MASK,\n\t\t    rdev->irq.crtc_vblank_int[i] ||\n\t\t    atomic_read(&rdev->irq.pflip[i]), \"vblank\", i);\n\t}\n\n\tfor (i = 0; i < rdev->num_crtc; i++)\n\t\tWREG32(GRPH_INT_CONTROL + crtc_offsets[i], GRPH_PFLIP_INT_MASK);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tradeon_irq_kms_set_irq_n_enabled(\n\t\t    rdev, DC_HPDx_INT_CONTROL(i),\n\t\t    DC_HPDx_INT_EN | DC_HPDx_RX_INT_EN,\n\t\t    rdev->irq.hpd[i], \"HPD\", i);\n\t}\n\n\tif (rdev->family == CHIP_ARUBA)\n\t\tWREG32(TN_CG_THERMAL_INT_CTRL, thermal_int);\n\telse\n\t\tWREG32(CG_THERMAL_INT, thermal_int);\n\n\tfor (i = 0; i < 6; i++) {\n\t\tradeon_irq_kms_set_irq_n_enabled(\n\t\t    rdev, AFMT_AUDIO_PACKET_CONTROL + crtc_offsets[i],\n\t\t    AFMT_AZ_FORMAT_WTRIG_MASK,\n\t\t    rdev->irq.afmt[i], \"HDMI\", i);\n\t}\n\n\t \n\tRREG32(SRBM_STATUS);\n\n\treturn 0;\n}\n\n \nstatic void evergreen_irq_ack(struct radeon_device *rdev)\n{\n\tint i, j;\n\tu32 *grph_int = rdev->irq.stat_regs.evergreen.grph_int;\n\tu32 *disp_int = rdev->irq.stat_regs.evergreen.disp_int;\n\tu32 *afmt_status = rdev->irq.stat_regs.evergreen.afmt_status;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tdisp_int[i] = RREG32(evergreen_disp_int_status[i]);\n\t\tafmt_status[i] = RREG32(AFMT_STATUS + crtc_offsets[i]);\n\t\tif (i < rdev->num_crtc)\n\t\t\tgrph_int[i] = RREG32(GRPH_INT_STATUS + crtc_offsets[i]);\n\t}\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i += 2) {\n\t\tfor (j = i; j < (i + 2); j++) {\n\t\t\tif (grph_int[j] & GRPH_PFLIP_INT_OCCURRED)\n\t\t\t\tWREG32(GRPH_INT_STATUS + crtc_offsets[j],\n\t\t\t\t       GRPH_PFLIP_INT_CLEAR);\n\t\t}\n\n\t\tfor (j = i; j < (i + 2); j++) {\n\t\t\tif (disp_int[j] & LB_D1_VBLANK_INTERRUPT)\n\t\t\t\tWREG32(VBLANK_STATUS + crtc_offsets[j],\n\t\t\t\t       VBLANK_ACK);\n\t\t\tif (disp_int[j] & LB_D1_VLINE_INTERRUPT)\n\t\t\t\tWREG32(VLINE_STATUS + crtc_offsets[j],\n\t\t\t\t       VLINE_ACK);\n\t\t}\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (disp_int[i] & DC_HPD1_INTERRUPT)\n\t\t\tWREG32_OR(DC_HPDx_INT_CONTROL(i), DC_HPDx_INT_ACK);\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (disp_int[i] & DC_HPD1_RX_INTERRUPT)\n\t\t\tWREG32_OR(DC_HPDx_INT_CONTROL(i), DC_HPDx_RX_INT_ACK);\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (afmt_status[i] & AFMT_AZ_FORMAT_WTRIG)\n\t\t\tWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + crtc_offsets[i],\n\t\t\t\t  AFMT_AZ_FORMAT_WTRIG_ACK);\n\t}\n}\n\nstatic void evergreen_irq_disable(struct radeon_device *rdev)\n{\n\tr600_disable_interrupts(rdev);\n\t \n\tmdelay(1);\n\tevergreen_irq_ack(rdev);\n\tevergreen_disable_interrupt_state(rdev);\n}\n\nvoid evergreen_irq_suspend(struct radeon_device *rdev)\n{\n\tevergreen_irq_disable(rdev);\n\tr600_rlc_stop(rdev);\n}\n\nstatic u32 evergreen_get_ih_wptr(struct radeon_device *rdev)\n{\n\tu32 wptr, tmp;\n\n\tif (rdev->wb.enabled)\n\t\twptr = le32_to_cpu(rdev->wb.wb[R600_WB_IH_WPTR_OFFSET/4]);\n\telse\n\t\twptr = RREG32(IH_RB_WPTR);\n\n\tif (wptr & RB_OVERFLOW) {\n\t\twptr &= ~RB_OVERFLOW;\n\t\t \n\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);\n\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;\n\t\ttmp = RREG32(IH_RB_CNTL);\n\t\ttmp |= IH_WPTR_OVERFLOW_CLEAR;\n\t\tWREG32(IH_RB_CNTL, tmp);\n\t}\n\treturn (wptr & rdev->ih.ptr_mask);\n}\n\nint evergreen_irq_process(struct radeon_device *rdev)\n{\n\tu32 *disp_int = rdev->irq.stat_regs.evergreen.disp_int;\n\tu32 *afmt_status = rdev->irq.stat_regs.evergreen.afmt_status;\n\tu32 crtc_idx, hpd_idx, afmt_idx;\n\tu32 mask;\n\tu32 wptr;\n\tu32 rptr;\n\tu32 src_id, src_data;\n\tu32 ring_index;\n\tbool queue_hotplug = false;\n\tbool queue_hdmi = false;\n\tbool queue_dp = false;\n\tbool queue_thermal = false;\n\tu32 status, addr;\n\tconst char *event_name;\n\n\tif (!rdev->ih.enabled || rdev->shutdown)\n\t\treturn IRQ_NONE;\n\n\twptr = evergreen_get_ih_wptr(rdev);\n\nrestart_ih:\n\t \n\tif (atomic_xchg(&rdev->ih.lock, 1))\n\t\treturn IRQ_NONE;\n\n\trptr = rdev->ih.rptr;\n\tDRM_DEBUG(\"evergreen_irq_process start: rptr %d, wptr %d\\n\", rptr, wptr);\n\n\t \n\trmb();\n\n\t \n\tevergreen_irq_ack(rdev);\n\n\twhile (rptr != wptr) {\n\t\t \n\t\tring_index = rptr / 4;\n\t\tsrc_id =  le32_to_cpu(rdev->ih.ring[ring_index]) & 0xff;\n\t\tsrc_data = le32_to_cpu(rdev->ih.ring[ring_index + 1]) & 0xfffffff;\n\n\t\tswitch (src_id) {\n\t\tcase 1:  \n\t\tcase 2:  \n\t\tcase 3:  \n\t\tcase 4:  \n\t\tcase 5:  \n\t\tcase 6:  \n\t\t\tcrtc_idx = src_id - 1;\n\n\t\t\tif (src_data == 0) {  \n\t\t\t\tmask = LB_D1_VBLANK_INTERRUPT;\n\t\t\t\tevent_name = \"vblank\";\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[crtc_idx]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, crtc_idx);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[crtc_idx])) {\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev,\n\t\t\t\t\t\t\t\t  crtc_idx);\n\t\t\t\t}\n\n\t\t\t} else if (src_data == 1) {  \n\t\t\t\tmask = LB_D1_VLINE_INTERRUPT;\n\t\t\t\tevent_name = \"vline\";\n\t\t\t} else {\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t\t\t  src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(disp_int[crtc_idx] & mask)) {\n\t\t\t\tDRM_DEBUG(\"IH: D%d %s - IH event w/o asserted irq bit?\\n\",\n\t\t\t\t\t  crtc_idx + 1, event_name);\n\t\t\t}\n\n\t\t\tdisp_int[crtc_idx] &= ~mask;\n\t\t\tDRM_DEBUG(\"IH: D%d %s\\n\", crtc_idx + 1, event_name);\n\n\t\t\tbreak;\n\t\tcase 8:  \n\t\tcase 10:  \n\t\tcase 12:  \n\t\tcase 14:  \n\t\tcase 16:  \n\t\tcase 18:  \n\t\t\tDRM_DEBUG(\"IH: D%d flip\\n\", ((src_id - 8) >> 1) + 1);\n\t\t\tif (radeon_use_pflipirq > 0)\n\t\t\t\tradeon_crtc_handle_flip(rdev, (src_id - 8) >> 1);\n\t\t\tbreak;\n\t\tcase 42:  \n\t\t\tif (src_data <= 5) {\n\t\t\t\thpd_idx = src_data;\n\t\t\t\tmask = DC_HPD1_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tevent_name = \"HPD\";\n\n\t\t\t} else if (src_data <= 11) {\n\t\t\t\thpd_idx = src_data - 6;\n\t\t\t\tmask = DC_HPD1_RX_INTERRUPT;\n\t\t\t\tqueue_dp = true;\n\t\t\t\tevent_name = \"HPD_RX\";\n\n\t\t\t} else {\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t\t\t  src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(disp_int[hpd_idx] & mask))\n\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\tdisp_int[hpd_idx] &= ~mask;\n\t\t\tDRM_DEBUG(\"IH: %s%d\\n\", event_name, hpd_idx + 1);\n\n\t\t\tbreak;\n\t\tcase 44:  \n\t\t\tafmt_idx = src_data;\n\t\t\tif (afmt_idx > 5) {\n\t\t\t\tDRM_ERROR(\"Unhandled interrupt: %d %d\\n\",\n\t\t\t\t\t  src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!(afmt_status[afmt_idx] & AFMT_AZ_FORMAT_WTRIG))\n\t\t\t\tDRM_DEBUG(\"IH: IH event w/o asserted irq bit?\\n\");\n\n\t\t\tafmt_status[afmt_idx] &= ~AFMT_AZ_FORMAT_WTRIG;\n\t\t\tqueue_hdmi = true;\n\t\t\tDRM_DEBUG(\"IH: HDMI%d\\n\", afmt_idx + 1);\n\t\t\tbreak;\n\t\tcase 96:\n\t\t\tDRM_ERROR(\"SRBM_READ_ERROR: 0x%x\\n\", RREG32(SRBM_READ_ERROR));\n\t\t\tWREG32(SRBM_INT_ACK, 0x1);\n\t\t\tbreak;\n\t\tcase 124:  \n\t\t\tDRM_DEBUG(\"IH: UVD int: 0x%08x\\n\", src_data);\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_UVD_INDEX);\n\t\t\tbreak;\n\t\tcase 146:\n\t\tcase 147:\n\t\t\taddr = RREG32(VM_CONTEXT1_PROTECTION_FAULT_ADDR);\n\t\t\tstatus = RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS);\n\t\t\t \n\t\t\tWREG32_P(VM_CONTEXT1_CNTL2, 1, ~1);\n\t\t\tif (addr == 0x0 && status == 0x0)\n\t\t\t\tbreak;\n\t\t\tdev_err(rdev->dev, \"GPU fault detected: %d 0x%08x\\n\", src_id, src_data);\n\t\t\tdev_err(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_ADDR   0x%08X\\n\",\n\t\t\t\taddr);\n\t\t\tdev_err(rdev->dev, \"  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\\n\",\n\t\t\t\tstatus);\n\t\t\tcayman_vm_decode_fault(rdev, status, addr);\n\t\t\tbreak;\n\t\tcase 176:  \n\t\tcase 177:  \n\t\tcase 178:  \n\t\t\tDRM_DEBUG(\"IH: CP int: 0x%08x\\n\", src_data);\n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\tbreak;\n\t\tcase 181:  \n\t\t\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\t\t\tif (rdev->family >= CHIP_CAYMAN) {\n\t\t\t\tswitch (src_data) {\n\t\t\t\tcase 0:\n\t\t\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP1_INDEX);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_CP2_INDEX);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\tbreak;\n\t\tcase 224:  \n\t\t\tDRM_DEBUG(\"IH: DMA trap\\n\");\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_DMA_INDEX);\n\t\t\tbreak;\n\t\tcase 230:  \n\t\t\tDRM_DEBUG(\"IH: thermal low to high\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = false;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 231:  \n\t\t\tDRM_DEBUG(\"IH: thermal high to low\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = true;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 233:  \n\t\t\tDRM_DEBUG(\"IH: GUI idle\\n\");\n\t\t\tbreak;\n\t\tcase 244:  \n\t\t\tif (rdev->family >= CHIP_CAYMAN) {\n\t\t\t\tDRM_DEBUG(\"IH: DMA1 trap\\n\");\n\t\t\t\tradeon_fence_process(rdev, CAYMAN_RING_TYPE_DMA1_INDEX);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trptr += 16;\n\t\trptr &= rdev->ih.ptr_mask;\n\t\tWREG32(IH_RB_RPTR, rptr);\n\t}\n\tif (queue_dp)\n\t\tschedule_work(&rdev->dp_work);\n\tif (queue_hotplug)\n\t\tschedule_delayed_work(&rdev->hotplug_work, 0);\n\tif (queue_hdmi)\n\t\tschedule_work(&rdev->audio_work);\n\tif (queue_thermal && rdev->pm.dpm_enabled)\n\t\tschedule_work(&rdev->pm.dpm.thermal.work);\n\trdev->ih.rptr = rptr;\n\tatomic_set(&rdev->ih.lock, 0);\n\n\t \n\twptr = evergreen_get_ih_wptr(rdev);\n\tif (wptr != rptr)\n\t\tgoto restart_ih;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void evergreen_uvd_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = radeon_uvd_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_uvd = false;\n\t\treturn;\n\t}\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[R600_RING_TYPE_UVD_INDEX], 4096);\n}\n\nstatic void evergreen_uvd_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = uvd_v2_2_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_UVD_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size = 0;\n}\n\nstatic void evergreen_uvd_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_uvd || !rdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, PACKET0(UVD_NO_OP, 0));\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = uvd_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic int evergreen_startup(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\t \n\tevergreen_pcie_gen2_enable(rdev);\n\t \n\tevergreen_program_aspm(rdev);\n\n\t \n\tr = r600_vram_scratch_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tevergreen_mc_program(rdev);\n\n\tif (ASIC_IS_DCE5(rdev) && !rdev->pm.dpm_enabled) {\n\t\tr = ni_mc_load_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load MC firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tevergreen_agp_enable(rdev);\n\t} else {\n\t\tr = evergreen_pcie_gart_enable(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tevergreen_gpu_init(rdev);\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\trdev->rlc.reg_list = sumo_rlc_save_restore_register_list;\n\t\trdev->rlc.reg_list_size =\n\t\t\t(u32)ARRAY_SIZE(sumo_rlc_save_restore_register_list);\n\t\trdev->rlc.cs_data = evergreen_cs_data;\n\t\tr = sumo_rlc_init(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to init rlc BOs!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_DMA_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing DMA fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tevergreen_uvd_start(rdev);\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = r600_irq_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: IH init failed (%d).\\n\", r);\n\t\tradeon_irq_kms_fini(rdev);\n\t\treturn r;\n\t}\n\tevergreen_irq_set(rdev);\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, R600_WB_DMA_RPTR_OFFSET,\n\t\t\t     DMA_PACKET(DMA_PACKET_NOP, 0, 0));\n\tif (r)\n\t\treturn r;\n\n\tr = evergreen_cp_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\tr = evergreen_cp_resume(rdev);\n\tif (r)\n\t\treturn r;\n\tr = r600_dma_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tevergreen_uvd_resume(rdev);\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: audio init failed\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint evergreen_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (radeon_asic_reset(rdev))\n\t\tdev_warn(rdev->dev, \"GPU reset failed !\\n\");\n\t \n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\n\t \n\tevergreen_init_golden_registers(rdev);\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_resume(rdev);\n\n\trdev->accel_working = true;\n\tr = evergreen_startup(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"evergreen startup failed on resume\\n\");\n\t\trdev->accel_working = false;\n\t\treturn r;\n\t}\n\n\treturn r;\n\n}\n\nint evergreen_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tif (rdev->has_uvd) {\n\t\tradeon_uvd_suspend(rdev);\n\t\tuvd_v1_0_fini(rdev);\n\t}\n\tr700_cp_stop(rdev);\n\tr600_dma_stop(rdev);\n\tevergreen_irq_suspend(rdev);\n\tradeon_wb_disable(rdev);\n\tevergreen_pcie_gart_disable(rdev);\n\n\treturn 0;\n}\n\n \nint evergreen_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting atombios for evergreen GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_atombios_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tif (radeon_asic_reset(rdev))\n\t\tdev_warn(rdev->dev, \"GPU reset failed !\\n\");\n\t \n\tif (!radeon_card_posted(rdev)) {\n\t\tif (!rdev->bios) {\n\t\t\tdev_err(rdev->dev, \"Card not posted and no BIOS - ignoring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDRM_INFO(\"GPU not posted. posting now...\\n\");\n\t\tatom_asic_init(rdev->mode_info.atom_context);\n\t}\n\t \n\tevergreen_init_golden_registers(rdev);\n\t \n\tr600_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr = radeon_agp_init(rdev);\n\t\tif (r)\n\t\t\tradeon_agp_disable(rdev);\n\t}\n\t \n\tr = evergreen_mc_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tif (ASIC_IS_DCE5(rdev)) {\n\t\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->rlc_fw || !rdev->mc_fw) {\n\t\t\tr = ni_init_microcode(rdev);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->rlc_fw) {\n\t\t\tr = r600_init_microcode(rdev);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX], 1024 * 1024);\n\n\trdev->ring[R600_RING_TYPE_DMA_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[R600_RING_TYPE_DMA_INDEX], 64 * 1024);\n\n\tevergreen_uvd_init(rdev);\n\n\trdev->ih.ring_obj = NULL;\n\tr600_ih_ring_init(rdev, 64 * 1024);\n\n\tr = r600_pcie_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\trdev->accel_working = true;\n\tr = evergreen_startup(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"disabling GPU acceleration\\n\");\n\t\tr700_cp_fini(rdev);\n\t\tr600_dma_fini(rdev);\n\t\tr600_irq_fini(rdev);\n\t\tif (rdev->flags & RADEON_IS_IGP)\n\t\t\tsumo_rlc_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tevergreen_pcie_gart_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\n\t \n\tif (ASIC_IS_DCE5(rdev)) {\n\t\tif (!rdev->mc_fw && !(rdev->flags & RADEON_IS_IGP)) {\n\t\t\tDRM_ERROR(\"radeon: MC ucode required for NI+.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid evergreen_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tradeon_audio_fini(rdev);\n\tr700_cp_fini(rdev);\n\tr600_dma_fini(rdev);\n\tr600_irq_fini(rdev);\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tsumo_rlc_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tuvd_v1_0_fini(rdev);\n\tradeon_uvd_fini(rdev);\n\tevergreen_pcie_gart_fini(rdev);\n\tr600_vram_scratch_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_agp_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nvoid evergreen_pcie_gen2_enable(struct radeon_device *rdev)\n{\n\tu32 link_width_cntl, speed_cntl;\n\n\tif (radeon_pcie_gen2 == 0)\n\t\treturn;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\t \n\tif (ASIC_IS_X2(rdev))\n\t\treturn;\n\n\tif ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&\n\t\t(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))\n\t\treturn;\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tif (speed_cntl & LC_CURRENT_DATA_RATE) {\n\t\tDRM_INFO(\"PCIE gen 2 link speeds already enabled\\n\");\n\t\treturn;\n\t}\n\n\tDRM_INFO(\"enabling PCIE gen 2 link speeds, disable with radeon.pcie_gen2=0\\n\");\n\n\tif ((speed_cntl & LC_OTHER_SIDE_EVER_SENT_GEN2) ||\n\t    (speed_cntl & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\n\n\t\tlink_width_cntl = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\tlink_width_cntl &= ~LC_UPCONFIGURE_DIS;\n\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tspeed_cntl &= ~LC_TARGET_LINK_SPEED_OVERRIDE_EN;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tspeed_cntl |= LC_CLR_FAILED_SPD_CHANGE_CNT;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tspeed_cntl &= ~LC_CLR_FAILED_SPD_CHANGE_CNT;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tspeed_cntl |= LC_GEN2_EN_STRAP;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\t} else {\n\t\tlink_width_cntl = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t \n\t\tif (1)\n\t\t\tlink_width_cntl |= LC_UPCONFIGURE_DIS;\n\t\telse\n\t\t\tlink_width_cntl &= ~LC_UPCONFIGURE_DIS;\n\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\t}\n}\n\nvoid evergreen_program_aspm(struct radeon_device *rdev)\n{\n\tu32 data, orig;\n\tu32 pcie_lc_cntl, pcie_lc_cntl_old;\n\tbool disable_l0s, disable_l1 = false, disable_plloff_in_l1 = false;\n\t \n\tbool fusion_platform = false;\n\n\tif (radeon_aspm == 0)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\tswitch (rdev->family) {\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\tcase CHIP_JUNIPER:\n\tcase CHIP_REDWOOD:\n\tcase CHIP_CEDAR:\n\tcase CHIP_SUMO:\n\tcase CHIP_SUMO2:\n\tcase CHIP_PALM:\n\tcase CHIP_ARUBA:\n\t\tdisable_l0s = true;\n\t\tbreak;\n\tdefault:\n\t\tdisable_l0s = false;\n\t\tbreak;\n\t}\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tfusion_platform = true;  \n\n\tdata = orig = RREG32_PIF_PHY0(PB0_PIF_PAIRING);\n\tif (fusion_platform)\n\t\tdata &= ~MULTI_PIF;\n\telse\n\t\tdata |= MULTI_PIF;\n\tif (data != orig)\n\t\tWREG32_PIF_PHY0(PB0_PIF_PAIRING, data);\n\n\tdata = orig = RREG32_PIF_PHY1(PB1_PIF_PAIRING);\n\tif (fusion_platform)\n\t\tdata &= ~MULTI_PIF;\n\telse\n\t\tdata |= MULTI_PIF;\n\tif (data != orig)\n\t\tWREG32_PIF_PHY1(PB1_PIF_PAIRING, data);\n\n\tpcie_lc_cntl = pcie_lc_cntl_old = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\tpcie_lc_cntl &= ~(LC_L0S_INACTIVITY_MASK | LC_L1_INACTIVITY_MASK);\n\tif (!disable_l0s) {\n\t\tif (rdev->family >= CHIP_BARTS)\n\t\t\tpcie_lc_cntl |= LC_L0S_INACTIVITY(7);\n\t\telse\n\t\t\tpcie_lc_cntl |= LC_L0S_INACTIVITY(3);\n\t}\n\n\tif (!disable_l1) {\n\t\tif (rdev->family >= CHIP_BARTS)\n\t\t\tpcie_lc_cntl |= LC_L1_INACTIVITY(7);\n\t\telse\n\t\t\tpcie_lc_cntl |= LC_L1_INACTIVITY(8);\n\n\t\tif (!disable_plloff_in_l1) {\n\t\t\tdata = orig = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_0_MASK | PLL_POWER_STATE_IN_TXS2_0_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_0(7) | PLL_POWER_STATE_IN_TXS2_0(7);\n\t\t\tif (data != orig)\n\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0, data);\n\n\t\t\tdata = orig = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_1_MASK | PLL_POWER_STATE_IN_TXS2_1_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_1(7) | PLL_POWER_STATE_IN_TXS2_1(7);\n\t\t\tif (data != orig)\n\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1, data);\n\n\t\t\tdata = orig = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_0_MASK | PLL_POWER_STATE_IN_TXS2_0_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_0(7) | PLL_POWER_STATE_IN_TXS2_0(7);\n\t\t\tif (data != orig)\n\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0, data);\n\n\t\t\tdata = orig = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1);\n\t\t\tdata &= ~(PLL_POWER_STATE_IN_OFF_1_MASK | PLL_POWER_STATE_IN_TXS2_1_MASK);\n\t\t\tdata |= PLL_POWER_STATE_IN_OFF_1(7) | PLL_POWER_STATE_IN_TXS2_1(7);\n\t\t\tif (data != orig)\n\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1, data);\n\n\t\t\tif (rdev->family >= CHIP_BARTS) {\n\t\t\t\tdata = orig = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_0_MASK;\n\t\t\t\tdata |= PLL_RAMP_UP_TIME_0(4);\n\t\t\t\tif (data != orig)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_0, data);\n\n\t\t\t\tdata = orig = RREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_1_MASK;\n\t\t\t\tdata |= PLL_RAMP_UP_TIME_1(4);\n\t\t\t\tif (data != orig)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_PWRDOWN_1, data);\n\n\t\t\t\tdata = orig = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_0_MASK;\n\t\t\t\tdata |= PLL_RAMP_UP_TIME_0(4);\n\t\t\t\tif (data != orig)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_0, data);\n\n\t\t\t\tdata = orig = RREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1);\n\t\t\t\tdata &= ~PLL_RAMP_UP_TIME_1_MASK;\n\t\t\t\tdata |= PLL_RAMP_UP_TIME_1(4);\n\t\t\t\tif (data != orig)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_PWRDOWN_1, data);\n\t\t\t}\n\n\t\t\tdata = orig = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t\tdata &= ~LC_DYN_LANES_PWR_STATE_MASK;\n\t\t\tdata |= LC_DYN_LANES_PWR_STATE(3);\n\t\t\tif (data != orig)\n\t\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, data);\n\n\t\t\tif (rdev->family >= CHIP_BARTS) {\n\t\t\t\tdata = orig = RREG32_PIF_PHY0(PB0_PIF_CNTL);\n\t\t\t\tdata &= ~LS2_EXIT_TIME_MASK;\n\t\t\t\tdata |= LS2_EXIT_TIME(1);\n\t\t\t\tif (data != orig)\n\t\t\t\t\tWREG32_PIF_PHY0(PB0_PIF_CNTL, data);\n\n\t\t\t\tdata = orig = RREG32_PIF_PHY1(PB1_PIF_CNTL);\n\t\t\t\tdata &= ~LS2_EXIT_TIME_MASK;\n\t\t\t\tdata |= LS2_EXIT_TIME(1);\n\t\t\t\tif (data != orig)\n\t\t\t\t\tWREG32_PIF_PHY1(PB1_PIF_CNTL, data);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (rdev->family < CHIP_BARTS)\n\t\tpcie_lc_cntl |= LC_PMI_TO_L1_DIS;\n\n\tif (pcie_lc_cntl != pcie_lc_cntl_old)\n\t\tWREG32_PCIE_PORT(PCIE_LC_CNTL, pcie_lc_cntl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}