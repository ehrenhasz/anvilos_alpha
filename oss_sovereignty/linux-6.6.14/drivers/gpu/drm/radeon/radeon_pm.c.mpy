{
  "module_name": "radeon_pm.c",
  "hash_id": "0de453935ffb804f60152c2bc8333164a5b83c05c76a7249eb1233225a4b0a83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_pm.c",
  "human_readable_source": " \n\n#include <linux/hwmon-sysfs.h>\n#include <linux/hwmon.h>\n#include <linux/pci.h>\n#include <linux/power_supply.h>\n\n#include <drm/drm_vblank.h>\n\n#include \"atom.h\"\n#include \"avivod.h\"\n#include \"r600_dpm.h\"\n#include \"radeon.h\"\n#include \"radeon_pm.h\"\n\n#define RADEON_IDLE_LOOP_MS 100\n#define RADEON_RECLOCK_DELAY_MS 200\n#define RADEON_WAIT_VBLANK_TIMEOUT 200\n\nstatic const char *radeon_pm_state_type_name[5] = {\n\t\"\",\n\t\"Powersave\",\n\t\"Battery\",\n\t\"Balanced\",\n\t\"Performance\",\n};\n\nstatic void radeon_dynpm_idle_work_handler(struct work_struct *work);\nstatic void radeon_debugfs_pm_init(struct radeon_device *rdev);\nstatic bool radeon_pm_in_vbl(struct radeon_device *rdev);\nstatic bool radeon_pm_debug_check_in_vbl(struct radeon_device *rdev, bool finish);\nstatic void radeon_pm_update_profile(struct radeon_device *rdev);\nstatic void radeon_pm_set_clocks(struct radeon_device *rdev);\n\nint radeon_pm_get_type_index(struct radeon_device *rdev,\n\t\t\t     enum radeon_pm_state_type ps_type,\n\t\t\t     int instance)\n{\n\tint i;\n\tint found_instance = -1;\n\n\tfor (i = 0; i < rdev->pm.num_power_states; i++) {\n\t\tif (rdev->pm.power_state[i].type == ps_type) {\n\t\t\tfound_instance++;\n\t\t\tif (found_instance == instance)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\t \n\treturn rdev->pm.default_power_state_index;\n}\n\nvoid radeon_pm_acpi_event_handler(struct radeon_device *rdev)\n{\n\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\tif (power_supply_is_system_supplied() > 0)\n\t\t\trdev->pm.dpm.ac_power = true;\n\t\telse\n\t\t\trdev->pm.dpm.ac_power = false;\n\t\tif (rdev->family == CHIP_ARUBA) {\n\t\t\tif (rdev->asic->dpm.enable_bapm)\n\t\t\t\tradeon_dpm_enable_bapm(rdev, rdev->pm.dpm.ac_power);\n\t\t}\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t} else if (rdev->pm.pm_method == PM_METHOD_PROFILE) {\n\t\tif (rdev->pm.profile == PM_PROFILE_AUTO) {\n\t\t\tmutex_lock(&rdev->pm.mutex);\n\t\t\tradeon_pm_update_profile(rdev);\n\t\t\tradeon_pm_set_clocks(rdev);\n\t\t\tmutex_unlock(&rdev->pm.mutex);\n\t\t}\n\t}\n}\n\nstatic void radeon_pm_update_profile(struct radeon_device *rdev)\n{\n\tswitch (rdev->pm.profile) {\n\tcase PM_PROFILE_DEFAULT:\n\t\trdev->pm.profile_index = PM_PROFILE_DEFAULT_IDX;\n\t\tbreak;\n\tcase PM_PROFILE_AUTO:\n\t\tif (power_supply_is_system_supplied() > 0) {\n\t\t\tif (rdev->pm.active_crtc_count > 1)\n\t\t\t\trdev->pm.profile_index = PM_PROFILE_HIGH_MH_IDX;\n\t\t\telse\n\t\t\t\trdev->pm.profile_index = PM_PROFILE_HIGH_SH_IDX;\n\t\t} else {\n\t\t\tif (rdev->pm.active_crtc_count > 1)\n\t\t\t\trdev->pm.profile_index = PM_PROFILE_MID_MH_IDX;\n\t\t\telse\n\t\t\t\trdev->pm.profile_index = PM_PROFILE_MID_SH_IDX;\n\t\t}\n\t\tbreak;\n\tcase PM_PROFILE_LOW:\n\t\tif (rdev->pm.active_crtc_count > 1)\n\t\t\trdev->pm.profile_index = PM_PROFILE_LOW_MH_IDX;\n\t\telse\n\t\t\trdev->pm.profile_index = PM_PROFILE_LOW_SH_IDX;\n\t\tbreak;\n\tcase PM_PROFILE_MID:\n\t\tif (rdev->pm.active_crtc_count > 1)\n\t\t\trdev->pm.profile_index = PM_PROFILE_MID_MH_IDX;\n\t\telse\n\t\t\trdev->pm.profile_index = PM_PROFILE_MID_SH_IDX;\n\t\tbreak;\n\tcase PM_PROFILE_HIGH:\n\t\tif (rdev->pm.active_crtc_count > 1)\n\t\t\trdev->pm.profile_index = PM_PROFILE_HIGH_MH_IDX;\n\t\telse\n\t\t\trdev->pm.profile_index = PM_PROFILE_HIGH_SH_IDX;\n\t\tbreak;\n\t}\n\n\tif (rdev->pm.active_crtc_count == 0) {\n\t\trdev->pm.requested_power_state_index =\n\t\t\trdev->pm.profiles[rdev->pm.profile_index].dpms_off_ps_idx;\n\t\trdev->pm.requested_clock_mode_index =\n\t\t\trdev->pm.profiles[rdev->pm.profile_index].dpms_off_cm_idx;\n\t} else {\n\t\trdev->pm.requested_power_state_index =\n\t\t\trdev->pm.profiles[rdev->pm.profile_index].dpms_on_ps_idx;\n\t\trdev->pm.requested_clock_mode_index =\n\t\t\trdev->pm.profiles[rdev->pm.profile_index].dpms_on_cm_idx;\n\t}\n}\n\nstatic void radeon_unmap_vram_bos(struct radeon_device *rdev)\n{\n\tstruct radeon_bo *bo, *n;\n\n\tif (list_empty(&rdev->gem.objects))\n\t\treturn;\n\n\tlist_for_each_entry_safe(bo, n, &rdev->gem.objects, list) {\n\t\tif (bo->tbo.resource->mem_type == TTM_PL_VRAM)\n\t\t\tttm_bo_unmap_virtual(&bo->tbo);\n\t}\n}\n\nstatic void radeon_sync_with_vblank(struct radeon_device *rdev)\n{\n\tif (rdev->pm.active_crtcs) {\n\t\trdev->pm.vblank_sync = false;\n\t\twait_event_timeout(\n\t\t\trdev->irq.vblank_queue, rdev->pm.vblank_sync,\n\t\t\tmsecs_to_jiffies(RADEON_WAIT_VBLANK_TIMEOUT));\n\t}\n}\n\nstatic void radeon_set_power_state(struct radeon_device *rdev)\n{\n\tu32 sclk, mclk;\n\tbool misc_after = false;\n\n\tif ((rdev->pm.requested_clock_mode_index == rdev->pm.current_clock_mode_index) &&\n\t    (rdev->pm.requested_power_state_index == rdev->pm.current_power_state_index))\n\t\treturn;\n\n\tif (radeon_gui_idle(rdev)) {\n\t\tsclk = rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t\tclock_info[rdev->pm.requested_clock_mode_index].sclk;\n\t\tif (sclk > rdev->pm.default_sclk)\n\t\t\tsclk = rdev->pm.default_sclk;\n\n\t\t \n\t\tif ((rdev->pm.pm_method == PM_METHOD_PROFILE) &&\n\t\t    (rdev->family >= CHIP_BARTS) &&\n\t\t    rdev->pm.active_crtc_count &&\n\t\t    ((rdev->pm.profile_index == PM_PROFILE_MID_MH_IDX) ||\n\t\t     (rdev->pm.profile_index == PM_PROFILE_LOW_MH_IDX)))\n\t\t\tmclk = rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t\t\tclock_info[rdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx].mclk;\n\t\telse\n\t\t\tmclk = rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t\t\tclock_info[rdev->pm.requested_clock_mode_index].mclk;\n\n\t\tif (mclk > rdev->pm.default_mclk)\n\t\t\tmclk = rdev->pm.default_mclk;\n\n\t\t \n\t\tif (sclk < rdev->pm.current_sclk)\n\t\t\tmisc_after = true;\n\n\t\tradeon_sync_with_vblank(rdev);\n\n\t\tif (rdev->pm.pm_method == PM_METHOD_DYNPM) {\n\t\t\tif (!radeon_pm_in_vbl(rdev))\n\t\t\t\treturn;\n\t\t}\n\n\t\tradeon_pm_prepare(rdev);\n\n\t\tif (!misc_after)\n\t\t\t \n\t\t\tradeon_pm_misc(rdev);\n\n\t\t \n\t\tif (sclk != rdev->pm.current_sclk) {\n\t\t\tradeon_pm_debug_check_in_vbl(rdev, false);\n\t\t\tradeon_set_engine_clock(rdev, sclk);\n\t\t\tradeon_pm_debug_check_in_vbl(rdev, true);\n\t\t\trdev->pm.current_sclk = sclk;\n\t\t\tDRM_DEBUG_DRIVER(\"Setting: e: %d\\n\", sclk);\n\t\t}\n\n\t\t \n\t\tif (rdev->asic->pm.set_memory_clock && (mclk != rdev->pm.current_mclk)) {\n\t\t\tradeon_pm_debug_check_in_vbl(rdev, false);\n\t\t\tradeon_set_memory_clock(rdev, mclk);\n\t\t\tradeon_pm_debug_check_in_vbl(rdev, true);\n\t\t\trdev->pm.current_mclk = mclk;\n\t\t\tDRM_DEBUG_DRIVER(\"Setting: m: %d\\n\", mclk);\n\t\t}\n\n\t\tif (misc_after)\n\t\t\t \n\t\t\tradeon_pm_misc(rdev);\n\n\t\tradeon_pm_finish(rdev);\n\n\t\trdev->pm.current_power_state_index = rdev->pm.requested_power_state_index;\n\t\trdev->pm.current_clock_mode_index = rdev->pm.requested_clock_mode_index;\n\t} else\n\t\tDRM_DEBUG_DRIVER(\"pm: GUI not idle!!!\\n\");\n}\n\nstatic void radeon_pm_set_clocks(struct radeon_device *rdev)\n{\n\tstruct drm_crtc *crtc;\n\tint i, r;\n\n\t \n\tif ((rdev->pm.requested_clock_mode_index == rdev->pm.current_clock_mode_index) &&\n\t    (rdev->pm.requested_power_state_index == rdev->pm.current_power_state_index))\n\t\treturn;\n\n\tdown_write(&rdev->pm.mclk_lock);\n\tmutex_lock(&rdev->ring_lock);\n\n\t \n\tfor (i = 0; i < RADEON_NUM_RINGS; i++) {\n\t\tstruct radeon_ring *ring = &rdev->ring[i];\n\t\tif (!ring->ready) {\n\t\t\tcontinue;\n\t\t}\n\t\tr = radeon_fence_wait_empty(rdev, i);\n\t\tif (r) {\n\t\t\t \n\t\t\tmutex_unlock(&rdev->ring_lock);\n\t\t\tup_write(&rdev->pm.mclk_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tradeon_unmap_vram_bos(rdev);\n\n\tif (rdev->irq.installed) {\n\t\ti = 0;\n\t\tdrm_for_each_crtc(crtc, rdev->ddev) {\n\t\t\tif (rdev->pm.active_crtcs & (1 << i)) {\n\t\t\t\t \n\t\t\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\t\t\trdev->pm.req_vblank |= (1 << i);\n\t\t\t\telse\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"crtc %d no vblank, can glitch\\n\",\n\t\t\t\t\t\t\t i);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tradeon_set_power_state(rdev);\n\n\tif (rdev->irq.installed) {\n\t\ti = 0;\n\t\tdrm_for_each_crtc(crtc, rdev->ddev) {\n\t\t\tif (rdev->pm.req_vblank & (1 << i)) {\n\t\t\t\trdev->pm.req_vblank &= ~(1 << i);\n\t\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\tradeon_update_bandwidth_info(rdev);\n\tif (rdev->pm.active_crtc_count)\n\t\tradeon_bandwidth_update(rdev);\n\n\trdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\n\n\tmutex_unlock(&rdev->ring_lock);\n\tup_write(&rdev->pm.mclk_lock);\n}\n\nstatic void radeon_pm_print_states(struct radeon_device *rdev)\n{\n\tint i, j;\n\tstruct radeon_power_state *power_state;\n\tstruct radeon_pm_clock_info *clock_info;\n\n\tDRM_DEBUG_DRIVER(\"%d Power State(s)\\n\", rdev->pm.num_power_states);\n\tfor (i = 0; i < rdev->pm.num_power_states; i++) {\n\t\tpower_state = &rdev->pm.power_state[i];\n\t\tDRM_DEBUG_DRIVER(\"State %d: %s\\n\", i,\n\t\t\tradeon_pm_state_type_name[power_state->type]);\n\t\tif (i == rdev->pm.default_power_state_index)\n\t\t\tDRM_DEBUG_DRIVER(\"\\tDefault\");\n\t\tif ((rdev->flags & RADEON_IS_PCIE) && !(rdev->flags & RADEON_IS_IGP))\n\t\t\tDRM_DEBUG_DRIVER(\"\\t%d PCIE Lanes\\n\", power_state->pcie_lanes);\n\t\tif (power_state->flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\n\t\t\tDRM_DEBUG_DRIVER(\"\\tSingle display only\\n\");\n\t\tDRM_DEBUG_DRIVER(\"\\t%d Clock Mode(s)\\n\", power_state->num_clock_modes);\n\t\tfor (j = 0; j < power_state->num_clock_modes; j++) {\n\t\t\tclock_info = &(power_state->clock_info[j]);\n\t\t\tif (rdev->flags & RADEON_IS_IGP)\n\t\t\t\tDRM_DEBUG_DRIVER(\"\\t\\t%d e: %d\\n\",\n\t\t\t\t\t\t j,\n\t\t\t\t\t\t clock_info->sclk * 10);\n\t\t\telse\n\t\t\t\tDRM_DEBUG_DRIVER(\"\\t\\t%d e: %d\\tm: %d\\tv: %d\\n\",\n\t\t\t\t\t\t j,\n\t\t\t\t\t\t clock_info->sclk * 10,\n\t\t\t\t\t\t clock_info->mclk * 10,\n\t\t\t\t\t\t clock_info->voltage.voltage);\n\t\t}\n\t}\n}\n\nstatic ssize_t radeon_get_pm_profile(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\tint cp = rdev->pm.profile;\n\n\treturn sysfs_emit(buf, \"%s\\n\", (cp == PM_PROFILE_AUTO) ? \"auto\" :\n\t\t\t  (cp == PM_PROFILE_LOW) ? \"low\" :\n\t\t\t  (cp == PM_PROFILE_MID) ? \"mid\" :\n\t\t\t  (cp == PM_PROFILE_HIGH) ? \"high\" : \"default\");\n}\n\nstatic ssize_t radeon_set_pm_profile(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf,\n\t\t\t\t     size_t count)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\n\t \n\tif  ((rdev->flags & RADEON_IS_PX) &&\n\t     (ddev->switch_power_state != DRM_SWITCH_POWER_ON))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rdev->pm.mutex);\n\tif (rdev->pm.pm_method == PM_METHOD_PROFILE) {\n\t\tif (strncmp(\"default\", buf, strlen(\"default\")) == 0)\n\t\t\trdev->pm.profile = PM_PROFILE_DEFAULT;\n\t\telse if (strncmp(\"auto\", buf, strlen(\"auto\")) == 0)\n\t\t\trdev->pm.profile = PM_PROFILE_AUTO;\n\t\telse if (strncmp(\"low\", buf, strlen(\"low\")) == 0)\n\t\t\trdev->pm.profile = PM_PROFILE_LOW;\n\t\telse if (strncmp(\"mid\", buf, strlen(\"mid\")) == 0)\n\t\t\trdev->pm.profile = PM_PROFILE_MID;\n\t\telse if (strncmp(\"high\", buf, strlen(\"high\")) == 0)\n\t\t\trdev->pm.profile = PM_PROFILE_HIGH;\n\t\telse {\n\t\t\tcount = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tradeon_pm_update_profile(rdev);\n\t\tradeon_pm_set_clocks(rdev);\n\t} else\n\t\tcount = -EINVAL;\n\nfail:\n\tmutex_unlock(&rdev->pm.mutex);\n\n\treturn count;\n}\n\nstatic ssize_t radeon_get_pm_method(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\tint pm = rdev->pm.pm_method;\n\n\treturn sysfs_emit(buf, \"%s\\n\", (pm == PM_METHOD_DYNPM) ? \"dynpm\" :\n\t\t\t  (pm == PM_METHOD_PROFILE) ? \"profile\" : \"dpm\");\n}\n\nstatic ssize_t radeon_set_pm_method(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf,\n\t\t\t\t    size_t count)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\n\t \n\tif  ((rdev->flags & RADEON_IS_PX) &&\n\t     (ddev->switch_power_state != DRM_SWITCH_POWER_ON)) {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (rdev->pm.pm_method == PM_METHOD_DPM) {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (strncmp(\"dynpm\", buf, strlen(\"dynpm\")) == 0) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\trdev->pm.pm_method = PM_METHOD_DYNPM;\n\t\trdev->pm.dynpm_state = DYNPM_STATE_PAUSED;\n\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t} else if (strncmp(\"profile\", buf, strlen(\"profile\")) == 0) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\t \n\t\trdev->pm.dynpm_state = DYNPM_STATE_DISABLED;\n\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\n\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t\tcancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);\n\t} else {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\tradeon_pm_compute_clocks(rdev);\nfail:\n\treturn count;\n}\n\nstatic ssize_t radeon_get_dpm_state(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\tenum radeon_pm_state_type pm = rdev->pm.dpm.user_state;\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  (pm == POWER_STATE_TYPE_BATTERY) ? \"battery\" :\n\t\t\t  (pm == POWER_STATE_TYPE_BALANCED) ? \"balanced\" : \"performance\");\n}\n\nstatic ssize_t radeon_set_dpm_state(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf,\n\t\t\t\t    size_t count)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\n\tmutex_lock(&rdev->pm.mutex);\n\tif (strncmp(\"battery\", buf, strlen(\"battery\")) == 0)\n\t\trdev->pm.dpm.user_state = POWER_STATE_TYPE_BATTERY;\n\telse if (strncmp(\"balanced\", buf, strlen(\"balanced\")) == 0)\n\t\trdev->pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;\n\telse if (strncmp(\"performance\", buf, strlen(\"performance\")) == 0)\n\t\trdev->pm.dpm.user_state = POWER_STATE_TYPE_PERFORMANCE;\n\telse {\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\tmutex_unlock(&rdev->pm.mutex);\n\n\t \n\tif (!(rdev->flags & RADEON_IS_PX) ||\n\t    (ddev->switch_power_state == DRM_SWITCH_POWER_ON))\n\t\tradeon_pm_compute_clocks(rdev);\n\nfail:\n\treturn count;\n}\n\nstatic ssize_t radeon_get_dpm_forced_performance_level(struct device *dev,\n\t\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t\t       char *buf)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\tenum radeon_dpm_forced_level level = rdev->pm.dpm.forced_level;\n\n\tif  ((rdev->flags & RADEON_IS_PX) &&\n\t     (ddev->switch_power_state != DRM_SWITCH_POWER_ON))\n\t\treturn sysfs_emit(buf, \"off\\n\");\n\n\treturn sysfs_emit(buf, \"%s\\n\",\n\t\t\t  (level == RADEON_DPM_FORCED_LEVEL_AUTO) ? \"auto\" :\n\t\t\t  (level == RADEON_DPM_FORCED_LEVEL_LOW) ? \"low\" : \"high\");\n}\n\nstatic ssize_t radeon_set_dpm_forced_performance_level(struct device *dev,\n\t\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t\t       const char *buf,\n\t\t\t\t\t\t       size_t count)\n{\n\tstruct drm_device *ddev = dev_get_drvdata(dev);\n\tstruct radeon_device *rdev = ddev->dev_private;\n\tenum radeon_dpm_forced_level level;\n\tint ret = 0;\n\n\t \n\tif  ((rdev->flags & RADEON_IS_PX) &&\n\t     (ddev->switch_power_state != DRM_SWITCH_POWER_ON))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rdev->pm.mutex);\n\tif (strncmp(\"low\", buf, strlen(\"low\")) == 0) {\n\t\tlevel = RADEON_DPM_FORCED_LEVEL_LOW;\n\t} else if (strncmp(\"high\", buf, strlen(\"high\")) == 0) {\n\t\tlevel = RADEON_DPM_FORCED_LEVEL_HIGH;\n\t} else if (strncmp(\"auto\", buf, strlen(\"auto\")) == 0) {\n\t\tlevel = RADEON_DPM_FORCED_LEVEL_AUTO;\n\t} else {\n\t\tcount = -EINVAL;\n\t\tgoto fail;\n\t}\n\tif (rdev->asic->dpm.force_performance_level) {\n\t\tif (rdev->pm.dpm.thermal_active) {\n\t\t\tcount = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tret = radeon_dpm_force_performance_level(rdev, level);\n\t\tif (ret)\n\t\t\tcount = -EINVAL;\n\t}\nfail:\n\tmutex_unlock(&rdev->pm.mutex);\n\n\treturn count;\n}\n\nstatic ssize_t radeon_hwmon_get_pwm1_enable(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    char *buf)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tu32 pwm_mode = 0;\n\n\tif (rdev->asic->dpm.fan_ctrl_get_mode)\n\t\tpwm_mode = rdev->asic->dpm.fan_ctrl_get_mode(rdev);\n\n\t \n\treturn sprintf(buf, \"%i\\n\", pwm_mode == FDO_PWM_MODE_STATIC ? 1 : 2);\n}\n\nstatic ssize_t radeon_hwmon_set_pwm1_enable(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf,\n\t\t\t\t\t    size_t count)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tint err;\n\tint value;\n\n\tif(!rdev->asic->dpm.fan_ctrl_set_mode)\n\t\treturn -EINVAL;\n\n\terr = kstrtoint(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tswitch (value) {\n\tcase 1:  \n\t\trdev->asic->dpm.fan_ctrl_set_mode(rdev, FDO_PWM_MODE_STATIC);\n\t\tbreak;\n\tdefault:  \n\t\trdev->asic->dpm.fan_ctrl_set_mode(rdev, 0);\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t radeon_hwmon_get_pwm1_min(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%i\\n\", 0);\n}\n\nstatic ssize_t radeon_hwmon_get_pwm1_max(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\treturn sprintf(buf, \"%i\\n\", 255);\n}\n\nstatic ssize_t radeon_hwmon_set_pwm1(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tint err;\n\tu32 value;\n\n\terr = kstrtou32(buf, 10, &value);\n\tif (err)\n\t\treturn err;\n\n\tvalue = (value * 100) / 255;\n\n\terr = rdev->asic->dpm.set_fan_speed_percent(rdev, value);\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\nstatic ssize_t radeon_hwmon_get_pwm1(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tint err;\n\tu32 speed;\n\n\terr = rdev->asic->dpm.get_fan_speed_percent(rdev, &speed);\n\tif (err)\n\t\treturn err;\n\n\tspeed = (speed * 255) / 100;\n\n\treturn sprintf(buf, \"%i\\n\", speed);\n}\n\nstatic DEVICE_ATTR(power_profile, S_IRUGO | S_IWUSR, radeon_get_pm_profile, radeon_set_pm_profile);\nstatic DEVICE_ATTR(power_method, S_IRUGO | S_IWUSR, radeon_get_pm_method, radeon_set_pm_method);\nstatic DEVICE_ATTR(power_dpm_state, S_IRUGO | S_IWUSR, radeon_get_dpm_state, radeon_set_dpm_state);\nstatic DEVICE_ATTR(power_dpm_force_performance_level, S_IRUGO | S_IWUSR,\n\t\t   radeon_get_dpm_forced_performance_level,\n\t\t   radeon_set_dpm_forced_performance_level);\n\nstatic ssize_t radeon_hwmon_show_temp(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tstruct drm_device *ddev = rdev->ddev;\n\tint temp;\n\n\t \n\tif  ((rdev->flags & RADEON_IS_PX) &&\n\t     (ddev->switch_power_state != DRM_SWITCH_POWER_ON))\n\t\treturn -EINVAL;\n\n\tif (rdev->asic->pm.get_temperature)\n\t\ttemp = radeon_get_temperature(rdev);\n\telse\n\t\ttemp = 0;\n\n\treturn sysfs_emit(buf, \"%d\\n\", temp);\n}\n\nstatic ssize_t radeon_hwmon_show_temp_thresh(struct device *dev,\n\t\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t\t     char *buf)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tint hyst = to_sensor_dev_attr(attr)->index;\n\tint temp;\n\n\tif (hyst)\n\t\ttemp = rdev->pm.dpm.thermal.min_temp;\n\telse\n\t\ttemp = rdev->pm.dpm.thermal.max_temp;\n\n\treturn sysfs_emit(buf, \"%d\\n\", temp);\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, radeon_hwmon_show_temp, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_crit, S_IRUGO, radeon_hwmon_show_temp_thresh, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(temp1_crit_hyst, S_IRUGO, radeon_hwmon_show_temp_thresh, NULL, 1);\nstatic SENSOR_DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, radeon_hwmon_get_pwm1, radeon_hwmon_set_pwm1, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR, radeon_hwmon_get_pwm1_enable, radeon_hwmon_set_pwm1_enable, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_min, S_IRUGO, radeon_hwmon_get_pwm1_min, NULL, 0);\nstatic SENSOR_DEVICE_ATTR(pwm1_max, S_IRUGO, radeon_hwmon_get_pwm1_max, NULL, 0);\n\nstatic ssize_t radeon_hwmon_show_sclk(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tstruct drm_device *ddev = rdev->ddev;\n\tu32 sclk = 0;\n\n\t \n\tif ((rdev->flags & RADEON_IS_PX) &&\n\t    (ddev->switch_power_state != DRM_SWITCH_POWER_ON))\n\t\treturn -EINVAL;\n\n\tif (rdev->asic->dpm.get_current_sclk)\n\t\tsclk = radeon_dpm_get_current_sclk(rdev);\n\n\t \n\tsclk *= 10000;\n\n\treturn sysfs_emit(buf, \"%u\\n\", sclk);\n}\n\nstatic SENSOR_DEVICE_ATTR(freq1_input, S_IRUGO, radeon_hwmon_show_sclk, NULL,\n\t\t\t  0);\n\nstatic ssize_t radeon_hwmon_show_vddc(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tstruct drm_device *ddev = rdev->ddev;\n\tu16 vddc = 0;\n\n\t \n\tif ((rdev->flags & RADEON_IS_PX) &&\n\t\t(ddev->switch_power_state != DRM_SWITCH_POWER_ON))\n\t\treturn -EINVAL;\n\n\tif (rdev->asic->dpm.get_current_vddc)\n\t\tvddc = rdev->asic->dpm.get_current_vddc(rdev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", vddc);\n}\n\nstatic SENSOR_DEVICE_ATTR(in0_input, S_IRUGO, radeon_hwmon_show_vddc, NULL,\n\t\t\t  0);\n\nstatic struct attribute *hwmon_attributes[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit.dev_attr.attr,\n\t&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,\n\t&sensor_dev_attr_pwm1.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_enable.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_max.dev_attr.attr,\n\t&sensor_dev_attr_freq1_input.dev_attr.attr,\n\t&sensor_dev_attr_in0_input.dev_attr.attr,\n\tNULL\n};\n\nstatic umode_t hwmon_attributes_visible(struct kobject *kobj,\n\t\t\t\t\tstruct attribute *attr, int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct radeon_device *rdev = dev_get_drvdata(dev);\n\tumode_t effective_mode = attr->mode;\n\n\t \n\tif (rdev->pm.pm_method != PM_METHOD_DPM &&\n\t    (attr == &sensor_dev_attr_temp1_crit.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_temp1_crit_hyst.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_enable.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_min.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_freq1_input.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_in0_input.dev_attr.attr))\n\t\treturn 0;\n\n\t \n\tif(attr == &sensor_dev_attr_in0_input.dev_attr.attr &&\n\t\t!rdev->asic->dpm.get_current_vddc)\n\t\treturn 0;\n\n\t \n\tif (rdev->pm.no_fan &&\n\t    (attr == &sensor_dev_attr_pwm1.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_enable.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\n\t\treturn 0;\n\n\t \n\tif ((!rdev->asic->dpm.get_fan_speed_percent &&\n\t     attr == &sensor_dev_attr_pwm1.dev_attr.attr) ||  \n\t    (!rdev->asic->dpm.fan_ctrl_get_mode &&\n\t     attr == &sensor_dev_attr_pwm1_enable.dev_attr.attr))  \n\t\teffective_mode &= ~S_IRUGO;\n\n\tif ((!rdev->asic->dpm.set_fan_speed_percent &&\n\t     attr == &sensor_dev_attr_pwm1.dev_attr.attr) ||  \n\t    (!rdev->asic->dpm.fan_ctrl_set_mode &&\n\t     attr == &sensor_dev_attr_pwm1_enable.dev_attr.attr))  \n\t\teffective_mode &= ~S_IWUSR;\n\n\t \n\tif ((!rdev->asic->dpm.set_fan_speed_percent &&\n\t     !rdev->asic->dpm.get_fan_speed_percent) &&\n\t    (attr == &sensor_dev_attr_pwm1_max.dev_attr.attr ||\n\t     attr == &sensor_dev_attr_pwm1_min.dev_attr.attr))\n\t\treturn 0;\n\n\treturn effective_mode;\n}\n\nstatic const struct attribute_group hwmon_attrgroup = {\n\t.attrs = hwmon_attributes,\n\t.is_visible = hwmon_attributes_visible,\n};\n\nstatic const struct attribute_group *hwmon_groups[] = {\n\t&hwmon_attrgroup,\n\tNULL\n};\n\nstatic int radeon_hwmon_init(struct radeon_device *rdev)\n{\n\tint err = 0;\n\n\tswitch (rdev->pm.int_thermal_type) {\n\tcase THERMAL_TYPE_RV6XX:\n\tcase THERMAL_TYPE_RV770:\n\tcase THERMAL_TYPE_EVERGREEN:\n\tcase THERMAL_TYPE_NI:\n\tcase THERMAL_TYPE_SUMO:\n\tcase THERMAL_TYPE_SI:\n\tcase THERMAL_TYPE_CI:\n\tcase THERMAL_TYPE_KV:\n\t\tif (rdev->asic->pm.get_temperature == NULL)\n\t\t\treturn err;\n\t\trdev->pm.int_hwmon_dev = hwmon_device_register_with_groups(rdev->dev,\n\t\t\t\t\t\t\t\t\t   \"radeon\", rdev,\n\t\t\t\t\t\t\t\t\t   hwmon_groups);\n\t\tif (IS_ERR(rdev->pm.int_hwmon_dev)) {\n\t\t\terr = PTR_ERR(rdev->pm.int_hwmon_dev);\n\t\t\tdev_err(rdev->dev,\n\t\t\t\t\"Unable to register hwmon device: %d\\n\", err);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void radeon_hwmon_fini(struct radeon_device *rdev)\n{\n\tif (rdev->pm.int_hwmon_dev)\n\t\thwmon_device_unregister(rdev->pm.int_hwmon_dev);\n}\n\nstatic void radeon_dpm_thermal_work_handler(struct work_struct *work)\n{\n\tstruct radeon_device *rdev =\n\t\tcontainer_of(work, struct radeon_device,\n\t\t\t     pm.dpm.thermal.work);\n\t \n\tenum radeon_pm_state_type dpm_state = POWER_STATE_TYPE_INTERNAL_THERMAL;\n\n\tif (!rdev->pm.dpm_enabled)\n\t\treturn;\n\n\tif (rdev->asic->pm.get_temperature) {\n\t\tint temp = radeon_get_temperature(rdev);\n\n\t\tif (temp < rdev->pm.dpm.thermal.min_temp)\n\t\t\t \n\t\t\tdpm_state = rdev->pm.dpm.user_state;\n\t} else {\n\t\tif (rdev->pm.dpm.thermal.high_to_low)\n\t\t\t \n\t\t\tdpm_state = rdev->pm.dpm.user_state;\n\t}\n\tmutex_lock(&rdev->pm.mutex);\n\tif (dpm_state == POWER_STATE_TYPE_INTERNAL_THERMAL)\n\t\trdev->pm.dpm.thermal_active = true;\n\telse\n\t\trdev->pm.dpm.thermal_active = false;\n\trdev->pm.dpm.state = dpm_state;\n\tmutex_unlock(&rdev->pm.mutex);\n\n\tradeon_pm_compute_clocks(rdev);\n}\n\nstatic bool radeon_dpm_single_display(struct radeon_device *rdev)\n{\n\tbool single_display = (rdev->pm.dpm.new_active_crtc_count < 2) ?\n\t\ttrue : false;\n\n\t \n\tif (single_display && rdev->asic->dpm.vblank_too_short) {\n\t\tif (radeon_dpm_vblank_too_short(rdev))\n\t\t\tsingle_display = false;\n\t}\n\n\t \n\tif (single_display && (r600_dpm_get_vrefresh(rdev) >= 120))\n\t\tsingle_display = false;\n\n\treturn single_display;\n}\n\nstatic struct radeon_ps *radeon_dpm_pick_power_state(struct radeon_device *rdev,\n\t\t\t\t\t\t     enum radeon_pm_state_type dpm_state)\n{\n\tint i;\n\tstruct radeon_ps *ps;\n\tu32 ui_class;\n\tbool single_display = radeon_dpm_single_display(rdev);\n\n\t \n\tif (dpm_state == POWER_STATE_TYPE_PERFORMANCE)\n\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_3DPERF;\n\t \n\tif (dpm_state == POWER_STATE_TYPE_BALANCED)\n\t\tdpm_state = POWER_STATE_TYPE_PERFORMANCE;\n\nrestart_search:\n\t \n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tps = &rdev->pm.dpm.ps[i];\n\t\tui_class = ps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK;\n\t\tswitch (dpm_state) {\n\t\t \n\t\tcase POWER_STATE_TYPE_BATTERY:\n\t\t\tif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY) {\n\t\t\t\tif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\n\t\t\t\t\tif (single_display)\n\t\t\t\t\t\treturn ps;\n\t\t\t\t} else\n\t\t\t\t\treturn ps;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_BALANCED:\n\t\t\tif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BALANCED) {\n\t\t\t\tif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\n\t\t\t\t\tif (single_display)\n\t\t\t\t\t\treturn ps;\n\t\t\t\t} else\n\t\t\t\t\treturn ps;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_PERFORMANCE:\n\t\t\tif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\n\t\t\t\tif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\n\t\t\t\t\tif (single_display)\n\t\t\t\t\t\treturn ps;\n\t\t\t\t} else\n\t\t\t\t\treturn ps;\n\t\t\t}\n\t\t\tbreak;\n\t\t \n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD:\n\t\t\tif (rdev->pm.dpm.uvd_ps)\n\t\t\t\treturn rdev->pm.dpm.uvd_ps;\n\t\t\telse\n\t\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_SD:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\n\t\t\tif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_BOOT:\n\t\t\treturn rdev->pm.dpm.boot_ps;\n\t\tcase POWER_STATE_TYPE_INTERNAL_THERMAL:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_ACPI:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_ULV:\n\t\t\tif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_3DPERF:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tswitch (dpm_state) {\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_SD:\n\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\n\t\tgoto restart_search;\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD:\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\n\t\tif (rdev->pm.dpm.uvd_ps) {\n\t\t\treturn rdev->pm.dpm.uvd_ps;\n\t\t} else {\n\t\t\tdpm_state = POWER_STATE_TYPE_PERFORMANCE;\n\t\t\tgoto restart_search;\n\t\t}\n\tcase POWER_STATE_TYPE_INTERNAL_THERMAL:\n\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_ACPI;\n\t\tgoto restart_search;\n\tcase POWER_STATE_TYPE_INTERNAL_ACPI:\n\t\tdpm_state = POWER_STATE_TYPE_BATTERY;\n\t\tgoto restart_search;\n\tcase POWER_STATE_TYPE_BATTERY:\n\tcase POWER_STATE_TYPE_BALANCED:\n\tcase POWER_STATE_TYPE_INTERNAL_3DPERF:\n\t\tdpm_state = POWER_STATE_TYPE_PERFORMANCE;\n\t\tgoto restart_search;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic void radeon_dpm_change_power_state_locked(struct radeon_device *rdev)\n{\n\tint i;\n\tstruct radeon_ps *ps;\n\tenum radeon_pm_state_type dpm_state;\n\tint ret;\n\tbool single_display = radeon_dpm_single_display(rdev);\n\n\t \n\tif (!rdev->pm.dpm_enabled)\n\t\treturn;\n\n\tif (rdev->pm.dpm.user_state != rdev->pm.dpm.state) {\n\t\t \n\t\tif ((!rdev->pm.dpm.thermal_active) &&\n\t\t    (!rdev->pm.dpm.uvd_active))\n\t\t\trdev->pm.dpm.state = rdev->pm.dpm.user_state;\n\t}\n\tdpm_state = rdev->pm.dpm.state;\n\n\tps = radeon_dpm_pick_power_state(rdev, dpm_state);\n\tif (ps)\n\t\trdev->pm.dpm.requested_ps = ps;\n\telse\n\t\treturn;\n\n\t \n\tif (rdev->pm.dpm.current_ps == rdev->pm.dpm.requested_ps) {\n\t\t \n\t\tif (ps->vce_active != rdev->pm.dpm.vce_active)\n\t\t\tgoto force;\n\t\t \n\t\tif (rdev->pm.dpm.single_display != single_display)\n\t\t\tgoto force;\n\t\tif ((rdev->family < CHIP_BARTS) || (rdev->flags & RADEON_IS_IGP)) {\n\t\t\t \n\t\t\tif (rdev->pm.dpm.new_active_crtcs != rdev->pm.dpm.current_active_crtcs) {\n\t\t\t\t \n\t\t\t\tradeon_bandwidth_update(rdev);\n\t\t\t\t \n\t\t\t\tradeon_dpm_display_configuration_changed(rdev);\n\t\t\t\trdev->pm.dpm.current_active_crtcs = rdev->pm.dpm.new_active_crtcs;\n\t\t\t\trdev->pm.dpm.current_active_crtc_count = rdev->pm.dpm.new_active_crtc_count;\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\tif (rdev->pm.dpm.new_active_crtcs ==\n\t\t\t    rdev->pm.dpm.current_active_crtcs) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tif ((rdev->pm.dpm.current_active_crtc_count > 1) &&\n\t\t\t\t    (rdev->pm.dpm.new_active_crtc_count > 1)) {\n\t\t\t\t\t \n\t\t\t\t\tradeon_bandwidth_update(rdev);\n\t\t\t\t\t \n\t\t\t\t\tradeon_dpm_display_configuration_changed(rdev);\n\t\t\t\t\trdev->pm.dpm.current_active_crtcs = rdev->pm.dpm.new_active_crtcs;\n\t\t\t\t\trdev->pm.dpm.current_active_crtc_count = rdev->pm.dpm.new_active_crtc_count;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nforce:\n\tif (radeon_dpm == 1) {\n\t\tprintk(\"switching from power state:\\n\");\n\t\tradeon_dpm_print_power_state(rdev, rdev->pm.dpm.current_ps);\n\t\tprintk(\"switching to power state:\\n\");\n\t\tradeon_dpm_print_power_state(rdev, rdev->pm.dpm.requested_ps);\n\t}\n\n\tdown_write(&rdev->pm.mclk_lock);\n\tmutex_lock(&rdev->ring_lock);\n\n\t \n\tps->vce_active = rdev->pm.dpm.vce_active;\n\n\tret = radeon_dpm_pre_set_power_state(rdev);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tradeon_bandwidth_update(rdev);\n\t \n\tradeon_dpm_display_configuration_changed(rdev);\n\n\t \n\tfor (i = 0; i < RADEON_NUM_RINGS; i++) {\n\t\tstruct radeon_ring *ring = &rdev->ring[i];\n\t\tif (ring->ready)\n\t\t\tradeon_fence_wait_empty(rdev, i);\n\t}\n\n\t \n\tradeon_dpm_set_power_state(rdev);\n\n\t \n\trdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps;\n\n\tradeon_dpm_post_set_power_state(rdev);\n\n\trdev->pm.dpm.current_active_crtcs = rdev->pm.dpm.new_active_crtcs;\n\trdev->pm.dpm.current_active_crtc_count = rdev->pm.dpm.new_active_crtc_count;\n\trdev->pm.dpm.single_display = single_display;\n\n\tif (rdev->asic->dpm.force_performance_level) {\n\t\tif (rdev->pm.dpm.thermal_active) {\n\t\t\tenum radeon_dpm_forced_level level = rdev->pm.dpm.forced_level;\n\t\t\t \n\t\t\tradeon_dpm_force_performance_level(rdev, RADEON_DPM_FORCED_LEVEL_LOW);\n\t\t\t \n\t\t\trdev->pm.dpm.forced_level = level;\n\t\t} else {\n\t\t\t \n\t\t\tradeon_dpm_force_performance_level(rdev, rdev->pm.dpm.forced_level);\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&rdev->ring_lock);\n\tup_write(&rdev->pm.mclk_lock);\n}\n\nvoid radeon_dpm_enable_uvd(struct radeon_device *rdev, bool enable)\n{\n\tenum radeon_pm_state_type dpm_state;\n\n\tif (rdev->asic->dpm.powergate_uvd) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\t \n\t\tenable |= rdev->pm.dpm.sd > 0;\n\t\tenable |= rdev->pm.dpm.hd > 0;\n\t\t \n\t\tradeon_dpm_powergate_uvd(rdev, !enable);\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t} else {\n\t\tif (enable) {\n\t\t\tmutex_lock(&rdev->pm.mutex);\n\t\t\trdev->pm.dpm.uvd_active = true;\n\t\t\t \n#if 0\n\t\t\tif ((rdev->pm.dpm.sd == 1) && (rdev->pm.dpm.hd == 0))\n\t\t\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD_SD;\n\t\t\telse if ((rdev->pm.dpm.sd == 2) && (rdev->pm.dpm.hd == 0))\n\t\t\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\n\t\t\telse if ((rdev->pm.dpm.sd == 0) && (rdev->pm.dpm.hd == 1))\n\t\t\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\n\t\t\telse if ((rdev->pm.dpm.sd == 0) && (rdev->pm.dpm.hd == 2))\n\t\t\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD2;\n\t\t\telse\n#endif\n\t\t\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD;\n\t\t\trdev->pm.dpm.state = dpm_state;\n\t\t\tmutex_unlock(&rdev->pm.mutex);\n\t\t} else {\n\t\t\tmutex_lock(&rdev->pm.mutex);\n\t\t\trdev->pm.dpm.uvd_active = false;\n\t\t\tmutex_unlock(&rdev->pm.mutex);\n\t\t}\n\n\t\tradeon_pm_compute_clocks(rdev);\n\t}\n}\n\nvoid radeon_dpm_enable_vce(struct radeon_device *rdev, bool enable)\n{\n\tif (enable) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\trdev->pm.dpm.vce_active = true;\n\t\t \n\t\trdev->pm.dpm.vce_level = RADEON_VCE_LEVEL_AC_ALL;\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t} else {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\trdev->pm.dpm.vce_active = false;\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t}\n\n\tradeon_pm_compute_clocks(rdev);\n}\n\nstatic void radeon_pm_suspend_old(struct radeon_device *rdev)\n{\n\tmutex_lock(&rdev->pm.mutex);\n\tif (rdev->pm.pm_method == PM_METHOD_DYNPM) {\n\t\tif (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE)\n\t\t\trdev->pm.dynpm_state = DYNPM_STATE_SUSPENDED;\n\t}\n\tmutex_unlock(&rdev->pm.mutex);\n\n\tcancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);\n}\n\nstatic void radeon_pm_suspend_dpm(struct radeon_device *rdev)\n{\n\tmutex_lock(&rdev->pm.mutex);\n\t \n\tradeon_dpm_disable(rdev);\n\t \n\trdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps = rdev->pm.dpm.boot_ps;\n\trdev->pm.dpm_enabled = false;\n\tmutex_unlock(&rdev->pm.mutex);\n}\n\nvoid radeon_pm_suspend(struct radeon_device *rdev)\n{\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_suspend_dpm(rdev);\n\telse\n\t\tradeon_pm_suspend_old(rdev);\n}\n\nstatic void radeon_pm_resume_old(struct radeon_device *rdev)\n{\n\t \n\tif ((rdev->family >= CHIP_BARTS) &&\n\t    (rdev->family <= CHIP_CAYMAN) &&\n\t    rdev->mc_fw) {\n\t\tif (rdev->pm.default_vddc)\n\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\n\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDC);\n\t\tif (rdev->pm.default_vddci)\n\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\n\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDCI);\n\t\tif (rdev->pm.default_sclk)\n\t\t\tradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\n\t\tif (rdev->pm.default_mclk)\n\t\t\tradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\n\t}\n\t \n\tmutex_lock(&rdev->pm.mutex);\n\trdev->pm.current_power_state_index = rdev->pm.default_power_state_index;\n\trdev->pm.current_clock_mode_index = 0;\n\trdev->pm.current_sclk = rdev->pm.default_sclk;\n\trdev->pm.current_mclk = rdev->pm.default_mclk;\n\tif (rdev->pm.power_state) {\n\t\trdev->pm.current_vddc = rdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.voltage;\n\t\trdev->pm.current_vddci = rdev->pm.power_state[rdev->pm.default_power_state_index].clock_info[0].voltage.vddci;\n\t}\n\tif (rdev->pm.pm_method == PM_METHOD_DYNPM\n\t    && rdev->pm.dynpm_state == DYNPM_STATE_SUSPENDED) {\n\t\trdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;\n\t\tschedule_delayed_work(&rdev->pm.dynpm_idle_work,\n\t\t\t\t      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));\n\t}\n\tmutex_unlock(&rdev->pm.mutex);\n\tradeon_pm_compute_clocks(rdev);\n}\n\nstatic void radeon_pm_resume_dpm(struct radeon_device *rdev)\n{\n\tint ret;\n\n\t \n\tmutex_lock(&rdev->pm.mutex);\n\trdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps = rdev->pm.dpm.boot_ps;\n\tradeon_dpm_setup_asic(rdev);\n\tret = radeon_dpm_enable(rdev);\n\tmutex_unlock(&rdev->pm.mutex);\n\tif (ret)\n\t\tgoto dpm_resume_fail;\n\trdev->pm.dpm_enabled = true;\n\treturn;\n\ndpm_resume_fail:\n\tDRM_ERROR(\"radeon: dpm resume failed\\n\");\n\tif ((rdev->family >= CHIP_BARTS) &&\n\t    (rdev->family <= CHIP_CAYMAN) &&\n\t    rdev->mc_fw) {\n\t\tif (rdev->pm.default_vddc)\n\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\n\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDC);\n\t\tif (rdev->pm.default_vddci)\n\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\n\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDCI);\n\t\tif (rdev->pm.default_sclk)\n\t\t\tradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\n\t\tif (rdev->pm.default_mclk)\n\t\t\tradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\n\t}\n}\n\nvoid radeon_pm_resume(struct radeon_device *rdev)\n{\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_resume_dpm(rdev);\n\telse\n\t\tradeon_pm_resume_old(rdev);\n}\n\nstatic int radeon_pm_init_old(struct radeon_device *rdev)\n{\n\tint ret;\n\n\trdev->pm.profile = PM_PROFILE_DEFAULT;\n\trdev->pm.dynpm_state = DYNPM_STATE_DISABLED;\n\trdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\n\trdev->pm.dynpm_can_upclock = true;\n\trdev->pm.dynpm_can_downclock = true;\n\trdev->pm.default_sclk = rdev->clock.default_sclk;\n\trdev->pm.default_mclk = rdev->clock.default_mclk;\n\trdev->pm.current_sclk = rdev->clock.default_sclk;\n\trdev->pm.current_mclk = rdev->clock.default_mclk;\n\trdev->pm.int_thermal_type = THERMAL_TYPE_NONE;\n\n\tif (rdev->bios) {\n\t\tif (rdev->is_atom_bios)\n\t\t\tradeon_atombios_get_power_modes(rdev);\n\t\telse\n\t\t\tradeon_combios_get_power_modes(rdev);\n\t\tradeon_pm_print_states(rdev);\n\t\tradeon_pm_init_profile(rdev);\n\t\t \n\t\tif ((rdev->family >= CHIP_BARTS) &&\n\t\t    (rdev->family <= CHIP_CAYMAN) &&\n\t\t    rdev->mc_fw) {\n\t\t\tif (rdev->pm.default_vddc)\n\t\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\n\t\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDC);\n\t\t\tif (rdev->pm.default_vddci)\n\t\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\n\t\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDCI);\n\t\t\tif (rdev->pm.default_sclk)\n\t\t\t\tradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\n\t\t\tif (rdev->pm.default_mclk)\n\t\t\t\tradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\n\t\t}\n\t}\n\n\t \n\tret = radeon_hwmon_init(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_DELAYED_WORK(&rdev->pm.dynpm_idle_work, radeon_dynpm_idle_work_handler);\n\n\tif (rdev->pm.num_power_states > 1) {\n\t\tradeon_debugfs_pm_init(rdev);\n\t\tDRM_INFO(\"radeon: power management initialized\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void radeon_dpm_print_power_states(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tprintk(\"== power state %d ==\\n\", i);\n\t\tradeon_dpm_print_power_state(rdev, &rdev->pm.dpm.ps[i]);\n\t}\n}\n\nstatic int radeon_pm_init_dpm(struct radeon_device *rdev)\n{\n\tint ret;\n\n\t \n\trdev->pm.dpm.state = POWER_STATE_TYPE_BALANCED;\n\trdev->pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;\n\trdev->pm.dpm.forced_level = RADEON_DPM_FORCED_LEVEL_AUTO;\n\trdev->pm.default_sclk = rdev->clock.default_sclk;\n\trdev->pm.default_mclk = rdev->clock.default_mclk;\n\trdev->pm.current_sclk = rdev->clock.default_sclk;\n\trdev->pm.current_mclk = rdev->clock.default_mclk;\n\trdev->pm.int_thermal_type = THERMAL_TYPE_NONE;\n\n\tif (rdev->bios && rdev->is_atom_bios)\n\t\tradeon_atombios_get_power_modes(rdev);\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tret = radeon_hwmon_init(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&rdev->pm.dpm.thermal.work, radeon_dpm_thermal_work_handler);\n\tmutex_lock(&rdev->pm.mutex);\n\tradeon_dpm_init(rdev);\n\trdev->pm.dpm.current_ps = rdev->pm.dpm.requested_ps = rdev->pm.dpm.boot_ps;\n\tif (radeon_dpm == 1)\n\t\tradeon_dpm_print_power_states(rdev);\n\tradeon_dpm_setup_asic(rdev);\n\tret = radeon_dpm_enable(rdev);\n\tmutex_unlock(&rdev->pm.mutex);\n\tif (ret)\n\t\tgoto dpm_failed;\n\trdev->pm.dpm_enabled = true;\n\n\tradeon_debugfs_pm_init(rdev);\n\n\tDRM_INFO(\"radeon: dpm initialized\\n\");\n\n\treturn 0;\n\ndpm_failed:\n\trdev->pm.dpm_enabled = false;\n\tif ((rdev->family >= CHIP_BARTS) &&\n\t    (rdev->family <= CHIP_CAYMAN) &&\n\t    rdev->mc_fw) {\n\t\tif (rdev->pm.default_vddc)\n\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddc,\n\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDC);\n\t\tif (rdev->pm.default_vddci)\n\t\t\tradeon_atom_set_voltage(rdev, rdev->pm.default_vddci,\n\t\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDCI);\n\t\tif (rdev->pm.default_sclk)\n\t\t\tradeon_set_engine_clock(rdev, rdev->pm.default_sclk);\n\t\tif (rdev->pm.default_mclk)\n\t\t\tradeon_set_memory_clock(rdev, rdev->pm.default_mclk);\n\t}\n\tDRM_ERROR(\"radeon: dpm initialization failed\\n\");\n\treturn ret;\n}\n\nstruct radeon_dpm_quirk {\n\tu32 chip_vendor;\n\tu32 chip_device;\n\tu32 subsys_vendor;\n\tu32 subsys_device;\n};\n\n \nstatic struct radeon_dpm_quirk radeon_dpm_quirk_list[] = {\n\t \n\t{ PCI_VENDOR_ID_ATI, 0x6759, 0x1682, 0x3195 },\n\t \n\t{ PCI_VENDOR_ID_ATI, 0x6840, 0x1179, 0xfb81 },\n\t{ 0, 0, 0, 0 },\n};\n\nint radeon_pm_init(struct radeon_device *rdev)\n{\n\tstruct radeon_dpm_quirk *p = radeon_dpm_quirk_list;\n\tbool disable_dpm = false;\n\n\t \n\twhile (p && p->chip_device != 0) {\n\t\tif (rdev->pdev->vendor == p->chip_vendor &&\n\t\t    rdev->pdev->device == p->chip_device &&\n\t\t    rdev->pdev->subsystem_vendor == p->subsys_vendor &&\n\t\t    rdev->pdev->subsystem_device == p->subsys_device) {\n\t\t\tdisable_dpm = true;\n\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\n\t \n\tswitch (rdev->family) {\n\tcase CHIP_RV610:\n\tcase CHIP_RV630:\n\tcase CHIP_RV620:\n\tcase CHIP_RV635:\n\tcase CHIP_RV670:\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\tcase CHIP_RV770:\n\t\t \n\t\tif (!rdev->rlc_fw)\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\telse if ((rdev->family >= CHIP_RV770) &&\n\t\t\t (!(rdev->flags & RADEON_IS_IGP)) &&\n\t\t\t (!rdev->smc_fw))\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\telse if (radeon_dpm == 1)\n\t\t\trdev->pm.pm_method = PM_METHOD_DPM;\n\t\telse\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\tbreak;\n\tcase CHIP_RV730:\n\tcase CHIP_RV710:\n\tcase CHIP_RV740:\n\tcase CHIP_CEDAR:\n\tcase CHIP_REDWOOD:\n\tcase CHIP_JUNIPER:\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\tcase CHIP_PALM:\n\tcase CHIP_SUMO:\n\tcase CHIP_SUMO2:\n\tcase CHIP_BARTS:\n\tcase CHIP_TURKS:\n\tcase CHIP_CAICOS:\n\tcase CHIP_CAYMAN:\n\tcase CHIP_ARUBA:\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\tcase CHIP_OLAND:\n\tcase CHIP_HAINAN:\n\tcase CHIP_BONAIRE:\n\tcase CHIP_KABINI:\n\tcase CHIP_KAVERI:\n\tcase CHIP_HAWAII:\n\tcase CHIP_MULLINS:\n\t\t \n\t\tif (!rdev->rlc_fw)\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\telse if ((rdev->family >= CHIP_RV770) &&\n\t\t\t (!(rdev->flags & RADEON_IS_IGP)) &&\n\t\t\t (!rdev->smc_fw))\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\telse if (disable_dpm && (radeon_dpm == -1))\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\telse if (radeon_dpm == 0)\n\t\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\telse\n\t\t\trdev->pm.pm_method = PM_METHOD_DPM;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\trdev->pm.pm_method = PM_METHOD_PROFILE;\n\t\tbreak;\n\t}\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\treturn radeon_pm_init_dpm(rdev);\n\telse\n\t\treturn radeon_pm_init_old(rdev);\n}\n\nint radeon_pm_late_init(struct radeon_device *rdev)\n{\n\tint ret = 0;\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM) {\n\t\tif (rdev->pm.dpm_enabled) {\n\t\t\tif (!rdev->pm.sysfs_initialized) {\n\t\t\t\tret = device_create_file(rdev->dev, &dev_attr_power_dpm_state);\n\t\t\t\tif (ret)\n\t\t\t\t\tDRM_ERROR(\"failed to create device file for dpm state\\n\");\n\t\t\t\tret = device_create_file(rdev->dev, &dev_attr_power_dpm_force_performance_level);\n\t\t\t\tif (ret)\n\t\t\t\t\tDRM_ERROR(\"failed to create device file for dpm state\\n\");\n\t\t\t\t \n\t\t\t\tret = device_create_file(rdev->dev, &dev_attr_power_profile);\n\t\t\t\tif (ret)\n\t\t\t\t\tDRM_ERROR(\"failed to create device file for power profile\\n\");\n\t\t\t\tret = device_create_file(rdev->dev, &dev_attr_power_method);\n\t\t\t\tif (ret)\n\t\t\t\t\tDRM_ERROR(\"failed to create device file for power method\\n\");\n\t\t\t\trdev->pm.sysfs_initialized = true;\n\t\t\t}\n\n\t\t\tmutex_lock(&rdev->pm.mutex);\n\t\t\tret = radeon_dpm_late_enable(rdev);\n\t\t\tmutex_unlock(&rdev->pm.mutex);\n\t\t\tif (ret) {\n\t\t\t\trdev->pm.dpm_enabled = false;\n\t\t\t\tDRM_ERROR(\"radeon_pm_late_init failed, disabling dpm\\n\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tradeon_pm_compute_clocks(rdev);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((rdev->pm.num_power_states > 1) &&\n\t\t    (!rdev->pm.sysfs_initialized)) {\n\t\t\t \n\t\t\tret = device_create_file(rdev->dev, &dev_attr_power_profile);\n\t\t\tif (ret)\n\t\t\t\tDRM_ERROR(\"failed to create device file for power profile\\n\");\n\t\t\tret = device_create_file(rdev->dev, &dev_attr_power_method);\n\t\t\tif (ret)\n\t\t\t\tDRM_ERROR(\"failed to create device file for power method\\n\");\n\t\t\telse\n\t\t\t\trdev->pm.sysfs_initialized = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void radeon_pm_fini_old(struct radeon_device *rdev)\n{\n\tif (rdev->pm.num_power_states > 1) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\tif (rdev->pm.pm_method == PM_METHOD_PROFILE) {\n\t\t\trdev->pm.profile = PM_PROFILE_DEFAULT;\n\t\t\tradeon_pm_update_profile(rdev);\n\t\t\tradeon_pm_set_clocks(rdev);\n\t\t} else if (rdev->pm.pm_method == PM_METHOD_DYNPM) {\n\t\t\t \n\t\t\trdev->pm.dynpm_state = DYNPM_STATE_DISABLED;\n\t\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;\n\t\t\tradeon_pm_set_clocks(rdev);\n\t\t}\n\t\tmutex_unlock(&rdev->pm.mutex);\n\n\t\tcancel_delayed_work_sync(&rdev->pm.dynpm_idle_work);\n\n\t\tdevice_remove_file(rdev->dev, &dev_attr_power_profile);\n\t\tdevice_remove_file(rdev->dev, &dev_attr_power_method);\n\t}\n\n\tradeon_hwmon_fini(rdev);\n\tkfree(rdev->pm.power_state);\n}\n\nstatic void radeon_pm_fini_dpm(struct radeon_device *rdev)\n{\n\tif (rdev->pm.num_power_states > 1) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\tradeon_dpm_disable(rdev);\n\t\tmutex_unlock(&rdev->pm.mutex);\n\n\t\tdevice_remove_file(rdev->dev, &dev_attr_power_dpm_state);\n\t\tdevice_remove_file(rdev->dev, &dev_attr_power_dpm_force_performance_level);\n\t\t \n\t\tdevice_remove_file(rdev->dev, &dev_attr_power_profile);\n\t\tdevice_remove_file(rdev->dev, &dev_attr_power_method);\n\t}\n\tradeon_dpm_fini(rdev);\n\n\tradeon_hwmon_fini(rdev);\n\tkfree(rdev->pm.power_state);\n}\n\nvoid radeon_pm_fini(struct radeon_device *rdev)\n{\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_fini_dpm(rdev);\n\telse\n\t\tradeon_pm_fini_old(rdev);\n}\n\nstatic void radeon_pm_compute_clocks_old(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\n\tif (rdev->pm.num_power_states < 2)\n\t\treturn;\n\n\tmutex_lock(&rdev->pm.mutex);\n\n\trdev->pm.active_crtcs = 0;\n\trdev->pm.active_crtc_count = 0;\n\tif (rdev->num_crtc && rdev->mode_info.mode_config_initialized) {\n\t\tlist_for_each_entry(crtc,\n\t\t\t\t    &ddev->mode_config.crtc_list, head) {\n\t\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\t\tif (radeon_crtc->enabled) {\n\t\t\t\trdev->pm.active_crtcs |= (1 << radeon_crtc->crtc_id);\n\t\t\t\trdev->pm.active_crtc_count++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rdev->pm.pm_method == PM_METHOD_PROFILE) {\n\t\tradeon_pm_update_profile(rdev);\n\t\tradeon_pm_set_clocks(rdev);\n\t} else if (rdev->pm.pm_method == PM_METHOD_DYNPM) {\n\t\tif (rdev->pm.dynpm_state != DYNPM_STATE_DISABLED) {\n\t\t\tif (rdev->pm.active_crtc_count > 1) {\n\t\t\t\tif (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE) {\n\t\t\t\t\tcancel_delayed_work(&rdev->pm.dynpm_idle_work);\n\n\t\t\t\t\trdev->pm.dynpm_state = DYNPM_STATE_PAUSED;\n\t\t\t\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_DEFAULT;\n\t\t\t\t\tradeon_pm_get_dynpm_state(rdev);\n\t\t\t\t\tradeon_pm_set_clocks(rdev);\n\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"radeon: dynamic power management deactivated\\n\");\n\t\t\t\t}\n\t\t\t} else if (rdev->pm.active_crtc_count == 1) {\n\t\t\t\t \n\n\t\t\t\tif (rdev->pm.dynpm_state == DYNPM_STATE_MINIMUM) {\n\t\t\t\t\trdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;\n\t\t\t\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_UPCLOCK;\n\t\t\t\t\tradeon_pm_get_dynpm_state(rdev);\n\t\t\t\t\tradeon_pm_set_clocks(rdev);\n\n\t\t\t\t\tschedule_delayed_work(&rdev->pm.dynpm_idle_work,\n\t\t\t\t\t\t\t      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));\n\t\t\t\t} else if (rdev->pm.dynpm_state == DYNPM_STATE_PAUSED) {\n\t\t\t\t\trdev->pm.dynpm_state = DYNPM_STATE_ACTIVE;\n\t\t\t\t\tschedule_delayed_work(&rdev->pm.dynpm_idle_work,\n\t\t\t\t\t\t\t      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"radeon: dynamic power management activated\\n\");\n\t\t\t\t}\n\t\t\t} else {  \n\t\t\t\tif (rdev->pm.dynpm_state != DYNPM_STATE_MINIMUM) {\n\t\t\t\t\tcancel_delayed_work(&rdev->pm.dynpm_idle_work);\n\n\t\t\t\t\trdev->pm.dynpm_state = DYNPM_STATE_MINIMUM;\n\t\t\t\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_MINIMUM;\n\t\t\t\t\tradeon_pm_get_dynpm_state(rdev);\n\t\t\t\t\tradeon_pm_set_clocks(rdev);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&rdev->pm.mutex);\n}\n\nstatic void radeon_pm_compute_clocks_dpm(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tstruct radeon_connector *radeon_connector;\n\n\tif (!rdev->pm.dpm_enabled)\n\t\treturn;\n\n\tmutex_lock(&rdev->pm.mutex);\n\n\t \n\trdev->pm.dpm.new_active_crtcs = 0;\n\trdev->pm.dpm.new_active_crtc_count = 0;\n\trdev->pm.dpm.high_pixelclock_count = 0;\n\tif (rdev->num_crtc && rdev->mode_info.mode_config_initialized) {\n\t\tlist_for_each_entry(crtc,\n\t\t\t\t    &ddev->mode_config.crtc_list, head) {\n\t\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\t\tif (crtc->enabled) {\n\t\t\t\trdev->pm.dpm.new_active_crtcs |= (1 << radeon_crtc->crtc_id);\n\t\t\t\trdev->pm.dpm.new_active_crtc_count++;\n\t\t\t\tif (!radeon_crtc->connector)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tradeon_connector = to_radeon_connector(radeon_crtc->connector);\n\t\t\t\tif (radeon_connector->pixelclock_for_modeset > 297000)\n\t\t\t\t\trdev->pm.dpm.high_pixelclock_count++;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (power_supply_is_system_supplied() > 0)\n\t\trdev->pm.dpm.ac_power = true;\n\telse\n\t\trdev->pm.dpm.ac_power = false;\n\n\tradeon_dpm_change_power_state_locked(rdev);\n\n\tmutex_unlock(&rdev->pm.mutex);\n\n}\n\nvoid radeon_pm_compute_clocks(struct radeon_device *rdev)\n{\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_compute_clocks_dpm(rdev);\n\telse\n\t\tradeon_pm_compute_clocks_old(rdev);\n}\n\nstatic bool radeon_pm_in_vbl(struct radeon_device *rdev)\n{\n\tint  crtc, vpos, hpos, vbl_status;\n\tbool in_vbl = true;\n\n\t \n\tfor (crtc = 0; (crtc < rdev->num_crtc) && in_vbl; crtc++) {\n\t\tif (rdev->pm.active_crtcs & (1 << crtc)) {\n\t\t\tvbl_status = radeon_get_crtc_scanoutpos(rdev->ddev,\n\t\t\t\t\t\t\t\tcrtc,\n\t\t\t\t\t\t\t\tUSE_REAL_VBLANKSTART,\n\t\t\t\t\t\t\t\t&vpos, &hpos, NULL, NULL,\n\t\t\t\t\t\t\t\t&rdev->mode_info.crtcs[crtc]->base.hwmode);\n\t\t\tif ((vbl_status & DRM_SCANOUTPOS_VALID) &&\n\t\t\t    !(vbl_status & DRM_SCANOUTPOS_IN_VBLANK))\n\t\t\t\tin_vbl = false;\n\t\t}\n\t}\n\n\treturn in_vbl;\n}\n\nstatic bool radeon_pm_debug_check_in_vbl(struct radeon_device *rdev, bool finish)\n{\n\tu32 stat_crtc = 0;\n\tbool in_vbl = radeon_pm_in_vbl(rdev);\n\n\tif (!in_vbl)\n\t\tDRM_DEBUG_DRIVER(\"not in vbl for pm change %08x at %s\\n\", stat_crtc,\n\t\t\t finish ? \"exit\" : \"entry\");\n\treturn in_vbl;\n}\n\nstatic void radeon_dynpm_idle_work_handler(struct work_struct *work)\n{\n\tstruct radeon_device *rdev;\n\n\trdev = container_of(work, struct radeon_device,\n\t\t\t\tpm.dynpm_idle_work.work);\n\n\tmutex_lock(&rdev->pm.mutex);\n\tif (rdev->pm.dynpm_state == DYNPM_STATE_ACTIVE) {\n\t\tint not_processed = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\t\tstruct radeon_ring *ring = &rdev->ring[i];\n\n\t\t\tif (ring->ready) {\n\t\t\t\tnot_processed += radeon_fence_count_emitted(rdev, i);\n\t\t\t\tif (not_processed >= 3)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (not_processed >= 3) {  \n\t\t\tif (rdev->pm.dynpm_planned_action == DYNPM_ACTION_DOWNCLOCK) {\n\t\t\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\n\t\t\t} else if (rdev->pm.dynpm_planned_action == DYNPM_ACTION_NONE &&\n\t\t\t\t   rdev->pm.dynpm_can_upclock) {\n\t\t\t\trdev->pm.dynpm_planned_action =\n\t\t\t\t\tDYNPM_ACTION_UPCLOCK;\n\t\t\t\trdev->pm.dynpm_action_timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(RADEON_RECLOCK_DELAY_MS);\n\t\t\t}\n\t\t} else if (not_processed == 0) {  \n\t\t\tif (rdev->pm.dynpm_planned_action == DYNPM_ACTION_UPCLOCK) {\n\t\t\t\trdev->pm.dynpm_planned_action = DYNPM_ACTION_NONE;\n\t\t\t} else if (rdev->pm.dynpm_planned_action == DYNPM_ACTION_NONE &&\n\t\t\t\t   rdev->pm.dynpm_can_downclock) {\n\t\t\t\trdev->pm.dynpm_planned_action =\n\t\t\t\t\tDYNPM_ACTION_DOWNCLOCK;\n\t\t\t\trdev->pm.dynpm_action_timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(RADEON_RECLOCK_DELAY_MS);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (rdev->pm.dynpm_planned_action != DYNPM_ACTION_NONE &&\n\t\t    time_after(jiffies, rdev->pm.dynpm_action_timeout)) {\n\t\t\tradeon_pm_get_dynpm_state(rdev);\n\t\t\tradeon_pm_set_clocks(rdev);\n\t\t}\n\n\t\tschedule_delayed_work(&rdev->pm.dynpm_idle_work,\n\t\t\t\t      msecs_to_jiffies(RADEON_IDLE_LOOP_MS));\n\t}\n\tmutex_unlock(&rdev->pm.mutex);\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\n\nstatic int radeon_debugfs_pm_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tstruct drm_device *ddev = rdev->ddev;\n\n\tif  ((rdev->flags & RADEON_IS_PX) &&\n\t     (ddev->switch_power_state != DRM_SWITCH_POWER_ON)) {\n\t\tseq_printf(m, \"PX asic powered off\\n\");\n\t} else if (rdev->pm.dpm_enabled) {\n\t\tmutex_lock(&rdev->pm.mutex);\n\t\tif (rdev->asic->dpm.debugfs_print_current_performance_level)\n\t\t\tradeon_dpm_debugfs_print_current_performance_level(rdev, m);\n\t\telse\n\t\t\tseq_printf(m, \"Debugfs support not implemented for this asic\\n\");\n\t\tmutex_unlock(&rdev->pm.mutex);\n\t} else {\n\t\tseq_printf(m, \"default engine clock: %u0 kHz\\n\", rdev->pm.default_sclk);\n\t\t \n\t\tif ((rdev->family >= CHIP_PALM) && (rdev->flags & RADEON_IS_IGP))\n\t\t\tseq_printf(m, \"current engine clock: %u0 kHz\\n\", rdev->pm.current_sclk);\n\t\telse\n\t\t\tseq_printf(m, \"current engine clock: %u0 kHz\\n\", radeon_get_engine_clock(rdev));\n\t\tseq_printf(m, \"default memory clock: %u0 kHz\\n\", rdev->pm.default_mclk);\n\t\tif (rdev->asic->pm.get_memory_clock)\n\t\t\tseq_printf(m, \"current memory clock: %u0 kHz\\n\", radeon_get_memory_clock(rdev));\n\t\tif (rdev->pm.current_vddc)\n\t\t\tseq_printf(m, \"voltage: %u mV\\n\", rdev->pm.current_vddc);\n\t\tif (rdev->asic->pm.get_pcie_lanes)\n\t\t\tseq_printf(m, \"PCIE lanes: %d\\n\", radeon_get_pcie_lanes(rdev));\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(radeon_debugfs_pm_info);\n#endif\n\nstatic void radeon_debugfs_pm_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"radeon_pm_info\", 0444, root, rdev,\n\t\t\t    &radeon_debugfs_pm_info_fops);\n\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}