{
  "module_name": "atombios_crtc.c",
  "hash_id": "5bee1b6dc36951e61b5fdf73232066534ce896ecb5ee2228f6713d582523a51e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/atombios_crtc.c",
  "human_readable_source": " \n\n#include <drm/drm_fixed.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon.h\"\n#include \"atom.h\"\n#include \"atom-bits.h\"\n\nstatic void atombios_overscan_setup(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_display_mode *mode,\n\t\t\t\t    struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tSET_CRTC_OVERSCAN_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_OverScan);\n\tint a1, a2;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\n\tswitch (radeon_crtc->rmx_type) {\n\tcase RMX_CENTER:\n\t\targs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\n\t\targs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - mode->crtc_vdisplay) / 2);\n\t\targs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\n\t\targs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - mode->crtc_hdisplay) / 2);\n\t\tbreak;\n\tcase RMX_ASPECT:\n\t\ta1 = mode->crtc_vdisplay * adjusted_mode->crtc_hdisplay;\n\t\ta2 = adjusted_mode->crtc_vdisplay * mode->crtc_hdisplay;\n\n\t\tif (a1 > a2) {\n\t\t\targs.usOverscanLeft = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\n\t\t\targs.usOverscanRight = cpu_to_le16((adjusted_mode->crtc_hdisplay - (a2 / mode->crtc_vdisplay)) / 2);\n\t\t} else if (a2 > a1) {\n\t\t\targs.usOverscanTop = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\n\t\t\targs.usOverscanBottom = cpu_to_le16((adjusted_mode->crtc_vdisplay - (a1 / mode->crtc_hdisplay)) / 2);\n\t\t}\n\t\tbreak;\n\tcase RMX_FULL:\n\tdefault:\n\t\targs.usOverscanRight = cpu_to_le16(radeon_crtc->h_border);\n\t\targs.usOverscanLeft = cpu_to_le16(radeon_crtc->h_border);\n\t\targs.usOverscanBottom = cpu_to_le16(radeon_crtc->v_border);\n\t\targs.usOverscanTop = cpu_to_le16(radeon_crtc->v_border);\n\t\tbreak;\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void atombios_scaler_setup(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tENABLE_SCALER_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableScaler);\n\tstruct radeon_encoder *radeon_encoder =\n\t\tto_radeon_encoder(radeon_crtc->encoder);\n\t \n\tenum radeon_tv_std tv_std = TV_STD_NTSC;\n\tbool is_tv = false, is_cv = false;\n\n\tif (!ASIC_IS_AVIVO(rdev) && radeon_crtc->crtc_id)\n\t\treturn;\n\n\tif (radeon_encoder->active_device & ATOM_DEVICE_TV_SUPPORT) {\n\t\tstruct radeon_encoder_atom_dac *tv_dac = radeon_encoder->enc_priv;\n\t\ttv_std = tv_dac->tv_std;\n\t\tis_tv = true;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucScaler = radeon_crtc->crtc_id;\n\n\tif (is_tv) {\n\t\tswitch (tv_std) {\n\t\tcase TV_STD_NTSC:\n\t\tdefault:\n\t\t\targs.ucTVStandard = ATOM_TV_NTSC;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL:\n\t\t\targs.ucTVStandard = ATOM_TV_PAL;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL_M:\n\t\t\targs.ucTVStandard = ATOM_TV_PALM;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL_60:\n\t\t\targs.ucTVStandard = ATOM_TV_PAL60;\n\t\t\tbreak;\n\t\tcase TV_STD_NTSC_J:\n\t\t\targs.ucTVStandard = ATOM_TV_NTSCJ;\n\t\t\tbreak;\n\t\tcase TV_STD_SCART_PAL:\n\t\t\targs.ucTVStandard = ATOM_TV_PAL;  \n\t\t\tbreak;\n\t\tcase TV_STD_SECAM:\n\t\t\targs.ucTVStandard = ATOM_TV_SECAM;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL_CN:\n\t\t\targs.ucTVStandard = ATOM_TV_PALCN;\n\t\t\tbreak;\n\t\t}\n\t\targs.ucEnable = SCALER_ENABLE_MULTITAP_MODE;\n\t} else if (is_cv) {\n\t\targs.ucTVStandard = ATOM_TV_CV;\n\t\targs.ucEnable = SCALER_ENABLE_MULTITAP_MODE;\n\t} else {\n\t\tswitch (radeon_crtc->rmx_type) {\n\t\tcase RMX_FULL:\n\t\t\targs.ucEnable = ATOM_SCALER_EXPANSION;\n\t\t\tbreak;\n\t\tcase RMX_CENTER:\n\t\t\targs.ucEnable = ATOM_SCALER_CENTER;\n\t\t\tbreak;\n\t\tcase RMX_ASPECT:\n\t\t\targs.ucEnable = ATOM_SCALER_EXPANSION;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\targs.ucEnable = ATOM_SCALER_DISABLE;\n\t\t\telse\n\t\t\t\targs.ucEnable = ATOM_SCALER_CENTER;\n\t\t\tbreak;\n\t\t}\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\tif ((is_tv || is_cv)\n\t    && rdev->family >= CHIP_RV515 && rdev->family <= CHIP_R580) {\n\t\tatom_rv515_force_tv_scaler(rdev, radeon_crtc);\n\t}\n}\n\nstatic void atombios_lock_crtc(struct drm_crtc *crtc, int lock)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint index =\n\t    GetIndexIntoMasterTable(COMMAND, UpdateCRTC_DoubleBufferRegisters);\n\tENABLE_CRTC_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\targs.ucEnable = lock;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void atombios_enable_crtc(struct drm_crtc *crtc, int state)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableCRTC);\n\tENABLE_CRTC_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\targs.ucEnable = state;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void atombios_enable_crtc_memreq(struct drm_crtc *crtc, int state)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableCRTCMemReq);\n\tENABLE_CRTC_PS_ALLOCATION args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\targs.ucEnable = state;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic const u32 vga_control_regs[6] =\n{\n\tAVIVO_D1VGA_CONTROL,\n\tAVIVO_D2VGA_CONTROL,\n\tEVERGREEN_D3VGA_CONTROL,\n\tEVERGREEN_D4VGA_CONTROL,\n\tEVERGREEN_D5VGA_CONTROL,\n\tEVERGREEN_D6VGA_CONTROL,\n};\n\nstatic void atombios_blank_crtc(struct drm_crtc *crtc, int state)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint index = GetIndexIntoMasterTable(COMMAND, BlankCRTC);\n\tBLANK_CRTC_PS_ALLOCATION args;\n\tu32 vga_control = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (ASIC_IS_DCE8(rdev)) {\n\t\tvga_control = RREG32(vga_control_regs[radeon_crtc->crtc_id]);\n\t\tWREG32(vga_control_regs[radeon_crtc->crtc_id], vga_control | 1);\n\t}\n\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\targs.ucBlanking = state;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\tif (ASIC_IS_DCE8(rdev))\n\t\tWREG32(vga_control_regs[radeon_crtc->crtc_id], vga_control);\n}\n\nstatic void atombios_powergate_crtc(struct drm_crtc *crtc, int state)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableDispPowerGating);\n\tENABLE_DISP_POWER_GATING_PARAMETERS_V2_1 args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.ucDispPipeId = radeon_crtc->crtc_id;\n\targs.ucEnable = state;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid atombios_crtc_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tradeon_crtc->enabled = true;\n\t\tatombios_enable_crtc(crtc, ATOM_ENABLE);\n\t\tif (ASIC_IS_DCE3(rdev) && !ASIC_IS_DCE6(rdev))\n\t\t\tatombios_enable_crtc_memreq(crtc, ATOM_ENABLE);\n\t\tatombios_blank_crtc(crtc, ATOM_DISABLE);\n\t\tif (dev->num_crtcs > radeon_crtc->crtc_id)\n\t\t\tdrm_crtc_vblank_on(crtc);\n\t\tradeon_crtc_load_lut(crtc);\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\tcase DRM_MODE_DPMS_OFF:\n\t\tif (dev->num_crtcs > radeon_crtc->crtc_id)\n\t\t\tdrm_crtc_vblank_off(crtc);\n\t\tif (radeon_crtc->enabled)\n\t\t\tatombios_blank_crtc(crtc, ATOM_ENABLE);\n\t\tif (ASIC_IS_DCE3(rdev) && !ASIC_IS_DCE6(rdev))\n\t\t\tatombios_enable_crtc_memreq(crtc, ATOM_DISABLE);\n\t\tatombios_enable_crtc(crtc, ATOM_DISABLE);\n\t\tradeon_crtc->enabled = false;\n\t\tbreak;\n\t}\n\t \n\tradeon_pm_compute_clocks(rdev);\n}\n\nstatic void\natombios_set_crtc_dtd_timing(struct drm_crtc *crtc,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tSET_CRTC_USING_DTD_TIMING_PARAMETERS args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_UsingDTDTiming);\n\tu16 misc = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.usH_Size = cpu_to_le16(mode->crtc_hdisplay - (radeon_crtc->h_border * 2));\n\targs.usH_Blanking_Time =\n\t\tcpu_to_le16(mode->crtc_hblank_end - mode->crtc_hdisplay + (radeon_crtc->h_border * 2));\n\targs.usV_Size = cpu_to_le16(mode->crtc_vdisplay - (radeon_crtc->v_border * 2));\n\targs.usV_Blanking_Time =\n\t\tcpu_to_le16(mode->crtc_vblank_end - mode->crtc_vdisplay + (radeon_crtc->v_border * 2));\n\targs.usH_SyncOffset =\n\t\tcpu_to_le16(mode->crtc_hsync_start - mode->crtc_hdisplay + radeon_crtc->h_border);\n\targs.usH_SyncWidth =\n\t\tcpu_to_le16(mode->crtc_hsync_end - mode->crtc_hsync_start);\n\targs.usV_SyncOffset =\n\t\tcpu_to_le16(mode->crtc_vsync_start - mode->crtc_vdisplay + radeon_crtc->v_border);\n\targs.usV_SyncWidth =\n\t\tcpu_to_le16(mode->crtc_vsync_end - mode->crtc_vsync_start);\n\targs.ucH_Border = radeon_crtc->h_border;\n\targs.ucV_Border = radeon_crtc->v_border;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tmisc |= ATOM_VSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tmisc |= ATOM_HSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_CSYNC)\n\t\tmisc |= ATOM_COMPOSITESYNC;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tmisc |= ATOM_INTERLACE;\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\tmisc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;\n\n\targs.susModeMiscInfo.usAccess = cpu_to_le16(misc);\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void atombios_crtc_set_timing(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tSET_CRTC_TIMING_PARAMETERS_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetCRTC_Timing);\n\tu16 misc = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\targs.usH_Total = cpu_to_le16(mode->crtc_htotal);\n\targs.usH_Disp = cpu_to_le16(mode->crtc_hdisplay);\n\targs.usH_SyncStart = cpu_to_le16(mode->crtc_hsync_start);\n\targs.usH_SyncWidth =\n\t\tcpu_to_le16(mode->crtc_hsync_end - mode->crtc_hsync_start);\n\targs.usV_Total = cpu_to_le16(mode->crtc_vtotal);\n\targs.usV_Disp = cpu_to_le16(mode->crtc_vdisplay);\n\targs.usV_SyncStart = cpu_to_le16(mode->crtc_vsync_start);\n\targs.usV_SyncWidth =\n\t\tcpu_to_le16(mode->crtc_vsync_end - mode->crtc_vsync_start);\n\n\targs.ucOverscanRight = radeon_crtc->h_border;\n\targs.ucOverscanLeft = radeon_crtc->h_border;\n\targs.ucOverscanBottom = radeon_crtc->v_border;\n\targs.ucOverscanTop = radeon_crtc->v_border;\n\n\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\tmisc |= ATOM_VSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\tmisc |= ATOM_HSYNC_POLARITY;\n\tif (mode->flags & DRM_MODE_FLAG_CSYNC)\n\t\tmisc |= ATOM_COMPOSITESYNC;\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tmisc |= ATOM_INTERLACE;\n\tif (mode->flags & DRM_MODE_FLAG_DBLCLK)\n\t\tmisc |= ATOM_DOUBLE_CLOCK_MODE;\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\tmisc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;\n\n\targs.susModeMiscInfo.usAccess = cpu_to_le16(misc);\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void atombios_disable_ss(struct radeon_device *rdev, int pll_id)\n{\n\tu32 ss_cntl;\n\n\tif (ASIC_IS_DCE4(rdev)) {\n\t\tswitch (pll_id) {\n\t\tcase ATOM_PPLL1:\n\t\t\tss_cntl = RREG32(EVERGREEN_P1PLL_SS_CNTL);\n\t\t\tss_cntl &= ~EVERGREEN_PxPLL_SS_EN;\n\t\t\tWREG32(EVERGREEN_P1PLL_SS_CNTL, ss_cntl);\n\t\t\tbreak;\n\t\tcase ATOM_PPLL2:\n\t\t\tss_cntl = RREG32(EVERGREEN_P2PLL_SS_CNTL);\n\t\t\tss_cntl &= ~EVERGREEN_PxPLL_SS_EN;\n\t\t\tWREG32(EVERGREEN_P2PLL_SS_CNTL, ss_cntl);\n\t\t\tbreak;\n\t\tcase ATOM_DCPLL:\n\t\tcase ATOM_PPLL_INVALID:\n\t\t\treturn;\n\t\t}\n\t} else if (ASIC_IS_AVIVO(rdev)) {\n\t\tswitch (pll_id) {\n\t\tcase ATOM_PPLL1:\n\t\t\tss_cntl = RREG32(AVIVO_P1PLL_INT_SS_CNTL);\n\t\t\tss_cntl &= ~1;\n\t\t\tWREG32(AVIVO_P1PLL_INT_SS_CNTL, ss_cntl);\n\t\t\tbreak;\n\t\tcase ATOM_PPLL2:\n\t\t\tss_cntl = RREG32(AVIVO_P2PLL_INT_SS_CNTL);\n\t\t\tss_cntl &= ~1;\n\t\t\tWREG32(AVIVO_P2PLL_INT_SS_CNTL, ss_cntl);\n\t\t\tbreak;\n\t\tcase ATOM_DCPLL:\n\t\tcase ATOM_PPLL_INVALID:\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n\nunion atom_enable_ss {\n\tENABLE_LVDS_SS_PARAMETERS lvds_ss;\n\tENABLE_LVDS_SS_PARAMETERS_V2 lvds_ss_2;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_PS_ALLOCATION v1;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_V2 v2;\n\tENABLE_SPREAD_SPECTRUM_ON_PPLL_V3 v3;\n};\n\nstatic void atombios_crtc_program_ss(struct radeon_device *rdev,\n\t\t\t\t     int enable,\n\t\t\t\t     int pll_id,\n\t\t\t\t     int crtc_id,\n\t\t\t\t     struct radeon_atom_ss *ss)\n{\n\tunsigned i;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableSpreadSpectrumOnPPLL);\n\tunion atom_enable_ss args;\n\n\tif (enable) {\n\t\t \n\t\tif (ss->percentage == 0)\n\t\t\treturn;\n\t\tif (ss->type & ATOM_EXTERNAL_SS_MASK)\n\t\t\treturn;\n\t} else {\n\t\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\t\tif (rdev->mode_info.crtcs[i] &&\n\t\t\t    rdev->mode_info.crtcs[i]->enabled &&\n\t\t\t    i != crtc_id &&\n\t\t\t    pll_id == rdev->mode_info.crtcs[i]->pll_id) {\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (ASIC_IS_DCE5(rdev)) {\n\t\targs.v3.usSpreadSpectrumAmountFrac = cpu_to_le16(0);\n\t\targs.v3.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\tswitch (pll_id) {\n\t\tcase ATOM_PPLL1:\n\t\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P1PLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL2:\n\t\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_P2PLL;\n\t\t\tbreak;\n\t\tcase ATOM_DCPLL:\n\t\t\targs.v3.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V3_DCPLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL_INVALID:\n\t\t\treturn;\n\t\t}\n\t\targs.v3.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\n\t\targs.v3.usSpreadSpectrumStep = cpu_to_le16(ss->step);\n\t\targs.v3.ucEnable = enable;\n\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\targs.v2.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.v2.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\tswitch (pll_id) {\n\t\tcase ATOM_PPLL1:\n\t\t\targs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_P1PLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL2:\n\t\t\targs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_P2PLL;\n\t\t\tbreak;\n\t\tcase ATOM_DCPLL:\n\t\t\targs.v2.ucSpreadSpectrumType |= ATOM_PPLL_SS_TYPE_V2_DCPLL;\n\t\t\tbreak;\n\t\tcase ATOM_PPLL_INVALID:\n\t\t\treturn;\n\t\t}\n\t\targs.v2.usSpreadSpectrumAmount = cpu_to_le16(ss->amount);\n\t\targs.v2.usSpreadSpectrumStep = cpu_to_le16(ss->step);\n\t\targs.v2.ucEnable = enable;\n\t} else if (ASIC_IS_DCE3(rdev)) {\n\t\targs.v1.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.v1.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\targs.v1.ucSpreadSpectrumStep = ss->step;\n\t\targs.v1.ucSpreadSpectrumDelay = ss->delay;\n\t\targs.v1.ucSpreadSpectrumRange = ss->range;\n\t\targs.v1.ucPpll = pll_id;\n\t\targs.v1.ucEnable = enable;\n\t} else if (ASIC_IS_AVIVO(rdev)) {\n\t\tif ((enable == ATOM_DISABLE) || (ss->percentage == 0) ||\n\t\t    (ss->type & ATOM_EXTERNAL_SS_MASK)) {\n\t\t\tatombios_disable_ss(rdev, pll_id);\n\t\t\treturn;\n\t\t}\n\t\targs.lvds_ss_2.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.lvds_ss_2.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\targs.lvds_ss_2.ucSpreadSpectrumStep = ss->step;\n\t\targs.lvds_ss_2.ucSpreadSpectrumDelay = ss->delay;\n\t\targs.lvds_ss_2.ucSpreadSpectrumRange = ss->range;\n\t\targs.lvds_ss_2.ucEnable = enable;\n\t} else {\n\t\tif (enable == ATOM_DISABLE) {\n\t\t\tatombios_disable_ss(rdev, pll_id);\n\t\t\treturn;\n\t\t}\n\t\targs.lvds_ss.usSpreadSpectrumPercentage = cpu_to_le16(ss->percentage);\n\t\targs.lvds_ss.ucSpreadSpectrumType = ss->type & ATOM_SS_CENTRE_SPREAD_MODE_MASK;\n\t\targs.lvds_ss.ucSpreadSpectrumStepSize_Delay = (ss->step & 3) << 2;\n\t\targs.lvds_ss.ucSpreadSpectrumStepSize_Delay |= (ss->delay & 7) << 4;\n\t\targs.lvds_ss.ucEnable = enable;\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nunion adjust_pixel_clock {\n\tADJUST_DISPLAY_PLL_PS_ALLOCATION v1;\n\tADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 v3;\n};\n\nstatic u32 atombios_adjust_pll(struct drm_crtc *crtc,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_encoder *encoder = radeon_crtc->encoder;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tu32 adjusted_clock = mode->clock;\n\tint encoder_mode = atombios_get_encoder_mode(encoder);\n\tu32 dp_clock = mode->clock;\n\tu32 clock = mode->clock;\n\tint bpc = radeon_crtc->bpc;\n\tbool is_duallink = radeon_dig_monitor_is_duallink(encoder, mode->clock);\n\n\t \n\tradeon_crtc->pll_flags = 0;\n\n\tif (ASIC_IS_AVIVO(rdev)) {\n\t\tif ((rdev->family == CHIP_RS600) ||\n\t\t    (rdev->family == CHIP_RS690) ||\n\t\t    (rdev->family == CHIP_RS740))\n\t\t\tradeon_crtc->pll_flags |= ( \n\t\t\t\tRADEON_PLL_PREFER_CLOSEST_LOWER);\n\n\t\tif (ASIC_IS_DCE32(rdev) && mode->clock > 200000)\t \n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;\n\t\telse\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;\n\n\t\tif (rdev->family < CHIP_RV770)\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;\n\t\t \n\t\tif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE61(rdev) || ASIC_IS_DCE8(rdev))\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\n\t\t \n\t\tif (((rdev->family == CHIP_RS780) || (rdev->family == CHIP_RS880))\n\t\t    && !radeon_crtc->ss_enabled)\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\n\t\tif (ASIC_IS_DCE32(rdev) && mode->clock > 165000)\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\n\t} else {\n\t\tradeon_crtc->pll_flags |= RADEON_PLL_LEGACY;\n\n\t\tif (mode->clock > 200000)\t \n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;\n\t\telse\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;\n\t}\n\n\tif ((radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT)) ||\n\t    (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)) {\n\t\tif (connector) {\n\t\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\t\tradeon_connector->con_priv;\n\n\t\t\tdp_clock = dig_connector->dp_clock;\n\t\t}\n\t}\n\n\t \n\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\tif (radeon_crtc->ss_enabled) {\n\t\t\tif (radeon_crtc->ss.refdiv) {\n\t\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_REF_DIV;\n\t\t\t\tradeon_crtc->pll_reference_div = radeon_crtc->ss.refdiv;\n\t\t\t\tif (ASIC_IS_AVIVO(rdev) &&\n\t\t\t\t    rdev->family != CHIP_RS780 &&\n\t\t\t\t    rdev->family != CHIP_RS880)\n\t\t\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ASIC_IS_AVIVO(rdev)) {\n\t\t \n\t\tif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1)\n\t\t\tadjusted_clock = mode->clock * 2;\n\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_IS_LCD;\n\t} else {\n\t\tif (encoder->encoder_type != DRM_MODE_ENCODER_DAC)\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_NO_ODD_POST_DIV;\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_LVDS)\n\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_REF_DIV;\n\t}\n\n\t \n\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\tswitch (bpc) {\n\t\tcase 8:\n\t\tdefault:\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tclock = (clock * 5) / 4;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tclock = (clock * 3) / 2;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tclock = clock * 2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ASIC_IS_DCE3(rdev)) {\n\t\tunion adjust_pixel_clock args;\n\t\tu8 frev, crev;\n\t\tint index;\n\n\t\tindex = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);\n\t\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev,\n\t\t\t\t\t   &crev))\n\t\t\treturn adjusted_clock;\n\n\t\tmemset(&args, 0, sizeof(args));\n\n\t\tswitch (frev) {\n\t\tcase 1:\n\t\t\tswitch (crev) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\t\targs.v1.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\t\targs.v1.ucTransmitterID = radeon_encoder->encoder_id;\n\t\t\t\targs.v1.ucEncodeMode = encoder_mode;\n\t\t\t\tif (radeon_crtc->ss_enabled && radeon_crtc->ss.percentage)\n\t\t\t\t\targs.v1.ucConfig |=\n\t\t\t\t\t\tADJUST_DISPLAY_CONFIG_SS_ENABLE;\n\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context,\n\t\t\t\t\t\t   index, (uint32_t *)&args);\n\t\t\t\tadjusted_clock = le16_to_cpu(args.v1.usPixelClock) * 10;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\targs.v3.sInput.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\t\targs.v3.sInput.ucTransmitterID = radeon_encoder->encoder_id;\n\t\t\t\targs.v3.sInput.ucEncodeMode = encoder_mode;\n\t\t\t\targs.v3.sInput.ucDispPllConfig = 0;\n\t\t\t\tif (radeon_crtc->ss_enabled && radeon_crtc->ss.percentage)\n\t\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\t\tDISPPLL_CONFIG_SS_ENABLE;\n\t\t\t\tif (ENCODER_MODE_IS_DP(encoder_mode)) {\n\t\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\t\tDISPPLL_CONFIG_COHERENT_MODE;\n\t\t\t\t\t \n\t\t\t\t\targs.v3.sInput.usPixelClock = cpu_to_le16(dp_clock / 10);\n\t\t\t\t} else if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\t\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\t\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\t\t\tDISPPLL_CONFIG_COHERENT_MODE;\n\t\t\t\t\tif (is_duallink)\n\t\t\t\t\t\targs.v3.sInput.ucDispPllConfig |=\n\t\t\t\t\t\t\tDISPPLL_CONFIG_DUAL_LINK;\n\t\t\t\t}\n\t\t\t\tif (radeon_encoder_get_dp_bridge_encoder_id(encoder) !=\n\t\t\t\t    ENCODER_OBJECT_ID_NONE)\n\t\t\t\t\targs.v3.sInput.ucExtTransmitterID =\n\t\t\t\t\t\tradeon_encoder_get_dp_bridge_encoder_id(encoder);\n\t\t\t\telse\n\t\t\t\t\targs.v3.sInput.ucExtTransmitterID = 0;\n\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context,\n\t\t\t\t\t\t   index, (uint32_t *)&args);\n\t\t\t\tadjusted_clock = le32_to_cpu(args.v3.sOutput.ulDispPllFreq) * 10;\n\t\t\t\tif (args.v3.sOutput.ucRefDiv) {\n\t\t\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\n\t\t\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_REF_DIV;\n\t\t\t\t\tradeon_crtc->pll_reference_div = args.v3.sOutput.ucRefDiv;\n\t\t\t\t}\n\t\t\t\tif (args.v3.sOutput.ucPostDiv) {\n\t\t\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV;\n\t\t\t\t\tradeon_crtc->pll_flags |= RADEON_PLL_USE_POST_DIV;\n\t\t\t\t\tradeon_crtc->pll_post_div = args.v3.sOutput.ucPostDiv;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\t\treturn adjusted_clock;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn adjusted_clock;\n\t\t}\n\t}\n\treturn adjusted_clock;\n}\n\nunion set_pixel_clock {\n\tSET_PIXEL_CLOCK_PS_ALLOCATION base;\n\tPIXEL_CLOCK_PARAMETERS v1;\n\tPIXEL_CLOCK_PARAMETERS_V2 v2;\n\tPIXEL_CLOCK_PARAMETERS_V3 v3;\n\tPIXEL_CLOCK_PARAMETERS_V5 v5;\n\tPIXEL_CLOCK_PARAMETERS_V6 v6;\n};\n\n \nstatic void atombios_crtc_set_disp_eng_pll(struct radeon_device *rdev,\n\t\t\t\t    u32 dispclk)\n{\n\tu8 frev, crev;\n\tint index;\n\tunion set_pixel_clock args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tindex = GetIndexIntoMasterTable(COMMAND, SetPixelClock);\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev,\n\t\t\t\t   &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 5:\n\t\t\t \n\t\t\targs.v5.ucCRTC = ATOM_CRTC_INVALID;\n\t\t\targs.v5.usPixelClock = cpu_to_le16(dispclk);\n\t\t\targs.v5.ucPpll = ATOM_DCPLL;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\t \n\t\t\targs.v6.ulDispEngClkFreq = cpu_to_le32(dispclk);\n\t\t\tif (ASIC_IS_DCE61(rdev) || ASIC_IS_DCE8(rdev))\n\t\t\t\targs.v6.ucPpll = ATOM_EXT_PLL1;\n\t\t\telse if (ASIC_IS_DCE6(rdev))\n\t\t\t\targs.v6.ucPpll = ATOM_PPLL0;\n\t\t\telse\n\t\t\t\targs.v6.ucPpll = ATOM_DCPLL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void atombios_crtc_program_pll(struct drm_crtc *crtc,\n\t\t\t\t      u32 crtc_id,\n\t\t\t\t      int pll_id,\n\t\t\t\t      u32 encoder_mode,\n\t\t\t\t      u32 encoder_id,\n\t\t\t\t      u32 clock,\n\t\t\t\t      u32 ref_div,\n\t\t\t\t      u32 fb_div,\n\t\t\t\t      u32 frac_fb_div,\n\t\t\t\t      u32 post_div,\n\t\t\t\t      int bpc,\n\t\t\t\t      bool ss_enabled,\n\t\t\t\t      struct radeon_atom_ss *ss)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tu8 frev, crev;\n\tint index = GetIndexIntoMasterTable(COMMAND, SetPixelClock);\n\tunion set_pixel_clock args;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev,\n\t\t\t\t   &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tif (clock == ATOM_DISABLE)\n\t\t\t\treturn;\n\t\t\targs.v1.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v1.usRefDiv = cpu_to_le16(ref_div);\n\t\t\targs.v1.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v1.ucFracFbDiv = frac_fb_div;\n\t\t\targs.v1.ucPostDiv = post_div;\n\t\t\targs.v1.ucPpll = pll_id;\n\t\t\targs.v1.ucCRTC = crtc_id;\n\t\t\targs.v1.ucRefDivSrc = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\targs.v2.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v2.usRefDiv = cpu_to_le16(ref_div);\n\t\t\targs.v2.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v2.ucFracFbDiv = frac_fb_div;\n\t\t\targs.v2.ucPostDiv = post_div;\n\t\t\targs.v2.ucPpll = pll_id;\n\t\t\targs.v2.ucCRTC = crtc_id;\n\t\t\targs.v2.ucRefDivSrc = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\targs.v3.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v3.usRefDiv = cpu_to_le16(ref_div);\n\t\t\targs.v3.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v3.ucFracFbDiv = frac_fb_div;\n\t\t\targs.v3.ucPostDiv = post_div;\n\t\t\targs.v3.ucPpll = pll_id;\n\t\t\tif (crtc_id == ATOM_CRTC2)\n\t\t\t\targs.v3.ucMiscInfo = PIXEL_CLOCK_MISC_CRTC_SEL_CRTC2;\n\t\t\telse\n\t\t\t\targs.v3.ucMiscInfo = PIXEL_CLOCK_MISC_CRTC_SEL_CRTC1;\n\t\t\tif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\n\t\t\t\targs.v3.ucMiscInfo |= PIXEL_CLOCK_MISC_REF_DIV_SRC;\n\t\t\targs.v3.ucTransmitterId = encoder_id;\n\t\t\targs.v3.ucEncoderMode = encoder_mode;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\targs.v5.ucCRTC = crtc_id;\n\t\t\targs.v5.usPixelClock = cpu_to_le16(clock / 10);\n\t\t\targs.v5.ucRefDiv = ref_div;\n\t\t\targs.v5.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v5.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);\n\t\t\targs.v5.ucPostDiv = post_div;\n\t\t\targs.v5.ucMiscInfo = 0;  \n\t\t\tif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\n\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_REF_DIV_SRC;\n\t\t\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\t\t\tswitch (bpc) {\n\t\t\t\tcase 8:\n\t\t\t\tdefault:\n\t\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_24BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\t \n\t\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_32BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\t \n\t\t\t\t\targs.v5.ucMiscInfo |= PIXEL_CLOCK_V5_MISC_HDMI_30BPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.v5.ucTransmitterID = encoder_id;\n\t\t\targs.v5.ucEncoderMode = encoder_mode;\n\t\t\targs.v5.ucPpll = pll_id;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\targs.v6.ulDispEngClkFreq = cpu_to_le32(crtc_id << 24 | clock / 10);\n\t\t\targs.v6.ucRefDiv = ref_div;\n\t\t\targs.v6.usFbDiv = cpu_to_le16(fb_div);\n\t\t\targs.v6.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);\n\t\t\targs.v6.ucPostDiv = post_div;\n\t\t\targs.v6.ucMiscInfo = 0;  \n\t\t\tif (ss_enabled && (ss->type & ATOM_EXTERNAL_SS_MASK))\n\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_REF_DIV_SRC;\n\t\t\tif (encoder_mode == ATOM_ENCODER_MODE_HDMI) {\n\t\t\t\tswitch (bpc) {\n\t\t\t\tcase 8:\n\t\t\t\tdefault:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_24BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 10:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_30BPP_V6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_36BPP_V6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\targs.v6.ucMiscInfo |= PIXEL_CLOCK_V6_MISC_HDMI_48BPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\targs.v6.ucTransmitterID = encoder_id;\n\t\t\targs.v6.ucEncoderMode = encoder_mode;\n\t\t\targs.v6.ucPpll = pll_id;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic bool atombios_crtc_prepare_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder =\n\t\tto_radeon_encoder(radeon_crtc->encoder);\n\tint encoder_mode = atombios_get_encoder_mode(radeon_crtc->encoder);\n\n\tradeon_crtc->bpc = 8;\n\tradeon_crtc->ss_enabled = false;\n\n\tif ((radeon_encoder->active_device & (ATOM_DEVICE_LCD_SUPPORT | ATOM_DEVICE_DFP_SUPPORT)) ||\n\t    (radeon_encoder_get_dp_bridge_encoder_id(radeon_crtc->encoder) != ENCODER_OBJECT_ID_NONE)) {\n\t\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\t\tstruct drm_connector *connector =\n\t\t\tradeon_get_connector_for_encoder(radeon_crtc->encoder);\n\t\tstruct radeon_connector *radeon_connector =\n\t\t\tto_radeon_connector(connector);\n\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\tradeon_connector->con_priv;\n\t\tint dp_clock;\n\n\t\t \n\t\tradeon_connector->pixelclock_for_modeset = mode->clock;\n\t\tradeon_crtc->bpc = radeon_get_monitor_bpc(connector);\n\n\t\tswitch (encoder_mode) {\n\t\tcase ATOM_ENCODER_MODE_DP_MST:\n\t\tcase ATOM_ENCODER_MODE_DP:\n\t\t\t \n\t\t\tdp_clock = dig_connector->dp_clock / 10;\n\t\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\tradeon_atombios_get_asic_ss_info(rdev, &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t ASIC_INTERNAL_SS_ON_DP,\n\t\t\t\t\t\t\t\t\t dp_clock);\n\t\t\telse {\n\t\t\t\tif (dp_clock == 16200) {\n\t\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\t\tradeon_atombios_get_ppll_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t\t ATOM_DP_SS_ID2);\n\t\t\t\t\tif (!radeon_crtc->ss_enabled)\n\t\t\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\t\t\tradeon_atombios_get_ppll_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t\t\t ATOM_DP_SS_ID1);\n\t\t\t\t} else {\n\t\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\t\tradeon_atombios_get_ppll_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t\t ATOM_DP_SS_ID1);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tradeon_crtc->ss_enabled = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ATOM_ENCODER_MODE_LVDS:\n\t\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\tradeon_atombios_get_asic_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t dig->lcd_ss_id,\n\t\t\t\t\t\t\t\t\t mode->clock / 10);\n\t\t\telse\n\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\tradeon_atombios_get_ppll_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t dig->lcd_ss_id);\n\t\t\tbreak;\n\t\tcase ATOM_ENCODER_MODE_DVI:\n\t\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\tradeon_atombios_get_asic_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t ASIC_INTERNAL_SS_ON_TMDS,\n\t\t\t\t\t\t\t\t\t mode->clock / 10);\n\t\t\tbreak;\n\t\tcase ATOM_ENCODER_MODE_HDMI:\n\t\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\t\tradeon_crtc->ss_enabled =\n\t\t\t\t\tradeon_atombios_get_asic_ss_info(rdev,\n\t\t\t\t\t\t\t\t\t &radeon_crtc->ss,\n\t\t\t\t\t\t\t\t\t ASIC_INTERNAL_SS_ON_HDMI,\n\t\t\t\t\t\t\t\t\t mode->clock / 10);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tradeon_crtc->adjusted_clock = atombios_adjust_pll(crtc, mode);\n\n\treturn true;\n}\n\nstatic void atombios_crtc_set_pll(struct drm_crtc *crtc, struct drm_display_mode *mode)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder =\n\t\tto_radeon_encoder(radeon_crtc->encoder);\n\tu32 pll_clock = mode->clock;\n\tu32 clock = mode->clock;\n\tu32 ref_div = 0, fb_div = 0, frac_fb_div = 0, post_div = 0;\n\tstruct radeon_pll *pll;\n\tint encoder_mode = atombios_get_encoder_mode(radeon_crtc->encoder);\n\n\t \n\tif (ASIC_IS_DCE5(rdev) &&\n\t    (encoder_mode == ATOM_ENCODER_MODE_HDMI) &&\n\t    (radeon_crtc->bpc > 8))\n\t\tclock = radeon_crtc->adjusted_clock;\n\n\tswitch (radeon_crtc->pll_id) {\n\tcase ATOM_PPLL1:\n\t\tpll = &rdev->clock.p1pll;\n\t\tbreak;\n\tcase ATOM_PPLL2:\n\t\tpll = &rdev->clock.p2pll;\n\t\tbreak;\n\tcase ATOM_DCPLL:\n\tcase ATOM_PPLL_INVALID:\n\tdefault:\n\t\tpll = &rdev->clock.dcpll;\n\t\tbreak;\n\t}\n\n\t \n\tpll->flags = radeon_crtc->pll_flags;\n\tpll->reference_div = radeon_crtc->pll_reference_div;\n\tpll->post_div = radeon_crtc->pll_post_div;\n\n\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t \n\t\tradeon_compute_pll_legacy(pll, radeon_crtc->adjusted_clock, &pll_clock,\n\t\t\t\t\t  &fb_div, &frac_fb_div, &ref_div, &post_div);\n\telse if (ASIC_IS_AVIVO(rdev))\n\t\tradeon_compute_pll_avivo(pll, radeon_crtc->adjusted_clock, &pll_clock,\n\t\t\t\t\t &fb_div, &frac_fb_div, &ref_div, &post_div);\n\telse\n\t\tradeon_compute_pll_legacy(pll, radeon_crtc->adjusted_clock, &pll_clock,\n\t\t\t\t\t  &fb_div, &frac_fb_div, &ref_div, &post_div);\n\n\tatombios_crtc_program_ss(rdev, ATOM_DISABLE, radeon_crtc->pll_id,\n\t\t\t\t radeon_crtc->crtc_id, &radeon_crtc->ss);\n\n\tatombios_crtc_program_pll(crtc, radeon_crtc->crtc_id, radeon_crtc->pll_id,\n\t\t\t\t  encoder_mode, radeon_encoder->encoder_id, clock,\n\t\t\t\t  ref_div, fb_div, frac_fb_div, post_div,\n\t\t\t\t  radeon_crtc->bpc, radeon_crtc->ss_enabled, &radeon_crtc->ss);\n\n\tif (radeon_crtc->ss_enabled) {\n\t\t \n\t\tif (ASIC_IS_DCE4(rdev)) {\n\t\t\tu32 step_size;\n\t\t\tu32 amount = (((fb_div * 10) + frac_fb_div) *\n\t\t\t\t      (u32)radeon_crtc->ss.percentage) /\n\t\t\t\t(100 * (u32)radeon_crtc->ss.percentage_divider);\n\t\t\tradeon_crtc->ss.amount = (amount / 10) & ATOM_PPLL_SS_AMOUNT_V2_FBDIV_MASK;\n\t\t\tradeon_crtc->ss.amount |= ((amount - (amount / 10)) << ATOM_PPLL_SS_AMOUNT_V2_NFRAC_SHIFT) &\n\t\t\t\tATOM_PPLL_SS_AMOUNT_V2_NFRAC_MASK;\n\t\t\tif (radeon_crtc->ss.type & ATOM_PPLL_SS_TYPE_V2_CENTRE_SPREAD)\n\t\t\t\tstep_size = (4 * amount * ref_div * ((u32)radeon_crtc->ss.rate * 2048)) /\n\t\t\t\t\t(125 * 25 * pll->reference_freq / 100);\n\t\t\telse\n\t\t\t\tstep_size = (2 * amount * ref_div * ((u32)radeon_crtc->ss.rate * 2048)) /\n\t\t\t\t\t(125 * 25 * pll->reference_freq / 100);\n\t\t\tradeon_crtc->ss.step = step_size;\n\t\t}\n\n\t\tatombios_crtc_program_ss(rdev, ATOM_ENABLE, radeon_crtc->pll_id,\n\t\t\t\t\t radeon_crtc->crtc_id, &radeon_crtc->ss);\n\t}\n}\n\nstatic int dce4_crtc_do_set_base(struct drm_crtc *crtc,\n\t\t\t\t struct drm_framebuffer *fb,\n\t\t\t\t int x, int y, int atomic)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_framebuffer *target_fb;\n\tstruct drm_gem_object *obj;\n\tstruct radeon_bo *rbo;\n\tuint64_t fb_location;\n\tuint32_t fb_format, fb_pitch_pixels, tiling_flags;\n\tunsigned bankw, bankh, mtaspect, tile_split;\n\tu32 fb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_NONE);\n\tu32 tmp, viewport_w, viewport_h;\n\tint r;\n\tbool bypass_lut = false;\n\n\t \n\tif (!atomic && !crtc->primary->fb) {\n\t\tDRM_DEBUG_KMS(\"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\tif (atomic)\n\t\ttarget_fb = fb;\n\telse\n\t\ttarget_fb = crtc->primary->fb;\n\n\t \n\tobj = target_fb->obj[0];\n\trbo = gem_to_radeon_bo(obj);\n\tr = radeon_bo_reserve(rbo, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\n\tif (atomic)\n\t\tfb_location = radeon_bo_gpu_offset(rbo);\n\telse {\n\t\tr = radeon_bo_pin(rbo, RADEON_GEM_DOMAIN_VRAM, &fb_location);\n\t\tif (unlikely(r != 0)) {\n\t\t\tradeon_bo_unreserve(rbo);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tradeon_bo_get_tiling_flags(rbo, &tiling_flags, NULL);\n\tradeon_bo_unreserve(rbo);\n\n\tswitch (target_fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_8BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_INDEXED));\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB4444:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB4444));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_ARGB1555:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB1555));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX5551:\n\tcase DRM_FORMAT_BGRA5551:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_BGRA5551));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_16BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB565));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN16);\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB8888));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB2101010));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\n#endif\n\t\t \n\t\tbypass_lut = true;\n\t\tbreak;\n\tcase DRM_FORMAT_BGRX1010102:\n\tcase DRM_FORMAT_BGRA1010102:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_BGRA1010102));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\n#endif\n\t\t \n\t\tbypass_lut = true;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tfb_format = (EVERGREEN_GRPH_DEPTH(EVERGREEN_GRPH_DEPTH_32BPP) |\n\t\t\t     EVERGREEN_GRPH_FORMAT(EVERGREEN_GRPH_FORMAT_ARGB8888));\n\t\tfb_swap = (EVERGREEN_GRPH_RED_CROSSBAR(EVERGREEN_GRPH_RED_SEL_B) |\n\t\t\t   EVERGREEN_GRPH_BLUE_CROSSBAR(EVERGREEN_GRPH_BLUE_SEL_R));\n#ifdef __BIG_ENDIAN\n\t\tfb_swap |= EVERGREEN_GRPH_ENDIAN_SWAP(EVERGREEN_GRPH_ENDIAN_8IN32);\n#endif\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported screen format %p4cc\\n\",\n\t\t\t  &target_fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tiling_flags & RADEON_TILING_MACRO) {\n\t\tevergreen_tiling_fields(tiling_flags, &bankw, &bankh, &mtaspect, &tile_split);\n\n\t\t \n\t\tif (rdev->family >= CHIP_TAHITI) {\n\t\t\tunsigned index, num_banks;\n\n\t\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\t\tunsigned tileb, tile_split_bytes;\n\n\t\t\t\t \n\t\t\t\ttile_split_bytes = 64 << tile_split;\n\t\t\t\ttileb = 8 * 8 * target_fb->format->cpp[0];\n\t\t\t\ttileb = min(tile_split_bytes, tileb);\n\n\t\t\t\tfor (index = 0; tileb > 64; index++)\n\t\t\t\t\ttileb >>= 1;\n\n\t\t\t\tif (index >= 16) {\n\t\t\t\t\tDRM_ERROR(\"Wrong screen bpp (%u) or tile split (%u)\\n\",\n\t\t\t\t\t\t  target_fb->format->cpp[0] * 8,\n\t\t\t\t\t\t  tile_split);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tnum_banks = (rdev->config.cik.macrotile_mode_array[index] >> 6) & 0x3;\n\t\t\t} else {\n\t\t\t\tswitch (target_fb->format->cpp[0] * 8) {\n\t\t\t\tcase 8:\n\t\t\t\t\tindex = 10;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 16:\n\t\t\t\t\tindex = SI_TILE_MODE_COLOR_2D_SCANOUT_16BPP;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase 32:\n\t\t\t\t\tindex = SI_TILE_MODE_COLOR_2D_SCANOUT_32BPP;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tnum_banks = (rdev->config.si.tile_mode_array[index] >> 20) & 0x3;\n\t\t\t}\n\n\t\t\tfb_format |= EVERGREEN_GRPH_NUM_BANKS(num_banks);\n\t\t} else {\n\t\t\t \n\t\t\tif (rdev->family >= CHIP_CAYMAN)\n\t\t\t\ttmp = rdev->config.cayman.tile_config;\n\t\t\telse\n\t\t\t\ttmp = rdev->config.evergreen.tile_config;\n\n\t\t\tswitch ((tmp & 0xf0) >> 4) {\n\t\t\tcase 0:  \n\t\t\t\tfb_format |= EVERGREEN_GRPH_NUM_BANKS(EVERGREEN_ADDR_SURF_4_BANK);\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\tdefault:\n\t\t\t\tfb_format |= EVERGREEN_GRPH_NUM_BANKS(EVERGREEN_ADDR_SURF_8_BANK);\n\t\t\t\tbreak;\n\t\t\tcase 2:  \n\t\t\t\tfb_format |= EVERGREEN_GRPH_NUM_BANKS(EVERGREEN_ADDR_SURF_16_BANK);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfb_format |= EVERGREEN_GRPH_ARRAY_MODE(EVERGREEN_GRPH_ARRAY_2D_TILED_THIN1);\n\t\tfb_format |= EVERGREEN_GRPH_TILE_SPLIT(tile_split);\n\t\tfb_format |= EVERGREEN_GRPH_BANK_WIDTH(bankw);\n\t\tfb_format |= EVERGREEN_GRPH_BANK_HEIGHT(bankh);\n\t\tfb_format |= EVERGREEN_GRPH_MACRO_TILE_ASPECT(mtaspect);\n\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\t \n\t\t\tfb_format |= CIK_GRPH_MICRO_TILE_MODE(CIK_DISPLAY_MICRO_TILING);\n\t\t}\n\t} else if (tiling_flags & RADEON_TILING_MICRO)\n\t\tfb_format |= EVERGREEN_GRPH_ARRAY_MODE(EVERGREEN_GRPH_ARRAY_1D_TILED_THIN1);\n\n\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t \n\t\tu32 pipe_config = (rdev->config.cik.tile_mode_array[10] >> 6) & 0x1f;\n\n\t\tfb_format |= CIK_GRPH_PIPE_CONFIG(pipe_config);\n\t} else if ((rdev->family == CHIP_TAHITI) ||\n\t\t   (rdev->family == CHIP_PITCAIRN))\n\t\tfb_format |= SI_GRPH_PIPE_CONFIG(SI_ADDR_SURF_P8_32x32_8x16);\n\telse if ((rdev->family == CHIP_VERDE) ||\n\t\t (rdev->family == CHIP_OLAND) ||\n\t\t (rdev->family == CHIP_HAINAN))  \n\t\tfb_format |= SI_GRPH_PIPE_CONFIG(SI_ADDR_SURF_P4_8x16);\n\n\tswitch (radeon_crtc->crtc_id) {\n\tcase 0:\n\t\tWREG32(AVIVO_D1VGA_CONTROL, 0);\n\t\tbreak;\n\tcase 1:\n\t\tWREG32(AVIVO_D2VGA_CONTROL, 0);\n\t\tbreak;\n\tcase 2:\n\t\tWREG32(EVERGREEN_D3VGA_CONTROL, 0);\n\t\tbreak;\n\tcase 3:\n\t\tWREG32(EVERGREEN_D4VGA_CONTROL, 0);\n\t\tbreak;\n\tcase 4:\n\t\tWREG32(EVERGREEN_D5VGA_CONTROL, 0);\n\t\tbreak;\n\tcase 5:\n\t\tWREG32(EVERGREEN_D6VGA_CONTROL, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tWREG32(EVERGREEN_GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,\n\t       upper_32_bits(fb_location));\n\tWREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS_HIGH + radeon_crtc->crtc_offset,\n\t       upper_32_bits(fb_location));\n\tWREG32(EVERGREEN_GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\n\t       (u32)fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);\n\tWREG32(EVERGREEN_GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\n\t       (u32) fb_location & EVERGREEN_GRPH_SURFACE_ADDRESS_MASK);\n\tWREG32(EVERGREEN_GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);\n\tWREG32(EVERGREEN_GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);\n\n\t \n\tWREG32_P(EVERGREEN_GRPH_LUT_10BIT_BYPASS_CONTROL + radeon_crtc->crtc_offset,\n\t\t (bypass_lut ? EVERGREEN_LUT_10BIT_BYPASS_EN : 0),\n\t\t ~EVERGREEN_LUT_10BIT_BYPASS_EN);\n\n\tif (bypass_lut)\n\t\tDRM_DEBUG_KMS(\"Bypassing hardware LUT due to 10 bit fb scanout.\\n\");\n\n\tWREG32(EVERGREEN_GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_GRPH_X_START + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_GRPH_Y_START + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_GRPH_X_END + radeon_crtc->crtc_offset, target_fb->width);\n\tWREG32(EVERGREEN_GRPH_Y_END + radeon_crtc->crtc_offset, target_fb->height);\n\n\tfb_pitch_pixels = target_fb->pitches[0] / target_fb->format->cpp[0];\n\tWREG32(EVERGREEN_GRPH_PITCH + radeon_crtc->crtc_offset, fb_pitch_pixels);\n\tWREG32(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 1);\n\n\tif (rdev->family >= CHIP_BONAIRE)\n\t\tWREG32(CIK_LB_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,\n\t\t       target_fb->height);\n\telse\n\t\tWREG32(EVERGREEN_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,\n\t\t       target_fb->height);\n\tx &= ~3;\n\ty &= ~1;\n\tWREG32(EVERGREEN_VIEWPORT_START + radeon_crtc->crtc_offset,\n\t       (x << 16) | y);\n\tviewport_w = crtc->mode.hdisplay;\n\tviewport_h = (crtc->mode.vdisplay + 1) & ~1;\n\tif ((rdev->family >= CHIP_BONAIRE) &&\n\t    (crtc->mode.flags & DRM_MODE_FLAG_INTERLACE))\n\t\tviewport_h *= 2;\n\tWREG32(EVERGREEN_VIEWPORT_SIZE + radeon_crtc->crtc_offset,\n\t       (viewport_w << 16) | viewport_h);\n\n\t \n\tWREG32(EVERGREEN_MASTER_UPDATE_MODE + radeon_crtc->crtc_offset, 0);\n\n\tif (!atomic && fb && fb != crtc->primary->fb) {\n\t\trbo = gem_to_radeon_bo(fb->obj[0]);\n\t\tr = radeon_bo_reserve(rbo, false);\n\t\tif (unlikely(r != 0))\n\t\t\treturn r;\n\t\tradeon_bo_unpin(rbo);\n\t\tradeon_bo_unreserve(rbo);\n\t}\n\n\t \n\tradeon_bandwidth_update(rdev);\n\n\treturn 0;\n}\n\nstatic int avivo_crtc_do_set_base(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_framebuffer *fb,\n\t\t\t\t  int x, int y, int atomic)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_gem_object *obj;\n\tstruct radeon_bo *rbo;\n\tstruct drm_framebuffer *target_fb;\n\tuint64_t fb_location;\n\tuint32_t fb_format, fb_pitch_pixels, tiling_flags;\n\tu32 fb_swap = R600_D1GRPH_SWAP_ENDIAN_NONE;\n\tu32 viewport_w, viewport_h;\n\tint r;\n\tbool bypass_lut = false;\n\n\t \n\tif (!atomic && !crtc->primary->fb) {\n\t\tDRM_DEBUG_KMS(\"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\tif (atomic)\n\t\ttarget_fb = fb;\n\telse\n\t\ttarget_fb = crtc->primary->fb;\n\n\tobj = target_fb->obj[0];\n\trbo = gem_to_radeon_bo(obj);\n\tr = radeon_bo_reserve(rbo, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\n\t \n\tif (atomic)\n\t\tfb_location = radeon_bo_gpu_offset(rbo);\n\telse {\n\t\tr = radeon_bo_pin(rbo, RADEON_GEM_DOMAIN_VRAM, &fb_location);\n\t\tif (unlikely(r != 0)) {\n\t\t\tradeon_bo_unreserve(rbo);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tradeon_bo_get_tiling_flags(rbo, &tiling_flags, NULL);\n\tradeon_bo_unreserve(rbo);\n\n\tswitch (target_fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_8BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_8BPP_INDEXED;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB4444:\n\tcase DRM_FORMAT_ARGB4444:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_16BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_16BPP_ARGB4444;\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_16BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_16BPP_ARGB1555;\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_16BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_16BPP_RGB565;\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = R600_D1GRPH_SWAP_ENDIAN_16BIT;\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_32BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;\n#endif\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_32BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_32BPP_ARGB2101010;\n#ifdef __BIG_ENDIAN\n\t\tfb_swap = R600_D1GRPH_SWAP_ENDIAN_32BIT;\n#endif\n\t\t \n\t\tbypass_lut = true;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tfb_format =\n\t\t    AVIVO_D1GRPH_CONTROL_DEPTH_32BPP |\n\t\t    AVIVO_D1GRPH_CONTROL_32BPP_ARGB8888;\n\t\tif (rdev->family >= CHIP_R600)\n\t\t\tfb_swap =\n\t\t\t    (R600_D1GRPH_RED_CROSSBAR(R600_D1GRPH_RED_SEL_B) |\n\t\t\t     R600_D1GRPH_BLUE_CROSSBAR(R600_D1GRPH_BLUE_SEL_R));\n\t\telse  \n\t\t\tfb_format |= AVIVO_D1GRPH_SWAP_RB;\n#ifdef __BIG_ENDIAN\n\t\tfb_swap |= R600_D1GRPH_SWAP_ENDIAN_32BIT;\n#endif\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported screen format %p4cc\\n\",\n\t\t\t  &target_fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rdev->family >= CHIP_R600) {\n\t\tif (tiling_flags & RADEON_TILING_MACRO)\n\t\t\tfb_format |= R600_D1GRPH_ARRAY_MODE_2D_TILED_THIN1;\n\t\telse if (tiling_flags & RADEON_TILING_MICRO)\n\t\t\tfb_format |= R600_D1GRPH_ARRAY_MODE_1D_TILED_THIN1;\n\t} else {\n\t\tif (tiling_flags & RADEON_TILING_MACRO)\n\t\t\tfb_format |= AVIVO_D1GRPH_MACRO_ADDRESS_MODE;\n\n\t\tif (tiling_flags & RADEON_TILING_MICRO)\n\t\t\tfb_format |= AVIVO_D1GRPH_TILED;\n\t}\n\n\tif (radeon_crtc->crtc_id == 0)\n\t\tWREG32(AVIVO_D1VGA_CONTROL, 0);\n\telse\n\t\tWREG32(AVIVO_D2VGA_CONTROL, 0);\n\n\t \n\tWREG32(AVIVO_D1GRPH_FLIP_CONTROL + radeon_crtc->crtc_offset, 0);\n\n\tif (rdev->family >= CHIP_RV770) {\n\t\tif (radeon_crtc->crtc_id) {\n\t\t\tWREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\n\t\t\tWREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\n\t\t} else {\n\t\t\tWREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\n\t\t\tWREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH, upper_32_bits(fb_location));\n\t\t}\n\t}\n\tWREG32(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\n\t       (u32) fb_location);\n\tWREG32(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS +\n\t       radeon_crtc->crtc_offset, (u32) fb_location);\n\tWREG32(AVIVO_D1GRPH_CONTROL + radeon_crtc->crtc_offset, fb_format);\n\tif (rdev->family >= CHIP_R600)\n\t\tWREG32(R600_D1GRPH_SWAP_CONTROL + radeon_crtc->crtc_offset, fb_swap);\n\n\t \n\tWREG32_P(AVIVO_D1GRPH_LUT_SEL + radeon_crtc->crtc_offset,\n\t\t (bypass_lut ? AVIVO_LUT_10BIT_BYPASS_EN : 0), ~AVIVO_LUT_10BIT_BYPASS_EN);\n\n\tif (bypass_lut)\n\t\tDRM_DEBUG_KMS(\"Bypassing hardware LUT due to 10 bit fb scanout.\\n\");\n\n\tWREG32(AVIVO_D1GRPH_SURFACE_OFFSET_X + radeon_crtc->crtc_offset, 0);\n\tWREG32(AVIVO_D1GRPH_SURFACE_OFFSET_Y + radeon_crtc->crtc_offset, 0);\n\tWREG32(AVIVO_D1GRPH_X_START + radeon_crtc->crtc_offset, 0);\n\tWREG32(AVIVO_D1GRPH_Y_START + radeon_crtc->crtc_offset, 0);\n\tWREG32(AVIVO_D1GRPH_X_END + radeon_crtc->crtc_offset, target_fb->width);\n\tWREG32(AVIVO_D1GRPH_Y_END + radeon_crtc->crtc_offset, target_fb->height);\n\n\tfb_pitch_pixels = target_fb->pitches[0] / target_fb->format->cpp[0];\n\tWREG32(AVIVO_D1GRPH_PITCH + radeon_crtc->crtc_offset, fb_pitch_pixels);\n\tWREG32(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 1);\n\n\tWREG32(AVIVO_D1MODE_DESKTOP_HEIGHT + radeon_crtc->crtc_offset,\n\t       target_fb->height);\n\tx &= ~3;\n\ty &= ~1;\n\tWREG32(AVIVO_D1MODE_VIEWPORT_START + radeon_crtc->crtc_offset,\n\t       (x << 16) | y);\n\tviewport_w = crtc->mode.hdisplay;\n\tviewport_h = (crtc->mode.vdisplay + 1) & ~1;\n\tWREG32(AVIVO_D1MODE_VIEWPORT_SIZE + radeon_crtc->crtc_offset,\n\t       (viewport_w << 16) | viewport_h);\n\n\t \n\tWREG32(AVIVO_D1MODE_MASTER_UPDATE_MODE + radeon_crtc->crtc_offset, 3);\n\n\tif (!atomic && fb && fb != crtc->primary->fb) {\n\t\trbo = gem_to_radeon_bo(fb->obj[0]);\n\t\tr = radeon_bo_reserve(rbo, false);\n\t\tif (unlikely(r != 0))\n\t\t\treturn r;\n\t\tradeon_bo_unpin(rbo);\n\t\tradeon_bo_unreserve(rbo);\n\t}\n\n\t \n\tradeon_bandwidth_update(rdev);\n\n\treturn 0;\n}\n\nint atombios_crtc_set_base(struct drm_crtc *crtc, int x, int y,\n\t\t\t   struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\treturn dce4_crtc_do_set_base(crtc, old_fb, x, y, 0);\n\telse if (ASIC_IS_AVIVO(rdev))\n\t\treturn avivo_crtc_do_set_base(crtc, old_fb, x, y, 0);\n\telse\n\t\treturn radeon_crtc_do_set_base(crtc, old_fb, x, y, 0);\n}\n\nint atombios_crtc_set_base_atomic(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_framebuffer *fb,\n\t\t\t\t  int x, int y, enum mode_set_atomic state)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\treturn dce4_crtc_do_set_base(crtc, fb, x, y, 1);\n\telse if (ASIC_IS_AVIVO(rdev))\n\t\treturn avivo_crtc_do_set_base(crtc, fb, x, y, 1);\n\telse\n\t\treturn radeon_crtc_do_set_base(crtc, fb, x, y, 1);\n}\n\n \nstatic void radeon_legacy_atom_fixup(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tu32 disp_merge_cntl;\n\n\tswitch (radeon_crtc->crtc_id) {\n\tcase 0:\n\t\tdisp_merge_cntl = RREG32(RADEON_DISP_MERGE_CNTL);\n\t\tdisp_merge_cntl &= ~RADEON_DISP_RGB_OFFSET_EN;\n\t\tWREG32(RADEON_DISP_MERGE_CNTL, disp_merge_cntl);\n\t\tbreak;\n\tcase 1:\n\t\tdisp_merge_cntl = RREG32(RADEON_DISP2_MERGE_CNTL);\n\t\tdisp_merge_cntl &= ~RADEON_DISP2_RGB_OFFSET_EN;\n\t\tWREG32(RADEON_DISP2_MERGE_CNTL, disp_merge_cntl);\n\t\tWREG32(RADEON_FP_H2_SYNC_STRT_WID,   RREG32(RADEON_CRTC2_H_SYNC_STRT_WID));\n\t\tWREG32(RADEON_FP_V2_SYNC_STRT_WID,   RREG32(RADEON_CRTC2_V_SYNC_STRT_WID));\n\t\tbreak;\n\t}\n}\n\n \nstatic u32 radeon_get_pll_use_mask(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_crtc *test_crtc;\n\tstruct radeon_crtc *test_radeon_crtc;\n\tu32 pll_in_use = 0;\n\n\tlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc == test_crtc)\n\t\t\tcontinue;\n\n\t\ttest_radeon_crtc = to_radeon_crtc(test_crtc);\n\t\tif (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID)\n\t\t\tpll_in_use |= (1 << test_radeon_crtc->pll_id);\n\t}\n\treturn pll_in_use;\n}\n\n \nstatic int radeon_get_shared_dp_ppll(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_crtc *test_crtc;\n\tstruct radeon_crtc *test_radeon_crtc;\n\n\tlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc == test_crtc)\n\t\t\tcontinue;\n\t\ttest_radeon_crtc = to_radeon_crtc(test_crtc);\n\t\tif (test_radeon_crtc->encoder &&\n\t\t    ENCODER_MODE_IS_DP(atombios_get_encoder_mode(test_radeon_crtc->encoder))) {\n\t\t\t \n\t\t\tif (ASIC_IS_DCE61(rdev) && !ASIC_IS_DCE8(rdev) &&\n\t\t\t    test_radeon_crtc->pll_id == ATOM_PPLL2)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID)\n\t\t\t\treturn test_radeon_crtc->pll_id;\n\t\t}\n\t}\n\treturn ATOM_PPLL_INVALID;\n}\n\n \nstatic int radeon_get_shared_nondp_ppll(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_crtc *test_crtc;\n\tstruct radeon_crtc *test_radeon_crtc;\n\tu32 adjusted_clock, test_adjusted_clock;\n\n\tadjusted_clock = radeon_crtc->adjusted_clock;\n\n\tif (adjusted_clock == 0)\n\t\treturn ATOM_PPLL_INVALID;\n\n\tlist_for_each_entry(test_crtc, &dev->mode_config.crtc_list, head) {\n\t\tif (crtc == test_crtc)\n\t\t\tcontinue;\n\t\ttest_radeon_crtc = to_radeon_crtc(test_crtc);\n\t\tif (test_radeon_crtc->encoder &&\n\t\t    !ENCODER_MODE_IS_DP(atombios_get_encoder_mode(test_radeon_crtc->encoder))) {\n\t\t\t \n\t\t\tif (ASIC_IS_DCE61(rdev) && !ASIC_IS_DCE8(rdev) &&\n\t\t\t    test_radeon_crtc->pll_id == ATOM_PPLL2)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (test_radeon_crtc->connector == radeon_crtc->connector) {\n\t\t\t\t \n\t\t\t\tif (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID)\n\t\t\t\t\treturn test_radeon_crtc->pll_id;\n\t\t\t}\n\t\t\t \n\t\t\ttest_adjusted_clock = test_radeon_crtc->adjusted_clock;\n\t\t\tif ((crtc->mode.clock == test_crtc->mode.clock) &&\n\t\t\t    (adjusted_clock == test_adjusted_clock) &&\n\t\t\t    (radeon_crtc->ss_enabled == test_radeon_crtc->ss_enabled) &&\n\t\t\t    (test_radeon_crtc->pll_id != ATOM_PPLL_INVALID))\n\t\t\t\treturn test_radeon_crtc->pll_id;\n\t\t}\n\t}\n\treturn ATOM_PPLL_INVALID;\n}\n\n \nstatic int radeon_atom_pick_pll(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder =\n\t\tto_radeon_encoder(radeon_crtc->encoder);\n\tu32 pll_in_use;\n\tint pll;\n\n\tif (ASIC_IS_DCE8(rdev)) {\n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\n\t\t\tif (rdev->clock.dp_extclk)\n\t\t\t\t \n\t\t\t\treturn ATOM_PPLL_INVALID;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tpll = radeon_get_shared_dp_ppll(crtc);\n\t\t\t\tif (pll != ATOM_PPLL_INVALID)\n\t\t\t\t\treturn pll;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tpll = radeon_get_shared_nondp_ppll(crtc);\n\t\t\tif (pll != ATOM_PPLL_INVALID)\n\t\t\t\treturn pll;\n\t\t}\n\t\t \n\t\tif ((rdev->family == CHIP_KABINI) ||\n\t\t    (rdev->family == CHIP_MULLINS)) {\n\t\t\t \n\t\t\tpll_in_use = radeon_get_pll_use_mask(crtc);\n\t\t\tif (!(pll_in_use & (1 << ATOM_PPLL2)))\n\t\t\t\treturn ATOM_PPLL2;\n\t\t\tif (!(pll_in_use & (1 << ATOM_PPLL1)))\n\t\t\t\treturn ATOM_PPLL1;\n\t\t\tDRM_ERROR(\"unable to allocate a PPLL\\n\");\n\t\t\treturn ATOM_PPLL_INVALID;\n\t\t} else {\n\t\t\t \n\t\t\tpll_in_use = radeon_get_pll_use_mask(crtc);\n\t\t\tif (!(pll_in_use & (1 << ATOM_PPLL2)))\n\t\t\t\treturn ATOM_PPLL2;\n\t\t\tif (!(pll_in_use & (1 << ATOM_PPLL1)))\n\t\t\t\treturn ATOM_PPLL1;\n\t\t\tif (!(pll_in_use & (1 << ATOM_PPLL0)))\n\t\t\t\treturn ATOM_PPLL0;\n\t\t\tDRM_ERROR(\"unable to allocate a PPLL\\n\");\n\t\t\treturn ATOM_PPLL_INVALID;\n\t\t}\n\t} else if (ASIC_IS_DCE61(rdev)) {\n\t\tstruct radeon_encoder_atom_dig *dig =\n\t\t\tradeon_encoder->enc_priv;\n\n\t\tif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_UNIPHY) &&\n\t\t    (dig->linkb == false))\n\t\t\t \n\t\t\treturn ATOM_PPLL2;\n\t\telse if (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\n\t\t\t \n\t\t\tif (rdev->clock.dp_extclk)\n\t\t\t\t \n\t\t\t\treturn ATOM_PPLL_INVALID;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tpll = radeon_get_shared_dp_ppll(crtc);\n\t\t\t\tif (pll != ATOM_PPLL_INVALID)\n\t\t\t\t\treturn pll;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tpll = radeon_get_shared_nondp_ppll(crtc);\n\t\t\tif (pll != ATOM_PPLL_INVALID)\n\t\t\t\treturn pll;\n\t\t}\n\t\t \n\t\tpll_in_use = radeon_get_pll_use_mask(crtc);\n\t\tif (!(pll_in_use & (1 << ATOM_PPLL0)))\n\t\t\treturn ATOM_PPLL0;\n\t\tif (!(pll_in_use & (1 << ATOM_PPLL1)))\n\t\t\treturn ATOM_PPLL1;\n\t\tDRM_ERROR(\"unable to allocate a PPLL\\n\");\n\t\treturn ATOM_PPLL_INVALID;\n\t} else if (ASIC_IS_DCE41(rdev)) {\n\t\t \n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\n\t\t\tif (rdev->clock.dp_extclk)\n\t\t\t\t \n\t\t\t\treturn ATOM_PPLL_INVALID;\n\t\t}\n\t\tpll_in_use = radeon_get_pll_use_mask(crtc);\n\t\tif (!(pll_in_use & (1 << ATOM_PPLL1)))\n\t\t\treturn ATOM_PPLL1;\n\t\tif (!(pll_in_use & (1 << ATOM_PPLL2)))\n\t\t\treturn ATOM_PPLL2;\n\t\tDRM_ERROR(\"unable to allocate a PPLL\\n\");\n\t\treturn ATOM_PPLL_INVALID;\n\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\t \n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder))) {\n\t\t\tif (rdev->clock.dp_extclk)\n\t\t\t\t \n\t\t\t\treturn ATOM_PPLL_INVALID;\n\t\t\telse if (ASIC_IS_DCE6(rdev))\n\t\t\t\t \n\t\t\t\treturn ATOM_PPLL0;\n\t\t\telse if (ASIC_IS_DCE5(rdev))\n\t\t\t\t \n\t\t\t\treturn ATOM_DCPLL;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tpll = radeon_get_shared_dp_ppll(crtc);\n\t\t\t\tif (pll != ATOM_PPLL_INVALID)\n\t\t\t\t\treturn pll;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tpll = radeon_get_shared_nondp_ppll(crtc);\n\t\t\tif (pll != ATOM_PPLL_INVALID)\n\t\t\t\treturn pll;\n\t\t}\n\t\t \n\t\tpll_in_use = radeon_get_pll_use_mask(crtc);\n\t\tif (!(pll_in_use & (1 << ATOM_PPLL1)))\n\t\t\treturn ATOM_PPLL1;\n\t\tif (!(pll_in_use & (1 << ATOM_PPLL2)))\n\t\t\treturn ATOM_PPLL2;\n\t\tDRM_ERROR(\"unable to allocate a PPLL\\n\");\n\t\treturn ATOM_PPLL_INVALID;\n\t} else {\n\t\t \n\t\t \n\t\treturn radeon_crtc->crtc_id;\n\t}\n}\n\nvoid radeon_atom_disp_eng_pll_init(struct radeon_device *rdev)\n{\n\t \n\tif (ASIC_IS_DCE6(rdev))\n\t\tatombios_crtc_set_disp_eng_pll(rdev, rdev->clock.default_dispclk);\n\telse if (ASIC_IS_DCE4(rdev)) {\n\t\tstruct radeon_atom_ss ss;\n\t\tbool ss_enabled = radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t\t\t   ASIC_INTERNAL_SS_ON_DCPLL,\n\t\t\t\t\t\t\t\t   rdev->clock.default_dispclk);\n\t\tif (ss_enabled)\n\t\t\tatombios_crtc_program_ss(rdev, ATOM_DISABLE, ATOM_DCPLL, -1, &ss);\n\t\t \n\t\tatombios_crtc_set_disp_eng_pll(rdev, rdev->clock.default_dispclk);\n\t\tif (ss_enabled)\n\t\t\tatombios_crtc_program_ss(rdev, ATOM_ENABLE, ATOM_DCPLL, -1, &ss);\n\t}\n\n}\n\nint atombios_crtc_mode_set(struct drm_crtc *crtc,\n\t\t\t   struct drm_display_mode *mode,\n\t\t\t   struct drm_display_mode *adjusted_mode,\n\t\t\t   int x, int y, struct drm_framebuffer *old_fb)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder =\n\t\tto_radeon_encoder(radeon_crtc->encoder);\n\tbool is_tvcv = false;\n\n\tif (radeon_encoder->active_device &\n\t    (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))\n\t\tis_tvcv = true;\n\n\tif (!radeon_crtc->adjusted_clock)\n\t\treturn -EINVAL;\n\n\tatombios_crtc_set_pll(crtc, adjusted_mode);\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\tatombios_set_crtc_dtd_timing(crtc, adjusted_mode);\n\telse if (ASIC_IS_AVIVO(rdev)) {\n\t\tif (is_tvcv)\n\t\t\tatombios_crtc_set_timing(crtc, adjusted_mode);\n\t\telse\n\t\t\tatombios_set_crtc_dtd_timing(crtc, adjusted_mode);\n\t} else {\n\t\tatombios_crtc_set_timing(crtc, adjusted_mode);\n\t\tif (radeon_crtc->crtc_id == 0)\n\t\t\tatombios_set_crtc_dtd_timing(crtc, adjusted_mode);\n\t\tradeon_legacy_atom_fixup(crtc);\n\t}\n\tatombios_crtc_set_base(crtc, x, y, old_fb);\n\tatombios_overscan_setup(crtc, mode, adjusted_mode);\n\tatombios_scaler_setup(crtc);\n\tradeon_cursor_reset(crtc);\n\t \n\tradeon_crtc->hw_mode = *adjusted_mode;\n\n\treturn 0;\n}\n\nstatic bool atombios_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t     const struct drm_display_mode *mode,\n\t\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_encoder *encoder;\n\n\t \n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->crtc == crtc) {\n\t\t\tradeon_crtc->encoder = encoder;\n\t\t\tradeon_crtc->connector = radeon_get_connector_for_encoder(encoder);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ((radeon_crtc->encoder == NULL) || (radeon_crtc->connector == NULL)) {\n\t\tradeon_crtc->encoder = NULL;\n\t\tradeon_crtc->connector = NULL;\n\t\treturn false;\n\t}\n\tif (radeon_crtc->encoder) {\n\t\tstruct radeon_encoder *radeon_encoder =\n\t\t\tto_radeon_encoder(radeon_crtc->encoder);\n\n\t\tradeon_crtc->output_csc = radeon_encoder->output_csc;\n\t}\n\tif (!radeon_crtc_scaling_mode_fixup(crtc, mode, adjusted_mode))\n\t\treturn false;\n\tif (!atombios_crtc_prepare_pll(crtc, adjusted_mode))\n\t\treturn false;\n\t \n\tradeon_crtc->pll_id = radeon_atom_pick_pll(crtc);\n\t \n\tif ((radeon_crtc->pll_id == ATOM_PPLL_INVALID) &&\n\t    !ENCODER_MODE_IS_DP(atombios_get_encoder_mode(radeon_crtc->encoder)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void atombios_crtc_prepare(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\t \n\tif (ASIC_IS_DCE6(rdev))\n\t\tatombios_powergate_crtc(crtc, ATOM_DISABLE);\n\n\tatombios_lock_crtc(crtc, ATOM_ENABLE);\n\tatombios_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\n}\n\nstatic void atombios_crtc_commit(struct drm_crtc *crtc)\n{\n\tatombios_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\n\tatombios_lock_crtc(crtc, ATOM_DISABLE);\n}\n\nstatic void atombios_crtc_disable(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_atom_ss ss;\n\tint i;\n\n\tatombios_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\n\tif (crtc->primary->fb) {\n\t\tint r;\n\t\tstruct radeon_bo *rbo;\n\n\t\trbo = gem_to_radeon_bo(crtc->primary->fb->obj[0]);\n\t\tr = radeon_bo_reserve(rbo, false);\n\t\tif (unlikely(r))\n\t\t\tDRM_ERROR(\"failed to reserve rbo before unpin\\n\");\n\t\telse {\n\t\t\tradeon_bo_unpin(rbo);\n\t\t\tradeon_bo_unreserve(rbo);\n\t\t}\n\t}\n\t \n\tif (ASIC_IS_DCE4(rdev))\n\t\tWREG32(EVERGREEN_GRPH_ENABLE + radeon_crtc->crtc_offset, 0);\n\telse if (ASIC_IS_AVIVO(rdev))\n\t\tWREG32(AVIVO_D1GRPH_ENABLE + radeon_crtc->crtc_offset, 0);\n\n\tif (ASIC_IS_DCE6(rdev))\n\t\tatombios_powergate_crtc(crtc, ATOM_ENABLE);\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (rdev->mode_info.crtcs[i] &&\n\t\t    rdev->mode_info.crtcs[i]->enabled &&\n\t\t    i != radeon_crtc->crtc_id &&\n\t\t    radeon_crtc->pll_id == rdev->mode_info.crtcs[i]->pll_id) {\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tswitch (radeon_crtc->pll_id) {\n\tcase ATOM_PPLL1:\n\tcase ATOM_PPLL2:\n\t\t \n\t\tatombios_crtc_program_pll(crtc, radeon_crtc->crtc_id, radeon_crtc->pll_id,\n\t\t\t\t\t  0, 0, ATOM_DISABLE, 0, 0, 0, 0, 0, false, &ss);\n\t\tbreak;\n\tcase ATOM_PPLL0:\n\t\t \n\t\tif ((rdev->family == CHIP_ARUBA) ||\n\t\t    (rdev->family == CHIP_KAVERI) ||\n\t\t    (rdev->family == CHIP_BONAIRE) ||\n\t\t    (rdev->family == CHIP_HAWAII))\n\t\t\tatombios_crtc_program_pll(crtc, radeon_crtc->crtc_id, radeon_crtc->pll_id,\n\t\t\t\t\t\t  0, 0, ATOM_DISABLE, 0, 0, 0, 0, 0, false, &ss);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\ndone:\n\tradeon_crtc->pll_id = ATOM_PPLL_INVALID;\n\tradeon_crtc->adjusted_clock = 0;\n\tradeon_crtc->encoder = NULL;\n\tradeon_crtc->connector = NULL;\n}\n\nstatic const struct drm_crtc_helper_funcs atombios_helper_funcs = {\n\t.dpms = atombios_crtc_dpms,\n\t.mode_fixup = atombios_crtc_mode_fixup,\n\t.mode_set = atombios_crtc_mode_set,\n\t.mode_set_base = atombios_crtc_set_base,\n\t.mode_set_base_atomic = atombios_crtc_set_base_atomic,\n\t.prepare = atombios_crtc_prepare,\n\t.commit = atombios_crtc_commit,\n\t.disable = atombios_crtc_disable,\n\t.get_scanout_position = radeon_get_crtc_scanout_position,\n};\n\nvoid radeon_atombios_init_crtc(struct drm_device *dev,\n\t\t\t       struct radeon_crtc *radeon_crtc)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (ASIC_IS_DCE4(rdev)) {\n\t\tswitch (radeon_crtc->crtc_id) {\n\t\tcase 0:\n\t\tdefault:\n\t\t\tradeon_crtc->crtc_offset = EVERGREEN_CRTC0_REGISTER_OFFSET;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tradeon_crtc->crtc_offset = EVERGREEN_CRTC1_REGISTER_OFFSET;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tradeon_crtc->crtc_offset = EVERGREEN_CRTC2_REGISTER_OFFSET;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tradeon_crtc->crtc_offset = EVERGREEN_CRTC3_REGISTER_OFFSET;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tradeon_crtc->crtc_offset = EVERGREEN_CRTC4_REGISTER_OFFSET;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tradeon_crtc->crtc_offset = EVERGREEN_CRTC5_REGISTER_OFFSET;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (radeon_crtc->crtc_id == 1)\n\t\t\tradeon_crtc->crtc_offset =\n\t\t\t\tAVIVO_D2CRTC_H_TOTAL - AVIVO_D1CRTC_H_TOTAL;\n\t\telse\n\t\t\tradeon_crtc->crtc_offset = 0;\n\t}\n\tradeon_crtc->pll_id = ATOM_PPLL_INVALID;\n\tradeon_crtc->adjusted_clock = 0;\n\tradeon_crtc->encoder = NULL;\n\tradeon_crtc->connector = NULL;\n\tdrm_crtc_helper_add(&radeon_crtc->base, &atombios_helper_funcs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}