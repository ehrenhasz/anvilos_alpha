{
  "module_name": "radeon_dp_auxch.c",
  "hash_id": "3fd0eadca319d3042ca14c53eed8415ceec8f03f05fc56c682eb129357573014",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_dp_auxch.c",
  "human_readable_source": " \n\n#include <drm/radeon_drm.h>\n#include \"radeon.h\"\n#include \"nid.h\"\n\n#define AUX_RX_ERROR_FLAGS (AUX_SW_RX_OVERFLOW |\t     \\\n\t\t\t    AUX_SW_RX_HPD_DISCON |\t     \\\n\t\t\t    AUX_SW_RX_PARTIAL_BYTE |\t     \\\n\t\t\t    AUX_SW_NON_AUX_MODE |\t     \\\n\t\t\t    AUX_SW_RX_SYNC_INVALID_L |\t     \\\n\t\t\t    AUX_SW_RX_SYNC_INVALID_H |\t     \\\n\t\t\t    AUX_SW_RX_INVALID_START |\t     \\\n\t\t\t    AUX_SW_RX_RECV_NO_DET |\t     \\\n\t\t\t    AUX_SW_RX_RECV_INVALID_H |\t     \\\n\t\t\t    AUX_SW_RX_RECV_INVALID_V)\n\n#define AUX_SW_REPLY_GET_BYTE_COUNT(x) (((x) >> 24) & 0x1f)\n\n#define BARE_ADDRESS_SIZE 3\n\nstatic const u32 aux_offset[] =\n{\n\t0x6200 - 0x6200,\n\t0x6250 - 0x6200,\n\t0x62a0 - 0x6200,\n\t0x6300 - 0x6200,\n\t0x6350 - 0x6200,\n\t0x63a0 - 0x6200,\n};\n\nssize_t\nradeon_dp_aux_transfer_native(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tstruct radeon_i2c_chan *chan =\n\t\tcontainer_of(aux, struct radeon_i2c_chan, aux);\n\tstruct drm_device *dev = chan->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint ret = 0, i;\n\tuint32_t tmp, ack = 0;\n\tint instance = chan->rec.i2c_id & 0xf;\n\tu8 byte;\n\tu8 *buf = msg->buffer;\n\tint retry_count = 0;\n\tint bytes;\n\tint msize;\n\tbool is_write = false;\n\n\tif (WARN_ON(msg->size > 16))\n\t\treturn -E2BIG;\n\n\tswitch (msg->request & ~DP_AUX_I2C_MOT) {\n\tcase DP_AUX_NATIVE_WRITE:\n\tcase DP_AUX_I2C_WRITE:\n\t\tis_write = true;\n\t\tbreak;\n\tcase DP_AUX_NATIVE_READ:\n\tcase DP_AUX_I2C_READ:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmsize = 0;\n\tbytes = BARE_ADDRESS_SIZE;\n\tif (msg->size) {\n\t\tmsize = msg->size - 1;\n\t\tbytes++;\n\t\tif (is_write)\n\t\t\tbytes += msg->size;\n\t}\n\n\tmutex_lock(&chan->mutex);\n\n\t \n\ttmp = RREG32(chan->rec.mask_clk_reg);\n\ttmp |= (1 << 16);\n\tWREG32(chan->rec.mask_clk_reg, tmp);\n\n\t \n\ttmp = RREG32(AUX_CONTROL + aux_offset[instance]);\n\n\ttmp &= AUX_HPD_SEL(0x7);\n\ttmp |= AUX_HPD_SEL(chan->rec.hpd);\n\ttmp |= AUX_EN | AUX_LS_READ_EN;\n\n\tWREG32(AUX_CONTROL + aux_offset[instance], tmp);\n\n\t \n\tWREG32(AUX_SW_CONTROL + aux_offset[instance],\n\t       AUX_SW_WR_BYTES(bytes));\n\tWREG32(AUX_SW_CONTROL + aux_offset[instance],\n\t       AUX_SW_WR_BYTES(bytes));\n\n\t \n\t \n\tbyte = (msg->request << 4) | ((msg->address >> 16) & 0xf);\n\tWREG32(AUX_SW_DATA + aux_offset[instance],\n\t       AUX_SW_DATA_MASK(byte) | AUX_SW_AUTOINCREMENT_DISABLE);\n\n\tbyte = (msg->address >> 8) & 0xff;\n\tWREG32(AUX_SW_DATA + aux_offset[instance],\n\t       AUX_SW_DATA_MASK(byte));\n\n\tbyte = msg->address & 0xff;\n\tWREG32(AUX_SW_DATA + aux_offset[instance],\n\t       AUX_SW_DATA_MASK(byte));\n\n\tbyte = msize;\n\tWREG32(AUX_SW_DATA + aux_offset[instance],\n\t       AUX_SW_DATA_MASK(byte));\n\n\t \n\tif (is_write) {\n\t\tfor (i = 0; i < msg->size; i++) {\n\t\t\tWREG32(AUX_SW_DATA + aux_offset[instance],\n\t\t\t       AUX_SW_DATA_MASK(buf[i]));\n\t\t}\n\t}\n\n\t \n\tWREG32(AUX_SW_INTERRUPT_CONTROL + aux_offset[instance], AUX_SW_DONE_ACK);\n\n\t \n\tWREG32(AUX_SW_CONTROL + aux_offset[instance],\n\t       AUX_SW_WR_BYTES(bytes) | AUX_SW_GO);\n\n\t \n\tdo {\n\t\ttmp = RREG32(AUX_SW_STATUS + aux_offset[instance]);\n\t\tif (tmp & AUX_SW_DONE) {\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(100, 200);\n\t} while (retry_count++ < 1000);\n\n\tif (retry_count >= 1000) {\n\t\tdev_err(rdev->dev, \"auxch hw never signalled completion, error %08x\\n\", tmp);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (tmp & AUX_SW_RX_TIMEOUT) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\tif (tmp & AUX_RX_ERROR_FLAGS) {\n\t\tdrm_dbg_kms_ratelimited(dev, \"dp_aux_ch flags not zero: %08x\\n\", tmp);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tbytes = AUX_SW_REPLY_GET_BYTE_COUNT(tmp);\n\tif (bytes) {\n\t\tWREG32(AUX_SW_DATA + aux_offset[instance],\n\t\t       AUX_SW_DATA_RW | AUX_SW_AUTOINCREMENT_DISABLE);\n\n\t\ttmp = RREG32(AUX_SW_DATA + aux_offset[instance]);\n\t\tack = (tmp >> 8) & 0xff;\n\n\t\tfor (i = 0; i < bytes - 1; i++) {\n\t\t\ttmp = RREG32(AUX_SW_DATA + aux_offset[instance]);\n\t\t\tif (buf)\n\t\t\t\tbuf[i] = (tmp >> 8) & 0xff;\n\t\t}\n\t\tif (buf)\n\t\t\tret = bytes - 1;\n\t}\n\n\tWREG32(AUX_SW_INTERRUPT_CONTROL + aux_offset[instance], AUX_SW_DONE_ACK);\n\n\tif (is_write)\n\t\tret = msg->size;\ndone:\n\tmutex_unlock(&chan->mutex);\n\n\tif (ret >= 0)\n\t\tmsg->reply = ack >> 4;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}