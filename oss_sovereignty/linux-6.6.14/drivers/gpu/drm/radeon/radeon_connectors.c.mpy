{
  "module_name": "radeon_connectors.c",
  "hash_id": "cbf4e14708cafb60682f59bb9bda0a32dccac5b317e3b10896dbb4262ec2b18e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_connectors.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/radeon_drm.h>\n#include \"radeon.h\"\n#include \"radeon_audio.h\"\n#include \"atom.h\"\n\n#include <linux/pm_runtime.h>\n#include <linux/vga_switcheroo.h>\n\nvoid radeon_connector_hotplug(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\t \n\tif (radeon_connector->hpd.hpd == RADEON_HPD_NONE)\n\t\treturn;\n\n\tradeon_hpd_set_polarity(rdev, radeon_connector->hpd.hpd);\n\n\t \n\t \n\tif (connector->dpms != DRM_MODE_DPMS_ON)\n\t\treturn;\n\n\t \n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\tradeon_connector->con_priv;\n\n\t\t \n\t\tif (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT)\n\t\t\treturn;\n\n\t\t \n\t\tdig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);\n\t\t \n\t\tif (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT &&\n\t\t    radeon_hpd_sense(rdev, radeon_connector->hpd.hpd) &&\n\t\t    radeon_dp_needs_link_train(radeon_connector)) {\n\t\t\t \n\t\t\tif (!radeon_dp_getdpcd(radeon_connector))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tdrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\n\t\t\tdrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\n\t\t}\n\t}\n}\n\nstatic void radeon_property_change_mode(struct drm_encoder *encoder)\n{\n\tstruct drm_crtc *crtc = encoder->crtc;\n\n\tif (crtc && crtc->enabled) {\n\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode,\n\t\t\t\t\t crtc->x, crtc->y, crtc->primary->fb);\n\t}\n}\n\nint radeon_get_monitor_bpc(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *dig_connector;\n\tint bpc = 8;\n\tint mode_clock, max_tmds_clock;\n\n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\tif (radeon_connector->use_digital) {\n\t\t\tif (drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\t\tif (connector->display_info.bpc)\n\t\t\t\t\tbpc = connector->display_info.bpc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVID:\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tif (drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\tif (connector->display_info.bpc)\n\t\t\t\tbpc = connector->display_info.bpc;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tdig_connector = radeon_connector->con_priv;\n\t\tif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t\t    (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) ||\n\t\t    drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\tif (connector->display_info.bpc)\n\t\t\t\tbpc = connector->display_info.bpc;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_eDP:\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tif (connector->display_info.bpc)\n\t\t\tbpc = connector->display_info.bpc;\n\t\telse if (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE5(rdev)) {\n\t\t\tconst struct drm_connector_helper_funcs *connector_funcs =\n\t\t\t\tconnector->helper_private;\n\t\t\tstruct drm_encoder *encoder = connector_funcs->best_encoder(connector);\n\t\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\t\t\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_V13_6BIT_PER_COLOR)\n\t\t\t\tbpc = 6;\n\t\t\telse if (dig->lcd_misc & ATOM_PANEL_MISC_V13_8BIT_PER_COLOR)\n\t\t\t\tbpc = 8;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t \n\t\tif ((bpc > 8) && !ASIC_IS_DCE4(rdev)) {\n\t\t\tDRM_DEBUG(\"%s: HDMI deep color %d bpc unsupported. Using 8 bpc.\\n\",\n\t\t\t\t\t  connector->name, bpc);\n\t\t\tbpc = 8;\n\t\t}\n\n\t\t \n\t\tif (bpc > 12) {\n\t\t\tDRM_DEBUG(\"%s: HDMI deep color %d bpc unsupported. Using 12 bpc.\\n\",\n\t\t\t\t\t  connector->name, bpc);\n\t\t\tbpc = 12;\n\t\t}\n\n\t\t \n\t\tif (connector->display_info.max_tmds_clock > 0) {\n\t\t\t \n\t\t\tmode_clock = radeon_connector->pixelclock_for_modeset;\n\n\t\t\t \n\t\t\tmax_tmds_clock = connector->display_info.max_tmds_clock;\n\n\t\t\tDRM_DEBUG(\"%s: hdmi mode dotclock %d kHz, max tmds input clock %d kHz.\\n\",\n\t\t\t\t\t  connector->name, mode_clock, max_tmds_clock);\n\n\t\t\t \n\t\t\tif ((bpc == 12) && (mode_clock * 3/2 > max_tmds_clock)) {\n\t\t\t\tif ((connector->display_info.edid_hdmi_rgb444_dc_modes & DRM_EDID_HDMI_DC_30) &&\n\t\t\t\t\t(mode_clock * 5/4 <= max_tmds_clock))\n\t\t\t\t\tbpc = 10;\n\t\t\t\telse\n\t\t\t\t\tbpc = 8;\n\n\t\t\t\tDRM_DEBUG(\"%s: HDMI deep color 12 bpc exceeds max tmds clock. Using %d bpc.\\n\",\n\t\t\t\t\t\t  connector->name, bpc);\n\t\t\t}\n\n\t\t\tif ((bpc == 10) && (mode_clock * 5/4 > max_tmds_clock)) {\n\t\t\t\tbpc = 8;\n\t\t\t\tDRM_DEBUG(\"%s: HDMI deep color 10 bpc exceeds max tmds clock. Using %d bpc.\\n\",\n\t\t\t\t\t\t  connector->name, bpc);\n\t\t\t}\n\t\t} else if (bpc > 8) {\n\t\t\t \n\t\t\tDRM_DEBUG(\"%s: Required max tmds clock for HDMI deep color missing. Using 8 bpc.\\n\",\n\t\t\t\t\t  connector->name);\n\t\t\tbpc = 8;\n\t\t}\n\t}\n\n\tif ((radeon_deep_color == 0) && (bpc > 8)) {\n\t\tDRM_DEBUG(\"%s: Deep color disabled. Set radeon module param deep_color=1 to enable.\\n\",\n\t\t\t\t  connector->name);\n\t\tbpc = 8;\n\t}\n\n\tDRM_DEBUG(\"%s: Display bpc=%d, returned bpc=%d\\n\",\n\t\t\t  connector->name, connector->display_info.bpc, bpc);\n\n\treturn bpc;\n}\n\nstatic void\nradeon_connector_update_scratch_regs(struct drm_connector *connector, enum drm_connector_status status)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_encoder *best_encoder;\n\tstruct drm_encoder *encoder;\n\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\tbool connected;\n\n\tbest_encoder = connector_funcs->best_encoder(connector);\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif ((encoder == best_encoder) && (status == connector_status_connected))\n\t\t\tconnected = true;\n\t\telse\n\t\t\tconnected = false;\n\n\t\tif (rdev->is_atom_bios)\n\t\t\tradeon_atombios_connected_scratch_regs(connector, encoder, connected);\n\t\telse\n\t\t\tradeon_combios_connected_scratch_regs(connector, encoder, connected);\n\t}\n}\n\nstatic struct drm_encoder *radeon_find_encoder(struct drm_connector *connector, int encoder_type)\n{\n\tstruct drm_encoder *encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif (encoder->encoder_type == encoder_type)\n\t\t\treturn encoder;\n\t}\n\n\treturn NULL;\n}\n\nstruct edid *radeon_connector_edid(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_property_blob *edid_blob = connector->edid_blob_ptr;\n\n\tif (radeon_connector->edid) {\n\t\treturn radeon_connector->edid;\n\t} else if (edid_blob) {\n\t\tstruct edid *edid = kmemdup(edid_blob->data, edid_blob->length, GFP_KERNEL);\n\t\tif (edid)\n\t\t\tradeon_connector->edid = edid;\n\t}\n\treturn radeon_connector->edid;\n}\n\nstatic void radeon_connector_get_edid(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\tif (radeon_connector->edid)\n\t\treturn;\n\n\t \n\tif (radeon_connector->router.ddc_valid)\n\t\tradeon_router_select_ddc_port(radeon_connector);\n\n\tif ((radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t     ENCODER_OBJECT_ID_NONE) &&\n\t    radeon_connector->ddc_bus->has_aux) {\n\t\tradeon_connector->edid = drm_get_edid(connector,\n\t\t\t\t\t\t      &radeon_connector->ddc_bus->aux.ddc);\n\t} else if ((connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) ||\n\t\t   (connector->connector_type == DRM_MODE_CONNECTOR_eDP)) {\n\t\tstruct radeon_connector_atom_dig *dig = radeon_connector->con_priv;\n\n\t\tif ((dig->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT ||\n\t\t     dig->dp_sink_type == CONNECTOR_OBJECT_ID_eDP) &&\n\t\t    radeon_connector->ddc_bus->has_aux)\n\t\t\tradeon_connector->edid = drm_get_edid(&radeon_connector->base,\n\t\t\t\t\t\t\t      &radeon_connector->ddc_bus->aux.ddc);\n\t\telse if (radeon_connector->ddc_bus)\n\t\t\tradeon_connector->edid = drm_get_edid(&radeon_connector->base,\n\t\t\t\t\t\t\t      &radeon_connector->ddc_bus->adapter);\n\t} else if (vga_switcheroo_handler_flags() & VGA_SWITCHEROO_CAN_SWITCH_DDC &&\n\t\t   connector->connector_type == DRM_MODE_CONNECTOR_LVDS &&\n\t\t   radeon_connector->ddc_bus) {\n\t\tradeon_connector->edid = drm_get_edid_switcheroo(&radeon_connector->base,\n\t\t\t\t\t\t\t\t &radeon_connector->ddc_bus->adapter);\n\t} else if (radeon_connector->ddc_bus) {\n\t\tradeon_connector->edid = drm_get_edid(&radeon_connector->base,\n\t\t\t\t\t\t      &radeon_connector->ddc_bus->adapter);\n\t}\n\n\tif (!radeon_connector->edid) {\n\t\t \n\t\tif ((rdev->flags & RADEON_IS_PX) && (radeon_runtime_pm != 0))\n\t\t\treturn;\n\n\t\tif (rdev->is_atom_bios) {\n\t\t\t \n\t\t\tif (((connector->connector_type == DRM_MODE_CONNECTOR_LVDS) ||\n\t\t\t     (connector->connector_type == DRM_MODE_CONNECTOR_eDP)))\n\t\t\t\tradeon_connector->edid = radeon_bios_get_hardcoded_edid(rdev);\n\t\t} else {\n\t\t\t \n\t\t\tradeon_connector->edid = radeon_bios_get_hardcoded_edid(rdev);\n\t\t}\n\t}\n}\n\nstatic void radeon_connector_free_edid(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\tkfree(radeon_connector->edid);\n\tradeon_connector->edid = NULL;\n}\n\nstatic int radeon_ddc_get_modes(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tint ret;\n\n\tif (radeon_connector->edid) {\n\t\tdrm_connector_update_edid_property(connector, radeon_connector->edid);\n\t\tret = drm_add_edid_modes(connector, radeon_connector->edid);\n\t\treturn ret;\n\t}\n\tdrm_connector_update_edid_property(connector, NULL);\n\treturn 0;\n}\n\nstatic struct drm_encoder *radeon_best_single_encoder(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\n\t \n\tdrm_connector_for_each_possible_encoder(connector, encoder)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic void radeon_get_native_mode(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\n\tstruct radeon_encoder *radeon_encoder;\n\n\tif (encoder == NULL)\n\t\treturn;\n\n\tradeon_encoder = to_radeon_encoder(encoder);\n\n\tif (!list_empty(&connector->probed_modes)) {\n\t\tstruct drm_display_mode *preferred_mode =\n\t\t\tlist_first_entry(&connector->probed_modes,\n\t\t\t\t\t struct drm_display_mode, head);\n\n\t\tradeon_encoder->native_mode = *preferred_mode;\n\t} else {\n\t\tradeon_encoder->native_mode.clock = 0;\n\t}\n}\n\n \nstatic enum drm_connector_status\nradeon_connector_analog_encoder_conflict_solve(struct drm_connector *connector,\n\t\t\t\t\t       struct drm_encoder *encoder,\n\t\t\t\t\t       enum drm_connector_status current_status,\n\t\t\t\t\t       bool priority)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_connector *conflict;\n\tstruct radeon_connector *radeon_conflict;\n\n\tlist_for_each_entry(conflict, &dev->mode_config.connector_list, head) {\n\t\tstruct drm_encoder *enc;\n\n\t\tif (conflict == connector)\n\t\t\tcontinue;\n\n\t\tradeon_conflict = to_radeon_connector(conflict);\n\n\t\tdrm_connector_for_each_possible_encoder(conflict, enc) {\n\t\t\t \n\t\t\tif (enc == encoder) {\n\t\t\t\tif (conflict->status != connector_status_connected)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (radeon_conflict->use_digital)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (priority) {\n\t\t\t\t\tDRM_DEBUG_KMS(\"1: conflicting encoders switching off %s\\n\",\n\t\t\t\t\t\t      conflict->name);\n\t\t\t\t\tDRM_DEBUG_KMS(\"in favor of %s\\n\",\n\t\t\t\t\t\t      connector->name);\n\t\t\t\t\tconflict->status = connector_status_disconnected;\n\t\t\t\t\tradeon_connector_update_scratch_regs(conflict, connector_status_disconnected);\n\t\t\t\t} else {\n\t\t\t\t\tDRM_DEBUG_KMS(\"2: conflicting encoders switching off %s\\n\",\n\t\t\t\t\t\t      connector->name);\n\t\t\t\t\tDRM_DEBUG_KMS(\"in favor of %s\\n\",\n\t\t\t\t\t\t      conflict->name);\n\t\t\t\t\tcurrent_status = connector_status_disconnected;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn current_status;\n\n}\n\nstatic struct drm_display_mode *radeon_fp_native_mode(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\n\tif (native_mode->hdisplay != 0 &&\n\t    native_mode->vdisplay != 0 &&\n\t    native_mode->clock != 0) {\n\t\tmode = drm_mode_duplicate(dev, native_mode);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\t\tmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\t\tdrm_mode_set_name(mode);\n\n\t\tDRM_DEBUG_KMS(\"Adding native panel mode %s\\n\", mode->name);\n\t} else if (native_mode->hdisplay != 0 &&\n\t\t   native_mode->vdisplay != 0) {\n\t\t \n\t\t \n\t\tmode = drm_cvt_mode(dev, native_mode->hdisplay, native_mode->vdisplay, 60, true, false, false);\n\t\tif (!mode)\n\t\t\treturn NULL;\n\t\tmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\n\t\tDRM_DEBUG_KMS(\"Adding cvt approximation of native panel mode %s\\n\", mode->name);\n\t}\n\treturn mode;\n}\n\nstatic void radeon_add_common_modes(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\tint i;\n\tstruct mode_size {\n\t\tint w;\n\t\tint h;\n\t} common_modes[17] = {\n\t\t{ 640,  480},\n\t\t{ 720,  480},\n\t\t{ 800,  600},\n\t\t{ 848,  480},\n\t\t{1024,  768},\n\t\t{1152,  768},\n\t\t{1280,  720},\n\t\t{1280,  800},\n\t\t{1280,  854},\n\t\t{1280,  960},\n\t\t{1280, 1024},\n\t\t{1440,  900},\n\t\t{1400, 1050},\n\t\t{1680, 1050},\n\t\t{1600, 1200},\n\t\t{1920, 1080},\n\t\t{1920, 1200}\n\t};\n\n\tfor (i = 0; i < 17; i++) {\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT)) {\n\t\t\tif (common_modes[i].w > 1024 ||\n\t\t\t    common_modes[i].h > 768)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\tif (common_modes[i].w > native_mode->hdisplay ||\n\t\t\t    common_modes[i].h > native_mode->vdisplay ||\n\t\t\t    (common_modes[i].w == native_mode->hdisplay &&\n\t\t\t     common_modes[i].h == native_mode->vdisplay))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (common_modes[i].w < 320 || common_modes[i].h < 200)\n\t\t\tcontinue;\n\n\t\tmode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h, 60, false, false, false);\n\t\tdrm_mode_probed_add(connector, mode);\n\t}\n}\n\nstatic int radeon_connector_set_property(struct drm_connector *connector, struct drm_property *property,\n\t\t\t\t  uint64_t val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\n\tif (property == rdev->mode_info.coherent_mode_property) {\n\t\tstruct radeon_encoder_atom_dig *dig;\n\t\tbool new_coherent_mode;\n\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tif (!radeon_encoder->enc_priv)\n\t\t\treturn 0;\n\n\t\tdig = radeon_encoder->enc_priv;\n\t\tnew_coherent_mode = val ? true : false;\n\t\tif (dig->coherent_mode != new_coherent_mode) {\n\t\t\tdig->coherent_mode = new_coherent_mode;\n\t\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t\t}\n\t}\n\n\tif (property == rdev->mode_info.audio_property) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tif (radeon_connector->audio != val) {\n\t\t\tradeon_connector->audio = val;\n\t\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t\t}\n\t}\n\n\tif (property == rdev->mode_info.dither_property) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tif (radeon_connector->dither != val) {\n\t\t\tradeon_connector->dither = val;\n\t\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t\t}\n\t}\n\n\tif (property == rdev->mode_info.underscan_property) {\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tif (radeon_encoder->underscan_type != val) {\n\t\t\tradeon_encoder->underscan_type = val;\n\t\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t\t}\n\t}\n\n\tif (property == rdev->mode_info.underscan_hborder_property) {\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tif (radeon_encoder->underscan_hborder != val) {\n\t\t\tradeon_encoder->underscan_hborder = val;\n\t\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t\t}\n\t}\n\n\tif (property == rdev->mode_info.underscan_vborder_property) {\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tif (radeon_encoder->underscan_vborder != val) {\n\t\t\tradeon_encoder->underscan_vborder = val;\n\t\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t\t}\n\t}\n\n\tif (property == rdev->mode_info.tv_std_property) {\n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TVDAC);\n\t\tif (!encoder) {\n\t\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_DAC);\n\t\t}\n\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\tif (!radeon_encoder->enc_priv)\n\t\t\treturn 0;\n\t\tif (ASIC_IS_AVIVO(rdev) || radeon_r4xx_atom) {\n\t\t\tstruct radeon_encoder_atom_dac *dac_int;\n\t\t\tdac_int = radeon_encoder->enc_priv;\n\t\t\tdac_int->tv_std = val;\n\t\t} else {\n\t\t\tstruct radeon_encoder_tv_dac *dac_int;\n\t\t\tdac_int = radeon_encoder->enc_priv;\n\t\t\tdac_int->tv_std = val;\n\t\t}\n\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t}\n\n\tif (property == rdev->mode_info.load_detect_property) {\n\t\tstruct radeon_connector *radeon_connector =\n\t\t\tto_radeon_connector(connector);\n\n\t\tif (val == 0)\n\t\t\tradeon_connector->dac_load_detect = false;\n\t\telse\n\t\t\tradeon_connector->dac_load_detect = true;\n\t}\n\n\tif (property == rdev->mode_info.tmds_pll_property) {\n\t\tstruct radeon_encoder_int_tmds *tmds = NULL;\n\t\tbool ret = false;\n\t\t \n\t\tencoder = radeon_find_encoder(connector, DRM_MODE_ENCODER_TMDS);\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\ttmds = radeon_encoder->enc_priv;\n\t\tif (!tmds)\n\t\t\treturn 0;\n\n\t\tif (val == 0) {\n\t\t\tif (rdev->is_atom_bios)\n\t\t\t\tret = radeon_atombios_get_tmds_info(radeon_encoder, tmds);\n\t\t\telse\n\t\t\t\tret = radeon_legacy_get_tmds_info_from_combios(radeon_encoder, tmds);\n\t\t}\n\t\tif (val == 1 || !ret)\n\t\t\tradeon_legacy_get_tmds_info_from_table(radeon_encoder, tmds);\n\n\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t}\n\n\tif (property == dev->mode_config.scaling_mode_property) {\n\t\tenum radeon_rmx_type rmx_type;\n\n\t\tif (connector->encoder)\n\t\t\tradeon_encoder = to_radeon_encoder(connector->encoder);\n\t\telse {\n\t\t\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\t\t\tradeon_encoder = to_radeon_encoder(connector_funcs->best_encoder(connector));\n\t\t}\n\n\t\tswitch (val) {\n\t\tdefault:\n\t\tcase DRM_MODE_SCALE_NONE: rmx_type = RMX_OFF; break;\n\t\tcase DRM_MODE_SCALE_CENTER: rmx_type = RMX_CENTER; break;\n\t\tcase DRM_MODE_SCALE_ASPECT: rmx_type = RMX_ASPECT; break;\n\t\tcase DRM_MODE_SCALE_FULLSCREEN: rmx_type = RMX_FULL; break;\n\t\t}\n\t\tif (radeon_encoder->rmx_type == rmx_type)\n\t\t\treturn 0;\n\n\t\tif ((rmx_type != DRM_MODE_SCALE_NONE) &&\n\t\t    (radeon_encoder->native_mode.clock == 0))\n\t\t\treturn 0;\n\n\t\tradeon_encoder->rmx_type = rmx_type;\n\n\t\tradeon_property_change_mode(&radeon_encoder->base);\n\t}\n\n\tif (property == rdev->mode_info.output_csc_property) {\n\t\tif (connector->encoder)\n\t\t\tradeon_encoder = to_radeon_encoder(connector->encoder);\n\t\telse {\n\t\t\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\t\t\tradeon_encoder = to_radeon_encoder(connector_funcs->best_encoder(connector));\n\t\t}\n\n\t\tif (radeon_encoder->output_csc == val)\n\t\t\treturn 0;\n\n\t\tradeon_encoder->output_csc = val;\n\n\t\tif (connector->encoder && connector->encoder->crtc) {\n\t\t\tstruct drm_crtc *crtc  = connector->encoder->crtc;\n\t\t\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\n\t\t\tradeon_crtc->output_csc = radeon_encoder->output_csc;\n\n\t\t\t \n\t\t\tcrtc->funcs->gamma_set(crtc, NULL, NULL, NULL, 0, NULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void radeon_fixup_lvds_native_mode(struct drm_encoder *encoder,\n\t\t\t\t\t  struct drm_connector *connector)\n{\n\tstruct radeon_encoder *radeon_encoder =\tto_radeon_encoder(encoder);\n\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\tstruct drm_display_mode *t, *mode;\n\n\t \n\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\n\t\tif (mode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tif (mode->hdisplay != native_mode->hdisplay ||\n\t\t\t    mode->vdisplay != native_mode->vdisplay)\n\t\t\t\tdrm_mode_copy(native_mode, mode);\n\t\t}\n\t}\n\n\t \n\tif (!native_mode->clock) {\n\t\tlist_for_each_entry_safe(mode, t, &connector->probed_modes, head) {\n\t\t\tif (mode->hdisplay == native_mode->hdisplay &&\n\t\t\t    mode->vdisplay == native_mode->vdisplay) {\n\t\t\t\tdrm_mode_copy(native_mode, mode);\n\t\t\t\tdrm_mode_set_crtcinfo(native_mode, CRTC_INTERLACE_HALVE_V);\n\t\t\t\tDRM_DEBUG_KMS(\"Determined LVDS native mode details from EDID\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!native_mode->clock) {\n\t\tDRM_DEBUG_KMS(\"No LVDS native mode details, disabling RMX\\n\");\n\t\tradeon_encoder->rmx_type = RMX_OFF;\n\t}\n}\n\nstatic int radeon_lvds_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tint ret = 0;\n\tstruct drm_display_mode *mode;\n\n\tradeon_connector_get_edid(connector);\n\tret = radeon_ddc_get_modes(connector);\n\tif (ret > 0) {\n\t\tencoder = radeon_best_single_encoder(connector);\n\t\tif (encoder) {\n\t\t\tradeon_fixup_lvds_native_mode(encoder, connector);\n\t\t\t \n\t\t\tradeon_add_common_modes(encoder, connector);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tencoder = radeon_best_single_encoder(connector);\n\tif (!encoder)\n\t\treturn 0;\n\n\t \n\tmode = radeon_fp_native_mode(encoder);\n\tif (mode) {\n\t\tret = 1;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\t \n\t\tconnector->display_info.width_mm = mode->width_mm;\n\t\tconnector->display_info.height_mm = mode->height_mm;\n\t\t \n\t\tradeon_add_common_modes(encoder, connector);\n\t}\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status radeon_lvds_mode_valid(struct drm_connector *connector,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\n\n\tif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\n\t\treturn MODE_PANEL;\n\n\tif (encoder) {\n\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\t\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\n\t\t \n\t\tif ((mode->hdisplay > native_mode->hdisplay) ||\n\t\t    (mode->vdisplay > native_mode->vdisplay))\n\t\t\treturn MODE_PANEL;\n\n\t\t \n\t\tif (radeon_encoder->rmx_type == RMX_OFF) {\n\t\t\tif ((mode->hdisplay != native_mode->hdisplay) ||\n\t\t\t    (mode->vdisplay != native_mode->vdisplay))\n\t\t\t\treturn MODE_PANEL;\n\t\t}\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status\nradeon_lvds_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tint r;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tif (encoder) {\n\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\t\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\n\t\t \n\t\tif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\n\t\t\tret = connector_status_connected;\n\t\t \n\t\tif ((rdev->flags & RADEON_IS_PX) && (radeon_runtime_pm != 0))\n\t\t\tret = connector_status_disconnected;\n\t}\n\n\t \n\tradeon_connector_get_edid(connector);\n\tif (radeon_connector->edid)\n\t\tret = connector_status_connected;\n\t \n\n\tradeon_connector_update_scratch_regs(connector, ret);\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void radeon_connector_unregister(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\tif (radeon_connector->ddc_bus && radeon_connector->ddc_bus->has_aux) {\n\t\tdrm_dp_aux_unregister(&radeon_connector->ddc_bus->aux);\n\t\tradeon_connector->ddc_bus->has_aux = false;\n\t}\n}\n\nstatic void radeon_connector_destroy(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\tradeon_connector_free_edid(connector);\n\tkfree(radeon_connector->con_priv);\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\tkfree(connector);\n}\n\nstatic int radeon_lvds_set_property(struct drm_connector *connector,\n\t\t\t\t    struct drm_property *property,\n\t\t\t\t    uint64_t value)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_encoder *radeon_encoder;\n\tenum radeon_rmx_type rmx_type;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\tif (property != dev->mode_config.scaling_mode_property)\n\t\treturn 0;\n\n\tif (connector->encoder)\n\t\tradeon_encoder = to_radeon_encoder(connector->encoder);\n\telse {\n\t\tconst struct drm_connector_helper_funcs *connector_funcs = connector->helper_private;\n\t\tradeon_encoder = to_radeon_encoder(connector_funcs->best_encoder(connector));\n\t}\n\n\tswitch (value) {\n\tcase DRM_MODE_SCALE_NONE: rmx_type = RMX_OFF; break;\n\tcase DRM_MODE_SCALE_CENTER: rmx_type = RMX_CENTER; break;\n\tcase DRM_MODE_SCALE_ASPECT: rmx_type = RMX_ASPECT; break;\n\tdefault:\n\tcase DRM_MODE_SCALE_FULLSCREEN: rmx_type = RMX_FULL; break;\n\t}\n\tif (radeon_encoder->rmx_type == rmx_type)\n\t\treturn 0;\n\n\tradeon_encoder->rmx_type = rmx_type;\n\n\tradeon_property_change_mode(&radeon_encoder->base);\n\treturn 0;\n}\n\n\nstatic const struct drm_connector_helper_funcs radeon_lvds_connector_helper_funcs = {\n\t.get_modes = radeon_lvds_get_modes,\n\t.mode_valid = radeon_lvds_mode_valid,\n\t.best_encoder = radeon_best_single_encoder,\n};\n\nstatic const struct drm_connector_funcs radeon_lvds_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_lvds_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.set_property = radeon_lvds_set_property,\n};\n\nstatic int radeon_vga_get_modes(struct drm_connector *connector)\n{\n\tint ret;\n\n\tradeon_connector_get_edid(connector);\n\tret = radeon_ddc_get_modes(connector);\n\n\tradeon_get_native_mode(connector);\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status radeon_vga_mode_valid(struct drm_connector *connector,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\t \n\n\tif ((mode->clock / 10) > rdev->clock.max_pixel_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status\nradeon_vga_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_encoder *encoder;\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tbool dret = false;\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tint r;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tencoder = radeon_best_single_encoder(connector);\n\tif (!encoder)\n\t\tret = connector_status_disconnected;\n\n\tif (radeon_connector->ddc_bus)\n\t\tdret = radeon_ddc_probe(radeon_connector, false);\n\tif (dret) {\n\t\tradeon_connector->detected_by_load = false;\n\t\tradeon_connector_free_edid(connector);\n\t\tradeon_connector_get_edid(connector);\n\n\t\tif (!radeon_connector->edid) {\n\t\t\tDRM_ERROR(\"%s: probed a monitor but no|invalid EDID\\n\",\n\t\t\t\t\tconnector->name);\n\t\t\tret = connector_status_connected;\n\t\t} else {\n\t\t\tradeon_connector->use_digital =\n\t\t\t\t!!(radeon_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\n\n\t\t\t \n\t\t\tif (radeon_connector->use_digital && radeon_connector->shared_ddc) {\n\t\t\t\tradeon_connector_free_edid(connector);\n\t\t\t\tret = connector_status_disconnected;\n\t\t\t} else {\n\t\t\t\tret = connector_status_connected;\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\t \n\t\tif (!force) {\n\t\t\t \n\t\t\tif (radeon_connector->detected_by_load)\n\t\t\t\tret = connector->status;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (radeon_connector->dac_load_detect && encoder) {\n\t\t\tencoder_funcs = encoder->helper_private;\n\t\t\tret = encoder_funcs->detect(encoder, connector);\n\t\t\tif (ret != connector_status_disconnected)\n\t\t\t\tradeon_connector->detected_by_load = true;\n\t\t}\n\t}\n\n\tif (ret == connector_status_connected)\n\t\tret = radeon_connector_analog_encoder_conflict_solve(connector, encoder, ret, true);\n\n\t \n\tif ((!rdev->is_atom_bios) &&\n\t    (ret == connector_status_disconnected) &&\n\t    rdev->mode_info.bios_hardcoded_edid_size) {\n\t\tret = connector_status_connected;\n\t}\n\n\tradeon_connector_update_scratch_regs(connector, ret);\n\nout:\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct drm_connector_helper_funcs radeon_vga_connector_helper_funcs = {\n\t.get_modes = radeon_vga_get_modes,\n\t.mode_valid = radeon_vga_mode_valid,\n\t.best_encoder = radeon_best_single_encoder,\n};\n\nstatic const struct drm_connector_funcs radeon_vga_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_vga_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.set_property = radeon_connector_set_property,\n};\n\nstatic int radeon_tv_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_display_mode *tv_mode;\n\tstruct drm_encoder *encoder;\n\n\tencoder = radeon_best_single_encoder(connector);\n\tif (!encoder)\n\t\treturn 0;\n\n\t \n\tif (rdev->family >= CHIP_RS600)\n\t\t \n\t\tradeon_add_common_modes(encoder, connector);\n\telse {\n\t\t \n\t\ttv_mode = drm_cvt_mode(dev, 800, 600, 60, false, false, false);\n\t\tif (!tv_mode)\n\t\t\treturn 0;\n\t\ttv_mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\t\tdrm_mode_probed_add(connector, tv_mode);\n\t}\n\treturn 1;\n}\n\nstatic enum drm_mode_status radeon_tv_mode_valid(struct drm_connector *connector,\n\t\t\t\tstruct drm_display_mode *mode)\n{\n\tif ((mode->hdisplay > 1024) || (mode->vdisplay > 768))\n\t\treturn MODE_CLOCK_RANGE;\n\treturn MODE_OK;\n}\n\nstatic enum drm_connector_status\nradeon_tv_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_encoder *encoder;\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tint r;\n\n\tif (!radeon_connector->dac_load_detect)\n\t\treturn ret;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tencoder = radeon_best_single_encoder(connector);\n\tif (!encoder)\n\t\tret = connector_status_disconnected;\n\telse {\n\t\tencoder_funcs = encoder->helper_private;\n\t\tret = encoder_funcs->detect(encoder, connector);\n\t}\n\tif (ret == connector_status_connected)\n\t\tret = radeon_connector_analog_encoder_conflict_solve(connector, encoder, ret, false);\n\tradeon_connector_update_scratch_regs(connector, ret);\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct drm_connector_helper_funcs radeon_tv_connector_helper_funcs = {\n\t.get_modes = radeon_tv_get_modes,\n\t.mode_valid = radeon_tv_mode_valid,\n\t.best_encoder = radeon_best_single_encoder,\n};\n\nstatic const struct drm_connector_funcs radeon_tv_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_tv_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.set_property = radeon_connector_set_property,\n};\n\nstatic bool radeon_check_hpd_status_unchanged(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tenum drm_connector_status status;\n\n\t \n\tif (rdev->family >= CHIP_R600\n\t  && radeon_connector->hpd.hpd != RADEON_HPD_NONE) {\n\t\tif (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd))\n\t\t\tstatus = connector_status_connected;\n\t\telse\n\t\t\tstatus = connector_status_disconnected;\n\t\tif (connector->status == status)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic enum drm_connector_status\nradeon_dvi_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_encoder *encoder = NULL;\n\tconst struct drm_encoder_helper_funcs *encoder_funcs;\n\tint r;\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tbool dret = false, broken_edid = false;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tif (radeon_connector->detected_hpd_without_ddc) {\n\t\tforce = true;\n\t\tradeon_connector->detected_hpd_without_ddc = false;\n\t}\n\n\tif (!force && radeon_check_hpd_status_unchanged(connector)) {\n\t\tret = connector->status;\n\t\tgoto exit;\n\t}\n\n\tif (radeon_connector->ddc_bus) {\n\t\tdret = radeon_ddc_probe(radeon_connector, false);\n\n\t\t \n\t\tif (!dret && !force &&\n\t\t    connector->status != connector_status_connected) {\n\t\t\tDRM_DEBUG_KMS(\"hpd detected without ddc, retrying in 1 second\\n\");\n\t\t\tradeon_connector->detected_hpd_without_ddc = true;\n\t\t\tschedule_delayed_work(&rdev->hotplug_work,\n\t\t\t\t\t      msecs_to_jiffies(1000));\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tif (dret) {\n\t\tradeon_connector->detected_by_load = false;\n\t\tradeon_connector_free_edid(connector);\n\t\tradeon_connector_get_edid(connector);\n\n\t\tif (!radeon_connector->edid) {\n\t\t\tDRM_ERROR(\"%s: probed a monitor but no|invalid EDID\\n\",\n\t\t\t\t\tconnector->name);\n\t\t\t \n\t\t\tif ((rdev->family == CHIP_RS690 || rdev->family == CHIP_RS740) &&\n\t\t\t    radeon_connector->base.null_edid_counter) {\n\t\t\t\tret = connector_status_disconnected;\n\t\t\t\tDRM_ERROR(\"%s: detected RS690 floating bus bug, stopping ddc detect\\n\",\n\t\t\t\t\t  connector->name);\n\t\t\t\tradeon_connector->ddc_bus = NULL;\n\t\t\t} else {\n\t\t\t\tret = connector_status_connected;\n\t\t\t\tbroken_edid = true;  \n\t\t\t}\n\t\t} else {\n\t\t\tradeon_connector->use_digital =\n\t\t\t\t!!(radeon_connector->edid->input & DRM_EDID_INPUT_DIGITAL);\n\n\t\t\t \n\t\t\tif ((!radeon_connector->use_digital) && radeon_connector->shared_ddc) {\n\t\t\t\tradeon_connector_free_edid(connector);\n\t\t\t\tret = connector_status_disconnected;\n\t\t\t} else {\n\t\t\t\tret = connector_status_connected;\n\t\t\t}\n\t\t\t \n\t\t\tif (radeon_connector->shared_ddc && (ret == connector_status_connected)) {\n\t\t\t\tstruct drm_connector *list_connector;\n\t\t\t\tstruct radeon_connector *list_radeon_connector;\n\t\t\t\tlist_for_each_entry(list_connector, &dev->mode_config.connector_list, head) {\n\t\t\t\t\tif (connector == list_connector)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tlist_radeon_connector = to_radeon_connector(list_connector);\n\t\t\t\t\tif (list_radeon_connector->shared_ddc &&\n\t\t\t\t\t    (list_radeon_connector->ddc_bus->rec.i2c_id ==\n\t\t\t\t\t     radeon_connector->ddc_bus->rec.i2c_id)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (list_connector->connector_type != DRM_MODE_CONNECTOR_VGA) {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\tif (!radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {\n\t\t\t\t\t\t\t\tradeon_connector_free_edid(connector);\n\t\t\t\t\t\t\t\tret = connector_status_disconnected;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ret == connector_status_connected) && (radeon_connector->use_digital == true))\n\t\tgoto out;\n\n\t \n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_DVID) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA))\n\t\tgoto out;\n\n\t \n\tif (!force) {\n\t\t \n\t\tif (radeon_connector->detected_by_load)\n\t\t\tret = connector->status;\n\t\tgoto out;\n\t}\n\n\t \n\tif (radeon_connector->dac_load_detect) {\n\t\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\t\tif (encoder->encoder_type != DRM_MODE_ENCODER_DAC &&\n\t\t\t    encoder->encoder_type != DRM_MODE_ENCODER_TVDAC)\n\t\t\t\tcontinue;\n\n\t\t\tencoder_funcs = encoder->helper_private;\n\t\t\tif (encoder_funcs->detect) {\n\t\t\t\tif (!broken_edid) {\n\t\t\t\t\tif (ret != connector_status_connected) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tret = encoder_funcs->detect(encoder, connector);\n\t\t\t\t\t\tif (ret == connector_status_connected) {\n\t\t\t\t\t\t\tradeon_connector->use_digital = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret != connector_status_disconnected)\n\t\t\t\t\t\t\tradeon_connector->detected_by_load = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tenum drm_connector_status lret;\n\t\t\t\t\t \n\t\t\t\t\tradeon_connector->use_digital = true;\n\t\t\t\t\tlret = encoder_funcs->detect(encoder, connector);\n\t\t\t\t\tDRM_DEBUG_KMS(\"load_detect %x returned: %x\\n\", encoder->encoder_type, lret);\n\t\t\t\t\tif (lret == connector_status_connected)\n\t\t\t\t\t\tradeon_connector->use_digital = false;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ret == connector_status_connected) && (radeon_connector->use_digital == false) &&\n\t    encoder) {\n\t\tret = radeon_connector_analog_encoder_conflict_solve(connector, encoder, ret, true);\n\t}\n\n\t \nout:\n\tif ((!rdev->is_atom_bios) &&\n\t    (ret == connector_status_disconnected) &&\n\t    rdev->mode_info.bios_hardcoded_edid_size) {\n\t\tradeon_connector->use_digital = true;\n\t\tret = connector_status_connected;\n\t}\n\n\t \n\tradeon_connector_update_scratch_regs(connector, ret);\n\n\tif ((radeon_audio != 0) && radeon_connector->use_digital) {\n\t\tconst struct drm_connector_helper_funcs *connector_funcs =\n\t\t\tconnector->helper_private;\n\n\t\tencoder = connector_funcs->best_encoder(connector);\n\t\tif (encoder && (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)) {\n\t\t\tradeon_connector_get_edid(connector);\n\t\t\tradeon_audio_detect(connector, encoder, ret);\n\t\t}\n\t}\n\nexit:\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic struct drm_encoder *radeon_dvi_encoder(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_encoder *encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tif (radeon_connector->use_digital == true) {\n\t\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_TMDS)\n\t\t\t\treturn encoder;\n\t\t} else {\n\t\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DAC ||\n\t\t\t    encoder->encoder_type == DRM_MODE_ENCODER_TVDAC)\n\t\t\t\treturn encoder;\n\t\t}\n\t}\n\n\t \n\n\t \n\t \n\tdrm_connector_for_each_possible_encoder(connector, encoder)\n\t\treturn encoder;\n\n\treturn NULL;\n}\n\nstatic void radeon_dvi_force(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tif (connector->force == DRM_FORCE_ON)\n\t\tradeon_connector->use_digital = false;\n\tif (connector->force == DRM_FORCE_ON_DIGITAL)\n\t\tradeon_connector->use_digital = true;\n}\n\nstatic enum drm_mode_status radeon_dvi_mode_valid(struct drm_connector *connector,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\t \n\n\t \n\tif (radeon_connector->use_digital &&\n\t    (rdev->family == CHIP_RV100) &&\n\t    (mode->clock > 135000))\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (radeon_connector->use_digital && (mode->clock > 165000)) {\n\t\tif ((radeon_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_I) ||\n\t\t    (radeon_connector->connector_object_id == CONNECTOR_OBJECT_ID_DUAL_LINK_DVI_D) ||\n\t\t    (radeon_connector->connector_object_id == CONNECTOR_OBJECT_ID_HDMI_TYPE_B))\n\t\t\treturn MODE_OK;\n\t\telse if (ASIC_IS_DCE6(rdev) && drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\t \n\t\t\tif (mode->clock > 340000)\n\t\t\t\treturn MODE_CLOCK_HIGH;\n\t\t\telse\n\t\t\t\treturn MODE_OK;\n\t\t} else {\n\t\t\treturn MODE_CLOCK_HIGH;\n\t\t}\n\t}\n\n\t \n\tif ((mode->clock / 10) > rdev->clock.max_pixel_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs radeon_dvi_connector_helper_funcs = {\n\t.get_modes = radeon_vga_get_modes,\n\t.mode_valid = radeon_dvi_mode_valid,\n\t.best_encoder = radeon_dvi_encoder,\n};\n\nstatic const struct drm_connector_funcs radeon_dvi_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_dvi_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = radeon_connector_set_property,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.force = radeon_dvi_force,\n};\n\nstatic int radeon_dp_get_modes(struct drm_connector *connector)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;\n\tstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\n\tint ret;\n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t\tif (!radeon_dig_connector->edp_on)\n\t\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_ON);\n\t\t\tradeon_connector_get_edid(connector);\n\t\t\tret = radeon_ddc_get_modes(connector);\n\t\t\tif (!radeon_dig_connector->edp_on)\n\t\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_OFF);\n\t\t} else {\n\t\t\t \n\t\t\tif (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t\t\t    ENCODER_OBJECT_ID_NONE) {\n\t\t\t\tif (encoder)\n\t\t\t\t\tradeon_atom_ext_encoder_setup_ddc(encoder);\n\t\t\t}\n\t\t\tradeon_connector_get_edid(connector);\n\t\t\tret = radeon_ddc_get_modes(connector);\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tif (encoder) {\n\t\t\t\tradeon_fixup_lvds_native_mode(encoder, connector);\n\t\t\t\t \n\t\t\t\tradeon_add_common_modes(encoder, connector);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!encoder)\n\t\t\treturn 0;\n\n\t\t \n\t\tmode = radeon_fp_native_mode(encoder);\n\t\tif (mode) {\n\t\t\tret = 1;\n\t\t\tdrm_mode_probed_add(connector, mode);\n\t\t\t \n\t\t\tconnector->display_info.width_mm = mode->width_mm;\n\t\t\tconnector->display_info.height_mm = mode->height_mm;\n\t\t\t \n\t\t\tradeon_add_common_modes(encoder, connector);\n\t\t}\n\t} else {\n\t\t \n\t\tif (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t\t\tENCODER_OBJECT_ID_NONE) {\n\t\t\tif (encoder)\n\t\t\t\tradeon_atom_ext_encoder_setup_ddc(encoder);\n\t\t}\n\t\tradeon_connector_get_edid(connector);\n\t\tret = radeon_ddc_get_modes(connector);\n\n\t\tradeon_get_native_mode(connector);\n\t}\n\n\treturn ret;\n}\n\nu16 radeon_connector_encoder_get_dp_bridge_encoder_id(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\n\t\tswitch (radeon_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_TRAVIS:\n\t\tcase ENCODER_OBJECT_ID_NUTMEG:\n\t\t\treturn radeon_encoder->encoder_id;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ENCODER_OBJECT_ID_NONE;\n}\n\nstatic bool radeon_connector_encoder_is_hbr2(struct drm_connector *connector)\n{\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\tbool found = false;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\tif (radeon_encoder->caps & ATOM_ENCODER_CAP_RECORD_HBR2)\n\t\t\tfound = true;\n\t}\n\n\treturn found;\n}\n\nbool radeon_connector_is_dp12_capable(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (ASIC_IS_DCE5(rdev) &&\n\t    (rdev->clock.default_dispclk >= 53900) &&\n\t    radeon_connector_encoder_is_hbr2(connector)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic enum drm_connector_status\nradeon_dp_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tenum drm_connector_status ret = connector_status_disconnected;\n\tstruct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;\n\tstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\n\tint r;\n\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tr = pm_runtime_get_sync(connector->dev->dev);\n\t\tif (r < 0) {\n\t\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\t\treturn connector_status_disconnected;\n\t\t}\n\t}\n\n\tif (!force && radeon_check_hpd_status_unchanged(connector)) {\n\t\tret = connector->status;\n\t\tgoto out;\n\t}\n\n\tradeon_connector_free_edid(connector);\n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\n\t\tif (encoder) {\n\t\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\t\t\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\n\t\t\t \n\t\t\tif (native_mode->hdisplay >= 320 && native_mode->vdisplay >= 240)\n\t\t\t\tret = connector_status_connected;\n\t\t\t \n\t\t\tif ((rdev->flags & RADEON_IS_PX) && (radeon_runtime_pm != 0))\n\t\t\t\tret = connector_status_disconnected;\n\t\t}\n\t\t \n\t\tradeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\n\t\tif (!radeon_dig_connector->edp_on)\n\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_ON);\n\t\tif (radeon_dp_getdpcd(radeon_connector))\n\t\t\tret = connector_status_connected;\n\t\tif (!radeon_dig_connector->edp_on)\n\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_OFF);\n\t} else if (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) !=\n\t\t   ENCODER_OBJECT_ID_NONE) {\n\t\t \n\t\tradeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;\n\t\t \n\t\tradeon_dp_getdpcd(radeon_connector);\n\n\t\tif (encoder) {\n\t\t\t \n\t\t\tradeon_atom_ext_encoder_setup_ddc(encoder);\n\t\t\t \n\t\t\tif (radeon_ddc_probe(radeon_connector, true))  \n\t\t\t\tret = connector_status_connected;\n\t\t\telse if (radeon_connector->dac_load_detect) {  \n\t\t\t\tconst struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\n\t\t\t\tret = encoder_funcs->detect(encoder, connector);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tradeon_dig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);\n\t\tif (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {\n\t\t\tret = connector_status_connected;\n\t\t\tif (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)\n\t\t\t\tradeon_dp_getdpcd(radeon_connector);\n\t\t} else {\n\t\t\tif (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {\n\t\t\t\tif (radeon_dp_getdpcd(radeon_connector))\n\t\t\t\t\tret = connector_status_connected;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (radeon_ddc_probe(radeon_connector, false))\n\t\t\t\t\tret = connector_status_connected;\n\t\t\t}\n\t\t}\n\t}\n\n\tradeon_connector_update_scratch_regs(connector, ret);\n\n\tif ((radeon_audio != 0) && encoder) {\n\t\tradeon_connector_get_edid(connector);\n\t\tradeon_audio_detect(connector, encoder, ret);\n\t}\n\nout:\n\tif (!drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_mark_last_busy(connector->dev->dev);\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic enum drm_mode_status radeon_dp_mode_valid(struct drm_connector *connector,\n\t\t\t\t  struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;\n\n\t \n\n\tif ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)) {\n\t\tstruct drm_encoder *encoder = radeon_best_single_encoder(connector);\n\n\t\tif ((mode->hdisplay < 320) || (mode->vdisplay < 240))\n\t\t\treturn MODE_PANEL;\n\n\t\tif (encoder) {\n\t\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\t\t\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\n\t\t\t \n\t\t\tif ((mode->hdisplay > native_mode->hdisplay) ||\n\t\t\t    (mode->vdisplay > native_mode->vdisplay))\n\t\t\t\treturn MODE_PANEL;\n\n\t\t\t \n\t\t\tif (radeon_encoder->rmx_type == RMX_OFF) {\n\t\t\t\tif ((mode->hdisplay != native_mode->hdisplay) ||\n\t\t\t\t    (mode->vdisplay != native_mode->vdisplay))\n\t\t\t\t\treturn MODE_PANEL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ((radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t\t    (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\n\t\t\treturn radeon_dp_mode_valid_helper(connector, mode);\n\t\t} else {\n\t\t\tif (ASIC_IS_DCE6(rdev) && drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\t\t \n\t\t\t\tif (mode->clock > 340000)\n\t\t\t\t\treturn MODE_CLOCK_HIGH;\n\t\t\t} else {\n\t\t\t\tif (mode->clock > 165000)\n\t\t\t\t\treturn MODE_CLOCK_HIGH;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs radeon_dp_connector_helper_funcs = {\n\t.get_modes = radeon_dp_get_modes,\n\t.mode_valid = radeon_dp_mode_valid,\n\t.best_encoder = radeon_dvi_encoder,\n};\n\nstatic const struct drm_connector_funcs radeon_dp_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_dp_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = radeon_connector_set_property,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.force = radeon_dvi_force,\n};\n\nstatic const struct drm_connector_funcs radeon_edp_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_dp_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = radeon_lvds_set_property,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.force = radeon_dvi_force,\n};\n\nstatic const struct drm_connector_funcs radeon_lvds_bridge_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.detect = radeon_dp_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = radeon_lvds_set_property,\n\t.early_unregister = radeon_connector_unregister,\n\t.destroy = radeon_connector_destroy,\n\t.force = radeon_dvi_force,\n};\n\nvoid\nradeon_add_atom_connector(struct drm_device *dev,\n\t\t\t  uint32_t connector_id,\n\t\t\t  uint32_t supported_device,\n\t\t\t  int connector_type,\n\t\t\t  struct radeon_i2c_bus_rec *i2c_bus,\n\t\t\t  uint32_t igp_lane_info,\n\t\t\t  uint16_t connector_object_id,\n\t\t\t  struct radeon_hpd *hpd,\n\t\t\t  struct radeon_router *router)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\tstruct radeon_connector_atom_dig *radeon_dig_connector;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct i2c_adapter *ddc = NULL;\n\tuint32_t subpixel_order = SubPixelNone;\n\tbool shared_ddc = false;\n\tbool is_dp_bridge = false;\n\tbool has_aux = false;\n\n\tif (connector_type == DRM_MODE_CONNECTOR_Unknown)\n\t\treturn;\n\n\t \n\tif (((connector_type == DRM_MODE_CONNECTOR_SVIDEO) ||\n\t     (connector_type == DRM_MODE_CONNECTOR_Composite) ||\n\t     (connector_type == DRM_MODE_CONNECTOR_9PinDIN)) &&\n\t    (radeon_tv == 0))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tif (radeon_connector->connector_id == connector_id) {\n\t\t\tradeon_connector->devices |= supported_device;\n\t\t\treturn;\n\t\t}\n\t\tif (radeon_connector->ddc_bus && i2c_bus->valid) {\n\t\t\tif (radeon_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) {\n\t\t\t\tradeon_connector->shared_ddc = true;\n\t\t\t\tshared_ddc = true;\n\t\t\t}\n\t\t\tif (radeon_connector->router_bus && router->ddc_valid &&\n\t\t\t    (radeon_connector->router.router_id == router->router_id)) {\n\t\t\t\tradeon_connector->shared_ddc = false;\n\t\t\t\tshared_ddc = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\tif (radeon_encoder->devices & supported_device) {\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_TRAVIS:\n\t\t\tcase ENCODER_OBJECT_ID_NUTMEG:\n\t\t\t\tis_dp_bridge = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tradeon_connector = kzalloc(sizeof(struct radeon_connector), GFP_KERNEL);\n\tif (!radeon_connector)\n\t\treturn;\n\n\tconnector = &radeon_connector->base;\n\n\tradeon_connector->connector_id = connector_id;\n\tradeon_connector->devices = supported_device;\n\tradeon_connector->shared_ddc = shared_ddc;\n\tradeon_connector->connector_object_id = connector_object_id;\n\tradeon_connector->hpd = *hpd;\n\n\tradeon_connector->router = *router;\n\tif (router->ddc_valid || router->cd_valid) {\n\t\tradeon_connector->router_bus = radeon_i2c_lookup(rdev, &router->i2c_info);\n\t\tif (!radeon_connector->router_bus)\n\t\t\tDRM_ERROR(\"Failed to assign router i2c bus! Check dmesg for i2c errors.\\n\");\n\t}\n\n\tif (is_dp_bridge) {\n\t\tradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\n\t\tif (!radeon_dig_connector)\n\t\t\tgoto failed;\n\t\tradeon_dig_connector->igp_lane_info = igp_lane_info;\n\t\tradeon_connector->con_priv = radeon_dig_connector;\n\t\tif (i2c_bus->valid) {\n\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\tif (radeon_connector->ddc_bus) {\n\t\t\t\thas_aux = true;\n\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t} else {\n\t\t\t\tDRM_ERROR(\"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t}\n\t\t}\n\t\tswitch (connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_VGA:\n\t\tcase DRM_MODE_CONNECTOR_DVIA:\n\t\tdefault:\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_dp_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base,\n\t\t\t\t\t\t &radeon_dp_connector_helper_funcs);\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tconnector->doublescan_allowed = true;\n\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DVII:\n\t\tcase DRM_MODE_CONNECTOR_DVID:\n\t\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_dp_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base,\n\t\t\t\t\t\t &radeon_dp_connector_helper_funcs);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.underscan_property,\n\t\t\t\t\t\t      UNDERSCAN_OFF);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t      0);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t      0);\n\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_NONE);\n\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t   rdev->mode_info.dither_property,\n\t\t\t\t\t\t   RADEON_FMT_DITHER_DISABLE);\n\n\t\t\tif (radeon_audio != 0) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.audio_property,\n\t\t\t\t\t\t\t   RADEON_AUDIO_AUTO);\n\t\t\t\tradeon_connector->audio = RADEON_AUDIO_AUTO;\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\n\t\t\t\tconnector->doublescan_allowed = true;\n\t\t\telse\n\t\t\t\tconnector->doublescan_allowed = false;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII) {\n\t\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t\t      1);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_lvds_bridge_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base,\n\t\t\t\t\t\t &radeon_dp_connector_helper_funcs);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_VGA:\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_vga_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\n\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\t\t\t \n\t\t\tradeon_connector->hpd.hpd = RADEON_HPD_NONE;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tconnector->doublescan_allowed = true;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DVIA:\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_vga_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\n\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\t\t\t \n\t\t\tradeon_connector->hpd.hpd = RADEON_HPD_NONE;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tconnector->doublescan_allowed = true;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DVII:\n\t\tcase DRM_MODE_CONNECTOR_DVID:\n\t\t\tradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!radeon_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tradeon_dig_connector->igp_lane_info = igp_lane_info;\n\t\t\tradeon_connector->con_priv = radeon_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_dvi_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_dvi_connector_helper_funcs);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.coherent_mode_property,\n\t\t\t\t\t\t      1);\n\t\t\tif (ASIC_IS_AVIVO(rdev)) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_property,\n\t\t\t\t\t\t\t      UNDERSCAN_OFF);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t\t      0);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t\t      0);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.dither_property,\n\t\t\t\t\t\t\t   RADEON_FMT_DITHER_DISABLE);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE2(rdev) && (radeon_audio != 0)) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.audio_property,\n\t\t\t\t\t\t\t   RADEON_AUDIO_AUTO);\n\t\t\t\tradeon_connector->audio = RADEON_AUDIO_AUTO;\n\t\t\t}\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII) {\n\t\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t\t      1);\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\t\t\tconnector->doublescan_allowed = true;\n\t\t\telse\n\t\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_HDMIA:\n\t\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\t\tradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!radeon_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tradeon_dig_connector->igp_lane_info = igp_lane_info;\n\t\t\tradeon_connector->con_priv = radeon_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"HDMI: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_dvi_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_dvi_connector_helper_funcs);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.coherent_mode_property,\n\t\t\t\t\t\t      1);\n\t\t\tif (ASIC_IS_AVIVO(rdev)) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_property,\n\t\t\t\t\t\t\t      UNDERSCAN_OFF);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t\t      0);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t\t      0);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.dither_property,\n\t\t\t\t\t\t\t   RADEON_FMT_DITHER_DISABLE);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE2(rdev) && (radeon_audio != 0)) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.audio_property,\n\t\t\t\t\t\t\t   RADEON_AUDIO_AUTO);\n\t\t\t\tradeon_connector->audio = RADEON_AUDIO_AUTO;\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = true;\n\t\t\tif (connector_type == DRM_MODE_CONNECTOR_HDMIB)\n\t\t\t\tconnector->doublescan_allowed = true;\n\t\t\telse\n\t\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\t\tradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!radeon_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tradeon_dig_connector->igp_lane_info = igp_lane_info;\n\t\t\tradeon_connector->con_priv = radeon_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (radeon_connector->ddc_bus) {\n\t\t\t\t\thas_aux = true;\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t\t} else {\n\t\t\t\t\tDRM_ERROR(\"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_dp_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_dp_connector_helper_funcs);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.coherent_mode_property,\n\t\t\t\t\t\t      1);\n\t\t\tif (ASIC_IS_AVIVO(rdev)) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_property,\n\t\t\t\t\t\t\t      UNDERSCAN_OFF);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_hborder_property,\n\t\t\t\t\t\t\t      0);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t      rdev->mode_info.underscan_vborder_property,\n\t\t\t\t\t\t\t      0);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.dither_property,\n\t\t\t\t\t\t\t   RADEON_FMT_DITHER_DISABLE);\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t\t   DRM_MODE_SCALE_NONE);\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE2(rdev) && (radeon_audio != 0)) {\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.audio_property,\n\t\t\t\t\t\t\t   RADEON_AUDIO_AUTO);\n\t\t\t\tradeon_connector->audio = RADEON_AUDIO_AUTO;\n\t\t\t}\n\t\t\tif (ASIC_IS_DCE5(rdev))\n\t\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t\t   rdev->mode_info.output_csc_property,\n\t\t\t\t\t\t\t   RADEON_OUTPUT_CSC_BYPASS);\n\t\t\tconnector->interlace_allowed = true;\n\t\t\t \n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\tradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!radeon_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tradeon_dig_connector->igp_lane_info = igp_lane_info;\n\t\t\tradeon_connector->con_priv = radeon_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (radeon_connector->ddc_bus) {\n\t\t\t\t\thas_aux = true;\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t\t} else {\n\t\t\t\t\tDRM_ERROR(\"DP: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_edp_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_dp_connector_helper_funcs);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_SVIDEO:\n\t\tcase DRM_MODE_CONNECTOR_Composite:\n\t\tcase DRM_MODE_CONNECTOR_9PinDIN:\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_tv_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_tv_connector_helper_funcs);\n\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.tv_std_property,\n\t\t\t\t\t\t      radeon_atombios_get_tv_info(rdev));\n\t\t\t \n\t\t\tradeon_connector->hpd.hpd = RADEON_HPD_NONE;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\t\tradeon_dig_connector = kzalloc(sizeof(struct radeon_connector_atom_dig), GFP_KERNEL);\n\t\t\tif (!radeon_dig_connector)\n\t\t\t\tgoto failed;\n\t\t\tradeon_dig_connector->igp_lane_info = igp_lane_info;\n\t\t\tradeon_connector->con_priv = radeon_dig_connector;\n\t\t\tif (i2c_bus->valid) {\n\t\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\t\tDRM_ERROR(\"LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\t\telse\n\t\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t\t}\n\t\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t\t    &radeon_lvds_connector_funcs,\n\t\t\t\t\t\t    connector_type,\n\t\t\t\t\t\t    ddc);\n\t\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_lvds_connector_helper_funcs);\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\t\tconnector->interlace_allowed = false;\n\t\t\tconnector->doublescan_allowed = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (radeon_connector->hpd.hpd == RADEON_HPD_NONE) {\n\t\tif (i2c_bus->valid) {\n\t\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t                    DRM_CONNECTOR_POLL_DISCONNECT;\n\t\t}\n\t} else\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tconnector->display_info.subpixel_order = subpixel_order;\n\tdrm_connector_register(connector);\n\n\tif (has_aux)\n\t\tradeon_dp_aux_init(radeon_connector);\n\n\treturn;\n\nfailed:\n\tdrm_connector_cleanup(connector);\n\tkfree(connector);\n}\n\nvoid\nradeon_add_legacy_connector(struct drm_device *dev,\n\t\t\t    uint32_t connector_id,\n\t\t\t    uint32_t supported_device,\n\t\t\t    int connector_type,\n\t\t\t    struct radeon_i2c_bus_rec *i2c_bus,\n\t\t\t    uint16_t connector_object_id,\n\t\t\t    struct radeon_hpd *hpd)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\tstruct i2c_adapter *ddc = NULL;\n\tuint32_t subpixel_order = SubPixelNone;\n\n\tif (connector_type == DRM_MODE_CONNECTOR_Unknown)\n\t\treturn;\n\n\t \n\tif (((connector_type == DRM_MODE_CONNECTOR_SVIDEO) ||\n\t     (connector_type == DRM_MODE_CONNECTOR_Composite) ||\n\t     (connector_type == DRM_MODE_CONNECTOR_9PinDIN)) &&\n\t    (radeon_tv == 0))\n\t\treturn;\n\n\t \n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tif (radeon_connector->connector_id == connector_id) {\n\t\t\tradeon_connector->devices |= supported_device;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tradeon_connector = kzalloc(sizeof(struct radeon_connector), GFP_KERNEL);\n\tif (!radeon_connector)\n\t\treturn;\n\n\tconnector = &radeon_connector->base;\n\n\tradeon_connector->connector_id = connector_id;\n\tradeon_connector->devices = supported_device;\n\tradeon_connector->connector_object_id = connector_object_id;\n\tradeon_connector->hpd = *hpd;\n\n\tswitch (connector_type) {\n\tcase DRM_MODE_CONNECTOR_VGA:\n\t\tif (i2c_bus->valid) {\n\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\tDRM_ERROR(\"VGA: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\telse\n\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t}\n\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t    &radeon_vga_connector_funcs,\n\t\t\t\t\t    connector_type,\n\t\t\t\t\t    ddc);\n\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\n\t\tradeon_connector->dac_load_detect = true;\n\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t      1);\n\t\t \n\t\tradeon_connector->hpd.hpd = RADEON_HPD_NONE;\n\t\tconnector->interlace_allowed = true;\n\t\tconnector->doublescan_allowed = true;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVIA:\n\t\tif (i2c_bus->valid) {\n\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\tDRM_ERROR(\"DVIA: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\telse\n\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t}\n\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t    &radeon_vga_connector_funcs,\n\t\t\t\t\t    connector_type,\n\t\t\t\t\t    ddc);\n\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_vga_connector_helper_funcs);\n\t\tradeon_connector->dac_load_detect = true;\n\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t      1);\n\t\t \n\t\tradeon_connector->hpd.hpd = RADEON_HPD_NONE;\n\t\tconnector->interlace_allowed = true;\n\t\tconnector->doublescan_allowed = true;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_DVID:\n\t\tif (i2c_bus->valid) {\n\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\tDRM_ERROR(\"DVI: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\telse\n\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t}\n\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t    &radeon_dvi_connector_funcs,\n\t\t\t\t\t    connector_type,\n\t\t\t\t\t    ddc);\n\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_dvi_connector_helper_funcs);\n\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII) {\n\t\t\tradeon_connector->dac_load_detect = true;\n\t\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t\t      1);\n\t\t}\n\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\tconnector->interlace_allowed = true;\n\t\tif (connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\t\tconnector->doublescan_allowed = true;\n\t\telse\n\t\t\tconnector->doublescan_allowed = false;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_SVIDEO:\n\tcase DRM_MODE_CONNECTOR_Composite:\n\tcase DRM_MODE_CONNECTOR_9PinDIN:\n\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t    &radeon_tv_connector_funcs,\n\t\t\t\t\t    connector_type,\n\t\t\t\t\t    ddc);\n\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_tv_connector_helper_funcs);\n\t\tradeon_connector->dac_load_detect = true;\n\t\t \n\t\tif (rdev->family == CHIP_RS400 || rdev->family == CHIP_RS480)\n\t\t\tradeon_connector->dac_load_detect = false;\n\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t      rdev->mode_info.load_detect_property,\n\t\t\t\t\t      radeon_connector->dac_load_detect);\n\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t      rdev->mode_info.tv_std_property,\n\t\t\t\t\t      radeon_combios_get_tv_info(rdev));\n\t\t \n\t\tradeon_connector->hpd.hpd = RADEON_HPD_NONE;\n\t\tconnector->interlace_allowed = false;\n\t\tconnector->doublescan_allowed = false;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tif (i2c_bus->valid) {\n\t\t\tradeon_connector->ddc_bus = radeon_i2c_lookup(rdev, i2c_bus);\n\t\t\tif (!radeon_connector->ddc_bus)\n\t\t\t\tDRM_ERROR(\"LVDS: Failed to assign ddc bus! Check dmesg for i2c errors.\\n\");\n\t\t\telse\n\t\t\t\tddc = &radeon_connector->ddc_bus->adapter;\n\t\t}\n\t\tdrm_connector_init_with_ddc(dev, &radeon_connector->base,\n\t\t\t\t\t    &radeon_lvds_connector_funcs,\n\t\t\t\t\t    connector_type,\n\t\t\t\t\t    ddc);\n\t\tdrm_connector_helper_add(&radeon_connector->base, &radeon_lvds_connector_helper_funcs);\n\t\tdrm_object_attach_property(&radeon_connector->base.base,\n\t\t\t\t\t      dev->mode_config.scaling_mode_property,\n\t\t\t\t\t      DRM_MODE_SCALE_FULLSCREEN);\n\t\tsubpixel_order = SubPixelHorizontalRGB;\n\t\tconnector->interlace_allowed = false;\n\t\tconnector->doublescan_allowed = false;\n\t\tbreak;\n\t}\n\n\tif (radeon_connector->hpd.hpd == RADEON_HPD_NONE) {\n\t\tif (i2c_bus->valid) {\n\t\t\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\n\t\t\t                    DRM_CONNECTOR_POLL_DISCONNECT;\n\t\t}\n\t} else\n\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\tconnector->display_info.subpixel_order = subpixel_order;\n\tdrm_connector_register(connector);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}