{
  "module_name": "sumo_dpm.c",
  "hash_id": "7fa49b77efa22f7ce92f88e492018a557f3557b161cdd5a188584f780b5c2bcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/sumo_dpm.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"sumod.h\"\n#include \"r600_dpm.h\"\n#include \"cypress_dpm.h\"\n#include \"sumo_dpm.h\"\n#include <linux/seq_file.h>\n\n#define SUMO_MAX_DEEPSLEEP_DIVIDER_ID 5\n#define SUMO_MINIMUM_ENGINE_CLOCK 800\n#define BOOST_DPM_LEVEL 7\n\nstatic const u32 sumo_utc[SUMO_PM_NUMBER_OF_TC] =\n{\n\tSUMO_UTC_DFLT_00,\n\tSUMO_UTC_DFLT_01,\n\tSUMO_UTC_DFLT_02,\n\tSUMO_UTC_DFLT_03,\n\tSUMO_UTC_DFLT_04,\n\tSUMO_UTC_DFLT_05,\n\tSUMO_UTC_DFLT_06,\n\tSUMO_UTC_DFLT_07,\n\tSUMO_UTC_DFLT_08,\n\tSUMO_UTC_DFLT_09,\n\tSUMO_UTC_DFLT_10,\n\tSUMO_UTC_DFLT_11,\n\tSUMO_UTC_DFLT_12,\n\tSUMO_UTC_DFLT_13,\n\tSUMO_UTC_DFLT_14,\n};\n\nstatic const u32 sumo_dtc[SUMO_PM_NUMBER_OF_TC] =\n{\n\tSUMO_DTC_DFLT_00,\n\tSUMO_DTC_DFLT_01,\n\tSUMO_DTC_DFLT_02,\n\tSUMO_DTC_DFLT_03,\n\tSUMO_DTC_DFLT_04,\n\tSUMO_DTC_DFLT_05,\n\tSUMO_DTC_DFLT_06,\n\tSUMO_DTC_DFLT_07,\n\tSUMO_DTC_DFLT_08,\n\tSUMO_DTC_DFLT_09,\n\tSUMO_DTC_DFLT_10,\n\tSUMO_DTC_DFLT_11,\n\tSUMO_DTC_DFLT_12,\n\tSUMO_DTC_DFLT_13,\n\tSUMO_DTC_DFLT_14,\n};\n\nstatic struct sumo_ps *sumo_get_ps(struct radeon_ps *rps)\n{\n\tstruct sumo_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstruct sumo_power_info *sumo_get_pi(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic void sumo_gfx_clockgating_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\n\telse {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\t\tRREG32(GB_ADDR_CONFIG);\n\t}\n}\n\n#define CGCG_CGTT_LOCAL0_MASK 0xE5BFFFFF\n#define CGCG_CGTT_LOCAL1_MASK 0xEFFF07FF\n\nstatic void sumo_mg_clockgating_enable(struct radeon_device *rdev, bool enable)\n{\n\tu32 local0;\n\tu32 local1;\n\n\tlocal0 = RREG32(CG_CGTT_LOCAL_0);\n\tlocal1 = RREG32(CG_CGTT_LOCAL_1);\n\n\tif (enable) {\n\t\tWREG32(CG_CGTT_LOCAL_0, (0 & CGCG_CGTT_LOCAL0_MASK) | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\n\t\tWREG32(CG_CGTT_LOCAL_1, (0 & CGCG_CGTT_LOCAL1_MASK) | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\n\t} else {\n\t\tWREG32(CG_CGTT_LOCAL_0, (0xFFFFFFFF & CGCG_CGTT_LOCAL0_MASK) | (local0 & ~CGCG_CGTT_LOCAL0_MASK) );\n\t\tWREG32(CG_CGTT_LOCAL_1, (0xFFFFCFFF & CGCG_CGTT_LOCAL1_MASK) | (local1 & ~CGCG_CGTT_LOCAL1_MASK) );\n\t}\n}\n\nstatic void sumo_program_git(struct radeon_device *rdev)\n{\n\tu32 p, u;\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tr600_calculate_u_and_p(SUMO_GICST_DFLT,\n\t\t\t       xclk, 16, &p, &u);\n\n\tWREG32_P(CG_GIT, CG_GICST(p), ~CG_GICST_MASK);\n}\n\nstatic void sumo_program_grsd(struct radeon_device *rdev)\n{\n\tu32 p, u;\n\tu32 xclk = radeon_get_xclk(rdev);\n\tu32 grs = 256 * 25 / 100;\n\n\tr600_calculate_u_and_p(1, xclk, 14, &p, &u);\n\n\tWREG32(CG_GCOOR, PHC(grs) | SDC(p) | SU(u));\n}\n\nvoid sumo_gfx_clockgating_initialize(struct radeon_device *rdev)\n{\n\tsumo_program_git(rdev);\n\tsumo_program_grsd(rdev);\n}\n\nstatic void sumo_gfx_powergating_initialize(struct radeon_device *rdev)\n{\n\tu32 rcu_pwr_gating_cntl;\n\tu32 p, u;\n\tu32 p_c, p_p, d_p;\n\tu32 r_t, i_t;\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tif (rdev->family == CHIP_PALM) {\n\t\tp_c = 4;\n\t\td_p = 10;\n\t\tr_t = 10;\n\t\ti_t = 4;\n\t\tp_p = 50 + 1000/200 + 6 * 32;\n\t} else {\n\t\tp_c = 16;\n\t\td_p = 50;\n\t\tr_t = 50;\n\t\ti_t  = 50;\n\t\tp_p = 113;\n\t}\n\n\tWREG32(CG_SCRATCH2, 0x01B60A17);\n\n\tr600_calculate_u_and_p(SUMO_GFXPOWERGATINGT_DFLT,\n\t\t\t       xclk, 16, &p, &u);\n\n\tWREG32_P(CG_PWR_GATING_CNTL, PGP(p) | PGU(u),\n\t\t ~(PGP_MASK | PGU_MASK));\n\n\tr600_calculate_u_and_p(SUMO_VOLTAGEDROPT_DFLT,\n\t\t\t       xclk, 16, &p, &u);\n\n\tWREG32_P(CG_CG_VOLTAGE_CNTL, PGP(p) | PGU(u),\n\t\t ~(PGP_MASK | PGU_MASK));\n\n\tif (rdev->family == CHIP_PALM) {\n\t\tWREG32_RCU(RCU_PWR_GATING_SEQ0, 0x10103210);\n\t\tWREG32_RCU(RCU_PWR_GATING_SEQ1, 0x10101010);\n\t} else {\n\t\tWREG32_RCU(RCU_PWR_GATING_SEQ0, 0x76543210);\n\t\tWREG32_RCU(RCU_PWR_GATING_SEQ1, 0xFEDCBA98);\n\t}\n\n\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL);\n\trcu_pwr_gating_cntl &=\n\t\t~(RSVD_MASK | PCV_MASK | PGS_MASK);\n\trcu_pwr_gating_cntl |= PCV(p_c) | PGS(1) | PWR_GATING_EN;\n\tif (rdev->family == CHIP_PALM) {\n\t\trcu_pwr_gating_cntl &= ~PCP_MASK;\n\t\trcu_pwr_gating_cntl |= PCP(0x77);\n\t}\n\tWREG32_RCU(RCU_PWR_GATING_CNTL, rcu_pwr_gating_cntl);\n\n\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_2);\n\trcu_pwr_gating_cntl &= ~(MPPU_MASK | MPPD_MASK);\n\trcu_pwr_gating_cntl |= MPPU(p_p) | MPPD(50);\n\tWREG32_RCU(RCU_PWR_GATING_CNTL_2, rcu_pwr_gating_cntl);\n\n\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_3);\n\trcu_pwr_gating_cntl &= ~(DPPU_MASK | DPPD_MASK);\n\trcu_pwr_gating_cntl |= DPPU(d_p) | DPPD(50);\n\tWREG32_RCU(RCU_PWR_GATING_CNTL_3, rcu_pwr_gating_cntl);\n\n\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_4);\n\trcu_pwr_gating_cntl &= ~(RT_MASK | IT_MASK);\n\trcu_pwr_gating_cntl |= RT(r_t) | IT(i_t);\n\tWREG32_RCU(RCU_PWR_GATING_CNTL_4, rcu_pwr_gating_cntl);\n\n\tif (rdev->family == CHIP_PALM)\n\t\tWREG32_RCU(RCU_PWR_GATING_CNTL_5, 0xA02);\n\n\tsumo_smu_pg_init(rdev);\n\n\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL);\n\trcu_pwr_gating_cntl &=\n\t\t~(RSVD_MASK | PCV_MASK | PGS_MASK);\n\trcu_pwr_gating_cntl |= PCV(p_c) | PGS(4) | PWR_GATING_EN;\n\tif (rdev->family == CHIP_PALM) {\n\t\trcu_pwr_gating_cntl &= ~PCP_MASK;\n\t\trcu_pwr_gating_cntl |= PCP(0x77);\n\t}\n\tWREG32_RCU(RCU_PWR_GATING_CNTL, rcu_pwr_gating_cntl);\n\n\tif (rdev->family == CHIP_PALM) {\n\t\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_2);\n\t\trcu_pwr_gating_cntl &= ~(MPPU_MASK | MPPD_MASK);\n\t\trcu_pwr_gating_cntl |= MPPU(113) | MPPD(50);\n\t\tWREG32_RCU(RCU_PWR_GATING_CNTL_2, rcu_pwr_gating_cntl);\n\n\t\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_3);\n\t\trcu_pwr_gating_cntl &= ~(DPPU_MASK | DPPD_MASK);\n\t\trcu_pwr_gating_cntl |= DPPU(16) | DPPD(50);\n\t\tWREG32_RCU(RCU_PWR_GATING_CNTL_3, rcu_pwr_gating_cntl);\n\t}\n\n\tsumo_smu_pg_init(rdev);\n\n\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL);\n\trcu_pwr_gating_cntl &=\n\t\t~(RSVD_MASK | PCV_MASK | PGS_MASK);\n\trcu_pwr_gating_cntl |= PGS(5) | PWR_GATING_EN;\n\n\tif (rdev->family == CHIP_PALM) {\n\t\trcu_pwr_gating_cntl |= PCV(4);\n\t\trcu_pwr_gating_cntl &= ~PCP_MASK;\n\t\trcu_pwr_gating_cntl |= PCP(0x77);\n\t} else\n\t\trcu_pwr_gating_cntl |= PCV(11);\n\tWREG32_RCU(RCU_PWR_GATING_CNTL, rcu_pwr_gating_cntl);\n\n\tif (rdev->family == CHIP_PALM) {\n\t\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_2);\n\t\trcu_pwr_gating_cntl &= ~(MPPU_MASK | MPPD_MASK);\n\t\trcu_pwr_gating_cntl |= MPPU(113) | MPPD(50);\n\t\tWREG32_RCU(RCU_PWR_GATING_CNTL_2, rcu_pwr_gating_cntl);\n\n\t\trcu_pwr_gating_cntl = RREG32_RCU(RCU_PWR_GATING_CNTL_3);\n\t\trcu_pwr_gating_cntl &= ~(DPPU_MASK | DPPD_MASK);\n\t\trcu_pwr_gating_cntl |= DPPU(22) | DPPD(50);\n\t\tWREG32_RCU(RCU_PWR_GATING_CNTL_3, rcu_pwr_gating_cntl);\n\t}\n\n\tsumo_smu_pg_init(rdev);\n}\n\nstatic void sumo_gfx_powergating_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(CG_PWR_GATING_CNTL, DYN_PWR_DOWN_EN, ~DYN_PWR_DOWN_EN);\n\telse {\n\t\tWREG32_P(CG_PWR_GATING_CNTL, 0, ~DYN_PWR_DOWN_EN);\n\t\tRREG32(GB_ADDR_CONFIG);\n\t}\n}\n\nstatic int sumo_enable_clock_power_gating(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (pi->enable_gfx_clock_gating)\n\t\tsumo_gfx_clockgating_initialize(rdev);\n\tif (pi->enable_gfx_power_gating)\n\t\tsumo_gfx_powergating_initialize(rdev);\n\tif (pi->enable_mg_clock_gating)\n\t\tsumo_mg_clockgating_enable(rdev, true);\n\tif (pi->enable_gfx_clock_gating)\n\t\tsumo_gfx_clockgating_enable(rdev, true);\n\tif (pi->enable_gfx_power_gating)\n\t\tsumo_gfx_powergating_enable(rdev, true);\n\n\treturn 0;\n}\n\nstatic void sumo_disable_clock_power_gating(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (pi->enable_gfx_clock_gating)\n\t\tsumo_gfx_clockgating_enable(rdev, false);\n\tif (pi->enable_gfx_power_gating)\n\t\tsumo_gfx_powergating_enable(rdev, false);\n\tif (pi->enable_mg_clock_gating)\n\t\tsumo_mg_clockgating_enable(rdev, false);\n}\n\nstatic void sumo_calculate_bsp(struct radeon_device *rdev,\n\t\t\t       u32 high_clk)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tpi->pasi = 65535 * 100 / high_clk;\n\tpi->asi = 65535 * 100 / high_clk;\n\n\tr600_calculate_u_and_p(pi->asi,\n\t\t\t       xclk, 16, &pi->bsp, &pi->bsu);\n\n\tr600_calculate_u_and_p(pi->pasi,\n\t\t\t       xclk, 16, &pi->pbsp, &pi->pbsu);\n\n\tpi->dsp = BSP(pi->bsp) | BSU(pi->bsu);\n\tpi->psp = BSP(pi->pbsp) | BSU(pi->pbsu);\n}\n\nstatic void sumo_init_bsp(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tWREG32(CG_BSP_0, pi->psp);\n}\n\n\nstatic void sumo_program_bsp(struct radeon_device *rdev,\n\t\t\t     struct radeon_ps *rps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tu32 i;\n\tu32 highest_engine_clock = ps->levels[ps->num_levels - 1].sclk;\n\n\tif (ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\n\t\thighest_engine_clock = pi->boost_pl.sclk;\n\n\tsumo_calculate_bsp(rdev, highest_engine_clock);\n\n\tfor (i = 0; i < ps->num_levels - 1; i++)\n\t\tWREG32(CG_BSP_0 + (i * 4), pi->dsp);\n\n\tWREG32(CG_BSP_0 + (i * 4), pi->psp);\n\n\tif (ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\n\t\tWREG32(CG_BSP_0 + (BOOST_DPM_LEVEL * 4), pi->psp);\n}\n\nstatic void sumo_write_at(struct radeon_device *rdev,\n\t\t\t  u32 index, u32 value)\n{\n\tif (index == 0)\n\t\tWREG32(CG_AT_0, value);\n\telse if (index == 1)\n\t\tWREG32(CG_AT_1, value);\n\telse if (index == 2)\n\t\tWREG32(CG_AT_2, value);\n\telse if (index == 3)\n\t\tWREG32(CG_AT_3, value);\n\telse if (index == 4)\n\t\tWREG32(CG_AT_4, value);\n\telse if (index == 5)\n\t\tWREG32(CG_AT_5, value);\n\telse if (index == 6)\n\t\tWREG32(CG_AT_6, value);\n\telse if (index == 7)\n\t\tWREG32(CG_AT_7, value);\n}\n\nstatic void sumo_program_at(struct radeon_device *rdev,\n\t\t\t    struct radeon_ps *rps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tu32 asi;\n\tu32 i;\n\tu32 m_a;\n\tu32 a_t;\n\tu32 r[SUMO_MAX_HARDWARE_POWERLEVELS];\n\tu32 l[SUMO_MAX_HARDWARE_POWERLEVELS];\n\n\tr[0] = SUMO_R_DFLT0;\n\tr[1] = SUMO_R_DFLT1;\n\tr[2] = SUMO_R_DFLT2;\n\tr[3] = SUMO_R_DFLT3;\n\tr[4] = SUMO_R_DFLT4;\n\n\tl[0] = SUMO_L_DFLT0;\n\tl[1] = SUMO_L_DFLT1;\n\tl[2] = SUMO_L_DFLT2;\n\tl[3] = SUMO_L_DFLT3;\n\tl[4] = SUMO_L_DFLT4;\n\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tasi = (i == ps->num_levels - 1) ? pi->pasi : pi->asi;\n\n\t\tm_a = asi * ps->levels[i].sclk / 100;\n\n\t\ta_t = CG_R(m_a * r[i] / 100) | CG_L(m_a * l[i] / 100);\n\n\t\tsumo_write_at(rdev, i, a_t);\n\t}\n\n\tif (ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE) {\n\t\tasi = pi->pasi;\n\n\t\tm_a = asi * pi->boost_pl.sclk / 100;\n\n\t\ta_t = CG_R(m_a * r[ps->num_levels - 1] / 100) |\n\t\t\tCG_L(m_a * l[ps->num_levels - 1] / 100);\n\n\t\tsumo_write_at(rdev, BOOST_DPM_LEVEL, a_t);\n\t}\n}\n\nstatic void sumo_program_tp(struct radeon_device *rdev)\n{\n\tint i;\n\tenum r600_td td = R600_TD_DFLT;\n\n\tfor (i = 0; i < SUMO_PM_NUMBER_OF_TC; i++) {\n\t\tWREG32_P(CG_FFCT_0 + (i * 4), UTC_0(sumo_utc[i]), ~UTC_0_MASK);\n\t\tWREG32_P(CG_FFCT_0 + (i * 4), DTC_0(sumo_dtc[i]), ~DTC_0_MASK);\n\t}\n\n\tif (td == R600_TD_AUTO)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_FORCE_TREND_SEL);\n\telse\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_FORCE_TREND_SEL, ~FIR_FORCE_TREND_SEL);\n\n\tif (td == R600_TD_UP)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_TREND_MODE);\n\n\tif (td == R600_TD_DOWN)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_TREND_MODE, ~FIR_TREND_MODE);\n}\n\nvoid sumo_program_vc(struct radeon_device *rdev, u32 vrc)\n{\n\tWREG32(CG_FTV, vrc);\n}\n\nvoid sumo_clear_vc(struct radeon_device *rdev)\n{\n\tWREG32(CG_FTV, 0);\n}\n\nvoid sumo_program_sstp(struct radeon_device *rdev)\n{\n\tu32 p, u;\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tr600_calculate_u_and_p(SUMO_SST_DFLT,\n\t\t\t       xclk, 16, &p, &u);\n\n\tWREG32(CG_SSP, SSTU(u) | SST(p));\n}\n\nstatic void sumo_set_divider_value(struct radeon_device *rdev,\n\t\t\t\t   u32 index, u32 divider)\n{\n\tu32 reg_index = index / 4;\n\tu32 field_index = index % 4;\n\n\tif (field_index == 0)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t SCLK_FSTATE_0_DIV(divider), ~SCLK_FSTATE_0_DIV_MASK);\n\telse if (field_index == 1)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t SCLK_FSTATE_1_DIV(divider), ~SCLK_FSTATE_1_DIV_MASK);\n\telse if (field_index == 2)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t SCLK_FSTATE_2_DIV(divider), ~SCLK_FSTATE_2_DIV_MASK);\n\telse if (field_index == 3)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t SCLK_FSTATE_3_DIV(divider), ~SCLK_FSTATE_3_DIV_MASK);\n}\n\nstatic void sumo_set_ds_dividers(struct radeon_device *rdev,\n\t\t\t\t u32 index, u32 divider)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (pi->enable_sclk_ds) {\n\t\tu32 dpm_ctrl = RREG32(CG_SCLK_DPM_CTRL_6);\n\n\t\tdpm_ctrl &= ~(0x7 << (index * 3));\n\t\tdpm_ctrl |= (divider << (index * 3));\n\t\tWREG32(CG_SCLK_DPM_CTRL_6, dpm_ctrl);\n\t}\n}\n\nstatic void sumo_set_ss_dividers(struct radeon_device *rdev,\n\t\t\t\t u32 index, u32 divider)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (pi->enable_sclk_ds) {\n\t\tu32 dpm_ctrl = RREG32(CG_SCLK_DPM_CTRL_11);\n\n\t\tdpm_ctrl &= ~(0x7 << (index * 3));\n\t\tdpm_ctrl |= (divider << (index * 3));\n\t\tWREG32(CG_SCLK_DPM_CTRL_11, dpm_ctrl);\n\t}\n}\n\nstatic void sumo_set_vid(struct radeon_device *rdev, u32 index, u32 vid)\n{\n\tu32 voltage_cntl = RREG32(CG_DPM_VOLTAGE_CNTL);\n\n\tvoltage_cntl &= ~(DPM_STATE0_LEVEL_MASK << (index * 2));\n\tvoltage_cntl |= (vid << (DPM_STATE0_LEVEL_SHIFT + index * 2));\n\tWREG32(CG_DPM_VOLTAGE_CNTL, voltage_cntl);\n}\n\nstatic void sumo_set_allos_gnb_slow(struct radeon_device *rdev, u32 index, u32 gnb_slow)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 temp = gnb_slow;\n\tu32 cg_sclk_dpm_ctrl_3;\n\n\tif (pi->driver_nbps_policy_disable)\n\t\ttemp = 1;\n\n\tcg_sclk_dpm_ctrl_3 = RREG32(CG_SCLK_DPM_CTRL_3);\n\tcg_sclk_dpm_ctrl_3 &= ~(GNB_SLOW_FSTATE_0_MASK << index);\n\tcg_sclk_dpm_ctrl_3 |= (temp << (GNB_SLOW_FSTATE_0_SHIFT + index));\n\n\tWREG32(CG_SCLK_DPM_CTRL_3, cg_sclk_dpm_ctrl_3);\n}\n\nstatic void sumo_program_power_level(struct radeon_device *rdev,\n\t\t\t\t     struct sumo_pl *pl, u32 index)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tint ret;\n\tstruct atom_clock_dividers dividers;\n\tu32 ds_en = RREG32(DEEP_SLEEP_CNTL) & ENABLE_DS;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     pl->sclk, false, &dividers);\n\tif (ret)\n\t\treturn;\n\n\tsumo_set_divider_value(rdev, index, dividers.post_div);\n\n\tsumo_set_vid(rdev, index, pl->vddc_index);\n\n\tif (pl->ss_divider_index == 0 || pl->ds_divider_index == 0) {\n\t\tif (ds_en)\n\t\t\tWREG32_P(DEEP_SLEEP_CNTL, 0, ~ENABLE_DS);\n\t} else {\n\t\tsumo_set_ss_dividers(rdev, index, pl->ss_divider_index);\n\t\tsumo_set_ds_dividers(rdev, index, pl->ds_divider_index);\n\n\t\tif (!ds_en)\n\t\t\tWREG32_P(DEEP_SLEEP_CNTL, ENABLE_DS, ~ENABLE_DS);\n\t}\n\n\tsumo_set_allos_gnb_slow(rdev, index, pl->allow_gnb_slow);\n\n\tif (pi->enable_boost)\n\t\tsumo_set_tdp_limit(rdev, index, pl->sclk_dpm_tdp_limit);\n}\n\nstatic void sumo_power_level_enable(struct radeon_device *rdev, u32 index, bool enable)\n{\n\tu32 reg_index = index / 4;\n\tu32 field_index = index % 4;\n\n\tif (field_index == 0)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t enable ? SCLK_FSTATE_0_VLD : 0, ~SCLK_FSTATE_0_VLD);\n\telse if (field_index == 1)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t enable ? SCLK_FSTATE_1_VLD : 0, ~SCLK_FSTATE_1_VLD);\n\telse if (field_index == 2)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t enable ? SCLK_FSTATE_2_VLD : 0, ~SCLK_FSTATE_2_VLD);\n\telse if (field_index == 3)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL + (reg_index * 4),\n\t\t\t enable ? SCLK_FSTATE_3_VLD : 0, ~SCLK_FSTATE_3_VLD);\n}\n\nstatic bool sumo_dpm_enabled(struct radeon_device *rdev)\n{\n\tif (RREG32(CG_SCLK_DPM_CTRL_3) & DPM_SCLK_ENABLE)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void sumo_start_dpm(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_SCLK_DPM_CTRL_3, DPM_SCLK_ENABLE, ~DPM_SCLK_ENABLE);\n}\n\nstatic void sumo_stop_dpm(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_SCLK_DPM_CTRL_3, 0, ~DPM_SCLK_ENABLE);\n}\n\nstatic void sumo_set_forced_mode(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(CG_SCLK_DPM_CTRL_3, FORCE_SCLK_STATE_EN, ~FORCE_SCLK_STATE_EN);\n\telse\n\t\tWREG32_P(CG_SCLK_DPM_CTRL_3, 0, ~FORCE_SCLK_STATE_EN);\n}\n\nstatic void sumo_set_forced_mode_enabled(struct radeon_device *rdev)\n{\n\tint i;\n\n\tsumo_set_forced_mode(rdev, true);\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(CG_SCLK_STATUS) & SCLK_OVERCLK_DETECT)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void sumo_wait_for_level_0(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_SCLK_INDEX_MASK) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif ((RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_INDEX_MASK) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nstatic void sumo_set_forced_mode_disabled(struct radeon_device *rdev)\n{\n\tsumo_set_forced_mode(rdev, false);\n}\n\nstatic void sumo_enable_power_level_0(struct radeon_device *rdev)\n{\n\tsumo_power_level_enable(rdev, 0, true);\n}\n\nstatic void sumo_patch_boost_state(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_ps *rps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *new_ps = sumo_get_ps(rps);\n\n\tif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE) {\n\t\tpi->boost_pl = new_ps->levels[new_ps->num_levels - 1];\n\t\tpi->boost_pl.sclk = pi->sys_info.boost_sclk;\n\t\tpi->boost_pl.vddc_index = pi->sys_info.boost_vid_2bit;\n\t\tpi->boost_pl.sclk_dpm_tdp_limit = pi->sys_info.sclk_dpm_tdp_limit_boost;\n\t}\n}\n\nstatic void sumo_pre_notify_alt_vddnb_change(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *new_rps,\n\t\t\t\t\t     struct radeon_ps *old_rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\n\tstruct sumo_ps *old_ps = sumo_get_ps(old_rps);\n\tu32 nbps1_old = 0;\n\tu32 nbps1_new = 0;\n\n\tif (old_ps != NULL)\n\t\tnbps1_old = (old_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE) ? 1 : 0;\n\n\tnbps1_new = (new_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE) ? 1 : 0;\n\n\tif (nbps1_old == 1 && nbps1_new == 0)\n\t\tsumo_smu_notify_alt_vddnb_change(rdev, 0, 0);\n}\n\nstatic void sumo_post_notify_alt_vddnb_change(struct radeon_device *rdev,\n\t\t\t\t\t      struct radeon_ps *new_rps,\n\t\t\t\t\t      struct radeon_ps *old_rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\n\tstruct sumo_ps *old_ps = sumo_get_ps(old_rps);\n\tu32 nbps1_old = 0;\n\tu32 nbps1_new = 0;\n\n\tif (old_ps != NULL)\n\t\tnbps1_old = (old_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)? 1 : 0;\n\n\tnbps1_new = (new_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)? 1 : 0;\n\n\tif (nbps1_old == 0 && nbps1_new == 1)\n\t\tsumo_smu_notify_alt_vddnb_change(rdev, 1, 1);\n}\n\nstatic void sumo_enable_boost(struct radeon_device *rdev,\n\t\t\t      struct radeon_ps *rps,\n\t\t\t      bool enable)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(rps);\n\n\tif (enable) {\n\t\tif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\n\t\t\tsumo_boost_state_enable(rdev, true);\n\t} else\n\t\tsumo_boost_state_enable(rdev, false);\n}\n\nstatic void sumo_set_forced_level(struct radeon_device *rdev, u32 index)\n{\n\tWREG32_P(CG_SCLK_DPM_CTRL_3, FORCE_SCLK_STATE(index), ~FORCE_SCLK_STATE_MASK);\n}\n\nstatic void sumo_set_forced_level_0(struct radeon_device *rdev)\n{\n\tsumo_set_forced_level(rdev, 0);\n}\n\nstatic void sumo_program_wl(struct radeon_device *rdev,\n\t\t\t    struct radeon_ps *rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(rps);\n\tu32 dpm_ctrl4 = RREG32(CG_SCLK_DPM_CTRL_4);\n\n\tdpm_ctrl4 &= 0xFFFFFF00;\n\tdpm_ctrl4 |= (1 << (new_ps->num_levels - 1));\n\n\tif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\n\t\tdpm_ctrl4 |= (1 << BOOST_DPM_LEVEL);\n\n\tWREG32(CG_SCLK_DPM_CTRL_4, dpm_ctrl4);\n}\n\nstatic void sumo_program_power_levels_0_to_n(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *new_rps,\n\t\t\t\t\t     struct radeon_ps *old_rps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\n\tstruct sumo_ps *old_ps = sumo_get_ps(old_rps);\n\tu32 i;\n\tu32 n_current_state_levels = (old_ps == NULL) ? 1 : old_ps->num_levels;\n\n\tfor (i = 0; i < new_ps->num_levels; i++) {\n\t\tsumo_program_power_level(rdev, &new_ps->levels[i], i);\n\t\tsumo_power_level_enable(rdev, i, true);\n\t}\n\n\tfor (i = new_ps->num_levels; i < n_current_state_levels; i++)\n\t\tsumo_power_level_enable(rdev, i, false);\n\n\tif (new_ps->flags & SUMO_POWERSTATE_FLAGS_BOOST_STATE)\n\t\tsumo_program_power_level(rdev, &pi->boost_pl, BOOST_DPM_LEVEL);\n}\n\nstatic void sumo_enable_acpi_pm(struct radeon_device *rdev)\n{\n\tWREG32_P(GENERAL_PWRMGT, STATIC_PM_EN, ~STATIC_PM_EN);\n}\n\nstatic void sumo_program_power_level_enter_state(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_SCLK_DPM_CTRL_5, SCLK_FSTATE_BOOTUP(0), ~SCLK_FSTATE_BOOTUP_MASK);\n}\n\nstatic void sumo_program_acpi_power_level(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     pi->acpi_pl.sclk,\n\t\t\t\t\t     false, &dividers);\n\tif (ret)\n\t\treturn;\n\n\tWREG32_P(CG_ACPI_CNTL, SCLK_ACPI_DIV(dividers.post_div), ~SCLK_ACPI_DIV_MASK);\n\tWREG32_P(CG_ACPI_VOLTAGE_CNTL, 0, ~ACPI_VOLTAGE_EN);\n}\n\nstatic void sumo_program_bootup_state(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 dpm_ctrl4 = RREG32(CG_SCLK_DPM_CTRL_4);\n\tu32 i;\n\n\tsumo_program_power_level(rdev, &pi->boot_pl, 0);\n\n\tdpm_ctrl4 &= 0xFFFFFF00;\n\tWREG32(CG_SCLK_DPM_CTRL_4, dpm_ctrl4);\n\n\tfor (i = 1; i < 8; i++)\n\t\tsumo_power_level_enable(rdev, i, false);\n}\n\nstatic void sumo_setup_uvd_clocks(struct radeon_device *rdev,\n\t\t\t\t  struct radeon_ps *new_rps,\n\t\t\t\t  struct radeon_ps *old_rps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (pi->enable_gfx_power_gating) {\n\t\tsumo_gfx_powergating_enable(rdev, false);\n\t}\n\n\tradeon_set_uvd_clocks(rdev, new_rps->vclk, new_rps->dclk);\n\n\tif (pi->enable_gfx_power_gating) {\n\t\tif (!pi->disable_gfx_power_gating_in_uvd ||\n\t\t    !r600_is_uvd_state(new_rps->class, new_rps->class2))\n\t\t\tsumo_gfx_powergating_enable(rdev, true);\n\t}\n}\n\nstatic void sumo_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t    struct radeon_ps *new_rps,\n\t\t\t\t\t\t    struct radeon_ps *old_rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\n\tstruct sumo_ps *current_ps = sumo_get_ps(old_rps);\n\n\tif ((new_rps->vclk == old_rps->vclk) &&\n\t    (new_rps->dclk == old_rps->dclk))\n\t\treturn;\n\n\tif (new_ps->levels[new_ps->num_levels - 1].sclk >=\n\t    current_ps->levels[current_ps->num_levels - 1].sclk)\n\t\treturn;\n\n\tsumo_setup_uvd_clocks(rdev, new_rps, old_rps);\n}\n\nstatic void sumo_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t   struct radeon_ps *new_rps,\n\t\t\t\t\t\t   struct radeon_ps *old_rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(new_rps);\n\tstruct sumo_ps *current_ps = sumo_get_ps(old_rps);\n\n\tif ((new_rps->vclk == old_rps->vclk) &&\n\t    (new_rps->dclk == old_rps->dclk))\n\t\treturn;\n\n\tif (new_ps->levels[new_ps->num_levels - 1].sclk <\n\t    current_ps->levels[current_ps->num_levels - 1].sclk)\n\t\treturn;\n\n\tsumo_setup_uvd_clocks(rdev, new_rps, old_rps);\n}\n\nvoid sumo_take_smu_control(struct radeon_device *rdev, bool enable)\n{\n \n#if 0\n\tu32 v = RREG32(DOUT_SCRATCH3);\n\n\tif (enable)\n\t\tv |= 0x4;\n\telse\n\t\tv &= 0xFFFFFFFB;\n\n\tWREG32(DOUT_SCRATCH3, v);\n#endif\n}\n\nstatic void sumo_enable_sclk_ds(struct radeon_device *rdev, bool enable)\n{\n\tif (enable) {\n\t\tu32 deep_sleep_cntl = RREG32(DEEP_SLEEP_CNTL);\n\t\tu32 deep_sleep_cntl2 = RREG32(DEEP_SLEEP_CNTL2);\n\t\tu32 t = 1;\n\n\t\tdeep_sleep_cntl &= ~R_DIS;\n\t\tdeep_sleep_cntl &= ~HS_MASK;\n\t\tdeep_sleep_cntl |= HS(t > 4095 ? 4095 : t);\n\n\t\tdeep_sleep_cntl2 |= LB_UFP_EN;\n\t\tdeep_sleep_cntl2 &= INOUT_C_MASK;\n\t\tdeep_sleep_cntl2 |= INOUT_C(0xf);\n\n\t\tWREG32(DEEP_SLEEP_CNTL2, deep_sleep_cntl2);\n\t\tWREG32(DEEP_SLEEP_CNTL, deep_sleep_cntl);\n\t} else\n\t\tWREG32_P(DEEP_SLEEP_CNTL, 0, ~ENABLE_DS);\n}\n\nstatic void sumo_program_bootup_at(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_AT_0, CG_R(0xffff), ~CG_R_MASK);\n\tWREG32_P(CG_AT_0, CG_L(0), ~CG_L_MASK);\n}\n\nstatic void sumo_reset_am(struct radeon_device *rdev)\n{\n\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_RESET, ~FIR_RESET);\n}\n\nstatic void sumo_start_am(struct radeon_device *rdev)\n{\n\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_RESET);\n}\n\nstatic void sumo_program_ttp(struct radeon_device *rdev)\n{\n\tu32 xclk = radeon_get_xclk(rdev);\n\tu32 p, u;\n\tu32 cg_sclk_dpm_ctrl_5 = RREG32(CG_SCLK_DPM_CTRL_5);\n\n\tr600_calculate_u_and_p(1000,\n\t\t\t       xclk, 16, &p, &u);\n\n\tcg_sclk_dpm_ctrl_5 &= ~(TT_TP_MASK | TT_TU_MASK);\n\tcg_sclk_dpm_ctrl_5 |= TT_TP(p) | TT_TU(u);\n\n\tWREG32(CG_SCLK_DPM_CTRL_5, cg_sclk_dpm_ctrl_5);\n}\n\nstatic void sumo_program_ttt(struct radeon_device *rdev)\n{\n\tu32 cg_sclk_dpm_ctrl_3 = RREG32(CG_SCLK_DPM_CTRL_3);\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tcg_sclk_dpm_ctrl_3 &= ~(GNB_TT_MASK | GNB_THERMTHRO_MASK);\n\tcg_sclk_dpm_ctrl_3 |= GNB_TT(pi->thermal_auto_throttling + 49);\n\n\tWREG32(CG_SCLK_DPM_CTRL_3, cg_sclk_dpm_ctrl_3);\n}\n\n\nstatic void sumo_enable_voltage_scaling(struct radeon_device *rdev, bool enable)\n{\n\tif (enable) {\n\t\tWREG32_P(CG_DPM_VOLTAGE_CNTL, DPM_VOLTAGE_EN, ~DPM_VOLTAGE_EN);\n\t\tWREG32_P(CG_CG_VOLTAGE_CNTL, 0, ~CG_VOLTAGE_EN);\n\t} else {\n\t\tWREG32_P(CG_CG_VOLTAGE_CNTL, CG_VOLTAGE_EN, ~CG_VOLTAGE_EN);\n\t\tWREG32_P(CG_DPM_VOLTAGE_CNTL, 0, ~DPM_VOLTAGE_EN);\n\t}\n}\n\nstatic void sumo_override_cnb_thermal_events(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_SCLK_DPM_CTRL_3, CNB_THERMTHRO_MASK_SCLK,\n\t\t ~CNB_THERMTHRO_MASK_SCLK);\n}\n\nstatic void sumo_program_dc_hto(struct radeon_device *rdev)\n{\n\tu32 cg_sclk_dpm_ctrl_4 = RREG32(CG_SCLK_DPM_CTRL_4);\n\tu32 p, u;\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tr600_calculate_u_and_p(100000,\n\t\t\t       xclk, 14, &p, &u);\n\n\tcg_sclk_dpm_ctrl_4 &= ~(DC_HDC_MASK | DC_HU_MASK);\n\tcg_sclk_dpm_ctrl_4 |= DC_HDC(p) | DC_HU(u);\n\n\tWREG32(CG_SCLK_DPM_CTRL_4, cg_sclk_dpm_ctrl_4);\n}\n\nstatic void sumo_force_nbp_state(struct radeon_device *rdev,\n\t\t\t\t struct radeon_ps *rps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *new_ps = sumo_get_ps(rps);\n\n\tif (!pi->driver_nbps_policy_disable) {\n\t\tif (new_ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)\n\t\t\tWREG32_P(CG_SCLK_DPM_CTRL_3, FORCE_NB_PSTATE_1, ~FORCE_NB_PSTATE_1);\n\t\telse\n\t\t\tWREG32_P(CG_SCLK_DPM_CTRL_3, 0, ~FORCE_NB_PSTATE_1);\n\t}\n}\n\nu32 sumo_get_sleep_divider_from_id(u32 id)\n{\n\treturn 1 << id;\n}\n\nu32 sumo_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\n\t\t\t\t\t u32 sclk,\n\t\t\t\t\t u32 min_sclk_in_sr)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 i;\n\tu32 temp;\n\tu32 min = (min_sclk_in_sr > SUMO_MINIMUM_ENGINE_CLOCK) ?\n\t\tmin_sclk_in_sr : SUMO_MINIMUM_ENGINE_CLOCK;\n\n\tif (sclk < min)\n\t\treturn 0;\n\n\tif (!pi->enable_sclk_ds)\n\t\treturn 0;\n\n\tfor (i = SUMO_MAX_DEEPSLEEP_DIVIDER_ID;  ; i--) {\n\t\ttemp = sclk / sumo_get_sleep_divider_from_id(i);\n\n\t\tif (temp >= min || i == 0)\n\t\t\tbreak;\n\t}\n\treturn i;\n}\n\nstatic u32 sumo_get_valid_engine_clock(struct radeon_device *rdev,\n\t\t\t\t       u32 lower_limit)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 i;\n\n\tfor (i = 0; i < pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries; i++) {\n\t\tif (pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency >= lower_limit)\n\t\t\treturn pi->sys_info.sclk_voltage_mapping_table.entries[i].sclk_frequency;\n\t}\n\n\treturn pi->sys_info.sclk_voltage_mapping_table.entries[pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries - 1].sclk_frequency;\n}\n\nstatic void sumo_patch_thermal_state(struct radeon_device *rdev,\n\t\t\t\t     struct sumo_ps *ps,\n\t\t\t\t     struct sumo_ps *current_ps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 sclk_in_sr = pi->sys_info.min_sclk;  \n\tu32 current_vddc;\n\tu32 current_sclk;\n\tu32 current_index = 0;\n\n\tif (current_ps) {\n\t\tcurrent_vddc = current_ps->levels[current_index].vddc_index;\n\t\tcurrent_sclk = current_ps->levels[current_index].sclk;\n\t} else {\n\t\tcurrent_vddc = pi->boot_pl.vddc_index;\n\t\tcurrent_sclk = pi->boot_pl.sclk;\n\t}\n\n\tps->levels[0].vddc_index = current_vddc;\n\n\tif (ps->levels[0].sclk > current_sclk)\n\t\tps->levels[0].sclk = current_sclk;\n\n\tps->levels[0].ss_divider_index =\n\t\tsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[0].sclk, sclk_in_sr);\n\n\tps->levels[0].ds_divider_index =\n\t\tsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[0].sclk, SUMO_MINIMUM_ENGINE_CLOCK);\n\n\tif (ps->levels[0].ds_divider_index > ps->levels[0].ss_divider_index + 1)\n\t\tps->levels[0].ds_divider_index = ps->levels[0].ss_divider_index + 1;\n\n\tif (ps->levels[0].ss_divider_index == ps->levels[0].ds_divider_index) {\n\t\tif (ps->levels[0].ss_divider_index > 1)\n\t\t\tps->levels[0].ss_divider_index = ps->levels[0].ss_divider_index - 1;\n\t}\n\n\tif (ps->levels[0].ss_divider_index == 0)\n\t\tps->levels[0].ds_divider_index = 0;\n\n\tif (ps->levels[0].ds_divider_index == 0)\n\t\tps->levels[0].ss_divider_index = 0;\n}\n\nstatic void sumo_apply_state_adjust_rules(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *new_rps,\n\t\t\t\t\t  struct radeon_ps *old_rps)\n{\n\tstruct sumo_ps *ps = sumo_get_ps(new_rps);\n\tstruct sumo_ps *current_ps = sumo_get_ps(old_rps);\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 min_voltage = 0;  \n\tu32 min_sclk = pi->sys_info.min_sclk;  \n\tu32 sclk_in_sr = pi->sys_info.min_sclk;  \n\tu32 i;\n\n\tif (new_rps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\treturn sumo_patch_thermal_state(rdev, ps, current_ps);\n\n\tif (pi->enable_boost) {\n\t\tif (new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE)\n\t\t\tps->flags |= SUMO_POWERSTATE_FLAGS_BOOST_STATE;\n\t}\n\n\tif ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_BATTERY) ||\n\t    (new_rps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE) ||\n\t    (new_rps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE))\n\t\tps->flags |= SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE;\n\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tif (ps->levels[i].vddc_index < min_voltage)\n\t\t\tps->levels[i].vddc_index = min_voltage;\n\n\t\tif (ps->levels[i].sclk < min_sclk)\n\t\t\tps->levels[i].sclk =\n\t\t\t\tsumo_get_valid_engine_clock(rdev, min_sclk);\n\n\t\tps->levels[i].ss_divider_index =\n\t\t\tsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[i].sclk, sclk_in_sr);\n\n\t\tps->levels[i].ds_divider_index =\n\t\t\tsumo_get_sleep_divider_id_from_clock(rdev, ps->levels[i].sclk, SUMO_MINIMUM_ENGINE_CLOCK);\n\n\t\tif (ps->levels[i].ds_divider_index > ps->levels[i].ss_divider_index + 1)\n\t\t\tps->levels[i].ds_divider_index = ps->levels[i].ss_divider_index + 1;\n\n\t\tif (ps->levels[i].ss_divider_index == ps->levels[i].ds_divider_index) {\n\t\t\tif (ps->levels[i].ss_divider_index > 1)\n\t\t\t\tps->levels[i].ss_divider_index = ps->levels[i].ss_divider_index - 1;\n\t\t}\n\n\t\tif (ps->levels[i].ss_divider_index == 0)\n\t\t\tps->levels[i].ds_divider_index = 0;\n\n\t\tif (ps->levels[i].ds_divider_index == 0)\n\t\t\tps->levels[i].ss_divider_index = 0;\n\n\t\tif (ps->flags & SUMO_POWERSTATE_FLAGS_FORCE_NBPS1_STATE)\n\t\t\tps->levels[i].allow_gnb_slow = 1;\n\t\telse if ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE) ||\n\t\t\t (new_rps->class2 & ATOM_PPLIB_CLASSIFICATION2_MVC))\n\t\t\tps->levels[i].allow_gnb_slow = 0;\n\t\telse if (i == ps->num_levels - 1)\n\t\t\tps->levels[i].allow_gnb_slow = 0;\n\t\telse\n\t\t\tps->levels[i].allow_gnb_slow = 1;\n\t}\n}\n\nstatic void sumo_cleanup_asic(struct radeon_device *rdev)\n{\n\tsumo_take_smu_control(rdev, false);\n}\n\nstatic int sumo_set_thermal_temperature_range(struct radeon_device *rdev,\n\t\t\t\t\t      int min_temp, int max_temp)\n{\n\tint low_temp = 0 * 1000;\n\tint high_temp = 255 * 1000;\n\n\tif (low_temp < min_temp)\n\t\tlow_temp = min_temp;\n\tif (high_temp > max_temp)\n\t\thigh_temp = max_temp;\n\tif (high_temp < low_temp) {\n\t\tDRM_ERROR(\"invalid thermal range: %d - %d\\n\", low_temp, high_temp);\n\t\treturn -EINVAL;\n\t}\n\n\tWREG32_P(CG_THERMAL_INT, DIG_THERM_INTH(49 + (high_temp / 1000)), ~DIG_THERM_INTH_MASK);\n\tWREG32_P(CG_THERMAL_INT, DIG_THERM_INTL(49 + (low_temp / 1000)), ~DIG_THERM_INTL_MASK);\n\n\trdev->pm.dpm.thermal.min_temp = low_temp;\n\trdev->pm.dpm.thermal.max_temp = high_temp;\n\n\treturn 0;\n}\n\nstatic void sumo_update_current_ps(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_ps *rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(rps);\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tpi->current_rps = *rps;\n\tpi->current_ps = *new_ps;\n\tpi->current_rps.ps_priv = &pi->current_ps;\n}\n\nstatic void sumo_update_requested_ps(struct radeon_device *rdev,\n\t\t\t\t     struct radeon_ps *rps)\n{\n\tstruct sumo_ps *new_ps = sumo_get_ps(rps);\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tpi->requested_rps = *rps;\n\tpi->requested_ps = *new_ps;\n\tpi->requested_rps.ps_priv = &pi->requested_ps;\n}\n\nint sumo_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (sumo_dpm_enabled(rdev))\n\t\treturn -EINVAL;\n\n\tsumo_program_bootup_state(rdev);\n\tsumo_init_bsp(rdev);\n\tsumo_reset_am(rdev);\n\tsumo_program_tp(rdev);\n\tsumo_program_bootup_at(rdev);\n\tsumo_start_am(rdev);\n\tif (pi->enable_auto_thermal_throttling) {\n\t\tsumo_program_ttp(rdev);\n\t\tsumo_program_ttt(rdev);\n\t}\n\tsumo_program_dc_hto(rdev);\n\tsumo_program_power_level_enter_state(rdev);\n\tsumo_enable_voltage_scaling(rdev, true);\n\tsumo_program_sstp(rdev);\n\tsumo_program_vc(rdev, SUMO_VRC_DFLT);\n\tsumo_override_cnb_thermal_events(rdev);\n\tsumo_start_dpm(rdev);\n\tsumo_wait_for_level_0(rdev);\n\tif (pi->enable_sclk_ds)\n\t\tsumo_enable_sclk_ds(rdev, true);\n\tif (pi->enable_boost)\n\t\tsumo_enable_boost_timer(rdev);\n\n\tsumo_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\n\n\treturn 0;\n}\n\nint sumo_dpm_late_enable(struct radeon_device *rdev)\n{\n\tint ret;\n\n\tret = sumo_enable_clock_power_gating(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\tret = sumo_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trdev->irq.dpm_thermal = true;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\treturn 0;\n}\n\nvoid sumo_dpm_disable(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tif (!sumo_dpm_enabled(rdev))\n\t\treturn;\n\tsumo_disable_clock_power_gating(rdev);\n\tif (pi->enable_sclk_ds)\n\t\tsumo_enable_sclk_ds(rdev, false);\n\tsumo_clear_vc(rdev);\n\tsumo_wait_for_level_0(rdev);\n\tsumo_stop_dpm(rdev);\n\tsumo_enable_voltage_scaling(rdev, false);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\tsumo_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\n}\n\nint sumo_dpm_pre_set_power_state(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *new_ps = &requested_ps;\n\n\tsumo_update_requested_ps(rdev, new_ps);\n\n\tif (pi->enable_dynamic_patch_ps)\n\t\tsumo_apply_state_adjust_rules(rdev,\n\t\t\t\t\t      &pi->requested_rps,\n\t\t\t\t\t      &pi->current_rps);\n\n\treturn 0;\n}\n\nint sumo_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &pi->requested_rps;\n\tstruct radeon_ps *old_ps = &pi->current_rps;\n\n\tif (pi->enable_dpm)\n\t\tsumo_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\tif (pi->enable_boost) {\n\t\tsumo_enable_boost(rdev, new_ps, false);\n\t\tsumo_patch_boost_state(rdev, new_ps);\n\t}\n\tif (pi->enable_dpm) {\n\t\tsumo_pre_notify_alt_vddnb_change(rdev, new_ps, old_ps);\n\t\tsumo_enable_power_level_0(rdev);\n\t\tsumo_set_forced_level_0(rdev);\n\t\tsumo_set_forced_mode_enabled(rdev);\n\t\tsumo_wait_for_level_0(rdev);\n\t\tsumo_program_power_levels_0_to_n(rdev, new_ps, old_ps);\n\t\tsumo_program_wl(rdev, new_ps);\n\t\tsumo_program_bsp(rdev, new_ps);\n\t\tsumo_program_at(rdev, new_ps);\n\t\tsumo_force_nbp_state(rdev, new_ps);\n\t\tsumo_set_forced_mode_disabled(rdev);\n\t\tsumo_set_forced_mode_enabled(rdev);\n\t\tsumo_set_forced_mode_disabled(rdev);\n\t\tsumo_post_notify_alt_vddnb_change(rdev, new_ps, old_ps);\n\t}\n\tif (pi->enable_boost)\n\t\tsumo_enable_boost(rdev, new_ps, true);\n\tif (pi->enable_dpm)\n\t\tsumo_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\n\treturn 0;\n}\n\nvoid sumo_dpm_post_set_power_state(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &pi->requested_rps;\n\n\tsumo_update_current_ps(rdev, new_ps);\n}\n\n#if 0\nvoid sumo_dpm_reset_asic(struct radeon_device *rdev)\n{\n\tsumo_program_bootup_state(rdev);\n\tsumo_enable_power_level_0(rdev);\n\tsumo_set_forced_level_0(rdev);\n\tsumo_set_forced_mode_enabled(rdev);\n\tsumo_wait_for_level_0(rdev);\n\tsumo_set_forced_mode_disabled(rdev);\n\tsumo_set_forced_mode_enabled(rdev);\n\tsumo_set_forced_mode_disabled(rdev);\n}\n#endif\n\nvoid sumo_dpm_setup_asic(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tsumo_initialize_m3_arb(rdev);\n\tpi->fw_version = sumo_get_running_fw_version(rdev);\n\tDRM_INFO(\"Found smc ucode version: 0x%08x\\n\", pi->fw_version);\n\tsumo_program_acpi_power_level(rdev);\n\tsumo_enable_acpi_pm(rdev);\n\tsumo_take_smu_control(rdev, true);\n}\n\nvoid sumo_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\n}\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void sumo_patch_boot_state(struct radeon_device *rdev,\n\t\t\t\t  struct sumo_ps *ps)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tps->num_levels = 1;\n\tps->flags = 0;\n\tps->levels[0] = pi->boot_pl;\n}\n\nstatic void sumo_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t    struct radeon_ps *rps,\n\t\t\t\t\t    struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t    u8 table_rev)\n{\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\trdev->pm.dpm.boot_ps = rps;\n\t\tsumo_patch_boot_state(rdev, ps);\n\t}\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void sumo_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_ps *rps, int index,\n\t\t\t\t\tunion pplib_clock_info *clock_info)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tstruct sumo_pl *pl = &ps->levels[index];\n\tu32 sclk;\n\n\tsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\n\tsclk |= clock_info->sumo.ucEngineClockHigh << 16;\n\tpl->sclk = sclk;\n\tpl->vddc_index = clock_info->sumo.vddcIndex;\n\tpl->sclk_dpm_tdp_limit = clock_info->sumo.tdpLimit;\n\n\tps->num_levels = index + 1;\n\n\tif (pi->enable_sclk_ds) {\n\t\tpl->ds_divider_index = 5;\n\t\tpl->ss_divider_index = 4;\n\t}\n}\n\nstatic int sumo_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j, k, non_clock_array_index, clock_array_index;\n\tunion pplib_clock_info *clock_info;\n\tstruct _StateArray *state_array;\n\tstruct _ClockInfoArray *clock_info_array;\n\tstruct _NonClockInfoArray *non_clock_info_array;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tu8 *power_state_offset;\n\tstruct sumo_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tstate_array = (struct _StateArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset));\n\tclock_info_array = (struct _ClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\n\tnon_clock_info_array = (struct _NonClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\n\n\trdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\tpower_state_offset = (u8 *)state_array->states;\n\tfor (i = 0; i < state_array->ucNumEntries; i++) {\n\t\tu8 *idx;\n\t\tpower_state = (union pplib_power_state *)power_state_offset;\n\t\tnon_clock_array_index = power_state->v2.nonClockInfoIndex;\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t&non_clock_info_array->nonClockInfo[non_clock_array_index];\n\t\tif (!rdev->pm.power_state[i].clock_info) {\n\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tps = kzalloc(sizeof(struct sumo_ps), GFP_KERNEL);\n\t\tif (ps == NULL) {\n\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\tk = 0;\n\t\tidx = (u8 *)&power_state->v2.clockInfoIndex[0];\n\t\tfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\n\t\t\tclock_array_index = idx[j];\n\t\t\tif (k >= SUMO_MAX_HARDWARE_POWERLEVELS)\n\t\t\t\tbreak;\n\n\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t((u8 *)&clock_info_array->clockInfo[0] +\n\t\t\t\t (clock_array_index * clock_info_array->ucEntrySize));\n\t\t\tsumo_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t    &rdev->pm.dpm.ps[i], k,\n\t\t\t\t\t\t    clock_info);\n\t\t\tk++;\n\t\t}\n\t\tsumo_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\tnon_clock_info,\n\t\t\t\t\t\tnon_clock_info_array->ucEntrySize);\n\t\tpower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\n\t}\n\trdev->pm.dpm.num_ps = state_array->ucNumEntries;\n\treturn 0;\n}\n\nu32 sumo_convert_vid2_to_vid7(struct radeon_device *rdev,\n\t\t\t      struct sumo_vid_mapping_table *vid_mapping_table,\n\t\t\t      u32 vid_2bit)\n{\n\tu32 i;\n\n\tfor (i = 0; i < vid_mapping_table->num_entries; i++) {\n\t\tif (vid_mapping_table->entries[i].vid_2bit == vid_2bit)\n\t\t\treturn vid_mapping_table->entries[i].vid_7bit;\n\t}\n\n\treturn vid_mapping_table->entries[vid_mapping_table->num_entries - 1].vid_7bit;\n}\n\n#if 0\nu32 sumo_convert_vid7_to_vid2(struct radeon_device *rdev,\n\t\t\t      struct sumo_vid_mapping_table *vid_mapping_table,\n\t\t\t      u32 vid_7bit)\n{\n\tu32 i;\n\n\tfor (i = 0; i < vid_mapping_table->num_entries; i++) {\n\t\tif (vid_mapping_table->entries[i].vid_7bit == vid_7bit)\n\t\t\treturn vid_mapping_table->entries[i].vid_2bit;\n\t}\n\n\treturn vid_mapping_table->entries[vid_mapping_table->num_entries - 1].vid_2bit;\n}\n#endif\n\nstatic u16 sumo_convert_voltage_index_to_value(struct radeon_device *rdev,\n\t\t\t\t\t       u32 vid_2bit)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 vid_7bit = sumo_convert_vid2_to_vid7(rdev, &pi->sys_info.vid_mapping_table, vid_2bit);\n\n\tif (vid_7bit > 0x7C)\n\t\treturn 0;\n\n\treturn (15500 - vid_7bit * 125 + 5) / 10;\n}\n\nstatic void sumo_construct_display_voltage_mapping_table(struct radeon_device *rdev,\n\t\t\t\t\t\t\t struct sumo_disp_clock_voltage_mapping_table *disp_clk_voltage_mapping_table,\n\t\t\t\t\t\t\t ATOM_CLK_VOLT_CAPABILITY *table)\n{\n\tu32 i;\n\n\tfor (i = 0; i < SUMO_MAX_NUMBER_VOLTAGES; i++) {\n\t\tif (table[i].ulMaximumSupportedCLK == 0)\n\t\t\tbreak;\n\n\t\tdisp_clk_voltage_mapping_table->display_clock_frequency[i] =\n\t\t\ttable[i].ulMaximumSupportedCLK;\n\t}\n\n\tdisp_clk_voltage_mapping_table->num_max_voltage_levels = i;\n\n\tif (disp_clk_voltage_mapping_table->num_max_voltage_levels == 0) {\n\t\tdisp_clk_voltage_mapping_table->display_clock_frequency[0] = 80000;\n\t\tdisp_clk_voltage_mapping_table->num_max_voltage_levels = 1;\n\t}\n}\n\nvoid sumo_construct_sclk_voltage_mapping_table(struct radeon_device *rdev,\n\t\t\t\t\t       struct sumo_sclk_voltage_mapping_table *sclk_voltage_mapping_table,\n\t\t\t\t\t       ATOM_AVAILABLE_SCLK_LIST *table)\n{\n\tu32 i;\n\tu32 n = 0;\n\tu32 prev_sclk = 0;\n\n\tfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++) {\n\t\tif (table[i].ulSupportedSCLK > prev_sclk) {\n\t\t\tsclk_voltage_mapping_table->entries[n].sclk_frequency =\n\t\t\t\ttable[i].ulSupportedSCLK;\n\t\t\tsclk_voltage_mapping_table->entries[n].vid_2bit =\n\t\t\t\ttable[i].usVoltageIndex;\n\t\t\tprev_sclk = table[i].ulSupportedSCLK;\n\t\t\tn++;\n\t\t}\n\t}\n\n\tsclk_voltage_mapping_table->num_max_dpm_entries = n;\n}\n\nvoid sumo_construct_vid_mapping_table(struct radeon_device *rdev,\n\t\t\t\t      struct sumo_vid_mapping_table *vid_mapping_table,\n\t\t\t\t      ATOM_AVAILABLE_SCLK_LIST *table)\n{\n\tu32 i, j;\n\n\tfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++) {\n\t\tif (table[i].ulSupportedSCLK != 0) {\n\t\t\tvid_mapping_table->entries[table[i].usVoltageIndex].vid_7bit =\n\t\t\t\ttable[i].usVoltageID;\n\t\t\tvid_mapping_table->entries[table[i].usVoltageIndex].vid_2bit =\n\t\t\t\ttable[i].usVoltageIndex;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SUMO_MAX_NUMBER_VOLTAGES; i++) {\n\t\tif (vid_mapping_table->entries[i].vid_7bit == 0) {\n\t\t\tfor (j = i + 1; j < SUMO_MAX_NUMBER_VOLTAGES; j++) {\n\t\t\t\tif (vid_mapping_table->entries[j].vid_7bit != 0) {\n\t\t\t\t\tvid_mapping_table->entries[i] =\n\t\t\t\t\t\tvid_mapping_table->entries[j];\n\t\t\t\t\tvid_mapping_table->entries[j].vid_7bit = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (j == SUMO_MAX_NUMBER_VOLTAGES)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tvid_mapping_table->num_entries = i;\n}\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V5 info_5;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V6 info_6;\n};\n\nstatic int sumo_parse_sys_info_table(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 data_offset;\n\tint i;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t      data_offset);\n\n\t\tif (crev != 6) {\n\t\t\tDRM_ERROR(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpi->sys_info.bootup_sclk = le32_to_cpu(igp_info->info_6.ulBootUpEngineClock);\n\t\tpi->sys_info.min_sclk = le32_to_cpu(igp_info->info_6.ulMinEngineClock);\n\t\tpi->sys_info.bootup_uma_clk = le32_to_cpu(igp_info->info_6.ulBootUpUMAClock);\n\t\tpi->sys_info.bootup_nb_voltage_index =\n\t\t\tle16_to_cpu(igp_info->info_6.usBootUpNBVoltage);\n\t\tif (igp_info->info_6.ucHtcTmpLmt == 0)\n\t\t\tpi->sys_info.htc_tmp_lmt = 203;\n\t\telse\n\t\t\tpi->sys_info.htc_tmp_lmt = igp_info->info_6.ucHtcTmpLmt;\n\t\tif (igp_info->info_6.ucHtcHystLmt == 0)\n\t\t\tpi->sys_info.htc_hyst_lmt = 5;\n\t\telse\n\t\t\tpi->sys_info.htc_hyst_lmt = igp_info->info_6.ucHtcHystLmt;\n\t\tif (pi->sys_info.htc_tmp_lmt <= pi->sys_info.htc_hyst_lmt) {\n\t\t\tDRM_ERROR(\"The htcTmpLmt should be larger than htcHystLmt.\\n\");\n\t\t}\n\t\tfor (i = 0; i < NUMBER_OF_M3ARB_PARAM_SETS; i++) {\n\t\t\tpi->sys_info.csr_m3_arb_cntl_default[i] =\n\t\t\t\tle32_to_cpu(igp_info->info_6.ulCSR_M3_ARB_CNTL_DEFAULT[i]);\n\t\t\tpi->sys_info.csr_m3_arb_cntl_uvd[i] =\n\t\t\t\tle32_to_cpu(igp_info->info_6.ulCSR_M3_ARB_CNTL_UVD[i]);\n\t\t\tpi->sys_info.csr_m3_arb_cntl_fs3d[i] =\n\t\t\t\tle32_to_cpu(igp_info->info_6.ulCSR_M3_ARB_CNTL_FS3D[i]);\n\t\t}\n\t\tpi->sys_info.sclk_dpm_boost_margin =\n\t\t\tle32_to_cpu(igp_info->info_6.SclkDpmBoostMargin);\n\t\tpi->sys_info.sclk_dpm_throttle_margin =\n\t\t\tle32_to_cpu(igp_info->info_6.SclkDpmThrottleMargin);\n\t\tpi->sys_info.sclk_dpm_tdp_limit_pg =\n\t\t\tle16_to_cpu(igp_info->info_6.SclkDpmTdpLimitPG);\n\t\tpi->sys_info.gnb_tdp_limit = le16_to_cpu(igp_info->info_6.GnbTdpLimit);\n\t\tpi->sys_info.sclk_dpm_tdp_limit_boost =\n\t\t\tle16_to_cpu(igp_info->info_6.SclkDpmTdpLimitBoost);\n\t\tpi->sys_info.boost_sclk = le32_to_cpu(igp_info->info_6.ulBoostEngineCLock);\n\t\tpi->sys_info.boost_vid_2bit = igp_info->info_6.ulBoostVid_2bit;\n\t\tif (igp_info->info_6.EnableBoost)\n\t\t\tpi->sys_info.enable_boost = true;\n\t\telse\n\t\t\tpi->sys_info.enable_boost = false;\n\t\tsumo_construct_display_voltage_mapping_table(rdev,\n\t\t\t\t\t\t\t     &pi->sys_info.disp_clk_voltage_mapping_table,\n\t\t\t\t\t\t\t     igp_info->info_6.sDISPCLK_Voltage);\n\t\tsumo_construct_sclk_voltage_mapping_table(rdev,\n\t\t\t\t\t\t\t  &pi->sys_info.sclk_voltage_mapping_table,\n\t\t\t\t\t\t\t  igp_info->info_6.sAvail_SCLK);\n\t\tsumo_construct_vid_mapping_table(rdev, &pi->sys_info.vid_mapping_table,\n\t\t\t\t\t\t igp_info->info_6.sAvail_SCLK);\n\n\t}\n\treturn 0;\n}\n\nstatic void sumo_construct_boot_and_acpi_state(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\tpi->boot_pl.sclk = pi->sys_info.bootup_sclk;\n\tpi->boot_pl.vddc_index = pi->sys_info.bootup_nb_voltage_index;\n\tpi->boot_pl.ds_divider_index = 0;\n\tpi->boot_pl.ss_divider_index = 0;\n\tpi->boot_pl.allow_gnb_slow = 1;\n\tpi->acpi_pl = pi->boot_pl;\n\tpi->current_ps.num_levels = 1;\n\tpi->current_ps.levels[0] = pi->boot_pl;\n}\n\nint sumo_dpm_init(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi;\n\tu32 hw_rev = (RREG32(HW_REV) & ATI_REV_ID_MASK) >> ATI_REV_ID_SHIFT;\n\tint ret;\n\n\tpi = kzalloc(sizeof(struct sumo_power_info), GFP_KERNEL);\n\tif (pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = pi;\n\n\tpi->driver_nbps_policy_disable = false;\n\tif ((rdev->family == CHIP_PALM) && (hw_rev < 3))\n\t\tpi->disable_gfx_power_gating_in_uvd = true;\n\telse\n\t\tpi->disable_gfx_power_gating_in_uvd = false;\n\tpi->enable_alt_vddnb = true;\n\tpi->enable_sclk_ds = true;\n\tpi->enable_dynamic_m3_arbiter = false;\n\tpi->enable_dynamic_patch_ps = true;\n\t \n\tif (rdev->family == CHIP_PALM)\n\t\tpi->enable_gfx_power_gating = false;\n\telse\n\t\tpi->enable_gfx_power_gating = true;\n\tpi->enable_gfx_clock_gating = true;\n\tpi->enable_mg_clock_gating = true;\n\tpi->enable_auto_thermal_throttling = true;\n\n\tret = sumo_parse_sys_info_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tsumo_construct_boot_and_acpi_state(rdev);\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sumo_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->pasi = CYPRESS_HASI_DFLT;\n\tpi->asi = RV770_ASI_DFLT;\n\tpi->thermal_auto_throttling = pi->sys_info.htc_tmp_lmt;\n\tpi->enable_boost = pi->sys_info.enable_boost;\n\tpi->enable_dpm = true;\n\n\treturn 0;\n}\n\nvoid sumo_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t\tstruct radeon_ps *rps)\n{\n\tint i;\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tstruct sumo_pl *pl = &ps->levels[i];\n\t\tprintk(\"\\t\\tpower level %d    sclk: %u vddc: %u\\n\",\n\t\t       i, pl->sclk,\n\t\t       sumo_convert_voltage_index_to_value(rdev, pl->vddc_index));\n\t}\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid sumo_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t      struct seq_file *m)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tstruct sumo_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_INDEX_MASK) >>\n\t\tCURR_INDEX_SHIFT;\n\n\tif (current_index == BOOST_DPM_LEVEL) {\n\t\tpl = &pi->boost_pl;\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tseq_printf(m, \"power level %d    sclk: %u vddc: %u\\n\",\n\t\t\t   current_index, pl->sclk,\n\t\t\t   sumo_convert_voltage_index_to_value(rdev, pl->vddc_index));\n\t} else if (current_index >= ps->num_levels) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tpl = &ps->levels[current_index];\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tseq_printf(m, \"power level %d    sclk: %u vddc: %u\\n\",\n\t\t\t   current_index, pl->sclk,\n\t\t\t   sumo_convert_voltage_index_to_value(rdev, pl->vddc_index));\n\t}\n}\n\nu32 sumo_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tstruct sumo_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_INDEX_MASK) >>\n\t\tCURR_INDEX_SHIFT;\n\n\tif (current_index == BOOST_DPM_LEVEL) {\n\t\tpl = &pi->boost_pl;\n\t\treturn pl->sclk;\n\t} else if (current_index >= ps->num_levels) {\n\t\treturn 0;\n\t} else {\n\t\tpl = &ps->levels[current_index];\n\t\treturn pl->sclk;\n\t}\n}\n\nu32 sumo_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\treturn pi->sys_info.bootup_uma_clk;\n}\n\nu16 sumo_dpm_get_current_vddc(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tstruct sumo_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_INDEX_MASK) >>\n\t\tCURR_INDEX_SHIFT;\n\n\tif (current_index == BOOST_DPM_LEVEL) {\n\t\tpl = &pi->boost_pl;\n\t} else if (current_index >= ps->num_levels) {\n\t\treturn 0;\n\t} else {\n\t\tpl = &ps->levels[current_index];\n\t}\n\treturn sumo_convert_voltage_index_to_value(rdev, pl->vddc_index);\n}\n\nvoid sumo_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tsumo_cleanup_asic(rdev);  \n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n}\n\nu32 sumo_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct sumo_ps *requested_state = sumo_get_ps(&pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->levels[0].sclk;\n\telse\n\t\treturn requested_state->levels[requested_state->num_levels - 1].sclk;\n}\n\nu32 sumo_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\n\treturn pi->sys_info.bootup_uma_clk;\n}\n\nint sumo_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t     enum radeon_dpm_forced_level level)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tstruct radeon_ps *rps = &pi->current_rps;\n\tstruct sumo_ps *ps = sumo_get_ps(rps);\n\tint i;\n\n\tif (ps->num_levels <= 1)\n\t\treturn 0;\n\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\tif (pi->enable_boost)\n\t\t\tsumo_enable_boost(rdev, rps, false);\n\t\tsumo_power_level_enable(rdev, ps->num_levels - 1, true);\n\t\tsumo_set_forced_level(rdev, ps->num_levels - 1);\n\t\tsumo_set_forced_mode_enabled(rdev);\n\t\tfor (i = 0; i < ps->num_levels - 1; i++) {\n\t\t\tsumo_power_level_enable(rdev, i, false);\n\t\t}\n\t\tsumo_set_forced_mode(rdev, false);\n\t\tsumo_set_forced_mode_enabled(rdev);\n\t\tsumo_set_forced_mode(rdev, false);\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tif (pi->enable_boost)\n\t\t\tsumo_enable_boost(rdev, rps, false);\n\t\tsumo_power_level_enable(rdev, 0, true);\n\t\tsumo_set_forced_level(rdev, 0);\n\t\tsumo_set_forced_mode_enabled(rdev);\n\t\tfor (i = 1; i < ps->num_levels; i++) {\n\t\t\tsumo_power_level_enable(rdev, i, false);\n\t\t}\n\t\tsumo_set_forced_mode(rdev, false);\n\t\tsumo_set_forced_mode_enabled(rdev);\n\t\tsumo_set_forced_mode(rdev, false);\n\t} else {\n\t\tfor (i = 0; i < ps->num_levels; i++) {\n\t\t\tsumo_power_level_enable(rdev, i, true);\n\t\t}\n\t\tif (pi->enable_boost)\n\t\t\tsumo_enable_boost(rdev, rps, true);\n\t}\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}