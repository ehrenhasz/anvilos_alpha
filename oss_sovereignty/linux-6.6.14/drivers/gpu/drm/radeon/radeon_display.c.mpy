{
  "module_name": "radeon_display.c",
  "hash_id": "e8fa208e333522058f0f253202669df1e8a2c24354143a96d45046d50bd23bdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_display.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/gcd.h>\n\n#include <asm/div64.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_kms.h\"\n\nstatic void avivo_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tu16 *r, *g, *b;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"%d\\n\", radeon_crtc->crtc_id);\n\tWREG32(AVIVO_DC_LUTA_CONTROL + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(AVIVO_DC_LUTA_BLACK_OFFSET_BLUE + radeon_crtc->crtc_offset, 0);\n\tWREG32(AVIVO_DC_LUTA_BLACK_OFFSET_GREEN + radeon_crtc->crtc_offset, 0);\n\tWREG32(AVIVO_DC_LUTA_BLACK_OFFSET_RED + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(AVIVO_DC_LUTA_WHITE_OFFSET_BLUE + radeon_crtc->crtc_offset, 0xffff);\n\tWREG32(AVIVO_DC_LUTA_WHITE_OFFSET_GREEN + radeon_crtc->crtc_offset, 0xffff);\n\tWREG32(AVIVO_DC_LUTA_WHITE_OFFSET_RED + radeon_crtc->crtc_offset, 0xffff);\n\n\tWREG32(AVIVO_DC_LUT_RW_SELECT, radeon_crtc->crtc_id);\n\tWREG32(AVIVO_DC_LUT_RW_MODE, 0);\n\tWREG32(AVIVO_DC_LUT_WRITE_EN_MASK, 0x0000003f);\n\n\tWREG8(AVIVO_DC_LUT_RW_INDEX, 0);\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\tfor (i = 0; i < 256; i++) {\n\t\tWREG32(AVIVO_DC_LUT_30_COLOR,\n\t\t       ((*r++ & 0xffc0) << 14) |\n\t\t       ((*g++ & 0xffc0) << 4) |\n\t\t       (*b++ >> 6));\n\t}\n\n\t \n\tWREG32_P(AVIVO_D1GRPH_LUT_SEL + radeon_crtc->crtc_offset, radeon_crtc->crtc_id, ~1);\n}\n\nstatic void dce4_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tu16 *r, *g, *b;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"%d\\n\", radeon_crtc->crtc_id);\n\tWREG32(EVERGREEN_DC_LUT_CONTROL + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_BLUE + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_GREEN + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_RED + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_BLUE + radeon_crtc->crtc_offset, 0xffff);\n\tWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_GREEN + radeon_crtc->crtc_offset, 0xffff);\n\tWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_RED + radeon_crtc->crtc_offset, 0xffff);\n\n\tWREG32(EVERGREEN_DC_LUT_RW_MODE + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_DC_LUT_WRITE_EN_MASK + radeon_crtc->crtc_offset, 0x00000007);\n\n\tWREG32(EVERGREEN_DC_LUT_RW_INDEX + radeon_crtc->crtc_offset, 0);\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\tfor (i = 0; i < 256; i++) {\n\t\tWREG32(EVERGREEN_DC_LUT_30_COLOR + radeon_crtc->crtc_offset,\n\t\t       ((*r++ & 0xffc0) << 14) |\n\t\t       ((*g++ & 0xffc0) << 4) |\n\t\t       (*b++ >> 6));\n\t}\n}\n\nstatic void dce5_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tu16 *r, *g, *b;\n\tint i;\n\n\tDRM_DEBUG_KMS(\"%d\\n\", radeon_crtc->crtc_id);\n\n\tmsleep(10);\n\n\tWREG32(NI_INPUT_CSC_CONTROL + radeon_crtc->crtc_offset,\n\t       (NI_INPUT_CSC_GRPH_MODE(NI_INPUT_CSC_BYPASS) |\n\t\tNI_INPUT_CSC_OVL_MODE(NI_INPUT_CSC_BYPASS)));\n\tWREG32(NI_PRESCALE_GRPH_CONTROL + radeon_crtc->crtc_offset,\n\t       NI_GRPH_PRESCALE_BYPASS);\n\tWREG32(NI_PRESCALE_OVL_CONTROL + radeon_crtc->crtc_offset,\n\t       NI_OVL_PRESCALE_BYPASS);\n\tWREG32(NI_INPUT_GAMMA_CONTROL + radeon_crtc->crtc_offset,\n\t       (NI_GRPH_INPUT_GAMMA_MODE(NI_INPUT_GAMMA_USE_LUT) |\n\t\tNI_OVL_INPUT_GAMMA_MODE(NI_INPUT_GAMMA_USE_LUT)));\n\n\tWREG32(EVERGREEN_DC_LUT_CONTROL + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_BLUE + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_GREEN + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_RED + radeon_crtc->crtc_offset, 0);\n\n\tWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_BLUE + radeon_crtc->crtc_offset, 0xffff);\n\tWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_GREEN + radeon_crtc->crtc_offset, 0xffff);\n\tWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_RED + radeon_crtc->crtc_offset, 0xffff);\n\n\tWREG32(EVERGREEN_DC_LUT_RW_MODE + radeon_crtc->crtc_offset, 0);\n\tWREG32(EVERGREEN_DC_LUT_WRITE_EN_MASK + radeon_crtc->crtc_offset, 0x00000007);\n\n\tWREG32(EVERGREEN_DC_LUT_RW_INDEX + radeon_crtc->crtc_offset, 0);\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\tfor (i = 0; i < 256; i++) {\n\t\tWREG32(EVERGREEN_DC_LUT_30_COLOR + radeon_crtc->crtc_offset,\n\t\t       ((*r++ & 0xffc0) << 14) |\n\t\t       ((*g++ & 0xffc0) << 4) |\n\t\t       (*b++ >> 6));\n\t}\n\n\tWREG32(NI_DEGAMMA_CONTROL + radeon_crtc->crtc_offset,\n\t       (NI_GRPH_DEGAMMA_MODE(NI_DEGAMMA_BYPASS) |\n\t\tNI_OVL_DEGAMMA_MODE(NI_DEGAMMA_BYPASS) |\n\t\tNI_ICON_DEGAMMA_MODE(NI_DEGAMMA_BYPASS) |\n\t\tNI_CURSOR_DEGAMMA_MODE(NI_DEGAMMA_BYPASS)));\n\tWREG32(NI_GAMUT_REMAP_CONTROL + radeon_crtc->crtc_offset,\n\t       (NI_GRPH_GAMUT_REMAP_MODE(NI_GAMUT_REMAP_BYPASS) |\n\t\tNI_OVL_GAMUT_REMAP_MODE(NI_GAMUT_REMAP_BYPASS)));\n\tWREG32(NI_REGAMMA_CONTROL + radeon_crtc->crtc_offset,\n\t       (NI_GRPH_REGAMMA_MODE(NI_REGAMMA_BYPASS) |\n\t\tNI_OVL_REGAMMA_MODE(NI_REGAMMA_BYPASS)));\n\tWREG32(NI_OUTPUT_CSC_CONTROL + radeon_crtc->crtc_offset,\n\t       (NI_OUTPUT_CSC_GRPH_MODE(radeon_crtc->output_csc) |\n\t\tNI_OUTPUT_CSC_OVL_MODE(NI_OUTPUT_CSC_BYPASS)));\n\t \n\tWREG32(0x6940 + radeon_crtc->crtc_offset, 0);\n\tif (ASIC_IS_DCE8(rdev)) {\n\t\t \n\t\tWREG32(CIK_ALPHA_CONTROL + radeon_crtc->crtc_offset,\n\t\t       CIK_CURSOR_ALPHA_BLND_ENA);\n\t}\n}\n\nstatic void legacy_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tu16 *r, *g, *b;\n\tint i;\n\tuint32_t dac2_cntl;\n\n\tdac2_cntl = RREG32(RADEON_DAC_CNTL2);\n\tif (radeon_crtc->crtc_id == 0)\n\t\tdac2_cntl &= (uint32_t)~RADEON_DAC2_PALETTE_ACC_CTL;\n\telse\n\t\tdac2_cntl |= RADEON_DAC2_PALETTE_ACC_CTL;\n\tWREG32(RADEON_DAC_CNTL2, dac2_cntl);\n\n\tWREG8(RADEON_PALETTE_INDEX, 0);\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\tfor (i = 0; i < 256; i++) {\n\t\tWREG32(RADEON_PALETTE_30_DATA,\n\t\t       ((*r++ & 0xffc0) << 14) |\n\t\t       ((*g++ & 0xffc0) << 4) |\n\t\t       (*b++ >> 6));\n\t}\n}\n\nvoid radeon_crtc_load_lut(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (!crtc->enabled)\n\t\treturn;\n\n\tif (ASIC_IS_DCE5(rdev))\n\t\tdce5_crtc_load_lut(crtc);\n\telse if (ASIC_IS_DCE4(rdev))\n\t\tdce4_crtc_load_lut(crtc);\n\telse if (ASIC_IS_AVIVO(rdev))\n\t\tavivo_crtc_load_lut(crtc);\n\telse\n\t\tlegacy_crtc_load_lut(crtc);\n}\n\nstatic int radeon_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\n\t\t\t\t u16 *blue, uint32_t size,\n\t\t\t\t struct drm_modeset_acquire_ctx *ctx)\n{\n\tradeon_crtc_load_lut(crtc);\n\n\treturn 0;\n}\n\nstatic void radeon_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\n\tdrm_crtc_cleanup(crtc);\n\tdestroy_workqueue(radeon_crtc->flip_queue);\n\tkfree(radeon_crtc);\n}\n\n \nstatic void radeon_unpin_work_func(struct work_struct *__work)\n{\n\tstruct radeon_flip_work *work =\n\t\tcontainer_of(__work, struct radeon_flip_work, unpin_work);\n\tint r;\n\n\t \n\tr = radeon_bo_reserve(work->old_rbo, false);\n\tif (likely(r == 0)) {\n\t\tradeon_bo_unpin(work->old_rbo);\n\t\tradeon_bo_unreserve(work->old_rbo);\n\t} else\n\t\tDRM_ERROR(\"failed to reserve buffer after flip\\n\");\n\n\tdrm_gem_object_put(&work->old_rbo->tbo.base);\n\tkfree(work);\n}\n\nvoid radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\tunsigned long flags;\n\tu32 update_pending;\n\tint vpos, hpos;\n\n\t \n\tif (radeon_crtc == NULL)\n\t\treturn;\n\n\t \n\tif ((radeon_use_pflipirq == 2) && ASIC_IS_DCE4(rdev))\n\t\treturn;\n\n\tspin_lock_irqsave(&rdev->ddev->event_lock, flags);\n\tif (radeon_crtc->flip_status != RADEON_FLIP_SUBMITTED) {\n\t\tDRM_DEBUG_DRIVER(\"radeon_crtc->flip_status = %d != \"\n\t\t\t\t \"RADEON_FLIP_SUBMITTED(%d)\\n\",\n\t\t\t\t radeon_crtc->flip_status,\n\t\t\t\t RADEON_FLIP_SUBMITTED);\n\t\tspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\n\t\treturn;\n\t}\n\n\tupdate_pending = radeon_page_flip_pending(rdev, crtc_id);\n\n\t \n\tif (update_pending &&\n\t    (DRM_SCANOUTPOS_VALID &\n\t     radeon_get_crtc_scanoutpos(rdev->ddev, crtc_id,\n\t\t\t\t\tGET_DISTANCE_TO_VBLANKSTART,\n\t\t\t\t\t&vpos, &hpos, NULL, NULL,\n\t\t\t\t\t&rdev->mode_info.crtcs[crtc_id]->base.hwmode)) &&\n\t    ((vpos >= 0 && hpos < 0) || (hpos >= 0 && !ASIC_IS_AVIVO(rdev)))) {\n\t\t \n\t\tupdate_pending = 0;\n\t}\n\tspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\n\tif (!update_pending)\n\t\tradeon_crtc_handle_flip(rdev, crtc_id);\n}\n\n \nvoid radeon_crtc_handle_flip(struct radeon_device *rdev, int crtc_id)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\tstruct radeon_flip_work *work;\n\tunsigned long flags;\n\n\t \n\tif (radeon_crtc == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rdev->ddev->event_lock, flags);\n\twork = radeon_crtc->flip_work;\n\tif (radeon_crtc->flip_status != RADEON_FLIP_SUBMITTED) {\n\t\tDRM_DEBUG_DRIVER(\"radeon_crtc->flip_status = %d != \"\n\t\t\t\t \"RADEON_FLIP_SUBMITTED(%d)\\n\",\n\t\t\t\t radeon_crtc->flip_status,\n\t\t\t\t RADEON_FLIP_SUBMITTED);\n\t\tspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tradeon_crtc->flip_status = RADEON_FLIP_NONE;\n\tradeon_crtc->flip_work = NULL;\n\n\t \n\tif (work->event)\n\t\tdrm_crtc_send_vblank_event(&radeon_crtc->base, work->event);\n\n\tspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\n\n\tdrm_crtc_vblank_put(&radeon_crtc->base);\n\tradeon_irq_kms_pflip_irq_put(rdev, work->crtc_id);\n\tqueue_work(radeon_crtc->flip_queue, &work->unpin_work);\n}\n\n \nstatic void radeon_flip_work_func(struct work_struct *__work)\n{\n\tstruct radeon_flip_work *work =\n\t\tcontainer_of(__work, struct radeon_flip_work, flip_work);\n\tstruct radeon_device *rdev = work->rdev;\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[work->crtc_id];\n\n\tstruct drm_crtc *crtc = &radeon_crtc->base;\n\tunsigned long flags;\n\tint r;\n\tint vpos, hpos;\n\n\tdown_read(&rdev->exclusive_lock);\n\tif (work->fence) {\n\t\tstruct radeon_fence *fence;\n\n\t\tfence = to_radeon_fence(work->fence);\n\t\tif (fence && fence->rdev == rdev) {\n\t\t\tr = radeon_fence_wait(fence, false);\n\t\t\tif (r == -EDEADLK) {\n\t\t\t\tup_read(&rdev->exclusive_lock);\n\t\t\t\tdo {\n\t\t\t\t\tr = radeon_gpu_reset(rdev);\n\t\t\t\t} while (r == -EAGAIN);\n\t\t\t\tdown_read(&rdev->exclusive_lock);\n\t\t\t}\n\t\t} else\n\t\t\tr = dma_fence_wait(work->fence, false);\n\n\t\tif (r)\n\t\t\tDRM_ERROR(\"failed to wait on page flip fence (%d)!\\n\", r);\n\n\t\t \n\n\t\tdma_fence_put(work->fence);\n\t\twork->fence = NULL;\n\t}\n\n\t \n\twhile (radeon_crtc->enabled &&\n\t\t(radeon_get_crtc_scanoutpos(dev, work->crtc_id, 0,\n\t\t\t\t\t    &vpos, &hpos, NULL, NULL,\n\t\t\t\t\t    &crtc->hwmode)\n\t\t& (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_IN_VBLANK)) ==\n\t\t(DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_IN_VBLANK) &&\n\t\t(!ASIC_IS_AVIVO(rdev) ||\n\t\t((int) (work->target_vblank -\n\t\tcrtc->funcs->get_vblank_counter(crtc)) > 0)))\n\t\tusleep_range(1000, 2000);\n\n\t \n\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\n\t \n\tradeon_irq_kms_pflip_irq_get(rdev, radeon_crtc->crtc_id);\n\n\t \n\tradeon_page_flip(rdev, radeon_crtc->crtc_id, work->base, work->async);\n\n\tradeon_crtc->flip_status = RADEON_FLIP_SUBMITTED;\n\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\tup_read(&rdev->exclusive_lock);\n}\n\nstatic int radeon_crtc_page_flip_target(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_framebuffer *fb,\n\t\t\t\t\tstruct drm_pending_vblank_event *event,\n\t\t\t\t\tuint32_t page_flip_flags,\n\t\t\t\t\tuint32_t target,\n\t\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct drm_gem_object *obj;\n\tstruct radeon_flip_work *work;\n\tstruct radeon_bo *new_rbo;\n\tuint32_t tiling_flags, pitch_pixels;\n\tuint64_t base;\n\tunsigned long flags;\n\tint r;\n\n\twork = kzalloc(sizeof *work, GFP_KERNEL);\n\tif (work == NULL)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&work->flip_work, radeon_flip_work_func);\n\tINIT_WORK(&work->unpin_work, radeon_unpin_work_func);\n\n\twork->rdev = rdev;\n\twork->crtc_id = radeon_crtc->crtc_id;\n\twork->event = event;\n\twork->async = (page_flip_flags & DRM_MODE_PAGE_FLIP_ASYNC) != 0;\n\n\t \n\tobj = crtc->primary->fb->obj[0];\n\n\t \n\tdrm_gem_object_get(obj);\n\twork->old_rbo = gem_to_radeon_bo(obj);\n\n\tobj = fb->obj[0];\n\tnew_rbo = gem_to_radeon_bo(obj);\n\n\t \n\tDRM_DEBUG_DRIVER(\"flip-ioctl() cur_rbo = %p, new_rbo = %p\\n\",\n\t\t\t work->old_rbo, new_rbo);\n\n\tr = radeon_bo_reserve(new_rbo, false);\n\tif (unlikely(r != 0)) {\n\t\tDRM_ERROR(\"failed to reserve new rbo buffer before flip\\n\");\n\t\tgoto cleanup;\n\t}\n\t \n\tr = radeon_bo_pin_restricted(new_rbo, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t     ASIC_IS_AVIVO(rdev) ? 0 : 1 << 27, &base);\n\tif (unlikely(r != 0)) {\n\t\tradeon_bo_unreserve(new_rbo);\n\t\tr = -EINVAL;\n\t\tDRM_ERROR(\"failed to pin new rbo buffer before flip\\n\");\n\t\tgoto cleanup;\n\t}\n\tr = dma_resv_get_singleton(new_rbo->tbo.base.resv, DMA_RESV_USAGE_WRITE,\n\t\t\t\t   &work->fence);\n\tif (r) {\n\t\tradeon_bo_unreserve(new_rbo);\n\t\tDRM_ERROR(\"failed to get new rbo buffer fences\\n\");\n\t\tgoto cleanup;\n\t}\n\tradeon_bo_get_tiling_flags(new_rbo, &tiling_flags, NULL);\n\tradeon_bo_unreserve(new_rbo);\n\n\tif (!ASIC_IS_AVIVO(rdev)) {\n\t\t \n\t\tbase -= radeon_crtc->legacy_display_base_addr;\n\t\tpitch_pixels = fb->pitches[0] / fb->format->cpp[0];\n\n\t\tif (tiling_flags & RADEON_TILING_MACRO) {\n\t\t\tif (ASIC_IS_R300(rdev)) {\n\t\t\t\tbase &= ~0x7ff;\n\t\t\t} else {\n\t\t\t\tint byteshift = fb->format->cpp[0] * 8 >> 4;\n\t\t\t\tint tile_addr = (((crtc->y >> 3) * pitch_pixels +  crtc->x) >> (8 - byteshift)) << 11;\n\t\t\t\tbase += tile_addr + ((crtc->x << byteshift) % 256) + ((crtc->y % 8) << 8);\n\t\t\t}\n\t\t} else {\n\t\t\tint offset = crtc->y * pitch_pixels + crtc->x;\n\t\t\tswitch (fb->format->cpp[0] * 8) {\n\t\t\tcase 8:\n\t\t\tdefault:\n\t\t\t\toffset *= 1;\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\tcase 16:\n\t\t\t\toffset *= 2;\n\t\t\t\tbreak;\n\t\t\tcase 24:\n\t\t\t\toffset *= 3;\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\t\toffset *= 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbase += offset;\n\t\t}\n\t\tbase &= ~7;\n\t}\n\twork->base = base;\n\twork->target_vblank = target - (uint32_t)drm_crtc_vblank_count(crtc) +\n\t\tcrtc->funcs->get_vblank_counter(crtc);\n\n\t \n\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\n\tif (radeon_crtc->flip_status != RADEON_FLIP_NONE) {\n\t\tDRM_DEBUG_DRIVER(\"flip queue: crtc already busy\\n\");\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\t\tr = -EBUSY;\n\t\tgoto pflip_cleanup;\n\t}\n\tradeon_crtc->flip_status = RADEON_FLIP_PENDING;\n\tradeon_crtc->flip_work = work;\n\n\t \n\tcrtc->primary->fb = fb;\n\n\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\n\tqueue_work(radeon_crtc->flip_queue, &work->flip_work);\n\treturn 0;\n\npflip_cleanup:\n\tif (unlikely(radeon_bo_reserve(new_rbo, false) != 0)) {\n\t\tDRM_ERROR(\"failed to reserve new rbo in error path\\n\");\n\t\tgoto cleanup;\n\t}\n\tradeon_bo_unpin(new_rbo);\n\tradeon_bo_unreserve(new_rbo);\n\ncleanup:\n\tdrm_gem_object_put(&work->old_rbo->tbo.base);\n\tdma_fence_put(work->fence);\n\tkfree(work);\n\treturn r;\n}\n\nstatic int\nradeon_crtc_set_config(struct drm_mode_set *set,\n\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev;\n\tstruct radeon_device *rdev;\n\tstruct drm_crtc *crtc;\n\tbool active = false;\n\tint ret;\n\n\tif (!set || !set->crtc)\n\t\treturn -EINVAL;\n\n\tdev = set->crtc->dev;\n\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn ret;\n\t}\n\n\tret = drm_crtc_helper_set_config(set, ctx);\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\n\t\tif (crtc->enabled)\n\t\t\tactive = true;\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\n\trdev = dev->dev_private;\n\t \n\tif (active && !rdev->have_disp_power_ref) {\n\t\trdev->have_disp_power_ref = true;\n\t\treturn ret;\n\t}\n\t \n\tif (!active && rdev->have_disp_power_ref) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\trdev->have_disp_power_ref = false;\n\t}\n\n\t \n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn ret;\n}\n\nstatic const struct drm_crtc_funcs radeon_crtc_funcs = {\n\t.cursor_set2 = radeon_crtc_cursor_set2,\n\t.cursor_move = radeon_crtc_cursor_move,\n\t.gamma_set = radeon_crtc_gamma_set,\n\t.set_config = radeon_crtc_set_config,\n\t.destroy = radeon_crtc_destroy,\n\t.page_flip_target = radeon_crtc_page_flip_target,\n\t.get_vblank_counter = radeon_get_vblank_counter_kms,\n\t.enable_vblank = radeon_enable_vblank_kms,\n\t.disable_vblank = radeon_disable_vblank_kms,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n};\n\nstatic void radeon_crtc_init(struct drm_device *dev, int index)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc;\n\n\tradeon_crtc = kzalloc(sizeof(struct radeon_crtc) + (RADEONFB_CONN_LIMIT * sizeof(struct drm_connector *)), GFP_KERNEL);\n\tif (radeon_crtc == NULL)\n\t\treturn;\n\n\tradeon_crtc->flip_queue = alloc_workqueue(\"radeon-crtc\", WQ_HIGHPRI, 0);\n\tif (!radeon_crtc->flip_queue) {\n\t\tkfree(radeon_crtc);\n\t\treturn;\n\t}\n\n\tdrm_crtc_init(dev, &radeon_crtc->base, &radeon_crtc_funcs);\n\n\tdrm_mode_crtc_set_gamma_size(&radeon_crtc->base, 256);\n\tradeon_crtc->crtc_id = index;\n\trdev->mode_info.crtcs[index] = radeon_crtc;\n\n\tif (rdev->family >= CHIP_BONAIRE) {\n\t\tradeon_crtc->max_cursor_width = CIK_CURSOR_WIDTH;\n\t\tradeon_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;\n\t} else {\n\t\tradeon_crtc->max_cursor_width = CURSOR_WIDTH;\n\t\tradeon_crtc->max_cursor_height = CURSOR_HEIGHT;\n\t}\n\tdev->mode_config.cursor_width = radeon_crtc->max_cursor_width;\n\tdev->mode_config.cursor_height = radeon_crtc->max_cursor_height;\n\n#if 0\n\tradeon_crtc->mode_set.crtc = &radeon_crtc->base;\n\tradeon_crtc->mode_set.connectors = (struct drm_connector **)(radeon_crtc + 1);\n\tradeon_crtc->mode_set.num_connectors = 0;\n#endif\n\n\tif (rdev->is_atom_bios && (ASIC_IS_AVIVO(rdev) || radeon_r4xx_atom))\n\t\tradeon_atombios_init_crtc(dev, radeon_crtc);\n\telse\n\t\tradeon_legacy_init_crtc(dev, radeon_crtc);\n}\n\nstatic const char *encoder_names[38] = {\n\t\"NONE\",\n\t\"INTERNAL_LVDS\",\n\t\"INTERNAL_TMDS1\",\n\t\"INTERNAL_TMDS2\",\n\t\"INTERNAL_DAC1\",\n\t\"INTERNAL_DAC2\",\n\t\"INTERNAL_SDVOA\",\n\t\"INTERNAL_SDVOB\",\n\t\"SI170B\",\n\t\"CH7303\",\n\t\"CH7301\",\n\t\"INTERNAL_DVO1\",\n\t\"EXTERNAL_SDVOA\",\n\t\"EXTERNAL_SDVOB\",\n\t\"TITFP513\",\n\t\"INTERNAL_LVTM1\",\n\t\"VT1623\",\n\t\"HDMI_SI1930\",\n\t\"HDMI_INTERNAL\",\n\t\"INTERNAL_KLDSCP_TMDS1\",\n\t\"INTERNAL_KLDSCP_DVO1\",\n\t\"INTERNAL_KLDSCP_DAC1\",\n\t\"INTERNAL_KLDSCP_DAC2\",\n\t\"SI178\",\n\t\"MVPU_FPGA\",\n\t\"INTERNAL_DDI\",\n\t\"VT1625\",\n\t\"HDMI_SI1932\",\n\t\"DP_AN9801\",\n\t\"DP_DP501\",\n\t\"INTERNAL_UNIPHY\",\n\t\"INTERNAL_KLDSCP_LVTMA\",\n\t\"INTERNAL_UNIPHY1\",\n\t\"INTERNAL_UNIPHY2\",\n\t\"NUTMEG\",\n\t\"TRAVIS\",\n\t\"INTERNAL_VCE\",\n\t\"INTERNAL_UNIPHY3\",\n};\n\nstatic const char *hpd_names[6] = {\n\t\"HPD1\",\n\t\"HPD2\",\n\t\"HPD3\",\n\t\"HPD4\",\n\t\"HPD5\",\n\t\"HPD6\",\n};\n\nstatic void radeon_print_display_setup(struct drm_device *dev)\n{\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\tuint32_t devices;\n\tint i = 0;\n\n\tDRM_INFO(\"Radeon Display Connectors\\n\");\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tDRM_INFO(\"Connector %d:\\n\", i);\n\t\tDRM_INFO(\"  %s\\n\", connector->name);\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tDRM_INFO(\"  %s\\n\", hpd_names[radeon_connector->hpd.hpd]);\n\t\tif (radeon_connector->ddc_bus) {\n\t\t\tDRM_INFO(\"  DDC: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\t radeon_connector->ddc_bus->rec.mask_clk_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.mask_data_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.a_clk_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.a_data_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.en_clk_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.en_data_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.y_clk_reg,\n\t\t\t\t radeon_connector->ddc_bus->rec.y_data_reg);\n\t\t\tif (radeon_connector->router.ddc_valid)\n\t\t\t\tDRM_INFO(\"  DDC Router 0x%x/0x%x\\n\",\n\t\t\t\t\t radeon_connector->router.ddc_mux_control_pin,\n\t\t\t\t\t radeon_connector->router.ddc_mux_state);\n\t\t\tif (radeon_connector->router.cd_valid)\n\t\t\t\tDRM_INFO(\"  Clock/Data Router 0x%x/0x%x\\n\",\n\t\t\t\t\t radeon_connector->router.cd_mux_control_pin,\n\t\t\t\t\t radeon_connector->router.cd_mux_state);\n\t\t} else {\n\t\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_VGA ||\n\t\t\t    connector->connector_type == DRM_MODE_CONNECTOR_DVII ||\n\t\t\t    connector->connector_type == DRM_MODE_CONNECTOR_DVID ||\n\t\t\t    connector->connector_type == DRM_MODE_CONNECTOR_DVIA ||\n\t\t\t    connector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||\n\t\t\t    connector->connector_type == DRM_MODE_CONNECTOR_HDMIB)\n\t\t\t\tDRM_INFO(\"  DDC: no ddc bus - possible BIOS bug - please report to xorg-driver-ati@lists.x.org\\n\");\n\t\t}\n\t\tDRM_INFO(\"  Encoders:\\n\");\n\t\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\t\tdevices = radeon_encoder->devices & radeon_connector->devices;\n\t\t\tif (devices) {\n\t\t\t\tif (devices & ATOM_DEVICE_CRT1_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    CRT1: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_CRT2_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    CRT2: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_LCD1_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    LCD1: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_DFP1_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    DFP1: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_DFP2_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    DFP2: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_DFP3_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    DFP3: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_DFP4_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    DFP4: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_DFP5_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    DFP5: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_DFP6_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    DFP6: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_TV1_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    TV1: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t\tif (devices & ATOM_DEVICE_CV_SUPPORT)\n\t\t\t\t\tDRM_INFO(\"    CV: %s\\n\", encoder_names[radeon_encoder->encoder_id]);\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n}\n\nstatic bool radeon_setup_enc_conn(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tbool ret = false;\n\n\tif (rdev->bios) {\n\t\tif (rdev->is_atom_bios) {\n\t\t\tret = radeon_get_atom_connector_info_from_supported_devices_table(dev);\n\t\t\tif (!ret)\n\t\t\t\tret = radeon_get_atom_connector_info_from_object_table(dev);\n\t\t} else {\n\t\t\tret = radeon_get_legacy_connector_info_from_bios(dev);\n\t\t\tif (!ret)\n\t\t\t\tret = radeon_get_legacy_connector_info_from_table(dev);\n\t\t}\n\t} else {\n\t\tif (!ASIC_IS_AVIVO(rdev))\n\t\t\tret = radeon_get_legacy_connector_info_from_table(dev);\n\t}\n\tif (ret) {\n\t\tradeon_setup_encoder_clones(dev);\n\t\tradeon_print_display_setup(dev);\n\t}\n\n\treturn ret;\n}\n\n \n\n \nstatic void avivo_reduce_ratio(unsigned *nom, unsigned *den,\n\t\t\t       unsigned nom_min, unsigned den_min)\n{\n\tunsigned tmp;\n\n\t \n\ttmp = gcd(*nom, *den);\n\t*nom /= tmp;\n\t*den /= tmp;\n\n\t \n\tif (*nom < nom_min) {\n\t\ttmp = DIV_ROUND_UP(nom_min, *nom);\n\t\t*nom *= tmp;\n\t\t*den *= tmp;\n\t}\n\n\t \n\tif (*den < den_min) {\n\t\ttmp = DIV_ROUND_UP(den_min, *den);\n\t\t*nom *= tmp;\n\t\t*den *= tmp;\n\t}\n}\n\n \nstatic void avivo_get_fb_ref_div(unsigned nom, unsigned den, unsigned post_div,\n\t\t\t\t unsigned fb_div_max, unsigned ref_div_max,\n\t\t\t\t unsigned *fb_div, unsigned *ref_div)\n{\n\t \n\tref_div_max = max(min(100 / post_div, ref_div_max), 1u);\n\n\t \n\t*ref_div = min(max(den/post_div, 1u), ref_div_max);\n\t*fb_div = DIV_ROUND_CLOSEST(nom * *ref_div * post_div, den);\n\n\t \n\tif (*fb_div > fb_div_max) {\n\t\t*ref_div = (*ref_div * fb_div_max)/(*fb_div);\n\t\t*fb_div = fb_div_max;\n\t}\n}\n\n \nvoid radeon_compute_pll_avivo(struct radeon_pll *pll,\n\t\t\t      u32 freq,\n\t\t\t      u32 *dot_clock_p,\n\t\t\t      u32 *fb_div_p,\n\t\t\t      u32 *frac_fb_div_p,\n\t\t\t      u32 *ref_div_p,\n\t\t\t      u32 *post_div_p)\n{\n\tunsigned target_clock = pll->flags & RADEON_PLL_USE_FRAC_FB_DIV ?\n\t\tfreq : freq / 10;\n\n\tunsigned fb_div_min, fb_div_max, fb_div;\n\tunsigned post_div_min, post_div_max, post_div;\n\tunsigned ref_div_min, ref_div_max, ref_div;\n\tunsigned post_div_best, diff_best;\n\tunsigned nom, den;\n\n\t \n\tfb_div_min = pll->min_feedback_div;\n\tfb_div_max = pll->max_feedback_div;\n\n\tif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\n\t\tfb_div_min *= 10;\n\t\tfb_div_max *= 10;\n\t}\n\n\t \n\tif (pll->flags & RADEON_PLL_USE_REF_DIV)\n\t\tref_div_min = pll->reference_div;\n\telse\n\t\tref_div_min = pll->min_ref_div;\n\n\tif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV &&\n\t    pll->flags & RADEON_PLL_USE_REF_DIV)\n\t\tref_div_max = pll->reference_div;\n\telse if (pll->flags & RADEON_PLL_PREFER_MINM_OVER_MAXP)\n\t\t \n\t\tref_div_max = min(pll->max_ref_div, 7u);\n\telse\n\t\tref_div_max = pll->max_ref_div;\n\n\t \n\tif (pll->flags & RADEON_PLL_USE_POST_DIV) {\n\t\tpost_div_min = pll->post_div;\n\t\tpost_div_max = pll->post_div;\n\t} else {\n\t\tunsigned vco_min, vco_max;\n\n\t\tif (pll->flags & RADEON_PLL_IS_LCD) {\n\t\t\tvco_min = pll->lcd_pll_out_min;\n\t\t\tvco_max = pll->lcd_pll_out_max;\n\t\t} else {\n\t\t\tvco_min = pll->pll_out_min;\n\t\t\tvco_max = pll->pll_out_max;\n\t\t}\n\n\t\tif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\n\t\t\tvco_min *= 10;\n\t\t\tvco_max *= 10;\n\t\t}\n\n\t\tpost_div_min = vco_min / target_clock;\n\t\tif ((target_clock * post_div_min) < vco_min)\n\t\t\t++post_div_min;\n\t\tif (post_div_min < pll->min_post_div)\n\t\t\tpost_div_min = pll->min_post_div;\n\n\t\tpost_div_max = vco_max / target_clock;\n\t\tif ((target_clock * post_div_max) > vco_max)\n\t\t\t--post_div_max;\n\t\tif (post_div_max > pll->max_post_div)\n\t\t\tpost_div_max = pll->max_post_div;\n\t}\n\n\t \n\tnom = target_clock;\n\tden = pll->reference_freq;\n\n\t \n\tavivo_reduce_ratio(&nom, &den, fb_div_min, post_div_min);\n\n\t \n\tif (pll->flags & RADEON_PLL_PREFER_MINM_OVER_MAXP)\n\t\tpost_div_best = post_div_min;\n\telse\n\t\tpost_div_best = post_div_max;\n\tdiff_best = ~0;\n\n\tfor (post_div = post_div_min; post_div <= post_div_max; ++post_div) {\n\t\tunsigned diff;\n\t\tavivo_get_fb_ref_div(nom, den, post_div, fb_div_max,\n\t\t\t\t     ref_div_max, &fb_div, &ref_div);\n\t\tdiff = abs(target_clock - (pll->reference_freq * fb_div) /\n\t\t\t(ref_div * post_div));\n\n\t\tif (diff < diff_best || (diff == diff_best &&\n\t\t    !(pll->flags & RADEON_PLL_PREFER_MINM_OVER_MAXP))) {\n\n\t\t\tpost_div_best = post_div;\n\t\t\tdiff_best = diff;\n\t\t}\n\t}\n\tpost_div = post_div_best;\n\n\t \n\tavivo_get_fb_ref_div(nom, den, post_div, fb_div_max, ref_div_max,\n\t\t\t     &fb_div, &ref_div);\n\n\t \n\t \n\tavivo_reduce_ratio(&fb_div, &ref_div, fb_div_min, ref_div_min);\n\n\t \n\tif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV && (fb_div % 10)) {\n\t\tfb_div_min = max(fb_div_min, (9 - (fb_div % 10)) * 20 + 50);\n\t\tif (fb_div < fb_div_min) {\n\t\t\tunsigned tmp = DIV_ROUND_UP(fb_div_min, fb_div);\n\t\t\tfb_div *= tmp;\n\t\t\tref_div *= tmp;\n\t\t}\n\t}\n\n\t \n\tif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\n\t\t*fb_div_p = fb_div / 10;\n\t\t*frac_fb_div_p = fb_div % 10;\n\t} else {\n\t\t*fb_div_p = fb_div;\n\t\t*frac_fb_div_p = 0;\n\t}\n\n\t*dot_clock_p = ((pll->reference_freq * *fb_div_p * 10) +\n\t\t\t(pll->reference_freq * *frac_fb_div_p)) /\n\t\t       (ref_div * post_div * 10);\n\t*ref_div_p = ref_div;\n\t*post_div_p = post_div;\n\n\tDRM_DEBUG_KMS(\"%d - %d, pll dividers - fb: %d.%d ref: %d, post %d\\n\",\n\t\t      freq, *dot_clock_p * 10, *fb_div_p, *frac_fb_div_p,\n\t\t      ref_div, post_div);\n}\n\n \nstatic inline uint32_t radeon_div(uint64_t n, uint32_t d)\n{\n\tn += d / 2;\n\n\tdo_div(n, d);\n\treturn n;\n}\n\nvoid radeon_compute_pll_legacy(struct radeon_pll *pll,\n\t\t\t       uint64_t freq,\n\t\t\t       uint32_t *dot_clock_p,\n\t\t\t       uint32_t *fb_div_p,\n\t\t\t       uint32_t *frac_fb_div_p,\n\t\t\t       uint32_t *ref_div_p,\n\t\t\t       uint32_t *post_div_p)\n{\n\tuint32_t min_ref_div = pll->min_ref_div;\n\tuint32_t max_ref_div = pll->max_ref_div;\n\tuint32_t min_post_div = pll->min_post_div;\n\tuint32_t max_post_div = pll->max_post_div;\n\tuint32_t min_fractional_feed_div = 0;\n\tuint32_t max_fractional_feed_div = 0;\n\tuint32_t best_vco = pll->best_vco;\n\tuint32_t best_post_div = 1;\n\tuint32_t best_ref_div = 1;\n\tuint32_t best_feedback_div = 1;\n\tuint32_t best_frac_feedback_div = 0;\n\tuint32_t best_freq = -1;\n\tuint32_t best_error = 0xffffffff;\n\tuint32_t best_vco_diff = 1;\n\tuint32_t post_div;\n\tu32 pll_out_min, pll_out_max;\n\n\tDRM_DEBUG_KMS(\"PLL freq %llu %u %u\\n\", freq, pll->min_ref_div, pll->max_ref_div);\n\tfreq = freq * 1000;\n\n\tif (pll->flags & RADEON_PLL_IS_LCD) {\n\t\tpll_out_min = pll->lcd_pll_out_min;\n\t\tpll_out_max = pll->lcd_pll_out_max;\n\t} else {\n\t\tpll_out_min = pll->pll_out_min;\n\t\tpll_out_max = pll->pll_out_max;\n\t}\n\n\tif (pll_out_min > 64800)\n\t\tpll_out_min = 64800;\n\n\tif (pll->flags & RADEON_PLL_USE_REF_DIV)\n\t\tmin_ref_div = max_ref_div = pll->reference_div;\n\telse {\n\t\twhile (min_ref_div < max_ref_div-1) {\n\t\t\tuint32_t mid = (min_ref_div + max_ref_div) / 2;\n\t\t\tuint32_t pll_in = pll->reference_freq / mid;\n\t\t\tif (pll_in < pll->pll_in_min)\n\t\t\t\tmax_ref_div = mid;\n\t\t\telse if (pll_in > pll->pll_in_max)\n\t\t\t\tmin_ref_div = mid;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pll->flags & RADEON_PLL_USE_POST_DIV)\n\t\tmin_post_div = max_post_div = pll->post_div;\n\n\tif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\n\t\tmin_fractional_feed_div = pll->min_frac_feedback_div;\n\t\tmax_fractional_feed_div = pll->max_frac_feedback_div;\n\t}\n\n\tfor (post_div = max_post_div; post_div >= min_post_div; --post_div) {\n\t\tuint32_t ref_div;\n\n\t\tif ((pll->flags & RADEON_PLL_NO_ODD_POST_DIV) && (post_div & 1))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pll->flags & RADEON_PLL_LEGACY) {\n\t\t\tif ((post_div == 5) ||\n\t\t\t    (post_div == 7) ||\n\t\t\t    (post_div == 9) ||\n\t\t\t    (post_div == 10) ||\n\t\t\t    (post_div == 11) ||\n\t\t\t    (post_div == 13) ||\n\t\t\t    (post_div == 14) ||\n\t\t\t    (post_div == 15))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tfor (ref_div = min_ref_div; ref_div <= max_ref_div; ++ref_div) {\n\t\t\tuint32_t feedback_div, current_freq = 0, error, vco_diff;\n\t\t\tuint32_t pll_in = pll->reference_freq / ref_div;\n\t\t\tuint32_t min_feed_div = pll->min_feedback_div;\n\t\t\tuint32_t max_feed_div = pll->max_feedback_div + 1;\n\n\t\t\tif (pll_in < pll->pll_in_min || pll_in > pll->pll_in_max)\n\t\t\t\tcontinue;\n\n\t\t\twhile (min_feed_div < max_feed_div) {\n\t\t\t\tuint32_t vco;\n\t\t\t\tuint32_t min_frac_feed_div = min_fractional_feed_div;\n\t\t\t\tuint32_t max_frac_feed_div = max_fractional_feed_div + 1;\n\t\t\t\tuint32_t frac_feedback_div;\n\t\t\t\tuint64_t tmp;\n\n\t\t\t\tfeedback_div = (min_feed_div + max_feed_div) / 2;\n\n\t\t\t\ttmp = (uint64_t)pll->reference_freq * feedback_div;\n\t\t\t\tvco = radeon_div(tmp, ref_div);\n\n\t\t\t\tif (vco < pll_out_min) {\n\t\t\t\t\tmin_feed_div = feedback_div + 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (vco > pll_out_max) {\n\t\t\t\t\tmax_feed_div = feedback_div;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\twhile (min_frac_feed_div < max_frac_feed_div) {\n\t\t\t\t\tfrac_feedback_div = (min_frac_feed_div + max_frac_feed_div) / 2;\n\t\t\t\t\ttmp = (uint64_t)pll->reference_freq * 10000 * feedback_div;\n\t\t\t\t\ttmp += (uint64_t)pll->reference_freq * 1000 * frac_feedback_div;\n\t\t\t\t\tcurrent_freq = radeon_div(tmp, ref_div * post_div);\n\n\t\t\t\t\tif (pll->flags & RADEON_PLL_PREFER_CLOSEST_LOWER) {\n\t\t\t\t\t\tif (freq < current_freq)\n\t\t\t\t\t\t\terror = 0xffffffff;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\terror = freq - current_freq;\n\t\t\t\t\t} else\n\t\t\t\t\t\terror = abs(current_freq - freq);\n\t\t\t\t\tvco_diff = abs(vco - best_vco);\n\n\t\t\t\t\tif ((best_vco == 0 && error < best_error) ||\n\t\t\t\t\t    (best_vco != 0 &&\n\t\t\t\t\t     ((best_error > 100 && error < best_error - 100) ||\n\t\t\t\t\t      (abs(error - best_error) < 100 && vco_diff < best_vco_diff)))) {\n\t\t\t\t\t\tbest_post_div = post_div;\n\t\t\t\t\t\tbest_ref_div = ref_div;\n\t\t\t\t\t\tbest_feedback_div = feedback_div;\n\t\t\t\t\t\tbest_frac_feedback_div = frac_feedback_div;\n\t\t\t\t\t\tbest_freq = current_freq;\n\t\t\t\t\t\tbest_error = error;\n\t\t\t\t\t\tbest_vco_diff = vco_diff;\n\t\t\t\t\t} else if (current_freq == freq) {\n\t\t\t\t\t\tif (best_freq == -1) {\n\t\t\t\t\t\t\tbest_post_div = post_div;\n\t\t\t\t\t\t\tbest_ref_div = ref_div;\n\t\t\t\t\t\t\tbest_feedback_div = feedback_div;\n\t\t\t\t\t\t\tbest_frac_feedback_div = frac_feedback_div;\n\t\t\t\t\t\t\tbest_freq = current_freq;\n\t\t\t\t\t\t\tbest_error = error;\n\t\t\t\t\t\t\tbest_vco_diff = vco_diff;\n\t\t\t\t\t\t} else if (((pll->flags & RADEON_PLL_PREFER_LOW_REF_DIV) && (ref_div < best_ref_div)) ||\n\t\t\t\t\t\t\t   ((pll->flags & RADEON_PLL_PREFER_HIGH_REF_DIV) && (ref_div > best_ref_div)) ||\n\t\t\t\t\t\t\t   ((pll->flags & RADEON_PLL_PREFER_LOW_FB_DIV) && (feedback_div < best_feedback_div)) ||\n\t\t\t\t\t\t\t   ((pll->flags & RADEON_PLL_PREFER_HIGH_FB_DIV) && (feedback_div > best_feedback_div)) ||\n\t\t\t\t\t\t\t   ((pll->flags & RADEON_PLL_PREFER_LOW_POST_DIV) && (post_div < best_post_div)) ||\n\t\t\t\t\t\t\t   ((pll->flags & RADEON_PLL_PREFER_HIGH_POST_DIV) && (post_div > best_post_div))) {\n\t\t\t\t\t\t\tbest_post_div = post_div;\n\t\t\t\t\t\t\tbest_ref_div = ref_div;\n\t\t\t\t\t\t\tbest_feedback_div = feedback_div;\n\t\t\t\t\t\t\tbest_frac_feedback_div = frac_feedback_div;\n\t\t\t\t\t\t\tbest_freq = current_freq;\n\t\t\t\t\t\t\tbest_error = error;\n\t\t\t\t\t\t\tbest_vco_diff = vco_diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (current_freq < freq)\n\t\t\t\t\t\tmin_frac_feed_div = frac_feedback_div + 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmax_frac_feed_div = frac_feedback_div;\n\t\t\t\t}\n\t\t\t\tif (current_freq < freq)\n\t\t\t\t\tmin_feed_div = feedback_div + 1;\n\t\t\t\telse\n\t\t\t\t\tmax_feed_div = feedback_div;\n\t\t\t}\n\t\t}\n\t}\n\n\t*dot_clock_p = best_freq / 10000;\n\t*fb_div_p = best_feedback_div;\n\t*frac_fb_div_p = best_frac_feedback_div;\n\t*ref_div_p = best_ref_div;\n\t*post_div_p = best_post_div;\n\tDRM_DEBUG_KMS(\"%lld %d, pll dividers - fb: %d.%d ref: %d, post %d\\n\",\n\t\t      (long long)freq,\n\t\t      best_freq / 1000, best_feedback_div, best_frac_feedback_div,\n\t\t      best_ref_div, best_post_div);\n\n}\n\nstatic const struct drm_framebuffer_funcs radeon_fb_funcs = {\n\t.destroy = drm_gem_fb_destroy,\n\t.create_handle = drm_gem_fb_create_handle,\n};\n\nint\nradeon_framebuffer_init(struct drm_device *dev,\n\t\t\tstruct drm_framebuffer *fb,\n\t\t\tconst struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\tstruct drm_gem_object *obj)\n{\n\tint ret;\n\tfb->obj[0] = obj;\n\tdrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\n\tret = drm_framebuffer_init(dev, fb, &radeon_fb_funcs);\n\tif (ret) {\n\t\tfb->obj[0] = NULL;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic struct drm_framebuffer *\nradeon_user_framebuffer_create(struct drm_device *dev,\n\t\t\t       struct drm_file *file_priv,\n\t\t\t       const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_gem_object *obj;\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\n\tobj = drm_gem_object_lookup(file_priv, mode_cmd->handles[0]);\n\tif (obj ==  NULL) {\n\t\tdev_err(dev->dev, \"No GEM object associated to handle 0x%08X, \"\n\t\t\t\"can't create framebuffer\\n\", mode_cmd->handles[0]);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\t \n\tif (obj->import_attach) {\n\t\tDRM_DEBUG_KMS(\"Cannot create framebuffer from imported dma_buf\\n\");\n\t\tdrm_gem_object_put(obj);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (fb == NULL) {\n\t\tdrm_gem_object_put(obj);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tret = radeon_framebuffer_init(dev, fb, mode_cmd, obj);\n\tif (ret) {\n\t\tkfree(fb);\n\t\tdrm_gem_object_put(obj);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn fb;\n}\n\nstatic const struct drm_mode_config_funcs radeon_mode_funcs = {\n\t.fb_create = radeon_user_framebuffer_create,\n};\n\nstatic const struct drm_prop_enum_list radeon_tmds_pll_enum_list[] =\n{\t{ 0, \"driver\" },\n\t{ 1, \"bios\" },\n};\n\nstatic const struct drm_prop_enum_list radeon_tv_std_enum_list[] =\n{\t{ TV_STD_NTSC, \"ntsc\" },\n\t{ TV_STD_PAL, \"pal\" },\n\t{ TV_STD_PAL_M, \"pal-m\" },\n\t{ TV_STD_PAL_60, \"pal-60\" },\n\t{ TV_STD_NTSC_J, \"ntsc-j\" },\n\t{ TV_STD_SCART_PAL, \"scart-pal\" },\n\t{ TV_STD_PAL_CN, \"pal-cn\" },\n\t{ TV_STD_SECAM, \"secam\" },\n};\n\nstatic const struct drm_prop_enum_list radeon_underscan_enum_list[] =\n{\t{ UNDERSCAN_OFF, \"off\" },\n\t{ UNDERSCAN_ON, \"on\" },\n\t{ UNDERSCAN_AUTO, \"auto\" },\n};\n\nstatic const struct drm_prop_enum_list radeon_audio_enum_list[] =\n{\t{ RADEON_AUDIO_DISABLE, \"off\" },\n\t{ RADEON_AUDIO_ENABLE, \"on\" },\n\t{ RADEON_AUDIO_AUTO, \"auto\" },\n};\n\n \nstatic const struct drm_prop_enum_list radeon_dither_enum_list[] =\n{\t{ RADEON_FMT_DITHER_DISABLE, \"off\" },\n\t{ RADEON_FMT_DITHER_ENABLE, \"on\" },\n};\n\nstatic const struct drm_prop_enum_list radeon_output_csc_enum_list[] =\n{\t{ RADEON_OUTPUT_CSC_BYPASS, \"bypass\" },\n\t{ RADEON_OUTPUT_CSC_TVRGB, \"tvrgb\" },\n\t{ RADEON_OUTPUT_CSC_YCBCR601, \"ycbcr601\" },\n\t{ RADEON_OUTPUT_CSC_YCBCR709, \"ycbcr709\" },\n};\n\nstatic int radeon_modeset_create_props(struct radeon_device *rdev)\n{\n\tint sz;\n\n\tif (rdev->is_atom_bios) {\n\t\trdev->mode_info.coherent_mode_property =\n\t\t\tdrm_property_create_range(rdev->ddev, 0 , \"coherent\", 0, 1);\n\t\tif (!rdev->mode_info.coherent_mode_property)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!ASIC_IS_AVIVO(rdev)) {\n\t\tsz = ARRAY_SIZE(radeon_tmds_pll_enum_list);\n\t\trdev->mode_info.tmds_pll_property =\n\t\t\tdrm_property_create_enum(rdev->ddev, 0,\n\t\t\t\t\t    \"tmds_pll\",\n\t\t\t\t\t    radeon_tmds_pll_enum_list, sz);\n\t}\n\n\trdev->mode_info.load_detect_property =\n\t\tdrm_property_create_range(rdev->ddev, 0, \"load detection\", 0, 1);\n\tif (!rdev->mode_info.load_detect_property)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_create_scaling_mode_property(rdev->ddev);\n\n\tsz = ARRAY_SIZE(radeon_tv_std_enum_list);\n\trdev->mode_info.tv_std_property =\n\t\tdrm_property_create_enum(rdev->ddev, 0,\n\t\t\t\t    \"tv standard\",\n\t\t\t\t    radeon_tv_std_enum_list, sz);\n\n\tsz = ARRAY_SIZE(radeon_underscan_enum_list);\n\trdev->mode_info.underscan_property =\n\t\tdrm_property_create_enum(rdev->ddev, 0,\n\t\t\t\t    \"underscan\",\n\t\t\t\t    radeon_underscan_enum_list, sz);\n\n\trdev->mode_info.underscan_hborder_property =\n\t\tdrm_property_create_range(rdev->ddev, 0,\n\t\t\t\t\t\"underscan hborder\", 0, 128);\n\tif (!rdev->mode_info.underscan_hborder_property)\n\t\treturn -ENOMEM;\n\n\trdev->mode_info.underscan_vborder_property =\n\t\tdrm_property_create_range(rdev->ddev, 0,\n\t\t\t\t\t\"underscan vborder\", 0, 128);\n\tif (!rdev->mode_info.underscan_vborder_property)\n\t\treturn -ENOMEM;\n\n\tsz = ARRAY_SIZE(radeon_audio_enum_list);\n\trdev->mode_info.audio_property =\n\t\tdrm_property_create_enum(rdev->ddev, 0,\n\t\t\t\t\t \"audio\",\n\t\t\t\t\t radeon_audio_enum_list, sz);\n\n\tsz = ARRAY_SIZE(radeon_dither_enum_list);\n\trdev->mode_info.dither_property =\n\t\tdrm_property_create_enum(rdev->ddev, 0,\n\t\t\t\t\t \"dither\",\n\t\t\t\t\t radeon_dither_enum_list, sz);\n\n\tsz = ARRAY_SIZE(radeon_output_csc_enum_list);\n\trdev->mode_info.output_csc_property =\n\t\tdrm_property_create_enum(rdev->ddev, 0,\n\t\t\t\t\t \"output_csc\",\n\t\t\t\t\t radeon_output_csc_enum_list, sz);\n\n\treturn 0;\n}\n\nvoid radeon_update_display_priority(struct radeon_device *rdev)\n{\n\t \n\tif ((radeon_disp_priority == 0) || (radeon_disp_priority > 2)) {\n\t\t \n\t\tif ((ASIC_IS_R300(rdev) || (rdev->family == CHIP_RV515)) &&\n\t\t    !(rdev->flags & RADEON_IS_IGP))\n\t\t\trdev->disp_priority = 2;\n\t\telse\n\t\t\trdev->disp_priority = 0;\n\t} else\n\t\trdev->disp_priority = radeon_disp_priority;\n\n}\n\n \nstatic void radeon_afmt_init(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < RADEON_MAX_AFMT_BLOCKS; i++)\n\t\trdev->mode_info.afmt[i] = NULL;\n\n\tif (ASIC_IS_NODCE(rdev)) {\n\t\t \n\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\tstatic uint32_t eg_offsets[] = {\n\t\t\tEVERGREEN_CRTC0_REGISTER_OFFSET,\n\t\t\tEVERGREEN_CRTC1_REGISTER_OFFSET,\n\t\t\tEVERGREEN_CRTC2_REGISTER_OFFSET,\n\t\t\tEVERGREEN_CRTC3_REGISTER_OFFSET,\n\t\t\tEVERGREEN_CRTC4_REGISTER_OFFSET,\n\t\t\tEVERGREEN_CRTC5_REGISTER_OFFSET,\n\t\t\t0x13830 - 0x7030,\n\t\t};\n\t\tint num_afmt;\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (ASIC_IS_DCE8(rdev))\n\t\t\tnum_afmt = 7;\n\t\telse if (ASIC_IS_DCE6(rdev))\n\t\t\tnum_afmt = 6;\n\t\telse if (ASIC_IS_DCE5(rdev))\n\t\t\tnum_afmt = 6;\n\t\telse if (ASIC_IS_DCE41(rdev))\n\t\t\tnum_afmt = 2;\n\t\telse  \n\t\t\tnum_afmt = 6;\n\n\t\tBUG_ON(num_afmt > ARRAY_SIZE(eg_offsets));\n\t\tfor (i = 0; i < num_afmt; i++) {\n\t\t\trdev->mode_info.afmt[i] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\n\t\t\tif (rdev->mode_info.afmt[i]) {\n\t\t\t\trdev->mode_info.afmt[i]->offset = eg_offsets[i];\n\t\t\t\trdev->mode_info.afmt[i]->id = i;\n\t\t\t}\n\t\t}\n\t} else if (ASIC_IS_DCE3(rdev)) {\n\t\t \n\t\trdev->mode_info.afmt[0] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\n\t\tif (rdev->mode_info.afmt[0]) {\n\t\t\trdev->mode_info.afmt[0]->offset = DCE3_HDMI_OFFSET0;\n\t\t\trdev->mode_info.afmt[0]->id = 0;\n\t\t}\n\t\trdev->mode_info.afmt[1] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\n\t\tif (rdev->mode_info.afmt[1]) {\n\t\t\trdev->mode_info.afmt[1]->offset = DCE3_HDMI_OFFSET1;\n\t\t\trdev->mode_info.afmt[1]->id = 1;\n\t\t}\n\t} else if (ASIC_IS_DCE2(rdev)) {\n\t\t \n\t\trdev->mode_info.afmt[0] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\n\t\tif (rdev->mode_info.afmt[0]) {\n\t\t\trdev->mode_info.afmt[0]->offset = DCE2_HDMI_OFFSET0;\n\t\t\trdev->mode_info.afmt[0]->id = 0;\n\t\t}\n\t\t \n\t\tif (rdev->family >= CHIP_R600) {\n\t\t\trdev->mode_info.afmt[1] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\n\t\t\tif (rdev->mode_info.afmt[1]) {\n\t\t\t\trdev->mode_info.afmt[1]->offset = DCE2_HDMI_OFFSET1;\n\t\t\t\trdev->mode_info.afmt[1]->id = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void radeon_afmt_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < RADEON_MAX_AFMT_BLOCKS; i++) {\n\t\tkfree(rdev->mode_info.afmt[i]);\n\t\trdev->mode_info.afmt[i] = NULL;\n\t}\n}\n\nint radeon_modeset_init(struct radeon_device *rdev)\n{\n\tint i;\n\tint ret;\n\n\tdrm_mode_config_init(rdev->ddev);\n\trdev->mode_info.mode_config_initialized = true;\n\n\trdev->ddev->mode_config.funcs = &radeon_mode_funcs;\n\n\tif (radeon_use_pflipirq == 2 && rdev->family >= CHIP_R600)\n\t\trdev->ddev->mode_config.async_page_flip = true;\n\n\tif (ASIC_IS_DCE5(rdev)) {\n\t\trdev->ddev->mode_config.max_width = 16384;\n\t\trdev->ddev->mode_config.max_height = 16384;\n\t} else if (ASIC_IS_AVIVO(rdev)) {\n\t\trdev->ddev->mode_config.max_width = 8192;\n\t\trdev->ddev->mode_config.max_height = 8192;\n\t} else {\n\t\trdev->ddev->mode_config.max_width = 4096;\n\t\trdev->ddev->mode_config.max_height = 4096;\n\t}\n\n\trdev->ddev->mode_config.preferred_depth = 24;\n\trdev->ddev->mode_config.prefer_shadow = 1;\n\n\trdev->ddev->mode_config.fb_modifiers_not_supported = true;\n\n\tret = radeon_modeset_create_props(rdev);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\t \n\tradeon_i2c_init(rdev);\n\n\t \n\tif (!rdev->is_atom_bios) {\n\t\t \n\t\tradeon_combios_check_hardcoded_edid(rdev);\n\t}\n\n\t \n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tradeon_crtc_init(rdev->ddev, i);\n\t}\n\n\t \n\tret = radeon_setup_enc_conn(rdev->ddev);\n\tif (!ret) {\n\t\treturn ret;\n\t}\n\n\t \n\tif (rdev->is_atom_bios) {\n\t\tradeon_atom_encoder_init(rdev);\n\t\tradeon_atom_disp_eng_pll_init(rdev);\n\t}\n\n\t \n\tradeon_hpd_init(rdev);\n\n\t \n\tradeon_afmt_init(rdev);\n\n\tdrm_kms_helper_poll_init(rdev->ddev);\n\n\t \n\tret = radeon_pm_late_init(rdev);\n\n\treturn 0;\n}\n\nvoid radeon_modeset_fini(struct radeon_device *rdev)\n{\n\tif (rdev->mode_info.mode_config_initialized) {\n\t\tdrm_kms_helper_poll_fini(rdev->ddev);\n\t\tradeon_hpd_fini(rdev);\n\t\tdrm_helper_force_disable_all(rdev->ddev);\n\t\tradeon_afmt_fini(rdev);\n\t\tdrm_mode_config_cleanup(rdev->ddev);\n\t\trdev->mode_info.mode_config_initialized = false;\n\t}\n\n\tkfree(rdev->mode_info.bios_hardcoded_edid);\n\n\t \n\tradeon_i2c_fini(rdev);\n}\n\nstatic bool is_hdtv_mode(const struct drm_display_mode *mode)\n{\n\t \n\tif ((mode->vdisplay == 480 && mode->hdisplay == 720) ||  \n\t    (mode->vdisplay == 576) ||  \n\t    (mode->vdisplay == 720) ||  \n\t    (mode->vdisplay == 1080))  \n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nbool radeon_crtc_scaling_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct drm_connector *connector;\n\tbool first = true;\n\tu32 src_v = 1, dst_v = 1;\n\tu32 src_h = 1, dst_h = 1;\n\n\tradeon_crtc->h_border = 0;\n\tradeon_crtc->v_border = 0;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\tconnector = radeon_get_connector_for_encoder(encoder);\n\n\t\tif (first) {\n\t\t\t \n\t\t\tif (radeon_encoder->rmx_type == RMX_OFF)\n\t\t\t\tradeon_crtc->rmx_type = RMX_OFF;\n\t\t\telse if (mode->hdisplay < radeon_encoder->native_mode.hdisplay ||\n\t\t\t\t mode->vdisplay < radeon_encoder->native_mode.vdisplay)\n\t\t\t\tradeon_crtc->rmx_type = radeon_encoder->rmx_type;\n\t\t\telse\n\t\t\t\tradeon_crtc->rmx_type = RMX_OFF;\n\t\t\t \n\t\t\tmemcpy(&radeon_crtc->native_mode,\n\t\t\t       &radeon_encoder->native_mode,\n\t\t\t\tsizeof(struct drm_display_mode));\n\t\t\tsrc_v = crtc->mode.vdisplay;\n\t\t\tdst_v = radeon_crtc->native_mode.vdisplay;\n\t\t\tsrc_h = crtc->mode.hdisplay;\n\t\t\tdst_h = radeon_crtc->native_mode.hdisplay;\n\n\t\t\t \n\t\t\tif (ASIC_IS_AVIVO(rdev) &&\n\t\t\t    (!(mode->flags & DRM_MODE_FLAG_INTERLACE)) &&\n\t\t\t    ((radeon_encoder->underscan_type == UNDERSCAN_ON) ||\n\t\t\t     ((radeon_encoder->underscan_type == UNDERSCAN_AUTO) &&\n\t\t\t      drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\n\t\t\t      is_hdtv_mode(mode)))) {\n\t\t\t\tif (radeon_encoder->underscan_hborder != 0)\n\t\t\t\t\tradeon_crtc->h_border = radeon_encoder->underscan_hborder;\n\t\t\t\telse\n\t\t\t\t\tradeon_crtc->h_border = (mode->hdisplay >> 5) + 16;\n\t\t\t\tif (radeon_encoder->underscan_vborder != 0)\n\t\t\t\t\tradeon_crtc->v_border = radeon_encoder->underscan_vborder;\n\t\t\t\telse\n\t\t\t\t\tradeon_crtc->v_border = (mode->vdisplay >> 5) + 16;\n\t\t\t\tradeon_crtc->rmx_type = RMX_FULL;\n\t\t\t\tsrc_v = crtc->mode.vdisplay;\n\t\t\t\tdst_v = crtc->mode.vdisplay - (radeon_crtc->v_border * 2);\n\t\t\t\tsrc_h = crtc->mode.hdisplay;\n\t\t\t\tdst_h = crtc->mode.hdisplay - (radeon_crtc->h_border * 2);\n\t\t\t}\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tif (radeon_crtc->rmx_type != radeon_encoder->rmx_type) {\n\t\t\t\t \n\t\t\t\tDRM_ERROR(\"Scaling not consistent across encoder.\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tif (radeon_crtc->rmx_type != RMX_OFF) {\n\t\tfixed20_12 a, b;\n\t\ta.full = dfixed_const(src_v);\n\t\tb.full = dfixed_const(dst_v);\n\t\tradeon_crtc->vsc.full = dfixed_div(a, b);\n\t\ta.full = dfixed_const(src_h);\n\t\tb.full = dfixed_const(dst_h);\n\t\tradeon_crtc->hsc.full = dfixed_div(a, b);\n\t} else {\n\t\tradeon_crtc->vsc.full = dfixed_const(1);\n\t\tradeon_crtc->hsc.full = dfixed_const(1);\n\t}\n\treturn true;\n}\n\n \nint radeon_get_crtc_scanoutpos(struct drm_device *dev, unsigned int pipe,\n\t\t\t       unsigned int flags, int *vpos, int *hpos,\n\t\t\t       ktime_t *stime, ktime_t *etime,\n\t\t\t       const struct drm_display_mode *mode)\n{\n\tu32 stat_crtc = 0, vbl = 0, position = 0;\n\tint vbl_start, vbl_end, vtotal, ret = 0;\n\tbool in_vbl = true;\n\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\t \n\n\t \n\tif (stime)\n\t\t*stime = ktime_get();\n\n\tif (ASIC_IS_DCE4(rdev)) {\n\t\tif (pipe == 0) {\n\t\t\tvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\n\t\t\t\t     EVERGREEN_CRTC0_REGISTER_OFFSET);\n\t\t\tposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\n\t\t\t\t\t  EVERGREEN_CRTC0_REGISTER_OFFSET);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 1) {\n\t\t\tvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\n\t\t\t\t     EVERGREEN_CRTC1_REGISTER_OFFSET);\n\t\t\tposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\n\t\t\t\t\t  EVERGREEN_CRTC1_REGISTER_OFFSET);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 2) {\n\t\t\tvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\n\t\t\t\t     EVERGREEN_CRTC2_REGISTER_OFFSET);\n\t\t\tposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\n\t\t\t\t\t  EVERGREEN_CRTC2_REGISTER_OFFSET);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 3) {\n\t\t\tvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\n\t\t\t\t     EVERGREEN_CRTC3_REGISTER_OFFSET);\n\t\t\tposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\n\t\t\t\t\t  EVERGREEN_CRTC3_REGISTER_OFFSET);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 4) {\n\t\t\tvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\n\t\t\t\t     EVERGREEN_CRTC4_REGISTER_OFFSET);\n\t\t\tposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\n\t\t\t\t\t  EVERGREEN_CRTC4_REGISTER_OFFSET);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 5) {\n\t\t\tvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\n\t\t\t\t     EVERGREEN_CRTC5_REGISTER_OFFSET);\n\t\t\tposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\n\t\t\t\t\t  EVERGREEN_CRTC5_REGISTER_OFFSET);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t} else if (ASIC_IS_AVIVO(rdev)) {\n\t\tif (pipe == 0) {\n\t\t\tvbl = RREG32(AVIVO_D1CRTC_V_BLANK_START_END);\n\t\t\tposition = RREG32(AVIVO_D1CRTC_STATUS_POSITION);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 1) {\n\t\t\tvbl = RREG32(AVIVO_D2CRTC_V_BLANK_START_END);\n\t\t\tposition = RREG32(AVIVO_D2CRTC_STATUS_POSITION);\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t} else {\n\t\t \n\t\tif (pipe == 0) {\n\t\t\t \n\t\t\tvbl = (RREG32(RADEON_CRTC_V_TOTAL_DISP) &\n\t\t\t\tRADEON_CRTC_V_DISP) >> RADEON_CRTC_V_DISP_SHIFT;\n\t\t\t \n\t\t\tposition = (RREG32(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\n\t\t\tstat_crtc = RREG32(RADEON_CRTC_STATUS);\n\t\t\tif (!(stat_crtc & 1))\n\t\t\t\tin_vbl = false;\n\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t\tif (pipe == 1) {\n\t\t\tvbl = (RREG32(RADEON_CRTC2_V_TOTAL_DISP) &\n\t\t\t\tRADEON_CRTC_V_DISP) >> RADEON_CRTC_V_DISP_SHIFT;\n\t\t\tposition = (RREG32(RADEON_CRTC2_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\n\t\t\tstat_crtc = RREG32(RADEON_CRTC2_STATUS);\n\t\t\tif (!(stat_crtc & 1))\n\t\t\t\tin_vbl = false;\n\n\t\t\tret |= DRM_SCANOUTPOS_VALID;\n\t\t}\n\t}\n\n\t \n\tif (etime)\n\t\t*etime = ktime_get();\n\n\t \n\n\t \n\t*vpos = position & 0x1fff;\n\t*hpos = (position >> 16) & 0x1fff;\n\n\t \n\tif (vbl > 0) {\n\t\t \n\t\tret |= DRM_SCANOUTPOS_ACCURATE;\n\t\tvbl_start = vbl & 0x1fff;\n\t\tvbl_end = (vbl >> 16) & 0x1fff;\n\t}\n\telse {\n\t\t \n\t\tvbl_start = mode->crtc_vdisplay;\n\t\tvbl_end = 0;\n\t}\n\n\t \n\tif (flags & GET_DISTANCE_TO_VBLANKSTART) {\n\t     \n\t    *hpos = *vpos - vbl_start;\n\t}\n\n\t \n\tif (!(flags & USE_REAL_VBLANKSTART))\n\t\tvbl_start -= rdev->mode_info.crtcs[pipe]->lb_vblank_lead_lines;\n\n\t \n\tif ((*vpos < vbl_start) && (*vpos >= vbl_end))\n\t\tin_vbl = false;\n\n\t \n\tif (in_vbl)\n\t    ret |= DRM_SCANOUTPOS_IN_VBLANK;\n\n\t \n\tif (flags & GET_DISTANCE_TO_VBLANKSTART) {\n\t\t \n\t\t*vpos -= vbl_start;\n\t\treturn ret;\n\t}\n\n\t \n\n\t \n\tif (in_vbl && (*vpos >= vbl_start)) {\n\t\tvtotal = mode->crtc_vtotal;\n\t\t*vpos = *vpos - vtotal;\n\t}\n\n\t \n\t*vpos = *vpos - vbl_end;\n\n\treturn ret;\n}\n\nbool\nradeon_get_crtc_scanout_position(struct drm_crtc *crtc,\n\t\t\t\t bool in_vblank_irq, int *vpos, int *hpos,\n\t\t\t\t ktime_t *stime, ktime_t *etime,\n\t\t\t\t const struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\n\treturn radeon_get_crtc_scanoutpos(dev, pipe, 0, vpos, hpos,\n\t\t\t\t\t  stime, etime, mode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}