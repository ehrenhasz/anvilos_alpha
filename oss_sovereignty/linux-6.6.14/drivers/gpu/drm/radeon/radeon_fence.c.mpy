{
  "module_name": "radeon_fence.c",
  "hash_id": "fb2122a2247344e43a2b9d06893b706bb7f4574f75e2f544cb1b170fbe9193c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_fence.c",
  "human_readable_source": " \n \n\n#include <linux/atomic.h>\n#include <linux/firmware.h>\n#include <linux/kref.h>\n#include <linux/sched/signal.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n\n#include \"radeon.h\"\n#include \"radeon_reg.h\"\n#include \"radeon_trace.h\"\n\n \n\n \nstatic void radeon_fence_write(struct radeon_device *rdev, u32 seq, int ring)\n{\n\tstruct radeon_fence_driver *drv = &rdev->fence_drv[ring];\n\tif (likely(rdev->wb.enabled || !drv->scratch_reg)) {\n\t\tif (drv->cpu_addr) {\n\t\t\t*drv->cpu_addr = cpu_to_le32(seq);\n\t\t}\n\t} else {\n\t\tWREG32(drv->scratch_reg, seq);\n\t}\n}\n\n \nstatic u32 radeon_fence_read(struct radeon_device *rdev, int ring)\n{\n\tstruct radeon_fence_driver *drv = &rdev->fence_drv[ring];\n\tu32 seq = 0;\n\n\tif (likely(rdev->wb.enabled || !drv->scratch_reg)) {\n\t\tif (drv->cpu_addr) {\n\t\t\tseq = le32_to_cpu(*drv->cpu_addr);\n\t\t} else {\n\t\t\tseq = lower_32_bits(atomic64_read(&drv->last_seq));\n\t\t}\n\t} else {\n\t\tseq = RREG32(drv->scratch_reg);\n\t}\n\treturn seq;\n}\n\n \nstatic void radeon_fence_schedule_check(struct radeon_device *rdev, int ring)\n{\n\t \n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &rdev->fence_drv[ring].lockup_work,\n\t\t\t   RADEON_FENCE_JIFFIES_TIMEOUT);\n}\n\n \nint radeon_fence_emit(struct radeon_device *rdev,\n\t\t      struct radeon_fence **fence,\n\t\t      int ring)\n{\n\tu64 seq;\n\n\t \n\t*fence = kmalloc(sizeof(struct radeon_fence), GFP_KERNEL);\n\tif ((*fence) == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\t(*fence)->rdev = rdev;\n\t(*fence)->seq = seq = ++rdev->fence_drv[ring].sync_seq[ring];\n\t(*fence)->ring = ring;\n\t(*fence)->is_vm_update = false;\n\tdma_fence_init(&(*fence)->base, &radeon_fence_ops,\n\t\t       &rdev->fence_queue.lock,\n\t\t       rdev->fence_context + ring,\n\t\t       seq);\n\tradeon_fence_ring_emit(rdev, ring, *fence);\n\ttrace_radeon_fence_emit(rdev->ddev, ring, (*fence)->seq);\n\tradeon_fence_schedule_check(rdev, ring);\n\treturn 0;\n}\n\n \nstatic int radeon_fence_check_signaled(wait_queue_entry_t *wait, unsigned mode, int flags, void *key)\n{\n\tstruct radeon_fence *fence;\n\tu64 seq;\n\n\tfence = container_of(wait, struct radeon_fence, fence_wake);\n\n\t \n\tseq = atomic64_read(&fence->rdev->fence_drv[fence->ring].last_seq);\n\tif (seq >= fence->seq) {\n\t\tdma_fence_signal_locked(&fence->base);\n\t\tradeon_irq_kms_sw_irq_put(fence->rdev, fence->ring);\n\t\t__remove_wait_queue(&fence->rdev->fence_queue, &fence->fence_wake);\n\t\tdma_fence_put(&fence->base);\n\t}\n\treturn 0;\n}\n\n \nstatic bool radeon_fence_activity(struct radeon_device *rdev, int ring)\n{\n\tuint64_t seq, last_seq, last_emitted;\n\tunsigned count_loop = 0;\n\tbool wake = false;\n\n\t \n\tlast_seq = atomic64_read(&rdev->fence_drv[ring].last_seq);\n\tdo {\n\t\tlast_emitted = rdev->fence_drv[ring].sync_seq[ring];\n\t\tseq = radeon_fence_read(rdev, ring);\n\t\tseq |= last_seq & 0xffffffff00000000LL;\n\t\tif (seq < last_seq) {\n\t\t\tseq &= 0xffffffff;\n\t\t\tseq |= last_emitted & 0xffffffff00000000LL;\n\t\t}\n\n\t\tif (seq <= last_seq || seq > last_emitted) {\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\twake = true;\n\t\tlast_seq = seq;\n\t\tif ((count_loop++) > 10) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t} while (atomic64_xchg(&rdev->fence_drv[ring].last_seq, seq) > seq);\n\n\tif (seq < last_emitted)\n\t\tradeon_fence_schedule_check(rdev, ring);\n\n\treturn wake;\n}\n\n \nstatic void radeon_fence_check_lockup(struct work_struct *work)\n{\n\tstruct radeon_fence_driver *fence_drv;\n\tstruct radeon_device *rdev;\n\tint ring;\n\n\tfence_drv = container_of(work, struct radeon_fence_driver,\n\t\t\t\t lockup_work.work);\n\trdev = fence_drv->rdev;\n\tring = fence_drv - &rdev->fence_drv[0];\n\n\tif (!down_read_trylock(&rdev->exclusive_lock)) {\n\t\t \n\t\tradeon_fence_schedule_check(rdev, ring);\n\t\treturn;\n\t}\n\n\tif (fence_drv->delayed_irq && rdev->irq.installed) {\n\t\tunsigned long irqflags;\n\n\t\tfence_drv->delayed_irq = false;\n\t\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\t\tradeon_irq_set(rdev);\n\t\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\t}\n\n\tif (radeon_fence_activity(rdev, ring))\n\t\twake_up_all(&rdev->fence_queue);\n\n\telse if (radeon_ring_is_lockup(rdev, ring, &rdev->ring[ring])) {\n\n\t\t \n\t\tdev_warn(rdev->dev, \"GPU lockup (current fence id \"\n\t\t\t \"0x%016llx last fence id 0x%016llx on ring %d)\\n\",\n\t\t\t (uint64_t)atomic64_read(&fence_drv->last_seq),\n\t\t\t fence_drv->sync_seq[ring], ring);\n\n\t\t \n\t\trdev->needs_reset = true;\n\t\twake_up_all(&rdev->fence_queue);\n\t}\n\tup_read(&rdev->exclusive_lock);\n}\n\n \nvoid radeon_fence_process(struct radeon_device *rdev, int ring)\n{\n\tif (radeon_fence_activity(rdev, ring))\n\t\twake_up_all(&rdev->fence_queue);\n}\n\n \nstatic bool radeon_fence_seq_signaled(struct radeon_device *rdev,\n\t\t\t\t      u64 seq, unsigned ring)\n{\n\tif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\n\t\treturn true;\n\t}\n\t \n\tradeon_fence_process(rdev, ring);\n\tif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool radeon_fence_is_signaled(struct dma_fence *f)\n{\n\tstruct radeon_fence *fence = to_radeon_fence(f);\n\tstruct radeon_device *rdev = fence->rdev;\n\tunsigned ring = fence->ring;\n\tu64 seq = fence->seq;\n\n\tif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\n\t\treturn true;\n\t}\n\n\tif (down_read_trylock(&rdev->exclusive_lock)) {\n\t\tradeon_fence_process(rdev, ring);\n\t\tup_read(&rdev->exclusive_lock);\n\n\t\tif (atomic64_read(&rdev->fence_drv[ring].last_seq) >= seq) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n \nstatic bool radeon_fence_enable_signaling(struct dma_fence *f)\n{\n\tstruct radeon_fence *fence = to_radeon_fence(f);\n\tstruct radeon_device *rdev = fence->rdev;\n\n\tif (atomic64_read(&rdev->fence_drv[fence->ring].last_seq) >= fence->seq)\n\t\treturn false;\n\n\tif (down_read_trylock(&rdev->exclusive_lock)) {\n\t\tradeon_irq_kms_sw_irq_get(rdev, fence->ring);\n\n\t\tif (radeon_fence_activity(rdev, fence->ring))\n\t\t\twake_up_all_locked(&rdev->fence_queue);\n\n\t\t \n\t\tif (atomic64_read(&rdev->fence_drv[fence->ring].last_seq) >= fence->seq) {\n\t\t\tradeon_irq_kms_sw_irq_put(rdev, fence->ring);\n\t\t\tup_read(&rdev->exclusive_lock);\n\t\t\treturn false;\n\t\t}\n\n\t\tup_read(&rdev->exclusive_lock);\n\t} else {\n\t\t \n\t\tif (radeon_irq_kms_sw_irq_get_delayed(rdev, fence->ring))\n\t\t\trdev->fence_drv[fence->ring].delayed_irq = true;\n\t\tradeon_fence_schedule_check(rdev, fence->ring);\n\t}\n\n\tfence->fence_wake.flags = 0;\n\tfence->fence_wake.private = NULL;\n\tfence->fence_wake.func = radeon_fence_check_signaled;\n\t__add_wait_queue(&rdev->fence_queue, &fence->fence_wake);\n\tdma_fence_get(f);\n\treturn true;\n}\n\n \nbool radeon_fence_signaled(struct radeon_fence *fence)\n{\n\tif (!fence)\n\t\treturn true;\n\n\tif (radeon_fence_seq_signaled(fence->rdev, fence->seq, fence->ring)) {\n\t\tdma_fence_signal(&fence->base);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic bool radeon_fence_any_seq_signaled(struct radeon_device *rdev, u64 *seq)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tif (seq[i] && radeon_fence_seq_signaled(rdev, seq[i], i))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic long radeon_fence_wait_seq_timeout(struct radeon_device *rdev,\n\t\t\t\t\t  u64 *target_seq, bool intr,\n\t\t\t\t\t  long timeout)\n{\n\tlong r;\n\tint i;\n\n\tif (radeon_fence_any_seq_signaled(rdev, target_seq))\n\t\treturn timeout;\n\n\t \n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tif (!target_seq[i])\n\t\t\tcontinue;\n\n\t\ttrace_radeon_fence_wait_begin(rdev->ddev, i, target_seq[i]);\n\t\tradeon_irq_kms_sw_irq_get(rdev, i);\n\t}\n\n\tif (intr) {\n\t\tr = wait_event_interruptible_timeout(rdev->fence_queue, (\n\t\t\tradeon_fence_any_seq_signaled(rdev, target_seq)\n\t\t\t || rdev->needs_reset), timeout);\n\t} else {\n\t\tr = wait_event_timeout(rdev->fence_queue, (\n\t\t\tradeon_fence_any_seq_signaled(rdev, target_seq)\n\t\t\t || rdev->needs_reset), timeout);\n\t}\n\n\tif (rdev->needs_reset)\n\t\tr = -EDEADLK;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tif (!target_seq[i])\n\t\t\tcontinue;\n\n\t\tradeon_irq_kms_sw_irq_put(rdev, i);\n\t\ttrace_radeon_fence_wait_end(rdev->ddev, i, target_seq[i]);\n\t}\n\n\treturn r;\n}\n\n \nlong radeon_fence_wait_timeout(struct radeon_fence *fence, bool intr, long timeout)\n{\n\tuint64_t seq[RADEON_NUM_RINGS] = {};\n\tlong r;\n\n\t \n\tif (WARN_ON_ONCE(!to_radeon_fence(&fence->base)))\n\t\treturn dma_fence_wait(&fence->base, intr);\n\n\tseq[fence->ring] = fence->seq;\n\tr = radeon_fence_wait_seq_timeout(fence->rdev, seq, intr, timeout);\n\tif (r <= 0) {\n\t\treturn r;\n\t}\n\n\tdma_fence_signal(&fence->base);\n\treturn r;\n}\n\n \nint radeon_fence_wait(struct radeon_fence *fence, bool intr)\n{\n\tlong r = radeon_fence_wait_timeout(fence, intr, MAX_SCHEDULE_TIMEOUT);\n\tif (r > 0) {\n\t\treturn 0;\n\t} else {\n\t\treturn r;\n\t}\n}\n\n \nint radeon_fence_wait_any(struct radeon_device *rdev,\n\t\t\t  struct radeon_fence **fences,\n\t\t\t  bool intr)\n{\n\tuint64_t seq[RADEON_NUM_RINGS];\n\tunsigned i, num_rings = 0;\n\tlong r;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tseq[i] = 0;\n\n\t\tif (!fences[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tseq[i] = fences[i]->seq;\n\t\t++num_rings;\n\t}\n\n\t \n\tif (num_rings == 0)\n\t\treturn -ENOENT;\n\n\tr = radeon_fence_wait_seq_timeout(rdev, seq, intr, MAX_SCHEDULE_TIMEOUT);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nint radeon_fence_wait_next(struct radeon_device *rdev, int ring)\n{\n\tuint64_t seq[RADEON_NUM_RINGS] = {};\n\tlong r;\n\n\tseq[ring] = atomic64_read(&rdev->fence_drv[ring].last_seq) + 1ULL;\n\tif (seq[ring] >= rdev->fence_drv[ring].sync_seq[ring]) {\n\t\t \n\t\treturn -ENOENT;\n\t}\n\tr = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);\n\tif (r < 0)\n\t\treturn r;\n\treturn 0;\n}\n\n \nint radeon_fence_wait_empty(struct radeon_device *rdev, int ring)\n{\n\tuint64_t seq[RADEON_NUM_RINGS] = {};\n\tlong r;\n\n\tseq[ring] = rdev->fence_drv[ring].sync_seq[ring];\n\tif (!seq[ring])\n\t\treturn 0;\n\n\tr = radeon_fence_wait_seq_timeout(rdev, seq, false, MAX_SCHEDULE_TIMEOUT);\n\tif (r < 0) {\n\t\tif (r == -EDEADLK)\n\t\t\treturn -EDEADLK;\n\n\t\tdev_err(rdev->dev, \"error waiting for ring[%d] to become idle (%ld)\\n\",\n\t\t\tring, r);\n\t}\n\treturn 0;\n}\n\n \nstruct radeon_fence *radeon_fence_ref(struct radeon_fence *fence)\n{\n\tdma_fence_get(&fence->base);\n\treturn fence;\n}\n\n \nvoid radeon_fence_unref(struct radeon_fence **fence)\n{\n\tstruct radeon_fence *tmp = *fence;\n\n\t*fence = NULL;\n\tif (tmp) {\n\t\tdma_fence_put(&tmp->base);\n\t}\n}\n\n \nunsigned radeon_fence_count_emitted(struct radeon_device *rdev, int ring)\n{\n\tuint64_t emitted;\n\n\t \n\tradeon_fence_process(rdev, ring);\n\temitted = rdev->fence_drv[ring].sync_seq[ring]\n\t\t- atomic64_read(&rdev->fence_drv[ring].last_seq);\n\t \n\tif (emitted > 0x10000000) {\n\t\temitted = 0x10000000;\n\t}\n\treturn (unsigned)emitted;\n}\n\n \nbool radeon_fence_need_sync(struct radeon_fence *fence, int dst_ring)\n{\n\tstruct radeon_fence_driver *fdrv;\n\n\tif (!fence) {\n\t\treturn false;\n\t}\n\n\tif (fence->ring == dst_ring) {\n\t\treturn false;\n\t}\n\n\t \n\tfdrv = &fence->rdev->fence_drv[dst_ring];\n\tif (fence->seq <= fdrv->sync_seq[fence->ring]) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nvoid radeon_fence_note_sync(struct radeon_fence *fence, int dst_ring)\n{\n\tstruct radeon_fence_driver *dst, *src;\n\tunsigned i;\n\n\tif (!fence) {\n\t\treturn;\n\t}\n\n\tif (fence->ring == dst_ring) {\n\t\treturn;\n\t}\n\n\t \n\tsrc = &fence->rdev->fence_drv[fence->ring];\n\tdst = &fence->rdev->fence_drv[dst_ring];\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tif (i == dst_ring) {\n\t\t\tcontinue;\n\t\t}\n\t\tdst->sync_seq[i] = max(dst->sync_seq[i], src->sync_seq[i]);\n\t}\n}\n\n \nint radeon_fence_driver_start_ring(struct radeon_device *rdev, int ring)\n{\n\tuint64_t index;\n\tint r;\n\n\tradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\n\tif (rdev->wb.use_event || !radeon_ring_supports_scratch_reg(rdev, &rdev->ring[ring])) {\n\t\trdev->fence_drv[ring].scratch_reg = 0;\n\t\tif (ring != R600_RING_TYPE_UVD_INDEX) {\n\t\t\tindex = R600_WB_EVENT_OFFSET + ring * 4;\n\t\t\trdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\n\t\t\trdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr +\n\t\t\t\t\t\t\t index;\n\n\t\t} else {\n\t\t\t \n\t\t\tindex = ALIGN(rdev->uvd_fw->size, 8);\n\t\t\trdev->fence_drv[ring].cpu_addr = rdev->uvd.cpu_addr + index;\n\t\t\trdev->fence_drv[ring].gpu_addr = rdev->uvd.gpu_addr + index;\n\t\t}\n\n\t} else {\n\t\tr = radeon_scratch_get(rdev, &rdev->fence_drv[ring].scratch_reg);\n\t\tif (r) {\n\t\t\tdev_err(rdev->dev, \"fence failed to get scratch register\\n\");\n\t\t\treturn r;\n\t\t}\n\t\tindex = RADEON_WB_SCRATCH_OFFSET +\n\t\t\trdev->fence_drv[ring].scratch_reg -\n\t\t\trdev->scratch.reg_base;\n\t\trdev->fence_drv[ring].cpu_addr = &rdev->wb.wb[index/4];\n\t\trdev->fence_drv[ring].gpu_addr = rdev->wb.gpu_addr + index;\n\t}\n\tradeon_fence_write(rdev, atomic64_read(&rdev->fence_drv[ring].last_seq), ring);\n\trdev->fence_drv[ring].initialized = true;\n\tdev_info(rdev->dev, \"fence driver on ring %d use gpu addr 0x%016llx\\n\",\n\t\t ring, rdev->fence_drv[ring].gpu_addr);\n\treturn 0;\n}\n\n \nstatic void radeon_fence_driver_init_ring(struct radeon_device *rdev, int ring)\n{\n\tint i;\n\n\trdev->fence_drv[ring].scratch_reg = -1;\n\trdev->fence_drv[ring].cpu_addr = NULL;\n\trdev->fence_drv[ring].gpu_addr = 0;\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i)\n\t\trdev->fence_drv[ring].sync_seq[i] = 0;\n\tatomic64_set(&rdev->fence_drv[ring].last_seq, 0);\n\trdev->fence_drv[ring].initialized = false;\n\tINIT_DELAYED_WORK(&rdev->fence_drv[ring].lockup_work,\n\t\t\t  radeon_fence_check_lockup);\n\trdev->fence_drv[ring].rdev = rdev;\n}\n\n \nvoid radeon_fence_driver_init(struct radeon_device *rdev)\n{\n\tint ring;\n\n\tinit_waitqueue_head(&rdev->fence_queue);\n\tfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\n\t\tradeon_fence_driver_init_ring(rdev, ring);\n\t}\n\n\tradeon_debugfs_fence_init(rdev);\n}\n\n \nvoid radeon_fence_driver_fini(struct radeon_device *rdev)\n{\n\tint ring, r;\n\n\tmutex_lock(&rdev->ring_lock);\n\tfor (ring = 0; ring < RADEON_NUM_RINGS; ring++) {\n\t\tif (!rdev->fence_drv[ring].initialized)\n\t\t\tcontinue;\n\t\tr = radeon_fence_wait_empty(rdev, ring);\n\t\tif (r) {\n\t\t\t \n\t\t\tradeon_fence_driver_force_completion(rdev, ring);\n\t\t}\n\t\tcancel_delayed_work_sync(&rdev->fence_drv[ring].lockup_work);\n\t\twake_up_all(&rdev->fence_queue);\n\t\tradeon_scratch_free(rdev, rdev->fence_drv[ring].scratch_reg);\n\t\trdev->fence_drv[ring].initialized = false;\n\t}\n\tmutex_unlock(&rdev->ring_lock);\n}\n\n \nvoid radeon_fence_driver_force_completion(struct radeon_device *rdev, int ring)\n{\n\tif (rdev->fence_drv[ring].initialized) {\n\t\tradeon_fence_write(rdev, rdev->fence_drv[ring].sync_seq[ring], ring);\n\t\tcancel_delayed_work_sync(&rdev->fence_drv[ring].lockup_work);\n\t}\n}\n\n\n \n#if defined(CONFIG_DEBUG_FS)\nstatic int radeon_debugfs_fence_info_show(struct seq_file *m, void *data)\n{\n\tstruct radeon_device *rdev = m->private;\n\tint i, j;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tif (!rdev->fence_drv[i].initialized)\n\t\t\tcontinue;\n\n\t\tradeon_fence_process(rdev, i);\n\n\t\tseq_printf(m, \"--- ring %d ---\\n\", i);\n\t\tseq_printf(m, \"Last signaled fence 0x%016llx\\n\",\n\t\t\t   (unsigned long long)atomic64_read(&rdev->fence_drv[i].last_seq));\n\t\tseq_printf(m, \"Last emitted        0x%016llx\\n\",\n\t\t\t   rdev->fence_drv[i].sync_seq[i]);\n\n\t\tfor (j = 0; j < RADEON_NUM_RINGS; ++j) {\n\t\t\tif (i != j && rdev->fence_drv[j].initialized)\n\t\t\t\tseq_printf(m, \"Last sync to ring %d 0x%016llx\\n\",\n\t\t\t\t\t   j, rdev->fence_drv[i].sync_seq[j]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int radeon_debugfs_gpu_reset(void *data, u64 *val)\n{\n\tstruct radeon_device *rdev = (struct radeon_device *)data;\n\n\tdown_read(&rdev->exclusive_lock);\n\t*val = rdev->needs_reset;\n\trdev->needs_reset = true;\n\twake_up_all(&rdev->fence_queue);\n\tup_read(&rdev->exclusive_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(radeon_debugfs_fence_info);\nDEFINE_DEBUGFS_ATTRIBUTE(radeon_debugfs_gpu_reset_fops,\n\t\t\t radeon_debugfs_gpu_reset, NULL, \"%lld\\n\");\n#endif\n\nvoid radeon_debugfs_fence_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"radeon_gpu_reset\", 0444, root, rdev,\n\t\t\t    &radeon_debugfs_gpu_reset_fops);\n\tdebugfs_create_file(\"radeon_fence_info\", 0444, root, rdev,\n\t\t\t    &radeon_debugfs_fence_info_fops);\n\n\n#endif\n}\n\nstatic const char *radeon_fence_get_driver_name(struct dma_fence *fence)\n{\n\treturn \"radeon\";\n}\n\nstatic const char *radeon_fence_get_timeline_name(struct dma_fence *f)\n{\n\tstruct radeon_fence *fence = to_radeon_fence(f);\n\tswitch (fence->ring) {\n\tcase RADEON_RING_TYPE_GFX_INDEX: return \"radeon.gfx\";\n\tcase CAYMAN_RING_TYPE_CP1_INDEX: return \"radeon.cp1\";\n\tcase CAYMAN_RING_TYPE_CP2_INDEX: return \"radeon.cp2\";\n\tcase R600_RING_TYPE_DMA_INDEX: return \"radeon.dma\";\n\tcase CAYMAN_RING_TYPE_DMA1_INDEX: return \"radeon.dma1\";\n\tcase R600_RING_TYPE_UVD_INDEX: return \"radeon.uvd\";\n\tcase TN_RING_TYPE_VCE1_INDEX: return \"radeon.vce1\";\n\tcase TN_RING_TYPE_VCE2_INDEX: return \"radeon.vce2\";\n\tdefault: WARN_ON_ONCE(1); return \"radeon.unk\";\n\t}\n}\n\nstatic inline bool radeon_test_signaled(struct radeon_fence *fence)\n{\n\treturn test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->base.flags);\n}\n\nstruct radeon_wait_cb {\n\tstruct dma_fence_cb base;\n\tstruct task_struct *task;\n};\n\nstatic void\nradeon_fence_wait_cb(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tstruct radeon_wait_cb *wait =\n\t\tcontainer_of(cb, struct radeon_wait_cb, base);\n\n\twake_up_process(wait->task);\n}\n\nstatic signed long radeon_fence_default_wait(struct dma_fence *f, bool intr,\n\t\t\t\t\t     signed long t)\n{\n\tstruct radeon_fence *fence = to_radeon_fence(f);\n\tstruct radeon_device *rdev = fence->rdev;\n\tstruct radeon_wait_cb cb;\n\n\tcb.task = current;\n\n\tif (dma_fence_add_callback(f, &cb.base, radeon_fence_wait_cb))\n\t\treturn t;\n\n\twhile (t > 0) {\n\t\tif (intr)\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\telse\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\n\t\t \n\t\tif (radeon_test_signaled(fence))\n\t\t\tbreak;\n\n\t\tif (rdev->needs_reset) {\n\t\t\tt = -EDEADLK;\n\t\t\tbreak;\n\t\t}\n\n\t\tt = schedule_timeout(t);\n\n\t\tif (t > 0 && intr && signal_pending(current))\n\t\t\tt = -ERESTARTSYS;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\tdma_fence_remove_callback(f, &cb.base);\n\n\treturn t;\n}\n\nconst struct dma_fence_ops radeon_fence_ops = {\n\t.get_driver_name = radeon_fence_get_driver_name,\n\t.get_timeline_name = radeon_fence_get_timeline_name,\n\t.enable_signaling = radeon_fence_enable_signaling,\n\t.signaled = radeon_fence_is_signaled,\n\t.wait = radeon_fence_default_wait,\n\t.release = NULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}