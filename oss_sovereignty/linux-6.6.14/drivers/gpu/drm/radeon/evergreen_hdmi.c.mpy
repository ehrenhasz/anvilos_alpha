{
  "module_name": "evergreen_hdmi.c",
  "hash_id": "4e0312b211872e651519d88f8ceaaab39f2bd9a3e724f6a9be105978477f0809",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/evergreen_hdmi.c",
  "human_readable_source": " \n#include <linux/hdmi.h>\n\n#include <drm/radeon_drm.h>\n#include \"evergreen_hdmi.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"evergreend.h\"\n#include \"atom.h\"\n\n \nvoid dce4_audio_enable(struct radeon_device *rdev,\n\t\t\t      struct r600_audio_pin *pin,\n\t\t\t      u8 enable_mask)\n{\n\tu32 tmp = RREG32(AZ_HOT_PLUG_CONTROL);\n\n\tif (!pin)\n\t\treturn;\n\n\tif (enable_mask) {\n\t\ttmp |= AUDIO_ENABLED;\n\t\tif (enable_mask & 1)\n\t\t\ttmp |= PIN0_AUDIO_ENABLED;\n\t\tif (enable_mask & 2)\n\t\t\ttmp |= PIN1_AUDIO_ENABLED;\n\t\tif (enable_mask & 4)\n\t\t\ttmp |= PIN2_AUDIO_ENABLED;\n\t\tif (enable_mask & 8)\n\t\t\ttmp |= PIN3_AUDIO_ENABLED;\n\t} else {\n\t\ttmp &= ~(AUDIO_ENABLED |\n\t\t\t PIN0_AUDIO_ENABLED |\n\t\t\t PIN1_AUDIO_ENABLED |\n\t\t\t PIN2_AUDIO_ENABLED |\n\t\t\t PIN3_AUDIO_ENABLED);\n\t}\n\n\tWREG32(AZ_HOT_PLUG_CONTROL, tmp);\n}\n\nvoid evergreen_hdmi_update_acr(struct drm_encoder *encoder, long offset,\n\tconst struct radeon_hdmi_acr *acr)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint bpc = 8;\n\n\tif (encoder->crtc) {\n\t\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\t\tbpc = radeon_crtc->bpc;\n\t}\n\n\tif (bpc > 8)\n\t\tWREG32(HDMI_ACR_PACKET_CONTROL + offset,\n\t\t\tHDMI_ACR_AUTO_SEND);\t \n\telse\n\t\tWREG32(HDMI_ACR_PACKET_CONTROL + offset,\n\t\t\tHDMI_ACR_SOURCE |\t\t \n\t\t\tHDMI_ACR_AUTO_SEND);\t \n\n\tWREG32(HDMI_ACR_32_0 + offset, HDMI_ACR_CTS_32(acr->cts_32khz));\n\tWREG32(HDMI_ACR_32_1 + offset, acr->n_32khz);\n\n\tWREG32(HDMI_ACR_44_0 + offset, HDMI_ACR_CTS_44(acr->cts_44_1khz));\n\tWREG32(HDMI_ACR_44_1 + offset, acr->n_44_1khz);\n\n\tWREG32(HDMI_ACR_48_0 + offset, HDMI_ACR_CTS_48(acr->cts_48khz));\n\tWREG32(HDMI_ACR_48_1 + offset, acr->n_48khz);\n}\n\nvoid dce4_afmt_write_latency_fields(struct drm_encoder *encoder,\n\t\tstruct drm_connector *connector, struct drm_display_mode *mode)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tu32 tmp = 0;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (connector->latency_present[1])\n\t\t\ttmp = VIDEO_LIPSYNC(connector->video_latency[1]) |\n\t\t\t\tAUDIO_LIPSYNC(connector->audio_latency[1]);\n\t\telse\n\t\t\ttmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);\n\t} else {\n\t\tif (connector->latency_present[0])\n\t\t\ttmp = VIDEO_LIPSYNC(connector->video_latency[0]) |\n\t\t\t\tAUDIO_LIPSYNC(connector->audio_latency[0]);\n\t\telse\n\t\t\ttmp = VIDEO_LIPSYNC(255) | AUDIO_LIPSYNC(255);\n\t}\n\tWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_RESPONSE_LIPSYNC, tmp);\n}\n\nvoid dce4_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,\n\tu8 *sadb, int sad_count)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\n\ttmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\n\t \n\ttmp |= HDMI_CONNECTION;\n\tif (sad_count)\n\t\ttmp |= SPEAKER_ALLOCATION(sadb[0]);\n\telse\n\t\ttmp |= SPEAKER_ALLOCATION(5);  \n\tWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\n}\n\nvoid dce4_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,\n\tu8 *sadb, int sad_count)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\n\ttmp &= ~(HDMI_CONNECTION | SPEAKER_ALLOCATION_MASK);\n\t \n\ttmp |= DP_CONNECTION;\n\tif (sad_count)\n\t\ttmp |= SPEAKER_ALLOCATION(sadb[0]);\n\telse\n\t\ttmp |= SPEAKER_ALLOCATION(5);  \n\tWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\n}\n\nvoid evergreen_hdmi_write_sad_regs(struct drm_encoder *encoder,\n\tstruct cea_sad *sads, int sad_count)\n{\n\tint i;\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstatic const u16 eld_reg_to_type[][2] = {\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\n\t\tu32 value = 0;\n\t\tu8 stereo_freqs = 0;\n\t\tint max_channels = -1;\n\t\tint j;\n\n\t\tfor (j = 0; j < sad_count; j++) {\n\t\t\tstruct cea_sad *sad = &sads[j];\n\n\t\t\tif (sad->format == eld_reg_to_type[i][1]) {\n\t\t\t\tif (sad->channels > max_channels) {\n\t\t\t\t\tvalue = MAX_CHANNELS(sad->channels) |\n\t\t\t\t\t\tDESCRIPTOR_BYTE_2(sad->byte2) |\n\t\t\t\t\t\tSUPPORTED_FREQUENCIES(sad->freq);\n\t\t\t\t\tmax_channels = sad->channels;\n\t\t\t\t}\n\n\t\t\t\tif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\n\t\t\t\t\tstereo_freqs |= sad->freq;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\n\n\t\tWREG32_ENDPOINT(0, eld_reg_to_type[i][0], value);\n\t}\n}\n\n \nvoid evergreen_set_avi_packet(struct radeon_device *rdev, u32 offset,\n\t\t\t      unsigned char *buffer, size_t size)\n{\n\tuint8_t *frame = buffer + 3;\n\n\tWREG32(AFMT_AVI_INFO0 + offset,\n\t\tframe[0x0] | (frame[0x1] << 8) | (frame[0x2] << 16) | (frame[0x3] << 24));\n\tWREG32(AFMT_AVI_INFO1 + offset,\n\t\tframe[0x4] | (frame[0x5] << 8) | (frame[0x6] << 16) | (frame[0x7] << 24));\n\tWREG32(AFMT_AVI_INFO2 + offset,\n\t\tframe[0x8] | (frame[0x9] << 8) | (frame[0xA] << 16) | (frame[0xB] << 24));\n\tWREG32(AFMT_AVI_INFO3 + offset,\n\t\tframe[0xC] | (frame[0xD] << 8) | (buffer[1] << 24));\n\n\tWREG32_P(HDMI_INFOFRAME_CONTROL1 + offset,\n\t\t HDMI_AVI_INFO_LINE(2),\t \n\t\t ~HDMI_AVI_INFO_LINE_MASK);\n}\n\nvoid dce4_hdmi_audio_set_dto(struct radeon_device *rdev,\n\tstruct radeon_crtc *crtc, unsigned int clock)\n{\n\tunsigned int max_ratio = clock / 24000;\n\tu32 dto_phase;\n\tu32 wallclock_ratio;\n\tu32 value;\n\n\tif (max_ratio >= 8) {\n\t\tdto_phase = 192 * 1000;\n\t\twallclock_ratio = 3;\n\t} else if (max_ratio >= 4) {\n\t\tdto_phase = 96 * 1000;\n\t\twallclock_ratio = 2;\n\t} else if (max_ratio >= 2) {\n\t\tdto_phase = 48 * 1000;\n\t\twallclock_ratio = 1;\n\t} else {\n\t\tdto_phase = 24 * 1000;\n\t\twallclock_ratio = 0;\n\t}\n\n\tvalue = RREG32(DCCG_AUDIO_DTO0_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\n\tvalue |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\n\tvalue &= ~DCCG_AUDIO_DTO1_USE_512FBR_DTO;\n\tWREG32(DCCG_AUDIO_DTO0_CNTL, value);\n\n\t \n\tvalue = 0;\n\n\tif (crtc)\n\t\tvalue |= DCCG_AUDIO_DTO0_SOURCE_SEL(crtc->crtc_id);\n\n\tWREG32(DCCG_AUDIO_DTO_SOURCE, value);\n\n\t \n\tWREG32(DCCG_AUDIO_DTO0_PHASE, dto_phase);\n\tWREG32(DCCG_AUDIO_DTO0_MODULE, clock);\n}\n\nvoid dce4_dp_audio_set_dto(struct radeon_device *rdev,\n\t\t\t   struct radeon_crtc *crtc, unsigned int clock)\n{\n\tu32 value;\n\n\tvalue = RREG32(DCCG_AUDIO_DTO1_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\n\tvalue |= DCCG_AUDIO_DTO1_USE_512FBR_DTO;\n\tWREG32(DCCG_AUDIO_DTO1_CNTL, value);\n\n\t \n\tvalue = 0;\n\tvalue |= DCCG_AUDIO_DTO_SEL;\n\n\tif (crtc)\n\t\tvalue |= DCCG_AUDIO_DTO0_SOURCE_SEL(crtc->crtc_id);\n\n\tWREG32(DCCG_AUDIO_DTO_SOURCE, value);\n\n\t \n\tif (ASIC_IS_DCE41(rdev)) {\n\t\tunsigned int div = (RREG32(DCE41_DENTIST_DISPCLK_CNTL) &\n\t\t\tDENTIST_DPREFCLK_WDIVIDER_MASK) >>\n\t\t\tDENTIST_DPREFCLK_WDIVIDER_SHIFT;\n\t\tdiv = radeon_audio_decode_dfs_div(div);\n\n\t\tif (div)\n\t\t\tclock = 100 * clock / div;\n\t}\n\n\tWREG32(DCCG_AUDIO_DTO1_PHASE, 24000);\n\tWREG32(DCCG_AUDIO_DTO1_MODULE, clock);\n}\n\nvoid dce4_set_vbi_packet(struct drm_encoder *encoder, u32 offset)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tWREG32(HDMI_VBI_PACKET_CONTROL + offset,\n\t\tHDMI_NULL_SEND |\t \n\t\tHDMI_GC_SEND |\t\t \n\t\tHDMI_GC_CONT);\t\t \n}\n\nvoid dce4_hdmi_set_color_depth(struct drm_encoder *encoder, u32 offset, int bpc)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tuint32_t val;\n\n\tval = RREG32(HDMI_CONTROL + offset);\n\tval &= ~HDMI_DEEP_COLOR_ENABLE;\n\tval &= ~HDMI_DEEP_COLOR_DEPTH_MASK;\n\n\tswitch (bpc) {\n\t\tcase 0:\n\t\tcase 6:\n\t\tcase 8:\n\t\tcase 16:\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"%s: Disabling hdmi deep color for %d bpc.\\n\",\n\t\t\t\t\t connector->name, bpc);\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tval |= HDMI_DEEP_COLOR_ENABLE;\n\t\t\tval |= HDMI_DEEP_COLOR_DEPTH(HDMI_30BIT_DEEP_COLOR);\n\t\t\tDRM_DEBUG(\"%s: Enabling hdmi deep color 30 for 10 bpc.\\n\",\n\t\t\t\t\t connector->name);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tval |= HDMI_DEEP_COLOR_ENABLE;\n\t\t\tval |= HDMI_DEEP_COLOR_DEPTH(HDMI_36BIT_DEEP_COLOR);\n\t\t\tDRM_DEBUG(\"%s: Enabling hdmi deep color 36 for 12 bpc.\\n\",\n\t\t\t\t\t connector->name);\n\t\t\tbreak;\n\t}\n\n\tWREG32(HDMI_CONTROL + offset, val);\n}\n\nvoid dce4_set_audio_packet(struct drm_encoder *encoder, u32 offset)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tWREG32(AFMT_INFOFRAME_CONTROL0 + offset,\n\t\tAFMT_AUDIO_INFO_UPDATE);  \n\n\tWREG32(AFMT_60958_0 + offset,\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_L(1));\n\n\tWREG32(AFMT_60958_1 + offset,\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_R(2));\n\n\tWREG32(AFMT_60958_2 + offset,\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_2(3) |\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_3(4) |\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_4(5) |\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_5(6) |\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_6(7) |\n\t\tAFMT_60958_CS_CHANNEL_NUMBER_7(8));\n\n\tWREG32(AFMT_AUDIO_PACKET_CONTROL2 + offset,\n\t\tAFMT_AUDIO_CHANNEL_ENABLE(0xff));\n\n\tWREG32(HDMI_AUDIO_PACKET_CONTROL + offset,\n\t       HDMI_AUDIO_DELAY_EN(1) |  \n\t       HDMI_AUDIO_PACKETS_PER_LINE(3));  \n\n\t \n\tWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + offset,\n\t\t  AFMT_RESET_FIFO_WHEN_AUDIO_DIS | AFMT_60958_CS_UPDATE);\n}\n\n\nvoid dce4_set_mute(struct drm_encoder *encoder, u32 offset, bool mute)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (mute)\n\t\tWREG32_OR(HDMI_GC + offset, HDMI_GC_AVMUTE);\n\telse\n\t\tWREG32_AND(HDMI_GC + offset, ~HDMI_GC_AVMUTE);\n}\n\nvoid evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (enable) {\n\t\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\n\t\tif (connector && drm_detect_monitor_audio(radeon_connector_edid(connector))) {\n\t\t\tWREG32(HDMI_INFOFRAME_CONTROL0 + dig->afmt->offset,\n\t\t\t       HDMI_AVI_INFO_SEND |  \n\t\t\t       HDMI_AVI_INFO_CONT |  \n\t\t\t       HDMI_AUDIO_INFO_SEND |  \n\t\t\t       HDMI_AUDIO_INFO_CONT);  \n\t\t\tWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\n\t\t\t\t  AFMT_AUDIO_SAMPLE_SEND);\n\t\t} else {\n\t\t\tWREG32(HDMI_INFOFRAME_CONTROL0 + dig->afmt->offset,\n\t\t\t       HDMI_AVI_INFO_SEND |  \n\t\t\t       HDMI_AVI_INFO_CONT);  \n\t\t\tWREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\n\t\t\t\t   ~AFMT_AUDIO_SAMPLE_SEND);\n\t\t}\n\t} else {\n\t\tWREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\n\t\t\t   ~AFMT_AUDIO_SAMPLE_SEND);\n\t\tWREG32(HDMI_INFOFRAME_CONTROL0 + dig->afmt->offset, 0);\n\t}\n\n\tdig->afmt->enabled = enable;\n\n\tDRM_DEBUG(\"%sabling HDMI interface @ 0x%04X for encoder 0x%x\\n\",\n\t\t  enable ? \"En\" : \"Dis\", dig->afmt->offset, radeon_encoder->encoder_id);\n}\n\nvoid evergreen_dp_enable(struct drm_encoder *encoder, bool enable)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\n\tif (!dig || !dig->afmt)\n\t\treturn;\n\n\tif (enable && connector &&\n\t    drm_detect_monitor_audio(radeon_connector_edid(connector))) {\n\t\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tstruct radeon_connector_atom_dig *dig_connector;\n\t\tuint32_t val;\n\n\t\tWREG32_OR(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\n\t\t\t  AFMT_AUDIO_SAMPLE_SEND);\n\n\t\tWREG32(EVERGREEN_DP_SEC_TIMESTAMP + dig->afmt->offset,\n\t\t       EVERGREEN_DP_SEC_TIMESTAMP_MODE(1));\n\n\t\tif (!ASIC_IS_DCE6(rdev) && radeon_connector->con_priv) {\n\t\t\tdig_connector = radeon_connector->con_priv;\n\t\t\tval = RREG32(EVERGREEN_DP_SEC_AUD_N + dig->afmt->offset);\n\t\t\tval &= ~EVERGREEN_DP_SEC_N_BASE_MULTIPLE(0xf);\n\n\t\t\tif (dig_connector->dp_clock == 162000)\n\t\t\t\tval |= EVERGREEN_DP_SEC_N_BASE_MULTIPLE(3);\n\t\t\telse\n\t\t\t\tval |= EVERGREEN_DP_SEC_N_BASE_MULTIPLE(5);\n\n\t\t\tWREG32(EVERGREEN_DP_SEC_AUD_N + dig->afmt->offset, val);\n\t\t}\n\n\t\tWREG32(EVERGREEN_DP_SEC_CNTL + dig->afmt->offset,\n\t\t\tEVERGREEN_DP_SEC_ASP_ENABLE |\t\t \n\t\t\tEVERGREEN_DP_SEC_ATP_ENABLE |\t\t \n\t\t\tEVERGREEN_DP_SEC_AIP_ENABLE |\t\t \n\t\t\tEVERGREEN_DP_SEC_STREAM_ENABLE);\t \n\t} else {\n\t\tWREG32(EVERGREEN_DP_SEC_CNTL + dig->afmt->offset, 0);\n\t\tWREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig->afmt->offset,\n\t\t\t   ~AFMT_AUDIO_SAMPLE_SEND);\n\t}\n\n\tdig->afmt->enabled = enable;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}