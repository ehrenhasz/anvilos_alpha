{
  "module_name": "sumo_smc.c",
  "hash_id": "2635743457eae045448604f5e30882b5463021d13d308b57f8e567b9e880c574",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/sumo_smc.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"sumod.h\"\n#include \"sumo_dpm.h\"\n#include \"ppsmc.h\"\n\n#define SUMO_SMU_SERVICE_ROUTINE_PG_INIT        1\n#define SUMO_SMU_SERVICE_ROUTINE_ALTVDDNB_NOTIFY  27\n#define SUMO_SMU_SERVICE_ROUTINE_GFX_SRV_ID_20  20\n\nstatic void sumo_send_msg_to_smu(struct radeon_device *rdev, u32 id)\n{\n\tu32 gfx_int_req;\n\tint i;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(GFX_INT_STATUS) & INT_DONE)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tgfx_int_req = SERV_INDEX(id) | INT_REQ;\n\tWREG32(GFX_INT_REQ, gfx_int_req);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(GFX_INT_REQ) & INT_REQ)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(GFX_INT_STATUS) & INT_ACK)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(GFX_INT_STATUS) & INT_DONE)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tgfx_int_req &= ~INT_REQ;\n\tWREG32(GFX_INT_REQ, gfx_int_req);\n}\n\nvoid sumo_initialize_m3_arb(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 i;\n\n\tif (!pi->enable_dynamic_m3_arbiter)\n\t\treturn;\n\n\tfor (i = 0; i < NUMBER_OF_M3ARB_PARAM_SETS; i++)\n\t\tWREG32_RCU(MCU_M3ARB_PARAMS + (i * 4),\n\t\t\t   pi->sys_info.csr_m3_arb_cntl_default[i]);\n\n\tfor (; i < NUMBER_OF_M3ARB_PARAM_SETS * 2; i++)\n\t\tWREG32_RCU(MCU_M3ARB_PARAMS + (i * 4),\n\t\t\t   pi->sys_info.csr_m3_arb_cntl_uvd[i % NUMBER_OF_M3ARB_PARAM_SETS]);\n\n\tfor (; i < NUMBER_OF_M3ARB_PARAM_SETS * 3; i++)\n\t\tWREG32_RCU(MCU_M3ARB_PARAMS + (i * 4),\n\t\t\t   pi->sys_info.csr_m3_arb_cntl_fs3d[i % NUMBER_OF_M3ARB_PARAM_SETS]);\n}\n\nstatic bool sumo_is_alt_vddnb_supported(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tbool return_code = false;\n\n\tif (!pi->enable_alt_vddnb)\n\t\treturn return_code;\n\n\tif ((rdev->family == CHIP_SUMO) || (rdev->family == CHIP_SUMO2)) {\n\t\tif (pi->fw_version >= 0x00010C00)\n\t\t\treturn_code = true;\n\t}\n\n\treturn return_code;\n}\n\nvoid sumo_smu_notify_alt_vddnb_change(struct radeon_device *rdev,\n\t\t\t\t      bool powersaving, bool force_nbps1)\n{\n\tu32 param = 0;\n\n\tif (!sumo_is_alt_vddnb_supported(rdev))\n\t\treturn;\n\n\tif (powersaving)\n\t\tparam |= 1;\n\n\tif (force_nbps1)\n\t\tparam |= 2;\n\n\tWREG32_RCU(RCU_ALTVDDNB_NOTIFY, param);\n\n\tsumo_send_msg_to_smu(rdev, SUMO_SMU_SERVICE_ROUTINE_ALTVDDNB_NOTIFY);\n}\n\nvoid sumo_smu_pg_init(struct radeon_device *rdev)\n{\n\tsumo_send_msg_to_smu(rdev, SUMO_SMU_SERVICE_ROUTINE_PG_INIT);\n}\n\nstatic u32 sumo_power_of_4(u32 unit)\n{\n\tu32 ret = 1;\n\tu32 i;\n\n\tfor (i = 0; i < unit; i++)\n\t\tret *= 4;\n\n\treturn ret;\n}\n\nvoid sumo_enable_boost_timer(struct radeon_device *rdev)\n{\n\tstruct sumo_power_info *pi = sumo_get_pi(rdev);\n\tu32 period, unit, timer_value;\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tunit = (RREG32_RCU(RCU_LCLK_SCALING_CNTL) & LCLK_SCALING_TIMER_PRESCALER_MASK)\n\t\t>> LCLK_SCALING_TIMER_PRESCALER_SHIFT;\n\n\tperiod = 100 * (xclk / 100 / sumo_power_of_4(unit));\n\n\ttimer_value = (period << 16) | (unit << 4);\n\n\tWREG32_RCU(RCU_GNB_PWR_REP_TIMER_CNTL, timer_value);\n\tWREG32_RCU(RCU_BOOST_MARGIN, pi->sys_info.sclk_dpm_boost_margin);\n\tWREG32_RCU(RCU_THROTTLE_MARGIN, pi->sys_info.sclk_dpm_throttle_margin);\n\tWREG32_RCU(GNB_TDP_LIMIT, pi->sys_info.gnb_tdp_limit);\n\tWREG32_RCU(RCU_SclkDpmTdpLimitPG, pi->sys_info.sclk_dpm_tdp_limit_pg);\n\n\tsumo_send_msg_to_smu(rdev, SUMO_SMU_SERVICE_ROUTINE_GFX_SRV_ID_20);\n}\n\nvoid sumo_set_tdp_limit(struct radeon_device *rdev, u32 index, u32 tdp_limit)\n{\n\tu32 regoffset = 0;\n\tu32 shift = 0;\n\tu32 mask = 0xFFF;\n\tu32 sclk_dpm_tdp_limit;\n\n\tswitch (index) {\n\tcase 0:\n\t\tregoffset = RCU_SclkDpmTdpLimit01;\n\t\tshift = 16;\n\t\tbreak;\n\tcase 1:\n\t\tregoffset = RCU_SclkDpmTdpLimit01;\n\t\tshift = 0;\n\t\tbreak;\n\tcase 2:\n\t\tregoffset = RCU_SclkDpmTdpLimit23;\n\t\tshift = 16;\n\t\tbreak;\n\tcase 3:\n\t\tregoffset = RCU_SclkDpmTdpLimit23;\n\t\tshift = 0;\n\t\tbreak;\n\tcase 4:\n\t\tregoffset = RCU_SclkDpmTdpLimit47;\n\t\tshift = 16;\n\t\tbreak;\n\tcase 7:\n\t\tregoffset = RCU_SclkDpmTdpLimit47;\n\t\tshift = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsclk_dpm_tdp_limit = RREG32_RCU(regoffset);\n\tsclk_dpm_tdp_limit &= ~(mask << shift);\n\tsclk_dpm_tdp_limit |= (tdp_limit << shift);\n\tWREG32_RCU(regoffset, sclk_dpm_tdp_limit);\n}\n\nvoid sumo_boost_state_enable(struct radeon_device *rdev, bool enable)\n{\n\tu32 boost_disable = RREG32_RCU(RCU_GPU_BOOST_DISABLE);\n\n\tboost_disable &= 0xFFFFFFFE;\n\tboost_disable |= (enable ? 0 : 1);\n\tWREG32_RCU(RCU_GPU_BOOST_DISABLE, boost_disable);\n}\n\nu32 sumo_get_running_fw_version(struct radeon_device *rdev)\n{\n\treturn RREG32_RCU(RCU_FW_VERSION);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}