{
  "module_name": "mkregtable.c",
  "hash_id": "e6f22b59f10db8916d01464cd6d684bf754b8e26c84b70523cff6bfd990e4689",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/mkregtable.c",
  "human_readable_source": "\n \n\n#include <sys/types.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <regex.h>\n#include <libgen.h>\n\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n \n#define container_of(ptr, type, member) ({          \\\n\tconst typeof(((type *)0)->member)*__mptr = (ptr);    \\\n\t\t     (type *)((char *)__mptr - offsetof(type, member)); })\n\n \n\nstruct list_head {\n\tstruct list_head *next, *prev;\n};\n\n\nstatic inline void INIT_LIST_HEAD(struct list_head *list)\n{\n\tlist->next = list;\n\tlist->prev = list;\n}\n\n \n#ifndef CONFIG_DEBUG_LIST\nstatic inline void __list_add(struct list_head *new,\n\t\t\t      struct list_head *prev, struct list_head *next)\n{\n\tnext->prev = new;\n\tnew->next = next;\n\tnew->prev = prev;\n\tprev->next = new;\n}\n#else\nextern void __list_add(struct list_head *new,\n\t\t       struct list_head *prev, struct list_head *next);\n#endif\n\n \nstatic inline void list_add_tail(struct list_head *new, struct list_head *head)\n{\n\t__list_add(new, head->prev, head);\n}\n\n \n#define list_entry(ptr, type, member) \\\n\tcontainer_of(ptr, type, member)\n\n \n#define list_for_each_entry(pos, head, member)\t\t\t\t\\\n\tfor (pos = list_entry((head)->next, typeof(*pos), member);\t\\\n\t     &pos->member != (head); \t\\\n\t     pos = list_entry(pos->member.next, typeof(*pos), member))\n\nstruct offset {\n\tstruct list_head list;\n\tunsigned offset;\n};\n\nstruct table {\n\tstruct list_head offsets;\n\tunsigned offset_max;\n\tunsigned nentry;\n\tunsigned *table;\n\tchar *gpu_prefix;\n};\n\nstatic struct offset *offset_new(unsigned o)\n{\n\tstruct offset *offset;\n\n\toffset = (struct offset *)malloc(sizeof(struct offset));\n\tif (offset) {\n\t\tINIT_LIST_HEAD(&offset->list);\n\t\toffset->offset = o;\n\t}\n\treturn offset;\n}\n\nstatic void table_offset_add(struct table *t, struct offset *offset)\n{\n\tlist_add_tail(&offset->list, &t->offsets);\n}\n\nstatic void table_init(struct table *t)\n{\n\tINIT_LIST_HEAD(&t->offsets);\n\tt->offset_max = 0;\n\tt->nentry = 0;\n\tt->table = NULL;\n}\n\nstatic void table_print(struct table *t)\n{\n\tunsigned nlloop, i, j, n, c, id;\n\n\tnlloop = (t->nentry + 3) / 4;\n\tc = t->nentry;\n\tprintf(\"static const unsigned %s_reg_safe_bm[%d] = {\\n\", t->gpu_prefix,\n\t       t->nentry);\n\tfor (i = 0, id = 0; i < nlloop; i++) {\n\t\tn = 4;\n\t\tif (n > c)\n\t\t\tn = c;\n\t\tc -= n;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (j == 0)\n\t\t\t\tprintf(\"\\t\");\n\t\t\telse\n\t\t\t\tprintf(\" \");\n\t\t\tprintf(\"0x%08X,\", t->table[id++]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"};\\n\");\n}\n\nstatic int table_build(struct table *t)\n{\n\tstruct offset *offset;\n\tunsigned i, m;\n\n\tt->nentry = ((t->offset_max >> 2) + 31) / 32;\n\tt->table = (unsigned *)malloc(sizeof(unsigned) * t->nentry);\n\tif (t->table == NULL)\n\t\treturn -1;\n\tmemset(t->table, 0xff, sizeof(unsigned) * t->nentry);\n\tlist_for_each_entry(offset, &t->offsets, list) {\n\t\ti = (offset->offset >> 2) / 32;\n\t\tm = (offset->offset >> 2) & 31;\n\t\tm = 1 << m;\n\t\tt->table[i] ^= m;\n\t}\n\treturn 0;\n}\n\nstatic char gpu_name[10];\nstatic int parser_auth(struct table *t, const char *filename)\n{\n\tFILE *file;\n\tregex_t mask_rex;\n\tregmatch_t match[4];\n\tchar buf[1024];\n\tsize_t end;\n\tint len;\n\tint done = 0;\n\tint r;\n\tunsigned o;\n\tstruct offset *offset;\n\tchar last_reg_s[10];\n\tint last_reg;\n\n\tif (regcomp\n\t    (&mask_rex, \"(0x[0-9a-fA-F]*) *([_a-zA-Z0-9]*)\", REG_EXTENDED)) {\n\t\tfprintf(stderr, \"Failed to compile regular expression\\n\");\n\t\treturn -1;\n\t}\n\tfile = fopen(filename, \"r\");\n\tif (file == NULL) {\n\t\tfprintf(stderr, \"Failed to open: %s\\n\", filename);\n\t\treturn -1;\n\t}\n\tfseek(file, 0, SEEK_END);\n\tend = ftell(file);\n\tfseek(file, 0, SEEK_SET);\n\n\t \n\tif (fgets(buf, 1024, file) == NULL) {\n\t\tfclose(file);\n\t\treturn -1;\n\t}\n\n\t \n\tsscanf(buf, \"%9s %9s\", gpu_name, last_reg_s);\n\tt->gpu_prefix = gpu_name;\n\tlast_reg = strtol(last_reg_s, NULL, 16);\n\n\tdo {\n\t\tif (fgets(buf, 1024, file) == NULL) {\n\t\t\tfclose(file);\n\t\t\treturn -1;\n\t\t}\n\t\tlen = strlen(buf);\n\t\tif (ftell(file) == end)\n\t\t\tdone = 1;\n\t\tif (len) {\n\t\t\tr = regexec(&mask_rex, buf, 4, match, 0);\n\t\t\tif (r == REG_NOMATCH) {\n\t\t\t} else if (r) {\n\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\"Error matching regular expression %d in %s\\n\",\n\t\t\t\t\tr, filename);\n\t\t\t\tfclose(file);\n\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\tbuf[match[0].rm_eo] = 0;\n\t\t\t\tbuf[match[1].rm_eo] = 0;\n\t\t\t\tbuf[match[2].rm_eo] = 0;\n\t\t\t\to = strtol(&buf[match[1].rm_so], NULL, 16);\n\t\t\t\toffset = offset_new(o);\n\t\t\t\ttable_offset_add(t, offset);\n\t\t\t\tif (o > t->offset_max)\n\t\t\t\t\tt->offset_max = o;\n\t\t\t}\n\t\t}\n\t} while (!done);\n\tfclose(file);\n\tif (t->offset_max < last_reg)\n\t\tt->offset_max = last_reg;\n\treturn table_build(t);\n}\n\nint main(int argc, char *argv[])\n{\n\tstruct table t;\n\n\tif (argc != 2) {\n\t\tfprintf(stderr, \"Usage: %s <authfile>\\n\", argv[0]);\n\t\texit(1);\n\t}\n\ttable_init(&t);\n\tif (parser_auth(&t, argv[1])) {\n\t\tfprintf(stderr, \"Failed to parse file %s\\n\", argv[1]);\n\t\treturn -1;\n\t}\n\ttable_print(&t);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}