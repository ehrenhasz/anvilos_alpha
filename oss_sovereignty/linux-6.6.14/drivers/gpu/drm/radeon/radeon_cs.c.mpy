{
  "module_name": "radeon_cs.c",
  "hash_id": "ccb86ef6055aeeb9f6ecf84718ac89c91921559bbda957cff6dc47f06a11b115",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_cs.c",
  "human_readable_source": " \n\n#include <linux/list_sort.h>\n#include <linux/pci.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon.h\"\n#include \"radeon_reg.h\"\n#include \"radeon_trace.h\"\n\n#define RADEON_CS_MAX_PRIORITY\t\t32u\n#define RADEON_CS_NUM_BUCKETS\t\t(RADEON_CS_MAX_PRIORITY + 1)\n\n \nstruct radeon_cs_buckets {\n\tstruct list_head bucket[RADEON_CS_NUM_BUCKETS];\n};\n\nstatic void radeon_cs_buckets_init(struct radeon_cs_buckets *b)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < RADEON_CS_NUM_BUCKETS; i++)\n\t\tINIT_LIST_HEAD(&b->bucket[i]);\n}\n\nstatic void radeon_cs_buckets_add(struct radeon_cs_buckets *b,\n\t\t\t\t  struct list_head *item, unsigned priority)\n{\n\t \n\tlist_add_tail(item, &b->bucket[min(priority, RADEON_CS_MAX_PRIORITY)]);\n}\n\nstatic void radeon_cs_buckets_get_list(struct radeon_cs_buckets *b,\n\t\t\t\t       struct list_head *out_list)\n{\n\tunsigned i;\n\n\t \n\tfor (i = 0; i < RADEON_CS_NUM_BUCKETS; i++) {\n\t\tlist_splice(&b->bucket[i], out_list);\n\t}\n}\n\nstatic int radeon_cs_parser_relocs(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_chunk *chunk;\n\tstruct radeon_cs_buckets buckets;\n\tunsigned i;\n\tbool need_mmap_lock = false;\n\tint r;\n\n\tif (p->chunk_relocs == NULL) {\n\t\treturn 0;\n\t}\n\tchunk = p->chunk_relocs;\n\tp->dma_reloc_idx = 0;\n\t \n\tp->nrelocs = chunk->length_dw / 4;\n\tp->relocs = kvcalloc(p->nrelocs, sizeof(struct radeon_bo_list),\n\t\t\tGFP_KERNEL);\n\tif (p->relocs == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\n\tradeon_cs_buckets_init(&buckets);\n\n\tfor (i = 0; i < p->nrelocs; i++) {\n\t\tstruct drm_radeon_cs_reloc *r;\n\t\tstruct drm_gem_object *gobj;\n\t\tunsigned priority;\n\n\t\tr = (struct drm_radeon_cs_reloc *)&chunk->kdata[i*4];\n\t\tgobj = drm_gem_object_lookup(p->filp, r->handle);\n\t\tif (gobj == NULL) {\n\t\t\tDRM_ERROR(\"gem object lookup failed 0x%x\\n\",\n\t\t\t\t  r->handle);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tp->relocs[i].robj = gem_to_radeon_bo(gobj);\n\n\t\t \n\t\tpriority = (r->flags & RADEON_RELOC_PRIO_MASK) * 2\n\t\t\t   + !!r->write_domain;\n\n\t\t \n\t\tif (p->ring == R600_RING_TYPE_UVD_INDEX &&\n\t\t    (i <= 0 || pci_find_capability(p->rdev->pdev, PCI_CAP_ID_AGP) ||\n\t\t     p->rdev->family == CHIP_RS780 ||\n\t\t     p->rdev->family == CHIP_RS880)) {\n\n\t\t\t \n\t\t\tp->relocs[i].preferred_domains =\n\t\t\t\tRADEON_GEM_DOMAIN_VRAM;\n\n\t\t\tp->relocs[i].allowed_domains =\n\t\t\t\tRADEON_GEM_DOMAIN_VRAM;\n\n\t\t\t \n\t\t\tpriority = RADEON_CS_MAX_PRIORITY;\n\t\t} else {\n\t\t\tuint32_t domain = r->write_domain ?\n\t\t\t\tr->write_domain : r->read_domains;\n\n\t\t\tif (domain & RADEON_GEM_DOMAIN_CPU) {\n\t\t\t\tDRM_ERROR(\"RADEON_GEM_DOMAIN_CPU is not valid \"\n\t\t\t\t\t  \"for command submission\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tp->relocs[i].preferred_domains = domain;\n\t\t\tif (domain == RADEON_GEM_DOMAIN_VRAM)\n\t\t\t\tdomain |= RADEON_GEM_DOMAIN_GTT;\n\t\t\tp->relocs[i].allowed_domains = domain;\n\t\t}\n\n\t\tif (radeon_ttm_tt_has_userptr(p->rdev, p->relocs[i].robj->tbo.ttm)) {\n\t\t\tuint32_t domain = p->relocs[i].preferred_domains;\n\t\t\tif (!(domain & RADEON_GEM_DOMAIN_GTT)) {\n\t\t\t\tDRM_ERROR(\"Only RADEON_GEM_DOMAIN_GTT is \"\n\t\t\t\t\t  \"allowed for userptr BOs\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tneed_mmap_lock = true;\n\t\t\tdomain = RADEON_GEM_DOMAIN_GTT;\n\t\t\tp->relocs[i].preferred_domains = domain;\n\t\t\tp->relocs[i].allowed_domains = domain;\n\t\t}\n\n\t\t \n\t\tif (p->relocs[i].robj->prime_shared_count) {\n\t\t\tp->relocs[i].allowed_domains &= ~RADEON_GEM_DOMAIN_VRAM;\n\t\t\tif (!p->relocs[i].allowed_domains) {\n\t\t\t\tDRM_ERROR(\"BO associated with dma-buf cannot \"\n\t\t\t\t\t  \"be moved to VRAM\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tp->relocs[i].tv.bo = &p->relocs[i].robj->tbo;\n\t\tp->relocs[i].tv.num_shared = !r->write_domain;\n\n\t\tradeon_cs_buckets_add(&buckets, &p->relocs[i].tv.head,\n\t\t\t\t      priority);\n\t}\n\n\tradeon_cs_buckets_get_list(&buckets, &p->validated);\n\n\tif (p->cs_flags & RADEON_CS_USE_VM)\n\t\tp->vm_bos = radeon_vm_get_bos(p->rdev, p->ib.vm,\n\t\t\t\t\t      &p->validated);\n\tif (need_mmap_lock)\n\t\tmmap_read_lock(current->mm);\n\n\tr = radeon_bo_list_validate(p->rdev, &p->ticket, &p->validated, p->ring);\n\n\tif (need_mmap_lock)\n\t\tmmap_read_unlock(current->mm);\n\n\treturn r;\n}\n\nstatic int radeon_cs_get_ring(struct radeon_cs_parser *p, u32 ring, s32 priority)\n{\n\tp->priority = priority;\n\n\tswitch (ring) {\n\tdefault:\n\t\tDRM_ERROR(\"unknown ring id: %d\\n\", ring);\n\t\treturn -EINVAL;\n\tcase RADEON_CS_RING_GFX:\n\t\tp->ring = RADEON_RING_TYPE_GFX_INDEX;\n\t\tbreak;\n\tcase RADEON_CS_RING_COMPUTE:\n\t\tif (p->rdev->family >= CHIP_TAHITI) {\n\t\t\tif (p->priority > 0)\n\t\t\t\tp->ring = CAYMAN_RING_TYPE_CP1_INDEX;\n\t\t\telse\n\t\t\t\tp->ring = CAYMAN_RING_TYPE_CP2_INDEX;\n\t\t} else\n\t\t\tp->ring = RADEON_RING_TYPE_GFX_INDEX;\n\t\tbreak;\n\tcase RADEON_CS_RING_DMA:\n\t\tif (p->rdev->family >= CHIP_CAYMAN) {\n\t\t\tif (p->priority > 0)\n\t\t\t\tp->ring = R600_RING_TYPE_DMA_INDEX;\n\t\t\telse\n\t\t\t\tp->ring = CAYMAN_RING_TYPE_DMA1_INDEX;\n\t\t} else if (p->rdev->family >= CHIP_RV770) {\n\t\t\tp->ring = R600_RING_TYPE_DMA_INDEX;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_CS_RING_UVD:\n\t\tp->ring = R600_RING_TYPE_UVD_INDEX;\n\t\tbreak;\n\tcase RADEON_CS_RING_VCE:\n\t\t \n\t\tp->ring = TN_RING_TYPE_VCE1_INDEX;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int radeon_cs_sync_rings(struct radeon_cs_parser *p)\n{\n\tstruct radeon_bo_list *reloc;\n\tint r;\n\n\tlist_for_each_entry(reloc, &p->validated, tv.head) {\n\t\tstruct dma_resv *resv;\n\n\t\tresv = reloc->robj->tbo.base.resv;\n\t\tr = radeon_sync_resv(p->rdev, &p->ib.sync, resv,\n\t\t\t\t     reloc->tv.num_shared);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}\n\n \nint radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)\n{\n\tstruct drm_radeon_cs *cs = data;\n\tuint64_t *chunk_array_ptr;\n\tu64 size;\n\tunsigned i;\n\tu32 ring = RADEON_CS_RING_GFX;\n\ts32 priority = 0;\n\n\tINIT_LIST_HEAD(&p->validated);\n\n\tif (!cs->num_chunks) {\n\t\treturn 0;\n\t}\n\n\t \n\tp->idx = 0;\n\tp->ib.sa_bo = NULL;\n\tp->const_ib.sa_bo = NULL;\n\tp->chunk_ib = NULL;\n\tp->chunk_relocs = NULL;\n\tp->chunk_flags = NULL;\n\tp->chunk_const_ib = NULL;\n\tp->chunks_array = kvmalloc_array(cs->num_chunks, sizeof(uint64_t), GFP_KERNEL);\n\tif (p->chunks_array == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\tchunk_array_ptr = (uint64_t *)(unsigned long)(cs->chunks);\n\tif (copy_from_user(p->chunks_array, chunk_array_ptr,\n\t\t\t       sizeof(uint64_t)*cs->num_chunks)) {\n\t\treturn -EFAULT;\n\t}\n\tp->cs_flags = 0;\n\tp->nchunks = cs->num_chunks;\n\tp->chunks = kvcalloc(p->nchunks, sizeof(struct radeon_cs_chunk), GFP_KERNEL);\n\tif (p->chunks == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < p->nchunks; i++) {\n\t\tstruct drm_radeon_cs_chunk __user **chunk_ptr = NULL;\n\t\tstruct drm_radeon_cs_chunk user_chunk;\n\t\tuint32_t __user *cdata;\n\n\t\tchunk_ptr = (void __user*)(unsigned long)p->chunks_array[i];\n\t\tif (copy_from_user(&user_chunk, chunk_ptr,\n\t\t\t\t       sizeof(struct drm_radeon_cs_chunk))) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tp->chunks[i].length_dw = user_chunk.length_dw;\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_RELOCS) {\n\t\t\tp->chunk_relocs = &p->chunks[i];\n\t\t}\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_IB) {\n\t\t\tp->chunk_ib = &p->chunks[i];\n\t\t\t \n\t\t\tif (p->chunks[i].length_dw == 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_CONST_IB) {\n\t\t\tp->chunk_const_ib = &p->chunks[i];\n\t\t\t \n\t\t\tif (p->chunks[i].length_dw == 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_FLAGS) {\n\t\t\tp->chunk_flags = &p->chunks[i];\n\t\t\t \n\t\t\tif (p->chunks[i].length_dw == 0)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsize = p->chunks[i].length_dw;\n\t\tcdata = (void __user *)(unsigned long)user_chunk.chunk_data;\n\t\tp->chunks[i].user_ptr = cdata;\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_CONST_IB)\n\t\t\tcontinue;\n\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_IB) {\n\t\t\tif (!p->rdev || !(p->rdev->flags & RADEON_IS_AGP))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tp->chunks[i].kdata = kvmalloc_array(size, sizeof(uint32_t), GFP_KERNEL);\n\t\tsize *= sizeof(uint32_t);\n\t\tif (p->chunks[i].kdata == NULL) {\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (copy_from_user(p->chunks[i].kdata, cdata, size)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (user_chunk.chunk_id == RADEON_CHUNK_ID_FLAGS) {\n\t\t\tp->cs_flags = p->chunks[i].kdata[0];\n\t\t\tif (p->chunks[i].length_dw > 1)\n\t\t\t\tring = p->chunks[i].kdata[1];\n\t\t\tif (p->chunks[i].length_dw > 2)\n\t\t\t\tpriority = (s32)p->chunks[i].kdata[2];\n\t\t}\n\t}\n\n\t \n\tif (p->rdev) {\n\t\tif ((p->cs_flags & RADEON_CS_USE_VM) &&\n\t\t    !p->rdev->vm_manager.enabled) {\n\t\t\tDRM_ERROR(\"VM not active on asic!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (radeon_cs_get_ring(p, ring, priority))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif ((p->cs_flags & RADEON_CS_USE_VM) == 0) {\n\t\t\tif (p->rdev->asic->ring[p->ring]->cs_parse == NULL) {\n\t\t\t\tDRM_ERROR(\"Ring %d requires VM!\\n\", p->ring);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (p->rdev->asic->ring[p->ring]->ib_parse == NULL) {\n\t\t\t\tDRM_ERROR(\"VM not supported on ring %d!\\n\",\n\t\t\t\t\t  p->ring);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cmp_size_smaller_first(void *priv, const struct list_head *a,\n\t\t\t\t  const struct list_head *b)\n{\n\tstruct radeon_bo_list *la = list_entry(a, struct radeon_bo_list, tv.head);\n\tstruct radeon_bo_list *lb = list_entry(b, struct radeon_bo_list, tv.head);\n\n\t \n\tif (la->robj->tbo.base.size > lb->robj->tbo.base.size)\n\t\treturn 1;\n\tif (la->robj->tbo.base.size < lb->robj->tbo.base.size)\n\t\treturn -1;\n\treturn 0;\n}\n\n \nstatic void radeon_cs_parser_fini(struct radeon_cs_parser *parser, int error, bool backoff)\n{\n\tunsigned i;\n\n\tif (!error) {\n\t\t \n\t\tlist_sort(NULL, &parser->validated, cmp_size_smaller_first);\n\n\t\tttm_eu_fence_buffer_objects(&parser->ticket,\n\t\t\t\t\t    &parser->validated,\n\t\t\t\t\t    &parser->ib.fence->base);\n\t} else if (backoff) {\n\t\tttm_eu_backoff_reservation(&parser->ticket,\n\t\t\t\t\t   &parser->validated);\n\t}\n\n\tif (parser->relocs != NULL) {\n\t\tfor (i = 0; i < parser->nrelocs; i++) {\n\t\t\tstruct radeon_bo *bo = parser->relocs[i].robj;\n\t\t\tif (bo == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tdrm_gem_object_put(&bo->tbo.base);\n\t\t}\n\t}\n\tkfree(parser->track);\n\tkvfree(parser->relocs);\n\tkvfree(parser->vm_bos);\n\tfor (i = 0; i < parser->nchunks; i++)\n\t\tkvfree(parser->chunks[i].kdata);\n\tkvfree(parser->chunks);\n\tkvfree(parser->chunks_array);\n\tradeon_ib_free(parser->rdev, &parser->ib);\n\tradeon_ib_free(parser->rdev, &parser->const_ib);\n}\n\nstatic int radeon_cs_ib_chunk(struct radeon_device *rdev,\n\t\t\t      struct radeon_cs_parser *parser)\n{\n\tint r;\n\n\tif (parser->chunk_ib == NULL)\n\t\treturn 0;\n\n\tif (parser->cs_flags & RADEON_CS_USE_VM)\n\t\treturn 0;\n\n\tr = radeon_cs_parse(rdev, parser->ring, parser);\n\tif (r || parser->parser_error) {\n\t\tDRM_ERROR(\"Invalid command stream !\\n\");\n\t\treturn r;\n\t}\n\n\tr = radeon_cs_sync_rings(parser);\n\tif (r) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"Failed to sync rings: %i\\n\", r);\n\t\treturn r;\n\t}\n\n\tif (parser->ring == R600_RING_TYPE_UVD_INDEX)\n\t\tradeon_uvd_note_usage(rdev);\n\telse if ((parser->ring == TN_RING_TYPE_VCE1_INDEX) ||\n\t\t (parser->ring == TN_RING_TYPE_VCE2_INDEX))\n\t\tradeon_vce_note_usage(rdev);\n\n\tr = radeon_ib_schedule(rdev, &parser->ib, NULL, true);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to schedule IB !\\n\");\n\t}\n\treturn r;\n}\n\nstatic int radeon_bo_vm_update_pte(struct radeon_cs_parser *p,\n\t\t\t\t   struct radeon_vm *vm)\n{\n\tstruct radeon_device *rdev = p->rdev;\n\tstruct radeon_bo_va *bo_va;\n\tint i, r;\n\n\tr = radeon_vm_update_page_directory(rdev, vm);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_vm_clear_freed(rdev, vm);\n\tif (r)\n\t\treturn r;\n\n\tif (vm->ib_bo_va == NULL) {\n\t\tDRM_ERROR(\"Tmp BO not in VM!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tr = radeon_vm_bo_update(rdev, vm->ib_bo_va,\n\t\t\t\trdev->ring_tmp_bo.bo->tbo.resource);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < p->nrelocs; i++) {\n\t\tstruct radeon_bo *bo;\n\n\t\tbo = p->relocs[i].robj;\n\t\tbo_va = radeon_vm_bo_find(vm, bo);\n\t\tif (bo_va == NULL) {\n\t\t\tdev_err(rdev->dev, \"bo %p not in vm %p\\n\", bo, vm);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tr = radeon_vm_bo_update(rdev, bo_va, bo->tbo.resource);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tradeon_sync_fence(&p->ib.sync, bo_va->last_pt_update);\n\n\t\tr = dma_resv_reserve_fences(bo->tbo.base.resv, 1);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn radeon_vm_clear_invalids(rdev, vm);\n}\n\nstatic int radeon_cs_ib_vm_chunk(struct radeon_device *rdev,\n\t\t\t\t struct radeon_cs_parser *parser)\n{\n\tstruct radeon_fpriv *fpriv = parser->filp->driver_priv;\n\tstruct radeon_vm *vm = &fpriv->vm;\n\tint r;\n\n\tif (parser->chunk_ib == NULL)\n\t\treturn 0;\n\tif ((parser->cs_flags & RADEON_CS_USE_VM) == 0)\n\t\treturn 0;\n\n\tif (parser->const_ib.length_dw) {\n\t\tr = radeon_ring_ib_parse(rdev, parser->ring, &parser->const_ib);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = radeon_ring_ib_parse(rdev, parser->ring, &parser->ib);\n\tif (r) {\n\t\treturn r;\n\t}\n\n\tif (parser->ring == R600_RING_TYPE_UVD_INDEX)\n\t\tradeon_uvd_note_usage(rdev);\n\n\tmutex_lock(&vm->mutex);\n\tr = radeon_bo_vm_update_pte(parser, vm);\n\tif (r) {\n\t\tgoto out;\n\t}\n\n\tr = radeon_cs_sync_rings(parser);\n\tif (r) {\n\t\tif (r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"Failed to sync rings: %i\\n\", r);\n\t\tgoto out;\n\t}\n\n\tif ((rdev->family >= CHIP_TAHITI) &&\n\t    (parser->chunk_const_ib != NULL)) {\n\t\tr = radeon_ib_schedule(rdev, &parser->ib, &parser->const_ib, true);\n\t} else {\n\t\tr = radeon_ib_schedule(rdev, &parser->ib, NULL, true);\n\t}\n\nout:\n\tmutex_unlock(&vm->mutex);\n\treturn r;\n}\n\nstatic int radeon_cs_handle_lockup(struct radeon_device *rdev, int r)\n{\n\tif (r == -EDEADLK) {\n\t\tr = radeon_gpu_reset(rdev);\n\t\tif (!r)\n\t\t\tr = -EAGAIN;\n\t}\n\treturn r;\n}\n\nstatic int radeon_cs_ib_fill(struct radeon_device *rdev, struct radeon_cs_parser *parser)\n{\n\tstruct radeon_cs_chunk *ib_chunk;\n\tstruct radeon_vm *vm = NULL;\n\tint r;\n\n\tif (parser->chunk_ib == NULL)\n\t\treturn 0;\n\n\tif (parser->cs_flags & RADEON_CS_USE_VM) {\n\t\tstruct radeon_fpriv *fpriv = parser->filp->driver_priv;\n\t\tvm = &fpriv->vm;\n\n\t\tif ((rdev->family >= CHIP_TAHITI) &&\n\t\t    (parser->chunk_const_ib != NULL)) {\n\t\t\tib_chunk = parser->chunk_const_ib;\n\t\t\tif (ib_chunk->length_dw > RADEON_IB_VM_MAX_SIZE) {\n\t\t\t\tDRM_ERROR(\"cs IB CONST too big: %d\\n\", ib_chunk->length_dw);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tr =  radeon_ib_get(rdev, parser->ring, &parser->const_ib,\n\t\t\t\t\t   vm, ib_chunk->length_dw * 4);\n\t\t\tif (r) {\n\t\t\t\tDRM_ERROR(\"Failed to get const ib !\\n\");\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tparser->const_ib.is_const_ib = true;\n\t\t\tparser->const_ib.length_dw = ib_chunk->length_dw;\n\t\t\tif (copy_from_user(parser->const_ib.ptr,\n\t\t\t\t\t       ib_chunk->user_ptr,\n\t\t\t\t\t       ib_chunk->length_dw * 4))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tib_chunk = parser->chunk_ib;\n\t\tif (ib_chunk->length_dw > RADEON_IB_VM_MAX_SIZE) {\n\t\t\tDRM_ERROR(\"cs IB too big: %d\\n\", ib_chunk->length_dw);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tib_chunk = parser->chunk_ib;\n\n\tr =  radeon_ib_get(rdev, parser->ring, &parser->ib,\n\t\t\t   vm, ib_chunk->length_dw * 4);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to get ib !\\n\");\n\t\treturn r;\n\t}\n\tparser->ib.length_dw = ib_chunk->length_dw;\n\tif (ib_chunk->kdata)\n\t\tmemcpy(parser->ib.ptr, ib_chunk->kdata, ib_chunk->length_dw * 4);\n\telse if (copy_from_user(parser->ib.ptr, ib_chunk->user_ptr, ib_chunk->length_dw * 4))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint radeon_cs_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_cs_parser parser;\n\tint r;\n\n\tdown_read(&rdev->exclusive_lock);\n\tif (!rdev->accel_working) {\n\t\tup_read(&rdev->exclusive_lock);\n\t\treturn -EBUSY;\n\t}\n\tif (rdev->in_reset) {\n\t\tup_read(&rdev->exclusive_lock);\n\t\tr = radeon_gpu_reset(rdev);\n\t\tif (!r)\n\t\t\tr = -EAGAIN;\n\t\treturn r;\n\t}\n\t \n\tmemset(&parser, 0, sizeof(struct radeon_cs_parser));\n\tparser.filp = filp;\n\tparser.rdev = rdev;\n\tparser.dev = rdev->dev;\n\tparser.family = rdev->family;\n\tr = radeon_cs_parser_init(&parser, data);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to initialize parser !\\n\");\n\t\tradeon_cs_parser_fini(&parser, r, false);\n\t\tup_read(&rdev->exclusive_lock);\n\t\tr = radeon_cs_handle_lockup(rdev, r);\n\t\treturn r;\n\t}\n\n\tr = radeon_cs_ib_fill(rdev, &parser);\n\tif (!r) {\n\t\tr = radeon_cs_parser_relocs(&parser);\n\t\tif (r && r != -ERESTARTSYS)\n\t\t\tDRM_ERROR(\"Failed to parse relocation %d!\\n\", r);\n\t}\n\n\tif (r) {\n\t\tradeon_cs_parser_fini(&parser, r, false);\n\t\tup_read(&rdev->exclusive_lock);\n\t\tr = radeon_cs_handle_lockup(rdev, r);\n\t\treturn r;\n\t}\n\n\ttrace_radeon_cs(&parser);\n\n\tr = radeon_cs_ib_chunk(rdev, &parser);\n\tif (r) {\n\t\tgoto out;\n\t}\n\tr = radeon_cs_ib_vm_chunk(rdev, &parser);\n\tif (r) {\n\t\tgoto out;\n\t}\nout:\n\tradeon_cs_parser_fini(&parser, r, true);\n\tup_read(&rdev->exclusive_lock);\n\tr = radeon_cs_handle_lockup(rdev, r);\n\treturn r;\n}\n\n \nint radeon_cs_packet_parse(struct radeon_cs_parser *p,\n\t\t\t   struct radeon_cs_packet *pkt,\n\t\t\t   unsigned idx)\n{\n\tstruct radeon_cs_chunk *ib_chunk = p->chunk_ib;\n\tstruct radeon_device *rdev = p->rdev;\n\tuint32_t header;\n\tint ret = 0, i;\n\n\tif (idx >= ib_chunk->length_dw) {\n\t\tDRM_ERROR(\"Can not parse packet at %d after CS end %d !\\n\",\n\t\t\t  idx, ib_chunk->length_dw);\n\t\treturn -EINVAL;\n\t}\n\theader = radeon_get_ib_value(p, idx);\n\tpkt->idx = idx;\n\tpkt->type = RADEON_CP_PACKET_GET_TYPE(header);\n\tpkt->count = RADEON_CP_PACKET_GET_COUNT(header);\n\tpkt->one_reg_wr = 0;\n\tswitch (pkt->type) {\n\tcase RADEON_PACKET_TYPE0:\n\t\tif (rdev->family < CHIP_R600) {\n\t\t\tpkt->reg = R100_CP_PACKET0_GET_REG(header);\n\t\t\tpkt->one_reg_wr =\n\t\t\t\tRADEON_CP_PACKET0_GET_ONE_REG_WR(header);\n\t\t} else\n\t\t\tpkt->reg = R600_CP_PACKET0_GET_REG(header);\n\t\tbreak;\n\tcase RADEON_PACKET_TYPE3:\n\t\tpkt->opcode = RADEON_CP_PACKET3_GET_OPCODE(header);\n\t\tbreak;\n\tcase RADEON_PACKET_TYPE2:\n\t\tpkt->count = -1;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown packet type %d at %d !\\n\", pkt->type, idx);\n\t\tret = -EINVAL;\n\t\tgoto dump_ib;\n\t}\n\tif ((pkt->count + 1 + pkt->idx) >= ib_chunk->length_dw) {\n\t\tDRM_ERROR(\"Packet (%d:%d:%d) end after CS buffer (%d) !\\n\",\n\t\t\t  pkt->idx, pkt->type, pkt->count, ib_chunk->length_dw);\n\t\tret = -EINVAL;\n\t\tgoto dump_ib;\n\t}\n\treturn 0;\n\ndump_ib:\n\tfor (i = 0; i < ib_chunk->length_dw; i++) {\n\t\tif (i == idx)\n\t\t\tprintk(\"\\t0x%08x <---\\n\", radeon_get_ib_value(p, i));\n\t\telse\n\t\t\tprintk(\"\\t0x%08x\\n\", radeon_get_ib_value(p, i));\n\t}\n\treturn ret;\n}\n\n \nbool radeon_cs_packet_next_is_pkt3_nop(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_packet p3reloc;\n\tint r;\n\n\tr = radeon_cs_packet_parse(p, &p3reloc, p->idx);\n\tif (r)\n\t\treturn false;\n\tif (p3reloc.type != RADEON_PACKET_TYPE3)\n\t\treturn false;\n\tif (p3reloc.opcode != RADEON_PACKET3_NOP)\n\t\treturn false;\n\treturn true;\n}\n\n \nvoid radeon_cs_dump_packet(struct radeon_cs_parser *p,\n\t\t\t   struct radeon_cs_packet *pkt)\n{\n\tvolatile uint32_t *ib;\n\tunsigned i;\n\tunsigned idx;\n\n\tib = p->ib.ptr;\n\tidx = pkt->idx;\n\tfor (i = 0; i <= (pkt->count + 1); i++, idx++)\n\t\tDRM_INFO(\"ib[%d]=0x%08X\\n\", idx, ib[idx]);\n}\n\n \nint radeon_cs_packet_next_reloc(struct radeon_cs_parser *p,\n\t\t\t\tstruct radeon_bo_list **cs_reloc,\n\t\t\t\tint nomm)\n{\n\tstruct radeon_cs_chunk *relocs_chunk;\n\tstruct radeon_cs_packet p3reloc;\n\tunsigned idx;\n\tint r;\n\n\tif (p->chunk_relocs == NULL) {\n\t\tDRM_ERROR(\"No relocation chunk !\\n\");\n\t\treturn -EINVAL;\n\t}\n\t*cs_reloc = NULL;\n\trelocs_chunk = p->chunk_relocs;\n\tr = radeon_cs_packet_parse(p, &p3reloc, p->idx);\n\tif (r)\n\t\treturn r;\n\tp->idx += p3reloc.count + 2;\n\tif (p3reloc.type != RADEON_PACKET_TYPE3 ||\n\t    p3reloc.opcode != RADEON_PACKET3_NOP) {\n\t\tDRM_ERROR(\"No packet3 for relocation for packet at %d.\\n\",\n\t\t\t  p3reloc.idx);\n\t\tradeon_cs_dump_packet(p, &p3reloc);\n\t\treturn -EINVAL;\n\t}\n\tidx = radeon_get_ib_value(p, p3reloc.idx + 1);\n\tif (idx >= relocs_chunk->length_dw) {\n\t\tDRM_ERROR(\"Relocs at %d after relocations chunk end %d !\\n\",\n\t\t\t  idx, relocs_chunk->length_dw);\n\t\tradeon_cs_dump_packet(p, &p3reloc);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (nomm) {\n\t\t*cs_reloc = p->relocs;\n\t\t(*cs_reloc)->gpu_offset =\n\t\t\t(u64)relocs_chunk->kdata[idx + 3] << 32;\n\t\t(*cs_reloc)->gpu_offset |= relocs_chunk->kdata[idx + 0];\n\t} else\n\t\t*cs_reloc = &p->relocs[(idx / 4)];\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}