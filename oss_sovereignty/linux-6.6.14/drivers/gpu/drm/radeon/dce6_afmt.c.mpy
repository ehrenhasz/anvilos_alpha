{
  "module_name": "dce6_afmt.c",
  "hash_id": "4c98569acf09d462c39c486ad9fd5aed02e602e10470aaff470df310936ca348",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/dce6_afmt.c",
  "human_readable_source": " \n#include <linux/hdmi.h>\n\n#include \"dce6_afmt.h\"\n#include \"radeon.h\"\n#include \"radeon_audio.h\"\n#include \"sid.h\"\n\n#define DCE8_DCCG_AUDIO_DTO1_PHASE\t0x05b8\n#define DCE8_DCCG_AUDIO_DTO1_MODULE\t0x05bc\n\nu32 dce6_endpoint_rreg(struct radeon_device *rdev,\n\t\t\t      u32 block_offset, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->end_idx_lock, flags);\n\tWREG32(AZ_F0_CODEC_ENDPOINT_INDEX + block_offset, reg);\n\tr = RREG32(AZ_F0_CODEC_ENDPOINT_DATA + block_offset);\n\tspin_unlock_irqrestore(&rdev->end_idx_lock, flags);\n\n\treturn r;\n}\n\nvoid dce6_endpoint_wreg(struct radeon_device *rdev,\n\t\t\t       u32 block_offset, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->end_idx_lock, flags);\n\tif (ASIC_IS_DCE8(rdev))\n\t\tWREG32(AZ_F0_CODEC_ENDPOINT_INDEX + block_offset, reg);\n\telse\n\t\tWREG32(AZ_F0_CODEC_ENDPOINT_INDEX + block_offset,\n\t\t       AZ_ENDPOINT_REG_WRITE_EN | AZ_ENDPOINT_REG_INDEX(reg));\n\tWREG32(AZ_F0_CODEC_ENDPOINT_DATA + block_offset, v);\n\tspin_unlock_irqrestore(&rdev->end_idx_lock, flags);\n}\n\nstatic void dce6_afmt_get_connected_pins(struct radeon_device *rdev)\n{\n\tint i;\n\tu32 offset, tmp;\n\n\tfor (i = 0; i < rdev->audio.num_pins; i++) {\n\t\toffset = rdev->audio.pin[i].offset;\n\t\ttmp = RREG32_ENDPOINT(offset,\n\t\t\t\t      AZ_F0_CODEC_PIN_CONTROL_RESPONSE_CONFIGURATION_DEFAULT);\n\t\tif (((tmp & PORT_CONNECTIVITY_MASK) >> PORT_CONNECTIVITY_SHIFT) == 1)\n\t\t\trdev->audio.pin[i].connected = false;\n\t\telse\n\t\t\trdev->audio.pin[i].connected = true;\n\t}\n}\n\nstruct r600_audio_pin *dce6_audio_get_pin(struct radeon_device *rdev)\n{\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct radeon_encoder_atom_dig *dig;\n\tstruct r600_audio_pin *pin = NULL;\n\tint i, pin_count;\n\n\tdce6_afmt_get_connected_pins(rdev);\n\n\tfor (i = 0; i < rdev->audio.num_pins; i++) {\n\t\tif (rdev->audio.pin[i].connected) {\n\t\t\tpin = &rdev->audio.pin[i];\n\t\t\tpin_count = 0;\n\n\t\t\tlist_for_each_entry(encoder, &rdev->ddev->mode_config.encoder_list, head) {\n\t\t\t\tif (radeon_encoder_is_digital(encoder)) {\n\t\t\t\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\t\t\t\tdig = radeon_encoder->enc_priv;\n\t\t\t\t\tif (dig->pin == pin)\n\t\t\t\t\t\tpin_count++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (pin_count == 0)\n\t\t\t\treturn pin;\n\t\t}\n\t}\n\tif (!pin)\n\t\tDRM_ERROR(\"No connected audio pins found!\\n\");\n\treturn pin;\n}\n\nvoid dce6_afmt_select_pin(struct drm_encoder *encoder)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\tif (!dig || !dig->afmt || !dig->pin)\n\t\treturn;\n\n\tWREG32(AFMT_AUDIO_SRC_CONTROL +  dig->afmt->offset,\n\t       AFMT_AUDIO_SRC_SELECT(dig->pin->id));\n}\n\nvoid dce6_afmt_write_latency_fields(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_connector *connector,\n\t\t\t\t    struct drm_display_mode *mode)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tu32 tmp = 0;\n\n\tif (!dig || !dig->afmt || !dig->pin)\n\t\treturn;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tif (connector->latency_present[1])\n\t\t\ttmp = VIDEO_LIPSYNC(connector->video_latency[1]) |\n\t\t\t\tAUDIO_LIPSYNC(connector->audio_latency[1]);\n\t\telse\n\t\t\ttmp = VIDEO_LIPSYNC(0) | AUDIO_LIPSYNC(0);\n\t} else {\n\t\tif (connector->latency_present[0])\n\t\t\ttmp = VIDEO_LIPSYNC(connector->video_latency[0]) |\n\t\t\t\tAUDIO_LIPSYNC(connector->audio_latency[0]);\n\t\telse\n\t\t\ttmp = VIDEO_LIPSYNC(0) | AUDIO_LIPSYNC(0);\n\t}\n\tWREG32_ENDPOINT(dig->pin->offset,\n\t\t\tAZ_F0_CODEC_PIN_CONTROL_RESPONSE_LIPSYNC, tmp);\n}\n\nvoid dce6_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,\n\t\t\t\t\t     u8 *sadb, int sad_count)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tu32 tmp;\n\n\tif (!dig || !dig->afmt || !dig->pin)\n\t\treturn;\n\n\t \n\ttmp = RREG32_ENDPOINT(dig->pin->offset,\n\t\t\t      AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);\n\ttmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\n\t \n\ttmp |= HDMI_CONNECTION;\n\tif (sad_count)\n\t\ttmp |= SPEAKER_ALLOCATION(sadb[0]);\n\telse\n\t\ttmp |= SPEAKER_ALLOCATION(5);  \n\tWREG32_ENDPOINT(dig->pin->offset,\n\t\t\tAZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, tmp);\n}\n\nvoid dce6_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,\n\t\t\t\t\t   u8 *sadb, int sad_count)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tu32 tmp;\n\n\tif (!dig || !dig->afmt || !dig->pin)\n\t\treturn;\n\n\t \n\ttmp = RREG32_ENDPOINT(dig->pin->offset,\n\t\t\t      AZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER);\n\ttmp &= ~(HDMI_CONNECTION | SPEAKER_ALLOCATION_MASK);\n\t \n\ttmp |= DP_CONNECTION;\n\tif (sad_count)\n\t\ttmp |= SPEAKER_ALLOCATION(sadb[0]);\n\telse\n\t\ttmp |= SPEAKER_ALLOCATION(5);  \n\tWREG32_ENDPOINT(dig->pin->offset,\n\t\t\tAZ_F0_CODEC_PIN_CONTROL_CHANNEL_SPEAKER, tmp);\n}\n\nvoid dce6_afmt_write_sad_regs(struct drm_encoder *encoder,\n\t\t\t      struct cea_sad *sads, int sad_count)\n{\n\tint i;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstatic const u16 eld_reg_to_type[][2] = {\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\n\t\t{ AZ_F0_CODEC_PIN_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\n\t};\n\n\tif (!dig || !dig->afmt || !dig->pin)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\n\t\tu32 value = 0;\n\t\tu8 stereo_freqs = 0;\n\t\tint max_channels = -1;\n\t\tint j;\n\n\t\tfor (j = 0; j < sad_count; j++) {\n\t\t\tstruct cea_sad *sad = &sads[j];\n\n\t\t\tif (sad->format == eld_reg_to_type[i][1]) {\n\t\t\t\tif (sad->channels > max_channels) {\n\t\t\t\t\tvalue = MAX_CHANNELS(sad->channels) |\n\t\t\t\t\t\tDESCRIPTOR_BYTE_2(sad->byte2) |\n\t\t\t\t\t\tSUPPORTED_FREQUENCIES(sad->freq);\n\t\t\t\t\tmax_channels = sad->channels;\n\t\t\t\t}\n\n\t\t\t\tif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\n\t\t\t\t\tstereo_freqs |= sad->freq;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\n\n\t\tWREG32_ENDPOINT(dig->pin->offset, eld_reg_to_type[i][0], value);\n\t}\n}\n\nvoid dce6_audio_enable(struct radeon_device *rdev,\n\t\t       struct r600_audio_pin *pin,\n\t\t       u8 enable_mask)\n{\n\tif (!pin)\n\t\treturn;\n\n\tWREG32_ENDPOINT(pin->offset, AZ_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL,\n\t\t\tenable_mask ? AUDIO_ENABLED : 0);\n}\n\nvoid dce6_hdmi_audio_set_dto(struct radeon_device *rdev,\n\t\t\t     struct radeon_crtc *crtc, unsigned int clock)\n{\n\t \n\tu32 value = 0;\n\n\tif (crtc)\n\t\tvalue |= DCCG_AUDIO_DTO0_SOURCE_SEL(crtc->crtc_id);\n\n\tWREG32(DCCG_AUDIO_DTO_SOURCE, value);\n\n\t \n\tWREG32(DCCG_AUDIO_DTO0_PHASE, 24000);\n\tWREG32(DCCG_AUDIO_DTO0_MODULE, clock);\n}\n\nvoid dce6_dp_audio_set_dto(struct radeon_device *rdev,\n\t\t\t   struct radeon_crtc *crtc, unsigned int clock)\n{\n\t \n\tu32 value = 0;\n\tvalue |= DCCG_AUDIO_DTO_SEL;\n\n\tif (crtc)\n\t\tvalue |= DCCG_AUDIO_DTO0_SOURCE_SEL(crtc->crtc_id);\n\n\tWREG32(DCCG_AUDIO_DTO_SOURCE, value);\n\n\t \n\tif (ASIC_IS_DCE8(rdev)) {\n\t\tunsigned int div = (RREG32(DENTIST_DISPCLK_CNTL) &\n\t\t\tDENTIST_DPREFCLK_WDIVIDER_MASK) >>\n\t\t\tDENTIST_DPREFCLK_WDIVIDER_SHIFT;\n\t\tdiv = radeon_audio_decode_dfs_div(div);\n\n\t\tif (div)\n\t\t\tclock = clock * 100 / div;\n\n\t\tWREG32(DCE8_DCCG_AUDIO_DTO1_PHASE, 24000);\n\t\tWREG32(DCE8_DCCG_AUDIO_DTO1_MODULE, clock);\n\t} else {\n\t\tWREG32(DCCG_AUDIO_DTO1_PHASE, 24000);\n\t\tWREG32(DCCG_AUDIO_DTO1_MODULE, clock);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}