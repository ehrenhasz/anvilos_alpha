{
  "module_name": "rs780_dpm.c",
  "hash_id": "6d5ee2be85c92ff1d8386740dbe6c08f542cbbae925f3cdbf6bc3627ba7a2eb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rs780_dpm.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n\n#include \"atom.h\"\n#include \"r600_dpm.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"rs780_dpm.h\"\n#include \"rs780d.h\"\n\nstatic struct igp_ps *rs780_get_ps(struct radeon_ps *rps)\n{\n\tstruct igp_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstatic struct igp_power_info *rs780_get_pi(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic void rs780_get_pm_mode_parameters(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\tstruct radeon_mode_info *minfo = &rdev->mode_info;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tint i;\n\n\t \n\tpi->crtc_id = 0;\n\tpi->refresh_rate = 60;\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tcrtc = (struct drm_crtc *)minfo->crtcs[i];\n\t\tif (crtc && crtc->enabled) {\n\t\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\t\tpi->crtc_id = radeon_crtc->crtc_id;\n\t\t\tif (crtc->mode.htotal && crtc->mode.vtotal)\n\t\t\t\tpi->refresh_rate = drm_mode_vrefresh(&crtc->mode);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void rs780_voltage_scaling_enable(struct radeon_device *rdev, bool enable);\n\nstatic int rs780_initialize_dpm_power_state(struct radeon_device *rdev,\n\t\t\t\t\t    struct radeon_ps *boot_ps)\n{\n\tstruct atom_clock_dividers dividers;\n\tstruct igp_ps *default_state = rs780_get_ps(boot_ps);\n\tint i, ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     default_state->sclk_low, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tr600_engine_clock_entry_set_reference_divider(rdev, 0, dividers.ref_div);\n\tr600_engine_clock_entry_set_feedback_divider(rdev, 0, dividers.fb_div);\n\tr600_engine_clock_entry_set_post_divider(rdev, 0, dividers.post_div);\n\n\tif (dividers.enable_post_div)\n\t\tr600_engine_clock_entry_enable_post_divider(rdev, 0, true);\n\telse\n\t\tr600_engine_clock_entry_enable_post_divider(rdev, 0, false);\n\n\tr600_engine_clock_entry_set_step_time(rdev, 0, R600_SST_DFLT);\n\tr600_engine_clock_entry_enable_pulse_skipping(rdev, 0, false);\n\n\tr600_engine_clock_entry_enable(rdev, 0, true);\n\tfor (i = 1; i < R600_PM_NUMBER_OF_SCLKS; i++)\n\t\tr600_engine_clock_entry_enable(rdev, i, false);\n\n\tr600_enable_mclk_control(rdev, false);\n\tr600_voltage_control_enable_pins(rdev, 0);\n\n\treturn 0;\n}\n\nstatic int rs780_initialize_dpm_parameters(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *boot_ps)\n{\n\tint ret = 0;\n\tint i;\n\n\tr600_set_bsp(rdev, R600_BSU_DFLT, R600_BSP_DFLT);\n\n\tr600_set_at(rdev, 0, 0, 0, 0);\n\n\tr600_set_git(rdev, R600_GICST_DFLT);\n\n\tfor (i = 0; i < R600_PM_NUMBER_OF_TC; i++)\n\t\tr600_set_tc(rdev, i, 0, 0);\n\n\tr600_select_td(rdev, R600_TD_DFLT);\n\tr600_set_vrc(rdev, 0);\n\n\tr600_set_tpu(rdev, R600_TPU_DFLT);\n\tr600_set_tpc(rdev, R600_TPC_DFLT);\n\n\tr600_set_sstu(rdev, R600_SSTU_DFLT);\n\tr600_set_sst(rdev, R600_SST_DFLT);\n\n\tr600_set_fctu(rdev, R600_FCTU_DFLT);\n\tr600_set_fct(rdev, R600_FCT_DFLT);\n\n\tr600_set_vddc3d_oorsu(rdev, R600_VDDC3DOORSU_DFLT);\n\tr600_set_vddc3d_oorphc(rdev, R600_VDDC3DOORPHC_DFLT);\n\tr600_set_vddc3d_oorsdc(rdev, R600_VDDC3DOORSDC_DFLT);\n\tr600_set_ctxcgtt3d_rphc(rdev, R600_CTXCGTT3DRPHC_DFLT);\n\tr600_set_ctxcgtt3d_rsdc(rdev, R600_CTXCGTT3DRSDC_DFLT);\n\n\tr600_vid_rt_set_vru(rdev, R600_VRU_DFLT);\n\tr600_vid_rt_set_vrt(rdev, R600_VOLTAGERESPONSETIME_DFLT);\n\tr600_vid_rt_set_ssu(rdev, R600_SPLLSTEPUNIT_DFLT);\n\n\tret = rs780_initialize_dpm_power_state(rdev, boot_ps);\n\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_LOW,     0);\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_MEDIUM,  0);\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_HIGH,    0);\n\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_LOW,    0);\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_MEDIUM, 0);\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_HIGH,   0);\n\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_LOW,    0);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_MEDIUM, 0);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_HIGH,   0);\n\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_LOW,    R600_DISPLAY_WATERMARK_HIGH);\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_MEDIUM, R600_DISPLAY_WATERMARK_HIGH);\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_HIGH,   R600_DISPLAY_WATERMARK_HIGH);\n\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_CTXSW, false);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\n\n\tr600_power_level_set_enter_index(rdev, R600_POWER_LEVEL_LOW);\n\n\tr600_set_vrc(rdev, RS780_CGFTV_DFLT);\n\n\treturn ret;\n}\n\nstatic void rs780_start_dpm(struct radeon_device *rdev)\n{\n\tr600_enable_sclk_control(rdev, false);\n\tr600_enable_mclk_control(rdev, false);\n\n\tr600_dynamicpm_enable(rdev, true);\n\n\tradeon_wait_for_vblank(rdev, 0);\n\tradeon_wait_for_vblank(rdev, 1);\n\n\tr600_enable_spll_bypass(rdev, true);\n\tr600_wait_for_spll_change(rdev);\n\tr600_enable_spll_bypass(rdev, false);\n\tr600_wait_for_spll_change(rdev);\n\n\tr600_enable_spll_bypass(rdev, true);\n\tr600_wait_for_spll_change(rdev);\n\tr600_enable_spll_bypass(rdev, false);\n\tr600_wait_for_spll_change(rdev);\n\n\tr600_enable_sclk_control(rdev, true);\n}\n\n\nstatic void rs780_preset_ranges_slow_clk_fbdiv_en(struct radeon_device *rdev)\n{\n\tWREG32_P(FVTHROT_SLOW_CLK_FEEDBACK_DIV_REG1, RANGE_SLOW_CLK_FEEDBACK_DIV_EN,\n\t\t ~RANGE_SLOW_CLK_FEEDBACK_DIV_EN);\n\n\tWREG32_P(FVTHROT_SLOW_CLK_FEEDBACK_DIV_REG1,\n\t\t RANGE0_SLOW_CLK_FEEDBACK_DIV(RS780_SLOWCLKFEEDBACKDIV_DFLT),\n\t\t ~RANGE0_SLOW_CLK_FEEDBACK_DIV_MASK);\n}\n\nstatic void rs780_preset_starting_fbdiv(struct radeon_device *rdev)\n{\n\tu32 fbdiv = (RREG32(CG_SPLL_FUNC_CNTL) & SPLL_FB_DIV_MASK) >> SPLL_FB_DIV_SHIFT;\n\n\tWREG32_P(FVTHROT_FBDIV_REG1, STARTING_FEEDBACK_DIV(fbdiv),\n\t\t ~STARTING_FEEDBACK_DIV_MASK);\n\n\tWREG32_P(FVTHROT_FBDIV_REG2, FORCED_FEEDBACK_DIV(fbdiv),\n\t\t ~FORCED_FEEDBACK_DIV_MASK);\n\n\tWREG32_P(FVTHROT_FBDIV_REG1, FORCE_FEEDBACK_DIV, ~FORCE_FEEDBACK_DIV);\n}\n\nstatic void rs780_voltage_scaling_init(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\tu32 fv_throt_pwm_fb_div_range[3];\n\tu32 fv_throt_pwm_range[4];\n\n\tif (rdev->pdev->device == 0x9614) {\n\t\tfv_throt_pwm_fb_div_range[0] = RS780D_FVTHROTPWMFBDIVRANGEREG0_DFLT;\n\t\tfv_throt_pwm_fb_div_range[1] = RS780D_FVTHROTPWMFBDIVRANGEREG1_DFLT;\n\t\tfv_throt_pwm_fb_div_range[2] = RS780D_FVTHROTPWMFBDIVRANGEREG2_DFLT;\n\t} else if ((rdev->pdev->device == 0x9714) ||\n\t\t   (rdev->pdev->device == 0x9715)) {\n\t\tfv_throt_pwm_fb_div_range[0] = RS880D_FVTHROTPWMFBDIVRANGEREG0_DFLT;\n\t\tfv_throt_pwm_fb_div_range[1] = RS880D_FVTHROTPWMFBDIVRANGEREG1_DFLT;\n\t\tfv_throt_pwm_fb_div_range[2] = RS880D_FVTHROTPWMFBDIVRANGEREG2_DFLT;\n\t} else {\n\t\tfv_throt_pwm_fb_div_range[0] = RS780_FVTHROTPWMFBDIVRANGEREG0_DFLT;\n\t\tfv_throt_pwm_fb_div_range[1] = RS780_FVTHROTPWMFBDIVRANGEREG1_DFLT;\n\t\tfv_throt_pwm_fb_div_range[2] = RS780_FVTHROTPWMFBDIVRANGEREG2_DFLT;\n\t}\n\n\tif (pi->pwm_voltage_control) {\n\t\tfv_throt_pwm_range[0] = pi->min_voltage;\n\t\tfv_throt_pwm_range[1] = pi->min_voltage;\n\t\tfv_throt_pwm_range[2] = pi->max_voltage;\n\t\tfv_throt_pwm_range[3] = pi->max_voltage;\n\t} else {\n\t\tfv_throt_pwm_range[0] = pi->invert_pwm_required ?\n\t\t\tRS780_FVTHROTPWMRANGE3_GPIO_DFLT : RS780_FVTHROTPWMRANGE0_GPIO_DFLT;\n\t\tfv_throt_pwm_range[1] = pi->invert_pwm_required ?\n\t\t\tRS780_FVTHROTPWMRANGE2_GPIO_DFLT : RS780_FVTHROTPWMRANGE1_GPIO_DFLT;\n\t\tfv_throt_pwm_range[2] = pi->invert_pwm_required ?\n\t\t\tRS780_FVTHROTPWMRANGE1_GPIO_DFLT : RS780_FVTHROTPWMRANGE2_GPIO_DFLT;\n\t\tfv_throt_pwm_range[3] = pi->invert_pwm_required ?\n\t\t\tRS780_FVTHROTPWMRANGE0_GPIO_DFLT : RS780_FVTHROTPWMRANGE3_GPIO_DFLT;\n\t}\n\n\tWREG32_P(FVTHROT_PWM_CTRL_REG0,\n\t\t STARTING_PWM_HIGHTIME(pi->max_voltage),\n\t\t ~STARTING_PWM_HIGHTIME_MASK);\n\n\tWREG32_P(FVTHROT_PWM_CTRL_REG0,\n\t\t NUMBER_OF_CYCLES_IN_PERIOD(pi->num_of_cycles_in_period),\n\t\t ~NUMBER_OF_CYCLES_IN_PERIOD_MASK);\n\n\tWREG32_P(FVTHROT_PWM_CTRL_REG0, FORCE_STARTING_PWM_HIGHTIME,\n\t\t ~FORCE_STARTING_PWM_HIGHTIME);\n\n\tif (pi->invert_pwm_required)\n\t\tWREG32_P(FVTHROT_PWM_CTRL_REG0, INVERT_PWM_WAVEFORM, ~INVERT_PWM_WAVEFORM);\n\telse\n\t\tWREG32_P(FVTHROT_PWM_CTRL_REG0, 0, ~INVERT_PWM_WAVEFORM);\n\n\trs780_voltage_scaling_enable(rdev, true);\n\n\tWREG32(FVTHROT_PWM_CTRL_REG1,\n\t       (MIN_PWM_HIGHTIME(pi->min_voltage) |\n\t\tMAX_PWM_HIGHTIME(pi->max_voltage)));\n\n\tWREG32(FVTHROT_PWM_US_REG0, RS780_FVTHROTPWMUSREG0_DFLT);\n\tWREG32(FVTHROT_PWM_US_REG1, RS780_FVTHROTPWMUSREG1_DFLT);\n\tWREG32(FVTHROT_PWM_DS_REG0, RS780_FVTHROTPWMDSREG0_DFLT);\n\tWREG32(FVTHROT_PWM_DS_REG1, RS780_FVTHROTPWMDSREG1_DFLT);\n\n\tWREG32_P(FVTHROT_PWM_FEEDBACK_DIV_REG1,\n\t\t RANGE0_PWM_FEEDBACK_DIV(fv_throt_pwm_fb_div_range[0]),\n\t\t ~RANGE0_PWM_FEEDBACK_DIV_MASK);\n\n\tWREG32(FVTHROT_PWM_FEEDBACK_DIV_REG2,\n\t       (RANGE1_PWM_FEEDBACK_DIV(fv_throt_pwm_fb_div_range[1]) |\n\t\tRANGE2_PWM_FEEDBACK_DIV(fv_throt_pwm_fb_div_range[2])));\n\n\tWREG32(FVTHROT_PWM_FEEDBACK_DIV_REG3,\n\t       (RANGE0_PWM(fv_throt_pwm_range[1]) |\n\t\tRANGE1_PWM(fv_throt_pwm_range[2])));\n\tWREG32(FVTHROT_PWM_FEEDBACK_DIV_REG4,\n\t       (RANGE2_PWM(fv_throt_pwm_range[1]) |\n\t\tRANGE3_PWM(fv_throt_pwm_range[2])));\n}\n\nstatic void rs780_clk_scaling_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(FVTHROT_CNTRL_REG, ENABLE_FV_THROT | ENABLE_FV_UPDATE,\n\t\t\t ~(ENABLE_FV_THROT | ENABLE_FV_UPDATE));\n\telse\n\t\tWREG32_P(FVTHROT_CNTRL_REG, 0,\n\t\t\t ~(ENABLE_FV_THROT | ENABLE_FV_UPDATE));\n}\n\nstatic void rs780_voltage_scaling_enable(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(FVTHROT_CNTRL_REG, ENABLE_FV_THROT_IO, ~ENABLE_FV_THROT_IO);\n\telse\n\t\tWREG32_P(FVTHROT_CNTRL_REG, 0, ~ENABLE_FV_THROT_IO);\n}\n\nstatic void rs780_set_engine_clock_wfc(struct radeon_device *rdev)\n{\n\tWREG32(FVTHROT_UTC0, RS780_FVTHROTUTC0_DFLT);\n\tWREG32(FVTHROT_UTC1, RS780_FVTHROTUTC1_DFLT);\n\tWREG32(FVTHROT_UTC2, RS780_FVTHROTUTC2_DFLT);\n\tWREG32(FVTHROT_UTC3, RS780_FVTHROTUTC3_DFLT);\n\tWREG32(FVTHROT_UTC4, RS780_FVTHROTUTC4_DFLT);\n\n\tWREG32(FVTHROT_DTC0, RS780_FVTHROTDTC0_DFLT);\n\tWREG32(FVTHROT_DTC1, RS780_FVTHROTDTC1_DFLT);\n\tWREG32(FVTHROT_DTC2, RS780_FVTHROTDTC2_DFLT);\n\tWREG32(FVTHROT_DTC3, RS780_FVTHROTDTC3_DFLT);\n\tWREG32(FVTHROT_DTC4, RS780_FVTHROTDTC4_DFLT);\n}\n\nstatic void rs780_set_engine_clock_sc(struct radeon_device *rdev)\n{\n\tWREG32_P(FVTHROT_FBDIV_REG2,\n\t\t FB_DIV_TIMER_VAL(RS780_FBDIVTIMERVAL_DFLT),\n\t\t ~FB_DIV_TIMER_VAL_MASK);\n\n\tWREG32_P(FVTHROT_CNTRL_REG,\n\t\t REFRESH_RATE_DIVISOR(0) | MINIMUM_CIP(0xf),\n\t\t ~(REFRESH_RATE_DIVISOR_MASK | MINIMUM_CIP_MASK));\n}\n\nstatic void rs780_set_engine_clock_tdc(struct radeon_device *rdev)\n{\n\tWREG32_P(FVTHROT_CNTRL_REG, 0, ~(FORCE_TREND_SEL | TREND_SEL_MODE));\n}\n\nstatic void rs780_set_engine_clock_ssc(struct radeon_device *rdev)\n{\n\tWREG32(FVTHROT_FB_US_REG0, RS780_FVTHROTFBUSREG0_DFLT);\n\tWREG32(FVTHROT_FB_US_REG1, RS780_FVTHROTFBUSREG1_DFLT);\n\tWREG32(FVTHROT_FB_DS_REG0, RS780_FVTHROTFBDSREG0_DFLT);\n\tWREG32(FVTHROT_FB_DS_REG1, RS780_FVTHROTFBDSREG1_DFLT);\n\n\tWREG32_P(FVTHROT_FBDIV_REG1, MAX_FEEDBACK_STEP(1), ~MAX_FEEDBACK_STEP_MASK);\n}\n\nstatic void rs780_program_at(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\n\tWREG32(FVTHROT_TARGET_REG, 30000000 / pi->refresh_rate);\n\tWREG32(FVTHROT_CB1, 1000000 * 5 / pi->refresh_rate);\n\tWREG32(FVTHROT_CB2, 1000000 * 10 / pi->refresh_rate);\n\tWREG32(FVTHROT_CB3, 1000000 * 30 / pi->refresh_rate);\n\tWREG32(FVTHROT_CB4, 1000000 * 50 / pi->refresh_rate);\n}\n\nstatic void rs780_disable_vbios_powersaving(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_INTGFX_MISC, 0, ~0xFFF00000);\n}\n\nstatic void rs780_force_voltage(struct radeon_device *rdev, u16 voltage)\n{\n\tstruct igp_ps *current_state = rs780_get_ps(rdev->pm.dpm.current_ps);\n\n\tif ((current_state->max_voltage == RS780_VDDC_LEVEL_HIGH) &&\n\t    (current_state->min_voltage == RS780_VDDC_LEVEL_HIGH))\n\t\treturn;\n\n\tWREG32_P(GFX_MACRO_BYPASS_CNTL, SPLL_BYPASS_CNTL, ~SPLL_BYPASS_CNTL);\n\n\tudelay(1);\n\n\tWREG32_P(FVTHROT_PWM_CTRL_REG0,\n\t\t STARTING_PWM_HIGHTIME(voltage),\n\t\t ~STARTING_PWM_HIGHTIME_MASK);\n\n\tWREG32_P(FVTHROT_PWM_CTRL_REG0,\n\t\t FORCE_STARTING_PWM_HIGHTIME, ~FORCE_STARTING_PWM_HIGHTIME);\n\n\tWREG32_P(FVTHROT_PWM_FEEDBACK_DIV_REG1, 0,\n\t\t~RANGE_PWM_FEEDBACK_DIV_EN);\n\n\tudelay(1);\n\n\tWREG32_P(GFX_MACRO_BYPASS_CNTL, 0, ~SPLL_BYPASS_CNTL);\n}\n\nstatic void rs780_force_fbdiv(struct radeon_device *rdev, u32 fb_div)\n{\n\tstruct igp_ps *current_state = rs780_get_ps(rdev->pm.dpm.current_ps);\n\n\tif (current_state->sclk_low == current_state->sclk_high)\n\t\treturn;\n\n\tWREG32_P(GFX_MACRO_BYPASS_CNTL, SPLL_BYPASS_CNTL, ~SPLL_BYPASS_CNTL);\n\n\tWREG32_P(FVTHROT_FBDIV_REG2, FORCED_FEEDBACK_DIV(fb_div),\n\t\t ~FORCED_FEEDBACK_DIV_MASK);\n\tWREG32_P(FVTHROT_FBDIV_REG1, STARTING_FEEDBACK_DIV(fb_div),\n\t\t ~STARTING_FEEDBACK_DIV_MASK);\n\tWREG32_P(FVTHROT_FBDIV_REG1, FORCE_FEEDBACK_DIV, ~FORCE_FEEDBACK_DIV);\n\n\tudelay(100);\n\n\tWREG32_P(GFX_MACRO_BYPASS_CNTL, 0, ~SPLL_BYPASS_CNTL);\n}\n\nstatic int rs780_set_engine_clock_scaling(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *new_ps,\n\t\t\t\t\t  struct radeon_ps *old_ps)\n{\n\tstruct atom_clock_dividers min_dividers, max_dividers, current_max_dividers;\n\tstruct igp_ps *new_state = rs780_get_ps(new_ps);\n\tstruct igp_ps *old_state = rs780_get_ps(old_ps);\n\tint ret;\n\n\tif ((new_state->sclk_high == old_state->sclk_high) &&\n\t    (new_state->sclk_low == old_state->sclk_low))\n\t\treturn 0;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     new_state->sclk_low, false, &min_dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     new_state->sclk_high, false, &max_dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     old_state->sclk_high, false, &current_max_dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((min_dividers.ref_div != max_dividers.ref_div) ||\n\t    (min_dividers.post_div != max_dividers.post_div) ||\n\t    (max_dividers.ref_div != current_max_dividers.ref_div) ||\n\t    (max_dividers.post_div != current_max_dividers.post_div))\n\t\treturn -EINVAL;\n\n\trs780_force_fbdiv(rdev, max_dividers.fb_div);\n\n\tif (max_dividers.fb_div > min_dividers.fb_div) {\n\t\tWREG32_P(FVTHROT_FBDIV_REG0,\n\t\t\t MIN_FEEDBACK_DIV(min_dividers.fb_div) |\n\t\t\t MAX_FEEDBACK_DIV(max_dividers.fb_div),\n\t\t\t ~(MIN_FEEDBACK_DIV_MASK | MAX_FEEDBACK_DIV_MASK));\n\n\t\tWREG32_P(FVTHROT_FBDIV_REG1, 0, ~FORCE_FEEDBACK_DIV);\n\t}\n\n\treturn 0;\n}\n\nstatic void rs780_set_engine_clock_spc(struct radeon_device *rdev,\n\t\t\t\t       struct radeon_ps *new_ps,\n\t\t\t\t       struct radeon_ps *old_ps)\n{\n\tstruct igp_ps *new_state = rs780_get_ps(new_ps);\n\tstruct igp_ps *old_state = rs780_get_ps(old_ps);\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\n\tif ((new_state->sclk_high == old_state->sclk_high) &&\n\t    (new_state->sclk_low == old_state->sclk_low))\n\t\treturn;\n\n\tif (pi->crtc_id == 0)\n\t\tWREG32_P(CG_INTGFX_MISC, 0, ~FVTHROT_VBLANK_SEL);\n\telse\n\t\tWREG32_P(CG_INTGFX_MISC, FVTHROT_VBLANK_SEL, ~FVTHROT_VBLANK_SEL);\n\n}\n\nstatic void rs780_activate_engine_clk_scaling(struct radeon_device *rdev,\n\t\t\t\t\t      struct radeon_ps *new_ps,\n\t\t\t\t\t      struct radeon_ps *old_ps)\n{\n\tstruct igp_ps *new_state = rs780_get_ps(new_ps);\n\tstruct igp_ps *old_state = rs780_get_ps(old_ps);\n\n\tif ((new_state->sclk_high == old_state->sclk_high) &&\n\t    (new_state->sclk_low == old_state->sclk_low))\n\t\treturn;\n\n\tif (new_state->sclk_high == new_state->sclk_low)\n\t\treturn;\n\n\trs780_clk_scaling_enable(rdev, true);\n}\n\nstatic u32 rs780_get_voltage_for_vddc_level(struct radeon_device *rdev,\n\t\t\t\t\t    enum rs780_vddc_level vddc)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\n\tif (vddc == RS780_VDDC_LEVEL_HIGH)\n\t\treturn pi->max_voltage;\n\telse if (vddc == RS780_VDDC_LEVEL_LOW)\n\t\treturn pi->min_voltage;\n\telse\n\t\treturn pi->max_voltage;\n}\n\nstatic void rs780_enable_voltage_scaling(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *new_ps)\n{\n\tstruct igp_ps *new_state = rs780_get_ps(new_ps);\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\tenum rs780_vddc_level vddc_high, vddc_low;\n\n\tudelay(100);\n\n\tif ((new_state->max_voltage == RS780_VDDC_LEVEL_HIGH) &&\n\t    (new_state->min_voltage == RS780_VDDC_LEVEL_HIGH))\n\t\treturn;\n\n\tvddc_high = rs780_get_voltage_for_vddc_level(rdev,\n\t\t\t\t\t\t     new_state->max_voltage);\n\tvddc_low = rs780_get_voltage_for_vddc_level(rdev,\n\t\t\t\t\t\t    new_state->min_voltage);\n\n\tWREG32_P(GFX_MACRO_BYPASS_CNTL, SPLL_BYPASS_CNTL, ~SPLL_BYPASS_CNTL);\n\n\tudelay(1);\n\tif (vddc_high > vddc_low) {\n\t\tWREG32_P(FVTHROT_PWM_FEEDBACK_DIV_REG1,\n\t\t\t RANGE_PWM_FEEDBACK_DIV_EN, ~RANGE_PWM_FEEDBACK_DIV_EN);\n\n\t\tWREG32_P(FVTHROT_PWM_CTRL_REG0, 0, ~FORCE_STARTING_PWM_HIGHTIME);\n\t} else if (vddc_high == vddc_low) {\n\t\tif (pi->max_voltage != vddc_high) {\n\t\t\tWREG32_P(FVTHROT_PWM_CTRL_REG0,\n\t\t\t\t STARTING_PWM_HIGHTIME(vddc_high),\n\t\t\t\t ~STARTING_PWM_HIGHTIME_MASK);\n\n\t\t\tWREG32_P(FVTHROT_PWM_CTRL_REG0,\n\t\t\t\t FORCE_STARTING_PWM_HIGHTIME,\n\t\t\t\t ~FORCE_STARTING_PWM_HIGHTIME);\n\t\t}\n\t}\n\n\tWREG32_P(GFX_MACRO_BYPASS_CNTL, 0, ~SPLL_BYPASS_CNTL);\n}\n\nstatic void rs780_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t     struct radeon_ps *new_ps,\n\t\t\t\t\t\t     struct radeon_ps *old_ps)\n{\n\tstruct igp_ps *new_state = rs780_get_ps(new_ps);\n\tstruct igp_ps *current_state = rs780_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->sclk_high >= current_state->sclk_high)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nstatic void rs780_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t    struct radeon_ps *new_ps,\n\t\t\t\t\t\t    struct radeon_ps *old_ps)\n{\n\tstruct igp_ps *new_state = rs780_get_ps(new_ps);\n\tstruct igp_ps *current_state = rs780_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->sclk_high < current_state->sclk_high)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nint rs780_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\tint ret;\n\n\trs780_get_pm_mode_parameters(rdev);\n\trs780_disable_vbios_powersaving(rdev);\n\n\tif (r600_dynamicpm_enabled(rdev))\n\t\treturn -EINVAL;\n\tret = rs780_initialize_dpm_parameters(rdev, boot_ps);\n\tif (ret)\n\t\treturn ret;\n\trs780_start_dpm(rdev);\n\n\trs780_preset_ranges_slow_clk_fbdiv_en(rdev);\n\trs780_preset_starting_fbdiv(rdev);\n\tif (pi->voltage_control)\n\t\trs780_voltage_scaling_init(rdev);\n\trs780_clk_scaling_enable(rdev, true);\n\trs780_set_engine_clock_sc(rdev);\n\trs780_set_engine_clock_wfc(rdev);\n\trs780_program_at(rdev);\n\trs780_set_engine_clock_tdc(rdev);\n\trs780_set_engine_clock_ssc(rdev);\n\n\tif (pi->gfx_clock_gating)\n\t\tr600_gfx_clockgating_enable(rdev, true);\n\n\treturn 0;\n}\n\nvoid rs780_dpm_disable(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\n\tr600_dynamicpm_enable(rdev, false);\n\n\trs780_clk_scaling_enable(rdev, false);\n\trs780_voltage_scaling_enable(rdev, false);\n\n\tif (pi->gfx_clock_gating)\n\t\tr600_gfx_clockgating_enable(rdev, false);\n\n\tif (rdev->irq.installed &&\n\t    (rdev->pm.int_thermal_type == THERMAL_TYPE_RV6XX)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n}\n\nint rs780_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\tstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\n\tint ret;\n\n\trs780_get_pm_mode_parameters(rdev);\n\n\trs780_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\n\tif (pi->voltage_control) {\n\t\trs780_force_voltage(rdev, pi->max_voltage);\n\t\tmdelay(5);\n\t}\n\n\tret = rs780_set_engine_clock_scaling(rdev, new_ps, old_ps);\n\tif (ret)\n\t\treturn ret;\n\trs780_set_engine_clock_spc(rdev, new_ps, old_ps);\n\n\trs780_activate_engine_clk_scaling(rdev, new_ps, old_ps);\n\n\tif (pi->voltage_control)\n\t\trs780_enable_voltage_scaling(rdev, new_ps);\n\n\trs780_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\n\treturn 0;\n}\n\nvoid rs780_dpm_setup_asic(struct radeon_device *rdev)\n{\n\n}\n\nvoid rs780_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\trs780_get_pm_mode_parameters(rdev);\n\trs780_program_at(rdev);\n}\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2;\n};\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void rs780_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *rps,\n\t\t\t\t\t     struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t     u8 table_rev)\n{\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (r600_is_uvd_state(rps->class, rps->class2)) {\n\t\tif ((rps->vclk == 0) || (rps->dclk == 0)) {\n\t\t\trps->vclk = RS780_DEFAULT_VCLK_FREQ;\n\t\t\trps->dclk = RS780_DEFAULT_DCLK_FREQ;\n\t\t}\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\trdev->pm.dpm.boot_ps = rps;\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void rs780_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *rps,\n\t\t\t\t\t union pplib_clock_info *clock_info)\n{\n\tstruct igp_ps *ps = rs780_get_ps(rps);\n\tu32 sclk;\n\n\tsclk = le16_to_cpu(clock_info->rs780.usLowEngineClockLow);\n\tsclk |= clock_info->rs780.ucLowEngineClockHigh << 16;\n\tps->sclk_low = sclk;\n\tsclk = le16_to_cpu(clock_info->rs780.usHighEngineClockLow);\n\tsclk |= clock_info->rs780.ucHighEngineClockHigh << 16;\n\tps->sclk_high = sclk;\n\tswitch (le16_to_cpu(clock_info->rs780.usVDDC)) {\n\tcase ATOM_PPLIB_RS780_VOLTAGE_NONE:\n\tdefault:\n\t\tps->min_voltage = RS780_VDDC_LEVEL_UNKNOWN;\n\t\tps->max_voltage = RS780_VDDC_LEVEL_UNKNOWN;\n\t\tbreak;\n\tcase ATOM_PPLIB_RS780_VOLTAGE_LOW:\n\t\tps->min_voltage = RS780_VDDC_LEVEL_LOW;\n\t\tps->max_voltage = RS780_VDDC_LEVEL_LOW;\n\t\tbreak;\n\tcase ATOM_PPLIB_RS780_VOLTAGE_HIGH:\n\t\tps->min_voltage = RS780_VDDC_LEVEL_HIGH;\n\t\tps->max_voltage = RS780_VDDC_LEVEL_HIGH;\n\t\tbreak;\n\tcase ATOM_PPLIB_RS780_VOLTAGE_VARIABLE:\n\t\tps->min_voltage = RS780_VDDC_LEVEL_LOW;\n\t\tps->max_voltage = RS780_VDDC_LEVEL_HIGH;\n\t\tbreak;\n\t}\n\tps->flags = le32_to_cpu(clock_info->rs780.ulFlags);\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\tps->sclk_low = rdev->clock.default_sclk;\n\t\tps->sclk_high = rdev->clock.default_sclk;\n\t\tps->min_voltage = RS780_VDDC_LEVEL_HIGH;\n\t\tps->max_voltage = RS780_VDDC_LEVEL_HIGH;\n\t}\n}\n\nstatic int rs780_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i;\n\tunion pplib_clock_info *clock_info;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tstruct igp_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\trdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\n\t\tpower_state = (union pplib_power_state *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset) +\n\t\t\t i * power_info->pplib.ucStateEntrySize);\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\n\t\t\t (power_state->v1.ucNonClockStateIndex *\n\t\t\t  power_info->pplib.ucNonClockSize));\n\t\tif (power_info->pplib.ucStateEntrySize - 1) {\n\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\n\t\t\t\t (power_state->v1.ucClockStateIndices[0] *\n\t\t\t\t  power_info->pplib.ucClockInfoSize));\n\t\t\tps = kzalloc(sizeof(struct igp_ps), GFP_KERNEL);\n\t\t\tif (ps == NULL) {\n\t\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\t\trs780_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\t\t non_clock_info,\n\t\t\t\t\t\t\t power_info->pplib.ucNonClockSize);\n\t\t\trs780_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t     &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\t     clock_info);\n\t\t}\n\t}\n\trdev->pm.dpm.num_ps = power_info->pplib.ucNumStates;\n\treturn 0;\n}\n\nint rs780_dpm_init(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *info;\n\tu16 data_offset;\n\tu8 frev, crev;\n\tint ret;\n\n\tpi = kzalloc(sizeof(struct igp_power_info), GFP_KERNEL);\n\tif (pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = pi;\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rs780_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->voltage_control = false;\n\tpi->gfx_clock_gating = true;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tinfo = (union igp_info *)(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\t \n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\tpi->num_of_cycles_in_period =\n\t\t\t\tinfo->info.ucNumberOfCyclesInPeriod;\n\t\t\tpi->num_of_cycles_in_period |=\n\t\t\t\tinfo->info.ucNumberOfCyclesInPeriodHi << 8;\n\t\t\tpi->invert_pwm_required =\n\t\t\t\t(pi->num_of_cycles_in_period & 0x8000) ? true : false;\n\t\t\tpi->boot_voltage = info->info.ucStartingPWM_HighTime;\n\t\t\tpi->max_voltage = info->info.ucMaxNBVoltage;\n\t\t\tpi->max_voltage |= info->info.ucMaxNBVoltageHigh << 8;\n\t\t\tpi->min_voltage = info->info.ucMinNBVoltage;\n\t\t\tpi->min_voltage |= info->info.ucMinNBVoltageHigh << 8;\n\t\t\tpi->inter_voltage_low =\n\t\t\t\tle16_to_cpu(info->info.usInterNBVoltageLow);\n\t\t\tpi->inter_voltage_high =\n\t\t\t\tle16_to_cpu(info->info.usInterNBVoltageHigh);\n\t\t\tpi->voltage_control = true;\n\t\t\tpi->bootup_uma_clk = info->info.usK8MemoryClock * 100;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpi->num_of_cycles_in_period =\n\t\t\t\tle16_to_cpu(info->info_2.usNumberOfCyclesInPeriod);\n\t\t\tpi->invert_pwm_required =\n\t\t\t\t(pi->num_of_cycles_in_period & 0x8000) ? true : false;\n\t\t\tpi->boot_voltage =\n\t\t\t\tle16_to_cpu(info->info_2.usBootUpNBVoltage);\n\t\t\tpi->max_voltage =\n\t\t\t\tle16_to_cpu(info->info_2.usMaxNBVoltage);\n\t\t\tpi->min_voltage =\n\t\t\t\tle16_to_cpu(info->info_2.usMinNBVoltage);\n\t\t\tpi->system_config =\n\t\t\t\tle32_to_cpu(info->info_2.ulSystemConfig);\n\t\t\tpi->pwm_voltage_control =\n\t\t\t\t(pi->system_config & 0x4) ? true : false;\n\t\t\tpi->voltage_control = true;\n\t\t\tpi->bootup_uma_clk = le32_to_cpu(info->info_2.ulBootUpUMAClock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"No integrated system info for your GPU\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pi->min_voltage > pi->max_voltage)\n\t\t\tpi->voltage_control = false;\n\t\tif (pi->pwm_voltage_control) {\n\t\t\tif ((pi->num_of_cycles_in_period == 0) ||\n\t\t\t    (pi->max_voltage == 0) ||\n\t\t\t    (pi->min_voltage == 0))\n\t\t\t\tpi->voltage_control = false;\n\t\t} else {\n\t\t\tif ((pi->num_of_cycles_in_period == 0) ||\n\t\t\t    (pi->max_voltage == 0))\n\t\t\t\tpi->voltage_control = false;\n\t\t}\n\n\t\treturn 0;\n\t}\n\tradeon_dpm_fini(rdev);\n\treturn -EINVAL;\n}\n\nvoid rs780_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t\t struct radeon_ps *rps)\n{\n\tstruct igp_ps *ps = rs780_get_ps(rps);\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tprintk(\"\\t\\tpower level 0    sclk: %u vddc_index: %d\\n\",\n\t       ps->sclk_low, ps->min_voltage);\n\tprintk(\"\\t\\tpower level 1    sclk: %u vddc_index: %d\\n\",\n\t       ps->sclk_high, ps->max_voltage);\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid rs780_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n}\n\nu32 rs780_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct igp_ps *requested_state = rs780_get_ps(rdev->pm.dpm.requested_ps);\n\n\tif (low)\n\t\treturn requested_state->sclk_low;\n\telse\n\t\treturn requested_state->sclk_high;\n}\n\nu32 rs780_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\n\treturn pi->bootup_uma_clk;\n}\n\nvoid rs780_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t       struct seq_file *m)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct igp_ps *ps = rs780_get_ps(rps);\n\tu32 current_fb_div = RREG32(FVTHROT_STATUS_REG0) & CURRENT_FEEDBACK_DIV_MASK;\n\tu32 func_cntl = RREG32(CG_SPLL_FUNC_CNTL);\n\tu32 ref_div = ((func_cntl & SPLL_REF_DIV_MASK) >> SPLL_REF_DIV_SHIFT) + 1;\n\tu32 post_div = ((func_cntl & SPLL_SW_HILEN_MASK) >> SPLL_SW_HILEN_SHIFT) + 1 +\n\t\t((func_cntl & SPLL_SW_LOLEN_MASK) >> SPLL_SW_LOLEN_SHIFT) + 1;\n\tu32 sclk = (rdev->clock.spll.reference_freq * current_fb_div) /\n\t\t(post_div * ref_div);\n\n\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\n\t \n\tif (sclk < (ps->sclk_low + 500))\n\t\tseq_printf(m, \"power level 0    sclk: %u vddc_index: %d\\n\",\n\t\t\t   ps->sclk_low, ps->min_voltage);\n\telse\n\t\tseq_printf(m, \"power level 1    sclk: %u vddc_index: %d\\n\",\n\t\t\t   ps->sclk_high, ps->max_voltage);\n}\n\n \nu32 rs780_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tu32 current_fb_div = RREG32(FVTHROT_STATUS_REG0) & CURRENT_FEEDBACK_DIV_MASK;\n\tu32 func_cntl = RREG32(CG_SPLL_FUNC_CNTL);\n\tu32 ref_div = ((func_cntl & SPLL_REF_DIV_MASK) >> SPLL_REF_DIV_SHIFT) + 1;\n\tu32 post_div = ((func_cntl & SPLL_SW_HILEN_MASK) >> SPLL_SW_HILEN_SHIFT) + 1 +\n\t\t((func_cntl & SPLL_SW_LOLEN_MASK) >> SPLL_SW_LOLEN_SHIFT) + 1;\n\tu32 sclk = (rdev->clock.spll.reference_freq * current_fb_div) /\n\t\t(post_div * ref_div);\n\n\treturn sclk;\n}\n\n \nu32 rs780_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\n\treturn pi->bootup_uma_clk;\n}\n\nint rs780_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t      enum radeon_dpm_forced_level level)\n{\n\tstruct igp_power_info *pi = rs780_get_pi(rdev);\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct igp_ps *ps = rs780_get_ps(rps);\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\trs780_clk_scaling_enable(rdev, false);\n\trs780_voltage_scaling_enable(rdev, false);\n\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\tif (pi->voltage_control)\n\t\t\trs780_force_voltage(rdev, pi->max_voltage);\n\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     ps->sclk_high, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trs780_force_fbdiv(rdev, dividers.fb_div);\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     ps->sclk_low, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\trs780_force_fbdiv(rdev, dividers.fb_div);\n\n\t\tif (pi->voltage_control)\n\t\t\trs780_force_voltage(rdev, pi->min_voltage);\n\t} else {\n\t\tif (pi->voltage_control)\n\t\t\trs780_force_voltage(rdev, pi->max_voltage);\n\n\t\tif (ps->sclk_high != ps->sclk_low) {\n\t\t\tWREG32_P(FVTHROT_FBDIV_REG1, 0, ~FORCE_FEEDBACK_DIV);\n\t\t\trs780_clk_scaling_enable(rdev, true);\n\t\t}\n\n\t\tif (pi->voltage_control) {\n\t\t\trs780_voltage_scaling_enable(rdev, true);\n\t\t\trs780_enable_voltage_scaling(rdev, rps);\n\t\t}\n\t}\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}