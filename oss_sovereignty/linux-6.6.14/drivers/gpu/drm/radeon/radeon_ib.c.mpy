{
  "module_name": "radeon_ib.c",
  "hash_id": "5506242aebabc6a0e13e4b477656c978363cdd5eba2681be03023d50e54cbeac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_ib.c",
  "human_readable_source": " \n\n#include <drm/drm_file.h>\n\n#include \"radeon.h\"\n\n \nstatic void radeon_debugfs_sa_init(struct radeon_device *rdev);\n\n \nint radeon_ib_get(struct radeon_device *rdev, int ring,\n\t\t  struct radeon_ib *ib, struct radeon_vm *vm,\n\t\t  unsigned size)\n{\n\tint r;\n\n\tr = radeon_sa_bo_new(&rdev->ring_tmp_bo, &ib->sa_bo, size, 256);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed to get a new IB (%d)\\n\", r);\n\t\treturn r;\n\t}\n\n\tradeon_sync_create(&ib->sync);\n\n\tib->ring = ring;\n\tib->fence = NULL;\n\tib->ptr = radeon_sa_bo_cpu_addr(ib->sa_bo);\n\tib->vm = vm;\n\tif (vm) {\n\t\t \n\t\tib->gpu_addr = drm_suballoc_soffset(ib->sa_bo) + RADEON_VA_IB_OFFSET;\n\t} else {\n\t\tib->gpu_addr = radeon_sa_bo_gpu_addr(ib->sa_bo);\n\t}\n\tib->is_const_ib = false;\n\n\treturn 0;\n}\n\n \nvoid radeon_ib_free(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tradeon_sync_free(rdev, &ib->sync, ib->fence);\n\tradeon_sa_bo_free(&ib->sa_bo, ib->fence);\n\tradeon_fence_unref(&ib->fence);\n}\n\n \nint radeon_ib_schedule(struct radeon_device *rdev, struct radeon_ib *ib,\n\t\t       struct radeon_ib *const_ib, bool hdp_flush)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tint r = 0;\n\n\tif (!ib->length_dw || !ring->ready) {\n\t\t \n\t\tdev_err(rdev->dev, \"couldn't schedule ib\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tr = radeon_ring_lock(rdev, ring, 64 + RADEON_NUM_SYNCS * 8);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"scheduling IB failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (ib->vm) {\n\t\tstruct radeon_fence *vm_id_fence;\n\t\tvm_id_fence = radeon_vm_grab_id(rdev, ib->vm, ib->ring);\n\t\tradeon_sync_fence(&ib->sync, vm_id_fence);\n\t}\n\n\t \n\tr = radeon_sync_rings(rdev, &ib->sync, ib->ring);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed to sync rings (%d)\\n\", r);\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\treturn r;\n\t}\n\n\tif (ib->vm)\n\t\tradeon_vm_flush(rdev, ib->vm, ib->ring,\n\t\t\t\tib->sync.last_vm_update);\n\n\tif (const_ib) {\n\t\tradeon_ring_ib_execute(rdev, const_ib->ring, const_ib);\n\t\tradeon_sync_free(rdev, &const_ib->sync, NULL);\n\t}\n\tradeon_ring_ib_execute(rdev, ib->ring, ib);\n\tr = radeon_fence_emit(rdev, &ib->fence, ib->ring);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed to emit fence for new IB (%d)\\n\", r);\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\treturn r;\n\t}\n\tif (const_ib) {\n\t\tconst_ib->fence = radeon_fence_ref(ib->fence);\n\t}\n\n\tif (ib->vm)\n\t\tradeon_vm_fence(rdev, ib->vm, ib->fence);\n\n\tradeon_ring_unlock_commit(rdev, ring, hdp_flush);\n\treturn 0;\n}\n\n \nint radeon_ib_pool_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->ib_pool_ready) {\n\t\treturn 0;\n\t}\n\n\tif (rdev->family >= CHIP_BONAIRE) {\n\t\tr = radeon_sa_bo_manager_init(rdev, &rdev->ring_tmp_bo,\n\t\t\t\t\t      RADEON_IB_POOL_SIZE*64*1024, 256,\n\t\t\t\t\t      RADEON_GEM_DOMAIN_GTT,\n\t\t\t\t\t      RADEON_GEM_GTT_WC);\n\t} else {\n\t\t \n\t\tr = radeon_sa_bo_manager_init(rdev, &rdev->ring_tmp_bo,\n\t\t\t\t\t      RADEON_IB_POOL_SIZE*64*1024, 256,\n\t\t\t\t\t      RADEON_GEM_DOMAIN_GTT, 0);\n\t}\n\tif (r) {\n\t\treturn r;\n\t}\n\n\tr = radeon_sa_bo_manager_start(rdev, &rdev->ring_tmp_bo);\n\tif (r) {\n\t\treturn r;\n\t}\n\n\trdev->ib_pool_ready = true;\n\tradeon_debugfs_sa_init(rdev);\n\treturn 0;\n}\n\n \nvoid radeon_ib_pool_fini(struct radeon_device *rdev)\n{\n\tif (rdev->ib_pool_ready) {\n\t\tradeon_sa_bo_manager_suspend(rdev, &rdev->ring_tmp_bo);\n\t\tradeon_sa_bo_manager_fini(rdev, &rdev->ring_tmp_bo);\n\t\trdev->ib_pool_ready = false;\n\t}\n}\n\n \nint radeon_ib_ring_tests(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tint r;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tstruct radeon_ring *ring = &rdev->ring[i];\n\n\t\tif (!ring->ready)\n\t\t\tcontinue;\n\n\t\tr = radeon_ib_test(rdev, i, ring);\n\t\tif (r) {\n\t\t\tradeon_fence_driver_force_completion(rdev, i);\n\t\t\tring->ready = false;\n\t\t\trdev->needs_reset = false;\n\n\t\t\tif (i == RADEON_RING_TYPE_GFX_INDEX) {\n\t\t\t\t \n\t\t\t\tDRM_ERROR(\"radeon: failed testing IB on GFX ring (%d).\\n\", r);\n\t\t\t\trdev->accel_working = false;\n\t\t\t\treturn r;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tDRM_ERROR(\"radeon: failed testing IB on ring %d (%d).\\n\", i, r);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\n\nstatic int radeon_debugfs_sa_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\n\tradeon_sa_bo_dump_debug_info(&rdev->ring_tmp_bo, m);\n\n\treturn 0;\n\n}\n\nDEFINE_SHOW_ATTRIBUTE(radeon_debugfs_sa_info);\n\n#endif\n\nstatic void radeon_debugfs_sa_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"radeon_sa_info\", 0444, root, rdev,\n\t\t\t    &radeon_debugfs_sa_info_fops);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}