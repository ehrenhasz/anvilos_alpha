{
  "module_name": "r600.c",
  "hash_id": "a88e5fcd7a55ef3865a9a5556cbc8dfe9b35fc9916587dbbe302a4c6681f95aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/r600.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"atom.h\"\n#include \"avivod.h\"\n#include \"evergreen.h\"\n#include \"r600.h\"\n#include \"r600d.h\"\n#include \"rv770.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"radeon_mode.h\"\n#include \"radeon_ucode.h\"\n\n \nMODULE_FIRMWARE(\"radeon/R600_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/R600_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV610_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV610_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV630_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV630_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV620_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV620_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV635_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV635_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV670_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV670_me.bin\");\nMODULE_FIRMWARE(\"radeon/RS780_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RS780_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV770_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV770_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV770_smc.bin\");\nMODULE_FIRMWARE(\"radeon/RV730_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV730_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV730_smc.bin\");\nMODULE_FIRMWARE(\"radeon/RV740_smc.bin\");\nMODULE_FIRMWARE(\"radeon/RV710_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/RV710_me.bin\");\nMODULE_FIRMWARE(\"radeon/RV710_smc.bin\");\nMODULE_FIRMWARE(\"radeon/R600_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/R700_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/CEDAR_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/CEDAR_me.bin\");\nMODULE_FIRMWARE(\"radeon/CEDAR_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/CEDAR_smc.bin\");\nMODULE_FIRMWARE(\"radeon/REDWOOD_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/REDWOOD_me.bin\");\nMODULE_FIRMWARE(\"radeon/REDWOOD_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/REDWOOD_smc.bin\");\nMODULE_FIRMWARE(\"radeon/JUNIPER_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/JUNIPER_me.bin\");\nMODULE_FIRMWARE(\"radeon/JUNIPER_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/JUNIPER_smc.bin\");\nMODULE_FIRMWARE(\"radeon/CYPRESS_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/CYPRESS_me.bin\");\nMODULE_FIRMWARE(\"radeon/CYPRESS_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/CYPRESS_smc.bin\");\nMODULE_FIRMWARE(\"radeon/PALM_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/PALM_me.bin\");\nMODULE_FIRMWARE(\"radeon/SUMO_rlc.bin\");\nMODULE_FIRMWARE(\"radeon/SUMO_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/SUMO_me.bin\");\nMODULE_FIRMWARE(\"radeon/SUMO2_pfp.bin\");\nMODULE_FIRMWARE(\"radeon/SUMO2_me.bin\");\n\nstatic const u32 crtc_offsets[2] =\n{\n\t0,\n\tAVIVO_D2CRTC_H_TOTAL - AVIVO_D1CRTC_H_TOTAL\n};\n\nstatic void r600_debugfs_mc_info_init(struct radeon_device *rdev);\n\n \nint r600_mc_wait_for_idle(struct radeon_device *rdev);\nstatic void r600_gpu_init(struct radeon_device *rdev);\nvoid r600_fini(struct radeon_device *rdev);\nvoid r600_irq_disable(struct radeon_device *rdev);\nstatic void r600_pcie_gen2_enable(struct radeon_device *rdev);\n\n \nu32 r600_rcu_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->rcu_idx_lock, flags);\n\tWREG32(R600_RCU_INDEX, ((reg) & 0x1fff));\n\tr = RREG32(R600_RCU_DATA);\n\tspin_unlock_irqrestore(&rdev->rcu_idx_lock, flags);\n\treturn r;\n}\n\nvoid r600_rcu_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->rcu_idx_lock, flags);\n\tWREG32(R600_RCU_INDEX, ((reg) & 0x1fff));\n\tWREG32(R600_RCU_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->rcu_idx_lock, flags);\n}\n\nu32 r600_uvd_ctx_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->uvd_idx_lock, flags);\n\tWREG32(R600_UVD_CTX_INDEX, ((reg) & 0x1ff));\n\tr = RREG32(R600_UVD_CTX_DATA);\n\tspin_unlock_irqrestore(&rdev->uvd_idx_lock, flags);\n\treturn r;\n}\n\nvoid r600_uvd_ctx_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->uvd_idx_lock, flags);\n\tWREG32(R600_UVD_CTX_INDEX, ((reg) & 0x1ff));\n\tWREG32(R600_UVD_CTX_DATA, (v));\n\tspin_unlock_irqrestore(&rdev->uvd_idx_lock, flags);\n}\n\n \nint r600_get_allowed_info_register(struct radeon_device *rdev,\n\t\t\t\t   u32 reg, u32 *val)\n{\n\tswitch (reg) {\n\tcase GRBM_STATUS:\n\tcase GRBM_STATUS2:\n\tcase R_000E50_SRBM_STATUS:\n\tcase DMA_STATUS_REG:\n\tcase UVD_STATUS:\n\t\t*val = RREG32(reg);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nu32 r600_get_xclk(struct radeon_device *rdev)\n{\n\treturn rdev->clock.spll.reference_freq;\n}\n\nint r600_set_uvd_clocks(struct radeon_device *rdev, u32 vclk, u32 dclk)\n{\n\tunsigned fb_div = 0, ref_div, vclk_div = 0, dclk_div = 0;\n\tint r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\t VCLK_SRC_SEL(1) | DCLK_SRC_SEL(1),\n\t\t ~(VCLK_SRC_SEL_MASK | DCLK_SRC_SEL_MASK));\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_BYPASS_EN_MASK, ~(\n\t\t UPLL_RESET_MASK | UPLL_SLEEP_MASK | UPLL_CTLREQ_MASK));\n\n\tif (rdev->family >= CHIP_RS780)\n\t\tWREG32_P(GFX_MACRO_BYPASS_CNTL, UPLL_BYPASS_CNTL,\n\t\t\t ~UPLL_BYPASS_CNTL);\n\n\tif (!vclk || !dclk) {\n\t\t \n\t\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_SLEEP_MASK, ~UPLL_SLEEP_MASK);\n\t\treturn 0;\n\t}\n\n\tif (rdev->clock.spll.reference_freq == 10000)\n\t\tref_div = 34;\n\telse\n\t\tref_div = 4;\n\n\tr = radeon_uvd_calc_upll_dividers(rdev, vclk, dclk, 50000, 160000,\n\t\t\t\t\t  ref_div + 1, 0xFFF, 2, 30, ~0,\n\t\t\t\t\t  &fb_div, &vclk_div, &dclk_div);\n\tif (r)\n\t\treturn r;\n\n\tif (rdev->family >= CHIP_RV670 && rdev->family < CHIP_RS780)\n\t\tfb_div >>= 1;\n\telse\n\t\tfb_div |= 1;\n\n\tr = radeon_uvd_send_upll_ctlreq(rdev, CG_UPLL_FUNC_CNTL);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_RESET_MASK, ~UPLL_RESET_MASK);\n\n\t \n\tif (rdev->family >= CHIP_RS780)\n\t\tWREG32_P(CG_UPLL_FUNC_CNTL, UPLL_REFCLK_SRC_SEL_MASK,\n\t\t\t ~UPLL_REFCLK_SRC_SEL_MASK);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL,\n\t\t UPLL_FB_DIV(fb_div) |\n\t\t UPLL_REF_DIV(ref_div),\n\t\t ~(UPLL_FB_DIV_MASK | UPLL_REF_DIV_MASK));\n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\t UPLL_SW_HILEN(vclk_div >> 1) |\n\t\t UPLL_SW_LOLEN((vclk_div >> 1) + (vclk_div & 1)) |\n\t\t UPLL_SW_HILEN2(dclk_div >> 1) |\n\t\t UPLL_SW_LOLEN2((dclk_div >> 1) + (dclk_div & 1)) |\n\t\t UPLL_DIVEN_MASK | UPLL_DIVEN2_MASK,\n\t\t ~UPLL_SW_MASK);\n\n\t \n\tmdelay(15);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_RESET_MASK);\n\n\tmdelay(15);\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL, 0, ~UPLL_BYPASS_EN_MASK);\n\n\tif (rdev->family >= CHIP_RS780)\n\t\tWREG32_P(GFX_MACRO_BYPASS_CNTL, 0, ~UPLL_BYPASS_CNTL);\n\n\tr = radeon_uvd_send_upll_ctlreq(rdev, CG_UPLL_FUNC_CNTL);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32_P(CG_UPLL_FUNC_CNTL_2,\n\t\t VCLK_SRC_SEL(2) | DCLK_SRC_SEL(2),\n\t\t ~(VCLK_SRC_SEL_MASK | DCLK_SRC_SEL_MASK));\n\n\tmdelay(100);\n\n\treturn 0;\n}\n\nvoid dce3_program_fmt(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tint bpc = 0;\n\tu32 tmp = 0;\n\tenum radeon_connector_dither dither = RADEON_FMT_DITHER_DISABLE;\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tbpc = radeon_get_monitor_bpc(connector);\n\t\tdither = radeon_connector->dither;\n\t}\n\n\t \n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD_SUPPORT)\n\t\treturn;\n\n\t \n\tif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1) ||\n\t    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2))\n\t\treturn;\n\n\tif (bpc == 0)\n\t\treturn;\n\n\tswitch (bpc) {\n\tcase 6:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= FMT_SPATIAL_DITHER_EN;\n\t\telse\n\t\t\ttmp |= FMT_TRUNCATE_EN;\n\t\tbreak;\n\tcase 8:\n\t\tif (dither == RADEON_FMT_DITHER_ENABLE)\n\t\t\t \n\t\t\ttmp |= (FMT_SPATIAL_DITHER_EN | FMT_SPATIAL_DITHER_DEPTH);\n\t\telse\n\t\t\ttmp |= (FMT_TRUNCATE_EN | FMT_TRUNCATE_DEPTH);\n\t\tbreak;\n\tcase 10:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tWREG32(FMT_BIT_DEPTH_CONTROL + radeon_crtc->crtc_offset, tmp);\n}\n\n \nint rv6xx_get_temp(struct radeon_device *rdev)\n{\n\tu32 temp = (RREG32(CG_THERMAL_STATUS) & ASIC_T_MASK) >>\n\t\tASIC_T_SHIFT;\n\tint actual_temp = temp & 0xff;\n\n\tif (temp & 0x100)\n\t\tactual_temp -= 256;\n\n\treturn actual_temp * 1000;\n}\n\nvoid r600_pm_get_dynpm_state(struct radeon_device *rdev)\n{\n\tint i;\n\n\trdev->pm.dynpm_can_upclock = true;\n\trdev->pm.dynpm_can_downclock = true;\n\n\t \n\tif ((rdev->flags & RADEON_IS_IGP) || (rdev->family == CHIP_R600)) {\n\t\tint min_power_state_index = 0;\n\n\t\tif (rdev->pm.num_power_states > 2)\n\t\t\tmin_power_state_index = 1;\n\n\t\tswitch (rdev->pm.dynpm_planned_action) {\n\t\tcase DYNPM_ACTION_MINIMUM:\n\t\t\trdev->pm.requested_power_state_index = min_power_state_index;\n\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\trdev->pm.dynpm_can_downclock = false;\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_DOWNCLOCK:\n\t\t\tif (rdev->pm.current_power_state_index == min_power_state_index) {\n\t\t\t\trdev->pm.requested_power_state_index = rdev->pm.current_power_state_index;\n\t\t\t\trdev->pm.dynpm_can_downclock = false;\n\t\t\t} else {\n\t\t\t\tif (rdev->pm.active_crtc_count > 1) {\n\t\t\t\t\tfor (i = 0; i < rdev->pm.num_power_states; i++) {\n\t\t\t\t\t\tif (rdev->pm.power_state[i].flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse if (i >= rdev->pm.current_power_state_index) {\n\t\t\t\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\t\t\t\trdev->pm.current_power_state_index;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trdev->pm.requested_power_state_index = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (rdev->pm.current_power_state_index == 0)\n\t\t\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\t\t\trdev->pm.num_power_states - 1;\n\t\t\t\t\telse\n\t\t\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\t\t\trdev->pm.current_power_state_index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\t \n\t\t\tif ((rdev->pm.active_crtc_count > 0) &&\n\t\t\t    (rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t\t     clock_info[rdev->pm.requested_clock_mode_index].flags &\n\t\t\t     RADEON_PM_MODE_NO_DISPLAY)) {\n\t\t\t\trdev->pm.requested_power_state_index++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_UPCLOCK:\n\t\t\tif (rdev->pm.current_power_state_index == (rdev->pm.num_power_states - 1)) {\n\t\t\t\trdev->pm.requested_power_state_index = rdev->pm.current_power_state_index;\n\t\t\t\trdev->pm.dynpm_can_upclock = false;\n\t\t\t} else {\n\t\t\t\tif (rdev->pm.active_crtc_count > 1) {\n\t\t\t\t\tfor (i = (rdev->pm.num_power_states - 1); i >= 0; i--) {\n\t\t\t\t\t\tif (rdev->pm.power_state[i].flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse if (i <= rdev->pm.current_power_state_index) {\n\t\t\t\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\t\t\t\trdev->pm.current_power_state_index;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trdev->pm.requested_power_state_index = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\t\trdev->pm.current_power_state_index + 1;\n\t\t\t}\n\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_DEFAULT:\n\t\t\trdev->pm.requested_power_state_index = rdev->pm.default_power_state_index;\n\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\trdev->pm.dynpm_can_upclock = false;\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_NONE:\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Requested mode for not defined action\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\t \n\t\tif (rdev->pm.active_crtc_count > 1) {\n\t\t\trdev->pm.requested_power_state_index = -1;\n\t\t\t \n\t\t\tfor (i = 1; i < rdev->pm.num_power_states; i++) {\n\t\t\t\tif (rdev->pm.power_state[i].flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\n\t\t\t\t\tcontinue;\n\t\t\t\telse if ((rdev->pm.power_state[i].type == POWER_STATE_TYPE_PERFORMANCE) ||\n\t\t\t\t\t (rdev->pm.power_state[i].type == POWER_STATE_TYPE_BATTERY)) {\n\t\t\t\t\trdev->pm.requested_power_state_index = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (rdev->pm.requested_power_state_index == -1)\n\t\t\t\trdev->pm.requested_power_state_index = 0;\n\t\t} else\n\t\t\trdev->pm.requested_power_state_index = 1;\n\n\t\tswitch (rdev->pm.dynpm_planned_action) {\n\t\tcase DYNPM_ACTION_MINIMUM:\n\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\trdev->pm.dynpm_can_downclock = false;\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_DOWNCLOCK:\n\t\t\tif (rdev->pm.requested_power_state_index == rdev->pm.current_power_state_index) {\n\t\t\t\tif (rdev->pm.current_clock_mode_index == 0) {\n\t\t\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\t\t\trdev->pm.dynpm_can_downclock = false;\n\t\t\t\t} else\n\t\t\t\t\trdev->pm.requested_clock_mode_index =\n\t\t\t\t\t\trdev->pm.current_clock_mode_index - 1;\n\t\t\t} else {\n\t\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\t\trdev->pm.dynpm_can_downclock = false;\n\t\t\t}\n\t\t\t \n\t\t\tif ((rdev->pm.active_crtc_count > 0) &&\n\t\t\t    (rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t\t     clock_info[rdev->pm.requested_clock_mode_index].flags &\n\t\t\t     RADEON_PM_MODE_NO_DISPLAY)) {\n\t\t\t\trdev->pm.requested_clock_mode_index++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_UPCLOCK:\n\t\t\tif (rdev->pm.requested_power_state_index == rdev->pm.current_power_state_index) {\n\t\t\t\tif (rdev->pm.current_clock_mode_index ==\n\t\t\t\t    (rdev->pm.power_state[rdev->pm.requested_power_state_index].num_clock_modes - 1)) {\n\t\t\t\t\trdev->pm.requested_clock_mode_index = rdev->pm.current_clock_mode_index;\n\t\t\t\t\trdev->pm.dynpm_can_upclock = false;\n\t\t\t\t} else\n\t\t\t\t\trdev->pm.requested_clock_mode_index =\n\t\t\t\t\t\trdev->pm.current_clock_mode_index + 1;\n\t\t\t} else {\n\t\t\t\trdev->pm.requested_clock_mode_index =\n\t\t\t\t\trdev->pm.power_state[rdev->pm.requested_power_state_index].num_clock_modes - 1;\n\t\t\t\trdev->pm.dynpm_can_upclock = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_DEFAULT:\n\t\t\trdev->pm.requested_power_state_index = rdev->pm.default_power_state_index;\n\t\t\trdev->pm.requested_clock_mode_index = 0;\n\t\t\trdev->pm.dynpm_can_upclock = false;\n\t\t\tbreak;\n\t\tcase DYNPM_ACTION_NONE:\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Requested mode for not defined action\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tDRM_DEBUG_DRIVER(\"Requested: e: %d m: %d p: %d\\n\",\n\t\t  rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t  clock_info[rdev->pm.requested_clock_mode_index].sclk,\n\t\t  rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t  clock_info[rdev->pm.requested_clock_mode_index].mclk,\n\t\t  rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t  pcie_lanes);\n}\n\nvoid rs780_pm_init_profile(struct radeon_device *rdev)\n{\n\tif (rdev->pm.num_power_states == 2) {\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 0;\n\t} else if (rdev->pm.num_power_states == 3) {\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = 1;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 0;\n\t} else {\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = 3;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = 2;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = 3;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 0;\n\t}\n}\n\nvoid r600_pm_init_profile(struct radeon_device *rdev)\n{\n\tint idx;\n\n\tif (rdev->family == CHIP_R600) {\n\t\t \n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 0;\n\t\t \n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 0;\n\t} else {\n\t\tif (rdev->pm.num_power_states < 4) {\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 2;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = 1;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = 1;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = 1;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = 1;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 1;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = 1;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = 1;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 2;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = 2;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = 2;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = 2;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = 2;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 1;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = 2;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = 2;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 2;\n\t\t} else {\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 2;\n\t\t\t \n\t\t\tif (rdev->flags & RADEON_IS_MOBILITY)\n\t\t\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_BATTERY, 0);\n\t\t\telse\n\t\t\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 0);\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 1;\n\t\t\t \n\t\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 0);\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 2;\n\t\t\t \n\t\t\tif (rdev->flags & RADEON_IS_MOBILITY)\n\t\t\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_BATTERY, 1);\n\t\t\telse\n\t\t\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 1);\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t\t\t \n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 1;\n\t\t\t \n\t\t\tidx = radeon_pm_get_type_index(rdev, POWER_STATE_TYPE_PERFORMANCE, 1);\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = idx;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\t\t\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 2;\n\t\t}\n\t}\n}\n\nvoid r600_pm_misc(struct radeon_device *rdev)\n{\n\tint req_ps_idx = rdev->pm.requested_power_state_index;\n\tint req_cm_idx = rdev->pm.requested_clock_mode_index;\n\tstruct radeon_power_state *ps = &rdev->pm.power_state[req_ps_idx];\n\tstruct radeon_voltage *voltage = &ps->clock_info[req_cm_idx].voltage;\n\n\tif ((voltage->type == VOLTAGE_SW) && voltage->voltage) {\n\t\t \n\t\tif (voltage->voltage == 0xff01)\n\t\t\treturn;\n\t\tif (voltage->voltage != rdev->pm.current_vddc) {\n\t\t\tradeon_atom_set_voltage(rdev, voltage->voltage, SET_VOLTAGE_TYPE_ASIC_VDDC);\n\t\t\trdev->pm.current_vddc = voltage->voltage;\n\t\t\tDRM_DEBUG_DRIVER(\"Setting: v: %d\\n\", voltage->voltage);\n\t\t}\n\t}\n}\n\nbool r600_gui_idle(struct radeon_device *rdev)\n{\n\tif (RREG32(GRBM_STATUS) & GUI_ACTIVE)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n \nbool r600_hpd_sense(struct radeon_device *rdev, enum radeon_hpd_id hpd)\n{\n\tbool connected = false;\n\n\tif (ASIC_IS_DCE3(rdev)) {\n\t\tswitch (hpd) {\n\t\tcase RADEON_HPD_1:\n\t\t\tif (RREG32(DC_HPD1_INT_STATUS) & DC_HPDx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tcase RADEON_HPD_2:\n\t\t\tif (RREG32(DC_HPD2_INT_STATUS) & DC_HPDx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tcase RADEON_HPD_3:\n\t\t\tif (RREG32(DC_HPD3_INT_STATUS) & DC_HPDx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tcase RADEON_HPD_4:\n\t\t\tif (RREG32(DC_HPD4_INT_STATUS) & DC_HPDx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\t\t \n\t\tcase RADEON_HPD_5:\n\t\t\tif (RREG32(DC_HPD5_INT_STATUS) & DC_HPDx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tcase RADEON_HPD_6:\n\t\t\tif (RREG32(DC_HPD6_INT_STATUS) & DC_HPDx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (hpd) {\n\t\tcase RADEON_HPD_1:\n\t\t\tif (RREG32(DC_HOT_PLUG_DETECT1_INT_STATUS) & DC_HOT_PLUG_DETECTx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tcase RADEON_HPD_2:\n\t\t\tif (RREG32(DC_HOT_PLUG_DETECT2_INT_STATUS) & DC_HOT_PLUG_DETECTx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tcase RADEON_HPD_3:\n\t\t\tif (RREG32(DC_HOT_PLUG_DETECT3_INT_STATUS) & DC_HOT_PLUG_DETECTx_SENSE)\n\t\t\t\tconnected = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn connected;\n}\n\nvoid r600_hpd_set_polarity(struct radeon_device *rdev,\n\t\t\t   enum radeon_hpd_id hpd)\n{\n\tu32 tmp;\n\tbool connected = r600_hpd_sense(rdev, hpd);\n\n\tif (ASIC_IS_DCE3(rdev)) {\n\t\tswitch (hpd) {\n\t\tcase RADEON_HPD_1:\n\t\t\ttmp = RREG32(DC_HPD1_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HPDx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD1_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tcase RADEON_HPD_2:\n\t\t\ttmp = RREG32(DC_HPD2_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HPDx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD2_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tcase RADEON_HPD_3:\n\t\t\ttmp = RREG32(DC_HPD3_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HPDx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD3_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tcase RADEON_HPD_4:\n\t\t\ttmp = RREG32(DC_HPD4_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HPDx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD4_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tcase RADEON_HPD_5:\n\t\t\ttmp = RREG32(DC_HPD5_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HPDx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD5_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\t\t \n\t\tcase RADEON_HPD_6:\n\t\t\ttmp = RREG32(DC_HPD6_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HPDx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD6_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (hpd) {\n\t\tcase RADEON_HPD_1:\n\t\t\ttmp = RREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\t\tWREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tcase RADEON_HPD_2:\n\t\t\ttmp = RREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\t\tWREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tcase RADEON_HPD_3:\n\t\t\ttmp = RREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL);\n\t\t\tif (connected)\n\t\t\t\ttmp &= ~DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\t\telse\n\t\t\t\ttmp |= DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\t\tWREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL, tmp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid r600_hpd_init(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned enable = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP ||\n\t\t    connector->connector_type == DRM_MODE_CONNECTOR_LVDS) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\t\tif (ASIC_IS_DCE3(rdev)) {\n\t\t\tu32 tmp = DC_HPDx_CONNECTION_TIMER(0x9c4) | DC_HPDx_RX_INT_TIMER(0xfa);\n\t\t\tif (ASIC_IS_DCE32(rdev))\n\t\t\t\ttmp |= DC_HPDx_EN;\n\n\t\t\tswitch (radeon_connector->hpd.hpd) {\n\t\t\tcase RADEON_HPD_1:\n\t\t\t\tWREG32(DC_HPD1_CONTROL, tmp);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_2:\n\t\t\t\tWREG32(DC_HPD2_CONTROL, tmp);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_3:\n\t\t\t\tWREG32(DC_HPD3_CONTROL, tmp);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_4:\n\t\t\t\tWREG32(DC_HPD4_CONTROL, tmp);\n\t\t\t\tbreak;\n\t\t\t\t \n\t\t\tcase RADEON_HPD_5:\n\t\t\t\tWREG32(DC_HPD5_CONTROL, tmp);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_6:\n\t\t\t\tWREG32(DC_HPD6_CONTROL, tmp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (radeon_connector->hpd.hpd) {\n\t\t\tcase RADEON_HPD_1:\n\t\t\t\tWREG32(DC_HOT_PLUG_DETECT1_CONTROL, DC_HOT_PLUG_DETECTx_EN);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_2:\n\t\t\t\tWREG32(DC_HOT_PLUG_DETECT2_CONTROL, DC_HOT_PLUG_DETECTx_EN);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_3:\n\t\t\t\tWREG32(DC_HOT_PLUG_DETECT3_CONTROL, DC_HOT_PLUG_DETECTx_EN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tenable |= 1 << radeon_connector->hpd.hpd;\n\t\tradeon_hpd_set_polarity(rdev, radeon_connector->hpd.hpd);\n\t}\n\tradeon_irq_kms_enable_hpd(rdev, enable);\n}\n\nvoid r600_hpd_fini(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned disable = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tif (ASIC_IS_DCE3(rdev)) {\n\t\t\tswitch (radeon_connector->hpd.hpd) {\n\t\t\tcase RADEON_HPD_1:\n\t\t\t\tWREG32(DC_HPD1_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_2:\n\t\t\t\tWREG32(DC_HPD2_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_3:\n\t\t\t\tWREG32(DC_HPD3_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_4:\n\t\t\t\tWREG32(DC_HPD4_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\t\t \n\t\t\tcase RADEON_HPD_5:\n\t\t\t\tWREG32(DC_HPD5_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_6:\n\t\t\t\tWREG32(DC_HPD6_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (radeon_connector->hpd.hpd) {\n\t\t\tcase RADEON_HPD_1:\n\t\t\t\tWREG32(DC_HOT_PLUG_DETECT1_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_2:\n\t\t\t\tWREG32(DC_HOT_PLUG_DETECT2_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tcase RADEON_HPD_3:\n\t\t\t\tWREG32(DC_HOT_PLUG_DETECT3_CONTROL, 0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tdisable |= 1 << radeon_connector->hpd.hpd;\n\t}\n\tradeon_irq_kms_disable_hpd(rdev, disable);\n}\n\n \nvoid r600_pcie_gart_tlb_flush(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tu32 tmp;\n\n\t \n\tif ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740) &&\n\t    !(rdev->flags & RADEON_IS_AGP)) {\n\t\tvoid __iomem *ptr = (void *)rdev->gart.ptr;\n\n\t\t \n\t\tWREG32(HDP_DEBUG1, 0);\n\t\treadl((void __iomem *)ptr);\n\t} else\n\t\tWREG32(R_005480_HDP_MEM_COHERENCY_FLUSH_CNTL, 0x1);\n\n\tWREG32(VM_CONTEXT0_INVALIDATION_LOW_ADDR, rdev->mc.gtt_start >> 12);\n\tWREG32(VM_CONTEXT0_INVALIDATION_HIGH_ADDR, (rdev->mc.gtt_end - 1) >> 12);\n\tWREG32(VM_CONTEXT0_REQUEST_RESPONSE, REQUEST_TYPE(1));\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(VM_CONTEXT0_REQUEST_RESPONSE);\n\t\ttmp = (tmp & RESPONSE_TYPE_MASK) >> RESPONSE_TYPE_SHIFT;\n\t\tif (tmp == 2) {\n\t\t\tpr_warn(\"[drm] r600 flush TLB failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (tmp) {\n\t\t\treturn;\n\t\t}\n\t\tudelay(1);\n\t}\n}\n\nint r600_pcie_gart_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->gart.robj) {\n\t\tWARN(1, \"R600 PCIE GART already initialized\\n\");\n\t\treturn 0;\n\t}\n\t \n\tr = radeon_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trdev->gart.table_size = rdev->gart.num_gpu_pages * 8;\n\treturn radeon_gart_table_vram_alloc(rdev);\n}\n\nstatic int r600_pcie_gart_enable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint r, i;\n\n\tif (rdev->gart.robj == NULL) {\n\t\tdev_err(rdev->dev, \"No VRAM object for PCIE GART.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_gart_table_vram_pin(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE | ENABLE_L2_FRAGMENT_PROCESSING |\n\t\t\t\tENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t\t\t\tEFFECTIVE_L2_QUEUE_SIZE(7));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, BANK_SELECT_0(0) | BANK_SELECT_1(1));\n\t \n\ttmp = ENABLE_L1_TLB | ENABLE_L1_FRAGMENT_PROCESSING |\n\t\tSYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t\tEFFECTIVE_L1_TLB_SIZE(5) | EFFECTIVE_L1_QUEUE_SIZE(5) |\n\t\tENABLE_WAIT_L2_QUERY;\n\tWREG32(MC_VM_L1_TLB_MCB_RD_SYS_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_SYS_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_HDP_CNTL, tmp | ENABLE_L1_STRICT_ORDERING);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_HDP_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_RD_A_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_WR_A_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_RD_B_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_WR_B_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_GFX_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_GFX_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_PDMA_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_PDMA_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_UVD_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_UVD_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_SEM_CNTL, tmp | ENABLE_SEMAPHORE_MODE);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_SEM_CNTL, tmp | ENABLE_SEMAPHORE_MODE);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);\n\tWREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR, rdev->gart.table_addr >> 12);\n\tWREG32(VM_CONTEXT0_CNTL, ENABLE_CONTEXT | PAGE_TABLE_DEPTH(0) |\n\t\t\t\tRANGE_PROTECTION_FAULT_ENABLE_DEFAULT);\n\tWREG32(VM_CONTEXT0_PROTECTION_FAULT_DEFAULT_ADDR,\n\t\t\t(u32)(rdev->dummy_page.addr >> 12));\n\tfor (i = 1; i < 7; i++)\n\t\tWREG32(VM_CONTEXT0_CNTL + (i * 4), 0);\n\n\tr600_pcie_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nstatic void r600_pcie_gart_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint i;\n\n\t \n\tfor (i = 0; i < 7; i++)\n\t\tWREG32(VM_CONTEXT0_CNTL + (i * 4), 0);\n\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_FRAGMENT_PROCESSING |\n\t\t\t\tEFFECTIVE_L2_QUEUE_SIZE(7));\n\tWREG32(VM_L2_CNTL3, BANK_SELECT_0(0) | BANK_SELECT_1(1));\n\t \n\ttmp = EFFECTIVE_L1_TLB_SIZE(5) | EFFECTIVE_L1_QUEUE_SIZE(5) |\n\t\tENABLE_WAIT_L2_QUERY;\n\tWREG32(MC_VM_L1_TLB_MCD_RD_A_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_WR_A_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_RD_B_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_WR_B_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_GFX_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_GFX_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_PDMA_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_PDMA_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_SEM_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_SEM_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_SYS_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_SYS_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_HDP_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_HDP_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_UVD_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_UVD_CNTL, tmp);\n\tradeon_gart_table_vram_unpin(rdev);\n}\n\nstatic void r600_pcie_gart_fini(struct radeon_device *rdev)\n{\n\tradeon_gart_fini(rdev);\n\tr600_pcie_gart_disable(rdev);\n\tradeon_gart_table_vram_free(rdev);\n}\n\nstatic void r600_agp_enable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint i;\n\n\t \n\tWREG32(VM_L2_CNTL, ENABLE_L2_CACHE | ENABLE_L2_FRAGMENT_PROCESSING |\n\t\t\t\tENABLE_L2_PTE_CACHE_LRU_UPDATE_BY_WRITE |\n\t\t\t\tEFFECTIVE_L2_QUEUE_SIZE(7));\n\tWREG32(VM_L2_CNTL2, 0);\n\tWREG32(VM_L2_CNTL3, BANK_SELECT_0(0) | BANK_SELECT_1(1));\n\t \n\ttmp = ENABLE_L1_TLB | ENABLE_L1_FRAGMENT_PROCESSING |\n\t\tSYSTEM_ACCESS_MODE_NOT_IN_SYS |\n\t\tEFFECTIVE_L1_TLB_SIZE(5) | EFFECTIVE_L1_QUEUE_SIZE(5) |\n\t\tENABLE_WAIT_L2_QUERY;\n\tWREG32(MC_VM_L1_TLB_MCB_RD_SYS_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_SYS_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_HDP_CNTL, tmp | ENABLE_L1_STRICT_ORDERING);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_HDP_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_RD_A_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_WR_A_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_RD_B_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCD_WR_B_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_GFX_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_GFX_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_PDMA_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_PDMA_CNTL, tmp);\n\tWREG32(MC_VM_L1_TLB_MCB_RD_SEM_CNTL, tmp | ENABLE_SEMAPHORE_MODE);\n\tWREG32(MC_VM_L1_TLB_MCB_WR_SEM_CNTL, tmp | ENABLE_SEMAPHORE_MODE);\n\tfor (i = 0; i < 7; i++)\n\t\tWREG32(VM_CONTEXT0_CNTL + (i * 4), 0);\n}\n\nint r600_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tu32 tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(R_000E50_SRBM_STATUS) & 0x3F00;\n\t\tif (!tmp)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nuint32_t rs780_mc_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t r;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(R_0028F8_MC_INDEX, S_0028F8_MC_IND_ADDR(reg));\n\tr = RREG32(R_0028FC_MC_DATA);\n\tWREG32(R_0028F8_MC_INDEX, ~C_0028F8_MC_IND_ADDR);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n\treturn r;\n}\n\nvoid rs780_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(R_0028F8_MC_INDEX, S_0028F8_MC_IND_ADDR(reg) |\n\t\tS_0028F8_MC_IND_WR_EN(1));\n\tWREG32(R_0028FC_MC_DATA, v);\n\tWREG32(R_0028F8_MC_INDEX, 0x7F);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n}\n\nstatic void r600_mc_program(struct radeon_device *rdev)\n{\n\tstruct rv515_mc_save save;\n\tu32 tmp;\n\tint i, j;\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\tWREG32(HDP_REG_COHERENCY_FLUSH_CNTL, 0);\n\n\trv515_mc_stop(rdev, &save);\n\tif (r600_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\t \n\tWREG32(VGA_HDP_CONTROL, VGA_MEMORY_DISABLE);\n\t \n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tif (rdev->mc.vram_start < rdev->mc.gtt_start) {\n\t\t\t \n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t\t\t\trdev->mc.vram_start >> 12);\n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t\t\t\trdev->mc.gtt_end >> 12);\n\t\t} else {\n\t\t\t \n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR,\n\t\t\t\trdev->mc.gtt_start >> 12);\n\t\t\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR,\n\t\t\t\trdev->mc.vram_end >> 12);\n\t\t}\n\t} else {\n\t\tWREG32(MC_VM_SYSTEM_APERTURE_LOW_ADDR, rdev->mc.vram_start >> 12);\n\t\tWREG32(MC_VM_SYSTEM_APERTURE_HIGH_ADDR, rdev->mc.vram_end >> 12);\n\t}\n\tWREG32(MC_VM_SYSTEM_APERTURE_DEFAULT_ADDR, rdev->vram_scratch.gpu_addr >> 12);\n\ttmp = ((rdev->mc.vram_end >> 24) & 0xFFFF) << 16;\n\ttmp |= ((rdev->mc.vram_start >> 24) & 0xFFFF);\n\tWREG32(MC_VM_FB_LOCATION, tmp);\n\tWREG32(HDP_NONSURFACE_BASE, (rdev->mc.vram_start >> 8));\n\tWREG32(HDP_NONSURFACE_INFO, (2 << 7));\n\tWREG32(HDP_NONSURFACE_SIZE, 0x3FFFFFFF);\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tWREG32(MC_VM_AGP_TOP, rdev->mc.gtt_end >> 22);\n\t\tWREG32(MC_VM_AGP_BOT, rdev->mc.gtt_start >> 22);\n\t\tWREG32(MC_VM_AGP_BASE, rdev->mc.agp_base >> 22);\n\t} else {\n\t\tWREG32(MC_VM_AGP_BASE, 0);\n\t\tWREG32(MC_VM_AGP_TOP, 0x0FFFFFFF);\n\t\tWREG32(MC_VM_AGP_BOT, 0x0FFFFFFF);\n\t}\n\tif (r600_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\trv515_mc_resume(rdev, &save);\n\t \n\trv515_vga_render_disable(rdev);\n}\n\n \nstatic void r600_vram_gtt_location(struct radeon_device *rdev, struct radeon_mc *mc)\n{\n\tu64 size_bf, size_af;\n\n\tif (mc->mc_vram_size > 0xE0000000) {\n\t\t \n\t\tdev_warn(rdev->dev, \"limiting VRAM\\n\");\n\t\tmc->real_vram_size = 0xE0000000;\n\t\tmc->mc_vram_size = 0xE0000000;\n\t}\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tsize_bf = mc->gtt_start;\n\t\tsize_af = mc->mc_mask - mc->gtt_end;\n\t\tif (size_bf > size_af) {\n\t\t\tif (mc->mc_vram_size > size_bf) {\n\t\t\t\tdev_warn(rdev->dev, \"limiting VRAM\\n\");\n\t\t\t\tmc->real_vram_size = size_bf;\n\t\t\t\tmc->mc_vram_size = size_bf;\n\t\t\t}\n\t\t\tmc->vram_start = mc->gtt_start - mc->mc_vram_size;\n\t\t} else {\n\t\t\tif (mc->mc_vram_size > size_af) {\n\t\t\t\tdev_warn(rdev->dev, \"limiting VRAM\\n\");\n\t\t\t\tmc->real_vram_size = size_af;\n\t\t\t\tmc->mc_vram_size = size_af;\n\t\t\t}\n\t\t\tmc->vram_start = mc->gtt_end + 1;\n\t\t}\n\t\tmc->vram_end = mc->vram_start + mc->mc_vram_size - 1;\n\t\tdev_info(rdev->dev, \"VRAM: %lluM 0x%08llX - 0x%08llX (%lluM used)\\n\",\n\t\t\t\tmc->mc_vram_size >> 20, mc->vram_start,\n\t\t\t\tmc->vram_end, mc->real_vram_size >> 20);\n\t} else {\n\t\tu64 base = 0;\n\t\tif (rdev->flags & RADEON_IS_IGP) {\n\t\t\tbase = RREG32(MC_VM_FB_LOCATION) & 0xFFFF;\n\t\t\tbase <<= 24;\n\t\t}\n\t\tradeon_vram_location(rdev, &rdev->mc, base);\n\t\trdev->mc.gtt_base_align = 0;\n\t\tradeon_gtt_location(rdev, mc);\n\t}\n}\n\nstatic int r600_mc_init(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint chansize, numchan;\n\tuint32_t h_addr, l_addr;\n\tunsigned long long k8_addr;\n\n\t \n\trdev->mc.vram_is_ddr = true;\n\ttmp = RREG32(RAMCFG);\n\tif (tmp & CHANSIZE_OVERRIDE) {\n\t\tchansize = 16;\n\t} else if (tmp & CHANSIZE_MASK) {\n\t\tchansize = 64;\n\t} else {\n\t\tchansize = 32;\n\t}\n\ttmp = RREG32(CHMAP);\n\tswitch ((tmp & NOOFCHAN_MASK) >> NOOFCHAN_SHIFT) {\n\tcase 0:\n\tdefault:\n\t\tnumchan = 1;\n\t\tbreak;\n\tcase 1:\n\t\tnumchan = 2;\n\t\tbreak;\n\tcase 2:\n\t\tnumchan = 4;\n\t\tbreak;\n\tcase 3:\n\t\tnumchan = 8;\n\t\tbreak;\n\t}\n\trdev->mc.vram_width = numchan * chansize;\n\t \n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\t \n\trdev->mc.mc_vram_size = RREG32(CONFIG_MEMSIZE);\n\trdev->mc.real_vram_size = RREG32(CONFIG_MEMSIZE);\n\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\tr600_vram_gtt_location(rdev, &rdev->mc);\n\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\trs690_pm_info(rdev);\n\t\trdev->mc.igp_sideport_enabled = radeon_atombios_sideport_present(rdev);\n\n\t\tif (rdev->family == CHIP_RS780 || rdev->family == CHIP_RS880) {\n\t\t\t \n\t\t\trdev->fastfb_working = false;\n\t\t\th_addr = G_000012_K8_ADDR_EXT(RREG32_MC(R_000012_MC_MISC_UMA_CNTL));\n\t\t\tl_addr = RREG32_MC(R_000011_K8_FB_LOCATION);\n\t\t\tk8_addr = ((unsigned long long)h_addr) << 32 | l_addr;\n#if defined(CONFIG_X86_32) && !defined(CONFIG_X86_PAE)\n\t\t\tif (k8_addr + rdev->mc.visible_vram_size < 0x100000000ULL)\n#endif\n\t\t\t{\n\t\t\t\t \n\t\t\t\tif (rdev->mc.igp_sideport_enabled == false && radeon_fastfb == 1) {\n\t\t\t\t\tDRM_INFO(\"Direct mapping: aper base at 0x%llx, replaced by direct mapping base 0x%llx.\\n\",\n\t\t\t\t\t\t(unsigned long long)rdev->mc.aper_base, k8_addr);\n\t\t\t\t\trdev->mc.aper_base = (resource_size_t)k8_addr;\n\t\t\t\t\trdev->fastfb_working = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tradeon_update_bandwidth_info(rdev);\n\treturn 0;\n}\n\nint r600_vram_scratch_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->vram_scratch.robj == NULL) {\n\t\tr = radeon_bo_create(rdev, RADEON_GPU_PAGE_SIZE,\n\t\t\t\t     PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t     0, NULL, NULL, &rdev->vram_scratch.robj);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tr = radeon_bo_reserve(rdev->vram_scratch.robj, false);\n\tif (unlikely(r != 0))\n\t\treturn r;\n\tr = radeon_bo_pin(rdev->vram_scratch.robj,\n\t\t\t  RADEON_GEM_DOMAIN_VRAM, &rdev->vram_scratch.gpu_addr);\n\tif (r) {\n\t\tradeon_bo_unreserve(rdev->vram_scratch.robj);\n\t\treturn r;\n\t}\n\tr = radeon_bo_kmap(rdev->vram_scratch.robj,\n\t\t\t\t(void **)&rdev->vram_scratch.ptr);\n\tif (r)\n\t\tradeon_bo_unpin(rdev->vram_scratch.robj);\n\tradeon_bo_unreserve(rdev->vram_scratch.robj);\n\n\treturn r;\n}\n\nvoid r600_vram_scratch_fini(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->vram_scratch.robj == NULL) {\n\t\treturn;\n\t}\n\tr = radeon_bo_reserve(rdev->vram_scratch.robj, false);\n\tif (likely(r == 0)) {\n\t\tradeon_bo_kunmap(rdev->vram_scratch.robj);\n\t\tradeon_bo_unpin(rdev->vram_scratch.robj);\n\t\tradeon_bo_unreserve(rdev->vram_scratch.robj);\n\t}\n\tradeon_bo_unref(&rdev->vram_scratch.robj);\n}\n\nvoid r600_set_bios_scratch_engine_hung(struct radeon_device *rdev, bool hung)\n{\n\tu32 tmp = RREG32(R600_BIOS_3_SCRATCH);\n\n\tif (hung)\n\t\ttmp |= ATOM_S3_ASIC_GUI_ENGINE_HUNG;\n\telse\n\t\ttmp &= ~ATOM_S3_ASIC_GUI_ENGINE_HUNG;\n\n\tWREG32(R600_BIOS_3_SCRATCH, tmp);\n}\n\nstatic void r600_print_gpu_status_regs(struct radeon_device *rdev)\n{\n\tdev_info(rdev->dev, \"  R_008010_GRBM_STATUS      = 0x%08X\\n\",\n\t\t RREG32(R_008010_GRBM_STATUS));\n\tdev_info(rdev->dev, \"  R_008014_GRBM_STATUS2     = 0x%08X\\n\",\n\t\t RREG32(R_008014_GRBM_STATUS2));\n\tdev_info(rdev->dev, \"  R_000E50_SRBM_STATUS      = 0x%08X\\n\",\n\t\t RREG32(R_000E50_SRBM_STATUS));\n\tdev_info(rdev->dev, \"  R_008674_CP_STALLED_STAT1 = 0x%08X\\n\",\n\t\t RREG32(CP_STALLED_STAT1));\n\tdev_info(rdev->dev, \"  R_008678_CP_STALLED_STAT2 = 0x%08X\\n\",\n\t\t RREG32(CP_STALLED_STAT2));\n\tdev_info(rdev->dev, \"  R_00867C_CP_BUSY_STAT     = 0x%08X\\n\",\n\t\t RREG32(CP_BUSY_STAT));\n\tdev_info(rdev->dev, \"  R_008680_CP_STAT          = 0x%08X\\n\",\n\t\t RREG32(CP_STAT));\n\tdev_info(rdev->dev, \"  R_00D034_DMA_STATUS_REG   = 0x%08X\\n\",\n\t\tRREG32(DMA_STATUS_REG));\n}\n\nstatic bool r600_is_display_hung(struct radeon_device *rdev)\n{\n\tu32 crtc_hung = 0;\n\tu32 crtc_status[2];\n\tu32 i, j, tmp;\n\n\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\tif (RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]) & AVIVO_CRTC_EN) {\n\t\t\tcrtc_status[i] = RREG32(AVIVO_D1CRTC_STATUS_HV_COUNT + crtc_offsets[i]);\n\t\t\tcrtc_hung |= (1 << i);\n\t\t}\n\t}\n\n\tfor (j = 0; j < 10; j++) {\n\t\tfor (i = 0; i < rdev->num_crtc; i++) {\n\t\t\tif (crtc_hung & (1 << i)) {\n\t\t\t\ttmp = RREG32(AVIVO_D1CRTC_STATUS_HV_COUNT + crtc_offsets[i]);\n\t\t\t\tif (tmp != crtc_status[i])\n\t\t\t\t\tcrtc_hung &= ~(1 << i);\n\t\t\t}\n\t\t}\n\t\tif (crtc_hung == 0)\n\t\t\treturn false;\n\t\tudelay(100);\n\t}\n\n\treturn true;\n}\n\nu32 r600_gpu_check_soft_reset(struct radeon_device *rdev)\n{\n\tu32 reset_mask = 0;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(R_008010_GRBM_STATUS);\n\tif (rdev->family >= CHIP_RV770) {\n\t\tif (G_008010_PA_BUSY(tmp) | G_008010_SC_BUSY(tmp) |\n\t\t    G_008010_SH_BUSY(tmp) | G_008010_SX_BUSY(tmp) |\n\t\t    G_008010_TA_BUSY(tmp) | G_008010_VGT_BUSY(tmp) |\n\t\t    G_008010_DB03_BUSY(tmp) | G_008010_CB03_BUSY(tmp) |\n\t\t    G_008010_SPI03_BUSY(tmp) | G_008010_VGT_BUSY_NO_DMA(tmp))\n\t\t\treset_mask |= RADEON_RESET_GFX;\n\t} else {\n\t\tif (G_008010_PA_BUSY(tmp) | G_008010_SC_BUSY(tmp) |\n\t\t    G_008010_SH_BUSY(tmp) | G_008010_SX_BUSY(tmp) |\n\t\t    G_008010_TA03_BUSY(tmp) | G_008010_VGT_BUSY(tmp) |\n\t\t    G_008010_DB03_BUSY(tmp) | G_008010_CB03_BUSY(tmp) |\n\t\t    G_008010_SPI03_BUSY(tmp) | G_008010_VGT_BUSY_NO_DMA(tmp))\n\t\t\treset_mask |= RADEON_RESET_GFX;\n\t}\n\n\tif (G_008010_CF_RQ_PENDING(tmp) | G_008010_PF_RQ_PENDING(tmp) |\n\t    G_008010_CP_BUSY(tmp) | G_008010_CP_COHERENCY_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_CP;\n\n\tif (G_008010_GRBM_EE_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_GRBM | RADEON_RESET_GFX | RADEON_RESET_CP;\n\n\t \n\ttmp = RREG32(DMA_STATUS_REG);\n\tif (!(tmp & DMA_IDLE))\n\t\treset_mask |= RADEON_RESET_DMA;\n\n\t \n\ttmp = RREG32(R_000E50_SRBM_STATUS);\n\tif (G_000E50_RLC_RQ_PENDING(tmp) | G_000E50_RLC_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_RLC;\n\n\tif (G_000E50_IH_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_IH;\n\n\tif (G_000E50_SEM_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_SEM;\n\n\tif (G_000E50_GRBM_RQ_PENDING(tmp))\n\t\treset_mask |= RADEON_RESET_GRBM;\n\n\tif (G_000E50_VMC_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_VMC;\n\n\tif (G_000E50_MCB_BUSY(tmp) | G_000E50_MCDZ_BUSY(tmp) |\n\t    G_000E50_MCDY_BUSY(tmp) | G_000E50_MCDX_BUSY(tmp) |\n\t    G_000E50_MCDW_BUSY(tmp))\n\t\treset_mask |= RADEON_RESET_MC;\n\n\tif (r600_is_display_hung(rdev))\n\t\treset_mask |= RADEON_RESET_DISPLAY;\n\n\t \n\tif (reset_mask & RADEON_RESET_MC) {\n\t\tDRM_DEBUG(\"MC busy: 0x%08X, clearing.\\n\", reset_mask);\n\t\treset_mask &= ~RADEON_RESET_MC;\n\t}\n\n\treturn reset_mask;\n}\n\nstatic void r600_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)\n{\n\tstruct rv515_mc_save save;\n\tu32 grbm_soft_reset = 0, srbm_soft_reset = 0;\n\tu32 tmp;\n\n\tif (reset_mask == 0)\n\t\treturn;\n\n\tdev_info(rdev->dev, \"GPU softreset: 0x%08X\\n\", reset_mask);\n\n\tr600_print_gpu_status_regs(rdev);\n\n\t \n\tif (rdev->family >= CHIP_RV770)\n\t\tWREG32(R_0086D8_CP_ME_CNTL, S_0086D8_CP_ME_HALT(1) | S_0086D8_CP_PFP_HALT(1));\n\telse\n\t\tWREG32(R_0086D8_CP_ME_CNTL, S_0086D8_CP_ME_HALT(1));\n\n\t \n\tWREG32(RLC_CNTL, 0);\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\t \n\t\ttmp = RREG32(DMA_RB_CNTL);\n\t\ttmp &= ~DMA_RB_ENABLE;\n\t\tWREG32(DMA_RB_CNTL, tmp);\n\t}\n\n\tmdelay(50);\n\n\trv515_mc_stop(rdev, &save);\n\tif (r600_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\n\tif (reset_mask & (RADEON_RESET_GFX | RADEON_RESET_COMPUTE)) {\n\t\tif (rdev->family >= CHIP_RV770)\n\t\t\tgrbm_soft_reset |= S_008020_SOFT_RESET_DB(1) |\n\t\t\t\tS_008020_SOFT_RESET_CB(1) |\n\t\t\t\tS_008020_SOFT_RESET_PA(1) |\n\t\t\t\tS_008020_SOFT_RESET_SC(1) |\n\t\t\t\tS_008020_SOFT_RESET_SPI(1) |\n\t\t\t\tS_008020_SOFT_RESET_SX(1) |\n\t\t\t\tS_008020_SOFT_RESET_SH(1) |\n\t\t\t\tS_008020_SOFT_RESET_TC(1) |\n\t\t\t\tS_008020_SOFT_RESET_TA(1) |\n\t\t\t\tS_008020_SOFT_RESET_VC(1) |\n\t\t\t\tS_008020_SOFT_RESET_VGT(1);\n\t\telse\n\t\t\tgrbm_soft_reset |= S_008020_SOFT_RESET_CR(1) |\n\t\t\t\tS_008020_SOFT_RESET_DB(1) |\n\t\t\t\tS_008020_SOFT_RESET_CB(1) |\n\t\t\t\tS_008020_SOFT_RESET_PA(1) |\n\t\t\t\tS_008020_SOFT_RESET_SC(1) |\n\t\t\t\tS_008020_SOFT_RESET_SMX(1) |\n\t\t\t\tS_008020_SOFT_RESET_SPI(1) |\n\t\t\t\tS_008020_SOFT_RESET_SX(1) |\n\t\t\t\tS_008020_SOFT_RESET_SH(1) |\n\t\t\t\tS_008020_SOFT_RESET_TC(1) |\n\t\t\t\tS_008020_SOFT_RESET_TA(1) |\n\t\t\t\tS_008020_SOFT_RESET_VC(1) |\n\t\t\t\tS_008020_SOFT_RESET_VGT(1);\n\t}\n\n\tif (reset_mask & RADEON_RESET_CP) {\n\t\tgrbm_soft_reset |= S_008020_SOFT_RESET_CP(1) |\n\t\t\tS_008020_SOFT_RESET_VGT(1);\n\n\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_GRBM(1);\n\t}\n\n\tif (reset_mask & RADEON_RESET_DMA) {\n\t\tif (rdev->family >= CHIP_RV770)\n\t\t\tsrbm_soft_reset |= RV770_SOFT_RESET_DMA;\n\t\telse\n\t\t\tsrbm_soft_reset |= SOFT_RESET_DMA;\n\t}\n\n\tif (reset_mask & RADEON_RESET_RLC)\n\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_RLC(1);\n\n\tif (reset_mask & RADEON_RESET_SEM)\n\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_SEM(1);\n\n\tif (reset_mask & RADEON_RESET_IH)\n\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_IH(1);\n\n\tif (reset_mask & RADEON_RESET_GRBM)\n\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_GRBM(1);\n\n\tif (!(rdev->flags & RADEON_IS_IGP)) {\n\t\tif (reset_mask & RADEON_RESET_MC)\n\t\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_MC(1);\n\t}\n\n\tif (reset_mask & RADEON_RESET_VMC)\n\t\tsrbm_soft_reset |= S_000E60_SOFT_RESET_VMC(1);\n\n\tif (grbm_soft_reset) {\n\t\ttmp = RREG32(R_008020_GRBM_SOFT_RESET);\n\t\ttmp |= grbm_soft_reset;\n\t\tdev_info(rdev->dev, \"R_008020_GRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(R_008020_GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(R_008020_GRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~grbm_soft_reset;\n\t\tWREG32(R_008020_GRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(R_008020_GRBM_SOFT_RESET);\n\t}\n\n\tif (srbm_soft_reset) {\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t\ttmp |= srbm_soft_reset;\n\t\tdev_info(rdev->dev, \"SRBM_SOFT_RESET=0x%08X\\n\", tmp);\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\n\t\tudelay(50);\n\n\t\ttmp &= ~srbm_soft_reset;\n\t\tWREG32(SRBM_SOFT_RESET, tmp);\n\t\ttmp = RREG32(SRBM_SOFT_RESET);\n\t}\n\n\t \n\tmdelay(1);\n\n\trv515_mc_resume(rdev, &save);\n\tudelay(50);\n\n\tr600_print_gpu_status_regs(rdev);\n}\n\nstatic void r600_gpu_pci_config_reset(struct radeon_device *rdev)\n{\n\tstruct rv515_mc_save save;\n\tu32 tmp, i;\n\n\tdev_info(rdev->dev, \"GPU pci config reset\\n\");\n\n\t \n\n\t \n\tif (rdev->family >= CHIP_RV770)\n\t\tWREG32(R_0086D8_CP_ME_CNTL, S_0086D8_CP_ME_HALT(1) | S_0086D8_CP_PFP_HALT(1));\n\telse\n\t\tWREG32(R_0086D8_CP_ME_CNTL, S_0086D8_CP_ME_HALT(1));\n\n\t \n\tWREG32(RLC_CNTL, 0);\n\n\t \n\ttmp = RREG32(DMA_RB_CNTL);\n\ttmp &= ~DMA_RB_ENABLE;\n\tWREG32(DMA_RB_CNTL, tmp);\n\n\tmdelay(50);\n\n\t \n\tif (rdev->family >= CHIP_RV770)\n\t\trv770_set_clk_bypass_mode(rdev);\n\t \n\tpci_clear_master(rdev->pdev);\n\t \n\trv515_mc_stop(rdev, &save);\n\tif (r600_mc_wait_for_idle(rdev)) {\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timedout !\\n\");\n\t}\n\n\t \n\ttmp = RREG32(BUS_CNTL);\n\ttmp |= VGA_COHE_SPEC_TIMER_DIS;\n\tWREG32(BUS_CNTL, tmp);\n\n\ttmp = RREG32(BIF_SCRATCH0);\n\n\t \n\tradeon_pci_config_reset(rdev);\n\tmdelay(1);\n\n\t \n\ttmp = SOFT_RESET_BIF;\n\tWREG32(SRBM_SOFT_RESET, tmp);\n\tmdelay(1);\n\tWREG32(SRBM_SOFT_RESET, 0);\n\n\t \n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(CONFIG_MEMSIZE) != 0xffffffff)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n}\n\nint r600_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tu32 reset_mask;\n\n\tif (hard) {\n\t\tr600_gpu_pci_config_reset(rdev);\n\t\treturn 0;\n\t}\n\n\treset_mask = r600_gpu_check_soft_reset(rdev);\n\n\tif (reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, true);\n\n\t \n\tr600_gpu_soft_reset(rdev, reset_mask);\n\n\treset_mask = r600_gpu_check_soft_reset(rdev);\n\n\t \n\tif (reset_mask && radeon_hard_reset)\n\t\tr600_gpu_pci_config_reset(rdev);\n\n\treset_mask = r600_gpu_check_soft_reset(rdev);\n\n\tif (!reset_mask)\n\t\tr600_set_bios_scratch_engine_hung(rdev, false);\n\n\treturn 0;\n}\n\n \nbool r600_gfx_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = r600_gpu_check_soft_reset(rdev);\n\n\tif (!(reset_mask & (RADEON_RESET_GFX |\n\t\t\t    RADEON_RESET_COMPUTE |\n\t\t\t    RADEON_RESET_CP))) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\nu32 r6xx_remap_render_backend(struct radeon_device *rdev,\n\t\t\t      u32 tiling_pipe_num,\n\t\t\t      u32 max_rb_num,\n\t\t\t      u32 total_max_rb_num,\n\t\t\t      u32 disabled_rb_mask)\n{\n\tu32 rendering_pipe_num, rb_num_width, req_rb_num;\n\tu32 pipe_rb_ratio, pipe_rb_remain, tmp;\n\tu32 data = 0, mask = 1 << (max_rb_num - 1);\n\tunsigned i, j;\n\n\t \n\ttmp = disabled_rb_mask | ((0xff << max_rb_num) & 0xff);\n\t \n\tif ((tmp & 0xff) != 0xff)\n\t\tdisabled_rb_mask = tmp;\n\n\trendering_pipe_num = 1 << tiling_pipe_num;\n\treq_rb_num = total_max_rb_num - r600_count_pipe_bits(disabled_rb_mask);\n\tBUG_ON(rendering_pipe_num < req_rb_num);\n\n\tpipe_rb_ratio = rendering_pipe_num / req_rb_num;\n\tpipe_rb_remain = rendering_pipe_num - pipe_rb_ratio * req_rb_num;\n\n\tif (rdev->family <= CHIP_RV740) {\n\t\t \n\t\trb_num_width = 2;\n\t} else {\n\t\t \n\t\trb_num_width = 4;\n\t}\n\n\tfor (i = 0; i < max_rb_num; i++) {\n\t\tif (!(mask & disabled_rb_mask)) {\n\t\t\tfor (j = 0; j < pipe_rb_ratio; j++) {\n\t\t\t\tdata <<= rb_num_width;\n\t\t\t\tdata |= max_rb_num - i - 1;\n\t\t\t}\n\t\t\tif (pipe_rb_remain) {\n\t\t\t\tdata <<= rb_num_width;\n\t\t\t\tdata |= max_rb_num - i - 1;\n\t\t\t\tpipe_rb_remain--;\n\t\t\t}\n\t\t}\n\t\tmask >>= 1;\n\t}\n\n\treturn data;\n}\n\nint r600_count_pipe_bits(uint32_t val)\n{\n\treturn hweight32(val);\n}\n\nstatic void r600_gpu_init(struct radeon_device *rdev)\n{\n\tu32 tiling_config;\n\tu32 ramcfg;\n\tu32 cc_gc_shader_pipe_config;\n\tu32 tmp;\n\tint i, j;\n\tu32 sq_config;\n\tu32 sq_gpr_resource_mgmt_1 = 0;\n\tu32 sq_gpr_resource_mgmt_2 = 0;\n\tu32 sq_thread_resource_mgmt = 0;\n\tu32 sq_stack_resource_mgmt_1 = 0;\n\tu32 sq_stack_resource_mgmt_2 = 0;\n\tu32 disabled_rb_mask;\n\n\trdev->config.r600.tiling_group_size = 256;\n\tswitch (rdev->family) {\n\tcase CHIP_R600:\n\t\trdev->config.r600.max_pipes = 4;\n\t\trdev->config.r600.max_tile_pipes = 8;\n\t\trdev->config.r600.max_simds = 4;\n\t\trdev->config.r600.max_backends = 4;\n\t\trdev->config.r600.max_gprs = 256;\n\t\trdev->config.r600.max_threads = 192;\n\t\trdev->config.r600.max_stack_entries = 256;\n\t\trdev->config.r600.max_hw_contexts = 8;\n\t\trdev->config.r600.max_gs_threads = 16;\n\t\trdev->config.r600.sx_max_export_size = 128;\n\t\trdev->config.r600.sx_max_export_pos_size = 16;\n\t\trdev->config.r600.sx_max_export_smx_size = 128;\n\t\trdev->config.r600.sq_num_cf_insts = 2;\n\t\tbreak;\n\tcase CHIP_RV630:\n\tcase CHIP_RV635:\n\t\trdev->config.r600.max_pipes = 2;\n\t\trdev->config.r600.max_tile_pipes = 2;\n\t\trdev->config.r600.max_simds = 3;\n\t\trdev->config.r600.max_backends = 1;\n\t\trdev->config.r600.max_gprs = 128;\n\t\trdev->config.r600.max_threads = 192;\n\t\trdev->config.r600.max_stack_entries = 128;\n\t\trdev->config.r600.max_hw_contexts = 8;\n\t\trdev->config.r600.max_gs_threads = 4;\n\t\trdev->config.r600.sx_max_export_size = 128;\n\t\trdev->config.r600.sx_max_export_pos_size = 16;\n\t\trdev->config.r600.sx_max_export_smx_size = 128;\n\t\trdev->config.r600.sq_num_cf_insts = 2;\n\t\tbreak;\n\tcase CHIP_RV610:\n\tcase CHIP_RV620:\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\t\trdev->config.r600.max_pipes = 1;\n\t\trdev->config.r600.max_tile_pipes = 1;\n\t\trdev->config.r600.max_simds = 2;\n\t\trdev->config.r600.max_backends = 1;\n\t\trdev->config.r600.max_gprs = 128;\n\t\trdev->config.r600.max_threads = 192;\n\t\trdev->config.r600.max_stack_entries = 128;\n\t\trdev->config.r600.max_hw_contexts = 4;\n\t\trdev->config.r600.max_gs_threads = 4;\n\t\trdev->config.r600.sx_max_export_size = 128;\n\t\trdev->config.r600.sx_max_export_pos_size = 16;\n\t\trdev->config.r600.sx_max_export_smx_size = 128;\n\t\trdev->config.r600.sq_num_cf_insts = 1;\n\t\tbreak;\n\tcase CHIP_RV670:\n\t\trdev->config.r600.max_pipes = 4;\n\t\trdev->config.r600.max_tile_pipes = 4;\n\t\trdev->config.r600.max_simds = 4;\n\t\trdev->config.r600.max_backends = 4;\n\t\trdev->config.r600.max_gprs = 192;\n\t\trdev->config.r600.max_threads = 192;\n\t\trdev->config.r600.max_stack_entries = 256;\n\t\trdev->config.r600.max_hw_contexts = 8;\n\t\trdev->config.r600.max_gs_threads = 16;\n\t\trdev->config.r600.sx_max_export_size = 128;\n\t\trdev->config.r600.sx_max_export_pos_size = 16;\n\t\trdev->config.r600.sx_max_export_smx_size = 128;\n\t\trdev->config.r600.sq_num_cf_insts = 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, j = 0; i < 32; i++, j += 0x18) {\n\t\tWREG32((0x2c14 + j), 0x00000000);\n\t\tWREG32((0x2c18 + j), 0x00000000);\n\t\tWREG32((0x2c1c + j), 0x00000000);\n\t\tWREG32((0x2c20 + j), 0x00000000);\n\t\tWREG32((0x2c24 + j), 0x00000000);\n\t}\n\n\tWREG32(GRBM_CNTL, GRBM_READ_TIMEOUT(0xff));\n\n\t \n\ttiling_config = 0;\n\tramcfg = RREG32(RAMCFG);\n\tswitch (rdev->config.r600.max_tile_pipes) {\n\tcase 1:\n\t\ttiling_config |= PIPE_TILING(0);\n\t\tbreak;\n\tcase 2:\n\t\ttiling_config |= PIPE_TILING(1);\n\t\tbreak;\n\tcase 4:\n\t\ttiling_config |= PIPE_TILING(2);\n\t\tbreak;\n\tcase 8:\n\t\ttiling_config |= PIPE_TILING(3);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trdev->config.r600.tiling_npipes = rdev->config.r600.max_tile_pipes;\n\trdev->config.r600.tiling_nbanks = 4 << ((ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT);\n\ttiling_config |= BANK_TILING((ramcfg & NOOFBANK_MASK) >> NOOFBANK_SHIFT);\n\ttiling_config |= GROUP_SIZE((ramcfg & BURSTLENGTH_MASK) >> BURSTLENGTH_SHIFT);\n\n\ttmp = (ramcfg & NOOFROWS_MASK) >> NOOFROWS_SHIFT;\n\tif (tmp > 3) {\n\t\ttiling_config |= ROW_TILING(3);\n\t\ttiling_config |= SAMPLE_SPLIT(3);\n\t} else {\n\t\ttiling_config |= ROW_TILING(tmp);\n\t\ttiling_config |= SAMPLE_SPLIT(tmp);\n\t}\n\ttiling_config |= BANK_SWAPS(1);\n\n\tcc_gc_shader_pipe_config = RREG32(CC_GC_SHADER_PIPE_CONFIG) & 0x00ffff00;\n\ttmp = rdev->config.r600.max_simds -\n\t\tr600_count_pipe_bits((cc_gc_shader_pipe_config >> 16) & R6XX_MAX_SIMDS_MASK);\n\trdev->config.r600.active_simds = tmp;\n\n\tdisabled_rb_mask = (RREG32(CC_RB_BACKEND_DISABLE) >> 16) & R6XX_MAX_BACKENDS_MASK;\n\ttmp = 0;\n\tfor (i = 0; i < rdev->config.r600.max_backends; i++)\n\t\ttmp |= (1 << i);\n\t \n\tif ((disabled_rb_mask & tmp) == tmp) {\n\t\tfor (i = 0; i < rdev->config.r600.max_backends; i++)\n\t\t\tdisabled_rb_mask &= ~(1 << i);\n\t}\n\ttmp = (tiling_config & PIPE_TILING__MASK) >> PIPE_TILING__SHIFT;\n\ttmp = r6xx_remap_render_backend(rdev, tmp, rdev->config.r600.max_backends,\n\t\t\t\t\tR6XX_MAX_BACKENDS, disabled_rb_mask);\n\ttiling_config |= tmp << 16;\n\trdev->config.r600.backend_map = tmp;\n\n\trdev->config.r600.tile_config = tiling_config;\n\tWREG32(GB_TILING_CONFIG, tiling_config);\n\tWREG32(DCP_TILING_CONFIG, tiling_config & 0xffff);\n\tWREG32(HDP_TILING_CONFIG, tiling_config & 0xffff);\n\tWREG32(DMA_TILING_CONFIG, tiling_config & 0xffff);\n\n\ttmp = R6XX_MAX_PIPES - r600_count_pipe_bits((cc_gc_shader_pipe_config & INACTIVE_QD_PIPES_MASK) >> 8);\n\tWREG32(VGT_OUT_DEALLOC_CNTL, (tmp * 4) & DEALLOC_DIST_MASK);\n\tWREG32(VGT_VERTEX_REUSE_BLOCK_CNTL, ((tmp * 4) - 2) & VTX_REUSE_DEPTH_MASK);\n\n\t \n\tWREG32(CP_QUEUE_THRESHOLDS, (ROQ_IB1_START(0x16) | ROQ_IB2_START(0x2b)));\n\tWREG32(CP_MEQ_THRESHOLDS, (MEQ_END(0x40) | ROQ_END(0x40)));\n\n\tWREG32(TA_CNTL_AUX, (DISABLE_CUBE_ANISO | SYNC_GRADIENT |\n\t\t\t     SYNC_WALKER | SYNC_ALIGNER));\n\t \n\tif (rdev->family == CHIP_RV670)\n\t\tWREG32(ARB_GDEC_RD_CNTL, 0x00000021);\n\n\ttmp = RREG32(SX_DEBUG_1);\n\ttmp |= SMX_EVENT_RELEASE;\n\tif ((rdev->family > CHIP_R600))\n\t\ttmp |= ENABLE_NEW_SMX_ADDRESS;\n\tWREG32(SX_DEBUG_1, tmp);\n\n\tif (((rdev->family) == CHIP_R600) ||\n\t    ((rdev->family) == CHIP_RV630) ||\n\t    ((rdev->family) == CHIP_RV610) ||\n\t    ((rdev->family) == CHIP_RV620) ||\n\t    ((rdev->family) == CHIP_RS780) ||\n\t    ((rdev->family) == CHIP_RS880)) {\n\t\tWREG32(DB_DEBUG, PREZ_MUST_WAIT_FOR_POSTZ_DONE);\n\t} else {\n\t\tWREG32(DB_DEBUG, 0);\n\t}\n\tWREG32(DB_WATERMARKS, (DEPTH_FREE(4) | DEPTH_CACHELINE_FREE(16) |\n\t\t\t       DEPTH_FLUSH(16) | DEPTH_PENDING_FREE(4)));\n\n\tWREG32(PA_SC_MULTI_CHIP_CNTL, 0);\n\tWREG32(VGT_NUM_INSTANCES, 0);\n\n\tWREG32(SPI_CONFIG_CNTL, GPR_WRITE_PRIORITY(0));\n\tWREG32(SPI_CONFIG_CNTL_1, VTX_DONE_DELAY(0));\n\n\ttmp = RREG32(SQ_MS_FIFO_SIZES);\n\tif (((rdev->family) == CHIP_RV610) ||\n\t    ((rdev->family) == CHIP_RV620) ||\n\t    ((rdev->family) == CHIP_RS780) ||\n\t    ((rdev->family) == CHIP_RS880)) {\n\t\ttmp = (CACHE_FIFO_SIZE(0xa) |\n\t\t       FETCH_FIFO_HIWATER(0xa) |\n\t\t       DONE_FIFO_HIWATER(0xe0) |\n\t\t       ALU_UPDATE_FIFO_HIWATER(0x8));\n\t} else if (((rdev->family) == CHIP_R600) ||\n\t\t   ((rdev->family) == CHIP_RV630)) {\n\t\ttmp &= ~DONE_FIFO_HIWATER(0xff);\n\t\ttmp |= DONE_FIFO_HIWATER(0x4);\n\t}\n\tWREG32(SQ_MS_FIFO_SIZES, tmp);\n\n\t \n\tsq_config = RREG32(SQ_CONFIG);\n\tsq_config &= ~(PS_PRIO(3) |\n\t\t       VS_PRIO(3) |\n\t\t       GS_PRIO(3) |\n\t\t       ES_PRIO(3));\n\tsq_config |= (DX9_CONSTS |\n\t\t      VC_ENABLE |\n\t\t      PS_PRIO(0) |\n\t\t      VS_PRIO(1) |\n\t\t      GS_PRIO(2) |\n\t\t      ES_PRIO(3));\n\n\tif ((rdev->family) == CHIP_R600) {\n\t\tsq_gpr_resource_mgmt_1 = (NUM_PS_GPRS(124) |\n\t\t\t\t\t  NUM_VS_GPRS(124) |\n\t\t\t\t\t  NUM_CLAUSE_TEMP_GPRS(4));\n\t\tsq_gpr_resource_mgmt_2 = (NUM_GS_GPRS(0) |\n\t\t\t\t\t  NUM_ES_GPRS(0));\n\t\tsq_thread_resource_mgmt = (NUM_PS_THREADS(136) |\n\t\t\t\t\t   NUM_VS_THREADS(48) |\n\t\t\t\t\t   NUM_GS_THREADS(4) |\n\t\t\t\t\t   NUM_ES_THREADS(4));\n\t\tsq_stack_resource_mgmt_1 = (NUM_PS_STACK_ENTRIES(128) |\n\t\t\t\t\t    NUM_VS_STACK_ENTRIES(128));\n\t\tsq_stack_resource_mgmt_2 = (NUM_GS_STACK_ENTRIES(0) |\n\t\t\t\t\t    NUM_ES_STACK_ENTRIES(0));\n\t} else if (((rdev->family) == CHIP_RV610) ||\n\t\t   ((rdev->family) == CHIP_RV620) ||\n\t\t   ((rdev->family) == CHIP_RS780) ||\n\t\t   ((rdev->family) == CHIP_RS880)) {\n\t\t \n\t\tsq_config &= ~VC_ENABLE;\n\n\t\tsq_gpr_resource_mgmt_1 = (NUM_PS_GPRS(44) |\n\t\t\t\t\t  NUM_VS_GPRS(44) |\n\t\t\t\t\t  NUM_CLAUSE_TEMP_GPRS(2));\n\t\tsq_gpr_resource_mgmt_2 = (NUM_GS_GPRS(17) |\n\t\t\t\t\t  NUM_ES_GPRS(17));\n\t\tsq_thread_resource_mgmt = (NUM_PS_THREADS(79) |\n\t\t\t\t\t   NUM_VS_THREADS(78) |\n\t\t\t\t\t   NUM_GS_THREADS(4) |\n\t\t\t\t\t   NUM_ES_THREADS(31));\n\t\tsq_stack_resource_mgmt_1 = (NUM_PS_STACK_ENTRIES(40) |\n\t\t\t\t\t    NUM_VS_STACK_ENTRIES(40));\n\t\tsq_stack_resource_mgmt_2 = (NUM_GS_STACK_ENTRIES(32) |\n\t\t\t\t\t    NUM_ES_STACK_ENTRIES(16));\n\t} else if (((rdev->family) == CHIP_RV630) ||\n\t\t   ((rdev->family) == CHIP_RV635)) {\n\t\tsq_gpr_resource_mgmt_1 = (NUM_PS_GPRS(44) |\n\t\t\t\t\t  NUM_VS_GPRS(44) |\n\t\t\t\t\t  NUM_CLAUSE_TEMP_GPRS(2));\n\t\tsq_gpr_resource_mgmt_2 = (NUM_GS_GPRS(18) |\n\t\t\t\t\t  NUM_ES_GPRS(18));\n\t\tsq_thread_resource_mgmt = (NUM_PS_THREADS(79) |\n\t\t\t\t\t   NUM_VS_THREADS(78) |\n\t\t\t\t\t   NUM_GS_THREADS(4) |\n\t\t\t\t\t   NUM_ES_THREADS(31));\n\t\tsq_stack_resource_mgmt_1 = (NUM_PS_STACK_ENTRIES(40) |\n\t\t\t\t\t    NUM_VS_STACK_ENTRIES(40));\n\t\tsq_stack_resource_mgmt_2 = (NUM_GS_STACK_ENTRIES(32) |\n\t\t\t\t\t    NUM_ES_STACK_ENTRIES(16));\n\t} else if ((rdev->family) == CHIP_RV670) {\n\t\tsq_gpr_resource_mgmt_1 = (NUM_PS_GPRS(44) |\n\t\t\t\t\t  NUM_VS_GPRS(44) |\n\t\t\t\t\t  NUM_CLAUSE_TEMP_GPRS(2));\n\t\tsq_gpr_resource_mgmt_2 = (NUM_GS_GPRS(17) |\n\t\t\t\t\t  NUM_ES_GPRS(17));\n\t\tsq_thread_resource_mgmt = (NUM_PS_THREADS(79) |\n\t\t\t\t\t   NUM_VS_THREADS(78) |\n\t\t\t\t\t   NUM_GS_THREADS(4) |\n\t\t\t\t\t   NUM_ES_THREADS(31));\n\t\tsq_stack_resource_mgmt_1 = (NUM_PS_STACK_ENTRIES(64) |\n\t\t\t\t\t    NUM_VS_STACK_ENTRIES(64));\n\t\tsq_stack_resource_mgmt_2 = (NUM_GS_STACK_ENTRIES(64) |\n\t\t\t\t\t    NUM_ES_STACK_ENTRIES(64));\n\t}\n\n\tWREG32(SQ_CONFIG, sq_config);\n\tWREG32(SQ_GPR_RESOURCE_MGMT_1,  sq_gpr_resource_mgmt_1);\n\tWREG32(SQ_GPR_RESOURCE_MGMT_2,  sq_gpr_resource_mgmt_2);\n\tWREG32(SQ_THREAD_RESOURCE_MGMT, sq_thread_resource_mgmt);\n\tWREG32(SQ_STACK_RESOURCE_MGMT_1, sq_stack_resource_mgmt_1);\n\tWREG32(SQ_STACK_RESOURCE_MGMT_2, sq_stack_resource_mgmt_2);\n\n\tif (((rdev->family) == CHIP_RV610) ||\n\t    ((rdev->family) == CHIP_RV620) ||\n\t    ((rdev->family) == CHIP_RS780) ||\n\t    ((rdev->family) == CHIP_RS880)) {\n\t\tWREG32(VGT_CACHE_INVALIDATION, CACHE_INVALIDATION(TC_ONLY));\n\t} else {\n\t\tWREG32(VGT_CACHE_INVALIDATION, CACHE_INVALIDATION(VC_AND_TC));\n\t}\n\n\t \n\tWREG32(PA_SC_AA_SAMPLE_LOCS_2S, (S0_X(0xc) | S0_Y(0x4) |\n\t\t\t\t\t S1_X(0x4) | S1_Y(0xc)));\n\tWREG32(PA_SC_AA_SAMPLE_LOCS_4S, (S0_X(0xe) | S0_Y(0xe) |\n\t\t\t\t\t S1_X(0x2) | S1_Y(0x2) |\n\t\t\t\t\t S2_X(0xa) | S2_Y(0x6) |\n\t\t\t\t\t S3_X(0x6) | S3_Y(0xa)));\n\tWREG32(PA_SC_AA_SAMPLE_LOCS_8S_WD0, (S0_X(0xe) | S0_Y(0xb) |\n\t\t\t\t\t     S1_X(0x4) | S1_Y(0xc) |\n\t\t\t\t\t     S2_X(0x1) | S2_Y(0x6) |\n\t\t\t\t\t     S3_X(0xa) | S3_Y(0xe)));\n\tWREG32(PA_SC_AA_SAMPLE_LOCS_8S_WD1, (S4_X(0x6) | S4_Y(0x1) |\n\t\t\t\t\t     S5_X(0x0) | S5_Y(0x0) |\n\t\t\t\t\t     S6_X(0xb) | S6_Y(0x4) |\n\t\t\t\t\t     S7_X(0x7) | S7_Y(0x8)));\n\n\tWREG32(VGT_STRMOUT_EN, 0);\n\ttmp = rdev->config.r600.max_pipes * 16;\n\tswitch (rdev->family) {\n\tcase CHIP_RV610:\n\tcase CHIP_RV620:\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\t\ttmp += 32;\n\t\tbreak;\n\tcase CHIP_RV670:\n\t\ttmp += 128;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (tmp > 256) {\n\t\ttmp = 256;\n\t}\n\tWREG32(VGT_ES_PER_GS, 128);\n\tWREG32(VGT_GS_PER_ES, tmp);\n\tWREG32(VGT_GS_PER_VS, 2);\n\tWREG32(VGT_GS_VERTEX_REUSE, 16);\n\n\t \n\tWREG32(PA_SC_LINE_STIPPLE_STATE, 0);\n\tWREG32(VGT_STRMOUT_EN, 0);\n\tWREG32(SX_MISC, 0);\n\tWREG32(PA_SC_MODE_CNTL, 0);\n\tWREG32(PA_SC_AA_CONFIG, 0);\n\tWREG32(PA_SC_LINE_STIPPLE, 0);\n\tWREG32(SPI_INPUT_Z, 0);\n\tWREG32(SPI_PS_IN_CONTROL_0, NUM_INTERP(2));\n\tWREG32(CB_COLOR7_FRAG, 0);\n\n\t \n\tWREG32(CB_COLOR0_BASE, 0);\n\tWREG32(CB_COLOR1_BASE, 0);\n\tWREG32(CB_COLOR2_BASE, 0);\n\tWREG32(CB_COLOR3_BASE, 0);\n\tWREG32(CB_COLOR4_BASE, 0);\n\tWREG32(CB_COLOR5_BASE, 0);\n\tWREG32(CB_COLOR6_BASE, 0);\n\tWREG32(CB_COLOR7_BASE, 0);\n\tWREG32(CB_COLOR7_FRAG, 0);\n\n\tswitch (rdev->family) {\n\tcase CHIP_RV610:\n\tcase CHIP_RV620:\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\t\ttmp = TC_L2_SIZE(8);\n\t\tbreak;\n\tcase CHIP_RV630:\n\tcase CHIP_RV635:\n\t\ttmp = TC_L2_SIZE(4);\n\t\tbreak;\n\tcase CHIP_R600:\n\t\ttmp = TC_L2_SIZE(0) | L2_DISABLE_LATE_HIT;\n\t\tbreak;\n\tdefault:\n\t\ttmp = TC_L2_SIZE(0);\n\t\tbreak;\n\t}\n\tWREG32(TC_CNTL, tmp);\n\n\ttmp = RREG32(HDP_HOST_PATH_CNTL);\n\tWREG32(HDP_HOST_PATH_CNTL, tmp);\n\n\ttmp = RREG32(ARB_POP);\n\ttmp |= ENABLE_TC128;\n\tWREG32(ARB_POP, tmp);\n\n\tWREG32(PA_SC_MULTI_CHIP_CNTL, 0);\n\tWREG32(PA_CL_ENHANCE, (CLIP_VTX_REORDER_ENA |\n\t\t\t       NUM_CLIP_SEQ(3)));\n\tWREG32(PA_SC_ENHANCE, FORCE_EOV_MAX_CLK_CNT(4095));\n\tWREG32(VC_ENHANCE, 0);\n}\n\n\n \nu32 r600_pciep_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tunsigned long flags;\n\tu32 r;\n\n\tspin_lock_irqsave(&rdev->pciep_idx_lock, flags);\n\tWREG32(PCIE_PORT_INDEX, ((reg) & 0xff));\n\t(void)RREG32(PCIE_PORT_INDEX);\n\tr = RREG32(PCIE_PORT_DATA);\n\tspin_unlock_irqrestore(&rdev->pciep_idx_lock, flags);\n\treturn r;\n}\n\nvoid r600_pciep_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->pciep_idx_lock, flags);\n\tWREG32(PCIE_PORT_INDEX, ((reg) & 0xff));\n\t(void)RREG32(PCIE_PORT_INDEX);\n\tWREG32(PCIE_PORT_DATA, (v));\n\t(void)RREG32(PCIE_PORT_DATA);\n\tspin_unlock_irqrestore(&rdev->pciep_idx_lock, flags);\n}\n\n \nvoid r600_cp_stop(struct radeon_device *rdev)\n{\n\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\n\tWREG32(R_0086D8_CP_ME_CNTL, S_0086D8_CP_ME_HALT(1));\n\tWREG32(SCRATCH_UMSK, 0);\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n}\n\nint r600_init_microcode(struct radeon_device *rdev)\n{\n\tconst char *chip_name;\n\tconst char *rlc_chip_name;\n\tconst char *smc_chip_name = \"RV770\";\n\tsize_t pfp_req_size, me_req_size, rlc_req_size, smc_req_size = 0;\n\tchar fw_name[30];\n\tint err;\n\n\tDRM_DEBUG(\"\\n\");\n\n\tswitch (rdev->family) {\n\tcase CHIP_R600:\n\t\tchip_name = \"R600\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RV610:\n\t\tchip_name = \"RV610\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RV630:\n\t\tchip_name = \"RV630\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RV620:\n\t\tchip_name = \"RV620\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RV635:\n\t\tchip_name = \"RV635\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RV670:\n\t\tchip_name = \"RV670\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RS780:\n\tcase CHIP_RS880:\n\t\tchip_name = \"RS780\";\n\t\trlc_chip_name = \"R600\";\n\t\tbreak;\n\tcase CHIP_RV770:\n\t\tchip_name = \"RV770\";\n\t\trlc_chip_name = \"R700\";\n\t\tsmc_chip_name = \"RV770\";\n\t\tsmc_req_size = ALIGN(RV770_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_RV730:\n\t\tchip_name = \"RV730\";\n\t\trlc_chip_name = \"R700\";\n\t\tsmc_chip_name = \"RV730\";\n\t\tsmc_req_size = ALIGN(RV730_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_RV710:\n\t\tchip_name = \"RV710\";\n\t\trlc_chip_name = \"R700\";\n\t\tsmc_chip_name = \"RV710\";\n\t\tsmc_req_size = ALIGN(RV710_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_RV740:\n\t\tchip_name = \"RV730\";\n\t\trlc_chip_name = \"R700\";\n\t\tsmc_chip_name = \"RV740\";\n\t\tsmc_req_size = ALIGN(RV740_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_CEDAR:\n\t\tchip_name = \"CEDAR\";\n\t\trlc_chip_name = \"CEDAR\";\n\t\tsmc_chip_name = \"CEDAR\";\n\t\tsmc_req_size = ALIGN(CEDAR_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_REDWOOD:\n\t\tchip_name = \"REDWOOD\";\n\t\trlc_chip_name = \"REDWOOD\";\n\t\tsmc_chip_name = \"REDWOOD\";\n\t\tsmc_req_size = ALIGN(REDWOOD_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_JUNIPER:\n\t\tchip_name = \"JUNIPER\";\n\t\trlc_chip_name = \"JUNIPER\";\n\t\tsmc_chip_name = \"JUNIPER\";\n\t\tsmc_req_size = ALIGN(JUNIPER_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_CYPRESS:\n\tcase CHIP_HEMLOCK:\n\t\tchip_name = \"CYPRESS\";\n\t\trlc_chip_name = \"CYPRESS\";\n\t\tsmc_chip_name = \"CYPRESS\";\n\t\tsmc_req_size = ALIGN(CYPRESS_SMC_UCODE_SIZE, 4);\n\t\tbreak;\n\tcase CHIP_PALM:\n\t\tchip_name = \"PALM\";\n\t\trlc_chip_name = \"SUMO\";\n\t\tbreak;\n\tcase CHIP_SUMO:\n\t\tchip_name = \"SUMO\";\n\t\trlc_chip_name = \"SUMO\";\n\t\tbreak;\n\tcase CHIP_SUMO2:\n\t\tchip_name = \"SUMO2\";\n\t\trlc_chip_name = \"SUMO\";\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\n\tif (rdev->family >= CHIP_CEDAR) {\n\t\tpfp_req_size = EVERGREEN_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = EVERGREEN_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = EVERGREEN_RLC_UCODE_SIZE * 4;\n\t} else if (rdev->family >= CHIP_RV770) {\n\t\tpfp_req_size = R700_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = R700_PM4_UCODE_SIZE * 4;\n\t\trlc_req_size = R700_RLC_UCODE_SIZE * 4;\n\t} else {\n\t\tpfp_req_size = R600_PFP_UCODE_SIZE * 4;\n\t\tme_req_size = R600_PM4_UCODE_SIZE * 12;\n\t\trlc_req_size = R600_RLC_UCODE_SIZE * 4;\n\t}\n\n\tDRM_INFO(\"Loading %s Microcode\\n\", chip_name);\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_pfp.bin\", chip_name);\n\terr = request_firmware(&rdev->pfp_fw, fw_name, rdev->dev);\n\tif (err)\n\t\tgoto out;\n\tif (rdev->pfp_fw->size != pfp_req_size) {\n\t\tpr_err(\"r600_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->pfp_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_me.bin\", chip_name);\n\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\tif (err)\n\t\tgoto out;\n\tif (rdev->me_fw->size != me_req_size) {\n\t\tpr_err(\"r600_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->me_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_rlc.bin\", rlc_chip_name);\n\terr = request_firmware(&rdev->rlc_fw, fw_name, rdev->dev);\n\tif (err)\n\t\tgoto out;\n\tif (rdev->rlc_fw->size != rlc_req_size) {\n\t\tpr_err(\"r600_rlc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->rlc_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_HEMLOCK)) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"radeon/%s_smc.bin\", smc_chip_name);\n\t\terr = request_firmware(&rdev->smc_fw, fw_name, rdev->dev);\n\t\tif (err) {\n\t\t\tpr_err(\"smc: error loading firmware \\\"%s\\\"\\n\", fw_name);\n\t\t\trelease_firmware(rdev->smc_fw);\n\t\t\trdev->smc_fw = NULL;\n\t\t\terr = 0;\n\t\t} else if (rdev->smc_fw->size != smc_req_size) {\n\t\t\tpr_err(\"smc: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       rdev->smc_fw->size, fw_name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\nout:\n\tif (err) {\n\t\tif (err != -EINVAL)\n\t\t\tpr_err(\"r600_cp: Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name);\n\t\trelease_firmware(rdev->pfp_fw);\n\t\trdev->pfp_fw = NULL;\n\t\trelease_firmware(rdev->me_fw);\n\t\trdev->me_fw = NULL;\n\t\trelease_firmware(rdev->rlc_fw);\n\t\trdev->rlc_fw = NULL;\n\t\trelease_firmware(rdev->smc_fw);\n\t\trdev->smc_fw = NULL;\n\t}\n\treturn err;\n}\n\nu32 r600_gfx_get_rptr(struct radeon_device *rdev,\n\t\t      struct radeon_ring *ring)\n{\n\tu32 rptr;\n\n\tif (rdev->wb.enabled)\n\t\trptr = rdev->wb.wb[ring->rptr_offs/4];\n\telse\n\t\trptr = RREG32(R600_CP_RB_RPTR);\n\n\treturn rptr;\n}\n\nu32 r600_gfx_get_wptr(struct radeon_device *rdev,\n\t\t      struct radeon_ring *ring)\n{\n\treturn RREG32(R600_CP_RB_WPTR);\n}\n\nvoid r600_gfx_set_wptr(struct radeon_device *rdev,\n\t\t       struct radeon_ring *ring)\n{\n\tWREG32(R600_CP_RB_WPTR, ring->wptr);\n\t(void)RREG32(R600_CP_RB_WPTR);\n}\n\nstatic int r600_cp_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data;\n\tint i;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw)\n\t\treturn -EINVAL;\n\n\tr600_cp_stop(rdev);\n\n\tWREG32(CP_RB_CNTL,\n#ifdef __BIG_ENDIAN\n\t       BUF_SWAP_32BIT |\n#endif\n\t       RB_NO_UPDATE | RB_BLKSZ(15) | RB_BUFSZ(3));\n\n\t \n\tWREG32(GRBM_SOFT_RESET, SOFT_RESET_CP);\n\tRREG32(GRBM_SOFT_RESET);\n\tmdelay(15);\n\tWREG32(GRBM_SOFT_RESET, 0);\n\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\n\tfw_data = (const __be32 *)rdev->me_fw->data;\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tfor (i = 0; i < R600_PM4_UCODE_SIZE * 3; i++)\n\t\tWREG32(CP_ME_RAM_DATA,\n\t\t       be32_to_cpup(fw_data++));\n\n\tfw_data = (const __be32 *)rdev->pfp_fw->data;\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tfor (i = 0; i < R600_PFP_UCODE_SIZE; i++)\n\t\tWREG32(CP_PFP_UCODE_DATA,\n\t\t       be32_to_cpup(fw_data++));\n\n\tWREG32(CP_PFP_UCODE_ADDR, 0);\n\tWREG32(CP_ME_RAM_WADDR, 0);\n\tWREG32(CP_ME_RAM_RADDR, 0);\n\treturn 0;\n}\n\nint r600_cp_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tint r;\n\tuint32_t cp_me;\n\n\tr = radeon_ring_lock(rdev, ring, 7);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET3(PACKET3_ME_INITIALIZE, 5));\n\tradeon_ring_write(ring, 0x1);\n\tif (rdev->family >= CHIP_RV770) {\n\t\tradeon_ring_write(ring, 0x0);\n\t\tradeon_ring_write(ring, rdev->config.rv770.max_hw_contexts - 1);\n\t} else {\n\t\tradeon_ring_write(ring, 0x3);\n\t\tradeon_ring_write(ring, rdev->config.r600.max_hw_contexts - 1);\n\t}\n\tradeon_ring_write(ring, PACKET3_ME_INITIALIZE_DEVICE_ID(1));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tcp_me = 0xff;\n\tWREG32(R_0086D8_CP_ME_CNTL, cp_me);\n\treturn 0;\n}\n\nint r600_cp_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tu32 tmp;\n\tu32 rb_bufsz;\n\tint r;\n\n\t \n\tWREG32(GRBM_SOFT_RESET, SOFT_RESET_CP);\n\tRREG32(GRBM_SOFT_RESET);\n\tmdelay(15);\n\tWREG32(GRBM_SOFT_RESET, 0);\n\n\t \n\trb_bufsz = order_base_2(ring->ring_size / 8);\n\ttmp = (order_base_2(RADEON_GPU_PAGE_SIZE/8) << 8) | rb_bufsz;\n#ifdef __BIG_ENDIAN\n\ttmp |= BUF_SWAP_32BIT;\n#endif\n\tWREG32(CP_RB_CNTL, tmp);\n\tWREG32(CP_SEM_WAIT_TIMER, 0x0);\n\n\t \n\tWREG32(CP_RB_WPTR_DELAY, 0);\n\n\t \n\tWREG32(CP_RB_CNTL, tmp | RB_RPTR_WR_ENA);\n\tWREG32(CP_RB_RPTR_WR, 0);\n\tring->wptr = 0;\n\tWREG32(CP_RB_WPTR, ring->wptr);\n\n\t \n\tWREG32(CP_RB_RPTR_ADDR,\n\t       ((rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFFFFFFFC));\n\tWREG32(CP_RB_RPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) & 0xFF);\n\tWREG32(SCRATCH_ADDR, ((rdev->wb.gpu_addr + RADEON_WB_SCRATCH_OFFSET) >> 8) & 0xFFFFFFFF);\n\n\tif (rdev->wb.enabled)\n\t\tWREG32(SCRATCH_UMSK, 0xff);\n\telse {\n\t\ttmp |= RB_NO_UPDATE;\n\t\tWREG32(SCRATCH_UMSK, 0);\n\t}\n\n\tmdelay(1);\n\tWREG32(CP_RB_CNTL, tmp);\n\n\tWREG32(CP_RB_BASE, ring->gpu_addr >> 8);\n\tWREG32(CP_DEBUG, (1 << 27) | (1 << 28));\n\n\tr600_cp_start(rdev);\n\tring->ready = true;\n\tr = radeon_ring_test(rdev, RADEON_RING_TYPE_GFX_INDEX, ring);\n\tif (r) {\n\t\tring->ready = false;\n\t\treturn r;\n\t}\n\n\tif (rdev->asic->copy.copy_ring_index == RADEON_RING_TYPE_GFX_INDEX)\n\t\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\n\n\treturn 0;\n}\n\nvoid r600_ring_init(struct radeon_device *rdev, struct radeon_ring *ring, unsigned ring_size)\n{\n\tu32 rb_bufsz;\n\tint r;\n\n\t \n\trb_bufsz = order_base_2(ring_size / 8);\n\tring_size = (1 << (rb_bufsz + 1)) * 4;\n\tring->ring_size = ring_size;\n\tring->align_mask = 16 - 1;\n\n\tif (radeon_ring_supports_scratch_reg(rdev, ring)) {\n\t\tr = radeon_scratch_get(rdev, &ring->rptr_save_reg);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"failed to get scratch reg for rptr save (%d).\\n\", r);\n\t\t\tring->rptr_save_reg = 0;\n\t\t}\n\t}\n}\n\nvoid r600_cp_fini(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tr600_cp_stop(rdev);\n\tradeon_ring_fini(rdev, ring);\n\tradeon_scratch_free(rdev, ring->rptr_save_reg);\n}\n\n \nvoid r600_scratch_init(struct radeon_device *rdev)\n{\n\tint i;\n\n\trdev->scratch.num_reg = 7;\n\trdev->scratch.reg_base = SCRATCH_REG0;\n\tfor (i = 0; i < rdev->scratch.num_reg; i++) {\n\t\trdev->scratch.free[i] = true;\n\t\trdev->scratch.reg[i] = rdev->scratch.reg_base + (i * 4);\n\t}\n}\n\nint r600_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to get scratch reg (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ring_lock(rdev, ring, 3);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring %d (%d).\\n\", ring->idx, r);\n\t\tradeon_scratch_free(rdev, scratch);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\tradeon_ring_write(ring, ((scratch - PACKET3_SET_CONFIG_REG_OFFSET) >> 2));\n\tradeon_ring_write(ring, 0xDEADBEEF);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ring test on %d succeeded in %d usecs\\n\", ring->idx, i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ring %d test failed (scratch(0x%04X)=0x%08X)\\n\",\n\t\t\t  ring->idx, scratch, tmp);\n\t\tr = -EINVAL;\n\t}\n\tradeon_scratch_free(rdev, scratch);\n\treturn r;\n}\n\n \n\nvoid r600_fence_ring_emit(struct radeon_device *rdev,\n\t\t\t  struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tu32 cp_coher_cntl = PACKET3_TC_ACTION_ENA | PACKET3_VC_ACTION_ENA |\n\t\tPACKET3_SH_ACTION_ENA;\n\n\tif (rdev->family >= CHIP_RV770)\n\t\tcp_coher_cntl |= PACKET3_FULL_CACHE_ENA;\n\n\tif (rdev->wb.use_event) {\n\t\tu64 addr = rdev->fence_drv[fence->ring].gpu_addr;\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\t\tradeon_ring_write(ring, cp_coher_cntl);\n\t\tradeon_ring_write(ring, 0xFFFFFFFF);\n\t\tradeon_ring_write(ring, 0);\n\t\tradeon_ring_write(ring, 10);  \n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE_EOP, 4));\n\t\tradeon_ring_write(ring, EVENT_TYPE(CACHE_FLUSH_AND_INV_EVENT_TS) | EVENT_INDEX(5));\n\t\tradeon_ring_write(ring, lower_32_bits(addr));\n\t\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xff) | DATA_SEL(1) | INT_SEL(2));\n\t\tradeon_ring_write(ring, fence->seq);\n\t\tradeon_ring_write(ring, 0);\n\t} else {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SURFACE_SYNC, 3));\n\t\tradeon_ring_write(ring, cp_coher_cntl);\n\t\tradeon_ring_write(ring, 0xFFFFFFFF);\n\t\tradeon_ring_write(ring, 0);\n\t\tradeon_ring_write(ring, 10);  \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_EVENT_WRITE, 0));\n\t\tradeon_ring_write(ring, EVENT_TYPE(CACHE_FLUSH_AND_INV_EVENT) | EVENT_INDEX(0));\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tradeon_ring_write(ring, (WAIT_UNTIL - PACKET3_SET_CONFIG_REG_OFFSET) >> 2);\n\t\tradeon_ring_write(ring, WAIT_3D_IDLE_bit | WAIT_3D_IDLECLEAN_bit);\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tradeon_ring_write(ring, ((rdev->fence_drv[fence->ring].scratch_reg - PACKET3_SET_CONFIG_REG_OFFSET) >> 2));\n\t\tradeon_ring_write(ring, fence->seq);\n\t\t \n\t\tradeon_ring_write(ring, PACKET0(CP_INT_STATUS, 0));\n\t\tradeon_ring_write(ring, RB_INT_STAT);\n\t}\n}\n\n \nbool r600_semaphore_ring_emit(struct radeon_device *rdev,\n\t\t\t      struct radeon_ring *ring,\n\t\t\t      struct radeon_semaphore *semaphore,\n\t\t\t      bool emit_wait)\n{\n\tuint64_t addr = semaphore->gpu_addr;\n\tunsigned sel = emit_wait ? PACKET3_SEM_SEL_WAIT : PACKET3_SEM_SEL_SIGNAL;\n\n\tif (rdev->family < CHIP_CAYMAN)\n\t\tsel |= PACKET3_SEM_WAIT_ON_SIGNAL;\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_MEM_SEMAPHORE, 1));\n\tradeon_ring_write(ring, lower_32_bits(addr));\n\tradeon_ring_write(ring, (upper_32_bits(addr) & 0xff) | sel);\n\n\t \n\tif (emit_wait && (rdev->family >= CHIP_CEDAR)) {\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_PFP_SYNC_ME, 0));\n\t\tradeon_ring_write(ring, 0x0);\n\t}\n\n\treturn true;\n}\n\n \nstruct radeon_fence *r600_copy_cpdma(struct radeon_device *rdev,\n\t\t\t\t     uint64_t src_offset, uint64_t dst_offset,\n\t\t\t\t     unsigned num_gpu_pages,\n\t\t\t\t     struct dma_resv *resv)\n{\n\tstruct radeon_fence *fence;\n\tstruct radeon_sync sync;\n\tint ring_index = rdev->asic->copy.blit_ring_index;\n\tstruct radeon_ring *ring = &rdev->ring[ring_index];\n\tu32 size_in_bytes, cur_size_in_bytes, tmp;\n\tint i, num_loops;\n\tint r = 0;\n\n\tradeon_sync_create(&sync);\n\n\tsize_in_bytes = (num_gpu_pages << RADEON_GPU_PAGE_SHIFT);\n\tnum_loops = DIV_ROUND_UP(size_in_bytes, 0x1fffff);\n\tr = radeon_ring_lock(rdev, ring, num_loops * 6 + 24);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: moving bo (%d).\\n\", r);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_sync_resv(rdev, &sync, resv, false);\n\tradeon_sync_rings(rdev, &sync, ring->idx);\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\tradeon_ring_write(ring, (WAIT_UNTIL - PACKET3_SET_CONFIG_REG_OFFSET) >> 2);\n\tradeon_ring_write(ring, WAIT_3D_IDLE_bit);\n\tfor (i = 0; i < num_loops; i++) {\n\t\tcur_size_in_bytes = size_in_bytes;\n\t\tif (cur_size_in_bytes > 0x1fffff)\n\t\t\tcur_size_in_bytes = 0x1fffff;\n\t\tsize_in_bytes -= cur_size_in_bytes;\n\t\ttmp = upper_32_bits(src_offset) & 0xff;\n\t\tif (size_in_bytes == 0)\n\t\t\ttmp |= PACKET3_CP_DMA_CP_SYNC;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_CP_DMA, 4));\n\t\tradeon_ring_write(ring, lower_32_bits(src_offset));\n\t\tradeon_ring_write(ring, tmp);\n\t\tradeon_ring_write(ring, lower_32_bits(dst_offset));\n\t\tradeon_ring_write(ring, upper_32_bits(dst_offset) & 0xff);\n\t\tradeon_ring_write(ring, cur_size_in_bytes);\n\t\tsrc_offset += cur_size_in_bytes;\n\t\tdst_offset += cur_size_in_bytes;\n\t}\n\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\tradeon_ring_write(ring, (WAIT_UNTIL - PACKET3_SET_CONFIG_REG_OFFSET) >> 2);\n\tradeon_ring_write(ring, WAIT_CP_DMA_IDLE_bit);\n\n\tr = radeon_fence_emit(rdev, &fence, ring->idx);\n\tif (r) {\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tradeon_sync_free(rdev, &sync, fence);\n\n\treturn fence;\n}\n\nint r600_set_surface_reg(struct radeon_device *rdev, int reg,\n\t\t\t uint32_t tiling_flags, uint32_t pitch,\n\t\t\t uint32_t offset, uint32_t obj_size)\n{\n\t \n\treturn 0;\n}\n\nvoid r600_clear_surface_reg(struct radeon_device *rdev, int reg)\n{\n\t \n}\n\nstatic void r600_uvd_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = radeon_uvd_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD (%d) init.\\n\", r);\n\t\t \n\t\trdev->has_uvd = false;\n\t\treturn;\n\t}\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[R600_RING_TYPE_UVD_INDEX], 4096);\n}\n\nstatic void r600_uvd_start(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (!rdev->has_uvd)\n\t\treturn;\n\n\tr = uvd_v1_0_resume(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed UVD resume (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\tr = radeon_fence_driver_start_ring(rdev, R600_RING_TYPE_UVD_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD fences (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\treturn;\n\nerror:\n\trdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size = 0;\n}\n\nstatic void r600_uvd_resume(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tif (!rdev->has_uvd || !rdev->ring[R600_RING_TYPE_UVD_INDEX].ring_size)\n\t\treturn;\n\n\tring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, 0, PACKET0(UVD_NO_OP, 0));\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD ring (%d).\\n\", r);\n\t\treturn;\n\t}\n\tr = uvd_v1_0_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing UVD (%d).\\n\", r);\n\t\treturn;\n\t}\n}\n\nstatic int r600_startup(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\t \n\tr600_pcie_gen2_enable(rdev);\n\n\t \n\tr = r600_vram_scratch_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr600_mc_program(rdev);\n\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr600_agp_enable(rdev);\n\t} else {\n\t\tr = r600_pcie_gart_enable(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tr600_gpu_init(rdev);\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr600_uvd_start(rdev);\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = r600_irq_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: IH init failed (%d).\\n\", r);\n\t\tradeon_irq_kms_fini(rdev);\n\t\treturn r;\n\t}\n\tr600_irq_set(rdev);\n\n\tring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tr = radeon_ring_init(rdev, ring, ring->ring_size, RADEON_WB_CP_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r)\n\t\treturn r;\n\n\tr = r600_cp_load_microcode(rdev);\n\tif (r)\n\t\treturn r;\n\tr = r600_cp_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr600_uvd_resume(rdev);\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: audio init failed\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nvoid r600_vga_set_state(struct radeon_device *rdev, bool state)\n{\n\tuint32_t temp;\n\n\ttemp = RREG32(CONFIG_CNTL);\n\tif (!state) {\n\t\ttemp &= ~(1<<0);\n\t\ttemp |= (1<<1);\n\t} else {\n\t\ttemp &= ~(1<<1);\n\t}\n\tWREG32(CONFIG_CNTL, temp);\n}\n\nint r600_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\n\tif (rdev->pm.pm_method == PM_METHOD_DPM)\n\t\tradeon_pm_resume(rdev);\n\n\trdev->accel_working = true;\n\tr = r600_startup(rdev);\n\tif (r) {\n\t\tDRM_ERROR(\"r600 startup failed on resume\\n\");\n\t\trdev->accel_working = false;\n\t\treturn r;\n\t}\n\n\treturn r;\n}\n\nint r600_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tr600_cp_stop(rdev);\n\tif (rdev->has_uvd) {\n\t\tradeon_uvd_suspend(rdev);\n\t\tuvd_v1_0_fini(rdev);\n\t}\n\tr600_irq_suspend(rdev);\n\tradeon_wb_disable(rdev);\n\tr600_pcie_gart_disable(rdev);\n\n\treturn 0;\n}\n\n \nint r600_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tr600_debugfs_mc_info_init(rdev);\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting atombios for R600 GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\tr = radeon_atombios_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tif (!radeon_card_posted(rdev)) {\n\t\tif (!rdev->bios) {\n\t\t\tdev_err(rdev->dev, \"Card not posted and no BIOS - ignoring\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDRM_INFO(\"GPU not posted. posting now...\\n\");\n\t\tatom_asic_init(rdev->mode_info.atom_context);\n\t}\n\t \n\tr600_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\tradeon_fence_driver_init(rdev);\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr = radeon_agp_init(rdev);\n\t\tif (r)\n\t\t\tradeon_agp_disable(rdev);\n\t}\n\tr = r600_mc_init(rdev);\n\tif (r)\n\t\treturn r;\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tif (!rdev->me_fw || !rdev->pfp_fw || !rdev->rlc_fw) {\n\t\tr = r600_init_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ring_obj = NULL;\n\tr600_ring_init(rdev, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX], 1024 * 1024);\n\n\tr600_uvd_init(rdev);\n\n\trdev->ih.ring_obj = NULL;\n\tr600_ih_ring_init(rdev, 64 * 1024);\n\n\tr = r600_pcie_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\trdev->accel_working = true;\n\tr = r600_startup(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"disabling GPU acceleration\\n\");\n\t\tr600_cp_fini(rdev);\n\t\tr600_irq_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tr600_pcie_gart_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\n\treturn 0;\n}\n\nvoid r600_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tradeon_audio_fini(rdev);\n\tr600_cp_fini(rdev);\n\tr600_irq_fini(rdev);\n\tif (rdev->has_uvd) {\n\t\tuvd_v1_0_fini(rdev);\n\t\tradeon_uvd_fini(rdev);\n\t}\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tr600_pcie_gart_fini(rdev);\n\tr600_vram_scratch_fini(rdev);\n\tradeon_agp_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\n\n \nvoid r600_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tu32 next_rptr;\n\n\tif (ring->rptr_save_reg) {\n\t\tnext_rptr = ring->wptr + 3 + 4;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_SET_CONFIG_REG, 1));\n\t\tradeon_ring_write(ring, ((ring->rptr_save_reg -\n\t\t\t\t\t PACKET3_SET_CONFIG_REG_OFFSET) >> 2));\n\t\tradeon_ring_write(ring, next_rptr);\n\t} else if (rdev->wb.enabled) {\n\t\tnext_rptr = ring->wptr + 5 + 4;\n\t\tradeon_ring_write(ring, PACKET3(PACKET3_MEM_WRITE, 3));\n\t\tradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\n\t\tradeon_ring_write(ring, (upper_32_bits(ring->next_rptr_gpu_addr) & 0xff) | (1 << 18));\n\t\tradeon_ring_write(ring, next_rptr);\n\t\tradeon_ring_write(ring, 0);\n\t}\n\n\tradeon_ring_write(ring, PACKET3(PACKET3_INDIRECT_BUFFER, 2));\n\tradeon_ring_write(ring,\n#ifdef __BIG_ENDIAN\n\t\t\t  (2 << 0) |\n#endif\n\t\t\t  (ib->gpu_addr & 0xFFFFFFFC));\n\tradeon_ring_write(ring, upper_32_bits(ib->gpu_addr) & 0xFF);\n\tradeon_ring_write(ring, ib->length_dw);\n}\n\nint r600_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tstruct radeon_ib ib;\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get scratch reg (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ib_get(rdev, ring->idx, &ib, NULL, 256);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get ib (%d).\\n\", r);\n\t\tgoto free_scratch;\n\t}\n\tib.ptr[0] = PACKET3(PACKET3_SET_CONFIG_REG, 1);\n\tib.ptr[1] = ((scratch - PACKET3_SET_CONFIG_REG_OFFSET) >> 2);\n\tib.ptr[2] = 0xDEADBEEF;\n\tib.length_dw = 3;\n\tr = radeon_ib_schedule(rdev, &ib, NULL, false);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to schedule ib (%d).\\n\", r);\n\t\tgoto free_ib;\n\t}\n\tr = radeon_fence_wait_timeout(ib.fence, false, usecs_to_jiffies(\n\t\tRADEON_USEC_IB_TEST_TIMEOUT));\n\tif (r < 0) {\n\t\tDRM_ERROR(\"radeon: fence wait failed (%d).\\n\", r);\n\t\tgoto free_ib;\n\t} else if (r == 0) {\n\t\tDRM_ERROR(\"radeon: fence wait timed out.\\n\");\n\t\tr = -ETIMEDOUT;\n\t\tgoto free_ib;\n\t}\n\tr = 0;\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ib test on ring %d succeeded in %u usecs\\n\", ib.fence->ring, i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ib test failed (scratch(0x%04X)=0x%08X)\\n\",\n\t\t\t  scratch, tmp);\n\t\tr = -EINVAL;\n\t}\nfree_ib:\n\tradeon_ib_free(rdev, &ib);\nfree_scratch:\n\tradeon_scratch_free(rdev, scratch);\n\treturn r;\n}\n\n \n\nvoid r600_ih_ring_init(struct radeon_device *rdev, unsigned ring_size)\n{\n\tu32 rb_bufsz;\n\n\t \n\trb_bufsz = order_base_2(ring_size / 4);\n\tring_size = (1 << rb_bufsz) * 4;\n\trdev->ih.ring_size = ring_size;\n\trdev->ih.ptr_mask = rdev->ih.ring_size - 1;\n\trdev->ih.rptr = 0;\n}\n\nint r600_ih_ring_alloc(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (rdev->ih.ring_obj == NULL) {\n\t\tr = radeon_bo_create(rdev, rdev->ih.ring_size,\n\t\t\t\t     PAGE_SIZE, true,\n\t\t\t\t     RADEON_GEM_DOMAIN_GTT, 0,\n\t\t\t\t     NULL, NULL, &rdev->ih.ring_obj);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"radeon: failed to create ih ring buffer (%d).\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_reserve(rdev->ih.ring_obj, false);\n\t\tif (unlikely(r != 0))\n\t\t\treturn r;\n\t\tr = radeon_bo_pin(rdev->ih.ring_obj,\n\t\t\t\t  RADEON_GEM_DOMAIN_GTT,\n\t\t\t\t  &rdev->ih.gpu_addr);\n\t\tif (r) {\n\t\t\tradeon_bo_unreserve(rdev->ih.ring_obj);\n\t\t\tDRM_ERROR(\"radeon: failed to pin ih ring buffer (%d).\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_bo_kmap(rdev->ih.ring_obj,\n\t\t\t\t   (void **)&rdev->ih.ring);\n\t\tradeon_bo_unreserve(rdev->ih.ring_obj);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"radeon: failed to map ih ring buffer (%d).\\n\", r);\n\t\t\treturn r;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid r600_ih_ring_fini(struct radeon_device *rdev)\n{\n\tint r;\n\tif (rdev->ih.ring_obj) {\n\t\tr = radeon_bo_reserve(rdev->ih.ring_obj, false);\n\t\tif (likely(r == 0)) {\n\t\t\tradeon_bo_kunmap(rdev->ih.ring_obj);\n\t\t\tradeon_bo_unpin(rdev->ih.ring_obj);\n\t\t\tradeon_bo_unreserve(rdev->ih.ring_obj);\n\t\t}\n\t\tradeon_bo_unref(&rdev->ih.ring_obj);\n\t\trdev->ih.ring = NULL;\n\t\trdev->ih.ring_obj = NULL;\n\t}\n}\n\nvoid r600_rlc_stop(struct radeon_device *rdev)\n{\n\n\tif ((rdev->family >= CHIP_RV770) &&\n\t    (rdev->family <= CHIP_RV740)) {\n\t\t \n\t\tWREG32(SRBM_SOFT_RESET, SOFT_RESET_RLC);\n\t\tRREG32(SRBM_SOFT_RESET);\n\t\tmdelay(15);\n\t\tWREG32(SRBM_SOFT_RESET, 0);\n\t\tRREG32(SRBM_SOFT_RESET);\n\t}\n\n\tWREG32(RLC_CNTL, 0);\n}\n\nstatic void r600_rlc_start(struct radeon_device *rdev)\n{\n\tWREG32(RLC_CNTL, RLC_ENABLE);\n}\n\nstatic int r600_rlc_resume(struct radeon_device *rdev)\n{\n\tu32 i;\n\tconst __be32 *fw_data;\n\n\tif (!rdev->rlc_fw)\n\t\treturn -EINVAL;\n\n\tr600_rlc_stop(rdev);\n\n\tWREG32(RLC_HB_CNTL, 0);\n\n\tWREG32(RLC_HB_BASE, 0);\n\tWREG32(RLC_HB_RPTR, 0);\n\tWREG32(RLC_HB_WPTR, 0);\n\tWREG32(RLC_HB_WPTR_LSB_ADDR, 0);\n\tWREG32(RLC_HB_WPTR_MSB_ADDR, 0);\n\tWREG32(RLC_MC_CNTL, 0);\n\tWREG32(RLC_UCODE_CNTL, 0);\n\n\tfw_data = (const __be32 *)rdev->rlc_fw->data;\n\tif (rdev->family >= CHIP_RV770) {\n\t\tfor (i = 0; i < R700_RLC_UCODE_SIZE; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < R600_RLC_UCODE_SIZE; i++) {\n\t\t\tWREG32(RLC_UCODE_ADDR, i);\n\t\t\tWREG32(RLC_UCODE_DATA, be32_to_cpup(fw_data++));\n\t\t}\n\t}\n\tWREG32(RLC_UCODE_ADDR, 0);\n\n\tr600_rlc_start(rdev);\n\n\treturn 0;\n}\n\nstatic void r600_enable_interrupts(struct radeon_device *rdev)\n{\n\tu32 ih_cntl = RREG32(IH_CNTL);\n\tu32 ih_rb_cntl = RREG32(IH_RB_CNTL);\n\n\tih_cntl |= ENABLE_INTR;\n\tih_rb_cntl |= IH_RB_ENABLE;\n\tWREG32(IH_CNTL, ih_cntl);\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\trdev->ih.enabled = true;\n}\n\nvoid r600_disable_interrupts(struct radeon_device *rdev)\n{\n\tu32 ih_rb_cntl = RREG32(IH_RB_CNTL);\n\tu32 ih_cntl = RREG32(IH_CNTL);\n\n\tih_rb_cntl &= ~IH_RB_ENABLE;\n\tih_cntl &= ~ENABLE_INTR;\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\tWREG32(IH_CNTL, ih_cntl);\n\t \n\tWREG32(IH_RB_RPTR, 0);\n\tWREG32(IH_RB_WPTR, 0);\n\trdev->ih.enabled = false;\n\trdev->ih.rptr = 0;\n}\n\nstatic void r600_disable_interrupt_state(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tWREG32(CP_INT_CNTL, CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE);\n\ttmp = RREG32(DMA_CNTL) & ~TRAP_ENABLE;\n\tWREG32(DMA_CNTL, tmp);\n\tWREG32(GRBM_INT_CNTL, 0);\n\tWREG32(DxMODE_INT_MASK, 0);\n\tWREG32(D1GRPH_INTERRUPT_CONTROL, 0);\n\tWREG32(D2GRPH_INTERRUPT_CONTROL, 0);\n\tif (ASIC_IS_DCE3(rdev)) {\n\t\tWREG32(DCE3_DACA_AUTODETECT_INT_CONTROL, 0);\n\t\tWREG32(DCE3_DACB_AUTODETECT_INT_CONTROL, 0);\n\t\ttmp = RREG32(DC_HPD1_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\t\tWREG32(DC_HPD1_INT_CONTROL, tmp);\n\t\ttmp = RREG32(DC_HPD2_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\t\tWREG32(DC_HPD2_INT_CONTROL, tmp);\n\t\ttmp = RREG32(DC_HPD3_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\t\tWREG32(DC_HPD3_INT_CONTROL, tmp);\n\t\ttmp = RREG32(DC_HPD4_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\t\tWREG32(DC_HPD4_INT_CONTROL, tmp);\n\t\tif (ASIC_IS_DCE32(rdev)) {\n\t\t\ttmp = RREG32(DC_HPD5_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD5_INT_CONTROL, tmp);\n\t\t\ttmp = RREG32(DC_HPD6_INT_CONTROL) & DC_HPDx_INT_POLARITY;\n\t\t\tWREG32(DC_HPD6_INT_CONTROL, tmp);\n\t\t\ttmp = RREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET0) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\t\tWREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET0, tmp);\n\t\t\ttmp = RREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET1) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\t\tWREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET1, tmp);\n\t\t} else {\n\t\t\ttmp = RREG32(HDMI0_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\t\tWREG32(HDMI0_AUDIO_PACKET_CONTROL, tmp);\n\t\t\ttmp = RREG32(DCE3_HDMI1_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\t\tWREG32(DCE3_HDMI1_AUDIO_PACKET_CONTROL, tmp);\n\t\t}\n\t} else {\n\t\tWREG32(DACA_AUTODETECT_INT_CONTROL, 0);\n\t\tWREG32(DACB_AUTODETECT_INT_CONTROL, 0);\n\t\ttmp = RREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL) & DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\tWREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\n\t\ttmp = RREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL) & DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\tWREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\n\t\ttmp = RREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL) & DC_HOT_PLUG_DETECTx_INT_POLARITY;\n\t\tWREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL, tmp);\n\t\ttmp = RREG32(HDMI0_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\tWREG32(HDMI0_AUDIO_PACKET_CONTROL, tmp);\n\t\ttmp = RREG32(HDMI1_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\tWREG32(HDMI1_AUDIO_PACKET_CONTROL, tmp);\n\t}\n}\n\nint r600_irq_init(struct radeon_device *rdev)\n{\n\tint ret = 0;\n\tint rb_bufsz;\n\tu32 interrupt_cntl, ih_cntl, ih_rb_cntl;\n\n\t \n\tret = r600_ih_ring_alloc(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tr600_disable_interrupts(rdev);\n\n\t \n\tif (rdev->family >= CHIP_CEDAR)\n\t\tret = evergreen_rlc_resume(rdev);\n\telse\n\t\tret = r600_rlc_resume(rdev);\n\tif (ret) {\n\t\tr600_ih_ring_fini(rdev);\n\t\treturn ret;\n\t}\n\n\t \n\t \n\tWREG32(INTERRUPT_CNTL2, rdev->dummy_page.addr >> 8);\n\tinterrupt_cntl = RREG32(INTERRUPT_CNTL);\n\t \n\tinterrupt_cntl &= ~IH_DUMMY_RD_OVERRIDE;\n\t \n\tinterrupt_cntl &= ~IH_REQ_NONSNOOP_EN;\n\tWREG32(INTERRUPT_CNTL, interrupt_cntl);\n\n\tWREG32(IH_RB_BASE, rdev->ih.gpu_addr >> 8);\n\trb_bufsz = order_base_2(rdev->ih.ring_size / 4);\n\n\tih_rb_cntl = (IH_WPTR_OVERFLOW_ENABLE |\n\t\t      IH_WPTR_OVERFLOW_CLEAR |\n\t\t      (rb_bufsz << 1));\n\n\tif (rdev->wb.enabled)\n\t\tih_rb_cntl |= IH_WPTR_WRITEBACK_ENABLE;\n\n\t \n\tWREG32(IH_RB_WPTR_ADDR_LO, (rdev->wb.gpu_addr + R600_WB_IH_WPTR_OFFSET) & 0xFFFFFFFC);\n\tWREG32(IH_RB_WPTR_ADDR_HI, upper_32_bits(rdev->wb.gpu_addr + R600_WB_IH_WPTR_OFFSET) & 0xFF);\n\n\tWREG32(IH_RB_CNTL, ih_rb_cntl);\n\n\t \n\tWREG32(IH_RB_RPTR, 0);\n\tWREG32(IH_RB_WPTR, 0);\n\n\t \n\tih_cntl = MC_WRREQ_CREDIT(0x10) | MC_WR_CLEAN_CNT(0x10);\n\t \n\tif (rdev->msi_enabled)\n\t\tih_cntl |= RPTR_REARM;\n\tWREG32(IH_CNTL, ih_cntl);\n\n\t \n\tif (rdev->family >= CHIP_CEDAR)\n\t\tevergreen_disable_interrupt_state(rdev);\n\telse\n\t\tr600_disable_interrupt_state(rdev);\n\n\t \n\tpci_set_master(rdev->pdev);\n\n\t \n\tr600_enable_interrupts(rdev);\n\n\treturn ret;\n}\n\nvoid r600_irq_suspend(struct radeon_device *rdev)\n{\n\tr600_irq_disable(rdev);\n\tr600_rlc_stop(rdev);\n}\n\nvoid r600_irq_fini(struct radeon_device *rdev)\n{\n\tr600_irq_suspend(rdev);\n\tr600_ih_ring_fini(rdev);\n}\n\nint r600_irq_set(struct radeon_device *rdev)\n{\n\tu32 cp_int_cntl = CNTX_BUSY_INT_ENABLE | CNTX_EMPTY_INT_ENABLE;\n\tu32 mode_int = 0;\n\tu32 hpd1, hpd2, hpd3, hpd4 = 0, hpd5 = 0, hpd6 = 0;\n\tu32 grbm_int_cntl = 0;\n\tu32 hdmi0, hdmi1;\n\tu32 dma_cntl;\n\tu32 thermal_int = 0;\n\n\tif (!rdev->irq.installed) {\n\t\tWARN(1, \"Can't enable IRQ/MSI because no handler is installed\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (!rdev->ih.enabled) {\n\t\tr600_disable_interrupts(rdev);\n\t\t \n\t\tr600_disable_interrupt_state(rdev);\n\t\treturn 0;\n\t}\n\n\tif (ASIC_IS_DCE3(rdev)) {\n\t\thpd1 = RREG32(DC_HPD1_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\thpd2 = RREG32(DC_HPD2_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\thpd3 = RREG32(DC_HPD3_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\thpd4 = RREG32(DC_HPD4_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\tif (ASIC_IS_DCE32(rdev)) {\n\t\t\thpd5 = RREG32(DC_HPD5_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\t\thpd6 = RREG32(DC_HPD6_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\t\thdmi0 = RREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET0) & ~AFMT_AZ_FORMAT_WTRIG_MASK;\n\t\t\thdmi1 = RREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET1) & ~AFMT_AZ_FORMAT_WTRIG_MASK;\n\t\t} else {\n\t\t\thdmi0 = RREG32(HDMI0_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\t\thdmi1 = RREG32(DCE3_HDMI1_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\t}\n\t} else {\n\t\thpd1 = RREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\thpd2 = RREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\thpd3 = RREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL) & ~DC_HPDx_INT_EN;\n\t\thdmi0 = RREG32(HDMI0_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t\thdmi1 = RREG32(HDMI1_AUDIO_PACKET_CONTROL) & ~HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t}\n\n\tdma_cntl = RREG32(DMA_CNTL) & ~TRAP_ENABLE;\n\n\tif ((rdev->family > CHIP_R600) && (rdev->family < CHIP_RV770)) {\n\t\tthermal_int = RREG32(CG_THERMAL_INT) &\n\t\t\t~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\n\t} else if (rdev->family >= CHIP_RV770) {\n\t\tthermal_int = RREG32(RV770_CG_THERMAL_INT) &\n\t\t\t~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\n\t}\n\tif (rdev->irq.dpm_thermal) {\n\t\tDRM_DEBUG(\"dpm thermal\\n\");\n\t\tthermal_int |= THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW;\n\t}\n\n\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\tDRM_DEBUG(\"r600_irq_set: sw int\\n\");\n\t\tcp_int_cntl |= RB_INT_ENABLE;\n\t\tcp_int_cntl |= TIME_STAMP_INT_ENABLE;\n\t}\n\n\tif (atomic_read(&rdev->irq.ring_int[R600_RING_TYPE_DMA_INDEX])) {\n\t\tDRM_DEBUG(\"r600_irq_set: sw int dma\\n\");\n\t\tdma_cntl |= TRAP_ENABLE;\n\t}\n\n\tif (rdev->irq.crtc_vblank_int[0] ||\n\t    atomic_read(&rdev->irq.pflip[0])) {\n\t\tDRM_DEBUG(\"r600_irq_set: vblank 0\\n\");\n\t\tmode_int |= D1MODE_VBLANK_INT_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[1] ||\n\t    atomic_read(&rdev->irq.pflip[1])) {\n\t\tDRM_DEBUG(\"r600_irq_set: vblank 1\\n\");\n\t\tmode_int |= D2MODE_VBLANK_INT_MASK;\n\t}\n\tif (rdev->irq.hpd[0]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hpd 1\\n\");\n\t\thpd1 |= DC_HPDx_INT_EN;\n\t}\n\tif (rdev->irq.hpd[1]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hpd 2\\n\");\n\t\thpd2 |= DC_HPDx_INT_EN;\n\t}\n\tif (rdev->irq.hpd[2]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hpd 3\\n\");\n\t\thpd3 |= DC_HPDx_INT_EN;\n\t}\n\tif (rdev->irq.hpd[3]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hpd 4\\n\");\n\t\thpd4 |= DC_HPDx_INT_EN;\n\t}\n\tif (rdev->irq.hpd[4]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hpd 5\\n\");\n\t\thpd5 |= DC_HPDx_INT_EN;\n\t}\n\tif (rdev->irq.hpd[5]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hpd 6\\n\");\n\t\thpd6 |= DC_HPDx_INT_EN;\n\t}\n\tif (rdev->irq.afmt[0]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hdmi 0\\n\");\n\t\thdmi0 |= HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t}\n\tif (rdev->irq.afmt[1]) {\n\t\tDRM_DEBUG(\"r600_irq_set: hdmi 0\\n\");\n\t\thdmi1 |= HDMI0_AZ_FORMAT_WTRIG_MASK;\n\t}\n\n\tWREG32(CP_INT_CNTL, cp_int_cntl);\n\tWREG32(DMA_CNTL, dma_cntl);\n\tWREG32(DxMODE_INT_MASK, mode_int);\n\tWREG32(D1GRPH_INTERRUPT_CONTROL, DxGRPH_PFLIP_INT_MASK);\n\tWREG32(D2GRPH_INTERRUPT_CONTROL, DxGRPH_PFLIP_INT_MASK);\n\tWREG32(GRBM_INT_CNTL, grbm_int_cntl);\n\tif (ASIC_IS_DCE3(rdev)) {\n\t\tWREG32(DC_HPD1_INT_CONTROL, hpd1);\n\t\tWREG32(DC_HPD2_INT_CONTROL, hpd2);\n\t\tWREG32(DC_HPD3_INT_CONTROL, hpd3);\n\t\tWREG32(DC_HPD4_INT_CONTROL, hpd4);\n\t\tif (ASIC_IS_DCE32(rdev)) {\n\t\t\tWREG32(DC_HPD5_INT_CONTROL, hpd5);\n\t\t\tWREG32(DC_HPD6_INT_CONTROL, hpd6);\n\t\t\tWREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET0, hdmi0);\n\t\t\tWREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET1, hdmi1);\n\t\t} else {\n\t\t\tWREG32(HDMI0_AUDIO_PACKET_CONTROL, hdmi0);\n\t\t\tWREG32(DCE3_HDMI1_AUDIO_PACKET_CONTROL, hdmi1);\n\t\t}\n\t} else {\n\t\tWREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL, hpd1);\n\t\tWREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL, hpd2);\n\t\tWREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL, hpd3);\n\t\tWREG32(HDMI0_AUDIO_PACKET_CONTROL, hdmi0);\n\t\tWREG32(HDMI1_AUDIO_PACKET_CONTROL, hdmi1);\n\t}\n\tif ((rdev->family > CHIP_R600) && (rdev->family < CHIP_RV770)) {\n\t\tWREG32(CG_THERMAL_INT, thermal_int);\n\t} else if (rdev->family >= CHIP_RV770) {\n\t\tWREG32(RV770_CG_THERMAL_INT, thermal_int);\n\t}\n\n\t \n\tRREG32(R_000E50_SRBM_STATUS);\n\n\treturn 0;\n}\n\nstatic void r600_irq_ack(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tif (ASIC_IS_DCE3(rdev)) {\n\t\trdev->irq.stat_regs.r600.disp_int = RREG32(DCE3_DISP_INTERRUPT_STATUS);\n\t\trdev->irq.stat_regs.r600.disp_int_cont = RREG32(DCE3_DISP_INTERRUPT_STATUS_CONTINUE);\n\t\trdev->irq.stat_regs.r600.disp_int_cont2 = RREG32(DCE3_DISP_INTERRUPT_STATUS_CONTINUE2);\n\t\tif (ASIC_IS_DCE32(rdev)) {\n\t\t\trdev->irq.stat_regs.r600.hdmi0_status = RREG32(AFMT_STATUS + DCE3_HDMI_OFFSET0);\n\t\t\trdev->irq.stat_regs.r600.hdmi1_status = RREG32(AFMT_STATUS + DCE3_HDMI_OFFSET1);\n\t\t} else {\n\t\t\trdev->irq.stat_regs.r600.hdmi0_status = RREG32(HDMI0_STATUS);\n\t\t\trdev->irq.stat_regs.r600.hdmi1_status = RREG32(DCE3_HDMI1_STATUS);\n\t\t}\n\t} else {\n\t\trdev->irq.stat_regs.r600.disp_int = RREG32(DISP_INTERRUPT_STATUS);\n\t\trdev->irq.stat_regs.r600.disp_int_cont = RREG32(DISP_INTERRUPT_STATUS_CONTINUE);\n\t\trdev->irq.stat_regs.r600.disp_int_cont2 = 0;\n\t\trdev->irq.stat_regs.r600.hdmi0_status = RREG32(HDMI0_STATUS);\n\t\trdev->irq.stat_regs.r600.hdmi1_status = RREG32(HDMI1_STATUS);\n\t}\n\trdev->irq.stat_regs.r600.d1grph_int = RREG32(D1GRPH_INTERRUPT_STATUS);\n\trdev->irq.stat_regs.r600.d2grph_int = RREG32(D2GRPH_INTERRUPT_STATUS);\n\n\tif (rdev->irq.stat_regs.r600.d1grph_int & DxGRPH_PFLIP_INT_OCCURRED)\n\t\tWREG32(D1GRPH_INTERRUPT_STATUS, DxGRPH_PFLIP_INT_CLEAR);\n\tif (rdev->irq.stat_regs.r600.d2grph_int & DxGRPH_PFLIP_INT_OCCURRED)\n\t\tWREG32(D2GRPH_INTERRUPT_STATUS, DxGRPH_PFLIP_INT_CLEAR);\n\tif (rdev->irq.stat_regs.r600.disp_int & LB_D1_VBLANK_INTERRUPT)\n\t\tWREG32(D1MODE_VBLANK_STATUS, DxMODE_VBLANK_ACK);\n\tif (rdev->irq.stat_regs.r600.disp_int & LB_D1_VLINE_INTERRUPT)\n\t\tWREG32(D1MODE_VLINE_STATUS, DxMODE_VLINE_ACK);\n\tif (rdev->irq.stat_regs.r600.disp_int & LB_D2_VBLANK_INTERRUPT)\n\t\tWREG32(D2MODE_VBLANK_STATUS, DxMODE_VBLANK_ACK);\n\tif (rdev->irq.stat_regs.r600.disp_int & LB_D2_VLINE_INTERRUPT)\n\t\tWREG32(D2MODE_VLINE_STATUS, DxMODE_VLINE_ACK);\n\tif (rdev->irq.stat_regs.r600.disp_int & DC_HPD1_INTERRUPT) {\n\t\tif (ASIC_IS_DCE3(rdev)) {\n\t\t\ttmp = RREG32(DC_HPD1_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HPD1_INT_CONTROL, tmp);\n\t\t} else {\n\t\t\ttmp = RREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\n\t\t}\n\t}\n\tif (rdev->irq.stat_regs.r600.disp_int & DC_HPD2_INTERRUPT) {\n\t\tif (ASIC_IS_DCE3(rdev)) {\n\t\t\ttmp = RREG32(DC_HPD2_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HPD2_INT_CONTROL, tmp);\n\t\t} else {\n\t\t\ttmp = RREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\n\t\t}\n\t}\n\tif (rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD3_INTERRUPT) {\n\t\tif (ASIC_IS_DCE3(rdev)) {\n\t\t\ttmp = RREG32(DC_HPD3_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HPD3_INT_CONTROL, tmp);\n\t\t} else {\n\t\t\ttmp = RREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL, tmp);\n\t\t}\n\t}\n\tif (rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD4_INTERRUPT) {\n\t\ttmp = RREG32(DC_HPD4_INT_CONTROL);\n\t\ttmp |= DC_HPDx_INT_ACK;\n\t\tWREG32(DC_HPD4_INT_CONTROL, tmp);\n\t}\n\tif (ASIC_IS_DCE32(rdev)) {\n\t\tif (rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD5_INTERRUPT) {\n\t\t\ttmp = RREG32(DC_HPD5_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HPD5_INT_CONTROL, tmp);\n\t\t}\n\t\tif (rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD6_INTERRUPT) {\n\t\t\ttmp = RREG32(DC_HPD6_INT_CONTROL);\n\t\t\ttmp |= DC_HPDx_INT_ACK;\n\t\t\tWREG32(DC_HPD6_INT_CONTROL, tmp);\n\t\t}\n\t\tif (rdev->irq.stat_regs.r600.hdmi0_status & AFMT_AZ_FORMAT_WTRIG) {\n\t\t\ttmp = RREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET0);\n\t\t\ttmp |= AFMT_AZ_FORMAT_WTRIG_ACK;\n\t\t\tWREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET0, tmp);\n\t\t}\n\t\tif (rdev->irq.stat_regs.r600.hdmi1_status & AFMT_AZ_FORMAT_WTRIG) {\n\t\t\ttmp = RREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET1);\n\t\t\ttmp |= AFMT_AZ_FORMAT_WTRIG_ACK;\n\t\t\tWREG32(AFMT_AUDIO_PACKET_CONTROL + DCE3_HDMI_OFFSET1, tmp);\n\t\t}\n\t} else {\n\t\tif (rdev->irq.stat_regs.r600.hdmi0_status & HDMI0_AZ_FORMAT_WTRIG) {\n\t\t\ttmp = RREG32(HDMI0_AUDIO_PACKET_CONTROL);\n\t\t\ttmp |= HDMI0_AZ_FORMAT_WTRIG_ACK;\n\t\t\tWREG32(HDMI0_AUDIO_PACKET_CONTROL, tmp);\n\t\t}\n\t\tif (rdev->irq.stat_regs.r600.hdmi1_status & HDMI0_AZ_FORMAT_WTRIG) {\n\t\t\tif (ASIC_IS_DCE3(rdev)) {\n\t\t\t\ttmp = RREG32(DCE3_HDMI1_AUDIO_PACKET_CONTROL);\n\t\t\t\ttmp |= HDMI0_AZ_FORMAT_WTRIG_ACK;\n\t\t\t\tWREG32(DCE3_HDMI1_AUDIO_PACKET_CONTROL, tmp);\n\t\t\t} else {\n\t\t\t\ttmp = RREG32(HDMI1_AUDIO_PACKET_CONTROL);\n\t\t\t\ttmp |= HDMI0_AZ_FORMAT_WTRIG_ACK;\n\t\t\t\tWREG32(HDMI1_AUDIO_PACKET_CONTROL, tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid r600_irq_disable(struct radeon_device *rdev)\n{\n\tr600_disable_interrupts(rdev);\n\t \n\tmdelay(1);\n\tr600_irq_ack(rdev);\n\tr600_disable_interrupt_state(rdev);\n}\n\nstatic u32 r600_get_ih_wptr(struct radeon_device *rdev)\n{\n\tu32 wptr, tmp;\n\n\tif (rdev->wb.enabled)\n\t\twptr = le32_to_cpu(rdev->wb.wb[R600_WB_IH_WPTR_OFFSET/4]);\n\telse\n\t\twptr = RREG32(IH_RB_WPTR);\n\n\tif (wptr & RB_OVERFLOW) {\n\t\twptr &= ~RB_OVERFLOW;\n\t\t \n\t\tdev_warn(rdev->dev, \"IH ring buffer overflow (0x%08X, 0x%08X, 0x%08X)\\n\",\n\t\t\t wptr, rdev->ih.rptr, (wptr + 16) & rdev->ih.ptr_mask);\n\t\trdev->ih.rptr = (wptr + 16) & rdev->ih.ptr_mask;\n\t\ttmp = RREG32(IH_RB_CNTL);\n\t\ttmp |= IH_WPTR_OVERFLOW_CLEAR;\n\t\tWREG32(IH_RB_CNTL, tmp);\n\t}\n\treturn (wptr & rdev->ih.ptr_mask);\n}\n\n \n\nint r600_irq_process(struct radeon_device *rdev)\n{\n\tu32 wptr;\n\tu32 rptr;\n\tu32 src_id, src_data;\n\tu32 ring_index;\n\tbool queue_hotplug = false;\n\tbool queue_hdmi = false;\n\tbool queue_thermal = false;\n\n\tif (!rdev->ih.enabled || rdev->shutdown)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (!rdev->msi_enabled)\n\t\tRREG32(IH_RB_WPTR);\n\n\twptr = r600_get_ih_wptr(rdev);\n\nrestart_ih:\n\t \n\tif (atomic_xchg(&rdev->ih.lock, 1))\n\t\treturn IRQ_NONE;\n\n\trptr = rdev->ih.rptr;\n\tDRM_DEBUG(\"r600_irq_process start: rptr %d, wptr %d\\n\", rptr, wptr);\n\n\t \n\trmb();\n\n\t \n\tr600_irq_ack(rdev);\n\n\twhile (rptr != wptr) {\n\t\t \n\t\tring_index = rptr / 4;\n\t\tsrc_id = le32_to_cpu(rdev->ih.ring[ring_index]) & 0xff;\n\t\tsrc_data = le32_to_cpu(rdev->ih.ring[ring_index + 1]) & 0xfffffff;\n\n\t\tswitch (src_id) {\n\t\tcase 1:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int & LB_D1_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: D1 vblank - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[0]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 0);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[0]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 0);\n\t\t\t\trdev->irq.stat_regs.r600.disp_int &= ~LB_D1_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D1 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int & LB_D1_VLINE_INTERRUPT))\n\t\t\t\t    DRM_DEBUG(\"IH: D1 vline - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int &= ~LB_D1_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D1 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:  \n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int & LB_D2_VBLANK_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: D2 vblank - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\tif (rdev->irq.crtc_vblank_int[1]) {\n\t\t\t\t\tdrm_handle_vblank(rdev->ddev, 1);\n\t\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t\t}\n\t\t\t\tif (atomic_read(&rdev->irq.pflip[1]))\n\t\t\t\t\tradeon_crtc_handle_vblank(rdev, 1);\n\t\t\t\trdev->irq.stat_regs.r600.disp_int &= ~LB_D2_VBLANK_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D2 vblank\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 1:  \n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int & LB_D2_VLINE_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: D2 vline - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int &= ~LB_D2_VLINE_INTERRUPT;\n\t\t\t\tDRM_DEBUG(\"IH: D2 vline\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 9:  \n\t\t\tDRM_DEBUG(\"IH: D1 flip\\n\");\n\t\t\tif (radeon_use_pflipirq > 0)\n\t\t\t\tradeon_crtc_handle_flip(rdev, 0);\n\t\t\tbreak;\n\t\tcase 11:  \n\t\t\tDRM_DEBUG(\"IH: D2 flip\\n\");\n\t\t\tif (radeon_use_pflipirq > 0)\n\t\t\t\tradeon_crtc_handle_flip(rdev, 1);\n\t\t\tbreak;\n\t\tcase 19:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 0:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int & DC_HPD1_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: HPD1 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int &= ~DC_HPD1_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD1\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int & DC_HPD2_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: HPD2 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int &= ~DC_HPD2_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD2\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD3_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: HPD3 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int_cont &= ~DC_HPD3_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD3\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD4_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: HPD4 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int_cont &= ~DC_HPD4_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD4\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD5_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: HPD5 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int_cont2 &= ~DC_HPD5_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD5\\n\");\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD6_INTERRUPT))\n\t\t\t\t\tDRM_DEBUG(\"IH: HPD6 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.disp_int_cont2 &= ~DC_HPD6_INTERRUPT;\n\t\t\t\tqueue_hotplug = true;\n\t\t\t\tDRM_DEBUG(\"IH: HPD6\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:  \n\t\t\tswitch (src_data) {\n\t\t\tcase 4:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.hdmi0_status & HDMI0_AZ_FORMAT_WTRIG))\n\t\t\t\t\tDRM_DEBUG(\"IH: HDMI0 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.hdmi0_status &= ~HDMI0_AZ_FORMAT_WTRIG;\n\t\t\t\tqueue_hdmi = true;\n\t\t\t\tDRM_DEBUG(\"IH: HDMI0\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tif (!(rdev->irq.stat_regs.r600.hdmi1_status & HDMI0_AZ_FORMAT_WTRIG))\n\t\t\t\t\tDRM_DEBUG(\"IH: HDMI1 - IH event w/o asserted irq bit?\\n\");\n\n\t\t\t\trdev->irq.stat_regs.r600.hdmi1_status &= ~HDMI0_AZ_FORMAT_WTRIG;\n\t\t\t\tqueue_hdmi = true;\n\t\t\t\tDRM_DEBUG(\"IH: HDMI1\\n\");\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tDRM_ERROR(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 124:  \n\t\t\tDRM_DEBUG(\"IH: UVD int: 0x%08x\\n\", src_data);\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_UVD_INDEX);\n\t\t\tbreak;\n\t\tcase 176:  \n\t\tcase 177:  \n\t\tcase 178:  \n\t\t\tDRM_DEBUG(\"IH: CP int: 0x%08x\\n\", src_data);\n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\tbreak;\n\t\tcase 181:  \n\t\t\tDRM_DEBUG(\"IH: CP EOP\\n\");\n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t\tbreak;\n\t\tcase 224:  \n\t\t\tDRM_DEBUG(\"IH: DMA trap\\n\");\n\t\t\tradeon_fence_process(rdev, R600_RING_TYPE_DMA_INDEX);\n\t\t\tbreak;\n\t\tcase 230:  \n\t\t\tDRM_DEBUG(\"IH: thermal low to high\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = false;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 231:  \n\t\t\tDRM_DEBUG(\"IH: thermal high to low\\n\");\n\t\t\trdev->pm.dpm.thermal.high_to_low = true;\n\t\t\tqueue_thermal = true;\n\t\t\tbreak;\n\t\tcase 233:  \n\t\t\tDRM_DEBUG(\"IH: GUI idle\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG(\"Unhandled interrupt: %d %d\\n\", src_id, src_data);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trptr += 16;\n\t\trptr &= rdev->ih.ptr_mask;\n\t\tWREG32(IH_RB_RPTR, rptr);\n\t}\n\tif (queue_hotplug)\n\t\tschedule_delayed_work(&rdev->hotplug_work, 0);\n\tif (queue_hdmi)\n\t\tschedule_work(&rdev->audio_work);\n\tif (queue_thermal && rdev->pm.dpm_enabled)\n\t\tschedule_work(&rdev->pm.dpm.thermal.work);\n\trdev->ih.rptr = rptr;\n\tatomic_set(&rdev->ih.lock, 0);\n\n\t \n\twptr = r600_get_ih_wptr(rdev);\n\tif (wptr != rptr)\n\t\tgoto restart_ih;\n\n\treturn IRQ_HANDLED;\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\n\nstatic int r600_debugfs_mc_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\n\tDREG32_SYS(m, rdev, R_000E50_SRBM_STATUS);\n\tDREG32_SYS(m, rdev, VM_L2_STATUS);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(r600_debugfs_mc_info);\n#endif\n\nstatic void r600_debugfs_mc_info_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"r600_mc_info\", 0444, root, rdev,\n\t\t\t    &r600_debugfs_mc_info_fops);\n\n#endif\n}\n\n \nvoid r600_mmio_hdp_flush(struct radeon_device *rdev)\n{\n\t \n\tif ((rdev->family >= CHIP_RV770) && (rdev->family <= CHIP_RV740) &&\n\t    rdev->vram_scratch.ptr && !(rdev->flags & RADEON_IS_AGP)) {\n\t\tvoid __iomem *ptr = (void *)rdev->vram_scratch.ptr;\n\n\t\tWREG32(HDP_DEBUG1, 0);\n\t\treadl((void __iomem *)ptr);\n\t} else\n\t\tWREG32(R_005480_HDP_MEM_COHERENCY_FLUSH_CNTL, 0x1);\n}\n\nvoid r600_set_pcie_lanes(struct radeon_device *rdev, int lanes)\n{\n\tu32 link_width_cntl, mask;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\t \n\tif (ASIC_IS_X2(rdev))\n\t\treturn;\n\n\tradeon_gui_idle(rdev);\n\n\tswitch (lanes) {\n\tcase 0:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X0;\n\t\tbreak;\n\tcase 1:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X1;\n\t\tbreak;\n\tcase 2:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X2;\n\t\tbreak;\n\tcase 4:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X4;\n\t\tbreak;\n\tcase 8:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X8;\n\t\tbreak;\n\tcase 12:\n\t\t \n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X12;\n\t\tbreak;\n\tcase 16:\n\t\tmask = RADEON_PCIE_LC_LINK_WIDTH_X16;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"invalid pcie lane request: %d\\n\", lanes);\n\t\treturn;\n\t}\n\n\tlink_width_cntl = RREG32_PCIE_PORT(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\n\tlink_width_cntl &= ~RADEON_PCIE_LC_LINK_WIDTH_MASK;\n\tlink_width_cntl |= mask << RADEON_PCIE_LC_LINK_WIDTH_SHIFT;\n\tlink_width_cntl |= (RADEON_PCIE_LC_RECONFIG_NOW |\n\t\t\t    R600_PCIE_LC_RECONFIG_ARC_MISSING_ESCAPE);\n\n\tWREG32_PCIE_PORT(RADEON_PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n}\n\nint r600_get_pcie_lanes(struct radeon_device *rdev)\n{\n\tu32 link_width_cntl;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn 0;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn 0;\n\n\t \n\tif (ASIC_IS_X2(rdev))\n\t\treturn 0;\n\n\tradeon_gui_idle(rdev);\n\n\tlink_width_cntl = RREG32_PCIE_PORT(RADEON_PCIE_LC_LINK_WIDTH_CNTL);\n\n\tswitch ((link_width_cntl & RADEON_PCIE_LC_LINK_WIDTH_RD_MASK) >> RADEON_PCIE_LC_LINK_WIDTH_RD_SHIFT) {\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X1:\n\t\treturn 1;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X2:\n\t\treturn 2;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X4:\n\t\treturn 4;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X8:\n\t\treturn 8;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X12:\n\t\t \n\t\treturn 12;\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X0:\n\tcase RADEON_PCIE_LC_LINK_WIDTH_X16:\n\tdefault:\n\t\treturn 16;\n\t}\n}\n\nstatic void r600_pcie_gen2_enable(struct radeon_device *rdev)\n{\n\tu32 link_width_cntl, lanes, speed_cntl, training_cntl, tmp;\n\tu16 link_cntl2;\n\n\tif (radeon_pcie_gen2 == 0)\n\t\treturn;\n\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn;\n\n\tif (!(rdev->flags & RADEON_IS_PCIE))\n\t\treturn;\n\n\t \n\tif (ASIC_IS_X2(rdev))\n\t\treturn;\n\n\t \n\tif (rdev->family <= CHIP_R600)\n\t\treturn;\n\n\tif ((rdev->pdev->bus->max_bus_speed != PCIE_SPEED_5_0GT) &&\n\t\t(rdev->pdev->bus->max_bus_speed != PCIE_SPEED_8_0GT))\n\t\treturn;\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tif (speed_cntl & LC_CURRENT_DATA_RATE) {\n\t\tDRM_INFO(\"PCIE gen 2 link speeds already enabled\\n\");\n\t\treturn;\n\t}\n\n\tDRM_INFO(\"enabling PCIE gen 2 link speeds, disable with radeon.pcie_gen2=0\\n\");\n\n\t \n\tif ((rdev->family == CHIP_RV670) ||\n\t    (rdev->family == CHIP_RV620) ||\n\t    (rdev->family == CHIP_RV635)) {\n\t\t \n\t\tlink_width_cntl = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\tlink_width_cntl &= ~LC_UPCONFIGURE_DIS;\n\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\t\tlink_width_cntl = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\tif (link_width_cntl & LC_RENEGOTIATION_SUPPORT) {\n\t\t\tlanes = (link_width_cntl & LC_LINK_WIDTH_RD_MASK) >> LC_LINK_WIDTH_RD_SHIFT;\n\t\t\tlink_width_cntl &= ~(LC_LINK_WIDTH_MASK |\n\t\t\t\t\t     LC_RECONFIG_ARC_MISSING_ESCAPE);\n\t\t\tlink_width_cntl |= lanes | LC_RECONFIG_NOW | LC_RENEGOTIATE_EN;\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\t\t} else {\n\t\t\tlink_width_cntl |= LC_UPCONFIGURE_DIS;\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\t\t}\n\t}\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tif ((speed_cntl & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t    (speed_cntl & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\n\n\t\t \n\t\tif ((rdev->family == CHIP_RV670) ||\n\t\t    (rdev->family == CHIP_RV620) ||\n\t\t    (rdev->family == CHIP_RV635)) {\n\t\t\tWREG32(MM_CFGREGS_CNTL, 0x8);\n\t\t\tlink_cntl2 = RREG32(0x4088);\n\t\t\tWREG32(MM_CFGREGS_CNTL, 0);\n\t\t\t \n\t\t\tif (link_cntl2 & SELECTABLE_DEEMPHASIS)\n\t\t\t\treturn;\n\t\t}\n\n\t\tspeed_cntl &= ~LC_SPEED_CHANGE_ATTEMPTS_ALLOWED_MASK;\n\t\tspeed_cntl |= (0x3 << LC_SPEED_CHANGE_ATTEMPTS_ALLOWED_SHIFT);\n\t\tspeed_cntl &= ~LC_VOLTAGE_TIMER_SEL_MASK;\n\t\tspeed_cntl &= ~LC_FORCE_DIS_HW_SPEED_CHANGE;\n\t\tspeed_cntl |= LC_FORCE_EN_HW_SPEED_CHANGE;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\t\ttmp = RREG32(0x541c);\n\t\tWREG32(0x541c, tmp | 0x8);\n\t\tWREG32(MM_CFGREGS_CNTL, MM_WR_TO_CFG_EN);\n\t\tlink_cntl2 = RREG16(0x4088);\n\t\tlink_cntl2 &= ~TARGET_LINK_SPEED_MASK;\n\t\tlink_cntl2 |= 0x2;\n\t\tWREG16(0x4088, link_cntl2);\n\t\tWREG32(MM_CFGREGS_CNTL, 0);\n\n\t\tif ((rdev->family == CHIP_RV670) ||\n\t\t    (rdev->family == CHIP_RV620) ||\n\t\t    (rdev->family == CHIP_RV635)) {\n\t\t\ttraining_cntl = RREG32_PCIE_PORT(PCIE_LC_TRAINING_CNTL);\n\t\t\ttraining_cntl &= ~LC_POINT_7_PLUS_EN;\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_TRAINING_CNTL, training_cntl);\n\t\t} else {\n\t\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\t\tspeed_cntl &= ~LC_TARGET_LINK_SPEED_OVERRIDE_EN;\n\t\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\t\t}\n\n\t\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\t\tspeed_cntl |= LC_GEN2_EN_STRAP;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, speed_cntl);\n\n\t} else {\n\t\tlink_width_cntl = RREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL);\n\t\t \n\t\tif (1)\n\t\t\tlink_width_cntl |= LC_UPCONFIGURE_DIS;\n\t\telse\n\t\t\tlink_width_cntl &= ~LC_UPCONFIGURE_DIS;\n\t\tWREG32_PCIE_PORT(PCIE_LC_LINK_WIDTH_CNTL, link_width_cntl);\n\t}\n}\n\n \nuint64_t r600_get_gpu_clock_counter(struct radeon_device *rdev)\n{\n\tuint64_t clock;\n\n\tmutex_lock(&rdev->gpu_clock_mutex);\n\tWREG32(RLC_CAPTURE_GPU_CLOCK_COUNT, 1);\n\tclock = (uint64_t)RREG32(RLC_GPU_CLOCK_COUNT_LSB) |\n\t\t((uint64_t)RREG32(RLC_GPU_CLOCK_COUNT_MSB) << 32ULL);\n\tmutex_unlock(&rdev->gpu_clock_mutex);\n\treturn clock;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}