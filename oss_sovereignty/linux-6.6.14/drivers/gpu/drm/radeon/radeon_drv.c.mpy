{
  "module_name": "radeon_drv.c",
  "hash_id": "c04a5a97a20939f9afd8e59ec5b6f51a83743002968461e6c621a258d0d267e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_drv.c",
  "human_readable_source": " \n\n \n\n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/vga_switcheroo.h>\n#include <linux/mmu_notifier.h>\n#include <linux/pci.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_pciids.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon_drv.h\"\n#include \"radeon.h\"\n#include \"radeon_kms.h\"\n#include \"radeon_ttm.h\"\n#include \"radeon_device.h\"\n#include \"radeon_prime.h\"\n\n \n#define KMS_DRIVER_MAJOR\t2\n#define KMS_DRIVER_MINOR\t50\n#define KMS_DRIVER_PATCHLEVEL\t0\n\nint radeon_no_wb;\nint radeon_modeset = -1;\nint radeon_dynclks = -1;\nint radeon_r4xx_atom;\nint radeon_agpmode = -1;\nint radeon_vram_limit;\nint radeon_gart_size = -1;  \nint radeon_benchmarking;\nint radeon_testing;\nint radeon_connector_table;\nint radeon_tv = 1;\nint radeon_audio = -1;\nint radeon_disp_priority;\nint radeon_hw_i2c;\nint radeon_pcie_gen2 = -1;\nint radeon_msi = -1;\nint radeon_lockup_timeout = 10000;\nint radeon_fastfb;\nint radeon_dpm = -1;\nint radeon_aspm = -1;\nint radeon_runtime_pm = -1;\nint radeon_hard_reset;\nint radeon_vm_size = 8;\nint radeon_vm_block_size = -1;\nint radeon_deep_color;\nint radeon_use_pflipirq = 2;\nint radeon_bapm = -1;\nint radeon_backlight = -1;\nint radeon_auxch = -1;\nint radeon_uvd = 1;\nint radeon_vce = 1;\n\nMODULE_PARM_DESC(no_wb, \"Disable AGP writeback for scratch registers\");\nmodule_param_named(no_wb, radeon_no_wb, int, 0444);\n\nMODULE_PARM_DESC(modeset, \"Disable/Enable modesetting\");\nmodule_param_named(modeset, radeon_modeset, int, 0400);\n\nMODULE_PARM_DESC(dynclks, \"Disable/Enable dynamic clocks\");\nmodule_param_named(dynclks, radeon_dynclks, int, 0444);\n\nMODULE_PARM_DESC(r4xx_atom, \"Enable ATOMBIOS modesetting for R4xx\");\nmodule_param_named(r4xx_atom, radeon_r4xx_atom, int, 0444);\n\nMODULE_PARM_DESC(vramlimit, \"Restrict VRAM for testing, in megabytes\");\nmodule_param_named(vramlimit, radeon_vram_limit, int, 0600);\n\nMODULE_PARM_DESC(agpmode, \"AGP Mode (-1 == PCI)\");\nmodule_param_named(agpmode, radeon_agpmode, int, 0444);\n\nMODULE_PARM_DESC(gartsize, \"Size of PCIE/IGP gart to setup in megabytes (32, 64, etc., -1 = auto)\");\nmodule_param_named(gartsize, radeon_gart_size, int, 0600);\n\nMODULE_PARM_DESC(benchmark, \"Run benchmark\");\nmodule_param_named(benchmark, radeon_benchmarking, int, 0444);\n\nMODULE_PARM_DESC(test, \"Run tests\");\nmodule_param_named(test, radeon_testing, int, 0444);\n\nMODULE_PARM_DESC(connector_table, \"Force connector table\");\nmodule_param_named(connector_table, radeon_connector_table, int, 0444);\n\nMODULE_PARM_DESC(tv, \"TV enable (0 = disable)\");\nmodule_param_named(tv, radeon_tv, int, 0444);\n\nMODULE_PARM_DESC(audio, \"Audio enable (-1 = auto, 0 = disable, 1 = enable)\");\nmodule_param_named(audio, radeon_audio, int, 0444);\n\nMODULE_PARM_DESC(disp_priority, \"Display Priority (0 = auto, 1 = normal, 2 = high)\");\nmodule_param_named(disp_priority, radeon_disp_priority, int, 0444);\n\nMODULE_PARM_DESC(hw_i2c, \"hw i2c engine enable (0 = disable)\");\nmodule_param_named(hw_i2c, radeon_hw_i2c, int, 0444);\n\nMODULE_PARM_DESC(pcie_gen2, \"PCIE Gen2 mode (-1 = auto, 0 = disable, 1 = enable)\");\nmodule_param_named(pcie_gen2, radeon_pcie_gen2, int, 0444);\n\nMODULE_PARM_DESC(msi, \"MSI support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(msi, radeon_msi, int, 0444);\n\nMODULE_PARM_DESC(lockup_timeout, \"GPU lockup timeout in ms (default 10000 = 10 seconds, 0 = disable)\");\nmodule_param_named(lockup_timeout, radeon_lockup_timeout, int, 0444);\n\nMODULE_PARM_DESC(fastfb, \"Direct FB access for IGP chips (0 = disable, 1 = enable)\");\nmodule_param_named(fastfb, radeon_fastfb, int, 0444);\n\nMODULE_PARM_DESC(dpm, \"DPM support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(dpm, radeon_dpm, int, 0444);\n\nMODULE_PARM_DESC(aspm, \"ASPM support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(aspm, radeon_aspm, int, 0444);\n\nMODULE_PARM_DESC(runpm, \"PX runtime pm (1 = force enable, 0 = disable, -1 = PX only default)\");\nmodule_param_named(runpm, radeon_runtime_pm, int, 0444);\n\nMODULE_PARM_DESC(hard_reset, \"PCI config reset (1 = force enable, 0 = disable (default))\");\nmodule_param_named(hard_reset, radeon_hard_reset, int, 0444);\n\nMODULE_PARM_DESC(vm_size, \"VM address space size in gigabytes (default 4GB)\");\nmodule_param_named(vm_size, radeon_vm_size, int, 0444);\n\nMODULE_PARM_DESC(vm_block_size, \"VM page table size in bits (default depending on vm_size)\");\nmodule_param_named(vm_block_size, radeon_vm_block_size, int, 0444);\n\nMODULE_PARM_DESC(deep_color, \"Deep Color support (1 = enable, 0 = disable (default))\");\nmodule_param_named(deep_color, radeon_deep_color, int, 0444);\n\nMODULE_PARM_DESC(use_pflipirq, \"Pflip irqs for pageflip completion (0 = disable, 1 = as fallback, 2 = exclusive (default))\");\nmodule_param_named(use_pflipirq, radeon_use_pflipirq, int, 0444);\n\nMODULE_PARM_DESC(bapm, \"BAPM support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(bapm, radeon_bapm, int, 0444);\n\nMODULE_PARM_DESC(backlight, \"backlight support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(backlight, radeon_backlight, int, 0444);\n\nMODULE_PARM_DESC(auxch, \"Use native auxch experimental support (1 = enable, 0 = disable, -1 = auto)\");\nmodule_param_named(auxch, radeon_auxch, int, 0444);\n\nMODULE_PARM_DESC(uvd, \"uvd enable/disable uvd support (1 = enable, 0 = disable)\");\nmodule_param_named(uvd, radeon_uvd, int, 0444);\n\nMODULE_PARM_DESC(vce, \"vce enable/disable vce support (1 = enable, 0 = disable)\");\nmodule_param_named(vce, radeon_vce, int, 0444);\n\nint radeon_si_support = 1;\nMODULE_PARM_DESC(si_support, \"SI support (1 = enabled (default), 0 = disabled)\");\nmodule_param_named(si_support, radeon_si_support, int, 0444);\n\nint radeon_cik_support = 1;\nMODULE_PARM_DESC(cik_support, \"CIK support (1 = enabled (default), 0 = disabled)\");\nmodule_param_named(cik_support, radeon_cik_support, int, 0444);\n\nstatic struct pci_device_id pciidlist[] = {\n\tradeon_PCI_IDS\n};\n\nMODULE_DEVICE_TABLE(pci, pciidlist);\n\nstatic const struct drm_driver kms_driver;\n\nstatic int radeon_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tunsigned long flags = 0;\n\tstruct drm_device *dev;\n\tint ret;\n\n\tif (!ent)\n\t\treturn -ENODEV;  \n\n\tflags = ent->driver_data;\n\n\tif (!radeon_si_support) {\n\t\tswitch (flags & RADEON_FAMILY_MASK) {\n\t\tcase CHIP_TAHITI:\n\t\tcase CHIP_PITCAIRN:\n\t\tcase CHIP_VERDE:\n\t\tcase CHIP_OLAND:\n\t\tcase CHIP_HAINAN:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"SI support disabled by module param\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif (!radeon_cik_support) {\n\t\tswitch (flags & RADEON_FAMILY_MASK) {\n\t\tcase CHIP_KAVERI:\n\t\tcase CHIP_BONAIRE:\n\t\tcase CHIP_HAWAII:\n\t\tcase CHIP_KABINI:\n\t\tcase CHIP_MULLINS:\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"CIK support disabled by module param\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (vga_switcheroo_client_probe_defer(pdev))\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &kms_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tdev = drm_dev_alloc(&kms_driver, &pdev->dev);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto err_free;\n\n\tpci_set_drvdata(pdev, dev);\n\n\tret = drm_dev_register(dev, ent->driver_data);\n\tif (ret)\n\t\tgoto err_agp;\n\n\tradeon_fbdev_setup(dev->dev_private);\n\n\treturn 0;\n\nerr_agp:\n\tpci_disable_device(pdev);\nerr_free:\n\tdrm_dev_put(dev);\n\treturn ret;\n}\n\nstatic void\nradeon_pci_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tdrm_put_dev(dev);\n}\n\nstatic void\nradeon_pci_shutdown(struct pci_dev *pdev)\n{\n\t \n\tif (radeon_device_is_virtual())\n\t\tradeon_pci_remove(pdev);\n\n#if defined(CONFIG_PPC64) || defined(CONFIG_MACH_LOONGSON64)\n\t \n\tradeon_suspend_kms(pci_get_drvdata(pdev), true, true, false);\n#endif\n}\n\nstatic int radeon_pmops_suspend(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn radeon_suspend_kms(drm_dev, true, true, false);\n}\n\nstatic int radeon_pmops_resume(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\t \n\tif (radeon_is_px(drm_dev)) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\treturn radeon_resume_kms(drm_dev, true, true);\n}\n\nstatic int radeon_pmops_freeze(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn radeon_suspend_kms(drm_dev, false, true, true);\n}\n\nstatic int radeon_pmops_thaw(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\n\treturn radeon_resume_kms(drm_dev, false, true);\n}\n\nstatic int radeon_pmops_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\n\tif (!radeon_is_px(drm_dev)) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\n\tdrm_kms_helper_poll_disable(drm_dev);\n\n\tradeon_suspend_kms(drm_dev, false, false, false);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_ignore_hotplug(pdev);\n\tif (radeon_is_atpx_hybrid())\n\t\tpci_set_power_state(pdev, PCI_D3cold);\n\telse if (!radeon_has_atpx_dgpu_power_cntl())\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_DYNAMIC_OFF;\n\n\treturn 0;\n}\n\nstatic int radeon_pmops_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (!radeon_is_px(drm_dev))\n\t\treturn -EINVAL;\n\n\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\n\n\tif (radeon_is_atpx_hybrid() ||\n\t    !radeon_has_atpx_dgpu_power_cntl())\n\t\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\tpci_set_master(pdev);\n\n\tret = radeon_resume_kms(drm_dev, false, false);\n\tdrm_kms_helper_poll_enable(drm_dev);\n\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_ON;\n\treturn 0;\n}\n\nstatic int radeon_pmops_runtime_idle(struct device *dev)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct drm_crtc *crtc;\n\n\tif (!radeon_is_px(drm_dev)) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tlist_for_each_entry(crtc, &drm_dev->mode_config.crtc_list, head) {\n\t\tif (crtc->enabled) {\n\t\t\tDRM_DEBUG_DRIVER(\"failing to power off - crtc active\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_autosuspend(dev);\n\t \n\treturn 1;\n}\n\nlong radeon_drm_ioctl(struct file *filp,\n\t\t      unsigned int cmd, unsigned long arg)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev;\n\tlong ret;\n\n\tdev = file_priv->minor->dev;\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn ret;\n\t}\n\n\tret = drm_ioctl(filp, cmd, arg);\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long radeon_kms_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tunsigned int nr = DRM_IOCTL_NR(cmd);\n\n\tif (nr < DRM_COMMAND_BASE)\n\t\treturn drm_compat_ioctl(filp, cmd, arg);\n\n\treturn radeon_drm_ioctl(filp, cmd, arg);\n}\n#endif\n\nstatic const struct dev_pm_ops radeon_pm_ops = {\n\t.suspend = radeon_pmops_suspend,\n\t.resume = radeon_pmops_resume,\n\t.freeze = radeon_pmops_freeze,\n\t.thaw = radeon_pmops_thaw,\n\t.poweroff = radeon_pmops_freeze,\n\t.restore = radeon_pmops_resume,\n\t.runtime_suspend = radeon_pmops_runtime_suspend,\n\t.runtime_resume = radeon_pmops_runtime_resume,\n\t.runtime_idle = radeon_pmops_runtime_idle,\n};\n\nstatic const struct file_operations radeon_driver_kms_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_open,\n\t.release = drm_release,\n\t.unlocked_ioctl = radeon_drm_ioctl,\n\t.mmap = drm_gem_mmap,\n\t.poll = drm_poll,\n\t.read = drm_read,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = radeon_kms_compat_ioctl,\n#endif\n};\n\nstatic const struct drm_ioctl_desc radeon_ioctls_kms[] = {\n\tDRM_IOCTL_DEF_DRV(RADEON_CP_INIT, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(RADEON_CP_START, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(RADEON_CP_STOP, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(RADEON_CP_RESET, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(RADEON_CP_IDLE, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_CP_RESUME, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_RESET, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_FULLSCREEN, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_SWAP, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_CLEAR, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_VERTEX, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_INDICES, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_TEXTURE, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_STIPPLE, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_INDIRECT, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(RADEON_VERTEX2, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_CMDBUF, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_GETPARAM, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_FLIP, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_ALLOC, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_FREE, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_INIT_HEAP, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(RADEON_IRQ_EMIT, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_IRQ_WAIT, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_SETPARAM, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_SURF_ALLOC, drm_invalid_op, DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(RADEON_SURF_FREE, drm_invalid_op, DRM_AUTH),\n\t \n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_INFO, radeon_gem_info_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_CREATE, radeon_gem_create_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_MMAP, radeon_gem_mmap_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_SET_DOMAIN, radeon_gem_set_domain_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_WAIT_IDLE, radeon_gem_wait_idle_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_CS, radeon_cs_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_INFO, radeon_info_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_SET_TILING, radeon_gem_set_tiling_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_GET_TILING, radeon_gem_get_tiling_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_BUSY, radeon_gem_busy_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_VA, radeon_gem_va_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_OP, radeon_gem_op_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(RADEON_GEM_USERPTR, radeon_gem_userptr_ioctl, DRM_AUTH|DRM_RENDER_ALLOW),\n};\n\nstatic const struct drm_driver kms_driver = {\n\t.driver_features =\n\t    DRIVER_GEM | DRIVER_RENDER | DRIVER_MODESET,\n\t.load = radeon_driver_load_kms,\n\t.open = radeon_driver_open_kms,\n\t.postclose = radeon_driver_postclose_kms,\n\t.unload = radeon_driver_unload_kms,\n\t.ioctls = radeon_ioctls_kms,\n\t.num_ioctls = ARRAY_SIZE(radeon_ioctls_kms),\n\t.dumb_create = radeon_mode_dumb_create,\n\t.dumb_map_offset = radeon_mode_dumb_mmap,\n\t.fops = &radeon_driver_kms_fops,\n\n\t.gem_prime_import_sg_table = radeon_gem_prime_import_sg_table,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = KMS_DRIVER_MAJOR,\n\t.minor = KMS_DRIVER_MINOR,\n\t.patchlevel = KMS_DRIVER_PATCHLEVEL,\n};\n\nstatic struct pci_driver radeon_kms_pci_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = pciidlist,\n\t.probe = radeon_pci_probe,\n\t.remove = radeon_pci_remove,\n\t.shutdown = radeon_pci_shutdown,\n\t.driver.pm = &radeon_pm_ops,\n};\n\nstatic int __init radeon_module_init(void)\n{\n\tif (drm_firmware_drivers_only() && radeon_modeset == -1)\n\t\tradeon_modeset = 0;\n\n\tif (radeon_modeset == 0)\n\t\treturn -EINVAL;\n\n\tDRM_INFO(\"radeon kernel modesetting enabled.\\n\");\n\tradeon_register_atpx_handler();\n\n\treturn pci_register_driver(&radeon_kms_pci_driver);\n}\n\nstatic void __exit radeon_module_exit(void)\n{\n\tpci_unregister_driver(&radeon_kms_pci_driver);\n\tradeon_unregister_atpx_handler();\n\tmmu_notifier_synchronize();\n}\n\nmodule_init(radeon_module_init);\nmodule_exit(radeon_module_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}