{
  "module_name": "dce3_1_afmt.c",
  "hash_id": "29edfde13b1b0357a28bba92f1e22776a4f09910f5940c906f39525157b3413c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/dce3_1_afmt.c",
  "human_readable_source": " \n#include <linux/hdmi.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"r600d.h\"\n\nvoid dce3_2_afmt_hdmi_write_speaker_allocation(struct drm_encoder *encoder,\n\tu8 *sadb, int sad_count)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\n\ttmp &= ~(DP_CONNECTION | SPEAKER_ALLOCATION_MASK);\n\t \n\ttmp |= HDMI_CONNECTION;\n\tif (sad_count)\n\t\ttmp |= SPEAKER_ALLOCATION(sadb[0]);\n\telse\n\t\ttmp |= SPEAKER_ALLOCATION(5);  \n\tWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\n}\n\nvoid dce3_2_afmt_dp_write_speaker_allocation(struct drm_encoder *encoder,\n\tu8 *sadb, int sad_count)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tu32 tmp;\n\n\t \n\ttmp = RREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER);\n\ttmp &= ~(HDMI_CONNECTION | SPEAKER_ALLOCATION_MASK);\n\t \n\ttmp |= DP_CONNECTION;\n\tif (sad_count)\n\t\ttmp |= SPEAKER_ALLOCATION(sadb[0]);\n\telse\n\t\ttmp |= SPEAKER_ALLOCATION(5);  \n\tWREG32_ENDPOINT(0, AZ_F0_CODEC_PIN0_CONTROL_CHANNEL_SPEAKER, tmp);\n}\n\nvoid dce3_2_afmt_write_sad_regs(struct drm_encoder *encoder,\n\tstruct cea_sad *sads, int sad_count)\n{\n\tint i;\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstatic const u16 eld_reg_to_type[][2] = {\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR0, HDMI_AUDIO_CODING_TYPE_PCM },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR1, HDMI_AUDIO_CODING_TYPE_AC3 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR2, HDMI_AUDIO_CODING_TYPE_MPEG1 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR3, HDMI_AUDIO_CODING_TYPE_MP3 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR4, HDMI_AUDIO_CODING_TYPE_MPEG2 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR5, HDMI_AUDIO_CODING_TYPE_AAC_LC },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR6, HDMI_AUDIO_CODING_TYPE_DTS },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR7, HDMI_AUDIO_CODING_TYPE_ATRAC },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR9, HDMI_AUDIO_CODING_TYPE_EAC3 },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR10, HDMI_AUDIO_CODING_TYPE_DTS_HD },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR11, HDMI_AUDIO_CODING_TYPE_MLP },\n\t\t{ AZ_F0_CODEC_PIN0_CONTROL_AUDIO_DESCRIPTOR13, HDMI_AUDIO_CODING_TYPE_WMA_PRO },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(eld_reg_to_type); i++) {\n\t\tu32 value = 0;\n\t\tu8 stereo_freqs = 0;\n\t\tint max_channels = -1;\n\t\tint j;\n\n\t\tfor (j = 0; j < sad_count; j++) {\n\t\t\tstruct cea_sad *sad = &sads[j];\n\n\t\t\tif (sad->format == eld_reg_to_type[i][1]) {\n\t\t\t\tif (sad->channels > max_channels) {\n\t\t\t\t\tvalue = MAX_CHANNELS(sad->channels) |\n\t\t\t\t\t\tDESCRIPTOR_BYTE_2(sad->byte2) |\n\t\t\t\t\t\tSUPPORTED_FREQUENCIES(sad->freq);\n\t\t\t\t\tmax_channels = sad->channels;\n\t\t\t\t}\n\n\t\t\t\tif (sad->format == HDMI_AUDIO_CODING_TYPE_PCM)\n\t\t\t\t\tstereo_freqs |= sad->freq;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvalue |= SUPPORTED_FREQUENCIES_STEREO(stereo_freqs);\n\n\t\tWREG32_ENDPOINT(0, eld_reg_to_type[i][0], value);\n\t}\n}\n\nvoid dce3_2_audio_set_dto(struct radeon_device *rdev,\n\tstruct radeon_crtc *crtc, unsigned int clock)\n{\n\tstruct radeon_encoder *radeon_encoder;\n\tstruct radeon_encoder_atom_dig *dig;\n\tunsigned int max_ratio = clock / 24000;\n\tu32 dto_phase;\n\tu32 wallclock_ratio;\n\tu32 dto_cntl;\n\n\tif (!crtc)\n\t\treturn;\n\n\tradeon_encoder = to_radeon_encoder(crtc->encoder);\n\tdig = radeon_encoder->enc_priv;\n\n\tif (!dig)\n\t\treturn;\n\n\tif (max_ratio >= 8) {\n\t\tdto_phase = 192 * 1000;\n\t\twallclock_ratio = 3;\n\t} else if (max_ratio >= 4) {\n\t\tdto_phase = 96 * 1000;\n\t\twallclock_ratio = 2;\n\t} else if (max_ratio >= 2) {\n\t\tdto_phase = 48 * 1000;\n\t\twallclock_ratio = 1;\n\t} else {\n\t\tdto_phase = 24 * 1000;\n\t\twallclock_ratio = 0;\n\t}\n\n\t \n\tif (dig->dig_encoder == 0) {\n\t\tdto_cntl = RREG32(DCCG_AUDIO_DTO0_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\n\t\tdto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\n\t\tWREG32(DCCG_AUDIO_DTO0_CNTL, dto_cntl);\n\t\tWREG32(DCCG_AUDIO_DTO0_PHASE, dto_phase);\n\t\tWREG32(DCCG_AUDIO_DTO0_MODULE, clock);\n\t\tWREG32(DCCG_AUDIO_DTO_SELECT, 0);  \n\t} else {\n\t\tdto_cntl = RREG32(DCCG_AUDIO_DTO1_CNTL) & ~DCCG_AUDIO_DTO_WALLCLOCK_RATIO_MASK;\n\t\tdto_cntl |= DCCG_AUDIO_DTO_WALLCLOCK_RATIO(wallclock_ratio);\n\t\tWREG32(DCCG_AUDIO_DTO1_CNTL, dto_cntl);\n\t\tWREG32(DCCG_AUDIO_DTO1_PHASE, dto_phase);\n\t\tWREG32(DCCG_AUDIO_DTO1_MODULE, clock);\n\t\tWREG32(DCCG_AUDIO_DTO_SELECT, 1);  \n\t}\n}\n\nvoid dce3_2_hdmi_update_acr(struct drm_encoder *encoder, long offset,\n\tconst struct radeon_hdmi_acr *acr)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tWREG32(DCE3_HDMI0_ACR_PACKET_CONTROL + offset,\n\t\tHDMI0_ACR_SOURCE |\t\t \n\t\tHDMI0_ACR_AUTO_SEND);\t \n\n\tWREG32_P(HDMI0_ACR_32_0 + offset,\n\t\tHDMI0_ACR_CTS_32(acr->cts_32khz),\n\t\t~HDMI0_ACR_CTS_32_MASK);\n\tWREG32_P(HDMI0_ACR_32_1 + offset,\n\t\tHDMI0_ACR_N_32(acr->n_32khz),\n\t\t~HDMI0_ACR_N_32_MASK);\n\n\tWREG32_P(HDMI0_ACR_44_0 + offset,\n\t\tHDMI0_ACR_CTS_44(acr->cts_44_1khz),\n\t\t~HDMI0_ACR_CTS_44_MASK);\n\tWREG32_P(HDMI0_ACR_44_1 + offset,\n\t\tHDMI0_ACR_N_44(acr->n_44_1khz),\n\t\t~HDMI0_ACR_N_44_MASK);\n\n\tWREG32_P(HDMI0_ACR_48_0 + offset,\n\t\tHDMI0_ACR_CTS_48(acr->cts_48khz),\n\t\t~HDMI0_ACR_CTS_48_MASK);\n\tWREG32_P(HDMI0_ACR_48_1 + offset,\n\t\tHDMI0_ACR_N_48(acr->n_48khz),\n\t\t~HDMI0_ACR_N_48_MASK);\n}\n\nvoid dce3_2_set_audio_packet(struct drm_encoder *encoder, u32 offset)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tWREG32(HDMI0_AUDIO_PACKET_CONTROL + offset,\n\t\tHDMI0_AUDIO_DELAY_EN(1) |\t\t\t \n\t\tHDMI0_AUDIO_PACKETS_PER_LINE(3));\t \n\n\tWREG32(AFMT_AUDIO_PACKET_CONTROL + offset,\n\t\tAFMT_AUDIO_SAMPLE_SEND |\t\t\t \n\t\tAFMT_60958_CS_UPDATE);\t\t\t\t \n\n\tWREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,\n\t\tHDMI0_AUDIO_INFO_SEND |\t\t\t\t \n\t\tHDMI0_AUDIO_INFO_CONT);\t\t\t\t \n\n\tWREG32_OR(HDMI0_INFOFRAME_CONTROL1 + offset,\n\t\tHDMI0_AUDIO_INFO_LINE(2));\t\t\t \n}\n\nvoid dce3_2_set_mute(struct drm_encoder *encoder, u32 offset, bool mute)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (mute)\n\t\tWREG32_OR(HDMI0_GC + offset, HDMI0_GC_AVMUTE);\n\telse\n\t\tWREG32_AND(HDMI0_GC + offset, ~HDMI0_GC_AVMUTE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}