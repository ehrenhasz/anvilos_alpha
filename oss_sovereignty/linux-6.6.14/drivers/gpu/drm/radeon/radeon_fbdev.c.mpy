{
  "module_name": "radeon_fbdev.c",
  "hash_id": "90ca19ddebe93fd0005e2b2f28466de30d1330e04bdd7ae4500294b89907b7f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_fbdev.c",
  "human_readable_source": " \n\n#include <linux/fb.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"radeon.h\"\n\nstatic void radeon_fbdev_destroy_pinned_object(struct drm_gem_object *gobj)\n{\n\tstruct radeon_bo *rbo = gem_to_radeon_bo(gobj);\n\tint ret;\n\n\tret = radeon_bo_reserve(rbo, false);\n\tif (likely(ret == 0)) {\n\t\tradeon_bo_kunmap(rbo);\n\t\tradeon_bo_unpin(rbo);\n\t\tradeon_bo_unreserve(rbo);\n\t}\n\tdrm_gem_object_put(gobj);\n}\n\nstatic int radeon_fbdev_create_pinned_object(struct drm_fb_helper *fb_helper,\n\t\t\t\t\t     struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\t\t\t     struct drm_gem_object **gobj_p)\n{\n\tconst struct drm_format_info *info;\n\tstruct radeon_device *rdev = fb_helper->dev->dev_private;\n\tstruct drm_gem_object *gobj = NULL;\n\tstruct radeon_bo *rbo = NULL;\n\tbool fb_tiled = false;  \n\tu32 tiling_flags = 0;\n\tint ret;\n\tint aligned_size, size;\n\tint height = mode_cmd->height;\n\tu32 cpp;\n\n\tinfo = drm_get_format_info(rdev->ddev, mode_cmd);\n\tcpp = info->cpp[0];\n\n\t \n\tmode_cmd->pitches[0] = radeon_align_pitch(rdev, mode_cmd->width, cpp,\n\t\t\t\t\t\t  fb_tiled);\n\n\tif (rdev->family >= CHIP_R600)\n\t\theight = ALIGN(mode_cmd->height, 8);\n\tsize = mode_cmd->pitches[0] * height;\n\taligned_size = ALIGN(size, PAGE_SIZE);\n\tret = radeon_gem_object_create(rdev, aligned_size, 0,\n\t\t\t\t       RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t       0, true, &gobj);\n\tif (ret) {\n\t\tpr_err(\"failed to allocate framebuffer (%d)\\n\", aligned_size);\n\t\treturn -ENOMEM;\n\t}\n\trbo = gem_to_radeon_bo(gobj);\n\n\tif (fb_tiled)\n\t\ttiling_flags = RADEON_TILING_MACRO;\n\n#ifdef __BIG_ENDIAN\n\tswitch (cpp) {\n\tcase 4:\n\t\ttiling_flags |= RADEON_TILING_SWAP_32BIT;\n\t\tbreak;\n\tcase 2:\n\t\ttiling_flags |= RADEON_TILING_SWAP_16BIT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\n\tif (tiling_flags) {\n\t\tret = radeon_bo_set_tiling_flags(rbo,\n\t\t\t\t\t\t tiling_flags | RADEON_TILING_SURFACE,\n\t\t\t\t\t\t mode_cmd->pitches[0]);\n\t\tif (ret)\n\t\t\tdev_err(rdev->dev, \"FB failed to set tiling flags\\n\");\n\t}\n\n\tret = radeon_bo_reserve(rbo, false);\n\tif (unlikely(ret != 0))\n\t\tgoto err_radeon_fbdev_destroy_pinned_object;\n\t \n\tret = radeon_bo_pin_restricted(rbo, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t\t       ASIC_IS_AVIVO(rdev) ? 0 : 1 << 27,\n\t\t\t\t       NULL);\n\tif (ret) {\n\t\tradeon_bo_unreserve(rbo);\n\t\tgoto err_radeon_fbdev_destroy_pinned_object;\n\t}\n\tif (fb_tiled)\n\t\tradeon_bo_check_tiling(rbo, 0, 0);\n\tret = radeon_bo_kmap(rbo, NULL);\n\tradeon_bo_unreserve(rbo);\n\tif (ret)\n\t\tgoto err_radeon_fbdev_destroy_pinned_object;\n\n\t*gobj_p = gobj;\n\treturn 0;\n\nerr_radeon_fbdev_destroy_pinned_object:\n\tradeon_fbdev_destroy_pinned_object(gobj);\n\t*gobj_p = NULL;\n\treturn ret;\n}\n\n \n\nstatic int radeon_fbdev_fb_open(struct fb_info *info, int user)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct radeon_device *rdev = fb_helper->dev->dev_private;\n\tint ret;\n\n\tret = pm_runtime_get_sync(rdev->ddev->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\tgoto err_pm_runtime_mark_last_busy;\n\n\treturn 0;\n\nerr_pm_runtime_mark_last_busy:\n\tpm_runtime_mark_last_busy(rdev->ddev->dev);\n\tpm_runtime_put_autosuspend(rdev->ddev->dev);\n\treturn ret;\n}\n\nstatic int radeon_fbdev_fb_release(struct fb_info *info, int user)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct radeon_device *rdev = fb_helper->dev->dev_private;\n\n\tpm_runtime_mark_last_busy(rdev->ddev->dev);\n\tpm_runtime_put_autosuspend(rdev->ddev->dev);\n\n\treturn 0;\n}\n\nstatic void radeon_fbdev_fb_destroy(struct fb_info *info)\n{\n\tstruct drm_fb_helper *fb_helper = info->par;\n\tstruct drm_framebuffer *fb = fb_helper->fb;\n\tstruct drm_gem_object *gobj = drm_gem_fb_get_obj(fb, 0);\n\n\tdrm_fb_helper_fini(fb_helper);\n\n\tdrm_framebuffer_unregister_private(fb);\n\tdrm_framebuffer_cleanup(fb);\n\tkfree(fb);\n\tradeon_fbdev_destroy_pinned_object(gobj);\n\n\tdrm_client_release(&fb_helper->client);\n\tdrm_fb_helper_unprepare(fb_helper);\n\tkfree(fb_helper);\n}\n\nstatic const struct fb_ops radeon_fbdev_fb_ops = {\n\t.owner = THIS_MODULE,\n\t.fb_open = radeon_fbdev_fb_open,\n\t.fb_release = radeon_fbdev_fb_release,\n\tFB_DEFAULT_IOMEM_OPS,\n\tDRM_FB_HELPER_DEFAULT_OPS,\n\t.fb_destroy = radeon_fbdev_fb_destroy,\n};\n\n \n\nstatic int radeon_fbdev_fb_helper_fb_probe(struct drm_fb_helper *fb_helper,\n\t\t\t\t\t   struct drm_fb_helper_surface_size *sizes)\n{\n\tstruct radeon_device *rdev = fb_helper->dev->dev_private;\n\tstruct drm_mode_fb_cmd2 mode_cmd = { };\n\tstruct fb_info *info;\n\tstruct drm_gem_object *gobj;\n\tstruct radeon_bo *rbo;\n\tstruct drm_framebuffer *fb;\n\tint ret;\n\tunsigned long tmp;\n\n\tmode_cmd.width = sizes->surface_width;\n\tmode_cmd.height = sizes->surface_height;\n\n\t \n\tif ((sizes->surface_bpp == 24) && ASIC_IS_AVIVO(rdev))\n\t\tsizes->surface_bpp = 32;\n\n\tmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\n\t\t\t\t\t\t\t  sizes->surface_depth);\n\n\tret = radeon_fbdev_create_pinned_object(fb_helper, &mode_cmd, &gobj);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to create fbcon object %d\\n\", ret);\n\t\treturn ret;\n\t}\n\trbo = gem_to_radeon_bo(gobj);\n\n\tfb = kzalloc(sizeof(*fb), GFP_KERNEL);\n\tif (!fb) {\n\t\tret = -ENOMEM;\n\t\tgoto err_radeon_fbdev_destroy_pinned_object;\n\t}\n\tret = radeon_framebuffer_init(rdev->ddev, fb, &mode_cmd, gobj);\n\tif (ret) {\n\t\tDRM_ERROR(\"failed to initialize framebuffer %d\\n\", ret);\n\t\tgoto err_kfree;\n\t}\n\n\t \n\tfb_helper->fb = fb;\n\n\t \n\tinfo = drm_fb_helper_alloc_info(fb_helper);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto err_drm_framebuffer_unregister_private;\n\t}\n\n\tinfo->fbops = &radeon_fbdev_fb_ops;\n\n\t \n\tinfo->skip_vt_switch = false;\n\n\tdrm_fb_helper_fill_info(info, fb_helper, sizes);\n\n\ttmp = radeon_bo_gpu_offset(rbo) - rdev->mc.vram_start;\n\tinfo->fix.smem_start = rdev->mc.aper_base + tmp;\n\tinfo->fix.smem_len = radeon_bo_size(rbo);\n\tinfo->screen_base = (__force void __iomem *)rbo->kptr;\n\tinfo->screen_size = radeon_bo_size(rbo);\n\n\tmemset_io(info->screen_base, 0, info->screen_size);\n\n\t \n\n\tDRM_INFO(\"fb mappable at 0x%lX\\n\",  info->fix.smem_start);\n\tDRM_INFO(\"vram apper at 0x%lX\\n\",  (unsigned long)rdev->mc.aper_base);\n\tDRM_INFO(\"size %lu\\n\", (unsigned long)radeon_bo_size(rbo));\n\tDRM_INFO(\"fb depth is %d\\n\", fb->format->depth);\n\tDRM_INFO(\"   pitch is %d\\n\", fb->pitches[0]);\n\n\treturn 0;\n\nerr_drm_framebuffer_unregister_private:\n\tfb_helper->fb = NULL;\n\tdrm_framebuffer_unregister_private(fb);\n\tdrm_framebuffer_cleanup(fb);\nerr_kfree:\n\tkfree(fb);\nerr_radeon_fbdev_destroy_pinned_object:\n\tradeon_fbdev_destroy_pinned_object(gobj);\n\treturn ret;\n}\n\nstatic const struct drm_fb_helper_funcs radeon_fbdev_fb_helper_funcs = {\n\t.fb_probe = radeon_fbdev_fb_helper_fb_probe,\n};\n\n \n\nstatic void radeon_fbdev_client_unregister(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = fb_helper->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (fb_helper->info) {\n\t\tvga_switcheroo_client_fb_set(rdev->pdev, NULL);\n\t\tdrm_helper_force_disable_all(dev);\n\t\tdrm_fb_helper_unregister_info(fb_helper);\n\t} else {\n\t\tdrm_client_release(&fb_helper->client);\n\t\tdrm_fb_helper_unprepare(fb_helper);\n\t\tkfree(fb_helper);\n\t}\n}\n\nstatic int radeon_fbdev_client_restore(struct drm_client_dev *client)\n{\n\tdrm_fb_helper_lastclose(client->dev);\n\tvga_switcheroo_process_delayed_switch();\n\n\treturn 0;\n}\n\nstatic int radeon_fbdev_client_hotplug(struct drm_client_dev *client)\n{\n\tstruct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);\n\tstruct drm_device *dev = client->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tint ret;\n\n\tif (dev->fb_helper)\n\t\treturn drm_fb_helper_hotplug_event(dev->fb_helper);\n\n\tret = drm_fb_helper_init(dev, fb_helper);\n\tif (ret)\n\t\tgoto err_drm_err;\n\n\tif (!drm_drv_uses_atomic_modeset(dev))\n\t\tdrm_helper_disable_unused_functions(dev);\n\n\tret = drm_fb_helper_initial_config(fb_helper);\n\tif (ret)\n\t\tgoto err_drm_fb_helper_fini;\n\n\tvga_switcheroo_client_fb_set(rdev->pdev, fb_helper->info);\n\n\treturn 0;\n\nerr_drm_fb_helper_fini:\n\tdrm_fb_helper_fini(fb_helper);\nerr_drm_err:\n\tdrm_err(dev, \"Failed to setup radeon fbdev emulation (ret=%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct drm_client_funcs radeon_fbdev_client_funcs = {\n\t.owner\t\t= THIS_MODULE,\n\t.unregister\t= radeon_fbdev_client_unregister,\n\t.restore\t= radeon_fbdev_client_restore,\n\t.hotplug\t= radeon_fbdev_client_hotplug,\n};\n\nvoid radeon_fbdev_setup(struct radeon_device *rdev)\n{\n\tstruct drm_fb_helper *fb_helper;\n\tint bpp_sel = 32;\n\tint ret;\n\n\tif (rdev->mc.real_vram_size <= (8 * 1024 * 1024))\n\t\tbpp_sel = 8;\n\telse if (ASIC_IS_RN50(rdev) || rdev->mc.real_vram_size <= (32 * 1024 * 1024))\n\t\tbpp_sel = 16;\n\n\tfb_helper = kzalloc(sizeof(*fb_helper), GFP_KERNEL);\n\tif (!fb_helper)\n\t\treturn;\n\tdrm_fb_helper_prepare(rdev->ddev, fb_helper, bpp_sel, &radeon_fbdev_fb_helper_funcs);\n\n\tret = drm_client_init(rdev->ddev, &fb_helper->client, \"radeon-fbdev\",\n\t\t\t      &radeon_fbdev_client_funcs);\n\tif (ret) {\n\t\tdrm_err(rdev->ddev, \"Failed to register client: %d\\n\", ret);\n\t\tgoto err_drm_client_init;\n\t}\n\n\tdrm_client_register(&fb_helper->client);\n\n\treturn;\n\nerr_drm_client_init:\n\tdrm_fb_helper_unprepare(fb_helper);\n\tkfree(fb_helper);\n}\n\nvoid radeon_fbdev_set_suspend(struct radeon_device *rdev, int state)\n{\n\tif (rdev->ddev->fb_helper)\n\t\tdrm_fb_helper_set_suspend(rdev->ddev->fb_helper, state);\n}\n\nbool radeon_fbdev_robj_is_fb(struct radeon_device *rdev, struct radeon_bo *robj)\n{\n\tstruct drm_fb_helper *fb_helper = rdev->ddev->fb_helper;\n\tstruct drm_gem_object *gobj;\n\n\tif (!fb_helper)\n\t\treturn false;\n\n\tgobj = drm_gem_fb_get_obj(fb_helper->fb, 0);\n\tif (!gobj)\n\t\treturn false;\n\tif (gobj != &robj->tbo.base)\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}