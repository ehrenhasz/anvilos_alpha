{
  "module_name": "rv770_dpm.c",
  "hash_id": "4770b3cfe34b6d6456575af2057af137f773eab8747ed1f38e51ef8d0fe0e211",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rv770_dpm.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"rv770.h\"\n#include \"rv770d.h\"\n#include \"r600_dpm.h\"\n#include \"rv770_dpm.h\"\n#include \"cypress_dpm.h\"\n#include \"atom.h\"\n#include \"evergreen.h\"\n#include <linux/seq_file.h>\n\n#define MC_CG_ARB_FREQ_F0           0x0a\n#define MC_CG_ARB_FREQ_F1           0x0b\n#define MC_CG_ARB_FREQ_F2           0x0c\n#define MC_CG_ARB_FREQ_F3           0x0d\n\n#define MC_CG_SEQ_DRAMCONF_S0       0x05\n#define MC_CG_SEQ_DRAMCONF_S1       0x06\n\n#define PCIE_BUS_CLK                10000\n#define TCLK                        (PCIE_BUS_CLK / 10)\n\n#define SMC_RAM_END 0xC000\n\nstruct rv7xx_ps *rv770_get_ps(struct radeon_ps *rps)\n{\n\tstruct rv7xx_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstruct rv7xx_power_info *rv770_get_pi(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstruct evergreen_power_info *evergreen_get_pi(struct radeon_device *rdev)\n{\n\tstruct evergreen_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic void rv770_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t       bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\tif (enable) {\n\t\ttmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\t\ttmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\n\t\ttmp |= LC_GEN2_EN_STRAP;\n\t} else {\n\t\tif (!pi->boot_in_gen2) {\n\t\t\ttmp &= ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\t\t\ttmp &= ~LC_GEN2_EN_STRAP;\n\t\t}\n\t}\n\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) ||\n\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\n}\n\nstatic void rv770_enable_l0s(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L0S_INACTIVITY_MASK;\n\ttmp |= LC_L0S_INACTIVITY(3);\n\tWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\n}\n\nstatic void rv770_enable_l1(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\ttmp &= ~LC_L1_INACTIVITY_MASK;\n\ttmp |= LC_L1_INACTIVITY(4);\n\ttmp &= ~LC_PMI_TO_L1_DIS;\n\ttmp &= ~LC_ASPM_TO_L1_DIS;\n\tWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\n}\n\nstatic void rv770_enable_pll_sleep_in_l1(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L1_INACTIVITY_MASK;\n\ttmp |= LC_L1_INACTIVITY(8);\n\tWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\n\n\t \n\ttmp = RREG32_PCIE(PCIE_P_CNTL);\n\ttmp |= P_PLL_PWRDN_IN_L1L23;\n\ttmp &= ~P_PLL_BUF_PDNB;\n\ttmp &= ~P_PLL_PDNB;\n\ttmp |= P_ALLOW_PRX_FRONTEND_SHUTOFF;\n\tWREG32_PCIE(PCIE_P_CNTL, tmp);\n}\n\nstatic void rv770_gfx_clock_gating_enable(struct radeon_device *rdev,\n\t\t\t\t\t  bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\n\telse {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\t\tRREG32(GB_TILING_CONFIG);\n\t}\n}\n\nstatic void rv770_mg_clock_gating_enable(struct radeon_device *rdev,\n\t\t\t\t\t bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (enable) {\n\t\tu32 mgcg_cgtt_local0;\n\n\t\tif (rdev->family == CHIP_RV770)\n\t\t\tmgcg_cgtt_local0 = RV770_MGCGTTLOCAL0_DFLT;\n\t\telse\n\t\t\tmgcg_cgtt_local0 = RV7XX_MGCGTTLOCAL0_DFLT;\n\n\t\tWREG32(CG_CGTT_LOCAL_0, mgcg_cgtt_local0);\n\t\tWREG32(CG_CGTT_LOCAL_1, (RV770_MGCGTTLOCAL1_DFLT & 0xFFFFCFFF));\n\n\t\tif (pi->mgcgtssm)\n\t\t\tWREG32(CGTS_SM_CTRL_REG, RV770_MGCGCGTSSMCTRL_DFLT);\n\t} else {\n\t\tWREG32(CG_CGTT_LOCAL_0, 0xFFFFFFFF);\n\t\tWREG32(CG_CGTT_LOCAL_1, 0xFFFFCFFF);\n\t}\n}\n\nvoid rv770_restore_cgcg(struct radeon_device *rdev)\n{\n\tbool dpm_en = false, cg_en = false;\n\n\tif (RREG32(GENERAL_PWRMGT) & GLOBAL_PWRMGT_EN)\n\t\tdpm_en = true;\n\tif (RREG32(SCLK_PWRMGT_CNTL) & DYN_GFX_CLK_OFF_EN)\n\t\tcg_en = true;\n\n\tif (dpm_en && !cg_en)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\n}\n\nstatic void rv770_start_dpm(struct radeon_device *rdev)\n{\n\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~SCLK_PWRMGT_OFF);\n\n\tWREG32_P(MCLK_PWRMGT_CNTL, 0, ~MPLL_PWRMGT_OFF);\n\n\tWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\n}\n\nvoid rv770_stop_dpm(struct radeon_device *rdev)\n{\n\tPPSMC_Result result;\n\n\tresult = rv770_send_msg_to_smc(rdev, PPSMC_MSG_TwoLevelsDisabled);\n\n\tif (result != PPSMC_Result_OK)\n\t\tDRM_DEBUG(\"Could not force DPM to low.\\n\");\n\n\tWREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);\n\n\tWREG32_P(SCLK_PWRMGT_CNTL, SCLK_PWRMGT_OFF, ~SCLK_PWRMGT_OFF);\n\n\tWREG32_P(MCLK_PWRMGT_CNTL, MPLL_PWRMGT_OFF, ~MPLL_PWRMGT_OFF);\n}\n\nbool rv770_dpm_enabled(struct radeon_device *rdev)\n{\n\tif (RREG32(GENERAL_PWRMGT) & GLOBAL_PWRMGT_EN)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nvoid rv770_enable_thermal_protection(struct radeon_device *rdev,\n\t\t\t\t     bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\n}\n\nvoid rv770_enable_acpi_pm(struct radeon_device *rdev)\n{\n\tWREG32_P(GENERAL_PWRMGT, STATIC_PM_EN, ~STATIC_PM_EN);\n}\n\nu8 rv770_get_seq_value(struct radeon_device *rdev,\n\t\t       struct rv7xx_pl *pl)\n{\n\treturn (pl->flags & ATOM_PPLIB_R600_FLAGS_LOWPOWER) ?\n\t\tMC_CG_SEQ_DRAMCONF_S0 : MC_CG_SEQ_DRAMCONF_S1;\n}\n\n#if 0\nint rv770_read_smc_soft_register(struct radeon_device *rdev,\n\t\t\t\t u16 reg_offset, u32 *value)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\treturn rv770_read_smc_sram_dword(rdev,\n\t\t\t\t\t pi->soft_regs_start + reg_offset,\n\t\t\t\t\t value, pi->sram_end);\n}\n#endif\n\nint rv770_write_smc_soft_register(struct radeon_device *rdev,\n\t\t\t\t  u16 reg_offset, u32 value)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\treturn rv770_write_smc_sram_dword(rdev,\n\t\t\t\t\t  pi->soft_regs_start + reg_offset,\n\t\t\t\t\t  value, pi->sram_end);\n}\n\nint rv770_populate_smc_t(struct radeon_device *rdev,\n\t\t\t struct radeon_ps *radeon_state,\n\t\t\t RV770_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint i;\n\tint a_n;\n\tint a_d;\n\tu8 l[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE];\n\tu8 r[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE];\n\tu32 a_t;\n\n\tl[0] = 0;\n\tr[2] = 100;\n\n\ta_n = (int)state->medium.sclk * pi->lmp +\n\t\t(int)state->low.sclk * (R600_AH_DFLT - pi->rlp);\n\ta_d = (int)state->low.sclk * (100 - (int)pi->rlp) +\n\t\t(int)state->medium.sclk * pi->lmp;\n\n\tl[1] = (u8)(pi->lmp - (int)pi->lmp * a_n / a_d);\n\tr[0] = (u8)(pi->rlp + (100 - (int)pi->rlp) * a_n / a_d);\n\n\ta_n = (int)state->high.sclk * pi->lhp + (int)state->medium.sclk *\n\t\t(R600_AH_DFLT - pi->rmp);\n\ta_d = (int)state->medium.sclk * (100 - (int)pi->rmp) +\n\t\t(int)state->high.sclk * pi->lhp;\n\n\tl[2] = (u8)(pi->lhp - (int)pi->lhp * a_n / a_d);\n\tr[1] = (u8)(pi->rmp + (100 - (int)pi->rmp) * a_n / a_d);\n\n\tfor (i = 0; i < (RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1); i++) {\n\t\ta_t = CG_R(r[i] * pi->bsp / 200) | CG_L(l[i] * pi->bsp / 200);\n\t\tsmc_state->levels[i].aT = cpu_to_be32(a_t);\n\t}\n\n\ta_t = CG_R(r[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1] * pi->pbsp / 200) |\n\t\tCG_L(l[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1] * pi->pbsp / 200);\n\n\tsmc_state->levels[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1].aT =\n\t\tcpu_to_be32(a_t);\n\n\treturn 0;\n}\n\nint rv770_populate_smc_sp(struct radeon_device *rdev,\n\t\t\t  struct radeon_ps *radeon_state,\n\t\t\t  RV770_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint i;\n\n\tfor (i = 0; i < (RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1); i++)\n\t\tsmc_state->levels[i].bSP = cpu_to_be32(pi->dsp);\n\n\tsmc_state->levels[RV770_SMC_PERFORMANCE_LEVELS_PER_SWSTATE - 1].bSP =\n\t\tcpu_to_be32(pi->psp);\n\n\treturn 0;\n}\n\nstatic void rv770_calculate_fractional_mpll_feedback_divider(u32 memory_clock,\n\t\t\t\t\t\t\t     u32 reference_clock,\n\t\t\t\t\t\t\t     bool gddr5,\n\t\t\t\t\t\t\t     struct atom_clock_dividers *dividers,\n\t\t\t\t\t\t\t     u32 *clkf,\n\t\t\t\t\t\t\t     u32 *clkfrac)\n{\n\tu32 post_divider, reference_divider, feedback_divider8;\n\tu32 fyclk;\n\n\tif (gddr5)\n\t\tfyclk = (memory_clock * 8) / 2;\n\telse\n\t\tfyclk = (memory_clock * 4) / 2;\n\n\tpost_divider = dividers->post_div;\n\treference_divider = dividers->ref_div;\n\n\tfeedback_divider8 =\n\t\t(8 * fyclk * reference_divider * post_divider) / reference_clock;\n\n\t*clkf = feedback_divider8 / 8;\n\t*clkfrac = feedback_divider8 % 8;\n}\n\nstatic int rv770_encode_yclk_post_div(u32 postdiv, u32 *encoded_postdiv)\n{\n\tint ret = 0;\n\n\tswitch (postdiv) {\n\tcase 1:\n\t\t*encoded_postdiv = 0;\n\t\tbreak;\n\tcase 2:\n\t\t*encoded_postdiv = 1;\n\t\tbreak;\n\tcase 4:\n\t\t*encoded_postdiv = 2;\n\t\tbreak;\n\tcase 8:\n\t\t*encoded_postdiv = 3;\n\t\tbreak;\n\tcase 16:\n\t\t*encoded_postdiv = 4;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nu32 rv770_map_clkf_to_ibias(struct radeon_device *rdev, u32 clkf)\n{\n\tif (clkf <= 0x10)\n\t\treturn 0x4B;\n\tif (clkf <= 0x19)\n\t\treturn 0x5B;\n\tif (clkf <= 0x21)\n\t\treturn 0x2B;\n\tif (clkf <= 0x27)\n\t\treturn 0x6C;\n\tif (clkf <= 0x31)\n\t\treturn 0x9D;\n\treturn 0xC6;\n}\n\nstatic int rv770_populate_mclk_value(struct radeon_device *rdev,\n\t\t\t\t     u32 engine_clock, u32 memory_clock,\n\t\t\t\t     RV7XX_SMC_MCLK_VALUE *mclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu8 encoded_reference_dividers[] = { 0, 16, 17, 20, 21 };\n\tu32 mpll_ad_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl_2;\n\tu32 mclk_pwrmgt_cntl =\n\t\tpi->clk_regs.rv770.mclk_pwrmgt_cntl;\n\tu32 dll_cntl = pi->clk_regs.rv770.dll_cntl;\n\tstruct atom_clock_dividers dividers;\n\tu32 reference_clock = rdev->clock.mpll.reference_freq;\n\tu32 clkf, clkfrac;\n\tu32 postdiv_yclk;\n\tu32 ibias;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\n\t\t\t\t\t     memory_clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((dividers.ref_div < 1) || (dividers.ref_div > 5))\n\t\treturn -EINVAL;\n\n\trv770_calculate_fractional_mpll_feedback_divider(memory_clock, reference_clock,\n\t\t\t\t\t\t\t pi->mem_gddr5,\n\t\t\t\t\t\t\t &dividers, &clkf, &clkfrac);\n\n\tret = rv770_encode_yclk_post_div(dividers.post_div, &postdiv_yclk);\n\tif (ret)\n\t\treturn ret;\n\n\tibias = rv770_map_clkf_to_ibias(rdev, clkf);\n\n\tmpll_ad_func_cntl &= ~(CLKR_MASK |\n\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t       CLKF_MASK |\n\t\t\t       CLKFRAC_MASK |\n\t\t\t       IBIAS_MASK);\n\tmpll_ad_func_cntl |= CLKR(encoded_reference_dividers[dividers.ref_div - 1]);\n\tmpll_ad_func_cntl |= YCLK_POST_DIV(postdiv_yclk);\n\tmpll_ad_func_cntl |= CLKF(clkf);\n\tmpll_ad_func_cntl |= CLKFRAC(clkfrac);\n\tmpll_ad_func_cntl |= IBIAS(ibias);\n\n\tif (dividers.vco_mode)\n\t\tmpll_ad_func_cntl_2 |= VCO_MODE;\n\telse\n\t\tmpll_ad_func_cntl_2 &= ~VCO_MODE;\n\n\tif (pi->mem_gddr5) {\n\t\trv770_calculate_fractional_mpll_feedback_divider(memory_clock,\n\t\t\t\t\t\t\t\t reference_clock,\n\t\t\t\t\t\t\t\t pi->mem_gddr5,\n\t\t\t\t\t\t\t\t &dividers, &clkf, &clkfrac);\n\n\t\tibias = rv770_map_clkf_to_ibias(rdev, clkf);\n\n\t\tret = rv770_encode_yclk_post_div(dividers.post_div, &postdiv_yclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmpll_dq_func_cntl &= ~(CLKR_MASK |\n\t\t\t\t       YCLK_POST_DIV_MASK |\n\t\t\t\t       CLKF_MASK |\n\t\t\t\t       CLKFRAC_MASK |\n\t\t\t\t       IBIAS_MASK);\n\t\tmpll_dq_func_cntl |= CLKR(encoded_reference_dividers[dividers.ref_div - 1]);\n\t\tmpll_dq_func_cntl |= YCLK_POST_DIV(postdiv_yclk);\n\t\tmpll_dq_func_cntl |= CLKF(clkf);\n\t\tmpll_dq_func_cntl |= CLKFRAC(clkfrac);\n\t\tmpll_dq_func_cntl |= IBIAS(ibias);\n\n\t\tif (dividers.vco_mode)\n\t\t\tmpll_dq_func_cntl_2 |= VCO_MODE;\n\t\telse\n\t\t\tmpll_dq_func_cntl_2 &= ~VCO_MODE;\n\t}\n\n\tmclk->mclk770.mclk_value = cpu_to_be32(memory_clock);\n\tmclk->mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\tmclk->mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\tmclk->mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\tmclk->mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\tmclk->mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\tmclk->mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\n\treturn 0;\n}\n\nstatic int rv770_populate_sclk_value(struct radeon_device *rdev,\n\t\t\t\t     u32 engine_clock,\n\t\t\t\t     RV770_SMC_SCLK_VALUE *sclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct atom_clock_dividers dividers;\n\tu32 spll_func_cntl =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl_3;\n\tu32 cg_spll_spread_spectrum =\n\t\tpi->clk_regs.rv770.cg_spll_spread_spectrum;\n\tu32 cg_spll_spread_spectrum_2 =\n\t\tpi->clk_regs.rv770.cg_spll_spread_spectrum_2;\n\tu64 tmp;\n\tu32 reference_clock = rdev->clock.spll.reference_freq;\n\tu32 reference_divider, post_divider;\n\tu32 fbdiv;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     engine_clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\treference_divider = 1 + dividers.ref_div;\n\n\tif (dividers.enable_post_div)\n\t\tpost_divider = (0x0f & (dividers.post_div >> 4)) + (0x0f & dividers.post_div) + 2;\n\telse\n\t\tpost_divider = 1;\n\n\ttmp = (u64) engine_clock * reference_divider * post_divider * 16384;\n\tdo_div(tmp, reference_clock);\n\tfbdiv = (u32) tmp;\n\n\tif (dividers.enable_post_div)\n\t\tspll_func_cntl |= SPLL_DIVEN;\n\telse\n\t\tspll_func_cntl &= ~SPLL_DIVEN;\n\tspll_func_cntl &= ~(SPLL_HILEN_MASK | SPLL_LOLEN_MASK | SPLL_REF_DIV_MASK);\n\tspll_func_cntl |= SPLL_REF_DIV(dividers.ref_div);\n\tspll_func_cntl |= SPLL_HILEN((dividers.post_div >> 4) & 0xf);\n\tspll_func_cntl |= SPLL_LOLEN(dividers.post_div & 0xf);\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(2);\n\n\tspll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;\n\tspll_func_cntl_3 |= SPLL_FB_DIV(fbdiv);\n\tspll_func_cntl_3 |= SPLL_DITHEN;\n\n\tif (pi->sclk_ss) {\n\t\tstruct radeon_atom_ss ss;\n\t\tu32 vco_freq = engine_clock * post_divider;\n\n\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_ENGINE_SS, vco_freq)) {\n\t\t\tu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\n\t\t\tu32 clk_v = ss.percentage * fbdiv / (clk_s * 10000);\n\n\t\t\tcg_spll_spread_spectrum &= ~CLKS_MASK;\n\t\t\tcg_spll_spread_spectrum |= CLKS(clk_s);\n\t\t\tcg_spll_spread_spectrum |= SSEN;\n\n\t\t\tcg_spll_spread_spectrum_2 &= ~CLKV_MASK;\n\t\t\tcg_spll_spread_spectrum_2 |= CLKV(clk_v);\n\t\t}\n\t}\n\n\tsclk->sclk_value = cpu_to_be32(engine_clock);\n\tsclk->vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\n\tsclk->vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\n\tsclk->vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32(cg_spll_spread_spectrum);\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32(cg_spll_spread_spectrum_2);\n\n\treturn 0;\n}\n\nint rv770_populate_vddc_value(struct radeon_device *rdev, u16 vddc,\n\t\t\t      RV770_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint i;\n\n\tif (!pi->voltage_control) {\n\t\tvoltage->index = 0;\n\t\tvoltage->value = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < pi->valid_vddc_entries; i++) {\n\t\tif (vddc <= pi->vddc_table[i].vddc) {\n\t\t\tvoltage->index = pi->vddc_table[i].vddc_index;\n\t\t\tvoltage->value = cpu_to_be16(vddc);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == pi->valid_vddc_entries)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint rv770_populate_mvdd_value(struct radeon_device *rdev, u32 mclk,\n\t\t\t      RV770_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (!pi->mvdd_control) {\n\t\tvoltage->index = MVDD_HIGH_INDEX;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t\treturn 0;\n\t}\n\n\tif (mclk <= pi->mvdd_split_frequency) {\n\t\tvoltage->index = MVDD_LOW_INDEX;\n\t\tvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\n\t} else {\n\t\tvoltage->index = MVDD_HIGH_INDEX;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t}\n\n\treturn 0;\n}\n\nstatic int rv770_convert_power_level_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t    struct rv7xx_pl *pl,\n\t\t\t\t\t    RV770_SMC_HW_PERFORMANCE_LEVEL *level,\n\t\t\t\t\t    u8 watermark_level)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint ret;\n\n\tlevel->gen2PCIE = pi->pcie_gen2 ?\n\t\t((pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0) : 0;\n\tlevel->gen2XSP  = (pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? 1 : 0;\n\tlevel->backbias = (pl->flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? 1 : 0;\n\tlevel->displayWatermark = watermark_level;\n\n\tif (rdev->family == CHIP_RV740)\n\t\tret = rv740_populate_sclk_value(rdev, pl->sclk,\n\t\t\t\t\t\t&level->sclk);\n\telse if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\tret = rv730_populate_sclk_value(rdev, pl->sclk,\n\t\t\t\t\t\t&level->sclk);\n\telse\n\t\tret = rv770_populate_sclk_value(rdev, pl->sclk,\n\t\t\t\t\t\t&level->sclk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->family == CHIP_RV740) {\n\t\tif (pi->mem_gddr5) {\n\t\t\tif (pl->mclk <= pi->mclk_strobe_mode_threshold)\n\t\t\t\tlevel->strobeMode =\n\t\t\t\t\trv740_get_mclk_frequency_ratio(pl->mclk) | 0x10;\n\t\t\telse\n\t\t\t\tlevel->strobeMode = 0;\n\n\t\t\tif (pl->mclk > pi->mclk_edc_enable_threshold)\n\t\t\t\tlevel->mcFlags = SMC_MC_EDC_RD_FLAG | SMC_MC_EDC_WR_FLAG;\n\t\t\telse\n\t\t\t\tlevel->mcFlags =  0;\n\t\t}\n\t\tret = rv740_populate_mclk_value(rdev, pl->sclk,\n\t\t\t\t\t\tpl->mclk, &level->mclk);\n\t} else if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\tret = rv730_populate_mclk_value(rdev, pl->sclk,\n\t\t\t\t\t\tpl->mclk, &level->mclk);\n\telse\n\t\tret = rv770_populate_mclk_value(rdev, pl->sclk,\n\t\t\t\t\t\tpl->mclk, &level->mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv770_populate_vddc_value(rdev, pl->vddc,\n\t\t\t\t\t&level->vddc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv770_populate_mvdd_value(rdev, pl->mclk, &level->mvdd);\n\n\treturn ret;\n}\n\nstatic int rv770_convert_power_state_to_smc(struct radeon_device *rdev,\n\t\t\t\t\t    struct radeon_ps *radeon_state,\n\t\t\t\t\t    RV770_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\n\tint ret;\n\n\tif (!(radeon_state->caps & ATOM_PPLIB_DISALLOW_ON_DC))\n\t\tsmc_state->flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\tret = rv770_convert_power_level_to_smc(rdev,\n\t\t\t\t\t       &state->low,\n\t\t\t\t\t       &smc_state->levels[0],\n\t\t\t\t\t       PPSMC_DISPLAY_WATERMARK_LOW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv770_convert_power_level_to_smc(rdev,\n\t\t\t\t\t       &state->medium,\n\t\t\t\t\t       &smc_state->levels[1],\n\t\t\t\t\t       PPSMC_DISPLAY_WATERMARK_LOW);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv770_convert_power_level_to_smc(rdev,\n\t\t\t\t\t       &state->high,\n\t\t\t\t\t       &smc_state->levels[2],\n\t\t\t\t\t       PPSMC_DISPLAY_WATERMARK_HIGH);\n\tif (ret)\n\t\treturn ret;\n\n\tsmc_state->levels[0].arbValue = MC_CG_ARB_FREQ_F1;\n\tsmc_state->levels[1].arbValue = MC_CG_ARB_FREQ_F2;\n\tsmc_state->levels[2].arbValue = MC_CG_ARB_FREQ_F3;\n\n\tsmc_state->levels[0].seqValue = rv770_get_seq_value(rdev,\n\t\t\t\t\t\t\t    &state->low);\n\tsmc_state->levels[1].seqValue = rv770_get_seq_value(rdev,\n\t\t\t\t\t\t\t    &state->medium);\n\tsmc_state->levels[2].seqValue = rv770_get_seq_value(rdev,\n\t\t\t\t\t\t\t    &state->high);\n\n\trv770_populate_smc_sp(rdev, radeon_state, smc_state);\n\n\treturn rv770_populate_smc_t(rdev, radeon_state, smc_state);\n\n}\n\nu32 rv770_calculate_memory_refresh_rate(struct radeon_device *rdev,\n\t\t\t\t\tu32 engine_clock)\n{\n\tu32 dram_rows;\n\tu32 dram_refresh_rate;\n\tu32 mc_arb_rfsh_rate;\n\tu32 tmp;\n\n\ttmp = (RREG32(MC_ARB_RAMCFG) & NOOFROWS_MASK) >> NOOFROWS_SHIFT;\n\tdram_rows = 1 << (tmp + 10);\n\ttmp = RREG32(MC_SEQ_MISC0) & 3;\n\tdram_refresh_rate = 1 << (tmp + 3);\n\tmc_arb_rfsh_rate = ((engine_clock * 10) * dram_refresh_rate / dram_rows - 32) / 64;\n\n\treturn mc_arb_rfsh_rate;\n}\n\nstatic void rv770_program_memory_timing_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\t   struct radeon_ps *radeon_state)\n{\n\tstruct rv7xx_ps *state = rv770_get_ps(radeon_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 sqm_ratio;\n\tu32 arb_refresh_rate;\n\tu32 high_clock;\n\n\tif (state->high.sclk < (state->low.sclk * 0xFF / 0x40))\n\t\thigh_clock = state->high.sclk;\n\telse\n\t\thigh_clock = (state->low.sclk * 0xFF / 0x40);\n\n\tradeon_atom_set_engine_dram_timings(rdev, high_clock,\n\t\t\t\t\t    state->high.mclk);\n\n\tsqm_ratio =\n\t\tSTATE0(64 * high_clock / pi->boot_sclk) |\n\t\tSTATE1(64 * high_clock / state->low.sclk) |\n\t\tSTATE2(64 * high_clock / state->medium.sclk) |\n\t\tSTATE3(64 * high_clock / state->high.sclk);\n\tWREG32(MC_ARB_SQM_RATIO, sqm_ratio);\n\n\tarb_refresh_rate =\n\t\tPOWERMODE0(rv770_calculate_memory_refresh_rate(rdev, pi->boot_sclk)) |\n\t\tPOWERMODE1(rv770_calculate_memory_refresh_rate(rdev, state->low.sclk)) |\n\t\tPOWERMODE2(rv770_calculate_memory_refresh_rate(rdev, state->medium.sclk)) |\n\t\tPOWERMODE3(rv770_calculate_memory_refresh_rate(rdev, state->high.sclk));\n\tWREG32(MC_ARB_RFSH_RATE, arb_refresh_rate);\n}\n\nvoid rv770_enable_backbias(struct radeon_device *rdev,\n\t\t\t   bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, BACKBIAS_PAD_EN, ~BACKBIAS_PAD_EN);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~(BACKBIAS_VALUE | BACKBIAS_PAD_EN));\n}\n\nstatic void rv770_enable_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t\t bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (enable) {\n\t\tif (pi->sclk_ss)\n\t\t\tWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\n\n\t\tif (pi->mclk_ss) {\n\t\t\tif (rdev->family == CHIP_RV740)\n\t\t\t\trv740_enable_mclk_spread_spectrum(rdev, true);\n\t\t}\n\t} else {\n\t\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM, 0, ~SSEN);\n\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\n\n\t\tWREG32_P(CG_MPLL_SPREAD_SPECTRUM, 0, ~SSEN);\n\n\t\tif (rdev->family == CHIP_RV740)\n\t\t\trv740_enable_mclk_spread_spectrum(rdev, false);\n\t}\n}\n\nstatic void rv770_program_mpll_timing_parameters(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif ((rdev->family == CHIP_RV770) && !pi->mem_gddr5) {\n\t\tWREG32(MPLL_TIME,\n\t\t       (MPLL_LOCK_TIME(R600_MPLLLOCKTIME_DFLT * pi->ref_div) |\n\t\t\tMPLL_RESET_TIME(R600_MPLLRESETTIME_DFLT)));\n\t}\n}\n\nvoid rv770_setup_bsp(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 xclk = radeon_get_xclk(rdev);\n\n\tr600_calculate_u_and_p(pi->asi,\n\t\t\t       xclk,\n\t\t\t       16,\n\t\t\t       &pi->bsp,\n\t\t\t       &pi->bsu);\n\n\tr600_calculate_u_and_p(pi->pasi,\n\t\t\t       xclk,\n\t\t\t       16,\n\t\t\t       &pi->pbsp,\n\t\t\t       &pi->pbsu);\n\n\tpi->dsp = BSP(pi->bsp) | BSU(pi->bsu);\n\tpi->psp = BSP(pi->pbsp) | BSU(pi->pbsu);\n\n\tWREG32(CG_BSP, pi->dsp);\n\n}\n\nvoid rv770_program_git(struct radeon_device *rdev)\n{\n\tWREG32_P(CG_GIT, CG_GICST(R600_GICST_DFLT), ~CG_GICST_MASK);\n}\n\nvoid rv770_program_tp(struct radeon_device *rdev)\n{\n\tint i;\n\tenum r600_td td = R600_TD_DFLT;\n\n\tfor (i = 0; i < R600_PM_NUMBER_OF_TC; i++)\n\t\tWREG32(CG_FFCT_0 + (i * 4), (UTC_0(r600_utc[i]) | DTC_0(r600_dtc[i])));\n\n\tif (td == R600_TD_AUTO)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_FORCE_TREND_SEL);\n\telse\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_FORCE_TREND_SEL, ~FIR_FORCE_TREND_SEL);\n\tif (td == R600_TD_UP)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_TREND_MODE);\n\tif (td == R600_TD_DOWN)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_TREND_MODE, ~FIR_TREND_MODE);\n}\n\nvoid rv770_program_tpp(struct radeon_device *rdev)\n{\n\tWREG32(CG_TPC, R600_TPC_DFLT);\n}\n\nvoid rv770_program_sstp(struct radeon_device *rdev)\n{\n\tWREG32(CG_SSP, (SSTU(R600_SSTU_DFLT) | SST(R600_SST_DFLT)));\n}\n\nvoid rv770_program_engine_speed_parameters(struct radeon_device *rdev)\n{\n\tWREG32_P(SPLL_CNTL_MODE, SPLL_DIV_SYNC, ~SPLL_DIV_SYNC);\n}\n\nstatic void rv770_enable_display_gap(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\n\n\ttmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\n\ttmp |= (DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE) |\n\t\tDISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE));\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n}\n\nvoid rv770_program_vc(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tWREG32(CG_FTV, pi->vrc);\n}\n\nvoid rv770_clear_vc(struct radeon_device *rdev)\n{\n\tWREG32(CG_FTV, 0);\n}\n\nint rv770_upload_firmware(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint ret;\n\n\trv770_reset_smc(rdev);\n\trv770_stop_smc_clock(rdev);\n\n\tret = rv770_load_smc_ucode(rdev, pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rv770_populate_smc_acpi_state(struct radeon_device *rdev,\n\t\t\t\t\t RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tu32 mpll_ad_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl;\n\tu32 mpll_ad_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_ad_func_cntl_2;\n\tu32 mpll_dq_func_cntl =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl;\n\tu32 mpll_dq_func_cntl_2 =\n\t\tpi->clk_regs.rv770.mpll_dq_func_cntl_2;\n\tu32 spll_func_cntl =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 =\n\t\tpi->clk_regs.rv770.cg_spll_func_cntl_3;\n\tu32 mclk_pwrmgt_cntl;\n\tu32 dll_cntl;\n\n\ttable->ACPIState = table->initialState;\n\n\ttable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\tif (pi->acpi_vddc) {\n\t\trv770_populate_vddc_value(rdev, pi->acpi_vddc,\n\t\t\t\t\t  &table->ACPIState.levels[0].vddc);\n\t\tif (pi->pcie_gen2) {\n\t\t\tif (pi->acpi_pcie_gen2)\n\t\t\t\ttable->ACPIState.levels[0].gen2PCIE = 1;\n\t\t\telse\n\t\t\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t\t} else\n\t\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t\tif (pi->acpi_pcie_gen2)\n\t\t\ttable->ACPIState.levels[0].gen2XSP = 1;\n\t\telse\n\t\t\ttable->ACPIState.levels[0].gen2XSP = 0;\n\t} else {\n\t\trv770_populate_vddc_value(rdev, pi->min_vddc_in_table,\n\t\t\t\t\t  &table->ACPIState.levels[0].vddc);\n\t\ttable->ACPIState.levels[0].gen2PCIE = 0;\n\t}\n\n\n\tmpll_ad_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\n\n\tmpll_dq_func_cntl_2 |= BIAS_GEN_PDNB | RESET_EN;\n\n\tmclk_pwrmgt_cntl = (MRDCKA0_RESET |\n\t\t\t    MRDCKA1_RESET |\n\t\t\t    MRDCKB0_RESET |\n\t\t\t    MRDCKB1_RESET |\n\t\t\t    MRDCKC0_RESET |\n\t\t\t    MRDCKC1_RESET |\n\t\t\t    MRDCKD0_RESET |\n\t\t\t    MRDCKD1_RESET);\n\n\tdll_cntl = 0xff000000;\n\n\tspll_func_cntl |= SPLL_RESET | SPLL_SLEEP | SPLL_BYPASS_EN;\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(4);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 = cpu_to_be32(mpll_ad_func_cntl_2);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 = cpu_to_be32(mpll_dq_func_cntl_2);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\ttable->ACPIState.levels[0].mclk.mclk770.vDLL_CNTL = cpu_to_be32(dll_cntl);\n\n\ttable->ACPIState.levels[0].mclk.mclk770.mclk_value = 0;\n\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL = cpu_to_be32(spll_func_cntl);\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(spll_func_cntl_2);\n\ttable->ACPIState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(spll_func_cntl_3);\n\n\ttable->ACPIState.levels[0].sclk.sclk_value = 0;\n\n\trv770_populate_mvdd_value(rdev, 0, &table->ACPIState.levels[0].mvdd);\n\n\ttable->ACPIState.levels[1] = table->ACPIState.levels[0];\n\ttable->ACPIState.levels[2] = table->ACPIState.levels[0];\n\n\treturn 0;\n}\n\nint rv770_populate_initial_mvdd_value(struct radeon_device *rdev,\n\t\t\t\t      RV770_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif ((pi->s0_vid_lower_smio_cntl & pi->mvdd_mask_low) ==\n\t     (pi->mvdd_low_smio[MVDD_LOW_INDEX] & pi->mvdd_mask_low) ) {\n\t\tvoltage->index = MVDD_LOW_INDEX;\n\t\tvoltage->value = cpu_to_be16(MVDD_LOW_VALUE);\n\t} else {\n\t\tvoltage->index = MVDD_HIGH_INDEX;\n\t\tvoltage->value = cpu_to_be16(MVDD_HIGH_VALUE);\n\t}\n\n\treturn 0;\n}\n\nstatic int rv770_populate_smc_initial_state(struct radeon_device *rdev,\n\t\t\t\t\t    struct radeon_ps *radeon_state,\n\t\t\t\t\t    RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_ps *initial_state = rv770_get_ps(radeon_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 a_t;\n\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_AD_FUNC_CNTL_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ad_func_cntl_2);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_DQ_FUNC_CNTL_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_dq_func_cntl_2);\n\ttable->initialState.levels[0].mclk.mclk770.vMCLK_PWRMGT_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mclk_pwrmgt_cntl);\n\ttable->initialState.levels[0].mclk.mclk770.vDLL_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.dll_cntl);\n\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_SS =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ss1);\n\ttable->initialState.levels[0].mclk.mclk770.vMPLL_SS2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.mpll_ss2);\n\n\ttable->initialState.levels[0].mclk.mclk770.mclk_value =\n\t\tcpu_to_be32(initial_state->low.mclk);\n\n\ttable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_2);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_FUNC_CNTL_3 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_func_cntl_3);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum);\n\ttable->initialState.levels[0].sclk.vCG_SPLL_SPREAD_SPECTRUM_2 =\n\t\tcpu_to_be32(pi->clk_regs.rv770.cg_spll_spread_spectrum_2);\n\n\ttable->initialState.levels[0].sclk.sclk_value =\n\t\tcpu_to_be32(initial_state->low.sclk);\n\n\ttable->initialState.levels[0].arbValue = MC_CG_ARB_FREQ_F0;\n\n\ttable->initialState.levels[0].seqValue =\n\t\trv770_get_seq_value(rdev, &initial_state->low);\n\n\trv770_populate_vddc_value(rdev,\n\t\t\t\t  initial_state->low.vddc,\n\t\t\t\t  &table->initialState.levels[0].vddc);\n\trv770_populate_initial_mvdd_value(rdev,\n\t\t\t\t\t  &table->initialState.levels[0].mvdd);\n\n\ta_t = CG_R(0xffff) | CG_L(0);\n\ttable->initialState.levels[0].aT = cpu_to_be32(a_t);\n\n\ttable->initialState.levels[0].bSP = cpu_to_be32(pi->dsp);\n\n\tif (pi->boot_in_gen2)\n\t\ttable->initialState.levels[0].gen2PCIE = 1;\n\telse\n\t\ttable->initialState.levels[0].gen2PCIE = 0;\n\tif (initial_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\n\t\ttable->initialState.levels[0].gen2XSP = 1;\n\telse\n\t\ttable->initialState.levels[0].gen2XSP = 0;\n\n\tif (rdev->family == CHIP_RV740) {\n\t\tif (pi->mem_gddr5) {\n\t\t\tif (initial_state->low.mclk <= pi->mclk_strobe_mode_threshold)\n\t\t\t\ttable->initialState.levels[0].strobeMode =\n\t\t\t\t\trv740_get_mclk_frequency_ratio(initial_state->low.mclk) | 0x10;\n\t\t\telse\n\t\t\t\ttable->initialState.levels[0].strobeMode = 0;\n\n\t\t\tif (initial_state->low.mclk >= pi->mclk_edc_enable_threshold)\n\t\t\t\ttable->initialState.levels[0].mcFlags = SMC_MC_EDC_RD_FLAG | SMC_MC_EDC_WR_FLAG;\n\t\t\telse\n\t\t\t\ttable->initialState.levels[0].mcFlags =  0;\n\t\t}\n\t}\n\n\ttable->initialState.levels[1] = table->initialState.levels[0];\n\ttable->initialState.levels[2] = table->initialState.levels[0];\n\n\ttable->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\treturn 0;\n}\n\nstatic int rv770_populate_smc_vddc_table(struct radeon_device *rdev,\n\t\t\t\t\t RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint i;\n\n\tfor (i = 0; i < pi->valid_vddc_entries; i++) {\n\t\ttable->highSMIO[pi->vddc_table[i].vddc_index] =\n\t\t\tpi->vddc_table[i].high_smio;\n\t\ttable->lowSMIO[pi->vddc_table[i].vddc_index] =\n\t\t\tcpu_to_be32(pi->vddc_table[i].low_smio);\n\t}\n\n\ttable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_VDDC] = 0;\n\ttable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_VDDC] =\n\t\tcpu_to_be32(pi->vddc_mask_low);\n\n\tfor (i = 0;\n\t     ((i < pi->valid_vddc_entries) &&\n\t      (pi->max_vddc_in_table >\n\t       pi->vddc_table[i].vddc));\n\t     i++);\n\n\ttable->maxVDDCIndexInPPTable =\n\t\tpi->vddc_table[i].vddc_index;\n\n\treturn 0;\n}\n\nstatic int rv770_populate_smc_mvdd_table(struct radeon_device *rdev,\n\t\t\t\t\t RV770_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (pi->mvdd_control) {\n\t\ttable->lowSMIO[MVDD_HIGH_INDEX] |=\n\t\t\tcpu_to_be32(pi->mvdd_low_smio[MVDD_HIGH_INDEX]);\n\t\ttable->lowSMIO[MVDD_LOW_INDEX] |=\n\t\t\tcpu_to_be32(pi->mvdd_low_smio[MVDD_LOW_INDEX]);\n\n\t\ttable->voltageMaskTable.highMask[RV770_SMC_VOLTAGEMASK_MVDD] = 0;\n\t\ttable->voltageMaskTable.lowMask[RV770_SMC_VOLTAGEMASK_MVDD] =\n\t\t\tcpu_to_be32(pi->mvdd_mask_low);\n\t}\n\n\treturn 0;\n}\n\nstatic int rv770_init_smc_table(struct radeon_device *rdev,\n\t\t\t\tstruct radeon_ps *radeon_boot_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct rv7xx_ps *boot_state = rv770_get_ps(radeon_boot_state);\n\tRV770_SMC_STATETABLE *table = &pi->smc_statetable;\n\tint ret;\n\n\tmemset(table, 0, sizeof(RV770_SMC_STATETABLE));\n\n\tpi->boot_sclk = boot_state->low.sclk;\n\n\trv770_populate_smc_vddc_table(rdev, table);\n\trv770_populate_smc_mvdd_table(rdev, table);\n\n\tswitch (rdev->pm.int_thermal_type) {\n\tcase THERMAL_TYPE_RV770:\n\tcase THERMAL_TYPE_ADT7473_WITH_INTERNAL:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\n\t\tbreak;\n\tcase THERMAL_TYPE_NONE:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\n\t\tbreak;\n\tcase THERMAL_TYPE_EXTERNAL_GPIO:\n\tdefault:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC) {\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\n\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_DONT_WAIT_FOR_VBLANK_ON_ALERT)\n\t\t\ttable->extraFlags |= PPSMC_EXTRAFLAGS_AC2DC_DONT_WAIT_FOR_VBLANK;\n\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_GOTO_BOOT_ON_ALERT)\n\t\t\ttable->extraFlags |= PPSMC_EXTRAFLAGS_AC2DC_ACTION_GOTOINITIALSTATE;\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\n\n\tif (pi->mem_gddr5)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\tret = rv730_populate_smc_initial_state(rdev, radeon_boot_state, table);\n\telse\n\t\tret = rv770_populate_smc_initial_state(rdev, radeon_boot_state, table);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->family == CHIP_RV740)\n\t\tret = rv740_populate_smc_acpi_state(rdev, table);\n\telse if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\tret = rv730_populate_smc_acpi_state(rdev, table);\n\telse\n\t\tret = rv770_populate_smc_acpi_state(rdev, table);\n\tif (ret)\n\t\treturn ret;\n\n\ttable->driverState = table->initialState;\n\n\treturn rv770_copy_bytes_to_smc(rdev,\n\t\t\t\t       pi->state_table_start,\n\t\t\t\t       (const u8 *)table,\n\t\t\t\t       sizeof(RV770_SMC_STATETABLE),\n\t\t\t\t       pi->sram_end);\n}\n\nstatic int rv770_construct_vddc_table(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu16 min, max, step;\n\tu32 steps = 0;\n\tu8 vddc_index = 0;\n\tu32 i;\n\n\tradeon_atom_get_min_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, &min);\n\tradeon_atom_get_max_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, &max);\n\tradeon_atom_get_voltage_step(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, &step);\n\n\tsteps = (max - min) / step + 1;\n\n\tif (steps > MAX_NO_VREG_STEPS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < steps; i++) {\n\t\tu32 gpio_pins, gpio_mask;\n\n\t\tpi->vddc_table[i].vddc = (u16)(min + i * step);\n\t\tradeon_atom_get_voltage_gpio_settings(rdev,\n\t\t\t\t\t\t      pi->vddc_table[i].vddc,\n\t\t\t\t\t\t      SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t\t      &gpio_pins, &gpio_mask);\n\t\tpi->vddc_table[i].low_smio = gpio_pins & gpio_mask;\n\t\tpi->vddc_table[i].high_smio = 0;\n\t\tpi->vddc_mask_low = gpio_mask;\n\t\tif (i > 0) {\n\t\t\tif ((pi->vddc_table[i].low_smio !=\n\t\t\t     pi->vddc_table[i - 1].low_smio ) ||\n\t\t\t     (pi->vddc_table[i].high_smio !=\n\t\t\t      pi->vddc_table[i - 1].high_smio))\n\t\t\t\tvddc_index++;\n\t\t}\n\t\tpi->vddc_table[i].vddc_index = vddc_index;\n\t}\n\n\tpi->valid_vddc_entries = (u8)steps;\n\n\treturn 0;\n}\n\nstatic u32 rv770_get_mclk_split_point(struct atom_memory_info *memory_info)\n{\n\tif (memory_info->mem_type == MEM_TYPE_GDDR3)\n\t\treturn 30000;\n\n\treturn 0;\n}\n\nstatic int rv770_get_mvdd_pin_configuration(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 gpio_pins, gpio_mask;\n\n\tradeon_atom_get_voltage_gpio_settings(rdev,\n\t\t\t\t\t      MVDD_HIGH_VALUE, SET_VOLTAGE_TYPE_ASIC_MVDDC,\n\t\t\t\t\t      &gpio_pins, &gpio_mask);\n\tpi->mvdd_mask_low = gpio_mask;\n\tpi->mvdd_low_smio[MVDD_HIGH_INDEX] =\n\t\tgpio_pins & gpio_mask;\n\n\tradeon_atom_get_voltage_gpio_settings(rdev,\n\t\t\t\t\t      MVDD_LOW_VALUE, SET_VOLTAGE_TYPE_ASIC_MVDDC,\n\t\t\t\t\t      &gpio_pins, &gpio_mask);\n\tpi->mvdd_low_smio[MVDD_LOW_INDEX] =\n\t\tgpio_pins & gpio_mask;\n\n\treturn 0;\n}\n\nu8 rv770_get_memory_module_index(struct radeon_device *rdev)\n{\n\treturn (u8) ((RREG32(BIOS_SCRATCH_4) >> 16) & 0xff);\n}\n\nstatic int rv770_get_mvdd_configuration(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu8 memory_module_index;\n\tstruct atom_memory_info memory_info;\n\n\tmemory_module_index = rv770_get_memory_module_index(rdev);\n\n\tif (radeon_atom_get_memory_info(rdev, memory_module_index, &memory_info)) {\n\t\tpi->mvdd_control = false;\n\t\treturn 0;\n\t}\n\n\tpi->mvdd_split_frequency =\n\t\trv770_get_mclk_split_point(&memory_info);\n\n\tif (pi->mvdd_split_frequency == 0) {\n\t\tpi->mvdd_control = false;\n\t\treturn 0;\n\t}\n\n\treturn rv770_get_mvdd_pin_configuration(rdev);\n}\n\nvoid rv770_enable_voltage_control(struct radeon_device *rdev,\n\t\t\t\t  bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, VOLT_PWRMGT_EN, ~VOLT_PWRMGT_EN);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~VOLT_PWRMGT_EN);\n}\n\nstatic void rv770_program_display_gap(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\n\n\ttmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\n\tif (rdev->pm.dpm.new_active_crtcs & 1) {\n\t\ttmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\n\t\ttmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t} else if (rdev->pm.dpm.new_active_crtcs & 2) {\n\t\ttmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t\ttmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\n\t} else {\n\t\ttmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t\ttmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t}\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n}\n\nstatic void rv770_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t   bool enable)\n{\n\trv770_enable_bif_dynamic_pcie_gen2(rdev, enable);\n\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, ENABLE_GEN2PCIE, ~ENABLE_GEN2PCIE);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~ENABLE_GEN2PCIE);\n}\n\nstatic void r7xx_program_memory_timing_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\t  struct radeon_ps *radeon_new_state)\n{\n\tif ((rdev->family == CHIP_RV730) ||\n\t    (rdev->family == CHIP_RV710) ||\n\t    (rdev->family == CHIP_RV740))\n\t\trv730_program_memory_timing_parameters(rdev, radeon_new_state);\n\telse\n\t\trv770_program_memory_timing_parameters(rdev, radeon_new_state);\n}\n\nstatic int rv770_upload_sw_state(struct radeon_device *rdev,\n\t\t\t\t struct radeon_ps *radeon_new_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu16 address = pi->state_table_start +\n\t\toffsetof(RV770_SMC_STATETABLE, driverState);\n\tRV770_SMC_SWSTATE state = { 0 };\n\tint ret;\n\n\tret = rv770_convert_power_state_to_smc(rdev, radeon_new_state, &state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rv770_copy_bytes_to_smc(rdev, address, (const u8 *)&state,\n\t\t\t\t       sizeof(RV770_SMC_SWSTATE),\n\t\t\t\t       pi->sram_end);\n}\n\nint rv770_halt_smc(struct radeon_device *rdev)\n{\n\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_Halt) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\tif (rv770_wait_for_smc_inactive(rdev) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint rv770_resume_smc(struct radeon_device *rdev)\n{\n\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_Resume) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nint rv770_set_sw_state(struct radeon_device *rdev)\n{\n\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToSwState) != PPSMC_Result_OK)\n\t\tDRM_DEBUG(\"rv770_set_sw_state failed\\n\");\n\treturn 0;\n}\n\nint rv770_set_boot_state(struct radeon_device *rdev)\n{\n\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToInitialState) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nvoid rv770_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t      struct radeon_ps *new_ps,\n\t\t\t\t\t      struct radeon_ps *old_ps)\n{\n\tstruct rv7xx_ps *new_state = rv770_get_ps(new_ps);\n\tstruct rv7xx_ps *current_state = rv770_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->high.sclk >= current_state->high.sclk)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nvoid rv770_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *new_ps,\n\t\t\t\t\t     struct radeon_ps *old_ps)\n{\n\tstruct rv7xx_ps *new_state = rv770_get_ps(new_ps);\n\tstruct rv7xx_ps *current_state = rv770_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->high.sclk < current_state->high.sclk)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nint rv770_restrict_performance_levels_before_switch(struct radeon_device *rdev)\n{\n\tif (rv770_send_msg_to_smc(rdev, (PPSMC_Msg)(PPSMC_MSG_NoForcedLevel)) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\tif (rv770_send_msg_to_smc(rdev, (PPSMC_Msg)(PPSMC_MSG_TwoLevelsDisabled)) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint rv770_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t      enum radeon_dpm_forced_level level)\n{\n\tPPSMC_Msg msg;\n\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_ZeroLevelsDisabled) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t\tmsg = PPSMC_MSG_ForceHigh;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t\tmsg = (PPSMC_Msg)(PPSMC_MSG_TwoLevelsDisabled);\n\t} else {\n\t\tif (rv770_send_msg_to_smc(rdev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t\tmsg = (PPSMC_Msg)(PPSMC_MSG_ZeroLevelsDisabled);\n\t}\n\n\tif (rv770_send_msg_to_smc(rdev, msg) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n\nvoid r7xx_start_smc(struct radeon_device *rdev)\n{\n\trv770_start_smc(rdev);\n\trv770_start_smc_clock(rdev);\n}\n\n\nvoid r7xx_stop_smc(struct radeon_device *rdev)\n{\n\trv770_reset_smc(rdev);\n\trv770_stop_smc_clock(rdev);\n}\n\nstatic void rv770_read_clock_registers(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tpi->clk_regs.rv770.cg_spll_func_cntl =\n\t\tRREG32(CG_SPLL_FUNC_CNTL);\n\tpi->clk_regs.rv770.cg_spll_func_cntl_2 =\n\t\tRREG32(CG_SPLL_FUNC_CNTL_2);\n\tpi->clk_regs.rv770.cg_spll_func_cntl_3 =\n\t\tRREG32(CG_SPLL_FUNC_CNTL_3);\n\tpi->clk_regs.rv770.cg_spll_spread_spectrum =\n\t\tRREG32(CG_SPLL_SPREAD_SPECTRUM);\n\tpi->clk_regs.rv770.cg_spll_spread_spectrum_2 =\n\t\tRREG32(CG_SPLL_SPREAD_SPECTRUM_2);\n\tpi->clk_regs.rv770.mpll_ad_func_cntl =\n\t\tRREG32(MPLL_AD_FUNC_CNTL);\n\tpi->clk_regs.rv770.mpll_ad_func_cntl_2 =\n\t\tRREG32(MPLL_AD_FUNC_CNTL_2);\n\tpi->clk_regs.rv770.mpll_dq_func_cntl =\n\t\tRREG32(MPLL_DQ_FUNC_CNTL);\n\tpi->clk_regs.rv770.mpll_dq_func_cntl_2 =\n\t\tRREG32(MPLL_DQ_FUNC_CNTL_2);\n\tpi->clk_regs.rv770.mclk_pwrmgt_cntl =\n\t\tRREG32(MCLK_PWRMGT_CNTL);\n\tpi->clk_regs.rv770.dll_cntl = RREG32(DLL_CNTL);\n}\n\nstatic void r7xx_read_clock_registers(struct radeon_device *rdev)\n{\n\tif (rdev->family == CHIP_RV740)\n\t\trv740_read_clock_registers(rdev);\n\telse if ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\trv730_read_clock_registers(rdev);\n\telse\n\t\trv770_read_clock_registers(rdev);\n}\n\nvoid rv770_read_voltage_smio_registers(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tpi->s0_vid_lower_smio_cntl =\n\t\tRREG32(S0_VID_LOWER_SMIO_CNTL);\n}\n\nvoid rv770_reset_smio_status(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 sw_smio_index, vid_smio_cntl;\n\n\tsw_smio_index =\n\t\t(RREG32(GENERAL_PWRMGT) & SW_SMIO_INDEX_MASK) >> SW_SMIO_INDEX_SHIFT;\n\tswitch (sw_smio_index) {\n\tcase 3:\n\t\tvid_smio_cntl = RREG32(S3_VID_LOWER_SMIO_CNTL);\n\t\tbreak;\n\tcase 2:\n\t\tvid_smio_cntl = RREG32(S2_VID_LOWER_SMIO_CNTL);\n\t\tbreak;\n\tcase 1:\n\t\tvid_smio_cntl = RREG32(S1_VID_LOWER_SMIO_CNTL);\n\t\tbreak;\n\tcase 0:\n\t\treturn;\n\tdefault:\n\t\tvid_smio_cntl = pi->s0_vid_lower_smio_cntl;\n\t\tbreak;\n\t}\n\n\tWREG32(S0_VID_LOWER_SMIO_CNTL, vid_smio_cntl);\n\tWREG32_P(GENERAL_PWRMGT, SW_SMIO_INDEX(0), ~SW_SMIO_INDEX_MASK);\n}\n\nvoid rv770_get_memory_type(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp;\n\n\ttmp = RREG32(MC_SEQ_MISC0);\n\n\tif (((tmp & MC_SEQ_MISC0_GDDR5_MASK) >> MC_SEQ_MISC0_GDDR5_SHIFT) ==\n\t    MC_SEQ_MISC0_GDDR5_VALUE)\n\t\tpi->mem_gddr5 = true;\n\telse\n\t\tpi->mem_gddr5 = false;\n\n}\n\nvoid rv770_get_pcie_gen2_status(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\n\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2))\n\t\tpi->pcie_gen2 = true;\n\telse\n\t\tpi->pcie_gen2 = false;\n\n\tif (pi->pcie_gen2) {\n\t\tif (tmp & LC_CURRENT_DATA_RATE)\n\t\t\tpi->boot_in_gen2 = true;\n\t\telse\n\t\t\tpi->boot_in_gen2 = false;\n\t} else\n\t\tpi->boot_in_gen2 = false;\n}\n\n#if 0\nstatic int rv770_enter_ulp_state(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (pi->gfx_clock_gating) {\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~DYN_GFX_CLK_OFF_EN);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, GFX_CLK_FORCE_ON, ~GFX_CLK_FORCE_ON);\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~GFX_CLK_FORCE_ON);\n\t\tRREG32(GB_TILING_CONFIG);\n\t}\n\n\tWREG32_P(SMC_MSG, HOST_SMC_MSG(PPSMC_MSG_SwitchToMinimumPower),\n\t\t ~HOST_SMC_MSG_MASK);\n\n\tudelay(7000);\n\n\treturn 0;\n}\n\nstatic int rv770_exit_ulp_state(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tint i;\n\n\tWREG32_P(SMC_MSG, HOST_SMC_MSG(PPSMC_MSG_ResumeFromMinimumPower),\n\t\t ~HOST_SMC_MSG_MASK);\n\n\tudelay(7000);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (((RREG32(SMC_MSG) & HOST_SMC_RESP_MASK) >> HOST_SMC_RESP_SHIFT) == 1)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\n\tif (pi->gfx_clock_gating)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, DYN_GFX_CLK_OFF_EN, ~DYN_GFX_CLK_OFF_EN);\n\n\treturn 0;\n}\n#endif\n\nstatic void rv770_get_mclk_odt_threshold(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu8 memory_module_index;\n\tstruct atom_memory_info memory_info;\n\n\tpi->mclk_odt_threshold = 0;\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710)) {\n\t\tmemory_module_index = rv770_get_memory_module_index(rdev);\n\n\t\tif (radeon_atom_get_memory_info(rdev, memory_module_index, &memory_info))\n\t\t\treturn;\n\n\t\tif (memory_info.mem_type == MEM_TYPE_DDR2 ||\n\t\t    memory_info.mem_type == MEM_TYPE_DDR3)\n\t\t\tpi->mclk_odt_threshold = 30000;\n\t}\n}\n\nvoid rv770_get_max_vddc(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tu16 vddc;\n\n\tif (radeon_atom_get_max_vddc(rdev, 0, 0, &vddc))\n\t\tpi->max_vddc = 0;\n\telse\n\t\tpi->max_vddc = vddc;\n}\n\nvoid rv770_program_response_times(struct radeon_device *rdev)\n{\n\tu32 voltage_response_time, backbias_response_time;\n\tu32 acpi_delay_time, vbi_time_out;\n\tu32 vddc_dly, bb_dly, acpi_dly, vbi_dly;\n\tu32 reference_clock;\n\n\tvoltage_response_time = (u32)rdev->pm.dpm.voltage_response_time;\n\tbackbias_response_time = (u32)rdev->pm.dpm.backbias_response_time;\n\n\tif (voltage_response_time == 0)\n\t\tvoltage_response_time = 1000;\n\n\tif (backbias_response_time == 0)\n\t\tbackbias_response_time = 1000;\n\n\tacpi_delay_time = 15000;\n\tvbi_time_out = 100000;\n\n\treference_clock = radeon_get_xclk(rdev);\n\n\tvddc_dly = (voltage_response_time  * reference_clock) / 1600;\n\tbb_dly = (backbias_response_time * reference_clock) / 1600;\n\tacpi_dly = (acpi_delay_time * reference_clock) / 1600;\n\tvbi_dly = (vbi_time_out * reference_clock) / 1600;\n\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_delay_vreg, vddc_dly);\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_delay_bbias, bb_dly);\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_delay_acpi, acpi_dly);\n\trv770_write_smc_soft_register(rdev,\n\t\t\t\t      RV770_SMC_SOFT_REGISTER_mclk_chg_timeout, vbi_dly);\n#if 0\n\t \n\tif (WEKIVA_A21)\n\t\trv770_write_smc_soft_register(rdev,\n\t\t\t\t\t      RV770_SMC_SOFT_REGISTER_baby_step_timer,\n\t\t\t\t\t      0x10);\n#endif\n}\n\nstatic void rv770_program_dcodt_before_state_switch(struct radeon_device *rdev,\n\t\t\t\t\t\t    struct radeon_ps *radeon_new_state,\n\t\t\t\t\t\t    struct radeon_ps *radeon_current_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct rv7xx_ps *new_state = rv770_get_ps(radeon_new_state);\n\tstruct rv7xx_ps *current_state = rv770_get_ps(radeon_current_state);\n\tbool current_use_dc = false;\n\tbool new_use_dc = false;\n\n\tif (pi->mclk_odt_threshold == 0)\n\t\treturn;\n\n\tif (current_state->high.mclk <= pi->mclk_odt_threshold)\n\t\tcurrent_use_dc = true;\n\n\tif (new_state->high.mclk <= pi->mclk_odt_threshold)\n\t\tnew_use_dc = true;\n\n\tif (current_use_dc == new_use_dc)\n\t\treturn;\n\n\tif (!current_use_dc && new_use_dc)\n\t\treturn;\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\trv730_program_dcodt(rdev, new_use_dc);\n}\n\nstatic void rv770_program_dcodt_after_state_switch(struct radeon_device *rdev,\n\t\t\t\t\t\t   struct radeon_ps *radeon_new_state,\n\t\t\t\t\t\t   struct radeon_ps *radeon_current_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct rv7xx_ps *new_state = rv770_get_ps(radeon_new_state);\n\tstruct rv7xx_ps *current_state = rv770_get_ps(radeon_current_state);\n\tbool current_use_dc = false;\n\tbool new_use_dc = false;\n\n\tif (pi->mclk_odt_threshold == 0)\n\t\treturn;\n\n\tif (current_state->high.mclk <= pi->mclk_odt_threshold)\n\t\tcurrent_use_dc = true;\n\n\tif (new_state->high.mclk <= pi->mclk_odt_threshold)\n\t\tnew_use_dc = true;\n\n\tif (current_use_dc == new_use_dc)\n\t\treturn;\n\n\tif (current_use_dc && !new_use_dc)\n\t\treturn;\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\trv730_program_dcodt(rdev, new_use_dc);\n}\n\nstatic void rv770_retrieve_odt_values(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (pi->mclk_odt_threshold == 0)\n\t\treturn;\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\trv730_get_odt_values(rdev);\n}\n\nstatic void rv770_set_dpm_event_sources(struct radeon_device *rdev, u32 sources)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tbool want_thermal_protection;\n\tenum radeon_dpm_event_src dpm_event_src;\n\n\tswitch (sources) {\n\tcase 0:\n\tdefault:\n\t\twant_thermal_protection = false;\n\t\tbreak;\n\tcase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = RADEON_DPM_EVENT_SRC_DIGITAL;\n\t\tbreak;\n\n\tcase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = RADEON_DPM_EVENT_SRC_EXTERNAL;\n\t\tbreak;\n\n\tcase ((1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\n\t      (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL)):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = RADEON_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (want_thermal_protection) {\n\t\tWREG32_P(CG_THERMAL_CTRL, DPM_EVENT_SRC(dpm_event_src), ~DPM_EVENT_SRC_MASK);\n\t\tif (pi->thermal_protection)\n\t\t\tWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\n\t} else {\n\t\tWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\n\t}\n}\n\nvoid rv770_enable_auto_throttle_source(struct radeon_device *rdev,\n\t\t\t\t       enum radeon_dpm_auto_throttle_src source,\n\t\t\t\t       bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (enable) {\n\t\tif (!(pi->active_auto_throttle_sources & (1 << source))) {\n\t\t\tpi->active_auto_throttle_sources |= 1 << source;\n\t\t\trv770_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\n\t\t}\n\t} else {\n\t\tif (pi->active_auto_throttle_sources & (1 << source)) {\n\t\t\tpi->active_auto_throttle_sources &= ~(1 << source);\n\t\t\trv770_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\n\t\t}\n\t}\n}\n\nstatic int rv770_set_thermal_temperature_range(struct radeon_device *rdev,\n\t\t\t\t\t       int min_temp, int max_temp)\n{\n\tint low_temp = 0 * 1000;\n\tint high_temp = 255 * 1000;\n\n\tif (low_temp < min_temp)\n\t\tlow_temp = min_temp;\n\tif (high_temp > max_temp)\n\t\thigh_temp = max_temp;\n\tif (high_temp < low_temp) {\n\t\tDRM_ERROR(\"invalid thermal range: %d - %d\\n\", low_temp, high_temp);\n\t\treturn -EINVAL;\n\t}\n\n\tWREG32_P(CG_THERMAL_INT, DIG_THERM_INTH(high_temp / 1000), ~DIG_THERM_INTH_MASK);\n\tWREG32_P(CG_THERMAL_INT, DIG_THERM_INTL(low_temp / 1000), ~DIG_THERM_INTL_MASK);\n\tWREG32_P(CG_THERMAL_CTRL, DIG_THERM_DPM(high_temp / 1000), ~DIG_THERM_DPM_MASK);\n\n\trdev->pm.dpm.thermal.min_temp = low_temp;\n\trdev->pm.dpm.thermal.max_temp = high_temp;\n\n\treturn 0;\n}\n\nint rv770_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\tint ret;\n\n\tif (pi->gfx_clock_gating)\n\t\trv770_restore_cgcg(rdev);\n\n\tif (rv770_dpm_enabled(rdev))\n\t\treturn -EINVAL;\n\n\tif (pi->voltage_control) {\n\t\trv770_enable_voltage_control(rdev, true);\n\t\tret = rv770_construct_vddc_table(rdev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"rv770_construct_vddc_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (pi->dcodt)\n\t\trv770_retrieve_odt_values(rdev);\n\n\tif (pi->mvdd_control) {\n\t\tret = rv770_get_mvdd_configuration(rdev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"rv770_get_mvdd_configuration failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv770_enable_backbias(rdev, true);\n\n\trv770_enable_spread_spectrum(rdev, true);\n\n\tif (pi->thermal_protection)\n\t\trv770_enable_thermal_protection(rdev, true);\n\n\trv770_program_mpll_timing_parameters(rdev);\n\trv770_setup_bsp(rdev);\n\trv770_program_git(rdev);\n\trv770_program_tp(rdev);\n\trv770_program_tpp(rdev);\n\trv770_program_sstp(rdev);\n\trv770_program_engine_speed_parameters(rdev);\n\trv770_enable_display_gap(rdev);\n\trv770_program_vc(rdev);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\trv770_enable_dynamic_pcie_gen2(rdev, true);\n\n\tret = rv770_upload_firmware(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_upload_firmware failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_init_smc_table(rdev, boot_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_init_smc_table failed\\n\");\n\t\treturn ret;\n\t}\n\n\trv770_program_response_times(rdev);\n\tr7xx_start_smc(rdev);\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\trv730_start_dpm(rdev);\n\telse\n\t\trv770_start_dpm(rdev);\n\n\tif (pi->gfx_clock_gating)\n\t\trv770_gfx_clock_gating_enable(rdev, true);\n\n\tif (pi->mg_clock_gating)\n\t\trv770_mg_clock_gating_enable(rdev, true);\n\n\trv770_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\n\n\treturn 0;\n}\n\nint rv770_dpm_late_enable(struct radeon_device *rdev)\n{\n\tint ret;\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\tPPSMC_Result result;\n\n\t\tret = rv770_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trdev->irq.dpm_thermal = true;\n\t\tradeon_irq_set(rdev);\n\t\tresult = rv770_send_msg_to_smc(rdev, PPSMC_MSG_EnableThermalInterrupt);\n\n\t\tif (result != PPSMC_Result_OK)\n\t\t\tDRM_DEBUG_KMS(\"Could not enable thermal interrupts.\\n\");\n\t}\n\n\treturn 0;\n}\n\nvoid rv770_dpm_disable(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tif (!rv770_dpm_enabled(rdev))\n\t\treturn;\n\n\trv770_clear_vc(rdev);\n\n\tif (pi->thermal_protection)\n\t\trv770_enable_thermal_protection(rdev, false);\n\n\trv770_enable_spread_spectrum(rdev, false);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\trv770_enable_dynamic_pcie_gen2(rdev, false);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\tif (pi->gfx_clock_gating)\n\t\trv770_gfx_clock_gating_enable(rdev, false);\n\n\tif (pi->mg_clock_gating)\n\t\trv770_mg_clock_gating_enable(rdev, false);\n\n\tif ((rdev->family == CHIP_RV730) || (rdev->family == CHIP_RV710))\n\t\trv730_stop_dpm(rdev);\n\telse\n\t\trv770_stop_dpm(rdev);\n\n\tr7xx_stop_smc(rdev);\n\trv770_reset_smio_status(rdev);\n}\n\nint rv770_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\n\tint ret;\n\n\tret = rv770_restrict_performance_levels_before_switch(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_restrict_performance_levels_before_switch failed\\n\");\n\t\treturn ret;\n\t}\n\trv770_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\tret = rv770_halt_smc(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_halt_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_upload_sw_state(rdev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_upload_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tr7xx_program_memory_timing_parameters(rdev, new_ps);\n\tif (pi->dcodt)\n\t\trv770_program_dcodt_before_state_switch(rdev, new_ps, old_ps);\n\tret = rv770_resume_smc(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_resume_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = rv770_set_sw_state(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"rv770_set_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tif (pi->dcodt)\n\t\trv770_program_dcodt_after_state_switch(rdev, new_ps, old_ps);\n\trv770_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\n\treturn 0;\n}\n\n#if 0\nvoid rv770_dpm_reset_asic(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\n\trv770_restrict_performance_levels_before_switch(rdev);\n\tif (pi->dcodt)\n\t\trv770_program_dcodt_before_state_switch(rdev, boot_ps, boot_ps);\n\trv770_set_boot_state(rdev);\n\tif (pi->dcodt)\n\t\trv770_program_dcodt_after_state_switch(rdev, boot_ps, boot_ps);\n}\n#endif\n\nvoid rv770_dpm_setup_asic(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\n\tr7xx_read_clock_registers(rdev);\n\trv770_read_voltage_smio_registers(rdev);\n\trv770_get_memory_type(rdev);\n\tif (pi->dcodt)\n\t\trv770_get_mclk_odt_threshold(rdev);\n\trv770_get_pcie_gen2_status(rdev);\n\n\trv770_enable_acpi_pm(rdev);\n\n\tif (radeon_aspm != 0) {\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L0s)\n\t\t\trv770_enable_l0s(rdev);\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L1)\n\t\t\trv770_enable_l1(rdev);\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1)\n\t\t\trv770_enable_pll_sleep_in_l1(rdev);\n\t}\n}\n\nvoid rv770_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\trv770_program_display_gap(rdev);\n}\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void rv7xx_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *rps,\n\t\t\t\t\t     struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t     u8 table_rev)\n{\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (r600_is_uvd_state(rps->class, rps->class2)) {\n\t\tif ((rps->vclk == 0) || (rps->dclk == 0)) {\n\t\t\trps->vclk = RV770_DEFAULT_VCLK_FREQ;\n\t\t\trps->dclk = RV770_DEFAULT_DCLK_FREQ;\n\t\t}\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\trdev->pm.dpm.boot_ps = rps;\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void rv7xx_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *rps, int index,\n\t\t\t\t\t union pplib_clock_info *clock_info)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(rdev);\n\tstruct rv7xx_ps *ps = rv770_get_ps(rps);\n\tu32 sclk, mclk;\n\tstruct rv7xx_pl *pl;\n\n\tswitch (index) {\n\tcase 0:\n\t\tpl = &ps->low;\n\t\tbreak;\n\tcase 1:\n\t\tpl = &ps->medium;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tpl = &ps->high;\n\t\tbreak;\n\t}\n\n\tif (rdev->family >= CHIP_CEDAR) {\n\t\tsclk = le16_to_cpu(clock_info->evergreen.usEngineClockLow);\n\t\tsclk |= clock_info->evergreen.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->evergreen.usMemoryClockLow);\n\t\tmclk |= clock_info->evergreen.ucMemoryClockHigh << 16;\n\n\t\tpl->vddc = le16_to_cpu(clock_info->evergreen.usVDDC);\n\t\tpl->vddci = le16_to_cpu(clock_info->evergreen.usVDDCI);\n\t\tpl->flags = le32_to_cpu(clock_info->evergreen.ulFlags);\n\t} else {\n\t\tsclk = le16_to_cpu(clock_info->r600.usEngineClockLow);\n\t\tsclk |= clock_info->r600.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->r600.usMemoryClockLow);\n\t\tmclk |= clock_info->r600.ucMemoryClockHigh << 16;\n\n\t\tpl->vddc = le16_to_cpu(clock_info->r600.usVDDC);\n\t\tpl->flags = le32_to_cpu(clock_info->r600.ulFlags);\n\t}\n\n\tpl->mclk = mclk;\n\tpl->sclk = sclk;\n\n\t \n\tif (pl->vddc == 0xff01) {\n\t\tif (pi->max_vddc)\n\t\t\tpl->vddc = pi->max_vddc;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) {\n\t\tpi->acpi_vddc = pl->vddc;\n\t\tif (rdev->family >= CHIP_CEDAR)\n\t\t\teg_pi->acpi_vddci = pl->vddci;\n\t\tif (ps->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2)\n\t\t\tpi->acpi_pcie_gen2 = true;\n\t\telse\n\t\t\tpi->acpi_pcie_gen2 = false;\n\t}\n\n\tif (rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) {\n\t\tif (rdev->family >= CHIP_BARTS) {\n\t\t\teg_pi->ulv.supported = true;\n\t\t\teg_pi->ulv.pl = pl;\n\t\t}\n\t}\n\n\tif (pi->min_vddc_in_table > pl->vddc)\n\t\tpi->min_vddc_in_table = pl->vddc;\n\n\tif (pi->max_vddc_in_table < pl->vddc)\n\t\tpi->max_vddc_in_table = pl->vddc;\n\n\t \n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\tu16 vddc, vddci, mvdd;\n\t\tradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\n\t\tpl->mclk = rdev->clock.default_mclk;\n\t\tpl->sclk = rdev->clock.default_sclk;\n\t\tpl->vddc = vddc;\n\t\tpl->vddci = vddci;\n\t}\n\n\tif ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==\n\t    ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk = pl->sclk;\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.mclk = pl->mclk;\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddc = pl->vddc;\n\t\trdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddci = pl->vddci;\n\t}\n}\n\nint rv7xx_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j;\n\tunion pplib_clock_info *clock_info;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tstruct rv7xx_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\trdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\n\t\tpower_state = (union pplib_power_state *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset) +\n\t\t\t i * power_info->pplib.ucStateEntrySize);\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\n\t\t\t (power_state->v1.ucNonClockStateIndex *\n\t\t\t  power_info->pplib.ucNonClockSize));\n\t\tif (power_info->pplib.ucStateEntrySize - 1) {\n\t\t\tu8 *idx;\n\t\t\tps = kzalloc(sizeof(struct rv7xx_ps), GFP_KERNEL);\n\t\t\tif (ps == NULL) {\n\t\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\t\trv7xx_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\t\t non_clock_info,\n\t\t\t\t\t\t\t power_info->pplib.ucNonClockSize);\n\t\t\tidx = (u8 *)&power_state->v1.ucClockStateIndices[0];\n\t\t\tfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\n\t\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\n\t\t\t\t\t (idx[j] * power_info->pplib.ucClockInfoSize));\n\t\t\t\trv7xx_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t\t     &rdev->pm.dpm.ps[i], j,\n\t\t\t\t\t\t\t     clock_info);\n\t\t\t}\n\t\t}\n\t}\n\trdev->pm.dpm.num_ps = power_info->pplib.ucNumStates;\n\treturn 0;\n}\n\nvoid rv770_get_engine_memory_ss(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(rdev);\n\tstruct radeon_atom_ss ss;\n\n\tpi->sclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t       ASIC_INTERNAL_ENGINE_SS, 0);\n\tpi->mclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t       ASIC_INTERNAL_MEMORY_SS, 0);\n\n\tif (pi->sclk_ss || pi->mclk_ss)\n\t\tpi->dynamic_ss = true;\n\telse\n\t\tpi->dynamic_ss = false;\n}\n\nint rv770_dpm_init(struct radeon_device *rdev)\n{\n\tstruct rv7xx_power_info *pi;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\tpi = kzalloc(sizeof(struct rv7xx_power_info), GFP_KERNEL);\n\tif (pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = pi;\n\n\trv770_get_max_vddc(rdev);\n\n\tpi->acpi_vddc = 0;\n\tpi->min_vddc_in_table = 0;\n\tpi->max_vddc_in_table = 0;\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv7xx_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->pm.dpm.voltage_response_time == 0)\n\t\trdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\n\tif (rdev->pm.dpm.backbias_response_time == 0)\n\t\trdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     0, false, &dividers);\n\tif (ret)\n\t\tpi->ref_div = dividers.ref_div + 1;\n\telse\n\t\tpi->ref_div = R600_REFERENCEDIVIDER_DFLT;\n\n\tpi->mclk_strobe_mode_threshold = 30000;\n\tpi->mclk_edc_enable_threshold = 30000;\n\n\tpi->rlp = RV770_RLP_DFLT;\n\tpi->rmp = RV770_RMP_DFLT;\n\tpi->lhp = RV770_LHP_DFLT;\n\tpi->lmp = RV770_LMP_DFLT;\n\n\tpi->voltage_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\n\n\tpi->mvdd_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_MVDDC, 0);\n\n\trv770_get_engine_memory_ss(rdev);\n\n\tpi->asi = RV770_ASI_DFLT;\n\tpi->pasi = RV770_HASI_DFLT;\n\tpi->vrc = RV770_VRC_DFLT;\n\n\tpi->power_gating = false;\n\n\tpi->gfx_clock_gating = true;\n\n\tpi->mg_clock_gating = true;\n\tpi->mgcgtssm = true;\n\n\tpi->dynamic_pcie_gen2 = true;\n\n\tif (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE)\n\t\tpi->thermal_protection = true;\n\telse\n\t\tpi->thermal_protection = false;\n\n\tpi->display_gap = true;\n\n\tif (rdev->flags & RADEON_IS_MOBILITY)\n\t\tpi->dcodt = true;\n\telse\n\t\tpi->dcodt = false;\n\n\tpi->ulps = true;\n\n\tpi->mclk_stutter_mode_threshold = 0;\n\n\tpi->sram_end = SMC_RAM_END;\n\tpi->state_table_start = RV770_SMC_TABLE_ADDRESS;\n\tpi->soft_regs_start = RV770_SMC_SOFT_REGISTERS_START;\n\n\treturn 0;\n}\n\nvoid rv770_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t\t struct radeon_ps *rps)\n{\n\tstruct rv7xx_ps *ps = rv770_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tif (rdev->family >= CHIP_CEDAR) {\n\t\tpl = &ps->low;\n\t\tprintk(\"\\t\\tpower level 0    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t       pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t\tpl = &ps->medium;\n\t\tprintk(\"\\t\\tpower level 1    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t       pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t\tpl = &ps->high;\n\t\tprintk(\"\\t\\tpower level 2    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t       pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t} else {\n\t\tpl = &ps->low;\n\t\tprintk(\"\\t\\tpower level 0    sclk: %u mclk: %u vddc: %u\\n\",\n\t\t       pl->sclk, pl->mclk, pl->vddc);\n\t\tpl = &ps->medium;\n\t\tprintk(\"\\t\\tpower level 1    sclk: %u mclk: %u vddc: %u\\n\",\n\t\t       pl->sclk, pl->mclk, pl->vddc);\n\t\tpl = &ps->high;\n\t\tprintk(\"\\t\\tpower level 2    sclk: %u mclk: %u vddc: %u\\n\",\n\t\t       pl->sclk, pl->mclk, pl->vddc);\n\t}\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid rv770_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t       struct seq_file *m)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct rv7xx_ps *ps = rv770_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\n\t\tCURRENT_PROFILE_INDEX_SHIFT;\n\n\tif (current_index > 2) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tif (current_index == 0)\n\t\t\tpl = &ps->low;\n\t\telse if (current_index == 1)\n\t\t\tpl = &ps->medium;\n\t\telse  \n\t\t\tpl = &ps->high;\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tif (rdev->family >= CHIP_CEDAR) {\n\t\t\tseq_printf(m, \"power level %d    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t\t\t   current_index, pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t\t} else {\n\t\t\tseq_printf(m, \"power level %d    sclk: %u mclk: %u vddc: %u\\n\",\n\t\t\t\t   current_index, pl->sclk, pl->mclk, pl->vddc);\n\t\t}\n\t}\n}\n\nu32 rv770_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct rv7xx_ps *ps = rv770_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\n\t\tCURRENT_PROFILE_INDEX_SHIFT;\n\n\tif (current_index > 2) {\n\t\treturn 0;\n\t} else {\n\t\tif (current_index == 0)\n\t\t\tpl = &ps->low;\n\t\telse if (current_index == 1)\n\t\t\tpl = &ps->medium;\n\t\telse  \n\t\t\tpl = &ps->high;\n\t\treturn  pl->sclk;\n\t}\n}\n\nu32 rv770_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct rv7xx_ps *ps = rv770_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\n\t\tCURRENT_PROFILE_INDEX_SHIFT;\n\n\tif (current_index > 2) {\n\t\treturn 0;\n\t} else {\n\t\tif (current_index == 0)\n\t\t\tpl = &ps->low;\n\t\telse if (current_index == 1)\n\t\t\tpl = &ps->medium;\n\t\telse  \n\t\t\tpl = &ps->high;\n\t\treturn  pl->mclk;\n\t}\n}\n\nvoid rv770_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n}\n\nu32 rv770_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct rv7xx_ps *requested_state = rv770_get_ps(rdev->pm.dpm.requested_ps);\n\n\tif (low)\n\t\treturn requested_state->low.sclk;\n\telse\n\t\treturn requested_state->high.sclk;\n}\n\nu32 rv770_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct rv7xx_ps *requested_state = rv770_get_ps(rdev->pm.dpm.requested_ps);\n\n\tif (low)\n\t\treturn requested_state->low.mclk;\n\telse\n\t\treturn requested_state->high.mclk;\n}\n\nbool rv770_dpm_vblank_too_short(struct radeon_device *rdev)\n{\n\tu32 vblank_time = r600_dpm_get_vblank_time(rdev);\n\tu32 switch_limit = 200;  \n\n\t \n\t \n\tif ((rdev->family == CHIP_RV770) &&\n\t    !(rdev->flags & RADEON_IS_MOBILITY))\n\t\tswitch_limit = 0xffffffff;  \n\n\tif (vblank_time < switch_limit)\n\t\treturn true;\n\telse\n\t\treturn false;\n\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}