{
  "module_name": "rs690.c",
  "hash_id": "dedaea7f8440c739d609f533d5a11da56d3e9789cb1c8aee76870d327103328c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rs690.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n#include \"rs690d.h\"\n\nint rs690_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32_MC(R_000090_MC_SYSTEM_STATUS);\n\t\tif (G_000090_MC_SYSTEM_IDLE(tmp))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nstatic void rs690_gpu_init(struct radeon_device *rdev)\n{\n\t \n\tr420_pipes_init(rdev);\n\tif (rs690_mc_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait MC idle while programming pipes. Bad things might happen.\\n\");\n\t}\n}\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_v2;\n};\n\nvoid rs690_pm_info(struct radeon_device *rdev)\n{\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *info;\n\tuint16_t data_offset;\n\tuint8_t frev, crev;\n\tfixed20_12 tmp;\n\n\tif (atom_parse_data_header(rdev->mode_info.atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tinfo = (union igp_info *)(rdev->mode_info.atom_context->bios + data_offset);\n\n\t\t \n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\ttmp.full = dfixed_const(100);\n\t\t\trdev->pm.igp_sideport_mclk.full = dfixed_const(le32_to_cpu(info->info.ulBootUpMemoryClock));\n\t\t\trdev->pm.igp_sideport_mclk.full = dfixed_div(rdev->pm.igp_sideport_mclk, tmp);\n\t\t\tif (le16_to_cpu(info->info.usK8MemoryClock))\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(le16_to_cpu(info->info.usK8MemoryClock));\n\t\t\telse if (rdev->clock.default_mclk) {\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(rdev->clock.default_mclk);\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_div(rdev->pm.igp_system_mclk, tmp);\n\t\t\t} else\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(400);\n\t\t\trdev->pm.igp_ht_link_clk.full = dfixed_const(le16_to_cpu(info->info.usFSBClock));\n\t\t\trdev->pm.igp_ht_link_width.full = dfixed_const(info->info.ucHTLinkWidth);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttmp.full = dfixed_const(100);\n\t\t\trdev->pm.igp_sideport_mclk.full = dfixed_const(le32_to_cpu(info->info_v2.ulBootUpSidePortClock));\n\t\t\trdev->pm.igp_sideport_mclk.full = dfixed_div(rdev->pm.igp_sideport_mclk, tmp);\n\t\t\tif (le32_to_cpu(info->info_v2.ulBootUpUMAClock))\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(le32_to_cpu(info->info_v2.ulBootUpUMAClock));\n\t\t\telse if (rdev->clock.default_mclk)\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(rdev->clock.default_mclk);\n\t\t\telse\n\t\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(66700);\n\t\t\trdev->pm.igp_system_mclk.full = dfixed_div(rdev->pm.igp_system_mclk, tmp);\n\t\t\trdev->pm.igp_ht_link_clk.full = dfixed_const(le32_to_cpu(info->info_v2.ulHTLinkFreq));\n\t\t\trdev->pm.igp_ht_link_clk.full = dfixed_div(rdev->pm.igp_ht_link_clk, tmp);\n\t\t\trdev->pm.igp_ht_link_width.full = dfixed_const(le16_to_cpu(info->info_v2.usMinHTLinkWidth));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\trdev->pm.igp_sideport_mclk.full = dfixed_const(200);\n\t\t\trdev->pm.igp_system_mclk.full = dfixed_const(200);\n\t\t\trdev->pm.igp_ht_link_clk.full = dfixed_const(1000);\n\t\t\trdev->pm.igp_ht_link_width.full = dfixed_const(8);\n\t\t\tDRM_ERROR(\"No integrated system info for your GPU, using safe default\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\trdev->pm.igp_sideport_mclk.full = dfixed_const(200);\n\t\trdev->pm.igp_system_mclk.full = dfixed_const(200);\n\t\trdev->pm.igp_ht_link_clk.full = dfixed_const(1000);\n\t\trdev->pm.igp_ht_link_width.full = dfixed_const(8);\n\t\tDRM_ERROR(\"No integrated system info for your GPU, using safe default\\n\");\n\t}\n\t \n\t \n\ttmp.full = dfixed_const(4);\n\trdev->pm.k8_bandwidth.full = dfixed_mul(rdev->pm.igp_system_mclk, tmp);\n\t \n\ttmp.full = dfixed_const(5);\n\trdev->pm.ht_bandwidth.full = dfixed_mul(rdev->pm.igp_ht_link_clk,\n\t\t\t\t\t\trdev->pm.igp_ht_link_width);\n\trdev->pm.ht_bandwidth.full = dfixed_div(rdev->pm.ht_bandwidth, tmp);\n\tif (tmp.full < rdev->pm.max_bandwidth.full) {\n\t\t \n\t\trdev->pm.max_bandwidth.full = tmp.full;\n\t}\n\t \n\ttmp.full = dfixed_const(14);\n\trdev->pm.sideport_bandwidth.full = dfixed_mul(rdev->pm.igp_sideport_mclk, tmp);\n\ttmp.full = dfixed_const(10);\n\trdev->pm.sideport_bandwidth.full = dfixed_div(rdev->pm.sideport_bandwidth, tmp);\n}\n\nstatic void rs690_mc_init(struct radeon_device *rdev)\n{\n\tu64 base;\n\tuint32_t h_addr, l_addr;\n\tunsigned long long k8_addr;\n\n\trs400_gart_adjust_size(rdev);\n\trdev->mc.vram_is_ddr = true;\n\trdev->mc.vram_width = 128;\n\trdev->mc.real_vram_size = RREG32(RADEON_CONFIG_MEMSIZE);\n\trdev->mc.mc_vram_size = rdev->mc.real_vram_size;\n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\tbase = RREG32_MC(R_000100_MCCFG_FB_LOCATION);\n\tbase = G_000100_MC_FB_START(base) << 16;\n\trdev->mc.igp_sideport_enabled = radeon_atombios_sideport_present(rdev);\n\t \n\tif (rdev->mc.igp_sideport_enabled &&\n\t    (rdev->mc.real_vram_size == (384 * 1024 * 1024))) {\n\t\tbase += 128 * 1024 * 1024;\n\t\trdev->mc.real_vram_size -= 128 * 1024 * 1024;\n\t\trdev->mc.mc_vram_size = rdev->mc.real_vram_size;\n\t}\n\n\t  \n\trdev->fastfb_working = false;\n\th_addr = G_00005F_K8_ADDR_EXT(RREG32_MC(R_00005F_MC_MISC_UMA_CNTL));\n\tl_addr = RREG32_MC(R_00001E_K8_FB_LOCATION);\n\tk8_addr = ((unsigned long long)h_addr) << 32 | l_addr;\n#if defined(CONFIG_X86_32) && !defined(CONFIG_X86_PAE)\n\tif (k8_addr + rdev->mc.visible_vram_size < 0x100000000ULL)\t\n#endif\n\t{\n\t\t \n\t\tif (!rdev->mc.igp_sideport_enabled && radeon_fastfb == 1) {\n\t\t\tDRM_INFO(\"Direct mapping: aper base at 0x%llx, replaced by direct mapping base 0x%llx.\\n\", \n\t\t\t\t\t(unsigned long long)rdev->mc.aper_base, k8_addr);\n\t\t\trdev->mc.aper_base = (resource_size_t)k8_addr;\n\t\t\trdev->fastfb_working = true;\n\t\t}\n\t}  \n\n\trs690_pm_info(rdev);\n\tradeon_vram_location(rdev, &rdev->mc, base);\n\trdev->mc.gtt_base_align = rdev->mc.gtt_size - 1;\n\tradeon_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n}\n\nvoid rs690_line_buffer_adjust(struct radeon_device *rdev,\n\t\t\t      struct drm_display_mode *mode1,\n\t\t\t      struct drm_display_mode *mode2)\n{\n\tu32 tmp;\n\n\t \n\tu32 lb_size = 8192;\n\n\t \n\ttmp = RREG32(R_006520_DC_LB_MEMORY_SPLIT) & C_006520_DC_LB_MEMORY_SPLIT;\n\ttmp &= ~C_006520_DC_LB_MEMORY_SPLIT_MODE;\n\t \n\tif (mode1 && mode2) {\n\t\tif (mode1->hdisplay > mode2->hdisplay) {\n\t\t\tif (mode1->hdisplay > 2560)\n\t\t\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1_3Q_D2_1Q;\n\t\t\telse\n\t\t\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;\n\t\t} else if (mode2->hdisplay > mode1->hdisplay) {\n\t\t\tif (mode2->hdisplay > 2560)\n\t\t\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q;\n\t\t\telse\n\t\t\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;\n\t\t} else\n\t\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1HALF_D2HALF;\n\t} else if (mode1) {\n\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1_ONLY;\n\t} else if (mode2) {\n\t\ttmp |= V_006520_DC_LB_MEMORY_SPLIT_D1_1Q_D2_3Q;\n\t}\n\tWREG32(R_006520_DC_LB_MEMORY_SPLIT, tmp);\n\n\t \n\tif (mode1)\n\t\trdev->mode_info.crtcs[0]->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode1->crtc_hdisplay);\n\n\tif (mode2)\n\t\trdev->mode_info.crtcs[1]->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode2->crtc_hdisplay);\n}\n\nstruct rs690_watermark {\n\tu32        lb_request_fifo_depth;\n\tfixed20_12 num_line_pair;\n\tfixed20_12 estimated_width;\n\tfixed20_12 worst_case_latency;\n\tfixed20_12 consumption_rate;\n\tfixed20_12 active_time;\n\tfixed20_12 dbpp;\n\tfixed20_12 priority_mark_max;\n\tfixed20_12 priority_mark;\n\tfixed20_12 sclk;\n};\n\nstatic void rs690_crtc_bandwidth_compute(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_crtc *crtc,\n\t\t\t\t\t struct rs690_watermark *wm,\n\t\t\t\t\t bool low)\n{\n\tstruct drm_display_mode *mode = &crtc->base.mode;\n\tfixed20_12 a, b, c;\n\tfixed20_12 pclk, request_fifo_depth, tolerable_latency, estimated_width;\n\tfixed20_12 consumption_time, line_time, chunk_time, read_delay_latency;\n\tfixed20_12 sclk, core_bandwidth, max_bandwidth;\n\tu32 selected_sclk;\n\n\tif (!crtc->base.enabled) {\n\t\t \n\t\twm->lb_request_fifo_depth = 4;\n\t\treturn;\n\t}\n\n\tif (((rdev->family == CHIP_RS780) || (rdev->family == CHIP_RS880)) &&\n\t    (rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled)\n\t\tselected_sclk = radeon_dpm_get_sclk(rdev, low);\n\telse\n\t\tselected_sclk = rdev->pm.current_sclk;\n\n\t \n\ta.full = dfixed_const(100);\n\tsclk.full = dfixed_const(selected_sclk);\n\tsclk.full = dfixed_div(sclk, a);\n\n\t \n\ta.full = dfixed_const(16);\n\tcore_bandwidth.full = dfixed_div(rdev->pm.sclk, a);\n\n\tif (crtc->vsc.full > dfixed_const(2))\n\t\twm->num_line_pair.full = dfixed_const(2);\n\telse\n\t\twm->num_line_pair.full = dfixed_const(1);\n\n\tb.full = dfixed_const(mode->crtc_hdisplay);\n\tc.full = dfixed_const(256);\n\ta.full = dfixed_div(b, c);\n\trequest_fifo_depth.full = dfixed_mul(a, wm->num_line_pair);\n\trequest_fifo_depth.full = dfixed_ceil(request_fifo_depth);\n\tif (a.full < dfixed_const(4)) {\n\t\twm->lb_request_fifo_depth = 4;\n\t} else {\n\t\twm->lb_request_fifo_depth = dfixed_trunc(request_fifo_depth);\n\t}\n\n\t \n\ta.full = dfixed_const(mode->clock);\n\tb.full = dfixed_const(1000);\n\ta.full = dfixed_div(a, b);\n\tpclk.full = dfixed_div(b, a);\n\tif (crtc->rmx_type != RMX_OFF) {\n\t\tb.full = dfixed_const(2);\n\t\tif (crtc->vsc.full > b.full)\n\t\t\tb.full = crtc->vsc.full;\n\t\tb.full = dfixed_mul(b, crtc->hsc);\n\t\tc.full = dfixed_const(2);\n\t\tb.full = dfixed_div(b, c);\n\t\tconsumption_time.full = dfixed_div(pclk, b);\n\t} else {\n\t\tconsumption_time.full = pclk.full;\n\t}\n\ta.full = dfixed_const(1);\n\twm->consumption_rate.full = dfixed_div(a, consumption_time);\n\n\n\t \n\ta.full = dfixed_const(crtc->base.mode.crtc_htotal);\n\tline_time.full = dfixed_mul(a, pclk);\n\n\t \n\ta.full = dfixed_const(crtc->base.mode.crtc_htotal);\n\tb.full = dfixed_const(crtc->base.mode.crtc_hdisplay);\n\twm->active_time.full = dfixed_mul(line_time, b);\n\twm->active_time.full = dfixed_div(wm->active_time, a);\n\n\t \n\tmax_bandwidth = core_bandwidth;\n\tif (rdev->mc.igp_sideport_enabled) {\n\t\tif (max_bandwidth.full > rdev->pm.sideport_bandwidth.full &&\n\t\t\trdev->pm.sideport_bandwidth.full)\n\t\t\tmax_bandwidth = rdev->pm.sideport_bandwidth;\n\t\tread_delay_latency.full = dfixed_const(370 * 800);\n\t\ta.full = dfixed_const(1000);\n\t\tb.full = dfixed_div(rdev->pm.igp_sideport_mclk, a);\n\t\tread_delay_latency.full = dfixed_div(read_delay_latency, b);\n\t\tread_delay_latency.full = dfixed_mul(read_delay_latency, a);\n\t} else {\n\t\tif (max_bandwidth.full > rdev->pm.k8_bandwidth.full &&\n\t\t\trdev->pm.k8_bandwidth.full)\n\t\t\tmax_bandwidth = rdev->pm.k8_bandwidth;\n\t\tif (max_bandwidth.full > rdev->pm.ht_bandwidth.full &&\n\t\t\trdev->pm.ht_bandwidth.full)\n\t\t\tmax_bandwidth = rdev->pm.ht_bandwidth;\n\t\tread_delay_latency.full = dfixed_const(5000);\n\t}\n\n\t \n\ta.full = dfixed_const(16);\n\tsclk.full = dfixed_mul(max_bandwidth, a);\n\ta.full = dfixed_const(1000);\n\tsclk.full = dfixed_div(a, sclk);\n\t \n\ta.full = dfixed_const(256 * 13);\n\tchunk_time.full = dfixed_mul(sclk, a);\n\ta.full = dfixed_const(10);\n\tchunk_time.full = dfixed_div(chunk_time, a);\n\n\t \n\tif (dfixed_trunc(wm->num_line_pair) > 1) {\n\t\ta.full = dfixed_const(3);\n\t\twm->worst_case_latency.full = dfixed_mul(a, chunk_time);\n\t\twm->worst_case_latency.full += read_delay_latency.full;\n\t} else {\n\t\ta.full = dfixed_const(2);\n\t\twm->worst_case_latency.full = dfixed_mul(a, chunk_time);\n\t\twm->worst_case_latency.full += read_delay_latency.full;\n\t}\n\n\t \n\tif ((2+wm->lb_request_fifo_depth) >= dfixed_trunc(request_fifo_depth)) {\n\t\ttolerable_latency.full = line_time.full;\n\t} else {\n\t\ttolerable_latency.full = dfixed_const(wm->lb_request_fifo_depth - 2);\n\t\ttolerable_latency.full = request_fifo_depth.full - tolerable_latency.full;\n\t\ttolerable_latency.full = dfixed_mul(tolerable_latency, chunk_time);\n\t\ttolerable_latency.full = line_time.full - tolerable_latency.full;\n\t}\n\t \n\twm->dbpp.full = dfixed_const(4 * 8);\n\n\t \n\ta.full = dfixed_const(16);\n\twm->priority_mark_max.full = dfixed_const(crtc->base.mode.crtc_hdisplay);\n\twm->priority_mark_max.full = dfixed_div(wm->priority_mark_max, a);\n\twm->priority_mark_max.full = dfixed_ceil(wm->priority_mark_max);\n\n\t \n\testimated_width.full = tolerable_latency.full - wm->worst_case_latency.full;\n\testimated_width.full = dfixed_div(estimated_width, consumption_time);\n\tif (dfixed_trunc(estimated_width) > crtc->base.mode.crtc_hdisplay) {\n\t\twm->priority_mark.full = dfixed_const(10);\n\t} else {\n\t\ta.full = dfixed_const(16);\n\t\twm->priority_mark.full = dfixed_div(estimated_width, a);\n\t\twm->priority_mark.full = dfixed_ceil(wm->priority_mark);\n\t\twm->priority_mark.full = wm->priority_mark_max.full - wm->priority_mark.full;\n\t}\n}\n\nstatic void rs690_compute_mode_priority(struct radeon_device *rdev,\n\t\t\t\t\tstruct rs690_watermark *wm0,\n\t\t\t\t\tstruct rs690_watermark *wm1,\n\t\t\t\t\tstruct drm_display_mode *mode0,\n\t\t\t\t\tstruct drm_display_mode *mode1,\n\t\t\t\t\tu32 *d1mode_priority_a_cnt,\n\t\t\t\t\tu32 *d2mode_priority_a_cnt)\n{\n\tfixed20_12 priority_mark02, priority_mark12, fill_rate;\n\tfixed20_12 a, b;\n\n\t*d1mode_priority_a_cnt = S_006548_D1MODE_PRIORITY_A_OFF(1);\n\t*d2mode_priority_a_cnt = S_006548_D1MODE_PRIORITY_A_OFF(1);\n\n\tif (mode0 && mode1) {\n\t\tif (dfixed_trunc(wm0->dbpp) > 64)\n\t\t\ta.full = dfixed_mul(wm0->dbpp, wm0->num_line_pair);\n\t\telse\n\t\t\ta.full = wm0->num_line_pair.full;\n\t\tif (dfixed_trunc(wm1->dbpp) > 64)\n\t\t\tb.full = dfixed_mul(wm1->dbpp, wm1->num_line_pair);\n\t\telse\n\t\t\tb.full = wm1->num_line_pair.full;\n\t\ta.full += b.full;\n\t\tfill_rate.full = dfixed_div(wm0->sclk, a);\n\t\tif (wm0->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm0->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm0->active_time);\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\ta.full = a.full + b.full;\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark02.full = dfixed_div(a, b);\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark02.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm1->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm1->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm1->active_time);\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\ta.full = a.full + b.full;\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark12.full = dfixed_div(a, b);\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark12.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm0->priority_mark.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark.full;\n\t\tif (wm0->priority_mark_max.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark_max.full;\n\t\tif (wm1->priority_mark.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark.full;\n\t\tif (wm1->priority_mark_max.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark_max.full;\n\t\t*d1mode_priority_a_cnt = dfixed_trunc(priority_mark02);\n\t\t*d2mode_priority_a_cnt = dfixed_trunc(priority_mark12);\n\t\tif (rdev->disp_priority == 2) {\n\t\t\t*d1mode_priority_a_cnt |= S_006548_D1MODE_PRIORITY_A_ALWAYS_ON(1);\n\t\t\t*d2mode_priority_a_cnt |= S_006D48_D2MODE_PRIORITY_A_ALWAYS_ON(1);\n\t\t}\n\t} else if (mode0) {\n\t\tif (dfixed_trunc(wm0->dbpp) > 64)\n\t\t\ta.full = dfixed_mul(wm0->dbpp, wm0->num_line_pair);\n\t\telse\n\t\t\ta.full = wm0->num_line_pair.full;\n\t\tfill_rate.full = dfixed_div(wm0->sclk, a);\n\t\tif (wm0->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm0->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm0->active_time);\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\ta.full = a.full + b.full;\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark02.full = dfixed_div(a, b);\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm0->worst_case_latency,\n\t\t\t\t\t\twm0->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark02.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm0->priority_mark.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark.full;\n\t\tif (wm0->priority_mark_max.full > priority_mark02.full)\n\t\t\tpriority_mark02.full = wm0->priority_mark_max.full;\n\t\t*d1mode_priority_a_cnt = dfixed_trunc(priority_mark02);\n\t\tif (rdev->disp_priority == 2)\n\t\t\t*d1mode_priority_a_cnt |= S_006548_D1MODE_PRIORITY_A_ALWAYS_ON(1);\n\t} else if (mode1) {\n\t\tif (dfixed_trunc(wm1->dbpp) > 64)\n\t\t\ta.full = dfixed_mul(wm1->dbpp, wm1->num_line_pair);\n\t\telse\n\t\t\ta.full = wm1->num_line_pair.full;\n\t\tfill_rate.full = dfixed_div(wm1->sclk, a);\n\t\tif (wm1->consumption_rate.full > fill_rate.full) {\n\t\t\tb.full = wm1->consumption_rate.full - fill_rate.full;\n\t\t\tb.full = dfixed_mul(b, wm1->active_time);\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\ta.full = a.full + b.full;\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark12.full = dfixed_div(a, b);\n\t\t} else {\n\t\t\ta.full = dfixed_mul(wm1->worst_case_latency,\n\t\t\t\t\t\twm1->consumption_rate);\n\t\t\tb.full = dfixed_const(16 * 1000);\n\t\t\tpriority_mark12.full = dfixed_div(a, b);\n\t\t}\n\t\tif (wm1->priority_mark.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark.full;\n\t\tif (wm1->priority_mark_max.full > priority_mark12.full)\n\t\t\tpriority_mark12.full = wm1->priority_mark_max.full;\n\t\t*d2mode_priority_a_cnt = dfixed_trunc(priority_mark12);\n\t\tif (rdev->disp_priority == 2)\n\t\t\t*d2mode_priority_a_cnt |= S_006D48_D2MODE_PRIORITY_A_ALWAYS_ON(1);\n\t}\n}\n\nvoid rs690_bandwidth_update(struct radeon_device *rdev)\n{\n\tstruct drm_display_mode *mode0 = NULL;\n\tstruct drm_display_mode *mode1 = NULL;\n\tstruct rs690_watermark wm0_high, wm0_low;\n\tstruct rs690_watermark wm1_high, wm1_low;\n\tu32 tmp;\n\tu32 d1mode_priority_a_cnt, d1mode_priority_b_cnt;\n\tu32 d2mode_priority_a_cnt, d2mode_priority_b_cnt;\n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tif (rdev->mode_info.crtcs[0]->base.enabled)\n\t\tmode0 = &rdev->mode_info.crtcs[0]->base.mode;\n\tif (rdev->mode_info.crtcs[1]->base.enabled)\n\t\tmode1 = &rdev->mode_info.crtcs[1]->base.mode;\n\t \n\tif ((rdev->disp_priority == 2) &&\n\t    ((rdev->family == CHIP_RS690) || (rdev->family == CHIP_RS740))) {\n\t\ttmp = RREG32_MC(R_000104_MC_INIT_MISC_LAT_TIMER);\n\t\ttmp &= C_000104_MC_DISP0R_INIT_LAT;\n\t\ttmp &= C_000104_MC_DISP1R_INIT_LAT;\n\t\tif (mode0)\n\t\t\ttmp |= S_000104_MC_DISP0R_INIT_LAT(1);\n\t\tif (mode1)\n\t\t\ttmp |= S_000104_MC_DISP1R_INIT_LAT(1);\n\t\tWREG32_MC(R_000104_MC_INIT_MISC_LAT_TIMER, tmp);\n\t}\n\trs690_line_buffer_adjust(rdev, mode0, mode1);\n\n\tif ((rdev->family == CHIP_RS690) || (rdev->family == CHIP_RS740))\n\t\tWREG32(R_006C9C_DCP_CONTROL, 0);\n\tif ((rdev->family == CHIP_RS780) || (rdev->family == CHIP_RS880))\n\t\tWREG32(R_006C9C_DCP_CONTROL, 2);\n\n\trs690_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[0], &wm0_high, false);\n\trs690_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[1], &wm1_high, false);\n\n\trs690_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[0], &wm0_low, true);\n\trs690_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[1], &wm1_low, true);\n\n\ttmp = (wm0_high.lb_request_fifo_depth - 1);\n\ttmp |= (wm1_high.lb_request_fifo_depth - 1) << 16;\n\tWREG32(R_006D58_LB_MAX_REQ_OUTSTANDING, tmp);\n\n\trs690_compute_mode_priority(rdev,\n\t\t\t\t    &wm0_high, &wm1_high,\n\t\t\t\t    mode0, mode1,\n\t\t\t\t    &d1mode_priority_a_cnt, &d2mode_priority_a_cnt);\n\trs690_compute_mode_priority(rdev,\n\t\t\t\t    &wm0_low, &wm1_low,\n\t\t\t\t    mode0, mode1,\n\t\t\t\t    &d1mode_priority_b_cnt, &d2mode_priority_b_cnt);\n\n\tWREG32(R_006548_D1MODE_PRIORITY_A_CNT, d1mode_priority_a_cnt);\n\tWREG32(R_00654C_D1MODE_PRIORITY_B_CNT, d1mode_priority_b_cnt);\n\tWREG32(R_006D48_D2MODE_PRIORITY_A_CNT, d2mode_priority_a_cnt);\n\tWREG32(R_006D4C_D2MODE_PRIORITY_B_CNT, d2mode_priority_b_cnt);\n}\n\nuint32_t rs690_mc_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t r;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(R_000078_MC_INDEX, S_000078_MC_IND_ADDR(reg));\n\tr = RREG32(R_00007C_MC_DATA);\n\tWREG32(R_000078_MC_INDEX, ~C_000078_MC_IND_ADDR);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n\treturn r;\n}\n\nvoid rs690_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(R_000078_MC_INDEX, S_000078_MC_IND_ADDR(reg) |\n\t\tS_000078_MC_IND_WR_EN(1));\n\tWREG32(R_00007C_MC_DATA, v);\n\tWREG32(R_000078_MC_INDEX, 0x7F);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n}\n\nstatic void rs690_mc_program(struct radeon_device *rdev)\n{\n\tstruct rv515_mc_save save;\n\n\t \n\trv515_mc_stop(rdev, &save);\n\n\t \n\tif (rs690_mc_wait_for_idle(rdev))\n\t\tdev_warn(rdev->dev, \"Wait MC idle timeout before updating MC.\\n\");\n\t \n\tWREG32_MC(R_000100_MCCFG_FB_LOCATION,\n\t\t\tS_000100_MC_FB_START(rdev->mc.vram_start >> 16) |\n\t\t\tS_000100_MC_FB_TOP(rdev->mc.vram_end >> 16));\n\tWREG32(R_000134_HDP_FB_LOCATION,\n\t\tS_000134_HDP_FB_START(rdev->mc.vram_start >> 16));\n\n\trv515_mc_resume(rdev, &save);\n}\n\nstatic int rs690_startup(struct radeon_device *rdev)\n{\n\tint r;\n\n\trs690_mc_program(rdev);\n\t \n\trv515_clock_startup(rdev);\n\t \n\trs690_gpu_init(rdev);\n\t \n\tr = rs400_gart_enable(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\trs600_irq_set(rdev);\n\trdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\n\t \n\tr = r100_cp_init(rdev, 1024 * 1024);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_audio_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing audio\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint rs690_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\trs400_gart_disable(rdev);\n\t \n\trv515_clock_startup(rdev);\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev, \"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tatom_asic_init(rdev->mode_info.atom_context);\n\t \n\trv515_clock_startup(rdev);\n\t \n\tradeon_surface_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rs690_startup(rdev);\n\tif (r) {\n\t\trdev->accel_working = false;\n\t}\n\treturn r;\n}\n\nint rs690_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tradeon_audio_fini(rdev);\n\tr100_cp_disable(rdev);\n\tradeon_wb_disable(rdev);\n\trs600_irq_disable(rdev);\n\trs400_gart_disable(rdev);\n\treturn 0;\n}\n\nvoid rs690_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tradeon_audio_fini(rdev);\n\tr100_cp_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_gem_fini(rdev);\n\trs400_gart_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nint rs690_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\trv515_vga_render_disable(rdev);\n\t \n\tradeon_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tr100_restore_sanity(rdev);\n\t \n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rdev->is_atom_bios) {\n\t\tr = radeon_atombios_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t} else {\n\t\tdev_err(rdev->dev, \"Expecting atombios for RV515 GPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev,\n\t\t\t\"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tif (radeon_boot_test_post_card(rdev) == false)\n\t\treturn -EINVAL;\n\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\trs690_mc_init(rdev);\n\trv515_debugfs(rdev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\tr = rs400_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trs600_set_safe_registers(rdev);\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rs690_startup(rdev);\n\tif (r) {\n\t\t \n\t\tdev_err(rdev->dev, \"Disabling GPU acceleration\\n\");\n\t\tr100_cp_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\trs400_gart_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}