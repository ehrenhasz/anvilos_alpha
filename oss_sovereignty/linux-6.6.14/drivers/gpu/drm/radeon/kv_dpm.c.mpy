{
  "module_name": "kv_dpm.c",
  "hash_id": "0399017375f02ab491444c4f0fe0280c554df84ad116ef114692fb95ccd78f22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/kv_dpm.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n\n#include \"cikd.h\"\n#include \"kv_dpm.h\"\n#include \"r600_dpm.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n\n#define KV_MAX_DEEPSLEEP_DIVIDER_ID     5\n#define KV_MINIMUM_ENGINE_CLOCK         800\n#define SMC_RAM_END                     0x40000\n\nstatic int kv_enable_nb_dpm(struct radeon_device *rdev,\n\t\t\t    bool enable);\nstatic void kv_init_graphics_levels(struct radeon_device *rdev);\nstatic int kv_calculate_ds_divider(struct radeon_device *rdev);\nstatic int kv_calculate_nbps_level_settings(struct radeon_device *rdev);\nstatic int kv_calculate_dpm_settings(struct radeon_device *rdev);\nstatic void kv_enable_new_levels(struct radeon_device *rdev);\nstatic void kv_program_nbps_index_settings(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *new_rps);\nstatic int kv_set_enabled_level(struct radeon_device *rdev, u32 level);\nstatic int kv_set_enabled_levels(struct radeon_device *rdev);\nstatic int kv_force_dpm_highest(struct radeon_device *rdev);\nstatic int kv_force_dpm_lowest(struct radeon_device *rdev);\nstatic void kv_apply_state_adjust_rules(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_ps *new_rps,\n\t\t\t\t\tstruct radeon_ps *old_rps);\nstatic int kv_set_thermal_temperature_range(struct radeon_device *rdev,\n\t\t\t\t\t    int min_temp, int max_temp);\nstatic int kv_init_fps_limits(struct radeon_device *rdev);\n\nvoid kv_dpm_powergate_uvd(struct radeon_device *rdev, bool gate);\nstatic void kv_dpm_powergate_vce(struct radeon_device *rdev, bool gate);\nstatic void kv_dpm_powergate_samu(struct radeon_device *rdev, bool gate);\nstatic void kv_dpm_powergate_acp(struct radeon_device *rdev, bool gate);\n\nextern void cik_enter_rlc_safe_mode(struct radeon_device *rdev);\nextern void cik_exit_rlc_safe_mode(struct radeon_device *rdev);\nextern void cik_update_cg(struct radeon_device *rdev,\n\t\t\t  u32 block, bool enable);\n\nstatic const struct kv_pt_config_reg didt_config_kv[] =\n{\n\t{ 0x10, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x10, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x10, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x10, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x11, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x11, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x11, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x11, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x12, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x12, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x12, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x12, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x2, 0x00003fff, 0, 0x4, KV_CONFIGREG_DIDT_IND },\n\t{ 0x2, 0x03ff0000, 16, 0x80, KV_CONFIGREG_DIDT_IND },\n\t{ 0x2, 0x78000000, 27, 0x3, KV_CONFIGREG_DIDT_IND },\n\t{ 0x1, 0x0000ffff, 0, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x1, 0xffff0000, 16, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x0, 0x00000001, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x30, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x30, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x30, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x30, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x31, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x31, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x31, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x31, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x32, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x32, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x32, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x32, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x22, 0x00003fff, 0, 0x4, KV_CONFIGREG_DIDT_IND },\n\t{ 0x22, 0x03ff0000, 16, 0x80, KV_CONFIGREG_DIDT_IND },\n\t{ 0x22, 0x78000000, 27, 0x3, KV_CONFIGREG_DIDT_IND },\n\t{ 0x21, 0x0000ffff, 0, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x21, 0xffff0000, 16, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x20, 0x00000001, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x50, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x50, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x50, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x50, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x51, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x51, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x51, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x51, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x52, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x52, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x52, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x52, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x42, 0x00003fff, 0, 0x4, KV_CONFIGREG_DIDT_IND },\n\t{ 0x42, 0x03ff0000, 16, 0x80, KV_CONFIGREG_DIDT_IND },\n\t{ 0x42, 0x78000000, 27, 0x3, KV_CONFIGREG_DIDT_IND },\n\t{ 0x41, 0x0000ffff, 0, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x41, 0xffff0000, 16, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x40, 0x00000001, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x70, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x70, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x70, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x70, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x71, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x71, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x71, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x71, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x72, 0x000000ff, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x72, 0x0000ff00, 8, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x72, 0x00ff0000, 16, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x72, 0xff000000, 24, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0x62, 0x00003fff, 0, 0x4, KV_CONFIGREG_DIDT_IND },\n\t{ 0x62, 0x03ff0000, 16, 0x80, KV_CONFIGREG_DIDT_IND },\n\t{ 0x62, 0x78000000, 27, 0x3, KV_CONFIGREG_DIDT_IND },\n\t{ 0x61, 0x0000ffff, 0, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x61, 0xffff0000, 16, 0x3FFF, KV_CONFIGREG_DIDT_IND },\n\t{ 0x60, 0x00000001, 0, 0x0, KV_CONFIGREG_DIDT_IND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic struct kv_ps *kv_get_ps(struct radeon_ps *rps)\n{\n\tstruct kv_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstatic struct kv_power_info *kv_get_pi(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic int kv_program_pt_config_registers(struct radeon_device *rdev,\n\t\t\t\t\t  const struct kv_pt_config_reg *cac_config_regs)\n{\n\tconst struct kv_pt_config_reg *config_regs = cac_config_regs;\n\tu32 data;\n\tu32 cache = 0;\n\n\tif (config_regs == NULL)\n\t\treturn -EINVAL;\n\n\twhile (config_regs->offset != 0xFFFFFFFF) {\n\t\tif (config_regs->type == KV_CONFIGREG_CACHE) {\n\t\t\tcache |= ((config_regs->value << config_regs->shift) & config_regs->mask);\n\t\t} else {\n\t\t\tswitch (config_regs->type) {\n\t\t\tcase KV_CONFIGREG_SMC_IND:\n\t\t\t\tdata = RREG32_SMC(config_regs->offset);\n\t\t\t\tbreak;\n\t\t\tcase KV_CONFIGREG_DIDT_IND:\n\t\t\t\tdata = RREG32_DIDT(config_regs->offset);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdata = RREG32(config_regs->offset << 2);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdata &= ~config_regs->mask;\n\t\t\tdata |= ((config_regs->value << config_regs->shift) & config_regs->mask);\n\t\t\tdata |= cache;\n\t\t\tcache = 0;\n\n\t\t\tswitch (config_regs->type) {\n\t\t\tcase KV_CONFIGREG_SMC_IND:\n\t\t\t\tWREG32_SMC(config_regs->offset, data);\n\t\t\t\tbreak;\n\t\t\tcase KV_CONFIGREG_DIDT_IND:\n\t\t\t\tWREG32_DIDT(config_regs->offset, data);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWREG32(config_regs->offset << 2, data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconfig_regs++;\n\t}\n\n\treturn 0;\n}\n\nstatic void kv_do_enable_didt(struct radeon_device *rdev, bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 data;\n\n\tif (pi->caps_sq_ramping) {\n\t\tdata = RREG32_DIDT(DIDT_SQ_CTRL0);\n\t\tif (enable)\n\t\t\tdata |= DIDT_CTRL_EN;\n\t\telse\n\t\t\tdata &= ~DIDT_CTRL_EN;\n\t\tWREG32_DIDT(DIDT_SQ_CTRL0, data);\n\t}\n\n\tif (pi->caps_db_ramping) {\n\t\tdata = RREG32_DIDT(DIDT_DB_CTRL0);\n\t\tif (enable)\n\t\t\tdata |= DIDT_CTRL_EN;\n\t\telse\n\t\t\tdata &= ~DIDT_CTRL_EN;\n\t\tWREG32_DIDT(DIDT_DB_CTRL0, data);\n\t}\n\n\tif (pi->caps_td_ramping) {\n\t\tdata = RREG32_DIDT(DIDT_TD_CTRL0);\n\t\tif (enable)\n\t\t\tdata |= DIDT_CTRL_EN;\n\t\telse\n\t\t\tdata &= ~DIDT_CTRL_EN;\n\t\tWREG32_DIDT(DIDT_TD_CTRL0, data);\n\t}\n\n\tif (pi->caps_tcp_ramping) {\n\t\tdata = RREG32_DIDT(DIDT_TCP_CTRL0);\n\t\tif (enable)\n\t\t\tdata |= DIDT_CTRL_EN;\n\t\telse\n\t\t\tdata &= ~DIDT_CTRL_EN;\n\t\tWREG32_DIDT(DIDT_TCP_CTRL0, data);\n\t}\n}\n\nstatic int kv_enable_didt(struct radeon_device *rdev, bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tif (pi->caps_sq_ramping ||\n\t    pi->caps_db_ramping ||\n\t    pi->caps_td_ramping ||\n\t    pi->caps_tcp_ramping) {\n\t\tcik_enter_rlc_safe_mode(rdev);\n\n\t\tif (enable) {\n\t\t\tret = kv_program_pt_config_registers(rdev, didt_config_kv);\n\t\t\tif (ret) {\n\t\t\t\tcik_exit_rlc_safe_mode(rdev);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tkv_do_enable_didt(rdev, enable);\n\n\t\tcik_exit_rlc_safe_mode(rdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int kv_enable_smc_cac(struct radeon_device *rdev, bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret = 0;\n\n\tif (pi->caps_cac) {\n\t\tif (enable) {\n\t\t\tret = kv_notify_message_to_smu(rdev, PPSMC_MSG_EnableCac);\n\t\t\tif (ret)\n\t\t\t\tpi->cac_enabled = false;\n\t\t\telse\n\t\t\t\tpi->cac_enabled = true;\n\t\t} else if (pi->cac_enabled) {\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_DisableCac);\n\t\t\tpi->cac_enabled = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int kv_process_firmware_header(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 tmp;\n\tint ret;\n\n\tret = kv_read_smc_sram_dword(rdev, SMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t     offsetof(SMU7_Firmware_Header, DpmTable),\n\t\t\t\t     &tmp, pi->sram_end);\n\n\tif (ret == 0)\n\t\tpi->dpm_table_start = tmp;\n\n\tret = kv_read_smc_sram_dword(rdev, SMU7_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t     offsetof(SMU7_Firmware_Header, SoftRegisters),\n\t\t\t\t     &tmp, pi->sram_end);\n\n\tif (ret == 0)\n\t\tpi->soft_regs_start = tmp;\n\n\treturn ret;\n}\n\nstatic int kv_enable_dpm_voltage_scaling(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tpi->graphics_voltage_change_enable = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, GraphicsVoltageChangeEnable),\n\t\t\t\t   &pi->graphics_voltage_change_enable,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\n\treturn ret;\n}\n\nstatic int kv_set_dpm_interval(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tpi->graphics_interval = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, GraphicsInterval),\n\t\t\t\t   &pi->graphics_interval,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\n\treturn ret;\n}\n\nstatic int kv_set_dpm_boot_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, GraphicsBootLevel),\n\t\t\t\t   &pi->graphics_boot_level,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\n\treturn ret;\n}\n\nstatic void kv_program_vc(struct radeon_device *rdev)\n{\n\tWREG32_SMC(CG_FTV_0, 0x3FFFC100);\n}\n\nstatic void kv_clear_vc(struct radeon_device *rdev)\n{\n\tWREG32_SMC(CG_FTV_0, 0);\n}\n\nstatic int kv_set_divider_value(struct radeon_device *rdev,\n\t\t\t\tu32 index, u32 sclk)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     sclk, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->graphics_level[index].SclkDid = (u8)dividers.post_div;\n\tpi->graphics_level[index].SclkFrequency = cpu_to_be32(sclk);\n\n\treturn 0;\n}\n\nstatic u32 kv_convert_vid2_to_vid7(struct radeon_device *rdev,\n\t\t\t\t   struct sumo_vid_mapping_table *vid_mapping_table,\n\t\t\t\t   u32 vid_2bit)\n{\n\tstruct radeon_clock_voltage_dependency_table *vddc_sclk_table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\tu32 i;\n\n\tif (vddc_sclk_table && vddc_sclk_table->count) {\n\t\tif (vid_2bit < vddc_sclk_table->count)\n\t\t\treturn vddc_sclk_table->entries[vid_2bit].v;\n\t\telse\n\t\t\treturn vddc_sclk_table->entries[vddc_sclk_table->count - 1].v;\n\t} else {\n\t\tfor (i = 0; i < vid_mapping_table->num_entries; i++) {\n\t\t\tif (vid_mapping_table->entries[i].vid_2bit == vid_2bit)\n\t\t\t\treturn vid_mapping_table->entries[i].vid_7bit;\n\t\t}\n\t\treturn vid_mapping_table->entries[vid_mapping_table->num_entries - 1].vid_7bit;\n\t}\n}\n\nstatic u32 kv_convert_vid7_to_vid2(struct radeon_device *rdev,\n\t\t\t\t   struct sumo_vid_mapping_table *vid_mapping_table,\n\t\t\t\t   u32 vid_7bit)\n{\n\tstruct radeon_clock_voltage_dependency_table *vddc_sclk_table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\tu32 i;\n\n\tif (vddc_sclk_table && vddc_sclk_table->count) {\n\t\tfor (i = 0; i < vddc_sclk_table->count; i++) {\n\t\t\tif (vddc_sclk_table->entries[i].v == vid_7bit)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn vddc_sclk_table->count - 1;\n\t} else {\n\t\tfor (i = 0; i < vid_mapping_table->num_entries; i++) {\n\t\t\tif (vid_mapping_table->entries[i].vid_7bit == vid_7bit)\n\t\t\t\treturn vid_mapping_table->entries[i].vid_2bit;\n\t\t}\n\n\t\treturn vid_mapping_table->entries[vid_mapping_table->num_entries - 1].vid_2bit;\n\t}\n}\n\nstatic u16 kv_convert_8bit_index_to_voltage(struct radeon_device *rdev,\n\t\t\t\t\t    u16 voltage)\n{\n\treturn 6200 - (voltage * 25);\n}\n\nstatic u16 kv_convert_2bit_index_to_voltage(struct radeon_device *rdev,\n\t\t\t\t\t    u32 vid_2bit)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 vid_8bit = kv_convert_vid2_to_vid7(rdev,\n\t\t\t\t\t       &pi->sys_info.vid_mapping_table,\n\t\t\t\t\t       vid_2bit);\n\n\treturn kv_convert_8bit_index_to_voltage(rdev, (u16)vid_8bit);\n}\n\n\nstatic int kv_set_vid(struct radeon_device *rdev, u32 index, u32 vid)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->graphics_level[index].VoltageDownH = (u8)pi->voltage_drop_t;\n\tpi->graphics_level[index].MinVddNb =\n\t\tcpu_to_be32(kv_convert_2bit_index_to_voltage(rdev, vid));\n\n\treturn 0;\n}\n\nstatic int kv_set_at(struct radeon_device *rdev, u32 index, u32 at)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->graphics_level[index].AT = cpu_to_be16((u16)at);\n\n\treturn 0;\n}\n\nstatic void kv_dpm_power_level_enable(struct radeon_device *rdev,\n\t\t\t\t      u32 index, bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->graphics_level[index].EnabledForActivity = enable ? 1 : 0;\n}\n\nstatic void kv_start_dpm(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(GENERAL_PWRMGT);\n\n\ttmp |= GLOBAL_PWRMGT_EN;\n\tWREG32_SMC(GENERAL_PWRMGT, tmp);\n\n\tkv_smc_dpm_enable(rdev, true);\n}\n\nstatic void kv_stop_dpm(struct radeon_device *rdev)\n{\n\tkv_smc_dpm_enable(rdev, false);\n}\n\nstatic void kv_start_am(struct radeon_device *rdev)\n{\n\tu32 sclk_pwrmgt_cntl = RREG32_SMC(SCLK_PWRMGT_CNTL);\n\n\tsclk_pwrmgt_cntl &= ~(RESET_SCLK_CNT | RESET_BUSY_CNT);\n\tsclk_pwrmgt_cntl |= DYNAMIC_PM_EN;\n\n\tWREG32_SMC(SCLK_PWRMGT_CNTL, sclk_pwrmgt_cntl);\n}\n\nstatic void kv_reset_am(struct radeon_device *rdev)\n{\n\tu32 sclk_pwrmgt_cntl = RREG32_SMC(SCLK_PWRMGT_CNTL);\n\n\tsclk_pwrmgt_cntl |= (RESET_SCLK_CNT | RESET_BUSY_CNT);\n\n\tWREG32_SMC(SCLK_PWRMGT_CNTL, sclk_pwrmgt_cntl);\n}\n\nstatic int kv_freeze_sclk_dpm(struct radeon_device *rdev, bool freeze)\n{\n\treturn kv_notify_message_to_smu(rdev, freeze ?\n\t\t\t\t\tPPSMC_MSG_SCLKDPM_FreezeLevel : PPSMC_MSG_SCLKDPM_UnfreezeLevel);\n}\n\nstatic int kv_force_lowest_valid(struct radeon_device *rdev)\n{\n\treturn kv_force_dpm_lowest(rdev);\n}\n\nstatic int kv_unforce_levels(struct radeon_device *rdev)\n{\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS)\n\t\treturn kv_notify_message_to_smu(rdev, PPSMC_MSG_NoForcedLevel);\n\telse\n\t\treturn kv_set_enabled_levels(rdev);\n}\n\nstatic int kv_update_sclk_t(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 low_sclk_interrupt_t = 0;\n\tint ret = 0;\n\n\tif (pi->caps_sclk_throttle_low_notification) {\n\t\tlow_sclk_interrupt_t = cpu_to_be32(pi->low_sclk_interrupt_t);\n\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, LowSclkInterruptT),\n\t\t\t\t\t   (u8 *)&low_sclk_interrupt_t,\n\t\t\t\t\t   sizeof(u32), pi->sram_end);\n\t}\n\treturn ret;\n}\n\nstatic int kv_program_bootup_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\n\tif (table && table->count) {\n\t\tfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\n\t\t\tif (table->entries[i].clk == pi->boot_pl.sclk)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpi->graphics_boot_level = (u8)i;\n\t\tkv_dpm_power_level_enable(rdev, i, true);\n\t} else {\n\t\tstruct sumo_sclk_voltage_mapping_table *table =\n\t\t\t&pi->sys_info.sclk_voltage_mapping_table;\n\n\t\tif (table->num_max_dpm_entries == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\n\t\t\tif (table->entries[i].sclk_frequency == pi->boot_pl.sclk)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpi->graphics_boot_level = (u8)i;\n\t\tkv_dpm_power_level_enable(rdev, i, true);\n\t}\n\treturn 0;\n}\n\nstatic int kv_enable_auto_thermal_throttling(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tpi->graphics_therm_throttle_enable = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, GraphicsThermThrottleEnable),\n\t\t\t\t   &pi->graphics_therm_throttle_enable,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\n\treturn ret;\n}\n\nstatic int kv_upload_dpm_settings(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, GraphicsLevel),\n\t\t\t\t   (u8 *)&pi->graphics_level,\n\t\t\t\t   sizeof(SMU7_Fusion_GraphicsLevel) * SMU7_MAX_LEVELS_GRAPHICS,\n\t\t\t\t   pi->sram_end);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, GraphicsDpmLevelCount),\n\t\t\t\t   &pi->graphics_dpm_level_count,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\n\treturn ret;\n}\n\nstatic u32 kv_get_clock_difference(u32 a, u32 b)\n{\n\treturn (a >= b) ? a - b : b - a;\n}\n\nstatic u32 kv_get_clk_bypass(struct radeon_device *rdev, u32 clk)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 value;\n\n\tif (pi->caps_enable_dfs_bypass) {\n\t\tif (kv_get_clock_difference(clk, 40000) < 200)\n\t\t\tvalue = 3;\n\t\telse if (kv_get_clock_difference(clk, 30000) < 200)\n\t\t\tvalue = 2;\n\t\telse if (kv_get_clock_difference(clk, 20000) < 200)\n\t\t\tvalue = 7;\n\t\telse if (kv_get_clock_difference(clk, 15000) < 200)\n\t\t\tvalue = 6;\n\t\telse if (kv_get_clock_difference(clk, 10000) < 200)\n\t\t\tvalue = 8;\n\t\telse\n\t\t\tvalue = 0;\n\t} else {\n\t\tvalue = 0;\n\t}\n\n\treturn value;\n}\n\nstatic int kv_populate_uvd_table(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_uvd_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\tu32 i;\n\n\tif (table == NULL || table->count == 0)\n\t\treturn 0;\n\n\tpi->uvd_level_count = 0;\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (pi->high_voltage_t &&\n\t\t    (pi->high_voltage_t < table->entries[i].v))\n\t\t\tbreak;\n\n\t\tpi->uvd_level[i].VclkFrequency = cpu_to_be32(table->entries[i].vclk);\n\t\tpi->uvd_level[i].DclkFrequency = cpu_to_be32(table->entries[i].dclk);\n\t\tpi->uvd_level[i].MinVddNb = cpu_to_be16(table->entries[i].v);\n\n\t\tpi->uvd_level[i].VClkBypassCntl =\n\t\t\t(u8)kv_get_clk_bypass(rdev, table->entries[i].vclk);\n\t\tpi->uvd_level[i].DClkBypassCntl =\n\t\t\t(u8)kv_get_clk_bypass(rdev, table->entries[i].dclk);\n\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     table->entries[i].vclk, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpi->uvd_level[i].VclkDivider = (u8)dividers.post_div;\n\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     table->entries[i].dclk, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpi->uvd_level[i].DclkDivider = (u8)dividers.post_div;\n\n\t\tpi->uvd_level_count++;\n\t}\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, UvdLevelCount),\n\t\t\t\t   (u8 *)&pi->uvd_level_count,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->uvd_interval = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, UVDInterval),\n\t\t\t\t   &pi->uvd_interval,\n\t\t\t\t   sizeof(u8), pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, UvdLevel),\n\t\t\t\t   (u8 *)&pi->uvd_level,\n\t\t\t\t   sizeof(SMU7_Fusion_UvdLevel) * SMU7_MAX_LEVELS_UVD,\n\t\t\t\t   pi->sram_end);\n\n\treturn ret;\n\n}\n\nstatic int kv_populate_vce_table(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\tu32 i;\n\tstruct radeon_vce_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\n\tstruct atom_clock_dividers dividers;\n\n\tif (table == NULL || table->count == 0)\n\t\treturn 0;\n\n\tpi->vce_level_count = 0;\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (pi->high_voltage_t &&\n\t\t    pi->high_voltage_t < table->entries[i].v)\n\t\t\tbreak;\n\n\t\tpi->vce_level[i].Frequency = cpu_to_be32(table->entries[i].evclk);\n\t\tpi->vce_level[i].MinVoltage = cpu_to_be16(table->entries[i].v);\n\n\t\tpi->vce_level[i].ClkBypassCntl =\n\t\t\t(u8)kv_get_clk_bypass(rdev, table->entries[i].evclk);\n\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     table->entries[i].evclk, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpi->vce_level[i].Divider = (u8)dividers.post_div;\n\n\t\tpi->vce_level_count++;\n\t}\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, VceLevelCount),\n\t\t\t\t   (u8 *)&pi->vce_level_count,\n\t\t\t\t   sizeof(u8),\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->vce_interval = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, VCEInterval),\n\t\t\t\t   (u8 *)&pi->vce_interval,\n\t\t\t\t   sizeof(u8),\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, VceLevel),\n\t\t\t\t   (u8 *)&pi->vce_level,\n\t\t\t\t   sizeof(SMU7_Fusion_ExtClkLevel) * SMU7_MAX_LEVELS_VCE,\n\t\t\t\t   pi->sram_end);\n\n\treturn ret;\n}\n\nstatic int kv_populate_samu_table(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\tu32 i;\n\n\tif (table == NULL || table->count == 0)\n\t\treturn 0;\n\n\tpi->samu_level_count = 0;\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (pi->high_voltage_t &&\n\t\t    pi->high_voltage_t < table->entries[i].v)\n\t\t\tbreak;\n\n\t\tpi->samu_level[i].Frequency = cpu_to_be32(table->entries[i].clk);\n\t\tpi->samu_level[i].MinVoltage = cpu_to_be16(table->entries[i].v);\n\n\t\tpi->samu_level[i].ClkBypassCntl =\n\t\t\t(u8)kv_get_clk_bypass(rdev, table->entries[i].clk);\n\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     table->entries[i].clk, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpi->samu_level[i].Divider = (u8)dividers.post_div;\n\n\t\tpi->samu_level_count++;\n\t}\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, SamuLevelCount),\n\t\t\t\t   (u8 *)&pi->samu_level_count,\n\t\t\t\t   sizeof(u8),\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->samu_interval = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, SAMUInterval),\n\t\t\t\t   (u8 *)&pi->samu_interval,\n\t\t\t\t   sizeof(u8),\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, SamuLevel),\n\t\t\t\t   (u8 *)&pi->samu_level,\n\t\t\t\t   sizeof(SMU7_Fusion_ExtClkLevel) * SMU7_MAX_LEVELS_SAMU,\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\n\nstatic int kv_populate_acp_table(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\tu32 i;\n\n\tif (table == NULL || table->count == 0)\n\t\treturn 0;\n\n\tpi->acp_level_count = 0;\n\tfor (i = 0; i < table->count; i++) {\n\t\tpi->acp_level[i].Frequency = cpu_to_be32(table->entries[i].clk);\n\t\tpi->acp_level[i].MinVoltage = cpu_to_be16(table->entries[i].v);\n\n\t\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t\t     table->entries[i].clk, false, &dividers);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tpi->acp_level[i].Divider = (u8)dividers.post_div;\n\n\t\tpi->acp_level_count++;\n\t}\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, AcpLevelCount),\n\t\t\t\t   (u8 *)&pi->acp_level_count,\n\t\t\t\t   sizeof(u8),\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->acp_interval = 1;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, ACPInterval),\n\t\t\t\t   (u8 *)&pi->acp_interval,\n\t\t\t\t   sizeof(u8),\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, AcpLevel),\n\t\t\t\t   (u8 *)&pi->acp_level,\n\t\t\t\t   sizeof(SMU7_Fusion_ExtClkLevel) * SMU7_MAX_LEVELS_ACP,\n\t\t\t\t   pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic void kv_calculate_dfs_bypass_settings(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\n\tif (table && table->count) {\n\t\tfor (i = 0; i < pi->graphics_dpm_level_count; i++) {\n\t\t\tif (pi->caps_enable_dfs_bypass) {\n\t\t\t\tif (kv_get_clock_difference(table->entries[i].clk, 40000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 3;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].clk, 30000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 2;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].clk, 26600) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 7;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].clk , 20000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 6;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].clk , 10000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 8;\n\t\t\t\telse\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 0;\n\t\t\t} else {\n\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct sumo_sclk_voltage_mapping_table *table =\n\t\t\t&pi->sys_info.sclk_voltage_mapping_table;\n\t\tfor (i = 0; i < pi->graphics_dpm_level_count; i++) {\n\t\t\tif (pi->caps_enable_dfs_bypass) {\n\t\t\t\tif (kv_get_clock_difference(table->entries[i].sclk_frequency, 40000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 3;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 30000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 2;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 26600) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 7;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 20000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 6;\n\t\t\t\telse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 10000) < 200)\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 8;\n\t\t\t\telse\n\t\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 0;\n\t\t\t} else {\n\t\t\t\tpi->graphics_level[i].ClkBypassCntl = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int kv_enable_ulv(struct radeon_device *rdev, bool enable)\n{\n\treturn kv_notify_message_to_smu(rdev, enable ?\n\t\t\t\t\tPPSMC_MSG_EnableULV : PPSMC_MSG_DisableULV);\n}\n\nstatic void kv_reset_acp_boot_level(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->acp_boot_level = 0xff;\n}\n\nstatic void kv_update_current_ps(struct radeon_device *rdev,\n\t\t\t\t struct radeon_ps *rps)\n{\n\tstruct kv_ps *new_ps = kv_get_ps(rps);\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->current_rps = *rps;\n\tpi->current_ps = *new_ps;\n\tpi->current_rps.ps_priv = &pi->current_ps;\n}\n\nstatic void kv_update_requested_ps(struct radeon_device *rdev,\n\t\t\t\t   struct radeon_ps *rps)\n{\n\tstruct kv_ps *new_ps = kv_get_ps(rps);\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->requested_rps = *rps;\n\tpi->requested_ps = *new_ps;\n\tpi->requested_rps.ps_priv = &pi->requested_ps;\n}\n\nvoid kv_dpm_enable_bapm(struct radeon_device *rdev, bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tif (pi->bapm_enable) {\n\t\tret = kv_smc_bapm_enable(rdev, enable);\n\t\tif (ret)\n\t\t\tDRM_ERROR(\"kv_smc_bapm_enable failed\\n\");\n\t}\n}\n\nstatic void kv_enable_thermal_int(struct radeon_device *rdev, bool enable)\n{\n\tu32 thermal_int;\n\n\tthermal_int = RREG32_SMC(CG_THERMAL_INT_CTRL);\n\tif (enable)\n\t\tthermal_int |= THERM_INTH_MASK | THERM_INTL_MASK;\n\telse\n\t\tthermal_int &= ~(THERM_INTH_MASK | THERM_INTL_MASK);\n\tWREG32_SMC(CG_THERMAL_INT_CTRL, thermal_int);\n\n}\n\nint kv_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret;\n\n\tret = kv_process_firmware_header(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_process_firmware_header failed\\n\");\n\t\treturn ret;\n\t}\n\tkv_init_fps_limits(rdev);\n\tkv_init_graphics_levels(rdev);\n\tret = kv_program_bootup_state(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_program_bootup_state failed\\n\");\n\t\treturn ret;\n\t}\n\tkv_calculate_dfs_bypass_settings(rdev);\n\tret = kv_upload_dpm_settings(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_upload_dpm_settings failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_populate_uvd_table(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_populate_uvd_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_populate_vce_table(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_populate_vce_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_populate_samu_table(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_populate_samu_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_populate_acp_table(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_populate_acp_table failed\\n\");\n\t\treturn ret;\n\t}\n\tkv_program_vc(rdev);\n\n\tkv_start_am(rdev);\n\tif (pi->enable_auto_thermal_throttling) {\n\t\tret = kv_enable_auto_thermal_throttling(rdev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"kv_enable_auto_thermal_throttling failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = kv_enable_dpm_voltage_scaling(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_enable_dpm_voltage_scaling failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_set_dpm_interval(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_set_dpm_interval failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_set_dpm_boot_state(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_set_dpm_boot_state failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_enable_ulv(rdev, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_enable_ulv failed\\n\");\n\t\treturn ret;\n\t}\n\tkv_start_dpm(rdev);\n\tret = kv_enable_didt(rdev, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_enable_didt failed\\n\");\n\t\treturn ret;\n\t}\n\tret = kv_enable_smc_cac(rdev, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_enable_smc_cac failed\\n\");\n\t\treturn ret;\n\t}\n\n\tkv_reset_acp_boot_level(rdev);\n\n\tret = kv_smc_bapm_enable(rdev, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"kv_smc_bapm_enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tkv_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\n\n\treturn ret;\n}\n\nint kv_dpm_late_enable(struct radeon_device *rdev)\n{\n\tint ret = 0;\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\tret = kv_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"kv_set_thermal_temperature_range failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tkv_enable_thermal_int(rdev, true);\n\t}\n\n\t \n\tkv_dpm_powergate_acp(rdev, true);\n\tkv_dpm_powergate_samu(rdev, true);\n\tkv_dpm_powergate_vce(rdev, true);\n\tkv_dpm_powergate_uvd(rdev, true);\n\n\treturn ret;\n}\n\nvoid kv_dpm_disable(struct radeon_device *rdev)\n{\n\tkv_smc_bapm_enable(rdev, false);\n\n\tif (rdev->family == CHIP_MULLINS)\n\t\tkv_enable_nb_dpm(rdev, false);\n\n\t \n\tkv_dpm_powergate_acp(rdev, false);\n\tkv_dpm_powergate_samu(rdev, false);\n\tkv_dpm_powergate_vce(rdev, false);\n\tkv_dpm_powergate_uvd(rdev, false);\n\n\tkv_enable_smc_cac(rdev, false);\n\tkv_enable_didt(rdev, false);\n\tkv_clear_vc(rdev);\n\tkv_stop_dpm(rdev);\n\tkv_enable_ulv(rdev, false);\n\tkv_reset_am(rdev);\n\tkv_enable_thermal_int(rdev, false);\n\n\tkv_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\n}\n\nstatic void kv_init_sclk_t(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->low_sclk_interrupt_t = 0;\n}\n\nstatic int kv_init_fps_limits(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret = 0;\n\n\tif (pi->caps_fps) {\n\t\tu16 tmp;\n\n\t\ttmp = 45;\n\t\tpi->fps_high_t = cpu_to_be16(tmp);\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, FpsHighT),\n\t\t\t\t\t   (u8 *)&pi->fps_high_t,\n\t\t\t\t\t   sizeof(u16), pi->sram_end);\n\n\t\ttmp = 30;\n\t\tpi->fps_low_t = cpu_to_be16(tmp);\n\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, FpsLowT),\n\t\t\t\t\t   (u8 *)&pi->fps_low_t,\n\t\t\t\t\t   sizeof(u16), pi->sram_end);\n\n\t}\n\treturn ret;\n}\n\nstatic void kv_init_powergate_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->uvd_power_gated = false;\n\tpi->vce_power_gated = false;\n\tpi->samu_power_gated = false;\n\tpi->acp_power_gated = false;\n\n}\n\nstatic int kv_enable_uvd_dpm(struct radeon_device *rdev, bool enable)\n{\n\treturn kv_notify_message_to_smu(rdev, enable ?\n\t\t\t\t\tPPSMC_MSG_UVDDPM_Enable : PPSMC_MSG_UVDDPM_Disable);\n}\n\nstatic int kv_enable_vce_dpm(struct radeon_device *rdev, bool enable)\n{\n\treturn kv_notify_message_to_smu(rdev, enable ?\n\t\t\t\t\tPPSMC_MSG_VCEDPM_Enable : PPSMC_MSG_VCEDPM_Disable);\n}\n\nstatic int kv_enable_samu_dpm(struct radeon_device *rdev, bool enable)\n{\n\treturn kv_notify_message_to_smu(rdev, enable ?\n\t\t\t\t\tPPSMC_MSG_SAMUDPM_Enable : PPSMC_MSG_SAMUDPM_Disable);\n}\n\nstatic int kv_enable_acp_dpm(struct radeon_device *rdev, bool enable)\n{\n\treturn kv_notify_message_to_smu(rdev, enable ?\n\t\t\t\t\tPPSMC_MSG_ACPDPM_Enable : PPSMC_MSG_ACPDPM_Disable);\n}\n\nstatic int kv_update_uvd_dpm(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_uvd_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table;\n\tint ret;\n\tu32 mask;\n\n\tif (!gate) {\n\t\tif (table->count)\n\t\t\tpi->uvd_boot_level = table->count - 1;\n\t\telse\n\t\t\tpi->uvd_boot_level = 0;\n\n\t\tif (!pi->caps_uvd_dpm || pi->caps_stable_p_state) {\n\t\t\tmask = 1 << pi->uvd_boot_level;\n\t\t} else {\n\t\t\tmask = 0x1f;\n\t\t}\n\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, UvdBootLevel),\n\t\t\t\t\t   (uint8_t *)&pi->uvd_boot_level,\n\t\t\t\t\t   sizeof(u8), pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tkv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t  PPSMC_MSG_UVDDPM_SetEnabledMask,\n\t\t\t\t\t\t  mask);\n\t}\n\n\treturn kv_enable_uvd_dpm(rdev, !gate);\n}\n\nstatic u8 kv_get_vce_boot_level(struct radeon_device *rdev, u32 evclk)\n{\n\tu8 i;\n\tstruct radeon_vce_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (table->entries[i].evclk >= evclk)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic int kv_update_vce_dpm(struct radeon_device *rdev,\n\t\t\t     struct radeon_ps *radeon_new_state,\n\t\t\t     struct radeon_ps *radeon_current_state)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_vce_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\n\tint ret;\n\n\tif (radeon_new_state->evclk > 0 && radeon_current_state->evclk == 0) {\n\t\tkv_dpm_powergate_vce(rdev, false);\n\t\t \n\t\tcik_update_cg(rdev, RADEON_CG_BLOCK_VCE, false);\n\t\tif (pi->caps_stable_p_state)\n\t\t\tpi->vce_boot_level = table->count - 1;\n\t\telse\n\t\t\tpi->vce_boot_level = kv_get_vce_boot_level(rdev, radeon_new_state->evclk);\n\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, VceBootLevel),\n\t\t\t\t\t   (u8 *)&pi->vce_boot_level,\n\t\t\t\t\t   sizeof(u8),\n\t\t\t\t\t   pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pi->caps_stable_p_state)\n\t\t\tkv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t\t  PPSMC_MSG_VCEDPM_SetEnabledMask,\n\t\t\t\t\t\t\t  (1 << pi->vce_boot_level));\n\n\t\tkv_enable_vce_dpm(rdev, true);\n\t} else if (radeon_new_state->evclk == 0 && radeon_current_state->evclk > 0) {\n\t\tkv_enable_vce_dpm(rdev, false);\n\t\t \n\t\tcik_update_cg(rdev, RADEON_CG_BLOCK_VCE, true);\n\t\tkv_dpm_powergate_vce(rdev, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int kv_update_samu_dpm(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table;\n\tint ret;\n\n\tif (!gate) {\n\t\tif (pi->caps_stable_p_state)\n\t\t\tpi->samu_boot_level = table->count - 1;\n\t\telse\n\t\t\tpi->samu_boot_level = 0;\n\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, SamuBootLevel),\n\t\t\t\t\t   (u8 *)&pi->samu_boot_level,\n\t\t\t\t\t   sizeof(u8),\n\t\t\t\t\t   pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pi->caps_stable_p_state)\n\t\t\tkv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t\t  PPSMC_MSG_SAMUDPM_SetEnabledMask,\n\t\t\t\t\t\t\t  (1 << pi->samu_boot_level));\n\t}\n\n\treturn kv_enable_samu_dpm(rdev, !gate);\n}\n\nstatic u8 kv_get_acp_boot_level(struct radeon_device *rdev)\n{\n\tu8 i;\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (table->entries[i].clk >= 0)  \n\t\t\tbreak;\n\t}\n\n\tif (i >= table->count)\n\t\ti = table->count - 1;\n\n\treturn i;\n}\n\nstatic void kv_update_acp_boot_level(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu8 acp_boot_level;\n\n\tif (!pi->caps_stable_p_state) {\n\t\tacp_boot_level = kv_get_acp_boot_level(rdev);\n\t\tif (acp_boot_level != pi->acp_boot_level) {\n\t\t\tpi->acp_boot_level = acp_boot_level;\n\t\t\tkv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t\t  PPSMC_MSG_ACPDPM_SetEnabledMask,\n\t\t\t\t\t\t\t  (1 << pi->acp_boot_level));\n\t\t}\n\t}\n}\n\nstatic int kv_update_acp_dpm(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\n\tint ret;\n\n\tif (!gate) {\n\t\tif (pi->caps_stable_p_state)\n\t\t\tpi->acp_boot_level = table->count - 1;\n\t\telse\n\t\t\tpi->acp_boot_level = kv_get_acp_boot_level(rdev);\n\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   pi->dpm_table_start +\n\t\t\t\t\t   offsetof(SMU7_Fusion_DpmTable, AcpBootLevel),\n\t\t\t\t\t   (u8 *)&pi->acp_boot_level,\n\t\t\t\t\t   sizeof(u8),\n\t\t\t\t\t   pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pi->caps_stable_p_state)\n\t\t\tkv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t\t  PPSMC_MSG_ACPDPM_SetEnabledMask,\n\t\t\t\t\t\t\t  (1 << pi->acp_boot_level));\n\t}\n\n\treturn kv_enable_acp_dpm(rdev, !gate);\n}\n\nvoid kv_dpm_powergate_uvd(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tif (pi->uvd_power_gated == gate)\n\t\treturn;\n\n\tpi->uvd_power_gated = gate;\n\n\tif (gate) {\n\t\tif (pi->caps_uvd_pg) {\n\t\t\tuvd_v1_0_stop(rdev);\n\t\t\tcik_update_cg(rdev, RADEON_CG_BLOCK_UVD, false);\n\t\t}\n\t\tkv_update_uvd_dpm(rdev, gate);\n\t\tif (pi->caps_uvd_pg)\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_UVDPowerOFF);\n\t} else {\n\t\tif (pi->caps_uvd_pg) {\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_UVDPowerON);\n\t\t\tuvd_v4_2_resume(rdev);\n\t\t\tuvd_v1_0_start(rdev);\n\t\t\tcik_update_cg(rdev, RADEON_CG_BLOCK_UVD, true);\n\t\t}\n\t\tkv_update_uvd_dpm(rdev, gate);\n\t}\n}\n\nstatic void kv_dpm_powergate_vce(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tif (pi->vce_power_gated == gate)\n\t\treturn;\n\n\tpi->vce_power_gated = gate;\n\n\tif (gate) {\n\t\tif (pi->caps_vce_pg) {\n\t\t\t \n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_VCEPowerOFF);\n\t\t}\n\t} else {\n\t\tif (pi->caps_vce_pg) {\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_VCEPowerON);\n\t\t\tvce_v2_0_resume(rdev);\n\t\t\tvce_v1_0_start(rdev);\n\t\t}\n\t}\n}\n\nstatic void kv_dpm_powergate_samu(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tif (pi->samu_power_gated == gate)\n\t\treturn;\n\n\tpi->samu_power_gated = gate;\n\n\tif (gate) {\n\t\tkv_update_samu_dpm(rdev, true);\n\t\tif (pi->caps_samu_pg)\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_SAMPowerOFF);\n\t} else {\n\t\tif (pi->caps_samu_pg)\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_SAMPowerON);\n\t\tkv_update_samu_dpm(rdev, false);\n\t}\n}\n\nstatic void kv_dpm_powergate_acp(struct radeon_device *rdev, bool gate)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tif (pi->acp_power_gated == gate)\n\t\treturn;\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS)\n\t\treturn;\n\n\tpi->acp_power_gated = gate;\n\n\tif (gate) {\n\t\tkv_update_acp_dpm(rdev, true);\n\t\tif (pi->caps_acp_pg)\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_ACPPowerOFF);\n\t} else {\n\t\tif (pi->caps_acp_pg)\n\t\t\tkv_notify_message_to_smu(rdev, PPSMC_MSG_ACPPowerON);\n\t\tkv_update_acp_dpm(rdev, false);\n\t}\n}\n\nstatic void kv_set_valid_clock_range(struct radeon_device *rdev,\n\t\t\t\t     struct radeon_ps *new_rps)\n{\n\tstruct kv_ps *new_ps = kv_get_ps(new_rps);\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\n\tif (table && table->count) {\n\t\tfor (i = 0; i < pi->graphics_dpm_level_count; i++) {\n\t\t\tif ((table->entries[i].clk >= new_ps->levels[0].sclk) ||\n\t\t\t    (i == (pi->graphics_dpm_level_count - 1))) {\n\t\t\t\tpi->lowest_valid = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\n\t\t\tif (table->entries[i].clk <= new_ps->levels[new_ps->num_levels - 1].sclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tpi->highest_valid = i;\n\n\t\tif (pi->lowest_valid > pi->highest_valid) {\n\t\t\tif ((new_ps->levels[0].sclk - table->entries[pi->highest_valid].clk) >\n\t\t\t    (table->entries[pi->lowest_valid].clk - new_ps->levels[new_ps->num_levels - 1].sclk))\n\t\t\t\tpi->highest_valid = pi->lowest_valid;\n\t\t\telse\n\t\t\t\tpi->lowest_valid =  pi->highest_valid;\n\t\t}\n\t} else {\n\t\tstruct sumo_sclk_voltage_mapping_table *table =\n\t\t\t&pi->sys_info.sclk_voltage_mapping_table;\n\n\t\tfor (i = 0; i < (int)pi->graphics_dpm_level_count; i++) {\n\t\t\tif (table->entries[i].sclk_frequency >= new_ps->levels[0].sclk ||\n\t\t\t    i == (int)(pi->graphics_dpm_level_count - 1)) {\n\t\t\t\tpi->lowest_valid = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\n\t\t\tif (table->entries[i].sclk_frequency <=\n\t\t\t    new_ps->levels[new_ps->num_levels - 1].sclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tpi->highest_valid = i;\n\n\t\tif (pi->lowest_valid > pi->highest_valid) {\n\t\t\tif ((new_ps->levels[0].sclk -\n\t\t\t     table->entries[pi->highest_valid].sclk_frequency) >\n\t\t\t    (table->entries[pi->lowest_valid].sclk_frequency -\n\t\t\t     new_ps->levels[new_ps->num_levels -1].sclk))\n\t\t\t\tpi->highest_valid = pi->lowest_valid;\n\t\t\telse\n\t\t\t\tpi->lowest_valid =  pi->highest_valid;\n\t\t}\n\t}\n}\n\nstatic int kv_update_dfs_bypass_settings(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *new_rps)\n{\n\tstruct kv_ps *new_ps = kv_get_ps(new_rps);\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret = 0;\n\tu8 clk_bypass_cntl;\n\n\tif (pi->caps_enable_dfs_bypass) {\n\t\tclk_bypass_cntl = new_ps->need_dfs_bypass ?\n\t\t\tpi->graphics_level[pi->graphics_boot_level].ClkBypassCntl : 0;\n\t\tret = kv_copy_bytes_to_smc(rdev,\n\t\t\t\t\t   (pi->dpm_table_start +\n\t\t\t\t\t    offsetof(SMU7_Fusion_DpmTable, GraphicsLevel) +\n\t\t\t\t\t    (pi->graphics_boot_level * sizeof(SMU7_Fusion_GraphicsLevel)) +\n\t\t\t\t\t    offsetof(SMU7_Fusion_GraphicsLevel, ClkBypassCntl)),\n\t\t\t\t\t   &clk_bypass_cntl,\n\t\t\t\t\t   sizeof(u8), pi->sram_end);\n\t}\n\n\treturn ret;\n}\n\nstatic int kv_enable_nb_dpm(struct radeon_device *rdev,\n\t\t\t    bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tint ret = 0;\n\n\tif (enable) {\n\t\tif (pi->enable_nb_dpm && !pi->nb_dpm_enabled) {\n\t\t\tret = kv_notify_message_to_smu(rdev, PPSMC_MSG_NBDPM_Enable);\n\t\t\tif (ret == 0)\n\t\t\t\tpi->nb_dpm_enabled = true;\n\t\t}\n\t} else {\n\t\tif (pi->enable_nb_dpm && pi->nb_dpm_enabled) {\n\t\t\tret = kv_notify_message_to_smu(rdev, PPSMC_MSG_NBDPM_Disable);\n\t\t\tif (ret == 0)\n\t\t\t\tpi->nb_dpm_enabled = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint kv_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t   enum radeon_dpm_forced_level level)\n{\n\tint ret;\n\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\tret = kv_force_dpm_highest(rdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tret = kv_force_dpm_lowest(rdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_AUTO) {\n\t\tret = kv_unforce_levels(rdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n\nint kv_dpm_pre_set_power_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *new_ps = &requested_ps;\n\n\tkv_update_requested_ps(rdev, new_ps);\n\n\tkv_apply_state_adjust_rules(rdev,\n\t\t\t\t    &pi->requested_rps,\n\t\t\t\t    &pi->current_rps);\n\n\treturn 0;\n}\n\nint kv_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &pi->requested_rps;\n\tstruct radeon_ps *old_ps = &pi->current_rps;\n\tint ret;\n\n\tif (pi->bapm_enable) {\n\t\tret = kv_smc_bapm_enable(rdev, rdev->pm.dpm.ac_power);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"kv_smc_bapm_enable failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS) {\n\t\tif (pi->enable_dpm) {\n\t\t\tkv_set_valid_clock_range(rdev, new_ps);\n\t\t\tkv_update_dfs_bypass_settings(rdev, new_ps);\n\t\t\tret = kv_calculate_ds_divider(rdev);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"kv_calculate_ds_divider failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tkv_calculate_nbps_level_settings(rdev);\n\t\t\tkv_calculate_dpm_settings(rdev);\n\t\t\tkv_force_lowest_valid(rdev);\n\t\t\tkv_enable_new_levels(rdev);\n\t\t\tkv_upload_dpm_settings(rdev);\n\t\t\tkv_program_nbps_index_settings(rdev, new_ps);\n\t\t\tkv_unforce_levels(rdev);\n\t\t\tkv_set_enabled_levels(rdev);\n\t\t\tkv_force_lowest_valid(rdev);\n\t\t\tkv_unforce_levels(rdev);\n\n\t\t\tret = kv_update_vce_dpm(rdev, new_ps, old_ps);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"kv_update_vce_dpm failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tkv_update_sclk_t(rdev);\n\t\t\tif (rdev->family == CHIP_MULLINS)\n\t\t\t\tkv_enable_nb_dpm(rdev, true);\n\t\t}\n\t} else {\n\t\tif (pi->enable_dpm) {\n\t\t\tkv_set_valid_clock_range(rdev, new_ps);\n\t\t\tkv_update_dfs_bypass_settings(rdev, new_ps);\n\t\t\tret = kv_calculate_ds_divider(rdev);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"kv_calculate_ds_divider failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tkv_calculate_nbps_level_settings(rdev);\n\t\t\tkv_calculate_dpm_settings(rdev);\n\t\t\tkv_freeze_sclk_dpm(rdev, true);\n\t\t\tkv_upload_dpm_settings(rdev);\n\t\t\tkv_program_nbps_index_settings(rdev, new_ps);\n\t\t\tkv_freeze_sclk_dpm(rdev, false);\n\t\t\tkv_set_enabled_levels(rdev);\n\t\t\tret = kv_update_vce_dpm(rdev, new_ps, old_ps);\n\t\t\tif (ret) {\n\t\t\t\tDRM_ERROR(\"kv_update_vce_dpm failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tkv_update_acp_boot_level(rdev);\n\t\t\tkv_update_sclk_t(rdev);\n\t\t\tkv_enable_nb_dpm(rdev, true);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid kv_dpm_post_set_power_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_ps *new_ps = &pi->requested_rps;\n\n\tkv_update_current_ps(rdev, new_ps);\n}\n\nvoid kv_dpm_setup_asic(struct radeon_device *rdev)\n{\n\tsumo_take_smu_control(rdev, true);\n\tkv_init_powergate_state(rdev);\n\tkv_init_sclk_t(rdev);\n}\n\n\n\nstatic void kv_construct_max_power_limits_table(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct radeon_clock_and_voltage_limits *table)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tif (pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries > 0) {\n\t\tint idx = pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries - 1;\n\t\ttable->sclk =\n\t\t\tpi->sys_info.sclk_voltage_mapping_table.entries[idx].sclk_frequency;\n\t\ttable->vddc =\n\t\t\tkv_convert_2bit_index_to_voltage(rdev,\n\t\t\t\t\t\t\t pi->sys_info.sclk_voltage_mapping_table.entries[idx].vid_2bit);\n\t}\n\n\ttable->mclk = pi->sys_info.nbp_memory_clock[0];\n}\n\nstatic void kv_patch_voltage_values(struct radeon_device *rdev)\n{\n\tint i;\n\tstruct radeon_uvd_clock_voltage_dependency_table *uvd_table =\n\t\t&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table;\n\tstruct radeon_vce_clock_voltage_dependency_table *vce_table =\n\t\t&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\n\tstruct radeon_clock_voltage_dependency_table *samu_table =\n\t\t&rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table;\n\tstruct radeon_clock_voltage_dependency_table *acp_table =\n\t\t&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\n\n\tif (uvd_table->count) {\n\t\tfor (i = 0; i < uvd_table->count; i++)\n\t\t\tuvd_table->entries[i].v =\n\t\t\t\tkv_convert_8bit_index_to_voltage(rdev,\n\t\t\t\t\t\t\t\t uvd_table->entries[i].v);\n\t}\n\n\tif (vce_table->count) {\n\t\tfor (i = 0; i < vce_table->count; i++)\n\t\t\tvce_table->entries[i].v =\n\t\t\t\tkv_convert_8bit_index_to_voltage(rdev,\n\t\t\t\t\t\t\t\t vce_table->entries[i].v);\n\t}\n\n\tif (samu_table->count) {\n\t\tfor (i = 0; i < samu_table->count; i++)\n\t\t\tsamu_table->entries[i].v =\n\t\t\t\tkv_convert_8bit_index_to_voltage(rdev,\n\t\t\t\t\t\t\t\t samu_table->entries[i].v);\n\t}\n\n\tif (acp_table->count) {\n\t\tfor (i = 0; i < acp_table->count; i++)\n\t\t\tacp_table->entries[i].v =\n\t\t\t\tkv_convert_8bit_index_to_voltage(rdev,\n\t\t\t\t\t\t\t\t acp_table->entries[i].v);\n\t}\n\n}\n\nstatic void kv_construct_boot_state(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->boot_pl.sclk = pi->sys_info.bootup_sclk;\n\tpi->boot_pl.vddc_index = pi->sys_info.bootup_nb_voltage_index;\n\tpi->boot_pl.ds_divider_index = 0;\n\tpi->boot_pl.ss_divider_index = 0;\n\tpi->boot_pl.allow_gnb_slow = 1;\n\tpi->boot_pl.force_nbp_state = 0;\n\tpi->boot_pl.display_wm = 0;\n\tpi->boot_pl.vce_wm = 0;\n}\n\nstatic int kv_force_dpm_highest(struct radeon_device *rdev)\n{\n\tint ret;\n\tu32 enable_mask, i;\n\n\tret = kv_dpm_get_enable_mask(rdev, &enable_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = SMU7_MAX_LEVELS_GRAPHICS - 1; i > 0; i--) {\n\t\tif (enable_mask & (1 << i))\n\t\t\tbreak;\n\t}\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS)\n\t\treturn kv_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_DPM_ForceState, i);\n\telse\n\t\treturn kv_set_enabled_level(rdev, i);\n}\n\nstatic int kv_force_dpm_lowest(struct radeon_device *rdev)\n{\n\tint ret;\n\tu32 enable_mask, i;\n\n\tret = kv_dpm_get_enable_mask(rdev, &enable_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < SMU7_MAX_LEVELS_GRAPHICS; i++) {\n\t\tif (enable_mask & (1 << i))\n\t\t\tbreak;\n\t}\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS)\n\t\treturn kv_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_DPM_ForceState, i);\n\telse\n\t\treturn kv_set_enabled_level(rdev, i);\n}\n\nstatic u8 kv_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\n\t\t\t\t\t     u32 sclk, u32 min_sclk_in_sr)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\tu32 temp;\n\tu32 min = (min_sclk_in_sr > KV_MINIMUM_ENGINE_CLOCK) ?\n\t\tmin_sclk_in_sr : KV_MINIMUM_ENGINE_CLOCK;\n\n\tif (sclk < min)\n\t\treturn 0;\n\n\tif (!pi->caps_sclk_ds)\n\t\treturn 0;\n\n\tfor (i = KV_MAX_DEEPSLEEP_DIVIDER_ID; i > 0; i--) {\n\t\ttemp = sclk / sumo_get_sleep_divider_from_id(i);\n\t\tif (temp >= min)\n\t\t\tbreak;\n\t}\n\n\treturn (u8)i;\n}\n\nstatic int kv_get_high_voltage_limit(struct radeon_device *rdev, int *limit)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\tint i;\n\n\tif (table && table->count) {\n\t\tfor (i = table->count - 1; i >= 0; i--) {\n\t\t\tif (pi->high_voltage_t &&\n\t\t\t    (kv_convert_8bit_index_to_voltage(rdev, table->entries[i].v) <=\n\t\t\t     pi->high_voltage_t)) {\n\t\t\t\t*limit = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct sumo_sclk_voltage_mapping_table *table =\n\t\t\t&pi->sys_info.sclk_voltage_mapping_table;\n\n\t\tfor (i = table->num_max_dpm_entries - 1; i >= 0; i--) {\n\t\t\tif (pi->high_voltage_t &&\n\t\t\t    (kv_convert_2bit_index_to_voltage(rdev, table->entries[i].vid_2bit) <=\n\t\t\t     pi->high_voltage_t)) {\n\t\t\t\t*limit = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t*limit = 0;\n\treturn 0;\n}\n\nstatic void kv_apply_state_adjust_rules(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_ps *new_rps,\n\t\t\t\t\tstruct radeon_ps *old_rps)\n{\n\tstruct kv_ps *ps = kv_get_ps(new_rps);\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 min_sclk = 10000;  \n\tu32 sclk, mclk = 0;\n\tint i, limit;\n\tbool force_high;\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\tu32 stable_p_state_sclk = 0;\n\tstruct radeon_clock_and_voltage_limits *max_limits =\n\t\t&rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\n\n\tif (new_rps->vce_active) {\n\t\tnew_rps->evclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].evclk;\n\t\tnew_rps->ecclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].ecclk;\n\t} else {\n\t\tnew_rps->evclk = 0;\n\t\tnew_rps->ecclk = 0;\n\t}\n\n\tmclk = max_limits->mclk;\n\tsclk = min_sclk;\n\n\tif (pi->caps_stable_p_state) {\n\t\tstable_p_state_sclk = (max_limits->sclk * 75) / 100;\n\n\t\tfor (i = table->count - 1; i >= 0; i--) {\n\t\t\tif (stable_p_state_sclk >= table->entries[i].clk) {\n\t\t\t\tstable_p_state_sclk = table->entries[i].clk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i > 0)\n\t\t\tstable_p_state_sclk = table->entries[0].clk;\n\n\t\tsclk = stable_p_state_sclk;\n\t}\n\n\tif (new_rps->vce_active) {\n\t\tif (sclk < rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk)\n\t\t\tsclk = rdev->pm.dpm.vce_states[rdev->pm.dpm.vce_level].sclk;\n\t}\n\n\tps->need_dfs_bypass = true;\n\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tif (ps->levels[i].sclk < sclk)\n\t\t\tps->levels[i].sclk = sclk;\n\t}\n\n\tif (table && table->count) {\n\t\tfor (i = 0; i < ps->num_levels; i++) {\n\t\t\tif (pi->high_voltage_t &&\n\t\t\t    (pi->high_voltage_t <\n\t\t\t     kv_convert_8bit_index_to_voltage(rdev, ps->levels[i].vddc_index))) {\n\t\t\t\tkv_get_high_voltage_limit(rdev, &limit);\n\t\t\t\tps->levels[i].sclk = table->entries[limit].clk;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct sumo_sclk_voltage_mapping_table *table =\n\t\t\t&pi->sys_info.sclk_voltage_mapping_table;\n\n\t\tfor (i = 0; i < ps->num_levels; i++) {\n\t\t\tif (pi->high_voltage_t &&\n\t\t\t    (pi->high_voltage_t <\n\t\t\t     kv_convert_8bit_index_to_voltage(rdev, ps->levels[i].vddc_index))) {\n\t\t\t\tkv_get_high_voltage_limit(rdev, &limit);\n\t\t\t\tps->levels[i].sclk = table->entries[limit].sclk_frequency;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pi->caps_stable_p_state) {\n\t\tfor (i = 0; i < ps->num_levels; i++) {\n\t\t\tps->levels[i].sclk = stable_p_state_sclk;\n\t\t}\n\t}\n\n\tpi->video_start = new_rps->dclk || new_rps->vclk ||\n\t\tnew_rps->evclk || new_rps->ecclk;\n\n\tif ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==\n\t    ATOM_PPLIB_CLASSIFICATION_UI_BATTERY)\n\t\tpi->battery_state = true;\n\telse\n\t\tpi->battery_state = false;\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS) {\n\t\tps->dpm0_pg_nb_ps_lo = 0x1;\n\t\tps->dpm0_pg_nb_ps_hi = 0x0;\n\t\tps->dpmx_nb_ps_lo = 0x1;\n\t\tps->dpmx_nb_ps_hi = 0x0;\n\t} else {\n\t\tps->dpm0_pg_nb_ps_lo = 0x3;\n\t\tps->dpm0_pg_nb_ps_hi = 0x0;\n\t\tps->dpmx_nb_ps_lo = 0x3;\n\t\tps->dpmx_nb_ps_hi = 0x0;\n\n\t\tif (pi->sys_info.nb_dpm_enable) {\n\t\t\tforce_high = (mclk >= pi->sys_info.nbp_memory_clock[3]) ||\n\t\t\t\tpi->video_start || (rdev->pm.dpm.new_active_crtc_count >= 3) ||\n\t\t\t\tpi->disable_nb_ps3_in_battery;\n\t\t\tps->dpm0_pg_nb_ps_lo = force_high ? 0x2 : 0x3;\n\t\t\tps->dpm0_pg_nb_ps_hi = 0x2;\n\t\t\tps->dpmx_nb_ps_lo = force_high ? 0x2 : 0x3;\n\t\t\tps->dpmx_nb_ps_hi = 0x2;\n\t\t}\n\t}\n}\n\nstatic void kv_dpm_power_level_enabled_for_throttle(struct radeon_device *rdev,\n\t\t\t\t\t\t    u32 index, bool enable)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tpi->graphics_level[index].EnabledForThrottle = enable ? 1 : 0;\n}\n\nstatic int kv_calculate_ds_divider(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 sclk_in_sr = 10000;  \n\tu32 i;\n\n\tif (pi->lowest_valid > pi->highest_valid)\n\t\treturn -EINVAL;\n\n\tfor (i = pi->lowest_valid; i <= pi->highest_valid; i++) {\n\t\tpi->graphics_level[i].DeepSleepDivId =\n\t\t\tkv_get_sleep_divider_id_from_clock(rdev,\n\t\t\t\t\t\t\t   be32_to_cpu(pi->graphics_level[i].SclkFrequency),\n\t\t\t\t\t\t\t   sclk_in_sr);\n\t}\n\treturn 0;\n}\n\nstatic int kv_calculate_nbps_level_settings(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\tbool force_high;\n\tstruct radeon_clock_and_voltage_limits *max_limits =\n\t\t&rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\n\tu32 mclk = max_limits->mclk;\n\n\tif (pi->lowest_valid > pi->highest_valid)\n\t\treturn -EINVAL;\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS) {\n\t\tfor (i = pi->lowest_valid; i <= pi->highest_valid; i++) {\n\t\t\tpi->graphics_level[i].GnbSlow = 1;\n\t\t\tpi->graphics_level[i].ForceNbPs1 = 0;\n\t\t\tpi->graphics_level[i].UpH = 0;\n\t\t}\n\n\t\tif (!pi->sys_info.nb_dpm_enable)\n\t\t\treturn 0;\n\n\t\tforce_high = ((mclk >= pi->sys_info.nbp_memory_clock[3]) ||\n\t\t\t      (rdev->pm.dpm.new_active_crtc_count >= 3) || pi->video_start);\n\n\t\tif (force_high) {\n\t\t\tfor (i = pi->lowest_valid; i <= pi->highest_valid; i++)\n\t\t\t\tpi->graphics_level[i].GnbSlow = 0;\n\t\t} else {\n\t\t\tif (pi->battery_state)\n\t\t\t\tpi->graphics_level[0].ForceNbPs1 = 1;\n\n\t\t\tpi->graphics_level[1].GnbSlow = 0;\n\t\t\tpi->graphics_level[2].GnbSlow = 0;\n\t\t\tpi->graphics_level[3].GnbSlow = 0;\n\t\t\tpi->graphics_level[4].GnbSlow = 0;\n\t\t}\n\t} else {\n\t\tfor (i = pi->lowest_valid; i <= pi->highest_valid; i++) {\n\t\t\tpi->graphics_level[i].GnbSlow = 1;\n\t\t\tpi->graphics_level[i].ForceNbPs1 = 0;\n\t\t\tpi->graphics_level[i].UpH = 0;\n\t\t}\n\n\t\tif (pi->sys_info.nb_dpm_enable && pi->battery_state) {\n\t\t\tpi->graphics_level[pi->lowest_valid].UpH = 0x28;\n\t\t\tpi->graphics_level[pi->lowest_valid].GnbSlow = 0;\n\t\t\tif (pi->lowest_valid != pi->highest_valid)\n\t\t\t\tpi->graphics_level[pi->lowest_valid].ForceNbPs1 = 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int kv_calculate_dpm_settings(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\n\tif (pi->lowest_valid > pi->highest_valid)\n\t\treturn -EINVAL;\n\n\tfor (i = pi->lowest_valid; i <= pi->highest_valid; i++)\n\t\tpi->graphics_level[i].DisplayWatermark = (i == pi->highest_valid) ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic void kv_init_graphics_levels(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\tstruct radeon_clock_voltage_dependency_table *table =\n\t\t&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\n\n\tif (table && table->count) {\n\t\tu32 vid_2bit;\n\n\t\tpi->graphics_dpm_level_count = 0;\n\t\tfor (i = 0; i < table->count; i++) {\n\t\t\tif (pi->high_voltage_t &&\n\t\t\t    (pi->high_voltage_t <\n\t\t\t     kv_convert_8bit_index_to_voltage(rdev, table->entries[i].v)))\n\t\t\t\tbreak;\n\n\t\t\tkv_set_divider_value(rdev, i, table->entries[i].clk);\n\t\t\tvid_2bit = kv_convert_vid7_to_vid2(rdev,\n\t\t\t\t\t\t\t   &pi->sys_info.vid_mapping_table,\n\t\t\t\t\t\t\t   table->entries[i].v);\n\t\t\tkv_set_vid(rdev, i, vid_2bit);\n\t\t\tkv_set_at(rdev, i, pi->at[i]);\n\t\t\tkv_dpm_power_level_enabled_for_throttle(rdev, i, true);\n\t\t\tpi->graphics_dpm_level_count++;\n\t\t}\n\t} else {\n\t\tstruct sumo_sclk_voltage_mapping_table *table =\n\t\t\t&pi->sys_info.sclk_voltage_mapping_table;\n\n\t\tpi->graphics_dpm_level_count = 0;\n\t\tfor (i = 0; i < table->num_max_dpm_entries; i++) {\n\t\t\tif (pi->high_voltage_t &&\n\t\t\t    pi->high_voltage_t <\n\t\t\t    kv_convert_2bit_index_to_voltage(rdev, table->entries[i].vid_2bit))\n\t\t\t\tbreak;\n\n\t\t\tkv_set_divider_value(rdev, i, table->entries[i].sclk_frequency);\n\t\t\tkv_set_vid(rdev, i, table->entries[i].vid_2bit);\n\t\t\tkv_set_at(rdev, i, pi->at[i]);\n\t\t\tkv_dpm_power_level_enabled_for_throttle(rdev, i, true);\n\t\t\tpi->graphics_dpm_level_count++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < SMU7_MAX_LEVELS_GRAPHICS; i++)\n\t\tkv_dpm_power_level_enable(rdev, i, false);\n}\n\nstatic void kv_enable_new_levels(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i;\n\n\tfor (i = 0; i < SMU7_MAX_LEVELS_GRAPHICS; i++) {\n\t\tif (i >= pi->lowest_valid && i <= pi->highest_valid)\n\t\t\tkv_dpm_power_level_enable(rdev, i, true);\n\t}\n}\n\nstatic int kv_set_enabled_level(struct radeon_device *rdev, u32 level)\n{\n\tu32 new_mask = (1 << level);\n\n\treturn kv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t PPSMC_MSG_SCLKDPM_SetEnabledMask,\n\t\t\t\t\t\t new_mask);\n}\n\nstatic int kv_set_enabled_levels(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 i, new_mask = 0;\n\n\tfor (i = pi->lowest_valid; i <= pi->highest_valid; i++)\n\t\tnew_mask |= (1 << i);\n\n\treturn kv_send_msg_to_smc_with_parameter(rdev,\n\t\t\t\t\t\t PPSMC_MSG_SCLKDPM_SetEnabledMask,\n\t\t\t\t\t\t new_mask);\n}\n\nstatic void kv_program_nbps_index_settings(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *new_rps)\n{\n\tstruct kv_ps *new_ps = kv_get_ps(new_rps);\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 nbdpmconfig1;\n\n\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS)\n\t\treturn;\n\n\tif (pi->sys_info.nb_dpm_enable) {\n\t\tnbdpmconfig1 = RREG32_SMC(NB_DPM_CONFIG_1);\n\t\tnbdpmconfig1 &= ~(Dpm0PgNbPsLo_MASK | Dpm0PgNbPsHi_MASK |\n\t\t\t\t  DpmXNbPsLo_MASK | DpmXNbPsHi_MASK);\n\t\tnbdpmconfig1 |= (Dpm0PgNbPsLo(new_ps->dpm0_pg_nb_ps_lo) |\n\t\t\t\t Dpm0PgNbPsHi(new_ps->dpm0_pg_nb_ps_hi) |\n\t\t\t\t DpmXNbPsLo(new_ps->dpmx_nb_ps_lo) |\n\t\t\t\t DpmXNbPsHi(new_ps->dpmx_nb_ps_hi));\n\t\tWREG32_SMC(NB_DPM_CONFIG_1, nbdpmconfig1);\n\t}\n}\n\nstatic int kv_set_thermal_temperature_range(struct radeon_device *rdev,\n\t\t\t\t\t    int min_temp, int max_temp)\n{\n\tint low_temp = 0 * 1000;\n\tint high_temp = 255 * 1000;\n\tu32 tmp;\n\n\tif (low_temp < min_temp)\n\t\tlow_temp = min_temp;\n\tif (high_temp > max_temp)\n\t\thigh_temp = max_temp;\n\tif (high_temp < low_temp) {\n\t\tDRM_ERROR(\"invalid thermal range: %d - %d\\n\", low_temp, high_temp);\n\t\treturn -EINVAL;\n\t}\n\n\ttmp = RREG32_SMC(CG_THERMAL_INT_CTRL);\n\ttmp &= ~(DIG_THERM_INTH_MASK | DIG_THERM_INTL_MASK);\n\ttmp |= (DIG_THERM_INTH(49 + (high_temp / 1000)) |\n\t\tDIG_THERM_INTL(49 + (low_temp / 1000)));\n\tWREG32_SMC(CG_THERMAL_INT_CTRL, tmp);\n\n\trdev->pm.dpm.thermal.min_temp = low_temp;\n\trdev->pm.dpm.thermal.max_temp = high_temp;\n\n\treturn 0;\n}\n\nunion igp_info {\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO info;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V2 info_2;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V5 info_5;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V6 info_6;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_7 info_7;\n\tstruct _ATOM_INTEGRATED_SYSTEM_INFO_V1_8 info_8;\n};\n\nstatic int kv_parse_sys_info_table(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\n\tunion igp_info *igp_info;\n\tu8 frev, crev;\n\tu16 data_offset;\n\tint i;\n\n\tif (atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset)) {\n\t\tigp_info = (union igp_info *)(mode_info->atom_context->bios +\n\t\t\t\t\t      data_offset);\n\n\t\tif (crev != 8) {\n\t\t\tDRM_ERROR(\"Unsupported IGP table: %d %d\\n\", frev, crev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpi->sys_info.bootup_sclk = le32_to_cpu(igp_info->info_8.ulBootUpEngineClock);\n\t\tpi->sys_info.bootup_uma_clk = le32_to_cpu(igp_info->info_8.ulBootUpUMAClock);\n\t\tpi->sys_info.bootup_nb_voltage_index =\n\t\t\tle16_to_cpu(igp_info->info_8.usBootUpNBVoltage);\n\t\tif (igp_info->info_8.ucHtcTmpLmt == 0)\n\t\t\tpi->sys_info.htc_tmp_lmt = 203;\n\t\telse\n\t\t\tpi->sys_info.htc_tmp_lmt = igp_info->info_8.ucHtcTmpLmt;\n\t\tif (igp_info->info_8.ucHtcHystLmt == 0)\n\t\t\tpi->sys_info.htc_hyst_lmt = 5;\n\t\telse\n\t\t\tpi->sys_info.htc_hyst_lmt = igp_info->info_8.ucHtcHystLmt;\n\t\tif (pi->sys_info.htc_tmp_lmt <= pi->sys_info.htc_hyst_lmt) {\n\t\t\tDRM_ERROR(\"The htcTmpLmt should be larger than htcHystLmt.\\n\");\n\t\t}\n\n\t\tif (le32_to_cpu(igp_info->info_8.ulSystemConfig) & (1 << 3))\n\t\t\tpi->sys_info.nb_dpm_enable = true;\n\t\telse\n\t\t\tpi->sys_info.nb_dpm_enable = false;\n\n\t\tfor (i = 0; i < KV_NUM_NBPSTATES; i++) {\n\t\t\tpi->sys_info.nbp_memory_clock[i] =\n\t\t\t\tle32_to_cpu(igp_info->info_8.ulNbpStateMemclkFreq[i]);\n\t\t\tpi->sys_info.nbp_n_clock[i] =\n\t\t\t\tle32_to_cpu(igp_info->info_8.ulNbpStateNClkFreq[i]);\n\t\t}\n\t\tif (le32_to_cpu(igp_info->info_8.ulGPUCapInfo) &\n\t\t    SYS_INFO_GPUCAPS__ENABEL_DFS_BYPASS)\n\t\t\tpi->caps_enable_dfs_bypass = true;\n\n\t\tsumo_construct_sclk_voltage_mapping_table(rdev,\n\t\t\t\t\t\t\t  &pi->sys_info.sclk_voltage_mapping_table,\n\t\t\t\t\t\t\t  igp_info->info_8.sAvail_SCLK);\n\n\t\tsumo_construct_vid_mapping_table(rdev,\n\t\t\t\t\t\t &pi->sys_info.vid_mapping_table,\n\t\t\t\t\t\t igp_info->info_8.sAvail_SCLK);\n\n\t\tkv_construct_max_power_limits_table(rdev,\n\t\t\t\t\t\t    &rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac);\n\t}\n\treturn 0;\n}\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void kv_patch_boot_state(struct radeon_device *rdev,\n\t\t\t\tstruct kv_ps *ps)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\tps->num_levels = 1;\n\tps->levels[0] = pi->boot_pl;\n}\n\nstatic void kv_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *rps,\n\t\t\t\t\t  struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t  u8 table_rev)\n{\n\tstruct kv_ps *ps = kv_get_ps(rps);\n\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\trdev->pm.dpm.boot_ps = rps;\n\t\tkv_patch_boot_state(rdev, ps);\n\t}\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void kv_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t      struct radeon_ps *rps, int index,\n\t\t\t\t\tunion pplib_clock_info *clock_info)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct kv_ps *ps = kv_get_ps(rps);\n\tstruct kv_pl *pl = &ps->levels[index];\n\tu32 sclk;\n\n\tsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\n\tsclk |= clock_info->sumo.ucEngineClockHigh << 16;\n\tpl->sclk = sclk;\n\tpl->vddc_index = clock_info->sumo.vddcIndex;\n\n\tps->num_levels = index + 1;\n\n\tif (pi->caps_sclk_ds) {\n\t\tpl->ds_divider_index = 5;\n\t\tpl->ss_divider_index = 5;\n\t}\n}\n\nstatic int kv_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j, k, non_clock_array_index, clock_array_index;\n\tunion pplib_clock_info *clock_info;\n\tstruct _StateArray *state_array;\n\tstruct _ClockInfoArray *clock_info_array;\n\tstruct _NonClockInfoArray *non_clock_info_array;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tu8 *power_state_offset;\n\tstruct kv_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tstate_array = (struct _StateArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset));\n\tclock_info_array = (struct _ClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\n\tnon_clock_info_array = (struct _NonClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\n\n\trdev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\tpower_state_offset = (u8 *)state_array->states;\n\tfor (i = 0; i < state_array->ucNumEntries; i++) {\n\t\tu8 *idx;\n\t\tpower_state = (union pplib_power_state *)power_state_offset;\n\t\tnon_clock_array_index = power_state->v2.nonClockInfoIndex;\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t&non_clock_info_array->nonClockInfo[non_clock_array_index];\n\t\tif (!rdev->pm.power_state[i].clock_info)\n\t\t\treturn -EINVAL;\n\t\tps = kzalloc(sizeof(struct kv_ps), GFP_KERNEL);\n\t\tif (ps == NULL) {\n\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\tk = 0;\n\t\tidx = (u8 *)&power_state->v2.clockInfoIndex[0];\n\t\tfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\n\t\t\tclock_array_index = idx[j];\n\t\t\tif (clock_array_index >= clock_info_array->ucNumEntries)\n\t\t\t\tcontinue;\n\t\t\tif (k >= SUMO_MAX_HARDWARE_POWERLEVELS)\n\t\t\t\tbreak;\n\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t((u8 *)&clock_info_array->clockInfo[0] +\n\t\t\t\t (clock_array_index * clock_info_array->ucEntrySize));\n\t\t\tkv_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t  &rdev->pm.dpm.ps[i], k,\n\t\t\t\t\t\t  clock_info);\n\t\t\tk++;\n\t\t}\n\t\tkv_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t      non_clock_info,\n\t\t\t\t\t      non_clock_info_array->ucEntrySize);\n\t\tpower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\n\t}\n\trdev->pm.dpm.num_ps = state_array->ucNumEntries;\n\n\t \n\tfor (i = 0; i < RADEON_MAX_VCE_LEVELS; i++) {\n\t\tu32 sclk;\n\t\tclock_array_index = rdev->pm.dpm.vce_states[i].clk_idx;\n\t\tclock_info = (union pplib_clock_info *)\n\t\t\t&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\n\t\tsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\n\t\tsclk |= clock_info->sumo.ucEngineClockHigh << 16;\n\t\trdev->pm.dpm.vce_states[i].sclk = sclk;\n\t\trdev->pm.dpm.vce_states[i].mclk = 0;\n\t}\n\n\treturn 0;\n}\n\nint kv_dpm_init(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi;\n\tint ret, i;\n\n\tpi = kzalloc(sizeof(struct kv_power_info), GFP_KERNEL);\n\tif (pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = pi;\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = r600_parse_extended_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++)\n\t\tpi->at[i] = TRINITY_AT_DFLT;\n\n\tpi->sram_end = SMC_RAM_END;\n\n\t \n\tif (rdev->pdev->subsystem_vendor == 0x1849)\n\t\tpi->enable_nb_dpm = false;\n\telse\n\t\tpi->enable_nb_dpm = true;\n\n\tpi->caps_power_containment = true;\n\tpi->caps_cac = true;\n\tpi->enable_didt = false;\n\tif (pi->enable_didt) {\n\t\tpi->caps_sq_ramping = true;\n\t\tpi->caps_db_ramping = true;\n\t\tpi->caps_td_ramping = true;\n\t\tpi->caps_tcp_ramping = true;\n\t}\n\n\tpi->caps_sclk_ds = true;\n\tpi->enable_auto_thermal_throttling = true;\n\tpi->disable_nb_ps3_in_battery = false;\n\tif (radeon_bapm == -1) {\n\t\t \n\t\tif (rdev->family == CHIP_KABINI || rdev->family == CHIP_MULLINS)\n\t\t\tpi->bapm_enable = true;\n\t\telse\n\t\t\tpi->bapm_enable = false;\n\t} else if (radeon_bapm == 0) {\n\t\tpi->bapm_enable = false;\n\t} else {\n\t\tpi->bapm_enable = true;\n\t}\n\tpi->voltage_drop_t = 0;\n\tpi->caps_sclk_throttle_low_notification = false;\n\tpi->caps_fps = false;  \n\tpi->caps_uvd_pg = true;\n\tpi->caps_uvd_dpm = true;\n\tpi->caps_vce_pg = false;  \n\tpi->caps_samu_pg = false;\n\tpi->caps_acp_pg = false;\n\tpi->caps_stable_p_state = false;\n\n\tret = kv_parse_sys_info_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tkv_patch_voltage_values(rdev);\n\tkv_construct_boot_state(rdev);\n\n\tret = kv_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpi->enable_dpm = true;\n\n\treturn 0;\n}\n\nvoid kv_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t    struct seq_file *m)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 current_index =\n\t\t(RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_SCLK_INDEX_MASK) >>\n\t\tCURR_SCLK_INDEX_SHIFT;\n\tu32 sclk, tmp;\n\tu16 vddc;\n\n\tif (current_index >= SMU__NUM_SCLK_DPM_STATE) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tsclk = be32_to_cpu(pi->graphics_level[current_index].SclkFrequency);\n\t\ttmp = (RREG32_SMC(SMU_VOLTAGE_STATUS) & SMU_VOLTAGE_CURRENT_LEVEL_MASK) >>\n\t\t\tSMU_VOLTAGE_CURRENT_LEVEL_SHIFT;\n\t\tvddc = kv_convert_8bit_index_to_voltage(rdev, (u16)tmp);\n\t\tseq_printf(m, \"uvd    %sabled\\n\", pi->uvd_power_gated ? \"dis\" : \"en\");\n\t\tseq_printf(m, \"vce    %sabled\\n\", pi->vce_power_gated ? \"dis\" : \"en\");\n\t\tseq_printf(m, \"power level %d    sclk: %u vddc: %u\\n\",\n\t\t\t   current_index, sclk, vddc);\n\t}\n}\n\nu32 kv_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tu32 current_index =\n\t\t(RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_SCLK_INDEX_MASK) >>\n\t\tCURR_SCLK_INDEX_SHIFT;\n\tu32 sclk;\n\n\tif (current_index >= SMU__NUM_SCLK_DPM_STATE) {\n\t\treturn 0;\n\t} else {\n\t\tsclk = be32_to_cpu(pi->graphics_level[current_index].SclkFrequency);\n\t\treturn sclk;\n\t}\n}\n\nu32 kv_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\treturn pi->sys_info.bootup_uma_clk;\n}\n\nvoid kv_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t      struct radeon_ps *rps)\n{\n\tint i;\n\tstruct kv_ps *ps = kv_get_ps(rps);\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tfor (i = 0; i < ps->num_levels; i++) {\n\t\tstruct kv_pl *pl = &ps->levels[i];\n\t\tprintk(\"\\t\\tpower level %d    sclk: %u vddc: %u\\n\",\n\t\t       i, pl->sclk,\n\t\t       kv_convert_8bit_index_to_voltage(rdev, pl->vddc_index));\n\t}\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid kv_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n\tr600_free_extended_power_table(rdev);\n}\n\nvoid kv_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\n}\n\nu32 kv_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\tstruct kv_ps *requested_state = kv_get_ps(&pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->levels[0].sclk;\n\telse\n\t\treturn requested_state->levels[requested_state->num_levels - 1].sclk;\n}\n\nu32 kv_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct kv_power_info *pi = kv_get_pi(rdev);\n\n\treturn pi->sys_info.bootup_uma_clk;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}