{
  "module_name": "radeon_vce.c",
  "hash_id": "3b2fd5d06d81ac50f444df92d06c37d0afa4b65f21b8c53143b7e519be35e242",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_vce.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n\n#include <drm/drm.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"sid.h\"\n\n \n#define VCE_IDLE_TIMEOUT_MS\t1000\n\n \n#define FIRMWARE_TAHITI\t\"radeon/TAHITI_vce.bin\"\n#define FIRMWARE_BONAIRE\t\"radeon/BONAIRE_vce.bin\"\n\nMODULE_FIRMWARE(FIRMWARE_TAHITI);\nMODULE_FIRMWARE(FIRMWARE_BONAIRE);\n\nstatic void radeon_vce_idle_work_handler(struct work_struct *work);\n\n \nint radeon_vce_init(struct radeon_device *rdev)\n{\n\tstatic const char *fw_version = \"[ATI LIB=VCEFW,\";\n\tstatic const char *fb_version = \"[ATI LIB=VCEFWSTATS,\";\n\tunsigned long size;\n\tconst char *fw_name, *c;\n\tuint8_t start, mid, end;\n\tint i, r;\n\n\tINIT_DELAYED_WORK(&rdev->vce.idle_work, radeon_vce_idle_work_handler);\n\n\tswitch (rdev->family) {\n\tcase CHIP_TAHITI:\n\tcase CHIP_PITCAIRN:\n\tcase CHIP_VERDE:\n\tcase CHIP_ARUBA:\n\t\tfw_name = FIRMWARE_TAHITI;\n\t\tbreak;\n\n\tcase CHIP_BONAIRE:\n\tcase CHIP_KAVERI:\n\tcase CHIP_KABINI:\n\tcase CHIP_HAWAII:\n\tcase CHIP_MULLINS:\n\t\tfw_name = FIRMWARE_BONAIRE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tr = request_firmware(&rdev->vce_fw, fw_name, rdev->dev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"radeon_vce: Can't load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name);\n\t\treturn r;\n\t}\n\n\t \n\n\tsize = rdev->vce_fw->size - strlen(fw_version) - 9;\n\tc = rdev->vce_fw->data;\n\tfor (; size > 0; --size, ++c)\n\t\tif (strncmp(c, fw_version, strlen(fw_version)) == 0)\n\t\t\tbreak;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tc += strlen(fw_version);\n\tif (sscanf(c, \"%2hhd.%2hhd.%2hhd]\", &start, &mid, &end) != 3)\n\t\treturn -EINVAL;\n\n\t \n\n\tsize = rdev->vce_fw->size - strlen(fb_version) - 3;\n\tc = rdev->vce_fw->data;\n\tfor (; size > 0; --size, ++c)\n\t\tif (strncmp(c, fb_version, strlen(fb_version)) == 0)\n\t\t\tbreak;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tc += strlen(fb_version);\n\tif (sscanf(c, \"%2u]\", &rdev->vce.fb_version) != 1)\n\t\treturn -EINVAL;\n\n\tDRM_INFO(\"Found VCE firmware/feedback version %d.%d.%d / %d!\\n\",\n\t\t start, mid, end, rdev->vce.fb_version);\n\n\trdev->vce.fw_version = (start << 24) | (mid << 16) | (end << 8);\n\n\t \n\tif ((rdev->vce.fw_version != ((40 << 24) | (2 << 16) | (2 << 8))) &&\n\t    (rdev->vce.fw_version != ((50 << 24) | (0 << 16) | (1 << 8))) &&\n\t    (rdev->vce.fw_version != ((50 << 24) | (1 << 16) | (2 << 8))))\n\t\treturn -EINVAL;\n\n\t \n\n\tif (rdev->family < CHIP_BONAIRE)\n\t\tsize = vce_v1_0_bo_size(rdev);\n\telse\n\t\tsize = vce_v2_0_bo_size(rdev);\n\tr = radeon_bo_create(rdev, size, PAGE_SIZE, true,\n\t\t\t     RADEON_GEM_DOMAIN_VRAM, 0, NULL, NULL,\n\t\t\t     &rdev->vce.vcpu_bo);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"(%d) failed to allocate VCE bo\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_bo_reserve(rdev->vce.vcpu_bo, false);\n\tif (r) {\n\t\tradeon_bo_unref(&rdev->vce.vcpu_bo);\n\t\tdev_err(rdev->dev, \"(%d) failed to reserve VCE bo\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_bo_pin(rdev->vce.vcpu_bo, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t  &rdev->vce.gpu_addr);\n\tradeon_bo_unreserve(rdev->vce.vcpu_bo);\n\tif (r) {\n\t\tradeon_bo_unref(&rdev->vce.vcpu_bo);\n\t\tdev_err(rdev->dev, \"(%d) VCE bo pin failed\\n\", r);\n\t\treturn r;\n\t}\n\n\tfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\n\t\tatomic_set(&rdev->vce.handles[i], 0);\n\t\trdev->vce.filp[i] = NULL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid radeon_vce_fini(struct radeon_device *rdev)\n{\n\tif (rdev->vce.vcpu_bo == NULL)\n\t\treturn;\n\n\tradeon_bo_unref(&rdev->vce.vcpu_bo);\n\n\trelease_firmware(rdev->vce_fw);\n}\n\n \nint radeon_vce_suspend(struct radeon_device *rdev)\n{\n\tint i;\n\n\tif (rdev->vce.vcpu_bo == NULL)\n\t\treturn 0;\n\n\tfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i)\n\t\tif (atomic_read(&rdev->vce.handles[i]))\n\t\t\tbreak;\n\n\tif (i == RADEON_MAX_VCE_HANDLES)\n\t\treturn 0;\n\n\t \n\treturn -EINVAL;\n}\n\n \nint radeon_vce_resume(struct radeon_device *rdev)\n{\n\tvoid *cpu_addr;\n\tint r;\n\n\tif (rdev->vce.vcpu_bo == NULL)\n\t\treturn -EINVAL;\n\n\tr = radeon_bo_reserve(rdev->vce.vcpu_bo, false);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"(%d) failed to reserve VCE bo\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_bo_kmap(rdev->vce.vcpu_bo, &cpu_addr);\n\tif (r) {\n\t\tradeon_bo_unreserve(rdev->vce.vcpu_bo);\n\t\tdev_err(rdev->dev, \"(%d) VCE map failed\\n\", r);\n\t\treturn r;\n\t}\n\n\tmemset(cpu_addr, 0, radeon_bo_size(rdev->vce.vcpu_bo));\n\tif (rdev->family < CHIP_BONAIRE)\n\t\tr = vce_v1_0_load_fw(rdev, cpu_addr);\n\telse\n\t\tmemcpy(cpu_addr, rdev->vce_fw->data, rdev->vce_fw->size);\n\n\tradeon_bo_kunmap(rdev->vce.vcpu_bo);\n\n\tradeon_bo_unreserve(rdev->vce.vcpu_bo);\n\n\treturn r;\n}\n\n \nstatic void radeon_vce_idle_work_handler(struct work_struct *work)\n{\n\tstruct radeon_device *rdev =\n\t\tcontainer_of(work, struct radeon_device, vce.idle_work.work);\n\n\tif ((radeon_fence_count_emitted(rdev, TN_RING_TYPE_VCE1_INDEX) == 0) &&\n\t    (radeon_fence_count_emitted(rdev, TN_RING_TYPE_VCE2_INDEX) == 0)) {\n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t\tradeon_dpm_enable_vce(rdev, false);\n\t\t} else {\n\t\t\tradeon_set_vce_clocks(rdev, 0, 0);\n\t\t}\n\t} else {\n\t\tschedule_delayed_work(&rdev->vce.idle_work,\n\t\t\t\t      msecs_to_jiffies(VCE_IDLE_TIMEOUT_MS));\n\t}\n}\n\n \nvoid radeon_vce_note_usage(struct radeon_device *rdev)\n{\n\tbool streams_changed = false;\n\tbool set_clocks = !cancel_delayed_work_sync(&rdev->vce.idle_work);\n\tset_clocks &= schedule_delayed_work(&rdev->vce.idle_work,\n\t\t\t\t\t    msecs_to_jiffies(VCE_IDLE_TIMEOUT_MS));\n\n\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t \n\t\tstreams_changed = false;\n\t}\n\n\tif (set_clocks || streams_changed) {\n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\n\t\t\tradeon_dpm_enable_vce(rdev, true);\n\t\t} else {\n\t\t\tradeon_set_vce_clocks(rdev, 53300, 40000);\n\t\t}\n\t}\n}\n\n \nvoid radeon_vce_free_handles(struct radeon_device *rdev, struct drm_file *filp)\n{\n\tint i, r;\n\tfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\n\t\tuint32_t handle = atomic_read(&rdev->vce.handles[i]);\n\t\tif (!handle || rdev->vce.filp[i] != filp)\n\t\t\tcontinue;\n\n\t\tradeon_vce_note_usage(rdev);\n\n\t\tr = radeon_vce_get_destroy_msg(rdev, TN_RING_TYPE_VCE1_INDEX,\n\t\t\t\t\t       handle, NULL);\n\t\tif (r)\n\t\t\tDRM_ERROR(\"Error destroying VCE handle (%d)!\\n\", r);\n\n\t\trdev->vce.filp[i] = NULL;\n\t\tatomic_set(&rdev->vce.handles[i], 0);\n\t}\n}\n\n \nint radeon_vce_get_create_msg(struct radeon_device *rdev, int ring,\n\t\t\t      uint32_t handle, struct radeon_fence **fence)\n{\n\tconst unsigned ib_size_dw = 1024;\n\tstruct radeon_ib ib;\n\tuint64_t dummy;\n\tint i, r;\n\n\tr = radeon_ib_get(rdev, ring, &ib, NULL, ib_size_dw * 4);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get ib (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tdummy = ib.gpu_addr + 1024;\n\n\t \n\tib.length_dw = 0;\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(handle);\n\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000030);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x01000001);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000042);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000a);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000080);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000060);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000100);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000000);\n\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));\n\tib.ptr[ib.length_dw++] = cpu_to_le32(dummy);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\n\n\tfor (i = ib.length_dw; i < ib_size_dw; ++i)\n\t\tib.ptr[i] = cpu_to_le32(0x0);\n\n\tr = radeon_ib_schedule(rdev, &ib, NULL, false);\n\tif (r)\n\t\tDRM_ERROR(\"radeon: failed to schedule ib (%d).\\n\", r);\n\n\n\tif (fence)\n\t\t*fence = radeon_fence_ref(ib.fence);\n\n\tradeon_ib_free(rdev, &ib);\n\n\treturn r;\n}\n\n \nint radeon_vce_get_destroy_msg(struct radeon_device *rdev, int ring,\n\t\t\t       uint32_t handle, struct radeon_fence **fence)\n{\n\tconst unsigned ib_size_dw = 1024;\n\tstruct radeon_ib ib;\n\tuint64_t dummy;\n\tint i, r;\n\n\tr = radeon_ib_get(rdev, ring, &ib, NULL, ib_size_dw * 4);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get ib (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tdummy = ib.gpu_addr + 1024;\n\n\t \n\tib.length_dw = 0;\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x0000000c);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(handle);\n\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000014);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x05000005);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(upper_32_bits(dummy));\n\tib.ptr[ib.length_dw++] = cpu_to_le32(dummy);\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000001);\n\n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x00000008);  \n\tib.ptr[ib.length_dw++] = cpu_to_le32(0x02000001);  \n\n\tfor (i = ib.length_dw; i < ib_size_dw; ++i)\n\t\tib.ptr[i] = cpu_to_le32(0x0);\n\n\tr = radeon_ib_schedule(rdev, &ib, NULL, false);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to schedule ib (%d).\\n\", r);\n\t}\n\n\tif (fence)\n\t\t*fence = radeon_fence_ref(ib.fence);\n\n\tradeon_ib_free(rdev, &ib);\n\n\treturn r;\n}\n\n \nint radeon_vce_cs_reloc(struct radeon_cs_parser *p, int lo, int hi,\n\t\t\tunsigned size)\n{\n\tstruct radeon_cs_chunk *relocs_chunk;\n\tstruct radeon_bo_list *reloc;\n\tuint64_t start, end, offset;\n\tunsigned idx;\n\n\trelocs_chunk = p->chunk_relocs;\n\toffset = radeon_get_ib_value(p, lo);\n\tidx = radeon_get_ib_value(p, hi);\n\n\tif (idx >= relocs_chunk->length_dw) {\n\t\tDRM_ERROR(\"Relocs at %d after relocations chunk end %d !\\n\",\n\t\t\t  idx, relocs_chunk->length_dw);\n\t\treturn -EINVAL;\n\t}\n\n\treloc = &p->relocs[(idx / 4)];\n\tstart = reloc->gpu_offset;\n\tend = start + radeon_bo_size(reloc->robj);\n\tstart += offset;\n\n\tp->ib.ptr[lo] = start & 0xFFFFFFFF;\n\tp->ib.ptr[hi] = start >> 32;\n\n\tif (end <= start) {\n\t\tDRM_ERROR(\"invalid reloc offset %llX!\\n\", offset);\n\t\treturn -EINVAL;\n\t}\n\tif ((end - start) < size) {\n\t\tDRM_ERROR(\"buffer to small (%d / %d)!\\n\",\n\t\t\t(unsigned)(end - start), size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int radeon_vce_validate_handle(struct radeon_cs_parser *p,\n\t\t\t\t      uint32_t handle, bool *allocated)\n{\n\tunsigned i;\n\n\t*allocated = false;\n\n\t \n\tfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\n\t\tif (atomic_read(&p->rdev->vce.handles[i]) == handle) {\n\t\t\tif (p->rdev->vce.filp[i] != p->filp) {\n\t\t\t\tDRM_ERROR(\"VCE handle collision detected!\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i) {\n\t\tif (!atomic_cmpxchg(&p->rdev->vce.handles[i], 0, handle)) {\n\t\t\tp->rdev->vce.filp[i] = p->filp;\n\t\t\tp->rdev->vce.img_size[i] = 0;\n\t\t\t*allocated = true;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tDRM_ERROR(\"No more free VCE handles!\\n\");\n\treturn -EINVAL;\n}\n\n \nint radeon_vce_cs_parse(struct radeon_cs_parser *p)\n{\n\tint session_idx = -1;\n\tbool destroyed = false, created = false, allocated = false;\n\tuint32_t tmp, handle = 0;\n\tuint32_t *size = &tmp;\n\tint i, r = 0;\n\n\twhile (p->idx < p->chunk_ib->length_dw) {\n\t\tuint32_t len = radeon_get_ib_value(p, p->idx);\n\t\tuint32_t cmd = radeon_get_ib_value(p, p->idx + 1);\n\n\t\tif ((len < 8) || (len & 3)) {\n\t\t\tDRM_ERROR(\"invalid VCE command length (%d)!\\n\", len);\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (destroyed) {\n\t\t\tDRM_ERROR(\"No other command allowed after destroy!\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase 0x00000001: \n\t\t\thandle = radeon_get_ib_value(p, p->idx + 2);\n\t\t\tsession_idx = radeon_vce_validate_handle(p, handle,\n\t\t\t\t\t\t\t\t &allocated);\n\t\t\tif (session_idx < 0)\n\t\t\t\treturn session_idx;\n\t\t\tsize = &p->rdev->vce.img_size[session_idx];\n\t\t\tbreak;\n\n\t\tcase 0x00000002: \n\t\t\tbreak;\n\n\t\tcase 0x01000001: \n\t\t\tcreated = true;\n\t\t\tif (!allocated) {\n\t\t\t\tDRM_ERROR(\"Handle already in use!\\n\");\n\t\t\t\tr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*size = radeon_get_ib_value(p, p->idx + 8) *\n\t\t\t\tradeon_get_ib_value(p, p->idx + 10) *\n\t\t\t\t8 * 3 / 2;\n\t\t\tbreak;\n\n\t\tcase 0x04000001: \n\t\tcase 0x04000002: \n\t\tcase 0x04000005: \n\t\tcase 0x04000007: \n\t\tcase 0x04000008: \n\t\tcase 0x04000009: \n\t\t\tbreak;\n\n\t\tcase 0x03000001: \n\t\t\tr = radeon_vce_cs_reloc(p, p->idx + 10, p->idx + 9,\n\t\t\t\t\t\t*size);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\n\t\t\tr = radeon_vce_cs_reloc(p, p->idx + 12, p->idx + 11,\n\t\t\t\t\t\t*size / 3);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase 0x02000001: \n\t\t\tdestroyed = true;\n\t\t\tbreak;\n\n\t\tcase 0x05000001: \n\t\t\tr = radeon_vce_cs_reloc(p, p->idx + 3, p->idx + 2,\n\t\t\t\t\t\t*size * 2);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase 0x05000004: \n\t\t\ttmp = radeon_get_ib_value(p, p->idx + 4);\n\t\t\tr = radeon_vce_cs_reloc(p, p->idx + 3, p->idx + 2,\n\t\t\t\t\t\ttmp);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tcase 0x05000005: \n\t\t\tr = radeon_vce_cs_reloc(p, p->idx + 3, p->idx + 2,\n\t\t\t\t\t\t4096);\n\t\t\tif (r)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tDRM_ERROR(\"invalid VCE command (0x%x)!\\n\", cmd);\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (session_idx == -1) {\n\t\t\tDRM_ERROR(\"no session command at start of IB\\n\");\n\t\t\tr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tp->idx += len / 4;\n\t}\n\n\tif (allocated && !created) {\n\t\tDRM_ERROR(\"New session without create command!\\n\");\n\t\tr = -ENOENT;\n\t}\n\nout:\n\tif ((!r && destroyed) || (r && allocated)) {\n\t\t \n\t\tfor (i = 0; i < RADEON_MAX_VCE_HANDLES; ++i)\n\t\t\tatomic_cmpxchg(&p->rdev->vce.handles[i], handle, 0);\n\t}\n\n\treturn r;\n}\n\n \nbool radeon_vce_semaphore_emit(struct radeon_device *rdev,\n\t\t\t       struct radeon_ring *ring,\n\t\t\t       struct radeon_semaphore *semaphore,\n\t\t\t       bool emit_wait)\n{\n\tuint64_t addr = semaphore->gpu_addr;\n\n\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_SEMAPHORE));\n\tradeon_ring_write(ring, cpu_to_le32((addr >> 3) & 0x000FFFFF));\n\tradeon_ring_write(ring, cpu_to_le32((addr >> 23) & 0x000FFFFF));\n\tradeon_ring_write(ring, cpu_to_le32(0x01003000 | (emit_wait ? 1 : 0)));\n\tif (!emit_wait)\n\t\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));\n\n\treturn true;\n}\n\n \nvoid radeon_vce_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_IB));\n\tradeon_ring_write(ring, cpu_to_le32(ib->gpu_addr));\n\tradeon_ring_write(ring, cpu_to_le32(upper_32_bits(ib->gpu_addr)));\n\tradeon_ring_write(ring, cpu_to_le32(ib->length_dw));\n}\n\n \nvoid radeon_vce_fence_emit(struct radeon_device *rdev,\n\t\t\t   struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tuint64_t addr = rdev->fence_drv[fence->ring].gpu_addr;\n\n\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_FENCE));\n\tradeon_ring_write(ring, cpu_to_le32(addr));\n\tradeon_ring_write(ring, cpu_to_le32(upper_32_bits(addr)));\n\tradeon_ring_write(ring, cpu_to_le32(fence->seq));\n\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_TRAP));\n\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));\n}\n\n \nint radeon_vce_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t rptr = vce_v1_0_get_rptr(rdev, ring);\n\tunsigned i;\n\tint r;\n\n\tr = radeon_ring_lock(rdev, ring, 16);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: vce failed to lock ring %d (%d).\\n\",\n\t\t\t  ring->idx, r);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, cpu_to_le32(VCE_CMD_END));\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (vce_v1_0_get_rptr(rdev, ring) != rptr)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ring test on %d succeeded in %d usecs\\n\",\n\t\t\t ring->idx, i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ring %d test failed\\n\",\n\t\t\t ring->idx);\n\t\tr = -ETIMEDOUT;\n\t}\n\n\treturn r;\n}\n\n \nint radeon_vce_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tstruct radeon_fence *fence = NULL;\n\tint r;\n\n\tr = radeon_vce_get_create_msg(rdev, ring->idx, 1, NULL);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get create msg (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\n\tr = radeon_vce_get_destroy_msg(rdev, ring->idx, 1, &fence);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get destroy ib (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\n\tr = radeon_fence_wait_timeout(fence, false, usecs_to_jiffies(\n\t\tRADEON_USEC_IB_TEST_TIMEOUT));\n\tif (r < 0) {\n\t\tDRM_ERROR(\"radeon: fence wait failed (%d).\\n\", r);\n\t} else if (r == 0) {\n\t\tDRM_ERROR(\"radeon: fence wait timed out.\\n\");\n\t\tr = -ETIMEDOUT;\n\t} else {\n\t\tDRM_INFO(\"ib test on ring %d succeeded\\n\", ring->idx);\n\t\tr = 0;\n\t}\nerror:\n\tradeon_fence_unref(&fence);\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}