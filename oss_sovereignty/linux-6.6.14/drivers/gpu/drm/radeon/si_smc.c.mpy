{
  "module_name": "si_smc.c",
  "hash_id": "8a4548b75264dbeaecfe3a1ce31b8301190edfbb10386d85ba2413e4b48907cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/si_smc.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"radeon.h\"\n#include \"sid.h\"\n#include \"ppsmc.h\"\n#include \"radeon_ucode.h\"\n#include \"sislands_smc.h\"\n\nstatic int si_set_smc_sram_address(struct radeon_device *rdev,\n\t\t\t\t   u32 smc_address, u32 limit)\n{\n\tif (smc_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_address + 3) > limit)\n\t\treturn -EINVAL;\n\n\tWREG32(SMC_IND_INDEX_0, smc_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\n\treturn 0;\n}\n\nint si_copy_bytes_to_smc(struct radeon_device *rdev,\n\t\t\t u32 smc_start_address,\n\t\t\t const u8 *src, u32 byte_count, u32 limit)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 data, original_data, addr, extra_shift;\n\n\tif (smc_start_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_start_address + byte_count) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_start_address;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\twhile (byte_count >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tret = si_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\t \n\tif (byte_count > 0) {\n\t\tdata = 0;\n\n\t\tret = si_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\toriginal_data = RREG32(SMC_IND_DATA_0);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (data << 8) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tret = si_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nvoid si_start_smc(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\n\ttmp &= ~RST_REG;\n\n\tWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\n}\n\nvoid si_reset_smc(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\n\ttmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\ttmp |= RST_REG;\n\tWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\n}\n\nint si_program_jump_on_start(struct radeon_device *rdev)\n{\n\tstatic const u8 data[] = { 0x0E, 0x00, 0x40, 0x40 };\n\n\treturn si_copy_bytes_to_smc(rdev, 0x0, data, 4, sizeof(data)+1);\n}\n\nvoid si_stop_smc_clock(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\ttmp |= CK_DISABLE;\n\n\tWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\n}\n\nvoid si_start_smc_clock(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\ttmp &= ~CK_DISABLE;\n\n\tWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\n}\n\nbool si_is_smc_running(struct radeon_device *rdev)\n{\n\tu32 rst = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\tu32 clk = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\tif (!(rst & RST_REG) && !(clk & CK_DISABLE))\n\t\treturn true;\n\n\treturn false;\n}\n\nPPSMC_Result si_send_msg_to_smc(struct radeon_device *rdev, PPSMC_Msg msg)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!si_is_smc_running(rdev))\n\t\treturn PPSMC_Result_Failed;\n\n\tWREG32(SMC_MESSAGE_0, msg);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(SMC_RESP_0);\n\t\tif (tmp != 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\ttmp = RREG32(SMC_RESP_0);\n\n\treturn (PPSMC_Result)tmp;\n}\n\nPPSMC_Result si_wait_for_smc_inactive(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!si_is_smc_running(rdev))\n\t\treturn PPSMC_Result_OK;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\t\tif ((tmp & CKEN) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn PPSMC_Result_OK;\n}\n\nint si_load_smc_ucode(struct radeon_device *rdev, u32 limit)\n{\n\tunsigned long flags;\n\tu32 ucode_start_address;\n\tu32 ucode_size;\n\tconst u8 *src;\n\tu32 data;\n\n\tif (!rdev->smc_fw)\n\t\treturn -EINVAL;\n\n\tif (rdev->new_fw) {\n\t\tconst struct smc_firmware_header_v1_0 *hdr =\n\t\t\t(const struct smc_firmware_header_v1_0 *)rdev->smc_fw->data;\n\n\t\tradeon_ucode_print_smc_hdr(&hdr->header);\n\n\t\tucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\n\t\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\n\t\tsrc = (const u8 *)\n\t\t\t(rdev->smc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t} else {\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_TAHITI:\n\t\t\tucode_start_address = TAHITI_SMC_UCODE_START;\n\t\t\tucode_size = TAHITI_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_PITCAIRN:\n\t\t\tucode_start_address = PITCAIRN_SMC_UCODE_START;\n\t\t\tucode_size = PITCAIRN_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_VERDE:\n\t\t\tucode_start_address = VERDE_SMC_UCODE_START;\n\t\t\tucode_size = VERDE_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_OLAND:\n\t\t\tucode_start_address = OLAND_SMC_UCODE_START;\n\t\t\tucode_size = OLAND_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_HAINAN:\n\t\t\tucode_start_address = HAINAN_SMC_UCODE_START;\n\t\t\tucode_size = HAINAN_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown asic in smc ucode loader\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tsrc = (const u8 *)rdev->smc_fw->data;\n\t}\n\n\tif (ucode_size & 3)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tWREG32(SMC_IND_INDEX_0, ucode_start_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, ~AUTO_INCREMENT_IND_0);\n\twhile (ucode_size >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tucode_size -= 4;\n\t}\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn 0;\n}\n\nint si_read_smc_sram_dword(struct radeon_device *rdev, u32 smc_address,\n\t\t\t   u32 *value, u32 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tret = si_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret == 0)\n\t\t*value = RREG32(SMC_IND_DATA_0);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nint si_write_smc_sram_dword(struct radeon_device *rdev, u32 smc_address,\n\t\t\t    u32 value, u32 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tret = si_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret == 0)\n\t\tWREG32(SMC_IND_DATA_0, value);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}