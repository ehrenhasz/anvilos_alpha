{
  "module_name": "si_dma.c",
  "hash_id": "18937fdd26dd3729ce27d4cb03d043389a9190569d5ed2ba269a9d662fcfca7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/si_dma.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_trace.h\"\n#include \"si.h\"\n#include \"sid.h\"\n\n \nbool si_dma_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 reset_mask = si_gpu_check_soft_reset(rdev);\n\tu32 mask;\n\n\tif (ring->idx == R600_RING_TYPE_DMA_INDEX)\n\t\tmask = RADEON_RESET_DMA;\n\telse\n\t\tmask = RADEON_RESET_DMA1;\n\n\tif (!(reset_mask & mask)) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\n \nvoid si_dma_vm_copy_pages(struct radeon_device *rdev,\n\t\t\t  struct radeon_ib *ib,\n\t\t\t  uint64_t pe, uint64_t src,\n\t\t\t  unsigned count)\n{\n\twhile (count) {\n\t\tunsigned bytes = count * 8;\n\t\tif (bytes > 0xFFFF8)\n\t\t\tbytes = 0xFFFF8;\n\n\t\tib->ptr[ib->length_dw++] = DMA_PACKET(DMA_PACKET_COPY,\n\t\t\t\t\t\t      1, 0, 0, bytes);\n\t\tib->ptr[ib->length_dw++] = lower_32_bits(pe);\n\t\tib->ptr[ib->length_dw++] = lower_32_bits(src);\n\t\tib->ptr[ib->length_dw++] = upper_32_bits(pe) & 0xff;\n\t\tib->ptr[ib->length_dw++] = upper_32_bits(src) & 0xff;\n\n\t\tpe += bytes;\n\t\tsrc += bytes;\n\t\tcount -= bytes / 8;\n\t}\n}\n\n \nvoid si_dma_vm_write_pages(struct radeon_device *rdev,\n\t\t\t   struct radeon_ib *ib,\n\t\t\t   uint64_t pe,\n\t\t\t   uint64_t addr, unsigned count,\n\t\t\t   uint32_t incr, uint32_t flags)\n{\n\tuint64_t value;\n\tunsigned ndw;\n\n\twhile (count) {\n\t\tndw = count * 2;\n\t\tif (ndw > 0xFFFFE)\n\t\t\tndw = 0xFFFFE;\n\n\t\t \n\t\tib->ptr[ib->length_dw++] = DMA_PACKET(DMA_PACKET_WRITE, 0, 0, 0, ndw);\n\t\tib->ptr[ib->length_dw++] = pe;\n\t\tib->ptr[ib->length_dw++] = upper_32_bits(pe) & 0xff;\n\t\tfor (; ndw > 0; ndw -= 2, --count, pe += 8) {\n\t\t\tif (flags & R600_PTE_SYSTEM) {\n\t\t\t\tvalue = radeon_vm_map_gart(rdev, addr);\n\t\t\t} else if (flags & R600_PTE_VALID) {\n\t\t\t\tvalue = addr;\n\t\t\t} else {\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\taddr += incr;\n\t\t\tvalue |= flags;\n\t\t\tib->ptr[ib->length_dw++] = value;\n\t\t\tib->ptr[ib->length_dw++] = upper_32_bits(value);\n\t\t}\n\t}\n}\n\n \nvoid si_dma_vm_set_pages(struct radeon_device *rdev,\n\t\t\t struct radeon_ib *ib,\n\t\t\t uint64_t pe,\n\t\t\t uint64_t addr, unsigned count,\n\t\t\t uint32_t incr, uint32_t flags)\n{\n\tuint64_t value;\n\tunsigned ndw;\n\n\twhile (count) {\n\t\tndw = count * 2;\n\t\tif (ndw > 0xFFFFE)\n\t\t\tndw = 0xFFFFE;\n\n\t\tif (flags & R600_PTE_VALID)\n\t\t\tvalue = addr;\n\t\telse\n\t\t\tvalue = 0;\n\n\t\t \n\t\tib->ptr[ib->length_dw++] = DMA_PTE_PDE_PACKET(ndw);\n\t\tib->ptr[ib->length_dw++] = pe;  \n\t\tib->ptr[ib->length_dw++] = upper_32_bits(pe) & 0xff;\n\t\tib->ptr[ib->length_dw++] = flags;  \n\t\tib->ptr[ib->length_dw++] = 0;\n\t\tib->ptr[ib->length_dw++] = value;  \n\t\tib->ptr[ib->length_dw++] = upper_32_bits(value);\n\t\tib->ptr[ib->length_dw++] = incr;  \n\t\tib->ptr[ib->length_dw++] = 0;\n\t\tpe += ndw * 4;\n\t\taddr += (ndw / 2) * incr;\n\t\tcount -= ndw / 2;\n\t}\n}\n\nvoid si_dma_vm_flush(struct radeon_device *rdev, struct radeon_ring *ring,\n\t\t     unsigned vm_id, uint64_t pd_addr)\n\n{\n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0, 0, 0));\n\tif (vm_id < 8) {\n\t\tradeon_ring_write(ring, (0xf << 16) | ((VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (vm_id << 2)) >> 2));\n\t} else {\n\t\tradeon_ring_write(ring, (0xf << 16) | ((VM_CONTEXT8_PAGE_TABLE_BASE_ADDR + ((vm_id - 8) << 2)) >> 2));\n\t}\n\tradeon_ring_write(ring, pd_addr >> 12);\n\n\t \n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0, 0, 0));\n\tradeon_ring_write(ring, (0xf << 16) | (HDP_MEM_COHERENCY_FLUSH_CNTL >> 2));\n\tradeon_ring_write(ring, 1);\n\n\t \n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0, 0, 0));\n\tradeon_ring_write(ring, (0xf << 16) | (VM_INVALIDATE_REQUEST >> 2));\n\tradeon_ring_write(ring, 1 << vm_id);\n\n\t \n\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_POLL_REG_MEM, 0, 0, 0, 0));\n\tradeon_ring_write(ring, VM_INVALIDATE_REQUEST);\n\tradeon_ring_write(ring, 0xff << 16);  \n\tradeon_ring_write(ring, 1 << vm_id);  \n\tradeon_ring_write(ring, 0);  \n\tradeon_ring_write(ring, (0 << 28) | 0x20);  \n}\n\n \nstruct radeon_fence *si_copy_dma(struct radeon_device *rdev,\n\t\t\t\t uint64_t src_offset, uint64_t dst_offset,\n\t\t\t\t unsigned num_gpu_pages,\n\t\t\t\t struct dma_resv *resv)\n{\n\tstruct radeon_fence *fence;\n\tstruct radeon_sync sync;\n\tint ring_index = rdev->asic->copy.dma_ring_index;\n\tstruct radeon_ring *ring = &rdev->ring[ring_index];\n\tu32 size_in_bytes, cur_size_in_bytes;\n\tint i, num_loops;\n\tint r = 0;\n\n\tradeon_sync_create(&sync);\n\n\tsize_in_bytes = (num_gpu_pages << RADEON_GPU_PAGE_SHIFT);\n\tnum_loops = DIV_ROUND_UP(size_in_bytes, 0xfffff);\n\tr = radeon_ring_lock(rdev, ring, num_loops * 5 + 11);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: moving bo (%d).\\n\", r);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_sync_resv(rdev, &sync, resv, false);\n\tradeon_sync_rings(rdev, &sync, ring->idx);\n\n\tfor (i = 0; i < num_loops; i++) {\n\t\tcur_size_in_bytes = size_in_bytes;\n\t\tif (cur_size_in_bytes > 0xFFFFF)\n\t\t\tcur_size_in_bytes = 0xFFFFF;\n\t\tsize_in_bytes -= cur_size_in_bytes;\n\t\tradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_COPY, 1, 0, 0, cur_size_in_bytes));\n\t\tradeon_ring_write(ring, lower_32_bits(dst_offset));\n\t\tradeon_ring_write(ring, lower_32_bits(src_offset));\n\t\tradeon_ring_write(ring, upper_32_bits(dst_offset) & 0xff);\n\t\tradeon_ring_write(ring, upper_32_bits(src_offset) & 0xff);\n\t\tsrc_offset += cur_size_in_bytes;\n\t\tdst_offset += cur_size_in_bytes;\n\t}\n\n\tr = radeon_fence_emit(rdev, &fence, ring->idx);\n\tif (r) {\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\tradeon_sync_free(rdev, &sync, NULL);\n\t\treturn ERR_PTR(r);\n\t}\n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tradeon_sync_free(rdev, &sync, fence);\n\n\treturn fence;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}