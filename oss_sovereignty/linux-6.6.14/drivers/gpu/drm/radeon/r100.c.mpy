{
  "module_name": "r100.c",
  "hash_id": "bd7eafda5a43b5998e370c7b74ad23ec077f3acdf15549dc801785f37a21d1c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/r100.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_vblank.h>\n#include <drm/radeon_drm.h>\n\n#include \"atom.h\"\n#include \"r100_reg_safe.h\"\n#include \"r100d.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_reg.h\"\n#include \"rn50_reg_safe.h\"\n#include \"rs100d.h\"\n#include \"rv200d.h\"\n#include \"rv250d.h\"\n\n \n#define FIRMWARE_R100\t\t\"radeon/R100_cp.bin\"\n#define FIRMWARE_R200\t\t\"radeon/R200_cp.bin\"\n#define FIRMWARE_R300\t\t\"radeon/R300_cp.bin\"\n#define FIRMWARE_R420\t\t\"radeon/R420_cp.bin\"\n#define FIRMWARE_RS690\t\t\"radeon/RS690_cp.bin\"\n#define FIRMWARE_RS600\t\t\"radeon/RS600_cp.bin\"\n#define FIRMWARE_R520\t\t\"radeon/R520_cp.bin\"\n\nMODULE_FIRMWARE(FIRMWARE_R100);\nMODULE_FIRMWARE(FIRMWARE_R200);\nMODULE_FIRMWARE(FIRMWARE_R300);\nMODULE_FIRMWARE(FIRMWARE_R420);\nMODULE_FIRMWARE(FIRMWARE_RS690);\nMODULE_FIRMWARE(FIRMWARE_RS600);\nMODULE_FIRMWARE(FIRMWARE_R520);\n\n#include \"r100_track.h\"\n\n \n\nstatic bool r100_is_in_vblank(struct radeon_device *rdev, int crtc)\n{\n\tif (crtc == 0) {\n\t\tif (RREG32(RADEON_CRTC_STATUS) & RADEON_CRTC_VBLANK_CUR)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t} else {\n\t\tif (RREG32(RADEON_CRTC2_STATUS) & RADEON_CRTC2_VBLANK_CUR)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\nstatic bool r100_is_counter_moving(struct radeon_device *rdev, int crtc)\n{\n\tu32 vline1, vline2;\n\n\tif (crtc == 0) {\n\t\tvline1 = (RREG32(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\n\t\tvline2 = (RREG32(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\n\t} else {\n\t\tvline1 = (RREG32(RADEON_CRTC2_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\n\t\tvline2 = (RREG32(RADEON_CRTC2_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\n\t}\n\tif (vline1 != vline2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\n \nvoid r100_wait_for_vblank(struct radeon_device *rdev, int crtc)\n{\n\tunsigned i = 0;\n\n\tif (crtc >= rdev->num_crtc)\n\t\treturn;\n\n\tif (crtc == 0) {\n\t\tif (!(RREG32(RADEON_CRTC_GEN_CNTL) & RADEON_CRTC_EN))\n\t\t\treturn;\n\t} else {\n\t\tif (!(RREG32(RADEON_CRTC2_GEN_CNTL) & RADEON_CRTC2_EN))\n\t\t\treturn;\n\t}\n\n\t \n\twhile (r100_is_in_vblank(rdev, crtc)) {\n\t\tif (i++ % 100 == 0) {\n\t\t\tif (!r100_is_counter_moving(rdev, crtc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twhile (!r100_is_in_vblank(rdev, crtc)) {\n\t\tif (i++ % 100 == 0) {\n\t\t\tif (!r100_is_counter_moving(rdev, crtc))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nvoid r100_page_flip(struct radeon_device *rdev, int crtc_id, u64 crtc_base, bool async)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\tuint32_t crtc_pitch, pitch_pixels;\n\tstruct drm_framebuffer *fb = radeon_crtc->base.primary->fb;\n\tu32 tmp = ((u32)crtc_base) | RADEON_CRTC_OFFSET__OFFSET_LOCK;\n\tint i;\n\n\t \n\t \n\tWREG32(RADEON_CRTC_OFFSET + radeon_crtc->crtc_offset, tmp);\n\n\t \n\tpitch_pixels = fb->pitches[0] / fb->format->cpp[0];\n\tcrtc_pitch = DIV_ROUND_UP(pitch_pixels * fb->format->cpp[0] * 8,\n\t\t\t\t  fb->format->cpp[0] * 8 * 8);\n\tcrtc_pitch |= crtc_pitch << 16;\n\tWREG32(RADEON_CRTC_PITCH + radeon_crtc->crtc_offset, crtc_pitch);\n\n\t \n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (RREG32(RADEON_CRTC_OFFSET + radeon_crtc->crtc_offset) & RADEON_CRTC_OFFSET__GUI_TRIG_OFFSET)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tDRM_DEBUG(\"Update pending now high. Unlocking vupdate_lock.\\n\");\n\n\t \n\ttmp &= ~RADEON_CRTC_OFFSET__OFFSET_LOCK;\n\tWREG32(RADEON_CRTC_OFFSET + radeon_crtc->crtc_offset, tmp);\n\n}\n\n \nbool r100_page_flip_pending(struct radeon_device *rdev, int crtc_id)\n{\n\tstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\n\n\t \n\treturn !!(RREG32(RADEON_CRTC_OFFSET + radeon_crtc->crtc_offset) &\n\t\tRADEON_CRTC_OFFSET__GUI_TRIG_OFFSET);\n}\n\n \nvoid r100_pm_get_dynpm_state(struct radeon_device *rdev)\n{\n\tint i;\n\trdev->pm.dynpm_can_upclock = true;\n\trdev->pm.dynpm_can_downclock = true;\n\n\tswitch (rdev->pm.dynpm_planned_action) {\n\tcase DYNPM_ACTION_MINIMUM:\n\t\trdev->pm.requested_power_state_index = 0;\n\t\trdev->pm.dynpm_can_downclock = false;\n\t\tbreak;\n\tcase DYNPM_ACTION_DOWNCLOCK:\n\t\tif (rdev->pm.current_power_state_index == 0) {\n\t\t\trdev->pm.requested_power_state_index = rdev->pm.current_power_state_index;\n\t\t\trdev->pm.dynpm_can_downclock = false;\n\t\t} else {\n\t\t\tif (rdev->pm.active_crtc_count > 1) {\n\t\t\t\tfor (i = 0; i < rdev->pm.num_power_states; i++) {\n\t\t\t\t\tif (rdev->pm.power_state[i].flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (i >= rdev->pm.current_power_state_index) {\n\t\t\t\t\t\trdev->pm.requested_power_state_index = rdev->pm.current_power_state_index;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trdev->pm.requested_power_state_index = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\trdev->pm.current_power_state_index - 1;\n\t\t}\n\t\t \n\t\tif ((rdev->pm.active_crtc_count > 0) &&\n\t\t    (rdev->pm.power_state[rdev->pm.requested_power_state_index].clock_info[0].flags &\n\t\t     RADEON_PM_MODE_NO_DISPLAY)) {\n\t\t\trdev->pm.requested_power_state_index++;\n\t\t}\n\t\tbreak;\n\tcase DYNPM_ACTION_UPCLOCK:\n\t\tif (rdev->pm.current_power_state_index == (rdev->pm.num_power_states - 1)) {\n\t\t\trdev->pm.requested_power_state_index = rdev->pm.current_power_state_index;\n\t\t\trdev->pm.dynpm_can_upclock = false;\n\t\t} else {\n\t\t\tif (rdev->pm.active_crtc_count > 1) {\n\t\t\t\tfor (i = (rdev->pm.num_power_states - 1); i >= 0; i--) {\n\t\t\t\t\tif (rdev->pm.power_state[i].flags & RADEON_PM_STATE_SINGLE_DISPLAY_ONLY)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (i <= rdev->pm.current_power_state_index) {\n\t\t\t\t\t\trdev->pm.requested_power_state_index = rdev->pm.current_power_state_index;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trdev->pm.requested_power_state_index = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\trdev->pm.requested_power_state_index =\n\t\t\t\t\trdev->pm.current_power_state_index + 1;\n\t\t}\n\t\tbreak;\n\tcase DYNPM_ACTION_DEFAULT:\n\t\trdev->pm.requested_power_state_index = rdev->pm.default_power_state_index;\n\t\trdev->pm.dynpm_can_upclock = false;\n\t\tbreak;\n\tcase DYNPM_ACTION_NONE:\n\tdefault:\n\t\tDRM_ERROR(\"Requested mode for not defined action\\n\");\n\t\treturn;\n\t}\n\t \n\trdev->pm.requested_clock_mode_index = 0;\n\n\tDRM_DEBUG_DRIVER(\"Requested: e: %d m: %d p: %d\\n\",\n\t\t  rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t  clock_info[rdev->pm.requested_clock_mode_index].sclk,\n\t\t  rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t  clock_info[rdev->pm.requested_clock_mode_index].mclk,\n\t\t  rdev->pm.power_state[rdev->pm.requested_power_state_index].\n\t\t  pcie_lanes);\n}\n\n \nvoid r100_pm_init_profile(struct radeon_device *rdev)\n{\n\t \n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_DEFAULT_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_SH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_SH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_SH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_LOW_MH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_MID_MH_IDX].dpms_on_cm_idx = 0;\n\t \n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_ps_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_ps_idx = rdev->pm.default_power_state_index;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_off_cm_idx = 0;\n\trdev->pm.profiles[PM_PROFILE_HIGH_MH_IDX].dpms_on_cm_idx = 0;\n}\n\n \nvoid r100_pm_misc(struct radeon_device *rdev)\n{\n\tint requested_index = rdev->pm.requested_power_state_index;\n\tstruct radeon_power_state *ps = &rdev->pm.power_state[requested_index];\n\tstruct radeon_voltage *voltage = &ps->clock_info[0].voltage;\n\tu32 tmp, sclk_cntl, sclk_cntl2, sclk_more_cntl;\n\n\tif ((voltage->type == VOLTAGE_GPIO) && (voltage->gpio.valid)) {\n\t\tif (ps->misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) {\n\t\t\ttmp = RREG32(voltage->gpio.reg);\n\t\t\tif (voltage->active_high)\n\t\t\t\ttmp |= voltage->gpio.mask;\n\t\t\telse\n\t\t\t\ttmp &= ~(voltage->gpio.mask);\n\t\t\tWREG32(voltage->gpio.reg, tmp);\n\t\t\tif (voltage->delay)\n\t\t\t\tudelay(voltage->delay);\n\t\t} else {\n\t\t\ttmp = RREG32(voltage->gpio.reg);\n\t\t\tif (voltage->active_high)\n\t\t\t\ttmp &= ~voltage->gpio.mask;\n\t\t\telse\n\t\t\t\ttmp |= voltage->gpio.mask;\n\t\t\tWREG32(voltage->gpio.reg, tmp);\n\t\t\tif (voltage->delay)\n\t\t\t\tudelay(voltage->delay);\n\t\t}\n\t}\n\n\tsclk_cntl = RREG32_PLL(SCLK_CNTL);\n\tsclk_cntl2 = RREG32_PLL(SCLK_CNTL2);\n\tsclk_cntl2 &= ~REDUCED_SPEED_SCLK_SEL(3);\n\tsclk_more_cntl = RREG32_PLL(SCLK_MORE_CNTL);\n\tsclk_more_cntl &= ~VOLTAGE_DELAY_SEL(3);\n\tif (ps->misc & ATOM_PM_MISCINFO_ASIC_REDUCED_SPEED_SCLK_EN) {\n\t\tsclk_more_cntl |= REDUCED_SPEED_SCLK_EN;\n\t\tif (ps->misc & ATOM_PM_MISCINFO_DYN_CLK_3D_IDLE)\n\t\t\tsclk_cntl2 |= REDUCED_SPEED_SCLK_MODE;\n\t\telse\n\t\t\tsclk_cntl2 &= ~REDUCED_SPEED_SCLK_MODE;\n\t\tif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_CLOCK_DIVIDER_BY_2)\n\t\t\tsclk_cntl2 |= REDUCED_SPEED_SCLK_SEL(0);\n\t\telse if (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_CLOCK_DIVIDER_BY_4)\n\t\t\tsclk_cntl2 |= REDUCED_SPEED_SCLK_SEL(2);\n\t} else\n\t\tsclk_more_cntl &= ~REDUCED_SPEED_SCLK_EN;\n\n\tif (ps->misc & ATOM_PM_MISCINFO_ASIC_DYNAMIC_VOLTAGE_EN) {\n\t\tsclk_more_cntl |= IO_CG_VOLTAGE_DROP;\n\t\tif (voltage->delay) {\n\t\t\tsclk_more_cntl |= VOLTAGE_DROP_SYNC;\n\t\t\tswitch (voltage->delay) {\n\t\t\tcase 33:\n\t\t\t\tsclk_more_cntl |= VOLTAGE_DELAY_SEL(0);\n\t\t\t\tbreak;\n\t\t\tcase 66:\n\t\t\t\tsclk_more_cntl |= VOLTAGE_DELAY_SEL(1);\n\t\t\t\tbreak;\n\t\t\tcase 99:\n\t\t\t\tsclk_more_cntl |= VOLTAGE_DELAY_SEL(2);\n\t\t\t\tbreak;\n\t\t\tcase 132:\n\t\t\t\tsclk_more_cntl |= VOLTAGE_DELAY_SEL(3);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tsclk_more_cntl &= ~VOLTAGE_DROP_SYNC;\n\t} else\n\t\tsclk_more_cntl &= ~IO_CG_VOLTAGE_DROP;\n\n\tif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_HDP_BLOCK_EN)\n\t\tsclk_cntl &= ~FORCE_HDP;\n\telse\n\t\tsclk_cntl |= FORCE_HDP;\n\n\tWREG32_PLL(SCLK_CNTL, sclk_cntl);\n\tWREG32_PLL(SCLK_CNTL2, sclk_cntl2);\n\tWREG32_PLL(SCLK_MORE_CNTL, sclk_more_cntl);\n\n\t \n\tif ((rdev->flags & RADEON_IS_PCIE) &&\n\t    !(rdev->flags & RADEON_IS_IGP) &&\n\t    rdev->asic->pm.set_pcie_lanes &&\n\t    (ps->pcie_lanes !=\n\t     rdev->pm.power_state[rdev->pm.current_power_state_index].pcie_lanes)) {\n\t\tradeon_set_pcie_lanes(rdev,\n\t\t\t\t      ps->pcie_lanes);\n\t\tDRM_DEBUG_DRIVER(\"Setting: p: %d\\n\", ps->pcie_lanes);\n\t}\n}\n\n \nvoid r100_pm_prepare(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tu32 tmp;\n\n\t \n\tlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\n\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\tif (radeon_crtc->enabled) {\n\t\t\tif (radeon_crtc->crtc_id) {\n\t\t\t\ttmp = RREG32(RADEON_CRTC2_GEN_CNTL);\n\t\t\t\ttmp |= RADEON_CRTC2_DISP_REQ_EN_B;\n\t\t\t\tWREG32(RADEON_CRTC2_GEN_CNTL, tmp);\n\t\t\t} else {\n\t\t\t\ttmp = RREG32(RADEON_CRTC_GEN_CNTL);\n\t\t\t\ttmp |= RADEON_CRTC_DISP_REQ_EN_B;\n\t\t\t\tWREG32(RADEON_CRTC_GEN_CNTL, tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid r100_pm_finish(struct radeon_device *rdev)\n{\n\tstruct drm_device *ddev = rdev->ddev;\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tu32 tmp;\n\n\t \n\tlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\n\t\tradeon_crtc = to_radeon_crtc(crtc);\n\t\tif (radeon_crtc->enabled) {\n\t\t\tif (radeon_crtc->crtc_id) {\n\t\t\t\ttmp = RREG32(RADEON_CRTC2_GEN_CNTL);\n\t\t\t\ttmp &= ~RADEON_CRTC2_DISP_REQ_EN_B;\n\t\t\t\tWREG32(RADEON_CRTC2_GEN_CNTL, tmp);\n\t\t\t} else {\n\t\t\t\ttmp = RREG32(RADEON_CRTC_GEN_CNTL);\n\t\t\t\ttmp &= ~RADEON_CRTC_DISP_REQ_EN_B;\n\t\t\t\tWREG32(RADEON_CRTC_GEN_CNTL, tmp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nbool r100_gui_idle(struct radeon_device *rdev)\n{\n\tif (RREG32(RADEON_RBBM_STATUS) & RADEON_RBBM_ACTIVE)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n \n \nbool r100_hpd_sense(struct radeon_device *rdev, enum radeon_hpd_id hpd)\n{\n\tbool connected = false;\n\n\tswitch (hpd) {\n\tcase RADEON_HPD_1:\n\t\tif (RREG32(RADEON_FP_GEN_CNTL) & RADEON_FP_DETECT_SENSE)\n\t\t\tconnected = true;\n\t\tbreak;\n\tcase RADEON_HPD_2:\n\t\tif (RREG32(RADEON_FP2_GEN_CNTL) & RADEON_FP2_DETECT_SENSE)\n\t\t\tconnected = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn connected;\n}\n\n \nvoid r100_hpd_set_polarity(struct radeon_device *rdev,\n\t\t\t   enum radeon_hpd_id hpd)\n{\n\tu32 tmp;\n\tbool connected = r100_hpd_sense(rdev, hpd);\n\n\tswitch (hpd) {\n\tcase RADEON_HPD_1:\n\t\ttmp = RREG32(RADEON_FP_GEN_CNTL);\n\t\tif (connected)\n\t\t\ttmp &= ~RADEON_FP_DETECT_INT_POL;\n\t\telse\n\t\t\ttmp |= RADEON_FP_DETECT_INT_POL;\n\t\tWREG32(RADEON_FP_GEN_CNTL, tmp);\n\t\tbreak;\n\tcase RADEON_HPD_2:\n\t\ttmp = RREG32(RADEON_FP2_GEN_CNTL);\n\t\tif (connected)\n\t\t\ttmp &= ~RADEON_FP2_DETECT_INT_POL;\n\t\telse\n\t\t\ttmp |= RADEON_FP2_DETECT_INT_POL;\n\t\tWREG32(RADEON_FP2_GEN_CNTL, tmp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nvoid r100_hpd_init(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned enable = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tenable |= 1 << radeon_connector->hpd.hpd;\n\t\tradeon_hpd_set_polarity(rdev, radeon_connector->hpd.hpd);\n\t}\n\tradeon_irq_kms_enable_hpd(rdev, enable);\n}\n\n \nvoid r100_hpd_fini(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_connector *connector;\n\tunsigned disable = 0;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\n\t\t\tdisable |= 1 << radeon_connector->hpd.hpd;\n\t}\n\tradeon_irq_kms_disable_hpd(rdev, disable);\n}\n\n \nvoid r100_pci_gart_tlb_flush(struct radeon_device *rdev)\n{\n\t \n\t \n}\n\nint r100_pci_gart_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->gart.ptr) {\n\t\tWARN(1, \"R100 PCI GART already initialized\\n\");\n\t\treturn 0;\n\t}\n\t \n\tr = radeon_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trdev->gart.table_size = rdev->gart.num_gpu_pages * 4;\n\trdev->asic->gart.tlb_flush = &r100_pci_gart_tlb_flush;\n\trdev->asic->gart.get_page_entry = &r100_pci_gart_get_page_entry;\n\trdev->asic->gart.set_page = &r100_pci_gart_set_page;\n\treturn radeon_gart_table_ram_alloc(rdev);\n}\n\nint r100_pci_gart_enable(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\n\t \n\ttmp = RREG32(RADEON_AIC_CNTL) | RADEON_DIS_OUT_OF_PCI_GART_ACCESS;\n\tWREG32(RADEON_AIC_CNTL, tmp);\n\t \n\tWREG32(RADEON_AIC_LO_ADDR, rdev->mc.gtt_start);\n\tWREG32(RADEON_AIC_HI_ADDR, rdev->mc.gtt_end);\n\t \n\tWREG32(RADEON_AIC_PT_BASE, rdev->gart.table_addr);\n\ttmp = RREG32(RADEON_AIC_CNTL) | RADEON_PCIGART_TRANSLATE_EN;\n\tWREG32(RADEON_AIC_CNTL, tmp);\n\tr100_pci_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCI GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nvoid r100_pci_gart_disable(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\n\t \n\ttmp = RREG32(RADEON_AIC_CNTL) | RADEON_DIS_OUT_OF_PCI_GART_ACCESS;\n\tWREG32(RADEON_AIC_CNTL, tmp & ~RADEON_PCIGART_TRANSLATE_EN);\n\tWREG32(RADEON_AIC_LO_ADDR, 0);\n\tWREG32(RADEON_AIC_HI_ADDR, 0);\n}\n\nuint64_t r100_pci_gart_get_page_entry(uint64_t addr, uint32_t flags)\n{\n\treturn addr;\n}\n\nvoid r100_pci_gart_set_page(struct radeon_device *rdev, unsigned i,\n\t\t\t    uint64_t entry)\n{\n\tu32 *gtt = rdev->gart.ptr;\n\tgtt[i] = cpu_to_le32(lower_32_bits(entry));\n}\n\nvoid r100_pci_gart_fini(struct radeon_device *rdev)\n{\n\tradeon_gart_fini(rdev);\n\tr100_pci_gart_disable(rdev);\n\tradeon_gart_table_ram_free(rdev);\n}\n\nint r100_irq_set(struct radeon_device *rdev)\n{\n\tuint32_t tmp = 0;\n\n\tif (!rdev->irq.installed) {\n\t\tWARN(1, \"Can't enable IRQ/MSI because no handler is installed\\n\");\n\t\tWREG32(R_000040_GEN_INT_CNTL, 0);\n\t\treturn -EINVAL;\n\t}\n\tif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\n\t\ttmp |= RADEON_SW_INT_ENABLE;\n\t}\n\tif (rdev->irq.crtc_vblank_int[0] ||\n\t    atomic_read(&rdev->irq.pflip[0])) {\n\t\ttmp |= RADEON_CRTC_VBLANK_MASK;\n\t}\n\tif (rdev->irq.crtc_vblank_int[1] ||\n\t    atomic_read(&rdev->irq.pflip[1])) {\n\t\ttmp |= RADEON_CRTC2_VBLANK_MASK;\n\t}\n\tif (rdev->irq.hpd[0]) {\n\t\ttmp |= RADEON_FP_DETECT_MASK;\n\t}\n\tif (rdev->irq.hpd[1]) {\n\t\ttmp |= RADEON_FP2_DETECT_MASK;\n\t}\n\tWREG32(RADEON_GEN_INT_CNTL, tmp);\n\n\t \n\tRREG32(RADEON_GEN_INT_CNTL);\n\n\treturn 0;\n}\n\nvoid r100_irq_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tWREG32(R_000040_GEN_INT_CNTL, 0);\n\t \n\tmdelay(1);\n\ttmp = RREG32(R_000044_GEN_INT_STATUS);\n\tWREG32(R_000044_GEN_INT_STATUS, tmp);\n}\n\nstatic uint32_t r100_irq_ack(struct radeon_device *rdev)\n{\n\tuint32_t irqs = RREG32(RADEON_GEN_INT_STATUS);\n\tuint32_t irq_mask = RADEON_SW_INT_TEST |\n\t\tRADEON_CRTC_VBLANK_STAT | RADEON_CRTC2_VBLANK_STAT |\n\t\tRADEON_FP_DETECT_STAT | RADEON_FP2_DETECT_STAT;\n\n\tif (irqs) {\n\t\tWREG32(RADEON_GEN_INT_STATUS, irqs);\n\t}\n\treturn irqs & irq_mask;\n}\n\nint r100_irq_process(struct radeon_device *rdev)\n{\n\tuint32_t status, msi_rearm;\n\tbool queue_hotplug = false;\n\n\tstatus = r100_irq_ack(rdev);\n\tif (!status) {\n\t\treturn IRQ_NONE;\n\t}\n\tif (rdev->shutdown) {\n\t\treturn IRQ_NONE;\n\t}\n\twhile (status) {\n\t\t \n\t\tif (status & RADEON_SW_INT_TEST) {\n\t\t\tradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\t\t}\n\t\t \n\t\tif (status & RADEON_CRTC_VBLANK_STAT) {\n\t\t\tif (rdev->irq.crtc_vblank_int[0]) {\n\t\t\t\tdrm_handle_vblank(rdev->ddev, 0);\n\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t}\n\t\t\tif (atomic_read(&rdev->irq.pflip[0]))\n\t\t\t\tradeon_crtc_handle_vblank(rdev, 0);\n\t\t}\n\t\tif (status & RADEON_CRTC2_VBLANK_STAT) {\n\t\t\tif (rdev->irq.crtc_vblank_int[1]) {\n\t\t\t\tdrm_handle_vblank(rdev->ddev, 1);\n\t\t\t\trdev->pm.vblank_sync = true;\n\t\t\t\twake_up(&rdev->irq.vblank_queue);\n\t\t\t}\n\t\t\tif (atomic_read(&rdev->irq.pflip[1]))\n\t\t\t\tradeon_crtc_handle_vblank(rdev, 1);\n\t\t}\n\t\tif (status & RADEON_FP_DETECT_STAT) {\n\t\t\tqueue_hotplug = true;\n\t\t\tDRM_DEBUG(\"HPD1\\n\");\n\t\t}\n\t\tif (status & RADEON_FP2_DETECT_STAT) {\n\t\t\tqueue_hotplug = true;\n\t\t\tDRM_DEBUG(\"HPD2\\n\");\n\t\t}\n\t\tstatus = r100_irq_ack(rdev);\n\t}\n\tif (queue_hotplug)\n\t\tschedule_delayed_work(&rdev->hotplug_work, 0);\n\tif (rdev->msi_enabled) {\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_RS400:\n\t\tcase CHIP_RS480:\n\t\t\tmsi_rearm = RREG32(RADEON_AIC_CNTL) & ~RS400_MSI_REARM;\n\t\t\tWREG32(RADEON_AIC_CNTL, msi_rearm);\n\t\t\tWREG32(RADEON_AIC_CNTL, msi_rearm | RS400_MSI_REARM);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWREG32(RADEON_MSI_REARM_EN, RV370_MSI_REARM_EN);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nu32 r100_get_vblank_counter(struct radeon_device *rdev, int crtc)\n{\n\tif (crtc == 0)\n\t\treturn RREG32(RADEON_CRTC_CRNT_FRAME);\n\telse\n\t\treturn RREG32(RADEON_CRTC2_CRNT_FRAME);\n}\n\n \nstatic void r100_ring_hdp_flush(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tradeon_ring_write(ring, PACKET0(RADEON_HOST_PATH_CNTL, 0));\n\tradeon_ring_write(ring, rdev->config.r100.hdp_cntl |\n\t\t\t\tRADEON_HDP_READ_BUFFER_INVALIDATE);\n\tradeon_ring_write(ring, PACKET0(RADEON_HOST_PATH_CNTL, 0));\n\tradeon_ring_write(ring, rdev->config.r100.hdp_cntl);\n}\n\n \nvoid r100_fence_ring_emit(struct radeon_device *rdev,\n\t\t\t  struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\n\t \n\tradeon_ring_write(ring, PACKET0(RADEON_RB3D_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, RADEON_RB3D_DC_FLUSH_ALL);\n\tradeon_ring_write(ring, PACKET0(RADEON_RB3D_ZCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, RADEON_RB3D_ZC_FLUSH_ALL);\n\t \n\tradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\n\tradeon_ring_write(ring, RADEON_WAIT_2D_IDLECLEAN | RADEON_WAIT_3D_IDLECLEAN);\n\tr100_ring_hdp_flush(rdev, ring);\n\t \n\tradeon_ring_write(ring, PACKET0(rdev->fence_drv[fence->ring].scratch_reg, 0));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, PACKET0(RADEON_GEN_INT_STATUS, 0));\n\tradeon_ring_write(ring, RADEON_SW_INT_FIRE);\n}\n\nbool r100_semaphore_ring_emit(struct radeon_device *rdev,\n\t\t\t      struct radeon_ring *ring,\n\t\t\t      struct radeon_semaphore *semaphore,\n\t\t\t      bool emit_wait)\n{\n\t \n\tBUG();\n\treturn false;\n}\n\nstruct radeon_fence *r100_copy_blit(struct radeon_device *rdev,\n\t\t\t\t    uint64_t src_offset,\n\t\t\t\t    uint64_t dst_offset,\n\t\t\t\t    unsigned num_gpu_pages,\n\t\t\t\t    struct dma_resv *resv)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tstruct radeon_fence *fence;\n\tuint32_t cur_pages;\n\tuint32_t stride_bytes = RADEON_GPU_PAGE_SIZE;\n\tuint32_t pitch;\n\tuint32_t stride_pixels;\n\tunsigned ndw;\n\tint num_loops;\n\tint r = 0;\n\n\t \n\tstride_bytes &= 0x3fff;\n\t \n\tpitch = stride_bytes / 64;\n\tstride_pixels = stride_bytes / 4;\n\tnum_loops = DIV_ROUND_UP(num_gpu_pages, 8191);\n\n\t \n\tndw = 64 + (10 * num_loops);\n\tr = radeon_ring_lock(rdev, ring, ndw);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: moving bo (%d) asking for %u dw.\\n\", r, ndw);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\twhile (num_gpu_pages > 0) {\n\t\tcur_pages = num_gpu_pages;\n\t\tif (cur_pages > 8191) {\n\t\t\tcur_pages = 8191;\n\t\t}\n\t\tnum_gpu_pages -= cur_pages;\n\n\t\t \n\t\tradeon_ring_write(ring, PACKET3(PACKET3_BITBLT_MULTI, 8));\n\t\tradeon_ring_write(ring,\n\t\t\t\t  RADEON_GMC_SRC_PITCH_OFFSET_CNTL |\n\t\t\t\t  RADEON_GMC_DST_PITCH_OFFSET_CNTL |\n\t\t\t\t  RADEON_GMC_SRC_CLIPPING |\n\t\t\t\t  RADEON_GMC_DST_CLIPPING |\n\t\t\t\t  RADEON_GMC_BRUSH_NONE |\n\t\t\t\t  (RADEON_COLOR_FORMAT_ARGB8888 << 8) |\n\t\t\t\t  RADEON_GMC_SRC_DATATYPE_COLOR |\n\t\t\t\t  RADEON_ROP3_S |\n\t\t\t\t  RADEON_DP_SRC_SOURCE_MEMORY |\n\t\t\t\t  RADEON_GMC_CLR_CMP_CNTL_DIS |\n\t\t\t\t  RADEON_GMC_WR_MSK_DIS);\n\t\tradeon_ring_write(ring, (pitch << 22) | (src_offset >> 10));\n\t\tradeon_ring_write(ring, (pitch << 22) | (dst_offset >> 10));\n\t\tradeon_ring_write(ring, (0x1fff) | (0x1fff << 16));\n\t\tradeon_ring_write(ring, 0);\n\t\tradeon_ring_write(ring, (0x1fff) | (0x1fff << 16));\n\t\tradeon_ring_write(ring, num_gpu_pages);\n\t\tradeon_ring_write(ring, num_gpu_pages);\n\t\tradeon_ring_write(ring, cur_pages | (stride_pixels << 16));\n\t}\n\tradeon_ring_write(ring, PACKET0(RADEON_DSTCACHE_CTLSTAT, 0));\n\tradeon_ring_write(ring, RADEON_RB2D_DC_FLUSH_ALL);\n\tradeon_ring_write(ring, PACKET0(RADEON_WAIT_UNTIL, 0));\n\tradeon_ring_write(ring,\n\t\t\t  RADEON_WAIT_2D_IDLECLEAN |\n\t\t\t  RADEON_WAIT_HOST_IDLECLEAN |\n\t\t\t  RADEON_WAIT_DMA_GUI_IDLE);\n\tr = radeon_fence_emit(rdev, &fence, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\treturn ERR_PTR(r);\n\t}\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\treturn fence;\n}\n\nstatic int r100_cp_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tu32 tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(R_000E40_RBBM_STATUS);\n\t\tif (!G_000E40_CP_CMDSTRM_BUSY(tmp)) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nvoid r100_ring_start(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tint r;\n\n\tr = radeon_ring_lock(rdev, ring, 2);\n\tif (r) {\n\t\treturn;\n\t}\n\tradeon_ring_write(ring, PACKET0(RADEON_ISYNC_CNTL, 0));\n\tradeon_ring_write(ring,\n\t\t\t  RADEON_ISYNC_ANY2D_IDLE3D |\n\t\t\t  RADEON_ISYNC_ANY3D_IDLE2D |\n\t\t\t  RADEON_ISYNC_WAIT_IDLEGUI |\n\t\t\t  RADEON_ISYNC_CPSCRATCH_IDLEGUI);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n}\n\n\n \nstatic int r100_cp_init_microcode(struct radeon_device *rdev)\n{\n\tconst char *fw_name = NULL;\n\tint err;\n\n\tDRM_DEBUG_KMS(\"\\n\");\n\n\tif ((rdev->family == CHIP_R100) || (rdev->family == CHIP_RV100) ||\n\t    (rdev->family == CHIP_RV200) || (rdev->family == CHIP_RS100) ||\n\t    (rdev->family == CHIP_RS200)) {\n\t\tDRM_INFO(\"Loading R100 Microcode\\n\");\n\t\tfw_name = FIRMWARE_R100;\n\t} else if ((rdev->family == CHIP_R200) ||\n\t\t   (rdev->family == CHIP_RV250) ||\n\t\t   (rdev->family == CHIP_RV280) ||\n\t\t   (rdev->family == CHIP_RS300)) {\n\t\tDRM_INFO(\"Loading R200 Microcode\\n\");\n\t\tfw_name = FIRMWARE_R200;\n\t} else if ((rdev->family == CHIP_R300) ||\n\t\t   (rdev->family == CHIP_R350) ||\n\t\t   (rdev->family == CHIP_RV350) ||\n\t\t   (rdev->family == CHIP_RV380) ||\n\t\t   (rdev->family == CHIP_RS400) ||\n\t\t   (rdev->family == CHIP_RS480)) {\n\t\tDRM_INFO(\"Loading R300 Microcode\\n\");\n\t\tfw_name = FIRMWARE_R300;\n\t} else if ((rdev->family == CHIP_R420) ||\n\t\t   (rdev->family == CHIP_R423) ||\n\t\t   (rdev->family == CHIP_RV410)) {\n\t\tDRM_INFO(\"Loading R400 Microcode\\n\");\n\t\tfw_name = FIRMWARE_R420;\n\t} else if ((rdev->family == CHIP_RS690) ||\n\t\t   (rdev->family == CHIP_RS740)) {\n\t\tDRM_INFO(\"Loading RS690/RS740 Microcode\\n\");\n\t\tfw_name = FIRMWARE_RS690;\n\t} else if (rdev->family == CHIP_RS600) {\n\t\tDRM_INFO(\"Loading RS600 Microcode\\n\");\n\t\tfw_name = FIRMWARE_RS600;\n\t} else if ((rdev->family == CHIP_RV515) ||\n\t\t   (rdev->family == CHIP_R520) ||\n\t\t   (rdev->family == CHIP_RV530) ||\n\t\t   (rdev->family == CHIP_R580) ||\n\t\t   (rdev->family == CHIP_RV560) ||\n\t\t   (rdev->family == CHIP_RV570)) {\n\t\tDRM_INFO(\"Loading R500 Microcode\\n\");\n\t\tfw_name = FIRMWARE_R520;\n\t}\n\n\terr = request_firmware(&rdev->me_fw, fw_name, rdev->dev);\n\tif (err) {\n\t\tpr_err(\"radeon_cp: Failed to load firmware \\\"%s\\\"\\n\", fw_name);\n\t} else if (rdev->me_fw->size % 8) {\n\t\tpr_err(\"radeon_cp: Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t       rdev->me_fw->size, fw_name);\n\t\terr = -EINVAL;\n\t\trelease_firmware(rdev->me_fw);\n\t\trdev->me_fw = NULL;\n\t}\n\treturn err;\n}\n\nu32 r100_gfx_get_rptr(struct radeon_device *rdev,\n\t\t      struct radeon_ring *ring)\n{\n\tu32 rptr;\n\n\tif (rdev->wb.enabled)\n\t\trptr = le32_to_cpu(rdev->wb.wb[ring->rptr_offs/4]);\n\telse\n\t\trptr = RREG32(RADEON_CP_RB_RPTR);\n\n\treturn rptr;\n}\n\nu32 r100_gfx_get_wptr(struct radeon_device *rdev,\n\t\t      struct radeon_ring *ring)\n{\n\treturn RREG32(RADEON_CP_RB_WPTR);\n}\n\nvoid r100_gfx_set_wptr(struct radeon_device *rdev,\n\t\t       struct radeon_ring *ring)\n{\n\tWREG32(RADEON_CP_RB_WPTR, ring->wptr);\n\t(void)RREG32(RADEON_CP_RB_WPTR);\n}\n\nstatic void r100_cp_load_microcode(struct radeon_device *rdev)\n{\n\tconst __be32 *fw_data;\n\tint i, size;\n\n\tif (r100_gui_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait GUI idle while programming pipes. Bad things might happen.\\n\");\n\t}\n\n\tif (rdev->me_fw) {\n\t\tsize = rdev->me_fw->size / 4;\n\t\tfw_data = (const __be32 *)&rdev->me_fw->data[0];\n\t\tWREG32(RADEON_CP_ME_RAM_ADDR, 0);\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tWREG32(RADEON_CP_ME_RAM_DATAH,\n\t\t\t       be32_to_cpup(&fw_data[i]));\n\t\t\tWREG32(RADEON_CP_ME_RAM_DATAL,\n\t\t\t       be32_to_cpup(&fw_data[i + 1]));\n\t\t}\n\t}\n}\n\nint r100_cp_init(struct radeon_device *rdev, unsigned ring_size)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tunsigned rb_bufsz;\n\tunsigned rb_blksz;\n\tunsigned max_fetch;\n\tunsigned pre_write_timer;\n\tunsigned pre_write_limit;\n\tunsigned indirect2_start;\n\tunsigned indirect1_start;\n\tuint32_t tmp;\n\tint r;\n\n\tr100_debugfs_cp_init(rdev);\n\tif (!rdev->me_fw) {\n\t\tr = r100_cp_init_microcode(rdev);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to load firmware!\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\t \n\trb_bufsz = order_base_2(ring_size / 8);\n\tring_size = (1 << (rb_bufsz + 1)) * 4;\n\tr100_cp_load_microcode(rdev);\n\tr = radeon_ring_init(rdev, ring, ring_size, RADEON_WB_CP_RPTR_OFFSET,\n\t\t\t     RADEON_CP_PACKET2);\n\tif (r) {\n\t\treturn r;\n\t}\n\t \n\trb_blksz = 9;\n\t \n\tmax_fetch = 1;\n\tring->align_mask = 16 - 1;\n\t \n\tpre_write_timer = 64;\n\t \n\tpre_write_limit = 0;\n\t \n\tindirect2_start = 80;\n\tindirect1_start = 16;\n\t \n\tWREG32(0x718, pre_write_timer | (pre_write_limit << 28));\n\ttmp = (REG_SET(RADEON_RB_BUFSZ, rb_bufsz) |\n\t       REG_SET(RADEON_RB_BLKSZ, rb_blksz) |\n\t       REG_SET(RADEON_MAX_FETCH, max_fetch));\n#ifdef __BIG_ENDIAN\n\ttmp |= RADEON_BUF_SWAP_32BIT;\n#endif\n\tWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_NO_UPDATE);\n\n\t \n\tDRM_INFO(\"radeon: ring at 0x%016lX\\n\", (unsigned long)ring->gpu_addr);\n\tWREG32(RADEON_CP_RB_BASE, ring->gpu_addr);\n\t \n\tWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_RPTR_WR_ENA | RADEON_RB_NO_UPDATE);\n\tWREG32(RADEON_CP_RB_RPTR_WR, 0);\n\tring->wptr = 0;\n\tWREG32(RADEON_CP_RB_WPTR, ring->wptr);\n\n\t \n\tWREG32(R_00070C_CP_RB_RPTR_ADDR,\n\t\tS_00070C_RB_RPTR_ADDR((rdev->wb.gpu_addr + RADEON_WB_CP_RPTR_OFFSET) >> 2));\n\tWREG32(R_000774_SCRATCH_ADDR, rdev->wb.gpu_addr + RADEON_WB_SCRATCH_OFFSET);\n\n\tif (rdev->wb.enabled)\n\t\tWREG32(R_000770_SCRATCH_UMSK, 0xff);\n\telse {\n\t\ttmp |= RADEON_RB_NO_UPDATE;\n\t\tWREG32(R_000770_SCRATCH_UMSK, 0);\n\t}\n\n\tWREG32(RADEON_CP_RB_CNTL, tmp);\n\tudelay(10);\n\t \n\tWREG32(RADEON_CP_CSQ_MODE,\n\t       REG_SET(RADEON_INDIRECT2_START, indirect2_start) |\n\t       REG_SET(RADEON_INDIRECT1_START, indirect1_start));\n\tWREG32(RADEON_CP_RB_WPTR_DELAY, 0);\n\tWREG32(RADEON_CP_CSQ_MODE, 0x00004D4D);\n\tWREG32(RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIBM_INDBM);\n\n\t \n\tpci_set_master(rdev->pdev);\n\n\tradeon_ring_start(rdev, RADEON_RING_TYPE_GFX_INDEX, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX]);\n\tr = radeon_ring_test(rdev, RADEON_RING_TYPE_GFX_INDEX, ring);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp isn't working (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tring->ready = true;\n\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\n\n\tif (!ring->rptr_save_reg  \n\t    && radeon_ring_supports_scratch_reg(rdev, ring)) {\n\t\tr = radeon_scratch_get(rdev, &ring->rptr_save_reg);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"failed to get scratch reg for rptr save (%d).\\n\", r);\n\t\t\tring->rptr_save_reg = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid r100_cp_fini(struct radeon_device *rdev)\n{\n\tif (r100_cp_wait_for_idle(rdev)) {\n\t\tDRM_ERROR(\"Wait for CP idle timeout, shutting down CP.\\n\");\n\t}\n\t \n\tr100_cp_disable(rdev);\n\tradeon_scratch_free(rdev, rdev->ring[RADEON_RING_TYPE_GFX_INDEX].rptr_save_reg);\n\tradeon_ring_fini(rdev, &rdev->ring[RADEON_RING_TYPE_GFX_INDEX]);\n\tDRM_INFO(\"radeon: cp finalized\\n\");\n}\n\nvoid r100_cp_disable(struct radeon_device *rdev)\n{\n\t \n\tradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\tWREG32(RADEON_CP_CSQ_MODE, 0);\n\tWREG32(RADEON_CP_CSQ_CNTL, 0);\n\tWREG32(R_000770_SCRATCH_UMSK, 0);\n\tif (r100_gui_wait_for_idle(rdev)) {\n\t\tpr_warn(\"Failed to wait GUI idle while programming pipes. Bad things might happen.\\n\");\n\t}\n}\n\n \nint r100_reloc_pitch_offset(struct radeon_cs_parser *p,\n\t\t\t    struct radeon_cs_packet *pkt,\n\t\t\t    unsigned idx,\n\t\t\t    unsigned reg)\n{\n\tint r;\n\tu32 tile_flags = 0;\n\tu32 tmp;\n\tstruct radeon_bo_list *reloc;\n\tu32 value;\n\n\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\tif (r) {\n\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t  idx, reg);\n\t\tradeon_cs_dump_packet(p, pkt);\n\t\treturn r;\n\t}\n\n\tvalue = radeon_get_ib_value(p, idx);\n\ttmp = value & 0x003fffff;\n\ttmp += (((u32)reloc->gpu_offset) >> 10);\n\n\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\ttile_flags |= RADEON_DST_TILE_MACRO;\n\t\tif (reloc->tiling_flags & RADEON_TILING_MICRO) {\n\t\t\tif (reg == RADEON_SRC_PITCH_OFFSET) {\n\t\t\t\tDRM_ERROR(\"Cannot src blit from microtiled surface\\n\");\n\t\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ttile_flags |= RADEON_DST_TILE_MICRO;\n\t\t}\n\n\t\ttmp |= tile_flags;\n\t\tp->ib.ptr[idx] = (value & 0x3fc00000) | tmp;\n\t} else\n\t\tp->ib.ptr[idx] = (value & 0xffc00000) | tmp;\n\treturn 0;\n}\n\nint r100_packet3_load_vbpntr(struct radeon_cs_parser *p,\n\t\t\t     struct radeon_cs_packet *pkt,\n\t\t\t     int idx)\n{\n\tunsigned c, i;\n\tstruct radeon_bo_list *reloc;\n\tstruct r100_cs_track *track;\n\tint r = 0;\n\tvolatile uint32_t *ib;\n\tu32 idx_value;\n\n\tib = p->ib.ptr;\n\ttrack = (struct r100_cs_track *)p->track;\n\tc = radeon_get_ib_value(p, idx++) & 0x1F;\n\tif (c > 16) {\n\t    DRM_ERROR(\"Only 16 vertex buffers are allowed %d\\n\",\n\t\t      pkt->opcode);\n\t    radeon_cs_dump_packet(p, pkt);\n\t    return -EINVAL;\n\t}\n\ttrack->num_arrays = c;\n\tfor (i = 0; i < (c - 1); i+=2, idx+=3) {\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for packet3 %d\\n\",\n\t\t\t\t  pkt->opcode);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tidx_value = radeon_get_ib_value(p, idx);\n\t\tib[idx+1] = radeon_get_ib_value(p, idx + 1) + ((u32)reloc->gpu_offset);\n\n\t\ttrack->arrays[i + 0].esize = idx_value >> 8;\n\t\ttrack->arrays[i + 0].robj = reloc->robj;\n\t\ttrack->arrays[i + 0].esize &= 0x7F;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for packet3 %d\\n\",\n\t\t\t\t  pkt->opcode);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tib[idx+2] = radeon_get_ib_value(p, idx + 2) + ((u32)reloc->gpu_offset);\n\t\ttrack->arrays[i + 1].robj = reloc->robj;\n\t\ttrack->arrays[i + 1].esize = idx_value >> 24;\n\t\ttrack->arrays[i + 1].esize &= 0x7F;\n\t}\n\tif (c & 1) {\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for packet3 %d\\n\",\n\t\t\t\t\t  pkt->opcode);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tidx_value = radeon_get_ib_value(p, idx);\n\t\tib[idx+1] = radeon_get_ib_value(p, idx + 1) + ((u32)reloc->gpu_offset);\n\t\ttrack->arrays[i + 0].robj = reloc->robj;\n\t\ttrack->arrays[i + 0].esize = idx_value >> 8;\n\t\ttrack->arrays[i + 0].esize &= 0x7F;\n\t}\n\treturn r;\n}\n\nint r100_cs_parse_packet0(struct radeon_cs_parser *p,\n\t\t\t  struct radeon_cs_packet *pkt,\n\t\t\t  const unsigned *auth, unsigned n,\n\t\t\t  radeon_packet0_check_t check)\n{\n\tunsigned reg;\n\tunsigned i, j, m;\n\tunsigned idx;\n\tint r;\n\n\tidx = pkt->idx + 1;\n\treg = pkt->reg;\n\t \n\tif (pkt->one_reg_wr) {\n\t\tif ((reg >> 7) > n) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (((reg + (pkt->count << 2)) >> 7) > n) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tfor (i = 0; i <= pkt->count; i++, idx++) {\n\t\tj = (reg >> 7);\n\t\tm = 1 << ((reg >> 2) & 31);\n\t\tif (auth[j] & m) {\n\t\t\tr = check(p, pkt, idx, reg);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\tif (pkt->one_reg_wr) {\n\t\t\tif (!(auth[j] & m)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\treg += 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nint r100_cs_packet_parse_vline(struct radeon_cs_parser *p)\n{\n\tstruct drm_crtc *crtc;\n\tstruct radeon_crtc *radeon_crtc;\n\tstruct radeon_cs_packet p3reloc, waitreloc;\n\tint crtc_id;\n\tint r;\n\tuint32_t header, h_idx, reg;\n\tvolatile uint32_t *ib;\n\n\tib = p->ib.ptr;\n\n\t \n\tr = radeon_cs_packet_parse(p, &waitreloc, p->idx);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (waitreloc.reg != RADEON_WAIT_UNTIL ||\n\t    waitreloc.count != 0) {\n\t\tDRM_ERROR(\"vline wait had illegal wait until segment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (radeon_get_ib_value(p, waitreloc.idx + 1) != RADEON_WAIT_CRTC_VLINE) {\n\t\tDRM_ERROR(\"vline wait had illegal wait until\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tr = radeon_cs_packet_parse(p, &p3reloc, p->idx + waitreloc.count + 2);\n\tif (r)\n\t\treturn r;\n\n\th_idx = p->idx - 2;\n\tp->idx += waitreloc.count + 2;\n\tp->idx += p3reloc.count + 2;\n\n\theader = radeon_get_ib_value(p, h_idx);\n\tcrtc_id = radeon_get_ib_value(p, h_idx + 5);\n\treg = R100_CP_PACKET0_GET_REG(header);\n\tcrtc = drm_crtc_find(p->rdev->ddev, p->filp, crtc_id);\n\tif (!crtc) {\n\t\tDRM_ERROR(\"cannot find crtc %d\\n\", crtc_id);\n\t\treturn -ENOENT;\n\t}\n\tradeon_crtc = to_radeon_crtc(crtc);\n\tcrtc_id = radeon_crtc->crtc_id;\n\n\tif (!crtc->enabled) {\n\t\t \n\t\tib[h_idx + 2] = PACKET2(0);\n\t\tib[h_idx + 3] = PACKET2(0);\n\t} else if (crtc_id == 1) {\n\t\tswitch (reg) {\n\t\tcase AVIVO_D1MODE_VLINE_START_END:\n\t\t\theader &= ~R300_CP_PACKET0_REG_MASK;\n\t\t\theader |= AVIVO_D2MODE_VLINE_START_END >> 2;\n\t\t\tbreak;\n\t\tcase RADEON_CRTC_GUI_TRIG_VLINE:\n\t\t\theader &= ~R300_CP_PACKET0_REG_MASK;\n\t\t\theader |= RADEON_CRTC2_GUI_TRIG_VLINE >> 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown crtc reloc\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tib[h_idx] = header;\n\t\tib[h_idx + 3] |= RADEON_ENG_DISPLAY_SELECT_CRTC1;\n\t}\n\n\treturn 0;\n}\n\nstatic int r100_get_vtx_size(uint32_t vtx_fmt)\n{\n\tint vtx_size;\n\tvtx_size = 2;\n\t \n\tif (vtx_fmt & RADEON_SE_VTX_FMT_W0)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_FPCOLOR)\n\t\tvtx_size += 3;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_FPALPHA)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_PKCOLOR)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_FPSPEC)\n\t\tvtx_size += 3;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_FPFOG)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_PKSPEC)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_ST0)\n\t\tvtx_size += 2;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_ST1)\n\t\tvtx_size += 2;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_Q1)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_ST2)\n\t\tvtx_size += 2;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_Q2)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_ST3)\n\t\tvtx_size += 2;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_Q3)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_Q0)\n\t\tvtx_size++;\n\t \n\tif (vtx_fmt & (0x7 << 15))\n\t\tvtx_size += (vtx_fmt >> 15) & 0x7;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_N0)\n\t\tvtx_size += 3;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_XY1)\n\t\tvtx_size += 2;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_Z1)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_W1)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_N1)\n\t\tvtx_size++;\n\tif (vtx_fmt & RADEON_SE_VTX_FMT_Z)\n\t\tvtx_size++;\n\treturn vtx_size;\n}\n\nstatic int r100_packet0_check(struct radeon_cs_parser *p,\n\t\t\t      struct radeon_cs_packet *pkt,\n\t\t\t      unsigned idx, unsigned reg)\n{\n\tstruct radeon_bo_list *reloc;\n\tstruct r100_cs_track *track;\n\tvolatile uint32_t *ib;\n\tuint32_t tmp;\n\tint r;\n\tint i, face;\n\tu32 tile_flags = 0;\n\tu32 idx_value;\n\n\tib = p->ib.ptr;\n\ttrack = (struct r100_cs_track *)p->track;\n\n\tidx_value = radeon_get_ib_value(p, idx);\n\n\tswitch (reg) {\n\tcase RADEON_CRTC_GUI_TRIG_VLINE:\n\t\tr = r100_cs_packet_parse_vline(p);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\t\t \n\tcase RADEON_DST_PITCH_OFFSET:\n\tcase RADEON_SRC_PITCH_OFFSET:\n\t\tr = r100_reloc_pitch_offset(p, pkt, idx, reg);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tcase RADEON_RB3D_DEPTHOFFSET:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->zb.robj = reloc->robj;\n\t\ttrack->zb.offset = idx_value;\n\t\ttrack->zb_dirty = true;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase RADEON_RB3D_COLOROFFSET:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->cb[0].robj = reloc->robj;\n\t\ttrack->cb[0].offset = idx_value;\n\t\ttrack->cb_dirty = true;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase RADEON_PP_TXOFFSET_0:\n\tcase RADEON_PP_TXOFFSET_1:\n\tcase RADEON_PP_TXOFFSET_2:\n\t\ti = (reg - RADEON_PP_TXOFFSET_0) / 24;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\t\ttile_flags |= RADEON_TXO_MACRO_TILE;\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MICRO)\n\t\t\t\ttile_flags |= RADEON_TXO_MICRO_TILE_X2;\n\n\t\t\ttmp = idx_value & ~(0x7 << 2);\n\t\t\ttmp |= tile_flags;\n\t\t\tib[idx] = tmp + ((u32)reloc->gpu_offset);\n\t\t} else\n\t\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\ttrack->textures[i].robj = reloc->robj;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_CUBIC_OFFSET_T0_0:\n\tcase RADEON_PP_CUBIC_OFFSET_T0_1:\n\tcase RADEON_PP_CUBIC_OFFSET_T0_2:\n\tcase RADEON_PP_CUBIC_OFFSET_T0_3:\n\tcase RADEON_PP_CUBIC_OFFSET_T0_4:\n\t\ti = (reg - RADEON_PP_CUBIC_OFFSET_T0_0) / 4;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->textures[0].cube_info[i].offset = idx_value;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\ttrack->textures[0].cube_info[i].robj = reloc->robj;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_CUBIC_OFFSET_T1_0:\n\tcase RADEON_PP_CUBIC_OFFSET_T1_1:\n\tcase RADEON_PP_CUBIC_OFFSET_T1_2:\n\tcase RADEON_PP_CUBIC_OFFSET_T1_3:\n\tcase RADEON_PP_CUBIC_OFFSET_T1_4:\n\t\ti = (reg - RADEON_PP_CUBIC_OFFSET_T1_0) / 4;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->textures[1].cube_info[i].offset = idx_value;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\ttrack->textures[1].cube_info[i].robj = reloc->robj;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_CUBIC_OFFSET_T2_0:\n\tcase RADEON_PP_CUBIC_OFFSET_T2_1:\n\tcase RADEON_PP_CUBIC_OFFSET_T2_2:\n\tcase RADEON_PP_CUBIC_OFFSET_T2_3:\n\tcase RADEON_PP_CUBIC_OFFSET_T2_4:\n\t\ti = (reg - RADEON_PP_CUBIC_OFFSET_T2_0) / 4;\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\ttrack->textures[2].cube_info[i].offset = idx_value;\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\ttrack->textures[2].cube_info[i].robj = reloc->robj;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_RE_WIDTH_HEIGHT:\n\t\ttrack->maxy = ((idx_value >> 16) & 0x7FF);\n\t\ttrack->cb_dirty = true;\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase RADEON_RB3D_COLORPITCH:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MACRO)\n\t\t\t\ttile_flags |= RADEON_COLOR_TILE_ENABLE;\n\t\t\tif (reloc->tiling_flags & RADEON_TILING_MICRO)\n\t\t\t\ttile_flags |= RADEON_COLOR_MICROTILE_ENABLE;\n\n\t\t\ttmp = idx_value & ~(0x7 << 16);\n\t\t\ttmp |= tile_flags;\n\t\t\tib[idx] = tmp;\n\t\t} else\n\t\t\tib[idx] = idx_value;\n\n\t\ttrack->cb[0].pitch = idx_value & RADEON_COLORPITCH_MASK;\n\t\ttrack->cb_dirty = true;\n\t\tbreak;\n\tcase RADEON_RB3D_DEPTHPITCH:\n\t\ttrack->zb.pitch = idx_value & RADEON_DEPTHPITCH_MASK;\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase RADEON_RB3D_CNTL:\n\t\tswitch ((idx_value >> RADEON_RB3D_COLOR_FORMAT_SHIFT) & 0x1f) {\n\t\tcase 7:\n\t\tcase 8:\n\t\tcase 9:\n\t\tcase 11:\n\t\tcase 12:\n\t\t\ttrack->cb[0].cpp = 1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 15:\n\t\t\ttrack->cb[0].cpp = 2;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ttrack->cb[0].cpp = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Invalid color buffer format (%d) !\\n\",\n\t\t\t\t  ((idx_value >> RADEON_RB3D_COLOR_FORMAT_SHIFT) & 0x1f));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->z_enabled = !!(idx_value & RADEON_Z_ENABLE);\n\t\ttrack->cb_dirty = true;\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase RADEON_RB3D_ZSTENCILCNTL:\n\t\tswitch (idx_value & 0xf) {\n\t\tcase 0:\n\t\t\ttrack->zb.cpp = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 9:\n\t\tcase 11:\n\t\t\ttrack->zb.cpp = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttrack->zb_dirty = true;\n\t\tbreak;\n\tcase RADEON_RB3D_ZPASS_ADDR:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n\t\t\t\t  idx, reg);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tib[idx] = idx_value + ((u32)reloc->gpu_offset);\n\t\tbreak;\n\tcase RADEON_PP_CNTL:\n\t\t{\n\t\t\tuint32_t temp = idx_value >> 4;\n\t\t\tfor (i = 0; i < track->num_texture; i++)\n\t\t\t\ttrack->textures[i].enabled = !!(temp & (1 << i));\n\t\t\ttrack->tex_dirty = true;\n\t\t}\n\t\tbreak;\n\tcase RADEON_SE_VF_CNTL:\n\t\ttrack->vap_vf_cntl = idx_value;\n\t\tbreak;\n\tcase RADEON_SE_VTX_FMT:\n\t\ttrack->vtx_size = r100_get_vtx_size(idx_value);\n\t\tbreak;\n\tcase RADEON_PP_TEX_SIZE_0:\n\tcase RADEON_PP_TEX_SIZE_1:\n\tcase RADEON_PP_TEX_SIZE_2:\n\t\ti = (reg - RADEON_PP_TEX_SIZE_0) / 8;\n\t\ttrack->textures[i].width = (idx_value & RADEON_TEX_USIZE_MASK) + 1;\n\t\ttrack->textures[i].height = ((idx_value & RADEON_TEX_VSIZE_MASK) >> RADEON_TEX_VSIZE_SHIFT) + 1;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_TEX_PITCH_0:\n\tcase RADEON_PP_TEX_PITCH_1:\n\tcase RADEON_PP_TEX_PITCH_2:\n\t\ti = (reg - RADEON_PP_TEX_PITCH_0) / 8;\n\t\ttrack->textures[i].pitch = idx_value + 32;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_TXFILTER_0:\n\tcase RADEON_PP_TXFILTER_1:\n\tcase RADEON_PP_TXFILTER_2:\n\t\ti = (reg - RADEON_PP_TXFILTER_0) / 24;\n\t\ttrack->textures[i].num_levels = ((idx_value & RADEON_MAX_MIP_LEVEL_MASK)\n\t\t\t\t\t\t >> RADEON_MAX_MIP_LEVEL_SHIFT);\n\t\ttmp = (idx_value >> 23) & 0x7;\n\t\tif (tmp == 2 || tmp == 6)\n\t\t\ttrack->textures[i].roundup_w = false;\n\t\ttmp = (idx_value >> 27) & 0x7;\n\t\tif (tmp == 2 || tmp == 6)\n\t\t\ttrack->textures[i].roundup_h = false;\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_TXFORMAT_0:\n\tcase RADEON_PP_TXFORMAT_1:\n\tcase RADEON_PP_TXFORMAT_2:\n\t\ti = (reg - RADEON_PP_TXFORMAT_0) / 24;\n\t\tif (idx_value & RADEON_TXFORMAT_NON_POWER2) {\n\t\t\ttrack->textures[i].use_pitch = true;\n\t\t} else {\n\t\t\ttrack->textures[i].use_pitch = false;\n\t\t\ttrack->textures[i].width = 1 << ((idx_value & RADEON_TXFORMAT_WIDTH_MASK) >> RADEON_TXFORMAT_WIDTH_SHIFT);\n\t\t\ttrack->textures[i].height = 1 << ((idx_value & RADEON_TXFORMAT_HEIGHT_MASK) >> RADEON_TXFORMAT_HEIGHT_SHIFT);\n\t\t}\n\t\tif (idx_value & RADEON_TXFORMAT_CUBIC_MAP_ENABLE)\n\t\t\ttrack->textures[i].tex_coord_type = 2;\n\t\tswitch ((idx_value & RADEON_TXFORMAT_FORMAT_MASK)) {\n\t\tcase RADEON_TXFORMAT_I8:\n\t\tcase RADEON_TXFORMAT_RGB332:\n\t\tcase RADEON_TXFORMAT_Y8:\n\t\t\ttrack->textures[i].cpp = 1;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase RADEON_TXFORMAT_AI88:\n\t\tcase RADEON_TXFORMAT_ARGB1555:\n\t\tcase RADEON_TXFORMAT_RGB565:\n\t\tcase RADEON_TXFORMAT_ARGB4444:\n\t\tcase RADEON_TXFORMAT_VYUY422:\n\t\tcase RADEON_TXFORMAT_YVYU422:\n\t\tcase RADEON_TXFORMAT_SHADOW16:\n\t\tcase RADEON_TXFORMAT_LDUDV655:\n\t\tcase RADEON_TXFORMAT_DUDV88:\n\t\t\ttrack->textures[i].cpp = 2;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase RADEON_TXFORMAT_ARGB8888:\n\t\tcase RADEON_TXFORMAT_RGBA8888:\n\t\tcase RADEON_TXFORMAT_SHADOW32:\n\t\tcase RADEON_TXFORMAT_LDUDUV8888:\n\t\t\ttrack->textures[i].cpp = 4;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\t\tbreak;\n\t\tcase RADEON_TXFORMAT_DXT1:\n\t\t\ttrack->textures[i].cpp = 1;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_DXT1;\n\t\t\tbreak;\n\t\tcase RADEON_TXFORMAT_DXT23:\n\t\tcase RADEON_TXFORMAT_DXT45:\n\t\t\ttrack->textures[i].cpp = 1;\n\t\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_DXT35;\n\t\t\tbreak;\n\t\t}\n\t\ttrack->textures[i].cube_info[4].width = 1 << ((idx_value >> 16) & 0xf);\n\t\ttrack->textures[i].cube_info[4].height = 1 << ((idx_value >> 20) & 0xf);\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tcase RADEON_PP_CUBIC_FACES_0:\n\tcase RADEON_PP_CUBIC_FACES_1:\n\tcase RADEON_PP_CUBIC_FACES_2:\n\t\ttmp = idx_value;\n\t\ti = (reg - RADEON_PP_CUBIC_FACES_0) / 4;\n\t\tfor (face = 0; face < 4; face++) {\n\t\t\ttrack->textures[i].cube_info[face].width = 1 << ((tmp >> (face * 8)) & 0xf);\n\t\t\ttrack->textures[i].cube_info[face].height = 1 << ((tmp >> ((face * 8) + 4)) & 0xf);\n\t\t}\n\t\ttrack->tex_dirty = true;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Forbidden register 0x%04X in cs at %d\\n\", reg, idx);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint r100_cs_track_check_pkt3_indx_buffer(struct radeon_cs_parser *p,\n\t\t\t\t\t struct radeon_cs_packet *pkt,\n\t\t\t\t\t struct radeon_bo *robj)\n{\n\tunsigned idx;\n\tu32 value;\n\tidx = pkt->idx + 1;\n\tvalue = radeon_get_ib_value(p, idx + 2);\n\tif ((value + 1) > radeon_bo_size(robj)) {\n\t\tDRM_ERROR(\"[drm] Buffer too small for PACKET3 INDX_BUFFER \"\n\t\t\t  \"(need %u have %lu) !\\n\",\n\t\t\t  value + 1,\n\t\t\t  radeon_bo_size(robj));\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int r100_packet3_check(struct radeon_cs_parser *p,\n\t\t\t      struct radeon_cs_packet *pkt)\n{\n\tstruct radeon_bo_list *reloc;\n\tstruct r100_cs_track *track;\n\tunsigned idx;\n\tvolatile uint32_t *ib;\n\tint r;\n\n\tib = p->ib.ptr;\n\tidx = pkt->idx + 1;\n\ttrack = (struct r100_cs_track *)p->track;\n\tswitch (pkt->opcode) {\n\tcase PACKET3_3D_LOAD_VBPNTR:\n\t\tr = r100_packet3_load_vbpntr(p, pkt, idx);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tcase PACKET3_INDX_BUFFER:\n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for packet3 %d\\n\", pkt->opcode);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tib[idx+1] = radeon_get_ib_value(p, idx+1) + ((u32)reloc->gpu_offset);\n\t\tr = r100_cs_track_check_pkt3_indx_buffer(p, pkt, reloc->robj);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tbreak;\n\tcase 0x23:\n\t\t \n\t\tr = radeon_cs_packet_next_reloc(p, &reloc, 0);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"No reloc for packet3 %d\\n\", pkt->opcode);\n\t\t\tradeon_cs_dump_packet(p, pkt);\n\t\t\treturn r;\n\t\t}\n\t\tib[idx] = radeon_get_ib_value(p, idx) + ((u32)reloc->gpu_offset);\n\t\ttrack->num_arrays = 1;\n\t\ttrack->vtx_size = r100_get_vtx_size(radeon_get_ib_value(p, idx + 2));\n\n\t\ttrack->arrays[0].robj = reloc->robj;\n\t\ttrack->arrays[0].esize = track->vtx_size;\n\n\t\ttrack->max_indx = radeon_get_ib_value(p, idx+1);\n\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx+3);\n\t\ttrack->immd_dwords = pkt->count - 1;\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\tcase PACKET3_3D_DRAW_IMMD:\n\t\tif (((radeon_get_ib_value(p, idx + 1) >> 4) & 0x3) != 3) {\n\t\t\tDRM_ERROR(\"PRIM_WALK must be 3 for IMMD draw\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->vtx_size = r100_get_vtx_size(radeon_get_ib_value(p, idx + 0));\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\n\t\ttrack->immd_dwords = pkt->count - 1;\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\t\t \n\tcase PACKET3_3D_DRAW_IMMD_2:\n\t\tif (((radeon_get_ib_value(p, idx) >> 4) & 0x3) != 3) {\n\t\t\tDRM_ERROR(\"PRIM_WALK must be 3 for IMMD draw\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\n\t\ttrack->immd_dwords = pkt->count;\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\t\t \n\tcase PACKET3_3D_DRAW_VBUF_2:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\t\t \n\tcase PACKET3_3D_DRAW_INDX_2:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\t\t \n\tcase PACKET3_3D_DRAW_VBUF:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\t\t \n\tcase PACKET3_3D_DRAW_INDX:\n\t\ttrack->vap_vf_cntl = radeon_get_ib_value(p, idx + 1);\n\t\tr = r100_cs_track_check(p->rdev, track);\n\t\tif (r)\n\t\t\treturn r;\n\t\tbreak;\n\t\t \n\tcase PACKET3_3D_CLEAR_HIZ:\n\tcase PACKET3_3D_CLEAR_ZMASK:\n\t\tif (p->rdev->hyperz_filp != p->filp)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase PACKET3_NOP:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Packet3 opcode %x not supported\\n\", pkt->opcode);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint r100_cs_parse(struct radeon_cs_parser *p)\n{\n\tstruct radeon_cs_packet pkt;\n\tstruct r100_cs_track *track;\n\tint r;\n\n\ttrack = kzalloc(sizeof(*track), GFP_KERNEL);\n\tif (!track)\n\t\treturn -ENOMEM;\n\tr100_cs_track_clear(p->rdev, track);\n\tp->track = track;\n\tdo {\n\t\tr = radeon_cs_packet_parse(p, &pkt, p->idx);\n\t\tif (r) {\n\t\t\treturn r;\n\t\t}\n\t\tp->idx += pkt.count + 2;\n\t\tswitch (pkt.type) {\n\t\tcase RADEON_PACKET_TYPE0:\n\t\t\tif (p->rdev->family >= CHIP_R200)\n\t\t\t\tr = r100_cs_parse_packet0(p, &pkt,\n\t\t\t\t\tp->rdev->config.r100.reg_safe_bm,\n\t\t\t\t\tp->rdev->config.r100.reg_safe_bm_size,\n\t\t\t\t\t&r200_packet0_check);\n\t\t\telse\n\t\t\t\tr = r100_cs_parse_packet0(p, &pkt,\n\t\t\t\t\tp->rdev->config.r100.reg_safe_bm,\n\t\t\t\t\tp->rdev->config.r100.reg_safe_bm_size,\n\t\t\t\t\t&r100_packet0_check);\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE2:\n\t\t\tbreak;\n\t\tcase RADEON_PACKET_TYPE3:\n\t\t\tr = r100_packet3_check(p, &pkt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown packet type %d !\\n\",\n\t\t\t\t  pkt.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (r)\n\t\t\treturn r;\n\t} while (p->idx < p->chunk_ib->length_dw);\n\treturn 0;\n}\n\nstatic void r100_cs_track_texture_print(struct r100_cs_track_texture *t)\n{\n\tDRM_ERROR(\"pitch                      %d\\n\", t->pitch);\n\tDRM_ERROR(\"use_pitch                  %d\\n\", t->use_pitch);\n\tDRM_ERROR(\"width                      %d\\n\", t->width);\n\tDRM_ERROR(\"width_11                   %d\\n\", t->width_11);\n\tDRM_ERROR(\"height                     %d\\n\", t->height);\n\tDRM_ERROR(\"height_11                  %d\\n\", t->height_11);\n\tDRM_ERROR(\"num levels                 %d\\n\", t->num_levels);\n\tDRM_ERROR(\"depth                      %d\\n\", t->txdepth);\n\tDRM_ERROR(\"bpp                        %d\\n\", t->cpp);\n\tDRM_ERROR(\"coordinate type            %d\\n\", t->tex_coord_type);\n\tDRM_ERROR(\"width round to power of 2  %d\\n\", t->roundup_w);\n\tDRM_ERROR(\"height round to power of 2 %d\\n\", t->roundup_h);\n\tDRM_ERROR(\"compress format            %d\\n\", t->compress_format);\n}\n\nstatic int r100_track_compress_size(int compress_format, int w, int h)\n{\n\tint block_width, block_height, block_bytes;\n\tint wblocks, hblocks;\n\tint min_wblocks;\n\tint sz;\n\n\tblock_width = 4;\n\tblock_height = 4;\n\n\tswitch (compress_format) {\n\tcase R100_TRACK_COMP_DXT1:\n\t\tblock_bytes = 8;\n\t\tmin_wblocks = 4;\n\t\tbreak;\n\tdefault:\n\tcase R100_TRACK_COMP_DXT35:\n\t\tblock_bytes = 16;\n\t\tmin_wblocks = 2;\n\t\tbreak;\n\t}\n\n\thblocks = (h + block_height - 1) / block_height;\n\twblocks = (w + block_width - 1) / block_width;\n\tif (wblocks < min_wblocks)\n\t\twblocks = min_wblocks;\n\tsz = wblocks * hblocks * block_bytes;\n\treturn sz;\n}\n\nstatic int r100_cs_track_cube(struct radeon_device *rdev,\n\t\t\t      struct r100_cs_track *track, unsigned idx)\n{\n\tunsigned face, w, h;\n\tstruct radeon_bo *cube_robj;\n\tunsigned long size;\n\tunsigned compress_format = track->textures[idx].compress_format;\n\n\tfor (face = 0; face < 5; face++) {\n\t\tcube_robj = track->textures[idx].cube_info[face].robj;\n\t\tw = track->textures[idx].cube_info[face].width;\n\t\th = track->textures[idx].cube_info[face].height;\n\n\t\tif (compress_format) {\n\t\t\tsize = r100_track_compress_size(compress_format, w, h);\n\t\t} else\n\t\t\tsize = w * h;\n\t\tsize *= track->textures[idx].cpp;\n\n\t\tsize += track->textures[idx].cube_info[face].offset;\n\n\t\tif (size > radeon_bo_size(cube_robj)) {\n\t\t\tDRM_ERROR(\"Cube texture offset greater than object size %lu %lu\\n\",\n\t\t\t\t  size, radeon_bo_size(cube_robj));\n\t\t\tr100_cs_track_texture_print(&track->textures[idx]);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int r100_cs_track_texture_check(struct radeon_device *rdev,\n\t\t\t\t       struct r100_cs_track *track)\n{\n\tstruct radeon_bo *robj;\n\tunsigned long size;\n\tunsigned u, i, w, h, d;\n\tint ret;\n\n\tfor (u = 0; u < track->num_texture; u++) {\n\t\tif (!track->textures[u].enabled)\n\t\t\tcontinue;\n\t\tif (track->textures[u].lookup_disable)\n\t\t\tcontinue;\n\t\trobj = track->textures[u].robj;\n\t\tif (robj == NULL) {\n\t\t\tDRM_ERROR(\"No texture bound to unit %u\\n\", u);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = 0;\n\t\tfor (i = 0; i <= track->textures[u].num_levels; i++) {\n\t\t\tif (track->textures[u].use_pitch) {\n\t\t\t\tif (rdev->family < CHIP_R300)\n\t\t\t\t\tw = (track->textures[u].pitch / track->textures[u].cpp) / (1 << i);\n\t\t\t\telse\n\t\t\t\t\tw = track->textures[u].pitch / (1 << i);\n\t\t\t} else {\n\t\t\t\tw = track->textures[u].width;\n\t\t\t\tif (rdev->family >= CHIP_RV515)\n\t\t\t\t\tw |= track->textures[u].width_11;\n\t\t\t\tw = w / (1 << i);\n\t\t\t\tif (track->textures[u].roundup_w)\n\t\t\t\t\tw = roundup_pow_of_two(w);\n\t\t\t}\n\t\t\th = track->textures[u].height;\n\t\t\tif (rdev->family >= CHIP_RV515)\n\t\t\t\th |= track->textures[u].height_11;\n\t\t\th = h / (1 << i);\n\t\t\tif (track->textures[u].roundup_h)\n\t\t\t\th = roundup_pow_of_two(h);\n\t\t\tif (track->textures[u].tex_coord_type == 1) {\n\t\t\t\td = (1 << track->textures[u].txdepth) / (1 << i);\n\t\t\t\tif (!d)\n\t\t\t\t\td = 1;\n\t\t\t} else {\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\tif (track->textures[u].compress_format) {\n\n\t\t\t\tsize += r100_track_compress_size(track->textures[u].compress_format, w, h) * d;\n\t\t\t\t \n\t\t\t} else\n\t\t\t\tsize += w * h * d;\n\t\t}\n\t\tsize *= track->textures[u].cpp;\n\n\t\tswitch (track->textures[u].tex_coord_type) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (track->separate_cube) {\n\t\t\t\tret = r100_cs_track_cube(rdev, track, u);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\tsize *= 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Invalid texture coordinate type %u for unit \"\n\t\t\t\t  \"%u\\n\", track->textures[u].tex_coord_type, u);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (size > radeon_bo_size(robj)) {\n\t\t\tDRM_ERROR(\"Texture of unit %u needs %lu bytes but is \"\n\t\t\t\t  \"%lu\\n\", u, size, radeon_bo_size(robj));\n\t\t\tr100_cs_track_texture_print(&track->textures[u]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint r100_cs_track_check(struct radeon_device *rdev, struct r100_cs_track *track)\n{\n\tunsigned i;\n\tunsigned long size;\n\tunsigned prim_walk;\n\tunsigned nverts;\n\tunsigned num_cb = track->cb_dirty ? track->num_cb : 0;\n\n\tif (num_cb && !track->zb_cb_clear && !track->color_channel_mask &&\n\t    !track->blend_read_enable)\n\t\tnum_cb = 0;\n\n\tfor (i = 0; i < num_cb; i++) {\n\t\tif (track->cb[i].robj == NULL) {\n\t\t\tDRM_ERROR(\"[drm] No buffer for color buffer %d !\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = track->cb[i].pitch * track->cb[i].cpp * track->maxy;\n\t\tsize += track->cb[i].offset;\n\t\tif (size > radeon_bo_size(track->cb[i].robj)) {\n\t\t\tDRM_ERROR(\"[drm] Buffer too small for color buffer %d \"\n\t\t\t\t  \"(need %lu have %lu) !\\n\", i, size,\n\t\t\t\t  radeon_bo_size(track->cb[i].robj));\n\t\t\tDRM_ERROR(\"[drm] color buffer %d (%u %u %u %u)\\n\",\n\t\t\t\t  i, track->cb[i].pitch, track->cb[i].cpp,\n\t\t\t\t  track->cb[i].offset, track->maxy);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\ttrack->cb_dirty = false;\n\n\tif (track->zb_dirty && track->z_enabled) {\n\t\tif (track->zb.robj == NULL) {\n\t\t\tDRM_ERROR(\"[drm] No buffer for z buffer !\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsize = track->zb.pitch * track->zb.cpp * track->maxy;\n\t\tsize += track->zb.offset;\n\t\tif (size > radeon_bo_size(track->zb.robj)) {\n\t\t\tDRM_ERROR(\"[drm] Buffer too small for z buffer \"\n\t\t\t\t  \"(need %lu have %lu) !\\n\", size,\n\t\t\t\t  radeon_bo_size(track->zb.robj));\n\t\t\tDRM_ERROR(\"[drm] zbuffer (%u %u %u %u)\\n\",\n\t\t\t\t  track->zb.pitch, track->zb.cpp,\n\t\t\t\t  track->zb.offset, track->maxy);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\ttrack->zb_dirty = false;\n\n\tif (track->aa_dirty && track->aaresolve) {\n\t\tif (track->aa.robj == NULL) {\n\t\t\tDRM_ERROR(\"[drm] No buffer for AA resolve buffer %d !\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tsize = track->aa.pitch * track->cb[0].cpp * track->maxy;\n\t\tsize += track->aa.offset;\n\t\tif (size > radeon_bo_size(track->aa.robj)) {\n\t\t\tDRM_ERROR(\"[drm] Buffer too small for AA resolve buffer %d \"\n\t\t\t\t  \"(need %lu have %lu) !\\n\", i, size,\n\t\t\t\t  radeon_bo_size(track->aa.robj));\n\t\t\tDRM_ERROR(\"[drm] AA resolve buffer %d (%u %u %u %u)\\n\",\n\t\t\t\t  i, track->aa.pitch, track->cb[0].cpp,\n\t\t\t\t  track->aa.offset, track->maxy);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\ttrack->aa_dirty = false;\n\n\tprim_walk = (track->vap_vf_cntl >> 4) & 0x3;\n\tif (track->vap_vf_cntl & (1 << 14)) {\n\t\tnverts = track->vap_alt_nverts;\n\t} else {\n\t\tnverts = (track->vap_vf_cntl >> 16) & 0xFFFF;\n\t}\n\tswitch (prim_walk) {\n\tcase 1:\n\t\tfor (i = 0; i < track->num_arrays; i++) {\n\t\t\tsize = track->arrays[i].esize * track->max_indx * 4UL;\n\t\t\tif (track->arrays[i].robj == NULL) {\n\t\t\t\tDRM_ERROR(\"(PW %u) Vertex array %u no buffer \"\n\t\t\t\t\t  \"bound\\n\", prim_walk, i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (size > radeon_bo_size(track->arrays[i].robj)) {\n\t\t\t\tdev_err(rdev->dev, \"(PW %u) Vertex array %u \"\n\t\t\t\t\t\"need %lu dwords have %lu dwords\\n\",\n\t\t\t\t\tprim_walk, i, size >> 2,\n\t\t\t\t\tradeon_bo_size(track->arrays[i].robj)\n\t\t\t\t\t>> 2);\n\t\t\t\tDRM_ERROR(\"Max indices %u\\n\", track->max_indx);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tfor (i = 0; i < track->num_arrays; i++) {\n\t\t\tsize = track->arrays[i].esize * (nverts - 1) * 4UL;\n\t\t\tif (track->arrays[i].robj == NULL) {\n\t\t\t\tDRM_ERROR(\"(PW %u) Vertex array %u no buffer \"\n\t\t\t\t\t  \"bound\\n\", prim_walk, i);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (size > radeon_bo_size(track->arrays[i].robj)) {\n\t\t\t\tdev_err(rdev->dev, \"(PW %u) Vertex array %u \"\n\t\t\t\t\t\"need %lu dwords have %lu dwords\\n\",\n\t\t\t\t\tprim_walk, i, size >> 2,\n\t\t\t\t\tradeon_bo_size(track->arrays[i].robj)\n\t\t\t\t\t>> 2);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tsize = track->vtx_size * nverts;\n\t\tif (size != track->immd_dwords) {\n\t\t\tDRM_ERROR(\"IMMD draw %u dwors but needs %lu dwords\\n\",\n\t\t\t\t  track->immd_dwords, size);\n\t\t\tDRM_ERROR(\"VAP_VF_CNTL.NUM_VERTICES %u, VTX_SIZE %u\\n\",\n\t\t\t\t  nverts, track->vtx_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"[drm] Invalid primitive walk %d for VAP_VF_CNTL\\n\",\n\t\t\t  prim_walk);\n\t\treturn -EINVAL;\n\t}\n\n\tif (track->tex_dirty) {\n\t\ttrack->tex_dirty = false;\n\t\treturn r100_cs_track_texture_check(rdev, track);\n\t}\n\treturn 0;\n}\n\nvoid r100_cs_track_clear(struct radeon_device *rdev, struct r100_cs_track *track)\n{\n\tunsigned i, face;\n\n\ttrack->cb_dirty = true;\n\ttrack->zb_dirty = true;\n\ttrack->tex_dirty = true;\n\ttrack->aa_dirty = true;\n\n\tif (rdev->family < CHIP_R300) {\n\t\ttrack->num_cb = 1;\n\t\tif (rdev->family <= CHIP_RS200)\n\t\t\ttrack->num_texture = 3;\n\t\telse\n\t\t\ttrack->num_texture = 6;\n\t\ttrack->maxy = 2048;\n\t\ttrack->separate_cube = true;\n\t} else {\n\t\ttrack->num_cb = 4;\n\t\ttrack->num_texture = 16;\n\t\ttrack->maxy = 4096;\n\t\ttrack->separate_cube = false;\n\t\ttrack->aaresolve = false;\n\t\ttrack->aa.robj = NULL;\n\t}\n\n\tfor (i = 0; i < track->num_cb; i++) {\n\t\ttrack->cb[i].robj = NULL;\n\t\ttrack->cb[i].pitch = 8192;\n\t\ttrack->cb[i].cpp = 16;\n\t\ttrack->cb[i].offset = 0;\n\t}\n\ttrack->z_enabled = true;\n\ttrack->zb.robj = NULL;\n\ttrack->zb.pitch = 8192;\n\ttrack->zb.cpp = 4;\n\ttrack->zb.offset = 0;\n\ttrack->vtx_size = 0x7F;\n\ttrack->immd_dwords = 0xFFFFFFFFUL;\n\ttrack->num_arrays = 11;\n\ttrack->max_indx = 0x00FFFFFFUL;\n\tfor (i = 0; i < track->num_arrays; i++) {\n\t\ttrack->arrays[i].robj = NULL;\n\t\ttrack->arrays[i].esize = 0x7F;\n\t}\n\tfor (i = 0; i < track->num_texture; i++) {\n\t\ttrack->textures[i].compress_format = R100_TRACK_COMP_NONE;\n\t\ttrack->textures[i].pitch = 16536;\n\t\ttrack->textures[i].width = 16536;\n\t\ttrack->textures[i].height = 16536;\n\t\ttrack->textures[i].width_11 = 1 << 11;\n\t\ttrack->textures[i].height_11 = 1 << 11;\n\t\ttrack->textures[i].num_levels = 12;\n\t\tif (rdev->family <= CHIP_RS200) {\n\t\t\ttrack->textures[i].tex_coord_type = 0;\n\t\t\ttrack->textures[i].txdepth = 0;\n\t\t} else {\n\t\t\ttrack->textures[i].txdepth = 16;\n\t\t\ttrack->textures[i].tex_coord_type = 1;\n\t\t}\n\t\ttrack->textures[i].cpp = 64;\n\t\ttrack->textures[i].robj = NULL;\n\t\t \n\t\ttrack->textures[i].enabled = false;\n\t\ttrack->textures[i].lookup_disable = false;\n\t\ttrack->textures[i].roundup_w = true;\n\t\ttrack->textures[i].roundup_h = true;\n\t\tif (track->separate_cube)\n\t\t\tfor (face = 0; face < 5; face++) {\n\t\t\t\ttrack->textures[i].cube_info[face].robj = NULL;\n\t\t\t\ttrack->textures[i].cube_info[face].width = 16536;\n\t\t\t\ttrack->textures[i].cube_info[face].height = 16536;\n\t\t\t\ttrack->textures[i].cube_info[face].offset = 0;\n\t\t\t}\n\t}\n}\n\n \nstatic void r100_errata(struct radeon_device *rdev)\n{\n\trdev->pll_errata = 0;\n\n\tif (rdev->family == CHIP_RV200 || rdev->family == CHIP_RS200) {\n\t\trdev->pll_errata |= CHIP_ERRATA_PLL_DUMMYREADS;\n\t}\n\n\tif (rdev->family == CHIP_RV100 ||\n\t    rdev->family == CHIP_RS100 ||\n\t    rdev->family == CHIP_RS200) {\n\t\trdev->pll_errata |= CHIP_ERRATA_PLL_DELAY;\n\t}\n}\n\nstatic int r100_rbbm_fifo_wait_for_entry(struct radeon_device *rdev, unsigned n)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(RADEON_RBBM_STATUS) & RADEON_RBBM_FIFOCNT_MASK;\n\t\tif (tmp >= n) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nint r100_gui_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tif (r100_rbbm_fifo_wait_for_entry(rdev, 64)) {\n\t\tpr_warn(\"radeon: wait for empty RBBM fifo failed! Bad things might happen.\\n\");\n\t}\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(RADEON_RBBM_STATUS);\n\t\tif (!(tmp & RADEON_RBBM_ACTIVE)) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nint r100_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(RADEON_MC_STATUS);\n\t\tif (tmp & RADEON_MC_IDLE) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nbool r100_gpu_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tu32 rbbm_status;\n\n\trbbm_status = RREG32(R_000E40_RBBM_STATUS);\n\tif (!G_000E40_GUI_ACTIVE(rbbm_status)) {\n\t\tradeon_ring_lockup_update(rdev, ring);\n\t\treturn false;\n\t}\n\treturn radeon_ring_test_lockup(rdev, ring);\n}\n\n \nvoid r100_enable_bm(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\t \n\ttmp = RREG32(RADEON_BUS_CNTL) & ~RADEON_BUS_MASTER_DIS;\n\tWREG32(RADEON_BUS_CNTL, tmp);\n}\n\nvoid r100_bm_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\t \n\ttmp = RREG32(R_000030_BUS_CNTL);\n\tWREG32(R_000030_BUS_CNTL, (tmp & 0xFFFFFFFF) | 0x00000044);\n\tmdelay(1);\n\tWREG32(R_000030_BUS_CNTL, (tmp & 0xFFFFFFFF) | 0x00000042);\n\tmdelay(1);\n\tWREG32(R_000030_BUS_CNTL, (tmp & 0xFFFFFFFF) | 0x00000040);\n\ttmp = RREG32(RADEON_BUS_CNTL);\n\tmdelay(1);\n\tpci_clear_master(rdev->pdev);\n\tmdelay(1);\n}\n\nint r100_asic_reset(struct radeon_device *rdev, bool hard)\n{\n\tstruct r100_mc_save save;\n\tu32 status, tmp;\n\tint ret = 0;\n\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tif (!G_000E40_GUI_ACTIVE(status)) {\n\t\treturn 0;\n\t}\n\tr100_mc_stop(rdev, &save);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(RADEON_CP_CSQ_CNTL, 0);\n\ttmp = RREG32(RADEON_CP_RB_CNTL);\n\tWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_RPTR_WR_ENA);\n\tWREG32(RADEON_CP_RB_RPTR_WR, 0);\n\tWREG32(RADEON_CP_RB_WPTR, 0);\n\tWREG32(RADEON_CP_RB_CNTL, tmp);\n\t \n\tpci_save_state(rdev->pdev);\n\t \n\tr100_bm_disable(rdev);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_SE(1) |\n\t\t\t\t\tS_0000F0_SOFT_RESET_RE(1) |\n\t\t\t\t\tS_0000F0_SOFT_RESET_PP(1) |\n\t\t\t\t\tS_0000F0_SOFT_RESET_RB(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_CP(1));\n\tRREG32(R_0000F0_RBBM_SOFT_RESET);\n\tmdelay(500);\n\tWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\n\tmdelay(1);\n\tstatus = RREG32(R_000E40_RBBM_STATUS);\n\tdev_info(rdev->dev, \"(%s:%d) RBBM_STATUS=0x%08X\\n\", __func__, __LINE__, status);\n\t \n\tpci_restore_state(rdev->pdev);\n\tr100_enable_bm(rdev);\n\t \n\tif (G_000E40_SE_BUSY(status) || G_000E40_RE_BUSY(status) ||\n\t\tG_000E40_TAM_BUSY(status) || G_000E40_PB_BUSY(status)) {\n\t\tdev_err(rdev->dev, \"failed to reset GPU\\n\");\n\t\tret = -1;\n\t} else\n\t\tdev_info(rdev->dev, \"GPU reset succeed\\n\");\n\tr100_mc_resume(rdev, &save);\n\treturn ret;\n}\n\nvoid r100_set_common_regs(struct radeon_device *rdev)\n{\n\tbool force_dac2 = false;\n\tu32 tmp;\n\n\t \n\tWREG32(RADEON_OV0_SCALE_CNTL, 0);\n\tWREG32(RADEON_SUBPIC_CNTL, 0);\n\tWREG32(RADEON_VIPH_CONTROL, 0);\n\tWREG32(RADEON_I2C_CNTL_1, 0);\n\tWREG32(RADEON_DVI_I2C_CNTL_1, 0);\n\tWREG32(RADEON_CAP0_TRIG_CNTL, 0);\n\tWREG32(RADEON_CAP1_TRIG_CNTL, 0);\n\n\t \n\tswitch (rdev->pdev->device) {\n\t\t \n\tcase 0x515e:\n\tcase 0x5969:\n\t\tforce_dac2 = true;\n\t\tbreak;\n\t\t \n\tcase 0x5159:\n\tcase 0x515a:\n\t\t \n\t\tif ((rdev->pdev->subsystem_vendor == 0x1028  ) &&\n\t\t    ((rdev->pdev->subsystem_device == 0x016c) ||\n\t\t     (rdev->pdev->subsystem_device == 0x016d) ||\n\t\t     (rdev->pdev->subsystem_device == 0x016e) ||\n\t\t     (rdev->pdev->subsystem_device == 0x016f) ||\n\t\t     (rdev->pdev->subsystem_device == 0x0170) ||\n\t\t     (rdev->pdev->subsystem_device == 0x017d) ||\n\t\t     (rdev->pdev->subsystem_device == 0x017e) ||\n\t\t     (rdev->pdev->subsystem_device == 0x0183) ||\n\t\t     (rdev->pdev->subsystem_device == 0x018a) ||\n\t\t     (rdev->pdev->subsystem_device == 0x019a)))\n\t\t\tforce_dac2 = true;\n\t\tbreak;\n\t}\n\n\tif (force_dac2) {\n\t\tu32 disp_hw_debug = RREG32(RADEON_DISP_HW_DEBUG);\n\t\tu32 tv_dac_cntl = RREG32(RADEON_TV_DAC_CNTL);\n\t\tu32 dac2_cntl = RREG32(RADEON_DAC_CNTL2);\n\n\t\t \n\n\t\t \n\t\tdac2_cntl &= ~RADEON_DAC2_DAC_CLK_SEL;\n\t\tdac2_cntl |= RADEON_DAC2_DAC2_CLK_SEL;\n\t\tdisp_hw_debug |= RADEON_CRT2_DISP1_SEL;\n\n\t\t \n\t\ttv_dac_cntl &= ~(RADEON_TV_DAC_PEDESTAL |\n\t\t\t\t RADEON_TV_DAC_STD_MASK |\n\t\t\t\t RADEON_TV_DAC_RDACPD |\n\t\t\t\t RADEON_TV_DAC_GDACPD |\n\t\t\t\t RADEON_TV_DAC_BDACPD |\n\t\t\t\t RADEON_TV_DAC_BGADJ_MASK |\n\t\t\t\t RADEON_TV_DAC_DACADJ_MASK);\n\t\ttv_dac_cntl |= (RADEON_TV_DAC_NBLANK |\n\t\t\t\tRADEON_TV_DAC_NHOLD |\n\t\t\t\tRADEON_TV_DAC_STD_PS2 |\n\t\t\t\t(0x58 << 16));\n\n\t\tWREG32(RADEON_TV_DAC_CNTL, tv_dac_cntl);\n\t\tWREG32(RADEON_DISP_HW_DEBUG, disp_hw_debug);\n\t\tWREG32(RADEON_DAC_CNTL2, dac2_cntl);\n\t}\n\n\t \n\ttmp = RREG32_PLL(RADEON_PLL_PWRMGT_CNTL);\n\ttmp &= ~RADEON_PM_MODE_SEL;\n\tWREG32_PLL(RADEON_PLL_PWRMGT_CNTL, tmp);\n\n}\n\n \nstatic void r100_vram_get_type(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\n\trdev->mc.vram_is_ddr = false;\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\trdev->mc.vram_is_ddr = true;\n\telse if (RREG32(RADEON_MEM_SDRAM_MODE_REG) & RADEON_MEM_CFG_TYPE_DDR)\n\t\trdev->mc.vram_is_ddr = true;\n\tif ((rdev->family == CHIP_RV100) ||\n\t    (rdev->family == CHIP_RS100) ||\n\t    (rdev->family == CHIP_RS200)) {\n\t\ttmp = RREG32(RADEON_MEM_CNTL);\n\t\tif (tmp & RV100_HALF_MODE) {\n\t\t\trdev->mc.vram_width = 32;\n\t\t} else {\n\t\t\trdev->mc.vram_width = 64;\n\t\t}\n\t\tif (rdev->flags & RADEON_SINGLE_CRTC) {\n\t\t\trdev->mc.vram_width /= 4;\n\t\t\trdev->mc.vram_is_ddr = true;\n\t\t}\n\t} else if (rdev->family <= CHIP_RV280) {\n\t\ttmp = RREG32(RADEON_MEM_CNTL);\n\t\tif (tmp & RADEON_MEM_NUM_CHANNELS_MASK) {\n\t\t\trdev->mc.vram_width = 128;\n\t\t} else {\n\t\t\trdev->mc.vram_width = 64;\n\t\t}\n\t} else {\n\t\t \n\t\trdev->mc.vram_width = 128;\n\t}\n}\n\nstatic u32 r100_get_accessible_vram(struct radeon_device *rdev)\n{\n\tu32 aper_size;\n\tu8 byte;\n\n\taper_size = RREG32(RADEON_CONFIG_APER_SIZE);\n\n\t \n\tif (rdev->family == CHIP_RV280 ||\n\t    rdev->family >= CHIP_RV350) {\n\t\tWREG32_P(RADEON_HOST_PATH_CNTL, RADEON_HDP_APER_CNTL,\n\t\t       ~RADEON_HDP_APER_CNTL);\n\t\tDRM_INFO(\"Generation 2 PCI interface, using max accessible memory\\n\");\n\t\treturn aper_size * 2;\n\t}\n\n\t \n\tpci_read_config_byte(rdev->pdev, 0xe, &byte);\n\tif (byte & 0x80) {\n\t\tDRM_INFO(\"Generation 1 PCI interface in multifunction mode\\n\");\n\t\tDRM_INFO(\"Limiting VRAM to one aperture\\n\");\n\t\treturn aper_size;\n\t}\n\n\t \n\tif (RREG32(RADEON_HOST_PATH_CNTL) & RADEON_HDP_APER_CNTL)\n\t\treturn aper_size * 2;\n\treturn aper_size;\n}\n\nvoid r100_vram_init_sizes(struct radeon_device *rdev)\n{\n\tu64 config_aper_size;\n\n\t \n\trdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\n\trdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\n\trdev->mc.visible_vram_size = r100_get_accessible_vram(rdev);\n\t \n\tif (rdev->mc.visible_vram_size > rdev->mc.aper_size)\n\t\trdev->mc.visible_vram_size = rdev->mc.aper_size;\n\tconfig_aper_size = RREG32(RADEON_CONFIG_APER_SIZE);\n\tif (rdev->flags & RADEON_IS_IGP) {\n\t\tuint32_t tom;\n\t\t \n\t\ttom = RREG32(RADEON_NB_TOM);\n\t\trdev->mc.real_vram_size = (((tom >> 16) - (tom & 0xffff) + 1) << 16);\n\t\tWREG32(RADEON_CONFIG_MEMSIZE, rdev->mc.real_vram_size);\n\t\trdev->mc.mc_vram_size = rdev->mc.real_vram_size;\n\t} else {\n\t\trdev->mc.real_vram_size = RREG32(RADEON_CONFIG_MEMSIZE);\n\t\t \n\t\tif (rdev->mc.real_vram_size == 0) {\n\t\t\trdev->mc.real_vram_size = 8192 * 1024;\n\t\t\tWREG32(RADEON_CONFIG_MEMSIZE, rdev->mc.real_vram_size);\n\t\t}\n\t\t \n\t\tif (rdev->mc.aper_size > config_aper_size)\n\t\t\tconfig_aper_size = rdev->mc.aper_size;\n\n\t\tif (config_aper_size > rdev->mc.real_vram_size)\n\t\t\trdev->mc.mc_vram_size = config_aper_size;\n\t\telse\n\t\t\trdev->mc.mc_vram_size = rdev->mc.real_vram_size;\n\t}\n}\n\nvoid r100_vga_set_state(struct radeon_device *rdev, bool state)\n{\n\tuint32_t temp;\n\n\ttemp = RREG32(RADEON_CONFIG_CNTL);\n\tif (!state) {\n\t\ttemp &= ~RADEON_CFG_VGA_RAM_EN;\n\t\ttemp |= RADEON_CFG_VGA_IO_DIS;\n\t} else {\n\t\ttemp &= ~RADEON_CFG_VGA_IO_DIS;\n\t}\n\tWREG32(RADEON_CONFIG_CNTL, temp);\n}\n\nstatic void r100_mc_init(struct radeon_device *rdev)\n{\n\tu64 base;\n\n\tr100_vram_get_type(rdev);\n\tr100_vram_init_sizes(rdev);\n\tbase = rdev->mc.aper_base;\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\tbase = (RREG32(RADEON_NB_TOM) & 0xffff) << 16;\n\tradeon_vram_location(rdev, &rdev->mc, base);\n\trdev->mc.gtt_base_align = 0;\n\tif (!(rdev->flags & RADEON_IS_AGP))\n\t\tradeon_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n}\n\n\n \nvoid r100_pll_errata_after_index(struct radeon_device *rdev)\n{\n\tif (rdev->pll_errata & CHIP_ERRATA_PLL_DUMMYREADS) {\n\t\t(void)RREG32(RADEON_CLOCK_CNTL_DATA);\n\t\t(void)RREG32(RADEON_CRTC_GEN_CNTL);\n\t}\n}\n\nstatic void r100_pll_errata_after_data(struct radeon_device *rdev)\n{\n\t \n\tif (rdev->pll_errata & CHIP_ERRATA_PLL_DELAY) {\n\t\tmdelay(5);\n\t}\n\n\t \n\tif (rdev->pll_errata & CHIP_ERRATA_R300_CG) {\n\t\tuint32_t save, tmp;\n\n\t\tsave = RREG32(RADEON_CLOCK_CNTL_INDEX);\n\t\ttmp = save & ~(0x3f | RADEON_PLL_WR_EN);\n\t\tWREG32(RADEON_CLOCK_CNTL_INDEX, tmp);\n\t\ttmp = RREG32(RADEON_CLOCK_CNTL_DATA);\n\t\tWREG32(RADEON_CLOCK_CNTL_INDEX, save);\n\t}\n}\n\nuint32_t r100_pll_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t data;\n\n\tspin_lock_irqsave(&rdev->pll_idx_lock, flags);\n\tWREG8(RADEON_CLOCK_CNTL_INDEX, reg & 0x3f);\n\tr100_pll_errata_after_index(rdev);\n\tdata = RREG32(RADEON_CLOCK_CNTL_DATA);\n\tr100_pll_errata_after_data(rdev);\n\tspin_unlock_irqrestore(&rdev->pll_idx_lock, flags);\n\treturn data;\n}\n\nvoid r100_pll_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->pll_idx_lock, flags);\n\tWREG8(RADEON_CLOCK_CNTL_INDEX, ((reg & 0x3f) | RADEON_PLL_WR_EN));\n\tr100_pll_errata_after_index(rdev);\n\tWREG32(RADEON_CLOCK_CNTL_DATA, v);\n\tr100_pll_errata_after_data(rdev);\n\tspin_unlock_irqrestore(&rdev->pll_idx_lock, flags);\n}\n\nstatic void r100_set_safe_registers(struct radeon_device *rdev)\n{\n\tif (ASIC_IS_RN50(rdev)) {\n\t\trdev->config.r100.reg_safe_bm = rn50_reg_safe_bm;\n\t\trdev->config.r100.reg_safe_bm_size = ARRAY_SIZE(rn50_reg_safe_bm);\n\t} else if (rdev->family < CHIP_R200) {\n\t\trdev->config.r100.reg_safe_bm = r100_reg_safe_bm;\n\t\trdev->config.r100.reg_safe_bm_size = ARRAY_SIZE(r100_reg_safe_bm);\n\t} else {\n\t\tr200_set_safe_registers(rdev);\n\t}\n}\n\n \n#if defined(CONFIG_DEBUG_FS)\nstatic int r100_debugfs_rbbm_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t reg, value;\n\tunsigned i;\n\n\tseq_printf(m, \"RBBM_STATUS 0x%08x\\n\", RREG32(RADEON_RBBM_STATUS));\n\tseq_printf(m, \"RBBM_CMDFIFO_STAT 0x%08x\\n\", RREG32(0xE7C));\n\tseq_printf(m, \"CP_STAT 0x%08x\\n\", RREG32(RADEON_CP_STAT));\n\tfor (i = 0; i < 64; i++) {\n\t\tWREG32(RADEON_RBBM_CMDFIFO_ADDR, i | 0x100);\n\t\treg = (RREG32(RADEON_RBBM_CMDFIFO_DATA) - 1) >> 2;\n\t\tWREG32(RADEON_RBBM_CMDFIFO_ADDR, i);\n\t\tvalue = RREG32(RADEON_RBBM_CMDFIFO_DATA);\n\t\tseq_printf(m, \"[0x%03X] 0x%04X=0x%08X\\n\", i, reg, value);\n\t}\n\treturn 0;\n}\n\nstatic int r100_debugfs_cp_ring_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\tuint32_t rdp, wdp;\n\tunsigned count, i, j;\n\n\tradeon_ring_free_size(rdev, ring);\n\trdp = RREG32(RADEON_CP_RB_RPTR);\n\twdp = RREG32(RADEON_CP_RB_WPTR);\n\tcount = (rdp + ring->ring_size - wdp) & ring->ptr_mask;\n\tseq_printf(m, \"CP_STAT 0x%08x\\n\", RREG32(RADEON_CP_STAT));\n\tseq_printf(m, \"CP_RB_WPTR 0x%08x\\n\", wdp);\n\tseq_printf(m, \"CP_RB_RPTR 0x%08x\\n\", rdp);\n\tseq_printf(m, \"%u free dwords in ring\\n\", ring->ring_free_dw);\n\tseq_printf(m, \"%u dwords in ring\\n\", count);\n\tif (ring->ready) {\n\t\tfor (j = 0; j <= count; j++) {\n\t\t\ti = (rdp + j) & ring->ptr_mask;\n\t\t\tseq_printf(m, \"r[%04d]=0x%08x\\n\", i, ring->ring[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int r100_debugfs_cp_csq_fifo_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t csq_stat, csq2_stat, tmp;\n\tunsigned r_rptr, r_wptr, ib1_rptr, ib1_wptr, ib2_rptr, ib2_wptr;\n\tunsigned i;\n\n\tseq_printf(m, \"CP_STAT 0x%08x\\n\", RREG32(RADEON_CP_STAT));\n\tseq_printf(m, \"CP_CSQ_MODE 0x%08x\\n\", RREG32(RADEON_CP_CSQ_MODE));\n\tcsq_stat = RREG32(RADEON_CP_CSQ_STAT);\n\tcsq2_stat = RREG32(RADEON_CP_CSQ2_STAT);\n\tr_rptr = (csq_stat >> 0) & 0x3ff;\n\tr_wptr = (csq_stat >> 10) & 0x3ff;\n\tib1_rptr = (csq_stat >> 20) & 0x3ff;\n\tib1_wptr = (csq2_stat >> 0) & 0x3ff;\n\tib2_rptr = (csq2_stat >> 10) & 0x3ff;\n\tib2_wptr = (csq2_stat >> 20) & 0x3ff;\n\tseq_printf(m, \"CP_CSQ_STAT 0x%08x\\n\", csq_stat);\n\tseq_printf(m, \"CP_CSQ2_STAT 0x%08x\\n\", csq2_stat);\n\tseq_printf(m, \"Ring rptr %u\\n\", r_rptr);\n\tseq_printf(m, \"Ring wptr %u\\n\", r_wptr);\n\tseq_printf(m, \"Indirect1 rptr %u\\n\", ib1_rptr);\n\tseq_printf(m, \"Indirect1 wptr %u\\n\", ib1_wptr);\n\tseq_printf(m, \"Indirect2 rptr %u\\n\", ib2_rptr);\n\tseq_printf(m, \"Indirect2 wptr %u\\n\", ib2_wptr);\n\t \n\tseq_printf(m, \"Ring fifo:\\n\");\n\tfor (i = 0; i < 256; i++) {\n\t\tWREG32(RADEON_CP_CSQ_ADDR, i << 2);\n\t\ttmp = RREG32(RADEON_CP_CSQ_DATA);\n\t\tseq_printf(m, \"rfifo[%04d]=0x%08X\\n\", i, tmp);\n\t}\n\tseq_printf(m, \"Indirect1 fifo:\\n\");\n\tfor (i = 256; i <= 512; i++) {\n\t\tWREG32(RADEON_CP_CSQ_ADDR, i << 2);\n\t\ttmp = RREG32(RADEON_CP_CSQ_DATA);\n\t\tseq_printf(m, \"ib1fifo[%04d]=0x%08X\\n\", i, tmp);\n\t}\n\tseq_printf(m, \"Indirect2 fifo:\\n\");\n\tfor (i = 640; i < ib1_wptr; i++) {\n\t\tWREG32(RADEON_CP_CSQ_ADDR, i << 2);\n\t\ttmp = RREG32(RADEON_CP_CSQ_DATA);\n\t\tseq_printf(m, \"ib2fifo[%04d]=0x%08X\\n\", i, tmp);\n\t}\n\treturn 0;\n}\n\nstatic int r100_debugfs_mc_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t tmp;\n\n\ttmp = RREG32(RADEON_CONFIG_MEMSIZE);\n\tseq_printf(m, \"CONFIG_MEMSIZE 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_MC_FB_LOCATION);\n\tseq_printf(m, \"MC_FB_LOCATION 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_BUS_CNTL);\n\tseq_printf(m, \"BUS_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_MC_AGP_LOCATION);\n\tseq_printf(m, \"MC_AGP_LOCATION 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_AGP_BASE);\n\tseq_printf(m, \"AGP_BASE 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_HOST_PATH_CNTL);\n\tseq_printf(m, \"HOST_PATH_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32(0x01D0);\n\tseq_printf(m, \"AIC_CTRL 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_AIC_LO_ADDR);\n\tseq_printf(m, \"AIC_LO_ADDR 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_AIC_HI_ADDR);\n\tseq_printf(m, \"AIC_HI_ADDR 0x%08x\\n\", tmp);\n\ttmp = RREG32(0x01E4);\n\tseq_printf(m, \"AIC_TLB_ADDR 0x%08x\\n\", tmp);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(r100_debugfs_rbbm_info);\nDEFINE_SHOW_ATTRIBUTE(r100_debugfs_cp_ring_info);\nDEFINE_SHOW_ATTRIBUTE(r100_debugfs_cp_csq_fifo);\nDEFINE_SHOW_ATTRIBUTE(r100_debugfs_mc_info);\n\n#endif\n\nvoid  r100_debugfs_rbbm_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"r100_rbbm_info\", 0444, root, rdev,\n\t\t\t    &r100_debugfs_rbbm_info_fops);\n#endif\n}\n\nvoid r100_debugfs_cp_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"r100_cp_ring_info\", 0444, root, rdev,\n\t\t\t    &r100_debugfs_cp_ring_info_fops);\n\tdebugfs_create_file(\"r100_cp_csq_fifo\", 0444, root, rdev,\n\t\t\t    &r100_debugfs_cp_csq_fifo_fops);\n#endif\n}\n\nvoid  r100_debugfs_mc_info_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"r100_mc_info\", 0444, root, rdev,\n\t\t\t    &r100_debugfs_mc_info_fops);\n#endif\n}\n\nint r100_set_surface_reg(struct radeon_device *rdev, int reg,\n\t\t\t uint32_t tiling_flags, uint32_t pitch,\n\t\t\t uint32_t offset, uint32_t obj_size)\n{\n\tint surf_index = reg * 16;\n\tint flags = 0;\n\n\tif (rdev->family <= CHIP_RS200) {\n\t\tif ((tiling_flags & (RADEON_TILING_MACRO|RADEON_TILING_MICRO))\n\t\t\t\t == (RADEON_TILING_MACRO|RADEON_TILING_MICRO))\n\t\t\tflags |= RADEON_SURF_TILE_COLOR_BOTH;\n\t\tif (tiling_flags & RADEON_TILING_MACRO)\n\t\t\tflags |= RADEON_SURF_TILE_COLOR_MACRO;\n\t\t \n\t\tif ((tiling_flags & (RADEON_TILING_MACRO|RADEON_TILING_MICRO))\n\t\t\t\t== 0)\n\t\t\tpitch = 0;\n\t} else if (rdev->family <= CHIP_RV280) {\n\t\tif (tiling_flags & (RADEON_TILING_MACRO))\n\t\t\tflags |= R200_SURF_TILE_COLOR_MACRO;\n\t\tif (tiling_flags & RADEON_TILING_MICRO)\n\t\t\tflags |= R200_SURF_TILE_COLOR_MICRO;\n\t} else {\n\t\tif (tiling_flags & RADEON_TILING_MACRO)\n\t\t\tflags |= R300_SURF_TILE_MACRO;\n\t\tif (tiling_flags & RADEON_TILING_MICRO)\n\t\t\tflags |= R300_SURF_TILE_MICRO;\n\t}\n\n\tif (tiling_flags & RADEON_TILING_SWAP_16BIT)\n\t\tflags |= RADEON_SURF_AP0_SWP_16BPP | RADEON_SURF_AP1_SWP_16BPP;\n\tif (tiling_flags & RADEON_TILING_SWAP_32BIT)\n\t\tflags |= RADEON_SURF_AP0_SWP_32BPP | RADEON_SURF_AP1_SWP_32BPP;\n\n\t \n\tif (rdev->family < CHIP_R300)\n\t\tflags |= pitch / 16;\n\telse\n\t\tflags |= pitch / 8;\n\n\n\tDRM_DEBUG_KMS(\"writing surface %d %d %x %x\\n\", reg, flags, offset, offset+obj_size-1);\n\tWREG32(RADEON_SURFACE0_INFO + surf_index, flags);\n\tWREG32(RADEON_SURFACE0_LOWER_BOUND + surf_index, offset);\n\tWREG32(RADEON_SURFACE0_UPPER_BOUND + surf_index, offset + obj_size - 1);\n\treturn 0;\n}\n\nvoid r100_clear_surface_reg(struct radeon_device *rdev, int reg)\n{\n\tint surf_index = reg * 16;\n\tWREG32(RADEON_SURFACE0_INFO + surf_index, 0);\n}\n\nvoid r100_bandwidth_update(struct radeon_device *rdev)\n{\n\tfixed20_12 trcd_ff, trp_ff, tras_ff, trbs_ff, tcas_ff;\n\tfixed20_12 sclk_ff, mclk_ff, sclk_eff_ff, sclk_delay_ff;\n\tfixed20_12 peak_disp_bw, mem_bw, pix_clk, pix_clk2, temp_ff;\n\tfixed20_12 crit_point_ff = {0};\n\tuint32_t temp, data, mem_trcd, mem_trp, mem_tras;\n\tfixed20_12 memtcas_ff[8] = {\n\t\tdfixed_init(1),\n\t\tdfixed_init(2),\n\t\tdfixed_init(3),\n\t\tdfixed_init(0),\n\t\tdfixed_init_half(1),\n\t\tdfixed_init_half(2),\n\t\tdfixed_init(0),\n\t};\n\tfixed20_12 memtcas_rs480_ff[8] = {\n\t\tdfixed_init(0),\n\t\tdfixed_init(1),\n\t\tdfixed_init(2),\n\t\tdfixed_init(3),\n\t\tdfixed_init(0),\n\t\tdfixed_init_half(1),\n\t\tdfixed_init_half(2),\n\t\tdfixed_init_half(3),\n\t};\n\tfixed20_12 memtcas2_ff[8] = {\n\t\tdfixed_init(0),\n\t\tdfixed_init(1),\n\t\tdfixed_init(2),\n\t\tdfixed_init(3),\n\t\tdfixed_init(4),\n\t\tdfixed_init(5),\n\t\tdfixed_init(6),\n\t\tdfixed_init(7),\n\t};\n\tfixed20_12 memtrbs[8] = {\n\t\tdfixed_init(1),\n\t\tdfixed_init_half(1),\n\t\tdfixed_init(2),\n\t\tdfixed_init_half(2),\n\t\tdfixed_init(3),\n\t\tdfixed_init_half(3),\n\t\tdfixed_init(4),\n\t\tdfixed_init_half(4)\n\t};\n\tfixed20_12 memtrbs_r4xx[8] = {\n\t\tdfixed_init(4),\n\t\tdfixed_init(5),\n\t\tdfixed_init(6),\n\t\tdfixed_init(7),\n\t\tdfixed_init(8),\n\t\tdfixed_init(9),\n\t\tdfixed_init(10),\n\t\tdfixed_init(11)\n\t};\n\tfixed20_12 min_mem_eff;\n\tfixed20_12 mc_latency_sclk, mc_latency_mclk, k1;\n\tfixed20_12 cur_latency_mclk, cur_latency_sclk;\n\tfixed20_12 disp_latency, disp_latency_overhead, disp_drain_rate = {0},\n\t\tdisp_drain_rate2, read_return_rate;\n\tfixed20_12 time_disp1_drop_priority;\n\tint c;\n\tint cur_size = 16;        \n\tint critical_point = 0, critical_point2;\n \n\tint stop_req, max_stop_req;\n\tstruct drm_display_mode *mode1 = NULL;\n\tstruct drm_display_mode *mode2 = NULL;\n\tuint32_t pixel_bytes1 = 0;\n\tuint32_t pixel_bytes2 = 0;\n\n\t \n\tu32 lb_size = 8192;\n\n\tif (!rdev->mode_info.mode_config_initialized)\n\t\treturn;\n\n\tradeon_update_display_priority(rdev);\n\n\tif (rdev->mode_info.crtcs[0]->base.enabled) {\n\t\tconst struct drm_framebuffer *fb =\n\t\t\trdev->mode_info.crtcs[0]->base.primary->fb;\n\n\t\tmode1 = &rdev->mode_info.crtcs[0]->base.mode;\n\t\tpixel_bytes1 = fb->format->cpp[0];\n\t}\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tif (rdev->mode_info.crtcs[1]->base.enabled) {\n\t\t\tconst struct drm_framebuffer *fb =\n\t\t\t\trdev->mode_info.crtcs[1]->base.primary->fb;\n\n\t\t\tmode2 = &rdev->mode_info.crtcs[1]->base.mode;\n\t\t\tpixel_bytes2 = fb->format->cpp[0];\n\t\t}\n\t}\n\n\tmin_mem_eff.full = dfixed_const_8(0);\n\t \n\tif ((rdev->disp_priority == 2) && ASIC_IS_R300(rdev)) {\n\t\tuint32_t mc_init_misc_lat_timer = RREG32(R300_MC_INIT_MISC_LAT_TIMER);\n\t\tmc_init_misc_lat_timer &= ~(R300_MC_DISP1R_INIT_LAT_MASK << R300_MC_DISP1R_INIT_LAT_SHIFT);\n\t\tmc_init_misc_lat_timer &= ~(R300_MC_DISP0R_INIT_LAT_MASK << R300_MC_DISP0R_INIT_LAT_SHIFT);\n\t\t \n\t\tif (mode2)\n\t\t\tmc_init_misc_lat_timer |= (1 << R300_MC_DISP1R_INIT_LAT_SHIFT);\n\t\tif (mode1)\n\t\t\tmc_init_misc_lat_timer |= (1 << R300_MC_DISP0R_INIT_LAT_SHIFT);\n\t\tWREG32(R300_MC_INIT_MISC_LAT_TIMER, mc_init_misc_lat_timer);\n\t}\n\n\t \n\tsclk_ff = rdev->pm.sclk;\n\tmclk_ff = rdev->pm.mclk;\n\n\ttemp = (rdev->mc.vram_width / 8) * (rdev->mc.vram_is_ddr ? 2 : 1);\n\ttemp_ff.full = dfixed_const(temp);\n\tmem_bw.full = dfixed_mul(mclk_ff, temp_ff);\n\n\tpix_clk.full = 0;\n\tpix_clk2.full = 0;\n\tpeak_disp_bw.full = 0;\n\tif (mode1) {\n\t\ttemp_ff.full = dfixed_const(1000);\n\t\tpix_clk.full = dfixed_const(mode1->clock);  \n\t\tpix_clk.full = dfixed_div(pix_clk, temp_ff);\n\t\ttemp_ff.full = dfixed_const(pixel_bytes1);\n\t\tpeak_disp_bw.full += dfixed_mul(pix_clk, temp_ff);\n\t}\n\tif (mode2) {\n\t\ttemp_ff.full = dfixed_const(1000);\n\t\tpix_clk2.full = dfixed_const(mode2->clock);  \n\t\tpix_clk2.full = dfixed_div(pix_clk2, temp_ff);\n\t\ttemp_ff.full = dfixed_const(pixel_bytes2);\n\t\tpeak_disp_bw.full += dfixed_mul(pix_clk2, temp_ff);\n\t}\n\n\tmem_bw.full = dfixed_mul(mem_bw, min_mem_eff);\n\tif (peak_disp_bw.full >= mem_bw.full) {\n\t\tDRM_ERROR(\"You may not have enough display bandwidth for current mode\\n\"\n\t\t\t  \"If you have flickering problem, try to lower resolution, refresh rate, or color depth\\n\");\n\t}\n\n\t \n\ttemp = RREG32(RADEON_MEM_TIMING_CNTL);\n\tif ((rdev->family == CHIP_RV100) || (rdev->flags & RADEON_IS_IGP)) {  \n\t\tmem_trcd = ((temp >> 2) & 0x3) + 1;\n\t\tmem_trp  = ((temp & 0x3)) + 1;\n\t\tmem_tras = ((temp & 0x70) >> 4) + 1;\n\t} else if (rdev->family == CHIP_R300 ||\n\t\t   rdev->family == CHIP_R350) {  \n\t\tmem_trcd = (temp & 0x7) + 1;\n\t\tmem_trp = ((temp >> 8) & 0x7) + 1;\n\t\tmem_tras = ((temp >> 11) & 0xf) + 4;\n\t} else if (rdev->family == CHIP_RV350 ||\n\t\t   rdev->family == CHIP_RV380) {\n\t\t \n\t\tmem_trcd = (temp & 0x7) + 3;\n\t\tmem_trp = ((temp >> 8) & 0x7) + 3;\n\t\tmem_tras = ((temp >> 11) & 0xf) + 6;\n\t} else if (rdev->family == CHIP_R420 ||\n\t\t   rdev->family == CHIP_R423 ||\n\t\t   rdev->family == CHIP_RV410) {\n\t\t \n\t\tmem_trcd = (temp & 0xf) + 3;\n\t\tif (mem_trcd > 15)\n\t\t\tmem_trcd = 15;\n\t\tmem_trp = ((temp >> 8) & 0xf) + 3;\n\t\tif (mem_trp > 15)\n\t\t\tmem_trp = 15;\n\t\tmem_tras = ((temp >> 12) & 0x1f) + 6;\n\t\tif (mem_tras > 31)\n\t\t\tmem_tras = 31;\n\t} else {  \n\t\tmem_trcd = (temp & 0x7) + 1;\n\t\tmem_trp = ((temp >> 8) & 0x7) + 1;\n\t\tmem_tras = ((temp >> 12) & 0xf) + 4;\n\t}\n\t \n\ttrcd_ff.full = dfixed_const(mem_trcd);\n\ttrp_ff.full = dfixed_const(mem_trp);\n\ttras_ff.full = dfixed_const(mem_tras);\n\n\t \n\ttemp = RREG32(RADEON_MEM_SDRAM_MODE_REG);\n\tdata = (temp & (7 << 20)) >> 20;\n\tif ((rdev->family == CHIP_RV100) || rdev->flags & RADEON_IS_IGP) {\n\t\tif (rdev->family == CHIP_RS480)  \n\t\t\ttcas_ff = memtcas_rs480_ff[data];\n\t\telse\n\t\t\ttcas_ff = memtcas_ff[data];\n\t} else\n\t\ttcas_ff = memtcas2_ff[data];\n\n\tif (rdev->family == CHIP_RS400 ||\n\t    rdev->family == CHIP_RS480) {\n\t\t \n\t\tdata = (temp >> 23) & 0x7;\n\t\tif (data < 5)\n\t\t\ttcas_ff.full += dfixed_const(data);\n\t}\n\n\tif (ASIC_IS_R300(rdev) && !(rdev->flags & RADEON_IS_IGP)) {\n\t\t \n\t\ttemp = RREG32(RADEON_MEM_CNTL);\n\t\tdata = (R300_MEM_NUM_CHANNELS_MASK & temp);\n\t\tif (data == 1) {\n\t\t\tif (R300_MEM_USE_CD_CH_ONLY & temp) {\n\t\t\t\ttemp = RREG32(R300_MC_IND_INDEX);\n\t\t\t\ttemp &= ~R300_MC_IND_ADDR_MASK;\n\t\t\t\ttemp |= R300_MC_READ_CNTL_CD_mcind;\n\t\t\t\tWREG32(R300_MC_IND_INDEX, temp);\n\t\t\t\ttemp = RREG32(R300_MC_IND_DATA);\n\t\t\t\tdata = (R300_MEM_RBS_POSITION_C_MASK & temp);\n\t\t\t} else {\n\t\t\t\ttemp = RREG32(R300_MC_READ_CNTL_AB);\n\t\t\t\tdata = (R300_MEM_RBS_POSITION_A_MASK & temp);\n\t\t\t}\n\t\t} else {\n\t\t\ttemp = RREG32(R300_MC_READ_CNTL_AB);\n\t\t\tdata = (R300_MEM_RBS_POSITION_A_MASK & temp);\n\t\t}\n\t\tif (rdev->family == CHIP_RV410 ||\n\t\t    rdev->family == CHIP_R420 ||\n\t\t    rdev->family == CHIP_R423)\n\t\t\ttrbs_ff = memtrbs_r4xx[data];\n\t\telse\n\t\t\ttrbs_ff = memtrbs[data];\n\t\ttcas_ff.full += trbs_ff.full;\n\t}\n\n\tsclk_eff_ff.full = sclk_ff.full;\n\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tfixed20_12 agpmode_ff;\n\t\tagpmode_ff.full = dfixed_const(radeon_agpmode);\n\t\ttemp_ff.full = dfixed_const_666(16);\n\t\tsclk_eff_ff.full -= dfixed_mul(agpmode_ff, temp_ff);\n\t}\n\t \n\n\tif (ASIC_IS_R300(rdev)) {\n\t\tsclk_delay_ff.full = dfixed_const(250);\n\t} else {\n\t\tif ((rdev->family == CHIP_RV100) ||\n\t\t    rdev->flags & RADEON_IS_IGP) {\n\t\t\tif (rdev->mc.vram_is_ddr)\n\t\t\t\tsclk_delay_ff.full = dfixed_const(41);\n\t\t\telse\n\t\t\t\tsclk_delay_ff.full = dfixed_const(33);\n\t\t} else {\n\t\t\tif (rdev->mc.vram_width == 128)\n\t\t\t\tsclk_delay_ff.full = dfixed_const(57);\n\t\t\telse\n\t\t\t\tsclk_delay_ff.full = dfixed_const(41);\n\t\t}\n\t}\n\n\tmc_latency_sclk.full = dfixed_div(sclk_delay_ff, sclk_eff_ff);\n\n\tif (rdev->mc.vram_is_ddr) {\n\t\tif (rdev->mc.vram_width == 32) {\n\t\t\tk1.full = dfixed_const(40);\n\t\t\tc  = 3;\n\t\t} else {\n\t\t\tk1.full = dfixed_const(20);\n\t\t\tc  = 1;\n\t\t}\n\t} else {\n\t\tk1.full = dfixed_const(40);\n\t\tc  = 3;\n\t}\n\n\ttemp_ff.full = dfixed_const(2);\n\tmc_latency_mclk.full = dfixed_mul(trcd_ff, temp_ff);\n\ttemp_ff.full = dfixed_const(c);\n\tmc_latency_mclk.full += dfixed_mul(tcas_ff, temp_ff);\n\ttemp_ff.full = dfixed_const(4);\n\tmc_latency_mclk.full += dfixed_mul(tras_ff, temp_ff);\n\tmc_latency_mclk.full += dfixed_mul(trp_ff, temp_ff);\n\tmc_latency_mclk.full += k1.full;\n\n\tmc_latency_mclk.full = dfixed_div(mc_latency_mclk, mclk_ff);\n\tmc_latency_mclk.full += dfixed_div(temp_ff, sclk_eff_ff);\n\n\t \n\ttemp_ff.full = dfixed_const((2 * (cur_size - (rdev->mc.vram_is_ddr + 1))));\n\ttemp_ff.full += trcd_ff.full;\n\tif (temp_ff.full < tras_ff.full)\n\t\ttemp_ff.full = tras_ff.full;\n\tcur_latency_mclk.full = dfixed_div(temp_ff, mclk_ff);\n\n\ttemp_ff.full = dfixed_const(cur_size);\n\tcur_latency_sclk.full = dfixed_div(temp_ff, sclk_eff_ff);\n\t \n\tdisp_latency_overhead.full = dfixed_const(8);\n\tdisp_latency_overhead.full = dfixed_div(disp_latency_overhead, sclk_ff);\n\tmc_latency_mclk.full += disp_latency_overhead.full + cur_latency_mclk.full;\n\tmc_latency_sclk.full += disp_latency_overhead.full + cur_latency_sclk.full;\n\n\tif (mc_latency_mclk.full > mc_latency_sclk.full)\n\t\tdisp_latency.full = mc_latency_mclk.full;\n\telse\n\t\tdisp_latency.full = mc_latency_sclk.full;\n\n\t \n\tif (ASIC_IS_RV100(rdev))\n\t\tmax_stop_req = 0x5c;\n\telse\n\t\tmax_stop_req = 0x7c;\n\n\tif (mode1) {\n\t\t \n\t\tstop_req = mode1->hdisplay * pixel_bytes1 / 16;\n\n\t\tif (stop_req > max_stop_req)\n\t\t\tstop_req = max_stop_req;\n\n\t\t \n\t\ttemp_ff.full = dfixed_const((16/pixel_bytes1));\n\t\tdisp_drain_rate.full = dfixed_div(pix_clk, temp_ff);\n\n\t\t \n\t\tcrit_point_ff.full = dfixed_mul(disp_drain_rate, disp_latency);\n\t\tcrit_point_ff.full += dfixed_const_half(0);\n\n\t\tcritical_point = dfixed_trunc(crit_point_ff);\n\n\t\tif (rdev->disp_priority == 2) {\n\t\t\tcritical_point = 0;\n\t\t}\n\n\t\t \n\t\tif (max_stop_req - critical_point < 4)\n\t\t\tcritical_point = 0;\n\n\t\tif (critical_point == 0 && mode2 && rdev->family == CHIP_R300) {\n\t\t\t \n\t\t\tcritical_point = 0x10;\n\t\t}\n\n\t\ttemp = RREG32(RADEON_GRPH_BUFFER_CNTL);\n\t\ttemp &= ~(RADEON_GRPH_STOP_REQ_MASK);\n\t\ttemp |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);\n\t\ttemp &= ~(RADEON_GRPH_START_REQ_MASK);\n\t\tif ((rdev->family == CHIP_R350) &&\n\t\t    (stop_req > 0x15)) {\n\t\t\tstop_req -= 0x10;\n\t\t}\n\t\ttemp |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);\n\t\ttemp |= RADEON_GRPH_BUFFER_SIZE;\n\t\ttemp &= ~(RADEON_GRPH_CRITICAL_CNTL   |\n\t\t\t  RADEON_GRPH_CRITICAL_AT_SOF |\n\t\t\t  RADEON_GRPH_STOP_CNTL);\n\t\t \n\t\tWREG32(RADEON_GRPH_BUFFER_CNTL, ((temp & ~RADEON_GRPH_CRITICAL_POINT_MASK) |\n\t\t\t\t\t\t       (critical_point << RADEON_GRPH_CRITICAL_POINT_SHIFT)));\n\n#if 0\n\t\tif ((rdev->family == CHIP_RS400) ||\n\t\t    (rdev->family == CHIP_RS480)) {\n\t\t\t \n\t\t\ttemp = RREG32(RS400_DISP1_REG_CNTL);\n\t\t\ttemp &= ~(RS400_DISP1_START_REQ_LEVEL_MASK |\n\t\t\t\t  RS400_DISP1_STOP_REQ_LEVEL_MASK);\n\t\t\tWREG32(RS400_DISP1_REQ_CNTL1, (temp |\n\t\t\t\t\t\t       (critical_point << RS400_DISP1_START_REQ_LEVEL_SHIFT) |\n\t\t\t\t\t\t       (critical_point << RS400_DISP1_STOP_REQ_LEVEL_SHIFT)));\n\t\t\ttemp = RREG32(RS400_DMIF_MEM_CNTL1);\n\t\t\ttemp &= ~(RS400_DISP1_CRITICAL_POINT_START_MASK |\n\t\t\t\t  RS400_DISP1_CRITICAL_POINT_STOP_MASK);\n\t\t\tWREG32(RS400_DMIF_MEM_CNTL1, (temp |\n\t\t\t\t\t\t      (critical_point << RS400_DISP1_CRITICAL_POINT_START_SHIFT) |\n\t\t\t\t\t\t      (critical_point << RS400_DISP1_CRITICAL_POINT_STOP_SHIFT)));\n\t\t}\n#endif\n\n\t\tDRM_DEBUG_KMS(\"GRPH_BUFFER_CNTL from to %x\\n\",\n\t\t\t   \n\t\t\t  (unsigned int)RREG32(RADEON_GRPH_BUFFER_CNTL));\n\t}\n\n\tif (mode2) {\n\t\tu32 grph2_cntl;\n\t\tstop_req = mode2->hdisplay * pixel_bytes2 / 16;\n\n\t\tif (stop_req > max_stop_req)\n\t\t\tstop_req = max_stop_req;\n\n\t\t \n\t\ttemp_ff.full = dfixed_const((16/pixel_bytes2));\n\t\tdisp_drain_rate2.full = dfixed_div(pix_clk2, temp_ff);\n\n\t\tgrph2_cntl = RREG32(RADEON_GRPH2_BUFFER_CNTL);\n\t\tgrph2_cntl &= ~(RADEON_GRPH_STOP_REQ_MASK);\n\t\tgrph2_cntl |= (stop_req << RADEON_GRPH_STOP_REQ_SHIFT);\n\t\tgrph2_cntl &= ~(RADEON_GRPH_START_REQ_MASK);\n\t\tif ((rdev->family == CHIP_R350) &&\n\t\t    (stop_req > 0x15)) {\n\t\t\tstop_req -= 0x10;\n\t\t}\n\t\tgrph2_cntl |= (stop_req << RADEON_GRPH_START_REQ_SHIFT);\n\t\tgrph2_cntl |= RADEON_GRPH_BUFFER_SIZE;\n\t\tgrph2_cntl &= ~(RADEON_GRPH_CRITICAL_CNTL   |\n\t\t\t  RADEON_GRPH_CRITICAL_AT_SOF |\n\t\t\t  RADEON_GRPH_STOP_CNTL);\n\n\t\tif ((rdev->family == CHIP_RS100) ||\n\t\t    (rdev->family == CHIP_RS200))\n\t\t\tcritical_point2 = 0;\n\t\telse {\n\t\t\ttemp = (rdev->mc.vram_width * rdev->mc.vram_is_ddr + 1)/128;\n\t\t\ttemp_ff.full = dfixed_const(temp);\n\t\t\ttemp_ff.full = dfixed_mul(mclk_ff, temp_ff);\n\t\t\tif (sclk_ff.full < temp_ff.full)\n\t\t\t\ttemp_ff.full = sclk_ff.full;\n\n\t\t\tread_return_rate.full = temp_ff.full;\n\n\t\t\tif (mode1) {\n\t\t\t\ttemp_ff.full = read_return_rate.full - disp_drain_rate.full;\n\t\t\t\ttime_disp1_drop_priority.full = dfixed_div(crit_point_ff, temp_ff);\n\t\t\t} else {\n\t\t\t\ttime_disp1_drop_priority.full = 0;\n\t\t\t}\n\t\t\tcrit_point_ff.full = disp_latency.full + time_disp1_drop_priority.full + disp_latency.full;\n\t\t\tcrit_point_ff.full = dfixed_mul(crit_point_ff, disp_drain_rate2);\n\t\t\tcrit_point_ff.full += dfixed_const_half(0);\n\n\t\t\tcritical_point2 = dfixed_trunc(crit_point_ff);\n\n\t\t\tif (rdev->disp_priority == 2) {\n\t\t\t\tcritical_point2 = 0;\n\t\t\t}\n\n\t\t\tif (max_stop_req - critical_point2 < 4)\n\t\t\t\tcritical_point2 = 0;\n\n\t\t}\n\n\t\tif (critical_point2 == 0 && rdev->family == CHIP_R300) {\n\t\t\t \n\t\t\tcritical_point2 = 0x10;\n\t\t}\n\n\t\tWREG32(RADEON_GRPH2_BUFFER_CNTL, ((grph2_cntl & ~RADEON_GRPH_CRITICAL_POINT_MASK) |\n\t\t\t\t\t\t  (critical_point2 << RADEON_GRPH_CRITICAL_POINT_SHIFT)));\n\n\t\tif ((rdev->family == CHIP_RS400) ||\n\t\t    (rdev->family == CHIP_RS480)) {\n#if 0\n\t\t\t \n\t\t\ttemp = RREG32(RS400_DISP2_REQ_CNTL1);\n\t\t\ttemp &= ~(RS400_DISP2_START_REQ_LEVEL_MASK |\n\t\t\t\t  RS400_DISP2_STOP_REQ_LEVEL_MASK);\n\t\t\tWREG32(RS400_DISP2_REQ_CNTL1, (temp |\n\t\t\t\t\t\t       (critical_point2 << RS400_DISP1_START_REQ_LEVEL_SHIFT) |\n\t\t\t\t\t\t       (critical_point2 << RS400_DISP1_STOP_REQ_LEVEL_SHIFT)));\n\t\t\ttemp = RREG32(RS400_DISP2_REQ_CNTL2);\n\t\t\ttemp &= ~(RS400_DISP2_CRITICAL_POINT_START_MASK |\n\t\t\t\t  RS400_DISP2_CRITICAL_POINT_STOP_MASK);\n\t\t\tWREG32(RS400_DISP2_REQ_CNTL2, (temp |\n\t\t\t\t\t\t       (critical_point2 << RS400_DISP2_CRITICAL_POINT_START_SHIFT) |\n\t\t\t\t\t\t       (critical_point2 << RS400_DISP2_CRITICAL_POINT_STOP_SHIFT)));\n#endif\n\t\t\tWREG32(RS400_DISP2_REQ_CNTL1, 0x105DC1CC);\n\t\t\tWREG32(RS400_DISP2_REQ_CNTL2, 0x2749D000);\n\t\t\tWREG32(RS400_DMIF_MEM_CNTL1,  0x29CA71DC);\n\t\t\tWREG32(RS400_DISP1_REQ_CNTL1, 0x28FBC3AC);\n\t\t}\n\n\t\tDRM_DEBUG_KMS(\"GRPH2_BUFFER_CNTL from to %x\\n\",\n\t\t\t  (unsigned int)RREG32(RADEON_GRPH2_BUFFER_CNTL));\n\t}\n\n\t \n\tif (mode1)\n\t    rdev->mode_info.crtcs[0]->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode1->crtc_hdisplay);\n\n\tif (mode2)\n\t    rdev->mode_info.crtcs[1]->lb_vblank_lead_lines = DIV_ROUND_UP(lb_size, mode2->crtc_hdisplay);\n}\n\nint r100_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to get scratch reg (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ring_lock(rdev, ring, 2);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring (%d).\\n\", r);\n\t\tradeon_scratch_free(rdev, scratch);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET0(scratch, 0));\n\tradeon_ring_write(ring, 0xDEADBEEF);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF) {\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ring test succeeded in %d usecs\\n\", i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ring test failed (scratch(0x%04X)=0x%08X)\\n\",\n\t\t\t  scratch, tmp);\n\t\tr = -EINVAL;\n\t}\n\tradeon_scratch_free(rdev, scratch);\n\treturn r;\n}\n\nvoid r100_ring_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[RADEON_RING_TYPE_GFX_INDEX];\n\n\tif (ring->rptr_save_reg) {\n\t\tu32 next_rptr = ring->wptr + 2 + 3;\n\t\tradeon_ring_write(ring, PACKET0(ring->rptr_save_reg, 0));\n\t\tradeon_ring_write(ring, next_rptr);\n\t}\n\n\tradeon_ring_write(ring, PACKET0(RADEON_CP_IB_BASE, 1));\n\tradeon_ring_write(ring, ib->gpu_addr);\n\tradeon_ring_write(ring, ib->length_dw);\n}\n\nint r100_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tstruct radeon_ib ib;\n\tuint32_t scratch;\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tr = radeon_scratch_get(rdev, &scratch);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get scratch reg (%d).\\n\", r);\n\t\treturn r;\n\t}\n\tWREG32(scratch, 0xCAFEDEAD);\n\tr = radeon_ib_get(rdev, RADEON_RING_TYPE_GFX_INDEX, &ib, NULL, 256);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get ib (%d).\\n\", r);\n\t\tgoto free_scratch;\n\t}\n\tib.ptr[0] = PACKET0(scratch, 0);\n\tib.ptr[1] = 0xDEADBEEF;\n\tib.ptr[2] = PACKET2(0);\n\tib.ptr[3] = PACKET2(0);\n\tib.ptr[4] = PACKET2(0);\n\tib.ptr[5] = PACKET2(0);\n\tib.ptr[6] = PACKET2(0);\n\tib.ptr[7] = PACKET2(0);\n\tib.length_dw = 8;\n\tr = radeon_ib_schedule(rdev, &ib, NULL, false);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to schedule ib (%d).\\n\", r);\n\t\tgoto free_ib;\n\t}\n\tr = radeon_fence_wait_timeout(ib.fence, false, usecs_to_jiffies(\n\t\tRADEON_USEC_IB_TEST_TIMEOUT));\n\tif (r < 0) {\n\t\tDRM_ERROR(\"radeon: fence wait failed (%d).\\n\", r);\n\t\tgoto free_ib;\n\t} else if (r == 0) {\n\t\tDRM_ERROR(\"radeon: fence wait timed out.\\n\");\n\t\tr = -ETIMEDOUT;\n\t\tgoto free_ib;\n\t}\n\tr = 0;\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(scratch);\n\t\tif (tmp == 0xDEADBEEF) {\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ib test succeeded in %u usecs\\n\", i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ib test failed (scratch(0x%04X)=0x%08X)\\n\",\n\t\t\t  scratch, tmp);\n\t\tr = -EINVAL;\n\t}\nfree_ib:\n\tradeon_ib_free(rdev, &ib);\nfree_scratch:\n\tradeon_scratch_free(rdev, scratch);\n\treturn r;\n}\n\nvoid r100_mc_stop(struct radeon_device *rdev, struct r100_mc_save *save)\n{\n\t \n\trdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready = false;\n\tWREG32(R_000740_CP_CSQ_CNTL, 0);\n\n\t \n\tsave->GENMO_WT = RREG8(R_0003C2_GENMO_WT);\n\tsave->CRTC_EXT_CNTL = RREG32(R_000054_CRTC_EXT_CNTL);\n\tsave->CRTC_GEN_CNTL = RREG32(R_000050_CRTC_GEN_CNTL);\n\tsave->CUR_OFFSET = RREG32(R_000260_CUR_OFFSET);\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tsave->CRTC2_GEN_CNTL = RREG32(R_0003F8_CRTC2_GEN_CNTL);\n\t\tsave->CUR2_OFFSET = RREG32(R_000360_CUR2_OFFSET);\n\t}\n\n\t \n\tWREG8(R_0003C2_GENMO_WT, C_0003C2_VGA_RAM_EN & save->GENMO_WT);\n\t \n\tWREG32(R_000260_CUR_OFFSET, save->CUR_OFFSET | S_000260_CUR_LOCK(1));\n\tWREG32(R_000054_CRTC_EXT_CNTL, save->CRTC_EXT_CNTL |\n\t\t\t\t\tS_000054_CRTC_DISPLAY_DIS(1));\n\tWREG32(R_000050_CRTC_GEN_CNTL,\n\t\t\t(C_000050_CRTC_CUR_EN & save->CRTC_GEN_CNTL) |\n\t\t\tS_000050_CRTC_DISP_REQ_EN_B(1));\n\tWREG32(R_000420_OV0_SCALE_CNTL,\n\t\tC_000420_OV0_OVERLAY_EN & RREG32(R_000420_OV0_SCALE_CNTL));\n\tWREG32(R_000260_CUR_OFFSET, C_000260_CUR_LOCK & save->CUR_OFFSET);\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tWREG32(R_000360_CUR2_OFFSET, save->CUR2_OFFSET |\n\t\t\t\t\t\tS_000360_CUR2_LOCK(1));\n\t\tWREG32(R_0003F8_CRTC2_GEN_CNTL,\n\t\t\t(C_0003F8_CRTC2_CUR_EN & save->CRTC2_GEN_CNTL) |\n\t\t\tS_0003F8_CRTC2_DISPLAY_DIS(1) |\n\t\t\tS_0003F8_CRTC2_DISP_REQ_EN_B(1));\n\t\tWREG32(R_000360_CUR2_OFFSET,\n\t\t\tC_000360_CUR2_LOCK & save->CUR2_OFFSET);\n\t}\n}\n\nvoid r100_mc_resume(struct radeon_device *rdev, struct r100_mc_save *save)\n{\n\t \n\tWREG32(R_00023C_DISPLAY_BASE_ADDR, rdev->mc.vram_start);\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tWREG32(R_00033C_CRTC2_DISPLAY_BASE_ADDR, rdev->mc.vram_start);\n\t}\n\t \n\tWREG8(R_0003C2_GENMO_WT, save->GENMO_WT);\n\tWREG32(R_000054_CRTC_EXT_CNTL, save->CRTC_EXT_CNTL);\n\tWREG32(R_000050_CRTC_GEN_CNTL, save->CRTC_GEN_CNTL);\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tWREG32(R_0003F8_CRTC2_GEN_CNTL, save->CRTC2_GEN_CNTL);\n\t}\n}\n\nvoid r100_vga_render_disable(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG8(R_0003C2_GENMO_WT);\n\tWREG8(R_0003C2_GENMO_WT, C_0003C2_VGA_RAM_EN & tmp);\n}\n\nstatic void r100_mc_program(struct radeon_device *rdev)\n{\n\tstruct r100_mc_save save;\n\n\t \n\tr100_mc_stop(rdev, &save);\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tWREG32(R_00014C_MC_AGP_LOCATION,\n\t\t\tS_00014C_MC_AGP_START(rdev->mc.gtt_start >> 16) |\n\t\t\tS_00014C_MC_AGP_TOP(rdev->mc.gtt_end >> 16));\n\t\tWREG32(R_000170_AGP_BASE, lower_32_bits(rdev->mc.agp_base));\n\t\tif (rdev->family > CHIP_RV200)\n\t\t\tWREG32(R_00015C_AGP_BASE_2,\n\t\t\t\tupper_32_bits(rdev->mc.agp_base) & 0xff);\n\t} else {\n\t\tWREG32(R_00014C_MC_AGP_LOCATION, 0x0FFFFFFF);\n\t\tWREG32(R_000170_AGP_BASE, 0);\n\t\tif (rdev->family > CHIP_RV200)\n\t\t\tWREG32(R_00015C_AGP_BASE_2, 0);\n\t}\n\t \n\tif (r100_mc_wait_for_idle(rdev))\n\t\tdev_warn(rdev->dev, \"Wait for MC idle timeout.\\n\");\n\t \n\tWREG32(R_000148_MC_FB_LOCATION,\n\t\tS_000148_MC_FB_START(rdev->mc.vram_start >> 16) |\n\t\tS_000148_MC_FB_TOP(rdev->mc.vram_end >> 16));\n\tr100_mc_resume(rdev, &save);\n}\n\nstatic void r100_clock_startup(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\tif (radeon_dynclks != -1 && radeon_dynclks)\n\t\tradeon_legacy_set_clock_gating(rdev, 1);\n\t \n\ttmp = RREG32_PLL(R_00000D_SCLK_CNTL);\n\ttmp |= S_00000D_FORCE_CP(1) | S_00000D_FORCE_VIP(1);\n\tif ((rdev->family == CHIP_RV250) || (rdev->family == CHIP_RV280))\n\t\ttmp |= S_00000D_FORCE_DISP1(1) | S_00000D_FORCE_DISP2(1);\n\tWREG32_PLL(R_00000D_SCLK_CNTL, tmp);\n}\n\nstatic int r100_startup(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tr100_set_common_regs(rdev);\n\t \n\tr100_mc_program(rdev);\n\t \n\tr100_clock_startup(rdev);\n\t \n\tr100_enable_bm(rdev);\n\tif (rdev->flags & RADEON_IS_PCI) {\n\t\tr = r100_pci_gart_enable(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr100_irq_set(rdev);\n\trdev->config.r100.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\n\t \n\tr = r100_cp_init(rdev, 1024 * 1024);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint r100_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tif (rdev->flags & RADEON_IS_PCI)\n\t\tr100_pci_gart_disable(rdev);\n\t \n\tr100_clock_startup(rdev);\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev, \"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tradeon_combios_asic_init(rdev->ddev);\n\t \n\tr100_clock_startup(rdev);\n\t \n\tradeon_surface_init(rdev);\n\n\trdev->accel_working = true;\n\tr = r100_startup(rdev);\n\tif (r) {\n\t\trdev->accel_working = false;\n\t}\n\treturn r;\n}\n\nint r100_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tr100_cp_disable(rdev);\n\tradeon_wb_disable(rdev);\n\tr100_irq_disable(rdev);\n\tif (rdev->flags & RADEON_IS_PCI)\n\t\tr100_pci_gart_disable(rdev);\n\treturn 0;\n}\n\nvoid r100_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tr100_cp_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_gem_fini(rdev);\n\tif (rdev->flags & RADEON_IS_PCI)\n\t\tr100_pci_gart_fini(rdev);\n\tradeon_agp_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\n \nvoid r100_restore_sanity(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(RADEON_CP_CSQ_CNTL);\n\tif (tmp) {\n\t\tWREG32(RADEON_CP_CSQ_CNTL, 0);\n\t}\n\ttmp = RREG32(RADEON_CP_RB_CNTL);\n\tif (tmp) {\n\t\tWREG32(RADEON_CP_RB_CNTL, 0);\n\t}\n\ttmp = RREG32(RADEON_SCRATCH_UMSK);\n\tif (tmp) {\n\t\tWREG32(RADEON_SCRATCH_UMSK, 0);\n\t}\n}\n\nint r100_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tr100_debugfs_mc_info_init(rdev);\n\t \n\tr100_vga_render_disable(rdev);\n\t \n\tradeon_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\tr100_restore_sanity(rdev);\n\t \n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting combios for RS400/RS480 GPU\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tr = radeon_combios_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev,\n\t\t\t\"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tif (radeon_boot_test_post_card(rdev) == false)\n\t\treturn -EINVAL;\n\t \n\tr100_errata(rdev);\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr = radeon_agp_init(rdev);\n\t\tif (r) {\n\t\t\tradeon_agp_disable(rdev);\n\t\t}\n\t}\n\t \n\tr100_mc_init(rdev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\tif (rdev->flags & RADEON_IS_PCI) {\n\t\tr = r100_pci_gart_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tr100_set_safe_registers(rdev);\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->accel_working = true;\n\tr = r100_startup(rdev);\n\tif (r) {\n\t\t \n\t\tdev_err(rdev->dev, \"Disabling GPU acceleration\\n\");\n\t\tr100_cp_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\tif (rdev->flags & RADEON_IS_PCI)\n\t\t\tr100_pci_gart_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\treturn 0;\n}\n\nuint32_t r100_mm_rreg_slow(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t ret;\n\n\tspin_lock_irqsave(&rdev->mmio_idx_lock, flags);\n\twritel(reg, ((void __iomem *)rdev->rmmio) + RADEON_MM_INDEX);\n\tret = readl(((void __iomem *)rdev->rmmio) + RADEON_MM_DATA);\n\tspin_unlock_irqrestore(&rdev->mmio_idx_lock, flags);\n\treturn ret;\n}\n\nvoid r100_mm_wreg_slow(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->mmio_idx_lock, flags);\n\twritel(reg, ((void __iomem *)rdev->rmmio) + RADEON_MM_INDEX);\n\twritel(v, ((void __iomem *)rdev->rmmio) + RADEON_MM_DATA);\n\tspin_unlock_irqrestore(&rdev->mmio_idx_lock, flags);\n}\n\nu32 r100_io_rreg(struct radeon_device *rdev, u32 reg)\n{\n\tif (reg < rdev->rio_mem_size)\n\t\treturn ioread32(rdev->rio_mem + reg);\n\telse {\n\t\tiowrite32(reg, rdev->rio_mem + RADEON_MM_INDEX);\n\t\treturn ioread32(rdev->rio_mem + RADEON_MM_DATA);\n\t}\n}\n\nvoid r100_io_wreg(struct radeon_device *rdev, u32 reg, u32 v)\n{\n\tif (reg < rdev->rio_mem_size)\n\t\tiowrite32(v, rdev->rio_mem + reg);\n\telse {\n\t\tiowrite32(reg, rdev->rio_mem + RADEON_MM_INDEX);\n\t\tiowrite32(v, rdev->rio_mem + RADEON_MM_DATA);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}