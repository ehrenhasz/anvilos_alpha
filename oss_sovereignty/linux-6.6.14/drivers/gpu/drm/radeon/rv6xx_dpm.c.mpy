{
  "module_name": "rv6xx_dpm.c",
  "hash_id": "20d927be9e58701175897c025a3a6ae658720b629970064de932624a0ce3a3ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rv6xx_dpm.c",
  "human_readable_source": " \n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"rv6xxd.h\"\n#include \"r600_dpm.h\"\n#include \"rv6xx_dpm.h\"\n#include \"atom.h\"\n#include <linux/seq_file.h>\n\nstatic u32 rv6xx_scale_count_given_unit(struct radeon_device *rdev,\n\t\t\t\t\tu32 unscaled_count, u32 unit);\n\nstatic struct rv6xx_ps *rv6xx_get_ps(struct radeon_ps *rps)\n{\n\tstruct rv6xx_ps *ps = rps->ps_priv;\n\n\treturn ps;\n}\n\nstatic struct rv6xx_power_info *rv6xx_get_pi(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rdev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic void rv6xx_force_pcie_gen1(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint i;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\ttmp &= LC_GEN2_EN;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\ttmp |= LC_INITIATE_LINK_SPEED_CHANGE;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\tif (!(RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & LC_CURRENT_DATA_RATE))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\ttmp &= ~LC_INITIATE_LINK_SPEED_CHANGE;\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n}\n\nstatic void rv6xx_enable_pcie_gen2_support(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL);\n\n\tif ((tmp & LC_OTHER_SIDE_EVER_SENT_GEN2) &&\n\t    (tmp & LC_OTHER_SIDE_SUPPORTS_GEN2)) {\n\t\ttmp |= LC_GEN2_EN;\n\t\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n\t}\n}\n\nstatic void rv6xx_enable_bif_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t       bool enable)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & ~LC_HW_VOLTAGE_IF_CONTROL_MASK;\n\tif (enable)\n\t\ttmp |= LC_HW_VOLTAGE_IF_CONTROL(1);\n\telse\n\t\ttmp |= LC_HW_VOLTAGE_IF_CONTROL(0);\n\tWREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL, tmp);\n}\n\nstatic void rv6xx_enable_l0s(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L0S_INACTIVITY_MASK;\n\ttmp |= LC_L0S_INACTIVITY(3);\n\tWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\n}\n\nstatic void rv6xx_enable_l1(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL);\n\ttmp &= ~LC_L1_INACTIVITY_MASK;\n\ttmp |= LC_L1_INACTIVITY(4);\n\ttmp &= ~LC_PMI_TO_L1_DIS;\n\ttmp &= ~LC_ASPM_TO_L1_DIS;\n\tWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\n}\n\nstatic void rv6xx_enable_pll_sleep_in_l1(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32_PCIE_PORT(PCIE_LC_CNTL) & ~LC_L1_INACTIVITY_MASK;\n\ttmp |= LC_L1_INACTIVITY(8);\n\tWREG32_PCIE_PORT(PCIE_LC_CNTL, tmp);\n\n\t \n\ttmp = RREG32_PCIE(PCIE_P_CNTL);\n\ttmp |= P_PLL_PWRDN_IN_L1L23;\n\ttmp &= ~P_PLL_BUF_PDNB;\n\ttmp &= ~P_PLL_PDNB;\n\ttmp |= P_ALLOW_PRX_FRONTEND_SHUTOFF;\n\tWREG32_PCIE(PCIE_P_CNTL, tmp);\n}\n\nstatic int rv6xx_convert_clock_to_stepping(struct radeon_device *rdev,\n\t\t\t\t\t   u32 clock, struct rv6xx_sclk_stepping *step)\n{\n\tint ret;\n\tstruct atom_clock_dividers dividers;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dividers.enable_post_div)\n\t\tstep->post_divider = 2 + (dividers.post_div & 0xF) + (dividers.post_div >> 4);\n\telse\n\t\tstep->post_divider = 1;\n\n\tstep->vco_frequency = clock * step->post_divider;\n\n\treturn 0;\n}\n\nstatic void rv6xx_output_stepping(struct radeon_device *rdev,\n\t\t\t\t  u32 step_index, struct rv6xx_sclk_stepping *step)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tu32 ref_clk = rdev->clock.spll.reference_freq;\n\tu32 fb_divider;\n\tu32 spll_step_count = rv6xx_scale_count_given_unit(rdev,\n\t\t\t\t\t\t\t   R600_SPLLSTEPTIME_DFLT *\n\t\t\t\t\t\t\t   pi->spll_ref_div,\n\t\t\t\t\t\t\t   R600_SPLLSTEPUNIT_DFLT);\n\n\tr600_engine_clock_entry_enable(rdev, step_index, true);\n\tr600_engine_clock_entry_enable_pulse_skipping(rdev, step_index, false);\n\n\tif (step->post_divider == 1)\n\t\tr600_engine_clock_entry_enable_post_divider(rdev, step_index, false);\n\telse {\n\t\tu32 lo_len = (step->post_divider - 2) / 2;\n\t\tu32 hi_len = step->post_divider - 2 - lo_len;\n\n\t\tr600_engine_clock_entry_enable_post_divider(rdev, step_index, true);\n\t\tr600_engine_clock_entry_set_post_divider(rdev, step_index, (hi_len << 4) | lo_len);\n\t}\n\n\tfb_divider = ((step->vco_frequency * pi->spll_ref_div) / ref_clk) >>\n\t\tpi->fb_div_scale;\n\n\tr600_engine_clock_entry_set_reference_divider(rdev, step_index,\n\t\t\t\t\t\t      pi->spll_ref_div - 1);\n\tr600_engine_clock_entry_set_feedback_divider(rdev, step_index, fb_divider);\n\tr600_engine_clock_entry_set_step_time(rdev, step_index, spll_step_count);\n\n}\n\nstatic struct rv6xx_sclk_stepping rv6xx_next_vco_step(struct radeon_device *rdev,\n\t\t\t\t\t\t      struct rv6xx_sclk_stepping *cur,\n\t\t\t\t\t\t      bool increasing_vco, u32 step_size)\n{\n\tstruct rv6xx_sclk_stepping next;\n\n\tnext.post_divider = cur->post_divider;\n\n\tif (increasing_vco)\n\t\tnext.vco_frequency = (cur->vco_frequency * (100 + step_size)) / 100;\n\telse\n\t\tnext.vco_frequency = (cur->vco_frequency * 100 + 99 + step_size) / (100 + step_size);\n\n\treturn next;\n}\n\nstatic bool rv6xx_can_step_post_div(struct radeon_device *rdev,\n\t\t\t\t    struct rv6xx_sclk_stepping *cur,\n\t\t\t\t    struct rv6xx_sclk_stepping *target)\n{\n\treturn (cur->post_divider > target->post_divider) &&\n\t\t((cur->vco_frequency * target->post_divider) <=\n\t\t (target->vco_frequency * (cur->post_divider - 1)));\n}\n\nstatic struct rv6xx_sclk_stepping rv6xx_next_post_div_step(struct radeon_device *rdev,\n\t\t\t\t\t\t\t   struct rv6xx_sclk_stepping *cur,\n\t\t\t\t\t\t\t   struct rv6xx_sclk_stepping *target)\n{\n\tstruct rv6xx_sclk_stepping next = *cur;\n\n\twhile (rv6xx_can_step_post_div(rdev, &next, target))\n\t\tnext.post_divider--;\n\n\treturn next;\n}\n\nstatic bool rv6xx_reached_stepping_target(struct radeon_device *rdev,\n\t\t\t\t\t  struct rv6xx_sclk_stepping *cur,\n\t\t\t\t\t  struct rv6xx_sclk_stepping *target,\n\t\t\t\t\t  bool increasing_vco)\n{\n\treturn (increasing_vco && (cur->vco_frequency >= target->vco_frequency)) ||\n\t\t(!increasing_vco && (cur->vco_frequency <= target->vco_frequency));\n}\n\nstatic void rv6xx_generate_steps(struct radeon_device *rdev,\n\t\t\t\t u32 low, u32 high,\n\t\t\t\t u32 start_index, u8 *end_index)\n{\n\tstruct rv6xx_sclk_stepping cur;\n\tstruct rv6xx_sclk_stepping target;\n\tbool increasing_vco;\n\tu32 step_index = start_index;\n\n\trv6xx_convert_clock_to_stepping(rdev, low, &cur);\n\trv6xx_convert_clock_to_stepping(rdev, high, &target);\n\n\trv6xx_output_stepping(rdev, step_index++, &cur);\n\n\tincreasing_vco = (target.vco_frequency >= cur.vco_frequency);\n\n\tif (target.post_divider > cur.post_divider)\n\t\tcur.post_divider = target.post_divider;\n\n\twhile (1) {\n\t\tstruct rv6xx_sclk_stepping next;\n\n\t\tif (rv6xx_can_step_post_div(rdev, &cur, &target))\n\t\t\tnext = rv6xx_next_post_div_step(rdev, &cur, &target);\n\t\telse\n\t\t\tnext = rv6xx_next_vco_step(rdev, &cur, increasing_vco, R600_VCOSTEPPCT_DFLT);\n\n\t\tif (rv6xx_reached_stepping_target(rdev, &next, &target, increasing_vco)) {\n\t\t\tstruct rv6xx_sclk_stepping tiny =\n\t\t\t\trv6xx_next_vco_step(rdev, &target, !increasing_vco, R600_ENDINGVCOSTEPPCT_DFLT);\n\t\t\ttiny.post_divider = next.post_divider;\n\n\t\t\tif (!rv6xx_reached_stepping_target(rdev, &tiny, &cur, !increasing_vco))\n\t\t\t\trv6xx_output_stepping(rdev, step_index++, &tiny);\n\n\t\t\tif ((next.post_divider != target.post_divider) &&\n\t\t\t    (next.vco_frequency != target.vco_frequency)) {\n\t\t\t\tstruct rv6xx_sclk_stepping final_vco;\n\n\t\t\t\tfinal_vco.vco_frequency = target.vco_frequency;\n\t\t\t\tfinal_vco.post_divider = next.post_divider;\n\n\t\t\t\trv6xx_output_stepping(rdev, step_index++, &final_vco);\n\t\t\t}\n\n\t\t\trv6xx_output_stepping(rdev, step_index++, &target);\n\t\t\tbreak;\n\t\t} else\n\t\t\trv6xx_output_stepping(rdev, step_index++, &next);\n\n\t\tcur = next;\n\t}\n\n\t*end_index = (u8)step_index - 1;\n\n}\n\nstatic void rv6xx_generate_single_step(struct radeon_device *rdev,\n\t\t\t\t       u32 clock, u32 index)\n{\n\tstruct rv6xx_sclk_stepping step;\n\n\trv6xx_convert_clock_to_stepping(rdev, clock, &step);\n\trv6xx_output_stepping(rdev, index, &step);\n}\n\nstatic void rv6xx_invalidate_intermediate_steps_range(struct radeon_device *rdev,\n\t\t\t\t\t\t      u32 start_index, u32 end_index)\n{\n\tu32 step_index;\n\n\tfor (step_index = start_index + 1; step_index < end_index; step_index++)\n\t\tr600_engine_clock_entry_enable(rdev, step_index, false);\n}\n\nstatic void rv6xx_set_engine_spread_spectrum_clk_s(struct radeon_device *rdev,\n\t\t\t\t\t\t   u32 index, u32 clk_s)\n{\n\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\n\t\t CLKS(clk_s), ~CLKS_MASK);\n}\n\nstatic void rv6xx_set_engine_spread_spectrum_clk_v(struct radeon_device *rdev,\n\t\t\t\t\t\t   u32 index, u32 clk_v)\n{\n\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\n\t\t CLKV(clk_v), ~CLKV_MASK);\n}\n\nstatic void rv6xx_enable_engine_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t\t\tu32 index, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\n\t\t\t SSEN, ~SSEN);\n\telse\n\t\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM_LOW + (index * 4),\n\t\t\t 0, ~SSEN);\n}\n\nstatic void rv6xx_set_memory_spread_spectrum_clk_s(struct radeon_device *rdev,\n\t\t\t\t\t\t   u32 clk_s)\n{\n\tWREG32_P(CG_MPLL_SPREAD_SPECTRUM, CLKS(clk_s), ~CLKS_MASK);\n}\n\nstatic void rv6xx_set_memory_spread_spectrum_clk_v(struct radeon_device *rdev,\n\t\t\t\t\t\t   u32 clk_v)\n{\n\tWREG32_P(CG_MPLL_SPREAD_SPECTRUM, CLKV(clk_v), ~CLKV_MASK);\n}\n\nstatic void rv6xx_enable_memory_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t\t\tbool enable)\n{\n\tif (enable)\n\t\tWREG32_P(CG_MPLL_SPREAD_SPECTRUM, SSEN, ~SSEN);\n\telse\n\t\tWREG32_P(CG_MPLL_SPREAD_SPECTRUM, 0, ~SSEN);\n}\n\nstatic void rv6xx_enable_dynamic_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t\t\t bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\n}\n\nstatic void rv6xx_memory_clock_entry_enable_post_divider(struct radeon_device *rdev,\n\t\t\t\t\t\t\t u32 index, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4),\n\t\t\t LEVEL0_MPLL_DIV_EN, ~LEVEL0_MPLL_DIV_EN);\n\telse\n\t\tWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4), 0, ~LEVEL0_MPLL_DIV_EN);\n}\n\nstatic void rv6xx_memory_clock_entry_set_post_divider(struct radeon_device *rdev,\n\t\t\t\t\t\t      u32 index, u32 divider)\n{\n\tWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4),\n\t\t LEVEL0_MPLL_POST_DIV(divider), ~LEVEL0_MPLL_POST_DIV_MASK);\n}\n\nstatic void rv6xx_memory_clock_entry_set_feedback_divider(struct radeon_device *rdev,\n\t\t\t\t\t\t\t  u32 index, u32 divider)\n{\n\tWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4), LEVEL0_MPLL_FB_DIV(divider),\n\t\t ~LEVEL0_MPLL_FB_DIV_MASK);\n}\n\nstatic void rv6xx_memory_clock_entry_set_reference_divider(struct radeon_device *rdev,\n\t\t\t\t\t\t\t   u32 index, u32 divider)\n{\n\tWREG32_P(MPLL_FREQ_LEVEL_0 + (index * 4),\n\t\t LEVEL0_MPLL_REF_DIV(divider), ~LEVEL0_MPLL_REF_DIV_MASK);\n}\n\nstatic void rv6xx_vid_response_set_brt(struct radeon_device *rdev, u32 rt)\n{\n\tWREG32_P(VID_RT, BRT(rt), ~BRT_MASK);\n}\n\nstatic void rv6xx_enable_engine_feedback_and_reference_sync(struct radeon_device *rdev)\n{\n\tWREG32_P(SPLL_CNTL_MODE, SPLL_DIV_SYNC, ~SPLL_DIV_SYNC);\n}\n\nstatic u32 rv6xx_clocks_per_unit(u32 unit)\n{\n\tu32 tmp = 1 << (2 * unit);\n\n\treturn tmp;\n}\n\nstatic u32 rv6xx_scale_count_given_unit(struct radeon_device *rdev,\n\t\t\t\t\tu32 unscaled_count, u32 unit)\n{\n\tu32 count_per_unit = rv6xx_clocks_per_unit(unit);\n\n\treturn (unscaled_count + count_per_unit - 1) / count_per_unit;\n}\n\nstatic u32 rv6xx_compute_count_for_delay(struct radeon_device *rdev,\n\t\t\t\t\t u32 delay_us, u32 unit)\n{\n\tu32 ref_clk = rdev->clock.spll.reference_freq;\n\n\treturn rv6xx_scale_count_given_unit(rdev, delay_us * (ref_clk / 100), unit);\n}\n\nstatic void rv6xx_calculate_engine_speed_stepping_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\t\t     struct rv6xx_ps *state)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tpi->hw.sclks[R600_POWER_LEVEL_LOW] =\n\t\tstate->low.sclk;\n\tpi->hw.sclks[R600_POWER_LEVEL_MEDIUM] =\n\t\tstate->medium.sclk;\n\tpi->hw.sclks[R600_POWER_LEVEL_HIGH] =\n\t\tstate->high.sclk;\n\n\tpi->hw.low_sclk_index = R600_POWER_LEVEL_LOW;\n\tpi->hw.medium_sclk_index = R600_POWER_LEVEL_MEDIUM;\n\tpi->hw.high_sclk_index = R600_POWER_LEVEL_HIGH;\n}\n\nstatic void rv6xx_calculate_memory_clock_stepping_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\t\t     struct rv6xx_ps *state)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tpi->hw.mclks[R600_POWER_LEVEL_CTXSW] =\n\t\tstate->high.mclk;\n\tpi->hw.mclks[R600_POWER_LEVEL_HIGH] =\n\t\tstate->high.mclk;\n\tpi->hw.mclks[R600_POWER_LEVEL_MEDIUM] =\n\t\tstate->medium.mclk;\n\tpi->hw.mclks[R600_POWER_LEVEL_LOW] =\n\t\tstate->low.mclk;\n\n\tpi->hw.high_mclk_index = R600_POWER_LEVEL_HIGH;\n\n\tif (state->high.mclk == state->medium.mclk)\n\t\tpi->hw.medium_mclk_index =\n\t\t\tpi->hw.high_mclk_index;\n\telse\n\t\tpi->hw.medium_mclk_index = R600_POWER_LEVEL_MEDIUM;\n\n\n\tif (state->medium.mclk == state->low.mclk)\n\t\tpi->hw.low_mclk_index =\n\t\t\tpi->hw.medium_mclk_index;\n\telse\n\t\tpi->hw.low_mclk_index = R600_POWER_LEVEL_LOW;\n}\n\nstatic void rv6xx_calculate_voltage_stepping_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\t\tstruct rv6xx_ps *state)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tpi->hw.vddc[R600_POWER_LEVEL_CTXSW] = state->high.vddc;\n\tpi->hw.vddc[R600_POWER_LEVEL_HIGH] = state->high.vddc;\n\tpi->hw.vddc[R600_POWER_LEVEL_MEDIUM] = state->medium.vddc;\n\tpi->hw.vddc[R600_POWER_LEVEL_LOW] = state->low.vddc;\n\n\tpi->hw.backbias[R600_POWER_LEVEL_CTXSW] =\n\t\t(state->high.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\n\tpi->hw.backbias[R600_POWER_LEVEL_HIGH] =\n\t\t(state->high.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\n\tpi->hw.backbias[R600_POWER_LEVEL_MEDIUM] =\n\t\t(state->medium.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\n\tpi->hw.backbias[R600_POWER_LEVEL_LOW] =\n\t\t(state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ? true : false;\n\n\tpi->hw.pcie_gen2[R600_POWER_LEVEL_HIGH] =\n\t\t(state->high.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? true : false;\n\tpi->hw.pcie_gen2[R600_POWER_LEVEL_MEDIUM] =\n\t\t(state->medium.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? true : false;\n\tpi->hw.pcie_gen2[R600_POWER_LEVEL_LOW] =\n\t\t(state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) ? true : false;\n\n\tpi->hw.high_vddc_index = R600_POWER_LEVEL_HIGH;\n\n\tif ((state->high.vddc == state->medium.vddc) &&\n\t    ((state->high.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ==\n\t     (state->medium.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE)))\n\t\tpi->hw.medium_vddc_index =\n\t\t\tpi->hw.high_vddc_index;\n\telse\n\t\tpi->hw.medium_vddc_index = R600_POWER_LEVEL_MEDIUM;\n\n\tif ((state->medium.vddc == state->low.vddc) &&\n\t    ((state->medium.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) ==\n\t     (state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE)))\n\t\tpi->hw.low_vddc_index =\n\t\t\tpi->hw.medium_vddc_index;\n\telse\n\t\tpi->hw.medium_vddc_index = R600_POWER_LEVEL_LOW;\n}\n\nstatic inline u32 rv6xx_calculate_vco_frequency(u32 ref_clock,\n\t\t\t\t\t\tstruct atom_clock_dividers *dividers,\n\t\t\t\t\t\tu32 fb_divider_scale)\n{\n\treturn ref_clock * ((dividers->fb_div & ~1) << fb_divider_scale) /\n\t\t(dividers->ref_div + 1);\n}\n\nstatic inline u32 rv6xx_calculate_spread_spectrum_clk_v(u32 vco_freq, u32 ref_freq,\n\t\t\t\t\t\t\tu32 ss_rate, u32 ss_percent,\n\t\t\t\t\t\t\tu32 fb_divider_scale)\n{\n\tu32 fb_divider = vco_freq / ref_freq;\n\n\treturn (ss_percent * ss_rate * 4 * (fb_divider * fb_divider) /\n\t\t(5375 * ((vco_freq * 10) / (4096 >> fb_divider_scale))));\n}\n\nstatic inline u32 rv6xx_calculate_spread_spectrum_clk_s(u32 ss_rate, u32 ref_freq)\n{\n\treturn (((ref_freq * 10) / (ss_rate * 2)) - 1) / 4;\n}\n\nstatic void rv6xx_program_engine_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t\t\t u32 clock, enum r600_power_level level)\n{\n\tu32 ref_clk = rdev->clock.spll.reference_freq;\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tstruct atom_clock_dividers dividers;\n\tstruct radeon_atom_ss ss;\n\tu32 vco_freq, clk_v, clk_s;\n\n\trv6xx_enable_engine_spread_spectrum(rdev, level, false);\n\n\tif (clock && pi->sclk_ss) {\n\t\tif (radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM, clock, false, &dividers) == 0) {\n\t\t\tvco_freq = rv6xx_calculate_vco_frequency(ref_clk, &dividers,\n\t\t\t\t\t\t\t\t pi->fb_div_scale);\n\n\t\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t\t     ASIC_INTERNAL_ENGINE_SS, vco_freq)) {\n\t\t\t\tclk_v = rv6xx_calculate_spread_spectrum_clk_v(vco_freq,\n\t\t\t\t\t\t\t\t\t      (ref_clk / (dividers.ref_div + 1)),\n\t\t\t\t\t\t\t\t\t      ss.rate,\n\t\t\t\t\t\t\t\t\t      ss.percentage,\n\t\t\t\t\t\t\t\t\t      pi->fb_div_scale);\n\n\t\t\t\tclk_s = rv6xx_calculate_spread_spectrum_clk_s(ss.rate,\n\t\t\t\t\t\t\t\t\t      (ref_clk / (dividers.ref_div + 1)));\n\n\t\t\t\trv6xx_set_engine_spread_spectrum_clk_v(rdev, level, clk_v);\n\t\t\t\trv6xx_set_engine_spread_spectrum_clk_s(rdev, level, clk_s);\n\t\t\t\trv6xx_enable_engine_spread_spectrum(rdev, level, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rv6xx_program_sclk_spread_spectrum_parameters_except_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_program_engine_spread_spectrum(rdev,\n\t\t\t\t\t     pi->hw.sclks[R600_POWER_LEVEL_HIGH],\n\t\t\t\t\t     R600_POWER_LEVEL_HIGH);\n\n\trv6xx_program_engine_spread_spectrum(rdev,\n\t\t\t\t\t     pi->hw.sclks[R600_POWER_LEVEL_MEDIUM],\n\t\t\t\t\t     R600_POWER_LEVEL_MEDIUM);\n\n}\n\nstatic int rv6xx_program_mclk_stepping_entry(struct radeon_device *rdev,\n\t\t\t\t\t     u32 entry, u32 clock)\n{\n\tstruct atom_clock_dividers dividers;\n\n\tif (radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM, clock, false, &dividers))\n\t    return -EINVAL;\n\n\n\trv6xx_memory_clock_entry_set_reference_divider(rdev, entry, dividers.ref_div);\n\trv6xx_memory_clock_entry_set_feedback_divider(rdev, entry, dividers.fb_div);\n\trv6xx_memory_clock_entry_set_post_divider(rdev, entry, dividers.post_div);\n\n\tif (dividers.enable_post_div)\n\t\trv6xx_memory_clock_entry_enable_post_divider(rdev, entry, true);\n\telse\n\t\trv6xx_memory_clock_entry_enable_post_divider(rdev, entry, false);\n\n\treturn 0;\n}\n\nstatic void rv6xx_program_mclk_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tint i;\n\n\tfor (i = 1; i < R600_PM_NUMBER_OF_MCLKS; i++) {\n\t\tif (pi->hw.mclks[i])\n\t\t\trv6xx_program_mclk_stepping_entry(rdev, i,\n\t\t\t\t\t\t\t  pi->hw.mclks[i]);\n\t}\n}\n\nstatic void rv6xx_find_memory_clock_with_highest_vco(struct radeon_device *rdev,\n\t\t\t\t\t\t     u32 requested_memory_clock,\n\t\t\t\t\t\t     u32 ref_clk,\n\t\t\t\t\t\t     struct atom_clock_dividers *dividers,\n\t\t\t\t\t\t     u32 *vco_freq)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tstruct atom_clock_dividers req_dividers;\n\tu32 vco_freq_temp;\n\n\tif (radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\n\t\t\t\t\t   requested_memory_clock, false, &req_dividers) == 0) {\n\t\tvco_freq_temp = rv6xx_calculate_vco_frequency(ref_clk, &req_dividers,\n\t\t\t\t\t\t\t      pi->fb_div_scale);\n\n\t\tif (vco_freq_temp > *vco_freq) {\n\t\t\t*dividers = req_dividers;\n\t\t\t*vco_freq = vco_freq_temp;\n\t\t}\n\t}\n}\n\nstatic void rv6xx_program_mclk_spread_spectrum_parameters(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tu32 ref_clk = rdev->clock.mpll.reference_freq;\n\tstruct atom_clock_dividers dividers;\n\tstruct radeon_atom_ss ss;\n\tu32 vco_freq = 0, clk_v, clk_s;\n\n\trv6xx_enable_memory_spread_spectrum(rdev, false);\n\n\tif (pi->mclk_ss) {\n\t\trv6xx_find_memory_clock_with_highest_vco(rdev,\n\t\t\t\t\t\t\t pi->hw.mclks[pi->hw.high_mclk_index],\n\t\t\t\t\t\t\t ref_clk,\n\t\t\t\t\t\t\t &dividers,\n\t\t\t\t\t\t\t &vco_freq);\n\n\t\trv6xx_find_memory_clock_with_highest_vco(rdev,\n\t\t\t\t\t\t\t pi->hw.mclks[pi->hw.medium_mclk_index],\n\t\t\t\t\t\t\t ref_clk,\n\t\t\t\t\t\t\t &dividers,\n\t\t\t\t\t\t\t &vco_freq);\n\n\t\trv6xx_find_memory_clock_with_highest_vco(rdev,\n\t\t\t\t\t\t\t pi->hw.mclks[pi->hw.low_mclk_index],\n\t\t\t\t\t\t\t ref_clk,\n\t\t\t\t\t\t\t &dividers,\n\t\t\t\t\t\t\t &vco_freq);\n\n\t\tif (vco_freq) {\n\t\t\tif (radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t\t     ASIC_INTERNAL_MEMORY_SS, vco_freq)) {\n\t\t\t\tclk_v = rv6xx_calculate_spread_spectrum_clk_v(vco_freq,\n\t\t\t\t\t\t\t\t\t     (ref_clk / (dividers.ref_div + 1)),\n\t\t\t\t\t\t\t\t\t     ss.rate,\n\t\t\t\t\t\t\t\t\t     ss.percentage,\n\t\t\t\t\t\t\t\t\t     pi->fb_div_scale);\n\n\t\t\t\tclk_s = rv6xx_calculate_spread_spectrum_clk_s(ss.rate,\n\t\t\t\t\t\t\t\t\t     (ref_clk / (dividers.ref_div + 1)));\n\n\t\t\t\trv6xx_set_memory_spread_spectrum_clk_v(rdev, clk_v);\n\t\t\t\trv6xx_set_memory_spread_spectrum_clk_s(rdev, clk_s);\n\t\t\t\trv6xx_enable_memory_spread_spectrum(rdev, true);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int rv6xx_program_voltage_stepping_entry(struct radeon_device *rdev,\n\t\t\t\t\t\tu32 entry, u16 voltage)\n{\n\tu32 mask, set_pins;\n\tint ret;\n\n\tret = radeon_atom_get_voltage_gpio_settings(rdev, voltage,\n\t\t\t\t\t\t    SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t\t    &set_pins, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tr600_voltage_control_program_voltages(rdev, entry, set_pins);\n\n\treturn 0;\n}\n\nstatic void rv6xx_program_voltage_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tint i;\n\n\tfor (i = 1; i < R600_PM_NUMBER_OF_VOLTAGE_LEVELS; i++)\n\t\trv6xx_program_voltage_stepping_entry(rdev, i,\n\t\t\t\t\t\t     pi->hw.vddc[i]);\n\n}\n\nstatic void rv6xx_program_backbias_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (pi->hw.backbias[1])\n\t\tWREG32_P(VID_UPPER_GPIO_CNTL, MEDIUM_BACKBIAS_VALUE, ~MEDIUM_BACKBIAS_VALUE);\n\telse\n\t\tWREG32_P(VID_UPPER_GPIO_CNTL, 0, ~MEDIUM_BACKBIAS_VALUE);\n\n\tif (pi->hw.backbias[2])\n\t\tWREG32_P(VID_UPPER_GPIO_CNTL, HIGH_BACKBIAS_VALUE, ~HIGH_BACKBIAS_VALUE);\n\telse\n\t\tWREG32_P(VID_UPPER_GPIO_CNTL, 0, ~HIGH_BACKBIAS_VALUE);\n}\n\nstatic void rv6xx_program_sclk_spread_spectrum_parameters_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_program_engine_spread_spectrum(rdev,\n\t\t\t\t\t     pi->hw.sclks[R600_POWER_LEVEL_LOW],\n\t\t\t\t\t     R600_POWER_LEVEL_LOW);\n}\n\nstatic void rv6xx_program_mclk_stepping_parameters_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (pi->hw.mclks[0])\n\t\trv6xx_program_mclk_stepping_entry(rdev, 0,\n\t\t\t\t\t\t  pi->hw.mclks[0]);\n}\n\nstatic void rv6xx_program_voltage_stepping_parameters_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_program_voltage_stepping_entry(rdev, 0,\n\t\t\t\t\t     pi->hw.vddc[0]);\n\n}\n\nstatic void rv6xx_program_backbias_stepping_parameters_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (pi->hw.backbias[0])\n\t\tWREG32_P(VID_UPPER_GPIO_CNTL, LOW_BACKBIAS_VALUE, ~LOW_BACKBIAS_VALUE);\n\telse\n\t\tWREG32_P(VID_UPPER_GPIO_CNTL, 0, ~LOW_BACKBIAS_VALUE);\n}\n\nstatic u32 calculate_memory_refresh_rate(struct radeon_device *rdev,\n\t\t\t\t\t u32 engine_clock)\n{\n\tu32 dram_rows, dram_refresh_rate;\n\tu32 tmp;\n\n\ttmp = (RREG32(RAMCFG) & NOOFROWS_MASK) >> NOOFROWS_SHIFT;\n\tdram_rows = 1 << (tmp + 10);\n\tdram_refresh_rate = 1 << ((RREG32(MC_SEQ_RESERVE_M) & 0x3) + 3);\n\n\treturn ((engine_clock * 10) * dram_refresh_rate / dram_rows - 32) / 64;\n}\n\nstatic void rv6xx_program_memory_timing_parameters(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tu32 sqm_ratio;\n\tu32 arb_refresh_rate;\n\tu32 high_clock;\n\n\tif (pi->hw.sclks[R600_POWER_LEVEL_HIGH] <\n\t    (pi->hw.sclks[R600_POWER_LEVEL_LOW] * 0xFF / 0x40))\n\t\thigh_clock = pi->hw.sclks[R600_POWER_LEVEL_HIGH];\n\telse\n\t\thigh_clock =\n\t\t\tpi->hw.sclks[R600_POWER_LEVEL_LOW] * 0xFF / 0x40;\n\n\tradeon_atom_set_engine_dram_timings(rdev, high_clock, 0);\n\n\tsqm_ratio = (STATE0(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_LOW]) |\n\t\t     STATE1(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_MEDIUM]) |\n\t\t     STATE2(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_HIGH]) |\n\t\t     STATE3(64 * high_clock / pi->hw.sclks[R600_POWER_LEVEL_HIGH]));\n\tWREG32(SQM_RATIO, sqm_ratio);\n\n\tarb_refresh_rate =\n\t\t(POWERMODE0(calculate_memory_refresh_rate(rdev,\n\t\t\t\t\t\t\t  pi->hw.sclks[R600_POWER_LEVEL_LOW])) |\n\t\t POWERMODE1(calculate_memory_refresh_rate(rdev,\n\t\t\t\t\t\t\t  pi->hw.sclks[R600_POWER_LEVEL_MEDIUM])) |\n\t\t POWERMODE2(calculate_memory_refresh_rate(rdev,\n\t\t\t\t\t\t\t  pi->hw.sclks[R600_POWER_LEVEL_HIGH])) |\n\t\t POWERMODE3(calculate_memory_refresh_rate(rdev,\n\t\t\t\t\t\t\t  pi->hw.sclks[R600_POWER_LEVEL_HIGH])));\n\tWREG32(ARB_RFSH_RATE, arb_refresh_rate);\n}\n\nstatic void rv6xx_program_mpll_timing_parameters(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tr600_set_mpll_lock_time(rdev, R600_MPLLLOCKTIME_DFLT *\n\t\t\t\tpi->mpll_ref_div);\n\tr600_set_mpll_reset_time(rdev, R600_MPLLRESETTIME_DFLT);\n}\n\nstatic void rv6xx_program_bsp(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tu32 ref_clk = rdev->clock.spll.reference_freq;\n\n\tr600_calculate_u_and_p(R600_ASI_DFLT,\n\t\t\t       ref_clk, 16,\n\t\t\t       &pi->bsp,\n\t\t\t       &pi->bsu);\n\n\tr600_set_bsp(rdev, pi->bsu, pi->bsp);\n}\n\nstatic void rv6xx_program_at(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tr600_set_at(rdev,\n\t\t    (pi->hw.rp[0] * pi->bsp) / 200,\n\t\t    (pi->hw.rp[1] * pi->bsp) / 200,\n\t\t    (pi->hw.lp[2] * pi->bsp) / 200,\n\t\t    (pi->hw.lp[1] * pi->bsp) / 200);\n}\n\nstatic void rv6xx_program_git(struct radeon_device *rdev)\n{\n\tr600_set_git(rdev, R600_GICST_DFLT);\n}\n\nstatic void rv6xx_program_tp(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < R600_PM_NUMBER_OF_TC; i++)\n\t\tr600_set_tc(rdev, i, r600_utc[i], r600_dtc[i]);\n\n\tr600_select_td(rdev, R600_TD_DFLT);\n}\n\nstatic void rv6xx_program_vc(struct radeon_device *rdev)\n{\n\tr600_set_vrc(rdev, R600_VRC_DFLT);\n}\n\nstatic void rv6xx_clear_vc(struct radeon_device *rdev)\n{\n\tr600_set_vrc(rdev, 0);\n}\n\nstatic void rv6xx_program_tpp(struct radeon_device *rdev)\n{\n\tr600_set_tpu(rdev, R600_TPU_DFLT);\n\tr600_set_tpc(rdev, R600_TPC_DFLT);\n}\n\nstatic void rv6xx_program_sstp(struct radeon_device *rdev)\n{\n\tr600_set_sstu(rdev, R600_SSTU_DFLT);\n\tr600_set_sst(rdev, R600_SST_DFLT);\n}\n\nstatic void rv6xx_program_fcp(struct radeon_device *rdev)\n{\n\tr600_set_fctu(rdev, R600_FCTU_DFLT);\n\tr600_set_fct(rdev, R600_FCT_DFLT);\n}\n\nstatic void rv6xx_program_vddc3d_parameters(struct radeon_device *rdev)\n{\n\tr600_set_vddc3d_oorsu(rdev, R600_VDDC3DOORSU_DFLT);\n\tr600_set_vddc3d_oorphc(rdev, R600_VDDC3DOORPHC_DFLT);\n\tr600_set_vddc3d_oorsdc(rdev, R600_VDDC3DOORSDC_DFLT);\n\tr600_set_ctxcgtt3d_rphc(rdev, R600_CTXCGTT3DRPHC_DFLT);\n\tr600_set_ctxcgtt3d_rsdc(rdev, R600_CTXCGTT3DRSDC_DFLT);\n}\n\nstatic void rv6xx_program_voltage_timing_parameters(struct radeon_device *rdev)\n{\n\tu32 rt;\n\n\tr600_vid_rt_set_vru(rdev, R600_VRU_DFLT);\n\n\tr600_vid_rt_set_vrt(rdev,\n\t\t\t    rv6xx_compute_count_for_delay(rdev,\n\t\t\t\t\t\t\t  rdev->pm.dpm.voltage_response_time,\n\t\t\t\t\t\t\t  R600_VRU_DFLT));\n\n\trt = rv6xx_compute_count_for_delay(rdev,\n\t\t\t\t\t   rdev->pm.dpm.backbias_response_time,\n\t\t\t\t\t   R600_VRU_DFLT);\n\n\trv6xx_vid_response_set_brt(rdev, (rt + 0x1F) >> 5);\n}\n\nstatic void rv6xx_program_engine_speed_parameters(struct radeon_device *rdev)\n{\n\tr600_vid_rt_set_ssu(rdev, R600_SPLLSTEPUNIT_DFLT);\n\trv6xx_enable_engine_feedback_and_reference_sync(rdev);\n}\n\nstatic u64 rv6xx_get_master_voltage_mask(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tu64 master_mask = 0;\n\tint i;\n\n\tfor (i = 0; i < R600_PM_NUMBER_OF_VOLTAGE_LEVELS; i++) {\n\t\tu32 tmp_mask, tmp_set_pins;\n\t\tint ret;\n\n\t\tret = radeon_atom_get_voltage_gpio_settings(rdev,\n\t\t\t\t\t\t\t    pi->hw.vddc[i],\n\t\t\t\t\t\t\t    SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t\t\t    &tmp_set_pins, &tmp_mask);\n\n\t\tif (ret == 0)\n\t\t\tmaster_mask |= tmp_mask;\n\t}\n\n\treturn master_mask;\n}\n\nstatic void rv6xx_program_voltage_gpio_pins(struct radeon_device *rdev)\n{\n\tr600_voltage_control_enable_pins(rdev,\n\t\t\t\t\t rv6xx_get_master_voltage_mask(rdev));\n}\n\nstatic void rv6xx_enable_static_voltage_control(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct radeon_ps *new_ps,\n\t\t\t\t\t\tbool enable)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\n\tif (enable)\n\t\tradeon_atom_set_voltage(rdev,\n\t\t\t\t\tnew_state->low.vddc,\n\t\t\t\t\tSET_VOLTAGE_TYPE_ASIC_VDDC);\n\telse\n\t\tr600_voltage_control_deactivate_static_control(rdev,\n\t\t\t\t\t\t\t       rv6xx_get_master_voltage_mask(rdev));\n}\n\nstatic void rv6xx_enable_display_gap(struct radeon_device *rdev, bool enable)\n{\n\tif (enable) {\n\t\tu32 tmp = (DISP1_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM) |\n\t\t\t   DISP2_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM) |\n\t\t\t   DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE) |\n\t\t\t   DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE) |\n\t\t\t   VBI_TIMER_COUNT(0x3FFF) |\n\t\t\t   VBI_TIMER_UNIT(7));\n\t\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n\n\t\tWREG32_P(MCLK_PWRMGT_CNTL, USE_DISPLAY_GAP, ~USE_DISPLAY_GAP);\n\t} else\n\t\tWREG32_P(MCLK_PWRMGT_CNTL, 0, ~USE_DISPLAY_GAP);\n}\n\nstatic void rv6xx_program_power_level_enter_state(struct radeon_device *rdev)\n{\n\tr600_power_level_set_enter_index(rdev, R600_POWER_LEVEL_MEDIUM);\n}\n\nstatic void rv6xx_calculate_t(u32 l_f, u32 h_f, int h,\n\t\t\t      int d_l, int d_r, u8 *l, u8 *r)\n{\n\tint a_n, a_d, h_r, l_r;\n\n\th_r = d_l;\n\tl_r = 100 - d_r;\n\n\ta_n = (int)h_f * d_l + (int)l_f * (h - d_r);\n\ta_d = (int)l_f * l_r + (int)h_f * h_r;\n\n\tif (a_d != 0) {\n\t\t*l = d_l - h_r * a_n / a_d;\n\t\t*r = d_r + l_r * a_n / a_d;\n\t}\n}\n\nstatic void rv6xx_calculate_ap(struct radeon_device *rdev,\n\t\t\t       struct rv6xx_ps *state)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tpi->hw.lp[0] = 0;\n\tpi->hw.rp[R600_PM_NUMBER_OF_ACTIVITY_LEVELS - 1]\n\t\t= 100;\n\n\trv6xx_calculate_t(state->low.sclk,\n\t\t\t  state->medium.sclk,\n\t\t\t  R600_AH_DFLT,\n\t\t\t  R600_LMP_DFLT,\n\t\t\t  R600_RLP_DFLT,\n\t\t\t  &pi->hw.lp[1],\n\t\t\t  &pi->hw.rp[0]);\n\n\trv6xx_calculate_t(state->medium.sclk,\n\t\t\t  state->high.sclk,\n\t\t\t  R600_AH_DFLT,\n\t\t\t  R600_LHP_DFLT,\n\t\t\t  R600_RMP_DFLT,\n\t\t\t  &pi->hw.lp[2],\n\t\t\t  &pi->hw.rp[1]);\n\n}\n\nstatic void rv6xx_calculate_stepping_parameters(struct radeon_device *rdev,\n\t\t\t\t\t\tstruct radeon_ps *new_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\n\trv6xx_calculate_engine_speed_stepping_parameters(rdev, new_state);\n\trv6xx_calculate_memory_clock_stepping_parameters(rdev, new_state);\n\trv6xx_calculate_voltage_stepping_parameters(rdev, new_state);\n\trv6xx_calculate_ap(rdev, new_state);\n}\n\nstatic void rv6xx_program_stepping_parameters_except_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_program_mclk_stepping_parameters_except_lowest_entry(rdev);\n\tif (pi->voltage_control)\n\t\trv6xx_program_voltage_stepping_parameters_except_lowest_entry(rdev);\n\trv6xx_program_backbias_stepping_parameters_except_lowest_entry(rdev);\n\trv6xx_program_sclk_spread_spectrum_parameters_except_lowest_entry(rdev);\n\trv6xx_program_mclk_spread_spectrum_parameters(rdev);\n\trv6xx_program_memory_timing_parameters(rdev);\n}\n\nstatic void rv6xx_program_stepping_parameters_lowest_entry(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_program_mclk_stepping_parameters_lowest_entry(rdev);\n\tif (pi->voltage_control)\n\t\trv6xx_program_voltage_stepping_parameters_lowest_entry(rdev);\n\trv6xx_program_backbias_stepping_parameters_lowest_entry(rdev);\n\trv6xx_program_sclk_spread_spectrum_parameters_lowest_entry(rdev);\n}\n\nstatic void rv6xx_program_power_level_low(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t\t   pi->hw.low_vddc_index);\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t\t     pi->hw.low_mclk_index);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t\t     pi->hw.low_sclk_index);\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t\t  R600_DISPLAY_WATERMARK_LOW);\n\tr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t       pi->hw.pcie_gen2[R600_POWER_LEVEL_LOW]);\n}\n\nstatic void rv6xx_program_power_level_low_to_lowest_state(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_LOW, 0);\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_LOW, 0);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_LOW, 0);\n\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t\t  R600_DISPLAY_WATERMARK_LOW);\n\n\tr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_LOW,\n\t\t\t\t       pi->hw.pcie_gen2[R600_POWER_LEVEL_LOW]);\n\n}\n\nstatic void rv6xx_program_power_level_medium(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t  pi->hw.medium_vddc_index);\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t    pi->hw.medium_mclk_index);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t    pi->hw.medium_sclk_index);\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t R600_DISPLAY_WATERMARK_LOW);\n\tr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t      pi->hw.pcie_gen2[R600_POWER_LEVEL_MEDIUM]);\n}\n\nstatic void rv6xx_program_power_level_medium_for_transition(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_program_mclk_stepping_entry(rdev,\n\t\t\t\t\t  R600_POWER_LEVEL_CTXSW,\n\t\t\t\t\t  pi->hw.mclks[pi->hw.low_mclk_index]);\n\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_MEDIUM, 1);\n\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t     R600_POWER_LEVEL_CTXSW);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t     pi->hw.medium_sclk_index);\n\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t\t  R600_DISPLAY_WATERMARK_LOW);\n\n\trv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\n\tr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_MEDIUM,\n\t\t\t\t       pi->hw.pcie_gen2[R600_POWER_LEVEL_LOW]);\n}\n\nstatic void rv6xx_program_power_level_high(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tr600_power_level_set_voltage_index(rdev, R600_POWER_LEVEL_HIGH,\n\t\t\t\t\t   pi->hw.high_vddc_index);\n\tr600_power_level_set_mem_clock_index(rdev, R600_POWER_LEVEL_HIGH,\n\t\t\t\t\t     pi->hw.high_mclk_index);\n\tr600_power_level_set_eng_clock_index(rdev, R600_POWER_LEVEL_HIGH,\n\t\t\t\t\t     pi->hw.high_sclk_index);\n\n\tr600_power_level_set_watermark_id(rdev, R600_POWER_LEVEL_HIGH,\n\t\t\t\t\t  R600_DISPLAY_WATERMARK_HIGH);\n\n\tr600_power_level_set_pcie_gen2(rdev, R600_POWER_LEVEL_HIGH,\n\t\t\t\t       pi->hw.pcie_gen2[R600_POWER_LEVEL_HIGH]);\n}\n\nstatic void rv6xx_enable_backbias(struct radeon_device *rdev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, BACKBIAS_PAD_EN | BACKBIAS_DPM_CNTL,\n\t\t\t ~(BACKBIAS_PAD_EN | BACKBIAS_DPM_CNTL));\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0,\n\t\t\t ~(BACKBIAS_VALUE | BACKBIAS_PAD_EN | BACKBIAS_DPM_CNTL));\n}\n\nstatic void rv6xx_program_display_gap(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\n\n\ttmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\n\tif (rdev->pm.dpm.new_active_crtcs & 1) {\n\t\ttmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\n\t\ttmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t} else if (rdev->pm.dpm.new_active_crtcs & 2) {\n\t\ttmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t\ttmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK);\n\t} else {\n\t\ttmp |= DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t\ttmp |= DISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE);\n\t}\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n}\n\nstatic void rv6xx_set_sw_voltage_to_safe(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *new_ps,\n\t\t\t\t\t struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\tu16 safe_voltage;\n\n\tsafe_voltage = (new_state->low.vddc >= old_state->low.vddc) ?\n\t\tnew_state->low.vddc : old_state->low.vddc;\n\n\trv6xx_program_voltage_stepping_entry(rdev, R600_POWER_LEVEL_CTXSW,\n\t\t\t\t\t     safe_voltage);\n\n\tWREG32_P(GENERAL_PWRMGT, SW_GPIO_INDEX(R600_POWER_LEVEL_CTXSW),\n\t\t ~SW_GPIO_INDEX_MASK);\n}\n\nstatic void rv6xx_set_sw_voltage_to_low(struct radeon_device *rdev,\n\t\t\t\t\tstruct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\n\trv6xx_program_voltage_stepping_entry(rdev, R600_POWER_LEVEL_CTXSW,\n\t\t\t\t\t     old_state->low.vddc);\n\n\tWREG32_P(GENERAL_PWRMGT, SW_GPIO_INDEX(R600_POWER_LEVEL_CTXSW),\n\t\t~SW_GPIO_INDEX_MASK);\n}\n\nstatic void rv6xx_set_safe_backbias(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_ps *new_ps,\n\t\t\t\t    struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\n\tif ((new_state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE) &&\n\t    (old_state->low.flags & ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE))\n\t\tWREG32_P(GENERAL_PWRMGT, BACKBIAS_VALUE, ~BACKBIAS_VALUE);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~BACKBIAS_VALUE);\n}\n\nstatic void rv6xx_set_safe_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t     struct radeon_ps *new_ps,\n\t\t\t\t     struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\n\tif ((new_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) !=\n\t    (old_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2))\n\t\trv6xx_force_pcie_gen1(rdev);\n}\n\nstatic void rv6xx_enable_dynamic_voltage_control(struct radeon_device *rdev,\n\t\t\t\t\t\t bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, VOLT_PWRMGT_EN, ~VOLT_PWRMGT_EN);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~VOLT_PWRMGT_EN);\n}\n\nstatic void rv6xx_enable_dynamic_backbias_control(struct radeon_device *rdev,\n\t\t\t\t\t\t  bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, BACKBIAS_DPM_CNTL, ~BACKBIAS_DPM_CNTL);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~BACKBIAS_DPM_CNTL);\n}\n\nstatic int rv6xx_step_sw_voltage(struct radeon_device *rdev,\n\t\t\t\t u16 initial_voltage,\n\t\t\t\t u16 target_voltage)\n{\n\tu16 current_voltage;\n\tu16 true_target_voltage;\n\tu16 voltage_step;\n\tint signed_voltage_step;\n\n\tif ((radeon_atom_get_voltage_step(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t  &voltage_step)) ||\n\t    (radeon_atom_round_to_true_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t       initial_voltage, &current_voltage)) ||\n\t    (radeon_atom_round_to_true_voltage(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t       target_voltage, &true_target_voltage)))\n\t\treturn -EINVAL;\n\n\tif (true_target_voltage < current_voltage)\n\t\tsigned_voltage_step = -(int)voltage_step;\n\telse\n\t\tsigned_voltage_step = voltage_step;\n\n\twhile (current_voltage != true_target_voltage) {\n\t\tcurrent_voltage += signed_voltage_step;\n\t\trv6xx_program_voltage_stepping_entry(rdev, R600_POWER_LEVEL_CTXSW,\n\t\t\t\t\t\t     current_voltage);\n\t\tmsleep((rdev->pm.dpm.voltage_response_time + 999) / 1000);\n\t}\n\n\treturn 0;\n}\n\nstatic int rv6xx_step_voltage_if_increasing(struct radeon_device *rdev,\n\t\t\t\t\t    struct radeon_ps *new_ps,\n\t\t\t\t\t    struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\n\tif (new_state->low.vddc > old_state->low.vddc)\n\t\treturn rv6xx_step_sw_voltage(rdev,\n\t\t\t\t\t     old_state->low.vddc,\n\t\t\t\t\t     new_state->low.vddc);\n\n\treturn 0;\n}\n\nstatic int rv6xx_step_voltage_if_decreasing(struct radeon_device *rdev,\n\t\t\t\t\t    struct radeon_ps *new_ps,\n\t\t\t\t\t    struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\n\tif (new_state->low.vddc < old_state->low.vddc)\n\t\treturn rv6xx_step_sw_voltage(rdev,\n\t\t\t\t\t     old_state->low.vddc,\n\t\t\t\t\t     new_state->low.vddc);\n\telse\n\t\treturn 0;\n}\n\nstatic void rv6xx_enable_high(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif ((pi->restricted_levels < 1) ||\n\t    (pi->restricted_levels == 3))\n\t\tr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, true);\n}\n\nstatic void rv6xx_enable_medium(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (pi->restricted_levels < 2)\n\t\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\n}\n\nstatic void rv6xx_set_dpm_event_sources(struct radeon_device *rdev, u32 sources)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tbool want_thermal_protection;\n\tenum radeon_dpm_event_src dpm_event_src;\n\n\tswitch (sources) {\n\tcase 0:\n\tdefault:\n\t\twant_thermal_protection = false;\n\t\tbreak;\n\tcase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = RADEON_DPM_EVENT_SRC_DIGITAL;\n\t\tbreak;\n\n\tcase (1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = RADEON_DPM_EVENT_SRC_EXTERNAL;\n\t\tbreak;\n\n\tcase ((1 << RADEON_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\n\t      (1 << RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL)):\n\t\t\twant_thermal_protection = true;\n\t\tdpm_event_src = RADEON_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (want_thermal_protection) {\n\t\tWREG32_P(CG_THERMAL_CTRL, DPM_EVENT_SRC(dpm_event_src), ~DPM_EVENT_SRC_MASK);\n\t\tif (pi->thermal_protection)\n\t\t\tWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\n\t} else {\n\t\tWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\n\t}\n}\n\nstatic void rv6xx_enable_auto_throttle_source(struct radeon_device *rdev,\n\t\t\t\t\t      enum radeon_dpm_auto_throttle_src source,\n\t\t\t\t\t      bool enable)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (enable) {\n\t\tif (!(pi->active_auto_throttle_sources & (1 << source))) {\n\t\t\tpi->active_auto_throttle_sources |= 1 << source;\n\t\t\trv6xx_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\n\t\t}\n\t} else {\n\t\tif (pi->active_auto_throttle_sources & (1 << source)) {\n\t\t\tpi->active_auto_throttle_sources &= ~(1 << source);\n\t\t\trv6xx_set_dpm_event_sources(rdev, pi->active_auto_throttle_sources);\n\t\t}\n\t}\n}\n\n\nstatic void rv6xx_enable_thermal_protection(struct radeon_device *rdev,\n\t\t\t\t\t    bool enable)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (pi->active_auto_throttle_sources)\n\t\tr600_enable_thermal_protection(rdev, enable);\n}\n\nstatic void rv6xx_generate_transition_stepping(struct radeon_device *rdev,\n\t\t\t\t\t       struct radeon_ps *new_ps,\n\t\t\t\t\t       struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *old_state = rv6xx_get_ps(old_ps);\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_generate_steps(rdev,\n\t\t\t     old_state->low.sclk,\n\t\t\t     new_state->low.sclk,\n\t\t\t     0, &pi->hw.medium_sclk_index);\n}\n\nstatic void rv6xx_generate_low_step(struct radeon_device *rdev,\n\t\t\t\t    struct radeon_ps *new_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tpi->hw.low_sclk_index = 0;\n\trv6xx_generate_single_step(rdev,\n\t\t\t\t   new_state->low.sclk,\n\t\t\t\t   0);\n}\n\nstatic void rv6xx_invalidate_intermediate_steps(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\trv6xx_invalidate_intermediate_steps_range(rdev, 0,\n\t\t\t\t\t\t  pi->hw.medium_sclk_index);\n}\n\nstatic void rv6xx_generate_stepping_table(struct radeon_device *rdev,\n\t\t\t\t\t  struct radeon_ps *new_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tpi->hw.low_sclk_index = 0;\n\n\trv6xx_generate_steps(rdev,\n\t\t\t     new_state->low.sclk,\n\t\t\t     new_state->medium.sclk,\n\t\t\t     0,\n\t\t\t     &pi->hw.medium_sclk_index);\n\trv6xx_generate_steps(rdev,\n\t\t\t     new_state->medium.sclk,\n\t\t\t     new_state->high.sclk,\n\t\t\t     pi->hw.medium_sclk_index,\n\t\t\t     &pi->hw.high_sclk_index);\n}\n\nstatic void rv6xx_enable_spread_spectrum(struct radeon_device *rdev,\n\t\t\t\t\t bool enable)\n{\n\tif (enable)\n\t\trv6xx_enable_dynamic_spread_spectrum(rdev, true);\n\telse {\n\t\trv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_LOW, false);\n\t\trv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\t\trv6xx_enable_engine_spread_spectrum(rdev, R600_POWER_LEVEL_HIGH, false);\n\t\trv6xx_enable_dynamic_spread_spectrum(rdev, false);\n\t\trv6xx_enable_memory_spread_spectrum(rdev, false);\n\t}\n}\n\nstatic void rv6xx_reset_lvtm_data_sync(struct radeon_device *rdev)\n{\n\tif (ASIC_IS_DCE3(rdev))\n\t\tWREG32_P(DCE3_LVTMA_DATA_SYNCHRONIZATION, LVTMA_PFREQCHG, ~LVTMA_PFREQCHG);\n\telse\n\t\tWREG32_P(LVTMA_DATA_SYNCHRONIZATION, LVTMA_PFREQCHG, ~LVTMA_PFREQCHG);\n}\n\nstatic void rv6xx_enable_dynamic_pcie_gen2(struct radeon_device *rdev,\n\t\t\t\t\t   struct radeon_ps *new_ps,\n\t\t\t\t\t   bool enable)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\n\tif (enable) {\n\t\trv6xx_enable_bif_dynamic_pcie_gen2(rdev, true);\n\t\trv6xx_enable_pcie_gen2_support(rdev);\n\t\tr600_enable_dynamic_pcie_gen2(rdev, true);\n\t} else {\n\t\tif (!(new_state->low.flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2))\n\t\t\trv6xx_force_pcie_gen1(rdev);\n\t\trv6xx_enable_bif_dynamic_pcie_gen2(rdev, false);\n\t\tr600_enable_dynamic_pcie_gen2(rdev, false);\n\t}\n}\n\nstatic void rv6xx_set_uvd_clock_before_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t     struct radeon_ps *new_ps,\n\t\t\t\t\t\t     struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *current_state = rv6xx_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->high.sclk >= current_state->high.sclk)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nstatic void rv6xx_set_uvd_clock_after_set_eng_clock(struct radeon_device *rdev,\n\t\t\t\t\t\t    struct radeon_ps *new_ps,\n\t\t\t\t\t\t    struct radeon_ps *old_ps)\n{\n\tstruct rv6xx_ps *new_state = rv6xx_get_ps(new_ps);\n\tstruct rv6xx_ps *current_state = rv6xx_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->high.sclk < current_state->high.sclk)\n\t\treturn;\n\n\tradeon_set_uvd_clocks(rdev, new_ps->vclk, new_ps->dclk);\n}\n\nint rv6xx_dpm_enable(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\n\tif (r600_dynamicpm_enabled(rdev))\n\t\treturn -EINVAL;\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv6xx_enable_backbias(rdev, true);\n\n\tif (pi->dynamic_ss)\n\t\trv6xx_enable_spread_spectrum(rdev, true);\n\n\trv6xx_program_mpll_timing_parameters(rdev);\n\trv6xx_program_bsp(rdev);\n\trv6xx_program_git(rdev);\n\trv6xx_program_tp(rdev);\n\trv6xx_program_tpp(rdev);\n\trv6xx_program_sstp(rdev);\n\trv6xx_program_fcp(rdev);\n\trv6xx_program_vddc3d_parameters(rdev);\n\trv6xx_program_voltage_timing_parameters(rdev);\n\trv6xx_program_engine_speed_parameters(rdev);\n\n\trv6xx_enable_display_gap(rdev, true);\n\tif (pi->display_gap == false)\n\t\trv6xx_enable_display_gap(rdev, false);\n\n\trv6xx_program_power_level_enter_state(rdev);\n\n\trv6xx_calculate_stepping_parameters(rdev, boot_ps);\n\n\tif (pi->voltage_control)\n\t\trv6xx_program_voltage_gpio_pins(rdev);\n\n\trv6xx_generate_stepping_table(rdev, boot_ps);\n\n\trv6xx_program_stepping_parameters_except_lowest_entry(rdev);\n\trv6xx_program_stepping_parameters_lowest_entry(rdev);\n\n\trv6xx_program_power_level_low(rdev);\n\trv6xx_program_power_level_medium(rdev);\n\trv6xx_program_power_level_high(rdev);\n\trv6xx_program_vc(rdev);\n\trv6xx_program_at(rdev);\n\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, true);\n\n\trv6xx_enable_auto_throttle_source(rdev, RADEON_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\n\n\tr600_start_dpm(rdev);\n\n\tif (pi->voltage_control)\n\t\trv6xx_enable_static_voltage_control(rdev, boot_ps, false);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\trv6xx_enable_dynamic_pcie_gen2(rdev, boot_ps, true);\n\n\tif (pi->gfx_clock_gating)\n\t\tr600_gfx_clockgating_enable(rdev, true);\n\n\treturn 0;\n}\n\nvoid rv6xx_dpm_disable(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tstruct radeon_ps *boot_ps = rdev->pm.dpm.boot_ps;\n\n\tif (!r600_dynamicpm_enabled(rdev))\n\t\treturn;\n\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\n\trv6xx_enable_display_gap(rdev, false);\n\trv6xx_clear_vc(rdev);\n\tr600_set_at(rdev, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF);\n\n\tif (pi->thermal_protection)\n\t\tr600_enable_thermal_protection(rdev, false);\n\n\tr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv6xx_enable_backbias(rdev, false);\n\n\trv6xx_enable_spread_spectrum(rdev, false);\n\n\tif (pi->voltage_control)\n\t\trv6xx_enable_static_voltage_control(rdev, boot_ps, true);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\trv6xx_enable_dynamic_pcie_gen2(rdev, boot_ps, false);\n\n\tif (rdev->irq.installed &&\n\t    r600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\n\t\trdev->irq.dpm_thermal = false;\n\t\tradeon_irq_set(rdev);\n\t}\n\n\tif (pi->gfx_clock_gating)\n\t\tr600_gfx_clockgating_enable(rdev, false);\n\n\tr600_stop_dpm(rdev);\n}\n\nint rv6xx_dpm_set_power_state(struct radeon_device *rdev)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\tstruct radeon_ps *new_ps = rdev->pm.dpm.requested_ps;\n\tstruct radeon_ps *old_ps = rdev->pm.dpm.current_ps;\n\tint ret;\n\n\tpi->restricted_levels = 0;\n\n\trv6xx_set_uvd_clock_before_set_eng_clock(rdev, new_ps, old_ps);\n\n\trv6xx_clear_vc(rdev);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\n\tr600_set_at(rdev, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF);\n\n\tif (pi->thermal_protection)\n\t\tr600_enable_thermal_protection(rdev, false);\n\n\tr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\n\trv6xx_generate_transition_stepping(rdev, new_ps, old_ps);\n\trv6xx_program_power_level_medium_for_transition(rdev);\n\n\tif (pi->voltage_control) {\n\t\trv6xx_set_sw_voltage_to_safe(rdev, new_ps, old_ps);\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\n\t\t\trv6xx_set_sw_voltage_to_low(rdev, old_ps);\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv6xx_set_safe_backbias(rdev, new_ps, old_ps);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\trv6xx_set_safe_pcie_gen2(rdev, new_ps, old_ps);\n\n\tif (pi->voltage_control)\n\t\trv6xx_enable_dynamic_voltage_control(rdev, false);\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv6xx_enable_dynamic_backbias_control(rdev, false);\n\n\tif (pi->voltage_control) {\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\n\t\t\trv6xx_step_voltage_if_increasing(rdev, new_ps, old_ps);\n\t\tmsleep((rdev->pm.dpm.voltage_response_time + 999) / 1000);\n\t}\n\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, true);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, false);\n\tr600_wait_for_power_level_unequal(rdev, R600_POWER_LEVEL_LOW);\n\n\trv6xx_generate_low_step(rdev, new_ps);\n\trv6xx_invalidate_intermediate_steps(rdev);\n\trv6xx_calculate_stepping_parameters(rdev, new_ps);\n\trv6xx_program_stepping_parameters_lowest_entry(rdev);\n\trv6xx_program_power_level_low_to_lowest_state(rdev);\n\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\n\tr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\n\tif (pi->voltage_control) {\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC) {\n\t\t\tret = rv6xx_step_voltage_if_decreasing(rdev, new_ps, old_ps);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\trv6xx_enable_dynamic_voltage_control(rdev, true);\n\t}\n\n\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS)\n\t\trv6xx_enable_dynamic_backbias_control(rdev, true);\n\n\tif (pi->dynamic_pcie_gen2)\n\t\trv6xx_enable_dynamic_pcie_gen2(rdev, new_ps, true);\n\n\trv6xx_reset_lvtm_data_sync(rdev);\n\n\trv6xx_generate_stepping_table(rdev, new_ps);\n\trv6xx_program_stepping_parameters_except_lowest_entry(rdev);\n\trv6xx_program_power_level_low(rdev);\n\trv6xx_program_power_level_medium(rdev);\n\trv6xx_program_power_level_high(rdev);\n\trv6xx_enable_medium(rdev);\n\trv6xx_enable_high(rdev);\n\n\tif (pi->thermal_protection)\n\t\trv6xx_enable_thermal_protection(rdev, true);\n\trv6xx_program_vc(rdev);\n\trv6xx_program_at(rdev);\n\n\trv6xx_set_uvd_clock_after_set_eng_clock(rdev, new_ps, old_ps);\n\n\treturn 0;\n}\n\nvoid rv6xx_setup_asic(struct radeon_device *rdev)\n{\n\tr600_enable_acpi_pm(rdev);\n\n\tif (radeon_aspm != 0) {\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L0s)\n\t\t\trv6xx_enable_l0s(rdev);\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_ASPM_L1)\n\t\t\trv6xx_enable_l1(rdev);\n\t\tif (rdev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1)\n\t\t\trv6xx_enable_pll_sleep_in_l1(rdev);\n\t}\n}\n\nvoid rv6xx_dpm_display_configuration_changed(struct radeon_device *rdev)\n{\n\trv6xx_program_display_gap(rdev);\n}\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n};\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic void rv6xx_parse_pplib_non_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ps *rps,\n\t\t\t\t\t     struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info)\n{\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (r600_is_uvd_state(rps->class, rps->class2)) {\n\t\trps->vclk = RV6XX_DEFAULT_VCLK_FREQ;\n\t\trps->dclk = RV6XX_DEFAULT_DCLK_FREQ;\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\trdev->pm.dpm.boot_ps = rps;\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\trdev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void rv6xx_parse_pplib_clock_info(struct radeon_device *rdev,\n\t\t\t\t\t struct radeon_ps *rps, int index,\n\t\t\t\t\t union pplib_clock_info *clock_info)\n{\n\tstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\n\tu32 sclk, mclk;\n\tu16 vddc;\n\tstruct rv6xx_pl *pl;\n\n\tswitch (index) {\n\tcase 0:\n\t\tpl = &ps->low;\n\t\tbreak;\n\tcase 1:\n\t\tpl = &ps->medium;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tpl = &ps->high;\n\t\tbreak;\n\t}\n\n\tsclk = le16_to_cpu(clock_info->r600.usEngineClockLow);\n\tsclk |= clock_info->r600.ucEngineClockHigh << 16;\n\tmclk = le16_to_cpu(clock_info->r600.usMemoryClockLow);\n\tmclk |= clock_info->r600.ucMemoryClockHigh << 16;\n\n\tpl->mclk = mclk;\n\tpl->sclk = sclk;\n\tpl->vddc = le16_to_cpu(clock_info->r600.usVDDC);\n\tpl->flags = le32_to_cpu(clock_info->r600.ulFlags);\n\n\t \n\tif (pl->vddc == 0xff01) {\n\t\tif (radeon_atom_get_max_vddc(rdev, 0, 0, &vddc) == 0)\n\t\t\tpl->vddc = vddc;\n\t}\n\n\t \n\tif (pl->flags & ATOM_PPLIB_R600_FLAGS_PCIEGEN2) {\n\t\tif ((rdev->family == CHIP_RV610) || (rdev->family == CHIP_RV630)) {\n\t\t\tif (pl->vddc < 1100)\n\t\t\t\tpl->flags &= ~ATOM_PPLIB_R600_FLAGS_PCIEGEN2;\n\t\t}\n\t}\n\n\t \n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\tu16 vddc, vddci, mvdd;\n\t\tradeon_atombios_get_default_voltages(rdev, &vddc, &vddci, &mvdd);\n\t\tpl->mclk = rdev->clock.default_mclk;\n\t\tpl->sclk = rdev->clock.default_sclk;\n\t\tpl->vddc = vddc;\n\t}\n}\n\nstatic int rv6xx_parse_power_table(struct radeon_device *rdev)\n{\n\tstruct radeon_mode_info *mode_info = &rdev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j;\n\tunion pplib_clock_info *clock_info;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tstruct rv6xx_ps *ps;\n\n\tif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\trdev->pm.dpm.ps = kcalloc(power_info->pplib.ucNumStates,\n\t\t\t\t  sizeof(struct radeon_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!rdev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < power_info->pplib.ucNumStates; i++) {\n\t\tpower_state = (union pplib_power_state *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset) +\n\t\t\t i * power_info->pplib.ucStateEntrySize);\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset) +\n\t\t\t (power_state->v1.ucNonClockStateIndex *\n\t\t\t  power_info->pplib.ucNonClockSize));\n\t\tif (power_info->pplib.ucStateEntrySize - 1) {\n\t\t\tu8 *idx;\n\t\t\tps = kzalloc(sizeof(struct rv6xx_ps), GFP_KERNEL);\n\t\t\tif (ps == NULL) {\n\t\t\t\tkfree(rdev->pm.dpm.ps);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\trdev->pm.dpm.ps[i].ps_priv = ps;\n\t\t\trv6xx_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\n\t\t\t\t\t\t\t non_clock_info);\n\t\t\tidx = (u8 *)&power_state->v1.ucClockStateIndices[0];\n\t\t\tfor (j = 0; j < (power_info->pplib.ucStateEntrySize - 1); j++) {\n\t\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset) +\n\t\t\t\t\t (idx[j] * power_info->pplib.ucClockInfoSize));\n\t\t\t\trv6xx_parse_pplib_clock_info(rdev,\n\t\t\t\t\t\t\t     &rdev->pm.dpm.ps[i], j,\n\t\t\t\t\t\t\t     clock_info);\n\t\t\t}\n\t\t}\n\t}\n\trdev->pm.dpm.num_ps = power_info->pplib.ucNumStates;\n\treturn 0;\n}\n\nint rv6xx_dpm_init(struct radeon_device *rdev)\n{\n\tstruct radeon_atom_ss ss;\n\tstruct atom_clock_dividers dividers;\n\tstruct rv6xx_power_info *pi;\n\tint ret;\n\n\tpi = kzalloc(sizeof(struct rv6xx_power_info), GFP_KERNEL);\n\tif (pi == NULL)\n\t\treturn -ENOMEM;\n\trdev->pm.dpm.priv = pi;\n\n\tret = r600_get_platform_caps(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rv6xx_parse_power_table(rdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rdev->pm.dpm.voltage_response_time == 0)\n\t\trdev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\n\tif (rdev->pm.dpm.backbias_response_time == 0)\n\t\trdev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     0, false, &dividers);\n\tif (ret)\n\t\tpi->spll_ref_div = dividers.ref_div + 1;\n\telse\n\t\tpi->spll_ref_div = R600_REFERENCEDIVIDER_DFLT;\n\n\tret = radeon_atom_get_clock_dividers(rdev, COMPUTE_MEMORY_PLL_PARAM,\n\t\t\t\t\t     0, false, &dividers);\n\tif (ret)\n\t\tpi->mpll_ref_div = dividers.ref_div + 1;\n\telse\n\t\tpi->mpll_ref_div = R600_REFERENCEDIVIDER_DFLT;\n\n\tif (rdev->family >= CHIP_RV670)\n\t\tpi->fb_div_scale = 1;\n\telse\n\t\tpi->fb_div_scale = 0;\n\n\tpi->voltage_control =\n\t\tradeon_atom_is_voltage_gpio(rdev, SET_VOLTAGE_TYPE_ASIC_VDDC, 0);\n\n\tpi->gfx_clock_gating = true;\n\n\tpi->sclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t       ASIC_INTERNAL_ENGINE_SS, 0);\n\tpi->mclk_ss = radeon_atombios_get_asic_ss_info(rdev, &ss,\n\t\t\t\t\t\t       ASIC_INTERNAL_MEMORY_SS, 0);\n\n\t \n\tpi->sclk_ss = false;\n\n\tif (pi->sclk_ss || pi->mclk_ss)\n\t\tpi->dynamic_ss = true;\n\telse\n\t\tpi->dynamic_ss = false;\n\n\tpi->dynamic_pcie_gen2 = true;\n\n\tif (pi->gfx_clock_gating &&\n\t    (rdev->pm.int_thermal_type != THERMAL_TYPE_NONE))\n\t\tpi->thermal_protection = true;\n\telse\n\t\tpi->thermal_protection = false;\n\n\tpi->display_gap = true;\n\n\treturn 0;\n}\n\nvoid rv6xx_dpm_print_power_state(struct radeon_device *rdev,\n\t\t\t\t struct radeon_ps *rps)\n{\n\tstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\n\tstruct rv6xx_pl *pl;\n\n\tr600_dpm_print_class_info(rps->class, rps->class2);\n\tr600_dpm_print_cap_info(rps->caps);\n\tprintk(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tpl = &ps->low;\n\tprintk(\"\\t\\tpower level 0    sclk: %u mclk: %u vddc: %u\\n\",\n\t       pl->sclk, pl->mclk, pl->vddc);\n\tpl = &ps->medium;\n\tprintk(\"\\t\\tpower level 1    sclk: %u mclk: %u vddc: %u\\n\",\n\t       pl->sclk, pl->mclk, pl->vddc);\n\tpl = &ps->high;\n\tprintk(\"\\t\\tpower level 2    sclk: %u mclk: %u vddc: %u\\n\",\n\t       pl->sclk, pl->mclk, pl->vddc);\n\tr600_dpm_print_ps_status(rdev, rps);\n}\n\nvoid rv6xx_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\n\t\t\t\t\t\t       struct seq_file *m)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\n\tstruct rv6xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\n\t\tCURRENT_PROFILE_INDEX_SHIFT;\n\n\tif (current_index > 2) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tif (current_index == 0)\n\t\t\tpl = &ps->low;\n\t\telse if (current_index == 1)\n\t\t\tpl = &ps->medium;\n\t\telse  \n\t\t\tpl = &ps->high;\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tseq_printf(m, \"power level %d    sclk: %u mclk: %u vddc: %u\\n\",\n\t\t\t   current_index, pl->sclk, pl->mclk, pl->vddc);\n\t}\n}\n\n \nu32 rv6xx_dpm_get_current_sclk(struct radeon_device *rdev)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\n\tstruct rv6xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\n\t\tCURRENT_PROFILE_INDEX_SHIFT;\n\n\tif (current_index > 2) {\n\t\treturn 0;\n\t} else {\n\t\tif (current_index == 0)\n\t\t\tpl = &ps->low;\n\t\telse if (current_index == 1)\n\t\t\tpl = &ps->medium;\n\t\telse  \n\t\t\tpl = &ps->high;\n\t\treturn pl->sclk;\n\t}\n}\n\n \nu32 rv6xx_dpm_get_current_mclk(struct radeon_device *rdev)\n{\n\tstruct radeon_ps *rps = rdev->pm.dpm.current_ps;\n\tstruct rv6xx_ps *ps = rv6xx_get_ps(rps);\n\tstruct rv6xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_PROFILE_INDEX_MASK) >>\n\t\tCURRENT_PROFILE_INDEX_SHIFT;\n\n\tif (current_index > 2) {\n\t\treturn 0;\n\t} else {\n\t\tif (current_index == 0)\n\t\t\tpl = &ps->low;\n\t\telse if (current_index == 1)\n\t\t\tpl = &ps->medium;\n\t\telse  \n\t\t\tpl = &ps->high;\n\t\treturn pl->mclk;\n\t}\n}\n\nvoid rv6xx_dpm_fini(struct radeon_device *rdev)\n{\n\tint i;\n\n\tfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\n\t\tkfree(rdev->pm.dpm.ps[i].ps_priv);\n\t}\n\tkfree(rdev->pm.dpm.ps);\n\tkfree(rdev->pm.dpm.priv);\n}\n\nu32 rv6xx_dpm_get_sclk(struct radeon_device *rdev, bool low)\n{\n\tstruct rv6xx_ps *requested_state = rv6xx_get_ps(rdev->pm.dpm.requested_ps);\n\n\tif (low)\n\t\treturn requested_state->low.sclk;\n\telse\n\t\treturn requested_state->high.sclk;\n}\n\nu32 rv6xx_dpm_get_mclk(struct radeon_device *rdev, bool low)\n{\n\tstruct rv6xx_ps *requested_state = rv6xx_get_ps(rdev->pm.dpm.requested_ps);\n\n\tif (low)\n\t\treturn requested_state->low.mclk;\n\telse\n\t\treturn requested_state->high.mclk;\n}\n\nint rv6xx_dpm_force_performance_level(struct radeon_device *rdev,\n\t\t\t\t      enum radeon_dpm_forced_level level)\n{\n\tstruct rv6xx_power_info *pi = rv6xx_get_pi(rdev);\n\n\tif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\n\t\tpi->restricted_levels = 3;\n\t} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\n\t\tpi->restricted_levels = 2;\n\t} else {\n\t\tpi->restricted_levels = 0;\n\t}\n\n\trv6xx_clear_vc(rdev);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, true);\n\tr600_set_at(rdev, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF);\n\tr600_wait_for_power_level(rdev, R600_POWER_LEVEL_LOW);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_HIGH, false);\n\tr600_power_level_enable(rdev, R600_POWER_LEVEL_MEDIUM, false);\n\trv6xx_enable_medium(rdev);\n\trv6xx_enable_high(rdev);\n\tif (pi->restricted_levels == 3)\n\t\tr600_power_level_enable(rdev, R600_POWER_LEVEL_LOW, false);\n\trv6xx_program_vc(rdev);\n\trv6xx_program_at(rdev);\n\n\trdev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}