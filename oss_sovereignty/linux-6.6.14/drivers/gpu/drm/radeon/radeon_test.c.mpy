{
  "module_name": "radeon_test.c",
  "hash_id": "61f1a506fa596ac4e36335102e5096e516467d8a27d65481f725cb8dcf8a5070",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_test.c",
  "human_readable_source": "\n \n\n#include <drm/radeon_drm.h>\n#include \"radeon_reg.h\"\n#include \"radeon.h\"\n\n#define RADEON_TEST_COPY_BLIT 1\n#define RADEON_TEST_COPY_DMA  0\n\n\n \nstatic void radeon_do_test_moves(struct radeon_device *rdev, int flag)\n{\n\tstruct radeon_bo *vram_obj = NULL;\n\tstruct radeon_bo **gtt_obj = NULL;\n\tuint64_t gtt_addr, vram_addr;\n\tunsigned n, size;\n\tint i, r, ring;\n\n\tswitch (flag) {\n\tcase RADEON_TEST_COPY_DMA:\n\t\tring = radeon_copy_dma_ring_index(rdev);\n\t\tbreak;\n\tcase RADEON_TEST_COPY_BLIT:\n\t\tring = radeon_copy_blit_ring_index(rdev);\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown copy method\\n\");\n\t\treturn;\n\t}\n\n\tsize = 1024 * 1024;\n\n\t \n\tn = rdev->mc.gtt_size - rdev->gart_pin_size;\n\tn /= size;\n\n\tgtt_obj = kcalloc(n, sizeof(*gtt_obj), GFP_KERNEL);\n\tif (!gtt_obj) {\n\t\tDRM_ERROR(\"Failed to allocate %d pointers\\n\", n);\n\t\tr = 1;\n\t\tgoto out_cleanup;\n\t}\n\n\tr = radeon_bo_create(rdev, size, PAGE_SIZE, true, RADEON_GEM_DOMAIN_VRAM,\n\t\t\t     0, NULL, NULL, &vram_obj);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to create VRAM object\\n\");\n\t\tgoto out_cleanup;\n\t}\n\tr = radeon_bo_reserve(vram_obj, false);\n\tif (unlikely(r != 0))\n\t\tgoto out_unref;\n\tr = radeon_bo_pin(vram_obj, RADEON_GEM_DOMAIN_VRAM, &vram_addr);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to pin VRAM object\\n\");\n\t\tgoto out_unres;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tvoid *gtt_map, *vram_map;\n\t\tvoid **gtt_start, **gtt_end;\n\t\tvoid **vram_start, **vram_end;\n\t\tstruct radeon_fence *fence = NULL;\n\n\t\tr = radeon_bo_create(rdev, size, PAGE_SIZE, true,\n\t\t\t\t     RADEON_GEM_DOMAIN_GTT, 0, NULL, NULL,\n\t\t\t\t     gtt_obj + i);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to create GTT object %d\\n\", i);\n\t\t\tgoto out_lclean;\n\t\t}\n\n\t\tr = radeon_bo_reserve(gtt_obj[i], false);\n\t\tif (unlikely(r != 0))\n\t\t\tgoto out_lclean_unref;\n\t\tr = radeon_bo_pin(gtt_obj[i], RADEON_GEM_DOMAIN_GTT, &gtt_addr);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to pin GTT object %d\\n\", i);\n\t\t\tgoto out_lclean_unres;\n\t\t}\n\n\t\tr = radeon_bo_kmap(gtt_obj[i], &gtt_map);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to map GTT object %d\\n\", i);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tfor (gtt_start = gtt_map, gtt_end = gtt_map + size;\n\t\t     gtt_start < gtt_end;\n\t\t     gtt_start++)\n\t\t\t*gtt_start = gtt_start;\n\n\t\tradeon_bo_kunmap(gtt_obj[i]);\n\n\t\tif (ring == R600_RING_TYPE_DMA_INDEX)\n\t\t\tfence = radeon_copy_dma(rdev, gtt_addr, vram_addr,\n\t\t\t\t\t\tsize / RADEON_GPU_PAGE_SIZE,\n\t\t\t\t\t\tvram_obj->tbo.base.resv);\n\t\telse\n\t\t\tfence = radeon_copy_blit(rdev, gtt_addr, vram_addr,\n\t\t\t\t\t\t size / RADEON_GPU_PAGE_SIZE,\n\t\t\t\t\t\t vram_obj->tbo.base.resv);\n\t\tif (IS_ERR(fence)) {\n\t\t\tDRM_ERROR(\"Failed GTT->VRAM copy %d\\n\", i);\n\t\t\tr = PTR_ERR(fence);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tr = radeon_fence_wait(fence, false);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to wait for GTT->VRAM fence %d\\n\", i);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tradeon_fence_unref(&fence);\n\n\t\tr = radeon_bo_kmap(vram_obj, &vram_map);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to map VRAM object after copy %d\\n\", i);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tfor (gtt_start = gtt_map, gtt_end = gtt_map + size,\n\t\t     vram_start = vram_map, vram_end = vram_map + size;\n\t\t     vram_start < vram_end;\n\t\t     gtt_start++, vram_start++) {\n\t\t\tif (*vram_start != gtt_start) {\n\t\t\t\tDRM_ERROR(\"Incorrect GTT->VRAM copy %d: Got 0x%p, \"\n\t\t\t\t\t  \"expected 0x%p (GTT/VRAM offset \"\n\t\t\t\t\t  \"0x%16llx/0x%16llx)\\n\",\n\t\t\t\t\t  i, *vram_start, gtt_start,\n\t\t\t\t\t  (unsigned long long)\n\t\t\t\t\t  (gtt_addr - rdev->mc.gtt_start +\n\t\t\t\t\t   (void *)gtt_start - gtt_map),\n\t\t\t\t\t  (unsigned long long)\n\t\t\t\t\t  (vram_addr - rdev->mc.vram_start +\n\t\t\t\t\t   (void *)gtt_start - gtt_map));\n\t\t\t\tradeon_bo_kunmap(vram_obj);\n\t\t\t\tgoto out_lclean_unpin;\n\t\t\t}\n\t\t\t*vram_start = vram_start;\n\t\t}\n\n\t\tradeon_bo_kunmap(vram_obj);\n\n\t\tif (ring == R600_RING_TYPE_DMA_INDEX)\n\t\t\tfence = radeon_copy_dma(rdev, vram_addr, gtt_addr,\n\t\t\t\t\t\tsize / RADEON_GPU_PAGE_SIZE,\n\t\t\t\t\t\tvram_obj->tbo.base.resv);\n\t\telse\n\t\t\tfence = radeon_copy_blit(rdev, vram_addr, gtt_addr,\n\t\t\t\t\t\t size / RADEON_GPU_PAGE_SIZE,\n\t\t\t\t\t\t vram_obj->tbo.base.resv);\n\t\tif (IS_ERR(fence)) {\n\t\t\tDRM_ERROR(\"Failed VRAM->GTT copy %d\\n\", i);\n\t\t\tr = PTR_ERR(fence);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tr = radeon_fence_wait(fence, false);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to wait for VRAM->GTT fence %d\\n\", i);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tradeon_fence_unref(&fence);\n\n\t\tr = radeon_bo_kmap(gtt_obj[i], &gtt_map);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to map GTT object after copy %d\\n\", i);\n\t\t\tgoto out_lclean_unpin;\n\t\t}\n\n\t\tfor (gtt_start = gtt_map, gtt_end = gtt_map + size,\n\t\t     vram_start = vram_map, vram_end = vram_map + size;\n\t\t     gtt_start < gtt_end;\n\t\t     gtt_start++, vram_start++) {\n\t\t\tif (*gtt_start != vram_start) {\n\t\t\t\tDRM_ERROR(\"Incorrect VRAM->GTT copy %d: Got 0x%p, \"\n\t\t\t\t\t  \"expected 0x%p (VRAM/GTT offset \"\n\t\t\t\t\t  \"0x%16llx/0x%16llx)\\n\",\n\t\t\t\t\t  i, *gtt_start, vram_start,\n\t\t\t\t\t  (unsigned long long)\n\t\t\t\t\t  (vram_addr - rdev->mc.vram_start +\n\t\t\t\t\t   (void *)vram_start - vram_map),\n\t\t\t\t\t  (unsigned long long)\n\t\t\t\t\t  (gtt_addr - rdev->mc.gtt_start +\n\t\t\t\t\t   (void *)vram_start - vram_map));\n\t\t\t\tradeon_bo_kunmap(gtt_obj[i]);\n\t\t\t\tgoto out_lclean_unpin;\n\t\t\t}\n\t\t}\n\n\t\tradeon_bo_kunmap(gtt_obj[i]);\n\n\t\tDRM_INFO(\"Tested GTT->VRAM and VRAM->GTT copy for GTT offset 0x%llx\\n\",\n\t\t\t gtt_addr - rdev->mc.gtt_start);\n\t\tcontinue;\n\nout_lclean_unpin:\n\t\tradeon_bo_unpin(gtt_obj[i]);\nout_lclean_unres:\n\t\tradeon_bo_unreserve(gtt_obj[i]);\nout_lclean_unref:\n\t\tradeon_bo_unref(&gtt_obj[i]);\nout_lclean:\n\t\tfor (--i; i >= 0; --i) {\n\t\t\tradeon_bo_unpin(gtt_obj[i]);\n\t\t\tradeon_bo_unreserve(gtt_obj[i]);\n\t\t\tradeon_bo_unref(&gtt_obj[i]);\n\t\t}\n\t\tif (fence && !IS_ERR(fence))\n\t\t\tradeon_fence_unref(&fence);\n\t\tbreak;\n\t}\n\n\tradeon_bo_unpin(vram_obj);\nout_unres:\n\tradeon_bo_unreserve(vram_obj);\nout_unref:\n\tradeon_bo_unref(&vram_obj);\nout_cleanup:\n\tkfree(gtt_obj);\n\tif (r) {\n\t\tpr_warn(\"Error while testing BO move\\n\");\n\t}\n}\n\nvoid radeon_test_moves(struct radeon_device *rdev)\n{\n\tif (rdev->asic->copy.dma)\n\t\tradeon_do_test_moves(rdev, RADEON_TEST_COPY_DMA);\n\tif (rdev->asic->copy.blit)\n\t\tradeon_do_test_moves(rdev, RADEON_TEST_COPY_BLIT);\n}\n\nstatic int radeon_test_create_and_emit_fence(struct radeon_device *rdev,\n\t\t\t\t\t     struct radeon_ring *ring,\n\t\t\t\t\t     struct radeon_fence **fence)\n{\n\tuint32_t handle = ring->idx ^ 0xdeafbeef;\n\tint r;\n\n\tif (ring->idx == R600_RING_TYPE_UVD_INDEX) {\n\t\tr = radeon_uvd_get_create_msg(rdev, ring->idx, handle, NULL);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to get dummy create msg\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tr = radeon_uvd_get_destroy_msg(rdev, ring->idx, handle, fence);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to get dummy destroy msg\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t} else if (ring->idx == TN_RING_TYPE_VCE1_INDEX ||\n\t\t   ring->idx == TN_RING_TYPE_VCE2_INDEX) {\n\t\tr = radeon_vce_get_create_msg(rdev, ring->idx, handle, NULL);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to get dummy create msg\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t\tr = radeon_vce_get_destroy_msg(rdev, ring->idx, handle, fence);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to get dummy destroy msg\\n\");\n\t\t\treturn r;\n\t\t}\n\n\t} else {\n\t\tr = radeon_ring_lock(rdev, ring, 64);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to lock ring A %d\\n\", ring->idx);\n\t\t\treturn r;\n\t\t}\n\t\tr = radeon_fence_emit(rdev, fence, ring->idx);\n\t\tif (r) {\n\t\t\tDRM_ERROR(\"Failed to emit fence\\n\");\n\t\t\tradeon_ring_unlock_undo(rdev, ring);\n\t\t\treturn r;\n\t\t}\n\t\tradeon_ring_unlock_commit(rdev, ring, false);\n\t}\n\treturn 0;\n}\n\nvoid radeon_test_ring_sync(struct radeon_device *rdev,\n\t\t\t   struct radeon_ring *ringA,\n\t\t\t   struct radeon_ring *ringB)\n{\n\tstruct radeon_fence *fence1 = NULL, *fence2 = NULL;\n\tstruct radeon_semaphore *semaphore = NULL;\n\tint r;\n\n\tr = radeon_semaphore_create(rdev, &semaphore);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to create semaphore\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tr = radeon_ring_lock(rdev, ringA, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring A %d\\n\", ringA->idx);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringA, false);\n\n\tr = radeon_test_create_and_emit_fence(rdev, ringA, &fence1);\n\tif (r)\n\t\tgoto out_cleanup;\n\n\tr = radeon_ring_lock(rdev, ringA, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring A %d\\n\", ringA->idx);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringA, false);\n\n\tr = radeon_test_create_and_emit_fence(rdev, ringA, &fence2);\n\tif (r)\n\t\tgoto out_cleanup;\n\n\tmsleep(1000);\n\n\tif (radeon_fence_signaled(fence1)) {\n\t\tDRM_ERROR(\"Fence 1 signaled without waiting for semaphore.\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tr = radeon_ring_lock(rdev, ringB, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring B %p\\n\", ringB);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_signal(rdev, ringB->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringB, false);\n\n\tr = radeon_fence_wait(fence1, false);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to wait for sync fence 1\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tmsleep(1000);\n\n\tif (radeon_fence_signaled(fence2)) {\n\t\tDRM_ERROR(\"Fence 2 signaled without waiting for semaphore.\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tr = radeon_ring_lock(rdev, ringB, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring B %p\\n\", ringB);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_signal(rdev, ringB->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringB, false);\n\n\tr = radeon_fence_wait(fence2, false);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to wait for sync fence 1\\n\");\n\t\tgoto out_cleanup;\n\t}\n\nout_cleanup:\n\tradeon_semaphore_free(rdev, &semaphore, NULL);\n\n\tif (fence1)\n\t\tradeon_fence_unref(&fence1);\n\n\tif (fence2)\n\t\tradeon_fence_unref(&fence2);\n\n\tif (r)\n\t\tpr_warn(\"Error while testing ring sync (%d)\\n\", r);\n}\n\nstatic void radeon_test_ring_sync2(struct radeon_device *rdev,\n\t\t\t    struct radeon_ring *ringA,\n\t\t\t    struct radeon_ring *ringB,\n\t\t\t    struct radeon_ring *ringC)\n{\n\tstruct radeon_fence *fenceA = NULL, *fenceB = NULL;\n\tstruct radeon_semaphore *semaphore = NULL;\n\tbool sigA, sigB;\n\tint i, r;\n\n\tr = radeon_semaphore_create(rdev, &semaphore);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to create semaphore\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tr = radeon_ring_lock(rdev, ringA, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring A %d\\n\", ringA->idx);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_wait(rdev, ringA->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringA, false);\n\n\tr = radeon_test_create_and_emit_fence(rdev, ringA, &fenceA);\n\tif (r)\n\t\tgoto out_cleanup;\n\n\tr = radeon_ring_lock(rdev, ringB, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring B %d\\n\", ringB->idx);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_wait(rdev, ringB->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringB, false);\n\tr = radeon_test_create_and_emit_fence(rdev, ringB, &fenceB);\n\tif (r)\n\t\tgoto out_cleanup;\n\n\tmsleep(1000);\n\n\tif (radeon_fence_signaled(fenceA)) {\n\t\tDRM_ERROR(\"Fence A signaled without waiting for semaphore.\\n\");\n\t\tgoto out_cleanup;\n\t}\n\tif (radeon_fence_signaled(fenceB)) {\n\t\tDRM_ERROR(\"Fence B signaled without waiting for semaphore.\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tr = radeon_ring_lock(rdev, ringC, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring B %p\\n\", ringC);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_signal(rdev, ringC->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringC, false);\n\n\tfor (i = 0; i < 30; ++i) {\n\t\tmsleep(100);\n\t\tsigA = radeon_fence_signaled(fenceA);\n\t\tsigB = radeon_fence_signaled(fenceB);\n\t\tif (sigA || sigB)\n\t\t\tbreak;\n\t}\n\n\tif (!sigA && !sigB) {\n\t\tDRM_ERROR(\"Neither fence A nor B has been signaled\\n\");\n\t\tgoto out_cleanup;\n\t} else if (sigA && sigB) {\n\t\tDRM_ERROR(\"Both fence A and B has been signaled\\n\");\n\t\tgoto out_cleanup;\n\t}\n\n\tDRM_INFO(\"Fence %c was first signaled\\n\", sigA ? 'A' : 'B');\n\n\tr = radeon_ring_lock(rdev, ringC, 64);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to lock ring B %p\\n\", ringC);\n\t\tgoto out_cleanup;\n\t}\n\tradeon_semaphore_emit_signal(rdev, ringC->idx, semaphore);\n\tradeon_ring_unlock_commit(rdev, ringC, false);\n\n\tmsleep(1000);\n\n\tr = radeon_fence_wait(fenceA, false);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to wait for sync fence A\\n\");\n\t\tgoto out_cleanup;\n\t}\n\tr = radeon_fence_wait(fenceB, false);\n\tif (r) {\n\t\tDRM_ERROR(\"Failed to wait for sync fence B\\n\");\n\t\tgoto out_cleanup;\n\t}\n\nout_cleanup:\n\tradeon_semaphore_free(rdev, &semaphore, NULL);\n\n\tif (fenceA)\n\t\tradeon_fence_unref(&fenceA);\n\n\tif (fenceB)\n\t\tradeon_fence_unref(&fenceB);\n\n\tif (r)\n\t\tpr_warn(\"Error while testing ring sync (%d)\\n\", r);\n}\n\nstatic bool radeon_test_sync_possible(struct radeon_ring *ringA,\n\t\t\t\t      struct radeon_ring *ringB)\n{\n\tif (ringA->idx == TN_RING_TYPE_VCE2_INDEX &&\n\t    ringB->idx == TN_RING_TYPE_VCE1_INDEX)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid radeon_test_syncing(struct radeon_device *rdev)\n{\n\tint i, j, k;\n\n\tfor (i = 1; i < RADEON_NUM_RINGS; ++i) {\n\t\tstruct radeon_ring *ringA = &rdev->ring[i];\n\t\tif (!ringA->ready)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < i; ++j) {\n\t\t\tstruct radeon_ring *ringB = &rdev->ring[j];\n\t\t\tif (!ringB->ready)\n\t\t\t\tcontinue;\n\n\t\t\tif (!radeon_test_sync_possible(ringA, ringB))\n\t\t\t\tcontinue;\n\n\t\t\tDRM_INFO(\"Testing syncing between rings %d and %d...\\n\", i, j);\n\t\t\tradeon_test_ring_sync(rdev, ringA, ringB);\n\n\t\t\tDRM_INFO(\"Testing syncing between rings %d and %d...\\n\", j, i);\n\t\t\tradeon_test_ring_sync(rdev, ringB, ringA);\n\n\t\t\tfor (k = 0; k < j; ++k) {\n\t\t\t\tstruct radeon_ring *ringC = &rdev->ring[k];\n\t\t\t\tif (!ringC->ready)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!radeon_test_sync_possible(ringA, ringC))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!radeon_test_sync_possible(ringB, ringC))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tDRM_INFO(\"Testing syncing between rings %d, %d and %d...\\n\", i, j, k);\n\t\t\t\tradeon_test_ring_sync2(rdev, ringA, ringB, ringC);\n\n\t\t\t\tDRM_INFO(\"Testing syncing between rings %d, %d and %d...\\n\", i, k, j);\n\t\t\t\tradeon_test_ring_sync2(rdev, ringA, ringC, ringB);\n\n\t\t\t\tDRM_INFO(\"Testing syncing between rings %d, %d and %d...\\n\", j, i, k);\n\t\t\t\tradeon_test_ring_sync2(rdev, ringB, ringA, ringC);\n\n\t\t\t\tDRM_INFO(\"Testing syncing between rings %d, %d and %d...\\n\", j, k, i);\n\t\t\t\tradeon_test_ring_sync2(rdev, ringB, ringC, ringA);\n\n\t\t\t\tDRM_INFO(\"Testing syncing between rings %d, %d and %d...\\n\", k, i, j);\n\t\t\t\tradeon_test_ring_sync2(rdev, ringC, ringA, ringB);\n\n\t\t\t\tDRM_INFO(\"Testing syncing between rings %d, %d and %d...\\n\", k, j, i);\n\t\t\t\tradeon_test_ring_sync2(rdev, ringC, ringB, ringA);\n\t\t\t}\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}