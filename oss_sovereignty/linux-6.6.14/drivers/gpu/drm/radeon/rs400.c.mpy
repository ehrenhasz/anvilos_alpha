{
  "module_name": "rs400.c",
  "hash_id": "0881a747dbd9f099bef581caecfeae022142c1837dab1ce99e7e8877d6b5f862",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/rs400.c",
  "human_readable_source": " \n\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_file.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"rs400d.h\"\n\n \nstatic void rs400_debugfs_pcie_gart_info_init(struct radeon_device *rdev);\n\nvoid rs400_gart_adjust_size(struct radeon_device *rdev)\n{\n\t \n\tswitch (rdev->mc.gtt_size/(1024*1024)) {\n\tcase 32:\n\tcase 64:\n\tcase 128:\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unable to use IGP GART size %uM\\n\",\n\t\t\t  (unsigned)(rdev->mc.gtt_size >> 20));\n\t\tDRM_ERROR(\"Valid GART size for IGP are 32M,64M,128M,256M,512M,1G,2G\\n\");\n\t\tDRM_ERROR(\"Forcing to 32M GART size\\n\");\n\t\trdev->mc.gtt_size = 32 * 1024 * 1024;\n\t\treturn;\n\t}\n}\n\nvoid rs400_gart_tlb_flush(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\tunsigned int timeout = rdev->usec_timeout;\n\n\tWREG32_MC(RS480_GART_CACHE_CNTRL, RS480_GART_CACHE_INVALIDATE);\n\tdo {\n\t\ttmp = RREG32_MC(RS480_GART_CACHE_CNTRL);\n\t\tif ((tmp & RS480_GART_CACHE_INVALIDATE) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t\ttimeout--;\n\t} while (timeout > 0);\n\tWREG32_MC(RS480_GART_CACHE_CNTRL, 0);\n}\n\nint rs400_gart_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\tif (rdev->gart.ptr) {\n\t\tWARN(1, \"RS400 GART already initialized\\n\");\n\t\treturn 0;\n\t}\n\t \n\tswitch(rdev->mc.gtt_size / (1024 * 1024)) {\n\tcase 32:\n\tcase 64:\n\tcase 128:\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tr = radeon_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\trs400_debugfs_pcie_gart_info_init(rdev);\n\trdev->gart.table_size = rdev->gart.num_gpu_pages * 4;\n\treturn radeon_gart_table_ram_alloc(rdev);\n}\n\nint rs400_gart_enable(struct radeon_device *rdev)\n{\n\tuint32_t size_reg;\n\tuint32_t tmp;\n\n\ttmp = RREG32_MC(RS690_AIC_CTRL_SCRATCH);\n\ttmp |= RS690_DIS_OUT_OF_PCI_GART_ACCESS;\n\tWREG32_MC(RS690_AIC_CTRL_SCRATCH, tmp);\n\t \n\tswitch(rdev->mc.gtt_size / (1024 * 1024)) {\n\tcase 32:\n\t\tsize_reg = RS480_VA_SIZE_32MB;\n\t\tbreak;\n\tcase 64:\n\t\tsize_reg = RS480_VA_SIZE_64MB;\n\t\tbreak;\n\tcase 128:\n\t\tsize_reg = RS480_VA_SIZE_128MB;\n\t\tbreak;\n\tcase 256:\n\t\tsize_reg = RS480_VA_SIZE_256MB;\n\t\tbreak;\n\tcase 512:\n\t\tsize_reg = RS480_VA_SIZE_512MB;\n\t\tbreak;\n\tcase 1024:\n\t\tsize_reg = RS480_VA_SIZE_1GB;\n\t\tbreak;\n\tcase 2048:\n\t\tsize_reg = RS480_VA_SIZE_2GB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (rdev->family == CHIP_RS690 || (rdev->family == CHIP_RS740)) {\n\t\tWREG32_MC(RS690_MCCFG_AGP_BASE, 0xFFFFFFFF);\n\t\tWREG32_MC(RS690_MCCFG_AGP_BASE_2, 0);\n\t} else {\n\t\tWREG32(RADEON_AGP_BASE, 0xFFFFFFFF);\n\t\tWREG32(RS480_AGP_BASE_2, 0);\n\t}\n\ttmp = REG_SET(RS690_MC_AGP_TOP, rdev->mc.gtt_end >> 16);\n\ttmp |= REG_SET(RS690_MC_AGP_START, rdev->mc.gtt_start >> 16);\n\tif ((rdev->family == CHIP_RS690) || (rdev->family == CHIP_RS740)) {\n\t\tWREG32_MC(RS690_MCCFG_AGP_LOCATION, tmp);\n\t\ttmp = RREG32(RADEON_BUS_CNTL) & ~RS600_BUS_MASTER_DIS;\n\t\tWREG32(RADEON_BUS_CNTL, tmp);\n\t} else {\n\t\tWREG32(RADEON_MC_AGP_LOCATION, tmp);\n\t\ttmp = RREG32(RADEON_BUS_CNTL) & ~RADEON_BUS_MASTER_DIS;\n\t\tWREG32(RADEON_BUS_CNTL, tmp);\n\t}\n\t \n\ttmp = (u32)rdev->gart.table_addr & 0xfffff000;\n\ttmp |= (upper_32_bits(rdev->gart.table_addr) & 0xff) << 4;\n\n\tWREG32_MC(RS480_GART_BASE, tmp);\n\t \n\tWREG32_MC(RS480_GART_FEATURE_ID,\n\t\t  (RS480_TLB_ENABLE |\n\t\t   RS480_GTW_LAC_EN | RS480_1LEVEL_GART));\n\t \n\tWREG32_MC(RS480_AGP_MODE_CNTL,\n\t\t  (1 << RS480_REQ_TYPE_SNOOP_SHIFT) | RS480_REQ_TYPE_SNOOP_DIS);\n\t \n\t \n\tif ((rdev->family == CHIP_RS690) || (rdev->family == CHIP_RS740)) {\n\t\ttmp = RREG32_MC(RS480_MC_MISC_CNTL);\n\t\ttmp |= RS480_GART_INDEX_REG_EN | RS690_BLOCK_GFX_D3_EN;\n\t\tWREG32_MC(RS480_MC_MISC_CNTL, tmp);\n\t} else {\n\t\ttmp = RREG32_MC(RS480_MC_MISC_CNTL);\n\t\ttmp |= RS480_GART_INDEX_REG_EN;\n\t\tWREG32_MC(RS480_MC_MISC_CNTL, tmp);\n\t}\n\t \n\tWREG32_MC(RS480_AGP_ADDRESS_SPACE_SIZE, (RS480_GART_EN | size_reg));\n\trs400_gart_tlb_flush(rdev);\n\tDRM_INFO(\"PCIE GART of %uM enabled (table at 0x%016llX).\\n\",\n\t\t (unsigned)(rdev->mc.gtt_size >> 20),\n\t\t (unsigned long long)rdev->gart.table_addr);\n\trdev->gart.ready = true;\n\treturn 0;\n}\n\nvoid rs400_gart_disable(struct radeon_device *rdev)\n{\n\tuint32_t tmp;\n\n\ttmp = RREG32_MC(RS690_AIC_CTRL_SCRATCH);\n\ttmp |= RS690_DIS_OUT_OF_PCI_GART_ACCESS;\n\tWREG32_MC(RS690_AIC_CTRL_SCRATCH, tmp);\n\tWREG32_MC(RS480_AGP_ADDRESS_SPACE_SIZE, 0);\n}\n\nvoid rs400_gart_fini(struct radeon_device *rdev)\n{\n\tradeon_gart_fini(rdev);\n\trs400_gart_disable(rdev);\n\tradeon_gart_table_ram_free(rdev);\n}\n\n#define RS400_PTE_UNSNOOPED (1 << 0)\n#define RS400_PTE_WRITEABLE (1 << 2)\n#define RS400_PTE_READABLE  (1 << 3)\n\nuint64_t rs400_gart_get_page_entry(uint64_t addr, uint32_t flags)\n{\n\tuint32_t entry;\n\n\tentry = (lower_32_bits(addr) & PAGE_MASK) |\n\t\t((upper_32_bits(addr) & 0xff) << 4);\n\tif (flags & RADEON_GART_PAGE_READ)\n\t\tentry |= RS400_PTE_READABLE;\n\tif (flags & RADEON_GART_PAGE_WRITE)\n\t\tentry |= RS400_PTE_WRITEABLE;\n\tif (!(flags & RADEON_GART_PAGE_SNOOP))\n\t\tentry |= RS400_PTE_UNSNOOPED;\n\treturn entry;\n}\n\nvoid rs400_gart_set_page(struct radeon_device *rdev, unsigned i,\n\t\t\t uint64_t entry)\n{\n\tu32 *gtt = rdev->gart.ptr;\n\tgtt[i] = cpu_to_le32(lower_32_bits(entry));\n}\n\nint rs400_mc_wait_for_idle(struct radeon_device *rdev)\n{\n\tunsigned i;\n\tuint32_t tmp;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\t \n\t\ttmp = RREG32(RADEON_MC_STATUS);\n\t\tif (tmp & RADEON_MC_IDLE) {\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(1);\n\t}\n\treturn -1;\n}\n\nstatic void rs400_gpu_init(struct radeon_device *rdev)\n{\n\t \n\tr420_pipes_init(rdev);\n\tif (rs400_mc_wait_for_idle(rdev)) {\n\t\tpr_warn(\"rs400: Failed to wait MC idle while programming pipes. Bad things might happen. %08x\\n\",\n\t\t\tRREG32(RADEON_MC_STATUS));\n\t}\n}\n\nstatic void rs400_mc_init(struct radeon_device *rdev)\n{\n\tu64 base;\n\n\trs400_gart_adjust_size(rdev);\n\trdev->mc.igp_sideport_enabled = radeon_combios_sideport_present(rdev);\n\t \n\trdev->mc.vram_is_ddr = true;\n\trdev->mc.vram_width = 128;\n\tr100_vram_init_sizes(rdev);\n\tbase = (RREG32(RADEON_NB_TOM) & 0xffff) << 16;\n\tradeon_vram_location(rdev, &rdev->mc, base);\n\trdev->mc.gtt_base_align = rdev->mc.gtt_size - 1;\n\tradeon_gtt_location(rdev, &rdev->mc);\n\tradeon_update_bandwidth_info(rdev);\n}\n\nuint32_t rs400_mc_rreg(struct radeon_device *rdev, uint32_t reg)\n{\n\tunsigned long flags;\n\tuint32_t r;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(RS480_NB_MC_INDEX, reg & 0xff);\n\tr = RREG32(RS480_NB_MC_DATA);\n\tWREG32(RS480_NB_MC_INDEX, 0xff);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n\treturn r;\n}\n\nvoid rs400_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rdev->mc_idx_lock, flags);\n\tWREG32(RS480_NB_MC_INDEX, ((reg) & 0xff) | RS480_NB_MC_IND_WR_EN);\n\tWREG32(RS480_NB_MC_DATA, (v));\n\tWREG32(RS480_NB_MC_INDEX, 0xff);\n\tspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\n}\n\n#if defined(CONFIG_DEBUG_FS)\nstatic int rs400_debugfs_gart_info_show(struct seq_file *m, void *unused)\n{\n\tstruct radeon_device *rdev = m->private;\n\tuint32_t tmp;\n\n\ttmp = RREG32(RADEON_HOST_PATH_CNTL);\n\tseq_printf(m, \"HOST_PATH_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32(RADEON_BUS_CNTL);\n\tseq_printf(m, \"BUS_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(RS690_AIC_CTRL_SCRATCH);\n\tseq_printf(m, \"AIC_CTRL_SCRATCH 0x%08x\\n\", tmp);\n\tif (rdev->family == CHIP_RS690 || (rdev->family == CHIP_RS740)) {\n\t\ttmp = RREG32_MC(RS690_MCCFG_AGP_BASE);\n\t\tseq_printf(m, \"MCCFG_AGP_BASE 0x%08x\\n\", tmp);\n\t\ttmp = RREG32_MC(RS690_MCCFG_AGP_BASE_2);\n\t\tseq_printf(m, \"MCCFG_AGP_BASE_2 0x%08x\\n\", tmp);\n\t\ttmp = RREG32_MC(RS690_MCCFG_AGP_LOCATION);\n\t\tseq_printf(m, \"MCCFG_AGP_LOCATION 0x%08x\\n\", tmp);\n\t\ttmp = RREG32_MC(RS690_MCCFG_FB_LOCATION);\n\t\tseq_printf(m, \"MCCFG_FB_LOCATION 0x%08x\\n\", tmp);\n\t\ttmp = RREG32(RS690_HDP_FB_LOCATION);\n\t\tseq_printf(m, \"HDP_FB_LOCATION 0x%08x\\n\", tmp);\n\t} else {\n\t\ttmp = RREG32(RADEON_AGP_BASE);\n\t\tseq_printf(m, \"AGP_BASE 0x%08x\\n\", tmp);\n\t\ttmp = RREG32(RS480_AGP_BASE_2);\n\t\tseq_printf(m, \"AGP_BASE_2 0x%08x\\n\", tmp);\n\t\ttmp = RREG32(RADEON_MC_AGP_LOCATION);\n\t\tseq_printf(m, \"MC_AGP_LOCATION 0x%08x\\n\", tmp);\n\t}\n\ttmp = RREG32_MC(RS480_GART_BASE);\n\tseq_printf(m, \"GART_BASE 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(RS480_GART_FEATURE_ID);\n\tseq_printf(m, \"GART_FEATURE_ID 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(RS480_AGP_MODE_CNTL);\n\tseq_printf(m, \"AGP_MODE_CONTROL 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(RS480_MC_MISC_CNTL);\n\tseq_printf(m, \"MC_MISC_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x5F);\n\tseq_printf(m, \"MC_MISC_UMA_CNTL 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(RS480_AGP_ADDRESS_SPACE_SIZE);\n\tseq_printf(m, \"AGP_ADDRESS_SPACE_SIZE 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(RS480_GART_CACHE_CNTRL);\n\tseq_printf(m, \"GART_CACHE_CNTRL 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x3B);\n\tseq_printf(m, \"MC_GART_ERROR_ADDRESS 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x3C);\n\tseq_printf(m, \"MC_GART_ERROR_ADDRESS_HI 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x30);\n\tseq_printf(m, \"GART_ERROR_0 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x31);\n\tseq_printf(m, \"GART_ERROR_1 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x32);\n\tseq_printf(m, \"GART_ERROR_2 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x33);\n\tseq_printf(m, \"GART_ERROR_3 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x34);\n\tseq_printf(m, \"GART_ERROR_4 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x35);\n\tseq_printf(m, \"GART_ERROR_5 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x36);\n\tseq_printf(m, \"GART_ERROR_6 0x%08x\\n\", tmp);\n\ttmp = RREG32_MC(0x37);\n\tseq_printf(m, \"GART_ERROR_7 0x%08x\\n\", tmp);\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rs400_debugfs_gart_info);\n#endif\n\nstatic void rs400_debugfs_pcie_gart_info_init(struct radeon_device *rdev)\n{\n#if defined(CONFIG_DEBUG_FS)\n\tstruct dentry *root = rdev->ddev->primary->debugfs_root;\n\n\tdebugfs_create_file(\"rs400_gart_info\", 0444, root, rdev,\n\t\t\t    &rs400_debugfs_gart_info_fops);\n#endif\n}\n\nstatic void rs400_mc_program(struct radeon_device *rdev)\n{\n\tstruct r100_mc_save save;\n\n\t \n\tr100_mc_stop(rdev, &save);\n\n\t \n\tif (rs400_mc_wait_for_idle(rdev))\n\t\tdev_warn(rdev->dev, \"rs400: Wait MC idle timeout before updating MC.\\n\");\n\tWREG32(R_000148_MC_FB_LOCATION,\n\t\tS_000148_MC_FB_START(rdev->mc.vram_start >> 16) |\n\t\tS_000148_MC_FB_TOP(rdev->mc.vram_end >> 16));\n\n\tr100_mc_resume(rdev, &save);\n}\n\nstatic int rs400_startup(struct radeon_device *rdev)\n{\n\tint r;\n\n\tr100_set_common_regs(rdev);\n\n\trs400_mc_program(rdev);\n\t \n\tr300_clock_startup(rdev);\n\t \n\trs400_gpu_init(rdev);\n\tr100_enable_bm(rdev);\n\t \n\tr = rs400_gart_enable(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\tr = radeon_wb_init(rdev);\n\tif (r)\n\t\treturn r;\n\n\tr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP fences (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\t \n\tif (!rdev->irq.installed) {\n\t\tr = radeon_irq_kms_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr100_irq_set(rdev);\n\trdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\n\t \n\tr = r100_cp_init(rdev, 1024 * 1024);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"failed initializing CP (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_ib_pool_init(rdev);\n\tif (r) {\n\t\tdev_err(rdev->dev, \"IB initialization failed (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint rs400_resume(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\trs400_gart_disable(rdev);\n\t \n\tr300_clock_startup(rdev);\n\t \n\trs400_mc_program(rdev);\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev, \"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tradeon_combios_asic_init(rdev->ddev);\n\t \n\tr300_clock_startup(rdev);\n\t \n\tradeon_surface_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rs400_startup(rdev);\n\tif (r) {\n\t\trdev->accel_working = false;\n\t}\n\treturn r;\n}\n\nint rs400_suspend(struct radeon_device *rdev)\n{\n\tradeon_pm_suspend(rdev);\n\tr100_cp_disable(rdev);\n\tradeon_wb_disable(rdev);\n\tr100_irq_disable(rdev);\n\trs400_gart_disable(rdev);\n\treturn 0;\n}\n\nvoid rs400_fini(struct radeon_device *rdev)\n{\n\tradeon_pm_fini(rdev);\n\tr100_cp_fini(rdev);\n\tradeon_wb_fini(rdev);\n\tradeon_ib_pool_fini(rdev);\n\tradeon_gem_fini(rdev);\n\trs400_gart_fini(rdev);\n\tradeon_irq_kms_fini(rdev);\n\tradeon_fence_driver_fini(rdev);\n\tradeon_bo_fini(rdev);\n\tradeon_atombios_fini(rdev);\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n}\n\nint rs400_init(struct radeon_device *rdev)\n{\n\tint r;\n\n\t \n\tr100_vga_render_disable(rdev);\n\t \n\tradeon_scratch_init(rdev);\n\t \n\tradeon_surface_init(rdev);\n\t \n\t \n\tr100_restore_sanity(rdev);\n\t \n\tif (!radeon_get_bios(rdev)) {\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\treturn -EINVAL;\n\t}\n\tif (rdev->is_atom_bios) {\n\t\tdev_err(rdev->dev, \"Expecting combios for RS400/RS480 GPU\\n\");\n\t\treturn -EINVAL;\n\t} else {\n\t\tr = radeon_combios_init(rdev);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\t \n\tif (radeon_asic_reset(rdev)) {\n\t\tdev_warn(rdev->dev,\n\t\t\t\"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\\n\",\n\t\t\tRREG32(R_000E40_RBBM_STATUS),\n\t\t\tRREG32(R_0007C0_CP_STAT));\n\t}\n\t \n\tif (radeon_boot_test_post_card(rdev) == false)\n\t\treturn -EINVAL;\n\n\t \n\tradeon_get_clock_info(rdev->ddev);\n\t \n\trs400_mc_init(rdev);\n\t \n\tradeon_fence_driver_init(rdev);\n\t \n\tr = radeon_bo_init(rdev);\n\tif (r)\n\t\treturn r;\n\tr = rs400_gart_init(rdev);\n\tif (r)\n\t\treturn r;\n\tr300_set_reg_safe(rdev);\n\n\t \n\tradeon_pm_init(rdev);\n\n\trdev->accel_working = true;\n\tr = rs400_startup(rdev);\n\tif (r) {\n\t\t \n\t\tdev_err(rdev->dev, \"Disabling GPU acceleration\\n\");\n\t\tr100_cp_fini(rdev);\n\t\tradeon_wb_fini(rdev);\n\t\tradeon_ib_pool_fini(rdev);\n\t\trs400_gart_fini(rdev);\n\t\tradeon_irq_kms_fini(rdev);\n\t\trdev->accel_working = false;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}