{
  "module_name": "radeon_kms.c",
  "hash_id": "adaca447a172dba95e732004a197d2aeefa122b7536739bff1937264a7dae9ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_kms.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_ioctl.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_drv.h\"\n#include \"radeon_kms.h\"\n\n#if defined(CONFIG_VGA_SWITCHEROO)\nbool radeon_has_atpx(void);\n#else\nstatic inline bool radeon_has_atpx(void) { return false; }\n#endif\n\n \nvoid radeon_driver_unload_kms(struct drm_device *dev)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (rdev == NULL)\n\t\treturn;\n\n\tif (rdev->rmmio == NULL)\n\t\tgoto done_free;\n\n\tif (radeon_is_px(dev)) {\n\t\tpm_runtime_get_sync(dev->dev);\n\t\tpm_runtime_forbid(dev->dev);\n\t}\n\n\tradeon_acpi_fini(rdev);\n\n\tradeon_modeset_fini(rdev);\n\tradeon_device_fini(rdev);\n\n\tif (rdev->agp)\n\t\tarch_phys_wc_del(rdev->agp->agp_mtrr);\n\tkfree(rdev->agp);\n\trdev->agp = NULL;\n\ndone_free:\n\tkfree(rdev);\n\tdev->dev_private = NULL;\n}\n\n \nint radeon_driver_load_kms(struct drm_device *dev, unsigned long flags)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct radeon_device *rdev;\n\tint r, acpi_status;\n\n\trdev = kzalloc(sizeof(struct radeon_device), GFP_KERNEL);\n\tif (rdev == NULL) {\n\t\treturn -ENOMEM;\n\t}\n\tdev->dev_private = (void *)rdev;\n\n#ifdef __alpha__\n\trdev->hose = pdev->sysdata;\n#endif\n\n\tif (pci_find_capability(pdev, PCI_CAP_ID_AGP))\n\t\trdev->agp = radeon_agp_head_init(dev);\n\tif (rdev->agp) {\n\t\trdev->agp->agp_mtrr = arch_phys_wc_add(\n\t\t\trdev->agp->agp_info.aper_base,\n\t\t\trdev->agp->agp_info.aper_size *\n\t\t\t1024 * 1024);\n\t}\n\n\t \n\tif (pci_find_capability(pdev, PCI_CAP_ID_AGP)) {\n\t\tflags |= RADEON_IS_AGP;\n\t} else if (pci_is_pcie(pdev)) {\n\t\tflags |= RADEON_IS_PCIE;\n\t} else {\n\t\tflags |= RADEON_IS_PCI;\n\t}\n\n\tif ((radeon_runtime_pm != 0) &&\n\t    radeon_has_atpx() &&\n\t    ((flags & RADEON_IS_IGP) == 0) &&\n\t    !pci_is_thunderbolt_attached(pdev))\n\t\tflags |= RADEON_IS_PX;\n\n\t \n\tr = radeon_device_init(rdev, dev, pdev, flags);\n\tif (r) {\n\t\tdev_err(dev->dev, \"Fatal error during GPU init\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tr = radeon_modeset_init(rdev);\n\tif (r)\n\t\tdev_err(dev->dev, \"Fatal error during modeset init\\n\");\n\n\t \n\tif (!r) {\n\t\tacpi_status = radeon_acpi_init(rdev);\n\t\tif (acpi_status)\n\t\t\tdev_dbg(dev->dev, \"Error during ACPI methods call\\n\");\n\t}\n\n\tif (radeon_is_px(dev)) {\n\t\tdev_pm_set_driver_flags(dev->dev, DPM_FLAG_NO_DIRECT_COMPLETE);\n\t\tpm_runtime_use_autosuspend(dev->dev);\n\t\tpm_runtime_set_autosuspend_delay(dev->dev, 5000);\n\t\tpm_runtime_set_active(dev->dev);\n\t\tpm_runtime_allow(dev->dev);\n\t\tpm_runtime_mark_last_busy(dev->dev);\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t}\n\nout:\n\tif (r)\n\t\tradeon_driver_unload_kms(dev);\n\n\n\treturn r;\n}\n\n \nstatic void radeon_set_filp_rights(struct drm_device *dev,\n\t\t\t\t   struct drm_file **owner,\n\t\t\t\t   struct drm_file *applier,\n\t\t\t\t   uint32_t *value)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tmutex_lock(&rdev->gem.mutex);\n\tif (*value == 1) {\n\t\t \n\t\tif (!*owner)\n\t\t\t*owner = applier;\n\t} else if (*value == 0) {\n\t\t \n\t\tif (*owner == applier)\n\t\t\t*owner = NULL;\n\t}\n\t*value = *owner == applier ? 1 : 0;\n\tmutex_unlock(&rdev->gem.mutex);\n}\n\n \n \nint radeon_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_radeon_info *info = data;\n\tstruct radeon_mode_info *minfo = &rdev->mode_info;\n\tuint32_t *value, value_tmp, *value_ptr, value_size;\n\tstruct ttm_resource_manager *man;\n\tuint64_t value64;\n\tstruct drm_crtc *crtc;\n\tint i, found;\n\n\tvalue_ptr = (uint32_t *)((unsigned long)info->value);\n\tvalue = &value_tmp;\n\tvalue_size = sizeof(uint32_t);\n\n\tswitch (info->request) {\n\tcase RADEON_INFO_DEVICE_ID:\n\t\t*value = to_pci_dev(dev->dev)->device;\n\t\tbreak;\n\tcase RADEON_INFO_NUM_GB_PIPES:\n\t\t*value = rdev->num_gb_pipes;\n\t\tbreak;\n\tcase RADEON_INFO_NUM_Z_PIPES:\n\t\t*value = rdev->num_z_pipes;\n\t\tbreak;\n\tcase RADEON_INFO_ACCEL_WORKING:\n\t\t \n\t\tif ((rdev->family >= CHIP_CEDAR) && (rdev->family <= CHIP_HEMLOCK))\n\t\t\t*value = false;\n\t\telse\n\t\t\t*value = rdev->accel_working;\n\t\tbreak;\n\tcase RADEON_INFO_CRTC_FROM_ID:\n\t\tif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\n\t\t\tDRM_ERROR(\"copy_from_user %s:%u\\n\", __func__, __LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tfor (i = 0, found = 0; i < rdev->num_crtc; i++) {\n\t\t\tcrtc = (struct drm_crtc *)minfo->crtcs[i];\n\t\t\tif (crtc && crtc->base.id == *value) {\n\t\t\t\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\n\t\t\t\t*value = radeon_crtc->crtc_id;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tDRM_DEBUG_KMS(\"unknown crtc id %d\\n\", *value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_ACCEL_WORKING2:\n\t\tif (rdev->family == CHIP_HAWAII) {\n\t\t\tif (rdev->accel_working) {\n\t\t\t\tif (rdev->new_fw)\n\t\t\t\t\t*value = 3;\n\t\t\t\telse\n\t\t\t\t\t*value = 2;\n\t\t\t} else {\n\t\t\t\t*value = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t*value = rdev->accel_working;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_TILING_CONFIG:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.tile_config;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.tile_config;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.tile_config;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.tile_config;\n\t\telse if (rdev->family >= CHIP_RV770)\n\t\t\t*value = rdev->config.rv770.tile_config;\n\t\telse if (rdev->family >= CHIP_R600)\n\t\t\t*value = rdev->config.r600.tile_config;\n\t\telse {\n\t\t\tDRM_DEBUG_KMS(\"tiling config is r6xx+ only!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_WANT_HYPERZ:\n\t\t \n\t\tif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\n\t\t\tDRM_ERROR(\"copy_from_user %s:%u\\n\", __func__, __LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (*value >= 2) {\n\t\t\tDRM_DEBUG_KMS(\"WANT_HYPERZ: invalid value %d\\n\", *value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tradeon_set_filp_rights(dev, &rdev->hyperz_filp, filp, value);\n\t\tbreak;\n\tcase RADEON_INFO_WANT_CMASK:\n\t\t \n\t\tif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\n\t\t\tDRM_ERROR(\"copy_from_user %s:%u\\n\", __func__, __LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (*value >= 2) {\n\t\t\tDRM_DEBUG_KMS(\"WANT_CMASK: invalid value %d\\n\", *value);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tradeon_set_filp_rights(dev, &rdev->cmask_filp, filp, value);\n\t\tbreak;\n\tcase RADEON_INFO_CLOCK_CRYSTAL_FREQ:\n\t\t \n\t\tif (rdev->asic->get_xclk)\n\t\t\t*value = radeon_get_xclk(rdev) * 10;\n\t\telse\n\t\t\t*value = rdev->clock.spll.reference_freq * 10;\n\t\tbreak;\n\tcase RADEON_INFO_NUM_BACKENDS:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.max_backends_per_se *\n\t\t\t\trdev->config.cik.max_shader_engines;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.max_backends_per_se *\n\t\t\t\trdev->config.si.max_shader_engines;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.max_backends_per_se *\n\t\t\t\trdev->config.cayman.max_shader_engines;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.max_backends;\n\t\telse if (rdev->family >= CHIP_RV770)\n\t\t\t*value = rdev->config.rv770.max_backends;\n\t\telse if (rdev->family >= CHIP_R600)\n\t\t\t*value = rdev->config.r600.max_backends;\n\t\telse {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_NUM_TILE_PIPES:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.max_tile_pipes;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.max_tile_pipes;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.max_tile_pipes;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.max_tile_pipes;\n\t\telse if (rdev->family >= CHIP_RV770)\n\t\t\t*value = rdev->config.rv770.max_tile_pipes;\n\t\telse if (rdev->family >= CHIP_R600)\n\t\t\t*value = rdev->config.r600.max_tile_pipes;\n\t\telse {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_FUSION_GART_WORKING:\n\t\t*value = 1;\n\t\tbreak;\n\tcase RADEON_INFO_BACKEND_MAP:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.backend_map;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.backend_map;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.backend_map;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.backend_map;\n\t\telse if (rdev->family >= CHIP_RV770)\n\t\t\t*value = rdev->config.rv770.backend_map;\n\t\telse if (rdev->family >= CHIP_R600)\n\t\t\t*value = rdev->config.r600.backend_map;\n\t\telse {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_VA_START:\n\t\t \n\t\tif (rdev->family < CHIP_CAYMAN)\n\t\t\treturn -EINVAL;\n\t\t*value = RADEON_VA_RESERVED_SIZE;\n\t\tbreak;\n\tcase RADEON_INFO_IB_VM_MAX_SIZE:\n\t\t \n\t\tif (rdev->family < CHIP_CAYMAN)\n\t\t\treturn -EINVAL;\n\t\t*value = RADEON_IB_VM_MAX_SIZE;\n\t\tbreak;\n\tcase RADEON_INFO_MAX_PIPES:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.max_cu_per_sh;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.max_cu_per_sh;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.max_pipes_per_simd;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.max_pipes;\n\t\telse if (rdev->family >= CHIP_RV770)\n\t\t\t*value = rdev->config.rv770.max_pipes;\n\t\telse if (rdev->family >= CHIP_R600)\n\t\t\t*value = rdev->config.r600.max_pipes;\n\t\telse {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_TIMESTAMP:\n\t\tif (rdev->family < CHIP_R600) {\n\t\t\tDRM_DEBUG_KMS(\"timestamp is r6xx+ only!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvalue = (uint32_t *)&value64;\n\t\tvalue_size = sizeof(uint64_t);\n\t\tvalue64 = radeon_get_gpu_clock_counter(rdev);\n\t\tbreak;\n\tcase RADEON_INFO_MAX_SE:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.max_shader_engines;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.max_shader_engines;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.max_shader_engines;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.num_ses;\n\t\telse\n\t\t\t*value = 1;\n\t\tbreak;\n\tcase RADEON_INFO_MAX_SH_PER_SE:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.max_sh_per_se;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.max_sh_per_se;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase RADEON_INFO_FASTFB_WORKING:\n\t\t*value = rdev->fastfb_working;\n\t\tbreak;\n\tcase RADEON_INFO_RING_WORKING:\n\t\tif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\n\t\t\tDRM_ERROR(\"copy_from_user %s:%u\\n\", __func__, __LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tswitch (*value) {\n\t\tcase RADEON_CS_RING_GFX:\n\t\tcase RADEON_CS_RING_COMPUTE:\n\t\t\t*value = rdev->ring[RADEON_RING_TYPE_GFX_INDEX].ready;\n\t\t\tbreak;\n\t\tcase RADEON_CS_RING_DMA:\n\t\t\t*value = rdev->ring[R600_RING_TYPE_DMA_INDEX].ready;\n\t\t\t*value |= rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready;\n\t\t\tbreak;\n\t\tcase RADEON_CS_RING_UVD:\n\t\t\t*value = rdev->ring[R600_RING_TYPE_UVD_INDEX].ready;\n\t\t\tbreak;\n\t\tcase RADEON_CS_RING_VCE:\n\t\t\t*value = rdev->ring[TN_RING_TYPE_VCE1_INDEX].ready;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_SI_TILE_MODE_ARRAY:\n\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\tvalue = rdev->config.cik.tile_mode_array;\n\t\t\tvalue_size = sizeof(uint32_t)*32;\n\t\t} else if (rdev->family >= CHIP_TAHITI) {\n\t\t\tvalue = rdev->config.si.tile_mode_array;\n\t\t\tvalue_size = sizeof(uint32_t)*32;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"tile mode array is si+ only!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_CIK_MACROTILE_MODE_ARRAY:\n\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\tvalue = rdev->config.cik.macrotile_mode_array;\n\t\t\tvalue_size = sizeof(uint32_t)*16;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"macrotile mode array is cik+ only!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_SI_CP_DMA_COMPUTE:\n\t\t*value = 1;\n\t\tbreak;\n\tcase RADEON_INFO_SI_BACKEND_ENABLED_MASK:\n\t\tif (rdev->family >= CHIP_BONAIRE) {\n\t\t\t*value = rdev->config.cik.backend_enable_mask;\n\t\t} else if (rdev->family >= CHIP_TAHITI) {\n\t\t\t*value = rdev->config.si.backend_enable_mask;\n\t\t} else {\n\t\t\tDRM_DEBUG_KMS(\"BACKEND_ENABLED_MASK is si+ only!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase RADEON_INFO_MAX_SCLK:\n\t\tif ((rdev->pm.pm_method == PM_METHOD_DPM) &&\n\t\t    rdev->pm.dpm_enabled)\n\t\t\t*value = rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk * 10;\n\t\telse\n\t\t\t*value = rdev->pm.default_sclk * 10;\n\t\tbreak;\n\tcase RADEON_INFO_VCE_FW_VERSION:\n\t\t*value = rdev->vce.fw_version;\n\t\tbreak;\n\tcase RADEON_INFO_VCE_FB_VERSION:\n\t\t*value = rdev->vce.fb_version;\n\t\tbreak;\n\tcase RADEON_INFO_NUM_BYTES_MOVED:\n\t\tvalue = (uint32_t *)&value64;\n\t\tvalue_size = sizeof(uint64_t);\n\t\tvalue64 = atomic64_read(&rdev->num_bytes_moved);\n\t\tbreak;\n\tcase RADEON_INFO_VRAM_USAGE:\n\t\tvalue = (uint32_t *)&value64;\n\t\tvalue_size = sizeof(uint64_t);\n\t\tman = ttm_manager_type(&rdev->mman.bdev, TTM_PL_VRAM);\n\t\tvalue64 = ttm_resource_manager_usage(man);\n\t\tbreak;\n\tcase RADEON_INFO_GTT_USAGE:\n\t\tvalue = (uint32_t *)&value64;\n\t\tvalue_size = sizeof(uint64_t);\n\t\tman = ttm_manager_type(&rdev->mman.bdev, TTM_PL_TT);\n\t\tvalue64 = ttm_resource_manager_usage(man);\n\t\tbreak;\n\tcase RADEON_INFO_ACTIVE_CU_COUNT:\n\t\tif (rdev->family >= CHIP_BONAIRE)\n\t\t\t*value = rdev->config.cik.active_cus;\n\t\telse if (rdev->family >= CHIP_TAHITI)\n\t\t\t*value = rdev->config.si.active_cus;\n\t\telse if (rdev->family >= CHIP_CAYMAN)\n\t\t\t*value = rdev->config.cayman.active_simds;\n\t\telse if (rdev->family >= CHIP_CEDAR)\n\t\t\t*value = rdev->config.evergreen.active_simds;\n\t\telse if (rdev->family >= CHIP_RV770)\n\t\t\t*value = rdev->config.rv770.active_simds;\n\t\telse if (rdev->family >= CHIP_R600)\n\t\t\t*value = rdev->config.r600.active_simds;\n\t\telse\n\t\t\t*value = 1;\n\t\tbreak;\n\tcase RADEON_INFO_CURRENT_GPU_TEMP:\n\t\t \n\t\tif (rdev->asic->pm.get_temperature)\n\t\t\t*value = radeon_get_temperature(rdev);\n\t\telse\n\t\t\t*value = 0;\n\t\tbreak;\n\tcase RADEON_INFO_CURRENT_GPU_SCLK:\n\t\t \n\t\tif (rdev->pm.dpm_enabled)\n\t\t\t*value = radeon_dpm_get_current_sclk(rdev) / 100;\n\t\telse\n\t\t\t*value = rdev->pm.current_sclk / 100;\n\t\tbreak;\n\tcase RADEON_INFO_CURRENT_GPU_MCLK:\n\t\t \n\t\tif (rdev->pm.dpm_enabled)\n\t\t\t*value = radeon_dpm_get_current_mclk(rdev) / 100;\n\t\telse\n\t\t\t*value = rdev->pm.current_mclk / 100;\n\t\tbreak;\n\tcase RADEON_INFO_READ_REG:\n\t\tif (copy_from_user(value, value_ptr, sizeof(uint32_t))) {\n\t\t\tDRM_ERROR(\"copy_from_user %s:%u\\n\", __func__, __LINE__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (radeon_get_allowed_info_register(rdev, *value, value))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase RADEON_INFO_VA_UNMAP_WORKING:\n\t\t*value = true;\n\t\tbreak;\n\tcase RADEON_INFO_GPU_RESET_COUNTER:\n\t\t*value = atomic_read(&rdev->gpu_reset_counter);\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"Invalid request %d\\n\", info->request);\n\t\treturn -EINVAL;\n\t}\n\tif (copy_to_user(value_ptr, (char *)value, value_size)) {\n\t\tDRM_ERROR(\"copy_to_user %s:%u\\n\", __func__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}\n\n \nint radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_fpriv *fpriv;\n\tstruct radeon_vm *vm;\n\tint r;\n\n\tfile_priv->driver_priv = NULL;\n\n\tr = pm_runtime_get_sync(dev->dev);\n\tif (r < 0) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn r;\n\t}\n\n\t \n\tif (rdev->family >= CHIP_CAYMAN) {\n\n\t\tfpriv = kzalloc(sizeof(*fpriv), GFP_KERNEL);\n\t\tif (unlikely(!fpriv)) {\n\t\t\tr = -ENOMEM;\n\t\t\tgoto err_suspend;\n\t\t}\n\n\t\tif (rdev->accel_working) {\n\t\t\tvm = &fpriv->vm;\n\t\t\tr = radeon_vm_init(rdev, vm);\n\t\t\tif (r)\n\t\t\t\tgoto err_fpriv;\n\n\t\t\tr = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);\n\t\t\tif (r)\n\t\t\t\tgoto err_vm_fini;\n\n\t\t\t \n\t\t\tvm->ib_bo_va = radeon_vm_bo_add(rdev, vm,\n\t\t\t\t\t\t\trdev->ring_tmp_bo.bo);\n\t\t\tif (!vm->ib_bo_va) {\n\t\t\t\tr = -ENOMEM;\n\t\t\t\tgoto err_vm_fini;\n\t\t\t}\n\n\t\t\tr = radeon_vm_bo_set_addr(rdev, vm->ib_bo_va,\n\t\t\t\t\t\t  RADEON_VA_IB_OFFSET,\n\t\t\t\t\t\t  RADEON_VM_PAGE_READABLE |\n\t\t\t\t\t\t  RADEON_VM_PAGE_SNOOPED);\n\t\t\tif (r)\n\t\t\t\tgoto err_vm_fini;\n\t\t}\n\t\tfile_priv->driver_priv = fpriv;\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn 0;\n\nerr_vm_fini:\n\tradeon_vm_fini(rdev, vm);\nerr_fpriv:\n\tkfree(fpriv);\n\nerr_suspend:\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn r;\n}\n\n \nvoid radeon_driver_postclose_kms(struct drm_device *dev,\n\t\t\t\t struct drm_file *file_priv)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tmutex_lock(&rdev->gem.mutex);\n\tif (rdev->hyperz_filp == file_priv)\n\t\trdev->hyperz_filp = NULL;\n\tif (rdev->cmask_filp == file_priv)\n\t\trdev->cmask_filp = NULL;\n\tmutex_unlock(&rdev->gem.mutex);\n\n\tradeon_uvd_free_handles(rdev, file_priv);\n\tradeon_vce_free_handles(rdev, file_priv);\n\n\t \n\tif (rdev->family >= CHIP_CAYMAN && file_priv->driver_priv) {\n\t\tstruct radeon_fpriv *fpriv = file_priv->driver_priv;\n\t\tstruct radeon_vm *vm = &fpriv->vm;\n\t\tint r;\n\n\t\tif (rdev->accel_working) {\n\t\t\tr = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);\n\t\t\tif (!r) {\n\t\t\t\tif (vm->ib_bo_va)\n\t\t\t\t\tradeon_vm_bo_rmv(rdev, vm->ib_bo_va);\n\t\t\t\tradeon_bo_unreserve(rdev->ring_tmp_bo.bo);\n\t\t\t}\n\t\t\tradeon_vm_fini(rdev, vm);\n\t\t}\n\n\t\tkfree(fpriv);\n\t\tfile_priv->driver_priv = NULL;\n\t}\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n}\n\n \n \nu32 radeon_get_vblank_counter_kms(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tint vpos, hpos, stat;\n\tu32 count;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (pipe >= rdev->num_crtc) {\n\t\tDRM_ERROR(\"Invalid crtc %u\\n\", pipe);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rdev->mode_info.crtcs[pipe]) {\n\t\t \n\t\tdo {\n\t\t\tcount = radeon_get_vblank_counter(rdev, pipe);\n\t\t\t \n\t\t\tstat = radeon_get_crtc_scanoutpos(\n\t\t\t\tdev, pipe, GET_DISTANCE_TO_VBLANKSTART,\n\t\t\t\t&vpos, &hpos, NULL, NULL,\n\t\t\t\t&rdev->mode_info.crtcs[pipe]->base.hwmode);\n\t\t} while (count != radeon_get_vblank_counter(rdev, pipe));\n\n\t\tif (((stat & (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE)) !=\n\t\t    (DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE))) {\n\t\t\tDRM_DEBUG_VBL(\"Query failed! stat %d\\n\", stat);\n\t\t}\n\t\telse {\n\t\t\tDRM_DEBUG_VBL(\"crtc %u: dist from vblank start %d\\n\",\n\t\t\t\t      pipe, vpos);\n\n\t\t\t \n\t\t\tif (vpos >= 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\telse {\n\t     \n\t    count = radeon_get_vblank_counter(rdev, pipe);\n\t    DRM_DEBUG_VBL(\"NULL mode info! Returned count may be wrong.\\n\");\n\t}\n\n\treturn count;\n}\n\n \nint radeon_enable_vblank_kms(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tunsigned long irqflags;\n\tint r;\n\n\tif (pipe >= rdev->num_crtc) {\n\t\tDRM_ERROR(\"Invalid crtc %d\\n\", pipe);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\trdev->irq.crtc_vblank_int[pipe] = true;\n\tr = radeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n\treturn r;\n}\n\n \nvoid radeon_disable_vblank_kms(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tunsigned long irqflags;\n\n\tif (pipe >= rdev->num_crtc) {\n\t\tDRM_ERROR(\"Invalid crtc %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&rdev->irq.lock, irqflags);\n\trdev->irq.crtc_vblank_int[pipe] = false;\n\tradeon_irq_set(rdev);\n\tspin_unlock_irqrestore(&rdev->irq.lock, irqflags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}