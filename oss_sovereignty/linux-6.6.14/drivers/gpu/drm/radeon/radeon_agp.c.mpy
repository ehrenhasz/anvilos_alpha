{
  "module_name": "radeon_agp.c",
  "hash_id": "07f84950ac5ee359299de2f3b0298ecf7f6240f5a04d233a8d8e3695d7538504",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_agp.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include <drm/drm_device.h>\n#include <drm/radeon_drm.h>\n\n#include \"radeon.h\"\n\n#if IS_ENABLED(CONFIG_AGP)\n\nstruct radeon_agpmode_quirk {\n\tu32 hostbridge_vendor;\n\tu32 hostbridge_device;\n\tu32 chip_vendor;\n\tu32 chip_device;\n\tu32 subsys_vendor;\n\tu32 subsys_device;\n\tu32 default_mode;\n};\n\nstatic struct radeon_agpmode_quirk radeon_agpmode_quirk_list[] = {\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x2550, PCI_VENDOR_ID_ATI, 0x4152, 0x1458, 0x4038, 4},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x2570, PCI_VENDOR_ID_ATI, 0x4a4e, PCI_VENDOR_ID_DELL, 0x5106, 4},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x2570, PCI_VENDOR_ID_ATI, 0x5964,\n\t\t0x148c, 0x2073, 4},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4c59,\n\t\tPCI_VENDOR_ID_IBM, 0x052f, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4e50,\n\t\tPCI_VENDOR_ID_IBM, 0x0550, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4c66,\n\t\tPCI_VENDOR_ID_IBM, 0x054d, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4c57,\n\t\tPCI_VENDOR_ID_IBM, 0x0530, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4e54,\n\t\tPCI_VENDOR_ID_IBM, 0x054f, 2},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x5c61,\n\t\tPCI_VENDOR_ID_SONY, 0x816b, 2},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x5c61,\n\t\tPCI_VENDOR_ID_SONY, 0x8195, 8},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3575, PCI_VENDOR_ID_ATI, 0x4c59,\n\t\tPCI_VENDOR_ID_DELL, 0x00e3, 2},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3580, PCI_VENDOR_ID_ATI, 0x4c66,\n\t\tPCI_VENDOR_ID_DELL, 0x0149, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4c66,\n\t\tPCI_VENDOR_ID_IBM, 0x0531, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3580, PCI_VENDOR_ID_ATI, 0x4e50,\n\t\t0x1025, 0x0061, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3580, PCI_VENDOR_ID_ATI, 0x4e50,\n\t\t0x1025, 0x0064, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3580, PCI_VENDOR_ID_ATI, 0x4e50,\n\t\tPCI_VENDOR_ID_ASUSTEK, 0x1942, 1},\n\t \n\t{ PCI_VENDOR_ID_INTEL, 0x3580, PCI_VENDOR_ID_ATI, 0x4e50,\n\t\t0x10cf, 0x127f, 1},\n\t \n\t{ 0x1849, 0x3189, PCI_VENDOR_ID_ATI, 0x5960,\n\t\t0x1787, 0x5960, 4},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x0204, PCI_VENDOR_ID_ATI, 0x5960,\n\t\t0x17af, 0x2020, 4},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x0269, PCI_VENDOR_ID_ATI, 0x4153,\n\t\tPCI_VENDOR_ID_ASUSTEK, 0x003c, 4},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x0305, PCI_VENDOR_ID_ATI, 0x514c,\n\t\tPCI_VENDOR_ID_ATI, 0x013a, 2},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x0691, PCI_VENDOR_ID_ATI, 0x5960,\n\t\tPCI_VENDOR_ID_ASUSTEK, 0x004c, 2},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x0691, PCI_VENDOR_ID_ATI, 0x5960,\n\t\tPCI_VENDOR_ID_ASUSTEK, 0x0054, 2},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x3189, PCI_VENDOR_ID_ATI, 0x514d,\n\t\t0x174b, 0x7149, 4},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x3189, PCI_VENDOR_ID_ATI, 0x5960,\n\t\t0x1462, 0x0380, 4},\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x3189, PCI_VENDOR_ID_ATI, 0x5964,\n\t\t0x148c, 0x2073, 4},\n\t \n\t{ PCI_VENDOR_ID_ATI, 0xcbb2, PCI_VENDOR_ID_ATI, 0x5c61,\n\t\tPCI_VENDOR_ID_SONY, 0x8175, 1},\n\t{ 0, 0, 0, 0, 0, 0, 0 },\n};\n\nstruct radeon_agp_head *radeon_agp_head_init(struct drm_device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct radeon_agp_head *head;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (!head)\n\t\treturn NULL;\n\thead->bridge = agp_find_bridge(pdev);\n\tif (!head->bridge) {\n\t\thead->bridge = agp_backend_acquire(pdev);\n\t\tif (!head->bridge) {\n\t\t\tkfree(head);\n\t\t\treturn NULL;\n\t\t}\n\t\tagp_copy_info(head->bridge, &head->agp_info);\n\t\tagp_backend_release(head->bridge);\n\t} else {\n\t\tagp_copy_info(head->bridge, &head->agp_info);\n\t}\n\tif (head->agp_info.chipset == NOT_SUPPORTED) {\n\t\tkfree(head);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&head->memory);\n\thead->cant_use_aperture = head->agp_info.cant_use_aperture;\n\thead->page_mask = head->agp_info.page_mask;\n\thead->base = head->agp_info.aper_base;\n\n\treturn head;\n}\n\nstatic int radeon_agp_head_acquire(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tif (!rdev->agp)\n\t\treturn -ENODEV;\n\tif (rdev->agp->acquired)\n\t\treturn -EBUSY;\n\trdev->agp->bridge = agp_backend_acquire(pdev);\n\tif (!rdev->agp->bridge)\n\t\treturn -ENODEV;\n\trdev->agp->acquired = 1;\n\treturn 0;\n}\n\nstatic int radeon_agp_head_release(struct radeon_device *rdev)\n{\n\tif (!rdev->agp || !rdev->agp->acquired)\n\t\treturn -EINVAL;\n\tagp_backend_release(rdev->agp->bridge);\n\trdev->agp->acquired = 0;\n\treturn 0;\n}\n\nstatic int radeon_agp_head_enable(struct radeon_device *rdev, struct radeon_agp_mode mode)\n{\n\tif (!rdev->agp || !rdev->agp->acquired)\n\t\treturn -EINVAL;\n\n\trdev->agp->mode = mode.mode;\n\tagp_enable(rdev->agp->bridge, mode.mode);\n\trdev->agp->enabled = 1;\n\treturn 0;\n}\n\nstatic int radeon_agp_head_info(struct radeon_device *rdev, struct radeon_agp_info *info)\n{\n\tstruct agp_kern_info *kern;\n\n\tif (!rdev->agp || !rdev->agp->acquired)\n\t\treturn -EINVAL;\n\n\tkern = &rdev->agp->agp_info;\n\tinfo->agp_version_major = kern->version.major;\n\tinfo->agp_version_minor = kern->version.minor;\n\tinfo->mode = kern->mode;\n\tinfo->aperture_base = kern->aper_base;\n\tinfo->aperture_size = kern->aper_size * 1024 * 1024;\n\tinfo->memory_allowed = kern->max_memory << PAGE_SHIFT;\n\tinfo->memory_used = kern->current_memory << PAGE_SHIFT;\n\tinfo->id_vendor = kern->device->vendor;\n\tinfo->id_device = kern->device->device;\n\n\treturn 0;\n}\n#endif\n\nint radeon_agp_init(struct radeon_device *rdev)\n{\n#if IS_ENABLED(CONFIG_AGP)\n\tstruct radeon_agpmode_quirk *p = radeon_agpmode_quirk_list;\n\tstruct radeon_agp_mode mode;\n\tstruct radeon_agp_info info;\n\tuint32_t agp_status;\n\tint default_mode;\n\tbool is_v3;\n\tint ret;\n\n\t \n\tret = radeon_agp_head_acquire(rdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"Unable to acquire AGP: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = radeon_agp_head_info(rdev, &info);\n\tif (ret) {\n\t\tradeon_agp_head_release(rdev);\n\t\tDRM_ERROR(\"Unable to get AGP info: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (rdev->agp->agp_info.aper_size < 32) {\n\t\tradeon_agp_head_release(rdev);\n\t\tdev_warn(rdev->dev, \"AGP aperture too small (%zuM) \"\n\t\t\t\"need at least 32M, disabling AGP\\n\",\n\t\t\trdev->agp->agp_info.aper_size);\n\t\treturn -EINVAL;\n\t}\n\n\tmode.mode = info.mode;\n\t \n\tif (rdev->family <= CHIP_RV350)\n\t\tagp_status = (RREG32(RADEON_AGP_STATUS) | RADEON_AGPv3_MODE) & mode.mode;\n\telse\n\t\tagp_status = mode.mode;\n\tis_v3 = !!(agp_status & RADEON_AGPv3_MODE);\n\n\tif (is_v3) {\n\t\tdefault_mode = (agp_status & RADEON_AGPv3_8X_MODE) ? 8 : 4;\n\t} else {\n\t\tif (agp_status & RADEON_AGP_4X_MODE) {\n\t\t\tdefault_mode = 4;\n\t\t} else if (agp_status & RADEON_AGP_2X_MODE) {\n\t\t\tdefault_mode = 2;\n\t\t} else {\n\t\t\tdefault_mode = 1;\n\t\t}\n\t}\n\n\t \n\twhile (p && p->chip_device != 0) {\n\t\tif (info.id_vendor == p->hostbridge_vendor &&\n\t\t    info.id_device == p->hostbridge_device &&\n\t\t    rdev->pdev->vendor == p->chip_vendor &&\n\t\t    rdev->pdev->device == p->chip_device &&\n\t\t    rdev->pdev->subsystem_vendor == p->subsys_vendor &&\n\t\t    rdev->pdev->subsystem_device == p->subsys_device) {\n\t\t\tdefault_mode = p->default_mode;\n\t\t}\n\t\t++p;\n\t}\n\n\tif (radeon_agpmode > 0) {\n\t\tif ((radeon_agpmode < (is_v3 ? 4 : 1)) ||\n\t\t    (radeon_agpmode > (is_v3 ? 8 : 4)) ||\n\t\t    (radeon_agpmode & (radeon_agpmode - 1))) {\n\t\t\tDRM_ERROR(\"Illegal AGP Mode: %d (valid %s), leaving at %d\\n\",\n\t\t\t\t  radeon_agpmode, is_v3 ? \"4, 8\" : \"1, 2, 4\",\n\t\t\t\t  default_mode);\n\t\t\tradeon_agpmode = default_mode;\n\t\t} else {\n\t\t\tDRM_INFO(\"AGP mode requested: %d\\n\", radeon_agpmode);\n\t\t}\n\t} else {\n\t\tradeon_agpmode = default_mode;\n\t}\n\n\tmode.mode &= ~RADEON_AGP_MODE_MASK;\n\tif (is_v3) {\n\t\tswitch (radeon_agpmode) {\n\t\tcase 8:\n\t\t\tmode.mode |= RADEON_AGPv3_8X_MODE;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tdefault:\n\t\t\tmode.mode |= RADEON_AGPv3_4X_MODE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (radeon_agpmode) {\n\t\tcase 4:\n\t\t\tmode.mode |= RADEON_AGP_4X_MODE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmode.mode |= RADEON_AGP_2X_MODE;\n\t\t\tbreak;\n\t\tcase 1:\n\t\tdefault:\n\t\t\tmode.mode |= RADEON_AGP_1X_MODE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmode.mode &= ~RADEON_AGP_FW_MODE;  \n\tret = radeon_agp_head_enable(rdev, mode);\n\tif (ret) {\n\t\tDRM_ERROR(\"Unable to enable AGP (mode = 0x%lx)\\n\", mode.mode);\n\t\tradeon_agp_head_release(rdev);\n\t\treturn ret;\n\t}\n\n\trdev->mc.agp_base = rdev->agp->agp_info.aper_base;\n\trdev->mc.gtt_size = rdev->agp->agp_info.aper_size << 20;\n\trdev->mc.gtt_start = rdev->mc.agp_base;\n\trdev->mc.gtt_end = rdev->mc.gtt_start + rdev->mc.gtt_size - 1;\n\tdev_info(rdev->dev, \"GTT: %lluM 0x%08llX - 0x%08llX\\n\",\n\t\trdev->mc.gtt_size >> 20, rdev->mc.gtt_start, rdev->mc.gtt_end);\n\n\t \n\tif (rdev->family < CHIP_R200) {\n\t\tWREG32(RADEON_AGP_CNTL, RREG32(RADEON_AGP_CNTL) | 0x000e0000);\n\t}\n\treturn 0;\n#else\n\treturn 0;\n#endif\n}\n\nvoid radeon_agp_resume(struct radeon_device *rdev)\n{\n#if IS_ENABLED(CONFIG_AGP)\n\tint r;\n\tif (rdev->flags & RADEON_IS_AGP) {\n\t\tr = radeon_agp_init(rdev);\n\t\tif (r)\n\t\t\tdev_warn(rdev->dev, \"radeon AGP reinit failed\\n\");\n\t}\n#endif\n}\n\nvoid radeon_agp_fini(struct radeon_device *rdev)\n{\n#if IS_ENABLED(CONFIG_AGP)\n\tif (rdev->agp && rdev->agp->acquired) {\n\t\tradeon_agp_head_release(rdev);\n\t}\n#endif\n}\n\nvoid radeon_agp_suspend(struct radeon_device *rdev)\n{\n\tradeon_agp_fini(rdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}