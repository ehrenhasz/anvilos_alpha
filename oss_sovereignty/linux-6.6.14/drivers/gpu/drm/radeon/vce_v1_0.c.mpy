{
  "module_name": "vce_v1_0.c",
  "hash_id": "9b53f20f4d270dc084cbfab45f3dd077fe6a70ab3634e908a6b15ae601ab8d88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/vce_v1_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"sid.h\"\n#include \"vce.h\"\n\n#define VCE_V1_0_FW_SIZE\t(256 * 1024)\n#define VCE_V1_0_STACK_SIZE\t(64 * 1024)\n#define VCE_V1_0_DATA_SIZE\t(7808 * (RADEON_MAX_VCE_HANDLES + 1))\n\nstruct vce_v1_0_fw_signature\n{\n\tint32_t off;\n\tuint32_t len;\n\tint32_t num;\n\tstruct {\n\t\tuint32_t chip_id;\n\t\tuint32_t keyselect;\n\t\tuint32_t nonce[4];\n\t\tuint32_t sigval[4];\n\t} val[8];\n};\n\n \nuint32_t vce_v1_0_get_rptr(struct radeon_device *rdev,\n\t\t\t   struct radeon_ring *ring)\n{\n\tif (ring->idx == TN_RING_TYPE_VCE1_INDEX)\n\t\treturn RREG32(VCE_RB_RPTR);\n\telse\n\t\treturn RREG32(VCE_RB_RPTR2);\n}\n\n \nuint32_t vce_v1_0_get_wptr(struct radeon_device *rdev,\n\t\t\t   struct radeon_ring *ring)\n{\n\tif (ring->idx == TN_RING_TYPE_VCE1_INDEX)\n\t\treturn RREG32(VCE_RB_WPTR);\n\telse\n\t\treturn RREG32(VCE_RB_WPTR2);\n}\n\n \nvoid vce_v1_0_set_wptr(struct radeon_device *rdev,\n\t\t       struct radeon_ring *ring)\n{\n\tif (ring->idx == TN_RING_TYPE_VCE1_INDEX)\n\t\tWREG32(VCE_RB_WPTR, ring->wptr);\n\telse\n\t\tWREG32(VCE_RB_WPTR2, ring->wptr);\n}\n\nvoid vce_v1_0_enable_mgcg(struct radeon_device *rdev, bool enable)\n{\n\tu32 tmp;\n\n\tif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_VCE_MGCG)) {\n\t\ttmp = RREG32(VCE_CLOCK_GATING_A);\n\t\ttmp |= CGC_DYN_CLOCK_MODE;\n\t\tWREG32(VCE_CLOCK_GATING_A, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_CLOCK_GATING);\n\t\ttmp &= ~0x1ff000;\n\t\ttmp |= 0xff800000;\n\t\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\n\t\ttmp &= ~0x3ff;\n\t\tWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\n\t} else {\n\t\ttmp = RREG32(VCE_CLOCK_GATING_A);\n\t\ttmp &= ~CGC_DYN_CLOCK_MODE;\n\t\tWREG32(VCE_CLOCK_GATING_A, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_CLOCK_GATING);\n\t\ttmp |= 0x1ff000;\n\t\ttmp &= ~0xff800000;\n\t\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\t\ttmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\n\t\ttmp |= 0x3ff;\n\t\tWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\n\t}\n}\n\nstatic void vce_v1_0_init_cg(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\n\ttmp = RREG32(VCE_CLOCK_GATING_A);\n\ttmp |= CGC_DYN_CLOCK_MODE;\n\tWREG32(VCE_CLOCK_GATING_A, tmp);\n\n\ttmp = RREG32(VCE_CLOCK_GATING_B);\n\ttmp |= 0x1e;\n\ttmp &= ~0xe100e1;\n\tWREG32(VCE_CLOCK_GATING_B, tmp);\n\n\ttmp = RREG32(VCE_UENC_CLOCK_GATING);\n\ttmp &= ~0xff9ff000;\n\tWREG32(VCE_UENC_CLOCK_GATING, tmp);\n\n\ttmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\n\ttmp &= ~0x3ff;\n\tWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\n}\n\nint vce_v1_0_load_fw(struct radeon_device *rdev, uint32_t *data)\n{\n\tstruct vce_v1_0_fw_signature *sign = (void*)rdev->vce_fw->data;\n\tuint32_t chip_id;\n\tint i;\n\n\tswitch (rdev->family) {\n\tcase CHIP_TAHITI:\n\t\tchip_id = 0x01000014;\n\t\tbreak;\n\tcase CHIP_VERDE:\n\t\tchip_id = 0x01000015;\n\t\tbreak;\n\tcase CHIP_PITCAIRN:\n\t\tchip_id = 0x01000016;\n\t\tbreak;\n\tcase CHIP_ARUBA:\n\t\tchip_id = 0x01000017;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < le32_to_cpu(sign->num); ++i) {\n\t\tif (le32_to_cpu(sign->val[i].chip_id) == chip_id)\n\t\t\tbreak;\n\t}\n\n\tif (i == le32_to_cpu(sign->num))\n\t\treturn -EINVAL;\n\n\tdata += (256 - 64) / 4;\n\tdata[0] = sign->val[i].nonce[0];\n\tdata[1] = sign->val[i].nonce[1];\n\tdata[2] = sign->val[i].nonce[2];\n\tdata[3] = sign->val[i].nonce[3];\n\tdata[4] = cpu_to_le32(le32_to_cpu(sign->len) + 64);\n\n\tmemset(&data[5], 0, 44);\n\tmemcpy(&data[16], &sign[1], rdev->vce_fw->size - sizeof(*sign));\n\n\tdata += (le32_to_cpu(sign->len) + 64) / 4;\n\tdata[0] = sign->val[i].sigval[0];\n\tdata[1] = sign->val[i].sigval[1];\n\tdata[2] = sign->val[i].sigval[2];\n\tdata[3] = sign->val[i].sigval[3];\n\n\trdev->vce.keyselect = le32_to_cpu(sign->val[i].keyselect);\n\n\treturn 0;\n}\n\nunsigned vce_v1_0_bo_size(struct radeon_device *rdev)\n{\n\tWARN_ON(VCE_V1_0_FW_SIZE < rdev->vce_fw->size);\n\treturn VCE_V1_0_FW_SIZE + VCE_V1_0_STACK_SIZE + VCE_V1_0_DATA_SIZE;\n}\n\nint vce_v1_0_resume(struct radeon_device *rdev)\n{\n\tuint64_t addr = rdev->vce.gpu_addr;\n\tuint32_t size;\n\tint i;\n\n\tWREG32_P(VCE_CLOCK_GATING_A, 0, ~(1 << 16));\n\tWREG32_P(VCE_UENC_CLOCK_GATING, 0x1FF000, ~0xFF9FF000);\n\tWREG32_P(VCE_UENC_REG_CLOCK_GATING, 0x3F, ~0x3F);\n\tWREG32(VCE_CLOCK_GATING_B, 0);\n\n\tWREG32_P(VCE_LMI_FW_PERIODIC_CTRL, 0x4, ~0x4);\n\n\tWREG32(VCE_LMI_CTRL, 0x00398000);\n\tWREG32_P(VCE_LMI_CACHE_CTRL, 0x0, ~0x1);\n\tWREG32(VCE_LMI_SWAP_CNTL, 0);\n\tWREG32(VCE_LMI_SWAP_CNTL1, 0);\n\tWREG32(VCE_LMI_VM_CTRL, 0);\n\n\tWREG32(VCE_VCPU_SCRATCH7, RADEON_MAX_VCE_HANDLES);\n\n\taddr += 256;\n\tsize = VCE_V1_0_FW_SIZE;\n\tWREG32(VCE_VCPU_CACHE_OFFSET0, addr & 0x7fffffff);\n\tWREG32(VCE_VCPU_CACHE_SIZE0, size);\n\n\taddr += size;\n\tsize = VCE_V1_0_STACK_SIZE;\n\tWREG32(VCE_VCPU_CACHE_OFFSET1, addr & 0x7fffffff);\n\tWREG32(VCE_VCPU_CACHE_SIZE1, size);\n\n\taddr += size;\n\tsize = VCE_V1_0_DATA_SIZE;\n\tWREG32(VCE_VCPU_CACHE_OFFSET2, addr & 0x7fffffff);\n\tWREG32(VCE_VCPU_CACHE_SIZE2, size);\n\n\tWREG32_P(VCE_LMI_CTRL2, 0x0, ~0x100);\n\n\tWREG32(VCE_LMI_FW_START_KEYSEL, rdev->vce.keyselect);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tmdelay(10);\n\t\tif (RREG32(VCE_FW_REG_STATUS) & VCE_FW_REG_STATUS_DONE)\n\t\t\tbreak;\n\t}\n\n\tif (i == 10)\n\t\treturn -ETIMEDOUT;\n\n\tif (!(RREG32(VCE_FW_REG_STATUS) & VCE_FW_REG_STATUS_PASS))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tmdelay(10);\n\t\tif (!(RREG32(VCE_FW_REG_STATUS) & VCE_FW_REG_STATUS_BUSY))\n\t\t\tbreak;\n\t}\n\n\tif (i == 10)\n\t\treturn -ETIMEDOUT;\n\n\tvce_v1_0_init_cg(rdev);\n\n\treturn 0;\n}\n\n \nint vce_v1_0_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint i, j, r;\n\n\t \n\tWREG32_P(VCE_STATUS, 1, ~1);\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\n\tWREG32(VCE_RB_RPTR, ring->wptr);\n\tWREG32(VCE_RB_WPTR, ring->wptr);\n\tWREG32(VCE_RB_BASE_LO, ring->gpu_addr);\n\tWREG32(VCE_RB_BASE_HI, upper_32_bits(ring->gpu_addr));\n\tWREG32(VCE_RB_SIZE, ring->ring_size / 4);\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\n\tWREG32(VCE_RB_RPTR2, ring->wptr);\n\tWREG32(VCE_RB_WPTR2, ring->wptr);\n\tWREG32(VCE_RB_BASE_LO2, ring->gpu_addr);\n\tWREG32(VCE_RB_BASE_HI2, upper_32_bits(ring->gpu_addr));\n\tWREG32(VCE_RB_SIZE2, ring->ring_size / 4);\n\n\tWREG32_P(VCE_VCPU_CNTL, VCE_CLK_EN, ~VCE_CLK_EN);\n\n\tWREG32_P(VCE_SOFT_RESET,\n\t\t VCE_ECPU_SOFT_RESET |\n\t\t VCE_FME_SOFT_RESET, ~(\n\t\t VCE_ECPU_SOFT_RESET |\n\t\t VCE_FME_SOFT_RESET));\n\n\tmdelay(100);\n\n\tWREG32_P(VCE_SOFT_RESET, 0, ~(\n\t\t VCE_ECPU_SOFT_RESET |\n\t\t VCE_FME_SOFT_RESET));\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tuint32_t status;\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(VCE_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(10);\n\t\t}\n\t\tr = 0;\n\t\tif (status & 2)\n\t\t\tbreak;\n\n\t\tDRM_ERROR(\"VCE not responding, trying to reset the ECPU!!!\\n\");\n\t\tWREG32_P(VCE_SOFT_RESET, VCE_ECPU_SOFT_RESET, ~VCE_ECPU_SOFT_RESET);\n\t\tmdelay(10);\n\t\tWREG32_P(VCE_SOFT_RESET, 0, ~VCE_ECPU_SOFT_RESET);\n\t\tmdelay(10);\n\t\tr = -1;\n\t}\n\n\t \n\tWREG32_P(VCE_STATUS, 0, ~1);\n\n\tif (r) {\n\t\tDRM_ERROR(\"VCE not responding, giving up!!!\\n\");\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nint vce_v1_0_init(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring;\n\tint r;\n\n\tr = vce_v1_0_start(rdev);\n\tif (r)\n\t\treturn r;\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\n\tring->ready = true;\n\tr = radeon_ring_test(rdev, TN_RING_TYPE_VCE1_INDEX, ring);\n\tif (r) {\n\t\tring->ready = false;\n\t\treturn r;\n\t}\n\n\tring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\n\tring->ready = true;\n\tr = radeon_ring_test(rdev, TN_RING_TYPE_VCE2_INDEX, ring);\n\tif (r) {\n\t\tring->ready = false;\n\t\treturn r;\n\t}\n\n\tDRM_INFO(\"VCE initialized successfully.\\n\");\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}