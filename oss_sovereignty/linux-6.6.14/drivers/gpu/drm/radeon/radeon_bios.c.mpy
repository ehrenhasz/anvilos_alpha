{
  "module_name": "radeon_bios.c",
  "hash_id": "085636bdef189c4889cef91c3b8709558461d24f3de1011721fa0beb11a2e6ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_bios.c",
  "human_readable_source": " \n\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include <drm/drm_device.h>\n\n#include \"atom.h\"\n#include \"radeon.h\"\n#include \"radeon_reg.h\"\n\n \n\n \nstatic bool igp_read_bios_from_vram(struct radeon_device *rdev)\n{\n\tuint8_t __iomem *bios;\n\tresource_size_t vram_base;\n\tresource_size_t size = 256 * 1024;  \n\n\tif (!(rdev->flags & RADEON_IS_IGP))\n\t\tif (!radeon_card_posted(rdev))\n\t\t\treturn false;\n\n\trdev->bios = NULL;\n\tvram_base = pci_resource_start(rdev->pdev, 0);\n\tbios = ioremap(vram_base, size);\n\tif (!bios) {\n\t\treturn false;\n\t}\n\n\tif (size == 0 || bios[0] != 0x55 || bios[1] != 0xaa) {\n\t\tiounmap(bios);\n\t\treturn false;\n\t}\n\trdev->bios = kmalloc(size, GFP_KERNEL);\n\tif (rdev->bios == NULL) {\n\t\tiounmap(bios);\n\t\treturn false;\n\t}\n\tmemcpy_fromio(rdev->bios, bios, size);\n\tiounmap(bios);\n\treturn true;\n}\n\nstatic bool radeon_read_bios(struct radeon_device *rdev)\n{\n\tuint8_t __iomem *bios, val1, val2;\n\tsize_t size;\n\n\trdev->bios = NULL;\n\t \n\tbios = pci_map_rom(rdev->pdev, &size);\n\tif (!bios) {\n\t\treturn false;\n\t}\n\n\tval1 = readb(&bios[0]);\n\tval2 = readb(&bios[1]);\n\n\tif (size == 0 || val1 != 0x55 || val2 != 0xaa) {\n\t\tpci_unmap_rom(rdev->pdev, bios);\n\t\treturn false;\n\t}\n\trdev->bios = kzalloc(size, GFP_KERNEL);\n\tif (rdev->bios == NULL) {\n\t\tpci_unmap_rom(rdev->pdev, bios);\n\t\treturn false;\n\t}\n\tmemcpy_fromio(rdev->bios, bios, size);\n\tpci_unmap_rom(rdev->pdev, bios);\n\treturn true;\n}\n\nstatic bool radeon_read_platform_bios(struct radeon_device *rdev)\n{\n\tphys_addr_t rom = rdev->pdev->rom;\n\tsize_t romlen = rdev->pdev->romlen;\n\tvoid __iomem *bios;\n\n\trdev->bios = NULL;\n\n\tif (!rom || romlen == 0)\n\t\treturn false;\n\n\trdev->bios = kzalloc(romlen, GFP_KERNEL);\n\tif (!rdev->bios)\n\t\treturn false;\n\n\tbios = ioremap(rom, romlen);\n\tif (!bios)\n\t\tgoto free_bios;\n\n\tmemcpy_fromio(rdev->bios, bios, romlen);\n\tiounmap(bios);\n\n\tif (rdev->bios[0] != 0x55 || rdev->bios[1] != 0xaa)\n\t\tgoto free_bios;\n\n\treturn true;\nfree_bios:\n\tkfree(rdev->bios);\n\treturn false;\n}\n\n#ifdef CONFIG_ACPI\n \n \n#define ATRM_BIOS_PAGE 4096\n \nstatic int radeon_atrm_call(acpi_handle atrm_handle, uint8_t *bios,\n\t\t\t    int offset, int len)\n{\n\tacpi_status status;\n\tunion acpi_object atrm_arg_elements[2], *obj;\n\tstruct acpi_object_list atrm_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\n\n\tatrm_arg.count = 2;\n\tatrm_arg.pointer = &atrm_arg_elements[0];\n\n\tatrm_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\tatrm_arg_elements[0].integer.value = offset;\n\n\tatrm_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\tatrm_arg_elements[1].integer.value = len;\n\n\tstatus = acpi_evaluate_object(atrm_handle, NULL, &atrm_arg, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tprintk(\"failed to evaluate ATRM got %s\\n\", acpi_format_exception(status));\n\t\treturn -ENODEV;\n\t}\n\n\tobj = (union acpi_object *)buffer.pointer;\n\tmemcpy(bios+offset, obj->buffer.pointer, obj->buffer.length);\n\tlen = obj->buffer.length;\n\tkfree(buffer.pointer);\n\treturn len;\n}\n\nstatic bool radeon_atrm_get_bios(struct radeon_device *rdev)\n{\n\tint ret;\n\tint size = 256 * 1024;\n\tint i;\n\tstruct pci_dev *pdev = NULL;\n\tacpi_handle dhandle, atrm_handle;\n\tacpi_status status;\n\tbool found = false;\n\n\t \n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn false;\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tdhandle = ACPI_HANDLE(&pdev->dev);\n\t\tif (!dhandle)\n\t\t\tcontinue;\n\n\t\tstatus = acpi_get_handle(dhandle, \"ATRM\", &atrm_handle);\n\t\tif (ACPI_SUCCESS(status)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found) {\n\t\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_OTHER << 8, pdev)) != NULL) {\n\t\t\tdhandle = ACPI_HANDLE(&pdev->dev);\n\t\t\tif (!dhandle)\n\t\t\t\tcontinue;\n\n\t\t\tstatus = acpi_get_handle(dhandle, \"ATRM\", &atrm_handle);\n\t\t\tif (ACPI_SUCCESS(status)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn false;\n\tpci_dev_put(pdev);\n\n\trdev->bios = kmalloc(size, GFP_KERNEL);\n\tif (!rdev->bios) {\n\t\tDRM_ERROR(\"Unable to allocate bios\\n\");\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < size / ATRM_BIOS_PAGE; i++) {\n\t\tret = radeon_atrm_call(atrm_handle,\n\t\t\t\t       rdev->bios,\n\t\t\t\t       (i * ATRM_BIOS_PAGE),\n\t\t\t\t       ATRM_BIOS_PAGE);\n\t\tif (ret < ATRM_BIOS_PAGE)\n\t\t\tbreak;\n\t}\n\n\tif (i == 0 || rdev->bios[0] != 0x55 || rdev->bios[1] != 0xaa) {\n\t\tkfree(rdev->bios);\n\t\treturn false;\n\t}\n\treturn true;\n}\n#else\nstatic inline bool radeon_atrm_get_bios(struct radeon_device *rdev)\n{\n\treturn false;\n}\n#endif\n\nstatic bool ni_read_disabled_bios(struct radeon_device *rdev)\n{\n\tu32 bus_cntl;\n\tu32 d1vga_control;\n\tu32 d2vga_control;\n\tu32 vga_render_control;\n\tu32 rom_cntl;\n\tbool r;\n\n\tbus_cntl = RREG32(R600_BUS_CNTL);\n\td1vga_control = RREG32(AVIVO_D1VGA_CONTROL);\n\td2vga_control = RREG32(AVIVO_D2VGA_CONTROL);\n\tvga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);\n\trom_cntl = RREG32(R600_ROM_CNTL);\n\n\t \n\tWREG32(R600_BUS_CNTL, (bus_cntl & ~R600_BIOS_ROM_DIS));\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\t \n\t\tWREG32(AVIVO_D1VGA_CONTROL,\n\t\t       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\t\t\t\t  AVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\t\tWREG32(AVIVO_D2VGA_CONTROL,\n\t\t       (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\t\t\t\t  AVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\t\tWREG32(AVIVO_VGA_RENDER_CONTROL,\n\t\t       (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));\n\t}\n\tWREG32(R600_ROM_CNTL, rom_cntl | R600_SCK_OVERWRITE);\n\n\tr = radeon_read_bios(rdev);\n\n\t \n\tWREG32(R600_BUS_CNTL, bus_cntl);\n\tif (!ASIC_IS_NODCE(rdev)) {\n\t\tWREG32(AVIVO_D1VGA_CONTROL, d1vga_control);\n\t\tWREG32(AVIVO_D2VGA_CONTROL, d2vga_control);\n\t\tWREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);\n\t}\n\tWREG32(R600_ROM_CNTL, rom_cntl);\n\treturn r;\n}\n\nstatic bool r700_read_disabled_bios(struct radeon_device *rdev)\n{\n\tuint32_t viph_control;\n\tuint32_t bus_cntl;\n\tuint32_t d1vga_control;\n\tuint32_t d2vga_control;\n\tuint32_t vga_render_control;\n\tuint32_t rom_cntl;\n\tuint32_t cg_spll_func_cntl = 0;\n\tuint32_t cg_spll_status;\n\tbool r;\n\n\tviph_control = RREG32(RADEON_VIPH_CONTROL);\n\tbus_cntl = RREG32(R600_BUS_CNTL);\n\td1vga_control = RREG32(AVIVO_D1VGA_CONTROL);\n\td2vga_control = RREG32(AVIVO_D2VGA_CONTROL);\n\tvga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);\n\trom_cntl = RREG32(R600_ROM_CNTL);\n\n\t \n\tWREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));\n\t \n\tWREG32(R600_BUS_CNTL, (bus_cntl & ~R600_BIOS_ROM_DIS));\n\t \n\tWREG32(AVIVO_D1VGA_CONTROL,\n\t       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\tAVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\tWREG32(AVIVO_D2VGA_CONTROL,\n\t       (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\tAVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\tWREG32(AVIVO_VGA_RENDER_CONTROL,\n\t       (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));\n\n\tif (rdev->family == CHIP_RV730) {\n\t\tcg_spll_func_cntl = RREG32(R600_CG_SPLL_FUNC_CNTL);\n\n\t\t \n\t\tWREG32(R600_CG_SPLL_FUNC_CNTL, (cg_spll_func_cntl |\n\t\t\t\t\t\tR600_SPLL_BYPASS_EN));\n\n\t\t \n\t\tcg_spll_status = 0;\n\t\twhile (!(cg_spll_status & R600_SPLL_CHG_STATUS))\n\t\t\tcg_spll_status = RREG32(R600_CG_SPLL_STATUS);\n\n\t\tWREG32(R600_ROM_CNTL, (rom_cntl & ~R600_SCK_OVERWRITE));\n\t} else\n\t\tWREG32(R600_ROM_CNTL, (rom_cntl | R600_SCK_OVERWRITE));\n\n\tr = radeon_read_bios(rdev);\n\n\t \n\tif (rdev->family == CHIP_RV730) {\n\t\tWREG32(R600_CG_SPLL_FUNC_CNTL, cg_spll_func_cntl);\n\n\t\t \n\t\tcg_spll_status = 0;\n\t\twhile (!(cg_spll_status & R600_SPLL_CHG_STATUS))\n\t\t\tcg_spll_status = RREG32(R600_CG_SPLL_STATUS);\n\t}\n\tWREG32(RADEON_VIPH_CONTROL, viph_control);\n\tWREG32(R600_BUS_CNTL, bus_cntl);\n\tWREG32(AVIVO_D1VGA_CONTROL, d1vga_control);\n\tWREG32(AVIVO_D2VGA_CONTROL, d2vga_control);\n\tWREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);\n\tWREG32(R600_ROM_CNTL, rom_cntl);\n\treturn r;\n}\n\nstatic bool r600_read_disabled_bios(struct radeon_device *rdev)\n{\n\tuint32_t viph_control;\n\tuint32_t bus_cntl;\n\tuint32_t d1vga_control;\n\tuint32_t d2vga_control;\n\tuint32_t vga_render_control;\n\tuint32_t rom_cntl;\n\tuint32_t general_pwrmgt;\n\tuint32_t low_vid_lower_gpio_cntl;\n\tuint32_t medium_vid_lower_gpio_cntl;\n\tuint32_t high_vid_lower_gpio_cntl;\n\tuint32_t ctxsw_vid_lower_gpio_cntl;\n\tuint32_t lower_gpio_enable;\n\tbool r;\n\n\tviph_control = RREG32(RADEON_VIPH_CONTROL);\n\tbus_cntl = RREG32(R600_BUS_CNTL);\n\td1vga_control = RREG32(AVIVO_D1VGA_CONTROL);\n\td2vga_control = RREG32(AVIVO_D2VGA_CONTROL);\n\tvga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);\n\trom_cntl = RREG32(R600_ROM_CNTL);\n\tgeneral_pwrmgt = RREG32(R600_GENERAL_PWRMGT);\n\tlow_vid_lower_gpio_cntl = RREG32(R600_LOW_VID_LOWER_GPIO_CNTL);\n\tmedium_vid_lower_gpio_cntl = RREG32(R600_MEDIUM_VID_LOWER_GPIO_CNTL);\n\thigh_vid_lower_gpio_cntl = RREG32(R600_HIGH_VID_LOWER_GPIO_CNTL);\n\tctxsw_vid_lower_gpio_cntl = RREG32(R600_CTXSW_VID_LOWER_GPIO_CNTL);\n\tlower_gpio_enable = RREG32(R600_LOWER_GPIO_ENABLE);\n\n\t \n\tWREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));\n\t \n\tWREG32(R600_BUS_CNTL, (bus_cntl & ~R600_BIOS_ROM_DIS));\n\t \n\tWREG32(AVIVO_D1VGA_CONTROL,\n\t       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\tAVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\tWREG32(AVIVO_D2VGA_CONTROL,\n\t       (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\tAVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\tWREG32(AVIVO_VGA_RENDER_CONTROL,\n\t       (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));\n\n\tWREG32(R600_ROM_CNTL,\n\t       ((rom_cntl & ~R600_SCK_PRESCALE_CRYSTAL_CLK_MASK) |\n\t\t(1 << R600_SCK_PRESCALE_CRYSTAL_CLK_SHIFT) |\n\t\tR600_SCK_OVERWRITE));\n\n\tWREG32(R600_GENERAL_PWRMGT, (general_pwrmgt & ~R600_OPEN_DRAIN_PADS));\n\tWREG32(R600_LOW_VID_LOWER_GPIO_CNTL,\n\t       (low_vid_lower_gpio_cntl & ~0x400));\n\tWREG32(R600_MEDIUM_VID_LOWER_GPIO_CNTL,\n\t       (medium_vid_lower_gpio_cntl & ~0x400));\n\tWREG32(R600_HIGH_VID_LOWER_GPIO_CNTL,\n\t       (high_vid_lower_gpio_cntl & ~0x400));\n\tWREG32(R600_CTXSW_VID_LOWER_GPIO_CNTL,\n\t       (ctxsw_vid_lower_gpio_cntl & ~0x400));\n\tWREG32(R600_LOWER_GPIO_ENABLE, (lower_gpio_enable | 0x400));\n\n\tr = radeon_read_bios(rdev);\n\n\t \n\tWREG32(RADEON_VIPH_CONTROL, viph_control);\n\tWREG32(R600_BUS_CNTL, bus_cntl);\n\tWREG32(AVIVO_D1VGA_CONTROL, d1vga_control);\n\tWREG32(AVIVO_D2VGA_CONTROL, d2vga_control);\n\tWREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);\n\tWREG32(R600_ROM_CNTL, rom_cntl);\n\tWREG32(R600_GENERAL_PWRMGT, general_pwrmgt);\n\tWREG32(R600_LOW_VID_LOWER_GPIO_CNTL, low_vid_lower_gpio_cntl);\n\tWREG32(R600_MEDIUM_VID_LOWER_GPIO_CNTL, medium_vid_lower_gpio_cntl);\n\tWREG32(R600_HIGH_VID_LOWER_GPIO_CNTL, high_vid_lower_gpio_cntl);\n\tWREG32(R600_CTXSW_VID_LOWER_GPIO_CNTL, ctxsw_vid_lower_gpio_cntl);\n\tWREG32(R600_LOWER_GPIO_ENABLE, lower_gpio_enable);\n\treturn r;\n}\n\nstatic bool avivo_read_disabled_bios(struct radeon_device *rdev)\n{\n\tuint32_t seprom_cntl1;\n\tuint32_t viph_control;\n\tuint32_t bus_cntl;\n\tuint32_t d1vga_control;\n\tuint32_t d2vga_control;\n\tuint32_t vga_render_control;\n\tuint32_t gpiopad_a;\n\tuint32_t gpiopad_en;\n\tuint32_t gpiopad_mask;\n\tbool r;\n\n\tseprom_cntl1 = RREG32(RADEON_SEPROM_CNTL1);\n\tviph_control = RREG32(RADEON_VIPH_CONTROL);\n\tbus_cntl = RREG32(RV370_BUS_CNTL);\n\td1vga_control = RREG32(AVIVO_D1VGA_CONTROL);\n\td2vga_control = RREG32(AVIVO_D2VGA_CONTROL);\n\tvga_render_control = RREG32(AVIVO_VGA_RENDER_CONTROL);\n\tgpiopad_a = RREG32(RADEON_GPIOPAD_A);\n\tgpiopad_en = RREG32(RADEON_GPIOPAD_EN);\n\tgpiopad_mask = RREG32(RADEON_GPIOPAD_MASK);\n\n\tWREG32(RADEON_SEPROM_CNTL1,\n\t       ((seprom_cntl1 & ~RADEON_SCK_PRESCALE_MASK) |\n\t\t(0xc << RADEON_SCK_PRESCALE_SHIFT)));\n\tWREG32(RADEON_GPIOPAD_A, 0);\n\tWREG32(RADEON_GPIOPAD_EN, 0);\n\tWREG32(RADEON_GPIOPAD_MASK, 0);\n\n\t \n\tWREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));\n\n\t \n\tWREG32(RV370_BUS_CNTL, (bus_cntl & ~RV370_BUS_BIOS_DIS_ROM));\n\n\t \n\tWREG32(AVIVO_D1VGA_CONTROL,\n\t       (d1vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\tAVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\tWREG32(AVIVO_D2VGA_CONTROL,\n\t       (d2vga_control & ~(AVIVO_DVGA_CONTROL_MODE_ENABLE |\n\t\tAVIVO_DVGA_CONTROL_TIMING_SELECT)));\n\tWREG32(AVIVO_VGA_RENDER_CONTROL,\n\t       (vga_render_control & ~AVIVO_VGA_VSTATUS_CNTL_MASK));\n\n\tr = radeon_read_bios(rdev);\n\n\t \n\tWREG32(RADEON_SEPROM_CNTL1, seprom_cntl1);\n\tWREG32(RADEON_VIPH_CONTROL, viph_control);\n\tWREG32(RV370_BUS_CNTL, bus_cntl);\n\tWREG32(AVIVO_D1VGA_CONTROL, d1vga_control);\n\tWREG32(AVIVO_D2VGA_CONTROL, d2vga_control);\n\tWREG32(AVIVO_VGA_RENDER_CONTROL, vga_render_control);\n\tWREG32(RADEON_GPIOPAD_A, gpiopad_a);\n\tWREG32(RADEON_GPIOPAD_EN, gpiopad_en);\n\tWREG32(RADEON_GPIOPAD_MASK, gpiopad_mask);\n\treturn r;\n}\n\nstatic bool legacy_read_disabled_bios(struct radeon_device *rdev)\n{\n\tuint32_t seprom_cntl1;\n\tuint32_t viph_control;\n\tuint32_t bus_cntl;\n\tuint32_t crtc_gen_cntl;\n\tuint32_t crtc2_gen_cntl;\n\tuint32_t crtc_ext_cntl;\n\tuint32_t fp2_gen_cntl;\n\tbool r;\n\n\tseprom_cntl1 = RREG32(RADEON_SEPROM_CNTL1);\n\tviph_control = RREG32(RADEON_VIPH_CONTROL);\n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\tbus_cntl = RREG32(RV370_BUS_CNTL);\n\telse\n\t\tbus_cntl = RREG32(RADEON_BUS_CNTL);\n\tcrtc_gen_cntl = RREG32(RADEON_CRTC_GEN_CNTL);\n\tcrtc2_gen_cntl = 0;\n\tcrtc_ext_cntl = RREG32(RADEON_CRTC_EXT_CNTL);\n\tfp2_gen_cntl = 0;\n\n\tif (rdev->pdev->device == PCI_DEVICE_ID_ATI_RADEON_QY) {\n\t\tfp2_gen_cntl = RREG32(RADEON_FP2_GEN_CNTL);\n\t}\n\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tcrtc2_gen_cntl = RREG32(RADEON_CRTC2_GEN_CNTL);\n\t}\n\n\tWREG32(RADEON_SEPROM_CNTL1,\n\t       ((seprom_cntl1 & ~RADEON_SCK_PRESCALE_MASK) |\n\t\t(0xc << RADEON_SCK_PRESCALE_SHIFT)));\n\n\t \n\tWREG32(RADEON_VIPH_CONTROL, (viph_control & ~RADEON_VIPH_EN));\n\n\t \n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\tWREG32(RV370_BUS_CNTL, (bus_cntl & ~RV370_BUS_BIOS_DIS_ROM));\n\telse\n\t\tWREG32(RADEON_BUS_CNTL, (bus_cntl & ~RADEON_BUS_BIOS_DIS_ROM));\n\n\t \n\tWREG32(RADEON_CRTC_GEN_CNTL,\n\t       ((crtc_gen_cntl & ~RADEON_CRTC_EN) |\n\t\t(RADEON_CRTC_DISP_REQ_EN_B |\n\t\t RADEON_CRTC_EXT_DISP_EN)));\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tWREG32(RADEON_CRTC2_GEN_CNTL,\n\t\t       ((crtc2_gen_cntl & ~RADEON_CRTC2_EN) |\n\t\t\tRADEON_CRTC2_DISP_REQ_EN_B));\n\t}\n\t \n\tWREG32(RADEON_CRTC_EXT_CNTL,\n\t       ((crtc_ext_cntl & ~RADEON_CRTC_CRT_ON) |\n\t\t(RADEON_CRTC_SYNC_TRISTAT |\n\t\t RADEON_CRTC_DISPLAY_DIS)));\n\n\tif (rdev->pdev->device == PCI_DEVICE_ID_ATI_RADEON_QY) {\n\t\tWREG32(RADEON_FP2_GEN_CNTL, (fp2_gen_cntl & ~RADEON_FP2_ON));\n\t}\n\n\tr = radeon_read_bios(rdev);\n\n\t \n\tWREG32(RADEON_SEPROM_CNTL1, seprom_cntl1);\n\tWREG32(RADEON_VIPH_CONTROL, viph_control);\n\tif (rdev->flags & RADEON_IS_PCIE)\n\t\tWREG32(RV370_BUS_CNTL, bus_cntl);\n\telse\n\t\tWREG32(RADEON_BUS_CNTL, bus_cntl);\n\tWREG32(RADEON_CRTC_GEN_CNTL, crtc_gen_cntl);\n\tif (!(rdev->flags & RADEON_SINGLE_CRTC)) {\n\t\tWREG32(RADEON_CRTC2_GEN_CNTL, crtc2_gen_cntl);\n\t}\n\tWREG32(RADEON_CRTC_EXT_CNTL, crtc_ext_cntl);\n\tif (rdev->pdev->device == PCI_DEVICE_ID_ATI_RADEON_QY) {\n\t\tWREG32(RADEON_FP2_GEN_CNTL, fp2_gen_cntl);\n\t}\n\treturn r;\n}\n\nstatic bool radeon_read_disabled_bios(struct radeon_device *rdev)\n{\n\tif (rdev->flags & RADEON_IS_IGP)\n\t\treturn igp_read_bios_from_vram(rdev);\n\telse if (rdev->family >= CHIP_BARTS)\n\t\treturn ni_read_disabled_bios(rdev);\n\telse if (rdev->family >= CHIP_RV770)\n\t\treturn r700_read_disabled_bios(rdev);\n\telse if (rdev->family >= CHIP_R600)\n\t\treturn r600_read_disabled_bios(rdev);\n\telse if (rdev->family >= CHIP_RS600)\n\t\treturn avivo_read_disabled_bios(rdev);\n\telse\n\t\treturn legacy_read_disabled_bios(rdev);\n}\n\n#ifdef CONFIG_ACPI\nstatic bool radeon_acpi_vfct_bios(struct radeon_device *rdev)\n{\n\tstruct acpi_table_header *hdr;\n\tacpi_size tbl_size;\n\tUEFI_ACPI_VFCT *vfct;\n\tunsigned offset;\n\tbool r = false;\n\n\tif (!ACPI_SUCCESS(acpi_get_table(\"VFCT\", 1, &hdr)))\n\t\treturn false;\n\ttbl_size = hdr->length;\n\tif (tbl_size < sizeof(UEFI_ACPI_VFCT)) {\n\t\tDRM_ERROR(\"ACPI VFCT table present but broken (too short #1)\\n\");\n\t\tgoto out;\n\t}\n\n\tvfct = (UEFI_ACPI_VFCT *)hdr;\n\toffset = vfct->VBIOSImageOffset;\n\n\twhile (offset < tbl_size) {\n\t\tGOP_VBIOS_CONTENT *vbios = (GOP_VBIOS_CONTENT *)((char *)hdr + offset);\n\t\tVFCT_IMAGE_HEADER *vhdr = &vbios->VbiosHeader;\n\n\t\toffset += sizeof(VFCT_IMAGE_HEADER);\n\t\tif (offset > tbl_size) {\n\t\t\tDRM_ERROR(\"ACPI VFCT image header truncated\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += vhdr->ImageLength;\n\t\tif (offset > tbl_size) {\n\t\t\tDRM_ERROR(\"ACPI VFCT image truncated\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (vhdr->ImageLength &&\n\t\t    vhdr->PCIBus == rdev->pdev->bus->number &&\n\t\t    vhdr->PCIDevice == PCI_SLOT(rdev->pdev->devfn) &&\n\t\t    vhdr->PCIFunction == PCI_FUNC(rdev->pdev->devfn) &&\n\t\t    vhdr->VendorID == rdev->pdev->vendor &&\n\t\t    vhdr->DeviceID == rdev->pdev->device) {\n\t\t\trdev->bios = kmemdup(&vbios->VbiosContent,\n\t\t\t\t\t     vhdr->ImageLength,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t\tif (rdev->bios)\n\t\t\t\tr = true;\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tDRM_ERROR(\"ACPI VFCT table present but broken (too short #2)\\n\");\n\nout:\n\tacpi_put_table(hdr);\n\treturn r;\n}\n#else\nstatic inline bool radeon_acpi_vfct_bios(struct radeon_device *rdev)\n{\n\treturn false;\n}\n#endif\n\nbool radeon_get_bios(struct radeon_device *rdev)\n{\n\tbool r;\n\tuint16_t tmp;\n\n\tr = radeon_atrm_get_bios(rdev);\n\tif (!r)\n\t\tr = radeon_acpi_vfct_bios(rdev);\n\tif (!r)\n\t\tr = igp_read_bios_from_vram(rdev);\n\tif (!r)\n\t\tr = radeon_read_bios(rdev);\n\tif (!r)\n\t\tr = radeon_read_disabled_bios(rdev);\n\tif (!r)\n\t\tr = radeon_read_platform_bios(rdev);\n\tif (!r || rdev->bios == NULL) {\n\t\tDRM_ERROR(\"Unable to locate a BIOS ROM\\n\");\n\t\trdev->bios = NULL;\n\t\treturn false;\n\t}\n\tif (rdev->bios[0] != 0x55 || rdev->bios[1] != 0xaa) {\n\t\tprintk(\"BIOS signature incorrect %x %x\\n\", rdev->bios[0], rdev->bios[1]);\n\t\tgoto free_bios;\n\t}\n\n\ttmp = RBIOS16(0x18);\n\tif (RBIOS8(tmp + 0x14) != 0x0) {\n\t\tDRM_INFO(\"Not an x86 BIOS ROM, not using.\\n\");\n\t\tgoto free_bios;\n\t}\n\n\trdev->bios_header_start = RBIOS16(0x48);\n\tif (!rdev->bios_header_start) {\n\t\tgoto free_bios;\n\t}\n\ttmp = rdev->bios_header_start + 4;\n\tif (!memcmp(rdev->bios + tmp, \"ATOM\", 4) ||\n\t    !memcmp(rdev->bios + tmp, \"MOTA\", 4)) {\n\t\trdev->is_atom_bios = true;\n\t} else {\n\t\trdev->is_atom_bios = false;\n\t}\n\n\tDRM_DEBUG(\"%sBIOS detected\\n\", rdev->is_atom_bios ? \"ATOM\" : \"COM\");\n\treturn true;\nfree_bios:\n\tkfree(rdev->bios);\n\trdev->bios = NULL;\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}