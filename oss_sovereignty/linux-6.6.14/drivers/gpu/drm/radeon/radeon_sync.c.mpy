{
  "module_name": "radeon_sync.c",
  "hash_id": "2429df5ba073e39035c970f466af68b0a1c6cad509fe40ca863e16cf35b38bec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_sync.c",
  "human_readable_source": " \n \n\n#include \"radeon.h\"\n#include \"radeon_trace.h\"\n\n \nvoid radeon_sync_create(struct radeon_sync *sync)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < RADEON_NUM_SYNCS; ++i)\n\t\tsync->semaphores[i] = NULL;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i)\n\t\tsync->sync_to[i] = NULL;\n\n\tsync->last_vm_update = NULL;\n}\n\n \nvoid radeon_sync_fence(struct radeon_sync *sync,\n\t\t       struct radeon_fence *fence)\n{\n\tstruct radeon_fence *other;\n\n\tif (!fence)\n\t\treturn;\n\n\tother = sync->sync_to[fence->ring];\n\tsync->sync_to[fence->ring] = radeon_fence_later(fence, other);\n\n\tif (fence->is_vm_update) {\n\t\tother = sync->last_vm_update;\n\t\tsync->last_vm_update = radeon_fence_later(fence, other);\n\t}\n}\n\n \nint radeon_sync_resv(struct radeon_device *rdev,\n\t\t     struct radeon_sync *sync,\n\t\t     struct dma_resv *resv,\n\t\t     bool shared)\n{\n\tstruct dma_resv_iter cursor;\n\tstruct radeon_fence *fence;\n\tstruct dma_fence *f;\n\tint r = 0;\n\n\tdma_resv_for_each_fence(&cursor, resv, dma_resv_usage_rw(!shared), f) {\n\t\tfence = to_radeon_fence(f);\n\t\tif (fence && fence->rdev == rdev)\n\t\t\tradeon_sync_fence(sync, fence);\n\t\telse\n\t\t\tr = dma_fence_wait(f, true);\n\t\tif (r)\n\t\t\tbreak;\n\t}\n\treturn r;\n}\n\n \nint radeon_sync_rings(struct radeon_device *rdev,\n\t\t      struct radeon_sync *sync,\n\t\t      int ring)\n{\n\tunsigned count = 0;\n\tint i, r;\n\n\tfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\n\t\tstruct radeon_fence *fence = sync->sync_to[i];\n\t\tstruct radeon_semaphore *semaphore;\n\n\t\t \n\t\tif (!radeon_fence_need_sync(fence, ring))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!rdev->ring[i].ready) {\n\t\t\tdev_err(rdev->dev, \"Syncing to a disabled ring!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (count >= RADEON_NUM_SYNCS) {\n\t\t\t \n\t\t\tr = radeon_fence_wait(fence, false);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\t\t}\n\t\tr = radeon_semaphore_create(rdev, &semaphore);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tsync->semaphores[count++] = semaphore;\n\n\t\t \n\t\tr = radeon_ring_alloc(rdev, &rdev->ring[i], 16);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\t \n\t\tif (!radeon_semaphore_emit_signal(rdev, i, semaphore)) {\n\t\t\t \n\t\t\tradeon_ring_undo(&rdev->ring[i]);\n\t\t\tr = radeon_fence_wait(fence, false);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!radeon_semaphore_emit_wait(rdev, ring, semaphore)) {\n\t\t\t \n\t\t\tradeon_ring_undo(&rdev->ring[i]);\n\t\t\tr = radeon_fence_wait(fence, false);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t\tcontinue;\n\t\t}\n\n\t\tradeon_ring_commit(rdev, &rdev->ring[i], false);\n\t\tradeon_fence_note_sync(fence, ring);\n\t}\n\n\treturn 0;\n}\n\n \nvoid radeon_sync_free(struct radeon_device *rdev,\n\t\t      struct radeon_sync *sync,\n\t\t      struct radeon_fence *fence)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < RADEON_NUM_SYNCS; ++i)\n\t\tradeon_semaphore_free(rdev, &sync->semaphores[i], fence);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}