{
  "module_name": "atombios_encoders.c",
  "hash_id": "c34f714ed761818d8dc3f9a2a561e6f49851360e984cc33b2153623a63dccd5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/atombios_encoders.c",
  "human_readable_source": " \n\n#include <linux/backlight.h>\n#include <linux/dmi.h>\n#include <linux/pci.h>\n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_file.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/radeon_drm.h>\n\n#include <acpi/video.h>\n\n#include \"atom.h\"\n#include \"radeon_atombios.h\"\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"radeon_audio.h\"\n\nextern int atom_debug;\n\nstatic u8\nradeon_atom_get_backlight_level_from_reg(struct radeon_device *rdev)\n{\n\tu8 backlight_level;\n\tu32 bios_2_scratch;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\n\telse\n\t\tbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\n\n\tbacklight_level = ((bios_2_scratch & ATOM_S2_CURRENT_BL_LEVEL_MASK) >>\n\t\t\t   ATOM_S2_CURRENT_BL_LEVEL_SHIFT);\n\n\treturn backlight_level;\n}\n\nstatic void\nradeon_atom_set_backlight_level_to_reg(struct radeon_device *rdev,\n\t\t\t\t       u8 backlight_level)\n{\n\tu32 bios_2_scratch;\n\n\tif (rdev->family >= CHIP_R600)\n\t\tbios_2_scratch = RREG32(R600_BIOS_2_SCRATCH);\n\telse\n\t\tbios_2_scratch = RREG32(RADEON_BIOS_2_SCRATCH);\n\n\tbios_2_scratch &= ~ATOM_S2_CURRENT_BL_LEVEL_MASK;\n\tbios_2_scratch |= ((backlight_level << ATOM_S2_CURRENT_BL_LEVEL_SHIFT) &\n\t\t\t   ATOM_S2_CURRENT_BL_LEVEL_MASK);\n\n\tif (rdev->family >= CHIP_R600)\n\t\tWREG32(R600_BIOS_2_SCRATCH, bios_2_scratch);\n\telse\n\t\tWREG32(RADEON_BIOS_2_SCRATCH, bios_2_scratch);\n}\n\nu8\natombios_get_backlight_level(struct radeon_encoder *radeon_encoder)\n{\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\tif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\n\t\treturn 0;\n\n\treturn radeon_atom_get_backlight_level_from_reg(rdev);\n}\n\nvoid\natombios_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level)\n{\n\tstruct drm_encoder *encoder = &radeon_encoder->base;\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder_atom_dig *dig;\n\tDISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION args;\n\tint index;\n\n\tif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\n\t\treturn;\n\n\tif ((radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\n\t    radeon_encoder->enc_priv) {\n\t\tdig = radeon_encoder->enc_priv;\n\t\tdig->backlight_level = level;\n\t\tradeon_atom_set_backlight_level_to_reg(rdev, dig->backlight_level);\n\n\t\tswitch (radeon_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);\n\t\t\tif (dig->backlight_level == 0) {\n\t\t\t\targs.ucAction = ATOM_LCD_BLOFF;\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t\t} else {\n\t\t\t\targs.ucAction = ATOM_LCD_BL_BRIGHTNESS_CONTROL;\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t\t\targs.ucAction = ATOM_LCD_BLON;\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\t\tif (dig->backlight_level == 0)\n\t\t\t\tatombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);\n\t\t\telse {\n\t\t\t\tatombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_BL_BRIGHTNESS_CONTROL, 0, 0);\n\t\t\t\tatombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic u8 radeon_atom_bl_level(struct backlight_device *bd)\n{\n\tu8 level;\n\n\t \n\tif (bd->props.brightness < 0)\n\t\tlevel = 0;\n\telse if (bd->props.brightness > RADEON_MAX_BL_LEVEL)\n\t\tlevel = RADEON_MAX_BL_LEVEL;\n\telse\n\t\tlevel = bd->props.brightness;\n\n\treturn level;\n}\n\nstatic int radeon_atom_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct radeon_backlight_privdata *pdata = bl_get_data(bd);\n\tstruct radeon_encoder *radeon_encoder = pdata->encoder;\n\n\tatombios_set_backlight_level(radeon_encoder, radeon_atom_bl_level(bd));\n\n\treturn 0;\n}\n\nstatic int radeon_atom_backlight_get_brightness(struct backlight_device *bd)\n{\n\tstruct radeon_backlight_privdata *pdata = bl_get_data(bd);\n\tstruct radeon_encoder *radeon_encoder = pdata->encoder;\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\treturn radeon_atom_get_backlight_level_from_reg(rdev);\n}\n\nstatic const struct backlight_ops radeon_atom_backlight_ops = {\n\t.get_brightness = radeon_atom_backlight_get_brightness,\n\t.update_status\t= radeon_atom_backlight_update_status,\n};\n\nvoid radeon_atom_backlight_init(struct radeon_encoder *radeon_encoder,\n\t\t\t\tstruct drm_connector *drm_connector)\n{\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct backlight_device *bd;\n\tstruct backlight_properties props;\n\tstruct radeon_backlight_privdata *pdata;\n\tstruct radeon_encoder_atom_dig *dig;\n\tchar bl_name[16];\n\n\t \n\tif ((rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE) &&\n\t    (rdev->pdev->device == 0x6741) &&\n\t    !dmi_match(DMI_PRODUCT_NAME, \"iMac12,1\"))\n\t\treturn;\n\n\tif (!radeon_encoder->enc_priv)\n\t\treturn;\n\n\tif (!rdev->is_atom_bios)\n\t\treturn;\n\n\tif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\n\t\treturn;\n\n\tif (!acpi_video_backlight_use_native()) {\n\t\tdrm_info(dev, \"Skipping radeon atom DIG backlight registration\\n\");\n\t\treturn;\n\t}\n\n\tpdata = kmalloc(sizeof(struct radeon_backlight_privdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tDRM_ERROR(\"Memory allocation failed\\n\");\n\t\tgoto error;\n\t}\n\n\tmemset(&props, 0, sizeof(props));\n\tprops.max_brightness = RADEON_MAX_BL_LEVEL;\n\tprops.type = BACKLIGHT_RAW;\n\tsnprintf(bl_name, sizeof(bl_name),\n\t\t \"radeon_bl%d\", dev->primary->index);\n\tbd = backlight_device_register(bl_name, drm_connector->kdev,\n\t\t\t\t       pdata, &radeon_atom_backlight_ops, &props);\n\tif (IS_ERR(bd)) {\n\t\tDRM_ERROR(\"Backlight registration failed\\n\");\n\t\tgoto error;\n\t}\n\n\tpdata->encoder = radeon_encoder;\n\n\tdig = radeon_encoder->enc_priv;\n\tdig->bl_dev = bd;\n\n\tbd->props.brightness = radeon_atom_backlight_get_brightness(bd);\n\t \n\tif (bd->props.brightness == 0)\n\t\tbd->props.brightness = RADEON_MAX_BL_LEVEL;\n\tbd->props.power = FB_BLANK_UNBLANK;\n\tbacklight_update_status(bd);\n\n\tDRM_INFO(\"radeon atom DIG backlight initialized\\n\");\n\trdev->mode_info.bl_encoder = radeon_encoder;\n\n\treturn;\n\nerror:\n\tkfree(pdata);\n\treturn;\n}\n\nstatic void radeon_atom_backlight_exit(struct radeon_encoder *radeon_encoder)\n{\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct backlight_device *bd = NULL;\n\tstruct radeon_encoder_atom_dig *dig;\n\n\tif (!radeon_encoder->enc_priv)\n\t\treturn;\n\n\tif (!rdev->is_atom_bios)\n\t\treturn;\n\n\tif (!(rdev->mode_info.firmware_flags & ATOM_BIOS_INFO_BL_CONTROLLED_BY_GPU))\n\t\treturn;\n\n\tdig = radeon_encoder->enc_priv;\n\tbd = dig->bl_dev;\n\tdig->bl_dev = NULL;\n\n\tif (bd) {\n\t\tstruct radeon_legacy_backlight_privdata *pdata;\n\n\t\tpdata = bl_get_data(bd);\n\t\tbacklight_device_unregister(bd);\n\t\tkfree(pdata);\n\n\t\tDRM_INFO(\"radeon atom LVDS backlight unloaded\\n\");\n\t}\n}\n\nstatic bool radeon_atom_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\t   const struct drm_display_mode *mode,\n\t\t\t\t   struct drm_display_mode *adjusted_mode)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\n\t \n\tradeon_encoder_set_active_device(encoder);\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\n\t \n\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t    && (mode->crtc_vsync_start < (mode->crtc_vdisplay + 2)))\n\t\tadjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vdisplay + 2;\n\n\t \n\tif (mode->crtc_vsync_start == mode->crtc_vdisplay)\n\t\tadjusted_mode->crtc_vsync_start++;\n\n\t \n\tif (radeon_encoder->active_device & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\tradeon_panel_mode_fixup(encoder, adjusted_mode);\n\t} else if (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT)) {\n\t\tstruct radeon_encoder_atom_dac *tv_dac = radeon_encoder->enc_priv;\n\t\tif (tv_dac) {\n\t\t\tif (tv_dac->tv_std == TV_STD_NTSC ||\n\t\t\t    tv_dac->tv_std == TV_STD_NTSC_J ||\n\t\t\t    tv_dac->tv_std == TV_STD_PAL_M)\n\t\t\t\tradeon_atom_get_tv_timings(rdev, 0, adjusted_mode);\n\t\t\telse\n\t\t\t\tradeon_atom_get_tv_timings(rdev, 1, adjusted_mode);\n\t\t}\n\t} else if (radeon_encoder->rmx_type != RMX_OFF) {\n\t\tradeon_panel_mode_fixup(encoder, adjusted_mode);\n\t}\n\n\tif (ASIC_IS_DCE3(rdev) &&\n\t    ((radeon_encoder->active_device & (ATOM_DEVICE_DFP_SUPPORT | ATOM_DEVICE_LCD_SUPPORT)) ||\n\t     (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE))) {\n\t\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\t\tradeon_dp_set_link_config(connector, adjusted_mode);\n\t}\n\n\treturn true;\n}\n\nstatic void\natombios_dac_setup(struct drm_encoder *encoder, int action)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tDAC_ENCODER_CONTROL_PS_ALLOCATION args;\n\tint index = 0;\n\tstruct radeon_encoder_atom_dac *dac_info = radeon_encoder->enc_priv;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, DAC1EncoderControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, DAC2EncoderControl);\n\t\tbreak;\n\t}\n\n\targs.ucAction = action;\n\n\tif (radeon_encoder->active_device & (ATOM_DEVICE_CRT_SUPPORT))\n\t\targs.ucDacStandard = ATOM_DAC1_PS2;\n\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\targs.ucDacStandard = ATOM_DAC1_CV;\n\telse {\n\t\tswitch (dac_info->tv_std) {\n\t\tcase TV_STD_PAL:\n\t\tcase TV_STD_PAL_M:\n\t\tcase TV_STD_SCART_PAL:\n\t\tcase TV_STD_SECAM:\n\t\tcase TV_STD_PAL_CN:\n\t\t\targs.ucDacStandard = ATOM_DAC1_PAL;\n\t\t\tbreak;\n\t\tcase TV_STD_NTSC:\n\t\tcase TV_STD_NTSC_J:\n\t\tcase TV_STD_PAL_60:\n\t\tdefault:\n\t\t\targs.ucDacStandard = ATOM_DAC1_NTSC;\n\t\t\tbreak;\n\t\t}\n\t}\n\targs.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n}\n\nstatic void\natombios_tv_setup(struct drm_encoder *encoder, int action)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tTV_ENCODER_CONTROL_PS_ALLOCATION args;\n\tint index = 0;\n\tstruct radeon_encoder_atom_dac *dac_info = radeon_encoder->enc_priv;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tindex = GetIndexIntoMasterTable(COMMAND, TVEncoderControl);\n\n\targs.sTVEncoder.ucAction = action;\n\n\tif (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_CV;\n\telse {\n\t\tswitch (dac_info->tv_std) {\n\t\tcase TV_STD_NTSC:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_NTSC;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_PAL;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL_M:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_PALM;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL_60:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_PAL60;\n\t\t\tbreak;\n\t\tcase TV_STD_NTSC_J:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_NTSCJ;\n\t\t\tbreak;\n\t\tcase TV_STD_SCART_PAL:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_PAL;  \n\t\t\tbreak;\n\t\tcase TV_STD_SECAM:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_SECAM;\n\t\t\tbreak;\n\t\tcase TV_STD_PAL_CN:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_PALCN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\targs.sTVEncoder.ucTvStandard = ATOM_TV_NTSC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\targs.sTVEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n}\n\nstatic u8 radeon_atom_get_bpc(struct drm_encoder *encoder)\n{\n\tint bpc = 8;\n\n\tif (encoder->crtc) {\n\t\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\t\tbpc = radeon_crtc->bpc;\n\t}\n\n\tswitch (bpc) {\n\tcase 0:\n\t\treturn PANEL_BPC_UNDEFINE;\n\tcase 6:\n\t\treturn PANEL_6BIT_PER_COLOR;\n\tcase 8:\n\tdefault:\n\t\treturn PANEL_8BIT_PER_COLOR;\n\tcase 10:\n\t\treturn PANEL_10BIT_PER_COLOR;\n\tcase 12:\n\t\treturn PANEL_12BIT_PER_COLOR;\n\tcase 16:\n\t\treturn PANEL_16BIT_PER_COLOR;\n\t}\n}\n\nunion dvo_encoder_control {\n\tENABLE_EXTERNAL_TMDS_ENCODER_PS_ALLOCATION ext_tmds;\n\tDVO_ENCODER_CONTROL_PS_ALLOCATION dvo;\n\tDVO_ENCODER_CONTROL_PS_ALLOCATION_V3 dvo_v3;\n\tDVO_ENCODER_CONTROL_PS_ALLOCATION_V1_4 dvo_v4;\n};\n\nvoid\natombios_dvo_setup(struct drm_encoder *encoder, int action)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tunion dvo_encoder_control args;\n\tint index = GetIndexIntoMasterTable(COMMAND, DVOEncoderControl);\n\tuint8_t frev, crev;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\t \n\tif (rdev->family <= CHIP_RV410)\n\t\tfrev = 1;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\t \n\t\t\targs.ext_tmds.sXTmdsEncoder.ucEnable = action;\n\n\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.ext_tmds.sXTmdsEncoder.ucMisc |= PANEL_ENCODER_MISC_DUAL;\n\n\t\t\targs.ext_tmds.sXTmdsEncoder.ucMisc |= ATOM_PANEL_MISC_888RGB;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t \n\t\t\targs.dvo.sDVOEncoder.ucAction = action;\n\t\t\targs.dvo.sDVOEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\t \n\t\t\targs.dvo.sDVOEncoder.ucDeviceType = ATOM_DEVICE_DFP1_INDEX;\n\n\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.dvo.sDVOEncoder.usDevAttr.sDigAttrib.ucAttribute |= PANEL_ENCODER_MISC_DUAL;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\targs.dvo_v3.ucAction = action;\n\t\t\targs.dvo_v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\targs.dvo_v3.ucDVOConfig = 0;  \n\t\t\tbreak;\n\t\tcase 4:\n\t\t\t \n\t\t\targs.dvo_v4.ucAction = action;\n\t\t\targs.dvo_v4.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\targs.dvo_v4.ucDVOConfig = 0;  \n\t\t\targs.dvo_v4.ucBitPerColor = radeon_atom_get_bpc(encoder);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\tbreak;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nunion lvds_encoder_control {\n\tLVDS_ENCODER_CONTROL_PS_ALLOCATION    v1;\n\tLVDS_ENCODER_CONTROL_PS_ALLOCATION_V2 v2;\n};\n\nvoid\natombios_digital_setup(struct drm_encoder *encoder, int action)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tunion lvds_encoder_control args;\n\tint index = 0;\n\tint hdmi_detected = 0;\n\tuint8_t frev, crev;\n\n\tif (!dig)\n\t\treturn;\n\n\tif (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI)\n\t\thdmi_detected = 1;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, LVDSEncoderControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, TMDS1EncoderControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, LVDSEncoderControl);\n\t\telse\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, TMDS2EncoderControl);\n\t\tbreak;\n\t}\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\tcase 2:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\targs.v1.ucMisc = 0;\n\t\t\targs.v1.ucAction = action;\n\t\t\tif (hdmi_detected)\n\t\t\t\targs.v1.ucMisc |= PANEL_ENCODER_MISC_HDMI_TYPE;\n\t\t\targs.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_DUAL)\n\t\t\t\t\targs.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;\n\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)\n\t\t\t\t\targs.v1.ucMisc |= ATOM_PANEL_MISC_888RGB;\n\t\t\t} else {\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\targs.v1.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;\n\t\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v1.ucMisc |= PANEL_ENCODER_MISC_DUAL;\n\t\t\t\t \n\t\t\t\targs.v1.ucMisc |= ATOM_PANEL_MISC_888RGB;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\targs.v2.ucMisc = 0;\n\t\t\targs.v2.ucAction = action;\n\t\t\tif (crev == 3) {\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v2.ucMisc |= PANEL_ENCODER_MISC_COHERENT;\n\t\t\t}\n\t\t\tif (hdmi_detected)\n\t\t\t\targs.v2.ucMisc |= PANEL_ENCODER_MISC_HDMI_TYPE;\n\t\t\targs.v2.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\targs.v2.ucTruncate = 0;\n\t\t\targs.v2.ucSpatial = 0;\n\t\t\targs.v2.ucTemporal = 0;\n\t\t\targs.v2.ucFRC = 0;\n\t\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_DUAL)\n\t\t\t\t\targs.v2.ucMisc |= PANEL_ENCODER_MISC_DUAL;\n\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_SPATIAL) {\n\t\t\t\t\targs.v2.ucSpatial = PANEL_ENCODER_SPATIAL_DITHER_EN;\n\t\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)\n\t\t\t\t\t\targs.v2.ucSpatial |= PANEL_ENCODER_SPATIAL_DITHER_DEPTH;\n\t\t\t\t}\n\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_TEMPORAL) {\n\t\t\t\t\targs.v2.ucTemporal = PANEL_ENCODER_TEMPORAL_DITHER_EN;\n\t\t\t\t\tif (dig->lcd_misc & ATOM_PANEL_MISC_888RGB)\n\t\t\t\t\t\targs.v2.ucTemporal |= PANEL_ENCODER_TEMPORAL_DITHER_DEPTH;\n\t\t\t\t\tif (((dig->lcd_misc >> ATOM_PANEL_MISC_GREY_LEVEL_SHIFT) & 0x3) == 2)\n\t\t\t\t\t\targs.v2.ucTemporal |= PANEL_ENCODER_TEMPORAL_LEVEL_4;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\targs.v2.ucMisc |= PANEL_ENCODER_MISC_TMDS_LINKB;\n\t\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v2.ucMisc |= PANEL_ENCODER_MISC_DUAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\tbreak;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nint\natombios_get_encoder_mode(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\tstruct radeon_connector_atom_dig *dig_connector;\n\n\t \n\tif (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)\n\t\treturn ATOM_ENCODER_MODE_DP;\n\n\t \n\tif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DVO1) ||\n\t    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1))\n\t\treturn ATOM_ENCODER_MODE_DVO;\n\n\tconnector = radeon_get_connector_for_encoder(encoder);\n\t \n\tif (!connector)\n\t\tconnector = radeon_get_connector_for_encoder_init(encoder);\n\tradeon_connector = to_radeon_connector(connector);\n\n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_HDMIB:  \n\t\tif (radeon_audio != 0) {\n\t\t\tif (radeon_connector->use_digital &&\n\t\t\t    (radeon_connector->audio == RADEON_AUDIO_ENABLE))\n\t\t\t\treturn ATOM_ENCODER_MODE_HDMI;\n\t\t\telse if (drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\n\t\t\t\t (radeon_connector->audio == RADEON_AUDIO_AUTO))\n\t\t\t\treturn ATOM_ENCODER_MODE_HDMI;\n\t\t\telse if (radeon_connector->use_digital)\n\t\t\t\treturn ATOM_ENCODER_MODE_DVI;\n\t\t\telse\n\t\t\t\treturn ATOM_ENCODER_MODE_CRT;\n\t\t} else if (radeon_connector->use_digital) {\n\t\t\treturn ATOM_ENCODER_MODE_DVI;\n\t\t} else {\n\t\t\treturn ATOM_ENCODER_MODE_CRT;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DVID:\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\tdefault:\n\t\tif (radeon_audio != 0) {\n\t\t\tif (radeon_connector->audio == RADEON_AUDIO_ENABLE)\n\t\t\t\treturn ATOM_ENCODER_MODE_HDMI;\n\t\t\telse if (drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\n\t\t\t\t (radeon_connector->audio == RADEON_AUDIO_AUTO))\n\t\t\t\treturn ATOM_ENCODER_MODE_HDMI;\n\t\t\telse\n\t\t\t\treturn ATOM_ENCODER_MODE_DVI;\n\t\t} else {\n\t\t\treturn ATOM_ENCODER_MODE_DVI;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\treturn ATOM_ENCODER_MODE_LVDS;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tdig_connector = radeon_connector->con_priv;\n\t\tif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t\t    (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\n\t\t\tif (radeon_audio != 0 &&\n\t\t\t    drm_detect_monitor_audio(radeon_connector_edid(connector)) &&\n\t\t\t    ASIC_IS_DCE4(rdev) && !ASIC_IS_DCE5(rdev))\n\t\t\t\treturn ATOM_ENCODER_MODE_DP_AUDIO;\n\t\t\treturn ATOM_ENCODER_MODE_DP;\n\t\t} else if (radeon_audio != 0) {\n\t\t\tif (radeon_connector->audio == RADEON_AUDIO_ENABLE)\n\t\t\t\treturn ATOM_ENCODER_MODE_HDMI;\n\t\t\telse if (drm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\n\t\t\t\t (radeon_connector->audio == RADEON_AUDIO_AUTO))\n\t\t\t\treturn ATOM_ENCODER_MODE_HDMI;\n\t\t\telse\n\t\t\t\treturn ATOM_ENCODER_MODE_DVI;\n\t\t} else {\n\t\t\treturn ATOM_ENCODER_MODE_DVI;\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tif (radeon_audio != 0 &&\n\t\t    drm_detect_monitor_audio(radeon_connector_edid(connector)) &&\n\t\t    ASIC_IS_DCE4(rdev) && !ASIC_IS_DCE5(rdev))\n\t\t\treturn ATOM_ENCODER_MODE_DP_AUDIO;\n\t\treturn ATOM_ENCODER_MODE_DP;\n\tcase DRM_MODE_CONNECTOR_DVIA:\n\tcase DRM_MODE_CONNECTOR_VGA:\n\t\treturn ATOM_ENCODER_MODE_CRT;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_Composite:\n\tcase DRM_MODE_CONNECTOR_SVIDEO:\n\tcase DRM_MODE_CONNECTOR_9PinDIN:\n\t\t \n\t\treturn ATOM_ENCODER_MODE_TV;\n\t\t \n\t\tbreak;\n\t}\n}\n\n \n\nunion dig_encoder_control {\n\tDIG_ENCODER_CONTROL_PS_ALLOCATION v1;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V2 v2;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V3 v3;\n\tDIG_ENCODER_CONTROL_PARAMETERS_V4 v4;\n};\n\nvoid\natombios_dig_encoder_setup2(struct drm_encoder *encoder, int action, int panel_mode, int enc_override)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tunion dig_encoder_control args;\n\tint index = 0;\n\tuint8_t frev, crev;\n\tint dp_clock = 0;\n\tint dp_lane_count = 0;\n\tint hpd_id = RADEON_HPD_NONE;\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\tradeon_connector->con_priv;\n\n\t\tdp_clock = dig_connector->dp_clock;\n\t\tdp_lane_count = dig_connector->dp_lane_count;\n\t\thpd_id = radeon_connector->hpd.hpd;\n\t}\n\n\t \n\tif (dig->dig_encoder == -1)\n\t\treturn;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (ASIC_IS_DCE4(rdev))\n\t\tindex = GetIndexIntoMasterTable(COMMAND, DIGxEncoderControl);\n\telse {\n\t\tif (dig->dig_encoder)\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, DIG2EncoderControl);\n\t\telse\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, DIG1EncoderControl);\n\t}\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\targs.v1.ucAction = action;\n\t\t\targs.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\tif (action == ATOM_ENCODER_CMD_SETUP_PANEL_MODE)\n\t\t\t\targs.v3.ucPanelMode = panel_mode;\n\t\t\telse\n\t\t\t\targs.v1.ucEncoderMode = atombios_get_encoder_mode(encoder);\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode))\n\t\t\t\targs.v1.ucLaneNum = dp_lane_count;\n\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v1.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v1.ucLaneNum = 4;\n\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\t\targs.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER1;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\t\t\targs.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER2;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\t\targs.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (dig->linkb)\n\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKB;\n\t\t\telse\n\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKA;\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode) && (dp_clock == 270000))\n\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;\n\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\targs.v3.ucAction = action;\n\t\t\targs.v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\tif (action == ATOM_ENCODER_CMD_SETUP_PANEL_MODE)\n\t\t\t\targs.v3.ucPanelMode = panel_mode;\n\t\t\telse\n\t\t\t\targs.v3.ucEncoderMode = atombios_get_encoder_mode(encoder);\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v3.ucEncoderMode))\n\t\t\t\targs.v3.ucLaneNum = dp_lane_count;\n\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v3.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v3.ucLaneNum = 4;\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v3.ucEncoderMode) && (dp_clock == 270000))\n\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V3_DPLINKRATE_2_70GHZ;\n\t\t\tif (enc_override != -1)\n\t\t\t\targs.v3.acConfig.ucDigSel = enc_override;\n\t\t\telse\n\t\t\t\targs.v3.acConfig.ucDigSel = dig->dig_encoder;\n\t\t\targs.v3.ucBitPerColor = radeon_atom_get_bpc(encoder);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\targs.v4.ucAction = action;\n\t\t\targs.v4.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\tif (action == ATOM_ENCODER_CMD_SETUP_PANEL_MODE)\n\t\t\t\targs.v4.ucPanelMode = panel_mode;\n\t\t\telse\n\t\t\t\targs.v4.ucEncoderMode = atombios_get_encoder_mode(encoder);\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v4.ucEncoderMode))\n\t\t\t\targs.v4.ucLaneNum = dp_lane_count;\n\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v4.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v4.ucLaneNum = 4;\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v4.ucEncoderMode)) {\n\t\t\t\tif (dp_clock == 540000)\n\t\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_5_40GHZ;\n\t\t\t\telse if (dp_clock == 324000)\n\t\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_3_24GHZ;\n\t\t\t\telse if (dp_clock == 270000)\n\t\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_2_70GHZ;\n\t\t\t\telse\n\t\t\t\t\targs.v1.ucConfig |= ATOM_ENCODER_CONFIG_V4_DPLINKRATE_1_62GHZ;\n\t\t\t}\n\n\t\t\tif (enc_override != -1)\n\t\t\t\targs.v4.acConfig.ucDigSel = enc_override;\n\t\t\telse\n\t\t\t\targs.v4.acConfig.ucDigSel = dig->dig_encoder;\n\t\t\targs.v4.ucBitPerColor = radeon_atom_get_bpc(encoder);\n\t\t\tif (hpd_id == RADEON_HPD_NONE)\n\t\t\t\targs.v4.ucHPD_ID = 0;\n\t\t\telse\n\t\t\t\targs.v4.ucHPD_ID = hpd_id + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\tbreak;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n}\n\nvoid\natombios_dig_encoder_setup(struct drm_encoder *encoder, int action, int panel_mode)\n{\n\tatombios_dig_encoder_setup2(encoder, action, panel_mode, -1);\n}\n\nunion dig_transmitter_control {\n\tDIG_TRANSMITTER_CONTROL_PS_ALLOCATION v1;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V2 v2;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V3 v3;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V4 v4;\n\tDIG_TRANSMITTER_CONTROL_PARAMETERS_V1_5 v5;\n};\n\nvoid\natombios_dig_transmitter_setup2(struct drm_encoder *encoder, int action, uint8_t lane_num, uint8_t lane_set, int fe)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector;\n\tunion dig_transmitter_control args;\n\tint index = 0;\n\tuint8_t frev, crev;\n\tbool is_dp = false;\n\tint pll_id = 0;\n\tint dp_clock = 0;\n\tint dp_lane_count = 0;\n\tint connector_object_id = 0;\n\tint igp_lane_info = 0;\n\tint dig_encoder = dig->dig_encoder;\n\tint hpd_id = RADEON_HPD_NONE;\n\n\tif (action == ATOM_TRANSMITTER_ACTION_INIT) {\n\t\tconnector = radeon_get_connector_for_encoder_init(encoder);\n\t\t \n\t\tdig_encoder = 0;\n\t} else\n\t\tconnector = radeon_get_connector_for_encoder(encoder);\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\tradeon_connector->con_priv;\n\n\t\thpd_id = radeon_connector->hpd.hpd;\n\t\tdp_clock = dig_connector->dp_clock;\n\t\tdp_lane_count = dig_connector->dp_lane_count;\n\t\tconnector_object_id =\n\t\t\t(radeon_connector->connector_object_id & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\n\t\tigp_lane_info = dig_connector->igp_lane_info;\n\t}\n\n\tif (encoder->crtc) {\n\t\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\t\tpll_id = radeon_crtc->pll_id;\n\t}\n\n\t \n\tif (dig_encoder == -1)\n\t\treturn;\n\n\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)))\n\t\tis_dp = true;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, LVTMATransmitterControl);\n\t\tbreak;\n\t}\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\t\targs.v1.ucAction = action;\n\t\t\tif (action == ATOM_TRANSMITTER_ACTION_INIT) {\n\t\t\t\targs.v1.usInitInfo = cpu_to_le16(connector_object_id);\n\t\t\t} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\n\t\t\t\targs.v1.asMode.ucLaneSel = lane_num;\n\t\t\t\targs.v1.asMode.ucLaneSet = lane_set;\n\t\t\t} else {\n\t\t\t\tif (is_dp)\n\t\t\t\t\targs.v1.usPixelClock = cpu_to_le16(dp_clock / 10);\n\t\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v1.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\n\t\t\t\telse\n\t\t\t\t\targs.v1.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\t}\n\n\t\t\targs.v1.ucConfig = ATOM_TRANSMITTER_CONFIG_CLKSRC_PPLL;\n\n\t\t\tif (dig_encoder)\n\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG2_ENCODER;\n\t\t\telse\n\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG1_ENCODER;\n\n\t\t\tif ((rdev->flags & RADEON_IS_IGP) &&\n\t\t\t    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_UNIPHY)) {\n\t\t\t\tif (is_dp ||\n\t\t\t\t    !radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock)) {\n\t\t\t\t\tif (igp_lane_info & 0x1)\n\t\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_0_3;\n\t\t\t\t\telse if (igp_lane_info & 0x2)\n\t\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_4_7;\n\t\t\t\t\telse if (igp_lane_info & 0x4)\n\t\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_8_11;\n\t\t\t\t\telse if (igp_lane_info & 0x8)\n\t\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_12_15;\n\t\t\t\t} else {\n\t\t\t\t\tif (igp_lane_info & 0x3)\n\t\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_0_7;\n\t\t\t\t\telse if (igp_lane_info & 0xc)\n\t\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LANE_8_15;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dig->linkb)\n\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LINKB;\n\t\t\telse\n\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LINKA;\n\n\t\t\tif (is_dp)\n\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_COHERENT;\n\t\t\telse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_COHERENT;\n\t\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_8LANE_LINK;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\targs.v2.ucAction = action;\n\t\t\tif (action == ATOM_TRANSMITTER_ACTION_INIT) {\n\t\t\t\targs.v2.usInitInfo = cpu_to_le16(connector_object_id);\n\t\t\t} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\n\t\t\t\targs.v2.asMode.ucLaneSel = lane_num;\n\t\t\t\targs.v2.asMode.ucLaneSet = lane_set;\n\t\t\t} else {\n\t\t\t\tif (is_dp)\n\t\t\t\t\targs.v2.usPixelClock = cpu_to_le16(dp_clock / 10);\n\t\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v2.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\n\t\t\t\telse\n\t\t\t\t\targs.v2.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\t}\n\n\t\t\targs.v2.acConfig.ucEncoderSel = dig_encoder;\n\t\t\tif (dig->linkb)\n\t\t\t\targs.v2.acConfig.ucLinkSel = 1;\n\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\t\targs.v2.acConfig.ucTransmitterSel = 0;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\t\targs.v2.acConfig.ucTransmitterSel = 1;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\t\targs.v2.acConfig.ucTransmitterSel = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (is_dp) {\n\t\t\t\targs.v2.acConfig.fCoherentMode = 1;\n\t\t\t\targs.v2.acConfig.fDPConnector = 1;\n\t\t\t} else if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v2.acConfig.fCoherentMode = 1;\n\t\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v2.acConfig.fDualLinkConnector = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\targs.v3.ucAction = action;\n\t\t\tif (action == ATOM_TRANSMITTER_ACTION_INIT) {\n\t\t\t\targs.v3.usInitInfo = cpu_to_le16(connector_object_id);\n\t\t\t} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\n\t\t\t\targs.v3.asMode.ucLaneSel = lane_num;\n\t\t\t\targs.v3.asMode.ucLaneSet = lane_set;\n\t\t\t} else {\n\t\t\t\tif (is_dp)\n\t\t\t\t\targs.v3.usPixelClock = cpu_to_le16(dp_clock / 10);\n\t\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v3.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\n\t\t\t\telse\n\t\t\t\t\targs.v3.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\t}\n\n\t\t\tif (is_dp)\n\t\t\t\targs.v3.ucLaneNum = dp_lane_count;\n\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v3.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v3.ucLaneNum = 4;\n\n\t\t\tif (dig->linkb)\n\t\t\t\targs.v3.acConfig.ucLinkSel = 1;\n\t\t\tif (dig_encoder & 1)\n\t\t\t\targs.v3.acConfig.ucEncoderSel = 1;\n\n\t\t\t \n\t\t\t \n\t\t\tif (is_dp && rdev->clock.dp_extclk)\n\t\t\t\targs.v3.acConfig.ucRefClkSource = 2;  \n\t\t\telse\n\t\t\t\targs.v3.acConfig.ucRefClkSource = pll_id;\n\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\t\targs.v3.acConfig.ucTransmitterSel = 0;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\t\targs.v3.acConfig.ucTransmitterSel = 1;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\t\targs.v3.acConfig.ucTransmitterSel = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (is_dp)\n\t\t\t\targs.v3.acConfig.fCoherentMode = 1;  \n\t\t\telse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v3.acConfig.fCoherentMode = 1;\n\t\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v3.acConfig.fDualLinkConnector = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\targs.v4.ucAction = action;\n\t\t\tif (action == ATOM_TRANSMITTER_ACTION_INIT) {\n\t\t\t\targs.v4.usInitInfo = cpu_to_le16(connector_object_id);\n\t\t\t} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {\n\t\t\t\targs.v4.asMode.ucLaneSel = lane_num;\n\t\t\t\targs.v4.asMode.ucLaneSet = lane_set;\n\t\t\t} else {\n\t\t\t\tif (is_dp)\n\t\t\t\t\targs.v4.usPixelClock = cpu_to_le16(dp_clock / 10);\n\t\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v4.usPixelClock = cpu_to_le16((radeon_encoder->pixel_clock / 2) / 10);\n\t\t\t\telse\n\t\t\t\t\targs.v4.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\t}\n\n\t\t\tif (is_dp)\n\t\t\t\targs.v4.ucLaneNum = dp_lane_count;\n\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v4.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v4.ucLaneNum = 4;\n\n\t\t\tif (dig->linkb)\n\t\t\t\targs.v4.acConfig.ucLinkSel = 1;\n\t\t\tif (dig_encoder & 1)\n\t\t\t\targs.v4.acConfig.ucEncoderSel = 1;\n\n\t\t\t \n\t\t\t \n\t\t\tif (is_dp) {\n\t\t\t\tif (rdev->clock.dp_extclk)\n\t\t\t\t\targs.v4.acConfig.ucRefClkSource = ENCODER_REFCLK_SRC_EXTCLK;\n\t\t\t\telse\n\t\t\t\t\targs.v4.acConfig.ucRefClkSource = ENCODER_REFCLK_SRC_DCPLL;\n\t\t\t} else\n\t\t\t\targs.v4.acConfig.ucRefClkSource = pll_id;\n\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\t\targs.v4.acConfig.ucTransmitterSel = 0;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\t\targs.v4.acConfig.ucTransmitterSel = 1;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\t\targs.v4.acConfig.ucTransmitterSel = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (is_dp)\n\t\t\t\targs.v4.acConfig.fCoherentMode = 1;  \n\t\t\telse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v4.acConfig.fCoherentMode = 1;\n\t\t\t\tif (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\t\targs.v4.acConfig.fDualLinkConnector = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\targs.v5.ucAction = action;\n\t\t\tif (is_dp)\n\t\t\t\targs.v5.usSymClock = cpu_to_le16(dp_clock / 10);\n\t\t\telse\n\t\t\t\targs.v5.usSymClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYB;\n\t\t\t\telse\n\t\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYA;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYD;\n\t\t\t\telse\n\t\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYC;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYF;\n\t\t\t\telse\n\t\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYE;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\t\t\targs.v5.ucPhyId = ATOM_PHY_ID_UNIPHYG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (is_dp)\n\t\t\t\targs.v5.ucLaneNum = dp_lane_count;\n\t\t\telse if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v5.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v5.ucLaneNum = 4;\n\t\t\targs.v5.ucConnObjId = connector_object_id;\n\t\t\targs.v5.ucDigMode = atombios_get_encoder_mode(encoder);\n\n\t\t\tif (is_dp && rdev->clock.dp_extclk)\n\t\t\t\targs.v5.asConfig.ucPhyClkSrcId = ENCODER_REFCLK_SRC_EXTCLK;\n\t\t\telse\n\t\t\t\targs.v5.asConfig.ucPhyClkSrcId = pll_id;\n\n\t\t\tif (is_dp)\n\t\t\t\targs.v5.asConfig.ucCoherentMode = 1;  \n\t\t\telse if (radeon_encoder->devices & (ATOM_DEVICE_DFP_SUPPORT)) {\n\t\t\t\tif (dig->coherent_mode)\n\t\t\t\t\targs.v5.asConfig.ucCoherentMode = 1;\n\t\t\t}\n\t\t\tif (hpd_id == RADEON_HPD_NONE)\n\t\t\t\targs.v5.asConfig.ucHPDSel = 0;\n\t\t\telse\n\t\t\t\targs.v5.asConfig.ucHPDSel = hpd_id + 1;\n\t\t\targs.v5.ucDigEncoderSel = (fe != -1) ? (1 << fe) : (1 << dig_encoder);\n\t\t\targs.v5.ucDPLaneSet = lane_set;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version %d, %d\\n\", frev, crev);\n\t\tbreak;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nvoid\natombios_dig_transmitter_setup(struct drm_encoder *encoder, int action, uint8_t lane_num, uint8_t lane_set)\n{\n\tatombios_dig_transmitter_setup2(encoder, action, lane_num, lane_set, -1);\n}\n\nbool\natombios_set_edp_panel_power(struct drm_connector *connector, int action)\n{\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_device *dev = radeon_connector->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tunion dig_transmitter_control args;\n\tint index = GetIndexIntoMasterTable(COMMAND, UNIPHYTransmitterControl);\n\tuint8_t frev, crev;\n\n\tif (connector->connector_type != DRM_MODE_CONNECTOR_eDP)\n\t\tgoto done;\n\n\tif (!ASIC_IS_DCE4(rdev))\n\t\tgoto done;\n\n\tif ((action != ATOM_TRANSMITTER_ACTION_POWER_ON) &&\n\t    (action != ATOM_TRANSMITTER_ACTION_POWER_OFF))\n\t\tgoto done;\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\tgoto done;\n\n\tmemset(&args, 0, sizeof(args));\n\n\targs.v1.ucAction = action;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t \n\tif (action == ATOM_TRANSMITTER_ACTION_POWER_ON) {\n\t\tint i;\n\n\t\tfor (i = 0; i < 300; i++) {\n\t\t\tif (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd))\n\t\t\t\treturn true;\n\t\t\tmdelay(1);\n\t\t}\n\t\treturn false;\n\t}\ndone:\n\treturn true;\n}\n\nunion external_encoder_control {\n\tEXTERNAL_ENCODER_CONTROL_PS_ALLOCATION v1;\n\tEXTERNAL_ENCODER_CONTROL_PS_ALLOCATION_V3 v3;\n};\n\nstatic void\natombios_external_encoder_setup(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_encoder *ext_encoder,\n\t\t\t\tint action)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder *ext_radeon_encoder = to_radeon_encoder(ext_encoder);\n\tunion external_encoder_control args;\n\tstruct drm_connector *connector;\n\tint index = GetIndexIntoMasterTable(COMMAND, ExternalEncoderControl);\n\tu8 frev, crev;\n\tint dp_clock = 0;\n\tint dp_lane_count = 0;\n\tint connector_object_id = 0;\n\tu32 ext_enum = (ext_radeon_encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\n\n\tif (action == EXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT)\n\t\tconnector = radeon_get_connector_for_encoder_init(encoder);\n\telse\n\t\tconnector = radeon_get_connector_for_encoder(encoder);\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\t\tstruct radeon_connector_atom_dig *dig_connector =\n\t\t\tradeon_connector->con_priv;\n\n\t\tdp_clock = dig_connector->dp_clock;\n\t\tdp_lane_count = dig_connector->dp_lane_count;\n\t\tconnector_object_id =\n\t\t\t(radeon_connector->connector_object_id & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\n\t}\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\t \n\t\tbreak;\n\tcase 2:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\targs.v1.sDigEncoder.ucAction = action;\n\t\t\targs.v1.sDigEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\targs.v1.sDigEncoder.ucEncoderMode = atombios_get_encoder_mode(encoder);\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v1.sDigEncoder.ucEncoderMode)) {\n\t\t\t\tif (dp_clock == 270000)\n\t\t\t\t\targs.v1.sDigEncoder.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;\n\t\t\t\targs.v1.sDigEncoder.ucLaneNum = dp_lane_count;\n\t\t\t} else if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v1.sDigEncoder.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v1.sDigEncoder.ucLaneNum = 4;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\targs.v3.sExtEncoder.ucAction = action;\n\t\t\tif (action == EXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT)\n\t\t\t\targs.v3.sExtEncoder.usConnectorId = cpu_to_le16(connector_object_id);\n\t\t\telse\n\t\t\t\targs.v3.sExtEncoder.usPixelClock = cpu_to_le16(radeon_encoder->pixel_clock / 10);\n\t\t\targs.v3.sExtEncoder.ucEncoderMode = atombios_get_encoder_mode(encoder);\n\n\t\t\tif (ENCODER_MODE_IS_DP(args.v3.sExtEncoder.ucEncoderMode)) {\n\t\t\t\tif (dp_clock == 270000)\n\t\t\t\t\targs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_DPLINKRATE_2_70GHZ;\n\t\t\t\telse if (dp_clock == 540000)\n\t\t\t\t\targs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_DPLINKRATE_5_40GHZ;\n\t\t\t\targs.v3.sExtEncoder.ucLaneNum = dp_lane_count;\n\t\t\t} else if (radeon_dig_monitor_is_duallink(encoder, radeon_encoder->pixel_clock))\n\t\t\t\targs.v3.sExtEncoder.ucLaneNum = 8;\n\t\t\telse\n\t\t\t\targs.v3.sExtEncoder.ucLaneNum = 4;\n\t\t\tswitch (ext_enum) {\n\t\t\tcase GRAPH_OBJECT_ENUM_ID1:\n\t\t\t\targs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_ENCODER1;\n\t\t\t\tbreak;\n\t\t\tcase GRAPH_OBJECT_ENUM_ID2:\n\t\t\t\targs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_ENCODER2;\n\t\t\t\tbreak;\n\t\t\tcase GRAPH_OBJECT_ENUM_ID3:\n\t\t\t\targs.v3.sExtEncoder.ucConfig |= EXTERNAL_ENCODER_CONFIG_V3_ENCODER3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targs.v3.sExtEncoder.ucBitPerColor = radeon_atom_get_bpc(encoder);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"Unknown table version: %d, %d\\n\", frev, crev);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version: %d, %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n}\n\nstatic void\natombios_yuv_setup(struct drm_encoder *encoder, bool enable)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\tENABLE_YUV_PS_ALLOCATION args;\n\tint index = GetIndexIntoMasterTable(COMMAND, EnableYUV);\n\tuint32_t temp, reg;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (rdev->family >= CHIP_R600)\n\t\treg = R600_BIOS_3_SCRATCH;\n\telse\n\t\treg = RADEON_BIOS_3_SCRATCH;\n\n\t \n\ttemp = RREG32(reg);\n\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\tWREG32(reg, (ATOM_S3_TV1_ACTIVE |\n\t\t\t     (radeon_crtc->crtc_id << 18)));\n\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\tWREG32(reg, (ATOM_S3_CV_ACTIVE | (radeon_crtc->crtc_id << 24)));\n\telse\n\t\tWREG32(reg, 0);\n\n\tif (enable)\n\t\targs.ucEnable = ATOM_ENABLE;\n\targs.ucCRTC = radeon_crtc->crtc_id;\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\tWREG32(reg, temp);\n}\n\nstatic void\nradeon_atom_encoder_dpms_avivo(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tDISPLAY_DEVICE_OUTPUT_CONTROL_PS_ALLOCATION args;\n\tint index = 0;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, TMDSAOutputControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, DVOOutputControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\t\tindex = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, LCD1OutputControl);\n\t\telse\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, LVTMAOutputControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, TV1OutputControl);\n\t\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, CV1OutputControl);\n\t\telse\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, DAC1OutputControl);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, TV1OutputControl);\n\t\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, CV1OutputControl);\n\t\telse\n\t\t\tindex = GetIndexIntoMasterTable(COMMAND, DAC2OutputControl);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\targs.ucAction = ATOM_ENABLE;\n\t\t \n\t\tif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DDI) {\n\t\t\tu32 reg = RREG32(RADEON_BIOS_3_SCRATCH);\n\t\t\tWREG32(RADEON_BIOS_3_SCRATCH, reg & ~ATOM_S3_DFP2I_ACTIVE);\n\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t\tWREG32(RADEON_BIOS_3_SCRATCH, reg);\n\t\t} else\n\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\tif (rdev->mode_info.bl_encoder) {\n\t\t\t\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\n\t\t\t\tatombios_set_backlight_level(radeon_encoder, dig->backlight_level);\n\t\t\t} else {\n\t\t\t\targs.ucAction = ATOM_LCD_BLON;\n\t\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\tcase DRM_MODE_DPMS_OFF:\n\t\targs.ucAction = ATOM_DISABLE;\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\targs.ucAction = ATOM_LCD_BLOFF;\n\t\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\nradeon_atom_encoder_dpms_dig(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tstruct radeon_connector *radeon_connector = NULL;\n\tstruct radeon_connector_atom_dig *radeon_dig_connector = NULL;\n\tbool travis_quirk = false;\n\n\tif (connector) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tradeon_dig_connector = radeon_connector->con_priv;\n\t\tif ((radeon_connector_encoder_get_dp_bridge_encoder_id(connector) ==\n\t\t     ENCODER_OBJECT_ID_TRAVIS) &&\n\t\t    (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) &&\n\t\t    !ASIC_IS_DCE5(rdev))\n\t\t\ttravis_quirk = true;\n\t}\n\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_ON:\n\t\tif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE5(rdev)) {\n\t\t\tif (!connector)\n\t\t\t\tdig->panel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\n\t\t\telse\n\t\t\t\tdig->panel_mode = radeon_dp_get_panel_mode(encoder, connector);\n\n\t\t\t \n\t\t\tatombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_SETUP, 0);\n\t\t\tatombios_dig_encoder_setup(encoder,\n\t\t\t\t\t\t   ATOM_ENCODER_CMD_SETUP_PANEL_MODE,\n\t\t\t\t\t\t   dig->panel_mode);\n\t\t\tif (ext_encoder) {\n\t\t\t\tif (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE61(rdev))\n\t\t\t\t\tatombios_external_encoder_setup(encoder, ext_encoder,\n\t\t\t\t\t\t\t\t\tEXTERNAL_ENCODER_ACTION_V3_ENCODER_SETUP);\n\t\t\t}\n\t\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\t\t \n\t\t\tatombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_SETUP, 0);\n\t\t} else {\n\t\t\t \n\t\t\tatombios_dig_encoder_setup(encoder, ATOM_ENABLE, 0);\n\t\t\tatombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_SETUP, 0, 0);\n\t\t}\n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {\n\t\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_ON);\n\t\t\t\tradeon_dig_connector->edp_on = true;\n\t\t\t}\n\t\t}\n\t\t \n\t\tatombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0);\n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {\n\t\t\t \n\t\t\tradeon_dp_link_train(encoder, connector);\n\t\t\tif (ASIC_IS_DCE4(rdev))\n\t\t\t\tatombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_ON, 0);\n\t\t}\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\tif (rdev->mode_info.bl_encoder)\n\t\t\t\tatombios_set_backlight_level(radeon_encoder, dig->backlight_level);\n\t\t\telse\n\t\t\t\tatombios_dig_transmitter_setup(encoder,\n\t\t\t\t\t\t\t       ATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);\n\t\t}\n\t\tif (ext_encoder)\n\t\t\tatombios_external_encoder_setup(encoder, ext_encoder, ATOM_ENABLE);\n\t\tbreak;\n\tcase DRM_MODE_DPMS_STANDBY:\n\tcase DRM_MODE_DPMS_SUSPEND:\n\tcase DRM_MODE_DPMS_OFF:\n\n\t\tif (ASIC_IS_DCE4(rdev)) {\n\t\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector)\n\t\t\t\tatombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_OFF, 0);\n\t\t}\n\t\tif (ext_encoder)\n\t\t\tatombios_external_encoder_setup(encoder, ext_encoder, ATOM_DISABLE);\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\tatombios_dig_transmitter_setup(encoder,\n\t\t\t\t\t\t       ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);\n\n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) &&\n\t\t    connector && !travis_quirk)\n\t\t\tradeon_dp_set_rx_power_state(connector, DP_SET_POWER_D3);\n\t\tif (ASIC_IS_DCE4(rdev)) {\n\t\t\t \n\t\t\tatombios_dig_transmitter_setup(encoder,\n\t\t\t\t\t\t       ATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);\n\t\t} else {\n\t\t\t \n\t\t\tatombios_dig_transmitter_setup(encoder,\n\t\t\t\t\t\t       ATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);\n\t\t\tatombios_dig_encoder_setup(encoder, ATOM_DISABLE, 0);\n\t\t}\n\t\tif (ENCODER_MODE_IS_DP(atombios_get_encoder_mode(encoder)) && connector) {\n\t\t\tif (travis_quirk)\n\t\t\t\tradeon_dp_set_rx_power_state(connector, DP_SET_POWER_D3);\n\t\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\n\t\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_OFF);\n\t\t\t\tradeon_dig_connector->edp_on = false;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\nradeon_atom_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tint encoder_mode = atombios_get_encoder_mode(encoder);\n\n\tDRM_DEBUG_KMS(\"encoder dpms %d to mode %d, devices %08x, active_devices %08x\\n\",\n\t\t  radeon_encoder->encoder_id, mode, radeon_encoder->devices,\n\t\t  radeon_encoder->active_device);\n\n\tif ((radeon_audio != 0) &&\n\t    ((encoder_mode == ATOM_ENCODER_MODE_HDMI) ||\n\t     ENCODER_MODE_IS_DP(encoder_mode)))\n\t\tradeon_audio_dpms(encoder, mode);\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\tradeon_atom_encoder_dpms_avivo(encoder, mode);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\tradeon_atom_encoder_dpms_dig(encoder, mode);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\tif (ASIC_IS_DCE5(rdev)) {\n\t\t\tswitch (mode) {\n\t\t\tcase DRM_MODE_DPMS_ON:\n\t\t\t\tatombios_dvo_setup(encoder, ATOM_ENABLE);\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_DPMS_STANDBY:\n\t\t\tcase DRM_MODE_DPMS_SUSPEND:\n\t\t\tcase DRM_MODE_DPMS_OFF:\n\t\t\t\tatombios_dvo_setup(encoder, ATOM_DISABLE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (ASIC_IS_DCE3(rdev))\n\t\t\tradeon_atom_encoder_dpms_dig(encoder, mode);\n\t\telse\n\t\t\tradeon_atom_encoder_dpms_avivo(encoder, mode);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\t\tif (ASIC_IS_DCE5(rdev)) {\n\t\t\tswitch (mode) {\n\t\t\tcase DRM_MODE_DPMS_ON:\n\t\t\t\tatombios_dac_setup(encoder, ATOM_ENABLE);\n\t\t\t\tbreak;\n\t\t\tcase DRM_MODE_DPMS_STANDBY:\n\t\t\tcase DRM_MODE_DPMS_SUSPEND:\n\t\t\tcase DRM_MODE_DPMS_OFF:\n\t\t\t\tatombios_dac_setup(encoder, ATOM_DISABLE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tradeon_atom_encoder_dpms_avivo(encoder, mode);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tradeon_atombios_encoder_dpms_scratch_regs(encoder, (mode == DRM_MODE_DPMS_ON) ? true : false);\n\n}\n\nunion crtc_source_param {\n\tSELECT_CRTC_SOURCE_PS_ALLOCATION v1;\n\tSELECT_CRTC_SOURCE_PARAMETERS_V2 v2;\n};\n\nstatic void\natombios_set_encoder_crtc_source(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\tunion crtc_source_param args;\n\tint index = GetIndexIntoMasterTable(COMMAND, SelectCRTC_Source);\n\tuint8_t frev, crev;\n\tstruct radeon_encoder_atom_dig *dig;\n\n\tmemset(&args, 0, sizeof(args));\n\n\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\treturn;\n\n\tswitch (frev) {\n\tcase 1:\n\t\tswitch (crev) {\n\t\tcase 1:\n\t\tdefault:\n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\targs.v1.ucCRTC = radeon_crtc->crtc_id;\n\t\t\telse {\n\t\t\t\tif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1)\n\t\t\t\t\targs.v1.ucCRTC = radeon_crtc->crtc_id;\n\t\t\t\telse\n\t\t\t\t\targs.v1.ucCRTC = radeon_crtc->crtc_id << 2;\n\t\t\t}\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_DFP1_INDEX;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\t\t\tif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT)\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_LCD1_INDEX;\n\t\t\t\telse\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_DFP3_INDEX;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_DFP2_INDEX;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\t\t\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_TV1_INDEX;\n\t\t\t\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_CV_INDEX;\n\t\t\t\telse\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_CRT1_INDEX;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\t\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_TV1_INDEX;\n\t\t\t\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_CV_INDEX;\n\t\t\t\telse\n\t\t\t\t\targs.v1.ucDevice = ATOM_DEVICE_CRT2_INDEX;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\targs.v2.ucCRTC = radeon_crtc->crtc_id;\n\t\t\tif (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE) {\n\t\t\t\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\n\t\t\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)\n\t\t\t\t\targs.v2.ucEncodeMode = ATOM_ENCODER_MODE_LVDS;\n\t\t\t\telse if (connector->connector_type == DRM_MODE_CONNECTOR_VGA)\n\t\t\t\t\targs.v2.ucEncodeMode = ATOM_ENCODER_MODE_CRT;\n\t\t\t\telse\n\t\t\t\t\targs.v2.ucEncodeMode = atombios_get_encoder_mode(encoder);\n\t\t\t} else if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\t\targs.v2.ucEncodeMode = ATOM_ENCODER_MODE_LVDS;\n\t\t\t} else {\n\t\t\t\targs.v2.ucEncodeMode = atombios_get_encoder_mode(encoder);\n\t\t\t}\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\t\t\tdig = radeon_encoder->enc_priv;\n\t\t\t\tswitch (dig->dig_encoder) {\n\t\t\t\tcase 0:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG1_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG2_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG3_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG4_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG5_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG6_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DIG7_ENCODER_ID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DVO_ENCODER_ID;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\t\t\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\n\t\t\t\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\n\t\t\t\telse\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DAC1_ENCODER_ID;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\t\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT))\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\n\t\t\t\telse if (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT))\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;\n\t\t\t\telse\n\t\t\t\t\targs.v2.ucEncoderID = ASIC_INT_DAC2_ENCODER_ID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unknown table version: %d, %d\\n\", frev, crev);\n\t\treturn;\n\t}\n\n\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t \n\tradeon_atombios_encoder_crtc_scratch_regs(encoder, radeon_crtc->crtc_id);\n}\n\nstatic void\natombios_apply_encoder_quirks(struct drm_encoder *encoder,\n\t\t\t      struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\n\t \n\tif ((rdev->pdev->device == 0x71C5) &&\n\t    (rdev->pdev->subsystem_vendor == 0x106b) &&\n\t    (rdev->pdev->subsystem_device == 0x0080)) {\n\t\tif (radeon_encoder->devices & ATOM_DEVICE_LCD1_SUPPORT) {\n\t\t\tuint32_t lvtma_bit_depth_control = RREG32(AVIVO_LVTMA_BIT_DEPTH_CONTROL);\n\n\t\t\tlvtma_bit_depth_control &= ~AVIVO_LVTMA_BIT_DEPTH_CONTROL_TRUNCATE_EN;\n\t\t\tlvtma_bit_depth_control &= ~AVIVO_LVTMA_BIT_DEPTH_CONTROL_SPATIAL_DITHER_EN;\n\n\t\t\tWREG32(AVIVO_LVTMA_BIT_DEPTH_CONTROL, lvtma_bit_depth_control);\n\t\t}\n\t}\n\n\t \n\tif (ASIC_IS_AVIVO(rdev) &&\n\t    (!(radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT)))) {\n\t\tif (ASIC_IS_DCE8(rdev)) {\n\t\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\t\tWREG32(CIK_LB_DATA_FORMAT + radeon_crtc->crtc_offset,\n\t\t\t\t       CIK_INTERLEAVE_EN);\n\t\t\telse\n\t\t\t\tWREG32(CIK_LB_DATA_FORMAT + radeon_crtc->crtc_offset, 0);\n\t\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\t\tWREG32(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset,\n\t\t\t\t       EVERGREEN_INTERLEAVE_EN);\n\t\t\telse\n\t\t\t\tWREG32(EVERGREEN_DATA_FORMAT + radeon_crtc->crtc_offset, 0);\n\t\t} else {\n\t\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\t\tWREG32(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset,\n\t\t\t\t       AVIVO_D1MODE_INTERLEAVE_EN);\n\t\t\telse\n\t\t\t\tWREG32(AVIVO_D1MODE_DATA_FORMAT + radeon_crtc->crtc_offset, 0);\n\t\t}\n\t}\n}\n\nvoid radeon_atom_release_dig_encoder(struct radeon_device *rdev, int enc_idx)\n{\n\tif (enc_idx < 0)\n\t\treturn;\n\trdev->mode_info.active_encoders &= ~(1 << enc_idx);\n}\n\nint radeon_atom_pick_dig_encoder(struct drm_encoder *encoder, int fe_idx)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_crtc *radeon_crtc = to_radeon_crtc(encoder->crtc);\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_encoder *test_encoder;\n\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\tuint32_t dig_enc_in_use = 0;\n\tint enc_idx = -1;\n\n\tif (fe_idx >= 0) {\n\t\tenc_idx = fe_idx;\n\t\tgoto assigned;\n\t}\n\tif (ASIC_IS_DCE6(rdev)) {\n\t\t \n\t\tswitch (radeon_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\tif (dig->linkb)\n\t\t\t\tenc_idx = 1;\n\t\t\telse\n\t\t\t\tenc_idx = 0;\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\tif (dig->linkb)\n\t\t\t\tenc_idx = 3;\n\t\t\telse\n\t\t\t\tenc_idx = 2;\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\tif (dig->linkb)\n\t\t\t\tenc_idx = 5;\n\t\t\telse\n\t\t\t\tenc_idx = 4;\n\t\t\tbreak;\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\t\tenc_idx = 6;\n\t\t\tbreak;\n\t\t}\n\t\tgoto assigned;\n\t} else if (ASIC_IS_DCE4(rdev)) {\n\t\t \n\t\tif (ASIC_IS_DCE41(rdev) && !ASIC_IS_DCE61(rdev)) {\n\t\t\t \n\t\t\tif (rdev->family == CHIP_PALM) {\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\tenc_idx = 1;\n\t\t\t\telse\n\t\t\t\t\tenc_idx = 0;\n\t\t\t} else\n\t\t\t\t \n\t\t\t\tenc_idx = radeon_crtc->crtc_id;\n\t\t} else {\n\t\t\tswitch (radeon_encoder->encoder_id) {\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\tenc_idx = 1;\n\t\t\t\telse\n\t\t\t\t\tenc_idx = 0;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\tenc_idx = 3;\n\t\t\t\telse\n\t\t\t\t\tenc_idx = 2;\n\t\t\t\tbreak;\n\t\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\t\t\tif (dig->linkb)\n\t\t\t\t\tenc_idx = 5;\n\t\t\t\telse\n\t\t\t\t\tenc_idx = 4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tgoto assigned;\n\t}\n\n\t \n\tif (ASIC_IS_DCE32(rdev)) {\n\t\tif (dmi_match(DMI_PRODUCT_NAME, \"iMac10,1\") ||\n\t\t    dmi_match(DMI_PRODUCT_NAME, \"iMac11,2\"))\n\t\t\tenc_idx = (dig->linkb) ? 1 : 0;\n\t\telse\n\t\t\tenc_idx = radeon_crtc->crtc_id;\n\n\t\tgoto assigned;\n\t}\n\n\t \n\tlist_for_each_entry(test_encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct radeon_encoder *radeon_test_encoder;\n\n\t\tif (encoder == test_encoder)\n\t\t\tcontinue;\n\n\t\tif (!radeon_encoder_is_digital(test_encoder))\n\t\t\tcontinue;\n\n\t\tradeon_test_encoder = to_radeon_encoder(test_encoder);\n\t\tdig = radeon_test_encoder->enc_priv;\n\n\t\tif (dig->dig_encoder >= 0)\n\t\t\tdig_enc_in_use |= (1 << dig->dig_encoder);\n\t}\n\n\tif (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA) {\n\t\tif (dig_enc_in_use & 0x2)\n\t\t\tDRM_ERROR(\"LVDS required digital encoder 2 but it was in use - stealing\\n\");\n\t\treturn 1;\n\t}\n\tif (!(dig_enc_in_use & 1))\n\t\treturn 0;\n\treturn 1;\n\nassigned:\n\tif (enc_idx == -1) {\n\t\tDRM_ERROR(\"Got encoder index incorrect - returning 0\\n\");\n\t\treturn 0;\n\t}\n\tif (rdev->mode_info.active_encoders & (1 << enc_idx))\n\t\tDRM_ERROR(\"chosen encoder in use %d\\n\", enc_idx);\n\n\trdev->mode_info.active_encoders |= (1 << enc_idx);\n\treturn enc_idx;\n}\n\n \nvoid\nradeon_atom_encoder_init(struct radeon_device *rdev)\n{\n\tstruct drm_device *dev = rdev->ddev;\n\tstruct drm_encoder *encoder;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\t\tstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\n\n\t\tswitch (radeon_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\t\tatombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_INIT, 0, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ext_encoder && (ASIC_IS_DCE41(rdev) || ASIC_IS_DCE61(rdev)))\n\t\t\tatombios_external_encoder_setup(encoder, ext_encoder,\n\t\t\t\t\t\t\tEXTERNAL_ENCODER_ACTION_V3_ENCODER_INIT);\n\t}\n}\n\nstatic void\nradeon_atom_encoder_mode_set(struct drm_encoder *encoder,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\tint encoder_mode;\n\n\tradeon_encoder->pixel_clock = adjusted_mode->clock;\n\n\t \n\tradeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\n\n\tif (ASIC_IS_AVIVO(rdev) && !ASIC_IS_DCE4(rdev)) {\n\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT))\n\t\t\tatombios_yuv_setup(encoder, true);\n\t\telse\n\t\t\tatombios_yuv_setup(encoder, false);\n\t}\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\tatombios_digital_setup(encoder, PANEL_ENCODER_ACTION_ENABLE);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\t \n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\tatombios_dvo_setup(encoder, ATOM_ENABLE);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\tatombios_dac_setup(encoder, ATOM_ENABLE);\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT)) {\n\t\t\tif (radeon_encoder->active_device & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))\n\t\t\t\tatombios_tv_setup(encoder, ATOM_ENABLE);\n\t\t\telse\n\t\t\t\tatombios_tv_setup(encoder, ATOM_DISABLE);\n\t\t}\n\t\tbreak;\n\t}\n\n\tatombios_apply_encoder_quirks(encoder, adjusted_mode);\n\n\tencoder_mode = atombios_get_encoder_mode(encoder);\n\tif (connector && (radeon_audio != 0) &&\n\t    ((encoder_mode == ATOM_ENCODER_MODE_HDMI) ||\n\t     ENCODER_MODE_IS_DP(encoder_mode)))\n\t\tradeon_audio_mode_set(encoder, adjusted_mode);\n}\n\nstatic bool\natombios_dac_load_detect(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\tif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT |\n\t\t\t\t       ATOM_DEVICE_CV_SUPPORT |\n\t\t\t\t       ATOM_DEVICE_CRT_SUPPORT)) {\n\t\tDAC_LOAD_DETECTION_PS_ALLOCATION args;\n\t\tint index = GetIndexIntoMasterTable(COMMAND, DAC_LoadDetection);\n\t\tuint8_t frev, crev;\n\n\t\tmemset(&args, 0, sizeof(args));\n\n\t\tif (!atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev))\n\t\t\treturn false;\n\n\t\targs.sDacload.ucMisc = 0;\n\n\t\tif ((radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1) ||\n\t\t    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1))\n\t\t\targs.sDacload.ucDacType = ATOM_DAC_A;\n\t\telse\n\t\t\targs.sDacload.ucDacType = ATOM_DAC_B;\n\n\t\tif (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT)\n\t\t\targs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CRT1_SUPPORT);\n\t\telse if (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT)\n\t\t\targs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CRT2_SUPPORT);\n\t\telse if (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT) {\n\t\t\targs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_CV_SUPPORT);\n\t\t\tif (crev >= 3)\n\t\t\t\targs.sDacload.ucMisc = DAC_LOAD_MISC_YPrPb;\n\t\t} else if (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT) {\n\t\t\targs.sDacload.usDeviceID = cpu_to_le16(ATOM_DEVICE_TV1_SUPPORT);\n\t\t\tif (crev >= 3)\n\t\t\t\targs.sDacload.ucMisc = DAC_LOAD_MISC_YPrPb;\n\t\t}\n\n\t\tatom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\n\n\t\treturn true;\n\t} else\n\t\treturn false;\n}\n\nstatic enum drm_connector_status\nradeon_atom_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tuint32_t bios_0_scratch;\n\n\tif (!atombios_dac_load_detect(encoder, connector)) {\n\t\tDRM_DEBUG_KMS(\"detect returned false \\n\");\n\t\treturn connector_status_unknown;\n\t}\n\n\tif (rdev->family >= CHIP_R600)\n\t\tbios_0_scratch = RREG32(R600_BIOS_0_SCRATCH);\n\telse\n\t\tbios_0_scratch = RREG32(RADEON_BIOS_0_SCRATCH);\n\n\tDRM_DEBUG_KMS(\"Bios 0 scratch %x %08x\\n\", bios_0_scratch, radeon_encoder->devices);\n\tif (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT) {\n\t\tif (bios_0_scratch & ATOM_S0_CRT1_MASK)\n\t\t\treturn connector_status_connected;\n\t}\n\tif (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT) {\n\t\tif (bios_0_scratch & ATOM_S0_CRT2_MASK)\n\t\t\treturn connector_status_connected;\n\t}\n\tif (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT) {\n\t\tif (bios_0_scratch & (ATOM_S0_CV_MASK|ATOM_S0_CV_MASK_A))\n\t\t\treturn connector_status_connected;\n\t}\n\tif (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT) {\n\t\tif (bios_0_scratch & (ATOM_S0_TV1_COMPOSITE | ATOM_S0_TV1_COMPOSITE_A))\n\t\t\treturn connector_status_connected;  \n\t\telse if (bios_0_scratch & (ATOM_S0_TV1_SVIDEO | ATOM_S0_TV1_SVIDEO_A))\n\t\t\treturn connector_status_connected;  \n\t}\n\treturn connector_status_disconnected;\n}\n\nstatic enum drm_connector_status\nradeon_atom_dig_detect(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\tstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\n\tu32 bios_0_scratch;\n\n\tif (!ASIC_IS_DCE4(rdev))\n\t\treturn connector_status_unknown;\n\n\tif (!ext_encoder)\n\t\treturn connector_status_unknown;\n\n\tif ((radeon_connector->devices & ATOM_DEVICE_CRT_SUPPORT) == 0)\n\t\treturn connector_status_unknown;\n\n\t \n\tatombios_external_encoder_setup(encoder, ext_encoder,\n\t\t\t\t\tEXTERNAL_ENCODER_ACTION_V3_DACLOAD_DETECTION);\n\n\tbios_0_scratch = RREG32(R600_BIOS_0_SCRATCH);\n\n\tDRM_DEBUG_KMS(\"Bios 0 scratch %x %08x\\n\", bios_0_scratch, radeon_encoder->devices);\n\tif (radeon_connector->devices & ATOM_DEVICE_CRT1_SUPPORT) {\n\t\tif (bios_0_scratch & ATOM_S0_CRT1_MASK)\n\t\t\treturn connector_status_connected;\n\t}\n\tif (radeon_connector->devices & ATOM_DEVICE_CRT2_SUPPORT) {\n\t\tif (bios_0_scratch & ATOM_S0_CRT2_MASK)\n\t\t\treturn connector_status_connected;\n\t}\n\tif (radeon_connector->devices & ATOM_DEVICE_CV_SUPPORT) {\n\t\tif (bios_0_scratch & (ATOM_S0_CV_MASK|ATOM_S0_CV_MASK_A))\n\t\t\treturn connector_status_connected;\n\t}\n\tif (radeon_connector->devices & ATOM_DEVICE_TV1_SUPPORT) {\n\t\tif (bios_0_scratch & (ATOM_S0_TV1_COMPOSITE | ATOM_S0_TV1_COMPOSITE_A))\n\t\t\treturn connector_status_connected;  \n\t\telse if (bios_0_scratch & (ATOM_S0_TV1_SVIDEO | ATOM_S0_TV1_SVIDEO_A))\n\t\t\treturn connector_status_connected;  \n\t}\n\treturn connector_status_disconnected;\n}\n\nvoid\nradeon_atom_ext_encoder_setup_ddc(struct drm_encoder *encoder)\n{\n\tstruct drm_encoder *ext_encoder = radeon_get_external_encoder(encoder);\n\n\tif (ext_encoder)\n\t\t \n\t\tatombios_external_encoder_setup(encoder, ext_encoder,\n\t\t\t\t\t\tEXTERNAL_ENCODER_ACTION_V3_DDC_SETUP);\n\n}\n\nstatic void radeon_atom_encoder_prepare(struct drm_encoder *encoder)\n{\n\tstruct radeon_device *rdev = encoder->dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\n\n\tif ((radeon_encoder->active_device &\n\t     (ATOM_DEVICE_DFP_SUPPORT | ATOM_DEVICE_LCD_SUPPORT)) ||\n\t    (radeon_encoder_get_dp_bridge_encoder_id(encoder) !=\n\t     ENCODER_OBJECT_ID_NONE)) {\n\t\tstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\n\t\tif (dig) {\n\t\t\tif (dig->dig_encoder >= 0)\n\t\t\t\tradeon_atom_release_dig_encoder(rdev, dig->dig_encoder);\n\t\t\tdig->dig_encoder = radeon_atom_pick_dig_encoder(encoder, -1);\n\t\t\tif (radeon_encoder->active_device & ATOM_DEVICE_DFP_SUPPORT) {\n\t\t\t\tif (rdev->family >= CHIP_R600)\n\t\t\t\t\tdig->afmt = rdev->mode_info.afmt[dig->dig_encoder];\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tdig->afmt = rdev->mode_info.afmt[0];\n\t\t\t}\n\t\t}\n\t}\n\n\tradeon_atom_output_lock(encoder, true);\n\n\tif (connector) {\n\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\t\t \n\t\tif (radeon_connector->router.cd_valid)\n\t\t\tradeon_router_select_cd_port(radeon_connector);\n\n\t\t \n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\t\tatombios_set_edp_panel_power(connector,\n\t\t\t\t\t\t     ATOM_TRANSMITTER_ACTION_POWER_ON);\n\t}\n\n\t \n\tatombios_set_encoder_crtc_source(encoder);\n\t \n\tif (ASIC_IS_DCE8(rdev))\n\t\tdce8_program_fmt(encoder);\n\telse if (ASIC_IS_DCE4(rdev))\n\t\tdce4_program_fmt(encoder);\n\telse if (ASIC_IS_DCE3(rdev))\n\t\tdce3_program_fmt(encoder);\n\telse if (ASIC_IS_AVIVO(rdev))\n\t\tavivo_program_fmt(encoder);\n}\n\nstatic void radeon_atom_encoder_commit(struct drm_encoder *encoder)\n{\n\t \n\tradeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\n\tradeon_atom_output_lock(encoder, false);\n}\n\nstatic void radeon_atom_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct radeon_encoder_atom_dig *dig;\n\n\t \n\tif (!ASIC_IS_DCE3(rdev)) {\n\t\tstruct drm_encoder *other_encoder;\n\t\tstruct radeon_encoder *other_radeon_encoder;\n\n\t\tlist_for_each_entry(other_encoder, &dev->mode_config.encoder_list, head) {\n\t\t\tother_radeon_encoder = to_radeon_encoder(other_encoder);\n\t\t\tif ((radeon_encoder->encoder_id == other_radeon_encoder->encoder_id) &&\n\t\t\t    drm_helper_encoder_in_use(other_encoder))\n\t\t\t\tgoto disable_done;\n\t\t}\n\t}\n\n\tradeon_atom_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\tatombios_digital_setup(encoder, PANEL_ENCODER_ACTION_DISABLE);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\t\t \n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\t\tatombios_dvo_setup(encoder, ATOM_DISABLE);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\tatombios_dac_setup(encoder, ATOM_DISABLE);\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_TV_SUPPORT | ATOM_DEVICE_CV_SUPPORT))\n\t\t\tatombios_tv_setup(encoder, ATOM_DISABLE);\n\t\tbreak;\n\t}\n\ndisable_done:\n\tif (radeon_encoder_is_digital(encoder)) {\n\t\tif (atombios_get_encoder_mode(encoder) == ATOM_ENCODER_MODE_HDMI) {\n\t\t\tif (rdev->asic->display.hdmi_enable)\n\t\t\t\tradeon_hdmi_enable(rdev, encoder, false);\n\t\t}\n\t\tif (atombios_get_encoder_mode(encoder) != ATOM_ENCODER_MODE_DP_MST) {\n\t\t\tdig = radeon_encoder->enc_priv;\n\t\t\tradeon_atom_release_dig_encoder(rdev, dig->dig_encoder);\n\t\t\tdig->dig_encoder = -1;\n\t\t\tradeon_encoder->active_device = 0;\n\t\t}\n\t} else\n\t\tradeon_encoder->active_device = 0;\n}\n\n \nstatic void radeon_atom_ext_prepare(struct drm_encoder *encoder)\n{\n\n}\n\nstatic void radeon_atom_ext_commit(struct drm_encoder *encoder)\n{\n\n}\n\nstatic void\nradeon_atom_ext_mode_set(struct drm_encoder *encoder,\n\t\t\t struct drm_display_mode *mode,\n\t\t\t struct drm_display_mode *adjusted_mode)\n{\n\n}\n\nstatic void radeon_atom_ext_disable(struct drm_encoder *encoder)\n{\n\n}\n\nstatic void\nradeon_atom_ext_dpms(struct drm_encoder *encoder, int mode)\n{\n\n}\n\nstatic const struct drm_encoder_helper_funcs radeon_atom_ext_helper_funcs = {\n\t.dpms = radeon_atom_ext_dpms,\n\t.prepare = radeon_atom_ext_prepare,\n\t.mode_set = radeon_atom_ext_mode_set,\n\t.commit = radeon_atom_ext_commit,\n\t.disable = radeon_atom_ext_disable,\n\t \n};\n\nstatic const struct drm_encoder_helper_funcs radeon_atom_dig_helper_funcs = {\n\t.dpms = radeon_atom_encoder_dpms,\n\t.mode_fixup = radeon_atom_mode_fixup,\n\t.prepare = radeon_atom_encoder_prepare,\n\t.mode_set = radeon_atom_encoder_mode_set,\n\t.commit = radeon_atom_encoder_commit,\n\t.disable = radeon_atom_encoder_disable,\n\t.detect = radeon_atom_dig_detect,\n};\n\nstatic const struct drm_encoder_helper_funcs radeon_atom_dac_helper_funcs = {\n\t.dpms = radeon_atom_encoder_dpms,\n\t.mode_fixup = radeon_atom_mode_fixup,\n\t.prepare = radeon_atom_encoder_prepare,\n\t.mode_set = radeon_atom_encoder_mode_set,\n\t.commit = radeon_atom_encoder_commit,\n\t.detect = radeon_atom_dac_detect,\n};\n\nvoid radeon_enc_destroy(struct drm_encoder *encoder)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\tradeon_atom_backlight_exit(radeon_encoder);\n\tkfree(radeon_encoder->enc_priv);\n\tdrm_encoder_cleanup(encoder);\n\tkfree(radeon_encoder);\n}\n\nstatic const struct drm_encoder_funcs radeon_atom_enc_funcs = {\n\t.destroy = radeon_enc_destroy,\n};\n\nstatic struct radeon_encoder_atom_dac *\nradeon_atombios_set_dac_info(struct radeon_encoder *radeon_encoder)\n{\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder_atom_dac *dac = kzalloc(sizeof(struct radeon_encoder_atom_dac), GFP_KERNEL);\n\n\tif (!dac)\n\t\treturn NULL;\n\n\tdac->tv_std = radeon_atombios_get_tv_info(rdev);\n\treturn dac;\n}\n\nstatic struct radeon_encoder_atom_dig *\nradeon_atombios_set_dig_info(struct radeon_encoder *radeon_encoder)\n{\n\tint encoder_enum = (radeon_encoder->encoder_enum & ENUM_ID_MASK) >> ENUM_ID_SHIFT;\n\tstruct radeon_encoder_atom_dig *dig = kzalloc(sizeof(struct radeon_encoder_atom_dig), GFP_KERNEL);\n\n\tif (!dig)\n\t\treturn NULL;\n\n\t \n\tdig->coherent_mode = true;\n\tdig->dig_encoder = -1;\n\n\tif (encoder_enum == 2)\n\t\tdig->linkb = true;\n\telse\n\t\tdig->linkb = false;\n\n\treturn dig;\n}\n\nvoid\nradeon_add_atom_encoder(struct drm_device *dev,\n\t\t\tuint32_t encoder_enum,\n\t\t\tuint32_t supported_device,\n\t\t\tu16 caps)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\n\t \n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\tif (radeon_encoder->encoder_enum == encoder_enum) {\n\t\t\tradeon_encoder->devices |= supported_device;\n\t\t\treturn;\n\t\t}\n\n\t}\n\n\t \n\tradeon_encoder = kzalloc(sizeof(struct radeon_encoder), GFP_KERNEL);\n\tif (!radeon_encoder)\n\t\treturn;\n\n\tencoder = &radeon_encoder->base;\n\tswitch (rdev->num_crtc) {\n\tcase 1:\n\t\tencoder->possible_crtcs = 0x1;\n\t\tbreak;\n\tcase 2:\n\tdefault:\n\t\tencoder->possible_crtcs = 0x3;\n\t\tbreak;\n\tcase 4:\n\t\tencoder->possible_crtcs = 0xf;\n\t\tbreak;\n\tcase 6:\n\t\tencoder->possible_crtcs = 0x3f;\n\t\tbreak;\n\t}\n\n\tradeon_encoder->enc_priv = NULL;\n\n\tradeon_encoder->encoder_enum = encoder_enum;\n\tradeon_encoder->encoder_id = (encoder_enum & OBJECT_ID_MASK) >> OBJECT_ID_SHIFT;\n\tradeon_encoder->devices = supported_device;\n\tradeon_encoder->rmx_type = RMX_OFF;\n\tradeon_encoder->underscan_type = UNDERSCAN_OFF;\n\tradeon_encoder->is_ext_encoder = false;\n\tradeon_encoder->caps = caps;\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\tradeon_encoder->rmx_type = RMX_FULL;\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_LVDS, NULL);\n\t\t\tradeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);\n\t\t} else {\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_TMDS, NULL);\n\t\t\tradeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);\n\t\t}\n\t\tdrm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC1:\n\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t DRM_MODE_ENCODER_DAC, NULL);\n\t\tradeon_encoder->enc_priv = radeon_atombios_set_dac_info(radeon_encoder);\n\t\tdrm_encoder_helper_add(encoder, &radeon_atom_dac_helper_funcs);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DAC2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:\n\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t DRM_MODE_ENCODER_TVDAC, NULL);\n\t\tradeon_encoder->enc_priv = radeon_atombios_set_dac_info(radeon_encoder);\n\t\tdrm_encoder_helper_add(encoder, &radeon_atom_dac_helper_funcs);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {\n\t\t\tradeon_encoder->rmx_type = RMX_FULL;\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_LVDS, NULL);\n\t\t\tradeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);\n\t\t} else if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_DAC, NULL);\n\t\t\tradeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);\n\t\t} else {\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_TMDS, NULL);\n\t\t\tradeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);\n\t\t}\n\t\tdrm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);\n\t\tbreak;\n\tcase ENCODER_OBJECT_ID_SI170B:\n\tcase ENCODER_OBJECT_ID_CH7303:\n\tcase ENCODER_OBJECT_ID_EXTERNAL_SDVOA:\n\tcase ENCODER_OBJECT_ID_EXTERNAL_SDVOB:\n\tcase ENCODER_OBJECT_ID_TITFP513:\n\tcase ENCODER_OBJECT_ID_VT1623:\n\tcase ENCODER_OBJECT_ID_HDMI_SI1930:\n\tcase ENCODER_OBJECT_ID_TRAVIS:\n\tcase ENCODER_OBJECT_ID_NUTMEG:\n\t\t \n\t\tradeon_encoder->is_ext_encoder = true;\n\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_LVDS, NULL);\n\t\telse if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_DAC, NULL);\n\t\telse\n\t\t\tdrm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,\n\t\t\t\t\t DRM_MODE_ENCODER_TMDS, NULL);\n\t\tdrm_encoder_helper_add(encoder, &radeon_atom_ext_helper_funcs);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}