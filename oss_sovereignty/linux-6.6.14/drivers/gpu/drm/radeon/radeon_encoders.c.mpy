{
  "module_name": "radeon_encoders.c",
  "hash_id": "73e635e3fc870992e90bf74888cedb6c479a862138c435e0765575834eed1b29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/radeon_encoders.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include <drm/drm_device.h>\n#include <drm/radeon_drm.h>\n\n#include <acpi/video.h>\n\n#include \"radeon.h\"\n#include \"radeon_atombios.h\"\n#include \"radeon_legacy_encoders.h\"\n#include \"atom.h\"\n\nstatic uint32_t radeon_encoder_clones(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_encoder *clone_encoder;\n\tuint32_t index_mask = 0;\n\tint count;\n\n\t \n\tif (rdev->family >= CHIP_R600)\n\t\treturn index_mask;\n\t \n\tif (radeon_encoder->devices & ATOM_DEVICE_LCD_SUPPORT)\n\t\treturn index_mask;\n\t \n\tif (radeon_encoder->devices & ATOM_DEVICE_DFP2_SUPPORT)\n\t\treturn index_mask;\n\n\tcount = -1;\n\tlist_for_each_entry(clone_encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct radeon_encoder *radeon_clone = to_radeon_encoder(clone_encoder);\n\n\t\tcount++;\n\n\t\tif (clone_encoder == encoder)\n\t\t\tcontinue;\n\t\tif (radeon_clone->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\tcontinue;\n\t\tif (radeon_clone->devices & ATOM_DEVICE_DFP2_SUPPORT)\n\t\t\tcontinue;\n\t\telse\n\t\t\tindex_mask |= (1 << count);\n\t}\n\treturn index_mask;\n}\n\nvoid radeon_setup_encoder_clones(struct drm_device *dev)\n{\n\tstruct drm_encoder *encoder;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tencoder->possible_clones = radeon_encoder_clones(encoder);\n\t}\n}\n\nuint32_t\nradeon_get_encoder_enum(struct drm_device *dev, uint32_t supported_device, uint8_t dac)\n{\n\tstruct radeon_device *rdev = dev->dev_private;\n\tuint32_t ret = 0;\n\n\tswitch (supported_device) {\n\tcase ATOM_DEVICE_CRT1_SUPPORT:\n\tcase ATOM_DEVICE_TV1_SUPPORT:\n\tcase ATOM_DEVICE_TV2_SUPPORT:\n\tcase ATOM_DEVICE_CRT2_SUPPORT:\n\tcase ATOM_DEVICE_CV_SUPPORT:\n\t\tswitch (dac) {\n\t\tcase 1:  \n\t\t\tif ((rdev->family == CHIP_RS300) ||\n\t\t\t    (rdev->family == CHIP_RS400) ||\n\t\t\t    (rdev->family == CHIP_RS480))\n\t\t\t\tret = ENCODER_INTERNAL_DAC2_ENUM_ID1;\n\t\t\telse if (ASIC_IS_AVIVO(rdev))\n\t\t\t\tret = ENCODER_INTERNAL_KLDSCP_DAC1_ENUM_ID1;\n\t\t\telse\n\t\t\t\tret = ENCODER_INTERNAL_DAC1_ENUM_ID1;\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tret = ENCODER_INTERNAL_KLDSCP_DAC2_ENUM_ID1;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tret = ENCODER_INTERNAL_DAC2_ENUM_ID1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:  \n\t\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\t\tret = ENCODER_INTERNAL_KLDSCP_DVO1_ENUM_ID1;\n\t\t\telse\n\t\t\t\tret = ENCODER_INTERNAL_DVO1_ENUM_ID1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ATOM_DEVICE_LCD1_SUPPORT:\n\t\tif (ASIC_IS_AVIVO(rdev))\n\t\t\tret = ENCODER_INTERNAL_LVTM1_ENUM_ID1;\n\t\telse\n\t\t\tret = ENCODER_INTERNAL_LVDS_ENUM_ID1;\n\t\tbreak;\n\tcase ATOM_DEVICE_DFP1_SUPPORT:\n\t\tif ((rdev->family == CHIP_RS300) ||\n\t\t    (rdev->family == CHIP_RS400) ||\n\t\t    (rdev->family == CHIP_RS480))\n\t\t\tret = ENCODER_INTERNAL_DVO1_ENUM_ID1;\n\t\telse if (ASIC_IS_AVIVO(rdev))\n\t\t\tret = ENCODER_INTERNAL_KLDSCP_TMDS1_ENUM_ID1;\n\t\telse\n\t\t\tret = ENCODER_INTERNAL_TMDS1_ENUM_ID1;\n\t\tbreak;\n\tcase ATOM_DEVICE_LCD2_SUPPORT:\n\tcase ATOM_DEVICE_DFP2_SUPPORT:\n\t\tif ((rdev->family == CHIP_RS600) ||\n\t\t    (rdev->family == CHIP_RS690) ||\n\t\t    (rdev->family == CHIP_RS740))\n\t\t\tret = ENCODER_INTERNAL_DDI_ENUM_ID1;\n\t\telse if (ASIC_IS_AVIVO(rdev))\n\t\t\tret = ENCODER_INTERNAL_KLDSCP_DVO1_ENUM_ID1;\n\t\telse\n\t\t\tret = ENCODER_INTERNAL_DVO1_ENUM_ID1;\n\t\tbreak;\n\tcase ATOM_DEVICE_DFP3_SUPPORT:\n\t\tret = ENCODER_INTERNAL_LVTM1_ENUM_ID1;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void radeon_encoder_add_backlight(struct radeon_encoder *radeon_encoder,\n\t\t\t\t\t struct drm_connector *connector)\n{\n\tstruct drm_device *dev = radeon_encoder->base.dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tbool use_bl = false;\n\n\tif (!(radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)))\n\t\treturn;\n\n\tif (radeon_backlight == 0) {\n\t\tuse_bl = false;\n\t} else if (radeon_backlight == 1) {\n\t\tuse_bl = true;\n\t} else if (radeon_backlight == -1) {\n\t\t \n\t\t \n\t\tif ((rdev->pdev->device == 0x9583) &&\n\t\t    (rdev->pdev->subsystem_vendor == 0x1734) &&\n\t\t    (rdev->pdev->subsystem_device == 0x1107))\n\t\t\tuse_bl = false;\n \n#ifndef CONFIG_PPC_PMAC\n\t\t \n\t\telse if (rdev->family < CHIP_R600)\n\t\t\tuse_bl = false;\n#endif\n\t\telse\n\t\t\tuse_bl = true;\n\t}\n\n\tif (use_bl) {\n\t\tif (rdev->is_atom_bios)\n\t\t\tradeon_atom_backlight_init(radeon_encoder, connector);\n\t\telse\n\t\t\tradeon_legacy_backlight_init(radeon_encoder, connector);\n\t}\n\n\t \n\tif (!rdev->mode_info.bl_encoder)\n\t\tacpi_video_register_backlight();\n}\n\nvoid\nradeon_link_encoder_connector(struct drm_device *dev)\n{\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\tstruct drm_encoder *encoder;\n\tstruct radeon_encoder *radeon_encoder;\n\n\t \n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\t\tradeon_encoder = to_radeon_encoder(encoder);\n\t\t\tif (radeon_encoder->devices & radeon_connector->devices) {\n\t\t\t\tdrm_connector_attach_encoder(connector, encoder);\n\t\t\t\tif (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))\n\t\t\t\t\tradeon_encoder_add_backlight(radeon_encoder, connector);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid radeon_encoder_set_active_device(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tif (connector->encoder == encoder) {\n\t\t\tstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\n\n\t\t\tradeon_encoder->active_device = radeon_encoder->devices & radeon_connector->devices;\n\t\t\tDRM_DEBUG_KMS(\"setting active device to %08x from %08x %08x for encoder %d\\n\",\n\t\t\t\t  radeon_encoder->active_device, radeon_encoder->devices,\n\t\t\t\t  radeon_connector->devices, encoder->encoder_type);\n\t\t}\n\t}\n}\n\nstruct drm_connector *\nradeon_get_connector_for_encoder(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tif (radeon_encoder->active_device & radeon_connector->devices)\n\t\t\treturn connector;\n\t}\n\treturn NULL;\n}\n\nstruct drm_connector *\nradeon_get_connector_for_encoder_init(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\n\tlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\n\t\tradeon_connector = to_radeon_connector(connector);\n\t\tif (radeon_encoder->devices & radeon_connector->devices)\n\t\t\treturn connector;\n\t}\n\treturn NULL;\n}\n\nstruct drm_encoder *radeon_get_external_encoder(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_encoder *other_encoder;\n\tstruct radeon_encoder *other_radeon_encoder;\n\n\tif (radeon_encoder->is_ext_encoder)\n\t\treturn NULL;\n\n\tlist_for_each_entry(other_encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (other_encoder == encoder)\n\t\t\tcontinue;\n\t\tother_radeon_encoder = to_radeon_encoder(other_encoder);\n\t\tif (other_radeon_encoder->is_ext_encoder &&\n\t\t    (radeon_encoder->devices & other_radeon_encoder->devices))\n\t\t\treturn other_encoder;\n\t}\n\treturn NULL;\n}\n\nu16 radeon_encoder_get_dp_bridge_encoder_id(struct drm_encoder *encoder)\n{\n\tstruct drm_encoder *other_encoder = radeon_get_external_encoder(encoder);\n\n\tif (other_encoder) {\n\t\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(other_encoder);\n\n\t\tswitch (radeon_encoder->encoder_id) {\n\t\tcase ENCODER_OBJECT_ID_TRAVIS:\n\t\tcase ENCODER_OBJECT_ID_NUTMEG:\n\t\t\treturn radeon_encoder->encoder_id;\n\t\tdefault:\n\t\t\treturn ENCODER_OBJECT_ID_NONE;\n\t\t}\n\t}\n\treturn ENCODER_OBJECT_ID_NONE;\n}\n\nvoid radeon_panel_mode_fixup(struct drm_encoder *encoder,\n\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_display_mode *native_mode = &radeon_encoder->native_mode;\n\tunsigned int hblank = native_mode->htotal - native_mode->hdisplay;\n\tunsigned int vblank = native_mode->vtotal - native_mode->vdisplay;\n\tunsigned int hover = native_mode->hsync_start - native_mode->hdisplay;\n\tunsigned int vover = native_mode->vsync_start - native_mode->vdisplay;\n\tunsigned int hsync_width = native_mode->hsync_end - native_mode->hsync_start;\n\tunsigned int vsync_width = native_mode->vsync_end - native_mode->vsync_start;\n\n\tadjusted_mode->clock = native_mode->clock;\n\tadjusted_mode->flags = native_mode->flags;\n\n\tif (ASIC_IS_AVIVO(rdev)) {\n\t\tadjusted_mode->hdisplay = native_mode->hdisplay;\n\t\tadjusted_mode->vdisplay = native_mode->vdisplay;\n\t}\n\n\tadjusted_mode->htotal = native_mode->hdisplay + hblank;\n\tadjusted_mode->hsync_start = native_mode->hdisplay + hover;\n\tadjusted_mode->hsync_end = adjusted_mode->hsync_start + hsync_width;\n\n\tadjusted_mode->vtotal = native_mode->vdisplay + vblank;\n\tadjusted_mode->vsync_start = native_mode->vdisplay + vover;\n\tadjusted_mode->vsync_end = adjusted_mode->vsync_start + vsync_width;\n\n\tdrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\n\n\tif (ASIC_IS_AVIVO(rdev)) {\n\t\tadjusted_mode->crtc_hdisplay = native_mode->hdisplay;\n\t\tadjusted_mode->crtc_vdisplay = native_mode->vdisplay;\n\t}\n\n\tadjusted_mode->crtc_htotal = adjusted_mode->crtc_hdisplay + hblank;\n\tadjusted_mode->crtc_hsync_start = adjusted_mode->crtc_hdisplay + hover;\n\tadjusted_mode->crtc_hsync_end = adjusted_mode->crtc_hsync_start + hsync_width;\n\n\tadjusted_mode->crtc_vtotal = adjusted_mode->crtc_vdisplay + vblank;\n\tadjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vdisplay + vover;\n\tadjusted_mode->crtc_vsync_end = adjusted_mode->crtc_vsync_start + vsync_width;\n\n}\n\nbool radeon_dig_monitor_is_duallink(struct drm_encoder *encoder,\n\t\t\t\t    u32 pixel_clock)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct radeon_device *rdev = dev->dev_private;\n\tstruct drm_connector *connector;\n\tstruct radeon_connector *radeon_connector;\n\tstruct radeon_connector_atom_dig *dig_connector;\n\n\tconnector = radeon_get_connector_for_encoder(encoder);\n\t \n\tif (!connector)\n\t\tconnector = radeon_get_connector_for_encoder_init(encoder);\n\tradeon_connector = to_radeon_connector(connector);\n\n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_DVII:\n\tcase DRM_MODE_CONNECTOR_HDMIB:\n\t\tif (radeon_connector->use_digital) {\n\t\t\t \n\t\t\tif (ASIC_IS_DCE6(rdev) && drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\t\tif (pixel_clock > 340000)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (pixel_clock > 165000)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else\n\t\t\treturn false;\n\tcase DRM_MODE_CONNECTOR_DVID:\n\tcase DRM_MODE_CONNECTOR_HDMIA:\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tdig_connector = radeon_connector->con_priv;\n\t\tif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\n\t\t    (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP))\n\t\t\treturn false;\n\t\telse {\n\t\t\t \n\t\t\tif (ASIC_IS_DCE6(rdev) && drm_detect_hdmi_monitor(radeon_connector_edid(connector))) {\n\t\t\t\tif (pixel_clock > 340000)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tif (pixel_clock > 165000)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool radeon_encoder_is_digital(struct drm_encoder *encoder)\n{\n\tstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\n\n\tswitch (radeon_encoder->encoder_id) {\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVDS:\n\tcase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_DDI:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\n\tcase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\n\tcase ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}