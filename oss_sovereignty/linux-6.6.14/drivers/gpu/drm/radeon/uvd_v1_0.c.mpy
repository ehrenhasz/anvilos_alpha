{
  "module_name": "uvd_v1_0.c",
  "hash_id": "a6c0726d5013c98666143c031edb57b6a2ef90b6c091959af73c955ccda21d0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/uvd_v1_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"radeon.h\"\n#include \"radeon_asic.h\"\n#include \"r600d.h\"\n\n \nuint32_t uvd_v1_0_get_rptr(struct radeon_device *rdev,\n\t\t\t   struct radeon_ring *ring)\n{\n\treturn RREG32(UVD_RBC_RB_RPTR);\n}\n\n \nuint32_t uvd_v1_0_get_wptr(struct radeon_device *rdev,\n\t\t\t   struct radeon_ring *ring)\n{\n\treturn RREG32(UVD_RBC_RB_WPTR);\n}\n\n \nvoid uvd_v1_0_set_wptr(struct radeon_device *rdev,\n\t\t       struct radeon_ring *ring)\n{\n\tWREG32(UVD_RBC_RB_WPTR, ring->wptr);\n}\n\n \nvoid uvd_v1_0_fence_emit(struct radeon_device *rdev,\n\t\t\t struct radeon_fence *fence)\n{\n\tstruct radeon_ring *ring = &rdev->ring[fence->ring];\n\tuint64_t addr = rdev->fence_drv[fence->ring].gpu_addr;\n\n\tradeon_ring_write(ring, PACKET0(UVD_GPCOM_VCPU_DATA0, 0));\n\tradeon_ring_write(ring, addr & 0xffffffff);\n\tradeon_ring_write(ring, PACKET0(UVD_GPCOM_VCPU_DATA1, 0));\n\tradeon_ring_write(ring, fence->seq);\n\tradeon_ring_write(ring, PACKET0(UVD_GPCOM_VCPU_CMD, 0));\n\tradeon_ring_write(ring, 0);\n\n\tradeon_ring_write(ring, PACKET0(UVD_GPCOM_VCPU_DATA0, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(UVD_GPCOM_VCPU_DATA1, 0));\n\tradeon_ring_write(ring, 0);\n\tradeon_ring_write(ring, PACKET0(UVD_GPCOM_VCPU_CMD, 0));\n\tradeon_ring_write(ring, 2);\n\treturn;\n}\n\n \nint uvd_v1_0_resume(struct radeon_device *rdev)\n{\n\tuint64_t addr;\n\tuint32_t size;\n\tint r;\n\n\tr = radeon_uvd_resume(rdev);\n\tif (r)\n\t\treturn r;\n\n\t \n\taddr = (rdev->uvd.gpu_addr >> 3) + 16;\n\tsize = RADEON_GPU_PAGE_ALIGN(rdev->uvd_fw->size) >> 3;\n\tWREG32(UVD_VCPU_CACHE_OFFSET0, addr);\n\tWREG32(UVD_VCPU_CACHE_SIZE0, size);\n\n\taddr += size;\n\tsize = RADEON_UVD_HEAP_SIZE >> 3;\n\tWREG32(UVD_VCPU_CACHE_OFFSET1, addr);\n\tWREG32(UVD_VCPU_CACHE_SIZE1, size);\n\n\taddr += size;\n\tsize = (RADEON_UVD_STACK_SIZE +\n\t       (RADEON_UVD_SESSION_SIZE * rdev->uvd.max_handles)) >> 3;\n\tWREG32(UVD_VCPU_CACHE_OFFSET2, addr);\n\tWREG32(UVD_VCPU_CACHE_SIZE2, size);\n\n\t \n\taddr = (rdev->uvd.gpu_addr >> 28) & 0xF;\n\tWREG32(UVD_LMI_ADDR_EXT, (addr << 12) | (addr << 0));\n\n\t \n\taddr = (rdev->uvd.gpu_addr >> 32) & 0xFF;\n\tWREG32(UVD_LMI_EXT40_ADDR, addr | (0x9 << 16) | (0x1 << 31));\n\n\tWREG32(UVD_FW_START, *((uint32_t*)rdev->uvd.cpu_addr));\n\n\treturn 0;\n}\n\n \nint uvd_v1_0_init(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tuint32_t tmp;\n\tint r;\n\n\t \n\tif (rdev->family < CHIP_RV740)\n\t\tradeon_set_uvd_clocks(rdev, 10000, 10000);\n\telse\n\t\tradeon_set_uvd_clocks(rdev, 53300, 40000);\n\n\tr = uvd_v1_0_start(rdev);\n\tif (r)\n\t\tgoto done;\n\n\tring->ready = true;\n\tr = radeon_ring_test(rdev, R600_RING_TYPE_UVD_INDEX, ring);\n\tif (r) {\n\t\tring->ready = false;\n\t\tgoto done;\n\t}\n\n\tr = radeon_ring_lock(rdev, ring, 10);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: ring failed to lock UVD ring (%d).\\n\", r);\n\t\tgoto done;\n\t}\n\n\ttmp = PACKET0(UVD_SEMA_WAIT_FAULT_TIMEOUT_CNTL, 0);\n\tradeon_ring_write(ring, tmp);\n\tradeon_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(UVD_SEMA_WAIT_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tradeon_ring_write(ring, tmp);\n\tradeon_ring_write(ring, 0xFFFFF);\n\n\ttmp = PACKET0(UVD_SEMA_SIGNAL_INCOMPLETE_TIMEOUT_CNTL, 0);\n\tradeon_ring_write(ring, tmp);\n\tradeon_ring_write(ring, 0xFFFFF);\n\n\t \n\tradeon_ring_write(ring, PACKET0(UVD_SEMA_TIMEOUT_STATUS, 0));\n\tradeon_ring_write(ring, 0x8);\n\n\tradeon_ring_write(ring, PACKET0(UVD_SEMA_CNTL, 0));\n\tradeon_ring_write(ring, 3);\n\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\ndone:\n\t \n\tradeon_set_uvd_clocks(rdev, 0, 0);\n\n\tif (!r) {\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_RV610:\n\t\tcase CHIP_RV630:\n\t\tcase CHIP_RV620:\n\t\t\t \n\t\t\tWREG32(MC_CONFIG, 0);\n\t\t\tWREG32(MC_CONFIG, 1 << 4);\n\t\t\tWREG32(RS_DQ_RD_RET_CONF, 0x3f);\n\t\t\tWREG32(MC_CONFIG, 0x1f);\n\n\t\t\tfallthrough;\n\t\tcase CHIP_RV670:\n\t\tcase CHIP_RV635:\n\n\t\t\t \n\t\t\tWREG32_P(UVD_VCPU_CNTL, 0x10, ~0x10);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tDRM_INFO(\"UVD initialized successfully.\\n\");\n\t}\n\n\treturn r;\n}\n\n \nvoid uvd_v1_0_fini(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\n\tuvd_v1_0_stop(rdev);\n\tring->ready = false;\n}\n\n \nint uvd_v1_0_start(struct radeon_device *rdev)\n{\n\tstruct radeon_ring *ring = &rdev->ring[R600_RING_TYPE_UVD_INDEX];\n\tuint32_t rb_bufsz;\n\tint i, j, r;\n\n\t \n\tu32 lmi_swap_cntl = 0;\n\tu32 mp_swap_cntl = 0;\n\n\t \n\tWREG32(UVD_CGC_GATE, 0);\n\n\t \n\tWREG32_P(UVD_MASTINT_EN, 0, ~(1 << 1));\n\n\t \n\tWREG32_P(UVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\n\tWREG32_P(UVD_RB_ARB_CTRL, 1 << 3, ~(1 << 3));\n\tmdelay(1);\n\n\t \n\tWREG32(UVD_SOFT_RESET, LMI_SOFT_RESET | VCPU_SOFT_RESET |\n\t       LBSI_SOFT_RESET | RBC_SOFT_RESET | CSM_SOFT_RESET |\n\t       CXW_SOFT_RESET | TAP_SOFT_RESET | LMI_UMC_SOFT_RESET);\n\tmdelay(5);\n\n\t \n\tWREG32_P(SRBM_SOFT_RESET, 0, ~SOFT_RESET_UVD);\n\tmdelay(5);\n\n\t \n\tWREG32(UVD_LMI_CTRL, 0x40 | (1 << 8) | (1 << 13) |\n\t\t\t     (1 << 21) | (1 << 9) | (1 << 20));\n\n#ifdef __BIG_ENDIAN\n\t \n\tlmi_swap_cntl = 0xa;\n\tmp_swap_cntl = 0;\n#endif\n\tWREG32(UVD_LMI_SWAP_CNTL, lmi_swap_cntl);\n\tWREG32(UVD_MP_SWAP_CNTL, mp_swap_cntl);\n\n\tWREG32(UVD_MPC_SET_MUXA0, 0x40c2040);\n\tWREG32(UVD_MPC_SET_MUXA1, 0x0);\n\tWREG32(UVD_MPC_SET_MUXB0, 0x40c2040);\n\tWREG32(UVD_MPC_SET_MUXB1, 0x0);\n\tWREG32(UVD_MPC_SET_ALU, 0);\n\tWREG32(UVD_MPC_SET_MUX, 0x88);\n\n\t \n\tWREG32(UVD_SOFT_RESET, VCPU_SOFT_RESET);\n\tmdelay(5);\n\n\t \n\tWREG32(UVD_VCPU_CNTL,  1 << 9);\n\n\t \n\tWREG32_P(UVD_LMI_CTRL2, 0, ~(1 << 8));\n\n\tWREG32_P(UVD_RB_ARB_CTRL, 0, ~(1 << 3));\n\n\t \n\tWREG32(UVD_SOFT_RESET, 0);\n\tmdelay(10);\n\n\tfor (i = 0; i < 10; ++i) {\n\t\tuint32_t status;\n\t\tfor (j = 0; j < 100; ++j) {\n\t\t\tstatus = RREG32(UVD_STATUS);\n\t\t\tif (status & 2)\n\t\t\t\tbreak;\n\t\t\tmdelay(10);\n\t\t}\n\t\tr = 0;\n\t\tif (status & 2)\n\t\t\tbreak;\n\n\t\tDRM_ERROR(\"UVD not responding, trying to reset the VCPU!!!\\n\");\n\t\tWREG32_P(UVD_SOFT_RESET, VCPU_SOFT_RESET, ~VCPU_SOFT_RESET);\n\t\tmdelay(10);\n\t\tWREG32_P(UVD_SOFT_RESET, 0, ~VCPU_SOFT_RESET);\n\t\tmdelay(10);\n\t\tr = -1;\n\t}\n\n\tif (r) {\n\t\tDRM_ERROR(\"UVD not responding, giving up!!!\\n\");\n\t\treturn r;\n\t}\n\n\t \n\tWREG32_P(UVD_MASTINT_EN, 3<<1, ~(3 << 1));\n\n\t \n\tWREG32(UVD_RBC_RB_CNTL, 0x11010101);\n\n\t \n\tWREG32(UVD_RBC_RB_WPTR_CNTL, 0);\n\n\t \n\tWREG32(UVD_LMI_EXT40_ADDR, upper_32_bits(ring->gpu_addr) |\n\t\t\t\t   (0x7 << 16) | (0x1 << 31));\n\n\t \n\tWREG32(UVD_RBC_RB_RPTR, 0x0);\n\n\tring->wptr = RREG32(UVD_RBC_RB_RPTR);\n\tWREG32(UVD_RBC_RB_WPTR, ring->wptr);\n\n\t \n\tWREG32(UVD_RBC_RB_BASE, ring->gpu_addr);\n\n\t \n\trb_bufsz = order_base_2(ring->ring_size);\n\trb_bufsz = (0x1 << 8) | rb_bufsz;\n\tWREG32_P(UVD_RBC_RB_CNTL, rb_bufsz, ~0x11f1f);\n\n\treturn 0;\n}\n\n \nvoid uvd_v1_0_stop(struct radeon_device *rdev)\n{\n\t \n\tWREG32(UVD_RBC_RB_CNTL, 0x11010101);\n\n\t \n\tWREG32_P(UVD_LMI_CTRL2, 1 << 8, ~(1 << 8));\n\tWREG32_P(UVD_RB_ARB_CTRL, 1 << 3, ~(1 << 3));\n\tmdelay(1);\n\n\t \n\tWREG32(UVD_SOFT_RESET, VCPU_SOFT_RESET);\n\tmdelay(5);\n\n\t \n\tWREG32(UVD_VCPU_CNTL, 0x0);\n\n\t \n\tWREG32_P(UVD_LMI_CTRL2, 0, ~(1 << 8));\n\tWREG32_P(UVD_RB_ARB_CTRL, 0, ~(1 << 3));\n}\n\n \nint uvd_v1_0_ring_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tuint32_t tmp = 0;\n\tunsigned i;\n\tint r;\n\n\tWREG32(UVD_CONTEXT_ID, 0xCAFEDEAD);\n\tr = radeon_ring_lock(rdev, ring, 3);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: cp failed to lock ring %d (%d).\\n\",\n\t\t\t  ring->idx, r);\n\t\treturn r;\n\t}\n\tradeon_ring_write(ring, PACKET0(UVD_CONTEXT_ID, 0));\n\tradeon_ring_write(ring, 0xDEADBEEF);\n\tradeon_ring_unlock_commit(rdev, ring, false);\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32(UVD_CONTEXT_ID);\n\t\tif (tmp == 0xDEADBEEF)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i < rdev->usec_timeout) {\n\t\tDRM_INFO(\"ring test on %d succeeded in %d usecs\\n\",\n\t\t\t ring->idx, i);\n\t} else {\n\t\tDRM_ERROR(\"radeon: ring %d test failed (0x%08X)\\n\",\n\t\t\t  ring->idx, tmp);\n\t\tr = -EINVAL;\n\t}\n\treturn r;\n}\n\n \nbool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,\n\t\t\t     struct radeon_ring *ring,\n\t\t\t     struct radeon_semaphore *semaphore,\n\t\t\t     bool emit_wait)\n{\n\t \n\treturn false;\n}\n\n \nvoid uvd_v1_0_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib)\n{\n\tstruct radeon_ring *ring = &rdev->ring[ib->ring];\n\n\tradeon_ring_write(ring, PACKET0(UVD_RBC_IB_BASE, 0));\n\tradeon_ring_write(ring, ib->gpu_addr);\n\tradeon_ring_write(ring, PACKET0(UVD_RBC_IB_SIZE, 0));\n\tradeon_ring_write(ring, ib->length_dw);\n}\n\n \nint uvd_v1_0_ib_test(struct radeon_device *rdev, struct radeon_ring *ring)\n{\n\tstruct radeon_fence *fence = NULL;\n\tint r;\n\n\tif (rdev->family < CHIP_RV740)\n\t\tr = radeon_set_uvd_clocks(rdev, 10000, 10000);\n\telse\n\t\tr = radeon_set_uvd_clocks(rdev, 53300, 40000);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to raise UVD clocks (%d).\\n\", r);\n\t\treturn r;\n\t}\n\n\tr = radeon_uvd_get_create_msg(rdev, ring->idx, 1, NULL);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get create msg (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\n\tr = radeon_uvd_get_destroy_msg(rdev, ring->idx, 1, &fence);\n\tif (r) {\n\t\tDRM_ERROR(\"radeon: failed to get destroy ib (%d).\\n\", r);\n\t\tgoto error;\n\t}\n\n\tr = radeon_fence_wait_timeout(fence, false, usecs_to_jiffies(\n\t\tRADEON_USEC_IB_TEST_TIMEOUT));\n\tif (r < 0) {\n\t\tDRM_ERROR(\"radeon: fence wait failed (%d).\\n\", r);\n\t\tgoto error;\n\t} else if (r == 0) {\n\t\tDRM_ERROR(\"radeon: fence wait timed out.\\n\");\n\t\tr = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\tr = 0;\n\tDRM_INFO(\"ib test on ring %d succeeded\\n\",  ring->idx);\nerror:\n\tradeon_fence_unref(&fence);\n\tradeon_set_uvd_clocks(rdev, 0, 0);\n\treturn r;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}