{
  "module_name": "ci_smc.c",
  "hash_id": "535dd695f3dedcf5e203c18ef0c5c3c2643ec9e272535ea9085b6d1107ea87a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/radeon/ci_smc.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"radeon.h\"\n#include \"cikd.h\"\n#include \"ppsmc.h\"\n#include \"radeon_ucode.h\"\n#include \"ci_dpm.h\"\n\nstatic int ci_set_smc_sram_address(struct radeon_device *rdev,\n\t\t\t\t   u32 smc_address, u32 limit)\n{\n\tif (smc_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_address + 3) > limit)\n\t\treturn -EINVAL;\n\n\tWREG32(SMC_IND_INDEX_0, smc_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\n\treturn 0;\n}\n\nint ci_copy_bytes_to_smc(struct radeon_device *rdev,\n\t\t\t u32 smc_start_address,\n\t\t\t const u8 *src, u32 byte_count, u32 limit)\n{\n\tunsigned long flags;\n\tu32 data, original_data;\n\tu32 addr;\n\tu32 extra_shift;\n\tint ret = 0;\n\n\tif (smc_start_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_start_address + byte_count) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_start_address;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\twhile (byte_count >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tret = ci_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\t \n\tif (byte_count > 0) {\n\t\tdata = 0;\n\n\t\tret = ci_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\toriginal_data = RREG32(SMC_IND_DATA_0);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\tdata = (data << 8) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tret = ci_set_smc_sram_address(rdev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nvoid ci_start_smc(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\n\ttmp &= ~RST_REG;\n\tWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\n}\n\nvoid ci_reset_smc(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\n\ttmp |= RST_REG;\n\tWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\n}\n\nint ci_program_jump_on_start(struct radeon_device *rdev)\n{\n\tstatic const u8 data[] = { 0xE0, 0x00, 0x80, 0x40 };\n\n\treturn ci_copy_bytes_to_smc(rdev, 0x0, data, 4, sizeof(data)+1);\n}\n\nvoid ci_stop_smc_clock(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\ttmp |= CK_DISABLE;\n\n\tWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\n}\n\nvoid ci_start_smc_clock(struct radeon_device *rdev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\ttmp &= ~CK_DISABLE;\n\n\tWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\n}\n\nbool ci_is_smc_running(struct radeon_device *rdev)\n{\n\tu32 clk = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\tu32 pc_c = RREG32_SMC(SMC_PC_C);\n\n\tif (!(clk & CK_DISABLE) && (0x20100 <= pc_c))\n\t\treturn true;\n\n\treturn false;\n}\n\n#if 0\nPPSMC_Result ci_wait_for_smc_inactive(struct radeon_device *rdev)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!ci_is_smc_running(rdev))\n\t\treturn PPSMC_Result_OK;\n\n\tfor (i = 0; i < rdev->usec_timeout; i++) {\n\t\ttmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\t\tif ((tmp & CKEN) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn PPSMC_Result_OK;\n}\n#endif\n\nint ci_load_smc_ucode(struct radeon_device *rdev, u32 limit)\n{\n\tunsigned long flags;\n\tu32 ucode_start_address;\n\tu32 ucode_size;\n\tconst u8 *src;\n\tu32 data;\n\n\tif (!rdev->smc_fw)\n\t\treturn -EINVAL;\n\n\tif (rdev->new_fw) {\n\t\tconst struct smc_firmware_header_v1_0 *hdr =\n\t\t\t(const struct smc_firmware_header_v1_0 *)rdev->smc_fw->data;\n\n\t\tradeon_ucode_print_smc_hdr(&hdr->header);\n\n\t\tucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\n\t\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\n\t\tsrc = (const u8 *)\n\t\t\t(rdev->smc_fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\t} else {\n\t\tswitch (rdev->family) {\n\t\tcase CHIP_BONAIRE:\n\t\t\tucode_start_address = BONAIRE_SMC_UCODE_START;\n\t\t\tucode_size = BONAIRE_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tcase CHIP_HAWAII:\n\t\t\tucode_start_address = HAWAII_SMC_UCODE_START;\n\t\t\tucode_size = HAWAII_SMC_UCODE_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_ERROR(\"unknown asic in smc ucode loader\\n\");\n\t\t\tBUG();\n\t\t}\n\n\t\tsrc = (const u8 *)rdev->smc_fw->data;\n\t}\n\n\tif (ucode_size & 3)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tWREG32(SMC_IND_INDEX_0, ucode_start_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, ~AUTO_INCREMENT_IND_0);\n\twhile (ucode_size >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tucode_size -= 4;\n\t}\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn 0;\n}\n\nint ci_read_smc_sram_dword(struct radeon_device *rdev,\n\t\t\t   u32 smc_address, u32 *value, u32 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tret = ci_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret == 0)\n\t\t*value = RREG32(SMC_IND_DATA_0);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nint ci_write_smc_sram_dword(struct radeon_device *rdev,\n\t\t\t    u32 smc_address, u32 value, u32 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&rdev->smc_idx_lock, flags);\n\tret = ci_set_smc_sram_address(rdev, smc_address, limit);\n\tif (ret == 0)\n\t\tWREG32(SMC_IND_DATA_0, value);\n\tspin_unlock_irqrestore(&rdev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}