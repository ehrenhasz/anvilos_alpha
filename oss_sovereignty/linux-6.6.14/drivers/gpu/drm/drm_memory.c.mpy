{
  "module_name": "drm_memory.c",
  "hash_id": "09745b92d91ade12dab697a8e48943ecca139feaaa7218a5d6c456b759ece384",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_memory.c",
  "human_readable_source": " \n\n \n\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include <drm/drm_cache.h>\n#include <drm/drm_device.h>\n\n#include \"drm_legacy.h\"\n\n#if IS_ENABLED(CONFIG_AGP)\n\n#ifdef HAVE_PAGE_AGP\n# include <asm/agp.h>\n#else\n# ifdef __powerpc__\n#  define PAGE_AGP\tpgprot_noncached_wc(PAGE_KERNEL)\n# else\n#  define PAGE_AGP\tPAGE_KERNEL\n# endif\n#endif\n\nstatic void *agp_remap(unsigned long offset, unsigned long size,\n\t\t       struct drm_device *dev)\n{\n\tunsigned long i, num_pages =\n\t    PAGE_ALIGN(size) / PAGE_SIZE;\n\tstruct drm_agp_mem *agpmem;\n\tstruct page **page_map;\n\tstruct page **phys_page_map;\n\tvoid *addr;\n\n\tsize = PAGE_ALIGN(size);\n\n#ifdef __alpha__\n\toffset -= dev->hose->mem_space->start;\n#endif\n\n\tlist_for_each_entry(agpmem, &dev->agp->memory, head)\n\t\tif (agpmem->bound <= offset\n\t\t    && (agpmem->bound + (agpmem->pages << PAGE_SHIFT)) >=\n\t\t    (offset + size))\n\t\t\tbreak;\n\tif (&agpmem->head == &dev->agp->memory)\n\t\treturn NULL;\n\n\t \n\t \n\tpage_map = vmalloc(array_size(num_pages, sizeof(struct page *)));\n\tif (!page_map)\n\t\treturn NULL;\n\n\tphys_page_map = (agpmem->memory->pages + (offset - agpmem->bound) / PAGE_SIZE);\n\tfor (i = 0; i < num_pages; ++i)\n\t\tpage_map[i] = phys_page_map[i];\n\taddr = vmap(page_map, num_pages, VM_IOREMAP, PAGE_AGP);\n\tvfree(page_map);\n\n\treturn addr;\n}\n\n#else  \nstatic inline void *agp_remap(unsigned long offset, unsigned long size,\n\t\t\t      struct drm_device *dev)\n{\n\treturn NULL;\n}\n\n#endif  \n\nvoid drm_legacy_ioremap(struct drm_local_map *map, struct drm_device *dev)\n{\n\tif (dev->agp && dev->agp->cant_use_aperture && map->type == _DRM_AGP)\n\t\tmap->handle = agp_remap(map->offset, map->size, dev);\n\telse\n\t\tmap->handle = ioremap(map->offset, map->size);\n}\nEXPORT_SYMBOL(drm_legacy_ioremap);\n\nvoid drm_legacy_ioremap_wc(struct drm_local_map *map, struct drm_device *dev)\n{\n\tif (dev->agp && dev->agp->cant_use_aperture && map->type == _DRM_AGP)\n\t\tmap->handle = agp_remap(map->offset, map->size, dev);\n\telse\n\t\tmap->handle = ioremap_wc(map->offset, map->size);\n}\nEXPORT_SYMBOL(drm_legacy_ioremap_wc);\n\nvoid drm_legacy_ioremapfree(struct drm_local_map *map, struct drm_device *dev)\n{\n\tif (!map->handle || !map->size)\n\t\treturn;\n\n\tif (dev->agp && dev->agp->cant_use_aperture && map->type == _DRM_AGP)\n\t\tvunmap(map->handle);\n\telse\n\t\tiounmap(map->handle);\n}\nEXPORT_SYMBOL(drm_legacy_ioremapfree);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}