{
  "module_name": "drm_suballoc.c",
  "hash_id": "479384e10699c3b118c2afb3938ff30bb2917f6e53afd52070272bce1c1e7d38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_suballoc.c",
  "human_readable_source": "\n \n \n\n#include <drm/drm_suballoc.h>\n#include <drm/drm_print.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/dma-fence.h>\n\nstatic void drm_suballoc_remove_locked(struct drm_suballoc *sa);\nstatic void drm_suballoc_try_free(struct drm_suballoc_manager *sa_manager);\n\n \nvoid drm_suballoc_manager_init(struct drm_suballoc_manager *sa_manager,\n\t\t\t       size_t size, size_t align)\n{\n\tunsigned int i;\n\n\tBUILD_BUG_ON(!is_power_of_2(DRM_SUBALLOC_MAX_QUEUES));\n\n\tif (!align)\n\t\talign = 1;\n\n\t \n\tif (WARN_ON_ONCE(align & (align - 1)))\n\t\talign = roundup_pow_of_two(align);\n\n\tinit_waitqueue_head(&sa_manager->wq);\n\tsa_manager->size = size;\n\tsa_manager->align = align;\n\tsa_manager->hole = &sa_manager->olist;\n\tINIT_LIST_HEAD(&sa_manager->olist);\n\tfor (i = 0; i < DRM_SUBALLOC_MAX_QUEUES; ++i)\n\t\tINIT_LIST_HEAD(&sa_manager->flist[i]);\n}\nEXPORT_SYMBOL(drm_suballoc_manager_init);\n\n \nvoid drm_suballoc_manager_fini(struct drm_suballoc_manager *sa_manager)\n{\n\tstruct drm_suballoc *sa, *tmp;\n\n\tif (!sa_manager->size)\n\t\treturn;\n\n\tif (!list_empty(&sa_manager->olist)) {\n\t\tsa_manager->hole = &sa_manager->olist;\n\t\tdrm_suballoc_try_free(sa_manager);\n\t\tif (!list_empty(&sa_manager->olist))\n\t\t\tDRM_ERROR(\"sa_manager is not empty, clearing anyway\\n\");\n\t}\n\tlist_for_each_entry_safe(sa, tmp, &sa_manager->olist, olist) {\n\t\tdrm_suballoc_remove_locked(sa);\n\t}\n\n\tsa_manager->size = 0;\n}\nEXPORT_SYMBOL(drm_suballoc_manager_fini);\n\nstatic void drm_suballoc_remove_locked(struct drm_suballoc *sa)\n{\n\tstruct drm_suballoc_manager *sa_manager = sa->manager;\n\n\tif (sa_manager->hole == &sa->olist)\n\t\tsa_manager->hole = sa->olist.prev;\n\n\tlist_del_init(&sa->olist);\n\tlist_del_init(&sa->flist);\n\tdma_fence_put(sa->fence);\n\tkfree(sa);\n}\n\nstatic void drm_suballoc_try_free(struct drm_suballoc_manager *sa_manager)\n{\n\tstruct drm_suballoc *sa, *tmp;\n\n\tif (sa_manager->hole->next == &sa_manager->olist)\n\t\treturn;\n\n\tsa = list_entry(sa_manager->hole->next, struct drm_suballoc, olist);\n\tlist_for_each_entry_safe_from(sa, tmp, &sa_manager->olist, olist) {\n\t\tif (!sa->fence || !dma_fence_is_signaled(sa->fence))\n\t\t\treturn;\n\n\t\tdrm_suballoc_remove_locked(sa);\n\t}\n}\n\nstatic size_t drm_suballoc_hole_soffset(struct drm_suballoc_manager *sa_manager)\n{\n\tstruct list_head *hole = sa_manager->hole;\n\n\tif (hole != &sa_manager->olist)\n\t\treturn list_entry(hole, struct drm_suballoc, olist)->eoffset;\n\n\treturn 0;\n}\n\nstatic size_t drm_suballoc_hole_eoffset(struct drm_suballoc_manager *sa_manager)\n{\n\tstruct list_head *hole = sa_manager->hole;\n\n\tif (hole->next != &sa_manager->olist)\n\t\treturn list_entry(hole->next, struct drm_suballoc, olist)->soffset;\n\treturn sa_manager->size;\n}\n\nstatic bool drm_suballoc_try_alloc(struct drm_suballoc_manager *sa_manager,\n\t\t\t\t   struct drm_suballoc *sa,\n\t\t\t\t   size_t size, size_t align)\n{\n\tsize_t soffset, eoffset, wasted;\n\n\tsoffset = drm_suballoc_hole_soffset(sa_manager);\n\teoffset = drm_suballoc_hole_eoffset(sa_manager);\n\twasted = round_up(soffset, align) - soffset;\n\n\tif ((eoffset - soffset) >= (size + wasted)) {\n\t\tsoffset += wasted;\n\n\t\tsa->manager = sa_manager;\n\t\tsa->soffset = soffset;\n\t\tsa->eoffset = soffset + size;\n\t\tlist_add(&sa->olist, sa_manager->hole);\n\t\tINIT_LIST_HEAD(&sa->flist);\n\t\tsa_manager->hole = &sa->olist;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool __drm_suballoc_event(struct drm_suballoc_manager *sa_manager,\n\t\t\t\t size_t size, size_t align)\n{\n\tsize_t soffset, eoffset, wasted;\n\tunsigned int i;\n\n\tfor (i = 0; i < DRM_SUBALLOC_MAX_QUEUES; ++i)\n\t\tif (!list_empty(&sa_manager->flist[i]))\n\t\t\treturn true;\n\n\tsoffset = drm_suballoc_hole_soffset(sa_manager);\n\teoffset = drm_suballoc_hole_eoffset(sa_manager);\n\twasted = round_up(soffset, align) - soffset;\n\n\treturn ((eoffset - soffset) >= (size + wasted));\n}\n\n \nstatic bool drm_suballoc_event(struct drm_suballoc_manager *sa_manager,\n\t\t\t       size_t size, size_t align)\n{\n\tbool ret;\n\n\tspin_lock(&sa_manager->wq.lock);\n\tret = __drm_suballoc_event(sa_manager, size, align);\n\tspin_unlock(&sa_manager->wq.lock);\n\treturn ret;\n}\n\nstatic bool drm_suballoc_next_hole(struct drm_suballoc_manager *sa_manager,\n\t\t\t\t   struct dma_fence **fences,\n\t\t\t\t   unsigned int *tries)\n{\n\tstruct drm_suballoc *best_bo = NULL;\n\tunsigned int i, best_idx;\n\tsize_t soffset, best, tmp;\n\n\t \n\tif (sa_manager->hole->next == &sa_manager->olist) {\n\t\t \n\t\tsa_manager->hole = &sa_manager->olist;\n\t\treturn true;\n\t}\n\n\tsoffset = drm_suballoc_hole_soffset(sa_manager);\n\t \n\tbest = sa_manager->size * 2;\n\t \n\tfor (i = 0; i < DRM_SUBALLOC_MAX_QUEUES; ++i) {\n\t\tstruct drm_suballoc *sa;\n\n\t\tfences[i] = NULL;\n\n\t\tif (list_empty(&sa_manager->flist[i]))\n\t\t\tcontinue;\n\n\t\tsa = list_first_entry(&sa_manager->flist[i],\n\t\t\t\t      struct drm_suballoc, flist);\n\n\t\tif (!dma_fence_is_signaled(sa->fence)) {\n\t\t\tfences[i] = sa->fence;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (tries[i] > 2)\n\t\t\tcontinue;\n\n\t\ttmp = sa->soffset;\n\t\tif (tmp < soffset) {\n\t\t\t \n\t\t\ttmp += sa_manager->size;\n\t\t}\n\t\ttmp -= soffset;\n\t\tif (tmp < best) {\n\t\t\t \n\t\t\tbest = tmp;\n\t\t\tbest_idx = i;\n\t\t\tbest_bo = sa;\n\t\t}\n\t}\n\n\tif (best_bo) {\n\t\t++tries[best_idx];\n\t\tsa_manager->hole = best_bo->olist.prev;\n\n\t\t \n\t\tdrm_suballoc_remove_locked(best_bo);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstruct drm_suballoc *\ndrm_suballoc_new(struct drm_suballoc_manager *sa_manager, size_t size,\n\t\t gfp_t gfp, bool intr, size_t align)\n{\n\tstruct dma_fence *fences[DRM_SUBALLOC_MAX_QUEUES];\n\tunsigned int tries[DRM_SUBALLOC_MAX_QUEUES];\n\tunsigned int count;\n\tint i, r;\n\tstruct drm_suballoc *sa;\n\n\tif (WARN_ON_ONCE(align > sa_manager->align))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON_ONCE(size > sa_manager->size || !size))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!align)\n\t\talign = sa_manager->align;\n\n\tsa = kmalloc(sizeof(*sa), gfp);\n\tif (!sa)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsa->manager = sa_manager;\n\tsa->fence = NULL;\n\tINIT_LIST_HEAD(&sa->olist);\n\tINIT_LIST_HEAD(&sa->flist);\n\n\tspin_lock(&sa_manager->wq.lock);\n\tdo {\n\t\tfor (i = 0; i < DRM_SUBALLOC_MAX_QUEUES; ++i)\n\t\t\ttries[i] = 0;\n\n\t\tdo {\n\t\t\tdrm_suballoc_try_free(sa_manager);\n\n\t\t\tif (drm_suballoc_try_alloc(sa_manager, sa,\n\t\t\t\t\t\t   size, align)) {\n\t\t\t\tspin_unlock(&sa_manager->wq.lock);\n\t\t\t\treturn sa;\n\t\t\t}\n\n\t\t\t \n\t\t} while (drm_suballoc_next_hole(sa_manager, fences, tries));\n\n\t\tfor (i = 0, count = 0; i < DRM_SUBALLOC_MAX_QUEUES; ++i)\n\t\t\tif (fences[i])\n\t\t\t\tfences[count++] = dma_fence_get(fences[i]);\n\n\t\tif (count) {\n\t\t\tlong t;\n\n\t\t\tspin_unlock(&sa_manager->wq.lock);\n\t\t\tt = dma_fence_wait_any_timeout(fences, count, intr,\n\t\t\t\t\t\t       MAX_SCHEDULE_TIMEOUT,\n\t\t\t\t\t\t       NULL);\n\t\t\tfor (i = 0; i < count; ++i)\n\t\t\t\tdma_fence_put(fences[i]);\n\n\t\t\tr = (t > 0) ? 0 : t;\n\t\t\tspin_lock(&sa_manager->wq.lock);\n\t\t} else if (intr) {\n\t\t\t \n\t\t\tr = wait_event_interruptible_locked\n\t\t\t\t(sa_manager->wq,\n\t\t\t\t __drm_suballoc_event(sa_manager, size, align));\n\t\t} else {\n\t\t\tspin_unlock(&sa_manager->wq.lock);\n\t\t\twait_event(sa_manager->wq,\n\t\t\t\t   drm_suballoc_event(sa_manager, size, align));\n\t\t\tr = 0;\n\t\t\tspin_lock(&sa_manager->wq.lock);\n\t\t}\n\t} while (!r);\n\n\tspin_unlock(&sa_manager->wq.lock);\n\tkfree(sa);\n\treturn ERR_PTR(r);\n}\nEXPORT_SYMBOL(drm_suballoc_new);\n\n \nvoid drm_suballoc_free(struct drm_suballoc *suballoc,\n\t\t       struct dma_fence *fence)\n{\n\tstruct drm_suballoc_manager *sa_manager;\n\n\tif (!suballoc)\n\t\treturn;\n\n\tsa_manager = suballoc->manager;\n\n\tspin_lock(&sa_manager->wq.lock);\n\tif (fence && !dma_fence_is_signaled(fence)) {\n\t\tu32 idx;\n\n\t\tsuballoc->fence = dma_fence_get(fence);\n\t\tidx = fence->context & (DRM_SUBALLOC_MAX_QUEUES - 1);\n\t\tlist_add_tail(&suballoc->flist, &sa_manager->flist[idx]);\n\t} else {\n\t\tdrm_suballoc_remove_locked(suballoc);\n\t}\n\twake_up_all_locked(&sa_manager->wq);\n\tspin_unlock(&sa_manager->wq.lock);\n}\nEXPORT_SYMBOL(drm_suballoc_free);\n\n#ifdef CONFIG_DEBUG_FS\nvoid drm_suballoc_dump_debug_info(struct drm_suballoc_manager *sa_manager,\n\t\t\t\t  struct drm_printer *p,\n\t\t\t\t  unsigned long long suballoc_base)\n{\n\tstruct drm_suballoc *i;\n\n\tspin_lock(&sa_manager->wq.lock);\n\tlist_for_each_entry(i, &sa_manager->olist, olist) {\n\t\tunsigned long long soffset = i->soffset;\n\t\tunsigned long long eoffset = i->eoffset;\n\n\t\tif (&i->olist == sa_manager->hole)\n\t\t\tdrm_puts(p, \">\");\n\t\telse\n\t\t\tdrm_puts(p, \" \");\n\n\t\tdrm_printf(p, \"[0x%010llx 0x%010llx] size %8lld\",\n\t\t\t   suballoc_base + soffset, suballoc_base + eoffset,\n\t\t\t   eoffset - soffset);\n\n\t\tif (i->fence)\n\t\t\tdrm_printf(p, \" protected by 0x%016llx on context %llu\",\n\t\t\t\t   (unsigned long long)i->fence->seqno,\n\t\t\t\t   (unsigned long long)i->fence->context);\n\n\t\tdrm_puts(p, \"\\n\");\n\t}\n\tspin_unlock(&sa_manager->wq.lock);\n}\nEXPORT_SYMBOL(drm_suballoc_dump_debug_info);\n#endif\nMODULE_AUTHOR(\"Multiple\");\nMODULE_DESCRIPTION(\"Range suballocator helper\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}