{
  "module_name": "drm_file.c",
  "hash_id": "86bc027d0b44579000bfacefedcfcfde7fda7ec1cb51ab6172ba5975c71a643c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_file.c",
  "human_readable_source": " \n\n \n\n#include <linux/anon_inodes.h>\n#include <linux/dma-fence.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n\n#include <drm/drm_client.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_print.h>\n\n#include \"drm_crtc_internal.h\"\n#include \"drm_internal.h\"\n#include \"drm_legacy.h\"\n\n \nDEFINE_MUTEX(drm_global_mutex);\n\nbool drm_dev_needs_global_mutex(struct drm_device *dev)\n{\n\t \n\tif (drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn true;\n\n\t \n\tif (dev->driver->load || dev->driver->unload)\n\t\treturn true;\n\n\t \n\tif (dev->driver->lastclose)\n\t\treturn true;\n\n\treturn false;\n}\n\n \n\n \nstruct drm_file *drm_file_alloc(struct drm_minor *minor)\n{\n\tstatic atomic64_t ident = ATOMIC_INIT(0);\n\tstruct drm_device *dev = minor->dev;\n\tstruct drm_file *file;\n\tint ret;\n\n\tfile = kzalloc(sizeof(*file), GFP_KERNEL);\n\tif (!file)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfile->client_id = atomic64_inc_return(&ident);\n\trcu_assign_pointer(file->pid, get_pid(task_tgid(current)));\n\tfile->minor = minor;\n\n\t \n\tfile->authenticated = capable(CAP_SYS_ADMIN);\n\n\tINIT_LIST_HEAD(&file->lhead);\n\tINIT_LIST_HEAD(&file->fbs);\n\tmutex_init(&file->fbs_lock);\n\tINIT_LIST_HEAD(&file->blobs);\n\tINIT_LIST_HEAD(&file->pending_event_list);\n\tINIT_LIST_HEAD(&file->event_list);\n\tinit_waitqueue_head(&file->event_wait);\n\tfile->event_space = 4096;  \n\n\tspin_lock_init(&file->master_lookup_lock);\n\tmutex_init(&file->event_read_lock);\n\n\tif (drm_core_check_feature(dev, DRIVER_GEM))\n\t\tdrm_gem_open(dev, file);\n\n\tif (drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\tdrm_syncobj_open(file);\n\n\tdrm_prime_init_file_private(&file->prime);\n\n\tif (dev->driver->open) {\n\t\tret = dev->driver->open(dev, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_prime_destroy;\n\t}\n\n\treturn file;\n\nout_prime_destroy:\n\tdrm_prime_destroy_file_private(&file->prime);\n\tif (drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\tdrm_syncobj_release(file);\n\tif (drm_core_check_feature(dev, DRIVER_GEM))\n\t\tdrm_gem_release(dev, file);\n\tput_pid(rcu_access_pointer(file->pid));\n\tkfree(file);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void drm_events_release(struct drm_file *file_priv)\n{\n\tstruct drm_device *dev = file_priv->minor->dev;\n\tstruct drm_pending_event *e, *et;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t \n\tlist_for_each_entry_safe(e, et, &file_priv->pending_event_list,\n\t\t\t\t pending_link) {\n\t\tlist_del(&e->pending_link);\n\t\te->file_priv = NULL;\n\t}\n\n\t \n\tlist_for_each_entry_safe(e, et, &file_priv->event_list, link) {\n\t\tlist_del(&e->link);\n\t\tkfree(e);\n\t}\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\n \nvoid drm_file_free(struct drm_file *file)\n{\n\tstruct drm_device *dev;\n\n\tif (!file)\n\t\treturn;\n\n\tdev = file->minor->dev;\n\n\tdrm_dbg_core(dev, \"comm=\\\"%s\\\", pid=%d, dev=0x%lx, open_count=%d\\n\",\n\t\t     current->comm, task_pid_nr(current),\n\t\t     (long)old_encode_dev(file->minor->kdev->devt),\n\t\t     atomic_read(&dev->open_count));\n\n#ifdef CONFIG_DRM_LEGACY\n\tif (drm_core_check_feature(dev, DRIVER_LEGACY) &&\n\t    dev->driver->preclose)\n\t\tdev->driver->preclose(dev, file);\n#endif\n\n\tif (drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\tdrm_legacy_lock_release(dev, file->filp);\n\n\tif (drm_core_check_feature(dev, DRIVER_HAVE_DMA))\n\t\tdrm_legacy_reclaim_buffers(dev, file);\n\n\tdrm_events_release(file);\n\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tdrm_fb_release(file);\n\t\tdrm_property_destroy_user_blobs(dev, file);\n\t}\n\n\tif (drm_core_check_feature(dev, DRIVER_SYNCOBJ))\n\t\tdrm_syncobj_release(file);\n\n\tif (drm_core_check_feature(dev, DRIVER_GEM))\n\t\tdrm_gem_release(dev, file);\n\n\tdrm_legacy_ctxbitmap_flush(dev, file);\n\n\tif (drm_is_primary_client(file))\n\t\tdrm_master_release(file);\n\n\tif (dev->driver->postclose)\n\t\tdev->driver->postclose(dev, file);\n\n\tdrm_prime_destroy_file_private(&file->prime);\n\n\tWARN_ON(!list_empty(&file->event_list));\n\n\tput_pid(rcu_access_pointer(file->pid));\n\tkfree(file);\n}\n\nstatic void drm_close_helper(struct file *filp)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev = file_priv->minor->dev;\n\n\tmutex_lock(&dev->filelist_mutex);\n\tlist_del(&file_priv->lhead);\n\tmutex_unlock(&dev->filelist_mutex);\n\n\tdrm_file_free(file_priv);\n}\n\n \nstatic int drm_cpu_valid(void)\n{\n#if defined(__sparc__) && !defined(__sparc_v9__)\n\treturn 0;\t\t \n#endif\n\treturn 1;\n}\n\n \nint drm_open_helper(struct file *filp, struct drm_minor *minor)\n{\n\tstruct drm_device *dev = minor->dev;\n\tstruct drm_file *priv;\n\tint ret;\n\n\tif (filp->f_flags & O_EXCL)\n\t\treturn -EBUSY;\t \n\tif (!drm_cpu_valid())\n\t\treturn -EINVAL;\n\tif (dev->switch_power_state != DRM_SWITCH_POWER_ON &&\n\t    dev->switch_power_state != DRM_SWITCH_POWER_DYNAMIC_OFF)\n\t\treturn -EINVAL;\n\n\tdrm_dbg_core(dev, \"comm=\\\"%s\\\", pid=%d, minor=%d\\n\",\n\t\t     current->comm, task_pid_nr(current), minor->index);\n\n\tpriv = drm_file_alloc(minor);\n\tif (IS_ERR(priv))\n\t\treturn PTR_ERR(priv);\n\n\tif (drm_is_primary_client(priv)) {\n\t\tret = drm_master_open(priv);\n\t\tif (ret) {\n\t\t\tdrm_file_free(priv);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfilp->private_data = priv;\n\tfilp->f_mode |= FMODE_UNSIGNED_OFFSET;\n\tpriv->filp = filp;\n\n\tmutex_lock(&dev->filelist_mutex);\n\tlist_add(&priv->lhead, &dev->filelist);\n\tmutex_unlock(&dev->filelist_mutex);\n\n#ifdef CONFIG_DRM_LEGACY\n#ifdef __alpha__\n\t \n\tif (!dev->hose) {\n\t\tstruct pci_dev *pci_dev;\n\n\t\tpci_dev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);\n\t\tif (pci_dev) {\n\t\t\tdev->hose = pci_dev->sysdata;\n\t\t\tpci_dev_put(pci_dev);\n\t\t}\n\t\tif (!dev->hose) {\n\t\t\tstruct pci_bus *b = list_entry(pci_root_buses.next,\n\t\t\t\tstruct pci_bus, node);\n\t\t\tif (b)\n\t\t\t\tdev->hose = b->sysdata;\n\t\t}\n\t}\n#endif\n#endif\n\n\treturn 0;\n}\n\n \nint drm_open(struct inode *inode, struct file *filp)\n{\n\tstruct drm_device *dev;\n\tstruct drm_minor *minor;\n\tint retcode;\n\tint need_setup = 0;\n\n\tminor = drm_minor_acquire(iminor(inode));\n\tif (IS_ERR(minor))\n\t\treturn PTR_ERR(minor);\n\n\tdev = minor->dev;\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_lock(&drm_global_mutex);\n\n\tif (!atomic_fetch_inc(&dev->open_count))\n\t\tneed_setup = 1;\n\n\t \n\tfilp->f_mapping = dev->anon_inode->i_mapping;\n\n\tretcode = drm_open_helper(filp, minor);\n\tif (retcode)\n\t\tgoto err_undo;\n\tif (need_setup) {\n\t\tretcode = drm_legacy_setup(dev);\n\t\tif (retcode) {\n\t\t\tdrm_close_helper(filp);\n\t\t\tgoto err_undo;\n\t\t}\n\t}\n\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_unlock(&drm_global_mutex);\n\n\treturn 0;\n\nerr_undo:\n\tatomic_dec(&dev->open_count);\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_unlock(&drm_global_mutex);\n\tdrm_minor_release(minor);\n\treturn retcode;\n}\nEXPORT_SYMBOL(drm_open);\n\nvoid drm_lastclose(struct drm_device * dev)\n{\n\tdrm_dbg_core(dev, \"\\n\");\n\n\tif (dev->driver->lastclose)\n\t\tdev->driver->lastclose(dev);\n\tdrm_dbg_core(dev, \"driver lastclose completed\\n\");\n\n\tif (drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\tdrm_legacy_dev_reinit(dev);\n\n\tdrm_client_dev_restore(dev);\n}\n\n \nint drm_release(struct inode *inode, struct file *filp)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_minor *minor = file_priv->minor;\n\tstruct drm_device *dev = minor->dev;\n\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_lock(&drm_global_mutex);\n\n\tdrm_dbg_core(dev, \"open_count = %d\\n\", atomic_read(&dev->open_count));\n\n\tdrm_close_helper(filp);\n\n\tif (atomic_dec_and_test(&dev->open_count))\n\t\tdrm_lastclose(dev);\n\n\tif (drm_dev_needs_global_mutex(dev))\n\t\tmutex_unlock(&drm_global_mutex);\n\n\tdrm_minor_release(minor);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_release);\n\nvoid drm_file_update_pid(struct drm_file *filp)\n{\n\tstruct drm_device *dev;\n\tstruct pid *pid, *old;\n\n\t \n\tif (filp->was_master)\n\t\treturn;\n\n\tpid = task_tgid(current);\n\n\t \n\tif (pid == rcu_access_pointer(filp->pid))\n\t\treturn;\n\n\tdev = filp->minor->dev;\n\tmutex_lock(&dev->filelist_mutex);\n\told = rcu_replace_pointer(filp->pid, pid, 1);\n\tmutex_unlock(&dev->filelist_mutex);\n\n\tif (pid != old) {\n\t\tget_pid(pid);\n\t\tsynchronize_rcu();\n\t\tput_pid(old);\n\t}\n}\n\n \nint drm_release_noglobal(struct inode *inode, struct file *filp)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_minor *minor = file_priv->minor;\n\tstruct drm_device *dev = minor->dev;\n\n\tdrm_close_helper(filp);\n\n\tif (atomic_dec_and_mutex_lock(&dev->open_count, &drm_global_mutex)) {\n\t\tdrm_lastclose(dev);\n\t\tmutex_unlock(&drm_global_mutex);\n\t}\n\n\tdrm_minor_release(minor);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_release_noglobal);\n\n \nssize_t drm_read(struct file *filp, char __user *buffer,\n\t\t size_t count, loff_t *offset)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\tstruct drm_device *dev = file_priv->minor->dev;\n\tssize_t ret;\n\n\tret = mutex_lock_interruptible(&file_priv->event_read_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (;;) {\n\t\tstruct drm_pending_event *e = NULL;\n\n\t\tspin_lock_irq(&dev->event_lock);\n\t\tif (!list_empty(&file_priv->event_list)) {\n\t\t\te = list_first_entry(&file_priv->event_list,\n\t\t\t\t\tstruct drm_pending_event, link);\n\t\t\tfile_priv->event_space += e->event->length;\n\t\t\tlist_del(&e->link);\n\t\t}\n\t\tspin_unlock_irq(&dev->event_lock);\n\n\t\tif (e == NULL) {\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&file_priv->event_read_lock);\n\t\t\tret = wait_event_interruptible(file_priv->event_wait,\n\t\t\t\t\t\t       !list_empty(&file_priv->event_list));\n\t\t\tif (ret >= 0)\n\t\t\t\tret = mutex_lock_interruptible(&file_priv->event_read_lock);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tunsigned length = e->event->length;\n\n\t\t\tif (length > count - ret) {\nput_back_event:\n\t\t\t\tspin_lock_irq(&dev->event_lock);\n\t\t\t\tfile_priv->event_space -= length;\n\t\t\t\tlist_add(&e->link, &file_priv->event_list);\n\t\t\t\tspin_unlock_irq(&dev->event_lock);\n\t\t\t\twake_up_interruptible_poll(&file_priv->event_wait,\n\t\t\t\t\tEPOLLIN | EPOLLRDNORM);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (copy_to_user(buffer + ret, e->event, length)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto put_back_event;\n\t\t\t}\n\n\t\t\tret += length;\n\t\t\tkfree(e);\n\t\t}\n\t}\n\tmutex_unlock(&file_priv->event_read_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_read);\n\n \n__poll_t drm_poll(struct file *filp, struct poll_table_struct *wait)\n{\n\tstruct drm_file *file_priv = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &file_priv->event_wait, wait);\n\n\tif (!list_empty(&file_priv->event_list))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\treturn mask;\n}\nEXPORT_SYMBOL(drm_poll);\n\n \nint drm_event_reserve_init_locked(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t  struct drm_pending_event *p,\n\t\t\t\t  struct drm_event *e)\n{\n\tif (file_priv->event_space < e->length)\n\t\treturn -ENOMEM;\n\n\tfile_priv->event_space -= e->length;\n\n\tp->event = e;\n\tlist_add(&p->pending_link, &file_priv->pending_event_list);\n\tp->file_priv = file_priv;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_event_reserve_init_locked);\n\n \nint drm_event_reserve_init(struct drm_device *dev,\n\t\t\t   struct drm_file *file_priv,\n\t\t\t   struct drm_pending_event *p,\n\t\t\t   struct drm_event *e)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tret = drm_event_reserve_init_locked(dev, file_priv, p, e);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_event_reserve_init);\n\n \nvoid drm_event_cancel_free(struct drm_device *dev,\n\t\t\t   struct drm_pending_event *p)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tif (p->file_priv) {\n\t\tp->file_priv->event_space += p->event->length;\n\t\tlist_del(&p->pending_link);\n\t}\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\tif (p->fence)\n\t\tdma_fence_put(p->fence);\n\n\tkfree(p);\n}\nEXPORT_SYMBOL(drm_event_cancel_free);\n\nstatic void drm_send_event_helper(struct drm_device *dev,\n\t\t\t   struct drm_pending_event *e, ktime_t timestamp)\n{\n\tassert_spin_locked(&dev->event_lock);\n\n\tif (e->completion) {\n\t\tcomplete_all(e->completion);\n\t\te->completion_release(e->completion);\n\t\te->completion = NULL;\n\t}\n\n\tif (e->fence) {\n\t\tif (timestamp)\n\t\t\tdma_fence_signal_timestamp(e->fence, timestamp);\n\t\telse\n\t\t\tdma_fence_signal(e->fence);\n\t\tdma_fence_put(e->fence);\n\t}\n\n\tif (!e->file_priv) {\n\t\tkfree(e);\n\t\treturn;\n\t}\n\n\tlist_del(&e->pending_link);\n\tlist_add_tail(&e->link,\n\t\t      &e->file_priv->event_list);\n\twake_up_interruptible_poll(&e->file_priv->event_wait,\n\t\tEPOLLIN | EPOLLRDNORM);\n}\n\n \nvoid drm_send_event_timestamp_locked(struct drm_device *dev,\n\t\t\t\t     struct drm_pending_event *e, ktime_t timestamp)\n{\n\tdrm_send_event_helper(dev, e, timestamp);\n}\nEXPORT_SYMBOL(drm_send_event_timestamp_locked);\n\n \nvoid drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e)\n{\n\tdrm_send_event_helper(dev, e, 0);\n}\nEXPORT_SYMBOL(drm_send_event_locked);\n\n \nvoid drm_send_event(struct drm_device *dev, struct drm_pending_event *e)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev->event_lock, irqflags);\n\tdrm_send_event_helper(dev, e, 0);\n\tspin_unlock_irqrestore(&dev->event_lock, irqflags);\n}\nEXPORT_SYMBOL(drm_send_event);\n\nstatic void print_size(struct drm_printer *p, const char *stat,\n\t\t       const char *region, u64 sz)\n{\n\tconst char *units[] = {\"\", \" KiB\", \" MiB\"};\n\tunsigned u;\n\n\tfor (u = 0; u < ARRAY_SIZE(units) - 1; u++) {\n\t\tif (sz < SZ_1K)\n\t\t\tbreak;\n\t\tsz = div_u64(sz, SZ_1K);\n\t}\n\n\tdrm_printf(p, \"drm-%s-%s:\\t%llu%s\\n\", stat, region, sz, units[u]);\n}\n\n \nvoid drm_print_memory_stats(struct drm_printer *p,\n\t\t\t    const struct drm_memory_stats *stats,\n\t\t\t    enum drm_gem_object_status supported_status,\n\t\t\t    const char *region)\n{\n\tprint_size(p, \"total\", region, stats->private + stats->shared);\n\tprint_size(p, \"shared\", region, stats->shared);\n\tprint_size(p, \"active\", region, stats->active);\n\n\tif (supported_status & DRM_GEM_OBJECT_RESIDENT)\n\t\tprint_size(p, \"resident\", region, stats->resident);\n\n\tif (supported_status & DRM_GEM_OBJECT_PURGEABLE)\n\t\tprint_size(p, \"purgeable\", region, stats->purgeable);\n}\nEXPORT_SYMBOL(drm_print_memory_stats);\n\n \nvoid drm_show_memory_stats(struct drm_printer *p, struct drm_file *file)\n{\n\tstruct drm_gem_object *obj;\n\tstruct drm_memory_stats status = {};\n\tenum drm_gem_object_status supported_status;\n\tint id;\n\n\tspin_lock(&file->table_lock);\n\tidr_for_each_entry (&file->object_idr, obj, id) {\n\t\tenum drm_gem_object_status s = 0;\n\n\t\tif (obj->funcs && obj->funcs->status) {\n\t\t\ts = obj->funcs->status(obj);\n\t\t\tsupported_status = DRM_GEM_OBJECT_RESIDENT |\n\t\t\t\t\tDRM_GEM_OBJECT_PURGEABLE;\n\t\t}\n\n\t\tif (obj->handle_count > 1) {\n\t\t\tstatus.shared += obj->size;\n\t\t} else {\n\t\t\tstatus.private += obj->size;\n\t\t}\n\n\t\tif (s & DRM_GEM_OBJECT_RESIDENT) {\n\t\t\tstatus.resident += obj->size;\n\t\t} else {\n\t\t\t \n\t\t\ts &= ~DRM_GEM_OBJECT_PURGEABLE;\n\t\t}\n\n\t\tif (!dma_resv_test_signaled(obj->resv, dma_resv_usage_rw(true))) {\n\t\t\tstatus.active += obj->size;\n\n\t\t\t \n\t\t\ts &= ~DRM_GEM_OBJECT_PURGEABLE;\n\t\t}\n\n\t\tif (s & DRM_GEM_OBJECT_PURGEABLE)\n\t\t\tstatus.purgeable += obj->size;\n\t}\n\tspin_unlock(&file->table_lock);\n\n\tdrm_print_memory_stats(p, &status, supported_status, \"memory\");\n}\nEXPORT_SYMBOL(drm_show_memory_stats);\n\n \nvoid drm_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct drm_file *file = f->private_data;\n\tstruct drm_device *dev = file->minor->dev;\n\tstruct drm_printer p = drm_seq_file_printer(m);\n\n\tdrm_printf(&p, \"drm-driver:\\t%s\\n\", dev->driver->name);\n\tdrm_printf(&p, \"drm-client-id:\\t%llu\\n\", file->client_id);\n\n\tif (dev_is_pci(dev->dev)) {\n\t\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\t\tdrm_printf(&p, \"drm-pdev:\\t%04x:%02x:%02x.%d\\n\",\n\t\t\t   pci_domain_nr(pdev->bus), pdev->bus->number,\n\t\t\t   PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\n\t}\n\n\tif (dev->driver->show_fdinfo)\n\t\tdev->driver->show_fdinfo(&p, file);\n}\nEXPORT_SYMBOL(drm_show_fdinfo);\n\n \nstruct file *mock_drm_getfile(struct drm_minor *minor, unsigned int flags)\n{\n\tstruct drm_device *dev = minor->dev;\n\tstruct drm_file *priv;\n\tstruct file *file;\n\n\tpriv = drm_file_alloc(minor);\n\tif (IS_ERR(priv))\n\t\treturn ERR_CAST(priv);\n\n\tfile = anon_inode_getfile(\"drm\", dev->driver->fops, priv, flags);\n\tif (IS_ERR(file)) {\n\t\tdrm_file_free(priv);\n\t\treturn file;\n\t}\n\n\t \n\tfile->f_mapping = dev->anon_inode->i_mapping;\n\n\tdrm_dev_get(dev);\n\tpriv->filp = file;\n\n\treturn file;\n}\nEXPORT_SYMBOL_FOR_TESTS_ONLY(mock_drm_getfile);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}