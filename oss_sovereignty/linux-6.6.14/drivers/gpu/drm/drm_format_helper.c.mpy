{
  "module_name": "drm_format_helper.c",
  "hash_id": "65c261287b7416124bbac821378193bb4ef0ef1a94b8d49266dc6f7ce5cd619d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_format_helper.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iosys-map.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <drm/drm_device.h>\n#include <drm/drm_format_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_print.h>\n#include <drm/drm_rect.h>\n\nstatic unsigned int clip_offset(const struct drm_rect *clip, unsigned int pitch, unsigned int cpp)\n{\n\treturn clip->y1 * pitch + clip->x1 * cpp;\n}\n\n \nunsigned int drm_fb_clip_offset(unsigned int pitch, const struct drm_format_info *format,\n\t\t\t\tconst struct drm_rect *clip)\n{\n\treturn clip_offset(clip, pitch, format->cpp[0]);\n}\nEXPORT_SYMBOL(drm_fb_clip_offset);\n\n \nstatic int __drm_fb_xfrm(void *dst, unsigned long dst_pitch, unsigned long dst_pixsize,\n\t\t\t const void *vaddr, const struct drm_framebuffer *fb,\n\t\t\t const struct drm_rect *clip, bool vaddr_cached_hint,\n\t\t\t void (*xfrm_line)(void *dbuf, const void *sbuf, unsigned int npixels))\n{\n\tunsigned long linepixels = drm_rect_width(clip);\n\tunsigned long lines = drm_rect_height(clip);\n\tsize_t sbuf_len = linepixels * fb->format->cpp[0];\n\tvoid *stmp = NULL;\n\tunsigned long i;\n\tconst void *sbuf;\n\n\t \n\tif (!vaddr_cached_hint) {\n\t\tstmp = kmalloc(sbuf_len, GFP_KERNEL);\n\t\tif (!stmp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!dst_pitch)\n\t\tdst_pitch = drm_rect_width(clip) * dst_pixsize;\n\tvaddr += clip_offset(clip, fb->pitches[0], fb->format->cpp[0]);\n\n\tfor (i = 0; i < lines; ++i) {\n\t\tif (stmp)\n\t\t\tsbuf = memcpy(stmp, vaddr, sbuf_len);\n\t\telse\n\t\t\tsbuf = vaddr;\n\t\txfrm_line(dst, sbuf, linepixels);\n\t\tvaddr += fb->pitches[0];\n\t\tdst += dst_pitch;\n\t}\n\n\tkfree(stmp);\n\n\treturn 0;\n}\n\n \nstatic int __drm_fb_xfrm_toio(void __iomem *dst, unsigned long dst_pitch, unsigned long dst_pixsize,\n\t\t\t      const void *vaddr, const struct drm_framebuffer *fb,\n\t\t\t      const struct drm_rect *clip, bool vaddr_cached_hint,\n\t\t\t      void (*xfrm_line)(void *dbuf, const void *sbuf, unsigned int npixels))\n{\n\tunsigned long linepixels = drm_rect_width(clip);\n\tunsigned long lines = drm_rect_height(clip);\n\tsize_t dbuf_len = linepixels * dst_pixsize;\n\tsize_t stmp_off = round_up(dbuf_len, ARCH_KMALLOC_MINALIGN);  \n\tsize_t sbuf_len = linepixels * fb->format->cpp[0];\n\tvoid *stmp = NULL;\n\tunsigned long i;\n\tconst void *sbuf;\n\tvoid *dbuf;\n\n\tif (vaddr_cached_hint) {\n\t\tdbuf = kmalloc(dbuf_len, GFP_KERNEL);\n\t} else {\n\t\tdbuf = kmalloc(stmp_off + sbuf_len, GFP_KERNEL);\n\t\tstmp = dbuf + stmp_off;\n\t}\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tif (!dst_pitch)\n\t\tdst_pitch = linepixels * dst_pixsize;\n\tvaddr += clip_offset(clip, fb->pitches[0], fb->format->cpp[0]);\n\n\tfor (i = 0; i < lines; ++i) {\n\t\tif (stmp)\n\t\t\tsbuf = memcpy(stmp, vaddr, sbuf_len);\n\t\telse\n\t\t\tsbuf = vaddr;\n\t\txfrm_line(dbuf, sbuf, linepixels);\n\t\tmemcpy_toio(dst, dbuf, dbuf_len);\n\t\tvaddr += fb->pitches[0];\n\t\tdst += dst_pitch;\n\t}\n\n\tkfree(dbuf);\n\n\treturn 0;\n}\n\n \nstatic int drm_fb_xfrm(struct iosys_map *dst,\n\t\t       const unsigned int *dst_pitch, const u8 *dst_pixsize,\n\t\t       const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t       const struct drm_rect *clip, bool vaddr_cached_hint,\n\t\t       void (*xfrm_line)(void *dbuf, const void *sbuf, unsigned int npixels))\n{\n\tstatic const unsigned int default_dst_pitch[DRM_FORMAT_MAX_PLANES] = {\n\t\t0, 0, 0, 0\n\t};\n\n\tif (!dst_pitch)\n\t\tdst_pitch = default_dst_pitch;\n\n\t \n\tif (dst[0].is_iomem)\n\t\treturn __drm_fb_xfrm_toio(dst[0].vaddr_iomem, dst_pitch[0], dst_pixsize[0],\n\t\t\t\t\t  src[0].vaddr, fb, clip, vaddr_cached_hint, xfrm_line);\n\telse\n\t\treturn __drm_fb_xfrm(dst[0].vaddr, dst_pitch[0], dst_pixsize[0],\n\t\t\t\t     src[0].vaddr, fb, clip, vaddr_cached_hint, xfrm_line);\n}\n\n \nvoid drm_fb_memcpy(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t   const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t   const struct drm_rect *clip)\n{\n\tstatic const unsigned int default_dst_pitch[DRM_FORMAT_MAX_PLANES] = {\n\t\t0, 0, 0, 0\n\t};\n\n\tconst struct drm_format_info *format = fb->format;\n\tunsigned int i, y, lines = drm_rect_height(clip);\n\n\tif (!dst_pitch)\n\t\tdst_pitch = default_dst_pitch;\n\n\tfor (i = 0; i < format->num_planes; ++i) {\n\t\tunsigned int bpp_i = drm_format_info_bpp(format, i);\n\t\tunsigned int cpp_i = DIV_ROUND_UP(bpp_i, 8);\n\t\tsize_t len_i = DIV_ROUND_UP(drm_rect_width(clip) * bpp_i, 8);\n\t\tunsigned int dst_pitch_i = dst_pitch[i];\n\t\tstruct iosys_map dst_i = dst[i];\n\t\tstruct iosys_map src_i = src[i];\n\n\t\tif (!dst_pitch_i)\n\t\t\tdst_pitch_i = len_i;\n\n\t\tiosys_map_incr(&src_i, clip_offset(clip, fb->pitches[i], cpp_i));\n\t\tfor (y = 0; y < lines; y++) {\n\t\t\t \n\t\t\tiosys_map_memcpy_to(&dst_i, 0, src_i.vaddr, len_i);\n\t\t\tiosys_map_incr(&src_i, fb->pitches[i]);\n\t\t\tiosys_map_incr(&dst_i, dst_pitch_i);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_fb_memcpy);\n\nstatic void drm_fb_swab16_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\tu16 *dbuf16 = dbuf;\n\tconst u16 *sbuf16 = sbuf;\n\tconst u16 *send16 = sbuf16 + pixels;\n\n\twhile (sbuf16 < send16)\n\t\t*dbuf16++ = swab16(*sbuf16++);\n}\n\nstatic void drm_fb_swab32_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\tu32 *dbuf32 = dbuf;\n\tconst u32 *sbuf32 = sbuf;\n\tconst u32 *send32 = sbuf32 + pixels;\n\n\twhile (sbuf32 < send32)\n\t\t*dbuf32++ = swab32(*sbuf32++);\n}\n\n \nvoid drm_fb_swab(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t const struct drm_rect *clip, bool cached)\n{\n\tconst struct drm_format_info *format = fb->format;\n\tu8 cpp = DIV_ROUND_UP(drm_format_info_bpp(format, 0), 8);\n\tvoid (*swab_line)(void *dbuf, const void *sbuf, unsigned int npixels);\n\n\tswitch (cpp) {\n\tcase 4:\n\t\tswab_line = drm_fb_swab32_line;\n\t\tbreak;\n\tcase 2:\n\t\tswab_line = drm_fb_swab16_line;\n\t\tbreak;\n\tdefault:\n\t\tdrm_warn_once(fb->dev, \"Format %p4cc has unsupported pixel size.\\n\",\n\t\t\t      &format->format);\n\t\treturn;\n\t}\n\n\tdrm_fb_xfrm(dst, dst_pitch, &cpp, src, fb, clip, cached, swab_line);\n}\nEXPORT_SYMBOL(drm_fb_swab);\n\nstatic void drm_fb_xrgb8888_to_rgb332_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\tu8 *dbuf8 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tdbuf8[x] = ((pix & 0x00e00000) >> 16) |\n\t\t\t   ((pix & 0x0000e000) >> 11) |\n\t\t\t   ((pix & 0x000000c0) >> 6);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_rgb332(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t       const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t       const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t1,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_rgb332_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_rgb332);\n\nstatic void drm_fb_xrgb8888_to_rgb565_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le16 *dbuf16 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu16 val16;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval16 = ((pix & 0x00F80000) >> 8) |\n\t\t\t((pix & 0x0000FC00) >> 5) |\n\t\t\t((pix & 0x000000F8) >> 3);\n\t\tdbuf16[x] = cpu_to_le16(val16);\n\t}\n}\n\n \nstatic void drm_fb_xrgb8888_to_rgb565_swab_line(void *dbuf, const void *sbuf,\n\t\t\t\t\t\tunsigned int pixels)\n{\n\t__le16 *dbuf16 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu16 val16;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval16 = ((pix & 0x00F80000) >> 8) |\n\t\t\t((pix & 0x0000FC00) >> 5) |\n\t\t\t((pix & 0x000000F8) >> 3);\n\t\tdbuf16[x] = cpu_to_le16(swab16(val16));\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_rgb565(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t       const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t       const struct drm_rect *clip, bool swab)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t2,\n\t};\n\n\tvoid (*xfrm_line)(void *dbuf, const void *sbuf, unsigned int npixels);\n\n\tif (swab)\n\t\txfrm_line = drm_fb_xrgb8888_to_rgb565_swab_line;\n\telse\n\t\txfrm_line = drm_fb_xrgb8888_to_rgb565_line;\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false, xfrm_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_rgb565);\n\nstatic void drm_fb_xrgb8888_to_xrgb1555_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le16 *dbuf16 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu16 val16;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval16 = ((pix & 0x00f80000) >> 9) |\n\t\t\t((pix & 0x0000f800) >> 6) |\n\t\t\t((pix & 0x000000f8) >> 3);\n\t\tdbuf16[x] = cpu_to_le16(val16);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_xrgb1555(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t\t const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t2,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_xrgb1555_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_xrgb1555);\n\nstatic void drm_fb_xrgb8888_to_argb1555_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le16 *dbuf16 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu16 val16;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval16 = BIT(15) |  \n\t\t\t((pix & 0x00f80000) >> 9) |\n\t\t\t((pix & 0x0000f800) >> 6) |\n\t\t\t((pix & 0x000000f8) >> 3);\n\t\tdbuf16[x] = cpu_to_le16(val16);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_argb1555(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t\t const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t2,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_argb1555_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_argb1555);\n\nstatic void drm_fb_xrgb8888_to_rgba5551_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le16 *dbuf16 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu16 val16;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval16 = ((pix & 0x00f80000) >> 8) |\n\t\t\t((pix & 0x0000f800) >> 5) |\n\t\t\t((pix & 0x000000f8) >> 2) |\n\t\t\tBIT(0);  \n\t\tdbuf16[x] = cpu_to_le16(val16);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_rgba5551(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t\t const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t2,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_rgba5551_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_rgba5551);\n\nstatic void drm_fb_xrgb8888_to_rgb888_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\tu8 *dbuf8 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\t \n\t\t*dbuf8++ = (pix & 0x000000FF) >>  0;\n\t\t*dbuf8++ = (pix & 0x0000FF00) >>  8;\n\t\t*dbuf8++ = (pix & 0x00FF0000) >> 16;\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_rgb888(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t       const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t       const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t3,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_rgb888_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_rgb888);\n\nstatic void drm_fb_xrgb8888_to_argb8888_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le32 *dbuf32 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tpix |= GENMASK(31, 24);  \n\t\tdbuf32[x] = cpu_to_le32(pix);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_argb8888(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t\t const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t4,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_argb8888_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_argb8888);\n\nstatic void drm_fb_xrgb8888_to_abgr8888_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le32 *dbuf32 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tpix = ((pix & 0x00ff0000) >> 16) <<  0 |\n\t\t      ((pix & 0x0000ff00) >>  8) <<  8 |\n\t\t      ((pix & 0x000000ff) >>  0) << 16 |\n\t\t      GENMASK(31, 24);  \n\t\t*dbuf32++ = cpu_to_le32(pix);\n\t}\n}\n\nstatic void drm_fb_xrgb8888_to_abgr8888(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t\tconst struct iosys_map *src,\n\t\t\t\t\tconst struct drm_framebuffer *fb,\n\t\t\t\t\tconst struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t4,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_abgr8888_line);\n}\n\nstatic void drm_fb_xrgb8888_to_xbgr8888_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le32 *dbuf32 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tpix = ((pix & 0x00ff0000) >> 16) <<  0 |\n\t\t      ((pix & 0x0000ff00) >>  8) <<  8 |\n\t\t      ((pix & 0x000000ff) >>  0) << 16 |\n\t\t      ((pix & 0xff000000) >> 24) << 24;\n\t\t*dbuf32++ = cpu_to_le32(pix);\n\t}\n}\n\nstatic void drm_fb_xrgb8888_to_xbgr8888(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t\tconst struct iosys_map *src,\n\t\t\t\t\tconst struct drm_framebuffer *fb,\n\t\t\t\t\tconst struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t4,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_xbgr8888_line);\n}\n\nstatic void drm_fb_xrgb8888_to_xrgb2101010_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le32 *dbuf32 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 val32;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval32 = ((pix & 0x000000FF) << 2) |\n\t\t\t((pix & 0x0000FF00) << 4) |\n\t\t\t((pix & 0x00FF0000) << 6);\n\t\tpix = val32 | ((val32 >> 8) & 0x00300C03);\n\t\t*dbuf32++ = cpu_to_le32(pix);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_xrgb2101010(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t    const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t\t    const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t4,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_xrgb2101010_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_xrgb2101010);\n\nstatic void drm_fb_xrgb8888_to_argb2101010_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\t__le32 *dbuf32 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\tu32 val32;\n\tu32 pix;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tpix = le32_to_cpu(sbuf32[x]);\n\t\tval32 = ((pix & 0x000000ff) << 2) |\n\t\t\t((pix & 0x0000ff00) << 4) |\n\t\t\t((pix & 0x00ff0000) << 6);\n\t\tpix = GENMASK(31, 30) |  \n\t\t      val32 | ((val32 >> 8) & 0x00300c03);\n\t\t*dbuf32++ = cpu_to_le32(pix);\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_argb2101010(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t\t    const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t\t    const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t4,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_argb2101010_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_argb2101010);\n\nstatic void drm_fb_xrgb8888_to_gray8_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\tu8 *dbuf8 = dbuf;\n\tconst __le32 *sbuf32 = sbuf;\n\tunsigned int x;\n\n\tfor (x = 0; x < pixels; x++) {\n\t\tu32 pix = le32_to_cpu(sbuf32[x]);\n\t\tu8 r = (pix & 0x00ff0000) >> 16;\n\t\tu8 g = (pix & 0x0000ff00) >> 8;\n\t\tu8 b =  pix & 0x000000ff;\n\n\t\t \n\t\t*dbuf8++ = (3 * r + 6 * g + b) / 10;\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_gray8(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t      const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t      const struct drm_rect *clip)\n{\n\tstatic const u8 dst_pixsize[DRM_FORMAT_MAX_PLANES] = {\n\t\t1,\n\t};\n\n\tdrm_fb_xfrm(dst, dst_pitch, dst_pixsize, src, fb, clip, false,\n\t\t    drm_fb_xrgb8888_to_gray8_line);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_gray8);\n\n \nint drm_fb_blit(struct iosys_map *dst, const unsigned int *dst_pitch, uint32_t dst_format,\n\t\tconst struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\tconst struct drm_rect *clip)\n{\n\tuint32_t fb_format = fb->format->format;\n\n\tif (fb_format == dst_format) {\n\t\tdrm_fb_memcpy(dst, dst_pitch, src, fb, clip);\n\t\treturn 0;\n\t} else if (fb_format == (dst_format | DRM_FORMAT_BIG_ENDIAN)) {\n\t\tdrm_fb_swab(dst, dst_pitch, src, fb, clip, false);\n\t\treturn 0;\n\t} else if (fb_format == (dst_format & ~DRM_FORMAT_BIG_ENDIAN)) {\n\t\tdrm_fb_swab(dst, dst_pitch, src, fb, clip, false);\n\t\treturn 0;\n\t} else if (fb_format == DRM_FORMAT_XRGB8888) {\n\t\tif (dst_format == DRM_FORMAT_RGB565) {\n\t\t\tdrm_fb_xrgb8888_to_rgb565(dst, dst_pitch, src, fb, clip, false);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_XRGB1555) {\n\t\t\tdrm_fb_xrgb8888_to_xrgb1555(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_ARGB1555) {\n\t\t\tdrm_fb_xrgb8888_to_argb1555(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_RGBA5551) {\n\t\t\tdrm_fb_xrgb8888_to_rgba5551(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_RGB888) {\n\t\t\tdrm_fb_xrgb8888_to_rgb888(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_ARGB8888) {\n\t\t\tdrm_fb_xrgb8888_to_argb8888(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_XBGR8888) {\n\t\t\tdrm_fb_xrgb8888_to_xbgr8888(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_ABGR8888) {\n\t\t\tdrm_fb_xrgb8888_to_abgr8888(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_XRGB2101010) {\n\t\t\tdrm_fb_xrgb8888_to_xrgb2101010(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_ARGB2101010) {\n\t\t\tdrm_fb_xrgb8888_to_argb2101010(dst, dst_pitch, src, fb, clip);\n\t\t\treturn 0;\n\t\t} else if (dst_format == DRM_FORMAT_BGRX8888) {\n\t\t\tdrm_fb_swab(dst, dst_pitch, src, fb, clip, false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdrm_warn_once(fb->dev, \"No conversion helper from %p4cc to %p4cc found.\\n\",\n\t\t      &fb_format, &dst_format);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_fb_blit);\n\nstatic void drm_fb_gray8_to_mono_line(void *dbuf, const void *sbuf, unsigned int pixels)\n{\n\tu8 *dbuf8 = dbuf;\n\tconst u8 *sbuf8 = sbuf;\n\n\twhile (pixels) {\n\t\tunsigned int i, bits = min(pixels, 8U);\n\t\tu8 byte = 0;\n\n\t\tfor (i = 0; i < bits; i++, pixels--) {\n\t\t\tif (*sbuf8++ >= 128)\n\t\t\t\tbyte |= BIT(i);\n\t\t}\n\t\t*dbuf8++ = byte;\n\t}\n}\n\n \nvoid drm_fb_xrgb8888_to_mono(struct iosys_map *dst, const unsigned int *dst_pitch,\n\t\t\t     const struct iosys_map *src, const struct drm_framebuffer *fb,\n\t\t\t     const struct drm_rect *clip)\n{\n\tstatic const unsigned int default_dst_pitch[DRM_FORMAT_MAX_PLANES] = {\n\t\t0, 0, 0, 0\n\t};\n\tunsigned int linepixels = drm_rect_width(clip);\n\tunsigned int lines = drm_rect_height(clip);\n\tunsigned int cpp = fb->format->cpp[0];\n\tunsigned int len_src32 = linepixels * cpp;\n\tstruct drm_device *dev = fb->dev;\n\tvoid *vaddr = src[0].vaddr;\n\tunsigned int dst_pitch_0;\n\tunsigned int y;\n\tu8 *mono = dst[0].vaddr, *gray8;\n\tu32 *src32;\n\n\tif (drm_WARN_ON(dev, fb->format->format != DRM_FORMAT_XRGB8888))\n\t\treturn;\n\n\tif (!dst_pitch)\n\t\tdst_pitch = default_dst_pitch;\n\tdst_pitch_0 = dst_pitch[0];\n\n\t \n\tif (!dst_pitch_0)\n\t\tdst_pitch_0 = DIV_ROUND_UP(linepixels, 8);\n\n\t \n\tsrc32 = kmalloc(len_src32 + linepixels, GFP_KERNEL);\n\tif (!src32)\n\t\treturn;\n\n\tgray8 = (u8 *)src32 + len_src32;\n\n\tvaddr += clip_offset(clip, fb->pitches[0], cpp);\n\tfor (y = 0; y < lines; y++) {\n\t\tsrc32 = memcpy(src32, vaddr, len_src32);\n\t\tdrm_fb_xrgb8888_to_gray8_line(gray8, src32, linepixels);\n\t\tdrm_fb_gray8_to_mono_line(mono, gray8, linepixels);\n\t\tvaddr += fb->pitches[0];\n\t\tmono += dst_pitch_0;\n\t}\n\n\tkfree(src32);\n}\nEXPORT_SYMBOL(drm_fb_xrgb8888_to_mono);\n\nstatic uint32_t drm_fb_nonalpha_fourcc(uint32_t fourcc)\n{\n\t \n\tswitch (fourcc) {\n\tcase DRM_FORMAT_ARGB1555:\n\t\treturn DRM_FORMAT_XRGB1555;\n\tcase DRM_FORMAT_ABGR1555:\n\t\treturn DRM_FORMAT_XBGR1555;\n\tcase DRM_FORMAT_RGBA5551:\n\t\treturn DRM_FORMAT_RGBX5551;\n\tcase DRM_FORMAT_BGRA5551:\n\t\treturn DRM_FORMAT_BGRX5551;\n\tcase DRM_FORMAT_ARGB8888:\n\t\treturn DRM_FORMAT_XRGB8888;\n\tcase DRM_FORMAT_ABGR8888:\n\t\treturn DRM_FORMAT_XBGR8888;\n\tcase DRM_FORMAT_RGBA8888:\n\t\treturn DRM_FORMAT_RGBX8888;\n\tcase DRM_FORMAT_BGRA8888:\n\t\treturn DRM_FORMAT_BGRX8888;\n\tcase DRM_FORMAT_ARGB2101010:\n\t\treturn DRM_FORMAT_XRGB2101010;\n\tcase DRM_FORMAT_ABGR2101010:\n\t\treturn DRM_FORMAT_XBGR2101010;\n\tcase DRM_FORMAT_RGBA1010102:\n\t\treturn DRM_FORMAT_RGBX1010102;\n\tcase DRM_FORMAT_BGRA1010102:\n\t\treturn DRM_FORMAT_BGRX1010102;\n\t}\n\n\treturn fourcc;\n}\n\nstatic bool is_listed_fourcc(const uint32_t *fourccs, size_t nfourccs, uint32_t fourcc)\n{\n\tconst uint32_t *fourccs_end = fourccs + nfourccs;\n\n\twhile (fourccs < fourccs_end) {\n\t\tif (*fourccs == fourcc)\n\t\t\treturn true;\n\t\t++fourccs;\n\t}\n\treturn false;\n}\n\n \nsize_t drm_fb_build_fourcc_list(struct drm_device *dev,\n\t\t\t\tconst u32 *native_fourccs, size_t native_nfourccs,\n\t\t\t\tu32 *fourccs_out, size_t nfourccs_out)\n{\n\t \n\tstatic const uint32_t extra_fourccs[] = {\n\t\tDRM_FORMAT_XRGB8888,\n\t};\n\tstatic const size_t extra_nfourccs = ARRAY_SIZE(extra_fourccs);\n\n\tu32 *fourccs = fourccs_out;\n\tconst u32 *fourccs_end = fourccs_out + nfourccs_out;\n\tsize_t i;\n\n\t \n\n\tfor (i = 0; i < native_nfourccs; ++i) {\n\t\t \n\t\tu32 fourcc = drm_fb_nonalpha_fourcc(native_fourccs[i]);\n\n\t\tif (is_listed_fourcc(fourccs_out, fourccs - fourccs_out, fourcc)) {\n\t\t\tcontinue;  \n\t\t} else if (fourccs == fourccs_end) {\n\t\t\tdrm_warn(dev, \"Ignoring native format %p4cc\\n\", &fourcc);\n\t\t\tcontinue;  \n\t\t}\n\n\t\tdrm_dbg_kms(dev, \"adding native format %p4cc\\n\", &fourcc);\n\n\t\t*fourccs = fourcc;\n\t\t++fourccs;\n\t}\n\n\t \n\n\tfor (i = 0; (i < extra_nfourccs) && (fourccs < fourccs_end); ++i) {\n\t\tu32 fourcc = extra_fourccs[i];\n\n\t\tif (is_listed_fourcc(fourccs_out, fourccs - fourccs_out, fourcc)) {\n\t\t\tcontinue;  \n\t\t} else if (fourccs == fourccs_end) {\n\t\t\tdrm_warn(dev, \"Ignoring emulated format %p4cc\\n\", &fourcc);\n\t\t\tcontinue;  \n\t\t}\n\n\t\tdrm_dbg_kms(dev, \"adding emulated format %p4cc\\n\", &fourcc);\n\n\t\t*fourccs = fourcc;\n\t\t++fourccs;\n\t}\n\n\treturn fourccs - fourccs_out;\n}\nEXPORT_SYMBOL(drm_fb_build_fourcc_list);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}