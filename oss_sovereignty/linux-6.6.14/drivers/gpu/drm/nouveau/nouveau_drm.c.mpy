{
  "module_name": "nouveau_drm.c",
  "hash_id": "65805c52d96766dfe3650c39cfd3cfe5369fd9b31f07d668ea241ecf04d8855c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_drm.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n#include <linux/vga_switcheroo.h>\n#include <linux/mmu_notifier.h>\n#include <linux/dynamic_debug.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_generic.h>\n#include <drm/drm_gem_ttm_helper.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_vblank.h>\n\n#include <core/gpuobj.h>\n#include <core/option.h>\n#include <core/pci.h>\n#include <core/tegra.h>\n\n#include <nvif/driver.h>\n#include <nvif/fifo.h>\n#include <nvif/push006c.h>\n#include <nvif/user.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_ttm.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_vga.h\"\n#include \"nouveau_led.h\"\n#include \"nouveau_hwmon.h\"\n#include \"nouveau_acpi.h\"\n#include \"nouveau_bios.h\"\n#include \"nouveau_ioctl.h\"\n#include \"nouveau_abi16.h\"\n#include \"nouveau_fence.h\"\n#include \"nouveau_debugfs.h\"\n#include \"nouveau_usif.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_platform.h\"\n#include \"nouveau_svm.h\"\n#include \"nouveau_dmem.h\"\n#include \"nouveau_exec.h\"\n#include \"nouveau_uvmm.h\"\n#include \"nouveau_sched.h\"\n\nDECLARE_DYNDBG_CLASSMAP(drm_debug_classes, DD_CLASS_TYPE_DISJOINT_BITS, 0,\n\t\t\t\"DRM_UT_CORE\",\n\t\t\t\"DRM_UT_DRIVER\",\n\t\t\t\"DRM_UT_KMS\",\n\t\t\t\"DRM_UT_PRIME\",\n\t\t\t\"DRM_UT_ATOMIC\",\n\t\t\t\"DRM_UT_VBL\",\n\t\t\t\"DRM_UT_STATE\",\n\t\t\t\"DRM_UT_LEASE\",\n\t\t\t\"DRM_UT_DP\",\n\t\t\t\"DRM_UT_DRMRES\");\n\nMODULE_PARM_DESC(config, \"option string to pass to driver core\");\nstatic char *nouveau_config;\nmodule_param_named(config, nouveau_config, charp, 0400);\n\nMODULE_PARM_DESC(debug, \"debug string to pass to driver core\");\nstatic char *nouveau_debug;\nmodule_param_named(debug, nouveau_debug, charp, 0400);\n\nMODULE_PARM_DESC(noaccel, \"disable kernel/abi16 acceleration\");\nstatic int nouveau_noaccel = 0;\nmodule_param_named(noaccel, nouveau_noaccel, int, 0400);\n\nMODULE_PARM_DESC(modeset, \"enable driver (default: auto, \"\n\t\t          \"0 = disabled, 1 = enabled, 2 = headless)\");\nint nouveau_modeset = -1;\nmodule_param_named(modeset, nouveau_modeset, int, 0400);\n\nMODULE_PARM_DESC(atomic, \"Expose atomic ioctl (default: disabled)\");\nstatic int nouveau_atomic = 0;\nmodule_param_named(atomic, nouveau_atomic, int, 0400);\n\nMODULE_PARM_DESC(runpm, \"disable (0), force enable (1), optimus only default (-1)\");\nstatic int nouveau_runtime_pm = -1;\nmodule_param_named(runpm, nouveau_runtime_pm, int, 0400);\n\nstatic struct drm_driver driver_stub;\nstatic struct drm_driver driver_pci;\nstatic struct drm_driver driver_platform;\n\nstatic u64\nnouveau_pci_name(struct pci_dev *pdev)\n{\n\tu64 name = (u64)pci_domain_nr(pdev->bus) << 32;\n\tname |= pdev->bus->number << 16;\n\tname |= PCI_SLOT(pdev->devfn) << 8;\n\treturn name | PCI_FUNC(pdev->devfn);\n}\n\nstatic u64\nnouveau_platform_name(struct platform_device *platformdev)\n{\n\treturn platformdev->id;\n}\n\nstatic u64\nnouveau_name(struct drm_device *dev)\n{\n\tif (dev_is_pci(dev->dev))\n\t\treturn nouveau_pci_name(to_pci_dev(dev->dev));\n\telse\n\t\treturn nouveau_platform_name(to_platform_device(dev->dev));\n}\n\nstatic inline bool\nnouveau_cli_work_ready(struct dma_fence *fence)\n{\n\tbool ret = true;\n\n\tspin_lock_irq(fence->lock);\n\tif (!dma_fence_is_signaled_locked(fence))\n\t\tret = false;\n\tspin_unlock_irq(fence->lock);\n\n\tif (ret == true)\n\t\tdma_fence_put(fence);\n\treturn ret;\n}\n\nstatic void\nnouveau_cli_work(struct work_struct *w)\n{\n\tstruct nouveau_cli *cli = container_of(w, typeof(*cli), work);\n\tstruct nouveau_cli_work *work, *wtmp;\n\tmutex_lock(&cli->lock);\n\tlist_for_each_entry_safe(work, wtmp, &cli->worker, head) {\n\t\tif (!work->fence || nouveau_cli_work_ready(work->fence)) {\n\t\t\tlist_del(&work->head);\n\t\t\twork->func(work);\n\t\t}\n\t}\n\tmutex_unlock(&cli->lock);\n}\n\nstatic void\nnouveau_cli_work_fence(struct dma_fence *fence, struct dma_fence_cb *cb)\n{\n\tstruct nouveau_cli_work *work = container_of(cb, typeof(*work), cb);\n\tschedule_work(&work->cli->work);\n}\n\nvoid\nnouveau_cli_work_queue(struct nouveau_cli *cli, struct dma_fence *fence,\n\t\t       struct nouveau_cli_work *work)\n{\n\twork->fence = dma_fence_get(fence);\n\twork->cli = cli;\n\tmutex_lock(&cli->lock);\n\tlist_add_tail(&work->head, &cli->worker);\n\tif (dma_fence_add_callback(fence, &work->cb, nouveau_cli_work_fence))\n\t\tnouveau_cli_work_fence(fence, &work->cb);\n\tmutex_unlock(&cli->lock);\n}\n\nstatic void\nnouveau_cli_fini(struct nouveau_cli *cli)\n{\n\t \n\tflush_work(&cli->work);\n\tWARN_ON(!list_empty(&cli->worker));\n\n\tusif_client_fini(cli);\n\tnouveau_uvmm_fini(&cli->uvmm);\n\tnouveau_sched_entity_fini(&cli->sched_entity);\n\tnouveau_vmm_fini(&cli->svm);\n\tnouveau_vmm_fini(&cli->vmm);\n\tnvif_mmu_dtor(&cli->mmu);\n\tnvif_device_dtor(&cli->device);\n\tmutex_lock(&cli->drm->master.lock);\n\tnvif_client_dtor(&cli->base);\n\tmutex_unlock(&cli->drm->master.lock);\n}\n\nstatic int\nnouveau_cli_init(struct nouveau_drm *drm, const char *sname,\n\t\t struct nouveau_cli *cli)\n{\n\tstatic const struct nvif_mclass\n\tmems[] = {\n\t\t{ NVIF_CLASS_MEM_GF100, -1 },\n\t\t{ NVIF_CLASS_MEM_NV50 , -1 },\n\t\t{ NVIF_CLASS_MEM_NV04 , -1 },\n\t\t{}\n\t};\n\tstatic const struct nvif_mclass\n\tmmus[] = {\n\t\t{ NVIF_CLASS_MMU_GF100, -1 },\n\t\t{ NVIF_CLASS_MMU_NV50 , -1 },\n\t\t{ NVIF_CLASS_MMU_NV04 , -1 },\n\t\t{}\n\t};\n\tstatic const struct nvif_mclass\n\tvmms[] = {\n\t\t{ NVIF_CLASS_VMM_GP100, -1 },\n\t\t{ NVIF_CLASS_VMM_GM200, -1 },\n\t\t{ NVIF_CLASS_VMM_GF100, -1 },\n\t\t{ NVIF_CLASS_VMM_NV50 , -1 },\n\t\t{ NVIF_CLASS_VMM_NV04 , -1 },\n\t\t{}\n\t};\n\tu64 device = nouveau_name(drm->dev);\n\tint ret;\n\n\tsnprintf(cli->name, sizeof(cli->name), \"%s\", sname);\n\tcli->drm = drm;\n\tmutex_init(&cli->mutex);\n\tusif_client_init(cli);\n\n\tINIT_WORK(&cli->work, nouveau_cli_work);\n\tINIT_LIST_HEAD(&cli->worker);\n\tmutex_init(&cli->lock);\n\n\tif (cli == &drm->master) {\n\t\tret = nvif_driver_init(NULL, nouveau_config, nouveau_debug,\n\t\t\t\t       cli->name, device, &cli->base);\n\t} else {\n\t\tmutex_lock(&drm->master.lock);\n\t\tret = nvif_client_ctor(&drm->master.base, cli->name, device,\n\t\t\t\t       &cli->base);\n\t\tmutex_unlock(&drm->master.lock);\n\t}\n\tif (ret) {\n\t\tNV_PRINTK(err, cli, \"Client allocation failed: %d\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tret = nvif_device_ctor(&cli->base.object, \"drmDevice\", 0, NV_DEVICE,\n\t\t\t       &(struct nv_device_v0) {\n\t\t\t\t\t.device = ~0,\n\t\t\t\t\t.priv = true,\n\t\t\t       }, sizeof(struct nv_device_v0),\n\t\t\t       &cli->device);\n\tif (ret) {\n\t\tNV_PRINTK(err, cli, \"Device allocation failed: %d\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tret = nvif_mclass(&cli->device.object, mmus);\n\tif (ret < 0) {\n\t\tNV_PRINTK(err, cli, \"No supported MMU class\\n\");\n\t\tgoto done;\n\t}\n\n\tret = nvif_mmu_ctor(&cli->device.object, \"drmMmu\", mmus[ret].oclass,\n\t\t\t    &cli->mmu);\n\tif (ret) {\n\t\tNV_PRINTK(err, cli, \"MMU allocation failed: %d\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tret = nvif_mclass(&cli->mmu.object, vmms);\n\tif (ret < 0) {\n\t\tNV_PRINTK(err, cli, \"No supported VMM class\\n\");\n\t\tgoto done;\n\t}\n\n\tret = nouveau_vmm_init(cli, vmms[ret].oclass, &cli->vmm);\n\tif (ret) {\n\t\tNV_PRINTK(err, cli, \"VMM allocation failed: %d\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tret = nvif_mclass(&cli->mmu.object, mems);\n\tif (ret < 0) {\n\t\tNV_PRINTK(err, cli, \"No supported MEM class\\n\");\n\t\tgoto done;\n\t}\n\n\tcli->mem = &mems[ret];\n\n\tret = nouveau_sched_entity_init(&cli->sched_entity, &drm->sched,\n\t\t\t\t\tdrm->sched_wq);\n\tif (ret)\n\t\tgoto done;\n\n\treturn 0;\ndone:\n\tif (ret)\n\t\tnouveau_cli_fini(cli);\n\treturn ret;\n}\n\nstatic void\nnouveau_accel_ce_fini(struct nouveau_drm *drm)\n{\n\tnouveau_channel_idle(drm->cechan);\n\tnvif_object_dtor(&drm->ttm.copy);\n\tnouveau_channel_del(&drm->cechan);\n}\n\nstatic void\nnouveau_accel_ce_init(struct nouveau_drm *drm)\n{\n\tstruct nvif_device *device = &drm->client.device;\n\tu64 runm;\n\tint ret = 0;\n\n\t \n\trunm = nvif_fifo_runlist_ce(device);\n\tif (!runm) {\n\t\tNV_DEBUG(drm, \"no ce runlist\\n\");\n\t\treturn;\n\t}\n\n\tret = nouveau_channel_new(drm, device, false, runm, NvDmaFB, NvDmaTT, &drm->cechan);\n\tif (ret)\n\t\tNV_ERROR(drm, \"failed to create ce channel, %d\\n\", ret);\n}\n\nstatic void\nnouveau_accel_gr_fini(struct nouveau_drm *drm)\n{\n\tnouveau_channel_idle(drm->channel);\n\tnvif_object_dtor(&drm->ntfy);\n\tnvkm_gpuobj_del(&drm->notify);\n\tnouveau_channel_del(&drm->channel);\n}\n\nstatic void\nnouveau_accel_gr_init(struct nouveau_drm *drm)\n{\n\tstruct nvif_device *device = &drm->client.device;\n\tu64 runm;\n\tint ret;\n\n\t \n\trunm = nvif_fifo_runlist(device, NV_DEVICE_HOST_RUNLIST_ENGINES_GR);\n\tif (!runm) {\n\t\tNV_DEBUG(drm, \"no gr runlist\\n\");\n\t\treturn;\n\t}\n\n\tret = nouveau_channel_new(drm, device, false, runm, NvDmaFB, NvDmaTT, &drm->channel);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"failed to create kernel channel, %d\\n\", ret);\n\t\tnouveau_accel_gr_fini(drm);\n\t\treturn;\n\t}\n\n\t \n\tif (!drm->channel->nvsw.client && device->info.family < NV_DEVICE_INFO_V0_TESLA) {\n\t\tret = nvif_object_ctor(&drm->channel->user, \"drmNvsw\",\n\t\t\t\t       NVDRM_NVSW, nouveau_abi16_swclass(drm),\n\t\t\t\t       NULL, 0, &drm->channel->nvsw);\n\n\t\tif (ret == 0 && device->info.chipset >= 0x11) {\n\t\t\tret = nvif_object_ctor(&drm->channel->user, \"drmBlit\",\n\t\t\t\t\t       0x005f, 0x009f,\n\t\t\t\t\t       NULL, 0, &drm->channel->blit);\n\t\t}\n\n\t\tif (ret == 0) {\n\t\t\tstruct nvif_push *push = drm->channel->chan.push;\n\t\t\tret = PUSH_WAIT(push, 8);\n\t\t\tif (ret == 0) {\n\t\t\t\tif (device->info.chipset >= 0x11) {\n\t\t\t\t\tPUSH_NVSQ(push, NV05F, 0x0000, drm->channel->blit.handle);\n\t\t\t\t\tPUSH_NVSQ(push, NV09F, 0x0120, 0,\n\t\t\t\t\t\t\t       0x0124, 1,\n\t\t\t\t\t\t\t       0x0128, 2);\n\t\t\t\t}\n\t\t\t\tPUSH_NVSQ(push, NV_SW, 0x0000, drm->channel->nvsw.handle);\n\t\t\t}\n\t\t}\n\n\t\tif (ret) {\n\t\t\tNV_ERROR(drm, \"failed to allocate sw or blit class, %d\\n\", ret);\n\t\t\tnouveau_accel_gr_fini(drm);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (device->info.family < NV_DEVICE_INFO_V0_FERMI) {\n\t\tret = nvkm_gpuobj_new(nvxx_device(device), 32, 0, false, NULL,\n\t\t\t\t      &drm->notify);\n\t\tif (ret) {\n\t\t\tNV_ERROR(drm, \"failed to allocate notifier, %d\\n\", ret);\n\t\t\tnouveau_accel_gr_fini(drm);\n\t\t\treturn;\n\t\t}\n\n\t\tret = nvif_object_ctor(&drm->channel->user, \"drmM2mfNtfy\",\n\t\t\t\t       NvNotify0, NV_DMA_IN_MEMORY,\n\t\t\t\t       &(struct nv_dma_v0) {\n\t\t\t\t\t\t.target = NV_DMA_V0_TARGET_VRAM,\n\t\t\t\t\t\t.access = NV_DMA_V0_ACCESS_RDWR,\n\t\t\t\t\t\t.start = drm->notify->addr,\n\t\t\t\t\t\t.limit = drm->notify->addr + 31\n\t\t\t\t       }, sizeof(struct nv_dma_v0),\n\t\t\t\t       &drm->ntfy);\n\t\tif (ret) {\n\t\t\tnouveau_accel_gr_fini(drm);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\nnouveau_accel_fini(struct nouveau_drm *drm)\n{\n\tnouveau_accel_ce_fini(drm);\n\tnouveau_accel_gr_fini(drm);\n\tif (drm->fence)\n\t\tnouveau_fence(drm)->dtor(drm);\n\tnouveau_channels_fini(drm);\n}\n\nstatic void\nnouveau_accel_init(struct nouveau_drm *drm)\n{\n\tstruct nvif_device *device = &drm->client.device;\n\tstruct nvif_sclass *sclass;\n\tint ret, i, n;\n\n\tif (nouveau_noaccel)\n\t\treturn;\n\n\t \n\tret = nouveau_channels_init(drm);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = n = nvif_object_sclass_get(&device->object, &sclass);\n\tif (ret < 0)\n\t\treturn;\n\n\tfor (ret = -ENOSYS, i = 0; i < n; i++) {\n\t\tswitch (sclass[i].oclass) {\n\t\tcase NV03_CHANNEL_DMA:\n\t\t\tret = nv04_fence_create(drm);\n\t\t\tbreak;\n\t\tcase NV10_CHANNEL_DMA:\n\t\t\tret = nv10_fence_create(drm);\n\t\t\tbreak;\n\t\tcase NV17_CHANNEL_DMA:\n\t\tcase NV40_CHANNEL_DMA:\n\t\t\tret = nv17_fence_create(drm);\n\t\t\tbreak;\n\t\tcase NV50_CHANNEL_GPFIFO:\n\t\t\tret = nv50_fence_create(drm);\n\t\t\tbreak;\n\t\tcase G82_CHANNEL_GPFIFO:\n\t\t\tret = nv84_fence_create(drm);\n\t\t\tbreak;\n\t\tcase FERMI_CHANNEL_GPFIFO:\n\t\tcase KEPLER_CHANNEL_GPFIFO_A:\n\t\tcase KEPLER_CHANNEL_GPFIFO_B:\n\t\tcase MAXWELL_CHANNEL_GPFIFO_A:\n\t\tcase PASCAL_CHANNEL_GPFIFO_A:\n\t\tcase VOLTA_CHANNEL_GPFIFO_A:\n\t\tcase TURING_CHANNEL_GPFIFO_A:\n\t\tcase AMPERE_CHANNEL_GPFIFO_A:\n\t\tcase AMPERE_CHANNEL_GPFIFO_B:\n\t\t\tret = nvc0_fence_create(drm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvif_object_sclass_put(&sclass);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"failed to initialise sync subsystem, %d\\n\", ret);\n\t\tnouveau_accel_fini(drm);\n\t\treturn;\n\t}\n\n\t \n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_VOLTA) {\n\t\tret = nvif_user_ctor(device, \"drmUsermode\");\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\n\t \n\tnouveau_accel_gr_init(drm);\n\tnouveau_accel_ce_init(drm);\n\n\t \n\tnouveau_bo_move_init(drm);\n}\n\nstatic void __printf(2, 3)\nnouveau_drm_errorf(struct nvif_object *object, const char *fmt, ...)\n{\n\tstruct nouveau_drm *drm = container_of(object->parent, typeof(*drm), parent);\n\tstruct va_format vaf;\n\tva_list va;\n\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tNV_ERROR(drm, \"%pV\", &vaf);\n\tva_end(va);\n}\n\nstatic void __printf(2, 3)\nnouveau_drm_debugf(struct nvif_object *object, const char *fmt, ...)\n{\n\tstruct nouveau_drm *drm = container_of(object->parent, typeof(*drm), parent);\n\tstruct va_format vaf;\n\tva_list va;\n\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tNV_DEBUG(drm, \"%pV\", &vaf);\n\tva_end(va);\n}\n\nstatic const struct nvif_parent_func\nnouveau_parent = {\n\t.debugf = nouveau_drm_debugf,\n\t.errorf = nouveau_drm_errorf,\n};\n\nstatic int\nnouveau_drm_device_init(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm;\n\tint ret;\n\n\tif (!(drm = kzalloc(sizeof(*drm), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tdev->dev_private = drm;\n\tdrm->dev = dev;\n\n\tnvif_parent_ctor(&nouveau_parent, &drm->parent);\n\tdrm->master.base.object.parent = &drm->parent;\n\n\tret = nouveau_sched_init(drm);\n\tif (ret)\n\t\tgoto fail_alloc;\n\n\tret = nouveau_cli_init(drm, \"DRM-master\", &drm->master);\n\tif (ret)\n\t\tgoto fail_sched;\n\n\tret = nouveau_cli_init(drm, \"DRM\", &drm->client);\n\tif (ret)\n\t\tgoto fail_master;\n\n\tnvxx_client(&drm->client.base)->debug =\n\t\tnvkm_dbgopt(nouveau_debug, \"DRM\");\n\n\tINIT_LIST_HEAD(&drm->clients);\n\tmutex_init(&drm->clients_lock);\n\tspin_lock_init(&drm->tile.lock);\n\n\t \n\tif (drm->client.device.info.chipset == 0xc1)\n\t\tnvif_mask(&drm->client.device.object, 0x00088080, 0x00000800, 0x00000000);\n\n\tnouveau_vga_init(drm);\n\n\tret = nouveau_ttm_init(drm);\n\tif (ret)\n\t\tgoto fail_ttm;\n\n\tret = nouveau_bios_init(dev);\n\tif (ret)\n\t\tgoto fail_bios;\n\n\tnouveau_accel_init(drm);\n\n\tret = nouveau_display_create(dev);\n\tif (ret)\n\t\tgoto fail_dispctor;\n\n\tif (dev->mode_config.num_crtc) {\n\t\tret = nouveau_display_init(dev, false, false);\n\t\tif (ret)\n\t\t\tgoto fail_dispinit;\n\t}\n\n\tnouveau_debugfs_init(drm);\n\tnouveau_hwmon_init(dev);\n\tnouveau_svm_init(drm);\n\tnouveau_dmem_init(drm);\n\tnouveau_led_init(dev);\n\n\tif (nouveau_pmops_runtime()) {\n\t\tpm_runtime_use_autosuspend(dev->dev);\n\t\tpm_runtime_set_autosuspend_delay(dev->dev, 5000);\n\t\tpm_runtime_set_active(dev->dev);\n\t\tpm_runtime_allow(dev->dev);\n\t\tpm_runtime_mark_last_busy(dev->dev);\n\t\tpm_runtime_put(dev->dev);\n\t}\n\n\treturn 0;\nfail_dispinit:\n\tnouveau_display_destroy(dev);\nfail_dispctor:\n\tnouveau_accel_fini(drm);\n\tnouveau_bios_takedown(dev);\nfail_bios:\n\tnouveau_ttm_fini(drm);\nfail_ttm:\n\tnouveau_vga_fini(drm);\n\tnouveau_cli_fini(&drm->client);\nfail_master:\n\tnouveau_cli_fini(&drm->master);\nfail_sched:\n\tnouveau_sched_fini(drm);\nfail_alloc:\n\tnvif_parent_dtor(&drm->parent);\n\tkfree(drm);\n\treturn ret;\n}\n\nstatic void\nnouveau_drm_device_fini(struct drm_device *dev)\n{\n\tstruct nouveau_cli *cli, *temp_cli;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (nouveau_pmops_runtime()) {\n\t\tpm_runtime_get_sync(dev->dev);\n\t\tpm_runtime_forbid(dev->dev);\n\t}\n\n\tnouveau_led_fini(dev);\n\tnouveau_dmem_fini(drm);\n\tnouveau_svm_fini(drm);\n\tnouveau_hwmon_fini(dev);\n\tnouveau_debugfs_fini(drm);\n\n\tif (dev->mode_config.num_crtc)\n\t\tnouveau_display_fini(dev, false, false);\n\tnouveau_display_destroy(dev);\n\n\tnouveau_accel_fini(drm);\n\tnouveau_bios_takedown(dev);\n\n\tnouveau_ttm_fini(drm);\n\tnouveau_vga_fini(drm);\n\n\t \n\tmutex_lock(&drm->clients_lock);\n\tlist_for_each_entry_safe(cli, temp_cli, &drm->clients, head) {\n\t\tlist_del(&cli->head);\n\t\tmutex_lock(&cli->mutex);\n\t\tif (cli->abi16)\n\t\t\tnouveau_abi16_fini(cli->abi16);\n\t\tmutex_unlock(&cli->mutex);\n\t\tnouveau_cli_fini(cli);\n\t\tkfree(cli);\n\t}\n\tmutex_unlock(&drm->clients_lock);\n\n\tnouveau_sched_fini(drm);\n\n\tnouveau_cli_fini(&drm->client);\n\tnouveau_cli_fini(&drm->master);\n\tnvif_parent_dtor(&drm->parent);\n\tmutex_destroy(&drm->clients_lock);\n\tkfree(drm);\n}\n\n \n\nstatic void quirk_broken_nv_runpm(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct pci_dev *bridge = pci_upstream_bridge(pdev);\n\n\tif (!bridge || bridge->vendor != PCI_VENDOR_ID_INTEL)\n\t\treturn;\n\n\tswitch (bridge->device) {\n\tcase 0x1901:\n\t\tdrm->old_pm_cap = pdev->pm_cap;\n\t\tpdev->pm_cap = 0;\n\t\tNV_INFO(drm, \"Disabling PCI power management to avoid bug\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic int nouveau_drm_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *pent)\n{\n\tstruct nvkm_device *device;\n\tstruct drm_device *drm_dev;\n\tint ret;\n\n\tif (vga_switcheroo_client_probe_defer(pdev))\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tret = nvkm_device_pci_new(pdev, nouveau_config, \"error\",\n\t\t\t\t  true, false, 0, &device);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_device_del(&device);\n\n\t \n\tret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &driver_pci);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_device_pci_new(pdev, nouveau_config, nouveau_debug,\n\t\t\t\t  true, true, ~0ULL, &device);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tif (nouveau_atomic)\n\t\tdriver_pci.driver_features |= DRIVER_ATOMIC;\n\n\tdrm_dev = drm_dev_alloc(&driver_pci, &pdev->dev);\n\tif (IS_ERR(drm_dev)) {\n\t\tret = PTR_ERR(drm_dev);\n\t\tgoto fail_nvkm;\n\t}\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\tgoto fail_drm;\n\n\tpci_set_drvdata(pdev, drm_dev);\n\n\tret = nouveau_drm_device_init(drm_dev);\n\tif (ret)\n\t\tgoto fail_pci;\n\n\tret = drm_dev_register(drm_dev, pent->driver_data);\n\tif (ret)\n\t\tgoto fail_drm_dev_init;\n\n\tif (nouveau_drm(drm_dev)->client.device.info.ram_size <= 32 * 1024 * 1024)\n\t\tdrm_fbdev_generic_setup(drm_dev, 8);\n\telse\n\t\tdrm_fbdev_generic_setup(drm_dev, 32);\n\n\tquirk_broken_nv_runpm(pdev);\n\treturn 0;\n\nfail_drm_dev_init:\n\tnouveau_drm_device_fini(drm_dev);\nfail_pci:\n\tpci_disable_device(pdev);\nfail_drm:\n\tdrm_dev_put(drm_dev);\nfail_nvkm:\n\tnvkm_device_del(&device);\n\treturn ret;\n}\n\nvoid\nnouveau_drm_device_remove(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_client *client;\n\tstruct nvkm_device *device;\n\n\tdrm_dev_unplug(dev);\n\n\tclient = nvxx_client(&drm->client.base);\n\tdevice = nvkm_device_find(client->device);\n\n\tnouveau_drm_device_fini(dev);\n\tdrm_dev_put(dev);\n\tnvkm_device_del(&device);\n}\n\nstatic void\nnouveau_drm_remove(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\t \n\tif (drm->old_pm_cap)\n\t\tpdev->pm_cap = drm->old_pm_cap;\n\tnouveau_drm_device_remove(dev);\n\tpci_disable_device(pdev);\n}\n\nstatic int\nnouveau_do_suspend(struct drm_device *dev, bool runtime)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct ttm_resource_manager *man;\n\tint ret;\n\n\tnouveau_svm_suspend(drm);\n\tnouveau_dmem_suspend(drm);\n\tnouveau_led_suspend(dev);\n\n\tif (dev->mode_config.num_crtc) {\n\t\tNV_DEBUG(drm, \"suspending display...\\n\");\n\t\tret = nouveau_display_suspend(dev, runtime);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tNV_DEBUG(drm, \"evicting buffers...\\n\");\n\n\tman = ttm_manager_type(&drm->ttm.bdev, TTM_PL_VRAM);\n\tttm_resource_manager_evict_all(&drm->ttm.bdev, man);\n\n\tNV_DEBUG(drm, \"waiting for kernel channels to go idle...\\n\");\n\tif (drm->cechan) {\n\t\tret = nouveau_channel_idle(drm->cechan);\n\t\tif (ret)\n\t\t\tgoto fail_display;\n\t}\n\n\tif (drm->channel) {\n\t\tret = nouveau_channel_idle(drm->channel);\n\t\tif (ret)\n\t\t\tgoto fail_display;\n\t}\n\n\tNV_DEBUG(drm, \"suspending fence...\\n\");\n\tif (drm->fence && nouveau_fence(drm)->suspend) {\n\t\tif (!nouveau_fence(drm)->suspend(drm)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_display;\n\t\t}\n\t}\n\n\tNV_DEBUG(drm, \"suspending object tree...\\n\");\n\tret = nvif_client_suspend(&drm->master.base);\n\tif (ret)\n\t\tgoto fail_client;\n\n\treturn 0;\n\nfail_client:\n\tif (drm->fence && nouveau_fence(drm)->resume)\n\t\tnouveau_fence(drm)->resume(drm);\n\nfail_display:\n\tif (dev->mode_config.num_crtc) {\n\t\tNV_DEBUG(drm, \"resuming display...\\n\");\n\t\tnouveau_display_resume(dev, runtime);\n\t}\n\treturn ret;\n}\n\nstatic int\nnouveau_do_resume(struct drm_device *dev, bool runtime)\n{\n\tint ret = 0;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tNV_DEBUG(drm, \"resuming object tree...\\n\");\n\tret = nvif_client_resume(&drm->master.base);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"Client resume failed with error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tNV_DEBUG(drm, \"resuming fence...\\n\");\n\tif (drm->fence && nouveau_fence(drm)->resume)\n\t\tnouveau_fence(drm)->resume(drm);\n\n\tnouveau_run_vbios_init(dev);\n\n\tif (dev->mode_config.num_crtc) {\n\t\tNV_DEBUG(drm, \"resuming display...\\n\");\n\t\tnouveau_display_resume(dev, runtime);\n\t}\n\n\tnouveau_led_resume(dev);\n\tnouveau_dmem_resume(drm);\n\tnouveau_svm_resume(drm);\n\treturn 0;\n}\n\nint\nnouveau_pmops_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF ||\n\t    drm_dev->switch_power_state == DRM_SWITCH_POWER_DYNAMIC_OFF)\n\t\treturn 0;\n\n\tret = nouveau_do_suspend(drm_dev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\tudelay(200);\n\treturn 0;\n}\n\nint\nnouveau_pmops_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (drm_dev->switch_power_state == DRM_SWITCH_POWER_OFF ||\n\t    drm_dev->switch_power_state == DRM_SWITCH_POWER_DYNAMIC_OFF)\n\t\treturn 0;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\tpci_set_master(pdev);\n\n\tret = nouveau_do_resume(drm_dev, false);\n\n\t \n\tnouveau_display_hpd_resume(drm_dev);\n\n\treturn ret;\n}\n\nstatic int\nnouveau_pmops_freeze(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\treturn nouveau_do_suspend(drm_dev, false);\n}\n\nstatic int\nnouveau_pmops_thaw(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\treturn nouveau_do_resume(drm_dev, false);\n}\n\nbool\nnouveau_pmops_runtime(void)\n{\n\tif (nouveau_runtime_pm == -1)\n\t\treturn nouveau_is_optimus() || nouveau_is_v1_dsm();\n\treturn nouveau_runtime_pm == 1;\n}\n\nstatic int\nnouveau_pmops_runtime_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tint ret;\n\n\tif (!nouveau_pmops_runtime()) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tnouveau_switcheroo_optimus_dsm();\n\tret = nouveau_do_suspend(drm_dev, true);\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\tpci_ignore_hotplug(pdev);\n\tpci_set_power_state(pdev, PCI_D3cold);\n\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_DYNAMIC_OFF;\n\treturn ret;\n}\n\nstatic int\nnouveau_pmops_runtime_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct drm_device *drm_dev = pci_get_drvdata(pdev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvif_device *device = &nouveau_drm(drm_dev)->client.device;\n\tint ret;\n\n\tif (!nouveau_pmops_runtime()) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\tpci_set_master(pdev);\n\n\tret = nouveau_do_resume(drm_dev, true);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"resume failed with: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tnvif_mask(&device->object, 0x088488, (1 << 25), (1 << 25));\n\tdrm_dev->switch_power_state = DRM_SWITCH_POWER_ON;\n\n\t \n\tnouveau_display_hpd_resume(drm_dev);\n\n\treturn ret;\n}\n\nstatic int\nnouveau_pmops_runtime_idle(struct device *dev)\n{\n\tif (!nouveau_pmops_runtime()) {\n\t\tpm_runtime_forbid(dev);\n\t\treturn -EBUSY;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_autosuspend(dev);\n\t \n\treturn 1;\n}\n\nstatic int\nnouveau_drm_open(struct drm_device *dev, struct drm_file *fpriv)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_cli *cli;\n\tchar name[32], tmpname[TASK_COMM_LEN];\n\tint ret;\n\n\t \n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn ret;\n\t}\n\n\tget_task_comm(tmpname, current);\n\trcu_read_lock();\n\tsnprintf(name, sizeof(name), \"%s[%d]\",\n\t\t tmpname, pid_nr(rcu_dereference(fpriv->pid)));\n\trcu_read_unlock();\n\n\tif (!(cli = kzalloc(sizeof(*cli), GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tret = nouveau_cli_init(drm, name, cli);\n\tif (ret)\n\t\tgoto done;\n\n\tfpriv->driver_priv = cli;\n\n\tmutex_lock(&drm->clients_lock);\n\tlist_add(&cli->head, &drm->clients);\n\tmutex_unlock(&drm->clients_lock);\n\ndone:\n\tif (ret && cli) {\n\t\tnouveau_cli_fini(cli);\n\t\tkfree(cli);\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn ret;\n}\n\nstatic void\nnouveau_drm_postclose(struct drm_device *dev, struct drm_file *fpriv)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(fpriv);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint dev_index;\n\n\t \n\tif (!drm_dev_enter(dev, &dev_index))\n\t\treturn;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tmutex_lock(&cli->mutex);\n\tif (cli->abi16)\n\t\tnouveau_abi16_fini(cli->abi16);\n\tmutex_unlock(&cli->mutex);\n\n\tmutex_lock(&drm->clients_lock);\n\tlist_del(&cli->head);\n\tmutex_unlock(&drm->clients_lock);\n\n\tnouveau_cli_fini(cli);\n\tkfree(cli);\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\tdrm_dev_exit(dev_index);\n}\n\nstatic const struct drm_ioctl_desc\nnouveau_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GETPARAM, nouveau_abi16_ioctl_getparam, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_SETPARAM, drm_invalid_op, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_CHANNEL_ALLOC, nouveau_abi16_ioctl_channel_alloc, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_CHANNEL_FREE, nouveau_abi16_ioctl_channel_free, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GROBJ_ALLOC, nouveau_abi16_ioctl_grobj_alloc, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_NOTIFIEROBJ_ALLOC, nouveau_abi16_ioctl_notifierobj_alloc, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GPUOBJ_FREE, nouveau_abi16_ioctl_gpuobj_free, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_SVM_INIT, nouveau_svmm_init, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_SVM_BIND, nouveau_svmm_bind, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GEM_NEW, nouveau_gem_ioctl_new, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GEM_PUSHBUF, nouveau_gem_ioctl_pushbuf, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GEM_CPU_PREP, nouveau_gem_ioctl_cpu_prep, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GEM_CPU_FINI, nouveau_gem_ioctl_cpu_fini, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_GEM_INFO, nouveau_gem_ioctl_info, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_VM_INIT, nouveau_uvmm_ioctl_vm_init, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_VM_BIND, nouveau_uvmm_ioctl_vm_bind, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(NOUVEAU_EXEC, nouveau_exec_ioctl_exec, DRM_RENDER_ALLOW),\n};\n\nlong\nnouveau_drm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct drm_file *filp = file->private_data;\n\tstruct drm_device *dev = filp->minor->dev;\n\tlong ret;\n\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn ret;\n\t}\n\n\tswitch (_IOC_NR(cmd) - DRM_COMMAND_BASE) {\n\tcase DRM_NOUVEAU_NVIF:\n\t\tret = usif_ioctl(filp, (void __user *)arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\tdefault:\n\t\tret = drm_ioctl(file, cmd, arg);\n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn ret;\n}\n\nstatic const struct file_operations\nnouveau_driver_fops = {\n\t.owner = THIS_MODULE,\n\t.open = drm_open,\n\t.release = drm_release,\n\t.unlocked_ioctl = nouveau_drm_ioctl,\n\t.mmap = drm_gem_mmap,\n\t.poll = drm_poll,\n\t.read = drm_read,\n#if defined(CONFIG_COMPAT)\n\t.compat_ioctl = nouveau_compat_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\nstatic struct drm_driver\ndriver_stub = {\n\t.driver_features = DRIVER_GEM |\n\t\t\t   DRIVER_SYNCOBJ | DRIVER_SYNCOBJ_TIMELINE |\n\t\t\t   DRIVER_GEM_GPUVA |\n\t\t\t   DRIVER_MODESET |\n\t\t\t   DRIVER_RENDER,\n\t.open = nouveau_drm_open,\n\t.postclose = nouveau_drm_postclose,\n\t.lastclose = nouveau_vga_lastclose,\n\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = nouveau_drm_debugfs_init,\n#endif\n\n\t.ioctls = nouveau_ioctls,\n\t.num_ioctls = ARRAY_SIZE(nouveau_ioctls),\n\t.fops = &nouveau_driver_fops,\n\n\t.gem_prime_import_sg_table = nouveau_gem_prime_import_sg_table,\n\n\t.dumb_create = nouveau_display_dumb_create,\n\t.dumb_map_offset = drm_gem_ttm_dumb_map_offset,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n#ifdef GIT_REVISION\n\t.date = GIT_REVISION,\n#else\n\t.date = DRIVER_DATE,\n#endif\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nstatic struct pci_device_id\nnouveau_drm_pci_table[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID),\n\t\t.class = PCI_BASE_CLASS_DISPLAY << 16,\n\t\t.class_mask  = 0xff << 16,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_NVIDIA_SGS, PCI_ANY_ID),\n\t\t.class = PCI_BASE_CLASS_DISPLAY << 16,\n\t\t.class_mask  = 0xff << 16,\n\t},\n\t{}\n};\n\nstatic void nouveau_display_options(void)\n{\n\tDRM_DEBUG_DRIVER(\"Loading Nouveau with parameters:\\n\");\n\n\tDRM_DEBUG_DRIVER(\"... tv_disable   : %d\\n\", nouveau_tv_disable);\n\tDRM_DEBUG_DRIVER(\"... ignorelid    : %d\\n\", nouveau_ignorelid);\n\tDRM_DEBUG_DRIVER(\"... duallink     : %d\\n\", nouveau_duallink);\n\tDRM_DEBUG_DRIVER(\"... config       : %s\\n\", nouveau_config);\n\tDRM_DEBUG_DRIVER(\"... debug        : %s\\n\", nouveau_debug);\n\tDRM_DEBUG_DRIVER(\"... noaccel      : %d\\n\", nouveau_noaccel);\n\tDRM_DEBUG_DRIVER(\"... modeset      : %d\\n\", nouveau_modeset);\n\tDRM_DEBUG_DRIVER(\"... runpm        : %d\\n\", nouveau_runtime_pm);\n\tDRM_DEBUG_DRIVER(\"... vram_pushbuf : %d\\n\", nouveau_vram_pushbuf);\n\tDRM_DEBUG_DRIVER(\"... hdmimhz      : %d\\n\", nouveau_hdmimhz);\n}\n\nstatic const struct dev_pm_ops nouveau_pm_ops = {\n\t.suspend = nouveau_pmops_suspend,\n\t.resume = nouveau_pmops_resume,\n\t.freeze = nouveau_pmops_freeze,\n\t.thaw = nouveau_pmops_thaw,\n\t.poweroff = nouveau_pmops_freeze,\n\t.restore = nouveau_pmops_resume,\n\t.runtime_suspend = nouveau_pmops_runtime_suspend,\n\t.runtime_resume = nouveau_pmops_runtime_resume,\n\t.runtime_idle = nouveau_pmops_runtime_idle,\n};\n\nstatic struct pci_driver\nnouveau_drm_pci_driver = {\n\t.name = \"nouveau\",\n\t.id_table = nouveau_drm_pci_table,\n\t.probe = nouveau_drm_probe,\n\t.remove = nouveau_drm_remove,\n\t.driver.pm = &nouveau_pm_ops,\n};\n\nstruct drm_device *\nnouveau_platform_device_create(const struct nvkm_device_tegra_func *func,\n\t\t\t       struct platform_device *pdev,\n\t\t\t       struct nvkm_device **pdevice)\n{\n\tstruct drm_device *drm;\n\tint err;\n\n\terr = nvkm_device_tegra_new(func, pdev, nouveau_config, nouveau_debug,\n\t\t\t\t    true, true, ~0ULL, pdevice);\n\tif (err)\n\t\tgoto err_free;\n\n\tdrm = drm_dev_alloc(&driver_platform, &pdev->dev);\n\tif (IS_ERR(drm)) {\n\t\terr = PTR_ERR(drm);\n\t\tgoto err_free;\n\t}\n\n\terr = nouveau_drm_device_init(drm);\n\tif (err)\n\t\tgoto err_put;\n\n\tplatform_set_drvdata(pdev, drm);\n\n\treturn drm;\n\nerr_put:\n\tdrm_dev_put(drm);\nerr_free:\n\tnvkm_device_del(pdevice);\n\n\treturn ERR_PTR(err);\n}\n\nstatic int __init\nnouveau_drm_init(void)\n{\n\tdriver_pci = driver_stub;\n\tdriver_platform = driver_stub;\n\n\tnouveau_display_options();\n\n\tif (nouveau_modeset == -1) {\n\t\tif (drm_firmware_drivers_only())\n\t\t\tnouveau_modeset = 0;\n\t}\n\n\tif (!nouveau_modeset)\n\t\treturn 0;\n\n#ifdef CONFIG_NOUVEAU_PLATFORM_DRIVER\n\tplatform_driver_register(&nouveau_platform_driver);\n#endif\n\n\tnouveau_register_dsm_handler();\n\tnouveau_backlight_ctor();\n\n#ifdef CONFIG_PCI\n\treturn pci_register_driver(&nouveau_drm_pci_driver);\n#else\n\treturn 0;\n#endif\n}\n\nstatic void __exit\nnouveau_drm_exit(void)\n{\n\tif (!nouveau_modeset)\n\t\treturn;\n\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&nouveau_drm_pci_driver);\n#endif\n\tnouveau_backlight_dtor();\n\tnouveau_unregister_dsm_handler();\n\n#ifdef CONFIG_NOUVEAU_PLATFORM_DRIVER\n\tplatform_driver_unregister(&nouveau_platform_driver);\n#endif\n\tif (IS_ENABLED(CONFIG_DRM_NOUVEAU_SVM))\n\t\tmmu_notifier_synchronize();\n}\n\nmodule_init(nouveau_drm_init);\nmodule_exit(nouveau_drm_exit);\n\nMODULE_DEVICE_TABLE(pci, nouveau_drm_pci_table);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL and additional rights\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}