{
  "module_name": "nouveau_exec.c",
  "hash_id": "e6cf706807a7ef67f4e18c59465fddf9b9056a7ab10d09385c8482e76c41fcaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_exec.c",
  "human_readable_source": "\n\n#include <drm/drm_exec.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_mem.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_exec.h\"\n#include \"nouveau_abi16.h\"\n#include \"nouveau_chan.h\"\n#include \"nouveau_sched.h\"\n#include \"nouveau_uvmm.h\"\n\n \n\nstatic int\nnouveau_exec_job_submit(struct nouveau_job *job)\n{\n\tstruct nouveau_exec_job *exec_job = to_nouveau_exec_job(job);\n\tstruct nouveau_cli *cli = job->cli;\n\tstruct nouveau_uvmm *uvmm = nouveau_cli_uvmm(cli);\n\tstruct drm_exec *exec = &job->exec;\n\tstruct drm_gem_object *obj;\n\tunsigned long index;\n\tint ret;\n\n\t \n\tret = nouveau_fence_create(&exec_job->fence, exec_job->chan);\n\tif (ret)\n\t\treturn ret;\n\n\tnouveau_uvmm_lock(uvmm);\n\tdrm_exec_init(exec, DRM_EXEC_INTERRUPTIBLE_WAIT |\n\t\t\t    DRM_EXEC_IGNORE_DUPLICATES);\n\tdrm_exec_until_all_locked(exec) {\n\t\tstruct drm_gpuva *va;\n\n\t\tdrm_gpuva_for_each_va(va, &uvmm->umgr) {\n\t\t\tif (unlikely(va == &uvmm->umgr.kernel_alloc_node))\n\t\t\t\tcontinue;\n\n\t\t\tret = drm_exec_prepare_obj(exec, va->gem.obj, 1);\n\t\t\tdrm_exec_retry_on_contention(exec);\n\t\t\tif (ret)\n\t\t\t\tgoto err_uvmm_unlock;\n\t\t}\n\t}\n\tnouveau_uvmm_unlock(uvmm);\n\n\tdrm_exec_for_each_locked_object(exec, index, obj) {\n\t\tstruct nouveau_bo *nvbo = nouveau_gem_object(obj);\n\n\t\tret = nouveau_bo_validate(nvbo, true, false);\n\t\tif (ret)\n\t\t\tgoto err_exec_fini;\n\t}\n\n\treturn 0;\n\nerr_uvmm_unlock:\n\tnouveau_uvmm_unlock(uvmm);\nerr_exec_fini:\n\tdrm_exec_fini(exec);\n\treturn ret;\n\n}\n\nstatic void\nnouveau_exec_job_armed_submit(struct nouveau_job *job)\n{\n\tstruct drm_exec *exec = &job->exec;\n\tstruct drm_gem_object *obj;\n\tunsigned long index;\n\n\tdrm_exec_for_each_locked_object(exec, index, obj)\n\t\tdma_resv_add_fence(obj->resv, job->done_fence, job->resv_usage);\n\n\tdrm_exec_fini(exec);\n}\n\nstatic struct dma_fence *\nnouveau_exec_job_run(struct nouveau_job *job)\n{\n\tstruct nouveau_exec_job *exec_job = to_nouveau_exec_job(job);\n\tstruct nouveau_channel *chan = exec_job->chan;\n\tstruct nouveau_fence *fence = exec_job->fence;\n\tint i, ret;\n\n\tret = nouveau_dma_wait(chan, exec_job->push.count + 1, 16);\n\tif (ret) {\n\t\tNV_PRINTK(err, job->cli, \"nv50cal_space: %d\\n\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tfor (i = 0; i < exec_job->push.count; i++) {\n\t\tstruct drm_nouveau_exec_push *p = &exec_job->push.s[i];\n\t\tbool no_prefetch = p->flags & DRM_NOUVEAU_EXEC_PUSH_NO_PREFETCH;\n\n\t\tnv50_dma_push(chan, p->va, p->va_len, no_prefetch);\n\t}\n\n\tret = nouveau_fence_emit(fence);\n\tif (ret) {\n\t\tnouveau_fence_unref(&exec_job->fence);\n\t\tNV_PRINTK(err, job->cli, \"error fencing pushbuf: %d\\n\", ret);\n\t\tWIND_RING(chan);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\texec_job->fence = NULL;\n\n\treturn &fence->base;\n}\n\nstatic void\nnouveau_exec_job_free(struct nouveau_job *job)\n{\n\tstruct nouveau_exec_job *exec_job = to_nouveau_exec_job(job);\n\n\tnouveau_job_free(job);\n\n\tkfree(exec_job->fence);\n\tkfree(exec_job->push.s);\n\tkfree(exec_job);\n}\n\nstatic enum drm_gpu_sched_stat\nnouveau_exec_job_timeout(struct nouveau_job *job)\n{\n\tstruct nouveau_exec_job *exec_job = to_nouveau_exec_job(job);\n\tstruct nouveau_channel *chan = exec_job->chan;\n\n\tif (unlikely(!atomic_read(&chan->killed)))\n\t\tnouveau_channel_kill(chan);\n\n\tNV_PRINTK(warn, job->cli, \"job timeout, channel %d killed!\\n\",\n\t\t  chan->chid);\n\n\tnouveau_sched_entity_fini(job->entity);\n\n\treturn DRM_GPU_SCHED_STAT_NOMINAL;\n}\n\nstatic struct nouveau_job_ops nouveau_exec_job_ops = {\n\t.submit = nouveau_exec_job_submit,\n\t.armed_submit = nouveau_exec_job_armed_submit,\n\t.run = nouveau_exec_job_run,\n\t.free = nouveau_exec_job_free,\n\t.timeout = nouveau_exec_job_timeout,\n};\n\nint\nnouveau_exec_job_init(struct nouveau_exec_job **pjob,\n\t\t      struct nouveau_exec_job_args *__args)\n{\n\tstruct nouveau_exec_job *job;\n\tstruct nouveau_job_args args = {};\n\tint i, ret;\n\n\tfor (i = 0; i < __args->push.count; i++) {\n\t\tstruct drm_nouveau_exec_push *p = &__args->push.s[i];\n\n\t\tif (unlikely(p->va_len > NV50_DMA_PUSH_MAX_LENGTH)) {\n\t\t\tNV_PRINTK(err, nouveau_cli(__args->file_priv),\n\t\t\t\t  \"pushbuf size exceeds limit: 0x%x max 0x%x\\n\",\n\t\t\t\t  p->va_len, NV50_DMA_PUSH_MAX_LENGTH);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tjob = *pjob = kzalloc(sizeof(*job), GFP_KERNEL);\n\tif (!job)\n\t\treturn -ENOMEM;\n\n\tjob->push.count = __args->push.count;\n\tif (__args->push.count) {\n\t\tjob->push.s = kmemdup(__args->push.s,\n\t\t\t\t      sizeof(*__args->push.s) *\n\t\t\t\t      __args->push.count,\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!job->push.s) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_job;\n\t\t}\n\t}\n\n\tjob->chan = __args->chan;\n\n\targs.sched_entity = __args->sched_entity;\n\targs.file_priv = __args->file_priv;\n\n\targs.in_sync.count = __args->in_sync.count;\n\targs.in_sync.s = __args->in_sync.s;\n\n\targs.out_sync.count = __args->out_sync.count;\n\targs.out_sync.s = __args->out_sync.s;\n\n\targs.ops = &nouveau_exec_job_ops;\n\targs.resv_usage = DMA_RESV_USAGE_WRITE;\n\n\tret = nouveau_job_init(&job->base, &args);\n\tif (ret)\n\t\tgoto err_free_pushs;\n\n\treturn 0;\n\nerr_free_pushs:\n\tkfree(job->push.s);\nerr_free_job:\n\tkfree(job);\n\t*pjob = NULL;\n\n\treturn ret;\n}\n\nstatic int\nnouveau_exec(struct nouveau_exec_job_args *args)\n{\n\tstruct nouveau_exec_job *job;\n\tint ret;\n\n\tret = nouveau_exec_job_init(&job, args);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nouveau_job_submit(&job->base);\n\tif (ret)\n\t\tgoto err_job_fini;\n\n\treturn 0;\n\nerr_job_fini:\n\tnouveau_job_fini(&job->base);\n\treturn ret;\n}\n\nstatic int\nnouveau_exec_ucopy(struct nouveau_exec_job_args *args,\n\t\t   struct drm_nouveau_exec *req)\n{\n\tstruct drm_nouveau_sync **s;\n\tu32 inc = req->wait_count;\n\tu64 ins = req->wait_ptr;\n\tu32 outc = req->sig_count;\n\tu64 outs = req->sig_ptr;\n\tu32 pushc = req->push_count;\n\tu64 pushs = req->push_ptr;\n\tint ret;\n\n\tif (pushc) {\n\t\targs->push.count = pushc;\n\t\targs->push.s = u_memcpya(pushs, pushc, sizeof(*args->push.s));\n\t\tif (IS_ERR(args->push.s))\n\t\t\treturn PTR_ERR(args->push.s);\n\t}\n\n\tif (inc) {\n\t\ts = &args->in_sync.s;\n\n\t\targs->in_sync.count = inc;\n\t\t*s = u_memcpya(ins, inc, sizeof(**s));\n\t\tif (IS_ERR(*s)) {\n\t\t\tret = PTR_ERR(*s);\n\t\t\tgoto err_free_pushs;\n\t\t}\n\t}\n\n\tif (outc) {\n\t\ts = &args->out_sync.s;\n\n\t\targs->out_sync.count = outc;\n\t\t*s = u_memcpya(outs, outc, sizeof(**s));\n\t\tif (IS_ERR(*s)) {\n\t\t\tret = PTR_ERR(*s);\n\t\t\tgoto err_free_ins;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_pushs:\n\tu_free(args->push.s);\nerr_free_ins:\n\tu_free(args->in_sync.s);\n\treturn ret;\n}\n\nstatic void\nnouveau_exec_ufree(struct nouveau_exec_job_args *args)\n{\n\tu_free(args->push.s);\n\tu_free(args->in_sync.s);\n\tu_free(args->out_sync.s);\n}\n\nint\nnouveau_exec_ioctl_exec(struct drm_device *dev,\n\t\t\tvoid *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_abi16_chan *chan16;\n\tstruct nouveau_channel *chan = NULL;\n\tstruct nouveau_exec_job_args args = {};\n\tstruct drm_nouveau_exec *req = data;\n\tint push_max, ret = 0;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\t \n\tif (unlikely(!nouveau_cli_uvmm(cli)))\n\t\treturn nouveau_abi16_put(abi16, -ENOSYS);\n\n\tlist_for_each_entry(chan16, &abi16->channels, head) {\n\t\tif (chan16->chan->chid == req->channel) {\n\t\t\tchan = chan16->chan;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -ENOENT);\n\n\tif (unlikely(atomic_read(&chan->killed)))\n\t\treturn nouveau_abi16_put(abi16, -ENODEV);\n\n\tif (!chan->dma.ib_max)\n\t\treturn nouveau_abi16_put(abi16, -ENOSYS);\n\n\tpush_max = nouveau_exec_push_max_from_ib_max(chan->dma.ib_max);\n\tif (unlikely(req->push_count > push_max)) {\n\t\tNV_PRINTK(err, cli, \"pushbuf push count exceeds limit: %d max %d\\n\",\n\t\t\t  req->push_count, push_max);\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\t}\n\n\tret = nouveau_exec_ucopy(&args, req);\n\tif (ret)\n\t\tgoto out;\n\n\targs.sched_entity = &chan16->sched_entity;\n\targs.file_priv = file_priv;\n\targs.chan = chan;\n\n\tret = nouveau_exec(&args);\n\tif (ret)\n\t\tgoto out_free_args;\n\nout_free_args:\n\tnouveau_exec_ufree(&args);\nout:\n\treturn nouveau_abi16_put(abi16, ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}