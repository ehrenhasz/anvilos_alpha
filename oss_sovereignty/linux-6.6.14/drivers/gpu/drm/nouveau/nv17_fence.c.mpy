{
  "module_name": "nv17_fence.c",
  "hash_id": "cc742a7d785d4bea6b730df4cf22c0ce7fb20aa8f7529aea8ba670240063c745",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nv17_fence.c",
  "human_readable_source": " \n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nv10_fence.h\"\n\n#include <nvif/push006c.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n\n#include <nvhw/class/cl176e.h>\n\nint\nnv17_fence_sync(struct nouveau_fence *fence,\n\t\tstruct nouveau_channel *prev, struct nouveau_channel *chan)\n{\n\tstruct nouveau_cli *cli = (void *)prev->user.client;\n\tstruct nv10_fence_priv *priv = chan->drm->fence;\n\tstruct nv10_fence_chan *fctx = chan->fence;\n\tstruct nvif_push *ppush = prev->chan.push;\n\tstruct nvif_push *npush = chan->chan.push;\n\tu32 value;\n\tint ret;\n\n\tif (!mutex_trylock(&cli->mutex))\n\t\treturn -EBUSY;\n\n\tspin_lock(&priv->lock);\n\tvalue = priv->sequence;\n\tpriv->sequence += 2;\n\tspin_unlock(&priv->lock);\n\n\tret = PUSH_WAIT(ppush, 5);\n\tif (!ret) {\n\t\tPUSH_MTHD(ppush, NV176E, SET_CONTEXT_DMA_SEMAPHORE, fctx->sema.handle,\n\t\t\t\t\t SEMAPHORE_OFFSET, 0,\n\t\t\t\t\t SEMAPHORE_ACQUIRE, value + 0,\n\t\t\t\t\t SEMAPHORE_RELEASE, value + 1);\n\t\tPUSH_KICK(ppush);\n\t}\n\n\tif (!ret && !(ret = PUSH_WAIT(npush, 5))) {\n\t\tPUSH_MTHD(npush, NV176E, SET_CONTEXT_DMA_SEMAPHORE, fctx->sema.handle,\n\t\t\t\t\t SEMAPHORE_OFFSET, 0,\n\t\t\t\t\t SEMAPHORE_ACQUIRE, value + 1,\n\t\t\t\t\t SEMAPHORE_RELEASE, value + 2);\n\t\tPUSH_KICK(npush);\n\t}\n\n\tmutex_unlock(&cli->mutex);\n\treturn 0;\n}\n\nstatic int\nnv17_fence_context_new(struct nouveau_channel *chan)\n{\n\tstruct nv10_fence_priv *priv = chan->drm->fence;\n\tstruct ttm_resource *reg = priv->bo->bo.resource;\n\tstruct nv10_fence_chan *fctx;\n\tu32 start = reg->start * PAGE_SIZE;\n\tu32 limit = start + priv->bo->bo.base.size - 1;\n\tint ret = 0;\n\n\tfctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);\n\tif (!fctx)\n\t\treturn -ENOMEM;\n\n\tnouveau_fence_context_new(chan, &fctx->base);\n\tfctx->base.emit = nv10_fence_emit;\n\tfctx->base.read = nv10_fence_read;\n\tfctx->base.sync = nv17_fence_sync;\n\n\tret = nvif_object_ctor(&chan->user, \"fenceCtxDma\", NvSema,\n\t\t\t       NV_DMA_FROM_MEMORY,\n\t\t\t       &(struct nv_dma_v0) {\n\t\t\t\t\t.target = NV_DMA_V0_TARGET_VRAM,\n\t\t\t\t\t.access = NV_DMA_V0_ACCESS_RDWR,\n\t\t\t\t\t.start = start,\n\t\t\t\t\t.limit = limit,\n\t\t\t       }, sizeof(struct nv_dma_v0),\n\t\t\t       &fctx->sema);\n\tif (ret)\n\t\tnv10_fence_context_del(chan);\n\treturn ret;\n}\n\nvoid\nnv17_fence_resume(struct nouveau_drm *drm)\n{\n\tstruct nv10_fence_priv *priv = drm->fence;\n\n\tnouveau_bo_wr32(priv->bo, 0, priv->sequence);\n}\n\nint\nnv17_fence_create(struct nouveau_drm *drm)\n{\n\tstruct nv10_fence_priv *priv;\n\tint ret = 0;\n\n\tpriv = drm->fence = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base.dtor = nv10_fence_destroy;\n\tpriv->base.resume = nv17_fence_resume;\n\tpriv->base.context_new = nv17_fence_context_new;\n\tpriv->base.context_del = nv10_fence_context_del;\n\tspin_lock_init(&priv->lock);\n\n\tret = nouveau_bo_new(&drm->client, 4096, 0x1000,\n\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM,\n\t\t\t     0, 0x0000, NULL, NULL, &priv->bo);\n\tif (!ret) {\n\t\tret = nouveau_bo_pin(priv->bo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\t\tif (!ret) {\n\t\t\tret = nouveau_bo_map(priv->bo);\n\t\t\tif (ret)\n\t\t\t\tnouveau_bo_unpin(priv->bo);\n\t\t}\n\t\tif (ret)\n\t\t\tnouveau_bo_ref(NULL, &priv->bo);\n\t}\n\n\tif (ret) {\n\t\tnv10_fence_destroy(drm);\n\t\treturn ret;\n\t}\n\n\tnouveau_bo_wr32(priv->bo, 0x000, 0x00000000);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}