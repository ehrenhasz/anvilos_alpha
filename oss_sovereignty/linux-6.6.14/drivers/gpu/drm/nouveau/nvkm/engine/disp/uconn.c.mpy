{
  "module_name": "uconn.c",
  "hash_id": "687b411c593098873cbb16abbe2afc583c5ac59a111b5277089972f5886a181c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/uconn.c",
  "human_readable_source": " \n#define nvkm_uconn(p) container_of((p), struct nvkm_conn, object)\n#include \"conn.h\"\n#include \"outp.h\"\n\n#include <core/client.h>\n#include <core/event.h>\n#include <subdev/gpio.h>\n#include <subdev/i2c.h>\n\n#include <nvif/if0011.h>\n\nstatic int\nnvkm_uconn_uevent_aux(struct nvkm_object *object, u64 token, u32 bits)\n{\n\tunion nvif_conn_event_args args;\n\n\targs.v0.version = 0;\n\targs.v0.types = 0;\n\tif (bits & NVKM_I2C_PLUG)\n\t\targs.v0.types |= NVIF_CONN_EVENT_V0_PLUG;\n\tif (bits & NVKM_I2C_UNPLUG)\n\t\targs.v0.types |= NVIF_CONN_EVENT_V0_UNPLUG;\n\tif (bits & NVKM_I2C_IRQ)\n\t\targs.v0.types |= NVIF_CONN_EVENT_V0_IRQ;\n\n\treturn object->client->event(token, &args, sizeof(args.v0));\n}\n\nstatic int\nnvkm_uconn_uevent_gpio(struct nvkm_object *object, u64 token, u32 bits)\n{\n\tunion nvif_conn_event_args args;\n\n\targs.v0.version = 0;\n\targs.v0.types = 0;\n\tif (bits & NVKM_GPIO_HI)\n\t\targs.v0.types |= NVIF_CONN_EVENT_V0_PLUG;\n\tif (bits & NVKM_GPIO_LO)\n\t\targs.v0.types |= NVIF_CONN_EVENT_V0_UNPLUG;\n\n\treturn object->client->event(token, &args, sizeof(args.v0));\n}\n\nstatic bool\nnvkm_connector_is_dp_dms(u8 type)\n{\n\tswitch (type) {\n\tcase DCB_CONNECTOR_DMS59_DP0:\n\tcase DCB_CONNECTOR_DMS59_DP1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int\nnvkm_uconn_uevent(struct nvkm_object *object, void *argv, u32 argc, struct nvkm_uevent *uevent)\n{\n\tstruct nvkm_conn *conn = nvkm_uconn(object);\n\tstruct nvkm_device *device = conn->disp->engine.subdev.device;\n\tstruct nvkm_outp *outp;\n\tunion nvif_conn_event_args *args = argv;\n\tu64 bits = 0;\n\n\tif (!uevent) {\n\t\tif (conn->info.hpd == DCB_GPIO_UNUSED)\n\t\t\treturn -ENOSYS;\n\t\treturn 0;\n\t}\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tlist_for_each_entry(outp, &conn->disp->outps, head) {\n\t\tif (outp->info.connector == conn->index)\n\t\t\tbreak;\n\t}\n\n\tif (&outp->head == &conn->disp->outps)\n\t\treturn -EINVAL;\n\n\tif (outp->dp.aux && !outp->info.location) {\n\t\tif (args->v0.types & NVIF_CONN_EVENT_V0_PLUG  ) bits |= NVKM_I2C_PLUG;\n\t\tif (args->v0.types & NVIF_CONN_EVENT_V0_UNPLUG) bits |= NVKM_I2C_UNPLUG;\n\t\tif (args->v0.types & NVIF_CONN_EVENT_V0_IRQ   ) bits |= NVKM_I2C_IRQ;\n\n\t\treturn nvkm_uevent_add(uevent, &device->i2c->event, outp->dp.aux->id, bits,\n\t\t\t\t       nvkm_uconn_uevent_aux);\n\t}\n\n\tif (args->v0.types & NVIF_CONN_EVENT_V0_PLUG  ) bits |= NVKM_GPIO_HI;\n\tif (args->v0.types & NVIF_CONN_EVENT_V0_UNPLUG) bits |= NVKM_GPIO_LO;\n\tif (args->v0.types & NVIF_CONN_EVENT_V0_IRQ) {\n\t\t \n\t\tif (!outp->info.location && !nvkm_connector_is_dp_dms(conn->info.type))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn nvkm_uevent_add(uevent, &device->gpio->event, conn->info.hpd, bits,\n\t\t\t       nvkm_uconn_uevent_gpio);\n}\n\nstatic int\nnvkm_uconn_mthd_hpd_status(struct nvkm_conn *conn, void *argv, u32 argc)\n{\n\tstruct nvkm_gpio *gpio = conn->disp->engine.subdev.device->gpio;\n\tunion nvif_conn_hpd_status_args *args = argv;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\targs->v0.support = gpio && conn->info.hpd != DCB_GPIO_UNUSED;\n\targs->v0.present = 0;\n\n\tif (args->v0.support) {\n\t\tint ret = nvkm_gpio_get(gpio, 0, DCB_GPIO_UNUSED, conn->info.hpd);\n\n\t\tif (WARN_ON(ret < 0)) {\n\t\t\targs->v0.support = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\targs->v0.present = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_uconn_mthd(struct nvkm_object *object, u32 mthd, void *argv, u32 argc)\n{\n\tstruct nvkm_conn *conn = nvkm_uconn(object);\n\n\tswitch (mthd) {\n\tcase NVIF_CONN_V0_HPD_STATUS: return nvkm_uconn_mthd_hpd_status(conn, argv, argc);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void *\nnvkm_uconn_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_conn *conn = nvkm_uconn(object);\n\tstruct nvkm_disp *disp = conn->disp;\n\n\tspin_lock(&disp->client.lock);\n\tconn->object.func = NULL;\n\tspin_unlock(&disp->client.lock);\n\treturn NULL;\n}\n\nstatic const struct nvkm_object_func\nnvkm_uconn = {\n\t.dtor = nvkm_uconn_dtor,\n\t.mthd = nvkm_uconn_mthd,\n\t.uevent = nvkm_uconn_uevent,\n};\n\nint\nnvkm_uconn_new(const struct nvkm_oclass *oclass, void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(oclass->parent);\n\tstruct nvkm_conn *cont, *conn = NULL;\n\tunion nvif_conn_args *args = argv;\n\tint ret;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tlist_for_each_entry(cont, &disp->conns, head) {\n\t\tif (cont->index == args->v0.id) {\n\t\t\tconn = cont;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!conn)\n\t\treturn -EINVAL;\n\n\tret = -EBUSY;\n\tspin_lock(&disp->client.lock);\n\tif (!conn->object.func) {\n\t\tnvkm_object_ctor(&nvkm_uconn, oclass, &conn->object);\n\t\t*pobject = &conn->object;\n\t\tret = 0;\n\t}\n\tspin_unlock(&disp->client.lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}