{
  "module_name": "usernv04.c",
  "hash_id": "46c0157908de1fc273ae204d1818c129780ee0f8e911874685dca5fca7fef05e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/dma/usernv04.c",
  "human_readable_source": " \n#define nv04_dmaobj(p) container_of((p), struct nv04_dmaobj, base)\n#include \"user.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n#include <subdev/mmu/vmm.h>\n\n#include <nvif/class.h>\n\nstruct nv04_dmaobj {\n\tstruct nvkm_dmaobj base;\n\tbool clone;\n\tu32 flags0;\n\tu32 flags2;\n};\n\nstatic int\nnv04_dmaobj_bind(struct nvkm_dmaobj *base, struct nvkm_gpuobj *parent,\n\t\t int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nv04_dmaobj *dmaobj = nv04_dmaobj(base);\n\tstruct nvkm_device *device = dmaobj->base.dma->engine.subdev.device;\n\tu64 offset = dmaobj->base.start & 0xfffff000;\n\tu64 adjust = dmaobj->base.start & 0x00000fff;\n\tu32 length = dmaobj->base.limit - dmaobj->base.start;\n\tint ret;\n\n\tif (dmaobj->clone) {\n\t\tstruct nvkm_memory *pgt =\n\t\t\tdevice->mmu->vmm->pd->pt[0]->memory;\n\t\tif (!dmaobj->base.start)\n\t\t\treturn nvkm_gpuobj_wrap(pgt, pgpuobj);\n\t\tnvkm_kmap(pgt);\n\t\toffset  = nvkm_ro32(pgt, 8 + (offset >> 10));\n\t\toffset &= 0xfffff000;\n\t\tnvkm_done(pgt);\n\t}\n\n\tret = nvkm_gpuobj_new(device, 16, align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, dmaobj->flags0 | (adjust << 20));\n\t\tnvkm_wo32(*pgpuobj, 0x04, length);\n\t\tnvkm_wo32(*pgpuobj, 0x08, dmaobj->flags2 | offset);\n\t\tnvkm_wo32(*pgpuobj, 0x0c, dmaobj->flags2 | offset);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nvkm_dmaobj_func\nnv04_dmaobj_func = {\n\t.bind = nv04_dmaobj_bind,\n};\n\nint\nnv04_dmaobj_new(struct nvkm_dma *dma, const struct nvkm_oclass *oclass,\n\t\tvoid *data, u32 size, struct nvkm_dmaobj **pdmaobj)\n{\n\tstruct nvkm_device *device = dma->engine.subdev.device;\n\tstruct nv04_dmaobj *dmaobj;\n\tint ret;\n\n\tif (!(dmaobj = kzalloc(sizeof(*dmaobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pdmaobj = &dmaobj->base;\n\n\tret = nvkm_dmaobj_ctor(&nv04_dmaobj_func, dma, oclass,\n\t\t\t       &data, &size, &dmaobj->base);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dmaobj->base.target == NV_MEM_TARGET_VM) {\n\t\tif (device->mmu->func == &nv04_mmu)\n\t\t\tdmaobj->clone = true;\n\t\tdmaobj->base.target = NV_MEM_TARGET_PCI;\n\t\tdmaobj->base.access = NV_MEM_ACCESS_RW;\n\t}\n\n\tdmaobj->flags0 = oclass->base.oclass;\n\tswitch (dmaobj->base.target) {\n\tcase NV_MEM_TARGET_VRAM:\n\t\tdmaobj->flags0 |= 0x00003000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_PCI:\n\t\tdmaobj->flags0 |= 0x00023000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_PCI_NOSNOOP:\n\t\tdmaobj->flags0 |= 0x00033000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dmaobj->base.access) {\n\tcase NV_MEM_ACCESS_RO:\n\t\tdmaobj->flags0 |= 0x00004000;\n\t\tbreak;\n\tcase NV_MEM_ACCESS_WO:\n\t\tdmaobj->flags0 |= 0x00008000;\n\t\tfallthrough;\n\tcase NV_MEM_ACCESS_RW:\n\t\tdmaobj->flags2 |= 0x00000002;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}