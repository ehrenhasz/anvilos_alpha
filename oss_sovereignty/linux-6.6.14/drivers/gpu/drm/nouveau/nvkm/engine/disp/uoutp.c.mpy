{
  "module_name": "uoutp.c",
  "hash_id": "edebb2cbdefd723f32dc37229f2a81cdf65e28c020f0b9b99619052238cbdc9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/uoutp.c",
  "human_readable_source": " \n#define nvkm_uoutp(p) container_of((p), struct nvkm_outp, object)\n#include \"outp.h\"\n#include \"dp.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <nvif/if0012.h>\n\nstatic int\nnvkm_uoutp_mthd_dp_mst_vcpi(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tunion nvif_outp_dp_mst_vcpi_args *args = argv;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\tif (!ior->func->dp || !ior->func->dp->vcpi || !nvkm_head_find(outp->disp, args->v0.head))\n\t\treturn -EINVAL;\n\n\tior->func->dp->vcpi(ior, args->v0.head, args->v0.start_slot, args->v0.num_slots,\n\t\t\t\t args->v0.pbn, args->v0.aligned_pbn);\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_dp_retrain(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tunion nvif_outp_dp_retrain_args *args = argv;\n\n\tif (argc != sizeof(args->vn))\n\t\treturn -ENOSYS;\n\n\tif (!atomic_read(&outp->dp.lt.done))\n\t\treturn 0;\n\n\treturn outp->func->acquire(outp);\n}\n\nstatic int\nnvkm_uoutp_mthd_dp_aux_pwr(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tunion nvif_outp_dp_aux_pwr_args *args = argv;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\toutp->dp.enabled = !!args->v0.state;\n\tnvkm_dp_enable(outp, outp->dp.enabled);\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_hda_eld(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tunion nvif_outp_hda_eld_args *args = argv;\n\n\tif (argc < sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\targc -= sizeof(args->v0);\n\n\tif (!ior->hda || !nvkm_head_find(outp->disp, args->v0.head))\n\t\treturn -EINVAL;\n\tif (argc > 0x60)\n\t\treturn -E2BIG;\n\n\tif (argc && args->v0.data[0]) {\n\t\tif (outp->info.type == DCB_OUTPUT_DP)\n\t\t\tior->func->dp->audio(ior, args->v0.head, true);\n\t\tior->func->hda->hpd(ior, args->v0.head, true);\n\t\tior->func->hda->eld(ior, args->v0.head, args->v0.data, argc);\n\t} else {\n\t\tif (outp->info.type == DCB_OUTPUT_DP)\n\t\t\tior->func->dp->audio(ior, args->v0.head, false);\n\t\tior->func->hda->hpd(ior, args->v0.head, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_infoframe(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tunion nvif_outp_infoframe_args *args = argv;\n\tssize_t size = argc - sizeof(*args);\n\n\tif (argc < sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\tif (!nvkm_head_find(outp->disp, args->v0.head))\n\t\treturn -EINVAL;\n\n\tswitch (ior->func->hdmi ? args->v0.type : 0xff) {\n\tcase NVIF_OUTP_INFOFRAME_V0_AVI:\n\t\tior->func->hdmi->infoframe_avi(ior, args->v0.head, &args->v0.data, size);\n\t\treturn 0;\n\tcase NVIF_OUTP_INFOFRAME_V0_VSI:\n\t\tior->func->hdmi->infoframe_vsi(ior, args->v0.head, &args->v0.data, size);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_uoutp_mthd_release(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tstruct nvkm_head *head = outp->asy.head;\n\tstruct nvkm_ior *ior = outp->ior;\n\tunion nvif_outp_release_args *args = argv;\n\n\tif (argc != sizeof(args->vn))\n\t\treturn -ENOSYS;\n\n\tif (ior->func->hdmi && head) {\n\t\tior->func->hdmi->infoframe_avi(ior, head->id, NULL, 0);\n\t\tior->func->hdmi->infoframe_vsi(ior, head->id, NULL, 0);\n\t\tior->func->hdmi->ctrl(ior, head->id, false, 0, 0);\n\t}\n\n\tnvkm_outp_release(outp, NVKM_OUTP_USER);\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_acquire_dp(struct nvkm_outp *outp, u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t   u8 link_nr, u8 link_bw, bool hda, bool mst)\n{\n\tint ret;\n\n\tret = nvkm_outp_acquire(outp, NVKM_OUTP_USER, hda);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(outp->dp.dpcd, dpcd, sizeof(outp->dp.dpcd));\n\toutp->dp.lt.nr = link_nr;\n\toutp->dp.lt.bw = link_bw;\n\toutp->dp.lt.mst = mst;\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_acquire_tmds(struct nvkm_outp *outp, u8 head, u8 hdmi, u8 hdmi_max_ac_packet,\n\t\t\t     u8 hdmi_rekey, u8 hdmi_scdc, u8 hdmi_hda)\n{\n\tstruct nvkm_ior *ior;\n\tint ret;\n\n\tif (!(outp->asy.head = nvkm_head_find(outp->disp, head)))\n\t\treturn -EINVAL;\n\n\tret = nvkm_outp_acquire(outp, NVKM_OUTP_USER, hdmi && hdmi_hda);\n\tif (ret)\n\t\treturn ret;\n\n\tior = outp->ior;\n\n\tif (hdmi) {\n\t\tif (!ior->func->hdmi ||\n\t\t    hdmi_max_ac_packet > 0x1f || hdmi_rekey > 0x7f ||\n\t\t    (hdmi_scdc && !ior->func->hdmi->scdc)) {\n\t\t\tnvkm_outp_release(outp, NVKM_OUTP_USER);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tior->func->hdmi->ctrl(ior, head, hdmi, hdmi_max_ac_packet, hdmi_rekey);\n\t\tif (ior->func->hdmi->scdc)\n\t\t\tior->func->hdmi->scdc(ior, hdmi_scdc);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_acquire_lvds(struct nvkm_outp *outp, bool dual, bool bpc8)\n{\n\tif (outp->info.type != DCB_OUTPUT_LVDS)\n\t\treturn -EINVAL;\n\n\toutp->lvds.dual = dual;\n\toutp->lvds.bpc8 = bpc8;\n\n\treturn nvkm_outp_acquire(outp, NVKM_OUTP_USER, false);\n}\n\nstatic int\nnvkm_uoutp_mthd_acquire(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tunion nvif_outp_acquire_args *args = argv;\n\tint ret;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\tif (outp->ior)\n\t\treturn -EBUSY;\n\n\tswitch (args->v0.proto) {\n\tcase NVIF_OUTP_ACQUIRE_V0_RGB_CRT:\n\t\tret = nvkm_outp_acquire(outp, NVKM_OUTP_USER, false);\n\t\tbreak;\n\tcase NVIF_OUTP_ACQUIRE_V0_TMDS:\n\t\tret = nvkm_uoutp_mthd_acquire_tmds(outp, args->v0.tmds.head,\n\t\t\t\t\t\t\t args->v0.tmds.hdmi,\n\t\t\t\t\t\t\t args->v0.tmds.hdmi_max_ac_packet,\n\t\t\t\t\t\t\t args->v0.tmds.hdmi_rekey,\n\t\t\t\t\t\t\t args->v0.tmds.hdmi_scdc,\n\t\t\t\t\t\t\t args->v0.tmds.hdmi_hda);\n\t\tbreak;\n\tcase NVIF_OUTP_ACQUIRE_V0_LVDS:\n\t\tret = nvkm_uoutp_mthd_acquire_lvds(outp, args->v0.lvds.dual, args->v0.lvds.bpc8);\n\t\tbreak;\n\tcase NVIF_OUTP_ACQUIRE_V0_DP:\n\t\tret = nvkm_uoutp_mthd_acquire_dp(outp, args->v0.dp.dpcd,\n\t\t\t\t\t\t       args->v0.dp.link_nr,\n\t\t\t\t\t\t       args->v0.dp.link_bw,\n\t\t\t\t\t\t       args->v0.dp.hda != 0,\n\t\t\t\t\t\t       args->v0.dp.mst != 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\targs->v0.or = outp->ior->id;\n\targs->v0.link = outp->ior->asy.link;\n\treturn 0;\n}\n\nstatic int\nnvkm_uoutp_mthd_load_detect(struct nvkm_outp *outp, void *argv, u32 argc)\n{\n\tunion nvif_outp_load_detect_args *args = argv;\n\tint ret;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tret = nvkm_outp_acquire(outp, NVKM_OUTP_PRIV, false);\n\tif (ret == 0) {\n\t\tif (outp->ior->func->sense) {\n\t\t\tret = outp->ior->func->sense(outp->ior, args->v0.data);\n\t\t\targs->v0.load = ret < 0 ? 0 : ret;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tnvkm_outp_release(outp, NVKM_OUTP_PRIV);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_uoutp_mthd_acquired(struct nvkm_outp *outp, u32 mthd, void *argv, u32 argc)\n{\n\tswitch (mthd) {\n\tcase NVIF_OUTP_V0_RELEASE    : return nvkm_uoutp_mthd_release    (outp, argv, argc);\n\tcase NVIF_OUTP_V0_INFOFRAME  : return nvkm_uoutp_mthd_infoframe  (outp, argv, argc);\n\tcase NVIF_OUTP_V0_HDA_ELD    : return nvkm_uoutp_mthd_hda_eld    (outp, argv, argc);\n\tcase NVIF_OUTP_V0_DP_RETRAIN : return nvkm_uoutp_mthd_dp_retrain (outp, argv, argc);\n\tcase NVIF_OUTP_V0_DP_MST_VCPI: return nvkm_uoutp_mthd_dp_mst_vcpi(outp, argv, argc);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_uoutp_mthd_noacquire(struct nvkm_outp *outp, u32 mthd, void *argv, u32 argc)\n{\n\tswitch (mthd) {\n\tcase NVIF_OUTP_V0_LOAD_DETECT: return nvkm_uoutp_mthd_load_detect(outp, argv, argc);\n\tcase NVIF_OUTP_V0_ACQUIRE    : return nvkm_uoutp_mthd_acquire    (outp, argv, argc);\n\tcase NVIF_OUTP_V0_DP_AUX_PWR : return nvkm_uoutp_mthd_dp_aux_pwr (outp, argv, argc);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nnvkm_uoutp_mthd(struct nvkm_object *object, u32 mthd, void *argv, u32 argc)\n{\n\tstruct nvkm_outp *outp = nvkm_uoutp(object);\n\tstruct nvkm_disp *disp = outp->disp;\n\tint ret;\n\n\tmutex_lock(&disp->super.mutex);\n\n\tret = nvkm_uoutp_mthd_noacquire(outp, mthd, argv, argc);\n\tif (ret <= 0)\n\t\tgoto done;\n\n\tif (outp->ior)\n\t\tret = nvkm_uoutp_mthd_acquired(outp, mthd, argv, argc);\n\telse\n\t\tret = -EIO;\n\ndone:\n\tmutex_unlock(&disp->super.mutex);\n\treturn ret;\n}\n\nstatic void *\nnvkm_uoutp_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_outp *outp = nvkm_uoutp(object);\n\tstruct nvkm_disp *disp = outp->disp;\n\n\tspin_lock(&disp->client.lock);\n\toutp->object.func = NULL;\n\tspin_unlock(&disp->client.lock);\n\treturn NULL;\n}\n\nstatic const struct nvkm_object_func\nnvkm_uoutp = {\n\t.dtor = nvkm_uoutp_dtor,\n\t.mthd = nvkm_uoutp_mthd,\n};\n\nint\nnvkm_uoutp_new(const struct nvkm_oclass *oclass, void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(oclass->parent);\n\tstruct nvkm_outp *outt, *outp = NULL;\n\tunion nvif_outp_args *args = argv;\n\tint ret;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tlist_for_each_entry(outt, &disp->outps, head) {\n\t\tif (outt->index == args->v0.id) {\n\t\t\toutp = outt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!outp)\n\t\treturn -EINVAL;\n\n\tret = -EBUSY;\n\tspin_lock(&disp->client.lock);\n\tif (!outp->object.func) {\n\t\tnvkm_object_ctor(&nvkm_uoutp, oclass, &outp->object);\n\t\t*pobject = &outp->object;\n\t\tret = 0;\n\t}\n\tspin_unlock(&disp->client.lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}