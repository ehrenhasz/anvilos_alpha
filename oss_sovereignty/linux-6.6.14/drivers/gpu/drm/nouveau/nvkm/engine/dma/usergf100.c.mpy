{
  "module_name": "usergf100.c",
  "hash_id": "0fa50be2736c88ac98c272d5930a13550e7fd99ee48ccca0a09caec213d6757f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/dma/usergf100.c",
  "human_readable_source": " \n#define gf100_dmaobj(p) container_of((p), struct gf100_dmaobj, base)\n#include \"user.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n\n#include <nvif/cl0002.h>\n#include <nvif/unpack.h>\n\nstruct gf100_dmaobj {\n\tstruct nvkm_dmaobj base;\n\tu32 flags0;\n\tu32 flags5;\n};\n\nstatic int\ngf100_dmaobj_bind(struct nvkm_dmaobj *base, struct nvkm_gpuobj *parent,\n\t\t  int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct gf100_dmaobj *dmaobj = gf100_dmaobj(base);\n\tstruct nvkm_device *device = dmaobj->base.dma->engine.subdev.device;\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 24, align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, dmaobj->flags0);\n\t\tnvkm_wo32(*pgpuobj, 0x04, lower_32_bits(dmaobj->base.limit));\n\t\tnvkm_wo32(*pgpuobj, 0x08, lower_32_bits(dmaobj->base.start));\n\t\tnvkm_wo32(*pgpuobj, 0x0c, upper_32_bits(dmaobj->base.limit) << 24 |\n\t\t\t\t\t  upper_32_bits(dmaobj->base.start));\n\t\tnvkm_wo32(*pgpuobj, 0x10, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x14, dmaobj->flags5);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nvkm_dmaobj_func\ngf100_dmaobj_func = {\n\t.bind = gf100_dmaobj_bind,\n};\n\nint\ngf100_dmaobj_new(struct nvkm_dma *dma, const struct nvkm_oclass *oclass,\n\t\t void *data, u32 size, struct nvkm_dmaobj **pdmaobj)\n{\n\tunion {\n\t\tstruct gf100_dma_v0 v0;\n\t} *args;\n\tstruct nvkm_object *parent = oclass->parent;\n\tstruct gf100_dmaobj *dmaobj;\n\tu32 kind, user, unkn;\n\tint ret;\n\n\tif (!(dmaobj = kzalloc(sizeof(*dmaobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pdmaobj = &dmaobj->base;\n\n\tret = nvkm_dmaobj_ctor(&gf100_dmaobj_func, dma, oclass,\n\t\t\t       &data, &size, &dmaobj->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret  = -ENOSYS;\n\targs = data;\n\n\tnvif_ioctl(parent, \"create gf100 dma size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(parent,\n\t\t\t   \"create gf100 dma vers %d priv %d kind %02x\\n\",\n\t\t\t   args->v0.version, args->v0.priv, args->v0.kind);\n\t\tkind = args->v0.kind;\n\t\tuser = args->v0.priv;\n\t\tunkn = 0;\n\t} else\n\tif (size == 0) {\n\t\tif (dmaobj->base.target != NV_MEM_TARGET_VM) {\n\t\t\tkind = GF100_DMA_V0_KIND_PITCH;\n\t\t\tuser = GF100_DMA_V0_PRIV_US;\n\t\t\tunkn = 2;\n\t\t} else {\n\t\t\tkind = GF100_DMA_V0_KIND_VM;\n\t\t\tuser = GF100_DMA_V0_PRIV_VM;\n\t\t\tunkn = 0;\n\t\t}\n\t} else\n\t\treturn ret;\n\n\tif (user > 2)\n\t\treturn -EINVAL;\n\tdmaobj->flags0 |= (kind << 22) | (user << 20) | oclass->base.oclass;\n\tdmaobj->flags5 |= (unkn << 16);\n\n\tswitch (dmaobj->base.target) {\n\tcase NV_MEM_TARGET_VM:\n\t\tdmaobj->flags0 |= 0x00000000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_VRAM:\n\t\tdmaobj->flags0 |= 0x00010000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_PCI:\n\t\tdmaobj->flags0 |= 0x00020000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_PCI_NOSNOOP:\n\t\tdmaobj->flags0 |= 0x00030000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dmaobj->base.access) {\n\tcase NV_MEM_ACCESS_VM:\n\t\tbreak;\n\tcase NV_MEM_ACCESS_RO:\n\t\tdmaobj->flags0 |= 0x00040000;\n\t\tbreak;\n\tcase NV_MEM_ACCESS_WO:\n\tcase NV_MEM_ACCESS_RW:\n\t\tdmaobj->flags0 |= 0x00080000;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}