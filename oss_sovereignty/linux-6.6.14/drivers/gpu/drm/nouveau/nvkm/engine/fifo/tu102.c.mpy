{
  "module_name": "tu102.c",
  "hash_id": "a6e852e1f3715f0e6ee513d9885fc10c4bb2277f297d9d1e39c7ca537a181ec8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/tu102.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"runl.h\"\n\n#include <core/memory.h>\n#include <subdev/mc.h>\n#include <subdev/vfn.h>\n\n#include <nvif/class.h>\n\nstatic u32\ntu102_chan_doorbell_handle(struct nvkm_chan *chan)\n{\n\treturn (chan->cgrp->runl->id << 16) | chan->id;\n}\n\nstatic void\ntu102_chan_start(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tgk104_chan_start(chan);\n\tnvkm_wr32(device, device->vfn->addr.user + 0x0090, chan->func->doorbell_handle(chan));\n}\n\nstatic const struct nvkm_chan_func\ntu102_chan = {\n\t.inst = &gf100_chan_inst,\n\t.userd = &gv100_chan_userd,\n\t.ramfc = &gv100_chan_ramfc,\n\t.bind = gk104_chan_bind_inst,\n\t.unbind = gk104_chan_unbind,\n\t.start = tu102_chan_start,\n\t.stop = gk104_chan_stop,\n\t.preempt = gk110_chan_preempt,\n\t.doorbell_handle = tu102_chan_doorbell_handle,\n};\n\nstatic bool\ntu102_runl_pending(struct nvkm_runl *runl)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\n\treturn nvkm_rd32(device, 0x002b0c + (runl->id * 0x10)) & 0x00008000;\n}\n\nstatic void\ntu102_runl_commit(struct nvkm_runl *runl, struct nvkm_memory *memory, u32 start, int count)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tu64 addr = nvkm_memory_addr(memory) + start;\n\t \n\n\tnvkm_wr32(device, 0x002b00 + (runl->id * 0x10), lower_32_bits(addr));\n\tnvkm_wr32(device, 0x002b04 + (runl->id * 0x10), upper_32_bits(addr));\n\tnvkm_wr32(device, 0x002b08 + (runl->id * 0x10), count);\n}\n\nstatic const struct nvkm_runl_func\ntu102_runl = {\n\t.runqs = 2,\n\t.size = 16,\n\t.update = nv50_runl_update,\n\t.insert_cgrp = gv100_runl_insert_cgrp,\n\t.insert_chan = gv100_runl_insert_chan,\n\t.commit = tu102_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = tu102_runl_pending,\n\t.block = gk104_runl_block,\n\t.allow = gk104_runl_allow,\n\t.preempt = gv100_runl_preempt,\n\t.preempt_pending = gf100_runl_preempt_pending,\n};\n\nstatic const struct nvkm_enum\ntu102_fifo_mmu_fault_engine[] = {\n\t{ 0x01, \"DISPLAY\" },\n\t{ 0x03, \"PTP\" },\n\t{ 0x06, \"PWR_PMU\" },\n\t{ 0x08, \"IFB\", NULL, NVKM_ENGINE_IFB },\n\t{ 0x09, \"PERF\" },\n\t{ 0x1f, \"PHYSICAL\" },\n\t{ 0x20, \"HOST0\" },\n\t{ 0x21, \"HOST1\" },\n\t{ 0x22, \"HOST2\" },\n\t{ 0x23, \"HOST3\" },\n\t{ 0x24, \"HOST4\" },\n\t{ 0x25, \"HOST5\" },\n\t{ 0x26, \"HOST6\" },\n\t{ 0x27, \"HOST7\" },\n\t{ 0x28, \"HOST8\" },\n\t{ 0x29, \"HOST9\" },\n\t{ 0x2a, \"HOST10\" },\n\t{ 0x2b, \"HOST11\" },\n\t{ 0x2c, \"HOST12\" },\n\t{ 0x2d, \"HOST13\" },\n\t{ 0x2e, \"HOST14\" },\n\t{ 0x80, \"BAR1\", NULL, NVKM_SUBDEV_BAR },\n\t{ 0xc0, \"BAR2\", NULL, NVKM_SUBDEV_INSTMEM },\n\t{}\n};\n\nconst struct nvkm_fifo_func_mmu_fault\ntu102_fifo_mmu_fault = {\n\t.recover = gf100_fifo_mmu_fault_recover,\n\t.access = gv100_fifo_mmu_fault_access,\n\t.engine = tu102_fifo_mmu_fault_engine,\n\t.reason = gv100_fifo_mmu_fault_reason,\n\t.hubclient = gv100_fifo_mmu_fault_hubclient,\n\t.gpcclient = gv100_fifo_mmu_fault_gpcclient,\n};\n\nvoid\ntu102_fifo_intr_ctxsw_timeout_info(struct nvkm_engn *engn, u32 info)\n{\n\tstruct nvkm_runl *runl = engn->runl;\n\tstruct nvkm_cgrp *cgrp;\n\tunsigned long flags;\n\n\t \n\tENGN_DEBUG(engn, \"CTXSW_TIMEOUT %08x\", info);\n\tif (info & 0xc0000000)\n\t\treturn;\n\n\t \n\tswitch (info & 0x0000c000) {\n\tcase 0x00004000:  \n\t\tcgrp = nvkm_runl_cgrp_get_cgid(runl, info & 0x3fff0000, &flags);\n\t\tbreak;\n\tcase 0x00008000:  \n\tcase 0x0000c000:  \n\t\tcgrp = nvkm_runl_cgrp_get_cgid(runl, info & 0x00003fff, &flags);\n\t\tbreak;\n\tdefault:\n\t\tcgrp = NULL;\n\t\tbreak;\n\t}\n\n\tif (!WARN_ON(!cgrp)) {\n\t\tnvkm_runl_rc_cgrp(cgrp);\n\t\tnvkm_cgrp_put(&cgrp, flags);\n\t}\n}\n\nstatic void\ntu102_fifo_intr_ctxsw_timeout(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\tu32 engm = nvkm_rd32(device, 0x002a30);\n\tu32 info;\n\n\tnvkm_runl_foreach(runl, fifo) {\n\t\tnvkm_runl_foreach_engn_cond(engn, runl, engm & BIT(engn->id)) {\n\t\t\tinfo = nvkm_rd32(device, 0x003200 + (engn->id * 4));\n\t\t\ttu102_fifo_intr_ctxsw_timeout_info(engn, info);\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x002a30, engm);\n}\n\nstatic void\ntu102_fifo_intr_sched(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tu32 intr = nvkm_rd32(subdev->device, 0x00254c);\n\tu32 code = intr & 0x000000ff;\n\n\tnvkm_error(subdev, \"SCHED_ERROR %02x\\n\", code);\n}\n\nstatic irqreturn_t\ntu102_fifo_intr(struct nvkm_inth *inth)\n{\n\tstruct nvkm_fifo *fifo = container_of(inth, typeof(*fifo), engine.subdev.inth);\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mask = nvkm_rd32(device, 0x002140);\n\tu32 stat = nvkm_rd32(device, 0x002100) & mask;\n\n\tif (stat & 0x00000001) {\n\t\tgk104_fifo_intr_bind(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00000001);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (stat & 0x00000002) {\n\t\ttu102_fifo_intr_ctxsw_timeout(fifo);\n\t\tstat &= ~0x00000002;\n\t}\n\n\tif (stat & 0x00000100) {\n\t\ttu102_fifo_intr_sched(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00000100);\n\t\tstat &= ~0x00000100;\n\t}\n\n\tif (stat & 0x00010000) {\n\t\tgk104_fifo_intr_chsw(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00010000);\n\t\tstat &= ~0x00010000;\n\t}\n\n\tif (stat & 0x20000000) {\n\t\tif (gf100_fifo_intr_pbdma(fifo))\n\t\t\tstat &= ~0x20000000;\n\t}\n\n\tif (stat & 0x40000000) {\n\t\tgk104_fifo_intr_runlist(fifo);\n\t\tstat &= ~0x40000000;\n\t}\n\n\tif (stat & 0x80000000) {\n\t\tnvkm_wr32(device, 0x002100, 0x80000000);\n\t\tnvkm_event_ntfy(&fifo->nonstall.event, 0, NVKM_FIFO_NONSTALL_EVENT);\n\t\tstat &= ~0x80000000;\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"INTR %08x\\n\", stat);\n\t\tspin_lock(&fifo->lock);\n\t\tnvkm_mask(device, 0x002140, stat, 0x00000000);\n\t\tspin_unlock(&fifo->lock);\n\t\tnvkm_wr32(device, 0x002100, stat);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ntu102_fifo_init_pbdmas(struct nvkm_fifo *fifo, u32 mask)\n{\n\t \n\tnvkm_mask(fifo->engine.subdev.device, 0xb65000, 0x80000000, 0x80000000);\n}\n\nstatic const struct nvkm_fifo_func\ntu102_fifo = {\n\t.chid_nr = gm200_fifo_chid_nr,\n\t.chid_ctor = gk110_fifo_chid_ctor,\n\t.runq_nr = gm200_fifo_runq_nr,\n\t.runl_ctor = gk104_fifo_runl_ctor,\n\t.init = gk104_fifo_init,\n\t.init_pbdmas = tu102_fifo_init_pbdmas,\n\t.intr = tu102_fifo_intr,\n\t.mmu_fault = &tu102_fifo_mmu_fault,\n\t.nonstall = &gf100_fifo_nonstall,\n\t.runl = &tu102_runl,\n\t.runq = &gv100_runq,\n\t.engn = &gv100_engn,\n\t.engn_ce = &gv100_engn_ce,\n\t.cgrp = {{ 0, 0, KEPLER_CHANNEL_GROUP_A  }, &gk110_cgrp, .force = true },\n\t.chan = {{ 0, 0, TURING_CHANNEL_GPFIFO_A }, &tu102_chan },\n};\n\nint\ntu102_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&tu102_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}