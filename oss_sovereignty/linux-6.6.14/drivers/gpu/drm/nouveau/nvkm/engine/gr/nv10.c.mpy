{
  "module_name": "nv10.c",
  "hash_id": "652bb90a98dac2427b0da65bcdd5e7253e415c3fe8b16a2dc7a30bd8151c4afd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv10.c",
  "human_readable_source": " \n#include \"nv10.h\"\n#include \"regs.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <engine/fifo.h>\n#include <engine/fifo/chan.h>\n#include <subdev/fb.h>\n\nstruct pipe_state {\n\tu32 pipe_0x0000[0x040/4];\n\tu32 pipe_0x0040[0x010/4];\n\tu32 pipe_0x0200[0x0c0/4];\n\tu32 pipe_0x4400[0x080/4];\n\tu32 pipe_0x6400[0x3b0/4];\n\tu32 pipe_0x6800[0x2f0/4];\n\tu32 pipe_0x6c00[0x030/4];\n\tu32 pipe_0x7000[0x130/4];\n\tu32 pipe_0x7400[0x0c0/4];\n\tu32 pipe_0x7800[0x0c0/4];\n};\n\nstatic int nv10_gr_ctx_regs[] = {\n\tNV10_PGRAPH_CTX_SWITCH(0),\n\tNV10_PGRAPH_CTX_SWITCH(1),\n\tNV10_PGRAPH_CTX_SWITCH(2),\n\tNV10_PGRAPH_CTX_SWITCH(3),\n\tNV10_PGRAPH_CTX_SWITCH(4),\n\tNV10_PGRAPH_CTX_CACHE(0, 0),\n\tNV10_PGRAPH_CTX_CACHE(0, 1),\n\tNV10_PGRAPH_CTX_CACHE(0, 2),\n\tNV10_PGRAPH_CTX_CACHE(0, 3),\n\tNV10_PGRAPH_CTX_CACHE(0, 4),\n\tNV10_PGRAPH_CTX_CACHE(1, 0),\n\tNV10_PGRAPH_CTX_CACHE(1, 1),\n\tNV10_PGRAPH_CTX_CACHE(1, 2),\n\tNV10_PGRAPH_CTX_CACHE(1, 3),\n\tNV10_PGRAPH_CTX_CACHE(1, 4),\n\tNV10_PGRAPH_CTX_CACHE(2, 0),\n\tNV10_PGRAPH_CTX_CACHE(2, 1),\n\tNV10_PGRAPH_CTX_CACHE(2, 2),\n\tNV10_PGRAPH_CTX_CACHE(2, 3),\n\tNV10_PGRAPH_CTX_CACHE(2, 4),\n\tNV10_PGRAPH_CTX_CACHE(3, 0),\n\tNV10_PGRAPH_CTX_CACHE(3, 1),\n\tNV10_PGRAPH_CTX_CACHE(3, 2),\n\tNV10_PGRAPH_CTX_CACHE(3, 3),\n\tNV10_PGRAPH_CTX_CACHE(3, 4),\n\tNV10_PGRAPH_CTX_CACHE(4, 0),\n\tNV10_PGRAPH_CTX_CACHE(4, 1),\n\tNV10_PGRAPH_CTX_CACHE(4, 2),\n\tNV10_PGRAPH_CTX_CACHE(4, 3),\n\tNV10_PGRAPH_CTX_CACHE(4, 4),\n\tNV10_PGRAPH_CTX_CACHE(5, 0),\n\tNV10_PGRAPH_CTX_CACHE(5, 1),\n\tNV10_PGRAPH_CTX_CACHE(5, 2),\n\tNV10_PGRAPH_CTX_CACHE(5, 3),\n\tNV10_PGRAPH_CTX_CACHE(5, 4),\n\tNV10_PGRAPH_CTX_CACHE(6, 0),\n\tNV10_PGRAPH_CTX_CACHE(6, 1),\n\tNV10_PGRAPH_CTX_CACHE(6, 2),\n\tNV10_PGRAPH_CTX_CACHE(6, 3),\n\tNV10_PGRAPH_CTX_CACHE(6, 4),\n\tNV10_PGRAPH_CTX_CACHE(7, 0),\n\tNV10_PGRAPH_CTX_CACHE(7, 1),\n\tNV10_PGRAPH_CTX_CACHE(7, 2),\n\tNV10_PGRAPH_CTX_CACHE(7, 3),\n\tNV10_PGRAPH_CTX_CACHE(7, 4),\n\tNV10_PGRAPH_CTX_USER,\n\tNV04_PGRAPH_DMA_START_0,\n\tNV04_PGRAPH_DMA_START_1,\n\tNV04_PGRAPH_DMA_LENGTH,\n\tNV04_PGRAPH_DMA_MISC,\n\tNV10_PGRAPH_DMA_PITCH,\n\tNV04_PGRAPH_BOFFSET0,\n\tNV04_PGRAPH_BBASE0,\n\tNV04_PGRAPH_BLIMIT0,\n\tNV04_PGRAPH_BOFFSET1,\n\tNV04_PGRAPH_BBASE1,\n\tNV04_PGRAPH_BLIMIT1,\n\tNV04_PGRAPH_BOFFSET2,\n\tNV04_PGRAPH_BBASE2,\n\tNV04_PGRAPH_BLIMIT2,\n\tNV04_PGRAPH_BOFFSET3,\n\tNV04_PGRAPH_BBASE3,\n\tNV04_PGRAPH_BLIMIT3,\n\tNV04_PGRAPH_BOFFSET4,\n\tNV04_PGRAPH_BBASE4,\n\tNV04_PGRAPH_BLIMIT4,\n\tNV04_PGRAPH_BOFFSET5,\n\tNV04_PGRAPH_BBASE5,\n\tNV04_PGRAPH_BLIMIT5,\n\tNV04_PGRAPH_BPITCH0,\n\tNV04_PGRAPH_BPITCH1,\n\tNV04_PGRAPH_BPITCH2,\n\tNV04_PGRAPH_BPITCH3,\n\tNV04_PGRAPH_BPITCH4,\n\tNV10_PGRAPH_SURFACE,\n\tNV10_PGRAPH_STATE,\n\tNV04_PGRAPH_BSWIZZLE2,\n\tNV04_PGRAPH_BSWIZZLE5,\n\tNV04_PGRAPH_BPIXEL,\n\tNV10_PGRAPH_NOTIFY,\n\tNV04_PGRAPH_PATT_COLOR0,\n\tNV04_PGRAPH_PATT_COLOR1,\n\tNV04_PGRAPH_PATT_COLORRAM,  \n\t0x00400904,\n\t0x00400908,\n\t0x0040090c,\n\t0x00400910,\n\t0x00400914,\n\t0x00400918,\n\t0x0040091c,\n\t0x00400920,\n\t0x00400924,\n\t0x00400928,\n\t0x0040092c,\n\t0x00400930,\n\t0x00400934,\n\t0x00400938,\n\t0x0040093c,\n\t0x00400940,\n\t0x00400944,\n\t0x00400948,\n\t0x0040094c,\n\t0x00400950,\n\t0x00400954,\n\t0x00400958,\n\t0x0040095c,\n\t0x00400960,\n\t0x00400964,\n\t0x00400968,\n\t0x0040096c,\n\t0x00400970,\n\t0x00400974,\n\t0x00400978,\n\t0x0040097c,\n\t0x00400980,\n\t0x00400984,\n\t0x00400988,\n\t0x0040098c,\n\t0x00400990,\n\t0x00400994,\n\t0x00400998,\n\t0x0040099c,\n\t0x004009a0,\n\t0x004009a4,\n\t0x004009a8,\n\t0x004009ac,\n\t0x004009b0,\n\t0x004009b4,\n\t0x004009b8,\n\t0x004009bc,\n\t0x004009c0,\n\t0x004009c4,\n\t0x004009c8,\n\t0x004009cc,\n\t0x004009d0,\n\t0x004009d4,\n\t0x004009d8,\n\t0x004009dc,\n\t0x004009e0,\n\t0x004009e4,\n\t0x004009e8,\n\t0x004009ec,\n\t0x004009f0,\n\t0x004009f4,\n\t0x004009f8,\n\t0x004009fc,\n\tNV04_PGRAPH_PATTERN,\t \n\t0x0040080c,\n\tNV04_PGRAPH_PATTERN_SHAPE,\n\tNV03_PGRAPH_MONO_COLOR0,\n\tNV04_PGRAPH_ROP3,\n\tNV04_PGRAPH_CHROMA,\n\tNV04_PGRAPH_BETA_AND,\n\tNV04_PGRAPH_BETA_PREMULT,\n\t0x00400e70,\n\t0x00400e74,\n\t0x00400e78,\n\t0x00400e7c,\n\t0x00400e80,\n\t0x00400e84,\n\t0x00400e88,\n\t0x00400e8c,\n\t0x00400ea0,\n\t0x00400ea4,\n\t0x00400ea8,\n\t0x00400e90,\n\t0x00400e94,\n\t0x00400e98,\n\t0x00400e9c,\n\tNV10_PGRAPH_WINDOWCLIP_HORIZONTAL,  \n\tNV10_PGRAPH_WINDOWCLIP_VERTICAL,    \n\t0x00400f04,\n\t0x00400f24,\n\t0x00400f08,\n\t0x00400f28,\n\t0x00400f0c,\n\t0x00400f2c,\n\t0x00400f10,\n\t0x00400f30,\n\t0x00400f14,\n\t0x00400f34,\n\t0x00400f18,\n\t0x00400f38,\n\t0x00400f1c,\n\t0x00400f3c,\n\tNV10_PGRAPH_XFMODE0,\n\tNV10_PGRAPH_XFMODE1,\n\tNV10_PGRAPH_GLOBALSTATE0,\n\tNV10_PGRAPH_GLOBALSTATE1,\n\tNV04_PGRAPH_STORED_FMT,\n\tNV04_PGRAPH_SOURCE_COLOR,\n\tNV03_PGRAPH_ABS_X_RAM,\t \n\tNV03_PGRAPH_ABS_Y_RAM,\t \n\t0x00400404,\n\t0x00400484,\n\t0x00400408,\n\t0x00400488,\n\t0x0040040c,\n\t0x0040048c,\n\t0x00400410,\n\t0x00400490,\n\t0x00400414,\n\t0x00400494,\n\t0x00400418,\n\t0x00400498,\n\t0x0040041c,\n\t0x0040049c,\n\t0x00400420,\n\t0x004004a0,\n\t0x00400424,\n\t0x004004a4,\n\t0x00400428,\n\t0x004004a8,\n\t0x0040042c,\n\t0x004004ac,\n\t0x00400430,\n\t0x004004b0,\n\t0x00400434,\n\t0x004004b4,\n\t0x00400438,\n\t0x004004b8,\n\t0x0040043c,\n\t0x004004bc,\n\t0x00400440,\n\t0x004004c0,\n\t0x00400444,\n\t0x004004c4,\n\t0x00400448,\n\t0x004004c8,\n\t0x0040044c,\n\t0x004004cc,\n\t0x00400450,\n\t0x004004d0,\n\t0x00400454,\n\t0x004004d4,\n\t0x00400458,\n\t0x004004d8,\n\t0x0040045c,\n\t0x004004dc,\n\t0x00400460,\n\t0x004004e0,\n\t0x00400464,\n\t0x004004e4,\n\t0x00400468,\n\t0x004004e8,\n\t0x0040046c,\n\t0x004004ec,\n\t0x00400470,\n\t0x004004f0,\n\t0x00400474,\n\t0x004004f4,\n\t0x00400478,\n\t0x004004f8,\n\t0x0040047c,\n\t0x004004fc,\n\tNV03_PGRAPH_ABS_UCLIP_XMIN,\n\tNV03_PGRAPH_ABS_UCLIP_XMAX,\n\tNV03_PGRAPH_ABS_UCLIP_YMIN,\n\tNV03_PGRAPH_ABS_UCLIP_YMAX,\n\t0x00400550,\n\t0x00400558,\n\t0x00400554,\n\t0x0040055c,\n\tNV03_PGRAPH_ABS_UCLIPA_XMIN,\n\tNV03_PGRAPH_ABS_UCLIPA_XMAX,\n\tNV03_PGRAPH_ABS_UCLIPA_YMIN,\n\tNV03_PGRAPH_ABS_UCLIPA_YMAX,\n\tNV03_PGRAPH_ABS_ICLIP_XMAX,\n\tNV03_PGRAPH_ABS_ICLIP_YMAX,\n\tNV03_PGRAPH_XY_LOGIC_MISC0,\n\tNV03_PGRAPH_XY_LOGIC_MISC1,\n\tNV03_PGRAPH_XY_LOGIC_MISC2,\n\tNV03_PGRAPH_XY_LOGIC_MISC3,\n\tNV03_PGRAPH_CLIPX_0,\n\tNV03_PGRAPH_CLIPX_1,\n\tNV03_PGRAPH_CLIPY_0,\n\tNV03_PGRAPH_CLIPY_1,\n\tNV10_PGRAPH_COMBINER0_IN_ALPHA,\n\tNV10_PGRAPH_COMBINER1_IN_ALPHA,\n\tNV10_PGRAPH_COMBINER0_IN_RGB,\n\tNV10_PGRAPH_COMBINER1_IN_RGB,\n\tNV10_PGRAPH_COMBINER_COLOR0,\n\tNV10_PGRAPH_COMBINER_COLOR1,\n\tNV10_PGRAPH_COMBINER0_OUT_ALPHA,\n\tNV10_PGRAPH_COMBINER1_OUT_ALPHA,\n\tNV10_PGRAPH_COMBINER0_OUT_RGB,\n\tNV10_PGRAPH_COMBINER1_OUT_RGB,\n\tNV10_PGRAPH_COMBINER_FINAL0,\n\tNV10_PGRAPH_COMBINER_FINAL1,\n\t0x00400e00,\n\t0x00400e04,\n\t0x00400e08,\n\t0x00400e0c,\n\t0x00400e10,\n\t0x00400e14,\n\t0x00400e18,\n\t0x00400e1c,\n\t0x00400e20,\n\t0x00400e24,\n\t0x00400e28,\n\t0x00400e2c,\n\t0x00400e30,\n\t0x00400e34,\n\t0x00400e38,\n\t0x00400e3c,\n\tNV04_PGRAPH_PASSTHRU_0,\n\tNV04_PGRAPH_PASSTHRU_1,\n\tNV04_PGRAPH_PASSTHRU_2,\n\tNV10_PGRAPH_DIMX_TEXTURE,\n\tNV10_PGRAPH_WDIMX_TEXTURE,\n\tNV10_PGRAPH_DVD_COLORFMT,\n\tNV10_PGRAPH_SCALED_FORMAT,\n\tNV04_PGRAPH_MISC24_0,\n\tNV04_PGRAPH_MISC24_1,\n\tNV04_PGRAPH_MISC24_2,\n\tNV03_PGRAPH_X_MISC,\n\tNV03_PGRAPH_Y_MISC,\n\tNV04_PGRAPH_VALID1,\n\tNV04_PGRAPH_VALID2,\n};\n\nstatic int nv17_gr_ctx_regs[] = {\n\tNV10_PGRAPH_DEBUG_4,\n\t0x004006b0,\n\t0x00400eac,\n\t0x00400eb0,\n\t0x00400eb4,\n\t0x00400eb8,\n\t0x00400ebc,\n\t0x00400ec0,\n\t0x00400ec4,\n\t0x00400ec8,\n\t0x00400ecc,\n\t0x00400ed0,\n\t0x00400ed4,\n\t0x00400ed8,\n\t0x00400edc,\n\t0x00400ee0,\n\t0x00400a00,\n\t0x00400a04,\n};\n\n#define nv10_gr(p) container_of((p), struct nv10_gr, base)\n\nstruct nv10_gr {\n\tstruct nvkm_gr base;\n\tstruct nv10_gr_chan *chan[32];\n\tspinlock_t lock;\n};\n\n#define nv10_gr_chan(p) container_of((p), struct nv10_gr_chan, object)\n\nstruct nv10_gr_chan {\n\tstruct nvkm_object object;\n\tstruct nv10_gr *gr;\n\tint chid;\n\tint nv10[ARRAY_SIZE(nv10_gr_ctx_regs)];\n\tint nv17[ARRAY_SIZE(nv17_gr_ctx_regs)];\n\tstruct pipe_state pipe_state;\n\tu32 lma_window[4];\n};\n\n\n \n\n#define PIPE_SAVE(gr, state, addr)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint __i;\t\t\t\t\t\t\\\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, addr);\t\t\\\n\t\tfor (__i = 0; __i < ARRAY_SIZE(state); __i++)\t\t\\\n\t\t\tstate[__i] = nvkm_rd32(device, NV10_PGRAPH_PIPE_DATA); \\\n\t} while (0)\n\n#define PIPE_RESTORE(gr, state, addr)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint __i;\t\t\t\t\t\t\\\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, addr);\t\t\\\n\t\tfor (__i = 0; __i < ARRAY_SIZE(state); __i++)\t\t\\\n\t\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, state[__i]); \\\n\t} while (0)\n\nstatic void\nnv17_gr_mthd_lma_window(struct nv10_gr_chan *chan, u32 mthd, u32 data)\n{\n\tstruct nvkm_device *device = chan->object.engine->subdev.device;\n\tstruct nvkm_gr *gr = &chan->gr->base;\n\tstruct pipe_state *pipe = &chan->pipe_state;\n\tu32 pipe_0x0040[1], pipe_0x64c0[8], pipe_0x6a80[3], pipe_0x6ab0[3];\n\tu32 xfmode0, xfmode1;\n\tint i;\n\n\tchan->lma_window[(mthd - 0x1638) / 4] = data;\n\n\tif (mthd != 0x1644)\n\t\treturn;\n\n\tnv04_gr_idle(gr);\n\n\tPIPE_SAVE(device, pipe_0x0040, 0x0040);\n\tPIPE_SAVE(device, pipe->pipe_0x0200, 0x0200);\n\n\tPIPE_RESTORE(device, chan->lma_window, 0x6790);\n\n\tnv04_gr_idle(gr);\n\n\txfmode0 = nvkm_rd32(device, NV10_PGRAPH_XFMODE0);\n\txfmode1 = nvkm_rd32(device, NV10_PGRAPH_XFMODE1);\n\n\tPIPE_SAVE(device, pipe->pipe_0x4400, 0x4400);\n\tPIPE_SAVE(device, pipe_0x64c0, 0x64c0);\n\tPIPE_SAVE(device, pipe_0x6ab0, 0x6ab0);\n\tPIPE_SAVE(device, pipe_0x6a80, 0x6a80);\n\n\tnv04_gr_idle(gr);\n\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE0, 0x10000000);\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE1, 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x000064c0);\n\tfor (i = 0; i < 4; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\n\tfor (i = 0; i < 4; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000000);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x00006ab0);\n\tfor (i = 0; i < 3; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x00006a80);\n\tfor (i = 0; i < 3; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000000);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x00000040);\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000008);\n\n\tPIPE_RESTORE(device, pipe->pipe_0x0200, 0x0200);\n\n\tnv04_gr_idle(gr);\n\n\tPIPE_RESTORE(device, pipe_0x0040, 0x0040);\n\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE0, xfmode0);\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE1, xfmode1);\n\n\tPIPE_RESTORE(device, pipe_0x64c0, 0x64c0);\n\tPIPE_RESTORE(device, pipe_0x6ab0, 0x6ab0);\n\tPIPE_RESTORE(device, pipe_0x6a80, 0x6a80);\n\tPIPE_RESTORE(device, pipe->pipe_0x4400, 0x4400);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x000000c0);\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000000);\n\n\tnv04_gr_idle(gr);\n}\n\nstatic void\nnv17_gr_mthd_lma_enable(struct nv10_gr_chan *chan, u32 mthd, u32 data)\n{\n\tstruct nvkm_device *device = chan->object.engine->subdev.device;\n\tstruct nvkm_gr *gr = &chan->gr->base;\n\n\tnv04_gr_idle(gr);\n\n\tnvkm_mask(device, NV10_PGRAPH_DEBUG_4, 0x00000100, 0x00000100);\n\tnvkm_mask(device, 0x4006b0, 0x08000000, 0x08000000);\n}\n\nstatic bool\nnv17_gr_mthd_celcius(struct nv10_gr_chan *chan, u32 mthd, u32 data)\n{\n\tvoid (*func)(struct nv10_gr_chan *, u32, u32);\n\tswitch (mthd) {\n\tcase 0x1638 ... 0x1644:\n\t\t     func = nv17_gr_mthd_lma_window; break;\n\tcase 0x1658: func = nv17_gr_mthd_lma_enable; break;\n\tdefault:\n\t\treturn false;\n\t}\n\tfunc(chan, mthd, data);\n\treturn true;\n}\n\nstatic bool\nnv10_gr_mthd(struct nv10_gr_chan *chan, u8 class, u32 mthd, u32 data)\n{\n\tbool (*func)(struct nv10_gr_chan *, u32, u32);\n\tswitch (class) {\n\tcase 0x99: func = nv17_gr_mthd_celcius; break;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn func(chan, mthd, data);\n}\n\n \n\nstatic struct nv10_gr_chan *\nnv10_gr_channel(struct nv10_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tstruct nv10_gr_chan *chan = NULL;\n\tif (nvkm_rd32(device, 0x400144) & 0x00010000) {\n\t\tint chid = nvkm_rd32(device, 0x400148) >> 24;\n\t\tif (chid < ARRAY_SIZE(gr->chan))\n\t\t\tchan = gr->chan[chid];\n\t}\n\treturn chan;\n}\n\nstatic void\nnv10_gr_save_pipe(struct nv10_gr_chan *chan)\n{\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct pipe_state *pipe = &chan->pipe_state;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tPIPE_SAVE(gr, pipe->pipe_0x4400, 0x4400);\n\tPIPE_SAVE(gr, pipe->pipe_0x0200, 0x0200);\n\tPIPE_SAVE(gr, pipe->pipe_0x6400, 0x6400);\n\tPIPE_SAVE(gr, pipe->pipe_0x6800, 0x6800);\n\tPIPE_SAVE(gr, pipe->pipe_0x6c00, 0x6c00);\n\tPIPE_SAVE(gr, pipe->pipe_0x7000, 0x7000);\n\tPIPE_SAVE(gr, pipe->pipe_0x7400, 0x7400);\n\tPIPE_SAVE(gr, pipe->pipe_0x7800, 0x7800);\n\tPIPE_SAVE(gr, pipe->pipe_0x0040, 0x0040);\n\tPIPE_SAVE(gr, pipe->pipe_0x0000, 0x0000);\n}\n\nstatic void\nnv10_gr_load_pipe(struct nv10_gr_chan *chan)\n{\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct pipe_state *pipe = &chan->pipe_state;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 xfmode0, xfmode1;\n\tint i;\n\n\tnv04_gr_idle(&gr->base);\n\t \n\txfmode0 = nvkm_rd32(device, NV10_PGRAPH_XFMODE0);\n\txfmode1 = nvkm_rd32(device, NV10_PGRAPH_XFMODE1);\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE0, 0x10000000);\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE1, 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x000064c0);\n\tfor (i = 0; i < 4; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\n\tfor (i = 0; i < 4; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000000);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x00006ab0);\n\tfor (i = 0; i < 3; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x3f800000);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x00006a80);\n\tfor (i = 0; i < 3; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000000);\n\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_ADDRESS, 0x00000040);\n\tnvkm_wr32(device, NV10_PGRAPH_PIPE_DATA, 0x00000008);\n\n\n\tPIPE_RESTORE(gr, pipe->pipe_0x0200, 0x0200);\n\tnv04_gr_idle(&gr->base);\n\n\t \n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE0, xfmode0);\n\tnvkm_wr32(device, NV10_PGRAPH_XFMODE1, xfmode1);\n\tPIPE_RESTORE(gr, pipe->pipe_0x6400, 0x6400);\n\tPIPE_RESTORE(gr, pipe->pipe_0x6800, 0x6800);\n\tPIPE_RESTORE(gr, pipe->pipe_0x6c00, 0x6c00);\n\tPIPE_RESTORE(gr, pipe->pipe_0x7000, 0x7000);\n\tPIPE_RESTORE(gr, pipe->pipe_0x7400, 0x7400);\n\tPIPE_RESTORE(gr, pipe->pipe_0x7800, 0x7800);\n\tPIPE_RESTORE(gr, pipe->pipe_0x4400, 0x4400);\n\tPIPE_RESTORE(gr, pipe->pipe_0x0000, 0x0000);\n\tPIPE_RESTORE(gr, pipe->pipe_0x0040, 0x0040);\n\tnv04_gr_idle(&gr->base);\n}\n\nstatic void\nnv10_gr_create_pipe(struct nv10_gr_chan *chan)\n{\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct pipe_state *pipe_state = &chan->pipe_state;\n\tu32 *pipe_state_addr;\n\tint i;\n#define PIPE_INIT(addr) \\\n\tdo { \\\n\t\tpipe_state_addr = pipe_state->pipe_##addr; \\\n\t} while (0)\n#define PIPE_INIT_END(addr) \\\n\tdo { \\\n\t\tu32 *__end_addr = pipe_state->pipe_##addr + \\\n\t\t\t\tARRAY_SIZE(pipe_state->pipe_##addr); \\\n\t\tif (pipe_state_addr != __end_addr) \\\n\t\t\tnvkm_error(subdev, \"incomplete pipe init for 0x%x :  %p/%p\\n\", \\\n\t\t\t\taddr, pipe_state_addr, __end_addr); \\\n\t} while (0)\n#define NV_WRITE_PIPE_INIT(value) *(pipe_state_addr++) = value\n\n\tPIPE_INIT(0x0200);\n\tfor (i = 0; i < 48; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x0200);\n\n\tPIPE_INIT(0x6400);\n\tfor (i = 0; i < 211; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tNV_WRITE_PIPE_INIT(0x40000000);\n\tNV_WRITE_PIPE_INIT(0x40000000);\n\tNV_WRITE_PIPE_INIT(0x40000000);\n\tNV_WRITE_PIPE_INIT(0x40000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x3f000000);\n\tNV_WRITE_PIPE_INIT(0x3f000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tPIPE_INIT_END(0x6400);\n\n\tPIPE_INIT(0x6800);\n\tfor (i = 0; i < 162; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x3f800000);\n\tfor (i = 0; i < 25; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x6800);\n\n\tPIPE_INIT(0x6c00);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0xbf800000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x6c00);\n\n\tPIPE_INIT(0x7000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x00000000);\n\tNV_WRITE_PIPE_INIT(0x7149f2ca);\n\tfor (i = 0; i < 35; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x7000);\n\n\tPIPE_INIT(0x7400);\n\tfor (i = 0; i < 48; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x7400);\n\n\tPIPE_INIT(0x7800);\n\tfor (i = 0; i < 48; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x7800);\n\n\tPIPE_INIT(0x4400);\n\tfor (i = 0; i < 32; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x4400);\n\n\tPIPE_INIT(0x0000);\n\tfor (i = 0; i < 16; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x0000);\n\n\tPIPE_INIT(0x0040);\n\tfor (i = 0; i < 4; i++)\n\t\tNV_WRITE_PIPE_INIT(0x00000000);\n\tPIPE_INIT_END(0x0040);\n\n#undef PIPE_INIT\n#undef PIPE_INIT_END\n#undef NV_WRITE_PIPE_INIT\n}\n\nstatic int\nnv10_gr_ctx_regs_find_offset(struct nv10_gr *gr, int reg)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(nv10_gr_ctx_regs); i++) {\n\t\tif (nv10_gr_ctx_regs[i] == reg)\n\t\t\treturn i;\n\t}\n\tnvkm_error(subdev, \"unknown offset nv10_ctx_regs %d\\n\", reg);\n\treturn -1;\n}\n\nstatic int\nnv17_gr_ctx_regs_find_offset(struct nv10_gr *gr, int reg)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(nv17_gr_ctx_regs); i++) {\n\t\tif (nv17_gr_ctx_regs[i] == reg)\n\t\t\treturn i;\n\t}\n\tnvkm_error(subdev, \"unknown offset nv17_ctx_regs %d\\n\", reg);\n\treturn -1;\n}\n\nstatic void\nnv10_gr_load_dma_vtxbuf(struct nv10_gr_chan *chan, int chid, u32 inst)\n{\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 st2, st2_dl, st2_dh, fifo_ptr, fifo[0x60/4];\n\tu32 ctx_user, ctx_switch[5];\n\tint i, subchan = -1;\n\n\t \n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tint class = nvkm_rd32(device, NV10_PGRAPH_CTX_CACHE(i, 0)) & 0xfff;\n\n\t\tif (class == 0x56 || class == 0x96 || class == 0x99) {\n\t\t\tsubchan = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (subchan < 0 || !inst)\n\t\treturn;\n\n\t \n\tctx_user = nvkm_rd32(device, NV10_PGRAPH_CTX_USER);\n\tfor (i = 0; i < 5; i++)\n\t\tctx_switch[i] = nvkm_rd32(device, NV10_PGRAPH_CTX_SWITCH(i));\n\n\t \n\tst2 = nvkm_rd32(device, NV10_PGRAPH_FFINTFC_ST2);\n\tst2_dl = nvkm_rd32(device, NV10_PGRAPH_FFINTFC_ST2_DL);\n\tst2_dh = nvkm_rd32(device, NV10_PGRAPH_FFINTFC_ST2_DH);\n\tfifo_ptr = nvkm_rd32(device, NV10_PGRAPH_FFINTFC_FIFO_PTR);\n\n\tfor (i = 0; i < ARRAY_SIZE(fifo); i++)\n\t\tfifo[i] = nvkm_rd32(device, 0x4007a0 + 4 * i);\n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(i),\n\t\t\tnvkm_rd32(device, NV10_PGRAPH_CTX_CACHE(subchan, i)));\n\tnvkm_mask(device, NV10_PGRAPH_CTX_USER, 0xe000, subchan << 13);\n\n\t \n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_FIFO_PTR, 0);\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_ST2,\n\t\t0x2c000000 | chid << 20 | subchan << 16 | 0x18c);\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_ST2_DL, inst);\n\tnvkm_mask(device, NV10_PGRAPH_CTX_CONTROL, 0, 0x10000);\n\tnvkm_mask(device, NV04_PGRAPH_FIFO, 0x00000001, 0x00000001);\n\tnvkm_mask(device, NV04_PGRAPH_FIFO, 0x00000001, 0x00000000);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fifo); i++)\n\t\tnvkm_wr32(device, 0x4007a0 + 4 * i, fifo[i]);\n\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_FIFO_PTR, fifo_ptr);\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_ST2, st2);\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_ST2_DL, st2_dl);\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_ST2_DH, st2_dh);\n\n\t \n\tfor (i = 0; i < 5; i++)\n\t\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(i), ctx_switch[i]);\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_USER, ctx_user);\n}\n\nstatic int\nnv10_gr_load_context(struct nv10_gr_chan *chan, int chid)\n{\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 inst;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nv10_gr_ctx_regs); i++)\n\t\tnvkm_wr32(device, nv10_gr_ctx_regs[i], chan->nv10[i]);\n\n\tif (device->card_type >= NV_11 && device->chipset >= 0x17) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nv17_gr_ctx_regs); i++)\n\t\t\tnvkm_wr32(device, nv17_gr_ctx_regs[i], chan->nv17[i]);\n\t}\n\n\tnv10_gr_load_pipe(chan);\n\n\tinst = nvkm_rd32(device, NV10_PGRAPH_GLOBALSTATE1) & 0xffff;\n\tnv10_gr_load_dma_vtxbuf(chan, chid, inst);\n\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_CONTROL, 0x10010100);\n\tnvkm_mask(device, NV10_PGRAPH_CTX_USER, 0xff000000, chid << 24);\n\tnvkm_mask(device, NV10_PGRAPH_FFINTFC_ST2, 0x30000000, 0x00000000);\n\treturn 0;\n}\n\nstatic int\nnv10_gr_unload_context(struct nv10_gr_chan *chan)\n{\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nv10_gr_ctx_regs); i++)\n\t\tchan->nv10[i] = nvkm_rd32(device, nv10_gr_ctx_regs[i]);\n\n\tif (device->card_type >= NV_11 && device->chipset >= 0x17) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nv17_gr_ctx_regs); i++)\n\t\t\tchan->nv17[i] = nvkm_rd32(device, nv17_gr_ctx_regs[i]);\n\t}\n\n\tnv10_gr_save_pipe(chan);\n\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_CONTROL, 0x10000000);\n\tnvkm_mask(device, NV10_PGRAPH_CTX_USER, 0xff000000, 0x1f000000);\n\treturn 0;\n}\n\nstatic void\nnv10_gr_context_switch(struct nv10_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tstruct nv10_gr_chan *prev = NULL;\n\tstruct nv10_gr_chan *next = NULL;\n\tint chid;\n\n\tnv04_gr_idle(&gr->base);\n\n\t \n\tprev = nv10_gr_channel(gr);\n\tif (prev)\n\t\tnv10_gr_unload_context(prev);\n\n\t \n\tchid = (nvkm_rd32(device, NV04_PGRAPH_TRAPPED_ADDR) >> 20) & 0x1f;\n\tnext = gr->chan[chid];\n\tif (next)\n\t\tnv10_gr_load_context(next, chid);\n}\n\nstatic int\nnv10_gr_chan_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nv10_gr_chan *chan = nv10_gr_chan(object);\n\tstruct nv10_gr *gr = chan->gr;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gr->lock, flags);\n\tnvkm_mask(device, NV04_PGRAPH_FIFO, 0x00000001, 0x00000000);\n\tif (nv10_gr_channel(gr) == chan)\n\t\tnv10_gr_unload_context(chan);\n\tnvkm_mask(device, NV04_PGRAPH_FIFO, 0x00000001, 0x00000001);\n\tspin_unlock_irqrestore(&gr->lock, flags);\n\treturn 0;\n}\n\nstatic void *\nnv10_gr_chan_dtor(struct nvkm_object *object)\n{\n\tstruct nv10_gr_chan *chan = nv10_gr_chan(object);\n\tstruct nv10_gr *gr = chan->gr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gr->lock, flags);\n\tgr->chan[chan->chid] = NULL;\n\tspin_unlock_irqrestore(&gr->lock, flags);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\nnv10_gr_chan = {\n\t.dtor = nv10_gr_chan_dtor,\n\t.fini = nv10_gr_chan_fini,\n};\n\n#define NV_WRITE_CTX(reg, val) do { \\\n\tint offset = nv10_gr_ctx_regs_find_offset(gr, reg); \\\n\tif (offset > 0) \\\n\t\tchan->nv10[offset] = val; \\\n\t} while (0)\n\n#define NV17_WRITE_CTX(reg, val) do { \\\n\tint offset = nv17_gr_ctx_regs_find_offset(gr, reg); \\\n\tif (offset > 0) \\\n\t\tchan->nv17[offset] = val; \\\n\t} while (0)\n\nint\nnv10_gr_chan_new(struct nvkm_gr *base, struct nvkm_chan *fifoch,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object **pobject)\n{\n\tstruct nv10_gr *gr = nv10_gr(base);\n\tstruct nv10_gr_chan *chan;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tunsigned long flags;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nv10_gr_chan, oclass, &chan->object);\n\tchan->gr = gr;\n\tchan->chid = fifoch->id;\n\t*pobject = &chan->object;\n\n\tNV_WRITE_CTX(0x00400e88, 0x08000000);\n\tNV_WRITE_CTX(0x00400e9c, 0x4b7fffff);\n\tNV_WRITE_CTX(NV03_PGRAPH_XY_LOGIC_MISC0, 0x0001ffff);\n\tNV_WRITE_CTX(0x00400e10, 0x00001000);\n\tNV_WRITE_CTX(0x00400e14, 0x00001000);\n\tNV_WRITE_CTX(0x00400e30, 0x00080008);\n\tNV_WRITE_CTX(0x00400e34, 0x00080008);\n\tif (device->card_type >= NV_11 && device->chipset >= 0x17) {\n\t\t \n\t\tNV17_WRITE_CTX(NV10_PGRAPH_DEBUG_4,\n\t\t\t       nvkm_rd32(device, NV10_PGRAPH_DEBUG_4));\n\t\tNV17_WRITE_CTX(0x004006b0, nvkm_rd32(device, 0x004006b0));\n\t\tNV17_WRITE_CTX(0x00400eac, 0x0fff0000);\n\t\tNV17_WRITE_CTX(0x00400eb0, 0x0fff0000);\n\t\tNV17_WRITE_CTX(0x00400ec0, 0x00000080);\n\t\tNV17_WRITE_CTX(0x00400ed0, 0x00000080);\n\t}\n\tNV_WRITE_CTX(NV10_PGRAPH_CTX_USER, chan->chid << 24);\n\n\tnv10_gr_create_pipe(chan);\n\n\tspin_lock_irqsave(&gr->lock, flags);\n\tgr->chan[chan->chid] = chan;\n\tspin_unlock_irqrestore(&gr->lock, flags);\n\treturn 0;\n}\n\n \n\nvoid\nnv10_gr_tile(struct nvkm_gr *base, int i, struct nvkm_fb_tile *tile)\n{\n\tstruct nv10_gr *gr = nv10_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tstruct nvkm_fifo *fifo = device->fifo;\n\tunsigned long flags;\n\n\tnvkm_fifo_pause(fifo, &flags);\n\tnv04_gr_idle(&gr->base);\n\n\tnvkm_wr32(device, NV10_PGRAPH_TLIMIT(i), tile->limit);\n\tnvkm_wr32(device, NV10_PGRAPH_TSIZE(i), tile->pitch);\n\tnvkm_wr32(device, NV10_PGRAPH_TILE(i), tile->addr);\n\n\tnvkm_fifo_start(fifo, &flags);\n}\n\nconst struct nvkm_bitfield nv10_gr_intr_name[] = {\n\t{ NV_PGRAPH_INTR_NOTIFY, \"NOTIFY\" },\n\t{ NV_PGRAPH_INTR_ERROR,  \"ERROR\"  },\n\t{}\n};\n\nconst struct nvkm_bitfield nv10_gr_nstatus[] = {\n\t{ NV10_PGRAPH_NSTATUS_STATE_IN_USE,       \"STATE_IN_USE\" },\n\t{ NV10_PGRAPH_NSTATUS_INVALID_STATE,      \"INVALID_STATE\" },\n\t{ NV10_PGRAPH_NSTATUS_BAD_ARGUMENT,       \"BAD_ARGUMENT\" },\n\t{ NV10_PGRAPH_NSTATUS_PROTECTION_FAULT,   \"PROTECTION_FAULT\" },\n\t{}\n};\n\nvoid\nnv10_gr_intr(struct nvkm_gr *base)\n{\n\tstruct nv10_gr *gr = nv10_gr(base);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, NV03_PGRAPH_INTR);\n\tu32 nsource = nvkm_rd32(device, NV03_PGRAPH_NSOURCE);\n\tu32 nstatus = nvkm_rd32(device, NV03_PGRAPH_NSTATUS);\n\tu32 addr = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_ADDR);\n\tu32 chid = (addr & 0x01f00000) >> 20;\n\tu32 subc = (addr & 0x00070000) >> 16;\n\tu32 mthd = (addr & 0x00001ffc);\n\tu32 data = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_DATA);\n\tu32 class = nvkm_rd32(device, 0x400160 + subc * 4) & 0xfff;\n\tu32 show = stat;\n\tchar msg[128], src[128], sta[128];\n\tstruct nv10_gr_chan *chan;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gr->lock, flags);\n\tchan = gr->chan[chid];\n\n\tif (stat & NV_PGRAPH_INTR_ERROR) {\n\t\tif (chan && (nsource & NV03_PGRAPH_NSOURCE_ILLEGAL_MTHD)) {\n\t\t\tif (!nv10_gr_mthd(chan, class, mthd, data))\n\t\t\t\tshow &= ~NV_PGRAPH_INTR_ERROR;\n\t\t}\n\t}\n\n\tif (stat & NV_PGRAPH_INTR_CONTEXT_SWITCH) {\n\t\tnvkm_wr32(device, NV03_PGRAPH_INTR, NV_PGRAPH_INTR_CONTEXT_SWITCH);\n\t\tstat &= ~NV_PGRAPH_INTR_CONTEXT_SWITCH;\n\t\tshow &= ~NV_PGRAPH_INTR_CONTEXT_SWITCH;\n\t\tnv10_gr_context_switch(gr);\n\t}\n\n\tnvkm_wr32(device, NV03_PGRAPH_INTR, stat);\n\tnvkm_wr32(device, NV04_PGRAPH_FIFO, 0x00000001);\n\n\tif (show) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), nv10_gr_intr_name, show);\n\t\tnvkm_snprintbf(src, sizeof(src), nv04_gr_nsource, nsource);\n\t\tnvkm_snprintbf(sta, sizeof(sta), nv10_gr_nstatus, nstatus);\n\t\tnvkm_error(subdev, \"intr %08x [%s] nsource %08x [%s] \"\n\t\t\t\t   \"nstatus %08x [%s] ch %d [%s] subc %d \"\n\t\t\t\t   \"class %04x mthd %04x data %08x\\n\",\n\t\t\t   show, msg, nsource, src, nstatus, sta, chid,\n\t\t\t   chan ? chan->object.client->name : \"unknown\",\n\t\t\t   subc, class, mthd, data);\n\t}\n\n\tspin_unlock_irqrestore(&gr->lock, flags);\n}\n\nint\nnv10_gr_init(struct nvkm_gr *base)\n{\n\tstruct nv10_gr *gr = nv10_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, NV03_PGRAPH_INTR   , 0xFFFFFFFF);\n\tnvkm_wr32(device, NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);\n\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0x00000000);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_1, 0x00118700);\n\t   \n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_2, 0x25f92ad9);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_3, 0x55DE0830 | (1 << 29) | (1 << 31));\n\n\tif (device->card_type >= NV_11 && device->chipset >= 0x17) {\n\t\tnvkm_wr32(device, NV10_PGRAPH_DEBUG_4, 0x1f000000);\n\t\tnvkm_wr32(device, 0x400a10, 0x03ff3fb6);\n\t\tnvkm_wr32(device, 0x400838, 0x002f8684);\n\t\tnvkm_wr32(device, 0x40083c, 0x00115f3f);\n\t\tnvkm_wr32(device, 0x4006b0, 0x40000020);\n\t} else {\n\t\tnvkm_wr32(device, NV10_PGRAPH_DEBUG_4, 0x00000000);\n\t}\n\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(0), 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(1), 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(2), 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(3), 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_SWITCH(4), 0x00000000);\n\tnvkm_wr32(device, NV10_PGRAPH_STATE, 0xFFFFFFFF);\n\n\tnvkm_mask(device, NV10_PGRAPH_CTX_USER, 0xff000000, 0x1f000000);\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_CONTROL, 0x10000100);\n\tnvkm_wr32(device, NV10_PGRAPH_FFINTFC_ST2, 0x08000000);\n\treturn 0;\n}\n\nint\nnv10_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\tstruct nv10_gr *gr;\n\n\tif (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gr->lock);\n\t*pgr = &gr->base;\n\n\treturn nvkm_gr_ctor(func, device, type, inst, true, &gr->base);\n}\n\nstatic const struct nvkm_gr_func\nnv10_gr = {\n\t.init = nv10_gr_init,\n\t.intr = nv10_gr_intr,\n\t.tile = nv10_gr_tile,\n\t.chan_new = nv10_gr_chan_new,\n\t.sclass = {\n\t\t{ -1, -1, 0x0012, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0019, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0030, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0039, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0043, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0044, &nv04_gr_object },  \n\t\t{ -1, -1, 0x004a, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0052, &nv04_gr_object },  \n\t\t{ -1, -1, 0x005f, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0062, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0072, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0089, &nv04_gr_object },  \n\t\t{ -1, -1, 0x008a, &nv04_gr_object },  \n\t\t{ -1, -1, 0x009f, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0093, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0094, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0095, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0056, &nv04_gr_object },  \n\t\t{}\n\t}\n};\n\nint\nnv10_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn nv10_gr_new_(&nv10_gr, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}