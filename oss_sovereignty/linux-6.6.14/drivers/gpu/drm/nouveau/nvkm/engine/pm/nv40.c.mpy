{
  "module_name": "nv40.c",
  "hash_id": "9cc6b81450fb1b27ba1e5a09ca37835cad73614a97d61186fa9f430ddb34cd86",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c",
  "human_readable_source": " \n#include \"nv40.h\"\n\nstatic void\nnv40_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,\n\t\t  struct nvkm_perfctr *ctr)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\tu32 log = ctr->logic_op;\n\tu32 src = 0x00000000;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tsrc |= ctr->signal[i] << (i * 8);\n\n\tnvkm_wr32(device, 0x00a7c0 + dom->addr, 0x00000001 | (dom->mode << 4));\n\tnvkm_wr32(device, 0x00a400 + dom->addr + (ctr->slot * 0x40), src);\n\tnvkm_wr32(device, 0x00a420 + dom->addr + (ctr->slot * 0x40), log);\n}\n\nstatic void\nnv40_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,\n\t\t  struct nvkm_perfctr *ctr)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\n\tswitch (ctr->slot) {\n\tcase 0: ctr->ctr = nvkm_rd32(device, 0x00a700 + dom->addr); break;\n\tcase 1: ctr->ctr = nvkm_rd32(device, 0x00a6c0 + dom->addr); break;\n\tcase 2: ctr->ctr = nvkm_rd32(device, 0x00a680 + dom->addr); break;\n\tcase 3: ctr->ctr = nvkm_rd32(device, 0x00a740 + dom->addr); break;\n\t}\n\tdom->clk = nvkm_rd32(device, 0x00a600 + dom->addr);\n}\n\nstatic void\nnv40_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\tstruct nv40_pm *nv40pm = container_of(pm, struct nv40_pm, base);\n\n\tif (nv40pm->sequence != pm->sequence) {\n\t\tnvkm_wr32(device, 0x400084, 0x00000020);\n\t\tnv40pm->sequence = pm->sequence;\n\t}\n}\n\nconst struct nvkm_funcdom\nnv40_perfctr_func = {\n\t.init = nv40_perfctr_init,\n\t.read = nv40_perfctr_read,\n\t.next = nv40_perfctr_next,\n};\n\nstatic const struct nvkm_pm_func\nnv40_pm_ = {\n};\n\nint\nnv40_pm_new_(const struct nvkm_specdom *doms, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_pm **ppm)\n{\n\tstruct nv40_pm *pm;\n\tint ret;\n\n\tif (!(pm = kzalloc(sizeof(*pm), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*ppm = &pm->base;\n\n\tret = nvkm_pm_ctor(&nv40_pm_, device, type, inst, &pm->base);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nvkm_perfdom_new(&pm->base, \"pc\", 0, 0, 0, 4, doms);\n}\n\nstatic const struct nvkm_specdom\nnv40_pm[] = {\n\t{ 0x20, (const struct nvkm_specsig[]) {\n\t\t\t{}\n\t\t}, &nv40_perfctr_func },\n\t{ 0x20, (const struct nvkm_specsig[]) {\n\t\t\t{}\n\t\t}, &nv40_perfctr_func },\n\t{ 0x20, (const struct nvkm_specsig[]) {\n\t\t\t{}\n\t\t}, &nv40_perfctr_func },\n\t{ 0x20, (const struct nvkm_specsig[]) {\n\t\t\t{}\n\t\t}, &nv40_perfctr_func },\n\t{ 0x20, (const struct nvkm_specsig[]) {\n\t\t\t{}\n\t\t}, &nv40_perfctr_func },\n\t{}\n};\n\nint\nnv40_pm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_pm **ppm)\n{\n\treturn nv40_pm_new_(nv40_pm, device, type, inst, ppm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}