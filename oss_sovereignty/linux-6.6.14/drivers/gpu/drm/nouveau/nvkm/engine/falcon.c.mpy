{
  "module_name": "falcon.c",
  "hash_id": "6b268acbd3f9af1eed60bbc9100e26cce74a0199c12e843adfb4517912587f6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/falcon.c",
  "human_readable_source": " \n#include <engine/falcon.h>\n\n#include <core/gpuobj.h>\n#include <subdev/mc.h>\n#include <subdev/timer.h>\n#include <engine/fifo.h>\n\nstatic int\nnvkm_falcon_oclass_get(struct nvkm_oclass *oclass, int index)\n{\n\tstruct nvkm_falcon *falcon = nvkm_falcon(oclass->engine);\n\tint c = 0;\n\n\twhile (falcon->func->sclass[c].oclass) {\n\t\tif (c++ == index) {\n\t\t\toclass->base = falcon->func->sclass[index];\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nstatic int\nnvkm_falcon_cclass_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t\tint align, struct nvkm_gpuobj **pgpuobj)\n{\n\treturn nvkm_gpuobj_new(object->engine->subdev.device, 256,\n\t\t\t       align, true, parent, pgpuobj);\n}\n\nstatic const struct nvkm_object_func\nnvkm_falcon_cclass = {\n\t.bind = nvkm_falcon_cclass_bind,\n};\n\nstatic void\nnvkm_falcon_intr(struct nvkm_engine *engine)\n{\n\tstruct nvkm_falcon *falcon = nvkm_falcon(engine);\n\tstruct nvkm_subdev *subdev = &falcon->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst u32 base = falcon->addr;\n\tu32 dest = nvkm_rd32(device, base + 0x01c);\n\tu32 intr = nvkm_rd32(device, base + 0x008) & dest & ~(dest >> 16);\n\tu32 inst = nvkm_rd32(device, base + 0x050) & 0x3fffffff;\n\tstruct nvkm_chan *chan;\n\tunsigned long flags;\n\n\tchan = nvkm_chan_get_inst(engine, (u64)inst << 12, &flags);\n\n\tif (intr & 0x00000040) {\n\t\tif (falcon->func->intr) {\n\t\t\tfalcon->func->intr(falcon, chan);\n\t\t\tnvkm_wr32(device, base + 0x004, 0x00000040);\n\t\t\tintr &= ~0x00000040;\n\t\t}\n\t}\n\n\tif (intr & 0x00000010) {\n\t\tnvkm_debug(subdev, \"ucode halted\\n\");\n\t\tnvkm_wr32(device, base + 0x004, 0x00000010);\n\t\tintr &= ~0x00000010;\n\t}\n\n\tif (intr)  {\n\t\tnvkm_error(subdev, \"intr %08x\\n\", intr);\n\t\tnvkm_wr32(device, base + 0x004, intr);\n\t}\n\n\tnvkm_chan_put(&chan, flags);\n}\n\nstatic int\nnvkm_falcon_fini(struct nvkm_engine *engine, bool suspend)\n{\n\tstruct nvkm_falcon *falcon = nvkm_falcon(engine);\n\tstruct nvkm_device *device = falcon->engine.subdev.device;\n\tconst u32 base = falcon->addr;\n\n\tif (!suspend) {\n\t\tnvkm_memory_unref(&falcon->core);\n\t\tif (falcon->external) {\n\t\t\tvfree(falcon->data.data);\n\t\t\tvfree(falcon->code.data);\n\t\t\tfalcon->code.data = NULL;\n\t\t}\n\t}\n\n\tif (nvkm_mc_enabled(device, engine->subdev.type, engine->subdev.inst)) {\n\t\tnvkm_mask(device, base + 0x048, 0x00000003, 0x00000000);\n\t\tnvkm_wr32(device, base + 0x014, 0xffffffff);\n\t}\n\treturn 0;\n}\n\nstatic void *\nvmemdup(const void *src, size_t len)\n{\n\tvoid *p = vmalloc(len);\n\n\tif (p)\n\t\tmemcpy(p, src, len);\n\treturn p;\n}\n\nstatic int\nnvkm_falcon_oneinit(struct nvkm_engine *engine)\n{\n\tstruct nvkm_falcon *falcon = nvkm_falcon(engine);\n\tstruct nvkm_subdev *subdev = &falcon->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst u32 base = falcon->addr;\n\tu32 caps;\n\n\t \n\tif (device->chipset <  0xa3 ||\n\t    device->chipset == 0xaa || device->chipset == 0xac) {\n\t\tfalcon->version = 0;\n\t\tfalcon->secret  = (falcon->addr == 0x087000) ? 1 : 0;\n\t} else {\n\t\tcaps = nvkm_rd32(device, base + 0x12c);\n\t\tfalcon->version = (caps & 0x0000000f);\n\t\tfalcon->secret  = (caps & 0x00000030) >> 4;\n\t}\n\n\tcaps = nvkm_rd32(device, base + 0x108);\n\tfalcon->code.limit = (caps & 0x000001ff) << 8;\n\tfalcon->data.limit = (caps & 0x0003fe00) >> 1;\n\n\tnvkm_debug(subdev, \"falcon version: %d\\n\", falcon->version);\n\tnvkm_debug(subdev, \"secret level: %d\\n\", falcon->secret);\n\tnvkm_debug(subdev, \"code limit: %d\\n\", falcon->code.limit);\n\tnvkm_debug(subdev, \"data limit: %d\\n\", falcon->data.limit);\n\treturn 0;\n}\n\nstatic int\nnvkm_falcon_init(struct nvkm_engine *engine)\n{\n\tstruct nvkm_falcon *falcon = nvkm_falcon(engine);\n\tstruct nvkm_subdev *subdev = &falcon->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst struct firmware *fw;\n\tchar name[32] = \"internal\";\n\tconst u32 base = falcon->addr;\n\tint ret, i;\n\n\t \n\tif (falcon->secret && falcon->version < 4) {\n\t\tif (!falcon->version) {\n\t\t\tnvkm_msec(device, 2000,\n\t\t\t\tif (nvkm_rd32(device, base + 0x008) & 0x00000010)\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t} else {\n\t\t\tnvkm_msec(device, 2000,\n\t\t\t\tif (!(nvkm_rd32(device, base + 0x180) & 0x80000000))\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t}\n\t\tnvkm_wr32(device, base + 0x004, 0x00000010);\n\t}\n\n\t \n\tnvkm_wr32(device, base + 0x014, 0xffffffff);\n\n\t \n\tif (!falcon->code.data) {\n\t\tsnprintf(name, sizeof(name), \"nouveau/nv%02x_fuc%03x\",\n\t\t\t device->chipset, falcon->addr >> 12);\n\n\t\tret = request_firmware(&fw, name, device->dev);\n\t\tif (ret == 0) {\n\t\t\tfalcon->code.data = vmemdup(fw->data, fw->size);\n\t\t\tfalcon->code.size = fw->size;\n\t\t\tfalcon->data.data = NULL;\n\t\t\tfalcon->data.size = 0;\n\t\t\trelease_firmware(fw);\n\t\t}\n\n\t\tfalcon->external = true;\n\t}\n\n\t \n\tif (!falcon->code.data) {\n\t\tsnprintf(name, sizeof(name), \"nouveau/nv%02x_fuc%03xd\",\n\t\t\t device->chipset, falcon->addr >> 12);\n\n\t\tret = request_firmware(&fw, name, device->dev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"unable to load firmware data\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tfalcon->data.data = vmemdup(fw->data, fw->size);\n\t\tfalcon->data.size = fw->size;\n\t\trelease_firmware(fw);\n\t\tif (!falcon->data.data)\n\t\t\treturn -ENOMEM;\n\n\t\tsnprintf(name, sizeof(name), \"nouveau/nv%02x_fuc%03xc\",\n\t\t\t device->chipset, falcon->addr >> 12);\n\n\t\tret = request_firmware(&fw, name, device->dev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"unable to load firmware code\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tfalcon->code.data = vmemdup(fw->data, fw->size);\n\t\tfalcon->code.size = fw->size;\n\t\trelease_firmware(fw);\n\t\tif (!falcon->code.data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnvkm_debug(subdev, \"firmware: %s (%s)\\n\", name, falcon->data.data ?\n\t\t   \"static code/data segments\" : \"self-bootstrapping\");\n\n\t \n\tif (!falcon->data.data && !falcon->core) {\n\t\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST,\n\t\t\t\t      falcon->code.size, 256, false,\n\t\t\t\t      &falcon->core);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"core allocation failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnvkm_kmap(falcon->core);\n\t\tfor (i = 0; i < falcon->code.size; i += 4)\n\t\t\tnvkm_wo32(falcon->core, i, falcon->code.data[i / 4]);\n\t\tnvkm_done(falcon->core);\n\t}\n\n\t \n\tif (falcon->core) {\n\t\tu64 addr = nvkm_memory_addr(falcon->core);\n\t\tif (device->card_type < NV_C0)\n\t\t\tnvkm_wr32(device, base + 0x618, 0x04000000);\n\t\telse\n\t\t\tnvkm_wr32(device, base + 0x618, 0x00000114);\n\t\tnvkm_wr32(device, base + 0x11c, 0);\n\t\tnvkm_wr32(device, base + 0x110, addr >> 8);\n\t\tnvkm_wr32(device, base + 0x114, 0);\n\t\tnvkm_wr32(device, base + 0x118, 0x00006610);\n\t} else {\n\t\tif (falcon->code.size > falcon->code.limit ||\n\t\t    falcon->data.size > falcon->data.limit) {\n\t\t\tnvkm_error(subdev, \"ucode exceeds falcon limit(s)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (falcon->version < 3) {\n\t\t\tnvkm_wr32(device, base + 0xff8, 0x00100000);\n\t\t\tfor (i = 0; i < falcon->code.size / 4; i++)\n\t\t\t\tnvkm_wr32(device, base + 0xff4, falcon->code.data[i]);\n\t\t} else {\n\t\t\tnvkm_wr32(device, base + 0x180, 0x01000000);\n\t\t\tfor (i = 0; i < falcon->code.size / 4; i++) {\n\t\t\t\tif ((i & 0x3f) == 0)\n\t\t\t\t\tnvkm_wr32(device, base + 0x188, i >> 6);\n\t\t\t\tnvkm_wr32(device, base + 0x184, falcon->code.data[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (falcon->version < 3) {\n\t\tnvkm_wr32(device, base + 0xff8, 0x00000000);\n\t\tfor (i = 0; !falcon->core && i < falcon->data.size / 4; i++)\n\t\t\tnvkm_wr32(device, base + 0xff4, falcon->data.data[i]);\n\t\tfor (; i < falcon->data.limit; i += 4)\n\t\t\tnvkm_wr32(device, base + 0xff4, 0x00000000);\n\t} else {\n\t\tnvkm_wr32(device, base + 0x1c0, 0x01000000);\n\t\tfor (i = 0; !falcon->core && i < falcon->data.size / 4; i++)\n\t\t\tnvkm_wr32(device, base + 0x1c4, falcon->data.data[i]);\n\t\tfor (; i < falcon->data.limit / 4; i++)\n\t\t\tnvkm_wr32(device, base + 0x1c4, 0x00000000);\n\t}\n\n\t \n\tnvkm_wr32(device, base + 0x10c, 0x00000001);  \n\tnvkm_wr32(device, base + 0x104, 0x00000000);  \n\tnvkm_wr32(device, base + 0x100, 0x00000002);  \n\tnvkm_wr32(device, base + 0x048, 0x00000003);  \n\n\tif (falcon->func->init)\n\t\tfalcon->func->init(falcon);\n\treturn 0;\n}\n\nstatic void *\nnvkm_falcon_dtor(struct nvkm_engine *engine)\n{\n\treturn nvkm_falcon(engine);\n}\n\nstatic const struct nvkm_engine_func\nnvkm_falcon = {\n\t.dtor = nvkm_falcon_dtor,\n\t.oneinit = nvkm_falcon_oneinit,\n\t.init = nvkm_falcon_init,\n\t.fini = nvkm_falcon_fini,\n\t.intr = nvkm_falcon_intr,\n\t.fifo.sclass = nvkm_falcon_oclass_get,\n\t.cclass = &nvkm_falcon_cclass,\n};\n\nint\nnvkm_falcon_new_(const struct nvkm_falcon_func *func, struct nvkm_device *device,\n\t\t enum nvkm_subdev_type type, int inst, bool enable, u32 addr,\n\t\t struct nvkm_engine **pengine)\n{\n\tstruct nvkm_falcon *falcon;\n\n\tif (!(falcon = kzalloc(sizeof(*falcon), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tfalcon->func = func;\n\tfalcon->addr = addr;\n\tfalcon->code.data = func->code.data;\n\tfalcon->code.size = func->code.size;\n\tfalcon->data.data = func->data.data;\n\tfalcon->data.size = func->data.size;\n\t*pengine = &falcon->engine;\n\n\treturn nvkm_engine_ctor(&nvkm_falcon, device, type, inst, enable, &falcon->engine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}