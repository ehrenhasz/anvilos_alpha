{
  "module_name": "cgrp.c",
  "hash_id": "3f1f41e9f42e24c324ff3e4112b3b3221504e09def33d03d496f0cb675a26413",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/cgrp.c",
  "human_readable_source": " \n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n#include \"priv.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/mmu.h>\n\nstatic void\nnvkm_cgrp_ectx_put(struct nvkm_cgrp *cgrp, struct nvkm_ectx **pectx)\n{\n\tstruct nvkm_ectx *ectx = *pectx;\n\n\tif (ectx) {\n\t\tstruct nvkm_engn *engn = ectx->engn;\n\n\t\tif (refcount_dec_and_test(&ectx->refs)) {\n\t\t\tCGRP_TRACE(cgrp, \"dtor ectx %d[%s]\", engn->id, engn->engine->subdev.name);\n\t\t\tnvkm_object_del(&ectx->object);\n\t\t\tlist_del(&ectx->head);\n\t\t\tkfree(ectx);\n\t\t}\n\n\t\t*pectx = NULL;\n\t}\n}\n\nstatic int\nnvkm_cgrp_ectx_get(struct nvkm_cgrp *cgrp, struct nvkm_engn *engn, struct nvkm_ectx **pectx,\n\t\t   struct nvkm_chan *chan, struct nvkm_client *client)\n{\n\tstruct nvkm_engine *engine = engn->engine;\n\tstruct nvkm_oclass cclass = {\n\t\t.client = client,\n\t\t.engine = engine,\n\t};\n\tstruct nvkm_ectx *ectx;\n\tint ret = 0;\n\n\t \n\tectx = nvkm_list_find(ectx, &cgrp->ectxs, head, ectx->engn == engn);\n\tif (ectx) {\n\t\trefcount_inc(&ectx->refs);\n\t\t*pectx = ectx;\n\t\treturn 0;\n\t}\n\n\t \n\tCGRP_TRACE(cgrp, \"ctor ectx %d[%s]\", engn->id, engn->engine->subdev.name);\n\tif (!(ectx = *pectx = kzalloc(sizeof(*ectx), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tectx->engn = engn;\n\trefcount_set(&ectx->refs, 1);\n\trefcount_set(&ectx->uses, 0);\n\tlist_add_tail(&ectx->head, &cgrp->ectxs);\n\n\t \n\tif (engine->func->fifo.cclass)\n\t\tret = engine->func->fifo.cclass(chan, &cclass, &ectx->object);\n\telse if (engine->func->cclass)\n\t\tret = nvkm_object_new_(engine->func->cclass, &cclass, NULL, 0, &ectx->object);\n\n\tif (ret)\n\t\tnvkm_cgrp_ectx_put(cgrp, pectx);\n\n\treturn ret;\n}\n\nvoid\nnvkm_cgrp_vctx_put(struct nvkm_cgrp *cgrp, struct nvkm_vctx **pvctx)\n{\n\tstruct nvkm_vctx *vctx = *pvctx;\n\n\tif (vctx) {\n\t\tstruct nvkm_engn *engn = vctx->ectx->engn;\n\n\t\tif (refcount_dec_and_test(&vctx->refs)) {\n\t\t\tCGRP_TRACE(cgrp, \"dtor vctx %d[%s]\", engn->id, engn->engine->subdev.name);\n\t\t\tnvkm_vmm_put(vctx->vmm, &vctx->vma);\n\t\t\tnvkm_gpuobj_del(&vctx->inst);\n\n\t\t\tnvkm_cgrp_ectx_put(cgrp, &vctx->ectx);\n\t\t\tif (vctx->vmm) {\n\t\t\t\tatomic_dec(&vctx->vmm->engref[engn->engine->subdev.type]);\n\t\t\t\tnvkm_vmm_unref(&vctx->vmm);\n\t\t\t}\n\t\t\tlist_del(&vctx->head);\n\t\t\tkfree(vctx);\n\t\t}\n\n\t\t*pvctx = NULL;\n\t}\n}\n\nint\nnvkm_cgrp_vctx_get(struct nvkm_cgrp *cgrp, struct nvkm_engn *engn, struct nvkm_chan *chan,\n\t\t   struct nvkm_vctx **pvctx, struct nvkm_client *client)\n{\n\tstruct nvkm_ectx *ectx;\n\tstruct nvkm_vctx *vctx;\n\tint ret;\n\n\t \n\tvctx = nvkm_list_find(vctx, &cgrp->vctxs, head,\n\t\t\t      vctx->ectx->engn == engn && vctx->vmm == chan->vmm);\n\tif (vctx) {\n\t\trefcount_inc(&vctx->refs);\n\t\t*pvctx = vctx;\n\t\treturn 0;\n\t}\n\n\t \n\tret = nvkm_cgrp_ectx_get(cgrp, engn, &ectx, chan, client);\n\tif (ret) {\n\t\tCGRP_ERROR(cgrp, \"ectx %d[%s]: %d\", engn->id, engn->engine->subdev.name, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tCGRP_TRACE(cgrp, \"ctor vctx %d[%s]\", engn->id, engn->engine->subdev.name);\n\tif (!(vctx = *pvctx = kzalloc(sizeof(*vctx), GFP_KERNEL))) {\n\t\tnvkm_cgrp_ectx_put(cgrp, &ectx);\n\t\treturn -ENOMEM;\n\t}\n\n\tvctx->ectx = ectx;\n\tvctx->vmm = nvkm_vmm_ref(chan->vmm);\n\trefcount_set(&vctx->refs, 1);\n\tlist_add_tail(&vctx->head, &cgrp->vctxs);\n\n\t \n\tif (vctx->vmm)\n\t\tatomic_inc(&vctx->vmm->engref[engn->engine->subdev.type]);\n\n\t \n\tif (engn->func->bind) {\n\t\tret = nvkm_object_bind(vctx->ectx->object, NULL, 0, &vctx->inst);\n\t\tif (ret == 0 && engn->func->ctor)\n\t\t\tret = engn->func->ctor(engn, vctx);\n\t}\n\n\tif (ret)\n\t\tnvkm_cgrp_vctx_put(cgrp, pvctx);\n\n\treturn ret;\n}\n\nstatic void\nnvkm_cgrp_del(struct kref *kref)\n{\n\tstruct nvkm_cgrp *cgrp = container_of(kref, typeof(*cgrp), kref);\n\tstruct nvkm_runl *runl = cgrp->runl;\n\n\tif (runl->cgid)\n\t\tnvkm_chid_put(runl->cgid, cgrp->id, &cgrp->lock);\n\n\tmutex_destroy(&cgrp->mutex);\n\tnvkm_vmm_unref(&cgrp->vmm);\n\tkfree(cgrp);\n}\n\nvoid\nnvkm_cgrp_unref(struct nvkm_cgrp **pcgrp)\n{\n\tstruct nvkm_cgrp *cgrp = *pcgrp;\n\n\tif (!cgrp)\n\t\treturn;\n\n\tkref_put(&cgrp->kref, nvkm_cgrp_del);\n\t*pcgrp = NULL;\n}\n\nstruct nvkm_cgrp *\nnvkm_cgrp_ref(struct nvkm_cgrp *cgrp)\n{\n\tif (cgrp)\n\t\tkref_get(&cgrp->kref);\n\n\treturn cgrp;\n}\n\nvoid\nnvkm_cgrp_put(struct nvkm_cgrp **pcgrp, unsigned long irqflags)\n{\n\tstruct nvkm_cgrp *cgrp = *pcgrp;\n\n\tif (!cgrp)\n\t\treturn;\n\n\t*pcgrp = NULL;\n\tspin_unlock_irqrestore(&cgrp->lock, irqflags);\n}\n\nint\nnvkm_cgrp_new(struct nvkm_runl *runl, const char *name, struct nvkm_vmm *vmm, bool hw,\n\t      struct nvkm_cgrp **pcgrp)\n{\n\tstruct nvkm_cgrp *cgrp;\n\n\tif (!(cgrp = *pcgrp = kmalloc(sizeof(*cgrp), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tcgrp->func = runl->fifo->func->cgrp.func;\n\tstrscpy(cgrp->name, name, sizeof(cgrp->name));\n\tcgrp->runl = runl;\n\tcgrp->vmm = nvkm_vmm_ref(vmm);\n\tcgrp->hw = hw;\n\tcgrp->id = -1;\n\tkref_init(&cgrp->kref);\n\tINIT_LIST_HEAD(&cgrp->chans);\n\tcgrp->chan_nr = 0;\n\tspin_lock_init(&cgrp->lock);\n\tINIT_LIST_HEAD(&cgrp->ectxs);\n\tINIT_LIST_HEAD(&cgrp->vctxs);\n\tmutex_init(&cgrp->mutex);\n\tatomic_set(&cgrp->rc, NVKM_CGRP_RC_NONE);\n\n\tif (runl->cgid) {\n\t\tcgrp->id = nvkm_chid_get(runl->cgid, cgrp);\n\t\tif (cgrp->id < 0) {\n\t\t\tRUNL_ERROR(runl, \"!cgids\");\n\t\t\tnvkm_cgrp_unref(pcgrp);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}