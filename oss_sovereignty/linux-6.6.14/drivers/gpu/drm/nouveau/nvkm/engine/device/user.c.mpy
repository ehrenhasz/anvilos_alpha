{
  "module_name": "user.c",
  "hash_id": "2eba7f1decf4e10e4f046ac3436742920f0cb78eedc7d3a46f25a9ad2f3e5c31",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/device/user.c",
  "human_readable_source": " \n#define nvkm_udevice(p) container_of((p), struct nvkm_udevice, object)\n#include \"priv.h\"\n#include \"ctrl.h\"\n\n#include <core/client.h>\n#include <subdev/fb.h>\n#include <subdev/instmem.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0080.h>\n#include <nvif/unpack.h>\n\nstruct nvkm_udevice {\n\tstruct nvkm_object object;\n\tstruct nvkm_device *device;\n};\n\nstatic int\nnvkm_udevice_info_subdev(struct nvkm_device *device, u64 mthd, u64 *data)\n{\n\tstruct nvkm_subdev *subdev;\n\tenum nvkm_subdev_type type;\n\n\tswitch (mthd & NV_DEVICE_INFO_UNIT) {\n\tcase NV_DEVICE_HOST(0): type = NVKM_ENGINE_FIFO; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsubdev = nvkm_device_subdev(device, type, 0);\n\tif (subdev)\n\t\treturn nvkm_subdev_info(subdev, mthd, data);\n\treturn -ENODEV;\n}\n\nstatic void\nnvkm_udevice_info_v1(struct nvkm_device *device,\n\t\t     struct nv_device_info_v1_data *args)\n{\n\tif (args->mthd & NV_DEVICE_INFO_UNIT) {\n\t\tif (nvkm_udevice_info_subdev(device, args->mthd, &args->data))\n\t\t\targs->mthd = NV_DEVICE_INFO_INVALID;\n\t\treturn;\n\t}\n\targs->mthd = NV_DEVICE_INFO_INVALID;\n}\n\nstatic int\nnvkm_udevice_info(struct nvkm_udevice *udev, void *data, u32 size)\n{\n\tstruct nvkm_object *object = &udev->object;\n\tstruct nvkm_device *device = udev->device;\n\tstruct nvkm_fb *fb = device->fb;\n\tstruct nvkm_instmem *imem = device->imem;\n\tunion {\n\t\tstruct nv_device_info_v0 v0;\n\t\tstruct nv_device_info_v1 v1;\n\t} *args = data;\n\tint ret = -ENOSYS, i;\n\n\tnvif_ioctl(object, \"device info size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v1, 1, 1, true))) {\n\t\tnvif_ioctl(object, \"device info vers %d count %d\\n\",\n\t\t\t   args->v1.version, args->v1.count);\n\t\tif (args->v1.count * sizeof(args->v1.data[0]) == size) {\n\t\t\tfor (i = 0; i < args->v1.count; i++)\n\t\t\t\tnvkm_udevice_info_v1(device, &args->v1.data[i]);\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t} else\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object, \"device info vers %d\\n\", args->v0.version);\n\t} else\n\t\treturn ret;\n\n\tswitch (device->chipset) {\n\tcase 0x01a:\n\tcase 0x01f:\n\tcase 0x04c:\n\tcase 0x04e:\n\tcase 0x063:\n\tcase 0x067:\n\tcase 0x068:\n\tcase 0x0aa:\n\tcase 0x0ac:\n\tcase 0x0af:\n\t\targs->v0.platform = NV_DEVICE_INFO_V0_IGP;\n\t\tbreak;\n\tdefault:\n\t\tswitch (device->type) {\n\t\tcase NVKM_DEVICE_PCI:\n\t\t\targs->v0.platform = NV_DEVICE_INFO_V0_PCI;\n\t\t\tbreak;\n\t\tcase NVKM_DEVICE_AGP:\n\t\t\targs->v0.platform = NV_DEVICE_INFO_V0_AGP;\n\t\t\tbreak;\n\t\tcase NVKM_DEVICE_PCIE:\n\t\t\targs->v0.platform = NV_DEVICE_INFO_V0_PCIE;\n\t\t\tbreak;\n\t\tcase NVKM_DEVICE_TEGRA:\n\t\t\targs->v0.platform = NV_DEVICE_INFO_V0_SOC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (device->card_type) {\n\tcase NV_04: args->v0.family = NV_DEVICE_INFO_V0_TNT; break;\n\tcase NV_10:\n\tcase NV_11: args->v0.family = NV_DEVICE_INFO_V0_CELSIUS; break;\n\tcase NV_20: args->v0.family = NV_DEVICE_INFO_V0_KELVIN; break;\n\tcase NV_30: args->v0.family = NV_DEVICE_INFO_V0_RANKINE; break;\n\tcase NV_40: args->v0.family = NV_DEVICE_INFO_V0_CURIE; break;\n\tcase NV_50: args->v0.family = NV_DEVICE_INFO_V0_TESLA; break;\n\tcase NV_C0: args->v0.family = NV_DEVICE_INFO_V0_FERMI; break;\n\tcase NV_E0: args->v0.family = NV_DEVICE_INFO_V0_KEPLER; break;\n\tcase GM100: args->v0.family = NV_DEVICE_INFO_V0_MAXWELL; break;\n\tcase GP100: args->v0.family = NV_DEVICE_INFO_V0_PASCAL; break;\n\tcase GV100: args->v0.family = NV_DEVICE_INFO_V0_VOLTA; break;\n\tcase TU100: args->v0.family = NV_DEVICE_INFO_V0_TURING; break;\n\tcase GA100: args->v0.family = NV_DEVICE_INFO_V0_AMPERE; break;\n\tdefault:\n\t\targs->v0.family = 0;\n\t\tbreak;\n\t}\n\n\targs->v0.chipset  = device->chipset;\n\targs->v0.revision = device->chiprev;\n\tif (fb && fb->ram)\n\t\targs->v0.ram_size = args->v0.ram_user = fb->ram->size;\n\telse\n\t\targs->v0.ram_size = args->v0.ram_user = 0;\n\tif (imem && args->v0.ram_size > 0)\n\t\targs->v0.ram_user = args->v0.ram_user - imem->reserved;\n\n\tsnprintf(args->v0.chip, sizeof(args->v0.chip), \"%s\", device->chip->name);\n\tsnprintf(args->v0.name, sizeof(args->v0.name), \"%s\", device->name);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_time(struct nvkm_udevice *udev, void *data, u32 size)\n{\n\tstruct nvkm_object *object = &udev->object;\n\tstruct nvkm_device *device = udev->device;\n\tunion {\n\t\tstruct nv_device_time_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"device time size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object, \"device time vers %d\\n\", args->v0.version);\n\t\targs->v0.time = nvkm_timer_read(device->timer);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_udevice_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tnvif_ioctl(object, \"device mthd %08x\\n\", mthd);\n\tswitch (mthd) {\n\tcase NV_DEVICE_V0_INFO:\n\t\treturn nvkm_udevice_info(udev, data, size);\n\tcase NV_DEVICE_V0_TIME:\n\t\treturn nvkm_udevice_time(udev, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_udevice_rd08(struct nvkm_object *object, u64 addr, u8 *data)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\t*data = nvkm_rd08(udev->device, addr);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_rd16(struct nvkm_object *object, u64 addr, u16 *data)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\t*data = nvkm_rd16(udev->device, addr);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_rd32(struct nvkm_object *object, u64 addr, u32 *data)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\t*data = nvkm_rd32(udev->device, addr);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_wr08(struct nvkm_object *object, u64 addr, u8 data)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tnvkm_wr08(udev->device, addr, data);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_wr16(struct nvkm_object *object, u64 addr, u16 data)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tnvkm_wr16(udev->device, addr, data);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_wr32(struct nvkm_object *object, u64 addr, u32 data)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tnvkm_wr32(udev->device, addr, data);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_map(struct nvkm_object *object, void *argv, u32 argc,\n\t\t enum nvkm_object_map *type, u64 *addr, u64 *size)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tstruct nvkm_device *device = udev->device;\n\t*type = NVKM_OBJECT_MAP_IO;\n\t*addr = device->func->resource_addr(device, 0);\n\t*size = device->func->resource_size(device, 0);\n\treturn 0;\n}\n\nstatic int\nnvkm_udevice_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tstruct nvkm_device *device = udev->device;\n\tint ret = 0;\n\n\tmutex_lock(&device->mutex);\n\tif (!--device->refcount) {\n\t\tret = nvkm_device_fini(device, suspend);\n\t\tif (ret && suspend) {\n\t\t\tdevice->refcount++;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&device->mutex);\n\treturn ret;\n}\n\nstatic int\nnvkm_udevice_init(struct nvkm_object *object)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tstruct nvkm_device *device = udev->device;\n\tint ret = 0;\n\n\tmutex_lock(&device->mutex);\n\tif (!device->refcount++) {\n\t\tret = nvkm_device_init(device);\n\t\tif (ret) {\n\t\t\tdevice->refcount--;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&device->mutex);\n\treturn ret;\n}\n\nstatic int\nnvkm_udevice_child_new(const struct nvkm_oclass *oclass,\n\t\t       void *data, u32 size, struct nvkm_object **pobject)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(oclass->parent);\n\tconst struct nvkm_device_oclass *sclass = oclass->priv;\n\treturn sclass->ctor(udev->device, oclass, data, size, pobject);\n}\n\nstatic int\nnvkm_udevice_child_get(struct nvkm_object *object, int index,\n\t\t       struct nvkm_oclass *oclass)\n{\n\tstruct nvkm_udevice *udev = nvkm_udevice(object);\n\tstruct nvkm_device *device = udev->device;\n\tstruct nvkm_engine *engine;\n\tu64 mask = (1ULL << NVKM_ENGINE_DMAOBJ) |\n\t\t   (1ULL << NVKM_ENGINE_FIFO) |\n\t\t   (1ULL << NVKM_ENGINE_DISP) |\n\t\t   (1ULL << NVKM_ENGINE_PM);\n\tconst struct nvkm_device_oclass *sclass = NULL;\n\tint i;\n\n\tfor (; i = __ffs64(mask), mask && !sclass; mask &= ~(1ULL << i)) {\n\t\tif (!(engine = nvkm_device_engine(device, i, 0)) ||\n\t\t    !(engine->func->base.sclass))\n\t\t\tcontinue;\n\t\toclass->engine = engine;\n\n\t\tindex -= engine->func->base.sclass(oclass, index, &sclass);\n\t}\n\n\tif (!sclass) {\n\t\tif (index-- == 0)\n\t\t\tsclass = &nvkm_control_oclass;\n\t\telse if (device->mmu && index-- == 0)\n\t\t\tsclass = &device->mmu->user;\n\t\telse if (device->fault && index-- == 0)\n\t\t\tsclass = &device->fault->user;\n\t\telse if (device->vfn && index-- == 0)\n\t\t\tsclass = &device->vfn->user;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\toclass->base = sclass->base;\n\t\toclass->engine = NULL;\n\t}\n\n\toclass->ctor = nvkm_udevice_child_new;\n\toclass->priv = sclass;\n\treturn 0;\n}\n\nstatic const struct nvkm_object_func\nnvkm_udevice_super = {\n\t.init = nvkm_udevice_init,\n\t.fini = nvkm_udevice_fini,\n\t.mthd = nvkm_udevice_mthd,\n\t.map = nvkm_udevice_map,\n\t.rd08 = nvkm_udevice_rd08,\n\t.rd16 = nvkm_udevice_rd16,\n\t.rd32 = nvkm_udevice_rd32,\n\t.wr08 = nvkm_udevice_wr08,\n\t.wr16 = nvkm_udevice_wr16,\n\t.wr32 = nvkm_udevice_wr32,\n\t.sclass = nvkm_udevice_child_get,\n};\n\nstatic const struct nvkm_object_func\nnvkm_udevice = {\n\t.init = nvkm_udevice_init,\n\t.fini = nvkm_udevice_fini,\n\t.mthd = nvkm_udevice_mthd,\n\t.sclass = nvkm_udevice_child_get,\n};\n\nstatic int\nnvkm_udevice_new(const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\t struct nvkm_object **pobject)\n{\n\tunion {\n\t\tstruct nv_device_v0 v0;\n\t} *args = data;\n\tstruct nvkm_client *client = oclass->client;\n\tstruct nvkm_object *parent = &client->object;\n\tconst struct nvkm_object_func *func;\n\tstruct nvkm_udevice *udev;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(parent, \"create device size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(parent, \"create device v%d device %016llx\\n\",\n\t\t\t   args->v0.version, args->v0.device);\n\t} else\n\t\treturn ret;\n\n\t \n\tif (args->v0.priv)\n\t\tfunc = &nvkm_udevice_super;\n\telse\n\t\tfunc = &nvkm_udevice;\n\n\tif (!(udev = kzalloc(sizeof(*udev), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(func, oclass, &udev->object);\n\t*pobject = &udev->object;\n\n\t \n\tif (args->v0.device != ~0)\n\t\tudev->device = nvkm_device_find(args->v0.device);\n\telse\n\t\tudev->device = nvkm_device_find(client->device);\n\tif (!udev->device)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nconst struct nvkm_sclass\nnvkm_udevice_sclass = {\n\t.oclass = NV_DEVICE,\n\t.minver = 0,\n\t.maxver = 0,\n\t.ctor = nvkm_udevice_new,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}