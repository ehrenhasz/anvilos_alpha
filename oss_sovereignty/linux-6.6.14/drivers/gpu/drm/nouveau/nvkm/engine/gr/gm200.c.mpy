{
  "module_name": "gm200.c",
  "hash_id": "3dba10850f24f22ebdefc2b2631452f5a81f48efd31beaf4362240ffff4f5ccb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm200.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ctxgf100.h\"\n\n#include <core/firmware.h>\n#include <subdev/acr.h>\n\n#include <nvfw/flcn.h>\n\n#include <nvif/class.h>\n\nint\ngm200_gr_nofw(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tnvkm_warn(&gr->base.engine.subdev, \"firmware unavailable\\n\");\n\treturn -ENODEV;\n}\n\n \n\nstatic void\ngm200_gr_acr_bld_patch(struct nvkm_acr *acr, u32 bld, s64 adjust)\n{\n\tstruct flcn_bl_dmem_desc_v1 hdr;\n\tnvkm_robj(acr->wpr, bld, &hdr, sizeof(hdr));\n\thdr.code_dma_base = hdr.code_dma_base + adjust;\n\thdr.data_dma_base = hdr.data_dma_base + adjust;\n\tnvkm_wobj(acr->wpr, bld, &hdr, sizeof(hdr));\n\tflcn_bl_dmem_desc_v1_dump(&acr->subdev, &hdr);\n}\n\nstatic void\ngm200_gr_acr_bld_write(struct nvkm_acr *acr, u32 bld,\n\t\t       struct nvkm_acr_lsfw *lsfw)\n{\n\tconst u64 base = lsfw->offset.img + lsfw->app_start_offset;\n\tconst u64 code = base + lsfw->app_resident_code_offset;\n\tconst u64 data = base + lsfw->app_resident_data_offset;\n\tconst struct flcn_bl_dmem_desc_v1 hdr = {\n\t\t.ctx_dma = FALCON_DMAIDX_UCODE,\n\t\t.code_dma_base = code,\n\t\t.non_sec_code_off = lsfw->app_resident_code_offset,\n\t\t.non_sec_code_size = lsfw->app_resident_code_size,\n\t\t.code_entry_point = lsfw->app_imem_entry,\n\t\t.data_dma_base = data,\n\t\t.data_size = lsfw->app_resident_data_size,\n\t};\n\n\tnvkm_wobj(acr->wpr, bld, &hdr, sizeof(hdr));\n}\n\nconst struct nvkm_acr_lsf_func\ngm200_gr_gpccs_acr = {\n\t.flags = NVKM_ACR_LSF_FORCE_PRIV_LOAD,\n\t.bld_size = sizeof(struct flcn_bl_dmem_desc_v1),\n\t.bld_write = gm200_gr_acr_bld_write,\n\t.bld_patch = gm200_gr_acr_bld_patch,\n};\n\nconst struct nvkm_acr_lsf_func\ngm200_gr_fecs_acr = {\n\t.bld_size = sizeof(struct flcn_bl_dmem_desc_v1),\n\t.bld_write = gm200_gr_acr_bld_write,\n\t.bld_patch = gm200_gr_acr_bld_patch,\n};\n\nint\ngm200_gr_rops(struct gf100_gr *gr)\n{\n\treturn nvkm_rd32(gr->base.engine.subdev.device, 0x12006c);\n}\n\nvoid\ngm200_gr_init_ds_hww_esr_2(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, 0x405848, 0xc0000000);\n\tnvkm_mask(device, 0x40584c, 0x00000001, 0x00000001);\n}\n\nvoid\ngm200_gr_init_num_active_ltcs(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, GPC_BCAST(0x08ac), nvkm_rd32(device, 0x100800));\n\tnvkm_wr32(device, GPC_BCAST(0x033c), nvkm_rd32(device, 0x100804));\n}\n\nvoid\ngm200_gr_init_gpc_mmu(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x418880, nvkm_rd32(device, 0x100c80) & 0xf0001fff);\n\tnvkm_wr32(device, 0x418890, 0x00000000);\n\tnvkm_wr32(device, 0x418894, 0x00000000);\n\n\tnvkm_wr32(device, 0x4188b4, nvkm_rd32(device, 0x100cc8));\n\tnvkm_wr32(device, 0x4188b8, nvkm_rd32(device, 0x100ccc));\n\tnvkm_wr32(device, 0x4188b0, nvkm_rd32(device, 0x100cc4));\n}\n\nstatic void\ngm200_gr_init_rop_active_fbps(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst u32 fbp_count = nvkm_rd32(device, 0x12006c);\n\tnvkm_mask(device, 0x408850, 0x0000000f, fbp_count);  \n\tnvkm_mask(device, 0x408958, 0x0000000f, fbp_count);  \n}\n\nstatic u8\ngm200_gr_tile_map_6_24[] = {\n\t0, 1, 2, 3, 4, 5, 3, 4, 5, 0, 1, 2, 0, 1, 2, 3, 4, 5, 3, 4, 5, 0, 1, 2,\n};\n\nstatic u8\ngm200_gr_tile_map_4_16[] = {\n\t0, 1, 2, 3, 2, 3, 0, 1, 3, 0, 1, 2, 1, 2, 3, 0,\n};\n\nstatic u8\ngm200_gr_tile_map_2_8[] = {\n\t0, 1, 1, 0, 0, 1, 1, 0,\n};\n\nint\ngm200_gr_oneinit_sm_id(struct gf100_gr *gr)\n{\n\t \n\treturn gf100_gr_oneinit_sm_id(gr);\n}\n\nvoid\ngm200_gr_oneinit_tiles(struct gf100_gr *gr)\n{\n\t \n\tif (gr->gpc_nr == 2 && gr->tpc_total == 8) {\n\t\tmemcpy(gr->tile, gm200_gr_tile_map_2_8, gr->tpc_total);\n\t\tgr->screen_tile_row_offset = 1;\n\t} else\n\tif (gr->gpc_nr == 4 && gr->tpc_total == 16) {\n\t\tmemcpy(gr->tile, gm200_gr_tile_map_4_16, gr->tpc_total);\n\t\tgr->screen_tile_row_offset = 4;\n\t} else\n\tif (gr->gpc_nr == 6 && gr->tpc_total == 24) {\n\t\tmemcpy(gr->tile, gm200_gr_tile_map_6_24, gr->tpc_total);\n\t\tgr->screen_tile_row_offset = 5;\n\t} else {\n\t\tgf100_gr_oneinit_tiles(gr);\n\t}\n}\n\nstatic const struct gf100_gr_func\ngm200_gr = {\n\t.oneinit_tiles = gm200_gr_oneinit_tiles,\n\t.oneinit_sm_id = gm200_gr_oneinit_sm_id,\n\t.init = gf100_gr_init,\n\t.init_gpc_mmu = gm200_gr_init_gpc_mmu,\n\t.init_bios = gm107_gr_init_bios,\n\t.init_vsc_stream_master = gk104_gr_init_vsc_stream_master,\n\t.init_zcull = gf117_gr_init_zcull,\n\t.init_num_active_ltcs = gm200_gr_init_num_active_ltcs,\n\t.init_rop_active_fbps = gm200_gr_init_rop_active_fbps,\n\t.init_fecs_exceptions = gf100_gr_init_fecs_exceptions,\n\t.init_ds_hww_esr_2 = gm200_gr_init_ds_hww_esr_2,\n\t.init_sked_hww_esr = gk104_gr_init_sked_hww_esr,\n\t.init_419cc0 = gf100_gr_init_419cc0,\n\t.init_ppc_exceptions = gk104_gr_init_ppc_exceptions,\n\t.init_tex_hww_esr = gf100_gr_init_tex_hww_esr,\n\t.init_504430 = gm107_gr_init_504430,\n\t.init_shader_exceptions = gm107_gr_init_shader_exceptions,\n\t.init_rop_exceptions = gf100_gr_init_rop_exceptions,\n\t.init_exception2 = gf100_gr_init_exception2,\n\t.init_400054 = gm107_gr_init_400054,\n\t.trap_mp = gf100_gr_trap_mp,\n\t.fecs.reset = gf100_gr_fecs_reset,\n\t.rops = gm200_gr_rops,\n\t.tpc_nr = 4,\n\t.ppc_nr = 2,\n\t.grctx = &gm200_grctx,\n\t.zbc = &gf100_gr_zbc,\n\t.sclass = {\n\t\t{ -1, -1, FERMI_TWOD_A },\n\t\t{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },\n\t\t{ -1, -1, MAXWELL_B, &gf100_fermi },\n\t\t{ -1, -1, MAXWELL_COMPUTE_B },\n\t\t{}\n\t}\n};\n\nint\ngm200_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tint ret;\n\n\tret = nvkm_acr_lsfw_load_bl_inst_data_sig(&gr->base.engine.subdev,\n\t\t\t\t\t\t  &gr->fecs.falcon,\n\t\t\t\t\t\t  NVKM_ACR_LSF_FECS,\n\t\t\t\t\t\t  \"gr/fecs_\", ver, fwif->fecs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_acr_lsfw_load_bl_inst_data_sig(&gr->base.engine.subdev,\n\t\t\t\t\t\t  &gr->gpccs.falcon,\n\t\t\t\t\t\t  NVKM_ACR_LSF_GPCCS,\n\t\t\t\t\t\t  \"gr/gpccs_\", ver,\n\t\t\t\t\t\t  fwif->gpccs);\n\tif (ret)\n\t\treturn ret;\n\n\tgr->firmware = true;\n\n\treturn gk20a_gr_load_sw(gr, \"gr/\", ver);\n}\n\nMODULE_FIRMWARE(\"nvidia/gm200/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/fecs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/fecs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/gpccs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/gpccs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/sw_ctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/sw_nonctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/sw_bundle_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gm200/gr/sw_method_init.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gm204/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/fecs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/fecs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/gpccs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/gpccs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/sw_ctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/sw_nonctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/sw_bundle_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gm204/gr/sw_method_init.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gm206/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/fecs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/fecs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/gpccs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/gpccs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/sw_ctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/sw_nonctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/sw_bundle_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gm206/gr/sw_method_init.bin\");\n\nstatic const struct gf100_gr_fwif\ngm200_gr_fwif[] = {\n\t{  0, gm200_gr_load, &gm200_gr, &gm200_gr_fecs_acr, &gm200_gr_gpccs_acr },\n\t{ -1, gm200_gr_nofw },\n\t{}\n};\n\nint\ngm200_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn gf100_gr_new_(gm200_gr_fwif, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}