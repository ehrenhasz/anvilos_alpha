{
  "module_name": "g94.c",
  "hash_id": "7745e7e59e775ed16ca69bd0615604349b65c529ef4ddeb94c1025bb340ccb57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/g94.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nvoid\ng94_sor_dp_watermark(struct nvkm_ior *sor, int head, u8 watermark)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 loff = nv50_sor_link(sor);\n\n\tnvkm_mask(device, 0x61c128 + loff, 0x0000003f, watermark);\n}\n\nvoid\ng94_sor_dp_activesym(struct nvkm_ior *sor, int head,\n\t\t     u8 TU, u8 VTUa, u8 VTUf, u8 VTUi)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 loff = nv50_sor_link(sor);\n\n\tnvkm_mask(device, 0x61c10c + loff, 0x000001fc, TU << 2);\n\tnvkm_mask(device, 0x61c128 + loff, 0x010f7f00, VTUa << 24 | VTUf << 16 | VTUi << 8);\n}\n\nvoid\ng94_sor_dp_audio_sym(struct nvkm_ior *sor, int head, u16 h, u32 v)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\n\tnvkm_mask(device, 0x61c1e8 + soff, 0x0000ffff, h);\n\tnvkm_mask(device, 0x61c1ec + soff, 0x00ffffff, v);\n}\n\nvoid\ng94_sor_dp_drive(struct nvkm_ior *sor, int ln, int pc, int dc, int pe, int pu)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32  loff = nv50_sor_link(sor);\n\tconst u32 shift = sor->func->dp->lanes[ln] * 8;\n\tu32 data[3];\n\n\tdata[0] = nvkm_rd32(device, 0x61c118 + loff) & ~(0x000000ff << shift);\n\tdata[1] = nvkm_rd32(device, 0x61c120 + loff) & ~(0x000000ff << shift);\n\tdata[2] = nvkm_rd32(device, 0x61c130 + loff);\n\tif ((data[2] & 0x0000ff00) < (pu << 8) || ln == 0)\n\t\tdata[2] = (data[2] & ~0x0000ff00) | (pu << 8);\n\n\tnvkm_wr32(device, 0x61c118 + loff, data[0] | (dc << shift));\n\tnvkm_wr32(device, 0x61c120 + loff, data[1] | (pe << shift));\n\tnvkm_wr32(device, 0x61c130 + loff, data[2]);\n}\n\nvoid\ng94_sor_dp_pattern(struct nvkm_ior *sor, int pattern)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 loff = nv50_sor_link(sor);\n\tu32 data;\n\n\tswitch (pattern) {\n\tcase 0: data = 0x00001000; break;\n\tcase 1: data = 0x01000000; break;\n\tcase 2: data = 0x02000000; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tnvkm_mask(device, 0x61c10c + loff, 0x0f001000, data);\n}\n\nvoid\ng94_sor_dp_power(struct nvkm_ior *sor, int nr)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tconst u32 loff = nv50_sor_link(sor);\n\tu32 mask = 0, i;\n\n\tfor (i = 0; i < nr; i++)\n\t\tmask |= 1 << sor->func->dp->lanes[i];\n\n\tnvkm_mask(device, 0x61c130 + loff, 0x0000000f, mask);\n\tnvkm_mask(device, 0x61c034 + soff, 0x80000000, 0x80000000);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x61c034 + soff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nint\ng94_sor_dp_links(struct nvkm_ior *sor, struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tconst u32 loff = nv50_sor_link(sor);\n\tu32 dpctrl = 0x00000000;\n\tu32 clksor = 0x00000000;\n\n\tdpctrl |= ((1 << sor->dp.nr) - 1) << 16;\n\tif (sor->dp.ef)\n\t\tdpctrl |= 0x00004000;\n\tif (sor->dp.bw > 0x06)\n\t\tclksor |= 0x00040000;\n\n\tnvkm_mask(device, 0x614300 + soff, 0x000c0000, clksor);\n\tnvkm_mask(device, 0x61c10c + loff, 0x001f4000, dpctrl);\n\treturn 0;\n}\n\nconst struct nvkm_ior_func_dp\ng94_sor_dp = {\n\t.lanes = { 2, 1, 0, 3},\n\t.links = g94_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = g94_sor_dp_pattern,\n\t.drive = g94_sor_dp_drive,\n\t.audio_sym = g94_sor_dp_audio_sym,\n\t.activesym = g94_sor_dp_activesym,\n\t.watermark = g94_sor_dp_watermark,\n};\n\nstatic bool\ng94_sor_war_needed(struct nvkm_ior *sor)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\n\tif (sor->asy.proto == TMDS) {\n\t\tswitch (nvkm_rd32(device, 0x614300 + soff) & 0x00030000) {\n\t\tcase 0x00000000:\n\t\tcase 0x00030000:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void\ng94_sor_war_update_sppll1(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tstruct nvkm_ior *ior;\n\tbool used = false;\n\tu32 clksor;\n\n\tlist_for_each_entry(ior, &disp->iors, head) {\n\t\tif (ior->type != SOR)\n\t\t\tcontinue;\n\n\t\tclksor = nvkm_rd32(device, 0x614300 + nv50_ior_base(ior));\n\t\tswitch (clksor & 0x03000000) {\n\t\tcase 0x02000000:\n\t\tcase 0x03000000:\n\t\t\tused = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (used)\n\t\treturn;\n\n\tnvkm_mask(device, 0x00e840, 0x80000000, 0x00000000);\n}\n\nstatic void\ng94_sor_war_3(struct nvkm_ior *sor)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tu32 sorpwr;\n\n\tif (!g94_sor_war_needed(sor))\n\t\treturn;\n\n\tsorpwr = nvkm_rd32(device, 0x61c004 + soff);\n\tif (sorpwr & 0x00000001) {\n\t\tu32 seqctl = nvkm_rd32(device, 0x61c030 + soff);\n\t\tu32  pd_pc = (seqctl & 0x00000f00) >> 8;\n\t\tu32  pu_pc =  seqctl & 0x0000000f;\n\n\t\tnvkm_wr32(device, 0x61c040 + soff + pd_pc * 4, 0x1f008000);\n\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))\n\t\t\t\tbreak;\n\t\t);\n\t\tnvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000000);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))\n\t\t\t\tbreak;\n\t\t);\n\n\t\tnvkm_wr32(device, 0x61c040 + soff + pd_pc * 4, 0x00002000);\n\t\tnvkm_wr32(device, 0x61c040 + soff + pu_pc * 4, 0x1f000000);\n\t}\n\n\tnvkm_mask(device, 0x61c10c + soff, 0x00000001, 0x00000000);\n\tnvkm_mask(device, 0x614300 + soff, 0x03000000, 0x00000000);\n\n\tif (sorpwr & 0x00000001)\n\t\tnvkm_mask(device, 0x61c004 + soff, 0x80000001, 0x80000001);\n\n\tg94_sor_war_update_sppll1(sor->disp);\n}\n\nstatic void\ng94_sor_war_2(struct nvkm_ior *sor)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\n\tif (!g94_sor_war_needed(sor))\n\t\treturn;\n\n\tnvkm_mask(device, 0x00e840, 0x80000000, 0x80000000);\n\tnvkm_mask(device, 0x614300 + soff, 0x03000000, 0x03000000);\n\tnvkm_mask(device, 0x61c10c + soff, 0x00000001, 0x00000001);\n\n\tnvkm_mask(device, 0x61c00c + soff, 0x0f000000, 0x00000000);\n\tnvkm_mask(device, 0x61c008 + soff, 0xff000000, 0x14000000);\n\tnvkm_usec(device, 400, NVKM_DELAY);\n\tnvkm_mask(device, 0x61c008 + soff, 0xff000000, 0x00000000);\n\tnvkm_mask(device, 0x61c00c + soff, 0x0f000000, 0x01000000);\n\n\tif (nvkm_rd32(device, 0x61c004 + soff) & 0x00000001) {\n\t\tu32 seqctl = nvkm_rd32(device, 0x61c030 + soff);\n\t\tu32  pu_pc = seqctl & 0x0000000f;\n\t\tnvkm_wr32(device, 0x61c040 + soff + pu_pc * 4, 0x1f008000);\n\t}\n}\n\nvoid\ng94_sor_state(struct nvkm_ior *sor, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 coff = sor->id * 8 + (state == &sor->arm) * 4;\n\tu32 ctrl = nvkm_rd32(device, 0x610794 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = LVDS; state->link = 1; break;\n\tcase 1: state->proto = TMDS; state->link = 1; break;\n\tcase 2: state->proto = TMDS; state->link = 2; break;\n\tcase 5: state->proto = TMDS; state->link = 3; break;\n\tcase 8: state->proto =   DP; state->link = 1; break;\n\tcase 9: state->proto =   DP; state->link = 2; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x00000003;\n\tnv50_pior_depth(sor, state, ctrl);\n}\n\nstatic const struct nvkm_ior_func\ng94_sor = {\n\t.state = g94_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = nv50_sor_clock,\n\t.war_2 = g94_sor_war_2,\n\t.war_3 = g94_sor_war_3,\n\t.hdmi = &g84_sor_hdmi,\n\t.dp = &g94_sor_dp,\n};\n\nstatic int\ng94_sor_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&g94_sor, disp, SOR, id, false);\n}\n\nint\ng94_sor_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = (nvkm_rd32(device, 0x610184) & 0x0f000000) >> 24;\n\treturn 4;\n}\n\nstatic const struct nvkm_disp_mthd_list\ng94_disp_core_mthd_sor = {\n\t.mthd = 0x0040,\n\t.addr = 0x000008,\n\t.data = {\n\t\t{ 0x0600, 0x610794 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_mthd\ng94_disp_core_mthd = {\n\t.name = \"Core\",\n\t.addr = 0x000000,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &nv50_disp_core_mthd_base },\n\t\t{    \"DAC\", 3, &g84_disp_core_mthd_dac },\n\t\t{    \"SOR\", 4, &g94_disp_core_mthd_sor },\n\t\t{   \"PIOR\", 3, &nv50_disp_core_mthd_pior },\n\t\t{   \"HEAD\", 2, &g84_disp_core_mthd_head },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_user\ng94_disp_core = {\n\t.func = &nv50_disp_core_func,\n\t.ctrl = 0,\n\t.user = 0,\n\t.mthd = &g94_disp_core_mthd,\n};\n\nstatic const struct nvkm_disp_func\ng94_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = nv50_disp_init,\n\t.fini = nv50_disp_fini,\n\t.intr = nv50_disp_intr,\n\t.super = nv50_disp_super,\n\t.uevent = &nv50_disp_chan_uevent,\n\t.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },\n\t.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },\n\t.sor = { .cnt = g94_sor_cnt, .new = g94_sor_new },\n\t.pior = { .cnt = nv50_pior_cnt, .new = nv50_pior_new },\n\t.root = { 0,0,GT206_DISP },\n\t.user = {\n\t\t{{0,0,  G82_DISP_CURSOR             }, nvkm_disp_chan_new, & nv50_disp_curs },\n\t\t{{0,0,  G82_DISP_OVERLAY            }, nvkm_disp_chan_new, & nv50_disp_oimm },\n\t\t{{0,0,GT200_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, &  g84_disp_base },\n\t\t{{0,0,GT206_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, &  g94_disp_core },\n\t\t{{0,0,GT200_DISP_OVERLAY_CHANNEL_DMA}, nvkm_disp_chan_new, &gt200_disp_ovly },\n\t\t{}\n\t},\n};\n\nint\ng94_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t     struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&g94_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}