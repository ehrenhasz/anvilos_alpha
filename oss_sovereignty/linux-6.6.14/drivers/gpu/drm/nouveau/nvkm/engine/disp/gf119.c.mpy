{
  "module_name": "gf119.c",
  "hash_id": "3bf0b0e8921f8219f938725c903feb5941cd40819b39ace1d65279dd735acb68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/gf119.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"hdmi.h\"\n#include \"head.h\"\n#include \"ior.h\"\n#include \"outp.h\"\n\n#include <core/ramht.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstatic void\ngf119_sor_hda_device_entry(struct nvkm_ior *ior, int head)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 hoff = 0x800 * head;\n\n\tnvkm_mask(device, 0x616548 + hoff, 0x00000070, head << 4);\n}\n\nvoid\ngf119_sor_hda_eld(struct nvkm_ior *ior, int head, u8 *data, u8 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 soff = 0x030 * ior->id + (head * 0x04);\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tnvkm_wr32(device, 0x10ec00 + soff, (i << 8) | data[i]);\n\tfor (; i < 0x60; i++)\n\t\tnvkm_wr32(device, 0x10ec00 + soff, (i << 8));\n\tnvkm_mask(device, 0x10ec10 + soff, 0x80000002, 0x80000002);\n}\n\nvoid\ngf119_sor_hda_hpd(struct nvkm_ior *ior, int head, bool present)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 soff = 0x030 * ior->id + (head * 0x04);\n\tu32 data = 0x80000000;\n\tu32 mask = 0x80000001;\n\n\tif (present) {\n\t\tior->func->hda->device_entry(ior, head);\n\t\tdata |= 0x00000001;\n\t} else {\n\t\tmask |= 0x00000002;\n\t}\n\n\tnvkm_mask(device, 0x10ec10 + soff, mask, data);\n}\n\nconst struct nvkm_ior_func_hda\ngf119_sor_hda = {\n\t.hpd = gf119_sor_hda_hpd,\n\t.eld = gf119_sor_hda_eld,\n\t.device_entry = gf119_sor_hda_device_entry,\n};\n\nvoid\ngf119_sor_dp_watermark(struct nvkm_ior *sor, int head, u8 watermark)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x616610 + hoff, 0x0800003f, 0x08000000 | watermark);\n}\n\nvoid\ngf119_sor_dp_audio_sym(struct nvkm_ior *sor, int head, u16 h, u32 v)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x616620 + hoff, 0x0000ffff, h);\n\tnvkm_mask(device, 0x616624 + hoff, 0x00ffffff, v);\n}\n\nvoid\ngf119_sor_dp_audio(struct nvkm_ior *sor, int head, bool enable)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = 0x800 * head;\n\tconst u32 data = 0x80000000 | (0x00000001 * enable);\n\tconst u32 mask = 0x8000000d;\n\n\tnvkm_mask(device, 0x616618 + hoff, mask, data);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x616618 + hoff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nvoid\ngf119_sor_dp_vcpi(struct nvkm_ior *sor, int head, u8 slot, u8 slot_nr, u16 pbn, u16 aligned)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x616588 + hoff, 0x00003f3f, (slot_nr << 8) | slot);\n\tnvkm_mask(device, 0x61658c + hoff, 0xffffffff, (aligned << 16) | pbn);\n}\n\nvoid\ngf119_sor_dp_drive(struct nvkm_ior *sor, int ln, int pc, int dc, int pe, int pu)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32  loff = nv50_sor_link(sor);\n\tconst u32 shift = sor->func->dp->lanes[ln] * 8;\n\tu32 data[4];\n\n\tdata[0] = nvkm_rd32(device, 0x61c118 + loff) & ~(0x000000ff << shift);\n\tdata[1] = nvkm_rd32(device, 0x61c120 + loff) & ~(0x000000ff << shift);\n\tdata[2] = nvkm_rd32(device, 0x61c130 + loff);\n\tif ((data[2] & 0x0000ff00) < (pu << 8) || ln == 0)\n\t\tdata[2] = (data[2] & ~0x0000ff00) | (pu << 8);\n\n\tnvkm_wr32(device, 0x61c118 + loff, data[0] | (dc << shift));\n\tnvkm_wr32(device, 0x61c120 + loff, data[1] | (pe << shift));\n\tnvkm_wr32(device, 0x61c130 + loff, data[2]);\n\n\tdata[3] = nvkm_rd32(device, 0x61c13c + loff) & ~(0x000000ff << shift);\n\tnvkm_wr32(device, 0x61c13c + loff, data[3] | (pc << shift));\n}\n\nstatic void\ngf119_sor_dp_pattern(struct nvkm_ior *sor, int pattern)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tu32 data;\n\n\tswitch (pattern) {\n\tcase 0: data = 0x10101010; break;\n\tcase 1: data = 0x01010101; break;\n\tcase 2: data = 0x02020202; break;\n\tcase 3: data = 0x03030303; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tnvkm_mask(device, 0x61c110 + soff, 0x1f1f1f1f, data);\n}\n\nint\ngf119_sor_dp_links(struct nvkm_ior *sor, struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tconst u32 loff = nv50_sor_link(sor);\n\tu32 dpctrl = 0x00000000;\n\tu32 clksor = 0x00000000;\n\n\tclksor |= sor->dp.bw << 18;\n\tdpctrl |= ((1 << sor->dp.nr) - 1) << 16;\n\tif (sor->dp.mst)\n\t\tdpctrl |= 0x40000000;\n\tif (sor->dp.ef)\n\t\tdpctrl |= 0x00004000;\n\n\tnvkm_mask(device, 0x612300 + soff, 0x007c0000, clksor);\n\tnvkm_mask(device, 0x61c10c + loff, 0x401f4000, dpctrl);\n\treturn 0;\n}\n\nconst struct nvkm_ior_func_dp\ngf119_sor_dp = {\n\t.lanes = { 2, 1, 0, 3 },\n\t.links = gf119_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = gf119_sor_dp_pattern,\n\t.drive = gf119_sor_dp_drive,\n\t.vcpi = gf119_sor_dp_vcpi,\n\t.audio = gf119_sor_dp_audio,\n\t.audio_sym = gf119_sor_dp_audio_sym,\n\t.watermark = gf119_sor_dp_watermark,\n};\n\nstatic void\ngf119_sor_hdmi_infoframe_vsi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe vsi;\n\tconst u32 hoff = head * 0x800;\n\n\tpack_hdmi_infoframe(&vsi, data, size);\n\n\tnvkm_mask(device, 0x616730 + hoff, 0x00010001, 0x00010000);\n\tif (!size)\n\t\treturn;\n\n\t \n\tnvkm_wr32(device, 0x616738 + hoff, vsi.header);\n\tnvkm_wr32(device, 0x61673c + hoff, vsi.subpack0_low);\n\tnvkm_wr32(device, 0x616740 + hoff, vsi.subpack0_high);\n\t \n\n\tnvkm_mask(device, 0x616730 + hoff, 0x00000001, 0x00000001);\n}\n\nstatic void\ngf119_sor_hdmi_infoframe_avi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe avi;\n\tconst u32 hoff = head * 0x800;\n\n\tpack_hdmi_infoframe(&avi, data, size);\n\n\tnvkm_mask(device, 0x616714 + hoff, 0x00000001, 0x00000000);\n\tif (!size)\n\t\treturn;\n\n\tnvkm_wr32(device, 0x61671c + hoff, avi.header);\n\tnvkm_wr32(device, 0x616720 + hoff, avi.subpack0_low);\n\tnvkm_wr32(device, 0x616724 + hoff, avi.subpack0_high);\n\tnvkm_wr32(device, 0x616728 + hoff, avi.subpack1_low);\n\tnvkm_wr32(device, 0x61672c + hoff, avi.subpack1_high);\n\n\tnvkm_mask(device, 0x616714 + hoff, 0x00000001, 0x00000001);\n}\n\nstatic void\ngf119_sor_hdmi_ctrl(struct nvkm_ior *ior, int head, bool enable, u8 max_ac_packet, u8 rekey)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 ctrl = 0x40000000 * enable |\n\t\t\t max_ac_packet << 16 |\n\t\t\t rekey;\n\tconst u32 hoff = head * 0x800;\n\n\tif (!(ctrl & 0x40000000)) {\n\t\tnvkm_mask(device, 0x616798 + hoff, 0x40000000, 0x00000000);\n\t\tnvkm_mask(device, 0x616730 + hoff, 0x00000001, 0x00000000);\n\t\tnvkm_mask(device, 0x6167a4 + hoff, 0x00000001, 0x00000000);\n\t\tnvkm_mask(device, 0x616714 + hoff, 0x00000001, 0x00000000);\n\t\treturn;\n\t}\n\n\t \n\tnvkm_mask(device, 0x6167a4 + hoff, 0x00000001, 0x00000000);\n\tnvkm_wr32(device, 0x6167ac + hoff, 0x00000010);\n\tnvkm_mask(device, 0x6167a4 + hoff, 0x00000001, 0x00000001);\n\n\t \n\tnvkm_mask(device, 0x616798 + hoff, 0x401f007f, ctrl);\n}\n\nstatic const struct nvkm_ior_func_hdmi\ngf119_sor_hdmi = {\n\t.ctrl = gf119_sor_hdmi_ctrl,\n\t.infoframe_avi = gf119_sor_hdmi_infoframe_avi,\n\t.infoframe_vsi = gf119_sor_hdmi_infoframe_vsi,\n};\n\nvoid\ngf119_sor_clock(struct nvkm_ior *sor)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tu32 div1 = sor->asy.link == 3;\n\tu32 div2 = sor->asy.link == 3;\n\n\tif (sor->asy.proto == TMDS) {\n\t\tconst u32 speed = sor->tmds.high_speed ? 0x14 : 0x0a;\n\t\tnvkm_mask(device, 0x612300 + soff, 0x007c0000, speed << 18);\n\t\tif (sor->tmds.high_speed)\n\t\t\tdiv2 = 1;\n\t}\n\n\tnvkm_mask(device, 0x612300 + soff, 0x00000707, (div2 << 8) | div1);\n}\n\nvoid\ngf119_sor_state(struct nvkm_ior *sor, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 coff = (state == &sor->asy) * 0x20000 + sor->id * 0x20;\n\tu32 ctrl = nvkm_rd32(device, 0x640200 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = LVDS; state->link = 1; break;\n\tcase 1: state->proto = TMDS; state->link = 1; break;\n\tcase 2: state->proto = TMDS; state->link = 2; break;\n\tcase 5: state->proto = TMDS; state->link = 3; break;\n\tcase 8: state->proto =   DP; state->link = 1; break;\n\tcase 9: state->proto =   DP; state->link = 2; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x0000000f;\n}\n\nstatic const struct nvkm_ior_func\ngf119_sor = {\n\t.state = gf119_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = gf119_sor_clock,\n\t.hdmi = &gf119_sor_hdmi,\n\t.dp = &gf119_sor_dp,\n\t.hda = &gf119_sor_hda,\n};\n\nstatic int\ngf119_sor_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&gf119_sor, disp, SOR, id, true);\n}\n\nint\ngf119_sor_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\t*pmask = (nvkm_rd32(device, 0x612004) & 0x0000ff00) >> 8;\n\treturn 8;\n}\n\nstatic void\ngf119_dac_clock(struct nvkm_ior *dac)\n{\n\tstruct nvkm_device *device = dac->disp->engine.subdev.device;\n\tconst u32 doff = nv50_ior_base(dac);\n\tnvkm_mask(device, 0x612280 + doff, 0x07070707, 0x00000000);\n}\n\nstatic void\ngf119_dac_state(struct nvkm_ior *dac, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = dac->disp->engine.subdev.device;\n\tconst u32 coff = (state == &dac->asy) * 0x20000 + dac->id * 0x20;\n\tu32 ctrl = nvkm_rd32(device, 0x640180 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = CRT; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x0000000f;\n}\n\nstatic const struct nvkm_ior_func\ngf119_dac = {\n\t.state = gf119_dac_state,\n\t.power = nv50_dac_power,\n\t.sense = nv50_dac_sense,\n\t.clock = gf119_dac_clock,\n};\n\nint\ngf119_dac_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&gf119_dac, disp, DAC, id, false);\n}\n\nint\ngf119_dac_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\t*pmask = (nvkm_rd32(device, 0x612004) & 0x000000f0) >> 4;\n\treturn 4;\n}\n\nstatic void\ngf119_head_vblank_put(struct nvkm_head *head)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = head->id * 0x800;\n\tnvkm_mask(device, 0x6100c0 + hoff, 0x00000001, 0x00000000);\n}\n\nstatic void\ngf119_head_vblank_get(struct nvkm_head *head)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = head->id * 0x800;\n\tnvkm_mask(device, 0x6100c0 + hoff, 0x00000001, 0x00000001);\n}\n\nvoid\ngf119_head_rgclk(struct nvkm_head *head, int div)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tnvkm_mask(device, 0x612200 + (head->id * 0x800), 0x0000000f, div);\n}\n\nstatic void\ngf119_head_state(struct nvkm_head *head, struct nvkm_head_state *state)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = (state == &head->asy) * 0x20000 + head->id * 0x300;\n\tu32 data;\n\n\tdata = nvkm_rd32(device, 0x640414 + hoff);\n\tstate->vtotal = (data & 0xffff0000) >> 16;\n\tstate->htotal = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x640418 + hoff);\n\tstate->vsynce = (data & 0xffff0000) >> 16;\n\tstate->hsynce = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x64041c + hoff);\n\tstate->vblanke = (data & 0xffff0000) >> 16;\n\tstate->hblanke = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x640420 + hoff);\n\tstate->vblanks = (data & 0xffff0000) >> 16;\n\tstate->hblanks = (data & 0x0000ffff);\n\tstate->hz = nvkm_rd32(device, 0x640450 + hoff);\n\n\tdata = nvkm_rd32(device, 0x640404 + hoff);\n\tswitch ((data & 0x000003c0) >> 6) {\n\tcase 6: state->or.depth = 30; break;\n\tcase 5: state->or.depth = 24; break;\n\tcase 2: state->or.depth = 18; break;\n\tcase 0: state->or.depth = 18; break;  \n\tdefault:\n\t\tstate->or.depth = 18;\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic const struct nvkm_head_func\ngf119_head = {\n\t.state = gf119_head_state,\n\t.rgpos = nv50_head_rgpos,\n\t.rgclk = gf119_head_rgclk,\n\t.vblank_get = gf119_head_vblank_get,\n\t.vblank_put = gf119_head_vblank_put,\n};\n\nint\ngf119_head_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_head_new_(&gf119_head, disp, id);\n}\n\nint\ngf119_head_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\t*pmask = nvkm_rd32(device, 0x612004) & 0x0000000f;\n\treturn nvkm_rd32(device, 0x022448);\n}\n\nstatic void\ngf119_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_disp *disp = container_of(event, typeof(*disp), uevent);\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tnvkm_mask(device, 0x610090, 0x00000001 << index, 0x00000000 << index);\n\tnvkm_wr32(device, 0x61008c, 0x00000001 << index);\n}\n\nstatic void\ngf119_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)\n{\n\tstruct nvkm_disp *disp = container_of(event, typeof(*disp), uevent);\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tnvkm_wr32(device, 0x61008c, 0x00000001 << index);\n\tnvkm_mask(device, 0x610090, 0x00000001 << index, 0x00000001 << index);\n}\n\nconst struct nvkm_event_func\ngf119_disp_chan_uevent = {\n\t.init = gf119_disp_chan_uevent_init,\n\t.fini = gf119_disp_chan_uevent_fini,\n};\n\nvoid\ngf119_disp_chan_intr(struct nvkm_disp_chan *chan, bool en)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 mask = 0x00000001 << chan->chid.user;\n\tif (!en) {\n\t\tnvkm_mask(device, 0x610090, mask, 0x00000000);\n\t\tnvkm_mask(device, 0x6100a0, mask, 0x00000000);\n\t} else {\n\t\tnvkm_mask(device, 0x6100a0, mask, mask);\n\t}\n}\n\nstatic void\ngf119_disp_pioc_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_disp *disp = chan->disp;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\tnvkm_mask(device, 0x610490 + (ctrl * 0x10), 0x00000001, 0x00000000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490 + (ctrl * 0x10)) & 0x00030000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d fini: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610490 + (ctrl * 0x10)));\n\t}\n}\n\nstatic int\ngf119_disp_pioc_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_disp *disp = chan->disp;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\t \n\tnvkm_wr32(device, 0x610490 + (ctrl * 0x10), 0x00000001);\n\tif (nvkm_msec(device, 2000,\n\t\tu32 tmp = nvkm_rd32(device, 0x610490 + (ctrl * 0x10));\n\t\tif ((tmp & 0x00030000) == 0x00010000)\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d init: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610490 + (ctrl * 0x10)));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\ngf119_disp_pioc_func = {\n\t.init = gf119_disp_pioc_init,\n\t.fini = gf119_disp_pioc_fini,\n\t.intr = gf119_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n};\n\nint\ngf119_disp_dmac_bind(struct nvkm_disp_chan *chan, struct nvkm_object *object, u32 handle)\n{\n\treturn nvkm_ramht_insert(chan->disp->ramht, object, chan->chid.user, -9, handle,\n\t\t\t\t chan->chid.user << 27 | 0x00000001);\n}\n\nvoid\ngf119_disp_dmac_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\t \n\tnvkm_mask(device, 0x610490 + (ctrl * 0x0010), 0x00001010, 0x00001000);\n\tnvkm_mask(device, 0x610490 + (ctrl * 0x0010), 0x00000003, 0x00000000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490 + (ctrl * 0x10)) & 0x001e0000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d fini: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610490 + (ctrl * 0x10)));\n\t}\n\n\tchan->suspend_put = nvkm_rd32(device, 0x640000 + (ctrl * 0x1000));\n}\n\nstatic int\ngf119_disp_dmac_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\t \n\tnvkm_wr32(device, 0x610494 + (ctrl * 0x0010), chan->push);\n\tnvkm_wr32(device, 0x610498 + (ctrl * 0x0010), 0x00010000);\n\tnvkm_wr32(device, 0x61049c + (ctrl * 0x0010), 0x00000001);\n\tnvkm_mask(device, 0x610490 + (ctrl * 0x0010), 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x640000 + (ctrl * 0x1000), chan->suspend_put);\n\tnvkm_wr32(device, 0x610490 + (ctrl * 0x0010), 0x00000013);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490 + (ctrl * 0x10)) & 0x80000000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d init: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610490 + (ctrl * 0x10)));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\ngf119_disp_dmac_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gf119_disp_dmac_init,\n\t.fini = gf119_disp_dmac_fini,\n\t.intr = gf119_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n\t.bind = gf119_disp_dmac_bind,\n};\n\nconst struct nvkm_disp_chan_user\ngf119_disp_curs = {\n\t.func = &gf119_disp_pioc_func,\n\t.ctrl = 13,\n\t.user = 13,\n};\n\nconst struct nvkm_disp_chan_user\ngf119_disp_oimm = {\n\t.func = &gf119_disp_pioc_func,\n\t.ctrl = 9,\n\t.user = 9,\n};\n\nstatic const struct nvkm_disp_mthd_list\ngf119_disp_ovly_mthd_base = {\n\t.mthd = 0x0000,\n\t.data = {\n\t\t{ 0x0080, 0x665080 },\n\t\t{ 0x0084, 0x665084 },\n\t\t{ 0x0088, 0x665088 },\n\t\t{ 0x008c, 0x66508c },\n\t\t{ 0x0090, 0x665090 },\n\t\t{ 0x0094, 0x665094 },\n\t\t{ 0x00a0, 0x6650a0 },\n\t\t{ 0x00a4, 0x6650a4 },\n\t\t{ 0x00b0, 0x6650b0 },\n\t\t{ 0x00b4, 0x6650b4 },\n\t\t{ 0x00b8, 0x6650b8 },\n\t\t{ 0x00c0, 0x6650c0 },\n\t\t{ 0x00e0, 0x6650e0 },\n\t\t{ 0x00e4, 0x6650e4 },\n\t\t{ 0x00e8, 0x6650e8 },\n\t\t{ 0x0100, 0x665100 },\n\t\t{ 0x0104, 0x665104 },\n\t\t{ 0x0108, 0x665108 },\n\t\t{ 0x010c, 0x66510c },\n\t\t{ 0x0110, 0x665110 },\n\t\t{ 0x0118, 0x665118 },\n\t\t{ 0x011c, 0x66511c },\n\t\t{ 0x0120, 0x665120 },\n\t\t{ 0x0124, 0x665124 },\n\t\t{ 0x0130, 0x665130 },\n\t\t{ 0x0134, 0x665134 },\n\t\t{ 0x0138, 0x665138 },\n\t\t{ 0x013c, 0x66513c },\n\t\t{ 0x0140, 0x665140 },\n\t\t{ 0x0144, 0x665144 },\n\t\t{ 0x0148, 0x665148 },\n\t\t{ 0x014c, 0x66514c },\n\t\t{ 0x0150, 0x665150 },\n\t\t{ 0x0154, 0x665154 },\n\t\t{ 0x0158, 0x665158 },\n\t\t{ 0x015c, 0x66515c },\n\t\t{ 0x0160, 0x665160 },\n\t\t{ 0x0164, 0x665164 },\n\t\t{ 0x0168, 0x665168 },\n\t\t{ 0x016c, 0x66516c },\n\t\t{ 0x0400, 0x665400 },\n\t\t{ 0x0408, 0x665408 },\n\t\t{ 0x040c, 0x66540c },\n\t\t{ 0x0410, 0x665410 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\ngf119_disp_ovly_mthd = {\n\t.name = \"Overlay\",\n\t.addr = 0x001000,\n\t.prev = -0x020000,\n\t.data = {\n\t\t{ \"Global\", 1, &gf119_disp_ovly_mthd_base },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_user\ngf119_disp_ovly = {\n\t.func = &gf119_disp_dmac_func,\n\t.ctrl = 5,\n\t.user = 5,\n\t.mthd = &gf119_disp_ovly_mthd,\n};\n\nstatic const struct nvkm_disp_mthd_list\ngf119_disp_base_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x661080 },\n\t\t{ 0x0084, 0x661084 },\n\t\t{ 0x0088, 0x661088 },\n\t\t{ 0x008c, 0x66108c },\n\t\t{ 0x0090, 0x661090 },\n\t\t{ 0x0094, 0x661094 },\n\t\t{ 0x00a0, 0x6610a0 },\n\t\t{ 0x00a4, 0x6610a4 },\n\t\t{ 0x00c0, 0x6610c0 },\n\t\t{ 0x00c4, 0x6610c4 },\n\t\t{ 0x00c8, 0x6610c8 },\n\t\t{ 0x00cc, 0x6610cc },\n\t\t{ 0x00e0, 0x6610e0 },\n\t\t{ 0x00e4, 0x6610e4 },\n\t\t{ 0x00e8, 0x6610e8 },\n\t\t{ 0x00ec, 0x6610ec },\n\t\t{ 0x00fc, 0x6610fc },\n\t\t{ 0x0100, 0x661100 },\n\t\t{ 0x0104, 0x661104 },\n\t\t{ 0x0108, 0x661108 },\n\t\t{ 0x010c, 0x66110c },\n\t\t{ 0x0110, 0x661110 },\n\t\t{ 0x0114, 0x661114 },\n\t\t{ 0x0118, 0x661118 },\n\t\t{ 0x011c, 0x66111c },\n\t\t{ 0x0130, 0x661130 },\n\t\t{ 0x0134, 0x661134 },\n\t\t{ 0x0138, 0x661138 },\n\t\t{ 0x013c, 0x66113c },\n\t\t{ 0x0140, 0x661140 },\n\t\t{ 0x0144, 0x661144 },\n\t\t{ 0x0148, 0x661148 },\n\t\t{ 0x014c, 0x66114c },\n\t\t{ 0x0150, 0x661150 },\n\t\t{ 0x0154, 0x661154 },\n\t\t{ 0x0158, 0x661158 },\n\t\t{ 0x015c, 0x66115c },\n\t\t{ 0x0160, 0x661160 },\n\t\t{ 0x0164, 0x661164 },\n\t\t{ 0x0168, 0x661168 },\n\t\t{ 0x016c, 0x66116c },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\ngf119_disp_base_mthd_image = {\n\t.mthd = 0x0020,\n\t.addr = 0x000020,\n\t.data = {\n\t\t{ 0x0400, 0x661400 },\n\t\t{ 0x0404, 0x661404 },\n\t\t{ 0x0408, 0x661408 },\n\t\t{ 0x040c, 0x66140c },\n\t\t{ 0x0410, 0x661410 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_mthd\ngf119_disp_base_mthd = {\n\t.name = \"Base\",\n\t.addr = 0x001000,\n\t.prev = -0x020000,\n\t.data = {\n\t\t{ \"Global\", 1, &gf119_disp_base_mthd_base },\n\t\t{  \"Image\", 2, &gf119_disp_base_mthd_image },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_user\ngf119_disp_base = {\n\t.func = &gf119_disp_dmac_func,\n\t.ctrl = 1,\n\t.user = 1,\n\t.mthd = &gf119_disp_base_mthd,\n};\n\nconst struct nvkm_disp_mthd_list\ngf119_disp_core_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x660080 },\n\t\t{ 0x0084, 0x660084 },\n\t\t{ 0x0088, 0x660088 },\n\t\t{ 0x008c, 0x000000 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\ngf119_disp_core_mthd_dac = {\n\t.mthd = 0x0020,\n\t.addr = 0x000020,\n\t.data = {\n\t\t{ 0x0180, 0x660180 },\n\t\t{ 0x0184, 0x660184 },\n\t\t{ 0x0188, 0x660188 },\n\t\t{ 0x0190, 0x660190 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\ngf119_disp_core_mthd_sor = {\n\t.mthd = 0x0020,\n\t.addr = 0x000020,\n\t.data = {\n\t\t{ 0x0200, 0x660200 },\n\t\t{ 0x0204, 0x660204 },\n\t\t{ 0x0208, 0x660208 },\n\t\t{ 0x0210, 0x660210 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\ngf119_disp_core_mthd_pior = {\n\t.mthd = 0x0020,\n\t.addr = 0x000020,\n\t.data = {\n\t\t{ 0x0300, 0x660300 },\n\t\t{ 0x0304, 0x660304 },\n\t\t{ 0x0308, 0x660308 },\n\t\t{ 0x0310, 0x660310 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\ngf119_disp_core_mthd_head = {\n\t.mthd = 0x0300,\n\t.addr = 0x000300,\n\t.data = {\n\t\t{ 0x0400, 0x660400 },\n\t\t{ 0x0404, 0x660404 },\n\t\t{ 0x0408, 0x660408 },\n\t\t{ 0x040c, 0x66040c },\n\t\t{ 0x0410, 0x660410 },\n\t\t{ 0x0414, 0x660414 },\n\t\t{ 0x0418, 0x660418 },\n\t\t{ 0x041c, 0x66041c },\n\t\t{ 0x0420, 0x660420 },\n\t\t{ 0x0424, 0x660424 },\n\t\t{ 0x0428, 0x660428 },\n\t\t{ 0x042c, 0x66042c },\n\t\t{ 0x0430, 0x660430 },\n\t\t{ 0x0434, 0x660434 },\n\t\t{ 0x0438, 0x660438 },\n\t\t{ 0x0440, 0x660440 },\n\t\t{ 0x0444, 0x660444 },\n\t\t{ 0x0448, 0x660448 },\n\t\t{ 0x044c, 0x66044c },\n\t\t{ 0x0450, 0x660450 },\n\t\t{ 0x0454, 0x660454 },\n\t\t{ 0x0458, 0x660458 },\n\t\t{ 0x045c, 0x66045c },\n\t\t{ 0x0460, 0x660460 },\n\t\t{ 0x0468, 0x660468 },\n\t\t{ 0x046c, 0x66046c },\n\t\t{ 0x0470, 0x660470 },\n\t\t{ 0x0474, 0x660474 },\n\t\t{ 0x0480, 0x660480 },\n\t\t{ 0x0484, 0x660484 },\n\t\t{ 0x048c, 0x66048c },\n\t\t{ 0x0490, 0x660490 },\n\t\t{ 0x0494, 0x660494 },\n\t\t{ 0x0498, 0x660498 },\n\t\t{ 0x04b0, 0x6604b0 },\n\t\t{ 0x04b8, 0x6604b8 },\n\t\t{ 0x04bc, 0x6604bc },\n\t\t{ 0x04c0, 0x6604c0 },\n\t\t{ 0x04c4, 0x6604c4 },\n\t\t{ 0x04c8, 0x6604c8 },\n\t\t{ 0x04d0, 0x6604d0 },\n\t\t{ 0x04d4, 0x6604d4 },\n\t\t{ 0x04e0, 0x6604e0 },\n\t\t{ 0x04e4, 0x6604e4 },\n\t\t{ 0x04e8, 0x6604e8 },\n\t\t{ 0x04ec, 0x6604ec },\n\t\t{ 0x04f0, 0x6604f0 },\n\t\t{ 0x04f4, 0x6604f4 },\n\t\t{ 0x04f8, 0x6604f8 },\n\t\t{ 0x04fc, 0x6604fc },\n\t\t{ 0x0500, 0x660500 },\n\t\t{ 0x0504, 0x660504 },\n\t\t{ 0x0508, 0x660508 },\n\t\t{ 0x050c, 0x66050c },\n\t\t{ 0x0510, 0x660510 },\n\t\t{ 0x0514, 0x660514 },\n\t\t{ 0x0518, 0x660518 },\n\t\t{ 0x051c, 0x66051c },\n\t\t{ 0x052c, 0x66052c },\n\t\t{ 0x0530, 0x660530 },\n\t\t{ 0x054c, 0x66054c },\n\t\t{ 0x0550, 0x660550 },\n\t\t{ 0x0554, 0x660554 },\n\t\t{ 0x0558, 0x660558 },\n\t\t{ 0x055c, 0x66055c },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\ngf119_disp_core_mthd = {\n\t.name = \"Core\",\n\t.addr = 0x000000,\n\t.prev = -0x020000,\n\t.data = {\n\t\t{ \"Global\", 1, &gf119_disp_core_mthd_base },\n\t\t{    \"DAC\", 3, &gf119_disp_core_mthd_dac  },\n\t\t{    \"SOR\", 8, &gf119_disp_core_mthd_sor  },\n\t\t{   \"PIOR\", 4, &gf119_disp_core_mthd_pior },\n\t\t{   \"HEAD\", 4, &gf119_disp_core_mthd_head },\n\t\t{}\n\t}\n};\n\nvoid\ngf119_disp_core_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tnvkm_mask(device, 0x610490, 0x00000010, 0x00000000);\n\tnvkm_mask(device, 0x610490, 0x00000003, 0x00000000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490) & 0x001e0000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"core fini: %08x\\n\",\n\t\t\t   nvkm_rd32(device, 0x610490));\n\t}\n\n\tchan->suspend_put = nvkm_rd32(device, 0x640000);\n}\n\nstatic int\ngf119_disp_core_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tnvkm_wr32(device, 0x610494, chan->push);\n\tnvkm_wr32(device, 0x610498, 0x00010000);\n\tnvkm_wr32(device, 0x61049c, 0x00000001);\n\tnvkm_mask(device, 0x610490, 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x640000, chan->suspend_put);\n\tnvkm_wr32(device, 0x610490, 0x01000013);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490) & 0x80000000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"core init: %08x\\n\",\n\t\t\t   nvkm_rd32(device, 0x610490));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\ngf119_disp_core_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gf119_disp_core_init,\n\t.fini = gf119_disp_core_fini,\n\t.intr = gf119_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n\t.bind = gf119_disp_dmac_bind,\n};\n\nstatic const struct nvkm_disp_chan_user\ngf119_disp_core = {\n\t.func = &gf119_disp_core_func,\n\t.ctrl = 0,\n\t.user = 0,\n\t.mthd = &gf119_disp_core_mthd,\n};\n\nvoid\ngf119_disp_super(struct work_struct *work)\n{\n\tstruct nvkm_disp *disp = container_of(work, struct nvkm_disp, super.work);\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_head *head;\n\tu32 mask[4];\n\n\tnvkm_debug(subdev, \"supervisor %d\\n\", ffs(disp->super.pending));\n\tmutex_lock(&disp->super.mutex);\n\n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tmask[head->id] = nvkm_rd32(device, 0x6101d4 + (head->id * 0x800));\n\t\tHEAD_DBG(head, \"%08x\", mask[head->id]);\n\t}\n\n\tif (disp->super.pending & 0x00000001) {\n\t\tnv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);\n\t\tnv50_disp_super_1(disp);\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_1_0(disp, head);\n\t\t}\n\t} else\n\tif (disp->super.pending & 0x00000002) {\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_0(disp, head);\n\t\t}\n\t\tnvkm_outp_route(disp);\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00010000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_1(disp, head);\n\t\t}\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_2(disp, head);\n\t\t}\n\t} else\n\tif (disp->super.pending & 0x00000004) {\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_3_0(disp, head);\n\t\t}\n\t}\n\n\tlist_for_each_entry(head, &disp->heads, head)\n\t\tnvkm_wr32(device, 0x6101d4 + (head->id * 0x800), 0x00000000);\n\n\tnvkm_wr32(device, 0x6101d0, 0x80000000);\n\tmutex_unlock(&disp->super.mutex);\n}\n\nvoid\ngf119_disp_intr_error(struct nvkm_disp *disp, int chid)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x6101f0 + (chid * 12));\n\tu32 type = (stat & 0x00007000) >> 12;\n\tu32 mthd = (stat & 0x00000ffc);\n\tu32 data = nvkm_rd32(device, 0x6101f4 + (chid * 12));\n\tu32 code = nvkm_rd32(device, 0x6101f8 + (chid * 12));\n\tconst struct nvkm_enum *reason =\n\t\tnvkm_enum_find(nv50_disp_intr_error_type, type);\n\n\tnvkm_error(subdev, \"chid %d stat %08x reason %d [%s] mthd %04x \"\n\t\t\t   \"data %08x code %08x\\n\",\n\t\t   chid, stat, type, reason ? reason->name : \"\",\n\t\t   mthd, data, code);\n\n\tif (chid < ARRAY_SIZE(disp->chan)) {\n\t\tswitch (mthd) {\n\t\tcase 0x0080:\n\t\t\tnv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x61009c, (1 << chid));\n\tnvkm_wr32(device, 0x6101f0 + (chid * 12), 0x90000000);\n}\n\nvoid\ngf119_disp_intr(struct nvkm_disp *disp)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_head *head;\n\tu32 intr = nvkm_rd32(device, 0x610088);\n\n\tif (intr & 0x00000001) {\n\t\tu32 stat = nvkm_rd32(device, 0x61008c);\n\t\twhile (stat) {\n\t\t\tint chid = __ffs(stat); stat &= ~(1 << chid);\n\t\t\tnv50_disp_chan_uevent_send(disp, chid);\n\t\t\tnvkm_wr32(device, 0x61008c, 1 << chid);\n\t\t}\n\t\tintr &= ~0x00000001;\n\t}\n\n\tif (intr & 0x00000002) {\n\t\tu32 stat = nvkm_rd32(device, 0x61009c);\n\t\tint chid = ffs(stat) - 1;\n\t\tif (chid >= 0)\n\t\t\tdisp->func->intr_error(disp, chid);\n\t\tintr &= ~0x00000002;\n\t}\n\n\tif (intr & 0x00100000) {\n\t\tu32 stat = nvkm_rd32(device, 0x6100ac);\n\t\tif (stat & 0x00000007) {\n\t\t\tdisp->super.pending = (stat & 0x00000007);\n\t\t\tqueue_work(disp->super.wq, &disp->super.work);\n\t\t\tnvkm_wr32(device, 0x6100ac, disp->super.pending);\n\t\t\tstat &= ~0x00000007;\n\t\t}\n\n\t\tif (stat) {\n\t\t\tnvkm_warn(subdev, \"intr24 %08x\\n\", stat);\n\t\t\tnvkm_wr32(device, 0x6100ac, stat);\n\t\t}\n\n\t\tintr &= ~0x00100000;\n\t}\n\n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst u32 hoff = head->id * 0x800;\n\t\tu32 mask = 0x01000000 << head->id;\n\t\tif (mask & intr) {\n\t\t\tu32 stat = nvkm_rd32(device, 0x6100bc + hoff);\n\t\t\tif (stat & 0x00000001)\n\t\t\t\tnvkm_disp_vblank(disp, head->id);\n\t\t\tnvkm_mask(device, 0x6100bc + hoff, 0, 0);\n\t\t\tnvkm_rd32(device, 0x6100c0 + hoff);\n\t\t}\n\t}\n}\n\nvoid\ngf119_disp_fini(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\t \n\tnvkm_wr32(device, 0x6100b0, 0x00000000);\n}\n\nint\ngf119_disp_init(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tstruct nvkm_head *head;\n\tu32 tmp;\n\tint i;\n\n\t \n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst u32 hoff = head->id * 0x800;\n\t\ttmp = nvkm_rd32(device, 0x616104 + hoff);\n\t\tnvkm_wr32(device, 0x6101b4 + hoff, tmp);\n\t\ttmp = nvkm_rd32(device, 0x616108 + hoff);\n\t\tnvkm_wr32(device, 0x6101b8 + hoff, tmp);\n\t\ttmp = nvkm_rd32(device, 0x61610c + hoff);\n\t\tnvkm_wr32(device, 0x6101bc + hoff, tmp);\n\t}\n\n\t \n\tfor (i = 0; i < disp->dac.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));\n\t\tnvkm_wr32(device, 0x6101c0 + (i * 0x800), tmp);\n\t}\n\n\t \n\tfor (i = 0; i < disp->sor.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));\n\t\tnvkm_wr32(device, 0x6301c4 + (i * 0x800), tmp);\n\t}\n\n\t \n\tif (nvkm_rd32(device, 0x6100ac) & 0x00000100) {\n\t\tnvkm_wr32(device, 0x6100ac, 0x00000100);\n\t\tnvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tnvkm_wr32(device, 0x610010, (disp->inst->addr >> 8) | 9);\n\n\t \n\tnvkm_wr32(device, 0x610090, 0x00000000);\n\tnvkm_wr32(device, 0x6100a0, 0x00000000);\n\tnvkm_wr32(device, 0x6100b0, 0x00000307);\n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst u32 hoff = head->id * 0x800;\n\t\tnvkm_mask(device, 0x616308 + hoff, 0x00000111, 0x00000010);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_disp_func\ngf119_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = gf119_disp_init,\n\t.fini = gf119_disp_fini,\n\t.intr = gf119_disp_intr,\n\t.intr_error = gf119_disp_intr_error,\n\t.super = gf119_disp_super,\n\t.uevent = &gf119_disp_chan_uevent,\n\t.head = { .cnt = gf119_head_cnt, .new = gf119_head_new },\n\t.dac = { .cnt = gf119_dac_cnt, .new = gf119_dac_new },\n\t.sor = { .cnt = gf119_sor_cnt, .new = gf119_sor_new },\n\t.root = { 0,0,GF110_DISP },\n\t.user = {\n\t\t{{0,0,GF110_DISP_CURSOR             }, nvkm_disp_chan_new, &gf119_disp_curs },\n\t\t{{0,0,GF110_DISP_OVERLAY            }, nvkm_disp_chan_new, &gf119_disp_oimm },\n\t\t{{0,0,GF110_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, &gf119_disp_base },\n\t\t{{0,0,GF110_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, &gf119_disp_core },\n\t\t{{0,0,GF110_DISP_OVERLAY_CONTROL_DMA}, nvkm_disp_chan_new, &gf119_disp_ovly },\n\t\t{}\n\t},\n};\n\nint\ngf119_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&gf119_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}