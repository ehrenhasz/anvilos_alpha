{
  "module_name": "nv50.c",
  "hash_id": "783f9d2a611c2d6e0628755dc169b13699faceef7b7da3643380cc67d5084bbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv50.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <core/gpuobj.h>\n#include <engine/disp.h>\n#include <engine/fifo/chan.h>\n#include <subdev/bar.h>\n\n#include <nvif/class.h>\n#include <nvif/event.h>\n\n \n\nstatic int\nnv50_sw_chan_vblsem_release(struct nvkm_event_ntfy *notify, u32 bits)\n{\n\tstruct nv50_sw_chan *chan =\n\t\tcontainer_of(notify, typeof(*chan), vblank.notify[notify->id]);\n\tstruct nvkm_sw *sw = chan->base.sw;\n\tstruct nvkm_device *device = sw->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x001704, chan->base.fifo->inst->addr >> 12);\n\tnvkm_wr32(device, 0x001710, 0x80000000 | chan->vblank.ctxdma);\n\tnvkm_bar_flush(device->bar);\n\n\tif (device->chipset == 0x50) {\n\t\tnvkm_wr32(device, 0x001570, chan->vblank.offset);\n\t\tnvkm_wr32(device, 0x001574, chan->vblank.value);\n\t} else {\n\t\tnvkm_wr32(device, 0x060010, chan->vblank.offset);\n\t\tnvkm_wr32(device, 0x060014, chan->vblank.value);\n\t}\n\n\treturn NVKM_EVENT_DROP;\n}\n\nstatic bool\nnv50_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)\n{\n\tstruct nv50_sw_chan *chan = nv50_sw_chan(base);\n\tstruct nvkm_engine *engine = chan->base.object.engine;\n\tstruct nvkm_device *device = engine->subdev.device;\n\tswitch (mthd) {\n\tcase 0x018c: chan->vblank.ctxdma = data; return true;\n\tcase 0x0400: chan->vblank.offset = data; return true;\n\tcase 0x0404: chan->vblank.value  = data; return true;\n\tcase 0x0408:\n\t\tif (data < device->disp->vblank.index_nr) {\n\t\t\tnvkm_event_ntfy_allow(&chan->vblank.notify[data]);\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nvoid *\nnv50_sw_chan_dtor(struct nvkm_sw_chan *base)\n{\n\tstruct nv50_sw_chan *chan = nv50_sw_chan(base);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(chan->vblank.notify); i++)\n\t\tnvkm_event_ntfy_del(&chan->vblank.notify[i]);\n\n\treturn chan;\n}\n\nstatic const struct nvkm_sw_chan_func\nnv50_sw_chan = {\n\t.dtor = nv50_sw_chan_dtor,\n\t.mthd = nv50_sw_chan_mthd,\n};\n\nstatic int\nnv50_sw_chan_new(struct nvkm_sw *sw, struct nvkm_chan *fifoch,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = sw->engine.subdev.device->disp;\n\tstruct nv50_sw_chan *chan;\n\tint ret, i;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &chan->base.object;\n\n\tret = nvkm_sw_chan_ctor(&nv50_sw_chan, sw, fifoch, oclass, &chan->base);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; disp && i < disp->vblank.index_nr; i++) {\n\t\tnvkm_event_ntfy_add(&disp->vblank, i, NVKM_DISP_HEAD_EVENT_VBLANK, true,\n\t\t\t\t    nv50_sw_chan_vblsem_release, &chan->vblank.notify[i]);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct nvkm_sw_func\nnv50_sw = {\n\t.chan_new = nv50_sw_chan_new,\n\t.sclass = {\n\t\t{ nvkm_nvsw_new, { -1, -1, NVIF_CLASS_SW_NV50 } },\n\t\t{}\n\t}\n};\n\nint\nnv50_sw_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_sw **psw)\n{\n\treturn nvkm_sw_new_(&nv50_sw, device, type, inst, psw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}