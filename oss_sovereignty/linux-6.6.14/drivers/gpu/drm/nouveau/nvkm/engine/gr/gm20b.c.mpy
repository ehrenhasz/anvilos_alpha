{
  "module_name": "gm20b.c",
  "hash_id": "51b2bdb1e8d0d13942c76c339e4c0d06cfb8a82718aefd8ef146156c8d671315",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/gm20b.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ctxgf100.h\"\n\n#include <core/firmware.h>\n#include <subdev/acr.h>\n#include <subdev/timer.h>\n\n#include <nvfw/flcn.h>\n\n#include <nvif/class.h>\n\nvoid\ngm20b_gr_acr_bld_patch(struct nvkm_acr *acr, u32 bld, s64 adjust)\n{\n\tstruct flcn_bl_dmem_desc hdr;\n\tu64 addr;\n\n\tnvkm_robj(acr->wpr, bld, &hdr, sizeof(hdr));\n\taddr = ((u64)hdr.code_dma_base1 << 40 | hdr.code_dma_base << 8);\n\thdr.code_dma_base  = lower_32_bits((addr + adjust) >> 8);\n\thdr.code_dma_base1 = upper_32_bits((addr + adjust) >> 8);\n\taddr = ((u64)hdr.data_dma_base1 << 40 | hdr.data_dma_base << 8);\n\thdr.data_dma_base  = lower_32_bits((addr + adjust) >> 8);\n\thdr.data_dma_base1 = upper_32_bits((addr + adjust) >> 8);\n\tnvkm_wobj(acr->wpr, bld, &hdr, sizeof(hdr));\n\n\tflcn_bl_dmem_desc_dump(&acr->subdev, &hdr);\n}\n\nvoid\ngm20b_gr_acr_bld_write(struct nvkm_acr *acr, u32 bld,\n\t\t       struct nvkm_acr_lsfw *lsfw)\n{\n\tconst u64 base = lsfw->offset.img + lsfw->app_start_offset;\n\tconst u64 code = (base + lsfw->app_resident_code_offset) >> 8;\n\tconst u64 data = (base + lsfw->app_resident_data_offset) >> 8;\n\tconst struct flcn_bl_dmem_desc hdr = {\n\t\t.ctx_dma = FALCON_DMAIDX_UCODE,\n\t\t.code_dma_base = lower_32_bits(code),\n\t\t.non_sec_code_off = lsfw->app_resident_code_offset,\n\t\t.non_sec_code_size = lsfw->app_resident_code_size,\n\t\t.code_entry_point = lsfw->app_imem_entry,\n\t\t.data_dma_base = lower_32_bits(data),\n\t\t.data_size = lsfw->app_resident_data_size,\n\t\t.code_dma_base1 = upper_32_bits(code),\n\t\t.data_dma_base1 = upper_32_bits(data),\n\t};\n\n\tnvkm_wobj(acr->wpr, bld, &hdr, sizeof(hdr));\n}\n\nconst struct nvkm_acr_lsf_func\ngm20b_gr_fecs_acr = {\n\t.bld_size = sizeof(struct flcn_bl_dmem_desc),\n\t.bld_write = gm20b_gr_acr_bld_write,\n\t.bld_patch = gm20b_gr_acr_bld_patch,\n};\n\nstatic void\ngm20b_gr_init_gpc_mmu(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 val;\n\n\t \n\tif (!device->acr) {\n\t\tnvkm_wr32(device, 0x100ce4, 0xffffffff);\n\n\t\tif (nvkm_rd32(device, 0x100ce4) != 0xffffffff)\n\t\t\tnvdev_warn(device,\n\t\t\t  \"cannot bypass secure boot - expect failure soon!\\n\");\n\t}\n\n\tval = nvkm_rd32(device, 0x100c80);\n\tval &= 0xf000187f;\n\tnvkm_wr32(device, 0x418880, val);\n\tnvkm_wr32(device, 0x418890, 0);\n\tnvkm_wr32(device, 0x418894, 0);\n\n\tnvkm_wr32(device, 0x4188b0, nvkm_rd32(device, 0x100cc4));\n\tnvkm_wr32(device, 0x4188b4, nvkm_rd32(device, 0x100cc8));\n\tnvkm_wr32(device, 0x4188b8, nvkm_rd32(device, 0x100ccc));\n\n\tnvkm_wr32(device, 0x4188ac, nvkm_rd32(device, 0x100800));\n}\n\nstatic void\ngm20b_gr_set_hww_esr_report_mask(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, 0x419e44, 0xdffffe);\n\tnvkm_wr32(device, 0x419e4c, 0x5);\n}\n\nstatic const struct gf100_gr_func\ngm20b_gr = {\n\t.oneinit_tiles = gm200_gr_oneinit_tiles,\n\t.oneinit_sm_id = gm200_gr_oneinit_sm_id,\n\t.init = gk20a_gr_init,\n\t.init_zcull = gf117_gr_init_zcull,\n\t.init_gpc_mmu = gm20b_gr_init_gpc_mmu,\n\t.init_rop_active_fbps = gk104_gr_init_rop_active_fbps,\n\t.trap_mp = gf100_gr_trap_mp,\n\t.set_hww_esr_report_mask = gm20b_gr_set_hww_esr_report_mask,\n\t.fecs.reset = gf100_gr_fecs_reset,\n\t.rops = gm200_gr_rops,\n\t.ppc_nr = 1,\n\t.grctx = &gm20b_grctx,\n\t.zbc = &gf100_gr_zbc,\n\t.sclass = {\n\t\t{ -1, -1, FERMI_TWOD_A },\n\t\t{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },\n\t\t{ -1, -1, MAXWELL_B, &gf100_fermi },\n\t\t{ -1, -1, MAXWELL_COMPUTE_B },\n\t\t{}\n\t}\n};\n\nstatic int\ngm20b_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tint ret;\n\n\tret = nvkm_acr_lsfw_load_bl_inst_data_sig(subdev, &gr->fecs.falcon,\n\t\t\t\t\t\t  NVKM_ACR_LSF_FECS,\n\t\t\t\t\t\t  \"gr/fecs_\", ver, fwif->fecs);\n\tif (ret)\n\t\treturn ret;\n\n\n\tif (nvkm_firmware_load_blob(subdev, \"gr/\", \"gpccs_inst\", ver,\n\t\t\t\t    &gr->gpccs.inst) ||\n\t    nvkm_firmware_load_blob(subdev, \"gr/\", \"gpccs_data\", ver,\n\t\t\t\t    &gr->gpccs.data))\n\t\treturn -ENOENT;\n\n\tgr->firmware = true;\n\n\treturn gk20a_gr_load_sw(gr, \"gr/\", ver);\n}\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/fecs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/fecs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/gpccs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/gpccs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/sw_ctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/sw_nonctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/sw_bundle_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/gr/sw_method_init.bin\");\n#endif\n\nstatic const struct gf100_gr_fwif\ngm20b_gr_fwif[] = {\n\t{  0, gm20b_gr_load, &gm20b_gr, &gm20b_gr_fecs_acr },\n\t{ -1, gm200_gr_nofw },\n\t{}\n};\n\nint\ngm20b_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn gf100_gr_new_(gm20b_gr_fwif, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}