{
  "module_name": "ctrl.c",
  "hash_id": "329c9d562b194634f64314d6e6d332bacdc89ad7031b839616c0c6dca0951970",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/device/ctrl.c",
  "human_readable_source": " \n#include \"ctrl.h\"\n\n#include <core/client.h>\n#include <subdev/clk.h>\n\n#include <nvif/class.h>\n#include <nvif/if0001.h>\n#include <nvif/ioctl.h>\n#include <nvif/unpack.h>\n\nstatic int\nnvkm_control_mthd_pstate_info(struct nvkm_control *ctrl, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_control_pstate_info_v0 v0;\n\t} *args = data;\n\tstruct nvkm_clk *clk = ctrl->device->clk;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(&ctrl->object, \"control pstate info size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(&ctrl->object, \"control pstate info vers %d\\n\",\n\t\t\t   args->v0.version);\n\t} else\n\t\treturn ret;\n\n\tif (clk) {\n\t\targs->v0.count = clk->state_nr;\n\t\targs->v0.ustate_ac = clk->ustate_ac;\n\t\targs->v0.ustate_dc = clk->ustate_dc;\n\t\targs->v0.pwrsrc = clk->pwrsrc;\n\t\targs->v0.pstate = clk->pstate;\n\t} else {\n\t\targs->v0.count = 0;\n\t\targs->v0.ustate_ac = NVIF_CONTROL_PSTATE_INFO_V0_USTATE_DISABLE;\n\t\targs->v0.ustate_dc = NVIF_CONTROL_PSTATE_INFO_V0_USTATE_DISABLE;\n\t\targs->v0.pwrsrc = -ENODEV;\n\t\targs->v0.pstate = NVIF_CONTROL_PSTATE_INFO_V0_PSTATE_UNKNOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_control_mthd_pstate_attr(struct nvkm_control *ctrl, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_control_pstate_attr_v0 v0;\n\t} *args = data;\n\tstruct nvkm_clk *clk = ctrl->device->clk;\n\tconst struct nvkm_domain *domain;\n\tstruct nvkm_pstate *pstate;\n\tstruct nvkm_cstate *cstate;\n\tint i = 0, j = -1;\n\tu32 lo, hi;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(&ctrl->object, \"control pstate attr size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(&ctrl->object,\n\t\t\t   \"control pstate attr vers %d state %d index %d\\n\",\n\t\t\t   args->v0.version, args->v0.state, args->v0.index);\n\t\tif (!clk)\n\t\t\treturn -ENODEV;\n\t\tif (args->v0.state < NVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT)\n\t\t\treturn -EINVAL;\n\t\tif (args->v0.state >= clk->state_nr)\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn ret;\n\tdomain = clk->domains;\n\n\twhile (domain->name != nv_clk_src_max) {\n\t\tif (domain->mname && ++j == args->v0.index)\n\t\t\tbreak;\n\t\tdomain++;\n\t}\n\n\tif (domain->name == nv_clk_src_max)\n\t\treturn -EINVAL;\n\n\tif (args->v0.state != NVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT) {\n\t\tlist_for_each_entry(pstate, &clk->states, head) {\n\t\t\tif (i++ == args->v0.state)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlo = pstate->base.domain[domain->name];\n\t\thi = lo;\n\t\tlist_for_each_entry(cstate, &pstate->list, head) {\n\t\t\tlo = min(lo, cstate->domain[domain->name]);\n\t\t\thi = max(hi, cstate->domain[domain->name]);\n\t\t}\n\n\t\targs->v0.state = pstate->pstate;\n\t} else {\n\t\tlo = max(nvkm_clk_read(clk, domain->name), 0);\n\t\thi = lo;\n\t}\n\n\tsnprintf(args->v0.name, sizeof(args->v0.name), \"%s\", domain->mname);\n\tsnprintf(args->v0.unit, sizeof(args->v0.unit), \"MHz\");\n\targs->v0.min = lo / domain->mdiv;\n\targs->v0.max = hi / domain->mdiv;\n\n\targs->v0.index = 0;\n\twhile ((++domain)->name != nv_clk_src_max) {\n\t\tif (domain->mname) {\n\t\t\targs->v0.index = ++j;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_control_mthd_pstate_user(struct nvkm_control *ctrl, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_control_pstate_user_v0 v0;\n\t} *args = data;\n\tstruct nvkm_clk *clk = ctrl->device->clk;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(&ctrl->object, \"control pstate user size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(&ctrl->object,\n\t\t\t   \"control pstate user vers %d ustate %d pwrsrc %d\\n\",\n\t\t\t   args->v0.version, args->v0.ustate, args->v0.pwrsrc);\n\t\tif (!clk)\n\t\t\treturn -ENODEV;\n\t} else\n\t\treturn ret;\n\n\tif (args->v0.pwrsrc >= 0) {\n\t\tret |= nvkm_clk_ustate(clk, args->v0.ustate, args->v0.pwrsrc);\n\t} else {\n\t\tret |= nvkm_clk_ustate(clk, args->v0.ustate, 0);\n\t\tret |= nvkm_clk_ustate(clk, args->v0.ustate, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_control_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tstruct nvkm_control *ctrl = nvkm_control(object);\n\tswitch (mthd) {\n\tcase NVIF_CONTROL_PSTATE_INFO:\n\t\treturn nvkm_control_mthd_pstate_info(ctrl, data, size);\n\tcase NVIF_CONTROL_PSTATE_ATTR:\n\t\treturn nvkm_control_mthd_pstate_attr(ctrl, data, size);\n\tcase NVIF_CONTROL_PSTATE_USER:\n\t\treturn nvkm_control_mthd_pstate_user(ctrl, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct nvkm_object_func\nnvkm_control = {\n\t.mthd = nvkm_control_mthd,\n};\n\nstatic int\nnvkm_control_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,\n\t\t void *data, u32 size, struct nvkm_object **pobject)\n{\n\tstruct nvkm_control *ctrl;\n\n\tif (!(ctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &ctrl->object;\n\tctrl->device = device;\n\n\tnvkm_object_ctor(&nvkm_control, oclass, &ctrl->object);\n\treturn 0;\n}\n\nconst struct nvkm_device_oclass\nnvkm_control_oclass = {\n\t.base.oclass = NVIF_CLASS_CONTROL,\n\t.base.minver = -1,\n\t.base.maxver = -1,\n\t.ctor = nvkm_control_new,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}