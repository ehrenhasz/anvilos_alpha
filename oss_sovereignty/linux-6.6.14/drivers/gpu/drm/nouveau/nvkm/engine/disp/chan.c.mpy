{
  "module_name": "chan.c",
  "hash_id": "ef221884d91364ffc64f7202e5ff09a1e4fbc518b9eacb2ed935ded2a061a143",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/chan.c",
  "human_readable_source": " \n#include \"chan.h\"\n\n#include <core/oproxy.h>\n#include <core/ramht.h>\n\n#include <nvif/if0014.h>\n\nstatic int\nnvkm_disp_chan_rd32(struct nvkm_object *object, u64 addr, u32 *data)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tu64 size, base = chan->func->user(chan, &size);\n\n\t*data = nvkm_rd32(device, base + addr);\n\treturn 0;\n}\n\nstatic int\nnvkm_disp_chan_wr32(struct nvkm_object *object, u64 addr, u32 data)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tu64 size, base = chan->func->user(chan, &size);\n\n\tnvkm_wr32(device, base + addr, data);\n\treturn 0;\n}\n\nstatic int\nnvkm_disp_chan_ntfy(struct nvkm_object *object, u32 type, struct nvkm_event **pevent)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\tstruct nvkm_disp *disp = chan->disp;\n\n\tswitch (type) {\n\tcase 0:\n\t\t*pevent = &disp->uevent;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_disp_chan_map(struct nvkm_object *object, void *argv, u32 argc,\n\t\t   enum nvkm_object_map *type, u64 *addr, u64 *size)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u64 base = device->func->resource_addr(device, 0);\n\n\t*type = NVKM_OBJECT_MAP_IO;\n\t*addr = base + chan->func->user(chan, size);\n\treturn 0;\n}\n\nstruct nvkm_disp_chan_object {\n\tstruct nvkm_oproxy oproxy;\n\tstruct nvkm_disp *disp;\n\tint hash;\n};\n\nstatic void\nnvkm_disp_chan_child_del_(struct nvkm_oproxy *base)\n{\n\tstruct nvkm_disp_chan_object *object = container_of(base, typeof(*object), oproxy);\n\n\tnvkm_ramht_remove(object->disp->ramht, object->hash);\n}\n\nstatic const struct nvkm_oproxy_func\nnvkm_disp_chan_child_func_ = {\n\t.dtor[0] = nvkm_disp_chan_child_del_,\n};\n\nstatic int\nnvkm_disp_chan_child_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t\t struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(oclass->parent);\n\tstruct nvkm_disp *disp = chan->disp;\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tconst struct nvkm_device_oclass *sclass = oclass->priv;\n\tstruct nvkm_disp_chan_object *object;\n\tint ret;\n\n\tif (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_oproxy_ctor(&nvkm_disp_chan_child_func_, oclass, &object->oproxy);\n\tobject->disp = disp;\n\t*pobject = &object->oproxy.base;\n\n\tret = sclass->ctor(device, oclass, argv, argc, &object->oproxy.object);\n\tif (ret)\n\t\treturn ret;\n\n\tobject->hash = chan->func->bind(chan, object->oproxy.object, oclass->handle);\n\tif (object->hash < 0)\n\t\treturn object->hash;\n\n\treturn 0;\n}\n\nstatic int\nnvkm_disp_chan_child_get(struct nvkm_object *object, int index, struct nvkm_oclass *sclass)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst struct nvkm_device_oclass *oclass = NULL;\n\n\tif (chan->func->bind)\n\t\tsclass->engine = nvkm_device_engine(device, NVKM_ENGINE_DMAOBJ, 0);\n\telse\n\t\tsclass->engine = NULL;\n\n\tif (sclass->engine && sclass->engine->func->base.sclass) {\n\t\tsclass->engine->func->base.sclass(sclass, index, &oclass);\n\t\tif (oclass) {\n\t\t\tsclass->ctor = nvkm_disp_chan_child_new;\n\t\t\tsclass->priv = oclass;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_disp_chan_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\n\tchan->func->fini(chan);\n\tchan->func->intr(chan, false);\n\treturn 0;\n}\n\nstatic int\nnvkm_disp_chan_init(struct nvkm_object *object)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\n\tchan->func->intr(chan, true);\n\treturn chan->func->init(chan);\n}\n\nstatic void *\nnvkm_disp_chan_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_disp_chan *chan = nvkm_disp_chan(object);\n\tstruct nvkm_disp *disp = chan->disp;\n\n\tspin_lock(&disp->client.lock);\n\tif (disp->chan[chan->chid.user] == chan)\n\t\tdisp->chan[chan->chid.user] = NULL;\n\tspin_unlock(&disp->client.lock);\n\n\tnvkm_memory_unref(&chan->memory);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\nnvkm_disp_chan = {\n\t.dtor = nvkm_disp_chan_dtor,\n\t.init = nvkm_disp_chan_init,\n\t.fini = nvkm_disp_chan_fini,\n\t.rd32 = nvkm_disp_chan_rd32,\n\t.wr32 = nvkm_disp_chan_wr32,\n\t.ntfy = nvkm_disp_chan_ntfy,\n\t.map = nvkm_disp_chan_map,\n\t.sclass = nvkm_disp_chan_child_get,\n};\n\nstatic int\nnvkm_disp_chan_new_(struct nvkm_disp *disp, int nr, const struct nvkm_oclass *oclass,\n\t\t    void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tconst struct nvkm_disp_chan_user *user = NULL;\n\tstruct nvkm_disp_chan *chan;\n\tunion nvif_disp_chan_args *args = argv;\n\tint ret, i;\n\n\tfor (i = 0; disp->func->user[i].ctor; i++) {\n\t\tif (disp->func->user[i].base.oclass == oclass->base.oclass) {\n\t\t\tuser = disp->func->user[i].chan;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(!user))\n\t\treturn -EINVAL;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\tif (args->v0.id >= nr || !args->v0.pushbuf != !user->func->push)\n\t\treturn -EINVAL;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &chan->object;\n\n\tnvkm_object_ctor(&nvkm_disp_chan, oclass, &chan->object);\n\tchan->func = user->func;\n\tchan->mthd = user->mthd;\n\tchan->disp = disp;\n\tchan->chid.ctrl = user->ctrl + args->v0.id;\n\tchan->chid.user = user->user + args->v0.id;\n\tchan->head = args->v0.id;\n\n\tif (chan->func->push) {\n\t\tret = chan->func->push(chan, args->v0.pushbuf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock(&disp->client.lock);\n\tif (disp->chan[chan->chid.user]) {\n\t\tspin_unlock(&disp->client.lock);\n\t\treturn -EBUSY;\n\t}\n\tdisp->chan[chan->chid.user] = chan;\n\tspin_unlock(&disp->client.lock);\n\treturn 0;\n}\n\nint\nnvkm_disp_wndw_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t   struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(oclass->parent);\n\n\treturn nvkm_disp_chan_new_(disp, disp->wndw.nr, oclass, argv, argc, pobject);\n}\n\nint\nnvkm_disp_chan_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t   struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(oclass->parent);\n\n\treturn nvkm_disp_chan_new_(disp, disp->head.nr, oclass, argv, argc, pobject);\n}\n\nint\nnvkm_disp_core_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t   struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(oclass->parent);\n\n\treturn nvkm_disp_chan_new_(disp, 1, oclass, argv, argc, pobject);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}