{
  "module_name": "base.c",
  "hash_id": "57c0a65f455b3c282fd01f9f0ef7ea2256ecec1e4d01b3cdcb45b1dbbd2a9203",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/pm/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/client.h>\n#include <core/option.h>\n\n#include <nvif/class.h>\n#include <nvif/if0002.h>\n#include <nvif/if0003.h>\n#include <nvif/ioctl.h>\n#include <nvif/unpack.h>\n\nstatic u8\nnvkm_pm_count_perfdom(struct nvkm_pm *pm)\n{\n\tstruct nvkm_perfdom *dom;\n\tu8 domain_nr = 0;\n\n\tlist_for_each_entry(dom, &pm->domains, head)\n\t\tdomain_nr++;\n\treturn domain_nr;\n}\n\nstatic u16\nnvkm_perfdom_count_perfsig(struct nvkm_perfdom *dom)\n{\n\tu16 signal_nr = 0;\n\tint i;\n\n\tif (dom) {\n\t\tfor (i = 0; i < dom->signal_nr; i++) {\n\t\t\tif (dom->signal[i].name)\n\t\t\t\tsignal_nr++;\n\t\t}\n\t}\n\treturn signal_nr;\n}\n\nstatic struct nvkm_perfdom *\nnvkm_perfdom_find(struct nvkm_pm *pm, int di)\n{\n\tstruct nvkm_perfdom *dom;\n\tint tmp = 0;\n\n\tlist_for_each_entry(dom, &pm->domains, head) {\n\t\tif (tmp++ == di)\n\t\t\treturn dom;\n\t}\n\treturn NULL;\n}\n\nstatic struct nvkm_perfsig *\nnvkm_perfsig_find(struct nvkm_pm *pm, u8 di, u8 si, struct nvkm_perfdom **pdom)\n{\n\tstruct nvkm_perfdom *dom = *pdom;\n\n\tif (dom == NULL) {\n\t\tdom = nvkm_perfdom_find(pm, di);\n\t\tif (dom == NULL)\n\t\t\treturn NULL;\n\t\t*pdom = dom;\n\t}\n\n\tif (!dom->signal[si].name)\n\t\treturn NULL;\n\treturn &dom->signal[si];\n}\n\nstatic u8\nnvkm_perfsig_count_perfsrc(struct nvkm_perfsig *sig)\n{\n\tu8 source_nr = 0, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sig->source); i++) {\n\t\tif (sig->source[i])\n\t\t\tsource_nr++;\n\t}\n\treturn source_nr;\n}\n\nstatic struct nvkm_perfsrc *\nnvkm_perfsrc_find(struct nvkm_pm *pm, struct nvkm_perfsig *sig, int si)\n{\n\tstruct nvkm_perfsrc *src;\n\tbool found = false;\n\tint tmp = 1;  \n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sig->source) && sig->source[i]; i++) {\n\t\tif (sig->source[i] == si) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tlist_for_each_entry(src, &pm->sources, head) {\n\t\t\tif (tmp++ == si)\n\t\t\t\treturn src;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int\nnvkm_perfsrc_enable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)\n{\n\tstruct nvkm_subdev *subdev = &pm->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_perfdom *dom = NULL;\n\tstruct nvkm_perfsig *sig;\n\tstruct nvkm_perfsrc *src;\n\tu32 mask, value;\n\tint i, j;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < 8 && ctr->source[i][j]; j++) {\n\t\t\tsig = nvkm_perfsig_find(pm, ctr->domain,\n\t\t\t\t\t\tctr->signal[i], &dom);\n\t\t\tif (!sig)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsrc = nvkm_perfsrc_find(pm, sig, ctr->source[i][j]);\n\t\t\tif (!src)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tmask = value = 0x00000000;\n\t\t\tif (src->enable)\n\t\t\t\tmask = value = 0x80000000;\n\t\t\tmask  |= (src->mask << src->shift);\n\t\t\tvalue |= ((ctr->source[i][j] >> 32) << src->shift);\n\n\t\t\t \n\t\t\tnvkm_mask(device, src->addr, mask, value);\n\t\t\tnvkm_debug(subdev,\n\t\t\t\t   \"enabled source %08x %08x %08x\\n\",\n\t\t\t\t   src->addr, mask, value);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nnvkm_perfsrc_disable(struct nvkm_pm *pm, struct nvkm_perfctr *ctr)\n{\n\tstruct nvkm_subdev *subdev = &pm->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_perfdom *dom = NULL;\n\tstruct nvkm_perfsig *sig;\n\tstruct nvkm_perfsrc *src;\n\tu32 mask;\n\tint i, j;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < 8 && ctr->source[i][j]; j++) {\n\t\t\tsig = nvkm_perfsig_find(pm, ctr->domain,\n\t\t\t\t\t\tctr->signal[i], &dom);\n\t\t\tif (!sig)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsrc = nvkm_perfsrc_find(pm, sig, ctr->source[i][j]);\n\t\t\tif (!src)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tmask = 0x00000000;\n\t\t\tif (src->enable)\n\t\t\t\tmask = 0x80000000;\n\t\t\tmask |= (src->mask << src->shift);\n\n\t\t\t \n\t\t\tnvkm_mask(device, src->addr, mask, 0);\n\t\t\tnvkm_debug(subdev, \"disabled source %08x %08x\\n\",\n\t\t\t\t   src->addr, mask);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int\nnvkm_perfdom_init(struct nvkm_perfdom *dom, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_perfdom_init none;\n\t} *args = data;\n\tstruct nvkm_object *object = &dom->object;\n\tstruct nvkm_pm *pm = dom->perfmon->pm;\n\tint ret = -ENOSYS, i;\n\n\tnvif_ioctl(object, \"perfdom init size %d\\n\", size);\n\tif (!(ret = nvif_unvers(ret, &data, &size, args->none))) {\n\t\tnvif_ioctl(object, \"perfdom init\\n\");\n\t} else\n\t\treturn ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (dom->ctr[i]) {\n\t\t\tdom->func->init(pm, dom, dom->ctr[i]);\n\n\t\t\t \n\t\t\tnvkm_perfsrc_enable(pm, dom->ctr[i]);\n\t\t}\n\t}\n\n\t \n\tdom->func->next(pm, dom);\n\treturn 0;\n}\n\nstatic int\nnvkm_perfdom_sample(struct nvkm_perfdom *dom, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_perfdom_sample none;\n\t} *args = data;\n\tstruct nvkm_object *object = &dom->object;\n\tstruct nvkm_pm *pm = dom->perfmon->pm;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"perfdom sample size %d\\n\", size);\n\tif (!(ret = nvif_unvers(ret, &data, &size, args->none))) {\n\t\tnvif_ioctl(object, \"perfdom sample\\n\");\n\t} else\n\t\treturn ret;\n\tpm->sequence++;\n\n\t \n\tlist_for_each_entry(dom, &pm->domains, head)\n\t\tdom->func->next(pm, dom);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_perfdom_read(struct nvkm_perfdom *dom, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_perfdom_read_v0 v0;\n\t} *args = data;\n\tstruct nvkm_object *object = &dom->object;\n\tstruct nvkm_pm *pm = dom->perfmon->pm;\n\tint ret = -ENOSYS, i;\n\n\tnvif_ioctl(object, \"perfdom read size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object, \"perfdom read vers %d\\n\", args->v0.version);\n\t} else\n\t\treturn ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (dom->ctr[i])\n\t\t\tdom->func->read(pm, dom, dom->ctr[i]);\n\t}\n\n\tif (!dom->clk)\n\t\treturn -EAGAIN;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (dom->ctr[i])\n\t\t\targs->v0.ctr[i] = dom->ctr[i]->ctr;\n\targs->v0.clk = dom->clk;\n\treturn 0;\n}\n\nstatic int\nnvkm_perfdom_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tstruct nvkm_perfdom *dom = nvkm_perfdom(object);\n\tswitch (mthd) {\n\tcase NVIF_PERFDOM_V0_INIT:\n\t\treturn nvkm_perfdom_init(dom, data, size);\n\tcase NVIF_PERFDOM_V0_SAMPLE:\n\t\treturn nvkm_perfdom_sample(dom, data, size);\n\tcase NVIF_PERFDOM_V0_READ:\n\t\treturn nvkm_perfdom_read(dom, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void *\nnvkm_perfdom_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_perfdom *dom = nvkm_perfdom(object);\n\tstruct nvkm_pm *pm = dom->perfmon->pm;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct nvkm_perfctr *ctr = dom->ctr[i];\n\t\tif (ctr) {\n\t\t\tnvkm_perfsrc_disable(pm, ctr);\n\t\t\tif (ctr->head.next)\n\t\t\t\tlist_del(&ctr->head);\n\t\t}\n\t\tkfree(ctr);\n\t}\n\n\treturn dom;\n}\n\nstatic int\nnvkm_perfctr_new(struct nvkm_perfdom *dom, int slot, u8 domain,\n\t\t struct nvkm_perfsig *signal[4], u64 source[4][8],\n\t\t u16 logic_op, struct nvkm_perfctr **pctr)\n{\n\tstruct nvkm_perfctr *ctr;\n\tint i, j;\n\n\tif (!dom)\n\t\treturn -EINVAL;\n\n\tctr = *pctr = kzalloc(sizeof(*ctr), GFP_KERNEL);\n\tif (!ctr)\n\t\treturn -ENOMEM;\n\n\tctr->domain   = domain;\n\tctr->logic_op = logic_op;\n\tctr->slot     = slot;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (signal[i]) {\n\t\t\tctr->signal[i] = signal[i] - dom->signal;\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tctr->source[i][j] = source[i][j];\n\t\t}\n\t}\n\tlist_add_tail(&ctr->head, &dom->list);\n\n\treturn 0;\n}\n\nstatic const struct nvkm_object_func\nnvkm_perfdom = {\n\t.dtor = nvkm_perfdom_dtor,\n\t.mthd = nvkm_perfdom_mthd,\n};\n\nstatic int\nnvkm_perfdom_new_(struct nvkm_perfmon *perfmon,\n\t\t  const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\t  struct nvkm_object **pobject)\n{\n\tunion {\n\t\tstruct nvif_perfdom_v0 v0;\n\t} *args = data;\n\tstruct nvkm_pm *pm = perfmon->pm;\n\tstruct nvkm_object *parent = oclass->parent;\n\tstruct nvkm_perfdom *sdom = NULL;\n\tstruct nvkm_perfctr *ctr[4] = {};\n\tstruct nvkm_perfdom *dom;\n\tint c, s, m;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(parent, \"create perfdom size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(parent, \"create perfdom vers %d dom %d mode %02x\\n\",\n\t\t\t   args->v0.version, args->v0.domain, args->v0.mode);\n\t} else\n\t\treturn ret;\n\n\tfor (c = 0; c < ARRAY_SIZE(args->v0.ctr); c++) {\n\t\tstruct nvkm_perfsig *sig[4] = {};\n\t\tu64 src[4][8] = {};\n\n\t\tfor (s = 0; s < ARRAY_SIZE(args->v0.ctr[c].signal); s++) {\n\t\t\tsig[s] = nvkm_perfsig_find(pm, args->v0.domain,\n\t\t\t\t\t\t   args->v0.ctr[c].signal[s],\n\t\t\t\t\t\t   &sdom);\n\t\t\tif (args->v0.ctr[c].signal[s] && !sig[s])\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (m = 0; m < 8; m++) {\n\t\t\t\tsrc[s][m] = args->v0.ctr[c].source[s][m];\n\t\t\t\tif (src[s][m] && !nvkm_perfsrc_find(pm, sig[s],\n\t\t\t\t\t\t\t            src[s][m]))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tret = nvkm_perfctr_new(sdom, c, args->v0.domain, sig, src,\n\t\t\t\t       args->v0.ctr[c].logic_op, &ctr[c]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!sdom)\n\t\treturn -EINVAL;\n\n\tif (!(dom = kzalloc(sizeof(*dom), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nvkm_perfdom, oclass, &dom->object);\n\tdom->perfmon = perfmon;\n\t*pobject = &dom->object;\n\n\tdom->func = sdom->func;\n\tdom->addr = sdom->addr;\n\tdom->mode = args->v0.mode;\n\tfor (c = 0; c < ARRAY_SIZE(ctr); c++)\n\t\tdom->ctr[c] = ctr[c];\n\treturn 0;\n}\n\n \nstatic int\nnvkm_perfmon_mthd_query_domain(struct nvkm_perfmon *perfmon,\n\t\t\t       void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_perfmon_query_domain_v0 v0;\n\t} *args = data;\n\tstruct nvkm_object *object = &perfmon->object;\n\tstruct nvkm_pm *pm = perfmon->pm;\n\tstruct nvkm_perfdom *dom;\n\tu8 domain_nr;\n\tint di, ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"perfmon query domain size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object, \"perfmon domain vers %d iter %02x\\n\",\n\t\t\t   args->v0.version, args->v0.iter);\n\t\tdi = (args->v0.iter & 0xff) - 1;\n\t} else\n\t\treturn ret;\n\n\tdomain_nr = nvkm_pm_count_perfdom(pm);\n\tif (di >= (int)domain_nr)\n\t\treturn -EINVAL;\n\n\tif (di >= 0) {\n\t\tdom = nvkm_perfdom_find(pm, di);\n\t\tif (dom == NULL)\n\t\t\treturn -EINVAL;\n\n\t\targs->v0.id         = di;\n\t\targs->v0.signal_nr  = nvkm_perfdom_count_perfsig(dom);\n\t\tstrncpy(args->v0.name, dom->name, sizeof(args->v0.name) - 1);\n\n\t\t \n\t\targs->v0.counter_nr = 4;\n\t}\n\n\tif (++di < domain_nr) {\n\t\targs->v0.iter = ++di;\n\t\treturn 0;\n\t}\n\n\targs->v0.iter = 0xff;\n\treturn 0;\n}\n\nstatic int\nnvkm_perfmon_mthd_query_signal(struct nvkm_perfmon *perfmon,\n\t\t\t       void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_perfmon_query_signal_v0 v0;\n\t} *args = data;\n\tstruct nvkm_object *object = &perfmon->object;\n\tstruct nvkm_pm *pm = perfmon->pm;\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\tstruct nvkm_perfdom *dom;\n\tstruct nvkm_perfsig *sig;\n\tconst bool all = nvkm_boolopt(device->cfgopt, \"NvPmShowAll\", false);\n\tconst bool raw = nvkm_boolopt(device->cfgopt, \"NvPmUnnamed\", all);\n\tint ret = -ENOSYS, si;\n\n\tnvif_ioctl(object, \"perfmon query signal size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object,\n\t\t\t   \"perfmon query signal vers %d dom %d iter %04x\\n\",\n\t\t\t   args->v0.version, args->v0.domain, args->v0.iter);\n\t\tsi = (args->v0.iter & 0xffff) - 1;\n\t} else\n\t\treturn ret;\n\n\tdom = nvkm_perfdom_find(pm, args->v0.domain);\n\tif (dom == NULL || si >= (int)dom->signal_nr)\n\t\treturn -EINVAL;\n\n\tif (si >= 0) {\n\t\tsig = &dom->signal[si];\n\t\tif (raw || !sig->name) {\n\t\t\tsnprintf(args->v0.name, sizeof(args->v0.name),\n\t\t\t\t \"/%s/%02x\", dom->name, si);\n\t\t} else {\n\t\t\tstrncpy(args->v0.name, sig->name,\n\t\t\t\tsizeof(args->v0.name) - 1);\n\t\t}\n\n\t\targs->v0.signal = si;\n\t\targs->v0.source_nr = nvkm_perfsig_count_perfsrc(sig);\n\t}\n\n\twhile (++si < dom->signal_nr) {\n\t\tif (all || dom->signal[si].name) {\n\t\t\targs->v0.iter = ++si;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\targs->v0.iter = 0xffff;\n\treturn 0;\n}\n\nstatic int\nnvkm_perfmon_mthd_query_source(struct nvkm_perfmon *perfmon,\n\t\t\t       void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_perfmon_query_source_v0 v0;\n\t} *args = data;\n\tstruct nvkm_object *object = &perfmon->object;\n\tstruct nvkm_pm *pm = perfmon->pm;\n\tstruct nvkm_perfdom *dom = NULL;\n\tstruct nvkm_perfsig *sig;\n\tstruct nvkm_perfsrc *src;\n\tu8 source_nr = 0;\n\tint si, ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"perfmon query source size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object,\n\t\t\t   \"perfmon source vers %d dom %d sig %02x iter %02x\\n\",\n\t\t\t   args->v0.version, args->v0.domain, args->v0.signal,\n\t\t\t   args->v0.iter);\n\t\tsi = (args->v0.iter & 0xff) - 1;\n\t} else\n\t\treturn ret;\n\n\tsig = nvkm_perfsig_find(pm, args->v0.domain, args->v0.signal, &dom);\n\tif (!sig)\n\t\treturn -EINVAL;\n\n\tsource_nr = nvkm_perfsig_count_perfsrc(sig);\n\tif (si >= (int)source_nr)\n\t\treturn -EINVAL;\n\n\tif (si >= 0) {\n\t\tsrc = nvkm_perfsrc_find(pm, sig, sig->source[si]);\n\t\tif (!src)\n\t\t\treturn -EINVAL;\n\n\t\targs->v0.source = sig->source[si];\n\t\targs->v0.mask   = src->mask;\n\t\tstrncpy(args->v0.name, src->name, sizeof(args->v0.name) - 1);\n\t}\n\n\tif (++si < source_nr) {\n\t\targs->v0.iter = ++si;\n\t\treturn 0;\n\t}\n\n\targs->v0.iter = 0xff;\n\treturn 0;\n}\n\nstatic int\nnvkm_perfmon_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tstruct nvkm_perfmon *perfmon = nvkm_perfmon(object);\n\tswitch (mthd) {\n\tcase NVIF_PERFMON_V0_QUERY_DOMAIN:\n\t\treturn nvkm_perfmon_mthd_query_domain(perfmon, data, size);\n\tcase NVIF_PERFMON_V0_QUERY_SIGNAL:\n\t\treturn nvkm_perfmon_mthd_query_signal(perfmon, data, size);\n\tcase NVIF_PERFMON_V0_QUERY_SOURCE:\n\t\treturn nvkm_perfmon_mthd_query_source(perfmon, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_perfmon_child_new(const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\t       struct nvkm_object **pobject)\n{\n\tstruct nvkm_perfmon *perfmon = nvkm_perfmon(oclass->parent);\n\treturn nvkm_perfdom_new_(perfmon, oclass, data, size, pobject);\n}\n\nstatic int\nnvkm_perfmon_child_get(struct nvkm_object *object, int index,\n\t\t       struct nvkm_oclass *oclass)\n{\n\tif (index == 0) {\n\t\toclass->base.oclass = NVIF_CLASS_PERFDOM;\n\t\toclass->base.minver = 0;\n\t\toclass->base.maxver = 0;\n\t\toclass->ctor = nvkm_perfmon_child_new;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void *\nnvkm_perfmon_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_perfmon *perfmon = nvkm_perfmon(object);\n\tstruct nvkm_pm *pm = perfmon->pm;\n\tspin_lock(&pm->client.lock);\n\tif (pm->client.object == &perfmon->object)\n\t\tpm->client.object = NULL;\n\tspin_unlock(&pm->client.lock);\n\treturn perfmon;\n}\n\nstatic const struct nvkm_object_func\nnvkm_perfmon = {\n\t.dtor = nvkm_perfmon_dtor,\n\t.mthd = nvkm_perfmon_mthd,\n\t.sclass = nvkm_perfmon_child_get,\n};\n\nstatic int\nnvkm_perfmon_new(struct nvkm_pm *pm, const struct nvkm_oclass *oclass,\n\t\t void *data, u32 size, struct nvkm_object **pobject)\n{\n\tstruct nvkm_perfmon *perfmon;\n\n\tif (!(perfmon = kzalloc(sizeof(*perfmon), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nvkm_perfmon, oclass, &perfmon->object);\n\tperfmon->pm = pm;\n\t*pobject = &perfmon->object;\n\treturn 0;\n}\n\n \n\nstatic int\nnvkm_pm_oclass_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,\n\t\t   void *data, u32 size, struct nvkm_object **pobject)\n{\n\tstruct nvkm_pm *pm = nvkm_pm(oclass->engine);\n\tint ret;\n\n\tret = nvkm_perfmon_new(pm, oclass, data, size, pobject);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&pm->client.lock);\n\tif (pm->client.object == NULL)\n\t\tpm->client.object = *pobject;\n\tret = (pm->client.object == *pobject) ? 0 : -EBUSY;\n\tspin_unlock(&pm->client.lock);\n\treturn ret;\n}\n\nstatic const struct nvkm_device_oclass\nnvkm_pm_oclass = {\n\t.base.oclass = NVIF_CLASS_PERFMON,\n\t.base.minver = -1,\n\t.base.maxver = -1,\n\t.ctor = nvkm_pm_oclass_new,\n};\n\nstatic int\nnvkm_pm_oclass_get(struct nvkm_oclass *oclass, int index,\n\t\t   const struct nvkm_device_oclass **class)\n{\n\tif (index == 0) {\n\t\toclass->base = nvkm_pm_oclass.base;\n\t\t*class = &nvkm_pm_oclass;\n\t\treturn index;\n\t}\n\treturn 1;\n}\n\nstatic int\nnvkm_perfsrc_new(struct nvkm_pm *pm, struct nvkm_perfsig *sig,\n\t\t const struct nvkm_specsrc *spec)\n{\n\tconst struct nvkm_specsrc *ssrc;\n\tconst struct nvkm_specmux *smux;\n\tstruct nvkm_perfsrc *src;\n\tu8 source_nr = 0;\n\n\tif (!spec) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tssrc = spec;\n\twhile (ssrc->name) {\n\t\tsmux = ssrc->mux;\n\t\twhile (smux->name) {\n\t\t\tbool found = false;\n\t\t\tu8 source_id = 0;\n\t\t\tu32 len;\n\n\t\t\tlist_for_each_entry(src, &pm->sources, head) {\n\t\t\t\tif (src->addr == ssrc->addr &&\n\t\t\t\t    src->shift == smux->shift) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsource_id++;\n\t\t\t}\n\n\t\t\tif (!found) {\n\t\t\t\tsrc = kzalloc(sizeof(*src), GFP_KERNEL);\n\t\t\t\tif (!src)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tsrc->addr   = ssrc->addr;\n\t\t\t\tsrc->mask   = smux->mask;\n\t\t\t\tsrc->shift  = smux->shift;\n\t\t\t\tsrc->enable = smux->enable;\n\n\t\t\t\tlen = strlen(ssrc->name) +\n\t\t\t\t      strlen(smux->name) + 2;\n\t\t\t\tsrc->name = kzalloc(len, GFP_KERNEL);\n\t\t\t\tif (!src->name) {\n\t\t\t\t\tkfree(src);\n\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t}\n\t\t\t\tsnprintf(src->name, len, \"%s_%s\", ssrc->name,\n\t\t\t\t\t smux->name);\n\n\t\t\t\tlist_add_tail(&src->head, &pm->sources);\n\t\t\t}\n\n\t\t\tsig->source[source_nr++] = source_id + 1;\n\t\t\tsmux++;\n\t\t}\n\t\tssrc++;\n\t}\n\n\treturn 0;\n}\n\nint\nnvkm_perfdom_new(struct nvkm_pm *pm, const char *name, u32 mask,\n\t\t u32 base, u32 size_unit, u32 size_domain,\n\t\t const struct nvkm_specdom *spec)\n{\n\tconst struct nvkm_specdom *sdom;\n\tconst struct nvkm_specsig *ssig;\n\tstruct nvkm_perfdom *dom;\n\tint ret, i;\n\n\tfor (i = 0; i == 0 || mask; i++) {\n\t\tu32 addr = base + (i * size_unit);\n\t\tif (i && !(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tsdom = spec;\n\t\twhile (sdom->signal_nr) {\n\t\t\tdom = kzalloc(struct_size(dom, signal, sdom->signal_nr),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!dom)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tif (mask) {\n\t\t\t\tsnprintf(dom->name, sizeof(dom->name),\n\t\t\t\t\t \"%s/%02x/%02x\", name, i,\n\t\t\t\t\t (int)(sdom - spec));\n\t\t\t} else {\n\t\t\t\tsnprintf(dom->name, sizeof(dom->name),\n\t\t\t\t\t \"%s/%02x\", name, (int)(sdom - spec));\n\t\t\t}\n\n\t\t\tlist_add_tail(&dom->head, &pm->domains);\n\t\t\tINIT_LIST_HEAD(&dom->list);\n\t\t\tdom->func = sdom->func;\n\t\t\tdom->addr = addr;\n\t\t\tdom->signal_nr = sdom->signal_nr;\n\n\t\t\tssig = (sdom++)->signal;\n\t\t\twhile (ssig->name) {\n\t\t\t\tstruct nvkm_perfsig *sig =\n\t\t\t\t\t&dom->signal[ssig->signal];\n\t\t\t\tsig->name = ssig->name;\n\t\t\t\tret = nvkm_perfsrc_new(pm, sig, ssig->source);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tssig++;\n\t\t\t}\n\n\t\t\taddr += size_domain;\n\t\t}\n\n\t\tmask &= ~(1 << i);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_pm_fini(struct nvkm_engine *engine, bool suspend)\n{\n\tstruct nvkm_pm *pm = nvkm_pm(engine);\n\tif (pm->func->fini)\n\t\tpm->func->fini(pm);\n\treturn 0;\n}\n\nstatic void *\nnvkm_pm_dtor(struct nvkm_engine *engine)\n{\n\tstruct nvkm_pm *pm = nvkm_pm(engine);\n\tstruct nvkm_perfdom *dom, *next_dom;\n\tstruct nvkm_perfsrc *src, *next_src;\n\n\tlist_for_each_entry_safe(dom, next_dom, &pm->domains, head) {\n\t\tlist_del(&dom->head);\n\t\tkfree(dom);\n\t}\n\n\tlist_for_each_entry_safe(src, next_src, &pm->sources, head) {\n\t\tlist_del(&src->head);\n\t\tkfree(src->name);\n\t\tkfree(src);\n\t}\n\n\treturn pm;\n}\n\nstatic const struct nvkm_engine_func\nnvkm_pm = {\n\t.dtor = nvkm_pm_dtor,\n\t.fini = nvkm_pm_fini,\n\t.base.sclass = nvkm_pm_oclass_get,\n};\n\nint\nnvkm_pm_ctor(const struct nvkm_pm_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_pm *pm)\n{\n\tpm->func = func;\n\tINIT_LIST_HEAD(&pm->domains);\n\tINIT_LIST_HEAD(&pm->sources);\n\tspin_lock_init(&pm->client.lock);\n\treturn nvkm_engine_ctor(&nvkm_pm, device, type, inst, true, &pm->engine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}