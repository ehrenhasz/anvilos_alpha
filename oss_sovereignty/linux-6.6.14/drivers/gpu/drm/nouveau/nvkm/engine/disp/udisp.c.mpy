{
  "module_name": "udisp.c",
  "hash_id": "f942e7867a0d0284b5ec810de77071e49d1483a32d89c97c983e87a2e021f833",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/udisp.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"conn.h\"\n#include \"head.h\"\n#include \"outp.h\"\n\n#include <nvif/class.h>\n#include <nvif/if0010.h>\n\nstatic int\nnvkm_udisp_sclass(struct nvkm_object *object, int index, struct nvkm_oclass *sclass)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(object);\n\n\tif (index-- == 0) {\n\t\tsclass->base = (struct nvkm_sclass) { 0, 0, NVIF_CLASS_CONN };\n\t\tsclass->ctor = nvkm_uconn_new;\n\t\treturn 0;\n\t}\n\n\tif (index-- == 0) {\n\t\tsclass->base = (struct nvkm_sclass) { 0, 0, NVIF_CLASS_OUTP };\n\t\tsclass->ctor = nvkm_uoutp_new;\n\t\treturn 0;\n\t}\n\n\tif (index-- == 0) {\n\t\tsclass->base = (struct nvkm_sclass) { 0, 0, NVIF_CLASS_HEAD };\n\t\tsclass->ctor = nvkm_uhead_new;\n\t\treturn 0;\n\t}\n\n\tif (disp->func->user[index].ctor) {\n\t\tsclass->base = disp->func->user[index].base;\n\t\tsclass->ctor = disp->func->user[index].ctor;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void *\nnvkm_udisp_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(object);\n\n\tspin_lock(&disp->client.lock);\n\tif (object == &disp->client.object)\n\t\tdisp->client.object.func = NULL;\n\tspin_unlock(&disp->client.lock);\n\treturn NULL;\n}\n\nstatic const struct nvkm_object_func\nnvkm_udisp = {\n\t.dtor = nvkm_udisp_dtor,\n\t.sclass = nvkm_udisp_sclass,\n};\n\nint\nnvkm_udisp_new(const struct nvkm_oclass *oclass, void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(oclass->engine);\n\tstruct nvkm_conn *conn;\n\tstruct nvkm_outp *outp;\n\tstruct nvkm_head *head;\n\tunion nvif_disp_args *args = argv;\n\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tspin_lock(&disp->client.lock);\n\tif (disp->client.object.func) {\n\t\tspin_unlock(&disp->client.lock);\n\t\treturn -EBUSY;\n\t}\n\tnvkm_object_ctor(&nvkm_udisp, oclass, &disp->client.object);\n\t*pobject = &disp->client.object;\n\tspin_unlock(&disp->client.lock);\n\n\targs->v0.conn_mask = 0;\n\tlist_for_each_entry(conn, &disp->conns, head)\n\t\targs->v0.conn_mask |= BIT(conn->index);\n\n\targs->v0.outp_mask = 0;\n\tlist_for_each_entry(outp, &disp->outps, head)\n\t\targs->v0.outp_mask |= BIT(outp->index);\n\n\targs->v0.head_mask = 0;\n\tlist_for_each_entry(head, &disp->heads, head)\n\t\targs->v0.head_mask |= BIT(head->id);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}