{
  "module_name": "g84.c",
  "hash_id": "74aacd08a9cb294e7e69cf7567f1222dab6ef1b849cdf571dee7f7b86407c724",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/g84.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"hdmi.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <nvif/class.h>\n\nstatic void\ng84_sor_hdmi_infoframe_vsi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe vsi;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x61653c + hoff, 0x00010001, 0x00010000);\n\tif (!size)\n\t\treturn;\n\n\tpack_hdmi_infoframe(&vsi, data, size);\n\n\tnvkm_wr32(device, 0x616544 + hoff, vsi.header);\n\tnvkm_wr32(device, 0x616548 + hoff, vsi.subpack0_low);\n\tnvkm_wr32(device, 0x61654c + hoff, vsi.subpack0_high);\n\t \n\t \n\t \n\n\tnvkm_mask(device, 0x61653c + hoff, 0x00010001, 0x00010001);\n}\n\nstatic void\ng84_sor_hdmi_infoframe_avi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe avi;\n\tconst u32 hoff = head * 0x800;\n\n\tpack_hdmi_infoframe(&avi, data, size);\n\n\tnvkm_mask(device, 0x616520 + hoff, 0x00000001, 0x00000000);\n\tif (!size)\n\t\treturn;\n\n\tnvkm_wr32(device, 0x616528 + hoff, avi.header);\n\tnvkm_wr32(device, 0x61652c + hoff, avi.subpack0_low);\n\tnvkm_wr32(device, 0x616530 + hoff, avi.subpack0_high);\n\tnvkm_wr32(device, 0x616534 + hoff, avi.subpack1_low);\n\tnvkm_wr32(device, 0x616538 + hoff, avi.subpack1_high);\n\n\tnvkm_mask(device, 0x616520 + hoff, 0x00000001, 0x00000001);\n}\n\n\nstatic void\ng84_sor_hdmi_ctrl(struct nvkm_ior *ior, int head, bool enable, u8 max_ac_packet, u8 rekey)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 ctrl = 0x40000000 * enable |\n\t\t\t 0x1f000000   |\n\t\t\t max_ac_packet << 16 |\n\t\t\t rekey;\n\tconst u32 hoff = head * 0x800;\n\n\tif (!(ctrl & 0x40000000)) {\n\t\tnvkm_mask(device, 0x6165a4 + hoff, 0x40000000, 0x00000000);\n\t\tnvkm_mask(device, 0x616500 + hoff, 0x00000001, 0x00000000);\n\t\treturn;\n\t}\n\n\t \n\tnvkm_mask(device, 0x616500 + hoff, 0x00000001, 0x00000000);\n\tnvkm_wr32(device, 0x616508 + hoff, 0x000a0184);\n\tnvkm_wr32(device, 0x61650c + hoff, 0x00000071);\n\tnvkm_wr32(device, 0x616510 + hoff, 0x00000000);\n\tnvkm_mask(device, 0x616500 + hoff, 0x00000001, 0x00000001);\n\n\n\tnvkm_mask(device, 0x6165d0 + hoff, 0x00070001, 0x00010001);  \n\tnvkm_mask(device, 0x616568 + hoff, 0x00010101, 0x00000000);  \n\tnvkm_mask(device, 0x616578 + hoff, 0x80000000, 0x80000000);  \n\n\t \n\tnvkm_mask(device, 0x61733c, 0x00100000, 0x00100000);  \n\tnvkm_mask(device, 0x61733c, 0x10000000, 0x10000000);  \n\tnvkm_mask(device, 0x61733c, 0x00100000, 0x00000000);  \n\n\t \n\tnvkm_mask(device, 0x6165a4 + hoff, 0x5f1f007f, ctrl);\n}\n\nconst struct nvkm_ior_func_hdmi\ng84_sor_hdmi = {\n\t.ctrl = g84_sor_hdmi_ctrl,\n\t.infoframe_avi = g84_sor_hdmi_infoframe_avi,\n\t.infoframe_vsi = g84_sor_hdmi_infoframe_vsi,\n};\n\nstatic const struct nvkm_ior_func\ng84_sor = {\n\t.state = nv50_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = nv50_sor_clock,\n\t.hdmi = &g84_sor_hdmi,\n};\n\nint\ng84_sor_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&g84_sor, disp, SOR, id, false);\n}\n\nstatic const struct nvkm_disp_mthd_list\ng84_disp_ovly_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x000000 },\n\t\t{ 0x0084, 0x6109a0 },\n\t\t{ 0x0088, 0x6109c0 },\n\t\t{ 0x008c, 0x6109c8 },\n\t\t{ 0x0090, 0x6109b4 },\n\t\t{ 0x0094, 0x610970 },\n\t\t{ 0x00a0, 0x610998 },\n\t\t{ 0x00a4, 0x610964 },\n\t\t{ 0x00c0, 0x610958 },\n\t\t{ 0x00e0, 0x6109a8 },\n\t\t{ 0x00e4, 0x6109d0 },\n\t\t{ 0x00e8, 0x6109d8 },\n\t\t{ 0x0100, 0x61094c },\n\t\t{ 0x0104, 0x610984 },\n\t\t{ 0x0108, 0x61098c },\n\t\t{ 0x0800, 0x6109f8 },\n\t\t{ 0x0808, 0x610a08 },\n\t\t{ 0x080c, 0x610a10 },\n\t\t{ 0x0810, 0x610a00 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\ng84_disp_ovly_mthd = {\n\t.name = \"Overlay\",\n\t.addr = 0x000540,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &g84_disp_ovly_mthd_base },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_user\ng84_disp_ovly = {\n\t.func = &nv50_disp_dmac_func,\n\t.ctrl = 3,\n\t.user = 3,\n\t.mthd = &g84_disp_ovly_mthd,\n};\n\nstatic const struct nvkm_disp_mthd_list\ng84_disp_base_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x000000 },\n\t\t{ 0x0084, 0x0008c4 },\n\t\t{ 0x0088, 0x0008d0 },\n\t\t{ 0x008c, 0x0008dc },\n\t\t{ 0x0090, 0x0008e4 },\n\t\t{ 0x0094, 0x610884 },\n\t\t{ 0x00a0, 0x6108a0 },\n\t\t{ 0x00a4, 0x610878 },\n\t\t{ 0x00c0, 0x61086c },\n\t\t{ 0x00c4, 0x610800 },\n\t\t{ 0x00c8, 0x61080c },\n\t\t{ 0x00cc, 0x610818 },\n\t\t{ 0x00e0, 0x610858 },\n\t\t{ 0x00e4, 0x610860 },\n\t\t{ 0x00e8, 0x6108ac },\n\t\t{ 0x00ec, 0x6108b4 },\n\t\t{ 0x00fc, 0x610824 },\n\t\t{ 0x0100, 0x610894 },\n\t\t{ 0x0104, 0x61082c },\n\t\t{ 0x0110, 0x6108bc },\n\t\t{ 0x0114, 0x61088c },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\ng84_disp_base_mthd = {\n\t.name = \"Base\",\n\t.addr = 0x000540,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &g84_disp_base_mthd_base },\n\t\t{  \"Image\", 2, &nv50_disp_base_mthd_image },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_user\ng84_disp_base = {\n\t.func = &nv50_disp_dmac_func,\n\t.ctrl = 1,\n\t.user = 1,\n\t.mthd = &g84_disp_base_mthd,\n};\n\nconst struct nvkm_disp_mthd_list\ng84_disp_core_mthd_dac = {\n\t.mthd = 0x0080,\n\t.addr = 0x000008,\n\t.data = {\n\t\t{ 0x0400, 0x610b58 },\n\t\t{ 0x0404, 0x610bdc },\n\t\t{ 0x0420, 0x610bc4 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\ng84_disp_core_mthd_head = {\n\t.mthd = 0x0400,\n\t.addr = 0x000540,\n\t.data = {\n\t\t{ 0x0800, 0x610ad8 },\n\t\t{ 0x0804, 0x610ad0 },\n\t\t{ 0x0808, 0x610a48 },\n\t\t{ 0x080c, 0x610a78 },\n\t\t{ 0x0810, 0x610ac0 },\n\t\t{ 0x0814, 0x610af8 },\n\t\t{ 0x0818, 0x610b00 },\n\t\t{ 0x081c, 0x610ae8 },\n\t\t{ 0x0820, 0x610af0 },\n\t\t{ 0x0824, 0x610b08 },\n\t\t{ 0x0828, 0x610b10 },\n\t\t{ 0x082c, 0x610a68 },\n\t\t{ 0x0830, 0x610a60 },\n\t\t{ 0x0834, 0x000000 },\n\t\t{ 0x0838, 0x610a40 },\n\t\t{ 0x0840, 0x610a24 },\n\t\t{ 0x0844, 0x610a2c },\n\t\t{ 0x0848, 0x610aa8 },\n\t\t{ 0x084c, 0x610ab0 },\n\t\t{ 0x085c, 0x610c5c },\n\t\t{ 0x0860, 0x610a84 },\n\t\t{ 0x0864, 0x610a90 },\n\t\t{ 0x0868, 0x610b18 },\n\t\t{ 0x086c, 0x610b20 },\n\t\t{ 0x0870, 0x610ac8 },\n\t\t{ 0x0874, 0x610a38 },\n\t\t{ 0x0878, 0x610c50 },\n\t\t{ 0x0880, 0x610a58 },\n\t\t{ 0x0884, 0x610a9c },\n\t\t{ 0x089c, 0x610c68 },\n\t\t{ 0x08a0, 0x610a70 },\n\t\t{ 0x08a4, 0x610a50 },\n\t\t{ 0x08a8, 0x610ae0 },\n\t\t{ 0x08c0, 0x610b28 },\n\t\t{ 0x08c4, 0x610b30 },\n\t\t{ 0x08c8, 0x610b40 },\n\t\t{ 0x08d4, 0x610b38 },\n\t\t{ 0x08d8, 0x610b48 },\n\t\t{ 0x08dc, 0x610b50 },\n\t\t{ 0x0900, 0x610a18 },\n\t\t{ 0x0904, 0x610ab8 },\n\t\t{ 0x0910, 0x610c70 },\n\t\t{ 0x0914, 0x610c78 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_mthd\ng84_disp_core_mthd = {\n\t.name = \"Core\",\n\t.addr = 0x000000,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &nv50_disp_core_mthd_base },\n\t\t{    \"DAC\", 3, &g84_disp_core_mthd_dac  },\n\t\t{    \"SOR\", 2, &nv50_disp_core_mthd_sor  },\n\t\t{   \"PIOR\", 3, &nv50_disp_core_mthd_pior },\n\t\t{   \"HEAD\", 2, &g84_disp_core_mthd_head },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_chan_user\ng84_disp_core = {\n\t.func = &nv50_disp_core_func,\n\t.ctrl = 0,\n\t.user = 0,\n\t.mthd = &g84_disp_core_mthd,\n};\n\nstatic const struct nvkm_disp_func\ng84_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = nv50_disp_init,\n\t.fini = nv50_disp_fini,\n\t.intr = nv50_disp_intr,\n\t.super = nv50_disp_super,\n\t.uevent = &nv50_disp_chan_uevent,\n\t.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },\n\t.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },\n\t.sor = { .cnt = nv50_sor_cnt, .new = g84_sor_new },\n\t.pior = { .cnt = nv50_pior_cnt, .new = nv50_pior_new },\n\t.root = { 0,0,G82_DISP },\n\t.user = {\n\t\t{{0,0,G82_DISP_CURSOR             }, nvkm_disp_chan_new, &nv50_disp_curs },\n\t\t{{0,0,G82_DISP_OVERLAY            }, nvkm_disp_chan_new, &nv50_disp_oimm },\n\t\t{{0,0,G82_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, & g84_disp_base },\n\t\t{{0,0,G82_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, & g84_disp_core },\n\t\t{{0,0,G82_DISP_OVERLAY_CHANNEL_DMA}, nvkm_disp_chan_new, & g84_disp_ovly },\n\t\t{}\n\t},\n};\n\nint\ng84_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t     struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&g84_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}