{
  "module_name": "dp.c",
  "hash_id": "f6a481ea347bbcf8446a0199271535666a97aad573f4b9d477486541b60cb1de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/dp.c",
  "human_readable_source": " \n#include \"dp.h\"\n#include \"conn.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <drm/display/drm_dp.h>\n\n#include <subdev/bios.h>\n#include <subdev/bios/init.h>\n#include <subdev/gpio.h>\n#include <subdev/i2c.h>\n\n#include <nvif/event.h>\n\n \n#define AMPERE_IED_HACK(disp) ((disp)->engine.subdev.device->card_type >= GA100)\n\nstruct lt_state {\n\tstruct nvkm_outp *outp;\n\n\tint repeaters;\n\tint repeater;\n\n\tu8  stat[6];\n\tu8  conf[4];\n\tbool pc2;\n\tu8  pc2stat;\n\tu8  pc2conf[2];\n};\n\nstatic int\nnvkm_dp_train_sense(struct lt_state *lt, bool pc, u32 delay)\n{\n\tstruct nvkm_outp *outp = lt->outp;\n\tu32 addr;\n\tint ret;\n\n\tusleep_range(delay, delay * 2);\n\n\tif (lt->repeater)\n\t\taddr = DPCD_LTTPR_LANE0_1_STATUS(lt->repeater);\n\telse\n\t\taddr = DPCD_LS02;\n\n\tret = nvkm_rdaux(outp->dp.aux, addr, &lt->stat[0], 3);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lt->repeater)\n\t\taddr = DPCD_LTTPR_LANE0_1_ADJUST(lt->repeater);\n\telse\n\t\taddr = DPCD_LS06;\n\n\tret = nvkm_rdaux(outp->dp.aux, addr, &lt->stat[4], 2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pc) {\n\t\tret = nvkm_rdaux(outp->dp.aux, DPCD_LS0C, &lt->pc2stat, 1);\n\t\tif (ret)\n\t\t\tlt->pc2stat = 0x00;\n\n\t\tOUTP_TRACE(outp, \"status %6ph pc2 %02x\", lt->stat, lt->pc2stat);\n\t} else {\n\t\tOUTP_TRACE(outp, \"status %6ph\", lt->stat);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_dp_train_drive(struct lt_state *lt, bool pc)\n{\n\tstruct nvkm_outp *outp = lt->outp;\n\tstruct nvkm_ior *ior = outp->ior;\n\tstruct nvkm_bios *bios = ior->disp->engine.subdev.device->bios;\n\tstruct nvbios_dpout info;\n\tstruct nvbios_dpcfg ocfg;\n\tu8  ver, hdr, cnt, len;\n\tu32 addr;\n\tu32 data;\n\tint ret, i;\n\n\tfor (i = 0; i < ior->dp.nr; i++) {\n\t\tu8 lane = (lt->stat[4 + (i >> 1)] >> ((i & 1) * 4)) & 0xf;\n\t\tu8 lpc2 = (lt->pc2stat >> (i * 2)) & 0x3;\n\t\tu8 lpre = (lane & 0x0c) >> 2;\n\t\tu8 lvsw = (lane & 0x03) >> 0;\n\t\tu8 hivs = 3 - lpre;\n\t\tu8 hipe = 3;\n\t\tu8 hipc = 3;\n\n\t\tif (lpc2 >= hipc)\n\t\t\tlpc2 = hipc | DPCD_LC0F_LANE0_MAX_POST_CURSOR2_REACHED;\n\t\tif (lpre >= hipe) {\n\t\t\tlpre = hipe | DPCD_LC03_MAX_SWING_REACHED;  \n\t\t\tlvsw = hivs = 3 - (lpre & 3);\n\t\t} else\n\t\tif (lvsw >= hivs) {\n\t\t\tlvsw = hivs | DPCD_LC03_MAX_SWING_REACHED;\n\t\t}\n\n\t\tlt->conf[i] = (lpre << 3) | lvsw;\n\t\tlt->pc2conf[i >> 1] |= lpc2 << ((i & 1) * 4);\n\n\t\tOUTP_TRACE(outp, \"config lane %d %02x %02x\", i, lt->conf[i], lpc2);\n\n\t\tif (lt->repeater != lt->repeaters)\n\t\t\tcontinue;\n\n\t\tdata = nvbios_dpout_match(bios, outp->info.hasht, outp->info.hashm,\n\t\t\t\t\t  &ver, &hdr, &cnt, &len, &info);\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\tdata = nvbios_dpcfg_match(bios, data, lpc2 & 3, lvsw & 3, lpre & 3,\n\t\t\t\t\t  &ver, &hdr, &cnt, &len, &ocfg);\n\t\tif (!data)\n\t\t\tcontinue;\n\n\t\tior->func->dp->drive(ior, i, ocfg.pc, ocfg.dc, ocfg.pe, ocfg.tx_pu);\n\t}\n\n\tif (lt->repeater)\n\t\taddr = DPCD_LTTPR_LANE0_SET(lt->repeater);\n\telse\n\t\taddr = DPCD_LC03(0);\n\n\tret = nvkm_wraux(outp->dp.aux, addr, lt->conf, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pc) {\n\t\tret = nvkm_wraux(outp->dp.aux, DPCD_LC0F, lt->pc2conf, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnvkm_dp_train_pattern(struct lt_state *lt, u8 pattern)\n{\n\tstruct nvkm_outp *outp = lt->outp;\n\tu32 addr;\n\tu8 sink_tp;\n\n\tOUTP_TRACE(outp, \"training pattern %d\", pattern);\n\toutp->ior->func->dp->pattern(outp->ior, pattern);\n\n\tif (lt->repeater)\n\t\taddr = DPCD_LTTPR_PATTERN_SET(lt->repeater);\n\telse\n\t\taddr = DPCD_LC02;\n\n\tnvkm_rdaux(outp->dp.aux, addr, &sink_tp, 1);\n\tsink_tp &= ~DPCD_LC02_TRAINING_PATTERN_SET;\n\tsink_tp |= (pattern != 4) ? pattern : 7;\n\n\tif (pattern != 0)\n\t\tsink_tp |=  DPCD_LC02_SCRAMBLING_DISABLE;\n\telse\n\t\tsink_tp &= ~DPCD_LC02_SCRAMBLING_DISABLE;\n\tnvkm_wraux(outp->dp.aux, addr, &sink_tp, 1);\n}\n\nstatic int\nnvkm_dp_train_eq(struct lt_state *lt)\n{\n\tstruct nvkm_i2c_aux *aux = lt->outp->dp.aux;\n\tbool eq_done = false, cr_done = true;\n\tint tries = 0, usec = 0, i;\n\tu8 data;\n\n\tif (lt->repeater) {\n\t\tif (!nvkm_rdaux(aux, DPCD_LTTPR_AUX_RD_INTERVAL(lt->repeater), &data, sizeof(data)))\n\t\t\tusec = (data & DPCD_RC0E_AUX_RD_INTERVAL) * 4000;\n\n\t\tnvkm_dp_train_pattern(lt, 4);\n\t} else {\n\t\tif (lt->outp->dp.dpcd[DPCD_RC00_DPCD_REV] >= 0x14 &&\n\t\t    lt->outp->dp.dpcd[DPCD_RC03] & DPCD_RC03_TPS4_SUPPORTED)\n\t\t\tnvkm_dp_train_pattern(lt, 4);\n\t\telse\n\t\tif (lt->outp->dp.dpcd[DPCD_RC00_DPCD_REV] >= 0x12 &&\n\t\t    lt->outp->dp.dpcd[DPCD_RC02] & DPCD_RC02_TPS3_SUPPORTED)\n\t\t\tnvkm_dp_train_pattern(lt, 3);\n\t\telse\n\t\t\tnvkm_dp_train_pattern(lt, 2);\n\n\t\tusec = (lt->outp->dp.dpcd[DPCD_RC0E] & DPCD_RC0E_AUX_RD_INTERVAL) * 4000;\n\t}\n\n\tdo {\n\t\tif ((tries &&\n\t\t    nvkm_dp_train_drive(lt, lt->pc2)) ||\n\t\t    nvkm_dp_train_sense(lt, lt->pc2, usec ? usec : 400))\n\t\t\tbreak;\n\n\t\teq_done = !!(lt->stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE);\n\t\tfor (i = 0; i < lt->outp->ior->dp.nr && eq_done; i++) {\n\t\t\tu8 lane = (lt->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\n\t\t\tif (!(lane & DPCD_LS02_LANE0_CR_DONE))\n\t\t\t\tcr_done = false;\n\t\t\tif (!(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||\n\t\t\t    !(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED))\n\t\t\t\teq_done = false;\n\t\t}\n\t} while (!eq_done && cr_done && ++tries <= 5);\n\n\treturn eq_done ? 0 : -1;\n}\n\nstatic int\nnvkm_dp_train_cr(struct lt_state *lt)\n{\n\tbool cr_done = false, abort = false;\n\tint voltage = lt->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;\n\tint tries = 0, usec = 0, i;\n\n\tnvkm_dp_train_pattern(lt, 1);\n\n\tif (lt->outp->dp.dpcd[DPCD_RC00_DPCD_REV] < 0x14 && !lt->repeater)\n\t\tusec = (lt->outp->dp.dpcd[DPCD_RC0E] & DPCD_RC0E_AUX_RD_INTERVAL) * 4000;\n\n\tdo {\n\t\tif (nvkm_dp_train_drive(lt, false) ||\n\t\t    nvkm_dp_train_sense(lt, false, usec ? usec : 100))\n\t\t\tbreak;\n\n\t\tcr_done = true;\n\t\tfor (i = 0; i < lt->outp->ior->dp.nr; i++) {\n\t\t\tu8 lane = (lt->stat[i >> 1] >> ((i & 1) * 4)) & 0xf;\n\t\t\tif (!(lane & DPCD_LS02_LANE0_CR_DONE)) {\n\t\t\t\tcr_done = false;\n\t\t\t\tif (lt->conf[i] & DPCD_LC03_MAX_SWING_REACHED)\n\t\t\t\t\tabort = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ((lt->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET) != voltage) {\n\t\t\tvoltage = lt->conf[0] & DPCD_LC03_VOLTAGE_SWING_SET;\n\t\t\ttries = 0;\n\t\t}\n\t} while (!cr_done && !abort && ++tries < 5);\n\n\treturn cr_done ? 0 : -1;\n}\n\nstatic int\nnvkm_dp_train_link(struct nvkm_outp *outp, int rate)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tstruct lt_state lt = {\n\t\t.outp = outp,\n\t\t.pc2 = outp->dp.dpcd[DPCD_RC02] & DPCD_RC02_TPS3_SUPPORTED,\n\t};\n\tu8 sink[2], data;\n\tint ret;\n\n\tOUTP_DBG(outp, \"training %dx%02x\", ior->dp.nr, ior->dp.bw);\n\n\t \n\tif (outp->dp.lttpr[0] >= 0x14) {\n\t\tdata = DPCD_LTTPR_MODE_TRANSPARENT;\n\t\tnvkm_wraux(outp->dp.aux, DPCD_LTTPR_MODE, &data, sizeof(data));\n\n\t\tif (outp->dp.lttprs) {\n\t\t\tdata = DPCD_LTTPR_MODE_NON_TRANSPARENT;\n\t\t\tnvkm_wraux(outp->dp.aux, DPCD_LTTPR_MODE, &data, sizeof(data));\n\t\t\tlt.repeaters = outp->dp.lttprs;\n\t\t}\n\t}\n\n\t \n\tsink[0] = (outp->dp.rate[rate].dpcd < 0) ? ior->dp.bw : 0;\n\tsink[1] = ior->dp.nr;\n\tif (ior->dp.ef)\n\t\tsink[1] |= DPCD_LC01_ENHANCED_FRAME_EN;\n\n\tret = nvkm_wraux(outp->dp.aux, DPCD_LC00_LINK_BW_SET, sink, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tif (outp->dp.rate[rate].dpcd >= 0) {\n\t\tret = nvkm_rdaux(outp->dp.aux, DPCD_LC15_LINK_RATE_SET, &sink[0], sizeof(sink[0]));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsink[0] &= ~DPCD_LC15_LINK_RATE_SET_MASK;\n\t\tsink[0] |= outp->dp.rate[rate].dpcd;\n\n\t\tret = nvkm_wraux(outp->dp.aux, DPCD_LC15_LINK_RATE_SET, &sink[0], sizeof(sink[0]));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (lt.repeater = lt.repeaters; lt.repeater >= 0; lt.repeater--) {\n\t\tif (lt.repeater)\n\t\t\tOUTP_DBG(outp, \"training LTTPR%d\", lt.repeater);\n\t\telse\n\t\t\tOUTP_DBG(outp, \"training sink\");\n\n\t\tmemset(lt.stat, 0x00, sizeof(lt.stat));\n\t\tret = nvkm_dp_train_cr(&lt);\n\t\tif (ret == 0)\n\t\t\tret = nvkm_dp_train_eq(&lt);\n\t\tnvkm_dp_train_pattern(&lt, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_dp_train_links(struct nvkm_outp *outp, int rate)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tstruct nvkm_disp *disp = outp->disp;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tu32 lnkcmp;\n\tint ret;\n\n\tOUTP_DBG(outp, \"programming link for %dx%02x\", ior->dp.nr, ior->dp.bw);\n\n\t \n\tif (disp->engine.subdev.device->chipset < 0x110)\n\t\toutp->dp.dpcd[DPCD_RC03] &= ~DPCD_RC03_TPS4_SUPPORTED;\n\tif (disp->engine.subdev.device->chipset < 0xd0)\n\t\toutp->dp.dpcd[DPCD_RC02] &= ~DPCD_RC02_TPS3_SUPPORTED;\n\n\tif (AMPERE_IED_HACK(disp) && (lnkcmp = outp->dp.info.script[0])) {\n\t\t \n\t\twhile (ior->dp.bw < nvbios_rd08(bios, lnkcmp))\n\t\t\tlnkcmp += 3;\n\t\tlnkcmp = nvbios_rd16(bios, lnkcmp + 1);\n\n\t\tnvbios_init(&outp->disp->engine.subdev, lnkcmp,\n\t\t\tinit.outp = &outp->info;\n\t\t\tinit.or   = ior->id;\n\t\t\tinit.link = ior->asy.link;\n\t\t);\n\t}\n\n\t \n\tif ((lnkcmp = outp->dp.info.lnkcmp)) {\n\t\tif (outp->dp.version < 0x30) {\n\t\t\twhile ((ior->dp.bw * 2700) < nvbios_rd16(bios, lnkcmp))\n\t\t\t\tlnkcmp += 4;\n\t\t\tlnkcmp = nvbios_rd16(bios, lnkcmp + 2);\n\t\t} else {\n\t\t\twhile (ior->dp.bw < nvbios_rd08(bios, lnkcmp))\n\t\t\t\tlnkcmp += 3;\n\t\t\tlnkcmp = nvbios_rd16(bios, lnkcmp + 1);\n\t\t}\n\n\t\tnvbios_init(subdev, lnkcmp,\n\t\t\tinit.outp = &outp->info;\n\t\t\tinit.or   = ior->id;\n\t\t\tinit.link = ior->asy.link;\n\t\t);\n\t}\n\n\tret = ior->func->dp->links(ior, outp->dp.aux);\n\tif (ret) {\n\t\tif (ret < 0) {\n\t\t\tOUTP_ERR(outp, \"train failed with %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tior->func->dp->power(ior, ior->dp.nr);\n\n\t \n\treturn nvkm_dp_train_link(outp, rate);\n}\n\nstatic void\nnvkm_dp_train_fini(struct nvkm_outp *outp)\n{\n\t \n\tnvbios_init(&outp->disp->engine.subdev, outp->dp.info.script[1],\n\t\tinit.outp = &outp->info;\n\t\tinit.or   = outp->ior->id;\n\t\tinit.link = outp->ior->asy.link;\n\t);\n}\n\nstatic void\nnvkm_dp_train_init(struct nvkm_outp *outp)\n{\n\t \n\tif (outp->dp.dpcd[DPCD_RC03] & DPCD_RC03_MAX_DOWNSPREAD) {\n\t\tnvbios_init(&outp->disp->engine.subdev, outp->dp.info.script[2],\n\t\t\tinit.outp = &outp->info;\n\t\t\tinit.or   = outp->ior->id;\n\t\t\tinit.link = outp->ior->asy.link;\n\t\t);\n\t} else {\n\t\tnvbios_init(&outp->disp->engine.subdev, outp->dp.info.script[3],\n\t\t\tinit.outp = &outp->info;\n\t\t\tinit.or   = outp->ior->id;\n\t\t\tinit.link = outp->ior->asy.link;\n\t\t);\n\t}\n\n\tif (!AMPERE_IED_HACK(outp->disp)) {\n\t\t \n\t\tnvbios_init(&outp->disp->engine.subdev, outp->dp.info.script[0],\n\t\t\tinit.outp = &outp->info;\n\t\t\tinit.or   = outp->ior->id;\n\t\t\tinit.link = outp->ior->asy.link;\n\t\t);\n\t}\n}\n\nstatic int\nnvkm_dp_train(struct nvkm_outp *outp, u32 dataKBps)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tint ret = -EINVAL, nr, rate;\n\tu8  pwr;\n\n\t \n\tif (atomic_read(&outp->dp.lt.done)) {\n\t\tfor (rate = 0; rate < outp->dp.rates; rate++) {\n\t\t\tif (outp->dp.rate[rate].rate == ior->dp.bw * 27000)\n\t\t\t\treturn nvkm_dp_train_link(outp, ret);\n\t\t}\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!nvkm_rdaux(outp->dp.aux, DPCD_SC00, &pwr, 1)) {\n\t\tif ((pwr & DPCD_SC00_SET_POWER) != DPCD_SC00_SET_POWER_D0) {\n\t\t\tpwr &= ~DPCD_SC00_SET_POWER;\n\t\t\tpwr |=  DPCD_SC00_SET_POWER_D0;\n\t\t\tnvkm_wraux(outp->dp.aux, DPCD_SC00, &pwr, 1);\n\t\t}\n\t}\n\n\tior->dp.mst = outp->dp.lt.mst;\n\tior->dp.ef = outp->dp.dpcd[DPCD_RC02] & DPCD_RC02_ENHANCED_FRAME_CAP;\n\tior->dp.nr = 0;\n\n\t \n\tOUTP_DBG(outp, \"training\");\n\tnvkm_dp_train_init(outp);\n\n\t \n\tif (outp->dp.lt.nr) {\n\t\tfor (nr = outp->dp.links; ret < 0 && nr; nr >>= 1) {\n\t\t\tfor (rate = 0; nr == outp->dp.lt.nr && rate < outp->dp.rates; rate++) {\n\t\t\t\tif (outp->dp.rate[rate].rate / 27000 == outp->dp.lt.bw) {\n\t\t\t\t\tior->dp.bw = outp->dp.rate[rate].rate / 27000;\n\t\t\t\t\tior->dp.nr = nr;\n\t\t\t\t\tret = nvkm_dp_train_links(outp, rate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (nr = outp->dp.links; ret < 0 && nr; nr >>= 1) {\n\t\tfor (rate = 0; ret < 0 && rate < outp->dp.rates; rate++) {\n\t\t\tif (outp->dp.rate[rate].rate * nr >= dataKBps || WARN_ON(!ior->dp.nr)) {\n\t\t\t\t \n\t\t\t\tior->dp.bw = outp->dp.rate[rate].rate / 27000;\n\t\t\t\tior->dp.nr = nr;\n\t\t\t\tret = nvkm_dp_train_links(outp, rate);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tnvkm_dp_train_fini(outp);\n\tif (ret < 0)\n\t\tOUTP_ERR(outp, \"training failed\");\n\telse\n\t\tOUTP_DBG(outp, \"training done\");\n\tatomic_set(&outp->dp.lt.done, 1);\n\treturn ret;\n}\n\nvoid\nnvkm_dp_disable(struct nvkm_outp *outp, struct nvkm_ior *ior)\n{\n\t \n\tnvbios_init(&ior->disp->engine.subdev, outp->dp.info.script[4],\n\t\tinit.outp = &outp->info;\n\t\tinit.or   = ior->id;\n\t\tinit.link = ior->arm.link;\n\t);\n}\n\nstatic void\nnvkm_dp_release(struct nvkm_outp *outp)\n{\n\t \n\tatomic_set(&outp->dp.lt.done, 0);\n\toutp->ior->dp.nr = 0;\n}\n\nstatic int\nnvkm_dp_acquire(struct nvkm_outp *outp)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tstruct nvkm_head *head;\n\tbool retrain = true;\n\tu32 datakbps = 0;\n\tu32 dataKBps;\n\tu32 linkKBps;\n\tu8  stat[3];\n\tint ret, i;\n\n\tmutex_lock(&outp->dp.mutex);\n\n\t \n\tlist_for_each_entry(head, &outp->disp->heads, head) {\n\t\tif (ior->asy.head & (1 << head->id)) {\n\t\t\tu32 khz = (head->asy.hz >> ior->asy.rgdiv) / 1000;\n\t\t\tdatakbps += khz * head->asy.or.depth;\n\t\t}\n\t}\n\n\tlinkKBps = ior->dp.bw * 27000 * ior->dp.nr;\n\tdataKBps = DIV_ROUND_UP(datakbps, 8);\n\tOUTP_DBG(outp, \"data %d KB/s link %d KB/s mst %d->%d\",\n\t\t dataKBps, linkKBps, ior->dp.mst, outp->dp.lt.mst);\n\tif (linkKBps < dataKBps || ior->dp.mst != outp->dp.lt.mst) {\n\t\tOUTP_DBG(outp, \"link requirements changed\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = nvkm_rdaux(outp->dp.aux, DPCD_LS02, stat, 3);\n\tif (ret) {\n\t\tOUTP_DBG(outp, \"failed to read link status, assuming no sink\");\n\t\tgoto done;\n\t}\n\n\tif (stat[2] & DPCD_LS04_INTERLANE_ALIGN_DONE) {\n\t\tfor (i = 0; i < ior->dp.nr; i++) {\n\t\t\tu8 lane = (stat[i >> 1] >> ((i & 1) * 4)) & 0x0f;\n\t\t\tif (!(lane & DPCD_LS02_LANE0_CR_DONE) ||\n\t\t\t    !(lane & DPCD_LS02_LANE0_CHANNEL_EQ_DONE) ||\n\t\t\t    !(lane & DPCD_LS02_LANE0_SYMBOL_LOCKED)) {\n\t\t\t\tOUTP_DBG(outp, \"lane %d not equalised\", lane);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tretrain = false;\n\t} else {\n\t\tOUTP_DBG(outp, \"no inter-lane alignment\");\n\t}\n\ndone:\n\tif (retrain || !atomic_read(&outp->dp.lt.done))\n\t\tret = nvkm_dp_train(outp, dataKBps);\n\tmutex_unlock(&outp->dp.mutex);\n\treturn ret;\n}\n\nstatic bool\nnvkm_dp_enable_supported_link_rates(struct nvkm_outp *outp)\n{\n\tu8 sink_rates[DPCD_RC10_SUPPORTED_LINK_RATES__SIZE];\n\tint i, j, k;\n\n\tif (outp->conn->info.type != DCB_CONNECTOR_eDP ||\n\t    outp->dp.dpcd[DPCD_RC00_DPCD_REV] < 0x13 ||\n\t    nvkm_rdaux(outp->dp.aux, DPCD_RC10_SUPPORTED_LINK_RATES(0),\n\t\t       sink_rates, sizeof(sink_rates)))\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(sink_rates); i += 2) {\n\t\tconst u32 rate = ((sink_rates[i + 1] << 8) | sink_rates[i]) * 200 / 10;\n\n\t\tif (!rate || WARN_ON(outp->dp.rates == ARRAY_SIZE(outp->dp.rate)))\n\t\t\tbreak;\n\n\t\tif (rate > outp->info.dpconf.link_bw * 27000) {\n\t\t\tOUTP_DBG(outp, \"rate %d !outp\", rate);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < outp->dp.rates; j++) {\n\t\t\tif (rate > outp->dp.rate[j].rate) {\n\t\t\t\tfor (k = outp->dp.rates; k > j; k--)\n\t\t\t\t\toutp->dp.rate[k] = outp->dp.rate[k - 1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\toutp->dp.rate[j].dpcd = i / 2;\n\t\toutp->dp.rate[j].rate = rate;\n\t\toutp->dp.rates++;\n\t}\n\n\tfor (i = 0; i < outp->dp.rates; i++)\n\t\tOUTP_DBG(outp, \"link_rate[%d] = %d\", outp->dp.rate[i].dpcd, outp->dp.rate[i].rate);\n\n\treturn outp->dp.rates != 0;\n}\n\n \nstatic int\nnvkm_dp_read_dpcd_caps(struct nvkm_outp *outp)\n{\n\tstruct nvkm_i2c_aux *aux = outp->dp.aux;\n\tu8 dpcd_ext[DP_RECEIVER_CAP_SIZE];\n\tint ret;\n\n\tret = nvkm_rdaux(aux, DPCD_RC00_DPCD_REV, outp->dp.dpcd, DP_RECEIVER_CAP_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!(outp->dp.dpcd[DP_TRAINING_AUX_RD_INTERVAL] &\n\t      DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT))\n\t\treturn 0;\n\n\tret = nvkm_rdaux(aux, DP_DP13_DPCD_REV, dpcd_ext, sizeof(dpcd_ext));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (outp->dp.dpcd[DP_DPCD_REV] > dpcd_ext[DP_DPCD_REV]) {\n\t\tOUTP_DBG(outp, \"Extended DPCD rev less than base DPCD rev (%d > %d)\\n\",\n\t\t\t outp->dp.dpcd[DP_DPCD_REV], dpcd_ext[DP_DPCD_REV]);\n\t\treturn 0;\n\t}\n\n\tif (!memcmp(outp->dp.dpcd, dpcd_ext, sizeof(dpcd_ext)))\n\t\treturn 0;\n\n\tmemcpy(outp->dp.dpcd, dpcd_ext, sizeof(dpcd_ext));\n\n\treturn 0;\n}\n\nvoid\nnvkm_dp_enable(struct nvkm_outp *outp, bool auxpwr)\n{\n\tstruct nvkm_gpio *gpio = outp->disp->engine.subdev.device->gpio;\n\tstruct nvkm_i2c_aux *aux = outp->dp.aux;\n\n\tif (auxpwr && !outp->dp.aux_pwr) {\n\t\t \n\t\tif (outp->conn->info.type == DCB_CONNECTOR_eDP) {\n\t\t\tint power = nvkm_gpio_get(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff);\n\t\t\tif (power == 0) {\n\t\t\t\tnvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 1);\n\t\t\t\toutp->dp.aux_pwr_pu = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tmsleep(300);\n\t\t}\n\n\t\tOUTP_DBG(outp, \"aux power -> always\");\n\t\tnvkm_i2c_aux_monitor(aux, true);\n\t\toutp->dp.aux_pwr = true;\n\n\t\t \n\t\tif (!nvkm_rdaux(aux, DPCD_LTTPR_REV, outp->dp.lttpr, sizeof(outp->dp.lttpr)) &&\n\t\t    outp->dp.lttpr[0] >= 0x14 && outp->dp.lttpr[2]) {\n\t\t\tswitch (outp->dp.lttpr[2]) {\n\t\t\tcase 0x80: outp->dp.lttprs = 1; break;\n\t\t\tcase 0x40: outp->dp.lttprs = 2; break;\n\t\t\tcase 0x20: outp->dp.lttprs = 3; break;\n\t\t\tcase 0x10: outp->dp.lttprs = 4; break;\n\t\t\tcase 0x08: outp->dp.lttprs = 5; break;\n\t\t\tcase 0x04: outp->dp.lttprs = 6; break;\n\t\t\tcase 0x02: outp->dp.lttprs = 7; break;\n\t\t\tcase 0x01: outp->dp.lttprs = 8; break;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tWARN_ON(1);\n\t\t\t\toutp->dp.lttprs = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tmemset(outp->dp.lttpr, 0x00, sizeof(outp->dp.lttpr));\n\t\t}\n\n\t\tif (!nvkm_dp_read_dpcd_caps(outp)) {\n\t\t\tconst u8 rates[] = { 0x1e, 0x14, 0x0a, 0x06, 0 };\n\t\t\tconst u8 *rate;\n\t\t\tint rate_max;\n\n\t\t\toutp->dp.rates = 0;\n\t\t\toutp->dp.links = outp->dp.dpcd[DPCD_RC02] & DPCD_RC02_MAX_LANE_COUNT;\n\t\t\toutp->dp.links = min(outp->dp.links, outp->info.dpconf.link_nr);\n\t\t\tif (outp->dp.lttprs && outp->dp.lttpr[4])\n\t\t\t\toutp->dp.links = min_t(int, outp->dp.links, outp->dp.lttpr[4]);\n\n\t\t\trate_max = outp->dp.dpcd[DPCD_RC01_MAX_LINK_RATE];\n\t\t\trate_max = min(rate_max, outp->info.dpconf.link_bw);\n\t\t\tif (outp->dp.lttprs && outp->dp.lttpr[1])\n\t\t\t\trate_max = min_t(int, rate_max, outp->dp.lttpr[1]);\n\n\t\t\tif (!nvkm_dp_enable_supported_link_rates(outp)) {\n\t\t\t\tfor (rate = rates; *rate; rate++) {\n\t\t\t\t\tif (*rate > rate_max)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (WARN_ON(outp->dp.rates == ARRAY_SIZE(outp->dp.rate)))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\toutp->dp.rate[outp->dp.rates].dpcd = -1;\n\t\t\t\t\toutp->dp.rate[outp->dp.rates].rate = *rate * 27000;\n\t\t\t\t\toutp->dp.rates++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else\n\tif (!auxpwr && outp->dp.aux_pwr) {\n\t\tOUTP_DBG(outp, \"aux power -> demand\");\n\t\tnvkm_i2c_aux_monitor(aux, false);\n\t\toutp->dp.aux_pwr = false;\n\t\tatomic_set(&outp->dp.lt.done, 0);\n\n\t\t \n\t\tif (outp->conn->info.type == DCB_CONNECTOR_eDP) {\n\t\t\tif (outp->dp.aux_pwr_pu) {\n\t\t\t\tnvkm_gpio_set(gpio, 0, DCB_GPIO_PANEL_POWER, 0xff, 0);\n\t\t\t\toutp->dp.aux_pwr_pu = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nnvkm_dp_fini(struct nvkm_outp *outp)\n{\n\tnvkm_dp_enable(outp, false);\n}\n\nstatic void\nnvkm_dp_init(struct nvkm_outp *outp)\n{\n\tnvkm_dp_enable(outp, outp->dp.enabled);\n}\n\nstatic void *\nnvkm_dp_dtor(struct nvkm_outp *outp)\n{\n\treturn outp;\n}\n\nstatic const struct nvkm_outp_func\nnvkm_dp_func = {\n\t.dtor = nvkm_dp_dtor,\n\t.init = nvkm_dp_init,\n\t.fini = nvkm_dp_fini,\n\t.acquire = nvkm_dp_acquire,\n\t.release = nvkm_dp_release,\n\t.disable = nvkm_dp_disable,\n};\n\nint\nnvkm_dp_new(struct nvkm_disp *disp, int index, struct dcb_output *dcbE, struct nvkm_outp **poutp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvkm_i2c *i2c = device->i2c;\n\tstruct nvkm_outp *outp;\n\tu8  hdr, cnt, len;\n\tu32 data;\n\tint ret;\n\n\tret = nvkm_outp_new_(&nvkm_dp_func, disp, index, dcbE, poutp);\n\toutp = *poutp;\n\tif (ret)\n\t\treturn ret;\n\n\tif (dcbE->location == 0)\n\t\toutp->dp.aux = nvkm_i2c_aux_find(i2c, NVKM_I2C_AUX_CCB(dcbE->i2c_index));\n\telse\n\t\toutp->dp.aux = nvkm_i2c_aux_find(i2c, NVKM_I2C_AUX_EXT(dcbE->extdev));\n\tif (!outp->dp.aux) {\n\t\tOUTP_ERR(outp, \"no aux\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdata = nvbios_dpout_match(bios, outp->info.hasht, outp->info.hashm,\n\t\t\t\t  &outp->dp.version, &hdr, &cnt, &len, &outp->dp.info);\n\tif (!data) {\n\t\tOUTP_ERR(outp, \"no bios dp data\");\n\t\treturn -EINVAL;\n\t}\n\n\tOUTP_DBG(outp, \"bios dp %02x %02x %02x %02x\", outp->dp.version, hdr, cnt, len);\n\n\tmutex_init(&outp->dp.mutex);\n\tatomic_set(&outp->dp.lt.done, 0);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}