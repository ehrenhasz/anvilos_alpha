{
  "module_name": "gf100.c",
  "hash_id": "ccbaa18cd17df8d3a3aa4791d8bc3f1f424f81432ba136649f0ed2acc910c47b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/sw/gf100.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/bar.h>\n#include <engine/disp.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n#include <nvif/event.h>\n\n \n\nstatic int\ngf100_sw_chan_vblsem_release(struct nvkm_event_ntfy *notify, u32 bits)\n{\n\tstruct nv50_sw_chan *chan =\n\t\tcontainer_of(notify, typeof(*chan), vblank.notify[notify->id]);\n\tstruct nvkm_sw *sw = chan->base.sw;\n\tstruct nvkm_device *device = sw->engine.subdev.device;\n\tu32 inst = chan->base.fifo->inst->addr >> 12;\n\n\tnvkm_wr32(device, 0x001718, 0x80000000 | inst);\n\tnvkm_bar_flush(device->bar);\n\tnvkm_wr32(device, 0x06000c, upper_32_bits(chan->vblank.offset));\n\tnvkm_wr32(device, 0x060010, lower_32_bits(chan->vblank.offset));\n\tnvkm_wr32(device, 0x060014, chan->vblank.value);\n\n\treturn NVKM_EVENT_DROP;\n}\n\nstatic bool\ngf100_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)\n{\n\tstruct nv50_sw_chan *chan = nv50_sw_chan(base);\n\tstruct nvkm_engine *engine = chan->base.object.engine;\n\tstruct nvkm_device *device = engine->subdev.device;\n\tswitch (mthd) {\n\tcase 0x0400:\n\t\tchan->vblank.offset &= 0x00ffffffffULL;\n\t\tchan->vblank.offset |= (u64)data << 32;\n\t\treturn true;\n\tcase 0x0404:\n\t\tchan->vblank.offset &= 0xff00000000ULL;\n\t\tchan->vblank.offset |= data;\n\t\treturn true;\n\tcase 0x0408:\n\t\tchan->vblank.value = data;\n\t\treturn true;\n\tcase 0x040c:\n\t\tif (data < device->disp->vblank.index_nr) {\n\t\t\tnvkm_event_ntfy_allow(&chan->vblank.notify[data]);\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase 0x600:  \n\t\tnvkm_wr32(device, 0x419e00, data);\n\t\treturn true;\n\tcase 0x644:  \n\t\tif (!(data & ~0x001ffffe)) {\n\t\t\tnvkm_wr32(device, 0x419e44, data);\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\tcase 0x6ac:  \n\t\tnvkm_wr32(device, 0x419eac, data);\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const struct nvkm_sw_chan_func\ngf100_sw_chan = {\n\t.dtor = nv50_sw_chan_dtor,\n\t.mthd = gf100_sw_chan_mthd,\n};\n\nstatic int\ngf100_sw_chan_new(struct nvkm_sw *sw, struct nvkm_chan *fifoch,\n\t\t  const struct nvkm_oclass *oclass,\n\t\t  struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = sw->engine.subdev.device->disp;\n\tstruct nv50_sw_chan *chan;\n\tint ret, i;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &chan->base.object;\n\n\tret = nvkm_sw_chan_ctor(&gf100_sw_chan, sw, fifoch, oclass,\n\t\t\t\t&chan->base);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; disp && i < disp->vblank.index_nr; i++) {\n\t\tnvkm_event_ntfy_add(&disp->vblank, i, NVKM_DISP_HEAD_EVENT_VBLANK, true,\n\t\t\t\t    gf100_sw_chan_vblsem_release, &chan->vblank.notify[i]);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic const struct nvkm_sw_func\ngf100_sw = {\n\t.chan_new = gf100_sw_chan_new,\n\t.sclass = {\n\t\t{ nvkm_nvsw_new, { -1, -1, NVIF_CLASS_SW_GF100 } },\n\t\t{}\n\t}\n};\n\nint\ngf100_sw_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_sw **psw)\n{\n\treturn nvkm_sw_new_(&gf100_sw, device, type, inst, psw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}