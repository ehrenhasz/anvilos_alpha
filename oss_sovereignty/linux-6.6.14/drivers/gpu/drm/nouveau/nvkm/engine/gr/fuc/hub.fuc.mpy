{
  "module_name": "hub.fuc",
  "hash_id": "5b68e01db5f7ff771d3ed149875f551e7a389e0fed7cc06217afa0f0d4fc060b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/hub.fuc",
  "human_readable_source": "/* fuc microcode for gf100 PGRAPH/HUB\n *\n * Copyright 2011 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n#ifdef INCLUDE_DATA\nhub_mmio_list_head:\t.b32 #hub_mmio_list_base\nhub_mmio_list_tail:\t.b32 #hub_mmio_list_next\n\ngpc_count:\t\t.b32 0\nrop_count:\t\t.b32 0\ncmd_queue:\t\tqueue_init\n\nctx_current:\t\t.b32 0\n\n.align 256\nchan_data:\nchan_mmio_count:\t.b32 0\nchan_mmio_address:\t.b32 0\n\n.align 256\nxfer_data: \t\t.skip 256\n\nhub_mmio_list_base:\n.b32 0x0417e91c // 0x17e91c, 2\nhub_mmio_list_next:\n#endif\n\n#ifdef INCLUDE_CODE\n// reports an exception to the host\n//\n// In: $r15 error code (see os.h)\n//\nerror:\n\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(5), 0, $r15)\n\tmov $r15 1\n\tnv_iowr(NV_PGRAPH_FECS_INTR_UP_SET, 0, $r15)\n\tret\n\n// HUB fuc initialisation, executed by triggering ucode start, will\n// fall through to main loop after completion.\n//\n// Output:\n//   CC_SCRATCH[0]:\n//\t     31:31: set to signal completion\n//   CC_SCRATCH[1]:\n//\t      31:0: total PGRAPH context size\n//\ninit:\n\tclear b32 $r0\n\tmov $xdbase $r0\n\n\t// setup stack\n\tnv_iord($r1, NV_PGRAPH_FECS_CAPS, 0)\n\textr $r1 $r1 9:17\n\tshl b32 $r1 8\n\tmov $sp $r1\n\n\t// enable fifo access\n\tmov $r2 NV_PGRAPH_FECS_ACCESS_FIFO\n\tnv_iowr(NV_PGRAPH_FECS_ACCESS, 0, $r2)\n\n\t// setup i0 handler, and route all interrupts to it\n\tmov $r1 #ih\n\tmov $iv0 $r1\n\n\tclear b32 $r2\n\tnv_iowr(NV_PGRAPH_FECS_INTR_ROUTE, 0, $r2)\n\n\t// route HUB_CHSW_PULSE to fuc interrupt 8\n\tmov $r2 0x2003\t\t// { HUB_CHSW_PULSE, ZERO } -> intr 8\n\tnv_iowr(NV_PGRAPH_FECS_IROUTE, 0, $r2)\n\n\t// not sure what these are, route them because NVIDIA does, and\n\t// the IRQ handler will signal the host if we ever get one.. we\n\t// may find out if/why we need to handle these if so..\n\t//\n\tmov $r2 0x2004\t\t// { 0x04, ZERO } -> intr 9\n\tnv_iowr(NV_PGRAPH_FECS_IROUTE, 1, $r2)\n\tmov $r2 0x200b\t\t// { HUB_FIRMWARE_MTHD, ZERO } -> intr 10\n\tnv_iowr(NV_PGRAPH_FECS_IROUTE, 2, $r2)\n\tmov $r2 0x200c\t\t// { 0x0c, ZERO } -> intr 15\n\tnv_iowr(NV_PGRAPH_FECS_IROUTE, 7, $r2)\n\n\t// enable all INTR_UP interrupts\n\tsub b32 $r3 $r0 1\n\tnv_iowr(NV_PGRAPH_FECS_INTR_UP_EN, 0, $r3)\n\n\t// enable fifo, ctxsw, 9, fwmthd, 15 interrupts\n\timm32($r2, 0x8704)\n\tnv_iowr(NV_PGRAPH_FECS_INTR_EN_SET, 0, $r2)\n\n\t// fifo level triggered, rest edge\n\tmov $r2 NV_PGRAPH_FECS_INTR_MODE_FIFO_LEVEL\n\tnv_iowr(NV_PGRAPH_FECS_INTR_MODE, 0, $r2)\n\n\t// enable interrupts\n\tbset $flags ie0\n\n\t// fetch enabled GPC/ROP counts\n\tnv_rd32($r14, 0x409604)\n\textr $r1 $r15 16:20\n\tst b32 D[$r0 + #rop_count] $r1\n\tand $r15 0x1f\n\tst b32 D[$r0 + #gpc_count] $r15\n\n\t// set BAR_REQMASK to GPC mask\n\tmov $r1 1\n\tshl b32 $r1 $r15\n\tsub b32 $r1 1\n\tnv_iowr(NV_PGRAPH_FECS_BAR_MASK0, 0, $r1)\n\tnv_iowr(NV_PGRAPH_FECS_BAR_MASK1, 0, $r1)\n\n\t// context size calculation, reserve first 256 bytes for use by fuc\n\tmov $r1 256\n\n\t//\n\tmov $r15 2\n\tcall(ctx_4170s)\n\tcall(ctx_4170w)\n\tmov $r15 0x10\n\tcall(ctx_86c)\n\n\t// calculate size of mmio context data\n\tld b32 $r14 D[$r0 + #hub_mmio_list_head]\n\tld b32 $r15 D[$r0 + #hub_mmio_list_tail]\n\tcall(mmctx_size)\n\n\t// set mmctx base addresses now so we don't have to do it later,\n\t// they don't (currently) ever change\n\tshr b32 $r4 $r1 8\n\tnv_iowr(NV_PGRAPH_FECS_MMCTX_SAVE_SWBASE, 0, $r4)\n\tnv_iowr(NV_PGRAPH_FECS_MMCTX_LOAD_SWBASE, 0, $r4)\n\tadd b32 $r3 0x1300\n\tadd b32 $r1 $r15\n\tshr b32 $r15 2\n\tnv_iowr(NV_PGRAPH_FECS_MMCTX_LOAD_COUNT, 0, $r15) // wtf??\n\n\t// strands, base offset needs to be aligned to 256 bytes\n\tshr b32 $r1 8\n\tadd b32 $r1 1\n\tshl b32 $r1 8\n\tmov b32 $r15 $r1\n\tcall(strand_ctx_init)\n\tadd b32 $r1 $r15\n\n\t// initialise each GPC in sequence by passing in the offset of its\n\t// context data in GPCn_CC_SCRATCH[1], and starting its FUC (which\n\t// has previously been uploaded by the host) running.\n\t//\n\t// the GPC fuc init sequence will set GPCn_CC_SCRATCH[0] bit 31\n\t// when it has completed, and return the size of its context data\n\t// in GPCn_CC_SCRATCH[1]\n\t//\n\tld b32 $r3 D[$r0 + #gpc_count]\n\timm32($r4, 0x502000)\n\tinit_gpc:\n\t\t// setup, and start GPC ucode running\n\t\tadd b32 $r14 $r4 0x804\n\t\tmov b32 $r15 $r1\n\t\tcall(nv_wr32)\t\t\t// CC_SCRATCH[1] = ctx offset\n\t\tadd b32 $r14 $r4 0x10c\n\t\tclear b32 $r15\n\t\tcall(nv_wr32)\n\t\tadd b32 $r14 $r4 0x104\n\t\tcall(nv_wr32)\t\t\t// ENTRY\n\t\tadd b32 $r14 $r4 0x100\n\t\tmov $r15 2\t\t\t// CTRL_START_TRIGGER\n\t\tcall(nv_wr32)\t\t\t// CTRL\n\n\t\t// wait for it to complete, and adjust context size\n\t\tadd b32 $r14 $r4 0x800\n\t\tinit_gpc_wait:\n\t\t\tcall(nv_rd32)\n\t\t\txbit $r15 $r15 31\n\t\t\tbra e #init_gpc_wait\n\t\tadd b32 $r14 $r4 0x804\n\t\tcall(nv_rd32)\n\t\tadd b32 $r1 $r15\n\n\t\t// next!\n\t\tadd b32 $r4 0x8000\n\t\tsub b32 $r3 1\n\t\tbra ne #init_gpc\n\n\t//\n\tmov $r15 0\n\tcall(ctx_86c)\n\tmov $r15 0\n\tcall(ctx_4170s)\n\n\t// save context size, and tell host we're ready\n\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(1), 0, $r1)\n\tclear b32 $r1\n\tbset $r1 31\n\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_SET(0), 0, $r1)\n\n// Main program loop, very simple, sleeps until woken up by the interrupt\n// handler, pulls a command from the queue and executes its handler\n//\nwait:\n\t// sleep until we have something to do\n\tsleep $p0\n\tbset $flags $p0\nmain:\n\tmov $r13 #cmd_queue\n\tcall(queue_get)\n\tbra $p1 #wait\n\n\t// context switch, requested by GPU?\n\tcmpu b32 $r14 0x4001\n\tbra ne #main_not_ctx_switch\n\t\ttrace_set(T_AUTO)\n\t\tnv_iord($r1, NV_PGRAPH_FECS_CHAN_ADDR, 0)\n\t\tnv_iord($r2, NV_PGRAPH_FECS_CHAN_NEXT, 0)\n\n\t\txbit $r3 $r1 31\n\t\tbra e #chsw_no_prev\n\t\t\txbit $r3 $r2 31\n\t\t\tbra e #chsw_prev_no_next\n\t\t\t\tpush $r2\n\t\t\t\tmov b32 $r2 $r1\n\t\t\t\ttrace_set(T_SAVE)\n\t\t\t\tbclr $flags $p1\n\t\t\t\tbset $flags $p2\n\t\t\t\tcall(ctx_xfer)\n\t\t\t\ttrace_clr(T_SAVE);\n\t\t\t\tpop $r2\n\t\t\t\ttrace_set(T_LOAD);\n\t\t\t\tbset $flags $p1\n\t\t\t\tcall(ctx_xfer)\n\t\t\t\ttrace_clr(T_LOAD);\n\t\t\t\tbra #chsw_done\n\t\t\tchsw_prev_no_next:\n\t\t\t\tpush $r2\n\t\t\t\tmov b32 $r2 $r1\n\t\t\t\tbclr $flags $p1\n\t\t\t\tbclr $flags $p2\n\t\t\t\tcall(ctx_xfer)\n\t\t\t\tpop $r2\n\t\t\t\tnv_iowr(NV_PGRAPH_FECS_CHAN_ADDR, 0, $r2)\n\t\t\t\tbra #chsw_done\n\t\tchsw_no_prev:\n\t\t\txbit $r3 $r2 31\n\t\t\tbra e #chsw_done\n\t\t\t\tbset $flags $p1\n\t\t\t\tbclr $flags $p2\n\t\t\t\tcall(ctx_xfer)\n\n\t\t// ack the context switch request\n\t\tchsw_done:\n\t\tmov $r2 NV_PGRAPH_FECS_CHSW_ACK\n\t\tnv_iowr(NV_PGRAPH_FECS_CHSW, 0, $r2)\n\t\ttrace_clr(T_AUTO)\n\t\tbra #main\n\n\t// request to set current channel? (*not* a context switch)\n\tmain_not_ctx_switch:\n\tcmpu b32 $r14 0x0001\n\tbra ne #main_not_ctx_chan\n\t\tmov b32 $r2 $r15\n\t\tcall(ctx_chan)\n\t\tbra #main_done\n\n\t// request to store current channel context?\n\tmain_not_ctx_chan:\n\tcmpu b32 $r14 0x0002\n\tbra ne #main_not_ctx_save\n\t\ttrace_set(T_SAVE)\n\t\tbclr $flags $p1\n\t\tbclr $flags $p2\n\t\tcall(ctx_xfer)\n\t\ttrace_clr(T_SAVE)\n\t\tbra #main_done\n\n\tmain_not_ctx_save:\n\t\tshl b32 $r15 $r14 16\n\t\tor $r15 E_BAD_COMMAND\n\t\tcall(error)\n\t\tbra #main\n\n\tmain_done:\n\tclear b32 $r2\n\tbset $r2 31\n\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_SET(0), 0, $r2)\n\tbra #main\n\n// interrupt handler\nih:\n\tpush $r0\n\tpush $r8\n\tmov $r8 $flags\n\tpush $r8\n\tpush $r9\n\tpush $r10\n\tpush $r11\n\tpush $r13\n\tpush $r14\n\tpush $r15\n\tclear b32 $r0\n\n\t// incoming fifo command?\n\tnv_iord($r10, NV_PGRAPH_FECS_INTR, 0)\n\tand $r11 $r10 NV_PGRAPH_FECS_INTR_FIFO\n\tbra e #ih_no_fifo\n\t\t// queue incoming fifo command for later processing\n\t\tmov $r13 #cmd_queue\n\t\tnv_iord($r14, NV_PGRAPH_FECS_FIFO_CMD, 0)\n\t\tnv_iord($r15, NV_PGRAPH_FECS_FIFO_DATA, 0)\n\t\tcall(queue_put)\n\t\tadd b32 $r11 0x400\n\t\tmov $r14 1\n\t\tnv_iowr(NV_PGRAPH_FECS_FIFO_ACK, 0, $r14)\n\n\t// context switch request?\n\tih_no_fifo:\n\tand $r11 $r10 NV_PGRAPH_FECS_INTR_CHSW\n\tbra e #ih_no_ctxsw\n\t\t// enqueue a context switch for later processing\n\t\tmov $r13 #cmd_queue\n\t\tmov $r14 0x4001\n\t\tcall(queue_put)\n\n\t// firmware method?\n\tih_no_ctxsw:\n\tand $r11 $r10 NV_PGRAPH_FECS_INTR_FWMTHD\n\tbra e #ih_no_fwmthd\n\t\t// none we handle; report to host and ack\n\t\tnv_rd32($r15, NV_PGRAPH_TRAPPED_DATA_LO)\n\t\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(4), 0, $r15)\n\t\tnv_rd32($r15, NV_PGRAPH_TRAPPED_ADDR)\n\t\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(3), 0, $r15)\n\t\textr $r14 $r15 16:18\n\t\tshl b32 $r14 $r14 2\n\t\timm32($r15, NV_PGRAPH_FE_OBJECT_TABLE(0))\n\t\tadd b32 $r14 $r15\n\t\tcall(nv_rd32)\n\t\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(2), 0, $r15)\n\t\tmov $r15 E_BAD_FWMTHD\n\t\tcall(error)\n\t\tmov $r11 0x100\n\t\tnv_wr32(0x400144, $r11)\n\n\t// anything we didn't handle, bring it to the host's attention\n\tih_no_fwmthd:\n\tmov $r11 0x504 // FIFO | CHSW | FWMTHD\n\tnot b32 $r11\n\tand $r11 $r10 $r11\n\tbra e #ih_no_other\n\t\tnv_iowr(NV_PGRAPH_FECS_INTR_UP_SET, 0, $r11)\n\n\t// ack, and wake up main()\n\tih_no_other:\n\tnv_iowr(NV_PGRAPH_FECS_INTR_ACK, 0, $r10)\n\n\tpop $r15\n\tpop $r14\n\tpop $r13\n\tpop $r11\n\tpop $r10\n\tpop $r9\n\tpop $r8\n\tmov $flags $r8\n\tpop $r8\n\tpop $r0\n\tbclr $flags $p0\n\tiret\n\n#if CHIPSET < GK100\n// Not real sure, but, MEM_CMD 7 will hang forever if this isn't done\nctx_4160s:\n\tmov $r15 1\n\tnv_wr32(0x404160, $r15)\n\tctx_4160s_wait:\n\t\tnv_rd32($r15, 0x404160)\n\t\txbit $r15 $r15 4\n\t\tbra e #ctx_4160s_wait\n\tret\n\n// Without clearing again at end of xfer, some things cause PGRAPH\n// to hang with STATUS=0x00000007 until it's cleared.. fbcon can\n// still function with it set however...\nctx_4160c:\n\tclear b32 $r15\n\tnv_wr32(0x404160, $r15)\n\tret\n#endif\n\n// Again, not real sure\n//\n// In: $r15 value to set 0x404170 to\n//\nctx_4170s:\n\tor $r15 0x10\n\tnv_wr32(0x404170, $r15)\n\tret\n\n// Waits for a ctx_4170s() call to complete\n//\nctx_4170w:\n\tnv_rd32($r15, 0x404170)\n\tand $r15 0x10\n\tbra ne #ctx_4170w\n\tret\n\n// Disables various things, waits a bit, and re-enables them..\n//\n// Not sure how exactly this helps, perhaps \"ENABLE\" is not such a\n// good description for the bits we turn off?  Anyways, without this,\n// funny things happen.\n//\nctx_redswitch:\n\tmov $r14 NV_PGRAPH_FECS_RED_SWITCH_ENABLE_GPC\n\tor  $r14 NV_PGRAPH_FECS_RED_SWITCH_POWER_ROP\n\tor  $r14 NV_PGRAPH_FECS_RED_SWITCH_POWER_GPC\n\tor  $r14 NV_PGRAPH_FECS_RED_SWITCH_POWER_MAIN\n\tnv_iowr(NV_PGRAPH_FECS_RED_SWITCH, 0, $r14)\n\tmov $r15 8\n\tctx_redswitch_delay:\n\t\tsub b32 $r15 1\n\t\tbra ne #ctx_redswitch_delay\n\tor  $r14 NV_PGRAPH_FECS_RED_SWITCH_ENABLE_ROP\n\tor  $r14 NV_PGRAPH_FECS_RED_SWITCH_ENABLE_MAIN\n\tnv_iowr(NV_PGRAPH_FECS_RED_SWITCH, 0, $r14)\n\tret\n\n// Not a clue what this is for, except that unless the value is 0x10, the\n// strand context is saved (and presumably restored) incorrectly..\n//\n// In: $r15 value to set to (0x00/0x10 are used)\n//\nctx_86c:\n\tnv_iowr(NV_PGRAPH_FECS_UNK86C, 0, $r15)\n\tnv_wr32(0x408a14, $r15)\n\tnv_wr32(NV_PGRAPH_GPCX_GPCCS_UNK86C, $r15)\n\tret\n\n// In: $r15 NV_PGRAPH_FECS_MEM_CMD_*\nctx_mem:\n\tnv_iowr(NV_PGRAPH_FECS_MEM_CMD, 0, $r15)\n\tctx_mem_wait:\n\t\tnv_iord($r15, NV_PGRAPH_FECS_MEM_CMD, 0)\n\t\tor $r15 $r15\n\t\tbra ne #ctx_mem_wait\n\tret\n\n// ctx_load - load's a channel's ctxctl data, and selects its vm\n//\n// In: $r2 channel address\n//\nctx_load:\n\ttrace_set(T_CHAN)\n\n\t// switch to channel, somewhat magic in parts..\n\tmov $r10 12\t\t// DONE_UNK12\n\tcall(wait_donez)\n\tclear b32 $r15\n\tnv_iowr(0x409a24, 0, $r15)\n\tnv_iowr(NV_PGRAPH_FECS_CHAN_NEXT, 0, $r2)\n\tnv_iowr(NV_PGRAPH_FECS_MEM_CHAN, 0, $r2)\n\tmov $r15 NV_PGRAPH_FECS_MEM_CMD_LOAD_CHAN\n\tcall(ctx_mem)\n\tnv_iowr(NV_PGRAPH_FECS_CHAN_ADDR, 0, $r2)\n\n\t// load channel header, fetch PGRAPH context pointer\n\tmov $xtargets $r0\n\tbclr $r2 31\n\tshl b32 $r2 4\n\tadd b32 $r2 2\n\n\ttrace_set(T_LCHAN)\n\tnv_iowr(NV_PGRAPH_FECS_MEM_BASE, 0, $r2)\n\timm32($r2, NV_PGRAPH_FECS_MEM_TARGET_UNK31)\n\tor  $r2 NV_PGRAPH_FECS_MEM_TARGET_AS_VRAM\n\tnv_iowr(NV_PGRAPH_FECS_MEM_TARGET, 0, $r2)\n\tmov $r1 0x10\t\t\t// chan + 0x0210\n\tmov $r2 #xfer_data\n\tsethi $r2 0x00020000\t\t// 16 bytes\n\txdld $r1 $r2\n\txdwait\n\ttrace_clr(T_LCHAN)\n\n\t// update current context\n\tld b32 $r1 D[$r0 + #xfer_data + 4]\n\tshl b32 $r1 24\n\tld b32 $r2 D[$r0 + #xfer_data + 0]\n\tshr b32 $r2 8\n\tor $r1 $r2\n\tst b32 D[$r0 + #ctx_current] $r1\n\n\t// set transfer base to start of context, and fetch context header\n\ttrace_set(T_LCTXH)\n\tnv_iowr(NV_PGRAPH_FECS_MEM_BASE, 0, $r1)\n\tmov $r2 NV_PGRAPH_FECS_MEM_TARGET_AS_VM\n\tnv_iowr(NV_PGRAPH_FECS_MEM_TARGET, 0, $r2)\n\tmov $r1 #chan_data\n\tsethi $r1 0x00060000\t\t// 256 bytes\n\txdld $r0 $r1\n\txdwait\n\ttrace_clr(T_LCTXH)\n\n\ttrace_clr(T_CHAN)\n\tret\n\n// ctx_chan - handler for HUB_SET_CHAN command, will set a channel as\n//            the active channel for ctxctl, but not actually transfer\n//            any context data.  intended for use only during initial\n//            context construction.\n//\n// In: $r2 channel address\n//\nctx_chan:\n#if CHIPSET < GK100\n\tcall(ctx_4160s)\n#endif\n\tcall(ctx_load)\n\tmov $r10 12\t\t\t// DONE_UNK12\n\tcall(wait_donez)\n\tmov $r15 5 // MEM_CMD 5 ???\n\tcall(ctx_mem)\n#if CHIPSET < GK100\n\tcall(ctx_4160c)\n#endif\n\tret\n\n// Execute per-context state overrides list\n//\n// Only executed on the first load of a channel.  Might want to look into\n// removing this and having the host directly modify the channel's context\n// to change this state...  The nouveau DRM already builds this list as\n// it's definitely needed for NVIDIA's, so we may as well use it for now\n//\n// Input: $r1 mmio list length\n//\nctx_mmio_exec:\n\t// set transfer base to be the mmio list\n\tld b32 $r3 D[$r0 + #chan_mmio_address]\n\tnv_iowr(NV_PGRAPH_FECS_MEM_BASE, 0, $r3)\n\n\tclear b32 $r3\n\tctx_mmio_loop:\n\t\t// fetch next 256 bytes of mmio list if necessary\n\t\tand $r4 $r3 0xff\n\t\tbra ne #ctx_mmio_pull\n\t\t\tmov $r5 #xfer_data\n\t\t\tsethi $r5 0x00060000\t// 256 bytes\n\t\t\txdld $r3 $r5\n\t\t\txdwait\n\n\t\t// execute a single list entry\n\t\tctx_mmio_pull:\n\t\tld b32 $r14 D[$r4 + #xfer_data + 0x00]\n\t\tld b32 $r15 D[$r4 + #xfer_data + 0x04]\n\t\tcall(nv_wr32)\n\n\t\t// next!\n\t\tadd b32 $r3 8\n\t\tsub b32 $r1 1\n\t\tbra ne #ctx_mmio_loop\n\n\t// set transfer base back to the current context\n\tctx_mmio_done:\n\tld b32 $r3 D[$r0 + #ctx_current]\n\tnv_iowr(NV_PGRAPH_FECS_MEM_BASE, 0, $r3)\n\n\t// disable the mmio list now, we don't need/want to execute it again\n\tst b32 D[$r0 + #chan_mmio_count] $r0\n\tmov $r1 #chan_data\n\tsethi $r1 0x00060000\t\t// 256 bytes\n\txdst $r0 $r1\n\txdwait\n\tret\n\n// Transfer HUB context data between GPU and storage area\n//\n// In: $r2 channel address\n//     $p1 clear on save, set on load\n//     $p2 set if opposite direction done/will be done, so:\n//\t\ton save it means: \"a load will follow this save\"\n//\t\ton load it means: \"a save preceeded this load\"\n//\nctx_xfer:\n\t// according to mwk, some kind of wait for idle\n\tmov $r14 4\n\tnv_iowr(0x409c08, 0, $r14)\n\tctx_xfer_idle:\n\t\tnv_iord($r14, 0x409c00, 0)\n\t\tand $r14 0x2000\n\t\tbra ne #ctx_xfer_idle\n\n\tbra not $p1 #ctx_xfer_pre\n\tbra $p2 #ctx_xfer_pre_load\n\tctx_xfer_pre:\n\t\tmov $r15 0x10\n\t\tcall(ctx_86c)\n#if CHIPSET < GK100\n\t\tcall(ctx_4160s)\n#endif\n\t\tbra not $p1 #ctx_xfer_exec\n\n\tctx_xfer_pre_load:\n\t\tmov $r15 2\n\t\tcall(ctx_4170s)\n\t\tcall(ctx_4170w)\n\t\tcall(ctx_redswitch)\n\t\tclear b32 $r15\n\t\tcall(ctx_4170s)\n\t\tcall(ctx_load)\n\n\t// fetch context pointer, and initiate xfer on all GPCs\n\tctx_xfer_exec:\n\tld b32 $r1 D[$r0 + #ctx_current]\n\n\tclear b32 $r2\n\tnv_iowr(NV_PGRAPH_FECS_BAR, 0, $r2)\n\n\tnv_wr32(0x41a500, $r1)\t// GPC_BCAST_WRCMD_DATA = ctx pointer\n\txbit $r15 $flags $p1\n\txbit $r2 $flags $p2\n\tshl b32 $r2 1\n\tor $r15 $r2\n\tnv_wr32(0x41a504, $r15)\t// GPC_BCAST_WRCMD_CMD = GPC_XFER(type)\n\n\t// strands\n\tcall(strand_pre)\n\tclear b32 $r2\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_SELECT, 0x3f, $r2)\n\txbit $r2 $flags $p1\t// SAVE/LOAD\n\tadd b32 $r2 NV_PGRAPH_FECS_STRAND_CMD_SAVE\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r2)\n\n\t// mmio context\n\txbit $r10 $flags $p1\t// direction\n\tor $r10 6\t\t// first, last\n\tmov $r11 0\t\t// base = 0\n\tld b32 $r12 D[$r0 + #hub_mmio_list_head]\n\tld b32 $r13 D[$r0 + #hub_mmio_list_tail]\n\tmov $r14 0\t\t// not multi\n\tcall(mmctx_xfer)\n\n\t// wait for GPCs to all complete\n\tmov $r10 8\t\t// DONE_BAR\n\tcall(wait_doneo)\n\n\t// wait for strand xfer to complete\n\tcall(strand_wait)\n\n\t// post-op\n\tbra $p1 #ctx_xfer_post\n\t\tmov $r10 12\t\t// DONE_UNK12\n\t\tcall(wait_donez)\n\t\tmov $r15 5 // MEM_CMD 5 ???\n\t\tcall(ctx_mem)\n\n\tbra $p2 #ctx_xfer_done\n\tctx_xfer_post:\n\t\tmov $r15 2\n\t\tcall(ctx_4170s)\n\t\tclear b32 $r15\n\t\tcall(ctx_86c)\n\t\tcall(strand_post)\n\t\tcall(ctx_4170w)\n\t\tclear b32 $r15\n\t\tcall(ctx_4170s)\n\n\t\tbra not $p1 #ctx_xfer_no_post_mmio\n\t\tld b32 $r1 D[$r0 + #chan_mmio_count]\n\t\tor $r1 $r1\n\t\tbra e #ctx_xfer_no_post_mmio\n\t\t\tcall(ctx_mmio_exec)\n\n\t\tctx_xfer_no_post_mmio:\n#if CHIPSET < GK100\n\t\tcall(ctx_4160c)\n#endif\n\n\tctx_xfer_done:\n\tret\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}