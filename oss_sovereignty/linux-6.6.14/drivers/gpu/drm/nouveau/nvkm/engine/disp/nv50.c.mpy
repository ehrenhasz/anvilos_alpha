{
  "module_name": "nv50.c",
  "hash_id": "8c0835df8875a1337dabfd33bf254034fdb7d39de673649d59bd3bbbe1a58bd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"head.h\"\n#include \"ior.h\"\n#include \"outp.h\"\n\n#include <core/client.h>\n#include <core/ramht.h>\n#include <subdev/bios.h>\n#include <subdev/bios/disp.h>\n#include <subdev/bios/init.h>\n#include <subdev/bios/pll.h>\n#include <subdev/devinit.h>\n#include <subdev/i2c.h>\n#include <subdev/mmu.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n#include <nvif/unpack.h>\n\nstatic void\nnv50_pior_clock(struct nvkm_ior *pior)\n{\n\tstruct nvkm_device *device = pior->disp->engine.subdev.device;\n\tconst u32 poff = nv50_ior_base(pior);\n\n\tnvkm_mask(device, 0x614380 + poff, 0x00000707, 0x00000001);\n}\n\nstatic int\nnv50_pior_dp_links(struct nvkm_ior *pior, struct nvkm_i2c_aux *aux)\n{\n\tint ret = nvkm_i2c_aux_lnk_ctl(aux, pior->dp.nr, pior->dp.bw, pior->dp.ef);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 1;\n}\n\nstatic const struct nvkm_ior_func_dp\nnv50_pior_dp = {\n\t.links = nv50_pior_dp_links,\n};\n\nstatic void\nnv50_pior_power_wait(struct nvkm_device *device, u32 poff)\n{\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x61e004 + poff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nstatic void\nnv50_pior_power(struct nvkm_ior *pior, bool normal, bool pu, bool data, bool vsync, bool hsync)\n{\n\tstruct nvkm_device *device = pior->disp->engine.subdev.device;\n\tconst u32  poff = nv50_ior_base(pior);\n\tconst u32 shift = normal ? 0 : 16;\n\tconst u32 state = 0x80000000 | (0x00000001 * !!pu) << shift;\n\tconst u32 field = 0x80000000 | (0x00000101 << shift);\n\n\tnv50_pior_power_wait(device, poff);\n\tnvkm_mask(device, 0x61e004 + poff, field, state);\n\tnv50_pior_power_wait(device, poff);\n}\n\nvoid\nnv50_pior_depth(struct nvkm_ior *ior, struct nvkm_ior_state *state, u32 ctrl)\n{\n\t \n\tif (state->head && state == &ior->asy) {\n\t\tstruct nvkm_head *head = nvkm_head_find(ior->disp, __ffs(state->head));\n\n\t\tif (!WARN_ON(!head)) {\n\t\t\tstruct nvkm_head_state *state = &head->asy;\n\t\t\tswitch ((ctrl & 0x000f0000) >> 16) {\n\t\t\tcase 6: state->or.depth = 30; break;\n\t\t\tcase 5: state->or.depth = 24; break;\n\t\t\tcase 2: state->or.depth = 18; break;\n\t\t\tcase 0: state->or.depth = 18; break;  \n\t\t\tdefault:\n\t\t\t\tstate->or.depth = 18;\n\t\t\t\tWARN_ON(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nnv50_pior_state(struct nvkm_ior *pior, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = pior->disp->engine.subdev.device;\n\tconst u32 coff = pior->id * 8 + (state == &pior->arm) * 4;\n\tu32 ctrl = nvkm_rd32(device, 0x610b80 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tstate->rgdiv = 1;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = TMDS; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x00000003;\n\tnv50_pior_depth(pior, state, ctrl);\n}\n\nstatic const struct nvkm_ior_func\nnv50_pior = {\n\t.state = nv50_pior_state,\n\t.power = nv50_pior_power,\n\t.clock = nv50_pior_clock,\n\t.dp = &nv50_pior_dp,\n};\n\nint\nnv50_pior_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&nv50_pior, disp, PIOR, id, false);\n}\n\nint\nnv50_pior_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = (nvkm_rd32(device, 0x610184) & 0x70000000) >> 28;\n\treturn 3;\n}\n\nvoid\nnv50_sor_clock(struct nvkm_ior *sor)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst int  div = sor->asy.link == 3;\n\tconst u32 soff = nv50_ior_base(sor);\n\n\tnvkm_mask(device, 0x614300 + soff, 0x00000707, (div << 8) | div);\n}\n\nstatic void\nnv50_sor_power_wait(struct nvkm_device *device, u32 soff)\n{\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x61c004 + soff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nvoid\nnv50_sor_power(struct nvkm_ior *sor, bool normal, bool pu, bool data, bool vsync, bool hsync)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32  soff = nv50_ior_base(sor);\n\tconst u32 shift = normal ? 0 : 16;\n\tconst u32 state = 0x80000000 | (0x00000001 * !!pu) << shift;\n\tconst u32 field = 0x80000000 | (0x00000001 << shift);\n\n\tnv50_sor_power_wait(device, soff);\n\tnvkm_mask(device, 0x61c004 + soff, field, state);\n\tnv50_sor_power_wait(device, soff);\n\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x61c030 + soff) & 0x10000000))\n\t\t\tbreak;\n\t);\n}\n\nvoid\nnv50_sor_state(struct nvkm_ior *sor, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 coff = sor->id * 8 + (state == &sor->arm) * 4;\n\tu32 ctrl = nvkm_rd32(device, 0x610b70 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = LVDS; state->link = 1; break;\n\tcase 1: state->proto = TMDS; state->link = 1; break;\n\tcase 2: state->proto = TMDS; state->link = 2; break;\n\tcase 5: state->proto = TMDS; state->link = 3; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x00000003;\n}\n\nstatic const struct nvkm_ior_func\nnv50_sor = {\n\t.state = nv50_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = nv50_sor_clock,\n};\n\nstatic int\nnv50_sor_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&nv50_sor, disp, SOR, id, false);\n}\n\nint\nnv50_sor_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = (nvkm_rd32(device, 0x610184) & 0x03000000) >> 24;\n\treturn 2;\n}\n\nstatic void\nnv50_dac_clock(struct nvkm_ior *dac)\n{\n\tstruct nvkm_device *device = dac->disp->engine.subdev.device;\n\tconst u32 doff = nv50_ior_base(dac);\n\n\tnvkm_mask(device, 0x614280 + doff, 0x07070707, 0x00000000);\n}\n\nint\nnv50_dac_sense(struct nvkm_ior *dac, u32 loadval)\n{\n\tstruct nvkm_device *device = dac->disp->engine.subdev.device;\n\tconst u32 doff = nv50_ior_base(dac);\n\n\tdac->func->power(dac, false, true, false, false, false);\n\n\tnvkm_wr32(device, 0x61a00c + doff, 0x00100000 | loadval);\n\tmdelay(9);\n\tudelay(500);\n\tloadval = nvkm_mask(device, 0x61a00c + doff, 0xffffffff, 0x00000000);\n\n\tdac->func->power(dac, false, false, false, false, false);\n\tif (!(loadval & 0x80000000))\n\t\treturn -ETIMEDOUT;\n\n\treturn (loadval & 0x38000000) >> 27;\n}\n\nstatic void\nnv50_dac_power_wait(struct nvkm_device *device, const u32 doff)\n{\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x61a004 + doff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nvoid\nnv50_dac_power(struct nvkm_ior *dac, bool normal, bool pu, bool data, bool vsync, bool hsync)\n{\n\tstruct nvkm_device *device = dac->disp->engine.subdev.device;\n\tconst u32  doff = nv50_ior_base(dac);\n\tconst u32 shift = normal ? 0 : 16;\n\tconst u32 state = 0x80000000 | (0x00000040 * !    pu |\n\t\t\t\t\t0x00000010 * !  data |\n\t\t\t\t\t0x00000004 * ! vsync |\n\t\t\t\t\t0x00000001 * ! hsync) << shift;\n\tconst u32 field = 0xc0000000 | (0x00000055 << shift);\n\n\tnv50_dac_power_wait(device, doff);\n\tnvkm_mask(device, 0x61a004 + doff, field, state);\n\tnv50_dac_power_wait(device, doff);\n}\n\nstatic void\nnv50_dac_state(struct nvkm_ior *dac, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = dac->disp->engine.subdev.device;\n\tconst u32 coff = dac->id * 8 + (state == &dac->arm) * 4;\n\tu32 ctrl = nvkm_rd32(device, 0x610b58 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = CRT; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x00000003;\n}\n\nstatic const struct nvkm_ior_func\nnv50_dac = {\n\t.state = nv50_dac_state,\n\t.power = nv50_dac_power,\n\t.sense = nv50_dac_sense,\n\t.clock = nv50_dac_clock,\n};\n\nint\nnv50_dac_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&nv50_dac, disp, DAC, id, false);\n}\n\nint\nnv50_dac_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = (nvkm_rd32(device, 0x610184) & 0x00700000) >> 20;\n\treturn 3;\n}\n\nstatic void\nnv50_head_vblank_put(struct nvkm_head *head)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\n\tnvkm_mask(device, 0x61002c, (4 << head->id), 0);\n}\n\nstatic void\nnv50_head_vblank_get(struct nvkm_head *head)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\n\tnvkm_mask(device, 0x61002c, (4 << head->id), (4 << head->id));\n}\n\nstatic void\nnv50_head_rgclk(struct nvkm_head *head, int div)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\n\tnvkm_mask(device, 0x614200 + (head->id * 0x800), 0x0000000f, div);\n}\n\nvoid\nnv50_head_rgpos(struct nvkm_head *head, u16 *hline, u16 *vline)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = head->id * 0x800;\n\n\t \n\t*vline = nvkm_rd32(device, 0x616340 + hoff) & 0x0000ffff;\n\t*hline = nvkm_rd32(device, 0x616344 + hoff) & 0x0000ffff;\n}\n\nstatic void\nnv50_head_state(struct nvkm_head *head, struct nvkm_head_state *state)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = head->id * 0x540 + (state == &head->arm) * 4;\n\tu32 data;\n\n\tdata = nvkm_rd32(device, 0x610ae8 + hoff);\n\tstate->vblanke = (data & 0xffff0000) >> 16;\n\tstate->hblanke = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x610af0 + hoff);\n\tstate->vblanks = (data & 0xffff0000) >> 16;\n\tstate->hblanks = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x610af8 + hoff);\n\tstate->vtotal = (data & 0xffff0000) >> 16;\n\tstate->htotal = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x610b00 + hoff);\n\tstate->vsynce = (data & 0xffff0000) >> 16;\n\tstate->hsynce = (data & 0x0000ffff);\n\tstate->hz = (nvkm_rd32(device, 0x610ad0 + hoff) & 0x003fffff) * 1000;\n}\n\nstatic const struct nvkm_head_func\nnv50_head = {\n\t.state = nv50_head_state,\n\t.rgpos = nv50_head_rgpos,\n\t.rgclk = nv50_head_rgclk,\n\t.vblank_get = nv50_head_vblank_get,\n\t.vblank_put = nv50_head_vblank_put,\n};\n\nint\nnv50_head_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_head_new_(&nv50_head, disp, id);\n}\n\nint\nnv50_head_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\t*pmask = 3;\n\treturn 2;\n}\n\n\nstatic void\nnv50_disp_mthd_list(struct nvkm_disp *disp, int debug, u32 base, int c,\n\t\t    const struct nvkm_disp_mthd_list *list, int inst)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint i;\n\n\tfor (i = 0; list->data[i].mthd; i++) {\n\t\tif (list->data[i].addr) {\n\t\t\tu32 next = nvkm_rd32(device, list->data[i].addr + base + 0);\n\t\t\tu32 prev = nvkm_rd32(device, list->data[i].addr + base + c);\n\t\t\tu32 mthd = list->data[i].mthd + (list->mthd * inst);\n\t\t\tconst char *name = list->data[i].name;\n\t\t\tchar mods[16];\n\n\t\t\tif (prev != next)\n\t\t\t\tsnprintf(mods, sizeof(mods), \"-> %08x\", next);\n\t\t\telse\n\t\t\t\tsnprintf(mods, sizeof(mods), \"%13c\", ' ');\n\n\t\t\tnvkm_printk_(subdev, debug, info,\n\t\t\t\t     \"\\t%04x: %08x %s%s%s\\n\",\n\t\t\t\t     mthd, prev, mods, name ? \" // \" : \"\",\n\t\t\t\t     name ? name : \"\");\n\t\t}\n\t}\n}\n\nvoid\nnv50_disp_chan_mthd(struct nvkm_disp_chan *chan, int debug)\n{\n\tstruct nvkm_disp *disp = chan->disp;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tconst struct nvkm_disp_chan_mthd *mthd = chan->mthd;\n\tconst struct nvkm_disp_mthd_list *list;\n\tint i, j;\n\n\tif (debug > subdev->debug)\n\t\treturn;\n\tif (!mthd)\n\t\treturn;\n\n\tfor (i = 0; (list = mthd->data[i].mthd) != NULL; i++) {\n\t\tu32 base = chan->head * mthd->addr;\n\t\tfor (j = 0; j < mthd->data[i].nr; j++, base += list->addr) {\n\t\t\tconst char *cname = mthd->name;\n\t\t\tconst char *sname = \"\";\n\t\t\tchar cname_[16], sname_[16];\n\n\t\t\tif (mthd->addr) {\n\t\t\t\tsnprintf(cname_, sizeof(cname_), \"%s %d\",\n\t\t\t\t\t mthd->name, chan->chid.user);\n\t\t\t\tcname = cname_;\n\t\t\t}\n\n\t\t\tif (mthd->data[i].nr > 1) {\n\t\t\t\tsnprintf(sname_, sizeof(sname_), \" - %s %d\",\n\t\t\t\t\t mthd->data[i].name, j);\n\t\t\t\tsname = sname_;\n\t\t\t}\n\n\t\t\tnvkm_printk_(subdev, debug, info, \"%s%s:\\n\", cname, sname);\n\t\t\tnv50_disp_mthd_list(disp, debug, base, mthd->prev,\n\t\t\t\t\t    list, j);\n\t\t}\n\t}\n}\n\nstatic void\nnv50_disp_chan_uevent_fini(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_disp *disp = container_of(event, typeof(*disp), uevent);\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tnvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000000 << index);\n\tnvkm_wr32(device, 0x610020, 0x00000001 << index);\n}\n\nstatic void\nnv50_disp_chan_uevent_init(struct nvkm_event *event, int types, int index)\n{\n\tstruct nvkm_disp *disp = container_of(event, typeof(*disp), uevent);\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tnvkm_wr32(device, 0x610020, 0x00000001 << index);\n\tnvkm_mask(device, 0x610028, 0x00000001 << index, 0x00000001 << index);\n}\n\nvoid\nnv50_disp_chan_uevent_send(struct nvkm_disp *disp, int chid)\n{\n\tnvkm_event_ntfy(&disp->uevent, chid, NVKM_DISP_EVENT_CHAN_AWAKEN);\n}\n\nconst struct nvkm_event_func\nnv50_disp_chan_uevent = {\n\t.init = nv50_disp_chan_uevent_init,\n\t.fini = nv50_disp_chan_uevent_fini,\n};\n\nu64\nnv50_disp_chan_user(struct nvkm_disp_chan *chan, u64 *psize)\n{\n\t*psize = 0x1000;\n\treturn 0x640000 + (chan->chid.user * 0x1000);\n}\n\nvoid\nnv50_disp_chan_intr(struct nvkm_disp_chan *chan, bool en)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 mask = 0x00010001 << chan->chid.user;\n\tconst u32 data = en ? 0x00010000 << chan->chid.user : 0x00000000;\n\tnvkm_mask(device, 0x610028, mask, data);\n}\n\nstatic void\nnv50_disp_pioc_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_disp *disp = chan->disp;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\tnvkm_mask(device, 0x610200 + (ctrl * 0x10), 0x00000001, 0x00000000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610200 + (ctrl * 0x10)) & 0x00030000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d timeout: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610200 + (ctrl * 0x10)));\n\t}\n}\n\nstatic int\nnv50_disp_pioc_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_disp *disp = chan->disp;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\tnvkm_wr32(device, 0x610200 + (ctrl * 0x10), 0x00002000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610200 + (ctrl * 0x10)) & 0x00030000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d timeout0: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610200 + (ctrl * 0x10)));\n\t\treturn -EBUSY;\n\t}\n\n\tnvkm_wr32(device, 0x610200 + (ctrl * 0x10), 0x00000001);\n\tif (nvkm_msec(device, 2000,\n\t\tu32 tmp = nvkm_rd32(device, 0x610200 + (ctrl * 0x10));\n\t\tif ((tmp & 0x00030000) == 0x00010000)\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d timeout1: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610200 + (ctrl * 0x10)));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\nnv50_disp_pioc_func = {\n\t.init = nv50_disp_pioc_init,\n\t.fini = nv50_disp_pioc_fini,\n\t.intr = nv50_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n};\n\nint\nnv50_disp_dmac_bind(struct nvkm_disp_chan *chan, struct nvkm_object *object, u32 handle)\n{\n\treturn nvkm_ramht_insert(chan->disp->ramht, object, chan->chid.user, -10, handle,\n\t\t\t\t chan->chid.user << 28 | chan->chid.user);\n}\n\nstatic void\nnv50_disp_dmac_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\t \n\tnvkm_mask(device, 0x610200 + (ctrl * 0x0010), 0x00001010, 0x00001000);\n\tnvkm_mask(device, 0x610200 + (ctrl * 0x0010), 0x00000003, 0x00000000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610200 + (ctrl * 0x10)) & 0x001e0000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d fini timeout, %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610200 + (ctrl * 0x10)));\n\t}\n\n\tchan->suspend_put = nvkm_rd32(device, 0x640000 + (ctrl * 0x1000));\n}\n\nstatic int\nnv50_disp_dmac_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\t \n\tnvkm_wr32(device, 0x610204 + (ctrl * 0x0010), chan->push);\n\tnvkm_wr32(device, 0x610208 + (ctrl * 0x0010), 0x00010000);\n\tnvkm_wr32(device, 0x61020c + (ctrl * 0x0010), ctrl);\n\tnvkm_mask(device, 0x610200 + (ctrl * 0x0010), 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x640000 + (ctrl * 0x1000), chan->suspend_put);\n\tnvkm_wr32(device, 0x610200 + (ctrl * 0x0010), 0x00000013);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610200 + (ctrl * 0x10)) & 0x80000000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d init timeout, %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610200 + (ctrl * 0x10)));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint\nnv50_disp_dmac_push(struct nvkm_disp_chan *chan, u64 object)\n{\n\tchan->memory = nvkm_umem_search(chan->object.client, object);\n\tif (IS_ERR(chan->memory))\n\t\treturn PTR_ERR(chan->memory);\n\n\tif (nvkm_memory_size(chan->memory) < 0x1000)\n\t\treturn -EINVAL;\n\n\tswitch (nvkm_memory_target(chan->memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: chan->push = 0x00000001; break;\n\tcase NVKM_MEM_TARGET_NCOH: chan->push = 0x00000002; break;\n\tcase NVKM_MEM_TARGET_HOST: chan->push = 0x00000003; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchan->push |= nvkm_memory_addr(chan->memory) >> 8;\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\nnv50_disp_dmac_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = nv50_disp_dmac_init,\n\t.fini = nv50_disp_dmac_fini,\n\t.intr = nv50_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n\t.bind = nv50_disp_dmac_bind,\n};\n\nconst struct nvkm_disp_chan_user\nnv50_disp_curs = {\n\t.func = &nv50_disp_pioc_func,\n\t.ctrl = 7,\n\t.user = 7,\n};\n\nconst struct nvkm_disp_chan_user\nnv50_disp_oimm = {\n\t.func = &nv50_disp_pioc_func,\n\t.ctrl = 5,\n\t.user = 5,\n};\n\nstatic const struct nvkm_disp_mthd_list\nnv50_disp_ovly_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x000000 },\n\t\t{ 0x0084, 0x0009a0 },\n\t\t{ 0x0088, 0x0009c0 },\n\t\t{ 0x008c, 0x0009c8 },\n\t\t{ 0x0090, 0x6109b4 },\n\t\t{ 0x0094, 0x610970 },\n\t\t{ 0x00a0, 0x610998 },\n\t\t{ 0x00a4, 0x610964 },\n\t\t{ 0x00c0, 0x610958 },\n\t\t{ 0x00e0, 0x6109a8 },\n\t\t{ 0x00e4, 0x6109d0 },\n\t\t{ 0x00e8, 0x6109d8 },\n\t\t{ 0x0100, 0x61094c },\n\t\t{ 0x0104, 0x610984 },\n\t\t{ 0x0108, 0x61098c },\n\t\t{ 0x0800, 0x6109f8 },\n\t\t{ 0x0808, 0x610a08 },\n\t\t{ 0x080c, 0x610a10 },\n\t\t{ 0x0810, 0x610a00 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\nnv50_disp_ovly_mthd = {\n\t.name = \"Overlay\",\n\t.addr = 0x000540,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &nv50_disp_ovly_mthd_base },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_user\nnv50_disp_ovly = {\n\t.func = &nv50_disp_dmac_func,\n\t.ctrl = 3,\n\t.user = 3,\n\t.mthd = &nv50_disp_ovly_mthd,\n};\n\nstatic const struct nvkm_disp_mthd_list\nnv50_disp_base_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x000000 },\n\t\t{ 0x0084, 0x0008c4 },\n\t\t{ 0x0088, 0x0008d0 },\n\t\t{ 0x008c, 0x0008dc },\n\t\t{ 0x0090, 0x0008e4 },\n\t\t{ 0x0094, 0x610884 },\n\t\t{ 0x00a0, 0x6108a0 },\n\t\t{ 0x00a4, 0x610878 },\n\t\t{ 0x00c0, 0x61086c },\n\t\t{ 0x00e0, 0x610858 },\n\t\t{ 0x00e4, 0x610860 },\n\t\t{ 0x00e8, 0x6108ac },\n\t\t{ 0x00ec, 0x6108b4 },\n\t\t{ 0x0100, 0x610894 },\n\t\t{ 0x0110, 0x6108bc },\n\t\t{ 0x0114, 0x61088c },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\nnv50_disp_base_mthd_image = {\n\t.mthd = 0x0400,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0800, 0x6108f0 },\n\t\t{ 0x0804, 0x6108fc },\n\t\t{ 0x0808, 0x61090c },\n\t\t{ 0x080c, 0x610914 },\n\t\t{ 0x0810, 0x610904 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\nnv50_disp_base_mthd = {\n\t.name = \"Base\",\n\t.addr = 0x000540,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &nv50_disp_base_mthd_base },\n\t\t{  \"Image\", 2, &nv50_disp_base_mthd_image },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_user\nnv50_disp_base = {\n\t.func = &nv50_disp_dmac_func,\n\t.ctrl = 1,\n\t.user = 1,\n\t.mthd = &nv50_disp_base_mthd,\n};\n\nconst struct nvkm_disp_mthd_list\nnv50_disp_core_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0080, 0x000000 },\n\t\t{ 0x0084, 0x610bb8 },\n\t\t{ 0x0088, 0x610b9c },\n\t\t{ 0x008c, 0x000000 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\nnv50_disp_core_mthd_dac = {\n\t.mthd = 0x0080,\n\t.addr = 0x000008,\n\t.data = {\n\t\t{ 0x0400, 0x610b58 },\n\t\t{ 0x0404, 0x610bdc },\n\t\t{ 0x0420, 0x610828 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\nnv50_disp_core_mthd_sor = {\n\t.mthd = 0x0040,\n\t.addr = 0x000008,\n\t.data = {\n\t\t{ 0x0600, 0x610b70 },\n\t\t{}\n\t}\n};\n\nconst struct nvkm_disp_mthd_list\nnv50_disp_core_mthd_pior = {\n\t.mthd = 0x0040,\n\t.addr = 0x000008,\n\t.data = {\n\t\t{ 0x0700, 0x610b80 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\nnv50_disp_core_mthd_head = {\n\t.mthd = 0x0400,\n\t.addr = 0x000540,\n\t.data = {\n\t\t{ 0x0800, 0x610ad8 },\n\t\t{ 0x0804, 0x610ad0 },\n\t\t{ 0x0808, 0x610a48 },\n\t\t{ 0x080c, 0x610a78 },\n\t\t{ 0x0810, 0x610ac0 },\n\t\t{ 0x0814, 0x610af8 },\n\t\t{ 0x0818, 0x610b00 },\n\t\t{ 0x081c, 0x610ae8 },\n\t\t{ 0x0820, 0x610af0 },\n\t\t{ 0x0824, 0x610b08 },\n\t\t{ 0x0828, 0x610b10 },\n\t\t{ 0x082c, 0x610a68 },\n\t\t{ 0x0830, 0x610a60 },\n\t\t{ 0x0834, 0x000000 },\n\t\t{ 0x0838, 0x610a40 },\n\t\t{ 0x0840, 0x610a24 },\n\t\t{ 0x0844, 0x610a2c },\n\t\t{ 0x0848, 0x610aa8 },\n\t\t{ 0x084c, 0x610ab0 },\n\t\t{ 0x0860, 0x610a84 },\n\t\t{ 0x0864, 0x610a90 },\n\t\t{ 0x0868, 0x610b18 },\n\t\t{ 0x086c, 0x610b20 },\n\t\t{ 0x0870, 0x610ac8 },\n\t\t{ 0x0874, 0x610a38 },\n\t\t{ 0x0880, 0x610a58 },\n\t\t{ 0x0884, 0x610a9c },\n\t\t{ 0x08a0, 0x610a70 },\n\t\t{ 0x08a4, 0x610a50 },\n\t\t{ 0x08a8, 0x610ae0 },\n\t\t{ 0x08c0, 0x610b28 },\n\t\t{ 0x08c4, 0x610b30 },\n\t\t{ 0x08c8, 0x610b40 },\n\t\t{ 0x08d4, 0x610b38 },\n\t\t{ 0x08d8, 0x610b48 },\n\t\t{ 0x08dc, 0x610b50 },\n\t\t{ 0x0900, 0x610a18 },\n\t\t{ 0x0904, 0x610ab8 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\nnv50_disp_core_mthd = {\n\t.name = \"Core\",\n\t.addr = 0x000000,\n\t.prev = 0x000004,\n\t.data = {\n\t\t{ \"Global\", 1, &nv50_disp_core_mthd_base },\n\t\t{    \"DAC\", 3, &nv50_disp_core_mthd_dac  },\n\t\t{    \"SOR\", 2, &nv50_disp_core_mthd_sor  },\n\t\t{   \"PIOR\", 3, &nv50_disp_core_mthd_pior },\n\t\t{   \"HEAD\", 2, &nv50_disp_core_mthd_head },\n\t\t{}\n\t}\n};\n\nstatic void\nnv50_disp_core_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tnvkm_mask(device, 0x610200, 0x00000010, 0x00000000);\n\tnvkm_mask(device, 0x610200, 0x00000003, 0x00000000);\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610200) & 0x001e0000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"core fini: %08x\\n\",\n\t\t\t   nvkm_rd32(device, 0x610200));\n\t}\n\n\tchan->suspend_put = nvkm_rd32(device, 0x640000);\n}\n\nstatic int\nnv50_disp_core_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tif ((nvkm_rd32(device, 0x610200) & 0x009f0000) == 0x00020000)\n\t\tnvkm_mask(device, 0x610200, 0x00800000, 0x00800000);\n\tif ((nvkm_rd32(device, 0x610200) & 0x003f0000) == 0x00030000)\n\t\tnvkm_mask(device, 0x610200, 0x00600000, 0x00600000);\n\n\t \n\tnvkm_wr32(device, 0x610204, chan->push);\n\tnvkm_wr32(device, 0x610208, 0x00010000);\n\tnvkm_wr32(device, 0x61020c, 0x00000000);\n\tnvkm_mask(device, 0x610200, 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x640000, chan->suspend_put);\n\tnvkm_wr32(device, 0x610200, 0x01000013);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610200) & 0x80000000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"core init: %08x\\n\",\n\t\t\t   nvkm_rd32(device, 0x610200));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\nnv50_disp_core_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = nv50_disp_core_init,\n\t.fini = nv50_disp_core_fini,\n\t.intr = nv50_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n\t.bind = nv50_disp_dmac_bind,\n};\n\nstatic const struct nvkm_disp_chan_user\nnv50_disp_core = {\n\t.func = &nv50_disp_core_func,\n\t.ctrl = 0,\n\t.user = 0,\n\t.mthd = &nv50_disp_core_mthd,\n};\n\nstatic u32\nnv50_disp_super_iedt(struct nvkm_head *head, struct nvkm_outp *outp,\n\t\t     u8 *ver, u8 *hdr, u8 *cnt, u8 *len,\n\t\t     struct nvbios_outp *iedt)\n{\n\tstruct nvkm_bios *bios = head->disp->engine.subdev.device->bios;\n\tconst u8  l = ffs(outp->info.link);\n\tconst u16 t = outp->info.hasht;\n\tconst u16 m = (0x0100 << head->id) | (l << 6) | outp->info.or;\n\tu32 data = nvbios_outp_match(bios, t, m, ver, hdr, cnt, len, iedt);\n\tif (!data)\n\t\tOUTP_DBG(outp, \"missing IEDT for %04x:%04x\", t, m);\n\treturn data;\n}\n\nstatic void\nnv50_disp_super_ied_on(struct nvkm_head *head,\n\t\t       struct nvkm_ior *ior, int id, u32 khz)\n{\n\tstruct nvkm_subdev *subdev = &head->disp->engine.subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvkm_outp *outp = ior->asy.outp;\n\tstruct nvbios_ocfg iedtrs;\n\tstruct nvbios_outp iedt;\n\tu8  ver, hdr, cnt, len, flags = 0x00;\n\tu32 data;\n\n\tif (!outp) {\n\t\tIOR_DBG(ior, \"nothing to attach\");\n\t\treturn;\n\t}\n\n\t \n\tdata = nv50_disp_super_iedt(head, outp, &ver, &hdr, &cnt, &len, &iedt);\n\tif (!data)\n\t\treturn;\n\n\t \n\tif (ior->type == SOR) {\n\t\tif (ior->asy.proto == LVDS) {\n\t\t\tif (head->asy.or.depth == 24)\n\t\t\t\tflags |= 0x02;\n\t\t}\n\t\tif (ior->asy.link == 3)\n\t\t\tflags |= 0x01;\n\t}\n\n\tdata = nvbios_ocfg_match(bios, data, ior->asy.proto_evo, flags,\n\t\t\t\t &ver, &hdr, &cnt, &len, &iedtrs);\n\tif (!data) {\n\t\tOUTP_DBG(outp, \"missing IEDT RS for %02x:%02x\",\n\t\t\t ior->asy.proto_evo, flags);\n\t\treturn;\n\t}\n\n\t \n\tdata = nvbios_oclk_match(bios, iedtrs.clkcmp[id], khz);\n\tif (!data) {\n\t\tOUTP_DBG(outp, \"missing IEDT RSS %d for %02x:%02x %d khz\",\n\t\t\t id, ior->asy.proto_evo, flags, khz);\n\t\treturn;\n\t}\n\n\tnvbios_init(subdev, data,\n\t\tinit.outp = &outp->info;\n\t\tinit.or   = ior->id;\n\t\tinit.link = ior->asy.link;\n\t\tinit.head = head->id;\n\t);\n}\n\nstatic void\nnv50_disp_super_ied_off(struct nvkm_head *head, struct nvkm_ior *ior, int id)\n{\n\tstruct nvkm_outp *outp = ior->arm.outp;\n\tstruct nvbios_outp iedt;\n\tu8  ver, hdr, cnt, len;\n\tu32 data;\n\n\tif (!outp) {\n\t\tIOR_DBG(ior, \"nothing attached\");\n\t\treturn;\n\t}\n\n\tdata = nv50_disp_super_iedt(head, outp, &ver, &hdr, &cnt, &len, &iedt);\n\tif (!data)\n\t\treturn;\n\n\tnvbios_init(&head->disp->engine.subdev, iedt.script[id],\n\t\tinit.outp = &outp->info;\n\t\tinit.or   = ior->id;\n\t\tinit.link = ior->arm.link;\n\t\tinit.head = head->id;\n\t);\n}\n\nstatic struct nvkm_ior *\nnv50_disp_super_ior_asy(struct nvkm_head *head)\n{\n\tstruct nvkm_ior *ior;\n\tlist_for_each_entry(ior, &head->disp->iors, head) {\n\t\tif (ior->asy.head & (1 << head->id)) {\n\t\t\tHEAD_DBG(head, \"to %s\", ior->name);\n\t\t\treturn ior;\n\t\t}\n\t}\n\tHEAD_DBG(head, \"nothing to attach\");\n\treturn NULL;\n}\n\nstatic struct nvkm_ior *\nnv50_disp_super_ior_arm(struct nvkm_head *head)\n{\n\tstruct nvkm_ior *ior;\n\tlist_for_each_entry(ior, &head->disp->iors, head) {\n\t\tif (ior->arm.head & (1 << head->id)) {\n\t\t\tHEAD_DBG(head, \"on %s\", ior->name);\n\t\t\treturn ior;\n\t\t}\n\t}\n\tHEAD_DBG(head, \"nothing attached\");\n\treturn NULL;\n}\n\nvoid\nnv50_disp_super_3_0(struct nvkm_disp *disp, struct nvkm_head *head)\n{\n\tstruct nvkm_ior *ior;\n\n\t \n\tHEAD_DBG(head, \"supervisor 3.0\");\n\tior = nv50_disp_super_ior_asy(head);\n\tif (!ior)\n\t\treturn;\n\n\t \n\tnv50_disp_super_ied_on(head, ior, 1, head->asy.hz / 1000);\n\n\t \n\tif (ior->func->war_3)\n\t\tior->func->war_3(ior);\n}\n\nstatic void\nnv50_disp_super_2_2_dp(struct nvkm_head *head, struct nvkm_ior *ior)\n{\n\tstruct nvkm_subdev *subdev = &head->disp->engine.subdev;\n\tconst u32      khz = head->asy.hz / 1000;\n\tconst u32 linkKBps = ior->dp.bw * 27000;\n\tconst u32   symbol = 100000;\n\tint bestTU = 0, bestVTUi = 0, bestVTUf = 0, bestVTUa = 0;\n\tint TU, VTUi, VTUf, VTUa;\n\tu64 link_data_rate, link_ratio, unk;\n\tu32 best_diff = 64 * symbol;\n\tu64 h, v;\n\n\t \n\th = head->asy.hblanke + head->asy.htotal - head->asy.hblanks - 7;\n\th = h * linkKBps;\n\tdo_div(h, khz);\n\th = h - (3 * ior->dp.ef) - (12 / ior->dp.nr);\n\n\t \n\tv = head->asy.vblanks - head->asy.vblanke - 25;\n\tv = v * linkKBps;\n\tdo_div(v, khz);\n\tv = v - ((36 / ior->dp.nr) + 3) - 1;\n\n\tior->func->dp->audio_sym(ior, head->id, h, v);\n\n\t \n\tlink_data_rate = (khz * head->asy.or.depth / 8) / ior->dp.nr;\n\n\t \n\tlink_ratio = link_data_rate * symbol;\n\tdo_div(link_ratio, linkKBps);\n\n\tfor (TU = 64; ior->func->dp->activesym && TU >= 32; TU--) {\n\t\t \n\t\tu32 tu_valid = link_ratio * TU;\n\t\tu32 calc, diff;\n\n\t\t \n\t\tVTUi = tu_valid / symbol;\n\t\tcalc = VTUi * symbol;\n\t\tdiff = tu_valid - calc;\n\t\tif (diff) {\n\t\t\tif (diff >= (symbol / 2)) {\n\t\t\t\tVTUf = symbol / (symbol - diff);\n\t\t\t\tif (symbol - (VTUf * diff))\n\t\t\t\t\tVTUf++;\n\n\t\t\t\tif (VTUf <= 15) {\n\t\t\t\t\tVTUa  = 1;\n\t\t\t\t\tcalc += symbol - (symbol / VTUf);\n\t\t\t\t} else {\n\t\t\t\t\tVTUa  = 0;\n\t\t\t\t\tVTUf  = 1;\n\t\t\t\t\tcalc += symbol;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVTUa  = 0;\n\t\t\t\tVTUf  = min((int)(symbol / diff), 15);\n\t\t\t\tcalc += symbol / VTUf;\n\t\t\t}\n\n\t\t\tdiff = calc - tu_valid;\n\t\t} else {\n\t\t\t \n\t\t\tVTUa = 0;\n\t\t\tVTUf = 1;\n\t\t\tVTUi--;\n\t\t}\n\n\t\tif (diff < best_diff) {\n\t\t\tbest_diff = diff;\n\t\t\tbestTU = TU;\n\t\t\tbestVTUa = VTUa;\n\t\t\tbestVTUf = VTUf;\n\t\t\tbestVTUi = VTUi;\n\t\t\tif (diff == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ior->func->dp->activesym) {\n\t\tif (!bestTU) {\n\t\t\tnvkm_error(subdev, \"unable to determine dp config\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tior->func->dp->activesym(ior, head->id, bestTU, bestVTUa, bestVTUf, bestVTUi);\n\t} else {\n\t\tbestTU = 64;\n\t}\n\n\t \n\tunk  = (symbol - link_ratio) * bestTU;\n\tunk *= link_ratio;\n\tdo_div(unk, symbol);\n\tdo_div(unk, symbol);\n\tunk += 6;\n\n\tior->func->dp->watermark(ior, head->id, unk);\n}\n\nvoid\nnv50_disp_super_2_2(struct nvkm_disp *disp, struct nvkm_head *head)\n{\n\tconst u32 khz = head->asy.hz / 1000;\n\tstruct nvkm_outp *outp;\n\tstruct nvkm_ior *ior;\n\n\t \n\tHEAD_DBG(head, \"supervisor 2.2\");\n\tior = nv50_disp_super_ior_asy(head);\n\tif (!ior)\n\t\treturn;\n\n\toutp = ior->asy.outp;\n\n\t \n\tif (outp && ior->type == SOR && ior->asy.proto == LVDS) {\n\t\thead->asy.or.depth = outp->lvds.bpc8 ? 24 : 18;\n\t\tior->asy.link      = outp->lvds.dual ? 3 : 1;\n\t}\n\n\t \n\tif (outp && outp->func->acquire)\n\t\toutp->func->acquire(outp);\n\n\t \n\tnv50_disp_super_ied_on(head, ior, 0, khz);\n\n\t \n\thead->func->rgclk(head, ior->asy.rgdiv);\n\n\t \n\tif (ior->type == SOR && ior->asy.proto == DP)\n\t\tnv50_disp_super_2_2_dp(head, ior);\n\n\t \n\tior->func->clock(ior);\n\tif (ior->func->war_2)\n\t\tior->func->war_2(ior);\n}\n\nvoid\nnv50_disp_super_2_1(struct nvkm_disp *disp, struct nvkm_head *head)\n{\n\tstruct nvkm_devinit *devinit = disp->engine.subdev.device->devinit;\n\tconst u32 khz = head->asy.hz / 1000;\n\tHEAD_DBG(head, \"supervisor 2.1 - %d khz\", khz);\n\tif (khz)\n\t\tnvkm_devinit_pll_set(devinit, PLL_VPLL0 + head->id, khz);\n}\n\nvoid\nnv50_disp_super_2_0(struct nvkm_disp *disp, struct nvkm_head *head)\n{\n\tstruct nvkm_outp *outp;\n\tstruct nvkm_ior *ior;\n\n\t \n\tHEAD_DBG(head, \"supervisor 2.0\");\n\tior = nv50_disp_super_ior_arm(head);\n\tif (!ior)\n\t\treturn;\n\n\t \n\tnv50_disp_super_ied_off(head, ior, 2);\n\n\t \n\tif (ior->arm.head == (1 << head->id)) {\n\t\tif ((outp = ior->arm.outp) && outp->func->disable)\n\t\t\toutp->func->disable(outp, ior);\n\t}\n}\n\nvoid\nnv50_disp_super_1_0(struct nvkm_disp *disp, struct nvkm_head *head)\n{\n\tstruct nvkm_ior *ior;\n\n\t \n\tHEAD_DBG(head, \"supervisor 1.0\");\n\tior = nv50_disp_super_ior_arm(head);\n\tif (!ior)\n\t\treturn;\n\n\t \n\tnv50_disp_super_ied_off(head, ior, 1);\n}\n\nvoid\nnv50_disp_super_1(struct nvkm_disp *disp)\n{\n\tstruct nvkm_head *head;\n\tstruct nvkm_ior *ior;\n\n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\thead->func->state(head, &head->arm);\n\t\thead->func->state(head, &head->asy);\n\t}\n\n\tlist_for_each_entry(ior, &disp->iors, head) {\n\t\tior->func->state(ior, &ior->arm);\n\t\tior->func->state(ior, &ior->asy);\n\t}\n}\n\nvoid\nnv50_disp_super(struct work_struct *work)\n{\n\tstruct nvkm_disp *disp = container_of(work, struct nvkm_disp, super.work);\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_head *head;\n\tu32 super;\n\n\tmutex_lock(&disp->super.mutex);\n\tsuper = nvkm_rd32(device, 0x610030);\n\n\tnvkm_debug(subdev, \"supervisor %08x %08x\\n\", disp->super.pending, super);\n\n\tif (disp->super.pending & 0x00000010) {\n\t\tnv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);\n\t\tnv50_disp_super_1(disp);\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(super & (0x00000020 << head->id)))\n\t\t\t\tcontinue;\n\t\t\tif (!(super & (0x00000080 << head->id)))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_1_0(disp, head);\n\t\t}\n\t} else\n\tif (disp->super.pending & 0x00000020) {\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(super & (0x00000080 << head->id)))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_0(disp, head);\n\t\t}\n\t\tnvkm_outp_route(disp);\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(super & (0x00000200 << head->id)))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_1(disp, head);\n\t\t}\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(super & (0x00000080 << head->id)))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_2(disp, head);\n\t\t}\n\t} else\n\tif (disp->super.pending & 0x00000040) {\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(super & (0x00000080 << head->id)))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_3_0(disp, head);\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x610030, 0x80000000);\n\tmutex_unlock(&disp->super.mutex);\n}\n\nconst struct nvkm_enum\nnv50_disp_intr_error_type[] = {\n\t{ 0, \"NONE\" },\n\t{ 1, \"PUSHBUFFER_ERR\" },\n\t{ 2, \"TRAP\" },\n\t{ 3, \"RESERVED_METHOD\" },\n\t{ 4, \"INVALID_ARG\" },\n\t{ 5, \"INVALID_STATE\" },\n\t{ 7, \"UNRESOLVABLE_HANDLE\" },\n\t{}\n};\n\nstatic const struct nvkm_enum\nnv50_disp_intr_error_code[] = {\n\t{ 0x00, \"\" },\n\t{}\n};\n\nstatic void\nnv50_disp_intr_error(struct nvkm_disp *disp, int chid)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 data = nvkm_rd32(device, 0x610084 + (chid * 0x08));\n\tu32 addr = nvkm_rd32(device, 0x610080 + (chid * 0x08));\n\tu32 code = (addr & 0x00ff0000) >> 16;\n\tu32 type = (addr & 0x00007000) >> 12;\n\tu32 mthd = (addr & 0x00000ffc);\n\tconst struct nvkm_enum *ec, *et;\n\n\tet = nvkm_enum_find(nv50_disp_intr_error_type, type);\n\tec = nvkm_enum_find(nv50_disp_intr_error_code, code);\n\n\tnvkm_error(subdev,\n\t\t   \"ERROR %d [%s] %02x [%s] chid %d mthd %04x data %08x\\n\",\n\t\t   type, et ? et->name : \"\", code, ec ? ec->name : \"\",\n\t\t   chid, mthd, data);\n\n\tif (chid < ARRAY_SIZE(disp->chan)) {\n\t\tswitch (mthd) {\n\t\tcase 0x0080:\n\t\t\tnv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x610020, 0x00010000 << chid);\n\tnvkm_wr32(device, 0x610080 + (chid * 0x08), 0x90000000);\n}\n\nvoid\nnv50_disp_intr(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tu32 intr0 = nvkm_rd32(device, 0x610020);\n\tu32 intr1 = nvkm_rd32(device, 0x610024);\n\n\twhile (intr0 & 0x001f0000) {\n\t\tu32 chid = __ffs(intr0 & 0x001f0000) - 16;\n\t\tnv50_disp_intr_error(disp, chid);\n\t\tintr0 &= ~(0x00010000 << chid);\n\t}\n\n\twhile (intr0 & 0x0000001f) {\n\t\tu32 chid = __ffs(intr0 & 0x0000001f);\n\t\tnv50_disp_chan_uevent_send(disp, chid);\n\t\tintr0 &= ~(0x00000001 << chid);\n\t}\n\n\tif (intr1 & 0x00000004) {\n\t\tnvkm_disp_vblank(disp, 0);\n\t\tnvkm_wr32(device, 0x610024, 0x00000004);\n\t}\n\n\tif (intr1 & 0x00000008) {\n\t\tnvkm_disp_vblank(disp, 1);\n\t\tnvkm_wr32(device, 0x610024, 0x00000008);\n\t}\n\n\tif (intr1 & 0x00000070) {\n\t\tdisp->super.pending = (intr1 & 0x00000070);\n\t\tqueue_work(disp->super.wq, &disp->super.work);\n\t\tnvkm_wr32(device, 0x610024, disp->super.pending);\n\t}\n}\n\nvoid\nnv50_disp_fini(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\t \n\tnvkm_wr32(device, 0x610024, 0x00000000);\n\tnvkm_wr32(device, 0x610020, 0x00000000);\n}\n\nint\nnv50_disp_init(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tstruct nvkm_head *head;\n\tu32 tmp;\n\tint i;\n\n\t \n\ttmp = nvkm_rd32(device, 0x614004);\n\tnvkm_wr32(device, 0x610184, tmp);\n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\ttmp = nvkm_rd32(device, 0x616100 + (head->id * 0x800));\n\t\tnvkm_wr32(device, 0x610190 + (head->id * 0x10), tmp);\n\t\ttmp = nvkm_rd32(device, 0x616104 + (head->id * 0x800));\n\t\tnvkm_wr32(device, 0x610194 + (head->id * 0x10), tmp);\n\t\ttmp = nvkm_rd32(device, 0x616108 + (head->id * 0x800));\n\t\tnvkm_wr32(device, 0x610198 + (head->id * 0x10), tmp);\n\t\ttmp = nvkm_rd32(device, 0x61610c + (head->id * 0x800));\n\t\tnvkm_wr32(device, 0x61019c + (head->id * 0x10), tmp);\n\t}\n\n\t \n\tfor (i = 0; i < disp->dac.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61a000 + (i * 0x800));\n\t\tnvkm_wr32(device, 0x6101d0 + (i * 0x04), tmp);\n\t}\n\n\t \n\tfor (i = 0; i < disp->sor.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));\n\t\tnvkm_wr32(device, 0x6101e0 + (i * 0x04), tmp);\n\t}\n\n\t \n\tfor (i = 0; i < disp->pior.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61e000 + (i * 0x800));\n\t\tnvkm_wr32(device, 0x6101f0 + (i * 0x04), tmp);\n\t}\n\n\t \n\tif (nvkm_rd32(device, 0x610024) & 0x00000100) {\n\t\tnvkm_wr32(device, 0x610024, 0x00000100);\n\t\tnvkm_mask(device, 0x6194e8, 0x00000001, 0x00000000);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x6194e8) & 0x00000002))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\tnvkm_wr32(device, 0x610010, (disp->inst->addr >> 8) | 9);\n\n\t \n\tnvkm_wr32(device, 0x61002c, 0x00000370);\n\tnvkm_wr32(device, 0x610028, 0x00000000);\n\treturn 0;\n}\n\nint\nnv50_disp_oneinit(struct nvkm_disp *disp)\n{\n\tconst struct nvkm_disp_func *func = disp->func;\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ret, i;\n\n\tif (func->wndw.cnt) {\n\t\tdisp->wndw.nr = func->wndw.cnt(disp, &disp->wndw.mask);\n\t\tnvkm_debug(subdev, \"Window(s): %d (%08lx)\\n\", disp->wndw.nr, disp->wndw.mask);\n\t}\n\n\tdisp->head.nr = func->head.cnt(disp, &disp->head.mask);\n\tnvkm_debug(subdev, \"  Head(s): %d (%02lx)\\n\", disp->head.nr, disp->head.mask);\n\tfor_each_set_bit(i, &disp->head.mask, disp->head.nr) {\n\t\tret = func->head.new(disp, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (func->dac.cnt) {\n\t\tdisp->dac.nr = func->dac.cnt(disp, &disp->dac.mask);\n\t\tnvkm_debug(subdev, \"   DAC(s): %d (%02lx)\\n\", disp->dac.nr, disp->dac.mask);\n\t\tfor_each_set_bit(i, &disp->dac.mask, disp->dac.nr) {\n\t\t\tret = func->dac.new(disp, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (func->pior.cnt) {\n\t\tdisp->pior.nr = func->pior.cnt(disp, &disp->pior.mask);\n\t\tnvkm_debug(subdev, \"  PIOR(s): %d (%02lx)\\n\", disp->pior.nr, disp->pior.mask);\n\t\tfor_each_set_bit(i, &disp->pior.mask, disp->pior.nr) {\n\t\t\tret = func->pior.new(disp, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdisp->sor.nr = func->sor.cnt(disp, &disp->sor.mask);\n\tnvkm_debug(subdev, \"   SOR(s): %d (%02lx)\\n\", disp->sor.nr, disp->sor.mask);\n\tfor_each_set_bit(i, &disp->sor.mask, disp->sor.nr) {\n\t\tret = func->sor.new(disp, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = nvkm_gpuobj_new(device, 0x10000, 0x10000, false, NULL, &disp->inst);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nvkm_ramht_new(device, func->ramht_size ? func->ramht_size :\n\t\t\t      0x1000, 0, disp->inst, &disp->ramht);\n}\n\nstatic const struct nvkm_disp_func\nnv50_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = nv50_disp_init,\n\t.fini = nv50_disp_fini,\n\t.intr = nv50_disp_intr,\n\t.super = nv50_disp_super,\n\t.uevent = &nv50_disp_chan_uevent,\n\t.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },\n\t.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },\n\t.sor = { .cnt = nv50_sor_cnt, .new = nv50_sor_new },\n\t.pior = { .cnt = nv50_pior_cnt, .new = nv50_pior_new },\n\t.root = { 0, 0, NV50_DISP },\n\t.user = {\n\t\t{{0,0,NV50_DISP_CURSOR             }, nvkm_disp_chan_new, &nv50_disp_curs },\n\t\t{{0,0,NV50_DISP_OVERLAY            }, nvkm_disp_chan_new, &nv50_disp_oimm },\n\t\t{{0,0,NV50_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, &nv50_disp_base },\n\t\t{{0,0,NV50_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, &nv50_disp_core },\n\t\t{{0,0,NV50_DISP_OVERLAY_CHANNEL_DMA}, nvkm_disp_chan_new, &nv50_disp_ovly },\n\t\t{}\n\t}\n};\n\nint\nnv50_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&nv50_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}