{
  "module_name": "tu102.c",
  "hash_id": "0558e687bf2e504b5bd87023943491378112abf216121f712257e324fc8e8c03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/tu102.c",
  "human_readable_source": " \n#include \"chan.h\"\n#include \"priv.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nvoid\ntu102_sor_dp_vcpi(struct nvkm_ior *sor, int head, u8 slot, u8 slot_nr, u16 pbn, u16 aligned)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x61657c + hoff, 0xffffffff, (aligned << 16) | pbn);\n\tnvkm_mask(device, 0x616578 + hoff, 0x00003f3f, (slot_nr << 8) | slot);\n}\n\nstatic int\ntu102_sor_dp_links(struct nvkm_ior *sor, struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tconst u32 loff = nv50_sor_link(sor);\n\tu32 dpctrl = 0x00000000;\n\tu32 clksor = 0x00000000;\n\n\tclksor |= sor->dp.bw << 18;\n\tdpctrl |= ((1 << sor->dp.nr) - 1) << 16;\n\tif (sor->dp.mst)\n\t\tdpctrl |= 0x40000000;\n\tif (sor->dp.ef)\n\t\tdpctrl |= 0x00004000;\n\n\tnvkm_mask(device, 0x612300 + soff, 0x007c0000, clksor);\n\n\t \n\tnvkm_msec(device, 40, NVKM_DELAY);\n\tnvkm_mask(device, 0x612300 + soff, 0x00030000, 0x00010000);\n\tnvkm_mask(device, 0x61c10c + loff, 0x00000003, 0x00000001);\n\n\tnvkm_mask(device, 0x61c10c + loff, 0x401f4000, dpctrl);\n\treturn 0;\n}\n\nstatic const struct nvkm_ior_func_dp\ntu102_sor_dp = {\n\t.lanes = { 0, 1, 2, 3 },\n\t.links = tu102_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = gm107_sor_dp_pattern,\n\t.drive = gm200_sor_dp_drive,\n\t.vcpi = tu102_sor_dp_vcpi,\n\t.audio = gv100_sor_dp_audio,\n\t.audio_sym = gv100_sor_dp_audio_sym,\n\t.watermark = gv100_sor_dp_watermark,\n};\n\nstatic const struct nvkm_ior_func\ntu102_sor = {\n\t.route = {\n\t\t.get = gm200_sor_route_get,\n\t\t.set = gm200_sor_route_set,\n\t},\n\t.state = gv100_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = gf119_sor_clock,\n\t.hdmi = &gv100_sor_hdmi,\n\t.dp = &tu102_sor_dp,\n\t.hda = &gv100_sor_hda,\n};\n\nstatic int\ntu102_sor_new(struct nvkm_disp *disp, int id)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tu32 hda = nvkm_rd32(device, 0x08a15c);\n\n\treturn nvkm_ior_new_(&tu102_sor, disp, SOR, id, hda & BIT(id));\n}\n\nint\ntu102_disp_init(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tstruct nvkm_head *head;\n\tint i, j;\n\tu32 tmp;\n\n\t \n\tif (nvkm_rd32(device, 0x6254e8) & 0x00000002) {\n\t\tnvkm_mask(device, 0x6254e8, 0x00000001, 0x00000000);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x6254e8) & 0x00000002))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\ttmp = 0x00000021;  \n\tnvkm_wr32(device, 0x640008, tmp);\n\n\t \n\tfor (i = 0; i < disp->sor.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));\n\t\tnvkm_mask(device, 0x640000, 0x00000100 << i, 0x00000100 << i);\n\t\tnvkm_wr32(device, 0x640144 + (i * 0x08), tmp);\n\t}\n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst int id = head->id;\n\n\t\t \n\t\ttmp = nvkm_rd32(device, 0x616300 + (id * 0x800));\n\t\tnvkm_wr32(device, 0x640048 + (id * 0x020), tmp);\n\n\t\t \n\t\tfor (j = 0; j < 5 * 4; j += 4) {\n\t\t\ttmp = nvkm_rd32(device, 0x616140 + (id * 0x800) + j);\n\t\t\tnvkm_wr32(device, 0x640680 + (id * 0x20) + j, tmp);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < disp->wndw.nr; i++) {\n\t\tnvkm_mask(device, 0x640004, 1 << i, 1 << i);\n\t\tfor (j = 0; j < 6 * 4; j += 4) {\n\t\t\ttmp = nvkm_rd32(device, 0x630100 + (i * 0x800) + j);\n\t\t\tnvkm_mask(device, 0x640780 + (i * 0x20) + j, 0xffffffff, tmp);\n\t\t}\n\t\tnvkm_mask(device, 0x64000c, 0x00000100, 0x00000100);\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\ttmp = nvkm_rd32(device, 0x62e000 + (i * 0x04));\n\t\tnvkm_wr32(device, 0x640010 + (i * 0x04), tmp);\n\t}\n\n\tnvkm_mask(device, 0x610078, 0x00000001, 0x00000001);\n\n\t \n\tswitch (nvkm_memory_target(disp->inst->memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: tmp = 0x00000001; break;\n\tcase NVKM_MEM_TARGET_NCOH: tmp = 0x00000002; break;\n\tcase NVKM_MEM_TARGET_HOST: tmp = 0x00000003; break;\n\tdefault:\n\t\tbreak;\n\t}\n\tnvkm_wr32(device, 0x610010, 0x00000008 | tmp);\n\tnvkm_wr32(device, 0x610014, disp->inst->addr >> 16);\n\n\t \n\tnvkm_wr32(device, 0x611cf0, 0x00000187);  \n\tnvkm_wr32(device, 0x611db0, 0x00000187);  \n\n\t \n\tnvkm_wr32(device, 0x611cec, disp->head.mask << 16 |\n\t\t\t\t    0x00000001);  \n\tnvkm_wr32(device, 0x611dac, 0x00000000);  \n\n\t \n\tnvkm_wr32(device, 0x611ce8, disp->wndw.mask);  \n\tnvkm_wr32(device, 0x611da8, 0x00000000);  \n\n\t \n\tnvkm_wr32(device, 0x611ce4, disp->wndw.mask);  \n\tnvkm_wr32(device, 0x611da4, 0x00000000);  \n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst u32 hoff = head->id * 4;\n\t\tnvkm_wr32(device, 0x611cc0 + hoff, 0x00000004);  \n\t\tnvkm_wr32(device, 0x611d80 + hoff, 0x00000000);  \n\t}\n\n\t \n\tnvkm_wr32(device, 0x611cf4, 0x00000000);  \n\tnvkm_wr32(device, 0x611db4, 0x00000000);  \n\treturn 0;\n}\n\nstatic const struct nvkm_disp_func\ntu102_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = tu102_disp_init,\n\t.fini = gv100_disp_fini,\n\t.intr = gv100_disp_intr,\n\t.super = gv100_disp_super,\n\t.uevent = &gv100_disp_chan_uevent,\n\t.wndw = { .cnt = gv100_disp_wndw_cnt },\n\t.head = { .cnt = gv100_head_cnt, .new = gv100_head_new },\n\t.sor = { .cnt = gv100_sor_cnt, .new = tu102_sor_new },\n\t.ramht_size = 0x2000,\n\t.root = {  0, 0,TU102_DISP },\n\t.user = {\n\t\t{{-1,-1,GV100_DISP_CAPS                  }, gv100_disp_caps_new },\n\t\t{{ 0, 0,TU102_DISP_CURSOR                },  nvkm_disp_chan_new, &gv100_disp_curs },\n\t\t{{ 0, 0,TU102_DISP_WINDOW_IMM_CHANNEL_DMA},  nvkm_disp_wndw_new, &gv100_disp_wimm },\n\t\t{{ 0, 0,TU102_DISP_CORE_CHANNEL_DMA      },  nvkm_disp_core_new, &gv100_disp_core },\n\t\t{{ 0, 0,TU102_DISP_WINDOW_CHANNEL_DMA    },  nvkm_disp_wndw_new, &gv100_disp_wndw },\n\t\t{}\n\t},\n};\n\nint\ntu102_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&tu102_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}