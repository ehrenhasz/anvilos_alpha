{
  "module_name": "com.fuc",
  "hash_id": "d8ea62d8f1c8e56725e21d07adc8e845acd15309aafa350ee9574ced841d524f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/com.fuc",
  "human_readable_source": "/* fuc microcode util functions for gf100 PGRAPH\n *\n * Copyright 2011 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n#ifdef INCLUDE_CODE\n// queue_put - add request to queue\n//\n// In : $r13 queue pointer\n//\t$r14 command\n//\t$r15 data\n//\nqueue_put:\n\t// make sure we have space..\n\tld b32 $r8 D[$r13 + 0x0]\t// GET\n\tld b32 $r9 D[$r13 + 0x4]\t// PUT\n\txor $r8 8\n\tcmpu b32 $r8 $r9\n\tbra ne #queue_put_next\n\t\tmov $r15 E_CMD_OVERFLOW\n\t\tcall(error)\n\t\tret\n\n\t// store cmd/data on queue\n\tqueue_put_next:\n\tand $r8 $r9 7\n\tshl b32 $r8 3\n\tadd b32 $r8 $r13\n\tadd b32 $r8 8\n\tst b32 D[$r8 + 0x0] $r14\n\tst b32 D[$r8 + 0x4] $r15\n\n\t// update PUT\n\tadd b32 $r9 1\n\tand $r9 0xf\n\tst b32 D[$r13 + 0x4] $r9\n\tret\n\n// queue_get - fetch request from queue\n//\n// In : $r13 queue pointer\n//\n// Out:\t$p1  clear on success (data available)\n//\t$r14 command\n// \t$r15 data\n//\nqueue_get:\n\tbset $flags $p1\n\tld b32 $r8 D[$r13 + 0x0]\t// GET\n\tld b32 $r9 D[$r13 + 0x4]\t// PUT\n\tcmpu b32 $r8 $r9\n\tbra e #queue_get_done\n\t\t// fetch first cmd/data pair\n\t\tand $r9 $r8 7\n\t\tshl b32 $r9 3\n\t\tadd b32 $r9 $r13\n\t\tadd b32 $r9 8\n\t\tld b32 $r14 D[$r9 + 0x0]\n\t\tld b32 $r15 D[$r9 + 0x4]\n\n\t\t// update GET\n\t\tadd b32 $r8 1\n\t\tand $r8 0xf\n\t\tst b32 D[$r13 + 0x0] $r8\n\t\tbclr $flags $p1\nqueue_get_done:\n\tret\n\n// nv_rd32 - read 32-bit value from nv register\n//\n// In : $r14 register\n// Out: $r15 value\n//\nnv_rd32:\n\tmov b32 $r12 $r14\n\tbset $r12 31\t\t\t// MMIO_CTRL_PENDING\n\tnv_iowr(NV_PGRAPH_FECS_MMIO_CTRL, 0, $r12)\n\tnv_rd32_wait:\n\t\tnv_iord($r12, NV_PGRAPH_FECS_MMIO_CTRL, 0)\n\t\txbit $r12 $r12 31\n\t\tbra ne #nv_rd32_wait\n\tmov $r10 6\t\t\t// DONE_MMIO_RD\n\tcall(wait_doneo)\n\tnv_iord($r15, NV_PGRAPH_FECS_MMIO_RDVAL, 0)\n\tret\n\n// nv_wr32 - write 32-bit value to nv register\n//\n// In : $r14 register\n//      $r15 value\n//\nnv_wr32:\n\tnv_iowr(NV_PGRAPH_FECS_MMIO_WRVAL, 0, $r15)\n\tmov b32 $r12 $r14\n\tbset $r12 31\t\t\t// MMIO_CTRL_PENDING\n\tbset $r12 30\t\t\t// MMIO_CTRL_WRITE\n\tnv_iowr(NV_PGRAPH_FECS_MMIO_CTRL, 0, $r12)\n\tnv_wr32_wait:\n\t\tnv_iord($r12, NV_PGRAPH_FECS_MMIO_CTRL, 0)\n\t\txbit $r12 $r12 31\n\t\tbra ne #nv_wr32_wait\n\tret\n\n// wait_donez - wait on FUC_DONE bit to become clear\n//\n// In : $r10 bit to wait on\n//\nwait_donez:\n\ttrace_set(T_WAIT);\n\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(6), 0, $r10)\n\twait_donez_ne:\n\t\tnv_iord($r8, NV_PGRAPH_FECS_SIGNAL, 0)\n\t\txbit $r8 $r8 $r10\n\t\tbra ne #wait_donez_ne\n\ttrace_clr(T_WAIT)\n\tret\n\n// wait_doneo - wait on FUC_DONE bit to become set\n//\n// In : $r10 bit to wait on\n//\nwait_doneo:\n\ttrace_set(T_WAIT);\n\tnv_iowr(NV_PGRAPH_FECS_CC_SCRATCH_VAL(6), 0, $r10)\n\twait_doneo_e:\n\t\tnv_iord($r8, NV_PGRAPH_FECS_SIGNAL, 0)\n\t\txbit $r8 $r8 $r10\n\t\tbra e #wait_doneo_e\n\ttrace_clr(T_WAIT)\n\tret\n\n// mmctx_size - determine size of a mmio list transfer\n//\n// In : $r14 mmio list head\n//      $r15 mmio list tail\n// Out: $r15 transfer size (in bytes)\n//\nmmctx_size:\n\tclear b32 $r9\n\tnv_mmctx_size_loop:\n\t\tld b32 $r8 D[$r14]\n\t\tshr b32 $r8 26\n\t\tadd b32 $r8 1\n\t\tshl b32 $r8 2\n\t\tadd b32 $r9 $r8\n\t\tadd b32 $r14 4\n\t\tcmpu b32 $r14 $r15\n\t\tbra ne #nv_mmctx_size_loop\n\tmov b32 $r15 $r9\n\tret\n\n// mmctx_xfer - execute a list of mmio transfers\n//\n// In : $r10 flags\n//\t\tbit 0: direction (0 = save, 1 = load)\n//\t\tbit 1: set if first transfer\n//\t\tbit 2: set if last transfer\n//\t$r11 base\n//\t$r12 mmio list head\n//\t$r13 mmio list tail\n//\t$r14 multi_stride\n//\t$r15 multi_mask\n//\nmmctx_xfer:\n\ttrace_set(T_MMCTX)\n\tclear b32 $r9\n\tor $r11 $r11\n\tbra e #mmctx_base_disabled\n\t\tnv_iowr(NV_PGRAPH_FECS_MMCTX_BASE, 0, $r11)\n\t\tbset $r9 0\t\t\t// BASE_EN\n\tmmctx_base_disabled:\n\tor $r14 $r14\n\tbra e #mmctx_multi_disabled\n\t\tnv_iowr(NV_PGRAPH_FECS_MMCTX_MULTI_STRIDE, 0, $r14)\n\t\tnv_iowr(NV_PGRAPH_FECS_MMCTX_MULTI_MASK, 0, $r15)\n\t\tbset $r9 1\t\t\t// MULTI_EN\n\tmmctx_multi_disabled:\n\n\txbit $r11 $r10 0\n\tshl b32 $r11 16\t\t\t// DIR\n\tbset $r11 12\t\t\t// QLIMIT = 0x10\n\txbit $r14 $r10 1\n\tshl b32 $r14 17\n\tor $r11 $r14\t\t\t// START_TRIGGER\n\tnv_iowr(NV_PGRAPH_FECS_MMCTX_CTRL, 0, $r11)\n\n\t// loop over the mmio list, and send requests to the hw\n\tmmctx_exec_loop:\n\t\t// wait for space in mmctx queue\n\t\tmmctx_wait_free:\n\t\t\tnv_iord($r14, NV_PGRAPH_FECS_MMCTX_CTRL, 0)\n\t\t\tand $r14 0x1f\n\t\t\tbra e #mmctx_wait_free\n\n\t\t// queue up an entry\n\t\tld b32 $r14 D[$r12]\n\t\tor $r14 $r9\n\t\tnv_iowr(NV_PGRAPH_FECS_MMCTX_QUEUE, 0, $r14)\n\t\tadd b32 $r12 4\n\t\tcmpu b32 $r12 $r13\n\t\tbra ne #mmctx_exec_loop\n\n\txbit $r11 $r10 2\n\tbra ne #mmctx_stop\n\t\t// wait for queue to empty\n\t\tmmctx_fini_wait:\n\t\t\tnv_iord($r11, NV_PGRAPH_FECS_MMCTX_CTRL, 0)\n\t\t\tand $r11 0x1f\n\t\t\tcmpu b32 $r11 0x10\n\t\t\tbra ne #mmctx_fini_wait\n\t\tmov $r10 5\t\t\t// DONE_MMCTX\n\t\tcall(wait_donez)\n\t\tbra #mmctx_done\n\tmmctx_stop:\n\t\txbit $r11 $r10 0\n\t\tshl b32 $r11 16\t\t\t// DIR\n\t\tbset $r11 12\t\t\t// QLIMIT = 0x10\n\t\tbset $r11 18\t\t\t// STOP_TRIGGER\n\t\tnv_iowr(NV_PGRAPH_FECS_MMCTX_CTRL, 0, $r11)\n\t\tmmctx_stop_wait:\n\t\t\t// wait for STOP_TRIGGER to clear\n\t\t\tnv_iord($r11, NV_PGRAPH_FECS_MMCTX_CTRL, 0)\n\t\t\txbit $r11 $r11 18\n\t\t\tbra ne #mmctx_stop_wait\n\tmmctx_done:\n\ttrace_clr(T_MMCTX)\n\tret\n\n// Wait for DONE_STRAND\n//\nstrand_wait:\n\tpush $r10\n\tmov $r10 2\n\tcall(wait_donez)\n\tpop $r10\n\tret\n\n// unknown - call before issuing strand commands\n//\nstrand_pre:\n\tmov $r9 NV_PGRAPH_FECS_STRAND_CMD_ENABLE\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r9)\n\tcall(strand_wait)\n\tret\n\n// unknown - call after issuing strand commands\n//\nstrand_post:\n\tmov $r9 NV_PGRAPH_FECS_STRAND_CMD_DISABLE\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r9)\n\tcall(strand_wait)\n\tret\n\n// Selects strand set?!\n//\n// In: $r14 id\n//\nstrand_set:\n\tmov $r12 0xf\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_FILTER, 0x3f, $r12)\n\tmov $r12 NV_PGRAPH_FECS_STRAND_CMD_DEACTIVATE_FILTER\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r12)\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_FILTER, 0x3f, $r14)\n\tmov $r12 NV_PGRAPH_FECS_STRAND_CMD_ACTIVATE_FILTER\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r12)\n\tcall(strand_wait)\n\tret\n\n// Initialise strand context data\n//\n// In : $r15 context base\n// Out: $r15 context size (in bytes)\n//\n// Strandset(?) 3 hardcoded currently\n//\nstrand_ctx_init:\n\ttrace_set(T_STRINIT)\n\tcall(strand_pre)\n\tmov $r14 3\n\tcall(strand_set)\n\n\tclear b32 $r12\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_SELECT, 0x3f, $r12)\n\tmov $r12 NV_PGRAPH_FECS_STRAND_CMD_SEEK\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r12)\n\tcall(strand_wait)\n\tsub b32 $r12 $r0 1\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_DATA, 0x3f, $r12)\n\tmov $r12 NV_PGRAPH_FECS_STRAND_CMD_GET_INFO\n\tnv_iowr(NV_PGRAPH_FECS_STRAND_CMD, 0x3f, $r12)\n\tcall(strand_wait)\n\tcall(strand_post)\n\n\t// read the size of each strand, poke the context offset of\n\t// each into STRAND_{SAVE,LOAD}_SWBASE now, no need to worry\n\t// about it later then.\n\tnv_mkio($r8, NV_PGRAPH_FECS_STRAND_SAVE_SWBASE, 0x00)\n\tnv_iord($r9, NV_PGRAPH_FECS_STRANDS_CNT, 0x00)\n\tshr b32 $r14 $r15 8\n\tctx_init_strand_loop:\n\t\tiowr I[$r8 + 0x000] $r14\t// STRAND_SAVE_SWBASE\n\t\tiowr I[$r8 + 0x100] $r14\t// STRAND_LOAD_SWBASE\n\t\tiord $r10 I[$r8 + 0x200]\t// STRAND_SIZE\n\t\tshr b32 $r10 6\n\t\tadd b32 $r10 1\n\t\tadd b32 $r14 $r10\n\t\tadd b32 $r8 4\n\t\tsub b32 $r9 1\n\t\tbra ne #ctx_init_strand_loop\n\n\tshl b32 $r14 8\n\tsub b32 $r15 $r14 $r15\n\ttrace_clr(T_STRINIT)\n\tret\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}