{
  "module_name": "gf100.c",
  "hash_id": "980be476bc0d423297fec580009bb97a8a5c3891e176b4102fbeb2e5ac4e7464",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gf100.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n#include \"runq.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/bar.h>\n#include <subdev/fault.h>\n#include <subdev/mc.h>\n#include <subdev/mmu.h>\n#include <engine/sw.h>\n\n#include <nvif/class.h>\n\nvoid\ngf100_chan_preempt(struct nvkm_chan *chan)\n{\n\tnvkm_wr32(chan->cgrp->runl->fifo->engine.subdev.device, 0x002634, chan->id);\n}\n\nstatic void\ngf100_chan_stop(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x003004 + (chan->id * 8), 0x00000001, 0x00000000);\n}\n\nstatic void\ngf100_chan_start(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x003004 + (chan->id * 8), 0x001f0001);\n}\n\nstatic void gf100_fifo_intr_engine(struct nvkm_fifo *);\n\nstatic void\ngf100_chan_unbind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_fifo *fifo = chan->cgrp->runl->fifo;\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\n\t \n\tgf100_fifo_intr_engine(fifo);\n\n\tnvkm_wr32(device, 0x003000 + (chan->id * 8), 0x00000000);\n}\n\nstatic void\ngf100_chan_bind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x003000 + (chan->id * 8), 0xc0000000 | chan->inst->addr >> 12);\n}\n\nstatic int\ngf100_chan_ramfc_write(struct nvkm_chan *chan, u64 offset, u64 length, u32 devm, bool priv)\n{\n\tconst u64 userd = nvkm_memory_addr(chan->userd.mem) + chan->userd.base;\n\tconst u32 limit2 = ilog2(length / 8);\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x08, lower_32_bits(userd));\n\tnvkm_wo32(chan->inst, 0x0c, upper_32_bits(userd));\n\tnvkm_wo32(chan->inst, 0x10, 0x0000face);\n\tnvkm_wo32(chan->inst, 0x30, 0xfffff902);\n\tnvkm_wo32(chan->inst, 0x48, lower_32_bits(offset));\n\tnvkm_wo32(chan->inst, 0x4c, upper_32_bits(offset) | (limit2 << 16));\n\tnvkm_wo32(chan->inst, 0x54, 0x00000002);\n\tnvkm_wo32(chan->inst, 0x84, 0x20400000);\n\tnvkm_wo32(chan->inst, 0x94, 0x30000000 | devm);\n\tnvkm_wo32(chan->inst, 0x9c, 0x00000100);\n\tnvkm_wo32(chan->inst, 0xa4, 0x1f1f1f1f);\n\tnvkm_wo32(chan->inst, 0xa8, 0x1f1f1f1f);\n\tnvkm_wo32(chan->inst, 0xac, 0x0000001f);\n\tnvkm_wo32(chan->inst, 0xb8, 0xf8000000);\n\tnvkm_wo32(chan->inst, 0xf8, 0x10003080);  \n\tnvkm_wo32(chan->inst, 0xfc, 0x10000010);  \n\tnvkm_done(chan->inst);\n\treturn 0;\n}\n\nstatic const struct nvkm_chan_func_ramfc\ngf100_chan_ramfc = {\n\t.write = gf100_chan_ramfc_write,\n\t.devm = 0xfff,\n};\n\nvoid\ngf100_chan_userd_clear(struct nvkm_chan *chan)\n{\n\tnvkm_kmap(chan->userd.mem);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x040, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x044, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x048, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x04c, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x050, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x058, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x05c, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x060, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x088, 0x00000000);\n\tnvkm_wo32(chan->userd.mem, chan->userd.base + 0x08c, 0x00000000);\n\tnvkm_done(chan->userd.mem);\n}\n\nstatic const struct nvkm_chan_func_userd\ngf100_chan_userd = {\n\t.bar = 1,\n\t.size = 0x1000,\n\t.clear = gf100_chan_userd_clear,\n};\n\nconst struct nvkm_chan_func_inst\ngf100_chan_inst = {\n\t.size = 0x1000,\n\t.zero = true,\n\t.vmm = true,\n};\n\nstatic const struct nvkm_chan_func\ngf100_chan = {\n\t.inst = &gf100_chan_inst,\n\t.userd = &gf100_chan_userd,\n\t.ramfc = &gf100_chan_ramfc,\n\t.bind = gf100_chan_bind,\n\t.unbind = gf100_chan_unbind,\n\t.start = gf100_chan_start,\n\t.stop = gf100_chan_stop,\n\t.preempt = gf100_chan_preempt,\n};\n\nstatic void\ngf100_ectx_bind(struct nvkm_engn *engn, struct nvkm_cctx *cctx, struct nvkm_chan *chan)\n{\n\tu64 addr = 0ULL;\n\tu32 ptr0;\n\n\tswitch (engn->engine->subdev.type) {\n\tcase NVKM_ENGINE_SW    : return;\n\tcase NVKM_ENGINE_GR    : ptr0 = 0x0210; break;\n\tcase NVKM_ENGINE_CE    : ptr0 = 0x0230 + (engn->engine->subdev.inst * 0x10); break;\n\tcase NVKM_ENGINE_MSPDEC: ptr0 = 0x0250; break;\n\tcase NVKM_ENGINE_MSPPP : ptr0 = 0x0260; break;\n\tcase NVKM_ENGINE_MSVLD : ptr0 = 0x0270; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (cctx) {\n\t\taddr  = cctx->vctx->vma->addr;\n\t\taddr |= 4ULL;\n\t}\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, ptr0 + 0, lower_32_bits(addr));\n\tnvkm_wo32(chan->inst, ptr0 + 4, upper_32_bits(addr));\n\tnvkm_done(chan->inst);\n}\n\nstatic int\ngf100_ectx_ctor(struct nvkm_engn *engn, struct nvkm_vctx *vctx)\n{\n\tint ret;\n\n\tret = nvkm_vmm_get(vctx->vmm, 12, vctx->inst->size, &vctx->vma);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nvkm_memory_map(vctx->inst, 0, vctx->vmm, vctx->vma, NULL, 0);\n}\n\nbool\ngf100_engn_mmu_fault_triggered(struct nvkm_engn *engn)\n{\n\tstruct nvkm_runl *runl = engn->runl;\n\tstruct nvkm_fifo *fifo = runl->fifo;\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tu32 data = nvkm_rd32(device, 0x002a30 + (engn->id * 4));\n\n\tENGN_DEBUG(engn, \"%08x: mmu fault triggered\", data);\n\tif (!(data & 0x00000100))\n\t\treturn false;\n\n\tspin_lock(&fifo->lock);\n\tnvkm_mask(device, 0x002a30 + (engn->id * 4), 0x00000100, 0x00000000);\n\tif (atomic_dec_and_test(&runl->rc_triggered))\n\t\tnvkm_mask(device, 0x002140, 0x00000100, 0x00000100);\n\tspin_unlock(&fifo->lock);\n\treturn true;\n}\n\nvoid\ngf100_engn_mmu_fault_trigger(struct nvkm_engn *engn)\n{\n\tstruct nvkm_runl *runl = engn->runl;\n\tstruct nvkm_fifo *fifo = runl->fifo;\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\n\tENGN_DEBUG(engn, \"triggering mmu fault on 0x%02x\", engn->fault);\n\tspin_lock(&fifo->lock);\n\tif (atomic_inc_return(&runl->rc_triggered) == 1)\n\t\tnvkm_mask(device, 0x002140, 0x00000100, 0x00000000);\n\tnvkm_wr32(device, 0x002100, 0x00000100);\n\tnvkm_wr32(device, 0x002a30 + (engn->id * 4), 0x00000100 | engn->fault);\n\tspin_unlock(&fifo->lock);\n}\n\n \nstruct gf100_engn_status {\n\tbool busy;\n\tbool save;\n\tbool unk0;\n\tbool unk1;\n\tu8   chid;\n};\n\nstatic void\ngf100_engn_status(struct nvkm_engn *engn, struct gf100_engn_status *status)\n{\n\tu32 stat = nvkm_rd32(engn->engine->subdev.device, 0x002640 + (engn->id * 4));\n\n\tstatus->busy = (stat & 0x10000000);\n\tstatus->save = (stat & 0x00100000);\n\tstatus->unk0 = (stat & 0x00004000);\n\tstatus->unk1 = (stat & 0x00001000);\n\tstatus->chid = (stat & 0x0000007f);\n\n\tENGN_DEBUG(engn, \"%08x: busy %d save %d unk0 %d unk1 %d chid %d\",\n\t\t   stat, status->busy, status->save, status->unk0, status->unk1, status->chid);\n}\n\nstatic int\ngf100_engn_cxid(struct nvkm_engn *engn, bool *cgid)\n{\n\tstruct gf100_engn_status status;\n\n\tgf100_engn_status(engn, &status);\n\tif (status.busy) {\n\t\t*cgid = false;\n\t\treturn status.chid;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic bool\ngf100_engn_chsw(struct nvkm_engn *engn)\n{\n\tstruct gf100_engn_status status;\n\n\tgf100_engn_status(engn, &status);\n\tif (status.busy && (status.unk0 || status.unk1))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct nvkm_engn_func\ngf100_engn = {\n\t.chsw = gf100_engn_chsw,\n\t.cxid = gf100_engn_cxid,\n\t.mmu_fault_trigger = gf100_engn_mmu_fault_trigger,\n\t.mmu_fault_triggered = gf100_engn_mmu_fault_triggered,\n\t.ctor = gf100_ectx_ctor,\n\t.bind = gf100_ectx_bind,\n};\n\nconst struct nvkm_engn_func\ngf100_engn_sw = {\n};\n\nstatic const struct nvkm_bitfield\ngf100_runq_intr_0_names[] = {\n \n\t{ 0x00200000, \"ILLEGAL_MTHD\" },\n\t{ 0x00800000, \"EMPTY_SUBC\" },\n\t{}\n};\n\nbool\ngf100_runq_intr(struct nvkm_runq *runq, struct nvkm_runl *null)\n{\n\tstruct nvkm_subdev *subdev = &runq->fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mask = nvkm_rd32(device, 0x04010c + (runq->id * 0x2000));\n\tu32 stat = nvkm_rd32(device, 0x040108 + (runq->id * 0x2000)) & mask;\n\tu32 addr = nvkm_rd32(device, 0x0400c0 + (runq->id * 0x2000));\n\tu32 data = nvkm_rd32(device, 0x0400c4 + (runq->id * 0x2000));\n\tu32 chid = nvkm_rd32(device, 0x040120 + (runq->id * 0x2000)) & runq->fifo->chid->mask;\n\tu32 subc = (addr & 0x00070000) >> 16;\n\tu32 mthd = (addr & 0x00003ffc);\n\tu32 show = stat;\n\tstruct nvkm_chan *chan;\n\tunsigned long flags;\n\tchar msg[128];\n\n\tif (stat & 0x00800000) {\n\t\tif (device->sw) {\n\t\t\tif (nvkm_sw_mthd(device->sw, chid, subc, mthd, data))\n\t\t\t\tshow &= ~0x00800000;\n\t\t}\n\t}\n\n\tif (show) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), runq->func->intr_0_names, show);\n\t\tchan = nvkm_chan_get_chid(&runq->fifo->engine, chid, &flags);\n\t\tnvkm_error(subdev, \"PBDMA%d: %08x [%s] ch %d [%010llx %s] \"\n\t\t\t\t   \"subc %d mthd %04x data %08x\\n\",\n\t\t\t   runq->id, show, msg, chid, chan ? chan->inst->addr : 0,\n\t\t\t   chan ? chan->name : \"unknown\", subc, mthd, data);\n\n\t\t \n\t\tif ((stat & 0xc67fe000) && chan)\n\t\t\tnvkm_chan_error(chan, true);\n\t\tnvkm_chan_put(&chan, flags);\n\t}\n\n\tnvkm_wr32(device, 0x0400c0 + (runq->id * 0x2000), 0x80600008);\n\tnvkm_wr32(device, 0x040108 + (runq->id * 0x2000), stat);\n\treturn true;\n}\n\nvoid\ngf100_runq_init(struct nvkm_runq *runq)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x04013c + (runq->id * 0x2000), 0x10000100, 0x00000000);\n\tnvkm_wr32(device, 0x040108 + (runq->id * 0x2000), 0xffffffff);  \n\tnvkm_wr32(device, 0x04010c + (runq->id * 0x2000), 0xfffffeff);  \n}\n\nstatic const struct nvkm_runq_func\ngf100_runq = {\n\t.init = gf100_runq_init,\n\t.intr = gf100_runq_intr,\n\t.intr_0_names = gf100_runq_intr_0_names,\n};\n\nbool\ngf100_runl_preempt_pending(struct nvkm_runl *runl)\n{\n\treturn nvkm_rd32(runl->fifo->engine.subdev.device, 0x002634) & 0x00100000;\n}\n\nstatic void\ngf100_runl_fault_clear(struct nvkm_runl *runl)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, 0x00262c, 0x00000000, 0x00000000);\n}\n\nstatic void\ngf100_runl_allow(struct nvkm_runl *runl, u32 engm)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, 0x002630, engm, 0x00000000);\n}\n\nstatic void\ngf100_runl_block(struct nvkm_runl *runl, u32 engm)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, 0x002630, engm, engm);\n}\n\nstatic bool\ngf100_runl_pending(struct nvkm_runl *runl)\n{\n\treturn nvkm_rd32(runl->fifo->engine.subdev.device, 0x00227c) & 0x00100000;\n}\n\nstatic void\ngf100_runl_commit(struct nvkm_runl *runl, struct nvkm_memory *memory, u32 start, int count)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tu64 addr = nvkm_memory_addr(memory) + start;\n\tint target;\n\n\tswitch (nvkm_memory_target(memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: target = 0; break;\n\tcase NVKM_MEM_TARGET_NCOH: target = 3; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tnvkm_wr32(device, 0x002270, (target << 28) | (addr >> 12));\n\tnvkm_wr32(device, 0x002274, 0x01f00000 | count);\n}\n\nstatic void\ngf100_runl_insert_chan(struct nvkm_chan *chan, struct nvkm_memory *memory, u64 offset)\n{\n\tnvkm_wo32(memory, offset + 0, chan->id);\n\tnvkm_wo32(memory, offset + 4, 0x00000004);\n}\n\nstatic const struct nvkm_runl_func\ngf100_runl = {\n\t.size = 8,\n\t.update = nv50_runl_update,\n\t.insert_chan = gf100_runl_insert_chan,\n\t.commit = gf100_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = gf100_runl_pending,\n\t.block = gf100_runl_block,\n\t.allow = gf100_runl_allow,\n\t.fault_clear = gf100_runl_fault_clear,\n\t.preempt_pending = gf100_runl_preempt_pending,\n};\n\nstatic void\ngf100_fifo_nonstall_allow(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fifo *fifo = container_of(event, typeof(*fifo), nonstall.event);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fifo->lock, flags);\n\tnvkm_mask(fifo->engine.subdev.device, 0x002140, 0x80000000, 0x80000000);\n\tspin_unlock_irqrestore(&fifo->lock, flags);\n}\n\nstatic void\ngf100_fifo_nonstall_block(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fifo *fifo = container_of(event, typeof(*fifo), nonstall.event);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fifo->lock, flags);\n\tnvkm_mask(fifo->engine.subdev.device, 0x002140, 0x80000000, 0x00000000);\n\tspin_unlock_irqrestore(&fifo->lock, flags);\n}\n\nconst struct nvkm_event_func\ngf100_fifo_nonstall = {\n\t.init = gf100_fifo_nonstall_allow,\n\t.fini = gf100_fifo_nonstall_block,\n};\n\nstatic const struct nvkm_enum\ngf100_fifo_mmu_fault_engine[] = {\n\t{ 0x00, \"PGRAPH\", NULL, NVKM_ENGINE_GR },\n\t{ 0x03, \"PEEPHOLE\", NULL, NVKM_ENGINE_IFB },\n\t{ 0x04, \"BAR1\", NULL, NVKM_SUBDEV_BAR },\n\t{ 0x05, \"BAR3\", NULL, NVKM_SUBDEV_INSTMEM },\n\t{ 0x07, \"PFIFO\" },\n\t{ 0x10, \"PMSVLD\", NULL, NVKM_ENGINE_MSVLD },\n\t{ 0x11, \"PMSPPP\", NULL, NVKM_ENGINE_MSPPP },\n\t{ 0x13, \"PCOUNTER\" },\n\t{ 0x14, \"PMSPDEC\", NULL, NVKM_ENGINE_MSPDEC },\n\t{ 0x15, \"PCE0\", NULL, NVKM_ENGINE_CE, 0 },\n\t{ 0x16, \"PCE1\", NULL, NVKM_ENGINE_CE, 1 },\n\t{ 0x17, \"PMU\" },\n\t{}\n};\n\nstatic const struct nvkm_enum\ngf100_fifo_mmu_fault_reason[] = {\n\t{ 0x00, \"PT_NOT_PRESENT\" },\n\t{ 0x01, \"PT_TOO_SHORT\" },\n\t{ 0x02, \"PAGE_NOT_PRESENT\" },\n\t{ 0x03, \"VM_LIMIT_EXCEEDED\" },\n\t{ 0x04, \"NO_CHANNEL\" },\n\t{ 0x05, \"PAGE_SYSTEM_ONLY\" },\n\t{ 0x06, \"PAGE_READ_ONLY\" },\n\t{ 0x0a, \"COMPRESSED_SYSRAM\" },\n\t{ 0x0c, \"INVALID_STORAGE_TYPE\" },\n\t{}\n};\n\nstatic const struct nvkm_enum\ngf100_fifo_mmu_fault_hubclient[] = {\n\t{ 0x01, \"PCOPY0\" },\n\t{ 0x02, \"PCOPY1\" },\n\t{ 0x04, \"DISPATCH\" },\n\t{ 0x05, \"CTXCTL\" },\n\t{ 0x06, \"PFIFO\" },\n\t{ 0x07, \"BAR_READ\" },\n\t{ 0x08, \"BAR_WRITE\" },\n\t{ 0x0b, \"PVP\" },\n\t{ 0x0c, \"PMSPPP\" },\n\t{ 0x0d, \"PMSVLD\" },\n\t{ 0x11, \"PCOUNTER\" },\n\t{ 0x12, \"PMU\" },\n\t{ 0x14, \"CCACHE\" },\n\t{ 0x15, \"CCACHE_POST\" },\n\t{}\n};\n\nstatic const struct nvkm_enum\ngf100_fifo_mmu_fault_gpcclient[] = {\n\t{ 0x01, \"TEX\" },\n\t{ 0x0c, \"ESETUP\" },\n\t{ 0x0e, \"CTXCTL\" },\n\t{ 0x0f, \"PROP\" },\n\t{}\n};\n\nconst struct nvkm_enum\ngf100_fifo_mmu_fault_access[] = {\n\t{ 0x00, \"READ\" },\n\t{ 0x01, \"WRITE\" },\n\t{}\n};\n\nvoid\ngf100_fifo_mmu_fault_recover(struct nvkm_fifo *fifo, struct nvkm_fault_data *info)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst struct nvkm_enum *er, *ee, *ec, *ea;\n\tstruct nvkm_engine *engine = NULL;\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\tstruct nvkm_chan *chan;\n\tunsigned long flags;\n\tchar ct[8] = \"HUB/\";\n\n\t \n\tnvkm_runl_foreach(runl, fifo) {\n\t\tengn = nvkm_runl_find_engn(engn, runl, engn->fault == info->engine);\n\t\tif (engn) {\n\t\t\t \n\t\t\tif (engn->func->mmu_fault_triggered &&\n\t\t\t    engn->func->mmu_fault_triggered(engn)) {\n\t\t\t\tnvkm_runl_rc_engn(runl, engn);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tengine = engn->engine;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ter = nvkm_enum_find(fifo->func->mmu_fault->reason, info->reason);\n\tee = nvkm_enum_find(fifo->func->mmu_fault->engine, info->engine);\n\tif (info->hub) {\n\t\tec = nvkm_enum_find(fifo->func->mmu_fault->hubclient, info->client);\n\t} else {\n\t\tec = nvkm_enum_find(fifo->func->mmu_fault->gpcclient, info->client);\n\t\tsnprintf(ct, sizeof(ct), \"GPC%d/\", info->gpc);\n\t}\n\tea = nvkm_enum_find(fifo->func->mmu_fault->access, info->access);\n\n\t \n\tif (ee && ee->data2) {\n\t\tswitch (ee->data2) {\n\t\tcase NVKM_SUBDEV_BAR:\n\t\t\tnvkm_bar_bar1_reset(device);\n\t\t\tbreak;\n\t\tcase NVKM_SUBDEV_INSTMEM:\n\t\t\tnvkm_bar_bar2_reset(device);\n\t\t\tbreak;\n\t\tcase NVKM_ENGINE_IFB:\n\t\t\tnvkm_mask(device, 0x001718, 0x00000000, 0x00000000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tchan = nvkm_chan_get_inst(&fifo->engine, info->inst, &flags);\n\n\tnvkm_error(subdev,\n\t\t   \"fault %02x [%s] at %016llx engine %02x [%s] client %02x \"\n\t\t   \"[%s%s] reason %02x [%s] on channel %d [%010llx %s]\\n\",\n\t\t   info->access, ea ? ea->name : \"\", info->addr,\n\t\t   info->engine, ee ? ee->name : engine ? engine->subdev.name : \"\",\n\t\t   info->client, ct, ec ? ec->name : \"\",\n\t\t   info->reason, er ? er->name : \"\",\n\t\t   chan ? chan->id : -1, info->inst, chan ? chan->name : \"unknown\");\n\n\t \n\tif (chan)\n\t\tnvkm_runl_rc_cgrp(chan->cgrp);\n\n\tnvkm_chan_put(&chan, flags);\n}\n\nstatic const struct nvkm_fifo_func_mmu_fault\ngf100_fifo_mmu_fault = {\n\t.recover = gf100_fifo_mmu_fault_recover,\n\t.access = gf100_fifo_mmu_fault_access,\n\t.engine = gf100_fifo_mmu_fault_engine,\n\t.reason = gf100_fifo_mmu_fault_reason,\n\t.hubclient = gf100_fifo_mmu_fault_hubclient,\n\t.gpcclient = gf100_fifo_mmu_fault_gpcclient,\n};\n\nvoid\ngf100_fifo_intr_ctxsw_timeout(struct nvkm_fifo *fifo, u32 engm)\n{\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn, *engn2;\n\tbool cgid, cgid2;\n\tint id, id2;\n\n\tnvkm_runl_foreach(runl, fifo) {\n\t\t \n\t\tnvkm_runl_block(runl);\n\t\tnvkm_runl_foreach_engn_cond(engn, runl, engm & BIT(engn->id)) {\n\t\t\t \n\t\t\tid = engn->func->cxid(engn, &cgid);\n\t\t\tif (id >= 0) {\n\t\t\t\t \n\t\t\t\tnvkm_runl_foreach_engn_cond(engn2, runl, engn2->func->cxid) {\n\t\t\t\t\tid2 = engn2->func->cxid(engn2, &cgid2);\n\t\t\t\t\tif (cgid2 == cgid && id2 == id)\n\t\t\t\t\t\tengn2->func->mmu_fault_trigger(engn2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnvkm_runl_allow(runl);  \n\t}\n}\n\nstatic void\ngf100_fifo_intr_sched_ctxsw(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\tu32 engm = 0;\n\n\t \n\tnvkm_runl_foreach(runl, fifo) {\n\t\tnvkm_runl_foreach_engn_cond(engn, runl, engn->func->chsw) {\n\t\t\tif (WARN_ON(engn->fault < 0) || !engn->func->chsw(engn))\n\t\t\t\tcontinue;\n\n\t\t\tengm |= BIT(engn->id);\n\t\t}\n\t}\n\n\tif (!engm)\n\t\treturn;\n\n\tfifo->func->intr_ctxsw_timeout(fifo, engm);\n}\n\nstatic const struct nvkm_enum\ngf100_fifo_intr_sched_names[] = {\n\t{ 0x0a, \"CTXSW_TIMEOUT\" },\n\t{}\n};\n\nvoid\ngf100_fifo_intr_sched(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 intr = nvkm_rd32(device, 0x00254c);\n\tu32 code = intr & 0x000000ff;\n\tconst struct nvkm_enum *en;\n\n\ten = nvkm_enum_find(gf100_fifo_intr_sched_names, code);\n\n\tnvkm_error(subdev, \"SCHED_ERROR %02x [%s]\\n\", code, en ? en->name : \"\");\n\n\tswitch (code) {\n\tcase 0x0a:\n\t\tgf100_fifo_intr_sched_ctxsw(fifo);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid\ngf100_fifo_intr_mmu_fault_unit(struct nvkm_fifo *fifo, int unit)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tu32 inst = nvkm_rd32(device, 0x002800 + (unit * 0x10));\n\tu32 valo = nvkm_rd32(device, 0x002804 + (unit * 0x10));\n\tu32 vahi = nvkm_rd32(device, 0x002808 + (unit * 0x10));\n\tu32 type = nvkm_rd32(device, 0x00280c + (unit * 0x10));\n\tstruct nvkm_fault_data info;\n\n\tinfo.inst   =  (u64)inst << 12;\n\tinfo.addr   = ((u64)vahi << 32) | valo;\n\tinfo.time   = 0;\n\tinfo.engine = unit;\n\tinfo.valid  = 1;\n\tinfo.gpc    = (type & 0x1f000000) >> 24;\n\tinfo.client = (type & 0x00001f00) >> 8;\n\tinfo.access = (type & 0x00000080) >> 7;\n\tinfo.hub    = (type & 0x00000040) >> 6;\n\tinfo.reason = (type & 0x0000000f);\n\n\tnvkm_fifo_fault(fifo, &info);\n}\n\nvoid\ngf100_fifo_intr_mmu_fault(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tunsigned long mask = nvkm_rd32(device, 0x00259c);\n\tint unit;\n\n\tfor_each_set_bit(unit, &mask, 32) {\n\t\tfifo->func->intr_mmu_fault_unit(fifo, unit);\n\t\tnvkm_wr32(device, 0x00259c, BIT(unit));\n\t}\n}\n\nbool\ngf100_fifo_intr_pbdma(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_runq *runq;\n\tu32 mask = nvkm_rd32(device, 0x0025a0);\n\tbool handled = false;\n\n\tnvkm_runq_foreach_cond(runq, fifo, mask & BIT(runq->id)) {\n\t\tif (runq->func->intr(runq, NULL))\n\t\t\thandled = true;\n\n\t\tnvkm_wr32(device, 0x0025a0, BIT(runq->id));\n\t}\n\n\treturn handled;\n}\n\nstatic void\ngf100_fifo_intr_runlist(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 intr = nvkm_rd32(device, 0x002a00);\n\n\tif (intr & 0x10000000) {\n\t\tnvkm_wr32(device, 0x002a00, 0x10000000);\n\t\tintr &= ~0x10000000;\n\t}\n\n\tif (intr) {\n\t\tnvkm_error(subdev, \"RUNLIST %08x\\n\", intr);\n\t\tnvkm_wr32(device, 0x002a00, intr);\n\t}\n}\n\nstatic void\ngf100_fifo_intr_engine_unit(struct nvkm_fifo *fifo, int engn)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 intr = nvkm_rd32(device, 0x0025a8 + (engn * 0x04));\n\tu32 inte = nvkm_rd32(device, 0x002628);\n\tu32 unkn;\n\n\tnvkm_wr32(device, 0x0025a8 + (engn * 0x04), intr);\n\n\tfor (unkn = 0; unkn < 8; unkn++) {\n\t\tu32 ints = (intr >> (unkn * 0x04)) & inte;\n\t\tif (ints & 0x1) {\n\t\t\tnvkm_event_ntfy(&fifo->nonstall.event, 0, NVKM_FIFO_NONSTALL_EVENT);\n\t\t\tints &= ~1;\n\t\t}\n\t\tif (ints) {\n\t\t\tnvkm_error(subdev, \"ENGINE %d %d %01x\", engn, unkn, ints);\n\t\t\tnvkm_mask(device, 0x002628, ints, 0);\n\t\t}\n\t}\n}\n\nstatic void\ngf100_fifo_intr_engine(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tu32 mask = nvkm_rd32(device, 0x0025a4);\n\n\twhile (mask) {\n\t\tu32 unit = __ffs(mask);\n\t\tgf100_fifo_intr_engine_unit(fifo, unit);\n\t\tmask &= ~(1 << unit);\n\t}\n}\n\nstatic irqreturn_t\ngf100_fifo_intr(struct nvkm_inth *inth)\n{\n\tstruct nvkm_fifo *fifo = container_of(inth, typeof(*fifo), engine.subdev.inth);\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mask = nvkm_rd32(device, 0x002140);\n\tu32 stat = nvkm_rd32(device, 0x002100) & mask;\n\n\tif (stat & 0x00000001) {\n\t\tu32 intr = nvkm_rd32(device, 0x00252c);\n\t\tnvkm_warn(subdev, \"INTR 00000001: %08x\\n\", intr);\n\t\tnvkm_wr32(device, 0x002100, 0x00000001);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (stat & 0x00000100) {\n\t\tgf100_fifo_intr_sched(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00000100);\n\t\tstat &= ~0x00000100;\n\t}\n\n\tif (stat & 0x00010000) {\n\t\tu32 intr = nvkm_rd32(device, 0x00256c);\n\t\tnvkm_warn(subdev, \"INTR 00010000: %08x\\n\", intr);\n\t\tnvkm_wr32(device, 0x002100, 0x00010000);\n\t\tstat &= ~0x00010000;\n\t}\n\n\tif (stat & 0x01000000) {\n\t\tu32 intr = nvkm_rd32(device, 0x00258c);\n\t\tnvkm_warn(subdev, \"INTR 01000000: %08x\\n\", intr);\n\t\tnvkm_wr32(device, 0x002100, 0x01000000);\n\t\tstat &= ~0x01000000;\n\t}\n\n\tif (stat & 0x10000000) {\n\t\tgf100_fifo_intr_mmu_fault(fifo);\n\t\tstat &= ~0x10000000;\n\t}\n\n\tif (stat & 0x20000000) {\n\t\tif (gf100_fifo_intr_pbdma(fifo))\n\t\t\tstat &= ~0x20000000;\n\t}\n\n\tif (stat & 0x40000000) {\n\t\tgf100_fifo_intr_runlist(fifo);\n\t\tstat &= ~0x40000000;\n\t}\n\n\tif (stat & 0x80000000) {\n\t\tgf100_fifo_intr_engine(fifo);\n\t\tstat &= ~0x80000000;\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"INTR %08x\\n\", stat);\n\t\tspin_lock(&fifo->lock);\n\t\tnvkm_mask(device, 0x002140, stat, 0x00000000);\n\t\tspin_unlock(&fifo->lock);\n\t\tnvkm_wr32(device, 0x002100, stat);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ngf100_fifo_init_pbdmas(struct nvkm_fifo *fifo, u32 mask)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\n\t \n\tnvkm_wr32(device, 0x000204, mask);\n\tnvkm_wr32(device, 0x002204, mask);\n\n\t \n\tif ((mask & 7) == 7) {\n\t\tnvkm_wr32(device, 0x002208, ~(1 << 0));  \n\t\tnvkm_wr32(device, 0x00220c, ~(1 << 1));  \n\t\tnvkm_wr32(device, 0x002210, ~(1 << 1));  \n\t\tnvkm_wr32(device, 0x002214, ~(1 << 1));  \n\t\tnvkm_wr32(device, 0x002218, ~(1 << 2));  \n\t\tnvkm_wr32(device, 0x00221c, ~(1 << 1));  \n\t}\n\n\tnvkm_mask(device, 0x002a04, 0xbfffffff, 0xbfffffff);\n}\n\nstatic void\ngf100_fifo_init(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x002200, 0x00000001, 0x00000001);\n\tnvkm_wr32(device, 0x002254, 0x10000000 | fifo->userd.bar1->addr >> 12);\n\n\tnvkm_wr32(device, 0x002100, 0xffffffff);\n\tnvkm_wr32(device, 0x002140, 0x7fffffff);\n\tnvkm_wr32(device, 0x002628, 0x00000001);  \n}\n\nstatic int\ngf100_fifo_runl_ctor(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_runl *runl;\n\n\trunl = nvkm_runl_new(fifo, 0, 0, 0);\n\tif (IS_ERR(runl))\n\t\treturn PTR_ERR(runl);\n\n\tnvkm_runl_add(runl,  0, fifo->func->engn, NVKM_ENGINE_GR, 0);\n\tnvkm_runl_add(runl,  1, fifo->func->engn, NVKM_ENGINE_MSPDEC, 0);\n\tnvkm_runl_add(runl,  2, fifo->func->engn, NVKM_ENGINE_MSPPP, 0);\n\tnvkm_runl_add(runl,  3, fifo->func->engn, NVKM_ENGINE_MSVLD, 0);\n\tnvkm_runl_add(runl,  4, fifo->func->engn, NVKM_ENGINE_CE, 0);\n\tnvkm_runl_add(runl,  5, fifo->func->engn, NVKM_ENGINE_CE, 1);\n\tnvkm_runl_add(runl, 15,   &gf100_engn_sw, NVKM_ENGINE_SW, 0);\n\treturn 0;\n}\n\nint\ngf100_fifo_runq_nr(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tu32 save;\n\n\t \n\tsave = nvkm_mask(device, 0x000204, 0xffffffff, 0xffffffff);\n\tsave = nvkm_mask(device, 0x000204, 0xffffffff, save);\n\treturn hweight32(save);\n}\n\nint\ngf100_fifo_chid_ctor(struct nvkm_fifo *fifo, int nr)\n{\n\treturn nvkm_chid_new(&nvkm_chan_event, &fifo->engine.subdev, nr, 0, nr, &fifo->chid);\n}\n\nstatic const struct nvkm_fifo_func\ngf100_fifo = {\n\t.chid_nr = nv50_fifo_chid_nr,\n\t.chid_ctor = gf100_fifo_chid_ctor,\n\t.runq_nr = gf100_fifo_runq_nr,\n\t.runl_ctor = gf100_fifo_runl_ctor,\n\t.init = gf100_fifo_init,\n\t.init_pbdmas = gf100_fifo_init_pbdmas,\n\t.intr = gf100_fifo_intr,\n\t.intr_mmu_fault_unit = gf100_fifo_intr_mmu_fault_unit,\n\t.intr_ctxsw_timeout = gf100_fifo_intr_ctxsw_timeout,\n\t.mmu_fault = &gf100_fifo_mmu_fault,\n\t.nonstall = &gf100_fifo_nonstall,\n\t.runl = &gf100_runl,\n\t.runq = &gf100_runq,\n\t.engn = &gf100_engn,\n\t.cgrp = {{                            }, &nv04_cgrp },\n\t.chan = {{ 0, 0, FERMI_CHANNEL_GPFIFO }, &gf100_chan },\n};\n\nint\ngf100_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&gf100_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}