{
  "module_name": "gk110.c",
  "hash_id": "63915634857d3e44ad2687b321324bd8d9b16bf2f0da91f798ce9b7c4a89e2aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gk110.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n\n#include <core/memory.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nvoid\ngk110_chan_preempt(struct nvkm_chan *chan)\n{\n\tstruct nvkm_cgrp *cgrp = chan->cgrp;\n\n\tif (cgrp->hw) {\n\t\tcgrp->func->preempt(cgrp);\n\t\treturn;\n\t}\n\n\tgf100_chan_preempt(chan);\n}\n\nconst struct nvkm_chan_func\ngk110_chan = {\n\t.inst = &gf100_chan_inst,\n\t.userd = &gk104_chan_userd,\n\t.ramfc = &gk104_chan_ramfc,\n\t.bind = gk104_chan_bind,\n\t.unbind = gk104_chan_unbind,\n\t.start = gk104_chan_start,\n\t.stop = gk104_chan_stop,\n\t.preempt = gk110_chan_preempt,\n};\n\nstatic void\ngk110_cgrp_preempt(struct nvkm_cgrp *cgrp)\n{\n\tnvkm_wr32(cgrp->runl->fifo->engine.subdev.device, 0x002634, 0x01000000 | cgrp->id);\n}\n\nconst struct nvkm_cgrp_func\ngk110_cgrp = {\n\t.preempt = gk110_cgrp_preempt,\n};\n\nvoid\ngk110_runl_insert_cgrp(struct nvkm_cgrp *cgrp, struct nvkm_memory *memory, u64 offset)\n{\n\tnvkm_wo32(memory, offset + 0, (cgrp->chan_nr << 26) | (128 << 18) |\n\t\t\t\t      (3 << 14) | 0x00002000 | cgrp->id);\n\tnvkm_wo32(memory, offset + 4, 0x00000000);\n}\n\nconst struct nvkm_runl_func\ngk110_runl = {\n\t.size = 8,\n\t.update = nv50_runl_update,\n\t.insert_cgrp = gk110_runl_insert_cgrp,\n\t.insert_chan = gk104_runl_insert_chan,\n\t.commit = gk104_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = gk104_runl_pending,\n\t.block = gk104_runl_block,\n\t.allow = gk104_runl_allow,\n\t.fault_clear = gk104_runl_fault_clear,\n\t.preempt_pending = gf100_runl_preempt_pending,\n};\n\nint\ngk110_fifo_chid_ctor(struct nvkm_fifo *fifo, int nr)\n{\n\tint ret;\n\n\tret = nvkm_chid_new(&nvkm_chan_event, &fifo->engine.subdev, nr, 0, nr, &fifo->cgid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn gf100_fifo_chid_ctor(fifo, nr);\n}\n\nstatic const struct nvkm_fifo_func\ngk110_fifo = {\n\t.chid_nr = gk104_fifo_chid_nr,\n\t.chid_ctor = gk110_fifo_chid_ctor,\n\t.runq_nr = gf100_fifo_runq_nr,\n\t.runl_ctor = gk104_fifo_runl_ctor,\n\t.init = gk104_fifo_init,\n\t.init_pbdmas = gk104_fifo_init_pbdmas,\n\t.intr = gk104_fifo_intr,\n\t.intr_mmu_fault_unit = gf100_fifo_intr_mmu_fault_unit,\n\t.intr_ctxsw_timeout = gf100_fifo_intr_ctxsw_timeout,\n\t.mmu_fault = &gk104_fifo_mmu_fault,\n\t.nonstall = &gf100_fifo_nonstall,\n\t.runl = &gk110_runl,\n\t.runq = &gk104_runq,\n\t.engn = &gk104_engn,\n\t.engn_ce = &gk104_engn_ce,\n\t.cgrp = {{ 0, 0, KEPLER_CHANNEL_GROUP_A  }, &gk110_cgrp },\n\t.chan = {{ 0, 0, KEPLER_CHANNEL_GPFIFO_B }, &gk110_chan },\n};\n\nint\ngk110_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&gk110_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}