{
  "module_name": "gm200.c",
  "hash_id": "d80d13cff1f20ed3fbe8a1deed4dc9112251ef25e2c38d7475347ff3d487a51e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/gm200.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"hdmi.h\"\n#include \"head.h\"\n#include \"ior.h\"\n#include \"outp.h\"\n\n#include <nvif/class.h>\n\nvoid\ngm200_sor_dp_drive(struct nvkm_ior *sor, int ln, int pc, int dc, int pe, int pu)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32  loff = nv50_sor_link(sor);\n\tconst u32 shift = sor->func->dp->lanes[ln] * 8;\n\tu32 data[4];\n\n\tpu &= 0x0f;\n\n\tdata[0] = nvkm_rd32(device, 0x61c118 + loff) & ~(0x000000ff << shift);\n\tdata[1] = nvkm_rd32(device, 0x61c120 + loff) & ~(0x000000ff << shift);\n\tdata[2] = nvkm_rd32(device, 0x61c130 + loff);\n\tif ((data[2] & 0x00000f00) < (pu << 8) || ln == 0)\n\t\tdata[2] = (data[2] & ~0x00000f00) | (pu << 8);\n\n\tnvkm_wr32(device, 0x61c118 + loff, data[0] | (dc << shift));\n\tnvkm_wr32(device, 0x61c120 + loff, data[1] | (pe << shift));\n\tnvkm_wr32(device, 0x61c130 + loff, data[2]);\n\n\tdata[3] = nvkm_rd32(device, 0x61c13c + loff) & ~(0x000000ff << shift);\n\tnvkm_wr32(device, 0x61c13c + loff, data[3] | (pc << shift));\n}\n\nconst struct nvkm_ior_func_dp\ngm200_sor_dp = {\n\t.lanes = { 0, 1, 2, 3 },\n\t.links = gf119_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = gm107_sor_dp_pattern,\n\t.drive = gm200_sor_dp_drive,\n\t.vcpi = gf119_sor_dp_vcpi,\n\t.audio = gf119_sor_dp_audio,\n\t.audio_sym = gf119_sor_dp_audio_sym,\n\t.watermark = gf119_sor_dp_watermark,\n};\n\nvoid\ngm200_sor_hdmi_scdc(struct nvkm_ior *ior, u8 scdc)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(ior);\n\tconst u32 ctrl = scdc & 0x3;\n\n\tnvkm_mask(device, 0x61c5bc + soff, 0x00000003, ctrl);\n\n\tior->tmds.high_speed = !!(scdc & 0x2);\n}\n\nconst struct nvkm_ior_func_hdmi\ngm200_sor_hdmi = {\n\t.ctrl = gk104_sor_hdmi_ctrl,\n\t.scdc = gm200_sor_hdmi_scdc,\n\t.infoframe_avi = gk104_sor_hdmi_infoframe_avi,\n\t.infoframe_vsi = gk104_sor_hdmi_infoframe_vsi,\n};\n\nvoid\ngm200_sor_route_set(struct nvkm_outp *outp, struct nvkm_ior *ior)\n{\n\tstruct nvkm_device *device = outp->disp->engine.subdev.device;\n\tconst u32 moff = __ffs(outp->info.or) * 0x100;\n\tconst u32  sor = ior ? ior->id + 1 : 0;\n\tu32 link = ior ? (ior->asy.link == 2) : 0;\n\n\tif (outp->info.sorconf.link & 1) {\n\t\tnvkm_mask(device, 0x612308 + moff, 0x0000001f, link << 4 | sor);\n\t\tlink++;\n\t}\n\n\tif (outp->info.sorconf.link & 2)\n\t\tnvkm_mask(device, 0x612388 + moff, 0x0000001f, link << 4 | sor);\n}\n\nint\ngm200_sor_route_get(struct nvkm_outp *outp, int *link)\n{\n\tstruct nvkm_device *device = outp->disp->engine.subdev.device;\n\tconst int sublinks = outp->info.sorconf.link;\n\tint lnk[2], sor[2], m, s;\n\n\tfor (*link = 0, m = __ffs(outp->info.or) * 2, s = 0; s < 2; m++, s++) {\n\t\tif (sublinks & BIT(s)) {\n\t\t\tu32 data = nvkm_rd32(device, 0x612308 + (m * 0x80));\n\t\t\tlnk[s] = (data & 0x00000010) >> 4;\n\t\t\tsor[s] = (data & 0x0000000f);\n\t\t\tif (!sor[s])\n\t\t\t\treturn -1;\n\t\t\t*link |= lnk[s];\n\t\t}\n\t}\n\n\tif (sublinks == 3) {\n\t\tif (sor[0] != sor[1] || WARN_ON(lnk[0] || !lnk[1]))\n\t\t\treturn -1;\n\t}\n\n\treturn ((sublinks & 1) ? sor[0] : sor[1]) - 1;\n}\n\nstatic const struct nvkm_ior_func\ngm200_sor = {\n\t.route = {\n\t\t.get = gm200_sor_route_get,\n\t\t.set = gm200_sor_route_set,\n\t},\n\t.state = gf119_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = gf119_sor_clock,\n\t.hdmi = &gm200_sor_hdmi,\n\t.dp = &gm200_sor_dp,\n\t.hda = &gf119_sor_hda,\n};\n\nstatic int\ngm200_sor_new(struct nvkm_disp *disp, int id)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tu32 hda;\n\n\tif (!((hda = nvkm_rd32(device, 0x08a15c)) & 0x40000000))\n\t\thda = nvkm_rd32(device, 0x101034);\n\n\treturn nvkm_ior_new_(&gm200_sor, disp, SOR, id, hda & BIT(id));\n}\n\nstatic const struct nvkm_disp_func\ngm200_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = gf119_disp_init,\n\t.fini = gf119_disp_fini,\n\t.intr = gf119_disp_intr,\n\t.intr_error = gf119_disp_intr_error,\n\t.super = gf119_disp_super,\n\t.uevent = &gf119_disp_chan_uevent,\n\t.head = { .cnt = gf119_head_cnt, .new = gf119_head_new },\n\t.dac = { .cnt = gf119_dac_cnt, .new = gf119_dac_new },\n\t.sor = { .cnt = gf119_sor_cnt, .new = gm200_sor_new },\n\t.root = { 0,0,GM200_DISP },\n\t.user = {\n\t\t{{0,0,GK104_DISP_CURSOR             }, nvkm_disp_chan_new, &gf119_disp_curs },\n\t\t{{0,0,GK104_DISP_OVERLAY            }, nvkm_disp_chan_new, &gf119_disp_oimm },\n\t\t{{0,0,GK110_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, &gf119_disp_base },\n\t\t{{0,0,GM200_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, &gk104_disp_core },\n\t\t{{0,0,GK104_DISP_OVERLAY_CONTROL_DMA}, nvkm_disp_chan_new, &gk104_disp_ovly },\n\t\t{}\n\t},\n};\n\nint\ngm200_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&gm200_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}