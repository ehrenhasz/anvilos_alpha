{
  "module_name": "nv44.c",
  "hash_id": "2200d288ca5f862d6372def066fbf9de7ca2f4fb66889eb0fca4da250c79aea4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv44.c",
  "human_readable_source": " \n#define nv44_mpeg(p) container_of((p), struct nv44_mpeg, engine)\n#include \"priv.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n\nstruct nv44_mpeg {\n\tstruct nvkm_engine engine;\n\tstruct list_head chan;\n};\n\n \n#define nv44_mpeg_chan(p) container_of((p), struct nv44_mpeg_chan, object)\n\nstruct nv44_mpeg_chan {\n\tstruct nvkm_object object;\n\tstruct nv44_mpeg *mpeg;\n\tstruct nvkm_chan *fifo;\n\tstruct list_head head;\n\tu32 inst;\n};\n\nstatic int\nnv44_mpeg_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t    int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);\n\tint ret = nvkm_gpuobj_new(chan->object.engine->subdev.device, 264 * 4,\n\t\t\t\t  align, true, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tchan->inst = (*pgpuobj)->addr;\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x78, 0x02001ec1);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nstatic int\nnv44_mpeg_chan_fini(struct nvkm_object *object, bool suspend)\n{\n\n\tstruct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);\n\tstruct nv44_mpeg *mpeg = chan->mpeg;\n\tstruct nvkm_device *device = mpeg->engine.subdev.device;\n\tu32 inst = 0x80000000 | (chan->inst >> 4);\n\n\tnvkm_mask(device, 0x00b32c, 0x00000001, 0x00000000);\n\tif (nvkm_rd32(device, 0x00b318) == inst)\n\t\tnvkm_mask(device, 0x00b318, 0x80000000, 0x00000000);\n\tnvkm_mask(device, 0x00b32c, 0x00000001, 0x00000001);\n\treturn 0;\n}\n\nstatic void *\nnv44_mpeg_chan_dtor(struct nvkm_object *object)\n{\n\tstruct nv44_mpeg_chan *chan = nv44_mpeg_chan(object);\n\tstruct nv44_mpeg *mpeg = chan->mpeg;\n\tunsigned long flags;\n\tspin_lock_irqsave(&mpeg->engine.lock, flags);\n\tlist_del(&chan->head);\n\tspin_unlock_irqrestore(&mpeg->engine.lock, flags);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\nnv44_mpeg_chan = {\n\t.dtor = nv44_mpeg_chan_dtor,\n\t.fini = nv44_mpeg_chan_fini,\n\t.bind = nv44_mpeg_chan_bind,\n};\n\nstatic int\nnv44_mpeg_chan_new(struct nvkm_chan *fifoch, const struct nvkm_oclass *oclass,\n\t\t   struct nvkm_object **pobject)\n{\n\tstruct nv44_mpeg *mpeg = nv44_mpeg(oclass->engine);\n\tstruct nv44_mpeg_chan *chan;\n\tunsigned long flags;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nv44_mpeg_chan, oclass, &chan->object);\n\tchan->mpeg = mpeg;\n\tchan->fifo = fifoch;\n\t*pobject = &chan->object;\n\n\tspin_lock_irqsave(&mpeg->engine.lock, flags);\n\tlist_add(&chan->head, &mpeg->chan);\n\tspin_unlock_irqrestore(&mpeg->engine.lock, flags);\n\treturn 0;\n}\n\n \n\nstatic bool\nnv44_mpeg_mthd(struct nvkm_device *device, u32 mthd, u32 data)\n{\n\tswitch (mthd) {\n\tcase 0x190:\n\tcase 0x1a0:\n\tcase 0x1b0:\n\t\treturn nv40_mpeg_mthd_dma(device, mthd, data);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic void\nnv44_mpeg_intr(struct nvkm_engine *engine)\n{\n\tstruct nv44_mpeg *mpeg = nv44_mpeg(engine);\n\tstruct nvkm_subdev *subdev = &mpeg->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nv44_mpeg_chan *temp, *chan = NULL;\n\tunsigned long flags;\n\tu32 inst = nvkm_rd32(device, 0x00b318) & 0x000fffff;\n\tu32 stat = nvkm_rd32(device, 0x00b100);\n\tu32 type = nvkm_rd32(device, 0x00b230);\n\tu32 mthd = nvkm_rd32(device, 0x00b234);\n\tu32 data = nvkm_rd32(device, 0x00b238);\n\tu32 show = stat;\n\n\tspin_lock_irqsave(&mpeg->engine.lock, flags);\n\tlist_for_each_entry(temp, &mpeg->chan, head) {\n\t\tif (temp->inst >> 4 == inst) {\n\t\t\tchan = temp;\n\t\t\tlist_del(&chan->head);\n\t\t\tlist_add(&chan->head, &mpeg->chan);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (stat & 0x01000000) {\n\t\t \n\t\tif (type == 0x00000020 && mthd == 0x0000) {\n\t\t\tnvkm_mask(device, 0x00b308, 0x00000000, 0x00000000);\n\t\t\tshow &= ~0x01000000;\n\t\t}\n\n\t\tif (type == 0x00000010) {\n\t\t\tif (nv44_mpeg_mthd(subdev->device, mthd, data))\n\t\t\t\tshow &= ~0x01000000;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x00b100, stat);\n\tnvkm_wr32(device, 0x00b230, 0x00000001);\n\n\tif (show) {\n\t\tnvkm_error(subdev, \"ch %d [%08x %s] %08x %08x %08x %08x\\n\",\n\t\t\t   chan ? chan->fifo->id : -1, inst << 4,\n\t\t\t   chan ? chan->fifo->name : \"unknown\",\n\t\t\t   stat, type, mthd, data);\n\t}\n\n\tspin_unlock_irqrestore(&mpeg->engine.lock, flags);\n}\n\nstatic const struct nvkm_engine_func\nnv44_mpeg = {\n\t.init = nv31_mpeg_init,\n\t.intr = nv44_mpeg_intr,\n\t.tile = nv31_mpeg_tile,\n\t.fifo.cclass = nv44_mpeg_chan_new,\n\t.sclass = {\n\t\t{ -1, -1, NV31_MPEG, &nv31_mpeg_object },\n\t\t{}\n\t}\n};\n\nint\nnv44_mpeg_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_engine **pmpeg)\n{\n\tstruct nv44_mpeg *mpeg;\n\n\tif (!(mpeg = kzalloc(sizeof(*mpeg), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&mpeg->chan);\n\t*pmpeg = &mpeg->engine;\n\n\treturn nvkm_engine_ctor(&nv44_mpeg, device, type, inst, true, &mpeg->engine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}