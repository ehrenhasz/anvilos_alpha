{
  "module_name": "usernv50.c",
  "hash_id": "00c3f9d742cc02b0da3106091af818469f1ba1d79b128426e772c5de189f7372",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/dma/usernv50.c",
  "human_readable_source": " \n#define nv50_dmaobj(p) container_of((p), struct nv50_dmaobj, base)\n#include \"user.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n\n#include <nvif/cl0002.h>\n#include <nvif/unpack.h>\n\nstruct nv50_dmaobj {\n\tstruct nvkm_dmaobj base;\n\tu32 flags0;\n\tu32 flags5;\n};\n\nstatic int\nnv50_dmaobj_bind(struct nvkm_dmaobj *base, struct nvkm_gpuobj *parent,\n\t\t int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nv50_dmaobj *dmaobj = nv50_dmaobj(base);\n\tstruct nvkm_device *device = dmaobj->base.dma->engine.subdev.device;\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 24, align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, dmaobj->flags0);\n\t\tnvkm_wo32(*pgpuobj, 0x04, lower_32_bits(dmaobj->base.limit));\n\t\tnvkm_wo32(*pgpuobj, 0x08, lower_32_bits(dmaobj->base.start));\n\t\tnvkm_wo32(*pgpuobj, 0x0c, upper_32_bits(dmaobj->base.limit) << 24 |\n\t\t\t\t\t  upper_32_bits(dmaobj->base.start));\n\t\tnvkm_wo32(*pgpuobj, 0x10, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x14, dmaobj->flags5);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nvkm_dmaobj_func\nnv50_dmaobj_func = {\n\t.bind = nv50_dmaobj_bind,\n};\n\nint\nnv50_dmaobj_new(struct nvkm_dma *dma, const struct nvkm_oclass *oclass,\n\t\tvoid *data, u32 size, struct nvkm_dmaobj **pdmaobj)\n{\n\tunion {\n\t\tstruct nv50_dma_v0 v0;\n\t} *args;\n\tstruct nvkm_object *parent = oclass->parent;\n\tstruct nv50_dmaobj *dmaobj;\n\tu32 user, part, comp, kind;\n\tint ret;\n\n\tif (!(dmaobj = kzalloc(sizeof(*dmaobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pdmaobj = &dmaobj->base;\n\n\tret = nvkm_dmaobj_ctor(&nv50_dmaobj_func, dma, oclass,\n\t\t\t       &data, &size, &dmaobj->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret  = -ENOSYS;\n\targs = data;\n\n\tnvif_ioctl(parent, \"create nv50 dma size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(parent, \"create nv50 dma vers %d priv %d part %d \"\n\t\t\t\t   \"comp %d kind %02x\\n\", args->v0.version,\n\t\t\t   args->v0.priv, args->v0.part, args->v0.comp,\n\t\t\t   args->v0.kind);\n\t\tuser = args->v0.priv;\n\t\tpart = args->v0.part;\n\t\tcomp = args->v0.comp;\n\t\tkind = args->v0.kind;\n\t} else\n\tif (size == 0) {\n\t\tif (dmaobj->base.target != NV_MEM_TARGET_VM) {\n\t\t\tuser = NV50_DMA_V0_PRIV_US;\n\t\t\tpart = NV50_DMA_V0_PART_256;\n\t\t\tcomp = NV50_DMA_V0_COMP_NONE;\n\t\t\tkind = NV50_DMA_V0_KIND_PITCH;\n\t\t} else {\n\t\t\tuser = NV50_DMA_V0_PRIV_VM;\n\t\t\tpart = NV50_DMA_V0_PART_VM;\n\t\t\tcomp = NV50_DMA_V0_COMP_VM;\n\t\t\tkind = NV50_DMA_V0_KIND_VM;\n\t\t}\n\t} else\n\t\treturn ret;\n\n\tif (user > 2 || part > 2 || comp > 3 || kind > 0x7f)\n\t\treturn -EINVAL;\n\tdmaobj->flags0 = (comp << 29) | (kind << 22) | (user << 20) |\n\t\t\t oclass->base.oclass;\n\tdmaobj->flags5 = (part << 16);\n\n\tswitch (dmaobj->base.target) {\n\tcase NV_MEM_TARGET_VM:\n\t\tdmaobj->flags0 |= 0x00000000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_VRAM:\n\t\tdmaobj->flags0 |= 0x00010000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_PCI:\n\t\tdmaobj->flags0 |= 0x00020000;\n\t\tbreak;\n\tcase NV_MEM_TARGET_PCI_NOSNOOP:\n\t\tdmaobj->flags0 |= 0x00030000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dmaobj->base.access) {\n\tcase NV_MEM_ACCESS_VM:\n\t\tbreak;\n\tcase NV_MEM_ACCESS_RO:\n\t\tdmaobj->flags0 |= 0x00040000;\n\t\tbreak;\n\tcase NV_MEM_ACCESS_WO:\n\tcase NV_MEM_ACCESS_RW:\n\t\tdmaobj->flags0 |= 0x00080000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}