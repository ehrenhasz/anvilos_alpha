{
  "module_name": "user.c",
  "hash_id": "f78e8a0a87bccc1cec5c9ebbb091d089909bf123a4944d4bd15e05e58ce8f331",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/dma/user.c",
  "human_readable_source": " \n#include \"user.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n\n#include <nvif/cl0002.h>\n#include <nvif/unpack.h>\n\nstatic const struct nvkm_object_func nvkm_dmaobj_func;\nstruct nvkm_dmaobj *\nnvkm_dmaobj_search(struct nvkm_client *client, u64 handle)\n{\n\tstruct nvkm_object *object;\n\n\tobject = nvkm_object_search(client, handle, &nvkm_dmaobj_func);\n\tif (IS_ERR(object))\n\t\treturn (void *)object;\n\n\treturn nvkm_dmaobj(object);\n}\n\nstatic int\nnvkm_dmaobj_bind(struct nvkm_object *base, struct nvkm_gpuobj *gpuobj,\n\t\t int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nvkm_dmaobj *dmaobj = nvkm_dmaobj(base);\n\treturn dmaobj->func->bind(dmaobj, gpuobj, align, pgpuobj);\n}\n\nstatic void *\nnvkm_dmaobj_dtor(struct nvkm_object *base)\n{\n\treturn nvkm_dmaobj(base);\n}\n\nstatic const struct nvkm_object_func\nnvkm_dmaobj_func = {\n\t.dtor = nvkm_dmaobj_dtor,\n\t.bind = nvkm_dmaobj_bind,\n};\n\nint\nnvkm_dmaobj_ctor(const struct nvkm_dmaobj_func *func, struct nvkm_dma *dma,\n\t\t const struct nvkm_oclass *oclass, void **pdata, u32 *psize,\n\t\t struct nvkm_dmaobj *dmaobj)\n{\n\tunion {\n\t\tstruct nv_dma_v0 v0;\n\t} *args = *pdata;\n\tstruct nvkm_object *parent = oclass->parent;\n\tvoid *data = *pdata;\n\tu32 size = *psize;\n\tint ret = -ENOSYS;\n\n\tnvkm_object_ctor(&nvkm_dmaobj_func, oclass, &dmaobj->object);\n\tdmaobj->func = func;\n\tdmaobj->dma = dma;\n\n\tnvif_ioctl(parent, \"create dma size %d\\n\", *psize);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(parent, \"create dma vers %d target %d access %d \"\n\t\t\t\t   \"start %016llx limit %016llx\\n\",\n\t\t\t   args->v0.version, args->v0.target, args->v0.access,\n\t\t\t   args->v0.start, args->v0.limit);\n\t\tdmaobj->target = args->v0.target;\n\t\tdmaobj->access = args->v0.access;\n\t\tdmaobj->start  = args->v0.start;\n\t\tdmaobj->limit  = args->v0.limit;\n\t} else\n\t\treturn ret;\n\n\t*pdata = data;\n\t*psize = size;\n\n\tif (dmaobj->start > dmaobj->limit)\n\t\treturn -EINVAL;\n\n\tswitch (dmaobj->target) {\n\tcase NV_DMA_V0_TARGET_VM:\n\t\tdmaobj->target = NV_MEM_TARGET_VM;\n\t\tbreak;\n\tcase NV_DMA_V0_TARGET_VRAM:\n\t\tdmaobj->target = NV_MEM_TARGET_VRAM;\n\t\tbreak;\n\tcase NV_DMA_V0_TARGET_PCI:\n\t\tdmaobj->target = NV_MEM_TARGET_PCI;\n\t\tbreak;\n\tcase NV_DMA_V0_TARGET_PCI_US:\n\tcase NV_DMA_V0_TARGET_AGP:\n\t\tdmaobj->target = NV_MEM_TARGET_PCI_NOSNOOP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dmaobj->access) {\n\tcase NV_DMA_V0_ACCESS_VM:\n\t\tdmaobj->access = NV_MEM_ACCESS_VM;\n\t\tbreak;\n\tcase NV_DMA_V0_ACCESS_RD:\n\t\tdmaobj->access = NV_MEM_ACCESS_RO;\n\t\tbreak;\n\tcase NV_DMA_V0_ACCESS_WR:\n\t\tdmaobj->access = NV_MEM_ACCESS_WO;\n\t\tbreak;\n\tcase NV_DMA_V0_ACCESS_RDWR:\n\t\tdmaobj->access = NV_MEM_ACCESS_RW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}