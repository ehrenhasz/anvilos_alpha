{
  "module_name": "base.c",
  "hash_id": "8375e54e78dc14d17c92ccac572cf52120fb712a3507f40da4e6a0e523f4e973",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"conn.h\"\n#include \"dp.h\"\n#include \"head.h\"\n#include \"ior.h\"\n#include \"outp.h\"\n\n#include <core/client.h>\n#include <core/ramht.h>\n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0046.h>\n#include <nvif/event.h>\n#include <nvif/unpack.h>\n\nstatic void\nnvkm_disp_vblank_fini(struct nvkm_event *event, int type, int id)\n{\n\tstruct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);\n\tstruct nvkm_head *head = nvkm_head_find(disp, id);\n\tif (head)\n\t\thead->func->vblank_put(head);\n}\n\nstatic void\nnvkm_disp_vblank_init(struct nvkm_event *event, int type, int id)\n{\n\tstruct nvkm_disp *disp = container_of(event, typeof(*disp), vblank);\n\tstruct nvkm_head *head = nvkm_head_find(disp, id);\n\tif (head)\n\t\thead->func->vblank_get(head);\n}\n\nstatic const struct nvkm_event_func\nnvkm_disp_vblank_func = {\n\t.init = nvkm_disp_vblank_init,\n\t.fini = nvkm_disp_vblank_fini,\n};\n\nvoid\nnvkm_disp_vblank(struct nvkm_disp *disp, int head)\n{\n\tnvkm_event_ntfy(&disp->vblank, head, NVKM_DISP_HEAD_EVENT_VBLANK);\n}\n\nstatic int\nnvkm_disp_class_new(struct nvkm_device *device,\n\t\t    const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\t    struct nvkm_object **pobject)\n{\n\treturn nvkm_udisp_new(oclass, data, size, pobject);\n}\n\nstatic const struct nvkm_device_oclass\nnvkm_disp_sclass = {\n\t.ctor = nvkm_disp_class_new,\n};\n\nstatic int\nnvkm_disp_class_get(struct nvkm_oclass *oclass, int index,\n\t\t    const struct nvkm_device_oclass **class)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(oclass->engine);\n\tif (index == 0) {\n\t\toclass->base = disp->func->root;\n\t\t*class = &nvkm_disp_sclass;\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic void\nnvkm_disp_intr(struct nvkm_engine *engine)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(engine);\n\tdisp->func->intr(disp);\n}\n\nstatic int\nnvkm_disp_fini(struct nvkm_engine *engine, bool suspend)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(engine);\n\tstruct nvkm_conn *conn;\n\tstruct nvkm_outp *outp;\n\n\tif (disp->func->fini)\n\t\tdisp->func->fini(disp);\n\n\tlist_for_each_entry(outp, &disp->outps, head) {\n\t\tnvkm_outp_fini(outp);\n\t}\n\n\tlist_for_each_entry(conn, &disp->conns, head) {\n\t\tnvkm_conn_fini(conn);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_disp_init(struct nvkm_engine *engine)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(engine);\n\tstruct nvkm_conn *conn;\n\tstruct nvkm_outp *outp;\n\tstruct nvkm_ior *ior;\n\n\tlist_for_each_entry(conn, &disp->conns, head) {\n\t\tnvkm_conn_init(conn);\n\t}\n\n\tlist_for_each_entry(outp, &disp->outps, head) {\n\t\tnvkm_outp_init(outp);\n\t}\n\n\tif (disp->func->init) {\n\t\tint ret = disp->func->init(disp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(ior, &disp->iors, head) {\n\t\tior->func->power(ior, true, true, true, true, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_disp_oneinit(struct nvkm_engine *engine)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(engine);\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvkm_outp *outp, *outt, *pair;\n\tstruct nvkm_conn *conn;\n\tstruct nvkm_head *head;\n\tstruct nvkm_ior *ior;\n\tstruct nvbios_connE connE;\n\tstruct dcb_output dcbE;\n\tu8  hpd = 0, ver, hdr;\n\tu32 data;\n\tint ret, i;\n\n\t \n\ti = -1;\n\twhile ((data = dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE))) {\n\t\tif (ver < 0x40)  \n\t\t\tbreak;\n\t\tif (dcbE.type == DCB_OUTPUT_UNUSED)\n\t\t\tcontinue;\n\t\tif (dcbE.type == DCB_OUTPUT_EOL)\n\t\t\tbreak;\n\t\toutp = NULL;\n\n\t\tswitch (dcbE.type) {\n\t\tcase DCB_OUTPUT_ANALOG:\n\t\tcase DCB_OUTPUT_TV:\n\t\tcase DCB_OUTPUT_TMDS:\n\t\tcase DCB_OUTPUT_LVDS:\n\t\t\tret = nvkm_outp_new(disp, i, &dcbE, &outp);\n\t\t\tbreak;\n\t\tcase DCB_OUTPUT_DP:\n\t\t\tret = nvkm_dp_new(disp, i, &dcbE, &outp);\n\t\t\tbreak;\n\t\tcase DCB_OUTPUT_WFD:\n\t\t\t \n\t\t\tret = -ENODEV;\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tnvkm_warn(subdev, \"dcb %d type %d unknown\\n\",\n\t\t\t\t  i, dcbE.type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tif (outp) {\n\t\t\t\tif (ret != -ENODEV)\n\t\t\t\t\tOUTP_ERR(outp, \"ctor failed: %d\", ret);\n\t\t\t\telse\n\t\t\t\t\tOUTP_DBG(outp, \"not supported\");\n\t\t\t\tnvkm_outp_del(&outp);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnvkm_error(subdev, \"failed to create outp %d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&outp->head, &disp->outps);\n\t\thpd = max(hpd, (u8)(dcbE.connector + 1));\n\t}\n\n\t \n\tlist_for_each_entry_safe(outp, outt, &disp->outps, head) {\n\t\t \n\t\tdata = nvbios_connEp(bios, outp->info.connector, &ver, &hdr,\n\t\t\t\t     &connE);\n\n\t\t \n\t\tif (!data) {\n\t\t\t \n\t\t\tint ccb_index = outp->info.i2c_index;\n\t\t\tif (ccb_index != 0xf) {\n\t\t\t\tlist_for_each_entry(pair, &disp->outps, head) {\n\t\t\t\t\tif (pair->info.i2c_index == ccb_index) {\n\t\t\t\t\t\toutp->conn = pair->conn;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (outp->conn)\n\t\t\t\tcontinue;\n\n\t\t\tmemset(&connE, 0x00, sizeof(connE));\n\t\t\tconnE.type = DCB_CONNECTOR_NONE;\n\t\t\ti = -1;\n\t\t} else {\n\t\t\ti = outp->info.connector;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(conn, &disp->conns, head) {\n\t\t\tif (conn->index == outp->info.connector) {\n\t\t\t\toutp->conn = conn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (outp->conn)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = nvkm_conn_new(disp, i, &connE, &outp->conn);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"failed to create outp %d conn: %d\\n\", outp->index, ret);\n\t\t\tnvkm_conn_del(&outp->conn);\n\t\t\tlist_del(&outp->head);\n\t\t\tnvkm_outp_del(&outp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_add_tail(&outp->conn->head, &disp->conns);\n\t}\n\n\tif (disp->func->oneinit) {\n\t\tret = disp->func->oneinit(disp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(outp, &disp->outps, head) {\n\t\tif (outp->conn->info.type == DCB_CONNECTOR_LVDS ||\n\t\t    outp->conn->info.type == DCB_CONNECTOR_eDP) {\n\t\t\tior = nvkm_ior_find(disp, SOR, ffs(outp->info.or) - 1);\n\t\t\tif (!WARN_ON(!ior))\n\t\t\t\tior->identity = true;\n\t\t\toutp->identity = true;\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(head, &disp->heads, head)\n\t\ti = max(i, head->id + 1);\n\n\treturn nvkm_event_init(&nvkm_disp_vblank_func, subdev, 1, i, &disp->vblank);\n}\n\nstatic void *\nnvkm_disp_dtor(struct nvkm_engine *engine)\n{\n\tstruct nvkm_disp *disp = nvkm_disp(engine);\n\tstruct nvkm_conn *conn;\n\tstruct nvkm_outp *outp;\n\tstruct nvkm_ior *ior;\n\tstruct nvkm_head *head;\n\tvoid *data = disp;\n\n\tnvkm_ramht_del(&disp->ramht);\n\tnvkm_gpuobj_del(&disp->inst);\n\n\tnvkm_event_fini(&disp->uevent);\n\n\tif (disp->super.wq) {\n\t\tdestroy_workqueue(disp->super.wq);\n\t\tmutex_destroy(&disp->super.mutex);\n\t}\n\n\tnvkm_event_fini(&disp->vblank);\n\n\twhile (!list_empty(&disp->conns)) {\n\t\tconn = list_first_entry(&disp->conns, typeof(*conn), head);\n\t\tlist_del(&conn->head);\n\t\tnvkm_conn_del(&conn);\n\t}\n\n\twhile (!list_empty(&disp->outps)) {\n\t\toutp = list_first_entry(&disp->outps, typeof(*outp), head);\n\t\tlist_del(&outp->head);\n\t\tnvkm_outp_del(&outp);\n\t}\n\n\twhile (!list_empty(&disp->iors)) {\n\t\tior = list_first_entry(&disp->iors, typeof(*ior), head);\n\t\tnvkm_ior_del(&ior);\n\t}\n\n\twhile (!list_empty(&disp->heads)) {\n\t\thead = list_first_entry(&disp->heads, typeof(*head), head);\n\t\tnvkm_head_del(&head);\n\t}\n\n\treturn data;\n}\n\nstatic const struct nvkm_engine_func\nnvkm_disp = {\n\t.dtor = nvkm_disp_dtor,\n\t.oneinit = nvkm_disp_oneinit,\n\t.init = nvkm_disp_init,\n\t.fini = nvkm_disp_fini,\n\t.intr = nvkm_disp_intr,\n\t.base.sclass = nvkm_disp_class_get,\n};\n\nint\nnvkm_disp_new_(const struct nvkm_disp_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_disp **pdisp)\n{\n\tstruct nvkm_disp *disp;\n\tint ret;\n\n\tif (!(disp = *pdisp = kzalloc(sizeof(**pdisp), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tdisp->func = func;\n\tINIT_LIST_HEAD(&disp->heads);\n\tINIT_LIST_HEAD(&disp->iors);\n\tINIT_LIST_HEAD(&disp->outps);\n\tINIT_LIST_HEAD(&disp->conns);\n\tspin_lock_init(&disp->client.lock);\n\n\tret = nvkm_engine_ctor(&nvkm_disp, device, type, inst, true, &disp->engine);\n\tif (ret)\n\t\treturn ret;\n\n\tif (func->super) {\n\t\tdisp->super.wq = create_singlethread_workqueue(\"nvkm-disp\");\n\t\tif (!disp->super.wq)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_WORK(&disp->super.work, func->super);\n\t\tmutex_init(&disp->super.mutex);\n\t}\n\n\treturn nvkm_event_init(func->uevent, &disp->engine.subdev, 1, ARRAY_SIZE(disp->chan),\n\t\t\t       &disp->uevent);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}