{
  "module_name": "gf100.c",
  "hash_id": "2f47d150a1e2a13f3aa2275917edac27618b938ac130dc1e69c4c6da7e19ae52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/gf100.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ctxgf100.h\"\n#include \"fuc/os.h\"\n\n#include <core/client.h>\n#include <core/firmware.h>\n#include <core/option.h>\n#include <subdev/acr.h>\n#include <subdev/fb.h>\n#include <subdev/mc.h>\n#include <subdev/pmu.h>\n#include <subdev/therm.h>\n#include <subdev/timer.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n#include <nvif/cl9097.h>\n#include <nvif/if900d.h>\n#include <nvif/unpack.h>\n\n \n\nstatic void\ngf100_gr_zbc_clear_color(struct gf100_gr *gr, int zbc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tif (gr->zbc_color[zbc].format) {\n\t\tnvkm_wr32(device, 0x405804, gr->zbc_color[zbc].ds[0]);\n\t\tnvkm_wr32(device, 0x405808, gr->zbc_color[zbc].ds[1]);\n\t\tnvkm_wr32(device, 0x40580c, gr->zbc_color[zbc].ds[2]);\n\t\tnvkm_wr32(device, 0x405810, gr->zbc_color[zbc].ds[3]);\n\t}\n\tnvkm_wr32(device, 0x405814, gr->zbc_color[zbc].format);\n\tnvkm_wr32(device, 0x405820, zbc);\n\tnvkm_wr32(device, 0x405824, 0x00000004);  \n}\n\nstatic int\ngf100_gr_zbc_color_get(struct gf100_gr *gr, int format,\n\t\t       const u32 ds[4], const u32 l2[4])\n{\n\tstruct nvkm_ltc *ltc = gr->base.engine.subdev.device->ltc;\n\tint zbc = -ENOSPC, i;\n\n\tfor (i = ltc->zbc_color_min; i <= ltc->zbc_color_max; i++) {\n\t\tif (gr->zbc_color[i].format) {\n\t\t\tif (gr->zbc_color[i].format != format)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(gr->zbc_color[i].ds, ds, sizeof(\n\t\t\t\t   gr->zbc_color[i].ds)))\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(gr->zbc_color[i].l2, l2, sizeof(\n\t\t\t\t   gr->zbc_color[i].l2))) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn i;\n\t\t} else {\n\t\t\tzbc = (zbc < 0) ? i : zbc;\n\t\t}\n\t}\n\n\tif (zbc < 0)\n\t\treturn zbc;\n\n\tmemcpy(gr->zbc_color[zbc].ds, ds, sizeof(gr->zbc_color[zbc].ds));\n\tmemcpy(gr->zbc_color[zbc].l2, l2, sizeof(gr->zbc_color[zbc].l2));\n\tgr->zbc_color[zbc].format = format;\n\tnvkm_ltc_zbc_color_get(ltc, zbc, l2);\n\tgr->func->zbc->clear_color(gr, zbc);\n\treturn zbc;\n}\n\nstatic void\ngf100_gr_zbc_clear_depth(struct gf100_gr *gr, int zbc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tif (gr->zbc_depth[zbc].format)\n\t\tnvkm_wr32(device, 0x405818, gr->zbc_depth[zbc].ds);\n\tnvkm_wr32(device, 0x40581c, gr->zbc_depth[zbc].format);\n\tnvkm_wr32(device, 0x405820, zbc);\n\tnvkm_wr32(device, 0x405824, 0x00000005);  \n}\n\nstatic int\ngf100_gr_zbc_depth_get(struct gf100_gr *gr, int format,\n\t\t       const u32 ds, const u32 l2)\n{\n\tstruct nvkm_ltc *ltc = gr->base.engine.subdev.device->ltc;\n\tint zbc = -ENOSPC, i;\n\n\tfor (i = ltc->zbc_depth_min; i <= ltc->zbc_depth_max; i++) {\n\t\tif (gr->zbc_depth[i].format) {\n\t\t\tif (gr->zbc_depth[i].format != format)\n\t\t\t\tcontinue;\n\t\t\tif (gr->zbc_depth[i].ds != ds)\n\t\t\t\tcontinue;\n\t\t\tif (gr->zbc_depth[i].l2 != l2) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn i;\n\t\t} else {\n\t\t\tzbc = (zbc < 0) ? i : zbc;\n\t\t}\n\t}\n\n\tif (zbc < 0)\n\t\treturn zbc;\n\n\tgr->zbc_depth[zbc].format = format;\n\tgr->zbc_depth[zbc].ds = ds;\n\tgr->zbc_depth[zbc].l2 = l2;\n\tnvkm_ltc_zbc_depth_get(ltc, zbc, l2);\n\tgr->func->zbc->clear_depth(gr, zbc);\n\treturn zbc;\n}\n\nconst struct gf100_gr_func_zbc\ngf100_gr_zbc = {\n\t.clear_color = gf100_gr_zbc_clear_color,\n\t.clear_depth = gf100_gr_zbc_clear_depth,\n};\n\n \n#define gf100_gr_object(p) container_of((p), struct gf100_gr_object, object)\n\nstruct gf100_gr_object {\n\tstruct nvkm_object object;\n\tstruct gf100_gr_chan *chan;\n};\n\nstatic int\ngf100_fermi_mthd_zbc_color(struct nvkm_object *object, void *data, u32 size)\n{\n\tstruct gf100_gr *gr = gf100_gr(nvkm_gr(object->engine));\n\tunion {\n\t\tstruct fermi_a_zbc_color_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tswitch (args->v0.format) {\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_ZERO:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_UNORM_ONE:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_RF32_GF32_BF32_AF32:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_R16_G16_B16_A16:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_RN16_GN16_BN16_AN16:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_RS16_GS16_BS16_AS16:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_RU16_GU16_BU16_AU16:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_RF16_GF16_BF16_AF16:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_A8R8G8B8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_A8RL8GL8BL8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_A2B10G10R10:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_AU2BU10GU10RU10:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_A8B8G8R8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_A8BL8GL8RL8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_AN8BN8GN8RN8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_AS8BS8GS8RS8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_AU8BU8GU8RU8:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_A2R10G10B10:\n\t\tcase FERMI_A_ZBC_COLOR_V0_FMT_BF10GF11RF11:\n\t\t\tret = gf100_gr_zbc_color_get(gr, args->v0.format,\n\t\t\t\t\t\t\t   args->v0.ds,\n\t\t\t\t\t\t\t   args->v0.l2);\n\t\t\tif (ret >= 0) {\n\t\t\t\targs->v0.index = ret;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\ngf100_fermi_mthd_zbc_depth(struct nvkm_object *object, void *data, u32 size)\n{\n\tstruct gf100_gr *gr = gf100_gr(nvkm_gr(object->engine));\n\tunion {\n\t\tstruct fermi_a_zbc_depth_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tswitch (args->v0.format) {\n\t\tcase FERMI_A_ZBC_DEPTH_V0_FMT_FP32:\n\t\t\tret = gf100_gr_zbc_depth_get(gr, args->v0.format,\n\t\t\t\t\t\t\t   args->v0.ds,\n\t\t\t\t\t\t\t   args->v0.l2);\n\t\t\treturn (ret >= 0) ? 0 : -ENOSPC;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\ngf100_fermi_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tnvif_ioctl(object, \"fermi mthd %08x\\n\", mthd);\n\tswitch (mthd) {\n\tcase FERMI_A_ZBC_COLOR:\n\t\treturn gf100_fermi_mthd_zbc_color(object, data, size);\n\tcase FERMI_A_ZBC_DEPTH:\n\t\treturn gf100_fermi_mthd_zbc_depth(object, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nconst struct nvkm_object_func\ngf100_fermi = {\n\t.mthd = gf100_fermi_mthd,\n};\n\nstatic void\ngf100_gr_mthd_set_shader_exceptions(struct nvkm_device *device, u32 data)\n{\n\tnvkm_wr32(device, 0x419e44, data ? 0xffffffff : 0x00000000);\n\tnvkm_wr32(device, 0x419e4c, data ? 0xffffffff : 0x00000000);\n}\n\nstatic bool\ngf100_gr_mthd_sw(struct nvkm_device *device, u16 class, u32 mthd, u32 data)\n{\n\tswitch (class & 0x00ff) {\n\tcase 0x97:\n\tcase 0xc0:\n\t\tswitch (mthd) {\n\t\tcase 0x1528:\n\t\t\tgf100_gr_mthd_set_shader_exceptions(device, data);\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic const struct nvkm_object_func\ngf100_gr_object_func = {\n};\n\nstatic int\ngf100_gr_object_new(const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\t    struct nvkm_object **pobject)\n{\n\tstruct gf100_gr_chan *chan = gf100_gr_chan(oclass->parent);\n\tstruct gf100_gr_object *object;\n\n\tif (!(object = kzalloc(sizeof(*object), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &object->object;\n\n\tnvkm_object_ctor(oclass->base.func ? oclass->base.func :\n\t\t\t &gf100_gr_object_func, oclass, &object->object);\n\tobject->chan = chan;\n\treturn 0;\n}\n\nstatic int\ngf100_gr_object_get(struct nvkm_gr *base, int index, struct nvkm_sclass *sclass)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tint c = 0;\n\n\twhile (gr->func->sclass[c].oclass) {\n\t\tif (c++ == index) {\n\t\t\t*sclass = gr->func->sclass[index];\n\t\t\tsclass->ctor = gf100_gr_object_new;\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn c;\n}\n\n \n\nstatic int\ngf100_gr_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t   int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct gf100_gr_chan *chan = gf100_gr_chan(object);\n\tstruct gf100_gr *gr = chan->gr;\n\tint ret, i;\n\n\tret = nvkm_gpuobj_new(gr->base.engine.subdev.device, gr->size,\n\t\t\t      align, false, parent, pgpuobj);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_kmap(*pgpuobj);\n\tfor (i = 0; i < gr->size; i += 4)\n\t\tnvkm_wo32(*pgpuobj, i, gr->data[i / 4]);\n\n\tif (!gr->firmware) {\n\t\tnvkm_wo32(*pgpuobj, 0x00, chan->mmio_nr / 2);\n\t\tnvkm_wo32(*pgpuobj, 0x04, chan->mmio_vma->addr >> 8);\n\t} else {\n\t\tnvkm_wo32(*pgpuobj, 0xf4, 0);\n\t\tnvkm_wo32(*pgpuobj, 0xf8, 0);\n\t\tnvkm_wo32(*pgpuobj, 0x10, chan->mmio_nr / 2);\n\t\tnvkm_wo32(*pgpuobj, 0x14, lower_32_bits(chan->mmio_vma->addr));\n\t\tnvkm_wo32(*pgpuobj, 0x18, upper_32_bits(chan->mmio_vma->addr));\n\t\tnvkm_wo32(*pgpuobj, 0x1c, 1);\n\t\tnvkm_wo32(*pgpuobj, 0x20, 0);\n\t\tnvkm_wo32(*pgpuobj, 0x28, 0);\n\t\tnvkm_wo32(*pgpuobj, 0x2c, 0);\n\t}\n\tnvkm_done(*pgpuobj);\n\treturn 0;\n}\n\nstatic void *\ngf100_gr_chan_dtor(struct nvkm_object *object)\n{\n\tstruct gf100_gr_chan *chan = gf100_gr_chan(object);\n\n\tnvkm_vmm_put(chan->vmm, &chan->mmio_vma);\n\tnvkm_memory_unref(&chan->mmio);\n\n\tnvkm_vmm_put(chan->vmm, &chan->attrib_cb);\n\tnvkm_vmm_put(chan->vmm, &chan->unknown);\n\tnvkm_vmm_put(chan->vmm, &chan->bundle_cb);\n\tnvkm_vmm_put(chan->vmm, &chan->pagepool);\n\tnvkm_vmm_unref(&chan->vmm);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\ngf100_gr_chan = {\n\t.dtor = gf100_gr_chan_dtor,\n\t.bind = gf100_gr_chan_bind,\n};\n\nstatic int\ngf100_gr_chan_new(struct nvkm_gr *base, struct nvkm_chan *fifoch,\n\t\t  const struct nvkm_oclass *oclass,\n\t\t  struct nvkm_object **pobject)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tstruct gf100_gr_chan *chan;\n\tstruct gf100_vmm_map_v0 args = { .priv = 1 };\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint ret;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&gf100_gr_chan, oclass, &chan->object);\n\tchan->gr = gr;\n\tchan->vmm = nvkm_vmm_ref(fifoch->vmm);\n\t*pobject = &chan->object;\n\n\t \n\tret = nvkm_vmm_get(chan->vmm, 12, nvkm_memory_size(gr->pagepool), &chan->pagepool);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_memory_map(gr->pagepool, 0, chan->vmm, chan->pagepool, &args, sizeof(args));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nvkm_vmm_get(chan->vmm, 12, nvkm_memory_size(gr->bundle_cb), &chan->bundle_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_memory_map(gr->bundle_cb, 0, chan->vmm, chan->bundle_cb, &args, sizeof(args));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nvkm_vmm_get(chan->vmm, 12, nvkm_memory_size(gr->attrib_cb), &chan->attrib_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device->card_type < GP100) {\n\t\tret = nvkm_memory_map(gr->attrib_cb, 0, chan->vmm, chan->attrib_cb, NULL, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = nvkm_memory_map(gr->attrib_cb, 0, chan->vmm, chan->attrib_cb,\n\t\t\t\t      &args, sizeof(args));;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (gr->func->grctx->unknown_size) {\n\t\tret = nvkm_vmm_get(chan->vmm, 12, nvkm_memory_size(gr->unknown), &chan->unknown);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nvkm_memory_map(gr->unknown, 0, chan->vmm, chan->unknown,\n\t\t\t\t      &args, sizeof(args));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&gr->fecs.mutex);\n\tif (gr->data == NULL) {\n\t\tret = gf100_grctx_generate(gr, chan, fifoch->inst);\n\t\tif (ret) {\n\t\t\tnvkm_error(&base->engine.subdev, \"failed to construct context\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&gr->fecs.mutex);\n\n\t \n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x1000, 0x100,\n\t\t\t      false, &chan->mmio);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_vmm_get(fifoch->vmm, 12, 0x1000, &chan->mmio_vma);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_memory_map(chan->mmio, 0, fifoch->vmm,\n\t\t\t      chan->mmio_vma, &args, sizeof(args));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnvkm_kmap(chan->mmio);\n\tgr->func->grctx->pagepool(chan, chan->pagepool->addr);\n\tgr->func->grctx->bundle(chan, chan->bundle_cb->addr, gr->func->grctx->bundle_size);\n\tgr->func->grctx->attrib_cb(chan, chan->attrib_cb->addr, gr->func->grctx->attrib_cb_size(gr));\n\tgr->func->grctx->attrib(chan);\n\tif (gr->func->grctx->patch_ltc)\n\t\tgr->func->grctx->patch_ltc(chan);\n\tif (gr->func->grctx->unknown_size)\n\t\tgr->func->grctx->unknown(chan, chan->unknown->addr, gr->func->grctx->unknown_size);\n\tnvkm_done(chan->mmio);\n\treturn 0;\n}\n\n \n\nconst struct gf100_gr_init\ngf100_gr_init_main_0[] = {\n\t{ 0x400080,   1, 0x04, 0x003083c2 },\n\t{ 0x400088,   1, 0x04, 0x00006fe7 },\n\t{ 0x40008c,   1, 0x04, 0x00000000 },\n\t{ 0x400090,   1, 0x04, 0x00000030 },\n\t{ 0x40013c,   1, 0x04, 0x013901f7 },\n\t{ 0x400140,   1, 0x04, 0x00000100 },\n\t{ 0x400144,   1, 0x04, 0x00000000 },\n\t{ 0x400148,   1, 0x04, 0x00000110 },\n\t{ 0x400138,   1, 0x04, 0x00000000 },\n\t{ 0x400130,   2, 0x04, 0x00000000 },\n\t{ 0x400124,   1, 0x04, 0x00000002 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_fe_0[] = {\n\t{ 0x40415c,   1, 0x04, 0x00000000 },\n\t{ 0x404170,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_pri_0[] = {\n\t{ 0x404488,   2, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_rstr2d_0[] = {\n\t{ 0x407808,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_pd_0[] = {\n\t{ 0x406024,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_ds_0[] = {\n\t{ 0x405844,   1, 0x04, 0x00ffffff },\n\t{ 0x405850,   1, 0x04, 0x00000000 },\n\t{ 0x405908,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_scc_0[] = {\n\t{ 0x40803c,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_prop_0[] = {\n\t{ 0x4184a0,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_gpc_unk_0[] = {\n\t{ 0x418604,   1, 0x04, 0x00000000 },\n\t{ 0x418680,   1, 0x04, 0x00000000 },\n\t{ 0x418714,   1, 0x04, 0x80000000 },\n\t{ 0x418384,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_setup_0[] = {\n\t{ 0x418814,   3, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_crstr_0[] = {\n\t{ 0x418b04,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_setup_1[] = {\n\t{ 0x4188c8,   1, 0x04, 0x80000000 },\n\t{ 0x4188cc,   1, 0x04, 0x00000000 },\n\t{ 0x4188d0,   1, 0x04, 0x00010000 },\n\t{ 0x4188d4,   1, 0x04, 0x00000001 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_zcull_0[] = {\n\t{ 0x418910,   1, 0x04, 0x00010001 },\n\t{ 0x418914,   1, 0x04, 0x00000301 },\n\t{ 0x418918,   1, 0x04, 0x00800000 },\n\t{ 0x418980,   1, 0x04, 0x77777770 },\n\t{ 0x418984,   3, 0x04, 0x77777777 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_gpm_0[] = {\n\t{ 0x418c04,   1, 0x04, 0x00000000 },\n\t{ 0x418c88,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_gpc_unk_1[] = {\n\t{ 0x418d00,   1, 0x04, 0x00000000 },\n\t{ 0x418f08,   1, 0x04, 0x00000000 },\n\t{ 0x418e00,   1, 0x04, 0x00000050 },\n\t{ 0x418e08,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_gcc_0[] = {\n\t{ 0x41900c,   1, 0x04, 0x00000000 },\n\t{ 0x419018,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_tpccs_0[] = {\n\t{ 0x419d08,   2, 0x04, 0x00000000 },\n\t{ 0x419d10,   1, 0x04, 0x00000014 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_tex_0[] = {\n\t{ 0x419ab0,   1, 0x04, 0x00000000 },\n\t{ 0x419ab8,   1, 0x04, 0x000000e7 },\n\t{ 0x419abc,   2, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_pe_0[] = {\n\t{ 0x41980c,   3, 0x04, 0x00000000 },\n\t{ 0x419844,   1, 0x04, 0x00000000 },\n\t{ 0x41984c,   1, 0x04, 0x00005bc5 },\n\t{ 0x419850,   4, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_l1c_0[] = {\n\t{ 0x419c98,   1, 0x04, 0x00000000 },\n\t{ 0x419ca8,   1, 0x04, 0x80000000 },\n\t{ 0x419cb4,   1, 0x04, 0x00000000 },\n\t{ 0x419cb8,   1, 0x04, 0x00008bf4 },\n\t{ 0x419cbc,   1, 0x04, 0x28137606 },\n\t{ 0x419cc0,   2, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_wwdx_0[] = {\n\t{ 0x419bd4,   1, 0x04, 0x00800000 },\n\t{ 0x419bdc,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_tpccs_1[] = {\n\t{ 0x419d2c,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_mpc_0[] = {\n\t{ 0x419c0c,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nstatic const struct gf100_gr_init\ngf100_gr_init_sm_0[] = {\n\t{ 0x419e00,   1, 0x04, 0x00000000 },\n\t{ 0x419ea0,   1, 0x04, 0x00000000 },\n\t{ 0x419ea4,   1, 0x04, 0x00000100 },\n\t{ 0x419ea8,   1, 0x04, 0x00001100 },\n\t{ 0x419eac,   1, 0x04, 0x11100702 },\n\t{ 0x419eb0,   1, 0x04, 0x00000003 },\n\t{ 0x419eb4,   4, 0x04, 0x00000000 },\n\t{ 0x419ec8,   1, 0x04, 0x06060618 },\n\t{ 0x419ed0,   1, 0x04, 0x0eff0e38 },\n\t{ 0x419ed4,   1, 0x04, 0x011104f1 },\n\t{ 0x419edc,   1, 0x04, 0x00000000 },\n\t{ 0x419f00,   1, 0x04, 0x00000000 },\n\t{ 0x419f2c,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_be_0[] = {\n\t{ 0x40880c,   1, 0x04, 0x00000000 },\n\t{ 0x408910,   9, 0x04, 0x00000000 },\n\t{ 0x408950,   1, 0x04, 0x00000000 },\n\t{ 0x408954,   1, 0x04, 0x0000ffff },\n\t{ 0x408984,   1, 0x04, 0x00000000 },\n\t{ 0x408988,   1, 0x04, 0x08040201 },\n\t{ 0x40898c,   1, 0x04, 0x80402010 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_fe_1[] = {\n\t{ 0x4040f0,   1, 0x04, 0x00000000 },\n\t{}\n};\n\nconst struct gf100_gr_init\ngf100_gr_init_pe_1[] = {\n\t{ 0x419880,   1, 0x04, 0x00000002 },\n\t{}\n};\n\nstatic const struct gf100_gr_pack\ngf100_gr_pack_mmio[] = {\n\t{ gf100_gr_init_main_0 },\n\t{ gf100_gr_init_fe_0 },\n\t{ gf100_gr_init_pri_0 },\n\t{ gf100_gr_init_rstr2d_0 },\n\t{ gf100_gr_init_pd_0 },\n\t{ gf100_gr_init_ds_0 },\n\t{ gf100_gr_init_scc_0 },\n\t{ gf100_gr_init_prop_0 },\n\t{ gf100_gr_init_gpc_unk_0 },\n\t{ gf100_gr_init_setup_0 },\n\t{ gf100_gr_init_crstr_0 },\n\t{ gf100_gr_init_setup_1 },\n\t{ gf100_gr_init_zcull_0 },\n\t{ gf100_gr_init_gpm_0 },\n\t{ gf100_gr_init_gpc_unk_1 },\n\t{ gf100_gr_init_gcc_0 },\n\t{ gf100_gr_init_tpccs_0 },\n\t{ gf100_gr_init_tex_0 },\n\t{ gf100_gr_init_pe_0 },\n\t{ gf100_gr_init_l1c_0 },\n\t{ gf100_gr_init_wwdx_0 },\n\t{ gf100_gr_init_tpccs_1 },\n\t{ gf100_gr_init_mpc_0 },\n\t{ gf100_gr_init_sm_0 },\n\t{ gf100_gr_init_be_0 },\n\t{ gf100_gr_init_fe_1 },\n\t{ gf100_gr_init_pe_1 },\n\t{}\n};\n\n \n\nstatic u32\ngf100_gr_ctxsw_inst(struct nvkm_gr *gr)\n{\n\treturn nvkm_rd32(gr->engine.subdev.device, 0x409b00);\n}\n\nstatic int\ngf100_gr_fecs_ctrl_ctxsw(struct gf100_gr *gr, u32 mthd)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409804, 0xffffffff);\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0xffffffff);\n\tnvkm_wr32(device, 0x409504, mthd);\n\tnvkm_msec(device, 2000,\n\t\tu32 stat = nvkm_rd32(device, 0x409804);\n\t\tif (stat == 0x00000002)\n\t\t\treturn -EIO;\n\t\tif (stat == 0x00000001)\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_start_ctxsw(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tint ret = 0;\n\n\tmutex_lock(&gr->fecs.mutex);\n\tif (!--gr->fecs.disable) {\n\t\tif (WARN_ON(ret = gf100_gr_fecs_ctrl_ctxsw(gr, 0x39)))\n\t\t\tgr->fecs.disable++;\n\t}\n\tmutex_unlock(&gr->fecs.mutex);\n\treturn ret;\n}\n\nstatic int\ngf100_gr_fecs_stop_ctxsw(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tint ret = 0;\n\n\tmutex_lock(&gr->fecs.mutex);\n\tif (!gr->fecs.disable++) {\n\t\tif (WARN_ON(ret = gf100_gr_fecs_ctrl_ctxsw(gr, 0x38)))\n\t\t\tgr->fecs.disable--;\n\t}\n\tmutex_unlock(&gr->fecs.mutex);\n\treturn ret;\n}\n\nstatic int\ngf100_gr_fecs_halt_pipeline(struct gf100_gr *gr)\n{\n\tint ret = 0;\n\n\tif (gr->firmware) {\n\t\tmutex_lock(&gr->fecs.mutex);\n\t\tret = gf100_gr_fecs_ctrl_ctxsw(gr, 0x04);\n\t\tmutex_unlock(&gr->fecs.mutex);\n\t}\n\n\treturn ret;\n}\n\nint\ngf100_gr_fecs_wfi_golden_save(struct gf100_gr *gr, u32 inst)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_mask(device, 0x409800, 0x00000003, 0x00000000);\n\tnvkm_wr32(device, 0x409500, inst);\n\tnvkm_wr32(device, 0x409504, 0x00000009);\n\tnvkm_msec(device, 2000,\n\t\tu32 stat = nvkm_rd32(device, 0x409800);\n\t\tif (stat & 0x00000002)\n\t\t\treturn -EIO;\n\t\tif (stat & 0x00000001)\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nint\ngf100_gr_fecs_bind_pointer(struct gf100_gr *gr, u32 inst)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_mask(device, 0x409800, 0x00000030, 0x00000000);\n\tnvkm_wr32(device, 0x409500, inst);\n\tnvkm_wr32(device, 0x409504, 0x00000003);\n\tnvkm_msec(device, 2000,\n\t\tu32 stat = nvkm_rd32(device, 0x409800);\n\t\tif (stat & 0x00000020)\n\t\t\treturn -EIO;\n\t\tif (stat & 0x00000010)\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_set_reglist_virtual_address(struct gf100_gr *gr, u64 addr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409810, addr >> 8);\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0x00000001);\n\tnvkm_wr32(device, 0x409504, 0x00000032);\n\tnvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x409800) == 0x00000001)\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_set_reglist_bind_instance(struct gf100_gr *gr, u32 inst)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409810, inst);\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0x00000001);\n\tnvkm_wr32(device, 0x409504, 0x00000031);\n\tnvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x409800) == 0x00000001)\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_discover_reglist_image_size(struct gf100_gr *gr, u32 *psize)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0x00000001);\n\tnvkm_wr32(device, 0x409504, 0x00000030);\n\tnvkm_msec(device, 2000,\n\t\tif ((*psize = nvkm_rd32(device, 0x409800)))\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_elpg_bind(struct gf100_gr *gr)\n{\n\tu32 size;\n\tint ret;\n\n\tret = gf100_gr_fecs_discover_reglist_image_size(gr, &size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = gf100_gr_fecs_set_reglist_bind_instance(gr, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn gf100_gr_fecs_set_reglist_virtual_address(gr, 0);\n}\n\nstatic int\ngf100_gr_fecs_discover_pm_image_size(struct gf100_gr *gr, u32 *psize)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0x00000000);\n\tnvkm_wr32(device, 0x409504, 0x00000025);\n\tnvkm_msec(device, 2000,\n\t\tif ((*psize = nvkm_rd32(device, 0x409800)))\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_discover_zcull_image_size(struct gf100_gr *gr, u32 *psize)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0x00000000);\n\tnvkm_wr32(device, 0x409504, 0x00000016);\n\tnvkm_msec(device, 2000,\n\t\tif ((*psize = nvkm_rd32(device, 0x409800)))\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int\ngf100_gr_fecs_discover_image_size(struct gf100_gr *gr, u32 *psize)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, 0x00000000);\n\tnvkm_wr32(device, 0x409504, 0x00000010);\n\tnvkm_msec(device, 2000,\n\t\tif ((*psize = nvkm_rd32(device, 0x409800)))\n\t\t\treturn 0;\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void\ngf100_gr_fecs_set_watchdog_timeout(struct gf100_gr *gr, u32 timeout)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x409500, timeout);\n\tnvkm_wr32(device, 0x409504, 0x00000021);\n}\n\nstatic bool\ngf100_gr_chsw_load(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tif (!gr->firmware) {\n\t\tu32 trace = nvkm_rd32(gr->base.engine.subdev.device, 0x40981c);\n\t\tif (trace & 0x00000040)\n\t\t\treturn true;\n\t} else {\n\t\tu32 mthd = nvkm_rd32(gr->base.engine.subdev.device, 0x409808);\n\t\tif (mthd & 0x00080000)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint\ngf100_gr_rops(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\treturn (nvkm_rd32(device, 0x409604) & 0x001f0000) >> 16;\n}\n\nvoid\ngf100_gr_zbc_init(struct gf100_gr *gr)\n{\n\tconst u32  zero[] = { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t\t      0x00000000, 0x00000000, 0x00000000, 0x00000000 };\n\tconst u32   one[] = { 0x3f800000, 0x3f800000, 0x3f800000, 0x3f800000,\n\t\t\t      0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff };\n\tconst u32 f32_0[] = { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n\t\t\t      0x00000000, 0x00000000, 0x00000000, 0x00000000 };\n\tconst u32 f32_1[] = { 0x3f800000, 0x3f800000, 0x3f800000, 0x3f800000,\n\t\t\t      0x3f800000, 0x3f800000, 0x3f800000, 0x3f800000 };\n\tstruct nvkm_ltc *ltc = gr->base.engine.subdev.device->ltc;\n\tint index, c = ltc->zbc_color_min, d = ltc->zbc_depth_min, s = ltc->zbc_depth_min;\n\n\tif (!gr->zbc_color[0].format) {\n\t\tgf100_gr_zbc_color_get(gr, 1,  & zero[0],   &zero[4]); c++;\n\t\tgf100_gr_zbc_color_get(gr, 2,  &  one[0],    &one[4]); c++;\n\t\tgf100_gr_zbc_color_get(gr, 4,  &f32_0[0],  &f32_0[4]); c++;\n\t\tgf100_gr_zbc_color_get(gr, 4,  &f32_1[0],  &f32_1[4]); c++;\n\t\tgf100_gr_zbc_depth_get(gr, 1, 0x00000000, 0x00000000); d++;\n\t\tgf100_gr_zbc_depth_get(gr, 1, 0x3f800000, 0x3f800000); d++;\n\t\tif (gr->func->zbc->stencil_get) {\n\t\t\tgr->func->zbc->stencil_get(gr, 1, 0x00, 0x00); s++;\n\t\t\tgr->func->zbc->stencil_get(gr, 1, 0x01, 0x01); s++;\n\t\t\tgr->func->zbc->stencil_get(gr, 1, 0xff, 0xff); s++;\n\t\t}\n\t}\n\n\tfor (index = c; index <= ltc->zbc_color_max; index++)\n\t\tgr->func->zbc->clear_color(gr, index);\n\tfor (index = d; index <= ltc->zbc_depth_max; index++)\n\t\tgr->func->zbc->clear_depth(gr, index);\n\n\tif (gr->func->zbc->clear_stencil) {\n\t\tfor (index = s; index <= ltc->zbc_depth_max; index++)\n\t\t\tgr->func->zbc->clear_stencil(gr, index);\n\t}\n}\n\n \nint\ngf100_gr_wait_idle(struct gf100_gr *gr)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tunsigned long end_jiffies = jiffies + msecs_to_jiffies(2000);\n\tbool gr_enabled, ctxsw_active, gr_busy;\n\n\tdo {\n\t\t \n\t\tnvkm_rd32(device, 0x400700);\n\n\t\tgr_enabled = nvkm_rd32(device, 0x200) & 0x1000;\n\t\tctxsw_active = nvkm_fifo_ctxsw_in_progress(&gr->base.engine);\n\t\tgr_busy = nvkm_rd32(device, 0x40060c) & 0x1;\n\n\t\tif (!gr_enabled || (!gr_busy && !ctxsw_active))\n\t\t\treturn 0;\n\t} while (time_before(jiffies, end_jiffies));\n\n\tnvkm_error(subdev,\n\t\t   \"wait for idle timeout (en: %d, ctxsw: %d, busy: %d)\\n\",\n\t\t   gr_enabled, ctxsw_active, gr_busy);\n\treturn -EAGAIN;\n}\n\nvoid\ngf100_gr_mmio(struct gf100_gr *gr, const struct gf100_gr_pack *p)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst struct gf100_gr_pack *pack;\n\tconst struct gf100_gr_init *init;\n\n\tpack_for_each_init(init, pack, p) {\n\t\tu32 next = init->addr + init->count * init->pitch;\n\t\tu32 addr = init->addr;\n\t\twhile (addr < next) {\n\t\t\tnvkm_wr32(device, addr, init->data);\n\t\t\taddr += init->pitch;\n\t\t}\n\t}\n}\n\nvoid\ngf100_gr_icmd(struct gf100_gr *gr, const struct gf100_gr_pack *p)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst struct gf100_gr_pack *pack;\n\tconst struct gf100_gr_init *init;\n\tu64 data = 0;\n\n\tnvkm_wr32(device, 0x400208, 0x80000000);\n\n\tpack_for_each_init(init, pack, p) {\n\t\tu32 next = init->addr + init->count * init->pitch;\n\t\tu32 addr = init->addr;\n\n\t\tif ((pack == p && init == p->init) || data != init->data) {\n\t\t\tnvkm_wr32(device, 0x400204, init->data);\n\t\t\tif (pack->type == 64)\n\t\t\t\tnvkm_wr32(device, 0x40020c, upper_32_bits(init->data));\n\t\t\tdata = init->data;\n\t\t}\n\n\t\twhile (addr < next) {\n\t\t\tnvkm_wr32(device, 0x400200, addr);\n\t\t\t \n\t\t\tif ((addr & 0xffff) == 0xe100)\n\t\t\t\tgf100_gr_wait_idle(gr);\n\t\t\tnvkm_msec(device, 2000,\n\t\t\t\tif (!(nvkm_rd32(device, 0x400700) & 0x00000004))\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t\taddr += init->pitch;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x400208, 0x00000000);\n}\n\nvoid\ngf100_gr_mthd(struct gf100_gr *gr, const struct gf100_gr_pack *p)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst struct gf100_gr_pack *pack;\n\tconst struct gf100_gr_init *init;\n\tu32 data = 0;\n\n\tpack_for_each_init(init, pack, p) {\n\t\tu32 ctrl = 0x80000000 | pack->type;\n\t\tu32 next = init->addr + init->count * init->pitch;\n\t\tu32 addr = init->addr;\n\n\t\tif ((pack == p && init == p->init) || data != init->data) {\n\t\t\tnvkm_wr32(device, 0x40448c, init->data);\n\t\t\tdata = init->data;\n\t\t}\n\n\t\twhile (addr < next) {\n\t\t\tnvkm_wr32(device, 0x404488, ctrl | (addr << 14));\n\t\t\taddr += init->pitch;\n\t\t}\n\t}\n}\n\nu64\ngf100_gr_units(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tu64 cfg;\n\n\tcfg  = (u32)gr->gpc_nr;\n\tcfg |= (u32)gr->tpc_total << 8;\n\tcfg |= (u64)gr->rop_nr << 32;\n\n\treturn cfg;\n}\n\nstatic const struct nvkm_bitfield gf100_dispatch_error[] = {\n\t{ 0x00000001, \"INJECTED_BUNDLE_ERROR\" },\n\t{ 0x00000002, \"CLASS_SUBCH_MISMATCH\" },\n\t{ 0x00000004, \"SUBCHSW_DURING_NOTIFY\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield gf100_m2mf_error[] = {\n\t{ 0x00000001, \"PUSH_TOO_MUCH_DATA\" },\n\t{ 0x00000002, \"PUSH_NOT_ENOUGH_DATA\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield gf100_unk6_error[] = {\n\t{ 0x00000001, \"TEMP_TOO_SMALL\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield gf100_ccache_error[] = {\n\t{ 0x00000001, \"INTR\" },\n\t{ 0x00000002, \"LDCONST_OOB\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield gf100_macro_error[] = {\n\t{ 0x00000001, \"TOO_FEW_PARAMS\" },\n\t{ 0x00000002, \"TOO_MANY_PARAMS\" },\n\t{ 0x00000004, \"ILLEGAL_OPCODE\" },\n\t{ 0x00000008, \"DOUBLE_BRANCH\" },\n\t{ 0x00000010, \"WATCHDOG\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield gk104_sked_error[] = {\n\t{ 0x00000040, \"CTA_RESUME\" },\n\t{ 0x00000080, \"CONSTANT_BUFFER_SIZE\" },\n\t{ 0x00000200, \"LOCAL_MEMORY_SIZE_POS\" },\n\t{ 0x00000400, \"LOCAL_MEMORY_SIZE_NEG\" },\n\t{ 0x00000800, \"WARP_CSTACK_SIZE\" },\n\t{ 0x00001000, \"TOTAL_TEMP_SIZE\" },\n\t{ 0x00002000, \"REGISTER_COUNT\" },\n\t{ 0x00040000, \"TOTAL_THREADS\" },\n\t{ 0x00100000, \"PROGRAM_OFFSET\" },\n\t{ 0x00200000, \"SHARED_MEMORY_SIZE\" },\n\t{ 0x00800000, \"CTA_THREAD_DIMENSION_ZERO\" },\n\t{ 0x01000000, \"MEMORY_WINDOW_OVERLAP\" },\n\t{ 0x02000000, \"SHARED_CONFIG_TOO_SMALL\" },\n\t{ 0x04000000, \"TOTAL_REGISTER_COUNT\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield gf100_gpc_rop_error[] = {\n\t{ 0x00000002, \"RT_PITCH_OVERRUN\" },\n\t{ 0x00000010, \"RT_WIDTH_OVERRUN\" },\n\t{ 0x00000020, \"RT_HEIGHT_OVERRUN\" },\n\t{ 0x00000080, \"ZETA_STORAGE_TYPE_MISMATCH\" },\n\t{ 0x00000100, \"RT_STORAGE_TYPE_MISMATCH\" },\n\t{ 0x00000400, \"RT_LINEAR_MISMATCH\" },\n\t{}\n};\n\nstatic void\ngf100_gr_trap_gpc_rop(struct gf100_gr *gr, int gpc)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tchar error[128];\n\tu32 trap[4];\n\n\ttrap[0] = nvkm_rd32(device, GPC_UNIT(gpc, 0x0420)) & 0x3fffffff;\n\ttrap[1] = nvkm_rd32(device, GPC_UNIT(gpc, 0x0434));\n\ttrap[2] = nvkm_rd32(device, GPC_UNIT(gpc, 0x0438));\n\ttrap[3] = nvkm_rd32(device, GPC_UNIT(gpc, 0x043c));\n\n\tnvkm_snprintbf(error, sizeof(error), gf100_gpc_rop_error, trap[0]);\n\n\tnvkm_error(subdev, \"GPC%d/PROP trap: %08x [%s] x = %u, y = %u, \"\n\t\t\t   \"format = %x, storage type = %x\\n\",\n\t\t   gpc, trap[0], error, trap[1] & 0xffff, trap[1] >> 16,\n\t\t   (trap[2] >> 8) & 0x3f, trap[3] & 0xff);\n\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0420), 0xc0000000);\n}\n\nconst struct nvkm_enum gf100_mp_warp_error[] = {\n\t{ 0x01, \"STACK_ERROR\" },\n\t{ 0x02, \"API_STACK_ERROR\" },\n\t{ 0x03, \"RET_EMPTY_STACK_ERROR\" },\n\t{ 0x04, \"PC_WRAP\" },\n\t{ 0x05, \"MISALIGNED_PC\" },\n\t{ 0x06, \"PC_OVERFLOW\" },\n\t{ 0x07, \"MISALIGNED_IMMC_ADDR\" },\n\t{ 0x08, \"MISALIGNED_REG\" },\n\t{ 0x09, \"ILLEGAL_INSTR_ENCODING\" },\n\t{ 0x0a, \"ILLEGAL_SPH_INSTR_COMBO\" },\n\t{ 0x0b, \"ILLEGAL_INSTR_PARAM\" },\n\t{ 0x0c, \"INVALID_CONST_ADDR\" },\n\t{ 0x0d, \"OOR_REG\" },\n\t{ 0x0e, \"OOR_ADDR\" },\n\t{ 0x0f, \"MISALIGNED_ADDR\" },\n\t{ 0x10, \"INVALID_ADDR_SPACE\" },\n\t{ 0x11, \"ILLEGAL_INSTR_PARAM2\" },\n\t{ 0x12, \"INVALID_CONST_ADDR_LDC\" },\n\t{ 0x13, \"GEOMETRY_SM_ERROR\" },\n\t{ 0x14, \"DIVERGENT\" },\n\t{ 0x15, \"WARP_EXIT\" },\n\t{}\n};\n\nconst struct nvkm_bitfield gf100_mp_global_error[] = {\n\t{ 0x00000001, \"SM_TO_SM_FAULT\" },\n\t{ 0x00000002, \"L1_ERROR\" },\n\t{ 0x00000004, \"MULTIPLE_WARP_ERRORS\" },\n\t{ 0x00000008, \"PHYSICAL_STACK_OVERFLOW\" },\n\t{ 0x00000010, \"BPT_INT\" },\n\t{ 0x00000020, \"BPT_PAUSE\" },\n\t{ 0x00000040, \"SINGLE_STEP_COMPLETE\" },\n\t{ 0x20000000, \"ECC_SEC_ERROR\" },\n\t{ 0x40000000, \"ECC_DED_ERROR\" },\n\t{ 0x80000000, \"TIMEOUT\" },\n\t{}\n};\n\nvoid\ngf100_gr_trap_mp(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 werr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x648));\n\tu32 gerr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x650));\n\tconst struct nvkm_enum *warp;\n\tchar glob[128];\n\n\tnvkm_snprintbf(glob, sizeof(glob), gf100_mp_global_error, gerr);\n\twarp = nvkm_enum_find(gf100_mp_warp_error, werr & 0xffff);\n\n\tnvkm_error(subdev, \"GPC%i/TPC%i/MP trap: \"\n\t\t\t   \"global %08x [%s] warp %04x [%s]\\n\",\n\t\t   gpc, tpc, gerr, glob, werr, warp ? warp->name : \"\");\n\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x648), 0x00000000);\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x650), gerr);\n}\n\nstatic void\ngf100_gr_trap_tpc(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x0508));\n\n\tif (stat & 0x00000001) {\n\t\tu32 trap = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x0224));\n\t\tnvkm_error(subdev, \"GPC%d/TPC%d/TEX: %08x\\n\", gpc, tpc, trap);\n\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x0224), 0xc0000000);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (stat & 0x00000002) {\n\t\tgr->func->trap_mp(gr, gpc, tpc);\n\t\tstat &= ~0x00000002;\n\t}\n\n\tif (stat & 0x00000004) {\n\t\tu32 trap = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x0084));\n\t\tnvkm_error(subdev, \"GPC%d/TPC%d/POLY: %08x\\n\", gpc, tpc, trap);\n\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x0084), 0xc0000000);\n\t\tstat &= ~0x00000004;\n\t}\n\n\tif (stat & 0x00000008) {\n\t\tu32 trap = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x048c));\n\t\tnvkm_error(subdev, \"GPC%d/TPC%d/L1C: %08x\\n\", gpc, tpc, trap);\n\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x048c), 0xc0000000);\n\t\tstat &= ~0x00000008;\n\t}\n\n\tif (stat & 0x00000010) {\n\t\tu32 trap = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x0430));\n\t\tnvkm_error(subdev, \"GPC%d/TPC%d/MPC: %08x\\n\", gpc, tpc, trap);\n\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x0430), 0xc0000000);\n\t\tstat &= ~0x00000010;\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"GPC%d/TPC%d/%08x: unknown\\n\", gpc, tpc, stat);\n\t}\n}\n\nstatic void\ngf100_gr_trap_gpc(struct gf100_gr *gr, int gpc)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, GPC_UNIT(gpc, 0x2c90));\n\tint tpc;\n\n\tif (stat & 0x00000001) {\n\t\tgf100_gr_trap_gpc_rop(gr, gpc);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (stat & 0x00000002) {\n\t\tu32 trap = nvkm_rd32(device, GPC_UNIT(gpc, 0x0900));\n\t\tnvkm_error(subdev, \"GPC%d/ZCULL: %08x\\n\", gpc, trap);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0900), 0xc0000000);\n\t\tstat &= ~0x00000002;\n\t}\n\n\tif (stat & 0x00000004) {\n\t\tu32 trap = nvkm_rd32(device, GPC_UNIT(gpc, 0x1028));\n\t\tnvkm_error(subdev, \"GPC%d/CCACHE: %08x\\n\", gpc, trap);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x1028), 0xc0000000);\n\t\tstat &= ~0x00000004;\n\t}\n\n\tif (stat & 0x00000008) {\n\t\tu32 trap = nvkm_rd32(device, GPC_UNIT(gpc, 0x0824));\n\t\tnvkm_error(subdev, \"GPC%d/ESETUP: %08x\\n\", gpc, trap);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0824), 0xc0000000);\n\t\tstat &= ~0x00000009;\n\t}\n\n\tfor (tpc = 0; tpc < gr->tpc_nr[gpc]; tpc++) {\n\t\tu32 mask = 0x00010000 << tpc;\n\t\tif (stat & mask) {\n\t\t\tgf100_gr_trap_tpc(gr, gpc, tpc);\n\t\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x2c90), mask);\n\t\t\tstat &= ~mask;\n\t\t}\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"GPC%d/%08x: unknown\\n\", gpc, stat);\n\t}\n}\n\nstatic void\ngf100_gr_trap_intr(struct gf100_gr *gr)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tchar error[128];\n\tu32 trap = nvkm_rd32(device, 0x400108);\n\tint rop, gpc;\n\n\tif (trap & 0x00000001) {\n\t\tu32 stat = nvkm_rd32(device, 0x404000);\n\n\t\tnvkm_snprintbf(error, sizeof(error), gf100_dispatch_error,\n\t\t\t       stat & 0x3fffffff);\n\t\tnvkm_error(subdev, \"DISPATCH %08x [%s]\\n\", stat, error);\n\t\tnvkm_wr32(device, 0x404000, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000001);\n\t\ttrap &= ~0x00000001;\n\t}\n\n\tif (trap & 0x00000002) {\n\t\tu32 stat = nvkm_rd32(device, 0x404600);\n\n\t\tnvkm_snprintbf(error, sizeof(error), gf100_m2mf_error,\n\t\t\t       stat & 0x3fffffff);\n\t\tnvkm_error(subdev, \"M2MF %08x [%s]\\n\", stat, error);\n\n\t\tnvkm_wr32(device, 0x404600, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000002);\n\t\ttrap &= ~0x00000002;\n\t}\n\n\tif (trap & 0x00000008) {\n\t\tu32 stat = nvkm_rd32(device, 0x408030);\n\n\t\tnvkm_snprintbf(error, sizeof(error), gf100_ccache_error,\n\t\t\t       stat & 0x3fffffff);\n\t\tnvkm_error(subdev, \"CCACHE %08x [%s]\\n\", stat, error);\n\t\tnvkm_wr32(device, 0x408030, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000008);\n\t\ttrap &= ~0x00000008;\n\t}\n\n\tif (trap & 0x00000010) {\n\t\tu32 stat = nvkm_rd32(device, 0x405840);\n\t\tnvkm_error(subdev, \"SHADER %08x, sph: 0x%06x, stage: 0x%02x\\n\",\n\t\t\t   stat, stat & 0xffffff, (stat >> 24) & 0x3f);\n\t\tnvkm_wr32(device, 0x405840, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000010);\n\t\ttrap &= ~0x00000010;\n\t}\n\n\tif (trap & 0x00000040) {\n\t\tu32 stat = nvkm_rd32(device, 0x40601c);\n\n\t\tnvkm_snprintbf(error, sizeof(error), gf100_unk6_error,\n\t\t\t       stat & 0x3fffffff);\n\t\tnvkm_error(subdev, \"UNK6 %08x [%s]\\n\", stat, error);\n\n\t\tnvkm_wr32(device, 0x40601c, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000040);\n\t\ttrap &= ~0x00000040;\n\t}\n\n\tif (trap & 0x00000080) {\n\t\tu32 stat = nvkm_rd32(device, 0x404490);\n\t\tu32 pc = nvkm_rd32(device, 0x404494);\n\t\tu32 op = nvkm_rd32(device, 0x40449c);\n\n\t\tnvkm_snprintbf(error, sizeof(error), gf100_macro_error,\n\t\t\t       stat & 0x1fffffff);\n\t\tnvkm_error(subdev, \"MACRO %08x [%s], pc: 0x%03x%s, op: 0x%08x\\n\",\n\t\t\t   stat, error, pc & 0x7ff,\n\t\t\t   (pc & 0x10000000) ? \"\" : \" (invalid)\",\n\t\t\t   op);\n\n\t\tnvkm_wr32(device, 0x404490, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000080);\n\t\ttrap &= ~0x00000080;\n\t}\n\n\tif (trap & 0x00000100) {\n\t\tu32 stat = nvkm_rd32(device, 0x407020) & 0x3fffffff;\n\n\t\tnvkm_snprintbf(error, sizeof(error), gk104_sked_error, stat);\n\t\tnvkm_error(subdev, \"SKED: %08x [%s]\\n\", stat, error);\n\n\t\tif (stat)\n\t\t\tnvkm_wr32(device, 0x407020, 0x40000000);\n\t\tnvkm_wr32(device, 0x400108, 0x00000100);\n\t\ttrap &= ~0x00000100;\n\t}\n\n\tif (trap & 0x01000000) {\n\t\tu32 stat = nvkm_rd32(device, 0x400118);\n\t\tfor (gpc = 0; stat && gpc < gr->gpc_nr; gpc++) {\n\t\t\tu32 mask = 0x00000001 << gpc;\n\t\t\tif (stat & mask) {\n\t\t\t\tgf100_gr_trap_gpc(gr, gpc);\n\t\t\t\tnvkm_wr32(device, 0x400118, mask);\n\t\t\t\tstat &= ~mask;\n\t\t\t}\n\t\t}\n\t\tnvkm_wr32(device, 0x400108, 0x01000000);\n\t\ttrap &= ~0x01000000;\n\t}\n\n\tif (trap & 0x02000000) {\n\t\tfor (rop = 0; rop < gr->rop_nr; rop++) {\n\t\t\tu32 statz = nvkm_rd32(device, ROP_UNIT(rop, 0x070));\n\t\t\tu32 statc = nvkm_rd32(device, ROP_UNIT(rop, 0x144));\n\t\t\tnvkm_error(subdev, \"ROP%d %08x %08x\\n\",\n\t\t\t\t rop, statz, statc);\n\t\t\tnvkm_wr32(device, ROP_UNIT(rop, 0x070), 0xc0000000);\n\t\t\tnvkm_wr32(device, ROP_UNIT(rop, 0x144), 0xc0000000);\n\t\t}\n\t\tnvkm_wr32(device, 0x400108, 0x02000000);\n\t\ttrap &= ~0x02000000;\n\t}\n\n\tif (trap) {\n\t\tnvkm_error(subdev, \"TRAP UNHANDLED %08x\\n\", trap);\n\t\tnvkm_wr32(device, 0x400108, trap);\n\t}\n}\n\nstatic void\ngf100_gr_ctxctl_debug_unit(struct gf100_gr *gr, u32 base)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tnvkm_error(subdev, \"%06x - done %08x\\n\", base,\n\t\t   nvkm_rd32(device, base + 0x400));\n\tnvkm_error(subdev, \"%06x - stat %08x %08x %08x %08x\\n\", base,\n\t\t   nvkm_rd32(device, base + 0x800),\n\t\t   nvkm_rd32(device, base + 0x804),\n\t\t   nvkm_rd32(device, base + 0x808),\n\t\t   nvkm_rd32(device, base + 0x80c));\n\tnvkm_error(subdev, \"%06x - stat %08x %08x %08x %08x\\n\", base,\n\t\t   nvkm_rd32(device, base + 0x810),\n\t\t   nvkm_rd32(device, base + 0x814),\n\t\t   nvkm_rd32(device, base + 0x818),\n\t\t   nvkm_rd32(device, base + 0x81c));\n}\n\nvoid\ngf100_gr_ctxctl_debug(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 gpcnr = nvkm_rd32(device, 0x409604) & 0xffff;\n\tu32 gpc;\n\n\tgf100_gr_ctxctl_debug_unit(gr, 0x409000);\n\tfor (gpc = 0; gpc < gpcnr; gpc++)\n\t\tgf100_gr_ctxctl_debug_unit(gr, 0x502000 + (gpc * 0x8000));\n}\n\nstatic void\ngf100_gr_ctxctl_isr(struct gf100_gr *gr)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x409c18);\n\n\tif (!gr->firmware && (stat & 0x00000001)) {\n\t\tu32 code = nvkm_rd32(device, 0x409814);\n\t\tif (code == E_BAD_FWMTHD) {\n\t\t\tu32 class = nvkm_rd32(device, 0x409808);\n\t\t\tu32  addr = nvkm_rd32(device, 0x40980c);\n\t\t\tu32  subc = (addr & 0x00070000) >> 16;\n\t\t\tu32  mthd = (addr & 0x00003ffc);\n\t\t\tu32  data = nvkm_rd32(device, 0x409810);\n\n\t\t\tnvkm_error(subdev, \"FECS MTHD subc %d class %04x \"\n\t\t\t\t\t   \"mthd %04x data %08x\\n\",\n\t\t\t\t   subc, class, mthd, data);\n\t\t} else {\n\t\t\tnvkm_error(subdev, \"FECS ucode error %d\\n\", code);\n\t\t}\n\t\tnvkm_wr32(device, 0x409c20, 0x00000001);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (!gr->firmware && (stat & 0x00080000)) {\n\t\tnvkm_error(subdev, \"FECS watchdog timeout\\n\");\n\t\tgf100_gr_ctxctl_debug(gr);\n\t\tnvkm_wr32(device, 0x409c20, 0x00080000);\n\t\tstat &= ~0x00080000;\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"FECS %08x\\n\", stat);\n\t\tgf100_gr_ctxctl_debug(gr);\n\t\tnvkm_wr32(device, 0x409c20, stat);\n\t}\n}\n\nstatic irqreturn_t\ngf100_gr_intr(struct nvkm_inth *inth)\n{\n\tstruct gf100_gr *gr = container_of(inth, typeof(*gr), base.engine.subdev.inth);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_chan *chan;\n\tunsigned long flags;\n\tu64 inst = nvkm_rd32(device, 0x409b00) & 0x0fffffff;\n\tu32 stat = nvkm_rd32(device, 0x400100);\n\tu32 addr = nvkm_rd32(device, 0x400704);\n\tu32 mthd = (addr & 0x00003ffc);\n\tu32 subc = (addr & 0x00070000) >> 16;\n\tu32 data = nvkm_rd32(device, 0x400708);\n\tu32 code = nvkm_rd32(device, 0x400110);\n\tu32 class;\n\tconst char *name = \"unknown\";\n\tint chid = -1;\n\n\tchan = nvkm_chan_get_inst(&gr->base.engine, (u64)inst << 12, &flags);\n\tif (chan) {\n\t\tname = chan->name;\n\t\tchid = chan->id;\n\t}\n\n\tif (device->card_type < NV_E0 || subc < 4)\n\t\tclass = nvkm_rd32(device, 0x404200 + (subc * 4));\n\telse\n\t\tclass = 0x0000;\n\n\tif (stat & 0x00000001) {\n\t\t \n\t\tnvkm_wr32(device, 0x400100, 0x00000001);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (stat & 0x00000010) {\n\t\tif (!gf100_gr_mthd_sw(device, class, mthd, data)) {\n\t\t\tnvkm_error(subdev, \"ILLEGAL_MTHD ch %d [%010llx %s] \"\n\t\t\t\t   \"subc %d class %04x mthd %04x data %08x\\n\",\n\t\t\t\t   chid, inst << 12, name, subc,\n\t\t\t\t   class, mthd, data);\n\t\t}\n\t\tnvkm_wr32(device, 0x400100, 0x00000010);\n\t\tstat &= ~0x00000010;\n\t}\n\n\tif (stat & 0x00000020) {\n\t\tnvkm_error(subdev, \"ILLEGAL_CLASS ch %d [%010llx %s] \"\n\t\t\t   \"subc %d class %04x mthd %04x data %08x\\n\",\n\t\t\t   chid, inst << 12, name, subc, class, mthd, data);\n\t\tnvkm_wr32(device, 0x400100, 0x00000020);\n\t\tstat &= ~0x00000020;\n\t}\n\n\tif (stat & 0x00100000) {\n\t\tconst struct nvkm_enum *en =\n\t\t\tnvkm_enum_find(nv50_data_error_names, code);\n\t\tnvkm_error(subdev, \"DATA_ERROR %08x [%s] ch %d [%010llx %s] \"\n\t\t\t\t   \"subc %d class %04x mthd %04x data %08x\\n\",\n\t\t\t   code, en ? en->name : \"\", chid, inst << 12,\n\t\t\t   name, subc, class, mthd, data);\n\t\tnvkm_wr32(device, 0x400100, 0x00100000);\n\t\tstat &= ~0x00100000;\n\t}\n\n\tif (stat & 0x00200000) {\n\t\tnvkm_error(subdev, \"TRAP ch %d [%010llx %s]\\n\",\n\t\t\t   chid, inst << 12, name);\n\t\tgf100_gr_trap_intr(gr);\n\t\tnvkm_wr32(device, 0x400100, 0x00200000);\n\t\tstat &= ~0x00200000;\n\t}\n\n\tif (stat & 0x00080000) {\n\t\tgf100_gr_ctxctl_isr(gr);\n\t\tnvkm_wr32(device, 0x400100, 0x00080000);\n\t\tstat &= ~0x00080000;\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"intr %08x\\n\", stat);\n\t\tnvkm_wr32(device, 0x400100, stat);\n\t}\n\n\tnvkm_wr32(device, 0x400500, 0x00010001);\n\tnvkm_chan_put(&chan, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ngf100_gr_init_fw(struct nvkm_falcon *falcon,\n\t\t struct nvkm_blob *code, struct nvkm_blob *data)\n{\n\tnvkm_falcon_load_dmem(falcon, data->data, 0x0, data->size, 0);\n\tnvkm_falcon_load_imem(falcon, code->data, 0x0, code->size, 0, 0, false);\n}\n\nstatic void\ngf100_gr_init_csdata(struct gf100_gr *gr,\n\t\t     const struct gf100_gr_pack *pack,\n\t\t     u32 falcon, u32 starstar, u32 base)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst struct gf100_gr_pack *iter;\n\tconst struct gf100_gr_init *init;\n\tu32 addr = ~0, prev = ~0, xfer = 0;\n\tu32 star, temp;\n\n\tnvkm_wr32(device, falcon + 0x01c0, 0x02000000 + starstar);\n\tstar = nvkm_rd32(device, falcon + 0x01c4);\n\ttemp = nvkm_rd32(device, falcon + 0x01c4);\n\tif (temp > star)\n\t\tstar = temp;\n\tnvkm_wr32(device, falcon + 0x01c0, 0x01000000 + star);\n\n\tpack_for_each_init(init, iter, pack) {\n\t\tu32 head = init->addr - base;\n\t\tu32 tail = head + init->count * init->pitch;\n\t\twhile (head < tail) {\n\t\t\tif (head != prev + 4 || xfer >= 32) {\n\t\t\t\tif (xfer) {\n\t\t\t\t\tu32 data = ((--xfer << 26) | addr);\n\t\t\t\t\tnvkm_wr32(device, falcon + 0x01c4, data);\n\t\t\t\t\tstar += 4;\n\t\t\t\t}\n\t\t\t\taddr = head;\n\t\t\t\txfer = 0;\n\t\t\t}\n\t\t\tprev = head;\n\t\t\txfer = xfer + 1;\n\t\t\thead = head + init->pitch;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, falcon + 0x01c4, (--xfer << 26) | addr);\n\tnvkm_wr32(device, falcon + 0x01c0, 0x01000004 + starstar);\n\tnvkm_wr32(device, falcon + 0x01c4, star + 4);\n}\n\n \nstatic int\ngf100_gr_init_ctxctl_ext(struct gf100_gr *gr)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 lsf_mask = 0;\n\tint ret;\n\n\t \n\tnvkm_mc_unk260(device, 0);\n\n\t \n\n\tif (!nvkm_acr_managed_falcon(device, NVKM_ACR_LSF_FECS)) {\n\t\tgf100_gr_init_fw(&gr->fecs.falcon, &gr->fecs.inst,\n\t\t\t\t\t\t   &gr->fecs.data);\n\t} else {\n\t\tlsf_mask |= BIT(NVKM_ACR_LSF_FECS);\n\t}\n\n\tif (!nvkm_acr_managed_falcon(device, NVKM_ACR_LSF_GPCCS)) {\n\t\tgf100_gr_init_fw(&gr->gpccs.falcon, &gr->gpccs.inst,\n\t\t\t\t\t\t    &gr->gpccs.data);\n\t} else {\n\t\tlsf_mask |= BIT(NVKM_ACR_LSF_GPCCS);\n\t}\n\n\tif (lsf_mask) {\n\t\tret = nvkm_acr_bootstrap_falcons(device, lsf_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnvkm_mc_unk260(device, 1);\n\n\t \n\tnvkm_wr32(device, 0x409800, 0x00000000);\n\tnvkm_wr32(device, 0x41a10c, 0x00000000);\n\tnvkm_wr32(device, 0x40910c, 0x00000000);\n\n\tnvkm_falcon_start(&gr->gpccs.falcon);\n\tnvkm_falcon_start(&gr->fecs.falcon);\n\n\tif (nvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x409800) & 0x00000001)\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -EBUSY;\n\n\tgf100_gr_fecs_set_watchdog_timeout(gr, 0x7fffffff);\n\n\t \n\tret = gf100_gr_fecs_discover_image_size(gr, &gr->size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = gf100_gr_fecs_discover_zcull_image_size(gr, &gr->size_zcull);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = gf100_gr_fecs_discover_pm_image_size(gr, &gr->size_pm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (0) {\n\t\tret = gf100_gr_fecs_elpg_bind(gr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngf100_gr_init_ctxctl_int(struct gf100_gr *gr)\n{\n\tconst struct gf100_grctx_func *grctx = gr->func->grctx;\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\tif (!gr->func->fecs.ucode) {\n\t\treturn -ENOSYS;\n\t}\n\n\t \n\tnvkm_mc_unk260(device, 0);\n\tnvkm_falcon_load_dmem(&gr->fecs.falcon,\n\t\t\t      gr->func->fecs.ucode->data.data, 0x0,\n\t\t\t      gr->func->fecs.ucode->data.size, 0);\n\tnvkm_falcon_load_imem(&gr->fecs.falcon,\n\t\t\t      gr->func->fecs.ucode->code.data, 0x0,\n\t\t\t      gr->func->fecs.ucode->code.size, 0, 0, false);\n\n\t \n\tnvkm_falcon_load_dmem(&gr->gpccs.falcon,\n\t\t\t      gr->func->gpccs.ucode->data.data, 0x0,\n\t\t\t      gr->func->gpccs.ucode->data.size, 0);\n\tnvkm_falcon_load_imem(&gr->gpccs.falcon,\n\t\t\t      gr->func->gpccs.ucode->code.data, 0x0,\n\t\t\t      gr->func->gpccs.ucode->code.size, 0, 0, false);\n\tnvkm_mc_unk260(device, 1);\n\n\t \n\tgf100_gr_init_csdata(gr, grctx->hub, 0x409000, 0x000, 0x000000);\n\tgf100_gr_init_csdata(gr, grctx->gpc_0, 0x41a000, 0x000, 0x418000);\n\tgf100_gr_init_csdata(gr, grctx->gpc_1, 0x41a000, 0x000, 0x418000);\n\tgf100_gr_init_csdata(gr, grctx->tpc, 0x41a000, 0x004, 0x419800);\n\tgf100_gr_init_csdata(gr, grctx->ppc, 0x41a000, 0x008, 0x41be00);\n\n\t \n\tnvkm_wr32(device, 0x40910c, 0x00000000);\n\tnvkm_wr32(device, 0x409100, 0x00000002);\n\tif (nvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x409800) & 0x80000000)\n\t\t\tbreak;\n\t) < 0) {\n\t\tgf100_gr_ctxctl_debug(gr);\n\t\treturn -EBUSY;\n\t}\n\n\tgr->size = nvkm_rd32(device, 0x409804);\n\treturn 0;\n}\n\nint\ngf100_gr_init_ctxctl(struct gf100_gr *gr)\n{\n\tint ret;\n\n\tif (gr->firmware)\n\t\tret = gf100_gr_init_ctxctl_ext(gr);\n\telse\n\t\tret = gf100_gr_init_ctxctl_int(gr);\n\n\treturn ret;\n}\n\nint\ngf100_gr_oneinit_sm_id(struct gf100_gr *gr)\n{\n\tint tpc, gpc;\n\n\tfor (tpc = 0; tpc < gr->tpc_max; tpc++) {\n\t\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\t\tif (tpc < gr->tpc_nr[gpc]) {\n\t\t\t\tgr->sm[gr->sm_nr].gpc = gpc;\n\t\t\t\tgr->sm[gr->sm_nr].tpc = tpc;\n\t\t\t\tgr->sm_nr++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\ngf100_gr_oneinit_tiles(struct gf100_gr *gr)\n{\n\tstatic const u8 primes[] = {\n\t\t3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61\n\t};\n\tint init_frac[GPC_MAX], init_err[GPC_MAX], run_err[GPC_MAX], i, j;\n\tu32 mul_factor, comm_denom;\n\tu8  gpc_map[GPC_MAX];\n\tbool sorted;\n\n\tswitch (gr->tpc_total) {\n\tcase 15: gr->screen_tile_row_offset = 0x06; break;\n\tcase 14: gr->screen_tile_row_offset = 0x05; break;\n\tcase 13: gr->screen_tile_row_offset = 0x02; break;\n\tcase 11: gr->screen_tile_row_offset = 0x07; break;\n\tcase 10: gr->screen_tile_row_offset = 0x06; break;\n\tcase  7:\n\tcase  5: gr->screen_tile_row_offset = 0x01; break;\n\tcase  3: gr->screen_tile_row_offset = 0x02; break;\n\tcase  2:\n\tcase  1: gr->screen_tile_row_offset = 0x01; break;\n\tdefault: gr->screen_tile_row_offset = 0x03;\n\t\tfor (i = 0; i < ARRAY_SIZE(primes); i++) {\n\t\t\tif (gr->tpc_total % primes[i]) {\n\t\t\t\tgr->screen_tile_row_offset = primes[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < gr->gpc_nr; i++)\n\t\tgpc_map[i] = i;\n\tsorted = false;\n\n\twhile (!sorted) {\n\t\tfor (sorted = true, i = 0; i < gr->gpc_nr - 1; i++) {\n\t\t\tif (gr->tpc_nr[gpc_map[i + 1]] >\n\t\t\t    gr->tpc_nr[gpc_map[i + 0]]) {\n\t\t\t\tu8 swap = gpc_map[i];\n\t\t\t\tgpc_map[i + 0] = gpc_map[i + 1];\n\t\t\t\tgpc_map[i + 1] = swap;\n\t\t\t\tsorted = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tmul_factor = gr->gpc_nr * gr->tpc_max;\n\tif (mul_factor & 1)\n\t\tmul_factor = 2;\n\telse\n\t\tmul_factor = 1;\n\n\tcomm_denom = gr->gpc_nr * gr->tpc_max * mul_factor;\n\n\tfor (i = 0; i < gr->gpc_nr; i++) {\n\t\tinit_frac[i] = gr->tpc_nr[gpc_map[i]] * gr->gpc_nr * mul_factor;\n\t\tinit_err[i] = i * gr->tpc_max * mul_factor - comm_denom/2;\n\t\trun_err[i] = init_frac[i] + init_err[i];\n\t}\n\n\tfor (i = 0; i < gr->tpc_total;) {\n\t\tfor (j = 0; j < gr->gpc_nr; j++) {\n\t\t\tif ((run_err[j] * 2) >= comm_denom) {\n\t\t\t\tgr->tile[i++] = gpc_map[j];\n\t\t\t\trun_err[j] += init_frac[j] - comm_denom;\n\t\t\t} else {\n\t\t\t\trun_err[j] += init_frac[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\ngf100_gr_oneinit(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_intr *intr = &device->mc->intr;\n\tenum nvkm_intr_type intr_type = NVKM_INTR_SUBDEV;\n\tint ret, i, j;\n\n\tif (gr->func->oneinit_intr)\n\t\tintr = gr->func->oneinit_intr(gr, &intr_type);\n\n\tret = nvkm_inth_add(intr, intr_type, NVKM_INTR_PRIO_NORMAL, &gr->base.engine.subdev,\n\t\t\t    gf100_gr_intr, &gr->base.engine.subdev.inth);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_pmu_pgob(device->pmu, false);\n\n\tgr->rop_nr = gr->func->rops(gr);\n\tgr->gpc_nr = nvkm_rd32(device, 0x409604) & 0x0000001f;\n\tfor (i = 0; i < gr->gpc_nr; i++) {\n\t\tgr->tpc_nr[i]  = nvkm_rd32(device, GPC_UNIT(i, 0x2608));\n\t\tgr->tpc_max = max(gr->tpc_max, gr->tpc_nr[i]);\n\t\tgr->tpc_total += gr->tpc_nr[i];\n\t\tfor (j = 0; j < gr->func->ppc_nr; j++) {\n\t\t\tgr->ppc_tpc_mask[i][j] =\n\t\t\t\tnvkm_rd32(device, GPC_UNIT(i, 0x0c30 + (j * 4)));\n\t\t\tif (gr->ppc_tpc_mask[i][j] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tgr->ppc_nr[i]++;\n\n\t\t\tgr->ppc_mask[i] |= (1 << j);\n\t\t\tgr->ppc_tpc_nr[i][j] = hweight8(gr->ppc_tpc_mask[i][j]);\n\t\t\tif (gr->ppc_tpc_min == 0 ||\n\t\t\t    gr->ppc_tpc_min > gr->ppc_tpc_nr[i][j])\n\t\t\t\tgr->ppc_tpc_min = gr->ppc_tpc_nr[i][j];\n\t\t\tif (gr->ppc_tpc_max < gr->ppc_tpc_nr[i][j])\n\t\t\t\tgr->ppc_tpc_max = gr->ppc_tpc_nr[i][j];\n\t\t}\n\n\t\tgr->ppc_total += gr->ppc_nr[i];\n\t}\n\n\t \n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, gr->func->grctx->pagepool_size,\n\t\t\t      0x100, false, &gr->pagepool);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, gr->func->grctx->bundle_size,\n\t\t\t      0x100, false, &gr->bundle_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, gr->func->grctx->attrib_cb_size(gr),\n\t\t\t      0x1000, false, &gr->attrib_cb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gr->func->grctx->unknown_size) {\n\t\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, gr->func->grctx->unknown_size,\n\t\t\t\t      0x100, false, &gr->unknown);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmemset(gr->tile, 0xff, sizeof(gr->tile));\n\tgr->func->oneinit_tiles(gr);\n\n\treturn gr->func->oneinit_sm_id(gr);\n}\n\nstatic int\ngf100_gr_init_(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tstruct nvkm_subdev *subdev = &base->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tbool reset = device->chipset == 0x137 || device->chipset == 0x138;\n\tint ret;\n\n\t \n\treset = nvkm_boolopt(device->cfgopt, \"NvGrResetWar\", reset);\n\tif (reset) {\n\t\tnvkm_mask(device, 0x000200, 0x00001000, 0x00000000);\n\t\tnvkm_rd32(device, 0x000200);\n\t\tmsleep(50);\n\t\tnvkm_mask(device, 0x000200, 0x00001000, 0x00001000);\n\t\tnvkm_rd32(device, 0x000200);\n\t}\n\n\tnvkm_pmu_pgob(gr->base.engine.subdev.device->pmu, false);\n\n\tret = nvkm_falcon_get(&gr->fecs.falcon, subdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_falcon_get(&gr->gpccs.falcon, subdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gr->func->init(gr);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_inth_allow(&subdev->inth);\n\treturn 0;\n}\n\nstatic int\ngf100_gr_fini(struct nvkm_gr *base, bool suspend)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\n\tnvkm_inth_block(&subdev->inth);\n\n\tnvkm_falcon_put(&gr->gpccs.falcon, subdev);\n\tnvkm_falcon_put(&gr->fecs.falcon, subdev);\n\treturn 0;\n}\n\nstatic void *\ngf100_gr_dtor(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\n\tkfree(gr->data);\n\n\tnvkm_memory_unref(&gr->unknown);\n\tnvkm_memory_unref(&gr->attrib_cb);\n\tnvkm_memory_unref(&gr->bundle_cb);\n\tnvkm_memory_unref(&gr->pagepool);\n\n\tnvkm_falcon_dtor(&gr->gpccs.falcon);\n\tnvkm_falcon_dtor(&gr->fecs.falcon);\n\n\tnvkm_blob_dtor(&gr->fecs.inst);\n\tnvkm_blob_dtor(&gr->fecs.data);\n\tnvkm_blob_dtor(&gr->gpccs.inst);\n\tnvkm_blob_dtor(&gr->gpccs.data);\n\n\tvfree(gr->bundle64);\n\tvfree(gr->bundle_veid);\n\tvfree(gr->bundle);\n\tvfree(gr->method);\n\tvfree(gr->sw_ctx);\n\tvfree(gr->sw_nonctx);\n\tvfree(gr->sw_nonctx1);\n\tvfree(gr->sw_nonctx2);\n\tvfree(gr->sw_nonctx3);\n\tvfree(gr->sw_nonctx4);\n\n\treturn gr;\n}\n\nstatic const struct nvkm_falcon_func\ngf100_gr_flcn = {\n\t.load_imem = nvkm_falcon_v1_load_imem,\n\t.load_dmem = nvkm_falcon_v1_load_dmem,\n\t.start = nvkm_falcon_v1_start,\n};\n\nvoid\ngf100_gr_init_num_tpc_per_gpc(struct gf100_gr *gr, bool pd, bool ds)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint gpc, i, j;\n\tu32 data;\n\n\tfor (gpc = 0, i = 0; i < 4; i++) {\n\t\tfor (data = 0, j = 0; j < 8 && gpc < gr->gpc_nr; j++, gpc++)\n\t\t\tdata |= gr->tpc_nr[gpc] << (j * 4);\n\t\tif (pd)\n\t\t\tnvkm_wr32(device, 0x406028 + (i * 4), data);\n\t\tif (ds)\n\t\t\tnvkm_wr32(device, 0x405870 + (i * 4), data);\n\t}\n}\n\nvoid\ngf100_gr_init_400054(struct gf100_gr *gr)\n{\n\tnvkm_wr32(gr->base.engine.subdev.device, 0x400054, 0x34ce3464);\n}\n\nvoid\ngf100_gr_init_exception2(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x40011c, 0xffffffff);\n\tnvkm_wr32(device, 0x400134, 0xffffffff);\n}\n\nvoid\ngf100_gr_init_rop_exceptions(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint rop;\n\n\tfor (rop = 0; rop < gr->rop_nr; rop++) {\n\t\tnvkm_wr32(device, ROP_UNIT(rop, 0x144), 0x40000000);\n\t\tnvkm_wr32(device, ROP_UNIT(rop, 0x070), 0x40000000);\n\t\tnvkm_wr32(device, ROP_UNIT(rop, 0x204), 0xffffffff);\n\t\tnvkm_wr32(device, ROP_UNIT(rop, 0x208), 0xffffffff);\n\t}\n}\n\nvoid\ngf100_gr_init_shader_exceptions(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x644), 0x001ffffe);\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x64c), 0x0000000f);\n}\n\nvoid\ngf100_gr_init_tex_hww_esr(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x224), 0xc0000000);\n}\n\nvoid\ngf100_gr_init_419eb4(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, 0x419eb4, 0x00001000, 0x00001000);\n}\n\nvoid\ngf100_gr_init_419cc0(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint gpc, tpc;\n\n\tnvkm_mask(device, 0x419cc0, 0x00000008, 0x00000008);\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tfor (tpc = 0; tpc < gr->tpc_nr[gpc]; tpc++)\n\t\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x48c), 0xc0000000);\n\t}\n}\n\nvoid\ngf100_gr_init_40601c(struct gf100_gr *gr)\n{\n\tnvkm_wr32(gr->base.engine.subdev.device, 0x40601c, 0xc0000000);\n}\n\nvoid\ngf100_gr_init_fecs_exceptions(struct gf100_gr *gr)\n{\n\tconst u32 data = gr->firmware ? 0x000e0000 : 0x000e0001;\n\tnvkm_wr32(gr->base.engine.subdev.device, 0x409c24, data);\n}\n\nvoid\ngf100_gr_init_gpc_mmu(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tstruct nvkm_fb *fb = device->fb;\n\n\tnvkm_wr32(device, 0x418880, nvkm_rd32(device, 0x100c80) & 0x00000001);\n\tnvkm_wr32(device, 0x4188a4, 0x03000000);\n\tnvkm_wr32(device, 0x418888, 0x00000000);\n\tnvkm_wr32(device, 0x41888c, 0x00000000);\n\tnvkm_wr32(device, 0x418890, 0x00000000);\n\tnvkm_wr32(device, 0x418894, 0x00000000);\n\tnvkm_wr32(device, 0x4188b4, nvkm_memory_addr(fb->mmu_wr) >> 8);\n\tnvkm_wr32(device, 0x4188b8, nvkm_memory_addr(fb->mmu_rd) >> 8);\n}\n\nvoid\ngf100_gr_init_num_active_ltcs(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, GPC_BCAST(0x08ac), nvkm_rd32(device, 0x100800));\n}\n\nvoid\ngf100_gr_init_zcull(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst u32 magicgpc918 = DIV_ROUND_UP(0x00800000, gr->tpc_total);\n\tconst u8 tile_nr = ALIGN(gr->tpc_total, 32);\n\tu8 bank[GPC_MAX] = {}, gpc, i, j;\n\tu32 data;\n\n\tfor (i = 0; i < tile_nr; i += 8) {\n\t\tfor (data = 0, j = 0; j < 8 && i + j < gr->tpc_total; j++) {\n\t\t\tdata |= bank[gr->tile[i + j]] << (j * 4);\n\t\t\tbank[gr->tile[i + j]]++;\n\t\t}\n\t\tnvkm_wr32(device, GPC_BCAST(0x0980 + ((i / 8) * 4)), data);\n\t}\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0914),\n\t\t\t  gr->screen_tile_row_offset << 8 | gr->tpc_nr[gpc]);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0910), 0x00040000 |\n\t\t\t\t\t\t\t gr->tpc_total);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0918), magicgpc918);\n\t}\n\n\tnvkm_wr32(device, GPC_BCAST(0x1bd4), magicgpc918);\n}\n\nvoid\ngf100_gr_init_vsc_stream_master(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, TPC_UNIT(0, 0, 0x05c), 0x00000001, 0x00000001);\n}\n\nstatic int\ngf100_gr_reset(struct nvkm_gr *base)\n{\n\tstruct nvkm_subdev *subdev = &base->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gf100_gr *gr = gf100_gr(base);\n\n\tnvkm_mask(device, 0x400500, 0x00000001, 0x00000000);\n\n\tWARN_ON(gf100_gr_fecs_halt_pipeline(gr));\n\n\tsubdev->func->fini(subdev, false);\n\tnvkm_mc_disable(device, subdev->type, subdev->inst);\n\tif (gr->func->gpccs.reset)\n\t\tgr->func->gpccs.reset(gr);\n\n\tnvkm_mc_enable(device, subdev->type, subdev->inst);\n\treturn subdev->func->init(subdev);\n}\n\nint\ngf100_gr_init(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint gpc, tpc;\n\n\tnvkm_mask(device, 0x400500, 0x00010001, 0x00000000);\n\n\tgr->func->init_gpc_mmu(gr);\n\n\tif (gr->sw_nonctx1) {\n\t\tgf100_gr_mmio(gr, gr->sw_nonctx1);\n\t\tgf100_gr_mmio(gr, gr->sw_nonctx2);\n\t\tgf100_gr_mmio(gr, gr->sw_nonctx3);\n\t\tgf100_gr_mmio(gr, gr->sw_nonctx4);\n\t} else\n\tif (gr->sw_nonctx) {\n\t\tgf100_gr_mmio(gr, gr->sw_nonctx);\n\t} else {\n\t\tgf100_gr_mmio(gr, gr->func->mmio);\n\t}\n\n\tgf100_gr_wait_idle(gr);\n\n\tif (gr->func->init_r405a14)\n\t\tgr->func->init_r405a14(gr);\n\n\tif (gr->func->clkgate_pack)\n\t\tnvkm_therm_clkgate_init(device->therm, gr->func->clkgate_pack);\n\n\tif (gr->func->init_bios)\n\t\tgr->func->init_bios(gr);\n\n\tgr->func->init_vsc_stream_master(gr);\n\tgr->func->init_zcull(gr);\n\tgr->func->init_num_active_ltcs(gr);\n\tif (gr->func->init_rop_active_fbps)\n\t\tgr->func->init_rop_active_fbps(gr);\n\tif (gr->func->init_bios_2)\n\t\tgr->func->init_bios_2(gr);\n\tif (gr->func->init_swdx_pes_mask)\n\t\tgr->func->init_swdx_pes_mask(gr);\n\tif (gr->func->init_fs)\n\t\tgr->func->init_fs(gr);\n\n\tnvkm_wr32(device, 0x400500, 0x00010001);\n\n\tnvkm_wr32(device, 0x400100, 0xffffffff);\n\tnvkm_wr32(device, 0x40013c, 0xffffffff);\n\tnvkm_wr32(device, 0x400124, 0x00000002);\n\n\tgr->func->init_fecs_exceptions(gr);\n\n\tif (gr->func->init_40a790)\n\t\tgr->func->init_40a790(gr);\n\n\tif (gr->func->init_ds_hww_esr_2)\n\t\tgr->func->init_ds_hww_esr_2(gr);\n\n\tnvkm_wr32(device, 0x404000, 0xc0000000);\n\tnvkm_wr32(device, 0x404600, 0xc0000000);\n\tnvkm_wr32(device, 0x408030, 0xc0000000);\n\n\tif (gr->func->init_40601c)\n\t\tgr->func->init_40601c(gr);\n\n\tnvkm_wr32(device, 0x406018, 0xc0000000);\n\tnvkm_wr32(device, 0x404490, 0xc0000000);\n\n\tif (gr->func->init_sked_hww_esr)\n\t\tgr->func->init_sked_hww_esr(gr);\n\n\tnvkm_wr32(device, 0x405840, 0xc0000000);\n\tnvkm_wr32(device, 0x405844, 0x00ffffff);\n\n\tif (gr->func->init_419cc0)\n\t\tgr->func->init_419cc0(gr);\n\tif (gr->func->init_419eb4)\n\t\tgr->func->init_419eb4(gr);\n\tif (gr->func->init_419c9c)\n\t\tgr->func->init_419c9c(gr);\n\n\tif (gr->func->init_ppc_exceptions)\n\t\tgr->func->init_ppc_exceptions(gr);\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0420), 0xc0000000);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0900), 0xc0000000);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x1028), 0xc0000000);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0824), 0xc0000000);\n\t\tfor (tpc = 0; tpc < gr->tpc_nr[gpc]; tpc++) {\n\t\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x508), 0xffffffff);\n\t\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x50c), 0xffffffff);\n\t\t\tif (gr->func->init_tex_hww_esr)\n\t\t\t\tgr->func->init_tex_hww_esr(gr, gpc, tpc);\n\t\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x084), 0xc0000000);\n\t\t\tif (gr->func->init_504430)\n\t\t\t\tgr->func->init_504430(gr, gpc, tpc);\n\t\t\tgr->func->init_shader_exceptions(gr, gpc, tpc);\n\t\t}\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x2c90), 0xffffffff);\n\t\tnvkm_wr32(device, GPC_UNIT(gpc, 0x2c94), 0xffffffff);\n\t}\n\n\tgr->func->init_rop_exceptions(gr);\n\n\tnvkm_wr32(device, 0x400108, 0xffffffff);\n\tnvkm_wr32(device, 0x400138, 0xffffffff);\n\tnvkm_wr32(device, 0x400118, 0xffffffff);\n\tnvkm_wr32(device, 0x400130, 0xffffffff);\n\tif (gr->func->init_exception2)\n\t\tgr->func->init_exception2(gr);\n\n\tif (gr->func->init_400054)\n\t\tgr->func->init_400054(gr);\n\n\tgf100_gr_zbc_init(gr);\n\n\tif (gr->func->init_4188a4)\n\t\tgr->func->init_4188a4(gr);\n\n\treturn gf100_gr_init_ctxctl(gr);\n}\n\nvoid\ngf100_gr_fecs_reset(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409614, 0x00000070);\n\tnvkm_usec(device, 10, NVKM_DELAY);\n\tnvkm_mask(device, 0x409614, 0x00000700, 0x00000700);\n\tnvkm_usec(device, 10, NVKM_DELAY);\n\tnvkm_rd32(device, 0x409614);\n}\n\n#include \"fuc/hubgf100.fuc3.h\"\n\nstruct gf100_gr_ucode\ngf100_gr_fecs_ucode = {\n\t.code.data = gf100_grhub_code,\n\t.code.size = sizeof(gf100_grhub_code),\n\t.data.data = gf100_grhub_data,\n\t.data.size = sizeof(gf100_grhub_data),\n};\n\n#include \"fuc/gpcgf100.fuc3.h\"\n\nstruct gf100_gr_ucode\ngf100_gr_gpccs_ucode = {\n\t.code.data = gf100_grgpc_code,\n\t.code.size = sizeof(gf100_grgpc_code),\n\t.data.data = gf100_grgpc_data,\n\t.data.size = sizeof(gf100_grgpc_data),\n};\n\nstatic int\ngf100_gr_nonstall(struct nvkm_gr *base)\n{\n\tstruct gf100_gr *gr = gf100_gr(base);\n\n\tif (gr->func->nonstall)\n\t\treturn gr->func->nonstall(gr);\n\n\treturn -EINVAL;\n}\n\nstatic const struct nvkm_gr_func\ngf100_gr_ = {\n\t.dtor = gf100_gr_dtor,\n\t.oneinit = gf100_gr_oneinit,\n\t.init = gf100_gr_init_,\n\t.fini = gf100_gr_fini,\n\t.nonstall = gf100_gr_nonstall,\n\t.reset = gf100_gr_reset,\n\t.units = gf100_gr_units,\n\t.chan_new = gf100_gr_chan_new,\n\t.object_get = gf100_gr_object_get,\n\t.chsw_load = gf100_gr_chsw_load,\n\t.ctxsw.pause = gf100_gr_fecs_stop_ctxsw,\n\t.ctxsw.resume = gf100_gr_fecs_start_ctxsw,\n\t.ctxsw.inst = gf100_gr_ctxsw_inst,\n};\n\nstatic const struct gf100_gr_func\ngf100_gr = {\n\t.oneinit_tiles = gf100_gr_oneinit_tiles,\n\t.oneinit_sm_id = gf100_gr_oneinit_sm_id,\n\t.init = gf100_gr_init,\n\t.init_gpc_mmu = gf100_gr_init_gpc_mmu,\n\t.init_vsc_stream_master = gf100_gr_init_vsc_stream_master,\n\t.init_zcull = gf100_gr_init_zcull,\n\t.init_num_active_ltcs = gf100_gr_init_num_active_ltcs,\n\t.init_fecs_exceptions = gf100_gr_init_fecs_exceptions,\n\t.init_40601c = gf100_gr_init_40601c,\n\t.init_419cc0 = gf100_gr_init_419cc0,\n\t.init_419eb4 = gf100_gr_init_419eb4,\n\t.init_tex_hww_esr = gf100_gr_init_tex_hww_esr,\n\t.init_shader_exceptions = gf100_gr_init_shader_exceptions,\n\t.init_rop_exceptions = gf100_gr_init_rop_exceptions,\n\t.init_exception2 = gf100_gr_init_exception2,\n\t.init_400054 = gf100_gr_init_400054,\n\t.trap_mp = gf100_gr_trap_mp,\n\t.mmio = gf100_gr_pack_mmio,\n\t.fecs.ucode = &gf100_gr_fecs_ucode,\n\t.fecs.reset = gf100_gr_fecs_reset,\n\t.gpccs.ucode = &gf100_gr_gpccs_ucode,\n\t.rops = gf100_gr_rops,\n\t.grctx = &gf100_grctx,\n\t.zbc = &gf100_gr_zbc,\n\t.sclass = {\n\t\t{ -1, -1, FERMI_TWOD_A },\n\t\t{ -1, -1, FERMI_MEMORY_TO_MEMORY_FORMAT_A },\n\t\t{ -1, -1, FERMI_A, &gf100_fermi },\n\t\t{ -1, -1, FERMI_COMPUTE_A },\n\t\t{}\n\t}\n};\n\nint\ngf100_gr_nofw(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tgr->firmware = false;\n\treturn 0;\n}\n\nstatic int\ngf100_gr_load_fw(struct gf100_gr *gr, const char *name,\n\t\t struct nvkm_blob *blob)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst struct firmware *fw;\n\tchar f[32];\n\tint ret;\n\n\tsnprintf(f, sizeof(f), \"nouveau/nv%02x_%s\", device->chipset, name);\n\tret = request_firmware(&fw, f, device->dev);\n\tif (ret) {\n\t\tsnprintf(f, sizeof(f), \"nouveau/%s\", name);\n\t\tret = request_firmware(&fw, f, device->dev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"failed to load %s\\n\", name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tblob->size = fw->size;\n\tblob->data = kmemdup(fw->data, blob->size, GFP_KERNEL);\n\trelease_firmware(fw);\n\treturn (blob->data != NULL) ? 0 : -ENOMEM;\n}\n\nint\ngf100_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tif (!nvkm_boolopt(device->cfgopt, \"NvGrUseFW\", false))\n\t\treturn -EINVAL;\n\n\tif (gf100_gr_load_fw(gr, \"fuc409c\", &gr->fecs.inst) ||\n\t    gf100_gr_load_fw(gr, \"fuc409d\", &gr->fecs.data) ||\n\t    gf100_gr_load_fw(gr, \"fuc41ac\", &gr->gpccs.inst) ||\n\t    gf100_gr_load_fw(gr, \"fuc41ad\", &gr->gpccs.data))\n\t\treturn -ENOENT;\n\n\tgr->firmware = true;\n\treturn 0;\n}\n\nstatic const struct gf100_gr_fwif\ngf100_gr_fwif[] = {\n\t{ -1, gf100_gr_load, &gf100_gr },\n\t{ -1, gf100_gr_nofw, &gf100_gr },\n\t{}\n};\n\nint\ngf100_gr_new_(const struct gf100_gr_fwif *fwif, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\tstruct gf100_gr *gr;\n\tint ret;\n\n\tif (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pgr = &gr->base;\n\n\tret = nvkm_gr_ctor(&gf100_gr_, device, type, inst, true, &gr->base);\n\tif (ret)\n\t\treturn ret;\n\n\tfwif = nvkm_firmware_load(&gr->base.engine.subdev, fwif, \"Gr\", gr);\n\tif (IS_ERR(fwif))\n\t\treturn PTR_ERR(fwif);\n\n\tgr->func = fwif->func;\n\n\tret = nvkm_falcon_ctor(&gf100_gr_flcn, &gr->base.engine.subdev,\n\t\t\t       \"fecs\", 0x409000, &gr->fecs.falcon);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&gr->fecs.mutex);\n\n\tret = nvkm_falcon_ctor(&gf100_gr_flcn, &gr->base.engine.subdev,\n\t\t\t       \"gpccs\", 0x41a000, &gr->gpccs.falcon);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint\ngf100_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn gf100_gr_new_(gf100_gr_fwif, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}