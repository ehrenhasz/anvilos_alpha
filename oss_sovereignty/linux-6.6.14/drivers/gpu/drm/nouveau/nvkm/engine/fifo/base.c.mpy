{
  "module_name": "base.c",
  "hash_id": "764218c10d5f679a1c878f12e15e64bf5efde6a6f1825fb0e5e48c2795cc52c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n#include \"runq.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/bar.h>\n#include <subdev/mc.h>\n#include <subdev/mmu.h>\n\n#include <nvif/cl0080.h>\n#include <nvif/unpack.h>\n\nbool\nnvkm_fifo_ctxsw_in_progress(struct nvkm_engine *engine)\n{\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\n\tnvkm_runl_foreach(runl, engine->subdev.device->fifo) {\n\t\tnvkm_runl_foreach_engn(engn, runl) {\n\t\t\tif (engn->engine == engine)\n\t\t\t\treturn engn->func->chsw ? engn->func->chsw(engn) : false;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid\nnvkm_fifo_pause(struct nvkm_fifo *fifo, unsigned long *flags)\n{\n\treturn fifo->func->pause(fifo, flags);\n}\n\nvoid\nnvkm_fifo_start(struct nvkm_fifo *fifo, unsigned long *flags)\n{\n\treturn fifo->func->start(fifo, flags);\n}\n\nvoid\nnvkm_fifo_fault(struct nvkm_fifo *fifo, struct nvkm_fault_data *info)\n{\n\treturn fifo->func->mmu_fault->recover(fifo, info);\n}\n\nstatic int\nnvkm_fifo_class_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,\n\t\t    void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tstruct nvkm_fifo *fifo = nvkm_fifo(oclass->engine);\n\n\tif (oclass->engn == &fifo->func->cgrp.user)\n\t\treturn nvkm_ucgrp_new(fifo, oclass, argv, argc, pobject);\n\n\tif (oclass->engn == &fifo->func->chan.user)\n\t\treturn nvkm_uchan_new(fifo, NULL, oclass, argv, argc, pobject);\n\n\tWARN_ON(1);\n\treturn -ENOSYS;\n}\n\nstatic const struct nvkm_device_oclass\nnvkm_fifo_class = {\n\t.ctor = nvkm_fifo_class_new,\n};\n\nstatic int\nnvkm_fifo_class_get(struct nvkm_oclass *oclass, int index, const struct nvkm_device_oclass **class)\n{\n\tstruct nvkm_fifo *fifo = nvkm_fifo(oclass->engine);\n\tconst struct nvkm_fifo_func_cgrp *cgrp = &fifo->func->cgrp;\n\tconst struct nvkm_fifo_func_chan *chan = &fifo->func->chan;\n\tint c = 0;\n\n\t \n\tif (cgrp->user.oclass) {\n\t\tif (c++ == index) {\n\t\t\toclass->base = cgrp->user;\n\t\t\toclass->engn = &fifo->func->cgrp.user;\n\t\t\t*class = &nvkm_fifo_class;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (chan->user.oclass) {\n\t\tif (c++ == index) {\n\t\t\toclass->base = chan->user;\n\t\t\toclass->engn = &fifo->func->chan.user;\n\t\t\t*class = &nvkm_fifo_class;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nstatic int\nnvkm_fifo_fini(struct nvkm_engine *engine, bool suspend)\n{\n\tstruct nvkm_fifo *fifo = nvkm_fifo(engine);\n\tstruct nvkm_runl *runl;\n\n\tnvkm_inth_block(&fifo->engine.subdev.inth);\n\n\tnvkm_runl_foreach(runl, fifo)\n\t\tnvkm_runl_fini(runl);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_fifo_init(struct nvkm_engine *engine)\n{\n\tstruct nvkm_fifo *fifo = nvkm_fifo(engine);\n\tstruct nvkm_runq *runq;\n\tstruct nvkm_runl *runl;\n\tu32 mask = 0;\n\n\tif (fifo->func->init_pbdmas) {\n\t\tnvkm_runq_foreach(runq, fifo)\n\t\t\tmask |= BIT(runq->id);\n\n\t\tfifo->func->init_pbdmas(fifo, mask);\n\n\t\tnvkm_runq_foreach(runq, fifo)\n\t\t\trunq->func->init(runq);\n\t}\n\n\tnvkm_runl_foreach(runl, fifo) {\n\t\tif (runl->func->init)\n\t\t\trunl->func->init(runl);\n\t}\n\n\tif (fifo->func->init)\n\t\tfifo->func->init(fifo);\n\n\tnvkm_inth_allow(&fifo->engine.subdev.inth);\n\treturn 0;\n}\n\nstatic int\nnvkm_fifo_info(struct nvkm_engine *engine, u64 mthd, u64 *data)\n{\n\tstruct nvkm_fifo *fifo = nvkm_fifo(engine);\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\tint ret;\n\n\tret = nvkm_subdev_oneinit(&fifo->engine.subdev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (mthd) {\n\tcase NV_DEVICE_HOST_CHANNELS: *data = fifo->chid ? fifo->chid->nr : 0; return 0;\n\tcase NV_DEVICE_HOST_RUNLISTS:\n\t\t*data = 0;\n\t\tnvkm_runl_foreach(runl, fifo)\n\t\t\t*data |= BIT(runl->id);\n\t\treturn 0;\n\tcase NV_DEVICE_HOST_RUNLIST_ENGINES:\n\t\trunl = nvkm_runl_get(fifo, *data, 0);\n\t\tif (runl) {\n\t\t\t*data = 0;\n\t\t\tnvkm_runl_foreach_engn(engn, runl) {\n#define CASE(n) case NVKM_ENGINE_##n: *data |= NV_DEVICE_HOST_RUNLIST_ENGINES_##n; break\n\t\t\t\tswitch (engn->engine->subdev.type) {\n\t\t\t\tcase NVKM_ENGINE_DMAOBJ:\n\t\t\t\t\tbreak;\n\t\t\t\tCASE(SW    );\n\t\t\t\tCASE(GR    );\n\t\t\t\tCASE(MPEG  );\n\t\t\t\tCASE(ME    );\n\t\t\t\tCASE(CIPHER);\n\t\t\t\tCASE(BSP   );\n\t\t\t\tCASE(VP    );\n\t\t\t\tCASE(CE    );\n\t\t\t\tCASE(SEC   );\n\t\t\t\tCASE(MSVLD );\n\t\t\t\tCASE(MSPDEC);\n\t\t\t\tCASE(MSPPP );\n\t\t\t\tCASE(MSENC );\n\t\t\t\tCASE(VIC   );\n\t\t\t\tCASE(SEC2  );\n\t\t\t\tCASE(NVDEC );\n\t\t\t\tCASE(NVENC );\n\t\t\t\tdefault:\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#undef CASE\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\tcase NV_DEVICE_HOST_RUNLIST_CHANNELS:\n\t\tif (!fifo->chid) {\n\t\t\trunl = nvkm_runl_get(fifo, *data, 0);\n\t\t\tif (runl) {\n\t\t\t\t*data = runl->chid->nr;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOSYS;\n}\n\nstatic int\nnvkm_fifo_oneinit(struct nvkm_engine *engine)\n{\n\tstruct nvkm_subdev *subdev = &engine->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_fifo *fifo = nvkm_fifo(engine);\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\tint ret, nr, i;\n\n\t \n\tif (fifo->func->chid_nr) {\n\t\tret = fifo->func->chid_ctor(fifo, fifo->func->chid_nr(fifo));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (fifo->func->runq_nr) {\n\t\tfor (nr = fifo->func->runq_nr(fifo), i = 0; i < nr; i++) {\n\t\t\tif (!nvkm_runq_new(fifo, i))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tret = fifo->func->runl_ctor(fifo);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_runl_foreach(runl, fifo) {\n\t\tRUNL_DEBUG(runl, \"chan:%06x\", runl->chan);\n\t\tnvkm_runl_foreach_engn(engn, runl) {\n\t\t\tENGN_DEBUG(engn, \"\");\n\t\t}\n\t}\n\n\t \n\tif (fifo->func->intr) {\n\t\tret = nvkm_inth_add(&device->mc->intr, NVKM_INTR_SUBDEV, NVKM_INTR_PRIO_NORMAL,\n\t\t\t\t    subdev, fifo->func->intr, &subdev->inth);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"intr %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (fifo->func->nonstall) {\n\t\tif (fifo->func->nonstall_ctor) {\n\t\t\tret = fifo->func->nonstall_ctor(fifo);\n\t\t\tif (ret < 0) {\n\t\t\t\tnvkm_error(subdev, \"nonstall %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = 1;\n\t\t}\n\n\t\tret = nvkm_event_init(fifo->func->nonstall, &fifo->engine.subdev, 1, ret,\n\t\t\t\t      &fifo->nonstall.event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (fifo->func->chan.func->userd->bar == 1) {\n\t\tstruct nvkm_vmm *bar1 = nvkm_bar_bar1_vmm(device);\n\n\t\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, fifo->chid->nr *\n\t\t\t\t      fifo->func->chan.func->userd->size, 0, true,\n\t\t\t\t      &fifo->userd.mem);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nvkm_vmm_get(bar1, 12, nvkm_memory_size(fifo->userd.mem), &fifo->userd.bar1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nvkm_memory_map(fifo->userd.mem, 0, bar1, fifo->userd.bar1, NULL, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnvkm_fifo_preinit(struct nvkm_engine *engine)\n{\n\tnvkm_mc_reset(engine->subdev.device, NVKM_ENGINE_FIFO, 0);\n}\n\nstatic void *\nnvkm_fifo_dtor(struct nvkm_engine *engine)\n{\n\tstruct nvkm_fifo *fifo = nvkm_fifo(engine);\n\tstruct nvkm_runl *runl, *runt;\n\tstruct nvkm_runq *runq, *rtmp;\n\n\tif (fifo->userd.bar1)\n\t\tnvkm_vmm_put(nvkm_bar_bar1_vmm(engine->subdev.device), &fifo->userd.bar1);\n\tnvkm_memory_unref(&fifo->userd.mem);\n\n\tlist_for_each_entry_safe(runl, runt, &fifo->runls, head)\n\t\tnvkm_runl_del(runl);\n\tlist_for_each_entry_safe(runq, rtmp, &fifo->runqs, head)\n\t\tnvkm_runq_del(runq);\n\n\tnvkm_chid_unref(&fifo->cgid);\n\tnvkm_chid_unref(&fifo->chid);\n\n\tnvkm_event_fini(&fifo->nonstall.event);\n\tmutex_destroy(&fifo->mutex);\n\treturn fifo;\n}\n\nstatic const struct nvkm_engine_func\nnvkm_fifo = {\n\t.dtor = nvkm_fifo_dtor,\n\t.preinit = nvkm_fifo_preinit,\n\t.oneinit = nvkm_fifo_oneinit,\n\t.info = nvkm_fifo_info,\n\t.init = nvkm_fifo_init,\n\t.fini = nvkm_fifo_fini,\n\t.base.sclass = nvkm_fifo_class_get,\n};\n\nint\nnvkm_fifo_new_(const struct nvkm_fifo_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_fifo **pfifo)\n{\n\tstruct nvkm_fifo *fifo;\n\n\tif (!(fifo = *pfifo = kzalloc(sizeof(*fifo), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tfifo->func = func;\n\tINIT_LIST_HEAD(&fifo->runqs);\n\tINIT_LIST_HEAD(&fifo->runls);\n\t \n\tfifo->timeout.chan_msec = 10000;\n\tspin_lock_init(&fifo->lock);\n\tmutex_init(&fifo->mutex);\n\n\treturn nvkm_engine_ctor(&nvkm_fifo, device, type, inst, true, &fifo->engine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}