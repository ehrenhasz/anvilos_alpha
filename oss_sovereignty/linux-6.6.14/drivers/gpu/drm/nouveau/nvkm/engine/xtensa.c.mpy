{
  "module_name": "xtensa.c",
  "hash_id": "b39c35a0efc7983cd30d53c85acaa2875e19268633f614991b2f1551b3dcc37f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/xtensa.c",
  "human_readable_source": " \n#include <engine/xtensa.h>\n\n#include <core/gpuobj.h>\n#include <engine/fifo.h>\n\nstatic int\nnvkm_xtensa_oclass_get(struct nvkm_oclass *oclass, int index)\n{\n\tstruct nvkm_xtensa *xtensa = nvkm_xtensa(oclass->engine);\n\tint c = 0;\n\n\twhile (xtensa->func->sclass[c].oclass) {\n\t\tif (c++ == index) {\n\t\t\toclass->base = xtensa->func->sclass[index];\n\t\t\treturn index;\n\t\t}\n\t}\n\n\treturn c;\n}\n\nstatic int\nnvkm_xtensa_cclass_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t\tint align, struct nvkm_gpuobj **pgpuobj)\n{\n\treturn nvkm_gpuobj_new(object->engine->subdev.device, 0x10000, align,\n\t\t\t       true, parent, pgpuobj);\n}\n\nstatic const struct nvkm_object_func\nnvkm_xtensa_cclass = {\n\t.bind = nvkm_xtensa_cclass_bind,\n};\n\nstatic void\nnvkm_xtensa_intr(struct nvkm_engine *engine)\n{\n\tstruct nvkm_xtensa *xtensa = nvkm_xtensa(engine);\n\tstruct nvkm_subdev *subdev = &xtensa->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst u32 base = xtensa->addr;\n\tu32 unk104 = nvkm_rd32(device, base + 0xd04);\n\tu32 intr = nvkm_rd32(device, base + 0xc20);\n\tu32 chan = nvkm_rd32(device, base + 0xc28);\n\tu32 unk10c = nvkm_rd32(device, base + 0xd0c);\n\n\tif (intr & 0x10)\n\t\tnvkm_warn(subdev, \"Watchdog interrupt, engine hung.\\n\");\n\tnvkm_wr32(device, base + 0xc20, intr);\n\tintr = nvkm_rd32(device, base + 0xc20);\n\tif (unk104 == 0x10001 && unk10c == 0x200 && chan && !intr) {\n\t\tnvkm_debug(subdev, \"Enabling FIFO_CTRL\\n\");\n\t\tnvkm_mask(device, xtensa->addr + 0xd94, 0, xtensa->func->fifo_val);\n\t}\n}\n\nstatic int\nnvkm_xtensa_fini(struct nvkm_engine *engine, bool suspend)\n{\n\tstruct nvkm_xtensa *xtensa = nvkm_xtensa(engine);\n\tstruct nvkm_device *device = xtensa->engine.subdev.device;\n\tconst u32 base = xtensa->addr;\n\n\tnvkm_wr32(device, base + 0xd84, 0);  \n\tnvkm_wr32(device, base + 0xd94, 0);  \n\n\tif (!suspend)\n\t\tnvkm_memory_unref(&xtensa->gpu_fw);\n\treturn 0;\n}\n\nstatic int\nnvkm_xtensa_init(struct nvkm_engine *engine)\n{\n\tstruct nvkm_xtensa *xtensa = nvkm_xtensa(engine);\n\tstruct nvkm_subdev *subdev = &xtensa->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst u32 base = xtensa->addr;\n\tconst struct firmware *fw;\n\tchar name[32];\n\tint i, ret;\n\tu64 addr, size;\n\tu32 tmp;\n\n\tif (!xtensa->gpu_fw) {\n\t\tsnprintf(name, sizeof(name), \"nouveau/nv84_xuc%03x\",\n\t\t\t xtensa->addr >> 12);\n\n\t\tret = request_firmware(&fw, name, device->dev);\n\t\tif (ret) {\n\t\t\tnvkm_warn(subdev, \"unable to load firmware %s\\n\", name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (fw->size > 0x40000) {\n\t\t\tnvkm_warn(subdev, \"firmware %s too large\\n\", name);\n\t\t\trelease_firmware(fw);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST,\n\t\t\t\t      0x40000, 0x1000, false,\n\t\t\t\t      &xtensa->gpu_fw);\n\t\tif (ret) {\n\t\t\trelease_firmware(fw);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnvkm_kmap(xtensa->gpu_fw);\n\t\tfor (i = 0; i < fw->size / 4; i++)\n\t\t\tnvkm_wo32(xtensa->gpu_fw, i * 4, *((u32 *)fw->data + i));\n\t\tnvkm_done(xtensa->gpu_fw);\n\t\trelease_firmware(fw);\n\t}\n\n\taddr = nvkm_memory_addr(xtensa->gpu_fw);\n\tsize = nvkm_memory_size(xtensa->gpu_fw);\n\n\tnvkm_wr32(device, base + 0xd10, 0x1fffffff);  \n\tnvkm_wr32(device, base + 0xd08, 0x0fffffff);  \n\n\tnvkm_wr32(device, base + 0xd28, xtensa->func->unkd28);  \n\tnvkm_wr32(device, base + 0xc20, 0x3f);  \n\tnvkm_wr32(device, base + 0xd84, 0x3f);  \n\n\tnvkm_wr32(device, base + 0xcc0, addr >> 8);  \n\tnvkm_wr32(device, base + 0xcc4, 0x1c);  \n\tnvkm_wr32(device, base + 0xcc8, size >> 8);  \n\n\ttmp = nvkm_rd32(device, 0x0);\n\tnvkm_wr32(device, base + 0xde0, tmp);  \n\n\tnvkm_wr32(device, base + 0xce8, 0xf);  \n\n\tnvkm_wr32(device, base + 0xc20, 0x3f);  \n\tnvkm_wr32(device, base + 0xd84, 0x3f);  \n\treturn 0;\n}\n\nstatic void *\nnvkm_xtensa_dtor(struct nvkm_engine *engine)\n{\n\treturn nvkm_xtensa(engine);\n}\n\nstatic const struct nvkm_engine_func\nnvkm_xtensa = {\n\t.dtor = nvkm_xtensa_dtor,\n\t.init = nvkm_xtensa_init,\n\t.fini = nvkm_xtensa_fini,\n\t.intr = nvkm_xtensa_intr,\n\t.fifo.sclass = nvkm_xtensa_oclass_get,\n\t.cclass = &nvkm_xtensa_cclass,\n};\n\nint\nnvkm_xtensa_new_(const struct nvkm_xtensa_func *func, struct nvkm_device *device,\n\t\t enum nvkm_subdev_type type, int inst, bool enable, u32 addr,\n\t\t struct nvkm_engine **pengine)\n{\n\tstruct nvkm_xtensa *xtensa;\n\n\tif (!(xtensa = kzalloc(sizeof(*xtensa), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\txtensa->func = func;\n\txtensa->addr = addr;\n\t*pengine = &xtensa->engine;\n\n\treturn nvkm_engine_ctor(&nvkm_xtensa, device, type, inst, enable, &xtensa->engine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}