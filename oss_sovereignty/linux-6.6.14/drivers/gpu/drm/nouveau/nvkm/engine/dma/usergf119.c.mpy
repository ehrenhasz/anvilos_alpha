{
  "module_name": "usergf119.c",
  "hash_id": "17cdf29a955fa890c34acf9c032f17be277a15594ea6732de7c7cf74c3dd1b5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/dma/usergf119.c",
  "human_readable_source": " \n#define gf119_dmaobj(p) container_of((p), struct gf119_dmaobj, base)\n#include \"user.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n\n#include <nvif/cl0002.h>\n#include <nvif/unpack.h>\n\nstruct gf119_dmaobj {\n\tstruct nvkm_dmaobj base;\n\tu32 flags0;\n};\n\nstatic int\ngf119_dmaobj_bind(struct nvkm_dmaobj *base, struct nvkm_gpuobj *parent,\n\t\t  int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct gf119_dmaobj *dmaobj = gf119_dmaobj(base);\n\tstruct nvkm_device *device = dmaobj->base.dma->engine.subdev.device;\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 24, align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, dmaobj->flags0);\n\t\tnvkm_wo32(*pgpuobj, 0x04, dmaobj->base.start >> 8);\n\t\tnvkm_wo32(*pgpuobj, 0x08, dmaobj->base.limit >> 8);\n\t\tnvkm_wo32(*pgpuobj, 0x0c, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x10, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x14, 0x00000000);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nvkm_dmaobj_func\ngf119_dmaobj_func = {\n\t.bind = gf119_dmaobj_bind,\n};\n\nint\ngf119_dmaobj_new(struct nvkm_dma *dma, const struct nvkm_oclass *oclass,\n\t\t void *data, u32 size, struct nvkm_dmaobj **pdmaobj)\n{\n\tunion {\n\t\tstruct gf119_dma_v0 v0;\n\t} *args;\n\tstruct nvkm_object *parent = oclass->parent;\n\tstruct gf119_dmaobj *dmaobj;\n\tu32 kind, page;\n\tint ret;\n\n\tif (!(dmaobj = kzalloc(sizeof(*dmaobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pdmaobj = &dmaobj->base;\n\n\tret = nvkm_dmaobj_ctor(&gf119_dmaobj_func, dma, oclass,\n\t\t\t       &data, &size, &dmaobj->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret  = -ENOSYS;\n\targs = data;\n\n\tnvif_ioctl(parent, \"create gf119 dma size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(parent,\n\t\t\t   \"create gf100 dma vers %d page %d kind %02x\\n\",\n\t\t\t   args->v0.version, args->v0.page, args->v0.kind);\n\t\tkind = args->v0.kind;\n\t\tpage = args->v0.page;\n\t} else\n\tif (size == 0) {\n\t\tif (dmaobj->base.target != NV_MEM_TARGET_VM) {\n\t\t\tkind = GF119_DMA_V0_KIND_PITCH;\n\t\t\tpage = GF119_DMA_V0_PAGE_SP;\n\t\t} else {\n\t\t\tkind = GF119_DMA_V0_KIND_VM;\n\t\t\tpage = GF119_DMA_V0_PAGE_LP;\n\t\t}\n\t} else\n\t\treturn ret;\n\n\tif (page > 1)\n\t\treturn -EINVAL;\n\tdmaobj->flags0 = (kind << 20) | (page << 6);\n\n\tswitch (dmaobj->base.target) {\n\tcase NV_MEM_TARGET_VRAM:\n\t\tdmaobj->flags0 |= 0x00000009;\n\t\tbreak;\n\tcase NV_MEM_TARGET_VM:\n\tcase NV_MEM_TARGET_PCI:\n\tcase NV_MEM_TARGET_PCI_NOSNOOP:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}