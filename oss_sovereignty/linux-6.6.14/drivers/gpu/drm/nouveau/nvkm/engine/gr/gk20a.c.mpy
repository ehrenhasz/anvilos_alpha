{
  "module_name": "gk20a.c",
  "hash_id": "67546f3f50fa38fb18d7af68e8da09a12e4a93f82391b24553fc3f724b45f3a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/gk20a.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ctxgf100.h\"\n\n#include <core/firmware.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstruct gk20a_fw_av\n{\n\tu32 addr;\n\tu32 data;\n};\n\nint\ngk20a_gr_av_to_init_(struct nvkm_blob *blob, u8 count, u32 pitch, struct gf100_gr_pack **ppack)\n{\n\tstruct gf100_gr_init *init;\n\tstruct gf100_gr_pack *pack;\n\tint nent;\n\tint i;\n\n\tnent = (blob->size / sizeof(struct gk20a_fw_av));\n\tpack = vzalloc((sizeof(*pack) * 2) + (sizeof(*init) * (nent + 1)));\n\tif (!pack)\n\t\treturn -ENOMEM;\n\n\tinit = (void *)(pack + 2);\n\tpack[0].init = init;\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct gf100_gr_init *ent = &init[i];\n\t\tstruct gk20a_fw_av *av = &((struct gk20a_fw_av *)blob->data)[i];\n\n\t\tent->addr = av->addr;\n\t\tent->data = av->data;\n\t\tent->count = ((ent->addr & 0xffff) != 0xe100) ? count : 1;\n\t\tent->pitch = pitch;\n\t}\n\n\t*ppack = pack;\n\treturn 0;\n}\n\nint\ngk20a_gr_av_to_init(struct nvkm_blob *blob, struct gf100_gr_pack **ppack)\n{\n\treturn gk20a_gr_av_to_init_(blob, 1, 1, ppack);\n}\n\nstruct gk20a_fw_aiv\n{\n\tu32 addr;\n\tu32 index;\n\tu32 data;\n};\n\nint\ngk20a_gr_aiv_to_init(struct nvkm_blob *blob, struct gf100_gr_pack **ppack)\n{\n\tstruct gf100_gr_init *init;\n\tstruct gf100_gr_pack *pack;\n\tint nent;\n\tint i;\n\n\tnent = (blob->size / sizeof(struct gk20a_fw_aiv));\n\tpack = vzalloc((sizeof(*pack) * 2) + (sizeof(*init) * (nent + 1)));\n\tif (!pack)\n\t\treturn -ENOMEM;\n\n\tinit = (void *)(pack + 2);\n\tpack[0].init = init;\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct gf100_gr_init *ent = &init[i];\n\t\tstruct gk20a_fw_aiv *av = &((struct gk20a_fw_aiv *)blob->data)[i];\n\n\t\tent->addr = av->addr;\n\t\tent->data = av->data;\n\t\tent->count = 1;\n\t\tent->pitch = 1;\n\t}\n\n\t*ppack = pack;\n\treturn 0;\n}\n\nint\ngk20a_gr_av_to_method(struct nvkm_blob *blob, struct gf100_gr_pack **ppack)\n{\n\tstruct gf100_gr_init *init;\n\tstruct gf100_gr_pack *pack;\n\t \n\tstatic const unsigned int max_classes = 16;\n\tu32 classidx = 0, prevclass = 0;\n\tint nent;\n\tint i;\n\n\tnent = (blob->size / sizeof(struct gk20a_fw_av));\n\tpack = vzalloc((sizeof(*pack) * (max_classes + 1)) +\n\t\t       (sizeof(*init) * (nent + max_classes + 1)));\n\tif (!pack)\n\t\treturn -ENOMEM;\n\n\tinit = (void *)(pack + max_classes + 1);\n\n\tfor (i = 0; i < nent; i++, init++) {\n\t\tstruct gk20a_fw_av *av = &((struct gk20a_fw_av *)blob->data)[i];\n\t\tu32 class = av->addr & 0xffff;\n\t\tu32 addr = (av->addr & 0xffff0000) >> 14;\n\n\t\tif (prevclass != class) {\n\t\t\tif (prevclass)  \n\t\t\t\tinit++;\n\t\t\tpack[classidx].init = init;\n\t\t\tpack[classidx].type = class;\n\t\t\tprevclass = class;\n\t\t\tif (++classidx >= max_classes) {\n\t\t\t\tvfree(pack);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t}\n\n\t\tinit->addr = addr;\n\t\tinit->data = av->data;\n\t\tinit->count = 1;\n\t\tinit->pitch = 1;\n\t}\n\n\t*ppack = pack;\n\treturn 0;\n}\n\nstatic int\ngk20a_gr_wait_mem_scrubbing(struct gf100_gr *gr)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x40910c) & 0x00000006))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"FECS mem scrubbing timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x41a10c) & 0x00000006))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"GPCCS mem scrubbing timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void\ngk20a_gr_set_hww_esr_report_mask(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, 0x419e44, 0x1ffffe);\n\tnvkm_wr32(device, 0x419e4c, 0x7f);\n}\n\nint\ngk20a_gr_init(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint ret;\n\n\t \n\tnvkm_wr32(device, 0x40802c, 0x1);\n\n\tgf100_gr_mmio(gr, gr->sw_nonctx);\n\n\tret = gk20a_gr_wait_mem_scrubbing(gr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gf100_gr_wait_idle(gr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (gr->func->init_gpc_mmu)\n\t\tgr->func->init_gpc_mmu(gr);\n\n\t \n\tnvkm_mask(device, 0x503018, 0x1, 0x1);\n\n\t \n\tgr->func->init_zcull(gr);\n\n\tgr->func->init_rop_active_fbps(gr);\n\n\t \n\tnvkm_wr32(device, 0x400500, 0x00010001);\n\n\t \n\tnvkm_wr32(device, 0x400100, 0xffffffff);\n\tnvkm_wr32(device, 0x40013c, 0xffffffff);\n\n\t \n\tnvkm_wr32(device, 0x409c24, 0x000f0000);\n\n\t \n\tnvkm_wr32(device, 0x404000, 0xc0000000);\n\tnvkm_wr32(device, 0x404600, 0xc0000000);\n\n\tif (gr->func->set_hww_esr_report_mask)\n\t\tgr->func->set_hww_esr_report_mask(gr);\n\n\t \n\tnvkm_wr32(device, 0x419d0c, 0x2);\n\tnvkm_wr32(device, 0x41ac94, (((1 << gr->tpc_total) - 1) & 0xff) << 16);\n\n\t \n\tnvkm_wr32(device, 0x400108, 0xffffffff);\n\tnvkm_wr32(device, 0x400138, 0xffffffff);\n\tnvkm_wr32(device, 0x400118, 0xffffffff);\n\tnvkm_wr32(device, 0x400130, 0xffffffff);\n\tnvkm_wr32(device, 0x40011c, 0xffffffff);\n\tnvkm_wr32(device, 0x400134, 0xffffffff);\n\n\tgf100_gr_zbc_init(gr);\n\n\treturn gf100_gr_init_ctxctl(gr);\n}\n\nstatic const struct gf100_gr_func\ngk20a_gr = {\n\t.oneinit_tiles = gf100_gr_oneinit_tiles,\n\t.oneinit_sm_id = gf100_gr_oneinit_sm_id,\n\t.init = gk20a_gr_init,\n\t.init_zcull = gf117_gr_init_zcull,\n\t.init_rop_active_fbps = gk104_gr_init_rop_active_fbps,\n\t.trap_mp = gf100_gr_trap_mp,\n\t.set_hww_esr_report_mask = gk20a_gr_set_hww_esr_report_mask,\n\t.fecs.reset = gf100_gr_fecs_reset,\n\t.rops = gf100_gr_rops,\n\t.ppc_nr = 1,\n\t.grctx = &gk20a_grctx,\n\t.zbc = &gf100_gr_zbc,\n\t.sclass = {\n\t\t{ -1, -1, FERMI_TWOD_A },\n\t\t{ -1, -1, KEPLER_INLINE_TO_MEMORY_A },\n\t\t{ -1, -1, KEPLER_C, &gf100_fermi },\n\t\t{ -1, -1, KEPLER_COMPUTE_A },\n\t\t{}\n\t}\n};\n\nint\ngk20a_gr_load_net(struct gf100_gr *gr, const char *path, const char *name, int ver,\n\t\t  int (*load)(struct nvkm_blob *, struct gf100_gr_pack **),\n\t\t  struct gf100_gr_pack **ppack)\n{\n\tstruct nvkm_blob blob;\n\tint ret;\n\n\tret = nvkm_firmware_load_blob(&gr->base.engine.subdev, path, name, ver, &blob);\n\tif (ret)\n\t\treturn ret;\n\n\tret = load(&blob, ppack);\n\tnvkm_blob_dtor(&blob);\n\treturn 0;\n}\n\nint\ngk20a_gr_load_sw(struct gf100_gr *gr, const char *path, int ver)\n{\n\tif (gk20a_gr_load_net(gr, path, \"sw_nonctx\", ver, gk20a_gr_av_to_init, &gr->sw_nonctx) ||\n\t    gk20a_gr_load_net(gr, path, \"sw_ctx\", ver, gk20a_gr_aiv_to_init, &gr->sw_ctx) ||\n\t    gk20a_gr_load_net(gr, path, \"sw_bundle_init\", ver, gk20a_gr_av_to_init, &gr->bundle) ||\n\t    gk20a_gr_load_net(gr, path, \"sw_method_init\", ver, gk20a_gr_av_to_method, &gr->method))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_124_SOC) || IS_ENABLED(CONFIG_ARCH_TEGRA_132_SOC)\nMODULE_FIRMWARE(\"nvidia/gk20a/fecs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/fecs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/gpccs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/gpccs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/sw_bundle_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/sw_ctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/sw_method_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gk20a/sw_nonctx.bin\");\n#endif\n\nstatic int\ngk20a_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\n\tif (nvkm_firmware_load_blob(subdev, \"\", \"fecs_inst\", ver,\n\t\t\t\t    &gr->fecs.inst) ||\n\t    nvkm_firmware_load_blob(subdev, \"\", \"fecs_data\", ver,\n\t\t\t\t    &gr->fecs.data) ||\n\t    nvkm_firmware_load_blob(subdev, \"\", \"gpccs_inst\", ver,\n\t\t\t\t    &gr->gpccs.inst) ||\n\t    nvkm_firmware_load_blob(subdev, \"\", \"gpccs_data\", ver,\n\t\t\t\t    &gr->gpccs.data))\n\t\treturn -ENOENT;\n\n\tgr->firmware = true;\n\n\treturn gk20a_gr_load_sw(gr, \"\", ver);\n}\n\nstatic const struct gf100_gr_fwif\ngk20a_gr_fwif[] = {\n\t{ 0, gk20a_gr_load, &gk20a_gr },\n\t{}\n};\n\nint\ngk20a_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn gf100_gr_new_(gk20a_gr_fwif, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}