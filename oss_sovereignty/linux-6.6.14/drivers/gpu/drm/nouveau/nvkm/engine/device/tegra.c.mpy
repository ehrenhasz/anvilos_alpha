{
  "module_name": "tegra.c",
  "hash_id": "1ecd3b61249a4e5a848310ab2559880e78e0961480f462ecfb95e2c15ffb0ad9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/device/tegra.c",
  "human_readable_source": " \n#include <core/tegra.h>\n#ifdef CONFIG_NOUVEAU_PLATFORM_DRIVER\n#include \"priv.h\"\n\n#if IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)\n#include <asm/dma-iommu.h>\n#endif\n\nstatic int\nnvkm_device_tegra_power_up(struct nvkm_device_tegra *tdev)\n{\n\tint ret;\n\n\tif (tdev->vdd) {\n\t\tret = regulator_enable(tdev->vdd);\n\t\tif (ret)\n\t\t\tgoto err_power;\n\t}\n\n\tret = clk_prepare_enable(tdev->clk);\n\tif (ret)\n\t\tgoto err_clk;\n\tret = clk_prepare_enable(tdev->clk_ref);\n\tif (ret)\n\t\tgoto err_clk_ref;\n\tret = clk_prepare_enable(tdev->clk_pwr);\n\tif (ret)\n\t\tgoto err_clk_pwr;\n\tclk_set_rate(tdev->clk_pwr, 204000000);\n\tudelay(10);\n\n\tif (!tdev->pdev->dev.pm_domain) {\n\t\treset_control_assert(tdev->rst);\n\t\tudelay(10);\n\n\t\tret = tegra_powergate_remove_clamping(TEGRA_POWERGATE_3D);\n\t\tif (ret)\n\t\t\tgoto err_clamp;\n\t\tudelay(10);\n\n\t\treset_control_deassert(tdev->rst);\n\t\tudelay(10);\n\t}\n\n\treturn 0;\n\nerr_clamp:\n\tclk_disable_unprepare(tdev->clk_pwr);\nerr_clk_pwr:\n\tclk_disable_unprepare(tdev->clk_ref);\nerr_clk_ref:\n\tclk_disable_unprepare(tdev->clk);\nerr_clk:\n\tif (tdev->vdd)\n\t\tregulator_disable(tdev->vdd);\nerr_power:\n\treturn ret;\n}\n\nstatic int\nnvkm_device_tegra_power_down(struct nvkm_device_tegra *tdev)\n{\n\tint ret;\n\n\tclk_disable_unprepare(tdev->clk_pwr);\n\tclk_disable_unprepare(tdev->clk_ref);\n\tclk_disable_unprepare(tdev->clk);\n\tudelay(10);\n\n\tif (tdev->vdd) {\n\t\tret = regulator_disable(tdev->vdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnvkm_device_tegra_probe_iommu(struct nvkm_device_tegra *tdev)\n{\n#if IS_ENABLED(CONFIG_IOMMU_API)\n\tstruct device *dev = &tdev->pdev->dev;\n\tunsigned long pgsize_bitmap;\n\tint ret;\n\n#if IS_ENABLED(CONFIG_ARM_DMA_USE_IOMMU)\n\tif (dev->archdata.mapping) {\n\t\tstruct dma_iommu_mapping *mapping = to_dma_iommu_mapping(dev);\n\n\t\tarm_iommu_detach_device(dev);\n\t\tarm_iommu_release_mapping(mapping);\n\t}\n#endif\n\n\tif (!tdev->func->iommu_bit)\n\t\treturn;\n\n\tmutex_init(&tdev->iommu.mutex);\n\n\tif (device_iommu_mapped(dev)) {\n\t\ttdev->iommu.domain = iommu_domain_alloc(&platform_bus_type);\n\t\tif (!tdev->iommu.domain)\n\t\t\tgoto error;\n\n\t\t \n\t\tpgsize_bitmap = tdev->iommu.domain->pgsize_bitmap;\n\t\tif (pgsize_bitmap & PAGE_SIZE) {\n\t\t\ttdev->iommu.pgshift = PAGE_SHIFT;\n\t\t} else {\n\t\t\ttdev->iommu.pgshift = fls(pgsize_bitmap & ~PAGE_MASK);\n\t\t\tif (tdev->iommu.pgshift == 0) {\n\t\t\t\tdev_warn(dev, \"unsupported IOMMU page size\\n\");\n\t\t\t\tgoto free_domain;\n\t\t\t}\n\t\t\ttdev->iommu.pgshift -= 1;\n\t\t}\n\n\t\tret = iommu_attach_device(tdev->iommu.domain, dev);\n\t\tif (ret)\n\t\t\tgoto free_domain;\n\n\t\tret = nvkm_mm_init(&tdev->iommu.mm, 0, 0,\n\t\t\t\t   (1ULL << tdev->func->iommu_bit) >>\n\t\t\t\t   tdev->iommu.pgshift, 1);\n\t\tif (ret)\n\t\t\tgoto detach_device;\n\t}\n\n\treturn;\n\ndetach_device:\n\tiommu_detach_device(tdev->iommu.domain, dev);\n\nfree_domain:\n\tiommu_domain_free(tdev->iommu.domain);\n\nerror:\n\ttdev->iommu.domain = NULL;\n\ttdev->iommu.pgshift = 0;\n\tdev_err(dev, \"cannot initialize IOMMU MM\\n\");\n#endif\n}\n\nstatic void\nnvkm_device_tegra_remove_iommu(struct nvkm_device_tegra *tdev)\n{\n#if IS_ENABLED(CONFIG_IOMMU_API)\n\tif (tdev->iommu.domain) {\n\t\tnvkm_mm_fini(&tdev->iommu.mm);\n\t\tiommu_detach_device(tdev->iommu.domain, tdev->device.dev);\n\t\tiommu_domain_free(tdev->iommu.domain);\n\t}\n#endif\n}\n\nstatic struct nvkm_device_tegra *\nnvkm_device_tegra(struct nvkm_device *device)\n{\n\treturn container_of(device, struct nvkm_device_tegra, device);\n}\n\nstatic struct resource *\nnvkm_device_tegra_resource(struct nvkm_device *device, unsigned bar)\n{\n\tstruct nvkm_device_tegra *tdev = nvkm_device_tegra(device);\n\treturn platform_get_resource(tdev->pdev, IORESOURCE_MEM, bar);\n}\n\nstatic resource_size_t\nnvkm_device_tegra_resource_addr(struct nvkm_device *device, unsigned bar)\n{\n\tstruct resource *res = nvkm_device_tegra_resource(device, bar);\n\treturn res ? res->start : 0;\n}\n\nstatic resource_size_t\nnvkm_device_tegra_resource_size(struct nvkm_device *device, unsigned bar)\n{\n\tstruct resource *res = nvkm_device_tegra_resource(device, bar);\n\treturn res ? resource_size(res) : 0;\n}\n\nstatic int\nnvkm_device_tegra_irq(struct nvkm_device *device)\n{\n\tstruct nvkm_device_tegra *tdev = nvkm_device_tegra(device);\n\n\treturn platform_get_irq_byname(tdev->pdev, \"stall\");\n}\n\nstatic void *\nnvkm_device_tegra_dtor(struct nvkm_device *device)\n{\n\tstruct nvkm_device_tegra *tdev = nvkm_device_tegra(device);\n\tnvkm_device_tegra_power_down(tdev);\n\tnvkm_device_tegra_remove_iommu(tdev);\n\treturn tdev;\n}\n\nstatic const struct nvkm_device_func\nnvkm_device_tegra_func = {\n\t.tegra = nvkm_device_tegra,\n\t.dtor = nvkm_device_tegra_dtor,\n\t.irq = nvkm_device_tegra_irq,\n\t.resource_addr = nvkm_device_tegra_resource_addr,\n\t.resource_size = nvkm_device_tegra_resource_size,\n\t.cpu_coherent = false,\n};\n\nint\nnvkm_device_tegra_new(const struct nvkm_device_tegra_func *func,\n\t\t      struct platform_device *pdev,\n\t\t      const char *cfg, const char *dbg,\n\t\t      bool detect, bool mmio, u64 subdev_mask,\n\t\t      struct nvkm_device **pdevice)\n{\n\tstruct nvkm_device_tegra *tdev;\n\tunsigned long rate;\n\tint ret;\n\n\tif (!(tdev = kzalloc(sizeof(*tdev), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\ttdev->func = func;\n\ttdev->pdev = pdev;\n\n\tif (func->require_vdd) {\n\t\ttdev->vdd = devm_regulator_get(&pdev->dev, \"vdd\");\n\t\tif (IS_ERR(tdev->vdd)) {\n\t\t\tret = PTR_ERR(tdev->vdd);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\ttdev->rst = devm_reset_control_get(&pdev->dev, \"gpu\");\n\tif (IS_ERR(tdev->rst)) {\n\t\tret = PTR_ERR(tdev->rst);\n\t\tgoto free;\n\t}\n\n\ttdev->clk = devm_clk_get(&pdev->dev, \"gpu\");\n\tif (IS_ERR(tdev->clk)) {\n\t\tret = PTR_ERR(tdev->clk);\n\t\tgoto free;\n\t}\n\n\trate = clk_get_rate(tdev->clk);\n\tif (rate == 0) {\n\t\tret = clk_set_rate(tdev->clk, ULONG_MAX);\n\t\tif (ret < 0)\n\t\t\tgoto free;\n\n\t\trate = clk_get_rate(tdev->clk);\n\n\t\tdev_dbg(&pdev->dev, \"GPU clock set to %lu\\n\", rate);\n\t}\n\n\tif (func->require_ref_clk)\n\t\ttdev->clk_ref = devm_clk_get(&pdev->dev, \"ref\");\n\tif (IS_ERR(tdev->clk_ref)) {\n\t\tret = PTR_ERR(tdev->clk_ref);\n\t\tgoto free;\n\t}\n\n\ttdev->clk_pwr = devm_clk_get(&pdev->dev, \"pwr\");\n\tif (IS_ERR(tdev->clk_pwr)) {\n\t\tret = PTR_ERR(tdev->clk_pwr);\n\t\tgoto free;\n\t}\n\n\t \n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(tdev->func->iommu_bit));\n\tif (ret)\n\t\tgoto free;\n\n\tnvkm_device_tegra_probe_iommu(tdev);\n\n\tret = nvkm_device_tegra_power_up(tdev);\n\tif (ret)\n\t\tgoto remove;\n\n\ttdev->gpu_speedo = tegra_sku_info.gpu_speedo_value;\n\ttdev->gpu_speedo_id = tegra_sku_info.gpu_speedo_id;\n\tret = nvkm_device_ctor(&nvkm_device_tegra_func, NULL, &pdev->dev,\n\t\t\t       NVKM_DEVICE_TEGRA, pdev->id, NULL,\n\t\t\t       cfg, dbg, detect, mmio, subdev_mask,\n\t\t\t       &tdev->device);\n\tif (ret)\n\t\tgoto powerdown;\n\n\t*pdevice = &tdev->device;\n\n\treturn 0;\n\npowerdown:\n\tnvkm_device_tegra_power_down(tdev);\nremove:\n\tnvkm_device_tegra_remove_iommu(tdev);\nfree:\n\tkfree(tdev);\n\treturn ret;\n}\n#else\nint\nnvkm_device_tegra_new(const struct nvkm_device_tegra_func *func,\n\t\t      struct platform_device *pdev,\n\t\t      const char *cfg, const char *dbg,\n\t\t      bool detect, bool mmio, u64 subdev_mask,\n\t\t      struct nvkm_device **pdevice)\n{\n\treturn -ENOSYS;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}