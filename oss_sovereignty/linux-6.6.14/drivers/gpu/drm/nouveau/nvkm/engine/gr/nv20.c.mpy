{
  "module_name": "nv20.c",
  "hash_id": "305b687f479e541fbb210b3e284b112c02e704ff80e753a76b33dc2b7c6ba99f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv20.c",
  "human_readable_source": "\n#include \"nv20.h\"\n#include \"regs.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <engine/fifo.h>\n#include <engine/fifo/chan.h>\n#include <subdev/fb.h>\n#include <subdev/timer.h>\n\n \n\nint\nnv20_gr_chan_init(struct nvkm_object *object)\n{\n\tstruct nv20_gr_chan *chan = nv20_gr_chan(object);\n\tstruct nv20_gr *gr = chan->gr;\n\tu32 inst = nvkm_memory_addr(chan->inst);\n\n\tnvkm_kmap(gr->ctxtab);\n\tnvkm_wo32(gr->ctxtab, chan->chid * 4, inst >> 4);\n\tnvkm_done(gr->ctxtab);\n\treturn 0;\n}\n\nint\nnv20_gr_chan_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nv20_gr_chan *chan = nv20_gr_chan(object);\n\tstruct nv20_gr *gr = chan->gr;\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 inst = nvkm_memory_addr(chan->inst);\n\tint chid = -1;\n\n\tnvkm_mask(device, 0x400720, 0x00000001, 0x00000000);\n\tif (nvkm_rd32(device, 0x400144) & 0x00010000)\n\t\tchid = (nvkm_rd32(device, 0x400148) & 0x1f000000) >> 24;\n\tif (chan->chid == chid) {\n\t\tnvkm_wr32(device, 0x400784, inst >> 4);\n\t\tnvkm_wr32(device, 0x400788, 0x00000002);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!nvkm_rd32(device, 0x400700))\n\t\t\t\tbreak;\n\t\t);\n\t\tnvkm_wr32(device, 0x400144, 0x10000000);\n\t\tnvkm_mask(device, 0x400148, 0xff000000, 0x1f000000);\n\t}\n\tnvkm_mask(device, 0x400720, 0x00000001, 0x00000001);\n\n\tnvkm_kmap(gr->ctxtab);\n\tnvkm_wo32(gr->ctxtab, chan->chid * 4, 0x00000000);\n\tnvkm_done(gr->ctxtab);\n\treturn 0;\n}\n\nvoid *\nnv20_gr_chan_dtor(struct nvkm_object *object)\n{\n\tstruct nv20_gr_chan *chan = nv20_gr_chan(object);\n\tnvkm_memory_unref(&chan->inst);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\nnv20_gr_chan = {\n\t.dtor = nv20_gr_chan_dtor,\n\t.init = nv20_gr_chan_init,\n\t.fini = nv20_gr_chan_fini,\n};\n\nstatic int\nnv20_gr_chan_new(struct nvkm_gr *base, struct nvkm_chan *fifoch,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object **pobject)\n{\n\tstruct nv20_gr *gr = nv20_gr(base);\n\tstruct nv20_gr_chan *chan;\n\tint ret, i;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nv20_gr_chan, oclass, &chan->object);\n\tchan->gr = gr;\n\tchan->chid = fifoch->id;\n\t*pobject = &chan->object;\n\n\tret = nvkm_memory_new(gr->base.engine.subdev.device,\n\t\t\t      NVKM_MEM_TARGET_INST, 0x37f0, 16, true,\n\t\t\t      &chan->inst);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x0000, 0x00000001 | (chan->chid << 24));\n\tnvkm_wo32(chan->inst, 0x033c, 0xffff0000);\n\tnvkm_wo32(chan->inst, 0x03a0, 0x0fff0000);\n\tnvkm_wo32(chan->inst, 0x03a4, 0x0fff0000);\n\tnvkm_wo32(chan->inst, 0x047c, 0x00000101);\n\tnvkm_wo32(chan->inst, 0x0490, 0x00000111);\n\tnvkm_wo32(chan->inst, 0x04a8, 0x44400000);\n\tfor (i = 0x04d4; i <= 0x04e0; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x00030303);\n\tfor (i = 0x04f4; i <= 0x0500; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x00080000);\n\tfor (i = 0x050c; i <= 0x0518; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x01012000);\n\tfor (i = 0x051c; i <= 0x0528; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x000105b8);\n\tfor (i = 0x052c; i <= 0x0538; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x00080008);\n\tfor (i = 0x055c; i <= 0x0598; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x07ff0000);\n\tnvkm_wo32(chan->inst, 0x05a4, 0x4b7fffff);\n\tnvkm_wo32(chan->inst, 0x05fc, 0x00000001);\n\tnvkm_wo32(chan->inst, 0x0604, 0x00004000);\n\tnvkm_wo32(chan->inst, 0x0610, 0x00000001);\n\tnvkm_wo32(chan->inst, 0x0618, 0x00040000);\n\tnvkm_wo32(chan->inst, 0x061c, 0x00010000);\n\tfor (i = 0x1c1c; i <= 0x248c; i += 16) {\n\t\tnvkm_wo32(chan->inst, (i + 0), 0x10700ff9);\n\t\tnvkm_wo32(chan->inst, (i + 4), 0x0436086c);\n\t\tnvkm_wo32(chan->inst, (i + 8), 0x000c001b);\n\t}\n\tnvkm_wo32(chan->inst, 0x281c, 0x3f800000);\n\tnvkm_wo32(chan->inst, 0x2830, 0x3f800000);\n\tnvkm_wo32(chan->inst, 0x285c, 0x40000000);\n\tnvkm_wo32(chan->inst, 0x2860, 0x3f800000);\n\tnvkm_wo32(chan->inst, 0x2864, 0x3f000000);\n\tnvkm_wo32(chan->inst, 0x286c, 0x40000000);\n\tnvkm_wo32(chan->inst, 0x2870, 0x3f800000);\n\tnvkm_wo32(chan->inst, 0x2878, 0xbf800000);\n\tnvkm_wo32(chan->inst, 0x2880, 0xbf800000);\n\tnvkm_wo32(chan->inst, 0x34a4, 0x000fe000);\n\tnvkm_wo32(chan->inst, 0x3530, 0x000003f8);\n\tnvkm_wo32(chan->inst, 0x3540, 0x002fe000);\n\tfor (i = 0x355c; i <= 0x3578; i += 4)\n\t\tnvkm_wo32(chan->inst, i, 0x001c527c);\n\tnvkm_done(chan->inst);\n\treturn 0;\n}\n\n \n\nvoid\nnv20_gr_tile(struct nvkm_gr *base, int i, struct nvkm_fb_tile *tile)\n{\n\tstruct nv20_gr *gr = nv20_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tstruct nvkm_fifo *fifo = device->fifo;\n\tunsigned long flags;\n\n\tnvkm_fifo_pause(fifo, &flags);\n\tnv04_gr_idle(&gr->base);\n\n\tnvkm_wr32(device, NV20_PGRAPH_TLIMIT(i), tile->limit);\n\tnvkm_wr32(device, NV20_PGRAPH_TSIZE(i), tile->pitch);\n\tnvkm_wr32(device, NV20_PGRAPH_TILE(i), tile->addr);\n\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00EA0030 + 4 * i);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, tile->limit);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00EA0050 + 4 * i);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, tile->pitch);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00EA0010 + 4 * i);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, tile->addr);\n\n\tif (device->chipset != 0x34) {\n\t\tnvkm_wr32(device, NV20_PGRAPH_ZCOMP(i), tile->zcomp);\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00ea0090 + 4 * i);\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, tile->zcomp);\n\t}\n\n\tnvkm_fifo_start(fifo, &flags);\n}\n\nvoid\nnv20_gr_intr(struct nvkm_gr *base)\n{\n\tstruct nv20_gr *gr = nv20_gr(base);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_chan *chan;\n\tu32 stat = nvkm_rd32(device, NV03_PGRAPH_INTR);\n\tu32 nsource = nvkm_rd32(device, NV03_PGRAPH_NSOURCE);\n\tu32 nstatus = nvkm_rd32(device, NV03_PGRAPH_NSTATUS);\n\tu32 addr = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_ADDR);\n\tu32 chid = (addr & 0x01f00000) >> 20;\n\tu32 subc = (addr & 0x00070000) >> 16;\n\tu32 mthd = (addr & 0x00001ffc);\n\tu32 data = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_DATA);\n\tu32 class = nvkm_rd32(device, 0x400160 + subc * 4) & 0xfff;\n\tu32 show = stat;\n\tchar msg[128], src[128], sta[128];\n\tunsigned long flags;\n\n\tchan = nvkm_chan_get_chid(&gr->base.engine, chid, &flags);\n\n\tnvkm_wr32(device, NV03_PGRAPH_INTR, stat);\n\tnvkm_wr32(device, NV04_PGRAPH_FIFO, 0x00000001);\n\n\tif (show) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), nv10_gr_intr_name, show);\n\t\tnvkm_snprintbf(src, sizeof(src), nv04_gr_nsource, nsource);\n\t\tnvkm_snprintbf(sta, sizeof(sta), nv10_gr_nstatus, nstatus);\n\t\tnvkm_error(subdev, \"intr %08x [%s] nsource %08x [%s] \"\n\t\t\t\t   \"nstatus %08x [%s] ch %d [%s] subc %d \"\n\t\t\t\t   \"class %04x mthd %04x data %08x\\n\",\n\t\t\t   show, msg, nsource, src, nstatus, sta, chid,\n\t\t\t   chan ? chan->name : \"unknown\",\n\t\t\t   subc, class, mthd, data);\n\t}\n\n\tnvkm_chan_put(&chan, flags);\n}\n\nint\nnv20_gr_oneinit(struct nvkm_gr *base)\n{\n\tstruct nv20_gr *gr = nv20_gr(base);\n\treturn nvkm_memory_new(gr->base.engine.subdev.device,\n\t\t\t       NVKM_MEM_TARGET_INST, 32 * 4, 16,\n\t\t\t       true, &gr->ctxtab);\n}\n\nint\nnv20_gr_init(struct nvkm_gr *base)\n{\n\tstruct nv20_gr *gr = nv20_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 tmp, vramsz;\n\tint i;\n\n\tnvkm_wr32(device, NV20_PGRAPH_CHANNEL_CTX_TABLE,\n\t\t\t  nvkm_memory_addr(gr->ctxtab) >> 4);\n\n\tif (device->chipset == 0x20) {\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x003d0000);\n\t\tfor (i = 0; i < 15; i++)\n\t\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, 0x00000000);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!nvkm_rd32(device, 0x400700))\n\t\t\t\tbreak;\n\t\t);\n\t} else {\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x02c80000);\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, 0x00000000);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!nvkm_rd32(device, 0x400700))\n\t\t\t\tbreak;\n\t\t);\n\t}\n\n\tnvkm_wr32(device, NV03_PGRAPH_INTR   , 0xFFFFFFFF);\n\tnvkm_wr32(device, NV03_PGRAPH_INTR_EN, 0xFFFFFFFF);\n\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0x00000000);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_1, 0x00118700);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_3, 0xF3CE0475);  \n\tnvkm_wr32(device, NV10_PGRAPH_DEBUG_4, 0x00000000);\n\tnvkm_wr32(device, 0x40009C           , 0x00000040);\n\n\tif (device->chipset >= 0x25) {\n\t\tnvkm_wr32(device, 0x400890, 0x00a8cfff);\n\t\tnvkm_wr32(device, 0x400610, 0x304B1FB6);\n\t\tnvkm_wr32(device, 0x400B80, 0x1cbd3883);\n\t\tnvkm_wr32(device, 0x400B84, 0x44000000);\n\t\tnvkm_wr32(device, 0x400098, 0x40000080);\n\t\tnvkm_wr32(device, 0x400B88, 0x000000ff);\n\n\t} else {\n\t\tnvkm_wr32(device, 0x400880, 0x0008c7df);\n\t\tnvkm_wr32(device, 0x400094, 0x00000005);\n\t\tnvkm_wr32(device, 0x400B80, 0x45eae20e);\n\t\tnvkm_wr32(device, 0x400B84, 0x24000000);\n\t\tnvkm_wr32(device, 0x400098, 0x00000040);\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00E00038);\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA , 0x00000030);\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00E10038);\n\t\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA , 0x00000030);\n\t}\n\n\tnvkm_wr32(device, 0x4009a0, nvkm_rd32(device, 0x100324));\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00EA000C);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA, nvkm_rd32(device, 0x100324));\n\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_CONTROL, 0x10000100);\n\tnvkm_wr32(device, NV10_PGRAPH_STATE      , 0xFFFFFFFF);\n\n\ttmp = nvkm_rd32(device, NV10_PGRAPH_SURFACE) & 0x0007ff00;\n\tnvkm_wr32(device, NV10_PGRAPH_SURFACE, tmp);\n\ttmp = nvkm_rd32(device, NV10_PGRAPH_SURFACE) | 0x00020100;\n\tnvkm_wr32(device, NV10_PGRAPH_SURFACE, tmp);\n\n\t \n\tvramsz = device->func->resource_size(device, 1) - 1;\n\tnvkm_wr32(device, 0x4009A4, nvkm_rd32(device, 0x100200));\n\tnvkm_wr32(device, 0x4009A8, nvkm_rd32(device, 0x100204));\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00EA0000);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA , nvkm_rd32(device, 0x100200));\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_INDEX, 0x00EA0004);\n\tnvkm_wr32(device, NV10_PGRAPH_RDI_DATA , nvkm_rd32(device, 0x100204));\n\tnvkm_wr32(device, 0x400820, 0);\n\tnvkm_wr32(device, 0x400824, 0);\n\tnvkm_wr32(device, 0x400864, vramsz - 1);\n\tnvkm_wr32(device, 0x400868, vramsz - 1);\n\n\t \n\tnvkm_wr32(device, 0x400B20, 0x00000000);\n\tnvkm_wr32(device, 0x400B04, 0xFFFFFFFF);\n\n\tnvkm_wr32(device, NV03_PGRAPH_ABS_UCLIP_XMIN, 0);\n\tnvkm_wr32(device, NV03_PGRAPH_ABS_UCLIP_YMIN, 0);\n\tnvkm_wr32(device, NV03_PGRAPH_ABS_UCLIP_XMAX, 0x7fff);\n\tnvkm_wr32(device, NV03_PGRAPH_ABS_UCLIP_YMAX, 0x7fff);\n\treturn 0;\n}\n\nvoid *\nnv20_gr_dtor(struct nvkm_gr *base)\n{\n\tstruct nv20_gr *gr = nv20_gr(base);\n\tnvkm_memory_unref(&gr->ctxtab);\n\treturn gr;\n}\n\nint\nnv20_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\tstruct nv20_gr *gr;\n\n\tif (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pgr = &gr->base;\n\n\treturn nvkm_gr_ctor(func, device, type, inst, true, &gr->base);\n}\n\nstatic const struct nvkm_gr_func\nnv20_gr = {\n\t.dtor = nv20_gr_dtor,\n\t.oneinit = nv20_gr_oneinit,\n\t.init = nv20_gr_init,\n\t.intr = nv20_gr_intr,\n\t.tile = nv20_gr_tile,\n\t.chan_new = nv20_gr_chan_new,\n\t.sclass = {\n\t\t{ -1, -1, 0x0012, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0019, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0030, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0039, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0043, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0044, &nv04_gr_object },  \n\t\t{ -1, -1, 0x004a, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0062, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0072, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0089, &nv04_gr_object },  \n\t\t{ -1, -1, 0x008a, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0096, &nv04_gr_object },  \n\t\t{ -1, -1, 0x0097, &nv04_gr_object },  \n\t\t{ -1, -1, 0x009e, &nv04_gr_object },  \n\t\t{ -1, -1, 0x009f, &nv04_gr_object },  \n\t\t{}\n\t}\n};\n\nint\nnv20_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn nv20_gr_new_(&nv20_gr, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}