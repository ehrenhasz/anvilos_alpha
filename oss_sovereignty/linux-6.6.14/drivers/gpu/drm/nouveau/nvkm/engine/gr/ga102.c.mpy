{
  "module_name": "ga102.c",
  "hash_id": "80e72fb0970a7fd929a372b0e0a1193aa672da0003c7514673f32b5891621dd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/ga102.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ctxgf100.h\"\n\n#include <core/firmware.h>\n#include <subdev/acr.h>\n#include <subdev/timer.h>\n#include <subdev/vfn.h>\n\n#include <nvfw/flcn.h>\n\n#include <nvif/class.h>\n\nstatic void\nga102_gr_zbc_clear_color(struct gf100_gr *gr, int zbc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 invalid[] = { 0, 0, 0, 0 }, *color;\n\n\tif (gr->zbc_color[zbc].format)\n\t\tcolor = gr->zbc_color[zbc].l2;\n\telse\n\t\tcolor = invalid;\n\n\tnvkm_mask(device, 0x41bcb4, 0x0000001f, zbc);\n\tnvkm_wr32(device, 0x41bcec, color[0]);\n\tnvkm_wr32(device, 0x41bcf0, color[1]);\n\tnvkm_wr32(device, 0x41bcf4, color[2]);\n\tnvkm_wr32(device, 0x41bcf8, color[3]);\n}\n\nstatic const struct gf100_gr_func_zbc\nga102_gr_zbc = {\n\t.clear_color = ga102_gr_zbc_clear_color,\n\t.clear_depth = gp100_gr_zbc_clear_depth,\n\t.stencil_get = gp102_gr_zbc_stencil_get,\n\t.clear_stencil = gp102_gr_zbc_clear_stencil,\n};\n\nstatic void\nga102_gr_gpccs_reset(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x41a610, 0x00000000);\n\tnvkm_msec(device, 1, NVKM_DELAY);\n\tnvkm_wr32(device, 0x41a610, 0x00000001);\n}\n\nstatic const struct nvkm_acr_lsf_func\nga102_gr_gpccs_acr = {\n\t.flags = NVKM_ACR_LSF_FORCE_PRIV_LOAD,\n\t.bl_entry = 0x3400,\n\t.bld_size = sizeof(struct flcn_bl_dmem_desc_v2),\n\t.bld_write = gp108_gr_acr_bld_write,\n\t.bld_patch = gp108_gr_acr_bld_patch,\n};\n\nstatic void\nga102_gr_fecs_reset(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x409614, 0x00000010);\n\tnvkm_wr32(device, 0x41a614, 0x00000020);\n\tnvkm_usec(device, 10, NVKM_DELAY);\n\tnvkm_wr32(device, 0x409614, 0x00000110);\n\tnvkm_wr32(device, 0x41a614, 0x00000a20);\n\tnvkm_usec(device, 10, NVKM_DELAY);\n\tnvkm_rd32(device, 0x409614);\n\tnvkm_rd32(device, 0x41a614);\n}\n\nstatic const struct nvkm_acr_lsf_func\nga102_gr_fecs_acr = {\n\t.bl_entry = 0x7e00,\n\t.bld_size = sizeof(struct flcn_bl_dmem_desc_v2),\n\t.bld_write = gp108_gr_acr_bld_write,\n\t.bld_patch = gp108_gr_acr_bld_patch,\n};\n\nstatic void\nga102_gr_init_rop_exceptions(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x41bcbc, 0x40000000);\n\tnvkm_wr32(device, 0x41bc38, 0x40000000);\n\tnvkm_wr32(device, 0x41ac94, nvkm_rd32(device, 0x502c94));\n}\n\nstatic void\nga102_gr_init_40a790(struct gf100_gr *gr)\n{\n\tnvkm_wr32(gr->base.engine.subdev.device, 0x40a790, 0xc0000000);\n}\n\nstatic void\nga102_gr_init_gpc_mmu(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_wr32(device, 0x418880, nvkm_rd32(device, 0x100c80) & 0xf8001fff);\n\tnvkm_wr32(device, 0x418894, 0x00000000);\n\n\tnvkm_wr32(device, 0x4188b4, nvkm_rd32(device, 0x100cc8));\n\tnvkm_wr32(device, 0x4188b8, nvkm_rd32(device, 0x100ccc));\n\tnvkm_wr32(device, 0x4188b0, nvkm_rd32(device, 0x100cc4));\n}\n\nstatic struct nvkm_intr *\nga102_gr_oneinit_intr(struct gf100_gr *gr, enum nvkm_intr_type *pvector)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\t*pvector = nvkm_rd32(device, 0x400154) & 0x00000fff;\n\treturn &device->vfn->intr;\n}\n\nstatic int\nga102_gr_nonstall(struct gf100_gr *gr)\n{\n\treturn nvkm_rd32(gr->base.engine.subdev.device, 0x400160) & 0x00000fff;\n}\n\nstatic const struct gf100_gr_func\nga102_gr = {\n\t.nonstall = ga102_gr_nonstall,\n\t.oneinit_intr = ga102_gr_oneinit_intr,\n\t.oneinit_tiles = gm200_gr_oneinit_tiles,\n\t.oneinit_sm_id = gv100_gr_oneinit_sm_id,\n\t.init = gf100_gr_init,\n\t.init_419bd8 = gv100_gr_init_419bd8,\n\t.init_gpc_mmu = ga102_gr_init_gpc_mmu,\n\t.init_vsc_stream_master = gk104_gr_init_vsc_stream_master,\n\t.init_zcull = tu102_gr_init_zcull,\n\t.init_num_active_ltcs = gf100_gr_init_num_active_ltcs,\n\t.init_swdx_pes_mask = gp102_gr_init_swdx_pes_mask,\n\t.init_fs = tu102_gr_init_fs,\n\t.init_fecs_exceptions = tu102_gr_init_fecs_exceptions,\n\t.init_40a790 = ga102_gr_init_40a790,\n\t.init_ds_hww_esr_2 = gm200_gr_init_ds_hww_esr_2,\n\t.init_sked_hww_esr = gk104_gr_init_sked_hww_esr,\n\t.init_ppc_exceptions = gk104_gr_init_ppc_exceptions,\n\t.init_504430 = gv100_gr_init_504430,\n\t.init_shader_exceptions = gv100_gr_init_shader_exceptions,\n\t.init_rop_exceptions = ga102_gr_init_rop_exceptions,\n\t.init_4188a4 = gv100_gr_init_4188a4,\n\t.trap_mp = gv100_gr_trap_mp,\n\t.fecs.reset = ga102_gr_fecs_reset,\n\t.gpccs.reset = ga102_gr_gpccs_reset,\n\t.rops = gm200_gr_rops,\n\t.gpc_nr = 7,\n\t.tpc_nr = 6,\n\t.ppc_nr = 3,\n\t.grctx = &ga102_grctx,\n\t.zbc = &ga102_gr_zbc,\n\t.sclass = {\n\t\t{ -1, -1, FERMI_TWOD_A },\n\t\t{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },\n\t\t{ -1, -1, AMPERE_B, &gf100_fermi },\n\t\t{ -1, -1, AMPERE_COMPUTE_B },\n\t\t{}\n\t}\n};\n\nMODULE_FIRMWARE(\"nvidia/ga102/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/gr/NET_img.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga103/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/gr/NET_img.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga104/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/gr/NET_img.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga106/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/gr/NET_img.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga107/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/gr/NET_img.bin\");\n\nstruct netlist_region {\n\tu32 region_id;\n\tu32 data_size;\n\tu32 data_offset;\n};\n\nstruct netlist_image_header {\n\tu32 version;\n\tu32 regions;\n};\n\nstruct netlist_image {\n\tstruct netlist_image_header header;\n\tstruct netlist_region regions[];\n};\n\nstruct netlist_av64 {\n\tu32 addr;\n\tu32 data_hi;\n\tu32 data_lo;\n};\n\nstatic int\nga102_gr_av64_to_init(struct nvkm_blob *blob, struct gf100_gr_pack **ppack)\n{\n\tstruct gf100_gr_init *init;\n\tstruct gf100_gr_pack *pack;\n\tint nent;\n\tint i;\n\n\tnent = (blob->size / sizeof(struct netlist_av64));\n\tpack = vzalloc((sizeof(*pack) * 2) + (sizeof(*init) * (nent + 1)));\n\tif (!pack)\n\t\treturn -ENOMEM;\n\n\tinit = (void *)(pack + 2);\n\tpack[0].init = init;\n\tpack[0].type = 64;\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct gf100_gr_init *ent = &init[i];\n\t\tstruct netlist_av64 *av = &((struct netlist_av64 *)blob->data)[i];\n\n\t\tent->addr = av->addr;\n\t\tent->data = ((u64)av->data_hi << 32) | av->data_lo;\n\t\tent->count = 1;\n\t\tent->pitch = 1;\n\t}\n\n\t*ppack = pack;\n\treturn 0;\n}\n\nstatic int\nga102_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tconst struct firmware *fw;\n\tconst struct netlist_image *net;\n\tconst struct netlist_region *fecs_inst = NULL;\n\tconst struct netlist_region *fecs_data = NULL;\n\tconst struct netlist_region *gpccs_inst = NULL;\n\tconst struct netlist_region *gpccs_data = NULL;\n\tint ret, i;\n\n\tret = nvkm_firmware_get(subdev, \"gr/NET_img\", 0, &fw);\n\tif (ret)\n\t\treturn ret;\n\n\tnet = (const void *)fw->data;\n\tnvkm_debug(subdev, \"netlist version %d, %d regions\\n\",\n\t\t   net->header.version, net->header.regions);\n\n\tfor (i = 0; i < net->header.regions; i++) {\n\t\tconst struct netlist_region *reg = &net->regions[i];\n\t\tstruct nvkm_blob blob = {\n\t\t\t.data = (void *)fw->data + reg->data_offset,\n\t\t\t.size = reg->data_size,\n\t\t};\n\n\t\tnvkm_debug(subdev, \"\\t%2d: %08x %08x\\n\",\n\t\t\t   reg->region_id, reg->data_offset, reg->data_size);\n\n\t\tswitch (reg->region_id) {\n\t\tcase  0: fecs_data = reg; break;\n\t\tcase  1: fecs_inst = reg; break;\n\t\tcase  2: gpccs_data = reg; break;\n\t\tcase  3: gpccs_inst = reg; break;\n\t\tcase  4: gk20a_gr_av_to_init(&blob, &gr->bundle); break;\n\t\tcase  5: gk20a_gr_aiv_to_init(&blob, &gr->sw_ctx); break;\n\t\tcase  7: gk20a_gr_av_to_method(&blob, &gr->method); break;\n\t\tcase 28: tu102_gr_av_to_init_veid(&blob, &gr->bundle_veid); break;\n\t\tcase 34: ga102_gr_av64_to_init(&blob, &gr->bundle64); break;\n\t\tcase 48: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx1); break;\n\t\tcase 49: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx2); break;\n\t\tcase 50: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx3); break;\n\t\tcase 51: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx4); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->fecs.falcon, NVKM_ACR_LSF_FECS,\n\t\t\t\t\t    \"gr/fecs_\", ver, fwif->fecs,\n\t\t\t\t\t    fw->data + fecs_inst->data_offset,\n\t\t\t\t\t\t       fecs_inst->data_size,\n\t\t\t\t\t    fw->data + fecs_data->data_offset,\n\t\t\t\t\t\t       fecs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->gpccs.falcon, NVKM_ACR_LSF_GPCCS,\n\t\t\t\t\t    \"gr/gpccs_\", ver, fwif->gpccs,\n\t\t\t\t\t    fw->data + gpccs_inst->data_offset,\n\t\t\t\t\t\t       gpccs_inst->data_size,\n\t\t\t\t\t    fw->data + gpccs_data->data_offset,\n\t\t\t\t\t\t       gpccs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tgr->firmware = true;\n\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}\n\nstatic const struct gf100_gr_fwif\nga102_gr_fwif[] = {\n\t{  0, ga102_gr_load, &ga102_gr, &ga102_gr_fecs_acr, &ga102_gr_gpccs_acr },\n\t{ -1, gm200_gr_nofw },\n\t{}\n};\n\nint\nga102_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn gf100_gr_new_(ga102_gr_fwif, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}