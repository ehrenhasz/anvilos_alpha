{
  "module_name": "nv50.c",
  "hash_id": "32ba5a6abf6df8ebd55a9137874e57654a630def30f4c393d8d2f231c534a2cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv50.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n\nu64\nnv50_gr_units(struct nvkm_gr *gr)\n{\n\treturn nvkm_rd32(gr->engine.subdev.device, 0x1540);\n}\n\n \n\nstatic int\nnv50_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t    int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tint ret = nvkm_gpuobj_new(object->engine->subdev.device, 16,\n\t\t\t\t  align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, object->oclass);\n\t\tnvkm_wo32(*pgpuobj, 0x04, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x08, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x0c, 0x00000000);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nconst struct nvkm_object_func\nnv50_gr_object = {\n\t.bind = nv50_gr_object_bind,\n};\n\n \n\nstatic int\nnv50_gr_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t  int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nv50_gr *gr = nv50_gr_chan(object)->gr;\n\tint ret = nvkm_gpuobj_new(gr->base.engine.subdev.device, gr->size,\n\t\t\t\t  align, true, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnv50_grctx_fill(gr->base.engine.subdev.device, *pgpuobj);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nstatic const struct nvkm_object_func\nnv50_gr_chan = {\n\t.bind = nv50_gr_chan_bind,\n};\n\nint\nnv50_gr_chan_new(struct nvkm_gr *base, struct nvkm_chan *fifoch,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object **pobject)\n{\n\tstruct nv50_gr *gr = nv50_gr(base);\n\tstruct nv50_gr_chan *chan;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nv50_gr_chan, oclass, &chan->object);\n\tchan->gr = gr;\n\t*pobject = &chan->object;\n\treturn 0;\n}\n\n \n\nstatic const struct nvkm_bitfield nv50_mp_exec_errors[] = {\n\t{ 0x01, \"STACK_UNDERFLOW\" },\n\t{ 0x02, \"STACK_MISMATCH\" },\n\t{ 0x04, \"QUADON_ACTIVE\" },\n\t{ 0x08, \"TIMEOUT\" },\n\t{ 0x10, \"INVALID_OPCODE\" },\n\t{ 0x20, \"PM_OVERFLOW\" },\n\t{ 0x40, \"BREAKPOINT\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_mpc_traps[] = {\n\t{ 0x0000001, \"LOCAL_LIMIT_READ\" },\n\t{ 0x0000010, \"LOCAL_LIMIT_WRITE\" },\n\t{ 0x0000040, \"STACK_LIMIT\" },\n\t{ 0x0000100, \"GLOBAL_LIMIT_READ\" },\n\t{ 0x0001000, \"GLOBAL_LIMIT_WRITE\" },\n\t{ 0x0010000, \"MP0\" },\n\t{ 0x0020000, \"MP1\" },\n\t{ 0x0040000, \"GLOBAL_LIMIT_RED\" },\n\t{ 0x0400000, \"GLOBAL_LIMIT_ATOM\" },\n\t{ 0x4000000, \"MP2\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_tex_traps[] = {\n\t{ 0x00000001, \"\" },  \n\t{ 0x00000002, \"FAULT\" },\n\t{ 0x00000004, \"STORAGE_TYPE_MISMATCH\" },\n\t{ 0x00000008, \"LINEAR_MISMATCH\" },\n\t{ 0x00000020, \"WRONG_MEMTYPE\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_gr_trap_m2mf[] = {\n\t{ 0x00000001, \"NOTIFY\" },\n\t{ 0x00000002, \"IN\" },\n\t{ 0x00000004, \"OUT\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_gr_trap_vfetch[] = {\n\t{ 0x00000001, \"FAULT\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_gr_trap_strmout[] = {\n\t{ 0x00000001, \"FAULT\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_gr_trap_ccache[] = {\n\t{ 0x00000001, \"FAULT\" },\n\t{}\n};\n\n \nconst struct nvkm_enum nv50_data_error_names[] = {\n\t{ 0x00000003, \"INVALID_OPERATION\", NULL },\n\t{ 0x00000004, \"INVALID_VALUE\", NULL },\n\t{ 0x00000005, \"INVALID_ENUM\", NULL },\n\t{ 0x00000008, \"INVALID_OBJECT\", NULL },\n\t{ 0x00000009, \"READ_ONLY_OBJECT\", NULL },\n\t{ 0x0000000a, \"SUPERVISOR_OBJECT\", NULL },\n\t{ 0x0000000b, \"INVALID_ADDRESS_ALIGNMENT\", NULL },\n\t{ 0x0000000c, \"INVALID_BITFIELD\", NULL },\n\t{ 0x0000000d, \"BEGIN_END_ACTIVE\", NULL },\n\t{ 0x0000000e, \"SEMANTIC_COLOR_BACK_OVER_LIMIT\", NULL },\n\t{ 0x0000000f, \"VIEWPORT_ID_NEEDS_GP\", NULL },\n\t{ 0x00000010, \"RT_DOUBLE_BIND\", NULL },\n\t{ 0x00000011, \"RT_TYPES_MISMATCH\", NULL },\n\t{ 0x00000012, \"RT_LINEAR_WITH_ZETA\", NULL },\n\t{ 0x00000015, \"FP_TOO_FEW_REGS\", NULL },\n\t{ 0x00000016, \"ZETA_FORMAT_CSAA_MISMATCH\", NULL },\n\t{ 0x00000017, \"RT_LINEAR_WITH_MSAA\", NULL },\n\t{ 0x00000018, \"FP_INTERPOLANT_START_OVER_LIMIT\", NULL },\n\t{ 0x00000019, \"SEMANTIC_LAYER_OVER_LIMIT\", NULL },\n\t{ 0x0000001a, \"RT_INVALID_ALIGNMENT\", NULL },\n\t{ 0x0000001b, \"SAMPLER_OVER_LIMIT\", NULL },\n\t{ 0x0000001c, \"TEXTURE_OVER_LIMIT\", NULL },\n\t{ 0x0000001e, \"GP_TOO_MANY_OUTPUTS\", NULL },\n\t{ 0x0000001f, \"RT_BPP128_WITH_MS8\", NULL },\n\t{ 0x00000021, \"Z_OUT_OF_BOUNDS\", NULL },\n\t{ 0x00000023, \"XY_OUT_OF_BOUNDS\", NULL },\n\t{ 0x00000024, \"VP_ZERO_INPUTS\", NULL },\n\t{ 0x00000027, \"CP_MORE_PARAMS_THAN_SHARED\", NULL },\n\t{ 0x00000028, \"CP_NO_REG_SPACE_STRIPED\", NULL },\n\t{ 0x00000029, \"CP_NO_REG_SPACE_PACKED\", NULL },\n\t{ 0x0000002a, \"CP_NOT_ENOUGH_WARPS\", NULL },\n\t{ 0x0000002b, \"CP_BLOCK_SIZE_MISMATCH\", NULL },\n\t{ 0x0000002c, \"CP_NOT_ENOUGH_LOCAL_WARPS\", NULL },\n\t{ 0x0000002d, \"CP_NOT_ENOUGH_STACK_WARPS\", NULL },\n\t{ 0x0000002e, \"CP_NO_BLOCKDIM_LATCH\", NULL },\n\t{ 0x00000031, \"ENG2D_FORMAT_MISMATCH\", NULL },\n\t{ 0x0000003f, \"PRIMITIVE_ID_NEEDS_GP\", NULL },\n\t{ 0x00000044, \"SEMANTIC_VIEWPORT_OVER_LIMIT\", NULL },\n\t{ 0x00000045, \"SEMANTIC_COLOR_FRONT_OVER_LIMIT\", NULL },\n\t{ 0x00000046, \"LAYER_ID_NEEDS_GP\", NULL },\n\t{ 0x00000047, \"SEMANTIC_CLIP_OVER_LIMIT\", NULL },\n\t{ 0x00000048, \"SEMANTIC_PTSZ_OVER_LIMIT\", NULL },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_gr_intr_name[] = {\n\t{ 0x00000001, \"NOTIFY\" },\n\t{ 0x00000002, \"COMPUTE_QUERY\" },\n\t{ 0x00000010, \"ILLEGAL_MTHD\" },\n\t{ 0x00000020, \"ILLEGAL_CLASS\" },\n\t{ 0x00000040, \"DOUBLE_NOTIFY\" },\n\t{ 0x00001000, \"CONTEXT_SWITCH\" },\n\t{ 0x00010000, \"BUFFER_NOTIFY\" },\n\t{ 0x00100000, \"DATA_ERROR\" },\n\t{ 0x00200000, \"TRAP\" },\n\t{ 0x01000000, \"SINGLE_STEP\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield nv50_gr_trap_prop[] = {\n\t{ 0x00000004, \"SURF_WIDTH_OVERRUN\" },\n\t{ 0x00000008, \"SURF_HEIGHT_OVERRUN\" },\n\t{ 0x00000010, \"DST2D_FAULT\" },\n\t{ 0x00000020, \"ZETA_FAULT\" },\n\t{ 0x00000040, \"RT_FAULT\" },\n\t{ 0x00000080, \"CUDA_FAULT\" },\n\t{ 0x00000100, \"DST2D_STORAGE_TYPE_MISMATCH\" },\n\t{ 0x00000200, \"ZETA_STORAGE_TYPE_MISMATCH\" },\n\t{ 0x00000400, \"RT_STORAGE_TYPE_MISMATCH\" },\n\t{ 0x00000800, \"DST2D_LINEAR_MISMATCH\" },\n\t{ 0x00001000, \"RT_LINEAR_MISMATCH\" },\n\t{}\n};\n\nstatic void\nnv50_gr_prop_trap(struct nv50_gr *gr, u32 ustatus_addr, u32 ustatus, u32 tp)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 e0c = nvkm_rd32(device, ustatus_addr + 0x04);\n\tu32 e10 = nvkm_rd32(device, ustatus_addr + 0x08);\n\tu32 e14 = nvkm_rd32(device, ustatus_addr + 0x0c);\n\tu32 e18 = nvkm_rd32(device, ustatus_addr + 0x10);\n\tu32 e1c = nvkm_rd32(device, ustatus_addr + 0x14);\n\tu32 e20 = nvkm_rd32(device, ustatus_addr + 0x18);\n\tu32 e24 = nvkm_rd32(device, ustatus_addr + 0x1c);\n\tchar msg[128];\n\n\t \n\tif (ustatus & 0x00000080) {\n\t\tif (e18 & 0x80000000) {\n\t\t\t \n\t\t\tnvkm_error(subdev, \"TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\\n\",\n\t\t\t\t\t tp, e14, e10 | ((e18 >> 24) & 0x1f));\n\t\t\te18 &= ~0x1f000000;\n\t\t} else if (e18 & 0xc) {\n\t\t\t \n\t\t\tnvkm_error(subdev, \"TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\\n\",\n\t\t\t\t tp, e14, e10 | ((e18 >> 7) & 0x1f));\n\t\t\te18 &= ~0x00000f80;\n\t\t} else {\n\t\t\tnvkm_error(subdev, \"TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\\n\",\n\t\t\t\t tp, e14, e10);\n\t\t}\n\t\tustatus &= ~0x00000080;\n\t}\n\tif (ustatus) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), nv50_gr_trap_prop, ustatus);\n\t\tnvkm_error(subdev, \"TRAP_PROP - TP %d - %08x [%s] - \"\n\t\t\t\t   \"Address %02x%08x\\n\",\n\t\t\t   tp, ustatus, msg, e14, e10);\n\t}\n\tnvkm_error(subdev, \"TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\\n\",\n\t\t tp, e0c, e18, e1c, e20, e24);\n}\n\nstatic void\nnv50_gr_mp_trap(struct nv50_gr *gr, int tpid, int display)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 units = nvkm_rd32(device, 0x1540);\n\tu32 addr, mp10, status, pc, oplow, ophigh;\n\tchar msg[128];\n\tint i;\n\tint mps = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (!(units & 1 << (i+24)))\n\t\t\tcontinue;\n\t\tif (device->chipset < 0xa0)\n\t\t\taddr = 0x408200 + (tpid << 12) + (i << 7);\n\t\telse\n\t\t\taddr = 0x408100 + (tpid << 11) + (i << 7);\n\t\tmp10 = nvkm_rd32(device, addr + 0x10);\n\t\tstatus = nvkm_rd32(device, addr + 0x14);\n\t\tif (!status)\n\t\t\tcontinue;\n\t\tif (display) {\n\t\t\tnvkm_rd32(device, addr + 0x20);\n\t\t\tpc = nvkm_rd32(device, addr + 0x24);\n\t\t\toplow = nvkm_rd32(device, addr + 0x70);\n\t\t\tophigh = nvkm_rd32(device, addr + 0x74);\n\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t       nv50_mp_exec_errors, status);\n\t\t\tnvkm_error(subdev, \"TRAP_MP_EXEC - TP %d MP %d: \"\n\t\t\t\t\t   \"%08x [%s] at %06x warp %d, \"\n\t\t\t\t\t   \"opcode %08x %08x\\n\",\n\t\t\t\t   tpid, i, status, msg, pc & 0xffffff,\n\t\t\t\t   pc >> 24, oplow, ophigh);\n\t\t}\n\t\tnvkm_wr32(device, addr + 0x10, mp10);\n\t\tnvkm_wr32(device, addr + 0x14, 0);\n\t\tmps++;\n\t}\n\tif (!mps && display)\n\t\tnvkm_error(subdev, \"TRAP_MP_EXEC - TP %d: \"\n\t\t\t\t\"No MPs claiming errors?\\n\", tpid);\n}\n\nstatic void\nnv50_gr_tp_trap(struct nv50_gr *gr, int type, u32 ustatus_old,\n\t\t  u32 ustatus_new, int display, const char *name)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 units = nvkm_rd32(device, 0x1540);\n\tint tps = 0;\n\tint i, r;\n\tchar msg[128];\n\tu32 ustatus_addr, ustatus;\n\tfor (i = 0; i < 16; i++) {\n\t\tif (!(units & (1 << i)))\n\t\t\tcontinue;\n\t\tif (device->chipset < 0xa0)\n\t\t\tustatus_addr = ustatus_old + (i << 12);\n\t\telse\n\t\t\tustatus_addr = ustatus_new + (i << 11);\n\t\tustatus = nvkm_rd32(device, ustatus_addr) & 0x7fffffff;\n\t\tif (!ustatus)\n\t\t\tcontinue;\n\t\ttps++;\n\t\tswitch (type) {\n\t\tcase 6:  \n\t\t\tif (display) {\n\t\t\t\tnvkm_error(subdev, \"magic set %d:\\n\", i);\n\t\t\t\tfor (r = ustatus_addr + 4; r <= ustatus_addr + 0x10; r += 4)\n\t\t\t\t\tnvkm_error(subdev, \"\\t%08x: %08x\\n\", r,\n\t\t\t\t\t\t   nvkm_rd32(device, r));\n\t\t\t\tif (ustatus) {\n\t\t\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t\t\t       nv50_tex_traps, ustatus);\n\t\t\t\t\tnvkm_error(subdev,\n\t\t\t\t\t\t   \"%s - TP%d: %08x [%s]\\n\",\n\t\t\t\t\t\t   name, i, ustatus, msg);\n\t\t\t\t\tustatus = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7:  \n\t\t\tif (ustatus & 0x04030000) {\n\t\t\t\tnv50_gr_mp_trap(gr, i, display);\n\t\t\t\tustatus &= ~0x04030000;\n\t\t\t}\n\t\t\tif (ustatus && display) {\n\t\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t\t       nv50_mpc_traps, ustatus);\n\t\t\t\tnvkm_error(subdev, \"%s - TP%d: %08x [%s]\\n\",\n\t\t\t\t\t   name, i, ustatus, msg);\n\t\t\t\tustatus = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 8:  \n\t\t\tif (display)\n\t\t\t\tnv50_gr_prop_trap(\n\t\t\t\t\t\tgr, ustatus_addr, ustatus, i);\n\t\t\tustatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (ustatus) {\n\t\t\tif (display)\n\t\t\t\tnvkm_error(subdev, \"%s - TP%d: Unhandled ustatus %08x\\n\", name, i, ustatus);\n\t\t}\n\t\tnvkm_wr32(device, ustatus_addr, 0xc0000000);\n\t}\n\n\tif (!tps && display)\n\t\tnvkm_warn(subdev, \"%s - No TPs claiming errors?\\n\", name);\n}\n\nstatic int\nnv50_gr_trap_handler(struct nv50_gr *gr, u32 display,\n\t\t     int chid, u64 inst, const char *name)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 status = nvkm_rd32(device, 0x400108);\n\tu32 ustatus;\n\tchar msg[128];\n\n\tif (!status && display) {\n\t\tnvkm_error(subdev, \"TRAP: no units reporting traps?\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tif (status & 0x001) {\n\t\tustatus = nvkm_rd32(device, 0x400804) & 0x7fffffff;\n\t\tif (!ustatus && display) {\n\t\t\tnvkm_error(subdev, \"TRAP_DISPATCH - no ustatus?\\n\");\n\t\t}\n\n\t\tnvkm_wr32(device, 0x400500, 0x00000000);\n\n\t\t \n\t\tif (ustatus & 0x00000001) {\n\t\t\tu32 addr = nvkm_rd32(device, 0x400808);\n\t\t\tu32 subc = (addr & 0x00070000) >> 16;\n\t\t\tu32 mthd = (addr & 0x00001ffc);\n\t\t\tu32 datal = nvkm_rd32(device, 0x40080c);\n\t\t\tu32 datah = nvkm_rd32(device, 0x400810);\n\t\t\tu32 class = nvkm_rd32(device, 0x400814);\n\t\t\tu32 r848 = nvkm_rd32(device, 0x400848);\n\n\t\t\tnvkm_error(subdev, \"TRAP DISPATCH_FAULT\\n\");\n\t\t\tif (display && (addr & 0x80000000)) {\n\t\t\t\tnvkm_error(subdev,\n\t\t\t\t\t   \"ch %d [%010llx %s] subc %d \"\n\t\t\t\t\t   \"class %04x mthd %04x data %08x%08x \"\n\t\t\t\t\t   \"400808 %08x 400848 %08x\\n\",\n\t\t\t\t\t   chid, inst, name, subc, class, mthd,\n\t\t\t\t\t   datah, datal, addr, r848);\n\t\t\t} else\n\t\t\tif (display) {\n\t\t\t\tnvkm_error(subdev, \"no stuck command?\\n\");\n\t\t\t}\n\n\t\t\tnvkm_wr32(device, 0x400808, 0);\n\t\t\tnvkm_wr32(device, 0x4008e8, nvkm_rd32(device, 0x4008e8) & 3);\n\t\t\tnvkm_wr32(device, 0x400848, 0);\n\t\t\tustatus &= ~0x00000001;\n\t\t}\n\n\t\tif (ustatus & 0x00000002) {\n\t\t\tu32 addr = nvkm_rd32(device, 0x40084c);\n\t\t\tu32 subc = (addr & 0x00070000) >> 16;\n\t\t\tu32 mthd = (addr & 0x00001ffc);\n\t\t\tu32 data = nvkm_rd32(device, 0x40085c);\n\t\t\tu32 class = nvkm_rd32(device, 0x400814);\n\n\t\t\tnvkm_error(subdev, \"TRAP DISPATCH_QUERY\\n\");\n\t\t\tif (display && (addr & 0x80000000)) {\n\t\t\t\tnvkm_error(subdev,\n\t\t\t\t\t   \"ch %d [%010llx %s] subc %d \"\n\t\t\t\t\t   \"class %04x mthd %04x data %08x \"\n\t\t\t\t\t   \"40084c %08x\\n\", chid, inst, name,\n\t\t\t\t\t   subc, class, mthd, data, addr);\n\t\t\t} else\n\t\t\tif (display) {\n\t\t\t\tnvkm_error(subdev, \"no stuck command?\\n\");\n\t\t\t}\n\n\t\t\tnvkm_wr32(device, 0x40084c, 0);\n\t\t\tustatus &= ~0x00000002;\n\t\t}\n\n\t\tif (ustatus && display) {\n\t\t\tnvkm_error(subdev, \"TRAP_DISPATCH \"\n\t\t\t\t\t   \"(unknown %08x)\\n\", ustatus);\n\t\t}\n\n\t\tnvkm_wr32(device, 0x400804, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x001);\n\t\tstatus &= ~0x001;\n\t\tif (!status)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (status & 0x002) {\n\t\tu32 ustatus = nvkm_rd32(device, 0x406800) & 0x7fffffff;\n\t\tif (display) {\n\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t       nv50_gr_trap_m2mf, ustatus);\n\t\t\tnvkm_error(subdev, \"TRAP_M2MF %08x [%s]\\n\",\n\t\t\t\t   ustatus, msg);\n\t\t\tnvkm_error(subdev, \"TRAP_M2MF %08x %08x %08x %08x\\n\",\n\t\t\t\t   nvkm_rd32(device, 0x406804),\n\t\t\t\t   nvkm_rd32(device, 0x406808),\n\t\t\t\t   nvkm_rd32(device, 0x40680c),\n\t\t\t\t   nvkm_rd32(device, 0x406810));\n\t\t}\n\n\t\t \n\t\tnvkm_wr32(device, 0x400040, 2);\n\t\tnvkm_wr32(device, 0x400040, 0);\n\t\tnvkm_wr32(device, 0x406800, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x002);\n\t\tstatus &= ~0x002;\n\t}\n\n\t \n\tif (status & 0x004) {\n\t\tu32 ustatus = nvkm_rd32(device, 0x400c04) & 0x7fffffff;\n\t\tif (display) {\n\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t       nv50_gr_trap_vfetch, ustatus);\n\t\t\tnvkm_error(subdev, \"TRAP_VFETCH %08x [%s]\\n\",\n\t\t\t\t   ustatus, msg);\n\t\t\tnvkm_error(subdev, \"TRAP_VFETCH %08x %08x %08x %08x\\n\",\n\t\t\t\t   nvkm_rd32(device, 0x400c00),\n\t\t\t\t   nvkm_rd32(device, 0x400c08),\n\t\t\t\t   nvkm_rd32(device, 0x400c0c),\n\t\t\t\t   nvkm_rd32(device, 0x400c10));\n\t\t}\n\n\t\tnvkm_wr32(device, 0x400c04, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x004);\n\t\tstatus &= ~0x004;\n\t}\n\n\t \n\tif (status & 0x008) {\n\t\tustatus = nvkm_rd32(device, 0x401800) & 0x7fffffff;\n\t\tif (display) {\n\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t       nv50_gr_trap_strmout, ustatus);\n\t\t\tnvkm_error(subdev, \"TRAP_STRMOUT %08x [%s]\\n\",\n\t\t\t\t   ustatus, msg);\n\t\t\tnvkm_error(subdev, \"TRAP_STRMOUT %08x %08x %08x %08x\\n\",\n\t\t\t\t   nvkm_rd32(device, 0x401804),\n\t\t\t\t   nvkm_rd32(device, 0x401808),\n\t\t\t\t   nvkm_rd32(device, 0x40180c),\n\t\t\t\t   nvkm_rd32(device, 0x401810));\n\t\t}\n\n\t\t \n\t\tnvkm_wr32(device, 0x400040, 0x80);\n\t\tnvkm_wr32(device, 0x400040, 0);\n\t\tnvkm_wr32(device, 0x401800, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x008);\n\t\tstatus &= ~0x008;\n\t}\n\n\t \n\tif (status & 0x010) {\n\t\tustatus = nvkm_rd32(device, 0x405018) & 0x7fffffff;\n\t\tif (display) {\n\t\t\tnvkm_snprintbf(msg, sizeof(msg),\n\t\t\t\t       nv50_gr_trap_ccache, ustatus);\n\t\t\tnvkm_error(subdev, \"TRAP_CCACHE %08x [%s]\\n\",\n\t\t\t\t   ustatus, msg);\n\t\t\tnvkm_error(subdev, \"TRAP_CCACHE %08x %08x %08x %08x \"\n\t\t\t\t\t   \"%08x %08x %08x\\n\",\n\t\t\t\t   nvkm_rd32(device, 0x405000),\n\t\t\t\t   nvkm_rd32(device, 0x405004),\n\t\t\t\t   nvkm_rd32(device, 0x405008),\n\t\t\t\t   nvkm_rd32(device, 0x40500c),\n\t\t\t\t   nvkm_rd32(device, 0x405010),\n\t\t\t\t   nvkm_rd32(device, 0x405014),\n\t\t\t\t   nvkm_rd32(device, 0x40501c));\n\t\t}\n\n\t\tnvkm_wr32(device, 0x405018, 0xc0000000);\n\t\tnvkm_wr32(device, 0x400108, 0x010);\n\t\tstatus &= ~0x010;\n\t}\n\n\t \n\tif (status & 0x20) {\n\t\tustatus = nvkm_rd32(device, 0x402000) & 0x7fffffff;\n\t\tif (display)\n\t\t\tnvkm_error(subdev, \"TRAP_UNKC04 %08x\\n\", ustatus);\n\t\tnvkm_wr32(device, 0x402000, 0xc0000000);\n\t\t \n\t}\n\n\t \n\tif (status & 0x040) {\n\t\tnv50_gr_tp_trap(gr, 6, 0x408900, 0x408600, display,\n\t\t\t\t    \"TRAP_TEXTURE\");\n\t\tnvkm_wr32(device, 0x400108, 0x040);\n\t\tstatus &= ~0x040;\n\t}\n\n\t \n\tif (status & 0x080) {\n\t\tnv50_gr_tp_trap(gr, 7, 0x408314, 0x40831c, display,\n\t\t\t\t    \"TRAP_MP\");\n\t\tnvkm_wr32(device, 0x400108, 0x080);\n\t\tstatus &= ~0x080;\n\t}\n\n\t \n\tif (status & 0x100) {\n\t\tnv50_gr_tp_trap(gr, 8, 0x408e08, 0x408708, display,\n\t\t\t\t    \"TRAP_PROP\");\n\t\tnvkm_wr32(device, 0x400108, 0x100);\n\t\tstatus &= ~0x100;\n\t}\n\n\tif (status) {\n\t\tif (display)\n\t\t\tnvkm_error(subdev, \"TRAP: unknown %08x\\n\", status);\n\t\tnvkm_wr32(device, 0x400108, status);\n\t}\n\n\treturn 1;\n}\n\nvoid\nnv50_gr_intr(struct nvkm_gr *base)\n{\n\tstruct nv50_gr *gr = nv50_gr(base);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_chan *chan;\n\tu32 stat = nvkm_rd32(device, 0x400100);\n\tu32 inst = nvkm_rd32(device, 0x40032c) & 0x0fffffff;\n\tu32 addr = nvkm_rd32(device, 0x400704);\n\tu32 subc = (addr & 0x00070000) >> 16;\n\tu32 mthd = (addr & 0x00001ffc);\n\tu32 data = nvkm_rd32(device, 0x400708);\n\tu32 class = nvkm_rd32(device, 0x400814);\n\tu32 show = stat, show_bitfield = stat;\n\tconst struct nvkm_enum *en;\n\tunsigned long flags;\n\tconst char *name = \"unknown\";\n\tchar msg[128];\n\tint chid = -1;\n\n\tchan = nvkm_chan_get_inst(&gr->base.engine, (u64)inst << 12, &flags);\n\tif (chan)  {\n\t\tname = chan->name;\n\t\tchid = chan->id;\n\t}\n\n\tif (show & 0x00100000) {\n\t\tu32 ecode = nvkm_rd32(device, 0x400110);\n\t\ten = nvkm_enum_find(nv50_data_error_names, ecode);\n\t\tnvkm_error(subdev, \"DATA_ERROR %08x [%s]\\n\",\n\t\t\t   ecode, en ? en->name : \"\");\n\t\tshow_bitfield &= ~0x00100000;\n\t}\n\n\tif (stat & 0x00200000) {\n\t\tif (!nv50_gr_trap_handler(gr, show, chid, (u64)inst << 12, name))\n\t\t\tshow &= ~0x00200000;\n\t\tshow_bitfield &= ~0x00200000;\n\t}\n\n\tnvkm_wr32(device, 0x400100, stat);\n\tnvkm_wr32(device, 0x400500, 0x00010001);\n\n\tif (show) {\n\t\tshow &= show_bitfield;\n\t\tnvkm_snprintbf(msg, sizeof(msg), nv50_gr_intr_name, show);\n\t\tnvkm_error(subdev, \"%08x [%s] ch %d [%010llx %s] subc %d \"\n\t\t\t\t   \"class %04x mthd %04x data %08x\\n\",\n\t\t\t   stat, msg, chid, (u64)inst << 12, name,\n\t\t\t   subc, class, mthd, data);\n\t}\n\n\tif (nvkm_rd32(device, 0x400824) & (1 << 31))\n\t\tnvkm_wr32(device, 0x400824, nvkm_rd32(device, 0x400824) & ~(1 << 31));\n\n\tnvkm_chan_put(&chan, flags);\n}\n\nint\nnv50_gr_init(struct nvkm_gr *base)\n{\n\tstruct nv50_gr *gr = nv50_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint ret, units, i;\n\n\t \n\tnvkm_wr32(device, 0x40008c, 0x00000004);\n\n\t \n\tnvkm_wr32(device, 0x400804, 0xc0000000);\n\tnvkm_wr32(device, 0x406800, 0xc0000000);\n\tnvkm_wr32(device, 0x400c04, 0xc0000000);\n\tnvkm_wr32(device, 0x401800, 0xc0000000);\n\tnvkm_wr32(device, 0x405018, 0xc0000000);\n\tnvkm_wr32(device, 0x402000, 0xc0000000);\n\n\tunits = nvkm_rd32(device, 0x001540);\n\tfor (i = 0; i < 16; i++) {\n\t\tif (!(units & (1 << i)))\n\t\t\tcontinue;\n\n\t\tif (device->chipset < 0xa0) {\n\t\t\tnvkm_wr32(device, 0x408900 + (i << 12), 0xc0000000);\n\t\t\tnvkm_wr32(device, 0x408e08 + (i << 12), 0xc0000000);\n\t\t\tnvkm_wr32(device, 0x408314 + (i << 12), 0xc0000000);\n\t\t} else {\n\t\t\tnvkm_wr32(device, 0x408600 + (i << 11), 0xc0000000);\n\t\t\tnvkm_wr32(device, 0x408708 + (i << 11), 0xc0000000);\n\t\t\tnvkm_wr32(device, 0x40831c + (i << 11), 0xc0000000);\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x400108, 0xffffffff);\n\tnvkm_wr32(device, 0x400138, 0xffffffff);\n\tnvkm_wr32(device, 0x400100, 0xffffffff);\n\tnvkm_wr32(device, 0x40013c, 0xffffffff);\n\tnvkm_wr32(device, 0x400500, 0x00010001);\n\n\t \n\tret = nv50_grctx_init(device, &gr->size);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_wr32(device, 0x400824, 0x00000000);\n\tnvkm_wr32(device, 0x400828, 0x00000000);\n\tnvkm_wr32(device, 0x40082c, 0x00000000);\n\tnvkm_wr32(device, 0x400830, 0x00000000);\n\tnvkm_wr32(device, 0x40032c, 0x00000000);\n\tnvkm_wr32(device, 0x400330, 0x00000000);\n\n\t \n\tswitch (device->chipset & 0xf0) {\n\tcase 0x50:\n\tcase 0x80:\n\tcase 0x90:\n\t\tnvkm_wr32(device, 0x402ca8, 0x00000800);\n\t\tbreak;\n\tcase 0xa0:\n\tdefault:\n\t\tif (device->chipset == 0xa0 ||\n\t\t    device->chipset == 0xaa ||\n\t\t    device->chipset == 0xac) {\n\t\t\tnvkm_wr32(device, 0x402ca8, 0x00000802);\n\t\t} else {\n\t\t\tnvkm_wr32(device, 0x402cc0, 0x00000000);\n\t\t\tnvkm_wr32(device, 0x402ca8, 0x00000002);\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\tnvkm_wr32(device, 0x402c20 + (i * 0x10), 0x00000000);\n\t\tnvkm_wr32(device, 0x402c24 + (i * 0x10), 0x00000000);\n\t\tnvkm_wr32(device, 0x402c28 + (i * 0x10), 0x00000000);\n\t\tnvkm_wr32(device, 0x402c2c + (i * 0x10), 0x00000000);\n\t}\n\n\treturn 0;\n}\n\nint\nnv50_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\tstruct nv50_gr *gr;\n\n\tif (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tspin_lock_init(&gr->lock);\n\t*pgr = &gr->base;\n\n\treturn nvkm_gr_ctor(func, device, type, inst, true, &gr->base);\n}\n\nstatic const struct nvkm_gr_func\nnv50_gr = {\n\t.init = nv50_gr_init,\n\t.intr = nv50_gr_intr,\n\t.chan_new = nv50_gr_chan_new,\n\t.units = nv50_gr_units,\n\t.sclass = {\n\t\t{ -1, -1, NV_NULL_CLASS, &nv50_gr_object },\n\t\t{ -1, -1, NV50_TWOD, &nv50_gr_object },\n\t\t{ -1, -1, NV50_MEMORY_TO_MEMORY_FORMAT, &nv50_gr_object },\n\t\t{ -1, -1, NV50_TESLA, &nv50_gr_object },\n\t\t{ -1, -1, NV50_COMPUTE, &nv50_gr_object },\n\t\t{}\n\t}\n};\n\nint\nnv50_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn nv50_gr_new_(&nv50_gr, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}