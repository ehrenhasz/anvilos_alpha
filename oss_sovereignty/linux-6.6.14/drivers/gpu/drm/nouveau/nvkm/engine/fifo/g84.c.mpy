{
  "module_name": "g84.c",
  "hash_id": "2156e78891e4c43c70745f0778d58ef1f966726b5593f2622f0c40764e3e3ebe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/g84.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"runl.h\"\n\n#include <core/ramht.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstatic void\ng84_chan_bind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x002600 + (chan->id * 4), chan->ramfc->addr >> 8);\n}\n\nstatic int\ng84_chan_ramfc_write(struct nvkm_chan *chan, u64 offset, u64 length, u32 devm, bool priv)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\tconst u32 limit2 = ilog2(length / 8);\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 0x0200, 0, true, chan->inst, &chan->eng);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 0x4000, 0, false, chan->inst, &chan->pgd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 0x1000, 0x400, true, chan->inst, &chan->cache);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 0x100, 0x100, true, chan->inst, &chan->ramfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_ramht_new(device, 0x8000, 16, chan->inst, &chan->ramht);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_kmap(chan->ramfc);\n\tnvkm_wo32(chan->ramfc, 0x3c, 0x403f6078);\n\tnvkm_wo32(chan->ramfc, 0x44, 0x01003fff);\n\tnvkm_wo32(chan->ramfc, 0x48, chan->push->node->offset >> 4);\n\tnvkm_wo32(chan->ramfc, 0x50, lower_32_bits(offset));\n\tnvkm_wo32(chan->ramfc, 0x54, upper_32_bits(offset) | (limit2 << 16));\n\tnvkm_wo32(chan->ramfc, 0x60, 0x7fffffff);\n\tnvkm_wo32(chan->ramfc, 0x78, 0x00000000);\n\tnvkm_wo32(chan->ramfc, 0x7c, 0x30000000 | devm);\n\tnvkm_wo32(chan->ramfc, 0x80, ((chan->ramht->bits - 9) << 27) |\n\t\t\t\t     (4 << 24)   |\n\t\t\t\t     (chan->ramht->gpuobj->node->offset >> 4));\n\tnvkm_wo32(chan->ramfc, 0x88, chan->cache->addr >> 10);\n\tnvkm_wo32(chan->ramfc, 0x98, chan->inst->addr >> 12);\n\tnvkm_done(chan->ramfc);\n\treturn 0;\n}\n\nstatic const struct nvkm_chan_func_ramfc\ng84_chan_ramfc = {\n\t.write = g84_chan_ramfc_write,\n\t.ctxdma = true,\n\t.devm = 0xfff,\n};\n\nconst struct nvkm_chan_func\ng84_chan = {\n\t.inst = &nv50_chan_inst,\n\t.userd = &nv50_chan_userd,\n\t.ramfc = &g84_chan_ramfc,\n\t.bind = g84_chan_bind,\n\t.unbind = nv50_chan_unbind,\n\t.start = nv50_chan_start,\n\t.stop = nv50_chan_stop,\n};\n\nstatic void\ng84_ectx_bind(struct nvkm_engn *engn, struct nvkm_cctx *cctx, struct nvkm_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->cgrp->runl->fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu64 start = 0, limit = 0;\n\tu32 flags = 0, ptr0, save;\n\n\tswitch (engn->engine->subdev.type) {\n\tcase NVKM_ENGINE_GR    : ptr0 = 0x0020; break;\n\tcase NVKM_ENGINE_VP    :\n\tcase NVKM_ENGINE_MSPDEC: ptr0 = 0x0040; break;\n\tcase NVKM_ENGINE_MPEG  :\n\tcase NVKM_ENGINE_MSPPP : ptr0 = 0x0060; break;\n\tcase NVKM_ENGINE_BSP   :\n\tcase NVKM_ENGINE_MSVLD : ptr0 = 0x0080; break;\n\tcase NVKM_ENGINE_CIPHER:\n\tcase NVKM_ENGINE_SEC   : ptr0 = 0x00a0; break;\n\tcase NVKM_ENGINE_CE    : ptr0 = 0x00c0; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (!cctx) {\n\t\tsave = nvkm_mask(device, 0x002520, 0x0000003f, BIT(engn->id - 1));\n\t\tnvkm_wr32(device, 0x0032fc, chan->inst->addr >> 12);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (nvkm_rd32(device, 0x0032fc) != 0xffffffff)\n\t\t\t\tbreak;\n\t\t);\n\t\tnvkm_wr32(device, 0x002520, save);\n\t} else {\n\t\tflags = 0x00190000;\n\t\tstart = cctx->vctx->inst->addr;\n\t\tlimit = start + cctx->vctx->inst->size - 1;\n\t}\n\n\tnvkm_kmap(chan->eng);\n\tnvkm_wo32(chan->eng, ptr0 + 0x00, flags);\n\tnvkm_wo32(chan->eng, ptr0 + 0x04, lower_32_bits(limit));\n\tnvkm_wo32(chan->eng, ptr0 + 0x08, lower_32_bits(start));\n\tnvkm_wo32(chan->eng, ptr0 + 0x0c, upper_32_bits(limit) << 24 |\n\t\t\t\t\t  lower_32_bits(start));\n\tnvkm_wo32(chan->eng, ptr0 + 0x10, 0x00000000);\n\tnvkm_wo32(chan->eng, ptr0 + 0x14, 0x00000000);\n\tnvkm_done(chan->eng);\n}\n\nconst struct nvkm_engn_func\ng84_engn = {\n\t.bind = g84_ectx_bind,\n\t.ramht_add = nv50_eobj_ramht_add,\n\t.ramht_del = nv50_eobj_ramht_del,\n};\n\nstatic void\ng84_fifo_nonstall_block(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fifo *fifo = container_of(event, typeof(*fifo), nonstall.event);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fifo->lock, flags);\n\tnvkm_mask(fifo->engine.subdev.device, 0x002140, 0x40000000, 0x00000000);\n\tspin_unlock_irqrestore(&fifo->lock, flags);\n}\n\nstatic void\ng84_fifo_nonstall_allow(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fifo *fifo = container_of(event, typeof(*fifo), nonstall.event);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fifo->lock, flags);\n\tnvkm_mask(fifo->engine.subdev.device, 0x002140, 0x40000000, 0x40000000);\n\tspin_unlock_irqrestore(&fifo->lock, flags);\n}\n\nconst struct nvkm_event_func\ng84_fifo_nonstall = {\n\t.init = g84_fifo_nonstall_allow,\n\t.fini = g84_fifo_nonstall_block,\n};\n\nstatic int\ng84_fifo_runl_ctor(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_runl *runl;\n\n\trunl = nvkm_runl_new(fifo, 0, 0, 0);\n\tif (IS_ERR(runl))\n\t\treturn PTR_ERR(runl);\n\n\tnvkm_runl_add(runl, 0, fifo->func->engn_sw, NVKM_ENGINE_SW, 0);\n\tnvkm_runl_add(runl, 0, fifo->func->engn_sw, NVKM_ENGINE_DMAOBJ, 0);\n\tnvkm_runl_add(runl, 1, fifo->func->engn, NVKM_ENGINE_GR, 0);\n\tnvkm_runl_add(runl, 2, fifo->func->engn, NVKM_ENGINE_MPEG, 0);\n\tnvkm_runl_add(runl, 3, fifo->func->engn, NVKM_ENGINE_ME, 0);\n\tnvkm_runl_add(runl, 4, fifo->func->engn, NVKM_ENGINE_VP, 0);\n\tnvkm_runl_add(runl, 5, fifo->func->engn, NVKM_ENGINE_CIPHER, 0);\n\tnvkm_runl_add(runl, 6, fifo->func->engn, NVKM_ENGINE_BSP, 0);\n\treturn 0;\n}\n\nstatic const struct nvkm_fifo_func\ng84_fifo = {\n\t.chid_nr = nv50_fifo_chid_nr,\n\t.chid_ctor = nv50_fifo_chid_ctor,\n\t.runl_ctor = g84_fifo_runl_ctor,\n\t.init = nv50_fifo_init,\n\t.intr = nv04_fifo_intr,\n\t.pause = nv04_fifo_pause,\n\t.start = nv04_fifo_start,\n\t.nonstall = &g84_fifo_nonstall,\n\t.runl = &nv50_runl,\n\t.engn = &g84_engn,\n\t.engn_sw = &nv50_engn_sw,\n\t.cgrp = {{                          }, &nv04_cgrp },\n\t.chan = {{ 0, 0, G82_CHANNEL_GPFIFO }, &g84_chan },\n};\n\nint\ng84_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t     struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&g84_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}