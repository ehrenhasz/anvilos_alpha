{
  "module_name": "usergv100.c",
  "hash_id": "5fc6e21dd7c9163faaa64ab78098f0df5b861e508c810164c23200a6e77f513c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/dma/usergv100.c",
  "human_readable_source": " \n#define gv100_dmaobj(p) container_of((p), struct gv100_dmaobj, base)\n#include \"user.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n\n#include <nvif/cl0002.h>\n#include <nvif/unpack.h>\n\nstruct gv100_dmaobj {\n\tstruct nvkm_dmaobj base;\n\tu32 flags0;\n};\n\nstatic int\ngv100_dmaobj_bind(struct nvkm_dmaobj *base, struct nvkm_gpuobj *parent,\n\t\t  int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct gv100_dmaobj *dmaobj = gv100_dmaobj(base);\n\tstruct nvkm_device *device = dmaobj->base.dma->engine.subdev.device;\n\tu64 start = dmaobj->base.start >> 8;\n\tu64 limit = dmaobj->base.limit >> 8;\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 24, align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, dmaobj->flags0);\n\t\tnvkm_wo32(*pgpuobj, 0x04, lower_32_bits(start));\n\t\tnvkm_wo32(*pgpuobj, 0x08, upper_32_bits(start));\n\t\tnvkm_wo32(*pgpuobj, 0x0c, lower_32_bits(limit));\n\t\tnvkm_wo32(*pgpuobj, 0x10, upper_32_bits(limit));\n\t\tnvkm_done(*pgpuobj);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nvkm_dmaobj_func\ngv100_dmaobj_func = {\n\t.bind = gv100_dmaobj_bind,\n};\n\nint\ngv100_dmaobj_new(struct nvkm_dma *dma, const struct nvkm_oclass *oclass,\n\t\t void *data, u32 size, struct nvkm_dmaobj **pdmaobj)\n{\n\tunion {\n\t\tstruct gf119_dma_v0 v0;\n\t} *args;\n\tstruct nvkm_object *parent = oclass->parent;\n\tstruct gv100_dmaobj *dmaobj;\n\tu32 kind, page;\n\tint ret;\n\n\tif (!(dmaobj = kzalloc(sizeof(*dmaobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pdmaobj = &dmaobj->base;\n\n\tret = nvkm_dmaobj_ctor(&gv100_dmaobj_func, dma, oclass,\n\t\t\t       &data, &size, &dmaobj->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret  = -ENOSYS;\n\targs = data;\n\n\tnvif_ioctl(parent, \"create gv100 dma size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(parent,\n\t\t\t   \"create gv100 dma vers %d page %d kind %02x\\n\",\n\t\t\t   args->v0.version, args->v0.page, args->v0.kind);\n\t\tkind = args->v0.kind != 0;\n\t\tpage = args->v0.page != 0;\n\t} else\n\tif (size == 0) {\n\t\tkind = 0;\n\t\tpage = GF119_DMA_V0_PAGE_SP;\n\t} else\n\t\treturn ret;\n\n\tif (kind)\n\t\tdmaobj->flags0 |= 0x00100000;\n\tif (page)\n\t\tdmaobj->flags0 |= 0x00000040;\n\tdmaobj->flags0 |= 0x00000004;  \n\n\tswitch (dmaobj->base.target) {\n\tcase NV_MEM_TARGET_VRAM       : dmaobj->flags0 |= 0x00000001; break;\n\tcase NV_MEM_TARGET_PCI        : dmaobj->flags0 |= 0x00000002; break;\n\tcase NV_MEM_TARGET_PCI_NOSNOOP: dmaobj->flags0 |= 0x00000003; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}