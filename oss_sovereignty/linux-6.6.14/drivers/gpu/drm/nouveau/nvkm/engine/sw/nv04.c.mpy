{
  "module_name": "nv04.c",
  "hash_id": "21324e63bc8fe145ada95b3ddd9ccb43488f798ced2a2a69a7e4df79101df66b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/sw/nv04.c",
  "human_readable_source": " \n#define nv04_sw_chan(p) container_of((p), struct nv04_sw_chan, base)\n#include \"priv.h\"\n#include \"chan.h\"\n#include \"nvsw.h\"\n\n#include <nvif/class.h>\n#include <nvif/if0004.h>\n#include <nvif/ioctl.h>\n#include <nvif/unpack.h>\n\nstruct nv04_sw_chan {\n\tstruct nvkm_sw_chan base;\n\tatomic_t ref;\n};\n\n \n\nstatic int\nnv04_nvsw_mthd_get_ref(struct nvkm_nvsw *nvsw, void *data, u32 size)\n{\n\tstruct nv04_sw_chan *chan = nv04_sw_chan(nvsw->chan);\n\tunion {\n\t\tstruct nv04_nvsw_get_ref_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\targs->v0.ref = atomic_read(&chan->ref);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnv04_nvsw_mthd(struct nvkm_nvsw *nvsw, u32 mthd, void *data, u32 size)\n{\n\tswitch (mthd) {\n\tcase NV04_NVSW_GET_REF:\n\t\treturn nv04_nvsw_mthd_get_ref(nvsw, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct nvkm_nvsw_func\nnv04_nvsw = {\n\t.mthd = nv04_nvsw_mthd,\n};\n\nstatic int\nnv04_nvsw_new(struct nvkm_sw_chan *chan, const struct nvkm_oclass *oclass,\n\t      void *data, u32 size, struct nvkm_object **pobject)\n{\n\treturn nvkm_nvsw_new_(&nv04_nvsw, chan, oclass, data, size, pobject);\n}\n\n \n\nstatic bool\nnv04_sw_chan_mthd(struct nvkm_sw_chan *base, int subc, u32 mthd, u32 data)\n{\n\tstruct nv04_sw_chan *chan = nv04_sw_chan(base);\n\n\tswitch (mthd) {\n\tcase 0x0150:\n\t\tatomic_set(&chan->ref, data);\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic const struct nvkm_sw_chan_func\nnv04_sw_chan = {\n\t.mthd = nv04_sw_chan_mthd,\n};\n\nstatic int\nnv04_sw_chan_new(struct nvkm_sw *sw, struct nvkm_chan *fifo,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object **pobject)\n{\n\tstruct nv04_sw_chan *chan;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tatomic_set(&chan->ref, 0);\n\t*pobject = &chan->base.object;\n\n\treturn nvkm_sw_chan_ctor(&nv04_sw_chan, sw, fifo, oclass, &chan->base);\n}\n\n \n\nstatic const struct nvkm_sw_func\nnv04_sw = {\n\t.chan_new = nv04_sw_chan_new,\n\t.sclass = {\n\t\t{ nv04_nvsw_new, { -1, -1, NVIF_CLASS_SW_NV04 } },\n\t\t{}\n\t}\n};\n\nint\nnv04_sw_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_sw **psw)\n{\n\treturn nvkm_sw_new_(&nv04_sw, device, type, inst, psw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}