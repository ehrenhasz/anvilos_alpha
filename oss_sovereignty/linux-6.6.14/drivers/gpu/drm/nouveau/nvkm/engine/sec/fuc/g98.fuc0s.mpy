{
  "module_name": "g98.fuc0s",
  "hash_id": "113924382519b582693064c099534ac5b82003881a775ce61a0034642b46ac94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/sec/fuc/g98.fuc0s",
  "human_readable_source": "/*\n *  fuc microcode for g98 sec engine\n *  Copyright (C) 2010  Marcin Ko\u015bcielnicki\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n.section #g98_sec_data\n\nctx_dma:\nctx_dma_query:\t\t.b32 0\nctx_dma_src:\t\t.b32 0\nctx_dma_dst:\t\t.b32 0\n.equ #dma_count 3\nctx_query_address_high:\t.b32 0\nctx_query_address_low:\t.b32 0\nctx_query_counter:\t.b32 0\nctx_cond_address_high:\t.b32 0\nctx_cond_address_low:\t.b32 0\nctx_cond_off:\t\t.b32 0\nctx_src_address_high:\t.b32 0\nctx_src_address_low:\t.b32 0\nctx_dst_address_high:\t.b32 0\nctx_dst_address_low:\t.b32 0\nctx_mode:\t\t.b32 0\n.align 16\nctx_key:\t\t.skip 16\nctx_iv:\t\t\t.skip 16\n\n.align 0x80\nswap:\n.skip 32\n\n.align 8\ncommon_cmd_dtable:\n.b32 #ctx_query_address_high + 0x20000 ~0xff\n.b32 #ctx_query_address_low + 0x20000 ~0xfffffff0\n.b32 #ctx_query_counter + 0x20000 ~0xffffffff\n.b32 #cmd_query_get + 0x00000 ~1\n.b32 #ctx_cond_address_high + 0x20000 ~0xff\n.b32 #ctx_cond_address_low + 0x20000 ~0xfffffff0\n.b32 #cmd_cond_mode + 0x00000 ~7\n.b32 #cmd_wrcache_flush + 0x00000 ~0\n.equ #common_cmd_max 0x88\n\n\n.align 8\nengine_cmd_dtable:\n.b32 #ctx_key + 0x0 + 0x20000 ~0xffffffff\n.b32 #ctx_key + 0x4 + 0x20000 ~0xffffffff\n.b32 #ctx_key + 0x8 + 0x20000 ~0xffffffff\n.b32 #ctx_key + 0xc + 0x20000 ~0xffffffff\n.b32 #ctx_iv + 0x0 + 0x20000 ~0xffffffff\n.b32 #ctx_iv + 0x4 + 0x20000 ~0xffffffff\n.b32 #ctx_iv + 0x8 + 0x20000 ~0xffffffff\n.b32 #ctx_iv + 0xc + 0x20000 ~0xffffffff\n.b32 #ctx_src_address_high + 0x20000 ~0xff\n.b32 #ctx_src_address_low + 0x20000 ~0xfffffff0\n.b32 #ctx_dst_address_high + 0x20000 ~0xff\n.b32 #ctx_dst_address_low + 0x20000 ~0xfffffff0\n.b32 #sec_cmd_mode + 0x00000 ~0xf\n.b32 #sec_cmd_length + 0x10000 ~0x0ffffff0\n.equ #engine_cmd_max 0xce\n\n.align 4\nsec_dtable:\n.b16 #sec_copy_prep #sec_do_inout\n.b16 #sec_store_prep #sec_do_out\n.b16 #sec_ecb_e_prep #sec_do_inout\n.b16 #sec_ecb_d_prep #sec_do_inout\n.b16 #sec_cbc_e_prep #sec_do_inout\n.b16 #sec_cbc_d_prep #sec_do_inout\n.b16 #sec_pcbc_e_prep #sec_do_inout\n.b16 #sec_pcbc_d_prep #sec_do_inout\n.b16 #sec_cfb_e_prep #sec_do_inout\n.b16 #sec_cfb_d_prep #sec_do_inout\n.b16 #sec_ofb_prep #sec_do_inout\n.b16 #sec_ctr_prep #sec_do_inout\n.b16 #sec_cbc_mac_prep #sec_do_in\n.b16 #sec_cmac_finish_complete_prep #sec_do_in\n.b16 #sec_cmac_finish_partial_prep #sec_do_in\n\n.align 0x100\n\n.section #g98_sec_code\n\n\t// $r0 is always set to 0 in our code - this allows some space savings.\n\tclear b32 $r0\n\n\t// set up the interrupt handler\n\tmov $r1 #ih\n\tmov $iv0 $r1\n\n\t// init stack pointer\n\tmov $sp $r0\n\n\t// set interrupt dispatch - route timer, fifo, ctxswitch to i0, others to host\n\tmovw $r1 0xfff0\n\tsethi $r1 0\n\tmov $r2 0x400\n\tiowr I[$r2 + 0x300] $r1\n\n\t// enable the interrupts\n\tor $r1 0xc\n\tiowr I[$r2] $r1\n\n\t// enable fifo access and context switching\n\tmov $r1 3\n\tmov $r2 0x1200\n\tiowr I[$r2] $r1\n\n\t// enable i0 delivery\n\tbset $flags ie0\n\n\t// sleep forver, waking only for interrupts.\n\tbset $flags $p0\n\tspin:\n\tsleep $p0\n\tbra #spin\n\n// i0 handler\nih:\n\t// see which interrupts we got\n\tiord $r1 I[$r0 + 0x200]\n\n\tand $r2 $r1 0x8\n\tcmpu b32 $r2 0\n\tbra e #noctx\n\n\t\t// context switch... prepare the regs for xfer\n\t\tmov $r2 0x7700\n\t\tmov $xtargets $r2\n\t\tmov $xdbase $r0\n\t\t// 128-byte context.\n\t\tmov $r2 0\n\t\tsethi $r2 0x50000\n\n\t\t// read current channel\n\t\tmov $r3 0x1400\n\t\tiord $r4 I[$r3]\n\t\t// if bit 30 set, it's active, so we have to unload it first.\n\t\tshl b32 $r5 $r4 1\n\t\tcmps b32 $r5 0\n\t\tbra nc #ctxload\n\n\t\t\t// unload the current channel - save the context\n\t\t\txdst $r0 $r2\n\t\t\txdwait\n\t\t\t// and clear bit 30, then write back\n\t\t\tbclr $r4 0x1e\n\t\t\tiowr I[$r3] $r4\n\t\t\t// tell PFIFO we unloaded\n\t\t\tmov $r4 1\n\t\t\tiowr I[$r3 + 0x200] $r4\n\n\t\tbra #noctx\n\n\t\tctxload:\n\t\t\t// no channel loaded - perhaps we're requested to load one\n\t\t\tiord $r4 I[$r3 + 0x100]\n\t\t\tshl b32 $r15 $r4 1\n\t\t\tcmps b32 $r15 0\n\t\t\t// if bit 30 of next channel not set, probably PFIFO is just\n\t\t\t// killing a context. do a faux load, without the active bit.\n\t\t\tbra nc #dummyload\n\n\t\t\t\t// ok, do a real context load.\n\t\t\t\txdld $r0 $r2\n\t\t\t\txdwait\n\t\t\t\tmov $r5 #ctx_dma\n\t\t\t\tmov $r6 #dma_count - 1\n\t\t\t\tctxload_dma_loop:\n\t\t\t\t\tld b32 $r7 D[$r5 + $r6 * 4]\n\t\t\t\t\tadd b32 $r8 $r6 0x180\n\t\t\t\t\tshl b32 $r8 8\n\t\t\t\t\tiowr I[$r8] $r7\n\t\t\t\t\tsub b32 $r6 1\n\t\t\t\tbra nc #ctxload_dma_loop\n\n\t\t\tdummyload:\n\t\t\t// tell PFIFO we're done\n\t\t\tmov $r5 2\n\t\t\tiowr I[$r3 + 0x200] $r5\n\n\tnoctx:\n\tand $r2 $r1 0x4\n\tcmpu b32 $r2 0\n\tbra e #nocmd\n\n\t\t// incoming fifo command.\n\t\tmov $r3 0x1900\n\t\tiord $r2 I[$r3 + 0x100]\n\t\tiord $r3 I[$r3]\n\t\t// extract the method\n\t\tand $r4 $r2 0x7ff\n\t\t// shift the addr to proper position if we need to interrupt later\n\t\tshl b32 $r2 0x10\n\n\t\t// mthd 0 and 0x100 [NAME, NOP]: ignore\n\t\tand $r5 $r4 0x7bf\n\t\tcmpu b32 $r5 0\n\t\tbra e #cmddone\n\n\t\tmov $r5 #engine_cmd_dtable - 0xc0 * 8\n\t\tmov $r6 #engine_cmd_max\n\t\tcmpu b32 $r4 0xc0\n\t\tbra nc #dtable_cmd\n\t\tmov $r5 #common_cmd_dtable - 0x80 * 8\n\t\tmov $r6 #common_cmd_max\n\t\tcmpu b32 $r4 0x80\n\t\tbra nc #dtable_cmd\n\t\tcmpu b32 $r4 0x60\n\t\tbra nc #dma_cmd\n\t\tcmpu b32 $r4 0x50\n\t\tbra ne #illegal_mthd\n\n\t\t\t// mthd 0x140: PM_TRIGGER\n\t\t\tmov $r2 0x2200\n\t\t\tclear b32 $r3\n\t\t\tsethi $r3 0x20000\n\t\t\tiowr I[$r2] $r3\n\t\t\tbra #cmddone\n\n\t\tdma_cmd:\n\t\t\t// mthd 0x180...: DMA_*\n\t\t\tcmpu b32 $r4 0x60+#dma_count\n\t\t\tbra nc #illegal_mthd\n\t\t\tshl b32 $r5 $r4 2\n\t\t\tadd b32 $r5 ((#ctx_dma - 0x60 * 4) & 0xffff)\n\t\t\tbset $r3 0x1e\n\t\t\tst b32 D[$r5] $r3\n\t\t\tadd b32 $r4 0x180 - 0x60\n\t\t\tshl b32 $r4 8\n\t\t\tiowr I[$r4] $r3\n\t\t\tbra #cmddone\n\n\t\tdtable_cmd:\n\t\t\tcmpu b32 $r4 $r6\n\t\t\tbra nc #illegal_mthd\n\t\t\tshl b32 $r4 3\n\t\t\tadd b32 $r4 $r5\n\t\t\tld b32 $r5 D[$r4 + 4]\n\t\t\tand $r5 $r3\n\t\t\tcmpu b32 $r5 0\n\t\t\tbra ne #invalid_bitfield\n\t\t\tld b16 $r5 D[$r4]\n\t\t\tld b16 $r6 D[$r4 + 2]\n\t\t\tcmpu b32 $r6 2\n\t\t\tbra e #cmd_setctx\n\t\t\tld b32 $r7 D[$r0 + #ctx_cond_off]\n\t\t\tand $r6 $r7\n\t\t\tcmpu b32 $r6 1\n\t\t\tbra e #cmddone\n\t\t\tcall $r5\n\t\t\tbra $p1 #dispatch_error\n\t\t\tbra #cmddone\n\n\t\tcmd_setctx:\n\t\t\tst b32 D[$r5] $r3\n\t\t\tbra #cmddone\n\n\n\t\tinvalid_bitfield:\n\t\t\tor $r2 1\n\t\tdispatch_error:\n\t\tillegal_mthd:\n\t\t\tmov $r4 0x1000\n\t\t\tiowr I[$r4] $r2\n\t\t\tiowr I[$r4 + 0x100] $r3\n\t\t\tmov $r4 0x40\n\t\t\tiowr I[$r0] $r4\n\n\t\t\tim_loop:\n\t\t\t\tiord $r4 I[$r0 + 0x200]\n\t\t\t\tand $r4 0x40\n\t\t\t\tcmpu b32 $r4 0\n\t\t\tbra ne #im_loop\n\n\t\tcmddone:\n\t\t// remove the command from FIFO\n\t\tmov $r3 0x1d00\n\t\tmov $r4 1\n\t\tiowr I[$r3] $r4\n\n\tnocmd:\n\t// ack the processed interrupts\n\tand $r1 $r1 0xc\n\tiowr I[$r0 + 0x100] $r1\niret\n\ncmd_query_get:\n\t// if bit 0 of param set, trigger interrupt afterwards.\n\tsetp $p1 $r3\n\tor $r2 3\n\n\t// read PTIMER, beware of races...\n\tmov $r4 0xb00\n\tptimer_retry:\n\t\tiord $r6 I[$r4 + 0x100]\n\t\tiord $r5 I[$r4]\n\t\tiord $r7 I[$r4 + 0x100]\n\t\tcmpu b32 $r6 $r7\n\tbra ne #ptimer_retry\n\n\t// prepare the query structure\n\tld b32 $r4 D[$r0 + #ctx_query_counter]\n\tst b32 D[$r0 + #swap + 0x0] $r4\n\tst b32 D[$r0 + #swap + 0x4] $r0\n\tst b32 D[$r0 + #swap + 0x8] $r5\n\tst b32 D[$r0 + #swap + 0xc] $r6\n\n\t// will use target 0, DMA_QUERY.\n\tmov $xtargets $r0\n\n\tld b32 $r4 D[$r0 + #ctx_query_address_high]\n\tshl b32 $r4 0x18\n\tmov $xdbase $r4\n\n\tld b32 $r4 D[$r0 + #ctx_query_address_low]\n\tmov $r5 #swap\n\tsethi $r5 0x20000\n\txdst $r4 $r5\n\txdwait\n\n\tret\n\ncmd_cond_mode:\n\t// if >= 5, INVALID_ENUM\n\tbset $flags $p1\n\tor $r2 2\n\tcmpu b32 $r3 5\n\tbra nc #return\n\n\t// otherwise, no error.\n\tbclr $flags $p1\n\n\t// if < 2, no QUERY object is involved\n\tcmpu b32 $r3 2\n\tbra nc #cmd_cond_mode_queryful\n\n\t\txor $r3 1\n\t\tst b32 D[$r0 + #ctx_cond_off] $r3\n\treturn:\n\t\tret\n\n\tcmd_cond_mode_queryful:\n\t// ok, will need to pull a QUERY object, prepare offsets\n\tld b32 $r4 D[$r0 + #ctx_cond_address_high]\n\tld b32 $r5 D[$r0 + #ctx_cond_address_low]\n\tand $r6 $r5 0xff\n\tshr b32 $r5 8\n\tshl b32 $r4 0x18\n\tor $r4 $r5\n\tmov $xdbase $r4\n\tmov $xtargets $r0\n\n\t// pull the first one\n\tmov $r5 #swap\n\tsethi $r5 0x20000\n\txdld $r6 $r5\n\n\t// if == 2, only a single QUERY is involved...\n\tcmpu b32 $r3 2\n\tbra ne #cmd_cond_mode_double\n\n\t\txdwait\n\t\tld b32 $r4 D[$r0 + #swap + 4]\n\t\tcmpu b32 $r4 0\n\t\txbit $r4 $flags z\n\t\tst b32 D[$r0 + #ctx_cond_off] $r4\n\t\tret\n\n\t// ok, we'll need to pull second one too\n\tcmd_cond_mode_double:\n\tadd b32 $r6 0x10\n\tadd b32 $r5 0x10\n\txdld $r6 $r5\n\txdwait\n\n\t// compare COUNTERs\n\tld b32 $r5 D[$r0 + #swap + 0x00]\n\tld b32 $r6 D[$r0 + #swap + 0x10]\n\tcmpu b32 $r5 $r6\n\txbit $r4 $flags z\n\n\t// compare RESen\n\tld b32 $r5 D[$r0 + #swap + 0x04]\n\tld b32 $r6 D[$r0 + #swap + 0x14]\n\tcmpu b32 $r5 $r6\n\txbit $r5 $flags z\n\tand $r4 $r5\n\n\t// and negate or not, depending on mode\n\tcmpu b32 $r3 3\n\txbit $r5 $flags z\n\txor $r4 $r5\n\tst b32 D[$r0 + #ctx_cond_off] $r4\n\tret\n\ncmd_wrcache_flush:\n\tbclr $flags $p1\n\tmov $r2 0x2200\n\tclear b32 $r3\n\tsethi $r3 0x10000\n\tiowr I[$r2] $r3\n\tret\n\nsec_cmd_mode:\n\t// if >= 0xf, INVALID_ENUM\n\tbset $flags $p1\n\tor $r2 2\n\tcmpu b32 $r3 0xf\n\tbra nc #sec_cmd_mode_return\n\n\t\tbclr $flags $p1\n\t\tst b32 D[$r0 + #ctx_mode] $r3\n\n\tsec_cmd_mode_return:\n\tret\n\nsec_cmd_length:\n\t// nop if length == 0\n\tcmpu b32 $r3 0\n\tbra e #sec_cmd_mode_return\n\n\t// init key, IV\n\tcxset 3\n\tmov $r4 #ctx_key\n\tsethi $r4 0x70000\n\txdst $r0 $r4\n\tmov $r4 #ctx_iv\n\tsethi $r4 0x60000\n\txdst $r0 $r4\n\txdwait\n\tckeyreg $c7\n\n\t// prepare the targets\n\tmov $r4 0x2100\n\tmov $xtargets $r4\n\n\t// prepare src address\n\tld b32 $r4 D[$r0 + #ctx_src_address_high]\n\tld b32 $r5 D[$r0 + #ctx_src_address_low]\n\tshr b32 $r8 $r5 8\n\tshl b32 $r4 0x18\n\tor $r4 $r8\n\tand $r5 $r5 0xff\n\n\t// prepare dst address\n\tld b32 $r6 D[$r0 + #ctx_dst_address_high]\n\tld b32 $r7 D[$r0 + #ctx_dst_address_low]\n\tshr b32 $r8 $r7 8\n\tshl b32 $r6 0x18\n\tor $r6 $r8\n\tand $r7 $r7 0xff\n\n\t// find the proper prep & do functions\n\tld b32 $r8 D[$r0 + #ctx_mode]\n\tshl b32 $r8 2\n\n\t// run prep\n\tld b16 $r9 D[$r8 + #sec_dtable]\n\tcall $r9\n\n\t// do it\n\tld b16 $r9 D[$r8 + #sec_dtable + 2]\n\tcall $r9\n\tcxset 1\n\txdwait\n\tcxset 0x61\n\txdwait\n\txdwait\n\n\t// update src address\n\tshr b32 $r8 $r4 0x18\n\tshl b32 $r9 $r4 8\n\tadd b32 $r9 $r5\n\tadc b32 $r8 0\n\tst b32 D[$r0 + #ctx_src_address_high] $r8\n\tst b32 D[$r0 + #ctx_src_address_low] $r9\n\n\t// update dst address\n\tshr b32 $r8 $r6 0x18\n\tshl b32 $r9 $r6 8\n\tadd b32 $r9 $r7\n\tadc b32 $r8 0\n\tst b32 D[$r0 + #ctx_dst_address_high] $r8\n\tst b32 D[$r0 + #ctx_dst_address_low] $r9\n\n\t// pull updated IV\n\tcxset 2\n\tmov $r4 #ctx_iv\n\tsethi $r4 0x60000\n\txdld $r0 $r4\n\txdwait\n\n\tret\n\n\nsec_copy_prep:\n\tcs0begin 2\n\t\tcxsin $c0\n\t\tcxsout $c0\n\tret\n\nsec_store_prep:\n\tcs0begin 1\n\t\tcxsout $c6\n\tret\n\nsec_ecb_e_prep:\n\tcs0begin 3\n\t\tcxsin $c0\n\t\tcenc $c0 $c0\n\t\tcxsout $c0\n\tret\n\nsec_ecb_d_prep:\n\tckexp $c7 $c7\n\tcs0begin 3\n\t\tcxsin $c0\n\t\tcdec $c0 $c0\n\t\tcxsout $c0\n\tret\n\nsec_cbc_e_prep:\n\tcs0begin 4\n\t\tcxsin $c0\n\t\tcxor $c6 $c0\n\t\tcenc $c6 $c6\n\t\tcxsout $c6\n\tret\n\nsec_cbc_d_prep:\n\tckexp $c7 $c7\n\tcs0begin 5\n\t\tcmov $c2 $c6\n\t\tcxsin $c6\n\t\tcdec $c0 $c6\n\t\tcxor $c0 $c2\n\t\tcxsout $c0\n\tret\n\nsec_pcbc_e_prep:\n\tcs0begin 5\n\t\tcxsin $c0\n\t\tcxor $c6 $c0\n\t\tcenc $c6 $c6\n\t\tcxsout $c6\n\t\tcxor $c6 $c0\n\tret\n\nsec_pcbc_d_prep:\n\tckexp $c7 $c7\n\tcs0begin 5\n\t\tcxsin $c0\n\t\tcdec $c1 $c0\n\t\tcxor $c6 $c1\n\t\tcxsout $c6\n\t\tcxor $c6 $c0\n\tret\n\nsec_cfb_e_prep:\n\tcs0begin 4\n\t\tcenc $c6 $c6\n\t\tcxsin $c0\n\t\tcxor $c6 $c0\n\t\tcxsout $c6\n\tret\n\nsec_cfb_d_prep:\n\tcs0begin 4\n\t\tcenc $c0 $c6\n\t\tcxsin $c6\n\t\tcxor $c0 $c6\n\t\tcxsout $c0\n\tret\n\nsec_ofb_prep:\n\tcs0begin 4\n\t\tcenc $c6 $c6\n\t\tcxsin $c0\n\t\tcxor $c0 $c6\n\t\tcxsout $c0\n\tret\n\nsec_ctr_prep:\n\tcs0begin 5\n\t\tcenc $c1 $c6\n\t\tcadd $c6 1\n\t\tcxsin $c0\n\t\tcxor $c0 $c1\n\t\tcxsout $c0\n\tret\n\nsec_cbc_mac_prep:\n\tcs0begin 3\n\t\tcxsin $c0\n\t\tcxor $c6 $c0\n\t\tcenc $c6 $c6\n\tret\n\nsec_cmac_finish_complete_prep:\n\tcs0begin 7\n\t\tcxsin $c0\n\t\tcxor $c6 $c0\n\t\tcxor $c0 $c0\n\t\tcenc $c0 $c0\n\t\tcprecmac $c0 $c0\n\t\tcxor $c6 $c0\n\t\tcenc $c6 $c6\n\tret\n\nsec_cmac_finish_partial_prep:\n\tcs0begin 8\n\t\tcxsin $c0\n\t\tcxor $c6 $c0\n\t\tcxor $c0 $c0\n\t\tcenc $c0 $c0\n\t\tcprecmac $c0 $c0\n\t\tcprecmac $c0 $c0\n\t\tcxor $c6 $c0\n\t\tcenc $c6 $c6\n\tret\n\n// TODO\nsec_do_in:\n\tadd b32 $r3 $r5\n\tmov $xdbase $r4\n\tmov $r9 #swap\n\tsethi $r9 0x20000\n\tsec_do_in_loop:\n\t\txdld $r5 $r9\n\t\txdwait\n\t\tcxset 0x22\n\t\txdst $r0 $r9\n\t\tcs0exec 1\n\t\txdwait\n\t\tadd b32 $r5 0x10\n\t\tcmpu b32 $r5 $r3\n\tbra ne #sec_do_in_loop\n\tcxset 1\n\txdwait\n\tret\n\nsec_do_out:\n\tadd b32 $r3 $r7\n\tmov $xdbase $r6\n\tmov $r9 #swap\n\tsethi $r9 0x20000\n\tsec_do_out_loop:\n\t\tcs0exec 1\n\t\tcxset 0x61\n\t\txdld $r7 $r9\n\t\txdst $r7 $r9\n\t\tcxset 1\n\t\txdwait\n\t\tadd b32 $r7 0x10\n\t\tcmpu b32 $r7 $r3\n\tbra ne #sec_do_out_loop\n\tret\n\nsec_do_inout:\n\tadd b32 $r3 $r5\n\tmov $r9 #swap\n\tsethi $r9 0x20000\n\tsec_do_inout_loop:\n\t\tmov $xdbase $r4\n\t\txdld $r5 $r9\n\t\txdwait\n\t\tcxset 0x21\n\t\txdst $r0 $r9\n\t\tcs0exec 1\n\t\tcxset 0x61\n\t\tmov $xdbase $r6\n\t\txdld $r7 $r9\n\t\txdst $r7 $r9\n\t\tcxset 1\n\t\txdwait\n\t\tadd b32 $r5 0x10\n\t\tadd b32 $r7 0x10\n\t\tcmpu b32 $r5 $r3\n\tbra ne #sec_do_inout_loop\n\tret\n\n.align 0x100\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}