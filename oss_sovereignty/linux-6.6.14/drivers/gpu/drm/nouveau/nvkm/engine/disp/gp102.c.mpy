{
  "module_name": "gp102.c",
  "hash_id": "3d8307cea0332f827f43760d055acd535e787796f20275eac44b50316685337e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/gp102.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstatic int\ngp102_disp_dmac_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ctrl = chan->chid.ctrl;\n\tint user = chan->chid.user;\n\n\t \n\tnvkm_wr32(device, 0x611494 + (ctrl * 0x0010), chan->push);\n\tnvkm_wr32(device, 0x611498 + (ctrl * 0x0010), 0x00010000);\n\tnvkm_wr32(device, 0x61149c + (ctrl * 0x0010), 0x00000001);\n\tnvkm_mask(device, 0x610490 + (ctrl * 0x0010), 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x640000 + (ctrl * 0x1000), chan->suspend_put);\n\tnvkm_wr32(device, 0x610490 + (ctrl * 0x0010), 0x00000013);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490 + (ctrl * 0x10)) & 0x80000000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"ch %d init: %08x\\n\", user,\n\t\t\t   nvkm_rd32(device, 0x610490 + (ctrl * 0x10)));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nconst struct nvkm_disp_chan_func\ngp102_disp_dmac_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gp102_disp_dmac_init,\n\t.fini = gf119_disp_dmac_fini,\n\t.intr = gf119_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n\t.bind = gf119_disp_dmac_bind,\n};\n\nstatic const struct nvkm_disp_chan_user\ngp102_disp_curs = {\n\t.func = &gf119_disp_pioc_func,\n\t.ctrl = 13,\n\t.user = 17,\n};\n\nstatic const struct nvkm_disp_chan_user\ngp102_disp_oimm = {\n\t.func = &gf119_disp_pioc_func,\n\t.ctrl = 9,\n\t.user = 13,\n};\n\nstatic const struct nvkm_disp_chan_user\ngp102_disp_ovly = {\n\t.func = &gp102_disp_dmac_func,\n\t.ctrl = 5,\n\t.user = 5,\n\t.mthd = &gk104_disp_ovly_mthd,\n};\n\nstatic const struct nvkm_disp_chan_user\ngp102_disp_base = {\n\t.func = &gp102_disp_dmac_func,\n\t.ctrl = 1,\n\t.user = 1,\n\t.mthd = &gf119_disp_base_mthd,\n};\n\nstatic int\ngp102_disp_core_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tnvkm_wr32(device, 0x611494, chan->push);\n\tnvkm_wr32(device, 0x611498, 0x00010000);\n\tnvkm_wr32(device, 0x61149c, 0x00000001);\n\tnvkm_mask(device, 0x610490, 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x640000, chan->suspend_put);\n\tnvkm_wr32(device, 0x610490, 0x01000013);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x610490) & 0x80000000))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"core init: %08x\\n\",\n\t\t\t   nvkm_rd32(device, 0x610490));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_disp_chan_func\ngp102_disp_core_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gp102_disp_core_init,\n\t.fini = gf119_disp_core_fini,\n\t.intr = gf119_disp_chan_intr,\n\t.user = nv50_disp_chan_user,\n\t.bind = gf119_disp_dmac_bind,\n};\n\nstatic const struct nvkm_disp_chan_user\ngp102_disp_core = {\n\t.func = &gp102_disp_core_func,\n\t.ctrl = 0,\n\t.user = 0,\n\t.mthd = &gk104_disp_core_mthd,\n};\n\nstatic void\ngp102_disp_intr_error(struct nvkm_disp *disp, int chid)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mthd = nvkm_rd32(device, 0x6111f0 + (chid * 12));\n\tu32 data = nvkm_rd32(device, 0x6111f4 + (chid * 12));\n\tu32 unkn = nvkm_rd32(device, 0x6111f8 + (chid * 12));\n\n\tnvkm_error(subdev, \"chid %d mthd %04x data %08x %08x %08x\\n\",\n\t\t   chid, (mthd & 0x0000ffc), data, mthd, unkn);\n\n\tif (chid < ARRAY_SIZE(disp->chan)) {\n\t\tswitch (mthd & 0xffc) {\n\t\tcase 0x0080:\n\t\t\tnv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x61009c, (1 << chid));\n\tnvkm_wr32(device, 0x6111f0 + (chid * 12), 0x90000000);\n}\n\nstatic const struct nvkm_disp_func\ngp102_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = gf119_disp_init,\n\t.fini = gf119_disp_fini,\n\t.intr = gf119_disp_intr,\n\t.intr_error = gp102_disp_intr_error,\n\t.super = gf119_disp_super,\n\t.uevent = &gf119_disp_chan_uevent,\n\t.head = { .cnt = gf119_head_cnt, .new = gf119_head_new },\n\t.sor = { .cnt = gf119_sor_cnt, .new = gp100_sor_new },\n\t.root = { 0,0,GP102_DISP },\n\t.user = {\n\t\t{{0,0,GK104_DISP_CURSOR             }, nvkm_disp_chan_new, &gp102_disp_curs },\n\t\t{{0,0,GK104_DISP_OVERLAY            }, nvkm_disp_chan_new, &gp102_disp_oimm },\n\t\t{{0,0,GK110_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, &gp102_disp_base },\n\t\t{{0,0,GP102_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, &gp102_disp_core },\n\t\t{{0,0,GK104_DISP_OVERLAY_CONTROL_DMA}, nvkm_disp_chan_new, &gp102_disp_ovly },\n\t\t{}\n\t},\n};\n\nint\ngp102_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&gp102_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}