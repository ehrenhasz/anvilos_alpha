{
  "module_name": "uchan.c",
  "hash_id": "b64438f017136f98b591fff2d833a67375339b33007709823b547e8e2782f294",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/uchan.c",
  "human_readable_source": " \n#define nvkm_uchan(p) container_of((p), struct nvkm_uchan, object)\n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n\n#include <core/gpuobj.h>\n#include <core/oproxy.h>\n#include <subdev/mmu.h>\n#include <engine/dma.h>\n\n#include <nvif/if0020.h>\n\nstruct nvkm_uchan {\n\tstruct nvkm_object object;\n\tstruct nvkm_chan *chan;\n};\n\nstatic int\nnvkm_uchan_uevent(struct nvkm_object *object, void *argv, u32 argc, struct nvkm_uevent *uevent)\n{\n\tstruct nvkm_chan *chan = nvkm_uchan(object)->chan;\n\tstruct nvkm_runl *runl = chan->cgrp->runl;\n\tunion nvif_chan_event_args *args = argv;\n\n\tif (!uevent)\n\t\treturn 0;\n\tif (argc != sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tswitch (args->v0.type) {\n\tcase NVIF_CHAN_EVENT_V0_NON_STALL_INTR:\n\t\treturn nvkm_uevent_add(uevent, &runl->fifo->nonstall.event, runl->id,\n\t\t\t\t       NVKM_FIFO_NONSTALL_EVENT, NULL);\n\tcase NVIF_CHAN_EVENT_V0_KILLED:\n\t\treturn nvkm_uevent_add(uevent, &runl->chid->event, chan->id,\n\t\t\t\t       NVKM_CHAN_EVENT_ERRORED, NULL);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOSYS;\n}\n\nstruct nvkm_uobj {\n\tstruct nvkm_oproxy oproxy;\n\tstruct nvkm_chan *chan;\n\tstruct nvkm_cctx *cctx;\n\tint hash;\n};\n\nstatic int\nnvkm_uchan_object_fini_1(struct nvkm_oproxy *oproxy, bool suspend)\n{\n\tstruct nvkm_uobj *uobj = container_of(oproxy, typeof(*uobj), oproxy);\n\tstruct nvkm_chan *chan = uobj->chan;\n\tstruct nvkm_cctx *cctx = uobj->cctx;\n\tstruct nvkm_ectx *ectx = cctx->vctx->ectx;\n\n\tif (!ectx->object)\n\t\treturn 0;\n\n\t \n\tif (refcount_dec_and_mutex_lock(&cctx->uses, &chan->cgrp->mutex)) {\n\t\tnvkm_chan_cctx_bind(chan, ectx->engn, NULL);\n\n\t\tif (refcount_dec_and_test(&ectx->uses))\n\t\t\tnvkm_object_fini(ectx->object, false);\n\t\tmutex_unlock(&chan->cgrp->mutex);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_uchan_object_init_0(struct nvkm_oproxy *oproxy)\n{\n\tstruct nvkm_uobj *uobj = container_of(oproxy, typeof(*uobj), oproxy);\n\tstruct nvkm_chan *chan = uobj->chan;\n\tstruct nvkm_cctx *cctx = uobj->cctx;\n\tstruct nvkm_ectx *ectx = cctx->vctx->ectx;\n\tint ret = 0;\n\n\tif (!ectx->object)\n\t\treturn 0;\n\n\t \n\tif (!refcount_inc_not_zero(&cctx->uses)) {\n\t\tmutex_lock(&chan->cgrp->mutex);\n\t\tif (!refcount_inc_not_zero(&cctx->uses)) {\n\t\t\tif (!refcount_inc_not_zero(&ectx->uses)) {\n\t\t\t\tret = nvkm_object_init(ectx->object);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\trefcount_set(&ectx->uses, 1);\n\t\t\t}\n\n\t\t\tif (ret == 0) {\n\t\t\t\tnvkm_chan_cctx_bind(chan, ectx->engn, cctx);\n\t\t\t\trefcount_set(&cctx->uses, 1);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&chan->cgrp->mutex);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nnvkm_uchan_object_dtor(struct nvkm_oproxy *oproxy)\n{\n\tstruct nvkm_uobj *uobj = container_of(oproxy, typeof(*uobj), oproxy);\n\tstruct nvkm_engn *engn;\n\n\tif (!uobj->cctx)\n\t\treturn;\n\n\tengn = uobj->cctx->vctx->ectx->engn;\n\tif (engn->func->ramht_del)\n\t\tengn->func->ramht_del(uobj->chan, uobj->hash);\n\n\tnvkm_chan_cctx_put(uobj->chan, &uobj->cctx);\n}\n\nstatic const struct nvkm_oproxy_func\nnvkm_uchan_object = {\n\t.dtor[1] = nvkm_uchan_object_dtor,\n\t.init[0] = nvkm_uchan_object_init_0,\n\t.fini[1] = nvkm_uchan_object_fini_1,\n};\n\nstatic int\nnvkm_uchan_object_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t      struct nvkm_object **pobject)\n{\n\tstruct nvkm_chan *chan = nvkm_uchan(oclass->parent)->chan;\n\tstruct nvkm_cgrp *cgrp = chan->cgrp;\n\tstruct nvkm_engn *engn;\n\tstruct nvkm_uobj *uobj;\n\tint ret;\n\n\t \n\tengn = nvkm_runl_find_engn(engn, cgrp->runl, engn->engine == oclass->engine);\n\tif (WARN_ON(!engn))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(uobj = kzalloc(sizeof(*uobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_oproxy_ctor(&nvkm_uchan_object, oclass, &uobj->oproxy);\n\tuobj->chan = chan;\n\t*pobject = &uobj->oproxy.base;\n\n\t \n\tret = nvkm_chan_cctx_get(chan, engn, &uobj->cctx, oclass->client);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = oclass->base.ctor(&(const struct nvkm_oclass) {\n\t\t\t\t\t.base = oclass->base,\n\t\t\t\t\t.engn = oclass->engn,\n\t\t\t\t\t.handle = oclass->handle,\n\t\t\t\t\t.object = oclass->object,\n\t\t\t\t\t.client = oclass->client,\n\t\t\t\t\t.parent = uobj->cctx->vctx->ectx->object ?: oclass->parent,\n\t\t\t\t\t.engine = engn->engine,\n\t\t\t\t }, argv, argc, &uobj->oproxy.object);\n\tif (ret)\n\t\treturn ret;\n\n\tif (engn->func->ramht_add) {\n\t\tuobj->hash = engn->func->ramht_add(engn, uobj->oproxy.object, uobj->chan);\n\t\tif (uobj->hash < 0)\n\t\t\treturn uobj->hash;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_uchan_sclass(struct nvkm_object *object, int index, struct nvkm_oclass *oclass)\n{\n\tstruct nvkm_chan *chan = nvkm_uchan(object)->chan;\n\tstruct nvkm_engn *engn;\n\tint ret, runq = 0;\n\n\tnvkm_runl_foreach_engn(engn, chan->cgrp->runl) {\n\t\tstruct nvkm_engine *engine = engn->engine;\n\t\tint c = 0;\n\n\t\t \n\t\tif (engn->runl->func->runqs) {\n\t\t\tif (engine->subdev.type == NVKM_ENGINE_CE) {\n\t\t\t\tif (chan->runq != runq++)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\toclass->engine = engine;\n\t\toclass->base.oclass = 0;\n\n\t\tif (engine->func->fifo.sclass) {\n\t\t\tret = engine->func->fifo.sclass(oclass, index);\n\t\t\tif (oclass->base.oclass) {\n\t\t\t\tif (!oclass->base.ctor)\n\t\t\t\t\toclass->base.ctor = nvkm_object_new;\n\t\t\t\toclass->ctor = nvkm_uchan_object_new;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tindex -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile (engine->func->sclass[c].oclass) {\n\t\t\tif (c++ == index) {\n\t\t\t\toclass->base = engine->func->sclass[index];\n\t\t\t\tif (!oclass->base.ctor)\n\t\t\t\t\toclass->base.ctor = nvkm_object_new;\n\t\t\t\toclass->ctor = nvkm_uchan_object_new;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tindex -= c;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_uchan_map(struct nvkm_object *object, void *argv, u32 argc,\n\t       enum nvkm_object_map *type, u64 *addr, u64 *size)\n{\n\tstruct nvkm_chan *chan = nvkm_uchan(object)->chan;\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tif (chan->func->userd->bar < 0)\n\t\treturn -ENOSYS;\n\n\t*type = NVKM_OBJECT_MAP_IO;\n\t*addr = device->func->resource_addr(device, chan->func->userd->bar) +\n\t\tchan->func->userd->base + chan->userd.base;\n\t*size = chan->func->userd->size;\n\treturn 0;\n}\n\nstatic int\nnvkm_uchan_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nvkm_chan *chan = nvkm_uchan(object)->chan;\n\n\tnvkm_chan_block(chan);\n\tnvkm_chan_remove(chan, true);\n\n\tif (chan->func->unbind)\n\t\tchan->func->unbind(chan);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_uchan_init(struct nvkm_object *object)\n{\n\tstruct nvkm_chan *chan = nvkm_uchan(object)->chan;\n\n\tif (atomic_read(&chan->errored))\n\t\treturn 0;\n\n\tif (chan->func->bind)\n\t\tchan->func->bind(chan);\n\n\tnvkm_chan_allow(chan);\n\tnvkm_chan_insert(chan);\n\treturn 0;\n}\n\nstatic void *\nnvkm_uchan_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_uchan *uchan = nvkm_uchan(object);\n\n\tnvkm_chan_del(&uchan->chan);\n\treturn uchan;\n}\n\nstatic const struct nvkm_object_func\nnvkm_uchan = {\n\t.dtor = nvkm_uchan_dtor,\n\t.init = nvkm_uchan_init,\n\t.fini = nvkm_uchan_fini,\n\t.map = nvkm_uchan_map,\n\t.sclass = nvkm_uchan_sclass,\n\t.uevent = nvkm_uchan_uevent,\n};\n\nint\nnvkm_uchan_new(struct nvkm_fifo *fifo, struct nvkm_cgrp *cgrp, const struct nvkm_oclass *oclass,\n\t       void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tunion nvif_chan_args *args = argv;\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_vmm *vmm = NULL;\n\tstruct nvkm_dmaobj *ctxdma = NULL;\n\tstruct nvkm_memory *userd = NULL;\n\tstruct nvkm_uchan *uchan;\n\tstruct nvkm_chan *chan;\n\tint ret;\n\n\tif (argc < sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\targc -= sizeof(args->v0);\n\n\tif (args->v0.namelen != argc)\n\t\treturn -EINVAL;\n\n\t \n\trunl = nvkm_runl_get(fifo, args->v0.runlist, 0);\n\tif (!runl)\n\t\treturn -EINVAL;\n\n\tif (args->v0.vmm) {\n\t\tvmm = nvkm_uvmm_search(oclass->client, args->v0.vmm);\n\t\tif (IS_ERR(vmm))\n\t\t\treturn PTR_ERR(vmm);\n\t}\n\n\tif (args->v0.ctxdma) {\n\t\tctxdma = nvkm_dmaobj_search(oclass->client, args->v0.ctxdma);\n\t\tif (IS_ERR(ctxdma)) {\n\t\t\tret = PTR_ERR(ctxdma);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (args->v0.huserd) {\n\t\tuserd = nvkm_umem_search(oclass->client, args->v0.huserd);\n\t\tif (IS_ERR(userd)) {\n\t\t\tret = PTR_ERR(userd);\n\t\t\tuserd = NULL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (!(uchan = kzalloc(sizeof(*uchan), GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tnvkm_object_ctor(&nvkm_uchan, oclass, &uchan->object);\n\t*pobject = &uchan->object;\n\n\tret = nvkm_chan_new_(fifo->func->chan.func, runl, args->v0.runq, cgrp, args->v0.name,\n\t\t\t     args->v0.priv != 0, args->v0.devm, vmm, ctxdma, args->v0.offset,\n\t\t\t     args->v0.length, userd, args->v0.ouserd, &uchan->chan);\n\tif (ret)\n\t\tgoto done;\n\n\tchan = uchan->chan;\n\n\t \n\tif (chan->func->doorbell_handle)\n\t\targs->v0.token = chan->func->doorbell_handle(chan);\n\telse\n\t\targs->v0.token = ~0;\n\n\targs->v0.chid = chan->id;\n\n\tswitch (nvkm_memory_target(chan->inst->memory)) {\n\tcase NVKM_MEM_TARGET_INST: args->v0.aper = NVIF_CHAN_V0_INST_APER_INST; break;\n\tcase NVKM_MEM_TARGET_VRAM: args->v0.aper = NVIF_CHAN_V0_INST_APER_VRAM; break;\n\tcase NVKM_MEM_TARGET_HOST: args->v0.aper = NVIF_CHAN_V0_INST_APER_HOST; break;\n\tcase NVKM_MEM_TARGET_NCOH: args->v0.aper = NVIF_CHAN_V0_INST_APER_NCOH; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = -EFAULT;\n\t\tbreak;\n\t}\n\n\targs->v0.inst = nvkm_memory_addr(chan->inst->memory);\ndone:\n\tnvkm_memory_unref(&userd);\n\tnvkm_vmm_unref(&vmm);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}