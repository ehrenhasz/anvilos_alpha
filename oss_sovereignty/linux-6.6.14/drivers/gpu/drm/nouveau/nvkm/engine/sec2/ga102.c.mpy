{
  "module_name": "ga102.c",
  "hash_id": "ebf968a5a51191cafbbb3efa63d34ce8aef3726af65c7b9d03cc9a9805ec816d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/sec2/ga102.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include <subdev/acr.h>\n#include <subdev/vfn.h>\n\n#include <nvfw/flcn.h>\n#include <nvfw/sec2.h>\n\nstatic int\nga102_sec2_initmsg(struct nvkm_sec2 *sec2)\n{\n\tstruct nv_sec2_init_msg_v1 msg;\n\tint ret, i;\n\n\tret = nvkm_falcon_msgq_recv_initmsg(sec2->msgq, &msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\n\tif (msg.hdr.unit_id != NV_SEC2_UNIT_INIT ||\n\t    msg.msg_type != NV_SEC2_INIT_MSG_INIT)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(msg.queue_info); i++) {\n\t\tif (msg.queue_info[i].id == NV_SEC2_INIT_MSG_QUEUE_ID_MSGQ) {\n\t\t\tnvkm_falcon_msgq_init(sec2->msgq, msg.queue_info[i].index,\n\t\t\t\t\t\t\t  msg.queue_info[i].offset,\n\t\t\t\t\t\t\t  msg.queue_info[i].size);\n\t\t} else {\n\t\t\tnvkm_falcon_cmdq_init(sec2->cmdq, msg.queue_info[i].index,\n\t\t\t\t\t\t\t  msg.queue_info[i].offset,\n\t\t\t\t\t\t\t  msg.queue_info[i].size);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct nvkm_intr *\nga102_sec2_intr_vector(struct nvkm_sec2 *sec2, enum nvkm_intr_type *pvector)\n{\n\tstruct nvkm_device *device = sec2->engine.subdev.device;\n\tstruct nvkm_falcon *falcon = &sec2->falcon;\n\tint ret;\n\n\tret = ga102_flcn_select(falcon);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t*pvector = nvkm_rd32(device, 0x8403e0) & 0x000000ff;\n\treturn &device->vfn->intr;\n}\n\nstatic int\nga102_sec2_acr_bootstrap_falcon_callback(void *priv, struct nvfw_falcon_msg *hdr)\n{\n\tstruct nv_sec2_acr_bootstrap_falcon_msg_v1 *msg =\n\t\tcontainer_of(hdr, typeof(*msg), msg.hdr);\n\tstruct nvkm_subdev *subdev = priv;\n\tconst char *name = nvkm_acr_lsf_id(msg->falcon_id);\n\n\tif (msg->error_code) {\n\t\tnvkm_error(subdev, \"ACR_BOOTSTRAP_FALCON failed for falcon %d [%s]: %08x %08x\\n\",\n\t\t\t   msg->falcon_id, name, msg->error_code, msg->unkn08);\n\t\treturn -EINVAL;\n\t}\n\n\tnvkm_debug(subdev, \"%s booted\\n\", name);\n\treturn 0;\n}\n\nstatic int\nga102_sec2_acr_bootstrap_falcon(struct nvkm_falcon *falcon, enum nvkm_acr_lsf_id id)\n{\n\tstruct nvkm_sec2 *sec2 = container_of(falcon, typeof(*sec2), falcon);\n\tstruct nv_sec2_acr_bootstrap_falcon_cmd_v1 cmd = {\n\t\t.cmd.hdr.unit_id = sec2->func->unit_acr,\n\t\t.cmd.hdr.size = sizeof(cmd),\n\t\t.cmd.cmd_type = NV_SEC2_ACR_CMD_BOOTSTRAP_FALCON,\n\t\t.flags = NV_SEC2_ACR_BOOTSTRAP_FALCON_FLAGS_RESET_YES,\n\t\t.falcon_id = id,\n\t};\n\n\treturn nvkm_falcon_cmdq_send(sec2->cmdq, &cmd.cmd.hdr,\n\t\t\t\t     ga102_sec2_acr_bootstrap_falcon_callback,\n\t\t\t\t     &sec2->engine.subdev,\n\t\t\t\t     msecs_to_jiffies(1000));\n}\n\nstatic const struct nvkm_acr_lsf_func\nga102_sec2_acr_0 = {\n\t.bld_size = sizeof(struct flcn_bl_dmem_desc_v2),\n\t.bld_write = gp102_sec2_acr_bld_write_1,\n\t.bld_patch = gp102_sec2_acr_bld_patch_1,\n\t.bootstrap_falcons = BIT_ULL(NVKM_ACR_LSF_FECS) |\n\t\t\t     BIT_ULL(NVKM_ACR_LSF_GPCCS) |\n\t\t\t     BIT_ULL(NVKM_ACR_LSF_SEC2),\n\t.bootstrap_falcon = ga102_sec2_acr_bootstrap_falcon,\n};\n\nstatic const struct nvkm_falcon_func\nga102_sec2_flcn = {\n\t.disable = gm200_flcn_disable,\n\t.enable = gm200_flcn_enable,\n\t.select = ga102_flcn_select,\n\t.addr2 = 0x1000,\n\t.reset_pmc = true,\n\t.reset_eng = gp102_flcn_reset_eng,\n\t.reset_prep = ga102_flcn_reset_prep,\n\t.reset_wait_mem_scrubbing = ga102_flcn_reset_wait_mem_scrubbing,\n\t.imem_dma = &ga102_flcn_dma,\n\t.dmem_pio = &gm200_flcn_dmem_pio,\n\t.dmem_dma = &ga102_flcn_dma,\n\t.emem_addr = 0x01000000,\n\t.emem_pio = &gp102_flcn_emem_pio,\n\t.start = nvkm_falcon_v1_start,\n\t.cmdq = { 0xc00, 0xc04, 8 },\n\t.msgq = { 0xc80, 0xc84, 8 },\n};\n\nstatic const struct nvkm_sec2_func\nga102_sec2 = {\n\t.flcn = &ga102_sec2_flcn,\n\t.intr_vector = ga102_sec2_intr_vector,\n\t.intr = gp102_sec2_intr,\n\t.initmsg = ga102_sec2_initmsg,\n\t.unit_acr = NV_SEC2_UNIT_V2_ACR,\n\t.unit_unload = NV_SEC2_UNIT_V2_UNLOAD,\n};\n\nMODULE_FIRMWARE(\"nvidia/ga102/sec2/desc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/sec2/image.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/sec2/sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga102/sec2/hs_bl_sig.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga103/sec2/desc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/sec2/image.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/sec2/sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/sec2/hs_bl_sig.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga104/sec2/desc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/sec2/image.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/sec2/sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/sec2/hs_bl_sig.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga106/sec2/desc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/sec2/image.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/sec2/sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/sec2/hs_bl_sig.bin\");\n\nMODULE_FIRMWARE(\"nvidia/ga107/sec2/desc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/sec2/image.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/sec2/sig.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/sec2/hs_bl_sig.bin\");\n\nstatic int\nga102_sec2_load(struct nvkm_sec2 *sec2, int ver,\n\t\tconst struct nvkm_sec2_fwif *fwif)\n{\n\treturn nvkm_acr_lsfw_load_sig_image_desc_v2(&sec2->engine.subdev, &sec2->falcon,\n\t\t\t\t\t\t    NVKM_ACR_LSF_SEC2, \"sec2/\", ver, fwif->acr);\n}\n\nstatic const struct nvkm_sec2_fwif\nga102_sec2_fwif[] = {\n\t{  0, ga102_sec2_load, &ga102_sec2, &ga102_sec2_acr_0 },\n\t{ -1, gp102_sec2_nofw, &ga102_sec2 }\n};\n\nint\nga102_sec2_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_sec2 **psec2)\n{\n\t \n\treturn nvkm_sec2_new_(ga102_sec2_fwif, device, type, inst, 0x840000, psec2);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}