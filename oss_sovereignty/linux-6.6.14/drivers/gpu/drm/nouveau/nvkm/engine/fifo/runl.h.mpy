{
  "module_name": "runl.h",
  "hash_id": "a91cace185632650c4b80765520787dab1fab5c72b4056eddb92bd567377cd5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/runl.h",
  "human_readable_source": "#ifndef __NVKM_RUNL_H__\n#define __NVKM_RUNL_H__\n#include <core/intr.h>\nstruct nvkm_cctx;\nstruct nvkm_cgrp;\nstruct nvkm_chan;\nstruct nvkm_memory;\nstruct nvkm_object;\nstruct nvkm_vctx;\nenum nvkm_subdev_type;\n\nstruct nvkm_engn {\n\tconst struct nvkm_engn_func {\n\t\tint (*nonstall)(struct nvkm_engn *);\n\t\tbool (*chsw)(struct nvkm_engn *);\n\t\tint (*cxid)(struct nvkm_engn *, bool *cgid);\n\t\tvoid (*mmu_fault_trigger)(struct nvkm_engn *);\n\t\tbool (*mmu_fault_triggered)(struct nvkm_engn *);\n\t\tint (*ctor)(struct nvkm_engn *, struct nvkm_vctx *);\n\t\tvoid (*bind)(struct nvkm_engn *, struct nvkm_cctx *, struct nvkm_chan *);\n\t\tint (*ramht_add)(struct nvkm_engn *, struct nvkm_object *, struct nvkm_chan *);\n\t\tvoid (*ramht_del)(struct nvkm_chan *, int hash);\n\t} *func;\n\tstruct nvkm_runl *runl;\n\tint id;\n\n\tstruct nvkm_engine *engine;\n\n\tint fault;\n\n\tstruct list_head head;\n};\n\n#define ENGN_PRINT(e,l,p,f,a...)                                                           \\\n\tRUNL_PRINT((e)->runl, l, p, \"%02d[%8s]:\"f, (e)->id, (e)->engine->subdev.name, ##a)\n#define ENGN_DEBUG(e,f,a...) ENGN_PRINT((e), DEBUG,   info, \" \"f\"\\n\", ##a)\n\nstruct nvkm_runl {\n\tconst struct nvkm_runl_func {\n\t\tvoid (*init)(struct nvkm_runl *);\n\t\tvoid (*fini)(struct nvkm_runl *);\n\t\tint runqs;\n\t\tu8 size;\n\t\tint (*update)(struct nvkm_runl *);\n\t\tvoid (*insert_cgrp)(struct nvkm_cgrp *, struct nvkm_memory *, u64 offset);\n\t\tvoid (*insert_chan)(struct nvkm_chan *, struct nvkm_memory *, u64 offset);\n\t\tvoid (*commit)(struct nvkm_runl *, struct nvkm_memory *, u32 start, int count);\n\t\tint (*wait)(struct nvkm_runl *);\n\t\tbool (*pending)(struct nvkm_runl *);\n\t\tvoid (*block)(struct nvkm_runl *, u32 engm);\n\t\tvoid (*allow)(struct nvkm_runl *, u32 engm);\n\t\tvoid (*fault_clear)(struct nvkm_runl *);\n\t\tvoid (*preempt)(struct nvkm_runl *);\n\t\tbool (*preempt_pending)(struct nvkm_runl *);\n\t} *func;\n\tstruct nvkm_fifo *fifo;\n\tint id;\n\tu32 addr;\n\tu32 chan;\n\tu16 doorbell;\n\n\tstruct nvkm_chid *cgid;\n#define NVKM_CHAN_EVENT_ERRORED BIT(0)\n\tstruct nvkm_chid *chid;\n\n\tstruct list_head engns;\n\n\tstruct nvkm_runq *runq[2];\n\tint runq_nr;\n\n\tstruct nvkm_inth inth;\n\n\tstruct {\n\t\tint vector;\n\t\tstruct nvkm_inth inth;\n\t} nonstall;\n\n\tstruct list_head cgrps;\n\tint cgrp_nr;\n\tint chan_nr;\n\tatomic_t changed;\n\tstruct nvkm_memory *mem;\n\tu32 offset;\n\tstruct mutex mutex;\n\n\tint blocked;\n\n\tstruct work_struct work;\n\tatomic_t rc_triggered;\n\tatomic_t rc_pending;\n\n\tstruct list_head head;\n};\n\nstruct nvkm_runl *nvkm_runl_new(struct nvkm_fifo *, int runi, u32 addr, int id_nr);\nstruct nvkm_runl *nvkm_runl_get(struct nvkm_fifo *, int runi, u32 addr);\nstruct nvkm_engn *nvkm_runl_add(struct nvkm_runl *, int engi, const struct nvkm_engn_func *,\n\t\t\t\tenum nvkm_subdev_type, int inst);\nvoid nvkm_runl_del(struct nvkm_runl *);\nvoid nvkm_runl_fini(struct nvkm_runl *);\nvoid nvkm_runl_block(struct nvkm_runl *);\nvoid nvkm_runl_allow(struct nvkm_runl *);\nvoid nvkm_runl_update_locked(struct nvkm_runl *, bool wait);\nbool nvkm_runl_update_pending(struct nvkm_runl *);\nint nvkm_runl_preempt_wait(struct nvkm_runl *);\n\nvoid nvkm_runl_rc_engn(struct nvkm_runl *, struct nvkm_engn *);\nvoid nvkm_runl_rc_cgrp(struct nvkm_cgrp *);\n\nstruct nvkm_cgrp *nvkm_runl_cgrp_get_cgid(struct nvkm_runl *, int cgid, unsigned long *irqflags);\nstruct nvkm_chan *nvkm_runl_chan_get_chid(struct nvkm_runl *, int chid, unsigned long *irqflags);\nstruct nvkm_chan *nvkm_runl_chan_get_inst(struct nvkm_runl *, u64 inst, unsigned long *irqflags);\n\n#define nvkm_runl_find_engn(engn,runl,cond) nvkm_list_find(engn, &(runl)->engns, head, (cond))\n\n#define nvkm_runl_first(fifo) list_first_entry(&(fifo)->runls, struct nvkm_runl, head)\n#define nvkm_runl_foreach(runl,fifo) list_for_each_entry((runl), &(fifo)->runls, head)\n#define nvkm_runl_foreach_cond(runl,fifo,cond) nvkm_list_foreach(runl, &(fifo)->runls, head, (cond))\n#define nvkm_runl_foreach_engn(engn,runl) list_for_each_entry((engn), &(runl)->engns, head)\n#define nvkm_runl_foreach_engn_cond(engn,runl,cond) \\\n\tnvkm_list_foreach(engn, &(runl)->engns, head, (cond))\n#define nvkm_runl_foreach_cgrp(cgrp,runl) list_for_each_entry((cgrp), &(runl)->cgrps, head)\n#define nvkm_runl_foreach_cgrp_safe(cgrp,gtmp,runl) \\\n\tlist_for_each_entry_safe((cgrp), (gtmp), &(runl)->cgrps, head)\n\n#define RUNL_PRINT(r,l,p,f,a...)                                                          \\\n\tnvkm_printk__(&(r)->fifo->engine.subdev, NV_DBG_##l, p, \"%06x:\"f, (r)->addr, ##a)\n#define RUNL_ERROR(r,f,a...) RUNL_PRINT((r), ERROR,    err, \" \"f\"\\n\", ##a)\n#define RUNL_DEBUG(r,f,a...) RUNL_PRINT((r), DEBUG,   info, \" \"f\"\\n\", ##a)\n#define RUNL_TRACE(r,f,a...) RUNL_PRINT((r), TRACE,   info, \" \"f\"\\n\", ##a)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}