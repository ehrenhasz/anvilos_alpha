{
  "module_name": "nv50.c",
  "hash_id": "fa5680f451a10cebd25516cb1017ad07e9bcc0bd103319750959b8beeada893b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/nv50.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n\n#include <core/ramht.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nvoid\nnv50_eobj_ramht_del(struct nvkm_chan *chan, int hash)\n{\n\tnvkm_ramht_remove(chan->ramht, hash);\n}\n\nint\nnv50_eobj_ramht_add(struct nvkm_engn *engn, struct nvkm_object *eobj, struct nvkm_chan *chan)\n{\n\treturn nvkm_ramht_insert(chan->ramht, eobj, 0, 4, eobj->handle, engn->id << 20);\n}\n\nvoid\nnv50_chan_stop(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x002600 + (chan->id * 4), 0x80000000, 0x00000000);\n}\n\nvoid\nnv50_chan_start(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x002600 + (chan->id * 4), 0x80000000, 0x80000000);\n}\n\nvoid\nnv50_chan_unbind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x002600 + (chan->id * 4), 0x00000000);\n}\n\nstatic void\nnv50_chan_bind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x002600 + (chan->id * 4), chan->ramfc->addr >> 12);\n}\n\nstatic int\nnv50_chan_ramfc_write(struct nvkm_chan *chan, u64 offset, u64 length, u32 devm, bool priv)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\tconst u32 limit2 = ilog2(length / 8);\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 0x0200, 0x1000, true, chan->inst, &chan->ramfc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 0x1200, 0, true, chan->inst, &chan->eng);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 0x4000, 0, false, chan->inst, &chan->pgd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_ramht_new(device, 0x8000, 16, chan->inst, &chan->ramht);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_kmap(chan->ramfc);\n\tnvkm_wo32(chan->ramfc, 0x3c, 0x403f6078);\n\tnvkm_wo32(chan->ramfc, 0x44, 0x01003fff);\n\tnvkm_wo32(chan->ramfc, 0x48, chan->push->node->offset >> 4);\n\tnvkm_wo32(chan->ramfc, 0x50, lower_32_bits(offset));\n\tnvkm_wo32(chan->ramfc, 0x54, upper_32_bits(offset) | (limit2 << 16));\n\tnvkm_wo32(chan->ramfc, 0x60, 0x7fffffff);\n\tnvkm_wo32(chan->ramfc, 0x78, 0x00000000);\n\tnvkm_wo32(chan->ramfc, 0x7c, 0x30000000 | devm);\n\tnvkm_wo32(chan->ramfc, 0x80, ((chan->ramht->bits - 9) << 27) |\n\t\t\t\t     (4 << 24)   |\n\t\t\t\t     (chan->ramht->gpuobj->node->offset >> 4));\n\tnvkm_done(chan->ramfc);\n\treturn 0;\n}\n\nstatic const struct nvkm_chan_func_ramfc\nnv50_chan_ramfc = {\n\t.write = nv50_chan_ramfc_write,\n\t.ctxdma = true,\n\t.devm = 0xfff,\n};\n\nconst struct nvkm_chan_func_userd\nnv50_chan_userd = {\n\t.bar = 0,\n\t.base = 0xc00000,\n\t.size = 0x002000,\n};\n\nconst struct nvkm_chan_func_inst\nnv50_chan_inst = {\n\t.size = 0x10000,\n\t.vmm = true,\n};\n\nstatic const struct nvkm_chan_func\nnv50_chan = {\n\t.inst = &nv50_chan_inst,\n\t.userd = &nv50_chan_userd,\n\t.ramfc = &nv50_chan_ramfc,\n\t.bind = nv50_chan_bind,\n\t.unbind = nv50_chan_unbind,\n\t.start = nv50_chan_start,\n\t.stop = nv50_chan_stop,\n};\n\nstatic void\nnv50_ectx_bind(struct nvkm_engn *engn, struct nvkm_cctx *cctx, struct nvkm_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->cgrp->runl->fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu64 start = 0, limit = 0;\n\tu32 flags = 0, ptr0, save;\n\n\tswitch (engn->engine->subdev.type) {\n\tcase NVKM_ENGINE_GR    : ptr0 = 0x0000; break;\n\tcase NVKM_ENGINE_MPEG  : ptr0 = 0x0060; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (!cctx) {\n\t\t \n\t\tsave = nvkm_mask(device, 0x00b860, 0x00000001, 0x00000001);\n\n\t\t \n\t\tnvkm_wr32(device, 0x0032fc, chan->inst->addr >> 12);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (nvkm_rd32(device, 0x0032fc) != 0xffffffff)\n\t\t\t\tbreak;\n\t\t);\n\t\tnvkm_wr32(device, 0x00b860, save);\n\t} else {\n\t\tflags = 0x00190000;\n\t\tstart = cctx->vctx->inst->addr;\n\t\tlimit = start + cctx->vctx->inst->size - 1;\n\t}\n\n\tnvkm_kmap(chan->eng);\n\tnvkm_wo32(chan->eng, ptr0 + 0x00, flags);\n\tnvkm_wo32(chan->eng, ptr0 + 0x04, lower_32_bits(limit));\n\tnvkm_wo32(chan->eng, ptr0 + 0x08, lower_32_bits(start));\n\tnvkm_wo32(chan->eng, ptr0 + 0x0c, upper_32_bits(limit) << 24 |\n\t\t\t\t\t  lower_32_bits(start));\n\tnvkm_wo32(chan->eng, ptr0 + 0x10, 0x00000000);\n\tnvkm_wo32(chan->eng, ptr0 + 0x14, 0x00000000);\n\tnvkm_done(chan->eng);\n}\n\nstatic const struct nvkm_engn_func\nnv50_engn = {\n\t.bind = nv50_ectx_bind,\n\t.ramht_add = nv50_eobj_ramht_add,\n\t.ramht_del = nv50_eobj_ramht_del,\n};\n\nconst struct nvkm_engn_func\nnv50_engn_sw = {\n\t.ramht_add = nv50_eobj_ramht_add,\n\t.ramht_del = nv50_eobj_ramht_del,\n};\n\nstatic bool\nnv50_runl_pending(struct nvkm_runl *runl)\n{\n\treturn nvkm_rd32(runl->fifo->engine.subdev.device, 0x0032ec) & 0x00000100;\n}\n\nint\nnv50_runl_wait(struct nvkm_runl *runl)\n{\n\tstruct nvkm_fifo *fifo = runl->fifo;\n\n\tnvkm_msec(fifo->engine.subdev.device, fifo->timeout.chan_msec,\n\t\tif (!nvkm_runl_update_pending(runl))\n\t\t\treturn 0;\n\t\tusleep_range(1, 2);\n\t);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void\nnv50_runl_commit(struct nvkm_runl *runl, struct nvkm_memory *memory, u32 start, int count)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tu64 addr = nvkm_memory_addr(memory) + start;\n\n\tnvkm_wr32(device, 0x0032f4, addr >> 12);\n\tnvkm_wr32(device, 0x0032ec, count);\n}\n\nstatic void\nnv50_runl_insert_chan(struct nvkm_chan *chan, struct nvkm_memory *memory, u64 offset)\n{\n\tnvkm_wo32(memory, offset, chan->id);\n}\n\nstatic struct nvkm_memory *\nnv50_runl_alloc(struct nvkm_runl *runl, u32 *offset)\n{\n\tconst u32 segment = ALIGN((runl->cgrp_nr + runl->chan_nr) * runl->func->size, 0x1000);\n\tconst u32 maxsize = (runl->cgid ? runl->cgid->nr : 0) + runl->chid->nr;\n\tint ret;\n\n\tif (unlikely(!runl->mem)) {\n\t\tret = nvkm_memory_new(runl->fifo->engine.subdev.device, NVKM_MEM_TARGET_INST,\n\t\t\t\t      maxsize * 2 * runl->func->size, 0, false, &runl->mem);\n\t\tif (ret) {\n\t\t\tRUNL_ERROR(runl, \"alloc %d\\n\", ret);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t} else {\n\t\tif (runl->offset + segment >= nvkm_memory_size(runl->mem)) {\n\t\t\tret = runl->func->wait(runl);\n\t\t\tif (ret) {\n\t\t\t\tRUNL_DEBUG(runl, \"rewind timeout\");\n\t\t\t\treturn ERR_PTR(ret);\n\t\t\t}\n\n\t\t\trunl->offset = 0;\n\t\t}\n\t}\n\n\t*offset = runl->offset;\n\trunl->offset += segment;\n\treturn runl->mem;\n}\n\nint\nnv50_runl_update(struct nvkm_runl *runl)\n{\n\tstruct nvkm_memory *memory;\n\tstruct nvkm_cgrp *cgrp;\n\tstruct nvkm_chan *chan;\n\tu32 start, offset, count;\n\n\t \n\n\tRUNL_TRACE(runl, \"RAMRL: update cgrps:%d chans:%d\", runl->cgrp_nr, runl->chan_nr);\n\tmemory = nv50_runl_alloc(runl, &start);\n\tif (IS_ERR(memory))\n\t\treturn PTR_ERR(memory);\n\n\tRUNL_TRACE(runl, \"RAMRL: update start:%08x\", start);\n\toffset = start;\n\n\tnvkm_kmap(memory);\n\tnvkm_runl_foreach_cgrp(cgrp, runl) {\n\t\tif (cgrp->hw) {\n\t\t\tCGRP_TRACE(cgrp, \"     RAMRL+%08x: chans:%d\", offset, cgrp->chan_nr);\n\t\t\trunl->func->insert_cgrp(cgrp, memory, offset);\n\t\t\toffset += runl->func->size;\n\t\t}\n\n\t\tnvkm_cgrp_foreach_chan(chan, cgrp) {\n\t\t\tCHAN_TRACE(chan, \"RAMRL+%08x: [%s]\", offset, chan->name);\n\t\t\trunl->func->insert_chan(chan, memory, offset);\n\t\t\toffset += runl->func->size;\n\t\t}\n\t}\n\tnvkm_done(memory);\n\n\t \n\tlist_rotate_left(&runl->cgrps);\n\n\tcount = (offset - start) / runl->func->size;\n\tRUNL_TRACE(runl, \"RAMRL: commit start:%08x count:%d\", start, count);\n\n\trunl->func->commit(runl, memory, start, count);\n\treturn 0;\n}\n\nconst struct nvkm_runl_func\nnv50_runl = {\n\t.size = 4,\n\t.update = nv50_runl_update,\n\t.insert_chan = nv50_runl_insert_chan,\n\t.commit = nv50_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = nv50_runl_pending,\n};\n\nvoid\nnv50_fifo_init(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_runl *runl = nvkm_runl_first(fifo);\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tint i;\n\n\tnvkm_mask(device, 0x000200, 0x00000100, 0x00000000);\n\tnvkm_mask(device, 0x000200, 0x00000100, 0x00000100);\n\tnvkm_wr32(device, 0x00250c, 0x6f3cfc34);\n\tnvkm_wr32(device, 0x002044, 0x01003fff);\n\n\tnvkm_wr32(device, 0x002100, 0xffffffff);\n\tnvkm_wr32(device, 0x002140, 0xbfffffff);\n\n\tfor (i = 0; i < 128; i++)\n\t\tnvkm_wr32(device, 0x002600 + (i * 4), 0x00000000);\n\n\tatomic_set(&runl->changed, 1);\n\trunl->func->update(runl);\n\n\tnvkm_wr32(device, 0x003200, 0x00000001);\n\tnvkm_wr32(device, 0x003250, 0x00000001);\n\tnvkm_wr32(device, 0x002500, 0x00000001);\n}\n\nint\nnv50_fifo_chid_ctor(struct nvkm_fifo *fifo, int nr)\n{\n\t \n\treturn nvkm_chid_new(&nvkm_chan_event, &fifo->engine.subdev, nr, 1, nr - 2, &fifo->chid);\n}\n\nint\nnv50_fifo_chid_nr(struct nvkm_fifo *fifo)\n{\n\treturn 128;\n}\n\nstatic const struct nvkm_fifo_func\nnv50_fifo = {\n\t.chid_nr = nv50_fifo_chid_nr,\n\t.chid_ctor = nv50_fifo_chid_ctor,\n\t.runl_ctor = nv04_fifo_runl_ctor,\n\t.init = nv50_fifo_init,\n\t.intr = nv04_fifo_intr,\n\t.pause = nv04_fifo_pause,\n\t.start = nv04_fifo_start,\n\t.runl = &nv50_runl,\n\t.engn = &nv50_engn,\n\t.engn_sw = &nv50_engn_sw,\n\t.cgrp = {{                           }, &nv04_cgrp },\n\t.chan = {{ 0, 0, NV50_CHANNEL_GPFIFO }, &nv50_chan },\n};\n\nint\nnv50_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&nv50_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}