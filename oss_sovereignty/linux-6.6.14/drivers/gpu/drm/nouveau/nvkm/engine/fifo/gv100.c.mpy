{
  "module_name": "gv100.c",
  "hash_id": "da76d58ddebd17ae9cd4440bb680780bd96fb1077a477546904c7978f0e6adf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gv100.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"cgrp.h\"\n#include \"runl.h\"\n#include \"runq.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/mmu.h>\n\n#include <nvif/class.h>\n\nstatic u32\ngv100_chan_doorbell_handle(struct nvkm_chan *chan)\n{\n\treturn chan->id;\n}\n\nstatic int\ngv100_chan_ramfc_write(struct nvkm_chan *chan, u64 offset, u64 length, u32 devm, bool priv)\n{\n\tconst u64 userd = nvkm_memory_addr(chan->userd.mem) + chan->userd.base;\n\tconst u32 limit2 = ilog2(length / 8);\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x008, lower_32_bits(userd));\n\tnvkm_wo32(chan->inst, 0x00c, upper_32_bits(userd));\n\tnvkm_wo32(chan->inst, 0x010, 0x0000face);\n\tnvkm_wo32(chan->inst, 0x030, 0x7ffff902);\n\tnvkm_wo32(chan->inst, 0x048, lower_32_bits(offset));\n\tnvkm_wo32(chan->inst, 0x04c, upper_32_bits(offset) | (limit2 << 16));\n\tnvkm_wo32(chan->inst, 0x084, 0x20400000);\n\tnvkm_wo32(chan->inst, 0x094, 0x30000000 | devm);\n\tnvkm_wo32(chan->inst, 0x0e4, priv ? 0x00000020 : 0x00000000);\n\tnvkm_wo32(chan->inst, 0x0e8, chan->id);\n\tnvkm_wo32(chan->inst, 0x0f4, 0x00001000 | (priv ? 0x00000100 : 0x00000000));\n\tnvkm_wo32(chan->inst, 0x0f8, 0x10003080);\n\tnvkm_mo32(chan->inst, 0x218, 0x00000000, 0x00000000);\n\tnvkm_done(chan->inst);\n\treturn 0;\n}\n\nconst struct nvkm_chan_func_ramfc\ngv100_chan_ramfc = {\n\t.write = gv100_chan_ramfc_write,\n\t.devm = 0xfff,\n\t.priv = true,\n};\n\nconst struct nvkm_chan_func_userd\ngv100_chan_userd = {\n\t.bar = -1,\n\t.size = 0x200,\n\t.clear = gf100_chan_userd_clear,\n};\n\nstatic const struct nvkm_chan_func\ngv100_chan = {\n\t.inst = &gf100_chan_inst,\n\t.userd = &gv100_chan_userd,\n\t.ramfc = &gv100_chan_ramfc,\n\t.bind = gk104_chan_bind_inst,\n\t.unbind = gk104_chan_unbind,\n\t.start = gk104_chan_start,\n\t.stop = gk104_chan_stop,\n\t.preempt = gk110_chan_preempt,\n\t.doorbell_handle = gv100_chan_doorbell_handle,\n};\n\nvoid\ngv100_ectx_bind(struct nvkm_engn *engn, struct nvkm_cctx *cctx, struct nvkm_chan *chan)\n{\n\tu64 addr = 0ULL;\n\n\tif (cctx) {\n\t\taddr  = cctx->vctx->vma->addr;\n\t\taddr |= 4ULL;\n\t}\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x210, lower_32_bits(addr));\n\tnvkm_wo32(chan->inst, 0x214, upper_32_bits(addr));\n\tnvkm_mo32(chan->inst, 0x0ac, 0x00010000, cctx ? 0x00010000 : 0x00000000);\n\tnvkm_done(chan->inst);\n}\n\nconst struct nvkm_engn_func\ngv100_engn = {\n\t.chsw = gk104_engn_chsw,\n\t.cxid = gk104_engn_cxid,\n\t.ctor = gk104_ectx_ctor,\n\t.bind = gv100_ectx_bind,\n};\n\nvoid\ngv100_ectx_ce_bind(struct nvkm_engn *engn, struct nvkm_cctx *cctx, struct nvkm_chan *chan)\n{\n\tconst u64 bar2 = cctx ? nvkm_memory_bar2(cctx->vctx->inst->memory) : 0ULL;\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x220, lower_32_bits(bar2));\n\tnvkm_wo32(chan->inst, 0x224, upper_32_bits(bar2));\n\tnvkm_mo32(chan->inst, 0x0ac, 0x00020000, cctx ? 0x00020000 : 0x00000000);\n\tnvkm_done(chan->inst);\n}\n\nint\ngv100_ectx_ce_ctor(struct nvkm_engn *engn, struct nvkm_vctx *vctx)\n{\n\tif (nvkm_memory_bar2(vctx->inst->memory) == ~0ULL)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nconst struct nvkm_engn_func\ngv100_engn_ce = {\n\t.chsw = gk104_engn_chsw,\n\t.cxid = gk104_engn_cxid,\n\t.ctor = gv100_ectx_ce_ctor,\n\t.bind = gv100_ectx_ce_bind,\n};\n\nstatic bool\ngv100_runq_intr_1_ctxnotvalid(struct nvkm_runq *runq, int chid)\n{\n\tstruct nvkm_fifo *fifo = runq->fifo;\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_chan *chan;\n\tunsigned long flags;\n\n\tRUNQ_ERROR(runq, \"CTXNOTVALID chid:%d\", chid);\n\n\tchan = nvkm_chan_get_chid(&fifo->engine, chid, &flags);\n\tif (WARN_ON_ONCE(!chan))\n\t\treturn false;\n\n\tnvkm_chan_error(chan, true);\n\tnvkm_chan_put(&chan, flags);\n\n\tnvkm_mask(device, 0x0400ac + (runq->id * 0x2000), 0x00030000, 0x00030000);\n\tnvkm_wr32(device, 0x040148 + (runq->id * 0x2000), 0x80000000);\n\treturn true;\n}\n\nconst struct nvkm_runq_func\ngv100_runq = {\n\t.init = gk208_runq_init,\n\t.intr = gk104_runq_intr,\n\t.intr_0_names = gk104_runq_intr_0_names,\n\t.intr_1_ctxnotvalid = gv100_runq_intr_1_ctxnotvalid,\n\t.idle = gk104_runq_idle,\n};\n\nvoid\ngv100_runl_preempt(struct nvkm_runl *runl)\n{\n\tnvkm_wr32(runl->fifo->engine.subdev.device, 0x002638, BIT(runl->id));\n}\n\nvoid\ngv100_runl_insert_chan(struct nvkm_chan *chan, struct nvkm_memory *memory, u64 offset)\n{\n\tconst u64 user = nvkm_memory_addr(chan->userd.mem) + chan->userd.base;\n\tconst u64 inst = chan->inst->addr;\n\n\tnvkm_wo32(memory, offset + 0x0, lower_32_bits(user) | chan->runq << 1);\n\tnvkm_wo32(memory, offset + 0x4, upper_32_bits(user));\n\tnvkm_wo32(memory, offset + 0x8, lower_32_bits(inst) | chan->id);\n\tnvkm_wo32(memory, offset + 0xc, upper_32_bits(inst));\n}\n\nvoid\ngv100_runl_insert_cgrp(struct nvkm_cgrp *cgrp, struct nvkm_memory *memory, u64 offset)\n{\n\tnvkm_wo32(memory, offset + 0x0, (128 << 24) | (3 << 16) | 0x00000001);\n\tnvkm_wo32(memory, offset + 0x4, cgrp->chan_nr);\n\tnvkm_wo32(memory, offset + 0x8, cgrp->id);\n\tnvkm_wo32(memory, offset + 0xc, 0x00000000);\n}\n\nstatic const struct nvkm_runl_func\ngv100_runl = {\n\t.runqs = 2,\n\t.size = 16,\n\t.update = nv50_runl_update,\n\t.insert_cgrp = gv100_runl_insert_cgrp,\n\t.insert_chan = gv100_runl_insert_chan,\n\t.commit = gk104_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = gk104_runl_pending,\n\t.block = gk104_runl_block,\n\t.allow = gk104_runl_allow,\n\t.preempt = gv100_runl_preempt,\n\t.preempt_pending = gf100_runl_preempt_pending,\n};\n\nconst struct nvkm_enum\ngv100_fifo_mmu_fault_gpcclient[] = {\n\t{ 0x00, \"T1_0\" },\n\t{ 0x01, \"T1_1\" },\n\t{ 0x02, \"T1_2\" },\n\t{ 0x03, \"T1_3\" },\n\t{ 0x04, \"T1_4\" },\n\t{ 0x05, \"T1_5\" },\n\t{ 0x06, \"T1_6\" },\n\t{ 0x07, \"T1_7\" },\n\t{ 0x08, \"PE_0\" },\n\t{ 0x09, \"PE_1\" },\n\t{ 0x0a, \"PE_2\" },\n\t{ 0x0b, \"PE_3\" },\n\t{ 0x0c, \"PE_4\" },\n\t{ 0x0d, \"PE_5\" },\n\t{ 0x0e, \"PE_6\" },\n\t{ 0x0f, \"PE_7\" },\n\t{ 0x10, \"RAST\" },\n\t{ 0x11, \"GCC\" },\n\t{ 0x12, \"GPCCS\" },\n\t{ 0x13, \"PROP_0\" },\n\t{ 0x14, \"PROP_1\" },\n\t{ 0x15, \"PROP_2\" },\n\t{ 0x16, \"PROP_3\" },\n\t{ 0x17, \"GPM\" },\n\t{ 0x18, \"LTP_UTLB_0\" },\n\t{ 0x19, \"LTP_UTLB_1\" },\n\t{ 0x1a, \"LTP_UTLB_2\" },\n\t{ 0x1b, \"LTP_UTLB_3\" },\n\t{ 0x1c, \"LTP_UTLB_4\" },\n\t{ 0x1d, \"LTP_UTLB_5\" },\n\t{ 0x1e, \"LTP_UTLB_6\" },\n\t{ 0x1f, \"LTP_UTLB_7\" },\n\t{ 0x20, \"RGG_UTLB\" },\n\t{ 0x21, \"T1_8\" },\n\t{ 0x22, \"T1_9\" },\n\t{ 0x23, \"T1_10\" },\n\t{ 0x24, \"T1_11\" },\n\t{ 0x25, \"T1_12\" },\n\t{ 0x26, \"T1_13\" },\n\t{ 0x27, \"T1_14\" },\n\t{ 0x28, \"T1_15\" },\n\t{ 0x29, \"TPCCS_0\" },\n\t{ 0x2a, \"TPCCS_1\" },\n\t{ 0x2b, \"TPCCS_2\" },\n\t{ 0x2c, \"TPCCS_3\" },\n\t{ 0x2d, \"TPCCS_4\" },\n\t{ 0x2e, \"TPCCS_5\" },\n\t{ 0x2f, \"TPCCS_6\" },\n\t{ 0x30, \"TPCCS_7\" },\n\t{ 0x31, \"PE_8\" },\n\t{ 0x32, \"PE_9\" },\n\t{ 0x33, \"TPCCS_8\" },\n\t{ 0x34, \"TPCCS_9\" },\n\t{ 0x35, \"T1_16\" },\n\t{ 0x36, \"T1_17\" },\n\t{ 0x37, \"T1_18\" },\n\t{ 0x38, \"T1_19\" },\n\t{ 0x39, \"PE_10\" },\n\t{ 0x3a, \"PE_11\" },\n\t{ 0x3b, \"TPCCS_10\" },\n\t{ 0x3c, \"TPCCS_11\" },\n\t{ 0x3d, \"T1_20\" },\n\t{ 0x3e, \"T1_21\" },\n\t{ 0x3f, \"T1_22\" },\n\t{ 0x40, \"T1_23\" },\n\t{ 0x41, \"PE_12\" },\n\t{ 0x42, \"PE_13\" },\n\t{ 0x43, \"TPCCS_12\" },\n\t{ 0x44, \"TPCCS_13\" },\n\t{ 0x45, \"T1_24\" },\n\t{ 0x46, \"T1_25\" },\n\t{ 0x47, \"T1_26\" },\n\t{ 0x48, \"T1_27\" },\n\t{ 0x49, \"PE_14\" },\n\t{ 0x4a, \"PE_15\" },\n\t{ 0x4b, \"TPCCS_14\" },\n\t{ 0x4c, \"TPCCS_15\" },\n\t{ 0x4d, \"T1_28\" },\n\t{ 0x4e, \"T1_29\" },\n\t{ 0x4f, \"T1_30\" },\n\t{ 0x50, \"T1_31\" },\n\t{ 0x51, \"PE_16\" },\n\t{ 0x52, \"PE_17\" },\n\t{ 0x53, \"TPCCS_16\" },\n\t{ 0x54, \"TPCCS_17\" },\n\t{ 0x55, \"T1_32\" },\n\t{ 0x56, \"T1_33\" },\n\t{ 0x57, \"T1_34\" },\n\t{ 0x58, \"T1_35\" },\n\t{ 0x59, \"PE_18\" },\n\t{ 0x5a, \"PE_19\" },\n\t{ 0x5b, \"TPCCS_18\" },\n\t{ 0x5c, \"TPCCS_19\" },\n\t{ 0x5d, \"T1_36\" },\n\t{ 0x5e, \"T1_37\" },\n\t{ 0x5f, \"T1_38\" },\n\t{ 0x60, \"T1_39\" },\n\t{}\n};\n\nconst struct nvkm_enum\ngv100_fifo_mmu_fault_hubclient[] = {\n\t{ 0x00, \"VIP\" },\n\t{ 0x01, \"CE0\" },\n\t{ 0x02, \"CE1\" },\n\t{ 0x03, \"DNISO\" },\n\t{ 0x04, \"FE\" },\n\t{ 0x05, \"FECS\" },\n\t{ 0x06, \"HOST\" },\n\t{ 0x07, \"HOST_CPU\" },\n\t{ 0x08, \"HOST_CPU_NB\" },\n\t{ 0x09, \"ISO\" },\n\t{ 0x0a, \"MMU\" },\n\t{ 0x0b, \"NVDEC\" },\n\t{ 0x0d, \"NVENC1\" },\n\t{ 0x0e, \"NISO\" },\n\t{ 0x0f, \"P2P\" },\n\t{ 0x10, \"PD\" },\n\t{ 0x11, \"PERF\" },\n\t{ 0x12, \"PMU\" },\n\t{ 0x13, \"RASTERTWOD\" },\n\t{ 0x14, \"SCC\" },\n\t{ 0x15, \"SCC_NB\" },\n\t{ 0x16, \"SEC\" },\n\t{ 0x17, \"SSYNC\" },\n\t{ 0x18, \"CE2\" },\n\t{ 0x19, \"XV\" },\n\t{ 0x1a, \"MMU_NB\" },\n\t{ 0x1b, \"NVENC0\" },\n\t{ 0x1c, \"DFALCON\" },\n\t{ 0x1d, \"SKED\" },\n\t{ 0x1e, \"AFALCON\" },\n\t{ 0x1f, \"DONT_CARE\" },\n\t{ 0x20, \"HSCE0\" },\n\t{ 0x21, \"HSCE1\" },\n\t{ 0x22, \"HSCE2\" },\n\t{ 0x23, \"HSCE3\" },\n\t{ 0x24, \"HSCE4\" },\n\t{ 0x25, \"HSCE5\" },\n\t{ 0x26, \"HSCE6\" },\n\t{ 0x27, \"HSCE7\" },\n\t{ 0x28, \"HSCE8\" },\n\t{ 0x29, \"HSCE9\" },\n\t{ 0x2a, \"HSHUB\" },\n\t{ 0x2b, \"PTP_X0\" },\n\t{ 0x2c, \"PTP_X1\" },\n\t{ 0x2d, \"PTP_X2\" },\n\t{ 0x2e, \"PTP_X3\" },\n\t{ 0x2f, \"PTP_X4\" },\n\t{ 0x30, \"PTP_X5\" },\n\t{ 0x31, \"PTP_X6\" },\n\t{ 0x32, \"PTP_X7\" },\n\t{ 0x33, \"NVENC2\" },\n\t{ 0x34, \"VPR_SCRUBBER0\" },\n\t{ 0x35, \"VPR_SCRUBBER1\" },\n\t{ 0x36, \"DWBIF\" },\n\t{ 0x37, \"FBFALCON\" },\n\t{ 0x38, \"CE_SHIM\" },\n\t{ 0x39, \"GSP\" },\n\t{}\n};\n\nconst struct nvkm_enum\ngv100_fifo_mmu_fault_reason[] = {\n\t{ 0x00, \"PDE\" },\n\t{ 0x01, \"PDE_SIZE\" },\n\t{ 0x02, \"PTE\" },\n\t{ 0x03, \"VA_LIMIT_VIOLATION\" },\n\t{ 0x04, \"UNBOUND_INST_BLOCK\" },\n\t{ 0x05, \"PRIV_VIOLATION\" },\n\t{ 0x06, \"RO_VIOLATION\" },\n\t{ 0x07, \"WO_VIOLATION\" },\n\t{ 0x08, \"PITCH_MASK_VIOLATION\" },\n\t{ 0x09, \"WORK_CREATION\" },\n\t{ 0x0a, \"UNSUPPORTED_APERTURE\" },\n\t{ 0x0b, \"COMPRESSION_FAILURE\" },\n\t{ 0x0c, \"UNSUPPORTED_KIND\" },\n\t{ 0x0d, \"REGION_VIOLATION\" },\n\t{ 0x0e, \"POISONED\" },\n\t{ 0x0f, \"ATOMIC_VIOLATION\" },\n\t{}\n};\n\nstatic const struct nvkm_enum\ngv100_fifo_mmu_fault_engine[] = {\n\t{ 0x01, \"DISPLAY\" },\n\t{ 0x03, \"PTP\" },\n\t{ 0x04, \"BAR1\", NULL, NVKM_SUBDEV_BAR },\n\t{ 0x05, \"BAR2\", NULL, NVKM_SUBDEV_INSTMEM },\n\t{ 0x06, \"PWR_PMU\" },\n\t{ 0x08, \"IFB\", NULL, NVKM_ENGINE_IFB },\n\t{ 0x09, \"PERF\" },\n\t{ 0x1f, \"PHYSICAL\" },\n\t{ 0x20, \"HOST0\" },\n\t{ 0x21, \"HOST1\" },\n\t{ 0x22, \"HOST2\" },\n\t{ 0x23, \"HOST3\" },\n\t{ 0x24, \"HOST4\" },\n\t{ 0x25, \"HOST5\" },\n\t{ 0x26, \"HOST6\" },\n\t{ 0x27, \"HOST7\" },\n\t{ 0x28, \"HOST8\" },\n\t{ 0x29, \"HOST9\" },\n\t{ 0x2a, \"HOST10\" },\n\t{ 0x2b, \"HOST11\" },\n\t{ 0x2c, \"HOST12\" },\n\t{ 0x2d, \"HOST13\" },\n\t{}\n};\n\nconst struct nvkm_enum\ngv100_fifo_mmu_fault_access[] = {\n\t{ 0x0, \"VIRT_READ\" },\n\t{ 0x1, \"VIRT_WRITE\" },\n\t{ 0x2, \"VIRT_ATOMIC\" },\n\t{ 0x3, \"VIRT_PREFETCH\" },\n\t{ 0x4, \"VIRT_ATOMIC_WEAK\" },\n\t{ 0x8, \"PHYS_READ\" },\n\t{ 0x9, \"PHYS_WRITE\" },\n\t{ 0xa, \"PHYS_ATOMIC\" },\n\t{ 0xb, \"PHYS_PREFETCH\" },\n\t{}\n};\n\nstatic const struct nvkm_fifo_func_mmu_fault\ngv100_fifo_mmu_fault = {\n\t.recover = gf100_fifo_mmu_fault_recover,\n\t.access = gv100_fifo_mmu_fault_access,\n\t.engine = gv100_fifo_mmu_fault_engine,\n\t.reason = gv100_fifo_mmu_fault_reason,\n\t.hubclient = gv100_fifo_mmu_fault_hubclient,\n\t.gpcclient = gv100_fifo_mmu_fault_gpcclient,\n};\n\nstatic void\ngv100_fifo_intr_ctxsw_timeout(struct nvkm_fifo *fifo, u32 engm)\n{\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\n\tnvkm_runl_foreach(runl, fifo) {\n\t\tnvkm_runl_foreach_engn_cond(engn, runl, engm & BIT(engn->id))\n\t\t\tnvkm_runl_rc_engn(runl, engn);\n\t}\n}\n\nstatic const struct nvkm_fifo_func\ngv100_fifo = {\n\t.chid_nr = gm200_fifo_chid_nr,\n\t.chid_ctor = gk110_fifo_chid_ctor,\n\t.runq_nr = gm200_fifo_runq_nr,\n\t.runl_ctor = gk104_fifo_runl_ctor,\n\t.init = gk104_fifo_init,\n\t.init_pbdmas = gk104_fifo_init_pbdmas,\n\t.intr = gk104_fifo_intr,\n\t.intr_ctxsw_timeout = gv100_fifo_intr_ctxsw_timeout,\n\t.mmu_fault = &gv100_fifo_mmu_fault,\n\t.nonstall = &gf100_fifo_nonstall,\n\t.runl = &gv100_runl,\n\t.runq = &gv100_runq,\n\t.engn = &gv100_engn,\n\t.engn_ce = &gv100_engn_ce,\n\t.cgrp = {{ 0, 0, KEPLER_CHANNEL_GROUP_A  }, &gk110_cgrp, .force = true },\n\t.chan = {{ 0, 0,  VOLTA_CHANNEL_GPFIFO_A }, &gv100_chan },\n};\n\nint\ngv100_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&gv100_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}