{
  "module_name": "gv100.c",
  "hash_id": "bfea88248d12294eac16a624a799303c57fa66401fb9d6d14995ee9920477947",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/gv100.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"hdmi.h\"\n#include \"head.h\"\n#include \"ior.h\"\n#include \"outp.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <core/ramht.h>\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n#include <nvif/unpack.h>\n\nstatic void\ngv100_sor_hda_device_entry(struct nvkm_ior *ior, int head)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 hoff = 0x800 * head;\n\n\tnvkm_mask(device, 0x616528 + hoff, 0x00000070, head << 4);\n}\n\nconst struct nvkm_ior_func_hda\ngv100_sor_hda = {\n\t.hpd = gf119_sor_hda_hpd,\n\t.eld = gf119_sor_hda_eld,\n\t.device_entry = gv100_sor_hda_device_entry,\n};\n\nvoid\ngv100_sor_dp_watermark(struct nvkm_ior *sor, int head, u8 watermark)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x616550 + hoff, 0x0c00003f, 0x08000000 | watermark);\n}\n\nvoid\ngv100_sor_dp_audio_sym(struct nvkm_ior *sor, int head, u16 h, u32 v)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = head * 0x800;\n\n\tnvkm_mask(device, 0x616568 + hoff, 0x0000ffff, h);\n\tnvkm_mask(device, 0x61656c + hoff, 0x00ffffff, v);\n}\n\nvoid\ngv100_sor_dp_audio(struct nvkm_ior *sor, int head, bool enable)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 hoff = 0x800 * head;\n\tconst u32 data = 0x80000000 | (0x00000001 * enable);\n\tconst u32 mask = 0x8000000d;\n\n\tnvkm_mask(device, 0x616560 + hoff, mask, data);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x616560 + hoff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nstatic const struct nvkm_ior_func_dp\ngv100_sor_dp = {\n\t.lanes = { 0, 1, 2, 3 },\n\t.links = gf119_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = gm107_sor_dp_pattern,\n\t.drive = gm200_sor_dp_drive,\n\t.audio = gv100_sor_dp_audio,\n\t.audio_sym = gv100_sor_dp_audio_sym,\n\t.watermark = gv100_sor_dp_watermark,\n};\n\nstatic void\ngv100_sor_hdmi_infoframe_vsi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe vsi;\n\tconst u32 hoff = head * 0x400;\n\n\tpack_hdmi_infoframe(&vsi, data, size);\n\n\tnvkm_mask(device, 0x6f0100 + hoff, 0x00010001, 0x00000000);\n\tif (!size)\n\t\treturn;\n\n\tnvkm_wr32(device, 0x6f0108 + hoff, vsi.header);\n\tnvkm_wr32(device, 0x6f010c + hoff, vsi.subpack0_low);\n\tnvkm_wr32(device, 0x6f0110 + hoff, vsi.subpack0_high);\n\tnvkm_wr32(device, 0x6f0114 + hoff, 0x00000000);\n\tnvkm_wr32(device, 0x6f0118 + hoff, 0x00000000);\n\tnvkm_wr32(device, 0x6f011c + hoff, 0x00000000);\n\tnvkm_wr32(device, 0x6f0120 + hoff, 0x00000000);\n\tnvkm_wr32(device, 0x6f0124 + hoff, 0x00000000);\n\tnvkm_mask(device, 0x6f0100 + hoff, 0x00000001, 0x00000001);\n}\n\nstatic void\ngv100_sor_hdmi_infoframe_avi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe avi;\n\tconst u32 hoff = head * 0x400;\n\n\tpack_hdmi_infoframe(&avi, data, size);\n\n\tnvkm_mask(device, 0x6f0000 + hoff, 0x00000001, 0x00000000);\n\tif (!size)\n\t\treturn;\n\n\tnvkm_wr32(device, 0x6f0008 + hoff, avi.header);\n\tnvkm_wr32(device, 0x6f000c + hoff, avi.subpack0_low);\n\tnvkm_wr32(device, 0x6f0010 + hoff, avi.subpack0_high);\n\tnvkm_wr32(device, 0x6f0014 + hoff, avi.subpack1_low);\n\tnvkm_wr32(device, 0x6f0018 + hoff, avi.subpack1_high);\n\n\tnvkm_mask(device, 0x6f0000 + hoff, 0x00000001, 0x00000001);\n}\n\nstatic void\ngv100_sor_hdmi_ctrl(struct nvkm_ior *ior, int head, bool enable, u8 max_ac_packet, u8 rekey)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 ctrl = 0x40000000 * enable |\n\t\t\t max_ac_packet << 16 |\n\t\t\t rekey;\n\tconst u32 hoff = head * 0x800;\n\tconst u32 hdmi = head * 0x400;\n\n\tif (!(ctrl & 0x40000000)) {\n\t\tnvkm_mask(device, 0x6165c0 + hoff, 0x40000000, 0x00000000);\n\t\tnvkm_mask(device, 0x6f0100 + hdmi, 0x00000001, 0x00000000);\n\t\tnvkm_mask(device, 0x6f00c0 + hdmi, 0x00000001, 0x00000000);\n\t\tnvkm_mask(device, 0x6f0000 + hdmi, 0x00000001, 0x00000000);\n\t\treturn;\n\t}\n\n\t \n\tnvkm_mask(device, 0x6f00c0 + hdmi, 0x00000001, 0x00000000);\n\tnvkm_wr32(device, 0x6f00cc + hdmi, 0x00000010);\n\tnvkm_mask(device, 0x6f00c0 + hdmi, 0x00000001, 0x00000001);\n\n\t \n\tnvkm_wr32(device, 0x6f0080 + hdmi, 0x82000000);\n\n\t \n\tnvkm_mask(device, 0x6165c0 + hoff, 0x401f007f, ctrl);\n}\n\nconst struct nvkm_ior_func_hdmi\ngv100_sor_hdmi = {\n\t.ctrl = gv100_sor_hdmi_ctrl,\n\t.scdc = gm200_sor_hdmi_scdc,\n\t.infoframe_avi = gv100_sor_hdmi_infoframe_avi,\n\t.infoframe_vsi = gv100_sor_hdmi_infoframe_vsi,\n};\n\nvoid\ngv100_sor_state(struct nvkm_ior *sor, struct nvkm_ior_state *state)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 coff = (state == &sor->arm) * 0x8000 + sor->id * 0x20;\n\tu32 ctrl = nvkm_rd32(device, 0x680300 + coff);\n\n\tstate->proto_evo = (ctrl & 0x00000f00) >> 8;\n\tswitch (state->proto_evo) {\n\tcase 0: state->proto = LVDS; state->link = 1; break;\n\tcase 1: state->proto = TMDS; state->link = 1; break;\n\tcase 2: state->proto = TMDS; state->link = 2; break;\n\tcase 5: state->proto = TMDS; state->link = 3; break;\n\tcase 8: state->proto =   DP; state->link = 1; break;\n\tcase 9: state->proto =   DP; state->link = 2; break;\n\tdefault:\n\t\tstate->proto = UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->head = ctrl & 0x000000ff;\n}\n\nstatic const struct nvkm_ior_func\ngv100_sor = {\n\t.route = {\n\t\t.get = gm200_sor_route_get,\n\t\t.set = gm200_sor_route_set,\n\t},\n\t.state = gv100_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = gf119_sor_clock,\n\t.hdmi = &gv100_sor_hdmi,\n\t.dp = &gv100_sor_dp,\n\t.hda = &gv100_sor_hda,\n};\n\nstatic int\ngv100_sor_new(struct nvkm_disp *disp, int id)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tu32 hda;\n\n\tif (!((hda = nvkm_rd32(device, 0x08a15c)) & 0x40000000))\n\t\thda = nvkm_rd32(device, 0x118fb0) >> 8;\n\n\treturn nvkm_ior_new_(&gv100_sor, disp, SOR, id, hda & BIT(id));\n}\n\nint\ngv100_sor_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = (nvkm_rd32(device, 0x610060) & 0x0000ff00) >> 8;\n\treturn (nvkm_rd32(device, 0x610074) & 0x00000f00) >> 8;\n}\n\nstatic void\ngv100_head_vblank_put(struct nvkm_head *head)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tnvkm_mask(device, 0x611d80 + (head->id * 4), 0x00000004, 0x00000000);\n}\n\nstatic void\ngv100_head_vblank_get(struct nvkm_head *head)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tnvkm_mask(device, 0x611d80 + (head->id * 4), 0x00000004, 0x00000004);\n}\n\nstatic void\ngv100_head_rgpos(struct nvkm_head *head, u16 *hline, u16 *vline)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = head->id * 0x800;\n\t \n\t*vline = nvkm_rd32(device, 0x616330 + hoff) & 0x0000ffff;\n\t*hline = nvkm_rd32(device, 0x616334 + hoff) & 0x0000ffff;\n}\n\nstatic void\ngv100_head_state(struct nvkm_head *head, struct nvkm_head_state *state)\n{\n\tstruct nvkm_device *device = head->disp->engine.subdev.device;\n\tconst u32 hoff = (state == &head->arm) * 0x8000 + head->id * 0x400;\n\tu32 data;\n\n\tdata = nvkm_rd32(device, 0x682064 + hoff);\n\tstate->vtotal = (data & 0xffff0000) >> 16;\n\tstate->htotal = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x682068 + hoff);\n\tstate->vsynce = (data & 0xffff0000) >> 16;\n\tstate->hsynce = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x68206c + hoff);\n\tstate->vblanke = (data & 0xffff0000) >> 16;\n\tstate->hblanke = (data & 0x0000ffff);\n\tdata = nvkm_rd32(device, 0x682070 + hoff);\n\tstate->vblanks = (data & 0xffff0000) >> 16;\n\tstate->hblanks = (data & 0x0000ffff);\n\tstate->hz = nvkm_rd32(device, 0x68200c + hoff);\n\n\tdata = nvkm_rd32(device, 0x682004 + hoff);\n\tswitch ((data & 0x000000f0) >> 4) {\n\tcase 5: state->or.depth = 30; break;\n\tcase 4: state->or.depth = 24; break;\n\tcase 1: state->or.depth = 18; break;\n\tdefault:\n\t\tstate->or.depth = 18;\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic const struct nvkm_head_func\ngv100_head = {\n\t.state = gv100_head_state,\n\t.rgpos = gv100_head_rgpos,\n\t.rgclk = gf119_head_rgclk,\n\t.vblank_get = gv100_head_vblank_get,\n\t.vblank_put = gv100_head_vblank_put,\n};\n\nint\ngv100_head_new(struct nvkm_disp *disp, int id)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\tif (!(nvkm_rd32(device, 0x610060) & (0x00000001 << id)))\n\t\treturn 0;\n\n\treturn nvkm_head_new_(&gv100_head, disp, id);\n}\n\nint\ngv100_head_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = nvkm_rd32(device, 0x610060) & 0x000000ff;\n\treturn nvkm_rd32(device, 0x610074) & 0x0000000f;\n}\n\nconst struct nvkm_event_func\ngv100_disp_chan_uevent = {\n};\n\nu64\ngv100_disp_chan_user(struct nvkm_disp_chan *chan, u64 *psize)\n{\n\t*psize = 0x1000;\n\treturn 0x690000 + ((chan->chid.user - 1) * 0x1000);\n}\n\nstatic int\ngv100_disp_dmac_idle(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 soff = (chan->chid.ctrl - 1) * 0x04;\n\tnvkm_msec(device, 2000,\n\t\tu32 stat = nvkm_rd32(device, 0x610664 + soff);\n\t\tif ((stat & 0x000f0000) == 0x00040000)\n\t\t\treturn 0;\n\t);\n\treturn -EBUSY;\n}\n\nint\ngv100_disp_dmac_bind(struct nvkm_disp_chan *chan,\n\t\t     struct nvkm_object *object, u32 handle)\n{\n\treturn nvkm_ramht_insert(chan->disp->ramht, object, chan->chid.user, -9, handle,\n\t\t\t\t chan->chid.user << 25 | 0x00000040);\n}\n\nvoid\ngv100_disp_dmac_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 uoff = (chan->chid.ctrl - 1) * 0x1000;\n\tconst u32 coff = chan->chid.ctrl * 0x04;\n\tnvkm_mask(device, 0x6104e0 + coff, 0x00000010, 0x00000000);\n\tgv100_disp_dmac_idle(chan);\n\tnvkm_mask(device, 0x6104e0 + coff, 0x00000002, 0x00000000);\n\tchan->suspend_put = nvkm_rd32(device, 0x690000 + uoff);\n}\n\nint\ngv100_disp_dmac_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst u32 uoff = (chan->chid.ctrl - 1) * 0x1000;\n\tconst u32 poff = chan->chid.ctrl * 0x10;\n\tconst u32 coff = chan->chid.ctrl * 0x04;\n\n\tnvkm_wr32(device, 0x610b24 + poff, lower_32_bits(chan->push));\n\tnvkm_wr32(device, 0x610b20 + poff, upper_32_bits(chan->push));\n\tnvkm_wr32(device, 0x610b28 + poff, 0x00000001);\n\tnvkm_wr32(device, 0x610b2c + poff, 0x00000040);\n\n\tnvkm_mask(device, 0x6104e0 + coff, 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x690000 + uoff, chan->suspend_put);\n\tnvkm_wr32(device, 0x6104e0 + coff, 0x00000013);\n\treturn gv100_disp_dmac_idle(chan);\n}\n\nstatic void\ngv100_disp_wimm_intr(struct nvkm_disp_chan *chan, bool en)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 mask = 0x00000001 << chan->head;\n\tconst u32 data = en ? mask : 0;\n\tnvkm_mask(device, 0x611da8, mask, data);\n}\n\nstatic const struct nvkm_disp_chan_func\ngv100_disp_wimm_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gv100_disp_dmac_init,\n\t.fini = gv100_disp_dmac_fini,\n\t.intr = gv100_disp_wimm_intr,\n\t.user = gv100_disp_chan_user,\n};\n\nconst struct nvkm_disp_chan_user\ngv100_disp_wimm = {\n\t.func = &gv100_disp_wimm_func,\n\t.ctrl = 33,\n\t.user = 33,\n};\n\nstatic const struct nvkm_disp_mthd_list\ngv100_disp_wndw_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0200, 0x690200 },\n\t\t{ 0x020c, 0x69020c },\n\t\t{ 0x0210, 0x690210 },\n\t\t{ 0x0214, 0x690214 },\n\t\t{ 0x0218, 0x690218 },\n\t\t{ 0x021c, 0x69021c },\n\t\t{ 0x0220, 0x690220 },\n\t\t{ 0x0224, 0x690224 },\n\t\t{ 0x0228, 0x690228 },\n\t\t{ 0x022c, 0x69022c },\n\t\t{ 0x0230, 0x690230 },\n\t\t{ 0x0234, 0x690234 },\n\t\t{ 0x0238, 0x690238 },\n\t\t{ 0x0240, 0x690240 },\n\t\t{ 0x0244, 0x690244 },\n\t\t{ 0x0248, 0x690248 },\n\t\t{ 0x024c, 0x69024c },\n\t\t{ 0x0250, 0x690250 },\n\t\t{ 0x0254, 0x690254 },\n\t\t{ 0x0260, 0x690260 },\n\t\t{ 0x0264, 0x690264 },\n\t\t{ 0x0268, 0x690268 },\n\t\t{ 0x026c, 0x69026c },\n\t\t{ 0x0270, 0x690270 },\n\t\t{ 0x0274, 0x690274 },\n\t\t{ 0x0280, 0x690280 },\n\t\t{ 0x0284, 0x690284 },\n\t\t{ 0x0288, 0x690288 },\n\t\t{ 0x028c, 0x69028c },\n\t\t{ 0x0290, 0x690290 },\n\t\t{ 0x0298, 0x690298 },\n\t\t{ 0x029c, 0x69029c },\n\t\t{ 0x02a0, 0x6902a0 },\n\t\t{ 0x02a4, 0x6902a4 },\n\t\t{ 0x02a8, 0x6902a8 },\n\t\t{ 0x02ac, 0x6902ac },\n\t\t{ 0x02b0, 0x6902b0 },\n\t\t{ 0x02b4, 0x6902b4 },\n\t\t{ 0x02b8, 0x6902b8 },\n\t\t{ 0x02bc, 0x6902bc },\n\t\t{ 0x02c0, 0x6902c0 },\n\t\t{ 0x02c4, 0x6902c4 },\n\t\t{ 0x02c8, 0x6902c8 },\n\t\t{ 0x02cc, 0x6902cc },\n\t\t{ 0x02d0, 0x6902d0 },\n\t\t{ 0x02d4, 0x6902d4 },\n\t\t{ 0x02d8, 0x6902d8 },\n\t\t{ 0x02dc, 0x6902dc },\n\t\t{ 0x02e0, 0x6902e0 },\n\t\t{ 0x02e4, 0x6902e4 },\n\t\t{ 0x02e8, 0x6902e8 },\n\t\t{ 0x02ec, 0x6902ec },\n\t\t{ 0x02f0, 0x6902f0 },\n\t\t{ 0x02f4, 0x6902f4 },\n\t\t{ 0x02f8, 0x6902f8 },\n\t\t{ 0x02fc, 0x6902fc },\n\t\t{ 0x0300, 0x690300 },\n\t\t{ 0x0304, 0x690304 },\n\t\t{ 0x0308, 0x690308 },\n\t\t{ 0x0310, 0x690310 },\n\t\t{ 0x0314, 0x690314 },\n\t\t{ 0x0318, 0x690318 },\n\t\t{ 0x031c, 0x69031c },\n\t\t{ 0x0320, 0x690320 },\n\t\t{ 0x0324, 0x690324 },\n\t\t{ 0x0328, 0x690328 },\n\t\t{ 0x032c, 0x69032c },\n\t\t{ 0x033c, 0x69033c },\n\t\t{ 0x0340, 0x690340 },\n\t\t{ 0x0344, 0x690344 },\n\t\t{ 0x0348, 0x690348 },\n\t\t{ 0x034c, 0x69034c },\n\t\t{ 0x0350, 0x690350 },\n\t\t{ 0x0354, 0x690354 },\n\t\t{ 0x0358, 0x690358 },\n\t\t{ 0x0364, 0x690364 },\n\t\t{ 0x0368, 0x690368 },\n\t\t{ 0x036c, 0x69036c },\n\t\t{ 0x0370, 0x690370 },\n\t\t{ 0x0374, 0x690374 },\n\t\t{ 0x0380, 0x690380 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\ngv100_disp_wndw_mthd = {\n\t.name = \"Window\",\n\t.addr = 0x001000,\n\t.prev = 0x000800,\n\t.data = {\n\t\t{ \"Global\", 1, &gv100_disp_wndw_mthd_base },\n\t\t{}\n\t}\n};\n\nstatic void\ngv100_disp_wndw_intr(struct nvkm_disp_chan *chan, bool en)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 mask = 0x00000001 << chan->head;\n\tconst u32 data = en ? mask : 0;\n\tnvkm_mask(device, 0x611da4, mask, data);\n}\n\nstatic const struct nvkm_disp_chan_func\ngv100_disp_wndw_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gv100_disp_dmac_init,\n\t.fini = gv100_disp_dmac_fini,\n\t.intr = gv100_disp_wndw_intr,\n\t.user = gv100_disp_chan_user,\n\t.bind = gv100_disp_dmac_bind,\n};\n\nconst struct nvkm_disp_chan_user\ngv100_disp_wndw = {\n\t.func = &gv100_disp_wndw_func,\n\t.ctrl = 1,\n\t.user = 1,\n\t.mthd = &gv100_disp_wndw_mthd,\n};\n\nint\ngv100_disp_wndw_cnt(struct nvkm_disp *disp, unsigned long *pmask)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\n\t*pmask = nvkm_rd32(device, 0x610064);\n\treturn (nvkm_rd32(device, 0x610074) & 0x03f00000) >> 20;\n}\n\nstatic int\ngv100_disp_curs_idle(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 soff = (chan->chid.ctrl - 1) * 0x04;\n\tnvkm_msec(device, 2000,\n\t\tu32 stat = nvkm_rd32(device, 0x610664 + soff);\n\t\tif ((stat & 0x00070000) == 0x00040000)\n\t\t\treturn 0;\n\t);\n\treturn -EBUSY;\n}\n\nstatic void\ngv100_disp_curs_intr(struct nvkm_disp_chan *chan, bool en)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 mask = 0x00010000 << chan->head;\n\tconst u32 data = en ? mask : 0;\n\tnvkm_mask(device, 0x611dac, mask, data);\n}\n\nstatic void\ngv100_disp_curs_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 hoff = chan->chid.ctrl * 4;\n\tnvkm_mask(device, 0x6104e0 + hoff, 0x00000010, 0x00000010);\n\tgv100_disp_curs_idle(chan);\n\tnvkm_mask(device, 0x6104e0 + hoff, 0x00000001, 0x00000000);\n}\n\nstatic int\ngv100_disp_curs_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tnvkm_wr32(device, 0x6104e0 + chan->chid.ctrl * 4, 0x00000001);\n\treturn gv100_disp_curs_idle(chan);\n}\n\nstatic const struct nvkm_disp_chan_func\ngv100_disp_curs_func = {\n\t.init = gv100_disp_curs_init,\n\t.fini = gv100_disp_curs_fini,\n\t.intr = gv100_disp_curs_intr,\n\t.user = gv100_disp_chan_user,\n};\n\nconst struct nvkm_disp_chan_user\ngv100_disp_curs = {\n\t.func = &gv100_disp_curs_func,\n\t.ctrl = 73,\n\t.user = 73,\n};\n\nstatic const struct nvkm_disp_mthd_list\ngv100_disp_core_mthd_base = {\n\t.mthd = 0x0000,\n\t.addr = 0x000000,\n\t.data = {\n\t\t{ 0x0200, 0x680200 },\n\t\t{ 0x0208, 0x680208 },\n\t\t{ 0x020c, 0x68020c },\n\t\t{ 0x0210, 0x680210 },\n\t\t{ 0x0214, 0x680214 },\n\t\t{ 0x0218, 0x680218 },\n\t\t{ 0x021c, 0x68021c },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\ngv100_disp_core_mthd_sor = {\n\t.mthd = 0x0020,\n\t.addr = 0x000020,\n\t.data = {\n\t\t{ 0x0300, 0x680300 },\n\t\t{ 0x0304, 0x680304 },\n\t\t{ 0x0308, 0x680308 },\n\t\t{ 0x030c, 0x68030c },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\ngv100_disp_core_mthd_wndw = {\n\t.mthd = 0x0080,\n\t.addr = 0x000080,\n\t.data = {\n\t\t{ 0x1000, 0x681000 },\n\t\t{ 0x1004, 0x681004 },\n\t\t{ 0x1008, 0x681008 },\n\t\t{ 0x100c, 0x68100c },\n\t\t{ 0x1010, 0x681010 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_mthd_list\ngv100_disp_core_mthd_head = {\n\t.mthd = 0x0400,\n\t.addr = 0x000400,\n\t.data = {\n\t\t{ 0x2000, 0x682000 },\n\t\t{ 0x2004, 0x682004 },\n\t\t{ 0x2008, 0x682008 },\n\t\t{ 0x200c, 0x68200c },\n\t\t{ 0x2014, 0x682014 },\n\t\t{ 0x2018, 0x682018 },\n\t\t{ 0x201c, 0x68201c },\n\t\t{ 0x2020, 0x682020 },\n\t\t{ 0x2028, 0x682028 },\n\t\t{ 0x202c, 0x68202c },\n\t\t{ 0x2030, 0x682030 },\n\t\t{ 0x2038, 0x682038 },\n\t\t{ 0x203c, 0x68203c },\n\t\t{ 0x2048, 0x682048 },\n\t\t{ 0x204c, 0x68204c },\n\t\t{ 0x2050, 0x682050 },\n\t\t{ 0x2054, 0x682054 },\n\t\t{ 0x2058, 0x682058 },\n\t\t{ 0x205c, 0x68205c },\n\t\t{ 0x2060, 0x682060 },\n\t\t{ 0x2064, 0x682064 },\n\t\t{ 0x2068, 0x682068 },\n\t\t{ 0x206c, 0x68206c },\n\t\t{ 0x2070, 0x682070 },\n\t\t{ 0x2074, 0x682074 },\n\t\t{ 0x2078, 0x682078 },\n\t\t{ 0x207c, 0x68207c },\n\t\t{ 0x2080, 0x682080 },\n\t\t{ 0x2088, 0x682088 },\n\t\t{ 0x2090, 0x682090 },\n\t\t{ 0x209c, 0x68209c },\n\t\t{ 0x20a0, 0x6820a0 },\n\t\t{ 0x20a4, 0x6820a4 },\n\t\t{ 0x20a8, 0x6820a8 },\n\t\t{ 0x20ac, 0x6820ac },\n\t\t{ 0x2180, 0x682180 },\n\t\t{ 0x2184, 0x682184 },\n\t\t{ 0x218c, 0x68218c },\n\t\t{ 0x2194, 0x682194 },\n\t\t{ 0x2198, 0x682198 },\n\t\t{ 0x219c, 0x68219c },\n\t\t{ 0x21a0, 0x6821a0 },\n\t\t{ 0x21a4, 0x6821a4 },\n\t\t{ 0x2214, 0x682214 },\n\t\t{ 0x2218, 0x682218 },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_disp_chan_mthd\ngv100_disp_core_mthd = {\n\t.name = \"Core\",\n\t.addr = 0x000000,\n\t.prev = 0x008000,\n\t.data = {\n\t\t{ \"Global\", 1, &gv100_disp_core_mthd_base },\n\t\t{    \"SOR\", 4, &gv100_disp_core_mthd_sor  },\n\t\t{ \"WINDOW\", 8, &gv100_disp_core_mthd_wndw },\n\t\t{   \"HEAD\", 4, &gv100_disp_core_mthd_head },\n\t\t{}\n\t}\n};\n\nstatic int\ngv100_disp_core_idle(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tnvkm_msec(device, 2000,\n\t\tu32 stat = nvkm_rd32(device, 0x610630);\n\t\tif ((stat & 0x001f0000) == 0x000b0000)\n\t\t\treturn 0;\n\t);\n\treturn -EBUSY;\n}\n\nstatic u64\ngv100_disp_core_user(struct nvkm_disp_chan *chan, u64 *psize)\n{\n\t*psize = 0x10000;\n\treturn 0x680000;\n}\n\nstatic void\ngv100_disp_core_intr(struct nvkm_disp_chan *chan, bool en)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tconst u32 mask = 0x00000001;\n\tconst u32 data = en ? mask : 0;\n\tnvkm_mask(device, 0x611dac, mask, data);\n}\n\nstatic void\ngv100_disp_core_fini(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_device *device = chan->disp->engine.subdev.device;\n\tnvkm_mask(device, 0x6104e0, 0x00000010, 0x00000000);\n\tgv100_disp_core_idle(chan);\n\tnvkm_mask(device, 0x6104e0, 0x00000002, 0x00000000);\n\tchan->suspend_put = nvkm_rd32(device, 0x680000);\n}\n\nstatic int\ngv100_disp_core_init(struct nvkm_disp_chan *chan)\n{\n\tstruct nvkm_subdev *subdev = &chan->disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\tnvkm_wr32(device, 0x610b24, lower_32_bits(chan->push));\n\tnvkm_wr32(device, 0x610b20, upper_32_bits(chan->push));\n\tnvkm_wr32(device, 0x610b28, 0x00000001);\n\tnvkm_wr32(device, 0x610b2c, 0x00000040);\n\n\tnvkm_mask(device, 0x6104e0, 0x00000010, 0x00000010);\n\tnvkm_wr32(device, 0x680000, chan->suspend_put);\n\tnvkm_wr32(device, 0x6104e0, 0x00000013);\n\treturn gv100_disp_core_idle(chan);\n}\n\nstatic const struct nvkm_disp_chan_func\ngv100_disp_core_func = {\n\t.push = nv50_disp_dmac_push,\n\t.init = gv100_disp_core_init,\n\t.fini = gv100_disp_core_fini,\n\t.intr = gv100_disp_core_intr,\n\t.user = gv100_disp_core_user,\n\t.bind = gv100_disp_dmac_bind,\n};\n\nconst struct nvkm_disp_chan_user\ngv100_disp_core = {\n\t.func = &gv100_disp_core_func,\n\t.ctrl = 0,\n\t.user = 0,\n\t.mthd = &gv100_disp_core_mthd,\n};\n\n#define gv100_disp_caps(p) container_of((p), struct gv100_disp_caps, object)\n\nstruct gv100_disp_caps {\n\tstruct nvkm_object object;\n\tstruct nvkm_disp *disp;\n};\n\nstatic int\ngv100_disp_caps_map(struct nvkm_object *object, void *argv, u32 argc,\n\t\t    enum nvkm_object_map *type, u64 *addr, u64 *size)\n{\n\tstruct gv100_disp_caps *caps = gv100_disp_caps(object);\n\tstruct nvkm_device *device = caps->disp->engine.subdev.device;\n\t*type = NVKM_OBJECT_MAP_IO;\n\t*addr = 0x640000 + device->func->resource_addr(device, 0);\n\t*size = 0x1000;\n\treturn 0;\n}\n\nstatic const struct nvkm_object_func\ngv100_disp_caps = {\n\t.map = gv100_disp_caps_map,\n};\n\nint\ngv100_disp_caps_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t    struct nvkm_object **pobject)\n{\n\tstruct nvkm_disp *disp = nvkm_udisp(oclass->parent);\n\tstruct gv100_disp_caps *caps;\n\n\tif (!(caps = kzalloc(sizeof(*caps), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &caps->object;\n\n\tnvkm_object_ctor(&gv100_disp_caps, oclass, &caps->object);\n\tcaps->disp = disp;\n\treturn 0;\n}\n\nvoid\ngv100_disp_super(struct work_struct *work)\n{\n\tstruct nvkm_disp *disp = container_of(work, struct nvkm_disp, super.work);\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_head *head;\n\tu32 stat, mask[4];\n\n\tmutex_lock(&disp->super.mutex);\n\tstat = nvkm_rd32(device, 0x6107a8);\n\n\tnvkm_debug(subdev, \"supervisor %d: %08x\\n\", ffs(disp->super.pending), stat);\n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tmask[head->id] = nvkm_rd32(device, 0x6107ac + (head->id * 4));\n\t\tHEAD_DBG(head, \"%08x\", mask[head->id]);\n\t}\n\n\tif (disp->super.pending & 0x00000001) {\n\t\tnv50_disp_chan_mthd(disp->chan[0], NV_DBG_DEBUG);\n\t\tnv50_disp_super_1(disp);\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_1_0(disp, head);\n\t\t}\n\t} else\n\tif (disp->super.pending & 0x00000002) {\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_0(disp, head);\n\t\t}\n\t\tnvkm_outp_route(disp);\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00010000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_1(disp, head);\n\t\t}\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_2_2(disp, head);\n\t\t}\n\t} else\n\tif (disp->super.pending & 0x00000004) {\n\t\tlist_for_each_entry(head, &disp->heads, head) {\n\t\t\tif (!(mask[head->id] & 0x00001000))\n\t\t\t\tcontinue;\n\t\t\tnv50_disp_super_3_0(disp, head);\n\t\t}\n\t}\n\n\tlist_for_each_entry(head, &disp->heads, head)\n\t\tnvkm_wr32(device, 0x6107ac + (head->id * 4), 0x00000000);\n\n\tnvkm_wr32(device, 0x6107a8, 0x80000000);\n\tmutex_unlock(&disp->super.mutex);\n}\n\nstatic void\ngv100_disp_exception(struct nvkm_disp *disp, int chid)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x611020 + (chid * 12));\n\tu32 type = (stat & 0x00007000) >> 12;\n\tu32 mthd = (stat & 0x00000fff) << 2;\n\tconst struct nvkm_enum *reason =\n\t\tnvkm_enum_find(nv50_disp_intr_error_type, type);\n\n\t \n\tif (chid <= 32) {\n\t\tu32 data = nvkm_rd32(device, 0x611024 + (chid * 12));\n\t\tu32 code = nvkm_rd32(device, 0x611028 + (chid * 12));\n\t\tnvkm_error(subdev, \"chid %d stat %08x reason %d [%s] \"\n\t\t\t\t   \"mthd %04x data %08x code %08x\\n\",\n\t\t\t   chid, stat, type, reason ? reason->name : \"\",\n\t\t\t   mthd, data, code);\n\t} else {\n\t\tnvkm_error(subdev, \"chid %d stat %08x reason %d [%s] \"\n\t\t\t\t   \"mthd %04x\\n\",\n\t\t\t   chid, stat, type, reason ? reason->name : \"\", mthd);\n\t}\n\n\tif (chid < ARRAY_SIZE(disp->chan) && disp->chan[chid]) {\n\t\tswitch (mthd) {\n\t\tcase 0x0200:\n\t\t\tnv50_disp_chan_mthd(disp->chan[chid], NV_DBG_ERROR);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x611020 + (chid * 12), 0x90000000);\n}\n\nstatic void\ngv100_disp_intr_ctrl_disp(struct nvkm_disp *disp)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x611c30);\n\n\tif (stat & 0x00000007) {\n\t\tdisp->super.pending = (stat & 0x00000007);\n\t\tqueue_work(disp->super.wq, &disp->super.work);\n\t\tnvkm_wr32(device, 0x611860, disp->super.pending);\n\t\tstat &= ~0x00000007;\n\t}\n\n\t \n\tif (stat & 0x00000008)\n\t\tstat &= ~0x00000008;\n\n\tif (stat & 0x00000080) {\n\t\tu32 error = nvkm_mask(device, 0x611848, 0x00000000, 0x00000000);\n\t\tnvkm_warn(subdev, \"error %08x\\n\", error);\n\t\tstat &= ~0x00000080;\n\t}\n\n\tif (stat & 0x00000100) {\n\t\tunsigned long wndws = nvkm_rd32(device, 0x611858);\n\t\tunsigned long other = nvkm_rd32(device, 0x61185c);\n\t\tint wndw;\n\n\t\tnvkm_wr32(device, 0x611858, wndws);\n\t\tnvkm_wr32(device, 0x61185c, other);\n\n\t\t \n\t\tif (other & 0x00000001)\n\t\t\tnv50_disp_chan_uevent_send(disp, 0);\n\n\t\t \n\t\tfor_each_set_bit(wndw, &wndws, disp->wndw.nr) {\n\t\t\tnv50_disp_chan_uevent_send(disp, 1 + wndw);\n\t\t}\n\t}\n\n\tif (stat)\n\t\tnvkm_warn(subdev, \"ctrl %08x\\n\", stat);\n}\n\nstatic void\ngv100_disp_intr_exc_other(struct nvkm_disp *disp)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x611854);\n\tunsigned long mask;\n\tint head;\n\n\tif (stat & 0x00000001) {\n\t\tnvkm_wr32(device, 0x611854, 0x00000001);\n\t\tgv100_disp_exception(disp, 0);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif ((mask = (stat & 0x00ff0000) >> 16)) {\n\t\tfor_each_set_bit(head, &mask, disp->wndw.nr) {\n\t\t\tnvkm_wr32(device, 0x611854, 0x00010000 << head);\n\t\t\tgv100_disp_exception(disp, 73 + head);\n\t\t\tstat &= ~(0x00010000 << head);\n\t\t}\n\t}\n\n\tif (stat) {\n\t\tnvkm_warn(subdev, \"exception %08x\\n\", stat);\n\t\tnvkm_wr32(device, 0x611854, stat);\n\t}\n}\n\nstatic void\ngv100_disp_intr_exc_winim(struct nvkm_disp *disp)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tunsigned long stat = nvkm_rd32(device, 0x611850);\n\tint wndw;\n\n\tfor_each_set_bit(wndw, &stat, disp->wndw.nr) {\n\t\tnvkm_wr32(device, 0x611850, BIT(wndw));\n\t\tgv100_disp_exception(disp, 33 + wndw);\n\t\tstat &= ~BIT(wndw);\n\t}\n\n\tif (stat) {\n\t\tnvkm_warn(subdev, \"wimm %08x\\n\", (u32)stat);\n\t\tnvkm_wr32(device, 0x611850, stat);\n\t}\n}\n\nstatic void\ngv100_disp_intr_exc_win(struct nvkm_disp *disp)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tunsigned long stat = nvkm_rd32(device, 0x61184c);\n\tint wndw;\n\n\tfor_each_set_bit(wndw, &stat, disp->wndw.nr) {\n\t\tnvkm_wr32(device, 0x61184c, BIT(wndw));\n\t\tgv100_disp_exception(disp, 1 + wndw);\n\t\tstat &= ~BIT(wndw);\n\t}\n\n\tif (stat) {\n\t\tnvkm_warn(subdev, \"wndw %08x\\n\", (u32)stat);\n\t\tnvkm_wr32(device, 0x61184c, stat);\n\t}\n}\n\nstatic void\ngv100_disp_intr_head_timing(struct nvkm_disp *disp, int head)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x611800 + (head * 0x04));\n\n\t \n\tif (stat & 0x00000003) {\n\t\tnvkm_wr32(device, 0x611800 + (head * 0x04), stat & 0x00000003);\n\t\tstat &= ~0x00000003;\n\t}\n\n\tif (stat & 0x00000004) {\n\t\tnvkm_disp_vblank(disp, head);\n\t\tnvkm_wr32(device, 0x611800 + (head * 0x04), 0x00000004);\n\t\tstat &= ~0x00000004;\n\t}\n\n\tif (stat) {\n\t\tnvkm_warn(subdev, \"head %08x\\n\", stat);\n\t\tnvkm_wr32(device, 0x611800 + (head * 0x04), stat);\n\t}\n}\n\nvoid\ngv100_disp_intr(struct nvkm_disp *disp)\n{\n\tstruct nvkm_subdev *subdev = &disp->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x611ec0);\n\tunsigned long mask;\n\tint head;\n\n\tif ((mask = (stat & 0x000000ff))) {\n\t\tfor_each_set_bit(head, &mask, 8) {\n\t\t\tgv100_disp_intr_head_timing(disp, head);\n\t\t\tstat &= ~BIT(head);\n\t\t}\n\t}\n\n\tif (stat & 0x00000200) {\n\t\tgv100_disp_intr_exc_win(disp);\n\t\tstat &= ~0x00000200;\n\t}\n\n\tif (stat & 0x00000400) {\n\t\tgv100_disp_intr_exc_winim(disp);\n\t\tstat &= ~0x00000400;\n\t}\n\n\tif (stat & 0x00000800) {\n\t\tgv100_disp_intr_exc_other(disp);\n\t\tstat &= ~0x00000800;\n\t}\n\n\tif (stat & 0x00001000) {\n\t\tgv100_disp_intr_ctrl_disp(disp);\n\t\tstat &= ~0x00001000;\n\t}\n\n\tif (stat)\n\t\tnvkm_warn(subdev, \"intr %08x\\n\", stat);\n}\n\nvoid\ngv100_disp_fini(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tnvkm_wr32(device, 0x611db0, 0x00000000);\n}\n\nstatic int\ngv100_disp_init(struct nvkm_disp *disp)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tstruct nvkm_head *head;\n\tint i, j;\n\tu32 tmp;\n\n\t \n\tif (nvkm_rd32(device, 0x6254e8) & 0x00000002) {\n\t\tnvkm_mask(device, 0x6254e8, 0x00000001, 0x00000000);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x6254e8) & 0x00000002))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\t}\n\n\t \n\ttmp = nvkm_rd32(device, 0x610068);\n\tnvkm_wr32(device, 0x640008, tmp);\n\n\t \n\tfor (i = 0; i < disp->sor.nr; i++) {\n\t\ttmp = nvkm_rd32(device, 0x61c000 + (i * 0x800));\n\t\tnvkm_mask(device, 0x640000, 0x00000100 << i, 0x00000100 << i);\n\t\tnvkm_wr32(device, 0x640144 + (i * 0x08), tmp);\n\t}\n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst int id = head->id;\n\n\t\t \n\t\ttmp = nvkm_rd32(device, 0x616300 + (id * 0x800));\n\t\tnvkm_wr32(device, 0x640048 + (id * 0x020), tmp);\n\n\t\t \n\t\tfor (j = 0; j < 6 * 4; j += 4) {\n\t\t\ttmp = nvkm_rd32(device, 0x616100 + (id * 0x800) + j);\n\t\t\tnvkm_wr32(device, 0x640030 + (id * 0x20) + j, tmp);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < disp->wndw.nr; i++) {\n\t\tnvkm_mask(device, 0x640004, 1 << i, 1 << i);\n\t\tfor (j = 0; j < 6 * 4; j += 4) {\n\t\t\ttmp = nvkm_rd32(device, 0x630050 + (i * 0x800) + j);\n\t\t\tnvkm_wr32(device, 0x6401e4 + (i * 0x20) + j, tmp);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\ttmp = nvkm_rd32(device, 0x62e000 + (i * 0x04));\n\t\tnvkm_wr32(device, 0x640010 + (i * 0x04), tmp);\n\t}\n\n\tnvkm_mask(device, 0x610078, 0x00000001, 0x00000001);\n\n\t \n\tswitch (nvkm_memory_target(disp->inst->memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: tmp = 0x00000001; break;\n\tcase NVKM_MEM_TARGET_NCOH: tmp = 0x00000002; break;\n\tcase NVKM_MEM_TARGET_HOST: tmp = 0x00000003; break;\n\tdefault:\n\t\tbreak;\n\t}\n\tnvkm_wr32(device, 0x610010, 0x00000008 | tmp);\n\tnvkm_wr32(device, 0x610014, disp->inst->addr >> 16);\n\n\t \n\tnvkm_wr32(device, 0x611cf0, 0x00000187);  \n\tnvkm_wr32(device, 0x611db0, 0x00000187);  \n\n\t \n\tnvkm_wr32(device, 0x611cec, disp->head.mask << 16 |\n\t\t\t\t    0x00000001);  \n\tnvkm_wr32(device, 0x611dac, 0x00000000);  \n\n\t \n\tnvkm_wr32(device, 0x611ce8, disp->wndw.mask);  \n\tnvkm_wr32(device, 0x611da8, 0x00000000);  \n\n\t \n\tnvkm_wr32(device, 0x611ce4, disp->wndw.mask);  \n\tnvkm_wr32(device, 0x611da4, 0x00000000);  \n\n\t \n\tlist_for_each_entry(head, &disp->heads, head) {\n\t\tconst u32 hoff = head->id * 4;\n\t\tnvkm_wr32(device, 0x611cc0 + hoff, 0x00000004);  \n\t\tnvkm_wr32(device, 0x611d80 + hoff, 0x00000000);  \n\t}\n\n\t \n\tnvkm_wr32(device, 0x611cf4, 0x00000000);  \n\tnvkm_wr32(device, 0x611db4, 0x00000000);  \n\treturn 0;\n}\n\nstatic const struct nvkm_disp_func\ngv100_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = gv100_disp_init,\n\t.fini = gv100_disp_fini,\n\t.intr = gv100_disp_intr,\n\t.super = gv100_disp_super,\n\t.uevent = &gv100_disp_chan_uevent,\n\t.wndw = { .cnt = gv100_disp_wndw_cnt },\n\t.head = { .cnt = gv100_head_cnt, .new = gv100_head_new },\n\t.sor = { .cnt = gv100_sor_cnt, .new = gv100_sor_new },\n\t.ramht_size = 0x2000,\n\t.root = {  0, 0,GV100_DISP },\n\t.user = {\n\t\t{{-1,-1,GV100_DISP_CAPS                  }, gv100_disp_caps_new },\n\t\t{{ 0, 0,GV100_DISP_CURSOR                },  nvkm_disp_chan_new, &gv100_disp_curs },\n\t\t{{ 0, 0,GV100_DISP_WINDOW_IMM_CHANNEL_DMA},  nvkm_disp_wndw_new, &gv100_disp_wimm },\n\t\t{{ 0, 0,GV100_DISP_CORE_CHANNEL_DMA      },  nvkm_disp_core_new, &gv100_disp_core },\n\t\t{{ 0, 0,GV100_DISP_WINDOW_CHANNEL_DMA    },  nvkm_disp_wndw_new, &gv100_disp_wndw },\n\t\t{}\n\t},\n};\n\nint\ngv100_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&gv100_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}