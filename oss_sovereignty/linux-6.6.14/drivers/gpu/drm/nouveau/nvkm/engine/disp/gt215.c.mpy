{
  "module_name": "gt215.c",
  "hash_id": "7ee594b77fb05f26220d0efad0f42cc5002ffaf3480139fd64ee490dbfb4cf02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/gt215.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"hdmi.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstatic void\ngt215_sor_hda_eld(struct nvkm_ior *ior, int head, u8 *data, u8 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 soff = ior->id * 0x800;\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\tnvkm_wr32(device, 0x61c440 + soff, (i << 8) | data[i]);\n\tfor (; i < 0x60; i++)\n\t\tnvkm_wr32(device, 0x61c440 + soff, (i << 8));\n\tnvkm_mask(device, 0x61c448 + soff, 0x80000002, 0x80000002);\n}\n\nstatic void\ngt215_sor_hda_hpd(struct nvkm_ior *ior, int head, bool present)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tu32 data = 0x80000000;\n\tu32 mask = 0x80000001;\n\tif (present)\n\t\tdata |= 0x00000001;\n\telse\n\t\tmask |= 0x00000002;\n\tnvkm_mask(device, 0x61c448 + ior->id * 0x800, mask, data);\n}\n\nconst struct nvkm_ior_func_hda\ngt215_sor_hda = {\n\t.hpd = gt215_sor_hda_hpd,\n\t.eld = gt215_sor_hda_eld,\n};\n\nvoid\ngt215_sor_dp_audio(struct nvkm_ior *sor, int head, bool enable)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tconst u32 data = 0x80000000 | (0x00000001 * enable);\n\tconst u32 mask = 0x8000000d;\n\n\tnvkm_mask(device, 0x61c1e0 + soff, mask, data);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x61c1e0 + soff) & 0x80000000))\n\t\t\tbreak;\n\t);\n}\n\nstatic const struct nvkm_ior_func_dp\ngt215_sor_dp = {\n\t.lanes = { 2, 1, 0, 3 },\n\t.links = g94_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = g94_sor_dp_pattern,\n\t.drive = g94_sor_dp_drive,\n\t.audio = gt215_sor_dp_audio,\n\t.audio_sym = g94_sor_dp_audio_sym,\n\t.activesym = g94_sor_dp_activesym,\n\t.watermark = g94_sor_dp_watermark,\n};\n\nstatic void\ngt215_sor_hdmi_infoframe_vsi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe vsi;\n\tconst u32 soff = nv50_ior_base(ior);\n\n\tpack_hdmi_infoframe(&vsi, data, size);\n\n\tnvkm_mask(device, 0x61c53c + soff, 0x00010001, 0x00010000);\n\tif (!size)\n\t\treturn;\n\n\tnvkm_wr32(device, 0x61c544 + soff, vsi.header);\n\tnvkm_wr32(device, 0x61c548 + soff, vsi.subpack0_low);\n\tnvkm_wr32(device, 0x61c54c + soff, vsi.subpack0_high);\n\t \n\t \n\t \n\n\tnvkm_mask(device, 0x61c53c + soff, 0x00010001, 0x00010001);\n}\n\nstatic void\ngt215_sor_hdmi_infoframe_avi(struct nvkm_ior *ior, int head, void *data, u32 size)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tstruct packed_hdmi_infoframe avi;\n\tconst u32 soff = nv50_ior_base(ior);\n\n\tpack_hdmi_infoframe(&avi, data, size);\n\n\tnvkm_mask(device, 0x61c520 + soff, 0x00000001, 0x00000000);\n\tif (!size)\n\t\treturn;\n\n\tnvkm_wr32(device, 0x61c528 + soff, avi.header);\n\tnvkm_wr32(device, 0x61c52c + soff, avi.subpack0_low);\n\tnvkm_wr32(device, 0x61c530 + soff, avi.subpack0_high);\n\tnvkm_wr32(device, 0x61c534 + soff, avi.subpack1_low);\n\tnvkm_wr32(device, 0x61c538 + soff, avi.subpack1_high);\n\n\tnvkm_mask(device, 0x61c520 + soff, 0x00000001, 0x00000001);\n}\n\nstatic void\ngt215_sor_hdmi_ctrl(struct nvkm_ior *ior, int head, bool enable, u8 max_ac_packet, u8 rekey)\n{\n\tstruct nvkm_device *device = ior->disp->engine.subdev.device;\n\tconst u32 ctrl = 0x40000000 * enable |\n\t\t\t 0x1f000000   |\n\t\t\t max_ac_packet << 16 |\n\t\t\t rekey;\n\tconst u32 soff = nv50_ior_base(ior);\n\n\tif (!(ctrl & 0x40000000)) {\n\t\tnvkm_mask(device, 0x61c5a4 + soff, 0x40000000, 0x00000000);\n\t\tnvkm_mask(device, 0x61c53c + soff, 0x00000001, 0x00000000);\n\t\tnvkm_mask(device, 0x61c520 + soff, 0x00000001, 0x00000000);\n\t\tnvkm_mask(device, 0x61c500 + soff, 0x00000001, 0x00000000);\n\t\treturn;\n\t}\n\n\t \n\tnvkm_mask(device, 0x61c500 + soff, 0x00000001, 0x00000000);\n\tnvkm_wr32(device, 0x61c508 + soff, 0x000a0184);\n\tnvkm_wr32(device, 0x61c50c + soff, 0x00000071);\n\tnvkm_wr32(device, 0x61c510 + soff, 0x00000000);\n\tnvkm_mask(device, 0x61c500 + soff, 0x00000001, 0x00000001);\n\n\tnvkm_mask(device, 0x61c5d0 + soff, 0x00070001, 0x00010001);  \n\tnvkm_mask(device, 0x61c568 + soff, 0x00010101, 0x00000000);  \n\tnvkm_mask(device, 0x61c578 + soff, 0x80000000, 0x80000000);  \n\n\t \n\tnvkm_mask(device, 0x61733c, 0x00100000, 0x00100000);  \n\tnvkm_mask(device, 0x61733c, 0x10000000, 0x10000000);  \n\tnvkm_mask(device, 0x61733c, 0x00100000, 0x00000000);  \n\n\t \n\tnvkm_mask(device, 0x61c5a4 + soff, 0x5f1f007f, ctrl);\n}\n\nconst struct nvkm_ior_func_hdmi\ngt215_sor_hdmi = {\n\t.ctrl = gt215_sor_hdmi_ctrl,\n\t.infoframe_avi = gt215_sor_hdmi_infoframe_avi,\n\t.infoframe_vsi = gt215_sor_hdmi_infoframe_vsi,\n};\n\nstatic const struct nvkm_ior_func\ngt215_sor = {\n\t.state = g94_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = nv50_sor_clock,\n\t.hdmi = &gt215_sor_hdmi,\n\t.dp = &gt215_sor_dp,\n\t.hda = &gt215_sor_hda,\n};\n\nstatic int\ngt215_sor_new(struct nvkm_disp *disp, int id)\n{\n\treturn nvkm_ior_new_(&gt215_sor, disp, SOR, id, true);\n}\n\nstatic const struct nvkm_disp_func\ngt215_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = nv50_disp_init,\n\t.fini = nv50_disp_fini,\n\t.intr = nv50_disp_intr,\n\t.super = nv50_disp_super,\n\t.uevent = &nv50_disp_chan_uevent,\n\t.head = { .cnt = nv50_head_cnt, .new = nv50_head_new },\n\t.dac = { .cnt = nv50_dac_cnt, .new = nv50_dac_new },\n\t.sor = { .cnt = g94_sor_cnt, .new = gt215_sor_new },\n\t.pior = { .cnt = nv50_pior_cnt, .new = nv50_pior_new },\n\t.root = { 0,0,GT214_DISP },\n\t.user = {\n\t\t{{0,0,GT214_DISP_CURSOR             }, nvkm_disp_chan_new, & nv50_disp_curs },\n\t\t{{0,0,GT214_DISP_OVERLAY            }, nvkm_disp_chan_new, & nv50_disp_oimm },\n\t\t{{0,0,GT214_DISP_BASE_CHANNEL_DMA   }, nvkm_disp_chan_new, &  g84_disp_base },\n\t\t{{0,0,GT214_DISP_CORE_CHANNEL_DMA   }, nvkm_disp_core_new, &  g94_disp_core },\n\t\t{{0,0,GT214_DISP_OVERLAY_CHANNEL_DMA}, nvkm_disp_chan_new, &  g84_disp_ovly },\n\t\t{}\n\t},\n};\n\nint\ngt215_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&gt215_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}