{
  "module_name": "gv100.c",
  "hash_id": "0938dba9353f1cece2e9ee02387f839174a4348248def205dfc5cb77a6608689",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/gv100.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ctxgf100.h\"\n\n#include <nvif/class.h>\n\nstatic void\ngv100_gr_trap_sm(struct gf100_gr *gr, int gpc, int tpc, int sm)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 werr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x730 + (sm * 0x80)));\n\tu32 gerr = nvkm_rd32(device, TPC_UNIT(gpc, tpc, 0x734 + (sm * 0x80)));\n\tconst struct nvkm_enum *warp;\n\tchar glob[128];\n\n\tnvkm_snprintbf(glob, sizeof(glob), gf100_mp_global_error, gerr);\n\twarp = nvkm_enum_find(gf100_mp_warp_error, werr & 0xffff);\n\n\tnvkm_error(subdev, \"GPC%i/TPC%i/SM%d trap: \"\n\t\t\t   \"global %08x [%s] warp %04x [%s]\\n\",\n\t\t   gpc, tpc, sm, gerr, glob, werr, warp ? warp->name : \"\");\n\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x730 + sm * 0x80), 0x00000000);\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x734 + sm * 0x80), gerr);\n}\n\nvoid\ngv100_gr_trap_mp(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tgv100_gr_trap_sm(gr, gpc, tpc, 0);\n\tgv100_gr_trap_sm(gr, gpc, tpc, 1);\n}\n\nvoid\ngv100_gr_init_4188a4(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\tnvkm_mask(device, 0x4188a4, 0x03000000, 0x03000000);\n}\n\nvoid\ngv100_gr_init_shader_exceptions(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint sm;\n\tfor (sm = 0; sm < 0x100; sm += 0x80) {\n\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x610), 0x00000001);\n\t\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x72c + sm), 0x00000004);\n\t}\n}\n\nvoid\ngv100_gr_init_504430(struct gf100_gr *gr, int gpc, int tpc)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x430), 0x403f0000);\n}\n\nvoid\ngv100_gr_init_419bd8(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, 0x419bd8, 0x00000700, 0x00000000);\n}\n\nu32\ngv100_gr_nonpes_aware_tpc(struct gf100_gr *gr, u32 gpc, u32 tpc)\n{\n\tu32 pes, temp, tpc_new = 0;\n\n\tfor (pes = 0; pes < gr->ppc_nr[gpc]; pes++) {\n\t\tif (gr->ppc_tpc_mask[gpc][pes] & BIT(tpc))\n\t\t\tbreak;\n\n\t\ttpc_new += gr->ppc_tpc_nr[gpc][pes];\n\t}\n\n\ttemp = (BIT(tpc) - 1) & gr->ppc_tpc_mask[gpc][pes];\n\ttemp = hweight32(temp);\n\treturn tpc_new + temp;\n}\n\nstatic int\ngv100_gr_scg_estimate_perf(struct gf100_gr *gr, unsigned long *gpc_tpc_mask,\n\t\t\t   u32 disable_gpc, u32 disable_tpc, int *perf)\n{\n\tconst u32 scale_factor = 512UL;\t\t \n\tconst u32 pix_scale = 1024*1024UL;\t \n\tconst u32 world_scale = 1024UL;\t\t \n\tconst u32 tpc_scale = 1;\t\t \n\tu32 scg_num_pes = 0;\n\tu32 min_scg_gpc_pix_perf = scale_factor;  \n\tu32 average_tpcs = 0;  \n\tu32 deviation;  \n\tu32 norm_tpc_deviation;\t \n\tu32 tpc_balance;\n\tu32 scg_gpc_pix_perf;\n\tu32 scg_world_perf;\n\tu32 gpc;\n\tu32 pes;\n\tint diff;\n\tbool tpc_removed_gpc = false;\n\tbool tpc_removed_pes = false;\n\tu32 max_tpc_gpc = 0;\n\tu32 num_tpc_mask;\n\tu32 *num_tpc_gpc;\n\tint ret = -EINVAL;\n\n\tif (!(num_tpc_gpc = kcalloc(gr->gpc_nr, sizeof(*num_tpc_gpc), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t \n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tnum_tpc_mask = gpc_tpc_mask[gpc];\n\n\t\tif ((gpc == disable_gpc) && num_tpc_mask & BIT(disable_tpc)) {\n\t\t\t \n\t\t\tif (WARN_ON(tpc_removed_gpc))\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tnum_tpc_mask &= ~BIT(disable_tpc);\n\t\t\ttpc_removed_gpc = true;\n\t\t}\n\n\t\t \n\t\tnum_tpc_gpc[gpc] = hweight32(num_tpc_mask);\n\t\taverage_tpcs += num_tpc_gpc[gpc];\n\n\t\t \n\t\tmax_tpc_gpc = num_tpc_gpc[gpc] > max_tpc_gpc ? num_tpc_gpc[gpc] : max_tpc_gpc;\n\n\t\t \n\t\tscg_gpc_pix_perf = scale_factor * num_tpc_gpc[gpc] / gr->tpc_nr[gpc];\n\t\tif (min_scg_gpc_pix_perf > scg_gpc_pix_perf)\n\t\t\tmin_scg_gpc_pix_perf = scg_gpc_pix_perf;\n\n\t\t \n\t\tfor (pes = 0; pes < gr->ppc_nr[gpc]; pes++) {\n\t\t\t \n\t\t\tnum_tpc_mask = gr->ppc_tpc_mask[gpc][pes] & gpc_tpc_mask[gpc];\n\n\t\t\tif ((gpc == disable_gpc) && (num_tpc_mask & BIT(disable_tpc))) {\n\t\t\t\tif (WARN_ON(tpc_removed_pes))\n\t\t\t\t\tgoto done;\n\n\t\t\t\tnum_tpc_mask &= ~BIT(disable_tpc);\n\t\t\t\ttpc_removed_pes = true;\n\t\t\t}\n\n\t\t\tif (hweight32(num_tpc_mask))\n\t\t\t\tscg_num_pes++;\n\t\t}\n\t}\n\n\tif (WARN_ON(!tpc_removed_gpc || !tpc_removed_pes))\n\t\tgoto done;\n\n\tif (max_tpc_gpc == 0) {\n\t\t*perf = 0;\n\t\tgoto done_ok;\n\t}\n\n\t \n\tscg_world_perf = (scale_factor * scg_num_pes) / gr->ppc_total;\n\tdeviation = 0;\n\taverage_tpcs = scale_factor * average_tpcs / gr->gpc_nr;\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tdiff = average_tpcs - scale_factor * num_tpc_gpc[gpc];\n\t\tif (diff < 0)\n\t\t\tdiff = -diff;\n\n\t\tdeviation += diff;\n\t}\n\n\tdeviation /= gr->gpc_nr;\n\n\tnorm_tpc_deviation = deviation / max_tpc_gpc;\n\n\ttpc_balance = scale_factor - norm_tpc_deviation;\n\n\tif ((tpc_balance > scale_factor)          ||\n\t    (scg_world_perf > scale_factor)       ||\n\t    (min_scg_gpc_pix_perf > scale_factor) ||\n\t    (norm_tpc_deviation > scale_factor)) {\n\t\tWARN_ON(1);\n\t\tgoto done;\n\t}\n\n\t*perf = (pix_scale * min_scg_gpc_pix_perf) +\n\t\t(world_scale * scg_world_perf) +\n\t\t(tpc_scale * tpc_balance);\ndone_ok:\n\tret = 0;\ndone:\n\tkfree(num_tpc_gpc);\n\treturn ret;\n}\n\nint\ngv100_gr_oneinit_sm_id(struct gf100_gr *gr)\n{\n\tunsigned long *gpc_tpc_mask;\n\tu32 *tpc_table, *gpc_table;\n\tu32 gpc, tpc, pes, gtpc;\n\tint perf, maxperf, ret = 0;\n\n\tgpc_tpc_mask = kcalloc(gr->gpc_nr, sizeof(*gpc_tpc_mask), GFP_KERNEL);\n\tgpc_table = kcalloc(gr->tpc_total, sizeof(*gpc_table), GFP_KERNEL);\n\ttpc_table = kcalloc(gr->tpc_total, sizeof(*tpc_table), GFP_KERNEL);\n\tif (!gpc_table || !tpc_table || !gpc_tpc_mask) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tfor (pes = 0; pes < gr->ppc_nr[gpc]; pes++)\n\t\t\tgpc_tpc_mask[gpc] |= gr->ppc_tpc_mask[gpc][pes];\n\t}\n\n\tfor (gtpc = 0; gtpc < gr->tpc_total; gtpc++) {\n\t\tfor (maxperf = -1, gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\t\tfor_each_set_bit(tpc, &gpc_tpc_mask[gpc], gr->tpc_nr[gpc]) {\n\t\t\t\tret = gv100_gr_scg_estimate_perf(gr, gpc_tpc_mask, gpc, tpc, &perf);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto done;\n\n\t\t\t\t \n\t\t\t\tif (perf > maxperf) {\n\t\t\t\t\tmaxperf = perf;\n\t\t\t\t\tgpc_table[gtpc] = gpc;\n\t\t\t\t\ttpc_table[gtpc] = tpc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgpc_tpc_mask[gpc_table[gtpc]] &= ~BIT(tpc_table[gtpc]);\n\t}\n\n\t \n\tfor (gtpc = 0; gtpc < gr->tpc_total; gtpc++) {\n\t\tgr->sm[gtpc].gpc = gpc_table[gtpc];\n\t\tgr->sm[gtpc].tpc = tpc_table[gtpc];\n\t\tgr->sm_nr++;\n\t}\n\ndone:\n\tkfree(gpc_table);\n\tkfree(tpc_table);\n\tkfree(gpc_tpc_mask);\n\treturn ret;\n}\n\nstatic const struct gf100_gr_func\ngv100_gr = {\n\t.oneinit_tiles = gm200_gr_oneinit_tiles,\n\t.oneinit_sm_id = gv100_gr_oneinit_sm_id,\n\t.init = gf100_gr_init,\n\t.init_419bd8 = gv100_gr_init_419bd8,\n\t.init_gpc_mmu = gm200_gr_init_gpc_mmu,\n\t.init_vsc_stream_master = gk104_gr_init_vsc_stream_master,\n\t.init_zcull = gf117_gr_init_zcull,\n\t.init_num_active_ltcs = gm200_gr_init_num_active_ltcs,\n\t.init_rop_active_fbps = gp100_gr_init_rop_active_fbps,\n\t.init_swdx_pes_mask = gp102_gr_init_swdx_pes_mask,\n\t.init_fecs_exceptions = gp100_gr_init_fecs_exceptions,\n\t.init_ds_hww_esr_2 = gm200_gr_init_ds_hww_esr_2,\n\t.init_sked_hww_esr = gk104_gr_init_sked_hww_esr,\n\t.init_ppc_exceptions = gk104_gr_init_ppc_exceptions,\n\t.init_504430 = gv100_gr_init_504430,\n\t.init_shader_exceptions = gv100_gr_init_shader_exceptions,\n\t.init_rop_exceptions = gf100_gr_init_rop_exceptions,\n\t.init_exception2 = gf100_gr_init_exception2,\n\t.init_4188a4 = gv100_gr_init_4188a4,\n\t.trap_mp = gv100_gr_trap_mp,\n\t.fecs.reset = gf100_gr_fecs_reset,\n\t.rops = gm200_gr_rops,\n\t.gpc_nr = 6,\n\t.tpc_nr = 7,\n\t.ppc_nr = 3,\n\t.grctx = &gv100_grctx,\n\t.zbc = &gp102_gr_zbc,\n\t.sclass = {\n\t\t{ -1, -1, FERMI_TWOD_A },\n\t\t{ -1, -1, KEPLER_INLINE_TO_MEMORY_B },\n\t\t{ -1, -1, VOLTA_A, &gf100_fermi },\n\t\t{ -1, -1, VOLTA_COMPUTE_A },\n\t\t{}\n\t}\n};\n\nMODULE_FIRMWARE(\"nvidia/gv100/gr/fecs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/fecs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/fecs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/fecs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/gpccs_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/gpccs_inst.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/gpccs_data.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/gpccs_sig.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/sw_ctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/sw_nonctx.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/sw_bundle_init.bin\");\nMODULE_FIRMWARE(\"nvidia/gv100/gr/sw_method_init.bin\");\n\nstatic const struct gf100_gr_fwif\ngv100_gr_fwif[] = {\n\t{  0, gm200_gr_load, &gv100_gr, &gp108_gr_fecs_acr, &gp108_gr_gpccs_acr },\n\t{ -1, gm200_gr_nofw },\n\t{}\n};\n\nint\ngv100_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn gf100_gr_new_(gv100_gr_fwif, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}