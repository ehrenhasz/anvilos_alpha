{
  "module_name": "nv31.c",
  "hash_id": "96db5a7133ca17f961bb555fbef7eb560bec7e58ddf77b3d4d397b99044e28db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/mpeg/nv31.c",
  "human_readable_source": " \n#include \"nv31.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n#include <subdev/timer.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n\n \n\nstatic int\nnv31_mpeg_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t      int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tint ret = nvkm_gpuobj_new(object->engine->subdev.device, 16, align,\n\t\t\t\t  false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, object->oclass);\n\t\tnvkm_wo32(*pgpuobj, 0x04, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x08, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x0c, 0x00000000);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nconst struct nvkm_object_func\nnv31_mpeg_object = {\n\t.bind = nv31_mpeg_object_bind,\n};\n\n \n\nstatic void *\nnv31_mpeg_chan_dtor(struct nvkm_object *object)\n{\n\tstruct nv31_mpeg_chan *chan = nv31_mpeg_chan(object);\n\tstruct nv31_mpeg *mpeg = chan->mpeg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mpeg->engine.lock, flags);\n\tif (mpeg->chan == chan)\n\t\tmpeg->chan = NULL;\n\tspin_unlock_irqrestore(&mpeg->engine.lock, flags);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\nnv31_mpeg_chan = {\n\t.dtor = nv31_mpeg_chan_dtor,\n};\n\nint\nnv31_mpeg_chan_new(struct nvkm_chan *fifoch, const struct nvkm_oclass *oclass,\n\t\t   struct nvkm_object **pobject)\n{\n\tstruct nv31_mpeg *mpeg = nv31_mpeg(oclass->engine);\n\tstruct nv31_mpeg_chan *chan;\n\tunsigned long flags;\n\tint ret = -EBUSY;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nv31_mpeg_chan, oclass, &chan->object);\n\tchan->mpeg = mpeg;\n\tchan->fifo = fifoch;\n\t*pobject = &chan->object;\n\n\tspin_lock_irqsave(&mpeg->engine.lock, flags);\n\tif (!mpeg->chan) {\n\t\tmpeg->chan = chan;\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&mpeg->engine.lock, flags);\n\treturn ret;\n}\n\n \n\nvoid\nnv31_mpeg_tile(struct nvkm_engine *engine, int i, struct nvkm_fb_tile *tile)\n{\n\tstruct nv31_mpeg *mpeg = nv31_mpeg(engine);\n\tstruct nvkm_device *device = mpeg->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x00b008 + (i * 0x10), tile->pitch);\n\tnvkm_wr32(device, 0x00b004 + (i * 0x10), tile->limit);\n\tnvkm_wr32(device, 0x00b000 + (i * 0x10), tile->addr);\n}\n\nstatic bool\nnv31_mpeg_mthd_dma(struct nvkm_device *device, u32 mthd, u32 data)\n{\n\tstruct nv31_mpeg *mpeg = nv31_mpeg(device->mpeg);\n\tstruct nvkm_subdev *subdev = &mpeg->engine.subdev;\n\tu32 inst = data << 4;\n\tu32 dma0 = nvkm_rd32(device, 0x700000 + inst);\n\tu32 dma1 = nvkm_rd32(device, 0x700004 + inst);\n\tu32 dma2 = nvkm_rd32(device, 0x700008 + inst);\n\tu32 base = (dma2 & 0xfffff000) | (dma0 >> 20);\n\tu32 size = dma1 + 1;\n\n\t \n\tif (!(dma0 & 0x00002000)) {\n\t\tnvkm_error(subdev, \"inst %08x dma0 %08x dma1 %08x dma2 %08x\\n\",\n\t\t\t   inst, dma0, dma1, dma2);\n\t\treturn false;\n\t}\n\n\tif (mthd == 0x0190) {\n\t\t \n\t\tnvkm_mask(device, 0x00b300, 0x00010000,\n\t\t\t\t  (dma0 & 0x00030000) ? 0x00010000 : 0);\n\t\tnvkm_wr32(device, 0x00b334, base);\n\t\tnvkm_wr32(device, 0x00b324, size);\n\t} else\n\tif (mthd == 0x01a0) {\n\t\t \n\t\tnvkm_mask(device, 0x00b300, 0x00020000,\n\t\t\t\t  (dma0 & 0x00030000) ? 0x00020000 : 0);\n\t\tnvkm_wr32(device, 0x00b360, base);\n\t\tnvkm_wr32(device, 0x00b364, size);\n\t} else {\n\t\t \n\t\tif (dma0 & 0x00030000)\n\t\t\treturn false;\n\n\t\tnvkm_wr32(device, 0x00b370, base);\n\t\tnvkm_wr32(device, 0x00b374, size);\n\t}\n\n\treturn true;\n}\n\nstatic bool\nnv31_mpeg_mthd(struct nv31_mpeg *mpeg, u32 mthd, u32 data)\n{\n\tstruct nvkm_device *device = mpeg->engine.subdev.device;\n\tswitch (mthd) {\n\tcase 0x190:\n\tcase 0x1a0:\n\tcase 0x1b0:\n\t\treturn mpeg->func->mthd_dma(device, mthd, data);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic void\nnv31_mpeg_intr(struct nvkm_engine *engine)\n{\n\tstruct nv31_mpeg *mpeg = nv31_mpeg(engine);\n\tstruct nvkm_subdev *subdev = &mpeg->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x00b100);\n\tu32 type = nvkm_rd32(device, 0x00b230);\n\tu32 mthd = nvkm_rd32(device, 0x00b234);\n\tu32 data = nvkm_rd32(device, 0x00b238);\n\tu32 show = stat;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mpeg->engine.lock, flags);\n\n\tif (stat & 0x01000000) {\n\t\t \n\t\tif (type == 0x00000020 && mthd == 0x0000) {\n\t\t\tnvkm_mask(device, 0x00b308, 0x00000000, 0x00000000);\n\t\t\tshow &= ~0x01000000;\n\t\t}\n\n\t\tif (type == 0x00000010) {\n\t\t\tif (nv31_mpeg_mthd(mpeg, mthd, data))\n\t\t\t\tshow &= ~0x01000000;\n\t\t}\n\t}\n\n\tnvkm_wr32(device, 0x00b100, stat);\n\tnvkm_wr32(device, 0x00b230, 0x00000001);\n\n\tif (show) {\n\t\tnvkm_error(subdev, \"ch %d [%s] %08x %08x %08x %08x\\n\",\n\t\t\t   mpeg->chan ? mpeg->chan->fifo->id : -1,\n\t\t\t   mpeg->chan ? mpeg->chan->fifo->name :\n\t\t\t   \"unknown\", stat, type, mthd, data);\n\t}\n\n\tspin_unlock_irqrestore(&mpeg->engine.lock, flags);\n}\n\nint\nnv31_mpeg_init(struct nvkm_engine *mpeg)\n{\n\tstruct nvkm_subdev *subdev = &mpeg->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tnvkm_wr32(device, 0x00b0e0, 0x00000020);  \n\tnvkm_wr32(device, 0x00b0e8, 0x00000020);  \n\n\t \n\tnvkm_wr32(device, 0x00b32c, 0x00000000);\n\tnvkm_wr32(device, 0x00b314, 0x00000100);\n\tnvkm_wr32(device, 0x00b220, 0x00000031);\n\tnvkm_wr32(device, 0x00b300, 0x02001ec1);\n\tnvkm_mask(device, 0x00b32c, 0x00000001, 0x00000001);\n\n\tnvkm_wr32(device, 0x00b100, 0xffffffff);\n\tnvkm_wr32(device, 0x00b140, 0xffffffff);\n\n\tif (nvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x00b200) & 0x00000001))\n\t\t\tbreak;\n\t) < 0) {\n\t\tnvkm_error(subdev, \"timeout %08x\\n\",\n\t\t\t   nvkm_rd32(device, 0x00b200));\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void *\nnv31_mpeg_dtor(struct nvkm_engine *engine)\n{\n\treturn nv31_mpeg(engine);\n}\n\nstatic const struct nvkm_engine_func\nnv31_mpeg_ = {\n\t.dtor = nv31_mpeg_dtor,\n\t.init = nv31_mpeg_init,\n\t.intr = nv31_mpeg_intr,\n\t.tile = nv31_mpeg_tile,\n\t.fifo.cclass = nv31_mpeg_chan_new,\n\t.sclass = {\n\t\t{ -1, -1, NV31_MPEG, &nv31_mpeg_object },\n\t\t{}\n\t}\n};\n\nint\nnv31_mpeg_new_(const struct nv31_mpeg_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_engine **pmpeg)\n{\n\tstruct nv31_mpeg *mpeg;\n\n\tif (!(mpeg = kzalloc(sizeof(*mpeg), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tmpeg->func = func;\n\t*pmpeg = &mpeg->engine;\n\n\treturn nvkm_engine_ctor(&nv31_mpeg_, device, type, inst, true, &mpeg->engine);\n}\n\nstatic const struct nv31_mpeg_func\nnv31_mpeg = {\n\t.mthd_dma = nv31_mpeg_mthd_dma,\n};\n\nint\nnv31_mpeg_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_engine **pmpeg)\n{\n\treturn nv31_mpeg_new_(&nv31_mpeg, device, type, inst, pmpeg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}