{
  "module_name": "nv40.c",
  "hash_id": "0902c89c2a7b7d6a7325bf3612ed94b9f0b8ddaae45d174d3fb525a066143c46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv40.c",
  "human_readable_source": " \n#include \"nv40.h\"\n#include \"regs.h\"\n\n#include <core/client.h>\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n#include <subdev/timer.h>\n#include <engine/fifo.h>\n\nu64\nnv40_gr_units(struct nvkm_gr *gr)\n{\n\treturn nvkm_rd32(gr->engine.subdev.device, 0x1540);\n}\n\n \n\nstatic int\nnv40_gr_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t    int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tint ret = nvkm_gpuobj_new(object->engine->subdev.device, 20, align,\n\t\t\t\t  false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, object->oclass);\n\t\tnvkm_wo32(*pgpuobj, 0x04, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x08, 0x00000000);\n#ifdef __BIG_ENDIAN\n\t\tnvkm_mo32(*pgpuobj, 0x08, 0x01000000, 0x01000000);\n#endif\n\t\tnvkm_wo32(*pgpuobj, 0x0c, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x10, 0x00000000);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nconst struct nvkm_object_func\nnv40_gr_object = {\n\t.bind = nv40_gr_object_bind,\n};\n\n \n\nstatic int\nnv40_gr_chan_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t  int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nv40_gr_chan *chan = nv40_gr_chan(object);\n\tstruct nv40_gr *gr = chan->gr;\n\tint ret = nvkm_gpuobj_new(gr->base.engine.subdev.device, gr->size,\n\t\t\t\t  align, true, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tchan->inst = (*pgpuobj)->addr;\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnv40_grctx_fill(gr->base.engine.subdev.device, *pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00000, chan->inst >> 4);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nstatic int\nnv40_gr_chan_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nv40_gr_chan *chan = nv40_gr_chan(object);\n\tstruct nv40_gr *gr = chan->gr;\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 inst = 0x01000000 | chan->inst >> 4;\n\tint ret = 0;\n\n\tnvkm_mask(device, 0x400720, 0x00000001, 0x00000000);\n\n\tif (nvkm_rd32(device, 0x40032c) == inst) {\n\t\tif (suspend) {\n\t\t\tnvkm_wr32(device, 0x400720, 0x00000000);\n\t\t\tnvkm_wr32(device, 0x400784, inst);\n\t\t\tnvkm_mask(device, 0x400310, 0x00000020, 0x00000020);\n\t\t\tnvkm_mask(device, 0x400304, 0x00000001, 0x00000001);\n\t\t\tif (nvkm_msec(device, 2000,\n\t\t\t\tif (!(nvkm_rd32(device, 0x400300) & 0x00000001))\n\t\t\t\t\tbreak;\n\t\t\t) < 0) {\n\t\t\t\tu32 insn = nvkm_rd32(device, 0x400308);\n\t\t\t\tnvkm_warn(subdev, \"ctxprog timeout %08x\\n\", insn);\n\t\t\t\tret = -EBUSY;\n\t\t\t}\n\t\t}\n\n\t\tnvkm_mask(device, 0x40032c, 0x01000000, 0x00000000);\n\t}\n\n\tif (nvkm_rd32(device, 0x400330) == inst)\n\t\tnvkm_mask(device, 0x400330, 0x01000000, 0x00000000);\n\n\tnvkm_mask(device, 0x400720, 0x00000001, 0x00000001);\n\treturn ret;\n}\n\nstatic void *\nnv40_gr_chan_dtor(struct nvkm_object *object)\n{\n\tstruct nv40_gr_chan *chan = nv40_gr_chan(object);\n\tunsigned long flags;\n\tspin_lock_irqsave(&chan->gr->base.engine.lock, flags);\n\tlist_del(&chan->head);\n\tspin_unlock_irqrestore(&chan->gr->base.engine.lock, flags);\n\treturn chan;\n}\n\nstatic const struct nvkm_object_func\nnv40_gr_chan = {\n\t.dtor = nv40_gr_chan_dtor,\n\t.fini = nv40_gr_chan_fini,\n\t.bind = nv40_gr_chan_bind,\n};\n\nint\nnv40_gr_chan_new(struct nvkm_gr *base, struct nvkm_chan *fifoch,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object **pobject)\n{\n\tstruct nv40_gr *gr = nv40_gr(base);\n\tstruct nv40_gr_chan *chan;\n\tunsigned long flags;\n\n\tif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nv40_gr_chan, oclass, &chan->object);\n\tchan->gr = gr;\n\tchan->fifo = fifoch;\n\t*pobject = &chan->object;\n\n\tspin_lock_irqsave(&chan->gr->base.engine.lock, flags);\n\tlist_add(&chan->head, &gr->chan);\n\tspin_unlock_irqrestore(&chan->gr->base.engine.lock, flags);\n\treturn 0;\n}\n\n \n\nstatic void\nnv40_gr_tile(struct nvkm_gr *base, int i, struct nvkm_fb_tile *tile)\n{\n\tstruct nv40_gr *gr = nv40_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tstruct nvkm_fifo *fifo = device->fifo;\n\tunsigned long flags;\n\n\tnvkm_fifo_pause(fifo, &flags);\n\tnv04_gr_idle(&gr->base);\n\n\tswitch (device->chipset) {\n\tcase 0x40:\n\tcase 0x41:\n\tcase 0x42:\n\tcase 0x43:\n\tcase 0x45:\n\t\tnvkm_wr32(device, NV20_PGRAPH_TSIZE(i), tile->pitch);\n\t\tnvkm_wr32(device, NV20_PGRAPH_TLIMIT(i), tile->limit);\n\t\tnvkm_wr32(device, NV20_PGRAPH_TILE(i), tile->addr);\n\t\tnvkm_wr32(device, NV40_PGRAPH_TSIZE1(i), tile->pitch);\n\t\tnvkm_wr32(device, NV40_PGRAPH_TLIMIT1(i), tile->limit);\n\t\tnvkm_wr32(device, NV40_PGRAPH_TILE1(i), tile->addr);\n\t\tswitch (device->chipset) {\n\t\tcase 0x40:\n\t\tcase 0x45:\n\t\t\tnvkm_wr32(device, NV20_PGRAPH_ZCOMP(i), tile->zcomp);\n\t\t\tnvkm_wr32(device, NV40_PGRAPH_ZCOMP1(i), tile->zcomp);\n\t\t\tbreak;\n\t\tcase 0x41:\n\t\tcase 0x42:\n\t\tcase 0x43:\n\t\t\tnvkm_wr32(device, NV41_PGRAPH_ZCOMP0(i), tile->zcomp);\n\t\t\tnvkm_wr32(device, NV41_PGRAPH_ZCOMP1(i), tile->zcomp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tnvkm_wr32(device, NV47_PGRAPH_TSIZE(i), tile->pitch);\n\t\tnvkm_wr32(device, NV47_PGRAPH_TLIMIT(i), tile->limit);\n\t\tnvkm_wr32(device, NV47_PGRAPH_TILE(i), tile->addr);\n\t\tnvkm_wr32(device, NV40_PGRAPH_TSIZE1(i), tile->pitch);\n\t\tnvkm_wr32(device, NV40_PGRAPH_TLIMIT1(i), tile->limit);\n\t\tnvkm_wr32(device, NV40_PGRAPH_TILE1(i), tile->addr);\n\t\tnvkm_wr32(device, NV47_PGRAPH_ZCOMP0(i), tile->zcomp);\n\t\tnvkm_wr32(device, NV47_PGRAPH_ZCOMP1(i), tile->zcomp);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tnvkm_fifo_start(fifo, &flags);\n}\n\nvoid\nnv40_gr_intr(struct nvkm_gr *base)\n{\n\tstruct nv40_gr *gr = nv40_gr(base);\n\tstruct nv40_gr_chan *temp, *chan = NULL;\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, NV03_PGRAPH_INTR);\n\tu32 nsource = nvkm_rd32(device, NV03_PGRAPH_NSOURCE);\n\tu32 nstatus = nvkm_rd32(device, NV03_PGRAPH_NSTATUS);\n\tu32 inst = nvkm_rd32(device, 0x40032c) & 0x000fffff;\n\tu32 addr = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_ADDR);\n\tu32 subc = (addr & 0x00070000) >> 16;\n\tu32 mthd = (addr & 0x00001ffc);\n\tu32 data = nvkm_rd32(device, NV04_PGRAPH_TRAPPED_DATA);\n\tu32 class = nvkm_rd32(device, 0x400160 + subc * 4) & 0xffff;\n\tu32 show = stat;\n\tchar msg[128], src[128], sta[128];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gr->base.engine.lock, flags);\n\tlist_for_each_entry(temp, &gr->chan, head) {\n\t\tif (temp->inst >> 4 == inst) {\n\t\t\tchan = temp;\n\t\t\tlist_del(&chan->head);\n\t\t\tlist_add(&chan->head, &gr->chan);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (stat & NV_PGRAPH_INTR_ERROR) {\n\t\tif (nsource & NV03_PGRAPH_NSOURCE_DMA_VTX_PROTECTION) {\n\t\t\tnvkm_mask(device, 0x402000, 0, 0);\n\t\t}\n\t}\n\n\tnvkm_wr32(device, NV03_PGRAPH_INTR, stat);\n\tnvkm_wr32(device, NV04_PGRAPH_FIFO, 0x00000001);\n\n\tif (show) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), nv10_gr_intr_name, show);\n\t\tnvkm_snprintbf(src, sizeof(src), nv04_gr_nsource, nsource);\n\t\tnvkm_snprintbf(sta, sizeof(sta), nv10_gr_nstatus, nstatus);\n\t\tnvkm_error(subdev, \"intr %08x [%s] nsource %08x [%s] \"\n\t\t\t\t   \"nstatus %08x [%s] ch %d [%08x %s] subc %d \"\n\t\t\t\t   \"class %04x mthd %04x data %08x\\n\",\n\t\t\t   show, msg, nsource, src, nstatus, sta,\n\t\t\t   chan ? chan->fifo->id : -1, inst << 4,\n\t\t\t   chan ? chan->fifo->name : \"unknown\",\n\t\t\t   subc, class, mthd, data);\n\t}\n\n\tspin_unlock_irqrestore(&gr->base.engine.lock, flags);\n}\n\nint\nnv40_gr_init(struct nvkm_gr *base)\n{\n\tstruct nv40_gr *gr = nv40_gr(base);\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tint ret, i, j;\n\tu32 vramsz;\n\n\t \n\tret = nv40_grctx_init(device, &gr->size);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnvkm_wr32(device, NV40_PGRAPH_CTXCTL_CUR, 0x00000000);\n\n\tnvkm_wr32(device, NV03_PGRAPH_INTR   , 0xFFFFFFFF);\n\tnvkm_wr32(device, NV40_PGRAPH_INTR_EN, 0xFFFFFFFF);\n\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0xFFFFFFFF);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_0, 0x00000000);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_1, 0x401287c0);\n\tnvkm_wr32(device, NV04_PGRAPH_DEBUG_3, 0xe0de8055);\n\tnvkm_wr32(device, NV10_PGRAPH_DEBUG_4, 0x00008000);\n\tnvkm_wr32(device, NV04_PGRAPH_LIMIT_VIOL_PIX, 0x00be3c5f);\n\n\tnvkm_wr32(device, NV10_PGRAPH_CTX_CONTROL, 0x10010100);\n\tnvkm_wr32(device, NV10_PGRAPH_STATE      , 0xFFFFFFFF);\n\n\tj = nvkm_rd32(device, 0x1540) & 0xff;\n\tif (j) {\n\t\tfor (i = 0; !(j & 1); j >>= 1, i++)\n\t\t\t;\n\t\tnvkm_wr32(device, 0x405000, i);\n\t}\n\n\tif (device->chipset == 0x40) {\n\t\tnvkm_wr32(device, 0x4009b0, 0x83280fff);\n\t\tnvkm_wr32(device, 0x4009b4, 0x000000a0);\n\t} else {\n\t\tnvkm_wr32(device, 0x400820, 0x83280eff);\n\t\tnvkm_wr32(device, 0x400824, 0x000000a0);\n\t}\n\n\tswitch (device->chipset) {\n\tcase 0x40:\n\tcase 0x45:\n\t\tnvkm_wr32(device, 0x4009b8, 0x0078e366);\n\t\tnvkm_wr32(device, 0x4009bc, 0x0000014c);\n\t\tbreak;\n\tcase 0x41:\n\tcase 0x42:  \n\t \n\t\tnvkm_wr32(device, 0x400828, 0x007596ff);\n\t\tnvkm_wr32(device, 0x40082c, 0x00000108);\n\t\tbreak;\n\tcase 0x43:\n\t\tnvkm_wr32(device, 0x400828, 0x0072cb77);\n\t\tnvkm_wr32(device, 0x40082c, 0x00000108);\n\t\tbreak;\n\tcase 0x44:\n\tcase 0x46:  \n\tcase 0x4a:\n\tcase 0x4c:  \n\tcase 0x4e:\n\t\tnvkm_wr32(device, 0x400860, 0);\n\t\tnvkm_wr32(device, 0x400864, 0);\n\t\tbreak;\n\tcase 0x47:  \n\tcase 0x49:  \n\tcase 0x4b:  \n\t\tnvkm_wr32(device, 0x400828, 0x07830610);\n\t\tnvkm_wr32(device, 0x40082c, 0x0000016A);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnvkm_wr32(device, 0x400b38, 0x2ffff800);\n\tnvkm_wr32(device, 0x400b3c, 0x00006000);\n\n\t \n\tswitch (device->chipset) {\n\tcase 0x44:\n\tcase 0x4a:\n\t\tnvkm_wr32(device, 0x400bc4, 0x1003d888);\n\t\tnvkm_wr32(device, 0x400bbc, 0xb7a7b500);\n\t\tbreak;\n\tcase 0x46:\n\t\tnvkm_wr32(device, 0x400bc4, 0x0000e024);\n\t\tnvkm_wr32(device, 0x400bbc, 0xb7a7b520);\n\t\tbreak;\n\tcase 0x4c:\n\tcase 0x4e:\n\tcase 0x67:\n\t\tnvkm_wr32(device, 0x400bc4, 0x1003d888);\n\t\tnvkm_wr32(device, 0x400bbc, 0xb7a7b540);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tvramsz = device->func->resource_size(device, 1) - 1;\n\tswitch (device->chipset) {\n\tcase 0x40:\n\t\tnvkm_wr32(device, 0x4009A4, nvkm_rd32(device, 0x100200));\n\t\tnvkm_wr32(device, 0x4009A8, nvkm_rd32(device, 0x100204));\n\t\tnvkm_wr32(device, 0x4069A4, nvkm_rd32(device, 0x100200));\n\t\tnvkm_wr32(device, 0x4069A8, nvkm_rd32(device, 0x100204));\n\t\tnvkm_wr32(device, 0x400820, 0);\n\t\tnvkm_wr32(device, 0x400824, 0);\n\t\tnvkm_wr32(device, 0x400864, vramsz);\n\t\tnvkm_wr32(device, 0x400868, vramsz);\n\t\tbreak;\n\tdefault:\n\t\tswitch (device->chipset) {\n\t\tcase 0x41:\n\t\tcase 0x42:\n\t\tcase 0x43:\n\t\tcase 0x45:\n\t\tcase 0x4e:\n\t\tcase 0x44:\n\t\tcase 0x4a:\n\t\t\tnvkm_wr32(device, 0x4009F0, nvkm_rd32(device, 0x100200));\n\t\t\tnvkm_wr32(device, 0x4009F4, nvkm_rd32(device, 0x100204));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnvkm_wr32(device, 0x400DF0, nvkm_rd32(device, 0x100200));\n\t\t\tnvkm_wr32(device, 0x400DF4, nvkm_rd32(device, 0x100204));\n\t\t\tbreak;\n\t\t}\n\t\tnvkm_wr32(device, 0x4069F0, nvkm_rd32(device, 0x100200));\n\t\tnvkm_wr32(device, 0x4069F4, nvkm_rd32(device, 0x100204));\n\t\tnvkm_wr32(device, 0x400840, 0);\n\t\tnvkm_wr32(device, 0x400844, 0);\n\t\tnvkm_wr32(device, 0x4008A0, vramsz);\n\t\tnvkm_wr32(device, 0x4008A4, vramsz);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint\nnv40_gr_new_(const struct nvkm_gr_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\tstruct nv40_gr *gr;\n\n\tif (!(gr = kzalloc(sizeof(*gr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pgr = &gr->base;\n\tINIT_LIST_HEAD(&gr->chan);\n\n\treturn nvkm_gr_ctor(func, device, type, inst, true, &gr->base);\n}\n\nstatic const struct nvkm_gr_func\nnv40_gr = {\n\t.init = nv40_gr_init,\n\t.intr = nv40_gr_intr,\n\t.tile = nv40_gr_tile,\n\t.units = nv40_gr_units,\n\t.chan_new = nv40_gr_chan_new,\n\t.sclass = {\n\t\t{ -1, -1, 0x0012, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0019, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0030, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0039, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0043, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0044, &nv40_gr_object },  \n\t\t{ -1, -1, 0x004a, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0062, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0072, &nv40_gr_object },  \n\t\t{ -1, -1, 0x0089, &nv40_gr_object },  \n\t\t{ -1, -1, 0x008a, &nv40_gr_object },  \n\t\t{ -1, -1, 0x009f, &nv40_gr_object },  \n\t\t{ -1, -1, 0x3062, &nv40_gr_object },  \n\t\t{ -1, -1, 0x3089, &nv40_gr_object },  \n\t\t{ -1, -1, 0x309e, &nv40_gr_object },  \n\t\t{ -1, -1, 0x4097, &nv40_gr_object },  \n\t\t{}\n\t}\n};\n\nint\nnv40_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn nv40_gr_new_(&nv40_gr, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}