{
  "module_name": "com.fuc",
  "hash_id": "1c02ea9eeb00a680950039ea3f95884cadc95dd09b025f9f611c5e260111dc24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/ce/fuc/com.fuc",
  "human_readable_source": "/* fuc microcode for copy engine on gt215- chipsets\n *\n * Copyright 2011 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n#ifdef GT215\n.section #gt215_ce_data\n#else\n.section #gf100_ce_data\n#endif\n\nctx_object:                   .b32 0\n#ifdef GT215\nctx_dma:\nctx_dma_query:                .b32 0\nctx_dma_src:                  .b32 0\nctx_dma_dst:                  .b32 0\n#endif\n.equ #ctx_dma_count 3\nctx_query_address_high:       .b32 0\nctx_query_address_low:        .b32 0\nctx_query_counter:            .b32 0\nctx_src_address_high:         .b32 0\nctx_src_address_low:          .b32 0\nctx_src_pitch:                .b32 0\nctx_src_tile_mode:            .b32 0\nctx_src_xsize:                .b32 0\nctx_src_ysize:                .b32 0\nctx_src_zsize:                .b32 0\nctx_src_zoff:                 .b32 0\nctx_src_xoff:                 .b32 0\nctx_src_yoff:                 .b32 0\nctx_src_cpp:                  .b32 0\nctx_dst_address_high:         .b32 0\nctx_dst_address_low:          .b32 0\nctx_dst_pitch:                .b32 0\nctx_dst_tile_mode:            .b32 0\nctx_dst_xsize:                .b32 0\nctx_dst_ysize:                .b32 0\nctx_dst_zsize:                .b32 0\nctx_dst_zoff:                 .b32 0\nctx_dst_xoff:                 .b32 0\nctx_dst_yoff:                 .b32 0\nctx_dst_cpp:                  .b32 0\nctx_format:                   .b32 0\nctx_swz_const0:               .b32 0\nctx_swz_const1:               .b32 0\nctx_xcnt:                     .b32 0\nctx_ycnt:                     .b32 0\n.align 256\n\ndispatch_table:\n// mthd 0x0000, NAME\n.b16 0x000 1\n.b32 #ctx_object                     ~0xffffffff\n// mthd 0x0100, NOP\n.b16 0x040 1\n.b32 0x00010000 + #cmd_nop           ~0xffffffff\n// mthd 0x0140, PM_TRIGGER\n.b16 0x050 1\n.b32 0x00010000 + #cmd_pm_trigger    ~0xffffffff\n#ifdef GT215\n// mthd 0x0180-0x018c, DMA_\n.b16 0x060 #ctx_dma_count\ndispatch_dma:\n.b32 0x00010000 + #cmd_dma           ~0xffffffff\n.b32 0x00010000 + #cmd_dma           ~0xffffffff\n.b32 0x00010000 + #cmd_dma           ~0xffffffff\n#endif\n// mthd 0x0200-0x0218, SRC_TILE\n.b16 0x80 7\n.b32 #ctx_src_tile_mode              ~0x00000fff\n.b32 #ctx_src_xsize                  ~0x0007ffff\n.b32 #ctx_src_ysize                  ~0x00001fff\n.b32 #ctx_src_zsize                  ~0x000007ff\n.b32 #ctx_src_zoff                   ~0x00000fff\n.b32 #ctx_src_xoff                   ~0x0007ffff\n.b32 #ctx_src_yoff                   ~0x00001fff\n// mthd 0x0220-0x0238, DST_TILE\n.b16 0x88 7\n.b32 #ctx_dst_tile_mode              ~0x00000fff\n.b32 #ctx_dst_xsize                  ~0x0007ffff\n.b32 #ctx_dst_ysize                  ~0x00001fff\n.b32 #ctx_dst_zsize                  ~0x000007ff\n.b32 #ctx_dst_zoff                   ~0x00000fff\n.b32 #ctx_dst_xoff                   ~0x0007ffff\n.b32 #ctx_dst_yoff                   ~0x00001fff\n// mthd 0x0300-0x0304, EXEC, WRCACHE_FLUSH\n.b16 0xc0 2\n.b32 0x00010000 + #cmd_exec          ~0xffffffff\n.b32 0x00010000 + #cmd_wrcache_flush ~0xffffffff\n// mthd 0x030c-0x0340, various stuff\n.b16 0xc3 14\n.b32 #ctx_src_address_high           ~0x000000ff\n.b32 #ctx_src_address_low            ~0xffffffff\n.b32 #ctx_dst_address_high           ~0x000000ff\n.b32 #ctx_dst_address_low            ~0xffffffff\n.b32 #ctx_src_pitch                  ~0x0007ffff\n.b32 #ctx_dst_pitch                  ~0x0007ffff\n.b32 #ctx_xcnt                       ~0x0000ffff\n.b32 #ctx_ycnt                       ~0x00001fff\n.b32 #ctx_format                     ~0x0333ffff\n.b32 #ctx_swz_const0                 ~0xffffffff\n.b32 #ctx_swz_const1                 ~0xffffffff\n.b32 #ctx_query_address_high         ~0x000000ff\n.b32 #ctx_query_address_low          ~0xffffffff\n.b32 #ctx_query_counter              ~0xffffffff\n.b16 0x800 0\n\n#ifdef GT215\n.section #gt215_ce_code\n#else\n.section #gf100_ce_code\n#endif\n\nmain:\n   clear b32 $r0\n   mov $sp $r0\n\n   // setup i0 handler and route fifo and ctxswitch to it\n   mov $r1 #ih\n   mov $iv0 $r1\n   mov $r1 0x400\n   movw $r2 0xfff3\n   sethi $r2 0\n   iowr I[$r1 + 0x300] $r2\n\n   // enable interrupts\n   or $r2 0xc\n   iowr I[$r1] $r2\n   bset $flags ie0\n\n   // enable fifo access and context switching\n   mov $r1 0x1200\n   mov $r2 3\n   iowr I[$r1] $r2\n\n   // sleep forever, waking for interrupts\n   bset $flags $p0\n   spin:\n      sleep $p0\n      bra #spin\n\n// i0 handler\nih:\n   iord $r1 I[$r0 + 0x200]\n\n   and $r2 $r1 0x00000008\n   bra e #ih_no_chsw\n      call #chsw\n   ih_no_chsw:\n   and $r2 $r1 0x00000004\n   bra e #ih_no_cmd\n      call #dispatch\n\n   ih_no_cmd:\n   and $r1 $r1 0x0000000c\n   iowr I[$r0 + 0x100] $r1\n   iret\n\n// $p1 direction (0 = unload, 1 = load)\n// $r3 channel\nswctx:\n   mov $r4 0x7700\n   mov $xtargets $r4\n#ifdef GT215\n   // target 7 hardcoded to ctx dma object\n   mov $xdbase $r0\n#else\n   // read SCRATCH3 to decide if we are PCOPY0 or PCOPY1\n   mov $r4 0x2100\n   iord $r4 I[$r4 + 0]\n   and $r4 1\n   shl b32 $r4 4\n   add b32 $r4 0x30\n\n   // channel is in vram\n   mov $r15 0x61c\n   shl b32 $r15 6\n   mov $r5 0x114\n   iowrs I[$r15] $r5\n\n   // read 16-byte PCOPYn info, containing context pointer, from channel\n   shl b32 $r5 $r3 4\n   add b32 $r5 2\n   mov $xdbase $r5\n   mov $r5 $sp\n   // get a chunk of stack space, aligned to 256 byte boundary\n   sub b32 $r5 0x100\n   mov $r6 0xff\n   not b32 $r6\n   and $r5 $r6\n   sethi $r5 0x00020000\n   xdld $r4 $r5\n   xdwait\n   sethi $r5 0\n\n   // set context pointer, from within channel VM\n   mov $r14 0\n   iowrs I[$r15] $r14\n   ld b32 $r4 D[$r5 + 0]\n   shr b32 $r4 8\n   ld b32 $r6 D[$r5 + 4]\n   shl b32 $r6 24\n   or $r4 $r6\n   mov $xdbase $r4\n#endif\n   // 256-byte context, at start of data segment\n   mov b32 $r4 $r0\n   sethi $r4 0x60000\n\n   // swap!\n   bra $p1 #swctx_load\n      xdst $r0 $r4\n      bra #swctx_done\n   swctx_load:\n      xdld $r0 $r4\n   swctx_done:\n   xdwait\n   ret\n\nchsw:\n   // read current channel\n   mov $r2 0x1400\n   iord $r3 I[$r2]\n\n   // if it's active, unload it and return\n   xbit $r15 $r3 0x1e\n   bra e #chsw_no_unload\n      bclr $flags $p1\n      call #swctx\n      bclr $r3 0x1e\n      iowr I[$r2] $r3\n      mov $r4 1\n      iowr I[$r2 + 0x200] $r4\n      ret\n\n   // read next channel\n   chsw_no_unload:\n   iord $r3 I[$r2 + 0x100]\n\n   // is there a channel waiting to be loaded?\n   xbit $r13 $r3 0x1e\n   bra e #chsw_finish_load\n      bset $flags $p1\n      call #swctx\n#ifdef GT215\n      // load dma objects back into TARGET regs\n      mov $r5 #ctx_dma\n      mov $r6 #ctx_dma_count\n      chsw_load_ctx_dma:\n         ld b32 $r7 D[$r5 + $r6 * 4]\n         add b32 $r8 $r6 0x180\n         shl b32 $r8 8\n         iowr I[$r8] $r7\n         sub b32 $r6 1\n         bra nc #chsw_load_ctx_dma\n#endif\n   chsw_finish_load:\n   mov $r3 2\n   iowr I[$r2 + 0x200] $r3\n   ret\n\ndispatch:\n   // read incoming fifo command\n   mov $r3 0x1900\n   iord $r2 I[$r3 + 0x100]\n   iord $r3 I[$r3 + 0x000]\n   and $r4 $r2 0x7ff\n   // $r2 will be used to store exception data\n   shl b32 $r2 0x10\n\n   // lookup method in the dispatch table, ILLEGAL_MTHD if not found\n   mov $r5 #dispatch_table\n   clear b32 $r6\n   clear b32 $r7\n   dispatch_loop:\n      ld b16 $r6 D[$r5 + 0]\n      ld b16 $r7 D[$r5 + 2]\n      add b32 $r5 4\n      cmpu b32 $r4 $r6\n      bra c #dispatch_illegal_mthd\n      add b32 $r7 $r6\n      cmpu b32 $r4 $r7\n      bra c #dispatch_valid_mthd\n      sub b32 $r7 $r6\n      shl b32 $r7 3\n      add b32 $r5 $r7\n      bra #dispatch_loop\n\n   // ensure no bits set in reserved fields, INVALID_BITFIELD\n   dispatch_valid_mthd:\n   sub b32 $r4 $r6\n   shl b32 $r4 3\n   add b32 $r4 $r5\n   ld b32 $r5 D[$r4 + 4]\n   and $r5 $r3\n   cmpu b32 $r5 0\n   bra ne #dispatch_invalid_bitfield\n\n   // depending on dispatch flags: execute method, or save data as state\n   ld b16 $r5 D[$r4 + 0]\n   ld b16 $r6 D[$r4 + 2]\n   cmpu b32 $r6 0\n   bra ne #dispatch_cmd\n      st b32 D[$r5] $r3\n      bra #dispatch_done\n   dispatch_cmd:\n      bclr $flags $p1\n      call $r5\n      bra $p1 #dispatch_error\n      bra #dispatch_done\n\n   dispatch_invalid_bitfield:\n   or $r2 2\n   dispatch_illegal_mthd:\n   or $r2 1\n\n   // store exception data in SCRATCH0/SCRATCH1, signal hostirq\n   dispatch_error:\n   mov $r4 0x1000\n   iowr I[$r4 + 0x000] $r2\n   iowr I[$r4 + 0x100] $r3\n   mov $r2 0x40\n   iowr I[$r0] $r2\n   hostirq_wait:\n      iord $r2 I[$r0 + 0x200]\n      and $r2 0x40\n      cmpu b32 $r2 0\n      bra ne #hostirq_wait\n\n   dispatch_done:\n   mov $r2 0x1d00\n   mov $r3 1\n   iowr I[$r2] $r3\n   ret\n\n// No-operation\n//\n// Inputs:\n//    $r1: irqh state\n//    $r2: hostirq state\n//    $r3: data\n//    $r4: dispatch table entry\n// Outputs:\n//    $r1: irqh state\n//    $p1: set on error\n//       $r2: hostirq state\n//       $r3: data\ncmd_nop:\n   ret\n\n// PM_TRIGGER\n//\n// Inputs:\n//    $r1: irqh state\n//    $r2: hostirq state\n//    $r3: data\n//    $r4: dispatch table entry\n// Outputs:\n//    $r1: irqh state\n//    $p1: set on error\n//       $r2: hostirq state\n//       $r3: data\ncmd_pm_trigger:\n   mov $r2 0x2200\n   clear b32 $r3\n   sethi $r3 0x20000\n   iowr I[$r2] $r3\n   ret\n\n#ifdef GT215\n// SET_DMA_* method handler\n//\n// Inputs:\n//    $r1: irqh state\n//    $r2: hostirq state\n//    $r3: data\n//    $r4: dispatch table entry\n// Outputs:\n//    $r1: irqh state\n//    $p1: set on error\n//       $r2: hostirq state\n//       $r3: data\ncmd_dma:\n   sub b32 $r4 #dispatch_dma\n   shr b32 $r4 1\n   bset $r3 0x1e\n   st b32 D[$r4 + #ctx_dma] $r3\n   add b32 $r4 0x600\n   shl b32 $r4 6\n   iowr I[$r4] $r3\n   ret\n#endif\n\n// Calculates the hw swizzle mask and adjusts the surface's xcnt to match\n//\ncmd_exec_set_format:\n   // zero out a chunk of the stack to store the swizzle into\n   add $sp -0x10\n   st b32 D[$sp + 0x00] $r0\n   st b32 D[$sp + 0x04] $r0\n   st b32 D[$sp + 0x08] $r0\n   st b32 D[$sp + 0x0c] $r0\n\n   // extract cpp, src_ncomp and dst_ncomp from FORMAT\n   ld b32 $r4 D[$r0 + #ctx_format]\n   extr $r5 $r4 16:17\n   add b32 $r5 1\n   extr $r6 $r4 20:21\n   add b32 $r6 1\n   extr $r7 $r4 24:25\n   add b32 $r7 1\n\n   // convert FORMAT swizzle mask to hw swizzle mask\n   bclr $flags $p2\n   clear b32 $r8\n   clear b32 $r9\n   ncomp_loop:\n      and $r10 $r4 0xf\n      shr b32 $r4 4\n      clear b32 $r11\n      bpc_loop:\n         cmpu b8 $r10 4\n         bra nc #cmp_c0\n            mulu $r12 $r10 $r5\n            add b32 $r12 $r11\n            bset $flags $p2\n            bra #bpc_next\n         cmp_c0:\n         bra ne #cmp_c1\n            mov $r12 0x10\n            add b32 $r12 $r11\n            bra #bpc_next\n         cmp_c1:\n         cmpu b8 $r10 6\n         bra nc #cmp_zero\n            mov $r12 0x14\n            add b32 $r12 $r11\n            bra #bpc_next\n         cmp_zero:\n            mov $r12 0x80\n         bpc_next:\n         st b8 D[$sp + $r8] $r12\n         add b32 $r8 1\n         add b32 $r11 1\n         cmpu b32 $r11 $r5\n         bra c #bpc_loop\n      add b32 $r9 1\n      cmpu b32 $r9 $r7\n      bra c #ncomp_loop\n\n   // SRC_XCNT = (xcnt * src_cpp), or 0 if no src ref in swz (hw will hang)\n   mulu $r6 $r5\n   st b32 D[$r0 + #ctx_src_cpp] $r6\n   ld b32 $r8 D[$r0 + #ctx_xcnt]\n   mulu $r6 $r8\n   bra $p2 #dst_xcnt\n   clear b32 $r6\n\n   dst_xcnt:\n   mulu $r7 $r5\n   st b32 D[$r0 + #ctx_dst_cpp] $r7\n   mulu $r7 $r8\n\n   mov $r5 0x810\n   shl b32 $r5 6\n   iowr I[$r5 + 0x000] $r6\n   iowr I[$r5 + 0x100] $r7\n   add b32 $r5 0x800\n   ld b32 $r6 D[$r0 + #ctx_dst_cpp]\n   sub b32 $r6 1\n   shl b32 $r6 8\n   ld b32 $r7 D[$r0 + #ctx_src_cpp]\n   sub b32 $r7 1\n   or $r6 $r7\n   iowr I[$r5 + 0x000] $r6\n   add b32 $r5 0x100\n   ld b32 $r6 D[$sp + 0x00]\n   iowr I[$r5 + 0x000] $r6\n   ld b32 $r6 D[$sp + 0x04]\n   iowr I[$r5 + 0x100] $r6\n   ld b32 $r6 D[$sp + 0x08]\n   iowr I[$r5 + 0x200] $r6\n   ld b32 $r6 D[$sp + 0x0c]\n   iowr I[$r5 + 0x300] $r6\n   add b32 $r5 0x400\n   ld b32 $r6 D[$r0 + #ctx_swz_const0]\n   iowr I[$r5 + 0x000] $r6\n   ld b32 $r6 D[$r0 + #ctx_swz_const1]\n   iowr I[$r5 + 0x100] $r6\n   add $sp 0x10\n   ret\n\n// Setup to handle a tiled surface\n//\n// Calculates a number of parameters the hardware requires in order\n// to correctly handle tiling.\n//\n// Offset calculation is performed as follows (Tp/Th/Td from TILE_MODE):\n//    nTx = round_up(w * cpp, 1 << Tp) >> Tp\n//    nTy = round_up(h, 1 << Th) >> Th\n//    Txo = (x * cpp) & ((1 << Tp) - 1)\n//     Tx = (x * cpp) >> Tp\n//    Tyo = y & ((1 << Th) - 1)\n//     Ty = y >> Th\n//    Tzo = z & ((1 << Td) - 1)\n//     Tz = z >> Td\n//\n//    off  = (Tzo << Tp << Th) + (Tyo << Tp) + Txo\n//    off += ((Tz * nTy * nTx)) + (Ty * nTx) + Tx) << Td << Th << Tp;\n//\n// Inputs:\n//    $r4: hw command (0x104800)\n//    $r5: ctx offset adjustment for src/dst selection\n//    $p2: set if dst surface\n//\ncmd_exec_set_surface_tiled:\n   // translate TILE_MODE into Tp, Th, Td shift values\n   ld b32 $r7 D[$r5 + #ctx_src_tile_mode]\n   extr $r9 $r7 8:11\n   extr $r8 $r7 4:7\n#ifdef GT215\n   add b32 $r8 2\n#else\n   add b32 $r8 3\n#endif\n   extr $r7 $r7 0:3\n   cmp b32 $r7 0xe\n   bra ne #xtile64\n   mov $r7 4\n   bra #xtileok\n   xtile64:\n   xbit $r7 $flags $p2\n   add b32 $r7 17\n   bset $r4 $r7\n   mov $r7 6\n   xtileok:\n\n   // Op = (x * cpp) & ((1 << Tp) - 1)\n   // Tx = (x * cpp) >> Tp\n   ld b32 $r10 D[$r5 + #ctx_src_xoff]\n   ld b32 $r11 D[$r5 + #ctx_src_cpp]\n   mulu $r10 $r11\n   mov $r11 1\n   shl b32 $r11 $r7\n   sub b32 $r11 1\n   and $r12 $r10 $r11\n   shr b32 $r10 $r7\n\n   // Tyo = y & ((1 << Th) - 1)\n   // Ty  = y >> Th\n   ld b32 $r13 D[$r5 + #ctx_src_yoff]\n   mov $r14 1\n   shl b32 $r14 $r8\n   sub b32 $r14 1\n   and $r11 $r13 $r14\n   shr b32 $r13 $r8\n\n   // YTILE = ((1 << Th) << 12) | ((1 << Th) - Tyo)\n   add b32 $r14 1\n   shl b32 $r15 $r14 12\n   sub b32 $r14 $r11\n   or $r15 $r14\n   xbit $r6 $flags $p2\n   add b32 $r6 0x208\n   shl b32 $r6 8\n   iowr I[$r6 + 0x000] $r15\n\n   // Op += Tyo << Tp\n   shl b32 $r11 $r7\n   add b32 $r12 $r11\n\n   // nTx = ((w * cpp) + ((1 << Tp) - 1) >> Tp)\n   ld b32 $r15 D[$r5 + #ctx_src_xsize]\n   ld b32 $r11 D[$r5 + #ctx_src_cpp]\n   mulu $r15 $r11\n   mov $r11 1\n   shl b32 $r11 $r7\n   sub b32 $r11 1\n   add b32 $r15 $r11\n   shr b32 $r15 $r7\n   push $r15\n\n   // nTy = (h + ((1 << Th) - 1)) >> Th\n   ld b32 $r15 D[$r5 + #ctx_src_ysize]\n   mov $r11 1\n   shl b32 $r11 $r8\n   sub b32 $r11 1\n   add b32 $r15 $r11\n   shr b32 $r15 $r8\n   push $r15\n\n   // Tys = Tp + Th\n   // CFG_YZ_TILE_SIZE = ((1 << Th) >> 2) << Td\n   add b32 $r7 $r8\n   sub b32 $r8 2\n   mov $r11 1\n   shl b32 $r11 $r8\n   shl b32 $r11 $r9\n\n   // Tzo = z & ((1 << Td) - 1)\n   // Tz  = z >> Td\n   // Op += Tzo << Tys\n   // Ts  = Tys + Td\n   ld b32 $r8 D[$r5 + #ctx_src_zoff]\n   mov $r14 1\n   shl b32 $r14 $r9\n   sub b32 $r14 1\n   and $r15 $r8 $r14\n   shl b32 $r15 $r7\n   add b32 $r12 $r15\n   add b32 $r7 $r9\n   shr b32 $r8 $r9\n\n   // Ot = ((Tz * nTy * nTx) + (Ty * nTx) + Tx) << Ts\n   pop $r15\n   pop $r9\n   mulu $r13 $r9\n   add b32 $r10 $r13\n   mulu $r8 $r9\n   mulu $r8 $r15\n   add b32 $r10 $r8\n   shl b32 $r10 $r7\n\n   // PITCH = (nTx - 1) << Ts\n   sub b32 $r9 1\n   shl b32 $r9 $r7\n   iowr I[$r6 + 0x200] $r9\n\n   // SRC_ADDRESS_LOW   = (Ot + Op) & 0xffffffff\n   // CFG_ADDRESS_HIGH |= ((Ot + Op) >> 32) << 16\n   ld b32 $r7 D[$r5 + #ctx_src_address_low]\n   ld b32 $r8 D[$r5 + #ctx_src_address_high]\n   add b32 $r10 $r12\n   add b32 $r7 $r10\n   adc b32 $r8 0\n   shl b32 $r8 16\n   or $r8 $r11\n   sub b32 $r6 0x600\n   iowr I[$r6 + 0x000] $r7\n   add b32 $r6 0x400\n   iowr I[$r6 + 0x000] $r8\n   ret\n\n// Setup to handle a linear surface\n//\n// Nothing to see here.. Sets ADDRESS and PITCH, pretty non-exciting\n//\ncmd_exec_set_surface_linear:\n   xbit $r6 $flags $p2\n   add b32 $r6 0x202\n   shl b32 $r6 8\n   ld b32 $r7 D[$r5 + #ctx_src_address_low]\n   iowr I[$r6 + 0x000] $r7\n   add b32 $r6 0x400\n   ld b32 $r7 D[$r5 + #ctx_src_address_high]\n   shl b32 $r7 16\n   iowr I[$r6 + 0x000] $r7\n   add b32 $r6 0x400\n   ld b32 $r7 D[$r5 + #ctx_src_pitch]\n   iowr I[$r6 + 0x000] $r7\n   ret\n\n// wait for regs to be available for use\ncmd_exec_wait:\n   push $r0\n   push $r1\n   mov $r0 0x800\n   shl b32 $r0 6\n   loop:\n      iord $r1 I[$r0]\n      and $r1 1\n      bra ne #loop\n   pop $r1\n   pop $r0\n   ret\n\ncmd_exec_query:\n   // if QUERY_SHORT not set, write out { -, 0, TIME_LO, TIME_HI }\n   xbit $r4 $r3 13\n   bra ne #query_counter\n      call #cmd_exec_wait\n      mov $r4 0x80c\n      shl b32 $r4 6\n      ld b32 $r5 D[$r0 + #ctx_query_address_low]\n      add b32 $r5 4\n      iowr I[$r4 + 0x000] $r5\n      iowr I[$r4 + 0x100] $r0\n      mov $r5 0xc\n      iowr I[$r4 + 0x200] $r5\n      add b32 $r4 0x400\n      ld b32 $r5 D[$r0 + #ctx_query_address_high]\n      shl b32 $r5 16\n      iowr I[$r4 + 0x000] $r5\n      add b32 $r4 0x500\n      mov $r5 0x00000b00\n      sethi $r5 0x00010000\n      iowr I[$r4 + 0x000] $r5\n      mov $r5 0x00004040\n      shl b32 $r5 1\n      sethi $r5 0x80800000\n      iowr I[$r4 + 0x100] $r5\n      mov $r5 0x00001110\n      sethi $r5 0x13120000\n      iowr I[$r4 + 0x200] $r5\n      mov $r5 0x00001514\n      sethi $r5 0x17160000\n      iowr I[$r4 + 0x300] $r5\n      mov $r5 0x00002601\n      sethi $r5 0x00010000\n      mov $r4 0x800\n      shl b32 $r4 6\n      iowr I[$r4 + 0x000] $r5\n\n   // write COUNTER\n   query_counter:\n   call #cmd_exec_wait\n   mov $r4 0x80c\n   shl b32 $r4 6\n   ld b32 $r5 D[$r0 + #ctx_query_address_low]\n   iowr I[$r4 + 0x000] $r5\n   iowr I[$r4 + 0x100] $r0\n   mov $r5 0x4\n   iowr I[$r4 + 0x200] $r5\n   add b32 $r4 0x400\n   ld b32 $r5 D[$r0 + #ctx_query_address_high]\n   shl b32 $r5 16\n   iowr I[$r4 + 0x000] $r5\n   add b32 $r4 0x500\n   mov $r5 0x00000300\n   iowr I[$r4 + 0x000] $r5\n   mov $r5 0x00001110\n   sethi $r5 0x13120000\n   iowr I[$r4 + 0x100] $r5\n   ld b32 $r5 D[$r0 + #ctx_query_counter]\n   add b32 $r4 0x500\n   iowr I[$r4 + 0x000] $r5\n   mov $r5 0x00002601\n   sethi $r5 0x00010000\n   mov $r4 0x800\n   shl b32 $r4 6\n   iowr I[$r4 + 0x000] $r5\n   ret\n\n// Execute a copy operation\n//\n// Inputs:\n//    $r1: irqh state\n//    $r2: hostirq state\n//    $r3: data\n//       000002000 QUERY_SHORT\n//       000001000 QUERY\n//       000000100 DST_LINEAR\n//       000000010 SRC_LINEAR\n//       000000001 FORMAT\n//    $r4: dispatch table entry\n// Outputs:\n//    $r1: irqh state\n//    $p1: set on error\n//       $r2: hostirq state\n//       $r3: data\ncmd_exec:\n   call #cmd_exec_wait\n\n   // if format requested, call function to calculate it, otherwise\n   // fill in cpp/xcnt for both surfaces as if (cpp == 1)\n   xbit $r15 $r3 0\n   bra e #cmd_exec_no_format\n      call #cmd_exec_set_format\n      mov $r4 0x200\n      bra #cmd_exec_init_src_surface\n   cmd_exec_no_format:\n      mov $r6 0x810\n      shl b32 $r6 6\n      mov $r7 1\n      st b32 D[$r0 + #ctx_src_cpp] $r7\n      st b32 D[$r0 + #ctx_dst_cpp] $r7\n      ld b32 $r7 D[$r0 + #ctx_xcnt]\n      iowr I[$r6 + 0x000] $r7\n      iowr I[$r6 + 0x100] $r7\n      clear b32 $r4\n\n   cmd_exec_init_src_surface:\n   bclr $flags $p2\n   clear b32 $r5\n   xbit $r15 $r3 4\n   bra e #src_tiled\n      call #cmd_exec_set_surface_linear\n      bra #cmd_exec_init_dst_surface\n   src_tiled:\n      call #cmd_exec_set_surface_tiled\n      bset $r4 7\n\n   cmd_exec_init_dst_surface:\n   bset $flags $p2\n   mov $r5 #ctx_dst_address_high - #ctx_src_address_high\n   xbit $r15 $r3 8\n   bra e #dst_tiled\n      call #cmd_exec_set_surface_linear\n      bra #cmd_exec_kick\n   dst_tiled:\n      call #cmd_exec_set_surface_tiled\n      bset $r4 8\n\n   cmd_exec_kick:\n   mov $r5 0x800\n   shl b32 $r5 6\n   ld b32 $r6 D[$r0 + #ctx_ycnt]\n   iowr I[$r5 + 0x100] $r6\n   mov $r6 0x0041\n   // SRC_TARGET = 1, DST_TARGET = 2\n   sethi $r6 0x44000000\n   or $r4 $r6\n   iowr I[$r5] $r4\n\n   // if requested, queue up a QUERY write after the copy has completed\n   xbit $r15 $r3 12\n   bra e #cmd_exec_done\n      call #cmd_exec_query\n\n   cmd_exec_done:\n   ret\n\n// Flush write cache\n//\n// Inputs:\n//    $r1: irqh state\n//    $r2: hostirq state\n//    $r3: data\n//    $r4: dispatch table entry\n// Outputs:\n//    $r1: irqh state\n//    $p1: set on error\n//       $r2: hostirq state\n//       $r3: data\ncmd_wrcache_flush:\n   mov $r2 0x2200\n   clear b32 $r3\n   sethi $r3 0x10000\n   iowr I[$r2] $r3\n   ret\n\n.align 0x100\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}