{
  "module_name": "ctxgm200.c",
  "hash_id": "14a0b1bc4eefffc62f3e51672ccd9aa368feb5228807293226c34fd10020690f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgm200.c",
  "human_readable_source": " \n#include \"ctxgf100.h\"\n\n \n\nvoid\ngm200_grctx_generate_r419a3c(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, 0x419a3c, 0x00000014, 0x00000000);\n}\n\nstatic void\ngm200_grctx_generate_r418e94(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, 0x418e94, 0xffffffff, 0xc4230000);\n\tnvkm_mask(device, 0x418e4c, 0xffffffff, 0x70000000);\n}\n\nvoid\ngm200_grctx_generate_smid_config(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst u32 dist_nr = DIV_ROUND_UP(gr->tpc_total, 4);\n\tu32 dist[TPC_MAX / 4] = {};\n\tu32 gpcs[GPC_MAX] = {};\n\tu8  sm, i;\n\n\tfor (sm = 0; sm < gr->sm_nr; sm++) {\n\t\tconst u8 gpc = gr->sm[sm].gpc;\n\t\tconst u8 tpc = gr->sm[sm].tpc;\n\t\tdist[sm / 4] |= ((gpc << 4) | tpc) << ((sm % 4) * 8);\n\t\tgpcs[gpc] |= sm << (tpc * 8);\n\t}\n\n\tfor (i = 0; i < dist_nr; i++)\n\t\tnvkm_wr32(device, 0x405b60 + (i * 4), dist[i]);\n\tfor (i = 0; i < gr->gpc_nr; i++)\n\t\tnvkm_wr32(device, 0x405ba0 + (i * 4), gpcs[i]);\n}\n\nvoid\ngm200_grctx_generate_tpc_mask(struct gf100_gr *gr)\n{\n\tu32 tmp, i;\n\tfor (tmp = 0, i = 0; i < gr->gpc_nr; i++)\n\t\ttmp |= ((1 << gr->tpc_nr[i]) - 1) << (i * gr->func->tpc_nr);\n\tnvkm_wr32(gr->base.engine.subdev.device, 0x4041c4, tmp);\n}\n\nvoid\ngm200_grctx_generate_r406500(struct gf100_gr *gr)\n{\n\tnvkm_wr32(gr->base.engine.subdev.device, 0x406500, 0x00000000);\n}\n\nvoid\ngm200_grctx_generate_dist_skip_table(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tu32 data[8] = {};\n\tint gpc, ppc, i;\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tfor (ppc = 0; ppc < gr->func->ppc_nr; ppc++) {\n\t\t\tu8 ppc_tpcs = gr->ppc_tpc_nr[gpc][ppc];\n\t\t\tu8 ppc_tpcm = gr->ppc_tpc_mask[gpc][ppc];\n\t\t\twhile (ppc_tpcs-- > gr->ppc_tpc_min)\n\t\t\t\tppc_tpcm &= ppc_tpcm - 1;\n\t\t\tppc_tpcm ^= gr->ppc_tpc_mask[gpc][ppc];\n\t\t\t((u8 *)data)[gpc] |= ppc_tpcm;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data); i++)\n\t\tnvkm_wr32(device, 0x4064d0 + (i * 0x04), data[i]);\n}\n\nconst struct gf100_grctx_func\ngm200_grctx = {\n\t.main  = gf100_grctx_generate_main,\n\t.unkn  = gk104_grctx_generate_unkn,\n\t.bundle = gm107_grctx_generate_bundle,\n\t.bundle_size = 0x3000,\n\t.bundle_min_gpm_fifo_depth = 0x180,\n\t.bundle_token_limit = 0x780,\n\t.pagepool = gm107_grctx_generate_pagepool,\n\t.pagepool_size = 0x20000,\n\t.attrib_cb_size = gf100_grctx_generate_attrib_cb_size,\n\t.attrib_cb = gm107_grctx_generate_attrib_cb,\n\t.attrib = gm107_grctx_generate_attrib,\n\t.attrib_nr_max = 0x600,\n\t.attrib_nr = 0x400,\n\t.alpha_nr_max = 0x1800,\n\t.alpha_nr = 0x1000,\n\t.sm_id = gm107_grctx_generate_sm_id,\n\t.rop_mapping = gf117_grctx_generate_rop_mapping,\n\t.dist_skip_table = gm200_grctx_generate_dist_skip_table,\n\t.r406500 = gm200_grctx_generate_r406500,\n\t.gpc_tpc_nr = gk104_grctx_generate_gpc_tpc_nr,\n\t.tpc_mask = gm200_grctx_generate_tpc_mask,\n\t.smid_config = gm200_grctx_generate_smid_config,\n\t.r418e94 = gm200_grctx_generate_r418e94,\n\t.r419a3c = gm200_grctx_generate_r419a3c,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}