{
  "module_name": "ctxgp100.c",
  "hash_id": "fd8d88555d5e3db1b7a8e158b7ce09b1c02ebd96e27b47635edb58661e008c6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgp100.c",
  "human_readable_source": " \n#include \"ctxgf100.h\"\n\n#include <subdev/fb.h>\n\n \n\nvoid\ngp100_grctx_generate_pagepool(struct gf100_gr_chan *chan, u64 addr)\n{\n\tgf100_grctx_patch_wr32(chan, 0x40800c, addr >> 8);\n\tgf100_grctx_patch_wr32(chan, 0x408010, 0x8007d800);\n\tgf100_grctx_patch_wr32(chan, 0x419004, addr >> 8);\n\tgf100_grctx_patch_wr32(chan, 0x419008, 0x00000000);\n}\n\nstatic void\ngp100_grctx_generate_attrib(struct gf100_gr_chan *chan)\n{\n\tstruct gf100_gr *gr = chan->gr;\n\tconst struct gf100_grctx_func *grctx = gr->func->grctx;\n\tconst u32  alpha = grctx->alpha_nr;\n\tconst u32 attrib = grctx->attrib_nr;\n\tconst int max_batches = 0xffff;\n\tu32 size = grctx->alpha_nr_max * gr->tpc_total;\n\tu32 ao = 0;\n\tu32 bo = ao + size;\n\tint gpc, ppc, n = 0;\n\n\tgf100_grctx_patch_wr32(chan, 0x405830, attrib);\n\tgf100_grctx_patch_wr32(chan, 0x40585c, alpha);\n\tgf100_grctx_patch_wr32(chan, 0x4064c4, ((alpha / 4) << 16) | max_batches);\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tfor (ppc = 0; ppc < gr->func->ppc_nr; ppc++, n++) {\n\t\t\tconst u32 as =  alpha * gr->ppc_tpc_nr[gpc][ppc];\n\t\t\tconst u32 bs = attrib * gr->ppc_tpc_max;\n\t\t\tconst u32 u = 0x418ea0 + (n * 0x04);\n\t\t\tconst u32 o = PPC_UNIT(gpc, ppc, 0);\n\n\t\t\tif (!(gr->ppc_mask[gpc] & (1 << ppc)))\n\t\t\t\tcontinue;\n\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xc0, bs);\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xf4, bo);\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xf0, bs);\n\t\t\tbo += grctx->attrib_nr_max * gr->ppc_tpc_max;\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xe4, as);\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xf8, ao);\n\t\t\tao += grctx->alpha_nr_max * gr->ppc_tpc_nr[gpc][ppc];\n\t\t\tgf100_grctx_patch_wr32(chan, u, bs);\n\t\t}\n\t}\n\n\tgf100_grctx_patch_wr32(chan, 0x418eec, 0x00000000);\n\tgf100_grctx_patch_wr32(chan, 0x41befc, 0x00000000);\n}\n\nvoid\ngp100_grctx_generate_attrib_cb(struct gf100_gr_chan *chan, u64 addr, u32 size)\n{\n\tgm107_grctx_generate_attrib_cb(chan, addr, size);\n\n\tgf100_grctx_patch_wr32(chan, 0x419b00, 0x00000000 | addr >> 12);\n\tgf100_grctx_patch_wr32(chan, 0x419b04, 0x80000000 | size >> 7);\n}\n\nstatic u32\ngp100_grctx_generate_attrib_cb_size(struct gf100_gr *gr)\n{\n\tconst struct gf100_grctx_func *grctx = gr->func->grctx;\n\tu32 size = grctx->alpha_nr_max * gr->tpc_total;\n\tint gpc;\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++)\n\t\tsize += grctx->attrib_nr_max * gr->func->ppc_nr * gr->ppc_tpc_max;\n\n\treturn ((size * 0x20) + 128) & ~127;\n}\n\nvoid\ngp100_grctx_generate_smid_config(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst u32 dist_nr = DIV_ROUND_UP(gr->tpc_total, 4);\n\tu32 dist[TPC_MAX / 4] = {}, gpcs[16] = {};\n\tu8  sm, i;\n\n\tfor (sm = 0; sm < gr->sm_nr; sm++) {\n\t\tconst u8 gpc = gr->sm[sm].gpc;\n\t\tconst u8 tpc = gr->sm[sm].tpc;\n\t\tdist[sm / 4] |= ((gpc << 4) | tpc) << ((sm % 4) * 8);\n\t\tgpcs[gpc + (gr->func->gpc_nr * (tpc / 4))] |= sm << ((tpc % 4) * 8);\n\t}\n\n\tfor (i = 0; i < dist_nr; i++)\n\t\tnvkm_wr32(device, 0x405b60 + (i * 4), dist[i]);\n\tfor (i = 0; i < ARRAY_SIZE(gpcs); i++)\n\t\tnvkm_wr32(device, 0x405ba0 + (i * 4), gpcs[i]);\n}\n\nconst struct gf100_grctx_func\ngp100_grctx = {\n\t.main  = gf100_grctx_generate_main,\n\t.unkn  = gk104_grctx_generate_unkn,\n\t.bundle = gm107_grctx_generate_bundle,\n\t.bundle_size = 0x3000,\n\t.bundle_min_gpm_fifo_depth = 0x180,\n\t.bundle_token_limit = 0x1080,\n\t.pagepool = gp100_grctx_generate_pagepool,\n\t.pagepool_size = 0x20000,\n\t.attrib_cb_size = gp100_grctx_generate_attrib_cb_size,\n\t.attrib_cb = gp100_grctx_generate_attrib_cb,\n\t.attrib = gp100_grctx_generate_attrib,\n\t.attrib_nr_max = 0x660,\n\t.attrib_nr = 0x440,\n\t.alpha_nr_max = 0xc00,\n\t.alpha_nr = 0x800,\n\t.sm_id = gm107_grctx_generate_sm_id,\n\t.rop_mapping = gf117_grctx_generate_rop_mapping,\n\t.dist_skip_table = gm200_grctx_generate_dist_skip_table,\n\t.r406500 = gm200_grctx_generate_r406500,\n\t.gpc_tpc_nr = gk104_grctx_generate_gpc_tpc_nr,\n\t.tpc_mask = gm200_grctx_generate_tpc_mask,\n\t.smid_config = gp100_grctx_generate_smid_config,\n\t.r419a3c = gm200_grctx_generate_r419a3c,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}