{
  "module_name": "g84.c",
  "hash_id": "012a317c327a125699944ff72ce2ef739aa88d4d646c6dcf2edb0736a5074b9c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/cipher/g84.c",
  "human_readable_source": " \n#include <engine/cipher.h>\n#include <engine/fifo.h>\n\n#include <core/client.h>\n#include <core/enum.h>\n#include <core/gpuobj.h>\n\n#include <nvif/class.h>\n\nstatic int\ng84_cipher_oclass_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t       int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tint ret = nvkm_gpuobj_new(object->engine->subdev.device, 16,\n\t\t\t\t  align, false, parent, pgpuobj);\n\tif (ret == 0) {\n\t\tnvkm_kmap(*pgpuobj);\n\t\tnvkm_wo32(*pgpuobj, 0x00, object->oclass);\n\t\tnvkm_wo32(*pgpuobj, 0x04, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x08, 0x00000000);\n\t\tnvkm_wo32(*pgpuobj, 0x0c, 0x00000000);\n\t\tnvkm_done(*pgpuobj);\n\t}\n\treturn ret;\n}\n\nstatic const struct nvkm_object_func\ng84_cipher_oclass_func = {\n\t.bind = g84_cipher_oclass_bind,\n};\n\nstatic int\ng84_cipher_cclass_bind(struct nvkm_object *object, struct nvkm_gpuobj *parent,\n\t\t       int align, struct nvkm_gpuobj **pgpuobj)\n{\n\treturn nvkm_gpuobj_new(object->engine->subdev.device, 256,\n\t\t\t       align, true, parent, pgpuobj);\n\n}\n\nstatic const struct nvkm_object_func\ng84_cipher_cclass = {\n\t.bind = g84_cipher_cclass_bind,\n};\n\nstatic const struct nvkm_bitfield\ng84_cipher_intr_mask[] = {\n\t{ 0x00000001, \"INVALID_STATE\" },\n\t{ 0x00000002, \"ILLEGAL_MTHD\" },\n\t{ 0x00000004, \"ILLEGAL_CLASS\" },\n\t{ 0x00000080, \"QUERY\" },\n\t{ 0x00000100, \"FAULT\" },\n\t{}\n};\n\nstatic void\ng84_cipher_intr(struct nvkm_engine *cipher)\n{\n\tstruct nvkm_subdev *subdev = &cipher->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_chan *chan;\n\tu32 stat = nvkm_rd32(device, 0x102130);\n\tu32 mthd = nvkm_rd32(device, 0x102190);\n\tu32 data = nvkm_rd32(device, 0x102194);\n\tu32 inst = nvkm_rd32(device, 0x102188) & 0x7fffffff;\n\tunsigned long flags;\n\tchar msg[128];\n\n\tchan = nvkm_chan_get_inst(cipher, (u64)inst << 12, &flags);\n\tif (stat) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), g84_cipher_intr_mask, stat);\n\t\tnvkm_error(subdev,  \"%08x [%s] ch %d [%010llx %s] \"\n\t\t\t\t    \"mthd %04x data %08x\\n\", stat, msg,\n\t\t\t   chan ? chan->id : -1, (u64)inst << 12,\n\t\t\t   chan ? chan->name : \"unknown\",\n\t\t\t   mthd, data);\n\t}\n\tnvkm_chan_put(&chan, flags);\n\n\tnvkm_wr32(device, 0x102130, stat);\n\tnvkm_wr32(device, 0x10200c, 0x10);\n}\n\nstatic int\ng84_cipher_init(struct nvkm_engine *cipher)\n{\n\tstruct nvkm_device *device = cipher->subdev.device;\n\tnvkm_wr32(device, 0x102130, 0xffffffff);\n\tnvkm_wr32(device, 0x102140, 0xffffffbf);\n\tnvkm_wr32(device, 0x10200c, 0x00000010);\n\treturn 0;\n}\n\nstatic const struct nvkm_engine_func\ng84_cipher = {\n\t.init = g84_cipher_init,\n\t.intr = g84_cipher_intr,\n\t.cclass = &g84_cipher_cclass,\n\t.sclass = {\n\t\t{ -1, -1, NV74_CIPHER, &g84_cipher_oclass_func },\n\t\t{}\n\t}\n};\n\nint\ng84_cipher_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_engine **pengine)\n{\n\treturn nvkm_engine_new_(&g84_cipher, device, type, inst, true, pengine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}