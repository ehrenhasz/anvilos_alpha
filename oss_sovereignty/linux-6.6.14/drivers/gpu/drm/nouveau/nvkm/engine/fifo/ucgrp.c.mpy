{
  "module_name": "ucgrp.c",
  "hash_id": "4df6f76a4cddd28d52559fa69f06a3cc300aa402149a6fa9cdae27253200dd3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/ucgrp.c",
  "human_readable_source": " \n#define nvkm_ucgrp(p) container_of((p), struct nvkm_ucgrp, object)\n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"runl.h\"\n\n#include <subdev/mmu.h>\n\n#include <nvif/if0021.h>\n\nstruct nvkm_ucgrp {\n\tstruct nvkm_object object;\n\tstruct nvkm_cgrp *cgrp;\n};\n\nstatic int\nnvkm_ucgrp_chan_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t    struct nvkm_object **pobject)\n{\n\tstruct nvkm_cgrp *cgrp = nvkm_ucgrp(oclass->parent)->cgrp;\n\n\treturn nvkm_uchan_new(cgrp->runl->fifo, cgrp, oclass, argv, argc, pobject);\n}\n\nstatic int\nnvkm_ucgrp_sclass(struct nvkm_object *object, int index, struct nvkm_oclass *oclass)\n{\n\tstruct nvkm_cgrp *cgrp = nvkm_ucgrp(object)->cgrp;\n\tstruct nvkm_fifo *fifo = cgrp->runl->fifo;\n\tconst struct nvkm_fifo_func_chan *chan = &fifo->func->chan;\n\tint c = 0;\n\n\t \n\tif (chan->user.oclass) {\n\t\tif (c++ == index) {\n\t\t\toclass->base = chan->user;\n\t\t\toclass->ctor = nvkm_ucgrp_chan_new;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void *\nnvkm_ucgrp_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_ucgrp *ucgrp = nvkm_ucgrp(object);\n\n\tnvkm_cgrp_unref(&ucgrp->cgrp);\n\treturn ucgrp;\n}\n\nstatic const struct nvkm_object_func\nnvkm_ucgrp = {\n\t.dtor = nvkm_ucgrp_dtor,\n\t.sclass = nvkm_ucgrp_sclass,\n};\n\nint\nnvkm_ucgrp_new(struct nvkm_fifo *fifo, const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t       struct nvkm_object **pobject)\n{\n\tunion nvif_cgrp_args *args = argv;\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_vmm *vmm;\n\tstruct nvkm_ucgrp *ucgrp;\n\tint ret;\n\n\tif (argc < sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\targc -= sizeof(args->v0);\n\n\tif (args->v0.namelen != argc)\n\t\treturn -EINVAL;\n\n\t \n\trunl = nvkm_runl_get(fifo, args->v0.runlist, 0);\n\tif (!runl)\n\t\treturn -EINVAL;\n\n\tvmm = nvkm_uvmm_search(oclass->client, args->v0.vmm);\n\tif (IS_ERR(vmm))\n\t\treturn PTR_ERR(vmm);\n\n\t \n\tif (!(ucgrp = kzalloc(sizeof(*ucgrp), GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tnvkm_object_ctor(&nvkm_ucgrp, oclass, &ucgrp->object);\n\t*pobject = &ucgrp->object;\n\n\tret = nvkm_cgrp_new(runl, args->v0.name, vmm, true, &ucgrp->cgrp);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\targs->v0.cgid = ucgrp->cgrp->id;\n\ndone:\n\tnvkm_vmm_unref(&vmm);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}