{
  "module_name": "gpc.fuc",
  "hash_id": "2c4fdb7f93f3c2e942e7c12d70ec36dac5426369aa8e59c32f08c45cff3fafd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/fuc/gpc.fuc",
  "human_readable_source": "/* fuc microcode for gf100 PGRAPH/GPC\n *\n * Copyright 2011 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n/* TODO\n * - bracket certain functions with scratch writes, useful for debugging\n * - watchdog timer around ctx operations\n */\n\n#ifdef INCLUDE_DATA\ngpc_mmio_list_head:\t.b32 #mmio_list_base\ngpc_mmio_list_tail:\ntpc_mmio_list_head:\t.b32 #mmio_list_base\ntpc_mmio_list_tail:\nunk_mmio_list_head:\t.b32 #mmio_list_base\nunk_mmio_list_tail:\t.b32 #mmio_list_base\n\ngpc_id:\t\t\t.b32 0\n\ntpc_count:\t\t.b32 0\ntpc_mask:\t\t.b32 0\n\n#if NV_PGRAPH_GPCX_UNK__SIZE > 0\nunk_count:\t\t.b32 0\nunk_mask:\t\t.b32 0\n#endif\n\ncmd_queue:\t\tqueue_init\n\nmmio_list_base:\n#endif\n\n#ifdef INCLUDE_CODE\n#define gpc_addr(reg,addr)                                                    /*\n*/\timm32(reg,addr)                                                       /*\n*/\tor reg NV_PGRAPH_GPCX_GPCCS_MMIO_CTRL_BASE_ENABLE\n#define gpc_wr32(addr,reg)                                                    /*\n*/\tgpc_addr($r14,addr)                                                   /*\n*/\tmov b32 $r15 reg                                                      /*\n*/\tcall(nv_wr32)\n\n// reports an exception to the host\n//\n// In: $r15 error code (see os.h)\n//\nerror:\n\tpush $r14\n\tnv_wr32(NV_PGRAPH_FECS_CC_SCRATCH_VAL(5), $r15)\n\tmov $r15 1\n\tnv_wr32(NV_PGRAPH_FECS_INTR_UP_SET, $r15)\n\tpop $r14\n\tret\n\n#if CHIPSET >= GM107\ntpc_strand_wait:\n\tpush $r9\n\ttrace_set(T_STRTPC)\n\ttpc_strand_busy:\n\t\tnv_iord($r9, NV_PGRAPH_GPCX_GPCCS_TPC_STATUS, 0)\n\t\tbra b32 $r9 0x0 ne #tpc_strand_busy\n\ttrace_clr(T_STRTPC)\n\tpop $r9\n\tret\n\n#define tpc_strand_wait() call(tpc_strand_wait)\n#define tpc_strand_enable()                                                   /*\n*/\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_CMD_ENABLE                        /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_CMD, $r15)                        /*\n*/\ttpc_strand_wait()\n#define tpc_strand_disable()                                                  /*\n*/\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_CMD_DISABLE                       /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_CMD, $r15)                        /*\n*/\ttpc_strand_wait()\n#define tpc_strand_seek(p)                                                    /*\n*/\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_INDEX_ALL                         /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_INDEX, $r15)                      /*\n*/\tmov $r15 p                                                            /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_SELECT, $r15)                     /*\n*/\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_CMD_SEEK                          /*\n*/\ttpc_strand_wait()\n#define tpc_strand_info(m)                                                    /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_CMD, $r15)                        /*\n*/\tmov $r15 m                                                            /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_DATA, $r15)                       /*\n*/\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_CMD_GET_INFO                      /*\n*/\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_CMD, $r15)                        /*\n*/\ttpc_strand_wait()\n#endif\n\n\n// GPC fuc initialisation, executed by triggering ucode start, will\n// fall through to main loop after completion.\n//\n// Input:\n//   CC_SCRATCH[1]: context base\n//\n// Output:\n//   CC_SCRATCH[0]:\n//\t     31:31: set to signal completion\n//   CC_SCRATCH[1]:\n//\t      31:0: GPC context size\n//\ninit:\n\tclear b32 $r0\n\n\t// setup stack\n\tnv_iord($r1, NV_PGRAPH_GPCX_GPCCS_CAPS, 0)\n\textr $r1 $r1 9:17\n\tshl b32 $r1 8\n\tmov $sp $r1\n\n\t// enable fifo access\n\tmov $r2 NV_PGRAPH_GPCX_GPCCS_ACCESS_FIFO\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_ACCESS, 0, $r2)\n\n\t// setup i0 handler, and route all interrupts to it\n\tmov $r1 #ih\n\tmov $iv0 $r1\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_INTR_ROUTE, 0, $r0)\n\n\t// enable fifo interrupt\n\tmov $r2 NV_PGRAPH_GPCX_GPCCS_INTR_EN_SET_FIFO\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_INTR_EN_SET, 0, $r2)\n\n\t// enable interrupts\n\tbset $flags ie0\n\n\t// how many TPCs do we have?\n\tnv_iord($r2, NV_PGRAPH_GPCX_GPCCS_UNITS, 0)\n\tmov $r3 1\n\tand $r2 0x1f\n\tshl b32 $r3 $r2\n\tsub b32 $r3 1\n\tst b32 D[$r0 + #tpc_count] $r2\n\tst b32 D[$r0 + #tpc_mask] $r3\n\n\t// determine which GPC we are, setup (optional) mmio access offset\n\tnv_iord($r2, NV_PGRAPH_GPCX_GPCCS_MYINDEX, 0)\n\tst b32 D[$r0 + #gpc_id] $r2\n\tshl b32 $r2 15\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_MMIO_BASE, 0, $r2)\n\n#if NV_PGRAPH_GPCX_UNK__SIZE > 0\n\t// figure out which, and how many, UNKs are actually present\n\tgpc_addr($r14, 0x500c30)\n\tclear b32 $r2\n\tclear b32 $r3\n\tclear b32 $r4\n\tinit_unk_loop:\n\t\tcall(nv_rd32)\n\t\tcmp b32 $r15 0\n\t\tbra z #init_unk_next\n\t\t\tmov $r15 1\n\t\t\tshl b32 $r15 $r2\n\t\t\tor $r4 $r15\n\t\t\tadd b32 $r3 1\n\t\tinit_unk_next:\n\t\tadd b32 $r2 1\n\t\tadd b32 $r14 4\n\t\tcmp b32 $r2 NV_PGRAPH_GPCX_UNK__SIZE\n\t\tbra ne #init_unk_loop\n\tinit_unk_done:\n\tst b32 D[$r0 + #unk_count] $r3\n\tst b32 D[$r0 + #unk_mask] $r4\n#endif\n\n\t// initialise context base, and size tracking\n\tnv_iord($r2, NV_PGRAPH_GPCX_GPCCS_CC_SCRATCH_VAL(1), 0)\n\tclear b32 $r3\t\t// track GPC context size here\n\n\t// set mmctx base addresses now so we don't have to do it later,\n\t// they don't currently ever change\n\tshr b32 $r5 $r2 8\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_MMCTX_SAVE_SWBASE, 0, $r5)\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_MMCTX_LOAD_SWBASE, 0, $r5)\n\n\t// calculate GPC mmio context size\n\tld b32 $r14 D[$r0 + #gpc_mmio_list_head]\n\tld b32 $r15 D[$r0 + #gpc_mmio_list_tail]\n\tcall(mmctx_size)\n\tadd b32 $r2 $r15\n\tadd b32 $r3 $r15\n\n\t// calculate per-TPC mmio context size\n\tld b32 $r14 D[$r0 + #tpc_mmio_list_head]\n\tld b32 $r15 D[$r0 + #tpc_mmio_list_tail]\n\tcall(mmctx_size)\n\tld b32 $r14 D[$r0 + #tpc_count]\n\tmulu $r14 $r15\n\tadd b32 $r2 $r14\n\tadd b32 $r3 $r14\n\n#if NV_PGRAPH_GPCX_UNK__SIZE > 0\n\t// calculate per-UNK mmio context size\n\tld b32 $r14 D[$r0 + #unk_mmio_list_head]\n\tld b32 $r15 D[$r0 + #unk_mmio_list_tail]\n\tcall(mmctx_size)\n\tld b32 $r14 D[$r0 + #unk_count]\n\tmulu $r14 $r15\n\tadd b32 $r2 $r14\n\tadd b32 $r3 $r14\n#endif\n\n\t// round up base/size to 256 byte boundary (for strand SWBASE)\n\tshr b32 $r3 2\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_MMCTX_LOAD_COUNT, 0, $r3) // wtf for?!\n\tshr b32 $r2 8\n\tshr b32 $r3 6\n\tadd b32 $r2 1\n\tadd b32 $r3 1\n\tshl b32 $r2 8\n\tshl b32 $r3 8\n\n\t// calculate size of strand context data\n\tmov b32 $r15 $r2\n\tcall(strand_ctx_init)\n\tadd b32 $r2 $r15\n\tadd b32 $r3 $r15\n\n#if CHIPSET >= GM107\n\t// calculate size of tpc strand context data\n\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_INDEX_ALL\n\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_INDEX, $r15)\n\ttpc_strand_enable();\n\ttpc_strand_seek(0);\n\ttpc_strand_info(-1);\n\n\tld b32 $r4 D[$r0 + #tpc_count]\n\tgpc_addr($r5, NV_PGRAPH_GPC0_TPC0)\n\ttpc_strand_init_tpc_loop:\n\t\tadd b32 $r14 $r5 NV_TPC_STRAND_CNT\n\t\tcall(nv_rd32)\n\t\tmov b32 $r6 $r15\n\t\tclear b32 $r7\n\t\ttpc_strand_init_idx_loop:\n\t\t\tadd b32 $r14 $r5 NV_TPC_STRAND_INDEX\n\t\t\tmov b32 $r15 $r7\n\t\t\tcall(nv_wr32)\n\t\t\tadd b32 $r14 $r5 NV_TPC_STRAND_SAVE_SWBASE\n\t\t\tshr b32 $r15 $r2 8\n\t\t\tcall(nv_wr32)\n\t\t\tadd b32 $r14 $r5 NV_TPC_STRAND_LOAD_SWBASE\n\t\t\tshr b32 $r15 $r2 8\n\t\t\tcall(nv_wr32)\n\t\t\tadd b32 $r14 $r5 NV_TPC_STRAND_WORDS\n\t\t\tcall(nv_rd32)\n\t\t\tshr b32 $r15 6\n\t\t\tadd b32 $r15 1\n\t\t\tshl b32 $r15 8\n\t\t\tadd b32 $r2 $r15\n\t\t\tadd b32 $r3 $r15\n\t\t\tadd b32 $r7 1\n\t\t\tsub b32 $r6 1\n\t\t\tbra nz #tpc_strand_init_idx_loop\n\t\tadd b32 $r5 NV_PGRAPH_GPC0_TPC0__SIZE\n\t\tsub b32 $r4 1\n\t\tbra nz #tpc_strand_init_tpc_loop\n\n\tmov $r15 NV_PGRAPH_GPC0_TPCX_STRAND_INDEX_ALL\n\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_INDEX, $r15)\n\ttpc_strand_disable();\n#endif\n\n\t// save context size, and tell HUB we're done\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_CC_SCRATCH_VAL(1), 0, $r3)\n\tclear b32 $r2\n\tbset $r2 31\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_CC_SCRATCH_SET(0), 0, $r2)\n\n// Main program loop, very simple, sleeps until woken up by the interrupt\n// handler, pulls a command from the queue and executes its handler\n//\nwait:\n\tsleep $p0\n\tbset $flags $p0\nmain:\n\tmov $r13 #cmd_queue\n\tcall(queue_get)\n\tbra $p1 #wait\n\n\t// 0x0000-0x0003 are all context transfers\n\tcmpu b32 $r14 0x04\n\tbra nc #main_not_ctx_xfer\n\t\t// fetch $flags and mask off $p1/$p2\n\t\tmov $r1 $flags\n\t\tmov $r2 0x0006\n\t\tnot b32 $r2\n\t\tand $r1 $r2\n\t\t// set $p1/$p2 according to transfer type\n\t\tshl b32 $r14 1\n\t\tor $r1 $r14\n\t\tmov $flags $r1\n\t\t// transfer context data\n\t\tcall(ctx_xfer)\n\t\tbra #main\n\n\tmain_not_ctx_xfer:\n\tshl b32 $r15 $r14 16\n\tor $r15 E_BAD_COMMAND\n\tcall(error)\n\tbra #main\n\n// interrupt handler\nih:\n\tpush $r0\n\tpush $r8\n\tmov $r8 $flags\n\tpush $r8\n\tpush $r9\n\tpush $r10\n\tpush $r11\n\tpush $r13\n\tpush $r14\n\tpush $r15\n\tclear b32 $r0\n\n\t// incoming fifo command?\n\tnv_iord($r10, NV_PGRAPH_GPCX_GPCCS_INTR, 0)\n\tand $r11 $r10 NV_PGRAPH_GPCX_GPCCS_INTR_FIFO\n\tbra e #ih_no_fifo\n\t\t// queue incoming fifo command for later processing\n\t\tmov $r13 #cmd_queue\n\t\tnv_iord($r14, NV_PGRAPH_GPCX_GPCCS_FIFO_CMD, 0)\n\t\tnv_iord($r15, NV_PGRAPH_GPCX_GPCCS_FIFO_DATA, 0)\n\t\tcall(queue_put)\n\t\tmov $r14 1\n\t\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_FIFO_ACK, 0, $r14)\n\n\t// ack, and wake up main()\n\tih_no_fifo:\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_INTR_ACK, 0, $r10)\n\n\tpop $r15\n\tpop $r14\n\tpop $r13\n\tpop $r11\n\tpop $r10\n\tpop $r9\n\tpop $r8\n\tmov $flags $r8\n\tpop $r8\n\tpop $r0\n\tbclr $flags $p0\n\tiret\n\n// Set this GPC's bit in HUB_BAR, used to signal completion of various\n// activities to the HUB fuc\n//\nhub_barrier_done:\n\tmov $r15 1\n\tld b32 $r14 D[$r0 + #gpc_id]\n\tshl b32 $r15 $r14\n\tnv_wr32(0x409418, $r15)\t// 0x409418 - HUB_BAR_SET\n\tret\n\n// Disables various things, waits a bit, and re-enables them..\n//\n// Not sure how exactly this helps, perhaps \"ENABLE\" is not such a\n// good description for the bits we turn off?  Anyways, without this,\n// funny things happen.\n//\nctx_redswitch:\n\tmov $r15 NV_PGRAPH_GPCX_GPCCS_RED_SWITCH_POWER\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_RED_SWITCH, 0, $r15)\n\tmov $r14 8\n\tctx_redswitch_delay:\n\t\tsub b32 $r14 1\n\t\tbra ne #ctx_redswitch_delay\n\tor $r15 NV_PGRAPH_GPCX_GPCCS_RED_SWITCH_UNK11\n\tor $r15 NV_PGRAPH_GPCX_GPCCS_RED_SWITCH_ENABLE\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_RED_SWITCH, 0, $r15)\n\tret\n\n// Transfer GPC context data between GPU and storage area\n//\n// In: $r15 context base address\n//     $p1 clear on save, set on load\n//     $p2 set if opposite direction done/will be done, so:\n//\t\ton save it means: \"a load will follow this save\"\n//\t\ton load it means: \"a save preceeded this load\"\n//\nctx_xfer:\n\t// set context base address\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_MEM_BASE, 0, $r15)\n#if CHIPSET >= GM107\n\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_MEM_BASE, $r15)\n#endif\n\tbra not $p1 #ctx_xfer_not_load\n\t\tcall(ctx_redswitch)\n\tctx_xfer_not_load:\n\n\t// strands\n\tcall(strand_pre)\n\tclear b32 $r2\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_STRAND_SELECT, 0x3f, $r2)\n\txbit $r2 $flags $p1\t// SAVE/LOAD\n\tadd b32 $r2 NV_PGRAPH_GPCX_GPCCS_STRAND_CMD_SAVE\n\tnv_iowr(NV_PGRAPH_GPCX_GPCCS_STRAND_CMD, 0x3f, $r2)\n\n#if CHIPSET >= GM107\n\ttpc_strand_enable();\n\ttpc_strand_seek(0);\n\txbit $r15 $flags $p1\t// SAVE/LOAD\n\tadd b32 $r15 NV_PGRAPH_GPC0_TPCX_STRAND_CMD_SAVE\n\tgpc_wr32(NV_PGRAPH_GPC0_TPCX_STRAND_CMD, $r15)\n#endif\n\n\t// mmio context\n\txbit $r10 $flags $p1\t// direction\n\tor $r10 2\t\t// first\n\timm32($r11,0x500000)\n\tld b32 $r12 D[$r0 + #gpc_id]\n\tshl b32 $r12 15\n\tadd b32 $r11 $r12\t// base = NV_PGRAPH_GPCn\n\tld b32 $r12 D[$r0 + #gpc_mmio_list_head]\n\tld b32 $r13 D[$r0 + #gpc_mmio_list_tail]\n\tmov $r14 0\t\t// not multi\n\tcall(mmctx_xfer)\n\n\t// per-TPC mmio context\n\txbit $r10 $flags $p1\t// direction\n#if !NV_PGRAPH_GPCX_UNK__SIZE\n\tor $r10 4\t\t// last\n#endif\n\timm32($r11, 0x504000)\n\tld b32 $r12 D[$r0 + #gpc_id]\n\tshl b32 $r12 15\n\tadd b32 $r11 $r12\t// base = NV_PGRAPH_GPCn_TPC0\n\tld b32 $r12 D[$r0 + #tpc_mmio_list_head]\n\tld b32 $r13 D[$r0 + #tpc_mmio_list_tail]\n\tld b32 $r15 D[$r0 + #tpc_mask]\n\tmov $r14 0x800\t\t// stride = 0x800\n\tcall(mmctx_xfer)\n\n#if NV_PGRAPH_GPCX_UNK__SIZE > 0\n\t// per-UNK mmio context\n\txbit $r10 $flags $p1\t// direction\n\tor $r10 4\t\t// last\n\timm32($r11, 0x503000)\n\tld b32 $r12 D[$r0 + #gpc_id]\n\tshl b32 $r12 15\n\tadd b32 $r11 $r12\t// base = NV_PGRAPH_GPCn_UNK0\n\tld b32 $r12 D[$r0 + #unk_mmio_list_head]\n\tld b32 $r13 D[$r0 + #unk_mmio_list_tail]\n\tld b32 $r15 D[$r0 + #unk_mask]\n\tmov $r14 0x200\t\t// stride = 0x200\n\tcall(mmctx_xfer)\n#endif\n\n\t// wait for strands to finish\n\tcall(strand_wait)\n#if CHIPSET >= GM107\n\ttpc_strand_wait()\n#endif\n\n\t// if load, or a save without a load following, do some\n\t// unknown stuff that's done after finishing a block of\n\t// strand commands\n\tbra $p1 #ctx_xfer_post\n\tbra not $p2 #ctx_xfer_done\n\tctx_xfer_post:\n\t\tcall(strand_post)\n#if CHIPSET >= GM107\n\t\ttpc_strand_disable()\n#endif\n\n\t// mark completion in HUB's barrier\n\tctx_xfer_done:\n\tcall(hub_barrier_done)\n\tret\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}