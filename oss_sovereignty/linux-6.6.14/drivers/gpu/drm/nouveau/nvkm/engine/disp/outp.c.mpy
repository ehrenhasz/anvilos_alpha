{
  "module_name": "outp.c",
  "hash_id": "efdcf931dec87ee60a3d25d1b974012bc2af410153473ab7e409b0b7a37e0707",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/outp.c",
  "human_readable_source": " \n#include \"outp.h\"\n#include \"dp.h\"\n#include \"ior.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/i2c.h>\n\nvoid\nnvkm_outp_route(struct nvkm_disp *disp)\n{\n\tstruct nvkm_outp *outp;\n\tstruct nvkm_ior *ior;\n\n\tlist_for_each_entry(ior, &disp->iors, head) {\n\t\tif ((outp = ior->arm.outp) && ior->arm.outp != ior->asy.outp) {\n\t\t\tOUTP_DBG(outp, \"release %s\", ior->name);\n\t\t\tif (ior->func->route.set)\n\t\t\t\tior->func->route.set(outp, NULL);\n\t\t\tior->arm.outp = NULL;\n\t\t}\n\t}\n\n\tlist_for_each_entry(ior, &disp->iors, head) {\n\t\tif ((outp = ior->asy.outp)) {\n\t\t\tOUTP_DBG(outp, \"acquire %s\", ior->name);\n\t\t\tif (ior->asy.outp != ior->arm.outp) {\n\t\t\t\tif (ior->func->route.set)\n\t\t\t\t\tior->func->route.set(outp, ior);\n\t\t\t\tior->arm.outp = ior->asy.outp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic enum nvkm_ior_proto\nnvkm_outp_xlat(struct nvkm_outp *outp, enum nvkm_ior_type *type)\n{\n\tswitch (outp->info.location) {\n\tcase 0:\n\t\tswitch (outp->info.type) {\n\t\tcase DCB_OUTPUT_ANALOG: *type = DAC; return  CRT;\n\t\tcase DCB_OUTPUT_TV    : *type = DAC; return   TV;\n\t\tcase DCB_OUTPUT_TMDS  : *type = SOR; return TMDS;\n\t\tcase DCB_OUTPUT_LVDS  : *type = SOR; return LVDS;\n\t\tcase DCB_OUTPUT_DP    : *type = SOR; return   DP;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tswitch (outp->info.type) {\n\t\tcase DCB_OUTPUT_TMDS: *type = PIOR; return TMDS;\n\t\tcase DCB_OUTPUT_DP  : *type = PIOR; return TMDS;  \n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tWARN_ON(1);\n\treturn UNKNOWN;\n}\n\nvoid\nnvkm_outp_release(struct nvkm_outp *outp, u8 user)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tOUTP_TRACE(outp, \"release %02x &= %02x %p\", outp->acquired, ~user, ior);\n\tif (ior) {\n\t\toutp->acquired &= ~user;\n\t\tif (!outp->acquired) {\n\t\t\tif (outp->func->release && outp->ior)\n\t\t\t\toutp->func->release(outp);\n\t\t\toutp->ior->asy.outp = NULL;\n\t\t\toutp->ior = NULL;\n\t\t}\n\t}\n}\n\nstatic inline int\nnvkm_outp_acquire_ior(struct nvkm_outp *outp, u8 user, struct nvkm_ior *ior)\n{\n\toutp->ior = ior;\n\toutp->ior->asy.outp = outp;\n\toutp->ior->asy.link = outp->info.sorconf.link;\n\toutp->acquired |= user;\n\treturn 0;\n}\n\nstatic inline int\nnvkm_outp_acquire_hda(struct nvkm_outp *outp, enum nvkm_ior_type type,\n\t\t      u8 user, bool hda)\n{\n\tstruct nvkm_ior *ior;\n\n\t \n\tlist_for_each_entry(ior, &outp->disp->iors, head) {\n\t\tif (!ior->identity && ior->hda == hda &&\n\t\t    !ior->asy.outp && ior->type == type && !ior->arm.outp &&\n\t\t    (ior->func->route.set || ior->id == __ffs(outp->info.or)))\n\t\t\treturn nvkm_outp_acquire_ior(outp, user, ior);\n\t}\n\n\t \n\tlist_for_each_entry(ior, &outp->disp->iors, head) {\n\t\tif (!ior->identity && ior->hda == hda &&\n\t\t    !ior->asy.outp && ior->type == type &&\n\t\t    (ior->func->route.set || ior->id == __ffs(outp->info.or)))\n\t\t\treturn nvkm_outp_acquire_ior(outp, user, ior);\n\t}\n\n\treturn -ENOSPC;\n}\n\nint\nnvkm_outp_acquire(struct nvkm_outp *outp, u8 user, bool hda)\n{\n\tstruct nvkm_ior *ior = outp->ior;\n\tenum nvkm_ior_proto proto;\n\tenum nvkm_ior_type type;\n\n\tOUTP_TRACE(outp, \"acquire %02x |= %02x %p\", outp->acquired, user, ior);\n\tif (ior) {\n\t\toutp->acquired |= user;\n\t\treturn 0;\n\t}\n\n\t \n\tproto = nvkm_outp_xlat(outp, &type);\n\tif (proto == UNKNOWN)\n\t\treturn -ENOSYS;\n\n\t \n\tif (outp->identity) {\n\t\tior = nvkm_ior_find(outp->disp, SOR, ffs(outp->info.or) - 1);\n\t\tif (WARN_ON(!ior))\n\t\t\treturn -ENOSPC;\n\t\treturn nvkm_outp_acquire_ior(outp, user, ior);\n\t}\n\n\t \n\tlist_for_each_entry(ior, &outp->disp->iors, head) {\n\t\tif (!ior->identity && !ior->asy.outp && ior->arm.outp == outp) {\n\t\t\t \n\t\t\tWARN_ON(hda && !ior->hda);\n\t\t\treturn nvkm_outp_acquire_ior(outp, user, ior);\n\t\t}\n\t}\n\n\t \n\tif (!hda) {\n\t\tif (!nvkm_outp_acquire_hda(outp, type, user, false))\n\t\t\treturn 0;\n\n\t\t \n\t\treturn nvkm_outp_acquire_hda(outp, type, user, true);\n\t}\n\n\t \n\tif (!nvkm_outp_acquire_hda(outp, type, user, true))\n\t\treturn 0;\n\n\t \n\treturn nvkm_outp_acquire_hda(outp, type, user, false);\n}\n\nvoid\nnvkm_outp_fini(struct nvkm_outp *outp)\n{\n\tif (outp->func->fini)\n\t\toutp->func->fini(outp);\n}\n\nstatic void\nnvkm_outp_init_route(struct nvkm_outp *outp)\n{\n\tstruct nvkm_disp *disp = outp->disp;\n\tenum nvkm_ior_proto proto;\n\tenum nvkm_ior_type type;\n\tstruct nvkm_ior *ior;\n\tint id, link;\n\n\t \n\tproto = nvkm_outp_xlat(outp, &type);\n\tif (proto == UNKNOWN)\n\t\treturn;\n\n\tior = nvkm_ior_find(disp, type, -1);\n\tif (!ior) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\tif (ior->func->route.get) {\n\t\tid = ior->func->route.get(outp, &link);\n\t\tif (id < 0) {\n\t\t\tOUTP_DBG(outp, \"no route\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tid   = ffs(outp->info.or) - 1;\n\t\tlink = (ior->type == SOR) ? outp->info.sorconf.link : 0;\n\t}\n\n\tior = nvkm_ior_find(disp, type, id);\n\tif (!ior) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\tior->func->state(ior, &ior->arm);\n\tif (!ior->arm.head || ior->arm.proto != proto) {\n\t\tOUTP_DBG(outp, \"no heads (%x %d %d)\", ior->arm.head,\n\t\t\t ior->arm.proto, proto);\n\n\t\t \n\t\tif (ior->func->route.get && !ior->arm.head && outp->info.type == DCB_OUTPUT_DP)\n\t\t\tnvkm_dp_disable(outp, ior);\n\n\t\treturn;\n\t}\n\n\tOUTP_DBG(outp, \"on %s link %x\", ior->name, ior->arm.link);\n\tior->arm.outp = outp;\n}\n\nvoid\nnvkm_outp_init(struct nvkm_outp *outp)\n{\n\tnvkm_outp_init_route(outp);\n\tif (outp->func->init)\n\t\toutp->func->init(outp);\n}\n\nvoid\nnvkm_outp_del(struct nvkm_outp **poutp)\n{\n\tstruct nvkm_outp *outp = *poutp;\n\tif (outp && !WARN_ON(!outp->func)) {\n\t\tif (outp->func->dtor)\n\t\t\t*poutp = outp->func->dtor(outp);\n\t\tkfree(*poutp);\n\t\t*poutp = NULL;\n\t}\n}\n\nint\nnvkm_outp_new_(const struct nvkm_outp_func *func, struct nvkm_disp *disp,\n\t       int index, struct dcb_output *dcbE, struct nvkm_outp **poutp)\n{\n\tstruct nvkm_i2c *i2c = disp->engine.subdev.device->i2c;\n\tstruct nvkm_outp *outp;\n\tenum nvkm_ior_proto proto;\n\tenum nvkm_ior_type type;\n\n\tif (!(outp = *poutp = kzalloc(sizeof(*outp), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\toutp->func = func;\n\toutp->disp = disp;\n\toutp->index = index;\n\toutp->info = *dcbE;\n\toutp->i2c = nvkm_i2c_bus_find(i2c, dcbE->i2c_index);\n\n\tOUTP_DBG(outp, \"type %02x loc %d or %d link %d con %x \"\n\t\t       \"edid %x bus %d head %x\",\n\t\t outp->info.type, outp->info.location, outp->info.or,\n\t\t outp->info.type >= 2 ? outp->info.sorconf.link : 0,\n\t\t outp->info.connector, outp->info.i2c_index,\n\t\t outp->info.bus, outp->info.heads);\n\n\t \n\tproto = nvkm_outp_xlat(outp, &type);\n\tif (proto == UNKNOWN)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic const struct nvkm_outp_func\nnvkm_outp = {\n};\n\nint\nnvkm_outp_new(struct nvkm_disp *disp, int index, struct dcb_output *dcbE,\n\t      struct nvkm_outp **poutp)\n{\n\treturn nvkm_outp_new_(&nvkm_outp, disp, index, dcbE, poutp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}