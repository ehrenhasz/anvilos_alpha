{
  "module_name": "ga102.c",
  "hash_id": "167ee81d90148b319f391cdbf334f452c4160e94050587af3739dfdeb1b9f975",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/disp/ga102.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"chan.h\"\n#include \"head.h\"\n#include \"ior.h\"\n\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstatic int\nga102_sor_dp_links(struct nvkm_ior *sor, struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tconst u32 soff = nv50_ior_base(sor);\n\tconst u32 loff = nv50_sor_link(sor);\n\tu32 dpctrl = 0x00000000;\n\tu32 clksor = 0x00000000;\n\n\tswitch (sor->dp.bw) {\n\tcase 0x06: clksor |= 0x00000000; break;\n\tcase 0x0a: clksor |= 0x00040000; break;\n\tcase 0x14: clksor |= 0x00080000; break;\n\tcase 0x1e: clksor |= 0x000c0000; break;\n\tcase 0x08: clksor |= 0x00100000; break;\n\tcase 0x09: clksor |= 0x00140000; break;\n\tcase 0x0c: clksor |= 0x00180000; break;\n\tcase 0x10: clksor |= 0x001c0000; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tdpctrl |= ((1 << sor->dp.nr) - 1) << 16;\n\tif (sor->dp.mst)\n\t\tdpctrl |= 0x40000000;\n\tif (sor->dp.ef)\n\t\tdpctrl |= 0x00004000;\n\n\tnvkm_mask(device, 0x612300 + soff, 0x007c0000, clksor);\n\n\t \n\tnvkm_msec(device, 40, NVKM_DELAY);\n\tnvkm_mask(device, 0x612300 + soff, 0x00030000, 0x00010000);\n\tnvkm_mask(device, 0x61c10c + loff, 0x00000003, 0x00000001);\n\n\tnvkm_mask(device, 0x61c10c + loff, 0x401f4000, dpctrl);\n\treturn 0;\n}\n\nstatic const struct nvkm_ior_func_dp\nga102_sor_dp = {\n\t.lanes = { 0, 1, 2, 3 },\n\t.links = ga102_sor_dp_links,\n\t.power = g94_sor_dp_power,\n\t.pattern = gm107_sor_dp_pattern,\n\t.drive = gm200_sor_dp_drive,\n\t.vcpi = tu102_sor_dp_vcpi,\n\t.audio = gv100_sor_dp_audio,\n\t.audio_sym = gv100_sor_dp_audio_sym,\n\t.watermark = gv100_sor_dp_watermark,\n};\n\nstatic void\nga102_sor_clock(struct nvkm_ior *sor)\n{\n\tstruct nvkm_device *device = sor->disp->engine.subdev.device;\n\tu32 div2 = 0;\n\n\tif (sor->asy.proto == TMDS) {\n\t\tif (sor->tmds.high_speed)\n\t\t\tdiv2 = 1;\n\t}\n\n\tnvkm_wr32(device, 0x00ec08 + (sor->id * 0x10), 0x00000000);\n\tnvkm_wr32(device, 0x00ec04 + (sor->id * 0x10), div2);\n}\n\nstatic const struct nvkm_ior_func\nga102_sor = {\n\t.route = {\n\t\t.get = gm200_sor_route_get,\n\t\t.set = gm200_sor_route_set,\n\t},\n\t.state = gv100_sor_state,\n\t.power = nv50_sor_power,\n\t.clock = ga102_sor_clock,\n\t.hdmi = &gv100_sor_hdmi,\n\t.dp = &ga102_sor_dp,\n\t.hda = &gv100_sor_hda,\n};\n\nstatic int\nga102_sor_new(struct nvkm_disp *disp, int id)\n{\n\tstruct nvkm_device *device = disp->engine.subdev.device;\n\tu32 hda = nvkm_rd32(device, 0x08a15c);\n\n\treturn nvkm_ior_new_(&ga102_sor, disp, SOR, id, hda & BIT(id));\n}\n\nstatic const struct nvkm_disp_func\nga102_disp = {\n\t.oneinit = nv50_disp_oneinit,\n\t.init = tu102_disp_init,\n\t.fini = gv100_disp_fini,\n\t.intr = gv100_disp_intr,\n\t.super = gv100_disp_super,\n\t.uevent = &gv100_disp_chan_uevent,\n\t.wndw = { .cnt = gv100_disp_wndw_cnt },\n\t.head = { .cnt = gv100_head_cnt, .new = gv100_head_new },\n\t.sor = { .cnt = gv100_sor_cnt, .new = ga102_sor_new },\n\t.ramht_size = 0x2000,\n\t.root = {  0, 0,GA102_DISP },\n\t.user = {\n\t\t{{-1,-1,GV100_DISP_CAPS                  }, gv100_disp_caps_new },\n\t\t{{ 0, 0,GA102_DISP_CURSOR                }, nvkm_disp_chan_new, &gv100_disp_curs },\n\t\t{{ 0, 0,GA102_DISP_WINDOW_IMM_CHANNEL_DMA}, nvkm_disp_wndw_new, &gv100_disp_wimm },\n\t\t{{ 0, 0,GA102_DISP_CORE_CHANNEL_DMA      }, nvkm_disp_core_new, &gv100_disp_core },\n\t\t{{ 0, 0,GA102_DISP_WINDOW_CHANNEL_DMA    }, nvkm_disp_wndw_new, &gv100_disp_wndw },\n\t\t{}\n\t},\n};\n\nint\nga102_disp_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_disp **pdisp)\n{\n\treturn nvkm_disp_new_(&ga102_disp, device, type, inst, pdisp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}