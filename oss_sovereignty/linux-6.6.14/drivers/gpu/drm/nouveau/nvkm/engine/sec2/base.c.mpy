{
  "module_name": "base.c",
  "hash_id": "2865bed8389d03d90d36e34691e6e2237f4483689924ba85a7adc4db52a58d70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/sec2/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/firmware.h>\n#include <subdev/mc.h>\n#include <subdev/timer.h>\n\n#include <nvfw/sec2.h>\n\nstatic int\nnvkm_sec2_finimsg(void *priv, struct nvfw_falcon_msg *hdr)\n{\n\tstruct nvkm_sec2 *sec2 = priv;\n\n\tatomic_set(&sec2->running, 0);\n\treturn 0;\n}\n\nstatic int\nnvkm_sec2_fini(struct nvkm_engine *engine, bool suspend)\n{\n\tstruct nvkm_sec2 *sec2 = nvkm_sec2(engine);\n\tstruct nvkm_subdev *subdev = &sec2->engine.subdev;\n\tstruct nvkm_falcon *falcon = &sec2->falcon;\n\tstruct nvkm_falcon_cmdq *cmdq = sec2->cmdq;\n\tstruct nvfw_falcon_cmd cmd = {\n\t\t.unit_id = sec2->func->unit_unload,\n\t\t.size = sizeof(cmd),\n\t};\n\tint ret;\n\n\tif (!subdev->use.enabled)\n\t\treturn 0;\n\n\tif (atomic_read(&sec2->initmsg) == 1) {\n\t\tret = nvkm_falcon_cmdq_send(cmdq, &cmd, nvkm_sec2_finimsg, sec2,\n\t\t\t\t\t    msecs_to_jiffies(1000));\n\t\tWARN_ON(ret);\n\n\t\tnvkm_msec(subdev->device, 2000,\n\t\t\tif (nvkm_falcon_rd32(falcon, 0x100) & 0x00000010)\n\t\t\t\tbreak;\n\t\t);\n\t}\n\n\tnvkm_inth_block(&subdev->inth);\n\n\tnvkm_falcon_cmdq_fini(cmdq);\n\tfalcon->func->disable(falcon);\n\tnvkm_falcon_put(falcon, subdev);\n\treturn 0;\n}\n\nstatic int\nnvkm_sec2_init(struct nvkm_engine *engine)\n{\n\tstruct nvkm_sec2 *sec2 = nvkm_sec2(engine);\n\tstruct nvkm_subdev *subdev = &sec2->engine.subdev;\n\tstruct nvkm_falcon *falcon = &sec2->falcon;\n\tint ret;\n\n\tret = nvkm_falcon_get(falcon, subdev);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_falcon_wr32(falcon, 0x014, 0xffffffff);\n\tatomic_set(&sec2->initmsg, 0);\n\tatomic_set(&sec2->running, 1);\n\tnvkm_inth_allow(&subdev->inth);\n\n\tnvkm_falcon_start(falcon);\n\treturn 0;\n}\n\nstatic int\nnvkm_sec2_oneinit(struct nvkm_engine *engine)\n{\n\tstruct nvkm_sec2 *sec2 = nvkm_sec2(engine);\n\tstruct nvkm_subdev *subdev = &sec2->engine.subdev;\n\tstruct nvkm_intr *intr = &sec2->engine.subdev.device->mc->intr;\n\tenum nvkm_intr_type type = NVKM_INTR_SUBDEV;\n\n\tif (sec2->func->intr_vector) {\n\t\tintr = sec2->func->intr_vector(sec2, &type);\n\t\tif (IS_ERR(intr))\n\t\t\treturn PTR_ERR(intr);\n\t}\n\n\treturn nvkm_inth_add(intr, type, NVKM_INTR_PRIO_NORMAL, subdev, sec2->func->intr,\n\t\t\t     &subdev->inth);\n}\n\nstatic void *\nnvkm_sec2_dtor(struct nvkm_engine *engine)\n{\n\tstruct nvkm_sec2 *sec2 = nvkm_sec2(engine);\n\n\tnvkm_falcon_msgq_del(&sec2->msgq);\n\tnvkm_falcon_cmdq_del(&sec2->cmdq);\n\tnvkm_falcon_qmgr_del(&sec2->qmgr);\n\tnvkm_falcon_dtor(&sec2->falcon);\n\treturn sec2;\n}\n\nstatic const struct nvkm_engine_func\nnvkm_sec2 = {\n\t.dtor = nvkm_sec2_dtor,\n\t.oneinit = nvkm_sec2_oneinit,\n\t.init = nvkm_sec2_init,\n\t.fini = nvkm_sec2_fini,\n};\n\nint\nnvkm_sec2_new_(const struct nvkm_sec2_fwif *fwif, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, u32 addr, struct nvkm_sec2 **psec2)\n{\n\tstruct nvkm_sec2 *sec2;\n\tint ret;\n\n\tif (!(sec2 = *psec2 = kzalloc(sizeof(*sec2), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tret = nvkm_engine_ctor(&nvkm_sec2, device, type, inst, true, &sec2->engine);\n\tif (ret)\n\t\treturn ret;\n\n\tfwif = nvkm_firmware_load(&sec2->engine.subdev, fwif, \"Sec2\", sec2);\n\tif (IS_ERR(fwif))\n\t\treturn PTR_ERR(fwif);\n\n\tsec2->func = fwif->func;\n\n\tret = nvkm_falcon_ctor(sec2->func->flcn, &sec2->engine.subdev,\n\t\t\t       sec2->engine.subdev.name, addr, &sec2->falcon);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((ret = nvkm_falcon_qmgr_new(&sec2->falcon, &sec2->qmgr)) ||\n\t    (ret = nvkm_falcon_cmdq_new(sec2->qmgr, \"cmdq\", &sec2->cmdq)) ||\n\t    (ret = nvkm_falcon_msgq_new(sec2->qmgr, \"msgq\", &sec2->msgq)))\n\t\treturn ret;\n\n\treturn 0;\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}