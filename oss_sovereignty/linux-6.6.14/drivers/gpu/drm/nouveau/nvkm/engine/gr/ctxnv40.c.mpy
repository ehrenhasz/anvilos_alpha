{
  "module_name": "ctxnv40.c",
  "hash_id": "824df4905549e0a065464583f84901a56d8d1be2c75182be821bf54c1a93b294",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxnv40.c",
  "human_readable_source": " \n\n \n\n#define CP_FLAG_CLEAR                 0\n#define CP_FLAG_SET                   1\n#define CP_FLAG_SWAP_DIRECTION        ((0 * 32) + 0)\n#define CP_FLAG_SWAP_DIRECTION_LOAD   0\n#define CP_FLAG_SWAP_DIRECTION_SAVE   1\n#define CP_FLAG_USER_SAVE             ((0 * 32) + 5)\n#define CP_FLAG_USER_SAVE_NOT_PENDING 0\n#define CP_FLAG_USER_SAVE_PENDING     1\n#define CP_FLAG_USER_LOAD             ((0 * 32) + 6)\n#define CP_FLAG_USER_LOAD_NOT_PENDING 0\n#define CP_FLAG_USER_LOAD_PENDING     1\n#define CP_FLAG_STATUS                ((3 * 32) + 0)\n#define CP_FLAG_STATUS_IDLE           0\n#define CP_FLAG_STATUS_BUSY           1\n#define CP_FLAG_AUTO_SAVE             ((3 * 32) + 4)\n#define CP_FLAG_AUTO_SAVE_NOT_PENDING 0\n#define CP_FLAG_AUTO_SAVE_PENDING     1\n#define CP_FLAG_AUTO_LOAD             ((3 * 32) + 5)\n#define CP_FLAG_AUTO_LOAD_NOT_PENDING 0\n#define CP_FLAG_AUTO_LOAD_PENDING     1\n#define CP_FLAG_UNK54                 ((3 * 32) + 6)\n#define CP_FLAG_UNK54_CLEAR           0\n#define CP_FLAG_UNK54_SET             1\n#define CP_FLAG_ALWAYS                ((3 * 32) + 8)\n#define CP_FLAG_ALWAYS_FALSE          0\n#define CP_FLAG_ALWAYS_TRUE           1\n#define CP_FLAG_UNK57                 ((3 * 32) + 9)\n#define CP_FLAG_UNK57_CLEAR           0\n#define CP_FLAG_UNK57_SET             1\n\n#define CP_CTX                   0x00100000\n#define CP_CTX_COUNT             0x000fc000\n#define CP_CTX_COUNT_SHIFT               14\n#define CP_CTX_REG               0x00003fff\n#define CP_LOAD_SR               0x00200000\n#define CP_LOAD_SR_VALUE         0x000fffff\n#define CP_BRA                   0x00400000\n#define CP_BRA_IP                0x0000ff00\n#define CP_BRA_IP_SHIFT                   8\n#define CP_BRA_IF_CLEAR          0x00000080\n#define CP_BRA_FLAG              0x0000007f\n#define CP_WAIT                  0x00500000\n#define CP_WAIT_SET              0x00000080\n#define CP_WAIT_FLAG             0x0000007f\n#define CP_SET                   0x00700000\n#define CP_SET_1                 0x00000080\n#define CP_SET_FLAG              0x0000007f\n#define CP_NEXT_TO_SWAP          0x00600007\n#define CP_NEXT_TO_CURRENT       0x00600009\n#define CP_SET_CONTEXT_POINTER   0x0060000a\n#define CP_END                   0x0060000e\n#define CP_LOAD_MAGIC_UNK01      0x00800001  \n#define CP_LOAD_MAGIC_NV44TCL    0x00800029  \n#define CP_LOAD_MAGIC_NV40TCL    0x00800041  \n\n#include \"ctxnv40.h\"\n#include \"nv40.h\"\n\n \n\nstatic int\nnv40_gr_vs_count(struct nvkm_device *device)\n{\n\n\tswitch (device->chipset) {\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\treturn 8;\n\tcase 0x40:\n\t\treturn 6;\n\tcase 0x41:\n\tcase 0x42:\n\t\treturn 5;\n\tcase 0x43:\n\tcase 0x44:\n\tcase 0x46:\n\tcase 0x4a:\n\t\treturn 3;\n\tcase 0x4c:\n\tcase 0x4e:\n\tcase 0x67:\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n\nenum cp_label {\n\tcp_check_load = 1,\n\tcp_setup_auto_load,\n\tcp_setup_load,\n\tcp_setup_save,\n\tcp_swap_state,\n\tcp_swap_state3d_3_is_save,\n\tcp_prepare_exit,\n\tcp_exit,\n};\n\nstatic void\nnv40_gr_construct_general(struct nvkm_grctx *ctx)\n{\n\tstruct nvkm_device *device = ctx->device;\n\tint i;\n\n\tcp_ctx(ctx, 0x4000a4, 1);\n\tgr_def(ctx, 0x4000a4, 0x00000008);\n\tcp_ctx(ctx, 0x400144, 58);\n\tgr_def(ctx, 0x400144, 0x00000001);\n\tcp_ctx(ctx, 0x400314, 1);\n\tgr_def(ctx, 0x400314, 0x00000000);\n\tcp_ctx(ctx, 0x400400, 10);\n\tcp_ctx(ctx, 0x400480, 10);\n\tcp_ctx(ctx, 0x400500, 19);\n\tgr_def(ctx, 0x400514, 0x00040000);\n\tgr_def(ctx, 0x400524, 0x55555555);\n\tgr_def(ctx, 0x400528, 0x55555555);\n\tgr_def(ctx, 0x40052c, 0x55555555);\n\tgr_def(ctx, 0x400530, 0x55555555);\n\tcp_ctx(ctx, 0x400560, 6);\n\tgr_def(ctx, 0x400568, 0x0000ffff);\n\tgr_def(ctx, 0x40056c, 0x0000ffff);\n\tcp_ctx(ctx, 0x40057c, 5);\n\tcp_ctx(ctx, 0x400710, 3);\n\tgr_def(ctx, 0x400710, 0x20010001);\n\tgr_def(ctx, 0x400714, 0x0f73ef00);\n\tcp_ctx(ctx, 0x400724, 1);\n\tgr_def(ctx, 0x400724, 0x02008821);\n\tcp_ctx(ctx, 0x400770, 3);\n\tif (device->chipset == 0x40) {\n\t\tcp_ctx(ctx, 0x400814, 4);\n\t\tcp_ctx(ctx, 0x400828, 5);\n\t\tcp_ctx(ctx, 0x400840, 5);\n\t\tgr_def(ctx, 0x400850, 0x00000040);\n\t\tcp_ctx(ctx, 0x400858, 4);\n\t\tgr_def(ctx, 0x400858, 0x00000040);\n\t\tgr_def(ctx, 0x40085c, 0x00000040);\n\t\tgr_def(ctx, 0x400864, 0x80000000);\n\t\tcp_ctx(ctx, 0x40086c, 9);\n\t\tgr_def(ctx, 0x40086c, 0x80000000);\n\t\tgr_def(ctx, 0x400870, 0x80000000);\n\t\tgr_def(ctx, 0x400874, 0x80000000);\n\t\tgr_def(ctx, 0x400878, 0x80000000);\n\t\tgr_def(ctx, 0x400888, 0x00000040);\n\t\tgr_def(ctx, 0x40088c, 0x80000000);\n\t\tcp_ctx(ctx, 0x4009c0, 8);\n\t\tgr_def(ctx, 0x4009cc, 0x80000000);\n\t\tgr_def(ctx, 0x4009dc, 0x80000000);\n\t} else {\n\t\tcp_ctx(ctx, 0x400840, 20);\n\t\tif (nv44_gr_class(ctx->device)) {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tgr_def(ctx, 0x400860 + (i * 4), 0x00000001);\n\t\t}\n\t\tgr_def(ctx, 0x400880, 0x00000040);\n\t\tgr_def(ctx, 0x400884, 0x00000040);\n\t\tgr_def(ctx, 0x400888, 0x00000040);\n\t\tcp_ctx(ctx, 0x400894, 11);\n\t\tgr_def(ctx, 0x400894, 0x00000040);\n\t\tif (!nv44_gr_class(ctx->device)) {\n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tgr_def(ctx, 0x4008a0 + (i * 4), 0x80000000);\n\t\t}\n\t\tcp_ctx(ctx, 0x4008e0, 2);\n\t\tcp_ctx(ctx, 0x4008f8, 2);\n\t\tif (device->chipset == 0x4c ||\n\t\t    (device->chipset & 0xf0) == 0x60)\n\t\t\tcp_ctx(ctx, 0x4009f8, 1);\n\t}\n\tcp_ctx(ctx, 0x400a00, 73);\n\tgr_def(ctx, 0x400b0c, 0x0b0b0b0c);\n\tcp_ctx(ctx, 0x401000, 4);\n\tcp_ctx(ctx, 0x405004, 1);\n\tswitch (device->chipset) {\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tcp_ctx(ctx, 0x403448, 1);\n\t\tgr_def(ctx, 0x403448, 0x00001010);\n\t\tbreak;\n\tdefault:\n\t\tcp_ctx(ctx, 0x403440, 1);\n\t\tswitch (device->chipset) {\n\t\tcase 0x40:\n\t\t\tgr_def(ctx, 0x403440, 0x00000010);\n\t\t\tbreak;\n\t\tcase 0x44:\n\t\tcase 0x46:\n\t\tcase 0x4a:\n\t\t\tgr_def(ctx, 0x403440, 0x00003010);\n\t\t\tbreak;\n\t\tcase 0x41:\n\t\tcase 0x42:\n\t\tcase 0x43:\n\t\tcase 0x4c:\n\t\tcase 0x4e:\n\t\tcase 0x67:\n\t\tdefault:\n\t\t\tgr_def(ctx, 0x403440, 0x00001010);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void\nnv40_gr_construct_state3d(struct nvkm_grctx *ctx)\n{\n\tstruct nvkm_device *device = ctx->device;\n\tint i;\n\n\tif (device->chipset == 0x40) {\n\t\tcp_ctx(ctx, 0x401880, 51);\n\t\tgr_def(ctx, 0x401940, 0x00000100);\n\t} else\n\tif (device->chipset == 0x46 || device->chipset == 0x47 ||\n\t    device->chipset == 0x49 || device->chipset == 0x4b) {\n\t\tcp_ctx(ctx, 0x401880, 32);\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tgr_def(ctx, 0x401880 + (i * 4), 0x00000111);\n\t\tif (device->chipset == 0x46)\n\t\t\tcp_ctx(ctx, 0x401900, 16);\n\t\tcp_ctx(ctx, 0x401940, 3);\n\t}\n\tcp_ctx(ctx, 0x40194c, 18);\n\tgr_def(ctx, 0x401954, 0x00000111);\n\tgr_def(ctx, 0x401958, 0x00080060);\n\tgr_def(ctx, 0x401974, 0x00000080);\n\tgr_def(ctx, 0x401978, 0xffff0000);\n\tgr_def(ctx, 0x40197c, 0x00000001);\n\tgr_def(ctx, 0x401990, 0x46400000);\n\tif (device->chipset == 0x40) {\n\t\tcp_ctx(ctx, 0x4019a0, 2);\n\t\tcp_ctx(ctx, 0x4019ac, 5);\n\t} else {\n\t\tcp_ctx(ctx, 0x4019a0, 1);\n\t\tcp_ctx(ctx, 0x4019b4, 3);\n\t}\n\tgr_def(ctx, 0x4019bc, 0xffff0000);\n\tswitch (device->chipset) {\n\tcase 0x46:\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tcp_ctx(ctx, 0x4019c0, 18);\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tgr_def(ctx, 0x4019c0 + (i * 4), 0x88888888);\n\t\tbreak;\n\t}\n\tcp_ctx(ctx, 0x401a08, 8);\n\tgr_def(ctx, 0x401a10, 0x0fff0000);\n\tgr_def(ctx, 0x401a14, 0x0fff0000);\n\tgr_def(ctx, 0x401a1c, 0x00011100);\n\tcp_ctx(ctx, 0x401a2c, 4);\n\tcp_ctx(ctx, 0x401a44, 26);\n\tfor (i = 0; i < 16; i++)\n\t\tgr_def(ctx, 0x401a44 + (i * 4), 0x07ff0000);\n\tgr_def(ctx, 0x401a8c, 0x4b7fffff);\n\tif (device->chipset == 0x40) {\n\t\tcp_ctx(ctx, 0x401ab8, 3);\n\t} else {\n\t\tcp_ctx(ctx, 0x401ab8, 1);\n\t\tcp_ctx(ctx, 0x401ac0, 1);\n\t}\n\tcp_ctx(ctx, 0x401ad0, 8);\n\tgr_def(ctx, 0x401ad0, 0x30201000);\n\tgr_def(ctx, 0x401ad4, 0x70605040);\n\tgr_def(ctx, 0x401ad8, 0xb8a89888);\n\tgr_def(ctx, 0x401adc, 0xf8e8d8c8);\n\tcp_ctx(ctx, 0x401b10, device->chipset == 0x40 ? 2 : 1);\n\tgr_def(ctx, 0x401b10, 0x40100000);\n\tcp_ctx(ctx, 0x401b18, device->chipset == 0x40 ? 6 : 5);\n\tgr_def(ctx, 0x401b28, device->chipset == 0x40 ?\n\t\t\t      0x00000004 : 0x00000000);\n\tcp_ctx(ctx, 0x401b30, 25);\n\tgr_def(ctx, 0x401b34, 0x0000ffff);\n\tgr_def(ctx, 0x401b68, 0x435185d6);\n\tgr_def(ctx, 0x401b6c, 0x2155b699);\n\tgr_def(ctx, 0x401b70, 0xfedcba98);\n\tgr_def(ctx, 0x401b74, 0x00000098);\n\tgr_def(ctx, 0x401b84, 0xffffffff);\n\tgr_def(ctx, 0x401b88, 0x00ff7000);\n\tgr_def(ctx, 0x401b8c, 0x0000ffff);\n\tif (device->chipset != 0x44 && device->chipset != 0x4a &&\n\t    device->chipset != 0x4e)\n\t\tcp_ctx(ctx, 0x401b94, 1);\n\tcp_ctx(ctx, 0x401b98, 8);\n\tgr_def(ctx, 0x401b9c, 0x00ff0000);\n\tcp_ctx(ctx, 0x401bc0, 9);\n\tgr_def(ctx, 0x401be0, 0x00ffff00);\n\tcp_ctx(ctx, 0x401c00, 192);\n\tfor (i = 0; i < 16; i++) {  \n\t\tgr_def(ctx, 0x401c40 + (i * 4), 0x00018488);\n\t\tgr_def(ctx, 0x401c80 + (i * 4), 0x00028202);\n\t\tgr_def(ctx, 0x401d00 + (i * 4), 0x0000aae4);\n\t\tgr_def(ctx, 0x401d40 + (i * 4), 0x01012000);\n\t\tgr_def(ctx, 0x401d80 + (i * 4), 0x00080008);\n\t\tgr_def(ctx, 0x401e00 + (i * 4), 0x00100008);\n\t}\n\tfor (i = 0; i < 4; i++) {  \n\t\tgr_def(ctx, 0x401e90 + (i * 4), 0x0001bc80);\n\t\tgr_def(ctx, 0x401ea0 + (i * 4), 0x00000202);\n\t\tgr_def(ctx, 0x401ec0 + (i * 4), 0x00000008);\n\t\tgr_def(ctx, 0x401ee0 + (i * 4), 0x00080008);\n\t}\n\tcp_ctx(ctx, 0x400f5c, 3);\n\tgr_def(ctx, 0x400f5c, 0x00000002);\n\tcp_ctx(ctx, 0x400f84, 1);\n}\n\nstatic void\nnv40_gr_construct_state3d_2(struct nvkm_grctx *ctx)\n{\n\tstruct nvkm_device *device = ctx->device;\n\tint i;\n\n\tcp_ctx(ctx, 0x402000, 1);\n\tcp_ctx(ctx, 0x402404, device->chipset == 0x40 ? 1 : 2);\n\tswitch (device->chipset) {\n\tcase 0x40:\n\t\tgr_def(ctx, 0x402404, 0x00000001);\n\t\tbreak;\n\tcase 0x4c:\n\tcase 0x4e:\n\tcase 0x67:\n\t\tgr_def(ctx, 0x402404, 0x00000020);\n\t\tbreak;\n\tcase 0x46:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tgr_def(ctx, 0x402404, 0x00000421);\n\t\tbreak;\n\tdefault:\n\t\tgr_def(ctx, 0x402404, 0x00000021);\n\t}\n\tif (device->chipset != 0x40)\n\t\tgr_def(ctx, 0x402408, 0x030c30c3);\n\tswitch (device->chipset) {\n\tcase 0x44:\n\tcase 0x46:\n\tcase 0x4a:\n\tcase 0x4c:\n\tcase 0x4e:\n\tcase 0x67:\n\t\tcp_ctx(ctx, 0x402440, 1);\n\t\tgr_def(ctx, 0x402440, 0x00011001);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tcp_ctx(ctx, 0x402480, device->chipset == 0x40 ? 8 : 9);\n\tgr_def(ctx, 0x402488, 0x3e020200);\n\tgr_def(ctx, 0x40248c, 0x00ffffff);\n\tswitch (device->chipset) {\n\tcase 0x40:\n\t\tgr_def(ctx, 0x402490, 0x60103f00);\n\t\tbreak;\n\tcase 0x47:\n\t\tgr_def(ctx, 0x402490, 0x40103f00);\n\t\tbreak;\n\tcase 0x41:\n\tcase 0x42:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tgr_def(ctx, 0x402490, 0x20103f00);\n\t\tbreak;\n\tdefault:\n\t\tgr_def(ctx, 0x402490, 0x0c103f00);\n\t\tbreak;\n\t}\n\tgr_def(ctx, 0x40249c, device->chipset <= 0x43 ?\n\t\t\t      0x00020000 : 0x00040000);\n\tcp_ctx(ctx, 0x402500, 31);\n\tgr_def(ctx, 0x402530, 0x00008100);\n\tif (device->chipset == 0x40)\n\t\tcp_ctx(ctx, 0x40257c, 6);\n\tcp_ctx(ctx, 0x402594, 16);\n\tcp_ctx(ctx, 0x402800, 17);\n\tgr_def(ctx, 0x402800, 0x00000001);\n\tswitch (device->chipset) {\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tcp_ctx(ctx, 0x402864, 1);\n\t\tgr_def(ctx, 0x402864, 0x00001001);\n\t\tcp_ctx(ctx, 0x402870, 3);\n\t\tgr_def(ctx, 0x402878, 0x00000003);\n\t\tif (device->chipset != 0x47) {  \n\t\t\tcp_ctx(ctx, 0x402900, 1);\n\t\t\tcp_ctx(ctx, 0x402940, 1);\n\t\t\tcp_ctx(ctx, 0x402980, 1);\n\t\t\tcp_ctx(ctx, 0x4029c0, 1);\n\t\t\tcp_ctx(ctx, 0x402a00, 1);\n\t\t\tcp_ctx(ctx, 0x402a40, 1);\n\t\t\tcp_ctx(ctx, 0x402a80, 1);\n\t\t\tcp_ctx(ctx, 0x402ac0, 1);\n\t\t}\n\t\tbreak;\n\tcase 0x40:\n\t\tcp_ctx(ctx, 0x402844, 1);\n\t\tgr_def(ctx, 0x402844, 0x00000001);\n\t\tcp_ctx(ctx, 0x402850, 1);\n\t\tbreak;\n\tdefault:\n\t\tcp_ctx(ctx, 0x402844, 1);\n\t\tgr_def(ctx, 0x402844, 0x00001001);\n\t\tcp_ctx(ctx, 0x402850, 2);\n\t\tgr_def(ctx, 0x402854, 0x00000003);\n\t\tbreak;\n\t}\n\n\tcp_ctx(ctx, 0x402c00, 4);\n\tgr_def(ctx, 0x402c00, device->chipset == 0x40 ?\n\t\t\t      0x80800001 : 0x00888001);\n\tswitch (device->chipset) {\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tcp_ctx(ctx, 0x402c20, 40);\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tgr_def(ctx, 0x402c40 + (i * 4), 0xffffffff);\n\t\tcp_ctx(ctx, 0x4030b8, 13);\n\t\tgr_def(ctx, 0x4030dc, 0x00000005);\n\t\tgr_def(ctx, 0x4030e8, 0x0000ffff);\n\t\tbreak;\n\tdefault:\n\t\tcp_ctx(ctx, 0x402c10, 4);\n\t\tif (device->chipset == 0x40)\n\t\t\tcp_ctx(ctx, 0x402c20, 36);\n\t\telse\n\t\tif (device->chipset <= 0x42)\n\t\t\tcp_ctx(ctx, 0x402c20, 24);\n\t\telse\n\t\tif (device->chipset <= 0x4a)\n\t\t\tcp_ctx(ctx, 0x402c20, 16);\n\t\telse\n\t\t\tcp_ctx(ctx, 0x402c20, 8);\n\t\tcp_ctx(ctx, 0x402cb0, device->chipset == 0x40 ? 12 : 13);\n\t\tgr_def(ctx, 0x402cd4, 0x00000005);\n\t\tif (device->chipset != 0x40)\n\t\t\tgr_def(ctx, 0x402ce0, 0x0000ffff);\n\t\tbreak;\n\t}\n\n\tcp_ctx(ctx, 0x403400, device->chipset == 0x40 ? 4 : 3);\n\tcp_ctx(ctx, 0x403410, device->chipset == 0x40 ? 4 : 3);\n\tcp_ctx(ctx, 0x403420, nv40_gr_vs_count(ctx->device));\n\tfor (i = 0; i < nv40_gr_vs_count(ctx->device); i++)\n\t\tgr_def(ctx, 0x403420 + (i * 4), 0x00005555);\n\n\tif (device->chipset != 0x40) {\n\t\tcp_ctx(ctx, 0x403600, 1);\n\t\tgr_def(ctx, 0x403600, 0x00000001);\n\t}\n\tcp_ctx(ctx, 0x403800, 1);\n\n\tcp_ctx(ctx, 0x403c18, 1);\n\tgr_def(ctx, 0x403c18, 0x00000001);\n\tswitch (device->chipset) {\n\tcase 0x46:\n\tcase 0x47:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tcp_ctx(ctx, 0x405018, 1);\n\t\tgr_def(ctx, 0x405018, 0x08e00001);\n\t\tcp_ctx(ctx, 0x405c24, 1);\n\t\tgr_def(ctx, 0x405c24, 0x000e3000);\n\t\tbreak;\n\t}\n\tif (device->chipset != 0x4e)\n\t\tcp_ctx(ctx, 0x405800, 11);\n\tcp_ctx(ctx, 0x407000, 1);\n}\n\nstatic void\nnv40_gr_construct_state3d_3(struct nvkm_grctx *ctx)\n{\n\tint len = nv44_gr_class(ctx->device) ? 0x0084 : 0x0684;\n\n\tcp_out (ctx, 0x300000);\n\tcp_lsr (ctx, len - 4);\n\tcp_bra (ctx, SWAP_DIRECTION, SAVE, cp_swap_state3d_3_is_save);\n\tcp_lsr (ctx, len);\n\tcp_name(ctx, cp_swap_state3d_3_is_save);\n\tcp_out (ctx, 0x800001);\n\n\tctx->ctxvals_pos += len;\n}\n\nstatic void\nnv40_gr_construct_shader(struct nvkm_grctx *ctx)\n{\n\tstruct nvkm_device *device = ctx->device;\n\tstruct nvkm_gpuobj *obj = ctx->data;\n\tint vs, vs_nr, vs_len, vs_nr_b0, vs_nr_b1, b0_offset, b1_offset;\n\tint offset, i;\n\n\tvs_nr    = nv40_gr_vs_count(ctx->device);\n\tvs_nr_b0 = 363;\n\tvs_nr_b1 = device->chipset == 0x40 ? 128 : 64;\n\tif (device->chipset == 0x40) {\n\t\tb0_offset = 0x2200/4;  \n\t\tb1_offset = 0x55a0/4;  \n\t\tvs_len = 0x6aa0/4;\n\t} else\n\tif (device->chipset == 0x41 || device->chipset == 0x42) {\n\t\tb0_offset = 0x2200/4;  \n\t\tb1_offset = 0x4400/4;  \n\t\tvs_len = 0x4f00/4;\n\t} else {\n\t\tb0_offset = 0x1d40/4;  \n\t\tb1_offset = 0x3f40/4;  \n\t\tvs_len = nv44_gr_class(device) ? 0x4980/4 : 0x4a40/4;\n\t}\n\n\tcp_lsr(ctx, vs_len * vs_nr + 0x300/4);\n\tcp_out(ctx, nv44_gr_class(device) ? 0x800029 : 0x800041);\n\n\toffset = ctx->ctxvals_pos;\n\tctx->ctxvals_pos += (0x0300/4 + (vs_nr * vs_len));\n\n\tif (ctx->mode != NVKM_GRCTX_VALS)\n\t\treturn;\n\n\toffset += 0x0280/4;\n\tfor (i = 0; i < 16; i++, offset += 2)\n\t\tnvkm_wo32(obj, offset * 4, 0x3f800000);\n\n\tfor (vs = 0; vs < vs_nr; vs++, offset += vs_len) {\n\t\tfor (i = 0; i < vs_nr_b0 * 6; i += 6)\n\t\t\tnvkm_wo32(obj, (offset + b0_offset + i) * 4, 0x00000001);\n\t\tfor (i = 0; i < vs_nr_b1 * 4; i += 4)\n\t\t\tnvkm_wo32(obj, (offset + b1_offset + i) * 4, 0x3f800000);\n\t}\n}\n\nstatic void\nnv40_grctx_generate(struct nvkm_grctx *ctx)\n{\n\t \n\tcp_bra (ctx, AUTO_SAVE, PENDING, cp_setup_save);\n\tcp_bra (ctx, USER_SAVE, PENDING, cp_setup_save);\n\n\tcp_name(ctx, cp_check_load);\n\tcp_bra (ctx, AUTO_LOAD, PENDING, cp_setup_auto_load);\n\tcp_bra (ctx, USER_LOAD, PENDING, cp_setup_load);\n\tcp_bra (ctx, ALWAYS, TRUE, cp_exit);\n\n\t \n\tcp_name(ctx, cp_setup_auto_load);\n\tcp_wait(ctx, STATUS, IDLE);\n\tcp_out (ctx, CP_NEXT_TO_SWAP);\n\tcp_name(ctx, cp_setup_load);\n\tcp_wait(ctx, STATUS, IDLE);\n\tcp_set (ctx, SWAP_DIRECTION, LOAD);\n\tcp_out (ctx, 0x00910880);  \n\tcp_out (ctx, 0x00901ffe);  \n\tcp_out (ctx, 0x01940000);  \n\tcp_lsr (ctx, 0x20);\n\tcp_out (ctx, 0x0060000b);  \n\tcp_wait(ctx, UNK57, CLEAR);\n\tcp_out (ctx, 0x0060000c);  \n\tcp_bra (ctx, ALWAYS, TRUE, cp_swap_state);\n\n\t \n\tcp_name(ctx, cp_setup_save);\n\tcp_set (ctx, SWAP_DIRECTION, SAVE);\n\n\t \n\tcp_name(ctx, cp_swap_state);\n\tcp_pos (ctx, 0x00020/4);\n\tnv40_gr_construct_general(ctx);\n\tcp_wait(ctx, STATUS, IDLE);\n\n\t \n\tcp_bra (ctx, UNK54, CLEAR, cp_prepare_exit);\n\tnv40_gr_construct_state3d(ctx);\n\tcp_wait(ctx, STATUS, IDLE);\n\n\t \n\tnv40_gr_construct_state3d_2(ctx);\n\n\t \n\tnv40_gr_construct_state3d_3(ctx);\n\n\t \n\tcp_pos (ctx, ctx->ctxvals_pos);\n\tnv40_gr_construct_shader(ctx);\n\n\t \n\tcp_name(ctx, cp_prepare_exit);\n\tcp_bra (ctx, SWAP_DIRECTION, SAVE, cp_check_load);\n\tcp_bra (ctx, USER_SAVE, PENDING, cp_exit);\n\tcp_out (ctx, CP_NEXT_TO_CURRENT);\n\n\tcp_name(ctx, cp_exit);\n\tcp_set (ctx, USER_SAVE, NOT_PENDING);\n\tcp_set (ctx, USER_LOAD, NOT_PENDING);\n\tcp_out (ctx, CP_END);\n}\n\nvoid\nnv40_grctx_fill(struct nvkm_device *device, struct nvkm_gpuobj *mem)\n{\n\tnv40_grctx_generate(&(struct nvkm_grctx) {\n\t\t\t     .device = device,\n\t\t\t     .mode = NVKM_GRCTX_VALS,\n\t\t\t     .data = mem,\n\t\t\t   });\n}\n\nint\nnv40_grctx_init(struct nvkm_device *device, u32 *size)\n{\n\tu32 *ctxprog = kmalloc(256 * 4, GFP_KERNEL), i;\n\tstruct nvkm_grctx ctx = {\n\t\t.device = device,\n\t\t.mode = NVKM_GRCTX_PROG,\n\t\t.ucode = ctxprog,\n\t\t.ctxprog_max = 256,\n\t};\n\n\tif (!ctxprog)\n\t\treturn -ENOMEM;\n\n\tnv40_grctx_generate(&ctx);\n\n\tnvkm_wr32(device, 0x400324, 0);\n\tfor (i = 0; i < ctx.ctxprog_len; i++)\n\t\tnvkm_wr32(device, 0x400328, ctxprog[i]);\n\t*size = ctx.ctxvals_pos * 4;\n\n\tkfree(ctxprog);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}