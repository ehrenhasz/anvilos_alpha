{
  "module_name": "ctxgv100.c",
  "hash_id": "6d62f34ea757d150d4491722f60904e7a5a2e5efa67159eec185bca3461cacc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/ctxgv100.c",
  "human_readable_source": " \n#include \"ctxgf100.h\"\n\n \n\nstatic const struct gf100_gr_init\ngv100_grctx_init_sw_veid_bundle_init_0[] = {\n\t{ 0x00001000, 64, 0x00100000, 0x00000008 },\n\t{ 0x00000941, 64, 0x00100000, 0x00000000 },\n\t{ 0x0000097e, 64, 0x00100000, 0x00000000 },\n\t{ 0x0000097f, 64, 0x00100000, 0x00000100 },\n\t{ 0x0000035c, 64, 0x00100000, 0x00000000 },\n\t{ 0x0000035d, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000a08, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000a09, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000a0a, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000352, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000353, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000358, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000359, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000370, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000371, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000372, 64, 0x00100000, 0x000fffff },\n\t{ 0x00000366, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000367, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000368, 64, 0x00100000, 0x00000fff },\n\t{ 0x00000623, 64, 0x00100000, 0x00000000 },\n\t{ 0x00000624, 64, 0x00100000, 0x00000000 },\n\t{ 0x0001e100,  1, 0x00000001, 0x02000001 },\n\t{}\n};\n\nstatic const struct gf100_gr_pack\ngv100_grctx_pack_sw_veid_bundle_init[] = {\n\t{ gv100_grctx_init_sw_veid_bundle_init_0 },\n\t{}\n};\n\nvoid\ngv100_grctx_generate_attrib(struct gf100_gr_chan *chan)\n{\n\tstruct gf100_gr *gr = chan->gr;\n\tconst struct gf100_grctx_func *grctx = gr->func->grctx;\n\tconst u32  alpha = grctx->alpha_nr;\n\tconst u32 attrib = grctx->attrib_nr;\n\tconst u32   gfxp = grctx->gfxp_nr;\n\tconst int max_batches = 0xffff;\n\tu32 size = grctx->alpha_nr_max * gr->tpc_total;\n\tu32 ao = 0;\n\tu32 bo = ao + size;\n\tint gpc, ppc, n = 0;\n\n\tgf100_grctx_patch_wr32(chan, 0x405830, attrib);\n\tgf100_grctx_patch_wr32(chan, 0x40585c, alpha);\n\tgf100_grctx_patch_wr32(chan, 0x4064c4, ((alpha / 4) << 16) | max_batches);\n\n\tfor (gpc = 0; gpc < gr->gpc_nr; gpc++) {\n\t\tfor (ppc = 0; ppc < gr->func->ppc_nr; ppc++, n++) {\n\t\t\tconst u32 as =  alpha * gr->ppc_tpc_nr[gpc][ppc];\n\t\t\tconst u32 bs = attrib * gr->ppc_tpc_max;\n\t\t\tconst u32 gs =   gfxp * gr->ppc_tpc_max;\n\t\t\tconst u32 u = 0x418ea0 + (n * 0x04);\n\t\t\tconst u32 o = PPC_UNIT(gpc, ppc, 0);\n\n\t\t\tif (!(gr->ppc_mask[gpc] & (1 << ppc)))\n\t\t\t\tcontinue;\n\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xc0, gs);\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xf4, bo);\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xf0, bs);\n\t\t\tbo += gs;\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xe4, as);\n\t\t\tgf100_grctx_patch_wr32(chan, o + 0xf8, ao);\n\t\t\tao += grctx->alpha_nr_max * gr->ppc_tpc_nr[gpc][ppc];\n\t\t\tgf100_grctx_patch_wr32(chan, u, bs);\n\t\t}\n\t}\n\n\tgf100_grctx_patch_wr32(chan, 0x4181e4, 0x00000100);\n\tgf100_grctx_patch_wr32(chan, 0x41befc, 0x00000100);\n}\n\nvoid\ngv100_grctx_generate_attrib_cb(struct gf100_gr_chan *chan, u64 addr, u32 size)\n{\n\tgm107_grctx_generate_attrib_cb(chan, addr, size);\n\n\tgf100_grctx_patch_wr32(chan, 0x419e00, 0x00000000 | addr >> 12);\n\tgf100_grctx_patch_wr32(chan, 0x419e04, 0x80000000 | size >> 7);\n}\n\nvoid\ngv100_grctx_generate_rop_mapping(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst u32 mapregs = DIV_ROUND_UP(gr->func->gpc_nr * gr->func->tpc_nr, 6);\n\tu32 data;\n\tint i, j;\n\n\t \n\tnvkm_wr32(device, 0x418bb8, (gr->tpc_total << 8) |\n\t\t\t\t     gr->screen_tile_row_offset);\n\tfor (i = 0; i < mapregs; i++) {\n\t\tfor (data = 0, j = 0; j < 6; j++)\n\t\t\tdata |= (gr->tile[i * 6 + j] & 0x1f) << (j * 5);\n\t\tnvkm_wr32(device, 0x418b08 + (i * 4), data);\n\t\tnvkm_wr32(device, 0x41bf00 + (i * 4), data);\n\t\tnvkm_wr32(device, 0x40780c + (i * 4), data);\n\t}\n\n\t \n\tnvkm_wr32(device, 0x41bfd0, (gr->tpc_total << 8) |\n\t\t\t\t     gr->screen_tile_row_offset);\n\tfor (i = 0, j = 1; i < 5; i++, j += 4) {\n\t\tu8 v19 = (1 << (j + 0)) % gr->tpc_total;\n\t\tu8 v20 = (1 << (j + 1)) % gr->tpc_total;\n\t\tu8 v21 = (1 << (j + 2)) % gr->tpc_total;\n\t\tu8 v22 = (1 << (j + 3)) % gr->tpc_total;\n\t\tnvkm_wr32(device, 0x41bfb0 + (i * 4), (v22 << 24) |\n\t\t\t\t\t\t      (v21 << 16) |\n\t\t\t\t\t\t      (v20 <<  8) |\n\t\t\t\t\t\t       v19);\n\t}\n\n\t \n\tnvkm_wr32(device, 0x4078bc, (gr->tpc_total << 8) |\n\t\t\t\t     gr->screen_tile_row_offset);\n}\n\nvoid\ngv100_grctx_generate_r400088(struct gf100_gr *gr, bool on)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, 0x400088, 0x00060000, on ? 0x00060000 : 0x00000000);\n}\n\nstatic void\ngv100_grctx_generate_sm_id(struct gf100_gr *gr, int gpc, int tpc, int sm)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\n\ttpc = gv100_gr_nonpes_aware_tpc(gr, gpc, tpc);\n\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x608), sm);\n\tnvkm_wr32(device, GPC_UNIT(gpc, 0x0c10 + tpc * 4), sm);\n\tnvkm_wr32(device, TPC_UNIT(gpc, tpc, 0x088), sm);\n}\n\nvoid\ngv100_grctx_generate_unkn(struct gf100_gr *gr)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tnvkm_mask(device, 0x41980c, 0x00000010, 0x00000010);\n\tnvkm_mask(device, 0x41be08, 0x00000004, 0x00000004);\n\tnvkm_mask(device, 0x4064c0, 0x80000000, 0x80000000);\n\tnvkm_mask(device, 0x405800, 0x08000000, 0x08000000);\n\tnvkm_mask(device, 0x419c00, 0x00000008, 0x00000008);\n}\n\nvoid\ngv100_grctx_unkn88c(struct gf100_gr *gr, bool on)\n{\n\tstruct nvkm_device *device = gr->base.engine.subdev.device;\n\tconst u32 mask = 0x00000010, data = on ? mask : 0x00000000;\n\tnvkm_mask(device, 0x40988c, mask, data);\n\tnvkm_rd32(device, 0x40988c);\n\tnvkm_mask(device, 0x41a88c, mask, data);\n\tnvkm_rd32(device, 0x41a88c);\n\tnvkm_mask(device, 0x408a14, mask, data);\n\tnvkm_rd32(device, 0x408a14);\n}\n\nconst struct gf100_grctx_func\ngv100_grctx = {\n\t.unkn88c = gv100_grctx_unkn88c,\n\t.main = gf100_grctx_generate_main,\n\t.unkn = gv100_grctx_generate_unkn,\n\t.sw_veid_bundle_init = gv100_grctx_pack_sw_veid_bundle_init,\n\t.bundle = gm107_grctx_generate_bundle,\n\t.bundle_size = 0x3000,\n\t.bundle_min_gpm_fifo_depth = 0x180,\n\t.bundle_token_limit = 0x1680,\n\t.pagepool = gp100_grctx_generate_pagepool,\n\t.pagepool_size = 0x20000,\n\t.attrib_cb_size = gp102_grctx_generate_attrib_cb_size,\n\t.attrib_cb = gv100_grctx_generate_attrib_cb,\n\t.attrib = gv100_grctx_generate_attrib,\n\t.attrib_nr_max = 0x6c0,\n\t.attrib_nr = 0x480,\n\t.alpha_nr_max = 0xc00,\n\t.alpha_nr = 0x800,\n\t.gfxp_nr = 0xd10,\n\t.sm_id = gv100_grctx_generate_sm_id,\n\t.rop_mapping = gv100_grctx_generate_rop_mapping,\n\t.dist_skip_table = gm200_grctx_generate_dist_skip_table,\n\t.r406500 = gm200_grctx_generate_r406500,\n\t.gpc_tpc_nr = gk104_grctx_generate_gpc_tpc_nr,\n\t.smid_config = gp100_grctx_generate_smid_config,\n\t.r400088 = gv100_grctx_generate_r400088,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}