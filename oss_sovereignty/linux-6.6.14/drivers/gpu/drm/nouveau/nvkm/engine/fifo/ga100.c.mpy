{
  "module_name": "ga100.c",
  "hash_id": "75bf40ac3190b2e697b97438a68af283b56b30df400e966850293e693be4ea95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/ga100.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n#include \"runq.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/top.h>\n#include <subdev/vfn.h>\n\n#include <nvif/class.h>\n\nstatic u32\nga100_chan_doorbell_handle(struct nvkm_chan *chan)\n{\n\treturn (chan->cgrp->runl->doorbell << 16) | chan->id;\n}\n\nstatic void\nga100_chan_stop(struct nvkm_chan *chan)\n{\n\tstruct nvkm_runl *runl = chan->cgrp->runl;\n\n\tnvkm_wr32(runl->fifo->engine.subdev.device, runl->chan + (chan->id * 4), 0x00000003);\n}\n\nstatic void\nga100_chan_start(struct nvkm_chan *chan)\n{\n\tstruct nvkm_runl *runl = chan->cgrp->runl;\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tconst int gfid = 0;\n\n\tnvkm_wr32(device, runl->chan + (chan->id * 4), 0x00000002);\n\tnvkm_wr32(device, runl->addr + 0x0090, (gfid << 16) | chan->id);  \n}\n\nstatic void\nga100_chan_unbind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_runl *runl = chan->cgrp->runl;\n\n\tnvkm_wr32(runl->fifo->engine.subdev.device, runl->chan + (chan->id * 4), 0xffffffff);\n}\n\nstatic int\nga100_chan_ramfc_write(struct nvkm_chan *chan, u64 offset, u64 length, u32 devm, bool priv)\n{\n\tconst u32 limit2 = ilog2(length / 8);\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x010, 0x0000face);\n\tnvkm_wo32(chan->inst, 0x030, 0x7ffff902);\n\tnvkm_wo32(chan->inst, 0x048, lower_32_bits(offset));\n\tnvkm_wo32(chan->inst, 0x04c, upper_32_bits(offset) | (limit2 << 16));\n\tnvkm_wo32(chan->inst, 0x084, 0x20400000);\n\tnvkm_wo32(chan->inst, 0x094, 0x30000000 | devm);\n\tnvkm_wo32(chan->inst, 0x0e4, priv ? 0x00000020 : 0x00000000);\n\tnvkm_wo32(chan->inst, 0x0e8, chan->id);\n\tnvkm_wo32(chan->inst, 0x0f4, 0x00001000 | (priv ? 0x00000100 : 0x00000000));\n\tnvkm_wo32(chan->inst, 0x0f8, 0x80000000 | chan->cgrp->runl->nonstall.vector);\n\tnvkm_mo32(chan->inst, 0x218, 0x00000000, 0x00000000);\n\tnvkm_done(chan->inst);\n\treturn 0;\n}\n\nstatic const struct nvkm_chan_func_ramfc\nga100_chan_ramfc = {\n\t.write = ga100_chan_ramfc_write,\n\t.devm = 0xfff,\n\t.priv = true,\n};\n\nconst struct nvkm_chan_func\nga100_chan = {\n\t.inst = &gf100_chan_inst,\n\t.userd = &gv100_chan_userd,\n\t.ramfc = &ga100_chan_ramfc,\n\t.unbind = ga100_chan_unbind,\n\t.start = ga100_chan_start,\n\t.stop = ga100_chan_stop,\n\t.preempt = gk110_chan_preempt,\n\t.doorbell_handle = ga100_chan_doorbell_handle,\n};\n\nstatic void\nga100_cgrp_preempt(struct nvkm_cgrp *cgrp)\n{\n\tstruct nvkm_runl *runl = cgrp->runl;\n\n\tnvkm_wr32(runl->fifo->engine.subdev.device, runl->addr + 0x098, 0x01000000 | cgrp->id);\n}\n\nconst struct nvkm_cgrp_func\nga100_cgrp = {\n\t.preempt = ga100_cgrp_preempt,\n};\n\nstatic int\nga100_engn_cxid(struct nvkm_engn *engn, bool *cgid)\n{\n\tstruct nvkm_runl *runl = engn->runl;\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tu32 stat = nvkm_rd32(device, runl->addr + 0x200 + engn->id * 0x40);\n\n\tENGN_DEBUG(engn, \"status %08x\", stat);\n\t*cgid = true;\n\n\tswitch ((stat & 0x0000e000) >> 13) {\n\tcase 0  : return -ENODEV;\n\tcase 1  :\n\tcase 5  : return (stat & 0x00000fff);\n\tcase 6  : return (stat & 0x0fff0000) >> 16;\n\tcase 7  :\n\t\tif (nvkm_engine_chsw_load(engn->engine))\n\t\t\treturn (stat & 0x0fff0000) >> 16;\n\t\treturn (stat & 0x00000fff);\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int\nga100_engn_nonstall(struct nvkm_engn *engn)\n{\n\tstruct nvkm_engine *engine = engn->engine;\n\n\tif (WARN_ON(!engine->func->nonstall))\n\t\treturn -EINVAL;\n\n\treturn engine->func->nonstall(engine);\n}\n\nconst struct nvkm_engn_func\nga100_engn = {\n\t.nonstall = ga100_engn_nonstall,\n\t.cxid = ga100_engn_cxid,\n\t.ctor = gk104_ectx_ctor,\n\t.bind = gv100_ectx_bind,\n};\n\nconst struct nvkm_engn_func\nga100_engn_ce = {\n\t.nonstall = ga100_engn_nonstall,\n\t.cxid = ga100_engn_cxid,\n\t.ctor = gv100_ectx_ce_ctor,\n\t.bind = gv100_ectx_ce_bind,\n};\n\nstatic bool\nga100_runq_idle(struct nvkm_runq *runq)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\n\treturn !(nvkm_rd32(device, 0x04015c + (runq->id * 0x800)) & 0x0000e000);\n}\n\nstatic bool\nga100_runq_intr_1(struct nvkm_runq *runq, struct nvkm_runl *runl)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\tu32 inte = nvkm_rd32(device, 0x040180 + (runq->id * 0x800));\n\tu32 intr = nvkm_rd32(device, 0x040148 + (runq->id * 0x800));\n\tu32 stat = intr & inte;\n\n\tif (!stat) {\n\t\tRUNQ_DEBUG(runq, \"inte1 %08x %08x\", intr, inte);\n\t\treturn false;\n\t}\n\n\tif (stat & 0x80000000) {\n\t\tu32 chid = nvkm_rd32(device, 0x040120 + (runq->id * 0x0800)) & runl->chid->mask;\n\t\tstruct nvkm_chan *chan;\n\t\tunsigned long flags;\n\n\t\tRUNQ_ERROR(runq, \"CTXNOTVALID chid:%d\", chid);\n\t\tchan = nvkm_runl_chan_get_chid(runl, chid, &flags);\n\t\tif (chan) {\n\t\t\tnvkm_chan_error(chan, true);\n\t\t\tnvkm_chan_put(&chan, flags);\n\t\t}\n\n\t\tnvkm_mask(device, 0x0400ac + (runq->id * 0x800), 0x00030000, 0x00030000);\n\t\tstat &= ~0x80000000;\n\t}\n\n\tif (stat) {\n\t\tRUNQ_ERROR(runq, \"intr1 %08x\", stat);\n\t\tnvkm_wr32(device, 0x0401a0 + (runq->id * 0x800), stat);\n\t}\n\n\tnvkm_wr32(device, 0x040148 + (runq->id * 0x800), intr);\n\treturn true;\n}\n\nstatic bool\nga100_runq_intr_0(struct nvkm_runq *runq, struct nvkm_runl *runl)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\tu32 inte = nvkm_rd32(device, 0x040170 + (runq->id * 0x800));\n\tu32 intr = nvkm_rd32(device, 0x040108 + (runq->id * 0x800));\n\tu32 stat = intr & inte;\n\n\tif (!stat) {\n\t\tRUNQ_DEBUG(runq, \"inte0 %08x %08x\", intr, inte);\n\t\treturn false;\n\t}\n\n\t \n\tif (stat & 0xc6afe000) {\n\t\tu32 chid = nvkm_rd32(device, 0x040120 + (runq->id * 0x0800)) & runl->chid->mask;\n\t\tstruct nvkm_chan *chan;\n\t\tunsigned long flags;\n\n\t\tRUNQ_ERROR(runq, \"intr0 %08x\", stat);\n\t\tchan = nvkm_runl_chan_get_chid(runl, chid, &flags);\n\t\tif (chan) {\n\t\t\tnvkm_chan_error(chan, true);\n\t\t\tnvkm_chan_put(&chan, flags);\n\t\t}\n\n\t\tstat &= ~0xc6afe000;\n\t}\n\n\tif (stat) {\n\t\tRUNQ_ERROR(runq, \"intr0 %08x\", stat);\n\t\tnvkm_wr32(device, 0x040190 + (runq->id * 0x800), stat);\n\t}\n\n\tnvkm_wr32(device, 0x040108 + (runq->id * 0x800), intr);\n\treturn true;\n}\n\nstatic bool\nga100_runq_intr(struct nvkm_runq *runq, struct nvkm_runl *runl)\n{\n\tbool intr0 = ga100_runq_intr_0(runq, runl);\n\tbool intr1 = ga100_runq_intr_1(runq, runl);\n\n\treturn intr0 || intr1;\n}\n\nstatic void\nga100_runq_init(struct nvkm_runq *runq)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x040108 + (runq->id * 0x800), 0xffffffff);  \n\tnvkm_wr32(device, 0x040148 + (runq->id * 0x800), 0xffffffff);  \n\tnvkm_wr32(device, 0x040170 + (runq->id * 0x800), 0xffffffff);  \n\tnvkm_wr32(device, 0x040180 + (runq->id * 0x800), 0xffffffff);  \n}\n\nconst struct nvkm_runq_func\nga100_runq = {\n\t.init = ga100_runq_init,\n\t.intr = ga100_runq_intr,\n\t.idle = ga100_runq_idle,\n};\n\nstatic bool\nga100_runl_preempt_pending(struct nvkm_runl *runl)\n{\n\treturn nvkm_rd32(runl->fifo->engine.subdev.device, runl->addr + 0x098) & 0x00100000;\n}\n\nstatic void\nga100_runl_preempt(struct nvkm_runl *runl)\n{\n\tnvkm_wr32(runl->fifo->engine.subdev.device, runl->addr + 0x098, 0x00000000);\n}\n\nstatic void\nga100_runl_allow(struct nvkm_runl *runl, u32 engm)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, runl->addr + 0x094, 0x00000001, 0x00000000);\n}\n\nstatic void\nga100_runl_block(struct nvkm_runl *runl, u32 engm)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, runl->addr + 0x094, 0x00000001, 0x00000001);\n}\n\nstatic bool\nga100_runl_pending(struct nvkm_runl *runl)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\n\treturn nvkm_rd32(device, runl->addr + 0x08c) & 0x00008000;\n}\n\nstatic void\nga100_runl_commit(struct nvkm_runl *runl, struct nvkm_memory *memory, u32 start, int count)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tu64 addr = nvkm_memory_addr(memory) + start;\n\n\tnvkm_wr32(device, runl->addr + 0x080, lower_32_bits(addr));\n\tnvkm_wr32(device, runl->addr + 0x084, upper_32_bits(addr));\n\tnvkm_wr32(device, runl->addr + 0x088, count);\n}\n\nstatic irqreturn_t\nga100_runl_intr(struct nvkm_inth *inth)\n{\n\tstruct nvkm_runl *runl = container_of(inth, typeof(*runl), inth);\n\tstruct nvkm_engn *engn;\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\tu32 inte = nvkm_rd32(device, runl->addr + 0x120);\n\tu32 intr = nvkm_rd32(device, runl->addr + 0x100);\n\tu32 stat = intr & inte;\n\tu32 info;\n\n\tif (!stat) {\n\t\tRUNL_DEBUG(runl, \"inte %08x %08x\", intr, inte);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (stat & 0x00000007) {\n\t\tnvkm_runl_foreach_engn_cond(engn, runl, stat & BIT(engn->id)) {\n\t\t\tinfo = nvkm_rd32(device, runl->addr + 0x224 + (engn->id * 0x40));\n\n\t\t\ttu102_fifo_intr_ctxsw_timeout_info(engn, info);\n\n\t\t\tnvkm_wr32(device, runl->addr + 0x100, BIT(engn->id));\n\t\t\tstat &= ~BIT(engn->id);\n\t\t}\n\t}\n\n\tif (stat & 0x00000300) {\n\t\tnvkm_wr32(device, runl->addr + 0x100, stat & 0x00000300);\n\t\tstat &= ~0x00000300;\n\t}\n\n\tif (stat & 0x00010000) {\n\t\tif (runl->runq[0]) {\n\t\t\tif (runl->runq[0]->func->intr(runl->runq[0], runl))\n\t\t\t\tstat &= ~0x00010000;\n\t\t}\n\t}\n\n\tif (stat & 0x00020000) {\n\t\tif (runl->runq[1]) {\n\t\t\tif (runl->runq[1]->func->intr(runl->runq[1], runl))\n\t\t\t\tstat &= ~0x00020000;\n\t\t}\n\t}\n\n\tif (stat) {\n\t\tRUNL_ERROR(runl, \"intr %08x\", stat);\n\t\tnvkm_wr32(device, runl->addr + 0x140, stat);\n\t}\n\n\tnvkm_wr32(device, runl->addr + 0x180, 0x00000001);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nga100_runl_fini(struct nvkm_runl *runl)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, runl->addr + 0x300, 0x80000000, 0x00000000);\n\tnvkm_inth_block(&runl->inth);\n}\n\nstatic void\nga100_runl_init(struct nvkm_runl *runl)\n{\n\tstruct nvkm_fifo *fifo = runl->fifo;\n\tstruct nvkm_runq *runq;\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tint i;\n\n\t \n\tnvkm_wr32(device, runl->addr + 0x088, 0x00000000);\n\trunl->func->preempt(runl);\n\n\t \n\tnvkm_mask(device, runl->addr + 0x300, 0x80000000, 0x80000000);\n\n\tnvkm_wr32(device, runl->addr + 0x100, 0xffffffff);  \n\tnvkm_wr32(device, runl->addr + 0x140, 0xffffffff);  \n\tnvkm_wr32(device, runl->addr + 0x120, 0x000f1307);  \n\tnvkm_wr32(device, runl->addr + 0x148, 0xffffffff);  \n\tnvkm_wr32(device, runl->addr + 0x128, 0x00000000);  \n\n\t \n\tfor (i = 0; i < runl->runq_nr; i++) {\n\t\trunq = runl->runq[i];\n\t\trunq->func->init(runq);\n\t}\n\n\tnvkm_inth_allow(&runl->inth);\n}\n\nconst struct nvkm_runl_func\nga100_runl = {\n\t.init = ga100_runl_init,\n\t.fini = ga100_runl_fini,\n\t.size = 16,\n\t.update = nv50_runl_update,\n\t.insert_cgrp = gv100_runl_insert_cgrp,\n\t.insert_chan = gv100_runl_insert_chan,\n\t.commit = ga100_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = ga100_runl_pending,\n\t.block = ga100_runl_block,\n\t.allow = ga100_runl_allow,\n\t.preempt = ga100_runl_preempt,\n\t.preempt_pending = ga100_runl_preempt_pending,\n};\n\nstatic int\nga100_runl_new(struct nvkm_fifo *fifo, int id, u32 addr, struct nvkm_runl **prunl)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_top_device *tdev;\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_engn *engn;\n\tu32 chcfg  = nvkm_rd32(device, addr + 0x004);\n\tu32 chnum  = 1 << (chcfg & 0x0000000f);\n\tu32 chaddr = (chcfg & 0xfffffff0);\n\tu32 dbcfg  = nvkm_rd32(device, addr + 0x008);\n\tu32 vector = nvkm_rd32(device, addr + 0x160);\n\tint i, ret;\n\n\trunl = nvkm_runl_new(fifo, id, addr, chnum);\n\tif (IS_ERR(runl))\n\t\treturn PTR_ERR(runl);\n\n\t*prunl = runl;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tu32 pbcfg = nvkm_rd32(device, addr + 0x010 + (i * 0x04));\n\t\tif (pbcfg & 0x80000000) {\n\t\t\trunl->runq[runl->runq_nr] =\n\t\t\t\tnvkm_runq_new(fifo, ((pbcfg & 0x03fffc00) - 0x040000) / 0x800);\n\t\t\tif (!runl->runq[runl->runq_nr]) {\n\t\t\t\tRUNL_ERROR(runl, \"runq %d\", runl->runq_nr);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\trunl->runq_nr++;\n\t\t}\n\t}\n\n\tnvkm_list_foreach(tdev, &device->top->device, head, tdev->runlist == runl->addr) {\n\t\tif (tdev->engine < 0) {\n\t\t\tRUNL_DEBUG(runl, \"engn !top\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tengn = nvkm_runl_add(runl, tdev->engine, (tdev->type == NVKM_ENGINE_CE) ?\n\t\t\t\t     fifo->func->engn_ce : fifo->func->engn,\n\t\t\t\t     tdev->type, tdev->inst);\n\t\tif (!engn)\n\t\t\treturn -EINVAL;\n\n\t\tif (!engn->engine->func->nonstall) {\n\t\t\tRUNL_DEBUG(runl, \"engn %s !nonstall\", engn->engine->subdev.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (list_empty(&runl->engns)) {\n\t\tRUNL_DEBUG(runl, \"!engns\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = nvkm_inth_add(&device->vfn->intr, vector & 0x00000fff, NVKM_INTR_PRIO_NORMAL,\n\t\t\t    &fifo->engine.subdev, ga100_runl_intr, &runl->inth);\n\tif (ret) {\n\t\tRUNL_ERROR(runl, \"inth %d\", ret);\n\t\treturn ret;\n\t}\n\n\trunl->chan = chaddr;\n\trunl->doorbell = dbcfg >> 16;\n\treturn 0;\n}\n\nstatic irqreturn_t\nga100_fifo_nonstall_intr(struct nvkm_inth *inth)\n{\n\tstruct nvkm_runl *runl = container_of(inth, typeof(*runl), nonstall.inth);\n\n\tnvkm_event_ntfy(&runl->fifo->nonstall.event, runl->id, NVKM_FIFO_NONSTALL_EVENT);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nga100_fifo_nonstall_block(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fifo *fifo = container_of(event, typeof(*fifo), nonstall.event);\n\tstruct nvkm_runl *runl = nvkm_runl_get(fifo, index, 0);\n\n\tnvkm_inth_block(&runl->nonstall.inth);\n}\n\nstatic void\nga100_fifo_nonstall_allow(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fifo *fifo = container_of(event, typeof(*fifo), nonstall.event);\n\tstruct nvkm_runl *runl = nvkm_runl_get(fifo, index, 0);\n\n\tnvkm_inth_allow(&runl->nonstall.inth);\n}\n\nconst struct nvkm_event_func\nga100_fifo_nonstall = {\n\t.init = ga100_fifo_nonstall_allow,\n\t.fini = ga100_fifo_nonstall_block,\n};\n\nint\nga100_fifo_nonstall_ctor(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_vfn *vfn = subdev->device->vfn;\n\tstruct nvkm_runl *runl;\n\tint ret, nr = 0;\n\n\tnvkm_runl_foreach(runl, fifo) {\n\t\tstruct nvkm_engn *engn = list_first_entry(&runl->engns, typeof(*engn), head);\n\n\t\trunl->nonstall.vector = engn->func->nonstall(engn);\n\t\tif (runl->nonstall.vector < 0) {\n\t\t\tRUNL_ERROR(runl, \"nonstall %d\", runl->nonstall.vector);\n\t\t\treturn runl->nonstall.vector;\n\t\t}\n\n\t\tret = nvkm_inth_add(&vfn->intr, runl->nonstall.vector, NVKM_INTR_PRIO_NORMAL,\n\t\t\t\t    subdev, ga100_fifo_nonstall_intr, &runl->nonstall.inth);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnr = max(nr, runl->id + 1);\n\t}\n\n\treturn nr;\n}\n\nint\nga100_fifo_runl_ctor(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_top_device *tdev;\n\tstruct nvkm_runl *runl;\n\tint id = 0, ret;\n\n\tnvkm_list_foreach(tdev, &device->top->device, head, tdev->runlist >= 0) {\n\t\trunl = nvkm_runl_get(fifo, -1, tdev->runlist);\n\t\tif (!runl) {\n\t\t\tret = ga100_runl_new(fifo, id++, tdev->runlist, &runl);\n\t\t\tif (ret) {\n\t\t\t\tif (runl)\n\t\t\t\t\tnvkm_runl_del(runl);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_fifo_func\nga100_fifo = {\n\t.runl_ctor = ga100_fifo_runl_ctor,\n\t.mmu_fault = &tu102_fifo_mmu_fault,\n\t.nonstall_ctor = ga100_fifo_nonstall_ctor,\n\t.nonstall = &ga100_fifo_nonstall,\n\t.runl = &ga100_runl,\n\t.runq = &ga100_runq,\n\t.engn = &ga100_engn,\n\t.engn_ce = &ga100_engn_ce,\n\t.cgrp = {{ 0, 0, KEPLER_CHANNEL_GROUP_A  }, &ga100_cgrp, .force = true },\n\t.chan = {{ 0, 0, AMPERE_CHANNEL_GPFIFO_A }, &ga100_chan },\n};\n\nint\nga100_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&ga100_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}