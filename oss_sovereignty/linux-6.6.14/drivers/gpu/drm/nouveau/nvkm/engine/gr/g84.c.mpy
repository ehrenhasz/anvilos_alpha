{
  "module_name": "g84.c",
  "hash_id": "d4e2b35e288dd3eaefdcc9bf81c730b117e59724e9857ac45acc3b405320e1af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/gr/g84.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <subdev/timer.h>\n\n#include <nvif/class.h>\n\nstatic const struct nvkm_bitfield nv50_gr_status[] = {\n\t{ 0x00000001, \"BUSY\" },  \n\t{ 0x00000002, \"DISPATCH\" },\n\t{ 0x00000004, \"UNK2\" },\n\t{ 0x00000008, \"UNK3\" },\n\t{ 0x00000010, \"UNK4\" },\n\t{ 0x00000020, \"UNK5\" },\n\t{ 0x00000040, \"M2MF\" },\n\t{ 0x00000080, \"UNK7\" },\n\t{ 0x00000100, \"CTXPROG\" },\n\t{ 0x00000200, \"VFETCH\" },\n\t{ 0x00000400, \"CCACHE_PREGEOM\" },\n\t{ 0x00000800, \"STRMOUT_VATTR_POSTGEOM\" },\n\t{ 0x00001000, \"VCLIP\" },\n\t{ 0x00002000, \"RATTR_APLANE\" },\n\t{ 0x00004000, \"TRAST\" },\n\t{ 0x00008000, \"CLIPID\" },\n\t{ 0x00010000, \"ZCULL\" },\n\t{ 0x00020000, \"ENG2D\" },\n\t{ 0x00040000, \"RMASK\" },\n\t{ 0x00080000, \"TPC_RAST\" },\n\t{ 0x00100000, \"TPC_PROP\" },\n\t{ 0x00200000, \"TPC_TEX\" },\n\t{ 0x00400000, \"TPC_GEOM\" },\n\t{ 0x00800000, \"TPC_MP\" },\n\t{ 0x01000000, \"ROP\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield\nnv50_gr_vstatus_0[] = {\n\t{ 0x01, \"VFETCH\" },\n\t{ 0x02, \"CCACHE\" },\n\t{ 0x04, \"PREGEOM\" },\n\t{ 0x08, \"POSTGEOM\" },\n\t{ 0x10, \"VATTR\" },\n\t{ 0x20, \"STRMOUT\" },\n\t{ 0x40, \"VCLIP\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield\nnv50_gr_vstatus_1[] = {\n\t{ 0x01, \"TPC_RAST\" },\n\t{ 0x02, \"TPC_PROP\" },\n\t{ 0x04, \"TPC_TEX\" },\n\t{ 0x08, \"TPC_GEOM\" },\n\t{ 0x10, \"TPC_MP\" },\n\t{}\n};\n\nstatic const struct nvkm_bitfield\nnv50_gr_vstatus_2[] = {\n\t{ 0x01, \"RATTR\" },\n\t{ 0x02, \"APLANE\" },\n\t{ 0x04, \"TRAST\" },\n\t{ 0x08, \"CLIPID\" },\n\t{ 0x10, \"ZCULL\" },\n\t{ 0x20, \"ENG2D\" },\n\t{ 0x40, \"RMASK\" },\n\t{ 0x80, \"ROP\" },\n\t{}\n};\n\nstatic void\nnvkm_gr_vstatus_print(struct nv50_gr *gr, int r,\n\t\t      const struct nvkm_bitfield *units, u32 status)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tu32 stat = status;\n\tu8  mask = 0x00;\n\tchar msg[64];\n\tint i;\n\n\tfor (i = 0; units[i].name && status; i++) {\n\t\tif ((status & 7) == 1)\n\t\t\tmask |= (1 << i);\n\t\tstatus >>= 3;\n\t}\n\n\tnvkm_snprintbf(msg, sizeof(msg), units, mask);\n\tnvkm_error(subdev, \"PGRAPH_VSTATUS%d: %08x [%s]\\n\", r, stat, msg);\n}\n\nint\ng84_gr_tlb_flush(struct nvkm_gr *base)\n{\n\tstruct nv50_gr *gr = nv50_gr(base);\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_timer *tmr = device->timer;\n\tbool idle, timeout = false;\n\tunsigned long flags;\n\tchar status[128];\n\tu64 start;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&gr->lock, flags);\n\tnvkm_mask(device, 0x400500, 0x00000001, 0x00000000);\n\n\tstart = nvkm_timer_read(tmr);\n\tdo {\n\t\tidle = true;\n\n\t\tfor (tmp = nvkm_rd32(device, 0x400380); tmp && idle; tmp >>= 3) {\n\t\t\tif ((tmp & 7) == 1)\n\t\t\t\tidle = false;\n\t\t}\n\n\t\tfor (tmp = nvkm_rd32(device, 0x400384); tmp && idle; tmp >>= 3) {\n\t\t\tif ((tmp & 7) == 1)\n\t\t\t\tidle = false;\n\t\t}\n\n\t\tfor (tmp = nvkm_rd32(device, 0x400388); tmp && idle; tmp >>= 3) {\n\t\t\tif ((tmp & 7) == 1)\n\t\t\t\tidle = false;\n\t\t}\n\t} while (!idle &&\n\t\t !(timeout = nvkm_timer_read(tmr) - start > 2000000000));\n\n\tif (timeout) {\n\t\tnvkm_error(subdev, \"PGRAPH TLB flush idle timeout fail\\n\");\n\n\t\ttmp = nvkm_rd32(device, 0x400700);\n\t\tnvkm_snprintbf(status, sizeof(status), nv50_gr_status, tmp);\n\t\tnvkm_error(subdev, \"PGRAPH_STATUS %08x [%s]\\n\", tmp, status);\n\n\t\tnvkm_gr_vstatus_print(gr, 0, nv50_gr_vstatus_0,\n\t\t\t\t       nvkm_rd32(device, 0x400380));\n\t\tnvkm_gr_vstatus_print(gr, 1, nv50_gr_vstatus_1,\n\t\t\t\t       nvkm_rd32(device, 0x400384));\n\t\tnvkm_gr_vstatus_print(gr, 2, nv50_gr_vstatus_2,\n\t\t\t\t       nvkm_rd32(device, 0x400388));\n\t}\n\n\n\tnvkm_wr32(device, 0x100c80, 0x00000001);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x100c80) & 0x00000001))\n\t\t\tbreak;\n\t);\n\tnvkm_mask(device, 0x400500, 0x00000001, 0x00000001);\n\tspin_unlock_irqrestore(&gr->lock, flags);\n\treturn timeout ? -EBUSY : 0;\n}\n\nstatic const struct nvkm_gr_func\ng84_gr = {\n\t.init = nv50_gr_init,\n\t.intr = nv50_gr_intr,\n\t.chan_new = nv50_gr_chan_new,\n\t.tlb_flush = g84_gr_tlb_flush,\n\t.units = nv50_gr_units,\n\t.sclass = {\n\t\t{ -1, -1, NV_NULL_CLASS, &nv50_gr_object },\n\t\t{ -1, -1, NV50_TWOD, &nv50_gr_object },\n\t\t{ -1, -1, NV50_MEMORY_TO_MEMORY_FORMAT, &nv50_gr_object },\n\t\t{ -1, -1, NV50_COMPUTE, &nv50_gr_object },\n\t\t{ -1, -1, G82_TESLA, &nv50_gr_object },\n\t\t{}\n\t}\n};\n\nint\ng84_gr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_gr **pgr)\n{\n\treturn nv50_gr_new_(&g84_gr, device, type, inst, pgr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}