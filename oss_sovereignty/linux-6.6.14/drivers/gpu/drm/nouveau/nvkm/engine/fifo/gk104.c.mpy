{
  "module_name": "gk104.c",
  "hash_id": "e2bc1dd7d3fd08c061005a0fca969187d17fcb062310486251fbd7f73a610914",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/fifo/gk104.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"cgrp.h\"\n#include \"chan.h\"\n#include \"chid.h\"\n#include \"runl.h\"\n#include \"runq.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/mc.h>\n#include <subdev/mmu.h>\n#include <subdev/top.h>\n\n#include <nvif/class.h>\n#include <nvif/if900d.h>\n\nvoid\ngk104_chan_stop(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x800004 + (chan->id * 8), 0x00000800, 0x00000800);\n}\n\nvoid\ngk104_chan_start(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x800004 + (chan->id * 8), 0x00000400, 0x00000400);\n}\n\nvoid\ngk104_chan_unbind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x800000 + (chan->id * 8), 0x00000000);\n}\n\nvoid\ngk104_chan_bind_inst(struct nvkm_chan *chan)\n{\n\tstruct nvkm_device *device = chan->cgrp->runl->fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x800000 + (chan->id * 8), 0x80000000 | chan->inst->addr >> 12);\n}\n\nvoid\ngk104_chan_bind(struct nvkm_chan *chan)\n{\n\tstruct nvkm_runl *runl = chan->cgrp->runl;\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\n\tnvkm_mask(device, 0x800004 + (chan->id * 8), 0x000f0000, runl->id << 16);\n\tgk104_chan_bind_inst(chan);\n}\n\nstatic int\ngk104_chan_ramfc_write(struct nvkm_chan *chan, u64 offset, u64 length, u32 devm, bool priv)\n{\n\tconst u64 userd = nvkm_memory_addr(chan->userd.mem) + chan->userd.base;\n\tconst u32 limit2 = ilog2(length / 8);\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, 0x08, lower_32_bits(userd));\n\tnvkm_wo32(chan->inst, 0x0c, upper_32_bits(userd));\n\tnvkm_wo32(chan->inst, 0x10, 0x0000face);\n\tnvkm_wo32(chan->inst, 0x30, 0xfffff902);\n\tnvkm_wo32(chan->inst, 0x48, lower_32_bits(offset));\n\tnvkm_wo32(chan->inst, 0x4c, upper_32_bits(offset) | (limit2 << 16));\n\tnvkm_wo32(chan->inst, 0x84, 0x20400000);\n\tnvkm_wo32(chan->inst, 0x94, 0x30000000 | devm);\n\tnvkm_wo32(chan->inst, 0x9c, 0x00000100);\n\tnvkm_wo32(chan->inst, 0xac, 0x0000001f);\n\tnvkm_wo32(chan->inst, 0xe4, priv ? 0x00000020 : 0x00000000);\n\tnvkm_wo32(chan->inst, 0xe8, chan->id);\n\tnvkm_wo32(chan->inst, 0xb8, 0xf8000000);\n\tnvkm_wo32(chan->inst, 0xf8, 0x10003080);  \n\tnvkm_wo32(chan->inst, 0xfc, 0x10000010);  \n\tnvkm_done(chan->inst);\n\treturn 0;\n}\n\nconst struct nvkm_chan_func_ramfc\ngk104_chan_ramfc = {\n\t.write = gk104_chan_ramfc_write,\n\t.devm = 0xfff,\n\t.priv = true,\n};\n\nconst struct nvkm_chan_func_userd\ngk104_chan_userd = {\n\t.bar = 1,\n\t.size = 0x200,\n\t.clear = gf100_chan_userd_clear,\n};\n\nstatic const struct nvkm_chan_func\ngk104_chan = {\n\t.inst = &gf100_chan_inst,\n\t.userd = &gk104_chan_userd,\n\t.ramfc = &gk104_chan_ramfc,\n\t.bind = gk104_chan_bind,\n\t.unbind = gk104_chan_unbind,\n\t.start = gk104_chan_start,\n\t.stop = gk104_chan_stop,\n\t.preempt = gf100_chan_preempt,\n};\n\nstatic void\ngk104_ectx_bind(struct nvkm_engn *engn, struct nvkm_cctx *cctx, struct nvkm_chan *chan)\n{\n\tu32 ptr0, ptr1 = 0;\n\tu64 addr = 0ULL;\n\n\tswitch (engn->engine->subdev.type) {\n\tcase NVKM_ENGINE_SW    : return;\n\tcase NVKM_ENGINE_GR    : ptr0 = 0x0210; break;\n\tcase NVKM_ENGINE_SEC   : ptr0 = 0x0220; break;\n\tcase NVKM_ENGINE_MSPDEC: ptr0 = 0x0250; break;\n\tcase NVKM_ENGINE_MSPPP : ptr0 = 0x0260; break;\n\tcase NVKM_ENGINE_MSVLD : ptr0 = 0x0270; break;\n\tcase NVKM_ENGINE_VIC   : ptr0 = 0x0280; break;\n\tcase NVKM_ENGINE_MSENC : ptr0 = 0x0290; break;\n\tcase NVKM_ENGINE_NVDEC :\n\t\tptr1 = 0x0270;\n\t\tptr0 = 0x0210;\n\t\tbreak;\n\tcase NVKM_ENGINE_NVENC :\n\t\tif (!engn->engine->subdev.inst)\n\t\t\tptr1 = 0x0290;\n\t\tptr0 = 0x0210;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (cctx) {\n\t\taddr  = cctx->vctx->vma->addr;\n\t\taddr |= 4ULL;\n\t}\n\n\tnvkm_kmap(chan->inst);\n\tnvkm_wo32(chan->inst, ptr0 + 0, lower_32_bits(addr));\n\tnvkm_wo32(chan->inst, ptr0 + 4, upper_32_bits(addr));\n\tif (ptr1) {\n\t\tnvkm_wo32(chan->inst, ptr1 + 0, lower_32_bits(addr));\n\t\tnvkm_wo32(chan->inst, ptr1 + 4, upper_32_bits(addr));\n\t}\n\tnvkm_done(chan->inst);\n}\n\nint\ngk104_ectx_ctor(struct nvkm_engn *engn, struct nvkm_vctx *vctx)\n{\n\tstruct gf100_vmm_map_v0 args = { .priv = 1 };\n\tint ret;\n\n\tret = nvkm_vmm_get(vctx->vmm, 12, vctx->inst->size, &vctx->vma);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nvkm_memory_map(vctx->inst, 0, vctx->vmm, vctx->vma, &args, sizeof(args));\n}\n\n \nstruct gk104_engn_status {\n\tbool busy;\n\tbool faulted;\n\tbool chsw;\n\tbool save;\n\tbool load;\n\tstruct {\n\t\tbool tsg;\n\t\tu32 id;\n\t} prev, next, *chan;\n};\n\nstatic void\ngk104_engn_status(struct nvkm_engn *engn, struct gk104_engn_status *status)\n{\n\tu32 stat = nvkm_rd32(engn->runl->fifo->engine.subdev.device, 0x002640 + (engn->id * 0x08));\n\n\tstatus->busy     = !!(stat & 0x80000000);\n\tstatus->faulted  = !!(stat & 0x40000000);\n\tstatus->next.tsg = !!(stat & 0x10000000);\n\tstatus->next.id  =   (stat & 0x0fff0000) >> 16;\n\tstatus->chsw     = !!(stat & 0x00008000);\n\tstatus->save     = !!(stat & 0x00004000);\n\tstatus->load     = !!(stat & 0x00002000);\n\tstatus->prev.tsg = !!(stat & 0x00001000);\n\tstatus->prev.id  =   (stat & 0x00000fff);\n\tstatus->chan     = NULL;\n\n\tif (status->busy && status->chsw) {\n\t\tif (status->load && status->save) {\n\t\t\tif (nvkm_engine_chsw_load(engn->engine))\n\t\t\t\tstatus->chan = &status->next;\n\t\t\telse\n\t\t\t\tstatus->chan = &status->prev;\n\t\t} else\n\t\tif (status->load) {\n\t\t\tstatus->chan = &status->next;\n\t\t} else {\n\t\t\tstatus->chan = &status->prev;\n\t\t}\n\t} else\n\tif (status->load) {\n\t\tstatus->chan = &status->prev;\n\t}\n\n\tENGN_DEBUG(engn, \"%08x: busy %d faulted %d chsw %d save %d load %d %sid %d%s-> %sid %d%s\",\n\t\t   stat, status->busy, status->faulted, status->chsw, status->save, status->load,\n\t\t   status->prev.tsg ? \"tsg\" : \"ch\", status->prev.id,\n\t\t   status->chan == &status->prev ? \"*\" : \" \",\n\t\t   status->next.tsg ? \"tsg\" : \"ch\", status->next.id,\n\t\t   status->chan == &status->next ? \"*\" : \" \");\n}\n\nint\ngk104_engn_cxid(struct nvkm_engn *engn, bool *cgid)\n{\n\tstruct gk104_engn_status status;\n\n\tgk104_engn_status(engn, &status);\n\tif (status.chan) {\n\t\t*cgid = status.chan->tsg;\n\t\treturn status.chan->id;\n\t}\n\n\treturn -ENODEV;\n}\n\nbool\ngk104_engn_chsw(struct nvkm_engn *engn)\n{\n\tstruct gk104_engn_status status;\n\n\tgk104_engn_status(engn, &status);\n\tif (status.busy && status.chsw)\n\t\treturn true;\n\n\treturn false;\n}\n\nconst struct nvkm_engn_func\ngk104_engn = {\n\t.chsw = gk104_engn_chsw,\n\t.cxid = gk104_engn_cxid,\n\t.mmu_fault_trigger = gf100_engn_mmu_fault_trigger,\n\t.mmu_fault_triggered = gf100_engn_mmu_fault_triggered,\n\t.ctor = gk104_ectx_ctor,\n\t.bind = gk104_ectx_bind,\n};\n\nconst struct nvkm_engn_func\ngk104_engn_ce = {\n\t.chsw = gk104_engn_chsw,\n\t.cxid = gk104_engn_cxid,\n\t.mmu_fault_trigger = gf100_engn_mmu_fault_trigger,\n\t.mmu_fault_triggered = gf100_engn_mmu_fault_triggered,\n};\n\nbool\ngk104_runq_idle(struct nvkm_runq *runq)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\n\treturn !(nvkm_rd32(device, 0x003080 + (runq->id * 4)) & 0x0000e000);\n}\n\nstatic const struct nvkm_bitfield\ngk104_runq_intr_1_names[] = {\n\t{ 0x00000001, \"HCE_RE_ILLEGAL_OP\" },\n\t{ 0x00000002, \"HCE_RE_ALIGNB\" },\n\t{ 0x00000004, \"HCE_PRIV\" },\n\t{ 0x00000008, \"HCE_ILLEGAL_MTHD\" },\n\t{ 0x00000010, \"HCE_ILLEGAL_CLASS\" },\n\t{}\n};\n\nstatic bool\ngk104_runq_intr_1(struct nvkm_runq *runq)\n{\n\tstruct nvkm_subdev *subdev = &runq->fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mask = nvkm_rd32(device, 0x04014c + (runq->id * 0x2000));\n\tu32 stat = nvkm_rd32(device, 0x040148 + (runq->id * 0x2000)) & mask;\n\tu32 chid = nvkm_rd32(device, 0x040120 + (runq->id * 0x2000)) & 0xfff;\n\tchar msg[128];\n\n\tif (stat & 0x80000000) {\n\t\tif (runq->func->intr_1_ctxnotvalid &&\n\t\t    runq->func->intr_1_ctxnotvalid(runq, chid))\n\t\t\tstat &= ~0x80000000;\n\t}\n\n\tif (stat) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), gk104_runq_intr_1_names, stat);\n\t\tnvkm_error(subdev, \"PBDMA%d: %08x [%s] ch %d %08x %08x\\n\",\n\t\t\t   runq->id, stat, msg, chid,\n\t\t\t   nvkm_rd32(device, 0x040150 + (runq->id * 0x2000)),\n\t\t\t   nvkm_rd32(device, 0x040154 + (runq->id * 0x2000)));\n\t}\n\n\tnvkm_wr32(device, 0x040148 + (runq->id * 0x2000), stat);\n\treturn true;\n}\n\nconst struct nvkm_bitfield\ngk104_runq_intr_0_names[] = {\n\t{ 0x00000001, \"MEMREQ\" },\n\t{ 0x00000002, \"MEMACK_TIMEOUT\" },\n\t{ 0x00000004, \"MEMACK_EXTRA\" },\n\t{ 0x00000008, \"MEMDAT_TIMEOUT\" },\n\t{ 0x00000010, \"MEMDAT_EXTRA\" },\n\t{ 0x00000020, \"MEMFLUSH\" },\n\t{ 0x00000040, \"MEMOP\" },\n\t{ 0x00000080, \"LBCONNECT\" },\n\t{ 0x00000100, \"LBREQ\" },\n\t{ 0x00000200, \"LBACK_TIMEOUT\" },\n\t{ 0x00000400, \"LBACK_EXTRA\" },\n\t{ 0x00000800, \"LBDAT_TIMEOUT\" },\n\t{ 0x00001000, \"LBDAT_EXTRA\" },\n\t{ 0x00002000, \"GPFIFO\" },\n\t{ 0x00004000, \"GPPTR\" },\n\t{ 0x00008000, \"GPENTRY\" },\n\t{ 0x00010000, \"GPCRC\" },\n\t{ 0x00020000, \"PBPTR\" },\n\t{ 0x00040000, \"PBENTRY\" },\n\t{ 0x00080000, \"PBCRC\" },\n\t{ 0x00100000, \"XBARCONNECT\" },\n\t{ 0x00200000, \"METHOD\" },\n\t{ 0x00400000, \"METHODCRC\" },\n\t{ 0x00800000, \"DEVICE\" },\n\t{ 0x02000000, \"SEMAPHORE\" },\n\t{ 0x04000000, \"ACQUIRE\" },\n\t{ 0x08000000, \"PRI\" },\n\t{ 0x20000000, \"NO_CTXSW_SEG\" },\n\t{ 0x40000000, \"PBSEG\" },\n\t{ 0x80000000, \"SIGNATURE\" },\n\t{}\n};\n\nbool\ngk104_runq_intr(struct nvkm_runq *runq, struct nvkm_runl *null)\n{\n\tbool intr0 = gf100_runq_intr(runq, NULL);\n\tbool intr1 = gk104_runq_intr_1(runq);\n\n\treturn intr0 || intr1;\n}\n\nvoid\ngk104_runq_init(struct nvkm_runq *runq)\n{\n\tstruct nvkm_device *device = runq->fifo->engine.subdev.device;\n\n\tgf100_runq_init(runq);\n\n\tnvkm_wr32(device, 0x040148 + (runq->id * 0x2000), 0xffffffff);  \n\tnvkm_wr32(device, 0x04014c + (runq->id * 0x2000), 0xffffffff);  \n}\n\nstatic u32\ngk104_runq_runm(struct nvkm_runq *runq)\n{\n\treturn nvkm_rd32(runq->fifo->engine.subdev.device, 0x002390 + (runq->id * 0x04));\n}\n\nconst struct nvkm_runq_func\ngk104_runq = {\n\t.init = gk104_runq_init,\n\t.intr = gk104_runq_intr,\n\t.intr_0_names = gk104_runq_intr_0_names,\n\t.idle = gk104_runq_idle,\n};\n\nvoid\ngk104_runl_fault_clear(struct nvkm_runl *runl)\n{\n\tnvkm_wr32(runl->fifo->engine.subdev.device, 0x00262c, BIT(runl->id));\n}\n\nvoid\ngk104_runl_allow(struct nvkm_runl *runl, u32 engm)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, 0x002630, BIT(runl->id), 0x00000000);\n}\n\nvoid\ngk104_runl_block(struct nvkm_runl *runl, u32 engm)\n{\n\tnvkm_mask(runl->fifo->engine.subdev.device, 0x002630, BIT(runl->id), BIT(runl->id));\n}\n\nbool\ngk104_runl_pending(struct nvkm_runl *runl)\n{\n\tstruct nvkm_device *device = runl->fifo->engine.subdev.device;\n\n\treturn nvkm_rd32(device, 0x002284 + (runl->id * 0x08)) & 0x00100000;\n}\n\nvoid\ngk104_runl_commit(struct nvkm_runl *runl, struct nvkm_memory *memory, u32 start, int count)\n{\n\tstruct nvkm_fifo *fifo = runl->fifo;\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tu64 addr = nvkm_memory_addr(memory) + start;\n\tint target;\n\n\tswitch (nvkm_memory_target(memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: target = 0; break;\n\tcase NVKM_MEM_TARGET_NCOH: target = 3; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&fifo->lock);\n\tnvkm_wr32(device, 0x002270, (target << 28) | (addr >> 12));\n\tnvkm_wr32(device, 0x002274, (runl->id << 20) | count);\n\tspin_unlock_irq(&fifo->lock);\n}\n\nvoid\ngk104_runl_insert_chan(struct nvkm_chan *chan, struct nvkm_memory *memory, u64 offset)\n{\n\tnvkm_wo32(memory, offset + 0, chan->id);\n\tnvkm_wo32(memory, offset + 4, 0x00000000);\n}\n\nstatic const struct nvkm_runl_func\ngk104_runl = {\n\t.size = 8,\n\t.update = nv50_runl_update,\n\t.insert_chan = gk104_runl_insert_chan,\n\t.commit = gk104_runl_commit,\n\t.wait = nv50_runl_wait,\n\t.pending = gk104_runl_pending,\n\t.block = gk104_runl_block,\n\t.allow = gk104_runl_allow,\n\t.fault_clear = gk104_runl_fault_clear,\n\t.preempt_pending = gf100_runl_preempt_pending,\n};\n\nstatic const struct nvkm_enum\ngk104_fifo_mmu_fault_engine[] = {\n\t{ 0x00, \"GR\", NULL, NVKM_ENGINE_GR },\n\t{ 0x01, \"DISPLAY\" },\n\t{ 0x02, \"CAPTURE\" },\n\t{ 0x03, \"IFB\", NULL, NVKM_ENGINE_IFB },\n\t{ 0x04, \"BAR1\", NULL, NVKM_SUBDEV_BAR },\n\t{ 0x05, \"BAR2\", NULL, NVKM_SUBDEV_INSTMEM },\n\t{ 0x06, \"SCHED\" },\n\t{ 0x07, \"HOST0\" },\n\t{ 0x08, \"HOST1\" },\n\t{ 0x09, \"HOST2\" },\n\t{ 0x0a, \"HOST3\" },\n\t{ 0x0b, \"HOST4\" },\n\t{ 0x0c, \"HOST5\" },\n\t{ 0x0d, \"HOST6\" },\n\t{ 0x0e, \"HOST7\" },\n\t{ 0x0f, \"HOSTSR\" },\n\t{ 0x10, \"MSVLD\", NULL, NVKM_ENGINE_MSVLD },\n\t{ 0x11, \"MSPPP\", NULL, NVKM_ENGINE_MSPPP },\n\t{ 0x13, \"PERF\" },\n\t{ 0x14, \"MSPDEC\", NULL, NVKM_ENGINE_MSPDEC },\n\t{ 0x15, \"CE0\", NULL, NVKM_ENGINE_CE, 0 },\n\t{ 0x16, \"CE1\", NULL, NVKM_ENGINE_CE, 1 },\n\t{ 0x17, \"PMU\" },\n\t{ 0x18, \"PTP\" },\n\t{ 0x19, \"MSENC\", NULL, NVKM_ENGINE_MSENC },\n\t{ 0x1b, \"CE2\", NULL, NVKM_ENGINE_CE, 2 },\n\t{}\n};\n\nconst struct nvkm_enum\ngk104_fifo_mmu_fault_reason[] = {\n\t{ 0x00, \"PDE\" },\n\t{ 0x01, \"PDE_SIZE\" },\n\t{ 0x02, \"PTE\" },\n\t{ 0x03, \"VA_LIMIT_VIOLATION\" },\n\t{ 0x04, \"UNBOUND_INST_BLOCK\" },\n\t{ 0x05, \"PRIV_VIOLATION\" },\n\t{ 0x06, \"RO_VIOLATION\" },\n\t{ 0x07, \"WO_VIOLATION\" },\n\t{ 0x08, \"PITCH_MASK_VIOLATION\" },\n\t{ 0x09, \"WORK_CREATION\" },\n\t{ 0x0a, \"UNSUPPORTED_APERTURE\" },\n\t{ 0x0b, \"COMPRESSION_FAILURE\" },\n\t{ 0x0c, \"UNSUPPORTED_KIND\" },\n\t{ 0x0d, \"REGION_VIOLATION\" },\n\t{ 0x0e, \"BOTH_PTES_VALID\" },\n\t{ 0x0f, \"INFO_TYPE_POISONED\" },\n\t{}\n};\n\nconst struct nvkm_enum\ngk104_fifo_mmu_fault_hubclient[] = {\n\t{ 0x00, \"VIP\" },\n\t{ 0x01, \"CE0\" },\n\t{ 0x02, \"CE1\" },\n\t{ 0x03, \"DNISO\" },\n\t{ 0x04, \"FE\" },\n\t{ 0x05, \"FECS\" },\n\t{ 0x06, \"HOST\" },\n\t{ 0x07, \"HOST_CPU\" },\n\t{ 0x08, \"HOST_CPU_NB\" },\n\t{ 0x09, \"ISO\" },\n\t{ 0x0a, \"MMU\" },\n\t{ 0x0b, \"MSPDEC\" },\n\t{ 0x0c, \"MSPPP\" },\n\t{ 0x0d, \"MSVLD\" },\n\t{ 0x0e, \"NISO\" },\n\t{ 0x0f, \"P2P\" },\n\t{ 0x10, \"PD\" },\n\t{ 0x11, \"PERF\" },\n\t{ 0x12, \"PMU\" },\n\t{ 0x13, \"RASTERTWOD\" },\n\t{ 0x14, \"SCC\" },\n\t{ 0x15, \"SCC_NB\" },\n\t{ 0x16, \"SEC\" },\n\t{ 0x17, \"SSYNC\" },\n\t{ 0x18, \"GR_CE\" },\n\t{ 0x19, \"CE2\" },\n\t{ 0x1a, \"XV\" },\n\t{ 0x1b, \"MMU_NB\" },\n\t{ 0x1c, \"MSENC\" },\n\t{ 0x1d, \"DFALCON\" },\n\t{ 0x1e, \"SKED\" },\n\t{ 0x1f, \"AFALCON\" },\n\t{}\n};\n\nconst struct nvkm_enum\ngk104_fifo_mmu_fault_gpcclient[] = {\n\t{ 0x00, \"L1_0\" }, { 0x01, \"T1_0\" }, { 0x02, \"PE_0\" },\n\t{ 0x03, \"L1_1\" }, { 0x04, \"T1_1\" }, { 0x05, \"PE_1\" },\n\t{ 0x06, \"L1_2\" }, { 0x07, \"T1_2\" }, { 0x08, \"PE_2\" },\n\t{ 0x09, \"L1_3\" }, { 0x0a, \"T1_3\" }, { 0x0b, \"PE_3\" },\n\t{ 0x0c, \"RAST\" },\n\t{ 0x0d, \"GCC\" },\n\t{ 0x0e, \"GPCCS\" },\n\t{ 0x0f, \"PROP_0\" },\n\t{ 0x10, \"PROP_1\" },\n\t{ 0x11, \"PROP_2\" },\n\t{ 0x12, \"PROP_3\" },\n\t{ 0x13, \"L1_4\" }, { 0x14, \"T1_4\" }, { 0x15, \"PE_4\" },\n\t{ 0x16, \"L1_5\" }, { 0x17, \"T1_5\" }, { 0x18, \"PE_5\" },\n\t{ 0x19, \"L1_6\" }, { 0x1a, \"T1_6\" }, { 0x1b, \"PE_6\" },\n\t{ 0x1c, \"L1_7\" }, { 0x1d, \"T1_7\" }, { 0x1e, \"PE_7\" },\n\t{ 0x1f, \"GPM\" },\n\t{ 0x20, \"LTP_UTLB_0\" },\n\t{ 0x21, \"LTP_UTLB_1\" },\n\t{ 0x22, \"LTP_UTLB_2\" },\n\t{ 0x23, \"LTP_UTLB_3\" },\n\t{ 0x24, \"GPC_RGG_UTLB\" },\n\t{}\n};\n\nconst struct nvkm_fifo_func_mmu_fault\ngk104_fifo_mmu_fault = {\n\t.recover = gf100_fifo_mmu_fault_recover,\n\t.access = gf100_fifo_mmu_fault_access,\n\t.engine = gk104_fifo_mmu_fault_engine,\n\t.reason = gk104_fifo_mmu_fault_reason,\n\t.hubclient = gk104_fifo_mmu_fault_hubclient,\n\t.gpcclient = gk104_fifo_mmu_fault_gpcclient,\n};\n\nstatic const struct nvkm_enum\ngk104_fifo_intr_bind_reason[] = {\n\t{ 0x01, \"BIND_NOT_UNBOUND\" },\n\t{ 0x02, \"SNOOP_WITHOUT_BAR1\" },\n\t{ 0x03, \"UNBIND_WHILE_RUNNING\" },\n\t{ 0x05, \"INVALID_RUNLIST\" },\n\t{ 0x06, \"INVALID_CTX_TGT\" },\n\t{ 0x0b, \"UNBIND_WHILE_PARKED\" },\n\t{}\n};\n\nvoid\ngk104_fifo_intr_bind(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tu32 intr = nvkm_rd32(subdev->device, 0x00252c);\n\tu32 code = intr & 0x000000ff;\n\tconst struct nvkm_enum *en = nvkm_enum_find(gk104_fifo_intr_bind_reason, code);\n\n\tnvkm_error(subdev, \"BIND_ERROR %02x [%s]\\n\", code, en ? en->name : \"\");\n}\n\nvoid\ngk104_fifo_intr_chsw(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x00256c);\n\n\tnvkm_error(subdev, \"CHSW_ERROR %08x\\n\", stat);\n\tnvkm_wr32(device, 0x00256c, stat);\n}\n\nstatic void\ngk104_fifo_intr_dropped_fault(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tu32 stat = nvkm_rd32(subdev->device, 0x00259c);\n\n\tnvkm_error(subdev, \"DROPPED_MMU_FAULT %08x\\n\", stat);\n}\n\nvoid\ngk104_fifo_intr_runlist(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_runl *runl;\n\tu32 mask = nvkm_rd32(device, 0x002a00);\n\n\tnvkm_runl_foreach_cond(runl, fifo, mask & BIT(runl->id)) {\n\t\tnvkm_wr32(device, 0x002a00, BIT(runl->id));\n\t}\n}\n\nirqreturn_t\ngk104_fifo_intr(struct nvkm_inth *inth)\n{\n\tstruct nvkm_fifo *fifo = container_of(inth, typeof(*fifo), engine.subdev.inth);\n\tstruct nvkm_subdev *subdev = &fifo->engine.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mask = nvkm_rd32(device, 0x002140);\n\tu32 stat = nvkm_rd32(device, 0x002100) & mask;\n\n\tif (stat & 0x00000001) {\n\t\tgk104_fifo_intr_bind(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00000001);\n\t\tstat &= ~0x00000001;\n\t}\n\n\tif (stat & 0x00000010) {\n\t\tnvkm_error(subdev, \"PIO_ERROR\\n\");\n\t\tnvkm_wr32(device, 0x002100, 0x00000010);\n\t\tstat &= ~0x00000010;\n\t}\n\n\tif (stat & 0x00000100) {\n\t\tgf100_fifo_intr_sched(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00000100);\n\t\tstat &= ~0x00000100;\n\t}\n\n\tif (stat & 0x00010000) {\n\t\tgk104_fifo_intr_chsw(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x00010000);\n\t\tstat &= ~0x00010000;\n\t}\n\n\tif (stat & 0x00800000) {\n\t\tnvkm_error(subdev, \"FB_FLUSH_TIMEOUT\\n\");\n\t\tnvkm_wr32(device, 0x002100, 0x00800000);\n\t\tstat &= ~0x00800000;\n\t}\n\n\tif (stat & 0x01000000) {\n\t\tnvkm_error(subdev, \"LB_ERROR\\n\");\n\t\tnvkm_wr32(device, 0x002100, 0x01000000);\n\t\tstat &= ~0x01000000;\n\t}\n\n\tif (stat & 0x08000000) {\n\t\tgk104_fifo_intr_dropped_fault(fifo);\n\t\tnvkm_wr32(device, 0x002100, 0x08000000);\n\t\tstat &= ~0x08000000;\n\t}\n\n\tif (stat & 0x10000000) {\n\t\tgf100_fifo_intr_mmu_fault(fifo);\n\t\tstat &= ~0x10000000;\n\t}\n\n\tif (stat & 0x20000000) {\n\t\tif (gf100_fifo_intr_pbdma(fifo))\n\t\t\tstat &= ~0x20000000;\n\t}\n\n\tif (stat & 0x40000000) {\n\t\tgk104_fifo_intr_runlist(fifo);\n\t\tstat &= ~0x40000000;\n\t}\n\n\tif (stat & 0x80000000) {\n\t\tnvkm_wr32(device, 0x002100, 0x80000000);\n\t\tnvkm_event_ntfy(&fifo->nonstall.event, 0, NVKM_FIFO_NONSTALL_EVENT);\n\t\tstat &= ~0x80000000;\n\t}\n\n\tif (stat) {\n\t\tnvkm_error(subdev, \"INTR %08x\\n\", stat);\n\t\tspin_lock(&fifo->lock);\n\t\tnvkm_mask(device, 0x002140, stat, 0x00000000);\n\t\tspin_unlock(&fifo->lock);\n\t\tnvkm_wr32(device, 0x002100, stat);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nvoid\ngk104_fifo_init_pbdmas(struct nvkm_fifo *fifo, u32 mask)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\n\tnvkm_wr32(device, 0x000204, mask);\n\tnvkm_mask(device, 0x002a04, 0xbfffffff, 0xbfffffff);\n}\n\nvoid\ngk104_fifo_init(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\n\tif (fifo->func->chan.func->userd->bar == 1)\n\t\tnvkm_wr32(device, 0x002254, 0x10000000 | fifo->userd.bar1->addr >> 12);\n\n\tnvkm_wr32(device, 0x002100, 0xffffffff);\n\tnvkm_wr32(device, 0x002140, 0x7fffffff);\n}\n\nint\ngk104_fifo_runl_ctor(struct nvkm_fifo *fifo)\n{\n\tstruct nvkm_device *device = fifo->engine.subdev.device;\n\tstruct nvkm_top_device *tdev;\n\tstruct nvkm_runl *runl;\n\tstruct nvkm_runq *runq;\n\tconst struct nvkm_engn_func *func;\n\n\tnvkm_list_foreach(tdev, &device->top->device, head, tdev->runlist >= 0) {\n\t\trunl = nvkm_runl_get(fifo, tdev->runlist, tdev->runlist);\n\t\tif (!runl) {\n\t\t\trunl = nvkm_runl_new(fifo, tdev->runlist, tdev->runlist, 0);\n\t\t\tif (IS_ERR(runl))\n\t\t\t\treturn PTR_ERR(runl);\n\n\t\t\tnvkm_runq_foreach_cond(runq, fifo, gk104_runq_runm(runq) & BIT(runl->id)) {\n\t\t\t\tif (WARN_ON(runl->runq_nr == ARRAY_SIZE(runl->runq)))\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\trunl->runq[runl->runq_nr++] = runq;\n\t\t\t}\n\n\t\t}\n\n\t\tif (tdev->engine < 0)\n\t\t\tcontinue;\n\n\t\tswitch (tdev->type) {\n\t\tcase NVKM_ENGINE_CE:\n\t\t\tfunc = fifo->func->engn_ce;\n\t\t\tbreak;\n\t\tcase NVKM_ENGINE_GR:\n\t\t\tnvkm_runl_add(runl, 15, &gf100_engn_sw, NVKM_ENGINE_SW, 0);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tfunc = fifo->func->engn;\n\t\t\tbreak;\n\t\t}\n\n\t\tnvkm_runl_add(runl, tdev->engine, func, tdev->type, tdev->inst);\n\t}\n\n\treturn 0;\n}\n\nint\ngk104_fifo_chid_nr(struct nvkm_fifo *fifo)\n{\n\treturn 4096;\n}\n\nstatic const struct nvkm_fifo_func\ngk104_fifo = {\n\t.chid_nr = gk104_fifo_chid_nr,\n\t.chid_ctor = gf100_fifo_chid_ctor,\n\t.runq_nr = gf100_fifo_runq_nr,\n\t.runl_ctor = gk104_fifo_runl_ctor,\n\t.init = gk104_fifo_init,\n\t.init_pbdmas = gk104_fifo_init_pbdmas,\n\t.intr = gk104_fifo_intr,\n\t.intr_mmu_fault_unit = gf100_fifo_intr_mmu_fault_unit,\n\t.intr_ctxsw_timeout = gf100_fifo_intr_ctxsw_timeout,\n\t.mmu_fault = &gk104_fifo_mmu_fault,\n\t.nonstall = &gf100_fifo_nonstall,\n\t.runl = &gk104_runl,\n\t.runq = &gk104_runq,\n\t.engn = &gk104_engn,\n\t.engn_ce = &gk104_engn_ce,\n\t.cgrp = {{                               }, &nv04_cgrp },\n\t.chan = {{ 0, 0, KEPLER_CHANNEL_GPFIFO_A }, &gk104_chan },\n};\n\nint\ngk104_fifo_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_fifo **pfifo)\n{\n\treturn nvkm_fifo_new_(&gk104_fifo, device, type, inst, pfifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}