{
  "module_name": "gf100.c",
  "hash_id": "21a04ce935dc6e8b1de4589c823afd788072a56db82a26a7ca57d321ad5e09d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/engine/pm/gf100.c",
  "human_readable_source": " \n#include \"gf100.h\"\n\nconst struct nvkm_specsrc\ngf100_pbfb_sources[] = {\n\t{ 0x10f100, (const struct nvkm_specmux[]) {\n\t\t\t{ 0x1, 0, \"unk0\" },\n\t\t\t{ 0x3f, 4, \"unk4\" },\n\t\t\t{}\n\t\t}, \"pbfb_broadcast_pm_unk100\" },\n\t{}\n};\n\nconst struct nvkm_specsrc\ngf100_pmfb_sources[] = {\n\t{ 0x140028, (const struct nvkm_specmux[]) {\n\t\t\t{ 0x3fff, 0, \"unk0\" },\n\t\t\t{ 0x7, 16, \"unk16\" },\n\t\t\t{ 0x3, 24, \"unk24\" },\n\t\t\t{ 0x2, 29, \"unk29\" },\n\t\t\t{}\n\t\t}, \"pmfb0_pm_unk28\" },\n\t{}\n};\n\nstatic const struct nvkm_specsrc\ngf100_l1_sources[] = {\n\t{ 0x5044a8, (const struct nvkm_specmux[]) {\n\t\t\t{ 0x3f, 0, \"sel\", true },\n\t\t\t{}\n\t\t}, \"pgraph_gpc0_tpc0_l1_pm_mux\" },\n\t{}\n};\n\nstatic const struct nvkm_specsrc\ngf100_tex_sources[] = {\n\t{ 0x5042c0, (const struct nvkm_specmux[]) {\n\t\t\t{ 0xf, 0, \"sel0\", true },\n\t\t\t{ 0x7, 8, \"sel1\", true },\n\t\t\t{}\n\t\t}, \"pgraph_gpc0_tpc0_tex_pm_mux_c_d\" },\n\t{}\n};\n\nstatic const struct nvkm_specsrc\ngf100_unk400_sources[] = {\n\t{ 0x50440c, (const struct nvkm_specmux[]) {\n\t\t\t{ 0x3f, 0, \"sel\", true },\n\t\t\t{}\n\t\t}, \"pgraph_gpc0_tpc0_unk400_pm_mux\" },\n\t{}\n};\n\nstatic const struct nvkm_specdom\ngf100_pm_hub[] = {\n\t{}\n};\n\nconst struct nvkm_specdom\ngf100_pm_gpc[] = {\n\t{ 0xe0, (const struct nvkm_specsig[]) {\n\t\t\t{ 0x00, \"gpc00_l1_00\", gf100_l1_sources },\n\t\t\t{ 0x01, \"gpc00_l1_01\", gf100_l1_sources },\n\t\t\t{ 0x02, \"gpc00_l1_02\", gf100_l1_sources },\n\t\t\t{ 0x03, \"gpc00_l1_03\", gf100_l1_sources },\n\t\t\t{ 0x05, \"gpc00_l1_04\", gf100_l1_sources },\n\t\t\t{ 0x06, \"gpc00_l1_05\", gf100_l1_sources },\n\t\t\t{ 0x0a, \"gpc00_tex_00\", gf100_tex_sources },\n\t\t\t{ 0x0b, \"gpc00_tex_01\", gf100_tex_sources },\n\t\t\t{ 0x0c, \"gpc00_tex_02\", gf100_tex_sources },\n\t\t\t{ 0x0d, \"gpc00_tex_03\", gf100_tex_sources },\n\t\t\t{ 0x0e, \"gpc00_tex_04\", gf100_tex_sources },\n\t\t\t{ 0x0f, \"gpc00_tex_05\", gf100_tex_sources },\n\t\t\t{ 0x10, \"gpc00_tex_06\", gf100_tex_sources },\n\t\t\t{ 0x11, \"gpc00_tex_07\", gf100_tex_sources },\n\t\t\t{ 0x12, \"gpc00_tex_08\", gf100_tex_sources },\n\t\t\t{ 0x26, \"gpc00_unk400_00\", gf100_unk400_sources },\n\t\t\t{}\n\t\t}, &gf100_perfctr_func },\n\t{}\n};\n\nstatic const struct nvkm_specdom\ngf100_pm_part[] = {\n\t{ 0xe0, (const struct nvkm_specsig[]) {\n\t\t\t{ 0x0f, \"part00_pbfb_00\", gf100_pbfb_sources },\n\t\t\t{ 0x10, \"part00_pbfb_01\", gf100_pbfb_sources },\n\t\t\t{ 0x21, \"part00_pmfb_00\", gf100_pmfb_sources },\n\t\t\t{ 0x04, \"part00_pmfb_01\", gf100_pmfb_sources },\n\t\t\t{ 0x00, \"part00_pmfb_02\", gf100_pmfb_sources },\n\t\t\t{ 0x02, \"part00_pmfb_03\", gf100_pmfb_sources },\n\t\t\t{ 0x01, \"part00_pmfb_04\", gf100_pmfb_sources },\n\t\t\t{ 0x2e, \"part00_pmfb_05\", gf100_pmfb_sources },\n\t\t\t{ 0x2f, \"part00_pmfb_06\", gf100_pmfb_sources },\n\t\t\t{ 0x1b, \"part00_pmfb_07\", gf100_pmfb_sources },\n\t\t\t{ 0x1c, \"part00_pmfb_08\", gf100_pmfb_sources },\n\t\t\t{ 0x1d, \"part00_pmfb_09\", gf100_pmfb_sources },\n\t\t\t{ 0x1e, \"part00_pmfb_0a\", gf100_pmfb_sources },\n\t\t\t{ 0x1f, \"part00_pmfb_0b\", gf100_pmfb_sources },\n\t\t\t{}\n\t\t}, &gf100_perfctr_func },\n\t{}\n};\n\nstatic void\ngf100_perfctr_init(struct nvkm_pm *pm, struct nvkm_perfdom *dom,\n\t\t   struct nvkm_perfctr *ctr)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\tu32 log = ctr->logic_op;\n\tu32 src = 0x00000000;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tsrc |= ctr->signal[i] << (i * 8);\n\n\tnvkm_wr32(device, dom->addr + 0x09c, 0x00040002 | (dom->mode << 3));\n\tnvkm_wr32(device, dom->addr + 0x100, 0x00000000);\n\tnvkm_wr32(device, dom->addr + 0x040 + (ctr->slot * 0x08), src);\n\tnvkm_wr32(device, dom->addr + 0x044 + (ctr->slot * 0x08), log);\n}\n\nstatic void\ngf100_perfctr_read(struct nvkm_pm *pm, struct nvkm_perfdom *dom,\n\t\t   struct nvkm_perfctr *ctr)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\n\tswitch (ctr->slot) {\n\tcase 0: ctr->ctr = nvkm_rd32(device, dom->addr + 0x08c); break;\n\tcase 1: ctr->ctr = nvkm_rd32(device, dom->addr + 0x088); break;\n\tcase 2: ctr->ctr = nvkm_rd32(device, dom->addr + 0x080); break;\n\tcase 3: ctr->ctr = nvkm_rd32(device, dom->addr + 0x090); break;\n\t}\n\tdom->clk = nvkm_rd32(device, dom->addr + 0x070);\n}\n\nstatic void\ngf100_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\tnvkm_wr32(device, dom->addr + 0x06c, dom->signal_nr - 0x40 + 0x27);\n\tnvkm_wr32(device, dom->addr + 0x0ec, 0x00000011);\n}\n\nconst struct nvkm_funcdom\ngf100_perfctr_func = {\n\t.init = gf100_perfctr_init,\n\t.read = gf100_perfctr_read,\n\t.next = gf100_perfctr_next,\n};\n\nstatic void\ngf100_pm_fini(struct nvkm_pm *pm)\n{\n\tstruct nvkm_device *device = pm->engine.subdev.device;\n\tnvkm_mask(device, 0x000200, 0x10000000, 0x00000000);\n\tnvkm_mask(device, 0x000200, 0x10000000, 0x10000000);\n}\n\nstatic const struct nvkm_pm_func\ngf100_pm_ = {\n\t.fini = gf100_pm_fini,\n};\n\nint\ngf100_pm_new_(const struct gf100_pm_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_pm **ppm)\n{\n\tstruct nvkm_pm *pm;\n\tu32 mask;\n\tint ret;\n\n\tif (!(pm = *ppm = kzalloc(sizeof(*pm), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tret = nvkm_pm_ctor(&gf100_pm_, device, type, inst, pm);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = nvkm_perfdom_new(pm, \"hub\", 0, 0x1b0000, 0, 0x200,\n\t\t\t       func->doms_hub);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask  = (1 << nvkm_rd32(device, 0x022430)) - 1;\n\tmask &= ~nvkm_rd32(device, 0x022504);\n\tmask &= ~nvkm_rd32(device, 0x022584);\n\n\tret = nvkm_perfdom_new(pm, \"gpc\", mask, 0x180000,\n\t\t\t       0x1000, 0x200, func->doms_gpc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask  = (1 << nvkm_rd32(device, 0x022438)) - 1;\n\tmask &= ~nvkm_rd32(device, 0x022548);\n\tmask &= ~nvkm_rd32(device, 0x0225c8);\n\n\tret = nvkm_perfdom_new(pm, \"part\", mask, 0x1a0000,\n\t\t\t       0x1000, 0x200, func->doms_part);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct gf100_pm_func\ngf100_pm = {\n\t.doms_gpc = gf100_pm_gpc,\n\t.doms_hub = gf100_pm_hub,\n\t.doms_part = gf100_pm_part,\n};\n\nint\ngf100_pm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_pm **ppm)\n{\n\treturn gf100_pm_new_(&gf100_pm, device, type, inst, ppm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}