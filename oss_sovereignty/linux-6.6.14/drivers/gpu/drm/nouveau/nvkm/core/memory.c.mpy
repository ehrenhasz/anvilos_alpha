{
  "module_name": "memory.c",
  "hash_id": "3be890e898cda0d2501fb7abaa343616c6b8e55c6e6361a1da7765dd84d0e355",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/memory.c",
  "human_readable_source": " \n#include <core/memory.h>\n#include <core/mm.h>\n#include <subdev/fb.h>\n#include <subdev/instmem.h>\n\nvoid\nnvkm_memory_tags_put(struct nvkm_memory *memory, struct nvkm_device *device,\n\t\t     struct nvkm_tags **ptags)\n{\n\tstruct nvkm_fb *fb = device->fb;\n\tstruct nvkm_tags *tags = *ptags;\n\tif (tags) {\n\t\tmutex_lock(&fb->tags.mutex);\n\t\tif (refcount_dec_and_test(&tags->refcount)) {\n\t\t\tnvkm_mm_free(&fb->tags.mm, &tags->mn);\n\t\t\tkfree(memory->tags);\n\t\t\tmemory->tags = NULL;\n\t\t}\n\t\tmutex_unlock(&fb->tags.mutex);\n\t\t*ptags = NULL;\n\t}\n}\n\nint\nnvkm_memory_tags_get(struct nvkm_memory *memory, struct nvkm_device *device,\n\t\t     u32 nr, void (*clr)(struct nvkm_device *, u32, u32),\n\t\t     struct nvkm_tags **ptags)\n{\n\tstruct nvkm_fb *fb = device->fb;\n\tstruct nvkm_tags *tags;\n\n\tmutex_lock(&fb->tags.mutex);\n\tif ((tags = memory->tags)) {\n\t\t \n\t\tif (tags->mn && tags->mn->length != nr) {\n\t\t\tmutex_unlock(&fb->tags.mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trefcount_inc(&tags->refcount);\n\t\tmutex_unlock(&fb->tags.mutex);\n\t\t*ptags = tags;\n\t\treturn 0;\n\t}\n\n\tif (!(tags = kmalloc(sizeof(*tags), GFP_KERNEL))) {\n\t\tmutex_unlock(&fb->tags.mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!nvkm_mm_head(&fb->tags.mm, 0, 1, nr, nr, 1, &tags->mn)) {\n\t\tif (clr)\n\t\t\tclr(device, tags->mn->offset, tags->mn->length);\n\t} else {\n\t\t \n\t\ttags->mn = NULL;\n\t}\n\n\trefcount_set(&tags->refcount, 1);\n\t*ptags = memory->tags = tags;\n\tmutex_unlock(&fb->tags.mutex);\n\treturn 0;\n}\n\nvoid\nnvkm_memory_ctor(const struct nvkm_memory_func *func,\n\t\t struct nvkm_memory *memory)\n{\n\tmemory->func = func;\n\tkref_init(&memory->kref);\n}\n\nstatic void\nnvkm_memory_del(struct kref *kref)\n{\n\tstruct nvkm_memory *memory = container_of(kref, typeof(*memory), kref);\n\tif (!WARN_ON(!memory->func)) {\n\t\tif (memory->func->dtor)\n\t\t\tmemory = memory->func->dtor(memory);\n\t\tkfree(memory);\n\t}\n}\n\nvoid\nnvkm_memory_unref(struct nvkm_memory **pmemory)\n{\n\tstruct nvkm_memory *memory = *pmemory;\n\tif (memory) {\n\t\tkref_put(&memory->kref, nvkm_memory_del);\n\t\t*pmemory = NULL;\n\t}\n}\n\nstruct nvkm_memory *\nnvkm_memory_ref(struct nvkm_memory *memory)\n{\n\tif (memory)\n\t\tkref_get(&memory->kref);\n\treturn memory;\n}\n\nint\nnvkm_memory_new(struct nvkm_device *device, enum nvkm_memory_target target,\n\t\tu64 size, u32 align, bool zero,\n\t\tstruct nvkm_memory **pmemory)\n{\n\tstruct nvkm_instmem *imem = device->imem;\n\tstruct nvkm_memory *memory;\n\tint ret;\n\n\tif (unlikely(target != NVKM_MEM_TARGET_INST || !imem))\n\t\treturn -ENOSYS;\n\n\tret = nvkm_instobj_new(imem, size, align, zero, &memory);\n\tif (ret)\n\t\treturn ret;\n\n\t*pmemory = memory;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}