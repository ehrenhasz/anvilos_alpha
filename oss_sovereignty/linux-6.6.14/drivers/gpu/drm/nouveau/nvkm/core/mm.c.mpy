{
  "module_name": "mm.c",
  "hash_id": "570782b1e24c1b45af6808913d6979fe454d3f9ba948a2beb1f8d4e7cc82b81f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/mm.c",
  "human_readable_source": " \n#include <core/mm.h>\n\n#define node(root, dir) ((root)->nl_entry.dir == &mm->nodes) ? NULL :          \\\n\tlist_entry((root)->nl_entry.dir, struct nvkm_mm_node, nl_entry)\n\nvoid\nnvkm_mm_dump(struct nvkm_mm *mm, const char *header)\n{\n\tstruct nvkm_mm_node *node;\n\n\tpr_err(\"nvkm: %s\\n\", header);\n\tpr_err(\"nvkm: node list:\\n\");\n\tlist_for_each_entry(node, &mm->nodes, nl_entry) {\n\t\tpr_err(\"nvkm: \\t%08x %08x %d\\n\",\n\t\t       node->offset, node->length, node->type);\n\t}\n\tpr_err(\"nvkm: free list:\\n\");\n\tlist_for_each_entry(node, &mm->free, fl_entry) {\n\t\tpr_err(\"nvkm: \\t%08x %08x %d\\n\",\n\t\t       node->offset, node->length, node->type);\n\t}\n}\n\nvoid\nnvkm_mm_free(struct nvkm_mm *mm, struct nvkm_mm_node **pthis)\n{\n\tstruct nvkm_mm_node *this = *pthis;\n\n\tif (this) {\n\t\tstruct nvkm_mm_node *prev = node(this, prev);\n\t\tstruct nvkm_mm_node *next = node(this, next);\n\n\t\tif (prev && prev->type == NVKM_MM_TYPE_NONE) {\n\t\t\tprev->length += this->length;\n\t\t\tlist_del(&this->nl_entry);\n\t\t\tkfree(this); this = prev;\n\t\t}\n\n\t\tif (next && next->type == NVKM_MM_TYPE_NONE) {\n\t\t\tnext->offset  = this->offset;\n\t\t\tnext->length += this->length;\n\t\t\tif (this->type == NVKM_MM_TYPE_NONE)\n\t\t\t\tlist_del(&this->fl_entry);\n\t\t\tlist_del(&this->nl_entry);\n\t\t\tkfree(this); this = NULL;\n\t\t}\n\n\t\tif (this && this->type != NVKM_MM_TYPE_NONE) {\n\t\t\tlist_for_each_entry(prev, &mm->free, fl_entry) {\n\t\t\t\tif (this->offset < prev->offset)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlist_add_tail(&this->fl_entry, &prev->fl_entry);\n\t\t\tthis->type = NVKM_MM_TYPE_NONE;\n\t\t}\n\t}\n\n\t*pthis = NULL;\n}\n\nstatic struct nvkm_mm_node *\nregion_head(struct nvkm_mm *mm, struct nvkm_mm_node *a, u32 size)\n{\n\tstruct nvkm_mm_node *b;\n\n\tif (a->length == size)\n\t\treturn a;\n\n\tb = kmalloc(sizeof(*b), GFP_KERNEL);\n\tif (unlikely(b == NULL))\n\t\treturn NULL;\n\n\tb->offset = a->offset;\n\tb->length = size;\n\tb->heap   = a->heap;\n\tb->type   = a->type;\n\ta->offset += size;\n\ta->length -= size;\n\tlist_add_tail(&b->nl_entry, &a->nl_entry);\n\tif (b->type == NVKM_MM_TYPE_NONE)\n\t\tlist_add_tail(&b->fl_entry, &a->fl_entry);\n\n\treturn b;\n}\n\nint\nnvkm_mm_head(struct nvkm_mm *mm, u8 heap, u8 type, u32 size_max, u32 size_min,\n\t     u32 align, struct nvkm_mm_node **pnode)\n{\n\tstruct nvkm_mm_node *prev, *this, *next;\n\tu32 mask = align - 1;\n\tu32 splitoff;\n\tu32 s, e;\n\n\tBUG_ON(type == NVKM_MM_TYPE_NONE || type == NVKM_MM_TYPE_HOLE);\n\n\tlist_for_each_entry(this, &mm->free, fl_entry) {\n\t\tif (unlikely(heap != NVKM_MM_HEAP_ANY)) {\n\t\t\tif (this->heap != heap)\n\t\t\t\tcontinue;\n\t\t}\n\t\te = this->offset + this->length;\n\t\ts = this->offset;\n\n\t\tprev = node(this, prev);\n\t\tif (prev && prev->type != type)\n\t\t\ts = roundup(s, mm->block_size);\n\n\t\tnext = node(this, next);\n\t\tif (next && next->type != type)\n\t\t\te = rounddown(e, mm->block_size);\n\n\t\ts  = (s + mask) & ~mask;\n\t\te &= ~mask;\n\t\tif (s > e || e - s < size_min)\n\t\t\tcontinue;\n\n\t\tsplitoff = s - this->offset;\n\t\tif (splitoff && !region_head(mm, this, splitoff))\n\t\t\treturn -ENOMEM;\n\n\t\tthis = region_head(mm, this, min(size_max, e - s));\n\t\tif (!this)\n\t\t\treturn -ENOMEM;\n\n\t\tthis->next = NULL;\n\t\tthis->type = type;\n\t\tlist_del(&this->fl_entry);\n\t\t*pnode = this;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic struct nvkm_mm_node *\nregion_tail(struct nvkm_mm *mm, struct nvkm_mm_node *a, u32 size)\n{\n\tstruct nvkm_mm_node *b;\n\n\tif (a->length == size)\n\t\treturn a;\n\n\tb = kmalloc(sizeof(*b), GFP_KERNEL);\n\tif (unlikely(b == NULL))\n\t\treturn NULL;\n\n\ta->length -= size;\n\tb->offset  = a->offset + a->length;\n\tb->length  = size;\n\tb->heap    = a->heap;\n\tb->type    = a->type;\n\n\tlist_add(&b->nl_entry, &a->nl_entry);\n\tif (b->type == NVKM_MM_TYPE_NONE)\n\t\tlist_add(&b->fl_entry, &a->fl_entry);\n\n\treturn b;\n}\n\nint\nnvkm_mm_tail(struct nvkm_mm *mm, u8 heap, u8 type, u32 size_max, u32 size_min,\n\t     u32 align, struct nvkm_mm_node **pnode)\n{\n\tstruct nvkm_mm_node *prev, *this, *next;\n\tu32 mask = align - 1;\n\n\tBUG_ON(type == NVKM_MM_TYPE_NONE || type == NVKM_MM_TYPE_HOLE);\n\n\tlist_for_each_entry_reverse(this, &mm->free, fl_entry) {\n\t\tu32 e = this->offset + this->length;\n\t\tu32 s = this->offset;\n\t\tu32 c = 0, a;\n\t\tif (unlikely(heap != NVKM_MM_HEAP_ANY)) {\n\t\t\tif (this->heap != heap)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tprev = node(this, prev);\n\t\tif (prev && prev->type != type)\n\t\t\ts = roundup(s, mm->block_size);\n\n\t\tnext = node(this, next);\n\t\tif (next && next->type != type) {\n\t\t\te = rounddown(e, mm->block_size);\n\t\t\tc = next->offset - e;\n\t\t}\n\n\t\ts = (s + mask) & ~mask;\n\t\ta = e - s;\n\t\tif (s > e || a < size_min)\n\t\t\tcontinue;\n\n\t\ta  = min(a, size_max);\n\t\ts  = (e - a) & ~mask;\n\t\tc += (e - s) - a;\n\n\t\tif (c && !region_tail(mm, this, c))\n\t\t\treturn -ENOMEM;\n\n\t\tthis = region_tail(mm, this, a);\n\t\tif (!this)\n\t\t\treturn -ENOMEM;\n\n\t\tthis->next = NULL;\n\t\tthis->type = type;\n\t\tlist_del(&this->fl_entry);\n\t\t*pnode = this;\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\n\nint\nnvkm_mm_init(struct nvkm_mm *mm, u8 heap, u32 offset, u32 length, u32 block)\n{\n\tstruct nvkm_mm_node *node, *prev;\n\tu32 next;\n\n\tif (nvkm_mm_initialised(mm)) {\n\t\tprev = list_last_entry(&mm->nodes, typeof(*node), nl_entry);\n\t\tnext = prev->offset + prev->length;\n\t\tif (next != offset) {\n\t\t\tBUG_ON(next > offset);\n\t\t\tif (!(node = kzalloc(sizeof(*node), GFP_KERNEL)))\n\t\t\t\treturn -ENOMEM;\n\t\t\tnode->type   = NVKM_MM_TYPE_HOLE;\n\t\t\tnode->offset = next;\n\t\t\tnode->length = offset - next;\n\t\t\tlist_add_tail(&node->nl_entry, &mm->nodes);\n\t\t}\n\t\tBUG_ON(block != mm->block_size);\n\t} else {\n\t\tINIT_LIST_HEAD(&mm->nodes);\n\t\tINIT_LIST_HEAD(&mm->free);\n\t\tmm->block_size = block;\n\t\tmm->heap_nodes = 0;\n\t}\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tif (length) {\n\t\tnode->offset  = roundup(offset, mm->block_size);\n\t\tnode->length  = rounddown(offset + length, mm->block_size);\n\t\tnode->length -= node->offset;\n\t}\n\n\tlist_add_tail(&node->nl_entry, &mm->nodes);\n\tlist_add_tail(&node->fl_entry, &mm->free);\n\tnode->heap = heap;\n\tmm->heap_nodes++;\n\treturn 0;\n}\n\nint\nnvkm_mm_fini(struct nvkm_mm *mm)\n{\n\tstruct nvkm_mm_node *node, *temp;\n\tint nodes = 0;\n\n\tif (!nvkm_mm_initialised(mm))\n\t\treturn 0;\n\n\tlist_for_each_entry(node, &mm->nodes, nl_entry) {\n\t\tif (node->type != NVKM_MM_TYPE_HOLE) {\n\t\t\tif (++nodes > mm->heap_nodes) {\n\t\t\t\tnvkm_mm_dump(mm, \"mm not clean!\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(node, temp, &mm->nodes, nl_entry) {\n\t\tlist_del(&node->nl_entry);\n\t\tkfree(node);\n\t}\n\n\tmm->heap_nodes = 0;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}