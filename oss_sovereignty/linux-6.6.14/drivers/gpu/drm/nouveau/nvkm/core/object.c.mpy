{
  "module_name": "object.c",
  "hash_id": "c7a32d0793ca0b0703b1b00b5c2a410b50c6a05a8595cd856549583c2969eea4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/object.c",
  "human_readable_source": " \n#include <core/object.h>\n#include <core/client.h>\n#include <core/engine.h>\n\nstruct nvkm_object *\nnvkm_object_search(struct nvkm_client *client, u64 handle,\n\t\t   const struct nvkm_object_func *func)\n{\n\tstruct nvkm_object *object;\n\n\tif (handle) {\n\t\tstruct rb_node *node = client->objroot.rb_node;\n\t\twhile (node) {\n\t\t\tobject = rb_entry(node, typeof(*object), node);\n\t\t\tif (handle < object->object)\n\t\t\t\tnode = node->rb_left;\n\t\t\telse\n\t\t\tif (handle > object->object)\n\t\t\t\tnode = node->rb_right;\n\t\t\telse\n\t\t\t\tgoto done;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t} else {\n\t\tobject = &client->object;\n\t}\n\ndone:\n\tif (unlikely(func && object->func != func))\n\t\treturn ERR_PTR(-EINVAL);\n\treturn object;\n}\n\nvoid\nnvkm_object_remove(struct nvkm_object *object)\n{\n\tif (!RB_EMPTY_NODE(&object->node))\n\t\trb_erase(&object->node, &object->client->objroot);\n}\n\nbool\nnvkm_object_insert(struct nvkm_object *object)\n{\n\tstruct rb_node **ptr = &object->client->objroot.rb_node;\n\tstruct rb_node *parent = NULL;\n\n\twhile (*ptr) {\n\t\tstruct nvkm_object *this = rb_entry(*ptr, typeof(*this), node);\n\t\tparent = *ptr;\n\t\tif (object->object < this->object)\n\t\t\tptr = &parent->rb_left;\n\t\telse\n\t\tif (object->object > this->object)\n\t\t\tptr = &parent->rb_right;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\trb_link_node(&object->node, parent, ptr);\n\trb_insert_color(&object->node, &object->client->objroot);\n\treturn true;\n}\n\nint\nnvkm_object_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tif (likely(object->func->mthd))\n\t\treturn object->func->mthd(object, mthd, data, size);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_ntfy(struct nvkm_object *object, u32 mthd,\n\t\t struct nvkm_event **pevent)\n{\n\tif (likely(object->func->ntfy))\n\t\treturn object->func->ntfy(object, mthd, pevent);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_map(struct nvkm_object *object, void *argv, u32 argc,\n\t\tenum nvkm_object_map *type, u64 *addr, u64 *size)\n{\n\tif (likely(object->func->map))\n\t\treturn object->func->map(object, argv, argc, type, addr, size);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_unmap(struct nvkm_object *object)\n{\n\tif (likely(object->func->unmap))\n\t\treturn object->func->unmap(object);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_rd08(struct nvkm_object *object, u64 addr, u8 *data)\n{\n\tif (likely(object->func->rd08))\n\t\treturn object->func->rd08(object, addr, data);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_rd16(struct nvkm_object *object, u64 addr, u16 *data)\n{\n\tif (likely(object->func->rd16))\n\t\treturn object->func->rd16(object, addr, data);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_rd32(struct nvkm_object *object, u64 addr, u32 *data)\n{\n\tif (likely(object->func->rd32))\n\t\treturn object->func->rd32(object, addr, data);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_wr08(struct nvkm_object *object, u64 addr, u8 data)\n{\n\tif (likely(object->func->wr08))\n\t\treturn object->func->wr08(object, addr, data);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_wr16(struct nvkm_object *object, u64 addr, u16 data)\n{\n\tif (likely(object->func->wr16))\n\t\treturn object->func->wr16(object, addr, data);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_wr32(struct nvkm_object *object, u64 addr, u32 data)\n{\n\tif (likely(object->func->wr32))\n\t\treturn object->func->wr32(object, addr, data);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_bind(struct nvkm_object *object, struct nvkm_gpuobj *gpuobj,\n\t\t int align, struct nvkm_gpuobj **pgpuobj)\n{\n\tif (object->func->bind)\n\t\treturn object->func->bind(object, gpuobj, align, pgpuobj);\n\treturn -ENODEV;\n}\n\nint\nnvkm_object_fini(struct nvkm_object *object, bool suspend)\n{\n\tconst char *action = suspend ? \"suspend\" : \"fini\";\n\tstruct nvkm_object *child;\n\ts64 time;\n\tint ret;\n\n\tnvif_debug(object, \"%s children...\\n\", action);\n\ttime = ktime_to_us(ktime_get());\n\tlist_for_each_entry_reverse(child, &object->tree, head) {\n\t\tret = nvkm_object_fini(child, suspend);\n\t\tif (ret && suspend)\n\t\t\tgoto fail_child;\n\t}\n\n\tnvif_debug(object, \"%s running...\\n\", action);\n\tif (object->func->fini) {\n\t\tret = object->func->fini(object, suspend);\n\t\tif (ret) {\n\t\t\tnvif_error(object, \"%s failed with %d\\n\", action, ret);\n\t\t\tif (suspend)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvif_debug(object, \"%s completed in %lldus\\n\", action, time);\n\treturn 0;\n\nfail:\n\tif (object->func->init) {\n\t\tint rret = object->func->init(object);\n\t\tif (rret)\n\t\t\tnvif_fatal(object, \"failed to restart, %d\\n\", rret);\n\t}\nfail_child:\n\tlist_for_each_entry_continue_reverse(child, &object->tree, head) {\n\t\tnvkm_object_init(child);\n\t}\n\treturn ret;\n}\n\nint\nnvkm_object_init(struct nvkm_object *object)\n{\n\tstruct nvkm_object *child;\n\ts64 time;\n\tint ret;\n\n\tnvif_debug(object, \"init running...\\n\");\n\ttime = ktime_to_us(ktime_get());\n\tif (object->func->init) {\n\t\tret = object->func->init(object);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tnvif_debug(object, \"init children...\\n\");\n\tlist_for_each_entry(child, &object->tree, head) {\n\t\tret = nvkm_object_init(child);\n\t\tif (ret)\n\t\t\tgoto fail_child;\n\t}\n\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvif_debug(object, \"init completed in %lldus\\n\", time);\n\treturn 0;\n\nfail_child:\n\tlist_for_each_entry_continue_reverse(child, &object->tree, head)\n\t\tnvkm_object_fini(child, false);\nfail:\n\tnvif_error(object, \"init failed with %d\\n\", ret);\n\tif (object->func->fini)\n\t\tobject->func->fini(object, false);\n\treturn ret;\n}\n\nvoid *\nnvkm_object_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_object *child, *ctemp;\n\tvoid *data = object;\n\ts64 time;\n\n\tnvif_debug(object, \"destroy children...\\n\");\n\ttime = ktime_to_us(ktime_get());\n\tlist_for_each_entry_safe(child, ctemp, &object->tree, head) {\n\t\tnvkm_object_del(&child);\n\t}\n\n\tnvif_debug(object, \"destroy running...\\n\");\n\tnvkm_object_unmap(object);\n\tif (object->func->dtor)\n\t\tdata = object->func->dtor(object);\n\tnvkm_engine_unref(&object->engine);\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvif_debug(object, \"destroy completed in %lldus...\\n\", time);\n\treturn data;\n}\n\nvoid\nnvkm_object_del(struct nvkm_object **pobject)\n{\n\tstruct nvkm_object *object = *pobject;\n\tif (object && !WARN_ON(!object->func)) {\n\t\t*pobject = nvkm_object_dtor(object);\n\t\tnvkm_object_remove(object);\n\t\tlist_del(&object->head);\n\t\tkfree(*pobject);\n\t\t*pobject = NULL;\n\t}\n}\n\nvoid\nnvkm_object_ctor(const struct nvkm_object_func *func,\n\t\t const struct nvkm_oclass *oclass, struct nvkm_object *object)\n{\n\tobject->func = func;\n\tobject->client = oclass->client;\n\tobject->engine = nvkm_engine_ref(oclass->engine);\n\tobject->oclass = oclass->base.oclass;\n\tobject->handle = oclass->handle;\n\tobject->route  = oclass->route;\n\tobject->token  = oclass->token;\n\tobject->object = oclass->object;\n\tINIT_LIST_HEAD(&object->head);\n\tINIT_LIST_HEAD(&object->tree);\n\tRB_CLEAR_NODE(&object->node);\n\tWARN_ON(IS_ERR(object->engine));\n}\n\nint\nnvkm_object_new_(const struct nvkm_object_func *func,\n\t\t const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\t struct nvkm_object **pobject)\n{\n\tif (size == 0) {\n\t\tif (!(*pobject = kzalloc(sizeof(**pobject), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tnvkm_object_ctor(func, oclass, *pobject);\n\t\treturn 0;\n\t}\n\treturn -ENOSYS;\n}\n\nstatic const struct nvkm_object_func\nnvkm_object_func = {\n};\n\nint\nnvkm_object_new(const struct nvkm_oclass *oclass, void *data, u32 size,\n\t\tstruct nvkm_object **pobject)\n{\n\tconst struct nvkm_object_func *func =\n\t\toclass->base.func ? oclass->base.func : &nvkm_object_func;\n\treturn nvkm_object_new_(func, oclass, data, size, pobject);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}