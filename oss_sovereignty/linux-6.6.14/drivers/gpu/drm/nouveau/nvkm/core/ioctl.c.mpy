{
  "module_name": "ioctl.c",
  "hash_id": "74526b887781762fc9a24c46db7710f45cdf0a0fb87c423c818293f923ef2628",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/ioctl.c",
  "human_readable_source": " \n#include <core/ioctl.h>\n#include <core/client.h>\n#include <core/engine.h>\n#include <core/event.h>\n\n#include <nvif/unpack.h>\n#include <nvif/ioctl.h>\n\nstatic int\nnvkm_ioctl_nop(struct nvkm_client *client,\n\t       struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_nop_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"nop size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object, \"nop vers %lld\\n\", args->v0.version);\n\t\targs->v0.version = NVIF_VERSION_LATEST;\n\t}\n\n\treturn ret;\n}\n\n#include <nvif/class.h>\n\nstatic int\nnvkm_ioctl_sclass_(struct nvkm_object *object, int index, struct nvkm_oclass *oclass)\n{\n\tif ( object->func->uevent &&\n\t    !object->func->uevent(object, NULL, 0, NULL) && index-- == 0) {\n\t\toclass->ctor = nvkm_uevent_new;\n\t\toclass->base.minver = 0;\n\t\toclass->base.maxver = 0;\n\t\toclass->base.oclass = NVIF_CLASS_EVENT;\n\t\treturn 0;\n\t}\n\n\tif (object->func->sclass)\n\t\treturn object->func->sclass(object, index, oclass);\n\n\treturn -ENOSYS;\n}\n\nstatic int\nnvkm_ioctl_sclass(struct nvkm_client *client,\n\t\t  struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_sclass_v0 v0;\n\t} *args = data;\n\tstruct nvkm_oclass oclass = { .client = client };\n\tint ret = -ENOSYS, i = 0;\n\n\tnvif_ioctl(object, \"sclass size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(object, \"sclass vers %d count %d\\n\",\n\t\t\t   args->v0.version, args->v0.count);\n\t\tif (size != args->v0.count * sizeof(args->v0.oclass[0]))\n\t\t\treturn -EINVAL;\n\n\t\twhile (nvkm_ioctl_sclass_(object, i, &oclass) >= 0) {\n\t\t\tif (i < args->v0.count) {\n\t\t\t\targs->v0.oclass[i].oclass = oclass.base.oclass;\n\t\t\t\targs->v0.oclass[i].minver = oclass.base.minver;\n\t\t\t\targs->v0.oclass[i].maxver = oclass.base.maxver;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\targs->v0.count = i;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_ioctl_new(struct nvkm_client *client,\n\t       struct nvkm_object *parent, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_new_v0 v0;\n\t} *args = data;\n\tstruct nvkm_object *object = NULL;\n\tstruct nvkm_oclass oclass;\n\tint ret = -ENOSYS, i = 0;\n\n\tnvif_ioctl(parent, \"new size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(parent, \"new vers %d handle %08x class %08x \"\n\t\t\t\t   \"route %02x token %llx object %016llx\\n\",\n\t\t\t   args->v0.version, args->v0.handle, args->v0.oclass,\n\t\t\t   args->v0.route, args->v0.token, args->v0.object);\n\t} else\n\t\treturn ret;\n\n\tif (!parent->func->sclass && !parent->func->uevent) {\n\t\tnvif_ioctl(parent, \"cannot have children\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tmemset(&oclass, 0x00, sizeof(oclass));\n\t\toclass.handle = args->v0.handle;\n\t\toclass.route  = args->v0.route;\n\t\toclass.token  = args->v0.token;\n\t\toclass.object = args->v0.object;\n\t\toclass.client = client;\n\t\toclass.parent = parent;\n\t\tret = nvkm_ioctl_sclass_(parent, i++, &oclass);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} while (oclass.base.oclass != args->v0.oclass);\n\n\tif (oclass.engine) {\n\t\toclass.engine = nvkm_engine_ref(oclass.engine);\n\t\tif (IS_ERR(oclass.engine))\n\t\t\treturn PTR_ERR(oclass.engine);\n\t}\n\n\tret = oclass.ctor(&oclass, data, size, &object);\n\tnvkm_engine_unref(&oclass.engine);\n\tif (ret == 0) {\n\t\tret = nvkm_object_init(object);\n\t\tif (ret == 0) {\n\t\t\tlist_add_tail(&object->head, &parent->tree);\n\t\t\tif (nvkm_object_insert(object)) {\n\t\t\t\tclient->data = object;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tret = -EEXIST;\n\t\t}\n\t\tnvkm_object_fini(object, false);\n\t}\n\n\tnvkm_object_del(&object);\n\treturn ret;\n}\n\nstatic int\nnvkm_ioctl_del(struct nvkm_client *client,\n\t       struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_del none;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"delete size %d\\n\", size);\n\tif (!(ret = nvif_unvers(ret, &data, &size, args->none))) {\n\t\tnvif_ioctl(object, \"delete\\n\");\n\t\tnvkm_object_fini(object, false);\n\t\tnvkm_object_del(&object);\n\t}\n\n\treturn ret ? ret : 1;\n}\n\nstatic int\nnvkm_ioctl_mthd(struct nvkm_client *client,\n\t\tstruct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_mthd_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"mthd size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(object, \"mthd vers %d mthd %02x\\n\",\n\t\t\t   args->v0.version, args->v0.method);\n\t\tret = nvkm_object_mthd(object, args->v0.method, data, size);\n\t}\n\n\treturn ret;\n}\n\n\nstatic int\nnvkm_ioctl_rd(struct nvkm_client *client,\n\t      struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_rd_v0 v0;\n\t} *args = data;\n\tunion {\n\t\tu8  b08;\n\t\tu16 b16;\n\t\tu32 b32;\n\t} v;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"rd size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object, \"rd vers %d size %d addr %016llx\\n\",\n\t\t\t   args->v0.version, args->v0.size, args->v0.addr);\n\t\tswitch (args->v0.size) {\n\t\tcase 1:\n\t\t\tret = nvkm_object_rd08(object, args->v0.addr, &v.b08);\n\t\t\targs->v0.data = v.b08;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret = nvkm_object_rd16(object, args->v0.addr, &v.b16);\n\t\t\targs->v0.data = v.b16;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tret = nvkm_object_rd32(object, args->v0.addr, &v.b32);\n\t\t\targs->v0.data = v.b32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_ioctl_wr(struct nvkm_client *client,\n\t      struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_wr_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"wr size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\n\t\tnvif_ioctl(object,\n\t\t\t   \"wr vers %d size %d addr %016llx data %08x\\n\",\n\t\t\t   args->v0.version, args->v0.size, args->v0.addr,\n\t\t\t   args->v0.data);\n\t} else\n\t\treturn ret;\n\n\tswitch (args->v0.size) {\n\tcase 1: return nvkm_object_wr08(object, args->v0.addr, args->v0.data);\n\tcase 2: return nvkm_object_wr16(object, args->v0.addr, args->v0.data);\n\tcase 4: return nvkm_object_wr32(object, args->v0.addr, args->v0.data);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_ioctl_map(struct nvkm_client *client,\n\t       struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_map_v0 v0;\n\t} *args = data;\n\tenum nvkm_object_map type;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"map size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(object, \"map vers %d\\n\", args->v0.version);\n\t\tret = nvkm_object_map(object, data, size, &type,\n\t\t\t\t      &args->v0.handle,\n\t\t\t\t      &args->v0.length);\n\t\tif (type == NVKM_OBJECT_MAP_IO)\n\t\t\targs->v0.type = NVIF_IOCTL_MAP_V0_IO;\n\t\telse\n\t\t\targs->v0.type = NVIF_IOCTL_MAP_V0_VA;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_ioctl_unmap(struct nvkm_client *client,\n\t\t struct nvkm_object *object, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_unmap none;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"unmap size %d\\n\", size);\n\tif (!(ret = nvif_unvers(ret, &data, &size, args->none))) {\n\t\tnvif_ioctl(object, \"unmap\\n\");\n\t\tret = nvkm_object_unmap(object);\n\t}\n\n\treturn ret;\n}\n\nstatic struct {\n\tint version;\n\tint (*func)(struct nvkm_client *, struct nvkm_object *, void *, u32);\n}\nnvkm_ioctl_v0[] = {\n\t{ 0x00, nvkm_ioctl_nop },\n\t{ 0x00, nvkm_ioctl_sclass },\n\t{ 0x00, nvkm_ioctl_new },\n\t{ 0x00, nvkm_ioctl_del },\n\t{ 0x00, nvkm_ioctl_mthd },\n\t{ 0x00, nvkm_ioctl_rd },\n\t{ 0x00, nvkm_ioctl_wr },\n\t{ 0x00, nvkm_ioctl_map },\n\t{ 0x00, nvkm_ioctl_unmap },\n};\n\nstatic int\nnvkm_ioctl_path(struct nvkm_client *client, u64 handle, u32 type,\n\t\tvoid *data, u32 size, u8 owner, u8 *route, u64 *token)\n{\n\tstruct nvkm_object *object;\n\tint ret;\n\n\tobject = nvkm_object_search(client, handle, NULL);\n\tif (IS_ERR(object)) {\n\t\tnvif_ioctl(&client->object, \"object not found\\n\");\n\t\treturn PTR_ERR(object);\n\t}\n\n\tif (owner != NVIF_IOCTL_V0_OWNER_ANY && owner != object->route) {\n\t\tnvif_ioctl(&client->object, \"route != owner\\n\");\n\t\treturn -EACCES;\n\t}\n\t*route = object->route;\n\t*token = object->token;\n\n\tif (ret = -EINVAL, type < ARRAY_SIZE(nvkm_ioctl_v0)) {\n\t\tif (nvkm_ioctl_v0[type].version == 0)\n\t\t\tret = nvkm_ioctl_v0[type].func(client, object, data, size);\n\t}\n\n\treturn ret;\n}\n\nint\nnvkm_ioctl(struct nvkm_client *client, void *data, u32 size, void **hack)\n{\n\tstruct nvkm_object *object = &client->object;\n\tunion {\n\t\tstruct nvif_ioctl_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(object, \"size %d\\n\", size);\n\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(object,\n\t\t\t   \"vers %d type %02x object %016llx owner %02x\\n\",\n\t\t\t   args->v0.version, args->v0.type, args->v0.object,\n\t\t\t   args->v0.owner);\n\t\tret = nvkm_ioctl_path(client, args->v0.object, args->v0.type,\n\t\t\t\t      data, size, args->v0.owner,\n\t\t\t\t      &args->v0.route, &args->v0.token);\n\t}\n\n\tif (ret != 1) {\n\t\tnvif_ioctl(object, \"return %d\\n\", ret);\n\t\tif (hack) {\n\t\t\t*hack = client->data;\n\t\t\tclient->data = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}