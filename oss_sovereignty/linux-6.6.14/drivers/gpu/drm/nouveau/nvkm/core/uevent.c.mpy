{
  "module_name": "uevent.c",
  "hash_id": "d9844d9309796668638bc69fbd6b358e5fe30b9d3a14806cfe2703afb940b6c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/uevent.c",
  "human_readable_source": " \n#define nvkm_uevent(p) container_of((p), struct nvkm_uevent, object)\n#include <core/event.h>\n#include <core/client.h>\n\n#include <nvif/if000e.h>\n\nstruct nvkm_uevent {\n\tstruct nvkm_object object;\n\tstruct nvkm_object *parent;\n\tnvkm_uevent_func func;\n\tbool wait;\n\n\tstruct nvkm_event_ntfy ntfy;\n\tatomic_t allowed;\n};\n\nstatic int\nnvkm_uevent_mthd_block(struct nvkm_uevent *uevent, union nvif_event_block_args *args, u32 argc)\n{\n\tif (argc != sizeof(args->vn))\n\t\treturn -ENOSYS;\n\n\tnvkm_event_ntfy_block(&uevent->ntfy);\n\tatomic_set(&uevent->allowed, 0);\n\treturn 0;\n}\n\nstatic int\nnvkm_uevent_mthd_allow(struct nvkm_uevent *uevent, union nvif_event_allow_args *args, u32 argc)\n{\n\tif (argc != sizeof(args->vn))\n\t\treturn -ENOSYS;\n\n\tnvkm_event_ntfy_allow(&uevent->ntfy);\n\tatomic_set(&uevent->allowed, 1);\n\treturn 0;\n}\n\nstatic int\nnvkm_uevent_mthd(struct nvkm_object *object, u32 mthd, void *argv, u32 argc)\n{\n\tstruct nvkm_uevent *uevent = nvkm_uevent(object);\n\n\tswitch (mthd) {\n\tcase NVIF_EVENT_V0_ALLOW: return nvkm_uevent_mthd_allow(uevent, argv, argc);\n\tcase NVIF_EVENT_V0_BLOCK: return nvkm_uevent_mthd_block(uevent, argv, argc);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_uevent_fini(struct nvkm_object *object, bool suspend)\n{\n\tstruct nvkm_uevent *uevent = nvkm_uevent(object);\n\n\tnvkm_event_ntfy_block(&uevent->ntfy);\n\treturn 0;\n}\n\nstatic int\nnvkm_uevent_init(struct nvkm_object *object)\n{\n\tstruct nvkm_uevent *uevent = nvkm_uevent(object);\n\n\tif (atomic_read(&uevent->allowed))\n\t\tnvkm_event_ntfy_allow(&uevent->ntfy);\n\n\treturn 0;\n}\n\nstatic void *\nnvkm_uevent_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_uevent *uevent = nvkm_uevent(object);\n\n\tnvkm_event_ntfy_del(&uevent->ntfy);\n\treturn uevent;\n}\n\nstatic const struct nvkm_object_func\nnvkm_uevent = {\n\t.dtor = nvkm_uevent_dtor,\n\t.init = nvkm_uevent_init,\n\t.fini = nvkm_uevent_fini,\n\t.mthd = nvkm_uevent_mthd,\n};\n\nstatic int\nnvkm_uevent_ntfy(struct nvkm_event_ntfy *ntfy, u32 bits)\n{\n\tstruct nvkm_uevent *uevent = container_of(ntfy, typeof(*uevent), ntfy);\n\tstruct nvkm_client *client = uevent->object.client;\n\n\tif (uevent->func)\n\t\treturn uevent->func(uevent->parent, uevent->object.token, bits);\n\n\treturn client->event(uevent->object.token, NULL, 0);\n}\n\nint\nnvkm_uevent_add(struct nvkm_uevent *uevent, struct nvkm_event *event, int id, u32 bits,\n\t\tnvkm_uevent_func func)\n{\n\tif (WARN_ON(uevent->func))\n\t\treturn -EBUSY;\n\n\tnvkm_event_ntfy_add(event, id, bits, uevent->wait, nvkm_uevent_ntfy, &uevent->ntfy);\n\tuevent->func = func;\n\treturn 0;\n}\n\nint\nnvkm_uevent_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\tstruct nvkm_object **pobject)\n{\n\tstruct nvkm_object *parent = oclass->parent;\n\tstruct nvkm_uevent *uevent;\n\tunion nvif_event_args *args = argv;\n\n\tif (argc < sizeof(args->v0) || args->v0.version != 0)\n\t\treturn -ENOSYS;\n\n\tif (!(uevent = kzalloc(sizeof(*uevent), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pobject = &uevent->object;\n\n\tnvkm_object_ctor(&nvkm_uevent, oclass, &uevent->object);\n\tuevent->parent = parent;\n\tuevent->func = NULL;\n\tuevent->wait = args->v0.wait;\n\tuevent->ntfy.event = NULL;\n\treturn parent->func->uevent(parent, &args->v0.data, argc - sizeof(args->v0), uevent);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}