{
  "module_name": "client.c",
  "hash_id": "4366d7b03b5a317ff2c25adc0024dd80df7c2b92b41ee48a1a507a9b61a4425e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/client.c",
  "human_readable_source": " \n#include <core/client.h>\n#include <core/device.h>\n#include <core/option.h>\n\n#include <nvif/class.h>\n#include <nvif/event.h>\n#include <nvif/if0000.h>\n#include <nvif/unpack.h>\n\nstatic int\nnvkm_uclient_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t\t struct nvkm_object **pobject)\n{\n\tunion {\n\t\tstruct nvif_client_v0 v0;\n\t} *args = argv;\n\tstruct nvkm_client *client;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))){\n\t\targs->v0.name[sizeof(args->v0.name) - 1] = 0;\n\t\tret = nvkm_client_new(args->v0.name, args->v0.device, NULL,\n\t\t\t\t      NULL, oclass->client->event, &client);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else\n\t\treturn ret;\n\n\tclient->object.client = oclass->client;\n\tclient->object.handle = oclass->handle;\n\tclient->object.route  = oclass->route;\n\tclient->object.token  = oclass->token;\n\tclient->object.object = oclass->object;\n\tclient->debug = oclass->client->debug;\n\t*pobject = &client->object;\n\treturn 0;\n}\n\nstatic const struct nvkm_sclass\nnvkm_uclient_sclass = {\n\t.oclass = NVIF_CLASS_CLIENT,\n\t.minver = 0,\n\t.maxver = 0,\n\t.ctor = nvkm_uclient_new,\n};\n\nstatic const struct nvkm_object_func nvkm_client;\nstruct nvkm_client *\nnvkm_client_search(struct nvkm_client *client, u64 handle)\n{\n\tstruct nvkm_object *object;\n\n\tobject = nvkm_object_search(client, handle, &nvkm_client);\n\tif (IS_ERR(object))\n\t\treturn (void *)object;\n\n\treturn nvkm_client(object);\n}\n\nstatic int\nnvkm_client_mthd_devlist(struct nvkm_client *client, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_client_devlist_v0 v0;\n\t} *args = data;\n\tint ret = -ENOSYS;\n\n\tnvif_ioctl(&client->object, \"client devlist size %d\\n\", size);\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tnvif_ioctl(&client->object, \"client devlist vers %d count %d\\n\",\n\t\t\t   args->v0.version, args->v0.count);\n\t\tif (size == sizeof(args->v0.device[0]) * args->v0.count) {\n\t\t\tret = nvkm_device_list(args->v0.device, args->v0.count);\n\t\t\tif (ret >= 0) {\n\t\t\t\targs->v0.count = ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\n{\n\tstruct nvkm_client *client = nvkm_client(object);\n\tswitch (mthd) {\n\tcase NVIF_CLIENT_V0_DEVLIST:\n\t\treturn nvkm_client_mthd_devlist(client, data, size);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_client_child_new(const struct nvkm_oclass *oclass,\n\t\t      void *data, u32 size, struct nvkm_object **pobject)\n{\n\treturn oclass->base.ctor(oclass, data, size, pobject);\n}\n\nstatic int\nnvkm_client_child_get(struct nvkm_object *object, int index,\n\t\t      struct nvkm_oclass *oclass)\n{\n\tconst struct nvkm_sclass *sclass;\n\n\tswitch (index) {\n\tcase 0: sclass = &nvkm_uclient_sclass; break;\n\tcase 1: sclass = &nvkm_udevice_sclass; break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\toclass->ctor = nvkm_client_child_new;\n\toclass->base = *sclass;\n\treturn 0;\n}\n\nstatic int\nnvkm_client_fini(struct nvkm_object *object, bool suspend)\n{\n\treturn 0;\n}\n\nstatic void *\nnvkm_client_dtor(struct nvkm_object *object)\n{\n\treturn nvkm_client(object);\n}\n\nstatic const struct nvkm_object_func\nnvkm_client = {\n\t.dtor = nvkm_client_dtor,\n\t.fini = nvkm_client_fini,\n\t.mthd = nvkm_client_mthd,\n\t.sclass = nvkm_client_child_get,\n};\n\nint\nnvkm_client_new(const char *name, u64 device, const char *cfg, const char *dbg,\n\t\tint (*event)(u64, void *, u32), struct nvkm_client **pclient)\n{\n\tstruct nvkm_oclass oclass = { .base = nvkm_uclient_sclass };\n\tstruct nvkm_client *client;\n\n\tif (!(client = *pclient = kzalloc(sizeof(*client), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\toclass.client = client;\n\n\tnvkm_object_ctor(&nvkm_client, &oclass, &client->object);\n\tsnprintf(client->name, sizeof(client->name), \"%s\", name);\n\tclient->device = device;\n\tclient->debug = nvkm_dbgopt(dbg, \"CLIENT\");\n\tclient->objroot = RB_ROOT;\n\tclient->event = event;\n\tINIT_LIST_HEAD(&client->umem);\n\tspin_lock_init(&client->lock);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}