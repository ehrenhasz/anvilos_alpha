{
  "module_name": "gpuobj.c",
  "hash_id": "e88a46cc8cf803d58919fd69ac772313ca56d882da33b713b15572a5e70b428b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/gpuobj.c",
  "human_readable_source": " \n#include <core/gpuobj.h>\n#include <core/engine.h>\n\n#include <subdev/instmem.h>\n#include <subdev/bar.h>\n#include <subdev/mmu.h>\n\n \nstatic u32\nnvkm_gpuobj_rd32_fast(struct nvkm_gpuobj *gpuobj, u32 offset)\n{\n\treturn ioread32_native(gpuobj->map + offset);\n}\n\nstatic void\nnvkm_gpuobj_wr32_fast(struct nvkm_gpuobj *gpuobj, u32 offset, u32 data)\n{\n\tiowrite32_native(data, gpuobj->map + offset);\n}\n\n \nstatic int\nnvkm_gpuobj_heap_map(struct nvkm_gpuobj *gpuobj, u64 offset,\n\t\t     struct nvkm_vmm *vmm, struct nvkm_vma *vma,\n\t\t     void *argv, u32 argc)\n{\n\treturn nvkm_memory_map(gpuobj->memory, offset, vmm, vma, argv, argc);\n}\n\nstatic u32\nnvkm_gpuobj_heap_rd32(struct nvkm_gpuobj *gpuobj, u32 offset)\n{\n\treturn nvkm_ro32(gpuobj->memory, offset);\n}\n\nstatic void\nnvkm_gpuobj_heap_wr32(struct nvkm_gpuobj *gpuobj, u32 offset, u32 data)\n{\n\tnvkm_wo32(gpuobj->memory, offset, data);\n}\n\nstatic const struct nvkm_gpuobj_func nvkm_gpuobj_heap;\nstatic void\nnvkm_gpuobj_heap_release(struct nvkm_gpuobj *gpuobj)\n{\n\tgpuobj->func = &nvkm_gpuobj_heap;\n\tnvkm_done(gpuobj->memory);\n}\n\nstatic const struct nvkm_gpuobj_func\nnvkm_gpuobj_heap_fast = {\n\t.release = nvkm_gpuobj_heap_release,\n\t.rd32 = nvkm_gpuobj_rd32_fast,\n\t.wr32 = nvkm_gpuobj_wr32_fast,\n\t.map = nvkm_gpuobj_heap_map,\n};\n\nstatic const struct nvkm_gpuobj_func\nnvkm_gpuobj_heap_slow = {\n\t.release = nvkm_gpuobj_heap_release,\n\t.rd32 = nvkm_gpuobj_heap_rd32,\n\t.wr32 = nvkm_gpuobj_heap_wr32,\n\t.map = nvkm_gpuobj_heap_map,\n};\n\nstatic void *\nnvkm_gpuobj_heap_acquire(struct nvkm_gpuobj *gpuobj)\n{\n\tgpuobj->map = nvkm_kmap(gpuobj->memory);\n\tif (likely(gpuobj->map))\n\t\tgpuobj->func = &nvkm_gpuobj_heap_fast;\n\telse\n\t\tgpuobj->func = &nvkm_gpuobj_heap_slow;\n\treturn gpuobj->map;\n}\n\nstatic const struct nvkm_gpuobj_func\nnvkm_gpuobj_heap = {\n\t.acquire = nvkm_gpuobj_heap_acquire,\n\t.map = nvkm_gpuobj_heap_map,\n};\n\n \nstatic int\nnvkm_gpuobj_map(struct nvkm_gpuobj *gpuobj, u64 offset,\n\t\tstruct nvkm_vmm *vmm, struct nvkm_vma *vma,\n\t\tvoid *argv, u32 argc)\n{\n\treturn nvkm_memory_map(gpuobj->parent, gpuobj->node->offset + offset,\n\t\t\t       vmm, vma, argv, argc);\n}\n\nstatic u32\nnvkm_gpuobj_rd32(struct nvkm_gpuobj *gpuobj, u32 offset)\n{\n\treturn nvkm_ro32(gpuobj->parent, gpuobj->node->offset + offset);\n}\n\nstatic void\nnvkm_gpuobj_wr32(struct nvkm_gpuobj *gpuobj, u32 offset, u32 data)\n{\n\tnvkm_wo32(gpuobj->parent, gpuobj->node->offset + offset, data);\n}\n\nstatic const struct nvkm_gpuobj_func nvkm_gpuobj_func;\nstatic void\nnvkm_gpuobj_release(struct nvkm_gpuobj *gpuobj)\n{\n\tgpuobj->func = &nvkm_gpuobj_func;\n\tnvkm_done(gpuobj->parent);\n}\n\nstatic const struct nvkm_gpuobj_func\nnvkm_gpuobj_fast = {\n\t.release = nvkm_gpuobj_release,\n\t.rd32 = nvkm_gpuobj_rd32_fast,\n\t.wr32 = nvkm_gpuobj_wr32_fast,\n\t.map = nvkm_gpuobj_map,\n};\n\nstatic const struct nvkm_gpuobj_func\nnvkm_gpuobj_slow = {\n\t.release = nvkm_gpuobj_release,\n\t.rd32 = nvkm_gpuobj_rd32,\n\t.wr32 = nvkm_gpuobj_wr32,\n\t.map = nvkm_gpuobj_map,\n};\n\nstatic void *\nnvkm_gpuobj_acquire(struct nvkm_gpuobj *gpuobj)\n{\n\tgpuobj->map = nvkm_kmap(gpuobj->parent);\n\tif (likely(gpuobj->map)) {\n\t\tgpuobj->map  = (u8 *)gpuobj->map + gpuobj->node->offset;\n\t\tgpuobj->func = &nvkm_gpuobj_fast;\n\t} else {\n\t\tgpuobj->func = &nvkm_gpuobj_slow;\n\t}\n\treturn gpuobj->map;\n}\n\nstatic const struct nvkm_gpuobj_func\nnvkm_gpuobj_func = {\n\t.acquire = nvkm_gpuobj_acquire,\n\t.map = nvkm_gpuobj_map,\n};\n\nstatic int\nnvkm_gpuobj_ctor(struct nvkm_device *device, u32 size, int align, bool zero,\n\t\t struct nvkm_gpuobj *parent, struct nvkm_gpuobj *gpuobj)\n{\n\tu32 offset;\n\tint ret;\n\n\tif (parent) {\n\t\tif (align >= 0) {\n\t\t\tret = nvkm_mm_head(&parent->heap, 0, 1, size, size,\n\t\t\t\t\t   max(align, 1), &gpuobj->node);\n\t\t} else {\n\t\t\tret = nvkm_mm_tail(&parent->heap, 0, 1, size, size,\n\t\t\t\t\t   -align, &gpuobj->node);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgpuobj->parent = parent;\n\t\tgpuobj->func = &nvkm_gpuobj_func;\n\t\tgpuobj->addr = parent->addr + gpuobj->node->offset;\n\t\tgpuobj->size = gpuobj->node->length;\n\n\t\tif (zero) {\n\t\t\tnvkm_kmap(gpuobj);\n\t\t\tfor (offset = 0; offset < gpuobj->size; offset += 4)\n\t\t\t\tnvkm_wo32(gpuobj, offset, 0x00000000);\n\t\t\tnvkm_done(gpuobj);\n\t\t}\n\t} else {\n\t\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, size,\n\t\t\t\t      abs(align), zero, &gpuobj->memory);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgpuobj->func = &nvkm_gpuobj_heap;\n\t\tgpuobj->addr = nvkm_memory_addr(gpuobj->memory);\n\t\tgpuobj->size = nvkm_memory_size(gpuobj->memory);\n\t}\n\n\treturn nvkm_mm_init(&gpuobj->heap, 0, 0, gpuobj->size, 1);\n}\n\nvoid\nnvkm_gpuobj_del(struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nvkm_gpuobj *gpuobj = *pgpuobj;\n\tif (gpuobj) {\n\t\tif (gpuobj->parent)\n\t\t\tnvkm_mm_free(&gpuobj->parent->heap, &gpuobj->node);\n\t\tnvkm_mm_fini(&gpuobj->heap);\n\t\tnvkm_memory_unref(&gpuobj->memory);\n\t\tkfree(*pgpuobj);\n\t\t*pgpuobj = NULL;\n\t}\n}\n\nint\nnvkm_gpuobj_new(struct nvkm_device *device, u32 size, int align, bool zero,\n\t\tstruct nvkm_gpuobj *parent, struct nvkm_gpuobj **pgpuobj)\n{\n\tstruct nvkm_gpuobj *gpuobj;\n\tint ret;\n\n\tif (!(gpuobj = *pgpuobj = kzalloc(sizeof(*gpuobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tret = nvkm_gpuobj_ctor(device, size, align, zero, parent, gpuobj);\n\tif (ret)\n\t\tnvkm_gpuobj_del(pgpuobj);\n\treturn ret;\n}\n\n \n\nint\nnvkm_gpuobj_wrap(struct nvkm_memory *memory, struct nvkm_gpuobj **pgpuobj)\n{\n\tif (!(*pgpuobj = kzalloc(sizeof(**pgpuobj), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t(*pgpuobj)->addr = nvkm_memory_addr(memory);\n\t(*pgpuobj)->size = nvkm_memory_size(memory);\n\treturn 0;\n}\n\nvoid\nnvkm_gpuobj_memcpy_to(struct nvkm_gpuobj *dst, u32 dstoffset, void *src,\n\t\t      u32 length)\n{\n\tint i;\n\n\tfor (i = 0; i < length; i += 4)\n\t\tnvkm_wo32(dst, dstoffset + i, *(u32 *)(src + i));\n}\n\nvoid\nnvkm_gpuobj_memcpy_from(void *dst, struct nvkm_gpuobj *src, u32 srcoffset,\n\t\t\tu32 length)\n{\n\tint i;\n\n\tfor (i = 0; i < length; i += 4)\n\t\t((u32 *)src)[i / 4] = nvkm_ro32(src, srcoffset + i);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}