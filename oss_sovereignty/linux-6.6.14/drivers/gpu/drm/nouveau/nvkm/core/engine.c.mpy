{
  "module_name": "engine.c",
  "hash_id": "48a98d7b47a307675a8e3f84f9c70dfc334c317b71f70db25d985fd4ad5b0ead",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/engine.c",
  "human_readable_source": " \n#include <core/engine.h>\n#include <core/device.h>\n#include <core/option.h>\n\n#include <subdev/fb.h>\n\nbool\nnvkm_engine_chsw_load(struct nvkm_engine *engine)\n{\n\tif (engine->func->chsw_load)\n\t\treturn engine->func->chsw_load(engine);\n\treturn false;\n}\n\nint\nnvkm_engine_reset(struct nvkm_engine *engine)\n{\n\tif (engine->func->reset)\n\t\treturn engine->func->reset(engine);\n\n\tnvkm_subdev_fini(&engine->subdev, false);\n\treturn nvkm_subdev_init(&engine->subdev);\n}\n\nvoid\nnvkm_engine_unref(struct nvkm_engine **pengine)\n{\n\tstruct nvkm_engine *engine = *pengine;\n\n\tif (engine) {\n\t\tnvkm_subdev_unref(&engine->subdev);\n\t\t*pengine = NULL;\n\t}\n}\n\nstruct nvkm_engine *\nnvkm_engine_ref(struct nvkm_engine *engine)\n{\n\tint ret;\n\n\tif (engine) {\n\t\tret = nvkm_subdev_ref(&engine->subdev);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn engine;\n}\n\nvoid\nnvkm_engine_tile(struct nvkm_engine *engine, int region)\n{\n\tstruct nvkm_fb *fb = engine->subdev.device->fb;\n\tif (engine->func->tile)\n\t\tengine->func->tile(engine, region, &fb->tile.region[region]);\n}\n\nstatic void\nnvkm_engine_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\tif (engine->func->intr)\n\t\tengine->func->intr(engine);\n}\n\nstatic int\nnvkm_engine_info(struct nvkm_subdev *subdev, u64 mthd, u64 *data)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\n\tif (engine->func->info)\n\t\treturn engine->func->info(engine, mthd, data);\n\n\treturn -ENOSYS;\n}\n\nstatic int\nnvkm_engine_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\tif (engine->func->fini)\n\t\treturn engine->func->fini(engine, suspend);\n\treturn 0;\n}\n\nstatic int\nnvkm_engine_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\tstruct nvkm_fb *fb = subdev->device->fb;\n\tint ret = 0, i;\n\n\tif (engine->func->init)\n\t\tret = engine->func->init(engine);\n\n\tfor (i = 0; fb && i < fb->tile.regions; i++)\n\t\tnvkm_engine_tile(engine, i);\n\treturn ret;\n}\n\nstatic int\nnvkm_engine_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\n\tif (engine->func->oneinit)\n\t\treturn engine->func->oneinit(engine);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_engine_preinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\tif (engine->func->preinit)\n\t\tengine->func->preinit(engine);\n\treturn 0;\n}\n\nstatic void *\nnvkm_engine_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_engine *engine = nvkm_engine(subdev);\n\tif (engine->func->dtor)\n\t\treturn engine->func->dtor(engine);\n\treturn engine;\n}\n\nconst struct nvkm_subdev_func\nnvkm_engine = {\n\t.dtor = nvkm_engine_dtor,\n\t.preinit = nvkm_engine_preinit,\n\t.oneinit = nvkm_engine_oneinit,\n\t.init = nvkm_engine_init,\n\t.fini = nvkm_engine_fini,\n\t.info = nvkm_engine_info,\n\t.intr = nvkm_engine_intr,\n};\n\nint\nnvkm_engine_ctor(const struct nvkm_engine_func *func, struct nvkm_device *device,\n\t\t enum nvkm_subdev_type type, int inst, bool enable, struct nvkm_engine *engine)\n{\n\tengine->func = func;\n\tnvkm_subdev_ctor(&nvkm_engine, device, type, inst, &engine->subdev);\n\trefcount_set(&engine->subdev.use.refcount, 0);\n\n\tif (!nvkm_boolopt(device->cfgopt, engine->subdev.name, enable)) {\n\t\tnvkm_debug(&engine->subdev, \"disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_init(&engine->lock);\n\treturn 0;\n}\n\nint\nnvkm_engine_new_(const struct nvkm_engine_func *func, struct nvkm_device *device,\n\t\t enum nvkm_subdev_type type, int inst, bool enable,\n\t\t struct nvkm_engine **pengine)\n{\n\tif (!(*pengine = kzalloc(sizeof(**pengine), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_engine_ctor(func, device, type, inst, enable, *pengine);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}