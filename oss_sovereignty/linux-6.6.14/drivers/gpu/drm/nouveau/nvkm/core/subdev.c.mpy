{
  "module_name": "subdev.c",
  "hash_id": "6bd03e7bb334298a74bfb7d243ece583160c2504552ca2b3ba6fc6e93601276c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/subdev.c",
  "human_readable_source": " \n#include <core/subdev.h>\n#include <core/device.h>\n#include <core/option.h>\n#include <subdev/mc.h>\n\nconst char *\nnvkm_subdev_type[NVKM_SUBDEV_NR] = {\n#define NVKM_LAYOUT_ONCE(type,data,ptr,...) [type] = #ptr,\n#define NVKM_LAYOUT_INST(A...) NVKM_LAYOUT_ONCE(A)\n#include <core/layout.h>\n#undef NVKM_LAYOUT_ONCE\n#undef NVKM_LAYOUT_INST\n};\n\nvoid\nnvkm_subdev_intr(struct nvkm_subdev *subdev)\n{\n\tif (subdev->func->intr)\n\t\tsubdev->func->intr(subdev);\n}\n\nint\nnvkm_subdev_info(struct nvkm_subdev *subdev, u64 mthd, u64 *data)\n{\n\tif (subdev->func->info)\n\t\treturn subdev->func->info(subdev, mthd, data);\n\treturn -ENOSYS;\n}\n\nint\nnvkm_subdev_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_device *device = subdev->device;\n\tconst char *action = suspend ? \"suspend\" : subdev->use.enabled ? \"fini\" : \"reset\";\n\ts64 time;\n\n\tnvkm_trace(subdev, \"%s running...\\n\", action);\n\ttime = ktime_to_us(ktime_get());\n\n\tif (subdev->func->fini) {\n\t\tint ret = subdev->func->fini(subdev, suspend);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"%s failed, %d\\n\", action, ret);\n\t\t\tif (suspend)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tsubdev->use.enabled = false;\n\n\tnvkm_mc_reset(device, subdev->type, subdev->inst);\n\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvkm_trace(subdev, \"%s completed in %lldus\\n\", action, time);\n\treturn 0;\n}\n\nint\nnvkm_subdev_preinit(struct nvkm_subdev *subdev)\n{\n\ts64 time;\n\n\tnvkm_trace(subdev, \"preinit running...\\n\");\n\ttime = ktime_to_us(ktime_get());\n\n\tif (subdev->func->preinit) {\n\t\tint ret = subdev->func->preinit(subdev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"preinit failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvkm_trace(subdev, \"preinit completed in %lldus\\n\", time);\n\treturn 0;\n}\n\nstatic int\nnvkm_subdev_oneinit_(struct nvkm_subdev *subdev)\n{\n\ts64 time;\n\tint ret;\n\n\tif (!subdev->func->oneinit || subdev->oneinit)\n\t\treturn 0;\n\n\tnvkm_trace(subdev, \"one-time init running...\\n\");\n\ttime = ktime_to_us(ktime_get());\n\tret = subdev->func->oneinit(subdev);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"one-time init failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsubdev->oneinit = true;\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvkm_trace(subdev, \"one-time init completed in %lldus\\n\", time);\n\treturn 0;\n}\n\nstatic int\nnvkm_subdev_init_(struct nvkm_subdev *subdev)\n{\n\ts64 time;\n\tint ret;\n\n\tif (subdev->use.enabled) {\n\t\tnvkm_trace(subdev, \"init skipped, already running\\n\");\n\t\treturn 0;\n\t}\n\n\tnvkm_trace(subdev, \"init running...\\n\");\n\ttime = ktime_to_us(ktime_get());\n\n\tret = nvkm_subdev_oneinit_(subdev);\n\tif (ret)\n\t\treturn ret;\n\n\tsubdev->use.enabled = true;\n\n\tif (subdev->func->init) {\n\t\tret = subdev->func->init(subdev);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"init failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttime = ktime_to_us(ktime_get()) - time;\n\tnvkm_trace(subdev, \"init completed in %lldus\\n\", time);\n\treturn 0;\n}\n\nint\nnvkm_subdev_init(struct nvkm_subdev *subdev)\n{\n\tint ret;\n\n\tmutex_lock(&subdev->use.mutex);\n\tif (refcount_read(&subdev->use.refcount) == 0) {\n\t\tnvkm_trace(subdev, \"init skipped, no users\\n\");\n\t\tmutex_unlock(&subdev->use.mutex);\n\t\treturn 0;\n\t}\n\n\tret = nvkm_subdev_init_(subdev);\n\tmutex_unlock(&subdev->use.mutex);\n\treturn ret;\n}\n\nint\nnvkm_subdev_oneinit(struct nvkm_subdev *subdev)\n{\n\tint ret;\n\n\tmutex_lock(&subdev->use.mutex);\n\tret = nvkm_subdev_oneinit_(subdev);\n\tmutex_unlock(&subdev->use.mutex);\n\treturn ret;\n}\n\nvoid\nnvkm_subdev_unref(struct nvkm_subdev *subdev)\n{\n\tif (refcount_dec_and_mutex_lock(&subdev->use.refcount, &subdev->use.mutex)) {\n\t\tnvkm_subdev_fini(subdev, false);\n\t\tmutex_unlock(&subdev->use.mutex);\n\t}\n}\n\nint\nnvkm_subdev_ref(struct nvkm_subdev *subdev)\n{\n\tint ret;\n\n\tif (subdev && !refcount_inc_not_zero(&subdev->use.refcount)) {\n\t\tmutex_lock(&subdev->use.mutex);\n\t\tif (!refcount_inc_not_zero(&subdev->use.refcount)) {\n\t\t\tif ((ret = nvkm_subdev_init_(subdev))) {\n\t\t\t\tmutex_unlock(&subdev->use.mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trefcount_set(&subdev->use.refcount, 1);\n\t\t}\n\t\tmutex_unlock(&subdev->use.mutex);\n\t}\n\n\treturn 0;\n}\n\nvoid\nnvkm_subdev_del(struct nvkm_subdev **psubdev)\n{\n\tstruct nvkm_subdev *subdev = *psubdev;\n\ts64 time;\n\n\tif (subdev && !WARN_ON(!subdev->func)) {\n\t\tnvkm_trace(subdev, \"destroy running...\\n\");\n\t\ttime = ktime_to_us(ktime_get());\n\t\tlist_del(&subdev->head);\n\t\tif (subdev->func->dtor)\n\t\t\t*psubdev = subdev->func->dtor(subdev);\n\t\tmutex_destroy(&subdev->use.mutex);\n\t\ttime = ktime_to_us(ktime_get()) - time;\n\t\tnvkm_trace(subdev, \"destroy completed in %lldus\\n\", time);\n\t\tkfree(*psubdev);\n\t\t*psubdev = NULL;\n\t}\n}\n\nvoid\nnvkm_subdev_disable(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tstruct nvkm_subdev *subdev;\n\tlist_for_each_entry(subdev, &device->subdev, head) {\n\t\tif (subdev->type == type && subdev->inst == inst) {\n\t\t\t*subdev->pself = NULL;\n\t\t\tnvkm_subdev_del(&subdev);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\n__nvkm_subdev_ctor(const struct nvkm_subdev_func *func, struct nvkm_device *device,\n\t\t   enum nvkm_subdev_type type, int inst, struct nvkm_subdev *subdev)\n{\n\tsubdev->func = func;\n\tsubdev->device = device;\n\tsubdev->type = type;\n\tsubdev->inst = inst < 0 ? 0 : inst;\n\n\tif (inst >= 0)\n\t\tsnprintf(subdev->name, sizeof(subdev->name), \"%s%d\", nvkm_subdev_type[type], inst);\n\telse\n\t\tstrscpy(subdev->name, nvkm_subdev_type[type], sizeof(subdev->name));\n\tsubdev->debug = nvkm_dbgopt(device->dbgopt, subdev->name);\n\n\trefcount_set(&subdev->use.refcount, 1);\n\tlist_add_tail(&subdev->head, &device->subdev);\n}\n\nint\nnvkm_subdev_new_(const struct nvkm_subdev_func *func, struct nvkm_device *device,\n\t\t enum nvkm_subdev_type type, int inst, struct nvkm_subdev **psubdev)\n{\n\tif (!(*psubdev = kzalloc(sizeof(**psubdev), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_subdev_ctor(func, device, type, inst, *psubdev);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}