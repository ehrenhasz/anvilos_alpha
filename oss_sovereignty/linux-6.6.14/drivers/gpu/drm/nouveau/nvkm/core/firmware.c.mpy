{
  "module_name": "firmware.c",
  "hash_id": "92a1c62a2c0679a4e2255c943ae5a63565204ca513339ef042c2cc62a1e73f70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/firmware.c",
  "human_readable_source": " \n#include <core/device.h>\n#include <core/firmware.h>\n\n#include <subdev/fb.h>\n#include <subdev/mmu.h>\n\nint\nnvkm_firmware_load_name(const struct nvkm_subdev *subdev, const char *base,\n\t\t\tconst char *name, int ver, const struct firmware **pfw)\n{\n\tchar path[64];\n\tint ret;\n\n\tsnprintf(path, sizeof(path), \"%s%s\", base, name);\n\tret = nvkm_firmware_get(subdev, path, ver, pfw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint\nnvkm_firmware_load_blob(const struct nvkm_subdev *subdev, const char *base,\n\t\t\tconst char *name, int ver, struct nvkm_blob *blob)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = nvkm_firmware_load_name(subdev, base, name, ver, &fw);\n\tif (ret == 0) {\n\t\tblob->data = kmemdup(fw->data, fw->size, GFP_KERNEL);\n\t\tblob->size = fw->size;\n\t\tnvkm_firmware_put(fw);\n\t\tif (!blob->data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn ret;\n}\n\n \nint\nnvkm_firmware_get(const struct nvkm_subdev *subdev, const char *fwname, int ver,\n\t\t  const struct firmware **fw)\n{\n\tstruct nvkm_device *device = subdev->device;\n\tchar f[64];\n\tchar cname[16];\n\tint i;\n\n\t \n\tstrncpy(cname, device->chip->name, sizeof(cname));\n\tcname[sizeof(cname) - 1] = '\\0';\n\ti = strlen(cname);\n\twhile (i) {\n\t\t--i;\n\t\tcname[i] = tolower(cname[i]);\n\t}\n\n\tif (ver != 0)\n\t\tsnprintf(f, sizeof(f), \"nvidia/%s/%s-%d.bin\", cname, fwname, ver);\n\telse\n\t\tsnprintf(f, sizeof(f), \"nvidia/%s/%s.bin\", cname, fwname);\n\n\tif (!firmware_request_nowarn(fw, f, device->dev)) {\n\t\tnvkm_debug(subdev, \"firmware \\\"%s\\\" loaded - %zu byte(s)\\n\",\n\t\t\t   f, (*fw)->size);\n\t\treturn 0;\n\t}\n\n\tnvkm_debug(subdev, \"firmware \\\"%s\\\" unavailable\\n\", f);\n\treturn -ENOENT;\n}\n\n \nvoid\nnvkm_firmware_put(const struct firmware *fw)\n{\n\trelease_firmware(fw);\n}\n\n#define nvkm_firmware_mem(p) container_of((p), struct nvkm_firmware, mem.memory)\n\nstatic int\nnvkm_firmware_mem_map(struct nvkm_memory *memory, u64 offset, struct nvkm_vmm *vmm,\n\t\t      struct nvkm_vma *vma, void *argv, u32 argc)\n{\n\tstruct nvkm_firmware *fw = nvkm_firmware_mem(memory);\n\tstruct nvkm_vmm_map map = {\n\t\t.memory = &fw->mem.memory,\n\t\t.offset = offset,\n\t\t.sgl = &fw->mem.sgl,\n\t};\n\n\tif (WARN_ON(fw->func->type != NVKM_FIRMWARE_IMG_DMA))\n\t\treturn -ENOSYS;\n\n\treturn nvkm_vmm_map(vmm, vma, argv, argc, &map);\n}\n\nstatic u64\nnvkm_firmware_mem_size(struct nvkm_memory *memory)\n{\n\treturn sg_dma_len(&nvkm_firmware_mem(memory)->mem.sgl);\n}\n\nstatic u64\nnvkm_firmware_mem_addr(struct nvkm_memory *memory)\n{\n\treturn nvkm_firmware_mem(memory)->phys;\n}\n\nstatic u8\nnvkm_firmware_mem_page(struct nvkm_memory *memory)\n{\n\treturn PAGE_SHIFT;\n}\n\nstatic enum nvkm_memory_target\nnvkm_firmware_mem_target(struct nvkm_memory *memory)\n{\n\tif (nvkm_firmware_mem(memory)->device->func->tegra)\n\t\treturn NVKM_MEM_TARGET_NCOH;\n\n\treturn NVKM_MEM_TARGET_HOST;\n}\n\nstatic void *\nnvkm_firmware_mem_dtor(struct nvkm_memory *memory)\n{\n\treturn NULL;\n}\n\nstatic const struct nvkm_memory_func\nnvkm_firmware_mem = {\n\t.dtor = nvkm_firmware_mem_dtor,\n\t.target = nvkm_firmware_mem_target,\n\t.page = nvkm_firmware_mem_page,\n\t.addr = nvkm_firmware_mem_addr,\n\t.size = nvkm_firmware_mem_size,\n\t.map = nvkm_firmware_mem_map,\n};\n\nvoid\nnvkm_firmware_dtor(struct nvkm_firmware *fw)\n{\n\tstruct nvkm_memory *memory = &fw->mem.memory;\n\n\tif (!fw->img)\n\t\treturn;\n\n\tswitch (fw->func->type) {\n\tcase NVKM_FIRMWARE_IMG_RAM:\n\t\tkfree(fw->img);\n\t\tbreak;\n\tcase NVKM_FIRMWARE_IMG_DMA:\n\t\tnvkm_memory_unref(&memory);\n\t\tdma_free_coherent(fw->device->dev, sg_dma_len(&fw->mem.sgl), fw->img, fw->phys);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tfw->img = NULL;\n}\n\nint\nnvkm_firmware_ctor(const struct nvkm_firmware_func *func, const char *name,\n\t\t   struct nvkm_device *device, const void *src, int len, struct nvkm_firmware *fw)\n{\n\tfw->func = func;\n\tfw->name = name;\n\tfw->device = device;\n\tfw->len = len;\n\n\tswitch (fw->func->type) {\n\tcase NVKM_FIRMWARE_IMG_RAM:\n\t\tfw->img = kmemdup(src, fw->len, GFP_KERNEL);\n\t\tbreak;\n\tcase NVKM_FIRMWARE_IMG_DMA: {\n\t\tdma_addr_t addr;\n\n\t\tlen = ALIGN(fw->len, PAGE_SIZE);\n\n\t\tfw->img = dma_alloc_coherent(fw->device->dev, len, &addr, GFP_KERNEL);\n\t\tif (fw->img) {\n\t\t\tmemcpy(fw->img, src, fw->len);\n\t\t\tfw->phys = addr;\n\t\t}\n\n\t\tsg_init_one(&fw->mem.sgl, fw->img, len);\n\t\tsg_dma_address(&fw->mem.sgl) = fw->phys;\n\t\tsg_dma_len(&fw->mem.sgl) = len;\n\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!fw->img)\n\t\treturn -ENOMEM;\n\n\tnvkm_memory_ctor(&nvkm_firmware_mem, &fw->mem.memory);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}