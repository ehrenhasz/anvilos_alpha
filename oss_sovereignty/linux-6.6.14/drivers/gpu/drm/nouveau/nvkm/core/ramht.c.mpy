{
  "module_name": "ramht.c",
  "hash_id": "2534a767f10cb1f5e3b7fb59e1b15bd209eff654acc15bee27172125dd64691f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/core/ramht.c",
  "human_readable_source": " \n#include <core/ramht.h>\n#include <core/engine.h>\n#include <core/object.h>\n\nstatic u32\nnvkm_ramht_hash(struct nvkm_ramht *ramht, int chid, u32 handle)\n{\n\tu32 hash = 0;\n\n\twhile (handle) {\n\t\thash ^= (handle & ((1 << ramht->bits) - 1));\n\t\thandle >>= ramht->bits;\n\t}\n\n\thash ^= chid << (ramht->bits - 4);\n\treturn hash;\n}\n\nstruct nvkm_gpuobj *\nnvkm_ramht_search(struct nvkm_ramht *ramht, int chid, u32 handle)\n{\n\tu32 co, ho;\n\n\tco = ho = nvkm_ramht_hash(ramht, chid, handle);\n\tdo {\n\t\tif (ramht->data[co].chid == chid) {\n\t\t\tif (ramht->data[co].handle == handle)\n\t\t\t\treturn ramht->data[co].inst;\n\t\t}\n\n\t\tif (++co >= ramht->size)\n\t\t\tco = 0;\n\t} while (co != ho);\n\n\treturn NULL;\n}\n\nstatic int\nnvkm_ramht_update(struct nvkm_ramht *ramht, int co, struct nvkm_object *object,\n\t\t  int chid, int addr, u32 handle, u32 context)\n{\n\tstruct nvkm_ramht_data *data = &ramht->data[co];\n\tu64 inst = 0x00000040;  \n\tint ret;\n\n\tnvkm_gpuobj_del(&data->inst);\n\tdata->chid = chid;\n\tdata->handle = handle;\n\n\tif (object) {\n\t\tret = nvkm_object_bind(object, ramht->parent, 16, &data->inst);\n\t\tif (ret) {\n\t\t\tif (ret != -ENODEV) {\n\t\t\t\tdata->chid = -1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdata->inst = NULL;\n\t\t}\n\n\t\tif (data->inst) {\n\t\t\tif (ramht->device->card_type >= NV_50)\n\t\t\t\tinst = data->inst->node->offset;\n\t\t\telse\n\t\t\t\tinst = data->inst->addr;\n\t\t}\n\n\t\tif (addr < 0) context |= inst << -addr;\n\t\telse          context |= inst >>  addr;\n\t}\n\n\tnvkm_kmap(ramht->gpuobj);\n\tnvkm_wo32(ramht->gpuobj, (co << 3) + 0, handle);\n\tnvkm_wo32(ramht->gpuobj, (co << 3) + 4, context);\n\tnvkm_done(ramht->gpuobj);\n\treturn co + 1;\n}\n\nvoid\nnvkm_ramht_remove(struct nvkm_ramht *ramht, int cookie)\n{\n\tif (--cookie >= 0)\n\t\tnvkm_ramht_update(ramht, cookie, NULL, -1, 0, 0, 0);\n}\n\nint\nnvkm_ramht_insert(struct nvkm_ramht *ramht, struct nvkm_object *object,\n\t\t  int chid, int addr, u32 handle, u32 context)\n{\n\tu32 co, ho;\n\n\tif (nvkm_ramht_search(ramht, chid, handle))\n\t\treturn -EEXIST;\n\n\tco = ho = nvkm_ramht_hash(ramht, chid, handle);\n\tdo {\n\t\tif (ramht->data[co].chid < 0) {\n\t\t\treturn nvkm_ramht_update(ramht, co, object, chid,\n\t\t\t\t\t\t addr, handle, context);\n\t\t}\n\n\t\tif (++co >= ramht->size)\n\t\t\tco = 0;\n\t} while (co != ho);\n\n\treturn -ENOSPC;\n}\n\nvoid\nnvkm_ramht_del(struct nvkm_ramht **pramht)\n{\n\tstruct nvkm_ramht *ramht = *pramht;\n\tif (ramht) {\n\t\tnvkm_gpuobj_del(&ramht->gpuobj);\n\t\tvfree(*pramht);\n\t\t*pramht = NULL;\n\t}\n}\n\nint\nnvkm_ramht_new(struct nvkm_device *device, u32 size, u32 align,\n\t       struct nvkm_gpuobj *parent, struct nvkm_ramht **pramht)\n{\n\tstruct nvkm_ramht *ramht;\n\tint ret, i;\n\n\tif (!(ramht = *pramht = vzalloc(struct_size(ramht, data, (size >> 3)))))\n\t\treturn -ENOMEM;\n\n\tramht->device = device;\n\tramht->parent = parent;\n\tramht->size = size >> 3;\n\tramht->bits = order_base_2(ramht->size);\n\tfor (i = 0; i < ramht->size; i++)\n\t\tramht->data[i].chid = -1;\n\n\tret = nvkm_gpuobj_new(ramht->device, size, align, true,\n\t\t\t      ramht->parent, &ramht->gpuobj);\n\tif (ret)\n\t\tnvkm_ramht_del(pramht);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}