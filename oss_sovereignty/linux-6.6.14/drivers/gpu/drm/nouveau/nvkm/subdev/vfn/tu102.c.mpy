{
  "module_name": "tu102.c",
  "hash_id": "9be7fe90de558e0bbe7f367ad6af4a69a1254073eb1db98a6e5ad16a8b960c6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/vfn/tu102.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <nvif/class.h>\n\nstatic void\ntu102_vfn_intr_reset(struct nvkm_intr *intr, int leaf, u32 mask)\n{\n\tstruct nvkm_vfn *vfn = container_of(intr, typeof(*vfn), intr);\n\n\tnvkm_wr32(vfn->subdev.device, vfn->addr.priv + 0x1000 + (leaf * 4), mask);\n}\n\nstatic void\ntu102_vfn_intr_allow(struct nvkm_intr *intr, int leaf, u32 mask)\n{\n\tstruct nvkm_vfn *vfn = container_of(intr, typeof(*vfn), intr);\n\n\tnvkm_wr32(vfn->subdev.device, vfn->addr.priv + 0x1200 + (leaf * 4), mask);\n}\n\nstatic void\ntu102_vfn_intr_block(struct nvkm_intr *intr, int leaf, u32 mask)\n{\n\tstruct nvkm_vfn *vfn = container_of(intr, typeof(*vfn), intr);\n\n\tnvkm_wr32(vfn->subdev.device, vfn->addr.priv + 0x1400 + (leaf * 4), mask);\n}\n\nstatic void\ntu102_vfn_intr_rearm(struct nvkm_intr *intr)\n{\n\tstruct nvkm_vfn *vfn = container_of(intr, typeof(*vfn), intr);\n\n\tnvkm_wr32(vfn->subdev.device, vfn->addr.priv + 0x1608, 0x0000000f);\n}\n\nstatic void\ntu102_vfn_intr_unarm(struct nvkm_intr *intr)\n{\n\tstruct nvkm_vfn *vfn = container_of(intr, typeof(*vfn), intr);\n\n\tnvkm_wr32(vfn->subdev.device, vfn->addr.priv + 0x1610, 0x0000000f);\n}\n\nstatic bool\ntu102_vfn_intr_pending(struct nvkm_intr *intr)\n{\n\tstruct nvkm_vfn *vfn = container_of(intr, typeof(*vfn), intr);\n\tstruct nvkm_device *device = vfn->subdev.device;\n\tu32 intr_top = nvkm_rd32(device, vfn->addr.priv + 0x1600);\n\tint pending = 0, leaf;\n\n\tfor (leaf = 0; leaf < 8; leaf++) {\n\t\tif (intr_top & BIT(leaf / 2)) {\n\t\t\tintr->stat[leaf] = nvkm_rd32(device, vfn->addr.priv + 0x1000 + (leaf * 4));\n\t\t\tif (intr->stat[leaf])\n\t\t\t\tpending++;\n\t\t} else {\n\t\t\tintr->stat[leaf] = 0;\n\t\t}\n\t}\n\n\treturn pending != 0;\n}\n\nconst struct nvkm_intr_func\ntu102_vfn_intr = {\n\t.pending = tu102_vfn_intr_pending,\n\t.unarm = tu102_vfn_intr_unarm,\n\t.rearm = tu102_vfn_intr_rearm,\n\t.block = tu102_vfn_intr_block,\n\t.allow = tu102_vfn_intr_allow,\n\t.reset = tu102_vfn_intr_reset,\n};\n\nstatic const struct nvkm_vfn_func\ntu102_vfn = {\n\t.intr = &tu102_vfn_intr,\n\t.user = { 0x030000, 0x010000, { -1, -1, TURING_USERMODE_A } },\n};\n\nint\ntu102_vfn_new(struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_vfn **pvfn)\n{\n\treturn nvkm_vfn_new_(&tu102_vfn, device, type, inst, 0xb80000, pvfn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}