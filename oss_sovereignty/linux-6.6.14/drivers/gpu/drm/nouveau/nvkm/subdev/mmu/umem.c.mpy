{
  "module_name": "umem.c",
  "hash_id": "3c8d330664ad289eb273d3532056dc4e9189aad3537a496dce117c7bbae34999",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/umem.c",
  "human_readable_source": " \n#include \"umem.h\"\n#include \"ummu.h\"\n\n#include <core/client.h>\n#include <core/memory.h>\n#include <subdev/bar.h>\n\n#include <nvif/class.h>\n#include <nvif/if000a.h>\n#include <nvif/unpack.h>\n\nstatic const struct nvkm_object_func nvkm_umem;\nstruct nvkm_memory *\nnvkm_umem_search(struct nvkm_client *client, u64 handle)\n{\n\tstruct nvkm_client *master = client->object.client;\n\tstruct nvkm_memory *memory = NULL;\n\tstruct nvkm_object *object;\n\tstruct nvkm_umem *umem;\n\n\tobject = nvkm_object_search(client, handle, &nvkm_umem);\n\tif (IS_ERR(object)) {\n\t\tif (client != master) {\n\t\t\tspin_lock(&master->lock);\n\t\t\tlist_for_each_entry(umem, &master->umem, head) {\n\t\t\t\tif (umem->object.object == handle) {\n\t\t\t\t\tmemory = nvkm_memory_ref(umem->memory);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&master->lock);\n\t\t}\n\t} else {\n\t\tumem = nvkm_umem(object);\n\t\tmemory = nvkm_memory_ref(umem->memory);\n\t}\n\n\treturn memory ? memory : ERR_PTR(-ENOENT);\n}\n\nstatic int\nnvkm_umem_unmap(struct nvkm_object *object)\n{\n\tstruct nvkm_umem *umem = nvkm_umem(object);\n\n\tif (!umem->map)\n\t\treturn -EEXIST;\n\n\tif (umem->io) {\n\t\tif (!IS_ERR(umem->bar)) {\n\t\t\tstruct nvkm_device *device = umem->mmu->subdev.device;\n\t\t\tnvkm_vmm_put(nvkm_bar_bar1_vmm(device), &umem->bar);\n\t\t} else {\n\t\t\tumem->bar = NULL;\n\t\t}\n\t} else {\n\t\tvunmap(umem->map);\n\t\tumem->map = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_umem_map(struct nvkm_object *object, void *argv, u32 argc,\n\t      enum nvkm_object_map *type, u64 *handle, u64 *length)\n{\n\tstruct nvkm_umem *umem = nvkm_umem(object);\n\tstruct nvkm_mmu *mmu = umem->mmu;\n\n\tif (!umem->mappable)\n\t\treturn -EINVAL;\n\tif (umem->map)\n\t\treturn -EEXIST;\n\n\tif ((umem->type & NVKM_MEM_HOST) && !argc) {\n\t\tint ret = nvkm_mem_map_host(umem->memory, &umem->map);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*handle = (unsigned long)(void *)umem->map;\n\t\t*length = nvkm_memory_size(umem->memory);\n\t\t*type = NVKM_OBJECT_MAP_VA;\n\t\treturn 0;\n\t} else\n\tif ((umem->type & NVKM_MEM_VRAM) ||\n\t    (umem->type & NVKM_MEM_KIND)) {\n\t\tint ret = mmu->func->mem.umap(mmu, umem->memory, argv, argc,\n\t\t\t\t\t      handle, length, &umem->bar);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*type = NVKM_OBJECT_MAP_IO;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tumem->io = (*type == NVKM_OBJECT_MAP_IO);\n\treturn 0;\n}\n\nstatic void *\nnvkm_umem_dtor(struct nvkm_object *object)\n{\n\tstruct nvkm_umem *umem = nvkm_umem(object);\n\tspin_lock(&umem->object.client->lock);\n\tlist_del_init(&umem->head);\n\tspin_unlock(&umem->object.client->lock);\n\tnvkm_memory_unref(&umem->memory);\n\treturn umem;\n}\n\nstatic const struct nvkm_object_func\nnvkm_umem = {\n\t.dtor = nvkm_umem_dtor,\n\t.map = nvkm_umem_map,\n\t.unmap = nvkm_umem_unmap,\n};\n\nint\nnvkm_umem_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\n\t      struct nvkm_object **pobject)\n{\n\tstruct nvkm_mmu *mmu = nvkm_ummu(oclass->parent)->mmu;\n\tunion {\n\t\tstruct nvif_mem_v0 v0;\n\t} *args = argv;\n\tstruct nvkm_umem *umem;\n\tint type, ret = -ENOSYS;\n\tu8  page;\n\tu64 size;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, true))) {\n\t\ttype = args->v0.type;\n\t\tpage = args->v0.page;\n\t\tsize = args->v0.size;\n\t} else\n\t\treturn ret;\n\n\tif (type >= mmu->type_nr)\n\t\treturn -EINVAL;\n\n\tif (!(umem = kzalloc(sizeof(*umem), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nvkm_umem, oclass, &umem->object);\n\tumem->mmu = mmu;\n\tumem->type = mmu->type[type].type;\n\tINIT_LIST_HEAD(&umem->head);\n\t*pobject = &umem->object;\n\n\tif (mmu->type[type].type & NVKM_MEM_MAPPABLE) {\n\t\tpage = max_t(u8, page, PAGE_SHIFT);\n\t\tumem->mappable = true;\n\t}\n\n\tret = nvkm_mem_new_type(mmu, type, page, size, argv, argc,\n\t\t\t\t&umem->memory);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&umem->object.client->lock);\n\tlist_add(&umem->head, &umem->object.client->umem);\n\tspin_unlock(&umem->object.client->lock);\n\n\targs->v0.page = nvkm_memory_page(umem->memory);\n\targs->v0.addr = nvkm_memory_addr(umem->memory);\n\targs->v0.size = nvkm_memory_size(umem->memory);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}