{
  "module_name": "g84.c",
  "hash_id": "e6d827355f37bae675e776db611081e7b0f352a5ff86bf774134eb1139abf99b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/g84.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/fuse.h>\n\nint\ng84_temp_get(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\n\tif (nvkm_fuse_read(device->fuse, 0x1a8) == 1)\n\t\treturn nvkm_rd32(device, 0x20400);\n\telse\n\t\treturn -ENODEV;\n}\n\nvoid\ng84_sensor_setup(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\n\t \n\tif (nvkm_fuse_read(device->fuse, 0x1a8) == 1) {\n\t\tnvkm_mask(device, 0x20008, 0x80008000, 0x80000000);\n\t\tnvkm_mask(device, 0x2000c, 0x80000003, 0x00000000);\n\t\tmdelay(20);  \n\t}\n}\n\nstatic void\ng84_therm_program_alarms(struct nvkm_therm *therm)\n{\n\tstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);\n\n\t \n\tnvkm_wr32(device, 0x20000, 0x000003ff);\n\n\t \n\tnvkm_wr32(device, 0x20484, sensor->thrs_shutdown.hysteresis);\n\tnvkm_wr32(device, 0x20480, sensor->thrs_shutdown.temp);\n\n\t \n\tnvkm_wr32(device, 0x204c4, sensor->thrs_fan_boost.temp);\n\n\t \n\tnvkm_wr32(device, 0x204c0, sensor->thrs_critical.temp);\n\n\t \n\tnvkm_wr32(device, 0x20414, sensor->thrs_down_clock.temp);\n\tspin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);\n\n\tnvkm_debug(subdev,\n\t\t   \"Programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\\n\",\n\t\t   sensor->thrs_fan_boost.temp,\n\t\t   sensor->thrs_fan_boost.hysteresis,\n\t\t   sensor->thrs_down_clock.temp,\n\t\t   sensor->thrs_down_clock.hysteresis,\n\t\t   sensor->thrs_critical.temp,\n\t\t   sensor->thrs_critical.hysteresis,\n\t\t   sensor->thrs_shutdown.temp,\n\t\t   sensor->thrs_shutdown.hysteresis);\n\n}\n\n \nstatic void\ng84_therm_threshold_hyst_emulation(struct nvkm_therm *therm,\n\t\t\t\t   uint32_t thrs_reg, u8 status_bit,\n\t\t\t\t   const struct nvbios_therm_threshold *thrs,\n\t\t\t\t   enum nvkm_therm_thrs thrs_name)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tenum nvkm_therm_thrs_direction direction;\n\tenum nvkm_therm_thrs_state prev_state, new_state;\n\tint temp, cur;\n\n\tprev_state = nvkm_therm_sensor_get_threshold_state(therm, thrs_name);\n\ttemp = nvkm_rd32(device, thrs_reg);\n\n\t \n\tif (temp == thrs->temp) {\n\t\tnvkm_wr32(device, thrs_reg, thrs->temp - thrs->hysteresis);\n\t\tnew_state = NVKM_THERM_THRS_HIGHER;\n\t} else {\n\t\tnvkm_wr32(device, thrs_reg, thrs->temp);\n\t\tnew_state = NVKM_THERM_THRS_LOWER;\n\t}\n\n\t \n\tcur = therm->func->temp_get(therm);\n\tif (new_state == NVKM_THERM_THRS_LOWER && cur > thrs->temp)\n\t\tnew_state = NVKM_THERM_THRS_HIGHER;\n\telse if (new_state == NVKM_THERM_THRS_HIGHER &&\n\t\tcur < thrs->temp - thrs->hysteresis)\n\t\tnew_state = NVKM_THERM_THRS_LOWER;\n\tnvkm_therm_sensor_set_threshold_state(therm, thrs_name, new_state);\n\n\t \n\tif (prev_state < new_state)\n\t\tdirection = NVKM_THERM_THRS_RISING;\n\telse if (prev_state > new_state)\n\t\tdirection = NVKM_THERM_THRS_FALLING;\n\telse\n\t\treturn;\n\n\t \n\tnvkm_therm_sensor_event(therm, thrs_name, direction);\n}\n\nstatic void\ng84_therm_intr(struct nvkm_therm *therm)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\n\tunsigned long flags;\n\tuint32_t intr;\n\n\tspin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);\n\n\tintr = nvkm_rd32(device, 0x20100) & 0x3ff;\n\n\t \n\tif (intr & 0x002) {\n\t\tg84_therm_threshold_hyst_emulation(therm, 0x20414, 24,\n\t\t\t\t\t\t   &sensor->thrs_down_clock,\n\t\t\t\t\t\t   NVKM_THERM_THRS_DOWNCLOCK);\n\t\tintr &= ~0x002;\n\t}\n\n\t \n\tif (intr & 0x004) {\n\t\tg84_therm_threshold_hyst_emulation(therm, 0x20480, 20,\n\t\t\t\t\t\t   &sensor->thrs_shutdown,\n\t\t\t\t\t\t   NVKM_THERM_THRS_SHUTDOWN);\n\t\tintr &= ~0x004;\n\t}\n\n\t \n\tif (intr & 0x008) {\n\t\tg84_therm_threshold_hyst_emulation(therm, 0x204c4, 21,\n\t\t\t\t\t\t   &sensor->thrs_fan_boost,\n\t\t\t\t\t\t   NVKM_THERM_THRS_FANBOOST);\n\t\tintr &= ~0x008;\n\t}\n\n\t \n\tif (intr & 0x010) {\n\t\tg84_therm_threshold_hyst_emulation(therm, 0x204c0, 22,\n\t\t\t\t\t\t   &sensor->thrs_critical,\n\t\t\t\t\t\t   NVKM_THERM_THRS_CRITICAL);\n\t\tintr &= ~0x010;\n\t}\n\n\tif (intr)\n\t\tnvkm_error(subdev, \"intr %08x\\n\", intr);\n\n\t \n\tnvkm_wr32(device, 0x20100, 0xffffffff);\n\tnvkm_wr32(device, 0x1100, 0x10000);  \n\n\tspin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);\n}\n\nvoid\ng84_therm_fini(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\n\t \n\tnvkm_wr32(device, 0x20000, 0x00000000);\n\n\t \n\tnvkm_wr32(device, 0x20100, 0xffffffff);\n\tnvkm_wr32(device, 0x1100, 0x10000);  \n}\n\nvoid\ng84_therm_init(struct nvkm_therm *therm)\n{\n\tg84_sensor_setup(therm);\n}\n\nstatic const struct nvkm_therm_func\ng84_therm = {\n\t.init = g84_therm_init,\n\t.fini = g84_therm_fini,\n\t.intr = g84_therm_intr,\n\t.pwm_ctrl = nv50_fan_pwm_ctrl,\n\t.pwm_get = nv50_fan_pwm_get,\n\t.pwm_set = nv50_fan_pwm_set,\n\t.pwm_clock = nv50_fan_pwm_clock,\n\t.temp_get = g84_temp_get,\n\t.program_alarms = g84_therm_program_alarms,\n};\n\nint\ng84_therm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_therm **ptherm)\n{\n\tstruct nvkm_therm *therm;\n\tint ret;\n\n\tret = nvkm_therm_new_(&g84_therm, device, type, inst, &therm);\n\t*ptherm = therm;\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnvkm_therm_sensor_set_threshold_state(therm, NVKM_THERM_THRS_SHUTDOWN,\n\t\t\t\t\t\t     NVKM_THERM_THRS_LOWER);\n\tnvkm_therm_sensor_set_threshold_state(therm, NVKM_THERM_THRS_FANBOOST,\n\t\t\t\t\t\t     NVKM_THERM_THRS_LOWER);\n\tnvkm_therm_sensor_set_threshold_state(therm, NVKM_THERM_THRS_CRITICAL,\n\t\t\t\t\t\t     NVKM_THERM_THRS_LOWER);\n\tnvkm_therm_sensor_set_threshold_state(therm, NVKM_THERM_THRS_DOWNCLOCK,\n\t\t\t\t\t\t     NVKM_THERM_THRS_LOWER);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}