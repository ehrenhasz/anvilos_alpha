{
  "module_name": "shadow.c",
  "hash_id": "4eafedd7788da716edb8b51aff6b88c7654ebfccb8abd9d04d62b937893bca80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadow.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/image.h>\n\nstruct shadow {\n\tu32 skip;\n\tconst struct nvbios_source *func;\n\tvoid *data;\n\tu32 size;\n\tint score;\n};\n\nstatic bool\nshadow_fetch(struct nvkm_bios *bios, struct shadow *mthd, u32 upto)\n{\n\tconst u32 limit = (upto + 3) & ~3;\n\tconst u32 start = bios->size;\n\tvoid *data = mthd->data;\n\tif (nvbios_extend(bios, limit) > 0) {\n\t\tu32 read = mthd->func->read(data, start, limit - start, bios);\n\t\tbios->size = start + read;\n\t}\n\treturn bios->size >= upto;\n}\n\nstatic int\nshadow_image(struct nvkm_bios *bios, int idx, u32 offset, struct shadow *mthd)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tstruct nvbios_image image;\n\tint score = 1;\n\n\tif (mthd->func->no_pcir) {\n\t\timage.base = 0;\n\t\timage.type = 0;\n\t\timage.size = mthd->func->size(mthd->data);\n\t\timage.last = 1;\n\t} else {\n\t\tif (!shadow_fetch(bios, mthd, offset + 0x1000)) {\n\t\t\tnvkm_debug(subdev, \"%08x: header fetch failed\\n\",\n\t\t\t\t   offset);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!nvbios_image(bios, idx, &image)) {\n\t\t\tnvkm_debug(subdev, \"image %d invalid\\n\", idx);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tnvkm_debug(subdev, \"%08x: type %02x, %d bytes\\n\",\n\t\t   image.base, image.type, image.size);\n\n\tif (!shadow_fetch(bios, mthd, image.base + image.size)) {\n\t\tnvkm_debug(subdev, \"%08x: fetch failed\\n\", image.base);\n\t\treturn 0;\n\t}\n\n\tswitch (image.type) {\n\tcase 0x00:\n\t\tif (!mthd->func->ignore_checksum &&\n\t\t    nvbios_checksum(&bios->data[image.base], image.size)) {\n\t\t\tnvkm_debug(subdev, \"%08x: checksum failed\\n\",\n\t\t\t\t   image.base);\n\t\t\tif (!mthd->func->require_checksum) {\n\t\t\t\tif (mthd->func->rw)\n\t\t\t\t\tscore += 1;\n\t\t\t\tscore += 1;\n\t\t\t} else\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tscore += 3;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tscore += 3;\n\t\tbreak;\n\t}\n\n\tif (!image.last)\n\t\tscore += shadow_image(bios, idx + 1, offset + image.size, mthd);\n\treturn score;\n}\n\nstatic int\nshadow_method(struct nvkm_bios *bios, struct shadow *mthd, const char *name)\n{\n\tconst struct nvbios_source *func = mthd->func;\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tif (func->name) {\n\t\tnvkm_debug(subdev, \"trying %s...\\n\", name ? name : func->name);\n\t\tif (func->init) {\n\t\t\tmthd->data = func->init(bios, name);\n\t\t\tif (IS_ERR(mthd->data)) {\n\t\t\t\tmthd->data = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tmthd->score = shadow_image(bios, 0, 0, mthd);\n\t\tif (func->fini)\n\t\t\tfunc->fini(mthd->data);\n\t\tnvkm_debug(subdev, \"scored %d\\n\", mthd->score);\n\t\tmthd->data = bios->data;\n\t\tmthd->size = bios->size;\n\t\tbios->data  = NULL;\n\t\tbios->size  = 0;\n\t}\n\treturn mthd->score;\n}\n\nstatic u32\nshadow_fw_read(void *data, u32 offset, u32 length, struct nvkm_bios *bios)\n{\n\tconst struct firmware *fw = data;\n\tif (offset + length <= fw->size) {\n\t\tmemcpy(bios->data + offset, fw->data + offset, length);\n\t\treturn length;\n\t}\n\treturn 0;\n}\n\nstatic void *\nshadow_fw_init(struct nvkm_bios *bios, const char *name)\n{\n\tstruct device *dev = bios->subdev.device->dev;\n\tconst struct firmware *fw;\n\tint ret = request_firmware(&fw, name, dev);\n\tif (ret)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn (void *)fw;\n}\n\nstatic const struct nvbios_source\nshadow_fw = {\n\t.name = \"firmware\",\n\t.init = shadow_fw_init,\n\t.fini = (void(*)(void *))release_firmware,\n\t.read = shadow_fw_read,\n\t.rw = false,\n};\n\nint\nnvbios_shadow(struct nvkm_bios *bios)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct shadow mthds[] = {\n\t\t{ 0, &nvbios_of },\n\t\t{ 0, &nvbios_ramin },\n\t\t{ 0, &nvbios_prom },\n\t\t{ 0, &nvbios_acpi_fast },\n\t\t{ 4, &nvbios_acpi_slow },\n\t\t{ 1, &nvbios_pcirom },\n\t\t{ 1, &nvbios_platform },\n\t\t{}\n\t}, *mthd, *best = NULL;\n\tconst char *optarg;\n\tchar *source;\n\tint optlen;\n\n\t \n\toptarg = nvkm_stropt(device->cfgopt, \"NvBios\", &optlen);\n\tsource = optarg ? kstrndup(optarg, optlen, GFP_KERNEL) : NULL;\n\tif (source) {\n\t\t \n\t\tfor (mthd = mthds; mthd->func; mthd++) {\n\t\t\tif (mthd->func->name &&\n\t\t\t    !strcasecmp(source, mthd->func->name)) {\n\t\t\t\tbest = mthd;\n\t\t\t\tif (shadow_method(bios, mthd, NULL))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!best && (best = mthd)) {\n\t\t\tmthd->func = &shadow_fw;\n\t\t\tshadow_method(bios, mthd, source);\n\t\t\tmthd->func = NULL;\n\t\t}\n\n\t\tif (!best->score) {\n\t\t\tnvkm_error(subdev, \"%s invalid\\n\", source);\n\t\t\tkfree(source);\n\t\t\tsource = NULL;\n\t\t}\n\t}\n\n\t \n\tif (!best || !best->score) {\n\t\tfor (mthd = mthds, best = mthd; mthd->func; mthd++) {\n\t\t\tif (!mthd->skip || best->score < mthd->skip) {\n\t\t\t\tif (shadow_method(bios, mthd, NULL)) {\n\t\t\t\t\tif (mthd->score > best->score)\n\t\t\t\t\t\tbest = mthd;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (mthd = mthds; mthd->func; mthd++) {\n\t\tif (mthd != best)\n\t\t\tkfree(mthd->data);\n\t}\n\n\tif (!best->score) {\n\t\tnvkm_error(subdev, \"unable to locate usable image\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnvkm_debug(subdev, \"using image from %s\\n\", best->func ?\n\t\t   best->func->name : source);\n\tbios->data = best->data;\n\tbios->size = best->size;\n\tkfree(source);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}