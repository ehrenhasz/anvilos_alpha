{
  "module_name": "nv50.c",
  "hash_id": "21495b9af233629193ab22b9b9170542649f049b01b4362e19731eac7e1a0646",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bar/nv50.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <core/gpuobj.h>\n#include <subdev/fb.h>\n#include <subdev/mmu.h>\n#include <subdev/timer.h>\n\nstatic void\nnv50_bar_flush(struct nvkm_bar *base)\n{\n\tstruct nv50_bar *bar = nv50_bar(base);\n\tstruct nvkm_device *device = bar->base.subdev.device;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bar->base.lock, flags);\n\tnvkm_wr32(device, 0x00330c, 0x00000001);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x00330c) & 0x00000002))\n\t\t\tbreak;\n\t);\n\tspin_unlock_irqrestore(&bar->base.lock, flags);\n}\n\nstruct nvkm_vmm *\nnv50_bar_bar1_vmm(struct nvkm_bar *base)\n{\n\treturn nv50_bar(base)->bar1_vmm;\n}\n\nvoid\nnv50_bar_bar1_wait(struct nvkm_bar *base)\n{\n\tnvkm_bar_flush(base);\n}\n\nvoid\nnv50_bar_bar1_fini(struct nvkm_bar *bar)\n{\n\tnvkm_wr32(bar->subdev.device, 0x001708, 0x00000000);\n}\n\nvoid\nnv50_bar_bar1_init(struct nvkm_bar *base)\n{\n\tstruct nvkm_device *device = base->subdev.device;\n\tstruct nv50_bar *bar = nv50_bar(base);\n\tnvkm_wr32(device, 0x001708, 0x80000000 | bar->bar1->node->offset >> 4);\n}\n\nstruct nvkm_vmm *\nnv50_bar_bar2_vmm(struct nvkm_bar *base)\n{\n\treturn nv50_bar(base)->bar2_vmm;\n}\n\nvoid\nnv50_bar_bar2_fini(struct nvkm_bar *bar)\n{\n\tnvkm_wr32(bar->subdev.device, 0x00170c, 0x00000000);\n}\n\nvoid\nnv50_bar_bar2_init(struct nvkm_bar *base)\n{\n\tstruct nvkm_device *device = base->subdev.device;\n\tstruct nv50_bar *bar = nv50_bar(base);\n\tnvkm_wr32(device, 0x001704, 0x00000000 | bar->mem->addr >> 12);\n\tnvkm_wr32(device, 0x001704, 0x40000000 | bar->mem->addr >> 12);\n\tnvkm_wr32(device, 0x00170c, 0x80000000 | bar->bar2->node->offset >> 4);\n}\n\nvoid\nnv50_bar_init(struct nvkm_bar *base)\n{\n\tstruct nv50_bar *bar = nv50_bar(base);\n\tstruct nvkm_device *device = bar->base.subdev.device;\n\tint i;\n\n\tfor (i = 0; i < 8; i++)\n\t\tnvkm_wr32(device, 0x001900 + (i * 4), 0x00000000);\n}\n\nint\nnv50_bar_oneinit(struct nvkm_bar *base)\n{\n\tstruct nv50_bar *bar = nv50_bar(base);\n\tstruct nvkm_device *device = bar->base.subdev.device;\n\tstatic struct lock_class_key bar1_lock;\n\tstatic struct lock_class_key bar2_lock;\n\tu64 start, limit, size;\n\tint ret;\n\n\tret = nvkm_gpuobj_new(device, 0x20000, 0, false, NULL, &bar->mem);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, bar->pgd_addr, 0, false, bar->mem,\n\t\t\t      &bar->pad);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 0x4000, 0, false, bar->mem, &bar->pgd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstart = 0x0100000000ULL;\n\tsize = device->func->resource_size(device, 3);\n\tif (!size)\n\t\treturn -ENOMEM;\n\tlimit = start + size;\n\n\tret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,\n\t\t\t   &bar2_lock, \"bar2\", &bar->bar2_vmm);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_inc(&bar->bar2_vmm->engref[NVKM_SUBDEV_BAR]);\n\tbar->bar2_vmm->debug = bar->base.subdev.debug;\n\n\tret = nvkm_vmm_boot(bar->bar2_vmm);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_vmm_join(bar->bar2_vmm, bar->mem->memory);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 24, 16, false, bar->mem, &bar->bar2);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_kmap(bar->bar2);\n\tnvkm_wo32(bar->bar2, 0x00, 0x7fc00000);\n\tnvkm_wo32(bar->bar2, 0x04, lower_32_bits(limit));\n\tnvkm_wo32(bar->bar2, 0x08, lower_32_bits(start));\n\tnvkm_wo32(bar->bar2, 0x0c, upper_32_bits(limit) << 24 |\n\t\t\t\t   upper_32_bits(start));\n\tnvkm_wo32(bar->bar2, 0x10, 0x00000000);\n\tnvkm_wo32(bar->bar2, 0x14, 0x00000000);\n\tnvkm_done(bar->bar2);\n\n\tbar->base.subdev.oneinit = true;\n\tnvkm_bar_bar2_init(device);\n\n\t \n\tstart = 0x0000000000ULL;\n\tsize = device->func->resource_size(device, 1);\n\tif (!size)\n\t\treturn -ENOMEM;\n\tlimit = start + size;\n\n\tret = nvkm_vmm_new(device, start, limit-- - start, NULL, 0,\n\t\t\t   &bar1_lock, \"bar1\", &bar->bar1_vmm);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_inc(&bar->bar1_vmm->engref[NVKM_SUBDEV_BAR]);\n\tbar->bar1_vmm->debug = bar->base.subdev.debug;\n\n\tret = nvkm_vmm_join(bar->bar1_vmm, bar->mem->memory);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_gpuobj_new(device, 24, 16, false, bar->mem, &bar->bar1);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_kmap(bar->bar1);\n\tnvkm_wo32(bar->bar1, 0x00, 0x7fc00000);\n\tnvkm_wo32(bar->bar1, 0x04, lower_32_bits(limit));\n\tnvkm_wo32(bar->bar1, 0x08, lower_32_bits(start));\n\tnvkm_wo32(bar->bar1, 0x0c, upper_32_bits(limit) << 24 |\n\t\t\t\t   upper_32_bits(start));\n\tnvkm_wo32(bar->bar1, 0x10, 0x00000000);\n\tnvkm_wo32(bar->bar1, 0x14, 0x00000000);\n\tnvkm_done(bar->bar1);\n\treturn 0;\n}\n\nvoid *\nnv50_bar_dtor(struct nvkm_bar *base)\n{\n\tstruct nv50_bar *bar = nv50_bar(base);\n\tif (bar->mem) {\n\t\tnvkm_gpuobj_del(&bar->bar1);\n\t\tnvkm_vmm_part(bar->bar1_vmm, bar->mem->memory);\n\t\tnvkm_vmm_unref(&bar->bar1_vmm);\n\t\tnvkm_gpuobj_del(&bar->bar2);\n\t\tnvkm_vmm_part(bar->bar2_vmm, bar->mem->memory);\n\t\tnvkm_vmm_unref(&bar->bar2_vmm);\n\t\tnvkm_gpuobj_del(&bar->pgd);\n\t\tnvkm_gpuobj_del(&bar->pad);\n\t\tnvkm_gpuobj_del(&bar->mem);\n\t}\n\treturn bar;\n}\n\nint\nnv50_bar_new_(const struct nvkm_bar_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, u32 pgd_addr, struct nvkm_bar **pbar)\n{\n\tstruct nv50_bar *bar;\n\tif (!(bar = kzalloc(sizeof(*bar), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_bar_ctor(func, device, type, inst, &bar->base);\n\tbar->pgd_addr = pgd_addr;\n\t*pbar = &bar->base;\n\treturn 0;\n}\n\nstatic const struct nvkm_bar_func\nnv50_bar_func = {\n\t.dtor = nv50_bar_dtor,\n\t.oneinit = nv50_bar_oneinit,\n\t.init = nv50_bar_init,\n\t.bar1.init = nv50_bar_bar1_init,\n\t.bar1.fini = nv50_bar_bar1_fini,\n\t.bar1.wait = nv50_bar_bar1_wait,\n\t.bar1.vmm = nv50_bar_bar1_vmm,\n\t.bar2.init = nv50_bar_bar2_init,\n\t.bar2.fini = nv50_bar_bar2_fini,\n\t.bar2.wait = nv50_bar_bar1_wait,\n\t.bar2.vmm = nv50_bar_bar2_vmm,\n\t.flush = nv50_bar_flush,\n};\n\nint\nnv50_bar_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t     struct nvkm_bar **pbar)\n{\n\treturn nv50_bar_new_(&nv50_bar_func, device, type, inst, 0x1400, pbar);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}