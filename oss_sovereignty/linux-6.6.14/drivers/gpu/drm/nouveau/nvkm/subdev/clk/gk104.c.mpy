{
  "module_name": "gk104.c",
  "hash_id": "ab933e3b0f009f2ee2c4dd073ba557da84607371ad44af2868ef6537598d3ed2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/gk104.c",
  "human_readable_source": " \n#define gk104_clk(p) container_of((p), struct gk104_clk, base)\n#include \"priv.h\"\n#include \"pll.h\"\n\n#include <subdev/timer.h>\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n\nstruct gk104_clk_info {\n\tu32 freq;\n\tu32 ssel;\n\tu32 mdiv;\n\tu32 dsrc;\n\tu32 ddiv;\n\tu32 coef;\n};\n\nstruct gk104_clk {\n\tstruct nvkm_clk base;\n\tstruct gk104_clk_info eng[16];\n};\n\nstatic u32 read_div(struct gk104_clk *, int, u32, u32);\nstatic u32 read_pll(struct gk104_clk *, u32);\n\nstatic u32\nread_vco(struct gk104_clk *clk, u32 dsrc)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ssrc = nvkm_rd32(device, dsrc);\n\tif (!(ssrc & 0x00000100))\n\t\treturn read_pll(clk, 0x00e800);\n\treturn read_pll(clk, 0x00e820);\n}\n\nstatic u32\nread_pll(struct gk104_clk *clk, u32 pll)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ctrl = nvkm_rd32(device, pll + 0x00);\n\tu32 coef = nvkm_rd32(device, pll + 0x04);\n\tu32 P = (coef & 0x003f0000) >> 16;\n\tu32 N = (coef & 0x0000ff00) >> 8;\n\tu32 M = (coef & 0x000000ff) >> 0;\n\tu32 sclk;\n\tu16 fN = 0xf000;\n\n\tif (!(ctrl & 0x00000001))\n\t\treturn 0;\n\n\tswitch (pll) {\n\tcase 0x00e800:\n\tcase 0x00e820:\n\t\tsclk = device->crystal;\n\t\tP = 1;\n\t\tbreak;\n\tcase 0x132000:\n\t\tsclk = read_pll(clk, 0x132020);\n\t\tP = (coef & 0x10000000) ? 2 : 1;\n\t\tbreak;\n\tcase 0x132020:\n\t\tsclk = read_div(clk, 0, 0x137320, 0x137330);\n\t\tfN   = nvkm_rd32(device, pll + 0x10) >> 16;\n\t\tbreak;\n\tcase 0x137000:\n\tcase 0x137020:\n\tcase 0x137040:\n\tcase 0x1370e0:\n\t\tsclk = read_div(clk, (pll & 0xff) / 0x20, 0x137120, 0x137140);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (P == 0)\n\t\tP = 1;\n\n\tsclk = (sclk * N) + (((u16)(fN + 4096) * sclk) >> 13);\n\treturn sclk / (M * P);\n}\n\nstatic u32\nread_div(struct gk104_clk *clk, int doff, u32 dsrc, u32 dctl)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ssrc = nvkm_rd32(device, dsrc + (doff * 4));\n\tu32 sctl = nvkm_rd32(device, dctl + (doff * 4));\n\n\tswitch (ssrc & 0x00000003) {\n\tcase 0:\n\t\tif ((ssrc & 0x00030000) != 0x00030000)\n\t\t\treturn device->crystal;\n\t\treturn 108000;\n\tcase 2:\n\t\treturn 100000;\n\tcase 3:\n\t\tif (sctl & 0x80000000) {\n\t\t\tu32 sclk = read_vco(clk, dsrc + (doff * 4));\n\t\t\tu32 sdiv = (sctl & 0x0000003f) + 2;\n\t\t\treturn (sclk * 2) / sdiv;\n\t\t}\n\n\t\treturn read_vco(clk, dsrc + (doff * 4));\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32\nread_mem(struct gk104_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tswitch (nvkm_rd32(device, 0x1373f4) & 0x0000000f) {\n\tcase 1: return read_pll(clk, 0x132020);\n\tcase 2: return read_pll(clk, 0x132000);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32\nread_clk(struct gk104_clk *clk, int idx)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 sctl = nvkm_rd32(device, 0x137250 + (idx * 4));\n\tu32 sclk, sdiv;\n\n\tif (idx < 7) {\n\t\tu32 ssel = nvkm_rd32(device, 0x137100);\n\t\tif (ssel & (1 << idx)) {\n\t\t\tsclk = read_pll(clk, 0x137000 + (idx * 0x20));\n\t\t\tsdiv = 1;\n\t\t} else {\n\t\t\tsclk = read_div(clk, idx, 0x137160, 0x1371d0);\n\t\t\tsdiv = 0;\n\t\t}\n\t} else {\n\t\tu32 ssrc = nvkm_rd32(device, 0x137160 + (idx * 0x04));\n\t\tif ((ssrc & 0x00000003) == 0x00000003) {\n\t\t\tsclk = read_div(clk, idx, 0x137160, 0x1371d0);\n\t\t\tif (ssrc & 0x00000100) {\n\t\t\t\tif (ssrc & 0x40000000)\n\t\t\t\t\tsclk = read_pll(clk, 0x1370e0);\n\t\t\t\tsdiv = 1;\n\t\t\t} else {\n\t\t\t\tsdiv = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tsclk = read_div(clk, idx, 0x137160, 0x1371d0);\n\t\t\tsdiv = 0;\n\t\t}\n\t}\n\n\tif (sctl & 0x80000000) {\n\t\tif (sdiv)\n\t\t\tsdiv = ((sctl & 0x00003f00) >> 8) + 2;\n\t\telse\n\t\t\tsdiv = ((sctl & 0x0000003f) >> 0) + 2;\n\t\treturn (sclk * 2) / sdiv;\n\t}\n\n\treturn sclk;\n}\n\nstatic int\ngk104_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\n{\n\tstruct gk104_clk *clk = gk104_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\tswitch (src) {\n\tcase nv_clk_src_crystal:\n\t\treturn device->crystal;\n\tcase nv_clk_src_href:\n\t\treturn 100000;\n\tcase nv_clk_src_mem:\n\t\treturn read_mem(clk);\n\tcase nv_clk_src_gpc:\n\t\treturn read_clk(clk, 0x00);\n\tcase nv_clk_src_rop:\n\t\treturn read_clk(clk, 0x01);\n\tcase nv_clk_src_hubk07:\n\t\treturn read_clk(clk, 0x02);\n\tcase nv_clk_src_hubk06:\n\t\treturn read_clk(clk, 0x07);\n\tcase nv_clk_src_hubk01:\n\t\treturn read_clk(clk, 0x08);\n\tcase nv_clk_src_pmu:\n\t\treturn read_clk(clk, 0x0c);\n\tcase nv_clk_src_vdec:\n\t\treturn read_clk(clk, 0x0e);\n\tdefault:\n\t\tnvkm_error(subdev, \"invalid clock source %d\\n\", src);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32\ncalc_div(struct gk104_clk *clk, int idx, u32 ref, u32 freq, u32 *ddiv)\n{\n\tu32 div = min((ref * 2) / freq, (u32)65);\n\tif (div < 2)\n\t\tdiv = 2;\n\n\t*ddiv = div - 2;\n\treturn (ref * 2) / div;\n}\n\nstatic u32\ncalc_src(struct gk104_clk *clk, int idx, u32 freq, u32 *dsrc, u32 *ddiv)\n{\n\tu32 sclk;\n\n\t \n\t*ddiv = 0x00000000;\n\tswitch (freq) {\n\tcase  27000:\n\tcase 108000:\n\t\t*dsrc = 0x00000000;\n\t\tif (freq == 108000)\n\t\t\t*dsrc |= 0x00030000;\n\t\treturn freq;\n\tcase 100000:\n\t\t*dsrc = 0x00000002;\n\t\treturn freq;\n\tdefault:\n\t\t*dsrc = 0x00000003;\n\t\tbreak;\n\t}\n\n\t \n\tsclk = read_vco(clk, 0x137160 + (idx * 4));\n\tif (idx < 7)\n\t\tsclk = calc_div(clk, idx, sclk, freq, ddiv);\n\treturn sclk;\n}\n\nstatic u32\ncalc_pll(struct gk104_clk *clk, int idx, u32 freq, u32 *coef)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvbios_pll limits;\n\tint N, M, P, ret;\n\n\tret = nvbios_pll_parse(bios, 0x137000 + (idx * 0x20), &limits);\n\tif (ret)\n\t\treturn 0;\n\n\tlimits.refclk = read_div(clk, idx, 0x137120, 0x137140);\n\tif (!limits.refclk)\n\t\treturn 0;\n\n\tret = gt215_pll_calc(subdev, &limits, freq, &N, NULL, &M, &P);\n\tif (ret <= 0)\n\t\treturn 0;\n\n\t*coef = (P << 16) | (N << 8) | M;\n\treturn ret;\n}\n\nstatic int\ncalc_clk(struct gk104_clk *clk,\n\t struct nvkm_cstate *cstate, int idx, int dom)\n{\n\tstruct gk104_clk_info *info = &clk->eng[idx];\n\tu32 freq = cstate->domain[dom];\n\tu32 src0, div0, div1D, div1P = 0;\n\tu32 clk0, clk1 = 0;\n\n\t \n\tif (!freq)\n\t\treturn 0;\n\n\t \n\tclk0 = calc_src(clk, idx, freq, &src0, &div0);\n\tclk0 = calc_div(clk, idx, clk0, freq, &div1D);\n\n\t \n\tif (clk0 != freq && (0x0000ff87 & (1 << idx))) {\n\t\tif (idx <= 7)\n\t\t\tclk1 = calc_pll(clk, idx, freq, &info->coef);\n\t\telse\n\t\t\tclk1 = cstate->domain[nv_clk_src_hubk06];\n\t\tclk1 = calc_div(clk, idx, clk1, freq, &div1P);\n\t}\n\n\t \n\tif (abs((int)freq - clk0) <= abs((int)freq - clk1)) {\n\t\tinfo->dsrc = src0;\n\t\tif (div0) {\n\t\t\tinfo->ddiv |= 0x80000000;\n\t\t\tinfo->ddiv |= div0;\n\t\t}\n\t\tif (div1D) {\n\t\t\tinfo->mdiv |= 0x80000000;\n\t\t\tinfo->mdiv |= div1D;\n\t\t}\n\t\tinfo->ssel = 0;\n\t\tinfo->freq = clk0;\n\t} else {\n\t\tif (div1P) {\n\t\t\tinfo->mdiv |= 0x80000000;\n\t\t\tinfo->mdiv |= div1P << 8;\n\t\t}\n\t\tinfo->ssel = (1 << idx);\n\t\tinfo->dsrc = 0x40000100;\n\t\tinfo->freq = clk1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngk104_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct gk104_clk *clk = gk104_clk(base);\n\tint ret;\n\n\tif ((ret = calc_clk(clk, cstate, 0x00, nv_clk_src_gpc)) ||\n\t    (ret = calc_clk(clk, cstate, 0x01, nv_clk_src_rop)) ||\n\t    (ret = calc_clk(clk, cstate, 0x02, nv_clk_src_hubk07)) ||\n\t    (ret = calc_clk(clk, cstate, 0x07, nv_clk_src_hubk06)) ||\n\t    (ret = calc_clk(clk, cstate, 0x08, nv_clk_src_hubk01)) ||\n\t    (ret = calc_clk(clk, cstate, 0x0c, nv_clk_src_pmu)) ||\n\t    (ret = calc_clk(clk, cstate, 0x0e, nv_clk_src_vdec)))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\ngk104_clk_prog_0(struct gk104_clk *clk, int idx)\n{\n\tstruct gk104_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tif (!info->ssel) {\n\t\tnvkm_mask(device, 0x1371d0 + (idx * 0x04), 0x8000003f, info->ddiv);\n\t\tnvkm_wr32(device, 0x137160 + (idx * 0x04), info->dsrc);\n\t}\n}\n\nstatic void\ngk104_clk_prog_1_0(struct gk104_clk *clk, int idx)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tnvkm_mask(device, 0x137100, (1 << idx), 0x00000000);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x137100) & (1 << idx)))\n\t\t\tbreak;\n\t);\n}\n\nstatic void\ngk104_clk_prog_1_1(struct gk104_clk *clk, int idx)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tnvkm_mask(device, 0x137160 + (idx * 0x04), 0x00000100, 0x00000000);\n}\n\nstatic void\ngk104_clk_prog_2(struct gk104_clk *clk, int idx)\n{\n\tstruct gk104_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tconst u32 addr = 0x137000 + (idx * 0x20);\n\tnvkm_mask(device, addr + 0x00, 0x00000004, 0x00000000);\n\tnvkm_mask(device, addr + 0x00, 0x00000001, 0x00000000);\n\tif (info->coef) {\n\t\tnvkm_wr32(device, addr + 0x04, info->coef);\n\t\tnvkm_mask(device, addr + 0x00, 0x00000001, 0x00000001);\n\n\t\t \n\t\tnvkm_mask(device, addr + 0x00, 0x00000010, 0x00000000);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (nvkm_rd32(device, addr + 0x00) & 0x00020000)\n\t\t\t\tbreak;\n\t\t);\n\t\tnvkm_mask(device, addr + 0x00, 0x00000010, 0x00000010);\n\n\t\t \n\t\tnvkm_mask(device, addr + 0x00, 0x00000004, 0x00000004);\n\t}\n}\n\nstatic void\ngk104_clk_prog_3(struct gk104_clk *clk, int idx)\n{\n\tstruct gk104_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tif (info->ssel)\n\t\tnvkm_mask(device, 0x137250 + (idx * 0x04), 0x00003f00, info->mdiv);\n\telse\n\t\tnvkm_mask(device, 0x137250 + (idx * 0x04), 0x0000003f, info->mdiv);\n}\n\nstatic void\ngk104_clk_prog_4_0(struct gk104_clk *clk, int idx)\n{\n\tstruct gk104_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tif (info->ssel) {\n\t\tnvkm_mask(device, 0x137100, (1 << idx), info->ssel);\n\t\tnvkm_msec(device, 2000,\n\t\t\tu32 tmp = nvkm_rd32(device, 0x137100) & (1 << idx);\n\t\t\tif (tmp == info->ssel)\n\t\t\t\tbreak;\n\t\t);\n\t}\n}\n\nstatic void\ngk104_clk_prog_4_1(struct gk104_clk *clk, int idx)\n{\n\tstruct gk104_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tif (info->ssel) {\n\t\tnvkm_mask(device, 0x137160 + (idx * 0x04), 0x40000000, 0x40000000);\n\t\tnvkm_mask(device, 0x137160 + (idx * 0x04), 0x00000100, 0x00000100);\n\t}\n}\n\nstatic int\ngk104_clk_prog(struct nvkm_clk *base)\n{\n\tstruct gk104_clk *clk = gk104_clk(base);\n\tstruct {\n\t\tu32 mask;\n\t\tvoid (*exec)(struct gk104_clk *, int);\n\t} stage[] = {\n\t\t{ 0x007f, gk104_clk_prog_0   },  \n\t\t{ 0x007f, gk104_clk_prog_1_0 },  \n\t\t{ 0xff80, gk104_clk_prog_1_1 },\n\t\t{ 0x00ff, gk104_clk_prog_2   },  \n\t\t{ 0xff80, gk104_clk_prog_3   },  \n\t\t{ 0x007f, gk104_clk_prog_4_0 },  \n\t\t{ 0xff80, gk104_clk_prog_4_1 },\n\t};\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(stage); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(clk->eng); j++) {\n\t\t\tif (!(stage[i].mask & (1 << j)))\n\t\t\t\tcontinue;\n\t\t\tif (!clk->eng[j].freq)\n\t\t\t\tcontinue;\n\t\t\tstage[i].exec(clk, j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\ngk104_clk_tidy(struct nvkm_clk *base)\n{\n\tstruct gk104_clk *clk = gk104_clk(base);\n\tmemset(clk->eng, 0x00, sizeof(clk->eng));\n}\n\nstatic const struct nvkm_clk_func\ngk104_clk = {\n\t.read = gk104_clk_read,\n\t.calc = gk104_clk_calc,\n\t.prog = gk104_clk_prog,\n\t.tidy = gk104_clk_tidy,\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_href   , 0xff },\n\t\t{ nv_clk_src_gpc    , 0x00, NVKM_CLK_DOM_FLAG_CORE | NVKM_CLK_DOM_FLAG_VPSTATE, \"core\", 2000 },\n\t\t{ nv_clk_src_hubk07 , 0x01, NVKM_CLK_DOM_FLAG_CORE },\n\t\t{ nv_clk_src_rop    , 0x02, NVKM_CLK_DOM_FLAG_CORE },\n\t\t{ nv_clk_src_mem    , 0x03, 0, \"memory\", 500 },\n\t\t{ nv_clk_src_hubk06 , 0x04, NVKM_CLK_DOM_FLAG_CORE },\n\t\t{ nv_clk_src_hubk01 , 0x05 },\n\t\t{ nv_clk_src_vdec   , 0x06 },\n\t\t{ nv_clk_src_pmu    , 0x07 },\n\t\t{ nv_clk_src_max }\n\t}\n};\n\nint\ngk104_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_clk **pclk)\n{\n\tstruct gk104_clk *clk;\n\n\tif (!(clk = kzalloc(sizeof(*clk), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base;\n\n\treturn nvkm_clk_ctor(&gk104_clk, device, type, inst, true, &clk->base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}