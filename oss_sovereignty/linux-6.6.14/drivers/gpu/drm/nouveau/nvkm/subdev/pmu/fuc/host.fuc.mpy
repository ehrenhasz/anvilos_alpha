{
  "module_name": "host.fuc",
  "hash_id": "ec9c3709f865d3712ffaaa1b41857db06b2e61a86ace9317a56028d75e0a2ca8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/fuc/host.fuc",
  "human_readable_source": "/*\n * Copyright 2013 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n#ifdef INCLUDE_PROC\nprocess(PROC_HOST, #host_init, #host_recv)\n#endif\n\n/******************************************************************************\n * HOST data segment\n *****************************************************************************/\n#ifdef INCLUDE_DATA\n// HOST (R)FIFO packet format\n.equ #fifo_process 0x00\n.equ #fifo_message 0x04\n.equ #fifo_data0   0x08\n.equ #fifo_data1   0x0c\n\n// HOST HOST->PWR queue description\n.equ #fifo_qlen 4 // log2(size of queue entry in bytes)\n.equ #fifo_qnum 3 // log2(max number of entries in queue)\n.equ #fifo_qmaskb (1 << #fifo_qnum) // max number of entries in queue\n.equ #fifo_qmaskp (#fifo_qmaskb - 1)\n.equ #fifo_qmaskf ((#fifo_qmaskb << 1) - 1)\n.equ #fifo_qsize  (1 << (#fifo_qlen + #fifo_qnum))\nfifo_queue: .skip 128 // #fifo_qsize\n\n// HOST PWR->HOST queue description\n.equ #rfifo_qlen 4 // log2(size of queue entry in bytes)\n.equ #rfifo_qnum 3 // log2(max number of entries in queue)\n.equ #rfifo_qmaskb (1 << #rfifo_qnum) // max number of entries in queue\n.equ #rfifo_qmaskp (#rfifo_qmaskb - 1)\n.equ #rfifo_qmaskf ((#rfifo_qmaskb << 1) - 1)\n.equ #rfifo_qsize  (1 << (#rfifo_qlen + #rfifo_qnum))\nrfifo_queue: .skip 128 // #rfifo_qsize\n#endif\n\n/******************************************************************************\n * HOST code segment\n *****************************************************************************/\n#ifdef INCLUDE_CODE\n// HOST->PWR comms - dequeue message(s) for process(es) from FIFO\n//\n// $r15 - current (host)\n// $r0  - zero\nhost_send:\n\tnv_iord($r1, NV_PPWR_FIFO_GET(0))\n\tnv_iord($r2, NV_PPWR_FIFO_PUT(0))\n\tcmp b32 $r1 $r2\n\tbra e #host_send_done\n\t\t// calculate address of message\n\t\tand $r14 $r1 #fifo_qmaskp\n\t\tshl b32 $r14 $r14 #fifo_qlen\n\t\tadd b32 $r14 #fifo_queue\n\n\t\t// read message data, and pass to appropriate process\n\t\tld b32 $r11 D[$r14 + #fifo_data1]\n\t\tld b32 $r12 D[$r14 + #fifo_data0]\n\t\tld b32 $r13 D[$r14 + #fifo_message]\n\t\tld b32 $r14 D[$r14 + #fifo_process]\n\t\tcall(send)\n\n\t\t// increment GET\n\t\tadd b32 $r1 0x1\n\t\tand $r14 $r1 #fifo_qmaskf\n\t\tnv_iowr(NV_PPWR_FIFO_GET(0), $r14)\n\t\tbra #host_send\n\thost_send_done:\n\tret\n\n// PWR->HOST comms - enqueue message for HOST to RFIFO\n//\n// $r15 - current (host)\n// $r14 - process\n// $r13 - message\n// $r12 - message data 0\n// $r11 - message data 1\n// $r0  - zero\nhost_recv:\n\t// message from intr handler == HOST->PWR comms pending\n\timm32($r1, PROC_KERN)\n\tcmp b32 $r14 $r1\n\tbra e #host_send\n\n\t// wait for space in RFIFO\n\thost_recv_wait:\n\tnv_iord($r1, NV_PPWR_RFIFO_GET)\n\tnv_iord($r2, NV_PPWR_RFIFO_PUT)\n\txor $r1 #rfifo_qmaskb\n\tcmp b32 $r1 $r2\n\tbra e #host_recv_wait\n\n\tand $r3 $r2 #rfifo_qmaskp\n\tshl b32 $r3 #rfifo_qlen\n\tadd b32 $r3 #rfifo_queue\n\n\t// enqueue message\n\tst b32 D[$r3 + #fifo_data1] $r11\n\tst b32 D[$r3 + #fifo_data0] $r12\n\tst b32 D[$r3 + #fifo_message] $r13\n\tst b32 D[$r3 + #fifo_process] $r14\n\n\tadd b32 $r2 0x1\n\tand $r2 #rfifo_qmaskf\n\tnv_iowr(NV_PPWR_RFIFO_PUT, $r2)\n\n\t// notify host of pending message\n\tmov $r2 NV_PPWR_INTR_TRIGGER_USER0\n\tnv_iowr(NV_PPWR_INTR_TRIGGER, $r2)\n\tret\n\n// $r15 - current (host)\n// $r0  - zero\nhost_init:\n\t// store each fifo's base/size in H2D/D2H scratch regs\n\tmov $r1 #fifo_qsize\n\tshl b32 $r1 16\n\tor $r1 #fifo_queue\n\tnv_iowr(NV_PPWR_H2D, $r1);\n\n\tmov $r1 #rfifo_qsize\n\tshl b32 $r1 16\n\tor $r1 #rfifo_queue\n\tnv_iowr(NV_PPWR_D2H, $r1);\n\n\t// enable fifo subintr for first fifo\n\tmov $r1 1\n\tnv_iowr(NV_PPWR_FIFO_INTR_EN, $r1)\n\tret\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}