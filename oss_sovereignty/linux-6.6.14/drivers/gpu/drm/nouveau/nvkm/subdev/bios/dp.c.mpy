{
  "module_name": "dp.c",
  "hash_id": "a7cc857b1aead0f7c2832e14ec171c4738424238ce33ad3c22b29c9bdcc4660b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/dp.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/dp.h>\n\nu16\nnvbios_dp_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tstruct bit_entry d;\n\n\tif (!bit_entry(bios, 'd', &d)) {\n\t\tif (d.version == 1 && d.length >= 2) {\n\t\t\tu16 data = nvbios_rd16(bios, d.offset);\n\t\t\tif (data) {\n\t\t\t\t*ver = nvbios_rd08(bios, data + 0x00);\n\t\t\t\tswitch (*ver) {\n\t\t\t\tcase 0x20:\n\t\t\t\tcase 0x21:\n\t\t\t\tcase 0x30:\n\t\t\t\tcase 0x40:\n\t\t\t\tcase 0x41:\n\t\t\t\tcase 0x42:\n\t\t\t\t\t*hdr = nvbios_rd08(bios, data + 0x01);\n\t\t\t\t\t*len = nvbios_rd08(bios, data + 0x02);\n\t\t\t\t\t*cnt = nvbios_rd08(bios, data + 0x03);\n\t\t\t\t\treturn data;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0x0000;\n}\n\nstatic u16\nnvbios_dpout_entry(struct nvkm_bios *bios, u8 idx,\n\t\t   u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tu16 data = nvbios_dp_table(bios, ver, hdr, cnt, len);\n\tif (data && idx < *cnt) {\n\t\tu16 outp = nvbios_rd16(bios, data + *hdr + idx * *len);\n\t\tswitch (*ver * !!outp) {\n\t\tcase 0x20:\n\t\tcase 0x21:\n\t\tcase 0x30:\n\t\t\t*hdr = nvbios_rd08(bios, data + 0x04);\n\t\t\t*len = nvbios_rd08(bios, data + 0x05);\n\t\t\t*cnt = nvbios_rd08(bios, outp + 0x04);\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\tcase 0x41:\n\t\tcase 0x42:\n\t\t\t*hdr = nvbios_rd08(bios, data + 0x04);\n\t\t\t*cnt = 0;\n\t\t\t*len = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn outp;\n\t}\n\t*ver = 0x00;\n\treturn 0x0000;\n}\n\nu16\nnvbios_dpout_parse(struct nvkm_bios *bios, u8 idx,\n\t\t   u8 *ver, u8 *hdr, u8 *cnt, u8 *len,\n\t\t   struct nvbios_dpout *info)\n{\n\tu16 data = nvbios_dpout_entry(bios, idx, ver, hdr, cnt, len);\n\tmemset(info, 0x00, sizeof(*info));\n\tif (data && *ver) {\n\t\tinfo->type = nvbios_rd16(bios, data + 0x00);\n\t\tinfo->mask = nvbios_rd16(bios, data + 0x02);\n\t\tswitch (*ver) {\n\t\tcase 0x20:\n\t\t\tinfo->mask |= 0x00c0;  \n\t\t\tfallthrough;\n\t\tcase 0x21:\n\t\tcase 0x30:\n\t\t\tinfo->flags     = nvbios_rd08(bios, data + 0x05);\n\t\t\tinfo->script[0] = nvbios_rd16(bios, data + 0x06);\n\t\t\tinfo->script[1] = nvbios_rd16(bios, data + 0x08);\n\t\t\tif (*len >= 0x0c)\n\t\t\t\tinfo->lnkcmp    = nvbios_rd16(bios, data + 0x0a);\n\t\t\tif (*len >= 0x0f) {\n\t\t\t\tinfo->script[2] = nvbios_rd16(bios, data + 0x0c);\n\t\t\t\tinfo->script[3] = nvbios_rd16(bios, data + 0x0e);\n\t\t\t}\n\t\t\tif (*len >= 0x11)\n\t\t\t\tinfo->script[4] = nvbios_rd16(bios, data + 0x10);\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\tcase 0x41:\n\t\tcase 0x42:\n\t\t\tinfo->flags     = nvbios_rd08(bios, data + 0x04);\n\t\t\tinfo->script[0] = nvbios_rd16(bios, data + 0x05);\n\t\t\tinfo->script[1] = nvbios_rd16(bios, data + 0x07);\n\t\t\tinfo->lnkcmp    = nvbios_rd16(bios, data + 0x09);\n\t\t\tinfo->script[2] = nvbios_rd16(bios, data + 0x0b);\n\t\t\tinfo->script[3] = nvbios_rd16(bios, data + 0x0d);\n\t\t\tinfo->script[4] = nvbios_rd16(bios, data + 0x0f);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata = 0x0000;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn data;\n}\n\nu16\nnvbios_dpout_match(struct nvkm_bios *bios, u16 type, u16 mask,\n\t\t   u8 *ver, u8 *hdr, u8 *cnt, u8 *len,\n\t\t   struct nvbios_dpout *info)\n{\n\tu16 data, idx = 0;\n\twhile ((data = nvbios_dpout_parse(bios, idx++, ver, hdr, cnt, len, info)) || *ver) {\n\t\tif (data && info->type == type) {\n\t\t\tif ((info->mask & mask) == mask)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn data;\n}\n\nstatic u16\nnvbios_dpcfg_entry(struct nvkm_bios *bios, u16 outp, u8 idx,\n\t\t   u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tif (*ver >= 0x40) {\n\t\toutp = nvbios_dp_table(bios, ver, hdr, cnt, len);\n\t\t*hdr = *hdr + (*len * * cnt);\n\t\t*len = nvbios_rd08(bios, outp + 0x06);\n\t\t*cnt = nvbios_rd08(bios, outp + 0x07) *\n\t\t       nvbios_rd08(bios, outp + 0x05);\n\t}\n\n\tif (idx < *cnt)\n\t\treturn outp + *hdr + (idx * *len);\n\n\treturn 0x0000;\n}\n\nu16\nnvbios_dpcfg_parse(struct nvkm_bios *bios, u16 outp, u8 idx,\n\t\t   u8 *ver, u8 *hdr, u8 *cnt, u8 *len,\n\t\t   struct nvbios_dpcfg *info)\n{\n\tu16 data = nvbios_dpcfg_entry(bios, outp, idx, ver, hdr, cnt, len);\n\tmemset(info, 0x00, sizeof(*info));\n\tif (data) {\n\t\tswitch (*ver) {\n\t\tcase 0x20:\n\t\tcase 0x21:\n\t\t\tinfo->dc    = nvbios_rd08(bios, data + 0x02);\n\t\t\tinfo->pe    = nvbios_rd08(bios, data + 0x03);\n\t\t\tinfo->tx_pu = nvbios_rd08(bios, data + 0x04);\n\t\t\tbreak;\n\t\tcase 0x30:\n\t\tcase 0x40:\n\t\tcase 0x41:\n\t\t\tinfo->pc    = nvbios_rd08(bios, data + 0x00);\n\t\t\tinfo->dc    = nvbios_rd08(bios, data + 0x01);\n\t\t\tinfo->pe    = nvbios_rd08(bios, data + 0x02);\n\t\t\tinfo->tx_pu = nvbios_rd08(bios, data + 0x03);\n\t\t\tbreak;\n\t\tcase 0x42:\n\t\t\tinfo->dc    = nvbios_rd08(bios, data + 0x00);\n\t\t\tinfo->pe    = nvbios_rd08(bios, data + 0x01);\n\t\t\tinfo->tx_pu = nvbios_rd08(bios, data + 0x02);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata = 0x0000;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn data;\n}\n\nu16\nnvbios_dpcfg_match(struct nvkm_bios *bios, u16 outp, u8 pc, u8 vs, u8 pe,\n\t\t   u8 *ver, u8 *hdr, u8 *cnt, u8 *len,\n\t\t   struct nvbios_dpcfg *info)\n{\n\tu8 idx = 0xff;\n\tu16 data;\n\n\tif (*ver >= 0x30) {\n\t\tstatic const u8 vsoff[] = { 0, 4, 7, 9 };\n\t\tidx = (pc * 10) + vsoff[vs] + pe;\n\t\tif (*ver >= 0x40 && *ver <= 0x41 && *hdr >= 0x12)\n\t\t\tidx += nvbios_rd08(bios, outp + 0x11) * 40;\n\t\telse\n\t\tif (*ver >= 0x42)\n\t\t\tidx += nvbios_rd08(bios, outp + 0x11) * 10;\n\t} else {\n\t\twhile ((data = nvbios_dpcfg_entry(bios, outp, ++idx,\n\t\t\t\t\t\t  ver, hdr, cnt, len))) {\n\t\t\tif (nvbios_rd08(bios, data + 0x00) == vs &&\n\t\t\t    nvbios_rd08(bios, data + 0x01) == pe)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nvbios_dpcfg_parse(bios, outp, idx, ver, hdr, cnt, len, info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}