{
  "module_name": "base.c",
  "hash_id": "286db4653c9c91c90be340c4c793278564f39c538822fdaafaf998190ab6115f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n\nvoid\nnvkm_ltc_tags_clear(struct nvkm_device *device, u32 first, u32 count)\n{\n\tstruct nvkm_ltc *ltc = device->ltc;\n\tconst u32 limit = first + count - 1;\n\n\tBUG_ON((first > limit) || (limit >= ltc->num_tags));\n\n\tmutex_lock(&ltc->mutex);\n\tltc->func->cbc_clear(ltc, first, limit);\n\tltc->func->cbc_wait(ltc);\n\tmutex_unlock(&ltc->mutex);\n}\n\nint\nnvkm_ltc_zbc_color_get(struct nvkm_ltc *ltc, int index, const u32 color[4])\n{\n\tmemcpy(ltc->zbc_color[index], color, sizeof(ltc->zbc_color[index]));\n\tltc->func->zbc_clear_color(ltc, index, color);\n\treturn index;\n}\n\nint\nnvkm_ltc_zbc_depth_get(struct nvkm_ltc *ltc, int index, const u32 depth)\n{\n\tltc->zbc_depth[index] = depth;\n\tltc->func->zbc_clear_depth(ltc, index, depth);\n\treturn index;\n}\n\nint\nnvkm_ltc_zbc_stencil_get(struct nvkm_ltc *ltc, int index, const u32 stencil)\n{\n\tltc->zbc_stencil[index] = stencil;\n\tltc->func->zbc_clear_stencil(ltc, index, stencil);\n\treturn index;\n}\n\nvoid\nnvkm_ltc_invalidate(struct nvkm_ltc *ltc)\n{\n\tif (ltc->func->invalidate)\n\t\tltc->func->invalidate(ltc);\n}\n\nvoid\nnvkm_ltc_flush(struct nvkm_ltc *ltc)\n{\n\tif (ltc->func->flush)\n\t\tltc->func->flush(ltc);\n}\n\nstatic void\nnvkm_ltc_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_ltc *ltc = nvkm_ltc(subdev);\n\tltc->func->intr(ltc);\n}\n\nstatic int\nnvkm_ltc_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_ltc *ltc = nvkm_ltc(subdev);\n\treturn ltc->func->oneinit(ltc);\n}\n\nstatic int\nnvkm_ltc_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_ltc *ltc = nvkm_ltc(subdev);\n\tint i;\n\n\tfor (i = ltc->zbc_color_min; i <= ltc->zbc_color_max; i++)\n\t\tltc->func->zbc_clear_color(ltc, i, ltc->zbc_color[i]);\n\n\tfor (i = ltc->zbc_depth_min; i <= ltc->zbc_depth_max; i++) {\n\t\tltc->func->zbc_clear_depth(ltc, i, ltc->zbc_depth[i]);\n\t\tif (ltc->func->zbc_clear_stencil)\n\t\t\tltc->func->zbc_clear_stencil(ltc, i, ltc->zbc_stencil[i]);\n\t}\n\n\tltc->func->init(ltc);\n\treturn 0;\n}\n\nstatic void *\nnvkm_ltc_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_ltc *ltc = nvkm_ltc(subdev);\n\tnvkm_memory_unref(&ltc->tag_ram);\n\tmutex_destroy(&ltc->mutex);\n\treturn ltc;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_ltc = {\n\t.dtor = nvkm_ltc_dtor,\n\t.oneinit = nvkm_ltc_oneinit,\n\t.init = nvkm_ltc_init,\n\t.intr = nvkm_ltc_intr,\n};\n\nint\nnvkm_ltc_new_(const struct nvkm_ltc_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_ltc **pltc)\n{\n\tstruct nvkm_ltc *ltc;\n\n\tif (!(ltc = *pltc = kzalloc(sizeof(*ltc), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_subdev_ctor(&nvkm_ltc, device, type, inst, &ltc->subdev);\n\tltc->func = func;\n\tmutex_init(&ltc->mutex);\n\tltc->zbc_color_min = 1;  \n\tltc->zbc_color_max = min(func->zbc_color, NVKM_LTC_MAX_ZBC_COLOR_CNT) - 1;\n\tltc->zbc_depth_min = 1;  \n\tltc->zbc_depth_max = min(func->zbc_depth, NVKM_LTC_MAX_ZBC_DEPTH_CNT) - 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}