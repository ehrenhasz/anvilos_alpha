{
  "module_name": "pll.c",
  "hash_id": "4c22d1d08d379c32093c72a2c33811642c8f8d88aa5434d0ccfddbc3d0611b76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/pll.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/bmp.h>\n#include <subdev/bios/pll.h>\n#include <subdev/vga.h>\n\n\nstruct pll_mapping {\n\tu8  type;\n\tu32 reg;\n};\n\nstatic struct pll_mapping\nnv04_pll_mapping[] = {\n\t{ PLL_CORE  , 0x680500 },\n\t{ PLL_MEMORY, 0x680504 },\n\t{ PLL_VPLL0 , 0x680508 },\n\t{ PLL_VPLL1 , 0x680520 },\n\t{}\n};\n\nstatic struct pll_mapping\nnv40_pll_mapping[] = {\n\t{ PLL_CORE  , 0x004000 },\n\t{ PLL_MEMORY, 0x004020 },\n\t{ PLL_VPLL0 , 0x680508 },\n\t{ PLL_VPLL1 , 0x680520 },\n\t{}\n};\n\nstatic struct pll_mapping\nnv50_pll_mapping[] = {\n\t{ PLL_CORE  , 0x004028 },\n\t{ PLL_SHADER, 0x004020 },\n\t{ PLL_UNK03 , 0x004000 },\n\t{ PLL_MEMORY, 0x004008 },\n\t{ PLL_UNK40 , 0x00e810 },\n\t{ PLL_UNK41 , 0x00e818 },\n\t{ PLL_UNK42 , 0x00e824 },\n\t{ PLL_VPLL0 , 0x614100 },\n\t{ PLL_VPLL1 , 0x614900 },\n\t{}\n};\n\nstatic struct pll_mapping\ng84_pll_mapping[] = {\n\t{ PLL_CORE  , 0x004028 },\n\t{ PLL_SHADER, 0x004020 },\n\t{ PLL_MEMORY, 0x004008 },\n\t{ PLL_VDEC  , 0x004030 },\n\t{ PLL_UNK41 , 0x00e818 },\n\t{ PLL_VPLL0 , 0x614100 },\n\t{ PLL_VPLL1 , 0x614900 },\n\t{}\n};\n\nstatic u32\npll_limits_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tstruct bit_entry bit_C;\n\tu32 data = 0x0000;\n\n\tif (!bit_entry(bios, 'C', &bit_C)) {\n\t\tif (bit_C.version == 1 && bit_C.length >= 10)\n\t\t\tdata = nvbios_rd16(bios, bit_C.offset + 8);\n\t\tif (bit_C.version == 2 && bit_C.length >= 4)\n\t\t\tdata = nvbios_rd32(bios, bit_C.offset + 0);\n\t\tif (data) {\n\t\t\t*ver = nvbios_rd08(bios, data + 0);\n\t\t\t*hdr = nvbios_rd08(bios, data + 1);\n\t\t\t*len = nvbios_rd08(bios, data + 2);\n\t\t\t*cnt = nvbios_rd08(bios, data + 3);\n\t\t\treturn data;\n\t\t}\n\t}\n\n\tif (bmp_version(bios) >= 0x0524) {\n\t\tdata = nvbios_rd16(bios, bios->bmp_offset + 142);\n\t\tif (data) {\n\t\t\t*ver = nvbios_rd08(bios, data + 0);\n\t\t\t*hdr = 1;\n\t\t\t*cnt = 1;\n\t\t\t*len = 0x18;\n\t\t\treturn data;\n\t\t}\n\t}\n\n\t*ver = 0x00;\n\treturn data;\n}\n\nstatic struct pll_mapping *\npll_map(struct nvkm_bios *bios)\n{\n\tstruct nvkm_device *device = bios->subdev.device;\n\tswitch (device->card_type) {\n\tcase NV_04:\n\tcase NV_10:\n\tcase NV_11:\n\tcase NV_20:\n\tcase NV_30:\n\t\treturn nv04_pll_mapping;\n\tcase NV_40:\n\t\treturn nv40_pll_mapping;\n\tcase NV_50:\n\t\tif (device->chipset == 0x50)\n\t\t\treturn nv50_pll_mapping;\n\t\telse\n\t\tif (device->chipset <  0xa3 ||\n\t\t    device->chipset == 0xaa ||\n\t\t    device->chipset == 0xac)\n\t\t\treturn g84_pll_mapping;\n\t\tfallthrough;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic u32\npll_map_reg(struct nvkm_bios *bios, u32 reg, u32 *type, u8 *ver, u8 *len)\n{\n\tstruct pll_mapping *map;\n\tu8  hdr, cnt;\n\tu32 data;\n\n\tdata = pll_limits_table(bios, ver, &hdr, &cnt, len);\n\tif (data && *ver >= 0x30) {\n\t\tdata += hdr;\n\t\twhile (cnt--) {\n\t\t\tif (nvbios_rd32(bios, data + 3) == reg) {\n\t\t\t\t*type = nvbios_rd08(bios, data + 0);\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\tdata += *len;\n\t\t}\n\t\treturn 0x0000;\n\t}\n\n\tmap = pll_map(bios);\n\twhile (map && map->reg) {\n\t\tif (map->reg == reg && *ver >= 0x20) {\n\t\t\tu32 addr = (data += hdr);\n\t\t\t*type = map->type;\n\t\t\twhile (cnt--) {\n\t\t\t\tif (nvbios_rd32(bios, data) == map->reg)\n\t\t\t\t\treturn data;\n\t\t\t\tdata += *len;\n\t\t\t}\n\t\t\treturn addr;\n\t\t} else\n\t\tif (map->reg == reg) {\n\t\t\t*type = map->type;\n\t\t\treturn data + 1;\n\t\t}\n\t\tmap++;\n\t}\n\n\treturn 0x0000;\n}\n\nstatic u32\npll_map_type(struct nvkm_bios *bios, u8 type, u32 *reg, u8 *ver, u8 *len)\n{\n\tstruct pll_mapping *map;\n\tu8  hdr, cnt;\n\tu32 data;\n\n\tdata = pll_limits_table(bios, ver, &hdr, &cnt, len);\n\tif (data && *ver >= 0x30) {\n\t\tdata += hdr;\n\t\twhile (cnt--) {\n\t\t\tif (nvbios_rd08(bios, data + 0) == type) {\n\t\t\t\tif (*ver < 0x50)\n\t\t\t\t\t*reg = nvbios_rd32(bios, data + 3);\n\t\t\t\telse\n\t\t\t\t\t*reg = 0;\n\t\t\t\treturn data;\n\t\t\t}\n\t\t\tdata += *len;\n\t\t}\n\t\treturn 0x0000;\n\t}\n\n\tmap = pll_map(bios);\n\twhile (map && map->reg) {\n\t\tif (map->type == type && *ver >= 0x20) {\n\t\t\tu32 addr = (data += hdr);\n\t\t\t*reg = map->reg;\n\t\t\twhile (cnt--) {\n\t\t\t\tif (nvbios_rd32(bios, data) == map->reg)\n\t\t\t\t\treturn data;\n\t\t\t\tdata += *len;\n\t\t\t}\n\t\t\treturn addr;\n\t\t} else\n\t\tif (map->type == type) {\n\t\t\t*reg = map->reg;\n\t\t\treturn data + 1;\n\t\t}\n\t\tmap++;\n\t}\n\n\treturn 0x0000;\n}\n\nint\nnvbios_pll_parse(struct nvkm_bios *bios, u32 type, struct nvbios_pll *info)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu8  ver, len;\n\tu32 reg = type;\n\tu32 data;\n\n\tif (type > PLL_MAX) {\n\t\treg  = type;\n\t\tdata = pll_map_reg(bios, reg, &type, &ver, &len);\n\t} else {\n\t\tdata = pll_map_type(bios, type, &reg, &ver, &len);\n\t}\n\n\tif (ver && !data)\n\t\treturn -ENOENT;\n\n\tmemset(info, 0, sizeof(*info));\n\tinfo->type = type;\n\tinfo->reg = reg;\n\n\tswitch (ver) {\n\tcase 0x00:\n\t\tbreak;\n\tcase 0x10:\n\tcase 0x11:\n\t\tinfo->vco1.min_freq = nvbios_rd32(bios, data + 0);\n\t\tinfo->vco1.max_freq = nvbios_rd32(bios, data + 4);\n\t\tinfo->vco2.min_freq = nvbios_rd32(bios, data + 8);\n\t\tinfo->vco2.max_freq = nvbios_rd32(bios, data + 12);\n\t\tinfo->vco1.min_inputfreq = nvbios_rd32(bios, data + 16);\n\t\tinfo->vco2.min_inputfreq = nvbios_rd32(bios, data + 20);\n\t\tinfo->vco1.max_inputfreq = INT_MAX;\n\t\tinfo->vco2.max_inputfreq = INT_MAX;\n\n\t\tinfo->max_p = 0x7;\n\t\tinfo->max_p_usable = 0x6;\n\n\t\t \n\t\tswitch (bios->version.chip) {\n\t\tcase 0x36:\n\t\t\tinfo->vco1.min_n = 0x5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->vco1.min_n = 0x1;\n\t\t\tbreak;\n\t\t}\n\t\tinfo->vco1.max_n = 0xff;\n\t\tinfo->vco1.min_m = 0x1;\n\t\tinfo->vco1.max_m = 0xd;\n\n\t\t \n\t\tinfo->vco2.min_n = 0x4;\n\t\tswitch (bios->version.chip) {\n\t\tcase 0x30:\n\t\tcase 0x35:\n\t\t\tinfo->vco2.max_n = 0x1f;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinfo->vco2.max_n = 0x28;\n\t\t\tbreak;\n\t\t}\n\t\tinfo->vco2.min_m = 0x1;\n\t\tinfo->vco2.max_m = 0x4;\n\t\tbreak;\n\tcase 0x20:\n\tcase 0x21:\n\t\tinfo->vco1.min_freq = nvbios_rd16(bios, data + 4) * 1000;\n\t\tinfo->vco1.max_freq = nvbios_rd16(bios, data + 6) * 1000;\n\t\tinfo->vco2.min_freq = nvbios_rd16(bios, data + 8) * 1000;\n\t\tinfo->vco2.max_freq = nvbios_rd16(bios, data + 10) * 1000;\n\t\tinfo->vco1.min_inputfreq = nvbios_rd16(bios, data + 12) * 1000;\n\t\tinfo->vco2.min_inputfreq = nvbios_rd16(bios, data + 14) * 1000;\n\t\tinfo->vco1.max_inputfreq = nvbios_rd16(bios, data + 16) * 1000;\n\t\tinfo->vco2.max_inputfreq = nvbios_rd16(bios, data + 18) * 1000;\n\t\tinfo->vco1.min_n = nvbios_rd08(bios, data + 20);\n\t\tinfo->vco1.max_n = nvbios_rd08(bios, data + 21);\n\t\tinfo->vco1.min_m = nvbios_rd08(bios, data + 22);\n\t\tinfo->vco1.max_m = nvbios_rd08(bios, data + 23);\n\t\tinfo->vco2.min_n = nvbios_rd08(bios, data + 24);\n\t\tinfo->vco2.max_n = nvbios_rd08(bios, data + 25);\n\t\tinfo->vco2.min_m = nvbios_rd08(bios, data + 26);\n\t\tinfo->vco2.max_m = nvbios_rd08(bios, data + 27);\n\n\t\tinfo->max_p = nvbios_rd08(bios, data + 29);\n\t\tinfo->max_p_usable = info->max_p;\n\t\tif (bios->version.chip < 0x60)\n\t\t\tinfo->max_p_usable = 0x6;\n\t\tinfo->bias_p = nvbios_rd08(bios, data + 30);\n\n\t\tif (len > 0x22)\n\t\t\tinfo->refclk = nvbios_rd32(bios, data + 31);\n\t\tbreak;\n\tcase 0x30:\n\t\tdata = nvbios_rd16(bios, data + 1);\n\n\t\tinfo->vco1.min_freq = nvbios_rd16(bios, data + 0) * 1000;\n\t\tinfo->vco1.max_freq = nvbios_rd16(bios, data + 2) * 1000;\n\t\tinfo->vco2.min_freq = nvbios_rd16(bios, data + 4) * 1000;\n\t\tinfo->vco2.max_freq = nvbios_rd16(bios, data + 6) * 1000;\n\t\tinfo->vco1.min_inputfreq = nvbios_rd16(bios, data + 8) * 1000;\n\t\tinfo->vco2.min_inputfreq = nvbios_rd16(bios, data + 10) * 1000;\n\t\tinfo->vco1.max_inputfreq = nvbios_rd16(bios, data + 12) * 1000;\n\t\tinfo->vco2.max_inputfreq = nvbios_rd16(bios, data + 14) * 1000;\n\t\tinfo->vco1.min_n = nvbios_rd08(bios, data + 16);\n\t\tinfo->vco1.max_n = nvbios_rd08(bios, data + 17);\n\t\tinfo->vco1.min_m = nvbios_rd08(bios, data + 18);\n\t\tinfo->vco1.max_m = nvbios_rd08(bios, data + 19);\n\t\tinfo->vco2.min_n = nvbios_rd08(bios, data + 20);\n\t\tinfo->vco2.max_n = nvbios_rd08(bios, data + 21);\n\t\tinfo->vco2.min_m = nvbios_rd08(bios, data + 22);\n\t\tinfo->vco2.max_m = nvbios_rd08(bios, data + 23);\n\t\tinfo->max_p_usable = info->max_p = nvbios_rd08(bios, data + 25);\n\t\tinfo->bias_p = nvbios_rd08(bios, data + 27);\n\t\tinfo->refclk = nvbios_rd32(bios, data + 28);\n\t\tbreak;\n\tcase 0x40:\n\t\tinfo->refclk = nvbios_rd16(bios, data + 9) * 1000;\n\t\tdata = nvbios_rd16(bios, data + 1);\n\n\t\tinfo->vco1.min_freq = nvbios_rd16(bios, data + 0) * 1000;\n\t\tinfo->vco1.max_freq = nvbios_rd16(bios, data + 2) * 1000;\n\t\tinfo->vco1.min_inputfreq = nvbios_rd16(bios, data + 4) * 1000;\n\t\tinfo->vco1.max_inputfreq = nvbios_rd16(bios, data + 6) * 1000;\n\t\tinfo->vco1.min_m = nvbios_rd08(bios, data + 8);\n\t\tinfo->vco1.max_m = nvbios_rd08(bios, data + 9);\n\t\tinfo->vco1.min_n = nvbios_rd08(bios, data + 10);\n\t\tinfo->vco1.max_n = nvbios_rd08(bios, data + 11);\n\t\tinfo->min_p = nvbios_rd08(bios, data + 12);\n\t\tinfo->max_p = nvbios_rd08(bios, data + 13);\n\t\tbreak;\n\tcase 0x50:\n\t\tinfo->refclk = nvbios_rd16(bios, data + 1) * 1000;\n\t\t \n\t\tinfo->vco1.min_freq = nvbios_rd16(bios, data + 5) * 1000;\n\t\tinfo->vco1.max_freq = nvbios_rd16(bios, data + 7) * 1000;\n\t\tinfo->vco1.min_inputfreq = nvbios_rd16(bios, data + 9) * 1000;\n\t\tinfo->vco1.max_inputfreq = nvbios_rd16(bios, data + 11) * 1000;\n\t\tinfo->vco1.min_m = nvbios_rd08(bios, data + 13);\n\t\tinfo->vco1.max_m = nvbios_rd08(bios, data + 14);\n\t\tinfo->vco1.min_n = nvbios_rd08(bios, data + 15);\n\t\tinfo->vco1.max_n = nvbios_rd08(bios, data + 16);\n\t\tinfo->min_p = nvbios_rd08(bios, data + 17);\n\t\tinfo->max_p = nvbios_rd08(bios, data + 18);\n\t\tbreak;\n\tdefault:\n\t\tnvkm_error(subdev, \"unknown pll limits version 0x%02x\\n\", ver);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!info->refclk) {\n\t\tinfo->refclk = device->crystal;\n\t\tif (bios->version.chip == 0x51) {\n\t\t\tu32 sel_clk = nvkm_rd32(device, 0x680524);\n\t\t\tif ((info->reg == 0x680508 && sel_clk & 0x20) ||\n\t\t\t    (info->reg == 0x680520 && sel_clk & 0x80)) {\n\t\t\t\tif (nvkm_rdvgac(device, 0, 0x27) < 0xa3)\n\t\t\t\t\tinfo->refclk = 200000;\n\t\t\t\telse\n\t\t\t\t\tinfo->refclk = 25000;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!info->vco1.max_freq) {\n\t\tinfo->vco1.max_freq = nvbios_rd32(bios, bios->bmp_offset + 67);\n\t\tinfo->vco1.min_freq = nvbios_rd32(bios, bios->bmp_offset + 71);\n\t\tif (bmp_version(bios) < 0x0506) {\n\t\t\tinfo->vco1.max_freq = 256000;\n\t\t\tinfo->vco1.min_freq = 128000;\n\t\t}\n\n\t\tinfo->vco1.min_inputfreq = 0;\n\t\tinfo->vco1.max_inputfreq = INT_MAX;\n\t\tinfo->vco1.min_n = 0x1;\n\t\tinfo->vco1.max_n = 0xff;\n\t\tinfo->vco1.min_m = 0x1;\n\n\t\tif (device->crystal == 13500) {\n\t\t\t \n\t\t\tif (bios->version.chip < 0x11)\n\t\t\t\tinfo->vco1.min_m = 0x7;\n\t\t\tinfo->vco1.max_m = 0xd;\n\t\t} else {\n\t\t\tif (bios->version.chip < 0x11)\n\t\t\t\tinfo->vco1.min_m = 0x8;\n\t\t\tinfo->vco1.max_m = 0xe;\n\t\t}\n\n\t\tif (bios->version.chip <  0x17 ||\n\t\t    bios->version.chip == 0x1a ||\n\t\t    bios->version.chip == 0x20)\n\t\t\tinfo->max_p = 4;\n\t\telse\n\t\t\tinfo->max_p = 5;\n\t\tinfo->max_p_usable = info->max_p;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}