{
  "module_name": "therm.c",
  "hash_id": "af29900c6c07ec9dc0af45446e70d927664209fab255a4295ffde8039cc5c76a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/therm.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/therm.h>\n\nstatic u32\ntherm_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *len, u8 *cnt)\n{\n\tstruct bit_entry bit_P;\n\tu32 therm = 0;\n\n\tif (!bit_entry(bios, 'P', &bit_P)) {\n\t\tif (bit_P.version == 1)\n\t\t\ttherm = nvbios_rd32(bios, bit_P.offset + 12);\n\t\telse if (bit_P.version == 2)\n\t\t\ttherm = nvbios_rd32(bios, bit_P.offset + 16);\n\t\telse\n\t\t\tnvkm_error(&bios->subdev,\n\t\t\t\t   \"unknown offset for thermal in BIT P %d\\n\",\n\t\t\t\t   bit_P.version);\n\t}\n\n\t \n\tif (!therm)\n\t\treturn 0;\n\n\t*ver = nvbios_rd08(bios, therm + 0);\n\t*hdr = nvbios_rd08(bios, therm + 1);\n\t*len = nvbios_rd08(bios, therm + 2);\n\t*cnt = nvbios_rd08(bios, therm + 3);\n\treturn therm + nvbios_rd08(bios, therm + 1);\n}\n\nstatic u32\nnvbios_therm_entry(struct nvkm_bios *bios, int idx, u8 *ver, u8 *len)\n{\n\tu8 hdr, cnt;\n\tu32 therm = therm_table(bios, ver, &hdr, len, &cnt);\n\tif (therm && idx < cnt)\n\t\treturn therm + idx * *len;\n\treturn 0;\n}\n\nint\nnvbios_therm_sensor_parse(struct nvkm_bios *bios,\n\t\t\t  enum nvbios_therm_domain domain,\n\t\t\t  struct nvbios_therm_sensor *sensor)\n{\n\ts8 thrs_section, sensor_section, offset;\n\tu8 ver, len, i;\n\tu32 entry;\n\n\t \n\tif (domain != NVBIOS_THERM_DOMAIN_CORE)\n\t\treturn -EINVAL;\n\n\t \n\tthrs_section = 0;\n\tsensor_section = -1;\n\ti = 0;\n\twhile ((entry = nvbios_therm_entry(bios, i++, &ver, &len))) {\n\t\ts16 value = nvbios_rd16(bios, entry + 1);\n\n\t\tswitch (nvbios_rd08(bios, entry + 0)) {\n\t\tcase 0x0:\n\t\t\tthrs_section = value;\n\t\t\tif (value > 0)\n\t\t\t\treturn 0;  \n\t\t\tbreak;\n\t\tcase 0x01:\n\t\t\tsensor_section++;\n\t\t\tif (sensor_section == 0) {\n\t\t\t\toffset = ((s8) nvbios_rd08(bios, entry + 2)) / 2;\n\t\t\t\tsensor->offset_constant = offset;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x04:\n\t\t\tif (thrs_section == 0) {\n\t\t\t\tsensor->thrs_critical.temp = (value & 0xff0) >> 4;\n\t\t\t\tsensor->thrs_critical.hysteresis = value & 0xf;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x07:\n\t\t\tif (thrs_section == 0) {\n\t\t\t\tsensor->thrs_down_clock.temp = (value & 0xff0) >> 4;\n\t\t\t\tsensor->thrs_down_clock.hysteresis = value & 0xf;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\tif (thrs_section == 0) {\n\t\t\t\tsensor->thrs_fan_boost.temp = (value & 0xff0) >> 4;\n\t\t\t\tsensor->thrs_fan_boost.hysteresis = value & 0xf;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 0x10:\n\t\t\tif (sensor_section == 0)\n\t\t\t\tsensor->offset_num = value;\n\t\t\tbreak;\n\n\t\tcase 0x11:\n\t\t\tif (sensor_section == 0)\n\t\t\t\tsensor->offset_den = value;\n\t\t\tbreak;\n\n\t\tcase 0x12:\n\t\t\tif (sensor_section == 0)\n\t\t\t\tsensor->slope_mult = value;\n\t\t\tbreak;\n\n\t\tcase 0x13:\n\t\t\tif (sensor_section == 0)\n\t\t\t\tsensor->slope_div = value;\n\t\t\tbreak;\n\t\tcase 0x32:\n\t\t\tif (thrs_section == 0) {\n\t\t\t\tsensor->thrs_shutdown.temp = (value & 0xff0) >> 4;\n\t\t\t\tsensor->thrs_shutdown.hysteresis = value & 0xf;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nnvbios_therm_fan_parse(struct nvkm_bios *bios, struct nvbios_therm_fan *fan)\n{\n\tstruct nvbios_therm_trip_point *cur_trip = NULL;\n\tu8 ver, len, i;\n\tu32 entry;\n\n\tuint8_t duty_lut[] = { 0, 0, 25, 0, 40, 0, 50, 0,\n\t\t\t\t75, 0, 85, 0, 100, 0, 100, 0 };\n\n\ti = 0;\n\tfan->nr_fan_trip = 0;\n\tfan->fan_mode = NVBIOS_THERM_FAN_OTHER;\n\twhile ((entry = nvbios_therm_entry(bios, i++, &ver, &len))) {\n\t\ts16 value = nvbios_rd16(bios, entry + 1);\n\n\t\tswitch (nvbios_rd08(bios, entry + 0)) {\n\t\tcase 0x22:\n\t\t\tfan->min_duty = value & 0xff;\n\t\t\tfan->max_duty = (value & 0xff00) >> 8;\n\t\t\tbreak;\n\t\tcase 0x24:\n\t\t\tfan->nr_fan_trip++;\n\t\t\tif (fan->fan_mode > NVBIOS_THERM_FAN_TRIP)\n\t\t\t\tfan->fan_mode = NVBIOS_THERM_FAN_TRIP;\n\t\t\tcur_trip = &fan->trip[fan->nr_fan_trip - 1];\n\t\t\tcur_trip->hysteresis = value & 0xf;\n\t\t\tcur_trip->temp = (value & 0xff0) >> 4;\n\t\t\tcur_trip->fan_duty = duty_lut[(value & 0xf000) >> 12];\n\t\t\tbreak;\n\t\tcase 0x25:\n\t\t\tcur_trip = &fan->trip[fan->nr_fan_trip - 1];\n\t\t\tcur_trip->fan_duty = value;\n\t\t\tbreak;\n\t\tcase 0x26:\n\t\t\tif (!fan->pwm_freq)\n\t\t\t\tfan->pwm_freq = value;\n\t\t\tbreak;\n\t\tcase 0x3b:\n\t\t\tfan->bump_period = value;\n\t\t\tbreak;\n\t\tcase 0x3c:\n\t\t\tfan->slow_down_period = value;\n\t\t\tbreak;\n\t\tcase 0x46:\n\t\t\tif (fan->fan_mode > NVBIOS_THERM_FAN_LINEAR)\n\t\t\t\tfan->fan_mode = NVBIOS_THERM_FAN_LINEAR;\n\t\t\tfan->linear_min_temp = nvbios_rd08(bios, entry + 1);\n\t\t\tfan->linear_max_temp = nvbios_rd08(bios, entry + 2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (bios->subdev.device->card_type >= NV_C0 &&\n\t\tfan->fan_mode == NVBIOS_THERM_FAN_OTHER) {\n\t\tfan->fan_mode = NVBIOS_THERM_FAN_LINEAR;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}