{
  "module_name": "nv50.c",
  "hash_id": "24fae106a0320d5830d5ff9cc4c526b3e67826ae37a06cec81188df92df0e819",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/nv50.c",
  "human_readable_source": " \n#include \"mxms.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/conn.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/bios/mxm.h>\n\nstruct context {\n\tu32 *outp;\n\tstruct mxms_odev desc;\n};\n\nstatic bool\nmxm_match_tmds_partner(struct nvkm_mxm *mxm, u8 *data, void *info)\n{\n\tstruct context *ctx = info;\n\tstruct mxms_odev desc;\n\n\tmxms_output_device(mxm, data, &desc);\n\tif (desc.outp_type == 2 &&\n\t    desc.dig_conn == ctx->desc.dig_conn)\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool\nmxm_match_dcb(struct nvkm_mxm *mxm, u8 *data, void *info)\n{\n\tstruct nvkm_bios *bios = mxm->subdev.device->bios;\n\tstruct context *ctx = info;\n\tu64 desc = *(u64 *)data;\n\n\tmxms_output_device(mxm, data, &ctx->desc);\n\n\t \n\tif ((ctx->outp[0] & 0x0000000f) != ctx->desc.outp_type)\n\t\treturn true;\n\n\t \n\tif ((desc & 0x00000000000000f0) >= 0x20) {\n\t\t \n\t\tu8 link = mxm_sor_map(bios, ctx->desc.dig_conn);\n\t\tif ((ctx->outp[0] & 0x0f000000) != (link & 0x0f) << 24)\n\t\t\treturn true;\n\n\t\t \n\t\tlink = (link & 0x30) >> 4;\n\t\tif ((link & ((ctx->outp[1] & 0x00000030) >> 4)) != link)\n\t\t\treturn true;\n\t}\n\n\t \n\tdata[0] &= ~0xf0;\n\tif (ctx->desc.outp_type == 6 && ctx->desc.conn_type == 6 &&\n\t    mxms_foreach(mxm, 0x01, mxm_match_tmds_partner, ctx)) {\n\t\tdata[0] |= 0x20;  \n\t} else {\n\t\tdata[0] |= 0xf0;\n\t}\n\n\treturn false;\n}\n\nstatic int\nmxm_dcb_sanitise_entry(struct nvkm_bios *bios, void *data, int idx, u16 pdcb)\n{\n\tstruct nvkm_mxm *mxm = data;\n\tstruct context ctx = { .outp = (u32 *)(bios->data + pdcb) };\n\tu8 type, i2cidx, link, ver, len;\n\tu8 *conn;\n\n\t \n\tif (mxms_foreach(mxm, 0x01, mxm_match_dcb, &ctx)) {\n\t\tnvkm_debug(&mxm->subdev, \"disable %d: %08x %08x\\n\",\n\t\t\t   idx, ctx.outp[0], ctx.outp[1]);\n\t\tctx.outp[0] |= 0x0000000f;\n\t\treturn 0;\n\t}\n\n\t \n\ti2cidx = mxm_ddc_map(bios, ctx.desc.ddc_port);\n\tif ((ctx.outp[0] & 0x0000000f) != DCB_OUTPUT_DP)\n\t\ti2cidx = (i2cidx & 0x0f) << 4;\n\telse\n\t\ti2cidx = (i2cidx & 0xf0);\n\n\tif (i2cidx != 0xf0) {\n\t\tctx.outp[0] &= ~0x000000f0;\n\t\tctx.outp[0] |= i2cidx;\n\t}\n\n\t \n\tswitch (ctx.desc.outp_type) {\n\tcase 0x00:  \n\tcase 0x01:  \n\t\tbreak;\n\tdefault:\n\t\tlink = mxm_sor_map(bios, ctx.desc.dig_conn) & 0x30;\n\t\tctx.outp[1] &= ~0x00000030;\n\t\tctx.outp[1] |= link;\n\t\tbreak;\n\t}\n\n\t \n\tconn  = bios->data;\n\tconn += nvbios_connEe(bios, (ctx.outp[0] & 0x0000f000) >> 12, &ver, &len);\n\ttype  = conn[0];\n\tswitch (ctx.desc.conn_type) {\n\tcase 0x01:  \n\t\tctx.outp[1] |= 0x00000004;  \n\t\t \n\t\tbreak;\n\tcase 0x02:  \n\t\ttype = DCB_CONNECTOR_HDMI_1;\n\t\tbreak;\n\tcase 0x03:  \n\t\ttype = DCB_CONNECTOR_DVI_D;\n\t\tbreak;\n\tcase 0x0e:  \n\t\tctx.outp[1] |= 0x00010000;\n\t\tfallthrough;\n\tcase 0x07:  \n\t\tctx.outp[1] |= 0x00000004;  \n\t\ttype = DCB_CONNECTOR_eDP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (mxms_version(mxm) >= 0x0300)\n\t\tconn[0] = type;\n\n\treturn 0;\n}\n\nstatic bool\nmxm_show_unmatched(struct nvkm_mxm *mxm, u8 *data, void *info)\n{\n\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tu64 desc = *(u64 *)data;\n\tif ((desc & 0xf0) != 0xf0)\n\t\tnvkm_info(subdev, \"unmatched output device %016llx\\n\", desc);\n\treturn true;\n}\n\nstatic void\nmxm_dcb_sanitise(struct nvkm_mxm *mxm)\n{\n\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tu8  ver, hdr, cnt, len;\n\tu16 dcb = dcb_table(bios, &ver, &hdr, &cnt, &len);\n\tif (dcb == 0x0000 || (ver != 0x40 && ver != 0x41)) {\n\t\tnvkm_warn(subdev, \"unsupported DCB version\\n\");\n\t\treturn;\n\t}\n\n\tdcb_outp_foreach(bios, mxm, mxm_dcb_sanitise_entry);\n\tmxms_foreach(mxm, 0x01, mxm_show_unmatched, NULL);\n}\n\nint\nnv50_mxm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t     struct nvkm_subdev **pmxm)\n{\n\tstruct nvkm_mxm *mxm;\n\tint ret;\n\n\tret = nvkm_mxm_new_(device, type, inst, &mxm);\n\tif (mxm)\n\t\t*pmxm = &mxm->subdev;\n\tif (ret)\n\t\treturn ret;\n\n\tif (mxm->action & MXM_SANITISE_DCB)\n\t\tmxm_dcb_sanitise(mxm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}