{
  "module_name": "gk104.c",
  "hash_id": "1902682c8e2575dd87bb8b8bf7a9fc4ea86fafd28b7e6b504039d098ed48ee15",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/top/gk104.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstatic int\ngk104_top_parse(struct nvkm_top *top)\n{\n\tstruct nvkm_subdev *subdev = &top->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_top_device *info = NULL;\n\tu32 data, type, inst;\n\tint i;\n\n\tfor (i = 0; i < 64; i++) {\n\t\tif (!info) {\n\t\t\tif (!(info = nvkm_top_device_new(top)))\n\t\t\t\treturn -ENOMEM;\n\t\t\ttype = ~0;\n\t\t\tinst = 0;\n\t\t}\n\n\t\tdata = nvkm_rd32(device, 0x022700 + (i * 0x04));\n\t\tnvkm_trace(subdev, \"%02x: %08x\\n\", i, data);\n\t\tswitch (data & 0x00000003) {\n\t\tcase 0x00000000:  \n\t\t\tcontinue;\n\t\tcase 0x00000001:  \n\t\t\tinst        = (data & 0x3c000000) >> 26;\n\t\t\tinfo->addr  = (data & 0x00fff000);\n\t\t\tif (data & 0x00000004)\n\t\t\t\tinfo->fault = (data & 0x000003f8) >> 3;\n\t\t\tbreak;\n\t\tcase 0x00000002:  \n\t\t\tif (data & 0x00000020)\n\t\t\t\tinfo->engine  = (data & 0x3c000000) >> 26;\n\t\t\tif (data & 0x00000010)\n\t\t\t\tinfo->runlist = (data & 0x01e00000) >> 21;\n\t\t\tif (data & 0x00000008)\n\t\t\t\tinfo->intr    = (data & 0x000f8000) >> 15;\n\t\t\tif (data & 0x00000004)\n\t\t\t\tinfo->reset   = (data & 0x00003e00) >> 9;\n\t\t\tbreak;\n\t\tcase 0x00000003:  \n\t\t\ttype = (data & 0x7ffffffc) >> 2;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data & 0x80000000)\n\t\t\tcontinue;\n\n\t\t \n#define I_(T,I) do { info->type = (T); info->inst = (I); } while(0)\n#define O_(T,I) do { WARN_ON(inst); I_(T, I); } while (0)\n\t\tswitch (type) {\n\t\tcase 0x00000000: O_(NVKM_ENGINE_GR    ,    0); break;\n\t\tcase 0x00000001: O_(NVKM_ENGINE_CE    ,    0); break;\n\t\tcase 0x00000002: O_(NVKM_ENGINE_CE    ,    1); break;\n\t\tcase 0x00000003: O_(NVKM_ENGINE_CE    ,    2); break;\n\t\tcase 0x00000008: O_(NVKM_ENGINE_MSPDEC,    0); break;\n\t\tcase 0x00000009: O_(NVKM_ENGINE_MSPPP ,    0); break;\n\t\tcase 0x0000000a: O_(NVKM_ENGINE_MSVLD ,    0); break;\n\t\tcase 0x0000000b: O_(NVKM_ENGINE_MSENC ,    0); break;\n\t\tcase 0x0000000c: O_(NVKM_ENGINE_VIC   ,    0); break;\n\t\tcase 0x0000000d: O_(NVKM_ENGINE_SEC2  ,    0); break;\n\t\tcase 0x0000000e: I_(NVKM_ENGINE_NVENC , inst); break;\n\t\tcase 0x0000000f: O_(NVKM_ENGINE_NVENC ,    1); break;\n\t\tcase 0x00000010: I_(NVKM_ENGINE_NVDEC , inst); break;\n\t\tcase 0x00000012: I_(NVKM_SUBDEV_IOCTRL, inst); break;\n\t\tcase 0x00000013: I_(NVKM_ENGINE_CE    , inst); break;\n\t\tcase 0x00000014: O_(NVKM_SUBDEV_GSP   ,    0); break;\n\t\tcase 0x00000015: O_(NVKM_ENGINE_NVJPG ,    0); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tnvkm_debug(subdev, \"%02x.%d (%8s): addr %06x fault %2d \"\n\t\t\t\t   \"engine %2d runlist %2d intr %2d \"\n\t\t\t\t   \"reset %2d\\n\", type, inst,\n\t\t\t   info->type == NVKM_SUBDEV_NR ? \"????????\" : nvkm_subdev_type[info->type],\n\t\t\t   info->addr, info->fault, info->engine, info->runlist,\n\t\t\t   info->intr, info->reset);\n\t\tinfo = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_top_func\ngk104_top = {\n\t.parse = gk104_top_parse,\n};\n\nint\ngk104_top_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_top **ptop)\n{\n\treturn nvkm_top_new_(&gk104_top, device, type, inst, ptop);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}