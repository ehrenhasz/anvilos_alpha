{
  "module_name": "base.c",
  "hash_id": "7d24d98d42a7747a18927ced560dd4dc6cd5db73b246cba52f782640eb69978f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mc/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/option.h>\n#include <subdev/top.h>\n\nvoid\nnvkm_mc_unk260(struct nvkm_device *device, u32 data)\n{\n\tstruct nvkm_mc *mc = device->mc;\n\tif (likely(mc) && mc->func->unk260)\n\t\tmc->func->unk260(mc, data);\n}\n\nvoid\nnvkm_mc_intr_mask(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, bool en)\n{\n\tstruct nvkm_subdev *subdev = nvkm_device_subdev(device, type, inst);\n\n\tif (subdev) {\n\t\tif (en)\n\t\t\tnvkm_intr_allow(subdev, NVKM_INTR_SUBDEV);\n\t\telse\n\t\t\tnvkm_intr_block(subdev, NVKM_INTR_SUBDEV);\n\t}\n}\n\nstatic u32\nnvkm_mc_reset_mask(struct nvkm_device *device, bool isauto, enum nvkm_subdev_type type, int inst)\n{\n\tstruct nvkm_mc *mc = device->mc;\n\tconst struct nvkm_mc_map *map;\n\tu64 pmc_enable = 0;\n\tif (likely(mc)) {\n\t\tif (!(pmc_enable = nvkm_top_reset(device, type, inst))) {\n\t\t\tfor (map = mc->func->reset; map && map->stat; map++) {\n\t\t\t\tif (!isauto || !map->noauto) {\n\t\t\t\t\tif (map->type == type && map->inst == inst) {\n\t\t\t\t\t\tpmc_enable = map->stat;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pmc_enable;\n}\n\nvoid\nnvkm_mc_reset(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tu64 pmc_enable = nvkm_mc_reset_mask(device, true, type, inst);\n\tif (pmc_enable) {\n\t\tdevice->mc->func->device->disable(device->mc, pmc_enable);\n\t\tdevice->mc->func->device->enable(device->mc, pmc_enable);\n\t}\n}\n\nvoid\nnvkm_mc_disable(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tu64 pmc_enable = nvkm_mc_reset_mask(device, false, type, inst);\n\tif (pmc_enable)\n\t\tdevice->mc->func->device->disable(device->mc, pmc_enable);\n}\n\nvoid\nnvkm_mc_enable(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tu64 pmc_enable = nvkm_mc_reset_mask(device, false, type, inst);\n\tif (pmc_enable)\n\t\tdevice->mc->func->device->enable(device->mc, pmc_enable);\n}\n\nbool\nnvkm_mc_enabled(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tu64 pmc_enable = nvkm_mc_reset_mask(device, false, type, inst);\n\n\treturn (pmc_enable != 0) && device->mc->func->device->enabled(device->mc, pmc_enable);\n}\n\nstatic int\nnvkm_mc_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_mc *mc = nvkm_mc(subdev);\n\tif (mc->func->init)\n\t\tmc->func->init(mc);\n\treturn 0;\n}\n\nstatic void *\nnvkm_mc_dtor(struct nvkm_subdev *subdev)\n{\n\treturn nvkm_mc(subdev);\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_mc = {\n\t.dtor = nvkm_mc_dtor,\n\t.init = nvkm_mc_init,\n};\n\nint\nnvkm_mc_new_(const struct nvkm_mc_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_mc **pmc)\n{\n\tstruct nvkm_mc *mc;\n\tint ret;\n\n\tif (!(mc = *pmc = kzalloc(sizeof(*mc), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_subdev_ctor(&nvkm_mc, device, type, inst, &mc->subdev);\n\tmc->func = func;\n\n\tif (mc->func->intr) {\n\t\tret = nvkm_intr_add(mc->func->intr, mc->func->intrs, &mc->subdev,\n\t\t\t\t    mc->func->intr_nonstall ? 2 : 1, &mc->intr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}