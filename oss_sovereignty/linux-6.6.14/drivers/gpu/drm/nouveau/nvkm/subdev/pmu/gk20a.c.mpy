{
  "module_name": "gk20a.c",
  "hash_id": "de74273c3422b7a79b054ec9985cbd19a293260300feb0ed98000fed32435fd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk20a.c",
  "human_readable_source": " \n#define gk20a_pmu(p) container_of((p), struct gk20a_pmu, base)\n#include \"priv.h\"\n\n#include <subdev/clk.h>\n#include <subdev/timer.h>\n#include <subdev/volt.h>\n\n#define BUSY_SLOT\t0\n#define CLK_SLOT\t7\n\nstruct gk20a_pmu_dvfs_data {\n\tint p_load_target;\n\tint p_load_max;\n\tint p_smooth;\n\tunsigned int avg_load;\n};\n\nstruct gk20a_pmu {\n\tstruct nvkm_pmu base;\n\tstruct nvkm_alarm alarm;\n\tstruct gk20a_pmu_dvfs_data *data;\n};\n\nstruct gk20a_pmu_dvfs_dev_status {\n\tu32 total;\n\tu32 busy;\n};\n\nstatic int\ngk20a_pmu_dvfs_target(struct gk20a_pmu *pmu, int *state)\n{\n\tstruct nvkm_clk *clk = pmu->base.subdev.device->clk;\n\n\treturn nvkm_clk_astate(clk, *state, 0, false);\n}\n\nstatic void\ngk20a_pmu_dvfs_get_cur_state(struct gk20a_pmu *pmu, int *state)\n{\n\tstruct nvkm_clk *clk = pmu->base.subdev.device->clk;\n\n\t*state = clk->pstate;\n}\n\nstatic int\ngk20a_pmu_dvfs_get_target_state(struct gk20a_pmu *pmu,\n\t\t\t\tint *state, int load)\n{\n\tstruct gk20a_pmu_dvfs_data *data = pmu->data;\n\tstruct nvkm_clk *clk = pmu->base.subdev.device->clk;\n\tint cur_level, level;\n\n\t \n\tlevel = cur_level = clk->pstate;\n\n\tif (load > data->p_load_max) {\n\t\tlevel = min(clk->state_nr - 1, level + (clk->state_nr / 3));\n\t} else {\n\t\tlevel += ((load - data->p_load_target) * 10 /\n\t\t\t\tdata->p_load_target) / 2;\n\t\tlevel = max(0, level);\n\t\tlevel = min(clk->state_nr - 1, level);\n\t}\n\n\tnvkm_trace(&pmu->base.subdev, \"cur level = %d, new level = %d\\n\",\n\t\t   cur_level, level);\n\n\t*state = level;\n\n\treturn (level != cur_level);\n}\n\nstatic void\ngk20a_pmu_dvfs_get_dev_status(struct gk20a_pmu *pmu,\n\t\t\t      struct gk20a_pmu_dvfs_dev_status *status)\n{\n\tstruct nvkm_falcon *falcon = &pmu->base.falcon;\n\n\tstatus->busy = nvkm_falcon_rd32(falcon, 0x508 + (BUSY_SLOT * 0x10));\n\tstatus->total= nvkm_falcon_rd32(falcon, 0x508 + (CLK_SLOT * 0x10));\n}\n\nstatic void\ngk20a_pmu_dvfs_reset_dev_status(struct gk20a_pmu *pmu)\n{\n\tstruct nvkm_falcon *falcon = &pmu->base.falcon;\n\n\tnvkm_falcon_wr32(falcon, 0x508 + (BUSY_SLOT * 0x10), 0x80000000);\n\tnvkm_falcon_wr32(falcon, 0x508 + (CLK_SLOT * 0x10), 0x80000000);\n}\n\nstatic void\ngk20a_pmu_dvfs_work(struct nvkm_alarm *alarm)\n{\n\tstruct gk20a_pmu *pmu =\n\t\tcontainer_of(alarm, struct gk20a_pmu, alarm);\n\tstruct gk20a_pmu_dvfs_data *data = pmu->data;\n\tstruct gk20a_pmu_dvfs_dev_status status;\n\tstruct nvkm_subdev *subdev = &pmu->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_clk *clk = device->clk;\n\tstruct nvkm_timer *tmr = device->timer;\n\tstruct nvkm_volt *volt = device->volt;\n\tu32 utilization = 0;\n\tint state;\n\n\t \n\tif (!clk || !volt)\n\t\tgoto resched;\n\n\tgk20a_pmu_dvfs_get_dev_status(pmu, &status);\n\n\tif (status.total)\n\t\tutilization = div_u64((u64)status.busy * 100, status.total);\n\n\tdata->avg_load = (data->p_smooth * data->avg_load) + utilization;\n\tdata->avg_load /= data->p_smooth + 1;\n\tnvkm_trace(subdev, \"utilization = %d %%, avg_load = %d %%\\n\",\n\t\t   utilization, data->avg_load);\n\n\tgk20a_pmu_dvfs_get_cur_state(pmu, &state);\n\n\tif (gk20a_pmu_dvfs_get_target_state(pmu, &state, data->avg_load)) {\n\t\tnvkm_trace(subdev, \"set new state to %d\\n\", state);\n\t\tgk20a_pmu_dvfs_target(pmu, &state);\n\t}\n\nresched:\n\tgk20a_pmu_dvfs_reset_dev_status(pmu);\n\tnvkm_timer_alarm(tmr, 100000000, alarm);\n}\n\nstatic void\ngk20a_pmu_fini(struct nvkm_pmu *pmu)\n{\n\tstruct gk20a_pmu *gpmu = gk20a_pmu(pmu);\n\tnvkm_timer_alarm(pmu->subdev.device->timer, 0, &gpmu->alarm);\n\n\tnvkm_falcon_put(&pmu->falcon, &pmu->subdev);\n}\n\nstatic int\ngk20a_pmu_init(struct nvkm_pmu *pmu)\n{\n\tstruct gk20a_pmu *gpmu = gk20a_pmu(pmu);\n\tstruct nvkm_subdev *subdev = &pmu->subdev;\n\tstruct nvkm_device *device = pmu->subdev.device;\n\tstruct nvkm_falcon *falcon = &pmu->falcon;\n\tint ret;\n\n\tret = nvkm_falcon_get(falcon, subdev);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"cannot acquire %s falcon!\\n\", falcon->name);\n\t\treturn ret;\n\t}\n\n\t \n\tnvkm_falcon_wr32(falcon, 0x504 + (BUSY_SLOT * 0x10), 0x00200001);\n\tnvkm_falcon_wr32(falcon, 0x50c + (BUSY_SLOT * 0x10), 0x00000002);\n\tnvkm_falcon_wr32(falcon, 0x50c + (CLK_SLOT * 0x10), 0x00000003);\n\n\tnvkm_timer_alarm(device->timer, 2000000000, &gpmu->alarm);\n\treturn 0;\n}\n\nstatic struct gk20a_pmu_dvfs_data\ngk20a_dvfs_data= {\n\t.p_load_target = 70,\n\t.p_load_max = 90,\n\t.p_smooth = 1,\n};\n\nstatic const struct nvkm_pmu_func\ngk20a_pmu = {\n\t.flcn = &gt215_pmu_flcn,\n\t.init = gk20a_pmu_init,\n\t.fini = gk20a_pmu_fini,\n\t.reset = gf100_pmu_reset,\n};\n\nstatic const struct nvkm_pmu_fwif\ngk20a_pmu_fwif[] = {\n\t{ -1, gf100_pmu_nofw, &gk20a_pmu },\n\t{}\n};\n\nint\ngk20a_pmu_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_pmu **ppmu)\n{\n\tstruct gk20a_pmu *pmu;\n\tint ret;\n\n\tif (!(pmu = kzalloc(sizeof(*pmu), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*ppmu = &pmu->base;\n\n\tret = nvkm_pmu_ctor(gk20a_pmu_fwif, device, type, inst, &pmu->base);\n\tif (ret)\n\t\treturn ret;\n\n\tpmu->data = &gk20a_dvfs_data;\n\tnvkm_alarm_init(&pmu->alarm, gk20a_pmu_dvfs_work);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}