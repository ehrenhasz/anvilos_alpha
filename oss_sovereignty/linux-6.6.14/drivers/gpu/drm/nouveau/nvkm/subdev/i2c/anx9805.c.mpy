{
  "module_name": "anx9805.c",
  "hash_id": "f0c3197956c12e900f6b3e98dedee65ffbbf6802dddcf50c036a505e598d304f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/anx9805.c",
  "human_readable_source": " \n#define anx9805_pad(p) container_of((p), struct anx9805_pad, base)\n#define anx9805_bus(p) container_of((p), struct anx9805_bus, base)\n#define anx9805_aux(p) container_of((p), struct anx9805_aux, base)\n#include \"aux.h\"\n#include \"bus.h\"\n\nstruct anx9805_pad {\n\tstruct nvkm_i2c_pad base;\n\tstruct nvkm_i2c_bus *bus;\n\tu8 addr;\n};\n\nstruct anx9805_bus {\n\tstruct nvkm_i2c_bus base;\n\tstruct anx9805_pad *pad;\n\tu8 addr;\n};\n\nstatic int\nanx9805_bus_xfer(struct nvkm_i2c_bus *base, struct i2c_msg *msgs, int num)\n{\n\tstruct anx9805_bus *bus = anx9805_bus(base);\n\tstruct anx9805_pad *pad = bus->pad;\n\tstruct i2c_adapter *adap = &pad->bus->i2c;\n\tstruct i2c_msg *msg = msgs;\n\tint ret = -ETIMEDOUT;\n\tint i, j, cnt = num;\n\tu8 seg = 0x00, off = 0x00, tmp;\n\n\ttmp = nvkm_rdi2cr(adap, pad->addr, 0x07) & ~0x10;\n\tnvkm_wri2cr(adap, pad->addr, 0x07, tmp | 0x10);\n\tnvkm_wri2cr(adap, pad->addr, 0x07, tmp);\n\tnvkm_wri2cr(adap, bus->addr, 0x43, 0x05);\n\tmdelay(5);\n\n\twhile (cnt--) {\n\t\tif ( (msg->flags & I2C_M_RD) && msg->addr == 0x50) {\n\t\t\tnvkm_wri2cr(adap, bus->addr, 0x40, msg->addr << 1);\n\t\t\tnvkm_wri2cr(adap, bus->addr, 0x41, seg);\n\t\t\tnvkm_wri2cr(adap, bus->addr, 0x42, off);\n\t\t\tnvkm_wri2cr(adap, bus->addr, 0x44, msg->len);\n\t\t\tnvkm_wri2cr(adap, bus->addr, 0x45, 0x00);\n\t\t\tnvkm_wri2cr(adap, bus->addr, 0x43, 0x01);\n\t\t\tfor (i = 0; i < msg->len; i++) {\n\t\t\t\tj = 0;\n\t\t\t\twhile (nvkm_rdi2cr(adap, bus->addr, 0x46) & 0x10) {\n\t\t\t\t\tmdelay(5);\n\t\t\t\t\tif (j++ == 32)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tmsg->buf[i] = nvkm_rdi2cr(adap, bus->addr, 0x47);\n\t\t\t}\n\t\t} else\n\t\tif (!(msg->flags & I2C_M_RD)) {\n\t\t\tif (msg->addr == 0x50 && msg->len == 0x01) {\n\t\t\t\toff = msg->buf[0];\n\t\t\t} else\n\t\t\tif (msg->addr == 0x30 && msg->len == 0x01) {\n\t\t\t\tseg = msg->buf[0];\n\t\t\t} else\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t\tmsg++;\n\t}\n\n\tret = num;\ndone:\n\tnvkm_wri2cr(adap, bus->addr, 0x43, 0x00);\n\treturn ret;\n}\n\nstatic const struct nvkm_i2c_bus_func\nanx9805_bus_func = {\n\t.xfer = anx9805_bus_xfer,\n};\n\nstatic int\nanx9805_bus_new(struct nvkm_i2c_pad *base, int id, u8 drive,\n\t\tstruct nvkm_i2c_bus **pbus)\n{\n\tstruct anx9805_pad *pad = anx9805_pad(base);\n\tstruct anx9805_bus *bus;\n\tint ret;\n\n\tif (!(bus = kzalloc(sizeof(*bus), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pbus = &bus->base;\n\tbus->pad = pad;\n\n\tret = nvkm_i2c_bus_ctor(&anx9805_bus_func, &pad->base, id, &bus->base);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (pad->addr) {\n\tcase 0x39: bus->addr = 0x3d; break;\n\tcase 0x3b: bus->addr = 0x3f; break;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstruct anx9805_aux {\n\tstruct nvkm_i2c_aux base;\n\tstruct anx9805_pad *pad;\n\tu8 addr;\n};\n\nstatic int\nanx9805_aux_xfer(struct nvkm_i2c_aux *base, bool retry,\n\t\t u8 type, u32 addr, u8 *data, u8 *size)\n{\n\tstruct anx9805_aux *aux = anx9805_aux(base);\n\tstruct anx9805_pad *pad = aux->pad;\n\tstruct i2c_adapter *adap = &pad->bus->i2c;\n\tint i, ret = -ETIMEDOUT;\n\tu8 buf[16] = {};\n\tu8 tmp;\n\n\tAUX_DBG(&aux->base, \"%02x %05x %d\", type, addr, *size);\n\n\ttmp = nvkm_rdi2cr(adap, pad->addr, 0x07) & ~0x04;\n\tnvkm_wri2cr(adap, pad->addr, 0x07, tmp | 0x04);\n\tnvkm_wri2cr(adap, pad->addr, 0x07, tmp);\n\tnvkm_wri2cr(adap, pad->addr, 0xf7, 0x01);\n\n\tnvkm_wri2cr(adap, aux->addr, 0xe4, 0x80);\n\tif (!(type & 1)) {\n\t\tmemcpy(buf, data, *size);\n\t\tAUX_DBG(&aux->base, \"%16ph\", buf);\n\t\tfor (i = 0; i < *size; i++)\n\t\t\tnvkm_wri2cr(adap, aux->addr, 0xf0 + i, buf[i]);\n\t}\n\tnvkm_wri2cr(adap, aux->addr, 0xe5, ((*size - 1) << 4) | type);\n\tnvkm_wri2cr(adap, aux->addr, 0xe6, (addr & 0x000ff) >>  0);\n\tnvkm_wri2cr(adap, aux->addr, 0xe7, (addr & 0x0ff00) >>  8);\n\tnvkm_wri2cr(adap, aux->addr, 0xe8, (addr & 0xf0000) >> 16);\n\tnvkm_wri2cr(adap, aux->addr, 0xe9, 0x01);\n\n\ti = 0;\n\twhile ((tmp = nvkm_rdi2cr(adap, aux->addr, 0xe9)) & 0x01) {\n\t\tmdelay(5);\n\t\tif (i++ == 32)\n\t\t\tgoto done;\n\t}\n\n\tif ((tmp = nvkm_rdi2cr(adap, pad->addr, 0xf7)) & 0x01) {\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (type & 1) {\n\t\tfor (i = 0; i < *size; i++)\n\t\t\tbuf[i] = nvkm_rdi2cr(adap, aux->addr, 0xf0 + i);\n\t\tAUX_DBG(&aux->base, \"%16ph\", buf);\n\t\tmemcpy(data, buf, *size);\n\t}\n\n\tret = 0;\ndone:\n\tnvkm_wri2cr(adap, pad->addr, 0xf7, 0x01);\n\treturn ret;\n}\n\nstatic int\nanx9805_aux_lnk_ctl(struct nvkm_i2c_aux *base,\n\t\t    int link_nr, int link_bw, bool enh)\n{\n\tstruct anx9805_aux *aux = anx9805_aux(base);\n\tstruct anx9805_pad *pad = aux->pad;\n\tstruct i2c_adapter *adap = &pad->bus->i2c;\n\tu8 tmp, i;\n\n\tAUX_DBG(&aux->base, \"ANX9805 train %d %02x %d\",\n\t\tlink_nr, link_bw, enh);\n\n\tnvkm_wri2cr(adap, aux->addr, 0xa0, link_bw);\n\tnvkm_wri2cr(adap, aux->addr, 0xa1, link_nr | (enh ? 0x80 : 0x00));\n\tnvkm_wri2cr(adap, aux->addr, 0xa2, 0x01);\n\tnvkm_wri2cr(adap, aux->addr, 0xa8, 0x01);\n\n\ti = 0;\n\twhile ((tmp = nvkm_rdi2cr(adap, aux->addr, 0xa8)) & 0x01) {\n\t\tmdelay(5);\n\t\tif (i++ == 100) {\n\t\t\tAUX_ERR(&aux->base, \"link training timeout\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tif (tmp & 0x70) {\n\t\tAUX_ERR(&aux->base, \"link training failed\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_i2c_aux_func\nanx9805_aux_func = {\n\t.xfer = anx9805_aux_xfer,\n\t.lnk_ctl = anx9805_aux_lnk_ctl,\n};\n\nstatic int\nanx9805_aux_new(struct nvkm_i2c_pad *base, int id, u8 drive,\n\t\tstruct nvkm_i2c_aux **pbus)\n{\n\tstruct anx9805_pad *pad = anx9805_pad(base);\n\tstruct anx9805_aux *aux;\n\tint ret;\n\n\tif (!(aux = kzalloc(sizeof(*aux), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pbus = &aux->base;\n\taux->pad = pad;\n\n\tret = nvkm_i2c_aux_ctor(&anx9805_aux_func, &pad->base, id, &aux->base);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (pad->addr) {\n\tcase 0x39: aux->addr = 0x38; break;\n\tcase 0x3b: aux->addr = 0x3c; break;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_i2c_pad_func\nanx9805_pad_func = {\n\t.bus_new_4 = anx9805_bus_new,\n\t.aux_new_6 = anx9805_aux_new,\n};\n\nint\nanx9805_pad_new(struct nvkm_i2c_bus *bus, int id, u8 addr,\n\t\tstruct nvkm_i2c_pad **ppad)\n{\n\tstruct anx9805_pad *pad;\n\n\tif (!(pad = kzalloc(sizeof(*pad), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*ppad = &pad->base;\n\n\tnvkm_i2c_pad_ctor(&anx9805_pad_func, bus->pad->i2c, id, &pad->base);\n\tpad->bus = bus;\n\tpad->addr = addr;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}