{
  "module_name": "ramgt215.c",
  "hash_id": "ac00e1809a690aa0791a7455ad37e7f4039a934cc8ced10cca8ba5b75c78946a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgt215.c",
  "human_readable_source": " \n#define gt215_ram(p) container_of((p), struct gt215_ram, base)\n#include \"ram.h\"\n#include \"ramfuc.h\"\n\n#include <core/memory.h>\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/M0205.h>\n#include <subdev/bios/rammap.h>\n#include <subdev/bios/timing.h>\n#include <subdev/clk/gt215.h>\n#include <subdev/gpio.h>\n\nstruct gt215_ramfuc {\n\tstruct ramfuc base;\n\tstruct ramfuc_reg r_0x001610;\n\tstruct ramfuc_reg r_0x001700;\n\tstruct ramfuc_reg r_0x002504;\n\tstruct ramfuc_reg r_0x004000;\n\tstruct ramfuc_reg r_0x004004;\n\tstruct ramfuc_reg r_0x004018;\n\tstruct ramfuc_reg r_0x004128;\n\tstruct ramfuc_reg r_0x004168;\n\tstruct ramfuc_reg r_0x100080;\n\tstruct ramfuc_reg r_0x100200;\n\tstruct ramfuc_reg r_0x100210;\n\tstruct ramfuc_reg r_0x100220[9];\n\tstruct ramfuc_reg r_0x100264;\n\tstruct ramfuc_reg r_0x1002d0;\n\tstruct ramfuc_reg r_0x1002d4;\n\tstruct ramfuc_reg r_0x1002dc;\n\tstruct ramfuc_reg r_0x10053c;\n\tstruct ramfuc_reg r_0x1005a0;\n\tstruct ramfuc_reg r_0x1005a4;\n\tstruct ramfuc_reg r_0x100700;\n\tstruct ramfuc_reg r_0x100714;\n\tstruct ramfuc_reg r_0x100718;\n\tstruct ramfuc_reg r_0x10071c;\n\tstruct ramfuc_reg r_0x100720;\n\tstruct ramfuc_reg r_0x100760;\n\tstruct ramfuc_reg r_0x1007a0;\n\tstruct ramfuc_reg r_0x1007e0;\n\tstruct ramfuc_reg r_0x100da0;\n\tstruct ramfuc_reg r_0x10f804;\n\tstruct ramfuc_reg r_0x1110e0;\n\tstruct ramfuc_reg r_0x111100;\n\tstruct ramfuc_reg r_0x111104;\n\tstruct ramfuc_reg r_0x1111e0;\n\tstruct ramfuc_reg r_0x111400;\n\tstruct ramfuc_reg r_0x611200;\n\tstruct ramfuc_reg r_mr[4];\n\tstruct ramfuc_reg r_gpio[4];\n};\n\nstruct gt215_ltrain {\n\tenum {\n\t\tNVA3_TRAIN_UNKNOWN,\n\t\tNVA3_TRAIN_UNSUPPORTED,\n\t\tNVA3_TRAIN_ONCE,\n\t\tNVA3_TRAIN_EXEC,\n\t\tNVA3_TRAIN_DONE\n\t} state;\n\tu32 r_100720;\n\tu32 r_1111e0;\n\tu32 r_111400;\n\tstruct nvkm_memory *memory;\n};\n\nstruct gt215_ram {\n\tstruct nvkm_ram base;\n\tstruct gt215_ramfuc fuc;\n\tstruct gt215_ltrain ltrain;\n};\n\nstatic void\ngt215_link_train_calc(u32 *vals, struct gt215_ltrain *train)\n{\n\tint i, lo, hi;\n\tu8 median[8], bins[4] = {0, 0, 0, 0}, bin = 0, qty = 0;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (lo = 0; lo < 0x40; lo++) {\n\t\t\tif (!(vals[lo] & 0x80000000))\n\t\t\t\tcontinue;\n\t\t\tif (vals[lo] & (0x101 << i))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (lo == 0x40)\n\t\t\treturn;\n\n\t\tfor (hi = lo + 1; hi < 0x40; hi++) {\n\t\t\tif (!(vals[lo] & 0x80000000))\n\t\t\t\tcontinue;\n\t\t\tif (!(vals[hi] & (0x101 << i))) {\n\t\t\t\thi--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmedian[i] = ((hi - lo) >> 1) + lo;\n\t\tbins[(median[i] & 0xf0) >> 4]++;\n\t\tmedian[i] += 0x30;\n\t}\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (bins[i] > qty) {\n\t\t\tbin = i + 3;\n\t\t\tqty = bins[i];\n\t\t}\n\t}\n\n\ttrain->r_100720 = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tmedian[i] = max(median[i], (u8) (bin << 4));\n\t\tmedian[i] = min(median[i], (u8) ((bin << 4) | 0xf));\n\n\t\ttrain->r_100720 |= ((median[i] & 0x0f) << (i << 2));\n\t}\n\n\ttrain->r_1111e0 = 0x02000000 | (bin * 0x101);\n\ttrain->r_111400 = 0x0;\n}\n\n \nstatic int\ngt215_link_train(struct gt215_ram *ram)\n{\n\tstruct gt215_ltrain *train = &ram->ltrain;\n\tstruct gt215_ramfuc *fuc = &ram->fuc;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvkm_clk *clk = device->clk;\n\tu32 *result, r1700;\n\tint ret, i;\n\tstruct nvbios_M0205T M0205T = { 0 };\n\tu8 ver, hdr, cnt, len, snr, ssz;\n\tunsigned int clk_current;\n\tunsigned long flags;\n\tunsigned long *f = &flags;\n\n\tif (nvkm_boolopt(device->cfgopt, \"NvMemExec\", true) != true)\n\t\treturn -ENOSYS;\n\n\t \n\tresult = kmalloc_array(64, sizeof(u32), GFP_KERNEL);\n\tif (!result)\n\t\treturn -ENOMEM;\n\n\ttrain->state = NVA3_TRAIN_EXEC;\n\n\t \n\tnvbios_M0205Tp(bios, &ver, &hdr, &cnt, &len, &snr, &ssz, &M0205T);\n\tif (M0205T.freq == 0) {\n\t\tkfree(result);\n\t\treturn -ENOENT;\n\t}\n\n\tclk_current = nvkm_clk_read(clk, nv_clk_src_mem);\n\n\tret = gt215_clk_pre(clk, f);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = ram->base.func->calc(&ram->base, (u32) M0205T.freq * 1000);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tnvkm_wr32(device, 0x111400, 0x00000000);\n\t \n\tnvkm_mask(device, 0x100674, 0x0000ffff, 0x00000000);\n\tnvkm_mask(device, 0x1005e4, 0x0000ffff, 0x00000000);\n\tnvkm_mask(device, 0x100b0c, 0x000000ff, 0x00000000);\n\tnvkm_wr32(device, 0x100c04, 0x00000400);\n\n\t \n\tr1700 = ram_rd32(fuc, 0x001700);\n\n\tram_mask(fuc, 0x100200, 0x00000800, 0x00000000);\n\tram_wr32(fuc, 0x611200, 0x3300);\n\tram_wait_vblank(fuc);\n\tram_wait(fuc, 0x611200, 0x00000003, 0x00000000, 500000);\n\tram_mask(fuc, 0x001610, 0x00000083, 0x00000003);\n\tram_mask(fuc, 0x100080, 0x00000020, 0x00000000);\n\tram_mask(fuc, 0x10f804, 0x80000000, 0x00000000);\n\tram_wr32(fuc, 0x001700, 0x00000000);\n\n\tram_train(fuc);\n\n\t \n\tram_mask(fuc, 0x10f804, 0x80000000, 0x80000000);\n\tram_wr32(fuc, 0x10053c, 0x0);\n\tram_wr32(fuc, 0x100720, train->r_100720);\n\tram_wr32(fuc, 0x1111e0, train->r_1111e0);\n\tram_wr32(fuc, 0x111400, train->r_111400);\n\tram_nuke(fuc, 0x100080);\n\tram_mask(fuc, 0x100080, 0x00000020, 0x00000020);\n\tram_nsec(fuc, 1000);\n\n\tram_wr32(fuc, 0x001700, r1700);\n\tram_mask(fuc, 0x001610, 0x00000083, 0x00000080);\n\tram_wr32(fuc, 0x611200, 0x3330);\n\tram_mask(fuc, 0x100200, 0x00000800, 0x00000800);\n\n\tram_exec(fuc, true);\n\n\tram->base.func->calc(&ram->base, clk_current);\n\tram_exec(fuc, true);\n\n\t \n\tnvkm_mask(device, 0x616308, 0x10, 0x10);\n\tnvkm_mask(device, 0x616b08, 0x10, 0x10);\n\n\tgt215_clk_post(clk, f);\n\n\tram_train_result(ram->base.fb, result, 64);\n\tfor (i = 0; i < 64; i++)\n\t\tnvkm_debug(subdev, \"Train: %08x\", result[i]);\n\tgt215_link_train_calc(result, train);\n\n\tnvkm_debug(subdev, \"Train: %08x %08x %08x\", train->r_100720,\n\t\t   train->r_1111e0, train->r_111400);\n\n\tkfree(result);\n\n\ttrain->state = NVA3_TRAIN_DONE;\n\n\treturn ret;\n\nout:\n\tif(ret == -EBUSY)\n\t\tf = NULL;\n\n\ttrain->state = NVA3_TRAIN_UNSUPPORTED;\n\n\tgt215_clk_post(clk, f);\n\tkfree(result);\n\treturn ret;\n}\n\nstatic int\ngt215_link_train_init(struct gt215_ram *ram)\n{\n\tstatic const u32 pattern[16] = {\n\t\t0xaaaaaaaa, 0xcccccccc, 0xdddddddd, 0xeeeeeeee,\n\t\t0x00000000, 0x11111111, 0x44444444, 0xdddddddd,\n\t\t0x33333333, 0x55555555, 0x77777777, 0x66666666,\n\t\t0x99999999, 0x88888888, 0xeeeeeeee, 0xbbbbbbbb,\n\t};\n\tstruct gt215_ltrain *train = &ram->ltrain;\n\tstruct nvkm_device *device = ram->base.fb->subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvbios_M0205E M0205E;\n\tu8 ver, hdr, cnt, len;\n\tu32 r001700;\n\tu64 addr;\n\tint ret, i = 0;\n\n\ttrain->state = NVA3_TRAIN_UNSUPPORTED;\n\n\t \n\tif (!nvbios_M0205Ep(bios, i, &ver, &hdr, &cnt, &len, &M0205E))\n\t\treturn -ENOENT;\n\n\tif (M0205E.type != 5)\n\t\treturn 0;\n\n\ttrain->state = NVA3_TRAIN_ONCE;\n\n\tret = nvkm_ram_get(device, NVKM_RAM_MM_NORMAL, 0x01, 16, 0x8000,\n\t\t\t   true, true, &ram->ltrain.memory);\n\tif (ret)\n\t\treturn ret;\n\n\taddr = nvkm_memory_addr(ram->ltrain.memory);\n\n\tnvkm_wr32(device, 0x100538, 0x10000000 | (addr >> 16));\n\tnvkm_wr32(device, 0x1005a8, 0x0000ffff);\n\tnvkm_mask(device, 0x10f800, 0x00000001, 0x00000001);\n\n\tfor (i = 0; i < 0x30; i++) {\n\t\tnvkm_wr32(device, 0x10f8c0, (i << 8) | i);\n\t\tnvkm_wr32(device, 0x10f900, pattern[i % 16]);\n\t}\n\n\tfor (i = 0; i < 0x30; i++) {\n\t\tnvkm_wr32(device, 0x10f8e0, (i << 8) | i);\n\t\tnvkm_wr32(device, 0x10f920, pattern[i % 16]);\n\t}\n\n\t \n\tr001700 = nvkm_rd32(device, 0x1700);\n\tnvkm_wr32(device, 0x1700, addr >> 16);\n\tfor (i = 0; i < 16; i++)\n\t\tnvkm_wr32(device, 0x700000 + (i << 2), pattern[i]);\n\tfor (i = 0; i < 16; i++)\n\t\tnvkm_wr32(device, 0x700100 + (i << 2), pattern[i]);\n\tnvkm_wr32(device, 0x1700, r001700);\n\n\ttrain->r_100720 = nvkm_rd32(device, 0x100720);\n\ttrain->r_1111e0 = nvkm_rd32(device, 0x1111e0);\n\ttrain->r_111400 = nvkm_rd32(device, 0x111400);\n\treturn 0;\n}\n\nstatic void\ngt215_link_train_fini(struct gt215_ram *ram)\n{\n\tnvkm_memory_unref(&ram->ltrain.memory);\n}\n\n \n#define T(t) cfg->timing_10_##t\nstatic int\ngt215_ram_timing_calc(struct gt215_ram *ram, u32 *timing)\n{\n\tstruct nvbios_ramcfg *cfg = &ram->base.target.bios;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint tUNK_base, tUNK_40_0, prevCL;\n\tu32 cur2, cur3, cur7, cur8;\n\n\tcur2 = nvkm_rd32(device, 0x100228);\n\tcur3 = nvkm_rd32(device, 0x10022c);\n\tcur7 = nvkm_rd32(device, 0x10023c);\n\tcur8 = nvkm_rd32(device, 0x100240);\n\n\n\tswitch ((!T(CWL)) * ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR2:\n\t\tT(CWL) = T(CL) - 1;\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tT(CWL) = ((cur2 & 0xff000000) >> 24) + 1;\n\t\tbreak;\n\t}\n\n\tprevCL = (cur3 & 0x000000ff) + 1;\n\ttUNK_base = ((cur7 & 0x00ff0000) >> 16) - prevCL;\n\n\ttiming[0] = (T(RP) << 24 | T(RAS) << 16 | T(RFC) << 8 | T(RC));\n\ttiming[1] = (T(WR) + 1 + T(CWL)) << 24 |\n\t\t    max_t(u8,T(18), 1) << 16 |\n\t\t    (T(WTR) + 1 + T(CWL)) << 8 |\n\t\t    (5 + T(CL) - T(CWL));\n\ttiming[2] = (T(CWL) - 1) << 24 |\n\t\t    (T(RRD) << 16) |\n\t\t    (T(RCDWR) << 8) |\n\t\t    T(RCDRD);\n\ttiming[3] = (cur3 & 0x00ff0000) |\n\t\t    (0x30 + T(CL)) << 24 |\n\t\t    (0xb + T(CL)) << 8 |\n\t\t    (T(CL) - 1);\n\ttiming[4] = T(20) << 24 |\n\t\t    T(21) << 16 |\n\t\t    T(13) << 8 |\n\t\t    T(13);\n\ttiming[5] = T(RFC) << 24 |\n\t\t    max_t(u8,T(RCDRD), T(RCDWR)) << 16 |\n\t\t    max_t(u8, (T(CWL) + 6), (T(CL) + 2)) << 8 |\n\t\t    T(RP);\n\ttiming[6] = (0x5a + T(CL)) << 16 |\n\t\t    max_t(u8, 1, (6 - T(CL) + T(CWL))) << 8 |\n\t\t    (0x50 + T(CL) - T(CWL));\n\ttiming[7] = (cur7 & 0xff000000) |\n\t\t    ((tUNK_base + T(CL)) << 16) |\n\t\t    0x202;\n\ttiming[8] = cur8 & 0xffffff00;\n\n\tswitch (ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR2:\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\ttUNK_40_0 = prevCL - (cur8 & 0xff);\n\t\tif (tUNK_40_0 > 0)\n\t\t\ttiming[8] |= T(CL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnvkm_debug(subdev, \"Entry: 220: %08x %08x %08x %08x\\n\",\n\t\t   timing[0], timing[1], timing[2], timing[3]);\n\tnvkm_debug(subdev, \"  230: %08x %08x %08x %08x\\n\",\n\t\t   timing[4], timing[5], timing[6], timing[7]);\n\tnvkm_debug(subdev, \"  240: %08x\\n\", timing[8]);\n\treturn 0;\n}\n#undef T\n\nstatic void\nnvkm_sddr2_dll_reset(struct gt215_ramfuc *fuc)\n{\n\tram_mask(fuc, mr[0], 0x100, 0x100);\n\tram_nsec(fuc, 1000);\n\tram_mask(fuc, mr[0], 0x100, 0x000);\n\tram_nsec(fuc, 1000);\n}\n\nstatic void\nnvkm_sddr3_dll_disable(struct gt215_ramfuc *fuc, u32 *mr)\n{\n\tu32 mr1_old = ram_rd32(fuc, mr[1]);\n\n\tif (!(mr1_old & 0x1)) {\n\t\tram_wr32(fuc, 0x1002d4, 0x00000001);\n\t\tram_wr32(fuc, mr[1], mr[1]);\n\t\tram_nsec(fuc, 1000);\n\t}\n}\n\nstatic void\nnvkm_gddr3_dll_disable(struct gt215_ramfuc *fuc, u32 *mr)\n{\n\tu32 mr1_old = ram_rd32(fuc, mr[1]);\n\n\tif (!(mr1_old & 0x40)) {\n\t\tram_wr32(fuc, mr[1], mr[1]);\n\t\tram_nsec(fuc, 1000);\n\t}\n}\n\nstatic void\ngt215_ram_lock_pll(struct gt215_ramfuc *fuc, struct gt215_clk_info *mclk)\n{\n\tram_wr32(fuc, 0x004004, mclk->pll);\n\tram_mask(fuc, 0x004000, 0x00000001, 0x00000001);\n\tram_mask(fuc, 0x004000, 0x00000010, 0x00000000);\n\tram_wait(fuc, 0x004000, 0x00020000, 0x00020000, 64000);\n\tram_mask(fuc, 0x004000, 0x00000010, 0x00000010);\n}\n\nstatic void\ngt215_ram_gpio(struct gt215_ramfuc *fuc, u8 tag, u32 val)\n{\n\tstruct nvkm_gpio *gpio = fuc->base.fb->subdev.device->gpio;\n\tstruct dcb_gpio_func func;\n\tu32 reg, sh, gpio_val;\n\tint ret;\n\n\tif (nvkm_gpio_get(gpio, 0, tag, DCB_GPIO_UNUSED) != val) {\n\t\tret = nvkm_gpio_find(gpio, 0, tag, DCB_GPIO_UNUSED, &func);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\treg = func.line >> 3;\n\t\tsh = (func.line & 0x7) << 2;\n\t\tgpio_val = ram_rd32(fuc, gpio[reg]);\n\t\tif (gpio_val & (8 << sh))\n\t\t\tval = !val;\n\t\tif (!(func.log[1] & 1))\n\t\t\tval = !val;\n\n\t\tram_mask(fuc, gpio[reg], (0x3 << sh), ((val | 0x2) << sh));\n\t\tram_nsec(fuc, 20000);\n\t}\n}\n\nstatic int\ngt215_ram_calc(struct nvkm_ram *base, u32 freq)\n{\n\tstruct gt215_ram *ram = gt215_ram(base);\n\tstruct gt215_ramfuc *fuc = &ram->fuc;\n\tstruct gt215_ltrain *train = &ram->ltrain;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct gt215_clk_info mclk;\n\tstruct nvkm_gpio *gpio = device->gpio;\n\tstruct nvkm_ram_data *next;\n\tu8  ver, hdr, cnt, len, strap;\n\tu32 data;\n\tu32 r004018, r100760, r100da0, r111100, ctrl;\n\tu32 unk714, unk718, unk71c;\n\tint ret, i;\n\tu32 timing[9];\n\tbool pll2pll;\n\n\tnext = &ram->base.target;\n\tnext->freq = freq;\n\tram->base.next = next;\n\n\tif (ram->ltrain.state == NVA3_TRAIN_ONCE)\n\t\tgt215_link_train(ram);\n\n\t \n\tdata = nvbios_rammapEm(bios, freq / 1000, &ver, &hdr, &cnt, &len,\n\t\t\t       &next->bios);\n\tif (!data || ver != 0x10 || hdr < 0x05) {\n\t\tnvkm_error(subdev, \"invalid/missing rammap entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstrap = nvbios_ramcfg_index(subdev);\n\tif (strap >= cnt) {\n\t\tnvkm_error(subdev, \"invalid ramcfg strap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = nvbios_rammapSp(bios, data, ver, hdr, cnt, len, strap,\n\t\t\t       &ver, &hdr, &next->bios);\n\tif (!data || ver != 0x10 || hdr < 0x09) {\n\t\tnvkm_error(subdev, \"invalid/missing ramcfg entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (next->bios.ramcfg_timing != 0xff) {\n\t\tdata = nvbios_timingEp(bios, next->bios.ramcfg_timing,\n\t\t\t\t       &ver, &hdr, &cnt, &len,\n\t\t\t\t       &next->bios);\n\t\tif (!data || ver != 0x10 || hdr < 0x17) {\n\t\t\tnvkm_error(subdev, \"invalid/missing timing entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = gt215_pll_info(device->clk, 0x12, 0x4000, freq, &mclk);\n\tif (ret < 0) {\n\t\tnvkm_error(subdev, \"failed mclk calculation\\n\");\n\t\treturn ret;\n\t}\n\n\tgt215_ram_timing_calc(ram, timing);\n\n\tret = ram_init(fuc, ram->base.fb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tram->base.mr[0] = ram_rd32(fuc, mr[0]);\n\tram->base.mr[1] = ram_rd32(fuc, mr[1]);\n\tram->base.mr[2] = ram_rd32(fuc, mr[2]);\n\n\tswitch (ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR2:\n\t\tret = nvkm_sddr2_calc(&ram->base);\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_DDR3:\n\t\tret = nvkm_sddr3_calc(&ram->base);\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tret = nvkm_gddr3_calc(&ram->base);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (freq <= 750000) {\n\t\tr004018 = 0x10000000;\n\t\tr100760 = 0x22222222;\n\t\tr100da0 = 0x00000010;\n\t} else {\n\t\tr004018 = 0x00000000;\n\t\tr100760 = 0x00000000;\n\t\tr100da0 = 0x00000000;\n\t}\n\n\tif (!next->bios.ramcfg_DLLoff)\n\t\tr004018 |= 0x00004000;\n\n\t \n\tctrl = ram_rd32(fuc, 0x004000);\n\tpll2pll = (!(ctrl & 0x00000008)) && mclk.pll;\n\n\t \n\tif (next->bios.ramcfg_10_02_10) {\n\t\tram_mask(fuc, 0x111104, 0x00000600, 0x00000000);\n\t} else {\n\t\tram_mask(fuc, 0x111100, 0x40000000, 0x40000000);\n\t\tram_mask(fuc, 0x111104, 0x00000180, 0x00000000);\n\t}\n\t \n\tram_mask(fuc, 0x100200, 0x00000800, 0x00000000);\n\n\t \n\tif (mclk.pll && !pll2pll) {\n\t\tram_mask(fuc, 0x004128, 0x003f3141, mclk.clk | 0x00000101);\n\t\tgt215_ram_lock_pll(fuc, &mclk);\n\t}\n\n\t \n\tram_wait_vblank(fuc);\n\tram_wr32(fuc, 0x611200, 0x3300);\n\tram_mask(fuc, 0x002504, 0x1, 0x1);\n\tram_nsec(fuc, 10000);\n\tram_wait(fuc, 0x002504, 0x10, 0x10, 20000);  \n\tram_block(fuc);\n\tram_nsec(fuc, 2000);\n\n\tif (!next->bios.ramcfg_10_02_10) {\n\t\tif (ram->base.type == NVKM_RAM_TYPE_GDDR3)\n\t\t\tram_mask(fuc, 0x111100, 0x04020000, 0x00020000);\n\t\telse\n\t\t\tram_mask(fuc, 0x111100, 0x04020000, 0x04020000);\n\t}\n\n\t \n\tswitch (next->bios.ramcfg_DLLoff * ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR3:\n\t\tnvkm_sddr3_dll_disable(fuc, ram->base.mr);\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tnvkm_gddr3_dll_disable(fuc, ram->base.mr);\n\t\tbreak;\n\t}\n\n\tif (next->bios.timing_10_ODT)\n\t\tgt215_ram_gpio(fuc, 0x2e, 1);\n\n\t \n\tram_wr32(fuc, 0x1002d4, 0x00000001);\n\tram_wr32(fuc, 0x1002d0, 0x00000001);\n\tram_wr32(fuc, 0x1002d0, 0x00000001);\n\tram_wr32(fuc, 0x100210, 0x00000000);\n\tram_wr32(fuc, 0x1002dc, 0x00000001);\n\tram_nsec(fuc, 2000);\n\n\tif (device->chipset == 0xa3 && freq <= 500000)\n\t\tram_mask(fuc, 0x100700, 0x00000006, 0x00000006);\n\n\t \n\tif (nvkm_gpio_get(gpio, 0, 0x18, DCB_GPIO_UNUSED) ==\n\t\t\tnext->bios.ramcfg_FBVDDQ) {\n\t\tdata = ram_rd32(fuc, 0x004000) & 0x9;\n\n\t\tif (data == 0x1)\n\t\t\tram_mask(fuc, 0x004000, 0x8, 0x8);\n\t\tif (data & 0x1)\n\t\t\tram_mask(fuc, 0x004000, 0x1, 0x0);\n\n\t\tgt215_ram_gpio(fuc, 0x18, !next->bios.ramcfg_FBVDDQ);\n\n\t\tif (data & 0x1)\n\t\t\tram_mask(fuc, 0x004000, 0x1, 0x1);\n\t}\n\n\t \n\t \n\n\t \n\tif (pll2pll) {\n\t\tram_mask(fuc, 0x004000, 0x00000004, 0x00000004);\n\t\tram_mask(fuc, 0x004168, 0x003f3141, 0x00083101);\n\t\tram_mask(fuc, 0x004000, 0x00000008, 0x00000008);\n\t\tram_mask(fuc, 0x1110e0, 0x00088000, 0x00088000);\n\t\tram_wr32(fuc, 0x004018, 0x00001000);\n\t\tgt215_ram_lock_pll(fuc, &mclk);\n\t}\n\n\tif (mclk.pll) {\n\t\tram_mask(fuc, 0x004000, 0x00000105, 0x00000105);\n\t\tram_wr32(fuc, 0x004018, 0x00001000 | r004018);\n\t\tram_wr32(fuc, 0x100da0, r100da0);\n\t} else {\n\t\tram_mask(fuc, 0x004168, 0x003f3141, mclk.clk | 0x00000101);\n\t\tram_mask(fuc, 0x004000, 0x00000108, 0x00000008);\n\t\tram_mask(fuc, 0x1110e0, 0x00088000, 0x00088000);\n\t\tram_wr32(fuc, 0x004018, 0x00009000 | r004018);\n\t\tram_wr32(fuc, 0x100da0, r100da0);\n\t}\n\tram_nsec(fuc, 20000);\n\n\tif (next->bios.rammap_10_04_08) {\n\t\tram_wr32(fuc, 0x1005a0, next->bios.ramcfg_10_06 << 16 |\n\t\t\t\t\tnext->bios.ramcfg_10_05 << 8 |\n\t\t\t\t\tnext->bios.ramcfg_10_05);\n\t\tram_wr32(fuc, 0x1005a4, next->bios.ramcfg_10_08 << 8 |\n\t\t\t\t\tnext->bios.ramcfg_10_07);\n\t\tram_wr32(fuc, 0x10f804, next->bios.ramcfg_10_09_f0 << 20 |\n\t\t\t\t\tnext->bios.ramcfg_10_03_0f << 16 |\n\t\t\t\t\tnext->bios.ramcfg_10_09_0f |\n\t\t\t\t\t0x80000000);\n\t\tram_mask(fuc, 0x10053c, 0x00001000, 0x00000000);\n\t} else {\n\t\tif (train->state == NVA3_TRAIN_DONE) {\n\t\t\tram_wr32(fuc, 0x100080, 0x1020);\n\t\t\tram_mask(fuc, 0x111400, 0xffffffff, train->r_111400);\n\t\t\tram_mask(fuc, 0x1111e0, 0xffffffff, train->r_1111e0);\n\t\t\tram_mask(fuc, 0x100720, 0xffffffff, train->r_100720);\n\t\t}\n\t\tram_mask(fuc, 0x10053c, 0x00001000, 0x00001000);\n\t\tram_mask(fuc, 0x10f804, 0x80000000, 0x00000000);\n\t\tram_mask(fuc, 0x100760, 0x22222222, r100760);\n\t\tram_mask(fuc, 0x1007a0, 0x22222222, r100760);\n\t\tram_mask(fuc, 0x1007e0, 0x22222222, r100760);\n\t}\n\n\tif (device->chipset == 0xa3 && freq > 500000) {\n\t\tram_mask(fuc, 0x100700, 0x00000006, 0x00000000);\n\t}\n\n\t \n\tif (mclk.pll) {\n\t\tram_mask(fuc, 0x1110e0, 0x00088000, 0x00011000);\n\t\tram_mask(fuc, 0x004000, 0x00000008, 0x00000000);\n\t}\n\n\tram_wr32(fuc, 0x1002dc, 0x00000000);\n\tram_wr32(fuc, 0x1002d4, 0x00000001);\n\tram_wr32(fuc, 0x100210, 0x80000000);\n\tram_nsec(fuc, 2000);\n\n\t \n\tfor (i = 2; i >= 0; i--) {\n\t\tif (ram_rd32(fuc, mr[i]) != ram->base.mr[i]) {\n\t\t\tram_wr32(fuc, mr[i], ram->base.mr[i]);\n\t\t\tram_nsec(fuc, 1000);\n\t\t}\n\t}\n\n\tram_wr32(fuc, 0x100220[3], timing[3]);\n\tram_wr32(fuc, 0x100220[1], timing[1]);\n\tram_wr32(fuc, 0x100220[6], timing[6]);\n\tram_wr32(fuc, 0x100220[7], timing[7]);\n\tram_wr32(fuc, 0x100220[2], timing[2]);\n\tram_wr32(fuc, 0x100220[4], timing[4]);\n\tram_wr32(fuc, 0x100220[5], timing[5]);\n\tram_wr32(fuc, 0x100220[0], timing[0]);\n\tram_wr32(fuc, 0x100220[8], timing[8]);\n\n\t \n\tram_mask(fuc, 0x100200, 0x00001000, !next->bios.ramcfg_10_02_08 << 12);\n\n\t \n\tunk714  = ram_rd32(fuc, 0x100714) & ~0xf0000130;\n\tunk718  = ram_rd32(fuc, 0x100718) & ~0x00000100;\n\tunk71c  = ram_rd32(fuc, 0x10071c) & ~0x00000100;\n\tr111100 = ram_rd32(fuc, 0x111100) & ~0x3a800000;\n\n\t \n\tif (device->chipset == 0xa8) {\n\t\tr111100 |= 0x08000000;\n\t\tif (!next->bios.ramcfg_10_02_04)\n\t\t\tunk714  |= 0x00000010;\n\t} else {\n\t\tif (next->bios.ramcfg_10_02_04) {\n\t\t\tswitch (ram->base.type) {\n\t\t\tcase NVKM_RAM_TYPE_DDR2:\n\t\t\tcase NVKM_RAM_TYPE_DDR3:\n\t\t\t\tr111100 &= ~0x00000020;\n\t\t\t\tif (next->bios.ramcfg_10_02_10)\n\t\t\t\t\tr111100 |= 0x08000004;\n\t\t\t\telse\n\t\t\t\t\tr111100 |= 0x00000024;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (ram->base.type) {\n\t\t\tcase NVKM_RAM_TYPE_DDR2:\n\t\t\tcase NVKM_RAM_TYPE_DDR3:\n\t\t\t\tr111100 &= ~0x00000024;\n\t\t\t\tr111100 |=  0x12800000;\n\n\t\t\t\tif (next->bios.ramcfg_10_02_10)\n\t\t\t\t\tr111100 |= 0x08000000;\n\t\t\t\tunk714  |= 0x00000010;\n\t\t\t\tbreak;\n\t\t\tcase NVKM_RAM_TYPE_GDDR3:\n\t\t\t\tr111100 |= 0x30000000;\n\t\t\t\tunk714  |= 0x00000020;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tunk714 |= (next->bios.ramcfg_10_04_01) << 8;\n\n\tif (next->bios.ramcfg_10_02_20)\n\t\tunk714 |= 0xf0000000;\n\tif (next->bios.ramcfg_10_02_02)\n\t\tunk718 |= 0x00000100;\n\tif (next->bios.ramcfg_10_02_01)\n\t\tunk71c |= 0x00000100;\n\tif (next->bios.timing_10_24 != 0xff) {\n\t\tunk718 &= ~0xf0000000;\n\t\tunk718 |= next->bios.timing_10_24 << 28;\n\t}\n\tif (next->bios.ramcfg_10_02_10)\n\t\tr111100 &= ~0x04020000;\n\n\tram_mask(fuc, 0x100714, 0xffffffff, unk714);\n\tram_mask(fuc, 0x10071c, 0xffffffff, unk71c);\n\tram_mask(fuc, 0x100718, 0xffffffff, unk718);\n\tram_mask(fuc, 0x111100, 0xffffffff, r111100);\n\n\tif (!next->bios.timing_10_ODT)\n\t\tgt215_ram_gpio(fuc, 0x2e, 0);\n\n\t \n\tif (!next->bios.ramcfg_DLLoff)\n\t\tnvkm_sddr2_dll_reset(fuc);\n\n\tif (ram->base.type == NVKM_RAM_TYPE_GDDR3) {\n\t\tram_nsec(fuc, 31000);\n\t} else {\n\t\tram_nsec(fuc, 14000);\n\t}\n\n\tif (ram->base.type == NVKM_RAM_TYPE_DDR3) {\n\t\tram_wr32(fuc, 0x100264, 0x1);\n\t\tram_nsec(fuc, 2000);\n\t}\n\n\tram_nuke(fuc, 0x100700);\n\tram_mask(fuc, 0x100700, 0x01000000, 0x01000000);\n\tram_mask(fuc, 0x100700, 0x01000000, 0x00000000);\n\n\t \n\tram_unblock(fuc);\n\tram_wr32(fuc, 0x611200, 0x3330);\n\n\t \n\tif (next->bios.rammap_10_04_02)\n\t\tram_mask(fuc, 0x100200, 0x00000800, 0x00000800);\n\tif (next->bios.ramcfg_10_02_10) {\n\t\tram_mask(fuc, 0x111104, 0x00000180, 0x00000180);\n\t\tram_mask(fuc, 0x111100, 0x40000000, 0x00000000);\n\t} else {\n\t\tram_mask(fuc, 0x111104, 0x00000600, 0x00000600);\n\t}\n\n\tif (mclk.pll) {\n\t\tram_mask(fuc, 0x004168, 0x00000001, 0x00000000);\n\t\tram_mask(fuc, 0x004168, 0x00000100, 0x00000000);\n\t} else {\n\t\tram_mask(fuc, 0x004000, 0x00000001, 0x00000000);\n\t\tram_mask(fuc, 0x004128, 0x00000001, 0x00000000);\n\t\tram_mask(fuc, 0x004128, 0x00000100, 0x00000000);\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngt215_ram_prog(struct nvkm_ram *base)\n{\n\tstruct gt215_ram *ram = gt215_ram(base);\n\tstruct gt215_ramfuc *fuc = &ram->fuc;\n\tstruct nvkm_device *device = ram->base.fb->subdev.device;\n\tbool exec = nvkm_boolopt(device->cfgopt, \"NvMemExec\", true);\n\n\tif (exec) {\n\t\tnvkm_mask(device, 0x001534, 0x2, 0x2);\n\n\t\tram_exec(fuc, true);\n\n\t\t \n\t\tnvkm_mask(device, 0x002504, 0x1, 0x0);\n\t\tnvkm_mask(device, 0x001534, 0x2, 0x0);\n\n\t\tnvkm_mask(device, 0x616308, 0x10, 0x10);\n\t\tnvkm_mask(device, 0x616b08, 0x10, 0x10);\n\t} else {\n\t\tram_exec(fuc, false);\n\t}\n\treturn 0;\n}\n\nstatic void\ngt215_ram_tidy(struct nvkm_ram *base)\n{\n\tstruct gt215_ram *ram = gt215_ram(base);\n\tram_exec(&ram->fuc, false);\n}\n\nstatic int\ngt215_ram_init(struct nvkm_ram *base)\n{\n\tstruct gt215_ram *ram = gt215_ram(base);\n\tgt215_link_train_init(ram);\n\treturn 0;\n}\n\nstatic void *\ngt215_ram_dtor(struct nvkm_ram *base)\n{\n\tstruct gt215_ram *ram = gt215_ram(base);\n\tgt215_link_train_fini(ram);\n\treturn ram;\n}\n\nstatic const struct nvkm_ram_func\ngt215_ram_func = {\n\t.dtor = gt215_ram_dtor,\n\t.init = gt215_ram_init,\n\t.calc = gt215_ram_calc,\n\t.prog = gt215_ram_prog,\n\t.tidy = gt215_ram_tidy,\n};\n\nint\ngt215_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)\n{\n\tstruct gt215_ram *ram;\n\tint ret, i;\n\n\tif (!(ram = kzalloc(sizeof(*ram), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pram = &ram->base;\n\n\tret = nv50_ram_ctor(&gt215_ram_func, fb, &ram->base);\n\tif (ret)\n\t\treturn ret;\n\n\tram->fuc.r_0x001610 = ramfuc_reg(0x001610);\n\tram->fuc.r_0x001700 = ramfuc_reg(0x001700);\n\tram->fuc.r_0x002504 = ramfuc_reg(0x002504);\n\tram->fuc.r_0x004000 = ramfuc_reg(0x004000);\n\tram->fuc.r_0x004004 = ramfuc_reg(0x004004);\n\tram->fuc.r_0x004018 = ramfuc_reg(0x004018);\n\tram->fuc.r_0x004128 = ramfuc_reg(0x004128);\n\tram->fuc.r_0x004168 = ramfuc_reg(0x004168);\n\tram->fuc.r_0x100080 = ramfuc_reg(0x100080);\n\tram->fuc.r_0x100200 = ramfuc_reg(0x100200);\n\tram->fuc.r_0x100210 = ramfuc_reg(0x100210);\n\tfor (i = 0; i < 9; i++)\n\t\tram->fuc.r_0x100220[i] = ramfuc_reg(0x100220 + (i * 4));\n\tram->fuc.r_0x100264 = ramfuc_reg(0x100264);\n\tram->fuc.r_0x1002d0 = ramfuc_reg(0x1002d0);\n\tram->fuc.r_0x1002d4 = ramfuc_reg(0x1002d4);\n\tram->fuc.r_0x1002dc = ramfuc_reg(0x1002dc);\n\tram->fuc.r_0x10053c = ramfuc_reg(0x10053c);\n\tram->fuc.r_0x1005a0 = ramfuc_reg(0x1005a0);\n\tram->fuc.r_0x1005a4 = ramfuc_reg(0x1005a4);\n\tram->fuc.r_0x100700 = ramfuc_reg(0x100700);\n\tram->fuc.r_0x100714 = ramfuc_reg(0x100714);\n\tram->fuc.r_0x100718 = ramfuc_reg(0x100718);\n\tram->fuc.r_0x10071c = ramfuc_reg(0x10071c);\n\tram->fuc.r_0x100720 = ramfuc_reg(0x100720);\n\tram->fuc.r_0x100760 = ramfuc_stride(0x100760, 4, ram->base.part_mask);\n\tram->fuc.r_0x1007a0 = ramfuc_stride(0x1007a0, 4, ram->base.part_mask);\n\tram->fuc.r_0x1007e0 = ramfuc_stride(0x1007e0, 4, ram->base.part_mask);\n\tram->fuc.r_0x100da0 = ramfuc_stride(0x100da0, 4, ram->base.part_mask);\n\tram->fuc.r_0x10f804 = ramfuc_reg(0x10f804);\n\tram->fuc.r_0x1110e0 = ramfuc_stride(0x1110e0, 4, ram->base.part_mask);\n\tram->fuc.r_0x111100 = ramfuc_reg(0x111100);\n\tram->fuc.r_0x111104 = ramfuc_reg(0x111104);\n\tram->fuc.r_0x1111e0 = ramfuc_reg(0x1111e0);\n\tram->fuc.r_0x111400 = ramfuc_reg(0x111400);\n\tram->fuc.r_0x611200 = ramfuc_reg(0x611200);\n\n\tif (ram->base.ranks > 1) {\n\t\tram->fuc.r_mr[0] = ramfuc_reg2(0x1002c0, 0x1002c8);\n\t\tram->fuc.r_mr[1] = ramfuc_reg2(0x1002c4, 0x1002cc);\n\t\tram->fuc.r_mr[2] = ramfuc_reg2(0x1002e0, 0x1002e8);\n\t\tram->fuc.r_mr[3] = ramfuc_reg2(0x1002e4, 0x1002ec);\n\t} else {\n\t\tram->fuc.r_mr[0] = ramfuc_reg(0x1002c0);\n\t\tram->fuc.r_mr[1] = ramfuc_reg(0x1002c4);\n\t\tram->fuc.r_mr[2] = ramfuc_reg(0x1002e0);\n\t\tram->fuc.r_mr[3] = ramfuc_reg(0x1002e4);\n\t}\n\tram->fuc.r_gpio[0] = ramfuc_reg(0x00e104);\n\tram->fuc.r_gpio[1] = ramfuc_reg(0x00e108);\n\tram->fuc.r_gpio[2] = ramfuc_reg(0x00e120);\n\tram->fuc.r_gpio[3] = ramfuc_reg(0x00e124);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}