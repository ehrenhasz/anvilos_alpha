{
  "module_name": "iccsense.c",
  "hash_id": "ba2505ed8c6e4b7e0d02effcf8a0b21580f327d121bc6a05604db16ae47cf5c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/iccsense.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/extdev.h>\n#include <subdev/bios/iccsense.h>\n\nstatic u32\nnvbios_iccsense_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt,\n\t\t      u8 *len)\n{\n\tstruct bit_entry bit_P;\n\tu32 iccsense;\n\n\tif (bit_entry(bios, 'P', &bit_P) || bit_P.version != 2 ||\n\t    bit_P.length < 0x2c)\n\t\treturn 0;\n\n\ticcsense = nvbios_rd32(bios, bit_P.offset + 0x28);\n\tif (!iccsense)\n\t\treturn 0;\n\n\t*ver = nvbios_rd08(bios, iccsense + 0);\n\tswitch (*ver) {\n\tcase 0x10:\n\tcase 0x20:\n\t\t*hdr = nvbios_rd08(bios, iccsense + 1);\n\t\t*len = nvbios_rd08(bios, iccsense + 2);\n\t\t*cnt = nvbios_rd08(bios, iccsense + 3);\n\t\treturn iccsense;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint\nnvbios_iccsense_parse(struct nvkm_bios *bios, struct nvbios_iccsense *iccsense)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tu8 ver, hdr, cnt, len, i;\n\tu32 table, entry;\n\n\ttable = nvbios_iccsense_table(bios, &ver, &hdr, &cnt, &len);\n\tif (!table || !cnt)\n\t\treturn -EINVAL;\n\n\tif (ver != 0x10 && ver != 0x20) {\n\t\tnvkm_error(subdev, \"ICCSENSE version 0x%02x unknown\\n\", ver);\n\t\treturn -EINVAL;\n\t}\n\n\ticcsense->nr_entry = cnt;\n\ticcsense->rail = kmalloc_array(cnt, sizeof(struct pwr_rail_t),\n\t\t\t\t       GFP_KERNEL);\n\tif (!iccsense->rail)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt; ++i) {\n\t\tstruct nvbios_extdev_func extdev;\n\t\tstruct pwr_rail_t *rail = &iccsense->rail[i];\n\t\tu8 res_start = 0;\n\t\tint r;\n\n\t\tentry = table + hdr + i * len;\n\n\t\tswitch(ver) {\n\t\tcase 0x10:\n\t\t\tif ((nvbios_rd08(bios, entry + 0x1) & 0xf8) == 0xf8)\n\t\t\t\trail->mode = 1;\n\t\t\telse\n\t\t\t\trail->mode = 0;\n\t\t\trail->extdev_id = nvbios_rd08(bios, entry + 0x2);\n\t\t\tres_start = 0x3;\n\t\t\tbreak;\n\t\tcase 0x20:\n\t\t\trail->mode = nvbios_rd08(bios, entry);\n\t\t\trail->extdev_id = nvbios_rd08(bios, entry + 0x1);\n\t\t\tres_start = 0x5;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (nvbios_extdev_parse(bios, rail->extdev_id, &extdev))\n\t\t\tcontinue;\n\n\t\tswitch (extdev.type) {\n\t\tcase NVBIOS_EXTDEV_INA209:\n\t\tcase NVBIOS_EXTDEV_INA219:\n\t\t\trail->resistor_count = 1;\n\t\t\tbreak;\n\t\tcase NVBIOS_EXTDEV_INA3221:\n\t\t\trail->resistor_count = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trail->resistor_count = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (r = 0; r < rail->resistor_count; ++r) {\n\t\t\trail->resistors[r].mohm = nvbios_rd08(bios, entry + res_start + r * 2);\n\t\t\trail->resistors[r].enabled = !(nvbios_rd08(bios, entry + res_start + r * 2 + 1) & 0x40);\n\t\t}\n\t\trail->config = nvbios_rd16(bios, entry + res_start + rail->resistor_count * 2);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}