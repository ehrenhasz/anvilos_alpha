{
  "module_name": "ramgf100.c",
  "hash_id": "4a4347270f2865f9179c2fab5fcd8360374b1d7b868eb1537a621159bd6354e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramgf100.c",
  "human_readable_source": " \n#define gf100_ram(p) container_of((p), struct gf100_ram, base)\n#include \"ram.h\"\n#include \"ramfuc.h\"\n\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n#include <subdev/bios/rammap.h>\n#include <subdev/bios/timing.h>\n#include <subdev/clk.h>\n#include <subdev/clk/pll.h>\n\nstruct gf100_ramfuc {\n\tstruct ramfuc base;\n\n\tstruct ramfuc_reg r_0x10fe20;\n\tstruct ramfuc_reg r_0x10fe24;\n\tstruct ramfuc_reg r_0x137320;\n\tstruct ramfuc_reg r_0x137330;\n\n\tstruct ramfuc_reg r_0x132000;\n\tstruct ramfuc_reg r_0x132004;\n\tstruct ramfuc_reg r_0x132100;\n\n\tstruct ramfuc_reg r_0x137390;\n\n\tstruct ramfuc_reg r_0x10f290;\n\tstruct ramfuc_reg r_0x10f294;\n\tstruct ramfuc_reg r_0x10f298;\n\tstruct ramfuc_reg r_0x10f29c;\n\tstruct ramfuc_reg r_0x10f2a0;\n\n\tstruct ramfuc_reg r_0x10f300;\n\tstruct ramfuc_reg r_0x10f338;\n\tstruct ramfuc_reg r_0x10f340;\n\tstruct ramfuc_reg r_0x10f344;\n\tstruct ramfuc_reg r_0x10f348;\n\n\tstruct ramfuc_reg r_0x10f910;\n\tstruct ramfuc_reg r_0x10f914;\n\n\tstruct ramfuc_reg r_0x100b0c;\n\tstruct ramfuc_reg r_0x10f050;\n\tstruct ramfuc_reg r_0x10f090;\n\tstruct ramfuc_reg r_0x10f200;\n\tstruct ramfuc_reg r_0x10f210;\n\tstruct ramfuc_reg r_0x10f310;\n\tstruct ramfuc_reg r_0x10f314;\n\tstruct ramfuc_reg r_0x10f610;\n\tstruct ramfuc_reg r_0x10f614;\n\tstruct ramfuc_reg r_0x10f800;\n\tstruct ramfuc_reg r_0x10f808;\n\tstruct ramfuc_reg r_0x10f824;\n\tstruct ramfuc_reg r_0x10f830;\n\tstruct ramfuc_reg r_0x10f988;\n\tstruct ramfuc_reg r_0x10f98c;\n\tstruct ramfuc_reg r_0x10f990;\n\tstruct ramfuc_reg r_0x10f998;\n\tstruct ramfuc_reg r_0x10f9b0;\n\tstruct ramfuc_reg r_0x10f9b4;\n\tstruct ramfuc_reg r_0x10fb04;\n\tstruct ramfuc_reg r_0x10fb08;\n\tstruct ramfuc_reg r_0x137300;\n\tstruct ramfuc_reg r_0x137310;\n\tstruct ramfuc_reg r_0x137360;\n\tstruct ramfuc_reg r_0x1373ec;\n\tstruct ramfuc_reg r_0x1373f0;\n\tstruct ramfuc_reg r_0x1373f8;\n\n\tstruct ramfuc_reg r_0x61c140;\n\tstruct ramfuc_reg r_0x611200;\n\n\tstruct ramfuc_reg r_0x13d8f4;\n};\n\nstruct gf100_ram {\n\tstruct nvkm_ram base;\n\tstruct gf100_ramfuc fuc;\n\tstruct nvbios_pll refpll;\n\tstruct nvbios_pll mempll;\n};\n\nstatic void\ngf100_ram_train(struct gf100_ramfuc *fuc, u32 magic)\n{\n\tstruct gf100_ram *ram = container_of(fuc, typeof(*ram), fuc);\n\tstruct nvkm_fb *fb = ram->base.fb;\n\tstruct nvkm_device *device = fb->subdev.device;\n\tu32 part = nvkm_rd32(device, 0x022438), i;\n\tu32 mask = nvkm_rd32(device, 0x022554);\n\tu32 addr = 0x110974;\n\n\tram_wr32(fuc, 0x10f910, magic);\n\tram_wr32(fuc, 0x10f914, magic);\n\n\tfor (i = 0; (magic & 0x80000000) && i < part; addr += 0x1000, i++) {\n\t\tif (mask & (1 << i))\n\t\t\tcontinue;\n\t\tram_wait(fuc, addr, 0x0000000f, 0x00000000, 500000);\n\t}\n}\n\nint\ngf100_ram_calc(struct nvkm_ram *base, u32 freq)\n{\n\tstruct gf100_ram *ram = gf100_ram(base);\n\tstruct gf100_ramfuc *fuc = &ram->fuc;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_clk *clk = device->clk;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvbios_ramcfg cfg;\n\tu8  ver, cnt, len, strap;\n\tstruct {\n\t\tu32 data;\n\t\tu8  size;\n\t} rammap, ramcfg, timing;\n\tint ref, div, out;\n\tint from, mode;\n\tint N1, M1, P;\n\tint ret;\n\n\t \n\trammap.data = nvbios_rammapEm(bios, freq / 1000, &ver, &rammap.size,\n\t\t\t\t      &cnt, &ramcfg.size, &cfg);\n\tif (!rammap.data || ver != 0x10 || rammap.size < 0x0e) {\n\t\tnvkm_error(subdev, \"invalid/missing rammap entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstrap = nvbios_ramcfg_index(subdev);\n\tif (strap >= cnt) {\n\t\tnvkm_error(subdev, \"invalid ramcfg strap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tramcfg.data = rammap.data + rammap.size + (strap * ramcfg.size);\n\tif (!ramcfg.data || ver != 0x10 || ramcfg.size < 0x0e) {\n\t\tnvkm_error(subdev, \"invalid/missing ramcfg entry\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tstrap = nvbios_rd08(bios, ramcfg.data + 0x01);\n\tif (strap != 0xff) {\n\t\ttiming.data = nvbios_timingEe(bios, strap, &ver, &timing.size,\n\t\t\t\t\t      &cnt, &len);\n\t\tif (!timing.data || ver != 0x10 || timing.size < 0x19) {\n\t\t\tnvkm_error(subdev, \"invalid/missing timing entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttiming.data = 0;\n\t}\n\n\tret = ram_init(fuc, ram->base.fb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfrom = !!(ram_rd32(fuc, 0x1373f0) & 0x00000002);  \n\n\t \n\tif (!(ram_rd32(fuc, 0x137300) & 0x00000100))\n\t\tref = nvkm_clk_read(clk, nv_clk_src_sppll0);\n\telse\n\t\tref = nvkm_clk_read(clk, nv_clk_src_sppll1);\n\tdiv = max(min((ref * 2) / freq, (u32)65), (u32)2) - 2;\n\tout = (ref * 2) / (div + 2);\n\tmode = freq != out;\n\n\tram_mask(fuc, 0x137360, 0x00000002, 0x00000000);\n\n\tif ((ram_rd32(fuc, 0x132000) & 0x00000002) || 0  ) {\n\t\tram_nuke(fuc, 0x132000);\n\t\tram_mask(fuc, 0x132000, 0x00000002, 0x00000002);\n\t\tram_mask(fuc, 0x132000, 0x00000002, 0x00000000);\n\t}\n\n\tif (mode == 1) {\n\t\tram_nuke(fuc, 0x10fe20);\n\t\tram_mask(fuc, 0x10fe20, 0x00000002, 0x00000002);\n\t\tram_mask(fuc, 0x10fe20, 0x00000002, 0x00000000);\n\t}\n\n \n\tram_wr32(fuc, 0x132100, 0x00000001);\n\n\tif (mode == 1 && from == 0) {\n\t\t \n\t\tret = gt215_pll_calc(subdev, &ram->refpll, ram->mempll.refclk,\n\t\t\t\t     &N1, NULL, &M1, &P);\n\t\tif (ret <= 0) {\n\t\t\tnvkm_error(subdev, \"unable to calc refpll\\n\");\n\t\t\treturn ret ? ret : -ERANGE;\n\t\t}\n\n\t\tram_wr32(fuc, 0x10fe20, 0x20010000);\n\t\tram_wr32(fuc, 0x137320, 0x00000003);\n\t\tram_wr32(fuc, 0x137330, 0x81200006);\n\t\tram_wr32(fuc, 0x10fe24, (P << 16) | (N1 << 8) | M1);\n\t\tram_wr32(fuc, 0x10fe20, 0x20010001);\n\t\tram_wait(fuc, 0x137390, 0x00020000, 0x00020000, 64000);\n\n\t\t \n\t\tret = gt215_pll_calc(subdev, &ram->mempll, freq,\n\t\t\t\t     &N1, NULL, &M1, &P);\n\t\tif (ret <= 0) {\n\t\t\tnvkm_error(subdev, \"unable to calc refpll\\n\");\n\t\t\treturn ret ? ret : -ERANGE;\n\t\t}\n\n\t\tram_wr32(fuc, 0x10fe20, 0x20010005);\n\t\tram_wr32(fuc, 0x132004, (P << 16) | (N1 << 8) | M1);\n\t\tram_wr32(fuc, 0x132000, 0x18010101);\n\t\tram_wait(fuc, 0x137390, 0x00000002, 0x00000002, 64000);\n\t} else\n\tif (mode == 0) {\n\t\tram_wr32(fuc, 0x137300, 0x00000003);\n\t}\n\n\tif (from == 0) {\n\t\tram_nuke(fuc, 0x10fb04);\n\t\tram_mask(fuc, 0x10fb04, 0x0000ffff, 0x00000000);\n\t\tram_nuke(fuc, 0x10fb08);\n\t\tram_mask(fuc, 0x10fb08, 0x0000ffff, 0x00000000);\n\t\tram_wr32(fuc, 0x10f988, 0x2004ff00);\n\t\tram_wr32(fuc, 0x10f98c, 0x003fc040);\n\t\tram_wr32(fuc, 0x10f990, 0x20012001);\n\t\tram_wr32(fuc, 0x10f998, 0x00011a00);\n\t\tram_wr32(fuc, 0x13d8f4, 0x00000000);\n\t} else {\n\t\tram_wr32(fuc, 0x10f988, 0x20010000);\n\t\tram_wr32(fuc, 0x10f98c, 0x00000000);\n\t\tram_wr32(fuc, 0x10f990, 0x20012001);\n\t\tram_wr32(fuc, 0x10f998, 0x00010a00);\n\t}\n\n\tif (from == 0) {\n \n\t}\n\n \n\tram_wr32(fuc, 0x100b0c, 0x00080012);\n \n \n\tram_wr32(fuc, 0x611200, 0x00003300);\n \n \n\n\tram_mask(fuc, 0x10f200, 0x00000800, 0x00000000);\n\tram_wr32(fuc, 0x10f210, 0x00000000);\n\tram_nsec(fuc, 1000);\n\tif (mode == 0)\n\t\tgf100_ram_train(fuc, 0x000c1001);\n\tram_wr32(fuc, 0x10f310, 0x00000001);\n\tram_nsec(fuc, 1000);\n\tram_wr32(fuc, 0x10f090, 0x00000061);\n\tram_wr32(fuc, 0x10f090, 0xc000007f);\n\tram_nsec(fuc, 1000);\n\n\tif (from == 0) {\n\t\tram_wr32(fuc, 0x10f824, 0x00007fd4);\n\t} else {\n\t\tram_wr32(fuc, 0x1373ec, 0x00020404);\n\t}\n\n\tif (mode == 0) {\n\t\tram_mask(fuc, 0x10f808, 0x00080000, 0x00000000);\n\t\tram_mask(fuc, 0x10f200, 0x00008000, 0x00008000);\n\t\tram_wr32(fuc, 0x10f830, 0x41500010);\n\t\tram_mask(fuc, 0x10f830, 0x01000000, 0x00000000);\n\t\tram_mask(fuc, 0x132100, 0x00000100, 0x00000100);\n\t\tram_wr32(fuc, 0x10f050, 0xff000090);\n\t\tram_wr32(fuc, 0x1373ec, 0x00020f0f);\n\t\tram_wr32(fuc, 0x1373f0, 0x00000003);\n\t\tram_wr32(fuc, 0x137310, 0x81201616);\n\t\tram_wr32(fuc, 0x132100, 0x00000001);\n \n\t\tram_wr32(fuc, 0x10f830, 0x00300017);\n\t\tram_wr32(fuc, 0x1373f0, 0x00000001);\n\t\tram_wr32(fuc, 0x10f824, 0x00007e77);\n\t\tram_wr32(fuc, 0x132000, 0x18030001);\n\t\tram_wr32(fuc, 0x10f090, 0x4000007e);\n\t\tram_nsec(fuc, 2000);\n\t\tram_wr32(fuc, 0x10f314, 0x00000001);\n\t\tram_wr32(fuc, 0x10f210, 0x80000000);\n\t\tram_wr32(fuc, 0x10f338, 0x00300220);\n\t\tram_wr32(fuc, 0x10f300, 0x0000011d);\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f290, 0x02060505);\n\t\tram_wr32(fuc, 0x10f294, 0x34208288);\n\t\tram_wr32(fuc, 0x10f298, 0x44050411);\n\t\tram_wr32(fuc, 0x10f29c, 0x0000114c);\n\t\tram_wr32(fuc, 0x10f2a0, 0x42e10069);\n\t\tram_wr32(fuc, 0x10f614, 0x40044f77);\n\t\tram_wr32(fuc, 0x10f610, 0x40044f77);\n\t\tram_wr32(fuc, 0x10f344, 0x00600009);\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f348, 0x00700008);\n\t\tram_wr32(fuc, 0x61c140, 0x19240000);\n\t\tram_wr32(fuc, 0x10f830, 0x00300017);\n\t\tgf100_ram_train(fuc, 0x80021001);\n\t\tgf100_ram_train(fuc, 0x80081001);\n\t\tram_wr32(fuc, 0x10f340, 0x00500004);\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f830, 0x01300017);\n\t\tram_wr32(fuc, 0x10f830, 0x00300017);\n \n \n\t\tram_wr32(fuc, 0x100b0c, 0x00080028);\n\t\tram_wr32(fuc, 0x611200, 0x00003330);\n\t} else {\n\t\tram_wr32(fuc, 0x10f800, 0x00001800);\n\t\tram_wr32(fuc, 0x13d8f4, 0x00000000);\n\t\tram_wr32(fuc, 0x1373ec, 0x00020404);\n\t\tram_wr32(fuc, 0x1373f0, 0x00000003);\n\t\tram_wr32(fuc, 0x10f830, 0x40700010);\n\t\tram_wr32(fuc, 0x10f830, 0x40500010);\n\t\tram_wr32(fuc, 0x13d8f4, 0x00000000);\n\t\tram_wr32(fuc, 0x1373f8, 0x00000000);\n\t\tram_wr32(fuc, 0x132100, 0x00000101);\n\t\tram_wr32(fuc, 0x137310, 0x89201616);\n\t\tram_wr32(fuc, 0x10f050, 0xff000090);\n\t\tram_wr32(fuc, 0x1373ec, 0x00030404);\n\t\tram_wr32(fuc, 0x1373f0, 0x00000002);\n\t \n\t\tram_wr32(fuc, 0x132100, 0x00000001);\n\t\tram_wr32(fuc, 0x1373f8, 0x00002000);\n\t\tram_nsec(fuc, 2000);\n\t\tram_wr32(fuc, 0x10f808, 0x7aaa0050);\n\t\tram_wr32(fuc, 0x10f830, 0x00500010);\n\t\tram_wr32(fuc, 0x10f200, 0x00ce1000);\n\t\tram_wr32(fuc, 0x10f090, 0x4000007e);\n\t\tram_nsec(fuc, 2000);\n\t\tram_wr32(fuc, 0x10f314, 0x00000001);\n\t\tram_wr32(fuc, 0x10f210, 0x80000000);\n\t\tram_wr32(fuc, 0x10f338, 0x00300200);\n\t\tram_wr32(fuc, 0x10f300, 0x0000084d);\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f290, 0x0b343825);\n\t\tram_wr32(fuc, 0x10f294, 0x3483028e);\n\t\tram_wr32(fuc, 0x10f298, 0x440c0600);\n\t\tram_wr32(fuc, 0x10f29c, 0x0000214c);\n\t\tram_wr32(fuc, 0x10f2a0, 0x42e20069);\n\t\tram_wr32(fuc, 0x10f200, 0x00ce0000);\n\t\tram_wr32(fuc, 0x10f614, 0x60044e77);\n\t\tram_wr32(fuc, 0x10f610, 0x60044e77);\n\t\tram_wr32(fuc, 0x10f340, 0x00500000);\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f344, 0x00600228);\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f348, 0x00700000);\n\t\tram_wr32(fuc, 0x13d8f4, 0x00000000);\n\t\tram_wr32(fuc, 0x61c140, 0x09a40000);\n\n\t\tgf100_ram_train(fuc, 0x800e1008);\n\n\t\tram_nsec(fuc, 1000);\n\t\tram_wr32(fuc, 0x10f800, 0x00001804);\n\t \n\t \n\t\tram_wr32(fuc, 0x13d8f4, 0x00000000);\n\t\tram_wr32(fuc, 0x100b0c, 0x00080028);\n\t\tram_wr32(fuc, 0x611200, 0x00003330);\n\t\tram_nsec(fuc, 100000);\n\t\tram_wr32(fuc, 0x10f9b0, 0x05313f41);\n\t\tram_wr32(fuc, 0x10f9b4, 0x00002f50);\n\n\t\tgf100_ram_train(fuc, 0x010c1001);\n\t}\n\n\tram_mask(fuc, 0x10f200, 0x00000800, 0x00000800);\n \n\n\tif (mode == 0)\n\t\tram_mask(fuc, 0x132000, 0x00000001, 0x00000000);\n\n\treturn 0;\n}\n\nint\ngf100_ram_prog(struct nvkm_ram *base)\n{\n\tstruct gf100_ram *ram = gf100_ram(base);\n\tstruct nvkm_device *device = ram->base.fb->subdev.device;\n\tram_exec(&ram->fuc, nvkm_boolopt(device->cfgopt, \"NvMemExec\", true));\n\treturn 0;\n}\n\nvoid\ngf100_ram_tidy(struct nvkm_ram *base)\n{\n\tstruct gf100_ram *ram = gf100_ram(base);\n\tram_exec(&ram->fuc, false);\n}\n\nint\ngf100_ram_init(struct nvkm_ram *base)\n{\n\tstatic const u8  train0[] = {\n\t\t0x00, 0xff, 0x55, 0xaa, 0x33, 0xcc,\n\t\t0x00, 0xff, 0xff, 0x00, 0xff, 0x00,\n\t};\n\tstatic const u32 train1[] = {\n\t\t0x00000000, 0xffffffff,\n\t\t0x55555555, 0xaaaaaaaa,\n\t\t0x33333333, 0xcccccccc,\n\t\t0xf0f0f0f0, 0x0f0f0f0f,\n\t\t0x00ff00ff, 0xff00ff00,\n\t\t0x0000ffff, 0xffff0000,\n\t};\n\tstruct gf100_ram *ram = gf100_ram(base);\n\tstruct nvkm_device *device = ram->base.fb->subdev.device;\n\tint i;\n\n\tswitch (ram->base.type) {\n\tcase NVKM_RAM_TYPE_GDDR5:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < 0x30; i++) {\n\t\tnvkm_wr32(device, 0x10f968, 0x00000000 | (i << 8));\n\t\tnvkm_wr32(device, 0x10f96c, 0x00000000 | (i << 8));\n\t\tnvkm_wr32(device, 0x10f920, 0x00000100 | train0[i % 12]);\n\t\tnvkm_wr32(device, 0x10f924, 0x00000100 | train0[i % 12]);\n\t\tnvkm_wr32(device, 0x10f918,              train1[i % 12]);\n\t\tnvkm_wr32(device, 0x10f91c,              train1[i % 12]);\n\t\tnvkm_wr32(device, 0x10f920, 0x00000000 | train0[i % 12]);\n\t\tnvkm_wr32(device, 0x10f924, 0x00000000 | train0[i % 12]);\n\t\tnvkm_wr32(device, 0x10f918,              train1[i % 12]);\n\t\tnvkm_wr32(device, 0x10f91c,              train1[i % 12]);\n\t}\n\n\treturn 0;\n}\n\nu32\ngf100_ram_probe_fbpa_amount(struct nvkm_device *device, int fbpa)\n{\n\treturn nvkm_rd32(device, 0x11020c + (fbpa * 0x1000));\n}\n\nu32\ngf100_ram_probe_fbp_amount(const struct nvkm_ram_func *func, u32 fbpao,\n\t\t\t   struct nvkm_device *device, int fbp, int *pltcs)\n{\n\tif (!(fbpao & BIT(fbp))) {\n\t\t*pltcs = 1;\n\t\treturn func->probe_fbpa_amount(device, fbp);\n\t}\n\treturn 0;\n}\n\nu32\ngf100_ram_probe_fbp(const struct nvkm_ram_func *func,\n\t\t    struct nvkm_device *device, int fbp, int *pltcs)\n{\n\tu32 fbpao = nvkm_rd32(device, 0x022554);\n\treturn func->probe_fbp_amount(func, fbpao, device, fbp, pltcs);\n}\n\nint\ngf100_ram_ctor(const struct nvkm_ram_func *func, struct nvkm_fb *fb,\n\t       struct nvkm_ram *ram)\n{\n\tstruct nvkm_subdev *subdev = &fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tconst u32 rsvd_head = ( 256 * 1024);  \n\tconst u32 rsvd_tail = (1024 * 1024);  \n\tenum nvkm_ram_type type = nvkm_fb_bios_memtype(bios);\n\tu32 fbps = nvkm_rd32(device, 0x022438);\n\tu64 total = 0, lcomm = ~0, lower, ubase, usize;\n\tint ret, fbp, ltcs, ltcn = 0;\n\n\tnvkm_debug(subdev, \"%d FBP(s)\\n\", fbps);\n\tfor (fbp = 0; fbp < fbps; fbp++) {\n\t\tu32 size = func->probe_fbp(func, device, fbp, &ltcs);\n\t\tif (size) {\n\t\t\tnvkm_debug(subdev, \"FBP %d: %4d MiB, %d LTC(s)\\n\",\n\t\t\t\t   fbp, size, ltcs);\n\t\t\tlcomm  = min(lcomm, (u64)(size / ltcs) << 20);\n\t\t\ttotal += (u64) size << 20;\n\t\t\tltcn  += ltcs;\n\t\t} else {\n\t\t\tnvkm_debug(subdev, \"FBP %d: disabled\\n\", fbp);\n\t\t}\n\t}\n\n\tlower = lcomm * ltcn;\n\tubase = lcomm + func->upper;\n\tusize = total - lower;\n\n\tnvkm_debug(subdev, \"Lower: %4lld MiB @ %010llx\\n\", lower >> 20, 0ULL);\n\tnvkm_debug(subdev, \"Upper: %4lld MiB @ %010llx\\n\", usize >> 20, ubase);\n\tnvkm_debug(subdev, \"Total: %4lld MiB\\n\", total >> 20);\n\n\tret = nvkm_ram_ctor(func, fb, type, total, ram);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_mm_fini(&ram->vram);\n\n\t \n\tif (lower != total) {\n\t\t \n\t\tret = nvkm_mm_init(&ram->vram, NVKM_RAM_MM_NORMAL,\n\t\t\t\t   rsvd_head >> NVKM_RAM_MM_SHIFT,\n\t\t\t\t   (lower - rsvd_head) >> NVKM_RAM_MM_SHIFT, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = nvkm_mm_init(&ram->vram, NVKM_RAM_MM_MIXED,\n\t\t\t\t   ubase >> NVKM_RAM_MM_SHIFT,\n\t\t\t\t   (usize - rsvd_tail) >> NVKM_RAM_MM_SHIFT, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = nvkm_mm_init(&ram->vram, NVKM_RAM_MM_NORMAL,\n\t\t\t\t   rsvd_head >> NVKM_RAM_MM_SHIFT,\n\t\t\t\t   (total - rsvd_head - rsvd_tail) >>\n\t\t\t\t   NVKM_RAM_MM_SHIFT, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint\ngf100_ram_new_(const struct nvkm_ram_func *func,\n\t       struct nvkm_fb *fb, struct nvkm_ram **pram)\n{\n\tstruct nvkm_subdev *subdev = &fb->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct gf100_ram *ram;\n\tint ret;\n\n\tif (!(ram = kzalloc(sizeof(*ram), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pram = &ram->base;\n\n\tret = gf100_ram_ctor(func, fb, &ram->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvbios_pll_parse(bios, 0x0c, &ram->refpll);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"mclk refpll data not found\\n\");\n\t\treturn ret;\n\t}\n\n\tret = nvbios_pll_parse(bios, 0x04, &ram->mempll);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"mclk pll data not found\\n\");\n\t\treturn ret;\n\t}\n\n\tram->fuc.r_0x10fe20 = ramfuc_reg(0x10fe20);\n\tram->fuc.r_0x10fe24 = ramfuc_reg(0x10fe24);\n\tram->fuc.r_0x137320 = ramfuc_reg(0x137320);\n\tram->fuc.r_0x137330 = ramfuc_reg(0x137330);\n\n\tram->fuc.r_0x132000 = ramfuc_reg(0x132000);\n\tram->fuc.r_0x132004 = ramfuc_reg(0x132004);\n\tram->fuc.r_0x132100 = ramfuc_reg(0x132100);\n\n\tram->fuc.r_0x137390 = ramfuc_reg(0x137390);\n\n\tram->fuc.r_0x10f290 = ramfuc_reg(0x10f290);\n\tram->fuc.r_0x10f294 = ramfuc_reg(0x10f294);\n\tram->fuc.r_0x10f298 = ramfuc_reg(0x10f298);\n\tram->fuc.r_0x10f29c = ramfuc_reg(0x10f29c);\n\tram->fuc.r_0x10f2a0 = ramfuc_reg(0x10f2a0);\n\n\tram->fuc.r_0x10f300 = ramfuc_reg(0x10f300);\n\tram->fuc.r_0x10f338 = ramfuc_reg(0x10f338);\n\tram->fuc.r_0x10f340 = ramfuc_reg(0x10f340);\n\tram->fuc.r_0x10f344 = ramfuc_reg(0x10f344);\n\tram->fuc.r_0x10f348 = ramfuc_reg(0x10f348);\n\n\tram->fuc.r_0x10f910 = ramfuc_reg(0x10f910);\n\tram->fuc.r_0x10f914 = ramfuc_reg(0x10f914);\n\n\tram->fuc.r_0x100b0c = ramfuc_reg(0x100b0c);\n\tram->fuc.r_0x10f050 = ramfuc_reg(0x10f050);\n\tram->fuc.r_0x10f090 = ramfuc_reg(0x10f090);\n\tram->fuc.r_0x10f200 = ramfuc_reg(0x10f200);\n\tram->fuc.r_0x10f210 = ramfuc_reg(0x10f210);\n\tram->fuc.r_0x10f310 = ramfuc_reg(0x10f310);\n\tram->fuc.r_0x10f314 = ramfuc_reg(0x10f314);\n\tram->fuc.r_0x10f610 = ramfuc_reg(0x10f610);\n\tram->fuc.r_0x10f614 = ramfuc_reg(0x10f614);\n\tram->fuc.r_0x10f800 = ramfuc_reg(0x10f800);\n\tram->fuc.r_0x10f808 = ramfuc_reg(0x10f808);\n\tram->fuc.r_0x10f824 = ramfuc_reg(0x10f824);\n\tram->fuc.r_0x10f830 = ramfuc_reg(0x10f830);\n\tram->fuc.r_0x10f988 = ramfuc_reg(0x10f988);\n\tram->fuc.r_0x10f98c = ramfuc_reg(0x10f98c);\n\tram->fuc.r_0x10f990 = ramfuc_reg(0x10f990);\n\tram->fuc.r_0x10f998 = ramfuc_reg(0x10f998);\n\tram->fuc.r_0x10f9b0 = ramfuc_reg(0x10f9b0);\n\tram->fuc.r_0x10f9b4 = ramfuc_reg(0x10f9b4);\n\tram->fuc.r_0x10fb04 = ramfuc_reg(0x10fb04);\n\tram->fuc.r_0x10fb08 = ramfuc_reg(0x10fb08);\n\tram->fuc.r_0x137310 = ramfuc_reg(0x137300);\n\tram->fuc.r_0x137310 = ramfuc_reg(0x137310);\n\tram->fuc.r_0x137360 = ramfuc_reg(0x137360);\n\tram->fuc.r_0x1373ec = ramfuc_reg(0x1373ec);\n\tram->fuc.r_0x1373f0 = ramfuc_reg(0x1373f0);\n\tram->fuc.r_0x1373f8 = ramfuc_reg(0x1373f8);\n\n\tram->fuc.r_0x61c140 = ramfuc_reg(0x61c140);\n\tram->fuc.r_0x611200 = ramfuc_reg(0x611200);\n\n\tram->fuc.r_0x13d8f4 = ramfuc_reg(0x13d8f4);\n\treturn 0;\n}\n\nstatic const struct nvkm_ram_func\ngf100_ram = {\n\t.upper = 0x0200000000ULL,\n\t.probe_fbp = gf100_ram_probe_fbp,\n\t.probe_fbp_amount = gf100_ram_probe_fbp_amount,\n\t.probe_fbpa_amount = gf100_ram_probe_fbpa_amount,\n\t.init = gf100_ram_init,\n\t.calc = gf100_ram_calc,\n\t.prog = gf100_ram_prog,\n\t.tidy = gf100_ram_tidy,\n};\n\nint\ngf100_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)\n{\n\treturn gf100_ram_new_(&gf100_ram, fb, pram);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}