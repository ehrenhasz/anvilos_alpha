{
  "module_name": "aux.c",
  "hash_id": "ae9c1d694032c1dd0c6aa5c1bfdd6fab9796a1f93cb95830d85170690719dfea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/aux.c",
  "human_readable_source": " \n\n#include <linux/string_helpers.h>\n\n#include \"aux.h\"\n#include \"pad.h\"\n\nstatic int\nnvkm_i2c_aux_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct nvkm_i2c_aux *aux = container_of(adap, typeof(*aux), i2c);\n\tstruct i2c_msg *msg = msgs;\n\tint ret, mcnt = num;\n\n\tret = nvkm_i2c_aux_acquire(aux);\n\tif (ret)\n\t\treturn ret;\n\n\twhile (mcnt--) {\n\t\tu8 remaining = msg->len;\n\t\tu8 *ptr = msg->buf;\n\n\t\twhile (remaining) {\n\t\t\tu8 cnt, retries, cmd;\n\n\t\t\tif (msg->flags & I2C_M_RD)\n\t\t\t\tcmd = 1;\n\t\t\telse\n\t\t\t\tcmd = 0;\n\n\t\t\tif (mcnt || remaining > 16)\n\t\t\t\tcmd |= 4;  \n\n\t\t\tfor (retries = 0, cnt = 0;\n\t\t\t     retries < 32 && !cnt;\n\t\t\t     retries++) {\n\t\t\t\tcnt = min_t(u8, remaining, 16);\n\t\t\t\tret = aux->func->xfer(aux, true, cmd,\n\t\t\t\t\t\t      msg->addr, ptr, &cnt);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!cnt) {\n\t\t\t\tAUX_TRACE(aux, \"no data after 32 retries\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tptr += cnt;\n\t\t\tremaining -= cnt;\n\t\t}\n\n\t\tmsg++;\n\t}\n\n\tret = num;\nout:\n\tnvkm_i2c_aux_release(aux);\n\treturn ret;\n}\n\nstatic u32\nnvkm_i2c_aux_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm\nnvkm_i2c_aux_i2c_algo = {\n\t.master_xfer = nvkm_i2c_aux_i2c_xfer,\n\t.functionality = nvkm_i2c_aux_i2c_func\n};\n\nvoid\nnvkm_i2c_aux_monitor(struct nvkm_i2c_aux *aux, bool monitor)\n{\n\tstruct nvkm_i2c_pad *pad = aux->pad;\n\tAUX_TRACE(aux, \"monitor: %s\", str_yes_no(monitor));\n\tif (monitor)\n\t\tnvkm_i2c_pad_mode(pad, NVKM_I2C_PAD_AUX);\n\telse\n\t\tnvkm_i2c_pad_mode(pad, NVKM_I2C_PAD_OFF);\n}\n\nvoid\nnvkm_i2c_aux_release(struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_i2c_pad *pad = aux->pad;\n\tAUX_TRACE(aux, \"release\");\n\tnvkm_i2c_pad_release(pad);\n\tmutex_unlock(&aux->mutex);\n}\n\nint\nnvkm_i2c_aux_acquire(struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_i2c_pad *pad = aux->pad;\n\tint ret;\n\n\tAUX_TRACE(aux, \"acquire\");\n\tmutex_lock(&aux->mutex);\n\n\tif (aux->enabled)\n\t\tret = nvkm_i2c_pad_acquire(pad, NVKM_I2C_PAD_AUX);\n\telse\n\t\tret = -EIO;\n\n\tif (ret)\n\t\tmutex_unlock(&aux->mutex);\n\treturn ret;\n}\n\nint\nnvkm_i2c_aux_xfer(struct nvkm_i2c_aux *aux, bool retry, u8 type,\n\t\t  u32 addr, u8 *data, u8 *size)\n{\n\tif (!*size && !aux->func->address_only) {\n\t\tAUX_ERR(aux, \"address-only transaction dropped\");\n\t\treturn -ENOSYS;\n\t}\n\treturn aux->func->xfer(aux, retry, type, addr, data, size);\n}\n\nint\nnvkm_i2c_aux_lnk_ctl(struct nvkm_i2c_aux *aux, int nr, int bw, bool ef)\n{\n\tif (aux->func->lnk_ctl)\n\t\treturn aux->func->lnk_ctl(aux, nr, bw, ef);\n\treturn -ENODEV;\n}\n\nvoid\nnvkm_i2c_aux_del(struct nvkm_i2c_aux **paux)\n{\n\tstruct nvkm_i2c_aux *aux = *paux;\n\tif (aux && !WARN_ON(!aux->func)) {\n\t\tAUX_TRACE(aux, \"dtor\");\n\t\tlist_del(&aux->head);\n\t\ti2c_del_adapter(&aux->i2c);\n\t\tkfree(*paux);\n\t\t*paux = NULL;\n\t}\n}\n\nvoid\nnvkm_i2c_aux_init(struct nvkm_i2c_aux *aux)\n{\n\tAUX_TRACE(aux, \"init\");\n\tmutex_lock(&aux->mutex);\n\taux->enabled = true;\n\tmutex_unlock(&aux->mutex);\n}\n\nvoid\nnvkm_i2c_aux_fini(struct nvkm_i2c_aux *aux)\n{\n\tAUX_TRACE(aux, \"fini\");\n\tmutex_lock(&aux->mutex);\n\taux->enabled = false;\n\tmutex_unlock(&aux->mutex);\n}\n\nint\nnvkm_i2c_aux_ctor(const struct nvkm_i2c_aux_func *func,\n\t\t  struct nvkm_i2c_pad *pad, int id,\n\t\t  struct nvkm_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = pad->i2c->subdev.device;\n\n\taux->func = func;\n\taux->pad = pad;\n\taux->id = id;\n\tmutex_init(&aux->mutex);\n\tlist_add_tail(&aux->head, &pad->i2c->aux);\n\tAUX_TRACE(aux, \"ctor\");\n\n\tsnprintf(aux->i2c.name, sizeof(aux->i2c.name), \"nvkm-%s-aux-%04x\",\n\t\t dev_name(device->dev), id);\n\taux->i2c.owner = THIS_MODULE;\n\taux->i2c.dev.parent = device->dev;\n\taux->i2c.algo = &nvkm_i2c_aux_i2c_algo;\n\treturn i2c_add_adapter(&aux->i2c);\n}\n\nint\nnvkm_i2c_aux_new_(const struct nvkm_i2c_aux_func *func,\n\t\t  struct nvkm_i2c_pad *pad, int id,\n\t\t  struct nvkm_i2c_aux **paux)\n{\n\tif (!(*paux = kzalloc(sizeof(**paux), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_i2c_aux_ctor(func, pad, id, *paux);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}