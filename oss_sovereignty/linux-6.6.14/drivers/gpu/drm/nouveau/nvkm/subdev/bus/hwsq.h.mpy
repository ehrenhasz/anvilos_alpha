{
  "module_name": "hwsq.h",
  "hash_id": "a7db4e53261e4f04c4d1f43a5c1e137df2419a2316b29f0cdded427e40bd2fd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bus/hwsq.h",
  "human_readable_source": " \n#ifndef __NVKM_BUS_HWSQ_H__\n#define __NVKM_BUS_HWSQ_H__\n#include <subdev/bus.h>\n\nstruct hwsq {\n\tstruct nvkm_subdev *subdev;\n\tstruct nvkm_hwsq *hwsq;\n\tint sequence;\n};\n\nstruct hwsq_reg {\n\tint sequence;\n\tbool force;\n\tu32 addr;\n\tu32 stride;  \n\tu32 mask;\n\tu32 data;\n};\n\nstatic inline struct hwsq_reg\nhwsq_stride(u32 addr, u32 stride, u32 mask)\n{\n\treturn (struct hwsq_reg) {\n\t\t.sequence = 0,\n\t\t.force = 0,\n\t\t.addr = addr,\n\t\t.stride = stride,\n\t\t.mask = mask,\n\t\t.data = 0xdeadbeef,\n\t};\n}\n\nstatic inline struct hwsq_reg\nhwsq_reg2(u32 addr1, u32 addr2)\n{\n\treturn (struct hwsq_reg) {\n\t\t.sequence = 0,\n\t\t.force = 0,\n\t\t.addr = addr1,\n\t\t.stride = addr2 - addr1,\n\t\t.mask = 0x3,\n\t\t.data = 0xdeadbeef,\n\t};\n}\n\nstatic inline struct hwsq_reg\nhwsq_reg(u32 addr)\n{\n\treturn (struct hwsq_reg) {\n\t\t.sequence = 0,\n\t\t.force = 0,\n\t\t.addr = addr,\n\t\t.stride = 0,\n\t\t.mask = 0x1,\n\t\t.data = 0xdeadbeef,\n\t};\n}\n\nstatic inline int\nhwsq_init(struct hwsq *ram, struct nvkm_subdev *subdev)\n{\n\tint ret;\n\n\tret = nvkm_hwsq_init(subdev, &ram->hwsq);\n\tif (ret)\n\t\treturn ret;\n\n\tram->sequence++;\n\tram->subdev = subdev;\n\treturn 0;\n}\n\nstatic inline int\nhwsq_exec(struct hwsq *ram, bool exec)\n{\n\tint ret = 0;\n\tif (ram->subdev) {\n\t\tret = nvkm_hwsq_fini(&ram->hwsq, exec);\n\t\tram->subdev = NULL;\n\t}\n\treturn ret;\n}\n\nstatic inline u32\nhwsq_rd32(struct hwsq *ram, struct hwsq_reg *reg)\n{\n\tstruct nvkm_device *device = ram->subdev->device;\n\tif (reg->sequence != ram->sequence)\n\t\treg->data = nvkm_rd32(device, reg->addr);\n\treturn reg->data;\n}\n\nstatic inline void\nhwsq_wr32(struct hwsq *ram, struct hwsq_reg *reg, u32 data)\n{\n\tu32 mask, off = 0;\n\n\treg->sequence = ram->sequence;\n\treg->data = data;\n\n\tfor (mask = reg->mask; mask > 0; mask = (mask & ~1) >> 1) {\n\t\tif (mask & 1)\n\t\t\tnvkm_hwsq_wr32(ram->hwsq, reg->addr+off, reg->data);\n\n\t\toff += reg->stride;\n\t}\n}\n\nstatic inline void\nhwsq_nuke(struct hwsq *ram, struct hwsq_reg *reg)\n{\n\treg->force = true;\n}\n\nstatic inline u32\nhwsq_mask(struct hwsq *ram, struct hwsq_reg *reg, u32 mask, u32 data)\n{\n\tu32 temp = hwsq_rd32(ram, reg);\n\tif (temp != ((temp & ~mask) | data) || reg->force)\n\t\thwsq_wr32(ram, reg, (temp & ~mask) | data);\n\treturn temp;\n}\n\nstatic inline void\nhwsq_setf(struct hwsq *ram, u8 flag, int data)\n{\n\tnvkm_hwsq_setf(ram->hwsq, flag, data);\n}\n\nstatic inline void\nhwsq_wait(struct hwsq *ram, u8 flag, u8 data)\n{\n\tnvkm_hwsq_wait(ram->hwsq, flag, data);\n}\n\nstatic inline void\nhwsq_wait_vblank(struct hwsq *ram)\n{\n\tnvkm_hwsq_wait_vblank(ram->hwsq);\n}\n\nstatic inline void\nhwsq_nsec(struct hwsq *ram, u32 nsec)\n{\n\tnvkm_hwsq_nsec(ram->hwsq, nsec);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}