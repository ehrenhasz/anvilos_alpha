{
  "module_name": "ramfuc.h",
  "hash_id": "72c8061a1dd01902c8b27a92c98e2c29117160cb6aedac83036efa9eca2e728c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramfuc.h",
  "human_readable_source": " \n#ifndef __NVKM_FBRAM_FUC_H__\n#define __NVKM_FBRAM_FUC_H__\n#include <subdev/fb.h>\n#include <subdev/pmu.h>\n\nstruct ramfuc {\n\tstruct nvkm_memx *memx;\n\tstruct nvkm_fb *fb;\n\tint sequence;\n};\n\nstruct ramfuc_reg {\n\tint sequence;\n\tbool force;\n\tu32 addr;\n\tu32 stride;  \n\tu32 mask;\n\tu32 data;\n};\n\nstatic inline struct ramfuc_reg\nramfuc_stride(u32 addr, u32 stride, u32 mask)\n{\n\treturn (struct ramfuc_reg) {\n\t\t.sequence = 0,\n\t\t.addr = addr,\n\t\t.stride = stride,\n\t\t.mask = mask,\n\t\t.data = 0xdeadbeef,\n\t};\n}\n\nstatic inline struct ramfuc_reg\nramfuc_reg2(u32 addr1, u32 addr2)\n{\n\treturn (struct ramfuc_reg) {\n\t\t.sequence = 0,\n\t\t.addr = addr1,\n\t\t.stride = addr2 - addr1,\n\t\t.mask = 0x3,\n\t\t.data = 0xdeadbeef,\n\t};\n}\n\nstatic noinline struct ramfuc_reg\nramfuc_reg(u32 addr)\n{\n\treturn (struct ramfuc_reg) {\n\t\t.sequence = 0,\n\t\t.addr = addr,\n\t\t.stride = 0,\n\t\t.mask = 0x1,\n\t\t.data = 0xdeadbeef,\n\t};\n}\n\nstatic inline int\nramfuc_init(struct ramfuc *ram, struct nvkm_fb *fb)\n{\n\tint ret = nvkm_memx_init(fb->subdev.device->pmu, &ram->memx);\n\tif (ret)\n\t\treturn ret;\n\n\tram->sequence++;\n\tram->fb = fb;\n\treturn 0;\n}\n\nstatic inline int\nramfuc_exec(struct ramfuc *ram, bool exec)\n{\n\tint ret = 0;\n\tif (ram->fb) {\n\t\tret = nvkm_memx_fini(&ram->memx, exec);\n\t\tram->fb = NULL;\n\t}\n\treturn ret;\n}\n\nstatic inline u32\nramfuc_rd32(struct ramfuc *ram, struct ramfuc_reg *reg)\n{\n\tstruct nvkm_device *device = ram->fb->subdev.device;\n\tif (reg->sequence != ram->sequence)\n\t\treg->data = nvkm_rd32(device, reg->addr);\n\treturn reg->data;\n}\n\nstatic inline void\nramfuc_wr32(struct ramfuc *ram, struct ramfuc_reg *reg, u32 data)\n{\n\tunsigned int mask, off = 0;\n\n\treg->sequence = ram->sequence;\n\treg->data = data;\n\n\tfor (mask = reg->mask; mask > 0; mask = (mask & ~1) >> 1) {\n\t\tif (mask & 1)\n\t\t\tnvkm_memx_wr32(ram->memx, reg->addr+off, reg->data);\n\t\toff += reg->stride;\n\t}\n}\n\nstatic inline void\nramfuc_nuke(struct ramfuc *ram, struct ramfuc_reg *reg)\n{\n\treg->force = true;\n}\n\nstatic inline u32\nramfuc_mask(struct ramfuc *ram, struct ramfuc_reg *reg, u32 mask, u32 data)\n{\n\tu32 temp = ramfuc_rd32(ram, reg);\n\tif (temp != ((temp & ~mask) | data) || reg->force) {\n\t\tramfuc_wr32(ram, reg, (temp & ~mask) | data);\n\t\treg->force = false;\n\t}\n\treturn temp;\n}\n\nstatic inline void\nramfuc_wait(struct ramfuc *ram, u32 addr, u32 mask, u32 data, u32 nsec)\n{\n\tnvkm_memx_wait(ram->memx, addr, mask, data, nsec);\n}\n\nstatic inline void\nramfuc_nsec(struct ramfuc *ram, u32 nsec)\n{\n\tnvkm_memx_nsec(ram->memx, nsec);\n}\n\nstatic inline void\nramfuc_wait_vblank(struct ramfuc *ram)\n{\n\tnvkm_memx_wait_vblank(ram->memx);\n}\n\nstatic inline void\nramfuc_train(struct ramfuc *ram)\n{\n\tnvkm_memx_train(ram->memx);\n}\n\nstatic inline int\nramfuc_train_result(struct nvkm_fb *fb, u32 *result, u32 rsize)\n{\n\treturn nvkm_memx_train_result(fb->subdev.device->pmu, result, rsize);\n}\n\nstatic inline void\nramfuc_block(struct ramfuc *ram)\n{\n\tnvkm_memx_block(ram->memx);\n}\n\nstatic inline void\nramfuc_unblock(struct ramfuc *ram)\n{\n\tnvkm_memx_unblock(ram->memx);\n}\n\n#define ram_init(s,p)        ramfuc_init(&(s)->base, (p))\n#define ram_exec(s,e)        ramfuc_exec(&(s)->base, (e))\n#define ram_have(s,r)        ((s)->r_##r.addr != 0x000000)\n#define ram_rd32(s,r)        ramfuc_rd32(&(s)->base, &(s)->r_##r)\n#define ram_wr32(s,r,d)      ramfuc_wr32(&(s)->base, &(s)->r_##r, (d))\n#define ram_nuke(s,r)        ramfuc_nuke(&(s)->base, &(s)->r_##r)\n#define ram_mask(s,r,m,d)    ramfuc_mask(&(s)->base, &(s)->r_##r, (m), (d))\n#define ram_wait(s,r,m,d,n)  ramfuc_wait(&(s)->base, (r), (m), (d), (n))\n#define ram_nsec(s,n)        ramfuc_nsec(&(s)->base, (n))\n#define ram_wait_vblank(s)   ramfuc_wait_vblank(&(s)->base)\n#define ram_train(s)         ramfuc_train(&(s)->base)\n#define ram_train_result(s,r,l) ramfuc_train_result((s), (r), (l))\n#define ram_block(s)         ramfuc_block(&(s)->base)\n#define ram_unblock(s)       ramfuc_unblock(&(s)->base)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}