{
  "module_name": "gp102.c",
  "hash_id": "48dc549b325031226f3496c2ef41f9400e568173741b4a40845d1d4d1477e247",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/acr/gp102.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/firmware.h>\n#include <core/memory.h>\n#include <subdev/mmu.h>\n#include <engine/sec2.h>\n\n#include <nvfw/acr.h>\n#include <nvfw/flcn.h>\n\nint\ngp102_acr_wpr_patch(struct nvkm_acr *acr, s64 adjust)\n{\n\tstruct wpr_header_v1 hdr;\n\tstruct lsb_header_v1 lsb;\n\tstruct nvkm_acr_lsfw *lsfw;\n\tu32 offset = 0;\n\n\tdo {\n\t\tnvkm_robj(acr->wpr, offset, &hdr, sizeof(hdr));\n\t\twpr_header_v1_dump(&acr->subdev, &hdr);\n\n\t\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\t\tif (lsfw->id != hdr.falcon_id)\n\t\t\t\tcontinue;\n\n\t\t\tnvkm_robj(acr->wpr, hdr.lsb_offset, &lsb, sizeof(lsb));\n\t\t\tlsb_header_v1_dump(&acr->subdev, &lsb);\n\n\t\t\tlsfw->func->bld_patch(acr, lsb.tail.bl_data_off, adjust);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += sizeof(hdr);\n\t} while (hdr.falcon_id != WPR_HEADER_V1_FALCON_ID_INVALID);\n\n\treturn 0;\n}\n\nint\ngp102_acr_wpr_build_lsb(struct nvkm_acr *acr, struct nvkm_acr_lsfw *lsfw)\n{\n\tstruct lsb_header_v1 hdr;\n\n\tif (WARN_ON(lsfw->sig->size != sizeof(hdr.signature)))\n\t\treturn -EINVAL;\n\n\tmemcpy(&hdr.signature, lsfw->sig->data, lsfw->sig->size);\n\tgm200_acr_wpr_build_lsb_tail(lsfw, &hdr.tail);\n\n\tnvkm_wobj(acr->wpr, lsfw->offset.lsb, &hdr, sizeof(hdr));\n\treturn 0;\n}\n\nint\ngp102_acr_wpr_build(struct nvkm_acr *acr, struct nvkm_acr_lsf *rtos)\n{\n\tstruct nvkm_acr_lsfw *lsfw;\n\tu32 offset = 0;\n\tint ret;\n\n\t \n\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\tstruct lsf_signature_v1 *sig = (void *)lsfw->sig->data;\n\t\tstruct wpr_header_v1 hdr = {\n\t\t\t.falcon_id = lsfw->id,\n\t\t\t.lsb_offset = lsfw->offset.lsb,\n\t\t\t.bootstrap_owner = NVKM_ACR_LSF_SEC2,\n\t\t\t.lazy_bootstrap = rtos && lsfw->id != rtos->id,\n\t\t\t.bin_version = sig->version,\n\t\t\t.status = WPR_HEADER_V1_STATUS_COPY,\n\t\t};\n\n\t\t \n\t\tnvkm_wobj(acr->wpr, offset, &hdr, sizeof(hdr));\n\t\toffset += sizeof(hdr);\n\n\t\t \n\t\tret = gp102_acr_wpr_build_lsb(acr, lsfw);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tnvkm_wobj(acr->wpr, lsfw->offset.img,\n\t\t\t\t    lsfw->img.data,\n\t\t\t\t    lsfw->img.size);\n\n\t\t \n\t\tlsfw->func->bld_write(acr, lsfw->offset.bld, lsfw);\n\t}\n\n\t \n\tnvkm_wo32(acr->wpr, offset, WPR_HEADER_V1_FALCON_ID_INVALID);\n\treturn 0;\n}\n\nint\ngp102_acr_wpr_alloc(struct nvkm_acr *acr, u32 wpr_size)\n{\n\tint ret = nvkm_memory_new(acr->subdev.device, NVKM_MEM_TARGET_INST,\n\t\t\t\t  ALIGN(wpr_size, 0x40000) << 1, 0x40000, true,\n\t\t\t\t  &acr->wpr);\n\tif (ret)\n\t\treturn ret;\n\n\tacr->shadow_start = nvkm_memory_addr(acr->wpr);\n\tacr->wpr_start = acr->shadow_start + (nvkm_memory_size(acr->wpr) >> 1);\n\tacr->wpr_end = acr->wpr_start + (nvkm_memory_size(acr->wpr) >> 1);\n\treturn 0;\n}\n\nu32\ngp102_acr_wpr_layout(struct nvkm_acr *acr)\n{\n\tstruct nvkm_acr_lsfw *lsfw;\n\tu32 wpr = 0;\n\n\twpr += 11   * sizeof(struct wpr_header_v1);\n\twpr  = ALIGN(wpr, 256);\n\n\twpr += 0x100;  \n\n\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\twpr  = ALIGN(wpr, 256);\n\t\tlsfw->offset.lsb = wpr;\n\t\twpr += sizeof(struct lsb_header_v1);\n\n\t\twpr  = ALIGN(wpr, 4096);\n\t\tlsfw->offset.img = wpr;\n\t\twpr += lsfw->img.size;\n\n\t\twpr  = ALIGN(wpr, 256);\n\t\tlsfw->offset.bld = wpr;\n\t\tlsfw->bl_data_size = ALIGN(lsfw->func->bld_size, 256);\n\t\twpr += lsfw->bl_data_size;\n\t}\n\n\treturn wpr;\n}\n\nint\ngp102_acr_wpr_parse(struct nvkm_acr *acr)\n{\n\tconst struct wpr_header_v1 *hdr = (void *)acr->wpr_fw->data;\n\tstruct nvkm_acr_lsfw *lsfw;\n\n\twhile (hdr->falcon_id != WPR_HEADER_V1_FALCON_ID_INVALID) {\n\t\twpr_header_v1_dump(&acr->subdev, hdr);\n\t\tlsfw = nvkm_acr_lsfw_add(NULL, acr, NULL, (hdr++)->falcon_id);\n\t\tif (IS_ERR(lsfw))\n\t\t\treturn PTR_ERR(lsfw);\n\t}\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(\"nvidia/gp102/acr/unload_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp102/acr/ucode_unload.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gp104/acr/unload_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp104/acr/ucode_unload.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gp106/acr/unload_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp106/acr/ucode_unload.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gp107/acr/unload_bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp107/acr/ucode_unload.bin\");\n\nstatic const struct nvkm_acr_hsf_fwif\ngp102_acr_unload_fwif[] = {\n\t{ 0, gm200_acr_hsfw_ctor, &gm200_acr_unload_0, NVKM_ACR_HSF_PMU, 0x1d, 0x00000010 },\n\t{}\n};\n\nint\ngp102_acr_load_setup(struct nvkm_falcon_fw *fw)\n{\n\tstruct flcn_acr_desc_v1 *desc = (void *)&fw->fw.img[fw->dmem_base_img];\n\tstruct nvkm_acr *acr = fw->falcon->owner->device->acr;\n\n\tdesc->wpr_region_id = 1;\n\tdesc->regions.no_regions = 2;\n\tdesc->regions.region_props[0].start_addr = acr->wpr_start >> 8;\n\tdesc->regions.region_props[0].end_addr = acr->wpr_end >> 8;\n\tdesc->regions.region_props[0].region_id = 1;\n\tdesc->regions.region_props[0].read_mask = 0xf;\n\tdesc->regions.region_props[0].write_mask = 0xc;\n\tdesc->regions.region_props[0].client_mask = 0x2;\n\tdesc->regions.region_props[0].shadow_mem_start_addr = acr->shadow_start >> 8;\n\tflcn_acr_desc_v1_dump(&acr->subdev, desc);\n\treturn 0;\n}\n\nstatic const struct nvkm_falcon_fw_func\ngp102_acr_load_0 = {\n\t.signature = gm200_flcn_fw_signature,\n\t.reset = gm200_flcn_fw_reset,\n\t.setup = gp102_acr_load_setup,\n\t.load = gm200_flcn_fw_load,\n\t.load_bld = gm200_acr_hsfw_load_bld,\n\t.boot = gm200_flcn_fw_boot,\n};\n\nMODULE_FIRMWARE(\"nvidia/gp102/acr/bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp102/acr/ucode_load.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gp104/acr/bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp104/acr/ucode_load.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gp106/acr/bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp106/acr/ucode_load.bin\");\n\nMODULE_FIRMWARE(\"nvidia/gp107/acr/bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gp107/acr/ucode_load.bin\");\n\nstatic const struct nvkm_acr_hsf_fwif\ngp102_acr_load_fwif[] = {\n\t{ 0, gm200_acr_hsfw_ctor, &gp102_acr_load_0, NVKM_ACR_HSF_SEC2, 0, 0x00000010 },\n\t{}\n};\n\nstatic const struct nvkm_acr_func\ngp102_acr = {\n\t.load = gp102_acr_load_fwif,\n\t.unload = gp102_acr_unload_fwif,\n\t.wpr_parse = gp102_acr_wpr_parse,\n\t.wpr_layout = gp102_acr_wpr_layout,\n\t.wpr_alloc = gp102_acr_wpr_alloc,\n\t.wpr_build = gp102_acr_wpr_build,\n\t.wpr_patch = gp102_acr_wpr_patch,\n\t.wpr_check = gm200_acr_wpr_check,\n\t.init = gm200_acr_init,\n};\n\nint\ngp102_acr_load(struct nvkm_acr *acr, int ver, const struct nvkm_acr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\tconst struct nvkm_acr_hsf_fwif *hsfwif;\n\n\thsfwif = nvkm_firmware_load(subdev, fwif->func->load, \"AcrLoad\",\n\t\t\t\t    acr, \"acr/bl\", \"acr/ucode_load\", \"load\");\n\tif (IS_ERR(hsfwif))\n\t\treturn PTR_ERR(hsfwif);\n\n\thsfwif = nvkm_firmware_load(subdev, fwif->func->unload, \"AcrUnload\",\n\t\t\t\t    acr, \"acr/unload_bl\", \"acr/ucode_unload\",\n\t\t\t\t    \"unload\");\n\tif (IS_ERR(hsfwif))\n\t\treturn PTR_ERR(hsfwif);\n\n\treturn 0;\n}\n\nstatic const struct nvkm_acr_fwif\ngp102_acr_fwif[] = {\n\t{  0, gp102_acr_load, &gp102_acr },\n\t{ -1, gm200_acr_nofw, &gm200_acr },\n\t{}\n};\n\nint\ngp102_acr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_acr **pacr)\n{\n\treturn nvkm_acr_new_(gp102_acr_fwif, device, type, inst, pacr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}