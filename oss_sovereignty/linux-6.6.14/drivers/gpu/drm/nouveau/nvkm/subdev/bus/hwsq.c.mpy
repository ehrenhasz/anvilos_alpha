{
  "module_name": "hwsq.c",
  "hash_id": "6ceaff7ff8919670c23a9d60f33023b1de140560593aa8bbb3abe2b6b7063c5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bus/hwsq.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstruct nvkm_hwsq {\n\tstruct nvkm_subdev *subdev;\n\tu32 addr;\n\tu32 data;\n\tstruct {\n\t\tu8 data[512];\n\t\tu16 size;\n\t} c;\n};\n\nstatic void\nhwsq_cmd(struct nvkm_hwsq *hwsq, int size, u8 data[])\n{\n\tmemcpy(&hwsq->c.data[hwsq->c.size], data, size * sizeof(data[0]));\n\thwsq->c.size += size;\n}\n\nint\nnvkm_hwsq_init(struct nvkm_subdev *subdev, struct nvkm_hwsq **phwsq)\n{\n\tstruct nvkm_hwsq *hwsq;\n\n\thwsq = *phwsq = kmalloc(sizeof(*hwsq), GFP_KERNEL);\n\tif (hwsq) {\n\t\thwsq->subdev = subdev;\n\t\thwsq->addr = ~0;\n\t\thwsq->data = ~0;\n\t\tmemset(hwsq->c.data, 0x7f, sizeof(hwsq->c.data));\n\t\thwsq->c.size = 0;\n\t}\n\n\treturn hwsq ? 0 : -ENOMEM;\n}\n\nint\nnvkm_hwsq_fini(struct nvkm_hwsq **phwsq, bool exec)\n{\n\tstruct nvkm_hwsq *hwsq = *phwsq;\n\tint ret = 0, i;\n\tif (hwsq) {\n\t\tstruct nvkm_subdev *subdev = hwsq->subdev;\n\t\tstruct nvkm_bus *bus = subdev->device->bus;\n\t\thwsq->c.size = (hwsq->c.size + 4) / 4;\n\t\tif (hwsq->c.size <= bus->func->hwsq_size) {\n\t\t\tif (exec)\n\t\t\t\tret = bus->func->hwsq_exec(bus,\n\t\t\t\t\t\t\t   (u32 *)hwsq->c.data,\n\t\t\t\t\t\t\t\t  hwsq->c.size);\n\t\t\tif (ret)\n\t\t\t\tnvkm_error(subdev, \"hwsq exec failed: %d\\n\", ret);\n\t\t} else {\n\t\t\tnvkm_error(subdev, \"hwsq ucode too large\\n\");\n\t\t\tret = -ENOSPC;\n\t\t}\n\n\t\tfor (i = 0; ret && i < hwsq->c.size; i++)\n\t\t\tnvkm_error(subdev, \"\\t%08x\\n\", ((u32 *)hwsq->c.data)[i]);\n\n\t\t*phwsq = NULL;\n\t\tkfree(hwsq);\n\t}\n\treturn ret;\n}\n\nvoid\nnvkm_hwsq_wr32(struct nvkm_hwsq *hwsq, u32 addr, u32 data)\n{\n\tnvkm_debug(hwsq->subdev, \"R[%06x] = %08x\\n\", addr, data);\n\n\tif (hwsq->data != data) {\n\t\tif ((data & 0xffff0000) != (hwsq->data & 0xffff0000)) {\n\t\t\thwsq_cmd(hwsq, 5, (u8[]){ 0xe2, data, data >> 8,\n\t\t\t\t\t\t  data >> 16, data >> 24 });\n\t\t} else {\n\t\t\thwsq_cmd(hwsq, 3, (u8[]){ 0x42, data, data >> 8 });\n\t\t}\n\t}\n\n\tif ((addr & 0xffff0000) != (hwsq->addr & 0xffff0000)) {\n\t\thwsq_cmd(hwsq, 5, (u8[]){ 0xe0, addr, addr >> 8,\n\t\t\t\t\t  addr >> 16, addr >> 24 });\n\t} else {\n\t\thwsq_cmd(hwsq, 3, (u8[]){ 0x40, addr, addr >> 8 });\n\t}\n\n\thwsq->addr = addr;\n\thwsq->data = data;\n}\n\nvoid\nnvkm_hwsq_setf(struct nvkm_hwsq *hwsq, u8 flag, int data)\n{\n\tnvkm_debug(hwsq->subdev, \" FLAG[%02x] = %d\\n\", flag, data);\n\tflag += 0x80;\n\tif (data >= 0)\n\t\tflag += 0x20;\n\tif (data >= 1)\n\t\tflag += 0x20;\n\thwsq_cmd(hwsq, 1, (u8[]){ flag });\n}\n\nvoid\nnvkm_hwsq_wait(struct nvkm_hwsq *hwsq, u8 flag, u8 data)\n{\n\tnvkm_debug(hwsq->subdev, \" WAIT[%02x] = %d\\n\", flag, data);\n\thwsq_cmd(hwsq, 3, (u8[]){ 0x5f, flag, data });\n}\n\nvoid\nnvkm_hwsq_wait_vblank(struct nvkm_hwsq *hwsq)\n{\n\tstruct nvkm_subdev *subdev = hwsq->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 heads, x, y, px = 0;\n\tint i, head_sync;\n\n\theads = nvkm_rd32(device, 0x610050);\n\tfor (i = 0; i < 2; i++) {\n\t\t \n\t\tif (heads & (2 << (i << 3))) {\n\t\t\tx = nvkm_rd32(device, 0x610b40 + (0x540 * i));\n\t\t\ty = (x & 0xffff0000) >> 16;\n\t\t\tx &= 0x0000ffff;\n\t\t\tif ((x * y) > px) {\n\t\t\t\tpx = (x * y);\n\t\t\t\thead_sync = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (px == 0) {\n\t\tnvkm_debug(subdev, \"WAIT VBLANK !NO ACTIVE HEAD\\n\");\n\t\treturn;\n\t}\n\n\tnvkm_debug(subdev, \"WAIT VBLANK HEAD%d\\n\", head_sync);\n\tnvkm_hwsq_wait(hwsq, head_sync ? 0x3 : 0x1, 0x0);\n\tnvkm_hwsq_wait(hwsq, head_sync ? 0x3 : 0x1, 0x1);\n}\n\nvoid\nnvkm_hwsq_nsec(struct nvkm_hwsq *hwsq, u32 nsec)\n{\n\tu8 shift = 0, usec = nsec / 1000;\n\twhile (usec & ~3) {\n\t\tusec >>= 2;\n\t\tshift++;\n\t}\n\n\tnvkm_debug(hwsq->subdev, \"    DELAY = %d ns\\n\", nsec);\n\thwsq_cmd(hwsq, 1, (u8[]){ 0x00 | (shift << 2) | usec });\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}