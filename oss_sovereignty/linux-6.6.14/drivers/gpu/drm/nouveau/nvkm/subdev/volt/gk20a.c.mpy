{
  "module_name": "gk20a.c",
  "hash_id": "e1e6685d326d11d765a16f972c8112cef4b65e20e3cc344af7f1756787af37e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/volt/gk20a.c",
  "human_readable_source": " \n#define gk20a_volt(p) container_of((p), struct gk20a_volt, base)\n#include \"priv.h\"\n\n#include <core/tegra.h>\n\n#include \"gk20a.h\"\n\nstatic const struct cvb_coef gk20a_cvb_coef[] = {\n\t \n\t  { 1209886, -36468,  515,   417, -13123,  203},\n\t  { 1130804, -27659,  296,   298, -10834,  221},\n\t  { 1162871, -27110,  247,   238, -10681,  268},\n\t  { 1220458, -28654,  247,   179, -10376,  298},\n\t  { 1280953, -30204,  247,   119,  -9766,  304},\n\t  { 1344547, -31777,  247,   119,  -8545,  292},\n\t  { 1420168, -34227,  269,    60,  -7172,  256},\n\t  { 1490757, -35955,  274,    60,  -5188,  197},\n\t  { 1599112, -42583,  398,     0,  -1831,  119},\n\t  { 1366986, -16459, -274,     0,  -3204,   72},\n\t  { 1391884, -17078, -274,   -60,  -1526,   30},\n\t  { 1415522, -17497, -274,   -60,   -458,    0},\n\t  { 1464061, -18331, -274,  -119,   1831,  -72},\n\t  { 1524225, -20064, -254,  -119,   4272, -155},\n\t  { 1608418, -21643, -269,     0,    763,  -48},\n};\n\n \nstatic inline int\ngk20a_volt_get_cvb_voltage(int speedo, int s_scale, const struct cvb_coef *coef)\n{\n\tint mv;\n\n\tmv = DIV_ROUND_CLOSEST(coef->c2 * speedo, s_scale);\n\tmv = DIV_ROUND_CLOSEST((mv + coef->c1) * speedo, s_scale) + coef->c0;\n\treturn mv;\n}\n\n \nstatic inline int\ngk20a_volt_get_cvb_t_voltage(int speedo, int temp, int s_scale, int t_scale,\n\t\t\t     const struct cvb_coef *coef)\n{\n\tint cvb_mv, mv;\n\n\tcvb_mv = gk20a_volt_get_cvb_voltage(speedo, s_scale, coef);\n\n\tmv = DIV_ROUND_CLOSEST(coef->c3 * speedo, s_scale) + coef->c4 +\n\t\tDIV_ROUND_CLOSEST(coef->c5 * temp, t_scale);\n\tmv = DIV_ROUND_CLOSEST(mv * temp, t_scale) + cvb_mv;\n\treturn mv;\n}\n\nstatic int\ngk20a_volt_calc_voltage(const struct cvb_coef *coef, int speedo)\n{\n\tstatic const int v_scale = 1000;\n\tint mv;\n\n\tmv = gk20a_volt_get_cvb_t_voltage(speedo, -10, 100, 10, coef);\n\tmv = DIV_ROUND_UP(mv, v_scale);\n\n\treturn mv * 1000;\n}\n\nstatic int\ngk20a_volt_vid_get(struct nvkm_volt *base)\n{\n\tstruct gk20a_volt *volt = gk20a_volt(base);\n\tint i, uv;\n\n\tuv = regulator_get_voltage(volt->vdd);\n\n\tfor (i = 0; i < volt->base.vid_nr; i++)\n\t\tif (volt->base.vid[i].uv >= uv)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int\ngk20a_volt_vid_set(struct nvkm_volt *base, u8 vid)\n{\n\tstruct gk20a_volt *volt = gk20a_volt(base);\n\tstruct nvkm_subdev *subdev = &volt->base.subdev;\n\n\tnvkm_debug(subdev, \"set voltage as %duv\\n\", volt->base.vid[vid].uv);\n\treturn regulator_set_voltage(volt->vdd, volt->base.vid[vid].uv, 1200000);\n}\n\nstatic int\ngk20a_volt_set_id(struct nvkm_volt *base, u8 id, int condition)\n{\n\tstruct gk20a_volt *volt = gk20a_volt(base);\n\tstruct nvkm_subdev *subdev = &volt->base.subdev;\n\tint prev_uv = regulator_get_voltage(volt->vdd);\n\tint target_uv = volt->base.vid[id].uv;\n\tint ret;\n\n\tnvkm_debug(subdev, \"prev=%d, target=%d, condition=%d\\n\",\n\t\t   prev_uv, target_uv, condition);\n\tif (!condition ||\n\t\t(condition < 0 && target_uv < prev_uv) ||\n\t\t(condition > 0 && target_uv > prev_uv)) {\n\t\tret = gk20a_volt_vid_set(&volt->base, volt->base.vid[id].vid);\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct nvkm_volt_func\ngk20a_volt = {\n\t.vid_get = gk20a_volt_vid_get,\n\t.vid_set = gk20a_volt_vid_set,\n\t.set_id = gk20a_volt_set_id,\n};\n\nint\ngk20a_volt_ctor(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\tconst struct cvb_coef *coefs, int nb_coefs,\n\t\tint vmin, struct gk20a_volt *volt)\n{\n\tstruct nvkm_device_tegra *tdev = device->func->tegra(device);\n\tint i, uv;\n\n\tnvkm_volt_ctor(&gk20a_volt, device, type, inst, &volt->base);\n\n\tuv = regulator_get_voltage(tdev->vdd);\n\tnvkm_debug(&volt->base.subdev, \"the default voltage is %duV\\n\", uv);\n\n\tvolt->vdd = tdev->vdd;\n\n\tvolt->base.vid_nr = nb_coefs;\n\tfor (i = 0; i < volt->base.vid_nr; i++) {\n\t\tvolt->base.vid[i].vid = i;\n\t\tvolt->base.vid[i].uv = max(\n\t\t\tgk20a_volt_calc_voltage(&coefs[i], tdev->gpu_speedo),\n\t\t\tvmin);\n\t\tnvkm_debug(&volt->base.subdev, \"%2d: vid=%d, uv=%d\\n\", i,\n\t\t\t   volt->base.vid[i].vid, volt->base.vid[i].uv);\n\t}\n\n\treturn 0;\n}\n\nint\ngk20a_volt_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_volt **pvolt)\n{\n\tstruct gk20a_volt *volt;\n\n\tvolt = kzalloc(sizeof(*volt), GFP_KERNEL);\n\tif (!volt)\n\t\treturn -ENOMEM;\n\t*pvolt = &volt->base;\n\n\treturn gk20a_volt_ctor(device, type, inst, gk20a_cvb_coef,\n\t\t\t       ARRAY_SIZE(gk20a_cvb_coef), 0, volt);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}