{
  "module_name": "nv40.c",
  "hash_id": "82120284c78e366210a44c6e90c0c907d3455d84c2eb1c0166c139fd3806b51e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/nv40.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nenum nv40_sensor_style { INVALID_STYLE = -1, OLD_STYLE = 0, NEW_STYLE = 1 };\n\nstatic enum nv40_sensor_style\nnv40_sensor_style(struct nvkm_therm *therm)\n{\n\tswitch (therm->subdev.device->chipset) {\n\tcase 0x43:\n\tcase 0x44:\n\tcase 0x4a:\n\tcase 0x47:\n\t\treturn OLD_STYLE;\n\tcase 0x46:\n\tcase 0x49:\n\tcase 0x4b:\n\tcase 0x4e:\n\tcase 0x4c:\n\tcase 0x67:\n\tcase 0x68:\n\tcase 0x63:\n\t\treturn NEW_STYLE;\n\tdefault:\n\t\treturn INVALID_STYLE;\n\t}\n}\n\nstatic int\nnv40_sensor_setup(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tenum nv40_sensor_style style = nv40_sensor_style(therm);\n\n\t \n\tif (style == NEW_STYLE) {\n\t\tnvkm_mask(device, 0x15b8, 0x80000000, 0);\n\t\tnvkm_wr32(device, 0x15b0, 0x80003fff);\n\t\tmdelay(20);  \n\t\treturn nvkm_rd32(device, 0x15b4) & 0x3fff;\n\t} else if (style == OLD_STYLE) {\n\t\tnvkm_wr32(device, 0x15b0, 0xff);\n\t\tmdelay(20);  \n\t\treturn nvkm_rd32(device, 0x15b4) & 0xff;\n\t} else\n\t\treturn -ENODEV;\n}\n\nstatic int\nnv40_temp_get(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\n\tenum nv40_sensor_style style = nv40_sensor_style(therm);\n\tint core_temp;\n\n\tif (style == NEW_STYLE) {\n\t\tnvkm_wr32(device, 0x15b0, 0x80003fff);\n\t\tcore_temp = nvkm_rd32(device, 0x15b4) & 0x3fff;\n\t} else if (style == OLD_STYLE) {\n\t\tnvkm_wr32(device, 0x15b0, 0xff);\n\t\tcore_temp = nvkm_rd32(device, 0x15b4) & 0xff;\n\t} else\n\t\treturn -ENODEV;\n\n\t \n\tif (!sensor->slope_div || !sensor->slope_mult ||\n\t    !sensor->offset_num || !sensor->offset_den)\n\t    return -ENODEV;\n\n\tcore_temp = core_temp * sensor->slope_mult / sensor->slope_div;\n\tcore_temp = core_temp + sensor->offset_num / sensor->offset_den;\n\tcore_temp = core_temp + sensor->offset_constant - 8;\n\n\t \n\tif (core_temp < 0)\n\t\tcore_temp = 0;\n\n\treturn core_temp;\n}\n\nstatic int\nnv40_fan_pwm_ctrl(struct nvkm_therm *therm, int line, bool enable)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mask = enable ? 0x80000000 : 0x00000000;\n\tif      (line == 2) nvkm_mask(device, 0x0010f0, 0x80000000, mask);\n\telse if (line == 9) nvkm_mask(device, 0x0015f4, 0x80000000, mask);\n\telse {\n\t\tnvkm_error(subdev, \"unknown pwm ctrl for gpio %d\\n\", line);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int\nnv40_fan_pwm_get(struct nvkm_therm *therm, int line, u32 *divs, u32 *duty)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tif (line == 2) {\n\t\tu32 reg = nvkm_rd32(device, 0x0010f0);\n\t\tif (reg & 0x80000000) {\n\t\t\t*duty = (reg & 0x7fff0000) >> 16;\n\t\t\t*divs = (reg & 0x00007fff);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\tif (line == 9) {\n\t\tu32 reg = nvkm_rd32(device, 0x0015f4);\n\t\tif (reg & 0x80000000) {\n\t\t\t*divs = nvkm_rd32(device, 0x0015f8);\n\t\t\t*duty = (reg & 0x7fffffff);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tnvkm_error(subdev, \"unknown pwm ctrl for gpio %d\\n\", line);\n\t\treturn -ENODEV;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnv40_fan_pwm_set(struct nvkm_therm *therm, int line, u32 divs, u32 duty)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tif (line == 2) {\n\t\tnvkm_mask(device, 0x0010f0, 0x7fff7fff, (duty << 16) | divs);\n\t} else\n\tif (line == 9) {\n\t\tnvkm_wr32(device, 0x0015f8, divs);\n\t\tnvkm_mask(device, 0x0015f4, 0x7fffffff, duty);\n\t} else {\n\t\tnvkm_error(subdev, \"unknown pwm ctrl for gpio %d\\n\", line);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid\nnv40_therm_intr(struct nvkm_therm *therm)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tuint32_t stat = nvkm_rd32(device, 0x1100);\n\n\t \n\n\t \n\tnvkm_wr32(device, 0x1100, 0x70000);\n\n\tnvkm_error(subdev, \"THERM received an IRQ: stat = %x\\n\", stat);\n}\n\nstatic void\nnv40_therm_init(struct nvkm_therm *therm)\n{\n\tnv40_sensor_setup(therm);\n}\n\nstatic const struct nvkm_therm_func\nnv40_therm = {\n\t.init = nv40_therm_init,\n\t.intr = nv40_therm_intr,\n\t.pwm_ctrl = nv40_fan_pwm_ctrl,\n\t.pwm_get = nv40_fan_pwm_get,\n\t.pwm_set = nv40_fan_pwm_set,\n\t.temp_get = nv40_temp_get,\n\t.program_alarms = nvkm_therm_program_alarms_polling,\n};\n\nint\nnv40_therm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_therm **ptherm)\n{\n\treturn nvkm_therm_new_(&nv40_therm, device, type, inst, ptherm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}