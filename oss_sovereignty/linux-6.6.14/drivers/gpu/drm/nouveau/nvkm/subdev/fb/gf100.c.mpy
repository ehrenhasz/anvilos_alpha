{
  "module_name": "gf100.c",
  "hash_id": "c2d9ebc64d6df0a52bd692f22fb1fd01c74e815831bb6c9d365c6e8a2ed4eb1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/gf100.c",
  "human_readable_source": " \n#include \"gf100.h\"\n#include \"ram.h\"\n\n#include <core/memory.h>\n#include <core/option.h>\n#include <subdev/therm.h>\n\nvoid\ngf100_fb_intr(struct nvkm_fb *base)\n{\n\tstruct gf100_fb *fb = gf100_fb(base);\n\tstruct nvkm_subdev *subdev = &fb->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 intr = nvkm_rd32(device, 0x000100);\n\tif (intr & 0x08000000)\n\t\tnvkm_debug(subdev, \"PFFB intr\\n\");\n\tif (intr & 0x00002000)\n\t\tnvkm_debug(subdev, \"PBFB intr\\n\");\n}\n\nint\ngf100_fb_oneinit(struct nvkm_fb *base)\n{\n\tstruct gf100_fb *fb = gf100_fb(base);\n\tstruct nvkm_device *device = fb->base.subdev.device;\n\tint ret, size = 1 << (fb->base.page ? fb->base.page : 17);\n\n\tsize = nvkm_longopt(device->cfgopt, \"MmuDebugBufferSize\", size);\n\tsize = max(size, 0x1000);\n\n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, size, 0x1000,\n\t\t\t      true, &fb->base.mmu_rd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, size, 0x1000,\n\t\t\t      true, &fb->base.mmu_wr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint\ngf100_fb_init_page(struct nvkm_fb *fb)\n{\n\tstruct nvkm_device *device = fb->subdev.device;\n\tswitch (fb->page) {\n\tcase 16: nvkm_mask(device, 0x100c80, 0x00000001, 0x00000001); break;\n\tcase 17: nvkm_mask(device, 0x100c80, 0x00000001, 0x00000000); break;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nvoid\ngf100_fb_sysmem_flush_page_init(struct nvkm_fb *fb)\n{\n\tnvkm_wr32(fb->subdev.device, 0x100c10, fb->sysmem.flush_page_addr >> 8);\n}\n\nvoid\ngf100_fb_init(struct nvkm_fb *base)\n{\n\tstruct gf100_fb *fb = gf100_fb(base);\n\tstruct nvkm_device *device = fb->base.subdev.device;\n\n\tif (base->func->clkgate_pack) {\n\t\tnvkm_therm_clkgate_init(device->therm,\n\t\t\t\t\tbase->func->clkgate_pack);\n\t}\n}\n\nvoid *\ngf100_fb_dtor(struct nvkm_fb *base)\n{\n\tstruct gf100_fb *fb = gf100_fb(base);\n\n\treturn fb;\n}\n\nint\ngf100_fb_new_(const struct nvkm_fb_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_fb **pfb)\n{\n\tstruct gf100_fb *fb;\n\n\tif (!(fb = kzalloc(sizeof(*fb), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_fb_ctor(func, device, type, inst, &fb->base);\n\t*pfb = &fb->base;\n\n\treturn 0;\n}\n\nstatic const struct nvkm_fb_func\ngf100_fb = {\n\t.dtor = gf100_fb_dtor,\n\t.oneinit = gf100_fb_oneinit,\n\t.init = gf100_fb_init,\n\t.init_page = gf100_fb_init_page,\n\t.intr = gf100_fb_intr,\n\t.sysmem.flush_page_init = gf100_fb_sysmem_flush_page_init,\n\t.ram_new = gf100_ram_new,\n\t.default_bigpage = 17,\n};\n\nint\ngf100_fb_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_fb **pfb)\n{\n\treturn gf100_fb_new_(&gf100_fb, device, type, inst, pfb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}