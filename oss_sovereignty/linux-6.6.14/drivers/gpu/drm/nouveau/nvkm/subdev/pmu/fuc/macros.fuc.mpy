{
  "module_name": "macros.fuc",
  "hash_id": "ab7faace60c11d151626353a64aa185e03695dcb11ec1177efc83a9a6ab29b89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/fuc/macros.fuc",
  "human_readable_source": "/*\n * Copyright 2013 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n#define GT215 0xa3\n#define GF100 0xc0\n#define GF119 0xd9\n#define GK208 0x108\n\n#include \"os.h\"\n\n// IO addresses\n#define NV_PPWR_INTR_TRIGGER                                             0x0000\n#define NV_PPWR_INTR_TRIGGER_USER1                                   0x00000080\n#define NV_PPWR_INTR_TRIGGER_USER0                                   0x00000040\n#define NV_PPWR_INTR_ACK                                                 0x0004\n#define NV_PPWR_INTR_ACK_SUBINTR                                     0x00000800\n#define NV_PPWR_INTR_ACK_WATCHDOG                                    0x00000002\n#define NV_PPWR_INTR                                                     0x0008\n#define NV_PPWR_INTR_SUBINTR                                         0x00000800\n#define NV_PPWR_INTR_USER1                                           0x00000080\n#define NV_PPWR_INTR_USER0                                           0x00000040\n#define NV_PPWR_INTR_PAUSE                                           0x00000020\n#define NV_PPWR_INTR_WATCHDOG                                        0x00000002\n#define NV_PPWR_INTR_EN_SET                                              0x0010\n#define NV_PPWR_INTR_EN_SET_SUBINTR                                  0x00000800\n#define NV_PPWR_INTR_EN_SET_WATCHDOG                                 0x00000002\n#define NV_PPWR_INTR_EN_CLR                                              0x0014\n#define NV_PPWR_INTR_EN_CLR_MASK                    /* fuck i hate envyas */ -1\n#define NV_PPWR_INTR_ROUTE                                               0x001c\n#define NV_PPWR_TIMER_LOW                                                0x002c\n#define NV_PPWR_WATCHDOG_TIME                                            0x0034\n#define NV_PPWR_WATCHDOG_ENABLE                                          0x0038\n#define NV_PPWR_CAPS                                                     0x0108\n#define NV_PPWR_UAS_CONFIG                                               0x0164\n#define NV_PPWR_UAS_CONFIG_ENABLE                                    0x00010000\n#if NVKM_PPWR_CHIPSET >= GK208\n#define NV_PPWR_DSCRATCH(i)                                   (4 * (i) + 0x0450)\n#endif\n#define NV_PPWR_FIFO_PUT(i)                                   (4 * (i) + 0x04a0)\n#define NV_PPWR_FIFO_GET(i)                                   (4 * (i) + 0x04b0)\n#define NV_PPWR_FIFO_INTR                                                0x04c0\n#define NV_PPWR_FIFO_INTR_EN                                             0x04c4\n#define NV_PPWR_RFIFO_PUT                                                0x04c8\n#define NV_PPWR_RFIFO_GET                                                0x04cc\n#define NV_PPWR_H2D                                                      0x04d0\n#define NV_PPWR_D2H                                                      0x04dc\n#if NVKM_PPWR_CHIPSET < GK208\n#define NV_PPWR_DSCRATCH(i)                                   (4 * (i) + 0x05d0)\n#endif\n#define NV_PPWR_SUBINTR                                                  0x0688\n#define NV_PPWR_SUBINTR_FIFO                                         0x00000002\n#define NV_PPWR_MMIO_ADDR                                                0x07a0\n#define NV_PPWR_MMIO_DATA                                                0x07a4\n#define NV_PPWR_MMIO_CTRL                                                0x07ac\n#define NV_PPWR_MMIO_CTRL_TRIGGER                                    0x00010000\n#define NV_PPWR_MMIO_CTRL_STATUS                                     0x00007000\n#define NV_PPWR_MMIO_CTRL_STATUS_IDLE                                0x00000000\n#define NV_PPWR_MMIO_CTRL_MASK                                       0x000000f0\n#define NV_PPWR_MMIO_CTRL_MASK_B32_0                                 0x000000f0\n#define NV_PPWR_MMIO_CTRL_OP                                         0x00000003\n#define NV_PPWR_MMIO_CTRL_OP_RD                                      0x00000001\n#define NV_PPWR_MMIO_CTRL_OP_WR                                      0x00000002\n#define NV_PPWR_OUTPUT                                                   0x07c0\n#define NV_PPWR_OUTPUT_FB_PAUSE                                      0x00000004\n#if NVKM_PPWR_CHIPSET < GF119\n#define NV_PPWR_OUTPUT_I2C_3_SCL                                     0x00000100\n#define NV_PPWR_OUTPUT_I2C_3_SDA                                     0x00000200\n#define NV_PPWR_OUTPUT_I2C_0_SCL                                     0x00001000\n#define NV_PPWR_OUTPUT_I2C_0_SDA                                     0x00002000\n#define NV_PPWR_OUTPUT_I2C_1_SCL                                     0x00004000\n#define NV_PPWR_OUTPUT_I2C_1_SDA                                     0x00008000\n#define NV_PPWR_OUTPUT_I2C_2_SCL                                     0x00010000\n#define NV_PPWR_OUTPUT_I2C_2_SDA                                     0x00020000\n#define NV_PPWR_OUTPUT_I2C_4_SCL                                     0x00040000\n#define NV_PPWR_OUTPUT_I2C_4_SDA                                     0x00080000\n#define NV_PPWR_OUTPUT_I2C_5_SCL                                     0x00100000\n#define NV_PPWR_OUTPUT_I2C_5_SDA                                     0x00200000\n#define NV_PPWR_OUTPUT_I2C_6_SCL                                     0x00400000\n#define NV_PPWR_OUTPUT_I2C_6_SDA                                     0x00800000\n#define NV_PPWR_OUTPUT_I2C_7_SCL                                     0x01000000\n#define NV_PPWR_OUTPUT_I2C_7_SDA                                     0x02000000\n#define NV_PPWR_OUTPUT_I2C_8_SCL                                     0x04000000\n#define NV_PPWR_OUTPUT_I2C_8_SDA                                     0x08000000\n#define NV_PPWR_OUTPUT_I2C_9_SCL                                     0x10000000\n#define NV_PPWR_OUTPUT_I2C_9_SDA                                     0x20000000\n#else\n#define NV_PPWR_OUTPUT_I2C_0_SCL                                     0x00000400\n#define NV_PPWR_OUTPUT_I2C_1_SCL                                     0x00000800\n#define NV_PPWR_OUTPUT_I2C_2_SCL                                     0x00001000\n#define NV_PPWR_OUTPUT_I2C_3_SCL                                     0x00002000\n#define NV_PPWR_OUTPUT_I2C_4_SCL                                     0x00004000\n#define NV_PPWR_OUTPUT_I2C_5_SCL                                     0x00008000\n#define NV_PPWR_OUTPUT_I2C_6_SCL                                     0x00010000\n#define NV_PPWR_OUTPUT_I2C_7_SCL                                     0x00020000\n#define NV_PPWR_OUTPUT_I2C_8_SCL                                     0x00040000\n#define NV_PPWR_OUTPUT_I2C_9_SCL                                     0x00080000\n#define NV_PPWR_OUTPUT_I2C_0_SDA                                     0x00100000\n#define NV_PPWR_OUTPUT_I2C_1_SDA                                     0x00200000\n#define NV_PPWR_OUTPUT_I2C_2_SDA                                     0x00400000\n#define NV_PPWR_OUTPUT_I2C_3_SDA                                     0x00800000\n#define NV_PPWR_OUTPUT_I2C_4_SDA                                     0x01000000\n#define NV_PPWR_OUTPUT_I2C_5_SDA                                     0x02000000\n#define NV_PPWR_OUTPUT_I2C_6_SDA                                     0x04000000\n#define NV_PPWR_OUTPUT_I2C_7_SDA                                     0x08000000\n#define NV_PPWR_OUTPUT_I2C_8_SDA                                     0x10000000\n#define NV_PPWR_OUTPUT_I2C_9_SDA                                     0x20000000\n#endif\n#define NV_PPWR_INPUT                                                    0x07c4\n#define NV_PPWR_OUTPUT_SET                                               0x07e0\n#define NV_PPWR_OUTPUT_SET_FB_PAUSE                                  0x00000004\n#define NV_PPWR_OUTPUT_CLR                                               0x07e4\n#define NV_PPWR_OUTPUT_CLR_FB_PAUSE                                  0x00000004\n\n// Inter-process message format\n.equ #msg_process 0x00 /* send() target, recv() sender */\n.equ #msg_message 0x04\n.equ #msg_data0   0x08\n.equ #msg_data1   0x0c\n\n// Kernel message IDs\n#define KMSG_FIFO  0x00000000\n#define KMSG_ALARM 0x00000001\n\n// Process message queue description\n.equ #proc_qlen 4 // log2(size of queue entry in bytes)\n.equ #proc_qnum 2 // log2(max number of entries in queue)\n.equ #proc_qmaskb (1 << #proc_qnum) // max number of entries in queue\n.equ #proc_qmaskp (#proc_qmaskb - 1)\n.equ #proc_qmaskf ((#proc_qmaskb << 1) - 1)\n.equ #proc_qsize  (1 << (#proc_qlen + #proc_qnum))\n\n// Process table entry\n.equ #proc_id    0x00\n.equ #proc_init  0x04\n.equ #proc_recv  0x08\n.equ #proc_time  0x0c\n.equ #proc_qput  0x10\n.equ #proc_qget  0x14\n.equ #proc_queue 0x18\n.equ #proc_size (0x18 + #proc_qsize)\n\n#define process(id,init,recv) /*\n*/\t.b32 id /*\n*/\t.b32 init /*\n*/\t.b32 recv /*\n*/\t.b32 0 /*\n*/\t.b32 0 /*\n*/\t.b32 0 /*\n*/\t.skip 64\n\n#if NVKM_PPWR_CHIPSET < GK208\n#define imm32(reg,val) /*\n*/\tmovw reg  ((val) & 0x0000ffff) /*\n*/\tsethi reg ((val) & 0xffff0000)\n#else\n#define imm32(reg,val) /*\n*/\tmov reg (val)\n#endif\n\n#ifndef NVKM_FALCON_UNSHIFTED_IO\n#define nv_iord(reg,ior) /*\n*/\tmov reg ior /*\n*/ \tshl b32 reg 6 /*\n*/ \tiord reg I[reg + 0x000]\n#else\n#define nv_iord(reg,ior) /*\n*/\tmov reg ior /*\n*/ \tiord reg I[reg + 0x000]\n#endif\n\n#ifndef NVKM_FALCON_UNSHIFTED_IO\n#define nv_iowr(ior,reg) /*\n*/\tmov $r0 ior /*\n*/ \tshl b32 $r0 6 /*\n*/ \tiowr I[$r0 + 0x000] reg /*\n*/\tclear b32 $r0\n#else\n#define nv_iowr(ior,reg) /*\n*/\tmov $r0 ior /*\n*/ \tiowr I[$r0 + 0x000] reg /*\n*/\tclear b32 $r0\n#endif\n\n#ifndef NVKM_FALCON_UNSHIFTED_IO\n#define nv_iowrs(ior,reg) /*\n*/\tmov $r0 ior /*\n*/ \tshl b32 $r0 6 /*\n*/ \tiowrs I[$r0 + 0x000] reg /*\n*/\tclear b32 $r0\n#else\n#define nv_iowrs(ior,reg) /*\n*/\tmov $r0 ior /*\n*/ \tiowrs I[$r0 + 0x000] reg /*\n*/\tclear b32 $r0\n#endif\n\n#define hash #\n#define fn(a) a\n#ifndef NVKM_FALCON_PC24\n#define call(a) call fn(hash)a\n#else\n#define call(a) lcall fn(hash)a\n#endif\n\n#ifndef NVKM_FALCON_MMIO_UAS\n#define nv_rd32(reg,addr) /*\n*/\tmov b32 $r14 addr /*\n*/\tcall(rd32) /*\n*/\tmov b32 reg $r13\n#else\n#define nv_rd32(reg,addr) /*\n*/ \tsethi $r0 0x14000000 /*\n*/\tor $r0 addr /*\n*/\tld b32 reg D[$r0] /*\n*/\tclear b32 $r0\n#endif\n\n#if !defined(NVKM_FALCON_MMIO_UAS) || defined(NVKM_FALCON_MMIO_TRAP)\n#define nv_wr32(addr,reg) /*\n*/\tpush addr /*\n*/\tpush reg /*\n*/\tpop $r13 /*\n*/\tpop $r14 /*\n*/\tcall(wr32)\n#else\n#define nv_wr32(addr,reg) /*\n*/ \tsethi $r0 0x14000000 /*\n*/\tor $r0 addr /*\n*/\tst b32 D[$r0] reg /*\n*/\tclear b32 $r0\n#endif\n\n#define st(size, addr, reg) /*\n*/\timm32($r0, addr) /*\n*/\tst size D[$r0] reg /*\n*/\tclear b32 $r0\n\n#define ld(size, reg, addr) /*\n*/\timm32($r0, addr)  /*\n*/\tld size reg D[$r0] /*\n*/\tclear b32 $r0\n\n// does a 64+64 -> 64 unsigned addition (C = A + B)\n#define addu64(reg_a_c_hi, reg_a_c_lo, b_hi, b_lo) /*\n*/    add b32 reg_a_c_lo b_lo /*\n*/    adc b32 reg_a_c_hi b_hi\n\n// does a 64+64 -> 64 substraction (C = A - B)\n#define subu64(reg_a_c_hi, reg_a_c_lo, b_hi, b_lo) /*\n*/    sub b32 reg_a_c_lo b_lo /*\n*/    sbb b32 reg_a_c_hi b_hi\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}