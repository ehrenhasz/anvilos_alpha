{
  "module_name": "mxms.c",
  "hash_id": "d3ce3689015e24ab421b1b0d4a6df8b7e99876a3e1b29869f0fd2f3cac363135",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/mxms.c",
  "human_readable_source": " \n#include \"mxms.h\"\n\n#define ROM16(x) get_unaligned_le16(&(x))\n#define ROM32(x) get_unaligned_le32(&(x))\n\nstatic u8 *\nmxms_data(struct nvkm_mxm *mxm)\n{\n\treturn mxm->mxms;\n\n}\n\nu16\nmxms_version(struct nvkm_mxm *mxm)\n{\n\tu8 *mxms = mxms_data(mxm);\n\tu16 version = (mxms[4] << 8) | mxms[5];\n\tswitch (version ) {\n\tcase 0x0200:\n\tcase 0x0201:\n\tcase 0x0300:\n\t\treturn version;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnvkm_debug(&mxm->subdev, \"unknown version %d.%d\\n\", mxms[4], mxms[5]);\n\treturn 0x0000;\n}\n\nu16\nmxms_headerlen(struct nvkm_mxm *mxm)\n{\n\treturn 8;\n}\n\nu16\nmxms_structlen(struct nvkm_mxm *mxm)\n{\n\treturn *(u16 *)&mxms_data(mxm)[6];\n}\n\nbool\nmxms_checksum(struct nvkm_mxm *mxm)\n{\n\tu16 size = mxms_headerlen(mxm) + mxms_structlen(mxm);\n\tu8 *mxms = mxms_data(mxm), sum = 0;\n\twhile (size--)\n\t\tsum += *mxms++;\n\tif (sum) {\n\t\tnvkm_debug(&mxm->subdev, \"checksum invalid\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool\nmxms_valid(struct nvkm_mxm *mxm)\n{\n\tu8 *mxms = mxms_data(mxm);\n\tif (*(u32 *)mxms != 0x5f4d584d) {\n\t\tnvkm_debug(&mxm->subdev, \"signature invalid\\n\");\n\t\treturn false;\n\t}\n\n\tif (!mxms_version(mxm) || !mxms_checksum(mxm))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nmxms_foreach(struct nvkm_mxm *mxm, u8 types,\n\t     bool (*exec)(struct nvkm_mxm *, u8 *, void *), void *info)\n{\n\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tu8 *mxms = mxms_data(mxm);\n\tu8 *desc = mxms + mxms_headerlen(mxm);\n\tu8 *fini = desc + mxms_structlen(mxm) - 1;\n\twhile (desc < fini) {\n\t\tu8 type = desc[0] & 0x0f;\n\t\tu8 headerlen = 0;\n\t\tu8 recordlen = 0;\n\t\tu8 entries = 0;\n\n\t\tswitch (type) {\n\t\tcase 0:  \n\t\t\tif (mxms_version(mxm) >= 0x0300)\n\t\t\t\theaderlen = 8;\n\t\t\telse\n\t\t\t\theaderlen = 6;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\tcase 2:  \n\t\tcase 3:  \n\t\t\theaderlen = 4;\n\t\t\tbreak;\n\t\tcase 4:  \n\t\t\theaderlen = 4;\n\t\t\trecordlen = 2;\n\t\t\tentries   = (ROM32(desc[0]) & 0x01f00000) >> 20;\n\t\t\tbreak;\n\t\tcase 5:  \n\t\t\theaderlen = 8;\n\t\t\tbreak;\n\t\tcase 6:  \n\t\t\tif (mxms_version(mxm) >= 0x0300) {\n\t\t\t\theaderlen = 4;\n\t\t\t\trecordlen = 8;\n\t\t\t\tentries   = (desc[1] & 0xf0) >> 4;\n\t\t\t} else {\n\t\t\t\theaderlen = 8;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 7:  \n\t\t\theaderlen = 8;\n\t\t\trecordlen = 4;\n\t\t\tentries   = desc[1] & 0x07;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnvkm_debug(subdev, \"unknown descriptor type %d\\n\", type);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (mxm->subdev.debug >= NV_DBG_DEBUG && (exec == NULL)) {\n\t\t\tstatic const char * mxms_desc[] = {\n\t\t\t\t\"ODS\", \"SCCS\", \"TS\", \"IPS\",\n\t\t\t\t\"GSD\", \"VSS\", \"BCS\", \"FCS\",\n\t\t\t};\n\t\t\tu8 *dump = desc;\n\t\t\tchar data[32], *ptr;\n\t\t\tint i, j;\n\n\t\t\tfor (j = headerlen - 1, ptr = data; j >= 0; j--)\n\t\t\t\tptr += sprintf(ptr, \"%02x\", dump[j]);\n\t\t\tdump += headerlen;\n\n\t\t\tnvkm_debug(subdev, \"%4s: %s\\n\", mxms_desc[type], data);\n\t\t\tfor (i = 0; i < entries; i++, dump += recordlen) {\n\t\t\t\tfor (j = recordlen - 1, ptr = data; j >= 0; j--)\n\t\t\t\t\tptr += sprintf(ptr, \"%02x\", dump[j]);\n\t\t\t\tnvkm_debug(subdev, \"      %s\\n\", data);\n\t\t\t}\n\t\t}\n\n\t\tif (types & (1 << type)) {\n\t\t\tif (!exec(mxm, desc, info))\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdesc += headerlen + (entries * recordlen);\n\t}\n\n\treturn true;\n}\n\nvoid\nmxms_output_device(struct nvkm_mxm *mxm, u8 *pdata, struct mxms_odev *desc)\n{\n\tu64 data = ROM32(pdata[0]);\n\tif (mxms_version(mxm) >= 0x0300)\n\t\tdata |= (u64)ROM16(pdata[4]) << 32;\n\n\tdesc->outp_type = (data & 0x00000000000000f0ULL) >> 4;\n\tdesc->ddc_port  = (data & 0x0000000000000f00ULL) >> 8;\n\tdesc->conn_type = (data & 0x000000000001f000ULL) >> 12;\n\tdesc->dig_conn  = (data & 0x0000000000780000ULL) >> 19;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}