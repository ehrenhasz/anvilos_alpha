{
  "module_name": "base.c",
  "hash_id": "045cc73dc3de19686e2569c32330a3299418be0476595df4351f673f903e5347",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/top/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstruct nvkm_top_device *\nnvkm_top_device_new(struct nvkm_top *top)\n{\n\tstruct nvkm_top_device *info = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (info) {\n\t\tinfo->type = NVKM_SUBDEV_NR;\n\t\tinfo->inst = -1;\n\t\tinfo->addr = 0;\n\t\tinfo->fault = -1;\n\t\tinfo->engine = -1;\n\t\tinfo->runlist = -1;\n\t\tinfo->reset = -1;\n\t\tinfo->intr = -1;\n\t\tlist_add_tail(&info->head, &top->device);\n\t}\n\treturn info;\n}\n\nu32\nnvkm_top_addr(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tstruct nvkm_top *top = device->top;\n\tstruct nvkm_top_device *info;\n\n\tif (top) {\n\t\tlist_for_each_entry(info, &top->device, head) {\n\t\t\tif (info->type == type && info->inst == inst)\n\t\t\t\treturn info->addr;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nu32\nnvkm_top_reset(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tstruct nvkm_top *top = device->top;\n\tstruct nvkm_top_device *info;\n\n\tif (top) {\n\t\tlist_for_each_entry(info, &top->device, head) {\n\t\t\tif (info->type == type && info->inst == inst && info->reset >= 0)\n\t\t\t\treturn BIT(info->reset);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nu32\nnvkm_top_intr_mask(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tstruct nvkm_top *top = device->top;\n\tstruct nvkm_top_device *info;\n\n\tif (top) {\n\t\tlist_for_each_entry(info, &top->device, head) {\n\t\t\tif (info->type == type && info->inst == inst && info->intr >= 0)\n\t\t\t\treturn BIT(info->intr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nnvkm_top_fault_id(struct nvkm_device *device, enum nvkm_subdev_type type, int inst)\n{\n\tstruct nvkm_top *top = device->top;\n\tstruct nvkm_top_device *info;\n\n\tlist_for_each_entry(info, &top->device, head) {\n\t\tif (info->type == type && info->inst == inst && info->fault >= 0)\n\t\t\treturn info->fault;\n\t}\n\n\treturn -ENOENT;\n}\n\nstruct nvkm_subdev *\nnvkm_top_fault(struct nvkm_device *device, int fault)\n{\n\tstruct nvkm_top *top = device->top;\n\tstruct nvkm_top_device *info;\n\n\tlist_for_each_entry(info, &top->device, head) {\n\t\tif (info->fault == fault)\n\t\t\treturn nvkm_device_subdev(device, info->type, info->inst);\n\t}\n\n\treturn NULL;\n}\n\nint\nnvkm_top_parse(struct nvkm_device *device)\n{\n\tstruct nvkm_top *top = device->top;\n\n\tif (!top || !list_empty(&top->device))\n\t\treturn 0;\n\n\treturn top->func->parse(top);\n}\n\nstatic void *\nnvkm_top_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_top *top = nvkm_top(subdev);\n\tstruct nvkm_top_device *info, *temp;\n\n\tlist_for_each_entry_safe(info, temp, &top->device, head) {\n\t\tlist_del(&info->head);\n\t\tkfree(info);\n\t}\n\n\treturn top;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_top = {\n\t.dtor = nvkm_top_dtor,\n};\n\nint\nnvkm_top_new_(const struct nvkm_top_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_top **ptop)\n{\n\tstruct nvkm_top *top;\n\tif (!(top = *ptop = kzalloc(sizeof(*top), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_subdev_ctor(&nvkm_top, device, type, inst, &top->subdev);\n\ttop->func = func;\n\tINIT_LIST_HEAD(&top->device);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}