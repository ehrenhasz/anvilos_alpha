{
  "module_name": "gf119.c",
  "hash_id": "e0059e21341136c62f7051cb7e1bfab21bbddf5b06a79f778de7933d9cd4e41c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/gf119.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstatic int\npwm_info(struct nvkm_therm *therm, int line)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 gpio = nvkm_rd32(device, 0x00d610 + (line * 0x04));\n\n\tswitch (gpio & 0x000000c0) {\n\tcase 0x00000000:  \n\tcase 0x00000040:  \n\t\tswitch (gpio & 0x0000001f) {\n\t\tcase 0x00: return 2;\n\t\tcase 0x19: return 1;\n\t\tcase 0x1c: return 0;\n\t\tcase 0x1e: return 2;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnvkm_error(subdev, \"GPIO %d unknown PWM: %08x\\n\", line, gpio);\n\treturn -ENODEV;\n}\n\nint\ngf119_fan_pwm_ctrl(struct nvkm_therm *therm, int line, bool enable)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tu32 data = enable ? 0x00000040 : 0x00000000;\n\tint indx = pwm_info(therm, line);\n\tif (indx < 0)\n\t\treturn indx;\n\telse if (indx < 2)\n\t\tnvkm_mask(device, 0x00d610 + (line * 0x04), 0x000000c0, data);\n\t \n\treturn 0;\n}\n\nint\ngf119_fan_pwm_get(struct nvkm_therm *therm, int line, u32 *divs, u32 *duty)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tint indx = pwm_info(therm, line);\n\tif (indx < 0)\n\t\treturn indx;\n\telse if (indx < 2) {\n\t\tif (nvkm_rd32(device, 0x00d610 + (line * 0x04)) & 0x00000040) {\n\t\t\t*divs = nvkm_rd32(device, 0x00e114 + (indx * 8));\n\t\t\t*duty = nvkm_rd32(device, 0x00e118 + (indx * 8));\n\t\t\treturn 0;\n\t\t}\n\t} else if (indx == 2) {\n\t\t*divs = nvkm_rd32(device, 0x0200d8) & 0x1fff;\n\t\t*duty = nvkm_rd32(device, 0x0200dc) & 0x1fff;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint\ngf119_fan_pwm_set(struct nvkm_therm *therm, int line, u32 divs, u32 duty)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tint indx = pwm_info(therm, line);\n\tif (indx < 0)\n\t\treturn indx;\n\telse if (indx < 2) {\n\t\tnvkm_wr32(device, 0x00e114 + (indx * 8), divs);\n\t\tnvkm_wr32(device, 0x00e118 + (indx * 8), duty | 0x80000000);\n\t} else if (indx == 2) {\n\t\tnvkm_mask(device, 0x0200d8, 0x1fff, divs);  \n\t\tnvkm_wr32(device, 0x0200dc, duty | 0x40000000);\n\t}\n\treturn 0;\n}\n\nint\ngf119_fan_pwm_clock(struct nvkm_therm *therm, int line)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tint indx = pwm_info(therm, line);\n\tif (indx < 0)\n\t\treturn 0;\n\telse if (indx < 2)\n\t\treturn (device->crystal * 1000) / 20;\n\telse\n\t\treturn device->crystal * 1000 / 10;\n}\n\nvoid\ngf119_therm_init(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\n\tg84_sensor_setup(therm);\n\n\t \n\tnvkm_mask(device, 0x00e720, 0x00000003, 0x00000002);\n\tif (therm->fan->tach.func != DCB_GPIO_UNUSED) {\n\t\tnvkm_mask(device, 0x00d79c, 0x000000ff, therm->fan->tach.line);\n\t\tnvkm_wr32(device, 0x00e724, device->crystal * 1000);\n\t\tnvkm_mask(device, 0x00e720, 0x00000001, 0x00000001);\n\t}\n\tnvkm_mask(device, 0x00e720, 0x00000002, 0x00000000);\n}\n\nstatic const struct nvkm_therm_func\ngf119_therm = {\n\t.init = gf119_therm_init,\n\t.fini = g84_therm_fini,\n\t.pwm_ctrl = gf119_fan_pwm_ctrl,\n\t.pwm_get = gf119_fan_pwm_get,\n\t.pwm_set = gf119_fan_pwm_set,\n\t.pwm_clock = gf119_fan_pwm_clock,\n\t.temp_get = g84_temp_get,\n\t.fan_sense = gt215_therm_fan_sense,\n\t.program_alarms = nvkm_therm_program_alarms_polling,\n};\n\nint\ngf119_therm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\tstruct nvkm_therm **ptherm)\n{\n\treturn nvkm_therm_new_(&gf119_therm, device, type, inst, ptherm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}