{
  "module_name": "gm200.c",
  "hash_id": "af0efc2c3139914e7fc618944bc83b7c5c0f745fd25738aa2c34463a4c86f444",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/gm200.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/pmu.h>\n#include <subdev/pmu.h>\n#include <subdev/timer.h>\n\nstatic void\npmu_code(struct nv50_devinit *init, u32 pmu, u32 img, u32 len, bool sec)\n{\n\tstruct nvkm_device *device = init->base.subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tint i;\n\n\tnvkm_wr32(device, 0x10a180, 0x01000000 | (sec ? 0x10000000 : 0) | pmu);\n\tfor (i = 0; i < len; i += 4) {\n\t\tif ((i & 0xff) == 0)\n\t\t\tnvkm_wr32(device, 0x10a188, (pmu + i) >> 8);\n\t\tnvkm_wr32(device, 0x10a184, nvbios_rd32(bios, img + i));\n\t}\n\n\twhile (i & 0xff) {\n\t\tnvkm_wr32(device, 0x10a184, 0x00000000);\n\t\ti += 4;\n\t}\n}\n\nstatic void\npmu_data(struct nv50_devinit *init, u32 pmu, u32 img, u32 len)\n{\n\tstruct nvkm_device *device = init->base.subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tint i;\n\n\tnvkm_wr32(device, 0x10a1c0, 0x01000000 | pmu);\n\tfor (i = 0; i < len; i += 4)\n\t\tnvkm_wr32(device, 0x10a1c4, nvbios_rd32(bios, img + i));\n}\n\nstatic u32\npmu_args(struct nv50_devinit *init, u32 argp, u32 argi)\n{\n\tstruct nvkm_device *device = init->base.subdev.device;\n\tnvkm_wr32(device, 0x10a1c0, argp);\n\tnvkm_wr32(device, 0x10a1c0, nvkm_rd32(device, 0x10a1c4) + argi);\n\treturn nvkm_rd32(device, 0x10a1c4);\n}\n\nstatic void\npmu_exec(struct nv50_devinit *init, u32 init_addr)\n{\n\tstruct nvkm_device *device = init->base.subdev.device;\n\tnvkm_wr32(device, 0x10a104, init_addr);\n\tnvkm_wr32(device, 0x10a10c, 0x00000000);\n\tnvkm_wr32(device, 0x10a100, 0x00000002);\n}\n\nstatic int\npmu_load(struct nv50_devinit *init, u8 type, bool post,\n\t u32 *init_addr_pmu, u32 *args_addr_pmu)\n{\n\tstruct nvkm_subdev *subdev = &init->base.subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvbios_pmuR pmu;\n\tint ret;\n\n\tif (!nvbios_pmuRm(bios, type, &pmu))\n\t\treturn -EINVAL;\n\n\tif (!post || !subdev->device->pmu)\n\t\treturn 0;\n\n\tret = nvkm_falcon_reset(&subdev->device->pmu->falcon);\n\tif (ret)\n\t\treturn ret;\n\n\tpmu_code(init, pmu.boot_addr_pmu, pmu.boot_addr, pmu.boot_size, false);\n\tpmu_code(init, pmu.code_addr_pmu, pmu.code_addr, pmu.code_size, true);\n\tpmu_data(init, pmu.data_addr_pmu, pmu.data_addr, pmu.data_size);\n\n\tif (init_addr_pmu) {\n\t\t*init_addr_pmu = pmu.init_addr_pmu;\n\t\t*args_addr_pmu = pmu.args_addr_pmu;\n\t\treturn 0;\n\t}\n\n\treturn pmu_exec(init, pmu.init_addr_pmu), 0;\n}\n\nvoid\ngm200_devinit_preos(struct nv50_devinit *init, bool post)\n{\n\t \n\tpmu_load(init, 0x01, post, NULL, NULL);\n}\n\nint\ngm200_devinit_post(struct nvkm_devinit *base, bool post)\n{\n\tstruct nv50_devinit *init = nv50_devinit(base);\n\tstruct nvkm_subdev *subdev = &init->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct bit_entry bit_I;\n\tu32 exec, args;\n\tint ret;\n\n\tif (bit_entry(bios, 'I', &bit_I) || bit_I.version != 1 ||\n\t\t\t\t\t    bit_I.length < 0x1c) {\n\t\tnvkm_error(subdev, \"VBIOS PMU init data not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = pmu_load(init, 0x04, post, &exec, &args);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"VBIOS PMU/DEVINIT not found\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (post) {\n\t\tu32 pmu = pmu_args(init, args + 0x08, 0x08);\n\t\tu32 img = nvbios_rd16(bios, bit_I.offset + 0x14);\n\t\tu32 len = nvbios_rd16(bios, bit_I.offset + 0x16);\n\t\tpmu_data(init, pmu, img, len);\n\t}\n\n\t \n\tif (post) {\n\t\tu32 pmu = pmu_args(init, args + 0x08, 0x10);\n\t\tu32 img = nvbios_rd16(bios, bit_I.offset + 0x18);\n\t\tu32 len = nvbios_rd16(bios, bit_I.offset + 0x1a);\n\t\tpmu_data(init, pmu, img, len);\n\t}\n\n\t \n\tif (post) {\n\t\tnvkm_wr32(device, 0x10a040, 0x00005000);\n\t\tpmu_exec(init, exec);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (nvkm_rd32(device, 0x10a040) & 0x00002000)\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tgm200_devinit_preos(init, post);\n\treturn 0;\n}\n\nstatic const struct nvkm_devinit_func\ngm200_devinit = {\n\t.preinit = gf100_devinit_preinit,\n\t.init = nv50_devinit_init,\n\t.post = gm200_devinit_post,\n\t.pll_set = gf100_devinit_pll_set,\n\t.disable = gm107_devinit_disable,\n};\n\nint\ngm200_devinit_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\t  struct nvkm_devinit **pinit)\n{\n\treturn nv50_devinit_new_(&gm200_devinit, device, type, inst, pinit);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}