{
  "module_name": "nv50.c",
  "hash_id": "dd3eb12d59617ae39ccb722b09d640557e2f69c5d20b48dce82f47545061cd4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/nv50.c",
  "human_readable_source": " \n#include \"nv50.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/bios/disp.h>\n#include <subdev/bios/init.h>\n#include <subdev/bios/pll.h>\n#include <subdev/clk/pll.h>\n#include <subdev/vga.h>\n\nint\nnv50_devinit_pll_set(struct nvkm_devinit *init, u32 type, u32 freq)\n{\n\tstruct nvkm_subdev *subdev = &init->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvbios_pll info;\n\tint N1, M1, N2, M2, P;\n\tint ret;\n\n\tret = nvbios_pll_parse(bios, type, &info);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"failed to retrieve pll data, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = nv04_pll_calc(subdev, &info, freq, &N1, &M1, &N2, &M2, &P);\n\tif (!ret) {\n\t\tnvkm_error(subdev, \"failed pll calculation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (info.type) {\n\tcase PLL_VPLL0:\n\tcase PLL_VPLL1:\n\t\tnvkm_wr32(device, info.reg + 0, 0x10000611);\n\t\tnvkm_mask(device, info.reg + 4, 0x00ff00ff, (M1 << 16) | N1);\n\t\tnvkm_mask(device, info.reg + 8, 0x7fff00ff, (P  << 28) |\n\t\t\t\t\t\t\t    (M2 << 16) | N2);\n\t\tbreak;\n\tcase PLL_MEMORY:\n\t\tnvkm_mask(device, info.reg + 0, 0x01ff0000,\n\t\t\t\t\t        (P << 22) |\n\t\t\t\t\t\t(info.bias_p << 19) |\n\t\t\t\t\t\t(P << 16));\n\t\tnvkm_wr32(device, info.reg + 4, (N1 << 8) | M1);\n\t\tbreak;\n\tdefault:\n\t\tnvkm_mask(device, info.reg + 0, 0x00070000, (P << 16));\n\t\tnvkm_wr32(device, info.reg + 4, (N1 << 8) | M1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv50_devinit_disable(struct nvkm_devinit *init)\n{\n\tstruct nvkm_device *device = init->subdev.device;\n\tu32 r001540 = nvkm_rd32(device, 0x001540);\n\n\tif (!(r001540 & 0x40000000))\n\t\tnvkm_subdev_disable(device, NVKM_ENGINE_MPEG, 0);\n}\n\nvoid\nnv50_devinit_preinit(struct nvkm_devinit *base)\n{\n\tstruct nvkm_subdev *subdev = &base->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tif (!base->post) {\n\t\tnvkm_devinit_disable(base);\n\t\tif (!device->disp)\n\t\t\tbase->post = true;\n\t}\n\n\t \n\tif (!base->post) {\n\t\tif (!nvkm_rdvgac(device, 0, 0x00) &&\n\t\t    !nvkm_rdvgac(device, 0, 0x1a)) {\n\t\t\tnvkm_debug(subdev, \"adaptor not initialised\\n\");\n\t\t\tbase->post = true;\n\t\t}\n\t}\n}\n\nvoid\nnv50_devinit_init(struct nvkm_devinit *base)\n{\n\tstruct nv50_devinit *init = nv50_devinit(base);\n\tstruct nvkm_subdev *subdev = &init->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvbios_outp info;\n\tstruct dcb_output outp;\n\tu8  ver = 0xff, hdr, cnt, len;\n\tint i = 0;\n\n\t \n\twhile (init->base.post && dcb_outp_parse(bios, i, &ver, &hdr, &outp)) {\n\t\tif (nvbios_outp_match(bios, outp.hasht, outp.hashm,\n\t\t\t\t      &ver, &hdr, &cnt, &len, &info)) {\n\t\t\tnvbios_init(subdev, info.script[0],\n\t\t\t\tinit.outp = &outp;\n\t\t\t\tinit.or   = ffs(outp.or) - 1;\n\t\t\t\tinit.link = outp.sorconf.link == 2;\n\t\t\t);\n\t\t}\n\t\ti++;\n\t}\n}\n\nint\nnv50_devinit_new_(const struct nvkm_devinit_func *func, struct nvkm_device *device,\n\t\t  enum nvkm_subdev_type type, int inst, struct nvkm_devinit **pinit)\n{\n\tstruct nv50_devinit *init;\n\n\tif (!(init = kzalloc(sizeof(*init), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pinit = &init->base;\n\n\tnvkm_devinit_ctor(func, device, type, inst, &init->base);\n\treturn 0;\n}\n\nstatic const struct nvkm_devinit_func\nnv50_devinit = {\n\t.preinit = nv50_devinit_preinit,\n\t.init = nv50_devinit_init,\n\t.post = nv04_devinit_post,\n\t.pll_set = nv50_devinit_pll_set,\n\t.disable = nv50_devinit_disable,\n};\n\nint\nnv50_devinit_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\t struct nvkm_devinit **pinit)\n{\n\treturn nv50_devinit_new_(&nv50_devinit, device, type, inst, pinit);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}