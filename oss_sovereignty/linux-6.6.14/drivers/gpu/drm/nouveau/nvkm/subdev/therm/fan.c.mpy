{
  "module_name": "fan.c",
  "hash_id": "08fa44769f8d394c2753293db1ddd323b4b181fb57df1192d9e81d6db66f0f87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/fan.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/bios/fan.h>\n#include <subdev/gpio.h>\n#include <subdev/timer.h>\n\nstatic int\nnvkm_fan_update(struct nvkm_fan *fan, bool immediate, int target)\n{\n\tstruct nvkm_therm *therm = fan->parent;\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_timer *tmr = subdev->device->timer;\n\tunsigned long flags;\n\tint ret = 0;\n\tint duty;\n\n\t \n\tspin_lock_irqsave(&fan->lock, flags);\n\tif (target < 0)\n\t\ttarget = fan->percent;\n\ttarget = max_t(u8, target, fan->bios.min_duty);\n\ttarget = min_t(u8, target, fan->bios.max_duty);\n\tif (fan->percent != target) {\n\t\tnvkm_debug(subdev, \"FAN target: %d\\n\", target);\n\t\tfan->percent = target;\n\t}\n\n\t \n\tduty = fan->get(therm);\n\tif (duty == target) {\n\t\tspin_unlock_irqrestore(&fan->lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!immediate && duty >= 0) {\n\t\t \n\t\tif (duty < target)\n\t\t\tduty = min(duty + 3, target);\n\t\telse if (duty > target)\n\t\t\tduty = max(duty - 3, target);\n\t} else {\n\t\tduty = target;\n\t}\n\n\tnvkm_debug(subdev, \"FAN update: %d\\n\", duty);\n\tret = fan->set(therm, duty);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&fan->lock, flags);\n\t\treturn ret;\n\t}\n\n\t \n\tspin_unlock_irqrestore(&fan->lock, flags);\n\n\t \n\tif (target != duty) {\n\t\tu16 bump_period = fan->bios.bump_period;\n\t\tu16 slow_down_period = fan->bios.slow_down_period;\n\t\tu64 delay;\n\n\t\tif (duty > target)\n\t\t\tdelay = slow_down_period;\n\t\telse if (duty == target)\n\t\t\tdelay = min(bump_period, slow_down_period) ;\n\t\telse\n\t\t\tdelay = bump_period;\n\n\t\tnvkm_timer_alarm(tmr, delay * 1000 * 1000, &fan->alarm);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nnvkm_fan_alarm(struct nvkm_alarm *alarm)\n{\n\tstruct nvkm_fan *fan = container_of(alarm, struct nvkm_fan, alarm);\n\tnvkm_fan_update(fan, false, -1);\n}\n\nint\nnvkm_therm_fan_get(struct nvkm_therm *therm)\n{\n\treturn therm->fan->get(therm);\n}\n\nint\nnvkm_therm_fan_set(struct nvkm_therm *therm, bool immediate, int percent)\n{\n\treturn nvkm_fan_update(therm->fan, immediate, percent);\n}\n\nint\nnvkm_therm_fan_sense(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tstruct nvkm_timer *tmr = device->timer;\n\tstruct nvkm_gpio *gpio = device->gpio;\n\tu32 cycles, cur, prev;\n\tu64 start, end, tach;\n\n\tif (therm->func->fan_sense)\n\t\treturn therm->func->fan_sense(therm);\n\n\tif (therm->fan->tach.func == DCB_GPIO_UNUSED)\n\t\treturn -ENODEV;\n\n\t \n\tstart = nvkm_timer_read(tmr);\n\tprev = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,\n\t\t\t\t      therm->fan->tach.line);\n\tcycles = 0;\n\tdo {\n\t\tusleep_range(500, 1000);  \n\n\t\tcur = nvkm_gpio_get(gpio, 0, therm->fan->tach.func,\n\t\t\t\t\t     therm->fan->tach.line);\n\t\tif (prev != cur) {\n\t\t\tif (!start)\n\t\t\t\tstart = nvkm_timer_read(tmr);\n\t\t\tcycles++;\n\t\t\tprev = cur;\n\t\t}\n\t} while (cycles < 5 && nvkm_timer_read(tmr) - start < 250000000);\n\tend = nvkm_timer_read(tmr);\n\n\tif (cycles == 5) {\n\t\ttach = (u64)60000000000ULL;\n\t\tdo_div(tach, (end - start));\n\t\treturn tach;\n\t} else\n\t\treturn 0;\n}\n\nint\nnvkm_therm_fan_user_get(struct nvkm_therm *therm)\n{\n\treturn nvkm_therm_fan_get(therm);\n}\n\nint\nnvkm_therm_fan_user_set(struct nvkm_therm *therm, int percent)\n{\n\tif (therm->mode != NVKM_THERM_CTRL_MANUAL)\n\t\treturn -EINVAL;\n\n\treturn nvkm_therm_fan_set(therm, true, percent);\n}\n\nstatic void\nnvkm_therm_fan_set_defaults(struct nvkm_therm *therm)\n{\n\ttherm->fan->bios.pwm_freq = 0;\n\ttherm->fan->bios.min_duty = 0;\n\ttherm->fan->bios.max_duty = 100;\n\ttherm->fan->bios.bump_period = 500;\n\ttherm->fan->bios.slow_down_period = 2000;\n\ttherm->fan->bios.linear_min_temp = 40;\n\ttherm->fan->bios.linear_max_temp = 85;\n}\n\nstatic void\nnvkm_therm_fan_safety_checks(struct nvkm_therm *therm)\n{\n\tif (therm->fan->bios.min_duty > 100)\n\t\ttherm->fan->bios.min_duty = 100;\n\tif (therm->fan->bios.max_duty > 100)\n\t\ttherm->fan->bios.max_duty = 100;\n\n\tif (therm->fan->bios.min_duty > therm->fan->bios.max_duty)\n\t\ttherm->fan->bios.min_duty = therm->fan->bios.max_duty;\n}\n\nint\nnvkm_therm_fan_init(struct nvkm_therm *therm)\n{\n\treturn 0;\n}\n\nint\nnvkm_therm_fan_fini(struct nvkm_therm *therm, bool suspend)\n{\n\tstruct nvkm_timer *tmr = therm->subdev.device->timer;\n\tif (suspend)\n\t\tnvkm_timer_alarm(tmr, 0, &therm->fan->alarm);\n\treturn 0;\n}\n\nint\nnvkm_therm_fan_ctor(struct nvkm_therm *therm)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_gpio *gpio = device->gpio;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct dcb_gpio_func func;\n\tint ret;\n\n\t \n\tret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN, 0xff, &func);\n\tif (ret == 0) {\n\t\t \n\t\tif (func.line != 16 && func.log[0] & DCB_GPIO_LOG_DIR_IN) {\n\t\t\tnvkm_debug(subdev, \"GPIO_FAN is in input mode\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = nvkm_fanpwm_create(therm, &func);\n\t\t\tif (ret != 0)\n\t\t\t\tret = nvkm_fantog_create(therm, &func);\n\t\t}\n\t}\n\n\t \n\tif (ret != 0) {\n\t\tret = nvkm_fannil_create(therm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnvkm_debug(subdev, \"FAN control: %s\\n\", therm->fan->type);\n\n\t \n\ttherm->fan->percent = nvkm_therm_fan_get(therm);\n\n\t \n\tret = nvkm_gpio_find(gpio, 0, DCB_GPIO_FAN_SENSE, 0xff,\n\t\t\t     &therm->fan->tach);\n\tif (ret)\n\t\ttherm->fan->tach.func = DCB_GPIO_UNUSED;\n\n\t \n\ttherm->fan->parent = therm;\n\tnvkm_alarm_init(&therm->fan->alarm, nvkm_fan_alarm);\n\tspin_lock_init(&therm->fan->lock);\n\n\t \n\tnvkm_therm_fan_set_defaults(therm);\n\tnvbios_perf_fan_parse(bios, &therm->fan->perf);\n\tif (!nvbios_fan_parse(bios, &therm->fan->bios)) {\n\t\tnvkm_debug(subdev, \"parsing the fan table failed\\n\");\n\t\tif (nvbios_therm_fan_parse(bios, &therm->fan->bios))\n\t\t\tnvkm_error(subdev, \"parsing both fan tables failed\\n\");\n\t}\n\tnvkm_therm_fan_safety_checks(therm);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}