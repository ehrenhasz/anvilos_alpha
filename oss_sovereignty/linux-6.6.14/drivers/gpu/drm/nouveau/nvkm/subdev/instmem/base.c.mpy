{
  "module_name": "base.c",
  "hash_id": "e32d08633b67cf09476071c6494329465809c012ba5749c570a387e6c38fcf8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/instmem/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/bar.h>\n\n \nstatic void\nnvkm_instobj_load(struct nvkm_instobj *iobj)\n{\n\tstruct nvkm_memory *memory = &iobj->memory;\n\tconst u64 size = nvkm_memory_size(memory);\n\tvoid __iomem *map;\n\tint i;\n\n\tif (!(map = nvkm_kmap(memory))) {\n\t\tfor (i = 0; i < size; i += 4)\n\t\t\tnvkm_wo32(memory, i, iobj->suspend[i / 4]);\n\t} else {\n\t\tmemcpy_toio(map, iobj->suspend, size);\n\t}\n\tnvkm_done(memory);\n\n\tkvfree(iobj->suspend);\n\tiobj->suspend = NULL;\n}\n\nstatic int\nnvkm_instobj_save(struct nvkm_instobj *iobj)\n{\n\tstruct nvkm_memory *memory = &iobj->memory;\n\tconst u64 size = nvkm_memory_size(memory);\n\tvoid __iomem *map;\n\tint i;\n\n\tiobj->suspend = kvmalloc(size, GFP_KERNEL);\n\tif (!iobj->suspend)\n\t\treturn -ENOMEM;\n\n\tif (!(map = nvkm_kmap(memory))) {\n\t\tfor (i = 0; i < size; i += 4)\n\t\t\tiobj->suspend[i / 4] = nvkm_ro32(memory, i);\n\t} else {\n\t\tmemcpy_fromio(iobj->suspend, map, size);\n\t}\n\tnvkm_done(memory);\n\treturn 0;\n}\n\nvoid\nnvkm_instobj_dtor(struct nvkm_instmem *imem, struct nvkm_instobj *iobj)\n{\n\tspin_lock(&imem->lock);\n\tlist_del(&iobj->head);\n\tspin_unlock(&imem->lock);\n}\n\nvoid\nnvkm_instobj_ctor(const struct nvkm_memory_func *func,\n\t\t  struct nvkm_instmem *imem, struct nvkm_instobj *iobj)\n{\n\tnvkm_memory_ctor(func, &iobj->memory);\n\tiobj->suspend = NULL;\n\tspin_lock(&imem->lock);\n\tlist_add_tail(&iobj->head, &imem->list);\n\tspin_unlock(&imem->lock);\n}\n\nint\nnvkm_instobj_wrap(struct nvkm_device *device,\n\t\t  struct nvkm_memory *memory, struct nvkm_memory **pmemory)\n{\n\tstruct nvkm_instmem *imem = device->imem;\n\n\tif (!imem->func->memory_wrap)\n\t\treturn -ENOSYS;\n\n\treturn imem->func->memory_wrap(imem, memory, pmemory);\n}\n\nint\nnvkm_instobj_new(struct nvkm_instmem *imem, u32 size, u32 align, bool zero,\n\t\t struct nvkm_memory **pmemory)\n{\n\tstruct nvkm_subdev *subdev = &imem->subdev;\n\tstruct nvkm_memory *memory = NULL;\n\tu32 offset;\n\tint ret;\n\n\tret = imem->func->memory_new(imem, size, align, zero, &memory);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"OOM: %08x %08x %d\\n\", size, align, ret);\n\t\tgoto done;\n\t}\n\n\tnvkm_trace(subdev, \"new %08x %08x %d: %010llx %010llx\\n\", size, align,\n\t\t   zero, nvkm_memory_addr(memory), nvkm_memory_size(memory));\n\n\tif (!imem->func->zero && zero) {\n\t\tvoid __iomem *map = nvkm_kmap(memory);\n\t\tif (unlikely(!map)) {\n\t\t\tfor (offset = 0; offset < size; offset += 4)\n\t\t\t\tnvkm_wo32(memory, offset, 0x00000000);\n\t\t} else {\n\t\t\tmemset_io(map, 0x00, size);\n\t\t}\n\t\tnvkm_done(memory);\n\t}\n\ndone:\n\tif (ret)\n\t\tnvkm_memory_unref(&memory);\n\t*pmemory = memory;\n\treturn ret;\n}\n\n \n\nu32\nnvkm_instmem_rd32(struct nvkm_instmem *imem, u32 addr)\n{\n\treturn imem->func->rd32(imem, addr);\n}\n\nvoid\nnvkm_instmem_wr32(struct nvkm_instmem *imem, u32 addr, u32 data)\n{\n\treturn imem->func->wr32(imem, addr, data);\n}\n\nvoid\nnvkm_instmem_boot(struct nvkm_instmem *imem)\n{\n\t \n\tstruct nvkm_instobj *iobj, *itmp;\n\tspin_lock(&imem->lock);\n\tlist_for_each_entry_safe(iobj, itmp, &imem->list, head) {\n\t\tlist_move_tail(&iobj->head, &imem->boot);\n\t}\n\tspin_unlock(&imem->lock);\n}\n\nstatic int\nnvkm_instmem_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_instmem *imem = nvkm_instmem(subdev);\n\tstruct nvkm_instobj *iobj;\n\n\tif (suspend) {\n\t\tlist_for_each_entry(iobj, &imem->list, head) {\n\t\t\tint ret = nvkm_instobj_save(iobj);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tnvkm_bar_bar2_fini(subdev->device);\n\n\t\tlist_for_each_entry(iobj, &imem->boot, head) {\n\t\t\tint ret = nvkm_instobj_save(iobj);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (imem->func->fini)\n\t\timem->func->fini(imem);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_instmem_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_instmem *imem = nvkm_instmem(subdev);\n\tstruct nvkm_instobj *iobj;\n\n\tlist_for_each_entry(iobj, &imem->boot, head) {\n\t\tif (iobj->suspend)\n\t\t\tnvkm_instobj_load(iobj);\n\t}\n\n\tnvkm_bar_bar2_init(subdev->device);\n\n\tlist_for_each_entry(iobj, &imem->list, head) {\n\t\tif (iobj->suspend)\n\t\t\tnvkm_instobj_load(iobj);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_instmem_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_instmem *imem = nvkm_instmem(subdev);\n\tif (imem->func->oneinit)\n\t\treturn imem->func->oneinit(imem);\n\treturn 0;\n}\n\nstatic void *\nnvkm_instmem_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_instmem *imem = nvkm_instmem(subdev);\n\tvoid *data = imem;\n\tif (imem->func->dtor)\n\t\tdata = imem->func->dtor(imem);\n\tmutex_destroy(&imem->mutex);\n\treturn data;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_instmem = {\n\t.dtor = nvkm_instmem_dtor,\n\t.oneinit = nvkm_instmem_oneinit,\n\t.init = nvkm_instmem_init,\n\t.fini = nvkm_instmem_fini,\n};\n\nvoid\nnvkm_instmem_ctor(const struct nvkm_instmem_func *func, struct nvkm_device *device,\n\t\t  enum nvkm_subdev_type type, int inst, struct nvkm_instmem *imem)\n{\n\tnvkm_subdev_ctor(&nvkm_instmem, device, type, inst, &imem->subdev);\n\timem->func = func;\n\tspin_lock_init(&imem->lock);\n\tINIT_LIST_HEAD(&imem->list);\n\tINIT_LIST_HEAD(&imem->boot);\n\tmutex_init(&imem->mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}