{
  "module_name": "i2c.c",
  "hash_id": "1d0194a58a2cf301e65e3333a62ff6bd38c7c80f6723058f16d45e5f589a6203",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/i2c.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/bios/i2c.h>\n\nu16\ndcb_i2c_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tu16 i2c = 0x0000;\n\tu16 dcb = dcb_table(bios, ver, hdr, cnt, len);\n\tif (dcb) {\n\t\tif (*ver >= 0x15)\n\t\t\ti2c = nvbios_rd16(bios, dcb + 2);\n\t\tif (*ver >= 0x30)\n\t\t\ti2c = nvbios_rd16(bios, dcb + 4);\n\t}\n\n\tif (i2c && *ver >= 0x42) {\n\t\tnvkm_warn(&bios->subdev, \"ccb %02x not supported\\n\", *ver);\n\t\treturn 0x0000;\n\t}\n\n\tif (i2c && *ver >= 0x30) {\n\t\t*ver = nvbios_rd08(bios, i2c + 0);\n\t\t*hdr = nvbios_rd08(bios, i2c + 1);\n\t\t*cnt = nvbios_rd08(bios, i2c + 2);\n\t\t*len = nvbios_rd08(bios, i2c + 3);\n\t} else {\n\t\t*ver = *ver;  \n\t\t*hdr = 0;\n\t\t*cnt = 16;\n\t\t*len = 4;\n\t}\n\n\treturn i2c;\n}\n\nu16\ndcb_i2c_entry(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len)\n{\n\tu8  hdr, cnt;\n\tu16 i2c = dcb_i2c_table(bios, ver, &hdr, &cnt, len);\n\tif (i2c && idx < cnt)\n\t\treturn i2c + hdr + (idx * *len);\n\treturn 0x0000;\n}\n\nint\ndcb_i2c_parse(struct nvkm_bios *bios, u8 idx, struct dcb_i2c_entry *info)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tu8  ver, len;\n\tu16 ent = dcb_i2c_entry(bios, idx, &ver, &len);\n\tif (ent) {\n\t\tif (ver >= 0x41) {\n\t\t\tu32 ent_value = nvbios_rd32(bios, ent);\n\t\t\tu8 i2c_port = (ent_value >> 0) & 0x1f;\n\t\t\tu8 dpaux_port = (ent_value >> 5) & 0x1f;\n\t\t\t \n\t\t\tif (i2c_port == 0x1f && dpaux_port == 0x1f)\n\t\t\t\tinfo->type = DCB_I2C_UNUSED;\n\t\t\telse\n\t\t\t\tinfo->type = DCB_I2C_PMGR;\n\t\t} else\n\t\tif (ver >= 0x30) {\n\t\t\tinfo->type = nvbios_rd08(bios, ent + 0x03);\n\t\t} else {\n\t\t\tinfo->type = nvbios_rd08(bios, ent + 0x03) & 0x07;\n\t\t\tif (info->type == 0x07)\n\t\t\t\tinfo->type = DCB_I2C_UNUSED;\n\t\t}\n\n\t\tinfo->drive = DCB_I2C_UNUSED;\n\t\tinfo->sense = DCB_I2C_UNUSED;\n\t\tinfo->share = DCB_I2C_UNUSED;\n\t\tinfo->auxch = DCB_I2C_UNUSED;\n\n\t\tswitch (info->type) {\n\t\tcase DCB_I2C_NV04_BIT:\n\t\t\tinfo->drive = nvbios_rd08(bios, ent + 0);\n\t\t\tinfo->sense = nvbios_rd08(bios, ent + 1);\n\t\t\treturn 0;\n\t\tcase DCB_I2C_NV4E_BIT:\n\t\t\tinfo->drive = nvbios_rd08(bios, ent + 1);\n\t\t\treturn 0;\n\t\tcase DCB_I2C_NVIO_BIT:\n\t\t\tinfo->drive = nvbios_rd08(bios, ent + 0) & 0x0f;\n\t\t\tif (nvbios_rd08(bios, ent + 1) & 0x01)\n\t\t\t\tinfo->share = nvbios_rd08(bios, ent + 1) >> 1;\n\t\t\treturn 0;\n\t\tcase DCB_I2C_NVIO_AUX:\n\t\t\tinfo->auxch = nvbios_rd08(bios, ent + 0) & 0x0f;\n\t\t\tif (nvbios_rd08(bios, ent + 1) & 0x01)\n\t\t\t\t\tinfo->share = info->auxch;\n\t\t\treturn 0;\n\t\tcase DCB_I2C_PMGR:\n\t\t\tinfo->drive = (nvbios_rd16(bios, ent + 0) & 0x01f) >> 0;\n\t\t\tif (info->drive == 0x1f)\n\t\t\t\tinfo->drive = DCB_I2C_UNUSED;\n\t\t\tinfo->auxch = (nvbios_rd16(bios, ent + 0) & 0x3e0) >> 5;\n\t\t\tif (info->auxch == 0x1f)\n\t\t\t\tinfo->auxch = DCB_I2C_UNUSED;\n\t\t\tinfo->share = info->auxch;\n\t\t\treturn 0;\n\t\tcase DCB_I2C_UNUSED:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tnvkm_warn(subdev, \"unknown i2c type %d\\n\", info->type);\n\t\t\tinfo->type = DCB_I2C_UNUSED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (bios->bmp_offset && idx < 2) {\n\t\t \n\t\tif (nvbios_rd08(bios, bios->bmp_offset + 5) < 4)\n\t\t\tent = 0x0048;\n\t\telse\n\t\t\tent = 0x0036 + bios->bmp_offset;\n\n\t\tif (idx == 0) {\n\t\t\tinfo->drive = nvbios_rd08(bios, ent + 4);\n\t\t\tif (!info->drive) info->drive = 0x3f;\n\t\t\tinfo->sense = nvbios_rd08(bios, ent + 5);\n\t\t\tif (!info->sense) info->sense = 0x3e;\n\t\t} else\n\t\tif (idx == 1) {\n\t\t\tinfo->drive = nvbios_rd08(bios, ent + 6);\n\t\t\tif (!info->drive) info->drive = 0x37;\n\t\t\tinfo->sense = nvbios_rd08(bios, ent + 7);\n\t\t\tif (!info->sense) info->sense = 0x36;\n\t\t}\n\n\t\tinfo->type  = DCB_I2C_NV04_BIT;\n\t\tinfo->share = DCB_I2C_UNUSED;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}