{
  "module_name": "gk20a.c",
  "hash_id": "a768b69690dffa338d0b08577f4839fcae1c806f5aa3498b54ba76d91b84c0d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/gk20a.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"gk20a.h\"\n\n#include <core/tegra.h>\n#include <subdev/timer.h>\n\nstatic const u8 _pl_to_div[] = {\n \n  1, 2, 3, 4, 5, 6, 8, 10, 12, 16, 12, 16, 20, 24, 32,\n};\n\nstatic u32 pl_to_div(u32 pl)\n{\n\tif (pl >= ARRAY_SIZE(_pl_to_div))\n\t\treturn 1;\n\n\treturn _pl_to_div[pl];\n}\n\nstatic u32 div_to_pl(u32 div)\n{\n\tu32 pl;\n\n\tfor (pl = 0; pl < ARRAY_SIZE(_pl_to_div) - 1; pl++) {\n\t\tif (_pl_to_div[pl] >= div)\n\t\t\treturn pl;\n\t}\n\n\treturn ARRAY_SIZE(_pl_to_div) - 1;\n}\n\nstatic const struct gk20a_clk_pllg_params gk20a_pllg_params = {\n\t.min_vco = 1000000, .max_vco = 2064000,\n\t.min_u = 12000, .max_u = 38000,\n\t.min_m = 1, .max_m = 255,\n\t.min_n = 8, .max_n = 255,\n\t.min_pl = 1, .max_pl = 32,\n};\n\nvoid\ngk20a_pllg_read_mnp(struct gk20a_clk *clk, struct gk20a_pll *pll)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 val;\n\n\tval = nvkm_rd32(device, GPCPLL_COEFF);\n\tpll->m = (val >> GPCPLL_COEFF_M_SHIFT) & MASK(GPCPLL_COEFF_M_WIDTH);\n\tpll->n = (val >> GPCPLL_COEFF_N_SHIFT) & MASK(GPCPLL_COEFF_N_WIDTH);\n\tpll->pl = (val >> GPCPLL_COEFF_P_SHIFT) & MASK(GPCPLL_COEFF_P_WIDTH);\n}\n\nvoid\ngk20a_pllg_write_mnp(struct gk20a_clk *clk, const struct gk20a_pll *pll)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 val;\n\n\tval = (pll->m & MASK(GPCPLL_COEFF_M_WIDTH)) << GPCPLL_COEFF_M_SHIFT;\n\tval |= (pll->n & MASK(GPCPLL_COEFF_N_WIDTH)) << GPCPLL_COEFF_N_SHIFT;\n\tval |= (pll->pl & MASK(GPCPLL_COEFF_P_WIDTH)) << GPCPLL_COEFF_P_SHIFT;\n\tnvkm_wr32(device, GPCPLL_COEFF, val);\n}\n\nu32\ngk20a_pllg_calc_rate(struct gk20a_clk *clk, struct gk20a_pll *pll)\n{\n\tu32 rate;\n\tu32 divider;\n\n\trate = clk->parent_rate * pll->n;\n\tdivider = pll->m * clk->pl_to_div(pll->pl);\n\n\treturn rate / divider / 2;\n}\n\nint\ngk20a_pllg_calc_mnp(struct gk20a_clk *clk, unsigned long rate,\n\t\t    struct gk20a_pll *pll)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tu32 target_clk_f, ref_clk_f, target_freq;\n\tu32 min_vco_f, max_vco_f;\n\tu32 low_pl, high_pl, best_pl;\n\tu32 target_vco_f;\n\tu32 best_m, best_n;\n\tu32 best_delta = ~0;\n\tu32 pl;\n\n\ttarget_clk_f = rate * 2 / KHZ;\n\tref_clk_f = clk->parent_rate / KHZ;\n\n\ttarget_vco_f = target_clk_f + target_clk_f / 50;\n\tmax_vco_f = max(clk->params->max_vco, target_vco_f);\n\tmin_vco_f = clk->params->min_vco;\n\tbest_m = clk->params->max_m;\n\tbest_n = clk->params->min_n;\n\tbest_pl = clk->params->min_pl;\n\n\t \n\thigh_pl = (max_vco_f + target_vco_f - 1) / target_vco_f;\n\thigh_pl = min(high_pl, clk->params->max_pl);\n\thigh_pl = max(high_pl, clk->params->min_pl);\n\thigh_pl = clk->div_to_pl(high_pl);\n\n\t \n\tlow_pl = min_vco_f / target_vco_f;\n\tlow_pl = min(low_pl, clk->params->max_pl);\n\tlow_pl = max(low_pl, clk->params->min_pl);\n\tlow_pl = clk->div_to_pl(low_pl);\n\n\tnvkm_debug(subdev, \"low_PL %d(div%d), high_PL %d(div%d)\", low_pl,\n\t\t   clk->pl_to_div(low_pl), high_pl, clk->pl_to_div(high_pl));\n\n\t \n\tfor (pl = low_pl; pl <= high_pl; pl++) {\n\t\tu32 m, n, n2;\n\n\t\ttarget_vco_f = target_clk_f * clk->pl_to_div(pl);\n\n\t\tfor (m = clk->params->min_m; m <= clk->params->max_m; m++) {\n\t\t\tu32 u_f = ref_clk_f / m;\n\n\t\t\tif (u_f < clk->params->min_u)\n\t\t\t\tbreak;\n\t\t\tif (u_f > clk->params->max_u)\n\t\t\t\tcontinue;\n\n\t\t\tn = (target_vco_f * m) / ref_clk_f;\n\t\t\tn2 = ((target_vco_f * m) + (ref_clk_f - 1)) / ref_clk_f;\n\n\t\t\tif (n > clk->params->max_n)\n\t\t\t\tbreak;\n\n\t\t\tfor (; n <= n2; n++) {\n\t\t\t\tu32 vco_f;\n\n\t\t\t\tif (n < clk->params->min_n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (n > clk->params->max_n)\n\t\t\t\t\tbreak;\n\n\t\t\t\tvco_f = ref_clk_f * n / m;\n\n\t\t\t\tif (vco_f >= min_vco_f && vco_f <= max_vco_f) {\n\t\t\t\t\tu32 delta, lwv;\n\n\t\t\t\t\tlwv = (vco_f + (clk->pl_to_div(pl) / 2))\n\t\t\t\t\t\t/ clk->pl_to_div(pl);\n\t\t\t\t\tdelta = abs(lwv - target_clk_f);\n\n\t\t\t\t\tif (delta < best_delta) {\n\t\t\t\t\t\tbest_delta = delta;\n\t\t\t\t\t\tbest_m = m;\n\t\t\t\t\t\tbest_n = n;\n\t\t\t\t\t\tbest_pl = pl;\n\n\t\t\t\t\t\tif (best_delta == 0)\n\t\t\t\t\t\t\tgoto found_match;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nfound_match:\n\tWARN_ON(best_delta == ~0);\n\n\tif (best_delta != 0)\n\t\tnvkm_debug(subdev,\n\t\t\t   \"no best match for target @ %dMHz on gpc_pll\",\n\t\t\t   target_clk_f / KHZ);\n\n\tpll->m = best_m;\n\tpll->n = best_n;\n\tpll->pl = best_pl;\n\n\ttarget_freq = gk20a_pllg_calc_rate(clk, pll);\n\n\tnvkm_debug(subdev,\n\t\t   \"actual target freq %d KHz, M %d, N %d, PL %d(div%d)\\n\",\n\t\t   target_freq / KHZ, pll->m, pll->n, pll->pl,\n\t\t   clk->pl_to_div(pll->pl));\n\treturn 0;\n}\n\nstatic int\ngk20a_pllg_slide(struct gk20a_clk *clk, u32 n)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gk20a_pll pll;\n\tint ret = 0;\n\n\t \n\tgk20a_pllg_read_mnp(clk, &pll);\n\t \n\tif (n == pll.n)\n\t\treturn 0;\n\n\t \n\tnvkm_mask(device, GPCPLL_NDIV_SLOWDOWN,\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_SLOWDOWN_USING_PLL_SHIFT),\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_SLOWDOWN_USING_PLL_SHIFT));\n\n\t \n\tpll.n = n;\n\tudelay(1);\n\tgk20a_pllg_write_mnp(clk, &pll);\n\n\t \n\tudelay(1);\n\tnvkm_mask(device, GPCPLL_NDIV_SLOWDOWN,\n\t\t  BIT(GPCPLL_NDIV_SLOWDOWN_EN_DYNRAMP_SHIFT),\n\t\t  BIT(GPCPLL_NDIV_SLOWDOWN_EN_DYNRAMP_SHIFT));\n\n\t \n\tif (nvkm_wait_usec(device, 500, GPC_BCAST_NDIV_SLOWDOWN_DEBUG,\n\t\tGPC_BCAST_NDIV_SLOWDOWN_DEBUG_PLL_DYNRAMP_DONE_SYNCED_MASK,\n\t\tGPC_BCAST_NDIV_SLOWDOWN_DEBUG_PLL_DYNRAMP_DONE_SYNCED_MASK) < 0)\n\t\tret = -ETIMEDOUT;\n\n\t \n\tnvkm_mask(device, GPCPLL_NDIV_SLOWDOWN,\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_SLOWDOWN_USING_PLL_SHIFT) |\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_EN_DYNRAMP_SHIFT), 0);\n\tnvkm_rd32(device, GPCPLL_NDIV_SLOWDOWN);\n\n\treturn ret;\n}\n\nstatic int\ngk20a_pllg_enable(struct gk20a_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 val;\n\n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_ENABLE, GPCPLL_CFG_ENABLE);\n\tnvkm_rd32(device, GPCPLL_CFG);\n\n\t \n\tval = nvkm_rd32(device, GPCPLL_CFG);\n\tif (val & GPCPLL_CFG_LOCK_DET_OFF) {\n\t\tval &= ~GPCPLL_CFG_LOCK_DET_OFF;\n\t\tnvkm_wr32(device, GPCPLL_CFG, val);\n\t}\n\n\t \n\tif (nvkm_wait_usec(device, 300, GPCPLL_CFG, GPCPLL_CFG_LOCK,\n\t\t\t   GPCPLL_CFG_LOCK) < 0)\n\t\treturn -ETIMEDOUT;\n\n\t \n\tnvkm_mask(device, SEL_VCO, BIT(SEL_VCO_GPC2CLK_OUT_SHIFT),\n\t\tBIT(SEL_VCO_GPC2CLK_OUT_SHIFT));\n\n\treturn 0;\n}\n\nstatic void\ngk20a_pllg_disable(struct gk20a_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\n\t \n\tnvkm_mask(device, SEL_VCO, BIT(SEL_VCO_GPC2CLK_OUT_SHIFT), 0);\n\n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_ENABLE, 0);\n\tnvkm_rd32(device, GPCPLL_CFG);\n}\n\nstatic int\ngk20a_pllg_program_mnp(struct gk20a_clk *clk, const struct gk20a_pll *pll)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gk20a_pll cur_pll;\n\tint ret;\n\n\tgk20a_pllg_read_mnp(clk, &cur_pll);\n\n\t \n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV2 << GPC2CLK_OUT_VCODIV_SHIFT);\n\t \n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV2 << GPC2CLK_OUT_VCODIV_SHIFT);\n\tnvkm_rd32(device, GPC2CLK_OUT);\n\tudelay(2);\n\n\tgk20a_pllg_disable(clk);\n\n\tgk20a_pllg_write_mnp(clk, pll);\n\n\tret = gk20a_pllg_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tudelay(2);\n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV1 << GPC2CLK_OUT_VCODIV_SHIFT);\n\t \n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV1 << GPC2CLK_OUT_VCODIV_SHIFT);\n\tnvkm_rd32(device, GPC2CLK_OUT);\n\n\treturn 0;\n}\n\nstatic int\ngk20a_pllg_program_mnp_slide(struct gk20a_clk *clk, const struct gk20a_pll *pll)\n{\n\tstruct gk20a_pll cur_pll;\n\tint ret;\n\n\tif (gk20a_pllg_is_enabled(clk)) {\n\t\tgk20a_pllg_read_mnp(clk, &cur_pll);\n\n\t\t \n\t\tif (pll->m == cur_pll.m && pll->pl == cur_pll.pl)\n\t\t\treturn gk20a_pllg_slide(clk, pll->n);\n\n\t\t \n\t\tcur_pll.n = gk20a_pllg_n_lo(clk, &cur_pll);\n\t\tret = gk20a_pllg_slide(clk, cur_pll.n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tcur_pll = *pll;\n\tcur_pll.n = gk20a_pllg_n_lo(clk, &cur_pll);\n\tret = gk20a_pllg_program_mnp(clk, &cur_pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn gk20a_pllg_slide(clk, pll->n);\n}\n\nstatic struct nvkm_pstate\ngk20a_pstates[] = {\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 72000,\n\t\t\t.voltage = 0,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 108000,\n\t\t\t.voltage = 1,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 180000,\n\t\t\t.voltage = 2,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 252000,\n\t\t\t.voltage = 3,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 324000,\n\t\t\t.voltage = 4,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 396000,\n\t\t\t.voltage = 5,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 468000,\n\t\t\t.voltage = 6,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 540000,\n\t\t\t.voltage = 7,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 612000,\n\t\t\t.voltage = 8,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 648000,\n\t\t\t.voltage = 9,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 684000,\n\t\t\t.voltage = 10,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 708000,\n\t\t\t.voltage = 11,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 756000,\n\t\t\t.voltage = 12,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 804000,\n\t\t\t.voltage = 13,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 852000,\n\t\t\t.voltage = 14,\n\t\t},\n\t},\n};\n\nint\ngk20a_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\n{\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gk20a_pll pll;\n\n\tswitch (src) {\n\tcase nv_clk_src_crystal:\n\t\treturn device->crystal;\n\tcase nv_clk_src_gpc:\n\t\tgk20a_pllg_read_mnp(clk, &pll);\n\t\treturn gk20a_pllg_calc_rate(clk, &pll) / GK20A_CLK_GPC_MDIV;\n\tdefault:\n\t\tnvkm_error(subdev, \"invalid clock source %d\\n\", src);\n\t\treturn -EINVAL;\n\t}\n}\n\nint\ngk20a_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\n\treturn gk20a_pllg_calc_mnp(clk, cstate->domain[nv_clk_src_gpc] *\n\t\t\t\t\t GK20A_CLK_GPC_MDIV, &clk->pll);\n}\n\nint\ngk20a_clk_prog(struct nvkm_clk *base)\n{\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\tint ret;\n\n\tret = gk20a_pllg_program_mnp_slide(clk, &clk->pll);\n\tif (ret)\n\t\tret = gk20a_pllg_program_mnp(clk, &clk->pll);\n\n\treturn ret;\n}\n\nvoid\ngk20a_clk_tidy(struct nvkm_clk *base)\n{\n}\n\nint\ngk20a_clk_setup_slide(struct gk20a_clk *clk)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 step_a, step_b;\n\n\tswitch (clk->parent_rate) {\n\tcase 12000000:\n\tcase 12800000:\n\tcase 13000000:\n\t\tstep_a = 0x2b;\n\t\tstep_b = 0x0b;\n\t\tbreak;\n\tcase 19200000:\n\t\tstep_a = 0x12;\n\t\tstep_b = 0x08;\n\t\tbreak;\n\tcase 38400000:\n\t\tstep_a = 0x04;\n\t\tstep_b = 0x05;\n\t\tbreak;\n\tdefault:\n\t\tnvkm_error(subdev, \"invalid parent clock rate %u KHz\",\n\t\t\t   clk->parent_rate / KHZ);\n\t\treturn -EINVAL;\n\t}\n\n\tnvkm_mask(device, GPCPLL_CFG2, 0xff << GPCPLL_CFG2_PLL_STEPA_SHIFT,\n\t\tstep_a << GPCPLL_CFG2_PLL_STEPA_SHIFT);\n\tnvkm_mask(device, GPCPLL_CFG3, 0xff << GPCPLL_CFG3_PLL_STEPB_SHIFT,\n\t\tstep_b << GPCPLL_CFG3_PLL_STEPB_SHIFT);\n\n\treturn 0;\n}\n\nvoid\ngk20a_clk_fini(struct nvkm_clk *base)\n{\n\tstruct nvkm_device *device = base->subdev.device;\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\n\t \n\tif (gk20a_pllg_is_enabled(clk)) {\n\t\tstruct gk20a_pll pll;\n\t\tu32 n_lo;\n\n\t\tgk20a_pllg_read_mnp(clk, &pll);\n\t\tn_lo = gk20a_pllg_n_lo(clk, &pll);\n\t\tgk20a_pllg_slide(clk, n_lo);\n\t}\n\n\tgk20a_pllg_disable(clk);\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_IDDQ, 1);\n}\n\nstatic int\ngk20a_clk_init(struct nvkm_clk *base)\n{\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ret;\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_IDDQ, 0);\n\tnvkm_rd32(device, GPCPLL_CFG);\n\tudelay(5);\n\n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_INIT_MASK,\n\t\t  GPC2CLK_OUT_INIT_VAL);\n\n\tret = gk20a_clk_setup_slide(clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbase->func->calc(base, &base->func->pstates[0].base);\n\tret = base->func->prog(&clk->base);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"cannot initialize clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_clk_func\ngk20a_clk = {\n\t.init = gk20a_clk_init,\n\t.fini = gk20a_clk_fini,\n\t.read = gk20a_clk_read,\n\t.calc = gk20a_clk_calc,\n\t.prog = gk20a_clk_prog,\n\t.tidy = gk20a_clk_tidy,\n\t.pstates = gk20a_pstates,\n\t.nr_pstates = ARRAY_SIZE(gk20a_pstates),\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_gpc, 0xff, 0, \"core\", GK20A_CLK_GPC_MDIV },\n\t\t{ nv_clk_src_max }\n\t}\n};\n\nint\ngk20a_clk_ctor(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       const struct nvkm_clk_func *func, const struct gk20a_clk_pllg_params *params,\n\t       struct gk20a_clk *clk)\n{\n\tstruct nvkm_device_tegra *tdev = device->func->tegra(device);\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < func->nr_pstates; i++) {\n\t\tINIT_LIST_HEAD(&func->pstates[i].list);\n\t\tfunc->pstates[i].pstate = i + 1;\n\t}\n\n\tclk->params = params;\n\tclk->parent_rate = clk_get_rate(tdev->clk);\n\n\tret = nvkm_clk_ctor(func, device, type, inst, true, &clk->base);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_debug(&clk->base.subdev, \"parent clock rate: %d Khz\\n\",\n\t\t   clk->parent_rate / KHZ);\n\n\treturn 0;\n}\n\nint\ngk20a_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_clk **pclk)\n{\n\tstruct gk20a_clk *clk;\n\tint ret;\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base;\n\n\tret = gk20a_clk_ctor(device, type, inst, &gk20a_clk, &gk20a_pllg_params, clk);\n\n\tclk->pl_to_div = pl_to_div;\n\tclk->div_to_pl = div_to_pl;\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}