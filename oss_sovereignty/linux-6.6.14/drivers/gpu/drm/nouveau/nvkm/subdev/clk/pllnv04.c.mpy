{
  "module_name": "pllnv04.c",
  "hash_id": "e9352b3911036b8e7e78baa3ce7673fae795ce435319f0fe587263b3c7a64a34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/pllnv04.c",
  "human_readable_source": " \n#include \"pll.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n\nstatic int\ngetMNP_single(struct nvkm_subdev *subdev, struct nvbios_pll *info, int clk,\n\t      int *pN, int *pM, int *pP)\n{\n\t \n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tint minvco = info->vco1.min_freq, maxvco = info->vco1.max_freq;\n\tint minM = info->vco1.min_m, maxM = info->vco1.max_m;\n\tint minN = info->vco1.min_n, maxN = info->vco1.max_n;\n\tint minU = info->vco1.min_inputfreq;\n\tint maxU = info->vco1.max_inputfreq;\n\tint minP = info->min_p;\n\tint maxP = info->max_p_usable;\n\tint crystal = info->refclk;\n\tint M, N, thisP, P;\n\tint clkP, calcclk;\n\tint delta, bestdelta = INT_MAX;\n\tint bestclk = 0;\n\n\t \n\t \n\tif (bios->version.major < 0x60) {\n\t\tint cv = bios->version.chip;\n\t\tif (cv < 0x17 || cv == 0x1a || cv == 0x20) {\n\t\t\tif (clk > 250000)\n\t\t\t\tmaxM = 6;\n\t\t\tif (clk > 340000)\n\t\t\t\tmaxM = 2;\n\t\t} else if (cv < 0x40) {\n\t\t\tif (clk > 150000)\n\t\t\t\tmaxM = 6;\n\t\t\tif (clk > 200000)\n\t\t\t\tmaxM = 4;\n\t\t\tif (clk > 340000)\n\t\t\t\tmaxM = 2;\n\t\t}\n\t}\n\n\tP = 1 << maxP;\n\tif ((clk * P) < minvco) {\n\t\tminvco = clk * maxP;\n\t\tmaxvco = minvco * 2;\n\t}\n\n\tif (clk + clk/200 > maxvco)\t \n\t\tmaxvco = clk + clk/200;\n\n\t \n\tfor (thisP = minP; thisP <= maxP; thisP++) {\n\t\tP = 1 << thisP;\n\t\tclkP = clk * P;\n\n\t\tif (clkP < minvco)\n\t\t\tcontinue;\n\t\tif (clkP > maxvco)\n\t\t\treturn bestclk;\n\n\t\tfor (M = minM; M <= maxM; M++) {\n\t\t\tif (crystal/M < minU)\n\t\t\t\treturn bestclk;\n\t\t\tif (crystal/M > maxU)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tN = (clkP * M + crystal/2) / crystal;\n\n\t\t\tif (N < minN)\n\t\t\t\tcontinue;\n\t\t\tif (N > maxN)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcalcclk = ((N * crystal + P/2) / P + M/2) / M;\n\t\t\tdelta = abs(calcclk - clk);\n\t\t\t \n\t\t\tif (delta < bestdelta) {\n\t\t\t\tbestdelta = delta;\n\t\t\t\tbestclk = calcclk;\n\t\t\t\t*pN = N;\n\t\t\t\t*pM = M;\n\t\t\t\t*pP = thisP;\n\t\t\t\tif (delta == 0)\t \n\t\t\t\t\treturn bestclk;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestclk;\n}\n\nstatic int\ngetMNP_double(struct nvkm_subdev *subdev, struct nvbios_pll *info, int clk,\n\t      int *pN1, int *pM1, int *pN2, int *pM2, int *pP)\n{\n\t \n\tint chip_version = subdev->device->bios->version.chip;\n\tint minvco1 = info->vco1.min_freq, maxvco1 = info->vco1.max_freq;\n\tint minvco2 = info->vco2.min_freq, maxvco2 = info->vco2.max_freq;\n\tint minU1 = info->vco1.min_inputfreq, minU2 = info->vco2.min_inputfreq;\n\tint maxU1 = info->vco1.max_inputfreq, maxU2 = info->vco2.max_inputfreq;\n\tint minM1 = info->vco1.min_m, maxM1 = info->vco1.max_m;\n\tint minN1 = info->vco1.min_n, maxN1 = info->vco1.max_n;\n\tint minM2 = info->vco2.min_m, maxM2 = info->vco2.max_m;\n\tint minN2 = info->vco2.min_n, maxN2 = info->vco2.max_n;\n\tint maxlog2P = info->max_p_usable;\n\tint crystal = info->refclk;\n\tbool fixedgain2 = (minM2 == maxM2 && minN2 == maxN2);\n\tint M1, N1, M2, N2, log2P;\n\tint clkP, calcclk1, calcclk2, calcclkout;\n\tint delta, bestdelta = INT_MAX;\n\tint bestclk = 0;\n\n\tint vco2 = (maxvco2 - maxvco2/200) / 2;\n\tfor (log2P = 0; clk && log2P < maxlog2P && clk <= (vco2 >> log2P); log2P++)\n\t\t;\n\tclkP = clk << log2P;\n\n\tif (maxvco2 < clk + clk/200)\t \n\t\tmaxvco2 = clk + clk/200;\n\n\tfor (M1 = minM1; M1 <= maxM1; M1++) {\n\t\tif (crystal/M1 < minU1)\n\t\t\treturn bestclk;\n\t\tif (crystal/M1 > maxU1)\n\t\t\tcontinue;\n\n\t\tfor (N1 = minN1; N1 <= maxN1; N1++) {\n\t\t\tcalcclk1 = crystal * N1 / M1;\n\t\t\tif (calcclk1 < minvco1)\n\t\t\t\tcontinue;\n\t\t\tif (calcclk1 > maxvco1)\n\t\t\t\tbreak;\n\n\t\t\tfor (M2 = minM2; M2 <= maxM2; M2++) {\n\t\t\t\tif (calcclk1/M2 < minU2)\n\t\t\t\t\tbreak;\n\t\t\t\tif (calcclk1/M2 > maxU2)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t \n\t\t\t\tN2 = (clkP * M2 + calcclk1/2) / calcclk1;\n\t\t\t\tif (N2 < minN2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (N2 > maxN2)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (!fixedgain2) {\n\t\t\t\t\tif (chip_version < 0x60)\n\t\t\t\t\t\tif (N2/M2 < 4 || N2/M2 > 10)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tcalcclk2 = calcclk1 * N2 / M2;\n\t\t\t\t\tif (calcclk2 < minvco2)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (calcclk2 > maxvco2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tcalcclk2 = calcclk1;\n\n\t\t\t\tcalcclkout = calcclk2 >> log2P;\n\t\t\t\tdelta = abs(calcclkout - clk);\n\t\t\t\t \n\t\t\t\tif (delta < bestdelta) {\n\t\t\t\t\tbestdelta = delta;\n\t\t\t\t\tbestclk = calcclkout;\n\t\t\t\t\t*pN1 = N1;\n\t\t\t\t\t*pM1 = M1;\n\t\t\t\t\t*pN2 = N2;\n\t\t\t\t\t*pM2 = M2;\n\t\t\t\t\t*pP = log2P;\n\t\t\t\t\tif (delta == 0)\t \n\t\t\t\t\t\treturn bestclk;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestclk;\n}\n\nint\nnv04_pll_calc(struct nvkm_subdev *subdev, struct nvbios_pll *info, u32 freq,\n\t      int *N1, int *M1, int *N2, int *M2, int *P)\n{\n\tint ret;\n\n\tif (!info->vco2.max_freq || !N2) {\n\t\tret = getMNP_single(subdev, info, freq, N1, M1, P);\n\t\tif (N2) {\n\t\t\t*N2 = 1;\n\t\t\t*M2 = 1;\n\t\t}\n\t} else {\n\t\tret = getMNP_double(subdev, info, freq, N1, M1, N2, M2, P);\n\t}\n\n\tif (!ret)\n\t\tnvkm_error(subdev, \"unable to compute acceptable pll values\\n\");\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}