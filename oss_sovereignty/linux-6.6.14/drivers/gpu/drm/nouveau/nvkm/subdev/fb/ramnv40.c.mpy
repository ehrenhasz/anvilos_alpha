{
  "module_name": "ramnv40.c",
  "hash_id": "961cf217e7ebdb64be268501cb086c235a6e02c67ffb00cc3b98fdd8c25aa400",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramnv40.c",
  "human_readable_source": " \n#include \"ramnv40.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/init.h>\n#include <subdev/bios/pll.h>\n#include <subdev/clk/pll.h>\n#include <subdev/timer.h>\n\nstatic int\nnv40_ram_calc(struct nvkm_ram *base, u32 freq)\n{\n\tstruct nv40_ram *ram = nv40_ram(base);\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvbios_pll pll;\n\tint N1, M1, N2, M2;\n\tint log2P, ret;\n\n\tret = nvbios_pll_parse(bios, 0x04, &pll);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"mclk pll data not found\\n\");\n\t\treturn ret;\n\t}\n\n\tret = nv04_pll_calc(subdev, &pll, freq, &N1, &M1, &N2, &M2, &log2P);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tram->ctrl  = 0x80000000 | (log2P << 16);\n\tram->ctrl |= min(pll.bias_p + log2P, (int)pll.max_p) << 20;\n\tif (N2 == M2) {\n\t\tram->ctrl |= 0x00000100;\n\t\tram->coef  = (N1 << 8) | M1;\n\t} else {\n\t\tram->ctrl |= 0x40000000;\n\t\tram->coef  = (N2 << 24) | (M2 << 16) | (N1 << 8) | M1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnv40_ram_prog(struct nvkm_ram *base)\n{\n\tstruct nv40_ram *ram = nv40_ram(base);\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct bit_entry M;\n\tu32 crtc_mask = 0;\n\tu8  sr1[2];\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tu32 vbl = nvkm_rd32(device, 0x600808 + (i * 0x2000));\n\t\tu32 cnt = 0;\n\t\tdo {\n\t\t\tif (vbl != nvkm_rd32(device, 0x600808 + (i * 0x2000))) {\n\t\t\t\tnvkm_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\n\t\t\t\tsr1[i] = nvkm_rd08(device, 0x0c03c5 + (i * 0x2000));\n\t\t\t\tif (!(sr1[i] & 0x20))\n\t\t\t\t\tcrtc_mask |= (1 << i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t} while (cnt++ < 32);\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (!(crtc_mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tnvkm_msec(device, 2000,\n\t\t\tu32 tmp = nvkm_rd32(device, 0x600808 + (i * 0x2000));\n\t\t\tif (!(tmp & 0x00010000))\n\t\t\t\tbreak;\n\t\t);\n\n\t\tnvkm_msec(device, 2000,\n\t\t\tu32 tmp = nvkm_rd32(device, 0x600808 + (i * 0x2000));\n\t\t\tif ( (tmp & 0x00010000))\n\t\t\t\tbreak;\n\t\t);\n\n\t\tnvkm_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\n\t\tnvkm_wr08(device, 0x0c03c5 + (i * 0x2000), sr1[i] | 0x20);\n\t}\n\n\t \n\tnvkm_wr32(device, 0x1002d4, 0x00000001);  \n\tnvkm_wr32(device, 0x1002d0, 0x00000001);  \n\tnvkm_wr32(device, 0x1002d0, 0x00000001);  \n\tnvkm_mask(device, 0x100210, 0x80000000, 0x00000000);  \n\tnvkm_wr32(device, 0x1002dc, 0x00000001);  \n\n\t \n\tnvkm_mask(device, 0x00c040, 0x0000c000, 0x00000000);\n\tswitch (device->chipset) {\n\tcase 0x40:\n\tcase 0x45:\n\tcase 0x41:\n\tcase 0x42:\n\tcase 0x47:\n\t\tnvkm_mask(device, 0x004044, 0xc0771100, ram->ctrl);\n\t\tnvkm_mask(device, 0x00402c, 0xc0771100, ram->ctrl);\n\t\tnvkm_wr32(device, 0x004048, ram->coef);\n\t\tnvkm_wr32(device, 0x004030, ram->coef);\n\t\tfallthrough;\n\tcase 0x43:\n\tcase 0x49:\n\tcase 0x4b:\n\t\tnvkm_mask(device, 0x004038, 0xc0771100, ram->ctrl);\n\t\tnvkm_wr32(device, 0x00403c, ram->coef);\n\t\tfallthrough;\n\tdefault:\n\t\tnvkm_mask(device, 0x004020, 0xc0771100, ram->ctrl);\n\t\tnvkm_wr32(device, 0x004024, ram->coef);\n\t\tbreak;\n\t}\n\tudelay(100);\n\tnvkm_mask(device, 0x00c040, 0x0000c000, 0x0000c000);\n\n\t \n\tnvkm_wr32(device, 0x1002dc, 0x00000000);\n\tnvkm_mask(device, 0x100210, 0x80000000, 0x80000000);\n\tudelay(100);\n\n\t \n\tif (!bit_entry(bios, 'M', &M))\n\t\tnvbios_init(subdev, nvbios_rd16(bios, M.offset + 0x00));\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (!(crtc_mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tnvkm_msec(device, 2000,\n\t\t\tu32 tmp = nvkm_rd32(device, 0x600808 + (i * 0x2000));\n\t\t\tif ( (tmp & 0x00010000))\n\t\t\t\tbreak;\n\t\t);\n\n\t\tnvkm_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\n\t\tnvkm_wr08(device, 0x0c03c5 + (i * 0x2000), sr1[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv40_ram_tidy(struct nvkm_ram *base)\n{\n}\n\nstatic const struct nvkm_ram_func\nnv40_ram_func = {\n\t.calc = nv40_ram_calc,\n\t.prog = nv40_ram_prog,\n\t.tidy = nv40_ram_tidy,\n};\n\nint\nnv40_ram_new_(struct nvkm_fb *fb, enum nvkm_ram_type type, u64 size,\n\t      struct nvkm_ram **pram)\n{\n\tstruct nv40_ram *ram;\n\tif (!(ram = kzalloc(sizeof(*ram), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pram = &ram->base;\n\treturn nvkm_ram_ctor(&nv40_ram_func, fb, type, size, &ram->base);\n}\n\nint\nnv40_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)\n{\n\tstruct nvkm_device *device = fb->subdev.device;\n\tu32 pbus1218 = nvkm_rd32(device, 0x001218);\n\tu32     size = nvkm_rd32(device, 0x10020c) & 0xff000000;\n\tenum nvkm_ram_type type = NVKM_RAM_TYPE_UNKNOWN;\n\tint ret;\n\n\tswitch (pbus1218 & 0x00000300) {\n\tcase 0x00000000: type = NVKM_RAM_TYPE_SDRAM; break;\n\tcase 0x00000100: type = NVKM_RAM_TYPE_DDR1 ; break;\n\tcase 0x00000200: type = NVKM_RAM_TYPE_GDDR3; break;\n\tcase 0x00000300: type = NVKM_RAM_TYPE_DDR2 ; break;\n\t}\n\n\tret = nv40_ram_new_(fb, type, size, pram);\n\tif (ret)\n\t\treturn ret;\n\n\t(*pram)->parts = (nvkm_rd32(device, 0x100200) & 0x00000003) + 1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}