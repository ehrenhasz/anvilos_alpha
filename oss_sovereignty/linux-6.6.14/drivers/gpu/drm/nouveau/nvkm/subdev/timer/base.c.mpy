{
  "module_name": "base.c",
  "hash_id": "f7f0d73feadf7910973bdb72e2cb6ceb7fa6b5475f8e4fae6c17a6f8d4474336",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/timer/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\ns64\nnvkm_timer_wait_test(struct nvkm_timer_wait *wait)\n{\n\tstruct nvkm_subdev *subdev = &wait->tmr->subdev;\n\tu64 time = nvkm_timer_read(wait->tmr);\n\n\tif (wait->reads == 0) {\n\t\twait->time0 = time;\n\t\twait->time1 = time;\n\t}\n\n\tif (wait->time1 == time) {\n\t\tif (wait->reads++ == 16) {\n\t\t\tnvkm_fatal(subdev, \"stalled at %016llx\\n\", time);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\twait->time1 = time;\n\t\twait->reads = 1;\n\t}\n\n\tif (wait->time1 - wait->time0 > wait->limit)\n\t\treturn -ETIMEDOUT;\n\n\treturn wait->time1 - wait->time0;\n}\n\nvoid\nnvkm_timer_wait_init(struct nvkm_device *device, u64 nsec,\n\t\t     struct nvkm_timer_wait *wait)\n{\n\twait->tmr = device->timer;\n\twait->limit = nsec;\n\twait->reads = 0;\n}\n\nu64\nnvkm_timer_read(struct nvkm_timer *tmr)\n{\n\treturn tmr->func->read(tmr);\n}\n\nvoid\nnvkm_timer_alarm_trigger(struct nvkm_timer *tmr)\n{\n\tstruct nvkm_alarm *alarm, *atemp;\n\tunsigned long flags;\n\tLIST_HEAD(exec);\n\n\t \n\tspin_lock_irqsave(&tmr->lock, flags);\n\tlist_for_each_entry_safe(alarm, atemp, &tmr->alarms, head) {\n\t\t \n\t\tif (alarm->timestamp > nvkm_timer_read(tmr)) {\n\t\t\t \n\t\t\ttmr->func->alarm_init(tmr, alarm->timestamp);\n\t\t\tif (alarm->timestamp > nvkm_timer_read(tmr))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlist_del_init(&alarm->head);\n\t\tlist_add(&alarm->exec, &exec);\n\t}\n\n\t \n\tif (list_empty(&tmr->alarms))\n\t\ttmr->func->alarm_fini(tmr);\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n\n\t \n\tlist_for_each_entry_safe(alarm, atemp, &exec, exec) {\n\t\tlist_del(&alarm->exec);\n\t\talarm->func(alarm);\n\t}\n}\n\nvoid\nnvkm_timer_alarm(struct nvkm_timer *tmr, u32 nsec, struct nvkm_alarm *alarm)\n{\n\tstruct nvkm_alarm *list;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&tmr->lock, flags);\n\tlist_del_init(&alarm->head);\n\n\tif (nsec) {\n\t\t \n\t\talarm->timestamp = nvkm_timer_read(tmr) + nsec;\n\t\tlist_for_each_entry(list, &tmr->alarms, head) {\n\t\t\tif (list->timestamp > alarm->timestamp)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlist_add_tail(&alarm->head, &list->head);\n\n\t\t \n\t\tlist = list_first_entry(&tmr->alarms, typeof(*list), head);\n\t\tif (list == alarm) {\n\t\t\ttmr->func->alarm_init(tmr, alarm->timestamp);\n\t\t\t \n\t\t\tWARN_ON(alarm->timestamp <= nvkm_timer_read(tmr));\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tmr->lock, flags);\n}\n\nstatic void\nnvkm_timer_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_timer *tmr = nvkm_timer(subdev);\n\ttmr->func->intr(tmr);\n}\n\nstatic int\nnvkm_timer_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_timer *tmr = nvkm_timer(subdev);\n\ttmr->func->alarm_fini(tmr);\n\treturn 0;\n}\n\nstatic int\nnvkm_timer_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_timer *tmr = nvkm_timer(subdev);\n\tif (tmr->func->init)\n\t\ttmr->func->init(tmr);\n\ttmr->func->time(tmr, ktime_to_ns(ktime_get()));\n\tnvkm_timer_alarm_trigger(tmr);\n\treturn 0;\n}\n\nstatic void *\nnvkm_timer_dtor(struct nvkm_subdev *subdev)\n{\n\treturn nvkm_timer(subdev);\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_timer = {\n\t.dtor = nvkm_timer_dtor,\n\t.init = nvkm_timer_init,\n\t.fini = nvkm_timer_fini,\n\t.intr = nvkm_timer_intr,\n};\n\nint\nnvkm_timer_new_(const struct nvkm_timer_func *func, struct nvkm_device *device,\n\t\tenum nvkm_subdev_type type, int inst, struct nvkm_timer **ptmr)\n{\n\tstruct nvkm_timer *tmr;\n\n\tif (!(tmr = *ptmr = kzalloc(sizeof(*tmr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_subdev_ctor(&nvkm_timer, device, type, inst, &tmr->subdev);\n\ttmr->func = func;\n\tINIT_LIST_HEAD(&tmr->alarms);\n\tspin_lock_init(&tmr->lock);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}