{
  "module_name": "gk104.c",
  "hash_id": "de0ff496746ed4a5467d83d43f4769894f1fc49d15c40fd34e1ca547ec570084",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/volt/gk104.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/volt.h>\n#include <subdev/gpio.h>\n#include <subdev/bios.h>\n#include <subdev/bios/volt.h>\n#include <subdev/fuse.h>\n\n#define gk104_volt(p) container_of((p), struct gk104_volt, base)\nstruct gk104_volt {\n\tstruct nvkm_volt base;\n\tstruct nvbios_volt bios;\n};\n\nstatic int\ngk104_volt_get(struct nvkm_volt *base)\n{\n\tstruct nvbios_volt *bios = &gk104_volt(base)->bios;\n\tstruct nvkm_device *device = base->subdev.device;\n\tu32 div, duty;\n\n\tdiv  = nvkm_rd32(device, 0x20340);\n\tduty = nvkm_rd32(device, 0x20344);\n\n\treturn bios->base + bios->pwm_range * duty / div;\n}\n\nstatic int\ngk104_volt_set(struct nvkm_volt *base, u32 uv)\n{\n\tstruct nvbios_volt *bios = &gk104_volt(base)->bios;\n\tstruct nvkm_device *device = base->subdev.device;\n\tu32 div, duty;\n\n\t \n\tdiv = 27648000 / bios->pwm_freq;\n\tduty = DIV_ROUND_UP((uv - bios->base) * div, bios->pwm_range);\n\n\tnvkm_wr32(device, 0x20340, div);\n\tnvkm_wr32(device, 0x20344, 0x80000000 | duty);\n\n\treturn 0;\n}\n\nstatic int\ngk104_volt_speedo_read(struct nvkm_volt *volt)\n{\n\tstruct nvkm_device *device = volt->subdev.device;\n\tstruct nvkm_fuse *fuse = device->fuse;\n\tint ret;\n\n\tif (!fuse)\n\t\treturn -EINVAL;\n\n\tnvkm_wr32(device, 0x122634, 0x0);\n\tret = nvkm_fuse_read(fuse, 0x3a8);\n\tnvkm_wr32(device, 0x122634, 0x41);\n\treturn ret;\n}\n\nstatic const struct nvkm_volt_func\ngk104_volt_pwm = {\n\t.oneinit = gf100_volt_oneinit,\n\t.volt_get = gk104_volt_get,\n\t.volt_set = gk104_volt_set,\n\t.speedo_read = gk104_volt_speedo_read,\n}, gk104_volt_gpio = {\n\t.oneinit = gf100_volt_oneinit,\n\t.vid_get = nvkm_voltgpio_get,\n\t.vid_set = nvkm_voltgpio_set,\n\t.speedo_read = gk104_volt_speedo_read,\n};\n\nint\ngk104_volt_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_volt **pvolt)\n{\n\tconst struct nvkm_volt_func *volt_func = &gk104_volt_gpio;\n\tstruct dcb_gpio_func gpio;\n\tstruct nvbios_volt bios;\n\tstruct gk104_volt *volt;\n\tu8 ver, hdr, cnt, len;\n\tconst char *mode;\n\n\tif (!nvbios_volt_parse(device->bios, &ver, &hdr, &cnt, &len, &bios))\n\t\treturn 0;\n\n\tif (!nvkm_gpio_find(device->gpio, 0, DCB_GPIO_VID_PWM, 0xff, &gpio) &&\n\t    bios.type == NVBIOS_VOLT_PWM) {\n\t\tvolt_func = &gk104_volt_pwm;\n\t}\n\n\tif (!(volt = kzalloc(sizeof(*volt), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_volt_ctor(volt_func, device, type, inst, &volt->base);\n\t*pvolt = &volt->base;\n\tvolt->bios = bios;\n\n\t \n\tif (bios.type == NVBIOS_VOLT_PWM && volt_func != &gk104_volt_pwm) {\n\t\tnvkm_error(&volt->base.subdev,\n\t\t\t   \"Type mismatch between the voltage table type and \"\n\t\t\t   \"the GPIO table. Fallback to GPIO mode.\\n\");\n\t}\n\n\tif (volt_func == &gk104_volt_gpio) {\n\t\tnvkm_voltgpio_init(&volt->base);\n\t\tmode = \"GPIO\";\n\t} else\n\t\tmode = \"PWM\";\n\n\tnvkm_debug(&volt->base.subdev, \"Using %s mode\\n\", mode);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}