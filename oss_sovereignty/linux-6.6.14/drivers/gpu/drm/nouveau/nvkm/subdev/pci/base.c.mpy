{
  "module_name": "base.c",
  "hash_id": "60c2fb9912246f87a211fd6939c94f0b47d962debb3bde38aaec2420e2ac4a04",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pci/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"agp.h\"\n\n#include <core/option.h>\n#include <core/pci.h>\n\nvoid\nnvkm_pci_msi_rearm(struct nvkm_device *device)\n{\n\tstruct nvkm_pci *pci = device->pci;\n\n\tif (pci && pci->msi)\n\t\tpci->func->msi_rearm(pci);\n}\n\nu32\nnvkm_pci_rd32(struct nvkm_pci *pci, u16 addr)\n{\n\treturn pci->func->rd32(pci, addr);\n}\n\nvoid\nnvkm_pci_wr08(struct nvkm_pci *pci, u16 addr, u8 data)\n{\n\tpci->func->wr08(pci, addr, data);\n}\n\nvoid\nnvkm_pci_wr32(struct nvkm_pci *pci, u16 addr, u32 data)\n{\n\tpci->func->wr32(pci, addr, data);\n}\n\nu32\nnvkm_pci_mask(struct nvkm_pci *pci, u16 addr, u32 mask, u32 value)\n{\n\tu32 data = pci->func->rd32(pci, addr);\n\tpci->func->wr32(pci, addr, (data & ~mask) | value);\n\treturn data;\n}\n\nvoid\nnvkm_pci_rom_shadow(struct nvkm_pci *pci, bool shadow)\n{\n\tu32 data = nvkm_pci_rd32(pci, 0x0050);\n\tif (shadow)\n\t\tdata |=  0x00000001;\n\telse\n\t\tdata &= ~0x00000001;\n\tnvkm_pci_wr32(pci, 0x0050, data);\n}\n\nstatic int\nnvkm_pci_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_pci *pci = nvkm_pci(subdev);\n\n\tif (pci->agp.bridge)\n\t\tnvkm_agp_fini(pci);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_pci_preinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pci *pci = nvkm_pci(subdev);\n\tif (pci->agp.bridge)\n\t\tnvkm_agp_preinit(pci);\n\treturn 0;\n}\n\nstatic int\nnvkm_pci_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pci *pci = nvkm_pci(subdev);\n\tint ret;\n\n\tif (pci_is_pcie(pci->pdev)) {\n\t\tret = nvkm_pcie_oneinit(pci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_pci_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pci *pci = nvkm_pci(subdev);\n\tint ret;\n\n\tif (pci->agp.bridge) {\n\t\tret = nvkm_agp_init(pci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (pci_is_pcie(pci->pdev)) {\n\t\tnvkm_pcie_init(pci);\n\t}\n\n\tif (pci->func->init)\n\t\tpci->func->init(pci);\n\n\t \n\tif (pci->msi)\n\t\tpci->func->msi_rearm(pci);\n\n\treturn 0;\n}\n\nstatic void *\nnvkm_pci_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pci *pci = nvkm_pci(subdev);\n\n\tnvkm_agp_dtor(pci);\n\n\tif (pci->msi)\n\t\tpci_disable_msi(pci->pdev);\n\n\treturn nvkm_pci(subdev);\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_pci_func = {\n\t.dtor = nvkm_pci_dtor,\n\t.oneinit = nvkm_pci_oneinit,\n\t.preinit = nvkm_pci_preinit,\n\t.init = nvkm_pci_init,\n\t.fini = nvkm_pci_fini,\n};\n\nint\nnvkm_pci_new_(const struct nvkm_pci_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_pci **ppci)\n{\n\tstruct nvkm_pci *pci;\n\n\tif (!(pci = *ppci = kzalloc(sizeof(**ppci), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_subdev_ctor(&nvkm_pci_func, device, type, inst, &pci->subdev);\n\tpci->func = func;\n\tpci->pdev = device->func->pci(device)->pdev;\n\tpci->pcie.speed = -1;\n\tpci->pcie.width = -1;\n\n\tif (device->type == NVKM_DEVICE_AGP)\n\t\tnvkm_agp_ctor(pci);\n\n\tswitch (pci->pdev->device & 0x0ff0) {\n\tcase 0x00f0:\n\tcase 0x02e0:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tswitch (device->chipset) {\n\t\tcase 0xaa:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpci->msi = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef __BIG_ENDIAN\n\tpci->msi = false;\n#endif\n\n\tpci->msi = nvkm_boolopt(device->cfgopt, \"NvMSI\", pci->msi);\n\tif (pci->msi && func->msi_rearm) {\n\t\tpci->msi = pci_enable_msi(pci->pdev) == 0;\n\t\tif (pci->msi)\n\t\t\tnvkm_debug(&pci->subdev, \"MSI enabled\\n\");\n\t} else {\n\t\tpci->msi = false;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}