{
  "module_name": "ummu.c",
  "hash_id": "3c9872fb26d0b0ffd50a49f900ca6f92d75b285c856cb972fb326ea7efde103e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/ummu.c",
  "human_readable_source": " \n#include \"ummu.h\"\n#include \"umem.h\"\n#include \"uvmm.h\"\n\n#include <core/client.h>\n\n#include <nvif/if0008.h>\n#include <nvif/unpack.h>\n\nstatic int\nnvkm_ummu_sclass(struct nvkm_object *object, int index,\n\t\t struct nvkm_oclass *oclass)\n{\n\tstruct nvkm_mmu *mmu = nvkm_ummu(object)->mmu;\n\n\tif (mmu->func->mem.user.oclass) {\n\t\tif (index-- == 0) {\n\t\t\toclass->base = mmu->func->mem.user;\n\t\t\toclass->ctor = nvkm_umem_new;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (mmu->func->vmm.user.oclass) {\n\t\tif (index-- == 0) {\n\t\t\toclass->base = mmu->func->vmm.user;\n\t\t\toclass->ctor = nvkm_uvmm_new;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_ummu_heap(struct nvkm_ummu *ummu, void *argv, u32 argc)\n{\n\tstruct nvkm_mmu *mmu = ummu->mmu;\n\tunion {\n\t\tstruct nvif_mmu_heap_v0 v0;\n\t} *args = argv;\n\tint ret = -ENOSYS;\n\tu8 index;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\tif ((index = args->v0.index) >= mmu->heap_nr)\n\t\t\treturn -EINVAL;\n\t\targs->v0.size = mmu->heap[index].size;\n\t} else\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nnvkm_ummu_type(struct nvkm_ummu *ummu, void *argv, u32 argc)\n{\n\tstruct nvkm_mmu *mmu = ummu->mmu;\n\tunion {\n\t\tstruct nvif_mmu_type_v0 v0;\n\t} *args = argv;\n\tint ret = -ENOSYS;\n\tu8 type, index;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\tif ((index = args->v0.index) >= mmu->type_nr)\n\t\t\treturn -EINVAL;\n\t\ttype = mmu->type[index].type;\n\t\targs->v0.heap = mmu->type[index].heap;\n\t\targs->v0.vram = !!(type & NVKM_MEM_VRAM);\n\t\targs->v0.host = !!(type & NVKM_MEM_HOST);\n\t\targs->v0.comp = !!(type & NVKM_MEM_COMP);\n\t\targs->v0.disp = !!(type & NVKM_MEM_DISP);\n\t\targs->v0.kind = !!(type & NVKM_MEM_KIND);\n\t\targs->v0.mappable = !!(type & NVKM_MEM_MAPPABLE);\n\t\targs->v0.coherent = !!(type & NVKM_MEM_COHERENT);\n\t\targs->v0.uncached = !!(type & NVKM_MEM_UNCACHED);\n\t} else\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nnvkm_ummu_kind(struct nvkm_ummu *ummu, void *argv, u32 argc)\n{\n\tstruct nvkm_mmu *mmu = ummu->mmu;\n\tunion {\n\t\tstruct nvif_mmu_kind_v0 v0;\n\t} *args = argv;\n\tconst u8 *kind = NULL;\n\tint ret = -ENOSYS, count = 0;\n\tu8 kind_inv = 0;\n\n\tif (mmu->func->kind)\n\t\tkind = mmu->func->kind(mmu, &count, &kind_inv);\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, true))) {\n\t\tif (argc != args->v0.count * sizeof(*args->v0.data))\n\t\t\treturn -EINVAL;\n\t\tif (args->v0.count > count)\n\t\t\treturn -EINVAL;\n\t\targs->v0.kind_inv = kind_inv;\n\t\tmemcpy(args->v0.data, kind, args->v0.count);\n\t} else\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nnvkm_ummu_mthd(struct nvkm_object *object, u32 mthd, void *argv, u32 argc)\n{\n\tstruct nvkm_ummu *ummu = nvkm_ummu(object);\n\tswitch (mthd) {\n\tcase NVIF_MMU_V0_HEAP: return nvkm_ummu_heap(ummu, argv, argc);\n\tcase NVIF_MMU_V0_TYPE: return nvkm_ummu_type(ummu, argv, argc);\n\tcase NVIF_MMU_V0_KIND: return nvkm_ummu_kind(ummu, argv, argc);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nstatic const struct nvkm_object_func\nnvkm_ummu = {\n\t.mthd = nvkm_ummu_mthd,\n\t.sclass = nvkm_ummu_sclass,\n};\n\nint\nnvkm_ummu_new(struct nvkm_device *device, const struct nvkm_oclass *oclass,\n\t      void *argv, u32 argc, struct nvkm_object **pobject)\n{\n\tunion {\n\t\tstruct nvif_mmu_v0 v0;\n\t} *args = argv;\n\tstruct nvkm_mmu *mmu = device->mmu;\n\tstruct nvkm_ummu *ummu;\n\tint ret = -ENOSYS, kinds = 0;\n\tu8 unused = 0;\n\n\tif (mmu->func->kind)\n\t\tmmu->func->kind(mmu, &kinds, &unused);\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\targs->v0.dmabits = mmu->dma_bits;\n\t\targs->v0.heap_nr = mmu->heap_nr;\n\t\targs->v0.type_nr = mmu->type_nr;\n\t\targs->v0.kind_nr = kinds;\n\t} else\n\t\treturn ret;\n\n\tif (!(ummu = kzalloc(sizeof(*ummu), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_object_ctor(&nvkm_ummu, oclass, &ummu->object);\n\tummu->mmu = mmu;\n\t*pobject = &ummu->object;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}