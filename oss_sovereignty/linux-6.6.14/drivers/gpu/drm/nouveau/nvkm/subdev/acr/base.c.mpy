{
  "module_name": "base.c",
  "hash_id": "803121cd94a990c28811b68f9d2a59a90d84155f91b2f9084b20be915fb832a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/acr/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/firmware.h>\n#include <core/memory.h>\n#include <subdev/mmu.h>\n#include <subdev/gsp.h>\n#include <subdev/pmu.h>\n#include <engine/sec2.h>\n#include <engine/nvdec.h>\n\nstatic struct nvkm_acr_hsfw *\nnvkm_acr_hsfw_find(struct nvkm_acr *acr, const char *name)\n{\n\tstruct nvkm_acr_hsfw *hsfw;\n\n\tlist_for_each_entry(hsfw, &acr->hsfw, head) {\n\t\tif (!strcmp(hsfw->fw.fw.name, name))\n\t\t\treturn hsfw;\n\t}\n\n\treturn NULL;\n}\n\nint\nnvkm_acr_hsfw_boot(struct nvkm_acr *acr, const char *name)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\tstruct nvkm_acr_hsfw *hsfw;\n\n\thsfw = nvkm_acr_hsfw_find(acr, name);\n\tif (!hsfw)\n\t\treturn -EINVAL;\n\n\treturn nvkm_falcon_fw_boot(&hsfw->fw, subdev, true, NULL, NULL,\n\t\t\t\t   hsfw->boot_mbox0, hsfw->intr_clear);\n}\n\nstatic struct nvkm_acr_lsf *\nnvkm_acr_rtos(struct nvkm_acr *acr)\n{\n\tstruct nvkm_acr_lsf *lsf;\n\n\tif (acr) {\n\t\tlist_for_each_entry(lsf, &acr->lsf, head) {\n\t\t\tif (lsf->func->bootstrap_falcon)\n\t\t\t\treturn lsf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nnvkm_acr_unload(struct nvkm_acr *acr)\n{\n\tif (acr->done) {\n\t\tif (acr->rtos) {\n\t\t\tnvkm_subdev_unref(acr->rtos->falcon->owner);\n\t\t\tacr->rtos = NULL;\n\t\t}\n\n\t\tnvkm_acr_hsfw_boot(acr, \"unload\");\n\t\tacr->done = false;\n\t}\n}\n\nstatic int\nnvkm_acr_load(struct nvkm_acr *acr)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\tstruct nvkm_acr_lsf *rtos = nvkm_acr_rtos(acr);\n\tu64 start, limit;\n\tint ret;\n\n\tif (list_empty(&acr->lsf)) {\n\t\tnvkm_debug(subdev, \"No LSF(s) present.\\n\");\n\t\treturn 0;\n\t}\n\n\tret = acr->func->init(acr);\n\tif (ret)\n\t\treturn ret;\n\n\tacr->func->wpr_check(acr, &start, &limit);\n\n\tif (start != acr->wpr_start || limit != acr->wpr_end) {\n\t\tnvkm_error(subdev, \"WPR not configured as expected: \"\n\t\t\t\t   \"%016llx-%016llx vs %016llx-%016llx\\n\",\n\t\t\t   acr->wpr_start, acr->wpr_end, start, limit);\n\t\treturn -EIO;\n\t}\n\n\tacr->done = true;\n\n\tif (rtos) {\n\t\tret = nvkm_subdev_ref(rtos->falcon->owner);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tacr->rtos = rtos;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnvkm_acr_reload(struct nvkm_acr *acr)\n{\n\tnvkm_acr_unload(acr);\n\treturn nvkm_acr_load(acr);\n}\n\nint\nnvkm_acr_bootstrap_falcons(struct nvkm_device *device, unsigned long mask)\n{\n\tstruct nvkm_acr *acr = device->acr;\n\tstruct nvkm_acr_lsf *rtos = nvkm_acr_rtos(acr);\n\tunsigned long id;\n\n\t \n\tif (!rtos) {\n\t\t \n\t\tif ((mask & acr->func->bootstrap_falcons) == mask) {\n\t\t\tint ret = nvkm_acr_reload(acr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\treturn acr->done ? 0 : -EINVAL;\n\t\t}\n\t\treturn -ENOSYS;\n\t}\n\n\tif ((mask & rtos->func->bootstrap_falcons) != mask)\n\t\treturn -ENOSYS;\n\n\tif (rtos->func->bootstrap_multiple_falcons)\n\t\treturn rtos->func->bootstrap_multiple_falcons(rtos->falcon, mask);\n\n\tfor_each_set_bit(id, &mask, NVKM_ACR_LSF_NUM) {\n\t\tint ret = rtos->func->bootstrap_falcon(rtos->falcon, id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nbool\nnvkm_acr_managed_falcon(struct nvkm_device *device, enum nvkm_acr_lsf_id id)\n{\n\tstruct nvkm_acr *acr = device->acr;\n\n\tif (acr) {\n\t\tif (acr->managed_falcons & BIT_ULL(id))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int\nnvkm_acr_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tif (!subdev->use.enabled)\n\t\treturn 0;\n\n\tnvkm_acr_unload(nvkm_acr(subdev));\n\treturn 0;\n}\n\nstatic int\nnvkm_acr_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_acr *acr = nvkm_acr(subdev);\n\n\tif (!nvkm_acr_rtos(acr))\n\t\treturn 0;\n\n\treturn nvkm_acr_load(acr);\n}\n\nstatic void\nnvkm_acr_cleanup(struct nvkm_acr *acr)\n{\n\tnvkm_acr_lsfw_del_all(acr);\n\n\tnvkm_firmware_put(acr->wpr_fw);\n\tacr->wpr_fw = NULL;\n}\n\nstatic int\nnvkm_acr_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_acr *acr = nvkm_acr(subdev);\n\tstruct nvkm_acr_hsfw *hsfw;\n\tstruct nvkm_acr_lsfw *lsfw, *lsft;\n\tstruct nvkm_acr_lsf *lsf, *rtos;\n\tstruct nvkm_falcon *falcon;\n\tu32 wpr_size = 0;\n\tu64 falcons;\n\tint ret, i;\n\n\tif (list_empty(&acr->hsfw) || !acr->func || !acr->func->wpr_layout) {\n\t\tnvkm_debug(subdev, \"No HSFW(s)\\n\");\n\t\tnvkm_acr_cleanup(acr);\n\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry_safe(lsfw, lsft, &acr->lsfw, head) {\n\t\t \n\t\tif (acr->wpr_fw) {\n\t\t\tif (!lsfw->func) {\n\t\t\t\tnvkm_acr_lsfw_del(lsfw);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twpr_size = acr->wpr_fw->size;\n\t\t}\n\n\t\t \n\t\tret = nvkm_falcon_get(lsfw->falcon, subdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnvkm_falcon_put(lsfw->falcon, subdev);\n\n\t\tif (!(lsf = kmalloc(sizeof(*lsf), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tlsf->func = lsfw->func;\n\t\tlsf->falcon = lsfw->falcon;\n\t\tlsf->id = lsfw->id;\n\t\tlist_add_tail(&lsf->head, &acr->lsf);\n\t\tacr->managed_falcons |= BIT_ULL(lsf->id);\n\t}\n\n\t \n\trtos = nvkm_acr_rtos(acr);\n\tif (rtos) {\n\t\tfalcons = rtos->func->bootstrap_falcons;\n\t\tlist_move(&rtos->head, &acr->lsf);\n\t} else {\n\t\tfalcons = acr->func->bootstrap_falcons;\n\t}\n\n\t \n\tlist_for_each_entry_safe(lsfw, lsft, &acr->lsfw, head) {\n\t\tif (!(falcons & BIT_ULL(lsfw->id))) {\n\t\t\tnvkm_warn(subdev, \"%s falcon cannot be bootstrapped\\n\",\n\t\t\t\t  nvkm_acr_lsf_id(lsfw->id));\n\t\t\tnvkm_acr_lsfw_del(lsfw);\n\t\t}\n\t}\n\n\tif (!acr->wpr_fw || acr->wpr_comp)\n\t\twpr_size = acr->func->wpr_layout(acr);\n\n\t \n\tret = acr->func->wpr_alloc(acr, wpr_size);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_debug(subdev, \"WPR region is from 0x%llx-0x%llx (shadow 0x%llx)\\n\",\n\t\t   acr->wpr_start, acr->wpr_end, acr->shadow_start);\n\n\t \n\tnvkm_kmap(acr->wpr);\n\tif (acr->wpr_fw && !acr->wpr_comp)\n\t\tnvkm_wobj(acr->wpr, 0, acr->wpr_fw->data, acr->wpr_fw->size);\n\n\tif (!acr->wpr_fw || acr->wpr_comp)\n\t\tacr->func->wpr_build(acr, rtos);\n\tacr->func->wpr_patch(acr, (s64)acr->wpr_start - acr->wpr_prev);\n\n\tif (acr->wpr_fw && acr->wpr_comp) {\n\t\tnvkm_kmap(acr->wpr);\n\t\tfor (i = 0; i < acr->wpr_fw->size; i += 4) {\n\t\t\tu32 us = nvkm_ro32(acr->wpr, i);\n\t\t\tu32 fw = ((u32 *)acr->wpr_fw->data)[i/4];\n\t\t\tif (fw != us) {\n\t\t\t\tnvkm_warn(subdev, \"%08x: %08x %08x\\n\",\n\t\t\t\t\t  i, us, fw);\n\t\t\t}\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tnvkm_done(acr->wpr);\n\n\t \n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x1000, 0, true,\n\t\t\t      &acr->inst);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_vmm_new(device, 0, 0, NULL, 0, NULL, \"acr\", &acr->vmm);\n\tif (ret)\n\t\treturn ret;\n\n\tacr->vmm->debug = acr->subdev.debug;\n\n\tret = nvkm_vmm_join(acr->vmm, acr->inst);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry(hsfw, &acr->hsfw, head) {\n\t\tswitch (hsfw->falcon_id) {\n\t\tcase NVKM_ACR_HSF_PMU : falcon = &device->pmu->falcon; break;\n\t\tcase NVKM_ACR_HSF_SEC2: falcon = &device->sec2->falcon; break;\n\t\tcase NVKM_ACR_HSF_GSP : falcon = &device->gsp->falcon; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = nvkm_falcon_fw_oneinit(&hsfw->fw, falcon, acr->vmm, acr->inst);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tnvkm_acr_cleanup(acr);\n\treturn 0;\n}\n\nstatic void *\nnvkm_acr_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_acr *acr = nvkm_acr(subdev);\n\tstruct nvkm_acr_hsfw *hsfw, *hsft;\n\tstruct nvkm_acr_lsf *lsf, *lst;\n\n\tlist_for_each_entry_safe(hsfw, hsft, &acr->hsfw, head) {\n\t\tnvkm_falcon_fw_dtor(&hsfw->fw);\n\t\tlist_del(&hsfw->head);\n\t\tkfree(hsfw);\n\t}\n\n\tnvkm_vmm_part(acr->vmm, acr->inst);\n\tnvkm_vmm_unref(&acr->vmm);\n\tnvkm_memory_unref(&acr->inst);\n\n\tnvkm_memory_unref(&acr->wpr);\n\n\tlist_for_each_entry_safe(lsf, lst, &acr->lsf, head) {\n\t\tlist_del(&lsf->head);\n\t\tkfree(lsf);\n\t}\n\n\tnvkm_acr_cleanup(acr);\n\treturn acr;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_acr = {\n\t.dtor = nvkm_acr_dtor,\n\t.oneinit = nvkm_acr_oneinit,\n\t.init = nvkm_acr_init,\n\t.fini = nvkm_acr_fini,\n};\n\nstatic int\nnvkm_acr_ctor_wpr(struct nvkm_acr *acr, int ver)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ret;\n\n\tret = nvkm_firmware_get(subdev, \"acr/wpr\", ver, &acr->wpr_fw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = acr->func->wpr_parse(acr);\n\tif (ret)\n\t\treturn ret;\n\n\tacr->wpr_comp = nvkm_boolopt(device->cfgopt, \"NvAcrWprCompare\", false);\n\tacr->wpr_prev = nvkm_longopt(device->cfgopt, \"NvAcrWprPrevAddr\", 0);\n\treturn 0;\n}\n\nint\nnvkm_acr_new_(const struct nvkm_acr_fwif *fwif, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_acr **pacr)\n{\n\tstruct nvkm_acr *acr;\n\tlong wprfw;\n\n\tif (!(acr = *pacr = kzalloc(sizeof(*acr), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_subdev_ctor(&nvkm_acr, device, type, inst, &acr->subdev);\n\tINIT_LIST_HEAD(&acr->hsfw);\n\tINIT_LIST_HEAD(&acr->lsfw);\n\tINIT_LIST_HEAD(&acr->lsf);\n\n\tfwif = nvkm_firmware_load(&acr->subdev, fwif, \"Acr\", acr);\n\tif (IS_ERR(fwif))\n\t\treturn PTR_ERR(fwif);\n\n\tacr->func = fwif->func;\n\n\twprfw = nvkm_longopt(device->cfgopt, \"NvAcrWpr\", -1);\n\tif (wprfw >= 0) {\n\t\tint ret = nvkm_acr_ctor_wpr(acr, wprfw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}