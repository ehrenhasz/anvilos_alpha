{
  "module_name": "busnv50.c",
  "hash_id": "9baad185ee35a3647c32d03eba8805adba49811bab9615e78bcbbcfa81b15147",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/busnv50.c",
  "human_readable_source": " \n#define nv50_i2c_bus(p) container_of((p), struct nv50_i2c_bus, base)\n#include \"bus.h\"\n\n#include <subdev/vga.h>\n\nstruct nv50_i2c_bus {\n\tstruct nvkm_i2c_bus base;\n\tu32 addr;\n\tu32 data;\n};\n\nstatic void\nnv50_i2c_bus_drive_scl(struct nvkm_i2c_bus *base, int state)\n{\n\tstruct nv50_i2c_bus *bus = nv50_i2c_bus(base);\n\tstruct nvkm_device *device = bus->base.pad->i2c->subdev.device;\n\tif (state) bus->data |= 0x01;\n\telse\t   bus->data &= 0xfe;\n\tnvkm_wr32(device, bus->addr, bus->data);\n}\n\nstatic void\nnv50_i2c_bus_drive_sda(struct nvkm_i2c_bus *base, int state)\n{\n\tstruct nv50_i2c_bus *bus = nv50_i2c_bus(base);\n\tstruct nvkm_device *device = bus->base.pad->i2c->subdev.device;\n\tif (state) bus->data |= 0x02;\n\telse\t   bus->data &= 0xfd;\n\tnvkm_wr32(device, bus->addr, bus->data);\n}\n\nstatic int\nnv50_i2c_bus_sense_scl(struct nvkm_i2c_bus *base)\n{\n\tstruct nv50_i2c_bus *bus = nv50_i2c_bus(base);\n\tstruct nvkm_device *device = bus->base.pad->i2c->subdev.device;\n\treturn !!(nvkm_rd32(device, bus->addr) & 0x00000001);\n}\n\nstatic int\nnv50_i2c_bus_sense_sda(struct nvkm_i2c_bus *base)\n{\n\tstruct nv50_i2c_bus *bus = nv50_i2c_bus(base);\n\tstruct nvkm_device *device = bus->base.pad->i2c->subdev.device;\n\treturn !!(nvkm_rd32(device, bus->addr) & 0x00000002);\n}\n\nstatic void\nnv50_i2c_bus_init(struct nvkm_i2c_bus *base)\n{\n\tstruct nv50_i2c_bus *bus = nv50_i2c_bus(base);\n\tstruct nvkm_device *device = bus->base.pad->i2c->subdev.device;\n\tnvkm_wr32(device, bus->addr, (bus->data = 0x00000007));\n}\n\nstatic const struct nvkm_i2c_bus_func\nnv50_i2c_bus_func = {\n\t.init = nv50_i2c_bus_init,\n\t.drive_scl = nv50_i2c_bus_drive_scl,\n\t.drive_sda = nv50_i2c_bus_drive_sda,\n\t.sense_scl = nv50_i2c_bus_sense_scl,\n\t.sense_sda = nv50_i2c_bus_sense_sda,\n\t.xfer = nvkm_i2c_bit_xfer,\n};\n\nint\nnv50_i2c_bus_new(struct nvkm_i2c_pad *pad, int id, u8 drive,\n\t\t struct nvkm_i2c_bus **pbus)\n{\n\tstatic const u32 addr[] = {\n\t\t0x00e138, 0x00e150, 0x00e168, 0x00e180,\n\t\t0x00e254, 0x00e274, 0x00e764, 0x00e780,\n\t\t0x00e79c, 0x00e7b8\n\t};\n\tstruct nv50_i2c_bus *bus;\n\n\tif (drive >= ARRAY_SIZE(addr)) {\n\t\tnvkm_warn(&pad->i2c->subdev, \"bus %d unknown\\n\", drive);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!(bus = kzalloc(sizeof(*bus), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pbus = &bus->base;\n\n\tnvkm_i2c_bus_ctor(&nv50_i2c_bus_func, pad, id, &bus->base);\n\tbus->addr = addr[drive];\n\tbus->data = 0x00000007;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}