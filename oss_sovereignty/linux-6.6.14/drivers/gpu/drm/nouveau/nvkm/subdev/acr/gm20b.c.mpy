{
  "module_name": "gm20b.c",
  "hash_id": "bcc43f2e8859ae7d8fbbadb5be023488d1bd6f358bccd105723dffad1941c4ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/acr/gm20b.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/firmware.h>\n#include <core/memory.h>\n#include <subdev/mmu.h>\n#include <subdev/pmu.h>\n\n#include <nvfw/acr.h>\n#include <nvfw/flcn.h>\n\nint\ngm20b_acr_wpr_alloc(struct nvkm_acr *acr, u32 wpr_size)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\n\tacr->func->wpr_check(acr, &acr->wpr_start, &acr->wpr_end);\n\n\tif ((acr->wpr_end - acr->wpr_start) < wpr_size) {\n\t\tnvkm_error(subdev, \"WPR image too big for WPR!\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\treturn nvkm_memory_new(subdev->device, NVKM_MEM_TARGET_INST,\n\t\t\t       wpr_size, 0, true, &acr->wpr);\n}\n\nstatic int\ngm20b_acr_hsfw_load_bld(struct nvkm_falcon_fw *fw)\n{\n\tstruct flcn_bl_dmem_desc hsdesc = {\n\t\t.ctx_dma = FALCON_DMAIDX_VIRT,\n\t\t.code_dma_base = fw->vma->addr >> 8,\n\t\t.non_sec_code_off = fw->nmem_base,\n\t\t.non_sec_code_size = fw->nmem_size,\n\t\t.sec_code_off = fw->imem_base,\n\t\t.sec_code_size = fw->imem_size,\n\t\t.code_entry_point = 0,\n\t\t.data_dma_base = (fw->vma->addr + fw->dmem_base_img) >> 8,\n\t\t.data_size = fw->dmem_size,\n\t};\n\n\tflcn_bl_dmem_desc_dump(fw->falcon->user, &hsdesc);\n\n\treturn nvkm_falcon_pio_wr(fw->falcon, (u8 *)&hsdesc, 0, 0, DMEM, 0, sizeof(hsdesc), 0, 0);\n}\n\n\nstatic int\ngm20b_acr_load_setup(struct nvkm_falcon_fw *fw)\n{\n\tstruct flcn_acr_desc *desc = (void *)&fw->fw.img[fw->dmem_base_img];\n\tstruct nvkm_acr *acr = fw->falcon->owner->device->acr;\n\n\tdesc->ucode_blob_base = nvkm_memory_addr(acr->wpr);\n\tdesc->ucode_blob_size = nvkm_memory_size(acr->wpr);\n\tflcn_acr_desc_dump(&acr->subdev, desc);\n\treturn 0;\n}\n\nconst struct nvkm_falcon_fw_func\ngm20b_acr_load_0 = {\n\t.signature = gm200_flcn_fw_signature,\n\t.reset = gm200_flcn_fw_reset,\n\t.setup = gm20b_acr_load_setup,\n\t.load = gm200_flcn_fw_load,\n\t.load_bld = gm20b_acr_hsfw_load_bld,\n\t.boot = gm200_flcn_fw_boot,\n};\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA_210_SOC)\nMODULE_FIRMWARE(\"nvidia/gm20b/acr/bl.bin\");\nMODULE_FIRMWARE(\"nvidia/gm20b/acr/ucode_load.bin\");\n#endif\n\nstatic const struct nvkm_acr_hsf_fwif\ngm20b_acr_load_fwif[] = {\n\t{ 0, gm200_acr_hsfw_ctor, &gm20b_acr_load_0, NVKM_ACR_HSF_PMU, 0, 0x10 },\n\t{}\n};\n\nstatic const struct nvkm_acr_func\ngm20b_acr = {\n\t.load = gm20b_acr_load_fwif,\n\t.wpr_parse = gm200_acr_wpr_parse,\n\t.wpr_layout = gm200_acr_wpr_layout,\n\t.wpr_alloc = gm20b_acr_wpr_alloc,\n\t.wpr_build = gm200_acr_wpr_build,\n\t.wpr_patch = gm200_acr_wpr_patch,\n\t.wpr_check = gm200_acr_wpr_check,\n\t.init = gm200_acr_init,\n};\n\nint\ngm20b_acr_load(struct nvkm_acr *acr, int ver, const struct nvkm_acr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\tconst struct nvkm_acr_hsf_fwif *hsfwif;\n\n\thsfwif = nvkm_firmware_load(subdev, fwif->func->load, \"AcrLoad\",\n\t\t\t\t    acr, \"acr/bl\", \"acr/ucode_load\", \"load\");\n\tif (IS_ERR(hsfwif))\n\t\treturn PTR_ERR(hsfwif);\n\n\treturn 0;\n}\n\nstatic const struct nvkm_acr_fwif\ngm20b_acr_fwif[] = {\n\t{  0, gm20b_acr_load, &gm20b_acr },\n\t{ -1, gm200_acr_nofw, &gm200_acr },\n\t{}\n};\n\nint\ngm20b_acr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_acr **pacr)\n{\n\treturn nvkm_acr_new_(gm20b_acr_fwif, device, type, inst, pacr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}