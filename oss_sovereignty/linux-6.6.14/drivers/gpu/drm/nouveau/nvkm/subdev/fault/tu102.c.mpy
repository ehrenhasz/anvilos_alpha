{
  "module_name": "tu102.c",
  "hash_id": "d1512d83934fc734ac89fbd026edb37e42121cdfd198412ca24ede043c6eefef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fault/tu102.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n#include <subdev/mc.h>\n#include <subdev/mmu.h>\n#include <subdev/vfn.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n\nstatic irqreturn_t\ntu102_fault_buffer_notify(struct nvkm_inth *inth)\n{\n\tstruct nvkm_fault_buffer *buffer = container_of(inth, typeof(*buffer), inth);\n\n\tnvkm_event_ntfy(&buffer->fault->event, buffer->id, NVKM_FAULT_BUFFER_EVENT_PENDING);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ntu102_fault_buffer_intr(struct nvkm_fault_buffer *buffer, bool enable)\n{\n\tif (enable)\n\t\tnvkm_inth_allow(&buffer->inth);\n\telse\n\t\tnvkm_inth_block(&buffer->inth);\n}\n\nstatic void\ntu102_fault_buffer_fini(struct nvkm_fault_buffer *buffer)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 foff = buffer->id * 0x20;\n\n\tnvkm_mask(device, 0xb83010 + foff, 0x80000000, 0x00000000);\n}\n\nstatic void\ntu102_fault_buffer_init(struct nvkm_fault_buffer *buffer)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 foff = buffer->id * 0x20;\n\n\tnvkm_mask(device, 0xb83010 + foff, 0xc0000000, 0x40000000);\n\tnvkm_wr32(device, 0xb83004 + foff, upper_32_bits(buffer->addr));\n\tnvkm_wr32(device, 0xb83000 + foff, lower_32_bits(buffer->addr));\n\tnvkm_mask(device, 0xb83010 + foff, 0x80000000, 0x80000000);\n}\n\nstatic void\ntu102_fault_buffer_info(struct nvkm_fault_buffer *buffer)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 foff = buffer->id * 0x20;\n\n\tnvkm_mask(device, 0xb83010 + foff, 0x40000000, 0x40000000);\n\n\tbuffer->entries = nvkm_rd32(device, 0xb83010 + foff) & 0x000fffff;\n\tbuffer->get = 0xb83008 + foff;\n\tbuffer->put = 0xb8300c + foff;\n}\n\nstatic irqreturn_t\ntu102_fault_info_fault(struct nvkm_inth *inth)\n{\n\tstruct nvkm_fault *fault = container_of(inth, typeof(*fault), info_fault);\n\tstruct nvkm_subdev *subdev = &fault->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_fault_data info;\n\tconst u32 addrlo = nvkm_rd32(device, 0xb83080);\n\tconst u32 addrhi = nvkm_rd32(device, 0xb83084);\n\tconst u32  info0 = nvkm_rd32(device, 0xb83088);\n\tconst u32 insthi = nvkm_rd32(device, 0xb8308c);\n\tconst u32  info1 = nvkm_rd32(device, 0xb83090);\n\n\tinfo.addr = ((u64)addrhi << 32) | addrlo;\n\tinfo.inst = ((u64)insthi << 32) | (info0 & 0xfffff000);\n\tinfo.time = 0;\n\tinfo.engine = (info0 & 0x000000ff);\n\tinfo.valid  = (info1 & 0x80000000) >> 31;\n\tinfo.gpc    = (info1 & 0x1f000000) >> 24;\n\tinfo.hub    = (info1 & 0x00100000) >> 20;\n\tinfo.access = (info1 & 0x000f0000) >> 16;\n\tinfo.client = (info1 & 0x00007f00) >> 8;\n\tinfo.reason = (info1 & 0x0000001f);\n\n\tnvkm_fifo_fault(device->fifo, &info);\n\n\tnvkm_wr32(device, 0xb83094, 0x80000000);\n\treturn IRQ_HANDLED;\n}\n\nstatic void\ntu102_fault_fini(struct nvkm_fault *fault)\n{\n\tnvkm_event_ntfy_block(&fault->nrpfb);\n\tflush_work(&fault->nrpfb_work);\n\n\tif (fault->buffer[0])\n\t\tfault->func->buffer.fini(fault->buffer[0]);\n\n\tnvkm_inth_block(&fault->info_fault);\n}\n\nstatic void\ntu102_fault_init(struct nvkm_fault *fault)\n{\n\tnvkm_inth_allow(&fault->info_fault);\n\n\tfault->func->buffer.init(fault->buffer[0]);\n\tnvkm_event_ntfy_allow(&fault->nrpfb);\n}\n\nstatic int\ntu102_fault_oneinit(struct nvkm_fault *fault)\n{\n\tstruct nvkm_device *device = fault->subdev.device;\n\tstruct nvkm_intr *intr = &device->vfn->intr;\n\tint ret, i;\n\n\tret = nvkm_inth_add(intr, nvkm_rd32(device, 0x100ee0) & 0x0000ffff,\n\t\t\t    NVKM_INTR_PRIO_NORMAL, &fault->subdev, tu102_fault_info_fault,\n\t\t\t    &fault->info_fault);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < fault->buffer_nr; i++) {\n\t\tret = nvkm_inth_add(intr, nvkm_rd32(device, 0x100ee4 + (i * 4)) >> 16,\n\t\t\t\t    NVKM_INTR_PRIO_NORMAL, &fault->subdev,\n\t\t\t\t    tu102_fault_buffer_notify, &fault->buffer[i]->inth);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn gv100_fault_oneinit(fault);\n}\n\nstatic const struct nvkm_fault_func\ntu102_fault = {\n\t.oneinit = tu102_fault_oneinit,\n\t.init = tu102_fault_init,\n\t.fini = tu102_fault_fini,\n\t.buffer.nr = 2,\n\t.buffer.entry_size = 32,\n\t.buffer.info = tu102_fault_buffer_info,\n\t.buffer.pin = gp100_fault_buffer_pin,\n\t.buffer.init = tu102_fault_buffer_init,\n\t.buffer.fini = tu102_fault_buffer_fini,\n\t.buffer.intr = tu102_fault_buffer_intr,\n\t.user = { { 0, 0, VOLTA_FAULT_BUFFER_A }, 1 },\n};\n\nint\ntu102_fault_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\tstruct nvkm_fault **pfault)\n{\n\tint ret = nvkm_fault_new_(&tu102_fault, device, type, inst, pfault);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&(*pfault)->nrpfb_work, gv100_fault_buffer_process);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}