{
  "module_name": "nv50.c",
  "hash_id": "7cc0c7468287355acc9767ab9f4459022206c203110a730c6bd825b1760dc6e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/nv50.c",
  "human_readable_source": " \n#include \"nv50.h\"\n#include \"ram.h\"\n\n#include <core/client.h>\n#include <core/enum.h>\n#include <engine/fifo.h>\n\nstatic int\nnv50_fb_ram_new(struct nvkm_fb *base, struct nvkm_ram **pram)\n{\n\tstruct nv50_fb *fb = nv50_fb(base);\n\treturn fb->func->ram_new(&fb->base, pram);\n}\n\nstatic const struct nvkm_enum vm_dispatch_subclients[] = {\n\t{ 0x00000000, \"GRCTX\" },\n\t{ 0x00000001, \"NOTIFY\" },\n\t{ 0x00000002, \"QUERY\" },\n\t{ 0x00000003, \"COND\" },\n\t{ 0x00000004, \"M2M_IN\" },\n\t{ 0x00000005, \"M2M_OUT\" },\n\t{ 0x00000006, \"M2M_NOTIFY\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_ccache_subclients[] = {\n\t{ 0x00000000, \"CB\" },\n\t{ 0x00000001, \"TIC\" },\n\t{ 0x00000002, \"TSC\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_prop_subclients[] = {\n\t{ 0x00000000, \"RT0\" },\n\t{ 0x00000001, \"RT1\" },\n\t{ 0x00000002, \"RT2\" },\n\t{ 0x00000003, \"RT3\" },\n\t{ 0x00000004, \"RT4\" },\n\t{ 0x00000005, \"RT5\" },\n\t{ 0x00000006, \"RT6\" },\n\t{ 0x00000007, \"RT7\" },\n\t{ 0x00000008, \"ZETA\" },\n\t{ 0x00000009, \"LOCAL\" },\n\t{ 0x0000000a, \"GLOBAL\" },\n\t{ 0x0000000b, \"STACK\" },\n\t{ 0x0000000c, \"DST2D\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_pfifo_subclients[] = {\n\t{ 0x00000000, \"PUSHBUF\" },\n\t{ 0x00000001, \"SEMAPHORE\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_bar_subclients[] = {\n\t{ 0x00000000, \"FB\" },\n\t{ 0x00000001, \"IN\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_client[] = {\n\t{ 0x00000000, \"STRMOUT\" },\n\t{ 0x00000003, \"DISPATCH\", vm_dispatch_subclients },\n\t{ 0x00000004, \"PFIFO_WRITE\" },\n\t{ 0x00000005, \"CCACHE\", vm_ccache_subclients },\n\t{ 0x00000006, \"PMSPPP\" },\n\t{ 0x00000007, \"CLIPID\" },\n\t{ 0x00000008, \"PFIFO_READ\" },\n\t{ 0x00000009, \"VFETCH\" },\n\t{ 0x0000000a, \"TEXTURE\" },\n\t{ 0x0000000b, \"PROP\", vm_prop_subclients },\n\t{ 0x0000000c, \"PVP\" },\n\t{ 0x0000000d, \"PBSP\" },\n\t{ 0x0000000e, \"PCRYPT\" },\n\t{ 0x0000000f, \"PCOUNTER\" },\n\t{ 0x00000011, \"PDAEMON\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_engine[] = {\n\t{ 0x00000000, \"PGRAPH\" },\n\t{ 0x00000001, \"PVP\" },\n\t{ 0x00000004, \"PEEPHOLE\" },\n\t{ 0x00000005, \"PFIFO\", vm_pfifo_subclients },\n\t{ 0x00000006, \"BAR\", vm_bar_subclients },\n\t{ 0x00000008, \"PMSPPP\" },\n\t{ 0x00000008, \"PMPEG\" },\n\t{ 0x00000009, \"PBSP\" },\n\t{ 0x0000000a, \"PCRYPT\" },\n\t{ 0x0000000b, \"PCOUNTER\" },\n\t{ 0x0000000c, \"SEMAPHORE_BG\" },\n\t{ 0x0000000d, \"PCE0\" },\n\t{ 0x0000000e, \"PMU\" },\n\t{}\n};\n\nstatic const struct nvkm_enum vm_fault[] = {\n\t{ 0x00000000, \"PT_NOT_PRESENT\" },\n\t{ 0x00000001, \"PT_TOO_SHORT\" },\n\t{ 0x00000002, \"PAGE_NOT_PRESENT\" },\n\t{ 0x00000003, \"PAGE_SYSTEM_ONLY\" },\n\t{ 0x00000004, \"PAGE_READ_ONLY\" },\n\t{ 0x00000006, \"NULL_DMAOBJ\" },\n\t{ 0x00000007, \"WRONG_MEMTYPE\" },\n\t{ 0x0000000b, \"VRAM_LIMIT\" },\n\t{ 0x0000000f, \"DMAOBJ_LIMIT\" },\n\t{}\n};\n\nstatic void\nnv50_fb_intr(struct nvkm_fb *base)\n{\n\tstruct nv50_fb *fb = nv50_fb(base);\n\tstruct nvkm_subdev *subdev = &fb->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_chan *chan;\n\tconst struct nvkm_enum *en, *re, *cl, *sc;\n\tu32 trap[6], idx, inst;\n\tu8 st0, st1, st2, st3;\n\tunsigned long flags;\n\tint i;\n\n\tidx = nvkm_rd32(device, 0x100c90);\n\tif (!(idx & 0x80000000))\n\t\treturn;\n\tidx &= 0x00ffffff;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tnvkm_wr32(device, 0x100c90, idx | i << 24);\n\t\ttrap[i] = nvkm_rd32(device, 0x100c94);\n\t}\n\tnvkm_wr32(device, 0x100c90, idx | 0x80000000);\n\n\t \n\tif (device->chipset  < 0xa3 ||\n\t    device->chipset == 0xaa || device->chipset == 0xac) {\n\t\tst0 = (trap[0] & 0x0000000f) >> 0;\n\t\tst1 = (trap[0] & 0x000000f0) >> 4;\n\t\tst2 = (trap[0] & 0x00000f00) >> 8;\n\t\tst3 = (trap[0] & 0x0000f000) >> 12;\n\t} else {\n\t\tst0 = (trap[0] & 0x000000ff) >> 0;\n\t\tst1 = (trap[0] & 0x0000ff00) >> 8;\n\t\tst2 = (trap[0] & 0x00ff0000) >> 16;\n\t\tst3 = (trap[0] & 0xff000000) >> 24;\n\t}\n\tinst = ((trap[2] << 16) | trap[1]) << 12;\n\n\ten = nvkm_enum_find(vm_engine, st0);\n\tre = nvkm_enum_find(vm_fault , st1);\n\tcl = nvkm_enum_find(vm_client, st2);\n\tif      (cl && cl->data) sc = nvkm_enum_find(cl->data, st3);\n\telse if (en && en->data) sc = nvkm_enum_find(en->data, st3);\n\telse                     sc = NULL;\n\n\tchan = nvkm_chan_get_inst(&device->fifo->engine, inst, &flags);\n\tnvkm_error(subdev, \"trapped %s at %02x%04x%04x on channel %d [%08x %s] \"\n\t\t\t   \"engine %02x [%s] client %02x [%s] \"\n\t\t\t   \"subclient %02x [%s] reason %08x [%s]\\n\",\n\t\t   (trap[5] & 0x00000100) ? \"read\" : \"write\",\n\t\t   trap[5] & 0xff, trap[4] & 0xffff, trap[3] & 0xffff,\n\t\t   chan ? chan->id : -1, inst,\n\t\t   chan ? chan->name : \"unknown\",\n\t\t   st0, en ? en->name : \"\",\n\t\t   st2, cl ? cl->name : \"\", st3, sc ? sc->name : \"\",\n\t\t   st1, re ? re->name : \"\");\n\tnvkm_chan_put(&chan, flags);\n}\n\nstatic void\nnv50_fb_init(struct nvkm_fb *base)\n{\n\tstruct nv50_fb *fb = nv50_fb(base);\n\tstruct nvkm_device *device = fb->base.subdev.device;\n\n\t \n\tnvkm_wr32(device, 0x100c90, fb->func->trap);\n}\n\nstatic u32\nnv50_fb_tags(struct nvkm_fb *base)\n{\n\tstruct nv50_fb *fb = nv50_fb(base);\n\tif (fb->func->tags)\n\t\treturn fb->func->tags(&fb->base);\n\treturn 0;\n}\n\nstatic void\nnv50_fb_sysmem_flush_page_init(struct nvkm_fb *fb)\n{\n\tnvkm_wr32(fb->subdev.device, 0x100c08, fb->sysmem.flush_page_addr >> 8);\n}\n\nstatic void *\nnv50_fb_dtor(struct nvkm_fb *base)\n{\n\tstruct nv50_fb *fb = nv50_fb(base);\n\n\treturn fb;\n}\n\nstatic const struct nvkm_fb_func\nnv50_fb_ = {\n\t.dtor = nv50_fb_dtor,\n\t.tags = nv50_fb_tags,\n\t.init = nv50_fb_init,\n\t.intr = nv50_fb_intr,\n\t.sysmem.flush_page_init = nv50_fb_sysmem_flush_page_init,\n\t.ram_new = nv50_fb_ram_new,\n};\n\nint\nnv50_fb_new_(const struct nv50_fb_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_fb **pfb)\n{\n\tstruct nv50_fb *fb;\n\n\tif (!(fb = kzalloc(sizeof(*fb), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_fb_ctor(&nv50_fb_, device, type, inst, &fb->base);\n\tfb->func = func;\n\t*pfb = &fb->base;\n\treturn 0;\n}\n\nstatic const struct nv50_fb_func\nnv50_fb = {\n\t.ram_new = nv50_ram_new,\n\t.tags = nv20_fb_tags,\n\t.trap = 0x000707ff,\n};\n\nint\nnv50_fb_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_fb **pfb)\n{\n\treturn nv50_fb_new_(&nv50_fb, device, type, inst, pfb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}