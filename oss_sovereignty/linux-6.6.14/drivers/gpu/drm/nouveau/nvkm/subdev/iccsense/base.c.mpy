{
  "module_name": "base.c",
  "hash_id": "9d1bc99e806103c0e3a740101998097e0dd961f814d319daf17a317ce34e59ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/iccsense/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/extdev.h>\n#include <subdev/bios/iccsense.h>\n#include <subdev/bios/power_budget.h>\n#include <subdev/i2c.h>\n\nstatic bool\nnvkm_iccsense_validate_device(struct i2c_adapter *i2c, u8 addr,\n\t\t\t      enum nvbios_extdev_type type)\n{\n\tswitch (type) {\n\tcase NVBIOS_EXTDEV_INA209:\n\tcase NVBIOS_EXTDEV_INA219:\n\t\treturn nv_rd16i2cr(i2c, addr, 0x0) >= 0;\n\tcase NVBIOS_EXTDEV_INA3221:\n\t\treturn nv_rd16i2cr(i2c, addr, 0xff) == 0x3220 &&\n\t\t       nv_rd16i2cr(i2c, addr, 0xfe) == 0x5449;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int\nnvkm_iccsense_poll_lane(struct i2c_adapter *i2c, u8 addr, u8 shunt_reg,\n\t\t\tu8 shunt_shift, u8 bus_reg, u8 bus_shift, u8 shunt,\n\t\t\tu16 lsb)\n{\n\tint vshunt = nv_rd16i2cr(i2c, addr, shunt_reg);\n\tint vbus = nv_rd16i2cr(i2c, addr, bus_reg);\n\n\tif (vshunt < 0 || vbus < 0)\n\t\treturn -EINVAL;\n\n\tvshunt >>= shunt_shift;\n\tvbus >>= bus_shift;\n\n\treturn vbus * vshunt * lsb / shunt;\n}\n\nstatic int\nnvkm_iccsense_ina2x9_read(struct nvkm_iccsense *iccsense,\n                          struct nvkm_iccsense_rail *rail,\n\t\t\t  u8 shunt_reg, u8 bus_reg)\n{\n\treturn nvkm_iccsense_poll_lane(rail->sensor->i2c, rail->sensor->addr,\n\t\t\t\t       shunt_reg, 0, bus_reg, 3, rail->mohm,\n\t\t\t\t       10 * 4);\n}\n\nstatic int\nnvkm_iccsense_ina209_read(struct nvkm_iccsense *iccsense,\n\t\t\t  struct nvkm_iccsense_rail *rail)\n{\n\treturn nvkm_iccsense_ina2x9_read(iccsense, rail, 3, 4);\n}\n\nstatic int\nnvkm_iccsense_ina219_read(struct nvkm_iccsense *iccsense,\n\t\t\t  struct nvkm_iccsense_rail *rail)\n{\n\treturn nvkm_iccsense_ina2x9_read(iccsense, rail, 1, 2);\n}\n\nstatic int\nnvkm_iccsense_ina3221_read(struct nvkm_iccsense *iccsense,\n\t\t\t   struct nvkm_iccsense_rail *rail)\n{\n\treturn nvkm_iccsense_poll_lane(rail->sensor->i2c, rail->sensor->addr,\n\t\t\t\t       1 + (rail->idx * 2), 3,\n\t\t\t\t       2 + (rail->idx * 2), 3, rail->mohm,\n\t\t\t\t       40 * 8);\n}\n\nstatic void\nnvkm_iccsense_sensor_config(struct nvkm_iccsense *iccsense,\n\t\t            struct nvkm_iccsense_sensor *sensor)\n{\n\tstruct nvkm_subdev *subdev = &iccsense->subdev;\n\tnvkm_trace(subdev, \"write config of extdev %i: 0x%04x\\n\", sensor->id, sensor->config);\n\tnv_wr16i2cr(sensor->i2c, sensor->addr, 0x00, sensor->config);\n}\n\nint\nnvkm_iccsense_read_all(struct nvkm_iccsense *iccsense)\n{\n\tint result = 0;\n\tstruct nvkm_iccsense_rail *rail;\n\n\tif (!iccsense)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(rail, &iccsense->rails, head) {\n\t\tint res;\n\t\tif (!rail->read)\n\t\t\treturn -ENODEV;\n\n\t\tres = rail->read(iccsense, rail);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t\tresult += res;\n\t}\n\treturn result;\n}\n\nstatic void *\nnvkm_iccsense_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_iccsense *iccsense = nvkm_iccsense(subdev);\n\tstruct nvkm_iccsense_sensor *sensor, *tmps;\n\tstruct nvkm_iccsense_rail *rail, *tmpr;\n\n\tlist_for_each_entry_safe(sensor, tmps, &iccsense->sensors, head) {\n\t\tlist_del(&sensor->head);\n\t\tkfree(sensor);\n\t}\n\tlist_for_each_entry_safe(rail, tmpr, &iccsense->rails, head) {\n\t\tlist_del(&rail->head);\n\t\tkfree(rail);\n\t}\n\n\treturn iccsense;\n}\n\nstatic struct nvkm_iccsense_sensor*\nnvkm_iccsense_create_sensor(struct nvkm_iccsense *iccsense, u8 id)\n{\n\tstruct nvkm_subdev *subdev = &iccsense->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvkm_i2c *i2c = subdev->device->i2c;\n\tstruct nvbios_extdev_func extdev;\n\tstruct nvkm_i2c_bus *i2c_bus;\n\tstruct nvkm_iccsense_sensor *sensor;\n\tu8 addr;\n\n\tif (!i2c || !bios || nvbios_extdev_parse(bios, id, &extdev))\n\t\treturn NULL;\n\n\tif (extdev.type == 0xff)\n\t\treturn NULL;\n\n\tif (extdev.type != NVBIOS_EXTDEV_INA209 &&\n\t    extdev.type != NVBIOS_EXTDEV_INA219 &&\n\t    extdev.type != NVBIOS_EXTDEV_INA3221) {\n\t\ticcsense->data_valid = false;\n\t\tnvkm_error(subdev, \"Unknown sensor type %x, power reading \"\n\t\t\t   \"disabled\\n\", extdev.type);\n\t\treturn NULL;\n\t}\n\n\tif (extdev.bus)\n\t\ti2c_bus = nvkm_i2c_bus_find(i2c, NVKM_I2C_BUS_SEC);\n\telse\n\t\ti2c_bus = nvkm_i2c_bus_find(i2c, NVKM_I2C_BUS_PRI);\n\tif (!i2c_bus)\n\t\treturn NULL;\n\n\taddr = extdev.addr >> 1;\n\tif (!nvkm_iccsense_validate_device(&i2c_bus->i2c, addr,\n\t\t\t\t\t   extdev.type)) {\n\t\ticcsense->data_valid = false;\n\t\tnvkm_warn(subdev, \"found invalid sensor id: %i, power reading\"\n\t\t\t  \"might be invalid\\n\", id);\n\t\treturn NULL;\n\t}\n\n\tsensor = kmalloc(sizeof(*sensor), GFP_KERNEL);\n\tif (!sensor)\n\t\treturn NULL;\n\n\tlist_add_tail(&sensor->head, &iccsense->sensors);\n\tsensor->id = id;\n\tsensor->type = extdev.type;\n\tsensor->i2c = &i2c_bus->i2c;\n\tsensor->addr = addr;\n\tsensor->config = 0x0;\n\treturn sensor;\n}\n\nstatic struct nvkm_iccsense_sensor*\nnvkm_iccsense_get_sensor(struct nvkm_iccsense *iccsense, u8 id)\n{\n\tstruct nvkm_iccsense_sensor *sensor;\n\tlist_for_each_entry(sensor, &iccsense->sensors, head) {\n\t\tif (sensor->id == id)\n\t\t\treturn sensor;\n\t}\n\treturn nvkm_iccsense_create_sensor(iccsense, id);\n}\n\nstatic int\nnvkm_iccsense_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_iccsense *iccsense = nvkm_iccsense(subdev);\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvbios_power_budget budget;\n\tstruct nvbios_iccsense stbl;\n\tint i, ret;\n\n\tif (!bios)\n\t\treturn 0;\n\n\tret = nvbios_power_budget_header(bios, &budget);\n\tif (!ret && budget.cap_entry != 0xff) {\n\t\tstruct nvbios_power_budget_entry entry;\n\t\tret = nvbios_power_budget_entry(bios, &budget,\n\t\t                                budget.cap_entry, &entry);\n\t\tif (!ret) {\n\t\t\ticcsense->power_w_max  = entry.avg_w;\n\t\t\ticcsense->power_w_crit = entry.max_w;\n\t\t}\n\t}\n\n\tif (nvbios_iccsense_parse(bios, &stbl) || !stbl.nr_entry)\n\t\treturn 0;\n\n\ticcsense->data_valid = true;\n\tfor (i = 0; i < stbl.nr_entry; ++i) {\n\t\tstruct pwr_rail_t *pwr_rail = &stbl.rail[i];\n\t\tstruct nvkm_iccsense_sensor *sensor;\n\t\tint r;\n\n\t\tif (pwr_rail->mode != 1 || !pwr_rail->resistor_count)\n\t\t\tcontinue;\n\n\t\tsensor = nvkm_iccsense_get_sensor(iccsense, pwr_rail->extdev_id);\n\t\tif (!sensor)\n\t\t\tcontinue;\n\n\t\tif (!sensor->config)\n\t\t\tsensor->config = pwr_rail->config;\n\t\telse if (sensor->config != pwr_rail->config)\n\t\t\tnvkm_error(subdev, \"config mismatch found for extdev %i\\n\", pwr_rail->extdev_id);\n\n\t\tfor (r = 0; r < pwr_rail->resistor_count; ++r) {\n\t\t\tstruct nvkm_iccsense_rail *rail;\n\t\t\tstruct pwr_rail_resistor_t *res = &pwr_rail->resistors[r];\n\t\t\tint (*read)(struct nvkm_iccsense *,\n\t\t\t\t    struct nvkm_iccsense_rail *);\n\n\t\t\tif (!res->mohm || !res->enabled)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (sensor->type) {\n\t\t\tcase NVBIOS_EXTDEV_INA209:\n\t\t\t\tread = nvkm_iccsense_ina209_read;\n\t\t\t\tbreak;\n\t\t\tcase NVBIOS_EXTDEV_INA219:\n\t\t\t\tread = nvkm_iccsense_ina219_read;\n\t\t\t\tbreak;\n\t\t\tcase NVBIOS_EXTDEV_INA3221:\n\t\t\t\tread = nvkm_iccsense_ina3221_read;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trail = kmalloc(sizeof(*rail), GFP_KERNEL);\n\t\t\tif (!rail)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\trail->read = read;\n\t\t\trail->sensor = sensor;\n\t\t\trail->idx = r;\n\t\t\trail->mohm = res->mohm;\n\t\t\tnvkm_debug(subdev, \"create rail for extdev %i: { idx: %i, mohm: %i }\\n\", pwr_rail->extdev_id, r, rail->mohm);\n\t\t\tlist_add_tail(&rail->head, &iccsense->rails);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nnvkm_iccsense_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_iccsense *iccsense = nvkm_iccsense(subdev);\n\tstruct nvkm_iccsense_sensor *sensor;\n\tlist_for_each_entry(sensor, &iccsense->sensors, head)\n\t\tnvkm_iccsense_sensor_config(iccsense, sensor);\n\treturn 0;\n}\n\nstatic const struct nvkm_subdev_func\niccsense_func = {\n\t.oneinit = nvkm_iccsense_oneinit,\n\t.init = nvkm_iccsense_init,\n\t.dtor = nvkm_iccsense_dtor,\n};\n\nvoid\nnvkm_iccsense_ctor(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\t   struct nvkm_iccsense *iccsense)\n{\n\tnvkm_subdev_ctor(&iccsense_func, device, type, inst, &iccsense->subdev);\n}\n\nint\nnvkm_iccsense_new_(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\t   struct nvkm_iccsense **iccsense)\n{\n\tif (!(*iccsense = kzalloc(sizeof(**iccsense), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&(*iccsense)->sensors);\n\tINIT_LIST_HEAD(&(*iccsense)->rails);\n\tnvkm_iccsense_ctor(device, type, inst, *iccsense);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}