{
  "module_name": "base.c",
  "hash_id": "447b7f1013b69af6bfbbebcd3112b6c1b70fba14df626d7ecf914cb824a516e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/option.h>\n\nstatic int\nnvkm_gpio_drive(struct nvkm_gpio *gpio, int idx, int line, int dir, int out)\n{\n\treturn gpio->func->drive(gpio, line, dir, out);\n}\n\nstatic int\nnvkm_gpio_sense(struct nvkm_gpio *gpio, int idx, int line)\n{\n\treturn gpio->func->sense(gpio, line);\n}\n\nvoid\nnvkm_gpio_reset(struct nvkm_gpio *gpio, u8 func)\n{\n\tif (gpio->func->reset)\n\t\tgpio->func->reset(gpio, func);\n}\n\nint\nnvkm_gpio_find(struct nvkm_gpio *gpio, int idx, u8 tag, u8 line,\n\t       struct dcb_gpio_func *func)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tu8  ver, len;\n\tu16 data;\n\n\tif (line == 0xff && tag == 0xff)\n\t\treturn -EINVAL;\n\n\tdata = dcb_gpio_match(bios, idx, tag, line, &ver, &len, func);\n\tif (data)\n\t\treturn 0;\n\n\t \n\tif (device->quirk && device->quirk->tv_gpio) {\n\t\tif (tag == DCB_GPIO_TVDAC0) {\n\t\t\t*func = (struct dcb_gpio_func) {\n\t\t\t\t.func = DCB_GPIO_TVDAC0,\n\t\t\t\t.line = device->quirk->tv_gpio,\n\t\t\t\t.log[0] = 0,\n\t\t\t\t.log[1] = 1,\n\t\t\t};\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nint\nnvkm_gpio_set(struct nvkm_gpio *gpio, int idx, u8 tag, u8 line, int state)\n{\n\tstruct dcb_gpio_func func;\n\tint ret;\n\n\tret = nvkm_gpio_find(gpio, idx, tag, line, &func);\n\tif (ret == 0) {\n\t\tint dir = !!(func.log[state] & 0x02);\n\t\tint out = !!(func.log[state] & 0x01);\n\t\tret = nvkm_gpio_drive(gpio, idx, func.line, dir, out);\n\t}\n\n\treturn ret;\n}\n\nint\nnvkm_gpio_get(struct nvkm_gpio *gpio, int idx, u8 tag, u8 line)\n{\n\tstruct dcb_gpio_func func;\n\tint ret;\n\n\tret = nvkm_gpio_find(gpio, idx, tag, line, &func);\n\tif (ret == 0) {\n\t\tret = nvkm_gpio_sense(gpio, idx, func.line);\n\t\tif (ret >= 0)\n\t\t\tret = (ret == (func.log[1] & 1));\n\t}\n\n\treturn ret;\n}\n\nstatic void\nnvkm_gpio_intr_fini(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_gpio *gpio = container_of(event, typeof(*gpio), event);\n\tgpio->func->intr_mask(gpio, type, 1 << index, 0);\n}\n\nstatic void\nnvkm_gpio_intr_init(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_gpio *gpio = container_of(event, typeof(*gpio), event);\n\tgpio->func->intr_mask(gpio, type, 1 << index, 1 << index);\n}\n\nstatic const struct nvkm_event_func\nnvkm_gpio_intr_func = {\n\t.init = nvkm_gpio_intr_init,\n\t.fini = nvkm_gpio_intr_fini,\n};\n\nstatic void\nnvkm_gpio_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_gpio *gpio = nvkm_gpio(subdev);\n\tu32 hi, lo, i;\n\n\tgpio->func->intr_stat(gpio, &hi, &lo);\n\n\tfor (i = 0; (hi | lo) && i < gpio->func->lines; i++) {\n\t\tu32 mask = (NVKM_GPIO_HI * !!(hi & (1 << i))) |\n\t\t\t   (NVKM_GPIO_LO * !!(lo & (1 << i)));\n\t\tnvkm_event_ntfy(&gpio->event, i, mask);\n\t}\n}\n\nstatic int\nnvkm_gpio_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_gpio *gpio = nvkm_gpio(subdev);\n\tu32 mask = (1ULL << gpio->func->lines) - 1;\n\n\tgpio->func->intr_mask(gpio, NVKM_GPIO_TOGGLED, mask, 0);\n\tgpio->func->intr_stat(gpio, &mask, &mask);\n\treturn 0;\n}\n\nstatic const struct dmi_system_id gpio_reset_ids[] = {\n\t{\n\t\t.ident = \"Apple Macbook 10,1\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro10,1\"),\n\t\t}\n\t},\n\t{ }\n};\n\nstatic enum dcb_gpio_func_name power_checks[] = {\n\tDCB_GPIO_THERM_EXT_POWER_EVENT,\n\tDCB_GPIO_POWER_ALERT,\n\tDCB_GPIO_EXT_POWER_LOW,\n};\n\nstatic int\nnvkm_gpio_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_gpio *gpio = nvkm_gpio(subdev);\n\tstruct dcb_gpio_func func;\n\tint ret;\n\tint i;\n\n\tif (dmi_check_system(gpio_reset_ids))\n\t\tnvkm_gpio_reset(gpio, DCB_GPIO_UNUSED);\n\n\tif (nvkm_boolopt(subdev->device->cfgopt, \"NvPowerChecks\", true)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(power_checks); ++i) {\n\t\t\tret = nvkm_gpio_find(gpio, 0, power_checks[i],\n\t\t\t\t\t     DCB_GPIO_UNUSED, &func);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\n\t\t\tret = nvkm_gpio_get(gpio, 0, func.func, func.line);\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\n\t\t\tnvkm_error(&gpio->subdev,\n\t\t\t\t   \"GPU is missing power, check its power \"\n\t\t\t\t   \"cables.  Boot with \"\n\t\t\t\t   \"nouveau.config=NvPowerChecks=0 to \"\n\t\t\t\t   \"disable.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void *\nnvkm_gpio_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_gpio *gpio = nvkm_gpio(subdev);\n\tnvkm_event_fini(&gpio->event);\n\treturn gpio;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_gpio = {\n\t.dtor = nvkm_gpio_dtor,\n\t.init = nvkm_gpio_init,\n\t.fini = nvkm_gpio_fini,\n\t.intr = nvkm_gpio_intr,\n};\n\nint\nnvkm_gpio_new_(const struct nvkm_gpio_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_gpio **pgpio)\n{\n\tstruct nvkm_gpio *gpio;\n\n\tif (!(gpio = *pgpio = kzalloc(sizeof(*gpio), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_subdev_ctor(&nvkm_gpio, device, type, inst, &gpio->subdev);\n\tgpio->func = func;\n\n\treturn nvkm_event_init(&nvkm_gpio_intr_func, &gpio->subdev, 2, func->lines, &gpio->event);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}