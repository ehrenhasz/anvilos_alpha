{
  "module_name": "nv04.c",
  "hash_id": "3612ddcd2fec6813dee91f066d1191b331324835c50c6a6c9377017f4d5d7c87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mc/nv04.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nconst struct nvkm_mc_map\nnv04_mc_reset[] = {\n\t{ 0x00001000, NVKM_ENGINE_GR },\n\t{ 0x00000100, NVKM_ENGINE_FIFO },\n\t{}\n};\n\nstatic void\nnv04_mc_device_disable(struct nvkm_mc *mc, u32 mask)\n{\n\tnvkm_mask(mc->subdev.device, 0x000200, mask, 0x00000000);\n}\n\nstatic void\nnv04_mc_device_enable(struct nvkm_mc *mc, u32 mask)\n{\n\tstruct nvkm_device *device = mc->subdev.device;\n\n\tnvkm_mask(device, 0x000200, mask, mask);\n\tnvkm_rd32(device, 0x000200);\n}\n\nstatic bool\nnv04_mc_device_enabled(struct nvkm_mc *mc, u32 mask)\n{\n\treturn (nvkm_rd32(mc->subdev.device, 0x000200) & mask) == mask;\n}\n\nconst struct nvkm_mc_device_func\nnv04_mc_device = {\n\t.enabled = nv04_mc_device_enabled,\n\t.enable = nv04_mc_device_enable,\n\t.disable = nv04_mc_device_disable,\n};\n\nstatic const struct nvkm_intr_data\nnv04_mc_intrs[] = {\n\t{ NVKM_ENGINE_DISP , 0, 0, 0x01010000, true },\n\t{ NVKM_ENGINE_GR   , 0, 0, 0x00001000, true },\n\t{ NVKM_ENGINE_FIFO , 0, 0, 0x00000100 },\n\t{ NVKM_SUBDEV_BUS  , 0, 0, 0x10000000, true },\n\t{ NVKM_SUBDEV_TIMER, 0, 0, 0x00100000, true },\n\t{}\n};\n\nvoid\nnv04_mc_intr_rearm(struct nvkm_intr *intr)\n{\n\tstruct nvkm_mc *mc = container_of(intr, typeof(*mc), intr);\n\tint leaf;\n\n\tfor (leaf = 0; leaf < intr->leaves; leaf++)\n\t\tnvkm_wr32(mc->subdev.device, 0x000140 + (leaf * 4), 0x00000001);\n}\n\nvoid\nnv04_mc_intr_unarm(struct nvkm_intr *intr)\n{\n\tstruct nvkm_mc *mc = container_of(intr, typeof(*mc), intr);\n\tint leaf;\n\n\tfor (leaf = 0; leaf < intr->leaves; leaf++)\n\t\tnvkm_wr32(mc->subdev.device, 0x000140 + (leaf * 4), 0x00000000);\n\n\tnvkm_rd32(mc->subdev.device, 0x000140);\n}\n\nbool\nnv04_mc_intr_pending(struct nvkm_intr *intr)\n{\n\tstruct nvkm_mc *mc = container_of(intr, typeof(*mc), intr);\n\tbool pending = false;\n\tint leaf;\n\n\tfor (leaf = 0; leaf < intr->leaves; leaf++) {\n\t\tintr->stat[leaf] = nvkm_rd32(mc->subdev.device, 0x000100 + (leaf * 4));\n\t\tif (intr->stat[leaf])\n\t\t\tpending = true;\n\t}\n\n\treturn pending;\n}\n\nconst struct nvkm_intr_func\nnv04_mc_intr = {\n\t.pending = nv04_mc_intr_pending,\n\t.unarm = nv04_mc_intr_unarm,\n\t.rearm = nv04_mc_intr_rearm,\n};\n\nvoid\nnv04_mc_init(struct nvkm_mc *mc)\n{\n\tstruct nvkm_device *device = mc->subdev.device;\n\tnvkm_wr32(device, 0x000200, 0xffffffff);  \n\tnvkm_wr32(device, 0x001850, 0x00000001);  \n}\n\nstatic const struct nvkm_mc_func\nnv04_mc = {\n\t.init = nv04_mc_init,\n\t.intr = &nv04_mc_intr,\n\t.intrs = nv04_mc_intrs,\n\t.device = &nv04_mc_device,\n\t.reset = nv04_mc_reset,\n};\n\nint\nnv04_mc_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_mc **pmc)\n{\n\treturn nvkm_mc_new_(&nv04_mc, device, type, inst, pmc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}