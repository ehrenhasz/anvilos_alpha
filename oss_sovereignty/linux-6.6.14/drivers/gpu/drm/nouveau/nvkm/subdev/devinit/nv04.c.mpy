{
  "module_name": "nv04.c",
  "hash_id": "8b265ecec5fe2867b127230eeb2f978568bf05b6cf922180d2a8fd16e4b41f9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/devinit/nv04.c",
  "human_readable_source": " \n#include \"nv04.h\"\n#include \"fbmem.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/init.h>\n#include <subdev/bios/pll.h>\n#include <subdev/clk/pll.h>\n#include <subdev/vga.h>\n\nstatic void\nnv04_devinit_meminit(struct nvkm_devinit *init)\n{\n\tstruct nvkm_subdev *subdev = &init->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 patt = 0xdeadbeef;\n\tstruct io_mapping *fb;\n\tint i;\n\n\t \n\tfb = fbmem_init(device);\n\tif (!fb) {\n\t\tnvkm_error(subdev, \"failed to map fb\\n\");\n\t\treturn;\n\t}\n\n\t \n\tnvkm_wrvgas(device, 0, 1, nvkm_rdvgas(device, 0, 1) | 0x20);\n\tnvkm_mask(device, NV04_PFB_DEBUG_0, 0, NV04_PFB_DEBUG_0_REFRESH_OFF);\n\n\tnvkm_mask(device, NV04_PFB_BOOT_0, ~0,\n\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT_16MB |\n\t\t      NV04_PFB_BOOT_0_RAM_WIDTH_128 |\n\t\t      NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_16MBIT);\n\n\tfor (i = 0; i < 4; i++)\n\t\tfbmem_poke(fb, 4 * i, patt);\n\n\tfbmem_poke(fb, 0x400000, patt + 1);\n\n\tif (fbmem_peek(fb, 0) == patt + 1) {\n\t\tnvkm_mask(device, NV04_PFB_BOOT_0,\n\t\t\t      NV04_PFB_BOOT_0_RAM_TYPE,\n\t\t\t      NV04_PFB_BOOT_0_RAM_TYPE_SDRAM_16MBIT);\n\t\tnvkm_mask(device, NV04_PFB_DEBUG_0,\n\t\t\t      NV04_PFB_DEBUG_0_REFRESH_OFF, 0);\n\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tfbmem_poke(fb, 4 * i, patt);\n\n\t\tif ((fbmem_peek(fb, 0xc) & 0xffff) != (patt & 0xffff))\n\t\t\tnvkm_mask(device, NV04_PFB_BOOT_0,\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_WIDTH_128 |\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT,\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);\n\t} else\n\tif ((fbmem_peek(fb, 0xc) & 0xffff0000) != (patt & 0xffff0000)) {\n\t\tnvkm_mask(device, NV04_PFB_BOOT_0,\n\t\t\t      NV04_PFB_BOOT_0_RAM_WIDTH_128 |\n\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT,\n\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);\n\t} else\n\tif (fbmem_peek(fb, 0) != patt) {\n\t\tif (fbmem_readback(fb, 0x800000, patt))\n\t\t\tnvkm_mask(device, NV04_PFB_BOOT_0,\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT,\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);\n\t\telse\n\t\t\tnvkm_mask(device, NV04_PFB_BOOT_0,\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT,\n\t\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT_4MB);\n\n\t\tnvkm_mask(device, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_TYPE,\n\t\t\t      NV04_PFB_BOOT_0_RAM_TYPE_SGRAM_8MBIT);\n\t} else\n\tif (!fbmem_readback(fb, 0x800000, patt)) {\n\t\tnvkm_mask(device, NV04_PFB_BOOT_0, NV04_PFB_BOOT_0_RAM_AMOUNT,\n\t\t\t      NV04_PFB_BOOT_0_RAM_AMOUNT_8MB);\n\n\t}\n\n\t \n\tnvkm_mask(device, NV04_PFB_DEBUG_0, NV04_PFB_DEBUG_0_REFRESH_OFF, 0);\n\tnvkm_wrvgas(device, 0, 1, nvkm_rdvgas(device, 0, 1) & ~0x20);\n\tfbmem_fini(fb);\n}\n\nstatic int\npowerctrl_1_shift(int chip_version, int reg)\n{\n\tint shift = -4;\n\n\tif (chip_version < 0x17 || chip_version == 0x1a || chip_version == 0x20)\n\t\treturn shift;\n\n\tswitch (reg) {\n\tcase 0x680520:\n\t\tshift += 4; fallthrough;\n\tcase 0x680508:\n\t\tshift += 4; fallthrough;\n\tcase 0x680504:\n\t\tshift += 4; fallthrough;\n\tcase 0x680500:\n\t\tshift += 4;\n\t}\n\n\t \n\tif (shift > 4 && (chip_version < 0x32 || chip_version == 0x35 ||\n\t\t\t  chip_version == 0x36 || chip_version >= 0x40))\n\t\tshift = -4;\n\n\treturn shift;\n}\n\nvoid\nsetPLL_single(struct nvkm_devinit *init, u32 reg,\n\t      struct nvkm_pll_vals *pv)\n{\n\tstruct nvkm_device *device = init->subdev.device;\n\tint chip_version = device->bios->version.chip;\n\tuint32_t oldpll = nvkm_rd32(device, reg);\n\tint oldN = (oldpll >> 8) & 0xff, oldM = oldpll & 0xff;\n\tuint32_t pll = (oldpll & 0xfff80000) | pv->log2P << 16 | pv->NM1;\n\tuint32_t saved_powerctrl_1 = 0;\n\tint shift_powerctrl_1 = powerctrl_1_shift(chip_version, reg);\n\n\tif (oldpll == pll)\n\t\treturn;\t \n\n\tif (shift_powerctrl_1 >= 0) {\n\t\tsaved_powerctrl_1 = nvkm_rd32(device, 0x001584);\n\t\tnvkm_wr32(device, 0x001584,\n\t\t\t(saved_powerctrl_1 & ~(0xf << shift_powerctrl_1)) |\n\t\t\t1 << shift_powerctrl_1);\n\t}\n\n\tif (oldM && pv->M1 && (oldN / oldM < pv->N1 / pv->M1))\n\t\t \n\t\tnvkm_wr32(device, reg, pv->log2P << 16 | (oldpll & 0xffff));\n\telse\n\t\t \n\t\tnvkm_wr32(device, reg, (oldpll & 0xffff0000) | pv->NM1);\n\n\tif ((chip_version < 0x17 || chip_version == 0x1a) &&\n\t    chip_version != 0x11)\n\t\t \n\t\tmsleep(64);\n\tnvkm_rd32(device, reg);\n\n\t \n\tnvkm_wr32(device, reg, pll);\n\n\tif (shift_powerctrl_1 >= 0)\n\t\tnvkm_wr32(device, 0x001584, saved_powerctrl_1);\n}\n\nstatic uint32_t\nnew_ramdac580(uint32_t reg1, bool ss, uint32_t ramdac580)\n{\n\tbool head_a = (reg1 == 0x680508);\n\n\tif (ss)\t \n\t\tramdac580 |= head_a ? 0x00000100 : 0x10000000;\n\telse\n\t\tramdac580 &= head_a ? 0xfffffeff : 0xefffffff;\n\n\treturn ramdac580;\n}\n\nvoid\nsetPLL_double_highregs(struct nvkm_devinit *init, u32 reg1,\n\t\t       struct nvkm_pll_vals *pv)\n{\n\tstruct nvkm_device *device = init->subdev.device;\n\tint chip_version = device->bios->version.chip;\n\tbool nv3035 = chip_version == 0x30 || chip_version == 0x35;\n\tuint32_t reg2 = reg1 + ((reg1 == 0x680520) ? 0x5c : 0x70);\n\tuint32_t oldpll1 = nvkm_rd32(device, reg1);\n\tuint32_t oldpll2 = !nv3035 ? nvkm_rd32(device, reg2) : 0;\n\tuint32_t pll1 = (oldpll1 & 0xfff80000) | pv->log2P << 16 | pv->NM1;\n\tuint32_t pll2 = (oldpll2 & 0x7fff0000) | 1 << 31 | pv->NM2;\n\tuint32_t oldramdac580 = 0, ramdac580 = 0;\n\tbool single_stage = !pv->NM2 || pv->N2 == pv->M2;\t \n\tuint32_t saved_powerctrl_1 = 0, savedc040 = 0;\n\tint shift_powerctrl_1 = powerctrl_1_shift(chip_version, reg1);\n\n\t \n\tif (nv3035) {\n\t\tpll1 = (pll1 & 0xfcc7ffff) | (pv->N2 & 0x18) << 21 |\n\t\t       (pv->N2 & 0x7) << 19 | 8 << 4 | (pv->M2 & 7) << 4;\n\t\tpll2 = 0;\n\t}\n\tif (chip_version > 0x40 && reg1 >= 0x680508) {  \n\t\toldramdac580 = nvkm_rd32(device, 0x680580);\n\t\tramdac580 = new_ramdac580(reg1, single_stage, oldramdac580);\n\t\tif (oldramdac580 != ramdac580)\n\t\t\toldpll1 = ~0;\t \n\t\tif (single_stage)\n\t\t\t \n\t\t\tpll2 |= 0x011f;\n\t}\n\tif (chip_version > 0x70)\n\t\t \n\t\tpll1 = (pll1 & 0x7fffffff) | (single_stage ? 0x4 : 0xc) << 28;\n\n\tif (oldpll1 == pll1 && oldpll2 == pll2)\n\t\treturn;\t \n\n\tif (shift_powerctrl_1 >= 0) {\n\t\tsaved_powerctrl_1 = nvkm_rd32(device, 0x001584);\n\t\tnvkm_wr32(device, 0x001584,\n\t\t\t(saved_powerctrl_1 & ~(0xf << shift_powerctrl_1)) |\n\t\t\t1 << shift_powerctrl_1);\n\t}\n\n\tif (chip_version >= 0x40) {\n\t\tint shift_c040 = 14;\n\n\t\tswitch (reg1) {\n\t\tcase 0x680504:\n\t\t\tshift_c040 += 2; fallthrough;\n\t\tcase 0x680500:\n\t\t\tshift_c040 += 2; fallthrough;\n\t\tcase 0x680520:\n\t\t\tshift_c040 += 2; fallthrough;\n\t\tcase 0x680508:\n\t\t\tshift_c040 += 2;\n\t\t}\n\n\t\tsavedc040 = nvkm_rd32(device, 0xc040);\n\t\tif (shift_c040 != 14)\n\t\t\tnvkm_wr32(device, 0xc040, savedc040 & ~(3 << shift_c040));\n\t}\n\n\tif (oldramdac580 != ramdac580)\n\t\tnvkm_wr32(device, 0x680580, ramdac580);\n\n\tif (!nv3035)\n\t\tnvkm_wr32(device, reg2, pll2);\n\tnvkm_wr32(device, reg1, pll1);\n\n\tif (shift_powerctrl_1 >= 0)\n\t\tnvkm_wr32(device, 0x001584, saved_powerctrl_1);\n\tif (chip_version >= 0x40)\n\t\tnvkm_wr32(device, 0xc040, savedc040);\n}\n\nvoid\nsetPLL_double_lowregs(struct nvkm_devinit *init, u32 NMNMreg,\n\t\t      struct nvkm_pll_vals *pv)\n{\n\t \n\tstruct nvkm_device *device = init->subdev.device;\n\tuint32_t Preg = NMNMreg - 4;\n\tbool mpll = Preg == 0x4020;\n\tuint32_t oldPval = nvkm_rd32(device, Preg);\n\tuint32_t NMNM = pv->NM2 << 16 | pv->NM1;\n\tuint32_t Pval = (oldPval & (mpll ? ~(0x77 << 16) : ~(7 << 16))) |\n\t\t\t0xc << 28 | pv->log2P << 16;\n\tuint32_t saved4600 = 0;\n\t \n\tuint32_t maskc040 = ~(3 << 14), savedc040;\n\tbool single_stage = !pv->NM2 || pv->N2 == pv->M2;\n\n\tif (nvkm_rd32(device, NMNMreg) == NMNM && (oldPval & 0xc0070000) == Pval)\n\t\treturn;\n\n\tif (Preg == 0x4000)\n\t\tmaskc040 = ~0x333;\n\tif (Preg == 0x4058)\n\t\tmaskc040 = ~(0xc << 24);\n\n\tif (mpll) {\n\t\tstruct nvbios_pll info;\n\t\tuint8_t Pval2;\n\n\t\tif (nvbios_pll_parse(device->bios, Preg, &info))\n\t\t\treturn;\n\n\t\tPval2 = pv->log2P + info.bias_p;\n\t\tif (Pval2 > info.max_p)\n\t\t\tPval2 = info.max_p;\n\t\tPval |= 1 << 28 | Pval2 << 20;\n\n\t\tsaved4600 = nvkm_rd32(device, 0x4600);\n\t\tnvkm_wr32(device, 0x4600, saved4600 | 8 << 28);\n\t}\n\tif (single_stage)\n\t\tPval |= mpll ? 1 << 12 : 1 << 8;\n\n\tnvkm_wr32(device, Preg, oldPval | 1 << 28);\n\tnvkm_wr32(device, Preg, Pval & ~(4 << 28));\n\tif (mpll) {\n\t\tPval |= 8 << 20;\n\t\tnvkm_wr32(device, 0x4020, Pval & ~(0xc << 28));\n\t\tnvkm_wr32(device, 0x4038, Pval & ~(0xc << 28));\n\t}\n\n\tsavedc040 = nvkm_rd32(device, 0xc040);\n\tnvkm_wr32(device, 0xc040, savedc040 & maskc040);\n\n\tnvkm_wr32(device, NMNMreg, NMNM);\n\tif (NMNMreg == 0x4024)\n\t\tnvkm_wr32(device, 0x403c, NMNM);\n\n\tnvkm_wr32(device, Preg, Pval);\n\tif (mpll) {\n\t\tPval &= ~(8 << 20);\n\t\tnvkm_wr32(device, 0x4020, Pval);\n\t\tnvkm_wr32(device, 0x4038, Pval);\n\t\tnvkm_wr32(device, 0x4600, saved4600);\n\t}\n\n\tnvkm_wr32(device, 0xc040, savedc040);\n\n\tif (mpll) {\n\t\tnvkm_wr32(device, 0x4020, Pval & ~(1 << 28));\n\t\tnvkm_wr32(device, 0x4038, Pval & ~(1 << 28));\n\t}\n}\n\nint\nnv04_devinit_pll_set(struct nvkm_devinit *devinit, u32 type, u32 freq)\n{\n\tstruct nvkm_subdev *subdev = &devinit->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvkm_pll_vals pv;\n\tstruct nvbios_pll info;\n\tint cv = bios->version.chip;\n\tint N1, M1, N2, M2, P;\n\tint ret;\n\n\tret = nvbios_pll_parse(bios, type > 0x405c ? type : type - 4, &info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nv04_pll_calc(subdev, &info, freq, &N1, &M1, &N2, &M2, &P);\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tpv.refclk = info.refclk;\n\tpv.N1 = N1;\n\tpv.M1 = M1;\n\tpv.N2 = N2;\n\tpv.M2 = M2;\n\tpv.log2P = P;\n\n\tif (cv == 0x30 || cv == 0x31 || cv == 0x35 || cv == 0x36 ||\n\t    cv >= 0x40) {\n\t\tif (type > 0x405c)\n\t\t\tsetPLL_double_highregs(devinit, type, &pv);\n\t\telse\n\t\t\tsetPLL_double_lowregs(devinit, type, &pv);\n\t} else\n\t\tsetPLL_single(devinit, type, &pv);\n\n\treturn 0;\n}\n\nint\nnv04_devinit_post(struct nvkm_devinit *init, bool execute)\n{\n\treturn nvbios_post(&init->subdev, execute);\n}\n\nvoid\nnv04_devinit_preinit(struct nvkm_devinit *base)\n{\n\tstruct nv04_devinit *init = nv04_devinit(base);\n\tstruct nvkm_subdev *subdev = &init->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\t \n\tnvkm_mask(device, 0x000200, 0x00000001, 0x00000001);\n\n\t \n\tif (init->owner < 0)\n\t\tinit->owner = nvkm_rdvgaowner(device);\n\tnvkm_wrvgaowner(device, 0);\n\n\tif (!init->base.post) {\n\t\tu32 htotal = nvkm_rdvgac(device, 0, 0x06);\n\t\thtotal |= (nvkm_rdvgac(device, 0, 0x07) & 0x01) << 8;\n\t\thtotal |= (nvkm_rdvgac(device, 0, 0x07) & 0x20) << 4;\n\t\thtotal |= (nvkm_rdvgac(device, 0, 0x25) & 0x01) << 10;\n\t\thtotal |= (nvkm_rdvgac(device, 0, 0x41) & 0x01) << 11;\n\t\tif (!htotal) {\n\t\t\tnvkm_debug(subdev, \"adaptor not initialised\\n\");\n\t\t\tinit->base.post = true;\n\t\t}\n\t}\n}\n\nvoid *\nnv04_devinit_dtor(struct nvkm_devinit *base)\n{\n\tstruct nv04_devinit *init = nv04_devinit(base);\n\t \n\tnvkm_wrvgaowner(init->base.subdev.device, init->owner);\n\treturn init;\n}\n\nint\nnv04_devinit_new_(const struct nvkm_devinit_func *func, struct nvkm_device *device,\n\t\t  enum nvkm_subdev_type type, int inst, struct nvkm_devinit **pinit)\n{\n\tstruct nv04_devinit *init;\n\n\tif (!(init = kzalloc(sizeof(*init), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pinit = &init->base;\n\n\tnvkm_devinit_ctor(func, device, type, inst, &init->base);\n\tinit->owner = -1;\n\treturn 0;\n}\n\nstatic const struct nvkm_devinit_func\nnv04_devinit = {\n\t.dtor = nv04_devinit_dtor,\n\t.preinit = nv04_devinit_preinit,\n\t.post = nv04_devinit_post,\n\t.meminit = nv04_devinit_meminit,\n\t.pll_set = nv04_devinit_pll_set,\n};\n\nint\nnv04_devinit_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\t struct nvkm_devinit **pinit)\n{\n\treturn nv04_devinit_new_(&nv04_devinit, device, type, inst, pinit);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}