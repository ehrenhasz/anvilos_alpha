{
  "module_name": "auxgm200.c",
  "hash_id": "4e3d3a909321b89c3b7b891393e793900d5e90e7247c238fa4ea3cba9b3f330d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/auxgm200.c",
  "human_readable_source": " \n#define gm200_i2c_aux(p) container_of((p), struct gm200_i2c_aux, base)\n#include \"aux.h\"\n\nstruct gm200_i2c_aux {\n\tstruct nvkm_i2c_aux base;\n\tint ch;\n};\n\nstatic void\ngm200_i2c_aux_fini(struct gm200_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = aux->base.pad->i2c->subdev.device;\n\tnvkm_mask(device, 0x00d954 + (aux->ch * 0x50), 0x00710000, 0x00000000);\n}\n\nstatic int\ngm200_i2c_aux_init(struct gm200_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = aux->base.pad->i2c->subdev.device;\n\tconst u32 unksel = 1;  \n\tconst u32 ureq = unksel ? 0x00100000 : 0x00200000;\n\tconst u32 urep = unksel ? 0x01000000 : 0x02000000;\n\tu32 ctrl, timeout;\n\n\t \n\ttimeout = 1000;\n\tdo {\n\t\tctrl = nvkm_rd32(device, 0x00d954 + (aux->ch * 0x50));\n\t\tudelay(1);\n\t\tif (!timeout--) {\n\t\t\tAUX_ERR(&aux->base, \"begin idle timeout %08x\", ctrl);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} while (ctrl & 0x07010000);\n\n\t \n\tnvkm_mask(device, 0x00d954 + (aux->ch * 0x50), 0x00700000, ureq);\n\ttimeout = 1000;\n\tdo {\n\t\tctrl = nvkm_rd32(device, 0x00d954 + (aux->ch * 0x50));\n\t\tudelay(1);\n\t\tif (!timeout--) {\n\t\t\tAUX_ERR(&aux->base, \"magic wait %08x\", ctrl);\n\t\t\tgm200_i2c_aux_fini(aux);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} while ((ctrl & 0x07000000) != urep);\n\n\treturn 0;\n}\n\nstatic int\ngm200_i2c_aux_xfer(struct nvkm_i2c_aux *obj, bool retry,\n\t\t   u8 type, u32 addr, u8 *data, u8 *size)\n{\n\tstruct gm200_i2c_aux *aux = gm200_i2c_aux(obj);\n\tstruct nvkm_i2c *i2c = aux->base.pad->i2c;\n\tstruct nvkm_device *device = i2c->subdev.device;\n\tconst u32 base = aux->ch * 0x50;\n\tu32 ctrl, stat, timeout, retries = 0;\n\tu32 xbuf[4] = {};\n\tint ret, i;\n\n\tAUX_TRACE(&aux->base, \"%d: %08x %d\", type, addr, *size);\n\n\tret = gm200_i2c_aux_init(aux);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tstat = nvkm_rd32(device, 0x00d958 + base);\n\tif (!(stat & 0x10000000)) {\n\t\tAUX_TRACE(&aux->base, \"sink not detected\");\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tnvkm_i2c_aux_autodpcd(i2c, aux->ch, false);\n\n\tif (!(type & 1)) {\n\t\tmemcpy(xbuf, data, *size);\n\t\tfor (i = 0; i < 16; i += 4) {\n\t\t\tAUX_TRACE(&aux->base, \"wr %08x\", xbuf[i / 4]);\n\t\t\tnvkm_wr32(device, 0x00d930 + base + i, xbuf[i / 4]);\n\t\t}\n\t}\n\n\tctrl  = nvkm_rd32(device, 0x00d954 + base);\n\tctrl &= ~0x0001f1ff;\n\tctrl |= type << 12;\n\tctrl |= (*size ? (*size - 1) : 0x00000100);\n\tnvkm_wr32(device, 0x00d950 + base, addr);\n\n\t \n\tdo {\n\t\t \n\t\tnvkm_wr32(device, 0x00d954 + base, 0x80000000 | ctrl);\n\t\tnvkm_wr32(device, 0x00d954 + base, 0x00000000 | ctrl);\n\t\tif (retries)\n\t\t\tudelay(400);\n\n\t\t \n\t\tnvkm_wr32(device, 0x00d954 + base, 0x00010000 | ctrl);\n\n\t\ttimeout = 2000;\n\t\tdo {\n\t\t\tctrl = nvkm_rd32(device, 0x00d954 + base);\n\t\t\tudelay(1);\n\t\t\tif (!timeout--) {\n\t\t\t\tAUX_ERR(&aux->base, \"timeout %08x\", ctrl);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t} while (ctrl & 0x00010000);\n\t\tret = 0;\n\n\t\t \n\t\tstat = nvkm_mask(device, 0x00d958 + base, 0, 0);\n\t\tif ((stat & 0x000f0000) == 0x00080000 ||\n\t\t    (stat & 0x000f0000) == 0x00020000)\n\t\t\tret = 1;\n\t\tif ((stat & 0x00000100))\n\t\t\tret = -ETIMEDOUT;\n\t\tif ((stat & 0x00000e00))\n\t\t\tret = -EIO;\n\n\t\tAUX_TRACE(&aux->base, \"%02d %08x %08x\", retries, ctrl, stat);\n\t} while (ret && retry && retries++ < 32);\n\n\tif (type & 1) {\n\t\tfor (i = 0; i < 16; i += 4) {\n\t\t\txbuf[i / 4] = nvkm_rd32(device, 0x00d940 + base + i);\n\t\t\tAUX_TRACE(&aux->base, \"rd %08x\", xbuf[i / 4]);\n\t\t}\n\t\tmemcpy(data, xbuf, *size);\n\t\t*size = stat & 0x0000001f;\n\t}\n\nout_err:\n\tnvkm_i2c_aux_autodpcd(i2c, aux->ch, true);\nout:\n\tgm200_i2c_aux_fini(aux);\n\treturn ret < 0 ? ret : (stat & 0x000f0000) >> 16;\n}\n\nstatic const struct nvkm_i2c_aux_func\ngm200_i2c_aux_func = {\n\t.address_only = true,\n\t.xfer = gm200_i2c_aux_xfer,\n};\n\nint\ngm200_i2c_aux_new(struct nvkm_i2c_pad *pad, int index, u8 drive,\n\t\tstruct nvkm_i2c_aux **paux)\n{\n\tstruct gm200_i2c_aux *aux;\n\n\tif (!(aux = kzalloc(sizeof(*aux), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*paux = &aux->base;\n\n\tnvkm_i2c_aux_ctor(&gm200_i2c_aux_func, pad, index, &aux->base);\n\taux->ch = drive;\n\taux->base.intr = 1 << aux->ch;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}