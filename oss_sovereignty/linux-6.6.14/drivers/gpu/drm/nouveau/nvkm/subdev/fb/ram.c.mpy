{
  "module_name": "ram.c",
  "hash_id": "47600a927ae24d6bed9f7aa016a409b75492e0770c9966fbe3fd8209aebcb061",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ram.c",
  "human_readable_source": " \n#define nvkm_vram(p) container_of((p), struct nvkm_vram, memory)\n#include \"ram.h\"\n\n#include <core/memory.h>\n#include <subdev/instmem.h>\n#include <subdev/mmu.h>\n\nstruct nvkm_vram {\n\tstruct nvkm_memory memory;\n\tstruct nvkm_ram *ram;\n\tu8 page;\n\tstruct nvkm_mm_node *mn;\n};\n\nstatic int\nnvkm_vram_kmap(struct nvkm_memory *memory, struct nvkm_memory **pmemory)\n{\n\treturn nvkm_instobj_wrap(nvkm_vram(memory)->ram->fb->subdev.device, memory, pmemory);\n}\n\nstatic int\nnvkm_vram_map(struct nvkm_memory *memory, u64 offset, struct nvkm_vmm *vmm,\n\t      struct nvkm_vma *vma, void *argv, u32 argc)\n{\n\tstruct nvkm_vram *vram = nvkm_vram(memory);\n\tstruct nvkm_vmm_map map = {\n\t\t.memory = &vram->memory,\n\t\t.offset = offset,\n\t\t.mem = vram->mn,\n\t};\n\n\treturn nvkm_vmm_map(vmm, vma, argv, argc, &map);\n}\n\nstatic u64\nnvkm_vram_size(struct nvkm_memory *memory)\n{\n\treturn (u64)nvkm_mm_size(nvkm_vram(memory)->mn) << NVKM_RAM_MM_SHIFT;\n}\n\nstatic u64\nnvkm_vram_addr(struct nvkm_memory *memory)\n{\n\tstruct nvkm_vram *vram = nvkm_vram(memory);\n\tif (!nvkm_mm_contiguous(vram->mn))\n\t\treturn ~0ULL;\n\treturn (u64)nvkm_mm_addr(vram->mn) << NVKM_RAM_MM_SHIFT;\n}\n\nstatic u8\nnvkm_vram_page(struct nvkm_memory *memory)\n{\n\treturn nvkm_vram(memory)->page;\n}\n\nstatic enum nvkm_memory_target\nnvkm_vram_target(struct nvkm_memory *memory)\n{\n\treturn NVKM_MEM_TARGET_VRAM;\n}\n\nstatic void *\nnvkm_vram_dtor(struct nvkm_memory *memory)\n{\n\tstruct nvkm_vram *vram = nvkm_vram(memory);\n\tstruct nvkm_mm_node *next = vram->mn;\n\tstruct nvkm_mm_node *node;\n\tmutex_lock(&vram->ram->mutex);\n\twhile ((node = next)) {\n\t\tnext = node->next;\n\t\tnvkm_mm_free(&vram->ram->vram, &node);\n\t}\n\tmutex_unlock(&vram->ram->mutex);\n\treturn vram;\n}\n\nstatic const struct nvkm_memory_func\nnvkm_vram = {\n\t.dtor = nvkm_vram_dtor,\n\t.target = nvkm_vram_target,\n\t.page = nvkm_vram_page,\n\t.addr = nvkm_vram_addr,\n\t.size = nvkm_vram_size,\n\t.map = nvkm_vram_map,\n\t.kmap = nvkm_vram_kmap,\n};\n\nint\nnvkm_ram_get(struct nvkm_device *device, u8 heap, u8 type, u8 rpage, u64 size,\n\t     bool contig, bool back, struct nvkm_memory **pmemory)\n{\n\tstruct nvkm_ram *ram;\n\tstruct nvkm_mm *mm;\n\tstruct nvkm_mm_node **node, *r;\n\tstruct nvkm_vram *vram;\n\tu8   page = max(rpage, (u8)NVKM_RAM_MM_SHIFT);\n\tu32 align = (1 << page) >> NVKM_RAM_MM_SHIFT;\n\tu32   max = ALIGN(size, 1 << page) >> NVKM_RAM_MM_SHIFT;\n\tu32   min = contig ? max : align;\n\tint ret;\n\n\tif (!device->fb || !(ram = device->fb->ram))\n\t\treturn -ENODEV;\n\tram = device->fb->ram;\n\tmm = &ram->vram;\n\n\tif (!(vram = kzalloc(sizeof(*vram), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_memory_ctor(&nvkm_vram, &vram->memory);\n\tvram->ram = ram;\n\tvram->page = page;\n\t*pmemory = &vram->memory;\n\n\tmutex_lock(&ram->mutex);\n\tnode = &vram->mn;\n\tdo {\n\t\tif (back)\n\t\t\tret = nvkm_mm_tail(mm, heap, type, max, min, align, &r);\n\t\telse\n\t\t\tret = nvkm_mm_head(mm, heap, type, max, min, align, &r);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&ram->mutex);\n\t\t\tnvkm_memory_unref(pmemory);\n\t\t\treturn ret;\n\t\t}\n\n\t\t*node = r;\n\t\tnode = &r->next;\n\t\tmax -= r->length;\n\t} while (max);\n\tmutex_unlock(&ram->mutex);\n\treturn 0;\n}\n\nint\nnvkm_ram_init(struct nvkm_ram *ram)\n{\n\tif (ram->func->init)\n\t\treturn ram->func->init(ram);\n\treturn 0;\n}\n\nvoid\nnvkm_ram_del(struct nvkm_ram **pram)\n{\n\tstruct nvkm_ram *ram = *pram;\n\tif (ram && !WARN_ON(!ram->func)) {\n\t\tif (ram->func->dtor)\n\t\t\t*pram = ram->func->dtor(ram);\n\t\tnvkm_mm_fini(&ram->vram);\n\t\tmutex_destroy(&ram->mutex);\n\t\tkfree(*pram);\n\t\t*pram = NULL;\n\t}\n}\n\nint\nnvkm_ram_ctor(const struct nvkm_ram_func *func, struct nvkm_fb *fb,\n\t      enum nvkm_ram_type type, u64 size, struct nvkm_ram *ram)\n{\n\tstatic const char *name[] = {\n\t\t[NVKM_RAM_TYPE_UNKNOWN] = \"of unknown memory type\",\n\t\t[NVKM_RAM_TYPE_STOLEN ] = \"stolen system memory\",\n\t\t[NVKM_RAM_TYPE_SGRAM  ] = \"SGRAM\",\n\t\t[NVKM_RAM_TYPE_SDRAM  ] = \"SDRAM\",\n\t\t[NVKM_RAM_TYPE_DDR1   ] = \"DDR1\",\n\t\t[NVKM_RAM_TYPE_DDR2   ] = \"DDR2\",\n\t\t[NVKM_RAM_TYPE_DDR3   ] = \"DDR3\",\n\t\t[NVKM_RAM_TYPE_GDDR2  ] = \"GDDR2\",\n\t\t[NVKM_RAM_TYPE_GDDR3  ] = \"GDDR3\",\n\t\t[NVKM_RAM_TYPE_GDDR4  ] = \"GDDR4\",\n\t\t[NVKM_RAM_TYPE_GDDR5  ] = \"GDDR5\",\n\t\t[NVKM_RAM_TYPE_GDDR5X ] = \"GDDR5X\",\n\t\t[NVKM_RAM_TYPE_GDDR6  ] = \"GDDR6\",\n\t\t[NVKM_RAM_TYPE_HBM2   ] = \"HBM2\",\n\t};\n\tstruct nvkm_subdev *subdev = &fb->subdev;\n\tint ret;\n\n\tnvkm_info(subdev, \"%d MiB %s\\n\", (int)(size >> 20), name[type]);\n\tram->func = func;\n\tram->fb = fb;\n\tram->type = type;\n\tram->size = size;\n\tmutex_init(&ram->mutex);\n\n\tif (!nvkm_mm_initialised(&ram->vram)) {\n\t\tret = nvkm_mm_init(&ram->vram, NVKM_RAM_MM_NORMAL, 0,\n\t\t\t\t   size >> NVKM_RAM_MM_SHIFT, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint\nnvkm_ram_new_(const struct nvkm_ram_func *func, struct nvkm_fb *fb,\n\t      enum nvkm_ram_type type, u64 size, struct nvkm_ram **pram)\n{\n\tif (!(*pram = kzalloc(sizeof(**pram), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_ram_ctor(func, fb, type, size, *pram);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}