{
  "module_name": "base.c",
  "hash_id": "bd032e01e6c8ede2cc30018348275aa93dad5cd870b19a3d180cec47cec528f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mxm/base.c",
  "human_readable_source": " \n#include \"mxms.h\"\n\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/mxm.h>\n#include <subdev/i2c.h>\n\nstatic bool\nmxm_shadow_rom_fetch(struct nvkm_i2c_bus *bus, u8 addr,\n\t\t     u8 offset, u8 size, u8 *data)\n{\n\tstruct i2c_msg msgs[] = {\n\t\t{ .addr = addr, .flags = 0, .len = 1, .buf = &offset },\n\t\t{ .addr = addr, .flags = I2C_M_RD, .len = size, .buf = data, },\n\t};\n\n\treturn i2c_transfer(&bus->i2c, msgs, 2) == 2;\n}\n\nstatic bool\nmxm_shadow_rom(struct nvkm_mxm *mxm, u8 version)\n{\n\tstruct nvkm_device *device = mxm->subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvkm_i2c *i2c = device->i2c;\n\tstruct nvkm_i2c_bus *bus = NULL;\n\tu8 i2cidx, mxms[6], addr, size;\n\n\ti2cidx = mxm_ddc_map(bios, 1  ) & 0x0f;\n\tif (i2cidx < 0x0f)\n\t\tbus = nvkm_i2c_bus_find(i2c, i2cidx);\n\tif (!bus)\n\t\treturn false;\n\n\taddr = 0x54;\n\tif (!mxm_shadow_rom_fetch(bus, addr, 0, 6, mxms)) {\n\t\taddr = 0x56;\n\t\tif (!mxm_shadow_rom_fetch(bus, addr, 0, 6, mxms))\n\t\t\treturn false;\n\t}\n\n\tmxm->mxms = mxms;\n\tsize = mxms_headerlen(mxm) + mxms_structlen(mxm);\n\tmxm->mxms = kmalloc(size, GFP_KERNEL);\n\n\tif (mxm->mxms &&\n\t    mxm_shadow_rom_fetch(bus, addr, 0, size, mxm->mxms))\n\t\treturn true;\n\n\tkfree(mxm->mxms);\n\tmxm->mxms = NULL;\n\treturn false;\n}\n\n#if defined(CONFIG_ACPI)\nstatic bool\nmxm_shadow_dsm(struct nvkm_mxm *mxm, u8 version)\n{\n\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstatic guid_t muid =\n\t\tGUID_INIT(0x4004A400, 0x917D, 0x4CF2,\n\t\t\t  0xB8, 0x9C, 0x79, 0xB6, 0x2F, 0xD5, 0x56, 0x65);\n\tu32 mxms_args[] = { 0x00000000 };\n\tunion acpi_object argv4 = {\n\t\t.buffer.type = ACPI_TYPE_BUFFER,\n\t\t.buffer.length = sizeof(mxms_args),\n\t\t.buffer.pointer = (char *)mxms_args,\n\t};\n\tunion acpi_object *obj;\n\tacpi_handle handle;\n\tint rev;\n\n\thandle = ACPI_HANDLE(device->dev);\n\tif (!handle)\n\t\treturn false;\n\n\t \n\trev = (version & 0xf0) << 4 | (version & 0x0f);\n\tobj = acpi_evaluate_dsm(handle, &muid, rev, 0x00000010, &argv4);\n\tif (!obj) {\n\t\tnvkm_debug(subdev, \"DSM MXMS failed\\n\");\n\t\treturn false;\n\t}\n\n\tif (obj->type == ACPI_TYPE_BUFFER) {\n\t\tmxm->mxms = kmemdup(obj->buffer.pointer,\n\t\t\t\t\t obj->buffer.length, GFP_KERNEL);\n\t} else if (obj->type == ACPI_TYPE_INTEGER) {\n\t\tnvkm_debug(subdev, \"DSM MXMS returned 0x%llx\\n\",\n\t\t\t   obj->integer.value);\n\t}\n\n\tACPI_FREE(obj);\n\treturn mxm->mxms != NULL;\n}\n#endif\n\n#if defined(CONFIG_ACPI_WMI) || defined(CONFIG_ACPI_WMI_MODULE)\n\n#define WMI_WMMX_GUID \"F6CB5C3C-9CAE-4EBD-B577-931EA32A2CC0\"\n\nstatic u8\nwmi_wmmx_mxmi(struct nvkm_mxm *mxm, u8 version)\n{\n\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tu32 mxmi_args[] = { 0x494D584D  , version, 0 };\n\tstruct acpi_buffer args = { sizeof(mxmi_args), mxmi_args };\n\tstruct acpi_buffer retn = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tstatus = wmi_evaluate_method(WMI_WMMX_GUID, 0, 0, &args, &retn);\n\tif (ACPI_FAILURE(status)) {\n\t\tnvkm_debug(subdev, \"WMMX MXMI returned %d\\n\", status);\n\t\treturn 0x00;\n\t}\n\n\tobj = retn.pointer;\n\tif (obj->type == ACPI_TYPE_INTEGER) {\n\t\tversion = obj->integer.value;\n\t\tnvkm_debug(subdev, \"WMMX MXMI version %d.%d\\n\",\n\t\t\t   (version >> 4), version & 0x0f);\n\t} else {\n\t\tversion = 0;\n\t\tnvkm_debug(subdev, \"WMMX MXMI returned non-integer\\n\");\n\t}\n\n\tkfree(obj);\n\treturn version;\n}\n\nstatic bool\nmxm_shadow_wmi(struct nvkm_mxm *mxm, u8 version)\n{\n\tstruct nvkm_subdev *subdev = &mxm->subdev;\n\tu32 mxms_args[] = { 0x534D584D  , version, 0 };\n\tstruct acpi_buffer args = { sizeof(mxms_args), mxms_args };\n\tstruct acpi_buffer retn = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *obj;\n\tacpi_status status;\n\n\tif (!wmi_has_guid(WMI_WMMX_GUID)) {\n\t\tnvkm_debug(subdev, \"WMMX GUID not found\\n\");\n\t\treturn false;\n\t}\n\n\tmxms_args[1] = wmi_wmmx_mxmi(mxm, 0x00);\n\tif (!mxms_args[1])\n\t\tmxms_args[1] = wmi_wmmx_mxmi(mxm, version);\n\tif (!mxms_args[1])\n\t\treturn false;\n\n\tstatus = wmi_evaluate_method(WMI_WMMX_GUID, 0, 0, &args, &retn);\n\tif (ACPI_FAILURE(status)) {\n\t\tnvkm_debug(subdev, \"WMMX MXMS returned %d\\n\", status);\n\t\treturn false;\n\t}\n\n\tobj = retn.pointer;\n\tif (obj->type == ACPI_TYPE_BUFFER) {\n\t\tmxm->mxms = kmemdup(obj->buffer.pointer,\n\t\t\t\t    obj->buffer.length, GFP_KERNEL);\n\t}\n\n\tkfree(obj);\n\treturn mxm->mxms != NULL;\n}\n#endif\n\nstatic struct mxm_shadow_h {\n\tconst char *name;\n\tbool (*exec)(struct nvkm_mxm *, u8 version);\n} _mxm_shadow[] = {\n\t{ \"ROM\", mxm_shadow_rom },\n#if defined(CONFIG_ACPI)\n\t{ \"DSM\", mxm_shadow_dsm },\n#endif\n#if defined(CONFIG_ACPI_WMI) || defined(CONFIG_ACPI_WMI_MODULE)\n\t{ \"WMI\", mxm_shadow_wmi },\n#endif\n\t{}\n};\n\nstatic int\nmxm_shadow(struct nvkm_mxm *mxm, u8 version)\n{\n\tstruct mxm_shadow_h *shadow = _mxm_shadow;\n\tdo {\n\t\tnvkm_debug(&mxm->subdev, \"checking %s\\n\", shadow->name);\n\t\tif (shadow->exec(mxm, version)) {\n\t\t\tif (mxms_valid(mxm))\n\t\t\t\treturn 0;\n\t\t\tkfree(mxm->mxms);\n\t\t\tmxm->mxms = NULL;\n\t\t}\n\t} while ((++shadow)->name);\n\treturn -ENOENT;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_mxm = {\n};\n\nint\nnvkm_mxm_new_(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_mxm **pmxm)\n{\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvkm_mxm *mxm;\n\tu8  ver, len;\n\tu16 data;\n\n\tif (!(mxm = *pmxm = kzalloc(sizeof(*mxm), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_subdev_ctor(&nvkm_mxm, device, type, inst, &mxm->subdev);\n\n\tdata = mxm_table(bios, &ver, &len);\n\tif (!data || !(ver = nvbios_rd08(bios, data))) {\n\t\tnvkm_debug(&mxm->subdev, \"no VBIOS data, nothing to do\\n\");\n\t\treturn 0;\n\t}\n\n\tnvkm_info(&mxm->subdev, \"BIOS version %d.%d\\n\", ver >> 4, ver & 0x0f);\n\tnvkm_debug(&mxm->subdev, \"module flags: %02x\\n\",\n\t\t   nvbios_rd08(bios, data + 0x01));\n\tnvkm_debug(&mxm->subdev, \"config flags: %02x\\n\",\n\t\t   nvbios_rd08(bios, data + 0x02));\n\n\tif (mxm_shadow(mxm, ver)) {\n\t\tnvkm_warn(&mxm->subdev, \"failed to locate valid SIS\\n\");\n#if 0\n\t\t \n\t\treturn -EINVAL;\n#else\n\t\treturn 0;\n#endif\n\t}\n\n\tnvkm_debug(&mxm->subdev, \"MXMS Version %d.%d\\n\",\n\t\t   mxms_version(mxm) >> 8, mxms_version(mxm) & 0xff);\n\tmxms_foreach(mxm, 0, NULL, NULL);\n\n\tif (nvkm_boolopt(device->cfgopt, \"NvMXMDCB\", true))\n\t\tmxm->action |= MXM_SANITISE_DCB;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}