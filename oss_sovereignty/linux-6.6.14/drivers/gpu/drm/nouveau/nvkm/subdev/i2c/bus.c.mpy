{
  "module_name": "bus.c",
  "hash_id": "6daafeeea17753e270cff7ccd79b1edab0397c06659800d46b717cab9246cc63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/bus.c",
  "human_readable_source": " \n#include \"bus.h\"\n#include \"pad.h\"\n\n#include <core/option.h>\n\n \nstatic int\nnvkm_i2c_bus_pre_xfer(struct i2c_adapter *adap)\n{\n\tstruct nvkm_i2c_bus *bus = container_of(adap, typeof(*bus), i2c);\n\treturn nvkm_i2c_bus_acquire(bus);\n}\n\nstatic void\nnvkm_i2c_bus_post_xfer(struct i2c_adapter *adap)\n{\n\tstruct nvkm_i2c_bus *bus = container_of(adap, typeof(*bus), i2c);\n\treturn nvkm_i2c_bus_release(bus);\n}\n\nstatic void\nnvkm_i2c_bus_setscl(void *data, int state)\n{\n\tstruct nvkm_i2c_bus *bus = data;\n\tbus->func->drive_scl(bus, state);\n}\n\nstatic void\nnvkm_i2c_bus_setsda(void *data, int state)\n{\n\tstruct nvkm_i2c_bus *bus = data;\n\tbus->func->drive_sda(bus, state);\n}\n\nstatic int\nnvkm_i2c_bus_getscl(void *data)\n{\n\tstruct nvkm_i2c_bus *bus = data;\n\treturn bus->func->sense_scl(bus);\n}\n\nstatic int\nnvkm_i2c_bus_getsda(void *data)\n{\n\tstruct nvkm_i2c_bus *bus = data;\n\treturn bus->func->sense_sda(bus);\n}\n\n \nstatic int\nnvkm_i2c_bus_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\n{\n\tstruct nvkm_i2c_bus *bus = container_of(adap, typeof(*bus), i2c);\n\tint ret;\n\n\tret = nvkm_i2c_bus_acquire(bus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bus->func->xfer(bus, msgs, num);\n\tnvkm_i2c_bus_release(bus);\n\treturn ret;\n}\n\nstatic u32\nnvkm_i2c_bus_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm\nnvkm_i2c_bus_algo = {\n\t.master_xfer = nvkm_i2c_bus_xfer,\n\t.functionality = nvkm_i2c_bus_func,\n};\n\n \nvoid\nnvkm_i2c_bus_init(struct nvkm_i2c_bus *bus)\n{\n\tBUS_TRACE(bus, \"init\");\n\tif (bus->func->init)\n\t\tbus->func->init(bus);\n\n\tmutex_lock(&bus->mutex);\n\tbus->enabled = true;\n\tmutex_unlock(&bus->mutex);\n}\n\nvoid\nnvkm_i2c_bus_fini(struct nvkm_i2c_bus *bus)\n{\n\tBUS_TRACE(bus, \"fini\");\n\tmutex_lock(&bus->mutex);\n\tbus->enabled = false;\n\tmutex_unlock(&bus->mutex);\n}\n\nvoid\nnvkm_i2c_bus_release(struct nvkm_i2c_bus *bus)\n{\n\tstruct nvkm_i2c_pad *pad = bus->pad;\n\tBUS_TRACE(bus, \"release\");\n\tnvkm_i2c_pad_release(pad);\n\tmutex_unlock(&bus->mutex);\n}\n\nint\nnvkm_i2c_bus_acquire(struct nvkm_i2c_bus *bus)\n{\n\tstruct nvkm_i2c_pad *pad = bus->pad;\n\tint ret;\n\n\tBUS_TRACE(bus, \"acquire\");\n\tmutex_lock(&bus->mutex);\n\n\tif (bus->enabled)\n\t\tret = nvkm_i2c_pad_acquire(pad, NVKM_I2C_PAD_I2C);\n\telse\n\t\tret = -EIO;\n\n\tif (ret)\n\t\tmutex_unlock(&bus->mutex);\n\treturn ret;\n}\n\nint\nnvkm_i2c_bus_probe(struct nvkm_i2c_bus *bus, const char *what,\n\t\t   struct nvkm_i2c_bus_probe *info,\n\t\t   bool (*match)(struct nvkm_i2c_bus *,\n\t\t\t\t struct i2c_board_info *, void *), void *data)\n{\n\tint i;\n\n\tBUS_DBG(bus, \"probing %ss\", what);\n\tfor (i = 0; info[i].dev.addr; i++) {\n\t\tu8 orig_udelay = 0;\n\n\t\tif ((bus->i2c.algo == &i2c_bit_algo) && (info[i].udelay != 0)) {\n\t\t\tstruct i2c_algo_bit_data *algo = bus->i2c.algo_data;\n\t\t\tBUS_DBG(bus, \"%dms delay instead of %dms\",\n\t\t\t\t     info[i].udelay, algo->udelay);\n\t\t\torig_udelay = algo->udelay;\n\t\t\talgo->udelay = info[i].udelay;\n\t\t}\n\n\t\tif (nvkm_probe_i2c(&bus->i2c, info[i].dev.addr) &&\n\t\t    (!match || match(bus, &info[i].dev, data))) {\n\t\t\tBUS_DBG(bus, \"detected %s: %s\",\n\t\t\t\twhat, info[i].dev.type);\n\t\t\treturn i;\n\t\t}\n\n\t\tif (orig_udelay) {\n\t\t\tstruct i2c_algo_bit_data *algo = bus->i2c.algo_data;\n\t\t\talgo->udelay = orig_udelay;\n\t\t}\n\t}\n\n\tBUS_DBG(bus, \"no devices found.\");\n\treturn -ENODEV;\n}\n\nvoid\nnvkm_i2c_bus_del(struct nvkm_i2c_bus **pbus)\n{\n\tstruct nvkm_i2c_bus *bus = *pbus;\n\tif (bus && !WARN_ON(!bus->func)) {\n\t\tBUS_TRACE(bus, \"dtor\");\n\t\tlist_del(&bus->head);\n\t\ti2c_del_adapter(&bus->i2c);\n\t\tkfree(bus->i2c.algo_data);\n\t\tkfree(*pbus);\n\t\t*pbus = NULL;\n\t}\n}\n\nint\nnvkm_i2c_bus_ctor(const struct nvkm_i2c_bus_func *func,\n\t\t  struct nvkm_i2c_pad *pad, int id,\n\t\t  struct nvkm_i2c_bus *bus)\n{\n\tstruct nvkm_device *device = pad->i2c->subdev.device;\n\tstruct i2c_algo_bit_data *bit;\n#ifndef CONFIG_NOUVEAU_I2C_INTERNAL_DEFAULT\n\tconst bool internal = false;\n#else\n\tconst bool internal = true;\n#endif\n\tint ret;\n\n\tbus->func = func;\n\tbus->pad = pad;\n\tbus->id = id;\n\tmutex_init(&bus->mutex);\n\tlist_add_tail(&bus->head, &pad->i2c->bus);\n\tBUS_TRACE(bus, \"ctor\");\n\n\tsnprintf(bus->i2c.name, sizeof(bus->i2c.name), \"nvkm-%s-bus-%04x\",\n\t\t dev_name(device->dev), id);\n\tbus->i2c.owner = THIS_MODULE;\n\tbus->i2c.dev.parent = device->dev;\n\n\tif ( bus->func->drive_scl &&\n\t    !nvkm_boolopt(device->cfgopt, \"NvI2C\", internal)) {\n\t\tif (!(bit = kzalloc(sizeof(*bit), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tbit->udelay = 10;\n\t\tbit->timeout = usecs_to_jiffies(2200);\n\t\tbit->data = bus;\n\t\tbit->pre_xfer = nvkm_i2c_bus_pre_xfer;\n\t\tbit->post_xfer = nvkm_i2c_bus_post_xfer;\n\t\tbit->setscl = nvkm_i2c_bus_setscl;\n\t\tbit->setsda = nvkm_i2c_bus_setsda;\n\t\tbit->getscl = nvkm_i2c_bus_getscl;\n\t\tbit->getsda = nvkm_i2c_bus_getsda;\n\t\tbus->i2c.algo_data = bit;\n\t\tret = i2c_bit_add_bus(&bus->i2c);\n\t} else {\n\t\tbus->i2c.algo = &nvkm_i2c_bus_algo;\n\t\tret = i2c_add_adapter(&bus->i2c);\n\t}\n\n\treturn ret;\n}\n\nint\nnvkm_i2c_bus_new_(const struct nvkm_i2c_bus_func *func,\n\t\t  struct nvkm_i2c_pad *pad, int id,\n\t\t  struct nvkm_i2c_bus **pbus)\n{\n\tif (!(*pbus = kzalloc(sizeof(**pbus), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_i2c_bus_ctor(func, pad, id, *pbus);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}