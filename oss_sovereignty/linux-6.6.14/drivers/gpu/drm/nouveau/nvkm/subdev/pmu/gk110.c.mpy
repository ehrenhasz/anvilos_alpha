{
  "module_name": "gk110.c",
  "hash_id": "d806bd9a3fd530c1ef77a7e39398c0cc99d39d8f03d76d2db8986daec9cc3bef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gk110.c",
  "human_readable_source": " \n#define gf119_pmu_code gk110_pmu_code\n#define gf119_pmu_data gk110_pmu_data\n#include \"priv.h\"\n#include \"fuc/gf119.fuc4.h\"\n\n#include <subdev/timer.h>\n\nvoid\ngk110_pmu_pgob(struct nvkm_pmu *pmu, bool enable)\n{\n\tstruct nvkm_device *device = pmu->subdev.device;\n\tstatic const struct {\n\t\tu32 addr;\n\t\tu32 data;\n\t} magic[] = {\n\t\t{ 0x020520, 0xfffffffc },\n\t\t{ 0x020524, 0xfffffffe },\n\t\t{ 0x020524, 0xfffffffc },\n\t\t{ 0x020524, 0xfffffff8 },\n\t\t{ 0x020524, 0xffffffe0 },\n\t\t{ 0x020530, 0xfffffffe },\n\t\t{ 0x02052c, 0xfffffffa },\n\t\t{ 0x02052c, 0xfffffff0 },\n\t\t{ 0x02052c, 0xffffffc0 },\n\t\t{ 0x02052c, 0xffffff00 },\n\t\t{ 0x02052c, 0xfffffc00 },\n\t\t{ 0x02052c, 0xfffcfc00 },\n\t\t{ 0x02052c, 0xfff0fc00 },\n\t\t{ 0x02052c, 0xff80fc00 },\n\t\t{ 0x020528, 0xfffffffe },\n\t\t{ 0x020528, 0xfffffffc },\n\t};\n\tint i;\n\n\tnvkm_mask(device, 0x000200, 0x00001000, 0x00000000);\n\tnvkm_rd32(device, 0x000200);\n\tnvkm_mask(device, 0x000200, 0x08000000, 0x08000000);\n\tmsleep(50);\n\n\tnvkm_mask(device, 0x10a78c, 0x00000002, 0x00000002);\n\tnvkm_mask(device, 0x10a78c, 0x00000001, 0x00000001);\n\tnvkm_mask(device, 0x10a78c, 0x00000001, 0x00000000);\n\n\tnvkm_mask(device, 0x0206b4, 0x00000000, 0x00000000);\n\tfor (i = 0; i < ARRAY_SIZE(magic); i++) {\n\t\tnvkm_wr32(device, magic[i].addr, magic[i].data);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, magic[i].addr) & 0x80000000))\n\t\t\t\tbreak;\n\t\t);\n\t}\n\n\tnvkm_mask(device, 0x10a78c, 0x00000002, 0x00000000);\n\tnvkm_mask(device, 0x10a78c, 0x00000001, 0x00000001);\n\tnvkm_mask(device, 0x10a78c, 0x00000001, 0x00000000);\n\n\tnvkm_mask(device, 0x000200, 0x08000000, 0x00000000);\n\tnvkm_mask(device, 0x000200, 0x00001000, 0x00001000);\n\tnvkm_rd32(device, 0x000200);\n}\n\nstatic const struct nvkm_pmu_func\ngk110_pmu = {\n\t.flcn = &gt215_pmu_flcn,\n\t.code.data = gk110_pmu_code,\n\t.code.size = sizeof(gk110_pmu_code),\n\t.data.data = gk110_pmu_data,\n\t.data.size = sizeof(gk110_pmu_data),\n\t.enabled = gf100_pmu_enabled,\n\t.reset = gf100_pmu_reset,\n\t.init = gt215_pmu_init,\n\t.fini = gt215_pmu_fini,\n\t.intr = gt215_pmu_intr,\n\t.send = gt215_pmu_send,\n\t.recv = gt215_pmu_recv,\n\t.pgob = gk110_pmu_pgob,\n};\n\nstatic const struct nvkm_pmu_fwif\ngk110_pmu_fwif[] = {\n\t{ -1, gf100_pmu_nofw, &gk110_pmu },\n\t{}\n};\n\nint\ngk110_pmu_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_pmu **ppmu)\n{\n\treturn nvkm_pmu_new_(gk110_pmu_fwif, device, type, inst, ppmu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}