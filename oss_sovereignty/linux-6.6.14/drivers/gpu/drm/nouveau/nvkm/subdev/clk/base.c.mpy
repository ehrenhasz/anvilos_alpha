{
  "module_name": "base.c",
  "hash_id": "ff6900a0354da52e3f75505ac3c151ebcb90f671f9ba1295da9ed5a49f3ebc50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/boost.h>\n#include <subdev/bios/cstep.h>\n#include <subdev/bios/perf.h>\n#include <subdev/bios/vpstate.h>\n#include <subdev/fb.h>\n#include <subdev/therm.h>\n#include <subdev/volt.h>\n\n#include <core/option.h>\n\n \nstatic u32\nnvkm_clk_adjust(struct nvkm_clk *clk, bool adjust,\n\t\tu8 pstate, u8 domain, u32 input)\n{\n\tstruct nvkm_bios *bios = clk->subdev.device->bios;\n\tstruct nvbios_boostE boostE;\n\tu8  ver, hdr, cnt, len;\n\tu32 data;\n\n\tdata = nvbios_boostEm(bios, pstate, &ver, &hdr, &cnt, &len, &boostE);\n\tif (data) {\n\t\tstruct nvbios_boostS boostS;\n\t\tu8  idx = 0, sver, shdr;\n\t\tu32 subd;\n\n\t\tinput = max(boostE.min, input);\n\t\tinput = min(boostE.max, input);\n\t\tdo {\n\t\t\tsver = ver;\n\t\t\tshdr = hdr;\n\t\t\tsubd = nvbios_boostSp(bios, idx++, data, &sver, &shdr,\n\t\t\t\t\t      cnt, len, &boostS);\n\t\t\tif (subd && boostS.domain == domain) {\n\t\t\t\tif (adjust)\n\t\t\t\t\tinput = input * boostS.percent / 100;\n\t\t\t\tinput = max(boostS.min, input);\n\t\t\t\tinput = min(boostS.max, input);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (subd);\n\t}\n\n\treturn input;\n}\n\n \nstatic bool\nnvkm_cstate_valid(struct nvkm_clk *clk, struct nvkm_cstate *cstate,\n\t\t  u32 max_volt, int temp)\n{\n\tconst struct nvkm_domain *domain = clk->domains;\n\tstruct nvkm_volt *volt = clk->subdev.device->volt;\n\tint voltage;\n\n\twhile (domain && domain->name != nv_clk_src_max) {\n\t\tif (domain->flags & NVKM_CLK_DOM_FLAG_VPSTATE) {\n\t\t\tu32 freq = cstate->domain[domain->name];\n\t\t\tswitch (clk->boost_mode) {\n\t\t\tcase NVKM_CLK_BOOST_NONE:\n\t\t\t\tif (clk->base_khz && freq > clk->base_khz)\n\t\t\t\t\treturn false;\n\t\t\t\tfallthrough;\n\t\t\tcase NVKM_CLK_BOOST_BIOS:\n\t\t\t\tif (clk->boost_khz && freq > clk->boost_khz)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tdomain++;\n\t}\n\n\tif (!volt)\n\t\treturn true;\n\n\tvoltage = nvkm_volt_map(volt, cstate->voltage, temp);\n\tif (voltage < 0)\n\t\treturn false;\n\treturn voltage <= min(max_volt, volt->max_uv);\n}\n\nstatic struct nvkm_cstate *\nnvkm_cstate_find_best(struct nvkm_clk *clk, struct nvkm_pstate *pstate,\n\t\t      struct nvkm_cstate *cstate)\n{\n\tstruct nvkm_device *device = clk->subdev.device;\n\tstruct nvkm_volt *volt = device->volt;\n\tint max_volt;\n\n\tif (!pstate || !cstate)\n\t\treturn NULL;\n\n\tif (!volt)\n\t\treturn cstate;\n\n\tmax_volt = volt->max_uv;\n\tif (volt->max0_id != 0xff)\n\t\tmax_volt = min(max_volt,\n\t\t\t       nvkm_volt_map(volt, volt->max0_id, clk->temp));\n\tif (volt->max1_id != 0xff)\n\t\tmax_volt = min(max_volt,\n\t\t\t       nvkm_volt_map(volt, volt->max1_id, clk->temp));\n\tif (volt->max2_id != 0xff)\n\t\tmax_volt = min(max_volt,\n\t\t\t       nvkm_volt_map(volt, volt->max2_id, clk->temp));\n\n\tlist_for_each_entry_from_reverse(cstate, &pstate->list, head) {\n\t\tif (nvkm_cstate_valid(clk, cstate, max_volt, clk->temp))\n\t\t\treturn cstate;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct nvkm_cstate *\nnvkm_cstate_get(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)\n{\n\tstruct nvkm_cstate *cstate;\n\tif (cstatei == NVKM_CLK_CSTATE_HIGHEST)\n\t\treturn list_last_entry(&pstate->list, typeof(*cstate), head);\n\telse {\n\t\tlist_for_each_entry(cstate, &pstate->list, head) {\n\t\t\tif (cstate->id == cstatei)\n\t\t\t\treturn cstate;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int\nnvkm_cstate_prog(struct nvkm_clk *clk, struct nvkm_pstate *pstate, int cstatei)\n{\n\tstruct nvkm_subdev *subdev = &clk->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_therm *therm = device->therm;\n\tstruct nvkm_volt *volt = device->volt;\n\tstruct nvkm_cstate *cstate;\n\tint ret;\n\n\tif (!list_empty(&pstate->list)) {\n\t\tcstate = nvkm_cstate_get(clk, pstate, cstatei);\n\t\tcstate = nvkm_cstate_find_best(clk, pstate, cstate);\n\t\tif (!cstate)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tcstate = &pstate->base;\n\t}\n\n\tif (therm) {\n\t\tret = nvkm_therm_cstate(therm, pstate->fanspeed, +1);\n\t\tif (ret && ret != -ENODEV) {\n\t\t\tnvkm_error(subdev, \"failed to raise fan speed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (volt) {\n\t\tret = nvkm_volt_set_id(volt, cstate->voltage,\n\t\t\t\t       pstate->base.voltage, clk->temp, +1);\n\t\tif (ret && ret != -ENODEV) {\n\t\t\tnvkm_error(subdev, \"failed to raise voltage: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = clk->func->calc(clk, cstate);\n\tif (ret == 0) {\n\t\tret = clk->func->prog(clk);\n\t\tclk->func->tidy(clk);\n\t}\n\n\tif (volt) {\n\t\tret = nvkm_volt_set_id(volt, cstate->voltage,\n\t\t\t\t       pstate->base.voltage, clk->temp, -1);\n\t\tif (ret && ret != -ENODEV)\n\t\t\tnvkm_error(subdev, \"failed to lower voltage: %d\\n\", ret);\n\t}\n\n\tif (therm) {\n\t\tret = nvkm_therm_cstate(therm, pstate->fanspeed, -1);\n\t\tif (ret && ret != -ENODEV)\n\t\t\tnvkm_error(subdev, \"failed to lower fan speed: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void\nnvkm_cstate_del(struct nvkm_cstate *cstate)\n{\n\tlist_del(&cstate->head);\n\tkfree(cstate);\n}\n\nstatic int\nnvkm_cstate_new(struct nvkm_clk *clk, int idx, struct nvkm_pstate *pstate)\n{\n\tstruct nvkm_bios *bios = clk->subdev.device->bios;\n\tstruct nvkm_volt *volt = clk->subdev.device->volt;\n\tconst struct nvkm_domain *domain = clk->domains;\n\tstruct nvkm_cstate *cstate = NULL;\n\tstruct nvbios_cstepX cstepX;\n\tu8  ver, hdr;\n\tu32 data;\n\n\tdata = nvbios_cstepXp(bios, idx, &ver, &hdr, &cstepX);\n\tif (!data)\n\t\treturn -ENOENT;\n\n\tif (volt && nvkm_volt_map_min(volt, cstepX.voltage) > volt->max_uv)\n\t\treturn -EINVAL;\n\n\tcstate = kzalloc(sizeof(*cstate), GFP_KERNEL);\n\tif (!cstate)\n\t\treturn -ENOMEM;\n\n\t*cstate = pstate->base;\n\tcstate->voltage = cstepX.voltage;\n\tcstate->id = idx;\n\n\twhile (domain && domain->name != nv_clk_src_max) {\n\t\tif (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {\n\t\t\tu32 freq = nvkm_clk_adjust(clk, true, pstate->pstate,\n\t\t\t\t\t\t   domain->bios, cstepX.freq);\n\t\t\tcstate->domain[domain->name] = freq;\n\t\t}\n\t\tdomain++;\n\t}\n\n\tlist_add(&cstate->head, &pstate->list);\n\treturn 0;\n}\n\n \nstatic int\nnvkm_pstate_prog(struct nvkm_clk *clk, int pstatei)\n{\n\tstruct nvkm_subdev *subdev = &clk->subdev;\n\tstruct nvkm_fb *fb = subdev->device->fb;\n\tstruct nvkm_pci *pci = subdev->device->pci;\n\tstruct nvkm_pstate *pstate;\n\tint ret, idx = 0;\n\n\tlist_for_each_entry(pstate, &clk->states, head) {\n\t\tif (idx++ == pstatei)\n\t\t\tbreak;\n\t}\n\n\tnvkm_debug(subdev, \"setting performance state %d\\n\", pstatei);\n\tclk->pstate = pstatei;\n\n\tnvkm_pcie_set_link(pci, pstate->pcie_speed, pstate->pcie_width);\n\n\tif (fb && fb->ram && fb->ram->func->calc) {\n\t\tstruct nvkm_ram *ram = fb->ram;\n\t\tint khz = pstate->base.domain[nv_clk_src_mem];\n\t\tdo {\n\t\t\tret = ram->func->calc(ram, khz);\n\t\t\tif (ret == 0)\n\t\t\t\tret = ram->func->prog(ram);\n\t\t} while (ret > 0);\n\t\tram->func->tidy(ram);\n\t}\n\n\treturn nvkm_cstate_prog(clk, pstate, NVKM_CLK_CSTATE_HIGHEST);\n}\n\nstatic void\nnvkm_pstate_work(struct work_struct *work)\n{\n\tstruct nvkm_clk *clk = container_of(work, typeof(*clk), work);\n\tstruct nvkm_subdev *subdev = &clk->subdev;\n\tint pstate;\n\n\tif (!atomic_xchg(&clk->waiting, 0))\n\t\treturn;\n\tclk->pwrsrc = power_supply_is_system_supplied();\n\n\tnvkm_trace(subdev, \"P %d PWR %d U(AC) %d U(DC) %d A %d T %d\u00b0C D %d\\n\",\n\t\t   clk->pstate, clk->pwrsrc, clk->ustate_ac, clk->ustate_dc,\n\t\t   clk->astate, clk->temp, clk->dstate);\n\n\tpstate = clk->pwrsrc ? clk->ustate_ac : clk->ustate_dc;\n\tif (clk->state_nr && pstate != -1) {\n\t\tpstate = (pstate < 0) ? clk->astate : pstate;\n\t\tpstate = min(pstate, clk->state_nr - 1);\n\t\tpstate = max(pstate, clk->dstate);\n\t} else {\n\t\tpstate = clk->pstate = -1;\n\t}\n\n\tnvkm_trace(subdev, \"-> %d\\n\", pstate);\n\tif (pstate != clk->pstate) {\n\t\tint ret = nvkm_pstate_prog(clk, pstate);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"error setting pstate %d: %d\\n\",\n\t\t\t\t   pstate, ret);\n\t\t}\n\t}\n\n\twake_up_all(&clk->wait);\n}\n\nstatic int\nnvkm_pstate_calc(struct nvkm_clk *clk, bool wait)\n{\n\tatomic_set(&clk->waiting, 1);\n\tschedule_work(&clk->work);\n\tif (wait)\n\t\twait_event(clk->wait, !atomic_read(&clk->waiting));\n\treturn 0;\n}\n\nstatic void\nnvkm_pstate_info(struct nvkm_clk *clk, struct nvkm_pstate *pstate)\n{\n\tconst struct nvkm_domain *clock = clk->domains - 1;\n\tstruct nvkm_cstate *cstate;\n\tstruct nvkm_subdev *subdev = &clk->subdev;\n\tchar info[3][32] = { \"\", \"\", \"\" };\n\tchar name[4] = \"--\";\n\tint i = -1;\n\n\tif (pstate->pstate != 0xff)\n\t\tsnprintf(name, sizeof(name), \"%02x\", pstate->pstate);\n\n\twhile ((++clock)->name != nv_clk_src_max) {\n\t\tu32 lo = pstate->base.domain[clock->name];\n\t\tu32 hi = lo;\n\t\tif (hi == 0)\n\t\t\tcontinue;\n\n\t\tnvkm_debug(subdev, \"%02x: %10d KHz\\n\", clock->name, lo);\n\t\tlist_for_each_entry(cstate, &pstate->list, head) {\n\t\t\tu32 freq = cstate->domain[clock->name];\n\t\t\tlo = min(lo, freq);\n\t\t\thi = max(hi, freq);\n\t\t\tnvkm_debug(subdev, \"%10d KHz\\n\", freq);\n\t\t}\n\n\t\tif (clock->mname && ++i < ARRAY_SIZE(info)) {\n\t\t\tlo /= clock->mdiv;\n\t\t\thi /= clock->mdiv;\n\t\t\tif (lo == hi) {\n\t\t\t\tsnprintf(info[i], sizeof(info[i]), \"%s %d MHz\",\n\t\t\t\t\t clock->mname, lo);\n\t\t\t} else {\n\t\t\t\tsnprintf(info[i], sizeof(info[i]),\n\t\t\t\t\t \"%s %d-%d MHz\", clock->mname, lo, hi);\n\t\t\t}\n\t\t}\n\t}\n\n\tnvkm_debug(subdev, \"%s: %s %s %s\\n\", name, info[0], info[1], info[2]);\n}\n\nstatic void\nnvkm_pstate_del(struct nvkm_pstate *pstate)\n{\n\tstruct nvkm_cstate *cstate, *temp;\n\n\tlist_for_each_entry_safe(cstate, temp, &pstate->list, head) {\n\t\tnvkm_cstate_del(cstate);\n\t}\n\n\tlist_del(&pstate->head);\n\tkfree(pstate);\n}\n\nstatic int\nnvkm_pstate_new(struct nvkm_clk *clk, int idx)\n{\n\tstruct nvkm_bios *bios = clk->subdev.device->bios;\n\tconst struct nvkm_domain *domain = clk->domains - 1;\n\tstruct nvkm_pstate *pstate;\n\tstruct nvkm_cstate *cstate;\n\tstruct nvbios_cstepE cstepE;\n\tstruct nvbios_perfE perfE;\n\tu8  ver, hdr, cnt, len;\n\tu32 data;\n\n\tdata = nvbios_perfEp(bios, idx, &ver, &hdr, &cnt, &len, &perfE);\n\tif (!data)\n\t\treturn -EINVAL;\n\tif (perfE.pstate == 0xff)\n\t\treturn 0;\n\n\tpstate = kzalloc(sizeof(*pstate), GFP_KERNEL);\n\tif (!pstate)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&pstate->list);\n\n\tpstate->pstate = perfE.pstate;\n\tpstate->fanspeed = perfE.fanspeed;\n\tpstate->pcie_speed = perfE.pcie_speed;\n\tpstate->pcie_width = perfE.pcie_width;\n\tcstate = &pstate->base;\n\tcstate->voltage = perfE.voltage;\n\tcstate->domain[nv_clk_src_core] = perfE.core;\n\tcstate->domain[nv_clk_src_shader] = perfE.shader;\n\tcstate->domain[nv_clk_src_mem] = perfE.memory;\n\tcstate->domain[nv_clk_src_vdec] = perfE.vdec;\n\tcstate->domain[nv_clk_src_dom6] = perfE.disp;\n\n\twhile (ver >= 0x40 && (++domain)->name != nv_clk_src_max) {\n\t\tstruct nvbios_perfS perfS;\n\t\tu8  sver = ver, shdr = hdr;\n\t\tu32 perfSe = nvbios_perfSp(bios, data, domain->bios,\n\t\t\t\t\t  &sver, &shdr, cnt, len, &perfS);\n\t\tif (perfSe == 0 || sver != 0x40)\n\t\t\tcontinue;\n\n\t\tif (domain->flags & NVKM_CLK_DOM_FLAG_CORE) {\n\t\t\tperfS.v40.freq = nvkm_clk_adjust(clk, false,\n\t\t\t\t\t\t\t pstate->pstate,\n\t\t\t\t\t\t\t domain->bios,\n\t\t\t\t\t\t\t perfS.v40.freq);\n\t\t}\n\n\t\tcstate->domain[domain->name] = perfS.v40.freq;\n\t}\n\n\tdata = nvbios_cstepEm(bios, pstate->pstate, &ver, &hdr, &cstepE);\n\tif (data) {\n\t\tint idx = cstepE.index;\n\t\tdo {\n\t\t\tnvkm_cstate_new(clk, idx, pstate);\n\t\t} while(idx--);\n\t}\n\n\tnvkm_pstate_info(clk, pstate);\n\tlist_add_tail(&pstate->head, &clk->states);\n\tclk->state_nr++;\n\treturn 0;\n}\n\n \nstatic int\nnvkm_clk_ustate_update(struct nvkm_clk *clk, int req)\n{\n\tstruct nvkm_pstate *pstate;\n\tint i = 0;\n\n\tif (!clk->allow_reclock)\n\t\treturn -ENOSYS;\n\n\tif (req != -1 && req != -2) {\n\t\tlist_for_each_entry(pstate, &clk->states, head) {\n\t\t\tif (pstate->pstate == req)\n\t\t\t\tbreak;\n\t\t\ti++;\n\t\t}\n\n\t\tif (pstate->pstate != req)\n\t\t\treturn -EINVAL;\n\t\treq = i;\n\t}\n\n\treturn req + 2;\n}\n\nstatic int\nnvkm_clk_nstate(struct nvkm_clk *clk, const char *mode, int arglen)\n{\n\tint ret = 1;\n\n\tif (clk->allow_reclock && !strncasecmpz(mode, \"auto\", arglen))\n\t\treturn -2;\n\n\tif (strncasecmpz(mode, \"disabled\", arglen)) {\n\t\tchar save = mode[arglen];\n\t\tlong v;\n\n\t\t((char *)mode)[arglen] = '\\0';\n\t\tif (!kstrtol(mode, 0, &v)) {\n\t\t\tret = nvkm_clk_ustate_update(clk, v);\n\t\t\tif (ret < 0)\n\t\t\t\tret = 1;\n\t\t}\n\t\t((char *)mode)[arglen] = save;\n\t}\n\n\treturn ret - 2;\n}\n\nint\nnvkm_clk_ustate(struct nvkm_clk *clk, int req, int pwr)\n{\n\tint ret = nvkm_clk_ustate_update(clk, req);\n\tif (ret >= 0) {\n\t\tif (ret -= 2, pwr) clk->ustate_ac = ret;\n\t\telse\t\t   clk->ustate_dc = ret;\n\t\treturn nvkm_pstate_calc(clk, true);\n\t}\n\treturn ret;\n}\n\nint\nnvkm_clk_astate(struct nvkm_clk *clk, int req, int rel, bool wait)\n{\n\tif (!rel) clk->astate  = req;\n\tif ( rel) clk->astate += rel;\n\tclk->astate = min(clk->astate, clk->state_nr - 1);\n\tclk->astate = max(clk->astate, 0);\n\treturn nvkm_pstate_calc(clk, wait);\n}\n\nint\nnvkm_clk_tstate(struct nvkm_clk *clk, u8 temp)\n{\n\tif (clk->temp == temp)\n\t\treturn 0;\n\tclk->temp = temp;\n\treturn nvkm_pstate_calc(clk, false);\n}\n\nint\nnvkm_clk_dstate(struct nvkm_clk *clk, int req, int rel)\n{\n\tif (!rel) clk->dstate  = req;\n\tif ( rel) clk->dstate += rel;\n\tclk->dstate = min(clk->dstate, clk->state_nr - 1);\n\tclk->dstate = max(clk->dstate, 0);\n\treturn nvkm_pstate_calc(clk, true);\n}\n\nint\nnvkm_clk_pwrsrc(struct nvkm_device *device)\n{\n\tif (device->clk)\n\t\treturn nvkm_pstate_calc(device->clk, false);\n\treturn 0;\n}\n\n \n\nint\nnvkm_clk_read(struct nvkm_clk *clk, enum nv_clk_src src)\n{\n\treturn clk->func->read(clk, src);\n}\n\nstatic int\nnvkm_clk_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_clk *clk = nvkm_clk(subdev);\n\tflush_work(&clk->work);\n\tif (clk->func->fini)\n\t\tclk->func->fini(clk);\n\treturn 0;\n}\n\nstatic int\nnvkm_clk_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_clk *clk = nvkm_clk(subdev);\n\tconst struct nvkm_domain *clock = clk->domains;\n\tint ret;\n\n\tmemset(&clk->bstate, 0x00, sizeof(clk->bstate));\n\tINIT_LIST_HEAD(&clk->bstate.list);\n\tclk->bstate.pstate = 0xff;\n\n\twhile (clock->name != nv_clk_src_max) {\n\t\tret = nvkm_clk_read(clk, clock->name);\n\t\tif (ret < 0) {\n\t\t\tnvkm_error(subdev, \"%02x freq unknown\\n\", clock->name);\n\t\t\treturn ret;\n\t\t}\n\t\tclk->bstate.base.domain[clock->name] = ret;\n\t\tclock++;\n\t}\n\n\tnvkm_pstate_info(clk, &clk->bstate);\n\n\tif (clk->func->init)\n\t\treturn clk->func->init(clk);\n\n\tclk->astate = clk->state_nr - 1;\n\tclk->dstate = 0;\n\tclk->pstate = -1;\n\tclk->temp = 90;  \n\tnvkm_pstate_calc(clk, true);\n\treturn 0;\n}\n\nstatic void *\nnvkm_clk_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_clk *clk = nvkm_clk(subdev);\n\tstruct nvkm_pstate *pstate, *temp;\n\n\t \n\tif (clk->func->pstates)\n\t\treturn clk;\n\n\tlist_for_each_entry_safe(pstate, temp, &clk->states, head) {\n\t\tnvkm_pstate_del(pstate);\n\t}\n\n\treturn clk;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_clk = {\n\t.dtor = nvkm_clk_dtor,\n\t.init = nvkm_clk_init,\n\t.fini = nvkm_clk_fini,\n};\n\nint\nnvkm_clk_ctor(const struct nvkm_clk_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, bool allow_reclock, struct nvkm_clk *clk)\n{\n\tstruct nvkm_subdev *subdev = &clk->subdev;\n\tstruct nvkm_bios *bios = device->bios;\n\tint ret, idx, arglen;\n\tconst char *mode;\n\tstruct nvbios_vpstate_header h;\n\n\tnvkm_subdev_ctor(&nvkm_clk, device, type, inst, subdev);\n\n\tif (bios && !nvbios_vpstate_parse(bios, &h)) {\n\t\tstruct nvbios_vpstate_entry base, boost;\n\t\tif (!nvbios_vpstate_entry(bios, &h, h.boost_id, &boost))\n\t\t\tclk->boost_khz = boost.clock_mhz * 1000;\n\t\tif (!nvbios_vpstate_entry(bios, &h, h.base_id, &base))\n\t\t\tclk->base_khz = base.clock_mhz * 1000;\n\t}\n\n\tclk->func = func;\n\tINIT_LIST_HEAD(&clk->states);\n\tclk->domains = func->domains;\n\tclk->ustate_ac = -1;\n\tclk->ustate_dc = -1;\n\tclk->allow_reclock = allow_reclock;\n\n\tINIT_WORK(&clk->work, nvkm_pstate_work);\n\tinit_waitqueue_head(&clk->wait);\n\tatomic_set(&clk->waiting, 0);\n\n\t \n\tif (!func->pstates) {\n\t\tidx = 0;\n\t\tdo {\n\t\t\tret = nvkm_pstate_new(clk, idx++);\n\t\t} while (ret == 0);\n\t} else {\n\t\tfor (idx = 0; idx < func->nr_pstates; idx++)\n\t\t\tlist_add_tail(&func->pstates[idx].head, &clk->states);\n\t\tclk->state_nr = func->nr_pstates;\n\t}\n\n\tmode = nvkm_stropt(device->cfgopt, \"NvClkMode\", &arglen);\n\tif (mode) {\n\t\tclk->ustate_ac = nvkm_clk_nstate(clk, mode, arglen);\n\t\tclk->ustate_dc = nvkm_clk_nstate(clk, mode, arglen);\n\t}\n\n\tmode = nvkm_stropt(device->cfgopt, \"NvClkModeAC\", &arglen);\n\tif (mode)\n\t\tclk->ustate_ac = nvkm_clk_nstate(clk, mode, arglen);\n\n\tmode = nvkm_stropt(device->cfgopt, \"NvClkModeDC\", &arglen);\n\tif (mode)\n\t\tclk->ustate_dc = nvkm_clk_nstate(clk, mode, arglen);\n\n\tclk->boost_mode = nvkm_longopt(device->cfgopt, \"NvBoost\",\n\t\t\t\t       NVKM_CLK_BOOST_NONE);\n\treturn 0;\n}\n\nint\nnvkm_clk_new_(const struct nvkm_clk_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, bool allow_reclock, struct nvkm_clk **pclk)\n{\n\tif (!(*pclk = kzalloc(sizeof(**pclk), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_clk_ctor(func, device, type, inst, allow_reclock, *pclk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}