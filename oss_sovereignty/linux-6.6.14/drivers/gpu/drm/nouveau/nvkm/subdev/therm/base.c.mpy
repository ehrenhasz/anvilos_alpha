{
  "module_name": "base.c",
  "hash_id": "7e7765e96e8ead1b579fc146b6553d502be742469685157d8f8a33f56bae898e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/option.h>\n#include <subdev/pmu.h>\n\nint\nnvkm_therm_temp_get(struct nvkm_therm *therm)\n{\n\tif (therm->func->temp_get)\n\t\treturn therm->func->temp_get(therm);\n\treturn -ENODEV;\n}\n\nstatic int\nnvkm_therm_update_trip(struct nvkm_therm *therm)\n{\n\tstruct nvbios_therm_trip_point *trip = therm->fan->bios.trip,\n\t\t\t\t       *cur_trip = NULL,\n\t\t\t\t       *last_trip = therm->last_trip;\n\tu8  temp = therm->func->temp_get(therm);\n\tu16 duty, i;\n\n\t \n\tcur_trip = NULL;\n\tfor (i = 0; i < therm->fan->bios.nr_fan_trip; i++) {\n\t\tif (temp >= trip[i].temp)\n\t\t\tcur_trip = &trip[i];\n\t}\n\n\t \n\tif (last_trip && temp <= (last_trip->temp) &&\n\t    temp > (last_trip->temp - last_trip->hysteresis))\n\t\tcur_trip = last_trip;\n\n\tif (cur_trip) {\n\t\tduty = cur_trip->fan_duty;\n\t\ttherm->last_trip = cur_trip;\n\t} else {\n\t\tduty = 0;\n\t\ttherm->last_trip = NULL;\n\t}\n\n\treturn duty;\n}\n\nstatic int\nnvkm_therm_compute_linear_duty(struct nvkm_therm *therm, u8 linear_min_temp,\n                               u8 linear_max_temp)\n{\n\tu8  temp = therm->func->temp_get(therm);\n\tu16 duty;\n\n\t \n\tif (temp < linear_min_temp)\n\t\treturn therm->fan->bios.min_duty;\n\telse if (temp > linear_max_temp)\n\t\treturn therm->fan->bios.max_duty;\n\n\t \n\tduty  = (temp - linear_min_temp);\n\tduty *= (therm->fan->bios.max_duty - therm->fan->bios.min_duty);\n\tduty /= (linear_max_temp - linear_min_temp);\n\tduty += therm->fan->bios.min_duty;\n\treturn duty;\n}\n\nstatic int\nnvkm_therm_update_linear(struct nvkm_therm *therm)\n{\n\tu8  min = therm->fan->bios.linear_min_temp;\n\tu8  max = therm->fan->bios.linear_max_temp;\n\treturn nvkm_therm_compute_linear_duty(therm, min, max);\n}\n\nstatic int\nnvkm_therm_update_linear_fallback(struct nvkm_therm *therm)\n{\n\tu8 max = therm->bios_sensor.thrs_fan_boost.temp;\n\treturn nvkm_therm_compute_linear_duty(therm, 30, max);\n}\n\nstatic void\nnvkm_therm_update(struct nvkm_therm *therm, int mode)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_timer *tmr = subdev->device->timer;\n\tunsigned long flags;\n\tbool immd = true;\n\tbool poll = true;\n\tint duty = -1;\n\n\tspin_lock_irqsave(&therm->lock, flags);\n\tif (mode < 0)\n\t\tmode = therm->mode;\n\ttherm->mode = mode;\n\n\tswitch (mode) {\n\tcase NVKM_THERM_CTRL_MANUAL:\n\t\tnvkm_timer_alarm(tmr, 0, &therm->alarm);\n\t\tduty = nvkm_therm_fan_get(therm);\n\t\tif (duty < 0)\n\t\t\tduty = 100;\n\t\tpoll = false;\n\t\tbreak;\n\tcase NVKM_THERM_CTRL_AUTO:\n\t\tswitch(therm->fan->bios.fan_mode) {\n\t\tcase NVBIOS_THERM_FAN_TRIP:\n\t\t\tduty = nvkm_therm_update_trip(therm);\n\t\t\tbreak;\n\t\tcase NVBIOS_THERM_FAN_LINEAR:\n\t\t\tduty = nvkm_therm_update_linear(therm);\n\t\t\tbreak;\n\t\tcase NVBIOS_THERM_FAN_OTHER:\n\t\t\tif (therm->cstate) {\n\t\t\t\tduty = therm->cstate;\n\t\t\t\tpoll = false;\n\t\t\t} else {\n\t\t\t\tduty = nvkm_therm_update_linear_fallback(therm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\timmd = false;\n\t\tbreak;\n\tcase NVKM_THERM_CTRL_NONE:\n\tdefault:\n\t\tnvkm_timer_alarm(tmr, 0, &therm->alarm);\n\t\tpoll = false;\n\t}\n\n\tif (poll)\n\t\tnvkm_timer_alarm(tmr, 1000000000ULL, &therm->alarm);\n\tspin_unlock_irqrestore(&therm->lock, flags);\n\n\tif (duty >= 0) {\n\t\tnvkm_debug(subdev, \"FAN target request: %d%%\\n\", duty);\n\t\tnvkm_therm_fan_set(therm, immd, duty);\n\t}\n}\n\nint\nnvkm_therm_cstate(struct nvkm_therm *therm, int fan, int dir)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tif (!dir || (dir < 0 && fan < therm->cstate) ||\n\t\t    (dir > 0 && fan > therm->cstate)) {\n\t\tnvkm_debug(subdev, \"default fan speed -> %d%%\\n\", fan);\n\t\ttherm->cstate = fan;\n\t\tnvkm_therm_update(therm, -1);\n\t}\n\treturn 0;\n}\n\nstatic void\nnvkm_therm_alarm(struct nvkm_alarm *alarm)\n{\n\tstruct nvkm_therm *therm =\n\t       container_of(alarm, struct nvkm_therm, alarm);\n\tnvkm_therm_update(therm, -1);\n}\n\nint\nnvkm_therm_fan_mode(struct nvkm_therm *therm, int mode)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstatic const char *name[] = {\n\t\t\"disabled\",\n\t\t\"manual\",\n\t\t\"automatic\"\n\t};\n\n\t \n\tif ((mode >= ARRAY_SIZE(name)) ||\n\t    (mode != NVKM_THERM_CTRL_NONE && nvkm_pmu_fan_controlled(device)))\n\t\treturn -EINVAL;\n\n\t \n\tif (mode == NVKM_THERM_CTRL_AUTO &&\n\t    therm->func->temp_get(therm) < 0)\n\t\treturn -EINVAL;\n\n\tif (therm->mode == mode)\n\t\treturn 0;\n\n\tnvkm_debug(subdev, \"fan management: %s\\n\", name[mode]);\n\tnvkm_therm_update(therm, mode);\n\treturn 0;\n}\n\nint\nnvkm_therm_attr_get(struct nvkm_therm *therm, enum nvkm_therm_attr_type type)\n{\n\tswitch (type) {\n\tcase NVKM_THERM_ATTR_FAN_MIN_DUTY:\n\t\treturn therm->fan->bios.min_duty;\n\tcase NVKM_THERM_ATTR_FAN_MAX_DUTY:\n\t\treturn therm->fan->bios.max_duty;\n\tcase NVKM_THERM_ATTR_FAN_MODE:\n\t\treturn therm->mode;\n\tcase NVKM_THERM_ATTR_THRS_FAN_BOOST:\n\t\treturn therm->bios_sensor.thrs_fan_boost.temp;\n\tcase NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:\n\t\treturn therm->bios_sensor.thrs_fan_boost.hysteresis;\n\tcase NVKM_THERM_ATTR_THRS_DOWN_CLK:\n\t\treturn therm->bios_sensor.thrs_down_clock.temp;\n\tcase NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:\n\t\treturn therm->bios_sensor.thrs_down_clock.hysteresis;\n\tcase NVKM_THERM_ATTR_THRS_CRITICAL:\n\t\treturn therm->bios_sensor.thrs_critical.temp;\n\tcase NVKM_THERM_ATTR_THRS_CRITICAL_HYST:\n\t\treturn therm->bios_sensor.thrs_critical.hysteresis;\n\tcase NVKM_THERM_ATTR_THRS_SHUTDOWN:\n\t\treturn therm->bios_sensor.thrs_shutdown.temp;\n\tcase NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:\n\t\treturn therm->bios_sensor.thrs_shutdown.hysteresis;\n\t}\n\n\treturn -EINVAL;\n}\n\nint\nnvkm_therm_attr_set(struct nvkm_therm *therm,\n\t\t    enum nvkm_therm_attr_type type, int value)\n{\n\tswitch (type) {\n\tcase NVKM_THERM_ATTR_FAN_MIN_DUTY:\n\t\tif (value < 0)\n\t\t\tvalue = 0;\n\t\tif (value > therm->fan->bios.max_duty)\n\t\t\tvalue = therm->fan->bios.max_duty;\n\t\ttherm->fan->bios.min_duty = value;\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_FAN_MAX_DUTY:\n\t\tif (value < 0)\n\t\t\tvalue = 0;\n\t\tif (value < therm->fan->bios.min_duty)\n\t\t\tvalue = therm->fan->bios.min_duty;\n\t\ttherm->fan->bios.max_duty = value;\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_FAN_MODE:\n\t\treturn nvkm_therm_fan_mode(therm, value);\n\tcase NVKM_THERM_ATTR_THRS_FAN_BOOST:\n\t\ttherm->bios_sensor.thrs_fan_boost.temp = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST:\n\t\ttherm->bios_sensor.thrs_fan_boost.hysteresis = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_DOWN_CLK:\n\t\ttherm->bios_sensor.thrs_down_clock.temp = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST:\n\t\ttherm->bios_sensor.thrs_down_clock.hysteresis = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_CRITICAL:\n\t\ttherm->bios_sensor.thrs_critical.temp = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_CRITICAL_HYST:\n\t\ttherm->bios_sensor.thrs_critical.hysteresis = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_SHUTDOWN:\n\t\ttherm->bios_sensor.thrs_shutdown.temp = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\tcase NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST:\n\t\ttherm->bios_sensor.thrs_shutdown.hysteresis = value;\n\t\ttherm->func->program_alarms(therm);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nvoid\nnvkm_therm_clkgate_enable(struct nvkm_therm *therm)\n{\n\tif (!therm || !therm->func->clkgate_enable || !therm->clkgating_enabled)\n\t\treturn;\n\n\tnvkm_debug(&therm->subdev,\n\t\t   \"Enabling clockgating\\n\");\n\ttherm->func->clkgate_enable(therm);\n}\n\nvoid\nnvkm_therm_clkgate_fini(struct nvkm_therm *therm, bool suspend)\n{\n\tif (!therm || !therm->func->clkgate_fini || !therm->clkgating_enabled)\n\t\treturn;\n\n\tnvkm_debug(&therm->subdev,\n\t\t   \"Preparing clockgating for %s\\n\",\n\t\t   suspend ? \"suspend\" : \"fini\");\n\ttherm->func->clkgate_fini(therm, suspend);\n}\n\nstatic void\nnvkm_therm_clkgate_oneinit(struct nvkm_therm *therm)\n{\n\tif (!therm->func->clkgate_enable || !therm->clkgating_enabled)\n\t\treturn;\n\n\tnvkm_info(&therm->subdev, \"Clockgating enabled\\n\");\n}\n\nstatic void\nnvkm_therm_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_therm *therm = nvkm_therm(subdev);\n\tif (therm->func->intr)\n\t\ttherm->func->intr(therm);\n}\n\nstatic int\nnvkm_therm_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_therm *therm = nvkm_therm(subdev);\n\n\tif (therm->func->fini)\n\t\ttherm->func->fini(therm);\n\n\tnvkm_therm_fan_fini(therm, suspend);\n\tnvkm_therm_sensor_fini(therm, suspend);\n\n\tif (suspend) {\n\t\ttherm->suspend = therm->mode;\n\t\ttherm->mode = NVKM_THERM_CTRL_NONE;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_therm_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_therm *therm = nvkm_therm(subdev);\n\tnvkm_therm_sensor_ctor(therm);\n\tnvkm_therm_ic_ctor(therm);\n\tnvkm_therm_fan_ctor(therm);\n\tnvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);\n\tnvkm_therm_sensor_preinit(therm);\n\tnvkm_therm_clkgate_oneinit(therm);\n\treturn 0;\n}\n\nstatic int\nnvkm_therm_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_therm *therm = nvkm_therm(subdev);\n\n\tif (therm->func->init)\n\t\ttherm->func->init(therm);\n\n\tif (therm->suspend >= 0) {\n\t\t \n\t\tif (therm->suspend > 0)\n\t\t\tnvkm_therm_fan_set(therm, true, therm->fan->percent);\n\n\t\tnvkm_therm_fan_mode(therm, therm->suspend);\n\t}\n\n\tnvkm_therm_sensor_init(therm);\n\tnvkm_therm_fan_init(therm);\n\treturn 0;\n}\n\nvoid\nnvkm_therm_clkgate_init(struct nvkm_therm *therm,\n\t\t\tconst struct nvkm_therm_clkgate_pack *p)\n{\n\tif (!therm || !therm->func->clkgate_init || !therm->clkgating_enabled)\n\t\treturn;\n\n\ttherm->func->clkgate_init(therm, p);\n}\n\nstatic void *\nnvkm_therm_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_therm *therm = nvkm_therm(subdev);\n\tkfree(therm->fan);\n\treturn therm;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_therm = {\n\t.dtor = nvkm_therm_dtor,\n\t.oneinit = nvkm_therm_oneinit,\n\t.init = nvkm_therm_init,\n\t.fini = nvkm_therm_fini,\n\t.intr = nvkm_therm_intr,\n};\n\nvoid\nnvkm_therm_ctor(struct nvkm_therm *therm, struct nvkm_device *device, enum nvkm_subdev_type type,\n\t\tint inst, const struct nvkm_therm_func *func)\n{\n\tnvkm_subdev_ctor(&nvkm_therm, device, type, inst, &therm->subdev);\n\ttherm->func = func;\n\n\tnvkm_alarm_init(&therm->alarm, nvkm_therm_alarm);\n\tspin_lock_init(&therm->lock);\n\tspin_lock_init(&therm->sensor.alarm_program_lock);\n\n\ttherm->fan_get = nvkm_therm_fan_user_get;\n\ttherm->fan_set = nvkm_therm_fan_user_set;\n\ttherm->attr_get = nvkm_therm_attr_get;\n\ttherm->attr_set = nvkm_therm_attr_set;\n\ttherm->mode = therm->suspend = -1;  \n\n\ttherm->clkgating_enabled = nvkm_boolopt(device->cfgopt,\n\t\t\t\t\t\t\"NvPmEnableGating\", false);\n}\n\nint\nnvkm_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,\n\t\tenum nvkm_subdev_type type, int inst, struct nvkm_therm **ptherm)\n{\n\tstruct nvkm_therm *therm;\n\n\tif (!(therm = *ptherm = kzalloc(sizeof(*therm), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_therm_ctor(therm, device, type, inst, func);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}