{
  "module_name": "ga102.c",
  "hash_id": "b7fb85e8bcdfaaaa25950fd0151146b9e7b7a3ded1cc54e7aea2e03b5401057b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/acr/ga102.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <nvfw/acr.h>\n\nstatic int\nga102_acr_wpr_patch(struct nvkm_acr *acr, s64 adjust)\n{\n\tstruct wpr_header_v2 hdr;\n\tstruct lsb_header_v2 *lsb;\n\tstruct nvkm_acr_lsfw *lsfw;\n\tu32 offset = 0;\n\n\tlsb = kvmalloc(sizeof(*lsb), GFP_KERNEL);\n\tif (!lsb)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tnvkm_robj(acr->wpr, offset, &hdr, sizeof(hdr));\n\t\twpr_header_v2_dump(&acr->subdev, &hdr);\n\n\t\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\t\tif (lsfw->id != hdr.wpr.falcon_id)\n\t\t\t\tcontinue;\n\n\t\t\tnvkm_robj(acr->wpr, hdr.wpr.lsb_offset, lsb, sizeof(*lsb));\n\t\t\tlsb_header_v2_dump(&acr->subdev, lsb);\n\n\t\t\tlsfw->func->bld_patch(acr, lsb->bl_data_off, adjust);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += sizeof(hdr);\n\t} while (hdr.wpr.falcon_id != WPR_HEADER_V1_FALCON_ID_INVALID);\n\n\tkvfree(lsb);\n\treturn 0;\n}\n\nstatic int\nga102_acr_wpr_build_lsb(struct nvkm_acr *acr, struct nvkm_acr_lsfw *lsfw)\n{\n\tstruct lsb_header_v2 *hdr;\n\tint ret = 0;\n\n\tif (WARN_ON(lsfw->sig->size != sizeof(hdr->signature)))\n\t\treturn -EINVAL;\n\n\thdr = kvzalloc(sizeof(*hdr), GFP_KERNEL);\n\tif (!hdr)\n\t\treturn -ENOMEM;\n\n\thdr->hdr.identifier = WPR_GENERIC_HEADER_ID_LSF_LSB_HEADER;\n\thdr->hdr.version = 2;\n\thdr->hdr.size = sizeof(*hdr);\n\n\tmemcpy(&hdr->signature, lsfw->sig->data, lsfw->sig->size);\n\thdr->ucode_off = lsfw->offset.img;\n\thdr->ucode_size = lsfw->ucode_size;\n\thdr->data_size = lsfw->data_size;\n\thdr->bl_code_size = lsfw->bootloader_size;\n\thdr->bl_imem_off = lsfw->bootloader_imem_offset;\n\thdr->bl_data_off = lsfw->offset.bld;\n\thdr->bl_data_size = lsfw->bl_data_size;\n\thdr->app_code_off = lsfw->app_start_offset + lsfw->app_resident_code_offset;\n\thdr->app_code_size = ALIGN(lsfw->app_resident_code_size, 0x100);\n\thdr->app_data_off = lsfw->app_start_offset + lsfw->app_resident_data_offset;\n\thdr->app_data_size = ALIGN(lsfw->app_resident_data_size, 0x100);\n\thdr->app_imem_offset = lsfw->app_imem_offset;\n\thdr->app_dmem_offset = lsfw->app_dmem_offset;\n\thdr->flags = lsfw->func->flags;\n\thdr->monitor_code_offset = 0;\n\thdr->monitor_data_offset = 0;\n\thdr->manifest_offset = 0;\n\n\tif (lsfw->secure_bootloader) {\n\t\tstruct nvkm_falcon_fw fw = {\n\t\t\t.fw.img = hdr->hs_fmc_params.pkc_signature,\n\t\t\t.fw.name = \"LSFW\",\n\t\t\t.func = &(const struct nvkm_falcon_fw_func) {\n\t\t\t\t.signature = ga100_flcn_fw_signature,\n\t\t\t},\n\t\t\t.sig_size = lsfw->sig_size,\n\t\t\t.sig_nr = lsfw->sig_nr,\n\t\t\t.sigs = lsfw->sigs,\n\t\t\t.fuse_ver = lsfw->fuse_ver,\n\t\t\t.engine_id = lsfw->engine_id,\n\t\t\t.ucode_id = lsfw->ucode_id,\n\t\t\t.falcon = lsfw->falcon,\n\n\t\t};\n\n\t\tret = nvkm_falcon_get(fw.falcon, &acr->subdev);\n\t\tif (ret == 0) {\n\t\t\thdr->hs_fmc_params.hs_fmc = 1;\n\t\t\thdr->hs_fmc_params.pkc_algo = 0;\n\t\t\thdr->hs_fmc_params.pkc_algo_version = 1;\n\t\t\thdr->hs_fmc_params.engid_mask = lsfw->engine_id;\n\t\t\thdr->hs_fmc_params.ucode_id = lsfw->ucode_id;\n\t\t\thdr->hs_fmc_params.fuse_ver = lsfw->fuse_ver;\n\t\t\tret = nvkm_falcon_fw_patch(&fw);\n\t\t\tnvkm_falcon_put(fw.falcon, &acr->subdev);\n\t\t}\n\t}\n\n\tnvkm_wobj(acr->wpr, lsfw->offset.lsb, hdr, sizeof(*hdr));\n\tkvfree(hdr);\n\treturn ret;\n}\n\nstatic int\nga102_acr_wpr_build(struct nvkm_acr *acr, struct nvkm_acr_lsf *rtos)\n{\n\tstruct nvkm_acr_lsfw *lsfw;\n\tstruct wpr_header_v2 hdr;\n\tu32 offset = 0;\n\tint ret;\n\n\t \n\tnvkm_wo32(acr->wpr, 0x300, (2 << 16) | WPR_GENERIC_HEADER_ID_LSF_SHARED_SUB_WPR);\n\tnvkm_wo32(acr->wpr, 0x304, 0x14);\n\tnvkm_wo32(acr->wpr, 0x308, 0xffffffff);\n\tnvkm_wo32(acr->wpr, 0x30c, 0);\n\tnvkm_wo32(acr->wpr, 0x310, 0);\n\n\t \n\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\tstruct lsf_signature_v2 *sig = (void *)lsfw->sig->data;\n\n\t\thdr.hdr.identifier = WPR_GENERIC_HEADER_ID_LSF_WPR_HEADER;\n\t\thdr.hdr.version = 2;\n\t\thdr.hdr.size = sizeof(hdr);\n\t\thdr.wpr.falcon_id = lsfw->id;\n\t\thdr.wpr.lsb_offset = lsfw->offset.lsb;\n\t\thdr.wpr.bootstrap_owner = NVKM_ACR_LSF_GSPLITE;\n\t\thdr.wpr.lazy_bootstrap = 1;\n\t\thdr.wpr.bin_version = sig->ls_ucode_version;\n\t\thdr.wpr.status = WPR_HEADER_V1_STATUS_COPY;\n\n\t\t \n\t\tnvkm_wobj(acr->wpr, offset, &hdr, sizeof(hdr));\n\t\toffset += sizeof(hdr);\n\n\t\t \n\t\tret = ga102_acr_wpr_build_lsb(acr, lsfw);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tnvkm_wobj(acr->wpr, lsfw->offset.img,\n\t\t\t\t    lsfw->img.data,\n\t\t\t\t    lsfw->img.size);\n\n\t\t \n\t\tlsfw->func->bld_write(acr, lsfw->offset.bld, lsfw);\n\t}\n\n\t \n\thdr.hdr.identifier = WPR_GENERIC_HEADER_ID_LSF_WPR_HEADER;\n\thdr.hdr.version = 2;\n\thdr.hdr.size = sizeof(hdr);\n\thdr.wpr.falcon_id = WPR_HEADER_V1_FALCON_ID_INVALID;\n\tnvkm_wobj(acr->wpr, offset, &hdr, sizeof(hdr));\n\treturn 0;\n}\n\nstatic u32\nga102_acr_wpr_layout(struct nvkm_acr *acr)\n{\n\tstruct nvkm_acr_lsfw *lsfw;\n\tu32 wpr = 0;\n\n\twpr += 21   * sizeof(struct wpr_header_v2);\n\twpr  = ALIGN(wpr, 256);\n\n\twpr += 0x100;  \n\n\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\twpr  = ALIGN(wpr, 256);\n\t\tlsfw->offset.lsb = wpr;\n\t\twpr += sizeof(struct lsb_header_v2);\n\n\t\twpr  = ALIGN(wpr, 4096);\n\t\tlsfw->offset.img = wpr;\n\t\twpr += lsfw->img.size;\n\n\t\twpr  = ALIGN(wpr, 256);\n\t\tlsfw->offset.bld = wpr;\n\t\tlsfw->bl_data_size = ALIGN(lsfw->func->bld_size, 256);\n\t\twpr += lsfw->bl_data_size;\n\t}\n\n\treturn wpr;\n}\n\nstatic int\nga102_acr_wpr_parse(struct nvkm_acr *acr)\n{\n\tconst struct wpr_header_v2 *hdr = (void *)acr->wpr_fw->data;\n\n\twhile (hdr->wpr.falcon_id != WPR_HEADER_V1_FALCON_ID_INVALID) {\n\t\twpr_header_v2_dump(&acr->subdev, hdr);\n\t\tif (!nvkm_acr_lsfw_add(NULL, acr, NULL, (hdr++)->wpr.falcon_id))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(\"nvidia/ga102/acr/ucode_unload.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/acr/ucode_unload.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/acr/ucode_unload.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/acr/ucode_unload.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/acr/ucode_unload.bin\");\n\nstatic const struct nvkm_acr_hsf_fwif\nga102_acr_unload_fwif[] = {\n\t{  0, ga100_acr_hsfw_ctor, &ga102_flcn_fw, NVKM_ACR_HSF_SEC2 },\n\t{}\n};\n\nMODULE_FIRMWARE(\"nvidia/ga102/acr/ucode_asb.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/acr/ucode_asb.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/acr/ucode_asb.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/acr/ucode_asb.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/acr/ucode_asb.bin\");\n\nstatic const struct nvkm_acr_hsf_fwif\nga102_acr_asb_fwif[] = {\n\t{  0, ga100_acr_hsfw_ctor, &ga102_flcn_fw, NVKM_ACR_HSF_GSP },\n\t{}\n};\n\nstatic const struct nvkm_falcon_fw_func\nga102_acr_ahesasc_0 = {\n\t.signature = ga100_flcn_fw_signature,\n\t.reset = gm200_flcn_fw_reset,\n\t.setup = gp102_acr_load_setup,\n\t.load = ga102_flcn_fw_load,\n\t.boot = ga102_flcn_fw_boot,\n};\n\nMODULE_FIRMWARE(\"nvidia/ga102/acr/ucode_ahesasc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga103/acr/ucode_ahesasc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga104/acr/ucode_ahesasc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga106/acr/ucode_ahesasc.bin\");\nMODULE_FIRMWARE(\"nvidia/ga107/acr/ucode_ahesasc.bin\");\n\nstatic const struct nvkm_acr_hsf_fwif\nga102_acr_ahesasc_fwif[] = {\n\t{  0, ga100_acr_hsfw_ctor, &ga102_acr_ahesasc_0, NVKM_ACR_HSF_SEC2 },\n\t{}\n};\n\nstatic const struct nvkm_acr_func\nga102_acr = {\n\t.ahesasc = ga102_acr_ahesasc_fwif,\n\t.asb = ga102_acr_asb_fwif,\n\t.unload = ga102_acr_unload_fwif,\n\t.wpr_parse = ga102_acr_wpr_parse,\n\t.wpr_layout = ga102_acr_wpr_layout,\n\t.wpr_alloc = gp102_acr_wpr_alloc,\n\t.wpr_patch = ga102_acr_wpr_patch,\n\t.wpr_build = ga102_acr_wpr_build,\n\t.wpr_check = ga100_acr_wpr_check,\n\t.init = tu102_acr_init,\n};\n\nstatic int\nga102_acr_load(struct nvkm_acr *acr, int version,\n\t       const struct nvkm_acr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &acr->subdev;\n\tconst struct nvkm_acr_hsf_fwif *hsfwif;\n\n\thsfwif = nvkm_firmware_load(subdev, fwif->func->ahesasc, \"AcrAHESASC\",\n\t\t\t\t    acr, NULL, \"acr/ucode_ahesasc\", \"AHESASC\");\n\tif (IS_ERR(hsfwif))\n\t\treturn PTR_ERR(hsfwif);\n\n\thsfwif = nvkm_firmware_load(subdev, fwif->func->asb, \"AcrASB\",\n\t\t\t\t    acr, NULL, \"acr/ucode_asb\", \"ASB\");\n\tif (IS_ERR(hsfwif))\n\t\treturn PTR_ERR(hsfwif);\n\n\thsfwif = nvkm_firmware_load(subdev, fwif->func->unload, \"AcrUnload\",\n\t\t\t\t    acr, NULL, \"acr/ucode_unload\", \"unload\");\n\tif (IS_ERR(hsfwif))\n\t\treturn PTR_ERR(hsfwif);\n\n\treturn 0;\n}\n\nstatic const struct nvkm_acr_fwif\nga102_acr_fwif[] = {\n\t{  0, ga102_acr_load, &ga102_acr },\n\t{ -1, gm200_acr_nofw, &gm200_acr },\n\t{}\n};\n\nint\nga102_acr_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_acr **pacr)\n{\n\treturn nvkm_acr_new_(ga102_acr_fwif, device, type, inst, pacr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}