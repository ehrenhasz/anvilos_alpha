{
  "module_name": "auxg94.c",
  "hash_id": "78f0e00cca4b46d4d8ea2495329cf58ddc68da0bc6c57c4848c8abe2c2c71138",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/auxg94.c",
  "human_readable_source": " \n#define g94_i2c_aux(p) container_of((p), struct g94_i2c_aux, base)\n#include \"aux.h\"\n\nstruct g94_i2c_aux {\n\tstruct nvkm_i2c_aux base;\n\tint ch;\n};\n\nstatic void\ng94_i2c_aux_fini(struct g94_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = aux->base.pad->i2c->subdev.device;\n\tnvkm_mask(device, 0x00e4e4 + (aux->ch * 0x50), 0x00310000, 0x00000000);\n}\n\nstatic int\ng94_i2c_aux_init(struct g94_i2c_aux *aux)\n{\n\tstruct nvkm_device *device = aux->base.pad->i2c->subdev.device;\n\tconst u32 unksel = 1;  \n\tconst u32 ureq = unksel ? 0x00100000 : 0x00200000;\n\tconst u32 urep = unksel ? 0x01000000 : 0x02000000;\n\tu32 ctrl, timeout;\n\n\t \n\ttimeout = 1000;\n\tdo {\n\t\tctrl = nvkm_rd32(device, 0x00e4e4 + (aux->ch * 0x50));\n\t\tudelay(1);\n\t\tif (!timeout--) {\n\t\t\tAUX_ERR(&aux->base, \"begin idle timeout %08x\", ctrl);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} while (ctrl & 0x03010000);\n\n\t \n\tnvkm_mask(device, 0x00e4e4 + (aux->ch * 0x50), 0x00300000, ureq);\n\ttimeout = 1000;\n\tdo {\n\t\tctrl = nvkm_rd32(device, 0x00e4e4 + (aux->ch * 0x50));\n\t\tudelay(1);\n\t\tif (!timeout--) {\n\t\t\tAUX_ERR(&aux->base, \"magic wait %08x\", ctrl);\n\t\t\tg94_i2c_aux_fini(aux);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} while ((ctrl & 0x03000000) != urep);\n\n\treturn 0;\n}\n\nint\ng94_i2c_aux_xfer(struct nvkm_i2c_aux *obj, bool retry,\n\t\t u8 type, u32 addr, u8 *data, u8 *size)\n{\n\tstruct g94_i2c_aux *aux = g94_i2c_aux(obj);\n\tstruct nvkm_i2c *i2c = aux->base.pad->i2c;\n\tstruct nvkm_device *device = i2c->subdev.device;\n\tconst u32 base = aux->ch * 0x50;\n\tu32 ctrl, stat, timeout, retries = 0;\n\tu32 xbuf[4] = {};\n\tint ret, i;\n\n\tAUX_TRACE(&aux->base, \"%d: %08x %d\", type, addr, *size);\n\n\tret = g94_i2c_aux_init(aux);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tstat = nvkm_rd32(device, 0x00e4e8 + base);\n\tif (!(stat & 0x10000000)) {\n\t\tAUX_TRACE(&aux->base, \"sink not detected\");\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tnvkm_i2c_aux_autodpcd(i2c, aux->ch, false);\n\n\tif (!(type & 1)) {\n\t\tmemcpy(xbuf, data, *size);\n\t\tfor (i = 0; i < 16; i += 4) {\n\t\t\tAUX_TRACE(&aux->base, \"wr %08x\", xbuf[i / 4]);\n\t\t\tnvkm_wr32(device, 0x00e4c0 + base + i, xbuf[i / 4]);\n\t\t}\n\t}\n\n\tctrl  = nvkm_rd32(device, 0x00e4e4 + base);\n\tctrl &= ~0x0001f1ff;\n\tctrl |= type << 12;\n\tctrl |= (*size ? (*size - 1) : 0x00000100);\n\tnvkm_wr32(device, 0x00e4e0 + base, addr);\n\n\t \n\tdo {\n\t\t \n\t\tnvkm_wr32(device, 0x00e4e4 + base, 0x80000000 | ctrl);\n\t\tnvkm_wr32(device, 0x00e4e4 + base, 0x00000000 | ctrl);\n\t\tif (retries)\n\t\t\tudelay(400);\n\n\t\t \n\t\tnvkm_wr32(device, 0x00e4e4 + base, 0x00010000 | ctrl);\n\n\t\ttimeout = 2000;\n\t\tdo {\n\t\t\tctrl = nvkm_rd32(device, 0x00e4e4 + base);\n\t\t\tudelay(1);\n\t\t\tif (!timeout--) {\n\t\t\t\tAUX_ERR(&aux->base, \"timeout %08x\", ctrl);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t} while (ctrl & 0x00010000);\n\t\tret = 0;\n\n\t\t \n\t\tstat = nvkm_mask(device, 0x00e4e8 + base, 0, 0);\n\t\tif ((stat & 0x000f0000) == 0x00080000 ||\n\t\t    (stat & 0x000f0000) == 0x00020000)\n\t\t\tret = 1;\n\t\tif ((stat & 0x00000100))\n\t\t\tret = -ETIMEDOUT;\n\t\tif ((stat & 0x00000e00))\n\t\t\tret = -EIO;\n\n\t\tAUX_TRACE(&aux->base, \"%02d %08x %08x\", retries, ctrl, stat);\n\t} while (ret && retry && retries++ < 32);\n\n\tif (type & 1) {\n\t\tfor (i = 0; i < 16; i += 4) {\n\t\t\txbuf[i / 4] = nvkm_rd32(device, 0x00e4d0 + base + i);\n\t\t\tAUX_TRACE(&aux->base, \"rd %08x\", xbuf[i / 4]);\n\t\t}\n\t\tmemcpy(data, xbuf, *size);\n\t\t*size = stat & 0x0000001f;\n\t}\nout_err:\n\tnvkm_i2c_aux_autodpcd(i2c, aux->ch, true);\nout:\n\tg94_i2c_aux_fini(aux);\n\treturn ret < 0 ? ret : (stat & 0x000f0000) >> 16;\n}\n\nint\ng94_i2c_aux_new_(const struct nvkm_i2c_aux_func *func,\n\t\t struct nvkm_i2c_pad *pad, int index, u8 drive,\n\t\t struct nvkm_i2c_aux **paux)\n{\n\tstruct g94_i2c_aux *aux;\n\n\tif (!(aux = kzalloc(sizeof(*aux), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*paux = &aux->base;\n\n\tnvkm_i2c_aux_ctor(func, pad, index, &aux->base);\n\taux->ch = drive;\n\taux->base.intr = 1 << aux->ch;\n\treturn 0;\n}\n\nstatic const struct nvkm_i2c_aux_func\ng94_i2c_aux = {\n\t.xfer = g94_i2c_aux_xfer,\n};\n\nint\ng94_i2c_aux_new(struct nvkm_i2c_pad *pad, int index, u8 drive,\n\t\tstruct nvkm_i2c_aux **paux)\n{\n\treturn g94_i2c_aux_new_(&g94_i2c_aux, pad, index, drive, paux);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}