{
  "module_name": "base.c",
  "hash_id": "54755eb95d8b579e97a409187595f13196289d29b19dec82cde4b45822ebb18f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/volt/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/vmap.h>\n#include <subdev/bios/volt.h>\n#include <subdev/therm.h>\n\nint\nnvkm_volt_get(struct nvkm_volt *volt)\n{\n\tint ret, i;\n\n\tif (volt->func->volt_get)\n\t\treturn volt->func->volt_get(volt);\n\n\tret = volt->func->vid_get(volt);\n\tif (ret >= 0) {\n\t\tfor (i = 0; i < volt->vid_nr; i++) {\n\t\t\tif (volt->vid[i].vid == ret)\n\t\t\t\treturn volt->vid[i].uv;\n\t\t}\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int\nnvkm_volt_set(struct nvkm_volt *volt, u32 uv)\n{\n\tstruct nvkm_subdev *subdev = &volt->subdev;\n\tint i, ret = -EINVAL, best_err = volt->max_uv, best = -1;\n\n\tif (volt->func->volt_set)\n\t\treturn volt->func->volt_set(volt, uv);\n\n\tfor (i = 0; i < volt->vid_nr; i++) {\n\t\tint err = volt->vid[i].uv - uv;\n\t\tif (err < 0 || err > best_err)\n\t\t\tcontinue;\n\n\t\tbest_err = err;\n\t\tbest = i;\n\t\tif (best_err == 0)\n\t\t\tbreak;\n\t}\n\n\tif (best == -1) {\n\t\tnvkm_error(subdev, \"couldn't set %iuv\\n\", uv);\n\t\treturn ret;\n\t}\n\n\tret = volt->func->vid_set(volt, volt->vid[best].vid);\n\tnvkm_debug(subdev, \"set req %duv to %duv: %d\\n\", uv,\n\t\t   volt->vid[best].uv, ret);\n\treturn ret;\n}\n\nint\nnvkm_volt_map_min(struct nvkm_volt *volt, u8 id)\n{\n\tstruct nvkm_bios *bios = volt->subdev.device->bios;\n\tstruct nvbios_vmap_entry info;\n\tu8  ver, len;\n\tu32 vmap;\n\n\tvmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);\n\tif (vmap) {\n\t\tif (info.link != 0xff) {\n\t\t\tint ret = nvkm_volt_map_min(volt, info.link);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tinfo.min += ret;\n\t\t}\n\t\treturn info.min;\n\t}\n\n\treturn id ? id * 10000 : -ENODEV;\n}\n\nint\nnvkm_volt_map(struct nvkm_volt *volt, u8 id, u8 temp)\n{\n\tstruct nvkm_bios *bios = volt->subdev.device->bios;\n\tstruct nvbios_vmap_entry info;\n\tu8  ver, len;\n\tu32 vmap;\n\n\tvmap = nvbios_vmap_entry_parse(bios, id, &ver, &len, &info);\n\tif (vmap) {\n\t\ts64 result;\n\n\t\tif (volt->speedo < 0)\n\t\t\treturn volt->speedo;\n\n\t\tif (ver == 0x10 || (ver == 0x20 && info.mode == 0)) {\n\t\t\tresult  = div64_s64((s64)info.arg[0], 10);\n\t\t\tresult += div64_s64((s64)info.arg[1] * volt->speedo, 10);\n\t\t\tresult += div64_s64((s64)info.arg[2] * volt->speedo * volt->speedo, 100000);\n\t\t} else if (ver == 0x20) {\n\t\t\tswitch (info.mode) {\n\t\t\t \n\t\t\tcase 0x1:\n\t\t\t\tresult =  ((s64)info.arg[0] * 15625) >> 18;\n\t\t\t\tresult += ((s64)info.arg[1] * volt->speedo * 15625) >> 18;\n\t\t\t\tresult += ((s64)info.arg[2] * temp * 15625) >> 10;\n\t\t\t\tresult += ((s64)info.arg[3] * volt->speedo * temp * 15625) >> 18;\n\t\t\t\tresult += ((s64)info.arg[4] * volt->speedo * volt->speedo * 15625) >> 30;\n\t\t\t\tresult += ((s64)info.arg[5] * temp * temp * 15625) >> 18;\n\t\t\t\tbreak;\n\t\t\tcase 0x3:\n\t\t\t\tresult = (info.min + info.max) / 2;\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\tdefault:\n\t\t\t\tresult = info.min;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tresult = min(max(result, (s64)info.min), (s64)info.max);\n\n\t\tif (info.link != 0xff) {\n\t\t\tint ret = nvkm_volt_map(volt, info.link, temp);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tresult += ret;\n\t\t}\n\t\treturn result;\n\t}\n\n\treturn id ? id * 10000 : -ENODEV;\n}\n\nint\nnvkm_volt_set_id(struct nvkm_volt *volt, u8 id, u8 min_id, u8 temp,\n\t\t int condition)\n{\n\tint ret;\n\n\tif (volt->func->set_id)\n\t\treturn volt->func->set_id(volt, id, condition);\n\n\tret = nvkm_volt_map(volt, id, temp);\n\tif (ret >= 0) {\n\t\tint prev = nvkm_volt_get(volt);\n\t\tif (!condition || prev < 0 ||\n\t\t    (condition < 0 && ret < prev) ||\n\t\t    (condition > 0 && ret > prev)) {\n\t\t\tint min = nvkm_volt_map(volt, min_id, temp);\n\t\t\tif (min >= 0)\n\t\t\t\tret = max(min, ret);\n\t\t\tret = nvkm_volt_set(volt, ret);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void\nnvkm_volt_parse_bios(struct nvkm_bios *bios, struct nvkm_volt *volt)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tstruct nvbios_volt_entry ivid;\n\tstruct nvbios_volt info;\n\tu8  ver, hdr, cnt, len;\n\tu32 data;\n\tint i;\n\n\tdata = nvbios_volt_parse(bios, &ver, &hdr, &cnt, &len, &info);\n\tif (data && info.vidmask && info.base && info.step && info.ranged) {\n\t\tnvkm_debug(subdev, \"found ranged based VIDs\\n\");\n\t\tvolt->min_uv = info.min;\n\t\tvolt->max_uv = info.max;\n\t\tfor (i = 0; i < info.vidmask + 1; i++) {\n\t\t\tif (info.base >= info.min &&\n\t\t\t\tinfo.base <= info.max) {\n\t\t\t\tvolt->vid[volt->vid_nr].uv = info.base;\n\t\t\t\tvolt->vid[volt->vid_nr].vid = i;\n\t\t\t\tvolt->vid_nr++;\n\t\t\t}\n\t\t\tinfo.base += info.step;\n\t\t}\n\t\tvolt->vid_mask = info.vidmask;\n\t} else if (data && info.vidmask && !info.ranged) {\n\t\tnvkm_debug(subdev, \"found entry based VIDs\\n\");\n\t\tvolt->min_uv = 0xffffffff;\n\t\tvolt->max_uv = 0;\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tdata = nvbios_volt_entry_parse(bios, i, &ver, &hdr,\n\t\t\t\t\t\t       &ivid);\n\t\t\tif (data) {\n\t\t\t\tvolt->vid[volt->vid_nr].uv = ivid.voltage;\n\t\t\t\tvolt->vid[volt->vid_nr].vid = ivid.vid;\n\t\t\t\tvolt->vid_nr++;\n\t\t\t\tvolt->min_uv = min(volt->min_uv, ivid.voltage);\n\t\t\t\tvolt->max_uv = max(volt->max_uv, ivid.voltage);\n\t\t\t}\n\t\t}\n\t\tvolt->vid_mask = info.vidmask;\n\t} else if (data && info.type == NVBIOS_VOLT_PWM) {\n\t\tvolt->min_uv = info.base;\n\t\tvolt->max_uv = info.base + info.pwm_range;\n\t}\n}\n\nstatic int\nnvkm_volt_speedo_read(struct nvkm_volt *volt)\n{\n\tif (volt->func->speedo_read)\n\t\treturn volt->func->speedo_read(volt);\n\treturn -EINVAL;\n}\n\nstatic int\nnvkm_volt_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_volt *volt = nvkm_volt(subdev);\n\tint ret = nvkm_volt_get(volt);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tnvkm_debug(subdev, \"current voltage unknown\\n\");\n\t\treturn 0;\n\t}\n\tnvkm_debug(subdev, \"current voltage: %duv\\n\", ret);\n\treturn 0;\n}\n\nstatic int\nnvkm_volt_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_volt *volt = nvkm_volt(subdev);\n\n\tvolt->speedo = nvkm_volt_speedo_read(volt);\n\tif (volt->speedo > 0)\n\t\tnvkm_debug(&volt->subdev, \"speedo %x\\n\", volt->speedo);\n\n\tif (volt->func->oneinit)\n\t\treturn volt->func->oneinit(volt);\n\n\treturn 0;\n}\n\nstatic void *\nnvkm_volt_dtor(struct nvkm_subdev *subdev)\n{\n\treturn nvkm_volt(subdev);\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_volt = {\n\t.dtor = nvkm_volt_dtor,\n\t.init = nvkm_volt_init,\n\t.oneinit = nvkm_volt_oneinit,\n};\n\nvoid\nnvkm_volt_ctor(const struct nvkm_volt_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_volt *volt)\n{\n\tstruct nvkm_bios *bios = device->bios;\n\tint i;\n\n\tnvkm_subdev_ctor(&nvkm_volt, device, type, inst, &volt->subdev);\n\tvolt->func = func;\n\n\t \n\tif (bios) {\n\t\tu8 ver, hdr, cnt, len;\n\t\tstruct nvbios_vmap vmap;\n\n\t\tnvkm_volt_parse_bios(bios, volt);\n\t\tnvkm_debug(&volt->subdev, \"min: %iuv max: %iuv\\n\",\n\t\t\t   volt->min_uv, volt->max_uv);\n\n\t\tif (nvbios_vmap_parse(bios, &ver, &hdr, &cnt, &len, &vmap)) {\n\t\t\tvolt->max0_id = vmap.max0;\n\t\t\tvolt->max1_id = vmap.max1;\n\t\t\tvolt->max2_id = vmap.max2;\n\t\t} else {\n\t\t\tvolt->max0_id = 0xff;\n\t\t\tvolt->max1_id = 0xff;\n\t\t\tvolt->max2_id = 0xff;\n\t\t}\n\t}\n\n\tif (volt->vid_nr) {\n\t\tfor (i = 0; i < volt->vid_nr; i++) {\n\t\t\tnvkm_debug(&volt->subdev, \"VID %02x: %duv\\n\",\n\t\t\t\t   volt->vid[i].vid, volt->vid[i].uv);\n\t\t}\n\t}\n}\n\nint\nnvkm_volt_new_(const struct nvkm_volt_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_volt **pvolt)\n{\n\tif (!(*pvolt = kzalloc(sizeof(**pvolt), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_volt_ctor(func, device, type, inst, *pvolt);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}