{
  "module_name": "vmmgp100.c",
  "hash_id": "af7db7031aae970f601bc57eaf2a17adadc88c8db89acb25d82bf78b9c1e73d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmgp100.c",
  "human_readable_source": " \n#include \"vmm.h\"\n\n#include <core/client.h>\n#include <subdev/fb.h>\n#include <subdev/ltc.h>\n#include <subdev/timer.h>\n#include <engine/gr.h>\n\n#include <nvif/ifc00d.h>\n#include <nvif/unpack.h>\n\nstatic void\ngp100_vmm_pfn_unmap(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tstruct device *dev = vmm->mmu->subdev.device->dev;\n\tdma_addr_t addr;\n\n\tnvkm_kmap(pt->memory);\n\twhile (ptes--) {\n\t\tu32 datalo = nvkm_ro32(pt->memory, pt->base + ptei * 8 + 0);\n\t\tu32 datahi = nvkm_ro32(pt->memory, pt->base + ptei * 8 + 4);\n\t\tu64 data   = (u64)datahi << 32 | datalo;\n\t\tif ((data & (3ULL << 1)) != 0) {\n\t\t\taddr = (data >> 8) << 12;\n\t\t\tdma_unmap_page(dev, addr, PAGE_SIZE, DMA_BIDIRECTIONAL);\n\t\t}\n\t\tptei++;\n\t}\n\tnvkm_done(pt->memory);\n}\n\nstatic bool\ngp100_vmm_pfn_clear(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tbool dma = false;\n\tnvkm_kmap(pt->memory);\n\twhile (ptes--) {\n\t\tu32 datalo = nvkm_ro32(pt->memory, pt->base + ptei * 8 + 0);\n\t\tu32 datahi = nvkm_ro32(pt->memory, pt->base + ptei * 8 + 4);\n\t\tu64 data   = (u64)datahi << 32 | datalo;\n\t\tif ((data & BIT_ULL(0)) && (data & (3ULL << 1)) != 0) {\n\t\t\tVMM_WO064(pt, vmm, ptei * 8, data & ~BIT_ULL(0));\n\t\t\tdma = true;\n\t\t}\n\t\tptei++;\n\t}\n\tnvkm_done(pt->memory);\n\treturn dma;\n}\n\nstatic void\ngp100_vmm_pgt_pfn(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tstruct device *dev = vmm->mmu->subdev.device->dev;\n\tdma_addr_t addr;\n\n\tnvkm_kmap(pt->memory);\n\tfor (; ptes; ptes--, map->pfn++) {\n\t\tu64 data = 0;\n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_V))\n\t\t\tcontinue;\n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_W))\n\t\t\tdata |= BIT_ULL(6);  \n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_A))\n\t\t\tdata |= BIT_ULL(7);  \n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_VRAM)) {\n\t\t\taddr = *map->pfn >> NVKM_VMM_PFN_ADDR_SHIFT;\n\t\t\taddr = dma_map_page(dev, pfn_to_page(addr), 0,\n\t\t\t\t\t    PAGE_SIZE, DMA_BIDIRECTIONAL);\n\t\t\tif (!WARN_ON(dma_mapping_error(dev, addr))) {\n\t\t\t\tdata |= addr >> 4;\n\t\t\t\tdata |= 2ULL << 1;  \n\t\t\t\tdata |= BIT_ULL(3);  \n\t\t\t\tdata |= BIT_ULL(0);  \n\t\t\t}\n\t\t} else {\n\t\t\tdata |= (*map->pfn & NVKM_VMM_PFN_ADDR) >> 4;\n\t\t\tdata |= BIT_ULL(0);  \n\t\t}\n\n\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t}\n\tnvkm_done(pt->memory);\n}\n\nstatic inline void\ngp100_vmm_pgt_pte(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map, u64 addr)\n{\n\tu64 data = (addr >> 4) | map->type;\n\n\tmap->type += ptes * map->ctag;\n\n\twhile (ptes--) {\n\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t\tdata += map->next;\n\t}\n}\n\nstatic void\ngp100_vmm_pgt_sgl(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_SGL(vmm, pt, ptei, ptes, map, gp100_vmm_pgt_pte);\n}\n\nstatic void\ngp100_vmm_pgt_dma(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tif (map->page->shift == PAGE_SHIFT) {\n\t\tVMM_SPAM(vmm, \"DMAA %08x %08x PTE(s)\", ptei, ptes);\n\t\tnvkm_kmap(pt->memory);\n\t\twhile (ptes--) {\n\t\t\tconst u64 data = (*map->dma++ >> 4) | map->type;\n\t\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t\t\tmap->type += map->ctag;\n\t\t}\n\t\tnvkm_done(pt->memory);\n\t\treturn;\n\t}\n\n\tVMM_MAP_ITER_DMA(vmm, pt, ptei, ptes, map, gp100_vmm_pgt_pte);\n}\n\nstatic void\ngp100_vmm_pgt_mem(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_MEM(vmm, pt, ptei, ptes, map, gp100_vmm_pgt_pte);\n}\n\nstatic void\ngp100_vmm_pgt_sparse(struct nvkm_vmm *vmm,\n\t\t     struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\t \n\tVMM_FO064(pt, vmm, ptei * 8, BIT_ULL(3)  , ptes);\n}\n\nstatic const struct nvkm_vmm_desc_func\ngp100_vmm_desc_spt = {\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.sparse = gp100_vmm_pgt_sparse,\n\t.mem = gp100_vmm_pgt_mem,\n\t.dma = gp100_vmm_pgt_dma,\n\t.sgl = gp100_vmm_pgt_sgl,\n\t.pfn = gp100_vmm_pgt_pfn,\n\t.pfn_clear = gp100_vmm_pfn_clear,\n\t.pfn_unmap = gp100_vmm_pfn_unmap,\n};\n\nstatic void\ngp100_vmm_lpt_invalid(struct nvkm_vmm *vmm,\n\t\t      struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\t \n\tVMM_FO064(pt, vmm, ptei * 8, BIT_ULL(5)  , ptes);\n}\n\nstatic const struct nvkm_vmm_desc_func\ngp100_vmm_desc_lpt = {\n\t.invalid = gp100_vmm_lpt_invalid,\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.sparse = gp100_vmm_pgt_sparse,\n\t.mem = gp100_vmm_pgt_mem,\n};\n\nstatic inline void\ngp100_vmm_pd0_pte(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map, u64 addr)\n{\n\tu64 data = (addr >> 4) | map->type;\n\n\tmap->type += ptes * map->ctag;\n\n\twhile (ptes--) {\n\t\tVMM_WO128(pt, vmm, ptei++ * 0x10, data, 0ULL);\n\t\tdata += map->next;\n\t}\n}\n\nstatic void\ngp100_vmm_pd0_mem(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_MEM(vmm, pt, ptei, ptes, map, gp100_vmm_pd0_pte);\n}\n\nstatic inline bool\ngp100_vmm_pde(struct nvkm_mmu_pt *pt, u64 *data)\n{\n\tswitch (nvkm_memory_target(pt->memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: *data |= 1ULL << 1; break;\n\tcase NVKM_MEM_TARGET_HOST: *data |= 2ULL << 1;\n\t\t*data |= BIT_ULL(3);  \n\t\tbreak;\n\tcase NVKM_MEM_TARGET_NCOH: *data |= 3ULL << 1; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn false;\n\t}\n\t*data |= pt->addr >> 4;\n\treturn true;\n}\n\nstatic void\ngp100_vmm_pd0_pde(struct nvkm_vmm *vmm, struct nvkm_vmm_pt *pgd, u32 pdei)\n{\n\tstruct nvkm_vmm_pt *pgt = pgd->pde[pdei];\n\tstruct nvkm_mmu_pt *pd = pgd->pt[0];\n\tu64 data[2] = {};\n\n\tif (pgt->pt[0] && !gp100_vmm_pde(pgt->pt[0], &data[0]))\n\t\treturn;\n\tif (pgt->pt[1] && !gp100_vmm_pde(pgt->pt[1], &data[1]))\n\t\treturn;\n\n\tnvkm_kmap(pd->memory);\n\tVMM_WO128(pd, vmm, pdei * 0x10, data[0], data[1]);\n\tnvkm_done(pd->memory);\n}\n\nstatic void\ngp100_vmm_pd0_sparse(struct nvkm_vmm *vmm,\n\t\t     struct nvkm_mmu_pt *pt, u32 pdei, u32 pdes)\n{\n\t \n\tVMM_FO128(pt, vmm, pdei * 0x10, BIT_ULL(3)  , 0ULL, pdes);\n}\n\nstatic void\ngp100_vmm_pd0_unmap(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_mmu_pt *pt, u32 pdei, u32 pdes)\n{\n\tVMM_FO128(pt, vmm, pdei * 0x10, 0ULL, 0ULL, pdes);\n}\n\nstatic void\ngp100_vmm_pd0_pfn_unmap(struct nvkm_vmm *vmm,\n\t\t\tstruct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tstruct device *dev = vmm->mmu->subdev.device->dev;\n\tdma_addr_t addr;\n\n\tnvkm_kmap(pt->memory);\n\twhile (ptes--) {\n\t\tu32 datalo = nvkm_ro32(pt->memory, pt->base + ptei * 16 + 0);\n\t\tu32 datahi = nvkm_ro32(pt->memory, pt->base + ptei * 16 + 4);\n\t\tu64 data   = (u64)datahi << 32 | datalo;\n\n\t\tif ((data & (3ULL << 1)) != 0) {\n\t\t\taddr = (data >> 8) << 12;\n\t\t\tdma_unmap_page(dev, addr, 1UL << 21, DMA_BIDIRECTIONAL);\n\t\t}\n\t\tptei++;\n\t}\n\tnvkm_done(pt->memory);\n}\n\nstatic bool\ngp100_vmm_pd0_pfn_clear(struct nvkm_vmm *vmm,\n\t\t\tstruct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tbool dma = false;\n\n\tnvkm_kmap(pt->memory);\n\twhile (ptes--) {\n\t\tu32 datalo = nvkm_ro32(pt->memory, pt->base + ptei * 16 + 0);\n\t\tu32 datahi = nvkm_ro32(pt->memory, pt->base + ptei * 16 + 4);\n\t\tu64 data   = (u64)datahi << 32 | datalo;\n\n\t\tif ((data & BIT_ULL(0)) && (data & (3ULL << 1)) != 0) {\n\t\t\tVMM_WO064(pt, vmm, ptei * 16, data & ~BIT_ULL(0));\n\t\t\tdma = true;\n\t\t}\n\t\tptei++;\n\t}\n\tnvkm_done(pt->memory);\n\treturn dma;\n}\n\nstatic void\ngp100_vmm_pd0_pfn(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tstruct device *dev = vmm->mmu->subdev.device->dev;\n\tdma_addr_t addr;\n\n\tnvkm_kmap(pt->memory);\n\tfor (; ptes; ptes--, map->pfn++) {\n\t\tu64 data = 0;\n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_V))\n\t\t\tcontinue;\n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_W))\n\t\t\tdata |= BIT_ULL(6);  \n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_A))\n\t\t\tdata |= BIT_ULL(7);  \n\n\t\tif (!(*map->pfn & NVKM_VMM_PFN_VRAM)) {\n\t\t\taddr = *map->pfn >> NVKM_VMM_PFN_ADDR_SHIFT;\n\t\t\taddr = dma_map_page(dev, pfn_to_page(addr), 0,\n\t\t\t\t\t    1UL << 21, DMA_BIDIRECTIONAL);\n\t\t\tif (!WARN_ON(dma_mapping_error(dev, addr))) {\n\t\t\t\tdata |= addr >> 4;\n\t\t\t\tdata |= 2ULL << 1;  \n\t\t\t\tdata |= BIT_ULL(3);  \n\t\t\t\tdata |= BIT_ULL(0);  \n\t\t\t}\n\t\t} else {\n\t\t\tdata |= (*map->pfn & NVKM_VMM_PFN_ADDR) >> 4;\n\t\t\tdata |= BIT_ULL(0);  \n\t\t}\n\n\t\tVMM_WO064(pt, vmm, ptei++ * 16, data);\n\t}\n\tnvkm_done(pt->memory);\n}\n\nstatic const struct nvkm_vmm_desc_func\ngp100_vmm_desc_pd0 = {\n\t.unmap = gp100_vmm_pd0_unmap,\n\t.sparse = gp100_vmm_pd0_sparse,\n\t.pde = gp100_vmm_pd0_pde,\n\t.mem = gp100_vmm_pd0_mem,\n\t.pfn = gp100_vmm_pd0_pfn,\n\t.pfn_clear = gp100_vmm_pd0_pfn_clear,\n\t.pfn_unmap = gp100_vmm_pd0_pfn_unmap,\n};\n\nstatic void\ngp100_vmm_pd1_pde(struct nvkm_vmm *vmm, struct nvkm_vmm_pt *pgd, u32 pdei)\n{\n\tstruct nvkm_vmm_pt *pgt = pgd->pde[pdei];\n\tstruct nvkm_mmu_pt *pd = pgd->pt[0];\n\tu64 data = 0;\n\n\tif (!gp100_vmm_pde(pgt->pt[0], &data))\n\t\treturn;\n\n\tnvkm_kmap(pd->memory);\n\tVMM_WO064(pd, vmm, pdei * 8, data);\n\tnvkm_done(pd->memory);\n}\n\nstatic const struct nvkm_vmm_desc_func\ngp100_vmm_desc_pd1 = {\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.sparse = gp100_vmm_pgt_sparse,\n\t.pde = gp100_vmm_pd1_pde,\n};\n\nconst struct nvkm_vmm_desc\ngp100_vmm_desc_16[] = {\n\t{ LPT, 5,  8, 0x0100, &gp100_vmm_desc_lpt },\n\t{ PGD, 8, 16, 0x1000, &gp100_vmm_desc_pd0 },\n\t{ PGD, 9,  8, 0x1000, &gp100_vmm_desc_pd1 },\n\t{ PGD, 9,  8, 0x1000, &gp100_vmm_desc_pd1 },\n\t{ PGD, 2,  8, 0x1000, &gp100_vmm_desc_pd1 },\n\t{}\n};\n\nconst struct nvkm_vmm_desc\ngp100_vmm_desc_12[] = {\n\t{ SPT, 9,  8, 0x1000, &gp100_vmm_desc_spt },\n\t{ PGD, 8, 16, 0x1000, &gp100_vmm_desc_pd0 },\n\t{ PGD, 9,  8, 0x1000, &gp100_vmm_desc_pd1 },\n\t{ PGD, 9,  8, 0x1000, &gp100_vmm_desc_pd1 },\n\t{ PGD, 2,  8, 0x1000, &gp100_vmm_desc_pd1 },\n\t{}\n};\n\nint\ngp100_vmm_valid(struct nvkm_vmm *vmm, void *argv, u32 argc,\n\t\tstruct nvkm_vmm_map *map)\n{\n\tconst enum nvkm_memory_target target = nvkm_memory_target(map->memory);\n\tconst struct nvkm_vmm_page *page = map->page;\n\tunion {\n\t\tstruct gp100_vmm_map_vn vn;\n\t\tstruct gp100_vmm_map_v0 v0;\n\t} *args = argv;\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tstruct nvkm_memory *memory = map->memory;\n\tu8  kind, kind_inv, priv, ro, vol;\n\tint kindn, aper, ret = -ENOSYS;\n\tconst u8 *kindm;\n\n\tmap->next = (1ULL << page->shift) >> 4;\n\tmap->type = 0;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\tvol  = !!args->v0.vol;\n\t\tro   = !!args->v0.ro;\n\t\tpriv = !!args->v0.priv;\n\t\tkind =   args->v0.kind;\n\t} else\n\tif (!(ret = nvif_unvers(ret, &argv, &argc, args->vn))) {\n\t\tvol  = target == NVKM_MEM_TARGET_HOST;\n\t\tro   = 0;\n\t\tpriv = 0;\n\t\tkind = 0x00;\n\t} else {\n\t\tVMM_DEBUG(vmm, \"args\");\n\t\treturn ret;\n\t}\n\n\taper = vmm->func->aper(target);\n\tif (WARN_ON(aper < 0))\n\t\treturn aper;\n\n\tkindm = vmm->mmu->func->kind(vmm->mmu, &kindn, &kind_inv);\n\tif (kind >= kindn || kindm[kind] == kind_inv) {\n\t\tVMM_DEBUG(vmm, \"kind %02x\", kind);\n\t\treturn -EINVAL;\n\t}\n\n\tif (kindm[kind] != kind) {\n\t\tu64 tags = nvkm_memory_size(memory) >> 16;\n\t\tif (aper != 0 || !(page->type & NVKM_VMM_PAGE_COMP)) {\n\t\t\tVMM_DEBUG(vmm, \"comp %d %02x\", aper, page->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!map->no_comp) {\n\t\t\tret = nvkm_memory_tags_get(memory, device, tags,\n\t\t\t\t\t\t   nvkm_ltc_tags_clear,\n\t\t\t\t\t\t   &map->tags);\n\t\t\tif (ret) {\n\t\t\t\tVMM_DEBUG(vmm, \"comp %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!map->no_comp && map->tags->mn) {\n\t\t\ttags = map->tags->mn->offset + (map->offset >> 16);\n\t\t\tmap->ctag |= ((1ULL << page->shift) >> 16) << 36;\n\t\t\tmap->type |= tags << 36;\n\t\t\tmap->next |= map->ctag;\n\t\t} else {\n\t\t\tkind = kindm[kind];\n\t\t}\n\t}\n\n\tmap->type |= BIT(0);\n\tmap->type |= (u64)aper << 1;\n\tmap->type |= (u64) vol << 3;\n\tmap->type |= (u64)priv << 5;\n\tmap->type |= (u64)  ro << 6;\n\tmap->type |= (u64)kind << 56;\n\treturn 0;\n}\n\nstatic int\ngp100_vmm_fault_cancel(struct nvkm_vmm *vmm, void *argv, u32 argc)\n{\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tunion {\n\t\tstruct gp100_vmm_fault_cancel_v0 v0;\n\t} *args = argv;\n\tint ret = -ENOSYS;\n\tu32 aper;\n\n\tif ((ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false)))\n\t\treturn ret;\n\n\t \n\taper = (args->v0.inst >> 8) & 3;\n\targs->v0.inst >>= 12;\n\targs->v0.inst |= aper << 28;\n\targs->v0.inst |= 0x80000000;\n\n\tif (!WARN_ON(nvkm_gr_ctxsw_pause(device))) {\n\t\tif (nvkm_gr_ctxsw_inst(device) == args->v0.inst) {\n\t\t\tgf100_vmm_invalidate(vmm, 0x0000001b\n\t\t\t\t\t       |\n\t\t\t\t\t     (args->v0.hub    << 20) |\n\t\t\t\t\t     (args->v0.gpc    << 15) |\n\t\t\t\t\t     (args->v0.client << 9));\n\t\t}\n\t\tWARN_ON(nvkm_gr_ctxsw_resume(device));\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngp100_vmm_fault_replay(struct nvkm_vmm *vmm, void *argv, u32 argc)\n{\n\tunion {\n\t\tstruct gp100_vmm_fault_replay_vn vn;\n\t} *args = argv;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unvers(ret, &argv, &argc, args->vn))) {\n\t\tgf100_vmm_invalidate(vmm, 0x0000000b);  \n\t}\n\n\treturn ret;\n}\n\nint\ngp100_vmm_mthd(struct nvkm_vmm *vmm,\n\t       struct nvkm_client *client, u32 mthd, void *argv, u32 argc)\n{\n\tswitch (mthd) {\n\tcase GP100_VMM_VN_FAULT_REPLAY:\n\t\treturn gp100_vmm_fault_replay(vmm, argv, argc);\n\tcase GP100_VMM_VN_FAULT_CANCEL:\n\t\treturn gp100_vmm_fault_cancel(vmm, argv, argc);\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\nvoid\ngp100_vmm_invalidate_pdb(struct nvkm_vmm *vmm, u64 addr)\n{\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tnvkm_wr32(device, 0x100cb8, lower_32_bits(addr));\n\tnvkm_wr32(device, 0x100cec, upper_32_bits(addr));\n}\n\nvoid\ngp100_vmm_flush(struct nvkm_vmm *vmm, int depth)\n{\n\tu32 type = (5   - depth) << 24;\n\tif (atomic_read(&vmm->engref[NVKM_SUBDEV_BAR]))\n\t\ttype |= 0x00000004;  \n\ttype |= 0x00000001;  \n\tgf100_vmm_invalidate(vmm, type);\n}\n\nint\ngp100_vmm_join(struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\tu64 base = BIT_ULL(10)   | BIT_ULL(11)  ;\n\tif (vmm->replay) {\n\t\tbase |= BIT_ULL(4);  \n\t\tbase |= BIT_ULL(5);  \n\t}\n\treturn gf100_vmm_join_(vmm, inst, base);\n}\n\nstatic const struct nvkm_vmm_func\ngp100_vmm = {\n\t.join = gp100_vmm_join,\n\t.part = gf100_vmm_part,\n\t.aper = gf100_vmm_aper,\n\t.valid = gp100_vmm_valid,\n\t.flush = gp100_vmm_flush,\n\t.mthd = gp100_vmm_mthd,\n\t.invalidate_pdb = gp100_vmm_invalidate_pdb,\n\t.page = {\n\t\t{ 47, &gp100_vmm_desc_16[4], NVKM_VMM_PAGE_Sxxx },\n\t\t{ 38, &gp100_vmm_desc_16[3], NVKM_VMM_PAGE_Sxxx },\n\t\t{ 29, &gp100_vmm_desc_16[2], NVKM_VMM_PAGE_Sxxx },\n\t\t{ 21, &gp100_vmm_desc_16[1], NVKM_VMM_PAGE_SVxC },\n\t\t{ 16, &gp100_vmm_desc_16[0], NVKM_VMM_PAGE_SVxC },\n\t\t{ 12, &gp100_vmm_desc_12[0], NVKM_VMM_PAGE_SVHx },\n\t\t{}\n\t}\n};\n\nint\ngp100_vmm_new_(const struct nvkm_vmm_func *func,\n\t       struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t       void *argv, u32 argc, struct lock_class_key *key,\n\t       const char *name, struct nvkm_vmm **pvmm)\n{\n\tunion {\n\t\tstruct gp100_vmm_vn vn;\n\t\tstruct gp100_vmm_v0 v0;\n\t} *args = argv;\n\tint ret = -ENOSYS;\n\tbool replay;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\treplay = args->v0.fault_replay != 0;\n\t} else\n\tif (!(ret = nvif_unvers(ret, &argv, &argc, args->vn))) {\n\t\treplay = false;\n\t} else\n\t\treturn ret;\n\n\tret = nvkm_vmm_new_(func, mmu, 0, managed, addr, size, key, name, pvmm);\n\tif (ret)\n\t\treturn ret;\n\n\t(*pvmm)->replay = replay;\n\treturn 0;\n}\n\nint\ngp100_vmm_new(struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t      void *argv, u32 argc, struct lock_class_key *key,\n\t      const char *name, struct nvkm_vmm **pvmm)\n{\n\treturn gp100_vmm_new_(&gp100_vmm, mmu, managed, addr, size,\n\t\t\t      argv, argc, key, name, pvmm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}