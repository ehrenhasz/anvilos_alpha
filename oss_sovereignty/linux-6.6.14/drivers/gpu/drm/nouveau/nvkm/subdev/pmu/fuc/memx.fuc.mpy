{
  "module_name": "memx.fuc",
  "hash_id": "8683173f58dde006e6064ad45894309ea4f8cfd30147638613ed5b03ecdeb610",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/fuc/memx.fuc",
  "human_readable_source": "/*\n * Copyright 2013 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n#ifdef INCLUDE_PROC\nprocess(PROC_MEMX, #memx_init, #memx_recv)\n#endif\n\n/******************************************************************************\n * MEMX data segment\n *****************************************************************************/\n#ifdef INCLUDE_DATA\n.equ #memx_opcode 0\n.equ #memx_header 2\n.equ #memx_length 4\n.equ #memx_func   8\n\n#define handler(cmd,hdr,len,func) /*\n*/\t.b16 MEMX_##cmd /*\n*/\t.b16 hdr /*\n*/\t.b16 len /*\n*/      .b16 0 /*\n*/\t.b32 func\n\nmemx_func_head:\nhandler(ENTER , 0x0000, 0x0000, #memx_func_enter)\nmemx_func_next:\nhandler(LEAVE , 0x0000, 0x0000, #memx_func_leave)\nhandler(WR32  , 0x0000, 0x0002, #memx_func_wr32)\nhandler(WAIT  , 0x0004, 0x0000, #memx_func_wait)\nhandler(DELAY , 0x0001, 0x0000, #memx_func_delay)\nhandler(VBLANK, 0x0001, 0x0000, #memx_func_wait_vblank)\nhandler(TRAIN , 0x0000, 0x0000, #memx_func_train)\nmemx_func_tail:\n\n.equ #memx_func_size #memx_func_next - #memx_func_head\n.equ #memx_func_num (#memx_func_tail - #memx_func_head) / #memx_func_size\n\nmemx_ts_start:\n.b32 0\nmemx_ts_end:\n.b32 0\n\nmemx_data_head:\n.skip 0x0800\nmemx_data_tail:\n\nmemx_train_head:\n.skip 0x0100\nmemx_train_tail:\n#endif\n\n/******************************************************************************\n * MEMX code segment\n *****************************************************************************/\n#ifdef INCLUDE_CODE\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_enter:\n#if NVKM_PPWR_CHIPSET == GT215\n\tmov $r8 0x1610\n\tnv_rd32($r7, $r8)\n\timm32($r6, 0xfffffffc)\n\tand $r7 $r6\n\tmov $r6 0x2\n\tor $r7 $r6\n\tnv_wr32($r8, $r7)\n#else\n\tmov $r6 0x001620\n\timm32($r7, ~0x00000aa2);\n\tnv_rd32($r8, $r6)\n\tand $r8 $r7\n\tnv_wr32($r6, $r8)\n\n\timm32($r7, ~0x00000001)\n\tnv_rd32($r8, $r6)\n\tand $r8 $r7\n\tnv_wr32($r6, $r8)\n\n\tmov $r6 0x0026f0\n\tnv_rd32($r8, $r6)\n\tand $r8 $r7\n\tnv_wr32($r6, $r8)\n#endif\n\n\tmov $r6 NV_PPWR_OUTPUT_SET_FB_PAUSE\n\tnv_iowr(NV_PPWR_OUTPUT_SET, $r6)\n\tmemx_func_enter_wait:\n\t\tnv_iord($r6, NV_PPWR_OUTPUT)\n\t\tand $r6 NV_PPWR_OUTPUT_FB_PAUSE\n\t\tbra z #memx_func_enter_wait\n\n\tnv_iord($r6, NV_PPWR_TIMER_LOW)\n\tst b32 D[$r0 + #memx_ts_start] $r6\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_leave:\n\tnv_iord($r6, NV_PPWR_TIMER_LOW)\n\tst b32 D[$r0 + #memx_ts_end] $r6\n\n\tmov $r6 NV_PPWR_OUTPUT_CLR_FB_PAUSE\n\tnv_iowr(NV_PPWR_OUTPUT_CLR, $r6)\n\tmemx_func_leave_wait:\n\t\tnv_iord($r6, NV_PPWR_OUTPUT)\n\t\tand $r6 NV_PPWR_OUTPUT_FB_PAUSE\n\t\tbra nz #memx_func_leave_wait\n\n#if NVKM_PPWR_CHIPSET == GT215\n\tmov $r8 0x1610\n\tnv_rd32($r7, $r8)\n\timm32($r6, 0xffffffcc)\n\tand $r7 $r6\n\tnv_wr32($r8, $r7)\n#else\n\tmov $r6 0x0026f0\n\timm32($r7, 0x00000001)\n\tnv_rd32($r8, $r6)\n\tor $r8 $r7\n\tnv_wr32($r6, $r8)\n\n\tmov $r6 0x001620\n\tnv_rd32($r8, $r6)\n\tor $r8 $r7\n\tnv_wr32($r6, $r8)\n\n\timm32($r7, 0x00000aa2);\n\tnv_rd32($r8, $r6)\n\tor $r8 $r7\n\tnv_wr32($r6, $r8)\n#endif\n\tret\n\n#if NVKM_PPWR_CHIPSET < GF119\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n//\t+00: head to wait for vblank on\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_wait_vblank:\n\tld b32 $r6 D[$r1 + 0x00]\n\tcmp b32 $r6 0x0\n\tbra z #memx_func_wait_vblank_head0\n\tcmp b32 $r6 0x1\n\tbra z #memx_func_wait_vblank_head1\n\tbra #memx_func_wait_vblank_fini\n\n\tmemx_func_wait_vblank_head1:\n\tmov $r7 0x20\n\tbra #memx_func_wait_vblank_0\n\n\tmemx_func_wait_vblank_head0:\n\tmov $r7 0x8\n\n\tmemx_func_wait_vblank_0:\n\t\tnv_iord($r6, NV_PPWR_INPUT)\n\t\tand $r6 $r7\n\t\tbra nz #memx_func_wait_vblank_0\n\n\tmemx_func_wait_vblank_1:\n\t\tnv_iord($r6, NV_PPWR_INPUT)\n\t\tand $r6 $r7\n\t\tbra z #memx_func_wait_vblank_1\n\n\tmemx_func_wait_vblank_fini:\n\tadd b32 $r1 0x4\n\tret\n\n#else\n\n// XXX: currently no-op\n//\n// $r15 - current (memx)\n// $r4  - packet length\n//\t+00: head to wait for vblank on\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_wait_vblank:\n\tadd b32 $r1 0x4\n\tret\n\n#endif\n\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n//\t+00*n: addr\n//\t+04*n: data\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_wr32:\n\tld b32 $r6 D[$r1 + 0x00]\n\tld b32 $r5 D[$r1 + 0x04]\n\tadd b32 $r1 0x08\n\tnv_wr32($r6, $r5)\n\tsub b32 $r4 0x02\n\tbra nz #memx_func_wr32\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n//\t+00: addr\n//\t+04: mask\n//\t+08: data\n//\t+0c: timeout (ns)\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_wait:\n\tnv_iord($r8, NV_PPWR_TIMER_LOW)\n\tld b32 $r14 D[$r1 + 0x00]\n\tld b32 $r13 D[$r1 + 0x04]\n\tld b32 $r12 D[$r1 + 0x08]\n\tld b32 $r11 D[$r1 + 0x0c]\n\tadd b32 $r1 0x10\n\tcall(wait)\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n//\t+00: time (ns)\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_delay:\n\tld b32 $r14 D[$r1 + 0x00]\n\tadd b32 $r1 0x04\n\tcall(nsec)\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r4  - packet length\n// $r3  - opcode desciption\n// $r0  - zero\nmemx_func_train:\n#if NVKM_PPWR_CHIPSET == GT215\n// $r5 - outer loop counter\n// $r6 - inner loop counter\n// $r7 - entry counter (#memx_train_head + $r7)\n\tmov $r5 0x3\n\tmov $r7 0x0\n\n// Read random memory to wake up... things\n\timm32($r9, 0x700000)\n\tnv_rd32($r8,$r9)\n\tmov $r14 0x2710\n\tcall(nsec)\n\n\tmemx_func_train_loop_outer:\n\t\tmulu $r8 $r5 0x101\n\t\tsethi $r8 0x02000000\n\t\timm32($r9, 0x1111e0)\n\t\tnv_wr32($r9, $r8)\n\t\tpush $r5\n\n\t\tmov $r6 0x0\n\t\tmemx_func_train_loop_inner:\n\t\t\tmov $r8 0x1111\n\t\t\tmulu $r9 $r6 $r8\n\t\t\tshl b32 $r8 $r9 0x10\n\t\t\tor $r8 $r9\n\t\t\timm32($r9, 0x100720)\n\t\t\tnv_wr32($r9, $r8)\n\n\t\t\timm32($r9, 0x100080)\n\t\t\tnv_rd32($r8, $r9)\n\t\t\tor $r8 $r8 0x20\n\t\t\tnv_wr32($r9, $r8)\n\n\t\t\timm32($r9, 0x10053c)\n\t\t\timm32($r8, 0x80003002)\n\t\t\tnv_wr32($r9, $r8)\n\n\t\t\timm32($r14, 0x100560)\n\t\t\timm32($r13, 0x80000000)\n\t\t\tadd b32 $r12 $r13 0\n\t\t\timm32($r11, 0x001e8480)\n\t\t\tcall(wait)\n\n\t\t\t// $r5 - inner inner loop counter\n\t\t\t// $r9 - result\n\t\t\tmov $r5 0\n\t\t\timm32($r9, 0x8300ffff)\n\t\t\tmemx_func_train_loop_4x:\n\t\t\t\timm32($r10, 0x100080)\n\t\t\t\tnv_rd32($r8, $r10)\n\t\t\t\timm32($r11, 0xffffffdf)\n\t\t\t\tand $r8 $r11\n\t\t\t\tnv_wr32($r10, $r8)\n\n\t\t\t\timm32($r10, 0x10053c)\n\t\t\t\timm32($r8, 0x80003002)\n\t\t\t\tnv_wr32($r10, $r8)\n\n\t\t\t\timm32($r14, 0x100560)\n\t\t\t\timm32($r13, 0x80000000)\n\t\t\t\tmov b32 $r12 $r13\n\t\t\t\timm32($r11, 0x00002710)\n\t\t\t\tcall(wait)\n\n\t\t\t\tnv_rd32($r13, $r14)\n\t\t\t\tand $r9 $r9 $r13\n\n\t\t\t\tadd b32 $r5 1\n\t\t\t\tcmp b16 $r5 0x4\n\t\t\t\tbra l #memx_func_train_loop_4x\n\n\t\t\tadd b32 $r10 $r7 #memx_train_head\n\t\t\tst b32 D[$r10 + 0] $r9\n\t\t\tadd b32 $r6 1\n\t\t\tadd b32 $r7 4\n\n\t\t\tcmp b16 $r6 0x10\n\t\t\tbra l #memx_func_train_loop_inner\n\n\t\tpop $r5\n\t\tadd b32 $r5 1\n\t\tcmp b16 $r5 7\n\t\tbra l #memx_func_train_loop_outer\n\n#endif\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r14 - sender process name\n// $r13 - message (exec)\n// $r12 - head of script\n// $r11 - tail of script\n// $r0  - zero\nmemx_exec:\n\tpush $r14\n\tpush $r13\n\tmov b32 $r1 $r12\n\tmov b32 $r2 $r11\n\n\tmemx_exec_next:\n\t\t// fetch the packet header\n\t\tld b32 $r3 D[$r1]\n\t\tadd b32 $r1 4\n\t\textr $r4 $r3 16:31\n\t\textr $r3 $r3 0:15\n\n\t\t// execute the opcode handler\n\t\tsub b32 $r3 1\n\t\tmulu $r3 #memx_func_size\n\t\tld b32 $r5 D[$r3 + #memx_func_head + #memx_func]\n\t\tcall $r5\n\n\t\t// keep going, if we haven't reached the end\n\t\tcmp b32 $r1 $r2\n\t\tbra l #memx_exec_next\n\n\t// send completion reply\n\tld b32 $r11 D[$r0 + #memx_ts_start]\n\tld b32 $r12 D[$r0 + #memx_ts_end]\n\tsub b32 $r12 $r11\n\tnv_iord($r11, NV_PPWR_INPUT)\n\tpop $r13\n\tpop $r14\n\tcall(send)\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r14 - sender process name\n// $r13 - message\n// $r12 - data0\n// $r11 - data1\n// $r0  - zero\nmemx_info:\n\tcmp b16 $r12 0x1\n\tbra e #memx_info_train\n\n\tmemx_info_data:\n\tmov $r12 #memx_data_head\n\tmov $r11 #memx_data_tail - #memx_data_head\n\tbra #memx_info_send\n\n\tmemx_info_train:\n\tmov $r12 #memx_train_head\n\tmov $r11 #memx_train_tail - #memx_train_head\n\n\tmemx_info_send:\n\tcall(send)\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r14 - sender process name\n// $r13 - message\n// $r12 - data0\n// $r11 - data1\n// $r0  - zero\nmemx_recv:\n\tcmp b32 $r13 MEMX_MSG_EXEC\n\tbra e #memx_exec\n\tcmp b32 $r13 MEMX_MSG_INFO\n\tbra e #memx_info\n\tret\n\n// description\n//\n// $r15 - current (memx)\n// $r0  - zero\nmemx_init:\n\tret\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}