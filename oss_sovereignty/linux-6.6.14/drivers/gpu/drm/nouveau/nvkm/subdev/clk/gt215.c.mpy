{
  "module_name": "gt215.c",
  "hash_id": "3a26b538894a3d37407fd1507d0c4d915e292afe5bdbe8974cf7df15468be222",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/gt215.c",
  "human_readable_source": " \n#define gt215_clk(p) container_of((p), struct gt215_clk, base)\n#include \"gt215.h\"\n#include \"pll.h\"\n\n#include <engine/fifo.h>\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n#include <subdev/timer.h>\n\nstruct gt215_clk {\n\tstruct nvkm_clk base;\n\tstruct gt215_clk_info eng[nv_clk_src_max];\n};\n\nstatic u32 read_clk(struct gt215_clk *, int, bool);\nstatic u32 read_pll(struct gt215_clk *, int, u32);\n\nstatic u32\nread_vco(struct gt215_clk *clk, int idx)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 sctl = nvkm_rd32(device, 0x4120 + (idx * 4));\n\n\tswitch (sctl & 0x00000030) {\n\tcase 0x00000000:\n\t\treturn device->crystal;\n\tcase 0x00000020:\n\t\treturn read_pll(clk, 0x41, 0x00e820);\n\tcase 0x00000030:\n\t\treturn read_pll(clk, 0x42, 0x00e8a0);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32\nread_clk(struct gt215_clk *clk, int idx, bool ignore_en)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 sctl, sdiv, sclk;\n\n\t \n\tif (idx >= 0x40) {\n\t\tif (device->chipset == 0xaf) {\n\t\t\t \n\t\t\treturn nvkm_rd32(device, 0x00471c) * 1000;\n\t\t}\n\n\t\treturn device->crystal;\n\t}\n\n\tsctl = nvkm_rd32(device, 0x4120 + (idx * 4));\n\tif (!ignore_en && !(sctl & 0x00000100))\n\t\treturn 0;\n\n\t \n\tif (sctl & 0x00000400)\n\t\treturn 108000;\n\n\t \n\tswitch (sctl & 0x00003000) {\n\tcase 0x00000000:\n\t\tif (!(sctl & 0x00000200))\n\t\t\treturn device->crystal;\n\t\treturn 0;\n\tcase 0x00002000:\n\t\tif (sctl & 0x00000040)\n\t\t\treturn 108000;\n\t\treturn 100000;\n\tcase 0x00003000:\n\t\t \n\t\tif (!(sctl & 0x00000001))\n\t\t\treturn 0;\n\n\t\tsclk = read_vco(clk, idx);\n\t\tsdiv = ((sctl & 0x003f0000) >> 16) + 2;\n\t\treturn (sclk * 2) / sdiv;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32\nread_pll(struct gt215_clk *clk, int idx, u32 pll)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ctrl = nvkm_rd32(device, pll + 0);\n\tu32 sclk = 0, P = 1, N = 1, M = 1;\n\tu32 MP;\n\n\tif (!(ctrl & 0x00000008)) {\n\t\tif (ctrl & 0x00000001) {\n\t\t\tu32 coef = nvkm_rd32(device, pll + 4);\n\t\t\tM = (coef & 0x000000ff) >> 0;\n\t\t\tN = (coef & 0x0000ff00) >> 8;\n\t\t\tP = (coef & 0x003f0000) >> 16;\n\n\t\t\t \n\t\t\tif ((pll & 0x00ff00) == 0x00e800)\n\t\t\t\tP = 1;\n\n\t\t\tsclk = read_clk(clk, 0x00 + idx, false);\n\t\t}\n\t} else {\n\t\tsclk = read_clk(clk, 0x10 + idx, false);\n\t}\n\n\tMP = M * P;\n\n\tif (!MP)\n\t\treturn 0;\n\n\treturn sclk * N / MP;\n}\n\nstatic int\ngt215_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\n{\n\tstruct gt215_clk *clk = gt215_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 hsrc;\n\n\tswitch (src) {\n\tcase nv_clk_src_crystal:\n\t\treturn device->crystal;\n\tcase nv_clk_src_core:\n\tcase nv_clk_src_core_intm:\n\t\treturn read_pll(clk, 0x00, 0x4200);\n\tcase nv_clk_src_shader:\n\t\treturn read_pll(clk, 0x01, 0x4220);\n\tcase nv_clk_src_mem:\n\t\treturn read_pll(clk, 0x02, 0x4000);\n\tcase nv_clk_src_disp:\n\t\treturn read_clk(clk, 0x20, false);\n\tcase nv_clk_src_vdec:\n\t\treturn read_clk(clk, 0x21, false);\n\tcase nv_clk_src_pmu:\n\t\treturn read_clk(clk, 0x25, false);\n\tcase nv_clk_src_host:\n\t\thsrc = (nvkm_rd32(device, 0xc040) & 0x30000000) >> 28;\n\t\tswitch (hsrc) {\n\t\tcase 0:\n\t\t\treturn read_clk(clk, 0x1d, false);\n\t\tcase 2:\n\t\tcase 3:\n\t\t\treturn 277000;\n\t\tdefault:\n\t\t\tnvkm_error(subdev, \"unknown HOST clock source %d\\n\", hsrc);\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\tnvkm_error(subdev, \"invalid clock source %d\\n\", src);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngt215_clk_info(struct nvkm_clk *base, int idx, u32 khz,\n\t       struct gt215_clk_info *info)\n{\n\tstruct gt215_clk *clk = gt215_clk(base);\n\tu32 oclk, sclk, sdiv;\n\ts32 diff;\n\n\tinfo->clk = 0;\n\n\tswitch (khz) {\n\tcase 27000:\n\t\tinfo->clk = 0x00000100;\n\t\treturn khz;\n\tcase 100000:\n\t\tinfo->clk = 0x00002100;\n\t\treturn khz;\n\tcase 108000:\n\t\tinfo->clk = 0x00002140;\n\t\treturn khz;\n\tdefault:\n\t\tsclk = read_vco(clk, idx);\n\t\tsdiv = min((sclk * 2) / khz, (u32)65);\n\t\toclk = (sclk * 2) / sdiv;\n\t\tdiff = ((khz + 3000) - oclk);\n\n\t\t \n\t\tif (diff < 0) {\n\t\t\tsdiv++;\n\t\t\toclk = (sclk * 2) / sdiv;\n\t\t}\n\n\t\t \n\t\tif (sdiv > 4) {\n\t\t\tinfo->clk = (((sdiv - 2) << 16) | 0x00003100);\n\t\t\treturn oclk;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn -ERANGE;\n}\n\nint\ngt215_pll_info(struct nvkm_clk *base, int idx, u32 pll, u32 khz,\n\t       struct gt215_clk_info *info)\n{\n\tstruct gt215_clk *clk = gt215_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvbios_pll limits;\n\tint P, N, M, diff;\n\tint ret;\n\n\tinfo->pll = 0;\n\n\t \n\tret = gt215_clk_info(&clk->base, idx, khz, info);\n\tdiff = khz - ret;\n\tif (!pll || (diff >= -2000 && diff < 3000)) {\n\t\tgoto out;\n\t}\n\n\t \n\tret = nvbios_pll_parse(subdev->device->bios, pll, &limits);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gt215_clk_info(&clk->base, idx - 0x10, limits.refclk, info);\n\tif (ret != limits.refclk)\n\t\treturn -EINVAL;\n\n\tret = gt215_pll_calc(subdev, &limits, khz, &N, NULL, &M, &P);\n\tif (ret >= 0) {\n\t\tinfo->pll = (P << 16) | (N << 8) | M;\n\t}\n\nout:\n\tinfo->fb_delay = max(((khz + 7566) / 15133), (u32) 18);\n\treturn ret ? ret : -ERANGE;\n}\n\nstatic int\ncalc_clk(struct gt215_clk *clk, struct nvkm_cstate *cstate,\n\t int idx, u32 pll, int dom)\n{\n\tint ret = gt215_pll_info(&clk->base, idx, pll, cstate->domain[dom],\n\t\t\t\t &clk->eng[dom]);\n\tif (ret >= 0)\n\t\treturn 0;\n\treturn ret;\n}\n\nstatic int\ncalc_host(struct gt215_clk *clk, struct nvkm_cstate *cstate)\n{\n\tint ret = 0;\n\tu32 kHz = cstate->domain[nv_clk_src_host];\n\tstruct gt215_clk_info *info = &clk->eng[nv_clk_src_host];\n\n\tif (kHz == 277000) {\n\t\tinfo->clk = 0;\n\t\tinfo->host_out = NVA3_HOST_277;\n\t\treturn 0;\n\t}\n\n\tinfo->host_out = NVA3_HOST_CLK;\n\n\tret = gt215_clk_info(&clk->base, 0x1d, kHz, info);\n\tif (ret >= 0)\n\t\treturn 0;\n\n\treturn ret;\n}\n\nint\ngt215_clk_pre(struct nvkm_clk *clk, unsigned long *flags)\n{\n\tstruct nvkm_device *device = clk->subdev.device;\n\tstruct nvkm_fifo *fifo = device->fifo;\n\n\t \n\tnvkm_mask(device, 0x020060, 0x00070000, 0x00000000);\n\tnvkm_mask(device, 0x002504, 0x00000001, 0x00000001);\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (!nvkm_rd32(device, 0x000100))\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -EBUSY;\n\n\tif (fifo)\n\t\tnvkm_fifo_pause(fifo, flags);\n\n\tif (nvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x002504) & 0x00000010)\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -EIO;\n\n\tif (nvkm_msec(device, 2000,\n\t\tu32 tmp = nvkm_rd32(device, 0x00251c) & 0x0000003f;\n\t\tif (tmp == 0x0000003f)\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nvoid\ngt215_clk_post(struct nvkm_clk *clk, unsigned long *flags)\n{\n\tstruct nvkm_device *device = clk->subdev.device;\n\tstruct nvkm_fifo *fifo = device->fifo;\n\n\tif (fifo && flags)\n\t\tnvkm_fifo_start(fifo, flags);\n\n\tnvkm_mask(device, 0x002504, 0x00000001, 0x00000000);\n\tnvkm_mask(device, 0x020060, 0x00070000, 0x00040000);\n}\n\nstatic void\ndisable_clk_src(struct gt215_clk *clk, u32 src)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tnvkm_mask(device, src, 0x00000100, 0x00000000);\n\tnvkm_mask(device, src, 0x00000001, 0x00000000);\n}\n\nstatic void\nprog_pll(struct gt215_clk *clk, int idx, u32 pll, int dom)\n{\n\tstruct gt215_clk_info *info = &clk->eng[dom];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tconst u32 src0 = 0x004120 + (idx * 4);\n\tconst u32 src1 = 0x004160 + (idx * 4);\n\tconst u32 ctrl = pll + 0;\n\tconst u32 coef = pll + 4;\n\tu32 bypass;\n\n\tif (info->pll) {\n\t\t \n\t\tbypass = nvkm_rd32(device, ctrl)  & 0x00000008;\n\t\tif (!bypass) {\n\t\t\tnvkm_mask(device, src1, 0x00000101, 0x00000101);\n\t\t\tnvkm_mask(device, ctrl, 0x00000008, 0x00000008);\n\t\t\tudelay(20);\n\t\t}\n\n\t\tnvkm_mask(device, src0, 0x003f3141, 0x00000101 | info->clk);\n\t\tnvkm_wr32(device, coef, info->pll);\n\t\tnvkm_mask(device, ctrl, 0x00000015, 0x00000015);\n\t\tnvkm_mask(device, ctrl, 0x00000010, 0x00000000);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (nvkm_rd32(device, ctrl) & 0x00020000)\n\t\t\t\tbreak;\n\t\t) < 0) {\n\t\t\tnvkm_mask(device, ctrl, 0x00000010, 0x00000010);\n\t\t\tnvkm_mask(device, src0, 0x00000101, 0x00000000);\n\t\t\treturn;\n\t\t}\n\t\tnvkm_mask(device, ctrl, 0x00000010, 0x00000010);\n\t\tnvkm_mask(device, ctrl, 0x00000008, 0x00000000);\n\t\tdisable_clk_src(clk, src1);\n\t} else {\n\t\tnvkm_mask(device, src1, 0x003f3141, 0x00000101 | info->clk);\n\t\tnvkm_mask(device, ctrl, 0x00000018, 0x00000018);\n\t\tudelay(20);\n\t\tnvkm_mask(device, ctrl, 0x00000001, 0x00000000);\n\t\tdisable_clk_src(clk, src0);\n\t}\n}\n\nstatic void\nprog_clk(struct gt215_clk *clk, int idx, int dom)\n{\n\tstruct gt215_clk_info *info = &clk->eng[dom];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tnvkm_mask(device, 0x004120 + (idx * 4), 0x003f3141, 0x00000101 | info->clk);\n}\n\nstatic void\nprog_host(struct gt215_clk *clk)\n{\n\tstruct gt215_clk_info *info = &clk->eng[nv_clk_src_host];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 hsrc = (nvkm_rd32(device, 0xc040));\n\n\tswitch (info->host_out) {\n\tcase NVA3_HOST_277:\n\t\tif ((hsrc & 0x30000000) == 0) {\n\t\t\tnvkm_wr32(device, 0xc040, hsrc | 0x20000000);\n\t\t\tdisable_clk_src(clk, 0x4194);\n\t\t}\n\t\tbreak;\n\tcase NVA3_HOST_CLK:\n\t\tprog_clk(clk, 0x1d, nv_clk_src_host);\n\t\tif ((hsrc & 0x30000000) >= 0x20000000) {\n\t\t\tnvkm_wr32(device, 0xc040, hsrc & ~0x30000000);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tnvkm_wr32(device, 0xc044, 0x3e);\n}\n\nstatic void\nprog_core(struct gt215_clk *clk, int dom)\n{\n\tstruct gt215_clk_info *info = &clk->eng[dom];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 fb_delay = nvkm_rd32(device, 0x10002c);\n\n\tif (fb_delay < info->fb_delay)\n\t\tnvkm_wr32(device, 0x10002c, info->fb_delay);\n\n\tprog_pll(clk, 0x00, 0x004200, dom);\n\n\tif (fb_delay > info->fb_delay)\n\t\tnvkm_wr32(device, 0x10002c, info->fb_delay);\n}\n\nstatic int\ngt215_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct gt215_clk *clk = gt215_clk(base);\n\tstruct gt215_clk_info *core = &clk->eng[nv_clk_src_core];\n\tint ret;\n\n\tif ((ret = calc_clk(clk, cstate, 0x10, 0x4200, nv_clk_src_core)) ||\n\t    (ret = calc_clk(clk, cstate, 0x11, 0x4220, nv_clk_src_shader)) ||\n\t    (ret = calc_clk(clk, cstate, 0x20, 0x0000, nv_clk_src_disp)) ||\n\t    (ret = calc_clk(clk, cstate, 0x21, 0x0000, nv_clk_src_vdec)) ||\n\t    (ret = calc_host(clk, cstate)))\n\t\treturn ret;\n\n\t \n\tif (core->pll) {\n\t\tret = gt215_clk_info(&clk->base, 0x10,\n\t\t\t\t     cstate->domain[nv_clk_src_core_intm],\n\t\t\t\t     &clk->eng[nv_clk_src_core_intm]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngt215_clk_prog(struct nvkm_clk *base)\n{\n\tstruct gt215_clk *clk = gt215_clk(base);\n\tstruct gt215_clk_info *core = &clk->eng[nv_clk_src_core];\n\tint ret = 0;\n\tunsigned long flags;\n\tunsigned long *f = &flags;\n\n\tret = gt215_clk_pre(&clk->base, f);\n\tif (ret)\n\t\tgoto out;\n\n\tif (core->pll)\n\t\tprog_core(clk, nv_clk_src_core_intm);\n\n\tprog_core(clk,  nv_clk_src_core);\n\tprog_pll(clk, 0x01, 0x004220, nv_clk_src_shader);\n\tprog_clk(clk, 0x20, nv_clk_src_disp);\n\tprog_clk(clk, 0x21, nv_clk_src_vdec);\n\tprog_host(clk);\n\nout:\n\tif (ret == -EBUSY)\n\t\tf = NULL;\n\n\tgt215_clk_post(&clk->base, f);\n\treturn ret;\n}\n\nstatic void\ngt215_clk_tidy(struct nvkm_clk *base)\n{\n}\n\nstatic const struct nvkm_clk_func\ngt215_clk = {\n\t.read = gt215_clk_read,\n\t.calc = gt215_clk_calc,\n\t.prog = gt215_clk_prog,\n\t.tidy = gt215_clk_tidy,\n\t.domains = {\n\t\t{ nv_clk_src_crystal  , 0xff },\n\t\t{ nv_clk_src_core     , 0x00, 0, \"core\", 1000 },\n\t\t{ nv_clk_src_shader   , 0x01, 0, \"shader\", 1000 },\n\t\t{ nv_clk_src_mem      , 0x02, 0, \"memory\", 1000 },\n\t\t{ nv_clk_src_vdec     , 0x03 },\n\t\t{ nv_clk_src_disp     , 0x04 },\n\t\t{ nv_clk_src_host     , 0x05 },\n\t\t{ nv_clk_src_core_intm, 0x06 },\n\t\t{ nv_clk_src_max }\n\t}\n};\n\nint\ngt215_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_clk **pclk)\n{\n\tstruct gt215_clk *clk;\n\n\tif (!(clk = kzalloc(sizeof(*clk), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base;\n\n\treturn nvkm_clk_ctor(&gt215_clk, device, type, inst, true, &clk->base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}