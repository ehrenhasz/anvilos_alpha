{
  "module_name": "base.c",
  "hash_id": "029d47b108914a8096bcf662d8c5905c6d2be22bd5cffb85bfb3374bfda3f407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fault/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n\nstatic void\nnvkm_fault_ntfy_fini(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fault *fault = container_of(event, typeof(*fault), event);\n\tfault->func->buffer.intr(fault->buffer[index], false);\n}\n\nstatic void\nnvkm_fault_ntfy_init(struct nvkm_event *event, int type, int index)\n{\n\tstruct nvkm_fault *fault = container_of(event, typeof(*fault), event);\n\tfault->func->buffer.intr(fault->buffer[index], true);\n}\n\nstatic const struct nvkm_event_func\nnvkm_fault_ntfy = {\n\t.init = nvkm_fault_ntfy_init,\n\t.fini = nvkm_fault_ntfy_fini,\n};\n\nstatic void\nnvkm_fault_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fault *fault = nvkm_fault(subdev);\n\treturn fault->func->intr(fault);\n}\n\nstatic int\nnvkm_fault_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_fault *fault = nvkm_fault(subdev);\n\tif (fault->func->fini)\n\t\tfault->func->fini(fault);\n\treturn 0;\n}\n\nstatic int\nnvkm_fault_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fault *fault = nvkm_fault(subdev);\n\tif (fault->func->init)\n\t\tfault->func->init(fault);\n\treturn 0;\n}\n\nstatic int\nnvkm_fault_oneinit_buffer(struct nvkm_fault *fault, int id)\n{\n\tstruct nvkm_subdev *subdev = &fault->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_fault_buffer *buffer;\n\tint ret;\n\n\tif (!(buffer = kzalloc(sizeof(*buffer), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tbuffer->fault = fault;\n\tbuffer->id = id;\n\tfault->func->buffer.info(buffer);\n\tfault->buffer[id] = buffer;\n\n\tnvkm_debug(subdev, \"buffer %d: %d entries\\n\", id, buffer->entries);\n\n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, buffer->entries *\n\t\t\t      fault->func->buffer.entry_size, 0x1000, true,\n\t\t\t      &buffer->mem);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tbuffer->addr = fault->func->buffer.pin(buffer);\n\tif (buffer->addr == ~0ULL)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int\nnvkm_fault_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fault *fault = nvkm_fault(subdev);\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fault->buffer); i++) {\n\t\tif (i < fault->func->buffer.nr) {\n\t\t\tret = nvkm_fault_oneinit_buffer(fault, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tfault->buffer_nr = i + 1;\n\t\t}\n\t}\n\n\tret = nvkm_event_init(&nvkm_fault_ntfy, subdev, 1, fault->buffer_nr, &fault->event);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fault->func->oneinit)\n\t\tret = fault->func->oneinit(fault);\n\treturn ret;\n}\n\nstatic void *\nnvkm_fault_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fault *fault = nvkm_fault(subdev);\n\tint i;\n\n\tnvkm_event_ntfy_del(&fault->nrpfb);\n\tnvkm_event_fini(&fault->event);\n\n\tfor (i = 0; i < fault->buffer_nr; i++) {\n\t\tif (fault->buffer[i]) {\n\t\t\tnvkm_memory_unref(&fault->buffer[i]->mem);\n\t\t\tkfree(fault->buffer[i]);\n\t\t}\n\t}\n\n\treturn fault;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_fault = {\n\t.dtor = nvkm_fault_dtor,\n\t.oneinit = nvkm_fault_oneinit,\n\t.init = nvkm_fault_init,\n\t.fini = nvkm_fault_fini,\n\t.intr = nvkm_fault_intr,\n};\n\nint\nnvkm_fault_new_(const struct nvkm_fault_func *func, struct nvkm_device *device,\n\t\tenum nvkm_subdev_type type, int inst, struct nvkm_fault **pfault)\n{\n\tstruct nvkm_fault *fault;\n\tif (!(fault = *pfault = kzalloc(sizeof(*fault), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_subdev_ctor(&nvkm_fault, device, type, inst, &fault->subdev);\n\tfault->func = func;\n\tfault->user.ctor = nvkm_ufault_new;\n\tfault->user.base = func->user.base;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}