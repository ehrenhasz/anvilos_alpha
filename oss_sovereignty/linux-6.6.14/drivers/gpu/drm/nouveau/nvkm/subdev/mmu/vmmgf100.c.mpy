{
  "module_name": "vmmgf100.c",
  "hash_id": "3a8017b2ff3fac4bf48f8074b90712f289e62773f76185ce923a01ef59fecaf6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmgf100.c",
  "human_readable_source": " \n#include \"vmm.h\"\n\n#include <subdev/fb.h>\n#include <subdev/ltc.h>\n#include <subdev/timer.h>\n\n#include <nvif/if900d.h>\n#include <nvif/unpack.h>\n\nstatic inline void\ngf100_vmm_pgt_pte(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map, u64 addr)\n{\n\tu64 base = (addr >> 8) | map->type;\n\tu64 data = base;\n\n\tif (map->ctag && !(map->next & (1ULL << 44))) {\n\t\twhile (ptes--) {\n\t\t\tdata = base | ((map->ctag >> 1) << 44);\n\t\t\tif (!(map->ctag++ & 1))\n\t\t\t\tdata |= BIT_ULL(60);\n\n\t\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t\t\tbase += map->next;\n\t\t}\n\t} else {\n\t\tmap->type += ptes * map->ctag;\n\n\t\twhile (ptes--) {\n\t\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t\t\tdata += map->next;\n\t\t}\n\t}\n}\n\nvoid\ngf100_vmm_pgt_sgl(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_SGL(vmm, pt, ptei, ptes, map, gf100_vmm_pgt_pte);\n}\n\nvoid\ngf100_vmm_pgt_dma(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tif (map->page->shift == PAGE_SHIFT) {\n\t\tVMM_SPAM(vmm, \"DMAA %08x %08x PTE(s)\", ptei, ptes);\n\t\tnvkm_kmap(pt->memory);\n\t\twhile (ptes--) {\n\t\t\tconst u64 data = (*map->dma++ >> 8) | map->type;\n\t\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t\t\tmap->type += map->ctag;\n\t\t}\n\t\tnvkm_done(pt->memory);\n\t\treturn;\n\t}\n\n\tVMM_MAP_ITER_DMA(vmm, pt, ptei, ptes, map, gf100_vmm_pgt_pte);\n}\n\nvoid\ngf100_vmm_pgt_mem(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t  u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_MEM(vmm, pt, ptei, ptes, map, gf100_vmm_pgt_pte);\n}\n\nvoid\ngf100_vmm_pgt_unmap(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tVMM_FO064(pt, vmm, ptei * 8, 0ULL, ptes);\n}\n\nconst struct nvkm_vmm_desc_func\ngf100_vmm_pgt = {\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.mem = gf100_vmm_pgt_mem,\n\t.dma = gf100_vmm_pgt_dma,\n\t.sgl = gf100_vmm_pgt_sgl,\n};\n\nvoid\ngf100_vmm_pgd_pde(struct nvkm_vmm *vmm, struct nvkm_vmm_pt *pgd, u32 pdei)\n{\n\tstruct nvkm_vmm_pt *pgt = pgd->pde[pdei];\n\tstruct nvkm_mmu_pt *pd = pgd->pt[0];\n\tstruct nvkm_mmu_pt *pt;\n\tu64 data = 0;\n\n\tif ((pt = pgt->pt[0])) {\n\t\tswitch (nvkm_memory_target(pt->memory)) {\n\t\tcase NVKM_MEM_TARGET_VRAM: data |= 1ULL << 0; break;\n\t\tcase NVKM_MEM_TARGET_HOST: data |= 2ULL << 0;\n\t\t\tdata |= BIT_ULL(35);  \n\t\t\tbreak;\n\t\tcase NVKM_MEM_TARGET_NCOH: data |= 3ULL << 0; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t\tdata |= pt->addr >> 8;\n\t}\n\n\tif ((pt = pgt->pt[1])) {\n\t\tswitch (nvkm_memory_target(pt->memory)) {\n\t\tcase NVKM_MEM_TARGET_VRAM: data |= 1ULL << 32; break;\n\t\tcase NVKM_MEM_TARGET_HOST: data |= 2ULL << 32;\n\t\t\tdata |= BIT_ULL(34);  \n\t\t\tbreak;\n\t\tcase NVKM_MEM_TARGET_NCOH: data |= 3ULL << 32; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t\tdata |= pt->addr << 24;\n\t}\n\n\tnvkm_kmap(pd->memory);\n\tVMM_WO064(pd, vmm, pdei * 8, data);\n\tnvkm_done(pd->memory);\n}\n\nconst struct nvkm_vmm_desc_func\ngf100_vmm_pgd = {\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.pde = gf100_vmm_pgd_pde,\n};\n\nstatic const struct nvkm_vmm_desc\ngf100_vmm_desc_17_12[] = {\n\t{ SPT, 15, 8, 0x1000, &gf100_vmm_pgt },\n\t{ PGD, 13, 8, 0x1000, &gf100_vmm_pgd },\n\t{}\n};\n\nstatic const struct nvkm_vmm_desc\ngf100_vmm_desc_17_17[] = {\n\t{ LPT, 10, 8, 0x1000, &gf100_vmm_pgt },\n\t{ PGD, 13, 8, 0x1000, &gf100_vmm_pgd },\n\t{}\n};\n\nstatic const struct nvkm_vmm_desc\ngf100_vmm_desc_16_12[] = {\n\t{ SPT, 14, 8, 0x1000, &gf100_vmm_pgt },\n\t{ PGD, 14, 8, 0x1000, &gf100_vmm_pgd },\n\t{}\n};\n\nstatic const struct nvkm_vmm_desc\ngf100_vmm_desc_16_16[] = {\n\t{ LPT, 10, 8, 0x1000, &gf100_vmm_pgt },\n\t{ PGD, 14, 8, 0x1000, &gf100_vmm_pgd },\n\t{}\n};\n\nvoid\ngf100_vmm_invalidate_pdb(struct nvkm_vmm *vmm, u64 addr)\n{\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tnvkm_wr32(device, 0x100cb8, addr);\n}\n\nvoid\ngf100_vmm_invalidate(struct nvkm_vmm *vmm, u32 type)\n{\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tstruct nvkm_mmu_pt *pd = vmm->pd->pt[0];\n\tu64 addr = 0;\n\n\tmutex_lock(&vmm->mmu->mutex);\n\t \n\tnvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x100c80) & 0x00ff0000)\n\t\t\tbreak;\n\t);\n\n\tif (!(type & 0x00000002)  ) {\n\t\tswitch (nvkm_memory_target(pd->memory)) {\n\t\tcase NVKM_MEM_TARGET_VRAM: addr |= 0x00000000; break;\n\t\tcase NVKM_MEM_TARGET_HOST: addr |= 0x00000002; break;\n\t\tcase NVKM_MEM_TARGET_NCOH: addr |= 0x00000003; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\taddr |= (vmm->pd->pt[0]->addr >> 12) << 4;\n\n\t\tvmm->func->invalidate_pdb(vmm, addr);\n\t}\n\n\tnvkm_wr32(device, 0x100cbc, 0x80000000 | type);\n\n\t \n\tnvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x100c80) & 0x00008000)\n\t\t\tbreak;\n\t);\n\tmutex_unlock(&vmm->mmu->mutex);\n}\n\nvoid\ngf100_vmm_flush(struct nvkm_vmm *vmm, int depth)\n{\n\tu32 type = 0x00000001;  \n\tif (atomic_read(&vmm->engref[NVKM_SUBDEV_BAR]))\n\t\ttype |= 0x00000004;  \n\tgf100_vmm_invalidate(vmm, type);\n}\n\nint\ngf100_vmm_valid(struct nvkm_vmm *vmm, void *argv, u32 argc,\n\t\tstruct nvkm_vmm_map *map)\n{\n\tconst enum nvkm_memory_target target = nvkm_memory_target(map->memory);\n\tconst struct nvkm_vmm_page *page = map->page;\n\tconst bool gm20x = page->desc->func->sparse != NULL;\n\tunion {\n\t\tstruct gf100_vmm_map_vn vn;\n\t\tstruct gf100_vmm_map_v0 v0;\n\t} *args = argv;\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tstruct nvkm_memory *memory = map->memory;\n\tu8  kind, kind_inv, priv, ro, vol;\n\tint kindn, aper, ret = -ENOSYS;\n\tconst u8 *kindm;\n\n\tmap->next = (1 << page->shift) >> 8;\n\tmap->type = map->ctag = 0;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\tvol  = !!args->v0.vol;\n\t\tro   = !!args->v0.ro;\n\t\tpriv = !!args->v0.priv;\n\t\tkind =   args->v0.kind;\n\t} else\n\tif (!(ret = nvif_unvers(ret, &argv, &argc, args->vn))) {\n\t\tvol  = target == NVKM_MEM_TARGET_HOST;\n\t\tro   = 0;\n\t\tpriv = 0;\n\t\tkind = 0x00;\n\t} else {\n\t\tVMM_DEBUG(vmm, \"args\");\n\t\treturn ret;\n\t}\n\n\taper = vmm->func->aper(target);\n\tif (WARN_ON(aper < 0))\n\t\treturn aper;\n\n\tkindm = vmm->mmu->func->kind(vmm->mmu, &kindn, &kind_inv);\n\tif (kind >= kindn || kindm[kind] == kind_inv) {\n\t\tVMM_DEBUG(vmm, \"kind %02x\", kind);\n\t\treturn -EINVAL;\n\t}\n\n\tif (kindm[kind] != kind) {\n\t\tu32 comp = (page->shift == 16 && !gm20x) ? 16 : 17;\n\t\tu32 tags = ALIGN(nvkm_memory_size(memory), 1 << 17) >> comp;\n\t\tif (aper != 0 || !(page->type & NVKM_VMM_PAGE_COMP)) {\n\t\t\tVMM_DEBUG(vmm, \"comp %d %02x\", aper, page->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!map->no_comp) {\n\t\t\tret = nvkm_memory_tags_get(memory, device, tags,\n\t\t\t\t\t\t   nvkm_ltc_tags_clear,\n\t\t\t\t\t\t   &map->tags);\n\t\t\tif (ret) {\n\t\t\t\tVMM_DEBUG(vmm, \"comp %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!map->no_comp && map->tags->mn) {\n\t\t\tu64 tags = map->tags->mn->offset + (map->offset >> 17);\n\t\t\tif (page->shift == 17 || !gm20x) {\n\t\t\t\tmap->type |= tags << 44;\n\t\t\t\tmap->ctag |= 1ULL << 44;\n\t\t\t\tmap->next |= 1ULL << 44;\n\t\t\t} else {\n\t\t\t\tmap->ctag |= tags << 1 | 1;\n\t\t\t}\n\t\t} else {\n\t\t\tkind = kindm[kind];\n\t\t}\n\t}\n\n\tmap->type |= BIT(0);\n\tmap->type |= (u64)priv << 1;\n\tmap->type |= (u64)  ro << 2;\n\tmap->type |= (u64) vol << 32;\n\tmap->type |= (u64)aper << 33;\n\tmap->type |= (u64)kind << 36;\n\treturn 0;\n}\n\nint\ngf100_vmm_aper(enum nvkm_memory_target target)\n{\n\tswitch (target) {\n\tcase NVKM_MEM_TARGET_VRAM: return 0;\n\tcase NVKM_MEM_TARGET_HOST: return 2;\n\tcase NVKM_MEM_TARGET_NCOH: return 3;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nvoid\ngf100_vmm_part(struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\tnvkm_fo64(inst, 0x0200, 0x00000000, 2);\n}\n\nint\ngf100_vmm_join_(struct nvkm_vmm *vmm, struct nvkm_memory *inst, u64 base)\n{\n\tstruct nvkm_mmu_pt *pd = vmm->pd->pt[0];\n\n\tswitch (nvkm_memory_target(pd->memory)) {\n\tcase NVKM_MEM_TARGET_VRAM: base |= 0ULL << 0; break;\n\tcase NVKM_MEM_TARGET_HOST: base |= 2ULL << 0;\n\t\tbase |= BIT_ULL(2)  ;\n\t\tbreak;\n\tcase NVKM_MEM_TARGET_NCOH: base |= 3ULL << 0; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tbase |= pd->addr;\n\n\tnvkm_kmap(inst);\n\tnvkm_wo64(inst, 0x0200, base);\n\tnvkm_wo64(inst, 0x0208, vmm->limit - 1);\n\tnvkm_done(inst);\n\treturn 0;\n}\n\nint\ngf100_vmm_join(struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\treturn gf100_vmm_join_(vmm, inst, 0);\n}\n\nstatic const struct nvkm_vmm_func\ngf100_vmm_17 = {\n\t.join = gf100_vmm_join,\n\t.part = gf100_vmm_part,\n\t.aper = gf100_vmm_aper,\n\t.valid = gf100_vmm_valid,\n\t.flush = gf100_vmm_flush,\n\t.invalidate_pdb = gf100_vmm_invalidate_pdb,\n\t.page = {\n\t\t{ 17, &gf100_vmm_desc_17_17[0], NVKM_VMM_PAGE_xVxC },\n\t\t{ 12, &gf100_vmm_desc_17_12[0], NVKM_VMM_PAGE_xVHx },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_vmm_func\ngf100_vmm_16 = {\n\t.join = gf100_vmm_join,\n\t.part = gf100_vmm_part,\n\t.aper = gf100_vmm_aper,\n\t.valid = gf100_vmm_valid,\n\t.flush = gf100_vmm_flush,\n\t.invalidate_pdb = gf100_vmm_invalidate_pdb,\n\t.page = {\n\t\t{ 16, &gf100_vmm_desc_16_16[0], NVKM_VMM_PAGE_xVxC },\n\t\t{ 12, &gf100_vmm_desc_16_12[0], NVKM_VMM_PAGE_xVHx },\n\t\t{}\n\t}\n};\n\nint\ngf100_vmm_new_(const struct nvkm_vmm_func *func_16,\n\t       const struct nvkm_vmm_func *func_17,\n\t       struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t       void *argv, u32 argc, struct lock_class_key *key,\n\t       const char *name, struct nvkm_vmm **pvmm)\n{\n\tswitch (mmu->subdev.device->fb->page) {\n\tcase 16: return nv04_vmm_new_(func_16, mmu, 0, managed, addr, size,\n\t\t\t\t      argv, argc, key, name, pvmm);\n\tcase 17: return nv04_vmm_new_(func_17, mmu, 0, managed, addr, size,\n\t\t\t\t      argv, argc, key, name, pvmm);\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n}\n\nint\ngf100_vmm_new(struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t      void *argv, u32 argc, struct lock_class_key *key,\n\t      const char *name, struct nvkm_vmm **pvmm)\n{\n\treturn gf100_vmm_new_(&gf100_vmm_16, &gf100_vmm_17, mmu, managed, addr,\n\t\t\t      size, argv, argc, key, name, pvmm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}