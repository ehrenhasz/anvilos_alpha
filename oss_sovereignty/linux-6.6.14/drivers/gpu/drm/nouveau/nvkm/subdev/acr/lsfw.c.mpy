{
  "module_name": "lsfw.c",
  "hash_id": "30e98e342cfe80aeccce1aee066b2873169fe8f821873d60726792b7a6be958a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/acr/lsfw.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include <core/falcon.h>\n#include <core/firmware.h>\n#include <nvfw/fw.h>\n#include <nvfw/ls.h>\n\nvoid\nnvkm_acr_lsfw_del(struct nvkm_acr_lsfw *lsfw)\n{\n\tnvkm_blob_dtor(&lsfw->img);\n\tkfree(lsfw->sigs);\n\tnvkm_firmware_put(lsfw->sig);\n\tlist_del(&lsfw->head);\n\tkfree(lsfw);\n}\n\nvoid\nnvkm_acr_lsfw_del_all(struct nvkm_acr *acr)\n{\n\tstruct nvkm_acr_lsfw *lsfw, *lsft;\n\tlist_for_each_entry_safe(lsfw, lsft, &acr->lsfw, head) {\n\t\tnvkm_acr_lsfw_del(lsfw);\n\t}\n}\n\nstatic struct nvkm_acr_lsfw *\nnvkm_acr_lsfw_get(struct nvkm_acr *acr, enum nvkm_acr_lsf_id id)\n{\n\tstruct nvkm_acr_lsfw *lsfw;\n\tlist_for_each_entry(lsfw, &acr->lsfw, head) {\n\t\tif (lsfw->id == id)\n\t\t\treturn lsfw;\n\t}\n\treturn NULL;\n}\n\nstruct nvkm_acr_lsfw *\nnvkm_acr_lsfw_add(const struct nvkm_acr_lsf_func *func, struct nvkm_acr *acr,\n\t\t struct nvkm_falcon *falcon, enum nvkm_acr_lsf_id id)\n{\n\tstruct nvkm_acr_lsfw *lsfw;\n\n\tif (!acr || list_empty(&acr->hsfw))\n\t\treturn ERR_PTR(-ENOSYS);\n\n\tlsfw = nvkm_acr_lsfw_get(acr, id);\n\tif (lsfw && lsfw->func) {\n\t\tnvkm_error(&acr->subdev, \"LSFW %d redefined\\n\", id);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\n\tif (!lsfw) {\n\t\tif (!(lsfw = kzalloc(sizeof(*lsfw), GFP_KERNEL)))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tlsfw->id = id;\n\t\tlist_add_tail(&lsfw->head, &acr->lsfw);\n\t}\n\n\tlsfw->func = func;\n\tlsfw->falcon = falcon;\n\treturn lsfw;\n}\n\nstatic struct nvkm_acr_lsfw *\nnvkm_acr_lsfw_load_sig_image_desc_(struct nvkm_subdev *subdev,\n\t\t\t\t   struct nvkm_falcon *falcon,\n\t\t\t\t   enum nvkm_acr_lsf_id id,\n\t\t\t\t   const char *path, int ver,\n\t\t\t\t   const struct nvkm_acr_lsf_func *func,\n\t\t\t\t   const struct firmware **pdesc)\n{\n\tstruct nvkm_acr *acr = subdev->device->acr;\n\tstruct nvkm_acr_lsfw *lsfw;\n\tint ret;\n\n\tif (IS_ERR((lsfw = nvkm_acr_lsfw_add(func, acr, falcon, id))))\n\t\treturn lsfw;\n\n\tret = nvkm_firmware_load_name(subdev, path, \"sig\", ver, &lsfw->sig);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nvkm_firmware_load_blob(subdev, path, \"image\", ver, &lsfw->img);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nvkm_firmware_load_name(subdev, path, \"desc\", ver, pdesc);\ndone:\n\tif (ret) {\n\t\tnvkm_acr_lsfw_del(lsfw);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn lsfw;\n}\n\nstatic void\nnvkm_acr_lsfw_from_desc(const struct nvfw_ls_desc_head *desc,\n\t\t\tstruct nvkm_acr_lsfw *lsfw)\n{\n\tlsfw->bootloader_size = ALIGN(desc->bootloader_size, 256);\n\tlsfw->bootloader_imem_offset = desc->bootloader_imem_offset;\n\n\tlsfw->app_size = ALIGN(desc->app_size, 256);\n\tlsfw->app_start_offset = desc->app_start_offset;\n\tlsfw->app_imem_entry = desc->app_imem_entry;\n\tlsfw->app_resident_code_offset = desc->app_resident_code_offset;\n\tlsfw->app_resident_code_size = desc->app_resident_code_size;\n\tlsfw->app_resident_data_offset = desc->app_resident_data_offset;\n\tlsfw->app_resident_data_size = desc->app_resident_data_size;\n\n\tlsfw->ucode_size = ALIGN(lsfw->app_resident_data_offset, 256) +\n\t\t\t   lsfw->bootloader_size;\n\tlsfw->data_size = lsfw->app_size + lsfw->bootloader_size -\n\t\t\t  lsfw->ucode_size;\n}\n\nint\nnvkm_acr_lsfw_load_sig_image_desc(struct nvkm_subdev *subdev,\n\t\t\t\t  struct nvkm_falcon *falcon,\n\t\t\t\t  enum nvkm_acr_lsf_id id,\n\t\t\t\t  const char *path, int ver,\n\t\t\t\t  const struct nvkm_acr_lsf_func *func)\n{\n\tconst struct firmware *fw;\n\tstruct nvkm_acr_lsfw *lsfw;\n\n\tlsfw = nvkm_acr_lsfw_load_sig_image_desc_(subdev, falcon, id, path, ver,\n\t\t\t\t\t\t  func, &fw);\n\tif (IS_ERR(lsfw))\n\t\treturn PTR_ERR(lsfw);\n\n\tnvkm_acr_lsfw_from_desc(&nvfw_ls_desc(subdev, fw->data)->head, lsfw);\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}\n\nint\nnvkm_acr_lsfw_load_sig_image_desc_v1(struct nvkm_subdev *subdev,\n\t\t\t\t     struct nvkm_falcon *falcon,\n\t\t\t\t     enum nvkm_acr_lsf_id id,\n\t\t\t\t     const char *path, int ver,\n\t\t\t\t     const struct nvkm_acr_lsf_func *func)\n{\n\tconst struct firmware *fw;\n\tstruct nvkm_acr_lsfw *lsfw;\n\n\tlsfw = nvkm_acr_lsfw_load_sig_image_desc_(subdev, falcon, id, path, ver,\n\t\t\t\t\t\t  func, &fw);\n\tif (IS_ERR(lsfw))\n\t\treturn PTR_ERR(lsfw);\n\n\tnvkm_acr_lsfw_from_desc(&nvfw_ls_desc_v1(subdev, fw->data)->head, lsfw);\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}\n\nint\nnvkm_acr_lsfw_load_sig_image_desc_v2(struct nvkm_subdev *subdev,\n\t\t\t\t     struct nvkm_falcon *falcon,\n\t\t\t\t     enum nvkm_acr_lsf_id id,\n\t\t\t\t     const char *path, int ver,\n\t\t\t\t     const struct nvkm_acr_lsf_func *func)\n{\n\tconst struct firmware *fw;\n\tstruct nvkm_acr_lsfw *lsfw;\n\tconst struct nvfw_ls_desc_v2 *desc;\n\tint ret = 0;\n\n\tlsfw = nvkm_acr_lsfw_load_sig_image_desc_(subdev, falcon, id, path, ver, func, &fw);\n\tif (IS_ERR(lsfw))\n\t\treturn PTR_ERR(lsfw);\n\n\tdesc = nvfw_ls_desc_v2(subdev, fw->data);\n\n\tlsfw->secure_bootloader = desc->secure_bootloader;\n\tlsfw->bootloader_size = ALIGN(desc->bootloader_size, 256);\n\tlsfw->bootloader_imem_offset = desc->bootloader_imem_offset;\n\n\tlsfw->app_size = ALIGN(desc->app_size, 256);\n\tlsfw->app_start_offset = desc->app_start_offset;\n\tlsfw->app_imem_entry = desc->app_imem_entry;\n\tlsfw->app_resident_code_offset = desc->app_resident_code_offset;\n\tlsfw->app_resident_code_size = desc->app_resident_code_size;\n\tlsfw->app_resident_data_offset = desc->app_resident_data_offset;\n\tlsfw->app_resident_data_size = desc->app_resident_data_size;\n\tlsfw->app_imem_offset = desc->app_imem_offset;\n\tlsfw->app_dmem_offset = desc->app_dmem_offset;\n\n\tlsfw->ucode_size = ALIGN(lsfw->app_resident_data_offset, 256) + lsfw->bootloader_size;\n\tlsfw->data_size = lsfw->app_size + lsfw->bootloader_size - lsfw->ucode_size;\n\n\tnvkm_firmware_put(fw);\n\n\tif (lsfw->secure_bootloader) {\n\t\tconst struct firmware *hsbl;\n\t\tconst struct nvfw_ls_hsbl_bin_hdr *hdr;\n\t\tconst struct nvfw_ls_hsbl_hdr *hshdr;\n\t\tu32 loc, sig, cnt, *meta;\n\n\t\tret = nvkm_firmware_load_name(subdev, path, \"hs_bl_sig\", ver, &hsbl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\thdr = nvfw_ls_hsbl_bin_hdr(subdev, hsbl->data);\n\t\thshdr = nvfw_ls_hsbl_hdr(subdev, hsbl->data + hdr->header_offset);\n\t\tmeta = (u32 *)(hsbl->data + hshdr->meta_data_offset);\n\t\tloc = *(u32 *)(hsbl->data + hshdr->patch_loc);\n\t\tsig = *(u32 *)(hsbl->data + hshdr->patch_sig);\n\t\tcnt = *(u32 *)(hsbl->data + hshdr->num_sig);\n\n\t\tlsfw->fuse_ver = meta[0];\n\t\tlsfw->engine_id = meta[1];\n\t\tlsfw->ucode_id = meta[2];\n\t\tlsfw->sig_size = hshdr->sig_prod_size / cnt;\n\t\tlsfw->sig_nr = cnt;\n\t\tlsfw->sigs = kmemdup(hsbl->data + hshdr->sig_prod_offset + sig,\n\t\t\t\t     lsfw->sig_nr * lsfw->sig_size, GFP_KERNEL);\n\t\tnvkm_firmware_put(hsbl);\n\t\tif (!lsfw->sigs)\n\t\t\tret = -ENOMEM;\n\t}\n\n\treturn ret;\n}\n\nint\nnvkm_acr_lsfw_load_bl_inst_data_sig(struct nvkm_subdev *subdev,\n\t\t\t\t    struct nvkm_falcon *falcon,\n\t\t\t\t    enum nvkm_acr_lsf_id id,\n\t\t\t\t    const char *path, int ver,\n\t\t\t\t    const struct nvkm_acr_lsf_func *func)\n{\n\tstruct nvkm_acr *acr = subdev->device->acr;\n\tstruct nvkm_acr_lsfw *lsfw;\n\tconst struct firmware *bl = NULL, *inst = NULL, *data = NULL;\n\tconst struct nvfw_bin_hdr *hdr;\n\tconst struct nvfw_bl_desc *desc;\n\tu32 *bldata;\n\tint ret;\n\n\tif (IS_ERR((lsfw = nvkm_acr_lsfw_add(func, acr, falcon, id))))\n\t\treturn PTR_ERR(lsfw);\n\n\tret = nvkm_firmware_load_name(subdev, path, \"bl\", ver, &bl);\n\tif (ret)\n\t\tgoto done;\n\n\thdr = nvfw_bin_hdr(subdev, bl->data);\n\tdesc = nvfw_bl_desc(subdev, bl->data + hdr->header_offset);\n\tbldata = (void *)(bl->data + hdr->data_offset);\n\n\tret = nvkm_firmware_load_name(subdev, path, \"inst\", ver, &inst);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nvkm_firmware_load_name(subdev, path, \"data\", ver, &data);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nvkm_firmware_load_name(subdev, path, \"sig\", ver, &lsfw->sig);\n\tif (ret)\n\t\tgoto done;\n\n\tlsfw->bootloader_size = ALIGN(desc->code_size, 256);\n\tlsfw->bootloader_imem_offset = desc->start_tag << 8;\n\n\tlsfw->app_start_offset = lsfw->bootloader_size;\n\tlsfw->app_imem_entry = 0;\n\tlsfw->app_resident_code_offset = 0;\n\tlsfw->app_resident_code_size = ALIGN(inst->size, 256);\n\tlsfw->app_resident_data_offset = lsfw->app_resident_code_size;\n\tlsfw->app_resident_data_size = ALIGN(data->size, 256);\n\tlsfw->app_size = lsfw->app_resident_code_size +\n\t\t\t lsfw->app_resident_data_size;\n\n\tlsfw->img.size = lsfw->bootloader_size + lsfw->app_size;\n\tif (!(lsfw->img.data = kzalloc(lsfw->img.size, GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tmemcpy(lsfw->img.data, bldata, lsfw->bootloader_size);\n\tmemcpy(lsfw->img.data + lsfw->app_start_offset +\n\t       lsfw->app_resident_code_offset, inst->data, inst->size);\n\tmemcpy(lsfw->img.data + lsfw->app_start_offset +\n\t       lsfw->app_resident_data_offset, data->data, data->size);\n\n\tlsfw->ucode_size = ALIGN(lsfw->app_resident_data_offset, 256) +\n\t\t\t   lsfw->bootloader_size;\n\tlsfw->data_size = lsfw->app_size + lsfw->bootloader_size -\n\t\t\t  lsfw->ucode_size;\n\ndone:\n\tif (ret)\n\t\tnvkm_acr_lsfw_del(lsfw);\n\tnvkm_firmware_put(data);\n\tnvkm_firmware_put(inst);\n\tnvkm_firmware_put(bl);\n\treturn ret;\n}\n\nint\nnvkm_acr_lsfw_load_bl_sig_net(struct nvkm_subdev *subdev,\n\t\t\t      struct nvkm_falcon *falcon,\n\t\t\t      enum nvkm_acr_lsf_id id,\n\t\t\t      const char *path, int ver,\n\t\t\t      const struct nvkm_acr_lsf_func *func,\n\t\t\t      const void *inst_data, u32 inst_size,\n\t\t\t      const void *data_data, u32 data_size)\n{\n\tstruct nvkm_acr *acr = subdev->device->acr;\n\tstruct nvkm_acr_lsfw *lsfw;\n\tconst struct firmware _inst = { .data = inst_data, .size = inst_size };\n\tconst struct firmware _data = { .data = data_data, .size = data_size };\n\tconst struct firmware *bl = NULL, *inst = &_inst, *data = &_data;\n\tconst struct {\n\t    int bin_magic;\n\t    int bin_version;\n\t    int bin_size;\n\t    int header_offset;\n\t    int header_size;\n\t} *hdr;\n\tu32 *bldata;\n\tint ret;\n\n\tif (IS_ERR((lsfw = nvkm_acr_lsfw_add(func, acr, falcon, id))))\n\t\treturn PTR_ERR(lsfw);\n\n\tret = nvkm_firmware_load_name(subdev, path, \"bl\", ver, &bl);\n\tif (ret)\n\t\tgoto done;\n\n\thdr = (const void *)bl->data;\n\tbldata = (void *)(bl->data + hdr->header_offset);\n\n\tret = nvkm_firmware_load_name(subdev, path, \"sig\", ver, &lsfw->sig);\n\tif (ret)\n\t\tgoto done;\n\n\tlsfw->bootloader_size = ALIGN(hdr->header_size, 256);\n\tlsfw->bootloader_imem_offset = func->bl_entry;\n\n\tlsfw->app_start_offset = lsfw->bootloader_size;\n\tlsfw->app_imem_entry = 0;\n\tlsfw->app_resident_code_offset = 0;\n\tlsfw->app_resident_code_size = ALIGN(inst->size, 256);\n\tlsfw->app_resident_data_offset = lsfw->app_resident_code_size;\n\tlsfw->app_resident_data_size = ALIGN(data->size, 256);\n\tlsfw->app_imem_offset = 0;\n\tlsfw->app_dmem_offset = 0;\n\tlsfw->app_size = lsfw->app_resident_code_size + lsfw->app_resident_data_size;\n\n\tlsfw->img.size = lsfw->bootloader_size + lsfw->app_size;\n\tif (!(lsfw->img.data = kzalloc(lsfw->img.size, GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tmemcpy(lsfw->img.data, bldata, lsfw->bootloader_size);\n\tmemcpy(lsfw->img.data + lsfw->app_start_offset +\n\t       lsfw->app_resident_code_offset, inst->data, inst->size);\n\tmemcpy(lsfw->img.data + lsfw->app_start_offset +\n\t       lsfw->app_resident_data_offset, data->data, data->size);\n\n\tlsfw->ucode_size = ALIGN(lsfw->app_resident_data_offset, 256) +\n\t\t\t   lsfw->bootloader_size;\n\tlsfw->data_size = lsfw->app_size + lsfw->bootloader_size -\n\t\t\t  lsfw->ucode_size;\n\ndone:\n\tif (ret)\n\t\tnvkm_acr_lsfw_del(lsfw);\n\tnvkm_firmware_put(bl);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}