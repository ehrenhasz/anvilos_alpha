{
  "module_name": "memx.c",
  "hash_id": "fd1bdf4ff96ad39ad27849ba159938461728212a058b3ffaf42155ff7f28927d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/memx.c",
  "human_readable_source": "\n#ifndef __NVKM_PMU_MEMX_H__\n#define __NVKM_PMU_MEMX_H__\n#include \"priv.h\"\n\nstruct nvkm_memx {\n\tstruct nvkm_pmu *pmu;\n\tu32 base;\n\tu32 size;\n\tstruct {\n\t\tu32 mthd;\n\t\tu32 size;\n\t\tu32 data[64];\n\t} c;\n};\n\nstatic void\nmemx_out(struct nvkm_memx *memx)\n{\n\tstruct nvkm_device *device = memx->pmu->subdev.device;\n\tint i;\n\n\tif (memx->c.mthd) {\n\t\tnvkm_wr32(device, 0x10a1c4, (memx->c.size << 16) | memx->c.mthd);\n\t\tfor (i = 0; i < memx->c.size; i++)\n\t\t\tnvkm_wr32(device, 0x10a1c4, memx->c.data[i]);\n\t\tmemx->c.mthd = 0;\n\t\tmemx->c.size = 0;\n\t}\n}\n\nstatic void\nmemx_cmd(struct nvkm_memx *memx, u32 mthd, u32 size, u32 data[])\n{\n\tif ((memx->c.size + size >= ARRAY_SIZE(memx->c.data)) ||\n\t    (memx->c.mthd && memx->c.mthd != mthd))\n\t\tmemx_out(memx);\n\tmemcpy(&memx->c.data[memx->c.size], data, size * sizeof(data[0]));\n\tmemx->c.size += size;\n\tmemx->c.mthd  = mthd;\n}\n\nint\nnvkm_memx_init(struct nvkm_pmu *pmu, struct nvkm_memx **pmemx)\n{\n\tstruct nvkm_device *device = pmu->subdev.device;\n\tstruct nvkm_memx *memx;\n\tu32 reply[2];\n\tint ret;\n\n\tret = nvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_INFO,\n\t\t\t    MEMX_INFO_DATA, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tmemx = *pmemx = kzalloc(sizeof(*memx), GFP_KERNEL);\n\tif (!memx)\n\t\treturn -ENOMEM;\n\tmemx->pmu = pmu;\n\tmemx->base = reply[0];\n\tmemx->size = reply[1];\n\n\t \n\tdo {\n\t\tnvkm_wr32(device, 0x10a580, 0x00000003);\n\t} while (nvkm_rd32(device, 0x10a580) != 0x00000003);\n\tnvkm_wr32(device, 0x10a1c0, 0x01000000 | memx->base);\n\treturn 0;\n}\n\nint\nnvkm_memx_fini(struct nvkm_memx **pmemx, bool exec)\n{\n\tstruct nvkm_memx *memx = *pmemx;\n\tstruct nvkm_pmu *pmu = memx->pmu;\n\tstruct nvkm_subdev *subdev = &pmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 finish, reply[2];\n\n\t \n\tmemx_out(memx);\n\n\t \n\tfinish = nvkm_rd32(device, 0x10a1c0) & 0x00ffffff;\n\tnvkm_wr32(device, 0x10a580, 0x00000000);\n\n\t \n\tif (exec) {\n\t\tnvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_EXEC,\n\t\t\t      memx->base, finish);\n\t\tnvkm_debug(subdev, \"Exec took %uns, PMU_IN %08x\\n\",\n\t\t\t   reply[0], reply[1]);\n\t}\n\n\tkfree(memx);\n\treturn 0;\n}\n\nvoid\nnvkm_memx_wr32(struct nvkm_memx *memx, u32 addr, u32 data)\n{\n\tnvkm_debug(&memx->pmu->subdev, \"R[%06x] = %08x\\n\", addr, data);\n\tmemx_cmd(memx, MEMX_WR32, 2, (u32[]){ addr, data });\n}\n\nvoid\nnvkm_memx_wait(struct nvkm_memx *memx,\n\t\t  u32 addr, u32 mask, u32 data, u32 nsec)\n{\n\tnvkm_debug(&memx->pmu->subdev, \"R[%06x] & %08x == %08x, %d us\\n\",\n\t\t   addr, mask, data, nsec);\n\tmemx_cmd(memx, MEMX_WAIT, 4, (u32[]){ addr, mask, data, nsec });\n\tmemx_out(memx);  \n}\n\nvoid\nnvkm_memx_nsec(struct nvkm_memx *memx, u32 nsec)\n{\n\tnvkm_debug(&memx->pmu->subdev, \"    DELAY = %d ns\\n\", nsec);\n\tmemx_cmd(memx, MEMX_DELAY, 1, (u32[]){ nsec });\n\tmemx_out(memx);  \n}\n\nvoid\nnvkm_memx_wait_vblank(struct nvkm_memx *memx)\n{\n\tstruct nvkm_subdev *subdev = &memx->pmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 heads, x, y, px = 0;\n\tint i, head_sync;\n\n\tif (device->chipset < 0xd0) {\n\t\theads = nvkm_rd32(device, 0x610050);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\t \n\t\t\tif (heads & (2 << (i << 3))) {\n\t\t\t\tx = nvkm_rd32(device, 0x610b40 + (0x540 * i));\n\t\t\t\ty = (x & 0xffff0000) >> 16;\n\t\t\t\tx &= 0x0000ffff;\n\t\t\t\tif ((x * y) > px) {\n\t\t\t\t\tpx = (x * y);\n\t\t\t\t\thead_sync = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (px == 0) {\n\t\tnvkm_debug(subdev, \"WAIT VBLANK !NO ACTIVE HEAD\\n\");\n\t\treturn;\n\t}\n\n\tnvkm_debug(subdev, \"WAIT VBLANK HEAD%d\\n\", head_sync);\n\tmemx_cmd(memx, MEMX_VBLANK, 1, (u32[]){ head_sync });\n\tmemx_out(memx);  \n}\n\nvoid\nnvkm_memx_train(struct nvkm_memx *memx)\n{\n\tnvkm_debug(&memx->pmu->subdev, \"   MEM TRAIN\\n\");\n\tmemx_cmd(memx, MEMX_TRAIN, 0, NULL);\n}\n\nint\nnvkm_memx_train_result(struct nvkm_pmu *pmu, u32 *res, int rsize)\n{\n\tstruct nvkm_device *device = pmu->subdev.device;\n\tu32 reply[2], base, size, i;\n\tint ret;\n\n\tret = nvkm_pmu_send(pmu, reply, PROC_MEMX, MEMX_MSG_INFO,\n\t\t\t    MEMX_INFO_TRAIN, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tbase = reply[0];\n\tsize = reply[1] >> 2;\n\tif (size > rsize)\n\t\treturn -ENOMEM;\n\n\t \n\tnvkm_wr32(device, 0x10a1c0, 0x02000000 | base);\n\n\tfor (i = 0; i < size; i++)\n\t\tres[i] = nvkm_rd32(device, 0x10a1c4);\n\n\treturn 0;\n}\n\nvoid\nnvkm_memx_block(struct nvkm_memx *memx)\n{\n\tnvkm_debug(&memx->pmu->subdev, \"   HOST BLOCKED\\n\");\n\tmemx_cmd(memx, MEMX_ENTER, 0, NULL);\n}\n\nvoid\nnvkm_memx_unblock(struct nvkm_memx *memx)\n{\n\tnvkm_debug(&memx->pmu->subdev, \"   HOST UNBLOCKED\\n\");\n\tmemx_cmd(memx, MEMX_LEAVE, 0, NULL);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}