{
  "module_name": "gv100.c",
  "hash_id": "911b0442960b57cb6d37561c89fc537f4efaef9e8f0d54cfa859178bfefc506a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fault/gv100.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n#include <subdev/mmu.h>\n#include <engine/fifo.h>\n\n#include <nvif/class.h>\n\nvoid\ngv100_fault_buffer_process(struct work_struct *work)\n{\n\tstruct nvkm_fault *fault = container_of(work, typeof(*fault), nrpfb_work);\n\tstruct nvkm_fault_buffer *buffer = fault->buffer[0];\n\tstruct nvkm_device *device = fault->subdev.device;\n\tstruct nvkm_memory *mem = buffer->mem;\n\tu32 get = nvkm_rd32(device, buffer->get);\n\tu32 put = nvkm_rd32(device, buffer->put);\n\tif (put == get)\n\t\treturn;\n\n\tnvkm_kmap(mem);\n\twhile (get != put) {\n\t\tconst u32   base = get * buffer->fault->func->buffer.entry_size;\n\t\tconst u32 instlo = nvkm_ro32(mem, base + 0x00);\n\t\tconst u32 insthi = nvkm_ro32(mem, base + 0x04);\n\t\tconst u32 addrlo = nvkm_ro32(mem, base + 0x08);\n\t\tconst u32 addrhi = nvkm_ro32(mem, base + 0x0c);\n\t\tconst u32 timelo = nvkm_ro32(mem, base + 0x10);\n\t\tconst u32 timehi = nvkm_ro32(mem, base + 0x14);\n\t\tconst u32  info0 = nvkm_ro32(mem, base + 0x18);\n\t\tconst u32  info1 = nvkm_ro32(mem, base + 0x1c);\n\t\tstruct nvkm_fault_data info;\n\n\t\tif (++get == buffer->entries)\n\t\t\tget = 0;\n\t\tnvkm_wr32(device, buffer->get, get);\n\n\t\tinfo.addr   = ((u64)addrhi << 32) | addrlo;\n\t\tinfo.inst   = ((u64)insthi << 32) | instlo;\n\t\tinfo.time   = ((u64)timehi << 32) | timelo;\n\t\tinfo.engine = (info0 & 0x000000ff);\n\t\tinfo.valid  = (info1 & 0x80000000) >> 31;\n\t\tinfo.gpc    = (info1 & 0x1f000000) >> 24;\n\t\tinfo.hub    = (info1 & 0x00100000) >> 20;\n\t\tinfo.access = (info1 & 0x000f0000) >> 16;\n\t\tinfo.client = (info1 & 0x00007f00) >> 8;\n\t\tinfo.reason = (info1 & 0x0000001f);\n\n\t\tnvkm_fifo_fault(device->fifo, &info);\n\t}\n\tnvkm_done(mem);\n}\n\nstatic void\ngv100_fault_buffer_intr(struct nvkm_fault_buffer *buffer, bool enable)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 intr = buffer->id ? 0x08000000 : 0x20000000;\n\tif (enable)\n\t\tnvkm_mask(device, 0x100a2c, intr, intr);\n\telse\n\t\tnvkm_mask(device, 0x100a34, intr, intr);\n}\n\nstatic void\ngv100_fault_buffer_fini(struct nvkm_fault_buffer *buffer)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 foff = buffer->id * 0x14;\n\tnvkm_mask(device, 0x100e34 + foff, 0x80000000, 0x00000000);\n}\n\nstatic void\ngv100_fault_buffer_init(struct nvkm_fault_buffer *buffer)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 foff = buffer->id * 0x14;\n\n\tnvkm_mask(device, 0x100e34 + foff, 0xc0000000, 0x40000000);\n\tnvkm_wr32(device, 0x100e28 + foff, upper_32_bits(buffer->addr));\n\tnvkm_wr32(device, 0x100e24 + foff, lower_32_bits(buffer->addr));\n\tnvkm_mask(device, 0x100e34 + foff, 0x80000000, 0x80000000);\n}\n\nstatic void\ngv100_fault_buffer_info(struct nvkm_fault_buffer *buffer)\n{\n\tstruct nvkm_device *device = buffer->fault->subdev.device;\n\tconst u32 foff = buffer->id * 0x14;\n\n\tnvkm_mask(device, 0x100e34 + foff, 0x40000000, 0x40000000);\n\n\tbuffer->entries = nvkm_rd32(device, 0x100e34 + foff) & 0x000fffff;\n\tbuffer->get = 0x100e2c + foff;\n\tbuffer->put = 0x100e30 + foff;\n}\n\nstatic int\ngv100_fault_ntfy_nrpfb(struct nvkm_event_ntfy *ntfy, u32 bits)\n{\n\tstruct nvkm_fault *fault = container_of(ntfy, typeof(*fault), nrpfb);\n\n\tschedule_work(&fault->nrpfb_work);\n\treturn NVKM_EVENT_KEEP;\n}\n\nstatic void\ngv100_fault_intr_fault(struct nvkm_fault *fault)\n{\n\tstruct nvkm_subdev *subdev = &fault->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct nvkm_fault_data info;\n\tconst u32 addrlo = nvkm_rd32(device, 0x100e4c);\n\tconst u32 addrhi = nvkm_rd32(device, 0x100e50);\n\tconst u32  info0 = nvkm_rd32(device, 0x100e54);\n\tconst u32 insthi = nvkm_rd32(device, 0x100e58);\n\tconst u32  info1 = nvkm_rd32(device, 0x100e5c);\n\n\tinfo.addr = ((u64)addrhi << 32) | addrlo;\n\tinfo.inst = ((u64)insthi << 32) | (info0 & 0xfffff000);\n\tinfo.time = 0;\n\tinfo.engine = (info0 & 0x000000ff);\n\tinfo.valid  = (info1 & 0x80000000) >> 31;\n\tinfo.gpc    = (info1 & 0x1f000000) >> 24;\n\tinfo.hub    = (info1 & 0x00100000) >> 20;\n\tinfo.access = (info1 & 0x000f0000) >> 16;\n\tinfo.client = (info1 & 0x00007f00) >> 8;\n\tinfo.reason = (info1 & 0x0000001f);\n\n\tnvkm_fifo_fault(device->fifo, &info);\n}\n\nstatic void\ngv100_fault_intr(struct nvkm_fault *fault)\n{\n\tstruct nvkm_subdev *subdev = &fault->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 stat = nvkm_rd32(device, 0x100a20);\n\n\tif (stat & 0x80000000) {\n\t\tgv100_fault_intr_fault(fault);\n\t\tnvkm_wr32(device, 0x100e60, 0x80000000);\n\t\tstat &= ~0x80000000;\n\t}\n\n\tif (stat & 0x20000000) {\n\t\tif (fault->buffer[0]) {\n\t\t\tnvkm_event_ntfy(&fault->event, 0, NVKM_FAULT_BUFFER_EVENT_PENDING);\n\t\t\tstat &= ~0x20000000;\n\t\t}\n\t}\n\n\tif (stat & 0x08000000) {\n\t\tif (fault->buffer[1]) {\n\t\t\tnvkm_event_ntfy(&fault->event, 1, NVKM_FAULT_BUFFER_EVENT_PENDING);\n\t\t\tstat &= ~0x08000000;\n\t\t}\n\t}\n\n\tif (stat) {\n\t\tnvkm_debug(subdev, \"intr %08x\\n\", stat);\n\t}\n}\n\nstatic void\ngv100_fault_fini(struct nvkm_fault *fault)\n{\n\tnvkm_event_ntfy_block(&fault->nrpfb);\n\tflush_work(&fault->nrpfb_work);\n\n\tif (fault->buffer[0])\n\t\tfault->func->buffer.fini(fault->buffer[0]);\n\n\tnvkm_mask(fault->subdev.device, 0x100a34, 0x80000000, 0x80000000);\n}\n\nstatic void\ngv100_fault_init(struct nvkm_fault *fault)\n{\n\tnvkm_mask(fault->subdev.device, 0x100a2c, 0x80000000, 0x80000000);\n\tfault->func->buffer.init(fault->buffer[0]);\n\tnvkm_event_ntfy_allow(&fault->nrpfb);\n}\n\nint\ngv100_fault_oneinit(struct nvkm_fault *fault)\n{\n\tnvkm_event_ntfy_add(&fault->event, 0, NVKM_FAULT_BUFFER_EVENT_PENDING, true,\n\t\t\t    gv100_fault_ntfy_nrpfb, &fault->nrpfb);\n\treturn 0;\n}\n\nstatic const struct nvkm_fault_func\ngv100_fault = {\n\t.oneinit = gv100_fault_oneinit,\n\t.init = gv100_fault_init,\n\t.fini = gv100_fault_fini,\n\t.intr = gv100_fault_intr,\n\t.buffer.nr = 2,\n\t.buffer.entry_size = 32,\n\t.buffer.info = gv100_fault_buffer_info,\n\t.buffer.pin = gp100_fault_buffer_pin,\n\t.buffer.init = gv100_fault_buffer_init,\n\t.buffer.fini = gv100_fault_buffer_fini,\n\t.buffer.intr = gv100_fault_buffer_intr,\n\t \n\t.user = { { 0, 0, VOLTA_FAULT_BUFFER_A }, 1 },\n};\n\nint\ngv100_fault_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\tstruct nvkm_fault **pfault)\n{\n\tint ret = nvkm_fault_new_(&gv100_fault, device, type, inst, pfault);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&(*pfault)->nrpfb_work, gv100_fault_buffer_process);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}