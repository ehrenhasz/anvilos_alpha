{
  "module_name": "gf100.c",
  "hash_id": "9a7b747fc9aa1bafcf806a0c6a0c5a5df254f86dde25277b4799a4f93695bfc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c",
  "human_readable_source": " \n#include \"gf100.h\"\n\n#include <core/memory.h>\n#include <core/option.h>\n#include <subdev/fb.h>\n#include <subdev/mmu.h>\n\nstruct nvkm_vmm *\ngf100_bar_bar1_vmm(struct nvkm_bar *base)\n{\n\treturn gf100_bar(base)->bar[1].vmm;\n}\n\nvoid\ngf100_bar_bar1_wait(struct nvkm_bar *base)\n{\n\t \n\tnvkm_bar_flush(base);\n\tnvkm_bar_flush(base);\n}\n\nvoid\ngf100_bar_bar1_fini(struct nvkm_bar *bar)\n{\n\tnvkm_mask(bar->subdev.device, 0x001704, 0x80000000, 0x00000000);\n}\n\nvoid\ngf100_bar_bar1_init(struct nvkm_bar *base)\n{\n\tstruct nvkm_device *device = base->subdev.device;\n\tstruct gf100_bar *bar = gf100_bar(base);\n\tconst u32 addr = nvkm_memory_addr(bar->bar[1].inst) >> 12;\n\tnvkm_wr32(device, 0x001704, 0x80000000 | addr);\n}\n\nstruct nvkm_vmm *\ngf100_bar_bar2_vmm(struct nvkm_bar *base)\n{\n\treturn gf100_bar(base)->bar[0].vmm;\n}\n\nvoid\ngf100_bar_bar2_fini(struct nvkm_bar *bar)\n{\n\tnvkm_mask(bar->subdev.device, 0x001714, 0x80000000, 0x00000000);\n}\n\nvoid\ngf100_bar_bar2_init(struct nvkm_bar *base)\n{\n\tstruct nvkm_device *device = base->subdev.device;\n\tstruct gf100_bar *bar = gf100_bar(base);\n\tu32 addr = nvkm_memory_addr(bar->bar[0].inst) >> 12;\n\tif (bar->bar2_halve)\n\t\taddr |= 0x40000000;\n\tnvkm_wr32(device, 0x001714, 0x80000000 | addr);\n}\n\nstatic int\ngf100_bar_oneinit_bar(struct gf100_bar *bar, struct gf100_barN *bar_vm,\n\t\t      struct lock_class_key *key, int bar_nr)\n{\n\tstruct nvkm_device *device = bar->base.subdev.device;\n\tresource_size_t bar_len;\n\tint ret;\n\n\tret = nvkm_memory_new(device, NVKM_MEM_TARGET_INST, 0x1000, 0, false,\n\t\t\t      &bar_vm->inst);\n\tif (ret)\n\t\treturn ret;\n\n\tbar_len = device->func->resource_size(device, bar_nr);\n\tif (!bar_len)\n\t\treturn -ENOMEM;\n\tif (bar_nr == 3 && bar->bar2_halve)\n\t\tbar_len >>= 1;\n\n\tret = nvkm_vmm_new(device, 0, bar_len, NULL, 0, key,\n\t\t\t   (bar_nr == 3) ? \"bar2\" : \"bar1\", &bar_vm->vmm);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_inc(&bar_vm->vmm->engref[NVKM_SUBDEV_BAR]);\n\tbar_vm->vmm->debug = bar->base.subdev.debug;\n\n\t \n\tif (bar_nr == 3) {\n\t\tret = nvkm_vmm_boot(bar_vm->vmm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn nvkm_vmm_join(bar_vm->vmm, bar_vm->inst);\n}\n\nint\ngf100_bar_oneinit(struct nvkm_bar *base)\n{\n\tstatic struct lock_class_key bar1_lock;\n\tstatic struct lock_class_key bar2_lock;\n\tstruct gf100_bar *bar = gf100_bar(base);\n\tint ret;\n\n\t \n\tif (bar->base.func->bar2.init) {\n\t\tret = gf100_bar_oneinit_bar(bar, &bar->bar[0], &bar2_lock, 3);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbar->base.subdev.oneinit = true;\n\t\tnvkm_bar_bar2_init(bar->base.subdev.device);\n\t}\n\n\t \n\tret = gf100_bar_oneinit_bar(bar, &bar->bar[1], &bar1_lock, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid *\ngf100_bar_dtor(struct nvkm_bar *base)\n{\n\tstruct gf100_bar *bar = gf100_bar(base);\n\n\tnvkm_vmm_part(bar->bar[1].vmm, bar->bar[1].inst);\n\tnvkm_vmm_unref(&bar->bar[1].vmm);\n\tnvkm_memory_unref(&bar->bar[1].inst);\n\n\tnvkm_vmm_part(bar->bar[0].vmm, bar->bar[0].inst);\n\tnvkm_vmm_unref(&bar->bar[0].vmm);\n\tnvkm_memory_unref(&bar->bar[0].inst);\n\treturn bar;\n}\n\nint\ngf100_bar_new_(const struct nvkm_bar_func *func, struct nvkm_device *device,\n\t       enum nvkm_subdev_type type, int inst, struct nvkm_bar **pbar)\n{\n\tstruct gf100_bar *bar;\n\tif (!(bar = kzalloc(sizeof(*bar), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_bar_ctor(func, device, type, inst, &bar->base);\n\tbar->bar2_halve = nvkm_boolopt(device->cfgopt, \"NvBar2Halve\", false);\n\t*pbar = &bar->base;\n\treturn 0;\n}\n\nstatic const struct nvkm_bar_func\ngf100_bar_func = {\n\t.dtor = gf100_bar_dtor,\n\t.oneinit = gf100_bar_oneinit,\n\t.bar1.init = gf100_bar_bar1_init,\n\t.bar1.fini = gf100_bar_bar1_fini,\n\t.bar1.wait = gf100_bar_bar1_wait,\n\t.bar1.vmm = gf100_bar_bar1_vmm,\n\t.bar2.init = gf100_bar_bar2_init,\n\t.bar2.fini = gf100_bar_bar2_fini,\n\t.bar2.wait = gf100_bar_bar1_wait,\n\t.bar2.vmm = gf100_bar_bar2_vmm,\n\t.flush = g84_bar_flush,\n};\n\nint\ngf100_bar_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_bar **pbar)\n{\n\treturn gf100_bar_new_(&gf100_bar_func, device, type, inst, pbar);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}