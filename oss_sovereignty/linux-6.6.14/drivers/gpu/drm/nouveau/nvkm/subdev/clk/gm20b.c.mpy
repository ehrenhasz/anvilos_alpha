{
  "module_name": "gm20b.c",
  "hash_id": "4dad79c0140457b4332d7ce1df2894a4e9999b85ce1a62d468b0a020154c732c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/gm20b.c",
  "human_readable_source": " \n\n#include <subdev/clk.h>\n#include <subdev/volt.h>\n#include <subdev/timer.h>\n#include <core/device.h>\n#include <core/tegra.h>\n\n#include \"priv.h\"\n#include \"gk20a.h\"\n\n#define GPCPLL_CFG_SYNC_MODE\tBIT(2)\n\n#define BYPASSCTRL_SYS\t(SYS_GPCPLL_CFG_BASE + 0x340)\n#define BYPASSCTRL_SYS_GPCPLL_SHIFT\t0\n#define BYPASSCTRL_SYS_GPCPLL_WIDTH\t1\n\n#define GPCPLL_CFG2_SDM_DIN_SHIFT\t0\n#define GPCPLL_CFG2_SDM_DIN_WIDTH\t8\n#define GPCPLL_CFG2_SDM_DIN_MASK\t\\\n\t(MASK(GPCPLL_CFG2_SDM_DIN_WIDTH) << GPCPLL_CFG2_SDM_DIN_SHIFT)\n#define GPCPLL_CFG2_SDM_DIN_NEW_SHIFT\t8\n#define GPCPLL_CFG2_SDM_DIN_NEW_WIDTH\t15\n#define GPCPLL_CFG2_SDM_DIN_NEW_MASK\t\\\n\t(MASK(GPCPLL_CFG2_SDM_DIN_NEW_WIDTH) << GPCPLL_CFG2_SDM_DIN_NEW_SHIFT)\n#define GPCPLL_CFG2_SETUP2_SHIFT\t16\n#define GPCPLL_CFG2_PLL_STEPA_SHIFT\t24\n\n#define GPCPLL_DVFS0\t(SYS_GPCPLL_CFG_BASE + 0x10)\n#define GPCPLL_DVFS0_DFS_COEFF_SHIFT\t0\n#define GPCPLL_DVFS0_DFS_COEFF_WIDTH\t7\n#define GPCPLL_DVFS0_DFS_COEFF_MASK\t\\\n\t(MASK(GPCPLL_DVFS0_DFS_COEFF_WIDTH) << GPCPLL_DVFS0_DFS_COEFF_SHIFT)\n#define GPCPLL_DVFS0_DFS_DET_MAX_SHIFT\t8\n#define GPCPLL_DVFS0_DFS_DET_MAX_WIDTH\t7\n#define GPCPLL_DVFS0_DFS_DET_MAX_MASK\t\\\n\t(MASK(GPCPLL_DVFS0_DFS_DET_MAX_WIDTH) << GPCPLL_DVFS0_DFS_DET_MAX_SHIFT)\n\n#define GPCPLL_DVFS1\t\t(SYS_GPCPLL_CFG_BASE + 0x14)\n#define GPCPLL_DVFS1_DFS_EXT_DET_SHIFT\t\t0\n#define GPCPLL_DVFS1_DFS_EXT_DET_WIDTH\t\t7\n#define GPCPLL_DVFS1_DFS_EXT_STRB_SHIFT\t\t7\n#define GPCPLL_DVFS1_DFS_EXT_STRB_WIDTH\t\t1\n#define GPCPLL_DVFS1_DFS_EXT_CAL_SHIFT\t\t8\n#define GPCPLL_DVFS1_DFS_EXT_CAL_WIDTH\t\t7\n#define GPCPLL_DVFS1_DFS_EXT_SEL_SHIFT\t\t15\n#define GPCPLL_DVFS1_DFS_EXT_SEL_WIDTH\t\t1\n#define GPCPLL_DVFS1_DFS_CTRL_SHIFT\t\t16\n#define GPCPLL_DVFS1_DFS_CTRL_WIDTH\t\t12\n#define GPCPLL_DVFS1_EN_SDM_SHIFT\t\t28\n#define GPCPLL_DVFS1_EN_SDM_WIDTH\t\t1\n#define GPCPLL_DVFS1_EN_SDM_BIT\t\t\tBIT(28)\n#define GPCPLL_DVFS1_EN_DFS_SHIFT\t\t29\n#define GPCPLL_DVFS1_EN_DFS_WIDTH\t\t1\n#define GPCPLL_DVFS1_EN_DFS_BIT\t\t\tBIT(29)\n#define GPCPLL_DVFS1_EN_DFS_CAL_SHIFT\t\t30\n#define GPCPLL_DVFS1_EN_DFS_CAL_WIDTH\t\t1\n#define GPCPLL_DVFS1_EN_DFS_CAL_BIT\t\tBIT(30)\n#define GPCPLL_DVFS1_DFS_CAL_DONE_SHIFT\t\t31\n#define GPCPLL_DVFS1_DFS_CAL_DONE_WIDTH\t\t1\n#define GPCPLL_DVFS1_DFS_CAL_DONE_BIT\t\tBIT(31)\n\n#define GPC_BCAST_GPCPLL_DVFS2\t(GPC_BCAST_GPCPLL_CFG_BASE + 0x20)\n#define GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT\tBIT(16)\n\n#define GPCPLL_CFG3_PLL_DFS_TESTOUT_SHIFT\t24\n#define GPCPLL_CFG3_PLL_DFS_TESTOUT_WIDTH\t7\n\n#define DFS_DET_RANGE\t6\t \n#define SDM_DIN_RANGE\t12\t \n\nstruct gm20b_clk_dvfs_params {\n\ts32 coeff_slope;\n\ts32 coeff_offs;\n\tu32 vco_ctrl;\n};\n\nstatic const struct gm20b_clk_dvfs_params gm20b_dvfs_params = {\n\t.coeff_slope = -165230,\n\t.coeff_offs = 214007,\n\t.vco_ctrl = 0x7 << 3,\n};\n\n \nstruct gm20b_pll {\n\tstruct gk20a_pll base;\n\tu32 sdm_din;\n};\n\nstruct gm20b_clk_dvfs {\n\tu32 dfs_coeff;\n\ts32 dfs_det_max;\n\ts32 dfs_ext_cal;\n};\n\nstruct gm20b_clk {\n\t \n\tstruct gk20a_clk base;\n\tstruct gm20b_clk_dvfs dvfs;\n\tu32 uv;\n\n\t \n\tstruct gk20a_pll new_pll;\n\tstruct gm20b_clk_dvfs new_dvfs;\n\tu32 new_uv;\n\n\tconst struct gm20b_clk_dvfs_params *dvfs_params;\n\n\t \n\ts32 uvdet_slope;\n\ts32 uvdet_offs;\n\n\t \n\tu32 safe_fmax_vmin;\n};\n#define gm20b_clk(p) container_of((gk20a_clk(p)), struct gm20b_clk, base)\n\nstatic u32 pl_to_div(u32 pl)\n{\n\treturn pl;\n}\n\nstatic u32 div_to_pl(u32 div)\n{\n\treturn div;\n}\n\nstatic const struct gk20a_clk_pllg_params gm20b_pllg_params = {\n\t.min_vco = 1300000, .max_vco = 2600000,\n\t.min_u = 12000, .max_u = 38400,\n\t.min_m = 1, .max_m = 255,\n\t.min_n = 8, .max_n = 255,\n\t.min_pl = 1, .max_pl = 31,\n};\n\nstatic void\ngm20b_pllg_read_mnp(struct gm20b_clk *clk, struct gm20b_pll *pll)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 val;\n\n\tgk20a_pllg_read_mnp(&clk->base, &pll->base);\n\tval = nvkm_rd32(device, GPCPLL_CFG2);\n\tpll->sdm_din = (val >> GPCPLL_CFG2_SDM_DIN_SHIFT) &\n\t\t       MASK(GPCPLL_CFG2_SDM_DIN_WIDTH);\n}\n\nstatic void\ngm20b_pllg_write_mnp(struct gm20b_clk *clk, const struct gm20b_pll *pll)\n{\n\tstruct nvkm_device *device = clk->base.base.subdev.device;\n\n\tnvkm_mask(device, GPCPLL_CFG2, GPCPLL_CFG2_SDM_DIN_MASK,\n\t\t  pll->sdm_din << GPCPLL_CFG2_SDM_DIN_SHIFT);\n\tgk20a_pllg_write_mnp(&clk->base, &pll->base);\n}\n\n \nstatic void\ngm20b_dvfs_calc_det_coeff(struct gm20b_clk *clk, s32 uv,\n\t\t\t  struct gm20b_clk_dvfs *dvfs)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tconst struct gm20b_clk_dvfs_params *p = clk->dvfs_params;\n\tu32 coeff;\n\t \n\ts32 mv = DIV_ROUND_CLOSEST(uv, 1000);\n\n\t \n\tcoeff = DIV_ROUND_CLOSEST(mv * p->coeff_slope, 1000) + p->coeff_offs;\n\tcoeff = DIV_ROUND_CLOSEST(coeff, 1000);\n\tdvfs->dfs_coeff = min_t(u32, coeff, MASK(GPCPLL_DVFS0_DFS_COEFF_WIDTH));\n\n\tdvfs->dfs_ext_cal = DIV_ROUND_CLOSEST(uv - clk->uvdet_offs,\n\t\t\t\t\t     clk->uvdet_slope);\n\t \n\tif (abs(dvfs->dfs_ext_cal) >= BIT(DFS_DET_RANGE))\n\t\tnvkm_error(subdev, \"dfs_ext_cal overflow!\\n\");\n\n\tdvfs->dfs_det_max = 0;\n\n\tnvkm_debug(subdev, \"%s uv: %d coeff: %x, ext_cal: %d, det_max: %d\\n\",\n\t\t   __func__, uv, dvfs->dfs_coeff, dvfs->dfs_ext_cal,\n\t\t   dvfs->dfs_det_max);\n}\n\n \nstatic void\ngm20b_dvfs_calc_ndiv(struct gm20b_clk *clk, u32 n_eff, u32 *n_int, u32 *sdm_din)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tconst struct gk20a_clk_pllg_params *p = clk->base.params;\n\tu32 n;\n\ts32 det_delta;\n\tu32 rem, rem_range;\n\n\t \n\tdet_delta = DIV_ROUND_CLOSEST(((s32)clk->uv) - clk->uvdet_offs,\n\t\t\t\t      clk->uvdet_slope);\n\tdet_delta -= clk->dvfs.dfs_ext_cal;\n\tdet_delta = min(det_delta, clk->dvfs.dfs_det_max);\n\tdet_delta *= clk->dvfs.dfs_coeff;\n\n\t \n\tn = (n_eff << DFS_DET_RANGE) - det_delta;\n\t \n\tif (n <= 0) {\n\t\tnvkm_error(subdev, \"ndiv <= 0 - setting to 1...\\n\");\n\t\tn = 1 << DFS_DET_RANGE;\n\t}\n\tif (n >> DFS_DET_RANGE > p->max_n) {\n\t\tnvkm_error(subdev, \"ndiv > max_n - setting to max_n...\\n\");\n\t\tn = p->max_n << DFS_DET_RANGE;\n\t}\n\t*n_int = n >> DFS_DET_RANGE;\n\n\t \n\trem = ((u32)n) & MASK(DFS_DET_RANGE);\n\trem_range = SDM_DIN_RANGE + 1 - DFS_DET_RANGE;\n\t \n\trem = (rem << rem_range) - BIT(SDM_DIN_RANGE);\n\t \n\t*sdm_din = (rem >> BITS_PER_BYTE) & MASK(GPCPLL_CFG2_SDM_DIN_WIDTH);\n\n\tnvkm_debug(subdev, \"%s n_eff: %d, n_int: %d, sdm_din: %d\\n\", __func__,\n\t\t   n_eff, *n_int, *sdm_din);\n}\n\nstatic int\ngm20b_pllg_slide(struct gm20b_clk *clk, u32 n)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gm20b_pll pll;\n\tu32 n_int, sdm_din;\n\tint ret = 0;\n\n\t \n\tgm20b_dvfs_calc_ndiv(clk, n, &n_int, &sdm_din);\n\n\t \n\tgm20b_pllg_read_mnp(clk, &pll);\n\t \n\tif (n_int == pll.base.n && sdm_din == pll.sdm_din)\n\t\treturn 0;\n\n\t \n\tnvkm_mask(device, GPCPLL_NDIV_SLOWDOWN,\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_SLOWDOWN_USING_PLL_SHIFT),\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_SLOWDOWN_USING_PLL_SHIFT));\n\n\t \n\t \n\tnvkm_mask(device, GPCPLL_CFG2, GPCPLL_CFG2_SDM_DIN_NEW_MASK,\n\t\t  sdm_din << GPCPLL_CFG2_SDM_DIN_NEW_SHIFT);\n\tpll.base.n = n_int;\n\tudelay(1);\n\tgk20a_pllg_write_mnp(&clk->base, &pll.base);\n\n\t \n\tudelay(1);\n\tnvkm_mask(device, GPCPLL_NDIV_SLOWDOWN,\n\t\t  BIT(GPCPLL_NDIV_SLOWDOWN_EN_DYNRAMP_SHIFT),\n\t\t  BIT(GPCPLL_NDIV_SLOWDOWN_EN_DYNRAMP_SHIFT));\n\n\t \n\tif (nvkm_wait_usec(device, 500, GPC_BCAST_NDIV_SLOWDOWN_DEBUG,\n\t\tGPC_BCAST_NDIV_SLOWDOWN_DEBUG_PLL_DYNRAMP_DONE_SYNCED_MASK,\n\t\tGPC_BCAST_NDIV_SLOWDOWN_DEBUG_PLL_DYNRAMP_DONE_SYNCED_MASK) < 0)\n\t\tret = -ETIMEDOUT;\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG2, GPCPLL_CFG2_SDM_DIN_MASK,\n\t\t  sdm_din << GPCPLL_CFG2_SDM_DIN_SHIFT);\n\n\t \n\tnvkm_mask(device, GPCPLL_NDIV_SLOWDOWN,\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_SLOWDOWN_USING_PLL_SHIFT) |\n\t\tBIT(GPCPLL_NDIV_SLOWDOWN_EN_DYNRAMP_SHIFT), 0);\n\tnvkm_rd32(device, GPCPLL_NDIV_SLOWDOWN);\n\n\treturn ret;\n}\n\nstatic int\ngm20b_pllg_enable(struct gm20b_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.base.subdev.device;\n\n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_ENABLE, GPCPLL_CFG_ENABLE);\n\tnvkm_rd32(device, GPCPLL_CFG);\n\n\t \n\tudelay(40);\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_SYNC_MODE,\n\t\t       GPCPLL_CFG_SYNC_MODE);\n\tnvkm_rd32(device, GPCPLL_CFG);\n\n\t \n\tnvkm_mask(device, SEL_VCO, BIT(SEL_VCO_GPC2CLK_OUT_SHIFT),\n\t\t  BIT(SEL_VCO_GPC2CLK_OUT_SHIFT));\n\n\treturn 0;\n}\n\nstatic void\ngm20b_pllg_disable(struct gm20b_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.base.subdev.device;\n\n\t \n\tnvkm_mask(device, SEL_VCO, BIT(SEL_VCO_GPC2CLK_OUT_SHIFT), 0);\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_SYNC_MODE, 0);\n\n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_ENABLE, 0);\n\tnvkm_rd32(device, GPCPLL_CFG);\n}\n\nstatic int\ngm20b_pllg_program_mnp(struct gm20b_clk *clk, const struct gk20a_pll *pll)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct gm20b_pll cur_pll;\n\tu32 n_int, sdm_din;\n\t \n\tbool pdiv_only;\n\tint ret;\n\n\tgm20b_dvfs_calc_ndiv(clk, pll->n, &n_int, &sdm_din);\n\tgm20b_pllg_read_mnp(clk, &cur_pll);\n\tpdiv_only = cur_pll.base.n == n_int && cur_pll.sdm_din == sdm_din &&\n\t\t    cur_pll.base.m == pll->m;\n\n\t \n\tif (!gk20a_pllg_is_enabled(&clk->base))\n\t\tpdiv_only = false;\n\n\t \n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV2 << GPC2CLK_OUT_VCODIV_SHIFT);\n\t \n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV2 << GPC2CLK_OUT_VCODIV_SHIFT);\n\tnvkm_rd32(device, GPC2CLK_OUT);\n\tudelay(2);\n\n\tif (pdiv_only) {\n\t\tu32 old = cur_pll.base.pl;\n\t\tu32 new = pll->pl;\n\n\t\t \n\t\tif ((old & new) == 0) {\n\t\t\tcur_pll.base.pl = min(old | BIT(ffs(new) - 1),\n\t\t\t\t\t      new | BIT(ffs(old) - 1));\n\t\t\tgk20a_pllg_write_mnp(&clk->base, &cur_pll.base);\n\t\t}\n\n\t\tcur_pll.base.pl = new;\n\t\tgk20a_pllg_write_mnp(&clk->base, &cur_pll.base);\n\t} else {\n\t\t \n\t\tgm20b_pllg_disable(clk);\n\n\t\tcur_pll.base = *pll;\n\t\tcur_pll.base.n = n_int;\n\t\tcur_pll.sdm_din = sdm_din;\n\t\tgm20b_pllg_write_mnp(clk, &cur_pll);\n\n\t\tret = gm20b_pllg_enable(clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tudelay(2);\n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV1 << GPC2CLK_OUT_VCODIV_SHIFT);\n\t \n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_VCODIV_MASK,\n\t\t  GPC2CLK_OUT_VCODIV1 << GPC2CLK_OUT_VCODIV_SHIFT);\n\tnvkm_rd32(device, GPC2CLK_OUT);\n\n\treturn 0;\n}\n\nstatic int\ngm20b_pllg_program_mnp_slide(struct gm20b_clk *clk, const struct gk20a_pll *pll)\n{\n\tstruct gk20a_pll cur_pll;\n\tint ret;\n\n\tif (gk20a_pllg_is_enabled(&clk->base)) {\n\t\tgk20a_pllg_read_mnp(&clk->base, &cur_pll);\n\n\t\t \n\t\tif (pll->m == cur_pll.m && pll->pl == cur_pll.pl)\n\t\t\treturn gm20b_pllg_slide(clk, pll->n);\n\n\t\t \n\t\tcur_pll.n = gk20a_pllg_n_lo(&clk->base, &cur_pll);\n\t\tret = gm20b_pllg_slide(clk, cur_pll.n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tcur_pll = *pll;\n\tcur_pll.n = gk20a_pllg_n_lo(&clk->base, &cur_pll);\n\tret = gm20b_pllg_program_mnp(clk, &cur_pll);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn gm20b_pllg_slide(clk, pll->n);\n}\n\nstatic int\ngm20b_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct gm20b_clk *clk = gm20b_clk(base);\n\tstruct nvkm_subdev *subdev = &base->subdev;\n\tstruct nvkm_volt *volt = base->subdev.device->volt;\n\tint ret;\n\n\tret = gk20a_pllg_calc_mnp(&clk->base, cstate->domain[nv_clk_src_gpc] *\n\t\t\t\t\t     GK20A_CLK_GPC_MDIV, &clk->new_pll);\n\tif (ret)\n\t\treturn ret;\n\n\tclk->new_uv = volt->vid[cstate->voltage].uv;\n\tgm20b_dvfs_calc_det_coeff(clk, clk->new_uv, &clk->new_dvfs);\n\n\tnvkm_debug(subdev, \"%s uv: %d uv\\n\", __func__, clk->new_uv);\n\n\treturn 0;\n}\n\n \nstatic void\ngm20b_dvfs_calc_safe_pll(struct gm20b_clk *clk, struct gk20a_pll *pll)\n{\n\tu32 rate = gk20a_pllg_calc_rate(&clk->base, pll) / KHZ;\n\tu32 parent_rate = clk->base.parent_rate / KHZ;\n\tu32 nmin, nsafe;\n\n\t \n\tif (rate > clk->safe_fmax_vmin)\n\t\trate = rate * (100 - 10) / 100;\n\n\t \n\trate *= 2;\n\n\tnmin = DIV_ROUND_UP(pll->m * clk->base.params->min_vco, parent_rate);\n\tnsafe = pll->m * rate / (clk->base.parent_rate);\n\n\tif (nsafe < nmin) {\n\t\tpll->pl = DIV_ROUND_UP(nmin * parent_rate, pll->m * rate);\n\t\tnsafe = nmin;\n\t}\n\n\tpll->n = nsafe;\n}\n\nstatic void\ngm20b_dvfs_program_coeff(struct gm20b_clk *clk, u32 coeff)\n{\n\tstruct nvkm_device *device = clk->base.base.subdev.device;\n\n\t \n\tnvkm_mask(device, GPC_BCAST_GPCPLL_DVFS2,\n\t\t  GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT,\n\t\t  GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT);\n\n\tnvkm_mask(device, GPCPLL_DVFS0, GPCPLL_DVFS0_DFS_COEFF_MASK,\n\t\t  coeff << GPCPLL_DVFS0_DFS_COEFF_SHIFT);\n\n\tudelay(1);\n\tnvkm_mask(device, GPC_BCAST_GPCPLL_DVFS2,\n\t\t  GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT, 0);\n}\n\nstatic void\ngm20b_dvfs_program_ext_cal(struct gm20b_clk *clk, u32 dfs_det_cal)\n{\n\tstruct nvkm_device *device = clk->base.base.subdev.device;\n\tu32 val;\n\n\tnvkm_mask(device, GPC_BCAST_GPCPLL_DVFS2, MASK(DFS_DET_RANGE + 1),\n\t\t  dfs_det_cal);\n\tudelay(1);\n\n\tval = nvkm_rd32(device, GPCPLL_DVFS1);\n\tif (!(val & BIT(25))) {\n\t\t \n\t\tval |= BIT(25) | BIT(16);\n\t\tnvkm_wr32(device, GPCPLL_DVFS1, val);\n\t}\n}\n\nstatic void\ngm20b_dvfs_program_dfs_detection(struct gm20b_clk *clk,\n\t\t\t\t struct gm20b_clk_dvfs *dvfs)\n{\n\tstruct nvkm_device *device = clk->base.base.subdev.device;\n\n\t \n\tnvkm_mask(device, GPC_BCAST_GPCPLL_DVFS2,\n\t\t  GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT,\n\t\t  GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT);\n\n\tnvkm_mask(device, GPCPLL_DVFS0,\n\t\t  GPCPLL_DVFS0_DFS_COEFF_MASK | GPCPLL_DVFS0_DFS_DET_MAX_MASK,\n\t\t  dvfs->dfs_coeff << GPCPLL_DVFS0_DFS_COEFF_SHIFT |\n\t\t  dvfs->dfs_det_max << GPCPLL_DVFS0_DFS_DET_MAX_SHIFT);\n\n\tudelay(1);\n\tnvkm_mask(device, GPC_BCAST_GPCPLL_DVFS2,\n\t\t  GPC_BCAST_GPCPLL_DVFS2_DFS_EXT_STROBE_BIT, 0);\n\n\tgm20b_dvfs_program_ext_cal(clk, dvfs->dfs_ext_cal);\n}\n\nstatic int\ngm20b_clk_prog(struct nvkm_clk *base)\n{\n\tstruct gm20b_clk *clk = gm20b_clk(base);\n\tu32 cur_freq;\n\tint ret;\n\n\t \n\tif (clk->uv == clk->new_uv)\n\t\tgoto prog;\n\n\t \n\tcur_freq = nvkm_clk_read(&clk->base.base, nv_clk_src_gpc);\n\tif (cur_freq > clk->safe_fmax_vmin) {\n\t\tstruct gk20a_pll pll_safe;\n\n\t\tif (clk->uv < clk->new_uv)\n\t\t\t \n\t\t\tpll_safe = clk->base.pll;\n\t\telse\n\t\t\t \n\t\t\tpll_safe = clk->new_pll;\n\n\t\tgm20b_dvfs_calc_safe_pll(clk, &pll_safe);\n\t\tret = gm20b_pllg_program_mnp_slide(clk, &pll_safe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tgm20b_dvfs_program_coeff(clk, 0);\n\tgm20b_dvfs_program_ext_cal(clk, clk->new_dvfs.dfs_ext_cal);\n\tgm20b_dvfs_program_coeff(clk, clk->new_dvfs.dfs_coeff);\n\tgm20b_dvfs_program_dfs_detection(clk, &clk->new_dvfs);\n\nprog:\n\tclk->uv = clk->new_uv;\n\tclk->dvfs = clk->new_dvfs;\n\tclk->base.pll = clk->new_pll;\n\n\treturn gm20b_pllg_program_mnp_slide(clk, &clk->base.pll);\n}\n\nstatic struct nvkm_pstate\ngm20b_pstates[] = {\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 76800,\n\t\t\t.voltage = 0,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 153600,\n\t\t\t.voltage = 1,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 230400,\n\t\t\t.voltage = 2,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 307200,\n\t\t\t.voltage = 3,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 384000,\n\t\t\t.voltage = 4,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 460800,\n\t\t\t.voltage = 5,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 537600,\n\t\t\t.voltage = 6,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 614400,\n\t\t\t.voltage = 7,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 691200,\n\t\t\t.voltage = 8,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 768000,\n\t\t\t.voltage = 9,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 844800,\n\t\t\t.voltage = 10,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 921600,\n\t\t\t.voltage = 11,\n\t\t},\n\t},\n\t{\n\t\t.base = {\n\t\t\t.domain[nv_clk_src_gpc] = 998400,\n\t\t\t.voltage = 12,\n\t\t},\n\t},\n};\n\nstatic void\ngm20b_clk_fini(struct nvkm_clk *base)\n{\n\tstruct nvkm_device *device = base->subdev.device;\n\tstruct gm20b_clk *clk = gm20b_clk(base);\n\n\t \n\tif (gk20a_pllg_is_enabled(&clk->base)) {\n\t\tstruct gk20a_pll pll;\n\t\tu32 n_lo;\n\n\t\tgk20a_pllg_read_mnp(&clk->base, &pll);\n\t\tn_lo = gk20a_pllg_n_lo(&clk->base, &pll);\n\t\tgm20b_pllg_slide(clk, n_lo);\n\t}\n\n\tgm20b_pllg_disable(clk);\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_IDDQ, 1);\n}\n\nstatic int\ngm20b_clk_init_dvfs(struct gm20b_clk *clk)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tbool fused = clk->uvdet_offs && clk->uvdet_slope;\n\tstatic const s32 ADC_SLOPE_UV = 10000;  \n\tu32 data;\n\tint ret;\n\n\t \n\tnvkm_mask(device, GPCPLL_DVFS1, GPCPLL_DVFS1_EN_DFS_BIT,\n\t\t  GPCPLL_DVFS1_EN_DFS_BIT);\n\n\t \n\tif (clk->dvfs_params->vco_ctrl)\n\t\tnvkm_mask(device, GPCPLL_CFG3, GPCPLL_CFG3_VCO_CTRL_MASK,\n\t\t      clk->dvfs_params->vco_ctrl << GPCPLL_CFG3_VCO_CTRL_SHIFT);\n\n\tif (fused) {\n\t\t \n\t\tnvkm_mask(device, GPCPLL_DVFS1, GPCPLL_DVFS1_EN_DFS_CAL_BIT,\n\t\t\t  GPCPLL_DVFS1_EN_DFS_CAL_BIT);\n\n\t\t \n\t\tgoto calibrated;\n\t}\n\n\t \n\tnvkm_mask(device, GPCPLL_DVFS1, GPCPLL_DVFS1_EN_DFS_CAL_BIT,\n\t\t\t  GPCPLL_DVFS1_EN_DFS_CAL_BIT);\n\n\t \n\tret = nvkm_wait_usec(device, 10, GPCPLL_DVFS1,\n\t\t\t     GPCPLL_DVFS1_DFS_CAL_DONE_BIT,\n\t\t\t     GPCPLL_DVFS1_DFS_CAL_DONE_BIT);\n\tif (ret < 0) {\n\t\tnvkm_error(subdev, \"GPCPLL calibration timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdata = nvkm_rd32(device, GPCPLL_CFG3) >>\n\t\t\t GPCPLL_CFG3_PLL_DFS_TESTOUT_SHIFT;\n\tdata &= MASK(GPCPLL_CFG3_PLL_DFS_TESTOUT_WIDTH);\n\n\tclk->uvdet_slope = ADC_SLOPE_UV;\n\tclk->uvdet_offs = ((s32)clk->uv) - data * ADC_SLOPE_UV;\n\n\tnvkm_debug(subdev, \"calibrated DVFS parameters: offs %d, slope %d\\n\",\n\t\t   clk->uvdet_offs, clk->uvdet_slope);\n\ncalibrated:\n\t \n\tgm20b_dvfs_calc_det_coeff(clk, clk->uv, &clk->dvfs);\n\tgm20b_dvfs_program_coeff(clk, 0);\n\tgm20b_dvfs_program_ext_cal(clk, clk->dvfs.dfs_ext_cal);\n\tgm20b_dvfs_program_coeff(clk, clk->dvfs.dfs_coeff);\n\tgm20b_dvfs_program_dfs_detection(clk, &clk->new_dvfs);\n\n\treturn 0;\n}\n\n \nstatic const struct nvkm_clk_func gm20b_clk;\n\nstatic int\ngm20b_clk_init(struct nvkm_clk *base)\n{\n\tstruct gk20a_clk *clk = gk20a_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint ret;\n\tu32 data;\n\n\t \n\tnvkm_mask(device, GPCPLL_CFG, GPCPLL_CFG_IDDQ, 0);\n\tnvkm_rd32(device, GPCPLL_CFG);\n\tudelay(5);\n\n\tnvkm_mask(device, GPC2CLK_OUT, GPC2CLK_OUT_INIT_MASK,\n\t\t  GPC2CLK_OUT_INIT_VAL);\n\n\t \n\tnvkm_mask(device, BYPASSCTRL_SYS,\n\t       MASK(BYPASSCTRL_SYS_GPCPLL_WIDTH) << BYPASSCTRL_SYS_GPCPLL_SHIFT,\n\t       0);\n\n\tret = gk20a_clk_setup_slide(clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata = nvkm_rd32(device, 0x021944);\n\tif (!(data & 0x3)) {\n\t\tdata |= 0x2;\n\t\tnvkm_wr32(device, 0x021944, data);\n\n\t\tdata = nvkm_rd32(device, 0x021948);\n\t\tdata |=  0x1;\n\t\tnvkm_wr32(device, 0x021948, data);\n\t}\n\n\t \n\tnvkm_mask(device, 0x20160, 0x003f0000, 0x0);\n\n\t \n\tif (clk->base.func == &gm20b_clk) {\n\t\tstruct gm20b_clk *_clk = gm20b_clk(base);\n\t\tstruct nvkm_volt *volt = device->volt;\n\n\t\t \n\t\t_clk->uv = nvkm_volt_get(volt);\n\n\t\t \n\t\tret = gm20b_clk_init_dvfs(_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tbase->func->calc(base, &base->func->pstates[0].base);\n\tret = base->func->prog(base);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"cannot initialize clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_clk_func\ngm20b_clk_speedo0 = {\n\t.init = gm20b_clk_init,\n\t.fini = gk20a_clk_fini,\n\t.read = gk20a_clk_read,\n\t.calc = gk20a_clk_calc,\n\t.prog = gk20a_clk_prog,\n\t.tidy = gk20a_clk_tidy,\n\t.pstates = gm20b_pstates,\n\t \n\t.nr_pstates = ARRAY_SIZE(gm20b_pstates) - 1,\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_gpc, 0xff, 0, \"core\", GK20A_CLK_GPC_MDIV },\n\t\t{ nv_clk_src_max },\n\t},\n};\n\nstatic const struct nvkm_clk_func\ngm20b_clk = {\n\t.init = gm20b_clk_init,\n\t.fini = gm20b_clk_fini,\n\t.read = gk20a_clk_read,\n\t.calc = gm20b_clk_calc,\n\t.prog = gm20b_clk_prog,\n\t.tidy = gk20a_clk_tidy,\n\t.pstates = gm20b_pstates,\n\t.nr_pstates = ARRAY_SIZE(gm20b_pstates),\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_gpc, 0xff, 0, \"core\", GK20A_CLK_GPC_MDIV },\n\t\t{ nv_clk_src_max },\n\t},\n};\n\nstatic int\ngm20b_clk_new_speedo0(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t\t      struct nvkm_clk **pclk)\n{\n\tstruct gk20a_clk *clk;\n\tint ret;\n\n\tclk = kzalloc(sizeof(*clk), GFP_KERNEL);\n\tif (!clk)\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base;\n\n\tret = gk20a_clk_ctor(device, type, inst, &gm20b_clk_speedo0, &gm20b_pllg_params, clk);\n\tclk->pl_to_div = pl_to_div;\n\tclk->div_to_pl = div_to_pl;\n\treturn ret;\n}\n\n \n#define FUSE_RESERVED_CALIB0\t0x204\n#define FUSE_RESERVED_CALIB0_INTERCEPT_FRAC_SHIFT\t0\n#define FUSE_RESERVED_CALIB0_INTERCEPT_FRAC_WIDTH\t4\n#define FUSE_RESERVED_CALIB0_INTERCEPT_INT_SHIFT\t4\n#define FUSE_RESERVED_CALIB0_INTERCEPT_INT_WIDTH\t10\n#define FUSE_RESERVED_CALIB0_SLOPE_FRAC_SHIFT\t\t14\n#define FUSE_RESERVED_CALIB0_SLOPE_FRAC_WIDTH\t\t10\n#define FUSE_RESERVED_CALIB0_SLOPE_INT_SHIFT\t\t24\n#define FUSE_RESERVED_CALIB0_SLOPE_INT_WIDTH\t\t6\n#define FUSE_RESERVED_CALIB0_FUSE_REV_SHIFT\t\t30\n#define FUSE_RESERVED_CALIB0_FUSE_REV_WIDTH\t\t2\n\nstatic int\ngm20b_clk_init_fused_params(struct gm20b_clk *clk)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tu32 val = 0;\n\tu32 rev = 0;\n\n#if IS_ENABLED(CONFIG_ARCH_TEGRA)\n\ttegra_fuse_readl(FUSE_RESERVED_CALIB0, &val);\n\trev = (val >> FUSE_RESERVED_CALIB0_FUSE_REV_SHIFT) &\n\t      MASK(FUSE_RESERVED_CALIB0_FUSE_REV_WIDTH);\n#endif\n\n\t \n\tif (rev == 0)\n\t\treturn -EINVAL;\n\n\t \n\tclk->uvdet_slope = ((val >> FUSE_RESERVED_CALIB0_SLOPE_INT_SHIFT) &\n\t\t\tMASK(FUSE_RESERVED_CALIB0_SLOPE_INT_WIDTH)) * 1000 +\n\t\t\t((val >> FUSE_RESERVED_CALIB0_SLOPE_FRAC_SHIFT) &\n\t\t\tMASK(FUSE_RESERVED_CALIB0_SLOPE_FRAC_WIDTH));\n\n\t \n\tclk->uvdet_offs = ((val >> FUSE_RESERVED_CALIB0_INTERCEPT_INT_SHIFT) &\n\t\t\tMASK(FUSE_RESERVED_CALIB0_INTERCEPT_INT_WIDTH)) * 1000 +\n\t\t\t((val >> FUSE_RESERVED_CALIB0_INTERCEPT_FRAC_SHIFT) &\n\t\t\t MASK(FUSE_RESERVED_CALIB0_INTERCEPT_FRAC_WIDTH)) * 100;\n\n\tnvkm_debug(subdev, \"fused calibration data: slope %d, offs %d\\n\",\n\t\t   clk->uvdet_slope, clk->uvdet_offs);\n\treturn 0;\n}\n\nstatic int\ngm20b_clk_init_safe_fmax(struct gm20b_clk *clk)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.base.subdev;\n\tstruct nvkm_volt *volt = subdev->device->volt;\n\tstruct nvkm_pstate *pstates = clk->base.base.func->pstates;\n\tint nr_pstates = clk->base.base.func->nr_pstates;\n\tint vmin, id = 0;\n\tu32 fmax = 0;\n\tint i;\n\n\t \n\tvmin = volt->vid[0].uv;\n\tfor (i = 1; i < volt->vid_nr; i++) {\n\t\tif (volt->vid[i].uv <= vmin) {\n\t\t\tvmin = volt->vid[i].uv;\n\t\t\tid = volt->vid[i].vid;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < nr_pstates; i++)\n\t\tif (pstates[i].base.voltage == id)\n\t\t\tfmax = max(fmax,\n\t\t\t\t   pstates[i].base.domain[nv_clk_src_gpc]);\n\n\tif (!fmax) {\n\t\tnvkm_error(subdev, \"failed to evaluate safe fmax\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclk->safe_fmax_vmin = fmax * (100 - 10) / 100;\n\tnvkm_debug(subdev, \"safe fmax @ vmin = %u Khz\\n\", clk->safe_fmax_vmin);\n\n\treturn 0;\n}\n\nint\ngm20b_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_clk **pclk)\n{\n\tstruct nvkm_device_tegra *tdev = device->func->tegra(device);\n\tstruct gm20b_clk *clk;\n\tstruct nvkm_subdev *subdev;\n\tstruct gk20a_clk_pllg_params *clk_params;\n\tint ret;\n\n\t \n\tif (tdev->gpu_speedo_id == 0)\n\t\treturn gm20b_clk_new_speedo0(device, type, inst, pclk);\n\n\t \n\tclk = kzalloc(sizeof(*clk) + sizeof(*clk_params), GFP_KERNEL);\n\tif (!clk)\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base.base;\n\tsubdev = &clk->base.base.subdev;\n\n\t \n\tclk_params = (void *) (clk + 1);\n\t*clk_params = gm20b_pllg_params;\n\tret = gk20a_clk_ctor(device, type, inst, &gm20b_clk, clk_params, &clk->base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk_params->max_m = clk_params->min_m = DIV_ROUND_UP(clk_params->max_u,\n\t\t\t\t\t\t(clk->base.parent_rate / KHZ));\n\tif (clk_params->max_m == 0) {\n\t\tnvkm_warn(subdev, \"cannot use NAPLL, using legacy clock...\\n\");\n\t\tkfree(clk);\n\t\treturn gm20b_clk_new_speedo0(device, type, inst, pclk);\n\t}\n\n\tclk->base.pl_to_div = pl_to_div;\n\tclk->base.div_to_pl = div_to_pl;\n\n\tclk->dvfs_params = &gm20b_dvfs_params;\n\n\tret = gm20b_clk_init_fused_params(clk);\n\t \n\tif (ret)\n\t\tnvkm_warn(subdev, \"no fused calibration parameters\\n\");\n\n\tret = gm20b_clk_init_safe_fmax(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}