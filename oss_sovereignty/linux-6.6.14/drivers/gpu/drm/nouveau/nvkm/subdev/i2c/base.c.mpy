{
  "module_name": "base.c",
  "hash_id": "49764d692b92d7a2917fbb13fc80edcac8b675b7c7fa903a7108242701c0a5b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"aux.h\"\n#include \"bus.h\"\n#include \"pad.h\"\n\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/bios/i2c.h>\n\nstatic struct nvkm_i2c_pad *\nnvkm_i2c_pad_find(struct nvkm_i2c *i2c, int id)\n{\n\tstruct nvkm_i2c_pad *pad;\n\n\tlist_for_each_entry(pad, &i2c->pad, head) {\n\t\tif (pad->id == id)\n\t\t\treturn pad;\n\t}\n\n\treturn NULL;\n}\n\nstruct nvkm_i2c_bus *\nnvkm_i2c_bus_find(struct nvkm_i2c *i2c, int id)\n{\n\tstruct nvkm_bios *bios = i2c->subdev.device->bios;\n\tstruct nvkm_i2c_bus *bus;\n\n\tif (id == NVKM_I2C_BUS_PRI || id == NVKM_I2C_BUS_SEC) {\n\t\tu8  ver, hdr, cnt, len;\n\t\tu16 i2c = dcb_i2c_table(bios, &ver, &hdr, &cnt, &len);\n\t\tif (i2c && ver >= 0x30) {\n\t\t\tu8 auxidx = nvbios_rd08(bios, i2c + 4);\n\t\t\tif (id == NVKM_I2C_BUS_PRI)\n\t\t\t\tid = NVKM_I2C_BUS_CCB((auxidx & 0x0f) >> 0);\n\t\t\telse\n\t\t\t\tid = NVKM_I2C_BUS_CCB((auxidx & 0xf0) >> 4);\n\t\t} else {\n\t\t\tid = NVKM_I2C_BUS_CCB(2);\n\t\t}\n\t}\n\n\tlist_for_each_entry(bus, &i2c->bus, head) {\n\t\tif (bus->id == id)\n\t\t\treturn bus;\n\t}\n\n\treturn NULL;\n}\n\nstruct nvkm_i2c_aux *\nnvkm_i2c_aux_find(struct nvkm_i2c *i2c, int id)\n{\n\tstruct nvkm_i2c_aux *aux;\n\n\tlist_for_each_entry(aux, &i2c->aux, head) {\n\t\tif (aux->id == id)\n\t\t\treturn aux;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nnvkm_i2c_intr_fini(struct nvkm_event *event, int type, int id)\n{\n\tstruct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);\n\tstruct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, id);\n\tif (aux)\n\t\ti2c->func->aux_mask(i2c, type, aux->intr, 0);\n}\n\nstatic void\nnvkm_i2c_intr_init(struct nvkm_event *event, int type, int id)\n{\n\tstruct nvkm_i2c *i2c = container_of(event, typeof(*i2c), event);\n\tstruct nvkm_i2c_aux *aux = nvkm_i2c_aux_find(i2c, id);\n\tif (aux)\n\t\ti2c->func->aux_mask(i2c, type, aux->intr, aux->intr);\n}\n\nstatic const struct nvkm_event_func\nnvkm_i2c_intr_func = {\n\t.init = nvkm_i2c_intr_init,\n\t.fini = nvkm_i2c_intr_fini,\n};\n\nstatic void\nnvkm_i2c_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_i2c *i2c = nvkm_i2c(subdev);\n\tstruct nvkm_i2c_aux *aux;\n\tu32 hi, lo, rq, tx;\n\n\tif (!i2c->func->aux_stat)\n\t\treturn;\n\n\ti2c->func->aux_stat(i2c, &hi, &lo, &rq, &tx);\n\tif (!hi && !lo && !rq && !tx)\n\t\treturn;\n\n\tlist_for_each_entry(aux, &i2c->aux, head) {\n\t\tu32 mask = 0;\n\t\tif (hi & aux->intr) mask |= NVKM_I2C_PLUG;\n\t\tif (lo & aux->intr) mask |= NVKM_I2C_UNPLUG;\n\t\tif (rq & aux->intr) mask |= NVKM_I2C_IRQ;\n\t\tif (tx & aux->intr) mask |= NVKM_I2C_DONE;\n\t\tif (mask)\n\t\t\tnvkm_event_ntfy(&i2c->event, aux->id, mask);\n\t}\n}\n\nstatic int\nnvkm_i2c_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_i2c *i2c = nvkm_i2c(subdev);\n\tstruct nvkm_i2c_pad *pad;\n\tstruct nvkm_i2c_bus *bus;\n\tstruct nvkm_i2c_aux *aux;\n\tu32 mask;\n\n\tlist_for_each_entry(aux, &i2c->aux, head) {\n\t\tnvkm_i2c_aux_fini(aux);\n\t}\n\n\tlist_for_each_entry(bus, &i2c->bus, head) {\n\t\tnvkm_i2c_bus_fini(bus);\n\t}\n\n\tif ((mask = (1 << i2c->func->aux) - 1), i2c->func->aux_stat) {\n\t\ti2c->func->aux_mask(i2c, NVKM_I2C_ANY, mask, 0);\n\t\ti2c->func->aux_stat(i2c, &mask, &mask, &mask, &mask);\n\t}\n\n\tlist_for_each_entry(pad, &i2c->pad, head) {\n\t\tnvkm_i2c_pad_fini(pad);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnvkm_i2c_preinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_i2c *i2c = nvkm_i2c(subdev);\n\tstruct nvkm_i2c_bus *bus;\n\tstruct nvkm_i2c_pad *pad;\n\n\t \n\tlist_for_each_entry(pad, &i2c->pad, head)\n\t\tnvkm_i2c_pad_init(pad);\n\tlist_for_each_entry(bus, &i2c->bus, head)\n\t\tnvkm_i2c_bus_init(bus);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_i2c_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_i2c *i2c = nvkm_i2c(subdev);\n\tstruct nvkm_i2c_bus *bus;\n\tstruct nvkm_i2c_pad *pad;\n\tstruct nvkm_i2c_aux *aux;\n\n\tlist_for_each_entry(pad, &i2c->pad, head) {\n\t\tnvkm_i2c_pad_init(pad);\n\t}\n\n\tlist_for_each_entry(bus, &i2c->bus, head) {\n\t\tnvkm_i2c_bus_init(bus);\n\t}\n\n\tlist_for_each_entry(aux, &i2c->aux, head) {\n\t\tnvkm_i2c_aux_init(aux);\n\t}\n\n\treturn 0;\n}\n\nstatic void *\nnvkm_i2c_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_i2c *i2c = nvkm_i2c(subdev);\n\n\tnvkm_event_fini(&i2c->event);\n\n\twhile (!list_empty(&i2c->aux)) {\n\t\tstruct nvkm_i2c_aux *aux =\n\t\t\tlist_first_entry(&i2c->aux, typeof(*aux), head);\n\t\tnvkm_i2c_aux_del(&aux);\n\t}\n\n\twhile (!list_empty(&i2c->bus)) {\n\t\tstruct nvkm_i2c_bus *bus =\n\t\t\tlist_first_entry(&i2c->bus, typeof(*bus), head);\n\t\tnvkm_i2c_bus_del(&bus);\n\t}\n\n\twhile (!list_empty(&i2c->pad)) {\n\t\tstruct nvkm_i2c_pad *pad =\n\t\t\tlist_first_entry(&i2c->pad, typeof(*pad), head);\n\t\tnvkm_i2c_pad_del(&pad);\n\t}\n\n\treturn i2c;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_i2c = {\n\t.dtor = nvkm_i2c_dtor,\n\t.preinit = nvkm_i2c_preinit,\n\t.init = nvkm_i2c_init,\n\t.fini = nvkm_i2c_fini,\n\t.intr = nvkm_i2c_intr,\n};\n\nstatic const struct nvkm_i2c_drv {\n\tu8 bios;\n\tu8 addr;\n\tint (*pad_new)(struct nvkm_i2c_bus *, int id, u8 addr,\n\t\t       struct nvkm_i2c_pad **);\n}\nnvkm_i2c_drv[] = {\n\t{ 0x0d, 0x39, anx9805_pad_new },\n\t{ 0x0e, 0x3b, anx9805_pad_new },\n\t{}\n};\n\nint\nnvkm_i2c_new_(const struct nvkm_i2c_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_i2c **pi2c)\n{\n\tstruct nvkm_bios *bios = device->bios;\n\tstruct nvkm_i2c *i2c;\n\tstruct nvkm_i2c_aux *aux;\n\tstruct dcb_i2c_entry ccbE;\n\tstruct dcb_output dcbE;\n\tu8 ver, hdr;\n\tint ret, i, ids;\n\n\tif (!(i2c = *pi2c = kzalloc(sizeof(*i2c), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tnvkm_subdev_ctor(&nvkm_i2c, device, type, inst, &i2c->subdev);\n\ti2c->func = func;\n\tINIT_LIST_HEAD(&i2c->pad);\n\tINIT_LIST_HEAD(&i2c->bus);\n\tINIT_LIST_HEAD(&i2c->aux);\n\n\ti = -1;\n\twhile (!dcb_i2c_parse(bios, ++i, &ccbE)) {\n\t\tstruct nvkm_i2c_pad *pad = NULL;\n\t\tstruct nvkm_i2c_bus *bus = NULL;\n\t\tstruct nvkm_i2c_aux *aux = NULL;\n\n\t\tnvkm_debug(&i2c->subdev, \"ccb %02x: type %02x drive %02x \"\n\t\t\t   \"sense %02x share %02x auxch %02x\\n\", i, ccbE.type,\n\t\t\t   ccbE.drive, ccbE.sense, ccbE.share, ccbE.auxch);\n\n\t\tif (ccbE.share != DCB_I2C_UNUSED) {\n\t\t\tconst int id = NVKM_I2C_PAD_HYBRID(ccbE.share);\n\t\t\tif (!(pad = nvkm_i2c_pad_find(i2c, id)))\n\t\t\t\tret = func->pad_s_new(i2c, id, &pad);\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = func->pad_x_new(i2c, NVKM_I2C_PAD_CCB(i), &pad);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tnvkm_error(&i2c->subdev, \"ccb %02x pad, %d\\n\", i, ret);\n\t\t\tnvkm_i2c_pad_del(&pad);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pad->func->bus_new_0 && ccbE.type == DCB_I2C_NV04_BIT) {\n\t\t\tret = pad->func->bus_new_0(pad, NVKM_I2C_BUS_CCB(i),\n\t\t\t\t\t\t   ccbE.drive,\n\t\t\t\t\t\t   ccbE.sense, &bus);\n\t\t} else\n\t\tif (pad->func->bus_new_4 &&\n\t\t    ( ccbE.type == DCB_I2C_NV4E_BIT ||\n\t\t      ccbE.type == DCB_I2C_NVIO_BIT ||\n\t\t     (ccbE.type == DCB_I2C_PMGR &&\n\t\t      ccbE.drive != DCB_I2C_UNUSED))) {\n\t\t\tret = pad->func->bus_new_4(pad, NVKM_I2C_BUS_CCB(i),\n\t\t\t\t\t\t   ccbE.drive, &bus);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tnvkm_error(&i2c->subdev, \"ccb %02x bus, %d\\n\", i, ret);\n\t\t\tnvkm_i2c_bus_del(&bus);\n\t\t}\n\n\t\tif (pad->func->aux_new_6 &&\n\t\t    ( ccbE.type == DCB_I2C_NVIO_AUX ||\n\t\t     (ccbE.type == DCB_I2C_PMGR &&\n\t\t      ccbE.auxch != DCB_I2C_UNUSED))) {\n\t\t\tret = pad->func->aux_new_6(pad, NVKM_I2C_BUS_CCB(i),\n\t\t\t\t\t\t   ccbE.auxch, &aux);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tnvkm_error(&i2c->subdev, \"ccb %02x aux, %d\\n\", i, ret);\n\t\t\tnvkm_i2c_aux_del(&aux);\n\t\t}\n\n\t\tif (ccbE.type != DCB_I2C_UNUSED && !bus && !aux) {\n\t\t\tnvkm_warn(&i2c->subdev, \"ccb %02x was ignored\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\ti = -1;\n\twhile (dcb_outp_parse(bios, ++i, &ver, &hdr, &dcbE)) {\n\t\tconst struct nvkm_i2c_drv *drv = nvkm_i2c_drv;\n\t\tstruct nvkm_i2c_bus *bus;\n\t\tstruct nvkm_i2c_pad *pad;\n\n\t\t \n\t\tif (!dcbE.location)\n\t\t\tcontinue;\n\n\t\t \n\t\tbus = nvkm_i2c_bus_find(i2c, dcbE.i2c_index);\n\t\tif (!bus) {\n\t\t\tnvkm_debug(&i2c->subdev, \"dcb %02x no bus\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\twhile (drv->pad_new) {\n\t\t\tif (drv->bios == dcbE.extdev)\n\t\t\t\tbreak;\n\t\t\tdrv++;\n\t\t}\n\n\t\tif (!drv->pad_new) {\n\t\t\tnvkm_debug(&i2c->subdev, \"dcb %02x drv %02x unknown\\n\",\n\t\t\t\t   i, dcbE.extdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tpad = nvkm_i2c_pad_find(i2c, NVKM_I2C_PAD_EXT(dcbE.extdev));\n\t\tif (!pad) {\n\t\t\tconst int id = NVKM_I2C_PAD_EXT(dcbE.extdev);\n\t\t\tret = drv->pad_new(bus, id, drv->addr, &pad);\n\t\t\tif (ret) {\n\t\t\t\tnvkm_error(&i2c->subdev, \"dcb %02x pad, %d\\n\",\n\t\t\t\t\t   i, ret);\n\t\t\t\tnvkm_i2c_pad_del(&pad);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pad->func->aux_new_6 && dcbE.type == DCB_OUTPUT_DP) {\n\t\t\tconst int id = NVKM_I2C_AUX_EXT(dcbE.extdev);\n\t\t\tstruct nvkm_i2c_aux *aux = NULL;\n\t\t\tret = pad->func->aux_new_6(pad, id, 0, &aux);\n\t\t\tif (ret) {\n\t\t\t\tnvkm_error(&i2c->subdev, \"dcb %02x aux, %d\\n\",\n\t\t\t\t\t   i, ret);\n\t\t\t\tnvkm_i2c_aux_del(&aux);\n\t\t\t}\n\t\t} else\n\t\tif (pad->func->bus_new_4) {\n\t\t\tconst int id = NVKM_I2C_BUS_EXT(dcbE.extdev);\n\t\t\tstruct nvkm_i2c_bus *bus = NULL;\n\t\t\tret = pad->func->bus_new_4(pad, id, 0, &bus);\n\t\t\tif (ret) {\n\t\t\t\tnvkm_error(&i2c->subdev, \"dcb %02x bus, %d\\n\",\n\t\t\t\t\t   i, ret);\n\t\t\t\tnvkm_i2c_bus_del(&bus);\n\t\t\t}\n\t\t}\n\t}\n\n\tids = 0;\n\tlist_for_each_entry(aux, &i2c->aux, head)\n\t\tids = max(ids, aux->id + 1);\n\tif (!ids)\n\t\treturn 0;\n\n\treturn nvkm_event_init(&nvkm_i2c_intr_func, &i2c->subdev, 4, ids, &i2c->event);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}