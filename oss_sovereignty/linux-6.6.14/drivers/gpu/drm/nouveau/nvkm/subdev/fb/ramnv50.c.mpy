{
  "module_name": "ramnv50.c",
  "hash_id": "53fc227a007841c99bd93bcbf3dfd08a80085b0b1c1b0ae16b01febb68b9a226",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/ramnv50.c",
  "human_readable_source": " \n#define nv50_ram(p) container_of((p), struct nv50_ram, base)\n#include \"ram.h\"\n#include \"ramseq.h\"\n#include \"nv50.h\"\n\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/perf.h>\n#include <subdev/bios/pll.h>\n#include <subdev/bios/rammap.h>\n#include <subdev/bios/timing.h>\n#include <subdev/clk/pll.h>\n#include <subdev/gpio.h>\n\nstruct nv50_ramseq {\n\tstruct hwsq base;\n\tstruct hwsq_reg r_0x002504;\n\tstruct hwsq_reg r_0x004008;\n\tstruct hwsq_reg r_0x00400c;\n\tstruct hwsq_reg r_0x00c040;\n\tstruct hwsq_reg r_0x100200;\n\tstruct hwsq_reg r_0x100210;\n\tstruct hwsq_reg r_0x10021c;\n\tstruct hwsq_reg r_0x1002d0;\n\tstruct hwsq_reg r_0x1002d4;\n\tstruct hwsq_reg r_0x1002dc;\n\tstruct hwsq_reg r_0x10053c;\n\tstruct hwsq_reg r_0x1005a0;\n\tstruct hwsq_reg r_0x1005a4;\n\tstruct hwsq_reg r_0x100710;\n\tstruct hwsq_reg r_0x100714;\n\tstruct hwsq_reg r_0x100718;\n\tstruct hwsq_reg r_0x10071c;\n\tstruct hwsq_reg r_0x100da0;\n\tstruct hwsq_reg r_0x100e20;\n\tstruct hwsq_reg r_0x100e24;\n\tstruct hwsq_reg r_0x611200;\n\tstruct hwsq_reg r_timing[9];\n\tstruct hwsq_reg r_mr[4];\n\tstruct hwsq_reg r_gpio[4];\n};\n\nstruct nv50_ram {\n\tstruct nvkm_ram base;\n\tstruct nv50_ramseq hwsq;\n};\n\n#define T(t) cfg->timing_10_##t\nstatic int\nnv50_ram_timing_calc(struct nv50_ram *ram, u32 *timing)\n{\n\tstruct nvbios_ramcfg *cfg = &ram->base.target.bios;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 cur2, cur4, cur7, cur8;\n\tu8 unkt3b;\n\n\tcur2 = nvkm_rd32(device, 0x100228);\n\tcur4 = nvkm_rd32(device, 0x100230);\n\tcur7 = nvkm_rd32(device, 0x10023c);\n\tcur8 = nvkm_rd32(device, 0x100240);\n\n\tswitch ((!T(CWL)) * ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR2:\n\t\tT(CWL) = T(CL) - 1;\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tT(CWL) = ((cur2 & 0xff000000) >> 24) + 1;\n\t\tbreak;\n\t}\n\n\t \n\tif (device->chipset == 0xa0) {\n\t\tunkt3b = 0x19 + ram->base.next->bios.rammap_00_16_40;\n\t\ttiming[6] = (0x2d + T(CL) - T(CWL) +\n\t\t\t\tram->base.next->bios.rammap_00_16_40) << 16 |\n\t\t\t    T(CWL) << 8 |\n\t\t\t    (0x2f + T(CL) - T(CWL));\n\t} else {\n\t\tunkt3b = 0x16;\n\t\ttiming[6] = (0x2b + T(CL) - T(CWL)) << 16 |\n\t\t\t    max_t(s8, T(CWL) - 2, 1) << 8 |\n\t\t\t    (0x2e + T(CL) - T(CWL));\n\t}\n\n\ttiming[0] = (T(RP) << 24 | T(RAS) << 16 | T(RFC) << 8 | T(RC));\n\ttiming[1] = (T(WR) + 1 + T(CWL)) << 24 |\n\t\t    max_t(u8, T(18), 1) << 16 |\n\t\t    (T(WTR) + 1 + T(CWL)) << 8 |\n\t\t    (3 + T(CL) - T(CWL));\n\ttiming[2] = (T(CWL) - 1) << 24 |\n\t\t    (T(RRD) << 16) |\n\t\t    (T(RCDWR) << 8) |\n\t\t    T(RCDRD);\n\ttiming[3] = (unkt3b - 2 + T(CL)) << 24 |\n\t\t    unkt3b << 16 |\n\t\t    (T(CL) - 1) << 8 |\n\t\t    (T(CL) - 1);\n\ttiming[4] = (cur4 & 0xffff0000) |\n\t\t    T(13) << 8 |\n\t\t    T(13);\n\ttiming[5] = T(RFC) << 24 |\n\t\t    max_t(u8, T(RCDRD), T(RCDWR)) << 16 |\n\t\t    T(RP);\n\t \n\ttiming[7] = (cur7 & 0xff00ffff) | (T(CL) - 1) << 16;\n\ttiming[8] = (cur8 & 0xffffff00);\n\n\t \n\tif (ram->base.type == NVKM_RAM_TYPE_DDR2) {\n\t\ttiming[5] |= (T(CL) + 3) << 8;\n\t\ttiming[8] |= (T(CL) - 4);\n\t} else\n\tif (ram->base.type == NVKM_RAM_TYPE_GDDR3) {\n\t\ttiming[5] |= (T(CL) + 2) << 8;\n\t\ttiming[8] |= (T(CL) - 2);\n\t}\n\n\tnvkm_debug(subdev, \" 220: %08x %08x %08x %08x\\n\",\n\t\t   timing[0], timing[1], timing[2], timing[3]);\n\tnvkm_debug(subdev, \" 230: %08x %08x %08x %08x\\n\",\n\t\t   timing[4], timing[5], timing[6], timing[7]);\n\tnvkm_debug(subdev, \" 240: %08x\\n\", timing[8]);\n\treturn 0;\n}\n\nstatic int\nnv50_ram_timing_read(struct nv50_ram *ram, u32 *timing)\n{\n\tunsigned int i;\n\tstruct nvbios_ramcfg *cfg = &ram->base.target.bios;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\tfor (i = 0; i <= 8; i++)\n\t\ttiming[i] = nvkm_rd32(device, 0x100220 + (i * 4));\n\n\t \n\tcfg->timing_ver = 0x10;\n\tT(CL) = (timing[3] & 0xff) + 1;\n\n\tswitch (ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR2:\n\t\tT(CWL) = T(CL) - 1;\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tT(CWL) = ((timing[2] & 0xff000000) >> 24) + 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\tT(WR) = ((timing[1] >> 24) & 0xff) - 1 - T(CWL);\n\n\treturn 0;\n}\n#undef T\n\nstatic void\nnvkm_sddr2_dll_reset(struct nv50_ramseq *hwsq)\n{\n\tram_mask(hwsq, mr[0], 0x100, 0x100);\n\tram_mask(hwsq, mr[0], 0x100, 0x000);\n\tram_nsec(hwsq, 24000);\n}\n\nstatic void\nnv50_ram_gpio(struct nv50_ramseq *hwsq, u8 tag, u32 val)\n{\n\tstruct nvkm_gpio *gpio = hwsq->base.subdev->device->gpio;\n\tstruct dcb_gpio_func func;\n\tu32 reg, sh, gpio_val;\n\tint ret;\n\n\tif (nvkm_gpio_get(gpio, 0, tag, DCB_GPIO_UNUSED) != val) {\n\t\tret = nvkm_gpio_find(gpio, 0, tag, DCB_GPIO_UNUSED, &func);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\treg = func.line >> 3;\n\t\tsh = (func.line & 0x7) << 2;\n\t\tgpio_val = ram_rd32(hwsq, gpio[reg]);\n\n\t\tif (gpio_val & (8 << sh))\n\t\t\tval = !val;\n\t\tif (!(func.log[1] & 1))\n\t\t\tval = !val;\n\n\t\tram_mask(hwsq, gpio[reg], (0x3 << sh), ((val | 0x2) << sh));\n\t\tram_nsec(hwsq, 20000);\n\t}\n}\n\nstatic int\nnv50_ram_calc(struct nvkm_ram *base, u32 freq)\n{\n\tstruct nv50_ram *ram = nv50_ram(base);\n\tstruct nv50_ramseq *hwsq = &ram->hwsq;\n\tstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvbios_perfE perfE;\n\tstruct nvbios_pll mpll;\n\tstruct nvkm_ram_data *next;\n\tu8  ver, hdr, cnt, len, strap, size;\n\tu32 data;\n\tu32 r100da0, r004008, unk710, unk714, unk718, unk71c;\n\tint N1, M1, N2, M2, P;\n\tint ret, i;\n\tu32 timing[9];\n\n\tnext = &ram->base.target;\n\tnext->freq = freq;\n\tram->base.next = next;\n\n\t \n\ti = 0;\n\tdo {\n\t\tdata = nvbios_perfEp(bios, i++, &ver, &hdr, &cnt,\n\t\t\t\t     &size, &perfE);\n\t\tif (!data || (ver < 0x25 || ver >= 0x40) ||\n\t\t    (size < 2)) {\n\t\t\tnvkm_error(subdev, \"invalid/missing perftab entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (perfE.memory < freq);\n\n\tnvbios_rammapEp_from_perf(bios, data, hdr, &next->bios);\n\n\t \n\tstrap = nvbios_ramcfg_index(subdev);\n\tif (strap >= cnt) {\n\t\tnvkm_error(subdev, \"invalid ramcfg strap\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = nvbios_rammapSp_from_perf(bios, data + hdr, size, strap,\n\t\t\t&next->bios);\n\tif (!data) {\n\t\tnvkm_error(subdev, \"invalid/missing rammap entry \");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (next->bios.ramcfg_timing != 0xff) {\n\t\tdata = nvbios_timingEp(bios, next->bios.ramcfg_timing,\n\t\t\t\t\t&ver, &hdr, &cnt, &len, &next->bios);\n\t\tif (!data || ver != 0x10 || hdr < 0x12) {\n\t\t\tnvkm_error(subdev, \"invalid/missing timing entry \"\n\t\t\t\t \"%02x %04x %02x %02x\\n\",\n\t\t\t\t strap, data, ver, hdr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnv50_ram_timing_calc(ram, timing);\n\t} else {\n\t\tnv50_ram_timing_read(ram, timing);\n\t}\n\n\tret = ram_init(hwsq, subdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tram->base.mr[0] = ram_rd32(hwsq, mr[0]);\n\tram->base.mr[1] = ram_rd32(hwsq, mr[1]);\n\tram->base.mr[2] = ram_rd32(hwsq, mr[2]);\n\n\tswitch (ram->base.type) {\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tret = nvkm_gddr3_calc(&ram->base);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tnvkm_error(subdev, \"Could not calculate MR\\n\");\n\t\treturn ret;\n\t}\n\n\tif (subdev->device->chipset <= 0x96 && !next->bios.ramcfg_00_03_02)\n\t\tram_mask(hwsq, 0x100710, 0x00000200, 0x00000000);\n\n\t \n\tram_mask(hwsq, 0x100200, 0x00000800, 0x00000000);\n\n\tram_wait_vblank(hwsq);\n\tram_wr32(hwsq, 0x611200, 0x00003300);\n\tram_wr32(hwsq, 0x002504, 0x00000001);  \n\tram_nsec(hwsq, 8000);\n\tram_setf(hwsq, 0x10, 0x00);  \n\tram_wait(hwsq, 0x00, 0x01);  \n\tram_nsec(hwsq, 2000);\n\n\tif (next->bios.timing_10_ODT)\n\t\tnv50_ram_gpio(hwsq, 0x2e, 1);\n\n\tram_wr32(hwsq, 0x1002d4, 0x00000001);  \n\tram_wr32(hwsq, 0x1002d0, 0x00000001);  \n\tram_wr32(hwsq, 0x1002d0, 0x00000001);  \n\tram_wr32(hwsq, 0x100210, 0x00000000);  \n\tram_wr32(hwsq, 0x1002dc, 0x00000001);  \n\n\tret = nvbios_pll_parse(bios, 0x004008, &mpll);\n\tmpll.vco2.max_freq = 0;\n\tif (ret >= 0) {\n\t\tret = nv04_pll_calc(subdev, &mpll, freq,\n\t\t\t\t    &N1, &M1, &N2, &M2, &P);\n\t\tif (ret <= 0)\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (freq <= 750000) {\n\t\tr100da0 = 0x00000010;\n\t\tr004008 = 0x90000000;\n\t} else {\n\t\tr100da0 = 0x00000000;\n\t\tr004008 = 0x80000000;\n\t}\n\n\tr004008 |= (mpll.bias_p << 19) | (P << 22) | (P << 16);\n\n\tram_mask(hwsq, 0x00c040, 0xc000c000, 0x0000c000);\n\t \n\tram_mask(hwsq, 0x004008, 0x00004200, 0x00000200 |\n\t\t\tnext->bios.rammap_00_16_40 << 14);\n\tram_mask(hwsq, 0x00400c, 0x0000ffff, (N1 << 8) | M1);\n\tram_mask(hwsq, 0x004008, 0x91ff0000, r004008);\n\n\t \n\tif (subdev->device->chipset >= 0x92)\n\t\tram_wr32(hwsq, 0x100da0, r100da0);\n\n\tnv50_ram_gpio(hwsq, 0x18, !next->bios.ramcfg_FBVDDQ);\n\tram_nsec(hwsq, 64000);  \n\tram_nsec(hwsq, 32000);  \n\n\tram_mask(hwsq, 0x004008, 0x00002200, 0x00002000);\n\n\tram_wr32(hwsq, 0x1002dc, 0x00000000);  \n\tram_wr32(hwsq, 0x1002d4, 0x00000001);  \n\tram_wr32(hwsq, 0x100210, 0x80000000);  \n\n\tram_nsec(hwsq, 12000);\n\n\tswitch (ram->base.type) {\n\tcase NVKM_RAM_TYPE_DDR2:\n\t\tram_nuke(hwsq, mr[0]);  \n\t\tram_mask(hwsq, mr[0], 0x000, 0x000);\n\t\tbreak;\n\tcase NVKM_RAM_TYPE_GDDR3:\n\t\tram_nuke(hwsq, mr[1]);  \n\t\tram_wr32(hwsq, mr[1], ram->base.mr[1]);\n\t\tram_nuke(hwsq, mr[0]);  \n\t\tram_wr32(hwsq, mr[0], ram->base.mr[0]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tram_mask(hwsq, timing[3], 0xffffffff, timing[3]);\n\tram_mask(hwsq, timing[1], 0xffffffff, timing[1]);\n\tram_mask(hwsq, timing[6], 0xffffffff, timing[6]);\n\tram_mask(hwsq, timing[7], 0xffffffff, timing[7]);\n\tram_mask(hwsq, timing[8], 0xffffffff, timing[8]);\n\tram_mask(hwsq, timing[0], 0xffffffff, timing[0]);\n\tram_mask(hwsq, timing[2], 0xffffffff, timing[2]);\n\tram_mask(hwsq, timing[4], 0xffffffff, timing[4]);\n\tram_mask(hwsq, timing[5], 0xffffffff, timing[5]);\n\n\tif (!next->bios.ramcfg_00_03_02)\n\t\tram_mask(hwsq, 0x10021c, 0x00010000, 0x00000000);\n\tram_mask(hwsq, 0x100200, 0x00001000, !next->bios.ramcfg_00_04_02 << 12);\n\n\t \n\tunk710  = ram_rd32(hwsq, 0x100710) & ~0x00000100;\n\tunk714  = ram_rd32(hwsq, 0x100714) & ~0xf0000020;\n\tunk718  = ram_rd32(hwsq, 0x100718) & ~0x00000100;\n\tunk71c  = ram_rd32(hwsq, 0x10071c) & ~0x00000100;\n\tif (subdev->device->chipset <= 0x96) {\n\t\tunk710 &= ~0x0000006e;\n\t\tunk714 &= ~0x00000100;\n\n\t\tif (!next->bios.ramcfg_00_03_08)\n\t\t\tunk710 |= 0x00000060;\n\t\tif (!next->bios.ramcfg_FBVDDQ)\n\t\t\tunk714 |= 0x00000100;\n\t\tif ( next->bios.ramcfg_00_04_04)\n\t\t\tunk710 |= 0x0000000e;\n\t} else {\n\t\tunk710 &= ~0x00000001;\n\n\t\tif (!next->bios.ramcfg_00_03_08)\n\t\t\tunk710 |= 0x00000001;\n\t}\n\n\tif ( next->bios.ramcfg_00_03_01)\n\t\tunk71c |= 0x00000100;\n\tif ( next->bios.ramcfg_00_03_02)\n\t\tunk710 |= 0x00000100;\n\tif (!next->bios.ramcfg_00_03_08)\n\t\tunk714 |= 0x00000020;\n\tif ( next->bios.ramcfg_00_04_04)\n\t\tunk714 |= 0x70000000;\n\tif ( next->bios.ramcfg_00_04_20)\n\t\tunk718 |= 0x00000100;\n\n\tram_mask(hwsq, 0x100714, 0xffffffff, unk714);\n\tram_mask(hwsq, 0x10071c, 0xffffffff, unk71c);\n\tram_mask(hwsq, 0x100718, 0xffffffff, unk718);\n\tram_mask(hwsq, 0x100710, 0xffffffff, unk710);\n\n\t \n\tif (next->bios.rammap_00_16_20) {\n\t\tram_wr32(hwsq, 0x1005a0, next->bios.ramcfg_00_07 << 16 |\n\t\t\t\t\t next->bios.ramcfg_00_06 << 8 |\n\t\t\t\t\t next->bios.ramcfg_00_05);\n\t\tram_wr32(hwsq, 0x1005a4, next->bios.ramcfg_00_09 << 8 |\n\t\t\t\t\t next->bios.ramcfg_00_08);\n\t\tram_mask(hwsq, 0x10053c, 0x00001000, 0x00000000);\n\t} else {\n\t\tram_mask(hwsq, 0x10053c, 0x00001000, 0x00001000);\n\t}\n\tram_mask(hwsq, mr[1], 0xffffffff, ram->base.mr[1]);\n\n\tif (!next->bios.timing_10_ODT)\n\t\tnv50_ram_gpio(hwsq, 0x2e, 0);\n\n\t \n\tif (!next->bios.ramcfg_DLLoff)\n\t\tnvkm_sddr2_dll_reset(hwsq);\n\n\tram_setf(hwsq, 0x10, 0x01);  \n\tram_wait(hwsq, 0x00, 0x00);  \n\tram_wr32(hwsq, 0x611200, 0x00003330);\n\tram_wr32(hwsq, 0x002504, 0x00000000);  \n\n\tif (next->bios.rammap_00_17_02)\n\t\tram_mask(hwsq, 0x100200, 0x00000800, 0x00000800);\n\tif (!next->bios.rammap_00_16_40)\n\t\tram_mask(hwsq, 0x004008, 0x00004000, 0x00000000);\n\tif (next->bios.ramcfg_00_03_02)\n\t\tram_mask(hwsq, 0x10021c, 0x00010000, 0x00010000);\n\tif (subdev->device->chipset <= 0x96 && next->bios.ramcfg_00_03_02)\n\t\tram_mask(hwsq, 0x100710, 0x00000200, 0x00000200);\n\n\treturn 0;\n}\n\nstatic int\nnv50_ram_prog(struct nvkm_ram *base)\n{\n\tstruct nv50_ram *ram = nv50_ram(base);\n\tstruct nvkm_device *device = ram->base.fb->subdev.device;\n\tram_exec(&ram->hwsq, nvkm_boolopt(device->cfgopt, \"NvMemExec\", true));\n\treturn 0;\n}\n\nstatic void\nnv50_ram_tidy(struct nvkm_ram *base)\n{\n\tstruct nv50_ram *ram = nv50_ram(base);\n\tram_exec(&ram->hwsq, false);\n}\n\nstatic const struct nvkm_ram_func\nnv50_ram_func = {\n\t.calc = nv50_ram_calc,\n\t.prog = nv50_ram_prog,\n\t.tidy = nv50_ram_tidy,\n};\n\nstatic u32\nnv50_fb_vram_rblock(struct nvkm_ram *ram)\n{\n\tstruct nvkm_subdev *subdev = &ram->fb->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint colbits, rowbitsa, rowbitsb, banks;\n\tu64 rowsize, predicted;\n\tu32 r0, r4, rt, rblock_size;\n\n\tr0 = nvkm_rd32(device, 0x100200);\n\tr4 = nvkm_rd32(device, 0x100204);\n\trt = nvkm_rd32(device, 0x100250);\n\tnvkm_debug(subdev, \"memcfg %08x %08x %08x %08x\\n\",\n\t\t   r0, r4, rt, nvkm_rd32(device, 0x001540));\n\n\tcolbits  =  (r4 & 0x0000f000) >> 12;\n\trowbitsa = ((r4 & 0x000f0000) >> 16) + 8;\n\trowbitsb = ((r4 & 0x00f00000) >> 20) + 8;\n\tbanks    = 1 << (((r4 & 0x03000000) >> 24) + 2);\n\n\trowsize = ram->parts * banks * (1 << colbits) * 8;\n\tpredicted = rowsize << rowbitsa;\n\tif (r0 & 0x00000004)\n\t\tpredicted += rowsize << rowbitsb;\n\n\tif (predicted != ram->size) {\n\t\tnvkm_warn(subdev, \"memory controller reports %d MiB VRAM\\n\",\n\t\t\t  (u32)(ram->size >> 20));\n\t}\n\n\trblock_size = rowsize;\n\tif (rt & 1)\n\t\trblock_size *= 3;\n\n\tnvkm_debug(subdev, \"rblock %d bytes\\n\", rblock_size);\n\treturn rblock_size;\n}\n\nint\nnv50_ram_ctor(const struct nvkm_ram_func *func,\n\t      struct nvkm_fb *fb, struct nvkm_ram *ram)\n{\n\tstruct nvkm_device *device = fb->subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tconst u32 rsvd_head = ( 256 * 1024);  \n\tconst u32 rsvd_tail = (1024 * 1024);  \n\tu64 size = nvkm_rd32(device, 0x10020c);\n\tenum nvkm_ram_type type = NVKM_RAM_TYPE_UNKNOWN;\n\tint ret;\n\n\tswitch (nvkm_rd32(device, 0x100714) & 0x00000007) {\n\tcase 0: type = NVKM_RAM_TYPE_DDR1; break;\n\tcase 1:\n\t\tif (nvkm_fb_bios_memtype(bios) == NVKM_RAM_TYPE_DDR3)\n\t\t\ttype = NVKM_RAM_TYPE_DDR3;\n\t\telse\n\t\t\ttype = NVKM_RAM_TYPE_DDR2;\n\t\tbreak;\n\tcase 2: type = NVKM_RAM_TYPE_GDDR3; break;\n\tcase 3: type = NVKM_RAM_TYPE_GDDR4; break;\n\tcase 4: type = NVKM_RAM_TYPE_GDDR5; break;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsize = (size & 0x000000ff) << 32 | (size & 0xffffff00);\n\n\tret = nvkm_ram_ctor(func, fb, type, size, ram);\n\tif (ret)\n\t\treturn ret;\n\n\tram->part_mask = (nvkm_rd32(device, 0x001540) & 0x00ff0000) >> 16;\n\tram->parts = hweight8(ram->part_mask);\n\tram->ranks = (nvkm_rd32(device, 0x100200) & 0x4) ? 2 : 1;\n\tnvkm_mm_fini(&ram->vram);\n\n\treturn nvkm_mm_init(&ram->vram, NVKM_RAM_MM_NORMAL,\n\t\t\t    rsvd_head >> NVKM_RAM_MM_SHIFT,\n\t\t\t    (size - rsvd_head - rsvd_tail) >> NVKM_RAM_MM_SHIFT,\n\t\t\t    nv50_fb_vram_rblock(ram) >> NVKM_RAM_MM_SHIFT);\n}\n\nint\nnv50_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)\n{\n\tstruct nv50_ram *ram;\n\tint ret, i;\n\n\tif (!(ram = kzalloc(sizeof(*ram), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pram = &ram->base;\n\n\tret = nv50_ram_ctor(&nv50_ram_func, fb, &ram->base);\n\tif (ret)\n\t\treturn ret;\n\n\tram->hwsq.r_0x002504 = hwsq_reg(0x002504);\n\tram->hwsq.r_0x00c040 = hwsq_reg(0x00c040);\n\tram->hwsq.r_0x004008 = hwsq_reg(0x004008);\n\tram->hwsq.r_0x00400c = hwsq_reg(0x00400c);\n\tram->hwsq.r_0x100200 = hwsq_reg(0x100200);\n\tram->hwsq.r_0x100210 = hwsq_reg(0x100210);\n\tram->hwsq.r_0x10021c = hwsq_reg(0x10021c);\n\tram->hwsq.r_0x1002d0 = hwsq_reg(0x1002d0);\n\tram->hwsq.r_0x1002d4 = hwsq_reg(0x1002d4);\n\tram->hwsq.r_0x1002dc = hwsq_reg(0x1002dc);\n\tram->hwsq.r_0x10053c = hwsq_reg(0x10053c);\n\tram->hwsq.r_0x1005a0 = hwsq_reg(0x1005a0);\n\tram->hwsq.r_0x1005a4 = hwsq_reg(0x1005a4);\n\tram->hwsq.r_0x100710 = hwsq_reg(0x100710);\n\tram->hwsq.r_0x100714 = hwsq_reg(0x100714);\n\tram->hwsq.r_0x100718 = hwsq_reg(0x100718);\n\tram->hwsq.r_0x10071c = hwsq_reg(0x10071c);\n\tram->hwsq.r_0x100da0 = hwsq_stride(0x100da0, 4, ram->base.part_mask);\n\tram->hwsq.r_0x100e20 = hwsq_reg(0x100e20);\n\tram->hwsq.r_0x100e24 = hwsq_reg(0x100e24);\n\tram->hwsq.r_0x611200 = hwsq_reg(0x611200);\n\n\tfor (i = 0; i < 9; i++)\n\t\tram->hwsq.r_timing[i] = hwsq_reg(0x100220 + (i * 0x04));\n\n\tif (ram->base.ranks > 1) {\n\t\tram->hwsq.r_mr[0] = hwsq_reg2(0x1002c0, 0x1002c8);\n\t\tram->hwsq.r_mr[1] = hwsq_reg2(0x1002c4, 0x1002cc);\n\t\tram->hwsq.r_mr[2] = hwsq_reg2(0x1002e0, 0x1002e8);\n\t\tram->hwsq.r_mr[3] = hwsq_reg2(0x1002e4, 0x1002ec);\n\t} else {\n\t\tram->hwsq.r_mr[0] = hwsq_reg(0x1002c0);\n\t\tram->hwsq.r_mr[1] = hwsq_reg(0x1002c4);\n\t\tram->hwsq.r_mr[2] = hwsq_reg(0x1002e0);\n\t\tram->hwsq.r_mr[3] = hwsq_reg(0x1002e4);\n\t}\n\n\tram->hwsq.r_gpio[0] = hwsq_reg(0x00e104);\n\tram->hwsq.r_gpio[1] = hwsq_reg(0x00e108);\n\tram->hwsq.r_gpio[2] = hwsq_reg(0x00e120);\n\tram->hwsq.r_gpio[3] = hwsq_reg(0x00e124);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}