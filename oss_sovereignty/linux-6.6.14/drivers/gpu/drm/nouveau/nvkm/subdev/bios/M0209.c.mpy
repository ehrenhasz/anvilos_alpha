{
  "module_name": "M0209.c",
  "hash_id": "b8d7d41b299fa9dc70991fe5d0a0865b98f343610f79988e8ab18801476f77f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/M0209.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/M0209.h>\n\nu32\nnvbios_M0209Te(struct nvkm_bios *bios,\n\t       u8 *ver, u8 *hdr, u8 *cnt, u8 *len, u8 *snr, u8 *ssz)\n{\n\tstruct bit_entry bit_M;\n\tu32 data = 0x00000000;\n\n\tif (!bit_entry(bios, 'M', &bit_M)) {\n\t\tif (bit_M.version == 2 && bit_M.length > 0x0c)\n\t\t\tdata = nvbios_rd32(bios, bit_M.offset + 0x09);\n\t\tif (data) {\n\t\t\t*ver = nvbios_rd08(bios, data + 0x00);\n\t\t\tswitch (*ver) {\n\t\t\tcase 0x10:\n\t\t\t\t*hdr = nvbios_rd08(bios, data + 0x01);\n\t\t\t\t*len = nvbios_rd08(bios, data + 0x02);\n\t\t\t\t*ssz = nvbios_rd08(bios, data + 0x03);\n\t\t\t\t*snr = 1;\n\t\t\t\t*cnt = nvbios_rd08(bios, data + 0x04);\n\t\t\t\treturn data;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0x00000000;\n}\n\nu32\nnvbios_M0209Ee(struct nvkm_bios *bios, int idx,\n\t       u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tu8  snr, ssz;\n\tu32 data = nvbios_M0209Te(bios, ver, hdr, cnt, len, &snr, &ssz);\n\tif (data && idx < *cnt) {\n\t\tdata = data + *hdr + idx * (*len + (snr * ssz));\n\t\t*hdr = *len;\n\t\t*cnt = snr;\n\t\t*len = ssz;\n\t\treturn data;\n\t}\n\treturn 0x00000000;\n}\n\nu32\nnvbios_M0209Ep(struct nvkm_bios *bios, int idx,\n\t       u8 *ver, u8 *hdr, u8 *cnt, u8 *len, struct nvbios_M0209E *info)\n{\n\tu32 data = nvbios_M0209Ee(bios, idx, ver, hdr, cnt, len);\n\tmemset(info, 0x00, sizeof(*info));\n\tswitch (!!data * *ver) {\n\tcase 0x10:\n\t\tinfo->v00_40 = (nvbios_rd08(bios, data + 0x00) & 0x40) >> 6;\n\t\tinfo->bits   =  nvbios_rd08(bios, data + 0x00) & 0x3f;\n\t\tinfo->modulo =  nvbios_rd08(bios, data + 0x01);\n\t\tinfo->v02_40 = (nvbios_rd08(bios, data + 0x02) & 0x40) >> 6;\n\t\tinfo->v02_07 =  nvbios_rd08(bios, data + 0x02) & 0x07;\n\t\tinfo->v03    =  nvbios_rd08(bios, data + 0x03);\n\t\treturn data;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0x00000000;\n}\n\nu32\nnvbios_M0209Se(struct nvkm_bios *bios, int ent, int idx, u8 *ver, u8 *hdr)\n{\n\n\tu8  cnt, len;\n\tu32 data = nvbios_M0209Ee(bios, ent, ver, hdr, &cnt, &len);\n\tif (data && idx < cnt) {\n\t\tdata = data + *hdr + idx * len;\n\t\t*hdr = len;\n\t\treturn data;\n\t}\n\treturn 0x00000000;\n}\n\nu32\nnvbios_M0209Sp(struct nvkm_bios *bios, int ent, int idx, u8 *ver, u8 *hdr,\n\t       struct nvbios_M0209S *info)\n{\n\tstruct nvbios_M0209E M0209E;\n\tu8  cnt, len;\n\tu32 data = nvbios_M0209Ep(bios, ent, ver, hdr, &cnt, &len, &M0209E);\n\tif (data) {\n\t\tu32 i, data = nvbios_M0209Se(bios, ent, idx, ver, hdr);\n\t\tmemset(info, 0x00, sizeof(*info));\n\t\tswitch (!!data * *ver) {\n\t\tcase 0x10:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(info->data); i++) {\n\t\t\t\tu32 bits = (i % M0209E.modulo) * M0209E.bits;\n\t\t\t\tu32 mask = (1ULL << M0209E.bits) - 1;\n\t\t\t\tu16  off = bits / 8;\n\t\t\t\tu8   mod = bits % 8;\n\t\t\t\tinfo->data[i] = nvbios_rd32(bios, data + off);\n\t\t\t\tinfo->data[i] = info->data[i] >> mod;\n\t\t\t\tinfo->data[i] = info->data[i] & mask;\n\t\t\t}\n\t\t\treturn data;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0x00000000;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}