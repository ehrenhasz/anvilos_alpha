{
  "module_name": "gt215.c",
  "hash_id": "92590082ff016253bd036a62c971ee35161be1631e5ce589cc17cdf025a3de3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/gt215.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"fuc/gt215.fuc3.h\"\n\n#include <subdev/timer.h>\n\nint\ngt215_pmu_send(struct nvkm_pmu *pmu, u32 reply[2],\n\t       u32 process, u32 message, u32 data0, u32 data1)\n{\n\tstruct nvkm_subdev *subdev = &pmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 addr;\n\n\tmutex_lock(&pmu->send.mutex);\n\t \n\taddr  = nvkm_rd32(device, 0x10a4a0);\n\tif (nvkm_msec(device, 2000,\n\t\tu32 tmp = nvkm_rd32(device, 0x10a4b0);\n\t\tif (tmp != (addr ^ 8))\n\t\t\tbreak;\n\t) < 0) {\n\t\tmutex_unlock(&pmu->send.mutex);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (reply) {\n\t\tpmu->recv.message = message;\n\t\tpmu->recv.process = process;\n\t}\n\n\t \n\tdo {\n\t\tnvkm_wr32(device, 0x10a580, 0x00000001);\n\t} while (nvkm_rd32(device, 0x10a580) != 0x00000001);\n\n\t \n\tnvkm_wr32(device, 0x10a1c0, 0x01000000 | (((addr & 0x07) << 4) +\n\t\t\t\tpmu->send.base));\n\tnvkm_wr32(device, 0x10a1c4, process);\n\tnvkm_wr32(device, 0x10a1c4, message);\n\tnvkm_wr32(device, 0x10a1c4, data0);\n\tnvkm_wr32(device, 0x10a1c4, data1);\n\tnvkm_wr32(device, 0x10a4a0, (addr + 1) & 0x0f);\n\n\t \n\tnvkm_wr32(device, 0x10a580, 0x00000000);\n\n\t \n\tif (reply) {\n\t\twait_event(pmu->recv.wait, (pmu->recv.process == 0));\n\t\treply[0] = pmu->recv.data[0];\n\t\treply[1] = pmu->recv.data[1];\n\t}\n\n\tmutex_unlock(&pmu->send.mutex);\n\treturn 0;\n}\n\nvoid\ngt215_pmu_recv(struct nvkm_pmu *pmu)\n{\n\tstruct nvkm_subdev *subdev = &pmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 process, message, data0, data1;\n\n\t \n\tu32 addr =  nvkm_rd32(device, 0x10a4cc);\n\tif (addr == nvkm_rd32(device, 0x10a4c8))\n\t\treturn;\n\n\t \n\tdo {\n\t\tnvkm_wr32(device, 0x10a580, 0x00000002);\n\t} while (nvkm_rd32(device, 0x10a580) != 0x00000002);\n\n\t \n\tnvkm_wr32(device, 0x10a1c0, 0x02000000 | (((addr & 0x07) << 4) +\n\t\t\t\tpmu->recv.base));\n\tprocess = nvkm_rd32(device, 0x10a1c4);\n\tmessage = nvkm_rd32(device, 0x10a1c4);\n\tdata0   = nvkm_rd32(device, 0x10a1c4);\n\tdata1   = nvkm_rd32(device, 0x10a1c4);\n\tnvkm_wr32(device, 0x10a4cc, (addr + 1) & 0x0f);\n\n\t \n\tnvkm_wr32(device, 0x10a580, 0x00000000);\n\n\t \n\tif (pmu->recv.process) {\n\t\tif (process == pmu->recv.process &&\n\t\t    message == pmu->recv.message) {\n\t\t\tpmu->recv.data[0] = data0;\n\t\t\tpmu->recv.data[1] = data1;\n\t\t\tpmu->recv.process = 0;\n\t\t\twake_up(&pmu->recv.wait);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tnvkm_warn(subdev, \"%c%c%c%c %08x %08x %08x %08x\\n\",\n\t\t  (char)((process & 0x000000ff) >>  0),\n\t\t  (char)((process & 0x0000ff00) >>  8),\n\t\t  (char)((process & 0x00ff0000) >> 16),\n\t\t  (char)((process & 0xff000000) >> 24),\n\t\t  process, message, data0, data1);\n}\n\nvoid\ngt215_pmu_intr(struct nvkm_pmu *pmu)\n{\n\tstruct nvkm_subdev *subdev = &pmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 disp = nvkm_rd32(device, 0x10a01c);\n\tu32 intr = nvkm_rd32(device, 0x10a008) & disp & ~(disp >> 16);\n\n\tif (intr & 0x00000020) {\n\t\tu32 stat = nvkm_rd32(device, 0x10a16c);\n\t\tif (stat & 0x80000000) {\n\t\t\tnvkm_error(subdev, \"UAS fault at %06x addr %08x\\n\",\n\t\t\t\t   stat & 0x00ffffff,\n\t\t\t\t   nvkm_rd32(device, 0x10a168));\n\t\t\tnvkm_wr32(device, 0x10a16c, 0x00000000);\n\t\t\tintr &= ~0x00000020;\n\t\t}\n\t}\n\n\tif (intr & 0x00000040) {\n\t\tschedule_work(&pmu->recv.work);\n\t\tnvkm_wr32(device, 0x10a004, 0x00000040);\n\t\tintr &= ~0x00000040;\n\t}\n\n\tif (intr & 0x00000080) {\n\t\tnvkm_info(subdev, \"wr32 %06x %08x\\n\",\n\t\t\t  nvkm_rd32(device, 0x10a7a0),\n\t\t\t  nvkm_rd32(device, 0x10a7a4));\n\t\tnvkm_wr32(device, 0x10a004, 0x00000080);\n\t\tintr &= ~0x00000080;\n\t}\n\n\tif (intr) {\n\t\tnvkm_error(subdev, \"intr %08x\\n\", intr);\n\t\tnvkm_wr32(device, 0x10a004, intr);\n\t}\n}\n\nvoid\ngt215_pmu_fini(struct nvkm_pmu *pmu)\n{\n\tnvkm_wr32(pmu->subdev.device, 0x10a014, 0x00000060);\n\tflush_work(&pmu->recv.work);\n}\n\nstatic void\ngt215_pmu_reset(struct nvkm_pmu *pmu)\n{\n\tstruct nvkm_device *device = pmu->subdev.device;\n\n\tnvkm_mask(device, 0x022210, 0x00000001, 0x00000000);\n\tnvkm_mask(device, 0x022210, 0x00000001, 0x00000001);\n\tnvkm_rd32(device, 0x022210);\n}\n\nstatic bool\ngt215_pmu_enabled(struct nvkm_pmu *pmu)\n{\n\treturn nvkm_rd32(pmu->subdev.device, 0x022210) & 0x00000001;\n}\n\nint\ngt215_pmu_init(struct nvkm_pmu *pmu)\n{\n\tstruct nvkm_device *device = pmu->subdev.device;\n\tint i;\n\n\t \n\tif (pmu->func->enabled(pmu)) {\n\t\tnvkm_wr32(device, 0x10a014, 0x0000ffff);\n\t\tnvkm_msec(device, 2000,\n\t\t\tif (!nvkm_rd32(device, 0x10a04c))\n\t\t\t\tbreak;\n\t\t);\n\t}\n\n\tpmu->func->reset(pmu);\n\n\t \n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x10a10c) & 0x00000006))\n\t\t\tbreak;\n\t);\n\n\t \n\tnvkm_wr32(device, 0x10a1c0, 0x01000000);\n\tfor (i = 0; i < pmu->func->data.size / 4; i++)\n\t\tnvkm_wr32(device, 0x10a1c4, pmu->func->data.data[i]);\n\n\t \n\tnvkm_wr32(device, 0x10a180, 0x01000000);\n\tfor (i = 0; i < pmu->func->code.size / 4; i++) {\n\t\tif ((i & 0x3f) == 0)\n\t\t\tnvkm_wr32(device, 0x10a188, i >> 6);\n\t\tnvkm_wr32(device, 0x10a184, pmu->func->code.data[i]);\n\t}\n\n\t \n\tnvkm_wr32(device, 0x10a10c, 0x00000000);\n\tnvkm_wr32(device, 0x10a104, 0x00000000);\n\tnvkm_wr32(device, 0x10a100, 0x00000002);\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x10a4d0))\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -EBUSY;\n\tpmu->send.base = nvkm_rd32(device, 0x10a4d0) & 0x0000ffff;\n\tpmu->send.size = nvkm_rd32(device, 0x10a4d0) >> 16;\n\n\t \n\tif (nvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x10a4dc))\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -EBUSY;\n\tpmu->recv.base = nvkm_rd32(device, 0x10a4dc) & 0x0000ffff;\n\tpmu->recv.size = nvkm_rd32(device, 0x10a4dc) >> 16;\n\n\tnvkm_wr32(device, 0x10a010, 0x000000e0);\n\treturn 0;\n}\n\nconst struct nvkm_falcon_func\ngt215_pmu_flcn = {\n};\n\nstatic const struct nvkm_pmu_func\ngt215_pmu = {\n\t.flcn = &gt215_pmu_flcn,\n\t.code.data = gt215_pmu_code,\n\t.code.size = sizeof(gt215_pmu_code),\n\t.data.data = gt215_pmu_data,\n\t.data.size = sizeof(gt215_pmu_data),\n\t.enabled = gt215_pmu_enabled,\n\t.reset = gt215_pmu_reset,\n\t.init = gt215_pmu_init,\n\t.fini = gt215_pmu_fini,\n\t.intr = gt215_pmu_intr,\n\t.send = gt215_pmu_send,\n\t.recv = gt215_pmu_recv,\n};\n\nstatic const struct nvkm_pmu_fwif\ngt215_pmu_fwif[] = {\n\t{ -1, gf100_pmu_nofw, &gt215_pmu },\n\t{}\n};\n\nint\ngt215_pmu_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_pmu **ppmu)\n{\n\treturn nvkm_pmu_new_(gt215_pmu_fwif, device, type, inst, ppmu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}