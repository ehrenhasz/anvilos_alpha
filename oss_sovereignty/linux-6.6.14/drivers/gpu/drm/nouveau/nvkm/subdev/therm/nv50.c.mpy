{
  "module_name": "nv50.c",
  "hash_id": "b5d7b4aac88833f5b0f9e75984ede1eae1997aae44ac05d876fb4b80ba6d2159",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/nv50.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstatic int\npwm_info(struct nvkm_therm *therm, int *line, int *ctrl, int *indx)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\n\tif (*line == 0x04) {\n\t\t*ctrl = 0x00e100;\n\t\t*line = 4;\n\t\t*indx = 0;\n\t} else\n\tif (*line == 0x09) {\n\t\t*ctrl = 0x00e100;\n\t\t*line = 9;\n\t\t*indx = 1;\n\t} else\n\tif (*line == 0x10) {\n\t\t*ctrl = 0x00e28c;\n\t\t*line = 0;\n\t\t*indx = 0;\n\t} else {\n\t\tnvkm_error(subdev, \"unknown pwm ctrl for gpio %d\\n\", *line);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint\nnv50_fan_pwm_ctrl(struct nvkm_therm *therm, int line, bool enable)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tu32 data = enable ? 0x00000001 : 0x00000000;\n\tint ctrl, id, ret = pwm_info(therm, &line, &ctrl, &id);\n\tif (ret == 0)\n\t\tnvkm_mask(device, ctrl, 0x00010001 << line, data << line);\n\treturn ret;\n}\n\nint\nnv50_fan_pwm_get(struct nvkm_therm *therm, int line, u32 *divs, u32 *duty)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tint ctrl, id, ret = pwm_info(therm, &line, &ctrl, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (nvkm_rd32(device, ctrl) & (1 << line)) {\n\t\t*divs = nvkm_rd32(device, 0x00e114 + (id * 8));\n\t\t*duty = nvkm_rd32(device, 0x00e118 + (id * 8));\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nint\nnv50_fan_pwm_set(struct nvkm_therm *therm, int line, u32 divs, u32 duty)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tint ctrl, id, ret = pwm_info(therm, &line, &ctrl, &id);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_wr32(device, 0x00e114 + (id * 8), divs);\n\tnvkm_wr32(device, 0x00e118 + (id * 8), duty | 0x80000000);\n\treturn 0;\n}\n\nint\nnv50_fan_pwm_clock(struct nvkm_therm *therm, int line)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tint pwm_clock;\n\n\t \n\tif (device->chipset > 0x50 && device->chipset < 0x94) {\n\t\tu8 pwm_div = nvkm_rd32(device, 0x410c);\n\t\tif (nvkm_rd32(device, 0xc040) & 0x800000) {\n\t\t\t \n\t\t\tpwm_clock = (100000000 >> pwm_div) * 10 / 24;\n\t\t} else {\n\t\t\t \n\t\t\tpwm_clock = (device->crystal * 1000) >> pwm_div;\n\t\t\tpwm_clock /= 20;\n\t\t}\n\t} else {\n\t\tpwm_clock = (device->crystal * 1000) / 20;\n\t}\n\n\treturn pwm_clock;\n}\n\nstatic void\nnv50_sensor_setup(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tnvkm_mask(device, 0x20010, 0x40000000, 0x0);\n\tmdelay(20);  \n}\n\nstatic int\nnv50_temp_get(struct nvkm_therm *therm)\n{\n\tstruct nvkm_device *device = therm->subdev.device;\n\tstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\n\tint core_temp;\n\n\tcore_temp = nvkm_rd32(device, 0x20014) & 0x3fff;\n\n\t \n\tif (!sensor->slope_div || !sensor->slope_mult ||\n\t    !sensor->offset_num || !sensor->offset_den)\n\t    return -ENODEV;\n\n\tcore_temp = core_temp * sensor->slope_mult / sensor->slope_div;\n\tcore_temp = core_temp + sensor->offset_num / sensor->offset_den;\n\tcore_temp = core_temp + sensor->offset_constant - 8;\n\n\t \n\tif (core_temp < 0)\n\t\tcore_temp = 0;\n\n\treturn core_temp;\n}\n\nstatic void\nnv50_therm_init(struct nvkm_therm *therm)\n{\n\tnv50_sensor_setup(therm);\n}\n\nstatic const struct nvkm_therm_func\nnv50_therm = {\n\t.init = nv50_therm_init,\n\t.intr = nv40_therm_intr,\n\t.pwm_ctrl = nv50_fan_pwm_ctrl,\n\t.pwm_get = nv50_fan_pwm_get,\n\t.pwm_set = nv50_fan_pwm_set,\n\t.pwm_clock = nv50_fan_pwm_clock,\n\t.temp_get = nv50_temp_get,\n\t.program_alarms = nvkm_therm_program_alarms_polling,\n};\n\nint\nnv50_therm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_therm **ptherm)\n{\n\treturn nvkm_therm_new_(&nv50_therm, device, type, inst, ptherm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}