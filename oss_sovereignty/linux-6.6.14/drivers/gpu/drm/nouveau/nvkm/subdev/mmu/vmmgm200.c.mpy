{
  "module_name": "vmmgm200.c",
  "hash_id": "b7c986d7e04231e7f59ebaf439447f6a8e0a4827d8c880be7a278dd3e5563be0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmgm200.c",
  "human_readable_source": " \n#include \"vmm.h\"\n\n#include <nvif/ifb00d.h>\n#include <nvif/unpack.h>\n\nstatic void\ngm200_vmm_pgt_sparse(struct nvkm_vmm *vmm,\n\t\t     struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\t \n\tVMM_FO064(pt, vmm, ptei * 8, BIT_ULL(32)  , ptes);\n}\n\nstatic const struct nvkm_vmm_desc_func\ngm200_vmm_spt = {\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.sparse = gm200_vmm_pgt_sparse,\n\t.mem = gf100_vmm_pgt_mem,\n\t.dma = gf100_vmm_pgt_dma,\n\t.sgl = gf100_vmm_pgt_sgl,\n};\n\nstatic const struct nvkm_vmm_desc_func\ngm200_vmm_lpt = {\n\t.invalid = gk104_vmm_lpt_invalid,\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.sparse = gm200_vmm_pgt_sparse,\n\t.mem = gf100_vmm_pgt_mem,\n};\n\nstatic void\ngm200_vmm_pgd_sparse(struct nvkm_vmm *vmm,\n\t\t     struct nvkm_mmu_pt *pt, u32 pdei, u32 pdes)\n{\n\t \n\tVMM_FO064(pt, vmm, pdei * 8, BIT_ULL(35)  , pdes);\n}\n\nstatic const struct nvkm_vmm_desc_func\ngm200_vmm_pgd = {\n\t.unmap = gf100_vmm_pgt_unmap,\n\t.sparse = gm200_vmm_pgd_sparse,\n\t.pde = gf100_vmm_pgd_pde,\n};\n\nconst struct nvkm_vmm_desc\ngm200_vmm_desc_17_12[] = {\n\t{ SPT, 15, 8, 0x1000, &gm200_vmm_spt },\n\t{ PGD, 13, 8, 0x1000, &gm200_vmm_pgd },\n\t{}\n};\n\nconst struct nvkm_vmm_desc\ngm200_vmm_desc_17_17[] = {\n\t{ LPT, 10, 8, 0x1000, &gm200_vmm_lpt },\n\t{ PGD, 13, 8, 0x1000, &gm200_vmm_pgd },\n\t{}\n};\n\nconst struct nvkm_vmm_desc\ngm200_vmm_desc_16_12[] = {\n\t{ SPT, 14, 8, 0x1000, &gm200_vmm_spt },\n\t{ PGD, 14, 8, 0x1000, &gm200_vmm_pgd },\n\t{}\n};\n\nconst struct nvkm_vmm_desc\ngm200_vmm_desc_16_16[] = {\n\t{ LPT, 10, 8, 0x1000, &gm200_vmm_lpt },\n\t{ PGD, 14, 8, 0x1000, &gm200_vmm_pgd },\n\t{}\n};\n\nint\ngm200_vmm_join_(struct nvkm_vmm *vmm, struct nvkm_memory *inst, u64 base)\n{\n\tif (vmm->func->page[1].shift == 16)\n\t\tbase |= BIT_ULL(11);\n\treturn gf100_vmm_join_(vmm, inst, base);\n}\n\nint\ngm200_vmm_join(struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\treturn gm200_vmm_join_(vmm, inst, 0);\n}\n\nstatic const struct nvkm_vmm_func\ngm200_vmm_17 = {\n\t.join = gm200_vmm_join,\n\t.part = gf100_vmm_part,\n\t.aper = gf100_vmm_aper,\n\t.valid = gf100_vmm_valid,\n\t.flush = gf100_vmm_flush,\n\t.invalidate_pdb = gf100_vmm_invalidate_pdb,\n\t.page = {\n\t\t{ 27, &gm200_vmm_desc_17_17[1], NVKM_VMM_PAGE_Sxxx },\n\t\t{ 17, &gm200_vmm_desc_17_17[0], NVKM_VMM_PAGE_SVxC },\n\t\t{ 12, &gm200_vmm_desc_17_12[0], NVKM_VMM_PAGE_SVHx },\n\t\t{}\n\t}\n};\n\nstatic const struct nvkm_vmm_func\ngm200_vmm_16 = {\n\t.join = gm200_vmm_join,\n\t.part = gf100_vmm_part,\n\t.aper = gf100_vmm_aper,\n\t.valid = gf100_vmm_valid,\n\t.flush = gf100_vmm_flush,\n\t.invalidate_pdb = gf100_vmm_invalidate_pdb,\n\t.page = {\n\t\t{ 27, &gm200_vmm_desc_16_16[1], NVKM_VMM_PAGE_Sxxx },\n\t\t{ 16, &gm200_vmm_desc_16_16[0], NVKM_VMM_PAGE_SVxC },\n\t\t{ 12, &gm200_vmm_desc_16_12[0], NVKM_VMM_PAGE_SVHx },\n\t\t{}\n\t}\n};\n\nint\ngm200_vmm_new_(const struct nvkm_vmm_func *func_16,\n\t       const struct nvkm_vmm_func *func_17,\n\t       struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t       void *argv, u32 argc, struct lock_class_key *key,\n\t       const char *name, struct nvkm_vmm **pvmm)\n{\n\tconst struct nvkm_vmm_func *func;\n\tunion {\n\t\tstruct gm200_vmm_vn vn;\n\t\tstruct gm200_vmm_v0 v0;\n\t} *args = argv;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\tswitch (args->v0.bigpage) {\n\t\tcase 16: func = func_16; break;\n\t\tcase 17: func = func_17; break;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\tif (!(ret = nvif_unvers(ret, &argv, &argc, args->vn))) {\n\t\tfunc = func_17;\n\t} else\n\t\treturn ret;\n\n\treturn nvkm_vmm_new_(func, mmu, 0, managed, addr, size, key, name, pvmm);\n}\n\nint\ngm200_vmm_new(struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t      void *argv, u32 argc, struct lock_class_key *key,\n\t      const char *name, struct nvkm_vmm **pvmm)\n{\n\treturn gm200_vmm_new_(&gm200_vmm_16, &gm200_vmm_17, mmu, managed, addr,\n\t\t\t      size, argv, argc, key, name, pvmm);\n}\n\nint\ngm200_vmm_new_fixed(struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t\t    void *argv, u32 argc, struct lock_class_key *key,\n\t\t    const char *name, struct nvkm_vmm **pvmm)\n{\n\treturn gf100_vmm_new_(&gm200_vmm_16, &gm200_vmm_17, mmu, managed, addr,\n\t\t\t      size, argv, argc, key, name, pvmm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}