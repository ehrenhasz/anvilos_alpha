{
  "module_name": "init.c",
  "hash_id": "b976ae47143e91141c1761a1978432c7df4b6fc6d6fee40bb012b6bf34b117d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/init.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/bmp.h>\n#include <subdev/bios/conn.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/bios/dp.h>\n#include <subdev/bios/gpio.h>\n#include <subdev/bios/init.h>\n#include <subdev/bios/ramcfg.h>\n\n#include <subdev/devinit.h>\n#include <subdev/gpio.h>\n#include <subdev/i2c.h>\n#include <subdev/vga.h>\n\n#include <linux/kernel.h>\n\n#define bioslog(lvl, fmt, args...) do {                                        \\\n\tnvkm_printk(init->subdev, lvl, info, \"0x%08x[%c]: \"fmt,                \\\n\t\t    init->offset, init_exec(init) ?                            \\\n\t\t    '0' + (init->nested - 1) : ' ', ##args);                   \\\n} while(0)\n#define cont(fmt, args...) do {                                                \\\n\tif (init->subdev->debug >= NV_DBG_TRACE)                               \\\n\t\tprintk(fmt, ##args);                                           \\\n} while(0)\n#define trace(fmt, args...) bioslog(TRACE, fmt, ##args)\n#define warn(fmt, args...) bioslog(WARN, fmt, ##args)\n#define error(fmt, args...) bioslog(ERROR, fmt, ##args)\n\n \n\nstatic inline bool\ninit_exec(struct nvbios_init *init)\n{\n\treturn (init->execute == 1) || ((init->execute & 5) == 5);\n}\n\nstatic inline void\ninit_exec_set(struct nvbios_init *init, bool exec)\n{\n\tif (exec) init->execute &= 0xfd;\n\telse      init->execute |= 0x02;\n}\n\nstatic inline void\ninit_exec_inv(struct nvbios_init *init)\n{\n\tinit->execute ^= 0x02;\n}\n\nstatic inline void\ninit_exec_force(struct nvbios_init *init, bool exec)\n{\n\tif (exec) init->execute |= 0x04;\n\telse      init->execute &= 0xfb;\n}\n\n \n\nstatic inline int\ninit_or(struct nvbios_init *init)\n{\n\tif (init_exec(init)) {\n\t\tif (init->or >= 0)\n\t\t\treturn init->or;\n\t\terror(\"script needs OR!!\\n\");\n\t}\n\treturn 0;\n}\n\nstatic inline int\ninit_link(struct nvbios_init *init)\n{\n\tif (init_exec(init)) {\n\t\tif (init->link)\n\t\t\treturn init->link == 2;\n\t\terror(\"script needs OR link\\n\");\n\t}\n\treturn 0;\n}\n\nstatic inline int\ninit_head(struct nvbios_init *init)\n{\n\tif (init_exec(init)) {\n\t\tif (init->head >= 0)\n\t\t\treturn init->head;\n\t\terror(\"script needs head\\n\");\n\t}\n\treturn 0;\n}\n\nstatic u8\ninit_conn(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tstruct nvbios_connE connE;\n\tu8  ver, hdr;\n\tu32 conn;\n\n\tif (init_exec(init)) {\n\t\tif (init->outp) {\n\t\t\tconn = init->outp->connector;\n\t\t\tconn = nvbios_connEp(bios, conn, &ver, &hdr, &connE);\n\t\t\tif (conn)\n\t\t\t\treturn connE.type;\n\t\t}\n\n\t\terror(\"script needs connector type\\n\");\n\t}\n\n\treturn 0xff;\n}\n\nstatic inline u32\ninit_nvreg(struct nvbios_init *init, u32 reg)\n{\n\tstruct nvkm_devinit *devinit = init->subdev->device->devinit;\n\n\t \n\treg &= ~0x00000003;\n\n\t \n\tif (init->subdev->device->card_type >= NV_50) {\n\t\tif (reg & 0x80000000) {\n\t\t\treg += init_head(init) * 0x800;\n\t\t\treg &= ~0x80000000;\n\t\t}\n\n\t\tif (reg & 0x40000000) {\n\t\t\treg += init_or(init) * 0x800;\n\t\t\treg &= ~0x40000000;\n\t\t\tif (reg & 0x20000000) {\n\t\t\t\treg += init_link(init) * 0x80;\n\t\t\t\treg &= ~0x20000000;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (reg & ~0x00fffffc)\n\t\twarn(\"unknown bits in register 0x%08x\\n\", reg);\n\n\treturn nvkm_devinit_mmio(devinit, reg);\n}\n\nstatic u32\ninit_rd32(struct nvbios_init *init, u32 reg)\n{\n\tstruct nvkm_device *device = init->subdev->device;\n\treg = init_nvreg(init, reg);\n\tif (reg != ~0 && init_exec(init))\n\t\treturn nvkm_rd32(device, reg);\n\treturn 0x00000000;\n}\n\nstatic void\ninit_wr32(struct nvbios_init *init, u32 reg, u32 val)\n{\n\tstruct nvkm_device *device = init->subdev->device;\n\treg = init_nvreg(init, reg);\n\tif (reg != ~0 && init_exec(init))\n\t\tnvkm_wr32(device, reg, val);\n}\n\nstatic u32\ninit_mask(struct nvbios_init *init, u32 reg, u32 mask, u32 val)\n{\n\tstruct nvkm_device *device = init->subdev->device;\n\treg = init_nvreg(init, reg);\n\tif (reg != ~0 && init_exec(init)) {\n\t\tu32 tmp = nvkm_rd32(device, reg);\n\t\tnvkm_wr32(device, reg, (tmp & ~mask) | val);\n\t\treturn tmp;\n\t}\n\treturn 0x00000000;\n}\n\nstatic u8\ninit_rdport(struct nvbios_init *init, u16 port)\n{\n\tif (init_exec(init))\n\t\treturn nvkm_rdport(init->subdev->device, init->head, port);\n\treturn 0x00;\n}\n\nstatic void\ninit_wrport(struct nvbios_init *init, u16 port, u8 value)\n{\n\tif (init_exec(init))\n\t\tnvkm_wrport(init->subdev->device, init->head, port, value);\n}\n\nstatic u8\ninit_rdvgai(struct nvbios_init *init, u16 port, u8 index)\n{\n\tstruct nvkm_subdev *subdev = init->subdev;\n\tif (init_exec(init)) {\n\t\tint head = init->head < 0 ? 0 : init->head;\n\t\treturn nvkm_rdvgai(subdev->device, head, port, index);\n\t}\n\treturn 0x00;\n}\n\nstatic void\ninit_wrvgai(struct nvbios_init *init, u16 port, u8 index, u8 value)\n{\n\tstruct nvkm_device *device = init->subdev->device;\n\n\t \n\tif (device->card_type < NV_50) {\n\t\tif (port == 0x03d4 && index == 0x44)\n\t\t\tinit->head = 0;\n\t}\n\n\tif (init_exec(init)) {\n\t\tint head = init->head < 0 ? 0 : init->head;\n\t\tnvkm_wrvgai(device, head, port, index, value);\n\t}\n\n\t \n\tif (device->card_type < NV_50) {\n\t\tif (port == 0x03d4 && index == 0x44 && value == 3)\n\t\t\tinit->head = 1;\n\t}\n}\n\nstatic struct i2c_adapter *\ninit_i2c(struct nvbios_init *init, int index)\n{\n\tstruct nvkm_i2c *i2c = init->subdev->device->i2c;\n\tstruct nvkm_i2c_bus *bus;\n\n\tif (index == 0xff) {\n\t\tindex = NVKM_I2C_BUS_PRI;\n\t\tif (init->outp && init->outp->i2c_upper_default)\n\t\t\tindex = NVKM_I2C_BUS_SEC;\n\t} else\n\tif (index == 0x80) {\n\t\tindex = NVKM_I2C_BUS_PRI;\n\t} else\n\tif (index == 0x81) {\n\t\tindex = NVKM_I2C_BUS_SEC;\n\t}\n\n\tbus = nvkm_i2c_bus_find(i2c, index);\n\treturn bus ? &bus->i2c : NULL;\n}\n\nstatic int\ninit_rdi2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg)\n{\n\tstruct i2c_adapter *adap = init_i2c(init, index);\n\tif (adap && init_exec(init))\n\t\treturn nvkm_rdi2cr(adap, addr, reg);\n\treturn -ENODEV;\n}\n\nstatic int\ninit_wri2cr(struct nvbios_init *init, u8 index, u8 addr, u8 reg, u8 val)\n{\n\tstruct i2c_adapter *adap = init_i2c(init, index);\n\tif (adap && init_exec(init))\n\t\treturn nvkm_wri2cr(adap, addr, reg, val);\n\treturn -ENODEV;\n}\n\nstatic struct nvkm_i2c_aux *\ninit_aux(struct nvbios_init *init)\n{\n\tstruct nvkm_i2c *i2c = init->subdev->device->i2c;\n\tif (!init->outp) {\n\t\tif (init_exec(init))\n\t\t\terror(\"script needs output for aux\\n\");\n\t\treturn NULL;\n\t}\n\treturn nvkm_i2c_aux_find(i2c, init->outp->i2c_index);\n}\n\nstatic u8\ninit_rdauxr(struct nvbios_init *init, u32 addr)\n{\n\tstruct nvkm_i2c_aux *aux = init_aux(init);\n\tu8 data;\n\n\tif (aux && init_exec(init)) {\n\t\tint ret = nvkm_rdaux(aux, addr, &data, 1);\n\t\tif (ret == 0)\n\t\t\treturn data;\n\t\ttrace(\"auxch read failed with %d\\n\", ret);\n\t}\n\n\treturn 0x00;\n}\n\nstatic int\ninit_wrauxr(struct nvbios_init *init, u32 addr, u8 data)\n{\n\tstruct nvkm_i2c_aux *aux = init_aux(init);\n\tif (aux && init_exec(init)) {\n\t\tint ret = nvkm_wraux(aux, addr, &data, 1);\n\t\tif (ret)\n\t\t\ttrace(\"auxch write failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn -ENODEV;\n}\n\nstatic void\ninit_prog_pll(struct nvbios_init *init, u32 id, u32 freq)\n{\n\tstruct nvkm_devinit *devinit = init->subdev->device->devinit;\n\tif (init_exec(init)) {\n\t\tint ret = nvkm_devinit_pll_set(devinit, id, freq);\n\t\tif (ret)\n\t\t\twarn(\"failed to prog pll 0x%08x to %dkHz\\n\", id, freq);\n\t}\n}\n\n \n\nstatic u16\ninit_table(struct nvkm_bios *bios, u16 *len)\n{\n\tstruct bit_entry bit_I;\n\n\tif (!bit_entry(bios, 'I', &bit_I)) {\n\t\t*len = bit_I.length;\n\t\treturn bit_I.offset;\n\t}\n\n\tif (bmp_version(bios) >= 0x0510) {\n\t\t*len = 14;\n\t\treturn bios->bmp_offset + 75;\n\t}\n\n\treturn 0x0000;\n}\n\nstatic u16\ninit_table_(struct nvbios_init *init, u16 offset, const char *name)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 len, data = init_table(bios, &len);\n\tif (data) {\n\t\tif (len >= offset + 2) {\n\t\t\tdata = nvbios_rd16(bios, data + offset);\n\t\t\tif (data)\n\t\t\t\treturn data;\n\n\t\t\twarn(\"%s pointer invalid\\n\", name);\n\t\t\treturn 0x0000;\n\t\t}\n\n\t\twarn(\"init data too short for %s pointer\", name);\n\t\treturn 0x0000;\n\t}\n\n\twarn(\"init data not found\\n\");\n\treturn 0x0000;\n}\n\n#define init_script_table(b) init_table_((b), 0x00, \"script table\")\n#define init_macro_index_table(b) init_table_((b), 0x02, \"macro index table\")\n#define init_macro_table(b) init_table_((b), 0x04, \"macro table\")\n#define init_condition_table(b) init_table_((b), 0x06, \"condition table\")\n#define init_io_condition_table(b) init_table_((b), 0x08, \"io condition table\")\n#define init_io_flag_condition_table(b) init_table_((b), 0x0a, \"io flag condition table\")\n#define init_function_table(b) init_table_((b), 0x0c, \"function table\")\n#define init_xlat_table(b) init_table_((b), 0x10, \"xlat table\");\n\nstatic u16\ninit_script(struct nvkm_bios *bios, int index)\n{\n\tstruct nvbios_init init = { .subdev = &bios->subdev };\n\tu16 bmp_ver = bmp_version(bios), data;\n\n\tif (bmp_ver && bmp_ver < 0x0510) {\n\t\tif (index > 1 || bmp_ver < 0x0100)\n\t\t\treturn 0x0000;\n\n\t\tdata = bios->bmp_offset + (bmp_ver < 0x0200 ? 14 : 18);\n\t\treturn nvbios_rd16(bios, data + (index * 2));\n\t}\n\n\tdata = init_script_table(&init);\n\tif (data)\n\t\treturn nvbios_rd16(bios, data + (index * 2));\n\n\treturn 0x0000;\n}\n\nstatic u16\ninit_unknown_script(struct nvkm_bios *bios)\n{\n\tu16 len, data = init_table(bios, &len);\n\tif (data && len >= 16)\n\t\treturn nvbios_rd16(bios, data + 14);\n\treturn 0x0000;\n}\n\nstatic u8\ninit_ram_restrict_group_count(struct nvbios_init *init)\n{\n\treturn nvbios_ramcfg_count(init->subdev->device->bios);\n}\n\nstatic u8\ninit_ram_restrict(struct nvbios_init *init)\n{\n\t \n\tif (!init->ramcfg || init->subdev->device->bios->version.major < 0x70)\n\t\tinit->ramcfg = 0x80000000 | nvbios_ramcfg_index(init->subdev);\n\treturn (init->ramcfg & 0x7fffffff);\n}\n\nstatic u8\ninit_xlat_(struct nvbios_init *init, u8 index, u8 offset)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 table = init_xlat_table(init);\n\tif (table) {\n\t\tu16 data = nvbios_rd16(bios, table + (index * 2));\n\t\tif (data)\n\t\t\treturn nvbios_rd08(bios, data + offset);\n\t\twarn(\"xlat table pointer %d invalid\\n\", index);\n\t}\n\treturn 0x00;\n}\n\n \n\nstatic bool\ninit_condition_met(struct nvbios_init *init, u8 cond)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 table = init_condition_table(init);\n\tif (table) {\n\t\tu32 reg = nvbios_rd32(bios, table + (cond * 12) + 0);\n\t\tu32 msk = nvbios_rd32(bios, table + (cond * 12) + 4);\n\t\tu32 val = nvbios_rd32(bios, table + (cond * 12) + 8);\n\t\ttrace(\"\\t[0x%02x] (R[0x%06x] & 0x%08x) == 0x%08x\\n\",\n\t\t      cond, reg, msk, val);\n\t\treturn (init_rd32(init, reg) & msk) == val;\n\t}\n\treturn false;\n}\n\nstatic bool\ninit_io_condition_met(struct nvbios_init *init, u8 cond)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 table = init_io_condition_table(init);\n\tif (table) {\n\t\tu16 port = nvbios_rd16(bios, table + (cond * 5) + 0);\n\t\tu8 index = nvbios_rd08(bios, table + (cond * 5) + 2);\n\t\tu8  mask = nvbios_rd08(bios, table + (cond * 5) + 3);\n\t\tu8 value = nvbios_rd08(bios, table + (cond * 5) + 4);\n\t\ttrace(\"\\t[0x%02x] (0x%04x[0x%02x] & 0x%02x) == 0x%02x\\n\",\n\t\t      cond, port, index, mask, value);\n\t\treturn (init_rdvgai(init, port, index) & mask) == value;\n\t}\n\treturn false;\n}\n\nstatic bool\ninit_io_flag_condition_met(struct nvbios_init *init, u8 cond)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 table = init_io_flag_condition_table(init);\n\tif (table) {\n\t\tu16 port = nvbios_rd16(bios, table + (cond * 9) + 0);\n\t\tu8 index = nvbios_rd08(bios, table + (cond * 9) + 2);\n\t\tu8  mask = nvbios_rd08(bios, table + (cond * 9) + 3);\n\t\tu8 shift = nvbios_rd08(bios, table + (cond * 9) + 4);\n\t\tu16 data = nvbios_rd16(bios, table + (cond * 9) + 5);\n\t\tu8 dmask = nvbios_rd08(bios, table + (cond * 9) + 7);\n\t\tu8 value = nvbios_rd08(bios, table + (cond * 9) + 8);\n\t\tu8 ioval = (init_rdvgai(init, port, index) & mask) >> shift;\n\t\treturn (nvbios_rd08(bios, data + ioval) & dmask) == value;\n\t}\n\treturn false;\n}\n\nstatic inline u32\ninit_shift(u32 data, u8 shift)\n{\n\tif (shift < 0x80)\n\t\treturn data >> shift;\n\treturn data << (0x100 - shift);\n}\n\nstatic u32\ninit_tmds_reg(struct nvbios_init *init, u8 tmds)\n{\n\t \n\tconst int pramdac_offset[13] = {\n\t\t0, 0, 0x8, 0, 0x2000, 0, 0, 0, 0x2008, 0, 0, 0, 0x2000 };\n\tconst u32 pramdac_table[4] = {\n\t\t0x6808b0, 0x6808b8, 0x6828b0, 0x6828b8 };\n\n\tif (tmds >= 0x80) {\n\t\tif (init->outp) {\n\t\t\tu32 dacoffset = pramdac_offset[init->outp->or];\n\t\t\tif (tmds == 0x81)\n\t\t\t\tdacoffset ^= 8;\n\t\t\treturn 0x6808b0 + dacoffset;\n\t\t}\n\n\t\tif (init_exec(init))\n\t\t\terror(\"tmds opcodes need dcb\\n\");\n\t} else {\n\t\tif (tmds < ARRAY_SIZE(pramdac_table))\n\t\t\treturn pramdac_table[tmds];\n\n\t\terror(\"tmds selector 0x%02x unknown\\n\", tmds);\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic void\ninit_reserved(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 opcode = nvbios_rd08(bios, init->offset);\n\tu8 length, i;\n\n\tswitch (opcode) {\n\tcase 0xaa:\n\t\tlength = 4;\n\t\tbreak;\n\tdefault:\n\t\tlength = 1;\n\t\tbreak;\n\t}\n\n\ttrace(\"RESERVED 0x%02x\\t\", opcode);\n\tfor (i = 1; i < length; i++)\n\t\tcont(\" 0x%02x\", nvbios_rd08(bios, init->offset + i));\n\tcont(\"\\n\");\n\tinit->offset += length;\n}\n\n \nstatic void\ninit_done(struct nvbios_init *init)\n{\n\ttrace(\"DONE\\n\");\n\tinit->offset = 0x0000;\n}\n\n \nstatic void\ninit_io_restrict_prog(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 port = nvbios_rd16(bios, init->offset + 1);\n\tu8 index = nvbios_rd08(bios, init->offset + 3);\n\tu8  mask = nvbios_rd08(bios, init->offset + 4);\n\tu8 shift = nvbios_rd08(bios, init->offset + 5);\n\tu8 count = nvbios_rd08(bios, init->offset + 6);\n\tu32  reg = nvbios_rd32(bios, init->offset + 7);\n\tu8 conf, i;\n\n\ttrace(\"IO_RESTRICT_PROG\\tR[0x%06x] = \"\n\t      \"((0x%04x[0x%02x] & 0x%02x) >> %d) [{\\n\",\n\t      reg, port, index, mask, shift);\n\tinit->offset += 11;\n\n\tconf = (init_rdvgai(init, port, index) & mask) >> shift;\n\tfor (i = 0; i < count; i++) {\n\t\tu32 data = nvbios_rd32(bios, init->offset);\n\n\t\tif (i == conf) {\n\t\t\ttrace(\"\\t0x%08x *\\n\", data);\n\t\t\tinit_wr32(init, reg, data);\n\t\t} else {\n\t\t\ttrace(\"\\t0x%08x\\n\", data);\n\t\t}\n\n\t\tinit->offset += 4;\n\t}\n\ttrace(\"}]\\n\");\n}\n\n \nstatic void\ninit_repeat(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 count = nvbios_rd08(bios, init->offset + 1);\n\tu16 repeat = init->repeat;\n\n\ttrace(\"REPEAT\\t0x%02x\\n\", count);\n\tinit->offset += 2;\n\n\tinit->repeat = init->offset;\n\tinit->repend = init->offset;\n\twhile (count--) {\n\t\tinit->offset = init->repeat;\n\t\tnvbios_exec(init);\n\t\tif (count)\n\t\t\ttrace(\"REPEAT\\t0x%02x\\n\", count);\n\t}\n\tinit->offset = init->repend;\n\tinit->repeat = repeat;\n}\n\n \nstatic void\ninit_io_restrict_pll(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 port = nvbios_rd16(bios, init->offset + 1);\n\tu8 index = nvbios_rd08(bios, init->offset + 3);\n\tu8  mask = nvbios_rd08(bios, init->offset + 4);\n\tu8 shift = nvbios_rd08(bios, init->offset + 5);\n\ts8  iofc = nvbios_rd08(bios, init->offset + 6);\n\tu8 count = nvbios_rd08(bios, init->offset + 7);\n\tu32  reg = nvbios_rd32(bios, init->offset + 8);\n\tu8 conf, i;\n\n\ttrace(\"IO_RESTRICT_PLL\\tR[0x%06x] =PLL= \"\n\t      \"((0x%04x[0x%02x] & 0x%02x) >> 0x%02x) IOFCOND 0x%02x [{\\n\",\n\t      reg, port, index, mask, shift, iofc);\n\tinit->offset += 12;\n\n\tconf = (init_rdvgai(init, port, index) & mask) >> shift;\n\tfor (i = 0; i < count; i++) {\n\t\tu32 freq = nvbios_rd16(bios, init->offset) * 10;\n\n\t\tif (i == conf) {\n\t\t\ttrace(\"\\t%dkHz *\\n\", freq);\n\t\t\tif (iofc > 0 && init_io_flag_condition_met(init, iofc))\n\t\t\t\tfreq *= 2;\n\t\t\tinit_prog_pll(init, reg, freq);\n\t\t} else {\n\t\t\ttrace(\"\\t%dkHz\\n\", freq);\n\t\t}\n\n\t\tinit->offset += 2;\n\t}\n\ttrace(\"}]\\n\");\n}\n\n \nstatic void\ninit_end_repeat(struct nvbios_init *init)\n{\n\ttrace(\"END_REPEAT\\n\");\n\tinit->offset += 1;\n\n\tif (init->repeat) {\n\t\tinit->repend = init->offset;\n\t\tinit->offset = 0;\n\t}\n}\n\n \nstatic void\ninit_copy(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu8 shift = nvbios_rd08(bios, init->offset + 5);\n\tu8 smask = nvbios_rd08(bios, init->offset + 6);\n\tu16 port = nvbios_rd16(bios, init->offset + 7);\n\tu8 index = nvbios_rd08(bios, init->offset + 9);\n\tu8  mask = nvbios_rd08(bios, init->offset + 10);\n\tu8  data;\n\n\ttrace(\"COPY\\t0x%04x[0x%02x] &= 0x%02x |= \"\n\t      \"((R[0x%06x] %s 0x%02x) & 0x%02x)\\n\",\n\t      port, index, mask, reg, (shift & 0x80) ? \"<<\" : \">>\",\n\t      (shift & 0x80) ? (0x100 - shift) : shift, smask);\n\tinit->offset += 11;\n\n\tdata  = init_rdvgai(init, port, index) & mask;\n\tdata |= init_shift(init_rd32(init, reg), shift) & smask;\n\tinit_wrvgai(init, port, index, data);\n}\n\n \nstatic void\ninit_not(struct nvbios_init *init)\n{\n\ttrace(\"NOT\\n\");\n\tinit->offset += 1;\n\tinit_exec_inv(init);\n}\n\n \nstatic void\ninit_io_flag_condition(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 cond = nvbios_rd08(bios, init->offset + 1);\n\n\ttrace(\"IO_FLAG_CONDITION\\t0x%02x\\n\", cond);\n\tinit->offset += 2;\n\n\tif (!init_io_flag_condition_met(init, cond))\n\t\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_generic_condition(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tstruct nvbios_dpout info;\n\tu8  cond = nvbios_rd08(bios, init->offset + 1);\n\tu8  size = nvbios_rd08(bios, init->offset + 2);\n\tu8  ver, hdr, cnt, len;\n\tu16 data;\n\n\ttrace(\"GENERIC_CONDITION\\t0x%02x 0x%02x\\n\", cond, size);\n\tinit->offset += 3;\n\n\tswitch (cond) {\n\tcase 0:  \n\t\tif (init_conn(init) != DCB_CONNECTOR_eDP)\n\t\t\tinit_exec_set(init, false);\n\t\tbreak;\n\tcase 1:  \n\tcase 2:  \n\t\tif ( init->outp &&\n\t\t    (data = nvbios_dpout_match(bios, DCB_OUTPUT_DP,\n\t\t\t\t\t       (init->outp->or << 0) |\n\t\t\t\t\t       (init->outp->sorconf.link << 6),\n\t\t\t\t\t       &ver, &hdr, &cnt, &len, &info)))\n\t\t{\n\t\t\tif (!(info.flags & cond))\n\t\t\t\tinit_exec_set(init, false);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (init_exec(init))\n\t\t\twarn(\"script needs dp output table data\\n\");\n\t\tbreak;\n\tcase 5:  \n\t\tif (!(init_rdauxr(init, 0x0d) & 1))\n\t\t\tinit_exec_set(init, false);\n\t\tbreak;\n\tcase 7:  \n\t\tinit_exec_set(init, false);\n\t\tbreak;\n\tdefault:\n\t\twarn(\"INIT_GENERIC_CONDITION: unknown 0x%02x\\n\", cond);\n\t\tinit->offset += size;\n\t\tbreak;\n\t}\n}\n\n \nstatic void\ninit_io_mask_or(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8    or = init_or(init);\n\tu8  data;\n\n\ttrace(\"IO_MASK_OR\\t0x03d4[0x%02x] &= ~(1 << 0x%02x)\\n\", index, or);\n\tinit->offset += 2;\n\n\tdata = init_rdvgai(init, 0x03d4, index);\n\tinit_wrvgai(init, 0x03d4, index, data &= ~(1 << or));\n}\n\n \nstatic void\ninit_io_or(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8    or = init_or(init);\n\tu8  data;\n\n\ttrace(\"IO_OR\\t0x03d4[0x%02x] |= (1 << 0x%02x)\\n\", index, or);\n\tinit->offset += 2;\n\n\tdata = init_rdvgai(init, 0x03d4, index);\n\tinit_wrvgai(init, 0x03d4, index, data | (1 << or));\n}\n\n \nstatic void\ninit_andn_reg(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu32 mask = nvbios_rd32(bios, init->offset + 5);\n\n\ttrace(\"ANDN_REG\\tR[0x%06x] &= ~0x%08x\\n\", reg, mask);\n\tinit->offset += 9;\n\n\tinit_mask(init, reg, mask, 0);\n}\n\n \nstatic void\ninit_or_reg(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu32 mask = nvbios_rd32(bios, init->offset + 5);\n\n\ttrace(\"OR_REG\\tR[0x%06x] |= 0x%08x\\n\", reg, mask);\n\tinit->offset += 9;\n\n\tinit_mask(init, reg, 0, mask);\n}\n\n \nstatic void\ninit_idx_addr_latched(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 creg = nvbios_rd32(bios, init->offset + 1);\n\tu32 dreg = nvbios_rd32(bios, init->offset + 5);\n\tu32 mask = nvbios_rd32(bios, init->offset + 9);\n\tu32 data = nvbios_rd32(bios, init->offset + 13);\n\tu8 count = nvbios_rd08(bios, init->offset + 17);\n\n\ttrace(\"INDEX_ADDRESS_LATCHED\\tR[0x%06x] : R[0x%06x]\\n\", creg, dreg);\n\ttrace(\"\\tCTRL &= 0x%08x |= 0x%08x\\n\", mask, data);\n\tinit->offset += 18;\n\n\twhile (count--) {\n\t\tu8 iaddr = nvbios_rd08(bios, init->offset + 0);\n\t\tu8 idata = nvbios_rd08(bios, init->offset + 1);\n\n\t\ttrace(\"\\t[0x%02x] = 0x%02x\\n\", iaddr, idata);\n\t\tinit->offset += 2;\n\n\t\tinit_wr32(init, dreg, idata);\n\t\tinit_mask(init, creg, ~mask, data | iaddr);\n\t}\n}\n\n \nstatic void\ninit_io_restrict_pll2(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 port = nvbios_rd16(bios, init->offset + 1);\n\tu8 index = nvbios_rd08(bios, init->offset + 3);\n\tu8  mask = nvbios_rd08(bios, init->offset + 4);\n\tu8 shift = nvbios_rd08(bios, init->offset + 5);\n\tu8 count = nvbios_rd08(bios, init->offset + 6);\n\tu32  reg = nvbios_rd32(bios, init->offset + 7);\n\tu8  conf, i;\n\n\ttrace(\"IO_RESTRICT_PLL2\\t\"\n\t      \"R[0x%06x] =PLL= ((0x%04x[0x%02x] & 0x%02x) >> 0x%02x) [{\\n\",\n\t      reg, port, index, mask, shift);\n\tinit->offset += 11;\n\n\tconf = (init_rdvgai(init, port, index) & mask) >> shift;\n\tfor (i = 0; i < count; i++) {\n\t\tu32 freq = nvbios_rd32(bios, init->offset);\n\t\tif (i == conf) {\n\t\t\ttrace(\"\\t%dkHz *\\n\", freq);\n\t\t\tinit_prog_pll(init, reg, freq);\n\t\t} else {\n\t\t\ttrace(\"\\t%dkHz\\n\", freq);\n\t\t}\n\t\tinit->offset += 4;\n\t}\n\ttrace(\"}]\\n\");\n}\n\n \nstatic void\ninit_pll2(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu32 freq = nvbios_rd32(bios, init->offset + 5);\n\n\ttrace(\"PLL2\\tR[0x%06x] =PLL= %dkHz\\n\", reg, freq);\n\tinit->offset += 9;\n\n\tinit_prog_pll(init, reg, freq);\n}\n\n \nstatic void\ninit_i2c_byte(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;\n\tu8 count = nvbios_rd08(bios, init->offset + 3);\n\n\ttrace(\"I2C_BYTE\\tI2C[0x%02x][0x%02x]\\n\", index, addr);\n\tinit->offset += 4;\n\n\twhile (count--) {\n\t\tu8  reg = nvbios_rd08(bios, init->offset + 0);\n\t\tu8 mask = nvbios_rd08(bios, init->offset + 1);\n\t\tu8 data = nvbios_rd08(bios, init->offset + 2);\n\t\tint val;\n\n\t\ttrace(\"\\t[0x%02x] &= 0x%02x |= 0x%02x\\n\", reg, mask, data);\n\t\tinit->offset += 3;\n\n\t\tval = init_rdi2cr(init, index, addr, reg);\n\t\tif (val < 0)\n\t\t\tcontinue;\n\t\tinit_wri2cr(init, index, addr, reg, (val & mask) | data);\n\t}\n}\n\n \nstatic void\ninit_zm_i2c_byte(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;\n\tu8 count = nvbios_rd08(bios, init->offset + 3);\n\n\ttrace(\"ZM_I2C_BYTE\\tI2C[0x%02x][0x%02x]\\n\", index, addr);\n\tinit->offset += 4;\n\n\twhile (count--) {\n\t\tu8  reg = nvbios_rd08(bios, init->offset + 0);\n\t\tu8 data = nvbios_rd08(bios, init->offset + 1);\n\n\t\ttrace(\"\\t[0x%02x] = 0x%02x\\n\", reg, data);\n\t\tinit->offset += 2;\n\n\t\tinit_wri2cr(init, index, addr, reg, data);\n\t}\n}\n\n \nstatic void\ninit_zm_i2c(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;\n\tu8 count = nvbios_rd08(bios, init->offset + 3);\n\tu8 data[256], i;\n\n\ttrace(\"ZM_I2C\\tI2C[0x%02x][0x%02x]\\n\", index, addr);\n\tinit->offset += 4;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdata[i] = nvbios_rd08(bios, init->offset);\n\t\ttrace(\"\\t0x%02x\\n\", data[i]);\n\t\tinit->offset++;\n\t}\n\n\tif (init_exec(init)) {\n\t\tstruct i2c_adapter *adap = init_i2c(init, index);\n\t\tstruct i2c_msg msg = {\n\t\t\t.addr = addr, .flags = 0, .len = count, .buf = data,\n\t\t};\n\t\tint ret;\n\n\t\tif (adap && (ret = i2c_transfer(adap, &msg, 1)) != 1)\n\t\t\twarn(\"i2c wr failed, %d\\n\", ret);\n\t}\n}\n\n \nstatic void\ninit_tmds(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 tmds = nvbios_rd08(bios, init->offset + 1);\n\tu8 addr = nvbios_rd08(bios, init->offset + 2);\n\tu8 mask = nvbios_rd08(bios, init->offset + 3);\n\tu8 data = nvbios_rd08(bios, init->offset + 4);\n\tu32 reg = init_tmds_reg(init, tmds);\n\n\ttrace(\"TMDS\\tT[0x%02x][0x%02x] &= 0x%02x |= 0x%02x\\n\",\n\t      tmds, addr, mask, data);\n\tinit->offset += 5;\n\n\tif (reg == 0)\n\t\treturn;\n\n\tinit_wr32(init, reg + 0, addr | 0x00010000);\n\tinit_wr32(init, reg + 4, data | (init_rd32(init, reg + 4) & mask));\n\tinit_wr32(init, reg + 0, addr);\n}\n\n \nstatic void\ninit_zm_tmds_group(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8  tmds = nvbios_rd08(bios, init->offset + 1);\n\tu8 count = nvbios_rd08(bios, init->offset + 2);\n\tu32  reg = init_tmds_reg(init, tmds);\n\n\ttrace(\"TMDS_ZM_GROUP\\tT[0x%02x]\\n\", tmds);\n\tinit->offset += 3;\n\n\twhile (count--) {\n\t\tu8 addr = nvbios_rd08(bios, init->offset + 0);\n\t\tu8 data = nvbios_rd08(bios, init->offset + 1);\n\n\t\ttrace(\"\\t[0x%02x] = 0x%02x\\n\", addr, data);\n\t\tinit->offset += 2;\n\n\t\tinit_wr32(init, reg + 4, data);\n\t\tinit_wr32(init, reg + 0, addr);\n\t}\n}\n\n \nstatic void\ninit_cr_idx_adr_latch(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 addr0 = nvbios_rd08(bios, init->offset + 1);\n\tu8 addr1 = nvbios_rd08(bios, init->offset + 2);\n\tu8  base = nvbios_rd08(bios, init->offset + 3);\n\tu8 count = nvbios_rd08(bios, init->offset + 4);\n\tu8 save0;\n\n\ttrace(\"CR_INDEX_ADDR C[%02x] C[%02x]\\n\", addr0, addr1);\n\tinit->offset += 5;\n\n\tsave0 = init_rdvgai(init, 0x03d4, addr0);\n\twhile (count--) {\n\t\tu8 data = nvbios_rd08(bios, init->offset);\n\n\t\ttrace(\"\\t\\t[0x%02x] = 0x%02x\\n\", base, data);\n\t\tinit->offset += 1;\n\n\t\tinit_wrvgai(init, 0x03d4, addr0, base++);\n\t\tinit_wrvgai(init, 0x03d4, addr1, data);\n\t}\n\tinit_wrvgai(init, 0x03d4, addr0, save0);\n}\n\n \nstatic void\ninit_cr(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 addr = nvbios_rd08(bios, init->offset + 1);\n\tu8 mask = nvbios_rd08(bios, init->offset + 2);\n\tu8 data = nvbios_rd08(bios, init->offset + 3);\n\tu8 val;\n\n\ttrace(\"CR\\t\\tC[0x%02x] &= 0x%02x |= 0x%02x\\n\", addr, mask, data);\n\tinit->offset += 4;\n\n\tval = init_rdvgai(init, 0x03d4, addr) & mask;\n\tinit_wrvgai(init, 0x03d4, addr, val | data);\n}\n\n \nstatic void\ninit_zm_cr(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 addr = nvbios_rd08(bios, init->offset + 1);\n\tu8 data = nvbios_rd08(bios, init->offset + 2);\n\n\ttrace(\"ZM_CR\\tC[0x%02x] = 0x%02x\\n\", addr,  data);\n\tinit->offset += 3;\n\n\tinit_wrvgai(init, 0x03d4, addr, data);\n}\n\n \nstatic void\ninit_zm_cr_group(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 count = nvbios_rd08(bios, init->offset + 1);\n\n\ttrace(\"ZM_CR_GROUP\\n\");\n\tinit->offset += 2;\n\n\twhile (count--) {\n\t\tu8 addr = nvbios_rd08(bios, init->offset + 0);\n\t\tu8 data = nvbios_rd08(bios, init->offset + 1);\n\n\t\ttrace(\"\\t\\tC[0x%02x] = 0x%02x\\n\", addr, data);\n\t\tinit->offset += 2;\n\n\t\tinit_wrvgai(init, 0x03d4, addr, data);\n\t}\n}\n\n \nstatic void\ninit_condition_time(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8  cond = nvbios_rd08(bios, init->offset + 1);\n\tu8 retry = nvbios_rd08(bios, init->offset + 2);\n\tu8  wait = min((u16)retry * 50, 100);\n\n\ttrace(\"CONDITION_TIME\\t0x%02x 0x%02x\\n\", cond, retry);\n\tinit->offset += 3;\n\n\tif (!init_exec(init))\n\t\treturn;\n\n\twhile (wait--) {\n\t\tif (init_condition_met(init, cond))\n\t\t\treturn;\n\t\tmdelay(20);\n\t}\n\n\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_ltime(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 msec = nvbios_rd16(bios, init->offset + 1);\n\n\ttrace(\"LTIME\\t0x%04x\\n\", msec);\n\tinit->offset += 3;\n\n\tif (init_exec(init))\n\t\tmdelay(msec);\n}\n\n \nstatic void\ninit_zm_reg_sequence(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 base = nvbios_rd32(bios, init->offset + 1);\n\tu8 count = nvbios_rd08(bios, init->offset + 5);\n\n\ttrace(\"ZM_REG_SEQUENCE\\t0x%02x\\n\", count);\n\tinit->offset += 6;\n\n\twhile (count--) {\n\t\tu32 data = nvbios_rd32(bios, init->offset);\n\n\t\ttrace(\"\\t\\tR[0x%06x] = 0x%08x\\n\", base, data);\n\t\tinit->offset += 4;\n\n\t\tinit_wr32(init, base, data);\n\t\tbase += 4;\n\t}\n}\n\n \nstatic void\ninit_pll_indirect(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu16 addr = nvbios_rd16(bios, init->offset + 5);\n\tu32 freq = (u32)nvbios_rd16(bios, addr) * 1000;\n\n\ttrace(\"PLL_INDIRECT\\tR[0x%06x] =PLL= VBIOS[%04x] = %dkHz\\n\",\n\t      reg, addr, freq);\n\tinit->offset += 7;\n\n\tinit_prog_pll(init, reg, freq);\n}\n\n \nstatic void\ninit_zm_reg_indirect(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu16 addr = nvbios_rd16(bios, init->offset + 5);\n\tu32 data = nvbios_rd32(bios, addr);\n\n\ttrace(\"ZM_REG_INDIRECT\\tR[0x%06x] = VBIOS[0x%04x] = 0x%08x\\n\",\n\t      reg, addr, data);\n\tinit->offset += 7;\n\n\tinit_wr32(init, addr, data);\n}\n\n \nstatic void\ninit_sub_direct(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 addr = nvbios_rd16(bios, init->offset + 1);\n\tu16 save;\n\n\ttrace(\"SUB_DIRECT\\t0x%04x\\n\", addr);\n\n\tif (init_exec(init)) {\n\t\tsave = init->offset;\n\t\tinit->offset = addr;\n\t\tif (nvbios_exec(init)) {\n\t\t\terror(\"error parsing sub-table\\n\");\n\t\t\treturn;\n\t\t}\n\t\tinit->offset = save;\n\t}\n\n\tinit->offset += 3;\n}\n\n \nstatic void\ninit_jump(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 offset = nvbios_rd16(bios, init->offset + 1);\n\n\ttrace(\"JUMP\\t0x%04x\\n\", offset);\n\n\tif (init_exec(init))\n\t\tinit->offset = offset;\n\telse\n\t\tinit->offset += 3;\n}\n\n \nstatic void\ninit_i2c_if(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8  addr = nvbios_rd08(bios, init->offset + 2);\n\tu8   reg = nvbios_rd08(bios, init->offset + 3);\n\tu8  mask = nvbios_rd08(bios, init->offset + 4);\n\tu8  data = nvbios_rd08(bios, init->offset + 5);\n\tu8 value;\n\n\ttrace(\"I2C_IF\\tI2C[0x%02x][0x%02x][0x%02x] & 0x%02x == 0x%02x\\n\",\n\t      index, addr, reg, mask, data);\n\tinit->offset += 6;\n\tinit_exec_force(init, true);\n\n\tvalue = init_rdi2cr(init, index, addr, reg);\n\tif ((value & mask) != data)\n\t\tinit_exec_set(init, false);\n\n\tinit_exec_force(init, false);\n}\n\n \nstatic void\ninit_copy_nv_reg(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  sreg = nvbios_rd32(bios, init->offset + 1);\n\tu8  shift = nvbios_rd08(bios, init->offset + 5);\n\tu32 smask = nvbios_rd32(bios, init->offset + 6);\n\tu32  sxor = nvbios_rd32(bios, init->offset + 10);\n\tu32  dreg = nvbios_rd32(bios, init->offset + 14);\n\tu32 dmask = nvbios_rd32(bios, init->offset + 18);\n\tu32 data;\n\n\ttrace(\"COPY_NV_REG\\tR[0x%06x] &= 0x%08x |= \"\n\t      \"((R[0x%06x] %s 0x%02x) & 0x%08x ^ 0x%08x)\\n\",\n\t      dreg, dmask, sreg, (shift & 0x80) ? \"<<\" : \">>\",\n\t      (shift & 0x80) ? (0x100 - shift) : shift, smask, sxor);\n\tinit->offset += 22;\n\n\tdata = init_shift(init_rd32(init, sreg), shift);\n\tinit_mask(init, dreg, ~dmask, (data & smask) ^ sxor);\n}\n\n \nstatic void\ninit_zm_index_io(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 port = nvbios_rd16(bios, init->offset + 1);\n\tu8 index = nvbios_rd08(bios, init->offset + 3);\n\tu8  data = nvbios_rd08(bios, init->offset + 4);\n\n\ttrace(\"ZM_INDEX_IO\\tI[0x%04x][0x%02x] = 0x%02x\\n\", port, index, data);\n\tinit->offset += 5;\n\n\tinit_wrvgai(init, port, index, data);\n}\n\n \nstatic void\ninit_compute_mem(struct nvbios_init *init)\n{\n\tstruct nvkm_devinit *devinit = init->subdev->device->devinit;\n\n\ttrace(\"COMPUTE_MEM\\n\");\n\tinit->offset += 1;\n\n\tinit_exec_force(init, true);\n\tif (init_exec(init))\n\t\tnvkm_devinit_meminit(devinit);\n\tinit_exec_force(init, false);\n}\n\n \nstatic void\ninit_reset(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32   reg = nvbios_rd32(bios, init->offset + 1);\n\tu32 data1 = nvbios_rd32(bios, init->offset + 5);\n\tu32 data2 = nvbios_rd32(bios, init->offset + 9);\n\tu32 savepci19;\n\n\ttrace(\"RESET\\tR[0x%08x] = 0x%08x, 0x%08x\", reg, data1, data2);\n\tinit->offset += 13;\n\tinit_exec_force(init, true);\n\n\tsavepci19 = init_mask(init, 0x00184c, 0x00000f00, 0x00000000);\n\tinit_wr32(init, reg, data1);\n\tudelay(10);\n\tinit_wr32(init, reg, data2);\n\tinit_wr32(init, 0x00184c, savepci19);\n\tinit_mask(init, 0x001850, 0x00000001, 0x00000000);\n\n\tinit_exec_force(init, false);\n}\n\n \nstatic u16\ninit_configure_mem_clk(struct nvbios_init *init)\n{\n\tu16 mdata = bmp_mem_init_table(init->subdev->device->bios);\n\tif (mdata)\n\t\tmdata += (init_rdvgai(init, 0x03d4, 0x3c) >> 4) * 66;\n\treturn mdata;\n}\n\nstatic void\ninit_configure_mem(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 mdata, sdata;\n\tu32 addr, data;\n\n\ttrace(\"CONFIGURE_MEM\\n\");\n\tinit->offset += 1;\n\n\tif (bios->version.major > 2) {\n\t\tinit_done(init);\n\t\treturn;\n\t}\n\tinit_exec_force(init, true);\n\n\tmdata = init_configure_mem_clk(init);\n\tsdata = bmp_sdr_seq_table(bios);\n\tif (nvbios_rd08(bios, mdata) & 0x01)\n\t\tsdata = bmp_ddr_seq_table(bios);\n\tmdata += 6;  \n\n\tdata = init_rdvgai(init, 0x03c4, 0x01);\n\tinit_wrvgai(init, 0x03c4, 0x01, data | 0x20);\n\n\tfor (; (addr = nvbios_rd32(bios, sdata)) != 0xffffffff; sdata += 4) {\n\t\tswitch (addr) {\n\t\tcase 0x10021c:  \n\t\tcase 0x1002d0:  \n\t\tcase 0x1002d4:  \n\t\t\tdata = 0x00000001;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata = nvbios_rd32(bios, mdata);\n\t\t\tmdata += 4;\n\t\t\tif (data == 0xffffffff)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tinit_wr32(init, addr, data);\n\t}\n\n\tinit_exec_force(init, false);\n}\n\n \nstatic void\ninit_configure_clk(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 mdata, clock;\n\n\ttrace(\"CONFIGURE_CLK\\n\");\n\tinit->offset += 1;\n\n\tif (bios->version.major > 2) {\n\t\tinit_done(init);\n\t\treturn;\n\t}\n\tinit_exec_force(init, true);\n\n\tmdata = init_configure_mem_clk(init);\n\n\t \n\tclock = nvbios_rd16(bios, mdata + 4) * 10;\n\tinit_prog_pll(init, 0x680500, clock);\n\n\t \n\tclock = nvbios_rd16(bios, mdata + 2) * 10;\n\tif (nvbios_rd08(bios, mdata) & 0x01)\n\t\tclock *= 2;\n\tinit_prog_pll(init, 0x680504, clock);\n\n\tinit_exec_force(init, false);\n}\n\n \nstatic void\ninit_configure_preinit(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 strap;\n\n\ttrace(\"CONFIGURE_PREINIT\\n\");\n\tinit->offset += 1;\n\n\tif (bios->version.major > 2) {\n\t\tinit_done(init);\n\t\treturn;\n\t}\n\tinit_exec_force(init, true);\n\n\tstrap = init_rd32(init, 0x101000);\n\tstrap = ((strap << 2) & 0xf0) | ((strap & 0x40) >> 6);\n\tinit_wrvgai(init, 0x03d4, 0x3c, strap);\n\n\tinit_exec_force(init, false);\n}\n\n \nstatic void\ninit_io(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 port = nvbios_rd16(bios, init->offset + 1);\n\tu8  mask = nvbios_rd16(bios, init->offset + 3);\n\tu8  data = nvbios_rd16(bios, init->offset + 4);\n\tu8 value;\n\n\ttrace(\"IO\\t\\tI[0x%04x] &= 0x%02x |= 0x%02x\\n\", port, mask, data);\n\tinit->offset += 5;\n\n\t \n\tif (bios->subdev.device->card_type >= NV_50 &&\n\t    port == 0x03c3 && data == 0x01) {\n\t\tinit_mask(init, 0x614100, 0xf0800000, 0x00800000);\n\t\tinit_mask(init, 0x00e18c, 0x00020000, 0x00020000);\n\t\tinit_mask(init, 0x614900, 0xf0800000, 0x00800000);\n\t\tinit_mask(init, 0x000200, 0x40000000, 0x00000000);\n\t\tmdelay(10);\n\t\tinit_mask(init, 0x00e18c, 0x00020000, 0x00000000);\n\t\tinit_mask(init, 0x000200, 0x40000000, 0x40000000);\n\t\tinit_wr32(init, 0x614100, 0x00800018);\n\t\tinit_wr32(init, 0x614900, 0x00800018);\n\t\tmdelay(10);\n\t\tinit_wr32(init, 0x614100, 0x10000018);\n\t\tinit_wr32(init, 0x614900, 0x10000018);\n\t}\n\n\tvalue = init_rdport(init, port) & mask;\n\tinit_wrport(init, port, data | value);\n}\n\n \nstatic void\ninit_sub(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu16 addr, save;\n\n\ttrace(\"SUB\\t0x%02x\\n\", index);\n\n\taddr = init_script(bios, index);\n\tif (addr && init_exec(init)) {\n\t\tsave = init->offset;\n\t\tinit->offset = addr;\n\t\tif (nvbios_exec(init)) {\n\t\t\terror(\"error parsing sub-table\\n\");\n\t\t\treturn;\n\t\t}\n\t\tinit->offset = save;\n\t}\n\n\tinit->offset += 2;\n}\n\n \nstatic void\ninit_ram_condition(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8  mask = nvbios_rd08(bios, init->offset + 1);\n\tu8 value = nvbios_rd08(bios, init->offset + 2);\n\n\ttrace(\"RAM_CONDITION\\t\"\n\t      \"(R[0x100000] & 0x%02x) == 0x%02x\\n\", mask, value);\n\tinit->offset += 3;\n\n\tif ((init_rd32(init, 0x100000) & mask) != value)\n\t\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_nv_reg(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu32 mask = nvbios_rd32(bios, init->offset + 5);\n\tu32 data = nvbios_rd32(bios, init->offset + 9);\n\n\ttrace(\"NV_REG\\tR[0x%06x] &= 0x%08x |= 0x%08x\\n\", reg, mask, data);\n\tinit->offset += 13;\n\n\tinit_mask(init, reg, ~mask, data);\n}\n\n \nstatic void\ninit_macro(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8  macro = nvbios_rd08(bios, init->offset + 1);\n\tu16 table;\n\n\ttrace(\"MACRO\\t0x%02x\\n\", macro);\n\n\ttable = init_macro_table(init);\n\tif (table) {\n\t\tu32 addr = nvbios_rd32(bios, table + (macro * 8) + 0);\n\t\tu32 data = nvbios_rd32(bios, table + (macro * 8) + 4);\n\t\ttrace(\"\\t\\tR[0x%06x] = 0x%08x\\n\", addr, data);\n\t\tinit_wr32(init, addr, data);\n\t}\n\n\tinit->offset += 2;\n}\n\n \nstatic void\ninit_resume(struct nvbios_init *init)\n{\n\ttrace(\"RESUME\\n\");\n\tinit->offset += 1;\n\tinit_exec_set(init, true);\n}\n\n \nstatic void\ninit_strap_condition(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 mask = nvbios_rd32(bios, init->offset + 1);\n\tu32 value = nvbios_rd32(bios, init->offset + 5);\n\n\ttrace(\"STRAP_CONDITION\\t(R[0x101000] & 0x%08x) == 0x%08x\\n\", mask, value);\n\tinit->offset += 9;\n\n\tif ((init_rd32(init, 0x101000) & mask) != value)\n\t\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_time(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 usec = nvbios_rd16(bios, init->offset + 1);\n\n\ttrace(\"TIME\\t0x%04x\\n\", usec);\n\tinit->offset += 3;\n\n\tif (init_exec(init)) {\n\t\tif (usec < 1000)\n\t\t\tudelay(usec);\n\t\telse\n\t\t\tmdelay((usec + 900) / 1000);\n\t}\n}\n\n \nstatic void\ninit_condition(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 cond = nvbios_rd08(bios, init->offset + 1);\n\n\ttrace(\"CONDITION\\t0x%02x\\n\", cond);\n\tinit->offset += 2;\n\n\tif (!init_condition_met(init, cond))\n\t\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_io_condition(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 cond = nvbios_rd08(bios, init->offset + 1);\n\n\ttrace(\"IO_CONDITION\\t0x%02x\\n\", cond);\n\tinit->offset += 2;\n\n\tif (!init_io_condition_met(init, cond))\n\t\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_zm_reg16(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu16 data = nvbios_rd16(bios, init->offset + 5);\n\n\ttrace(\"ZM_REG\\tR[0x%06x] = 0x%04x\\n\", addr, data);\n\tinit->offset += 7;\n\n\tinit_wr32(init, addr, data);\n}\n\n \nstatic void\ninit_index_io(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu16 port = nvbios_rd16(bios, init->offset + 1);\n\tu8 index = nvbios_rd16(bios, init->offset + 3);\n\tu8  mask = nvbios_rd08(bios, init->offset + 4);\n\tu8  data = nvbios_rd08(bios, init->offset + 5);\n\tu8 value;\n\n\ttrace(\"INDEX_IO\\tI[0x%04x][0x%02x] &= 0x%02x |= 0x%02x\\n\",\n\t      port, index, mask, data);\n\tinit->offset += 6;\n\n\tvalue = init_rdvgai(init, port, index) & mask;\n\tinit_wrvgai(init, port, index, data | value);\n}\n\n \nstatic void\ninit_pll(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32  reg = nvbios_rd32(bios, init->offset + 1);\n\tu32 freq = nvbios_rd16(bios, init->offset + 5) * 10;\n\n\ttrace(\"PLL\\tR[0x%06x] =PLL= %dkHz\\n\", reg, freq);\n\tinit->offset += 7;\n\n\tinit_prog_pll(init, reg, freq);\n}\n\n \nstatic void\ninit_zm_reg(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu32 data = nvbios_rd32(bios, init->offset + 5);\n\n\ttrace(\"ZM_REG\\tR[0x%06x] = 0x%08x\\n\", addr, data);\n\tinit->offset += 9;\n\n\tif (addr == 0x000200)\n\t\tdata |= 0x00000001;\n\n\tinit_wr32(init, addr, data);\n}\n\n \nstatic void\ninit_ram_restrict_pll(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8  type = nvbios_rd08(bios, init->offset + 1);\n\tu8 count = init_ram_restrict_group_count(init);\n\tu8 strap = init_ram_restrict(init);\n\tu8 cconf;\n\n\ttrace(\"RAM_RESTRICT_PLL\\t0x%02x\\n\", type);\n\tinit->offset += 2;\n\n\tfor (cconf = 0; cconf < count; cconf++) {\n\t\tu32 freq = nvbios_rd32(bios, init->offset);\n\n\t\tif (cconf == strap) {\n\t\t\ttrace(\"%dkHz *\\n\", freq);\n\t\t\tinit_prog_pll(init, type, freq);\n\t\t} else {\n\t\t\ttrace(\"%dkHz\\n\", freq);\n\t\t}\n\n\t\tinit->offset += 4;\n\t}\n}\n\n \nstatic void\ninit_reset_begun(struct nvbios_init *init)\n{\n\ttrace(\"RESET_BEGUN\\n\");\n\tinit->offset += 1;\n}\n\n \nstatic void\ninit_reset_end(struct nvbios_init *init)\n{\n\ttrace(\"RESET_END\\n\");\n\tinit->offset += 1;\n}\n\n \nstatic void\ninit_gpio(struct nvbios_init *init)\n{\n\tstruct nvkm_gpio *gpio = init->subdev->device->gpio;\n\n\ttrace(\"GPIO\\n\");\n\tinit->offset += 1;\n\n\tif (init_exec(init))\n\t\tnvkm_gpio_reset(gpio, DCB_GPIO_UNUSED);\n}\n\n \nstatic void\ninit_ram_restrict_zm_reg_group(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu8  incr = nvbios_rd08(bios, init->offset + 5);\n\tu8   num = nvbios_rd08(bios, init->offset + 6);\n\tu8 count = init_ram_restrict_group_count(init);\n\tu8 index = init_ram_restrict(init);\n\tu8 i, j;\n\n\ttrace(\"RAM_RESTRICT_ZM_REG_GROUP\\t\"\n\t      \"R[0x%08x] 0x%02x 0x%02x\\n\", addr, incr, num);\n\tinit->offset += 7;\n\n\tfor (i = 0; i < num; i++) {\n\t\ttrace(\"\\tR[0x%06x] = {\\n\", addr);\n\t\tfor (j = 0; j < count; j++) {\n\t\t\tu32 data = nvbios_rd32(bios, init->offset);\n\n\t\t\tif (j == index) {\n\t\t\t\ttrace(\"\\t\\t0x%08x *\\n\", data);\n\t\t\t\tinit_wr32(init, addr, data);\n\t\t\t} else {\n\t\t\t\ttrace(\"\\t\\t0x%08x\\n\", data);\n\t\t\t}\n\n\t\t\tinit->offset += 4;\n\t\t}\n\t\ttrace(\"\\t}\\n\");\n\t\taddr += incr;\n\t}\n}\n\n \nstatic void\ninit_copy_zm_reg(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 sreg = nvbios_rd32(bios, init->offset + 1);\n\tu32 dreg = nvbios_rd32(bios, init->offset + 5);\n\n\ttrace(\"COPY_ZM_REG\\tR[0x%06x] = R[0x%06x]\\n\", dreg, sreg);\n\tinit->offset += 9;\n\n\tinit_wr32(init, dreg, init_rd32(init, sreg));\n}\n\n \nstatic void\ninit_zm_reg_group(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu8 count = nvbios_rd08(bios, init->offset + 5);\n\n\ttrace(\"ZM_REG_GROUP\\tR[0x%06x] =\\n\", addr);\n\tinit->offset += 6;\n\n\twhile (count--) {\n\t\tu32 data = nvbios_rd32(bios, init->offset);\n\t\ttrace(\"\\t0x%08x\\n\", data);\n\t\tinit_wr32(init, addr, data);\n\t\tinit->offset += 4;\n\t}\n}\n\n \nstatic void\ninit_xlat(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 saddr = nvbios_rd32(bios, init->offset + 1);\n\tu8 sshift = nvbios_rd08(bios, init->offset + 5);\n\tu8  smask = nvbios_rd08(bios, init->offset + 6);\n\tu8  index = nvbios_rd08(bios, init->offset + 7);\n\tu32 daddr = nvbios_rd32(bios, init->offset + 8);\n\tu32 dmask = nvbios_rd32(bios, init->offset + 12);\n\tu8  shift = nvbios_rd08(bios, init->offset + 16);\n\tu32 data;\n\n\ttrace(\"INIT_XLAT\\tR[0x%06x] &= 0x%08x |= \"\n\t      \"(X%02x((R[0x%06x] %s 0x%02x) & 0x%02x) << 0x%02x)\\n\",\n\t      daddr, dmask, index, saddr, (sshift & 0x80) ? \"<<\" : \">>\",\n\t      (sshift & 0x80) ? (0x100 - sshift) : sshift, smask, shift);\n\tinit->offset += 17;\n\n\tdata = init_shift(init_rd32(init, saddr), sshift) & smask;\n\tdata = init_xlat_(init, index, data) << shift;\n\tinit_mask(init, daddr, ~dmask, data);\n}\n\n \nstatic void\ninit_zm_mask_add(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu32 mask = nvbios_rd32(bios, init->offset + 5);\n\tu32  add = nvbios_rd32(bios, init->offset + 9);\n\tu32 data;\n\n\ttrace(\"ZM_MASK_ADD\\tR[0x%06x] &= 0x%08x += 0x%08x\\n\", addr, mask, add);\n\tinit->offset += 13;\n\n\tdata =  init_rd32(init, addr);\n\tdata = (data & mask) | ((data + add) & ~mask);\n\tinit_wr32(init, addr, data);\n}\n\n \nstatic void\ninit_auxch(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu8 count = nvbios_rd08(bios, init->offset + 5);\n\n\ttrace(\"AUXCH\\tAUX[0x%08x] 0x%02x\\n\", addr, count);\n\tinit->offset += 6;\n\n\twhile (count--) {\n\t\tu8 mask = nvbios_rd08(bios, init->offset + 0);\n\t\tu8 data = nvbios_rd08(bios, init->offset + 1);\n\t\ttrace(\"\\tAUX[0x%08x] &= 0x%02x |= 0x%02x\\n\", addr, mask, data);\n\t\tmask = init_rdauxr(init, addr) & mask;\n\t\tinit_wrauxr(init, addr, mask | data);\n\t\tinit->offset += 2;\n\t}\n}\n\n \nstatic void\ninit_zm_auxch(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu32 addr = nvbios_rd32(bios, init->offset + 1);\n\tu8 count = nvbios_rd08(bios, init->offset + 5);\n\n\ttrace(\"ZM_AUXCH\\tAUX[0x%08x] 0x%02x\\n\", addr, count);\n\tinit->offset += 6;\n\n\twhile (count--) {\n\t\tu8 data = nvbios_rd08(bios, init->offset + 0);\n\t\ttrace(\"\\tAUX[0x%08x] = 0x%02x\\n\", addr, data);\n\t\tinit_wrauxr(init, addr, data);\n\t\tinit->offset += 1;\n\t}\n}\n\n \nstatic void\ninit_i2c_long_if(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tu8 index = nvbios_rd08(bios, init->offset + 1);\n\tu8  addr = nvbios_rd08(bios, init->offset + 2) >> 1;\n\tu8 reglo = nvbios_rd08(bios, init->offset + 3);\n\tu8 reghi = nvbios_rd08(bios, init->offset + 4);\n\tu8  mask = nvbios_rd08(bios, init->offset + 5);\n\tu8  data = nvbios_rd08(bios, init->offset + 6);\n\tstruct i2c_adapter *adap;\n\n\ttrace(\"I2C_LONG_IF\\t\"\n\t      \"I2C[0x%02x][0x%02x][0x%02x%02x] & 0x%02x == 0x%02x\\n\",\n\t      index, addr, reglo, reghi, mask, data);\n\tinit->offset += 7;\n\n\tadap = init_i2c(init, index);\n\tif (adap) {\n\t\tu8 i[2] = { reghi, reglo };\n\t\tu8 o[1] = {};\n\t\tstruct i2c_msg msg[] = {\n\t\t\t{ .addr = addr, .flags = 0, .len = 2, .buf = i },\n\t\t\t{ .addr = addr, .flags = I2C_M_RD, .len = 1, .buf = o }\n\t\t};\n\t\tint ret;\n\n\t\tret = i2c_transfer(adap, msg, 2);\n\t\tif (ret == 2 && ((o[0] & mask) == data))\n\t\t\treturn;\n\t}\n\n\tinit_exec_set(init, false);\n}\n\n \nstatic void\ninit_gpio_ne(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\tstruct nvkm_gpio *gpio = bios->subdev.device->gpio;\n\tstruct dcb_gpio_func func;\n\tu8 count = nvbios_rd08(bios, init->offset + 1);\n\tu8 idx = 0, ver, len;\n\tu16 data, i;\n\n\ttrace(\"GPIO_NE\\t\");\n\tinit->offset += 2;\n\n\tfor (i = init->offset; i < init->offset + count; i++)\n\t\tcont(\"0x%02x \", nvbios_rd08(bios, i));\n\tcont(\"\\n\");\n\n\twhile ((data = dcb_gpio_parse(bios, 0, idx++, &ver, &len, &func))) {\n\t\tif (func.func != DCB_GPIO_UNUSED) {\n\t\t\tfor (i = init->offset; i < init->offset + count; i++) {\n\t\t\t\tif (func.func == nvbios_rd08(bios, i))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace(\"\\tFUNC[0x%02x]\", func.func);\n\t\t\tif (i == (init->offset + count)) {\n\t\t\t\tcont(\" *\");\n\t\t\t\tif (init_exec(init))\n\t\t\t\t\tnvkm_gpio_reset(gpio, func.func);\n\t\t\t}\n\t\t\tcont(\"\\n\");\n\t\t}\n\t}\n\n\tinit->offset += count;\n}\n\nstatic struct nvbios_init_opcode {\n\tvoid (*exec)(struct nvbios_init *);\n} init_opcode[] = {\n\t[0x32] = { init_io_restrict_prog },\n\t[0x33] = { init_repeat },\n\t[0x34] = { init_io_restrict_pll },\n\t[0x36] = { init_end_repeat },\n\t[0x37] = { init_copy },\n\t[0x38] = { init_not },\n\t[0x39] = { init_io_flag_condition },\n\t[0x3a] = { init_generic_condition },\n\t[0x3b] = { init_io_mask_or },\n\t[0x3c] = { init_io_or },\n\t[0x47] = { init_andn_reg },\n\t[0x48] = { init_or_reg },\n\t[0x49] = { init_idx_addr_latched },\n\t[0x4a] = { init_io_restrict_pll2 },\n\t[0x4b] = { init_pll2 },\n\t[0x4c] = { init_i2c_byte },\n\t[0x4d] = { init_zm_i2c_byte },\n\t[0x4e] = { init_zm_i2c },\n\t[0x4f] = { init_tmds },\n\t[0x50] = { init_zm_tmds_group },\n\t[0x51] = { init_cr_idx_adr_latch },\n\t[0x52] = { init_cr },\n\t[0x53] = { init_zm_cr },\n\t[0x54] = { init_zm_cr_group },\n\t[0x56] = { init_condition_time },\n\t[0x57] = { init_ltime },\n\t[0x58] = { init_zm_reg_sequence },\n\t[0x59] = { init_pll_indirect },\n\t[0x5a] = { init_zm_reg_indirect },\n\t[0x5b] = { init_sub_direct },\n\t[0x5c] = { init_jump },\n\t[0x5e] = { init_i2c_if },\n\t[0x5f] = { init_copy_nv_reg },\n\t[0x62] = { init_zm_index_io },\n\t[0x63] = { init_compute_mem },\n\t[0x65] = { init_reset },\n\t[0x66] = { init_configure_mem },\n\t[0x67] = { init_configure_clk },\n\t[0x68] = { init_configure_preinit },\n\t[0x69] = { init_io },\n\t[0x6b] = { init_sub },\n\t[0x6d] = { init_ram_condition },\n\t[0x6e] = { init_nv_reg },\n\t[0x6f] = { init_macro },\n\t[0x71] = { init_done },\n\t[0x72] = { init_resume },\n\t[0x73] = { init_strap_condition },\n\t[0x74] = { init_time },\n\t[0x75] = { init_condition },\n\t[0x76] = { init_io_condition },\n\t[0x77] = { init_zm_reg16 },\n\t[0x78] = { init_index_io },\n\t[0x79] = { init_pll },\n\t[0x7a] = { init_zm_reg },\n\t[0x87] = { init_ram_restrict_pll },\n\t[0x8c] = { init_reset_begun },\n\t[0x8d] = { init_reset_end },\n\t[0x8e] = { init_gpio },\n\t[0x8f] = { init_ram_restrict_zm_reg_group },\n\t[0x90] = { init_copy_zm_reg },\n\t[0x91] = { init_zm_reg_group },\n\t[0x92] = { init_reserved },\n\t[0x96] = { init_xlat },\n\t[0x97] = { init_zm_mask_add },\n\t[0x98] = { init_auxch },\n\t[0x99] = { init_zm_auxch },\n\t[0x9a] = { init_i2c_long_if },\n\t[0xa9] = { init_gpio_ne },\n\t[0xaa] = { init_reserved },\n};\n\nint\nnvbios_exec(struct nvbios_init *init)\n{\n\tstruct nvkm_bios *bios = init->subdev->device->bios;\n\n\tinit->nested++;\n\twhile (init->offset) {\n\t\tu8 opcode = nvbios_rd08(bios, init->offset);\n\t\tif (opcode >= ARRAY_SIZE(init_opcode) ||\n\t\t    !init_opcode[opcode].exec) {\n\t\t\terror(\"unknown opcode 0x%02x\\n\", opcode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tinit_opcode[opcode].exec(init);\n\t}\n\tinit->nested--;\n\treturn 0;\n}\n\nint\nnvbios_post(struct nvkm_subdev *subdev, bool execute)\n{\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tint ret = 0;\n\tint i = -1;\n\tu16 data;\n\n\tif (execute)\n\t\tnvkm_debug(subdev, \"running init tables\\n\");\n\twhile (!ret && (data = (init_script(bios, ++i)))) {\n\t\tret = nvbios_init(subdev, data,\n\t\t\tinit.execute = execute ? 1 : 0;\n\t\t      );\n\t}\n\n\t \n\tif (!ret && (data = init_unknown_script(bios))) {\n\t\tret = nvbios_init(subdev, data,\n\t\t\tinit.execute = execute ? 1 : 0;\n\t\t      );\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}