{
  "module_name": "mcp77.c",
  "hash_id": "51b70344a00e25b47ddd428d91a9d4d31317ddd758ef45b4ae80ba49738e2c49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/mcp77.c",
  "human_readable_source": " \n#define mcp77_clk(p) container_of((p), struct mcp77_clk, base)\n#include \"gt215.h\"\n#include \"pll.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n#include <subdev/timer.h>\n\nstruct mcp77_clk {\n\tstruct nvkm_clk base;\n\tenum nv_clk_src csrc, ssrc, vsrc;\n\tu32 cctrl, sctrl;\n\tu32 ccoef, scoef;\n\tu32 cpost, spost;\n\tu32 vdiv;\n};\n\nstatic u32\nread_div(struct mcp77_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\treturn nvkm_rd32(device, 0x004600);\n}\n\nstatic u32\nread_pll(struct mcp77_clk *clk, u32 base)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ctrl = nvkm_rd32(device, base + 0);\n\tu32 coef = nvkm_rd32(device, base + 4);\n\tu32 ref = nvkm_clk_read(&clk->base, nv_clk_src_href);\n\tu32 post_div = 0;\n\tu32 clock = 0;\n\tint N1, M1;\n\n\tswitch (base){\n\tcase 0x4020:\n\t\tpost_div = 1 << ((nvkm_rd32(device, 0x4070) & 0x000f0000) >> 16);\n\t\tbreak;\n\tcase 0x4028:\n\t\tpost_div = (nvkm_rd32(device, 0x4040) & 0x000f0000) >> 16;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tN1 = (coef & 0x0000ff00) >> 8;\n\tM1 = (coef & 0x000000ff);\n\tif ((ctrl & 0x80000000) && M1) {\n\t\tclock = ref * N1 / M1;\n\t\tclock = clock / post_div;\n\t}\n\n\treturn clock;\n}\n\nstatic int\nmcp77_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\n{\n\tstruct mcp77_clk *clk = mcp77_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mast = nvkm_rd32(device, 0x00c054);\n\tu32 P = 0;\n\n\tswitch (src) {\n\tcase nv_clk_src_crystal:\n\t\treturn device->crystal;\n\tcase nv_clk_src_href:\n\t\treturn 100000;  \n\tcase nv_clk_src_hclkm4:\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_href) * 4;\n\tcase nv_clk_src_hclkm2d3:\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_href) * 2 / 3;\n\tcase nv_clk_src_host:\n\t\tswitch (mast & 0x000c0000) {\n\t\tcase 0x00000000: return nvkm_clk_read(&clk->base, nv_clk_src_hclkm2d3);\n\t\tcase 0x00040000: break;\n\t\tcase 0x00080000: return nvkm_clk_read(&clk->base, nv_clk_src_hclkm4);\n\t\tcase 0x000c0000: return nvkm_clk_read(&clk->base, nv_clk_src_cclk);\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_core:\n\t\tP = (nvkm_rd32(device, 0x004028) & 0x00070000) >> 16;\n\n\t\tswitch (mast & 0x00000003) {\n\t\tcase 0x00000000: return nvkm_clk_read(&clk->base, nv_clk_src_crystal) >> P;\n\t\tcase 0x00000001: return 0;\n\t\tcase 0x00000002: return nvkm_clk_read(&clk->base, nv_clk_src_hclkm4) >> P;\n\t\tcase 0x00000003: return read_pll(clk, 0x004028) >> P;\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_cclk:\n\t\tif ((mast & 0x03000000) != 0x03000000)\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_core);\n\n\t\tif ((mast & 0x00000200) == 0x00000000)\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_core);\n\n\t\tswitch (mast & 0x00000c00) {\n\t\tcase 0x00000000: return nvkm_clk_read(&clk->base, nv_clk_src_href);\n\t\tcase 0x00000400: return nvkm_clk_read(&clk->base, nv_clk_src_hclkm4);\n\t\tcase 0x00000800: return nvkm_clk_read(&clk->base, nv_clk_src_hclkm2d3);\n\t\tdefault: return 0;\n\t\t}\n\tcase nv_clk_src_shader:\n\t\tP = (nvkm_rd32(device, 0x004020) & 0x00070000) >> 16;\n\t\tswitch (mast & 0x00000030) {\n\t\tcase 0x00000000:\n\t\t\tif (mast & 0x00000040)\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_href) >> P;\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_crystal) >> P;\n\t\tcase 0x00000010: break;\n\t\tcase 0x00000020: return read_pll(clk, 0x004028) >> P;\n\t\tcase 0x00000030: return read_pll(clk, 0x004020) >> P;\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_mem:\n\t\treturn 0;\n\tcase nv_clk_src_vdec:\n\t\tP = (read_div(clk) & 0x00000700) >> 8;\n\n\t\tswitch (mast & 0x00400000) {\n\t\tcase 0x00400000:\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_core) >> P;\n\t\tdefault:\n\t\t\treturn 500000 >> P;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnvkm_debug(subdev, \"unknown clock source %d %08x\\n\", src, mast);\n\treturn 0;\n}\n\nstatic u32\ncalc_pll(struct mcp77_clk *clk, u32 reg,\n\t u32 clock, int *N, int *M, int *P)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvbios_pll pll;\n\tint ret;\n\n\tret = nvbios_pll_parse(subdev->device->bios, reg, &pll);\n\tif (ret)\n\t\treturn 0;\n\n\tpll.vco2.max_freq = 0;\n\tpll.refclk = nvkm_clk_read(&clk->base, nv_clk_src_href);\n\tif (!pll.refclk)\n\t\treturn 0;\n\n\treturn nv04_pll_calc(subdev, &pll, clock, N, M, NULL, NULL, P);\n}\n\nstatic inline u32\ncalc_P(u32 src, u32 target, int *div)\n{\n\tu32 clk0 = src, clk1 = src;\n\tfor (*div = 0; *div <= 7; (*div)++) {\n\t\tif (clk0 <= target) {\n\t\t\tclk1 = clk0 << (*div ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\t\tclk0 >>= 1;\n\t}\n\n\tif (target - clk0 <= clk1 - target)\n\t\treturn clk0;\n\t(*div)--;\n\treturn clk1;\n}\n\nstatic int\nmcp77_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct mcp77_clk *clk = mcp77_clk(base);\n\tconst int shader = cstate->domain[nv_clk_src_shader];\n\tconst int core = cstate->domain[nv_clk_src_core];\n\tconst int vdec = cstate->domain[nv_clk_src_vdec];\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tu32 out = 0, clock = 0;\n\tint N, M, P1, P2 = 0;\n\tint divs = 0;\n\n\t \n\tif (core < nvkm_clk_read(&clk->base, nv_clk_src_hclkm4))\n\t\tout = calc_P(nvkm_clk_read(&clk->base, nv_clk_src_hclkm4), core, &divs);\n\n\t \n\tclock = calc_pll(clk, 0x4028, (core << 1), &N, &M, &P1);\n\n\tif (abs(core - out) <= abs(core - (clock >> 1))) {\n\t\tclk->csrc = nv_clk_src_hclkm4;\n\t\tclk->cctrl = divs << 16;\n\t} else {\n\t\t \n\t\tif(P1 > 2) {\n\t\t\tP2 = P1 - 2;\n\t\t\tP1 = 2;\n\t\t}\n\n\t\tclk->csrc = nv_clk_src_core;\n\t\tclk->ccoef = (N << 8) | M;\n\n\t\tclk->cctrl = (P2 + 1) << 16;\n\t\tclk->cpost = (1 << P1) << 16;\n\t}\n\n\t \n\tout = 0;\n\tif (shader == nvkm_clk_read(&clk->base, nv_clk_src_href)) {\n\t\tclk->ssrc = nv_clk_src_href;\n\t} else {\n\t\tclock = calc_pll(clk, 0x4020, shader, &N, &M, &P1);\n\t\tif (clk->csrc == nv_clk_src_core)\n\t\t\tout = calc_P((core << 1), shader, &divs);\n\n\t\tif (abs(shader - out) <=\n\t\t    abs(shader - clock) &&\n\t\t   (divs + P2) <= 7) {\n\t\t\tclk->ssrc = nv_clk_src_core;\n\t\t\tclk->sctrl = (divs + P2) << 16;\n\t\t} else {\n\t\t\tclk->ssrc = nv_clk_src_shader;\n\t\t\tclk->scoef = (N << 8) | M;\n\t\t\tclk->sctrl = P1 << 16;\n\t\t}\n\t}\n\n\t \n\tout = calc_P(core, vdec, &divs);\n\tclock = calc_P(500000, vdec, &P1);\n\tif(abs(vdec - out) <= abs(vdec - clock)) {\n\t\tclk->vsrc = nv_clk_src_cclk;\n\t\tclk->vdiv = divs << 16;\n\t} else {\n\t\tclk->vsrc = nv_clk_src_vdec;\n\t\tclk->vdiv = P1 << 16;\n\t}\n\n\t \n\tnvkm_debug(subdev, \"nvpll: %08x %08x %08x\\n\",\n\t\t   clk->ccoef, clk->cpost, clk->cctrl);\n\tnvkm_debug(subdev, \" spll: %08x %08x %08x\\n\",\n\t\t   clk->scoef, clk->spost, clk->sctrl);\n\tnvkm_debug(subdev, \" vdiv: %08x\\n\", clk->vdiv);\n\tif (clk->csrc == nv_clk_src_hclkm4)\n\t\tnvkm_debug(subdev, \"core: hrefm4\\n\");\n\telse\n\t\tnvkm_debug(subdev, \"core: nvpll\\n\");\n\n\tif (clk->ssrc == nv_clk_src_hclkm4)\n\t\tnvkm_debug(subdev, \"shader: hrefm4\\n\");\n\telse if (clk->ssrc == nv_clk_src_core)\n\t\tnvkm_debug(subdev, \"shader: nvpll\\n\");\n\telse\n\t\tnvkm_debug(subdev, \"shader: spll\\n\");\n\n\tif (clk->vsrc == nv_clk_src_hclkm4)\n\t\tnvkm_debug(subdev, \"vdec: 500MHz\\n\");\n\telse\n\t\tnvkm_debug(subdev, \"vdec: core\\n\");\n\n\treturn 0;\n}\n\nstatic int\nmcp77_clk_prog(struct nvkm_clk *base)\n{\n\tstruct mcp77_clk *clk = mcp77_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 pllmask = 0, mast;\n\tunsigned long flags;\n\tunsigned long *f = &flags;\n\tint ret = 0;\n\n\tret = gt215_clk_pre(&clk->base, f);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmast = nvkm_mask(device, 0xc054, 0x03400e70, 0x03400640);\n\tmast &= ~0x00400e73;\n\tmast |= 0x03000000;\n\n\tswitch (clk->csrc) {\n\tcase nv_clk_src_hclkm4:\n\t\tnvkm_mask(device, 0x4028, 0x00070000, clk->cctrl);\n\t\tmast |= 0x00000002;\n\t\tbreak;\n\tcase nv_clk_src_core:\n\t\tnvkm_wr32(device, 0x402c, clk->ccoef);\n\t\tnvkm_wr32(device, 0x4028, 0x80000000 | clk->cctrl);\n\t\tnvkm_wr32(device, 0x4040, clk->cpost);\n\t\tpllmask |= (0x3 << 8);\n\t\tmast |= 0x00000003;\n\t\tbreak;\n\tdefault:\n\t\tnvkm_warn(subdev, \"Reclocking failed: unknown core clock\\n\");\n\t\tgoto resume;\n\t}\n\n\tswitch (clk->ssrc) {\n\tcase nv_clk_src_href:\n\t\tnvkm_mask(device, 0x4020, 0x00070000, 0x00000000);\n\t\t \n\t\tbreak;\n\tcase nv_clk_src_core:\n\t\tnvkm_mask(device, 0x4020, 0x00070000, clk->sctrl);\n\t\tmast |= 0x00000020;\n\t\tbreak;\n\tcase nv_clk_src_shader:\n\t\tnvkm_wr32(device, 0x4024, clk->scoef);\n\t\tnvkm_wr32(device, 0x4020, 0x80000000 | clk->sctrl);\n\t\tnvkm_wr32(device, 0x4070, clk->spost);\n\t\tpllmask |= (0x3 << 12);\n\t\tmast |= 0x00000030;\n\t\tbreak;\n\tdefault:\n\t\tnvkm_warn(subdev, \"Reclocking failed: unknown sclk clock\\n\");\n\t\tgoto resume;\n\t}\n\n\tif (nvkm_msec(device, 2000,\n\t\tu32 tmp = nvkm_rd32(device, 0x004080) & pllmask;\n\t\tif (tmp == pllmask)\n\t\t\tbreak;\n\t) < 0)\n\t\tgoto resume;\n\n\tswitch (clk->vsrc) {\n\tcase nv_clk_src_cclk:\n\t\tmast |= 0x00400000;\n\t\tfallthrough;\n\tdefault:\n\t\tnvkm_wr32(device, 0x4600, clk->vdiv);\n\t}\n\n\tnvkm_wr32(device, 0xc054, mast);\n\nresume:\n\t \n\tif (clk->csrc != nv_clk_src_core) {\n\t\tnvkm_wr32(device, 0x4040, 0x00000000);\n\t\tnvkm_mask(device, 0x4028, 0x80000000, 0x00000000);\n\t}\n\n\tif (clk->ssrc != nv_clk_src_shader) {\n\t\tnvkm_wr32(device, 0x4070, 0x00000000);\n\t\tnvkm_mask(device, 0x4020, 0x80000000, 0x00000000);\n\t}\n\nout:\n\tif (ret == -EBUSY)\n\t\tf = NULL;\n\n\tgt215_clk_post(&clk->base, f);\n\treturn ret;\n}\n\nstatic void\nmcp77_clk_tidy(struct nvkm_clk *base)\n{\n}\n\nstatic const struct nvkm_clk_func\nmcp77_clk = {\n\t.read = mcp77_clk_read,\n\t.calc = mcp77_clk_calc,\n\t.prog = mcp77_clk_prog,\n\t.tidy = mcp77_clk_tidy,\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_href   , 0xff },\n\t\t{ nv_clk_src_core   , 0xff, 0, \"core\", 1000 },\n\t\t{ nv_clk_src_shader , 0xff, 0, \"shader\", 1000 },\n\t\t{ nv_clk_src_vdec   , 0xff, 0, \"vdec\", 1000 },\n\t\t{ nv_clk_src_max }\n\t}\n};\n\nint\nmcp77_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_clk **pclk)\n{\n\tstruct mcp77_clk *clk;\n\n\tif (!(clk = kzalloc(sizeof(*clk), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base;\n\n\treturn nvkm_clk_ctor(&mcp77_clk, device, type, inst, true, &clk->base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}