{
  "module_name": "agp.c",
  "hash_id": "20618b01344060f2f4095a92b90c1564715e5290f8f5d9d1582ff0ea7c6348cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pci/agp.c",
  "human_readable_source": " \n#include \"agp.h\"\n#ifdef __NVKM_PCI_AGP_H__\n#include <core/option.h>\n\nstruct nvkm_device_agp_quirk {\n\tu16 hostbridge_vendor;\n\tu16 hostbridge_device;\n\tu16 chip_vendor;\n\tu16 chip_device;\n\tint mode;\n};\n\nstatic const struct nvkm_device_agp_quirk\nnvkm_device_agp_quirks[] = {\n\t \n\t{ PCI_VENDOR_ID_VIA, 0x0691, PCI_VENDOR_ID_NVIDIA, 0x0311, 2 },\n\t \n\t{ PCI_VENDOR_ID_SI, 0x0761, PCI_ANY_ID, PCI_ANY_ID, 0 },\n\t{},\n};\n\nvoid\nnvkm_agp_fini(struct nvkm_pci *pci)\n{\n\tif (pci->agp.acquired) {\n\t\tagp_backend_release(pci->agp.bridge);\n\t\tpci->agp.acquired = false;\n\t}\n}\n\n \nvoid\nnvkm_agp_preinit(struct nvkm_pci *pci)\n{\n\tstruct nvkm_device *device = pci->subdev.device;\n\tu32 mode = nvkm_pci_rd32(pci, 0x004c);\n\tu32 save[2];\n\n\t \n\tif ((mode | pci->agp.mode) & PCI_AGP_COMMAND_FW) {\n\t\tmode = pci->agp.mode & ~PCI_AGP_COMMAND_FW;\n\t\tagp_enable(pci->agp.bridge, mode);\n\t}\n\n\t \n\tsave[0] = nvkm_pci_rd32(pci, 0x0004);\n\tnvkm_pci_wr32(pci, 0x0004, save[0] & ~0x00000004);\n\tnvkm_pci_wr32(pci, 0x004c, 0x00000000);\n\n\t \n\tsave[1] = nvkm_mask(device, 0x000200, 0x00011100, 0x00000000);\n\tnvkm_mask(device, 0x000200, 0x00011100, save[1]);\n\n\t \n\tnvkm_pci_wr32(pci, 0x0004, save[0]);\n}\n\nint\nnvkm_agp_init(struct nvkm_pci *pci)\n{\n\tif (!agp_backend_acquire(pci->pdev)) {\n\t\tnvkm_error(&pci->subdev, \"failed to acquire agp\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tagp_enable(pci->agp.bridge, pci->agp.mode);\n\tpci->agp.acquired = true;\n\treturn 0;\n}\n\nvoid\nnvkm_agp_dtor(struct nvkm_pci *pci)\n{\n\tarch_phys_wc_del(pci->agp.mtrr);\n}\n\nvoid\nnvkm_agp_ctor(struct nvkm_pci *pci)\n{\n\tconst struct nvkm_device_agp_quirk *quirk = nvkm_device_agp_quirks;\n\tstruct nvkm_subdev *subdev = &pci->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tstruct agp_kern_info info;\n\tint mode = -1;\n\n#ifdef __powerpc__\n\t \n\tmode = 0;\n#endif\n\tmode = nvkm_longopt(device->cfgopt, \"NvAGP\", mode);\n\n\t \n\tif (!(pci->agp.bridge = agp_backend_acquire(pci->pdev))) {\n\t\tnvkm_warn(subdev, \"failed to acquire agp\\n\");\n\t\treturn;\n\t}\n\tagp_copy_info(pci->agp.bridge, &info);\n\tagp_backend_release(pci->agp.bridge);\n\n\tpci->agp.mode = info.mode;\n\tpci->agp.base = info.aper_base;\n\tpci->agp.size = info.aper_size * 1024 * 1024;\n\tpci->agp.cma  = info.cant_use_aperture;\n\tpci->agp.mtrr = -1;\n\n\t \n\twhile (quirk->hostbridge_vendor) {\n\t\tif (info.device->vendor == quirk->hostbridge_vendor &&\n\t\t    info.device->device == quirk->hostbridge_device &&\n\t\t    (quirk->chip_vendor == (u16)PCI_ANY_ID ||\n\t\t    pci->pdev->vendor == quirk->chip_vendor) &&\n\t\t    (quirk->chip_device == (u16)PCI_ANY_ID ||\n\t\t    pci->pdev->device == quirk->chip_device)) {\n\t\t\tnvkm_info(subdev, \"forcing default agp mode to %dX, \"\n\t\t\t\t\t  \"use NvAGP=<mode> to override\\n\",\n\t\t\t\t  quirk->mode);\n\t\t\tmode = quirk->mode;\n\t\t\tbreak;\n\t\t}\n\t\tquirk++;\n\t}\n\n\t \n\tif (mode >= 1) {\n\t\tif (pci->agp.mode & 0x00000008)\n\t\t\tmode /= 4;  \n\t\tpci->agp.mode &= ~0x00000007;\n\t\tpci->agp.mode |= (mode & 0x7);\n\t} else\n\tif (mode == 0) {\n\t\tpci->agp.bridge = NULL;\n\t\treturn;\n\t}\n\n\t \n\tif (device->chipset == 0x18)\n\t\tpci->agp.mode &= ~PCI_AGP_COMMAND_FW;\n\n\tpci->agp.mtrr = arch_phys_wc_add(pci->agp.base, pci->agp.size);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}