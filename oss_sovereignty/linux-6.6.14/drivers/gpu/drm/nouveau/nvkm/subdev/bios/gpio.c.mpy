{
  "module_name": "gpio.c",
  "hash_id": "a53243740e8b51cca77f9949761354754287013a9c55736f9a8bc58516094259",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/gpio.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n#include <subdev/bios/gpio.h>\n#include <subdev/bios/xpio.h>\n\nu16\ndcb_gpio_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tu16 data = 0x0000;\n\tu16 dcb = dcb_table(bios, ver, hdr, cnt, len);\n\tif (dcb) {\n\t\tif (*ver >= 0x30 && *hdr >= 0x0c)\n\t\t\tdata = nvbios_rd16(bios, dcb + 0x0a);\n\t\telse\n\t\tif (*ver >= 0x22 && nvbios_rd08(bios, dcb - 1) >= 0x13)\n\t\t\tdata = nvbios_rd16(bios, dcb - 0x0f);\n\n\t\tif (data) {\n\t\t\t*ver = nvbios_rd08(bios, data + 0x00);\n\t\t\tif (*ver < 0x30) {\n\t\t\t\t*hdr = 3;\n\t\t\t\t*cnt = nvbios_rd08(bios, data + 0x02);\n\t\t\t\t*len = nvbios_rd08(bios, data + 0x01);\n\t\t\t} else\n\t\t\tif (*ver <= 0x41) {\n\t\t\t\t*hdr = nvbios_rd08(bios, data + 0x01);\n\t\t\t\t*cnt = nvbios_rd08(bios, data + 0x02);\n\t\t\t\t*len = nvbios_rd08(bios, data + 0x03);\n\t\t\t} else {\n\t\t\t\tdata = 0x0000;\n\t\t\t}\n\t\t}\n\t}\n\treturn data;\n}\n\nu16\ndcb_gpio_entry(struct nvkm_bios *bios, int idx, int ent, u8 *ver, u8 *len)\n{\n\tu8  hdr, cnt, xver;  \n\tu16 gpio;\n\n\tif (!idx--)\n\t\tgpio = dcb_gpio_table(bios, ver, &hdr, &cnt, len);\n\telse\n\t\tgpio = dcb_xpio_table(bios, idx, &xver, &hdr, &cnt, len);\n\n\tif (gpio && ent < cnt)\n\t\treturn gpio + hdr + (ent * *len);\n\n\treturn 0x0000;\n}\n\nu16\ndcb_gpio_parse(struct nvkm_bios *bios, int idx, int ent, u8 *ver, u8 *len,\n\t       struct dcb_gpio_func *gpio)\n{\n\tu16 data = dcb_gpio_entry(bios, idx, ent, ver, len);\n\tif (data) {\n\t\tif (*ver < 0x40) {\n\t\t\tu16 info = nvbios_rd16(bios, data);\n\t\t\t*gpio = (struct dcb_gpio_func) {\n\t\t\t\t.line = (info & 0x001f) >> 0,\n\t\t\t\t.func = (info & 0x07e0) >> 5,\n\t\t\t\t.log[0] = (info & 0x1800) >> 11,\n\t\t\t\t.log[1] = (info & 0x6000) >> 13,\n\t\t\t\t.param = !!(info & 0x8000),\n\t\t\t};\n\t\t} else\n\t\tif (*ver < 0x41) {\n\t\t\tu32 info = nvbios_rd32(bios, data);\n\t\t\t*gpio = (struct dcb_gpio_func) {\n\t\t\t\t.line = (info & 0x0000001f) >> 0,\n\t\t\t\t.func = (info & 0x0000ff00) >> 8,\n\t\t\t\t.log[0] = (info & 0x18000000) >> 27,\n\t\t\t\t.log[1] = (info & 0x60000000) >> 29,\n\t\t\t\t.param = !!(info & 0x80000000),\n\t\t\t};\n\t\t} else {\n\t\t\tu32 info = nvbios_rd32(bios, data + 0);\n\t\t\tu8 info1 = nvbios_rd32(bios, data + 4);\n\t\t\t*gpio = (struct dcb_gpio_func) {\n\t\t\t\t.line = (info & 0x0000003f) >> 0,\n\t\t\t\t.func = (info & 0x0000ff00) >> 8,\n\t\t\t\t.log[0] = (info1 & 0x30) >> 4,\n\t\t\t\t.log[1] = (info1 & 0xc0) >> 6,\n\t\t\t\t.param = !!(info & 0x80000000),\n\t\t\t};\n\t\t}\n\t}\n\n\treturn data;\n}\n\nu16\ndcb_gpio_match(struct nvkm_bios *bios, int idx, u8 func, u8 line,\n\t       u8 *ver, u8 *len, struct dcb_gpio_func *gpio)\n{\n\tu8  hdr, cnt, i = 0;\n\tu16 data;\n\n\twhile ((data = dcb_gpio_parse(bios, idx, i++, ver, len, gpio))) {\n\t\tif ((line == 0xff || line == gpio->line) &&\n\t\t    (func == 0xff || func == gpio->func))\n\t\t\treturn data;\n\t}\n\n\t \n\tif ((data = dcb_table(bios, ver, &hdr, &cnt, len))) {\n\t\tif (*ver >= 0x22 && *ver < 0x30 && func == DCB_GPIO_TVDAC0) {\n\t\t\tu8 conf = nvbios_rd08(bios, data - 5);\n\t\t\tu8 addr = nvbios_rd08(bios, data - 4);\n\t\t\tif (conf & 0x01) {\n\t\t\t\t*gpio = (struct dcb_gpio_func) {\n\t\t\t\t\t.func = DCB_GPIO_TVDAC0,\n\t\t\t\t\t.line = addr >> 4,\n\t\t\t\t\t.log[0] = !!(conf & 0x02),\n\t\t\t\t\t.log[1] =  !(conf & 0x02),\n\t\t\t\t};\n\t\t\t\t*ver = 0x00;\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0x0000;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}