{
  "module_name": "gm107.c",
  "hash_id": "c77827104a4760ffcfcb334f2b0ddb5a2ca2d6fd48bcf68e760d73bf1bd93dd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gm107.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/fb.h>\n#include <subdev/timer.h>\n\nvoid\ngm107_ltc_cbc_clear(struct nvkm_ltc *ltc, u32 start, u32 limit)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tnvkm_wr32(device, 0x17e270, start);\n\tnvkm_wr32(device, 0x17e274, limit);\n\tnvkm_mask(device, 0x17e26c, 0x00000000, 0x00000004);\n}\n\nvoid\ngm107_ltc_cbc_wait(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tint c, s;\n\tfor (c = 0; c < ltc->ltc_nr; c++) {\n\t\tfor (s = 0; s < ltc->lts_nr; s++) {\n\t\t\tconst u32 addr = 0x14046c + (c * 0x2000) + (s * 0x200);\n\t\t\tnvkm_wait_msec(device, 2000, addr,\n\t\t\t\t       0x00000004, 0x00000000);\n\t\t}\n\t}\n}\n\nvoid\ngm107_ltc_zbc_clear_color(struct nvkm_ltc *ltc, int i, const u32 color[4])\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tnvkm_mask(device, 0x17e338, 0x0000000f, i);\n\tnvkm_wr32(device, 0x17e33c, color[0]);\n\tnvkm_wr32(device, 0x17e340, color[1]);\n\tnvkm_wr32(device, 0x17e344, color[2]);\n\tnvkm_wr32(device, 0x17e348, color[3]);\n}\n\nvoid\ngm107_ltc_zbc_clear_depth(struct nvkm_ltc *ltc, int i, const u32 depth)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tnvkm_mask(device, 0x17e338, 0x0000000f, i);\n\tnvkm_wr32(device, 0x17e34c, depth);\n}\n\nvoid\ngm107_ltc_intr_lts(struct nvkm_ltc *ltc, int c, int s)\n{\n\tstruct nvkm_subdev *subdev = &ltc->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 base = 0x140400 + (c * 0x2000) + (s * 0x200);\n\tu32 intr = nvkm_rd32(device, base + 0x00c);\n\tu16 stat = intr & 0x0000ffff;\n\tchar msg[128];\n\n\tif (stat) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), gf100_ltc_lts_intr_name, stat);\n\t\tnvkm_error(subdev, \"LTC%d_LTS%d: %08x [%s]\\n\", c, s, intr, msg);\n\t}\n\n\tnvkm_wr32(device, base + 0x00c, intr);\n}\n\nvoid\ngm107_ltc_intr(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tu32 mask;\n\n\tmask = nvkm_rd32(device, 0x00017c);\n\twhile (mask) {\n\t\tu32 s, c = __ffs(mask);\n\t\tfor (s = 0; s < ltc->lts_nr; s++)\n\t\t\tgm107_ltc_intr_lts(ltc, c, s);\n\t\tmask &= ~(1 << c);\n\t}\n}\n\nstatic int\ngm107_ltc_oneinit(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tconst u32 parts = nvkm_rd32(device, 0x022438);\n\tconst u32  mask = nvkm_rd32(device, 0x021c14);\n\tconst u32 slice = nvkm_rd32(device, 0x17e280) >> 28;\n\tint i;\n\n\tfor (i = 0; i < parts; i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tltc->ltc_nr++;\n\t}\n\tltc->lts_nr = slice;\n\n\treturn gf100_ltc_oneinit_tag_ram(ltc);\n}\n\nstatic void\ngm107_ltc_init(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tu32 lpg128 = !(nvkm_rd32(device, 0x100c80) & 0x00000001);\n\n\tnvkm_wr32(device, 0x17e27c, ltc->ltc_nr);\n\tnvkm_wr32(device, 0x17e278, ltc->tag_base);\n\tnvkm_mask(device, 0x17e264, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);\n}\n\nstatic const struct nvkm_ltc_func\ngm107_ltc = {\n\t.oneinit = gm107_ltc_oneinit,\n\t.init = gm107_ltc_init,\n\t.intr = gm107_ltc_intr,\n\t.cbc_clear = gm107_ltc_cbc_clear,\n\t.cbc_wait = gm107_ltc_cbc_wait,\n\t.zbc_color = 16,\n\t.zbc_depth = 16,\n\t.zbc_clear_color = gm107_ltc_zbc_clear_color,\n\t.zbc_clear_depth = gm107_ltc_zbc_clear_depth,\n\t.invalidate = gf100_ltc_invalidate,\n\t.flush = gf100_ltc_flush,\n};\n\nint\ngm107_ltc_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_ltc **pltc)\n{\n\treturn nvkm_ltc_new_(&gm107_ltc, device, type, inst, pltc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}