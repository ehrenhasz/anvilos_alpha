{
  "module_name": "temp.c",
  "hash_id": "5014e4df7f633233adb3fc2dcb68bb06230af82cbcb12eeef1be589477e59258",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/temp.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstatic void\nnvkm_therm_temp_set_defaults(struct nvkm_therm *therm)\n{\n\ttherm->bios_sensor.offset_constant = 0;\n\n\ttherm->bios_sensor.thrs_fan_boost.temp = 90;\n\ttherm->bios_sensor.thrs_fan_boost.hysteresis = 3;\n\n\ttherm->bios_sensor.thrs_down_clock.temp = 95;\n\ttherm->bios_sensor.thrs_down_clock.hysteresis = 3;\n\n\ttherm->bios_sensor.thrs_critical.temp = 105;\n\ttherm->bios_sensor.thrs_critical.hysteresis = 5;\n\n\ttherm->bios_sensor.thrs_shutdown.temp = 135;\n\ttherm->bios_sensor.thrs_shutdown.hysteresis = 5;  \n}\n\nstatic void\nnvkm_therm_temp_safety_checks(struct nvkm_therm *therm)\n{\n\tstruct nvbios_therm_sensor *s = &therm->bios_sensor;\n\n\t \n\ts->thrs_fan_boost.hysteresis = max_t(u8, s->thrs_fan_boost.hysteresis, 2);\n\ts->thrs_down_clock.hysteresis = max_t(u8, s->thrs_down_clock.hysteresis, 2);\n\ts->thrs_critical.hysteresis = max_t(u8, s->thrs_critical.hysteresis, 2);\n\ts->thrs_shutdown.hysteresis = max_t(u8, s->thrs_shutdown.hysteresis, 2);\n}\n\n \nvoid\nnvkm_therm_sensor_set_threshold_state(struct nvkm_therm *therm,\n\t\t\t\t      enum nvkm_therm_thrs thrs,\n\t\t\t\t      enum nvkm_therm_thrs_state st)\n{\n\ttherm->sensor.alarm_state[thrs] = st;\n}\n\n \nenum nvkm_therm_thrs_state\nnvkm_therm_sensor_get_threshold_state(struct nvkm_therm *therm,\n\t\t\t\t      enum nvkm_therm_thrs thrs)\n{\n\treturn therm->sensor.alarm_state[thrs];\n}\n\nstatic void\nnv_poweroff_work(struct work_struct *work)\n{\n\torderly_poweroff(true);\n\tkfree(work);\n}\n\nvoid\nnvkm_therm_sensor_event(struct nvkm_therm *therm, enum nvkm_therm_thrs thrs,\n\t\t\tenum nvkm_therm_thrs_direction dir)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tbool active;\n\tstatic const char * const thresholds[] = {\n\t\t\"fanboost\", \"downclock\", \"critical\", \"shutdown\"\n\t};\n\tint temperature = therm->func->temp_get(therm);\n\n\tif (thrs < 0 || thrs > 3)\n\t\treturn;\n\n\tif (dir == NVKM_THERM_THRS_FALLING)\n\t\tnvkm_info(subdev,\n\t\t\t  \"temperature (%i C) went below the '%s' threshold\\n\",\n\t\t\t  temperature, thresholds[thrs]);\n\telse\n\t\tnvkm_info(subdev, \"temperature (%i C) hit the '%s' threshold\\n\",\n\t\t\t  temperature, thresholds[thrs]);\n\n\tactive = (dir == NVKM_THERM_THRS_RISING);\n\tswitch (thrs) {\n\tcase NVKM_THERM_THRS_FANBOOST:\n\t\tif (active) {\n\t\t\tnvkm_therm_fan_set(therm, true, 100);\n\t\t\tnvkm_therm_fan_mode(therm, NVKM_THERM_CTRL_AUTO);\n\t\t}\n\t\tbreak;\n\tcase NVKM_THERM_THRS_DOWNCLOCK:\n\t\tif (therm->emergency.downclock)\n\t\t\ttherm->emergency.downclock(therm, active);\n\t\tbreak;\n\tcase NVKM_THERM_THRS_CRITICAL:\n\t\tif (therm->emergency.pause)\n\t\t\ttherm->emergency.pause(therm, active);\n\t\tbreak;\n\tcase NVKM_THERM_THRS_SHUTDOWN:\n\t\tif (active) {\n\t\t\tstruct work_struct *work;\n\n\t\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\t\tif (work) {\n\t\t\t\tINIT_WORK(work, nv_poweroff_work);\n\t\t\t\tschedule_work(work);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase NVKM_THERM_THRS_NR:\n\t\tbreak;\n\t}\n\n}\n\n \nstatic void\nnvkm_therm_threshold_hyst_polling(struct nvkm_therm *therm,\n\t\t\t\t  const struct nvbios_therm_threshold *thrs,\n\t\t\t\t  enum nvkm_therm_thrs thrs_name)\n{\n\tenum nvkm_therm_thrs_direction direction;\n\tenum nvkm_therm_thrs_state prev_state, new_state;\n\tint temp = therm->func->temp_get(therm);\n\n\tprev_state = nvkm_therm_sensor_get_threshold_state(therm, thrs_name);\n\n\tif (temp >= thrs->temp && prev_state == NVKM_THERM_THRS_LOWER) {\n\t\tdirection = NVKM_THERM_THRS_RISING;\n\t\tnew_state = NVKM_THERM_THRS_HIGHER;\n\t} else if (temp <= thrs->temp - thrs->hysteresis &&\n\t\t\tprev_state == NVKM_THERM_THRS_HIGHER) {\n\t\tdirection = NVKM_THERM_THRS_FALLING;\n\t\tnew_state = NVKM_THERM_THRS_LOWER;\n\t} else\n\t\treturn;  \n\n\tnvkm_therm_sensor_set_threshold_state(therm, thrs_name, new_state);\n\tnvkm_therm_sensor_event(therm, thrs_name, direction);\n}\n\nstatic void\nalarm_timer_callback(struct nvkm_alarm *alarm)\n{\n\tstruct nvkm_therm *therm =\n\t\tcontainer_of(alarm, struct nvkm_therm, sensor.therm_poll_alarm);\n\tstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\n\tstruct nvkm_timer *tmr = therm->subdev.device->timer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&therm->sensor.alarm_program_lock, flags);\n\n\tnvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_fan_boost,\n\t\t\t\t\t  NVKM_THERM_THRS_FANBOOST);\n\n\tnvkm_therm_threshold_hyst_polling(therm,\n\t\t\t\t\t  &sensor->thrs_down_clock,\n\t\t\t\t\t  NVKM_THERM_THRS_DOWNCLOCK);\n\n\tnvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_critical,\n\t\t\t\t\t  NVKM_THERM_THRS_CRITICAL);\n\n\tnvkm_therm_threshold_hyst_polling(therm, &sensor->thrs_shutdown,\n\t\t\t\t\t  NVKM_THERM_THRS_SHUTDOWN);\n\n\tspin_unlock_irqrestore(&therm->sensor.alarm_program_lock, flags);\n\n\t \n\tif (therm->func->temp_get(therm) >= 0)\n\t\tnvkm_timer_alarm(tmr, 1000000000ULL, alarm);\n}\n\nvoid\nnvkm_therm_program_alarms_polling(struct nvkm_therm *therm)\n{\n\tstruct nvbios_therm_sensor *sensor = &therm->bios_sensor;\n\n\tnvkm_debug(&therm->subdev,\n\t\t   \"programmed thresholds [ %d(%d), %d(%d), %d(%d), %d(%d) ]\\n\",\n\t\t   sensor->thrs_fan_boost.temp,\n\t\t   sensor->thrs_fan_boost.hysteresis,\n\t\t   sensor->thrs_down_clock.temp,\n\t\t   sensor->thrs_down_clock.hysteresis,\n\t\t   sensor->thrs_critical.temp,\n\t\t   sensor->thrs_critical.hysteresis,\n\t\t   sensor->thrs_shutdown.temp,\n\t\t   sensor->thrs_shutdown.hysteresis);\n\n\talarm_timer_callback(&therm->sensor.therm_poll_alarm);\n}\n\nint\nnvkm_therm_sensor_init(struct nvkm_therm *therm)\n{\n\ttherm->func->program_alarms(therm);\n\treturn 0;\n}\n\nint\nnvkm_therm_sensor_fini(struct nvkm_therm *therm, bool suspend)\n{\n\tstruct nvkm_timer *tmr = therm->subdev.device->timer;\n\tif (suspend)\n\t\tnvkm_timer_alarm(tmr, 0, &therm->sensor.therm_poll_alarm);\n\treturn 0;\n}\n\nvoid\nnvkm_therm_sensor_preinit(struct nvkm_therm *therm)\n{\n\tconst char *sensor_avail = \"yes\";\n\n\tif (therm->func->temp_get(therm) < 0)\n\t\tsensor_avail = \"no\";\n\n\tnvkm_debug(&therm->subdev, \"internal sensor: %s\\n\", sensor_avail);\n}\n\nint\nnvkm_therm_sensor_ctor(struct nvkm_therm *therm)\n{\n\tstruct nvkm_subdev *subdev = &therm->subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\n\tnvkm_alarm_init(&therm->sensor.therm_poll_alarm, alarm_timer_callback);\n\n\tnvkm_therm_temp_set_defaults(therm);\n\tif (nvbios_therm_sensor_parse(bios, NVBIOS_THERM_DOMAIN_CORE,\n\t\t\t\t      &therm->bios_sensor))\n\t\tnvkm_error(subdev, \"nvbios_therm_sensor_parse failed\\n\");\n\tnvkm_therm_temp_safety_checks(therm);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}