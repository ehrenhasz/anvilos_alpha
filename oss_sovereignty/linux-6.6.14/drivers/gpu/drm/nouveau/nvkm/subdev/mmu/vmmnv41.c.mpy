{
  "module_name": "vmmnv41.c",
  "hash_id": "994ba0b513db99e810a00aa35ac7c543d88dcad9a8199be16d944e33beddab36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmnv41.c",
  "human_readable_source": " \n#include \"vmm.h\"\n\n#include <subdev/timer.h>\n\nstatic void\nnv41_vmm_pgt_pte(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map, u64 addr)\n{\n\tu32 data = (addr >> 7) | 0x00000001;  \n\twhile (ptes--) {\n\t\tVMM_WO032(pt, vmm, ptei++ * 4, data);\n\t\tdata += 0x00000020;\n\t}\n}\n\nstatic void\nnv41_vmm_pgt_sgl(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_SGL(vmm, pt, ptei, ptes, map, nv41_vmm_pgt_pte);\n}\n\nstatic void\nnv41_vmm_pgt_dma(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n#if PAGE_SHIFT == 12\n\tnvkm_kmap(pt->memory);\n\twhile (ptes--) {\n\t\tconst u32 data = (*map->dma++ >> 7) | 0x00000001;\n\t\tVMM_WO032(pt, vmm, ptei++ * 4, data);\n\t}\n\tnvkm_done(pt->memory);\n#else\n\tVMM_MAP_ITER_DMA(vmm, pt, ptei, ptes, map, nv41_vmm_pgt_pte);\n#endif\n}\n\nstatic void\nnv41_vmm_pgt_unmap(struct nvkm_vmm *vmm,\n\t\t   struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tVMM_FO032(pt, vmm, ptei * 4, 0, ptes);\n}\n\nstatic const struct nvkm_vmm_desc_func\nnv41_vmm_desc_pgt = {\n\t.unmap = nv41_vmm_pgt_unmap,\n\t.dma = nv41_vmm_pgt_dma,\n\t.sgl = nv41_vmm_pgt_sgl,\n};\n\nstatic const struct nvkm_vmm_desc\nnv41_vmm_desc_12[] = {\n\t{ PGT, 17, 4, 0x1000, &nv41_vmm_desc_pgt },\n\t{}\n};\n\nstatic void\nnv41_vmm_flush(struct nvkm_vmm *vmm, int level)\n{\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\n\tmutex_lock(&vmm->mmu->mutex);\n\tnvkm_wr32(device, 0x100810, 0x00000022);\n\tnvkm_msec(device, 2000,\n\t\tif (nvkm_rd32(device, 0x100810) & 0x00000020)\n\t\t\tbreak;\n\t);\n\tnvkm_wr32(device, 0x100810, 0x00000000);\n\tmutex_unlock(&vmm->mmu->mutex);\n}\n\nstatic const struct nvkm_vmm_func\nnv41_vmm = {\n\t.valid = nv04_vmm_valid,\n\t.flush = nv41_vmm_flush,\n\t.page = {\n\t\t{ 12, &nv41_vmm_desc_12[0], NVKM_VMM_PAGE_HOST },\n\t\t{}\n\t}\n};\n\nint\nnv41_vmm_new(struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t     void *argv, u32 argc, struct lock_class_key *key, const char *name,\n\t     struct nvkm_vmm **pvmm)\n{\n\treturn nv04_vmm_new_(&nv41_vmm, mmu, 0, managed, addr, size,\n\t\t\t     argv, argc, key, name, pvmm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}