{
  "module_name": "nv50.c",
  "hash_id": "180f0e0f379891da3f3b56e4724975d956a35223c4c5bb414ca46fa4d6b3b07e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/nv50.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nvoid\nnv50_gpio_reset(struct nvkm_gpio *gpio, u8 match)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tu8 ver, len;\n\tu16 entry;\n\tint ent = -1;\n\n\twhile ((entry = dcb_gpio_entry(bios, 0, ++ent, &ver, &len))) {\n\t\tstatic const u32 regs[] = { 0xe100, 0xe28c };\n\t\tu32 data = nvbios_rd32(bios, entry);\n\t\tu8  line =   (data & 0x0000001f);\n\t\tu8  func =   (data & 0x0000ff00) >> 8;\n\t\tu8  defs = !!(data & 0x01000000);\n\t\tu8  unk0 = !!(data & 0x02000000);\n\t\tu8  unk1 = !!(data & 0x04000000);\n\t\tu32 val = (unk1 << 16) | unk0;\n\t\tu32 reg = regs[line >> 4];\n\t\tu32 lsh = line & 0x0f;\n\n\t\tif ( func  == DCB_GPIO_UNUSED ||\n\t\t    (match != DCB_GPIO_UNUSED && match != func))\n\t\t\tcontinue;\n\n\t\tnvkm_gpio_set(gpio, 0, func, line, defs);\n\n\t\tnvkm_mask(device, reg, 0x00010001 << lsh, val << lsh);\n\t}\n}\n\nstatic int\nnv50_gpio_location(int line, u32 *reg, u32 *shift)\n{\n\tconst u32 nv50_gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };\n\n\tif (line >= 32)\n\t\treturn -EINVAL;\n\n\t*reg = nv50_gpio_reg[line >> 3];\n\t*shift = (line & 7) << 2;\n\treturn 0;\n}\n\nint\nnv50_gpio_drive(struct nvkm_gpio *gpio, int line, int dir, int out)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 reg, shift;\n\n\tif (nv50_gpio_location(line, &reg, &shift))\n\t\treturn -EINVAL;\n\n\tnvkm_mask(device, reg, 3 << shift, (((dir ^ 1) << 1) | out) << shift);\n\treturn 0;\n}\n\nint\nnv50_gpio_sense(struct nvkm_gpio *gpio, int line)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 reg, shift;\n\n\tif (nv50_gpio_location(line, &reg, &shift))\n\t\treturn -EINVAL;\n\n\treturn !!(nvkm_rd32(device, reg) & (4 << shift));\n}\n\nstatic void\nnv50_gpio_intr_stat(struct nvkm_gpio *gpio, u32 *hi, u32 *lo)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 intr = nvkm_rd32(device, 0x00e054);\n\tu32 stat = nvkm_rd32(device, 0x00e050) & intr;\n\t*lo = (stat & 0xffff0000) >> 16;\n\t*hi = (stat & 0x0000ffff);\n\tnvkm_wr32(device, 0x00e054, intr);\n}\n\nstatic void\nnv50_gpio_intr_mask(struct nvkm_gpio *gpio, u32 type, u32 mask, u32 data)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 inte = nvkm_rd32(device, 0x00e050);\n\tif (type & NVKM_GPIO_LO)\n\t\tinte = (inte & ~(mask << 16)) | (data << 16);\n\tif (type & NVKM_GPIO_HI)\n\t\tinte = (inte & ~mask) | data;\n\tnvkm_wr32(device, 0x00e050, inte);\n}\n\nstatic const struct nvkm_gpio_func\nnv50_gpio = {\n\t.lines = 16,\n\t.intr_stat = nv50_gpio_intr_stat,\n\t.intr_mask = nv50_gpio_intr_mask,\n\t.drive = nv50_gpio_drive,\n\t.sense = nv50_gpio_sense,\n\t.reset = nv50_gpio_reset,\n};\n\nint\nnv50_gpio_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_gpio **pgpio)\n{\n\treturn nvkm_gpio_new_(&nv50_gpio, device, type, inst, pgpio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}