{
  "module_name": "vmmnv50.c",
  "hash_id": "77a531851c3f8b2c8524f5e146eed9b85ad3a5a388e04f25cd56c967c853c3bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmmnv50.c",
  "human_readable_source": " \n#include \"vmm.h\"\n\n#include <subdev/fb.h>\n#include <subdev/timer.h>\n#include <engine/gr.h>\n\n#include <nvif/if500d.h>\n#include <nvif/unpack.h>\n\nstatic inline void\nnv50_vmm_pgt_pte(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map, u64 addr)\n{\n\tu64 next = addr + map->type, data;\n\tu32 pten;\n\tint log2blk;\n\n\tmap->type += ptes * map->ctag;\n\n\twhile (ptes) {\n\t\tfor (log2blk = 7; log2blk >= 0; log2blk--) {\n\t\t\tpten = 1 << log2blk;\n\t\t\tif (ptes >= pten && IS_ALIGNED(ptei, pten))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdata  = next | (log2blk << 7);\n\t\tnext += pten * map->next;\n\t\tptes -= pten;\n\n\t\twhile (pten--)\n\t\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t}\n}\n\nstatic void\nnv50_vmm_pgt_sgl(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_SGL(vmm, pt, ptei, ptes, map, nv50_vmm_pgt_pte);\n}\n\nstatic void\nnv50_vmm_pgt_dma(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tif (map->page->shift == PAGE_SHIFT) {\n\t\tVMM_SPAM(vmm, \"DMAA %08x %08x PTE(s)\", ptei, ptes);\n\t\tnvkm_kmap(pt->memory);\n\t\twhile (ptes--) {\n\t\t\tconst u64 data = *map->dma++ + map->type;\n\t\t\tVMM_WO064(pt, vmm, ptei++ * 8, data);\n\t\t\tmap->type += map->ctag;\n\t\t}\n\t\tnvkm_done(pt->memory);\n\t\treturn;\n\t}\n\n\tVMM_MAP_ITER_DMA(vmm, pt, ptei, ptes, map, nv50_vmm_pgt_pte);\n}\n\nstatic void\nnv50_vmm_pgt_mem(struct nvkm_vmm *vmm, struct nvkm_mmu_pt *pt,\n\t\t u32 ptei, u32 ptes, struct nvkm_vmm_map *map)\n{\n\tVMM_MAP_ITER_MEM(vmm, pt, ptei, ptes, map, nv50_vmm_pgt_pte);\n}\n\nstatic void\nnv50_vmm_pgt_unmap(struct nvkm_vmm *vmm,\n\t\t   struct nvkm_mmu_pt *pt, u32 ptei, u32 ptes)\n{\n\tVMM_FO064(pt, vmm, ptei * 8, 0ULL, ptes);\n}\n\nstatic const struct nvkm_vmm_desc_func\nnv50_vmm_pgt = {\n\t.unmap = nv50_vmm_pgt_unmap,\n\t.mem = nv50_vmm_pgt_mem,\n\t.dma = nv50_vmm_pgt_dma,\n\t.sgl = nv50_vmm_pgt_sgl,\n};\n\nstatic bool\nnv50_vmm_pde(struct nvkm_vmm *vmm, struct nvkm_vmm_pt *pgt, u64 *pdata)\n{\n\tstruct nvkm_mmu_pt *pt;\n\tu64 data = 0xdeadcafe00000000ULL;\n\tif (pgt && (pt = pgt->pt[0])) {\n\t\tswitch (pgt->page) {\n\t\tcase 16: data = 0x00000001; break;\n\t\tcase 12: data = 0x00000003;\n\t\t\tswitch (nvkm_memory_size(pt->memory)) {\n\t\t\tcase 0x100000: data |= 0x00000000; break;\n\t\t\tcase 0x040000: data |= 0x00000020; break;\n\t\t\tcase 0x020000: data |= 0x00000040; break;\n\t\t\tcase 0x010000: data |= 0x00000060; break;\n\t\t\tdefault:\n\t\t\t\tWARN_ON(1);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (nvkm_memory_target(pt->memory)) {\n\t\tcase NVKM_MEM_TARGET_VRAM: data |= 0x00000000; break;\n\t\tcase NVKM_MEM_TARGET_HOST: data |= 0x00000008; break;\n\t\tcase NVKM_MEM_TARGET_NCOH: data |= 0x0000000c; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tdata |= pt->addr;\n\t}\n\t*pdata = data;\n\treturn true;\n}\n\nstatic void\nnv50_vmm_pgd_pde(struct nvkm_vmm *vmm, struct nvkm_vmm_pt *pgd, u32 pdei)\n{\n\tstruct nvkm_vmm_join *join;\n\tu32 pdeo = vmm->mmu->func->vmm.pd_offset + (pdei * 8);\n\tu64 data;\n\n\tif (!nv50_vmm_pde(vmm, pgd->pde[pdei], &data))\n\t\treturn;\n\n\tlist_for_each_entry(join, &vmm->join, head) {\n\t\tnvkm_kmap(join->inst);\n\t\tnvkm_wo64(join->inst, pdeo, data);\n\t\tnvkm_done(join->inst);\n\t}\n}\n\nstatic const struct nvkm_vmm_desc_func\nnv50_vmm_pgd = {\n\t.pde = nv50_vmm_pgd_pde,\n};\n\nconst struct nvkm_vmm_desc\nnv50_vmm_desc_12[] = {\n\t{ PGT, 17, 8, 0x1000, &nv50_vmm_pgt },\n\t{ PGD, 11, 0, 0x0000, &nv50_vmm_pgd },\n\t{}\n};\n\nconst struct nvkm_vmm_desc\nnv50_vmm_desc_16[] = {\n\t{ PGT, 13, 8, 0x1000, &nv50_vmm_pgt },\n\t{ PGD, 11, 0, 0x0000, &nv50_vmm_pgd },\n\t{}\n};\n\nvoid\nnv50_vmm_flush(struct nvkm_vmm *vmm, int level)\n{\n\tstruct nvkm_subdev *subdev = &vmm->mmu->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tint i, id;\n\n\tmutex_lock(&vmm->mmu->mutex);\n\tfor (i = 0; i < NVKM_SUBDEV_NR; i++) {\n\t\tif (!atomic_read(&vmm->engref[i]))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i == NVKM_ENGINE_GR && device->gr) {\n\t\t\tint ret = nvkm_gr_tlb_flush(device->gr);\n\t\t\tif (ret != -ENODEV)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (i) {\n\t\tcase NVKM_ENGINE_GR    : id = 0x00; break;\n\t\tcase NVKM_ENGINE_VP    :\n\t\tcase NVKM_ENGINE_MSPDEC: id = 0x01; break;\n\t\tcase NVKM_SUBDEV_BAR   : id = 0x06; break;\n\t\tcase NVKM_ENGINE_MSPPP :\n\t\tcase NVKM_ENGINE_MPEG  : id = 0x08; break;\n\t\tcase NVKM_ENGINE_BSP   :\n\t\tcase NVKM_ENGINE_MSVLD : id = 0x09; break;\n\t\tcase NVKM_ENGINE_CIPHER:\n\t\tcase NVKM_ENGINE_SEC   : id = 0x0a; break;\n\t\tcase NVKM_ENGINE_CE    : id = 0x0d; break;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tnvkm_wr32(device, 0x100c80, (id << 16) | 1);\n\t\tif (nvkm_msec(device, 2000,\n\t\t\tif (!(nvkm_rd32(device, 0x100c80) & 0x00000001))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\tnvkm_error(subdev, \"%s mmu invalidate timeout\\n\", nvkm_subdev_type[i]);\n\t}\n\tmutex_unlock(&vmm->mmu->mutex);\n}\n\nint\nnv50_vmm_valid(struct nvkm_vmm *vmm, void *argv, u32 argc,\n\t       struct nvkm_vmm_map *map)\n{\n\tconst struct nvkm_vmm_page *page = map->page;\n\tunion {\n\t\tstruct nv50_vmm_map_vn vn;\n\t\tstruct nv50_vmm_map_v0 v0;\n\t} *args = argv;\n\tstruct nvkm_device *device = vmm->mmu->subdev.device;\n\tstruct nvkm_ram *ram = device->fb->ram;\n\tstruct nvkm_memory *memory = map->memory;\n\tu8  aper, kind, kind_inv, comp, priv, ro;\n\tint kindn, ret = -ENOSYS;\n\tconst u8 *kindm;\n\n\tmap->type = map->ctag = 0;\n\tmap->next = 1 << page->shift;\n\n\tif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))) {\n\t\tro   = !!args->v0.ro;\n\t\tpriv = !!args->v0.priv;\n\t\tkind = args->v0.kind & 0x7f;\n\t\tcomp = args->v0.comp & 0x03;\n\t} else\n\tif (!(ret = nvif_unvers(ret, &argv, &argc, args->vn))) {\n\t\tro   = 0;\n\t\tpriv = 0;\n\t\tkind = 0x00;\n\t\tcomp = 0;\n\t} else {\n\t\tVMM_DEBUG(vmm, \"args\");\n\t\treturn ret;\n\t}\n\n\tswitch (nvkm_memory_target(memory)) {\n\tcase NVKM_MEM_TARGET_VRAM:\n\t\tif (ram->stolen) {\n\t\t\tmap->type |= ram->stolen;\n\t\t\taper = 3;\n\t\t} else {\n\t\t\taper = 0;\n\t\t}\n\t\tbreak;\n\tcase NVKM_MEM_TARGET_HOST:\n\t\taper = 2;\n\t\tbreak;\n\tcase NVKM_MEM_TARGET_NCOH:\n\t\taper = 3;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tkindm = vmm->mmu->func->kind(vmm->mmu, &kindn, &kind_inv);\n\tif (kind >= kindn || kindm[kind] == kind_inv) {\n\t\tVMM_DEBUG(vmm, \"kind %02x\", kind);\n\t\treturn -EINVAL;\n\t}\n\n\tif (map->mem && map->mem->type != kindm[kind]) {\n\t\tVMM_DEBUG(vmm, \"kind %02x bankswz: %d %d\", kind,\n\t\t\t  kindm[kind], map->mem->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (comp) {\n\t\tu32 tags = (nvkm_memory_size(memory) >> 16) * comp;\n\t\tif (aper != 0 || !(page->type & NVKM_VMM_PAGE_COMP)) {\n\t\t\tVMM_DEBUG(vmm, \"comp %d %02x\", aper, page->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!map->no_comp) {\n\t\t\tret = nvkm_memory_tags_get(memory, device, tags, NULL,\n\t\t\t\t\t\t   &map->tags);\n\t\t\tif (ret) {\n\t\t\t\tVMM_DEBUG(vmm, \"comp %d\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (map->tags->mn) {\n\t\t\t\tu32 tags = map->tags->mn->offset +\n\t\t\t\t\t   (map->offset >> 16);\n\t\t\t\tmap->ctag |= (u64)comp << 49;\n\t\t\t\tmap->type |= (u64)comp << 47;\n\t\t\t\tmap->type |= (u64)tags << 49;\n\t\t\t\tmap->next |= map->ctag;\n\t\t\t}\n\t\t}\n\t}\n\n\tmap->type |= BIT(0);  \n\tmap->type |= (u64)ro << 3;\n\tmap->type |= (u64)aper << 4;\n\tmap->type |= (u64)priv << 6;\n\tmap->type |= (u64)kind << 40;\n\treturn 0;\n}\n\nvoid\nnv50_vmm_part(struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\tstruct nvkm_vmm_join *join;\n\n\tlist_for_each_entry(join, &vmm->join, head) {\n\t\tif (join->inst == inst) {\n\t\t\tlist_del(&join->head);\n\t\t\tkfree(join);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint\nnv50_vmm_join(struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\tconst u32 pd_offset = vmm->mmu->func->vmm.pd_offset;\n\tstruct nvkm_vmm_join *join;\n\tint ret = 0;\n\tu64 data;\n\tu32 pdei;\n\n\tif (!(join = kmalloc(sizeof(*join), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tjoin->inst = inst;\n\tlist_add_tail(&join->head, &vmm->join);\n\n\tnvkm_kmap(join->inst);\n\tfor (pdei = vmm->start >> 29; pdei <= (vmm->limit - 1) >> 29; pdei++) {\n\t\tif (!nv50_vmm_pde(vmm, vmm->pd->pde[pdei], &data)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tnvkm_wo64(join->inst, pd_offset + (pdei * 8), data);\n\t}\n\tnvkm_done(join->inst);\n\treturn ret;\n}\n\nstatic const struct nvkm_vmm_func\nnv50_vmm = {\n\t.join = nv50_vmm_join,\n\t.part = nv50_vmm_part,\n\t.valid = nv50_vmm_valid,\n\t.flush = nv50_vmm_flush,\n\t.page_block = 1 << 29,\n\t.page = {\n\t\t{ 16, &nv50_vmm_desc_16[0], NVKM_VMM_PAGE_xVxC },\n\t\t{ 12, &nv50_vmm_desc_12[0], NVKM_VMM_PAGE_xVHx },\n\t\t{}\n\t}\n};\n\nint\nnv50_vmm_new(struct nvkm_mmu *mmu, bool managed, u64 addr, u64 size,\n\t     void *argv, u32 argc, struct lock_class_key *key, const char *name,\n\t     struct nvkm_vmm **pvmm)\n{\n\treturn nv04_vmm_new_(&nv50_vmm, mmu, 0, managed, addr, size,\n\t\t\t     argv, argc, key, name, pvmm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}