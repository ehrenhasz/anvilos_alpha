{
  "module_name": "pad.c",
  "hash_id": "4a937a7a9c48e85b19f069b5454a2f36e28efe3bbcd9f11a0c205e0c1badcf70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/i2c/pad.c",
  "human_readable_source": " \n#include \"pad.h\"\n\nstatic void\nnvkm_i2c_pad_mode_locked(struct nvkm_i2c_pad *pad, enum nvkm_i2c_pad_mode mode)\n{\n\tPAD_TRACE(pad, \"-> %s\", (mode == NVKM_I2C_PAD_AUX) ? \"aux\" :\n\t\t\t      (mode == NVKM_I2C_PAD_I2C) ? \"i2c\" : \"off\");\n\tif (pad->func->mode)\n\t\tpad->func->mode(pad, mode);\n}\n\nvoid\nnvkm_i2c_pad_mode(struct nvkm_i2c_pad *pad, enum nvkm_i2c_pad_mode mode)\n{\n\tPAD_TRACE(pad, \"mode %d\", mode);\n\tmutex_lock(&pad->mutex);\n\tnvkm_i2c_pad_mode_locked(pad, mode);\n\tpad->mode = mode;\n\tmutex_unlock(&pad->mutex);\n}\n\nvoid\nnvkm_i2c_pad_release(struct nvkm_i2c_pad *pad)\n{\n\tPAD_TRACE(pad, \"release\");\n\tif (pad->mode == NVKM_I2C_PAD_OFF)\n\t\tnvkm_i2c_pad_mode_locked(pad, pad->mode);\n\tmutex_unlock(&pad->mutex);\n}\n\nint\nnvkm_i2c_pad_acquire(struct nvkm_i2c_pad *pad, enum nvkm_i2c_pad_mode mode)\n{\n\tPAD_TRACE(pad, \"acquire\");\n\tmutex_lock(&pad->mutex);\n\tif (pad->mode != mode) {\n\t\tif (pad->mode != NVKM_I2C_PAD_OFF) {\n\t\t\tmutex_unlock(&pad->mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tnvkm_i2c_pad_mode_locked(pad, mode);\n\t}\n\treturn 0;\n}\n\nvoid\nnvkm_i2c_pad_fini(struct nvkm_i2c_pad *pad)\n{\n\tPAD_TRACE(pad, \"fini\");\n\tnvkm_i2c_pad_mode_locked(pad, NVKM_I2C_PAD_OFF);\n}\n\nvoid\nnvkm_i2c_pad_init(struct nvkm_i2c_pad *pad)\n{\n\tPAD_TRACE(pad, \"init\");\n\tnvkm_i2c_pad_mode_locked(pad, pad->mode);\n}\n\nvoid\nnvkm_i2c_pad_del(struct nvkm_i2c_pad **ppad)\n{\n\tstruct nvkm_i2c_pad *pad = *ppad;\n\tif (pad) {\n\t\tPAD_TRACE(pad, \"dtor\");\n\t\tlist_del(&pad->head);\n\t\tkfree(pad);\n\t\tpad = NULL;\n\t}\n}\n\nvoid\nnvkm_i2c_pad_ctor(const struct nvkm_i2c_pad_func *func, struct nvkm_i2c *i2c,\n\t\t  int id, struct nvkm_i2c_pad *pad)\n{\n\tpad->func = func;\n\tpad->i2c = i2c;\n\tpad->id = id;\n\tpad->mode = NVKM_I2C_PAD_OFF;\n\tmutex_init(&pad->mutex);\n\tlist_add_tail(&pad->head, &i2c->pad);\n\tPAD_TRACE(pad, \"ctor\");\n}\n\nint\nnvkm_i2c_pad_new_(const struct nvkm_i2c_pad_func *func, struct nvkm_i2c *i2c,\n\t\t  int id, struct nvkm_i2c_pad **ppad)\n{\n\tif (!(*ppad = kzalloc(sizeof(**ppad), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tnvkm_i2c_pad_ctor(func, i2c, id, *ppad);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}