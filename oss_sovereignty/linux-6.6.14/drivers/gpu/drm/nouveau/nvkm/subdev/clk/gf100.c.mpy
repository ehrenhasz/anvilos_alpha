{
  "module_name": "gf100.c",
  "hash_id": "1c3a84f54e75ddc0f700ffabafe9c86729308928fea02a295426aab99ee86413",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/gf100.c",
  "human_readable_source": " \n#define gf100_clk(p) container_of((p), struct gf100_clk, base)\n#include \"priv.h\"\n#include \"pll.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n#include <subdev/timer.h>\n\nstruct gf100_clk_info {\n\tu32 freq;\n\tu32 ssel;\n\tu32 mdiv;\n\tu32 dsrc;\n\tu32 ddiv;\n\tu32 coef;\n};\n\nstruct gf100_clk {\n\tstruct nvkm_clk base;\n\tstruct gf100_clk_info eng[16];\n};\n\nstatic u32 read_div(struct gf100_clk *, int, u32, u32);\n\nstatic u32\nread_vco(struct gf100_clk *clk, u32 dsrc)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ssrc = nvkm_rd32(device, dsrc);\n\tif (!(ssrc & 0x00000100))\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_sppll0);\n\treturn nvkm_clk_read(&clk->base, nv_clk_src_sppll1);\n}\n\nstatic u32\nread_pll(struct gf100_clk *clk, u32 pll)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ctrl = nvkm_rd32(device, pll + 0x00);\n\tu32 coef = nvkm_rd32(device, pll + 0x04);\n\tu32 P = (coef & 0x003f0000) >> 16;\n\tu32 N = (coef & 0x0000ff00) >> 8;\n\tu32 M = (coef & 0x000000ff) >> 0;\n\tu32 sclk;\n\n\tif (!(ctrl & 0x00000001))\n\t\treturn 0;\n\n\tswitch (pll) {\n\tcase 0x00e800:\n\tcase 0x00e820:\n\t\tsclk = device->crystal;\n\t\tP = 1;\n\t\tbreak;\n\tcase 0x132000:\n\t\tsclk = nvkm_clk_read(&clk->base, nv_clk_src_mpllsrc);\n\t\tbreak;\n\tcase 0x132020:\n\t\tsclk = nvkm_clk_read(&clk->base, nv_clk_src_mpllsrcref);\n\t\tbreak;\n\tcase 0x137000:\n\tcase 0x137020:\n\tcase 0x137040:\n\tcase 0x1370e0:\n\t\tsclk = read_div(clk, (pll & 0xff) / 0x20, 0x137120, 0x137140);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn sclk * N / M / P;\n}\n\nstatic u32\nread_div(struct gf100_clk *clk, int doff, u32 dsrc, u32 dctl)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 ssrc = nvkm_rd32(device, dsrc + (doff * 4));\n\tu32 sclk, sctl, sdiv = 2;\n\n\tswitch (ssrc & 0x00000003) {\n\tcase 0:\n\t\tif ((ssrc & 0x00030000) != 0x00030000)\n\t\t\treturn device->crystal;\n\t\treturn 108000;\n\tcase 2:\n\t\treturn 100000;\n\tcase 3:\n\t\tsclk = read_vco(clk, dsrc + (doff * 4));\n\n\t\t \n\t\tif (doff <= 2) {\n\t\t\tsctl = nvkm_rd32(device, dctl + (doff * 4));\n\n\t\t\tif (sctl & 0x80000000) {\n\t\t\t\tif (ssrc & 0x100)\n\t\t\t\t\tsctl >>= 8;\n\n\t\t\t\tsdiv = (sctl & 0x3f) + 2;\n\t\t\t}\n\t\t}\n\n\t\treturn (sclk * 2) / sdiv;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32\nread_clk(struct gf100_clk *clk, int idx)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 sctl = nvkm_rd32(device, 0x137250 + (idx * 4));\n\tu32 ssel = nvkm_rd32(device, 0x137100);\n\tu32 sclk, sdiv;\n\n\tif (ssel & (1 << idx)) {\n\t\tif (idx < 7)\n\t\t\tsclk = read_pll(clk, 0x137000 + (idx * 0x20));\n\t\telse\n\t\t\tsclk = read_pll(clk, 0x1370e0);\n\t\tsdiv = ((sctl & 0x00003f00) >> 8) + 2;\n\t} else {\n\t\tsclk = read_div(clk, idx, 0x137160, 0x1371d0);\n\t\tsdiv = ((sctl & 0x0000003f) >> 0) + 2;\n\t}\n\n\tif (sctl & 0x80000000)\n\t\treturn (sclk * 2) / sdiv;\n\n\treturn sclk;\n}\n\nstatic int\ngf100_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\n{\n\tstruct gf100_clk *clk = gf100_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\n\tswitch (src) {\n\tcase nv_clk_src_crystal:\n\t\treturn device->crystal;\n\tcase nv_clk_src_href:\n\t\treturn 100000;\n\tcase nv_clk_src_sppll0:\n\t\treturn read_pll(clk, 0x00e800);\n\tcase nv_clk_src_sppll1:\n\t\treturn read_pll(clk, 0x00e820);\n\n\tcase nv_clk_src_mpllsrcref:\n\t\treturn read_div(clk, 0, 0x137320, 0x137330);\n\tcase nv_clk_src_mpllsrc:\n\t\treturn read_pll(clk, 0x132020);\n\tcase nv_clk_src_mpll:\n\t\treturn read_pll(clk, 0x132000);\n\tcase nv_clk_src_mdiv:\n\t\treturn read_div(clk, 0, 0x137300, 0x137310);\n\tcase nv_clk_src_mem:\n\t\tif (nvkm_rd32(device, 0x1373f0) & 0x00000002)\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_mpll);\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_mdiv);\n\n\tcase nv_clk_src_gpc:\n\t\treturn read_clk(clk, 0x00);\n\tcase nv_clk_src_rop:\n\t\treturn read_clk(clk, 0x01);\n\tcase nv_clk_src_hubk07:\n\t\treturn read_clk(clk, 0x02);\n\tcase nv_clk_src_hubk06:\n\t\treturn read_clk(clk, 0x07);\n\tcase nv_clk_src_hubk01:\n\t\treturn read_clk(clk, 0x08);\n\tcase nv_clk_src_copy:\n\t\treturn read_clk(clk, 0x09);\n\tcase nv_clk_src_pmu:\n\t\treturn read_clk(clk, 0x0c);\n\tcase nv_clk_src_vdec:\n\t\treturn read_clk(clk, 0x0e);\n\tdefault:\n\t\tnvkm_error(subdev, \"invalid clock source %d\\n\", src);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32\ncalc_div(struct gf100_clk *clk, int idx, u32 ref, u32 freq, u32 *ddiv)\n{\n\tu32 div = min((ref * 2) / freq, (u32)65);\n\tif (div < 2)\n\t\tdiv = 2;\n\n\t*ddiv = div - 2;\n\treturn (ref * 2) / div;\n}\n\nstatic u32\ncalc_src(struct gf100_clk *clk, int idx, u32 freq, u32 *dsrc, u32 *ddiv)\n{\n\tu32 sclk;\n\n\t \n\t*ddiv = 0x00000000;\n\tswitch (freq) {\n\tcase  27000:\n\tcase 108000:\n\t\t*dsrc = 0x00000000;\n\t\tif (freq == 108000)\n\t\t\t*dsrc |= 0x00030000;\n\t\treturn freq;\n\tcase 100000:\n\t\t*dsrc = 0x00000002;\n\t\treturn freq;\n\tdefault:\n\t\t*dsrc = 0x00000003;\n\t\tbreak;\n\t}\n\n\t \n\tsclk = read_vco(clk, 0x137160 + (idx * 4));\n\tif (idx < 7)\n\t\tsclk = calc_div(clk, idx, sclk, freq, ddiv);\n\treturn sclk;\n}\n\nstatic u32\ncalc_pll(struct gf100_clk *clk, int idx, u32 freq, u32 *coef)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_bios *bios = subdev->device->bios;\n\tstruct nvbios_pll limits;\n\tint N, M, P, ret;\n\n\tret = nvbios_pll_parse(bios, 0x137000 + (idx * 0x20), &limits);\n\tif (ret)\n\t\treturn 0;\n\n\tlimits.refclk = read_div(clk, idx, 0x137120, 0x137140);\n\tif (!limits.refclk)\n\t\treturn 0;\n\n\tret = gt215_pll_calc(subdev, &limits, freq, &N, NULL, &M, &P);\n\tif (ret <= 0)\n\t\treturn 0;\n\n\t*coef = (P << 16) | (N << 8) | M;\n\treturn ret;\n}\n\nstatic int\ncalc_clk(struct gf100_clk *clk, struct nvkm_cstate *cstate, int idx, int dom)\n{\n\tstruct gf100_clk_info *info = &clk->eng[idx];\n\tu32 freq = cstate->domain[dom];\n\tu32 src0, div0, div1D, div1P = 0;\n\tu32 clk0, clk1 = 0;\n\n\t \n\tif (!freq)\n\t\treturn 0;\n\n\t \n\tclk0 = calc_src(clk, idx, freq, &src0, &div0);\n\tclk0 = calc_div(clk, idx, clk0, freq, &div1D);\n\n\t \n\tif (clk0 != freq && (0x00004387 & (1 << idx))) {\n\t\tif (idx <= 7)\n\t\t\tclk1 = calc_pll(clk, idx, freq, &info->coef);\n\t\telse\n\t\t\tclk1 = cstate->domain[nv_clk_src_hubk06];\n\t\tclk1 = calc_div(clk, idx, clk1, freq, &div1P);\n\t}\n\n\t \n\tif (abs((int)freq - clk0) <= abs((int)freq - clk1)) {\n\t\tinfo->dsrc = src0;\n\t\tif (div0) {\n\t\t\tinfo->ddiv |= 0x80000000;\n\t\t\tinfo->ddiv |= div0 << 8;\n\t\t\tinfo->ddiv |= div0;\n\t\t}\n\t\tif (div1D) {\n\t\t\tinfo->mdiv |= 0x80000000;\n\t\t\tinfo->mdiv |= div1D;\n\t\t}\n\t\tinfo->ssel = info->coef = 0;\n\t\tinfo->freq = clk0;\n\t} else {\n\t\tif (div1P) {\n\t\t\tinfo->mdiv |= 0x80000000;\n\t\t\tinfo->mdiv |= div1P << 8;\n\t\t}\n\t\tinfo->ssel = (1 << idx);\n\t\tinfo->freq = clk1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ngf100_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct gf100_clk *clk = gf100_clk(base);\n\tint ret;\n\n\tif ((ret = calc_clk(clk, cstate, 0x00, nv_clk_src_gpc)) ||\n\t    (ret = calc_clk(clk, cstate, 0x01, nv_clk_src_rop)) ||\n\t    (ret = calc_clk(clk, cstate, 0x02, nv_clk_src_hubk07)) ||\n\t    (ret = calc_clk(clk, cstate, 0x07, nv_clk_src_hubk06)) ||\n\t    (ret = calc_clk(clk, cstate, 0x08, nv_clk_src_hubk01)) ||\n\t    (ret = calc_clk(clk, cstate, 0x09, nv_clk_src_copy)) ||\n\t    (ret = calc_clk(clk, cstate, 0x0c, nv_clk_src_pmu)) ||\n\t    (ret = calc_clk(clk, cstate, 0x0e, nv_clk_src_vdec)))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\ngf100_clk_prog_0(struct gf100_clk *clk, int idx)\n{\n\tstruct gf100_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tif (idx < 7 && !info->ssel) {\n\t\tnvkm_mask(device, 0x1371d0 + (idx * 0x04), 0x80003f3f, info->ddiv);\n\t\tnvkm_wr32(device, 0x137160 + (idx * 0x04), info->dsrc);\n\t}\n}\n\nstatic void\ngf100_clk_prog_1(struct gf100_clk *clk, int idx)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tnvkm_mask(device, 0x137100, (1 << idx), 0x00000000);\n\tnvkm_msec(device, 2000,\n\t\tif (!(nvkm_rd32(device, 0x137100) & (1 << idx)))\n\t\t\tbreak;\n\t);\n}\n\nstatic void\ngf100_clk_prog_2(struct gf100_clk *clk, int idx)\n{\n\tstruct gf100_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tconst u32 addr = 0x137000 + (idx * 0x20);\n\tif (idx <= 7) {\n\t\tnvkm_mask(device, addr + 0x00, 0x00000004, 0x00000000);\n\t\tnvkm_mask(device, addr + 0x00, 0x00000001, 0x00000000);\n\t\tif (info->coef) {\n\t\t\tnvkm_wr32(device, addr + 0x04, info->coef);\n\t\t\tnvkm_mask(device, addr + 0x00, 0x00000001, 0x00000001);\n\n\t\t\t \n\t\t\tnvkm_mask(device, addr + 0x00, 0x00000010, 0x00000000);\n\t\t\tnvkm_msec(device, 2000,\n\t\t\t\tif (nvkm_rd32(device, addr + 0x00) & 0x00020000)\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t\tnvkm_mask(device, addr + 0x00, 0x00000010, 0x00000010);\n\n\t\t\t \n\t\t\tnvkm_mask(device, addr + 0x00, 0x00000004, 0x00000004);\n\t\t}\n\t}\n}\n\nstatic void\ngf100_clk_prog_3(struct gf100_clk *clk, int idx)\n{\n\tstruct gf100_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tif (info->ssel) {\n\t\tnvkm_mask(device, 0x137100, (1 << idx), info->ssel);\n\t\tnvkm_msec(device, 2000,\n\t\t\tu32 tmp = nvkm_rd32(device, 0x137100) & (1 << idx);\n\t\t\tif (tmp == info->ssel)\n\t\t\t\tbreak;\n\t\t);\n\t}\n}\n\nstatic void\ngf100_clk_prog_4(struct gf100_clk *clk, int idx)\n{\n\tstruct gf100_clk_info *info = &clk->eng[idx];\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tnvkm_mask(device, 0x137250 + (idx * 0x04), 0x00003f3f, info->mdiv);\n}\n\nstatic int\ngf100_clk_prog(struct nvkm_clk *base)\n{\n\tstruct gf100_clk *clk = gf100_clk(base);\n\tstruct {\n\t\tvoid (*exec)(struct gf100_clk *, int);\n\t} stage[] = {\n\t\t{ gf100_clk_prog_0 },  \n\t\t{ gf100_clk_prog_1 },  \n\t\t{ gf100_clk_prog_2 },  \n\t\t{ gf100_clk_prog_3 },  \n\t\t{ gf100_clk_prog_4 },  \n\t};\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(stage); i++) {\n\t\tfor (j = 0; j < ARRAY_SIZE(clk->eng); j++) {\n\t\t\tif (!clk->eng[j].freq)\n\t\t\t\tcontinue;\n\t\t\tstage[i].exec(clk, j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\ngf100_clk_tidy(struct nvkm_clk *base)\n{\n\tstruct gf100_clk *clk = gf100_clk(base);\n\tmemset(clk->eng, 0x00, sizeof(clk->eng));\n}\n\nstatic const struct nvkm_clk_func\ngf100_clk = {\n\t.read = gf100_clk_read,\n\t.calc = gf100_clk_calc,\n\t.prog = gf100_clk_prog,\n\t.tidy = gf100_clk_tidy,\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_href   , 0xff },\n\t\t{ nv_clk_src_hubk06 , 0x00 },\n\t\t{ nv_clk_src_hubk01 , 0x01 },\n\t\t{ nv_clk_src_copy   , 0x02 },\n\t\t{ nv_clk_src_gpc    , 0x03, NVKM_CLK_DOM_FLAG_VPSTATE, \"core\", 2000 },\n\t\t{ nv_clk_src_rop    , 0x04 },\n\t\t{ nv_clk_src_mem    , 0x05, 0, \"memory\", 1000 },\n\t\t{ nv_clk_src_vdec   , 0x06 },\n\t\t{ nv_clk_src_pmu    , 0x0a },\n\t\t{ nv_clk_src_hubk07 , 0x0b },\n\t\t{ nv_clk_src_max }\n\t}\n};\n\nint\ngf100_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_clk **pclk)\n{\n\tstruct gf100_clk *clk;\n\n\tif (!(clk = kzalloc(sizeof(*clk), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\t*pclk = &clk->base;\n\n\treturn nvkm_clk_ctor(&gf100_clk, device, type, inst, false, &clk->base);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}