{
  "module_name": "nv50.c",
  "hash_id": "432c15185119ea630c679e44f0ce932f568991d4d65d1194b3ed78f44ed03eb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/clk/nv50.c",
  "human_readable_source": " \n#include \"nv50.h\"\n#include \"pll.h\"\n#include \"seq.h\"\n\n#include <subdev/bios.h>\n#include <subdev/bios/pll.h>\n\nstatic u32\nread_div(struct nv50_clk *clk)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tswitch (device->chipset) {\n\tcase 0x50:  \n\tcase 0x84:\n\tcase 0x86:\n\tcase 0x98:\n\tcase 0xa0:\n\t\treturn nvkm_rd32(device, 0x004700);\n\tcase 0x92:\n\tcase 0x94:\n\tcase 0x96:\n\t\treturn nvkm_rd32(device, 0x004800);\n\tdefault:\n\t\treturn 0x00000000;\n\t}\n}\n\nstatic u32\nread_pll_src(struct nv50_clk *clk, u32 base)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 coef, ref = nvkm_clk_read(&clk->base, nv_clk_src_crystal);\n\tu32 rsel = nvkm_rd32(device, 0x00e18c);\n\tint P, N, M, id;\n\n\tswitch (device->chipset) {\n\tcase 0x50:\n\tcase 0xa0:\n\t\tswitch (base) {\n\t\tcase 0x4020:\n\t\tcase 0x4028: id = !!(rsel & 0x00000004); break;\n\t\tcase 0x4008: id = !!(rsel & 0x00000008); break;\n\t\tcase 0x4030: id = 0; break;\n\t\tdefault:\n\t\t\tnvkm_error(subdev, \"ref: bad pll %06x\\n\", base);\n\t\t\treturn 0;\n\t\t}\n\n\t\tcoef = nvkm_rd32(device, 0x00e81c + (id * 0x0c));\n\t\tref *=  (coef & 0x01000000) ? 2 : 4;\n\t\tP    =  (coef & 0x00070000) >> 16;\n\t\tN    = ((coef & 0x0000ff00) >> 8) + 1;\n\t\tM    = ((coef & 0x000000ff) >> 0) + 1;\n\t\tbreak;\n\tcase 0x84:\n\tcase 0x86:\n\tcase 0x92:\n\t\tcoef = nvkm_rd32(device, 0x00e81c);\n\t\tP    = (coef & 0x00070000) >> 16;\n\t\tN    = (coef & 0x0000ff00) >> 8;\n\t\tM    = (coef & 0x000000ff) >> 0;\n\t\tbreak;\n\tcase 0x94:\n\tcase 0x96:\n\tcase 0x98:\n\t\trsel = nvkm_rd32(device, 0x00c050);\n\t\tswitch (base) {\n\t\tcase 0x4020: rsel = (rsel & 0x00000003) >> 0; break;\n\t\tcase 0x4008: rsel = (rsel & 0x0000000c) >> 2; break;\n\t\tcase 0x4028: rsel = (rsel & 0x00001800) >> 11; break;\n\t\tcase 0x4030: rsel = 3; break;\n\t\tdefault:\n\t\t\tnvkm_error(subdev, \"ref: bad pll %06x\\n\", base);\n\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (rsel) {\n\t\tcase 0: id = 1; break;\n\t\tcase 1: return nvkm_clk_read(&clk->base, nv_clk_src_crystal);\n\t\tcase 2: return nvkm_clk_read(&clk->base, nv_clk_src_href);\n\t\tcase 3: id = 0; break;\n\t\t}\n\n\t\tcoef =  nvkm_rd32(device, 0x00e81c + (id * 0x28));\n\t\tP    = (nvkm_rd32(device, 0x00e824 + (id * 0x28)) >> 16) & 7;\n\t\tP   += (coef & 0x00070000) >> 16;\n\t\tN    = (coef & 0x0000ff00) >> 8;\n\t\tM    = (coef & 0x000000ff) >> 0;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (M)\n\t\treturn (ref * N / M) >> P;\n\n\treturn 0;\n}\n\nstatic u32\nread_pll_ref(struct nv50_clk *clk, u32 base)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 src, mast = nvkm_rd32(device, 0x00c040);\n\n\tswitch (base) {\n\tcase 0x004028:\n\t\tsrc = !!(mast & 0x00200000);\n\t\tbreak;\n\tcase 0x004020:\n\t\tsrc = !!(mast & 0x00400000);\n\t\tbreak;\n\tcase 0x004008:\n\t\tsrc = !!(mast & 0x00010000);\n\t\tbreak;\n\tcase 0x004030:\n\t\tsrc = !!(mast & 0x02000000);\n\t\tbreak;\n\tcase 0x00e810:\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_crystal);\n\tdefault:\n\t\tnvkm_error(subdev, \"bad pll %06x\\n\", base);\n\t\treturn 0;\n\t}\n\n\tif (src)\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_href);\n\n\treturn read_pll_src(clk, base);\n}\n\nstatic u32\nread_pll(struct nv50_clk *clk, u32 base)\n{\n\tstruct nvkm_device *device = clk->base.subdev.device;\n\tu32 mast = nvkm_rd32(device, 0x00c040);\n\tu32 ctrl = nvkm_rd32(device, base + 0);\n\tu32 coef = nvkm_rd32(device, base + 4);\n\tu32 ref = read_pll_ref(clk, base);\n\tu32 freq = 0;\n\tint N1, N2, M1, M2;\n\n\tif (base == 0x004028 && (mast & 0x00100000)) {\n\t\t \n\t\tif (device->chipset != 0xa0)\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_dom6);\n\t}\n\n\tN2 = (coef & 0xff000000) >> 24;\n\tM2 = (coef & 0x00ff0000) >> 16;\n\tN1 = (coef & 0x0000ff00) >> 8;\n\tM1 = (coef & 0x000000ff);\n\tif ((ctrl & 0x80000000) && M1) {\n\t\tfreq = ref * N1 / M1;\n\t\tif ((ctrl & 0x40000100) == 0x40000000) {\n\t\t\tif (M2)\n\t\t\t\tfreq = freq * N2 / M2;\n\t\t\telse\n\t\t\t\tfreq = 0;\n\t\t}\n\t}\n\n\treturn freq;\n}\n\nint\nnv50_clk_read(struct nvkm_clk *base, enum nv_clk_src src)\n{\n\tstruct nv50_clk *clk = nv50_clk(base);\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 mast = nvkm_rd32(device, 0x00c040);\n\tu32 P = 0;\n\n\tswitch (src) {\n\tcase nv_clk_src_crystal:\n\t\treturn device->crystal;\n\tcase nv_clk_src_href:\n\t\treturn 100000;  \n\tcase nv_clk_src_hclk:\n\t\treturn div_u64((u64)nvkm_clk_read(&clk->base, nv_clk_src_href) * 27778, 10000);\n\tcase nv_clk_src_hclkm3:\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_hclk) * 3;\n\tcase nv_clk_src_hclkm3d2:\n\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_hclk) * 3 / 2;\n\tcase nv_clk_src_host:\n\t\tswitch (mast & 0x30000000) {\n\t\tcase 0x00000000: return nvkm_clk_read(&clk->base, nv_clk_src_href);\n\t\tcase 0x10000000: break;\n\t\tcase 0x20000000:  \n\t\tcase 0x30000000: return nvkm_clk_read(&clk->base, nv_clk_src_hclk);\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_core:\n\t\tif (!(mast & 0x00100000))\n\t\t\tP = (nvkm_rd32(device, 0x004028) & 0x00070000) >> 16;\n\t\tswitch (mast & 0x00000003) {\n\t\tcase 0x00000000: return nvkm_clk_read(&clk->base, nv_clk_src_crystal) >> P;\n\t\tcase 0x00000001: return nvkm_clk_read(&clk->base, nv_clk_src_dom6);\n\t\tcase 0x00000002: return read_pll(clk, 0x004020) >> P;\n\t\tcase 0x00000003: return read_pll(clk, 0x004028) >> P;\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_shader:\n\t\tP = (nvkm_rd32(device, 0x004020) & 0x00070000) >> 16;\n\t\tswitch (mast & 0x00000030) {\n\t\tcase 0x00000000:\n\t\t\tif (mast & 0x00000080)\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_host) >> P;\n\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_crystal) >> P;\n\t\tcase 0x00000010: break;\n\t\tcase 0x00000020: return read_pll(clk, 0x004028) >> P;\n\t\tcase 0x00000030: return read_pll(clk, 0x004020) >> P;\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_mem:\n\t\tP = (nvkm_rd32(device, 0x004008) & 0x00070000) >> 16;\n\t\tif (nvkm_rd32(device, 0x004008) & 0x00000200) {\n\t\t\tswitch (mast & 0x0000c000) {\n\t\t\tcase 0x00000000:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_crystal) >> P;\n\t\t\tcase 0x00008000:\n\t\t\tcase 0x0000c000:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_href) >> P;\n\t\t\t}\n\t\t} else {\n\t\t\treturn read_pll(clk, 0x004008) >> P;\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_vdec:\n\t\tP = (read_div(clk) & 0x00000700) >> 8;\n\t\tswitch (device->chipset) {\n\t\tcase 0x84:\n\t\tcase 0x86:\n\t\tcase 0x92:\n\t\tcase 0x94:\n\t\tcase 0x96:\n\t\tcase 0xa0:\n\t\t\tswitch (mast & 0x00000c00) {\n\t\t\tcase 0x00000000:\n\t\t\t\tif (device->chipset == 0xa0)  \n\t\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_core) >> P;\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_crystal) >> P;\n\t\t\tcase 0x00000400:\n\t\t\t\treturn 0;\n\t\t\tcase 0x00000800:\n\t\t\t\tif (mast & 0x01000000)\n\t\t\t\t\treturn read_pll(clk, 0x004028) >> P;\n\t\t\t\treturn read_pll(clk, 0x004030) >> P;\n\t\t\tcase 0x00000c00:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_core) >> P;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x98:\n\t\t\tswitch (mast & 0x00000c00) {\n\t\t\tcase 0x00000000:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_core) >> P;\n\t\t\tcase 0x00000400:\n\t\t\t\treturn 0;\n\t\t\tcase 0x00000800:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_hclkm3d2) >> P;\n\t\t\tcase 0x00000c00:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_mem) >> P;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase nv_clk_src_dom6:\n\t\tswitch (device->chipset) {\n\t\tcase 0x50:\n\t\tcase 0xa0:\n\t\t\treturn read_pll(clk, 0x00e810) >> 2;\n\t\tcase 0x84:\n\t\tcase 0x86:\n\t\tcase 0x92:\n\t\tcase 0x94:\n\t\tcase 0x96:\n\t\tcase 0x98:\n\t\t\tP = (read_div(clk) & 0x00000007) >> 0;\n\t\t\tswitch (mast & 0x0c000000) {\n\t\t\tcase 0x00000000: return nvkm_clk_read(&clk->base, nv_clk_src_href);\n\t\t\tcase 0x04000000: break;\n\t\t\tcase 0x08000000: return nvkm_clk_read(&clk->base, nv_clk_src_hclk);\n\t\t\tcase 0x0c000000:\n\t\t\t\treturn nvkm_clk_read(&clk->base, nv_clk_src_hclkm3) >> P;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnvkm_debug(subdev, \"unknown clock source %d %08x\\n\", src, mast);\n\treturn -EINVAL;\n}\n\nstatic u32\ncalc_pll(struct nv50_clk *clk, u32 reg, u32 idx, int *N, int *M, int *P)\n{\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvbios_pll pll;\n\tint ret;\n\n\tret = nvbios_pll_parse(subdev->device->bios, reg, &pll);\n\tif (ret)\n\t\treturn 0;\n\n\tpll.vco2.max_freq = 0;\n\tpll.refclk = read_pll_ref(clk, reg);\n\tif (!pll.refclk)\n\t\treturn 0;\n\n\treturn nv04_pll_calc(subdev, &pll, idx, N, M, NULL, NULL, P);\n}\n\nstatic inline u32\ncalc_div(u32 src, u32 target, int *div)\n{\n\tu32 clk0 = src, clk1 = src;\n\tfor (*div = 0; *div <= 7; (*div)++) {\n\t\tif (clk0 <= target) {\n\t\t\tclk1 = clk0 << (*div ? 1 : 0);\n\t\t\tbreak;\n\t\t}\n\t\tclk0 >>= 1;\n\t}\n\n\tif (target - clk0 <= clk1 - target)\n\t\treturn clk0;\n\t(*div)--;\n\treturn clk1;\n}\n\nstatic inline u32\nclk_same(u32 a, u32 b)\n{\n\treturn ((a / 1000) == (b / 1000));\n}\n\nint\nnv50_clk_calc(struct nvkm_clk *base, struct nvkm_cstate *cstate)\n{\n\tstruct nv50_clk *clk = nv50_clk(base);\n\tstruct nv50_clk_hwsq *hwsq = &clk->hwsq;\n\tstruct nvkm_subdev *subdev = &clk->base.subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst int shader = cstate->domain[nv_clk_src_shader];\n\tconst int core = cstate->domain[nv_clk_src_core];\n\tconst int vdec = cstate->domain[nv_clk_src_vdec];\n\tconst int dom6 = cstate->domain[nv_clk_src_dom6];\n\tu32 mastm = 0, mastv = 0;\n\tu32 divsm = 0, divsv = 0;\n\tint N, M, P1, P2;\n\tint freq, out;\n\n\t \n\tout = clk_init(hwsq, subdev);\n\tif (out)\n\t\treturn out;\n\n\tclk_wr32(hwsq, fifo, 0x00000001);  \n\tclk_nsec(hwsq, 8000);\n\tclk_setf(hwsq, 0x10, 0x00);  \n\tclk_wait(hwsq, 0x00, 0x01);  \n\n\t \n\tif (vdec) {\n\t\t \n\t\tfreq = calc_div(core, vdec, &P1);\n\n\t\t \n\t\tif (device->chipset != 0x98)\n\t\t\tout = read_pll(clk, 0x004030);\n\t\telse\n\t\t\tout = nvkm_clk_read(&clk->base, nv_clk_src_hclkm3d2);\n\t\tout = calc_div(out, vdec, &P2);\n\n\t\t \n\t\tif (abs(vdec - freq) <= abs(vdec - out)) {\n\t\t\tif (device->chipset != 0x98)\n\t\t\t\tmastv |= 0x00000c00;\n\t\t\tdivsv |= P1 << 8;\n\t\t} else {\n\t\t\tmastv |= 0x00000800;\n\t\t\tdivsv |= P2 << 8;\n\t\t}\n\n\t\tmastm |= 0x00000c00;\n\t\tdivsm |= 0x00000700;\n\t}\n\n\t \n\tif (dom6) {\n\t\tif (clk_same(dom6, nvkm_clk_read(&clk->base, nv_clk_src_href))) {\n\t\t\tmastv |= 0x00000000;\n\t\t} else\n\t\tif (clk_same(dom6, nvkm_clk_read(&clk->base, nv_clk_src_hclk))) {\n\t\t\tmastv |= 0x08000000;\n\t\t} else {\n\t\t\tfreq = nvkm_clk_read(&clk->base, nv_clk_src_hclk) * 3;\n\t\t\tcalc_div(freq, dom6, &P1);\n\n\t\t\tmastv |= 0x0c000000;\n\t\t\tdivsv |= P1;\n\t\t}\n\n\t\tmastm |= 0x0c000000;\n\t\tdivsm |= 0x00000007;\n\t}\n\n\t \n\tclk_mask(hwsq, mast, mastm, 0x00000000);\n\tclk_mask(hwsq, divs, divsm, divsv);\n\tclk_mask(hwsq, mast, mastm, mastv);\n\n\t \n\tif (device->chipset < 0x92)\n\t\tclk_mask(hwsq, mast, 0x001000b0, 0x00100080);\n\telse\n\t\tclk_mask(hwsq, mast, 0x000000b3, 0x00000081);\n\n\t \n\tfreq = calc_pll(clk, 0x4028, core, &N, &M, &P1);\n\tif (freq == 0)\n\t\treturn -ERANGE;\n\n\tclk_mask(hwsq, nvpll[0], 0xc03f0100,\n\t\t\t\t 0x80000000 | (P1 << 19) | (P1 << 16));\n\tclk_mask(hwsq, nvpll[1], 0x0000ffff, (N << 8) | M);\n\n\t \n\tif (P1-- && shader == (core << 1)) {\n\t\tclk_mask(hwsq, spll[0], 0xc03f0100, (P1 << 19) | (P1 << 16));\n\t\tclk_mask(hwsq, mast, 0x00100033, 0x00000023);\n\t} else {\n\t\tfreq = calc_pll(clk, 0x4020, shader, &N, &M, &P1);\n\t\tif (freq == 0)\n\t\t\treturn -ERANGE;\n\n\t\tclk_mask(hwsq, spll[0], 0xc03f0100,\n\t\t\t\t\t0x80000000 | (P1 << 19) | (P1 << 16));\n\t\tclk_mask(hwsq, spll[1], 0x0000ffff, (N << 8) | M);\n\t\tclk_mask(hwsq, mast, 0x00100033, 0x00000033);\n\t}\n\n\t \n\tclk_setf(hwsq, 0x10, 0x01);  \n\tclk_wait(hwsq, 0x00, 0x00);  \n\tclk_wr32(hwsq, fifo, 0x00000000);  \n\treturn 0;\n}\n\nint\nnv50_clk_prog(struct nvkm_clk *base)\n{\n\tstruct nv50_clk *clk = nv50_clk(base);\n\treturn clk_exec(&clk->hwsq, true);\n}\n\nvoid\nnv50_clk_tidy(struct nvkm_clk *base)\n{\n\tstruct nv50_clk *clk = nv50_clk(base);\n\tclk_exec(&clk->hwsq, false);\n}\n\nint\nnv50_clk_new_(const struct nvkm_clk_func *func, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, bool allow_reclock, struct nvkm_clk **pclk)\n{\n\tstruct nv50_clk *clk;\n\tint ret;\n\n\tif (!(clk = kzalloc(sizeof(*clk), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tret = nvkm_clk_ctor(func, device, type, inst, allow_reclock, &clk->base);\n\t*pclk = &clk->base;\n\tif (ret)\n\t\treturn ret;\n\n\tclk->hwsq.r_fifo = hwsq_reg(0x002504);\n\tclk->hwsq.r_spll[0] = hwsq_reg(0x004020);\n\tclk->hwsq.r_spll[1] = hwsq_reg(0x004024);\n\tclk->hwsq.r_nvpll[0] = hwsq_reg(0x004028);\n\tclk->hwsq.r_nvpll[1] = hwsq_reg(0x00402c);\n\tswitch (device->chipset) {\n\tcase 0x92:\n\tcase 0x94:\n\tcase 0x96:\n\t\tclk->hwsq.r_divs = hwsq_reg(0x004800);\n\t\tbreak;\n\tdefault:\n\t\tclk->hwsq.r_divs = hwsq_reg(0x004700);\n\t\tbreak;\n\t}\n\tclk->hwsq.r_mast = hwsq_reg(0x00c040);\n\treturn 0;\n}\n\nstatic const struct nvkm_clk_func\nnv50_clk = {\n\t.read = nv50_clk_read,\n\t.calc = nv50_clk_calc,\n\t.prog = nv50_clk_prog,\n\t.tidy = nv50_clk_tidy,\n\t.domains = {\n\t\t{ nv_clk_src_crystal, 0xff },\n\t\t{ nv_clk_src_href   , 0xff },\n\t\t{ nv_clk_src_core   , 0xff, 0, \"core\", 1000 },\n\t\t{ nv_clk_src_shader , 0xff, 0, \"shader\", 1000 },\n\t\t{ nv_clk_src_mem    , 0xff, 0, \"memory\", 1000 },\n\t\t{ nv_clk_src_max }\n\t}\n};\n\nint\nnv50_clk_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t     struct nvkm_clk **pclk)\n{\n\treturn nv50_clk_new_(&nv50_clk, device, type, inst, false, pclk);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}