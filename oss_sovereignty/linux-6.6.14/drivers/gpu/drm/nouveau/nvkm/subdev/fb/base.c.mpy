{
  "module_name": "base.c",
  "hash_id": "cf7f76e605129db50d32968451c0da26f2b66dfe1dd00c26e7c0ecb42f4c706d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/fb/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n#include \"ram.h\"\n\n#include <core/memory.h>\n#include <core/option.h>\n#include <subdev/bios.h>\n#include <subdev/bios/M0203.h>\n#include <engine/gr.h>\n#include <engine/mpeg.h>\n\nvoid\nnvkm_fb_tile_fini(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)\n{\n\tfb->func->tile.fini(fb, region, tile);\n}\n\nvoid\nnvkm_fb_tile_init(struct nvkm_fb *fb, int region, u32 addr, u32 size,\n\t\t  u32 pitch, u32 flags, struct nvkm_fb_tile *tile)\n{\n\tfb->func->tile.init(fb, region, addr, size, pitch, flags, tile);\n}\n\nvoid\nnvkm_fb_tile_prog(struct nvkm_fb *fb, int region, struct nvkm_fb_tile *tile)\n{\n\tstruct nvkm_device *device = fb->subdev.device;\n\tif (fb->func->tile.prog) {\n\t\tfb->func->tile.prog(fb, region, tile);\n\t\tif (device->gr)\n\t\t\tnvkm_engine_tile(&device->gr->engine, region);\n\t\tif (device->mpeg)\n\t\t\tnvkm_engine_tile(device->mpeg, region);\n\t}\n}\n\nstatic void\nnvkm_fb_sysmem_flush_page_init(struct nvkm_device *device)\n{\n\tstruct nvkm_fb *fb = device->fb;\n\n\tif (fb->func->sysmem.flush_page_init)\n\t\tfb->func->sysmem.flush_page_init(fb);\n}\n\nint\nnvkm_fb_bios_memtype(struct nvkm_bios *bios)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tconst u8 ramcfg = (nvkm_rd32(device, 0x101000) & 0x0000003c) >> 2;\n\tstruct nvbios_M0203E M0203E;\n\tu8 ver, hdr;\n\n\tif (nvbios_M0203Em(bios, ramcfg, &ver, &hdr, &M0203E)) {\n\t\tswitch (M0203E.type) {\n\t\tcase M0203E_TYPE_DDR2  : return NVKM_RAM_TYPE_DDR2;\n\t\tcase M0203E_TYPE_DDR3  : return NVKM_RAM_TYPE_DDR3;\n\t\tcase M0203E_TYPE_GDDR3 : return NVKM_RAM_TYPE_GDDR3;\n\t\tcase M0203E_TYPE_GDDR5 : return NVKM_RAM_TYPE_GDDR5;\n\t\tcase M0203E_TYPE_GDDR5X: return NVKM_RAM_TYPE_GDDR5X;\n\t\tcase M0203E_TYPE_GDDR6 : return NVKM_RAM_TYPE_GDDR6;\n\t\tcase M0203E_TYPE_HBM2  : return NVKM_RAM_TYPE_HBM2;\n\t\tdefault:\n\t\t\tnvkm_warn(subdev, \"M0203E type %02x\\n\", M0203E.type);\n\t\t\treturn NVKM_RAM_TYPE_UNKNOWN;\n\t\t}\n\t}\n\n\tnvkm_warn(subdev, \"M0203E not matched!\\n\");\n\treturn NVKM_RAM_TYPE_UNKNOWN;\n}\n\nstatic void\nnvkm_fb_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fb *fb = nvkm_fb(subdev);\n\tif (fb->func->intr)\n\t\tfb->func->intr(fb);\n}\n\nstatic int\nnvkm_fb_oneinit(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fb *fb = nvkm_fb(subdev);\n\tu32 tags = 0;\n\n\tif (fb->func->ram_new) {\n\t\tint ret = fb->func->ram_new(fb, &fb->ram);\n\t\tif (ret) {\n\t\t\tnvkm_error(subdev, \"vram setup failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (fb->func->oneinit) {\n\t\tint ret = fb->func->oneinit(fb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (fb->func->tags) {\n\t\ttags = fb->func->tags(fb);\n\t\tnvkm_debug(subdev, \"%d comptags\\n\", tags);\n\t}\n\n\treturn nvkm_mm_init(&fb->tags.mm, 0, 0, tags, 1);\n}\n\nint\nnvkm_fb_mem_unlock(struct nvkm_fb *fb)\n{\n\tstruct nvkm_subdev *subdev = &fb->subdev;\n\tint ret;\n\n\tif (!fb->func->vpr.scrub_required)\n\t\treturn 0;\n\n\tret = nvkm_subdev_oneinit(subdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!fb->func->vpr.scrub_required(fb)) {\n\t\tnvkm_debug(subdev, \"VPR not locked\\n\");\n\t\treturn 0;\n\t}\n\n\tnvkm_debug(subdev, \"VPR locked, running scrubber binary\\n\");\n\n\tif (!fb->vpr_scrubber.fw.img) {\n\t\tnvkm_warn(subdev, \"VPR locked, but no scrubber binary!\\n\");\n\t\treturn 0;\n\t}\n\n\tret = fb->func->vpr.scrub(fb);\n\tif (ret) {\n\t\tnvkm_error(subdev, \"VPR scrubber binary failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (fb->func->vpr.scrub_required(fb)) {\n\t\tnvkm_error(subdev, \"VPR still locked after scrub!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnvkm_debug(subdev, \"VPR scrubber binary successful\\n\");\n\treturn 0;\n}\n\nu64\nnvkm_fb_vidmem_size(struct nvkm_device *device)\n{\n\tstruct nvkm_fb *fb = device->fb;\n\n\tif (fb && fb->func->vidmem.size)\n\t\treturn fb->func->vidmem.size(fb);\n\n\tWARN_ON(1);\n\treturn 0;\n}\n\nstatic int\nnvkm_fb_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fb *fb = nvkm_fb(subdev);\n\tint ret, i;\n\n\tif (fb->ram) {\n\t\tret = nvkm_ram_init(fb->ram);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < fb->tile.regions; i++)\n\t\tfb->func->tile.prog(fb, i, &fb->tile.region[i]);\n\n\tnvkm_fb_sysmem_flush_page_init(subdev->device);\n\n\tif (fb->func->init)\n\t\tfb->func->init(fb);\n\n\tif (fb->func->init_remapper)\n\t\tfb->func->init_remapper(fb);\n\n\tif (fb->func->init_page) {\n\t\tret = fb->func->init_page(fb);\n\t\tif (WARN_ON(ret))\n\t\t\treturn ret;\n\t}\n\n\tif (fb->func->init_unkn)\n\t\tfb->func->init_unkn(fb);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_fb_preinit(struct nvkm_subdev *subdev)\n{\n\tnvkm_fb_sysmem_flush_page_init(subdev->device);\n\treturn 0;\n}\n\nstatic void *\nnvkm_fb_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_fb *fb = nvkm_fb(subdev);\n\tint i;\n\n\tnvkm_memory_unref(&fb->mmu_wr);\n\tnvkm_memory_unref(&fb->mmu_rd);\n\n\tfor (i = 0; i < fb->tile.regions; i++)\n\t\tfb->func->tile.fini(fb, i, &fb->tile.region[i]);\n\n\tnvkm_mm_fini(&fb->tags.mm);\n\tmutex_destroy(&fb->tags.mutex);\n\n\tnvkm_ram_del(&fb->ram);\n\n\tnvkm_falcon_fw_dtor(&fb->vpr_scrubber);\n\n\tif (fb->sysmem.flush_page) {\n\t\tdma_unmap_page(subdev->device->dev, fb->sysmem.flush_page_addr,\n\t\t\t       PAGE_SIZE, DMA_BIDIRECTIONAL);\n\t\t__free_page(fb->sysmem.flush_page);\n\t}\n\n\tif (fb->func->dtor)\n\t\treturn fb->func->dtor(fb);\n\n\treturn fb;\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_fb = {\n\t.dtor = nvkm_fb_dtor,\n\t.preinit = nvkm_fb_preinit,\n\t.oneinit = nvkm_fb_oneinit,\n\t.init = nvkm_fb_init,\n\t.intr = nvkm_fb_intr,\n};\n\nint\nnvkm_fb_ctor(const struct nvkm_fb_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_fb *fb)\n{\n\tnvkm_subdev_ctor(&nvkm_fb, device, type, inst, &fb->subdev);\n\tfb->func = func;\n\tfb->tile.regions = fb->func->tile.regions;\n\tfb->page = nvkm_longopt(device->cfgopt, \"NvFbBigPage\", fb->func->default_bigpage);\n\tmutex_init(&fb->tags.mutex);\n\n\tif (func->sysmem.flush_page_init) {\n\t\tfb->sysmem.flush_page = alloc_page(GFP_KERNEL | __GFP_ZERO);\n\t\tif (!fb->sysmem.flush_page)\n\t\t\treturn -ENOMEM;\n\n\t\tfb->sysmem.flush_page_addr = dma_map_page(device->dev, fb->sysmem.flush_page,\n\t\t\t\t\t\t\t  0, PAGE_SIZE, DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(device->dev, fb->sysmem.flush_page_addr))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nint\nnvkm_fb_new_(const struct nvkm_fb_func *func, struct nvkm_device *device,\n\t     enum nvkm_subdev_type type, int inst, struct nvkm_fb **pfb)\n{\n\tif (!(*pfb = kzalloc(sizeof(**pfb), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_fb_ctor(func, device, type, inst, *pfb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}