{
  "module_name": "dcb.c",
  "hash_id": "ff68f119944b7e21587336fa461bdea9b6b14e6eeb15e74b2c6f7536dfe443e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/dcb.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/dcb.h>\n\nu16\ndcb_table(struct nvkm_bios *bios, u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tstruct nvkm_subdev *subdev = &bios->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu16 dcb = 0x0000;\n\n\tif (device->card_type > NV_04)\n\t\tdcb = nvbios_rd16(bios, 0x36);\n\tif (!dcb) {\n\t\tnvkm_warn(subdev, \"DCB table not found\\n\");\n\t\treturn dcb;\n\t}\n\n\t*ver = nvbios_rd08(bios, dcb);\n\n\tif (*ver >= 0x42) {\n\t\tnvkm_warn(subdev, \"DCB version 0x%02x unknown\\n\", *ver);\n\t\treturn 0x0000;\n\t} else\n\tif (*ver >= 0x30) {\n\t\tif (nvbios_rd32(bios, dcb + 6) == 0x4edcbdcb) {\n\t\t\t*hdr = nvbios_rd08(bios, dcb + 1);\n\t\t\t*cnt = nvbios_rd08(bios, dcb + 2);\n\t\t\t*len = nvbios_rd08(bios, dcb + 3);\n\t\t\treturn dcb;\n\t\t}\n\t} else\n\tif (*ver >= 0x20) {\n\t\tif (nvbios_rd32(bios, dcb + 4) == 0x4edcbdcb) {\n\t\t\tu16 i2c = nvbios_rd16(bios, dcb + 2);\n\t\t\t*hdr = 8;\n\t\t\t*cnt = (i2c - dcb) / 8;\n\t\t\t*len = 8;\n\t\t\treturn dcb;\n\t\t}\n\t} else\n\tif (*ver >= 0x15) {\n\t\tif (!nvbios_memcmp(bios, dcb - 7, \"DEV_REC\", 7)) {\n\t\t\tu16 i2c = nvbios_rd16(bios, dcb + 2);\n\t\t\t*hdr = 4;\n\t\t\t*cnt = (i2c - dcb) / 10;\n\t\t\t*len = 10;\n\t\t\treturn dcb;\n\t\t}\n\t} else {\n\t\t \n\t\tnvkm_debug(subdev, \"DCB contains no useful data\\n\");\n\t\treturn 0x0000;\n\t}\n\n\tnvkm_warn(subdev, \"DCB header validation failed\\n\");\n\treturn 0x0000;\n}\n\nu16\ndcb_outp(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len)\n{\n\tu8  hdr, cnt;\n\tu16 dcb = dcb_table(bios, ver, &hdr, &cnt, len);\n\tif (dcb && idx < cnt)\n\t\treturn dcb + hdr + (idx * *len);\n\treturn 0x0000;\n}\n\nstatic inline u16\ndcb_outp_hasht(struct dcb_output *outp)\n{\n\treturn (outp->extdev << 8) | (outp->location << 4) | outp->type;\n}\n\nstatic inline u16\ndcb_outp_hashm(struct dcb_output *outp)\n{\n\treturn (outp->heads << 8) | (outp->link << 6) | outp->or;\n}\n\nu16\ndcb_outp_parse(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len,\n\t       struct dcb_output *outp)\n{\n\tu16 dcb = dcb_outp(bios, idx, ver, len);\n\tmemset(outp, 0x00, sizeof(*outp));\n\tif (dcb) {\n\t\tif (*ver >= 0x20) {\n\t\t\tu32 conn = nvbios_rd32(bios, dcb + 0x00);\n\t\t\toutp->or        = (conn & 0x0f000000) >> 24;\n\t\t\toutp->location  = (conn & 0x00300000) >> 20;\n\t\t\toutp->bus       = (conn & 0x000f0000) >> 16;\n\t\t\toutp->connector = (conn & 0x0000f000) >> 12;\n\t\t\toutp->heads     = (conn & 0x00000f00) >> 8;\n\t\t\toutp->i2c_index = (conn & 0x000000f0) >> 4;\n\t\t\toutp->type      = (conn & 0x0000000f);\n\t\t\toutp->link      = 0;\n\t\t} else {\n\t\t\tdcb = 0x0000;\n\t\t}\n\n\t\tif (*ver >= 0x40) {\n\t\t\tu32 conf = nvbios_rd32(bios, dcb + 0x04);\n\t\t\tswitch (outp->type) {\n\t\t\tcase DCB_OUTPUT_DP:\n\t\t\t\tswitch (conf & 0x00e00000) {\n\t\t\t\tcase 0x00000000:  \n\t\t\t\t\toutp->dpconf.link_bw = 0x06;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x00200000:  \n\t\t\t\t\toutp->dpconf.link_bw = 0x0a;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x00400000:  \n\t\t\t\t\toutp->dpconf.link_bw = 0x14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x00600000:  \n\t\t\t\tdefault:\n\t\t\t\t\toutp->dpconf.link_bw = 0x1e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch ((conf & 0x0f000000) >> 24) {\n\t\t\t\tcase 0xf:\n\t\t\t\tcase 0x4:\n\t\t\t\t\toutp->dpconf.link_nr = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x3:\n\t\t\t\tcase 0x2:\n\t\t\t\t\toutp->dpconf.link_nr = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1:\n\t\t\t\tdefault:\n\t\t\t\t\toutp->dpconf.link_nr = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\n\t\t\tcase DCB_OUTPUT_TMDS:\n\t\t\tcase DCB_OUTPUT_LVDS:\n\t\t\t\toutp->link = (conf & 0x00000030) >> 4;\n\t\t\t\toutp->sorconf.link = outp->link;  \n\t\t\t\toutp->extdev = 0x00;\n\t\t\t\tif (outp->location != 0)\n\t\t\t\t\toutp->extdev = (conf & 0x0000ff00) >> 8;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\toutp->hasht = dcb_outp_hasht(outp);\n\t\toutp->hashm = dcb_outp_hashm(outp);\n\t}\n\treturn dcb;\n}\n\nu16\ndcb_outp_match(struct nvkm_bios *bios, u16 type, u16 mask,\n\t       u8 *ver, u8 *len, struct dcb_output *outp)\n{\n\tu16 dcb, idx = 0;\n\twhile ((dcb = dcb_outp_parse(bios, idx++, ver, len, outp))) {\n\t\tif ((dcb_outp_hasht(outp) & 0x00ff) == (type & 0x00ff)) {\n\t\t\tif ((dcb_outp_hashm(outp) & mask) == mask)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn dcb;\n}\n\nint\ndcb_outp_foreach(struct nvkm_bios *bios, void *data,\n\t\t int (*exec)(struct nvkm_bios *, void *, int, u16))\n{\n\tint ret, idx = -1;\n\tu8  ver, len;\n\tu16 outp;\n\n\twhile ((outp = dcb_outp(bios, ++idx, &ver, &len))) {\n\t\tif (nvbios_rd32(bios, outp) == 0x00000000)\n\t\t\tbreak;  \n\t\tif (nvbios_rd32(bios, outp) == 0xffffffff)\n\t\t\tbreak;  \n\n\t\tif (nvbios_rd08(bios, outp) == DCB_OUTPUT_UNUSED)\n\t\t\tcontinue;\n\t\tif (nvbios_rd08(bios, outp) == DCB_OUTPUT_EOL)\n\t\t\tbreak;\n\n\t\tret = exec(bios, data, idx, outp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}