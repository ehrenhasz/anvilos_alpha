{
  "module_name": "base.c",
  "hash_id": "47c15dce3e9a1bbe462e7f8304eb2aa6e014ec21e1ad15b08fb6911552307941",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/firmware.h>\n#include <subdev/timer.h>\n\nbool\nnvkm_pmu_fan_controlled(struct nvkm_device *device)\n{\n\tstruct nvkm_pmu *pmu = device->pmu;\n\n\t \n\tif (pmu && pmu->func->code.size)\n\t\treturn false;\n\n\t \n\treturn (device->chipset >= 0xc0);\n}\n\nvoid\nnvkm_pmu_pgob(struct nvkm_pmu *pmu, bool enable)\n{\n\tif (pmu && pmu->func->pgob)\n\t\tpmu->func->pgob(pmu, enable);\n}\n\nstatic void\nnvkm_pmu_recv(struct work_struct *work)\n{\n\tstruct nvkm_pmu *pmu = container_of(work, typeof(*pmu), recv.work);\n\treturn pmu->func->recv(pmu);\n}\n\nint\nnvkm_pmu_send(struct nvkm_pmu *pmu, u32 reply[2],\n\t      u32 process, u32 message, u32 data0, u32 data1)\n{\n\tif (!pmu || !pmu->func->send)\n\t\treturn -ENODEV;\n\treturn pmu->func->send(pmu, reply, process, message, data0, data1);\n}\n\nstatic void\nnvkm_pmu_intr(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pmu *pmu = nvkm_pmu(subdev);\n\tif (!pmu->func->intr)\n\t\treturn;\n\tpmu->func->intr(pmu);\n}\n\nstatic int\nnvkm_pmu_fini(struct nvkm_subdev *subdev, bool suspend)\n{\n\tstruct nvkm_pmu *pmu = nvkm_pmu(subdev);\n\n\tif (!subdev->use.enabled)\n\t\treturn 0;\n\n\tif (pmu->func->fini)\n\t\tpmu->func->fini(pmu);\n\n\treturn 0;\n}\n\nstatic int\nnvkm_pmu_init(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pmu *pmu = nvkm_pmu(subdev);\n\n\tif (!pmu->func->init)\n\t\treturn 0;\n\n\treturn pmu->func->init(pmu);\n}\n\nstatic void *\nnvkm_pmu_dtor(struct nvkm_subdev *subdev)\n{\n\tstruct nvkm_pmu *pmu = nvkm_pmu(subdev);\n\tnvkm_falcon_msgq_del(&pmu->msgq);\n\tnvkm_falcon_cmdq_del(&pmu->lpq);\n\tnvkm_falcon_cmdq_del(&pmu->hpq);\n\tnvkm_falcon_qmgr_del(&pmu->qmgr);\n\tnvkm_falcon_dtor(&pmu->falcon);\n\tmutex_destroy(&pmu->send.mutex);\n\treturn nvkm_pmu(subdev);\n}\n\nstatic const struct nvkm_subdev_func\nnvkm_pmu = {\n\t.dtor = nvkm_pmu_dtor,\n\t.init = nvkm_pmu_init,\n\t.fini = nvkm_pmu_fini,\n\t.intr = nvkm_pmu_intr,\n};\n\nint\nnvkm_pmu_ctor(const struct nvkm_pmu_fwif *fwif, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_pmu *pmu)\n{\n\tint ret;\n\n\tnvkm_subdev_ctor(&nvkm_pmu, device, type, inst, &pmu->subdev);\n\n\tmutex_init(&pmu->send.mutex);\n\n\tINIT_WORK(&pmu->recv.work, nvkm_pmu_recv);\n\tinit_waitqueue_head(&pmu->recv.wait);\n\n\tfwif = nvkm_firmware_load(&pmu->subdev, fwif, \"Pmu\", pmu);\n\tif (IS_ERR(fwif))\n\t\treturn PTR_ERR(fwif);\n\n\tpmu->func = fwif->func;\n\n\tret = nvkm_falcon_ctor(pmu->func->flcn, &pmu->subdev, pmu->subdev.name,\n\t\t\t       0x10a000, &pmu->falcon);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((ret = nvkm_falcon_qmgr_new(&pmu->falcon, &pmu->qmgr)) ||\n\t    (ret = nvkm_falcon_cmdq_new(pmu->qmgr, \"hpq\", &pmu->hpq)) ||\n\t    (ret = nvkm_falcon_cmdq_new(pmu->qmgr, \"lpq\", &pmu->lpq)) ||\n\t    (ret = nvkm_falcon_msgq_new(pmu->qmgr, \"msgq\", &pmu->msgq)))\n\t\treturn ret;\n\n\tinit_completion(&pmu->wpr_ready);\n\treturn 0;\n}\n\nint\nnvkm_pmu_new_(const struct nvkm_pmu_fwif *fwif, struct nvkm_device *device,\n\t      enum nvkm_subdev_type type, int inst, struct nvkm_pmu **ppmu)\n{\n\tstruct nvkm_pmu *pmu;\n\tif (!(pmu = *ppmu = kzalloc(sizeof(*pmu), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\treturn nvkm_pmu_ctor(fwif, device, type, inst, *ppmu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}