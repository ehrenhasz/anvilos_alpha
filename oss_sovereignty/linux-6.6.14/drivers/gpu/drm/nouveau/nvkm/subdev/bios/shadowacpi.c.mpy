{
  "module_name": "shadowacpi.c",
  "hash_id": "14f9ba9b135a1da98aac38bacd83e76f51cd3816078141a8a101112fb9394174",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/shadowacpi.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstatic int\nacpi_read_bios(acpi_handle rom_handle, u8 *bios, u32 offset, u32 length)\n{\n#if defined(CONFIG_ACPI) && defined(CONFIG_X86)\n\tacpi_status status;\n\tunion acpi_object rom_arg_elements[2], *obj;\n\tstruct acpi_object_list rom_arg;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\n\n\trom_arg.count = 2;\n\trom_arg.pointer = &rom_arg_elements[0];\n\n\trom_arg_elements[0].type = ACPI_TYPE_INTEGER;\n\trom_arg_elements[0].integer.value = offset;\n\n\trom_arg_elements[1].type = ACPI_TYPE_INTEGER;\n\trom_arg_elements[1].integer.value = length;\n\n\tstatus = acpi_evaluate_object(rom_handle, NULL, &rom_arg, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tpr_info(\"failed to evaluate ROM got %s\\n\",\n\t\t\tacpi_format_exception(status));\n\t\treturn -ENODEV;\n\t}\n\tobj = (union acpi_object *)buffer.pointer;\n\tlength = min(length, obj->buffer.length);\n\tmemcpy(bios+offset, obj->buffer.pointer, length);\n\tkfree(buffer.pointer);\n\treturn length;\n#else\n\treturn -EINVAL;\n#endif\n}\n\n \nstatic u32\nacpi_read_fast(void *data, u32 offset, u32 length, struct nvkm_bios *bios)\n{\n\tu32 limit = (offset + length + 0xfff) & ~0xfff;\n\tu32 start = offset & ~0x00000fff;\n\tu32 fetch = limit - start;\n\n\tif (nvbios_extend(bios, limit) >= 0) {\n\t\tint ret = acpi_read_bios(data, bios->data, start, fetch);\n\t\tif (ret == fetch)\n\t\t\treturn fetch;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32\nacpi_read_slow(void *data, u32 offset, u32 length, struct nvkm_bios *bios)\n{\n\tu32 limit = (offset + length + 0xfff) & ~0xfff;\n\tu32 start = offset & ~0xfff;\n\tu32 fetch = 0;\n\n\tif (nvbios_extend(bios, limit) >= 0) {\n\t\twhile (start + fetch < limit) {\n\t\t\tint ret = acpi_read_bios(data, bios->data,\n\t\t\t\t\t\t start + fetch, 0x1000);\n\t\t\tif (ret != 0x1000)\n\t\t\t\tbreak;\n\t\t\tfetch += 0x1000;\n\t\t}\n\t}\n\n\treturn fetch;\n}\n\nstatic void *\nacpi_init(struct nvkm_bios *bios, const char *name)\n{\n#if defined(CONFIG_ACPI) && defined(CONFIG_X86)\n\tacpi_status status;\n\tacpi_handle dhandle, rom_handle;\n\n\tdhandle = ACPI_HANDLE(bios->subdev.device->dev);\n\tif (!dhandle)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tstatus = acpi_get_handle(dhandle, \"_ROM\", &rom_handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn rom_handle;\n#else\n\treturn ERR_PTR(-ENODEV);\n#endif\n}\n\nconst struct nvbios_source\nnvbios_acpi_fast = {\n\t.name = \"ACPI\",\n\t.init = acpi_init,\n\t.read = acpi_read_fast,\n\t.rw = false,\n\t.require_checksum = true,\n};\n\nconst struct nvbios_source\nnvbios_acpi_slow = {\n\t.name = \"ACPI\",\n\t.init = acpi_init,\n\t.read = acpi_read_slow,\n\t.rw = false,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}