{
  "module_name": "gk104.c",
  "hash_id": "d728f941ee699c44dbbbe68cdcb45f708e4e4a9b3d79151fb2e9fc86342aa0ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/therm/gk104.c",
  "human_readable_source": " \n#include <core/device.h>\n\n#include \"priv.h\"\n#include \"gk104.h\"\n\nvoid\ngk104_clkgate_enable(struct nvkm_therm *base)\n{\n\tstruct gk104_therm *therm = gk104_therm(base);\n\tstruct nvkm_device *dev = therm->base.subdev.device;\n\tconst struct gk104_clkgate_engine_info *order = therm->clkgate_order;\n\tint i;\n\n\t \n\tfor (i = 0; order[i].type != NVKM_SUBDEV_NR; i++) {\n\t\tif (!nvkm_device_subdev(dev, order[i].type, order[i].inst))\n\t\t\tcontinue;\n\n\t\tnvkm_mask(dev, 0x20200 + order[i].offset, 0xff00, 0x4500);\n\t}\n\n\t \n\tnvkm_wr32(dev, 0x020288, therm->idle_filter->fecs);\n\tnvkm_wr32(dev, 0x02028c, therm->idle_filter->hubmmu);\n\n\t \n\tfor (i = 0; order[i].type != NVKM_SUBDEV_NR; i++) {\n\t\tif (!nvkm_device_subdev(dev, order[i].type, order[i].inst))\n\t\t\tcontinue;\n\n\t\tnvkm_mask(dev, 0x20200 + order[i].offset, 0x00ff, 0x0045);\n\t}\n}\n\nvoid\ngk104_clkgate_fini(struct nvkm_therm *base, bool suspend)\n{\n\tstruct gk104_therm *therm = gk104_therm(base);\n\tstruct nvkm_device *dev = therm->base.subdev.device;\n\tconst struct gk104_clkgate_engine_info *order = therm->clkgate_order;\n\tint i;\n\n\t \n\tfor (i = 0; order[i].type != NVKM_SUBDEV_NR; i++) {\n\t\tif (!nvkm_device_subdev(dev, order[i].type, order[i].inst))\n\t\t\tcontinue;\n\n\t\tnvkm_mask(dev, 0x20200 + order[i].offset, 0xff, 0x54);\n\t}\n}\n\nconst struct gk104_clkgate_engine_info gk104_clkgate_engine_info[] = {\n\t{ NVKM_ENGINE_GR,     0, 0x00 },\n\t{ NVKM_ENGINE_MSPDEC, 0, 0x04 },\n\t{ NVKM_ENGINE_MSPPP,  0, 0x08 },\n\t{ NVKM_ENGINE_MSVLD,  0, 0x0c },\n\t{ NVKM_ENGINE_CE,     0, 0x10 },\n\t{ NVKM_ENGINE_CE,     1, 0x14 },\n\t{ NVKM_ENGINE_MSENC,  0, 0x18 },\n\t{ NVKM_ENGINE_CE,     2, 0x1c },\n\t{ NVKM_SUBDEV_NR },\n};\n\nconst struct gf100_idle_filter gk104_idle_filter = {\n\t.fecs = 0x00001000,\n\t.hubmmu = 0x00001000,\n};\n\nstatic const struct nvkm_therm_func\ngk104_therm_func = {\n\t.init = gf119_therm_init,\n\t.fini = g84_therm_fini,\n\t.pwm_ctrl = gf119_fan_pwm_ctrl,\n\t.pwm_get = gf119_fan_pwm_get,\n\t.pwm_set = gf119_fan_pwm_set,\n\t.pwm_clock = gf119_fan_pwm_clock,\n\t.temp_get = g84_temp_get,\n\t.fan_sense = gt215_therm_fan_sense,\n\t.program_alarms = nvkm_therm_program_alarms_polling,\n\t.clkgate_init = gf100_clkgate_init,\n\t.clkgate_enable = gk104_clkgate_enable,\n\t.clkgate_fini = gk104_clkgate_fini,\n};\n\nstatic int\ngk104_therm_new_(const struct nvkm_therm_func *func, struct nvkm_device *device,\n\t\t enum nvkm_subdev_type type, int inst,\n\t\t const struct gk104_clkgate_engine_info *clkgate_order,\n\t\t const struct gf100_idle_filter *idle_filter,\n\t\t struct nvkm_therm **ptherm)\n{\n\tstruct gk104_therm *therm = kzalloc(sizeof(*therm), GFP_KERNEL);\n\n\tif (!therm)\n\t\treturn -ENOMEM;\n\n\tnvkm_therm_ctor(&therm->base, device, type, inst, func);\n\t*ptherm = &therm->base;\n\ttherm->clkgate_order = clkgate_order;\n\ttherm->idle_filter = idle_filter;\n\treturn 0;\n}\n\nint\ngk104_therm_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst, struct nvkm_therm **ptherm)\n{\n\treturn gk104_therm_new_(&gk104_therm_func, device, type, inst,\n\t\t\t\tgk104_clkgate_engine_info, &gk104_idle_filter,\n\t\t\t\tptherm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}