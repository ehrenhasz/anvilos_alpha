{
  "module_name": "gf100.c",
  "hash_id": "9df366e836b3fa02ea439ec9766ed6a4cbcab29908e67fb2dbf6f9046f354f6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/ltc/gf100.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n#include <subdev/fb.h>\n#include <subdev/timer.h>\n\nvoid\ngf100_ltc_cbc_clear(struct nvkm_ltc *ltc, u32 start, u32 limit)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tnvkm_wr32(device, 0x17e8cc, start);\n\tnvkm_wr32(device, 0x17e8d0, limit);\n\tnvkm_wr32(device, 0x17e8c8, 0x00000004);\n}\n\nvoid\ngf100_ltc_cbc_wait(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tint c, s;\n\tfor (c = 0; c < ltc->ltc_nr; c++) {\n\t\tfor (s = 0; s < ltc->lts_nr; s++) {\n\t\t\tconst u32 addr = 0x1410c8 + (c * 0x2000) + (s * 0x400);\n\t\t\tnvkm_msec(device, 2000,\n\t\t\t\tif (!nvkm_rd32(device, addr))\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t}\n\t}\n}\n\nvoid\ngf100_ltc_zbc_clear_color(struct nvkm_ltc *ltc, int i, const u32 color[4])\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tnvkm_mask(device, 0x17ea44, 0x0000000f, i);\n\tnvkm_wr32(device, 0x17ea48, color[0]);\n\tnvkm_wr32(device, 0x17ea4c, color[1]);\n\tnvkm_wr32(device, 0x17ea50, color[2]);\n\tnvkm_wr32(device, 0x17ea54, color[3]);\n}\n\nvoid\ngf100_ltc_zbc_clear_depth(struct nvkm_ltc *ltc, int i, const u32 depth)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tnvkm_mask(device, 0x17ea44, 0x0000000f, i);\n\tnvkm_wr32(device, 0x17ea58, depth);\n}\n\nconst struct nvkm_bitfield\ngf100_ltc_lts_intr_name[] = {\n\t{ 0x00000001, \"IDLE_ERROR_IQ\" },\n\t{ 0x00000002, \"IDLE_ERROR_CBC\" },\n\t{ 0x00000004, \"IDLE_ERROR_TSTG\" },\n\t{ 0x00000008, \"IDLE_ERROR_DSTG\" },\n\t{ 0x00000010, \"EVICTED_CB\" },\n\t{ 0x00000020, \"ILLEGAL_COMPSTAT\" },\n\t{ 0x00000040, \"BLOCKLINEAR_CB\" },\n\t{ 0x00000100, \"ECC_SEC_ERROR\" },\n\t{ 0x00000200, \"ECC_DED_ERROR\" },\n\t{ 0x00000400, \"DEBUG\" },\n\t{ 0x00000800, \"ATOMIC_TO_Z\" },\n\t{ 0x00001000, \"ILLEGAL_ATOMIC\" },\n\t{ 0x00002000, \"BLKACTIVITY_ERR\" },\n\t{}\n};\n\nstatic void\ngf100_ltc_lts_intr(struct nvkm_ltc *ltc, int c, int s)\n{\n\tstruct nvkm_subdev *subdev = &ltc->subdev;\n\tstruct nvkm_device *device = subdev->device;\n\tu32 base = 0x141000 + (c * 0x2000) + (s * 0x400);\n\tu32 intr = nvkm_rd32(device, base + 0x020);\n\tu32 stat = intr & 0x0000ffff;\n\tchar msg[128];\n\n\tif (stat) {\n\t\tnvkm_snprintbf(msg, sizeof(msg), gf100_ltc_lts_intr_name, stat);\n\t\tnvkm_error(subdev, \"LTC%d_LTS%d: %08x [%s]\\n\", c, s, stat, msg);\n\t}\n\n\tnvkm_wr32(device, base + 0x020, intr);\n}\n\nvoid\ngf100_ltc_intr(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tu32 mask;\n\n\tmask = nvkm_rd32(device, 0x00017c);\n\twhile (mask) {\n\t\tu32 s, c = __ffs(mask);\n\t\tfor (s = 0; s < ltc->lts_nr; s++)\n\t\t\tgf100_ltc_lts_intr(ltc, c, s);\n\t\tmask &= ~(1 << c);\n\t}\n}\n\nvoid\ngf100_ltc_invalidate(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\ts64 taken;\n\n\tnvkm_wr32(device, 0x70004, 0x00000001);\n\ttaken = nvkm_wait_msec(device, 2000, 0x70004, 0x00000003, 0x00000000);\n\n\tif (taken > 0)\n\t\tnvkm_debug(&ltc->subdev, \"LTC invalidate took %lld ns\\n\", taken);\n}\n\nvoid\ngf100_ltc_flush(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\ts64 taken;\n\n\tnvkm_wr32(device, 0x70010, 0x00000001);\n\ttaken = nvkm_wait_msec(device, 2000, 0x70010, 0x00000003, 0x00000000);\n\n\tif (taken > 0)\n\t\tnvkm_debug(&ltc->subdev, \"LTC flush took %lld ns\\n\", taken);\n}\n\n \nint\ngf100_ltc_oneinit_tag_ram(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tstruct nvkm_fb *fb = device->fb;\n\tstruct nvkm_ram *ram = fb->ram;\n\tu32 bits = (nvkm_rd32(device, 0x100c80) & 0x00001000) ? 16 : 17;\n\tu32 tag_size, tag_margin, tag_align;\n\tint ret;\n\n\t \n\tif (!ram) {\n\t\tltc->num_tags = 0;\n\t\tgoto mm_init;\n\t}\n\n\t \n\tltc->num_tags = (ram->size >> 17) / 4;\n\tif (ltc->num_tags > (1 << bits))\n\t\tltc->num_tags = 1 << bits;  \n\tltc->num_tags = (ltc->num_tags + 63) & ~63;  \n\n\ttag_align = ltc->ltc_nr * 0x800;\n\ttag_margin = (tag_align < 0x6000) ? 0x6000 : tag_align;\n\n\t \n\t \n\t \n\ttag_size  = (ltc->num_tags / 64) * 0x6000 + tag_margin;\n\ttag_size += tag_align;\n\n\tret = nvkm_ram_get(device, NVKM_RAM_MM_NORMAL, 0x01, 12, tag_size,\n\t\t\t   true, true, &ltc->tag_ram);\n\tif (ret) {\n\t\tltc->num_tags = 0;\n\t} else {\n\t\tu64 tag_base = nvkm_memory_addr(ltc->tag_ram) + tag_margin;\n\n\t\ttag_base += tag_align - 1;\n\t\tdo_div(tag_base, tag_align);\n\n\t\tltc->tag_base = tag_base;\n\t}\n\nmm_init:\n\tnvkm_mm_fini(&fb->tags.mm);\n\treturn nvkm_mm_init(&fb->tags.mm, 0, 0, ltc->num_tags, 1);\n}\n\nint\ngf100_ltc_oneinit(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tconst u32 parts = nvkm_rd32(device, 0x022438);\n\tconst u32  mask = nvkm_rd32(device, 0x022554);\n\tconst u32 slice = nvkm_rd32(device, 0x17e8dc) >> 28;\n\tint i;\n\n\tfor (i = 0; i < parts; i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tltc->ltc_nr++;\n\t}\n\tltc->lts_nr = slice;\n\n\treturn gf100_ltc_oneinit_tag_ram(ltc);\n}\n\nstatic void\ngf100_ltc_init(struct nvkm_ltc *ltc)\n{\n\tstruct nvkm_device *device = ltc->subdev.device;\n\tu32 lpg128 = !(nvkm_rd32(device, 0x100c80) & 0x00000001);\n\n\tnvkm_mask(device, 0x17e820, 0x00100000, 0x00000000);  \n\tnvkm_wr32(device, 0x17e8d8, ltc->ltc_nr);\n\tnvkm_wr32(device, 0x17e8d4, ltc->tag_base);\n\tnvkm_mask(device, 0x17e8c0, 0x00000002, lpg128 ? 0x00000002 : 0x00000000);\n}\n\nstatic const struct nvkm_ltc_func\ngf100_ltc = {\n\t.oneinit = gf100_ltc_oneinit,\n\t.init = gf100_ltc_init,\n\t.intr = gf100_ltc_intr,\n\t.cbc_clear = gf100_ltc_cbc_clear,\n\t.cbc_wait = gf100_ltc_cbc_wait,\n\t.zbc_color = 16,\n\t.zbc_depth = 16,\n\t.zbc_clear_color = gf100_ltc_zbc_clear_color,\n\t.zbc_clear_depth = gf100_ltc_zbc_clear_depth,\n\t.invalidate = gf100_ltc_invalidate,\n\t.flush = gf100_ltc_flush,\n};\n\nint\ngf100_ltc_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t      struct nvkm_ltc **pltc)\n{\n\treturn nvkm_ltc_new_(&gf100_ltc, device, type, inst, pltc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}