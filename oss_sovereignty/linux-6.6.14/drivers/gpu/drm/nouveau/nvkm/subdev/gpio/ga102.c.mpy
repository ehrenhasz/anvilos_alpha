{
  "module_name": "ga102.c",
  "hash_id": "6805f084bc5ff2e9f3462a1886f34db67271058d6521e248720a6a0b73a75ad2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/gpio/ga102.c",
  "human_readable_source": " \n#include \"priv.h\"\n\nstatic void\nga102_gpio_reset(struct nvkm_gpio *gpio, u8 match)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tstruct nvkm_bios *bios = device->bios;\n\tu8 ver, len;\n\tu16 entry;\n\tint ent = -1;\n\n\twhile ((entry = dcb_gpio_entry(bios, 0, ++ent, &ver, &len))) {\n\t\tu32 data = nvbios_rd32(bios, entry);\n\t\tu8  line =   (data & 0x0000003f);\n\t\tu8  defs = !!(data & 0x00000080);\n\t\tu8  func =   (data & 0x0000ff00) >> 8;\n\t\tu8  unk0 =   (data & 0x00ff0000) >> 16;\n\t\tu8  unk1 =   (data & 0x1f000000) >> 24;\n\n\t\tif ( func  == DCB_GPIO_UNUSED ||\n\t\t    (match != DCB_GPIO_UNUSED && match != func))\n\t\t\tcontinue;\n\n\t\tnvkm_gpio_set(gpio, 0, func, line, defs);\n\n\t\tnvkm_mask(device, 0x021200 + (line * 4), 0xff, unk0);\n\t\tif (unk1--)\n\t\t\tnvkm_mask(device, 0x00d740 + (unk1 * 4), 0xff, line);\n\t}\n}\n\nstatic int\nga102_gpio_drive(struct nvkm_gpio *gpio, int line, int dir, int out)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 data = ((dir ^ 1) << 13) | (out << 12);\n\tnvkm_mask(device, 0x021200 + (line * 4), 0x00003000, data);\n\tnvkm_mask(device, 0x00d604, 0x00000001, 0x00000001);  \n\treturn 0;\n}\n\nstatic int\nga102_gpio_sense(struct nvkm_gpio *gpio, int line)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\treturn !!(nvkm_rd32(device, 0x021200 + (line * 4)) & 0x00004000);\n}\n\nstatic void\nga102_gpio_intr_stat(struct nvkm_gpio *gpio, u32 *hi, u32 *lo)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 intr0 = nvkm_rd32(device, 0x021640);\n\tu32 intr1 = nvkm_rd32(device, 0x02164c);\n\tu32 stat0 = nvkm_rd32(device, 0x021648) & intr0;\n\tu32 stat1 = nvkm_rd32(device, 0x021654) & intr1;\n\t*lo = (stat1 & 0xffff0000) | (stat0 >> 16);\n\t*hi = (stat1 << 16) | (stat0 & 0x0000ffff);\n\tnvkm_wr32(device, 0x021640, intr0);\n\tnvkm_wr32(device, 0x02164c, intr1);\n}\n\nstatic void\nga102_gpio_intr_mask(struct nvkm_gpio *gpio, u32 type, u32 mask, u32 data)\n{\n\tstruct nvkm_device *device = gpio->subdev.device;\n\tu32 inte0 = nvkm_rd32(device, 0x021648);\n\tu32 inte1 = nvkm_rd32(device, 0x021654);\n\tif (type & NVKM_GPIO_LO)\n\t\tinte0 = (inte0 & ~(mask << 16)) | (data << 16);\n\tif (type & NVKM_GPIO_HI)\n\t\tinte0 = (inte0 & ~(mask & 0xffff)) | (data & 0xffff);\n\tmask >>= 16;\n\tdata >>= 16;\n\tif (type & NVKM_GPIO_LO)\n\t\tinte1 = (inte1 & ~(mask << 16)) | (data << 16);\n\tif (type & NVKM_GPIO_HI)\n\t\tinte1 = (inte1 & ~mask) | data;\n\tnvkm_wr32(device, 0x021648, inte0);\n\tnvkm_wr32(device, 0x021654, inte1);\n}\n\nstatic const struct nvkm_gpio_func\nga102_gpio = {\n\t.lines = 32,\n\t.intr_stat = ga102_gpio_intr_stat,\n\t.intr_mask = ga102_gpio_intr_mask,\n\t.drive = ga102_gpio_drive,\n\t.sense = ga102_gpio_sense,\n\t.reset = ga102_gpio_reset,\n};\n\nint\nga102_gpio_new(struct nvkm_device *device, enum nvkm_subdev_type type, int inst,\n\t       struct nvkm_gpio **pgpio)\n{\n\treturn nvkm_gpio_new_(&ga102_gpio, device, type, inst, pgpio);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}