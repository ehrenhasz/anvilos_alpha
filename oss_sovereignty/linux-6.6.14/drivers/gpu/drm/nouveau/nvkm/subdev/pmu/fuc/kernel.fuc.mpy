{
  "module_name": "kernel.fuc",
  "hash_id": "18a2ece7443ec1444261f1d5246ff7b7861ad2aa318ecb1a632481fdd856b103",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/fuc/kernel.fuc",
  "human_readable_source": "/*\n * Copyright 2013 Red Hat Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: Ben Skeggs\n */\n\n/******************************************************************************\n * kernel data segment\n *****************************************************************************/\n#ifdef INCLUDE_PROC\nproc_kern:\nprocess(PROC_KERN, 0, 0)\nproc_list_head:\n#endif\n\n#ifdef INCLUDE_DATA\nproc_list_tail:\ntime_prev: .b32 0\ntime_next: .b32 0\n#endif\n\n/******************************************************************************\n * kernel code segment\n *****************************************************************************/\n#ifdef INCLUDE_CODE\n\tbra #init\n\n// read nv register\n//\n// $r15 - current\n// $r14 - addr\n// $r13 - data (return)\n// $r0  - zero\nrd32:\n\tnv_iowr(NV_PPWR_MMIO_ADDR, $r14)\n\timm32($r13, NV_PPWR_MMIO_CTRL_OP_RD | NV_PPWR_MMIO_CTRL_TRIGGER)\n\tnv_iowr(NV_PPWR_MMIO_CTRL, $r13)\n\trd32_wait:\n\t\tnv_iord($r13, NV_PPWR_MMIO_CTRL)\n\t\tand $r13 NV_PPWR_MMIO_CTRL_STATUS\n\t\tbra nz #rd32_wait\n\tnv_iord($r13, NV_PPWR_MMIO_DATA)\n\tret\n\n// write nv register\n//\n// $r15 - current\n// $r14 - addr\n// $r13 - data\n// $r0  - zero\nwr32:\n\tnv_iowr(NV_PPWR_MMIO_ADDR, $r14)\n\tnv_iowr(NV_PPWR_MMIO_DATA, $r13)\n\timm32($r13, NV_PPWR_MMIO_CTRL_OP_WR | NV_PPWR_MMIO_CTRL_MASK_B32_0 | NV_PPWR_MMIO_CTRL_TRIGGER)\n\n#ifdef NVKM_FALCON_MMIO_TRAP\n\tpush $r13\n\tmov $r13 NV_PPWR_INTR_TRIGGER_USER1\n\tnv_iowr(NV_PPWR_INTR_TRIGGER, $r13)\n\twr32_host:\n\t\tnv_iord($r13, NV_PPWR_INTR)\n\t\tand $r13 NV_PPWR_INTR_USER1\n\t\tbra nz #wr32_host\n\tpop $r13\n#endif\n\n\tnv_iowr(NV_PPWR_MMIO_CTRL, $r13)\n\twr32_wait:\n\t\tnv_iord($r13, NV_PPWR_MMIO_CTRL)\n\t\tand $r13 NV_PPWR_MMIO_CTRL_STATUS\n\t\tbra nz #wr32_wait\n\tret\n\n// busy-wait for a period of time\n//\n// $r15 - current\n// $r14 - ns\n// $r0  - zero\nnsec:\n\tpush $r9\n\tpush $r8\n\tnv_iord($r8, NV_PPWR_TIMER_LOW)\n\tnsec_loop:\n\t\tnv_iord($r9, NV_PPWR_TIMER_LOW)\n\t\tsub b32 $r9 $r8\n\t\tcmp b32 $r9 $r14\n\t\tbra l #nsec_loop\n\tpop $r8\n\tpop $r9\n\tret\n\n// busy-wait for a period of time\n//\n// $r15 - current\n// $r14 - addr\n// $r13 - mask\n// $r12 - data\n// $r11 - timeout (ns)\n// $r0  - zero\nwait:\n\tpush $r9\n\tpush $r8\n\tnv_iord($r8, NV_PPWR_TIMER_LOW)\n\twait_loop:\n\t\tnv_rd32($r10, $r14)\n\t\tand $r10 $r13\n\t\tcmp b32 $r10 $r12\n\t\tbra e #wait_done\n\t\tnv_iord($r9, NV_PPWR_TIMER_LOW)\n\t\tsub b32 $r9 $r8\n\t\tcmp b32 $r9 $r11\n\t\tbra l #wait_loop\n\twait_done:\n\tpop $r8\n\tpop $r9\n\tret\n\n// $r15 - current (kern)\n// $r14 - process\n// $r8  - NV_PPWR_INTR\nintr_watchdog:\n\t// read process' timer status, skip if not enabled\n\tld b32 $r9 D[$r14 + #proc_time]\n\tcmp b32 $r9 0\n\tbra z #intr_watchdog_next_proc\n\n\t// subtract last timer's value from process' timer,\n\t// if it's <= 0 then the timer has expired\n\tld b32 $r10 D[$r0 + #time_prev]\n\tsub b32 $r9 $r10\n\tbra g #intr_watchdog_next_time\n\t\tmov $r13 KMSG_ALARM\n\t\tcall(send_proc)\n\t\tclear b32 $r9\n\t\tbra #intr_watchdog_next_proc\n\n\t// otherwise, update the next timer's value if this\n\t// process' timer is the soonest\n\tintr_watchdog_next_time:\n\t\t// ... or if there's no next timer yet\n\t\tld b32 $r10 D[$r0 + #time_next]\n\t\tcmp b32 $r10 0\n\t\tbra z #intr_watchdog_next_time_set\n\n\t\tcmp b32 $r9 $r10\n\t\tbra g #intr_watchdog_next_proc\n\t\tintr_watchdog_next_time_set:\n\t\tst b32 D[$r0 + #time_next] $r9\n\n\t// update process' timer status, and advance\n\tintr_watchdog_next_proc:\n\tst b32 D[$r14 + #proc_time] $r9\n\tadd b32 $r14 #proc_size\n\tcmp b32 $r14 #proc_list_tail\n\tbra ne #intr_watchdog\n\tret\n\nintr:\n\tpush $r0\n\tclear b32 $r0\n\tpush $r8\n\tpush $r9\n\tpush $r10\n\tpush $r11\n\tpush $r12\n\tpush $r13\n\tpush $r14\n\tpush $r15\n\tmov $r15 #proc_kern\n\tmov $r8 $flags\n\tpush $r8\n\n\tnv_iord($r8, NV_PPWR_DSCRATCH(0))\n\tadd b32 $r8 1\n\tnv_iowr(NV_PPWR_DSCRATCH(0), $r8)\n\n\tnv_iord($r8, NV_PPWR_INTR)\n\tand $r9 $r8 NV_PPWR_INTR_WATCHDOG\n\tbra z #intr_skip_watchdog\n\t\tst b32 D[$r0 + #time_next] $r0\n\t\tmov $r14 #proc_list_head\n\t\tcall(intr_watchdog)\n\t\tld b32 $r9 D[$r0 + #time_next]\n\t\tcmp b32 $r9 0\n\t\tbra z #intr_skip_watchdog\n\t\t\tnv_iowr(NV_PPWR_WATCHDOG_TIME, $r9)\n\t\t\tst b32 D[$r0 + #time_prev] $r9\n\n\tintr_skip_watchdog:\n\tand $r9 $r8 NV_PPWR_INTR_SUBINTR\n\tbra z #intr_skip_subintr\n\t\tnv_iord($r9, NV_PPWR_SUBINTR)\n\t\tand $r10 $r9 NV_PPWR_SUBINTR_FIFO\n\t\tbra z #intr_subintr_skip_fifo\n\t\t\tnv_iord($r12, NV_PPWR_FIFO_INTR)\n\t\t\tpush $r12\n\t\t\timm32($r14, PROC_HOST)\n\t\t\tmov $r13 KMSG_FIFO\n\t\t\tcall(send)\n\t\t\tpop $r12\n\t\t\tnv_iowr(NV_PPWR_FIFO_INTR, $r12)\n\t\tintr_subintr_skip_fifo:\n\t\tnv_iowr(NV_PPWR_SUBINTR, $r9)\n\n\tintr_skip_subintr:\n\tmov $r9 (NV_PPWR_INTR_USER0 | NV_PPWR_INTR_USER1 | NV_PPWR_INTR_PAUSE)\n\tnot b32 $r9\n\tand $r8 $r9\n\tnv_iowr(NV_PPWR_INTR_ACK, $r8)\n\n\tpop $r8\n\tmov $flags $r8\n\tpop $r15\n\tpop $r14\n\tpop $r13\n\tpop $r12\n\tpop $r11\n\tpop $r10\n\tpop $r9\n\tpop $r8\n\tpop $r0\n\tbclr $flags $p0\n\tiret\n\n// calculate the number of ticks in the specified nanoseconds delay\n//\n// $r15 - current\n// $r14 - ns\n// $r14 - ticks (return)\n// $r0  - zero\nticks_from_ns:\n\tpush $r12\n\tpush $r11\n\n\t/* try not losing precision (multiply then divide) */\n\timm32($r13, HW_TICKS_PER_US)\n\tcall(mulu32_32_64)\n\n\t/* use an immeditate, it's ok because HW_TICKS_PER_US < 16 bits */\n\tdiv $r12 $r12 1000\n\n\t/* check if there wasn't any overflow */\n\tcmpu b32 $r11 0\n\tbra e #ticks_from_ns_quit\n\n\t/* let's divide then multiply, too bad for the precision! */\n\tdiv $r14 $r14 1000\n\timm32($r13, HW_TICKS_PER_US)\n\tcall(mulu32_32_64)\n\n\t/* this cannot overflow as long as HW_TICKS_PER_US < 1000 */\n\nticks_from_ns_quit:\n\tmov b32 $r14 $r12\n\tpop $r11\n\tpop $r12\n\tret\n\n// calculate the number of ticks in the specified microsecond delay\n//\n// $r15 - current\n// $r14 - us\n// $r14 - ticks (return)\n// $r0  - zero\nticks_from_us:\n\tpush $r12\n\tpush $r11\n\n\t/* simply multiply $us by HW_TICKS_PER_US */\n\timm32($r13, HW_TICKS_PER_US)\n\tcall(mulu32_32_64)\n\tmov b32 $r14 $r12\n\n\t/* check if there wasn't any overflow */\n\tcmpu b32 $r11 0\n\tbra e #ticks_from_us_quit\n\n\t/* Overflow! */\n\tclear b32 $r14\n\nticks_from_us_quit:\n\tpop $r11\n\tpop $r12\n\tret\n\n// calculate the number of ticks in the specified microsecond delay\n//\n// $r15 - current\n// $r14 - ticks\n// $r14 - us (return)\n// $r0  - zero\nticks_to_us:\n\t/* simply divide $ticks by HW_TICKS_PER_US */\n\timm32($r13, HW_TICKS_PER_US)\n\tdiv $r14 $r14 $r13\n\n\tret\n\n// request the current process be sent a message after a timeout expires\n//\n// $r15 - current\n// $r14 - ticks (make sure it is < 2^31 to avoid any possible overflow)\n// $r0  - zero\ntimer:\n\tpush $r9\n\tpush $r8\n\n\t// interrupts off to prevent racing with timer isr\n\tbclr $flags ie0\n\n\t// if current process already has a timer set, bail\n\tld b32 $r8 D[$r15 + #proc_time]\n\tcmp b32 $r8 0\n\tbra g #timer_done\n\n\t// halt watchdog timer temporarily\n\tclear b32 $r8\n\tnv_iowr(NV_PPWR_WATCHDOG_ENABLE, $r8)\n\n\t// find out how much time elapsed since the last update\n\t// of the watchdog and add this time to the wanted ticks\n\tnv_iord($r8, NV_PPWR_WATCHDOG_TIME)\n\tld b32 $r9 D[$r0 + #time_prev]\n\tsub b32 $r9 $r8\n\tadd b32 $r14 $r9\n\tst b32 D[$r15 + #proc_time] $r14\n\n\t// check for a pending interrupt.  if there's one already\n\t// pending, we can just bail since the timer isr will\n\t// queue the next soonest right after it's done\n\tnv_iord($r8, NV_PPWR_INTR)\n\tand $r8 NV_PPWR_INTR_WATCHDOG\n\tbra nz #timer_enable\n\n\t// update the watchdog if this timer should expire first,\n\t// or if there's no timeout already set\n\tnv_iord($r8, NV_PPWR_WATCHDOG_TIME)\n\tcmp b32 $r14 $r0\n\tbra e #timer_reset\n\tcmp b32 $r14 $r8\n\tbra g #timer_enable\n\t\ttimer_reset:\n\t\tnv_iowr(NV_PPWR_WATCHDOG_TIME, $r14)\n\t\tst b32 D[$r0 + #time_prev] $r14\n\n\t// re-enable the watchdog timer\n\ttimer_enable:\n\tmov $r8 1\n\tnv_iowr(NV_PPWR_WATCHDOG_ENABLE, $r8)\n\n\t// interrupts back on\n\ttimer_done:\n\tbset $flags ie0\n\n\tpop $r8\n\tpop $r9\n\tret\n\n// send message to another process\n//\n// $r15 - current\n// $r14 - process\n// $r13 - message\n// $r12 - message data 0\n// $r11 - message data 1\n// $r0  - zero\nsend_proc:\n\tpush $r8\n\tpush $r9\n\t// check for space in queue\n\tld b32 $r8 D[$r14 + #proc_qget]\n\tld b32 $r9 D[$r14 + #proc_qput]\n\txor $r8 #proc_qmaskb\n\tcmp b32 $r8 $r9\n\tbra e #send_done\n\n\t// enqueue message\n\tand $r8 $r9 #proc_qmaskp\n\tshl b32 $r8 $r8 #proc_qlen\n\tadd b32 $r8 #proc_queue\n\tadd b32 $r8 $r14\n\n\tld b32 $r10 D[$r15 + #proc_id]\n\tst b32 D[$r8 + #msg_process] $r10\n\tst b32 D[$r8 + #msg_message] $r13\n\tst b32 D[$r8 + #msg_data0] $r12\n\tst b32 D[$r8 + #msg_data1] $r11\n\n\t// increment PUT\n\tadd b32 $r9 1\n\tand $r9 #proc_qmaskf\n\tst b32 D[$r14 + #proc_qput] $r9\n\tbset $flags $p2\n\tsend_done:\n\tpop $r9\n\tpop $r8\n\tret\n\n// lookup process structure by its name\n//\n// $r15 - current\n// $r14 - process name\n// $r0  - zero\n//\n// $r14 - process\n// $p1  - success\nfind:\n\tpush $r8\n\tmov $r8 #proc_list_head\n\tbset $flags $p1\n\tfind_loop:\n\t\tld b32 $r10 D[$r8 + #proc_id]\n\t\tcmp b32 $r10 $r14\n\t\tbra e #find_done\n\t\tadd b32 $r8 #proc_size\n\t\tcmp b32 $r8 #proc_list_tail\n\t\tbra ne #find_loop\n\t\tbclr $flags $p1\n\tfind_done:\n\tmov b32 $r14 $r8\n\tpop $r8\n\tret\n\n// send message to another process\n//\n// $r15 - current\n// $r14 - process id\n// $r13 - message\n// $r12 - message data 0\n// $r11 - message data 1\n// $r0  - zero\nsend:\n\tcall(find)\n\tbra $p1 #send_proc\n\tret\n\n// process single message for a given process\n//\n// $r15 - current\n// $r14 - process\n// $r0  - zero\nrecv:\n\tpush $r9\n\tpush $r8\n\n\tld b32 $r8 D[$r14 + #proc_qget]\n\tld b32 $r9 D[$r14 + #proc_qput]\n\tbclr $flags $p1\n\tcmp b32 $r8 $r9\n\tbra e #recv_done\n\t\t// dequeue message\n\t\tand $r9 $r8 #proc_qmaskp\n\t\tadd b32 $r8 1\n\t\tand $r8 #proc_qmaskf\n\t\tst b32 D[$r14 + #proc_qget] $r8\n\t\tld b32 $r10 D[$r14 + #proc_recv]\n\n\t\tpush $r15\n\t\tmov $r15 $flags\n\t\tpush $r15\n\t\tmov b32 $r15 $r14\n\n\t\tshl b32 $r9 $r9 #proc_qlen\n\t\tadd b32 $r14 $r9\n\t\tadd b32 $r14 #proc_queue\n\t\tld b32 $r11 D[$r14 + #msg_data1]\n\t\tld b32 $r12 D[$r14 + #msg_data0]\n\t\tld b32 $r13 D[$r14 + #msg_message]\n\t\tld b32 $r14 D[$r14 + #msg_process]\n\n\t\t// process it\n\t\tcall $r10\n\t\tpop $r15\n\t\tmov $flags $r15\n\t\tbset $flags $p1\n\t\tpop $r15\n\trecv_done:\n\tpop $r8\n\tpop $r9\n\tret\n\ninit:\n\t// setup stack\n\tnv_iord($r1, NV_PPWR_CAPS)\n\textr $r1 $r1 9:17\n\tshl b32 $r1 8\n\tmov $sp $r1\n\n#ifdef NVKM_FALCON_MMIO_UAS\n\t// somehow allows the magic \"access mmio via D[]\" stuff that's\n\t// used by the nv_rd32/nv_wr32 macros to work\n\timm32($r1, 0x10 | NV_PPWR_UAS_CONFIG_ENABLE)\n\tnv_iowrs(NV_PPWR_UAS_CONFIG, $r1)\n#endif\n\n\t// route all interrupts except user0/1 and pause to fuc\n\timm32($r1, 0xe0)\n\tnv_iowr(NV_PPWR_INTR_ROUTE, $r1)\n\n\t// enable watchdog and subintr intrs\n\tmov $r1 NV_PPWR_INTR_EN_CLR_MASK\n\tnv_iowr(NV_PPWR_INTR_EN_CLR, $r1)\n\tmov $r1 NV_PPWR_INTR_EN_SET_WATCHDOG\n\tor $r1 NV_PPWR_INTR_EN_SET_SUBINTR\n\tnv_iowr(NV_PPWR_INTR_EN_SET, $r1)\n\n\t// enable interrupts globally\n\timm32($r1, #intr)\n\tand $r1 0xffff\n\tmov $iv0 $r1\n\tbset $flags ie0\n\n\t// enable watchdog timer\n\tmov $r1 1\n\tnv_iowr(NV_PPWR_WATCHDOG_ENABLE, $r1)\n\n\t// bootstrap processes, idle process will be last, and not return\n\tmov $r15 #proc_list_head\n\tinit_proc:\n\t\tld b32 $r1 D[$r15 + #proc_init]\n\t\tcmp b32 $r1 0\n\t\tbra z #init_proc\n\t\tcall $r1\n\t\tadd b32 $r15 #proc_size\n\t\tbra #init_proc\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}