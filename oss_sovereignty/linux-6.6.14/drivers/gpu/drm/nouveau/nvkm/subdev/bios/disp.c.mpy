{
  "module_name": "disp.c",
  "hash_id": "3ae105112a3867cfdffd5cb71bdf271bdf6b9ae4bcf27e66990b2504304324e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/subdev/bios/disp.c",
  "human_readable_source": " \n#include <subdev/bios.h>\n#include <subdev/bios/bit.h>\n#include <subdev/bios/disp.h>\n\nu16\nnvbios_disp_table(struct nvkm_bios *bios,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len, u8 *sub)\n{\n\tstruct bit_entry U;\n\n\tif (!bit_entry(bios, 'U', &U)) {\n\t\tif (U.version == 1) {\n\t\t\tu16 data = nvbios_rd16(bios, U.offset);\n\t\t\tif (data) {\n\t\t\t\t*ver = nvbios_rd08(bios, data + 0x00);\n\t\t\t\tswitch (*ver) {\n\t\t\t\tcase 0x20:\n\t\t\t\tcase 0x21:\n\t\t\t\tcase 0x22:\n\t\t\t\t\t*hdr = nvbios_rd08(bios, data + 0x01);\n\t\t\t\t\t*len = nvbios_rd08(bios, data + 0x02);\n\t\t\t\t\t*cnt = nvbios_rd08(bios, data + 0x03);\n\t\t\t\t\t*sub = nvbios_rd08(bios, data + 0x04);\n\t\t\t\t\treturn data;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0x0000;\n}\n\nu16\nnvbios_disp_entry(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len, u8 *sub)\n{\n\tu8  hdr, cnt;\n\tu16 data = nvbios_disp_table(bios, ver, &hdr, &cnt, len, sub);\n\tif (data && idx < cnt)\n\t\treturn data + hdr + (idx * *len);\n\t*ver = 0x00;\n\treturn 0x0000;\n}\n\nu16\nnvbios_disp_parse(struct nvkm_bios *bios, u8 idx, u8 *ver, u8 *len, u8 *sub,\n\t\t  struct nvbios_disp *info)\n{\n\tu16 data = nvbios_disp_entry(bios, idx, ver, len, sub);\n\tif (data && *len >= 2) {\n\t\tinfo->data = nvbios_rd16(bios, data + 0);\n\t\treturn data;\n\t}\n\treturn 0x0000;\n}\n\nu16\nnvbios_outp_entry(struct nvkm_bios *bios, u8 idx,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tstruct nvbios_disp info;\n\tu16 data = nvbios_disp_parse(bios, idx, ver, len, hdr, &info);\n\tif (data) {\n\t\t*cnt = nvbios_rd08(bios, info.data + 0x05);\n\t\t*len = 0x06;\n\t\tdata = info.data;\n\t}\n\treturn data;\n}\n\nu16\nnvbios_outp_parse(struct nvkm_bios *bios, u8 idx,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len, struct nvbios_outp *info)\n{\n\tu16 data = nvbios_outp_entry(bios, idx, ver, hdr, cnt, len);\n\tif (data && *hdr >= 0x0a) {\n\t\tinfo->type      = nvbios_rd16(bios, data + 0x00);\n\t\tinfo->mask      = nvbios_rd32(bios, data + 0x02);\n\t\tif (*ver <= 0x20)  \n\t\t\tinfo->mask |= 0x00c0;\n\t\tinfo->script[0] = nvbios_rd16(bios, data + 0x06);\n\t\tinfo->script[1] = nvbios_rd16(bios, data + 0x08);\n\t\tinfo->script[2] = 0x0000;\n\t\tif (*hdr >= 0x0c)\n\t\t\tinfo->script[2] = nvbios_rd16(bios, data + 0x0a);\n\t\treturn data;\n\t}\n\treturn 0x0000;\n}\n\nu16\nnvbios_outp_match(struct nvkm_bios *bios, u16 type, u16 mask,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len, struct nvbios_outp *info)\n{\n\tu16 data, idx = 0;\n\twhile ((data = nvbios_outp_parse(bios, idx++, ver, hdr, cnt, len, info)) || *ver) {\n\t\tif (data && info->type == type) {\n\t\t\tif ((info->mask & mask) == mask)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn data;\n}\n\nu16\nnvbios_ocfg_entry(struct nvkm_bios *bios, u16 outp, u8 idx,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len)\n{\n\tif (idx < *cnt)\n\t\treturn outp + *hdr + (idx * *len);\n\treturn 0x0000;\n}\n\nu16\nnvbios_ocfg_parse(struct nvkm_bios *bios, u16 outp, u8 idx,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len, struct nvbios_ocfg *info)\n{\n\tu16 data = nvbios_ocfg_entry(bios, outp, idx, ver, hdr, cnt, len);\n\tif (data) {\n\t\tinfo->proto     = nvbios_rd08(bios, data + 0x00);\n\t\tinfo->flags     = nvbios_rd16(bios, data + 0x01);\n\t\tinfo->clkcmp[0] = nvbios_rd16(bios, data + 0x02);\n\t\tinfo->clkcmp[1] = nvbios_rd16(bios, data + 0x04);\n\t}\n\treturn data;\n}\n\nu16\nnvbios_ocfg_match(struct nvkm_bios *bios, u16 outp, u8 proto, u8 flags,\n\t\t  u8 *ver, u8 *hdr, u8 *cnt, u8 *len, struct nvbios_ocfg *info)\n{\n\tu16 data, idx = 0;\n\twhile ((data = nvbios_ocfg_parse(bios, outp, idx++, ver, hdr, cnt, len, info))) {\n\t\tif ((info->proto == proto || info->proto == 0xff) &&\n\t\t    (info->flags == flags))\n\t\t\tbreak;\n\t}\n\treturn data;\n}\n\nu16\nnvbios_oclk_match(struct nvkm_bios *bios, u16 cmp, u32 khz)\n{\n\twhile (cmp) {\n\t\tif (khz / 10 >= nvbios_rd16(bios, cmp + 0x00))\n\t\t\treturn  nvbios_rd16(bios, cmp + 0x02);\n\t\tcmp += 0x04;\n\t}\n\treturn 0x0000;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}