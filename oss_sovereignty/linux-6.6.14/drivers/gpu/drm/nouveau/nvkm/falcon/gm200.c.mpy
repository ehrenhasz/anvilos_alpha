{
  "module_name": "gm200.c",
  "hash_id": "4a0787561e80a2528c022791a7f7dc2684a2513efdec63d53be951d4ce9439e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/falcon/gm200.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n#include <subdev/mc.h>\n#include <subdev/timer.h>\n\nvoid\ngm200_flcn_tracepc(struct nvkm_falcon *falcon)\n{\n\tu32 sctl = nvkm_falcon_rd32(falcon, 0x240);\n\tu32 tidx = nvkm_falcon_rd32(falcon, 0x148);\n\tint nr = (tidx & 0x00ff0000) >> 16, sp, ip;\n\n\tFLCN_ERR(falcon, \"TRACEPC SCTL %08x TIDX %08x\", sctl, tidx);\n\tfor (sp = 0; sp < nr; sp++) {\n\t\tnvkm_falcon_wr32(falcon, 0x148, sp);\n\t\tip = nvkm_falcon_rd32(falcon, 0x14c);\n\t\tFLCN_ERR(falcon, \"TRACEPC: %08x\", ip);\n\t}\n}\n\nstatic void\ngm200_flcn_pio_dmem_rd(struct nvkm_falcon *falcon, u8 port, const u8 *img, int len)\n{\n\twhile (len >= 4) {\n\t\t*(u32 *)img = nvkm_falcon_rd32(falcon, 0x1c4 + (port * 8));\n\t\timg += 4;\n\t\tlen -= 4;\n\t}\n\n\t \n\tif (len) {\n\t\tu32 data = nvkm_falcon_rd32(falcon, 0x1c4 + (port * 8));\n\n\t\twhile (len--) {\n\t\t\t*(u8 *)img++ = data & 0xff;\n\t\t\tdata >>= 8;\n\t\t}\n\t}\n}\n\nstatic void\ngm200_flcn_pio_dmem_rd_init(struct nvkm_falcon *falcon, u8 port, u32 dmem_base)\n{\n\tnvkm_falcon_wr32(falcon, 0x1c0 + (port * 8), BIT(25) | dmem_base);\n}\n\nstatic void\ngm200_flcn_pio_dmem_wr(struct nvkm_falcon *falcon, u8 port, const u8 *img, int len, u16 tag)\n{\n\twhile (len >= 4) {\n\t\tnvkm_falcon_wr32(falcon, 0x1c4 + (port * 8), *(u32 *)img);\n\t\timg += 4;\n\t\tlen -= 4;\n\t}\n\n\tWARN_ON(len);\n}\n\nstatic void\ngm200_flcn_pio_dmem_wr_init(struct nvkm_falcon *falcon, u8 port, bool sec, u32 dmem_base)\n{\n\tnvkm_falcon_wr32(falcon, 0x1c0 + (port * 8), BIT(24) | dmem_base);\n}\n\nconst struct nvkm_falcon_func_pio\ngm200_flcn_dmem_pio = {\n\t.min = 1,\n\t.max = 0x100,\n\t.wr_init = gm200_flcn_pio_dmem_wr_init,\n\t.wr = gm200_flcn_pio_dmem_wr,\n\t.rd_init = gm200_flcn_pio_dmem_rd_init,\n\t.rd = gm200_flcn_pio_dmem_rd,\n};\n\nstatic void\ngm200_flcn_pio_imem_wr_init(struct nvkm_falcon *falcon, u8 port, bool sec, u32 imem_base)\n{\n\tnvkm_falcon_wr32(falcon, 0x180 + (port * 0x10), (sec ? BIT(28) : 0) | BIT(24) | imem_base);\n}\n\nstatic void\ngm200_flcn_pio_imem_wr(struct nvkm_falcon *falcon, u8 port, const u8 *img, int len, u16 tag)\n{\n\tnvkm_falcon_wr32(falcon, 0x188 + (port * 0x10), tag++);\n\twhile (len >= 4) {\n\t\tnvkm_falcon_wr32(falcon, 0x184 + (port * 0x10), *(u32 *)img);\n\t\timg += 4;\n\t\tlen -= 4;\n\t}\n}\n\nconst struct nvkm_falcon_func_pio\ngm200_flcn_imem_pio = {\n\t.min = 0x100,\n\t.max = 0x100,\n\t.wr_init = gm200_flcn_pio_imem_wr_init,\n\t.wr = gm200_flcn_pio_imem_wr,\n};\n\nint\ngm200_flcn_bind_stat(struct nvkm_falcon *falcon, bool intr)\n{\n\tif (intr && !(nvkm_falcon_rd32(falcon, 0x008) & 0x00000008))\n\t\treturn -1;\n\n\treturn (nvkm_falcon_rd32(falcon, 0x0dc) & 0x00007000) >> 12;\n}\n\nvoid\ngm200_flcn_bind_inst(struct nvkm_falcon *falcon, int target, u64 addr)\n{\n\tnvkm_falcon_mask(falcon, 0x604, 0x00000007, 0x00000000);  \n\tnvkm_falcon_wr32(falcon, 0x054, (1 << 30) | (target << 28) | (addr >> 12));\n\tnvkm_falcon_mask(falcon, 0x090, 0x00010000, 0x00010000);\n\tnvkm_falcon_mask(falcon, 0x0a4, 0x00000008, 0x00000008);\n}\n\nint\ngm200_flcn_reset_wait_mem_scrubbing(struct nvkm_falcon *falcon)\n{\n\tnvkm_falcon_mask(falcon, 0x040, 0x00000000, 0x00000000);\n\n\tif (nvkm_msec(falcon->owner->device, 10,\n\t\tif (!(nvkm_falcon_rd32(falcon, 0x10c) & 0x00000006))\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint\ngm200_flcn_enable(struct nvkm_falcon *falcon)\n{\n\tstruct nvkm_device *device = falcon->owner->device;\n\tint ret;\n\n\tif (falcon->func->reset_eng) {\n\t\tret = falcon->func->reset_eng(falcon);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (falcon->func->select) {\n\t\tret = falcon->func->select(falcon);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (falcon->func->reset_pmc)\n\t\tnvkm_mc_enable(device, falcon->owner->type, falcon->owner->inst);\n\n\tret = falcon->func->reset_wait_mem_scrubbing(falcon);\n\tif (ret)\n\t\treturn ret;\n\n\tnvkm_falcon_wr32(falcon, 0x084, nvkm_rd32(device, 0x000000));\n\treturn 0;\n}\n\nint\ngm200_flcn_disable(struct nvkm_falcon *falcon)\n{\n\tstruct nvkm_device *device = falcon->owner->device;\n\tint ret;\n\n\tif (falcon->func->select) {\n\t\tret = falcon->func->select(falcon);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnvkm_falcon_mask(falcon, 0x048, 0x00000003, 0x00000000);\n\tnvkm_falcon_wr32(falcon, 0x014, 0xffffffff);\n\n\tif (falcon->func->reset_pmc) {\n\t\tif (falcon->func->reset_prep) {\n\t\t\tret = falcon->func->reset_prep(falcon);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tnvkm_mc_disable(device, falcon->owner->type, falcon->owner->inst);\n\t}\n\n\tif (falcon->func->reset_eng) {\n\t\tret = falcon->func->reset_eng(falcon);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint\ngm200_flcn_fw_boot(struct nvkm_falcon_fw *fw, u32 *pmbox0, u32 *pmbox1, u32 mbox0_ok, u32 irqsclr)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\tu32 mbox0, mbox1;\n\tint ret = 0;\n\n\tnvkm_falcon_wr32(falcon, 0x040, pmbox0 ? *pmbox0 : 0xcafebeef);\n\tif (pmbox1)\n\t\tnvkm_falcon_wr32(falcon, 0x044, *pmbox1);\n\n\tnvkm_falcon_wr32(falcon, 0x104, fw->boot_addr);\n\tnvkm_falcon_wr32(falcon, 0x100, 0x00000002);\n\n\tif (nvkm_msec(falcon->owner->device, 2000,\n\t\tif (nvkm_falcon_rd32(falcon, 0x100) & 0x00000010)\n\t\t\tbreak;\n\t) < 0)\n\t\tret = -ETIMEDOUT;\n\n\tmbox0 = nvkm_falcon_rd32(falcon, 0x040);\n\tmbox1 = nvkm_falcon_rd32(falcon, 0x044);\n\tif (FLCN_ERRON(falcon, ret || mbox0 != mbox0_ok, \"mbox %08x %08x\", mbox0, mbox1))\n\t\tret = ret ?: -EIO;\n\n\tif (irqsclr)\n\t\tnvkm_falcon_mask(falcon, 0x004, 0xffffffff, irqsclr);\n\n\treturn ret;\n}\n\nint\ngm200_flcn_fw_load(struct nvkm_falcon_fw *fw)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\tint target, ret;\n\n\tif (fw->inst) {\n\t\tnvkm_falcon_mask(falcon, 0x048, 0x00000001, 0x00000001);\n\n\t\tswitch (nvkm_memory_target(fw->inst)) {\n\t\tcase NVKM_MEM_TARGET_VRAM: target = 0; break;\n\t\tcase NVKM_MEM_TARGET_HOST: target = 2; break;\n\t\tcase NVKM_MEM_TARGET_NCOH: target = 3; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfalcon->func->bind_inst(falcon, target, nvkm_memory_addr(fw->inst));\n\n\t\tif (nvkm_msec(falcon->owner->device, 10,\n\t\t\tif (falcon->func->bind_stat(falcon, falcon->func->bind_intr) == 5)\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tnvkm_falcon_mask(falcon, 0x004, 0x00000008, 0x00000008);\n\t\tnvkm_falcon_mask(falcon, 0x058, 0x00000002, 0x00000002);\n\n\t\tif (nvkm_msec(falcon->owner->device, 10,\n\t\t\tif (falcon->func->bind_stat(falcon, false) == 0)\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -ETIMEDOUT;\n\t} else {\n\t\tnvkm_falcon_mask(falcon, 0x624, 0x00000080, 0x00000080);\n\t\tnvkm_falcon_wr32(falcon, 0x10c, 0x00000000);\n\t}\n\n\tif (fw->boot) {\n\t\tswitch (nvkm_memory_target(&fw->fw.mem.memory)) {\n\t\tcase NVKM_MEM_TARGET_VRAM: target = 4; break;\n\t\tcase NVKM_MEM_TARGET_HOST: target = 5; break;\n\t\tcase NVKM_MEM_TARGET_NCOH: target = 6; break;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = nvkm_falcon_pio_wr(falcon, fw->boot, 0, 0,\n\t\t\t\t\t IMEM, falcon->code.limit - fw->boot_size, fw->boot_size,\n\t\t\t\t\t fw->boot_addr >> 8, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn fw->func->load_bld(fw);\n\t}\n\n\tret = nvkm_falcon_pio_wr(falcon, fw->fw.img + fw->nmem_base_img, fw->nmem_base_img, 0,\n\t\t\t\t IMEM, fw->nmem_base, fw->nmem_size, fw->nmem_base >> 8, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_falcon_pio_wr(falcon, fw->fw.img + fw->imem_base_img, fw->imem_base_img, 0,\n\t\t\t\t IMEM, fw->imem_base, fw->imem_size, fw->imem_base >> 8, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_falcon_pio_wr(falcon, fw->fw.img + fw->dmem_base_img, fw->dmem_base_img, 0,\n\t\t\t\t DMEM, fw->dmem_base, fw->dmem_size, 0, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint\ngm200_flcn_fw_reset(struct nvkm_falcon_fw *fw)\n{\n\treturn nvkm_falcon_reset(fw->falcon);\n}\n\nint\ngm200_flcn_fw_signature(struct nvkm_falcon_fw *fw, u32 *sig_base_src)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\tu32 addr = falcon->func->debug;\n\tint ret = 0;\n\n\tif (addr) {\n\t\tret = nvkm_falcon_enable(falcon);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (nvkm_falcon_rd32(falcon, addr) & 0x00100000) {\n\t\t\t*sig_base_src = fw->sig_base_dbg;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nconst struct nvkm_falcon_fw_func\ngm200_flcn_fw = {\n\t.signature = gm200_flcn_fw_signature,\n\t.reset = gm200_flcn_fw_reset,\n\t.load = gm200_flcn_fw_load,\n\t.boot = gm200_flcn_fw_boot,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}