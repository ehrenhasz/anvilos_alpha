{
  "module_name": "fw.c",
  "hash_id": "583791f71add0b641a2475b45aaba735ac9036af8604b1422d2e01d16f5f9a65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/falcon/fw.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <core/memory.h>\n#include <subdev/mmu.h>\n\n#include <nvfw/fw.h>\n#include <nvfw/hs.h>\n\nint\nnvkm_falcon_fw_patch(struct nvkm_falcon_fw *fw)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\tu32 sig_base_src = fw->sig_base_prd;\n\tu32 src, dst, len, i;\n\tint idx = 0;\n\n\tFLCNFW_DBG(fw, \"patching sigs:%d size:%d\", fw->sig_nr, fw->sig_size);\n\tif (fw->func->signature) {\n\t\tidx = fw->func->signature(fw, &sig_base_src);\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t}\n\n\tsrc = idx * fw->sig_size;\n\tdst = fw->sig_base_img;\n\tlen = fw->sig_size / 4;\n\tFLCNFW_DBG(fw, \"patch idx:%d src:%08x dst:%08x\", idx, sig_base_src + src, dst);\n\tfor (i = 0; i < len; i++) {\n\t\tu32 sig = *(u32 *)(fw->sigs + src);\n\n\t\tif (nvkm_printk_ok(falcon->owner, falcon->user, NV_DBG_TRACE)) {\n\t\t\tif (i % 8 == 0)\n\t\t\t\tprintk(KERN_INFO \"sig -> %08x:\", dst);\n\t\t\tprintk(KERN_CONT \" %08x\", sig);\n\t\t}\n\n\t\t*(u32 *)(fw->fw.img + dst) = sig;\n\t\tsrc += 4;\n\t\tdst += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnvkm_falcon_fw_dtor_sigs(struct nvkm_falcon_fw *fw)\n{\n\tkfree(fw->sigs);\n\tfw->sigs = NULL;\n}\n\nint\nnvkm_falcon_fw_boot(struct nvkm_falcon_fw *fw, struct nvkm_subdev *user,\n\t\t    bool release, u32 *pmbox0, u32 *pmbox1, u32 mbox0_ok, u32 irqsclr)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\tint ret;\n\n\tret = nvkm_falcon_get(falcon, user);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fw->sigs) {\n\t\tret = nvkm_falcon_fw_patch(fw);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tnvkm_falcon_fw_dtor_sigs(fw);\n\t}\n\n\tFLCNFW_DBG(fw, \"resetting\");\n\tfw->func->reset(fw);\n\n\tFLCNFW_DBG(fw, \"loading\");\n\tif (fw->func->setup) {\n\t\tret = fw->func->setup(fw);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tret = fw->func->load(fw);\n\tif (ret)\n\t\tgoto done;\n\n\tFLCNFW_DBG(fw, \"booting\");\n\tret = fw->func->boot(fw, pmbox0, pmbox1, mbox0_ok, irqsclr);\n\tif (ret)\n\t\tFLCNFW_ERR(fw, \"boot failed: %d\", ret);\n\telse\n\t\tFLCNFW_DBG(fw, \"booted\");\n\ndone:\n\tif (ret || release)\n\t\tnvkm_falcon_put(falcon, user);\n\treturn ret;\n}\n\nint\nnvkm_falcon_fw_oneinit(struct nvkm_falcon_fw *fw, struct nvkm_falcon *falcon,\n\t\t       struct nvkm_vmm *vmm, struct nvkm_memory *inst)\n{\n\tint ret;\n\n\tfw->falcon = falcon;\n\tfw->vmm = nvkm_vmm_ref(vmm);\n\tfw->inst = nvkm_memory_ref(inst);\n\n\tif (fw->boot) {\n\t\tFLCN_DBG(falcon, \"mapping %s fw\", fw->fw.name);\n\t\tret = nvkm_vmm_get(fw->vmm, 12, nvkm_memory_size(&fw->fw.mem.memory), &fw->vma);\n\t\tif (ret) {\n\t\t\tFLCN_ERR(falcon, \"get %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = nvkm_memory_map(&fw->fw.mem.memory, 0, fw->vmm, fw->vma, NULL, 0);\n\t\tif (ret) {\n\t\t\tFLCN_ERR(falcon, \"map %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\nnvkm_falcon_fw_dtor(struct nvkm_falcon_fw *fw)\n{\n\tnvkm_vmm_put(fw->vmm, &fw->vma);\n\tnvkm_vmm_unref(&fw->vmm);\n\tnvkm_memory_unref(&fw->inst);\n\tnvkm_falcon_fw_dtor_sigs(fw);\n\tnvkm_firmware_dtor(&fw->fw);\n}\n\nstatic const struct nvkm_firmware_func\nnvkm_falcon_fw_dma = {\n\t.type = NVKM_FIRMWARE_IMG_DMA,\n};\n\nstatic const struct nvkm_firmware_func\nnvkm_falcon_fw = {\n\t.type = NVKM_FIRMWARE_IMG_RAM,\n};\n\nint\nnvkm_falcon_fw_sign(struct nvkm_falcon_fw *fw, u32 sig_base_img, u32 sig_size, const u8 *sigs,\n\t\t    int sig_nr_prd, u32 sig_base_prd, int sig_nr_dbg, u32 sig_base_dbg)\n{\n\tfw->sig_base_prd = sig_base_prd;\n\tfw->sig_base_dbg = sig_base_dbg;\n\tfw->sig_base_img = sig_base_img;\n\tfw->sig_size = sig_size;\n\tfw->sig_nr = sig_nr_prd + sig_nr_dbg;\n\n\tfw->sigs = kmalloc_array(fw->sig_nr, fw->sig_size, GFP_KERNEL);\n\tif (!fw->sigs)\n\t\treturn -ENOMEM;\n\n\tmemcpy(fw->sigs, sigs + sig_base_prd, sig_nr_prd * fw->sig_size);\n\tif (sig_nr_dbg)\n\t\tmemcpy(fw->sigs + sig_size, sigs + sig_base_dbg, sig_nr_dbg * fw->sig_size);\n\n\treturn 0;\n}\n\nint\nnvkm_falcon_fw_ctor(const struct nvkm_falcon_fw_func *func, const char *name,\n\t\t    struct nvkm_device *device, bool dma, const void *src, u32 len,\n\t\t    struct nvkm_falcon *falcon, struct nvkm_falcon_fw *fw)\n{\n\tconst struct nvkm_firmware_func *type = dma ? &nvkm_falcon_fw_dma : &nvkm_falcon_fw;\n\tint ret;\n\n\tfw->func = func;\n\n\tret = nvkm_firmware_ctor(type, name, device, src, len, &fw->fw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn falcon ? nvkm_falcon_fw_oneinit(fw, falcon, NULL, NULL) : 0;\n}\n\nint\nnvkm_falcon_fw_ctor_hs(const struct nvkm_falcon_fw_func *func, const char *name,\n\t\t       struct nvkm_subdev *subdev, const char *bl, const char *img, int ver,\n\t\t       struct nvkm_falcon *falcon, struct nvkm_falcon_fw *fw)\n{\n\tconst struct firmware *blob;\n\tconst struct nvfw_bin_hdr *hdr;\n\tconst struct nvfw_hs_header *hshdr;\n\tconst struct nvfw_hs_load_header *lhdr;\n\tconst struct nvfw_bl_desc *desc;\n\tu32 loc, sig;\n\tint ret;\n\n\tret = nvkm_firmware_load_name(subdev, img, \"\", ver, &blob);\n\tif (ret)\n\t\treturn ret;\n\n\thdr = nvfw_bin_hdr(subdev, blob->data);\n\thshdr = nvfw_hs_header(subdev, blob->data + hdr->header_offset);\n\n\tret = nvkm_falcon_fw_ctor(func, name, subdev->device, bl != NULL,\n\t\t\t\t  blob->data + hdr->data_offset, hdr->data_size, falcon, fw);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tswitch (hdr->bin_magic) {\n\tcase 0x000010de:\n\t\tloc = *(u32 *)(blob->data + hshdr->patch_loc);\n\t\tsig = *(u32 *)(blob->data + hshdr->patch_sig);\n\t\tbreak;\n\tcase 0x3b1d14f0:\n\t\tloc = hshdr->patch_loc;\n\t\tsig = hshdr->patch_sig;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tret = nvkm_falcon_fw_sign(fw, loc, hshdr->sig_prod_size, blob->data,\n\t\t\t\t  1, hshdr->sig_prod_offset + sig,\n\t\t\t\t  1, hshdr->sig_dbg_offset + sig);\n\tif (ret)\n\t\tgoto done;\n\n\tlhdr = nvfw_hs_load_header(subdev, blob->data + hshdr->hdr_offset);\n\n\tfw->nmem_base_img = 0;\n\tfw->nmem_base = lhdr->non_sec_code_off;\n\tfw->nmem_size = lhdr->non_sec_code_size;\n\n\tfw->imem_base_img = lhdr->apps[0];\n\tfw->imem_base = ALIGN(lhdr->apps[0], 0x100);\n\tfw->imem_size = lhdr->apps[lhdr->num_apps + 0];\n\n\tfw->dmem_base_img = lhdr->data_dma_base;\n\tfw->dmem_base = 0;\n\tfw->dmem_size = lhdr->data_size;\n\tfw->dmem_sign = loc - lhdr->data_dma_base;\n\n\tif (bl) {\n\t\tnvkm_firmware_put(blob);\n\n\t\tret = nvkm_firmware_load_name(subdev, bl, \"\", ver, &blob);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\thdr = nvfw_bin_hdr(subdev, blob->data);\n\t\tdesc = nvfw_bl_desc(subdev, blob->data + hdr->header_offset);\n\n\t\tfw->boot_addr = desc->start_tag << 8;\n\t\tfw->boot_size = desc->code_size;\n\t\tfw->boot = kmemdup(blob->data + hdr->data_offset + desc->code_off,\n\t\t\t\t   fw->boot_size, GFP_KERNEL);\n\t\tif (!fw->boot)\n\t\t\tret = -ENOMEM;\n\t} else {\n\t\tfw->boot_addr = fw->nmem_base;\n\t}\n\ndone:\n\tif (ret)\n\t\tnvkm_falcon_fw_dtor(fw);\n\n\tnvkm_firmware_put(blob);\n\treturn ret;\n}\n\nint\nnvkm_falcon_fw_ctor_hs_v2(const struct nvkm_falcon_fw_func *func, const char *name,\n\t\t\t  struct nvkm_subdev *subdev, const char *img, int ver,\n\t\t\t  struct nvkm_falcon *falcon, struct nvkm_falcon_fw *fw)\n{\n\tconst struct nvfw_bin_hdr *hdr;\n\tconst struct nvfw_hs_header_v2 *hshdr;\n\tconst struct nvfw_hs_load_header_v2 *lhdr;\n\tconst struct firmware *blob;\n\tu32 loc, sig, cnt, *meta;\n\tint ret;\n\n\tret = nvkm_firmware_load_name(subdev, img, \"\", ver, &blob);\n\tif (ret)\n\t\treturn ret;\n\n\thdr = nvfw_bin_hdr(subdev, blob->data);\n\thshdr = nvfw_hs_header_v2(subdev, blob->data + hdr->header_offset);\n\tmeta = (u32 *)(blob->data + hshdr->meta_data_offset);\n\tloc = *(u32 *)(blob->data + hshdr->patch_loc);\n\tsig = *(u32 *)(blob->data + hshdr->patch_sig);\n\tcnt = *(u32 *)(blob->data + hshdr->num_sig);\n\n\tret = nvkm_falcon_fw_ctor(func, name, subdev->device, true,\n\t\t\t\t  blob->data + hdr->data_offset, hdr->data_size, falcon, fw);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nvkm_falcon_fw_sign(fw, loc, hshdr->sig_prod_size / cnt, blob->data,\n\t\t\t\t  cnt, hshdr->sig_prod_offset + sig, 0, 0);\n\tif (ret)\n\t\tgoto done;\n\n\tlhdr = nvfw_hs_load_header_v2(subdev, blob->data + hshdr->header_offset);\n\n\tfw->imem_base_img = lhdr->app[0].offset;\n\tfw->imem_base = 0;\n\tfw->imem_size = lhdr->app[0].size;\n\n\tfw->dmem_base_img = lhdr->os_data_offset;\n\tfw->dmem_base = 0;\n\tfw->dmem_size = lhdr->os_data_size;\n\tfw->dmem_sign = loc - lhdr->os_data_offset;\n\n\tfw->boot_addr = lhdr->app[0].offset;\n\n\tfw->fuse_ver = meta[0];\n\tfw->engine_id = meta[1];\n\tfw->ucode_id = meta[2];\n\ndone:\n\tif (ret)\n\t\tnvkm_falcon_fw_dtor(fw);\n\n\tnvkm_firmware_put(blob);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}