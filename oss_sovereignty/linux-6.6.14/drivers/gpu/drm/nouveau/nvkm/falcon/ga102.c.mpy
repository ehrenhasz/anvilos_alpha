{
  "module_name": "ga102.c",
  "hash_id": "dd926636b278b329f479134d5f3b630911e1867c9c078211cb5747a3231286a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/falcon/ga102.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/mc.h>\n#include <subdev/timer.h>\n\nstatic bool\nga102_flcn_dma_done(struct nvkm_falcon *falcon)\n{\n\treturn !!(nvkm_falcon_rd32(falcon, 0x118) & 0x00000002);\n}\n\nstatic void\nga102_flcn_dma_xfer(struct nvkm_falcon *falcon, u32 mem_base, u32 dma_base, u32 cmd)\n{\n\tnvkm_falcon_wr32(falcon, 0x114, mem_base);\n\tnvkm_falcon_wr32(falcon, 0x11c, dma_base);\n\tnvkm_falcon_wr32(falcon, 0x118, cmd);\n}\n\nstatic int\nga102_flcn_dma_init(struct nvkm_falcon *falcon, u64 dma_addr, int xfer_len,\n\t\t    enum nvkm_falcon_mem mem_type, bool sec, u32 *cmd)\n{\n\t*cmd = (ilog2(xfer_len) - 2) << 8;\n\tif (mem_type == IMEM)\n\t\t*cmd |= 0x00000010;\n\tif (sec)\n\t\t*cmd |= 0x00000004;\n\n\tnvkm_falcon_wr32(falcon, 0x110, dma_addr >> 8);\n\tnvkm_falcon_wr32(falcon, 0x128, 0x00000000);\n\treturn 0;\n}\n\nconst struct nvkm_falcon_func_dma\nga102_flcn_dma = {\n\t.init = ga102_flcn_dma_init,\n\t.xfer = ga102_flcn_dma_xfer,\n\t.done = ga102_flcn_dma_done,\n};\n\nint\nga102_flcn_reset_wait_mem_scrubbing(struct nvkm_falcon *falcon)\n{\n\tnvkm_falcon_mask(falcon, 0x040, 0x00000000, 0x00000000);\n\n\tif (nvkm_msec(falcon->owner->device, 20,\n\t\tif (!(nvkm_falcon_rd32(falcon, 0x0f4) & 0x00001000))\n\t\t\tbreak;\n\t) < 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint\nga102_flcn_reset_prep(struct nvkm_falcon *falcon)\n{\n\tnvkm_falcon_rd32(falcon, 0x0f4);\n\n\tnvkm_usec(falcon->owner->device, 150,\n\t\tif (nvkm_falcon_rd32(falcon, 0x0f4) & 0x80000000)\n\t\t\tbreak;\n\t\t_warn = false;\n\t);\n\n\treturn 0;\n}\n\nint\nga102_flcn_select(struct nvkm_falcon *falcon)\n{\n\tif ((nvkm_falcon_rd32(falcon, falcon->addr2 + 0x668) & 0x00000010) != 0x00000000) {\n\t\tnvkm_falcon_wr32(falcon, falcon->addr2 + 0x668, 0x00000000);\n\t\tif (nvkm_msec(falcon->owner->device, 10,\n\t\t\tif (nvkm_falcon_rd32(falcon, falcon->addr2 + 0x668) & 0x00000001)\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint\nga102_flcn_fw_boot(struct nvkm_falcon_fw *fw, u32 *mbox0, u32 *mbox1, u32 mbox0_ok, u32 irqsclr)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\n\tnvkm_falcon_wr32(falcon, falcon->addr2 + 0x210, fw->dmem_sign);\n\tnvkm_falcon_wr32(falcon, falcon->addr2 + 0x19c, fw->engine_id);\n\tnvkm_falcon_wr32(falcon, falcon->addr2 + 0x198, fw->ucode_id);\n\tnvkm_falcon_wr32(falcon, falcon->addr2 + 0x180, 0x00000001);\n\n\treturn gm200_flcn_fw_boot(fw, mbox0, mbox1, mbox0_ok, irqsclr);\n}\n\nint\nga102_flcn_fw_load(struct nvkm_falcon_fw *fw)\n{\n\tstruct nvkm_falcon *falcon = fw->falcon;\n\tint ret = 0;\n\n\tnvkm_falcon_mask(falcon, 0x624, 0x00000080, 0x00000080);\n\tnvkm_falcon_wr32(falcon, 0x10c, 0x00000000);\n\tnvkm_falcon_mask(falcon, 0x600, 0x00010007, (0 << 16) | (1 << 2) | 1);\n\n\tret = nvkm_falcon_dma_wr(falcon, fw->fw.img, fw->fw.phys, fw->imem_base_img,\n\t\t\t\t IMEM, fw->imem_base, fw->imem_size, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_falcon_dma_wr(falcon, fw->fw.img, fw->fw.phys, fw->dmem_base_img,\n\t\t\t\t DMEM, fw->dmem_base, fw->dmem_size, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nconst struct nvkm_falcon_fw_func\nga102_flcn_fw = {\n\t.signature = ga100_flcn_fw_signature,\n\t.reset = gm200_flcn_fw_reset,\n\t.load = ga102_flcn_fw_load,\n\t.boot = ga102_flcn_fw_boot,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}