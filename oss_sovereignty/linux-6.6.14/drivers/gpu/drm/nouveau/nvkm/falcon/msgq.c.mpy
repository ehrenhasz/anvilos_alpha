{
  "module_name": "msgq.c",
  "hash_id": "a62d49152b7dae5e594c65a8f5a25a22b2e7d5f6553bef0ec6004221800d4343",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/falcon/msgq.c",
  "human_readable_source": " \n#include \"qmgr.h\"\n\nstatic void\nnvkm_falcon_msgq_open(struct nvkm_falcon_msgq *msgq)\n{\n\tspin_lock(&msgq->lock);\n\tmsgq->position = nvkm_falcon_rd32(msgq->qmgr->falcon, msgq->tail_reg);\n}\n\nstatic void\nnvkm_falcon_msgq_close(struct nvkm_falcon_msgq *msgq, bool commit)\n{\n\tstruct nvkm_falcon *falcon = msgq->qmgr->falcon;\n\n\tif (commit)\n\t\tnvkm_falcon_wr32(falcon, msgq->tail_reg, msgq->position);\n\n\tspin_unlock(&msgq->lock);\n}\n\nbool\nnvkm_falcon_msgq_empty(struct nvkm_falcon_msgq *msgq)\n{\n\tu32 head = nvkm_falcon_rd32(msgq->qmgr->falcon, msgq->head_reg);\n\tu32 tail = nvkm_falcon_rd32(msgq->qmgr->falcon, msgq->tail_reg);\n\treturn head == tail;\n}\n\nstatic int\nnvkm_falcon_msgq_pop(struct nvkm_falcon_msgq *msgq, void *data, u32 size)\n{\n\tstruct nvkm_falcon *falcon = msgq->qmgr->falcon;\n\tu32 head, tail, available;\n\n\thead = nvkm_falcon_rd32(falcon, msgq->head_reg);\n\t \n\tif (head < msgq->position)\n\t\tmsgq->position = msgq->offset;\n\n\ttail = msgq->position;\n\n\tavailable = head - tail;\n\tif (size > available) {\n\t\tFLCNQ_ERR(msgq, \"requested %d bytes, but only %d available\",\n\t\t\t  size, available);\n\t\treturn -EINVAL;\n\t}\n\n\tnvkm_falcon_pio_rd(falcon, 0, DMEM, tail, data, 0, size);\n\tmsgq->position += ALIGN(size, QUEUE_ALIGNMENT);\n\treturn 0;\n}\n\nstatic int\nnvkm_falcon_msgq_read(struct nvkm_falcon_msgq *msgq, struct nvfw_falcon_msg *hdr)\n{\n\tint ret = 0;\n\n\tnvkm_falcon_msgq_open(msgq);\n\n\tif (nvkm_falcon_msgq_empty(msgq))\n\t\tgoto close;\n\n\tret = nvkm_falcon_msgq_pop(msgq, hdr, HDR_SIZE);\n\tif (ret) {\n\t\tFLCNQ_ERR(msgq, \"failed to read message header\");\n\t\tgoto close;\n\t}\n\n\tif (hdr->size > MSG_BUF_SIZE) {\n\t\tFLCNQ_ERR(msgq, \"message too big, %d bytes\", hdr->size);\n\t\tret = -ENOSPC;\n\t\tgoto close;\n\t}\n\n\tif (hdr->size > HDR_SIZE) {\n\t\tu32 read_size = hdr->size - HDR_SIZE;\n\n\t\tret = nvkm_falcon_msgq_pop(msgq, (hdr + 1), read_size);\n\t\tif (ret) {\n\t\t\tFLCNQ_ERR(msgq, \"failed to read message data\");\n\t\t\tgoto close;\n\t\t}\n\t}\n\n\tret = 1;\nclose:\n\tnvkm_falcon_msgq_close(msgq, (ret >= 0));\n\treturn ret;\n}\n\nstatic int\nnvkm_falcon_msgq_exec(struct nvkm_falcon_msgq *msgq, struct nvfw_falcon_msg *hdr)\n{\n\tstruct nvkm_falcon_qmgr_seq *seq;\n\n\tseq = &msgq->qmgr->seq.id[hdr->seq_id];\n\tif (seq->state != SEQ_STATE_USED && seq->state != SEQ_STATE_CANCELLED) {\n\t\tFLCNQ_ERR(msgq, \"message for unknown sequence %08x\", seq->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (seq->state == SEQ_STATE_USED) {\n\t\tif (seq->callback)\n\t\t\tseq->result = seq->callback(seq->priv, hdr);\n\t}\n\n\tif (seq->async) {\n\t\tnvkm_falcon_qmgr_seq_release(msgq->qmgr, seq);\n\t\treturn 0;\n\t}\n\n\tcomplete_all(&seq->done);\n\treturn 0;\n}\n\nvoid\nnvkm_falcon_msgq_recv(struct nvkm_falcon_msgq *msgq)\n{\n\t \n\tu8 msg_buffer[MSG_BUF_SIZE];\n\tstruct nvfw_falcon_msg *hdr = (void *)msg_buffer;\n\n\twhile (nvkm_falcon_msgq_read(msgq, hdr) > 0)\n\t\tnvkm_falcon_msgq_exec(msgq, hdr);\n}\n\nint\nnvkm_falcon_msgq_recv_initmsg(struct nvkm_falcon_msgq *msgq,\n\t\t\t      void *data, u32 size)\n{\n\tstruct nvkm_falcon *falcon = msgq->qmgr->falcon;\n\tstruct nvfw_falcon_msg *hdr = data;\n\tint ret;\n\n\tmsgq->head_reg = falcon->func->msgq.head;\n\tmsgq->tail_reg = falcon->func->msgq.tail;\n\tmsgq->offset = nvkm_falcon_rd32(falcon, falcon->func->msgq.tail);\n\n\tnvkm_falcon_msgq_open(msgq);\n\tret = nvkm_falcon_msgq_pop(msgq, data, size);\n\tif (ret == 0 && hdr->size != size) {\n\t\tFLCN_ERR(falcon, \"unexpected init message size %d vs %d\",\n\t\t\t hdr->size, size);\n\t\tret = -EINVAL;\n\t}\n\tnvkm_falcon_msgq_close(msgq, ret == 0);\n\treturn ret;\n}\n\nvoid\nnvkm_falcon_msgq_init(struct nvkm_falcon_msgq *msgq,\n\t\t      u32 index, u32 offset, u32 size)\n{\n\tconst struct nvkm_falcon_func *func = msgq->qmgr->falcon->func;\n\n\tmsgq->head_reg = func->msgq.head + index * func->msgq.stride;\n\tmsgq->tail_reg = func->msgq.tail + index * func->msgq.stride;\n\tmsgq->offset = offset;\n\n\tFLCNQ_DBG(msgq, \"initialised @ index %d offset 0x%08x size 0x%08x\",\n\t\t  index, msgq->offset, size);\n}\n\nvoid\nnvkm_falcon_msgq_del(struct nvkm_falcon_msgq **pmsgq)\n{\n\tstruct nvkm_falcon_msgq *msgq = *pmsgq;\n\tif (msgq) {\n\t\tkfree(*pmsgq);\n\t\t*pmsgq = NULL;\n\t}\n}\n\nint\nnvkm_falcon_msgq_new(struct nvkm_falcon_qmgr *qmgr, const char *name,\n\t\t     struct nvkm_falcon_msgq **pmsgq)\n{\n\tstruct nvkm_falcon_msgq *msgq = *pmsgq;\n\n\tif (!(msgq = *pmsgq = kzalloc(sizeof(*msgq), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tmsgq->qmgr = qmgr;\n\tmsgq->name = name;\n\tspin_lock_init(&msgq->lock);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}