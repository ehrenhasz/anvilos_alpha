{
  "module_name": "cmdq.c",
  "hash_id": "0b58ec2fe97354734429fb17579c395785da148f75b781aa8ccdd94e7a93d3fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/falcon/cmdq.c",
  "human_readable_source": " \n#include \"qmgr.h\"\n\nstatic bool\nnvkm_falcon_cmdq_has_room(struct nvkm_falcon_cmdq *cmdq, u32 size, bool *rewind)\n{\n\tu32 head = nvkm_falcon_rd32(cmdq->qmgr->falcon, cmdq->head_reg);\n\tu32 tail = nvkm_falcon_rd32(cmdq->qmgr->falcon, cmdq->tail_reg);\n\tu32 free;\n\n\tsize = ALIGN(size, QUEUE_ALIGNMENT);\n\n\tif (head >= tail) {\n\t\tfree = cmdq->offset + cmdq->size - head;\n\t\tfree -= HDR_SIZE;\n\n\t\tif (size > free) {\n\t\t\t*rewind = true;\n\t\t\thead = cmdq->offset;\n\t\t}\n\t}\n\n\tif (head < tail)\n\t\tfree = tail - head - 1;\n\n\treturn size <= free;\n}\n\nstatic void\nnvkm_falcon_cmdq_push(struct nvkm_falcon_cmdq *cmdq, void *data, u32 size)\n{\n\tstruct nvkm_falcon *falcon = cmdq->qmgr->falcon;\n\tnvkm_falcon_pio_wr(falcon, data, 0, 0, DMEM, cmdq->position, size, 0, false);\n\tcmdq->position += ALIGN(size, QUEUE_ALIGNMENT);\n}\n\nstatic void\nnvkm_falcon_cmdq_rewind(struct nvkm_falcon_cmdq *cmdq)\n{\n\tstruct nvfw_falcon_cmd cmd;\n\n\tcmd.unit_id = NV_FALCON_CMD_UNIT_ID_REWIND;\n\tcmd.size = sizeof(cmd);\n\tnvkm_falcon_cmdq_push(cmdq, &cmd, cmd.size);\n\n\tcmdq->position = cmdq->offset;\n}\n\nstatic int\nnvkm_falcon_cmdq_open(struct nvkm_falcon_cmdq *cmdq, u32 size)\n{\n\tstruct nvkm_falcon *falcon = cmdq->qmgr->falcon;\n\tbool rewind = false;\n\n\tmutex_lock(&cmdq->mutex);\n\n\tif (!nvkm_falcon_cmdq_has_room(cmdq, size, &rewind)) {\n\t\tFLCNQ_DBG(cmdq, \"queue full\");\n\t\tmutex_unlock(&cmdq->mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\tcmdq->position = nvkm_falcon_rd32(falcon, cmdq->head_reg);\n\n\tif (rewind)\n\t\tnvkm_falcon_cmdq_rewind(cmdq);\n\n\treturn 0;\n}\n\nstatic void\nnvkm_falcon_cmdq_close(struct nvkm_falcon_cmdq *cmdq)\n{\n\tnvkm_falcon_wr32(cmdq->qmgr->falcon, cmdq->head_reg, cmdq->position);\n\tmutex_unlock(&cmdq->mutex);\n}\n\nstatic int\nnvkm_falcon_cmdq_write(struct nvkm_falcon_cmdq *cmdq, struct nvfw_falcon_cmd *cmd)\n{\n\tstatic unsigned timeout = 2000;\n\tunsigned long end_jiffies = jiffies + msecs_to_jiffies(timeout);\n\tint ret = -EAGAIN;\n\n\twhile (ret == -EAGAIN && time_before(jiffies, end_jiffies))\n\t\tret = nvkm_falcon_cmdq_open(cmdq, cmd->size);\n\tif (ret) {\n\t\tFLCNQ_ERR(cmdq, \"timeout waiting for queue space\");\n\t\treturn ret;\n\t}\n\n\tnvkm_falcon_cmdq_push(cmdq, cmd, cmd->size);\n\tnvkm_falcon_cmdq_close(cmdq);\n\treturn ret;\n}\n\n \n#define CMD_FLAGS_STATUS BIT(0)\n \n#define CMD_FLAGS_INTR BIT(1)\n\nint\nnvkm_falcon_cmdq_send(struct nvkm_falcon_cmdq *cmdq, struct nvfw_falcon_cmd *cmd,\n\t\t      nvkm_falcon_qmgr_callback cb, void *priv,\n\t\t      unsigned long timeout)\n{\n\tstruct nvkm_falcon_qmgr_seq *seq;\n\tint ret;\n\n\tif (!wait_for_completion_timeout(&cmdq->ready,\n\t\t\t\t\t msecs_to_jiffies(1000))) {\n\t\tFLCNQ_ERR(cmdq, \"timeout waiting for queue ready\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tseq = nvkm_falcon_qmgr_seq_acquire(cmdq->qmgr);\n\tif (IS_ERR(seq))\n\t\treturn PTR_ERR(seq);\n\n\tcmd->seq_id = seq->id;\n\tcmd->ctrl_flags = CMD_FLAGS_STATUS | CMD_FLAGS_INTR;\n\n\tseq->state = SEQ_STATE_USED;\n\tseq->async = !timeout;\n\tseq->callback = cb;\n\tseq->priv = priv;\n\n\tret = nvkm_falcon_cmdq_write(cmdq, cmd);\n\tif (ret) {\n\t\tseq->state = SEQ_STATE_PENDING;\n\t\tnvkm_falcon_qmgr_seq_release(cmdq->qmgr, seq);\n\t\treturn ret;\n\t}\n\n\tif (!seq->async) {\n\t\tif (!wait_for_completion_timeout(&seq->done, timeout)) {\n\t\t\tFLCNQ_ERR(cmdq, \"timeout waiting for reply\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tret = seq->result;\n\t\tnvkm_falcon_qmgr_seq_release(cmdq->qmgr, seq);\n\t}\n\n\treturn ret;\n}\n\nvoid\nnvkm_falcon_cmdq_fini(struct nvkm_falcon_cmdq *cmdq)\n{\n\treinit_completion(&cmdq->ready);\n}\n\nvoid\nnvkm_falcon_cmdq_init(struct nvkm_falcon_cmdq *cmdq,\n\t\t      u32 index, u32 offset, u32 size)\n{\n\tconst struct nvkm_falcon_func *func = cmdq->qmgr->falcon->func;\n\n\tcmdq->head_reg = func->cmdq.head + index * func->cmdq.stride;\n\tcmdq->tail_reg = func->cmdq.tail + index * func->cmdq.stride;\n\tcmdq->offset = offset;\n\tcmdq->size = size;\n\tcomplete_all(&cmdq->ready);\n\n\tFLCNQ_DBG(cmdq, \"initialised @ index %d offset 0x%08x size 0x%08x\",\n\t\t  index, cmdq->offset, cmdq->size);\n}\n\nvoid\nnvkm_falcon_cmdq_del(struct nvkm_falcon_cmdq **pcmdq)\n{\n\tstruct nvkm_falcon_cmdq *cmdq = *pcmdq;\n\tif (cmdq) {\n\t\tkfree(*pcmdq);\n\t\t*pcmdq = NULL;\n\t}\n}\n\nint\nnvkm_falcon_cmdq_new(struct nvkm_falcon_qmgr *qmgr, const char *name,\n\t\t     struct nvkm_falcon_cmdq **pcmdq)\n{\n\tstruct nvkm_falcon_cmdq *cmdq = *pcmdq;\n\n\tif (!(cmdq = *pcmdq = kzalloc(sizeof(*cmdq), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tcmdq->qmgr = qmgr;\n\tcmdq->name = name;\n\tmutex_init(&cmdq->mutex);\n\tinit_completion(&cmdq->ready);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}