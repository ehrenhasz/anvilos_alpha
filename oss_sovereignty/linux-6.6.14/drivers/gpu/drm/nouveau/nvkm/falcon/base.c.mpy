{
  "module_name": "base.c",
  "hash_id": "1556c9e74f2b6fd3b21de9455e1a1842d1d44b4dc5a6508f032c7702504576b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvkm/falcon/base.c",
  "human_readable_source": " \n#include \"priv.h\"\n\n#include <subdev/mc.h>\n#include <subdev/timer.h>\n#include <subdev/top.h>\n\nstatic const struct nvkm_falcon_func_dma *\nnvkm_falcon_dma(struct nvkm_falcon *falcon, enum nvkm_falcon_mem *mem_type, u32 *mem_base)\n{\n\tswitch (*mem_type) {\n\tcase IMEM: return falcon->func->imem_dma;\n\tcase DMEM: return falcon->func->dmem_dma;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nint\nnvkm_falcon_dma_wr(struct nvkm_falcon *falcon, const u8 *img, u64 dma_addr, u32 dma_base,\n\t\t   enum nvkm_falcon_mem mem_type, u32 mem_base, int len, bool sec)\n{\n\tconst struct nvkm_falcon_func_dma *dma = nvkm_falcon_dma(falcon, &mem_type, &mem_base);\n\tconst char *type = nvkm_falcon_mem(mem_type);\n\tconst int dmalen = 256;\n\tu32 dma_start = 0;\n\tu32 dst, src, cmd;\n\tint ret, i;\n\n\tif (WARN_ON(!dma->xfer))\n\t\treturn -EINVAL;\n\n\tif (mem_type == DMEM) {\n\t\tdma_start = dma_base;\n\t\tdma_addr += dma_base;\n\t}\n\n\tFLCN_DBG(falcon, \"%s %08x <- %08x bytes at %08x (%010llx %08x)\",\n\t\t type, mem_base, len, dma_base, dma_addr - dma_base, dma_start);\n\tif (WARN_ON(!len || (len & (dmalen - 1))))\n\t\treturn -EINVAL;\n\n\tret = dma->init(falcon, dma_addr, dmalen, mem_type, sec, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tdst = mem_base;\n\tsrc = dma_base;\n\tif (len) {\n\t\twhile (len >= dmalen) {\n\t\t\tdma->xfer(falcon, dst, src - dma_start, cmd);\n\n\t\t\tif (img && nvkm_printk_ok(falcon->owner, falcon->user, NV_DBG_TRACE)) {\n\t\t\t\tfor (i = 0; i < dmalen; i += 4, mem_base += 4) {\n\t\t\t\t\tconst int w = 8, x = (i / 4) % w;\n\n\t\t\t\t\tif (x == 0)\n\t\t\t\t\t\tprintk(KERN_INFO \"%s %08x <-\", type, mem_base);\n\t\t\t\t\tprintk(KERN_CONT \" %08x\", *(u32 *)(img + src + i));\n\t\t\t\t\tif (x == (w - 1) || ((i + 4) == dmalen))\n\t\t\t\t\t\tprintk(KERN_CONT \" <- %08x+%08x\", dma_base,\n\t\t\t\t\t\t       src + i - dma_base - (x * 4));\n\t\t\t\t\tif (i == (7 * 4))\n\t\t\t\t\t\tprintk(KERN_CONT \" *\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nvkm_msec(falcon->owner->device, 2000,\n\t\t\t\tif (dma->done(falcon))\n\t\t\t\t\tbreak;\n\t\t\t) < 0)\n\t\t\t\treturn -ETIMEDOUT;\n\n\t\t\tsrc += dmalen;\n\t\t\tdst += dmalen;\n\t\t\tlen -= dmalen;\n\t\t}\n\t\tWARN_ON(len);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct nvkm_falcon_func_pio *\nnvkm_falcon_pio(struct nvkm_falcon *falcon, enum nvkm_falcon_mem *mem_type, u32 *mem_base)\n{\n\tswitch (*mem_type) {\n\tcase IMEM:\n\t\treturn falcon->func->imem_pio;\n\tcase DMEM:\n\t\tif (!falcon->func->emem_addr || *mem_base < falcon->func->emem_addr)\n\t\t\treturn falcon->func->dmem_pio;\n\n\t\t*mem_base -= falcon->func->emem_addr;\n\t\tfallthrough;\n\tcase EMEM:\n\t\treturn falcon->func->emem_pio;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nint\nnvkm_falcon_pio_rd(struct nvkm_falcon *falcon, u8 port, enum nvkm_falcon_mem mem_type, u32 mem_base,\n\t\t   const u8 *img, u32 img_base, int len)\n{\n\tconst struct nvkm_falcon_func_pio *pio = nvkm_falcon_pio(falcon, &mem_type, &mem_base);\n\tconst char *type = nvkm_falcon_mem(mem_type);\n\tint xfer_len;\n\n\tif (WARN_ON(!pio || !pio->rd))\n\t\treturn -EINVAL;\n\n\tFLCN_DBG(falcon, \"%s %08x -> %08x bytes at %08x\", type, mem_base, len, img_base);\n\tif (WARN_ON(!len || (len & (pio->min - 1))))\n\t\treturn -EINVAL;\n\n\tpio->rd_init(falcon, port, mem_base);\n\tdo {\n\t\txfer_len = min(len, pio->max);\n\t\tpio->rd(falcon, port, img, xfer_len);\n\n\t\tif (nvkm_printk_ok(falcon->owner, falcon->user, NV_DBG_TRACE)) {\n\t\t\tfor (img_base = 0; img_base < xfer_len; img_base += 4, mem_base += 4) {\n\t\t\t\tif (((img_base / 4) % 8) == 0)\n\t\t\t\t\tprintk(KERN_INFO \"%s %08x ->\", type, mem_base);\n\t\t\t\tprintk(KERN_CONT \" %08x\", *(u32 *)(img + img_base));\n\t\t\t}\n\t\t}\n\n\t\timg += xfer_len;\n\t\tlen -= xfer_len;\n\t} while (len);\n\n\treturn 0;\n}\n\nint\nnvkm_falcon_pio_wr(struct nvkm_falcon *falcon, const u8 *img, u32 img_base, u8 port,\n\t\t   enum nvkm_falcon_mem mem_type, u32 mem_base, int len, u16 tag, bool sec)\n{\n\tconst struct nvkm_falcon_func_pio *pio = nvkm_falcon_pio(falcon, &mem_type, &mem_base);\n\tconst char *type = nvkm_falcon_mem(mem_type);\n\tint xfer_len;\n\n\tif (WARN_ON(!pio || !pio->wr))\n\t\treturn -EINVAL;\n\n\tFLCN_DBG(falcon, \"%s %08x <- %08x bytes at %08x\", type, mem_base, len, img_base);\n\tif (WARN_ON(!len || (len & (pio->min - 1))))\n\t\treturn -EINVAL;\n\n\tpio->wr_init(falcon, port, sec, mem_base);\n\tdo {\n\t\txfer_len = min(len, pio->max);\n\t\tpio->wr(falcon, port, img, xfer_len, tag++);\n\n\t\tif (nvkm_printk_ok(falcon->owner, falcon->user, NV_DBG_TRACE)) {\n\t\t\tfor (img_base = 0; img_base < xfer_len; img_base += 4, mem_base += 4) {\n\t\t\t\tif (((img_base / 4) % 8) == 0)\n\t\t\t\t\tprintk(KERN_INFO \"%s %08x <-\", type, mem_base);\n\t\t\t\tprintk(KERN_CONT \" %08x\", *(u32 *)(img + img_base));\n\t\t\t\tif ((img_base / 4) == 7 && mem_type == IMEM)\n\t\t\t\t\tprintk(KERN_CONT \" %04x\", tag - 1);\n\t\t\t}\n\t\t}\n\n\t\timg += xfer_len;\n\t\tlen -= xfer_len;\n\t} while (len);\n\n\treturn 0;\n}\n\nvoid\nnvkm_falcon_load_imem(struct nvkm_falcon *falcon, void *data, u32 start,\n\t\t      u32 size, u16 tag, u8 port, bool secure)\n{\n\tif (secure && !falcon->secret) {\n\t\tnvkm_warn(falcon->user,\n\t\t\t  \"writing with secure tag on a non-secure falcon!\\n\");\n\t\treturn;\n\t}\n\n\tfalcon->func->load_imem(falcon, data, start, size, tag, port,\n\t\t\t\tsecure);\n}\n\nvoid\nnvkm_falcon_load_dmem(struct nvkm_falcon *falcon, void *data, u32 start,\n\t\t      u32 size, u8 port)\n{\n\tmutex_lock(&falcon->dmem_mutex);\n\n\tfalcon->func->load_dmem(falcon, data, start, size, port);\n\n\tmutex_unlock(&falcon->dmem_mutex);\n}\n\nvoid\nnvkm_falcon_start(struct nvkm_falcon *falcon)\n{\n\tfalcon->func->start(falcon);\n}\n\nint\nnvkm_falcon_reset(struct nvkm_falcon *falcon)\n{\n\tint ret;\n\n\tret = falcon->func->disable(falcon);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\treturn nvkm_falcon_enable(falcon);\n}\n\nstatic int\nnvkm_falcon_oneinit(struct nvkm_falcon *falcon)\n{\n\tconst struct nvkm_falcon_func *func = falcon->func;\n\tconst struct nvkm_subdev *subdev = falcon->owner;\n\tu32 reg;\n\n\tif (!falcon->addr) {\n\t\tfalcon->addr = nvkm_top_addr(subdev->device, subdev->type, subdev->inst);\n\t\tif (WARN_ON(!falcon->addr))\n\t\t\treturn -ENODEV;\n\t}\n\n\treg = nvkm_falcon_rd32(falcon, 0x12c);\n\tfalcon->version = reg & 0xf;\n\tfalcon->secret = (reg >> 4) & 0x3;\n\tfalcon->code.ports = (reg >> 8) & 0xf;\n\tfalcon->data.ports = (reg >> 12) & 0xf;\n\n\treg = nvkm_falcon_rd32(falcon, 0x108);\n\tfalcon->code.limit = (reg & 0x1ff) << 8;\n\tfalcon->data.limit = (reg & 0x3fe00) >> 1;\n\n\tif (func->debug) {\n\t\tu32 val = nvkm_falcon_rd32(falcon, func->debug);\n\t\tfalcon->debug = (val >> 20) & 0x1;\n\t}\n\n\treturn 0;\n}\n\nvoid\nnvkm_falcon_put(struct nvkm_falcon *falcon, struct nvkm_subdev *user)\n{\n\tif (unlikely(!falcon))\n\t\treturn;\n\n\tmutex_lock(&falcon->mutex);\n\tif (falcon->user == user) {\n\t\tnvkm_debug(falcon->user, \"released %s falcon\\n\", falcon->name);\n\t\tfalcon->user = NULL;\n\t}\n\tmutex_unlock(&falcon->mutex);\n}\n\nint\nnvkm_falcon_get(struct nvkm_falcon *falcon, struct nvkm_subdev *user)\n{\n\tint ret = 0;\n\n\tmutex_lock(&falcon->mutex);\n\tif (falcon->user) {\n\t\tnvkm_error(user, \"%s falcon already acquired by %s!\\n\",\n\t\t\t   falcon->name, falcon->user->name);\n\t\tmutex_unlock(&falcon->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tnvkm_debug(user, \"acquired %s falcon\\n\", falcon->name);\n\tif (!falcon->oneinit)\n\t\tret = nvkm_falcon_oneinit(falcon);\n\tfalcon->user = user;\n\tmutex_unlock(&falcon->mutex);\n\treturn ret;\n}\n\nvoid\nnvkm_falcon_dtor(struct nvkm_falcon *falcon)\n{\n}\n\nint\nnvkm_falcon_ctor(const struct nvkm_falcon_func *func,\n\t\t struct nvkm_subdev *subdev, const char *name, u32 addr,\n\t\t struct nvkm_falcon *falcon)\n{\n\tfalcon->func = func;\n\tfalcon->owner = subdev;\n\tfalcon->name = name;\n\tfalcon->addr = addr;\n\tfalcon->addr2 = func->addr2;\n\tmutex_init(&falcon->mutex);\n\tmutex_init(&falcon->dmem_mutex);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}