{
  "module_name": "nouveau_mem.c",
  "hash_id": "b27236079932d3302d35560bf2f397756a0dbae26ad8079fba2b4be328f5b064",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_mem.c",
  "human_readable_source": " \n#include <drm/ttm/ttm_tt.h>\n\n#include \"nouveau_mem.h\"\n#include \"nouveau_drv.h\"\n#include \"nouveau_bo.h\"\n\n\n#include <nvif/class.h>\n#include <nvif/if000a.h>\n#include <nvif/if500b.h>\n#include <nvif/if500d.h>\n#include <nvif/if900b.h>\n#include <nvif/if900d.h>\n\nint\nnouveau_mem_map(struct nouveau_mem *mem,\n\t\tstruct nvif_vmm *vmm, struct nvif_vma *vma)\n{\n\tunion {\n\t\tstruct nv50_vmm_map_v0 nv50;\n\t\tstruct gf100_vmm_map_v0 gf100;\n\t} args;\n\tu32 argc = 0;\n\n\tswitch (vmm->object.oclass) {\n\tcase NVIF_CLASS_VMM_NV04:\n\t\tbreak;\n\tcase NVIF_CLASS_VMM_NV50:\n\t\targs.nv50.version = 0;\n\t\targs.nv50.ro = 0;\n\t\targs.nv50.priv = 0;\n\t\targs.nv50.kind = mem->kind;\n\t\targs.nv50.comp = mem->comp;\n\t\targc = sizeof(args.nv50);\n\t\tbreak;\n\tcase NVIF_CLASS_VMM_GF100:\n\tcase NVIF_CLASS_VMM_GM200:\n\tcase NVIF_CLASS_VMM_GP100:\n\t\targs.gf100.version = 0;\n\t\tif (mem->mem.type & NVIF_MEM_VRAM)\n\t\t\targs.gf100.vol = 0;\n\t\telse\n\t\t\targs.gf100.vol = 1;\n\t\targs.gf100.ro = 0;\n\t\targs.gf100.priv = 0;\n\t\targs.gf100.kind = mem->kind;\n\t\targc = sizeof(args.gf100);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn nvif_vmm_map(vmm, vma->addr, mem->mem.size, &args, argc, &mem->mem, 0);\n}\n\nvoid\nnouveau_mem_fini(struct nouveau_mem *mem)\n{\n\tnvif_vmm_put(&mem->cli->drm->client.vmm.vmm, &mem->vma[1]);\n\tnvif_vmm_put(&mem->cli->drm->client.vmm.vmm, &mem->vma[0]);\n\tmutex_lock(&mem->cli->drm->master.lock);\n\tnvif_mem_dtor(&mem->mem);\n\tmutex_unlock(&mem->cli->drm->master.lock);\n}\n\nint\nnouveau_mem_host(struct ttm_resource *reg, struct ttm_tt *tt)\n{\n\tstruct nouveau_mem *mem = nouveau_mem(reg);\n\tstruct nouveau_cli *cli = mem->cli;\n\tstruct nouveau_drm *drm = cli->drm;\n\tstruct nvif_mmu *mmu = &cli->mmu;\n\tstruct nvif_mem_ram_v0 args = {};\n\tu8 type;\n\tint ret;\n\n\tif (!nouveau_drm_use_coherent_gpu_mapping(drm))\n\t\ttype = drm->ttm.type_ncoh[!!mem->kind];\n\telse\n\t\ttype = drm->ttm.type_host[0];\n\n\tif (mem->kind && !(mmu->type[type].type & NVIF_MEM_KIND))\n\t\tmem->comp = mem->kind = 0;\n\tif (mem->comp && !(mmu->type[type].type & NVIF_MEM_COMP)) {\n\t\tif (mmu->object.oclass >= NVIF_CLASS_MMU_GF100)\n\t\t\tmem->kind = mmu->kind[mem->kind];\n\t\tmem->comp = 0;\n\t}\n\n\tif (tt->sg)\n\t\targs.sgl = tt->sg->sgl;\n\telse\n\t\targs.dma = tt->dma_address;\n\n\tmutex_lock(&drm->master.lock);\n\tret = nvif_mem_ctor_type(mmu, \"ttmHostMem\", cli->mem->oclass, type, PAGE_SHIFT,\n\t\t\t\t reg->size,\n\t\t\t\t &args, sizeof(args), &mem->mem);\n\tmutex_unlock(&drm->master.lock);\n\treturn ret;\n}\n\nint\nnouveau_mem_vram(struct ttm_resource *reg, bool contig, u8 page)\n{\n\tstruct nouveau_mem *mem = nouveau_mem(reg);\n\tstruct nouveau_cli *cli = mem->cli;\n\tstruct nouveau_drm *drm = cli->drm;\n\tstruct nvif_mmu *mmu = &cli->mmu;\n\tu64 size = ALIGN(reg->size, 1 << page);\n\tint ret;\n\n\tmutex_lock(&drm->master.lock);\n\tswitch (cli->mem->oclass) {\n\tcase NVIF_CLASS_MEM_GF100:\n\t\tret = nvif_mem_ctor_type(mmu, \"ttmVram\", cli->mem->oclass,\n\t\t\t\t\t drm->ttm.type_vram, page, size,\n\t\t\t\t\t &(struct gf100_mem_v0) {\n\t\t\t\t\t\t.contig = contig,\n\t\t\t\t\t }, sizeof(struct gf100_mem_v0),\n\t\t\t\t\t &mem->mem);\n\t\tbreak;\n\tcase NVIF_CLASS_MEM_NV50:\n\t\tret = nvif_mem_ctor_type(mmu, \"ttmVram\", cli->mem->oclass,\n\t\t\t\t\t drm->ttm.type_vram, page, size,\n\t\t\t\t\t &(struct nv50_mem_v0) {\n\t\t\t\t\t\t.bankswz = mmu->kind[mem->kind] == 2,\n\t\t\t\t\t\t.contig = contig,\n\t\t\t\t\t }, sizeof(struct nv50_mem_v0),\n\t\t\t\t\t &mem->mem);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOSYS;\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tmutex_unlock(&drm->master.lock);\n\n\treg->start = mem->mem.addr >> PAGE_SHIFT;\n\treturn ret;\n}\n\nvoid\nnouveau_mem_del(struct ttm_resource_manager *man, struct ttm_resource *reg)\n{\n\tstruct nouveau_mem *mem = nouveau_mem(reg);\n\n\tnouveau_mem_fini(mem);\n\tttm_resource_fini(man, reg);\n\tkfree(mem);\n}\n\nint\nnouveau_mem_new(struct nouveau_cli *cli, u8 kind, u8 comp,\n\t\tstruct ttm_resource **res)\n{\n\tstruct nouveau_mem *mem;\n\n\tif (!(mem = kzalloc(sizeof(*mem), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tmem->cli = cli;\n\tmem->kind = kind;\n\tmem->comp = comp;\n\n\t*res = &mem->base;\n\treturn 0;\n}\n\nbool\nnouveau_mem_intersects(struct ttm_resource *res,\n\t\t       const struct ttm_place *place,\n\t\t       size_t size)\n{\n\tu32 num_pages = PFN_UP(size);\n\n\t \n\tif (place->fpfn >= (res->start + num_pages) ||\n\t    (place->lpfn && place->lpfn <= res->start))\n\t\treturn false;\n\n\treturn true;\n}\n\nbool\nnouveau_mem_compatible(struct ttm_resource *res,\n\t\t       const struct ttm_place *place,\n\t\t       size_t size)\n{\n\tu32 num_pages = PFN_UP(size);\n\n\tif (res->start < place->fpfn ||\n\t    (place->lpfn && (res->start + num_pages) > place->lpfn))\n\t\treturn false;\n\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}