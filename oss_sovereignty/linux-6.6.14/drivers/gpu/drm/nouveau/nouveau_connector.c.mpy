{
  "module_name": "nouveau_connector.c",
  "hash_id": "271150c95be198407f965303ed68a8fd356551ab1a9927e2b98868b6286152d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_connector.c",
  "human_readable_source": " \n\n#include <acpi/button.h>\n\n#include <linux/pm_runtime.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_atomic.h>\n\n#include \"nouveau_reg.h\"\n#include \"nouveau_drv.h\"\n#include \"dispnv04/hw.h\"\n#include \"dispnv50/disp.h\"\n#include \"nouveau_acpi.h\"\n\n#include \"nouveau_display.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_crtc.h\"\n\n#include <nvif/class.h>\n#include <nvif/if0011.h>\n\nstruct drm_display_mode *\nnouveau_conn_native_mode(struct drm_connector *connector)\n{\n\tconst struct drm_connector_helper_funcs *helper = connector->helper_private;\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_display_mode *mode, *largest = NULL;\n\tint high_w = 0, high_h = 0, high_v = 0;\n\n\tlist_for_each_entry(mode, &connector->probed_modes, head) {\n\t\tif (helper->mode_valid(connector, mode) != MODE_OK ||\n\t\t    (mode->flags & DRM_MODE_FLAG_INTERLACE))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (mode->type & DRM_MODE_TYPE_PREFERRED) {\n\t\t\tNV_DEBUG(drm, \"native mode from preferred\\n\");\n\t\t\treturn drm_mode_duplicate(dev, mode);\n\t\t}\n\n\t\t \n\t\tif (mode->hdisplay < high_w)\n\t\t\tcontinue;\n\n\t\tif (mode->hdisplay == high_w && mode->vdisplay < high_h)\n\t\t\tcontinue;\n\n\t\tif (mode->hdisplay == high_w && mode->vdisplay == high_h &&\n\t\t    drm_mode_vrefresh(mode) < high_v)\n\t\t\tcontinue;\n\n\t\thigh_w = mode->hdisplay;\n\t\thigh_h = mode->vdisplay;\n\t\thigh_v = drm_mode_vrefresh(mode);\n\t\tlargest = mode;\n\t}\n\n\tNV_DEBUG(drm, \"native mode from largest: %dx%d@%d\\n\",\n\t\t      high_w, high_h, high_v);\n\treturn largest ? drm_mode_duplicate(dev, largest) : NULL;\n}\n\nint\nnouveau_conn_atomic_get_property(struct drm_connector *connector,\n\t\t\t\t const struct drm_connector_state *state,\n\t\t\t\t struct drm_property *property, u64 *val)\n{\n\tstruct nouveau_conn_atom *asyc = nouveau_conn_atom(state);\n\tstruct nouveau_display *disp = nouveau_display(connector->dev);\n\tstruct drm_device *dev = connector->dev;\n\n\tif (property == dev->mode_config.scaling_mode_property)\n\t\t*val = asyc->scaler.mode;\n\telse if (property == disp->underscan_property)\n\t\t*val = asyc->scaler.underscan.mode;\n\telse if (property == disp->underscan_hborder_property)\n\t\t*val = asyc->scaler.underscan.hborder;\n\telse if (property == disp->underscan_vborder_property)\n\t\t*val = asyc->scaler.underscan.vborder;\n\telse if (property == disp->dithering_mode)\n\t\t*val = asyc->dither.mode;\n\telse if (property == disp->dithering_depth)\n\t\t*val = asyc->dither.depth;\n\telse if (property == disp->vibrant_hue_property)\n\t\t*val = asyc->procamp.vibrant_hue;\n\telse if (property == disp->color_vibrance_property)\n\t\t*val = asyc->procamp.color_vibrance;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint\nnouveau_conn_atomic_set_property(struct drm_connector *connector,\n\t\t\t\t struct drm_connector_state *state,\n\t\t\t\t struct drm_property *property, u64 val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_conn_atom *asyc = nouveau_conn_atom(state);\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\n\tif (property == dev->mode_config.scaling_mode_property) {\n\t\tswitch (val) {\n\t\tcase DRM_MODE_SCALE_NONE:\n\t\t\t \n\t\t\tswitch (connector->connector_type) {\n\t\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\t\t \n\t\t\t\tif (disp->disp.object.oclass < NV50_DISP)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DRM_MODE_SCALE_FULLSCREEN:\n\t\tcase DRM_MODE_SCALE_CENTER:\n\t\tcase DRM_MODE_SCALE_ASPECT:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (asyc->scaler.mode != val) {\n\t\t\tasyc->scaler.mode = val;\n\t\t\tasyc->set.scaler = true;\n\t\t}\n\t} else\n\tif (property == disp->underscan_property) {\n\t\tif (asyc->scaler.underscan.mode != val) {\n\t\t\tasyc->scaler.underscan.mode = val;\n\t\t\tasyc->set.scaler = true;\n\t\t}\n\t} else\n\tif (property == disp->underscan_hborder_property) {\n\t\tif (asyc->scaler.underscan.hborder != val) {\n\t\t\tasyc->scaler.underscan.hborder = val;\n\t\t\tasyc->set.scaler = true;\n\t\t}\n\t} else\n\tif (property == disp->underscan_vborder_property) {\n\t\tif (asyc->scaler.underscan.vborder != val) {\n\t\t\tasyc->scaler.underscan.vborder = val;\n\t\t\tasyc->set.scaler = true;\n\t\t}\n\t} else\n\tif (property == disp->dithering_mode) {\n\t\tif (asyc->dither.mode != val) {\n\t\t\tasyc->dither.mode = val;\n\t\t\tasyc->set.dither = true;\n\t\t}\n\t} else\n\tif (property == disp->dithering_depth) {\n\t\tif (asyc->dither.mode != val) {\n\t\t\tasyc->dither.depth = val;\n\t\t\tasyc->set.dither = true;\n\t\t}\n\t} else\n\tif (property == disp->vibrant_hue_property) {\n\t\tif (asyc->procamp.vibrant_hue != val) {\n\t\t\tasyc->procamp.vibrant_hue = val;\n\t\t\tasyc->set.procamp = true;\n\t\t}\n\t} else\n\tif (property == disp->color_vibrance_property) {\n\t\tif (asyc->procamp.color_vibrance != val) {\n\t\t\tasyc->procamp.color_vibrance = val;\n\t\t\tasyc->set.procamp = true;\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid\nnouveau_conn_atomic_destroy_state(struct drm_connector *connector,\n\t\t\t\t  struct drm_connector_state *state)\n{\n\tstruct nouveau_conn_atom *asyc = nouveau_conn_atom(state);\n\t__drm_atomic_helper_connector_destroy_state(&asyc->state);\n\tkfree(asyc);\n}\n\nstruct drm_connector_state *\nnouveau_conn_atomic_duplicate_state(struct drm_connector *connector)\n{\n\tstruct nouveau_conn_atom *armc = nouveau_conn_atom(connector->state);\n\tstruct nouveau_conn_atom *asyc;\n\tif (!(asyc = kmalloc(sizeof(*asyc), GFP_KERNEL)))\n\t\treturn NULL;\n\t__drm_atomic_helper_connector_duplicate_state(connector, &asyc->state);\n\tasyc->dither = armc->dither;\n\tasyc->scaler = armc->scaler;\n\tasyc->procamp = armc->procamp;\n\tasyc->set.mask = 0;\n\treturn &asyc->state;\n}\n\nvoid\nnouveau_conn_reset(struct drm_connector *connector)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_conn_atom *asyc;\n\n\tif (drm_drv_uses_atomic_modeset(connector->dev)) {\n\t\tif (WARN_ON(!(asyc = kzalloc(sizeof(*asyc), GFP_KERNEL))))\n\t\t\treturn;\n\n\t\tif (connector->state)\n\t\t\tnouveau_conn_atomic_destroy_state(connector,\n\t\t\t\t\t\t\t  connector->state);\n\n\t\t__drm_atomic_helper_connector_reset(connector, &asyc->state);\n\t} else {\n\t\tasyc = &nv_connector->properties_state;\n\t}\n\n\tasyc->dither.mode = DITHERING_MODE_AUTO;\n\tasyc->dither.depth = DITHERING_DEPTH_AUTO;\n\tasyc->scaler.mode = DRM_MODE_SCALE_NONE;\n\tasyc->scaler.underscan.mode = UNDERSCAN_OFF;\n\tasyc->procamp.color_vibrance = 150;\n\tasyc->procamp.vibrant_hue = 90;\n\n\tif (nouveau_display(connector->dev)->disp.object.oclass < NV50_DISP) {\n\t\tswitch (connector->connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\t\t \n\t\t\tasyc->scaler.mode = DRM_MODE_SCALE_FULLSCREEN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid\nnouveau_conn_attach_properties(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_conn_atom *armc;\n\n\tif (drm_drv_uses_atomic_modeset(connector->dev))\n\t\tarmc = nouveau_conn_atom(connector->state);\n\telse\n\t\tarmc = &nv_connector->properties_state;\n\n\t \n\tif (connector->connector_type == DRM_MODE_CONNECTOR_DVII)\n\t\tdrm_object_attach_property(&connector->base, dev->mode_config.\n\t\t\t\t\t   dvi_i_subconnector_property, 0);\n\n\t \n\tif (disp->underscan_property &&\n\t    (connector->connector_type == DRM_MODE_CONNECTOR_DVID ||\n\t     connector->connector_type == DRM_MODE_CONNECTOR_DVII ||\n\t     connector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||\n\t     connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort)) {\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   disp->underscan_property,\n\t\t\t\t\t   UNDERSCAN_OFF);\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   disp->underscan_hborder_property, 0);\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   disp->underscan_vborder_property, 0);\n\t}\n\n\t \n\tif (disp->vibrant_hue_property)\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   disp->vibrant_hue_property,\n\t\t\t\t\t   armc->procamp.vibrant_hue);\n\tif (disp->color_vibrance_property)\n\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t   disp->color_vibrance_property,\n\t\t\t\t\t   armc->procamp.color_vibrance);\n\n\t \n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_TV:\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_VGA:\n\t\tif (disp->disp.object.oclass < NV50_DISP)\n\t\t\tbreak;  \n\t\tfallthrough;\n\tdefault:\n\t\tdrm_object_attach_property(&connector->base, dev->mode_config.\n\t\t\t\t\t   scaling_mode_property,\n\t\t\t\t\t   armc->scaler.mode);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_TV:\n\tcase DRM_MODE_CONNECTOR_VGA:\n\t\tbreak;\n\tdefault:\n\t\tif (disp->dithering_mode) {\n\t\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t\t   disp->dithering_mode,\n\t\t\t\t\t\t   armc->dither.mode);\n\t\t}\n\t\tif (disp->dithering_depth) {\n\t\t\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\t\t   disp->dithering_depth,\n\t\t\t\t\t\t   armc->dither.depth);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nMODULE_PARM_DESC(tv_disable, \"Disable TV-out detection\");\nint nouveau_tv_disable = 0;\nmodule_param_named(tv_disable, nouveau_tv_disable, int, 0400);\n\nMODULE_PARM_DESC(ignorelid, \"Ignore ACPI lid status\");\nint nouveau_ignorelid = 0;\nmodule_param_named(ignorelid, nouveau_ignorelid, int, 0400);\n\nMODULE_PARM_DESC(duallink, \"Allow dual-link TMDS (default: enabled)\");\nint nouveau_duallink = 1;\nmodule_param_named(duallink, nouveau_duallink, int, 0400);\n\nMODULE_PARM_DESC(hdmimhz, \"Force a maximum HDMI pixel clock (in MHz)\");\nint nouveau_hdmimhz = 0;\nmodule_param_named(hdmimhz, nouveau_hdmimhz, int, 0400);\n\nstruct nouveau_encoder *\nfind_encoder(struct drm_connector *connector, int type)\n{\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct drm_encoder *enc;\n\n\tdrm_connector_for_each_possible_encoder(connector, enc) {\n\t\tnv_encoder = nouveau_encoder(enc);\n\n\t\tif (type == DCB_OUTPUT_ANY ||\n\t\t    (nv_encoder->dcb && nv_encoder->dcb->type == type))\n\t\t\treturn nv_encoder;\n\t}\n\n\treturn NULL;\n}\n\nstatic void\nnouveau_connector_destroy(struct drm_connector *connector)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tnvif_event_dtor(&nv_connector->irq);\n\tnvif_event_dtor(&nv_connector->hpd);\n\tkfree(nv_connector->edid);\n\tdrm_connector_unregister(connector);\n\tdrm_connector_cleanup(connector);\n\tif (nv_connector->aux.transfer) {\n\t\tdrm_dp_cec_unregister_connector(&nv_connector->aux);\n\t\tkfree(nv_connector->aux.name);\n\t}\n\tnvif_conn_dtor(&nv_connector->conn);\n\tkfree(connector);\n}\n\nstatic struct nouveau_encoder *\nnouveau_connector_ddc_detect(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct nouveau_encoder *nv_encoder = NULL, *found = NULL;\n\tstruct drm_encoder *encoder;\n\tint ret;\n\tbool switcheroo_ddc = false;\n\n\tdrm_connector_for_each_possible_encoder(connector, encoder) {\n\t\tnv_encoder = nouveau_encoder(encoder);\n\n\t\tswitch (nv_encoder->dcb->type) {\n\t\tcase DCB_OUTPUT_DP:\n\t\t\tret = nouveau_dp_detect(nouveau_connector(connector),\n\t\t\t\t\t\tnv_encoder);\n\t\t\tif (ret == NOUVEAU_DP_MST)\n\t\t\t\treturn NULL;\n\t\t\telse if (ret == NOUVEAU_DP_SST)\n\t\t\t\tfound = nv_encoder;\n\n\t\t\tbreak;\n\t\tcase DCB_OUTPUT_LVDS:\n\t\t\tswitcheroo_ddc = !!(vga_switcheroo_handler_flags() &\n\t\t\t\t\t    VGA_SWITCHEROO_CAN_SWITCH_DDC);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (!nv_encoder->i2c)\n\t\t\t\tbreak;\n\n\t\t\tif (switcheroo_ddc)\n\t\t\t\tvga_switcheroo_lock_ddc(pdev);\n\t\t\tif (nvkm_probe_i2c(nv_encoder->i2c, 0x50))\n\t\t\t\tfound = nv_encoder;\n\t\t\tif (switcheroo_ddc)\n\t\t\t\tvga_switcheroo_unlock_ddc(pdev);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}\n\nstatic struct nouveau_encoder *\nnouveau_connector_of_detect(struct drm_connector *connector)\n{\n#ifdef __powerpc__\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct device_node *cn, *dn = pci_device_to_OF_node(pdev);\n\n\tif (!dn ||\n\t    !((nv_encoder = find_encoder(connector, DCB_OUTPUT_TMDS)) ||\n\t      (nv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG))))\n\t\treturn NULL;\n\n\tfor_each_child_of_node(dn, cn) {\n\t\tconst char *name = of_get_property(cn, \"name\", NULL);\n\t\tconst void *edid = of_get_property(cn, \"EDID\", NULL);\n\t\tint idx = name ? name[strlen(name) - 1] - 'A' : 0;\n\n\t\tif (nv_encoder->dcb->i2c_index == idx && edid) {\n\t\t\tnv_connector->edid =\n\t\t\t\tkmemdup(edid, EDID_LENGTH, GFP_KERNEL);\n\t\t\tof_node_put(cn);\n\t\t\treturn nv_encoder;\n\t\t}\n\t}\n#endif\n\treturn NULL;\n}\n\nstatic void\nnouveau_connector_set_encoder(struct drm_connector *connector,\n\t\t\t      struct nouveau_encoder *nv_encoder)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct drm_device *dev = connector->dev;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tif (nv_connector->detected_encoder == nv_encoder)\n\t\treturn;\n\tnv_connector->detected_encoder = nv_encoder;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_TESLA) {\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_DP)\n\t\t\tconnector->interlace_allowed =\n\t\t\t\tnv_encoder->caps.dp_interlace;\n\t\telse\n\t\t\tconnector->interlace_allowed =\n\t\t\t\tdrm->client.device.info.family < NV_DEVICE_INFO_V0_VOLTA;\n\t\tconnector->doublescan_allowed = true;\n\t} else\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||\n\t    nv_encoder->dcb->type == DCB_OUTPUT_TMDS) {\n\t\tconnector->doublescan_allowed = false;\n\t\tconnector->interlace_allowed = false;\n\t} else {\n\t\tconnector->doublescan_allowed = true;\n\t\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_KELVIN ||\n\t\t    (drm->client.device.info.family == NV_DEVICE_INFO_V0_CELSIUS &&\n\t\t     (pdev->device & 0x0ff0) != 0x0100 &&\n\t\t     (pdev->device & 0x0ff0) != 0x0150))\n\t\t\t \n\t\t\tconnector->interlace_allowed = false;\n\t\telse\n\t\t\tconnector->interlace_allowed = true;\n\t}\n\n\tif (nv_connector->type == DCB_CONNECTOR_DVI_I) {\n\t\tdrm_object_property_set_value(&connector->base,\n\t\t\tdev->mode_config.dvi_i_subconnector_property,\n\t\t\tnv_encoder->dcb->type == DCB_OUTPUT_TMDS ?\n\t\t\tDRM_MODE_SUBCONNECTOR_DVID :\n\t\t\tDRM_MODE_SUBCONNECTOR_DVIA);\n\t}\n}\n\nstatic void\nnouveau_connector_set_edid(struct nouveau_connector *nv_connector,\n\t\t\t   struct edid *edid)\n{\n\tif (nv_connector->edid != edid) {\n\t\tstruct edid *old_edid = nv_connector->edid;\n\n\t\tdrm_connector_update_edid_property(&nv_connector->base, edid);\n\t\tkfree(old_edid);\n\t\tnv_connector->edid = edid;\n\t}\n}\n\nstatic enum drm_connector_status\nnouveau_connector_detect(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = NULL;\n\tstruct nouveau_encoder *nv_partner;\n\tstruct i2c_adapter *i2c;\n\tint type;\n\tint ret;\n\tenum drm_connector_status conn_status = connector_status_disconnected;\n\n\t \n\tif (drm_kms_helper_is_poll_worker()) {\n\t\tpm_runtime_get_noresume(dev->dev);\n\t} else {\n\t\tret = pm_runtime_get_sync(dev->dev);\n\t\tif (ret < 0 && ret != -EACCES) {\n\t\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\t\tnouveau_connector_set_edid(nv_connector, NULL);\n\t\t\treturn conn_status;\n\t\t}\n\t}\n\n\tnv_encoder = nouveau_connector_ddc_detect(connector);\n\tif (nv_encoder && (i2c = nv_encoder->i2c) != NULL) {\n\t\tstruct edid *new_edid;\n\n\t\tif ((vga_switcheroo_handler_flags() &\n\t\t     VGA_SWITCHEROO_CAN_SWITCH_DDC) &&\n\t\t    nv_connector->type == DCB_CONNECTOR_LVDS)\n\t\t\tnew_edid = drm_get_edid_switcheroo(connector, i2c);\n\t\telse\n\t\t\tnew_edid = drm_get_edid(connector, i2c);\n\n\t\tnouveau_connector_set_edid(nv_connector, new_edid);\n\t\tif (!nv_connector->edid) {\n\t\t\tNV_ERROR(drm, \"DDC responded, but no EDID for %s\\n\",\n\t\t\t\t connector->name);\n\t\t\tgoto detect_analog;\n\t\t}\n\n\t\t \n\t\tnv_partner = NULL;\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)\n\t\t\tnv_partner = find_encoder(connector, DCB_OUTPUT_ANALOG);\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_ANALOG)\n\t\t\tnv_partner = find_encoder(connector, DCB_OUTPUT_TMDS);\n\n\t\tif (nv_partner && ((nv_encoder->dcb->type == DCB_OUTPUT_ANALOG &&\n\t\t\t\t    nv_partner->dcb->type == DCB_OUTPUT_TMDS) ||\n\t\t\t\t   (nv_encoder->dcb->type == DCB_OUTPUT_TMDS &&\n\t\t\t\t    nv_partner->dcb->type == DCB_OUTPUT_ANALOG))) {\n\t\t\tif (nv_connector->edid->input & DRM_EDID_INPUT_DIGITAL)\n\t\t\t\ttype = DCB_OUTPUT_TMDS;\n\t\t\telse\n\t\t\t\ttype = DCB_OUTPUT_ANALOG;\n\n\t\t\tnv_encoder = find_encoder(connector, type);\n\t\t}\n\n\t\tnouveau_connector_set_encoder(connector, nv_encoder);\n\t\tconn_status = connector_status_connected;\n\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_DP)\n\t\t\tdrm_dp_cec_set_edid(&nv_connector->aux, nv_connector->edid);\n\n\t\tgoto out;\n\t} else {\n\t\tnouveau_connector_set_edid(nv_connector, NULL);\n\t}\n\n\tnv_encoder = nouveau_connector_of_detect(connector);\n\tif (nv_encoder) {\n\t\tnouveau_connector_set_encoder(connector, nv_encoder);\n\t\tconn_status = connector_status_connected;\n\t\tgoto out;\n\t}\n\ndetect_analog:\n\tnv_encoder = find_encoder(connector, DCB_OUTPUT_ANALOG);\n\tif (!nv_encoder && !nouveau_tv_disable)\n\t\tnv_encoder = find_encoder(connector, DCB_OUTPUT_TV);\n\tif (nv_encoder && force) {\n\t\tstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\n\t\tconst struct drm_encoder_helper_funcs *helper =\n\t\t\t\t\t\tencoder->helper_private;\n\n\t\tif (helper->detect(encoder, connector) ==\n\t\t\t\t\t\tconnector_status_connected) {\n\t\t\tnouveau_connector_set_encoder(connector, nv_encoder);\n\t\t\tconn_status = connector_status_connected;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n out:\n\tif (!nv_connector->edid)\n\t\tdrm_dp_cec_unset_edid(&nv_connector->aux);\n\n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n\n\treturn conn_status;\n}\n\nstatic enum drm_connector_status\nnouveau_connector_detect_lvds(struct drm_connector *connector, bool force)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = NULL;\n\tstruct edid *edid = NULL;\n\tenum drm_connector_status status = connector_status_disconnected;\n\n\tnv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);\n\tif (!nv_encoder)\n\t\tgoto out;\n\n\t \n\tif (!drm->vbios.fp_no_ddc) {\n\t\tstatus = nouveau_connector_detect(connector, force);\n\t\tif (status == connector_status_connected) {\n\t\t\tedid = nv_connector->edid;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (nv_encoder->dcb->lvdsconf.use_acpi_for_edid) {\n\t\tedid = nouveau_acpi_edid(dev, connector);\n\t\tif (edid) {\n\t\t\tstatus = connector_status_connected;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (nouveau_bios_fp_mode(dev, NULL) && (drm->vbios.fp_no_ddc ||\n\t    nv_encoder->dcb->lvdsconf.use_straps_for_mode)) {\n\t\tstatus = connector_status_connected;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!drm->vbios.fp_no_ddc) {\n\t\tedid = (struct edid *)nouveau_bios_embedded_edid(dev);\n\t\tif (edid) {\n\t\t\tedid = kmemdup(edid, EDID_LENGTH, GFP_KERNEL);\n\t\t\tif (edid)\n\t\t\t\tstatus = connector_status_connected;\n\t\t}\n\t}\n\nout:\n#if defined(CONFIG_ACPI_BUTTON) || \\\n\t(defined(CONFIG_ACPI_BUTTON_MODULE) && defined(MODULE))\n\tif (status == connector_status_connected &&\n\t    !nouveau_ignorelid && !acpi_lid_open())\n\t\tstatus = connector_status_unknown;\n#endif\n\n\tnouveau_connector_set_edid(nv_connector, edid);\n\tif (nv_encoder)\n\t\tnouveau_connector_set_encoder(connector, nv_encoder);\n\treturn status;\n}\n\nstatic void\nnouveau_connector_force(struct drm_connector *connector)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder;\n\tint type;\n\n\tif (nv_connector->type == DCB_CONNECTOR_DVI_I) {\n\t\tif (connector->force == DRM_FORCE_ON_DIGITAL)\n\t\t\ttype = DCB_OUTPUT_TMDS;\n\t\telse\n\t\t\ttype = DCB_OUTPUT_ANALOG;\n\t} else\n\t\ttype = DCB_OUTPUT_ANY;\n\n\tnv_encoder = find_encoder(connector, type);\n\tif (!nv_encoder) {\n\t\tNV_ERROR(drm, \"can't find encoder to force %s on!\\n\",\n\t\t\t connector->name);\n\t\tconnector->status = connector_status_disconnected;\n\t\treturn;\n\t}\n\n\tnouveau_connector_set_encoder(connector, nv_encoder);\n}\n\nstatic int\nnouveau_connector_set_property(struct drm_connector *connector,\n\t\t\t       struct drm_property *property, uint64_t value)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\n\tstruct nouveau_conn_atom *asyc = &nv_connector->properties_state;\n\tstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\n\tint ret;\n\n\tret = connector->funcs->atomic_set_property(&nv_connector->base,\n\t\t\t\t\t\t    &asyc->state,\n\t\t\t\t\t\t    property, value);\n\tif (ret) {\n\t\tif (nv_encoder && nv_encoder->dcb->type == DCB_OUTPUT_TV)\n\t\t\treturn get_slave_funcs(encoder)->set_property(\n\t\t\t\tencoder, connector, property, value);\n\t\treturn ret;\n\t}\n\n\tnv_connector->scaling_mode = asyc->scaler.mode;\n\tnv_connector->dithering_mode = asyc->dither.mode;\n\n\tif (connector->encoder && connector->encoder->crtc) {\n\t\tret = drm_crtc_helper_set_mode(connector->encoder->crtc,\n\t\t\t\t\t      &connector->encoder->crtc->mode,\n\t\t\t\t\t       connector->encoder->crtc->x,\n\t\t\t\t\t       connector->encoder->crtc->y,\n\t\t\t\t\t       NULL);\n\t\tif (!ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct moderec {\n\tint hdisplay;\n\tint vdisplay;\n};\n\nstatic struct moderec scaler_modes[] = {\n\t{ 1920, 1200 },\n\t{ 1920, 1080 },\n\t{ 1680, 1050 },\n\t{ 1600, 1200 },\n\t{ 1400, 1050 },\n\t{ 1280, 1024 },\n\t{ 1280, 960 },\n\t{ 1152, 864 },\n\t{ 1024, 768 },\n\t{ 800, 600 },\n\t{ 720, 400 },\n\t{ 640, 480 },\n\t{ 640, 400 },\n\t{ 640, 350 },\n\t{}\n};\n\nstatic int\nnouveau_connector_scaler_modes_add(struct drm_connector *connector)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct drm_display_mode *native = nv_connector->native_mode, *m;\n\tstruct drm_device *dev = connector->dev;\n\tstruct moderec *mode = &scaler_modes[0];\n\tint modes = 0;\n\n\tif (!native)\n\t\treturn 0;\n\n\twhile (mode->hdisplay) {\n\t\tif (mode->hdisplay <= native->hdisplay &&\n\t\t    mode->vdisplay <= native->vdisplay &&\n\t\t    (mode->hdisplay != native->hdisplay ||\n\t\t     mode->vdisplay != native->vdisplay)) {\n\t\t\tm = drm_cvt_mode(dev, mode->hdisplay, mode->vdisplay,\n\t\t\t\t\t drm_mode_vrefresh(native), false,\n\t\t\t\t\t false, false);\n\t\t\tif (!m)\n\t\t\t\tcontinue;\n\n\t\t\tdrm_mode_probed_add(connector, m);\n\t\t\tmodes++;\n\t\t}\n\n\t\tmode++;\n\t}\n\n\treturn modes;\n}\n\nstatic void\nnouveau_connector_detect_depth(struct drm_connector *connector)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\n\tstruct nvbios *bios = &drm->vbios;\n\tstruct drm_display_mode *mode = nv_connector->native_mode;\n\tbool duallink;\n\n\t \n\tif (nv_connector->edid && connector->display_info.bpc)\n\t\treturn;\n\n\t \n\tif (nv_connector->type == DCB_CONNECTOR_eDP) {\n\t\tconnector->display_info.bpc = 6;\n\t\treturn;\n\t}\n\n\t \n\tif (nv_encoder->dcb->type != DCB_OUTPUT_LVDS) {\n\t\tconnector->display_info.bpc = 8;\n\t\treturn;\n\t}\n\n\tconnector->display_info.bpc = 6;\n\n\t \n\tif (bios->fp_no_ddc) {\n\t\tif (bios->fp.if_is_24bit)\n\t\t\tconnector->display_info.bpc = 8;\n\t\treturn;\n\t}\n\n\t \n\tif (nv_connector->edid &&\n\t    nv_connector->type == DCB_CONNECTOR_LVDS_SPWG)\n\t\tduallink = ((u8 *)nv_connector->edid)[121] == 2;\n\telse\n\t\tduallink = mode->clock >= bios->fp.duallink_transition_clk;\n\n\tif ((!duallink && (bios->fp.strapless_is_24bit & 1)) ||\n\t    ( duallink && (bios->fp.strapless_is_24bit & 2)))\n\t\tconnector->display_info.bpc = 8;\n}\n\nstatic int\nnouveau_connector_late_register(struct drm_connector *connector)\n{\n\tint ret;\n\n\tret = nouveau_backlight_init(connector);\n\tif (ret)\n\t\treturn ret;\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort) {\n\t\tret = drm_dp_aux_register(&nouveau_connector(connector)->aux);\n\t\tif (ret)\n\t\t\tgoto backlight_fini;\n\t}\n\n\treturn 0;\nbacklight_fini:\n\tnouveau_backlight_fini(connector);\n\treturn ret;\n}\n\nstatic void\nnouveau_connector_early_unregister(struct drm_connector *connector)\n{\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP ||\n\t    connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort)\n\t\tdrm_dp_aux_unregister(&nouveau_connector(connector)->aux);\n\n\tnouveau_backlight_fini(connector);\n}\n\nstatic int\nnouveau_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\n\tstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\n\tint ret = 0;\n\n\t \n\tif (nv_connector->native_mode) {\n\t\tdrm_mode_destroy(dev, nv_connector->native_mode);\n\t\tnv_connector->native_mode = NULL;\n\t}\n\n\tif (nv_connector->edid)\n\t\tret = drm_add_edid_modes(connector, nv_connector->edid);\n\telse\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS &&\n\t    (nv_encoder->dcb->lvdsconf.use_straps_for_mode ||\n\t     drm->vbios.fp_no_ddc) && nouveau_bios_fp_mode(dev, NULL)) {\n\t\tstruct drm_display_mode mode;\n\n\t\tnouveau_bios_fp_mode(dev, &mode);\n\t\tnv_connector->native_mode = drm_mode_duplicate(dev, &mode);\n\t}\n\n\t \n\tif (connector->connector_type != DRM_MODE_CONNECTOR_LVDS)\n\t\tnouveau_connector_detect_depth(connector);\n\n\t \n\tif (!nv_connector->native_mode)\n\t\tnv_connector->native_mode = nouveau_conn_native_mode(connector);\n\tif (ret == 0 && nv_connector->native_mode) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(dev, nv_connector->native_mode);\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tret = 1;\n\t}\n\n\t \n\tif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS && nv_connector->native_mode)\n\t\tnouveau_connector_detect_depth(connector);\n\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_TV)\n\t\tret = get_slave_funcs(encoder)->get_modes(encoder, connector);\n\n\tif (nv_connector->type == DCB_CONNECTOR_LVDS ||\n\t    nv_connector->type == DCB_CONNECTOR_LVDS_SPWG ||\n\t    nv_connector->type == DCB_CONNECTOR_eDP)\n\t\tret += nouveau_connector_scaler_modes_add(connector);\n\n\treturn ret;\n}\n\nstatic unsigned\nget_tmds_link_bandwidth(struct drm_connector *connector)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct dcb_output *dcb = nv_connector->detected_encoder->dcb;\n\tstruct drm_display_info *info = NULL;\n\tunsigned duallink_scale =\n\t\tnouveau_duallink && nv_encoder->dcb->duallink_possible ? 2 : 1;\n\n\tif (drm_detect_hdmi_monitor(nv_connector->edid)) {\n\t\tinfo = &nv_connector->base.display_info;\n\t\tduallink_scale = 1;\n\t}\n\n\tif (info) {\n\t\tif (nouveau_hdmimhz > 0)\n\t\t\treturn nouveau_hdmimhz * 1000;\n\t\t \n\t\tif (drm->client.device.info.chipset >= 0x120) {\n\t\t\tconst int max_tmds_clock =\n\t\t\t\tinfo->hdmi.scdc.scrambling.supported ?\n\t\t\t\t594000 : 340000;\n\t\t\treturn info->max_tmds_clock ?\n\t\t\t\tmin(info->max_tmds_clock, max_tmds_clock) :\n\t\t\t\tmax_tmds_clock;\n\t\t}\n\t\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_KEPLER)\n\t\t\treturn 297000;\n\t\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_FERMI)\n\t\t\treturn 225000;\n\t}\n\n\tif (dcb->location != DCB_LOC_ON_CHIP ||\n\t    drm->client.device.info.chipset >= 0x46)\n\t\treturn 165000 * duallink_scale;\n\telse if (drm->client.device.info.chipset >= 0x40)\n\t\treturn 155000 * duallink_scale;\n\telse if (drm->client.device.info.chipset >= 0x18)\n\t\treturn 135000 * duallink_scale;\n\telse\n\t\treturn 112000 * duallink_scale;\n}\n\nstatic enum drm_mode_status\nnouveau_connector_mode_valid(struct drm_connector *connector,\n\t\t\t     struct drm_display_mode *mode)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_encoder *nv_encoder = nv_connector->detected_encoder;\n\tstruct drm_encoder *encoder = to_drm_encoder(nv_encoder);\n\tunsigned int min_clock = 25000, max_clock = min_clock, clock = mode->clock;\n\n\tswitch (nv_encoder->dcb->type) {\n\tcase DCB_OUTPUT_LVDS:\n\t\tif (nv_connector->native_mode &&\n\t\t    (mode->hdisplay > nv_connector->native_mode->hdisplay ||\n\t\t     mode->vdisplay > nv_connector->native_mode->vdisplay))\n\t\t\treturn MODE_PANEL;\n\n\t\tmin_clock = 0;\n\t\tmax_clock = 400000;\n\t\tbreak;\n\tcase DCB_OUTPUT_TMDS:\n\t\tmax_clock = get_tmds_link_bandwidth(connector);\n\t\tbreak;\n\tcase DCB_OUTPUT_ANALOG:\n\t\tmax_clock = nv_encoder->dcb->crtconf.maxfreq;\n\t\tif (!max_clock)\n\t\t\tmax_clock = 350000;\n\t\tbreak;\n\tcase DCB_OUTPUT_TV:\n\t\treturn get_slave_funcs(encoder)->mode_valid(encoder, mode);\n\tcase DCB_OUTPUT_DP:\n\t\treturn nv50_dp_mode_valid(nv_encoder, mode, NULL);\n\tdefault:\n\t\tBUG();\n\t\treturn MODE_BAD;\n\t}\n\n\tif ((mode->flags & DRM_MODE_FLAG_3D_MASK) == DRM_MODE_FLAG_3D_FRAME_PACKING)\n\t\tclock *= 2;\n\n\tif (clock < min_clock)\n\t\treturn MODE_CLOCK_LOW;\n\tif (clock > max_clock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\treturn MODE_OK;\n}\n\nstatic struct drm_encoder *\nnouveau_connector_best_encoder(struct drm_connector *connector)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\n\tif (nv_connector->detected_encoder)\n\t\treturn to_drm_encoder(nv_connector->detected_encoder);\n\n\treturn NULL;\n}\n\nstatic int\nnouveau_connector_atomic_check(struct drm_connector *connector, struct drm_atomic_state *state)\n{\n\tstruct nouveau_connector *nv_conn = nouveau_connector(connector);\n\tstruct drm_connector_state *conn_state =\n\t\tdrm_atomic_get_new_connector_state(state, connector);\n\n\tif (!nv_conn->dp_encoder || !nv50_has_mst(nouveau_drm(connector->dev)))\n\t\treturn 0;\n\n\treturn drm_dp_mst_root_conn_atomic_check(conn_state, &nv_conn->dp_encoder->dp.mstm->mgr);\n}\n\nstatic const struct drm_connector_helper_funcs\nnouveau_connector_helper_funcs = {\n\t.get_modes = nouveau_connector_get_modes,\n\t.mode_valid = nouveau_connector_mode_valid,\n\t.best_encoder = nouveau_connector_best_encoder,\n\t.atomic_check = nouveau_connector_atomic_check,\n};\n\nstatic const struct drm_connector_funcs\nnouveau_connector_funcs = {\n\t.dpms = drm_helper_connector_dpms,\n\t.reset = nouveau_conn_reset,\n\t.detect = nouveau_connector_detect,\n\t.force = nouveau_connector_force,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = nouveau_connector_set_property,\n\t.destroy = nouveau_connector_destroy,\n\t.atomic_duplicate_state = nouveau_conn_atomic_duplicate_state,\n\t.atomic_destroy_state = nouveau_conn_atomic_destroy_state,\n\t.atomic_set_property = nouveau_conn_atomic_set_property,\n\t.atomic_get_property = nouveau_conn_atomic_get_property,\n\t.late_register = nouveau_connector_late_register,\n\t.early_unregister = nouveau_connector_early_unregister,\n};\n\nstatic const struct drm_connector_funcs\nnouveau_connector_funcs_lvds = {\n\t.dpms = drm_helper_connector_dpms,\n\t.reset = nouveau_conn_reset,\n\t.detect = nouveau_connector_detect_lvds,\n\t.force = nouveau_connector_force,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.set_property = nouveau_connector_set_property,\n\t.destroy = nouveau_connector_destroy,\n\t.atomic_duplicate_state = nouveau_conn_atomic_duplicate_state,\n\t.atomic_destroy_state = nouveau_conn_atomic_destroy_state,\n\t.atomic_set_property = nouveau_conn_atomic_set_property,\n\t.atomic_get_property = nouveau_conn_atomic_get_property,\n\t.late_register = nouveau_connector_late_register,\n\t.early_unregister = nouveau_connector_early_unregister,\n};\n\nvoid\nnouveau_connector_hpd(struct nouveau_connector *nv_connector, u64 bits)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(nv_connector->base.dev);\n\tu32 mask = drm_connector_mask(&nv_connector->base);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&drm->hpd_lock, flags);\n\tif (!(drm->hpd_pending & mask)) {\n\t\tnv_connector->hpd_pending |= bits;\n\t\tdrm->hpd_pending |= mask;\n\t\tschedule_work(&drm->hpd_work);\n\t}\n\tspin_unlock_irqrestore(&drm->hpd_lock, flags);\n}\n\nstatic int\nnouveau_connector_irq(struct nvif_event *event, void *repv, u32 repc)\n{\n\tstruct nouveau_connector *nv_connector = container_of(event, typeof(*nv_connector), irq);\n\n\tschedule_work(&nv_connector->irq_work);\n\treturn NVIF_EVENT_KEEP;\n}\n\nstatic int\nnouveau_connector_hotplug(struct nvif_event *event, void *repv, u32 repc)\n{\n\tstruct nouveau_connector *nv_connector = container_of(event, typeof(*nv_connector), hpd);\n\tstruct nvif_conn_event_v0 *rep = repv;\n\n\tnouveau_connector_hpd(nv_connector, rep->types);\n\treturn NVIF_EVENT_KEEP;\n}\n\nstatic ssize_t\nnouveau_connector_aux_xfer(struct drm_dp_aux *obj, struct drm_dp_aux_msg *msg)\n{\n\tstruct nouveau_connector *nv_connector =\n\t\tcontainer_of(obj, typeof(*nv_connector), aux);\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct nvkm_i2c_aux *aux;\n\tu8 size = msg->size;\n\tint ret;\n\n\tnv_encoder = find_encoder(&nv_connector->base, DCB_OUTPUT_DP);\n\tif (!nv_encoder || !(aux = nv_encoder->aux))\n\t\treturn -ENODEV;\n\tif (WARN_ON(msg->size > 16))\n\t\treturn -E2BIG;\n\n\tret = nvkm_i2c_aux_acquire(aux);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_i2c_aux_xfer(aux, false, msg->request, msg->address,\n\t\t\t\tmsg->buffer, &size);\n\tnvkm_i2c_aux_release(aux);\n\tif (ret >= 0) {\n\t\tmsg->reply = ret;\n\t\treturn size;\n\t}\n\n\treturn ret;\n}\n\nstatic int\ndrm_conntype_from_dcb(enum dcb_connector_type dcb)\n{\n\tswitch (dcb) {\n\tcase DCB_CONNECTOR_VGA      : return DRM_MODE_CONNECTOR_VGA;\n\tcase DCB_CONNECTOR_TV_0     :\n\tcase DCB_CONNECTOR_TV_1     :\n\tcase DCB_CONNECTOR_TV_3     : return DRM_MODE_CONNECTOR_TV;\n\tcase DCB_CONNECTOR_DMS59_0  :\n\tcase DCB_CONNECTOR_DMS59_1  :\n\tcase DCB_CONNECTOR_DVI_I    : return DRM_MODE_CONNECTOR_DVII;\n\tcase DCB_CONNECTOR_DVI_D    : return DRM_MODE_CONNECTOR_DVID;\n\tcase DCB_CONNECTOR_LVDS     :\n\tcase DCB_CONNECTOR_LVDS_SPWG: return DRM_MODE_CONNECTOR_LVDS;\n\tcase DCB_CONNECTOR_DMS59_DP0:\n\tcase DCB_CONNECTOR_DMS59_DP1:\n\tcase DCB_CONNECTOR_DP       :\n\tcase DCB_CONNECTOR_mDP      :\n\tcase DCB_CONNECTOR_USB_C    : return DRM_MODE_CONNECTOR_DisplayPort;\n\tcase DCB_CONNECTOR_eDP      : return DRM_MODE_CONNECTOR_eDP;\n\tcase DCB_CONNECTOR_HDMI_0   :\n\tcase DCB_CONNECTOR_HDMI_1   :\n\tcase DCB_CONNECTOR_HDMI_C   : return DRM_MODE_CONNECTOR_HDMIA;\n\tcase DCB_CONNECTOR_WFD\t    : return DRM_MODE_CONNECTOR_VIRTUAL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn DRM_MODE_CONNECTOR_Unknown;\n}\n\nstruct drm_connector *\nnouveau_connector_create(struct drm_device *dev,\n\t\t\t const struct dcb_output *dcbe)\n{\n\tconst struct drm_connector_funcs *funcs = &nouveau_connector_funcs;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tstruct nouveau_connector *nv_connector = NULL;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tchar aux_name[48] = {0};\n\tint index = dcbe->connector;\n\tint type, ret = 0;\n\tbool dummy;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tnouveau_for_each_non_mst_connector_iter(connector, &conn_iter) {\n\t\tnv_connector = nouveau_connector(connector);\n\t\tif (nv_connector->index == index) {\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\treturn connector;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tnv_connector = kzalloc(sizeof(*nv_connector), GFP_KERNEL);\n\tif (!nv_connector)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconnector = &nv_connector->base;\n\tnv_connector->index = index;\n\tINIT_WORK(&nv_connector->irq_work, nouveau_dp_irq);\n\n\t \n\tnv_connector->dcb = olddcb_conn(dev, index);\n\tif (nv_connector->dcb) {\n\t\tu32 entry = ROM16(nv_connector->dcb[0]);\n\t\tif (olddcb_conntab(dev)[3] >= 4)\n\t\t\tentry |= (u32)ROM16(nv_connector->dcb[2]) << 16;\n\n\t\tnv_connector->type = nv_connector->dcb[0];\n\t\tif (drm_conntype_from_dcb(nv_connector->type) ==\n\t\t\t\t\t  DRM_MODE_CONNECTOR_Unknown) {\n\t\t\tNV_WARN(drm, \"unknown connector type %02x\\n\",\n\t\t\t\tnv_connector->type);\n\t\t\tnv_connector->type = DCB_CONNECTOR_NONE;\n\t\t}\n\n\t\t \n\t\tif (nv_match_device(dev, 0x0421, 0x1458, 0x344c)) {\n\t\t\tif (nv_connector->type == DCB_CONNECTOR_HDMI_1)\n\t\t\t\tnv_connector->type = DCB_CONNECTOR_DVI_I;\n\t\t}\n\n\t\t \n\t\tif (nv_match_device(dev, 0x0402, 0x1458, 0x3455)) {\n\t\t\tif (nv_connector->type == DCB_CONNECTOR_HDMI_1)\n\t\t\t\tnv_connector->type = DCB_CONNECTOR_DVI_I;\n\t\t}\n\t} else {\n\t\tnv_connector->type = DCB_CONNECTOR_NONE;\n\t}\n\n\t \n\tif (nv_connector->type == DCB_CONNECTOR_NONE) {\n\t\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\t\tstruct dcb_table *dcbt = &drm->vbios.dcb;\n\t\tu32 encoders = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < dcbt->entries; i++) {\n\t\t\tif (dcbt->entry[i].connector == nv_connector->index)\n\t\t\t\tencoders |= (1 << dcbt->entry[i].type);\n\t\t}\n\n\t\tif (encoders & (1 << DCB_OUTPUT_DP)) {\n\t\t\tif (encoders & (1 << DCB_OUTPUT_TMDS))\n\t\t\t\tnv_connector->type = DCB_CONNECTOR_DP;\n\t\t\telse\n\t\t\t\tnv_connector->type = DCB_CONNECTOR_eDP;\n\t\t} else\n\t\tif (encoders & (1 << DCB_OUTPUT_TMDS)) {\n\t\t\tif (encoders & (1 << DCB_OUTPUT_ANALOG))\n\t\t\t\tnv_connector->type = DCB_CONNECTOR_DVI_I;\n\t\t\telse\n\t\t\t\tnv_connector->type = DCB_CONNECTOR_DVI_D;\n\t\t} else\n\t\tif (encoders & (1 << DCB_OUTPUT_ANALOG)) {\n\t\t\tnv_connector->type = DCB_CONNECTOR_VGA;\n\t\t} else\n\t\tif (encoders & (1 << DCB_OUTPUT_LVDS)) {\n\t\t\tnv_connector->type = DCB_CONNECTOR_LVDS;\n\t\t} else\n\t\tif (encoders & (1 << DCB_OUTPUT_TV)) {\n\t\t\tnv_connector->type = DCB_CONNECTOR_TV_0;\n\t\t}\n\t}\n\n\tswitch ((type = drm_conntype_from_dcb(nv_connector->type))) {\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tret = nouveau_bios_parse_lvds_table(dev, 0, &dummy, &dummy);\n\t\tif (ret) {\n\t\t\tNV_ERROR(drm, \"Error parsing LVDS table, disabling\\n\");\n\t\t\tkfree(nv_connector);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\n\t\tfuncs = &nouveau_connector_funcs_lvds;\n\t\tbreak;\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tnv_connector->aux.dev = connector->kdev;\n\t\tnv_connector->aux.drm_dev = dev;\n\t\tnv_connector->aux.transfer = nouveau_connector_aux_xfer;\n\t\tsnprintf(aux_name, sizeof(aux_name), \"sor-%04x-%04x\",\n\t\t\t dcbe->hasht, dcbe->hashm);\n\t\tnv_connector->aux.name = kstrdup(aux_name, GFP_KERNEL);\n\t\tif (!nv_connector->aux.name) {\n\t\t\tkfree(nv_connector);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tdrm_dp_aux_init(&nv_connector->aux);\n\t\tbreak;\n\tdefault:\n\t\tfuncs = &nouveau_connector_funcs;\n\t\tbreak;\n\t}\n\n\t \n\tif ((disp->disp.object.oclass >= G82_DISP)\n\t    && ((type == DRM_MODE_CONNECTOR_DisplayPort)\n\t\t|| (type == DRM_MODE_CONNECTOR_eDP)\n\t\t|| (type == DRM_MODE_CONNECTOR_HDMIA)))\n\t\tconnector->stereo_allowed = true;\n\n\t \n\tconnector->interlace_allowed = false;\n\tconnector->doublescan_allowed = false;\n\n\tdrm_connector_init(dev, connector, funcs, type);\n\tdrm_connector_helper_add(connector, &nouveau_connector_helper_funcs);\n\tconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\n\n\tif (nv_connector->dcb && (disp->disp.conn_mask & BIT(nv_connector->index))) {\n\t\tret = nvif_conn_ctor(&disp->disp, nv_connector->base.name, nv_connector->index,\n\t\t\t\t     &nv_connector->conn);\n\t\tif (ret) {\n\t\t\tgoto drm_conn_err;\n\t\t}\n\n\t\tret = nvif_conn_event_ctor(&nv_connector->conn, \"kmsHotplug\",\n\t\t\t\t\t   nouveau_connector_hotplug,\n\t\t\t\t\t   NVIF_CONN_EVENT_V0_PLUG | NVIF_CONN_EVENT_V0_UNPLUG,\n\t\t\t\t\t   &nv_connector->hpd);\n\t\tif (ret == 0)\n\t\t\tconnector->polled = DRM_CONNECTOR_POLL_HPD;\n\n\t\tif (nv_connector->aux.transfer) {\n\t\t\tret = nvif_conn_event_ctor(&nv_connector->conn, \"kmsDpIrq\",\n\t\t\t\t\t\t   nouveau_connector_irq, NVIF_CONN_EVENT_V0_IRQ,\n\t\t\t\t\t\t   &nv_connector->irq);\n\t\t\tif (ret) {\n\t\t\t\tnvif_event_dtor(&nv_connector->hpd);\n\t\t\t\tnvif_conn_dtor(&nv_connector->conn);\n\t\t\t\tgoto drm_conn_err;\n\t\t\t}\n\t\t}\n\t}\n\n\tconnector->funcs->reset(connector);\n\tnouveau_conn_attach_properties(connector);\n\n\t \n\tswitch (nv_connector->type) {\n\tcase DCB_CONNECTOR_LVDS:\n\tcase DCB_CONNECTOR_LVDS_SPWG:\n\tcase DCB_CONNECTOR_eDP:\n\t\t \n\t\tif (disp->disp.object.oclass < NV50_DISP) {\n\t\t\tnv_connector->scaling_mode = DRM_MODE_SCALE_FULLSCREEN;\n\t\t\tbreak;\n\t\t}\n\t\tnv_connector->scaling_mode = DRM_MODE_SCALE_NONE;\n\t\tbreak;\n\tdefault:\n\t\tnv_connector->scaling_mode = DRM_MODE_SCALE_NONE;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (nv_connector->type) {\n\tcase DCB_CONNECTOR_TV_0:\n\tcase DCB_CONNECTOR_TV_1:\n\tcase DCB_CONNECTOR_TV_3:\n\tcase DCB_CONNECTOR_VGA:\n\t\tbreak;\n\tdefault:\n\t\tnv_connector->dithering_mode = DITHERING_MODE_AUTO;\n\t\tbreak;\n\t}\n\n\tswitch (type) {\n\tcase DRM_MODE_CONNECTOR_DisplayPort:\n\t\tnv_connector->dp_encoder = find_encoder(&nv_connector->base, DCB_OUTPUT_DP);\n\t\tfallthrough;\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\tdrm_dp_cec_register_connector(&nv_connector->aux, connector);\n\t\tbreak;\n\t}\n\n\tdrm_connector_register(connector);\n\treturn connector;\n\ndrm_conn_err:\n\tdrm_connector_cleanup(connector);\n\tkfree(nv_connector);\n\treturn ERR_PTR(ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}