{
  "module_name": "nouveau_drv.h",
  "hash_id": "4b0a30f5766a749a3baf3472fd04116d10a04a60bbbee4f0d3ea4093234059cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_drv.h",
  "human_readable_source": " \n#ifndef __NOUVEAU_DRV_H__\n#define __NOUVEAU_DRV_H__\n\n#define DRIVER_AUTHOR\t\t\"Nouveau Project\"\n#define DRIVER_EMAIL\t\t\"nouveau@lists.freedesktop.org\"\n\n#define DRIVER_NAME\t\t\"nouveau\"\n#define DRIVER_DESC\t\t\"nVidia Riva/TNT/GeForce/Quadro/Tesla/Tegra K1+\"\n#define DRIVER_DATE\t\t\"20120801\"\n\n#define DRIVER_MAJOR\t\t1\n#define DRIVER_MINOR\t\t4\n#define DRIVER_PATCHLEVEL\t0\n\n \n\n#include <linux/notifier.h>\n\n#include <nvif/client.h>\n#include <nvif/device.h>\n#include <nvif/ioctl.h>\n#include <nvif/mmu.h>\n#include <nvif/vmm.h>\n\n#include <drm/drm_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_file.h>\n\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_placement.h>\n\n#include <drm/drm_audio_component.h>\n\n#include \"uapi/drm/nouveau_drm.h\"\n\nstruct nouveau_channel;\nstruct platform_device;\n\n#include \"nouveau_fence.h\"\n#include \"nouveau_bios.h\"\n#include \"nouveau_sched.h\"\n#include \"nouveau_vmm.h\"\n#include \"nouveau_uvmm.h\"\n\nstruct nouveau_drm_tile {\n\tstruct nouveau_fence *fence;\n\tbool used;\n};\n\nenum nouveau_drm_object_route {\n\tNVDRM_OBJECT_NVIF = NVIF_IOCTL_V0_OWNER_NVIF,\n\tNVDRM_OBJECT_USIF,\n\tNVDRM_OBJECT_ABI16,\n\tNVDRM_OBJECT_ANY = NVIF_IOCTL_V0_OWNER_ANY,\n};\n\nenum nouveau_drm_handle {\n\tNVDRM_CHAN    = 0xcccc0000,  \n\tNVDRM_NVSW    = 0x55550000,\n};\n\nstruct nouveau_cli {\n\tstruct nvif_client base;\n\tstruct nouveau_drm *drm;\n\tstruct mutex mutex;\n\n\tstruct nvif_device device;\n\tstruct nvif_mmu mmu;\n\tstruct nouveau_vmm vmm;\n\tstruct nouveau_vmm svm;\n\tstruct nouveau_uvmm uvmm;\n\n\tstruct nouveau_sched_entity sched_entity;\n\n\tconst struct nvif_mclass *mem;\n\n\tstruct list_head head;\n\tvoid *abi16;\n\tstruct list_head objects;\n\tchar name[32];\n\n\tstruct work_struct work;\n\tstruct list_head worker;\n\tstruct mutex lock;\n};\n\nstruct nouveau_cli_work {\n\tvoid (*func)(struct nouveau_cli_work *);\n\tstruct nouveau_cli *cli;\n\tstruct list_head head;\n\n\tstruct dma_fence *fence;\n\tstruct dma_fence_cb cb;\n};\n\nstatic inline struct nouveau_uvmm *\nnouveau_cli_uvmm(struct nouveau_cli *cli)\n{\n\tif (!cli || !cli->uvmm.vmm.cli)\n\t\treturn NULL;\n\n\treturn &cli->uvmm;\n}\n\nstatic inline struct nouveau_uvmm *\nnouveau_cli_uvmm_locked(struct nouveau_cli *cli)\n{\n\tstruct nouveau_uvmm *uvmm;\n\n\tmutex_lock(&cli->mutex);\n\tuvmm = nouveau_cli_uvmm(cli);\n\tmutex_unlock(&cli->mutex);\n\n\treturn uvmm;\n}\n\nstatic inline struct nouveau_vmm *\nnouveau_cli_vmm(struct nouveau_cli *cli)\n{\n\tstruct nouveau_uvmm *uvmm;\n\n\tuvmm = nouveau_cli_uvmm(cli);\n\tif (uvmm)\n\t\treturn &uvmm->vmm;\n\n\tif (cli->svm.cli)\n\t\treturn &cli->svm;\n\n\treturn &cli->vmm;\n}\n\nstatic inline void\n__nouveau_cli_disable_uvmm_noinit(struct nouveau_cli *cli)\n{\n\tstruct nouveau_uvmm *uvmm = nouveau_cli_uvmm(cli);\n\n\tif (!uvmm)\n\t\tcli->uvmm.disabled = true;\n}\n\nstatic inline void\nnouveau_cli_disable_uvmm_noinit(struct nouveau_cli *cli)\n{\n\tmutex_lock(&cli->mutex);\n\t__nouveau_cli_disable_uvmm_noinit(cli);\n\tmutex_unlock(&cli->mutex);\n}\n\nvoid nouveau_cli_work_queue(struct nouveau_cli *, struct dma_fence *,\n\t\t\t    struct nouveau_cli_work *);\n\nstatic inline struct nouveau_cli *\nnouveau_cli(struct drm_file *fpriv)\n{\n\treturn fpriv ? fpriv->driver_priv : NULL;\n}\n\nstatic inline void\nu_free(void *addr)\n{\n\tkvfree(addr);\n}\n\nstatic inline void *\nu_memcpya(uint64_t user, unsigned int nmemb, unsigned int size)\n{\n\tvoid __user *userptr = u64_to_user_ptr(user);\n\tsize_t bytes;\n\n\tif (unlikely(check_mul_overflow(nmemb, size, &bytes)))\n\t\treturn ERR_PTR(-EOVERFLOW);\n\treturn vmemdup_user(userptr, bytes);\n}\n\n#include <nvif/object.h>\n#include <nvif/parent.h>\n\nstruct nouveau_drm {\n\tstruct nvif_parent parent;\n\tstruct nouveau_cli master;\n\tstruct nouveau_cli client;\n\tstruct drm_device *dev;\n\n\tstruct list_head clients;\n\n\t \n\tstruct mutex clients_lock;\n\n\tu8 old_pm_cap;\n\n\tstruct {\n\t\tstruct agp_bridge_data *bridge;\n\t\tu32 base;\n\t\tu32 size;\n\t\tbool cma;\n\t} agp;\n\n\t \n\tstruct {\n\t\tstruct ttm_device bdev;\n\t\tatomic_t validate_sequence;\n\t\tint (*move)(struct nouveau_channel *,\n\t\t\t    struct ttm_buffer_object *,\n\t\t\t    struct ttm_resource *, struct ttm_resource *);\n\t\tstruct nouveau_channel *chan;\n\t\tstruct nvif_object copy;\n\t\tint mtrr;\n\t\tint type_vram;\n\t\tint type_host[2];\n\t\tint type_ncoh[2];\n\t\tstruct mutex io_reserve_mutex;\n\t\tstruct list_head io_reserve_lru;\n\t} ttm;\n\n\t \n\tstruct {\n\t\tu64 vram_available;\n\t\tu64 gart_available;\n\t} gem;\n\n\t \n\tvoid *fence;\n\n\t \n\tint chan_total;  \n\tint chan_nr;\t \n\tint runl_nr;\n\tstruct {\n\t\tint chan_nr;\n\t\tint chan_id_base;\n\t\tu64 context_base;\n\t} *runl;\n\n\t \n\tstruct nouveau_channel *cechan;\n\tstruct nouveau_channel *channel;\n\tstruct nvkm_gpuobj *notify;\n\tstruct nvif_object ntfy;\n\n\t \n\tstruct {\n\t\tstruct nouveau_drm_tile reg[15];\n\t\tspinlock_t lock;\n\t} tile;\n\n\t \n\tstruct nvbios vbios;\n\tstruct nouveau_display *display;\n\tstruct work_struct hpd_work;\n\tspinlock_t hpd_lock;\n\tu32 hpd_pending;\n#ifdef CONFIG_ACPI\n\tstruct notifier_block acpi_nb;\n#endif\n\n\t \n\tstruct nouveau_hwmon *hwmon;\n\tstruct nouveau_debugfs *debugfs;\n\n\t \n\tstruct nouveau_led *led;\n\n\tstruct dev_pm_domain vga_pm_domain;\n\n\tstruct nouveau_svm *svm;\n\n\tstruct nouveau_dmem *dmem;\n\n\tstruct {\n\t\tstruct drm_audio_component *component;\n\t\tstruct mutex lock;\n\t\tbool component_registered;\n\t} audio;\n\n\tstruct drm_gpu_scheduler sched;\n\tstruct workqueue_struct *sched_wq;\n\n};\n\nstatic inline struct nouveau_drm *\nnouveau_drm(struct drm_device *dev)\n{\n\treturn dev->dev_private;\n}\n\nstatic inline bool\nnouveau_drm_use_coherent_gpu_mapping(struct nouveau_drm *drm)\n{\n\tstruct nvif_mmu *mmu = &drm->client.mmu;\n\treturn !(mmu->type[drm->ttm.type_host[0]].type & NVIF_MEM_UNCACHED);\n}\n\nint nouveau_pmops_suspend(struct device *);\nint nouveau_pmops_resume(struct device *);\nbool nouveau_pmops_runtime(void);\n\n#include <nvkm/core/tegra.h>\n\nstruct drm_device *\nnouveau_platform_device_create(const struct nvkm_device_tegra_func *,\n\t\t\t       struct platform_device *, struct nvkm_device **);\nvoid nouveau_drm_device_remove(struct drm_device *dev);\n\n#define NV_PRINTK(l,c,f,a...) do {                                             \\\n\tstruct nouveau_cli *_cli = (c);                                        \\\n\tdev_##l(_cli->drm->dev->dev, \"%s: \"f, _cli->name, ##a);                \\\n} while(0)\n\n#define NV_FATAL(drm,f,a...) NV_PRINTK(crit, &(drm)->client, f, ##a)\n#define NV_ERROR(drm,f,a...) NV_PRINTK(err, &(drm)->client, f, ##a)\n#define NV_WARN(drm,f,a...) NV_PRINTK(warn, &(drm)->client, f, ##a)\n#define NV_INFO(drm,f,a...) NV_PRINTK(info, &(drm)->client, f, ##a)\n\n#define NV_DEBUG(drm,f,a...) do {                                              \\\n\tif (drm_debug_enabled(DRM_UT_DRIVER))                                  \\\n\t\tNV_PRINTK(info, &(drm)->client, f, ##a);                       \\\n} while(0)\n#define NV_ATOMIC(drm,f,a...) do {                                             \\\n\tif (drm_debug_enabled(DRM_UT_ATOMIC))                                  \\\n\t\tNV_PRINTK(info, &(drm)->client, f, ##a);                       \\\n} while(0)\n\n#define NV_PRINTK_ONCE(l,c,f,a...) NV_PRINTK(l##_once,c,f, ##a)\n\n#define NV_ERROR_ONCE(drm,f,a...) NV_PRINTK_ONCE(err, &(drm)->client, f, ##a)\n#define NV_WARN_ONCE(drm,f,a...) NV_PRINTK_ONCE(warn, &(drm)->client, f, ##a)\n#define NV_INFO_ONCE(drm,f,a...) NV_PRINTK_ONCE(info, &(drm)->client, f, ##a)\n\nextern int nouveau_modeset;\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}