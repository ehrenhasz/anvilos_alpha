{
  "module_name": "nouveau_hwmon.c",
  "hash_id": "e14e54676b6a612e9779b0d0a5763f1e99ebc53a7c7fca6d57406c875d404f0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_hwmon.c",
  "human_readable_source": " \n\n#ifdef CONFIG_ACPI\n#include <linux/acpi.h>\n#endif\n#include <linux/power_supply.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_hwmon.h\"\n\n#include <nvkm/subdev/iccsense.h>\n#include <nvkm/subdev/volt.h>\n\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\n\nstatic ssize_t\nnouveau_hwmon_show_temp1_auto_point1_pwm(struct device *d,\n\t\t\t\t\t struct device_attribute *a, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", 100);\n}\nstatic SENSOR_DEVICE_ATTR(temp1_auto_point1_pwm, 0444,\n\t\t\t  nouveau_hwmon_show_temp1_auto_point1_pwm, NULL, 0);\n\nstatic ssize_t\nnouveau_hwmon_temp1_auto_point1_temp(struct device *d,\n\t\t\t\t     struct device_attribute *a, char *buf)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  therm->attr_get(therm, NVKM_THERM_ATTR_THRS_FAN_BOOST) * 1000);\n}\nstatic ssize_t\nnouveau_hwmon_set_temp1_auto_point1_temp(struct device *d,\n\t\t\t\t\t struct device_attribute *a,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tlong value;\n\n\tif (kstrtol(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\ttherm->attr_set(therm, NVKM_THERM_ATTR_THRS_FAN_BOOST,\n\t\t\tvalue / 1000);\n\n\treturn count;\n}\nstatic SENSOR_DEVICE_ATTR(temp1_auto_point1_temp, 0644,\n\t\t\t  nouveau_hwmon_temp1_auto_point1_temp,\n\t\t\t  nouveau_hwmon_set_temp1_auto_point1_temp, 0);\n\nstatic ssize_t\nnouveau_hwmon_temp1_auto_point1_temp_hyst(struct device *d,\n\t\t\t\t\t  struct device_attribute *a, char *buf)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  therm->attr_get(therm, NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST) * 1000);\n}\nstatic ssize_t\nnouveau_hwmon_set_temp1_auto_point1_temp_hyst(struct device *d,\n\t\t\t\t\t      struct device_attribute *a,\n\t\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tlong value;\n\n\tif (kstrtol(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\ttherm->attr_set(therm, NVKM_THERM_ATTR_THRS_FAN_BOOST_HYST,\n\t\t\tvalue / 1000);\n\n\treturn count;\n}\nstatic SENSOR_DEVICE_ATTR(temp1_auto_point1_temp_hyst, 0644,\n\t\t\t  nouveau_hwmon_temp1_auto_point1_temp_hyst,\n\t\t\t  nouveau_hwmon_set_temp1_auto_point1_temp_hyst, 0);\n\nstatic ssize_t\nnouveau_hwmon_get_pwm1_max(struct device *d,\n\t\t\t   struct device_attribute *a, char *buf)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tint ret;\n\n\tret = therm->attr_get(therm, NVKM_THERM_ATTR_FAN_MAX_DUTY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", ret);\n}\n\nstatic ssize_t\nnouveau_hwmon_get_pwm1_min(struct device *d,\n\t\t\t   struct device_attribute *a, char *buf)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tint ret;\n\n\tret = therm->attr_get(therm, NVKM_THERM_ATTR_FAN_MIN_DUTY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sprintf(buf, \"%i\\n\", ret);\n}\n\nstatic ssize_t\nnouveau_hwmon_set_pwm1_min(struct device *d, struct device_attribute *a,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tlong value;\n\tint ret;\n\n\tif (kstrtol(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\tret = therm->attr_set(therm, NVKM_THERM_ATTR_FAN_MIN_DUTY, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic SENSOR_DEVICE_ATTR(pwm1_min, 0644,\n\t\t\t  nouveau_hwmon_get_pwm1_min,\n\t\t\t  nouveau_hwmon_set_pwm1_min, 0);\n\nstatic ssize_t\nnouveau_hwmon_set_pwm1_max(struct device *d, struct device_attribute *a,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct drm_device *dev = dev_get_drvdata(d);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tlong value;\n\tint ret;\n\n\tif (kstrtol(buf, 10, &value))\n\t\treturn -EINVAL;\n\n\tret = therm->attr_set(therm, NVKM_THERM_ATTR_FAN_MAX_DUTY, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic SENSOR_DEVICE_ATTR(pwm1_max, 0644,\n\t\t\t  nouveau_hwmon_get_pwm1_max,\n\t\t\t  nouveau_hwmon_set_pwm1_max, 0);\n\nstatic struct attribute *pwm_fan_sensor_attrs[] = {\n\t&sensor_dev_attr_pwm1_min.dev_attr.attr,\n\t&sensor_dev_attr_pwm1_max.dev_attr.attr,\n\tNULL\n};\nstatic const struct attribute_group pwm_fan_sensor_group = {\n\t.attrs = pwm_fan_sensor_attrs,\n};\n\nstatic struct attribute *temp1_auto_point_sensor_attrs[] = {\n\t&sensor_dev_attr_temp1_auto_point1_pwm.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point1_temp.dev_attr.attr,\n\t&sensor_dev_attr_temp1_auto_point1_temp_hyst.dev_attr.attr,\n\tNULL\n};\nstatic const struct attribute_group temp1_auto_point_sensor_group = {\n\t.attrs = temp1_auto_point_sensor_attrs,\n};\n\n#define N_ATTR_GROUPS   3\n\nstatic const struct hwmon_channel_info * const nouveau_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_UPDATE_INTERVAL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT |\n\t\t\t   HWMON_T_MAX | HWMON_T_MAX_HYST |\n\t\t\t   HWMON_T_CRIT | HWMON_T_CRIT_HYST |\n\t\t\t   HWMON_T_EMERGENCY | HWMON_T_EMERGENCY_HYST),\n\tHWMON_CHANNEL_INFO(fan,\n\t\t\t   HWMON_F_INPUT),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT |\n\t\t\t   HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(pwm,\n\t\t\t   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t   HWMON_P_INPUT | HWMON_P_CAP_MAX | HWMON_P_CRIT),\n\tNULL\n};\n\nstatic umode_t\nnouveau_chip_is_visible(const void *data, u32 attr, int channel)\n{\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t\nnouveau_power_is_visible(const void *data, u32 attr, int channel)\n{\n\tstruct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);\n\tstruct nvkm_iccsense *iccsense = nvxx_iccsense(&drm->client.device);\n\n\tif (!iccsense || !iccsense->data_valid || list_empty(&iccsense->rails))\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\treturn 0444;\n\tcase hwmon_power_max:\n\t\tif (iccsense->power_w_max)\n\t\t\treturn 0444;\n\t\treturn 0;\n\tcase hwmon_power_crit:\n\t\tif (iccsense->power_w_crit)\n\t\t\treturn 0444;\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t\nnouveau_temp_is_visible(const void *data, u32 attr, int channel)\n{\n\tstruct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm || !therm->attr_get || nvkm_therm_temp_get(therm) < 0)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn 0444;\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_max_hyst:\n\tcase hwmon_temp_crit:\n\tcase hwmon_temp_crit_hyst:\n\tcase hwmon_temp_emergency:\n\tcase hwmon_temp_emergency_hyst:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t\nnouveau_pwm_is_visible(const void *data, u32 attr, int channel)\n{\n\tstruct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm || !therm->attr_get || !therm->fan_get ||\n\t    therm->fan_get(therm) < 0)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_enable:\n\tcase hwmon_pwm_input:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t\nnouveau_input_is_visible(const void *data, u32 attr, int channel)\n{\n\tstruct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);\n\tstruct nvkm_volt *volt = nvxx_volt(&drm->client.device);\n\n\tif (!volt || nvkm_volt_get(volt) < 0)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\tcase hwmon_in_label:\n\tcase hwmon_in_min:\n\tcase hwmon_in_max:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic umode_t\nnouveau_fan_is_visible(const void *data, u32 attr, int channel)\n{\n\tstruct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm || !therm->attr_get || nvkm_therm_fan_sense(therm) < 0)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int\nnouveau_chip_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tswitch (attr) {\n\tcase hwmon_chip_update_interval:\n\t\t*val = 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_temp_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tint ret;\n\n\tif (!therm || !therm->attr_get)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\tif (drm_dev->switch_power_state != DRM_SWITCH_POWER_ON)\n\t\t\treturn -EINVAL;\n\t\tret = nvkm_therm_temp_get(therm);\n\t\t*val = ret < 0 ? ret : (ret * 1000);\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_THRS_DOWN_CLK)\n\t\t\t\t\t* 1000;\n\t\tbreak;\n\tcase hwmon_temp_max_hyst:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST)\n\t\t\t\t\t* 1000;\n\t\tbreak;\n\tcase hwmon_temp_crit:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_THRS_CRITICAL)\n\t\t\t\t\t* 1000;\n\t\tbreak;\n\tcase hwmon_temp_crit_hyst:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_THRS_CRITICAL_HYST)\n\t\t\t\t\t* 1000;\n\t\tbreak;\n\tcase hwmon_temp_emergency:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_THRS_SHUTDOWN)\n\t\t\t\t\t* 1000;\n\t\tbreak;\n\tcase hwmon_temp_emergency_hyst:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST)\n\t\t\t\t\t* 1000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_fan_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_fan_input:\n\t\tif (drm_dev->switch_power_state != DRM_SWITCH_POWER_ON)\n\t\t\treturn -EINVAL;\n\t\t*val = nvkm_therm_fan_sense(therm);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_in_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_volt *volt = nvxx_volt(&drm->client.device);\n\tint ret;\n\n\tif (!volt)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\tif (drm_dev->switch_power_state != DRM_SWITCH_POWER_ON)\n\t\t\treturn -EINVAL;\n\t\tret = nvkm_volt_get(volt);\n\t\t*val = ret < 0 ? ret : (ret / 1000);\n\t\tbreak;\n\tcase hwmon_in_min:\n\t\t*val = volt->min_uv > 0 ? (volt->min_uv / 1000) : -ENODEV;\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\t*val = volt->max_uv > 0 ? (volt->max_uv / 1000) : -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_pwm_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm || !therm->attr_get || !therm->fan_get)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_enable:\n\t\t*val = therm->attr_get(therm, NVKM_THERM_ATTR_FAN_MODE);\n\t\tbreak;\n\tcase hwmon_pwm_input:\n\t\tif (drm_dev->switch_power_state != DRM_SWITCH_POWER_ON)\n\t\t\treturn -EINVAL;\n\t\t*val = therm->fan_get(therm);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_power_read(struct device *dev, u32 attr, int channel, long *val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_iccsense *iccsense = nvxx_iccsense(&drm->client.device);\n\n\tif (!iccsense)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\tif (drm_dev->switch_power_state != DRM_SWITCH_POWER_ON)\n\t\t\treturn -EINVAL;\n\t\t*val = nvkm_iccsense_read_all(iccsense);\n\t\tbreak;\n\tcase hwmon_power_max:\n\t\t*val = iccsense->power_w_max;\n\t\tbreak;\n\tcase hwmon_power_crit:\n\t\t*val = iccsense->power_w_crit;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_temp_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm || !therm->attr_set)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_temp_max:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_THRS_DOWN_CLK,\n\t\t\t\t\tval / 1000);\n\tcase hwmon_temp_max_hyst:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_THRS_DOWN_CLK_HYST,\n\t\t\t\t\tval / 1000);\n\tcase hwmon_temp_crit:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_THRS_CRITICAL,\n\t\t\t\t\tval / 1000);\n\tcase hwmon_temp_crit_hyst:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_THRS_CRITICAL_HYST,\n\t\t\t\t\tval / 1000);\n\tcase hwmon_temp_emergency:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_THRS_SHUTDOWN,\n\t\t\t\t\tval / 1000);\n\tcase hwmon_temp_emergency_hyst:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_THRS_SHUTDOWN_HYST,\n\t\t\t\t\tval / 1000);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nnouveau_pwm_write(struct device *dev, u32 attr, int channel, long val)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\n\tif (!therm || !therm->attr_set)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_pwm_input:\n\t\treturn therm->fan_set(therm, val);\n\tcase hwmon_pwm_enable:\n\t\treturn therm->attr_set(therm, NVKM_THERM_ATTR_FAN_MODE, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic umode_t\nnouveau_is_visible(const void *data, enum hwmon_sensor_types type, u32 attr,\n\t\t\tint channel)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn nouveau_chip_is_visible(data, attr, channel);\n\tcase hwmon_temp:\n\t\treturn nouveau_temp_is_visible(data, attr, channel);\n\tcase hwmon_fan:\n\t\treturn nouveau_fan_is_visible(data, attr, channel);\n\tcase hwmon_in:\n\t\treturn nouveau_input_is_visible(data, attr, channel);\n\tcase hwmon_pwm:\n\t\treturn nouveau_pwm_is_visible(data, attr, channel);\n\tcase hwmon_power:\n\t\treturn nouveau_power_is_visible(data, attr, channel);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const char input_label[] = \"GPU core\";\n\nstatic int\nnouveau_read_string(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t    int channel, const char **buf)\n{\n\tif (type == hwmon_in && attr == hwmon_in_label) {\n\t\t*buf = input_label;\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nnouveau_read(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t\t\t\tint channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_chip:\n\t\treturn nouveau_chip_read(dev, attr, channel, val);\n\tcase hwmon_temp:\n\t\treturn nouveau_temp_read(dev, attr, channel, val);\n\tcase hwmon_fan:\n\t\treturn nouveau_fan_read(dev, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn nouveau_in_read(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn nouveau_pwm_read(dev, attr, channel, val);\n\tcase hwmon_power:\n\t\treturn nouveau_power_read(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nnouveau_write(struct device *dev, enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t\t\t\tint channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn nouveau_temp_write(dev, attr, channel, val);\n\tcase hwmon_pwm:\n\t\treturn nouveau_pwm_write(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops nouveau_hwmon_ops = {\n\t.is_visible = nouveau_is_visible,\n\t.read = nouveau_read,\n\t.read_string = nouveau_read_string,\n\t.write = nouveau_write,\n};\n\nstatic const struct hwmon_chip_info nouveau_chip_info = {\n\t.ops = &nouveau_hwmon_ops,\n\t.info = nouveau_info,\n};\n#endif\n\nint\nnouveau_hwmon_init(struct drm_device *dev)\n{\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_iccsense *iccsense = nvxx_iccsense(&drm->client.device);\n\tstruct nvkm_therm *therm = nvxx_therm(&drm->client.device);\n\tstruct nvkm_volt *volt = nvxx_volt(&drm->client.device);\n\tconst struct attribute_group *special_groups[N_ATTR_GROUPS];\n\tstruct nouveau_hwmon *hwmon;\n\tstruct device *hwmon_dev;\n\tint ret = 0;\n\tint i = 0;\n\n\tif (!iccsense && !therm && !volt) {\n\t\tNV_DEBUG(drm, \"Skipping hwmon registration\\n\");\n\t\treturn 0;\n\t}\n\n\thwmon = drm->hwmon = kzalloc(sizeof(*hwmon), GFP_KERNEL);\n\tif (!hwmon)\n\t\treturn -ENOMEM;\n\thwmon->dev = dev;\n\n\tif (therm && therm->attr_get && therm->attr_set) {\n\t\tif (nvkm_therm_temp_get(therm) >= 0)\n\t\t\tspecial_groups[i++] = &temp1_auto_point_sensor_group;\n\t\tif (therm->fan_get && therm->fan_get(therm) >= 0)\n\t\t\tspecial_groups[i++] = &pwm_fan_sensor_group;\n\t}\n\n\tspecial_groups[i] = NULL;\n\thwmon_dev = hwmon_device_register_with_info(dev->dev, \"nouveau\", dev,\n\t\t\t\t\t\t\t&nouveau_chip_info,\n\t\t\t\t\t\t\tspecial_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tret = PTR_ERR(hwmon_dev);\n\t\tNV_ERROR(drm, \"Unable to register hwmon device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thwmon->hwmon = hwmon_dev;\n\treturn 0;\n#else\n\treturn 0;\n#endif\n}\n\nvoid\nnouveau_hwmon_fini(struct drm_device *dev)\n{\n#if defined(CONFIG_HWMON) || (defined(MODULE) && defined(CONFIG_HWMON_MODULE))\n\tstruct nouveau_hwmon *hwmon = nouveau_hwmon(dev);\n\n\tif (!hwmon)\n\t\treturn;\n\n\tif (hwmon->hwmon)\n\t\thwmon_device_unregister(hwmon->hwmon);\n\n\tnouveau_drm(dev)->hwmon = NULL;\n\tkfree(hwmon);\n#endif\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}