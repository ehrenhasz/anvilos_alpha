{
  "module_name": "nouveau_led.c",
  "hash_id": "2de1bc7841c83062774b383f146f274dc4ef3bbec098c94643df87d66eaa82d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_led.c",
  "human_readable_source": " \n\n \n\n#include <linux/leds.h>\n\n#include \"nouveau_led.h\"\n#include <nvkm/subdev/gpio.h>\n\nstatic enum led_brightness\nnouveau_led_get_brightness(struct led_classdev *led)\n{\n\tstruct drm_device *drm_dev = container_of(led, struct nouveau_led, led)->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tu32 div, duty;\n\n\tdiv =  nvif_rd32(device, 0x61c880) & 0x00ffffff;\n\tduty = nvif_rd32(device, 0x61c884) & 0x00ffffff;\n\n\tif (div > 0)\n\t\treturn duty * LED_FULL / div;\n\telse\n\t\treturn 0;\n}\n\nstatic void\nnouveau_led_set_brightness(struct led_classdev *led, enum led_brightness value)\n{\n\tstruct drm_device *drm_dev = container_of(led, struct nouveau_led, led)->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\n\tu32 input_clk = 27e6;  \n\tu32 freq = 100;  \n\tu32 div, duty;\n\n\tdiv = input_clk / freq;\n\tduty = value * div / LED_FULL;\n\n\t \n\tnvif_wr32(device, 0x61c880, div);\n\tnvif_wr32(device, 0x61c884, 0xc0000000 | duty);\n}\n\n\nint\nnouveau_led_init(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_gpio *gpio = nvxx_gpio(&drm->client.device);\n\tstruct dcb_gpio_func logo_led;\n\tint ret;\n\n\tif (!gpio)\n\t\treturn 0;\n\n\t \n\tif (nvkm_gpio_find(gpio, 0, DCB_GPIO_LOGO_LED_PWM, 0xff, &logo_led))\n\t\treturn 0;\n\n\tdrm->led = kzalloc(sizeof(*drm->led), GFP_KERNEL);\n\tif (!drm->led)\n\t\treturn -ENOMEM;\n\tdrm->led->dev = dev;\n\n\tdrm->led->led.name = \"nvidia-logo\";\n\tdrm->led->led.max_brightness = 255;\n\tdrm->led->led.brightness_get = nouveau_led_get_brightness;\n\tdrm->led->led.brightness_set = nouveau_led_set_brightness;\n\n\tret = led_classdev_register(dev->dev, &drm->led->led);\n\tif (ret) {\n\t\tkfree(drm->led);\n\t\tdrm->led = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid\nnouveau_led_suspend(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (drm->led)\n\t\tled_classdev_suspend(&drm->led->led);\n}\n\nvoid\nnouveau_led_resume(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (drm->led)\n\t\tled_classdev_resume(&drm->led->led);\n}\n\nvoid\nnouveau_led_fini(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (drm->led) {\n\t\tled_classdev_unregister(&drm->led->led);\n\t\tkfree(drm->led);\n\t\tdrm->led = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}