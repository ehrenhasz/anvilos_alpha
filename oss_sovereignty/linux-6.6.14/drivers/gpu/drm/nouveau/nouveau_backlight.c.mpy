{
  "module_name": "nouveau_backlight.c",
  "hash_id": "d342f68a85f40c04ffe315704be88b133d3f8cc5b1b75dd9a6b4775b31017f26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_backlight.c",
  "human_readable_source": " \n\n \n\n#include <linux/apple-gmux.h>\n#include <linux/backlight.h>\n#include <linux/idr.h>\n#include <drm/drm_probe_helper.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_acpi.h\"\n\nstatic struct ida bl_ida;\n#define BL_NAME_SIZE 15 \n\nstatic bool\nnouveau_get_backlight_name(char backlight_name[BL_NAME_SIZE],\n\t\t\t   struct nouveau_backlight *bl)\n{\n\tconst int nb = ida_alloc_max(&bl_ida, 99, GFP_KERNEL);\n\n\tif (nb < 0)\n\t\treturn false;\n\tif (nb > 0)\n\t\tsnprintf(backlight_name, BL_NAME_SIZE, \"nv_backlight%d\", nb);\n\telse\n\t\tsnprintf(backlight_name, BL_NAME_SIZE, \"nv_backlight\");\n\tbl->id = nb;\n\treturn true;\n}\n\nstatic int\nnv40_get_intensity(struct backlight_device *bd)\n{\n\tstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint val = (nvif_rd32(device, NV40_PMC_BACKLIGHT) &\n\t\t   NV40_PMC_BACKLIGHT_MASK) >> 16;\n\n\treturn val;\n}\n\nstatic int\nnv40_set_intensity(struct backlight_device *bd)\n{\n\tstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint val = bd->props.brightness;\n\tint reg = nvif_rd32(device, NV40_PMC_BACKLIGHT);\n\n\tnvif_wr32(device, NV40_PMC_BACKLIGHT,\n\t\t  (val << 16) | (reg & ~NV40_PMC_BACKLIGHT_MASK));\n\n\treturn 0;\n}\n\nstatic const struct backlight_ops nv40_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.get_brightness = nv40_get_intensity,\n\t.update_status = nv40_set_intensity,\n};\n\nstatic int\nnv40_backlight_init(struct nouveau_encoder *encoder,\n\t\t    struct backlight_properties *props,\n\t\t    const struct backlight_ops **ops)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\n\tif (!(nvif_rd32(device, NV40_PMC_BACKLIGHT) & NV40_PMC_BACKLIGHT_MASK))\n\t\treturn -ENODEV;\n\n\tprops->max_brightness = 31;\n\t*ops = &nv40_bl_ops;\n\treturn 0;\n}\n\nstatic int\nnv50_get_intensity(struct backlight_device *bd)\n{\n\tstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint or = ffs(nv_encoder->dcb->or) - 1;\n\tu32 div = 1025;\n\tu32 val;\n\n\tval  = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));\n\tval &= NV50_PDISP_SOR_PWM_CTL_VAL;\n\treturn ((val * 100) + (div / 2)) / div;\n}\n\nstatic int\nnv50_set_intensity(struct backlight_device *bd)\n{\n\tstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint or = ffs(nv_encoder->dcb->or) - 1;\n\tu32 div = 1025;\n\tu32 val = (bd->props.brightness * div) / 100;\n\n\tnvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),\n\t\t  NV50_PDISP_SOR_PWM_CTL_NEW | val);\n\treturn 0;\n}\n\nstatic const struct backlight_ops nv50_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.get_brightness = nv50_get_intensity,\n\t.update_status = nv50_set_intensity,\n};\n\n \nstatic int\nnv50_edp_get_brightness(struct backlight_device *bd)\n{\n\tstruct drm_connector *connector = dev_get_drvdata(bd->dev.parent);\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = 0;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\n\nretry:\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);\n\tif (ret == -EDEADLK)\n\t\tgoto deadlock;\n\telse if (ret < 0)\n\t\tgoto out;\n\n\tcrtc = connector->state->crtc;\n\tif (!crtc)\n\t\tgoto out;\n\n\tret = drm_modeset_lock(&crtc->mutex, &ctx);\n\tif (ret == -EDEADLK)\n\t\tgoto deadlock;\n\telse if (ret < 0)\n\t\tgoto out;\n\n\tif (!crtc->state->active)\n\t\tgoto out;\n\n\tret = bd->props.brightness;\nout:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\treturn ret;\ndeadlock:\n\tdrm_modeset_backoff(&ctx);\n\tgoto retry;\n}\n\nstatic int\nnv50_edp_set_brightness(struct backlight_device *bd)\n{\n\tstruct drm_connector *connector = dev_get_drvdata(bd->dev.parent);\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_crtc *crtc;\n\tstruct drm_dp_aux *aux = &nv_connector->aux;\n\tstruct nouveau_backlight *nv_bl = nv_connector->backlight;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret = 0;\n\n\tdrm_modeset_acquire_init(&ctx, 0);\nretry:\n\tret = drm_modeset_lock(&dev->mode_config.connection_mutex, &ctx);\n\tif (ret == -EDEADLK)\n\t\tgoto deadlock;\n\telse if (ret < 0)\n\t\tgoto out;\n\n\tcrtc = connector->state->crtc;\n\tif (!crtc)\n\t\tgoto out;\n\n\tret = drm_modeset_lock(&crtc->mutex, &ctx);\n\tif (ret == -EDEADLK)\n\t\tgoto deadlock;\n\telse if (ret < 0)\n\t\tgoto out;\n\n\tif (crtc->state->active)\n\t\tret = drm_edp_backlight_set_level(aux, &nv_bl->edp_info, bd->props.brightness);\n\nout:\n\tdrm_modeset_drop_locks(&ctx);\n\tdrm_modeset_acquire_fini(&ctx);\n\treturn ret;\ndeadlock:\n\tdrm_modeset_backoff(&ctx);\n\tgoto retry;\n}\n\nstatic const struct backlight_ops nv50_edp_bl_ops = {\n\t.get_brightness = nv50_edp_get_brightness,\n\t.update_status = nv50_edp_set_brightness,\n};\n\nstatic int\nnva3_get_intensity(struct backlight_device *bd)\n{\n\tstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint or = ffs(nv_encoder->dcb->or) - 1;\n\tu32 div, val;\n\n\tdiv  = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));\n\tval  = nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(or));\n\tval &= NVA3_PDISP_SOR_PWM_CTL_VAL;\n\tif (div && div >= val)\n\t\treturn ((val * 100) + (div / 2)) / div;\n\n\treturn 100;\n}\n\nstatic int\nnva3_set_intensity(struct backlight_device *bd)\n{\n\tstruct nouveau_encoder *nv_encoder = bl_get_data(bd);\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint or = ffs(nv_encoder->dcb->or) - 1;\n\tu32 div, val;\n\n\tdiv = nvif_rd32(device, NV50_PDISP_SOR_PWM_DIV(or));\n\n\tval = backlight_get_brightness(bd);\n\tif (val)\n\t\tval = (val * div) / 100;\n\n\tif (div) {\n\t\tnvif_wr32(device, NV50_PDISP_SOR_PWM_CTL(or),\n\t\t\t  val |\n\t\t\t  NV50_PDISP_SOR_PWM_CTL_NEW |\n\t\t\t  NVA3_PDISP_SOR_PWM_CTL_UNK);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct backlight_ops nva3_bl_ops = {\n\t.options = BL_CORE_SUSPENDRESUME,\n\t.get_brightness = nva3_get_intensity,\n\t.update_status = nva3_set_intensity,\n};\n\n \nstatic int\nnv50_backlight_init(struct nouveau_backlight *bl,\n\t\t    struct nouveau_connector *nv_conn,\n\t\t    struct nouveau_encoder *nv_encoder,\n\t\t    struct backlight_properties *props,\n\t\t    const struct backlight_ops **ops)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\n\t \n\tif (!nvif_rd32(device, NV50_PDISP_SOR_PWM_CTL(ffs(nv_encoder->dcb->or) - 1)) ||\n\t    drm_helper_probe_detect(&nv_conn->base, NULL, false) != connector_status_connected)\n\t\treturn -ENODEV;\n\n\tif (nv_conn->type == DCB_CONNECTOR_eDP) {\n\t\tint ret;\n\t\tu16 current_level;\n\t\tu8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE];\n\t\tu8 current_mode;\n\n\t\tret = drm_dp_dpcd_read(&nv_conn->aux, DP_EDP_DPCD_REV, edp_dpcd,\n\t\t\t\t       EDP_DISPLAY_CTL_CAP_SIZE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (drm_edp_backlight_supported(edp_dpcd) &&\n\t\t    (edp_dpcd[1] & DP_EDP_BACKLIGHT_AUX_ENABLE_CAP) &&\n\t\t    (edp_dpcd[2] & DP_EDP_BACKLIGHT_BRIGHTNESS_AUX_SET_CAP)) {\n\t\t\tNV_DEBUG(drm, \"DPCD backlight controls supported on %s\\n\",\n\t\t\t\t nv_conn->base.name);\n\n\t\t\tret = drm_edp_backlight_init(&nv_conn->aux, &bl->edp_info, 0, edp_dpcd,\n\t\t\t\t\t\t     &current_level, &current_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = drm_edp_backlight_enable(&nv_conn->aux, &bl->edp_info, current_level);\n\t\t\tif (ret < 0) {\n\t\t\t\tNV_ERROR(drm, \"Failed to enable backlight on %s: %d\\n\",\n\t\t\t\t\t nv_conn->base.name, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t*ops = &nv50_edp_bl_ops;\n\t\t\tprops->brightness = current_level;\n\t\t\tprops->max_brightness = bl->edp_info.max;\n\t\t\tbl->uses_dpcd = true;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (drm->client.device.info.chipset <= 0xa0 ||\n\t    drm->client.device.info.chipset == 0xaa ||\n\t    drm->client.device.info.chipset == 0xac)\n\t\t*ops = &nv50_bl_ops;\n\telse\n\t\t*ops = &nva3_bl_ops;\n\n\tprops->max_brightness = 100;\n\n\treturn 0;\n}\n\nint\nnouveau_backlight_init(struct drm_connector *connector)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct nouveau_backlight *bl;\n\tstruct nouveau_encoder *nv_encoder = NULL;\n\tstruct nvif_device *device = &drm->client.device;\n\tchar backlight_name[BL_NAME_SIZE];\n\tstruct backlight_properties props = {0};\n\tconst struct backlight_ops *ops;\n\tint ret;\n\n\tif (apple_gmux_present()) {\n\t\tNV_INFO_ONCE(drm, \"Apple GMUX detected: not registering Nouveau backlight interface\\n\");\n\t\treturn 0;\n\t}\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS)\n\t\tnv_encoder = find_encoder(connector, DCB_OUTPUT_LVDS);\n\telse if (connector->connector_type == DRM_MODE_CONNECTOR_eDP)\n\t\tnv_encoder = find_encoder(connector, DCB_OUTPUT_DP);\n\telse\n\t\treturn 0;\n\n\tif (!nv_encoder)\n\t\treturn 0;\n\n\tbl = kzalloc(sizeof(*bl), GFP_KERNEL);\n\tif (!bl)\n\t\treturn -ENOMEM;\n\n\tswitch (device->info.family) {\n\tcase NV_DEVICE_INFO_V0_CURIE:\n\t\tret = nv40_backlight_init(nv_encoder, &props, &ops);\n\t\tbreak;\n\tcase NV_DEVICE_INFO_V0_TESLA:\n\tcase NV_DEVICE_INFO_V0_FERMI:\n\tcase NV_DEVICE_INFO_V0_KEPLER:\n\tcase NV_DEVICE_INFO_V0_MAXWELL:\n\tcase NV_DEVICE_INFO_V0_PASCAL:\n\tcase NV_DEVICE_INFO_V0_VOLTA:\n\tcase NV_DEVICE_INFO_V0_TURING:\n\tcase NV_DEVICE_INFO_V0_AMPERE: \n\t\tret = nv50_backlight_init(bl, nouveau_connector(connector),\n\t\t\t\t\t  nv_encoder, &props, &ops);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t\tgoto fail_alloc;\n\t}\n\n\tif (ret) {\n\t\tif (ret == -ENODEV)\n\t\t\tret = 0;\n\t\tgoto fail_alloc;\n\t}\n\n\tif (!nouveau_acpi_video_backlight_use_native()) {\n\t\tNV_INFO(drm, \"Skipping nv_backlight registration\\n\");\n\t\tgoto fail_alloc;\n\t}\n\n\tif (!nouveau_get_backlight_name(backlight_name, bl)) {\n\t\tNV_ERROR(drm, \"Failed to retrieve a unique name for the backlight interface\\n\");\n\t\tgoto fail_alloc;\n\t}\n\n\tprops.type = BACKLIGHT_RAW;\n\tbl->dev = backlight_device_register(backlight_name, connector->kdev,\n\t\t\t\t\t    nv_encoder, ops, &props);\n\tif (IS_ERR(bl->dev)) {\n\t\tif (bl->id >= 0)\n\t\t\tida_free(&bl_ida, bl->id);\n\t\tret = PTR_ERR(bl->dev);\n\t\tgoto fail_alloc;\n\t}\n\n\tnouveau_connector(connector)->backlight = bl;\n\tif (!bl->dev->props.brightness)\n\t\tbl->dev->props.brightness =\n\t\t\tbl->dev->ops->get_brightness(bl->dev);\n\tbacklight_update_status(bl->dev);\n\n\treturn 0;\n\nfail_alloc:\n\tkfree(bl);\n\t \n\tif (ret == 0)\n\t\tnouveau_acpi_video_register_backlight();\n\n\treturn ret;\n}\n\nvoid\nnouveau_backlight_fini(struct drm_connector *connector)\n{\n\tstruct nouveau_connector *nv_conn = nouveau_connector(connector);\n\tstruct nouveau_backlight *bl = nv_conn->backlight;\n\n\tif (!bl)\n\t\treturn;\n\n\tif (bl->id >= 0)\n\t\tida_free(&bl_ida, bl->id);\n\n\tbacklight_device_unregister(bl->dev);\n\tnv_conn->backlight = NULL;\n\tkfree(bl);\n}\n\nvoid\nnouveau_backlight_ctor(void)\n{\n\tida_init(&bl_ida);\n}\n\nvoid\nnouveau_backlight_dtor(void)\n{\n\tida_destroy(&bl_ida);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}