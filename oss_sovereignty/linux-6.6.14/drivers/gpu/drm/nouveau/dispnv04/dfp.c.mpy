{
  "module_name": "dfp.c",
  "hash_id": "f977f5a1dbd9425e8563231002c6ed49321fb42dcb4c5d1c65de555b57998a8b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/dfp.c",
  "human_readable_source": " \n\n#include <drm/drm_fourcc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_crtc.h\"\n#include \"hw.h\"\n#include \"nvreg.h\"\n\n#include <drm/i2c/sil164.h>\n\n#include <subdev/i2c.h>\n\n#define FP_TG_CONTROL_ON  (NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\t\\\n\t\t\t   NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS |\t\t\\\n\t\t\t   NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS)\n#define FP_TG_CONTROL_OFF (NV_PRAMDAC_FP_TG_CONTROL_DISPEN_DISABLE |\t\\\n\t\t\t   NV_PRAMDAC_FP_TG_CONTROL_HSYNC_DISABLE |\t\\\n\t\t\t   NV_PRAMDAC_FP_TG_CONTROL_VSYNC_DISABLE)\n\nstatic inline bool is_fpc_off(uint32_t fpc)\n{\n\treturn ((fpc & (FP_TG_CONTROL_ON | FP_TG_CONTROL_OFF)) ==\n\t\t\tFP_TG_CONTROL_OFF);\n}\n\nint nv04_dfp_get_bound_head(struct drm_device *dev, struct dcb_output *dcbent)\n{\n\t \n\tint ramdac = (dcbent->or & DCB_OUTPUT_C) >> 2;\n\n\tNVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL,\n\tNV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE | 0x4);\n\treturn ((NVReadRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_DATA) & 0x8) >> 3) ^ ramdac;\n}\n\nvoid nv04_dfp_bind_head(struct drm_device *dev, struct dcb_output *dcbent,\n\t\t\tint head, bool dl)\n{\n\t \n\n\tint ramdac = (dcbent->or & DCB_OUTPUT_C) >> 2;\n\tuint8_t tmds04 = 0x80;\n\n\tif (head != ramdac)\n\t\ttmds04 = 0x88;\n\n\tif (dcbent->type == DCB_OUTPUT_LVDS)\n\t\ttmds04 |= 0x01;\n\n\tnv_write_tmds(dev, dcbent->or, 0, 0x04, tmds04);\n\n\tif (dl)\t \n\t\tnv_write_tmds(dev, dcbent->or, 1, 0x04, tmds04 ^ 0x08);\n}\n\nvoid nv04_dfp_disable(struct drm_device *dev, int head)\n{\n\tstruct nv04_crtc_reg *crtcstate = nv04_display(dev)->mode_reg.crtc_reg;\n\n\tif (NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL) &\n\t    FP_TG_CONTROL_ON) {\n\t\t \n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL,\n\t\t\t      FP_TG_CONTROL_OFF);\n\t\tmsleep(50);\n\t}\n\t \n\tcrtcstate[head].fp_control = FP_TG_CONTROL_OFF;\n\tcrtcstate[head].CRTC[NV_CIO_CRE_LCD__INDEX] &=\n\t\t~NV_CIO_CRE_LCD_ROUTE_MASK;\n}\n\nvoid nv04_dfp_update_fp_control(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_crtc *crtc;\n\tstruct nouveau_crtc *nv_crtc;\n\tuint32_t *fpc;\n\n\tif (mode == DRM_MODE_DPMS_ON) {\n\t\tnv_crtc = nouveau_crtc(encoder->crtc);\n\t\tfpc = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index].fp_control;\n\n\t\tif (is_fpc_off(*fpc)) {\n\t\t\t \n\t\t\t*fpc = nv_crtc->dpms_saved_fp_control;\n\t\t}\n\n\t\tnv_crtc->fp_users |= 1 << nouveau_encoder(encoder)->dcb->index;\n\t\tNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_FP_TG_CONTROL, *fpc);\n\t} else {\n\t\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\t\tnv_crtc = nouveau_crtc(crtc);\n\t\t\tfpc = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index].fp_control;\n\n\t\t\tnv_crtc->fp_users &= ~(1 << nouveau_encoder(encoder)->dcb->index);\n\t\t\tif (!is_fpc_off(*fpc) && !nv_crtc->fp_users) {\n\t\t\t\tnv_crtc->dpms_saved_fp_control = *fpc;\n\t\t\t\t \n\t\t\t\t*fpc &= ~FP_TG_CONTROL_ON;\n\t\t\t\t*fpc |= FP_TG_CONTROL_OFF;\n\t\t\t\tNVWriteRAMDAC(dev, nv_crtc->index,\n\t\t\t\t\t      NV_PRAMDAC_FP_TG_CONTROL, *fpc);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct drm_encoder *get_tmds_slave(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\tstruct drm_encoder *slave;\n\n\tif (dcb->type != DCB_OUTPUT_TMDS || dcb->location == DCB_LOC_ON_CHIP)\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(slave, &dev->mode_config.encoder_list, head) {\n\t\tstruct dcb_output *slave_dcb = nouveau_encoder(slave)->dcb;\n\n\t\tif (slave_dcb->type == DCB_OUTPUT_TMDS && get_slave_funcs(slave) &&\n\t\t    slave_dcb->tmdsconf.slave_addr == dcb->tmdsconf.slave_addr)\n\t\t\treturn slave;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool nv04_dfp_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_connector *nv_connector =\n\t\tnv04_encoder_get_connector(nv_encoder);\n\n\tif (!nv_connector->native_mode ||\n\t    nv_connector->scaling_mode == DRM_MODE_SCALE_NONE ||\n\t    mode->hdisplay > nv_connector->native_mode->hdisplay ||\n\t    mode->vdisplay > nv_connector->native_mode->vdisplay) {\n\t\tnv_encoder->mode = *adjusted_mode;\n\n\t} else {\n\t\tnv_encoder->mode = *nv_connector->native_mode;\n\t\tadjusted_mode->clock = nv_connector->native_mode->clock;\n\t}\n\n\treturn true;\n}\n\nstatic void nv04_dfp_prepare_sel_clk(struct drm_device *dev,\n\t\t\t\t     struct nouveau_encoder *nv_encoder, int head)\n{\n\tstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\n\tuint32_t bits1618 = nv_encoder->dcb->or & DCB_OUTPUT_A ? 0x10000 : 0x40000;\n\n\tif (nv_encoder->dcb->location != DCB_LOC_ON_CHIP)\n\t\treturn;\n\n\t \n\tif (head)\n\t\tstate->sel_clk |= bits1618;\n\telse\n\t\tstate->sel_clk &= ~bits1618;\n\n\t \n\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS && nv04_display(dev)->saved_reg.sel_clk & 0xf0) {\n\t\tint shift = (nv04_display(dev)->saved_reg.sel_clk & 0x50) ? 0 : 1;\n\n\t\tstate->sel_clk &= ~0xf0;\n\t\tstate->sel_clk |= (head ? 0x40 : 0x10) << shift;\n\t}\n}\n\nstatic void nv04_dfp_prepare(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\tstruct drm_device *dev = encoder->dev;\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\tstruct nv04_crtc_reg *crtcstate = nv04_display(dev)->mode_reg.crtc_reg;\n\tuint8_t *cr_lcd = &crtcstate[head].CRTC[NV_CIO_CRE_LCD__INDEX];\n\tuint8_t *cr_lcd_oth = &crtcstate[head ^ 1].CRTC[NV_CIO_CRE_LCD__INDEX];\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_OFF);\n\n\tnv04_dfp_prepare_sel_clk(dev, nv_encoder, head);\n\n\t*cr_lcd = (*cr_lcd & ~NV_CIO_CRE_LCD_ROUTE_MASK) | 0x3;\n\n\tif (nv_two_heads(dev)) {\n\t\tif (nv_encoder->dcb->location == DCB_LOC_ON_CHIP)\n\t\t\t*cr_lcd |= head ? 0x0 : 0x8;\n\t\telse {\n\t\t\t*cr_lcd |= (nv_encoder->dcb->or << 4) & 0x30;\n\t\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS)\n\t\t\t\t*cr_lcd |= 0x30;\n\t\t\tif ((*cr_lcd & 0x30) == (*cr_lcd_oth & 0x30)) {\n\t\t\t\t \n\t\t\t\t*cr_lcd_oth &= ~0x30;\n\t\t\t\tNVWriteVgaCrtc(dev, head ^ 1,\n\t\t\t\t\t       NV_CIO_CRE_LCD__INDEX,\n\t\t\t\t\t       *cr_lcd_oth);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstatic void nv04_dfp_mode_set(struct drm_encoder *encoder,\n\t\t\t      struct drm_display_mode *mode,\n\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\tstruct nv04_crtc_reg *savep = &nv04_display(dev)->saved_reg.crtc_reg[nv_crtc->index];\n\tstruct nouveau_connector *nv_connector = nouveau_crtc_connector_get(nv_crtc);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_display_mode *output_mode = &nv_encoder->mode;\n\tstruct drm_connector *connector = &nv_connector->base;\n\tconst struct drm_framebuffer *fb = encoder->crtc->primary->fb;\n\tuint32_t mode_ratio, panel_ratio;\n\n\tNV_DEBUG(drm, \"Output mode on CRTC %d:\\n\", nv_crtc->index);\n\tdrm_mode_debug_printmodeline(output_mode);\n\n\t \n\tregp->fp_horiz_regs[FP_DISPLAY_END] = output_mode->hdisplay - 1;\n\tregp->fp_horiz_regs[FP_TOTAL] = output_mode->htotal - 1;\n\tif (!nv_gf4_disp_arch(dev) ||\n\t    (output_mode->hsync_start - output_mode->hdisplay) >=\n\t\t\t\t\tdrm->vbios.digital_min_front_porch)\n\t\tregp->fp_horiz_regs[FP_CRTC] = output_mode->hdisplay;\n\telse\n\t\tregp->fp_horiz_regs[FP_CRTC] = output_mode->hsync_start - drm->vbios.digital_min_front_porch - 1;\n\tregp->fp_horiz_regs[FP_SYNC_START] = output_mode->hsync_start - 1;\n\tregp->fp_horiz_regs[FP_SYNC_END] = output_mode->hsync_end - 1;\n\tregp->fp_horiz_regs[FP_VALID_START] = output_mode->hskew;\n\tregp->fp_horiz_regs[FP_VALID_END] = output_mode->hdisplay - 1;\n\n\tregp->fp_vert_regs[FP_DISPLAY_END] = output_mode->vdisplay - 1;\n\tregp->fp_vert_regs[FP_TOTAL] = output_mode->vtotal - 1;\n\tregp->fp_vert_regs[FP_CRTC] = output_mode->vtotal - 5 - 1;\n\tregp->fp_vert_regs[FP_SYNC_START] = output_mode->vsync_start - 1;\n\tregp->fp_vert_regs[FP_SYNC_END] = output_mode->vsync_end - 1;\n\tregp->fp_vert_regs[FP_VALID_START] = 0;\n\tregp->fp_vert_regs[FP_VALID_END] = output_mode->vdisplay - 1;\n\n\t \n\tregp->fp_control = NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\n\t\t\t   (savep->fp_control & (1 << 26 | NV_PRAMDAC_FP_TG_CONTROL_READ_PROG));\n\t \n\t \n\tif (output_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS;\n\tif (output_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS;\n\t \n\tif (nv_connector->scaling_mode == DRM_MODE_SCALE_NONE ||\n\t    nv_connector->scaling_mode == DRM_MODE_SCALE_CENTER)\t \n\t\tregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER;\n\telse if (adjusted_mode->hdisplay == output_mode->hdisplay &&\n\t\t adjusted_mode->vdisplay == output_mode->vdisplay)  \n\t\tregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_MODE_NATIVE;\n\telse  \n\t\tregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE;\n\tif (nvif_rd32(device, NV_PEXTDEV_BOOT_0) & NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_12BIT)\n\t\tregp->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_WIDTH_12;\n\tif (nv_encoder->dcb->location != DCB_LOC_ON_CHIP &&\n\t    output_mode->clock > 165000)\n\t\tregp->fp_control |= (2 << 24);\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS) {\n\t\tbool duallink = false, dummy;\n\t\tif (nv_connector->edid &&\n\t\t    nv_connector->type == DCB_CONNECTOR_LVDS_SPWG) {\n\t\t\tduallink = (((u8 *)nv_connector->edid)[121] == 2);\n\t\t} else {\n\t\t\tnouveau_bios_parse_lvds_table(dev, output_mode->clock,\n\t\t\t\t\t\t      &duallink, &dummy);\n\t\t}\n\n\t\tif (duallink)\n\t\t\tregp->fp_control |= (8 << 28);\n\t} else\n\tif (output_mode->clock > 165000)\n\t\tregp->fp_control |= (8 << 28);\n\n\tregp->fp_debug_0 = NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_ROUND |\n\t\t\t   NV_PRAMDAC_FP_DEBUG_0_XWEIGHT_ROUND |\n\t\t\t   NV_PRAMDAC_FP_DEBUG_0_YINTERP_BILINEAR |\n\t\t\t   NV_PRAMDAC_FP_DEBUG_0_XINTERP_BILINEAR |\n\t\t\t   NV_RAMDAC_FP_DEBUG_0_TMDS_ENABLED |\n\t\t\t   NV_PRAMDAC_FP_DEBUG_0_YSCALE_ENABLE |\n\t\t\t   NV_PRAMDAC_FP_DEBUG_0_XSCALE_ENABLE;\n\n\t \n\tregp->fp_debug_1 = 0;\n\t \n\tregp->fp_debug_2 = 0;\n\n\t \n\tmode_ratio = (1 << 12) * adjusted_mode->hdisplay / adjusted_mode->vdisplay;\n\tpanel_ratio = (1 << 12) * output_mode->hdisplay / output_mode->vdisplay;\n\t \n\tif (nv_connector->scaling_mode == DRM_MODE_SCALE_ASPECT &&\n\t    mode_ratio != panel_ratio) {\n\t\tuint32_t diff, scale;\n\t\tbool divide_by_2 = nv_gf4_disp_arch(dev);\n\n\t\tif (mode_ratio < panel_ratio) {\n\t\t\t \n\n\t\t\tscale = (1 << 12) * adjusted_mode->vdisplay / output_mode->vdisplay;\n\t\t\tregp->fp_debug_1 = NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE_ENABLE |\n\t\t\t\t\t   XLATE(scale, divide_by_2, NV_PRAMDAC_FP_DEBUG_1_XSCALE_VALUE);\n\n\t\t\t \n\t\t\tdiff = output_mode->hdisplay -\n\t\t\t       output_mode->vdisplay * mode_ratio / (1 << 12);\n\t\t\tregp->fp_horiz_regs[FP_VALID_START] += diff / 2;\n\t\t\tregp->fp_horiz_regs[FP_VALID_END] -= diff / 2;\n\t\t}\n\n\t\tif (mode_ratio > panel_ratio) {\n\t\t\t \n\n\t\t\tscale = (1 << 12) * adjusted_mode->hdisplay / output_mode->hdisplay;\n\t\t\tregp->fp_debug_1 = NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE_ENABLE |\n\t\t\t\t\t   XLATE(scale, divide_by_2, NV_PRAMDAC_FP_DEBUG_1_YSCALE_VALUE);\n\n\t\t\t \n\t\t\tdiff = output_mode->vdisplay -\n\t\t\t       (1 << 12) * output_mode->hdisplay / mode_ratio;\n\t\t\tregp->fp_vert_regs[FP_VALID_START] += diff / 2;\n\t\t\tregp->fp_vert_regs[FP_VALID_END] -= diff / 2;\n\t\t}\n\t}\n\n\t \n\tif ((nv_connector->dithering_mode == DITHERING_MODE_ON) ||\n\t    (nv_connector->dithering_mode == DITHERING_MODE_AUTO &&\n\t     fb->format->depth > connector->display_info.bpc * 3)) {\n\t\tif (drm->client.device.info.chipset == 0x11)\n\t\t\tregp->dither = savep->dither | 0x00010000;\n\t\telse {\n\t\t\tint i;\n\t\t\tregp->dither = savep->dither | 0x00000001;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tregp->dither_regs[i] = 0xe4e4e4e4;\n\t\t\t\tregp->dither_regs[i + 3] = 0x44444444;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (drm->client.device.info.chipset != 0x11) {\n\t\t\t \n\t\t\tint i;\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tregp->dither_regs[i] = savep->dither_regs[i];\n\t\t\t\tregp->dither_regs[i + 3] = savep->dither_regs[i + 3];\n\t\t\t}\n\t\t}\n\t\tregp->dither = savep->dither;\n\t}\n\n\tregp->fp_margin_color = 0;\n}\n\nstatic void nv04_dfp_commit(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct dcb_output *dcbe = nv_encoder->dcb;\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\tstruct drm_encoder *slave_encoder;\n\n\tif (dcbe->type == DCB_OUTPUT_TMDS)\n\t\trun_tmds_table(dev, dcbe, head, nv_encoder->mode.clock);\n\telse if (dcbe->type == DCB_OUTPUT_LVDS)\n\t\tcall_lvds_script(dev, dcbe, head, LVDS_RESET, nv_encoder->mode.clock);\n\n\t \n\tnv04_display(dev)->mode_reg.crtc_reg[head].fp_control =\n\t\tNVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\n\n\t \n\tif (drm->client.device.info.chipset < 0x44)\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0xf0000000);\n\telse\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0x00100000);\n\n\t \n\tslave_encoder = get_tmds_slave(encoder);\n\tif (slave_encoder)\n\t\tget_slave_funcs(slave_encoder)->mode_set(\n\t\t\tslave_encoder, &nv_encoder->mode, &nv_encoder->mode);\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_ON);\n\n\tNV_DEBUG(drm, \"Output %s is running on CRTC %d using output %c\\n\",\n\t\t nv04_encoder_get_connector(nv_encoder)->base.name,\n\t\t nv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\n}\n\nstatic void nv04_dfp_update_backlight(struct drm_encoder *encoder, int mode)\n{\n#ifdef __powerpc__\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\t \n\tif (pdev->device == 0x0174 || pdev->device == 0x0179 ||\n\t    pdev->device == 0x0189 || pdev->device == 0x0329) {\n\t\tif (mode == DRM_MODE_DPMS_ON) {\n\t\t\tnvif_mask(device, NV_PBUS_DEBUG_DUALHEAD_CTL, 1 << 31, 1 << 31);\n\t\t\tnvif_mask(device, NV_PCRTC_GPIO_EXT, 3, 1);\n\t\t} else {\n\t\t\tnvif_mask(device, NV_PBUS_DEBUG_DUALHEAD_CTL, 1 << 31, 0);\n\t\t\tnvif_mask(device, NV_PCRTC_GPIO_EXT, 3, 0);\n\t\t}\n\t}\n#endif\n}\n\nstatic inline bool is_powersaving_dpms(int mode)\n{\n\treturn mode != DRM_MODE_DPMS_ON && mode != NV_DPMS_CLEARED;\n}\n\nstatic void nv04_lvds_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tbool was_powersaving = is_powersaving_dpms(nv_encoder->last_dpms);\n\n\tif (nv_encoder->last_dpms == mode)\n\t\treturn;\n\tnv_encoder->last_dpms = mode;\n\n\tNV_DEBUG(drm, \"Setting dpms mode %d on lvds encoder (output %d)\\n\",\n\t\t mode, nv_encoder->dcb->index);\n\n\tif (was_powersaving && is_powersaving_dpms(mode))\n\t\treturn;\n\n\tif (nv_encoder->dcb->lvdsconf.use_power_scripts) {\n\t\t \n\t\tint head = crtc ? nouveau_crtc(crtc)->index :\n\t\t\t   nv04_dfp_get_bound_head(dev, nv_encoder->dcb);\n\n\t\tif (mode == DRM_MODE_DPMS_ON) {\n\t\t\tcall_lvds_script(dev, nv_encoder->dcb, head,\n\t\t\t\t\t LVDS_PANEL_ON, nv_encoder->mode.clock);\n\t\t} else\n\t\t\t \n\t\t\tcall_lvds_script(dev, nv_encoder->dcb, head,\n\t\t\t\t\t LVDS_PANEL_OFF, 0);\n\t}\n\n\tnv04_dfp_update_backlight(encoder, mode);\n\tnv04_dfp_update_fp_control(encoder, mode);\n\n\tif (mode == DRM_MODE_DPMS_ON)\n\t\tnv04_dfp_prepare_sel_clk(dev, nv_encoder, nouveau_crtc(crtc)->index);\n\telse {\n\t\tnv04_display(dev)->mode_reg.sel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK);\n\t\tnv04_display(dev)->mode_reg.sel_clk &= ~0xf0;\n\t}\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, nv04_display(dev)->mode_reg.sel_clk);\n}\n\nstatic void nv04_tmds_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\tif (nv_encoder->last_dpms == mode)\n\t\treturn;\n\tnv_encoder->last_dpms = mode;\n\n\tNV_DEBUG(drm, \"Setting dpms mode %d on tmds encoder (output %d)\\n\",\n\t\t mode, nv_encoder->dcb->index);\n\n\tnv04_dfp_update_backlight(encoder, mode);\n\tnv04_dfp_update_fp_control(encoder, mode);\n}\n\nstatic void nv04_dfp_save(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\n\tif (nv_two_heads(dev))\n\t\tnv_encoder->restore.head =\n\t\t\tnv04_dfp_get_bound_head(dev, nv_encoder->dcb);\n}\n\nstatic void nv04_dfp_restore(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\tint head = nv_encoder->restore.head;\n\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS) {\n\t\tstruct nouveau_connector *connector =\n\t\t\tnv04_encoder_get_connector(nv_encoder);\n\n\t\tif (connector && connector->native_mode)\n\t\t\tcall_lvds_script(dev, nv_encoder->dcb, head,\n\t\t\t\t\t LVDS_PANEL_ON,\n\t\t\t\t\t connector->native_mode->clock);\n\n\t} else if (nv_encoder->dcb->type == DCB_OUTPUT_TMDS) {\n\t\tint clock = nouveau_hw_pllvals_to_clk\n\t\t\t\t\t(&nv04_display(dev)->saved_reg.crtc_reg[head].pllvals);\n\n\t\trun_tmds_table(dev, nv_encoder->dcb, head, clock);\n\t}\n\n\tnv_encoder->last_dpms = NV_DPMS_CLEARED;\n}\n\nstatic void nv04_dfp_destroy(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\tif (get_slave_funcs(encoder))\n\t\tget_slave_funcs(encoder)->destroy(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(nv_encoder);\n}\n\nstatic void nv04_tmds_slave_init(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct nvkm_i2c_bus *bus = nvkm_i2c_bus_find(i2c, NVKM_I2C_BUS_PRI);\n\tstruct nvkm_i2c_bus_probe info[] = {\n\t\t{\n\t\t    {\n\t\t        .type = \"sil164\",\n\t\t        .addr = (dcb->tmdsconf.slave_addr == 0x7 ? 0x3a : 0x38),\n\t\t        .platform_data = &(struct sil164_encoder_params) {\n\t\t            SIL164_INPUT_EDGE_RISING\n\t\t         }\n\t\t    }, 0\n\t\t},\n\t\t{ }\n\t};\n\tint type;\n\n\tif (!nv_gf4_disp_arch(dev) || !bus || get_tmds_slave(encoder))\n\t\treturn;\n\n\ttype = nvkm_i2c_bus_probe(bus, \"TMDS transmitter\", info, NULL, NULL);\n\tif (type < 0)\n\t\treturn;\n\n\tdrm_i2c_encoder_init(dev, to_encoder_slave(encoder),\n\t\t\t     &bus->i2c, &info[type].dev);\n}\n\nstatic const struct drm_encoder_helper_funcs nv04_lvds_helper_funcs = {\n\t.dpms = nv04_lvds_dpms,\n\t.mode_fixup = nv04_dfp_mode_fixup,\n\t.prepare = nv04_dfp_prepare,\n\t.commit = nv04_dfp_commit,\n\t.mode_set = nv04_dfp_mode_set,\n\t.detect = NULL,\n};\n\nstatic const struct drm_encoder_helper_funcs nv04_tmds_helper_funcs = {\n\t.dpms = nv04_tmds_dpms,\n\t.mode_fixup = nv04_dfp_mode_fixup,\n\t.prepare = nv04_dfp_prepare,\n\t.commit = nv04_dfp_commit,\n\t.mode_set = nv04_dfp_mode_set,\n\t.detect = NULL,\n};\n\nstatic const struct drm_encoder_funcs nv04_dfp_funcs = {\n\t.destroy = nv04_dfp_destroy,\n};\n\nint\nnv04_dfp_create(struct drm_connector *connector, struct dcb_output *entry)\n{\n\tconst struct drm_encoder_helper_funcs *helper;\n\tstruct nouveau_encoder *nv_encoder = NULL;\n\tstruct drm_encoder *encoder;\n\tint type;\n\n\tswitch (entry->type) {\n\tcase DCB_OUTPUT_TMDS:\n\t\ttype = DRM_MODE_ENCODER_TMDS;\n\t\thelper = &nv04_tmds_helper_funcs;\n\t\tbreak;\n\tcase DCB_OUTPUT_LVDS:\n\t\ttype = DRM_MODE_ENCODER_LVDS;\n\t\thelper = &nv04_lvds_helper_funcs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\n\tif (!nv_encoder)\n\t\treturn -ENOMEM;\n\n\tnv_encoder->enc_save = nv04_dfp_save;\n\tnv_encoder->enc_restore = nv04_dfp_restore;\n\n\tencoder = to_drm_encoder(nv_encoder);\n\n\tnv_encoder->dcb = entry;\n\tnv_encoder->or = ffs(entry->or) - 1;\n\n\tdrm_encoder_init(connector->dev, encoder, &nv04_dfp_funcs, type, NULL);\n\tdrm_encoder_helper_add(encoder, helper);\n\n\tencoder->possible_crtcs = entry->heads;\n\tencoder->possible_clones = 0;\n\n\tif (entry->type == DCB_OUTPUT_TMDS &&\n\t    entry->location != DCB_LOC_ON_CHIP)\n\t\tnv04_tmds_slave_init(encoder);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}