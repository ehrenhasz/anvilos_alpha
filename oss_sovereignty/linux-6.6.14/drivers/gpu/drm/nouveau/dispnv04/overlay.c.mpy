{
  "module_name": "overlay.c",
  "hash_id": "18eeb033d26a8f034dea53488ae3c18f24ca6f8251155b9885d36e50f3e3c5b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/overlay.c",
  "human_readable_source": " \n\n#include <drm/drm_crtc.h>\n#include <drm/drm_fourcc.h>\n\n#include \"nouveau_drv.h\"\n\n#include \"nouveau_bo.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_display.h\"\n#include \"nouveau_gem.h\"\n#include \"nvreg.h\"\n#include \"disp.h\"\n\nstruct nouveau_plane {\n\tstruct drm_plane base;\n\tbool flip;\n\tstruct nouveau_bo *cur;\n\n\tstruct {\n\t\tstruct drm_property *colorkey;\n\t\tstruct drm_property *contrast;\n\t\tstruct drm_property *brightness;\n\t\tstruct drm_property *hue;\n\t\tstruct drm_property *saturation;\n\t} props;\n\n\tint colorkey;\n\tint contrast;\n\tint brightness;\n\tint hue;\n\tint saturation;\n\tenum drm_color_encoding color_encoding;\n\n\tvoid (*set_params)(struct nouveau_plane *);\n};\n\nstatic uint32_t formats[] = {\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_NV12,\n\tDRM_FORMAT_NV21,\n};\n\n \nstatic inline int\nsin_mul(int degrees, int factor)\n{\n\tif (degrees > 180) {\n\t\tdegrees -= 180;\n\t\tfactor *= -1;\n\t}\n\treturn factor * 4 * degrees * (180 - degrees) /\n\t\t(40500 - degrees * (180 - degrees));\n}\n\n \nstatic inline int\ncos_mul(int degrees, int factor)\n{\n\treturn sin_mul((degrees + 90) % 360, factor);\n}\n\nstatic int\nverify_scaling(const struct drm_framebuffer *fb, uint8_t shift,\n               uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h,\n               uint32_t crtc_w, uint32_t crtc_h)\n{\n\tif (crtc_w < (src_w >> shift) || crtc_h < (src_h >> shift)) {\n\t\tDRM_DEBUG_KMS(\"Unsuitable framebuffer scaling: %dx%d -> %dx%d\\n\",\n\t\t\t      src_w, src_h, crtc_w, crtc_h);\n\t\treturn -ERANGE;\n\t}\n\n\tif (src_x != 0 || src_y != 0) {\n\t\tDRM_DEBUG_KMS(\"Unsuitable framebuffer offset: %d,%d\\n\",\n                              src_x, src_y);\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,\n\t\t  struct drm_framebuffer *fb, int crtc_x, int crtc_y,\n\t\t  unsigned int crtc_w, unsigned int crtc_h,\n\t\t  uint32_t src_x, uint32_t src_y,\n\t\t  uint32_t src_w, uint32_t src_h,\n\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(plane->dev);\n\tstruct nvif_object *dev = &drm->client.device.object;\n\tstruct nouveau_plane *nv_plane =\n\t\tcontainer_of(plane, struct nouveau_plane, base);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct nouveau_bo *cur = nv_plane->cur;\n\tstruct nouveau_bo *nvbo;\n\tbool flip = nv_plane->flip;\n\tint soff = NV_PCRTC0_SIZE * nv_crtc->index;\n\tint soff2 = NV_PCRTC0_SIZE * !nv_crtc->index;\n\tunsigned shift = drm->client.device.info.chipset >= 0x30 ? 1 : 3;\n\tunsigned format = 0;\n\tint ret;\n\n\t \n\tsrc_x >>= 16;\n\tsrc_y >>= 16;\n\tsrc_w >>= 16;\n\tsrc_h >>= 16;\n\n\tret = verify_scaling(fb, shift, 0, 0, src_w, src_h, crtc_w, crtc_h);\n\tif (ret)\n\t\treturn ret;\n\n\tnvbo = nouveau_gem_object(fb->obj[0]);\n\tret = nouveau_bo_pin(nvbo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\tif (ret)\n\t\treturn ret;\n\n\tnv_plane->cur = nvbo;\n\n\tnvif_mask(dev, NV_PCRTC_ENGINE_CTRL + soff, NV_CRTC_FSEL_OVERLAY, NV_CRTC_FSEL_OVERLAY);\n\tnvif_mask(dev, NV_PCRTC_ENGINE_CTRL + soff2, NV_CRTC_FSEL_OVERLAY, 0);\n\n\tnvif_wr32(dev, NV_PVIDEO_BASE(flip), 0);\n\tnvif_wr32(dev, NV_PVIDEO_OFFSET_BUFF(flip), nvbo->offset);\n\tnvif_wr32(dev, NV_PVIDEO_SIZE_IN(flip), src_h << 16 | src_w);\n\tnvif_wr32(dev, NV_PVIDEO_POINT_IN(flip), src_y << 16 | src_x);\n\tnvif_wr32(dev, NV_PVIDEO_DS_DX(flip), (src_w << 20) / crtc_w);\n\tnvif_wr32(dev, NV_PVIDEO_DT_DY(flip), (src_h << 20) / crtc_h);\n\tnvif_wr32(dev, NV_PVIDEO_POINT_OUT(flip), crtc_y << 16 | crtc_x);\n\tnvif_wr32(dev, NV_PVIDEO_SIZE_OUT(flip), crtc_h << 16 | crtc_w);\n\n\tif (fb->format->format == DRM_FORMAT_YUYV ||\n\t    fb->format->format == DRM_FORMAT_NV12)\n\t\tformat |= NV_PVIDEO_FORMAT_COLOR_LE_CR8YB8CB8YA8;\n\tif (fb->format->format == DRM_FORMAT_NV12 ||\n\t    fb->format->format == DRM_FORMAT_NV21)\n\t\tformat |= NV_PVIDEO_FORMAT_PLANAR;\n\tif (nv_plane->color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\tformat |= NV_PVIDEO_FORMAT_MATRIX_ITURBT709;\n\tif (nv_plane->colorkey & (1 << 24))\n\t\tformat |= NV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY;\n\n\tif (format & NV_PVIDEO_FORMAT_PLANAR) {\n\t\tnvif_wr32(dev, NV_PVIDEO_UVPLANE_BASE(flip), 0);\n\t\tnvif_wr32(dev, NV_PVIDEO_UVPLANE_OFFSET_BUFF(flip),\n\t\t\tnvbo->offset + fb->offsets[1]);\n\t}\n\tnvif_wr32(dev, NV_PVIDEO_FORMAT(flip), format | fb->pitches[0]);\n\tnvif_wr32(dev, NV_PVIDEO_STOP, 0);\n\t \n\tnvif_wr32(dev, NV_PVIDEO_BUFFER, flip ? 0x10 : 0x1);\n\tnv_plane->flip = !flip;\n\n\tif (cur)\n\t\tnouveau_bo_unpin(cur);\n\n\treturn 0;\n}\n\nstatic int\nnv10_disable_plane(struct drm_plane *plane,\n\t\t   struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct nvif_object *dev = &nouveau_drm(plane->dev)->client.device.object;\n\tstruct nouveau_plane *nv_plane =\n\t\tcontainer_of(plane, struct nouveau_plane, base);\n\n\tnvif_wr32(dev, NV_PVIDEO_STOP, 1);\n\tif (nv_plane->cur) {\n\t\tnouveau_bo_unpin(nv_plane->cur);\n\t\tnv_plane->cur = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv_destroy_plane(struct drm_plane *plane)\n{\n\tdrm_plane_force_disable(plane);\n\tdrm_plane_cleanup(plane);\n\tkfree(plane);\n}\n\nstatic void\nnv10_set_params(struct nouveau_plane *plane)\n{\n\tstruct nvif_object *dev = &nouveau_drm(plane->base.dev)->client.device.object;\n\tu32 luma = (plane->brightness - 512) << 16 | plane->contrast;\n\tu32 chroma = ((sin_mul(plane->hue, plane->saturation) & 0xffff) << 16) |\n\t\t(cos_mul(plane->hue, plane->saturation) & 0xffff);\n\tu32 format = 0;\n\n\tnvif_wr32(dev, NV_PVIDEO_LUMINANCE(0), luma);\n\tnvif_wr32(dev, NV_PVIDEO_LUMINANCE(1), luma);\n\tnvif_wr32(dev, NV_PVIDEO_CHROMINANCE(0), chroma);\n\tnvif_wr32(dev, NV_PVIDEO_CHROMINANCE(1), chroma);\n\tnvif_wr32(dev, NV_PVIDEO_COLOR_KEY, plane->colorkey & 0xffffff);\n\n\tif (plane->cur) {\n\t\tif (plane->color_encoding == DRM_COLOR_YCBCR_BT709)\n\t\t\tformat |= NV_PVIDEO_FORMAT_MATRIX_ITURBT709;\n\t\tif (plane->colorkey & (1 << 24))\n\t\t\tformat |= NV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY;\n\t\tnvif_mask(dev, NV_PVIDEO_FORMAT(plane->flip),\n\t\t\tNV_PVIDEO_FORMAT_MATRIX_ITURBT709 |\n\t\t\tNV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY,\n\t\t\tformat);\n\t}\n}\n\nstatic int\nnv_set_property(struct drm_plane *plane,\n\t\tstruct drm_property *property,\n\t\tuint64_t value)\n{\n\tstruct nouveau_plane *nv_plane =\n\t\tcontainer_of(plane, struct nouveau_plane, base);\n\n\tif (property == nv_plane->props.colorkey)\n\t\tnv_plane->colorkey = value;\n\telse if (property == nv_plane->props.contrast)\n\t\tnv_plane->contrast = value;\n\telse if (property == nv_plane->props.brightness)\n\t\tnv_plane->brightness = value;\n\telse if (property == nv_plane->props.hue)\n\t\tnv_plane->hue = value;\n\telse if (property == nv_plane->props.saturation)\n\t\tnv_plane->saturation = value;\n\telse if (property == nv_plane->base.color_encoding_property)\n\t\tnv_plane->color_encoding = value;\n\telse\n\t\treturn -EINVAL;\n\n\tif (nv_plane->set_params)\n\t\tnv_plane->set_params(nv_plane);\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs nv10_plane_funcs = {\n\t.update_plane = nv10_update_plane,\n\t.disable_plane = nv10_disable_plane,\n\t.set_property = nv_set_property,\n\t.destroy = nv_destroy_plane,\n};\n\nstatic void\nnv10_overlay_init(struct drm_device *device)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(device);\n\tstruct nouveau_plane *plane = kzalloc(sizeof(struct nouveau_plane), GFP_KERNEL);\n\tunsigned int num_formats = ARRAY_SIZE(formats);\n\tint ret;\n\n\tif (!plane)\n\t\treturn;\n\n\tswitch (drm->client.device.info.chipset) {\n\tcase 0x10:\n\tcase 0x11:\n\tcase 0x15:\n\tcase 0x1a:\n\tcase 0x20:\n\t\tnum_formats = 2;\n\t\tbreak;\n\t}\n\n\tret = drm_universal_plane_init(device, &plane->base, 3  ,\n\t\t\t\t       &nv10_plane_funcs,\n\t\t\t\t       formats, num_formats, NULL,\n\t\t\t\t       DRM_PLANE_TYPE_OVERLAY, NULL);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tplane->props.colorkey = drm_property_create_range(\n\t\t\tdevice, 0, \"colorkey\", 0, 0x01ffffff);\n\tplane->props.contrast = drm_property_create_range(\n\t\t\tdevice, 0, \"contrast\", 0, 8192 - 1);\n\tplane->props.brightness = drm_property_create_range(\n\t\t\tdevice, 0, \"brightness\", 0, 1024);\n\tplane->props.hue = drm_property_create_range(\n\t\t\tdevice, 0, \"hue\", 0, 359);\n\tplane->props.saturation = drm_property_create_range(\n\t\t\tdevice, 0, \"saturation\", 0, 8192 - 1);\n\tif (!plane->props.colorkey ||\n\t    !plane->props.contrast ||\n\t    !plane->props.brightness ||\n\t    !plane->props.hue ||\n\t    !plane->props.saturation)\n\t\tgoto cleanup;\n\n\tplane->colorkey = 0;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.colorkey, plane->colorkey);\n\n\tplane->contrast = 0x1000;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.contrast, plane->contrast);\n\n\tplane->brightness = 512;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.brightness, plane->brightness);\n\n\tplane->hue = 0;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.hue, plane->hue);\n\n\tplane->saturation = 0x1000;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.saturation, plane->saturation);\n\n\tplane->color_encoding = DRM_COLOR_YCBCR_BT601;\n\tdrm_plane_create_color_properties(&plane->base,\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_BT709),\n\t\t\t\t\t  BIT(DRM_COLOR_YCBCR_LIMITED_RANGE),\n\t\t\t\t\t  DRM_COLOR_YCBCR_BT601,\n\t\t\t\t\t  DRM_COLOR_YCBCR_LIMITED_RANGE);\n\n\tplane->set_params = nv10_set_params;\n\tnv10_set_params(plane);\n\tdrm_plane_force_disable(&plane->base);\n\treturn;\ncleanup:\n\tdrm_plane_cleanup(&plane->base);\nerr:\n\tkfree(plane);\n\tNV_ERROR(drm, \"Failed to create plane\\n\");\n}\n\nstatic int\nnv04_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,\n\t\t  struct drm_framebuffer *fb, int crtc_x, int crtc_y,\n\t\t  unsigned int crtc_w, unsigned int crtc_h,\n\t\t  uint32_t src_x, uint32_t src_y,\n\t\t  uint32_t src_w, uint32_t src_h,\n\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct nvif_object *dev = &nouveau_drm(plane->dev)->client.device.object;\n\tstruct nouveau_plane *nv_plane =\n\t\tcontainer_of(plane, struct nouveau_plane, base);\n\tstruct nouveau_bo *cur = nv_plane->cur;\n\tstruct nouveau_bo *nvbo;\n\tuint32_t overlay = 1;\n\tint brightness = (nv_plane->brightness - 512) * 62 / 512;\n\tint ret, i;\n\n\t \n\tsrc_x >>= 16;\n\tsrc_y >>= 16;\n\tsrc_w >>= 16;\n\tsrc_h >>= 16;\n\n\tret = verify_scaling(fb, 0, src_x, src_y, src_w, src_h, crtc_w, crtc_h);\n\tif (ret)\n\t\treturn ret;\n\n\tnvbo = nouveau_gem_object(fb->obj[0]);\n\tret = nouveau_bo_pin(nvbo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\tif (ret)\n\t\treturn ret;\n\n\tnv_plane->cur = nvbo;\n\n\tnvif_wr32(dev, NV_PVIDEO_OE_STATE, 0);\n\tnvif_wr32(dev, NV_PVIDEO_SU_STATE, 0);\n\tnvif_wr32(dev, NV_PVIDEO_RM_STATE, 0);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tnvif_wr32(dev, NV_PVIDEO_BUFF0_START_ADDRESS + 4 * i,\n\t\t\t  nvbo->offset);\n\t\tnvif_wr32(dev, NV_PVIDEO_BUFF0_PITCH_LENGTH + 4 * i,\n\t\t\t  fb->pitches[0]);\n\t\tnvif_wr32(dev, NV_PVIDEO_BUFF0_OFFSET + 4 * i, 0);\n\t}\n\tnvif_wr32(dev, NV_PVIDEO_WINDOW_START, crtc_y << 16 | crtc_x);\n\tnvif_wr32(dev, NV_PVIDEO_WINDOW_SIZE, crtc_h << 16 | crtc_w);\n\tnvif_wr32(dev, NV_PVIDEO_STEP_SIZE,\n\t\t(uint32_t)(((src_h - 1) << 11) / (crtc_h - 1)) << 16 | (uint32_t)(((src_w - 1) << 11) / (crtc_w - 1)));\n\n\t \n\tnvif_wr32(dev, NV_PVIDEO_RED_CSC_OFFSET, 0x69 - brightness);\n\tnvif_wr32(dev, NV_PVIDEO_GREEN_CSC_OFFSET, 0x3e + brightness);\n\tnvif_wr32(dev, NV_PVIDEO_BLUE_CSC_OFFSET, 0x89 - brightness);\n\tnvif_wr32(dev, NV_PVIDEO_CSC_ADJUST, 0);\n\n\tnvif_wr32(dev, NV_PVIDEO_CONTROL_Y, 0x001);  \n\tnvif_wr32(dev, NV_PVIDEO_CONTROL_X, 0x111);  \n\n\tnvif_wr32(dev, NV_PVIDEO_FIFO_BURST_LENGTH, 0x03);\n\tnvif_wr32(dev, NV_PVIDEO_FIFO_THRES_SIZE, 0x38);\n\n\tnvif_wr32(dev, NV_PVIDEO_KEY, nv_plane->colorkey);\n\n\tif (nv_plane->colorkey & (1 << 24))\n\t\toverlay |= 0x10;\n\tif (fb->format->format == DRM_FORMAT_YUYV)\n\t\toverlay |= 0x100;\n\n\tnvif_wr32(dev, NV_PVIDEO_OVERLAY, overlay);\n\n\tnvif_wr32(dev, NV_PVIDEO_SU_STATE, nvif_rd32(dev, NV_PVIDEO_SU_STATE) ^ (1 << 16));\n\n\tif (cur)\n\t\tnouveau_bo_unpin(cur);\n\n\treturn 0;\n}\n\nstatic int\nnv04_disable_plane(struct drm_plane *plane,\n\t\t   struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct nvif_object *dev = &nouveau_drm(plane->dev)->client.device.object;\n\tstruct nouveau_plane *nv_plane =\n\t\tcontainer_of(plane, struct nouveau_plane, base);\n\n\tnvif_mask(dev, NV_PVIDEO_OVERLAY, 1, 0);\n\tnvif_wr32(dev, NV_PVIDEO_OE_STATE, 0);\n\tnvif_wr32(dev, NV_PVIDEO_SU_STATE, 0);\n\tnvif_wr32(dev, NV_PVIDEO_RM_STATE, 0);\n\tif (nv_plane->cur) {\n\t\tnouveau_bo_unpin(nv_plane->cur);\n\t\tnv_plane->cur = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_funcs nv04_plane_funcs = {\n\t.update_plane = nv04_update_plane,\n\t.disable_plane = nv04_disable_plane,\n\t.set_property = nv_set_property,\n\t.destroy = nv_destroy_plane,\n};\n\nstatic void\nnv04_overlay_init(struct drm_device *device)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(device);\n\tstruct nouveau_plane *plane = kzalloc(sizeof(struct nouveau_plane), GFP_KERNEL);\n\tint ret;\n\n\tif (!plane)\n\t\treturn;\n\n\tret = drm_universal_plane_init(device, &plane->base, 1  ,\n\t\t\t\t       &nv04_plane_funcs, formats, 2, NULL,\n\t\t\t\t       DRM_PLANE_TYPE_OVERLAY, NULL);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tplane->props.colorkey = drm_property_create_range(\n\t\t\tdevice, 0, \"colorkey\", 0, 0x01ffffff);\n\tplane->props.brightness = drm_property_create_range(\n\t\t\tdevice, 0, \"brightness\", 0, 1024);\n\tif (!plane->props.colorkey ||\n\t    !plane->props.brightness)\n\t\tgoto cleanup;\n\n\tplane->colorkey = 0;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.colorkey, plane->colorkey);\n\n\tplane->brightness = 512;\n\tdrm_object_attach_property(&plane->base.base,\n\t\t\t\t   plane->props.brightness, plane->brightness);\n\n\tdrm_plane_force_disable(&plane->base);\n\treturn;\ncleanup:\n\tdrm_plane_cleanup(&plane->base);\nerr:\n\tkfree(plane);\n\tNV_ERROR(drm, \"Failed to create plane\\n\");\n}\n\nvoid\nnouveau_overlay_init(struct drm_device *device)\n{\n\tstruct nvif_device *dev = &nouveau_drm(device)->client.device;\n\tif (dev->info.chipset < 0x10)\n\t\tnv04_overlay_init(device);\n\telse if (dev->info.chipset <= 0x40)\n\t\tnv10_overlay_init(device);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}