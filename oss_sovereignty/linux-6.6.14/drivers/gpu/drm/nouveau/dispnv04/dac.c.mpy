{
  "module_name": "dac.c",
  "hash_id": "9958bf7acc2808ecb475b8a9f4e7963eb59491b51a80633ae3f7615b11aa4fd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/dac.c",
  "human_readable_source": " \n\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_crtc.h\"\n#include \"hw.h\"\n#include \"nvreg.h\"\n\n#include <subdev/bios/gpio.h>\n#include <subdev/gpio.h>\n\n#include <nvif/timer.h>\n\nint nv04_dac_output_offset(struct drm_encoder *encoder)\n{\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\tint offset = 0;\n\n\tif (dcb->or & (8 | DCB_OUTPUT_C))\n\t\toffset += 0x68;\n\tif (dcb->or & (8 | DCB_OUTPUT_B))\n\t\toffset += 0x2000;\n\n\treturn offset;\n}\n\n \n#define MAX_HBLANK_OSC 20\n\n \n#define MAX_SAMPLE_PAIRS 10\n\nstatic int sample_load_twice(struct drm_device *dev, bool sense[2])\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tbool sense_a, sense_b, sense_b_prime;\n\t\tint j = 0;\n\n\t\t \n\t\tif (nvif_msec(&drm->client.device, 10,\n\t\t\tif (!(nvif_rd32(device, NV_PRMCIO_INP0__COLOR) & 1))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\n\t\tif (nvif_msec(&drm->client.device, 10,\n\t\t\tif ( (nvif_rd32(device, NV_PRMCIO_INP0__COLOR) & 1))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\n\t\tif (nvif_msec(&drm->client.device, 10,\n\t\t\tif (!(nvif_rd32(device, NV_PRMCIO_INP0__COLOR) & 1))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -EBUSY;\n\n\t\tudelay(100);\n\t\t \n\t\tsense_a = nvif_rd08(device, NV_PRMCIO_INP0) & 0x10;\n\n\t\t \n\t\tdo {\n\t\t\tudelay(100);\n\t\t\tsense_b = nvif_rd08(device, NV_PRMCIO_INP0) & 0x10;\n\t\t\tif (sense_a != sense_b) {\n\t\t\t\tsense_b_prime =\n\t\t\t\t\tnvif_rd08(device, NV_PRMCIO_INP0) & 0x10;\n\t\t\t\tif (sense_b == sense_b_prime) {\n\t\t\t\t\t \n\t\t\t\t\tsense_a = sense_b;\n\t\t\t\t\t \n\t\t\t\t\tsense_b = !sense_a;\n\t\t\t\t}\n\t\t\t}\n\t\t} while ((sense_a != sense_b) && ++j < MAX_HBLANK_OSC);\n\n\t\tif (j == MAX_HBLANK_OSC)\n\t\t\t \n\t\t\tsense[i] = false;\n\t\telse\n\t\t\tsense[i] = sense_a;\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_connector_status nv04_dac_detect(struct drm_encoder *encoder,\n\t\t\t\t\t\t struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint8_t saved_seq1, saved_pi, saved_rpc1, saved_cr_mode;\n\tuint8_t saved_palette0[3], saved_palette_mask;\n\tuint32_t saved_rtest_ctrl, saved_rgen_ctrl;\n\tint i;\n\tuint8_t blue;\n\tbool sense = true;\n\n\t \n\n\tif (nv_two_heads(dev))\n\t\t \n\t\tNVSetOwner(dev, 0);\n\n\tsaved_cr_mode = NVReadVgaCrtc(dev, 0, NV_CIO_CR_MODE_INDEX);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CR_MODE_INDEX, saved_cr_mode | 0x80);\n\n\tsaved_seq1 = NVReadVgaSeq(dev, 0, NV_VIO_SR_CLOCK_INDEX);\n\tNVWriteVgaSeq(dev, 0, NV_VIO_SR_CLOCK_INDEX, saved_seq1 & ~0x20);\n\n\tsaved_rtest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL,\n\t\t      saved_rtest_ctrl & ~NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF);\n\n\tmsleep(10);\n\n\tsaved_pi = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX,\n\t\t       saved_pi & ~(0x80 | MASK(NV_CIO_CRE_PIXEL_FORMAT)));\n\tsaved_rpc1 = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_RPC1_INDEX);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_RPC1_INDEX, saved_rpc1 & ~0xc0);\n\n\tnvif_wr08(device, NV_PRMDIO_READ_MODE_ADDRESS, 0x0);\n\tfor (i = 0; i < 3; i++)\n\t\tsaved_palette0[i] = nvif_rd08(device, NV_PRMDIO_PALETTE_DATA);\n\tsaved_palette_mask = nvif_rd08(device, NV_PRMDIO_PIXEL_MASK);\n\tnvif_wr08(device, NV_PRMDIO_PIXEL_MASK, 0);\n\n\tsaved_rgen_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_GENERAL_CONTROL);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_GENERAL_CONTROL,\n\t\t      (saved_rgen_ctrl & ~(NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS |\n\t\t\t\t\t   NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM)) |\n\t\t      NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON);\n\n\tblue = 8;\t \n\n\tdo {\n\t\tbool sense_pair[2];\n\n\t\tnvif_wr08(device, NV_PRMDIO_WRITE_MODE_ADDRESS, 0);\n\t\tnvif_wr08(device, NV_PRMDIO_PALETTE_DATA, 0);\n\t\tnvif_wr08(device, NV_PRMDIO_PALETTE_DATA, 0);\n\t\t \n\t\tnvif_wr08(device, NV_PRMDIO_PALETTE_DATA, blue);\n\n\t\ti = 0;\n\t\t \n\t\tdo {\n\t\t\tif (sample_load_twice(dev, sense_pair))\n\t\t\t\tgoto out;\n\t\t} while ((sense_pair[0] != sense_pair[1]) &&\n\t\t\t\t\t\t\t++i < MAX_SAMPLE_PAIRS);\n\n\t\tif (i == MAX_SAMPLE_PAIRS)\n\t\t\t \n\t\t\tsense = false;\n\t\telse\n\t\t\tsense = sense_pair[0];\n\n\t \n\t} while (++blue < 0x18 && sense);\n\nout:\n\tnvif_wr08(device, NV_PRMDIO_PIXEL_MASK, saved_palette_mask);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_GENERAL_CONTROL, saved_rgen_ctrl);\n\tnvif_wr08(device, NV_PRMDIO_WRITE_MODE_ADDRESS, 0);\n\tfor (i = 0; i < 3; i++)\n\t\tnvif_wr08(device, NV_PRMDIO_PALETTE_DATA, saved_palette0[i]);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL, saved_rtest_ctrl);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_PIXEL_INDEX, saved_pi);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_RPC1_INDEX, saved_rpc1);\n\tNVWriteVgaSeq(dev, 0, NV_VIO_SR_CLOCK_INDEX, saved_seq1);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CR_MODE_INDEX, saved_cr_mode);\n\n\tif (blue == 0x18) {\n\t\tNV_DEBUG(drm, \"Load detected on head A\\n\");\n\t\treturn connector_status_connected;\n\t}\n\n\treturn connector_status_disconnected;\n}\n\nuint32_t nv17_dac_sample_load(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nvkm_gpio *gpio = nvxx_gpio(&drm->client.device);\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\tuint32_t sample, testval, regoffset = nv04_dac_output_offset(encoder);\n\tuint32_t saved_powerctrl_2 = 0, saved_powerctrl_4 = 0, saved_routput,\n\t\tsaved_rtest_ctrl, saved_gpio0 = 0, saved_gpio1 = 0, temp, routput;\n\tint head;\n\n#define RGB_TEST_DATA(r, g, b) (r << 0 | g << 10 | b << 20)\n\tif (dcb->type == DCB_OUTPUT_TV) {\n\t\ttestval = RGB_TEST_DATA(0xa0, 0xa0, 0xa0);\n\n\t\tif (drm->vbios.tvdactestval)\n\t\t\ttestval = drm->vbios.tvdactestval;\n\t} else {\n\t\ttestval = RGB_TEST_DATA(0x140, 0x140, 0x140);  \n\n\t\tif (drm->vbios.dactestval)\n\t\t\ttestval = drm->vbios.dactestval;\n\t}\n\n\tsaved_rtest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset,\n\t\t      saved_rtest_ctrl & ~NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF);\n\n\tsaved_powerctrl_2 = nvif_rd32(device, NV_PBUS_POWERCTRL_2);\n\n\tnvif_wr32(device, NV_PBUS_POWERCTRL_2, saved_powerctrl_2 & 0xd7ffffff);\n\tif (regoffset == 0x68) {\n\t\tsaved_powerctrl_4 = nvif_rd32(device, NV_PBUS_POWERCTRL_4);\n\t\tnvif_wr32(device, NV_PBUS_POWERCTRL_4, saved_powerctrl_4 & 0xffffffcf);\n\t}\n\n\tif (gpio) {\n\t\tsaved_gpio1 = nvkm_gpio_get(gpio, 0, DCB_GPIO_TVDAC1, 0xff);\n\t\tsaved_gpio0 = nvkm_gpio_get(gpio, 0, DCB_GPIO_TVDAC0, 0xff);\n\t\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC1, 0xff, dcb->type == DCB_OUTPUT_TV);\n\t\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC0, 0xff, dcb->type == DCB_OUTPUT_TV);\n\t}\n\n\tmsleep(4);\n\n\tsaved_routput = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);\n\thead = (saved_routput & 0x100) >> 8;\n\n\t \n\tif (!(NVReadVgaCrtc(dev, head, NV_CIO_CRE_RPC1_INDEX) & 0xC0))\n\t\thead ^= 1;\n\n\t \n\troutput = (saved_routput & 0xfffffece) | head << 8;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CURIE) {\n\t\tif (dcb->type == DCB_OUTPUT_TV)\n\t\t\troutput |= 0x1a << 16;\n\t\telse\n\t\t\troutput &= ~(0x1a << 16);\n\t}\n\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, routput);\n\tmsleep(1);\n\n\ttemp = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, temp | 1);\n\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TESTPOINT_DATA,\n\t\t      NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK | testval);\n\ttemp = NVReadRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL,\n\t\t      temp | NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED);\n\tmsleep(5);\n\n\tsample = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\n\t \n\tsample &= NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\n\n\ttemp = NVReadRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL,\n\t\t      temp & ~NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TESTPOINT_DATA, 0);\n\n\t \n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, saved_routput);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset, saved_rtest_ctrl);\n\tif (regoffset == 0x68)\n\t\tnvif_wr32(device, NV_PBUS_POWERCTRL_4, saved_powerctrl_4);\n\tnvif_wr32(device, NV_PBUS_POWERCTRL_2, saved_powerctrl_2);\n\n\tif (gpio) {\n\t\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC1, 0xff, saved_gpio1);\n\t\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC0, 0xff, saved_gpio0);\n\t}\n\n\treturn sample;\n}\n\nstatic enum drm_connector_status\nnv17_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\n\tif (nv04_dac_in_use(encoder))\n\t\treturn connector_status_disconnected;\n\n\tif (nv17_dac_sample_load(encoder) &\n\t    NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI) {\n\t\tNV_DEBUG(drm, \"Load detected on output %c\\n\",\n\t\t\t '@' + ffs(dcb->or));\n\t\treturn connector_status_connected;\n\t} else {\n\t\treturn connector_status_disconnected;\n\t}\n}\n\nstatic bool nv04_dac_mode_fixup(struct drm_encoder *encoder,\n\t\t\t\tconst struct drm_display_mode *mode,\n\t\t\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tif (nv04_dac_in_use(encoder))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void nv04_dac_prepare(struct drm_encoder *encoder)\n{\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\tstruct drm_device *dev = encoder->dev;\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_OFF);\n\n\tnv04_dfp_disable(dev, head);\n}\n\nstatic void nv04_dac_mode_set(struct drm_encoder *encoder,\n\t\t\t      struct drm_display_mode *mode,\n\t\t\t      struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\n\tif (nv_gf4_disp_arch(dev)) {\n\t\tstruct drm_encoder *rebind;\n\t\tuint32_t dac_offset = nv04_dac_output_offset(encoder);\n\t\tuint32_t otherdac;\n\n\t\t \n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + dac_offset,\n\t\t\t      head << 8 | NV_PRAMDAC_DACCLK_SEL_DACCLK);\n\t\t \n\t\tlist_for_each_entry(rebind, &dev->mode_config.encoder_list, head) {\n\t\t\tif (rebind == encoder\n\t\t\t    || nouveau_encoder(rebind)->dcb->type != DCB_OUTPUT_ANALOG)\n\t\t\t\tcontinue;\n\n\t\t\tdac_offset = nv04_dac_output_offset(rebind);\n\t\t\totherdac = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + dac_offset);\n\t\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + dac_offset,\n\t\t\t\t      (otherdac & ~0x0100) | (head ^ 1) << 8);\n\t\t}\n\t}\n\n\t \n\tif (drm->client.device.info.chipset < 0x44)\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0xf0000000);\n\telse\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + nv04_dac_output_offset(encoder), 0x00100000);\n}\n\nstatic void nv04_dac_commit(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_ON);\n\n\tNV_DEBUG(drm, \"Output %s is running on CRTC %d using output %c\\n\",\n\t\t nv04_encoder_get_connector(nv_encoder)->base.name,\n\t\t nv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\n}\n\nvoid nv04_dac_update_dacclk(struct drm_encoder *encoder, bool enable)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\n\tif (nv_gf4_disp_arch(dev)) {\n\t\tuint32_t *dac_users = &nv04_display(dev)->dac_users[ffs(dcb->or) - 1];\n\t\tint dacclk_off = NV_PRAMDAC_DACCLK + nv04_dac_output_offset(encoder);\n\t\tuint32_t dacclk = NVReadRAMDAC(dev, 0, dacclk_off);\n\n\t\tif (enable) {\n\t\t\t*dac_users |= 1 << dcb->index;\n\t\t\tNVWriteRAMDAC(dev, 0, dacclk_off, dacclk | NV_PRAMDAC_DACCLK_SEL_DACCLK);\n\n\t\t} else {\n\t\t\t*dac_users &= ~(1 << dcb->index);\n\t\t\tif (!*dac_users)\n\t\t\t\tNVWriteRAMDAC(dev, 0, dacclk_off,\n\t\t\t\t\tdacclk & ~NV_PRAMDAC_DACCLK_SEL_DACCLK);\n\t\t}\n\t}\n}\n\n \nbool nv04_dac_in_use(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\n\treturn nv_gf4_disp_arch(encoder->dev) &&\n\t\t(nv04_display(dev)->dac_users[ffs(dcb->or) - 1] & ~(1 << dcb->index));\n}\n\nstatic void nv04_dac_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\n\tif (nv_encoder->last_dpms == mode)\n\t\treturn;\n\tnv_encoder->last_dpms = mode;\n\n\tNV_DEBUG(drm, \"Setting dpms mode %d on vga encoder (output %d)\\n\",\n\t\t mode, nv_encoder->dcb->index);\n\n\tnv04_dac_update_dacclk(encoder, mode == DRM_MODE_DPMS_ON);\n}\n\nstatic void nv04_dac_save(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\n\tif (nv_gf4_disp_arch(dev))\n\t\tnv_encoder->restore.output = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK +\n\t\t\t\t\t\t\t  nv04_dac_output_offset(encoder));\n}\n\nstatic void nv04_dac_restore(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\n\tif (nv_gf4_disp_arch(dev))\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + nv04_dac_output_offset(encoder),\n\t\t\t      nv_encoder->restore.output);\n\n\tnv_encoder->last_dpms = NV_DPMS_CLEARED;\n}\n\nstatic void nv04_dac_destroy(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(nv_encoder);\n}\n\nstatic const struct drm_encoder_helper_funcs nv04_dac_helper_funcs = {\n\t.dpms = nv04_dac_dpms,\n\t.mode_fixup = nv04_dac_mode_fixup,\n\t.prepare = nv04_dac_prepare,\n\t.commit = nv04_dac_commit,\n\t.mode_set = nv04_dac_mode_set,\n\t.detect = nv04_dac_detect\n};\n\nstatic const struct drm_encoder_helper_funcs nv17_dac_helper_funcs = {\n\t.dpms = nv04_dac_dpms,\n\t.mode_fixup = nv04_dac_mode_fixup,\n\t.prepare = nv04_dac_prepare,\n\t.commit = nv04_dac_commit,\n\t.mode_set = nv04_dac_mode_set,\n\t.detect = nv17_dac_detect\n};\n\nstatic const struct drm_encoder_funcs nv04_dac_funcs = {\n\t.destroy = nv04_dac_destroy,\n};\n\nint\nnv04_dac_create(struct drm_connector *connector, struct dcb_output *entry)\n{\n\tconst struct drm_encoder_helper_funcs *helper;\n\tstruct nouveau_encoder *nv_encoder = NULL;\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_encoder *encoder;\n\n\tnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\n\tif (!nv_encoder)\n\t\treturn -ENOMEM;\n\n\tencoder = to_drm_encoder(nv_encoder);\n\n\tnv_encoder->dcb = entry;\n\tnv_encoder->or = ffs(entry->or) - 1;\n\n\tnv_encoder->enc_save = nv04_dac_save;\n\tnv_encoder->enc_restore = nv04_dac_restore;\n\n\tif (nv_gf4_disp_arch(dev))\n\t\thelper = &nv17_dac_helper_funcs;\n\telse\n\t\thelper = &nv04_dac_helper_funcs;\n\n\tdrm_encoder_init(dev, encoder, &nv04_dac_funcs, DRM_MODE_ENCODER_DAC,\n\t\t\t NULL);\n\tdrm_encoder_helper_add(encoder, helper);\n\n\tencoder->possible_crtcs = entry->heads;\n\tencoder->possible_clones = 0;\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}