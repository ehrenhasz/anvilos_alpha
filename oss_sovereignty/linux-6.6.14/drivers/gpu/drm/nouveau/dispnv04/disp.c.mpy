{
  "module_name": "disp.c",
  "hash_id": "d68d6c81297303f6818f536f04d218725925564fa8b65a264b94b6fe5ec22bc8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/disp.c",
  "human_readable_source": " \n\n#include <drm/drm_crtc_helper.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"hw.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_bo.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_chan.h\"\n\n#include <nvif/if0004.h>\n\nstruct nouveau_connector *\nnv04_encoder_get_connector(struct nouveau_encoder *encoder)\n{\n\tstruct drm_device *dev = to_drm_encoder(encoder)->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct nouveau_connector *nv_connector = NULL;\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder == to_drm_encoder(encoder))\n\t\t\tnv_connector = nouveau_connector(connector);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn nv_connector;\n}\n\nstatic void\nnv04_display_fini(struct drm_device *dev, bool runtime, bool suspend)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv04_display *disp = nv04_display(dev);\n\tstruct drm_crtc *crtc;\n\n\t \n\tnvif_event_block(&disp->flip);\n\n\t \n\tNVWriteCRTC(dev, 0, NV_PCRTC_INTR_EN_0, 0);\n\tif (nv_two_heads(dev))\n\t\tNVWriteCRTC(dev, 1, NV_PCRTC_INTR_EN_0, 0);\n\n\tif (!runtime)\n\t\tcancel_work_sync(&drm->hpd_work);\n\n\tif (!suspend)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\t\tstruct nouveau_bo *nvbo;\n\n\t\tif (!fb || !fb->obj[0])\n\t\t\tcontinue;\n\t\tnvbo = nouveau_gem_object(fb->obj[0]);\n\t\tnouveau_bo_unpin(nvbo);\n\t}\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\t\tif (nv_crtc->cursor.nvbo) {\n\t\t\tif (nv_crtc->cursor.set_offset)\n\t\t\t\tnouveau_bo_unmap(nv_crtc->cursor.nvbo);\n\t\t\tnouveau_bo_unpin(nv_crtc->cursor.nvbo);\n\t\t}\n\t}\n}\n\nstatic int\nnv04_display_init(struct drm_device *dev, bool resume, bool runtime)\n{\n\tstruct nv04_display *disp = nv04_display(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_encoder *encoder;\n\tstruct drm_crtc *crtc;\n\tint ret;\n\n\t \n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\t\tnv_crtc->save(&nv_crtc->base);\n\t}\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, base.base.head)\n\t\tencoder->enc_save(&encoder->base.base);\n\n\t \n\tnvif_event_allow(&disp->flip);\n\n\tif (!resume)\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\t\tstruct nouveau_bo *nvbo;\n\n\t\tif (!fb || !fb->obj[0])\n\t\t\tcontinue;\n\t\tnvbo = nouveau_gem_object(fb->obj[0]);\n\t\tret = nouveau_bo_pin(nvbo, NOUVEAU_GEM_DOMAIN_VRAM, true);\n\t\tif (ret)\n\t\t\tNV_ERROR(drm, \"Could not pin framebuffer\\n\");\n\t}\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\t\tif (!nv_crtc->cursor.nvbo)\n\t\t\tcontinue;\n\n\t\tret = nouveau_bo_pin(nv_crtc->cursor.nvbo,\n\t\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM, true);\n\t\tif (!ret && nv_crtc->cursor.set_offset)\n\t\t\tret = nouveau_bo_map(nv_crtc->cursor.nvbo);\n\t\tif (ret)\n\t\t\tNV_ERROR(drm, \"Could not pin/map cursor.\\n\");\n\t}\n\n\t \n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\n\t\tnv_crtc->lut.depth = 0;\n\t}\n\n\t \n\tif (runtime)\n\t\treturn 0;\n\n\t \n\tdrm_helper_resume_force_mode(dev);\n\n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\n\t\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\n\t\tif (!nv_crtc->cursor.nvbo)\n\t\t\tcontinue;\n\n\t\tif (nv_crtc->cursor.set_offset)\n\t\t\tnv_crtc->cursor.set_offset(nv_crtc,\n\t\t\t\t\t\t   nv_crtc->cursor.nvbo->offset);\n\t\tnv_crtc->cursor.set_pos(nv_crtc, nv_crtc->cursor_saved_x,\n\t\t\t\t\t\t nv_crtc->cursor_saved_y);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv04_display_destroy(struct drm_device *dev)\n{\n\tstruct nv04_display *disp = nv04_display(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_encoder *encoder;\n\tstruct nouveau_crtc *nv_crtc;\n\n\t \n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, base.base.head)\n\t\tencoder->enc_restore(&encoder->base.base);\n\n\tlist_for_each_entry(nv_crtc, &dev->mode_config.crtc_list, base.head)\n\t\tnv_crtc->restore(&nv_crtc->base);\n\n\tnouveau_hw_save_vga_fonts(dev, 0);\n\n\tnvif_event_dtor(&disp->flip);\n\n\tnouveau_display(dev)->priv = NULL;\n\tvfree(disp);\n\n\tnvif_object_unmap(&drm->client.device.object);\n}\n\nint\nnv04_display_create(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct dcb_table *dcb = &drm->vbios.dcb;\n\tstruct drm_connector *connector, *ct;\n\tstruct drm_encoder *encoder;\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct nouveau_crtc *crtc;\n\tstruct nv04_display *disp;\n\tint i, ret;\n\n\tdisp = vzalloc(sizeof(*disp));\n\tif (!disp)\n\t\treturn -ENOMEM;\n\n\tdisp->drm = drm;\n\n\tnvif_object_map(&drm->client.device.object, NULL, 0);\n\n\tnouveau_display(dev)->priv = disp;\n\tnouveau_display(dev)->dtor = nv04_display_destroy;\n\tnouveau_display(dev)->init = nv04_display_init;\n\tnouveau_display(dev)->fini = nv04_display_fini;\n\n\t \n\tdev->driver_features &= ~DRIVER_ATOMIC;\n\n\t \n\tif (drm->channel) {\n\t\tret = nvif_event_ctor(&drm->channel->nvsw, \"kmsFlip\", 0, nv04_flip_complete,\n\t\t\t\t      true, NULL, 0, &disp->flip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnouveau_hw_save_vga_fonts(dev, 1);\n\n\tnv04_crtc_create(dev, 0);\n\tif (nv_two_heads(dev))\n\t\tnv04_crtc_create(dev, 1);\n\n\tfor (i = 0; i < dcb->entries; i++) {\n\t\tstruct dcb_output *dcbent = &dcb->entry[i];\n\n\t\tconnector = nouveau_connector_create(dev, dcbent);\n\t\tif (IS_ERR(connector))\n\t\t\tcontinue;\n\n\t\tswitch (dcbent->type) {\n\t\tcase DCB_OUTPUT_ANALOG:\n\t\t\tret = nv04_dac_create(connector, dcbent);\n\t\t\tbreak;\n\t\tcase DCB_OUTPUT_LVDS:\n\t\tcase DCB_OUTPUT_TMDS:\n\t\t\tret = nv04_dfp_create(connector, dcbent);\n\t\t\tbreak;\n\t\tcase DCB_OUTPUT_TV:\n\t\t\tif (dcbent->location == DCB_LOC_ON_CHIP)\n\t\t\t\tret = nv17_tv_create(connector, dcbent);\n\t\t\telse\n\t\t\t\tret = nv04_tv_create(connector, dcbent);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNV_WARN(drm, \"DCB type %d not known\\n\", dcbent->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret)\n\t\t\tcontinue;\n\t}\n\n\tlist_for_each_entry_safe(connector, ct,\n\t\t\t\t &dev->mode_config.connector_list, head) {\n\t\tif (!connector->possible_encoders) {\n\t\t\tNV_WARN(drm, \"%s has no encoders, removing\\n\",\n\t\t\t\tconnector->name);\n\t\t\tconnector->funcs->destroy(connector);\n\t\t}\n\t}\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\t\tstruct nvkm_i2c_bus *bus =\n\t\t\tnvkm_i2c_bus_find(i2c, nv_encoder->dcb->i2c_index);\n\t\tnv_encoder->i2c = bus ? &bus->i2c : NULL;\n\t}\n\n\t \n\tlist_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)\n\t\tcrtc->save(&crtc->base);\n\n\tlist_for_each_entry(nv_encoder, &dev->mode_config.encoder_list, base.base.head)\n\t\tnv_encoder->enc_save(&nv_encoder->base.base);\n\n\tnouveau_overlay_init(dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}