{
  "module_name": "tvnv04.c",
  "hash_id": "bc4016575ff18b5a488314674bb487c0f90899f0eb7b0e9ef06a7608ee933ce0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/tvnv04.c",
  "human_readable_source": " \n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_crtc.h\"\n#include \"hw.h\"\n#include <drm/drm_modeset_helper_vtables.h>\n\n#include <drm/i2c/ch7006.h>\n\nstatic struct nvkm_i2c_bus_probe nv04_tv_encoder_info[] = {\n\t{\n\t\t{\n\t\t\tI2C_BOARD_INFO(\"ch7006\", 0x75),\n\t\t\t.platform_data = &(struct ch7006_encoder_params) {\n\t\t\t\tCH7006_FORMAT_RGB24m12I, CH7006_CLOCK_MASTER,\n\t\t\t\t0, 0, 0,\n\t\t\t\tCH7006_SYNC_SLAVE, CH7006_SYNC_SEPARATED,\n\t\t\t\tCH7006_POUT_3_3V, CH7006_ACTIVE_HSYNC\n\t\t\t}\n\t\t},\n\t\t0\n\t},\n\t{ }\n};\n\nint nv04_tv_identify(struct drm_device *dev, int i2c_index)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct nvkm_i2c_bus *bus = nvkm_i2c_bus_find(i2c, i2c_index);\n\tif (bus) {\n\t\treturn nvkm_i2c_bus_probe(bus, \"TV encoder\",\n\t\t\t\t\t  nv04_tv_encoder_info,\n\t\t\t\t\t  NULL, NULL);\n\t}\n\treturn -ENODEV;\n}\n\n\n#define PLLSEL_TV_CRTC1_MASK\t\t\t\t\\\n\t(NV_PRAMDAC_PLL_COEFF_SELECT_TV_VSCLK1\t\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_TV_PCLK1)\n#define PLLSEL_TV_CRTC2_MASK\t\t\t\t\\\n\t(NV_PRAMDAC_PLL_COEFF_SELECT_TV_VSCLK2\t\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_TV_PCLK2)\n\nstatic void nv04_tv_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\n\tuint8_t crtc1A;\n\n\tNV_DEBUG(drm, \"Setting dpms mode %d on TV encoder (output %d)\\n\",\n\t\t mode, nv_encoder->dcb->index);\n\n\tstate->pllsel &= ~(PLLSEL_TV_CRTC1_MASK | PLLSEL_TV_CRTC2_MASK);\n\n\tif (mode == DRM_MODE_DPMS_ON) {\n\t\tint head = nouveau_crtc(encoder->crtc)->index;\n\t\tcrtc1A = NVReadVgaCrtc(dev, head, NV_CIO_CRE_RPC1_INDEX);\n\n\t\tstate->pllsel |= head ? PLLSEL_TV_CRTC2_MASK :\n\t\t\t\t\tPLLSEL_TV_CRTC1_MASK;\n\n\t\t \n\t\tcrtc1A |= 0x80;\n\n\t\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_RPC1_INDEX, crtc1A);\n\t}\n\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT, state->pllsel);\n\n\tget_slave_funcs(encoder)->dpms(encoder, mode);\n}\n\nstatic void nv04_tv_bind(struct drm_device *dev, int head, bool bind)\n{\n\tstruct nv04_crtc_reg *state = &nv04_display(dev)->mode_reg.crtc_reg[head];\n\n\tstate->tv_setup = 0;\n\n\tif (bind)\n\t\tstate->CRTC[NV_CIO_CRE_49] |= 0x10;\n\telse\n\t\tstate->CRTC[NV_CIO_CRE_49] &= ~0x10;\n\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_LCD__INDEX,\n\t\t       state->CRTC[NV_CIO_CRE_LCD__INDEX]);\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_49,\n\t\t       state->CRTC[NV_CIO_CRE_49]);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP,\n\t\t      state->tv_setup);\n}\n\nstatic void nv04_tv_prepare(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_OFF);\n\n\tnv04_dfp_disable(dev, head);\n\n\tif (nv_two_heads(dev))\n\t\tnv04_tv_bind(dev, head ^ 1, false);\n\n\tnv04_tv_bind(dev, head, true);\n}\n\nstatic void nv04_tv_mode_set(struct drm_encoder *encoder,\n\t\t\t     struct drm_display_mode *mode,\n\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\n\tregp->tv_htotal = adjusted_mode->htotal;\n\tregp->tv_vtotal = adjusted_mode->vtotal;\n\n\t \n\tregp->tv_hskew = 1;\n\tregp->tv_hsync_delay = 1;\n\tregp->tv_hsync_delay2 = 64;\n\tregp->tv_vskew = 1;\n\tregp->tv_vsync_delay = 1;\n\n\tget_slave_funcs(encoder)->mode_set(encoder, mode, adjusted_mode);\n}\n\nstatic void nv04_tv_commit(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_ON);\n\n\tNV_DEBUG(drm, \"Output %s is running on CRTC %d using output %c\\n\",\n\t\t nv04_encoder_get_connector(nv_encoder)->base.name,\n\t\t nv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\n}\n\nstatic void nv04_tv_destroy(struct drm_encoder *encoder)\n{\n\tget_slave_funcs(encoder)->destroy(encoder);\n\tdrm_encoder_cleanup(encoder);\n\n\tkfree(encoder->helper_private);\n\tkfree(nouveau_encoder(encoder));\n}\n\nstatic const struct drm_encoder_funcs nv04_tv_funcs = {\n\t.destroy = nv04_tv_destroy,\n};\n\nstatic const struct drm_encoder_helper_funcs nv04_tv_helper_funcs = {\n\t.dpms = nv04_tv_dpms,\n\t.mode_fixup = drm_i2c_encoder_mode_fixup,\n\t.prepare = nv04_tv_prepare,\n\t.commit = nv04_tv_commit,\n\t.mode_set = nv04_tv_mode_set,\n\t.detect = drm_i2c_encoder_detect,\n};\n\nint\nnv04_tv_create(struct drm_connector *connector, struct dcb_output *entry)\n{\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct drm_encoder *encoder;\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct nvkm_i2c_bus *bus = nvkm_i2c_bus_find(i2c, entry->i2c_index);\n\tint type, ret;\n\n\t \n\ttype = nv04_tv_identify(dev, entry->i2c_index);\n\tif (type < 0)\n\t\treturn type;\n\n\t \n\tnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\n\tif (!nv_encoder)\n\t\treturn -ENOMEM;\n\n\t \n\tencoder = to_drm_encoder(nv_encoder);\n\n\tdrm_encoder_init(dev, encoder, &nv04_tv_funcs, DRM_MODE_ENCODER_TVDAC,\n\t\t\t NULL);\n\tdrm_encoder_helper_add(encoder, &nv04_tv_helper_funcs);\n\n\tnv_encoder->enc_save = drm_i2c_encoder_save;\n\tnv_encoder->enc_restore = drm_i2c_encoder_restore;\n\n\tencoder->possible_crtcs = entry->heads;\n\tencoder->possible_clones = 0;\n\tnv_encoder->dcb = entry;\n\tnv_encoder->or = ffs(entry->or) - 1;\n\n\t \n\tret = drm_i2c_encoder_init(dev, to_encoder_slave(encoder),\n\t\t\t\t   &bus->i2c,\n\t\t\t\t   &nv04_tv_encoder_info[type].dev);\n\tif (ret < 0)\n\t\tgoto fail_cleanup;\n\n\t \n\tget_slave_funcs(encoder)->create_resources(encoder, connector);\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\treturn 0;\n\nfail_cleanup:\n\tdrm_encoder_cleanup(encoder);\n\tkfree(nv_encoder);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}