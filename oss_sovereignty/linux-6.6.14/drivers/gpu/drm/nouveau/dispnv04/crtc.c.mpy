{
  "module_name": "crtc.c",
  "hash_id": "5c0f3992e8579e5fffd05b7dc40399ddf39b01f36bb2cc9829f50149f51dcc44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/crtc.c",
  "human_readable_source": " \n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_plane_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"nouveau_ttm.h\"\n#include \"nouveau_bo.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_crtc.h\"\n#include \"hw.h\"\n#include \"nvreg.h\"\n#include \"disp.h\"\n#include \"nouveau_dma.h\"\n\n#include <subdev/bios/pll.h>\n#include <subdev/clk.h>\n\n#include <nvif/push006c.h>\n\n#include <nvif/event.h>\n#include <nvif/cl0046.h>\n\nstatic int\nnv04_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\n\t\t\tstruct drm_framebuffer *old_fb);\n\nstatic void\ncrtc_wr_cio_state(struct drm_crtc *crtc, struct nv04_crtc_reg *crtcstate, int index)\n{\n\tNVWriteVgaCrtc(crtc->dev, nouveau_crtc(crtc)->index, index,\n\t\t       crtcstate->CRTC[index]);\n}\n\nstatic void nv_crtc_set_digital_vibrance(struct drm_crtc *crtc, int level)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\n\tregp->CRTC[NV_CIO_CRE_CSB] = nv_crtc->saturation = level;\n\tif (nv_crtc->saturation && nv_gf4_disp_arch(crtc->dev)) {\n\t\tregp->CRTC[NV_CIO_CRE_CSB] = 0x80;\n\t\tregp->CRTC[NV_CIO_CRE_5B] = nv_crtc->saturation << 2;\n\t\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_5B);\n\t}\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_CSB);\n}\n\nstatic void nv_crtc_set_image_sharpening(struct drm_crtc *crtc, int level)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\n\tnv_crtc->sharpness = level;\n\tif (level < 0)\t \n\t\tlevel += 0x40;\n\tregp->ramdac_634 = level;\n\tNVWriteRAMDAC(crtc->dev, nv_crtc->index, NV_PRAMDAC_634, regp->ramdac_634);\n}\n\n#define PLLSEL_VPLL1_MASK\t\t\t\t\\\n\t(NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_VPLL\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2)\n#define PLLSEL_VPLL2_MASK\t\t\t\t\\\n\t(NV_PRAMDAC_PLL_COEFF_SELECT_PLL_SOURCE_VPLL2\t\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_VCLK2_RATIO_DB2)\n#define PLLSEL_TV_MASK\t\t\t\t\t\\\n\t(NV_PRAMDAC_PLL_COEFF_SELECT_TV_VSCLK1\t\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_TV_PCLK1\t\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_TV_VSCLK2\t\\\n\t | NV_PRAMDAC_PLL_COEFF_SELECT_TV_PCLK2)\n\n \n\nstatic void nv_crtc_calc_state_ext(struct drm_crtc *crtc, struct drm_display_mode * mode, int dot_clock)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_bios *bios = nvxx_bios(&drm->client.device);\n\tstruct nvkm_clk *clk = nvxx_clk(&drm->client.device);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[nv_crtc->index];\n\tstruct nvkm_pll_vals *pv = &regp->pllvals;\n\tstruct nvbios_pll pll_lim;\n\n\tif (nvbios_pll_parse(bios, nv_crtc->index ? PLL_VPLL1 : PLL_VPLL0,\n\t\t\t    &pll_lim))\n\t\treturn;\n\n\t \n\tpv->NM2 = 0;\n\n\t \n\t \n\tif (drm->client.device.info.chipset > 0x40 && dot_clock <= (pll_lim.vco1.max_freq / 2))\n\t\tmemset(&pll_lim.vco2, 0, sizeof(pll_lim.vco2));\n\n\n\tif (!clk->pll_calc(clk, &pll_lim, dot_clock, pv))\n\t\treturn;\n\n\tstate->pllsel &= PLLSEL_VPLL1_MASK | PLLSEL_VPLL2_MASK | PLLSEL_TV_MASK;\n\n\t \n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\tstate->pllsel |= NV_PRAMDAC_PLL_COEFF_SELECT_USE_VPLL2_TRUE;\n\t \n\tif (drm->client.device.info.chipset < 0x41)\n\t\tstate->pllsel |= NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_MPLL |\n\t\t\t\t NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_NVPLL;\n\tstate->pllsel |= nv_crtc->index ? PLLSEL_VPLL2_MASK : PLLSEL_VPLL1_MASK;\n\n\tif (pv->NM2)\n\t\tNV_DEBUG(drm, \"vpll: n1 %d n2 %d m1 %d m2 %d log2p %d\\n\",\n\t\t\t pv->N1, pv->N2, pv->M1, pv->M2, pv->log2P);\n\telse\n\t\tNV_DEBUG(drm, \"vpll: n %d m %d log2p %d\\n\",\n\t\t\t pv->N1, pv->M1, pv->log2P);\n\n\tnv_crtc->cursor.set_offset(nv_crtc, nv_crtc->cursor.offset);\n}\n\nstatic void\nnv_crtc_dpms(struct drm_crtc *crtc, int mode)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tunsigned char seq1 = 0, crtc17 = 0;\n\tunsigned char crtc1A;\n\n\tNV_DEBUG(drm, \"Setting dpms mode %d on CRTC %d\\n\", mode,\n\t\t\t\t\t\t\tnv_crtc->index);\n\n\tif (nv_crtc->last_dpms == mode)  \n\t\treturn;\n\n\tnv_crtc->last_dpms = mode;\n\n\tif (nv_two_heads(dev))\n\t\tNVSetOwner(dev, nv_crtc->index);\n\n\t \n\tcrtc1A = NVReadVgaCrtc(dev, nv_crtc->index,\n\t\t\t\t\tNV_CIO_CRE_RPC1_INDEX) & ~0xC0;\n\tswitch (mode) {\n\tcase DRM_MODE_DPMS_STANDBY:\n\t\t \n\t\tseq1 = 0x20;\n\t\tcrtc17 = 0x80;\n\t\tcrtc1A |= 0x80;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_SUSPEND:\n\t\t \n\t\tseq1 = 0x20;\n\t\tcrtc17 = 0x80;\n\t\tcrtc1A |= 0x40;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_OFF:\n\t\t \n\t\tseq1 = 0x20;\n\t\tcrtc17 = 0x00;\n\t\tcrtc1A |= 0xC0;\n\t\tbreak;\n\tcase DRM_MODE_DPMS_ON:\n\tdefault:\n\t\t \n\t\tseq1 = 0x00;\n\t\tcrtc17 = 0x80;\n\t\tbreak;\n\t}\n\n\tNVVgaSeqReset(dev, nv_crtc->index, true);\n\t \n\tseq1 |= (NVReadVgaSeq(dev, nv_crtc->index, NV_VIO_SR_CLOCK_INDEX) & ~0x20);\n\tNVWriteVgaSeq(dev, nv_crtc->index, NV_VIO_SR_CLOCK_INDEX, seq1);\n\tcrtc17 |= (NVReadVgaCrtc(dev, nv_crtc->index, NV_CIO_CR_MODE_INDEX) & ~0x80);\n\tmdelay(10);\n\tNVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CR_MODE_INDEX, crtc17);\n\tNVVgaSeqReset(dev, nv_crtc->index, false);\n\n\tNVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RPC1_INDEX, crtc1A);\n}\n\nstatic void\nnv_crtc_mode_set_vga(struct drm_crtc *crtc, struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\n\t \n\tint horizDisplay\t= (mode->crtc_hdisplay >> 3)\t\t- 1;\n\tint horizStart\t\t= (mode->crtc_hsync_start >> 3) \t+ 1;\n\tint horizEnd\t\t= (mode->crtc_hsync_end >> 3)\t\t+ 1;\n\tint horizTotal\t\t= (mode->crtc_htotal >> 3)\t\t- 5;\n\tint horizBlankStart\t= (mode->crtc_hdisplay >> 3)\t\t- 1;\n\tint horizBlankEnd\t= (mode->crtc_htotal >> 3)\t\t- 1;\n\tint vertDisplay\t\t= mode->crtc_vdisplay\t\t\t- 1;\n\tint vertStart\t\t= mode->crtc_vsync_start \t\t- 1;\n\tint vertEnd\t\t= mode->crtc_vsync_end\t\t\t- 1;\n\tint vertTotal\t\t= mode->crtc_vtotal \t\t\t- 2;\n\tint vertBlankStart\t= mode->crtc_vdisplay \t\t\t- 1;\n\tint vertBlankEnd\t= mode->crtc_vtotal\t\t\t- 1;\n\n\tstruct drm_encoder *encoder;\n\tbool fp_output = false;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\t\tif (encoder->crtc == crtc &&\n\t\t    (nv_encoder->dcb->type == DCB_OUTPUT_LVDS ||\n\t\t     nv_encoder->dcb->type == DCB_OUTPUT_TMDS))\n\t\t\tfp_output = true;\n\t}\n\n\tif (fp_output) {\n\t\tvertStart = vertTotal - 3;\n\t\tvertEnd = vertTotal - 2;\n\t\tvertBlankStart = vertStart;\n\t\thorizStart = horizTotal - 5;\n\t\thorizEnd = horizTotal - 2;\n\t\thorizBlankEnd = horizTotal + 4;\n#if 0\n\t\tif (dev->overlayAdaptor && drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\n\t\t\t \n\t\t\thorizTotal += 2;\n#endif\n\t}\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\tvertTotal |= 1;\n\n#if 0\n\tErrorF(\"horizDisplay: 0x%X \\n\", horizDisplay);\n\tErrorF(\"horizStart: 0x%X \\n\", horizStart);\n\tErrorF(\"horizEnd: 0x%X \\n\", horizEnd);\n\tErrorF(\"horizTotal: 0x%X \\n\", horizTotal);\n\tErrorF(\"horizBlankStart: 0x%X \\n\", horizBlankStart);\n\tErrorF(\"horizBlankEnd: 0x%X \\n\", horizBlankEnd);\n\tErrorF(\"vertDisplay: 0x%X \\n\", vertDisplay);\n\tErrorF(\"vertStart: 0x%X \\n\", vertStart);\n\tErrorF(\"vertEnd: 0x%X \\n\", vertEnd);\n\tErrorF(\"vertTotal: 0x%X \\n\", vertTotal);\n\tErrorF(\"vertBlankStart: 0x%X \\n\", vertBlankStart);\n\tErrorF(\"vertBlankEnd: 0x%X \\n\", vertBlankEnd);\n#endif\n\n\t \n\tif ((mode->flags & (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC))\n\t\t&& (mode->flags & (DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))) {\n\n\t\tregp->MiscOutReg = 0x23;\n\t\tif (mode->flags & DRM_MODE_FLAG_NHSYNC)\n\t\t\tregp->MiscOutReg |= 0x40;\n\t\tif (mode->flags & DRM_MODE_FLAG_NVSYNC)\n\t\t\tregp->MiscOutReg |= 0x80;\n\t} else {\n\t\tint vdisplay = mode->vdisplay;\n\t\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\t\tvdisplay *= 2;\n\t\tif (mode->vscan > 1)\n\t\t\tvdisplay *= mode->vscan;\n\t\tif (vdisplay < 400)\n\t\t\tregp->MiscOutReg = 0xA3;\t \n\t\telse if (vdisplay < 480)\n\t\t\tregp->MiscOutReg = 0x63;\t \n\t\telse if (vdisplay < 768)\n\t\t\tregp->MiscOutReg = 0xE3;\t \n\t\telse\n\t\t\tregp->MiscOutReg = 0x23;\t \n\t}\n\n\t \n\tregp->Sequencer[NV_VIO_SR_RESET_INDEX] = 0x00;\n\t \n\tif (mode->flags & DRM_MODE_FLAG_CLKDIV2)\n\t\tregp->Sequencer[NV_VIO_SR_CLOCK_INDEX] = 0x29;\n\telse\n\t\tregp->Sequencer[NV_VIO_SR_CLOCK_INDEX] = 0x21;\n\tregp->Sequencer[NV_VIO_SR_PLANE_MASK_INDEX] = 0x0F;\n\tregp->Sequencer[NV_VIO_SR_CHAR_MAP_INDEX] = 0x00;\n\tregp->Sequencer[NV_VIO_SR_MEM_MODE_INDEX] = 0x0E;\n\n\t \n\tregp->CRTC[NV_CIO_CR_HDT_INDEX] = horizTotal;\n\tregp->CRTC[NV_CIO_CR_HDE_INDEX] = horizDisplay;\n\tregp->CRTC[NV_CIO_CR_HBS_INDEX] = horizBlankStart;\n\tregp->CRTC[NV_CIO_CR_HBE_INDEX] = (1 << 7) |\n\t\t\t\t\t  XLATE(horizBlankEnd, 0, NV_CIO_CR_HBE_4_0);\n\tregp->CRTC[NV_CIO_CR_HRS_INDEX] = horizStart;\n\tregp->CRTC[NV_CIO_CR_HRE_INDEX] = XLATE(horizBlankEnd, 5, NV_CIO_CR_HRE_HBE_5) |\n\t\t\t\t\t  XLATE(horizEnd, 0, NV_CIO_CR_HRE_4_0);\n\tregp->CRTC[NV_CIO_CR_VDT_INDEX] = vertTotal;\n\tregp->CRTC[NV_CIO_CR_OVL_INDEX] = XLATE(vertStart, 9, NV_CIO_CR_OVL_VRS_9) |\n\t\t\t\t\t  XLATE(vertDisplay, 9, NV_CIO_CR_OVL_VDE_9) |\n\t\t\t\t\t  XLATE(vertTotal, 9, NV_CIO_CR_OVL_VDT_9) |\n\t\t\t\t\t  (1 << 4) |\n\t\t\t\t\t  XLATE(vertBlankStart, 8, NV_CIO_CR_OVL_VBS_8) |\n\t\t\t\t\t  XLATE(vertStart, 8, NV_CIO_CR_OVL_VRS_8) |\n\t\t\t\t\t  XLATE(vertDisplay, 8, NV_CIO_CR_OVL_VDE_8) |\n\t\t\t\t\t  XLATE(vertTotal, 8, NV_CIO_CR_OVL_VDT_8);\n\tregp->CRTC[NV_CIO_CR_RSAL_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_CELL_HT_INDEX] = ((mode->flags & DRM_MODE_FLAG_DBLSCAN) ? MASK(NV_CIO_CR_CELL_HT_SCANDBL) : 0) |\n\t\t\t\t\t      1 << 6 |\n\t\t\t\t\t      XLATE(vertBlankStart, 9, NV_CIO_CR_CELL_HT_VBS_9);\n\tregp->CRTC[NV_CIO_CR_CURS_ST_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_CURS_END_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_SA_HI_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_SA_LO_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_TCOFF_HI_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_TCOFF_LO_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_VRS_INDEX] = vertStart;\n\tregp->CRTC[NV_CIO_CR_VRE_INDEX] = 1 << 5 | XLATE(vertEnd, 0, NV_CIO_CR_VRE_3_0);\n\tregp->CRTC[NV_CIO_CR_VDE_INDEX] = vertDisplay;\n\t \n\tregp->CRTC[NV_CIO_CR_OFFSET_INDEX] = fb->pitches[0] / 8;\n\tregp->CRTC[NV_CIO_CR_ULINE_INDEX] = 0x00;\n\tregp->CRTC[NV_CIO_CR_VBS_INDEX] = vertBlankStart;\n\tregp->CRTC[NV_CIO_CR_VBE_INDEX] = vertBlankEnd;\n\tregp->CRTC[NV_CIO_CR_MODE_INDEX] = 0x43;\n\tregp->CRTC[NV_CIO_CR_LCOMP_INDEX] = 0xff;\n\n\t \n\n\t \n\tregp->CRTC[NV_CIO_CRE_RPC0_INDEX] =\n\t\tXLATE(fb->pitches[0] / 8, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);\n\tregp->CRTC[NV_CIO_CRE_42] =\n\t\tXLATE(fb->pitches[0] / 8, 11, NV_CIO_CRE_42_OFFSET_11);\n\tregp->CRTC[NV_CIO_CRE_RPC1_INDEX] = mode->crtc_hdisplay < 1280 ?\n\t\t\t\t\t    MASK(NV_CIO_CRE_RPC1_LARGE) : 0x00;\n\tregp->CRTC[NV_CIO_CRE_LSR_INDEX] = XLATE(horizBlankEnd, 6, NV_CIO_CRE_LSR_HBE_6) |\n\t\t\t\t\t   XLATE(vertBlankStart, 10, NV_CIO_CRE_LSR_VBS_10) |\n\t\t\t\t\t   XLATE(vertStart, 10, NV_CIO_CRE_LSR_VRS_10) |\n\t\t\t\t\t   XLATE(vertDisplay, 10, NV_CIO_CRE_LSR_VDE_10) |\n\t\t\t\t\t   XLATE(vertTotal, 10, NV_CIO_CRE_LSR_VDT_10);\n\tregp->CRTC[NV_CIO_CRE_HEB__INDEX] = XLATE(horizStart, 8, NV_CIO_CRE_HEB_HRS_8) |\n\t\t\t\t\t    XLATE(horizBlankStart, 8, NV_CIO_CRE_HEB_HBS_8) |\n\t\t\t\t\t    XLATE(horizDisplay, 8, NV_CIO_CRE_HEB_HDE_8) |\n\t\t\t\t\t    XLATE(horizTotal, 8, NV_CIO_CRE_HEB_HDT_8);\n\tregp->CRTC[NV_CIO_CRE_EBR_INDEX] = XLATE(vertBlankStart, 11, NV_CIO_CRE_EBR_VBS_11) |\n\t\t\t\t\t   XLATE(vertStart, 11, NV_CIO_CRE_EBR_VRS_11) |\n\t\t\t\t\t   XLATE(vertDisplay, 11, NV_CIO_CRE_EBR_VDE_11) |\n\t\t\t\t\t   XLATE(vertTotal, 11, NV_CIO_CRE_EBR_VDT_11);\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\thorizTotal = (horizTotal >> 1) & ~1;\n\t\tregp->CRTC[NV_CIO_CRE_ILACE__INDEX] = horizTotal;\n\t\tregp->CRTC[NV_CIO_CRE_HEB__INDEX] |= XLATE(horizTotal, 8, NV_CIO_CRE_HEB_ILC_8);\n\t} else\n\t\tregp->CRTC[NV_CIO_CRE_ILACE__INDEX] = 0xff;   \n\n\t \n\tregp->Graphics[NV_VIO_GX_SR_INDEX] = 0x00;\n\tregp->Graphics[NV_VIO_GX_SREN_INDEX] = 0x00;\n\tregp->Graphics[NV_VIO_GX_CCOMP_INDEX] = 0x00;\n\tregp->Graphics[NV_VIO_GX_ROP_INDEX] = 0x00;\n\tregp->Graphics[NV_VIO_GX_READ_MAP_INDEX] = 0x00;\n\tregp->Graphics[NV_VIO_GX_MODE_INDEX] = 0x40;  \n\tregp->Graphics[NV_VIO_GX_MISC_INDEX] = 0x05;  \n\tregp->Graphics[NV_VIO_GX_DONT_CARE_INDEX] = 0x0F;\n\tregp->Graphics[NV_VIO_GX_BIT_MASK_INDEX] = 0xFF;\n\n\tregp->Attribute[0]  = 0x00;  \n\tregp->Attribute[1]  = 0x01;\n\tregp->Attribute[2]  = 0x02;\n\tregp->Attribute[3]  = 0x03;\n\tregp->Attribute[4]  = 0x04;\n\tregp->Attribute[5]  = 0x05;\n\tregp->Attribute[6]  = 0x06;\n\tregp->Attribute[7]  = 0x07;\n\tregp->Attribute[8]  = 0x08;\n\tregp->Attribute[9]  = 0x09;\n\tregp->Attribute[10] = 0x0A;\n\tregp->Attribute[11] = 0x0B;\n\tregp->Attribute[12] = 0x0C;\n\tregp->Attribute[13] = 0x0D;\n\tregp->Attribute[14] = 0x0E;\n\tregp->Attribute[15] = 0x0F;\n\tregp->Attribute[NV_CIO_AR_MODE_INDEX] = 0x01;  \n\t \n\tregp->Attribute[NV_CIO_AR_OSCAN_INDEX] = 0x00;\n\tregp->Attribute[NV_CIO_AR_PLANE_INDEX] = 0x0F;  \n\tregp->Attribute[NV_CIO_AR_HPP_INDEX] = 0x00;\n\tregp->Attribute[NV_CIO_AR_CSEL_INDEX] = 0x00;\n}\n\n \nstatic void\nnv_crtc_mode_set_regs(struct drm_crtc *crtc, struct drm_display_mode * mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\tstruct nv04_crtc_reg *savep = &nv04_display(dev)->saved_reg.crtc_reg[nv_crtc->index];\n\tconst struct drm_framebuffer *fb = crtc->primary->fb;\n\tstruct drm_encoder *encoder;\n\tbool lvds_output = false, tmds_output = false, tv_output = false,\n\t\toff_chip_digital = false;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\t\tbool digital = false;\n\n\t\tif (encoder->crtc != crtc)\n\t\t\tcontinue;\n\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_LVDS)\n\t\t\tdigital = lvds_output = true;\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_TV)\n\t\t\ttv_output = true;\n\t\tif (nv_encoder->dcb->type == DCB_OUTPUT_TMDS)\n\t\t\tdigital = tmds_output = true;\n\t\tif (nv_encoder->dcb->location != DCB_LOC_ON_CHIP && digital)\n\t\t\toff_chip_digital = true;\n\t}\n\n\t \n\n\t \n\t \n\tregp->CRTC[NV_CIO_CRE_ENH_INDEX] = savep->CRTC[NV_CIO_CRE_ENH_INDEX] & ~(1<<5);\n\n\tregp->crtc_eng_ctrl = 0;\n\t \n\tif (nv_crtc->index == 0)\n\t\tregp->crtc_eng_ctrl |= NV_CRTC_FSEL_I2C;\n#if 0\n\t \n\tif (dev->overlayAdaptor) {\n\t\tNVPortPrivPtr pPriv = GET_OVERLAY_PRIVATE(dev);\n\t\tif (pPriv->overlayCRTC == nv_crtc->index)\n\t\t\tregp->crtc_eng_ctrl |= NV_CRTC_FSEL_OVERLAY;\n\t}\n#endif\n\n\t \n\tregp->cursor_cfg = NV_PCRTC_CURSOR_CONFIG_CUR_LINES_64 |\n\t\t\t     NV_PCRTC_CURSOR_CONFIG_CUR_PIXELS_64 |\n\t\t\t     NV_PCRTC_CURSOR_CONFIG_ADDRESS_SPACE_PNVM;\n\tif (drm->client.device.info.chipset >= 0x11)\n\t\tregp->cursor_cfg |= NV_PCRTC_CURSOR_CONFIG_CUR_BPP_32;\n\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\tregp->cursor_cfg |= NV_PCRTC_CURSOR_CONFIG_DOUBLE_SCAN_ENABLE;\n\n\t \n\tregp->CRTC[NV_CIO_CRE_53] = 0;\n\tregp->CRTC[NV_CIO_CRE_54] = 0;\n\n\t \n\tif (lvds_output)\n\t\tregp->CRTC[NV_CIO_CRE_SCRATCH3__INDEX] = 0x11;\n\telse if (tmds_output)\n\t\tregp->CRTC[NV_CIO_CRE_SCRATCH3__INDEX] = 0x88;\n\telse\n\t\tregp->CRTC[NV_CIO_CRE_SCRATCH3__INDEX] = 0x22;\n\n\t \n\t \n\tregp->CRTC[NV_CIO_CRE_SCRATCH4__INDEX] = savep->CRTC[NV_CIO_CRE_SCRATCH4__INDEX];\n\n\tnv_crtc_set_digital_vibrance(crtc, nv_crtc->saturation);\n\n\t \n\tif (nv_crtc->index == 0)\n\t\tregp->CRTC[NV_CIO_CRE_4B] = savep->CRTC[NV_CIO_CRE_4B] | 0x80;\n\n\t \n\tregp->CRTC[NV_CIO_CRE_TVOUT_LATENCY] = nv04_display(dev)->saved_reg.crtc_reg[0].CRTC[NV_CIO_CRE_TVOUT_LATENCY];\n\tif (!nv_crtc->index)\n\t\tregp->CRTC[NV_CIO_CRE_TVOUT_LATENCY] += 4;\n\n\t \n\tregp->CRTC[NV_CIO_CRE_59] = off_chip_digital;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\n\t\tregp->CRTC[0x9f] = off_chip_digital ? 0x11 : 0x1;\n\n\tregp->crtc_830 = mode->crtc_vdisplay - 3;\n\tregp->crtc_834 = mode->crtc_vdisplay - 1;\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\t \n\t\tregp->crtc_850 = NVReadCRTC(dev, 0, NV_PCRTC_850);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\n\t\tregp->gpio_ext = NVReadCRTC(dev, 0, NV_PCRTC_GPIO_EXT);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\n\t\tregp->crtc_cfg = NV10_PCRTC_CONFIG_START_ADDRESS_HSYNC;\n\telse\n\t\tregp->crtc_cfg = NV04_PCRTC_CONFIG_START_ADDRESS_HSYNC;\n\n\t \n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE) {\n\t\tregp->CRTC[NV_CIO_CRE_85] = 0xFF;\n\t\tregp->CRTC[NV_CIO_CRE_86] = 0x1;\n\t}\n\n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] = (fb->format->depth + 1) / 8;\n\t \n\tif (lvds_output || tmds_output || tv_output)\n\t\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] |= (1 << 7);\n\n\t \n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\n\t\t \n\t\tregp->nv10_cursync = (1 << 25);\n\n\tregp->ramdac_gen_ctrl = NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS |\n\t\t\t\tNV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL |\n\t\t\t\tNV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON;\n\tif (fb->format->depth == 16)\n\t\tregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tif (drm->client.device.info.chipset >= 0x11)\n\t\tregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_PIPE_LONG;\n\n\tregp->ramdac_630 = 0;  \n\tregp->tv_setup = 0;\n\n\tnv_crtc_set_image_sharpening(crtc, nv_crtc->sharpness);\n\n\t \n\tregp->ramdac_8c0 = 0x100;\n\tregp->ramdac_a20 = 0x0;\n\tregp->ramdac_a24 = 0xfffff;\n\tregp->ramdac_a34 = 0x1;\n}\n\nstatic int\nnv_crtc_swap_fbs(struct drm_crtc *crtc, struct drm_framebuffer *old_fb)\n{\n\tstruct nv04_display *disp = nv04_display(crtc->dev);\n\tstruct drm_framebuffer *fb = crtc->primary->fb;\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(fb->obj[0]);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tint ret;\n\n\tret = nouveau_bo_pin(nvbo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\tif (ret == 0) {\n\t\tif (disp->image[nv_crtc->index])\n\t\t\tnouveau_bo_unpin(disp->image[nv_crtc->index]);\n\t\tnouveau_bo_ref(nvbo, &disp->image[nv_crtc->index]);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nnv_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,\n\t\t struct drm_display_mode *adjusted_mode,\n\t\t int x, int y, struct drm_framebuffer *old_fb)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint ret;\n\n\tNV_DEBUG(drm, \"CTRC mode on CRTC %d:\\n\", nv_crtc->index);\n\tdrm_mode_debug_printmodeline(adjusted_mode);\n\n\tret = nv_crtc_swap_fbs(crtc, old_fb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnv_lock_vga_crtc_shadow(dev, nv_crtc->index, -1);\n\n\tnv_crtc_mode_set_vga(crtc, adjusted_mode);\n\t \n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, nv04_display(dev)->mode_reg.sel_clk);\n\tnv_crtc_mode_set_regs(crtc, adjusted_mode);\n\tnv_crtc_calc_state_ext(crtc, mode, adjusted_mode->clock);\n\treturn 0;\n}\n\nstatic void nv_crtc_save(struct drm_crtc *crtc)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nv04_mode_state *state = &nv04_display(dev)->mode_reg;\n\tstruct nv04_crtc_reg *crtc_state = &state->crtc_reg[nv_crtc->index];\n\tstruct nv04_mode_state *saved = &nv04_display(dev)->saved_reg;\n\tstruct nv04_crtc_reg *crtc_saved = &saved->crtc_reg[nv_crtc->index];\n\n\tif (nv_two_heads(crtc->dev))\n\t\tNVSetOwner(crtc->dev, nv_crtc->index);\n\n\tnouveau_hw_save_state(crtc->dev, nv_crtc->index, saved);\n\n\t \n\tstate->sel_clk = saved->sel_clk & ~(0x5 << 16);\n\tcrtc_state->CRTC[NV_CIO_CRE_LCD__INDEX] = crtc_saved->CRTC[NV_CIO_CRE_LCD__INDEX];\n\tstate->pllsel = saved->pllsel & ~(PLLSEL_VPLL1_MASK | PLLSEL_VPLL2_MASK | PLLSEL_TV_MASK);\n\tcrtc_state->gpio_ext = crtc_saved->gpio_ext;\n}\n\nstatic void nv_crtc_restore(struct drm_crtc *crtc)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tint head = nv_crtc->index;\n\tuint8_t saved_cr21 = nv04_display(dev)->saved_reg.crtc_reg[head].CRTC[NV_CIO_CRE_21];\n\n\tif (nv_two_heads(crtc->dev))\n\t\tNVSetOwner(crtc->dev, head);\n\n\tnouveau_hw_load_state(crtc->dev, head, &nv04_display(dev)->saved_reg);\n\tnv_lock_vga_crtc_shadow(crtc->dev, head, saved_cr21);\n\n\tnv_crtc->last_dpms = NV_DPMS_CLEARED;\n}\n\nstatic void nv_crtc_prepare(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tconst struct drm_crtc_helper_funcs *funcs = crtc->helper_private;\n\n\tif (nv_two_heads(dev))\n\t\tNVSetOwner(dev, nv_crtc->index);\n\n\tdrm_crtc_vblank_off(crtc);\n\tfuncs->dpms(crtc, DRM_MODE_DPMS_OFF);\n\n\tNVBlankScreen(dev, nv_crtc->index, true);\n\n\t \n\tNVWriteCRTC(dev, nv_crtc->index, NV_PCRTC_CONFIG, NV_PCRTC_CONFIG_START_ADDRESS_NON_VGA);\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE) {\n\t\tuint32_t reg900 = NVReadRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_900);\n\t\tNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_900, reg900 & ~0x10000);\n\t}\n}\n\nstatic void nv_crtc_commit(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tconst struct drm_crtc_helper_funcs *funcs = crtc->helper_private;\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\n\tnouveau_hw_load_state(dev, nv_crtc->index, &nv04_display(dev)->mode_reg);\n\tnv04_crtc_mode_set_base(crtc, crtc->x, crtc->y, NULL);\n\n#ifdef __BIG_ENDIAN\n\t \n\t{\n\t\tuint8_t tmp = NVReadVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RCR);\n\t\ttmp |= MASK(NV_CIO_CRE_RCR_ENDIAN_BIG);\n\t\tNVWriteVgaCrtc(dev, nv_crtc->index, NV_CIO_CRE_RCR, tmp);\n\t}\n#endif\n\n\tfuncs->dpms(crtc, DRM_MODE_DPMS_ON);\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void nv_crtc_destroy(struct drm_crtc *crtc)\n{\n\tstruct nv04_display *disp = nv04_display(crtc->dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\n\tif (!nv_crtc)\n\t\treturn;\n\n\tdrm_crtc_cleanup(crtc);\n\n\tif (disp->image[nv_crtc->index])\n\t\tnouveau_bo_unpin(disp->image[nv_crtc->index]);\n\tnouveau_bo_ref(NULL, &disp->image[nv_crtc->index]);\n\n\tnouveau_bo_unmap(nv_crtc->cursor.nvbo);\n\tnouveau_bo_unpin(nv_crtc->cursor.nvbo);\n\tnouveau_bo_ref(NULL, &nv_crtc->cursor.nvbo);\n\tnvif_event_dtor(&nv_crtc->vblank);\n\tnvif_head_dtor(&nv_crtc->head);\n\tkfree(nv_crtc);\n}\n\nstatic void\nnv_crtc_gamma_load(struct drm_crtc *crtc)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = nv_crtc->base.dev;\n\tstruct rgb { uint8_t r, g, b; } __attribute__((packed)) *rgbs;\n\tu16 *r, *g, *b;\n\tint i;\n\n\trgbs = (struct rgb *)nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index].DAC;\n\tr = crtc->gamma_store;\n\tg = r + crtc->gamma_size;\n\tb = g + crtc->gamma_size;\n\n\tfor (i = 0; i < 256; i++) {\n\t\trgbs[i].r = *r++ >> 8;\n\t\trgbs[i].g = *g++ >> 8;\n\t\trgbs[i].b = *b++ >> 8;\n\t}\n\n\tnouveau_hw_load_state_palette(dev, nv_crtc->index, &nv04_display(dev)->mode_reg);\n}\n\nstatic void\nnv_crtc_disable(struct drm_crtc *crtc)\n{\n\tstruct nv04_display *disp = nv04_display(crtc->dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tif (disp->image[nv_crtc->index])\n\t\tnouveau_bo_unpin(disp->image[nv_crtc->index]);\n\tnouveau_bo_ref(NULL, &disp->image[nv_crtc->index]);\n}\n\nstatic int\nnv_crtc_gamma_set(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,\n\t\t  uint32_t size,\n\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\n\t \n\tif (!nv_crtc->base.primary->fb) {\n\t\tnv_crtc->lut.depth = 0;\n\t\treturn 0;\n\t}\n\n\tnv_crtc_gamma_load(crtc);\n\n\treturn 0;\n}\n\nstatic int\nnv04_crtc_do_mode_set_base(struct drm_crtc *crtc,\n\t\t\t   struct drm_framebuffer *passed_fb,\n\t\t\t   int x, int y, bool atomic)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\tstruct nouveau_bo *nvbo;\n\tstruct drm_framebuffer *drm_fb;\n\tint arb_burst, arb_lwm;\n\n\tNV_DEBUG(drm, \"index %d\\n\", nv_crtc->index);\n\n\t \n\tif (!atomic && !crtc->primary->fb) {\n\t\tNV_DEBUG(drm, \"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (atomic) {\n\t\tdrm_fb = passed_fb;\n\t} else {\n\t\tdrm_fb = crtc->primary->fb;\n\t}\n\n\tnvbo = nouveau_gem_object(drm_fb->obj[0]);\n\tnv_crtc->fb.offset = nvbo->offset;\n\n\tif (nv_crtc->lut.depth != drm_fb->format->depth) {\n\t\tnv_crtc->lut.depth = drm_fb->format->depth;\n\t\tnv_crtc_gamma_load(crtc);\n\t}\n\n\t \n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] &= ~3;\n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] |= (drm_fb->format->depth + 1) / 8;\n\tregp->ramdac_gen_ctrl &= ~NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tif (drm_fb->format->depth == 16)\n\t\tregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_PIXEL_INDEX);\n\tNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_GENERAL_CONTROL,\n\t\t      regp->ramdac_gen_ctrl);\n\n\tregp->CRTC[NV_CIO_CR_OFFSET_INDEX] = drm_fb->pitches[0] >> 3;\n\tregp->CRTC[NV_CIO_CRE_RPC0_INDEX] =\n\t\tXLATE(drm_fb->pitches[0] >> 3, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);\n\tregp->CRTC[NV_CIO_CRE_42] =\n\t\tXLATE(drm_fb->pitches[0] / 8, 11, NV_CIO_CRE_42_OFFSET_11);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_RPC0_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CR_OFFSET_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_42);\n\n\t \n\tregp->fb_start = nv_crtc->fb.offset & ~3;\n\tregp->fb_start += (y * drm_fb->pitches[0]) + (x * drm_fb->format->cpp[0]);\n\tnv_set_crtc_base(dev, nv_crtc->index, regp->fb_start);\n\n\t \n\tnouveau_calc_arb(dev, crtc->mode.clock, drm_fb->format->cpp[0] * 8,\n\t\t\t &arb_burst, &arb_lwm);\n\n\tregp->CRTC[NV_CIO_CRE_FF_INDEX] = arb_burst;\n\tregp->CRTC[NV_CIO_CRE_FFLWM__INDEX] = arb_lwm & 0xff;\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FF_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FFLWM__INDEX);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_KELVIN) {\n\t\tregp->CRTC[NV_CIO_CRE_47] = arb_lwm >> 8;\n\t\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_47);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnv04_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\n\t\t\tstruct drm_framebuffer *old_fb)\n{\n\tint ret = nv_crtc_swap_fbs(crtc, old_fb);\n\tif (ret)\n\t\treturn ret;\n\treturn nv04_crtc_do_mode_set_base(crtc, old_fb, x, y, false);\n}\n\nstatic int\nnv04_crtc_mode_set_base_atomic(struct drm_crtc *crtc,\n\t\t\t       struct drm_framebuffer *fb,\n\t\t\t       int x, int y, enum mode_set_atomic state)\n{\n\treturn nv04_crtc_do_mode_set_base(crtc, fb, x, y, true);\n}\n\nstatic void nv04_cursor_upload(struct drm_device *dev, struct nouveau_bo *src,\n\t\t\t       struct nouveau_bo *dst)\n{\n\tint width = nv_cursor_width(dev);\n\tuint32_t pixel;\n\tint i, j;\n\n\tfor (i = 0; i < width; i++) {\n\t\tfor (j = 0; j < width; j++) {\n\t\t\tpixel = nouveau_bo_rd32(src, i*64 + j);\n\n\t\t\tnouveau_bo_wr16(dst, i*width + j, (pixel & 0x80000000) >> 16\n\t\t\t\t     | (pixel & 0xf80000) >> 9\n\t\t\t\t     | (pixel & 0xf800) >> 6\n\t\t\t\t     | (pixel & 0xf8) >> 3);\n\t\t}\n\t}\n}\n\nstatic void nv11_cursor_upload(struct drm_device *dev, struct nouveau_bo *src,\n\t\t\t       struct nouveau_bo *dst)\n{\n\tuint32_t pixel;\n\tint alpha, i;\n\n\t \n\tfor (i = 0; i < 64 * 64; i++) {\n\t\tpixel = nouveau_bo_rd32(src, i);\n\n\t\t \n\t\talpha = pixel >> 24;\n\t\tif (alpha > 0 && alpha < 255)\n\t\t\tpixel = (pixel & 0x00ffffff) | ((alpha + 1) << 24);\n\n#ifdef __BIG_ENDIAN\n\t\t{\n\t\t\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\t\t\tif (drm->client.device.info.chipset == 0x11) {\n\t\t\t\tpixel = ((pixel & 0x000000ff) << 24) |\n\t\t\t\t\t((pixel & 0x0000ff00) << 8) |\n\t\t\t\t\t((pixel & 0x00ff0000) >> 8) |\n\t\t\t\t\t((pixel & 0xff000000) >> 24);\n\t\t\t}\n\t\t}\n#endif\n\n\t\tnouveau_bo_wr32(dst, i, pixel);\n\t}\n}\n\nstatic int\nnv04_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,\n\t\t     uint32_t buffer_handle, uint32_t width, uint32_t height)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\n\tstruct drm_device *dev = drm->dev;\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct nouveau_bo *cursor = NULL;\n\tstruct drm_gem_object *gem;\n\tint ret = 0;\n\n\tif (!buffer_handle) {\n\t\tnv_crtc->cursor.hide(nv_crtc, true);\n\t\treturn 0;\n\t}\n\n\tif (width != 64 || height != 64)\n\t\treturn -EINVAL;\n\n\tgem = drm_gem_object_lookup(file_priv, buffer_handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\tcursor = nouveau_gem_object(gem);\n\n\tret = nouveau_bo_map(cursor);\n\tif (ret)\n\t\tgoto out;\n\n\tif (drm->client.device.info.chipset >= 0x11)\n\t\tnv11_cursor_upload(dev, cursor, nv_crtc->cursor.nvbo);\n\telse\n\t\tnv04_cursor_upload(dev, cursor, nv_crtc->cursor.nvbo);\n\n\tnouveau_bo_unmap(cursor);\n\tnv_crtc->cursor.offset = nv_crtc->cursor.nvbo->offset;\n\tnv_crtc->cursor.set_offset(nv_crtc, nv_crtc->cursor.offset);\n\tnv_crtc->cursor.show(nv_crtc, true);\nout:\n\tdrm_gem_object_put(gem);\n\treturn ret;\n}\n\nstatic int\nnv04_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\n\tnv_crtc->cursor.set_pos(nv_crtc, x, y);\n\treturn 0;\n}\n\nstruct nv04_page_flip_state {\n\tstruct list_head head;\n\tstruct drm_pending_vblank_event *event;\n\tstruct drm_crtc *crtc;\n\tint bpp, pitch;\n\tu64 offset;\n};\n\nstatic int\nnv04_finish_page_flip(struct nouveau_channel *chan,\n\t\t      struct nv04_page_flip_state *ps)\n{\n\tstruct nouveau_fence_chan *fctx = chan->fence;\n\tstruct nouveau_drm *drm = chan->drm;\n\tstruct drm_device *dev = drm->dev;\n\tstruct nv04_page_flip_state *s;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tif (list_empty(&fctx->flip)) {\n\t\tNV_ERROR(drm, \"unexpected pageflip\\n\");\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\ts = list_first_entry(&fctx->flip, struct nv04_page_flip_state, head);\n\tif (s->event) {\n\t\tdrm_crtc_arm_vblank_event(s->crtc, s->event);\n\t} else {\n\t\t \n\t\tdrm_crtc_vblank_put(s->crtc);\n\t}\n\n\tlist_del(&s->head);\n\tif (ps)\n\t\t*ps = *s;\n\tkfree(s);\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn 0;\n}\n\nint\nnv04_flip_complete(struct nvif_event *event, void *argv, u32 argc)\n{\n\tstruct nv04_display *disp = container_of(event, typeof(*disp), flip);\n\tstruct nouveau_drm *drm = disp->drm;\n\tstruct nouveau_channel *chan = drm->channel;\n\tstruct nv04_page_flip_state state;\n\n\tif (!nv04_finish_page_flip(chan, &state)) {\n\t\tnv_set_crtc_base(drm->dev, drm_crtc_index(state.crtc),\n\t\t\t\t state.offset + state.crtc->y *\n\t\t\t\t state.pitch + state.crtc->x *\n\t\t\t\t state.bpp / 8);\n\t}\n\n\treturn NVIF_EVENT_KEEP;\n}\n\nstatic int\nnv04_page_flip_emit(struct nouveau_channel *chan,\n\t\t    struct nouveau_bo *old_bo,\n\t\t    struct nouveau_bo *new_bo,\n\t\t    struct nv04_page_flip_state *s,\n\t\t    struct nouveau_fence **pfence)\n{\n\tstruct nouveau_fence_chan *fctx = chan->fence;\n\tstruct nouveau_drm *drm = chan->drm;\n\tstruct drm_device *dev = drm->dev;\n\tstruct nvif_push *push = chan->chan.push;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tlist_add_tail(&s->head, &fctx->flip);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\t \n\tret = nouveau_fence_sync(old_bo, chan, false, false);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tret = PUSH_WAIT(push, 2);\n\tif (ret)\n\t\tgoto fail;\n\n\tPUSH_NVSQ(push, NV_SW, NV_SW_PAGE_FLIP, 0x00000000);\n\tPUSH_KICK(push);\n\n\tret = nouveau_fence_new(pfence, chan);\n\tif (ret)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tlist_del(&s->head);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn ret;\n}\n\nstatic int\nnv04_crtc_page_flip(struct drm_crtc *crtc, struct drm_framebuffer *fb,\n\t\t    struct drm_pending_vblank_event *event, u32 flags,\n\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tconst int swap_interval = (flags & DRM_MODE_PAGE_FLIP_ASYNC) ? 0 : 1;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_framebuffer *old_fb = crtc->primary->fb;\n\tstruct nouveau_bo *old_bo = nouveau_gem_object(old_fb->obj[0]);\n\tstruct nouveau_bo *new_bo = nouveau_gem_object(fb->obj[0]);\n\tstruct nv04_page_flip_state *s;\n\tstruct nouveau_channel *chan;\n\tstruct nouveau_cli *cli;\n\tstruct nouveau_fence *fence;\n\tstruct nv04_display *dispnv04 = nv04_display(dev);\n\tstruct nvif_push *push;\n\tint head = nouveau_crtc(crtc)->index;\n\tint ret;\n\n\tchan = drm->channel;\n\tif (!chan)\n\t\treturn -ENODEV;\n\tcli = (void *)chan->user.client;\n\tpush = chan->chan.push;\n\n\ts = kzalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tif (new_bo != old_bo) {\n\t\tret = nouveau_bo_pin(new_bo, NOUVEAU_GEM_DOMAIN_VRAM, true);\n\t\tif (ret)\n\t\t\tgoto fail_free;\n\t}\n\n\tmutex_lock(&cli->mutex);\n\tret = ttm_bo_reserve(&new_bo->bo, true, false, NULL);\n\tif (ret)\n\t\tgoto fail_unpin;\n\n\t \n\tret = nouveau_fence_sync(new_bo, chan, false, true);\n\tif (ret) {\n\t\tttm_bo_unreserve(&new_bo->bo);\n\t\tgoto fail_unpin;\n\t}\n\n\tif (new_bo != old_bo) {\n\t\tttm_bo_unreserve(&new_bo->bo);\n\n\t\tret = ttm_bo_reserve(&old_bo->bo, true, false, NULL);\n\t\tif (ret)\n\t\t\tgoto fail_unpin;\n\t}\n\n\t \n\t*s = (struct nv04_page_flip_state)\n\t\t{ { }, event, crtc, fb->format->cpp[0] * 8, fb->pitches[0],\n\t\t  new_bo->offset };\n\n\t \n\tdrm_crtc_vblank_get(crtc);\n\n\t \n\tif (swap_interval) {\n\t\tret = PUSH_WAIT(push, 8);\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\n\t\tPUSH_NVSQ(push, NV05F, 0x012c, 0);\n\t\tPUSH_NVSQ(push, NV05F, 0x0134, head);\n\t\tPUSH_NVSQ(push, NV05F, 0x0100, 0);\n\t\tPUSH_NVSQ(push, NV05F, 0x0130, 0);\n\t}\n\n\tnouveau_bo_ref(new_bo, &dispnv04->image[head]);\n\n\tret = nv04_page_flip_emit(chan, old_bo, new_bo, s, &fence);\n\tif (ret)\n\t\tgoto fail_unreserve;\n\tmutex_unlock(&cli->mutex);\n\n\t \n\tcrtc->primary->fb = fb;\n\n\tnouveau_bo_fence(old_bo, fence, false);\n\tttm_bo_unreserve(&old_bo->bo);\n\tif (old_bo != new_bo)\n\t\tnouveau_bo_unpin(old_bo);\n\tnouveau_fence_unref(&fence);\n\treturn 0;\n\nfail_unreserve:\n\tdrm_crtc_vblank_put(crtc);\n\tttm_bo_unreserve(&old_bo->bo);\nfail_unpin:\n\tmutex_unlock(&cli->mutex);\n\tif (old_bo != new_bo)\n\t\tnouveau_bo_unpin(new_bo);\nfail_free:\n\tkfree(s);\n\treturn ret;\n}\n\nstatic const struct drm_crtc_funcs nv04_crtc_funcs = {\n\t.cursor_set = nv04_crtc_cursor_set,\n\t.cursor_move = nv04_crtc_cursor_move,\n\t.gamma_set = nv_crtc_gamma_set,\n\t.set_config = drm_crtc_helper_set_config,\n\t.page_flip = nv04_crtc_page_flip,\n\t.destroy = nv_crtc_destroy,\n\t.enable_vblank = nouveau_display_vblank_enable,\n\t.disable_vblank = nouveau_display_vblank_disable,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n};\n\nstatic const struct drm_crtc_helper_funcs nv04_crtc_helper_funcs = {\n\t.dpms = nv_crtc_dpms,\n\t.prepare = nv_crtc_prepare,\n\t.commit = nv_crtc_commit,\n\t.mode_set = nv_crtc_mode_set,\n\t.mode_set_base = nv04_crtc_mode_set_base,\n\t.mode_set_base_atomic = nv04_crtc_mode_set_base_atomic,\n\t.disable = nv_crtc_disable,\n\t.get_scanout_position = nouveau_display_scanoutpos,\n};\n\nstatic const uint32_t modeset_formats[] = {\n        DRM_FORMAT_XRGB8888,\n        DRM_FORMAT_RGB565,\n        DRM_FORMAT_XRGB1555,\n};\n\nstatic const struct drm_plane_funcs nv04_primary_plane_funcs = {\n\tDRM_PLANE_NON_ATOMIC_FUNCS,\n};\n\nstatic int\nnv04_crtc_vblank_handler(struct nvif_event *event, void *repv, u32 repc)\n{\n\tstruct nouveau_crtc *nv_crtc = container_of(event, struct nouveau_crtc, vblank);\n\n\tdrm_crtc_handle_vblank(&nv_crtc->base);\n\treturn NVIF_EVENT_KEEP;\n}\n\nint\nnv04_crtc_create(struct drm_device *dev, int crtc_num)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tstruct nouveau_crtc *nv_crtc;\n\tstruct drm_plane *primary;\n\tint ret;\n\n\tnv_crtc = kzalloc(sizeof(*nv_crtc), GFP_KERNEL);\n\tif (!nv_crtc)\n\t\treturn -ENOMEM;\n\n\tnv_crtc->lut.depth = 0;\n\n\tnv_crtc->index = crtc_num;\n\tnv_crtc->last_dpms = NV_DPMS_CLEARED;\n\n\tnv_crtc->save = nv_crtc_save;\n\tnv_crtc->restore = nv_crtc_restore;\n\n\tprimary = __drm_universal_plane_alloc(dev, sizeof(*primary), 0, 0,\n\t\t\t\t\t      &nv04_primary_plane_funcs,\n\t\t\t\t\t      modeset_formats,\n\t\t\t\t\t      ARRAY_SIZE(modeset_formats), NULL,\n\t\t\t\t\t      DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (IS_ERR(primary)) {\n\t\tret = PTR_ERR(primary);\n\t\tkfree(nv_crtc);\n\t\treturn ret;\n\t}\n\n\tdrm_crtc_init_with_planes(dev, &nv_crtc->base, primary, NULL,\n                                  &nv04_crtc_funcs, NULL);\n\tdrm_crtc_helper_add(&nv_crtc->base, &nv04_crtc_helper_funcs);\n\tdrm_mode_crtc_set_gamma_size(&nv_crtc->base, 256);\n\n\tret = nouveau_bo_new(&nouveau_drm(dev)->client, 64*64*4, 0x100,\n\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM, 0, 0x0000, NULL, NULL,\n\t\t\t     &nv_crtc->cursor.nvbo);\n\tif (!ret) {\n\t\tret = nouveau_bo_pin(nv_crtc->cursor.nvbo,\n\t\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM, false);\n\t\tif (!ret) {\n\t\t\tret = nouveau_bo_map(nv_crtc->cursor.nvbo);\n\t\t\tif (ret)\n\t\t\t\tnouveau_bo_unpin(nv_crtc->cursor.nvbo);\n\t\t}\n\t\tif (ret)\n\t\t\tnouveau_bo_ref(NULL, &nv_crtc->cursor.nvbo);\n\t}\n\n\tnv04_cursor_init(nv_crtc);\n\n\tret = nvif_head_ctor(&disp->disp, nv_crtc->base.name, nv_crtc->index, &nv_crtc->head);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nvif_head_vblank_event_ctor(&nv_crtc->head, \"kmsVbl\", nv04_crtc_vblank_handler,\n\t\t\t\t\t   false, &nv_crtc->vblank);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}