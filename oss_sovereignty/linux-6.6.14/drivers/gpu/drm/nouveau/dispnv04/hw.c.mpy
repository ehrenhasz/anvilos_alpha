{
  "module_name": "hw.c",
  "hash_id": "66bb5c1b861dfd6f1a6fb176cec30fa9e787aceb2467360134f87a285919c01e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/hw.c",
  "human_readable_source": " \n\n#include \"nouveau_drv.h\"\n#include \"hw.h\"\n\n#include <subdev/bios/pll.h>\n#include <nvif/timer.h>\n\n#define CHIPSET_NFORCE 0x01a0\n#define CHIPSET_NFORCE2 0x01f0\n\n \n\nvoid\nNVWriteVgaSeq(struct drm_device *dev, int head, uint8_t index, uint8_t value)\n{\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_SRX, index);\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_SR, value);\n}\n\nuint8_t\nNVReadVgaSeq(struct drm_device *dev, int head, uint8_t index)\n{\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_SRX, index);\n\treturn NVReadPRMVIO(dev, head, NV_PRMVIO_SR);\n}\n\nvoid\nNVWriteVgaGr(struct drm_device *dev, int head, uint8_t index, uint8_t value)\n{\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_GRX, index);\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_GX, value);\n}\n\nuint8_t\nNVReadVgaGr(struct drm_device *dev, int head, uint8_t index)\n{\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_GRX, index);\n\treturn NVReadPRMVIO(dev, head, NV_PRMVIO_GX);\n}\n\n \nvoid\nNVSetOwner(struct drm_device *dev, int owner)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (owner == 1)\n\t\towner *= 3;\n\n\tif (drm->client.device.info.chipset == 0x11) {\n\t\t \n\t\tNVReadVgaCrtc(dev, 0, NV_CIO_SR_LOCK_INDEX);\n\t\tNVReadVgaCrtc(dev, 1, NV_CIO_SR_LOCK_INDEX);\n\t}\n\n\t \n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_44, owner);\n\n\tif (drm->client.device.info.chipset == 0x11) {\t \n\t\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_2E, owner);\n\t\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_2E, owner);\n\t}\n}\n\nvoid\nNVBlankScreen(struct drm_device *dev, int head, bool blank)\n{\n\tunsigned char seq1;\n\n\tif (nv_two_heads(dev))\n\t\tNVSetOwner(dev, head);\n\n\tseq1 = NVReadVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX);\n\n\tNVVgaSeqReset(dev, head, true);\n\tif (blank)\n\t\tNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 | 0x20);\n\telse\n\t\tNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 & ~0x20);\n\tNVVgaSeqReset(dev, head, false);\n}\n\n \n\nstatic void\nnouveau_hw_decode_pll(struct drm_device *dev, uint32_t reg1, uint32_t pll1,\n\t\t      uint32_t pll2, struct nvkm_pll_vals *pllvals)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\t \n\n\t \n\tpllvals->log2P = (pll1 >> 16) & 0x7;\n\tpllvals->N2 = pllvals->M2 = 1;\n\n\tif (reg1 <= 0x405c) {\n\t\tpllvals->NM1 = pll2 & 0xffff;\n\t\t \n\t\tif (!(pll1 & 0x1100))\n\t\t\tpllvals->NM2 = pll2 >> 16;\n\t} else {\n\t\tpllvals->NM1 = pll1 & 0xffff;\n\t\tif (nv_two_reg_pll(dev) && pll2 & NV31_RAMDAC_ENABLE_VCO2)\n\t\t\tpllvals->NM2 = pll2 & 0xffff;\n\t\telse if (drm->client.device.info.chipset == 0x30 || drm->client.device.info.chipset == 0x35) {\n\t\t\tpllvals->M1 &= 0xf;  \n\t\t\tif (pll1 & NV30_RAMDAC_ENABLE_VCO2) {\n\t\t\t\tpllvals->M2 = (pll1 >> 4) & 0x7;\n\t\t\t\tpllvals->N2 = ((pll1 >> 21) & 0x18) |\n\t\t\t\t\t      ((pll1 >> 19) & 0x7);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\nnouveau_hw_get_pllvals(struct drm_device *dev, enum nvbios_pll_type plltype,\n\t\t       struct nvkm_pll_vals *pllvals)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tstruct nvkm_bios *bios = nvxx_bios(&drm->client.device);\n\tuint32_t reg1, pll1, pll2 = 0;\n\tstruct nvbios_pll pll_lim;\n\tint ret;\n\n\tret = nvbios_pll_parse(bios, plltype, &pll_lim);\n\tif (ret || !(reg1 = pll_lim.reg))\n\t\treturn -ENOENT;\n\n\tpll1 = nvif_rd32(device, reg1);\n\tif (reg1 <= 0x405c)\n\t\tpll2 = nvif_rd32(device, reg1 + 4);\n\telse if (nv_two_reg_pll(dev)) {\n\t\tuint32_t reg2 = reg1 + (reg1 == NV_RAMDAC_VPLL2 ? 0x5c : 0x70);\n\n\t\tpll2 = nvif_rd32(device, reg2);\n\t}\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CELSIUS && reg1 >= NV_PRAMDAC_VPLL_COEFF) {\n\t\tuint32_t ramdac580 = NVReadRAMDAC(dev, 0, NV_PRAMDAC_580);\n\n\t\t \n\t\tif (reg1 == NV_PRAMDAC_VPLL_COEFF) {\n\t\t\tif (ramdac580 & NV_RAMDAC_580_VPLL1_ACTIVE)\n\t\t\t\tpll2 = 0;\n\t\t} else\n\t\t\tif (ramdac580 & NV_RAMDAC_580_VPLL2_ACTIVE)\n\t\t\t\tpll2 = 0;\n\t}\n\n\tnouveau_hw_decode_pll(dev, reg1, pll1, pll2, pllvals);\n\tpllvals->refclk = pll_lim.refclk;\n\treturn 0;\n}\n\nint\nnouveau_hw_pllvals_to_clk(struct nvkm_pll_vals *pv)\n{\n\t \n\tif (!pv->M1 || !pv->M2)\n\t\treturn 0;\n\n\treturn pv->N1 * pv->N2 * pv->refclk / (pv->M1 * pv->M2) >> pv->log2P;\n}\n\nint\nnouveau_hw_get_clock(struct drm_device *dev, enum nvbios_pll_type plltype)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tstruct nvkm_pll_vals pllvals;\n\tint ret;\n\tint domain;\n\n\tdomain = pci_domain_nr(pdev->bus);\n\n\tif (plltype == PLL_MEMORY &&\n\t    (pdev->device & 0x0ff0) == CHIPSET_NFORCE) {\n\t\tuint32_t mpllP;\n\t\tpci_read_config_dword(pci_get_domain_bus_and_slot(domain, 0, 3),\n\t\t\t\t      0x6c, &mpllP);\n\t\tmpllP = (mpllP >> 8) & 0xf;\n\t\tif (!mpllP)\n\t\t\tmpllP = 4;\n\n\t\treturn 400000 / mpllP;\n\t} else\n\tif (plltype == PLL_MEMORY &&\n\t    (pdev->device & 0xff0) == CHIPSET_NFORCE2) {\n\t\tuint32_t clock;\n\n\t\tpci_read_config_dword(pci_get_domain_bus_and_slot(domain, 0, 5),\n\t\t\t\t      0x4c, &clock);\n\t\treturn clock / 1000;\n\t}\n\n\tret = nouveau_hw_get_pllvals(dev, plltype, &pllvals);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nouveau_hw_pllvals_to_clk(&pllvals);\n}\n\nstatic void\nnouveau_hw_fix_bad_vpll(struct drm_device *dev, int head)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_device *device = &drm->client.device;\n\tstruct nvkm_clk *clk = nvxx_clk(device);\n\tstruct nvkm_bios *bios = nvxx_bios(device);\n\tstruct nvbios_pll pll_lim;\n\tstruct nvkm_pll_vals pv;\n\tenum nvbios_pll_type pll = head ? PLL_VPLL1 : PLL_VPLL0;\n\n\tif (nvbios_pll_parse(bios, pll, &pll_lim))\n\t\treturn;\n\tnouveau_hw_get_pllvals(dev, pll, &pv);\n\n\tif (pv.M1 >= pll_lim.vco1.min_m && pv.M1 <= pll_lim.vco1.max_m &&\n\t    pv.N1 >= pll_lim.vco1.min_n && pv.N1 <= pll_lim.vco1.max_n &&\n\t    pv.log2P <= pll_lim.max_p)\n\t\treturn;\n\n\tNV_WARN(drm, \"VPLL %d outwith limits, attempting to fix\\n\", head + 1);\n\n\t \n\tpv.M1 = pll_lim.vco1.max_m;\n\tpv.N1 = pll_lim.vco1.min_n;\n\tpv.log2P = pll_lim.max_p_usable;\n\tclk->pll_prog(clk, pll_lim.reg, &pv);\n}\n\n \n\nstatic void nouveau_vga_font_io(struct drm_device *dev,\n\t\t\t\tvoid __iomem *iovram,\n\t\t\t\tbool save, unsigned plane)\n{\n\tunsigned i;\n\n\tNVWriteVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX, 1 << plane);\n\tNVWriteVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX, plane);\n\tfor (i = 0; i < 16384; i++) {\n\t\tif (save) {\n\t\t\tnv04_display(dev)->saved_vga_font[plane][i] =\n\t\t\t\t\tioread32_native(iovram + i * 4);\n\t\t} else {\n\t\t\tiowrite32_native(nv04_display(dev)->saved_vga_font[plane][i],\n\t\t\t\t\t\t\tiovram + i * 4);\n\t\t}\n\t}\n}\n\nvoid\nnouveau_hw_save_vga_fonts(struct drm_device *dev, bool save)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\tuint8_t misc, gr4, gr5, gr6, seq2, seq4;\n\tbool graphicsmode;\n\tunsigned plane;\n\tvoid __iomem *iovram;\n\n\tif (nv_two_heads(dev))\n\t\tNVSetOwner(dev, 0);\n\n\tNVSetEnablePalette(dev, 0, true);\n\tgraphicsmode = NVReadVgaAttr(dev, 0, NV_CIO_AR_MODE_INDEX) & 1;\n\tNVSetEnablePalette(dev, 0, false);\n\n\tif (graphicsmode)  \n\t\treturn;\n\n\tNV_INFO(drm, \"%sing VGA fonts\\n\", save ? \"Sav\" : \"Restor\");\n\n\t \n\tiovram = ioremap(pci_resource_start(pdev, 1), 65536);\n\tif (!iovram) {\n\t\tNV_ERROR(drm, \"Failed to map VRAM, \"\n\t\t\t\t\t\"cannot save/restore VGA fonts.\\n\");\n\t\treturn;\n\t}\n\n\tif (nv_two_heads(dev))\n\t\tNVBlankScreen(dev, 1, true);\n\tNVBlankScreen(dev, 0, true);\n\n\t \n\tmisc = NVReadPRMVIO(dev, 0, NV_PRMVIO_MISC__READ);\n\tseq2 = NVReadVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX);\n\tseq4 = NVReadVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX);\n\tgr4 = NVReadVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX);\n\tgr5 = NVReadVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX);\n\tgr6 = NVReadVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX);\n\n\tNVWritePRMVIO(dev, 0, NV_PRMVIO_MISC__WRITE, 0x67);\n\tNVWriteVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX, 0x6);\n\tNVWriteVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX, 0x0);\n\tNVWriteVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX, 0x5);\n\n\t \n\tfor (plane = 0; plane < 4; plane++)\n\t\tnouveau_vga_font_io(dev, iovram, save, plane);\n\n\t \n\tNVWritePRMVIO(dev, 0, NV_PRMVIO_MISC__WRITE, misc);\n\tNVWriteVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX, gr4);\n\tNVWriteVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX, gr5);\n\tNVWriteVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX, gr6);\n\tNVWriteVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX, seq2);\n\tNVWriteVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX, seq4);\n\n\tif (nv_two_heads(dev))\n\t\tNVBlankScreen(dev, 1, false);\n\tNVBlankScreen(dev, 0, false);\n\n\tiounmap(iovram);\n}\n\n \n\nstatic void\nrd_cio_state(struct drm_device *dev, int head,\n\t     struct nv04_crtc_reg *crtcstate, int index)\n{\n\tcrtcstate->CRTC[index] = NVReadVgaCrtc(dev, head, index);\n}\n\nstatic void\nwr_cio_state(struct drm_device *dev, int head,\n\t     struct nv04_crtc_reg *crtcstate, int index)\n{\n\tNVWriteVgaCrtc(dev, head, index, crtcstate->CRTC[index]);\n}\n\nstatic void\nnv_save_state_ramdac(struct drm_device *dev, int head,\n\t\t     struct nv04_mode_state *state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\n\tint i;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\n\t\tregp->nv10_cursync = NVReadRAMDAC(dev, head, NV_RAMDAC_NV10_CURSYNC);\n\n\tnouveau_hw_get_pllvals(dev, head ? PLL_VPLL1 : PLL_VPLL0, &regp->pllvals);\n\tstate->pllsel = NVReadRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT);\n\tif (nv_two_heads(dev))\n\t\tstate->sel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK);\n\tif (drm->client.device.info.chipset == 0x11)\n\t\tregp->dither = NVReadRAMDAC(dev, head, NV_RAMDAC_DITHER_NV11);\n\n\tregp->ramdac_gen_ctrl = NVReadRAMDAC(dev, head, NV_PRAMDAC_GENERAL_CONTROL);\n\n\tif (nv_gf4_disp_arch(dev))\n\t\tregp->ramdac_630 = NVReadRAMDAC(dev, head, NV_PRAMDAC_630);\n\tif (drm->client.device.info.chipset >= 0x30)\n\t\tregp->ramdac_634 = NVReadRAMDAC(dev, head, NV_PRAMDAC_634);\n\n\tregp->tv_setup = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP);\n\tregp->tv_vtotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VTOTAL);\n\tregp->tv_vskew = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VSKEW);\n\tregp->tv_vsync_delay = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VSYNC_DELAY);\n\tregp->tv_htotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HTOTAL);\n\tregp->tv_hskew = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSKEW);\n\tregp->tv_hsync_delay = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY);\n\tregp->tv_hsync_delay2 = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY2);\n\n\tfor (i = 0; i < 7; i++) {\n\t\tuint32_t ramdac_reg = NV_PRAMDAC_FP_VDISPLAY_END + (i * 4);\n\t\tregp->fp_vert_regs[i] = NVReadRAMDAC(dev, head, ramdac_reg);\n\t\tregp->fp_horiz_regs[i] = NVReadRAMDAC(dev, head, ramdac_reg + 0x20);\n\t}\n\n\tif (nv_gf4_disp_arch(dev)) {\n\t\tregp->dither = NVReadRAMDAC(dev, head, NV_RAMDAC_FP_DITHER);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tregp->dither_regs[i] = NVReadRAMDAC(dev, head, NV_PRAMDAC_850 + i * 4);\n\t\t\tregp->dither_regs[i + 3] = NVReadRAMDAC(dev, head, NV_PRAMDAC_85C + i * 4);\n\t\t}\n\t}\n\n\tregp->fp_control = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\n\tregp->fp_debug_0 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_0);\n\tif (!nv_gf4_disp_arch(dev) && head == 0) {\n\t\t \n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_FP_DEBUG_0, regp->fp_debug_0 &\n\t\t\t      ~NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);\n\t}\n\tregp->fp_debug_1 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_1);\n\tregp->fp_debug_2 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_2);\n\n\tregp->fp_margin_color = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_MARGIN_COLOR);\n\n\tif (nv_gf4_disp_arch(dev))\n\t\tregp->ramdac_8c0 = NVReadRAMDAC(dev, head, NV_PRAMDAC_8C0);\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE) {\n\t\tregp->ramdac_a20 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A20);\n\t\tregp->ramdac_a24 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A24);\n\t\tregp->ramdac_a34 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A34);\n\n\t\tfor (i = 0; i < 38; i++)\n\t\t\tregp->ctv_regs[i] = NVReadRAMDAC(dev, head,\n\t\t\t\t\t\t\t NV_PRAMDAC_CTV + 4*i);\n\t}\n}\n\nstatic void\nnv_load_state_ramdac(struct drm_device *dev, int head,\n\t\t     struct nv04_mode_state *state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_clk *clk = nvxx_clk(&drm->client.device);\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\n\tuint32_t pllreg = head ? NV_RAMDAC_VPLL2 : NV_PRAMDAC_VPLL_COEFF;\n\tint i;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS)\n\t\tNVWriteRAMDAC(dev, head, NV_RAMDAC_NV10_CURSYNC, regp->nv10_cursync);\n\n\tclk->pll_prog(clk, pllreg, &regp->pllvals);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT, state->pllsel);\n\tif (nv_two_heads(dev))\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, state->sel_clk);\n\tif (drm->client.device.info.chipset == 0x11)\n\t\tNVWriteRAMDAC(dev, head, NV_RAMDAC_DITHER_NV11, regp->dither);\n\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_GENERAL_CONTROL, regp->ramdac_gen_ctrl);\n\n\tif (nv_gf4_disp_arch(dev))\n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_630, regp->ramdac_630);\n\tif (drm->client.device.info.chipset >= 0x30)\n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_634, regp->ramdac_634);\n\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP, regp->tv_setup);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VTOTAL, regp->tv_vtotal);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VSKEW, regp->tv_vskew);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VSYNC_DELAY, regp->tv_vsync_delay);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HTOTAL, regp->tv_htotal);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSKEW, regp->tv_hskew);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY, regp->tv_hsync_delay);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY2, regp->tv_hsync_delay2);\n\n\tfor (i = 0; i < 7; i++) {\n\t\tuint32_t ramdac_reg = NV_PRAMDAC_FP_VDISPLAY_END + (i * 4);\n\n\t\tNVWriteRAMDAC(dev, head, ramdac_reg, regp->fp_vert_regs[i]);\n\t\tNVWriteRAMDAC(dev, head, ramdac_reg + 0x20, regp->fp_horiz_regs[i]);\n\t}\n\n\tif (nv_gf4_disp_arch(dev)) {\n\t\tNVWriteRAMDAC(dev, head, NV_RAMDAC_FP_DITHER, regp->dither);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_850 + i * 4, regp->dither_regs[i]);\n\t\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_85C + i * 4, regp->dither_regs[i + 3]);\n\t\t}\n\t}\n\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL, regp->fp_control);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_0, regp->fp_debug_0);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_1, regp->fp_debug_1);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_2, regp->fp_debug_2);\n\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_MARGIN_COLOR, regp->fp_margin_color);\n\n\tif (nv_gf4_disp_arch(dev))\n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_8C0, regp->ramdac_8c0);\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE) {\n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_A20, regp->ramdac_a20);\n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_A24, regp->ramdac_a24);\n\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_A34, regp->ramdac_a34);\n\n\t\tfor (i = 0; i < 38; i++)\n\t\t\tNVWriteRAMDAC(dev, head,\n\t\t\t\t      NV_PRAMDAC_CTV + 4*i, regp->ctv_regs[i]);\n\t}\n}\n\nstatic void\nnv_save_state_vga(struct drm_device *dev, int head,\n\t\t  struct nv04_mode_state *state)\n{\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\n\tint i;\n\n\tregp->MiscOutReg = NVReadPRMVIO(dev, head, NV_PRMVIO_MISC__READ);\n\n\tfor (i = 0; i < 25; i++)\n\t\trd_cio_state(dev, head, regp, i);\n\n\tNVSetEnablePalette(dev, head, true);\n\tfor (i = 0; i < 21; i++)\n\t\tregp->Attribute[i] = NVReadVgaAttr(dev, head, i);\n\tNVSetEnablePalette(dev, head, false);\n\n\tfor (i = 0; i < 9; i++)\n\t\tregp->Graphics[i] = NVReadVgaGr(dev, head, i);\n\n\tfor (i = 0; i < 5; i++)\n\t\tregp->Sequencer[i] = NVReadVgaSeq(dev, head, i);\n}\n\nstatic void\nnv_load_state_vga(struct drm_device *dev, int head,\n\t\t  struct nv04_mode_state *state)\n{\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\n\tint i;\n\n\tNVWritePRMVIO(dev, head, NV_PRMVIO_MISC__WRITE, regp->MiscOutReg);\n\n\tfor (i = 0; i < 5; i++)\n\t\tNVWriteVgaSeq(dev, head, i, regp->Sequencer[i]);\n\n\tnv_lock_vga_crtc_base(dev, head, false);\n\tfor (i = 0; i < 25; i++)\n\t\twr_cio_state(dev, head, regp, i);\n\tnv_lock_vga_crtc_base(dev, head, true);\n\n\tfor (i = 0; i < 9; i++)\n\t\tNVWriteVgaGr(dev, head, i, regp->Graphics[i]);\n\n\tNVSetEnablePalette(dev, head, true);\n\tfor (i = 0; i < 21; i++)\n\t\tNVWriteVgaAttr(dev, head, i, regp->Attribute[i]);\n\tNVSetEnablePalette(dev, head, false);\n}\n\nstatic void\nnv_save_state_ext(struct drm_device *dev, int head,\n\t\t  struct nv04_mode_state *state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\n\tint i;\n\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_LCD__INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_RPC0_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_RPC1_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_LSR_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_PIXEL_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_HEB__INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_ENH_INDEX);\n\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_FF_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_FFLWM__INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_21);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_KELVIN)\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_47);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\n\t\trd_cio_state(dev, head, regp, 0x9f);\n\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_49);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR0_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR1_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR2_INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_ILACE__INDEX);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS) {\n\t\tregp->crtc_830 = NVReadCRTC(dev, head, NV_PCRTC_830);\n\t\tregp->crtc_834 = NVReadCRTC(dev, head, NV_PCRTC_834);\n\n\t\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\n\t\t\tregp->gpio_ext = NVReadCRTC(dev, head, NV_PCRTC_GPIO_EXT);\n\n\t\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\t\tregp->crtc_850 = NVReadCRTC(dev, head, NV_PCRTC_850);\n\n\t\tif (nv_two_heads(dev))\n\t\t\tregp->crtc_eng_ctrl = NVReadCRTC(dev, head, NV_PCRTC_ENGINE_CTRL);\n\t\tregp->cursor_cfg = NVReadCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG);\n\t}\n\n\tregp->crtc_cfg = NVReadCRTC(dev, head, NV_PCRTC_CONFIG);\n\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH3__INDEX);\n\trd_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH4__INDEX);\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS) {\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_EBR_INDEX);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_CSB);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_4B);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_TVOUT_LATENCY);\n\t}\n\t \n\tif (nv_gf4_disp_arch(dev)) {\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_42);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_53);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_54);\n\n\t\tfor (i = 0; i < 0x10; i++)\n\t\t\tregp->CR58[i] = NVReadVgaCrtc5758(dev, head, i);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_59);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_5B);\n\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_85);\n\t\trd_cio_state(dev, head, regp, NV_CIO_CRE_86);\n\t}\n\n\tregp->fb_start = NVReadCRTC(dev, head, NV_PCRTC_START);\n}\n\nstatic void\nnv_load_state_ext(struct drm_device *dev, int head,\n\t\t  struct nv04_mode_state *state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\n\tuint32_t reg900;\n\tint i;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS) {\n\t\tif (nv_two_heads(dev))\n\t\t\t \n\t\t\tNVWriteCRTC(dev, head, NV_PCRTC_ENGINE_CTRL, regp->crtc_eng_ctrl);\n\n\t\tnvif_wr32(device, NV_PVIDEO_STOP, 1);\n\t\tnvif_wr32(device, NV_PVIDEO_INTR_EN, 0);\n\t\tnvif_wr32(device, NV_PVIDEO_OFFSET_BUFF(0), 0);\n\t\tnvif_wr32(device, NV_PVIDEO_OFFSET_BUFF(1), 0);\n\t\tnvif_wr32(device, NV_PVIDEO_LIMIT(0), drm->client.device.info.ram_size - 1);\n\t\tnvif_wr32(device, NV_PVIDEO_LIMIT(1), drm->client.device.info.ram_size - 1);\n\t\tnvif_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(0), drm->client.device.info.ram_size - 1);\n\t\tnvif_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(1), drm->client.device.info.ram_size - 1);\n\t\tnvif_wr32(device, NV_PBUS_POWERCTRL_2, 0);\n\n\t\tNVWriteCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG, regp->cursor_cfg);\n\t\tNVWriteCRTC(dev, head, NV_PCRTC_830, regp->crtc_830);\n\t\tNVWriteCRTC(dev, head, NV_PCRTC_834, regp->crtc_834);\n\n\t\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\n\t\t\tNVWriteCRTC(dev, head, NV_PCRTC_GPIO_EXT, regp->gpio_ext);\n\n\t\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE) {\n\t\t\tNVWriteCRTC(dev, head, NV_PCRTC_850, regp->crtc_850);\n\n\t\t\treg900 = NVReadRAMDAC(dev, head, NV_PRAMDAC_900);\n\t\t\tif (regp->crtc_cfg == NV10_PCRTC_CONFIG_START_ADDRESS_HSYNC)\n\t\t\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_900, reg900 | 0x10000);\n\t\t\telse\n\t\t\t\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_900, reg900 & ~0x10000);\n\t\t}\n\t}\n\n\tNVWriteCRTC(dev, head, NV_PCRTC_CONFIG, regp->crtc_cfg);\n\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_RPC0_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_RPC1_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_LSR_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_PIXEL_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_LCD__INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_HEB__INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_ENH_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_FF_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_FFLWM__INDEX);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_KELVIN)\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_47);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE)\n\t\twr_cio_state(dev, head, regp, 0x9f);\n\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_49);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR0_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR1_INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR2_INDEX);\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\tnv_fix_nv40_hw_cursor(dev, head);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_ILACE__INDEX);\n\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH3__INDEX);\n\twr_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH4__INDEX);\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS) {\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_EBR_INDEX);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_CSB);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_4B);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_TVOUT_LATENCY);\n\t}\n\t \n\tif (nv_gf4_disp_arch(dev)) {\n\t\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_KELVIN) {\n\t\t\t \n\t\t\tnvif_msec(&drm->client.device, 650,\n\t\t\t\tif ( (nvif_rd32(device, NV_PRMCIO_INP0__COLOR) & 8))\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t\tnvif_msec(&drm->client.device, 650,\n\t\t\t\tif (!(nvif_rd32(device, NV_PRMCIO_INP0__COLOR) & 8))\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t}\n\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_42);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_53);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_54);\n\n\t\tfor (i = 0; i < 0x10; i++)\n\t\t\tNVWriteVgaCrtc5758(dev, head, i, regp->CR58[i]);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_59);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_5B);\n\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_85);\n\t\twr_cio_state(dev, head, regp, NV_CIO_CRE_86);\n\t}\n\n\tNVWriteCRTC(dev, head, NV_PCRTC_START, regp->fb_start);\n}\n\nstatic void\nnv_save_state_palette(struct drm_device *dev, int head,\n\t\t      struct nv04_mode_state *state)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tint head_offset = head * NV_PRMDIO_SIZE, i;\n\n\tnvif_wr08(device, NV_PRMDIO_PIXEL_MASK + head_offset,\n\t\t\t\tNV_PRMDIO_PIXEL_MASK_MASK);\n\tnvif_wr08(device, NV_PRMDIO_READ_MODE_ADDRESS + head_offset, 0x0);\n\n\tfor (i = 0; i < 768; i++) {\n\t\tstate->crtc_reg[head].DAC[i] = nvif_rd08(device,\n\t\t\t\tNV_PRMDIO_PALETTE_DATA + head_offset);\n\t}\n\n\tNVSetEnablePalette(dev, head, false);\n}\n\nvoid\nnouveau_hw_load_state_palette(struct drm_device *dev, int head,\n\t\t\t      struct nv04_mode_state *state)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tint head_offset = head * NV_PRMDIO_SIZE, i;\n\n\tnvif_wr08(device, NV_PRMDIO_PIXEL_MASK + head_offset,\n\t\t\t\tNV_PRMDIO_PIXEL_MASK_MASK);\n\tnvif_wr08(device, NV_PRMDIO_WRITE_MODE_ADDRESS + head_offset, 0x0);\n\n\tfor (i = 0; i < 768; i++) {\n\t\tnvif_wr08(device, NV_PRMDIO_PALETTE_DATA + head_offset,\n\t\t\t\tstate->crtc_reg[head].DAC[i]);\n\t}\n\n\tNVSetEnablePalette(dev, head, false);\n}\n\nvoid nouveau_hw_save_state(struct drm_device *dev, int head,\n\t\t\t   struct nv04_mode_state *state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (drm->client.device.info.chipset == 0x11)\n\t\t \n\t\tnouveau_hw_fix_bad_vpll(dev, head);\n\tnv_save_state_ramdac(dev, head, state);\n\tnv_save_state_vga(dev, head, state);\n\tnv_save_state_palette(dev, head, state);\n\tnv_save_state_ext(dev, head, state);\n}\n\nvoid nouveau_hw_load_state(struct drm_device *dev, int head,\n\t\t\t   struct nv04_mode_state *state)\n{\n\tNVVgaProtect(dev, head, true);\n\tnv_load_state_ramdac(dev, head, state);\n\tnv_load_state_ext(dev, head, state);\n\tnouveau_hw_load_state_palette(dev, head, state);\n\tnv_load_state_vga(dev, head, state);\n\tNVVgaProtect(dev, head, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}