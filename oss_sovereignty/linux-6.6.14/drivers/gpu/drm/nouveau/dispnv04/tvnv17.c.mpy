{
  "module_name": "tvnv17.c",
  "hash_id": "50c6c728794409077f31d4f823f1ccd248f3fb57a8eaa0ae6540e3046647f43d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c",
  "human_readable_source": " \n\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_probe_helper.h>\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_crtc.h\"\n#include \"hw.h\"\n#include \"tvnv17.h\"\n\nMODULE_PARM_DESC(tv_norm, \"Default TV norm.\\n\"\n\t\t \"\\t\\tSupported: PAL, PAL-M, PAL-N, PAL-Nc, NTSC-M, NTSC-J,\\n\"\n\t\t \"\\t\\t\\thd480i, hd480p, hd576i, hd576p, hd720p, hd1080i.\\n\"\n\t\t \"\\t\\tDefault: PAL\\n\"\n\t\t \"\\t\\t*NOTE* Ignored for cards with external TV encoders.\");\nstatic char *nouveau_tv_norm;\nmodule_param_named(tv_norm, nouveau_tv_norm, charp, 0400);\n\nstatic uint32_t nv42_tv_sample_load(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_gpio *gpio = nvxx_gpio(&drm->client.device);\n\tuint32_t testval, regoffset = nv04_dac_output_offset(encoder);\n\tuint32_t gpio0, gpio1, fp_htotal, fp_hsync_start, fp_hsync_end,\n\t\tfp_control, test_ctrl, dacclk, ctv_14, ctv_1c, ctv_6c;\n\tuint32_t sample = 0;\n\tint head;\n\n#define RGB_TEST_DATA(r, g, b) (r << 0 | g << 10 | b << 20)\n\ttestval = RGB_TEST_DATA(0x82, 0xeb, 0x82);\n\tif (drm->vbios.tvdactestval)\n\t\ttestval = drm->vbios.tvdactestval;\n\n\tdacclk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);\n\thead = (dacclk & 0x100) >> 8;\n\n\t \n\tgpio1 = nvkm_gpio_get(gpio, 0, DCB_GPIO_TVDAC1, 0xff);\n\tgpio0 = nvkm_gpio_get(gpio, 0, DCB_GPIO_TVDAC0, 0xff);\n\tfp_htotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_HTOTAL);\n\tfp_hsync_start = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_START);\n\tfp_hsync_end = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_END);\n\tfp_control = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\n\ttest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);\n\tctv_1c = NVReadRAMDAC(dev, head, 0x680c1c);\n\tctv_14 = NVReadRAMDAC(dev, head, 0x680c14);\n\tctv_6c = NVReadRAMDAC(dev, head, 0x680c6c);\n\n\t \n\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC1, 0xff, true);\n\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC0, 0xff, true);\n\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HTOTAL, 1343);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_START, 1047);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_END, 1183);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL,\n\t\t      NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\n\t\t      NV_PRAMDAC_FP_TG_CONTROL_WIDTH_12 |\n\t\t      NV_PRAMDAC_FP_TG_CONTROL_READ_PROG |\n\t\t      NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS |\n\t\t      NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS);\n\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset, 0);\n\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset,\n\t\t      (dacclk & ~0xff) | 0x22);\n\tmsleep(1);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset,\n\t\t      (dacclk & ~0xff) | 0x21);\n\n\tNVWriteRAMDAC(dev, head, 0x680c1c, 1 << 20);\n\tNVWriteRAMDAC(dev, head, 0x680c14, 4 << 16);\n\n\t \n\tNVWriteRAMDAC(dev, head, 0x680c6c, testval >> 10 & 0x3ff);\n\tmsleep(20);\n\tsample |= NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset)\n\t\t& 0x4 << 28;\n\n\t \n\tNVWriteRAMDAC(dev, head, 0x680c6c, testval & 0x3ff);\n\tmsleep(20);\n\tsample |= NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset)\n\t\t& 0xa << 28;\n\n\t \n\tNVWriteRAMDAC(dev, head, 0x680c1c, ctv_1c);\n\tNVWriteRAMDAC(dev, head, 0x680c14, ctv_14);\n\tNVWriteRAMDAC(dev, head, 0x680c6c, ctv_6c);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, dacclk);\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset, test_ctrl);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL, fp_control);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_END, fp_hsync_end);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HSYNC_START, fp_hsync_start);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_HTOTAL, fp_htotal);\n\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC1, 0xff, gpio1);\n\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC0, 0xff, gpio0);\n\n\treturn sample;\n}\n\nstatic bool\nget_tv_detect_quirks(struct drm_device *dev, uint32_t *pin_mask)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_device *device = nvxx_device(&drm->client.device);\n\n\tif (device->quirk && device->quirk->tv_pin_mask) {\n\t\t*pin_mask = device->quirk->tv_pin_mask;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic enum drm_connector_status\nnv17_tv_detect(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_mode_config *conf = &dev->mode_config;\n\tstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\n\tstruct dcb_output *dcb = tv_enc->base.dcb;\n\tbool reliable = get_tv_detect_quirks(dev, &tv_enc->pin_mask);\n\n\tif (nv04_dac_in_use(encoder))\n\t\treturn connector_status_disconnected;\n\n\tif (reliable) {\n\t\tif (drm->client.device.info.chipset == 0x42 ||\n\t\t    drm->client.device.info.chipset == 0x43)\n\t\t\ttv_enc->pin_mask =\n\t\t\t\tnv42_tv_sample_load(encoder) >> 28 & 0xe;\n\t\telse\n\t\t\ttv_enc->pin_mask =\n\t\t\t\tnv17_dac_sample_load(encoder) >> 28 & 0xe;\n\t}\n\n\tswitch (tv_enc->pin_mask) {\n\tcase 0x2:\n\tcase 0x4:\n\t\ttv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Composite;\n\t\tbreak;\n\tcase 0xc:\n\t\ttv_enc->subconnector = DRM_MODE_SUBCONNECTOR_SVIDEO;\n\t\tbreak;\n\tcase 0xe:\n\t\tif (dcb->tvconf.has_component_output)\n\t\t\ttv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Component;\n\t\telse\n\t\t\ttv_enc->subconnector = DRM_MODE_SUBCONNECTOR_SCART;\n\t\tbreak;\n\tdefault:\n\t\ttv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\n\t\tbreak;\n\t}\n\n\tdrm_object_property_set_value(&connector->base,\n\t\t\t\t\t conf->tv_subconnector_property,\n\t\t\t\t\t tv_enc->subconnector);\n\n\tif (!reliable) {\n\t\treturn connector_status_unknown;\n\t} else if (tv_enc->subconnector) {\n\t\tNV_INFO(drm, \"Load detected on output %c\\n\",\n\t\t\t'@' + ffs(dcb->or));\n\t\treturn connector_status_connected;\n\t} else {\n\t\treturn connector_status_disconnected;\n\t}\n}\n\nstatic int nv17_tv_get_ld_modes(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tconst struct drm_display_mode *tv_mode;\n\tint n = 0;\n\n\tfor (tv_mode = nv17_tv_modes; tv_mode->hdisplay; tv_mode++) {\n\t\tstruct drm_display_mode *mode;\n\n\t\tmode = drm_mode_duplicate(encoder->dev, tv_mode);\n\n\t\tmode->clock = tv_norm->tv_enc_mode.vrefresh *\n\t\t\tmode->htotal / 1000 *\n\t\t\tmode->vtotal / 1000;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\t\tmode->clock *= 2;\n\n\t\tif (mode->hdisplay == tv_norm->tv_enc_mode.hdisplay &&\n\t\t    mode->vdisplay == tv_norm->tv_enc_mode.vdisplay)\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tn++;\n\t}\n\n\treturn n;\n}\n\nstatic int nv17_tv_get_hd_modes(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_connector *connector)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tstruct drm_display_mode *output_mode = &tv_norm->ctv_enc_mode.mode;\n\tstruct drm_display_mode *mode;\n\tconst struct {\n\t\tint hdisplay;\n\t\tint vdisplay;\n\t} modes[] = {\n\t\t{ 640, 400 },\n\t\t{ 640, 480 },\n\t\t{ 720, 480 },\n\t\t{ 720, 576 },\n\t\t{ 800, 600 },\n\t\t{ 1024, 768 },\n\t\t{ 1280, 720 },\n\t\t{ 1280, 1024 },\n\t\t{ 1920, 1080 }\n\t};\n\tint i, n = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(modes); i++) {\n\t\tif (modes[i].hdisplay > output_mode->hdisplay ||\n\t\t    modes[i].vdisplay > output_mode->vdisplay)\n\t\t\tcontinue;\n\n\t\tif (modes[i].hdisplay == output_mode->hdisplay &&\n\t\t    modes[i].vdisplay == output_mode->vdisplay) {\n\t\t\tmode = drm_mode_duplicate(encoder->dev, output_mode);\n\t\t\tmode->type |= DRM_MODE_TYPE_PREFERRED;\n\n\t\t} else {\n\t\t\tmode = drm_cvt_mode(encoder->dev, modes[i].hdisplay,\n\t\t\t\t\t    modes[i].vdisplay, 60, false,\n\t\t\t\t\t    (output_mode->flags &\n\t\t\t\t\t     DRM_MODE_FLAG_INTERLACE), false);\n\t\t}\n\n\t\t \n\t\tif (output_mode->hdisplay <= 720\n\t\t    || output_mode->hdisplay >= 1920) {\n\t\t\tmode->htotal = output_mode->htotal;\n\t\t\tmode->hsync_start = (mode->hdisplay + (mode->htotal\n\t\t\t\t\t     - mode->hdisplay) * 9 / 10) & ~7;\n\t\t\tmode->hsync_end = mode->hsync_start + 8;\n\t\t}\n\n\t\tif (output_mode->vdisplay >= 1024) {\n\t\t\tmode->vtotal = output_mode->vtotal;\n\t\t\tmode->vsync_start = output_mode->vsync_start;\n\t\t\tmode->vsync_end = output_mode->vsync_end;\n\t\t}\n\n\t\tmode->type |= DRM_MODE_TYPE_DRIVER;\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tn++;\n\t}\n\n\treturn n;\n}\n\nstatic int nv17_tv_get_modes(struct drm_encoder *encoder,\n\t\t\t     struct drm_connector *connector)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\n\tif (tv_norm->kind == CTV_ENC_MODE)\n\t\treturn nv17_tv_get_hd_modes(encoder, connector);\n\telse\n\t\treturn nv17_tv_get_ld_modes(encoder, connector);\n}\n\nstatic int nv17_tv_mode_valid(struct drm_encoder *encoder,\n\t\t\t      struct drm_display_mode *mode)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\n\tif (tv_norm->kind == CTV_ENC_MODE) {\n\t\tstruct drm_display_mode *output_mode =\n\t\t\t\t\t\t&tv_norm->ctv_enc_mode.mode;\n\n\t\tif (mode->clock > 400000)\n\t\t\treturn MODE_CLOCK_HIGH;\n\n\t\tif (mode->hdisplay > output_mode->hdisplay ||\n\t\t    mode->vdisplay > output_mode->vdisplay)\n\t\t\treturn MODE_BAD;\n\n\t\tif ((mode->flags & DRM_MODE_FLAG_INTERLACE) !=\n\t\t    (output_mode->flags & DRM_MODE_FLAG_INTERLACE))\n\t\t\treturn MODE_NO_INTERLACE;\n\n\t\tif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\n\t\t\treturn MODE_NO_DBLESCAN;\n\n\t} else {\n\t\tconst int vsync_tolerance = 600;\n\n\t\tif (mode->clock > 70000)\n\t\t\treturn MODE_CLOCK_HIGH;\n\n\t\tif (abs(drm_mode_vrefresh(mode) * 1000 -\n\t\t\ttv_norm->tv_enc_mode.vrefresh) > vsync_tolerance)\n\t\t\treturn MODE_VSYNC;\n\n\t\t \n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\treturn MODE_NO_INTERLACE;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic bool nv17_tv_mode_fixup(struct drm_encoder *encoder,\n\t\t\t       const struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\n\tif (nv04_dac_in_use(encoder))\n\t\treturn false;\n\n\tif (tv_norm->kind == CTV_ENC_MODE)\n\t\tadjusted_mode->clock = tv_norm->ctv_enc_mode.mode.clock;\n\telse\n\t\tadjusted_mode->clock = 90000;\n\n\treturn true;\n}\n\nstatic void  nv17_tv_dpms(struct drm_encoder *encoder, int mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_gpio *gpio = nvxx_gpio(&drm->client.device);\n\tstruct nv17_tv_state *regs = &to_tv_enc(encoder)->state;\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\n\tif (nouveau_encoder(encoder)->last_dpms == mode)\n\t\treturn;\n\tnouveau_encoder(encoder)->last_dpms = mode;\n\n\tNV_INFO(drm, \"Setting dpms mode %d on TV encoder (output %d)\\n\",\n\t\t mode, nouveau_encoder(encoder)->dcb->index);\n\n\tregs->ptv_200 &= ~1;\n\n\tif (tv_norm->kind == CTV_ENC_MODE) {\n\t\tnv04_dfp_update_fp_control(encoder, mode);\n\n\t} else {\n\t\tnv04_dfp_update_fp_control(encoder, DRM_MODE_DPMS_OFF);\n\n\t\tif (mode == DRM_MODE_DPMS_ON)\n\t\t\tregs->ptv_200 |= 1;\n\t}\n\n\tnv_load_ptv(dev, regs, 200);\n\n\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC1, 0xff, mode == DRM_MODE_DPMS_ON);\n\tnvkm_gpio_set(gpio, 0, DCB_GPIO_TVDAC0, 0xff, mode == DRM_MODE_DPMS_ON);\n\n\tnv04_dac_update_dacclk(encoder, mode == DRM_MODE_DPMS_ON);\n}\n\nstatic void nv17_tv_prepare(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\tuint8_t *cr_lcd = &nv04_display(dev)->mode_reg.crtc_reg[head].CRTC[\n\t\t\t\t\t\t\tNV_CIO_CRE_LCD__INDEX];\n\tuint32_t dacclk_off = NV_PRAMDAC_DACCLK +\n\t\t\t\t\tnv04_dac_output_offset(encoder);\n\tuint32_t dacclk;\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_OFF);\n\n\tnv04_dfp_disable(dev, head);\n\n\t \n\tif (tv_norm->kind == CTV_ENC_MODE) {\n\t\tstruct drm_encoder *enc;\n\n\t\tlist_for_each_entry(enc, &dev->mode_config.encoder_list, head) {\n\t\t\tstruct dcb_output *dcb = nouveau_encoder(enc)->dcb;\n\n\t\t\tif ((dcb->type == DCB_OUTPUT_TMDS ||\n\t\t\t     dcb->type == DCB_OUTPUT_LVDS) &&\n\t\t\t     !enc->crtc &&\n\t\t\t     nv04_dfp_get_bound_head(dev, dcb) == head) {\n\t\t\t\tnv04_dfp_bind_head(dev, dcb, head ^ 1,\n\t\t\t\t\t\tdrm->vbios.fp.dual_link);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (tv_norm->kind == CTV_ENC_MODE)\n\t\t*cr_lcd |= 0x1 | (head ? 0x0 : 0x8);\n\n\t \n\tdacclk = (NVReadRAMDAC(dev, 0, dacclk_off) & ~0x30) | 0x1;\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\tdacclk |= 0x1a << 16;\n\n\tif (tv_norm->kind == CTV_ENC_MODE) {\n\t\tdacclk |=  0x20;\n\n\t\tif (head)\n\t\t\tdacclk |= 0x100;\n\t\telse\n\t\t\tdacclk &= ~0x100;\n\n\t} else {\n\t\tdacclk |= 0x10;\n\n\t}\n\n\tNVWriteRAMDAC(dev, 0, dacclk_off, dacclk);\n}\n\nstatic void nv17_tv_mode_set(struct drm_encoder *encoder,\n\t\t\t     struct drm_display_mode *drm_mode,\n\t\t\t     struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint head = nouveau_crtc(encoder->crtc)->index;\n\tstruct nv04_crtc_reg *regs = &nv04_display(dev)->mode_reg.crtc_reg[head];\n\tstruct nv17_tv_state *tv_regs = &to_tv_enc(encoder)->state;\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tint i;\n\n\tregs->CRTC[NV_CIO_CRE_53] = 0x40;  \n\tregs->CRTC[NV_CIO_CRE_54] = 0;  \n\tregs->ramdac_630 = 0x2;  \n\tregs->tv_setup = 1;\n\tregs->ramdac_8c0 = 0x0;\n\n\tif (tv_norm->kind == TV_ENC_MODE) {\n\t\ttv_regs->ptv_200 = 0x13111100;\n\t\tif (head)\n\t\t\ttv_regs->ptv_200 |= 0x10;\n\n\t\ttv_regs->ptv_20c = 0x808010;\n\t\ttv_regs->ptv_304 = 0x2d00000;\n\t\ttv_regs->ptv_600 = 0x0;\n\t\ttv_regs->ptv_60c = 0x0;\n\t\ttv_regs->ptv_610 = 0x1e00000;\n\n\t\tif (tv_norm->tv_enc_mode.vdisplay == 576) {\n\t\t\ttv_regs->ptv_508 = 0x1200000;\n\t\t\ttv_regs->ptv_614 = 0x33;\n\n\t\t} else if (tv_norm->tv_enc_mode.vdisplay == 480) {\n\t\t\ttv_regs->ptv_508 = 0xf00000;\n\t\t\ttv_regs->ptv_614 = 0x13;\n\t\t}\n\n\t\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_RANKINE) {\n\t\t\ttv_regs->ptv_500 = 0xe8e0;\n\t\t\ttv_regs->ptv_504 = 0x1710;\n\t\t\ttv_regs->ptv_604 = 0x0;\n\t\t\ttv_regs->ptv_608 = 0x0;\n\t\t} else {\n\t\t\tif (tv_norm->tv_enc_mode.vdisplay == 576) {\n\t\t\t\ttv_regs->ptv_604 = 0x20;\n\t\t\t\ttv_regs->ptv_608 = 0x10;\n\t\t\t\ttv_regs->ptv_500 = 0x19710;\n\t\t\t\ttv_regs->ptv_504 = 0x68f0;\n\n\t\t\t} else if (tv_norm->tv_enc_mode.vdisplay == 480) {\n\t\t\t\ttv_regs->ptv_604 = 0x10;\n\t\t\t\ttv_regs->ptv_608 = 0x20;\n\t\t\t\ttv_regs->ptv_500 = 0x4b90;\n\t\t\t\ttv_regs->ptv_504 = 0x1b480;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < 0x40; i++)\n\t\t\ttv_regs->tv_enc[i] = tv_norm->tv_enc_mode.tv_enc[i];\n\n\t} else {\n\t\tstruct drm_display_mode *output_mode =\n\t\t\t\t\t\t&tv_norm->ctv_enc_mode.mode;\n\n\t\t \n\t\tfor (i = 0; i < 38; i++)\n\t\t\tregs->ctv_regs[i] = tv_norm->ctv_enc_mode.ctv_regs[i];\n\n\t\tregs->fp_horiz_regs[FP_DISPLAY_END] = output_mode->hdisplay - 1;\n\t\tregs->fp_horiz_regs[FP_TOTAL] = output_mode->htotal - 1;\n\t\tregs->fp_horiz_regs[FP_SYNC_START] =\n\t\t\t\t\t\toutput_mode->hsync_start - 1;\n\t\tregs->fp_horiz_regs[FP_SYNC_END] = output_mode->hsync_end - 1;\n\t\tregs->fp_horiz_regs[FP_CRTC] = output_mode->hdisplay +\n\t\t\tmax((output_mode->hdisplay-600)/40 - 1, 1);\n\n\t\tregs->fp_vert_regs[FP_DISPLAY_END] = output_mode->vdisplay - 1;\n\t\tregs->fp_vert_regs[FP_TOTAL] = output_mode->vtotal - 1;\n\t\tregs->fp_vert_regs[FP_SYNC_START] =\n\t\t\t\t\t\toutput_mode->vsync_start - 1;\n\t\tregs->fp_vert_regs[FP_SYNC_END] = output_mode->vsync_end - 1;\n\t\tregs->fp_vert_regs[FP_CRTC] = output_mode->vdisplay - 1;\n\n\t\tregs->fp_control = NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |\n\t\t\tNV_PRAMDAC_FP_TG_CONTROL_READ_PROG |\n\t\t\tNV_PRAMDAC_FP_TG_CONTROL_WIDTH_12;\n\n\t\tif (output_mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\t\tregs->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS;\n\t\tif (output_mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\t\tregs->fp_control |= NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS;\n\n\t\tregs->fp_debug_0 = NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_ROUND |\n\t\t\tNV_PRAMDAC_FP_DEBUG_0_XWEIGHT_ROUND |\n\t\t\tNV_PRAMDAC_FP_DEBUG_0_YINTERP_BILINEAR |\n\t\t\tNV_PRAMDAC_FP_DEBUG_0_XINTERP_BILINEAR |\n\t\t\tNV_RAMDAC_FP_DEBUG_0_TMDS_ENABLED |\n\t\t\tNV_PRAMDAC_FP_DEBUG_0_YSCALE_ENABLE |\n\t\t\tNV_PRAMDAC_FP_DEBUG_0_XSCALE_ENABLE;\n\n\t\tregs->fp_debug_2 = 0;\n\n\t\tregs->fp_margin_color = 0x801080;\n\n\t}\n}\n\nstatic void nv17_tv_commit(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tconst struct drm_encoder_helper_funcs *helper = encoder->helper_private;\n\n\tif (get_tv_norm(encoder)->kind == TV_ENC_MODE) {\n\t\tnv17_tv_update_rescaler(encoder);\n\t\tnv17_tv_update_properties(encoder);\n\t} else {\n\t\tnv17_ctv_update_rescaler(encoder);\n\t}\n\n\tnv17_tv_state_load(dev, &to_tv_enc(encoder)->state);\n\n\t \n\tif (drm->client.device.info.chipset < 0x44)\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL +\n\t\t\t\t\tnv04_dac_output_offset(encoder),\n\t\t\t\t\t0xf0000000);\n\telse\n\t\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL +\n\t\t\t\t\tnv04_dac_output_offset(encoder),\n\t\t\t\t\t0x00100000);\n\n\thelper->dpms(encoder, DRM_MODE_DPMS_ON);\n\n\tNV_INFO(drm, \"Output %s is running on CRTC %d using output %c\\n\",\n\t\tnv04_encoder_get_connector(nv_encoder)->base.name,\n\t\tnv_crtc->index, '@' + ffs(nv_encoder->dcb->or));\n}\n\nstatic void nv17_tv_save(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\n\n\tnouveau_encoder(encoder)->restore.output =\n\t\t\t\t\tNVReadRAMDAC(dev, 0,\n\t\t\t\t\tNV_PRAMDAC_DACCLK +\n\t\t\t\t\tnv04_dac_output_offset(encoder));\n\n\tnv17_tv_state_save(dev, &tv_enc->saved_state);\n\n\ttv_enc->state.ptv_200 = tv_enc->saved_state.ptv_200;\n}\n\nstatic void nv17_tv_restore(struct drm_encoder *encoder)\n{\n\tstruct drm_device *dev = encoder->dev;\n\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK +\n\t\t\t\tnv04_dac_output_offset(encoder),\n\t\t\t\tnouveau_encoder(encoder)->restore.output);\n\n\tnv17_tv_state_load(dev, &to_tv_enc(encoder)->saved_state);\n\n\tnouveau_encoder(encoder)->last_dpms = NV_DPMS_CLEARED;\n}\n\nstatic int nv17_tv_create_resources(struct drm_encoder *encoder,\n\t\t\t\t    struct drm_connector *connector)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_mode_config *conf = &dev->mode_config;\n\tstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\n\tstruct dcb_output *dcb = nouveau_encoder(encoder)->dcb;\n\tint num_tv_norms = dcb->tvconf.has_component_output ? NUM_TV_NORMS :\n\t\t\t\t\t\t\tNUM_LD_TV_NORMS;\n\tint i;\n\n\tif (nouveau_tv_norm) {\n\t\ti = match_string(nv17_tv_norm_names, num_tv_norms,\n\t\t\t\t nouveau_tv_norm);\n\t\tif (i < 0)\n\t\t\tNV_WARN(drm, \"Invalid TV norm setting \\\"%s\\\"\\n\",\n\t\t\t\tnouveau_tv_norm);\n\t\telse\n\t\t\ttv_enc->tv_norm = i;\n\t}\n\n\tdrm_mode_create_tv_properties_legacy(dev, num_tv_norms, nv17_tv_norm_names);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->tv_select_subconnector_property,\n\t\t\t\t\ttv_enc->select_subconnector);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->tv_subconnector_property,\n\t\t\t\t\ttv_enc->subconnector);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->legacy_tv_mode_property,\n\t\t\t\t\ttv_enc->tv_norm);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->tv_flicker_reduction_property,\n\t\t\t\t\ttv_enc->flicker);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->tv_saturation_property,\n\t\t\t\t\ttv_enc->saturation);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->tv_hue_property,\n\t\t\t\t\ttv_enc->hue);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t\tconf->tv_overscan_property,\n\t\t\t\t\ttv_enc->overscan);\n\n\treturn 0;\n}\n\nstatic int nv17_tv_set_property(struct drm_encoder *encoder,\n\t\t\t\tstruct drm_connector *connector,\n\t\t\t\tstruct drm_property *property,\n\t\t\t\tuint64_t val)\n{\n\tstruct drm_mode_config *conf = &encoder->dev->mode_config;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\n\tstruct nv17_tv_norm_params *tv_norm = get_tv_norm(encoder);\n\tbool modes_changed = false;\n\n\tif (property == conf->tv_overscan_property) {\n\t\ttv_enc->overscan = val;\n\t\tif (encoder->crtc) {\n\t\t\tif (tv_norm->kind == CTV_ENC_MODE)\n\t\t\t\tnv17_ctv_update_rescaler(encoder);\n\t\t\telse\n\t\t\t\tnv17_tv_update_rescaler(encoder);\n\t\t}\n\n\t} else if (property == conf->tv_saturation_property) {\n\t\tif (tv_norm->kind != TV_ENC_MODE)\n\t\t\treturn -EINVAL;\n\n\t\ttv_enc->saturation = val;\n\t\tnv17_tv_update_properties(encoder);\n\n\t} else if (property == conf->tv_hue_property) {\n\t\tif (tv_norm->kind != TV_ENC_MODE)\n\t\t\treturn -EINVAL;\n\n\t\ttv_enc->hue = val;\n\t\tnv17_tv_update_properties(encoder);\n\n\t} else if (property == conf->tv_flicker_reduction_property) {\n\t\tif (tv_norm->kind != TV_ENC_MODE)\n\t\t\treturn -EINVAL;\n\n\t\ttv_enc->flicker = val;\n\t\tif (encoder->crtc)\n\t\t\tnv17_tv_update_rescaler(encoder);\n\n\t} else if (property == conf->legacy_tv_mode_property) {\n\t\tif (connector->dpms != DRM_MODE_DPMS_OFF)\n\t\t\treturn -EINVAL;\n\n\t\ttv_enc->tv_norm = val;\n\n\t\tmodes_changed = true;\n\n\t} else if (property == conf->tv_select_subconnector_property) {\n\t\tif (tv_norm->kind != TV_ENC_MODE)\n\t\t\treturn -EINVAL;\n\n\t\ttv_enc->select_subconnector = val;\n\t\tnv17_tv_update_properties(encoder);\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (modes_changed) {\n\t\tdrm_helper_probe_single_connector_modes(connector, 0, 0);\n\n\t\t \n\t\tif (crtc)\n\t\t\tdrm_crtc_helper_set_mode(crtc, &crtc->mode,\n\t\t\t\t\t\t crtc->x, crtc->y,\n\t\t\t\t\t\t crtc->primary->fb);\n\t}\n\n\treturn 0;\n}\n\nstatic void nv17_tv_destroy(struct drm_encoder *encoder)\n{\n\tstruct nv17_tv_encoder *tv_enc = to_tv_enc(encoder);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(tv_enc);\n}\n\nstatic const struct drm_encoder_helper_funcs nv17_tv_helper_funcs = {\n\t.dpms = nv17_tv_dpms,\n\t.mode_fixup = nv17_tv_mode_fixup,\n\t.prepare = nv17_tv_prepare,\n\t.commit = nv17_tv_commit,\n\t.mode_set = nv17_tv_mode_set,\n\t.detect = nv17_tv_detect,\n};\n\nstatic const struct drm_encoder_slave_funcs nv17_tv_slave_funcs = {\n\t.get_modes = nv17_tv_get_modes,\n\t.mode_valid = nv17_tv_mode_valid,\n\t.create_resources = nv17_tv_create_resources,\n\t.set_property = nv17_tv_set_property,\n};\n\nstatic const struct drm_encoder_funcs nv17_tv_funcs = {\n\t.destroy = nv17_tv_destroy,\n};\n\nint\nnv17_tv_create(struct drm_connector *connector, struct dcb_output *entry)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_encoder *encoder;\n\tstruct nv17_tv_encoder *tv_enc = NULL;\n\n\ttv_enc = kzalloc(sizeof(*tv_enc), GFP_KERNEL);\n\tif (!tv_enc)\n\t\treturn -ENOMEM;\n\n\ttv_enc->overscan = 50;\n\ttv_enc->flicker = 50;\n\ttv_enc->saturation = 50;\n\ttv_enc->hue = 0;\n\ttv_enc->tv_norm = TV_NORM_PAL;\n\ttv_enc->subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\n\ttv_enc->select_subconnector = DRM_MODE_SUBCONNECTOR_Automatic;\n\ttv_enc->pin_mask = 0;\n\n\tencoder = to_drm_encoder(&tv_enc->base);\n\n\ttv_enc->base.dcb = entry;\n\ttv_enc->base.or = ffs(entry->or) - 1;\n\n\tdrm_encoder_init(dev, encoder, &nv17_tv_funcs, DRM_MODE_ENCODER_TVDAC,\n\t\t\t NULL);\n\tdrm_encoder_helper_add(encoder, &nv17_tv_helper_funcs);\n\tto_encoder_slave(encoder)->slave_funcs = &nv17_tv_slave_funcs;\n\n\ttv_enc->base.enc_save = nv17_tv_save;\n\ttv_enc->base.enc_restore = nv17_tv_restore;\n\n\tencoder->possible_crtcs = entry->heads;\n\tencoder->possible_clones = 0;\n\n\tnv17_tv_create_resources(encoder, connector);\n\tdrm_connector_attach_encoder(connector, encoder);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}