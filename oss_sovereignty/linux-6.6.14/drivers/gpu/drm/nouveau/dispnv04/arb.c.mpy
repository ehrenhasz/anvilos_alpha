{
  "module_name": "arb.c",
  "hash_id": "44123081ddbb6cda362ff336c29d0626ac0aff49c2fe23ae0c5d86ee8937d627",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/arb.c",
  "human_readable_source": " \n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"hw.h\"\n\n \n\nstruct nv_fifo_info {\n\tint lwm;\n\tint burst;\n};\n\nstruct nv_sim_state {\n\tint pclk_khz;\n\tint mclk_khz;\n\tint nvclk_khz;\n\tint bpp;\n\tint mem_page_miss;\n\tint mem_latency;\n\tint memory_type;\n\tint memory_width;\n\tint two_heads;\n};\n\nstatic void\nnv04_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)\n{\n\tint pagemiss, cas, bpp;\n\tint nvclks, mclks, crtpagemiss;\n\tint found, mclk_extra, mclk_loop, cbs, m1, p1;\n\tint mclk_freq, pclk_freq, nvclk_freq;\n\tint us_m, us_n, us_p, crtc_drain_rate;\n\tint cpm_us, us_crt, clwm;\n\n\tpclk_freq = arb->pclk_khz;\n\tmclk_freq = arb->mclk_khz;\n\tnvclk_freq = arb->nvclk_khz;\n\tpagemiss = arb->mem_page_miss;\n\tcas = arb->mem_latency;\n\tbpp = arb->bpp;\n\tcbs = 128;\n\n\tnvclks = 10;\n\tmclks = 13 + cas;\n\tmclk_extra = 3;\n\tfound = 0;\n\n\twhile (!found) {\n\t\tfound = 1;\n\n\t\tmclk_loop = mclks + mclk_extra;\n\t\tus_m = mclk_loop * 1000 * 1000 / mclk_freq;\n\t\tus_n = nvclks * 1000 * 1000 / nvclk_freq;\n\t\tus_p = nvclks * 1000 * 1000 / pclk_freq;\n\n\t\tcrtc_drain_rate = pclk_freq * bpp / 8;\n\t\tcrtpagemiss = 2;\n\t\tcrtpagemiss += 1;\n\t\tcpm_us = crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\n\t\tus_crt = cpm_us + us_m + us_n + us_p;\n\t\tclwm = us_crt * crtc_drain_rate / (1000 * 1000);\n\t\tclwm++;\n\n\t\tm1 = clwm + cbs - 512;\n\t\tp1 = m1 * pclk_freq / mclk_freq;\n\t\tp1 = p1 * bpp / 8;\n\t\tif ((p1 < m1 && m1 > 0) || clwm > 519) {\n\t\t\tfound = !mclk_extra;\n\t\t\tmclk_extra--;\n\t\t}\n\t\tif (clwm < 384)\n\t\t\tclwm = 384;\n\n\t\tfifo->lwm = clwm;\n\t\tfifo->burst = cbs;\n\t}\n}\n\nstatic void\nnv10_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)\n{\n\tint fill_rate, drain_rate;\n\tint pclks, nvclks, mclks, xclks;\n\tint pclk_freq, nvclk_freq, mclk_freq;\n\tint fill_lat, extra_lat;\n\tint max_burst_o, max_burst_l;\n\tint fifo_len, min_lwm, max_lwm;\n\tconst int burst_lat = 80;  \n\n\tpclk_freq = arb->pclk_khz;\n\tnvclk_freq = arb->nvclk_khz;\n\tmclk_freq = arb->mclk_khz;\n\n\tfill_rate = mclk_freq * arb->memory_width / 8;  \n\tdrain_rate = pclk_freq * arb->bpp / 8;  \n\n\tfifo_len = arb->two_heads ? 1536 : 1024;  \n\n\t \n\n\tpclks = 4;\t \n\n\tnvclks = 3\t \n\t\t+ 2\t \n\t\t+ 1\t \n\t\t+ 1\t \n\t\t+ 1\t \n\t\t+ 1;\t \n\n\tmclks = 1\t \n\t\t+ 1\t \n\t\t+ 5\t \n\t\t+ 2\t \n\t\t+ 2\t \n\t\t+ 7;\t \n\n\t \n\tmclks += (arb->memory_type == 0 ? 2 : 1)\n\t\t* arb->memory_width / 32;\n\n\tfill_lat = mclks * 1000 * 1000 / mclk_freq    \n\t\t+ nvclks * 1000 * 1000 / nvclk_freq   \n\t\t+ pclks * 1000 * 1000 / pclk_freq;    \n\n\t \n\n\txclks = 2 * arb->mem_page_miss + mclks  \n\t\t+ 2 * arb->mem_page_miss        \n\t\t+ (arb->bpp == 32 ? 8 : 4);     \n\n\textra_lat = xclks * 1000 * 1000 / mclk_freq;\n\n\tif (arb->two_heads)\n\t\t \n\t\textra_lat += fill_lat + extra_lat + burst_lat;\n\n\t \n\n\t \n\tmax_burst_o = (1 + fifo_len - extra_lat * drain_rate / (1000 * 1000))\n\t\t* (fill_rate / 1000) / ((fill_rate - drain_rate) / 1000);\n\tfifo->burst = min(max_burst_o, 1024);\n\n\t \n\tmax_burst_l = burst_lat * fill_rate / (1000 * 1000);\n\tfifo->burst = min(max_burst_l, fifo->burst);\n\n\tfifo->burst = rounddown_pow_of_two(fifo->burst);\n\n\t \n\n\tmin_lwm = (fill_lat + extra_lat) * drain_rate / (1000 * 1000) + 1;\n\tmax_lwm = fifo_len - fifo->burst\n\t\t+ fill_lat * drain_rate / (1000 * 1000)\n\t\t+ fifo->burst * drain_rate / fill_rate;\n\n\tfifo->lwm = min_lwm + 10 * (max_lwm - min_lwm) / 100;  \n}\n\nstatic void\nnv04_update_arb(struct drm_device *dev, int VClk, int bpp,\n\t\tint *burst, int *lwm)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nv_fifo_info fifo_data;\n\tstruct nv_sim_state sim_data;\n\tint MClk = nouveau_hw_get_clock(dev, PLL_MEMORY);\n\tint NVClk = nouveau_hw_get_clock(dev, PLL_CORE);\n\tuint32_t cfg1 = nvif_rd32(device, NV04_PFB_CFG1);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tsim_data.pclk_khz = VClk;\n\tsim_data.mclk_khz = MClk;\n\tsim_data.nvclk_khz = NVClk;\n\tsim_data.bpp = bpp;\n\tsim_data.two_heads = nv_two_heads(dev);\n\tif ((pdev->device & 0xffff) == 0x01a0   ||\n\t    (pdev->device & 0xffff) == 0x01f0  ) {\n\t\tuint32_t type;\n\t\tint domain = pci_domain_nr(pdev->bus);\n\n\t\tpci_read_config_dword(pci_get_domain_bus_and_slot(domain, 0, 1),\n\t\t\t\t      0x7c, &type);\n\n\t\tsim_data.memory_type = (type >> 12) & 1;\n\t\tsim_data.memory_width = 64;\n\t\tsim_data.mem_latency = 3;\n\t\tsim_data.mem_page_miss = 10;\n\t} else {\n\t\tsim_data.memory_type = nvif_rd32(device, NV04_PFB_CFG0) & 0x1;\n\t\tsim_data.memory_width = (nvif_rd32(device, NV_PEXTDEV_BOOT_0) & 0x10) ? 128 : 64;\n\t\tsim_data.mem_latency = cfg1 & 0xf;\n\t\tsim_data.mem_page_miss = ((cfg1 >> 4) & 0xf) + ((cfg1 >> 31) & 0x1);\n\t}\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_TNT)\n\t\tnv04_calc_arb(&fifo_data, &sim_data);\n\telse\n\t\tnv10_calc_arb(&fifo_data, &sim_data);\n\n\t*burst = ilog2(fifo_data.burst >> 4);\n\t*lwm = fifo_data.lwm >> 3;\n}\n\nstatic void\nnv20_update_arb(int *burst, int *lwm)\n{\n\tunsigned int fifo_size, burst_size, graphics_lwm;\n\n\tfifo_size = 2048;\n\tburst_size = 512;\n\tgraphics_lwm = fifo_size - burst_size;\n\n\t*burst = ilog2(burst_size >> 5);\n\t*lwm = graphics_lwm >> 3;\n}\n\nvoid\nnouveau_calc_arb(struct drm_device *dev, int vclk, int bpp, int *burst, int *lwm)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_KELVIN)\n\t\tnv04_update_arb(dev, vclk, bpp, burst, lwm);\n\telse if ((pdev->device & 0xfff0) == 0x0240   ||\n\t\t (pdev->device & 0xfff0) == 0x03d0  ) {\n\t\t*burst = 128;\n\t\t*lwm = 0x0480;\n\t} else\n\t\tnv20_update_arb(burst, lwm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}