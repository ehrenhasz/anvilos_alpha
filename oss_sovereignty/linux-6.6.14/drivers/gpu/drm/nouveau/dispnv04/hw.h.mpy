{
  "module_name": "hw.h",
  "hash_id": "e6189b4b875dc59fda5b1363f1a04deeca7e65c4271196a602fbfe8099e15c3f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv04/hw.h",
  "human_readable_source": " \n\n#ifndef __NOUVEAU_HW_H__\n#define __NOUVEAU_HW_H__\n\n#include \"disp.h\"\n#include \"nvreg.h\"\n\n#include <subdev/bios/pll.h>\n\n#define MASK(field) ( \\\n\t(0xffffffff >> (31 - ((1 ? field) - (0 ? field)))) << (0 ? field))\n\n#define XLATE(src, srclowbit, outfield) ( \\\n\t(((src) >> (srclowbit)) << (0 ? outfield)) & MASK(outfield))\n\nvoid NVWriteVgaSeq(struct drm_device *, int head, uint8_t index, uint8_t value);\nuint8_t NVReadVgaSeq(struct drm_device *, int head, uint8_t index);\nvoid NVWriteVgaGr(struct drm_device *, int head, uint8_t index, uint8_t value);\nuint8_t NVReadVgaGr(struct drm_device *, int head, uint8_t index);\nvoid NVSetOwner(struct drm_device *, int owner);\nvoid NVBlankScreen(struct drm_device *, int head, bool blank);\nint nouveau_hw_get_pllvals(struct drm_device *, enum nvbios_pll_type plltype,\n\t\t\t   struct nvkm_pll_vals *pllvals);\nint nouveau_hw_pllvals_to_clk(struct nvkm_pll_vals *pllvals);\nint nouveau_hw_get_clock(struct drm_device *, enum nvbios_pll_type plltype);\nvoid nouveau_hw_save_vga_fonts(struct drm_device *, bool save);\nvoid nouveau_hw_save_state(struct drm_device *, int head,\n\t\t\t   struct nv04_mode_state *state);\nvoid nouveau_hw_load_state(struct drm_device *, int head,\n\t\t\t   struct nv04_mode_state *state);\nvoid nouveau_hw_load_state_palette(struct drm_device *, int head,\n\t\t\t\t   struct nv04_mode_state *state);\n\n \nextern void nouveau_calc_arb(struct drm_device *, int vclk, int bpp,\n\t\t\t     int *burst, int *lwm);\n\nstatic inline uint32_t NVReadCRTC(struct drm_device *dev,\n\t\t\t\t\tint head, uint32_t reg)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tuint32_t val;\n\tif (head)\n\t\treg += NV_PCRTC0_SIZE;\n\tval = nvif_rd32(device, reg);\n\treturn val;\n}\n\nstatic inline void NVWriteCRTC(struct drm_device *dev,\n\t\t\t\t\tint head, uint32_t reg, uint32_t val)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tif (head)\n\t\treg += NV_PCRTC0_SIZE;\n\tnvif_wr32(device, reg, val);\n}\n\nstatic inline uint32_t NVReadRAMDAC(struct drm_device *dev,\n\t\t\t\t\tint head, uint32_t reg)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tuint32_t val;\n\tif (head)\n\t\treg += NV_PRAMDAC0_SIZE;\n\tval = nvif_rd32(device, reg);\n\treturn val;\n}\n\nstatic inline void NVWriteRAMDAC(struct drm_device *dev,\n\t\t\t\t\tint head, uint32_t reg, uint32_t val)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tif (head)\n\t\treg += NV_PRAMDAC0_SIZE;\n\tnvif_wr32(device, reg, val);\n}\n\nstatic inline uint8_t nv_read_tmds(struct drm_device *dev,\n\t\t\t\t\tint or, int dl, uint8_t address)\n{\n\tint ramdac = (or & DCB_OUTPUT_C) >> 2;\n\n\tNVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL + dl * 8,\n\tNV_PRAMDAC_FP_TMDS_CONTROL_WRITE_DISABLE | address);\n\treturn NVReadRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_DATA + dl * 8);\n}\n\nstatic inline void nv_write_tmds(struct drm_device *dev,\n\t\t\t\t\tint or, int dl, uint8_t address,\n\t\t\t\t\tuint8_t data)\n{\n\tint ramdac = (or & DCB_OUTPUT_C) >> 2;\n\n\tNVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_DATA + dl * 8, data);\n\tNVWriteRAMDAC(dev, ramdac, NV_PRAMDAC_FP_TMDS_CONTROL + dl * 8, address);\n}\n\nstatic inline void NVWriteVgaCrtc(struct drm_device *dev,\n\t\t\t\t\tint head, uint8_t index, uint8_t value)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tnvif_wr08(device, NV_PRMCIO_CRX__COLOR + head * NV_PRMCIO_SIZE, index);\n\tnvif_wr08(device, NV_PRMCIO_CR__COLOR + head * NV_PRMCIO_SIZE, value);\n}\n\nstatic inline uint8_t NVReadVgaCrtc(struct drm_device *dev,\n\t\t\t\t\tint head, uint8_t index)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tuint8_t val;\n\tnvif_wr08(device, NV_PRMCIO_CRX__COLOR + head * NV_PRMCIO_SIZE, index);\n\tval = nvif_rd08(device, NV_PRMCIO_CR__COLOR + head * NV_PRMCIO_SIZE);\n\treturn val;\n}\n\n \n\nstatic inline void\nNVWriteVgaCrtc5758(struct drm_device *dev, int head, uint8_t index, uint8_t value)\n{\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_57, index);\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_58, value);\n}\n\nstatic inline uint8_t NVReadVgaCrtc5758(struct drm_device *dev, int head, uint8_t index)\n{\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_57, index);\n\treturn NVReadVgaCrtc(dev, head, NV_CIO_CRE_58);\n}\n\nstatic inline uint8_t NVReadPRMVIO(struct drm_device *dev,\n\t\t\t\t\tint head, uint32_t reg)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint8_t val;\n\n\t \n\tif (head && drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\treg += NV_PRMVIO_SIZE;\n\n\tval = nvif_rd08(device, reg);\n\treturn val;\n}\n\nstatic inline void NVWritePRMVIO(struct drm_device *dev,\n\t\t\t\t\tint head, uint32_t reg, uint8_t value)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\t \n\tif (head && drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\treg += NV_PRMVIO_SIZE;\n\n\tnvif_wr08(device, reg, value);\n}\n\nstatic inline void NVSetEnablePalette(struct drm_device *dev, int head, bool enable)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tnvif_rd08(device, NV_PRMCIO_INP0__COLOR + head * NV_PRMCIO_SIZE);\n\tnvif_wr08(device, NV_PRMCIO_ARX + head * NV_PRMCIO_SIZE, enable ? 0 : 0x20);\n}\n\nstatic inline bool NVGetEnablePalette(struct drm_device *dev, int head)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tnvif_rd08(device, NV_PRMCIO_INP0__COLOR + head * NV_PRMCIO_SIZE);\n\treturn !(nvif_rd08(device, NV_PRMCIO_ARX + head * NV_PRMCIO_SIZE) & 0x20);\n}\n\nstatic inline void NVWriteVgaAttr(struct drm_device *dev,\n\t\t\t\t\tint head, uint8_t index, uint8_t value)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tif (NVGetEnablePalette(dev, head))\n\t\tindex &= ~0x20;\n\telse\n\t\tindex |= 0x20;\n\n\tnvif_rd08(device, NV_PRMCIO_INP0__COLOR + head * NV_PRMCIO_SIZE);\n\tnvif_wr08(device, NV_PRMCIO_ARX + head * NV_PRMCIO_SIZE, index);\n\tnvif_wr08(device, NV_PRMCIO_AR__WRITE + head * NV_PRMCIO_SIZE, value);\n}\n\nstatic inline uint8_t NVReadVgaAttr(struct drm_device *dev,\n\t\t\t\t\tint head, uint8_t index)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tuint8_t val;\n\tif (NVGetEnablePalette(dev, head))\n\t\tindex &= ~0x20;\n\telse\n\t\tindex |= 0x20;\n\n\tnvif_rd08(device, NV_PRMCIO_INP0__COLOR + head * NV_PRMCIO_SIZE);\n\tnvif_wr08(device, NV_PRMCIO_ARX + head * NV_PRMCIO_SIZE, index);\n\tval = nvif_rd08(device, NV_PRMCIO_AR__READ + head * NV_PRMCIO_SIZE);\n\treturn val;\n}\n\nstatic inline void NVVgaSeqReset(struct drm_device *dev, int head, bool start)\n{\n\tNVWriteVgaSeq(dev, head, NV_VIO_SR_RESET_INDEX, start ? 0x1 : 0x3);\n}\n\nstatic inline void NVVgaProtect(struct drm_device *dev, int head, bool protect)\n{\n\tuint8_t seq1 = NVReadVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX);\n\n\tif (protect) {\n\t\tNVVgaSeqReset(dev, head, true);\n\t\tNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 | 0x20);\n\t} else {\n\t\t \n\t\tNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 & ~0x20);    \n\t\tNVVgaSeqReset(dev, head, false);\n\t}\n\tNVSetEnablePalette(dev, head, protect);\n}\n\nstatic inline bool\nnv_heads_tied(struct drm_device *dev)\n{\n\tstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (drm->client.device.info.chipset == 0x11)\n\t\treturn !!(nvif_rd32(device, NV_PBUS_DEBUG_1) & (1 << 28));\n\n\treturn NVReadVgaCrtc(dev, 0, NV_CIO_CRE_44) & 0x4;\n}\n\n \nstatic inline bool\nnv_lock_vga_crtc_base(struct drm_device *dev, int head, bool lock)\n{\n\tuint8_t cr11 = NVReadVgaCrtc(dev, head, NV_CIO_CR_VRE_INDEX);\n\tbool waslocked = cr11 & 0x80;\n\n\tif (lock)\n\t\tcr11 |= 0x80;\n\telse\n\t\tcr11 &= ~0x80;\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CR_VRE_INDEX, cr11);\n\n\treturn waslocked;\n}\n\nstatic inline void\nnv_lock_vga_crtc_shadow(struct drm_device *dev, int head, int lock)\n{\n\t \n\n\tuint8_t cr21 = lock;\n\n\tif (lock < 0)\n\t\t \n\t\tcr21 = NVReadVgaCrtc(dev, head, NV_CIO_CRE_21) | 0xfa;\n\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_21, cr21);\n}\n\n \nstatic inline bool\nNVLockVgaCrtcs(struct drm_device *dev, bool lock)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tbool waslocked = !NVReadVgaCrtc(dev, 0, NV_CIO_SR_LOCK_INDEX);\n\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_SR_LOCK_INDEX,\n\t\t       lock ? NV_CIO_SR_LOCK_VALUE : NV_CIO_SR_UNLOCK_RW_VALUE);\n\t \n\tif (drm->client.device.info.chipset == 0x11 && !nv_heads_tied(dev))\n\t\tNVWriteVgaCrtc(dev, 1, NV_CIO_SR_LOCK_INDEX,\n\t\t\t       lock ? NV_CIO_SR_LOCK_VALUE :\n\t\t\t\t      NV_CIO_SR_UNLOCK_RW_VALUE);\n\n\treturn waslocked;\n}\n\n \n#define NV04_CURSOR_SIZE 32\n \n#define NV10_CURSOR_SIZE 64\n\nstatic inline int nv_cursor_width(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\treturn drm->client.device.info.family >= NV_DEVICE_INFO_V0_CELSIUS ? NV10_CURSOR_SIZE : NV04_CURSOR_SIZE;\n}\n\nstatic inline void\nnv_fix_nv40_hw_cursor(struct drm_device *dev, int head)\n{\n\t \n\tuint32_t curpos = NVReadRAMDAC(dev, head, NV_PRAMDAC_CU_START_POS);\n\tNVWriteRAMDAC(dev, head, NV_PRAMDAC_CU_START_POS, curpos);\n}\n\nstatic inline void\nnv_set_crtc_base(struct drm_device *dev, int head, uint32_t offset)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tNVWriteCRTC(dev, head, NV_PCRTC_START, offset);\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_TNT) {\n\t\t \n\t\tint cre_heb = NVReadVgaCrtc(dev, head, NV_CIO_CRE_HEB__INDEX);\n\n\t\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_HEB__INDEX,\n\t\t\t       (cre_heb & ~0x40) | ((offset >> 18) & 0x40));\n\t}\n}\n\nstatic inline void\nnv_show_cursor(struct drm_device *dev, int head, bool show)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint8_t *curctl1 =\n\t\t&nv04_display(dev)->mode_reg.crtc_reg[head].CRTC[NV_CIO_CRE_HCUR_ADDR1_INDEX];\n\n\tif (show)\n\t\t*curctl1 |= MASK(NV_CIO_CRE_HCUR_ADDR1_ENABLE);\n\telse\n\t\t*curctl1 &= ~MASK(NV_CIO_CRE_HCUR_ADDR1_ENABLE);\n\tNVWriteVgaCrtc(dev, head, NV_CIO_CRE_HCUR_ADDR1_INDEX, *curctl1);\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE)\n\t\tnv_fix_nv40_hw_cursor(dev, head);\n}\n\nstatic inline uint32_t\nnv_pitch_align(struct drm_device *dev, uint32_t width, int bpp)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint mask;\n\n\tif (bpp == 15)\n\t\tbpp = 16;\n\tif (bpp == 24)\n\t\tbpp = 8;\n\n\t \n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_TNT)\n\t\tmask = 128 / bpp - 1;\n\telse\n\t\tmask = 512 / bpp - 1;\n\n\treturn (width + mask) & ~mask;\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}