{
  "module_name": "nouveau_display.c",
  "hash_id": "80c59f03573395efacd36f0ace63fb15a6abe5f9f52fcedea36a41752a91fc4b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_display.c",
  "human_readable_source": " \n\n#include <acpi/video.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc_helper.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"nouveau_crtc.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_connector.h\"\n#include \"nv50_display.h\"\n\n#include <nvif/class.h>\n#include <nvif/if0011.h>\n#include <nvif/if0013.h>\n#include <dispnv50/crc.h>\n\nint\nnouveau_display_vblank_enable(struct drm_crtc *crtc)\n{\n\tstruct nouveau_crtc *nv_crtc;\n\n\tnv_crtc = nouveau_crtc(crtc);\n\tnvif_event_allow(&nv_crtc->vblank);\n\n\treturn 0;\n}\n\nvoid\nnouveau_display_vblank_disable(struct drm_crtc *crtc)\n{\n\tstruct nouveau_crtc *nv_crtc;\n\n\tnv_crtc = nouveau_crtc(crtc);\n\tnvif_event_block(&nv_crtc->vblank);\n}\n\nstatic inline int\ncalc(int blanks, int blanke, int total, int line)\n{\n\tif (blanke >= blanks) {\n\t\tif (line >= blanks)\n\t\t\tline -= total;\n\t} else {\n\t\tif (line >= blanks)\n\t\t\tline -= total;\n\t\tline -= blanke + 1;\n\t}\n\treturn line;\n}\n\nstatic bool\nnouveau_display_scanoutpos_head(struct drm_crtc *crtc, int *vpos, int *hpos,\n\t\t\t\tktime_t *stime, ktime_t *etime)\n{\n\tstruct drm_vblank_crtc *vblank = &crtc->dev->vblank[drm_crtc_index(crtc)];\n\tstruct nvif_head *head = &nouveau_crtc(crtc)->head;\n\tstruct nvif_head_scanoutpos_v0 args;\n\tint retry = 20;\n\tbool ret = false;\n\n\targs.version = 0;\n\n\tdo {\n\t\tret = nvif_mthd(&head->object, NVIF_HEAD_V0_SCANOUTPOS, &args, sizeof(args));\n\t\tif (ret != 0)\n\t\t\treturn false;\n\n\t\tif (args.vline) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (retry) ndelay(vblank->linedur_ns);\n\t} while (retry--);\n\n\t*hpos = args.hline;\n\t*vpos = calc(args.vblanks, args.vblanke, args.vtotal, args.vline);\n\tif (stime) *stime = ns_to_ktime(args.time[0]);\n\tif (etime) *etime = ns_to_ktime(args.time[1]);\n\n\treturn ret;\n}\n\nbool\nnouveau_display_scanoutpos(struct drm_crtc *crtc,\n\t\t\t   bool in_vblank_irq, int *vpos, int *hpos,\n\t\t\t   ktime_t *stime, ktime_t *etime,\n\t\t\t   const struct drm_display_mode *mode)\n{\n\treturn nouveau_display_scanoutpos_head(crtc, vpos, hpos,\n\t\t\t\t\t       stime, etime);\n}\n\nstatic const struct drm_framebuffer_funcs nouveau_framebuffer_funcs = {\n\t.destroy = drm_gem_fb_destroy,\n\t.create_handle = drm_gem_fb_create_handle,\n};\n\nstatic void\nnouveau_decode_mod(struct nouveau_drm *drm,\n\t\t   uint64_t modifier,\n\t\t   uint32_t *tile_mode,\n\t\t   uint8_t *kind)\n{\n\tstruct nouveau_display *disp = nouveau_display(drm->dev);\n\tBUG_ON(!tile_mode || !kind);\n\n\tif (modifier == DRM_FORMAT_MOD_LINEAR) {\n\t\t \n\t\t*tile_mode = 0;\n\t\t*kind = 0;\n\t} else {\n\t\t \n\n\t\tif ((modifier & (0xffull << 12)) == 0ull) {\n\t\t\t \n\t\t\tmodifier |= disp->format_modifiers[0] & (0xffull << 12);\n\t\t}\n\n\t\t*tile_mode = (uint32_t)(modifier & 0xF);\n\t\t*kind = (uint8_t)((modifier >> 12) & 0xFF);\n\n\t\tif (drm->client.device.info.chipset >= 0xc0)\n\t\t\t*tile_mode <<= 4;\n\t}\n}\n\nvoid\nnouveau_framebuffer_get_layout(struct drm_framebuffer *fb,\n\t\t\t       uint32_t *tile_mode,\n\t\t\t       uint8_t *kind)\n{\n\tif (fb->flags & DRM_MODE_FB_MODIFIERS) {\n\t\tstruct nouveau_drm *drm = nouveau_drm(fb->dev);\n\n\t\tnouveau_decode_mod(drm, fb->modifier, tile_mode, kind);\n\t} else {\n\t\tconst struct nouveau_bo *nvbo = nouveau_gem_object(fb->obj[0]);\n\n\t\t*tile_mode = nvbo->mode;\n\t\t*kind = nvbo->kind;\n\t}\n}\n\nstatic const u64 legacy_modifiers[] = {\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(0),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(1),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(2),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(3),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(4),\n\tDRM_FORMAT_MOD_NVIDIA_16BX2_BLOCK(5),\n\tDRM_FORMAT_MOD_INVALID\n};\n\nstatic int\nnouveau_validate_decode_mod(struct nouveau_drm *drm,\n\t\t\t    uint64_t modifier,\n\t\t\t    uint32_t *tile_mode,\n\t\t\t    uint8_t *kind)\n{\n\tstruct nouveau_display *disp = nouveau_display(drm->dev);\n\tint mod;\n\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA) {\n\t\treturn -EINVAL;\n\t}\n\n\tBUG_ON(!disp->format_modifiers);\n\n\tfor (mod = 0;\n\t     (disp->format_modifiers[mod] != DRM_FORMAT_MOD_INVALID) &&\n\t     (disp->format_modifiers[mod] != modifier);\n\t     mod++);\n\n\tif (disp->format_modifiers[mod] == DRM_FORMAT_MOD_INVALID) {\n\t\tfor (mod = 0;\n\t\t     (legacy_modifiers[mod] != DRM_FORMAT_MOD_INVALID) &&\n\t\t     (legacy_modifiers[mod] != modifier);\n\t\t     mod++);\n\t\tif (legacy_modifiers[mod] == DRM_FORMAT_MOD_INVALID)\n\t\t\treturn -EINVAL;\n\t}\n\n\tnouveau_decode_mod(drm, modifier, tile_mode, kind);\n\n\treturn 0;\n}\n\nstatic inline uint32_t\nnouveau_get_width_in_blocks(uint32_t stride)\n{\n\t \n\tstatic const uint32_t log_block_width = 6;\n\n\treturn (stride + (1 << log_block_width) - 1) >> log_block_width;\n}\n\nstatic inline uint32_t\nnouveau_get_height_in_blocks(struct nouveau_drm *drm,\n\t\t\t     uint32_t height,\n\t\t\t     uint32_t log_block_height_in_gobs)\n{\n\tuint32_t log_gob_height;\n\tuint32_t log_block_height;\n\n\tBUG_ON(drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA);\n\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_FERMI)\n\t\tlog_gob_height = 2;\n\telse\n\t\tlog_gob_height = 3;\n\n\tlog_block_height = log_block_height_in_gobs + log_gob_height;\n\n\treturn (height + (1 << log_block_height) - 1) >> log_block_height;\n}\n\nstatic int\nnouveau_check_bl_size(struct nouveau_drm *drm, struct nouveau_bo *nvbo,\n\t\t      uint32_t offset, uint32_t stride, uint32_t h,\n\t\t      uint32_t tile_mode)\n{\n\tuint32_t gob_size, bw, bh;\n\tuint64_t bl_size;\n\n\tBUG_ON(drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA);\n\n\tif (drm->client.device.info.chipset >= 0xc0) {\n\t\tif (tile_mode & 0xF)\n\t\t\treturn -EINVAL;\n\t\ttile_mode >>= 4;\n\t}\n\n\tif (tile_mode & 0xFFFFFFF0)\n\t\treturn -EINVAL;\n\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_FERMI)\n\t\tgob_size = 256;\n\telse\n\t\tgob_size = 512;\n\n\tbw = nouveau_get_width_in_blocks(stride);\n\tbh = nouveau_get_height_in_blocks(drm, h, tile_mode);\n\n\tbl_size = bw * bh * (1 << tile_mode) * gob_size;\n\n\tDRM_DEBUG_KMS(\"offset=%u stride=%u h=%u tile_mode=0x%02x bw=%u bh=%u gob_size=%u bl_size=%llu size=%zu\\n\",\n\t\t      offset, stride, h, tile_mode, bw, bh, gob_size, bl_size,\n\t\t      nvbo->bo.base.size);\n\n\tif (bl_size + offset > nvbo->bo.base.size)\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nint\nnouveau_framebuffer_new(struct drm_device *dev,\n\t\t\tconst struct drm_mode_fb_cmd2 *mode_cmd,\n\t\t\tstruct drm_gem_object *gem,\n\t\t\tstruct drm_framebuffer **pfb)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(gem);\n\tstruct drm_framebuffer *fb;\n\tconst struct drm_format_info *info;\n\tunsigned int height, i;\n\tuint32_t tile_mode;\n\tuint8_t kind;\n\tint ret;\n\n         \n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA &&\n\n\t    (mode_cmd->pixel_format == DRM_FORMAT_YUYV ||\n\t     mode_cmd->pixel_format == DRM_FORMAT_UYVY ||\n\t     mode_cmd->pixel_format == DRM_FORMAT_NV12 ||\n\t     mode_cmd->pixel_format == DRM_FORMAT_NV21) &&\n\t    (mode_cmd->pitches[0] & 0x3f ||  \n\t     mode_cmd->pitches[0] >= 0x10000 ||  \n\t     (mode_cmd->pitches[1] &&  \n\t      mode_cmd->pitches[0] != mode_cmd->pitches[1]))) {\n\t\tDRM_DEBUG_KMS(\"Unsuitable framebuffer: format: %p4cc; pitches: 0x%x\\n 0x%x\\n\",\n\t\t\t      &mode_cmd->pixel_format,\n\t\t\t      mode_cmd->pitches[0], mode_cmd->pitches[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode_cmd->flags & DRM_MODE_FB_MODIFIERS) {\n\t\tif (nouveau_validate_decode_mod(drm, mode_cmd->modifier[0],\n\t\t\t\t\t\t&tile_mode, &kind)) {\n\t\t\tDRM_DEBUG_KMS(\"Unsupported modifier: 0x%llx\\n\",\n\t\t\t\t      mode_cmd->modifier[0]);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttile_mode = nvbo->mode;\n\t\tkind = nvbo->kind;\n\t}\n\n\tinfo = drm_get_format_info(dev, mode_cmd);\n\n\tfor (i = 0; i < info->num_planes; i++) {\n\t\theight = drm_format_info_plane_height(info,\n\t\t\t\t\t\t      mode_cmd->height,\n\t\t\t\t\t\t      i);\n\n\t\tif (kind) {\n\t\t\tret = nouveau_check_bl_size(drm, nvbo,\n\t\t\t\t\t\t    mode_cmd->offsets[i],\n\t\t\t\t\t\t    mode_cmd->pitches[i],\n\t\t\t\t\t\t    height, tile_mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tuint32_t size = mode_cmd->pitches[i] * height;\n\n\t\t\tif (size + mode_cmd->offsets[i] > nvbo->bo.base.size)\n\t\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tif (!(fb = *pfb = kzalloc(sizeof(*fb), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tdrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\n\tfb->obj[0] = gem;\n\n\tret = drm_framebuffer_init(dev, fb, &nouveau_framebuffer_funcs);\n\tif (ret)\n\t\tkfree(fb);\n\treturn ret;\n}\n\nstruct drm_framebuffer *\nnouveau_user_framebuffer_create(struct drm_device *dev,\n\t\t\t\tstruct drm_file *file_priv,\n\t\t\t\tconst struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_framebuffer *fb;\n\tstruct drm_gem_object *gem;\n\tint ret;\n\n\tgem = drm_gem_object_lookup(file_priv, mode_cmd->handles[0]);\n\tif (!gem)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tret = nouveau_framebuffer_new(dev, mode_cmd, gem, &fb);\n\tif (ret == 0)\n\t\treturn fb;\n\n\tdrm_gem_object_put(gem);\n\treturn ERR_PTR(ret);\n}\n\nstatic const struct drm_mode_config_funcs nouveau_mode_config_funcs = {\n\t.fb_create = nouveau_user_framebuffer_create,\n\t.output_poll_changed = drm_fb_helper_output_poll_changed,\n};\n\n\nstruct nouveau_drm_prop_enum_list {\n\tu8 gen_mask;\n\tint type;\n\tchar *name;\n};\n\nstatic struct nouveau_drm_prop_enum_list underscan[] = {\n\t{ 6, UNDERSCAN_AUTO, \"auto\" },\n\t{ 6, UNDERSCAN_OFF, \"off\" },\n\t{ 6, UNDERSCAN_ON, \"on\" },\n\t{}\n};\n\nstatic struct nouveau_drm_prop_enum_list dither_mode[] = {\n\t{ 7, DITHERING_MODE_AUTO, \"auto\" },\n\t{ 7, DITHERING_MODE_OFF, \"off\" },\n\t{ 1, DITHERING_MODE_ON, \"on\" },\n\t{ 6, DITHERING_MODE_STATIC2X2, \"static 2x2\" },\n\t{ 6, DITHERING_MODE_DYNAMIC2X2, \"dynamic 2x2\" },\n\t{ 4, DITHERING_MODE_TEMPORAL, \"temporal\" },\n\t{}\n};\n\nstatic struct nouveau_drm_prop_enum_list dither_depth[] = {\n\t{ 6, DITHERING_DEPTH_AUTO, \"auto\" },\n\t{ 6, DITHERING_DEPTH_6BPC, \"6 bpc\" },\n\t{ 6, DITHERING_DEPTH_8BPC, \"8 bpc\" },\n\t{}\n};\n\n#define PROP_ENUM(p,gen,n,list) do {                                           \\\n\tstruct nouveau_drm_prop_enum_list *l = (list);                         \\\n\tint c = 0;                                                             \\\n\twhile (l->gen_mask) {                                                  \\\n\t\tif (l->gen_mask & (1 << (gen)))                                \\\n\t\t\tc++;                                                   \\\n\t\tl++;                                                           \\\n\t}                                                                      \\\n\tif (c) {                                                               \\\n\t\tp = drm_property_create(dev, DRM_MODE_PROP_ENUM, n, c);        \\\n\t\tl = (list);                                                    \\\n\t\twhile (p && l->gen_mask) {                                     \\\n\t\t\tif (l->gen_mask & (1 << (gen))) {                      \\\n\t\t\t\tdrm_property_add_enum(p, l->type, l->name);    \\\n\t\t\t}                                                      \\\n\t\t\tl++;                                                   \\\n\t\t}                                                              \\\n\t}                                                                      \\\n} while(0)\n\nvoid\nnouveau_display_hpd_resume(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tspin_lock_irq(&drm->hpd_lock);\n\tdrm->hpd_pending = ~0;\n\tspin_unlock_irq(&drm->hpd_lock);\n\n\tschedule_work(&drm->hpd_work);\n}\n\nstatic void\nnouveau_display_hpd_work(struct work_struct *work)\n{\n\tstruct nouveau_drm *drm = container_of(work, typeof(*drm), hpd_work);\n\tstruct drm_device *dev = drm->dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tu32 pending;\n\tint changed = 0;\n\tstruct drm_connector *first_changed_connector = NULL;\n\n\tpm_runtime_get_sync(dev->dev);\n\n\tspin_lock_irq(&drm->hpd_lock);\n\tpending = drm->hpd_pending;\n\tdrm->hpd_pending = 0;\n\tspin_unlock_irq(&drm->hpd_lock);\n\n\t \n\tif (!pending)\n\t\tgoto noop;\n\n\tmutex_lock(&dev->mode_config.mutex);\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\n\tnouveau_for_each_non_mst_connector_iter(connector, &conn_iter) {\n\t\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\t\tenum drm_connector_status old_status = connector->status;\n\t\tu64 bits, old_epoch_counter = connector->epoch_counter;\n\n\t\tif (!(pending & drm_connector_mask(connector)))\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&drm->hpd_lock);\n\t\tbits = nv_connector->hpd_pending;\n\t\tnv_connector->hpd_pending = 0;\n\t\tspin_unlock_irq(&drm->hpd_lock);\n\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] plug:%d unplug:%d irq:%d\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    !!(bits & NVIF_CONN_EVENT_V0_PLUG),\n\t\t\t    !!(bits & NVIF_CONN_EVENT_V0_UNPLUG),\n\t\t\t    !!(bits & NVIF_CONN_EVENT_V0_IRQ));\n\n\t\tif (bits & NVIF_CONN_EVENT_V0_IRQ) {\n\t\t\tif (nouveau_dp_link_check(nv_connector))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tconnector->status = drm_helper_probe_detect(connector, NULL, false);\n\t\tif (old_epoch_counter == connector->epoch_counter)\n\t\t\tcontinue;\n\n\t\tchanged++;\n\t\tif (!first_changed_connector) {\n\t\t\tdrm_connector_get(connector);\n\t\t\tfirst_changed_connector = connector;\n\t\t}\n\n\t\tdrm_dbg_kms(dev, \"[CONNECTOR:%d:%s] status updated from %s to %s (epoch counter %llu->%llu)\\n\",\n\t\t\t    connector->base.id, connector->name,\n\t\t\t    drm_get_connector_status_name(old_status),\n\t\t\t    drm_get_connector_status_name(connector->status),\n\t\t\t    old_epoch_counter, connector->epoch_counter);\n\t}\n\n\tdrm_connector_list_iter_end(&conn_iter);\n\tmutex_unlock(&dev->mode_config.mutex);\n\n\tif (changed == 1)\n\t\tdrm_kms_helper_connector_hotplug_event(first_changed_connector);\n\telse if (changed > 0)\n\t\tdrm_kms_helper_hotplug_event(dev);\n\n\tif (first_changed_connector)\n\t\tdrm_connector_put(first_changed_connector);\n\n\tpm_runtime_mark_last_busy(drm->dev->dev);\nnoop:\n\tpm_runtime_put_autosuspend(dev->dev);\n}\n\n#ifdef CONFIG_ACPI\n\nstatic int\nnouveau_display_acpi_ntfy(struct notifier_block *nb, unsigned long val,\n\t\t\t  void *data)\n{\n\tstruct nouveau_drm *drm = container_of(nb, typeof(*drm), acpi_nb);\n\tstruct acpi_bus_event *info = data;\n\tint ret;\n\n\tif (!strcmp(info->device_class, ACPI_VIDEO_CLASS)) {\n\t\tif (info->type == ACPI_VIDEO_NOTIFY_PROBE) {\n\t\t\tret = pm_runtime_get(drm->dev->dev);\n\t\t\tif (ret == 1 || ret == -EACCES) {\n\t\t\t\t \n\t\t\t\tpm_runtime_put_autosuspend(drm->dev->dev);\n\t\t\t} else if (ret == 0 || ret == -EINPROGRESS) {\n\t\t\t\t \n\t\t\t\tNV_DEBUG(drm, \"ACPI requested connector reprobe\\n\");\n\t\t\t\tpm_runtime_put_noidle(drm->dev->dev);\n\t\t\t} else {\n\t\t\t\tNV_WARN(drm, \"Dropped ACPI reprobe event due to RPM error: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t}\n\n\t\t\t \n\t\t\treturn NOTIFY_BAD;\n\t\t}\n\t}\n\n\treturn NOTIFY_DONE;\n}\n#endif\n\nint\nnouveau_display_init(struct drm_device *dev, bool resume, bool runtime)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tint ret;\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tnouveau_for_each_non_mst_connector_iter(connector, &conn_iter) {\n\t\tstruct nouveau_connector *conn = nouveau_connector(connector);\n\t\tnvif_event_allow(&conn->hpd);\n\t\tnvif_event_allow(&conn->irq);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tret = disp->init(dev, resume, runtime);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdrm_kms_helper_poll_enable(dev);\n\n\treturn ret;\n}\n\nvoid\nnouveau_display_fini(struct drm_device *dev, bool suspend, bool runtime)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\n\tif (!suspend) {\n\t\tif (drm_drv_uses_atomic_modeset(dev))\n\t\t\tdrm_atomic_helper_shutdown(dev);\n\t\telse\n\t\t\tdrm_helper_force_disable_all(dev);\n\t}\n\n\t \n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tnouveau_for_each_non_mst_connector_iter(connector, &conn_iter) {\n\t\tstruct nouveau_connector *conn = nouveau_connector(connector);\n\t\tnvif_event_block(&conn->irq);\n\t\tnvif_event_block(&conn->hpd);\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (!runtime)\n\t\tcancel_work_sync(&drm->hpd_work);\n\n\tdrm_kms_helper_poll_disable(dev);\n\tdisp->fini(dev, runtime, suspend);\n}\n\nstatic void\nnouveau_display_create_properties(struct drm_device *dev)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tint gen;\n\n\tif (disp->disp.object.oclass < NV50_DISP)\n\t\tgen = 0;\n\telse\n\tif (disp->disp.object.oclass < GF110_DISP)\n\t\tgen = 1;\n\telse\n\t\tgen = 2;\n\n\tPROP_ENUM(disp->dithering_mode, gen, \"dithering mode\", dither_mode);\n\tPROP_ENUM(disp->dithering_depth, gen, \"dithering depth\", dither_depth);\n\tPROP_ENUM(disp->underscan_property, gen, \"underscan\", underscan);\n\n\tdisp->underscan_hborder_property =\n\t\tdrm_property_create_range(dev, 0, \"underscan hborder\", 0, 128);\n\n\tdisp->underscan_vborder_property =\n\t\tdrm_property_create_range(dev, 0, \"underscan vborder\", 0, 128);\n\n\tif (gen < 1)\n\t\treturn;\n\n\t \n\tdisp->vibrant_hue_property =\n\t\tdrm_property_create_range(dev, 0, \"vibrant hue\", 0, 180);\n\n\t \n\tdisp->color_vibrance_property =\n\t\tdrm_property_create_range(dev, 0, \"color vibrance\", 0, 200);\n}\n\nint\nnouveau_display_create(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_display *disp;\n\tint ret;\n\n\tdisp = drm->display = kzalloc(sizeof(*disp), GFP_KERNEL);\n\tif (!disp)\n\t\treturn -ENOMEM;\n\n\tdrm_mode_config_init(dev);\n\tdrm_mode_create_scaling_mode_property(dev);\n\tdrm_mode_create_dvi_i_properties(dev);\n\n\tdev->mode_config.funcs = &nouveau_mode_config_funcs;\n\n\tdev->mode_config.min_width = 0;\n\tdev->mode_config.min_height = 0;\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_CELSIUS) {\n\t\tdev->mode_config.max_width = 2048;\n\t\tdev->mode_config.max_height = 2048;\n\t} else\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA) {\n\t\tdev->mode_config.max_width = 4096;\n\t\tdev->mode_config.max_height = 4096;\n\t} else\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_FERMI) {\n\t\tdev->mode_config.max_width = 8192;\n\t\tdev->mode_config.max_height = 8192;\n\t} else {\n\t\tdev->mode_config.max_width = 16384;\n\t\tdev->mode_config.max_height = 16384;\n\t}\n\n\tdev->mode_config.preferred_depth = 24;\n\tdev->mode_config.prefer_shadow = 1;\n\n\tif (drm->client.device.info.chipset < 0x11)\n\t\tdev->mode_config.async_page_flip = false;\n\telse\n\t\tdev->mode_config.async_page_flip = true;\n\n\tdrm_kms_helper_poll_init(dev);\n\tdrm_kms_helper_poll_disable(dev);\n\n\tif (nouveau_modeset != 2 && drm->vbios.dcb.entries) {\n\t\tret = nvif_disp_ctor(&drm->client.device, \"kmsDisp\", 0,\n\t\t\t\t     &disp->disp);\n\t\tif (ret == 0) {\n\t\t\tnouveau_display_create_properties(dev);\n\t\t\tif (disp->disp.object.oclass < NV50_DISP) {\n\t\t\t\tdev->mode_config.fb_modifiers_not_supported = true;\n\t\t\t\tret = nv04_display_create(dev);\n\t\t\t} else {\n\t\t\t\tret = nv50_display_create(dev);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = 0;\n\t}\n\n\tif (ret)\n\t\tgoto disp_create_err;\n\n\tdrm_mode_config_reset(dev);\n\n\tif (dev->mode_config.num_crtc) {\n\t\tret = drm_vblank_init(dev, dev->mode_config.num_crtc);\n\t\tif (ret)\n\t\t\tgoto vblank_err;\n\n\t\tif (disp->disp.object.oclass >= NV50_DISP)\n\t\t\tnv50_crc_init(dev);\n\t}\n\n\tINIT_WORK(&drm->hpd_work, nouveau_display_hpd_work);\n\tspin_lock_init(&drm->hpd_lock);\n#ifdef CONFIG_ACPI\n\tdrm->acpi_nb.notifier_call = nouveau_display_acpi_ntfy;\n\tregister_acpi_notifier(&drm->acpi_nb);\n#endif\n\n\treturn 0;\n\nvblank_err:\n\tdisp->dtor(dev);\ndisp_create_err:\n\tdrm_kms_helper_poll_fini(dev);\n\tdrm_mode_config_cleanup(dev);\n\treturn ret;\n}\n\nvoid\nnouveau_display_destroy(struct drm_device *dev)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n#ifdef CONFIG_ACPI\n\tunregister_acpi_notifier(&drm->acpi_nb);\n#endif\n\n\tdrm_kms_helper_poll_fini(dev);\n\tdrm_mode_config_cleanup(dev);\n\n\tif (disp->dtor)\n\t\tdisp->dtor(dev);\n\n\tnvif_disp_dtor(&disp->disp);\n\n\tdrm->display = NULL;\n\tkfree(disp);\n}\n\nint\nnouveau_display_suspend(struct drm_device *dev, bool runtime)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\n\t \n\tdrm_fb_helper_set_suspend_unlocked(dev->fb_helper, true);\n\n\tif (drm_drv_uses_atomic_modeset(dev)) {\n\t\tif (!runtime) {\n\t\t\tdisp->suspend = drm_atomic_helper_suspend(dev);\n\t\t\tif (IS_ERR(disp->suspend)) {\n\t\t\t\tint ret = PTR_ERR(disp->suspend);\n\t\t\t\tdisp->suspend = NULL;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tnouveau_display_fini(dev, true, runtime);\n\treturn 0;\n}\n\nvoid\nnouveau_display_resume(struct drm_device *dev, bool runtime)\n{\n\tstruct nouveau_display *disp = nouveau_display(dev);\n\n\tnouveau_display_init(dev, true, runtime);\n\n\tif (drm_drv_uses_atomic_modeset(dev)) {\n\t\tif (disp->suspend) {\n\t\t\tdrm_atomic_helper_resume(dev, disp->suspend);\n\t\t\tdisp->suspend = NULL;\n\t\t}\n\t}\n\n\t \n\tdrm_fb_helper_set_suspend_unlocked(dev->fb_helper, false);\n}\n\nint\nnouveau_display_dumb_create(struct drm_file *file_priv, struct drm_device *dev,\n\t\t\t    struct drm_mode_create_dumb *args)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_bo *bo;\n\tuint32_t domain;\n\tint ret;\n\n\targs->pitch = roundup(args->width * (args->bpp / 8), 256);\n\targs->size = args->pitch * args->height;\n\targs->size = roundup(args->size, PAGE_SIZE);\n\n\t \n\tif (nouveau_drm(dev)->client.device.info.ram_size != 0)\n\t\tdomain = NOUVEAU_GEM_DOMAIN_VRAM;\n\telse\n\t\tdomain = NOUVEAU_GEM_DOMAIN_GART;\n\n\tret = nouveau_gem_new(cli, args->size, 0, domain, 0, 0, &bo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_gem_handle_create(file_priv, &bo->bo.base, &args->handle);\n\tdrm_gem_object_put(&bo->bo.base);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}