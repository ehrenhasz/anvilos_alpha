{
  "module_name": "nouveau_dp.c",
  "hash_id": "0e378cde01f918c6c20a892c6dbc89abdcb1f049190103247d8eb41a80dadd59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_dp.c",
  "human_readable_source": " \n\n#include <drm/display/drm_dp_helper.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_crtc.h\"\n\n#include <nvif/if0011.h>\n\nMODULE_PARM_DESC(mst, \"Enable DisplayPort multi-stream (default: enabled)\");\nstatic int nouveau_mst = 1;\nmodule_param_named(mst, nouveau_mst, int, 0400);\n\nstatic bool\nnouveau_dp_has_sink_count(struct drm_connector *connector,\n\t\t\t  struct nouveau_encoder *outp)\n{\n\treturn drm_dp_read_sink_count_cap(connector, outp->dp.dpcd, &outp->dp.desc);\n}\n\nstatic enum drm_connector_status\nnouveau_dp_probe_dpcd(struct nouveau_connector *nv_connector,\n\t\t      struct nouveau_encoder *outp)\n{\n\tstruct drm_connector *connector = &nv_connector->base;\n\tstruct drm_dp_aux *aux = &nv_connector->aux;\n\tstruct nv50_mstm *mstm = NULL;\n\tenum drm_connector_status status = connector_status_disconnected;\n\tint ret;\n\tu8 *dpcd = outp->dp.dpcd;\n\n\tret = drm_dp_read_dpcd_caps(aux, dpcd);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = drm_dp_read_desc(aux, &outp->dp.desc, drm_dp_is_branch(dpcd));\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (nouveau_mst) {\n\t\tmstm = outp->dp.mstm;\n\t\tif (mstm)\n\t\t\tmstm->can_mst = drm_dp_read_mst_cap(aux, dpcd);\n\t}\n\n\tif (nouveau_dp_has_sink_count(connector, outp)) {\n\t\tret = drm_dp_read_sink_count(aux);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\toutp->dp.sink_count = ret;\n\n\t\t \n\t\tif (!outp->dp.sink_count)\n\t\t\treturn connector_status_disconnected;\n\t}\n\n\tret = drm_dp_read_downstream_info(aux, dpcd,\n\t\t\t\t\t  outp->dp.downstream_ports);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tstatus = connector_status_connected;\nout:\n\tif (status != connector_status_connected) {\n\t\t \n\t\toutp->dp.sink_count = 0;\n\t}\n\treturn status;\n}\n\nint\nnouveau_dp_detect(struct nouveau_connector *nv_connector,\n\t\t  struct nouveau_encoder *nv_encoder)\n{\n\tstruct drm_device *dev = nv_encoder->base.base.dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_connector *connector = &nv_connector->base;\n\tstruct nv50_mstm *mstm = nv_encoder->dp.mstm;\n\tenum drm_connector_status status;\n\tu8 *dpcd = nv_encoder->dp.dpcd;\n\tint ret = NOUVEAU_DP_NONE, hpd;\n\n\t \n\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP &&\n\t    dpcd[DP_DPCD_REV] != 0)\n\t\treturn NOUVEAU_DP_SST;\n\n\tmutex_lock(&nv_encoder->dp.hpd_irq_lock);\n\tif (mstm) {\n\t\t \n\t\tif (mstm->suspended) {\n\t\t\tif (mstm->is_mst)\n\t\t\t\tret = NOUVEAU_DP_MST;\n\t\t\telse if (connector->status ==\n\t\t\t\t connector_status_connected)\n\t\t\t\tret = NOUVEAU_DP_SST;\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\thpd = nvif_conn_hpd_status(&nv_connector->conn);\n\tif (hpd == NVIF_CONN_HPD_STATUS_NOT_PRESENT) {\n\t\tnvif_outp_dp_aux_pwr(&nv_encoder->outp, false);\n\t\tgoto out;\n\t}\n\tnvif_outp_dp_aux_pwr(&nv_encoder->outp, true);\n\n\tstatus = nouveau_dp_probe_dpcd(nv_connector, nv_encoder);\n\tif (status == connector_status_disconnected) {\n\t\tnvif_outp_dp_aux_pwr(&nv_encoder->outp, false);\n\t\tgoto out;\n\t}\n\n\t \n\tif (mstm && mstm->can_mst && mstm->is_mst) {\n\t\tret = NOUVEAU_DP_MST;\n\t\tgoto out;\n\t}\n\n\tnv_encoder->dp.link_bw = 27000 * dpcd[DP_MAX_LINK_RATE];\n\tnv_encoder->dp.link_nr =\n\t\tdpcd[DP_MAX_LANE_COUNT] & DP_MAX_LANE_COUNT_MASK;\n\n\tif (connector->connector_type == DRM_MODE_CONNECTOR_eDP && dpcd[DP_DPCD_REV] >= 0x13) {\n\t\tstruct drm_dp_aux *aux = &nv_connector->aux;\n\t\tint ret, i;\n\t\tu8 sink_rates[16];\n\n\t\tret = drm_dp_dpcd_read(aux, DP_SUPPORTED_LINK_RATES, sink_rates, sizeof(sink_rates));\n\t\tif (ret == sizeof(sink_rates)) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(sink_rates); i += 2) {\n\t\t\t\tint val = ((sink_rates[i + 1] << 8) | sink_rates[i]) * 200 / 10;\n\t\t\t\tif (val && (i == 0 || val > nv_encoder->dp.link_bw))\n\t\t\t\t\tnv_encoder->dp.link_bw = val;\n\t\t\t}\n\t\t}\n\t}\n\n\tNV_DEBUG(drm, \"display: %dx%d dpcd 0x%02x\\n\",\n\t\t nv_encoder->dp.link_nr, nv_encoder->dp.link_bw,\n\t\t dpcd[DP_DPCD_REV]);\n\tNV_DEBUG(drm, \"encoder: %dx%d\\n\",\n\t\t nv_encoder->dcb->dpconf.link_nr,\n\t\t nv_encoder->dcb->dpconf.link_bw);\n\n\tif (nv_encoder->dcb->dpconf.link_nr < nv_encoder->dp.link_nr)\n\t\tnv_encoder->dp.link_nr = nv_encoder->dcb->dpconf.link_nr;\n\tif (nv_encoder->dcb->dpconf.link_bw < nv_encoder->dp.link_bw)\n\t\tnv_encoder->dp.link_bw = nv_encoder->dcb->dpconf.link_bw;\n\n\tNV_DEBUG(drm, \"maximum: %dx%d\\n\",\n\t\t nv_encoder->dp.link_nr, nv_encoder->dp.link_bw);\n\n\tif (mstm && mstm->can_mst) {\n\t\tret = nv50_mstm_detect(nv_encoder);\n\t\tif (ret == 1) {\n\t\t\tret = NOUVEAU_DP_MST;\n\t\t\tgoto out;\n\t\t} else if (ret != 0) {\n\t\t\tnvif_outp_dp_aux_pwr(&nv_encoder->outp, false);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = NOUVEAU_DP_SST;\n\nout:\n\tif (mstm && !mstm->suspended && ret != NOUVEAU_DP_MST)\n\t\tnv50_mstm_remove(mstm);\n\n\tmutex_unlock(&nv_encoder->dp.hpd_irq_lock);\n\treturn ret;\n}\n\nbool\nnouveau_dp_link_check(struct nouveau_connector *nv_connector)\n{\n\tstruct nouveau_encoder *nv_encoder = find_encoder(&nv_connector->base, DCB_OUTPUT_DP);\n\n\tif (!nv_encoder || nv_encoder->outp.or.id < 0)\n\t\treturn true;\n\n\treturn nvif_outp_dp_retrain(&nv_encoder->outp) == 0;\n}\n\nvoid\nnouveau_dp_irq(struct work_struct *work)\n{\n\tstruct nouveau_connector *nv_connector =\n\t\tcontainer_of(work, typeof(*nv_connector), irq_work);\n\tstruct drm_connector *connector = &nv_connector->base;\n\tstruct nouveau_encoder *outp = find_encoder(connector, DCB_OUTPUT_DP);\n\tstruct nouveau_drm *drm = nouveau_drm(outp->base.base.dev);\n\tstruct nv50_mstm *mstm;\n\tu64 hpd = 0;\n\tint ret;\n\n\tif (!outp)\n\t\treturn;\n\n\tmstm = outp->dp.mstm;\n\tNV_DEBUG(drm, \"service %s\\n\", connector->name);\n\n\tmutex_lock(&outp->dp.hpd_irq_lock);\n\n\tif (mstm && mstm->is_mst) {\n\t\tif (!nv50_mstm_service(drm, nv_connector, mstm))\n\t\t\thpd |= NVIF_CONN_EVENT_V0_UNPLUG;\n\t} else {\n\t\tdrm_dp_cec_irq(&nv_connector->aux);\n\n\t\tif (nouveau_dp_has_sink_count(connector, outp)) {\n\t\t\tret = drm_dp_read_sink_count(&nv_connector->aux);\n\t\t\tif (ret != outp->dp.sink_count)\n\t\t\t\thpd |= NVIF_CONN_EVENT_V0_PLUG;\n\t\t\tif (ret >= 0)\n\t\t\t\toutp->dp.sink_count = ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&outp->dp.hpd_irq_lock);\n\n\tnouveau_connector_hpd(nv_connector, NVIF_CONN_EVENT_V0_IRQ | hpd);\n}\n\n \nenum drm_mode_status\nnv50_dp_mode_valid(struct nouveau_encoder *outp,\n\t\t   const struct drm_display_mode *mode,\n\t\t   unsigned *out_clock)\n{\n\tconst unsigned int min_clock = 25000;\n\tunsigned int max_rate, mode_rate, ds_max_dotclock, clock = mode->clock;\n\t \n\tconst u8 bpp = 6 * 3;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE && !outp->caps.dp_interlace)\n\t\treturn MODE_NO_INTERLACE;\n\n\tif ((mode->flags & DRM_MODE_FLAG_3D_MASK) == DRM_MODE_FLAG_3D_FRAME_PACKING)\n\t\tclock *= 2;\n\n\tmax_rate = outp->dp.link_nr * outp->dp.link_bw;\n\tmode_rate = DIV_ROUND_UP(clock * bpp, 8);\n\tif (mode_rate > max_rate)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tds_max_dotclock = drm_dp_downstream_max_dotclock(outp->dp.dpcd, outp->dp.downstream_ports);\n\tif (ds_max_dotclock && clock > ds_max_dotclock)\n\t\treturn MODE_CLOCK_HIGH;\n\n\tif (clock < min_clock)\n\t\treturn MODE_CLOCK_LOW;\n\n\tif (out_clock)\n\t\t*out_clock = clock;\n\n\treturn MODE_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}