{
  "module_name": "nv50_fence.c",
  "hash_id": "831a66064c18519ba61231ee03325e147fc21f7aed7385721e3d30a649686cf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nv50_fence.c",
  "human_readable_source": " \n\n#include <nvif/os.h>\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nv10_fence.h\"\n\n#include \"nv50_display.h\"\n\nstatic int\nnv50_fence_context_new(struct nouveau_channel *chan)\n{\n\tstruct nv10_fence_priv *priv = chan->drm->fence;\n\tstruct nv10_fence_chan *fctx;\n\tstruct ttm_resource *reg = priv->bo->bo.resource;\n\tu32 start = reg->start * PAGE_SIZE;\n\tu32 limit = start + priv->bo->bo.base.size - 1;\n\tint ret;\n\n\tfctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);\n\tif (!fctx)\n\t\treturn -ENOMEM;\n\n\tnouveau_fence_context_new(chan, &fctx->base);\n\tfctx->base.emit = nv10_fence_emit;\n\tfctx->base.read = nv10_fence_read;\n\tfctx->base.sync = nv17_fence_sync;\n\n\tret = nvif_object_ctor(&chan->user, \"fenceCtxDma\", NvSema,\n\t\t\t       NV_DMA_IN_MEMORY,\n\t\t\t       &(struct nv_dma_v0) {\n\t\t\t\t\t.target = NV_DMA_V0_TARGET_VRAM,\n\t\t\t\t\t.access = NV_DMA_V0_ACCESS_RDWR,\n\t\t\t\t\t.start = start,\n\t\t\t\t\t.limit = limit,\n\t\t\t       }, sizeof(struct nv_dma_v0),\n\t\t\t       &fctx->sema);\n\tif (ret)\n\t\tnv10_fence_context_del(chan);\n\treturn ret;\n}\n\nint\nnv50_fence_create(struct nouveau_drm *drm)\n{\n\tstruct nv10_fence_priv *priv;\n\tint ret = 0;\n\n\tpriv = drm->fence = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base.dtor = nv10_fence_destroy;\n\tpriv->base.resume = nv17_fence_resume;\n\tpriv->base.context_new = nv50_fence_context_new;\n\tpriv->base.context_del = nv10_fence_context_del;\n\tspin_lock_init(&priv->lock);\n\n\tret = nouveau_bo_new(&drm->client, 4096, 0x1000,\n\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM,\n\t\t\t     0, 0x0000, NULL, NULL, &priv->bo);\n\tif (!ret) {\n\t\tret = nouveau_bo_pin(priv->bo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\t\tif (!ret) {\n\t\t\tret = nouveau_bo_map(priv->bo);\n\t\t\tif (ret)\n\t\t\t\tnouveau_bo_unpin(priv->bo);\n\t\t}\n\t\tif (ret)\n\t\t\tnouveau_bo_ref(NULL, &priv->bo);\n\t}\n\n\tif (ret) {\n\t\tnv10_fence_destroy(drm);\n\t\treturn ret;\n\t}\n\n\tnouveau_bo_wr32(priv->bo, 0x000, 0x00000000);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}