{
  "module_name": "nouveau_vmm.c",
  "hash_id": "08dcf958f47d2bf13f6275f9fd577b49afebe063b0a425b26b62941e768bda89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_vmm.c",
  "human_readable_source": " \n#include \"nouveau_vmm.h\"\n#include \"nouveau_drv.h\"\n#include \"nouveau_bo.h\"\n#include \"nouveau_svm.h\"\n#include \"nouveau_mem.h\"\n\nvoid\nnouveau_vma_unmap(struct nouveau_vma *vma)\n{\n\tif (vma->mem) {\n\t\tnvif_vmm_unmap(&vma->vmm->vmm, vma->addr);\n\t\tvma->mem = NULL;\n\t}\n}\n\nint\nnouveau_vma_map(struct nouveau_vma *vma, struct nouveau_mem *mem)\n{\n\tstruct nvif_vma tmp = { .addr = vma->addr };\n\tint ret = nouveau_mem_map(mem, &vma->vmm->vmm, &tmp);\n\tif (ret)\n\t\treturn ret;\n\tvma->mem = mem;\n\treturn 0;\n}\n\nstruct nouveau_vma *\nnouveau_vma_find(struct nouveau_bo *nvbo, struct nouveau_vmm *vmm)\n{\n\tstruct nouveau_vma *vma;\n\n\tlist_for_each_entry(vma, &nvbo->vma_list, head) {\n\t\tif (vma->vmm == vmm)\n\t\t\treturn vma;\n\t}\n\n\treturn NULL;\n}\n\nvoid\nnouveau_vma_del(struct nouveau_vma **pvma)\n{\n\tstruct nouveau_vma *vma = *pvma;\n\tif (vma && --vma->refs <= 0) {\n\t\tif (likely(vma->addr != ~0ULL)) {\n\t\t\tstruct nvif_vma tmp = { .addr = vma->addr, .size = 1 };\n\t\t\tnvif_vmm_put(&vma->vmm->vmm, &tmp);\n\t\t}\n\t\tlist_del(&vma->head);\n\t\tkfree(*pvma);\n\t}\n\t*pvma = NULL;\n}\n\nint\nnouveau_vma_new(struct nouveau_bo *nvbo, struct nouveau_vmm *vmm,\n\t\tstruct nouveau_vma **pvma)\n{\n\tstruct nouveau_mem *mem = nouveau_mem(nvbo->bo.resource);\n\tstruct nouveau_vma *vma;\n\tstruct nvif_vma tmp;\n\tint ret;\n\n\tif ((vma = *pvma = nouveau_vma_find(nvbo, vmm))) {\n\t\tvma->refs++;\n\t\treturn 0;\n\t}\n\n\tif (!(vma = *pvma = kmalloc(sizeof(*vma), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tvma->vmm = vmm;\n\tvma->refs = 1;\n\tvma->addr = ~0ULL;\n\tvma->mem = NULL;\n\tvma->fence = NULL;\n\tlist_add_tail(&vma->head, &nvbo->vma_list);\n\n\tif (nvbo->bo.resource->mem_type != TTM_PL_SYSTEM &&\n\t    mem->mem.page == nvbo->page) {\n\t\tret = nvif_vmm_get(&vmm->vmm, LAZY, false, mem->mem.page, 0,\n\t\t\t\t   mem->mem.size, &tmp);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tvma->addr = tmp.addr;\n\t\tret = nouveau_vma_map(vma, mem);\n\t} else {\n\t\tret = nvif_vmm_get(&vmm->vmm, PTES, false, mem->mem.page, 0,\n\t\t\t\t   mem->mem.size, &tmp);\n\t\tvma->addr = tmp.addr;\n\t}\n\ndone:\n\tif (ret)\n\t\tnouveau_vma_del(pvma);\n\treturn ret;\n}\n\nvoid\nnouveau_vmm_fini(struct nouveau_vmm *vmm)\n{\n\tnouveau_svmm_fini(&vmm->svmm);\n\tnvif_vmm_dtor(&vmm->vmm);\n\tvmm->cli = NULL;\n}\n\nint\nnouveau_vmm_init(struct nouveau_cli *cli, s32 oclass, struct nouveau_vmm *vmm)\n{\n\tint ret = nvif_vmm_ctor(&cli->mmu, \"drmVmm\", oclass, UNMANAGED,\n\t\t\t\tPAGE_SIZE, 0, NULL, 0, &vmm->vmm);\n\tif (ret)\n\t\treturn ret;\n\n\tvmm->cli = cli;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}