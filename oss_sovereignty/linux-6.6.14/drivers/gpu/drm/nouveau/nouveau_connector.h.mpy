{
  "module_name": "nouveau_connector.h",
  "hash_id": "eb348107e57715d833e664be9a38f8d4efeb0f0e9abbee031cd962749cfe8463",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_connector.h",
  "human_readable_source": " \n\n#ifndef __NOUVEAU_CONNECTOR_H__\n#define __NOUVEAU_CONNECTOR_H__\n#include <nvif/conn.h>\n#include <nvif/event.h>\n\n#include <nvhw/class/cl507d.h>\n#include <nvhw/class/cl907d.h>\n#include <nvhw/drf.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_encoder.h>\n#include <drm/drm_util.h>\n\n#include \"nouveau_crtc.h\"\n#include \"nouveau_encoder.h\"\n\nstruct nvkm_i2c_port;\nstruct dcb_output;\n\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\nstruct nouveau_backlight {\n\tstruct backlight_device *dev;\n\n\tstruct drm_edp_backlight_info edp_info;\n\tbool uses_dpcd : 1;\n\n\tint id;\n};\n#endif\n\n#define nouveau_conn_atom(p)                                                   \\\n\tcontainer_of((p), struct nouveau_conn_atom, state)\n\nstruct nouveau_conn_atom {\n\tstruct drm_connector_state state;\n\n\tstruct {\n\t\t \n\t\tenum {\n\t\t\tDITHERING_MODE_OFF =\n\t\t\t\tNVDEF(NV507D, HEAD_SET_DITHER_CONTROL, ENABLE, DISABLE),\n\t\t\tDITHERING_MODE_ON =\n\t\t\t\tNVDEF(NV507D, HEAD_SET_DITHER_CONTROL, ENABLE, ENABLE),\n\t\t\tDITHERING_MODE_DYNAMIC2X2 = DITHERING_MODE_ON |\n\t\t\t\tNVDEF(NV507D, HEAD_SET_DITHER_CONTROL, MODE, DYNAMIC_2X2),\n\t\t\tDITHERING_MODE_STATIC2X2 = DITHERING_MODE_ON |\n\t\t\t\tNVDEF(NV507D, HEAD_SET_DITHER_CONTROL, MODE, STATIC_2X2),\n\t\t\tDITHERING_MODE_TEMPORAL = DITHERING_MODE_ON |\n\t\t\t\tNVDEF(NV907D, HEAD_SET_DITHER_CONTROL, MODE, TEMPORAL),\n\t\t\tDITHERING_MODE_AUTO\n\t\t} mode;\n\t\tenum {\n\t\t\tDITHERING_DEPTH_6BPC =\n\t\t\t\tNVDEF(NV507D, HEAD_SET_DITHER_CONTROL, BITS, DITHER_TO_6_BITS),\n\t\t\tDITHERING_DEPTH_8BPC =\n\t\t\t\tNVDEF(NV507D, HEAD_SET_DITHER_CONTROL, BITS, DITHER_TO_8_BITS),\n\t\t\tDITHERING_DEPTH_AUTO\n\t\t} depth;\n\t} dither;\n\n\tstruct {\n\t\tint mode;\t \n\t\tstruct {\n\t\t\tenum {\n\t\t\t\tUNDERSCAN_OFF,\n\t\t\t\tUNDERSCAN_ON,\n\t\t\t\tUNDERSCAN_AUTO,\n\t\t\t} mode;\n\t\t\tu32 hborder;\n\t\t\tu32 vborder;\n\t\t} underscan;\n\t\tbool full;\n\t} scaler;\n\n\tstruct {\n\t\tint color_vibrance;\n\t\tint vibrant_hue;\n\t} procamp;\n\n\tunion {\n\t\tstruct {\n\t\t\tbool dither:1;\n\t\t\tbool scaler:1;\n\t\t\tbool procamp:1;\n\t\t};\n\t\tu8 mask;\n\t} set;\n};\n\nstruct nouveau_connector {\n\tstruct drm_connector base;\n\tenum dcb_connector_type type;\n\tu8 index;\n\tu8 *dcb;\n\n\tstruct nvif_conn conn;\n\tu64 hpd_pending;\n\tstruct nvif_event hpd;\n\tstruct nvif_event irq;\n\tstruct work_struct irq_work;\n\n\tstruct drm_dp_aux aux;\n\n\t \n\tstruct nouveau_encoder *dp_encoder;\n\n\tint dithering_mode;\n\tint scaling_mode;\n\n\tstruct nouveau_encoder *detected_encoder;\n\tstruct edid *edid;\n\tstruct drm_display_mode *native_mode;\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\n\tstruct nouveau_backlight *backlight;\n#endif\n\t \n\tstruct nouveau_conn_atom properties_state;\n};\n\nstatic inline struct nouveau_connector *nouveau_connector(\n\t\t\t\t\t\tstruct drm_connector *con)\n{\n\treturn container_of(con, struct nouveau_connector, base);\n}\n\nstatic inline bool\nnouveau_connector_is_mst(struct drm_connector *connector)\n{\n\tconst struct nouveau_encoder *nv_encoder;\n\tconst struct drm_encoder *encoder;\n\n\tif (connector->connector_type != DRM_MODE_CONNECTOR_DisplayPort)\n\t\treturn false;\n\n\tnv_encoder = find_encoder(connector, DCB_OUTPUT_ANY);\n\tif (!nv_encoder)\n\t\treturn false;\n\n\tencoder = &nv_encoder->base.base;\n\treturn encoder->encoder_type == DRM_MODE_ENCODER_DPMST;\n}\n\n#define nouveau_for_each_non_mst_connector_iter(connector, iter) \\\n\tdrm_for_each_connector_iter(connector, iter) \\\n\t\tfor_each_if(!nouveau_connector_is_mst(connector))\n\nstatic inline struct nouveau_connector *\nnouveau_crtc_connector_get(struct nouveau_crtc *nv_crtc)\n{\n\tstruct drm_device *dev = nv_crtc->base.dev;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct nouveau_connector *nv_connector = NULL;\n\tstruct drm_crtc *crtc = to_drm_crtc(nv_crtc);\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tnouveau_for_each_non_mst_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder && connector->encoder->crtc == crtc) {\n\t\t\tnv_connector = nouveau_connector(connector);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn nv_connector;\n}\n\nstruct drm_connector *\nnouveau_connector_create(struct drm_device *, const struct dcb_output *);\nvoid nouveau_connector_hpd(struct nouveau_connector *, u64 bits);\n\nextern int nouveau_tv_disable;\nextern int nouveau_ignorelid;\nextern int nouveau_duallink;\nextern int nouveau_hdmimhz;\n\nvoid nouveau_conn_attach_properties(struct drm_connector *);\nvoid nouveau_conn_reset(struct drm_connector *);\nstruct drm_connector_state *\nnouveau_conn_atomic_duplicate_state(struct drm_connector *);\nvoid nouveau_conn_atomic_destroy_state(struct drm_connector *,\n\t\t\t\t       struct drm_connector_state *);\nint nouveau_conn_atomic_set_property(struct drm_connector *,\n\t\t\t\t     struct drm_connector_state *,\n\t\t\t\t     struct drm_property *, u64);\nint nouveau_conn_atomic_get_property(struct drm_connector *,\n\t\t\t\t     const struct drm_connector_state *,\n\t\t\t\t     struct drm_property *, u64 *);\nstruct drm_display_mode *nouveau_conn_native_mode(struct drm_connector *);\nenum drm_mode_status\nnouveau_conn_mode_clock_valid(const struct drm_display_mode *,\n\t\t\t      const unsigned min_clock,\n\t\t\t      const unsigned max_clock,\n\t\t\t      unsigned *clock);\n\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\nextern int nouveau_backlight_init(struct drm_connector *);\nextern void nouveau_backlight_fini(struct drm_connector *);\nextern void nouveau_backlight_ctor(void);\nextern void nouveau_backlight_dtor(void);\n#else\nstatic inline int\nnouveau_backlight_init(struct drm_connector *connector)\n{\n\treturn 0;\n}\n\nstatic inline void\nnouveau_backlight_fini(struct drm_connector *connector) {\n}\n\nstatic inline void\nnouveau_backlight_ctor(void) {\n}\n\nstatic inline void\nnouveau_backlight_dtor(void) {\n}\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}