{
  "module_name": "nouveau_usif.c",
  "hash_id": "3a57623513f8708e928c33b837211faac0ad8d91d6f6baafd406304f53253d44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_usif.c",
  "human_readable_source": " \n\n#include \"nouveau_drv.h\"\n#include \"nouveau_usif.h\"\n#include \"nouveau_abi16.h\"\n\n#include <nvif/unpack.h>\n#include <nvif/client.h>\n#include <nvif/ioctl.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0080.h>\n\nstruct usif_object {\n\tstruct list_head head;\n\tu8  route;\n\tu64 token;\n};\n\nstatic void\nusif_object_dtor(struct usif_object *object)\n{\n\tlist_del(&object->head);\n\tkfree(object);\n}\n\nstatic int\nusif_object_new(struct drm_file *f, void *data, u32 size, void *argv, u32 argc, bool parent_abi16)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(f);\n\tstruct nvif_client *client = &cli->base;\n\tunion {\n\t\tstruct nvif_ioctl_new_v0 v0;\n\t} *args = data;\n\tstruct usif_object *object;\n\tint ret = -ENOSYS;\n\n\tif ((ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true)))\n\t\treturn ret;\n\n\tswitch (args->v0.oclass) {\n\tcase NV_DMA_FROM_MEMORY:\n\tcase NV_DMA_TO_MEMORY:\n\tcase NV_DMA_IN_MEMORY:\n\t\treturn -EINVAL;\n\tcase NV_DEVICE: {\n\t\tunion {\n\t\t\tstruct nv_device_v0 v0;\n\t\t} *args = data;\n\n\t\tif ((ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false)))\n\t\t\treturn ret;\n\n\t\targs->v0.priv = false;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tif (!parent_abi16)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!(object = kmalloc(sizeof(*object), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tlist_add(&object->head, &cli->objects);\n\n\tobject->route = args->v0.route;\n\tobject->token = args->v0.token;\n\targs->v0.route = NVDRM_OBJECT_USIF;\n\targs->v0.token = (unsigned long)(void *)object;\n\tret = nvif_client_ioctl(client, argv, argc);\n\tif (ret) {\n\t\tusif_object_dtor(object);\n\t\treturn ret;\n\t}\n\n\targs->v0.token = object->token;\n\targs->v0.route = object->route;\n\treturn 0;\n}\n\nint\nusif_ioctl(struct drm_file *filp, void __user *user, u32 argc)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(filp);\n\tstruct nvif_client *client = &cli->base;\n\tvoid *data = kmalloc(argc, GFP_KERNEL);\n\tu32   size = argc;\n\tunion {\n\t\tstruct nvif_ioctl_v0 v0;\n\t} *argv = data;\n\tstruct usif_object *object;\n\tbool abi16 = false;\n\tu8 owner;\n\tint ret;\n\n\tif (ret = -ENOMEM, !argv)\n\t\tgoto done;\n\tif (ret = -EFAULT, copy_from_user(argv, user, size))\n\t\tgoto done;\n\n\tif (!(ret = nvif_unpack(-ENOSYS, &data, &size, argv->v0, 0, 0, true))) {\n\t\t \n\t\towner = argv->v0.owner;\n\t\tif (argv->v0.object == 0ULL &&\n\t\t    argv->v0.type != NVIF_IOCTL_V0_DEL)\n\t\t\targv->v0.owner = NVDRM_OBJECT_ANY;  \n\t\telse\n\t\t\targv->v0.owner = NVDRM_OBJECT_USIF;\n\t} else\n\t\tgoto done;\n\n\t \n\tmutex_lock(&cli->mutex);\n\tif (argv->v0.route) {\n\t\tif (ret = -EINVAL, argv->v0.route == 0xff)\n\t\t\tret = nouveau_abi16_usif(filp, argv, argc);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&cli->mutex);\n\t\t\tgoto done;\n\t\t}\n\n\t\tabi16 = true;\n\t}\n\n\tswitch (argv->v0.type) {\n\tcase NVIF_IOCTL_V0_NEW:\n\t\tret = usif_object_new(filp, data, size, argv, argc, abi16);\n\t\tbreak;\n\tdefault:\n\t\tret = nvif_client_ioctl(client, argv, argc);\n\t\tbreak;\n\t}\n\tif (argv->v0.route == NVDRM_OBJECT_USIF) {\n\t\tobject = (void *)(unsigned long)argv->v0.token;\n\t\targv->v0.route = object->route;\n\t\targv->v0.token = object->token;\n\t\tif (ret == 0 && argv->v0.type == NVIF_IOCTL_V0_DEL) {\n\t\t\tlist_del(&object->head);\n\t\t\tkfree(object);\n\t\t}\n\t} else {\n\t\targv->v0.route = NVIF_IOCTL_V0_ROUTE_HIDDEN;\n\t\targv->v0.token = 0;\n\t}\n\targv->v0.owner = owner;\n\tmutex_unlock(&cli->mutex);\n\n\tif (copy_to_user(user, argv, argc))\n\t\tret = -EFAULT;\ndone:\n\tkfree(argv);\n\treturn ret;\n}\n\nvoid\nusif_client_fini(struct nouveau_cli *cli)\n{\n\tstruct usif_object *object, *otemp;\n\n\tlist_for_each_entry_safe(object, otemp, &cli->objects, head) {\n\t\tusif_object_dtor(object);\n\t}\n}\n\nvoid\nusif_client_init(struct nouveau_cli *cli)\n{\n\tINIT_LIST_HEAD(&cli->objects);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}