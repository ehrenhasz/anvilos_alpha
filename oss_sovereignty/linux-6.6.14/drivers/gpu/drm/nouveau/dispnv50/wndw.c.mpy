{
  "module_name": "wndw.c",
  "hash_id": "4dab3d53bea02c4275efaad26f23ae843009090a749c269c3ff4a83208e8efbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/wndw.c",
  "human_readable_source": " \n#include \"wndw.h\"\n#include \"wimm.h\"\n#include \"handles.h\"\n\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n\n#include <nvhw/class/cl507c.h>\n#include <nvhw/class/cl507e.h>\n#include <nvhw/class/clc37e.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"nouveau_bo.h\"\n#include \"nouveau_gem.h\"\n\nstatic void\nnv50_wndw_ctxdma_del(struct nv50_wndw_ctxdma *ctxdma)\n{\n\tnvif_object_dtor(&ctxdma->object);\n\tlist_del(&ctxdma->head);\n\tkfree(ctxdma);\n}\n\nstatic struct nv50_wndw_ctxdma *\nnv50_wndw_ctxdma_new(struct nv50_wndw *wndw, struct drm_framebuffer *fb)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(fb->dev);\n\tstruct nv50_wndw_ctxdma *ctxdma;\n\tu32 handle;\n\tu32 unused;\n\tu8  kind;\n\tstruct {\n\t\tstruct nv_dma_v0 base;\n\t\tunion {\n\t\t\tstruct nv50_dma_v0 nv50;\n\t\t\tstruct gf100_dma_v0 gf100;\n\t\t\tstruct gf119_dma_v0 gf119;\n\t\t};\n\t} args = {};\n\tu32 argc = sizeof(args.base);\n\tint ret;\n\n\tnouveau_framebuffer_get_layout(fb, &unused, &kind);\n\thandle = NV50_DISP_HANDLE_WNDW_CTX(kind);\n\n\tlist_for_each_entry(ctxdma, &wndw->ctxdma.list, head) {\n\t\tif (ctxdma->object.handle == handle)\n\t\t\treturn ctxdma;\n\t}\n\n\tif (!(ctxdma = kzalloc(sizeof(*ctxdma), GFP_KERNEL)))\n\t\treturn ERR_PTR(-ENOMEM);\n\tlist_add(&ctxdma->head, &wndw->ctxdma.list);\n\n\targs.base.target = NV_DMA_V0_TARGET_VRAM;\n\targs.base.access = NV_DMA_V0_ACCESS_RDWR;\n\targs.base.start  = 0;\n\targs.base.limit  = drm->client.device.info.ram_user - 1;\n\n\tif (drm->client.device.info.chipset < 0x80) {\n\t\targs.nv50.part = NV50_DMA_V0_PART_256;\n\t\targc += sizeof(args.nv50);\n\t} else\n\tif (drm->client.device.info.chipset < 0xc0) {\n\t\targs.nv50.part = NV50_DMA_V0_PART_256;\n\t\targs.nv50.kind = kind;\n\t\targc += sizeof(args.nv50);\n\t} else\n\tif (drm->client.device.info.chipset < 0xd0) {\n\t\targs.gf100.kind = kind;\n\t\targc += sizeof(args.gf100);\n\t} else {\n\t\targs.gf119.page = GF119_DMA_V0_PAGE_LP;\n\t\targs.gf119.kind = kind;\n\t\targc += sizeof(args.gf119);\n\t}\n\n\tret = nvif_object_ctor(wndw->ctxdma.parent, \"kmsFbCtxDma\", handle,\n\t\t\t       NV_DMA_IN_MEMORY, &args, argc, &ctxdma->object);\n\tif (ret) {\n\t\tnv50_wndw_ctxdma_del(ctxdma);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn ctxdma;\n}\n\nint\nnv50_wndw_wait_armed(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nv50_disp *disp = nv50_disp(wndw->plane.dev);\n\tif (asyw->set.ntfy) {\n\t\treturn wndw->func->ntfy_wait_begun(disp->sync,\n\t\t\t\t\t\t   asyw->ntfy.offset,\n\t\t\t\t\t\t   wndw->wndw.base.device);\n\t}\n\treturn 0;\n}\n\nvoid\nnv50_wndw_flush_clr(struct nv50_wndw *wndw, u32 *interlock, bool flush,\n\t\t    struct nv50_wndw_atom *asyw)\n{\n\tunion nv50_wndw_atom_mask clr = {\n\t\t.mask = asyw->clr.mask & ~(flush ? 0 : asyw->set.mask),\n\t};\n\tif (clr.sema ) wndw->func-> sema_clr(wndw);\n\tif (clr.ntfy ) wndw->func-> ntfy_clr(wndw);\n\tif (clr.xlut ) wndw->func-> xlut_clr(wndw);\n\tif (clr.csc  ) wndw->func->  csc_clr(wndw);\n\tif (clr.image) wndw->func->image_clr(wndw);\n\n\tinterlock[wndw->interlock.type] |= wndw->interlock.data;\n}\n\nvoid\nnv50_wndw_flush_set(struct nv50_wndw *wndw, u32 *interlock,\n\t\t    struct nv50_wndw_atom *asyw)\n{\n\tif (interlock[NV50_DISP_INTERLOCK_CORE]) {\n\t\tasyw->image.mode = NV507C_SET_PRESENT_CONTROL_BEGIN_MODE_NON_TEARING;\n\t\tasyw->image.interval = 1;\n\t}\n\n\tif (asyw->set.sema ) wndw->func->sema_set (wndw, asyw);\n\tif (asyw->set.ntfy ) wndw->func->ntfy_set (wndw, asyw);\n\tif (asyw->set.image) wndw->func->image_set(wndw, asyw);\n\n\tif (asyw->set.xlut ) {\n\t\tif (asyw->ilut) {\n\t\t\tasyw->xlut.i.offset =\n\t\t\t\tnv50_lut_load(&wndw->ilut, asyw->xlut.i.buffer,\n\t\t\t\t\t      asyw->ilut, asyw->xlut.i.load);\n\t\t}\n\t\twndw->func->xlut_set(wndw, asyw);\n\t}\n\n\tif (asyw->set.csc  ) wndw->func->csc_set  (wndw, asyw);\n\tif (asyw->set.scale) wndw->func->scale_set(wndw, asyw);\n\tif (asyw->set.blend) wndw->func->blend_set(wndw, asyw);\n\tif (asyw->set.point) {\n\t\tif (asyw->set.point = false, asyw->set.mask)\n\t\t\tinterlock[wndw->interlock.type] |= wndw->interlock.data;\n\t\tinterlock[NV50_DISP_INTERLOCK_WIMM] |= wndw->interlock.wimm;\n\n\t\twndw->immd->point(wndw, asyw);\n\t\twndw->immd->update(wndw, interlock);\n\t} else {\n\t\tinterlock[wndw->interlock.type] |= wndw->interlock.data;\n\t}\n}\n\nvoid\nnv50_wndw_ntfy_enable(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nv50_disp *disp = nv50_disp(wndw->plane.dev);\n\n\tasyw->ntfy.handle = wndw->wndw.sync.handle;\n\tasyw->ntfy.offset = wndw->ntfy;\n\tasyw->ntfy.awaken = false;\n\tasyw->set.ntfy = true;\n\n\twndw->func->ntfy_reset(disp->sync, wndw->ntfy);\n\twndw->ntfy ^= 0x10;\n}\n\nstatic void\nnv50_wndw_atomic_check_release(struct nv50_wndw *wndw,\n\t\t\t       struct nv50_wndw_atom *asyw,\n\t\t\t       struct nv50_head_atom *asyh)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(wndw->plane.dev);\n\tNV_ATOMIC(drm, \"%s release\\n\", wndw->plane.name);\n\twndw->func->release(wndw, asyw, asyh);\n\tasyw->ntfy.handle = 0;\n\tasyw->sema.handle = 0;\n\tasyw->xlut.handle = 0;\n\tmemset(asyw->image.handle, 0x00, sizeof(asyw->image.handle));\n}\n\nstatic int\nnv50_wndw_atomic_check_acquire_yuv(struct nv50_wndw_atom *asyw)\n{\n\tswitch (asyw->state.fb->format->format) {\n\tcase DRM_FORMAT_YUYV:\n\t\tasyw->image.format = NV507E_SURFACE_SET_PARAMS_FORMAT_VE8YO8UE8YE8;\n\t\tbreak;\n\tcase DRM_FORMAT_UYVY:\n\t\tasyw->image.format = NV507E_SURFACE_SET_PARAMS_FORMAT_YO8VE8YE8UE8;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tasyw->image.colorspace = NV507E_SURFACE_SET_PARAMS_COLOR_SPACE_YUV_601;\n\treturn 0;\n}\n\nstatic int\nnv50_wndw_atomic_check_acquire_rgb(struct nv50_wndw_atom *asyw)\n{\n\tswitch (asyw->state.fb->format->format) {\n\tcase DRM_FORMAT_C8:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_I8;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ARGB8888:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_A8R8G8B8;\n\t\tbreak;\n\tcase DRM_FORMAT_RGB565:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_R5G6B5;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB1555:\n\tcase DRM_FORMAT_ARGB1555:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_A1R5G5B5;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_A2B10G10R10;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_ABGR8888:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_A8B8G8R8;\n\t\tbreak;\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\t\tasyw->image.format = NVC37E_SET_PARAMS_FORMAT_A2R10G10B10;\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\t\tasyw->image.format = NV507C_SURFACE_SET_PARAMS_FORMAT_RF16_GF16_BF16_AF16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tasyw->image.colorspace = NV507E_SURFACE_SET_PARAMS_COLOR_SPACE_RGB;\n\treturn 0;\n}\n\nstatic int\nnv50_wndw_atomic_check_acquire(struct nv50_wndw *wndw, bool modeset,\n\t\t\t       struct nv50_wndw_atom *armw,\n\t\t\t       struct nv50_wndw_atom *asyw,\n\t\t\t       struct nv50_head_atom *asyh)\n{\n\tstruct drm_framebuffer *fb = asyw->state.fb;\n\tstruct nouveau_drm *drm = nouveau_drm(wndw->plane.dev);\n\tuint8_t kind;\n\tuint32_t tile_mode;\n\tint ret;\n\n\tNV_ATOMIC(drm, \"%s acquire\\n\", wndw->plane.name);\n\n\tif (fb != armw->state.fb || !armw->visible || modeset) {\n\t\tnouveau_framebuffer_get_layout(fb, &tile_mode, &kind);\n\n\t\tasyw->image.w = fb->width;\n\t\tasyw->image.h = fb->height;\n\t\tasyw->image.kind = kind;\n\n\t\tret = nv50_wndw_atomic_check_acquire_rgb(asyw);\n\t\tif (ret) {\n\t\t\tret = nv50_wndw_atomic_check_acquire_yuv(asyw);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (asyw->image.kind) {\n\t\t\tasyw->image.layout = NV507C_SURFACE_SET_STORAGE_MEMORY_LAYOUT_BLOCKLINEAR;\n\t\t\tif (drm->client.device.info.chipset >= 0xc0)\n\t\t\t\tasyw->image.blockh = tile_mode >> 4;\n\t\t\telse\n\t\t\t\tasyw->image.blockh = tile_mode;\n\t\t\tasyw->image.blocks[0] = fb->pitches[0] / 64;\n\t\t\tasyw->image.pitch[0] = 0;\n\t\t} else {\n\t\t\tasyw->image.layout = NV507C_SURFACE_SET_STORAGE_MEMORY_LAYOUT_PITCH;\n\t\t\tasyw->image.blockh = NV507C_SURFACE_SET_STORAGE_BLOCK_HEIGHT_ONE_GOB;\n\t\t\tasyw->image.blocks[0] = 0;\n\t\t\tasyw->image.pitch[0] = fb->pitches[0];\n\t\t}\n\n\t\tif (!asyh->state.async_flip)\n\t\t\tasyw->image.interval = 1;\n\t\telse\n\t\t\tasyw->image.interval = 0;\n\n\t\tif (asyw->image.interval)\n\t\t\tasyw->image.mode = NV507C_SET_PRESENT_CONTROL_BEGIN_MODE_NON_TEARING;\n\t\telse\n\t\t\tasyw->image.mode = NV507C_SET_PRESENT_CONTROL_BEGIN_MODE_IMMEDIATE;\n\n\t\tasyw->set.image = wndw->func->image_set != NULL;\n\t}\n\n\tif (wndw->func->scale_set) {\n\t\tasyw->scale.sx = asyw->state.src_x >> 16;\n\t\tasyw->scale.sy = asyw->state.src_y >> 16;\n\t\tasyw->scale.sw = asyw->state.src_w >> 16;\n\t\tasyw->scale.sh = asyw->state.src_h >> 16;\n\t\tasyw->scale.dw = asyw->state.crtc_w;\n\t\tasyw->scale.dh = asyw->state.crtc_h;\n\t\tif (memcmp(&armw->scale, &asyw->scale, sizeof(asyw->scale)))\n\t\t\tasyw->set.scale = true;\n\t}\n\n\tif (wndw->func->blend_set) {\n\t\tasyw->blend.depth = 255 - asyw->state.normalized_zpos;\n\t\tasyw->blend.k1 = asyw->state.alpha >> 8;\n\t\tswitch (asyw->state.pixel_blend_mode) {\n\t\tcase DRM_MODE_BLEND_PREMULTI:\n\t\t\tasyw->blend.src_color = NVC37E_SET_COMPOSITION_FACTOR_SELECT_SRC_COLOR_FACTOR_MATCH_SELECT_K1;\n\t\t\tasyw->blend.dst_color = NVC37E_SET_COMPOSITION_FACTOR_SELECT_DST_COLOR_FACTOR_MATCH_SELECT_NEG_K1_TIMES_SRC;\n\t\t\tbreak;\n\t\tcase DRM_MODE_BLEND_COVERAGE:\n\t\t\tasyw->blend.src_color = NVC37E_SET_COMPOSITION_FACTOR_SELECT_SRC_COLOR_FACTOR_MATCH_SELECT_K1_TIMES_SRC;\n\t\t\tasyw->blend.dst_color = NVC37E_SET_COMPOSITION_FACTOR_SELECT_DST_COLOR_FACTOR_MATCH_SELECT_NEG_K1_TIMES_SRC;\n\t\t\tbreak;\n\t\tcase DRM_MODE_BLEND_PIXEL_NONE:\n\t\tdefault:\n\t\t\tasyw->blend.src_color = NVC37E_SET_COMPOSITION_FACTOR_SELECT_SRC_COLOR_FACTOR_MATCH_SELECT_K1;\n\t\t\tasyw->blend.dst_color = NVC37E_SET_COMPOSITION_FACTOR_SELECT_DST_COLOR_FACTOR_MATCH_SELECT_NEG_K1;\n\t\t\tbreak;\n\t\t}\n\t\tif (memcmp(&armw->blend, &asyw->blend, sizeof(asyw->blend)))\n\t\t\tasyw->set.blend = true;\n\t}\n\n\tif (wndw->immd) {\n\t\tasyw->point.x = asyw->state.crtc_x;\n\t\tasyw->point.y = asyw->state.crtc_y;\n\t\tif (memcmp(&armw->point, &asyw->point, sizeof(asyw->point)))\n\t\t\tasyw->set.point = true;\n\t}\n\n\treturn wndw->func->acquire(wndw, asyw, asyh);\n}\n\nstatic int\nnv50_wndw_atomic_check_lut(struct nv50_wndw *wndw,\n\t\t\t   struct nv50_wndw_atom *armw,\n\t\t\t   struct nv50_wndw_atom *asyw,\n\t\t\t   struct nv50_head_atom *asyh)\n{\n\tstruct drm_property_blob *ilut = asyh->state.degamma_lut;\n\n\t \n\tif (!ilut && asyw->state.fb->format->format == DRM_FORMAT_C8) {\n\t\t \n\t\tif (!(ilut = asyh->state.gamma_lut)) {\n\t\t\tasyw->visible = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (wndw->func->ilut)\n\t\t\tasyh->wndw.olut |= BIT(wndw->id);\n\t} else {\n\t\tasyh->wndw.olut &= ~BIT(wndw->id);\n\t}\n\n\tif (!ilut && wndw->func->ilut_identity &&\n\t    asyw->state.fb->format->format != DRM_FORMAT_XBGR16161616F &&\n\t    asyw->state.fb->format->format != DRM_FORMAT_ABGR16161616F) {\n\t\tstatic struct drm_property_blob dummy = {};\n\t\tilut = &dummy;\n\t}\n\n\t \n\tmemset(&asyw->xlut, 0x00, sizeof(asyw->xlut));\n\tif ((asyw->ilut = wndw->func->ilut ? ilut : NULL)) {\n\t\twndw->func->ilut(wndw, asyw, drm_color_lut_size(ilut));\n\t\tasyw->xlut.handle = wndw->wndw.vram.handle;\n\t\tasyw->xlut.i.buffer = !asyw->xlut.i.buffer;\n\t\tasyw->set.xlut = true;\n\t} else {\n\t\tasyw->clr.xlut = armw->xlut.handle != 0;\n\t}\n\n\t \n\tif (wndw->func->olut_core &&\n\t    (!armw->visible || (armw->xlut.handle && !asyw->xlut.handle)))\n\t\tasyw->set.xlut = true;\n\n\tif (wndw->func->csc && asyh->state.ctm) {\n\t\tconst struct drm_color_ctm *ctm = asyh->state.ctm->data;\n\t\twndw->func->csc(wndw, asyw, ctm);\n\t\tasyw->csc.valid = true;\n\t\tasyw->set.csc = true;\n\t} else {\n\t\tasyw->csc.valid = false;\n\t\tasyw->clr.csc = armw->csc.valid;\n\t}\n\n\t \n\tasyh->state.async_flip = false;\n\treturn 0;\n}\n\nstatic int\nnv50_wndw_atomic_check(struct drm_plane *plane,\n\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct nouveau_drm *drm = nouveau_drm(plane->dev);\n\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\tstruct nv50_wndw_atom *armw = nv50_wndw_atom(wndw->plane.state);\n\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(new_plane_state);\n\tstruct nv50_head_atom *harm = NULL, *asyh = NULL;\n\tbool modeset = false;\n\tint ret;\n\n\tNV_ATOMIC(drm, \"%s atomic_check\\n\", plane->name);\n\n\t \n\tif (asyw->state.crtc) {\n\t\tasyh = nv50_head_atom_get(asyw->state.state, asyw->state.crtc);\n\t\tif (IS_ERR(asyh))\n\t\t\treturn PTR_ERR(asyh);\n\t\tmodeset = drm_atomic_crtc_needs_modeset(&asyh->state);\n\t\tasyw->visible = asyh->state.active;\n\t} else {\n\t\tasyw->visible = false;\n\t}\n\n\t \n\tif (armw->state.crtc) {\n\t\tharm = nv50_head_atom_get(asyw->state.state, armw->state.crtc);\n\t\tif (IS_ERR(harm))\n\t\t\treturn PTR_ERR(harm);\n\t}\n\n\t \n\tif (asyw->visible && wndw->func->xlut_set &&\n\t    (!armw->visible ||\n\t     asyh->state.color_mgmt_changed ||\n\t     asyw->state.fb->format->format !=\n\t     armw->state.fb->format->format)) {\n\t\tret = nv50_wndw_atomic_check_lut(wndw, armw, asyw, asyh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (asyw->visible) {\n\t\tret = nv50_wndw_atomic_check_acquire(wndw, modeset,\n\t\t\t\t\t\t     armw, asyw, asyh);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tasyh->wndw.mask |= BIT(wndw->id);\n\t} else\n\tif (armw->visible) {\n\t\tnv50_wndw_atomic_check_release(wndw, asyw, harm);\n\t\tharm->wndw.mask &= ~BIT(wndw->id);\n\t} else {\n\t\treturn 0;\n\t}\n\n\t \n\tif (!asyw->visible || modeset) {\n\t\tasyw->clr.ntfy = armw->ntfy.handle != 0;\n\t\tasyw->clr.sema = armw->sema.handle != 0;\n\t\tasyw->clr.xlut = armw->xlut.handle != 0;\n\t\tif (asyw->clr.xlut && asyw->visible)\n\t\t\tasyw->set.xlut = asyw->xlut.handle != 0;\n\t\tasyw->clr.csc  = armw->csc.valid;\n\t\tif (wndw->func->image_clr)\n\t\t\tasyw->clr.image = armw->image.handle[0] != 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv50_wndw_cleanup_fb(struct drm_plane *plane, struct drm_plane_state *old_state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(plane->dev);\n\tstruct nouveau_bo *nvbo;\n\n\tNV_ATOMIC(drm, \"%s cleanup: %p\\n\", plane->name, old_state->fb);\n\tif (!old_state->fb)\n\t\treturn;\n\n\tnvbo = nouveau_gem_object(old_state->fb->obj[0]);\n\tnouveau_bo_unpin(nvbo);\n}\n\nstatic int\nnv50_wndw_prepare_fb(struct drm_plane *plane, struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct nouveau_drm *drm = nouveau_drm(plane->dev);\n\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(state);\n\tstruct nouveau_bo *nvbo;\n\tstruct nv50_head_atom *asyh;\n\tstruct nv50_wndw_ctxdma *ctxdma;\n\tint ret;\n\n\tNV_ATOMIC(drm, \"%s prepare: %p\\n\", plane->name, fb);\n\tif (!asyw->state.fb)\n\t\treturn 0;\n\n\tnvbo = nouveau_gem_object(fb->obj[0]);\n\tret = nouveau_bo_pin(nvbo, NOUVEAU_GEM_DOMAIN_VRAM, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (wndw->ctxdma.parent) {\n\t\tctxdma = nv50_wndw_ctxdma_new(wndw, fb);\n\t\tif (IS_ERR(ctxdma)) {\n\t\t\tnouveau_bo_unpin(nvbo);\n\t\t\treturn PTR_ERR(ctxdma);\n\t\t}\n\n\t\tif (asyw->visible)\n\t\t\tasyw->image.handle[0] = ctxdma->object.handle;\n\t}\n\n\tret = drm_gem_plane_helper_prepare_fb(plane, state);\n\tif (ret)\n\t\treturn ret;\n\n\tasyw->image.offset[0] = nvbo->offset;\n\n\tif (wndw->func->prepare) {\n\t\tasyh = nv50_head_atom_get(asyw->state.state, asyw->state.crtc);\n\t\tif (IS_ERR(asyh))\n\t\t\treturn PTR_ERR(asyh);\n\n\t\twndw->func->prepare(wndw, asyh, asyw);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct drm_plane_helper_funcs\nnv50_wndw_helper = {\n\t.prepare_fb = nv50_wndw_prepare_fb,\n\t.cleanup_fb = nv50_wndw_cleanup_fb,\n\t.atomic_check = nv50_wndw_atomic_check,\n};\n\nstatic void\nnv50_wndw_atomic_destroy_state(struct drm_plane *plane,\n\t\t\t       struct drm_plane_state *state)\n{\n\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(state);\n\t__drm_atomic_helper_plane_destroy_state(&asyw->state);\n\tkfree(asyw);\n}\n\nstatic struct drm_plane_state *\nnv50_wndw_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct nv50_wndw_atom *armw = nv50_wndw_atom(plane->state);\n\tstruct nv50_wndw_atom *asyw;\n\tif (!(asyw = kmalloc(sizeof(*asyw), GFP_KERNEL)))\n\t\treturn NULL;\n\t__drm_atomic_helper_plane_duplicate_state(plane, &asyw->state);\n\tasyw->sema = armw->sema;\n\tasyw->ntfy = armw->ntfy;\n\tasyw->ilut = NULL;\n\tasyw->xlut = armw->xlut;\n\tasyw->csc  = armw->csc;\n\tasyw->image = armw->image;\n\tasyw->point = armw->point;\n\tasyw->clr.mask = 0;\n\tasyw->set.mask = 0;\n\treturn &asyw->state;\n}\n\nstatic int\nnv50_wndw_zpos_default(struct drm_plane *plane)\n{\n\treturn (plane->type == DRM_PLANE_TYPE_PRIMARY) ? 0 :\n\t       (plane->type == DRM_PLANE_TYPE_OVERLAY) ? 1 : 255;\n}\n\nstatic void\nnv50_wndw_reset(struct drm_plane *plane)\n{\n\tstruct nv50_wndw_atom *asyw;\n\n\tif (WARN_ON(!(asyw = kzalloc(sizeof(*asyw), GFP_KERNEL))))\n\t\treturn;\n\n\tif (plane->state)\n\t\tplane->funcs->atomic_destroy_state(plane, plane->state);\n\n\t__drm_atomic_helper_plane_reset(plane, &asyw->state);\n}\n\nstatic void\nnv50_wndw_destroy(struct drm_plane *plane)\n{\n\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\tstruct nv50_wndw_ctxdma *ctxdma, *ctxtmp;\n\n\tlist_for_each_entry_safe(ctxdma, ctxtmp, &wndw->ctxdma.list, head) {\n\t\tnv50_wndw_ctxdma_del(ctxdma);\n\t}\n\n\tnv50_dmac_destroy(&wndw->wimm);\n\tnv50_dmac_destroy(&wndw->wndw);\n\n\tnv50_lut_fini(&wndw->ilut);\n\n\tdrm_plane_cleanup(&wndw->plane);\n\tkfree(wndw);\n}\n\n \nstatic bool nv50_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t\t    u32 format, u64 modifier)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(plane->dev);\n\tuint8_t i;\n\n\tif (drm->client.device.info.chipset < 0xc0) {\n\t\tconst struct drm_format_info *info = drm_format_info(format);\n\t\tconst uint8_t kind = (modifier >> 12) & 0xff;\n\n\t\tif (!format) return false;\n\n\t\tfor (i = 0; i < info->num_planes; i++)\n\t\t\tif ((info->cpp[i] != 4) && kind != 0x70) return false;\n\t}\n\n\treturn true;\n}\n\nconst struct drm_plane_funcs\nnv50_wndw = {\n\t.update_plane = drm_atomic_helper_update_plane,\n\t.disable_plane = drm_atomic_helper_disable_plane,\n\t.destroy = nv50_wndw_destroy,\n\t.reset = nv50_wndw_reset,\n\t.atomic_duplicate_state = nv50_wndw_atomic_duplicate_state,\n\t.atomic_destroy_state = nv50_wndw_atomic_destroy_state,\n\t.format_mod_supported = nv50_plane_format_mod_supported,\n};\n\nstatic const u64 nv50_cursor_format_modifiers[] = {\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID,\n};\n\nint\nnv50_wndw_new_(const struct nv50_wndw_func *func, struct drm_device *dev,\n\t       enum drm_plane_type type, const char *name, int index,\n\t       const u32 *format, u32 heads,\n\t       enum nv50_disp_interlock_type interlock_type, u32 interlock_data,\n\t       struct nv50_wndw **pwndw)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_mmu *mmu = &drm->client.mmu;\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tstruct nv50_wndw *wndw;\n\tconst u64 *format_modifiers;\n\tint nformat;\n\tint ret;\n\n\tif (!(wndw = *pwndw = kzalloc(sizeof(*wndw), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\twndw->func = func;\n\twndw->id = index;\n\twndw->interlock.type = interlock_type;\n\twndw->interlock.data = interlock_data;\n\n\twndw->ctxdma.parent = &wndw->wndw.base.user;\n\tINIT_LIST_HEAD(&wndw->ctxdma.list);\n\n\tfor (nformat = 0; format[nformat]; nformat++);\n\n\tif (type == DRM_PLANE_TYPE_CURSOR)\n\t\tformat_modifiers = nv50_cursor_format_modifiers;\n\telse\n\t\tformat_modifiers = nouveau_display(dev)->format_modifiers;\n\n\tret = drm_universal_plane_init(dev, &wndw->plane, heads, &nv50_wndw, format, nformat,\n\t\t\t\t       format_modifiers, type, \"%s-%d\", name, index);\n\tif (ret) {\n\t\tkfree(*pwndw);\n\t\t*pwndw = NULL;\n\t\treturn ret;\n\t}\n\n\tdrm_plane_helper_add(&wndw->plane, &nv50_wndw_helper);\n\n\tif (wndw->func->ilut) {\n\t\tret = nv50_lut_init(disp, mmu, &wndw->ilut);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wndw->func->blend_set) {\n\t\tret = drm_plane_create_zpos_property(&wndw->plane,\n\t\t\t\tnv50_wndw_zpos_default(&wndw->plane), 0, 254);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drm_plane_create_alpha_property(&wndw->plane);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drm_plane_create_blend_mode_property(&wndw->plane,\n\t\t\t\tBIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\t\tBIT(DRM_MODE_BLEND_PREMULTI) |\n\t\t\t\tBIT(DRM_MODE_BLEND_COVERAGE));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = drm_plane_create_zpos_immutable_property(&wndw->plane,\n\t\t\t\tnv50_wndw_zpos_default(&wndw->plane));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint\nnv50_wndw_new(struct nouveau_drm *drm, enum drm_plane_type type, int index,\n\t      struct nv50_wndw **pwndw)\n{\n\tstruct {\n\t\ts32 oclass;\n\t\tint version;\n\t\tint (*new)(struct nouveau_drm *, enum drm_plane_type,\n\t\t\t   int, s32, struct nv50_wndw **);\n\t} wndws[] = {\n\t\t{ GA102_DISP_WINDOW_CHANNEL_DMA, 0, wndwc67e_new },\n\t\t{ TU102_DISP_WINDOW_CHANNEL_DMA, 0, wndwc57e_new },\n\t\t{ GV100_DISP_WINDOW_CHANNEL_DMA, 0, wndwc37e_new },\n\t\t{}\n\t};\n\tstruct nv50_disp *disp = nv50_disp(drm->dev);\n\tint cid, ret;\n\n\tcid = nvif_mclass(&disp->disp->object, wndws);\n\tif (cid < 0) {\n\t\tNV_ERROR(drm, \"No supported window class\\n\");\n\t\treturn cid;\n\t}\n\n\tret = wndws[cid].new(drm, type, index, wndws[cid].oclass, pwndw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nv50_wimm_init(drm, *pwndw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}