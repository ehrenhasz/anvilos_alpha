{
  "module_name": "crc.c",
  "hash_id": "95e6bc33087442186b21e75638926582948b2be56136f40f9689bffa5a256aa1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/crc.c",
  "human_readable_source": "\n#include <linux/string.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_vblank_work.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n#include <nvif/timer.h>\n\n#include <nvhw/class/cl907d.h>\n\n#include \"nouveau_drv.h\"\n#include \"core.h\"\n#include \"head.h\"\n#include \"wndw.h\"\n#include \"handles.h\"\n#include \"crc.h\"\n\nstatic const char * const nv50_crc_sources[] = {\n\t[NV50_CRC_SOURCE_NONE] = \"none\",\n\t[NV50_CRC_SOURCE_AUTO] = \"auto\",\n\t[NV50_CRC_SOURCE_RG] = \"rg\",\n\t[NV50_CRC_SOURCE_OUTP_ACTIVE] = \"outp-active\",\n\t[NV50_CRC_SOURCE_OUTP_COMPLETE] = \"outp-complete\",\n\t[NV50_CRC_SOURCE_OUTP_INACTIVE] = \"outp-inactive\",\n};\n\nstatic int nv50_crc_parse_source(const char *buf, enum nv50_crc_source *s)\n{\n\tint i;\n\n\tif (!buf) {\n\t\t*s = NV50_CRC_SOURCE_NONE;\n\t\treturn 0;\n\t}\n\n\ti = match_string(nv50_crc_sources, ARRAY_SIZE(nv50_crc_sources), buf);\n\tif (i < 0)\n\t\treturn i;\n\n\t*s = i;\n\treturn 0;\n}\n\nint\nnv50_crc_verify_source(struct drm_crtc *crtc, const char *source_name,\n\t\t       size_t *values_cnt)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\n\tenum nv50_crc_source source;\n\n\tif (nv50_crc_parse_source(source_name, &source) < 0) {\n\t\tNV_DEBUG(drm, \"unknown source %s\\n\", source_name);\n\t\treturn -EINVAL;\n\t}\n\n\t*values_cnt = 1;\n\treturn 0;\n}\n\nconst char *const *nv50_crc_get_sources(struct drm_crtc *crtc, size_t *count)\n{\n\t*count = ARRAY_SIZE(nv50_crc_sources);\n\treturn nv50_crc_sources;\n}\n\nstatic void\nnv50_crc_program_ctx(struct nv50_head *head,\n\t\t     struct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nv50_disp *disp = nv50_disp(head->base.base.dev);\n\tstruct nv50_core *core = disp->core;\n\tu32 interlock[NV50_DISP_INTERLOCK__SIZE] = { 0 };\n\n\tcore->func->crc->set_ctx(head, ctx);\n\tcore->func->update(core, interlock, false);\n}\n\nstatic void nv50_crc_ctx_flip_work(struct kthread_work *base)\n{\n\tstruct drm_vblank_work *work = to_drm_vblank_work(base);\n\tstruct nv50_crc *crc = container_of(work, struct nv50_crc, flip_work);\n\tstruct nv50_head *head = container_of(crc, struct nv50_head, crc);\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tconst uint64_t start_vbl = drm_crtc_vblank_count(crtc);\n\tuint64_t end_vbl;\n\tu8 new_idx = crc->ctx_idx ^ 1;\n\n\t \n\tif (!mutex_trylock(&disp->mutex)) {\n\t\tdrm_dbg_kms(dev, \"Lock contended, delaying CRC ctx flip for %s\\n\", crtc->name);\n\t\tdrm_vblank_work_schedule(work, start_vbl + 1, true);\n\t\treturn;\n\t}\n\n\tdrm_dbg_kms(dev, \"Flipping notifier ctx for %s (%d -> %d)\\n\",\n\t\t    crtc->name, crc->ctx_idx, new_idx);\n\n\tnv50_crc_program_ctx(head, NULL);\n\tnv50_crc_program_ctx(head, &crc->ctx[new_idx]);\n\tmutex_unlock(&disp->mutex);\n\n\tend_vbl = drm_crtc_vblank_count(crtc);\n\tif (unlikely(end_vbl != start_vbl))\n\t\tNV_ERROR(nouveau_drm(dev),\n\t\t\t \"Failed to flip CRC context on %s on time (%llu > %llu)\\n\",\n\t\t\t crtc->name, end_vbl, start_vbl);\n\n\tspin_lock_irq(&crc->lock);\n\tcrc->ctx_changed = true;\n\tspin_unlock_irq(&crc->lock);\n}\n\nstatic inline void nv50_crc_reset_ctx(struct nv50_crc_notifier_ctx *ctx)\n{\n\tmemset_io(ctx->mem.object.map.ptr, 0, ctx->mem.object.map.size);\n}\n\nstatic void\nnv50_crc_get_entries(struct nv50_head *head,\n\t\t     const struct nv50_crc_func *func,\n\t\t     enum nv50_crc_source source)\n{\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct nv50_crc *crc = &head->crc;\n\tu32 output_crc;\n\n\twhile (crc->entry_idx < func->num_entries) {\n\t\t \n\t\toutput_crc = func->get_entry(head, &crc->ctx[crc->ctx_idx],\n\t\t\t\t\t     source, crc->entry_idx);\n\t\tif (!output_crc)\n\t\t\treturn;\n\n\t\tdrm_crtc_add_crc_entry(crtc, true, crc->frame, &output_crc);\n\t\tcrc->frame++;\n\t\tcrc->entry_idx++;\n\t}\n}\n\nvoid nv50_crc_handle_vblank(struct nv50_head *head)\n{\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct nv50_crc *crc = &head->crc;\n\tconst struct nv50_crc_func *func =\n\t\tnv50_disp(head->base.base.dev)->core->func->crc;\n\tstruct nv50_crc_notifier_ctx *ctx;\n\tbool need_reschedule = false;\n\n\tif (!func)\n\t\treturn;\n\n\t \n\tif (!spin_trylock(&crc->lock))\n\t\treturn;\n\n\tif (!crc->src)\n\t\tgoto out;\n\n\tctx = &crc->ctx[crc->ctx_idx];\n\tif (crc->ctx_changed && func->ctx_finished(head, ctx)) {\n\t\tnv50_crc_get_entries(head, func, crc->src);\n\n\t\tcrc->ctx_idx ^= 1;\n\t\tcrc->entry_idx = 0;\n\t\tcrc->ctx_changed = false;\n\n\t\t \n\t\tdrm_dbg_kms(head->base.base.dev,\n\t\t\t    \"Notifier ctx flip for head-%d finished, lost CRC for frame %llu\\n\",\n\t\t\t    head->base.index, crc->frame);\n\t\tcrc->frame++;\n\n\t\tnv50_crc_reset_ctx(ctx);\n\t\tneed_reschedule = true;\n\t}\n\n\tnv50_crc_get_entries(head, func, crc->src);\n\n\tif (need_reschedule)\n\t\tdrm_vblank_work_schedule(&crc->flip_work,\n\t\t\t\t\t drm_crtc_vblank_count(crtc)\n\t\t\t\t\t + crc->flip_threshold\n\t\t\t\t\t - crc->entry_idx,\n\t\t\t\t\t true);\n\nout:\n\tspin_unlock(&crc->lock);\n}\n\nstatic void nv50_crc_wait_ctx_finished(struct nv50_head *head,\n\t\t\t\t       const struct nv50_crc_func *func,\n\t\t\t\t       struct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct drm_device *dev = head->base.base.dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\ts64 ret;\n\n\tret = nvif_msec(&drm->client.device, 50,\n\t\t\tif (func->ctx_finished(head, ctx)) break;);\n\tif (ret == -ETIMEDOUT)\n\t\tNV_ERROR(drm,\n\t\t\t \"CRC notifier ctx for head %d not finished after 50ms\\n\",\n\t\t\t head->base.index);\n\telse if (ret)\n\t\tNV_ATOMIC(drm,\n\t\t\t  \"CRC notifier ctx for head-%d finished after %lldns\\n\",\n\t\t\t  head->base.index, ret);\n}\n\nvoid nv50_crc_atomic_stop_reporting(struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(crtc_state);\n\t\tstruct nv50_crc *crc = &head->crc;\n\n\t\tif (!asyh->clr.crc)\n\t\t\tcontinue;\n\n\t\tspin_lock_irq(&crc->lock);\n\t\tcrc->src = NV50_CRC_SOURCE_NONE;\n\t\tspin_unlock_irq(&crc->lock);\n\n\t\tdrm_crtc_vblank_put(crtc);\n\t\tdrm_vblank_work_cancel_sync(&crc->flip_work);\n\n\t\tNV_ATOMIC(nouveau_drm(crtc->dev),\n\t\t\t  \"CRC reporting on vblank for head-%d disabled\\n\",\n\t\t\t  head->base.index);\n\n\t\t \n\t}\n}\n\nvoid nv50_crc_atomic_init_notifier_contexts(struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);\n\t\tstruct nv50_crc *crc = &head->crc;\n\t\tint i;\n\n\t\tif (!asyh->set.crc)\n\t\t\tcontinue;\n\n\t\tcrc->entry_idx = 0;\n\t\tcrc->ctx_changed = false;\n\t\tfor (i = 0; i < ARRAY_SIZE(crc->ctx); i++)\n\t\t\tnv50_crc_reset_ctx(&crc->ctx[i]);\n\t}\n}\n\nvoid nv50_crc_atomic_release_notifier_contexts(struct drm_atomic_state *state)\n{\n\tconst struct nv50_crc_func *func =\n\t\tnv50_disp(state->dev)->core->func->crc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);\n\t\tstruct nv50_crc *crc = &head->crc;\n\t\tstruct nv50_crc_notifier_ctx *ctx = &crc->ctx[crc->ctx_idx];\n\n\t\tif (!asyh->clr.crc)\n\t\t\tcontinue;\n\n\t\tif (crc->ctx_changed) {\n\t\t\tnv50_crc_wait_ctx_finished(head, func, ctx);\n\t\t\tctx = &crc->ctx[crc->ctx_idx ^ 1];\n\t\t}\n\t\tnv50_crc_wait_ctx_finished(head, func, ctx);\n\t}\n}\n\nvoid nv50_crc_atomic_start_reporting(struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(crtc_state);\n\t\tstruct nv50_crc *crc = &head->crc;\n\t\tu64 vbl_count;\n\n\t\tif (!asyh->set.crc)\n\t\t\tcontinue;\n\n\t\tdrm_crtc_vblank_get(crtc);\n\n\t\tspin_lock_irq(&crc->lock);\n\t\tvbl_count = drm_crtc_vblank_count(crtc);\n\t\tcrc->frame = vbl_count;\n\t\tcrc->src = asyh->crc.src;\n\t\tdrm_vblank_work_schedule(&crc->flip_work,\n\t\t\t\t\t vbl_count + crc->flip_threshold,\n\t\t\t\t\t true);\n\t\tspin_unlock_irq(&crc->lock);\n\n\t\tNV_ATOMIC(nouveau_drm(crtc->dev),\n\t\t\t  \"CRC reporting on vblank for head-%d enabled\\n\",\n\t\t\t  head->base.index);\n\t}\n}\n\nint nv50_crc_atomic_check_head(struct nv50_head *head,\n\t\t\t       struct nv50_head_atom *asyh,\n\t\t\t       struct nv50_head_atom *armh)\n{\n\tstruct nv50_atom *atom = nv50_atom(asyh->state.state);\n\tbool changed = armh->crc.src != asyh->crc.src;\n\n\tif (!armh->crc.src && !asyh->crc.src) {\n\t\tasyh->set.crc = false;\n\t\tasyh->clr.crc = false;\n\t\treturn 0;\n\t}\n\n\tif (drm_atomic_crtc_needs_modeset(&asyh->state) || changed) {\n\t\tasyh->clr.crc = armh->crc.src && armh->state.active;\n\t\tasyh->set.crc = asyh->crc.src && asyh->state.active;\n\t\tif (changed)\n\t\t\tasyh->set.or |= armh->or.crc_raster !=\n\t\t\t\t\tasyh->or.crc_raster;\n\n\t\tif (asyh->clr.crc && asyh->set.crc)\n\t\t\tatom->flush_disable = true;\n\t} else {\n\t\tasyh->set.crc = false;\n\t\tasyh->clr.crc = false;\n\t}\n\n\treturn 0;\n}\n\nvoid nv50_crc_atomic_check_outp(struct nv50_atom *atom)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tint i;\n\n\tif (atom->flush_disable)\n\t\treturn;\n\n\tfor_each_oldnew_crtc_in_state(&atom->state, crtc, old_crtc_state,\n\t\t\t\t      new_crtc_state, i) {\n\t\tstruct nv50_head_atom *armh = nv50_head_atom(old_crtc_state);\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);\n\t\tstruct nv50_outp_atom *outp_atom;\n\t\tstruct nouveau_encoder *outp;\n\t\tstruct drm_encoder *encoder, *enc;\n\n\t\tenc = nv50_head_atom_get_encoder(armh);\n\t\tif (!enc)\n\t\t\tcontinue;\n\n\t\toutp = nv50_real_outp(enc);\n\t\tif (!outp)\n\t\t\tcontinue;\n\n\t\tencoder = &outp->base.base;\n\n\t\tif (!asyh->clr.crc)\n\t\t\tcontinue;\n\n\t\t \n\t\tlist_for_each_entry(outp_atom, &atom->outp, head) {\n\t\t\tif (outp_atom->encoder == encoder) {\n\t\t\t\tif (outp_atom->set.mask) {\n\t\t\t\t\tatom->flush_disable = true;\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic enum nv50_crc_source_type\nnv50_crc_source_type(struct nouveau_encoder *outp,\n\t\t     enum nv50_crc_source source)\n{\n\tstruct dcb_output *dcbe = outp->dcb;\n\n\tswitch (source) {\n\tcase NV50_CRC_SOURCE_NONE: return NV50_CRC_SOURCE_TYPE_NONE;\n\tcase NV50_CRC_SOURCE_RG:   return NV50_CRC_SOURCE_TYPE_RG;\n\tdefault:\t\t   break;\n\t}\n\n\tif (dcbe->location != DCB_LOC_ON_CHIP)\n\t\treturn NV50_CRC_SOURCE_TYPE_PIOR;\n\n\tswitch (dcbe->type) {\n\tcase DCB_OUTPUT_DP:\treturn NV50_CRC_SOURCE_TYPE_SF;\n\tcase DCB_OUTPUT_ANALOG:\treturn NV50_CRC_SOURCE_TYPE_DAC;\n\tdefault:\t\treturn NV50_CRC_SOURCE_TYPE_SOR;\n\t}\n}\n\nvoid nv50_crc_atomic_set(struct nv50_head *head,\n\t\t\t struct nv50_head_atom *asyh)\n{\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nv50_crc *crc = &head->crc;\n\tconst struct nv50_crc_func *func = nv50_disp(dev)->core->func->crc;\n\tstruct nouveau_encoder *outp;\n\tstruct drm_encoder *encoder;\n\n\tencoder = nv50_head_atom_get_encoder(asyh);\n\tif (!encoder)\n\t\treturn;\n\n\toutp = nv50_real_outp(encoder);\n\tif (!outp)\n\t\treturn;\n\n\tfunc->set_src(head, outp->outp.or.id, nv50_crc_source_type(outp, asyh->crc.src),\n\t\t      &crc->ctx[crc->ctx_idx]);\n}\n\nvoid nv50_crc_atomic_clr(struct nv50_head *head)\n{\n\tconst struct nv50_crc_func *func =\n\t\tnv50_disp(head->base.base.dev)->core->func->crc;\n\n\tfunc->set_src(head, 0, NV50_CRC_SOURCE_TYPE_NONE, NULL);\n}\n\nstatic inline int\nnv50_crc_raster_type(enum nv50_crc_source source)\n{\n\tswitch (source) {\n\tcase NV50_CRC_SOURCE_NONE:\n\tcase NV50_CRC_SOURCE_AUTO:\n\tcase NV50_CRC_SOURCE_RG:\n\tcase NV50_CRC_SOURCE_OUTP_ACTIVE:\n\t\treturn NV907D_HEAD_SET_CONTROL_OUTPUT_RESOURCE_CRC_MODE_ACTIVE_RASTER;\n\tcase NV50_CRC_SOURCE_OUTP_COMPLETE:\n\t\treturn NV907D_HEAD_SET_CONTROL_OUTPUT_RESOURCE_CRC_MODE_COMPLETE_RASTER;\n\tcase NV50_CRC_SOURCE_OUTP_INACTIVE:\n\t\treturn NV907D_HEAD_SET_CONTROL_OUTPUT_RESOURCE_CRC_MODE_NON_ACTIVE_RASTER;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline int\nnv50_crc_ctx_init(struct nv50_head *head, struct nvif_mmu *mmu,\n\t\t  struct nv50_crc_notifier_ctx *ctx, size_t len, int idx)\n{\n\tstruct nv50_core *core = nv50_disp(head->base.base.dev)->core;\n\tint ret;\n\n\tret = nvif_mem_ctor_map(mmu, \"kmsCrcNtfy\", NVIF_MEM_VRAM, len, &ctx->mem);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvif_object_ctor(&core->chan.base.user, \"kmsCrcNtfyCtxDma\",\n\t\t\t       NV50_DISP_HANDLE_CRC_CTX(head, idx),\n\t\t\t       NV_DMA_IN_MEMORY,\n\t\t\t       &(struct nv_dma_v0) {\n\t\t\t\t\t.target = NV_DMA_V0_TARGET_VRAM,\n\t\t\t\t\t.access = NV_DMA_V0_ACCESS_RDWR,\n\t\t\t\t\t.start = ctx->mem.addr,\n\t\t\t\t\t.limit =  ctx->mem.addr\n\t\t\t\t\t\t+ ctx->mem.size - 1,\n\t\t\t       }, sizeof(struct nv_dma_v0),\n\t\t\t       &ctx->ntfy);\n\tif (ret)\n\t\tgoto fail_fini;\n\n\treturn 0;\n\nfail_fini:\n\tnvif_mem_dtor(&ctx->mem);\n\treturn ret;\n}\n\nstatic inline void\nnv50_crc_ctx_fini(struct nv50_crc_notifier_ctx *ctx)\n{\n\tnvif_object_dtor(&ctx->ntfy);\n\tnvif_mem_dtor(&ctx->mem);\n}\n\nint nv50_crc_set_source(struct drm_crtc *crtc, const char *source_str)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_atomic_state *state;\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct nv50_head *head = nv50_head(crtc);\n\tstruct nv50_crc *crc = &head->crc;\n\tconst struct nv50_crc_func *func = nv50_disp(dev)->core->func->crc;\n\tstruct nvif_mmu *mmu = &nouveau_drm(dev)->client.mmu;\n\tstruct nv50_head_atom *asyh;\n\tstruct drm_crtc_state *crtc_state;\n\tenum nv50_crc_source source;\n\tint ret = 0, ctx_flags = 0, i;\n\n\tret = nv50_crc_parse_source(source_str, &source);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (source)\n\t\tctx_flags |= DRM_MODESET_ACQUIRE_INTERRUPTIBLE;\n\tdrm_modeset_acquire_init(&ctx, ctx_flags);\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state) {\n\t\tret = -ENOMEM;\n\t\tgoto out_acquire_fini;\n\t}\n\tstate->acquire_ctx = &ctx;\n\n\tif (source) {\n\t\tfor (i = 0; i < ARRAY_SIZE(head->crc.ctx); i++) {\n\t\t\tret = nv50_crc_ctx_init(head, mmu, &crc->ctx[i],\n\t\t\t\t\t\tfunc->notifier_len, i);\n\t\t\tif (ret)\n\t\t\t\tgoto out_ctx_fini;\n\t\t}\n\t}\n\nretry:\n\tcrtc_state = drm_atomic_get_crtc_state(state, &head->base.base);\n\tif (IS_ERR(crtc_state)) {\n\t\tret = PTR_ERR(crtc_state);\n\t\tif (ret == -EDEADLK)\n\t\t\tgoto deadlock;\n\t\telse if (ret)\n\t\t\tgoto out_drop_locks;\n\t}\n\tasyh = nv50_head_atom(crtc_state);\n\tasyh->crc.src = source;\n\tasyh->or.crc_raster = nv50_crc_raster_type(source);\n\n\tret = drm_atomic_commit(state);\n\tif (ret == -EDEADLK)\n\t\tgoto deadlock;\n\telse if (ret)\n\t\tgoto out_drop_locks;\n\n\tif (!source) {\n\t\t \n\t\tcrc->flip_threshold = func->flip_threshold;\n\t}\n\nout_drop_locks:\n\tdrm_modeset_drop_locks(&ctx);\nout_ctx_fini:\n\tif (!source || ret) {\n\t\tfor (i = 0; i < ARRAY_SIZE(crc->ctx); i++)\n\t\t\tnv50_crc_ctx_fini(&crc->ctx[i]);\n\t}\n\tdrm_atomic_state_put(state);\nout_acquire_fini:\n\tdrm_modeset_acquire_fini(&ctx);\n\treturn ret;\n\ndeadlock:\n\tdrm_atomic_state_clear(state);\n\tdrm_modeset_backoff(&ctx);\n\tgoto retry;\n}\n\nstatic int\nnv50_crc_debugfs_flip_threshold_get(struct seq_file *m, void *data)\n{\n\tstruct nv50_head *head = m->private;\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct nv50_crc *crc = &head->crc;\n\tint ret;\n\n\tret = drm_modeset_lock_single_interruptible(&crtc->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tseq_printf(m, \"%d\\n\", crc->flip_threshold);\n\n\tdrm_modeset_unlock(&crtc->mutex);\n\treturn ret;\n}\n\nstatic int\nnv50_crc_debugfs_flip_threshold_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, nv50_crc_debugfs_flip_threshold_get,\n\t\t\t   inode->i_private);\n}\n\nstatic ssize_t\nnv50_crc_debugfs_flip_threshold_set(struct file *file,\n\t\t\t\t    const char __user *ubuf, size_t len,\n\t\t\t\t    loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct nv50_head *head = m->private;\n\tstruct nv50_head_atom *armh;\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\n\tstruct nv50_crc *crc = &head->crc;\n\tconst struct nv50_crc_func *func =\n\t\tnv50_disp(crtc->dev)->core->func->crc;\n\tint value, ret;\n\n\tret = kstrtoint_from_user(ubuf, len, 10, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value > func->flip_threshold)\n\t\treturn -EINVAL;\n\telse if (value == -1)\n\t\tvalue = func->flip_threshold;\n\telse if (value < -1)\n\t\treturn -EINVAL;\n\n\tret = drm_modeset_lock_single_interruptible(&crtc->mutex);\n\tif (ret)\n\t\treturn ret;\n\n\tarmh = nv50_head_atom(crtc->state);\n\tif (armh->crc.src) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tNV_DEBUG(drm,\n\t\t \"Changing CRC flip threshold for next capture on head-%d to %d\\n\",\n\t\t head->base.index, value);\n\tcrc->flip_threshold = value;\n\tret = len;\n\nout:\n\tdrm_modeset_unlock(&crtc->mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations nv50_crc_flip_threshold_fops = {\n\t.owner = THIS_MODULE,\n\t.open = nv50_crc_debugfs_flip_threshold_open,\n\t.read = seq_read,\n\t.write = nv50_crc_debugfs_flip_threshold_set,\n\t.release = single_release,\n};\n\nint nv50_head_crc_late_register(struct nv50_head *head)\n{\n\tstruct drm_crtc *crtc = &head->base.base;\n\tconst struct nv50_crc_func *func =\n\t\tnv50_disp(crtc->dev)->core->func->crc;\n\tstruct dentry *root;\n\n\tif (!func || !crtc->debugfs_entry)\n\t\treturn 0;\n\n\troot = debugfs_create_dir(\"nv_crc\", crtc->debugfs_entry);\n\tdebugfs_create_file(\"flip_threshold\", 0644, root, head,\n\t\t\t    &nv50_crc_flip_threshold_fops);\n\n\treturn 0;\n}\n\nstatic inline void\nnv50_crc_init_head(struct nv50_disp *disp, const struct nv50_crc_func *func,\n\t\t   struct nv50_head *head)\n{\n\tstruct nv50_crc *crc = &head->crc;\n\n\tcrc->flip_threshold = func->flip_threshold;\n\tspin_lock_init(&crc->lock);\n\tdrm_vblank_work_init(&crc->flip_work, &head->base.base,\n\t\t\t     nv50_crc_ctx_flip_work);\n}\n\nvoid nv50_crc_init(struct drm_device *dev)\n{\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tstruct drm_crtc *crtc;\n\tconst struct nv50_crc_func *func = disp->core->func->crc;\n\n\tif (!func)\n\t\treturn;\n\n\tdrm_for_each_crtc(crtc, dev)\n\t\tnv50_crc_init_head(disp, func, nv50_head(crtc));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}