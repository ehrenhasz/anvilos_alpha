{
  "module_name": "disp.c",
  "hash_id": "f2a32b1fe64abeab9cb4f898ab650b1b1d05c39669de7fd4c857dabc60508310",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/disp.c",
  "human_readable_source": " \n#include \"disp.h\"\n#include \"atom.h\"\n#include \"core.h\"\n#include \"head.h\"\n#include \"wndw.h\"\n#include \"handles.h\"\n\n#include <linux/dma-mapping.h>\n#include <linux/hdmi.h>\n#include <linux/component.h>\n#include <linux/iopoll.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fb_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include <nvif/push507c.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n#include <nvif/event.h>\n#include <nvif/if0012.h>\n#include <nvif/if0014.h>\n#include <nvif/timer.h>\n\n#include <nvhw/class/cl507c.h>\n#include <nvhw/class/cl507d.h>\n#include <nvhw/class/cl837d.h>\n#include <nvhw/class/cl887d.h>\n#include <nvhw/class/cl907d.h>\n#include <nvhw/class/cl917d.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_connector.h\"\n#include \"nouveau_encoder.h\"\n#include \"nouveau_fence.h\"\n#include \"nv50_display.h\"\n\n#include <subdev/bios/dp.h>\n\n \n\nstatic int\nnv50_chan_create(struct nvif_device *device, struct nvif_object *disp,\n\t\t const s32 *oclass, u8 head, void *data, u32 size,\n\t\t struct nv50_chan *chan)\n{\n\tstruct nvif_sclass *sclass;\n\tint ret, i, n;\n\n\tchan->device = device;\n\n\tret = n = nvif_object_sclass_get(disp, &sclass);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (oclass[0]) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (sclass[i].oclass == oclass[0]) {\n\t\t\t\tret = nvif_object_ctor(disp, \"kmsChan\", 0,\n\t\t\t\t\t\t       oclass[0], data, size,\n\t\t\t\t\t\t       &chan->user);\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tnvif_object_map(&chan->user, NULL, 0);\n\t\t\t\tnvif_object_sclass_put(&sclass);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\toclass++;\n\t}\n\n\tnvif_object_sclass_put(&sclass);\n\treturn -ENOSYS;\n}\n\nstatic void\nnv50_chan_destroy(struct nv50_chan *chan)\n{\n\tnvif_object_dtor(&chan->user);\n}\n\n \n\nvoid\nnv50_dmac_destroy(struct nv50_dmac *dmac)\n{\n\tnvif_object_dtor(&dmac->vram);\n\tnvif_object_dtor(&dmac->sync);\n\n\tnv50_chan_destroy(&dmac->base);\n\n\tnvif_mem_dtor(&dmac->_push.mem);\n}\n\nstatic void\nnv50_dmac_kick(struct nvif_push *push)\n{\n\tstruct nv50_dmac *dmac = container_of(push, typeof(*dmac), _push);\n\n\tdmac->cur = push->cur - (u32 __iomem *)dmac->_push.mem.object.map.ptr;\n\tif (dmac->put != dmac->cur) {\n\t\t \n\t\tif (dmac->push->mem.type & NVIF_MEM_VRAM) {\n\t\t\tstruct nvif_device *device = dmac->base.device;\n\t\t\tnvif_wr32(&device->object, 0x070000, 0x00000001);\n\t\t\tnvif_msec(device, 2000,\n\t\t\t\tif (!(nvif_rd32(&device->object, 0x070000) & 0x00000002))\n\t\t\t\t\tbreak;\n\t\t\t);\n\t\t}\n\n\t\tNVIF_WV32(&dmac->base.user, NV507C, PUT, PTR, dmac->cur);\n\t\tdmac->put = dmac->cur;\n\t}\n\n\tpush->bgn = push->cur;\n}\n\nstatic int\nnv50_dmac_free(struct nv50_dmac *dmac)\n{\n\tu32 get = NVIF_RV32(&dmac->base.user, NV507C, GET, PTR);\n\tif (get > dmac->cur)  \n\t\treturn get - dmac->cur - 5;\n\treturn dmac->max - dmac->cur;\n}\n\nstatic int\nnv50_dmac_wind(struct nv50_dmac *dmac)\n{\n\t \n\tu32 get = NVIF_RV32(&dmac->base.user, NV507C, GET, PTR);\n\tif (get == 0) {\n\t\t \n\t\tif (dmac->put == 0)\n\t\t\tnv50_dmac_kick(dmac->push);\n\n\t\tif (nvif_msec(dmac->base.device, 2000,\n\t\t\tif (NVIF_TV32(&dmac->base.user, NV507C, GET, PTR, >, 0))\n\t\t\t\tbreak;\n\t\t) < 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\tPUSH_RSVD(dmac->push, PUSH_JUMP(dmac->push, 0));\n\tdmac->cur = 0;\n\treturn 0;\n}\n\nstatic int\nnv50_dmac_wait(struct nvif_push *push, u32 size)\n{\n\tstruct nv50_dmac *dmac = container_of(push, typeof(*dmac), _push);\n\tint free;\n\n\tif (WARN_ON(size > dmac->max))\n\t\treturn -EINVAL;\n\n\tdmac->cur = push->cur - (u32 __iomem *)dmac->_push.mem.object.map.ptr;\n\tif (dmac->cur + size >= dmac->max) {\n\t\tint ret = nv50_dmac_wind(dmac);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpush->cur = dmac->_push.mem.object.map.ptr;\n\t\tpush->cur = push->cur + dmac->cur;\n\t\tnv50_dmac_kick(push);\n\t}\n\n\tif (nvif_msec(dmac->base.device, 2000,\n\t\tif ((free = nv50_dmac_free(dmac)) >= size)\n\t\t\tbreak;\n\t) < 0) {\n\t\tWARN_ON(1);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tpush->bgn = dmac->_push.mem.object.map.ptr;\n\tpush->bgn = push->bgn + dmac->cur;\n\tpush->cur = push->bgn;\n\tpush->end = push->cur + free;\n\treturn 0;\n}\n\nMODULE_PARM_DESC(kms_vram_pushbuf, \"Place EVO/NVD push buffers in VRAM (default: auto)\");\nstatic int nv50_dmac_vram_pushbuf = -1;\nmodule_param_named(kms_vram_pushbuf, nv50_dmac_vram_pushbuf, int, 0400);\n\nint\nnv50_dmac_create(struct nvif_device *device, struct nvif_object *disp,\n\t\t const s32 *oclass, u8 head, void *data, u32 size, s64 syncbuf,\n\t\t struct nv50_dmac *dmac)\n{\n\tstruct nouveau_cli *cli = (void *)device->object.client;\n\tstruct nvif_disp_chan_v0 *args = data;\n\tu8 type = NVIF_MEM_COHERENT;\n\tint ret;\n\n\tmutex_init(&dmac->lock);\n\n\t \n\tif ((nv50_dmac_vram_pushbuf > 0) ||\n\t    (nv50_dmac_vram_pushbuf < 0 && device->info.family == NV_DEVICE_INFO_V0_PASCAL))\n\t\ttype |= NVIF_MEM_VRAM;\n\n\tret = nvif_mem_ctor_map(&cli->mmu, \"kmsChanPush\", type, 0x1000,\n\t\t\t\t&dmac->_push.mem);\n\tif (ret)\n\t\treturn ret;\n\n\tdmac->ptr = dmac->_push.mem.object.map.ptr;\n\tdmac->_push.wait = nv50_dmac_wait;\n\tdmac->_push.kick = nv50_dmac_kick;\n\tdmac->push = &dmac->_push;\n\tdmac->push->bgn = dmac->_push.mem.object.map.ptr;\n\tdmac->push->cur = dmac->push->bgn;\n\tdmac->push->end = dmac->push->bgn;\n\tdmac->max = 0x1000/4 - 1;\n\n\t \n\tif (disp->oclass < GV100_DISP)\n\t\tdmac->max -= 12;\n\n\targs->pushbuf = nvif_handle(&dmac->_push.mem.object);\n\n\tret = nv50_chan_create(device, disp, oclass, head, data, size,\n\t\t\t       &dmac->base);\n\tif (ret)\n\t\treturn ret;\n\n\tif (syncbuf < 0)\n\t\treturn 0;\n\n\tret = nvif_object_ctor(&dmac->base.user, \"kmsSyncCtxDma\", NV50_DISP_HANDLE_SYNCBUF,\n\t\t\t       NV_DMA_IN_MEMORY,\n\t\t\t       &(struct nv_dma_v0) {\n\t\t\t\t\t.target = NV_DMA_V0_TARGET_VRAM,\n\t\t\t\t\t.access = NV_DMA_V0_ACCESS_RDWR,\n\t\t\t\t\t.start = syncbuf + 0x0000,\n\t\t\t\t\t.limit = syncbuf + 0x0fff,\n\t\t\t       }, sizeof(struct nv_dma_v0),\n\t\t\t       &dmac->sync);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvif_object_ctor(&dmac->base.user, \"kmsVramCtxDma\", NV50_DISP_HANDLE_VRAM,\n\t\t\t       NV_DMA_IN_MEMORY,\n\t\t\t       &(struct nv_dma_v0) {\n\t\t\t\t\t.target = NV_DMA_V0_TARGET_VRAM,\n\t\t\t\t\t.access = NV_DMA_V0_ACCESS_RDWR,\n\t\t\t\t\t.start = 0,\n\t\t\t\t\t.limit = device->info.ram_user - 1,\n\t\t\t       }, sizeof(struct nv_dma_v0),\n\t\t\t       &dmac->vram);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\n \nstatic void\nnv50_outp_dump_caps(struct nouveau_drm *drm,\n\t\t    struct nouveau_encoder *outp)\n{\n\tNV_DEBUG(drm, \"%s caps: dp_interlace=%d\\n\",\n\t\t outp->base.base.name, outp->caps.dp_interlace);\n}\n\nstatic int\nnv50_outp_atomic_check_view(struct drm_encoder *encoder,\n\t\t\t    struct drm_crtc_state *crtc_state,\n\t\t\t    struct drm_connector_state *conn_state,\n\t\t\t    struct drm_display_mode *native_mode)\n{\n\tstruct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;\n\tstruct drm_display_mode *mode = &crtc_state->mode;\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct nouveau_conn_atom *asyc = nouveau_conn_atom(conn_state);\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\n\tNV_ATOMIC(drm, \"%s atomic_check\\n\", encoder->name);\n\tasyc->scaler.full = false;\n\tif (!native_mode)\n\t\treturn 0;\n\n\tif (asyc->scaler.mode == DRM_MODE_SCALE_NONE) {\n\t\tswitch (connector->connector_type) {\n\t\tcase DRM_MODE_CONNECTOR_LVDS:\n\t\tcase DRM_MODE_CONNECTOR_eDP:\n\t\t\t \n\t\t\tif (mode->hdisplay == native_mode->hdisplay &&\n\t\t\t    mode->vdisplay == native_mode->vdisplay &&\n\t\t\t    mode->type & DRM_MODE_TYPE_DRIVER)\n\t\t\t\tbreak;\n\t\t\tmode = native_mode;\n\t\t\tasyc->scaler.full = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmode = native_mode;\n\t}\n\n\tif (!drm_mode_equal(adjusted_mode, mode)) {\n\t\tdrm_mode_copy(adjusted_mode, mode);\n\t\tcrtc_state->mode_changed = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv50_outp_atomic_fix_depth(struct drm_encoder *encoder, struct drm_crtc_state *crtc_state)\n{\n\tstruct nv50_head_atom *asyh = nv50_head_atom(crtc_state);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_display_mode *mode = &asyh->state.adjusted_mode;\n\tunsigned int max_rate, mode_rate;\n\n\tswitch (nv_encoder->dcb->type) {\n\tcase DCB_OUTPUT_DP:\n\t\tmax_rate = nv_encoder->dp.link_nr * nv_encoder->dp.link_bw;\n\n\t\t \n\t\tasyh->or.bpc = min_t(u8, asyh->or.bpc, 10);\n\n\t\t \n\t\twhile (asyh->or.bpc > 6) {\n\t\t\tmode_rate = DIV_ROUND_UP(mode->clock * asyh->or.bpc * 3, 8);\n\t\t\tif (mode_rate <= max_rate)\n\t\t\t\tbreak;\n\n\t\t\tasyh->or.bpc -= 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int\nnv50_outp_atomic_check(struct drm_encoder *encoder,\n\t\t       struct drm_crtc_state *crtc_state,\n\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nv50_head_atom *asyh = nv50_head_atom(crtc_state);\n\tint ret;\n\n\tret = nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,\n\t\t\t\t\t  nv_connector->native_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tif (crtc_state->mode_changed || crtc_state->connectors_changed)\n\t\tasyh->or.bpc = connector->display_info.bpc;\n\n\t \n\tnv50_outp_atomic_fix_depth(encoder, crtc_state);\n\n\treturn 0;\n}\n\nstruct nouveau_connector *\nnv50_outp_get_new_connector(struct drm_atomic_state *state, struct nouveau_encoder *outp)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_encoder *encoder = to_drm_encoder(outp);\n\tint i;\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->best_encoder == encoder)\n\t\t\treturn nouveau_connector(connector);\n\t}\n\n\treturn NULL;\n}\n\nstruct nouveau_connector *\nnv50_outp_get_old_connector(struct drm_atomic_state *state, struct nouveau_encoder *outp)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *connector_state;\n\tstruct drm_encoder *encoder = to_drm_encoder(outp);\n\tint i;\n\n\tfor_each_old_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->best_encoder == encoder)\n\t\t\treturn nouveau_connector(connector);\n\t}\n\n\treturn NULL;\n}\n\nstatic struct nouveau_crtc *\nnv50_outp_get_new_crtc(const struct drm_atomic_state *state, const struct nouveau_encoder *outp)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tconst u32 mask = drm_encoder_mask(&outp->base.base);\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (crtc_state->encoder_mask & mask)\n\t\t\treturn nouveau_crtc(crtc);\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void\nnv50_dac_atomic_disable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nv50_core *core = nv50_disp(encoder->dev)->core;\n\tconst u32 ctrl = NVDEF(NV507D, DAC_SET_CONTROL, OWNER, NONE);\n\n\tcore->func->dac->ctrl(core, nv_encoder->outp.or.id, ctrl, NULL);\n\tnv_encoder->crtc = NULL;\n\tnvif_outp_release(&nv_encoder->outp);\n}\n\nstatic void\nnv50_dac_atomic_enable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_crtc *nv_crtc = nv50_outp_get_new_crtc(state, nv_encoder);\n\tstruct nv50_head_atom *asyh =\n\t\tnv50_head_atom(drm_atomic_get_new_crtc_state(state, &nv_crtc->base));\n\tstruct nv50_core *core = nv50_disp(encoder->dev)->core;\n\tu32 ctrl = 0;\n\n\tswitch (nv_crtc->index) {\n\tcase 0: ctrl |= NVDEF(NV507D, DAC_SET_CONTROL, OWNER, HEAD0); break;\n\tcase 1: ctrl |= NVDEF(NV507D, DAC_SET_CONTROL, OWNER, HEAD1); break;\n\tcase 2: ctrl |= NVDEF(NV907D, DAC_SET_CONTROL, OWNER_MASK, HEAD2); break;\n\tcase 3: ctrl |= NVDEF(NV907D, DAC_SET_CONTROL, OWNER_MASK, HEAD3); break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tctrl |= NVDEF(NV507D, DAC_SET_CONTROL, PROTOCOL, RGB_CRT);\n\n\tnvif_outp_acquire_rgb_crt(&nv_encoder->outp);\n\n\tcore->func->dac->ctrl(core, nv_encoder->outp.or.id, ctrl, asyh);\n\tasyh->or.depth = 0;\n\n\tnv_encoder->crtc = &nv_crtc->base;\n}\n\nstatic enum drm_connector_status\nnv50_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tu32 loadval;\n\tint ret;\n\n\tloadval = nouveau_drm(encoder->dev)->vbios.dactestval;\n\tif (loadval == 0)\n\t\tloadval = 340;\n\n\tret = nvif_outp_load_detect(&nv_encoder->outp, loadval);\n\tif (ret <= 0)\n\t\treturn connector_status_disconnected;\n\n\treturn connector_status_connected;\n}\n\nstatic const struct drm_encoder_helper_funcs\nnv50_dac_help = {\n\t.atomic_check = nv50_outp_atomic_check,\n\t.atomic_enable = nv50_dac_atomic_enable,\n\t.atomic_disable = nv50_dac_atomic_disable,\n\t.detect = nv50_dac_detect\n};\n\nstatic void\nnv50_dac_destroy(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\tnvif_outp_dtor(&nv_encoder->outp);\n\n\tdrm_encoder_cleanup(encoder);\n\tkfree(encoder);\n}\n\nstatic const struct drm_encoder_funcs\nnv50_dac_func = {\n\t.destroy = nv50_dac_destroy,\n};\n\nstatic int\nnv50_dac_create(struct drm_connector *connector, struct dcb_output *dcbe)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct nv50_disp *disp = nv50_disp(connector->dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct nvkm_i2c_bus *bus;\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct drm_encoder *encoder;\n\tint type = DRM_MODE_ENCODER_DAC;\n\n\tnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\n\tif (!nv_encoder)\n\t\treturn -ENOMEM;\n\tnv_encoder->dcb = dcbe;\n\n\tbus = nvkm_i2c_bus_find(i2c, dcbe->i2c_index);\n\tif (bus)\n\t\tnv_encoder->i2c = &bus->i2c;\n\n\tencoder = to_drm_encoder(nv_encoder);\n\tencoder->possible_crtcs = dcbe->heads;\n\tencoder->possible_clones = 0;\n\tdrm_encoder_init(connector->dev, encoder, &nv50_dac_func, type,\n\t\t\t \"dac-%04x-%04x\", dcbe->hasht, dcbe->hashm);\n\tdrm_encoder_helper_add(encoder, &nv50_dac_help);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\treturn nvif_outp_ctor(disp->disp, nv_encoder->base.base.name, dcbe->id, &nv_encoder->outp);\n}\n\n \nstatic void\nnv50_audio_component_eld_notify(struct drm_audio_component *acomp, int port,\n\t\t\t\tint dev_id)\n{\n\tif (acomp && acomp->audio_ops && acomp->audio_ops->pin_eld_notify)\n\t\tacomp->audio_ops->pin_eld_notify(acomp->audio_ops->audio_ptr,\n\t\t\t\t\t\t port, dev_id);\n}\n\nstatic int\nnv50_audio_component_get_eld(struct device *kdev, int port, int dev_id,\n\t\t\t     bool *enabled, unsigned char *buf, int max_bytes)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(kdev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct drm_encoder *encoder;\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct nouveau_crtc *nv_crtc;\n\tint ret = 0;\n\n\t*enabled = false;\n\n\tmutex_lock(&drm->audio.lock);\n\n\tdrm_for_each_encoder(encoder, drm->dev) {\n\t\tstruct nouveau_connector *nv_connector = NULL;\n\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DPMST)\n\t\t\tcontinue;  \n\n\t\tnv_encoder = nouveau_encoder(encoder);\n\t\tnv_connector = nouveau_connector(nv_encoder->audio.connector);\n\t\tnv_crtc = nouveau_crtc(nv_encoder->crtc);\n\n\t\tif (!nv_crtc || nv_encoder->outp.or.id != port || nv_crtc->index != dev_id)\n\t\t\tcontinue;\n\n\t\t*enabled = nv_encoder->audio.enabled;\n\t\tif (*enabled) {\n\t\t\tret = drm_eld_size(nv_connector->base.eld);\n\t\t\tmemcpy(buf, nv_connector->base.eld,\n\t\t\t       min(max_bytes, ret));\n\t\t}\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&drm->audio.lock);\n\n\treturn ret;\n}\n\nstatic const struct drm_audio_component_ops nv50_audio_component_ops = {\n\t.get_eld = nv50_audio_component_get_eld,\n};\n\nstatic int\nnv50_audio_component_bind(struct device *kdev, struct device *hda_kdev,\n\t\t\t  void *data)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(kdev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct drm_audio_component *acomp = data;\n\n\tif (WARN_ON(!device_link_add(hda_kdev, kdev, DL_FLAG_STATELESS)))\n\t\treturn -ENOMEM;\n\n\tdrm_modeset_lock_all(drm_dev);\n\tacomp->ops = &nv50_audio_component_ops;\n\tacomp->dev = kdev;\n\tdrm->audio.component = acomp;\n\tdrm_modeset_unlock_all(drm_dev);\n\treturn 0;\n}\n\nstatic void\nnv50_audio_component_unbind(struct device *kdev, struct device *hda_kdev,\n\t\t\t    void *data)\n{\n\tstruct drm_device *drm_dev = dev_get_drvdata(kdev);\n\tstruct nouveau_drm *drm = nouveau_drm(drm_dev);\n\tstruct drm_audio_component *acomp = data;\n\n\tdrm_modeset_lock_all(drm_dev);\n\tdrm->audio.component = NULL;\n\tacomp->ops = NULL;\n\tacomp->dev = NULL;\n\tdrm_modeset_unlock_all(drm_dev);\n}\n\nstatic const struct component_ops nv50_audio_component_bind_ops = {\n\t.bind   = nv50_audio_component_bind,\n\t.unbind = nv50_audio_component_unbind,\n};\n\nstatic void\nnv50_audio_component_init(struct nouveau_drm *drm)\n{\n\tif (component_add(drm->dev->dev, &nv50_audio_component_bind_ops))\n\t\treturn;\n\n\tdrm->audio.component_registered = true;\n\tmutex_init(&drm->audio.lock);\n}\n\nstatic void\nnv50_audio_component_fini(struct nouveau_drm *drm)\n{\n\tif (!drm->audio.component_registered)\n\t\treturn;\n\n\tcomponent_del(drm->dev->dev, &nv50_audio_component_bind_ops);\n\tdrm->audio.component_registered = false;\n\tmutex_destroy(&drm->audio.lock);\n}\n\n \nstatic bool\nnv50_audio_supported(struct drm_encoder *encoder)\n{\n\tstruct nv50_disp *disp = nv50_disp(encoder->dev);\n\n\tif (disp->disp->object.oclass <= GT200_DISP ||\n\t    disp->disp->object.oclass == GT206_DISP)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\nnv50_audio_disable(struct drm_encoder *encoder, struct nouveau_crtc *nv_crtc)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nvif_outp *outp = &nv_encoder->outp;\n\n\tif (!nv50_audio_supported(encoder))\n\t\treturn;\n\n\tmutex_lock(&drm->audio.lock);\n\tif (nv_encoder->audio.enabled) {\n\t\tnv_encoder->audio.enabled = false;\n\t\tnv_encoder->audio.connector = NULL;\n\t\tnvif_outp_hda_eld(&nv_encoder->outp, nv_crtc->index, NULL, 0);\n\t}\n\tmutex_unlock(&drm->audio.lock);\n\n\tnv50_audio_component_eld_notify(drm->audio.component, outp->or.id, nv_crtc->index);\n}\n\nstatic void\nnv50_audio_enable(struct drm_encoder *encoder, struct nouveau_crtc *nv_crtc,\n\t\t  struct nouveau_connector *nv_connector, struct drm_atomic_state *state,\n\t\t  struct drm_display_mode *mode)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nvif_outp *outp = &nv_encoder->outp;\n\n\tif (!nv50_audio_supported(encoder) || !drm_detect_monitor_audio(nv_connector->edid))\n\t\treturn;\n\n\tmutex_lock(&drm->audio.lock);\n\n\tnvif_outp_hda_eld(&nv_encoder->outp, nv_crtc->index, nv_connector->base.eld,\n\t\t\t  drm_eld_size(nv_connector->base.eld));\n\tnv_encoder->audio.enabled = true;\n\tnv_encoder->audio.connector = &nv_connector->base;\n\n\tmutex_unlock(&drm->audio.lock);\n\n\tnv50_audio_component_eld_notify(drm->audio.component, outp->or.id, nv_crtc->index);\n}\n\n \nstatic void\nnv50_hdmi_enable(struct drm_encoder *encoder, struct nouveau_crtc *nv_crtc,\n\t\t struct nouveau_connector *nv_connector, struct drm_atomic_state *state,\n\t\t struct drm_display_mode *mode, bool hda)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(encoder->dev);\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct drm_hdmi_info *hdmi = &nv_connector->base.display_info.hdmi;\n\tunion hdmi_infoframe infoframe = { 0 };\n\tconst u8 rekey = 56;  \n\tu8 scdc = 0;\n\tu32 max_ac_packet;\n\tstruct {\n\t\tstruct nvif_outp_infoframe_v0 infoframe;\n\t\tu8 data[17];\n\t} args = { 0 };\n\tint ret, size;\n\n\tmax_ac_packet  = mode->htotal - mode->hdisplay;\n\tmax_ac_packet -= rekey;\n\tmax_ac_packet -= 18;  \n\tmax_ac_packet /= 32;\n\n\tif (hdmi->scdc.scrambling.supported) {\n\t\tconst bool high_tmds_clock_ratio = mode->clock > 340000;\n\n\t\tret = drm_scdc_readb(nv_encoder->i2c, SCDC_TMDS_CONFIG, &scdc);\n\t\tif (ret < 0) {\n\t\t\tNV_ERROR(drm, \"Failure to read SCDC_TMDS_CONFIG: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\tscdc &= ~(SCDC_TMDS_BIT_CLOCK_RATIO_BY_40 | SCDC_SCRAMBLING_ENABLE);\n\t\tif (high_tmds_clock_ratio || hdmi->scdc.scrambling.low_rates)\n\t\t\tscdc |= SCDC_SCRAMBLING_ENABLE;\n\t\tif (high_tmds_clock_ratio)\n\t\t\tscdc |= SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;\n\n\t\tret = drm_scdc_writeb(nv_encoder->i2c, SCDC_TMDS_CONFIG, scdc);\n\t\tif (ret < 0)\n\t\t\tNV_ERROR(drm, \"Failure to write SCDC_TMDS_CONFIG = 0x%02x: %d\\n\",\n\t\t\t\t scdc, ret);\n\t}\n\n\tret = nvif_outp_acquire_tmds(&nv_encoder->outp, nv_crtc->index, true,\n\t\t\t\t     max_ac_packet, rekey, scdc, hda);\n\tif (ret)\n\t\treturn;\n\n\t \n\targs.infoframe.version = 0;\n\targs.infoframe.head = nv_crtc->index;\n\n\tif (!drm_hdmi_avi_infoframe_from_display_mode(&infoframe.avi, &nv_connector->base, mode)) {\n\t\tdrm_hdmi_avi_infoframe_quant_range(&infoframe.avi, &nv_connector->base, mode,\n\t\t\t\t\t\t   HDMI_QUANTIZATION_RANGE_FULL);\n\n\t\tsize = hdmi_infoframe_pack(&infoframe, args.data, ARRAY_SIZE(args.data));\n\t} else {\n\t\tsize = 0;\n\t}\n\n\tnvif_outp_infoframe(&nv_encoder->outp, NVIF_OUTP_INFOFRAME_V0_AVI, &args.infoframe, size);\n\n\t \n\tmemset(&args.data, 0, sizeof(args.data));\n\tif (!drm_hdmi_vendor_infoframe_from_display_mode(&infoframe.vendor.hdmi,\n\t\t\t\t\t\t\t &nv_connector->base, mode))\n\t\tsize = hdmi_infoframe_pack(&infoframe, args.data, ARRAY_SIZE(args.data));\n\telse\n\t\tsize = 0;\n\n\tnvif_outp_infoframe(&nv_encoder->outp, NVIF_OUTP_INFOFRAME_V0_VSI, &args.infoframe, size);\n\n\tnv50_audio_enable(encoder, nv_crtc, nv_connector, state, mode);\n}\n\n \n#define nv50_mstm(p) container_of((p), struct nv50_mstm, mgr)\n#define nv50_mstc(p) container_of((p), struct nv50_mstc, connector)\n#define nv50_msto(p) container_of((p), struct nv50_msto, encoder)\n\nstruct nv50_mstc {\n\tstruct nv50_mstm *mstm;\n\tstruct drm_dp_mst_port *port;\n\tstruct drm_connector connector;\n\n\tstruct drm_display_mode *native;\n\tstruct edid *edid;\n};\n\nstruct nv50_msto {\n\tstruct drm_encoder encoder;\n\n\t \n\tstruct nv50_head *head;\n\tstruct nv50_mstc *mstc;\n\tbool disabled;\n\tbool enabled;\n};\n\nstruct nouveau_encoder *nv50_real_outp(struct drm_encoder *encoder)\n{\n\tstruct nv50_msto *msto;\n\n\tif (encoder->encoder_type != DRM_MODE_ENCODER_DPMST)\n\t\treturn nouveau_encoder(encoder);\n\n\tmsto = nv50_msto(encoder);\n\tif (!msto->mstc)\n\t\treturn NULL;\n\treturn msto->mstc->mstm->outp;\n}\n\nstatic void\nnv50_msto_cleanup(struct drm_atomic_state *state,\n\t\t  struct drm_dp_mst_topology_state *mst_state,\n\t\t  struct drm_dp_mst_topology_mgr *mgr,\n\t\t  struct nv50_msto *msto)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(msto->encoder.dev);\n\tstruct drm_dp_mst_atomic_payload *payload =\n\t\tdrm_atomic_get_mst_payload_state(mst_state, msto->mstc->port);\n\n\tNV_ATOMIC(drm, \"%s: msto cleanup\\n\", msto->encoder.name);\n\n\tif (msto->disabled) {\n\t\tmsto->mstc = NULL;\n\t\tmsto->disabled = false;\n\t} else if (msto->enabled) {\n\t\tdrm_dp_add_payload_part2(mgr, state, payload);\n\t\tmsto->enabled = false;\n\t}\n}\n\nstatic void\nnv50_msto_prepare(struct drm_atomic_state *state,\n\t\t  struct drm_dp_mst_topology_state *mst_state,\n\t\t  struct drm_dp_mst_topology_mgr *mgr,\n\t\t  struct nv50_msto *msto)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(msto->encoder.dev);\n\tstruct nv50_mstc *mstc = msto->mstc;\n\tstruct nv50_mstm *mstm = mstc->mstm;\n\tstruct drm_dp_mst_topology_state *old_mst_state;\n\tstruct drm_dp_mst_atomic_payload *payload, *old_payload;\n\n\tNV_ATOMIC(drm, \"%s: msto prepare\\n\", msto->encoder.name);\n\n\told_mst_state = drm_atomic_get_old_mst_topology_state(state, mgr);\n\n\tpayload = drm_atomic_get_mst_payload_state(mst_state, mstc->port);\n\told_payload = drm_atomic_get_mst_payload_state(old_mst_state, mstc->port);\n\n\t\n\tif (msto->disabled) {\n\t\tdrm_dp_remove_payload(mgr, mst_state, old_payload, payload);\n\n\t\tnvif_outp_dp_mst_vcpi(&mstm->outp->outp, msto->head->base.index, 0, 0, 0, 0);\n\t} else {\n\t\tif (msto->enabled)\n\t\t\tdrm_dp_add_payload_part1(mgr, mst_state, payload);\n\n\t\tnvif_outp_dp_mst_vcpi(&mstm->outp->outp, msto->head->base.index,\n\t\t\t\t      payload->vc_start_slot, payload->time_slots,\n\t\t\t\t      payload->pbn, payload->time_slots * mst_state->pbn_div);\n\t}\n}\n\nstatic int\nnv50_msto_atomic_check(struct drm_encoder *encoder,\n\t\t       struct drm_crtc_state *crtc_state,\n\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct drm_atomic_state *state = crtc_state->state;\n\tstruct drm_connector *connector = conn_state->connector;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\tstruct nv50_mstm *mstm = mstc->mstm;\n\tstruct nv50_head_atom *asyh = nv50_head_atom(crtc_state);\n\tint slots;\n\tint ret;\n\n\tret = nv50_outp_atomic_check_view(encoder, crtc_state, conn_state,\n\t\t\t\t\t  mstc->native);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!drm_atomic_crtc_needs_modeset(crtc_state))\n\t\treturn 0;\n\n\t \n\tif (!state->duplicated) {\n\t\tconst int clock = crtc_state->adjusted_mode.clock;\n\n\t\tasyh->or.bpc = connector->display_info.bpc;\n\t\tasyh->dp.pbn = drm_dp_calc_pbn_mode(clock, asyh->or.bpc * 3 << 4);\n\t}\n\n\tmst_state = drm_atomic_get_mst_topology_state(state, &mstm->mgr);\n\tif (IS_ERR(mst_state))\n\t\treturn PTR_ERR(mst_state);\n\n\tif (!mst_state->pbn_div) {\n\t\tstruct nouveau_encoder *outp = mstc->mstm->outp;\n\n\t\tmst_state->pbn_div = drm_dp_get_vc_payload_bw(&mstm->mgr,\n\t\t\t\t\t\t\t      outp->dp.link_bw, outp->dp.link_nr);\n\t}\n\n\tslots = drm_dp_atomic_find_time_slots(state, &mstm->mgr, mstc->port, asyh->dp.pbn);\n\tif (slots < 0)\n\t\treturn slots;\n\n\tasyh->dp.tu = slots;\n\n\treturn 0;\n}\n\nstatic u8\nnv50_dp_bpc_to_depth(unsigned int bpc)\n{\n\tswitch (bpc) {\n\tcase  6: return NV837D_SOR_SET_CONTROL_PIXEL_DEPTH_BPP_18_444;\n\tcase  8: return NV837D_SOR_SET_CONTROL_PIXEL_DEPTH_BPP_24_444;\n\tcase 10:\n\tdefault: return NV837D_SOR_SET_CONTROL_PIXEL_DEPTH_BPP_30_444;\n\t}\n}\n\nstatic void\nnv50_msto_atomic_enable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nv50_msto *msto = nv50_msto(encoder);\n\tstruct nv50_head *head = msto->head;\n\tstruct nv50_head_atom *asyh =\n\t\tnv50_head_atom(drm_atomic_get_new_crtc_state(state, &head->base.base));\n\tstruct nv50_mstc *mstc = NULL;\n\tstruct nv50_mstm *mstm = NULL;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tu8 proto;\n\n\tdrm_connector_list_iter_begin(encoder->dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->state->best_encoder == &msto->encoder) {\n\t\t\tmstc = nv50_mstc(connector);\n\t\t\tmstm = mstc->mstm;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (WARN_ON(!mstc))\n\t\treturn;\n\n\tif (!mstm->links++) {\n\t\t \n\t\tnvif_outp_acquire_dp(&mstm->outp->outp, mstm->outp->dp.dpcd, 0, 0, false, true);\n\t}\n\n\tif (mstm->outp->outp.or.link & 1)\n\t\tproto = NV917D_SOR_SET_CONTROL_PROTOCOL_DP_A;\n\telse\n\t\tproto = NV917D_SOR_SET_CONTROL_PROTOCOL_DP_B;\n\n\tmstm->outp->update(mstm->outp, head->base.index, asyh, proto,\n\t\t\t   nv50_dp_bpc_to_depth(asyh->or.bpc));\n\n\tmsto->mstc = mstc;\n\tmsto->enabled = true;\n\tmstm->modified = true;\n}\n\nstatic void\nnv50_msto_atomic_disable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nv50_msto *msto = nv50_msto(encoder);\n\tstruct nv50_mstc *mstc = msto->mstc;\n\tstruct nv50_mstm *mstm = mstc->mstm;\n\n\tmstm->outp->update(mstm->outp, msto->head->base.index, NULL, 0, 0);\n\tmstm->modified = true;\n\tif (!--mstm->links)\n\t\tmstm->disabled = true;\n\tmsto->disabled = true;\n}\n\nstatic const struct drm_encoder_helper_funcs\nnv50_msto_help = {\n\t.atomic_disable = nv50_msto_atomic_disable,\n\t.atomic_enable = nv50_msto_atomic_enable,\n\t.atomic_check = nv50_msto_atomic_check,\n};\n\nstatic void\nnv50_msto_destroy(struct drm_encoder *encoder)\n{\n\tstruct nv50_msto *msto = nv50_msto(encoder);\n\tdrm_encoder_cleanup(&msto->encoder);\n\tkfree(msto);\n}\n\nstatic const struct drm_encoder_funcs\nnv50_msto = {\n\t.destroy = nv50_msto_destroy,\n};\n\nstatic struct nv50_msto *\nnv50_msto_new(struct drm_device *dev, struct nv50_head *head, int id)\n{\n\tstruct nv50_msto *msto;\n\tint ret;\n\n\tmsto = kzalloc(sizeof(*msto), GFP_KERNEL);\n\tif (!msto)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = drm_encoder_init(dev, &msto->encoder, &nv50_msto,\n\t\t\t       DRM_MODE_ENCODER_DPMST, \"mst-%d\", id);\n\tif (ret) {\n\t\tkfree(msto);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdrm_encoder_helper_add(&msto->encoder, &nv50_msto_help);\n\tmsto->encoder.possible_crtcs = drm_crtc_mask(&head->base.base);\n\tmsto->head = head;\n\treturn msto;\n}\n\nstatic struct drm_encoder *\nnv50_mstc_atomic_best_encoder(struct drm_connector *connector,\n\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *connector_state = drm_atomic_get_new_connector_state(state,\n\t\t\t\t\t\t\t\t\t\t\t connector);\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\tstruct drm_crtc *crtc = connector_state->crtc;\n\n\tif (!(mstc->mstm->outp->dcb->heads & drm_crtc_mask(crtc)))\n\t\treturn NULL;\n\n\treturn &nv50_head(crtc)->msto->encoder;\n}\n\nstatic enum drm_mode_status\nnv50_mstc_mode_valid(struct drm_connector *connector,\n\t\t     struct drm_display_mode *mode)\n{\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\tstruct nouveau_encoder *outp = mstc->mstm->outp;\n\n\t \n\n\treturn nv50_dp_mode_valid(outp, mode, NULL);\n}\n\nstatic int\nnv50_mstc_get_modes(struct drm_connector *connector)\n{\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\tint ret = 0;\n\n\tmstc->edid = drm_dp_mst_get_edid(&mstc->connector, mstc->port->mgr, mstc->port);\n\tdrm_connector_update_edid_property(&mstc->connector, mstc->edid);\n\tif (mstc->edid)\n\t\tret = drm_add_edid_modes(&mstc->connector, mstc->edid);\n\n\t \n\tif (connector->display_info.bpc)\n\t\tconnector->display_info.bpc =\n\t\t\tclamp(connector->display_info.bpc, 6U, 8U);\n\telse\n\t\tconnector->display_info.bpc = 8;\n\n\tif (mstc->native)\n\t\tdrm_mode_destroy(mstc->connector.dev, mstc->native);\n\tmstc->native = nouveau_conn_native_mode(&mstc->connector);\n\treturn ret;\n}\n\nstatic int\nnv50_mstc_atomic_check(struct drm_connector *connector,\n\t\t       struct drm_atomic_state *state)\n{\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\tstruct drm_dp_mst_topology_mgr *mgr = &mstc->mstm->mgr;\n\n\treturn drm_dp_atomic_release_time_slots(state, mgr, mstc->port);\n}\n\nstatic int\nnv50_mstc_detect(struct drm_connector *connector,\n\t\t struct drm_modeset_acquire_ctx *ctx, bool force)\n{\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\tint ret;\n\n\tif (drm_connector_is_unregistered(connector))\n\t\treturn connector_status_disconnected;\n\n\tret = pm_runtime_get_sync(connector->dev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(connector->dev->dev);\n\t\treturn connector_status_disconnected;\n\t}\n\n\tret = drm_dp_mst_detect_port(connector, ctx, mstc->port->mgr,\n\t\t\t\t     mstc->port);\n\tif (ret != connector_status_connected)\n\t\tgoto out;\n\nout:\n\tpm_runtime_mark_last_busy(connector->dev->dev);\n\tpm_runtime_put_autosuspend(connector->dev->dev);\n\treturn ret;\n}\n\nstatic const struct drm_connector_helper_funcs\nnv50_mstc_help = {\n\t.get_modes = nv50_mstc_get_modes,\n\t.mode_valid = nv50_mstc_mode_valid,\n\t.atomic_best_encoder = nv50_mstc_atomic_best_encoder,\n\t.atomic_check = nv50_mstc_atomic_check,\n\t.detect_ctx = nv50_mstc_detect,\n};\n\nstatic void\nnv50_mstc_destroy(struct drm_connector *connector)\n{\n\tstruct nv50_mstc *mstc = nv50_mstc(connector);\n\n\tdrm_connector_cleanup(&mstc->connector);\n\tdrm_dp_mst_put_port_malloc(mstc->port);\n\n\tkfree(mstc);\n}\n\nstatic const struct drm_connector_funcs\nnv50_mstc = {\n\t.reset = nouveau_conn_reset,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = nv50_mstc_destroy,\n\t.atomic_duplicate_state = nouveau_conn_atomic_duplicate_state,\n\t.atomic_destroy_state = nouveau_conn_atomic_destroy_state,\n\t.atomic_set_property = nouveau_conn_atomic_set_property,\n\t.atomic_get_property = nouveau_conn_atomic_get_property,\n};\n\nstatic int\nnv50_mstc_new(struct nv50_mstm *mstm, struct drm_dp_mst_port *port,\n\t      const char *path, struct nv50_mstc **pmstc)\n{\n\tstruct drm_device *dev = mstm->outp->base.base.dev;\n\tstruct drm_crtc *crtc;\n\tstruct nv50_mstc *mstc;\n\tint ret;\n\n\tif (!(mstc = *pmstc = kzalloc(sizeof(*mstc), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tmstc->mstm = mstm;\n\tmstc->port = port;\n\n\tret = drm_connector_init(dev, &mstc->connector, &nv50_mstc,\n\t\t\t\t DRM_MODE_CONNECTOR_DisplayPort);\n\tif (ret) {\n\t\tkfree(*pmstc);\n\t\t*pmstc = NULL;\n\t\treturn ret;\n\t}\n\n\tdrm_connector_helper_add(&mstc->connector, &nv50_mstc_help);\n\n\tmstc->connector.funcs->reset(&mstc->connector);\n\tnouveau_conn_attach_properties(&mstc->connector);\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tif (!(mstm->outp->dcb->heads & drm_crtc_mask(crtc)))\n\t\t\tcontinue;\n\n\t\tdrm_connector_attach_encoder(&mstc->connector,\n\t\t\t\t\t     &nv50_head(crtc)->msto->encoder);\n\t}\n\n\tdrm_object_attach_property(&mstc->connector.base, dev->mode_config.path_property, 0);\n\tdrm_object_attach_property(&mstc->connector.base, dev->mode_config.tile_property, 0);\n\tdrm_connector_set_path_property(&mstc->connector, path);\n\tdrm_dp_mst_get_port_malloc(port);\n\treturn 0;\n}\n\nstatic void\nnv50_mstm_cleanup(struct drm_atomic_state *state,\n\t\t  struct drm_dp_mst_topology_state *mst_state,\n\t\t  struct nv50_mstm *mstm)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(mstm->outp->base.base.dev);\n\tstruct drm_encoder *encoder;\n\n\tNV_ATOMIC(drm, \"%s: mstm cleanup\\n\", mstm->outp->base.base.name);\n\tdrm_dp_check_act_status(&mstm->mgr);\n\n\tdrm_for_each_encoder(encoder, mstm->outp->base.base.dev) {\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DPMST) {\n\t\t\tstruct nv50_msto *msto = nv50_msto(encoder);\n\t\t\tstruct nv50_mstc *mstc = msto->mstc;\n\t\t\tif (mstc && mstc->mstm == mstm)\n\t\t\t\tnv50_msto_cleanup(state, mst_state, &mstm->mgr, msto);\n\t\t}\n\t}\n\n\tmstm->modified = false;\n}\n\nstatic void\nnv50_mstm_prepare(struct drm_atomic_state *state,\n\t\t  struct drm_dp_mst_topology_state *mst_state,\n\t\t  struct nv50_mstm *mstm)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(mstm->outp->base.base.dev);\n\tstruct drm_encoder *encoder;\n\n\tNV_ATOMIC(drm, \"%s: mstm prepare\\n\", mstm->outp->base.base.name);\n\n\t \n\tdrm_for_each_encoder(encoder, mstm->outp->base.base.dev) {\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DPMST) {\n\t\t\tstruct nv50_msto *msto = nv50_msto(encoder);\n\t\t\tstruct nv50_mstc *mstc = msto->mstc;\n\t\t\tif (mstc && mstc->mstm == mstm && msto->disabled)\n\t\t\t\tnv50_msto_prepare(state, mst_state, &mstm->mgr, msto);\n\t\t}\n\t}\n\n\t \n\tdrm_for_each_encoder(encoder, mstm->outp->base.base.dev) {\n\t\tif (encoder->encoder_type == DRM_MODE_ENCODER_DPMST) {\n\t\t\tstruct nv50_msto *msto = nv50_msto(encoder);\n\t\t\tstruct nv50_mstc *mstc = msto->mstc;\n\t\t\tif (mstc && mstc->mstm == mstm && !msto->disabled)\n\t\t\t\tnv50_msto_prepare(state, mst_state, &mstm->mgr, msto);\n\t\t}\n\t}\n\n\tif (mstm->disabled) {\n\t\tif (!mstm->links)\n\t\t\tnvif_outp_release(&mstm->outp->outp);\n\t\tmstm->disabled = false;\n\t}\n}\n\nstatic struct drm_connector *\nnv50_mstm_add_connector(struct drm_dp_mst_topology_mgr *mgr,\n\t\t\tstruct drm_dp_mst_port *port, const char *path)\n{\n\tstruct nv50_mstm *mstm = nv50_mstm(mgr);\n\tstruct nv50_mstc *mstc;\n\tint ret;\n\n\tret = nv50_mstc_new(mstm, port, path, &mstc);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn &mstc->connector;\n}\n\nstatic const struct drm_dp_mst_topology_cbs\nnv50_mstm = {\n\t.add_connector = nv50_mstm_add_connector,\n};\n\nbool\nnv50_mstm_service(struct nouveau_drm *drm,\n\t\t  struct nouveau_connector *nv_connector,\n\t\t  struct nv50_mstm *mstm)\n{\n\tstruct drm_dp_aux *aux = &nv_connector->aux;\n\tbool handled = true, ret = true;\n\tint rc;\n\tu8 esi[8] = {};\n\n\twhile (handled) {\n\t\tu8 ack[8] = {};\n\n\t\trc = drm_dp_dpcd_read(aux, DP_SINK_COUNT_ESI, esi, 8);\n\t\tif (rc != 8) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrm_dp_mst_hpd_irq_handle_event(&mstm->mgr, esi, ack, &handled);\n\t\tif (!handled)\n\t\t\tbreak;\n\n\t\trc = drm_dp_dpcd_writeb(aux, DP_SINK_COUNT_ESI + 1, ack[1]);\n\n\t\tif (rc != 1) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrm_dp_mst_hpd_irq_send_new_request(&mstm->mgr);\n\t}\n\n\tif (!ret)\n\t\tNV_DEBUG(drm, \"Failed to handle ESI on %s: %d\\n\",\n\t\t\t nv_connector->base.name, rc);\n\n\treturn ret;\n}\n\nvoid\nnv50_mstm_remove(struct nv50_mstm *mstm)\n{\n\tmstm->is_mst = false;\n\tdrm_dp_mst_topology_mgr_set_mst(&mstm->mgr, false);\n}\n\nint\nnv50_mstm_detect(struct nouveau_encoder *outp)\n{\n\tstruct nv50_mstm *mstm = outp->dp.mstm;\n\tstruct drm_dp_aux *aux;\n\tint ret;\n\n\tif (!mstm || !mstm->can_mst)\n\t\treturn 0;\n\n\taux = mstm->mgr.aux;\n\n\t \n\tret = drm_dp_dpcd_writeb(aux, DP_MSTM_CTRL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = drm_dp_mst_topology_mgr_set_mst(&mstm->mgr, true);\n\tif (ret)\n\t\treturn ret;\n\n\tmstm->is_mst = true;\n\treturn 1;\n}\n\nstatic void\nnv50_mstm_fini(struct nouveau_encoder *outp)\n{\n\tstruct nv50_mstm *mstm = outp->dp.mstm;\n\n\tif (!mstm)\n\t\treturn;\n\n\t \n\tmutex_lock(&outp->dp.hpd_irq_lock);\n\tmstm->suspended = true;\n\tmutex_unlock(&outp->dp.hpd_irq_lock);\n\n\tif (mstm->is_mst)\n\t\tdrm_dp_mst_topology_mgr_suspend(&mstm->mgr);\n}\n\nstatic void\nnv50_mstm_init(struct nouveau_encoder *outp, bool runtime)\n{\n\tstruct nv50_mstm *mstm = outp->dp.mstm;\n\tint ret = 0;\n\n\tif (!mstm)\n\t\treturn;\n\n\tif (mstm->is_mst) {\n\t\tret = drm_dp_mst_topology_mgr_resume(&mstm->mgr, !runtime);\n\t\tif (ret == -1)\n\t\t\tnv50_mstm_remove(mstm);\n\t}\n\n\tmutex_lock(&outp->dp.hpd_irq_lock);\n\tmstm->suspended = false;\n\tmutex_unlock(&outp->dp.hpd_irq_lock);\n\n\tif (ret == -1)\n\t\tdrm_kms_helper_hotplug_event(mstm->mgr.dev);\n}\n\nstatic void\nnv50_mstm_del(struct nv50_mstm **pmstm)\n{\n\tstruct nv50_mstm *mstm = *pmstm;\n\tif (mstm) {\n\t\tdrm_dp_mst_topology_mgr_destroy(&mstm->mgr);\n\t\tkfree(*pmstm);\n\t\t*pmstm = NULL;\n\t}\n}\n\nstatic int\nnv50_mstm_new(struct nouveau_encoder *outp, struct drm_dp_aux *aux, int aux_max,\n\t      int conn_base_id, struct nv50_mstm **pmstm)\n{\n\tconst int max_payloads = hweight8(outp->dcb->heads);\n\tstruct drm_device *dev = outp->base.base.dev;\n\tstruct nv50_mstm *mstm;\n\tint ret;\n\n\tif (!(mstm = *pmstm = kzalloc(sizeof(*mstm), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tmstm->outp = outp;\n\tmstm->mgr.cbs = &nv50_mstm;\n\n\tret = drm_dp_mst_topology_mgr_init(&mstm->mgr, dev, aux, aux_max,\n\t\t\t\t\t   max_payloads, conn_base_id);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void\nnv50_sor_update(struct nouveau_encoder *nv_encoder, u8 head,\n\t\tstruct nv50_head_atom *asyh, u8 proto, u8 depth)\n{\n\tstruct nv50_disp *disp = nv50_disp(nv_encoder->base.base.dev);\n\tstruct nv50_core *core = disp->core;\n\n\tif (!asyh) {\n\t\tnv_encoder->ctrl &= ~BIT(head);\n\t\tif (NVDEF_TEST(nv_encoder->ctrl, NV507D, SOR_SET_CONTROL, OWNER, ==, NONE))\n\t\t\tnv_encoder->ctrl = 0;\n\t} else {\n\t\tnv_encoder->ctrl |= NVVAL(NV507D, SOR_SET_CONTROL, PROTOCOL, proto);\n\t\tnv_encoder->ctrl |= BIT(head);\n\t\tasyh->or.depth = depth;\n\t}\n\n\tcore->func->sor->ctrl(core, nv_encoder->outp.or.id, nv_encoder->ctrl, asyh);\n}\n\n \nstatic void\nnv50_sor_atomic_disable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(nv_encoder->crtc);\n\tstruct nouveau_connector *nv_connector = nv50_outp_get_old_connector(state, nv_encoder);\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\n\tstruct nouveau_drm *drm = nouveau_drm(nv_encoder->base.base.dev);\n\tstruct nouveau_backlight *backlight = nv_connector->backlight;\n#endif\n\tstruct drm_dp_aux *aux = &nv_connector->aux;\n\tint ret;\n\tu8 pwr;\n\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\n\tif (backlight && backlight->uses_dpcd) {\n\t\tret = drm_edp_backlight_disable(aux, &backlight->edp_info);\n\t\tif (ret < 0)\n\t\t\tNV_ERROR(drm, \"Failed to disable backlight on [CONNECTOR:%d:%s]: %d\\n\",\n\t\t\t\t nv_connector->base.base.id, nv_connector->base.name, ret);\n\t}\n#endif\n\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_DP) {\n\t\tret = drm_dp_dpcd_readb(aux, DP_SET_POWER, &pwr);\n\n\t\tif (ret == 0) {\n\t\t\tpwr &= ~DP_SET_POWER_MASK;\n\t\t\tpwr |=  DP_SET_POWER_D3;\n\t\t\tdrm_dp_dpcd_writeb(aux, DP_SET_POWER, pwr);\n\t\t}\n\t}\n\n\tnv_encoder->update(nv_encoder, nv_crtc->index, NULL, 0, 0);\n\tnv50_audio_disable(encoder, nv_crtc);\n\tnvif_outp_release(&nv_encoder->outp);\n\tnv_encoder->crtc = NULL;\n}\n\nstatic void\nnv50_sor_atomic_enable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_crtc *nv_crtc = nv50_outp_get_new_crtc(state, nv_encoder);\n\tstruct nv50_head_atom *asyh =\n\t\tnv50_head_atom(drm_atomic_get_new_crtc_state(state, &nv_crtc->base));\n\tstruct drm_display_mode *mode = &asyh->state.adjusted_mode;\n\tstruct nv50_disp *disp = nv50_disp(encoder->dev);\n\tstruct nvif_outp *outp = &nv_encoder->outp;\n\tstruct drm_device *dev = encoder->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_connector *nv_connector;\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\n\tstruct nouveau_backlight *backlight;\n#endif\n\tstruct nvbios *bios = &drm->vbios;\n\tbool lvds_dual = false, lvds_8bpc = false, hda = false;\n\tu8 proto = NV507D_SOR_SET_CONTROL_PROTOCOL_CUSTOM;\n\tu8 depth = NV837D_SOR_SET_CONTROL_PIXEL_DEPTH_DEFAULT;\n\n\tnv_connector = nv50_outp_get_new_connector(state, nv_encoder);\n\tnv_encoder->crtc = &nv_crtc->base;\n\n\tif ((disp->disp->object.oclass == GT214_DISP ||\n\t     disp->disp->object.oclass >= GF110_DISP) &&\n\t    drm_detect_monitor_audio(nv_connector->edid))\n\t\thda = true;\n\n\tswitch (nv_encoder->dcb->type) {\n\tcase DCB_OUTPUT_TMDS:\n\t\tif (disp->disp->object.oclass == NV50_DISP ||\n\t\t    !drm_detect_hdmi_monitor(nv_connector->edid))\n\t\t\tnvif_outp_acquire_tmds(outp, nv_crtc->index, false, 0, 0, 0, false);\n\t\telse\n\t\t\tnv50_hdmi_enable(encoder, nv_crtc, nv_connector, state, mode, hda);\n\n\t\tif (nv_encoder->outp.or.link & 1) {\n\t\t\tproto = NV507D_SOR_SET_CONTROL_PROTOCOL_SINGLE_TMDS_A;\n\t\t\t \n\t\t\tif (mode->clock >= 165000 &&\n\t\t\t    nv_encoder->dcb->duallink_possible &&\n\t\t\t    !drm_detect_hdmi_monitor(nv_connector->edid))\n\t\t\t\tproto = NV507D_SOR_SET_CONTROL_PROTOCOL_DUAL_TMDS;\n\t\t} else {\n\t\t\tproto = NV507D_SOR_SET_CONTROL_PROTOCOL_SINGLE_TMDS_B;\n\t\t}\n\t\tbreak;\n\tcase DCB_OUTPUT_LVDS:\n\t\tproto = NV507D_SOR_SET_CONTROL_PROTOCOL_LVDS_CUSTOM;\n\n\t\tif (bios->fp_no_ddc) {\n\t\t\tlvds_dual = bios->fp.dual_link;\n\t\t\tlvds_8bpc = bios->fp.if_is_24bit;\n\t\t} else {\n\t\t\tif (nv_connector->type == DCB_CONNECTOR_LVDS_SPWG) {\n\t\t\t\tif (((u8 *)nv_connector->edid)[121] == 2)\n\t\t\t\t\tlvds_dual = true;\n\t\t\t} else\n\t\t\tif (mode->clock >= bios->fp.duallink_transition_clk) {\n\t\t\t\tlvds_dual = true;\n\t\t\t}\n\n\t\t\tif (lvds_dual) {\n\t\t\t\tif (bios->fp.strapless_is_24bit & 2)\n\t\t\t\t\tlvds_8bpc = true;\n\t\t\t} else {\n\t\t\t\tif (bios->fp.strapless_is_24bit & 1)\n\t\t\t\t\tlvds_8bpc = true;\n\t\t\t}\n\n\t\t\tif (asyh->or.bpc == 8)\n\t\t\t\tlvds_8bpc = true;\n\t\t}\n\n\t\tnvif_outp_acquire_lvds(&nv_encoder->outp, lvds_dual, lvds_8bpc);\n\t\tbreak;\n\tcase DCB_OUTPUT_DP:\n\t\tnvif_outp_acquire_dp(&nv_encoder->outp, nv_encoder->dp.dpcd, 0, 0, hda, false);\n\t\tdepth = nv50_dp_bpc_to_depth(asyh->or.bpc);\n\n\t\tif (nv_encoder->outp.or.link & 1)\n\t\t\tproto = NV887D_SOR_SET_CONTROL_PROTOCOL_DP_A;\n\t\telse\n\t\t\tproto = NV887D_SOR_SET_CONTROL_PROTOCOL_DP_B;\n\n\t\tnv50_audio_enable(encoder, nv_crtc, nv_connector, state, mode);\n\n#ifdef CONFIG_DRM_NOUVEAU_BACKLIGHT\n\t\tbacklight = nv_connector->backlight;\n\t\tif (backlight && backlight->uses_dpcd)\n\t\t\tdrm_edp_backlight_enable(&nv_connector->aux, &backlight->edp_info,\n\t\t\t\t\t\t (u16)backlight->dev->props.brightness);\n#endif\n\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tnv_encoder->update(nv_encoder, nv_crtc->index, asyh, proto, depth);\n}\n\nstatic const struct drm_encoder_helper_funcs\nnv50_sor_help = {\n\t.atomic_check = nv50_outp_atomic_check,\n\t.atomic_enable = nv50_sor_atomic_enable,\n\t.atomic_disable = nv50_sor_atomic_disable,\n};\n\nstatic void\nnv50_sor_destroy(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\tnvif_outp_dtor(&nv_encoder->outp);\n\n\tnv50_mstm_del(&nv_encoder->dp.mstm);\n\tdrm_encoder_cleanup(encoder);\n\n\tif (nv_encoder->dcb->type == DCB_OUTPUT_DP)\n\t\tmutex_destroy(&nv_encoder->dp.hpd_irq_lock);\n\n\tkfree(encoder);\n}\n\nstatic const struct drm_encoder_funcs\nnv50_sor_func = {\n\t.destroy = nv50_sor_destroy,\n};\n\nbool nv50_has_mst(struct nouveau_drm *drm)\n{\n\tstruct nvkm_bios *bios = nvxx_bios(&drm->client.device);\n\tu32 data;\n\tu8 ver, hdr, cnt, len;\n\n\tdata = nvbios_dp_table(bios, &ver, &hdr, &cnt, &len);\n\treturn data && ver >= 0x40 && (nvbios_rd08(bios, data + 0x08) & 0x04);\n}\n\nstatic int\nnv50_sor_create(struct drm_connector *connector, struct dcb_output *dcbe)\n{\n\tstruct nouveau_connector *nv_connector = nouveau_connector(connector);\n\tstruct nouveau_drm *drm = nouveau_drm(connector->dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct drm_encoder *encoder;\n\tstruct nv50_disp *disp = nv50_disp(connector->dev);\n\tint type, ret;\n\n\tswitch (dcbe->type) {\n\tcase DCB_OUTPUT_LVDS: type = DRM_MODE_ENCODER_LVDS; break;\n\tcase DCB_OUTPUT_TMDS:\n\tcase DCB_OUTPUT_DP:\n\tdefault:\n\t\ttype = DRM_MODE_ENCODER_TMDS;\n\t\tbreak;\n\t}\n\n\tnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\n\tif (!nv_encoder)\n\t\treturn -ENOMEM;\n\tnv_encoder->dcb = dcbe;\n\tnv_encoder->update = nv50_sor_update;\n\n\tencoder = to_drm_encoder(nv_encoder);\n\tencoder->possible_crtcs = dcbe->heads;\n\tencoder->possible_clones = 0;\n\tdrm_encoder_init(connector->dev, encoder, &nv50_sor_func, type,\n\t\t\t \"sor-%04x-%04x\", dcbe->hasht, dcbe->hashm);\n\tdrm_encoder_helper_add(encoder, &nv50_sor_help);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\tdisp->core->func->sor->get_caps(disp, nv_encoder, ffs(dcbe->or) - 1);\n\tnv50_outp_dump_caps(drm, nv_encoder);\n\n\tif (dcbe->type == DCB_OUTPUT_DP) {\n\t\tstruct nvkm_i2c_aux *aux =\n\t\t\tnvkm_i2c_aux_find(i2c, dcbe->i2c_index);\n\n\t\tmutex_init(&nv_encoder->dp.hpd_irq_lock);\n\n\t\tif (aux) {\n\t\t\tif (disp->disp->object.oclass < GF110_DISP) {\n\t\t\t\t \n\t\t\t\tnv_encoder->i2c = &aux->i2c;\n\t\t\t} else {\n\t\t\t\tnv_encoder->i2c = &nv_connector->aux.ddc;\n\t\t\t}\n\t\t\tnv_encoder->aux = aux;\n\t\t}\n\n\t\tif (nv_connector->type != DCB_CONNECTOR_eDP &&\n\t\t    nv50_has_mst(drm)) {\n\t\t\tret = nv50_mstm_new(nv_encoder, &nv_connector->aux,\n\t\t\t\t\t    16, nv_connector->base.base.id,\n\t\t\t\t\t    &nv_encoder->dp.mstm);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tstruct nvkm_i2c_bus *bus =\n\t\t\tnvkm_i2c_bus_find(i2c, dcbe->i2c_index);\n\t\tif (bus)\n\t\t\tnv_encoder->i2c = &bus->i2c;\n\t}\n\n\treturn nvif_outp_ctor(disp->disp, nv_encoder->base.base.name, dcbe->id, &nv_encoder->outp);\n}\n\n \nstatic int\nnv50_pior_atomic_check(struct drm_encoder *encoder,\n\t\t       struct drm_crtc_state *crtc_state,\n\t\t       struct drm_connector_state *conn_state)\n{\n\tint ret = nv50_outp_atomic_check(encoder, crtc_state, conn_state);\n\tif (ret)\n\t\treturn ret;\n\tcrtc_state->adjusted_mode.clock *= 2;\n\treturn 0;\n}\n\nstatic void\nnv50_pior_atomic_disable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nv50_core *core = nv50_disp(encoder->dev)->core;\n\tconst u32 ctrl = NVDEF(NV507D, PIOR_SET_CONTROL, OWNER, NONE);\n\n\tcore->func->pior->ctrl(core, nv_encoder->outp.or.id, ctrl, NULL);\n\tnv_encoder->crtc = NULL;\n\tnvif_outp_release(&nv_encoder->outp);\n}\n\nstatic void\nnv50_pior_atomic_enable(struct drm_encoder *encoder, struct drm_atomic_state *state)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\tstruct nouveau_crtc *nv_crtc = nv50_outp_get_new_crtc(state, nv_encoder);\n\tstruct nv50_head_atom *asyh =\n\t\tnv50_head_atom(drm_atomic_get_new_crtc_state(state, &nv_crtc->base));\n\tstruct nv50_core *core = nv50_disp(encoder->dev)->core;\n\tu32 ctrl = 0;\n\n\tswitch (nv_crtc->index) {\n\tcase 0: ctrl |= NVDEF(NV507D, PIOR_SET_CONTROL, OWNER, HEAD0); break;\n\tcase 1: ctrl |= NVDEF(NV507D, PIOR_SET_CONTROL, OWNER, HEAD1); break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tswitch (asyh->or.bpc) {\n\tcase 10: asyh->or.depth = NV837D_PIOR_SET_CONTROL_PIXEL_DEPTH_BPP_30_444; break;\n\tcase  8: asyh->or.depth = NV837D_PIOR_SET_CONTROL_PIXEL_DEPTH_BPP_24_444; break;\n\tcase  6: asyh->or.depth = NV837D_PIOR_SET_CONTROL_PIXEL_DEPTH_BPP_18_444; break;\n\tdefault: asyh->or.depth = NV837D_PIOR_SET_CONTROL_PIXEL_DEPTH_DEFAULT; break;\n\t}\n\n\tswitch (nv_encoder->dcb->type) {\n\tcase DCB_OUTPUT_TMDS:\n\t\tctrl |= NVDEF(NV507D, PIOR_SET_CONTROL, PROTOCOL, EXT_TMDS_ENC);\n\t\tnvif_outp_acquire_tmds(&nv_encoder->outp, false, false, 0, 0, 0, false);\n\t\tbreak;\n\tcase DCB_OUTPUT_DP:\n\t\tctrl |= NVDEF(NV507D, PIOR_SET_CONTROL, PROTOCOL, EXT_TMDS_ENC);\n\t\tnvif_outp_acquire_dp(&nv_encoder->outp, nv_encoder->dp.dpcd, 0, 0, false, false);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tcore->func->pior->ctrl(core, nv_encoder->outp.or.id, ctrl, asyh);\n\tnv_encoder->crtc = &nv_crtc->base;\n}\n\nstatic const struct drm_encoder_helper_funcs\nnv50_pior_help = {\n\t.atomic_check = nv50_pior_atomic_check,\n\t.atomic_enable = nv50_pior_atomic_enable,\n\t.atomic_disable = nv50_pior_atomic_disable,\n};\n\nstatic void\nnv50_pior_destroy(struct drm_encoder *encoder)\n{\n\tstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\n\n\tnvif_outp_dtor(&nv_encoder->outp);\n\n\tdrm_encoder_cleanup(encoder);\n\n\tmutex_destroy(&nv_encoder->dp.hpd_irq_lock);\n\tkfree(encoder);\n}\n\nstatic const struct drm_encoder_funcs\nnv50_pior_func = {\n\t.destroy = nv50_pior_destroy,\n};\n\nstatic int\nnv50_pior_create(struct drm_connector *connector, struct dcb_output *dcbe)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tstruct nvkm_i2c *i2c = nvxx_i2c(&drm->client.device);\n\tstruct nvkm_i2c_bus *bus = NULL;\n\tstruct nvkm_i2c_aux *aux = NULL;\n\tstruct i2c_adapter *ddc;\n\tstruct nouveau_encoder *nv_encoder;\n\tstruct drm_encoder *encoder;\n\tint type;\n\n\tswitch (dcbe->type) {\n\tcase DCB_OUTPUT_TMDS:\n\t\tbus  = nvkm_i2c_bus_find(i2c, NVKM_I2C_BUS_EXT(dcbe->extdev));\n\t\tddc  = bus ? &bus->i2c : NULL;\n\t\ttype = DRM_MODE_ENCODER_TMDS;\n\t\tbreak;\n\tcase DCB_OUTPUT_DP:\n\t\taux  = nvkm_i2c_aux_find(i2c, NVKM_I2C_AUX_EXT(dcbe->extdev));\n\t\tddc  = aux ? &aux->i2c : NULL;\n\t\ttype = DRM_MODE_ENCODER_TMDS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\n\tif (!nv_encoder)\n\t\treturn -ENOMEM;\n\tnv_encoder->dcb = dcbe;\n\tnv_encoder->i2c = ddc;\n\tnv_encoder->aux = aux;\n\n\tmutex_init(&nv_encoder->dp.hpd_irq_lock);\n\n\tencoder = to_drm_encoder(nv_encoder);\n\tencoder->possible_crtcs = dcbe->heads;\n\tencoder->possible_clones = 0;\n\tdrm_encoder_init(connector->dev, encoder, &nv50_pior_func, type,\n\t\t\t \"pior-%04x-%04x\", dcbe->hasht, dcbe->hashm);\n\tdrm_encoder_helper_add(encoder, &nv50_pior_help);\n\n\tdrm_connector_attach_encoder(connector, encoder);\n\n\tdisp->core->func->pior->get_caps(disp, nv_encoder, ffs(dcbe->or) - 1);\n\tnv50_outp_dump_caps(drm, nv_encoder);\n\n\treturn nvif_outp_ctor(disp->disp, nv_encoder->base.base.name, dcbe->id, &nv_encoder->outp);\n}\n\n \n\nstatic void\nnv50_disp_atomic_commit_core(struct drm_atomic_state *state, u32 *interlock)\n{\n\tstruct drm_dp_mst_topology_mgr *mgr;\n\tstruct drm_dp_mst_topology_state *mst_state;\n\tstruct nouveau_drm *drm = nouveau_drm(state->dev);\n\tstruct nv50_disp *disp = nv50_disp(drm->dev);\n\tstruct nv50_core *core = disp->core;\n\tstruct nv50_mstm *mstm;\n\tint i;\n\n\tNV_ATOMIC(drm, \"commit core %08x\\n\", interlock[NV50_DISP_INTERLOCK_BASE]);\n\n\tfor_each_new_mst_mgr_in_state(state, mgr, mst_state, i) {\n\t\tmstm = nv50_mstm(mgr);\n\t\tif (mstm->modified)\n\t\t\tnv50_mstm_prepare(state, mst_state, mstm);\n\t}\n\n\tcore->func->ntfy_init(disp->sync, NV50_DISP_CORE_NTFY);\n\tcore->func->update(core, interlock, true);\n\tif (core->func->ntfy_wait_done(disp->sync, NV50_DISP_CORE_NTFY,\n\t\t\t\t       disp->core->chan.base.device))\n\t\tNV_ERROR(drm, \"core notifier timeout\\n\");\n\n\tfor_each_new_mst_mgr_in_state(state, mgr, mst_state, i) {\n\t\tmstm = nv50_mstm(mgr);\n\t\tif (mstm->modified)\n\t\t\tnv50_mstm_cleanup(state, mst_state, mstm);\n\t}\n}\n\nstatic void\nnv50_disp_atomic_commit_wndw(struct drm_atomic_state *state, u32 *interlock)\n{\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_plane *plane;\n\tint i;\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\t\tif (interlock[wndw->interlock.type] & wndw->interlock.data) {\n\t\t\tif (wndw->func->update)\n\t\t\t\twndw->func->update(wndw, interlock);\n\t\t}\n\t}\n}\n\nstatic void\nnv50_disp_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct drm_crtc_state *new_crtc_state, *old_crtc_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_plane *plane;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tstruct nv50_atom *atom = nv50_atom(state);\n\tstruct nv50_core *core = disp->core;\n\tstruct nv50_outp_atom *outp, *outt;\n\tu32 interlock[NV50_DISP_INTERLOCK__SIZE] = {};\n\tint i;\n\tbool flushed = false;\n\n\tNV_ATOMIC(drm, \"commit %d %d\\n\", atom->lock_core, atom->flush_disable);\n\tnv50_crc_atomic_stop_reporting(state);\n\tdrm_atomic_helper_wait_for_fences(dev, state, false);\n\tdrm_atomic_helper_wait_for_dependencies(state);\n\tdrm_dp_mst_atomic_wait_for_dependencies(state);\n\tdrm_atomic_helper_update_legacy_modeset_state(dev, state);\n\tdrm_atomic_helper_calc_timestamping_constants(state);\n\n\tif (atom->lock_core)\n\t\tmutex_lock(&disp->mutex);\n\n\t \n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\n\t\tNV_ATOMIC(drm, \"%s: clr %04x (set %04x)\\n\", crtc->name,\n\t\t\t  asyh->clr.mask, asyh->set.mask);\n\n\t\tif (old_crtc_state->active && !new_crtc_state->active) {\n\t\t\tpm_runtime_put_noidle(dev->dev);\n\t\t\tdrm_crtc_vblank_off(crtc);\n\t\t}\n\n\t\tif (asyh->clr.mask) {\n\t\t\tnv50_head_flush_clr(head, asyh, atom->flush_disable);\n\t\t\tinterlock[NV50_DISP_INTERLOCK_CORE] |= 1;\n\t\t}\n\t}\n\n\t \n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(new_plane_state);\n\t\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\n\t\tNV_ATOMIC(drm, \"%s: clr %02x (set %02x)\\n\", plane->name,\n\t\t\t  asyw->clr.mask, asyw->set.mask);\n\t\tif (!asyw->clr.mask)\n\t\t\tcontinue;\n\n\t\tnv50_wndw_flush_clr(wndw, interlock, atom->flush_disable, asyw);\n\t}\n\n\t \n\tlist_for_each_entry(outp, &atom->outp, head) {\n\t\tconst struct drm_encoder_helper_funcs *help;\n\t\tstruct drm_encoder *encoder;\n\n\t\tencoder = outp->encoder;\n\t\thelp = encoder->helper_private;\n\n\t\tNV_ATOMIC(drm, \"%s: clr %02x (set %02x)\\n\", encoder->name,\n\t\t\t  outp->clr.mask, outp->set.mask);\n\n\t\tif (outp->clr.mask) {\n\t\t\thelp->atomic_disable(encoder, state);\n\t\t\tinterlock[NV50_DISP_INTERLOCK_CORE] |= 1;\n\t\t\tif (outp->flush_disable) {\n\t\t\t\tnv50_disp_atomic_commit_wndw(state, interlock);\n\t\t\t\tnv50_disp_atomic_commit_core(state, interlock);\n\t\t\t\tmemset(interlock, 0x00, sizeof(interlock));\n\n\t\t\t\tflushed = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (interlock[NV50_DISP_INTERLOCK_CORE]) {\n\t\tif (atom->flush_disable) {\n\t\t\tnv50_disp_atomic_commit_wndw(state, interlock);\n\t\t\tnv50_disp_atomic_commit_core(state, interlock);\n\t\t\tmemset(interlock, 0x00, sizeof(interlock));\n\n\t\t\tflushed = true;\n\t\t}\n\t}\n\n\tif (flushed)\n\t\tnv50_crc_atomic_release_notifier_contexts(state);\n\tnv50_crc_atomic_init_notifier_contexts(state);\n\n\t \n\tlist_for_each_entry_safe(outp, outt, &atom->outp, head) {\n\t\tconst struct drm_encoder_helper_funcs *help;\n\t\tstruct drm_encoder *encoder;\n\n\t\tencoder = outp->encoder;\n\t\thelp = encoder->helper_private;\n\n\t\tNV_ATOMIC(drm, \"%s: set %02x (clr %02x)\\n\", encoder->name,\n\t\t\t  outp->set.mask, outp->clr.mask);\n\n\t\tif (outp->set.mask) {\n\t\t\thelp->atomic_enable(encoder, state);\n\t\t\tinterlock[NV50_DISP_INTERLOCK_CORE] = 1;\n\t\t}\n\n\t\tlist_del(&outp->head);\n\t\tkfree(outp);\n\t}\n\n\t \n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\n\t\tNV_ATOMIC(drm, \"%s: set %04x (clr %04x)\\n\", crtc->name,\n\t\t\t  asyh->set.mask, asyh->clr.mask);\n\n\t\tif (asyh->set.mask) {\n\t\t\tnv50_head_flush_set(head, asyh);\n\t\t\tinterlock[NV50_DISP_INTERLOCK_CORE] = 1;\n\t\t}\n\n\t\tif (new_crtc_state->active) {\n\t\t\tif (!old_crtc_state->active) {\n\t\t\t\tdrm_crtc_vblank_on(crtc);\n\t\t\t\tpm_runtime_get_noresume(dev->dev);\n\t\t\t}\n\t\t\tif (new_crtc_state->event)\n\t\t\t\tdrm_crtc_vblank_get(crtc);\n\t\t}\n\t}\n\n\t \n\tif (core->assign_windows) {\n\t\tcore->func->wndw.owner(core);\n\t\tnv50_disp_atomic_commit_core(state, interlock);\n\t\tcore->assign_windows = false;\n\t\tinterlock[NV50_DISP_INTERLOCK_CORE] = 0;\n\t}\n\n\t \n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);\n\t\tstruct nv50_head *head = nv50_head(crtc);\n\n\t\tNV_ATOMIC(drm, \"%s: set %04x (clr %04x)\\n\", crtc->name,\n\t\t\t  asyh->set.mask, asyh->clr.mask);\n\n\t\tif (asyh->set.mask) {\n\t\t\tnv50_head_flush_set_wndw(head, asyh);\n\t\t\tinterlock[NV50_DISP_INTERLOCK_CORE] = 1;\n\t\t}\n\t}\n\n\t \n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(new_plane_state);\n\t\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\n\t\tNV_ATOMIC(drm, \"%s: set %02x (clr %02x)\\n\", plane->name,\n\t\t\t  asyw->set.mask, asyw->clr.mask);\n\t\tif ( !asyw->set.mask &&\n\t\t    (!asyw->clr.mask || atom->flush_disable))\n\t\t\tcontinue;\n\n\t\tnv50_wndw_flush_set(wndw, interlock, asyw);\n\t}\n\n\t \n\tnv50_disp_atomic_commit_wndw(state, interlock);\n\n\tif (interlock[NV50_DISP_INTERLOCK_CORE]) {\n\t\tif (interlock[NV50_DISP_INTERLOCK_BASE] ||\n\t\t    interlock[NV50_DISP_INTERLOCK_OVLY] ||\n\t\t    interlock[NV50_DISP_INTERLOCK_WNDW] ||\n\t\t    !atom->state.legacy_cursor_update)\n\t\t\tnv50_disp_atomic_commit_core(state, interlock);\n\t\telse\n\t\t\tdisp->core->func->update(disp->core, interlock, false);\n\t}\n\n\tif (atom->lock_core)\n\t\tmutex_unlock(&disp->mutex);\n\n\t \n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(new_plane_state);\n\t\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\t\tint ret = nv50_wndw_wait_armed(wndw, asyw);\n\t\tif (ret)\n\t\t\tNV_ERROR(drm, \"%s: timeout\\n\", plane->name);\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->event) {\n\t\t\tunsigned long flags;\n\t\t\t \n\t\t\tif (new_crtc_state->active)\n\t\t\t\tdrm_crtc_accurate_vblank_count(crtc);\n\t\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\t\t\tdrm_crtc_send_vblank_event(crtc, new_crtc_state->event);\n\t\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\n\t\t\tnew_crtc_state->event = NULL;\n\t\t\tif (new_crtc_state->active)\n\t\t\t\tdrm_crtc_vblank_put(crtc);\n\t\t}\n\t}\n\n\tnv50_crc_atomic_start_reporting(state);\n\tif (!flushed)\n\t\tnv50_crc_atomic_release_notifier_contexts(state);\n\n\tdrm_atomic_helper_commit_hw_done(state);\n\tdrm_atomic_helper_cleanup_planes(dev, state);\n\tdrm_atomic_helper_commit_cleanup_done(state);\n\tdrm_atomic_state_put(state);\n\n\t \n\tpm_runtime_mark_last_busy(dev->dev);\n\tpm_runtime_put_autosuspend(dev->dev);\n}\n\nstatic void\nnv50_disp_atomic_commit_work(struct work_struct *work)\n{\n\tstruct drm_atomic_state *state =\n\t\tcontainer_of(work, typeof(*state), commit_work);\n\tnv50_disp_atomic_commit_tail(state);\n}\n\nstatic int\nnv50_disp_atomic_commit(struct drm_device *dev,\n\t\t\tstruct drm_atomic_state *state, bool nonblock)\n{\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_plane *plane;\n\tint ret, i;\n\n\tret = pm_runtime_get_sync(dev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\t\treturn ret;\n\t}\n\n\tret = drm_atomic_helper_setup_commit(state, nonblock);\n\tif (ret)\n\t\tgoto done;\n\n\tINIT_WORK(&state->commit_work, nv50_disp_atomic_commit_work);\n\n\tret = drm_atomic_helper_prepare_planes(dev, state);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!nonblock) {\n\t\tret = drm_atomic_helper_wait_for_fences(dev, state, true);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\t}\n\n\tret = drm_atomic_helper_swap_state(state, true);\n\tif (ret)\n\t\tgoto err_cleanup;\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tstruct nv50_wndw_atom *asyw = nv50_wndw_atom(new_plane_state);\n\t\tstruct nv50_wndw *wndw = nv50_wndw(plane);\n\n\t\tif (asyw->set.image)\n\t\t\tnv50_wndw_ntfy_enable(wndw, asyw);\n\t}\n\n\tdrm_atomic_state_get(state);\n\n\t \n\tpm_runtime_get_noresume(dev->dev);\n\n\tif (nonblock)\n\t\tqueue_work(system_unbound_wq, &state->commit_work);\n\telse\n\t\tnv50_disp_atomic_commit_tail(state);\n\nerr_cleanup:\n\tif (ret)\n\t\tdrm_atomic_helper_unprepare_planes(dev, state);\ndone:\n\tpm_runtime_put_autosuspend(dev->dev);\n\treturn ret;\n}\n\nstatic struct nv50_outp_atom *\nnv50_disp_outp_atomic_add(struct nv50_atom *atom, struct drm_encoder *encoder)\n{\n\tstruct nv50_outp_atom *outp;\n\n\tlist_for_each_entry(outp, &atom->outp, head) {\n\t\tif (outp->encoder == encoder)\n\t\t\treturn outp;\n\t}\n\n\toutp = kzalloc(sizeof(*outp), GFP_KERNEL);\n\tif (!outp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist_add(&outp->head, &atom->outp);\n\toutp->encoder = encoder;\n\treturn outp;\n}\n\nstatic int\nnv50_disp_outp_atomic_check_clr(struct nv50_atom *atom,\n\t\t\t\tstruct drm_connector_state *old_connector_state)\n{\n\tstruct drm_encoder *encoder = old_connector_state->best_encoder;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tstruct nv50_outp_atom *outp;\n\n\tif (!(crtc = old_connector_state->crtc))\n\t\treturn 0;\n\n\told_crtc_state = drm_atomic_get_old_crtc_state(&atom->state, crtc);\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(&atom->state, crtc);\n\tif (old_crtc_state->active && drm_atomic_crtc_needs_modeset(new_crtc_state)) {\n\t\toutp = nv50_disp_outp_atomic_add(atom, encoder);\n\t\tif (IS_ERR(outp))\n\t\t\treturn PTR_ERR(outp);\n\n\t\tif (outp->encoder->encoder_type == DRM_MODE_ENCODER_DPMST) {\n\t\t\toutp->flush_disable = true;\n\t\t\tatom->flush_disable = true;\n\t\t}\n\t\toutp->clr.ctrl = true;\n\t\tatom->lock_core = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnv50_disp_outp_atomic_check_set(struct nv50_atom *atom,\n\t\t\t\tstruct drm_connector_state *connector_state)\n{\n\tstruct drm_encoder *encoder = connector_state->best_encoder;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tstruct nv50_outp_atom *outp;\n\n\tif (!(crtc = connector_state->crtc))\n\t\treturn 0;\n\n\tnew_crtc_state = drm_atomic_get_new_crtc_state(&atom->state, crtc);\n\tif (new_crtc_state->active && drm_atomic_crtc_needs_modeset(new_crtc_state)) {\n\t\toutp = nv50_disp_outp_atomic_add(atom, encoder);\n\t\tif (IS_ERR(outp))\n\t\t\treturn PTR_ERR(outp);\n\n\t\toutp->set.ctrl = true;\n\t\tatom->lock_core = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnv50_disp_atomic_check(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tstruct nv50_atom *atom = nv50_atom(state);\n\tstruct nv50_core *core = nv50_disp(dev)->core;\n\tstruct drm_connector_state *old_connector_state, *new_connector_state;\n\tstruct drm_connector *connector;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tstruct nv50_head *head;\n\tstruct nv50_head_atom *asyh;\n\tint ret, i;\n\n\tif (core->assign_windows && core->func->head->static_wndw_map) {\n\t\tdrm_for_each_crtc(crtc, dev) {\n\t\t\tnew_crtc_state = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t\t\t\t   crtc);\n\t\t\tif (IS_ERR(new_crtc_state))\n\t\t\t\treturn PTR_ERR(new_crtc_state);\n\n\t\t\thead = nv50_head(crtc);\n\t\t\tasyh = nv50_head_atom(new_crtc_state);\n\t\t\tcore->func->head->static_wndw_map(head, asyh);\n\t\t}\n\t}\n\n\t \n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->color_mgmt_changed) {\n\t\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = drm_atomic_helper_check(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i) {\n\t\tret = nv50_disp_outp_atomic_check_clr(atom, old_connector_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = nv50_disp_outp_atomic_check_set(atom, new_connector_state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = drm_dp_mst_atomic_check(state);\n\tif (ret)\n\t\treturn ret;\n\n\tnv50_crc_atomic_check_outp(atom);\n\n\treturn 0;\n}\n\nstatic void\nnv50_disp_atomic_state_clear(struct drm_atomic_state *state)\n{\n\tstruct nv50_atom *atom = nv50_atom(state);\n\tstruct nv50_outp_atom *outp, *outt;\n\n\tlist_for_each_entry_safe(outp, outt, &atom->outp, head) {\n\t\tlist_del(&outp->head);\n\t\tkfree(outp);\n\t}\n\n\tdrm_atomic_state_default_clear(state);\n}\n\nstatic void\nnv50_disp_atomic_state_free(struct drm_atomic_state *state)\n{\n\tstruct nv50_atom *atom = nv50_atom(state);\n\tdrm_atomic_state_default_release(&atom->state);\n\tkfree(atom);\n}\n\nstatic struct drm_atomic_state *\nnv50_disp_atomic_state_alloc(struct drm_device *dev)\n{\n\tstruct nv50_atom *atom;\n\tif (!(atom = kzalloc(sizeof(*atom), GFP_KERNEL)) ||\n\t    drm_atomic_state_init(dev, &atom->state) < 0) {\n\t\tkfree(atom);\n\t\treturn NULL;\n\t}\n\tINIT_LIST_HEAD(&atom->outp);\n\treturn &atom->state;\n}\n\nstatic const struct drm_mode_config_funcs\nnv50_disp_func = {\n\t.fb_create = nouveau_user_framebuffer_create,\n\t.output_poll_changed = drm_fb_helper_output_poll_changed,\n\t.atomic_check = nv50_disp_atomic_check,\n\t.atomic_commit = nv50_disp_atomic_commit,\n\t.atomic_state_alloc = nv50_disp_atomic_state_alloc,\n\t.atomic_state_clear = nv50_disp_atomic_state_clear,\n\t.atomic_state_free = nv50_disp_atomic_state_free,\n};\n\nstatic const struct drm_mode_config_helper_funcs\nnv50_disp_helper_func = {\n\t.atomic_commit_setup = drm_dp_mst_atomic_setup_commit,\n};\n\n \n\nstatic void\nnv50_display_fini(struct drm_device *dev, bool runtime, bool suspend)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_encoder *encoder;\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->encoder_type != DRM_MODE_ENCODER_DPMST)\n\t\t\tnv50_mstm_fini(nouveau_encoder(encoder));\n\t}\n\n\tif (!runtime)\n\t\tcancel_work_sync(&drm->hpd_work);\n}\n\nstatic int\nnv50_display_init(struct drm_device *dev, bool resume, bool runtime)\n{\n\tstruct nv50_core *core = nv50_disp(dev)->core;\n\tstruct drm_encoder *encoder;\n\n\tif (resume || runtime)\n\t\tcore->func->init(core);\n\n\tlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\n\t\tif (encoder->encoder_type != DRM_MODE_ENCODER_DPMST) {\n\t\t\tstruct nouveau_encoder *nv_encoder =\n\t\t\t\tnouveau_encoder(encoder);\n\t\t\tnv50_mstm_init(nv_encoder, runtime);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nnv50_display_destroy(struct drm_device *dev)\n{\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\n\tnv50_audio_component_fini(nouveau_drm(dev));\n\n\tnvif_object_unmap(&disp->caps);\n\tnvif_object_dtor(&disp->caps);\n\tnv50_core_del(&disp->core);\n\n\tnouveau_bo_unmap(disp->sync);\n\tif (disp->sync)\n\t\tnouveau_bo_unpin(disp->sync);\n\tnouveau_bo_ref(NULL, &disp->sync);\n\n\tnouveau_display(dev)->priv = NULL;\n\tkfree(disp);\n}\n\nint\nnv50_display_create(struct drm_device *dev)\n{\n\tstruct nvif_device *device = &nouveau_drm(dev)->client.device;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct dcb_table *dcb = &drm->vbios.dcb;\n\tstruct drm_connector *connector, *tmp;\n\tstruct nv50_disp *disp;\n\tstruct dcb_output *dcbe;\n\tint crtcs, ret, i;\n\tbool has_mst = nv50_has_mst(drm);\n\n\tdisp = kzalloc(sizeof(*disp), GFP_KERNEL);\n\tif (!disp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&disp->mutex);\n\n\tnouveau_display(dev)->priv = disp;\n\tnouveau_display(dev)->dtor = nv50_display_destroy;\n\tnouveau_display(dev)->init = nv50_display_init;\n\tnouveau_display(dev)->fini = nv50_display_fini;\n\tdisp->disp = &nouveau_display(dev)->disp;\n\tdev->mode_config.funcs = &nv50_disp_func;\n\tdev->mode_config.helper_private = &nv50_disp_helper_func;\n\tdev->mode_config.quirk_addfb_prefer_xbgr_30bpp = true;\n\tdev->mode_config.normalize_zpos = true;\n\n\t \n\tret = nouveau_bo_new(&drm->client, 4096, 0x1000,\n\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM,\n\t\t\t     0, 0x0000, NULL, NULL, &disp->sync);\n\tif (!ret) {\n\t\tret = nouveau_bo_pin(disp->sync, NOUVEAU_GEM_DOMAIN_VRAM, true);\n\t\tif (!ret) {\n\t\t\tret = nouveau_bo_map(disp->sync);\n\t\t\tif (ret)\n\t\t\t\tnouveau_bo_unpin(disp->sync);\n\t\t}\n\t\tif (ret)\n\t\t\tnouveau_bo_ref(NULL, &disp->sync);\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = nv50_core_new(drm, &disp->core);\n\tif (ret)\n\t\tgoto out;\n\n\tdisp->core->func->init(disp->core);\n\tif (disp->core->func->caps_init) {\n\t\tret = disp->core->func->caps_init(drm, disp);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (disp->disp->object.oclass >= TU102_DISP)\n\t\tnouveau_display(dev)->format_modifiers = wndwc57e_modifiers;\n\telse\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_FERMI)\n\t\tnouveau_display(dev)->format_modifiers = disp90xx_modifiers;\n\telse\n\t\tnouveau_display(dev)->format_modifiers = disp50xx_modifiers;\n\n\t \n\tif (disp->disp->object.oclass >= GM107_DISP) {\n\t\tdev->mode_config.cursor_width = 256;\n\t\tdev->mode_config.cursor_height = 256;\n\t} else if (disp->disp->object.oclass >= GK104_DISP) {\n\t\tdev->mode_config.cursor_width = 128;\n\t\tdev->mode_config.cursor_height = 128;\n\t} else {\n\t\tdev->mode_config.cursor_width = 64;\n\t\tdev->mode_config.cursor_height = 64;\n\t}\n\n\t \n\tif (disp->disp->object.oclass >= GV100_DISP)\n\t\tcrtcs = nvif_rd32(&device->object, 0x610060) & 0xff;\n\telse\n\tif (disp->disp->object.oclass >= GF110_DISP)\n\t\tcrtcs = nvif_rd32(&device->object, 0x612004) & 0xf;\n\telse\n\t\tcrtcs = 0x3;\n\n\tfor (i = 0; i < fls(crtcs); i++) {\n\t\tstruct nv50_head *head;\n\n\t\tif (!(crtcs & (1 << i)))\n\t\t\tcontinue;\n\n\t\thead = nv50_head_create(dev, i);\n\t\tif (IS_ERR(head)) {\n\t\t\tret = PTR_ERR(head);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (has_mst) {\n\t\t\thead->msto = nv50_msto_new(dev, head, i);\n\t\t\tif (IS_ERR(head->msto)) {\n\t\t\t\tret = PTR_ERR(head->msto);\n\t\t\t\thead->msto = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t \n\t\t\thead->msto->encoder.possible_crtcs = crtcs;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0, dcbe = &dcb->entry[0]; i < dcb->entries; i++, dcbe++) {\n\t\tconnector = nouveau_connector_create(dev, dcbe);\n\t\tif (IS_ERR(connector))\n\t\t\tcontinue;\n\n\t\tif (dcbe->location == DCB_LOC_ON_CHIP) {\n\t\t\tswitch (dcbe->type) {\n\t\t\tcase DCB_OUTPUT_TMDS:\n\t\t\tcase DCB_OUTPUT_LVDS:\n\t\t\tcase DCB_OUTPUT_DP:\n\t\t\t\tret = nv50_sor_create(connector, dcbe);\n\t\t\t\tbreak;\n\t\t\tcase DCB_OUTPUT_ANALOG:\n\t\t\t\tret = nv50_dac_create(connector, dcbe);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tret = nv50_pior_create(connector, dcbe);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tNV_WARN(drm, \"failed to create encoder %d/%d/%d: %d\\n\",\n\t\t\t\t     dcbe->location, dcbe->type,\n\t\t\t\t     ffs(dcbe->or) - 1, ret);\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(connector, tmp, &dev->mode_config.connector_list, head) {\n\t\tif (connector->possible_encoders)\n\t\t\tcontinue;\n\n\t\tNV_WARN(drm, \"%s has no encoders, removing\\n\",\n\t\t\tconnector->name);\n\t\tconnector->funcs->destroy(connector);\n\t}\n\n\t \n\tdev->vblank_disable_immediate = true;\n\n\tnv50_audio_component_init(drm);\n\nout:\n\tif (ret)\n\t\tnv50_display_destroy(dev);\n\treturn ret;\n}\n\n \n\n \nconst u64 disp50xx_modifiers[] = {  \n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x7a, 0),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x7a, 1),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x7a, 2),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x7a, 3),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x7a, 4),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x7a, 5),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x78, 0),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x78, 1),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x78, 2),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x78, 3),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x78, 4),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x78, 5),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x70, 0),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x70, 1),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x70, 2),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x70, 3),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x70, 4),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 1, 0x70, 5),\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\n \nconst u64 disp90xx_modifiers[] = {  \n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 0, 0xfe, 0),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 0, 0xfe, 1),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 0, 0xfe, 2),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 0, 0xfe, 3),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 0, 0xfe, 4),\n\tDRM_FORMAT_MOD_NVIDIA_BLOCK_LINEAR_2D(0, 1, 0, 0xfe, 5),\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}