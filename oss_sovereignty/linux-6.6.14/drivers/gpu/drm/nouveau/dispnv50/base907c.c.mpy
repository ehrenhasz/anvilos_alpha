{
  "module_name": "base907c.c",
  "hash_id": "172eeaed39ce298ef1199365c31c97a46404a513cf23a2d7f3f7a0895806820b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/base907c.c",
  "human_readable_source": " \n#include \"base.h\"\n\n#include <nvif/push507c.h>\n\n#include <nvhw/class/cl907c.h>\n\nstatic int\nbase907c_image_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 10)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV907C, SET_PRESENT_CONTROL,\n\t\t  NVVAL(NV907C, SET_PRESENT_CONTROL, BEGIN_MODE, asyw->image.mode) |\n\t\t  NVDEF(NV907C, SET_PRESENT_CONTROL, TIMESTAMP_MODE, DISABLE) |\n\t\t  NVVAL(NV907C, SET_PRESENT_CONTROL, MIN_PRESENT_INTERVAL, asyw->image.interval));\n\n\tPUSH_MTHD(push, NV907C, SET_CONTEXT_DMAS_ISO(0), asyw->image.handle, 1);\n\n\tPUSH_MTHD(push, NV907C, SURFACE_SET_OFFSET(0, 0), asyw->image.offset[0] >> 8,\n\t\t\t\tSURFACE_SET_OFFSET(0, 1), 0x00000000,\n\n\t\t\t\tSURFACE_SET_SIZE(0),\n\t\t  NVVAL(NV907C, SURFACE_SET_SIZE, WIDTH, asyw->image.w) |\n\t\t  NVVAL(NV907C, SURFACE_SET_SIZE, HEIGHT, asyw->image.h),\n\n\t\t\t\tSURFACE_SET_STORAGE(0),\n\t\t  NVVAL(NV907C, SURFACE_SET_STORAGE, BLOCK_HEIGHT, asyw->image.blockh) |\n\t\t  NVVAL(NV907C, SURFACE_SET_STORAGE, PITCH, asyw->image.pitch[0] >> 8) |\n\t\t  NVVAL(NV907C, SURFACE_SET_STORAGE, PITCH, asyw->image.blocks[0]) |\n\t\t  NVVAL(NV907C, SURFACE_SET_STORAGE, MEMORY_LAYOUT, asyw->image.layout),\n\n\t\t\t\tSURFACE_SET_PARAMS(0),\n\t\t  NVVAL(NV907C, SURFACE_SET_PARAMS, FORMAT, asyw->image.format) |\n\t\t  NVDEF(NV907C, SURFACE_SET_PARAMS, SUPER_SAMPLE, X1_AA) |\n\t\t  NVDEF(NV907C, SURFACE_SET_PARAMS, GAMMA, LINEAR) |\n\t\t  NVDEF(NV907C, SURFACE_SET_PARAMS, LAYOUT, FRM));\n\treturn 0;\n}\n\nstatic int\nbase907c_xlut_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 6)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV907C, SET_BASE_LUT_LO,\n\t\t  NVDEF(NV907C, SET_BASE_LUT_LO, ENABLE, DISABLE));\n\n\tPUSH_MTHD(push, NV907C, SET_OUTPUT_LUT_LO,\n\t\t  NVDEF(NV907C, SET_OUTPUT_LUT_LO, ENABLE, DISABLE));\n\n\tPUSH_MTHD(push, NV907C, SET_CONTEXT_DMA_LUT, 0x00000000);\n\treturn 0;\n}\n\nstatic int\nbase907c_xlut_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 6)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV907C, SET_BASE_LUT_LO,\n\t\t  NVVAL(NV907C, SET_BASE_LUT_LO, ENABLE, asyw->xlut.i.enable) |\n\t\t  NVVAL(NV907C, SET_BASE_LUT_LO, MODE, asyw->xlut.i.mode),\n\n\t\t\t\tSET_BASE_LUT_HI, asyw->xlut.i.offset >> 8,\n\n\t\t\t\tSET_OUTPUT_LUT_LO,\n\t\t  NVDEF(NV907C, SET_OUTPUT_LUT_LO, ENABLE, USE_CORE_LUT));\n\n\tPUSH_MTHD(push, NV907C, SET_CONTEXT_DMA_LUT, asyw->xlut.handle);\n\treturn 0;\n}\n\nstatic void\nbase907c_ilut(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw, int size)\n{\n\tif (size == 1024)\n\t\tasyw->xlut.i.mode = NV907C_SET_BASE_LUT_LO_MODE_INTERPOLATE_1025_UNITY_RANGE;\n\telse\n\t\tasyw->xlut.i.mode = NV907C_SET_BASE_LUT_LO_MODE_INTERPOLATE_257_UNITY_RANGE;\n\n\tasyw->xlut.i.enable = NV907C_SET_BASE_LUT_LO_ENABLE_ENABLE;\n\tasyw->xlut.i.load = head907d_olut_load;\n}\n\nstatic inline u32\ncsc_drm_to_base(u64 in)\n{\n\t \n\tbool sign = in & BIT_ULL(63);\n\tu32 integer = (in >> 32) & 0x7fffffff;\n\tu32 fraction = in & 0xffffffff;\n\n\tif (integer >= 4) {\n\t\treturn (1 << 18) - (sign ? 0 : 1);\n\t} else {\n\t\tu32 ret = (integer << 16) | (fraction >> 16);\n\t\tif (sign)\n\t\t\tret = -ret;\n\t\treturn ret & GENMASK(18, 0);\n\t}\n}\n\nvoid\nbase907c_csc(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t     const struct drm_color_ctm *ctm)\n{\n\tint i, j;\n\n\tfor (j = 0; j < 3; j++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tu32 *val = &asyw->csc.matrix[j * 4 + i];\n\t\t\t \n\t\t\tif (i == 3) {\n\t\t\t\t*val = 0;\n\t\t\t} else {\n\t\t\t\t*val = csc_drm_to_base(ctm->matrix[j * 3 + i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\nbase907c_csc_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV907C, SET_CSC_RED2RED,\n\t\t  NVDEF(NV907C, SET_CSC_RED2RED, OWNER, CORE));\n\treturn 0;\n}\n\nstatic int\nbase907c_csc_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 13)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV907C, SET_CSC_RED2RED,\n\t\t  NVDEF(NV907C, SET_CSC_RED2RED, OWNER, BASE) |\n\t\t  NVVAL(NV907C, SET_CSC_RED2RED, COEFF, asyw->csc.matrix[0]),\n\n\t\t\t\tSET_CSC_GRN2RED, &asyw->csc.matrix[1], 11);\n\treturn 0;\n}\n\nconst struct nv50_wndw_func\nbase907c = {\n\t.acquire = base507c_acquire,\n\t.release = base507c_release,\n\t.sema_set = base507c_sema_set,\n\t.sema_clr = base507c_sema_clr,\n\t.ntfy_reset = base507c_ntfy_reset,\n\t.ntfy_set = base507c_ntfy_set,\n\t.ntfy_clr = base507c_ntfy_clr,\n\t.ntfy_wait_begun = base507c_ntfy_wait_begun,\n\t.ilut = base907c_ilut,\n\t.csc = base907c_csc,\n\t.csc_set = base907c_csc_set,\n\t.csc_clr = base907c_csc_clr,\n\t.olut_core = true,\n\t.ilut_size = 1024,\n\t.xlut_set = base907c_xlut_set,\n\t.xlut_clr = base907c_xlut_clr,\n\t.image_set = base907c_image_set,\n\t.image_clr = base507c_image_clr,\n\t.update = base507c_update,\n};\n\nint\nbase907c_new(struct nouveau_drm *drm, int head, s32 oclass,\n\t     struct nv50_wndw **pwndw)\n{\n\treturn base507c_new_(&base907c, base507c_format, drm, head, oclass,\n\t\t\t     0x00000002 << (head * 4), pwndw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}