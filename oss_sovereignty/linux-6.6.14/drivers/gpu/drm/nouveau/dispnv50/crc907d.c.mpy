{
  "module_name": "crc907d.c",
  "hash_id": "dfc3e752d1e96591cefa2e2bb79ac1e7c018a99d12c908ec730935515186ddc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/crc907d.c",
  "human_readable_source": "\n#include <drm/drm_crtc.h>\n\n#include \"crc.h\"\n#include \"core.h\"\n#include \"disp.h\"\n#include \"head.h\"\n\n#include <nvif/push507c.h>\n\n#include <nvhw/class/cl907d.h>\n\n#define CRC907D_MAX_ENTRIES 255\n\nstruct crc907d_notifier {\n\tu32 status;\n\tu32 :32;  \n\tstruct crc907d_entry {\n\t\tu32 status;\n\t\tu32 compositor_crc;\n\t\tu32 output_crc[2];\n\t} entries[CRC907D_MAX_ENTRIES];\n} __packed;\n\nstatic int\ncrc907d_set_src(struct nv50_head *head, int or, enum nv50_crc_source_type source,\n\t\tstruct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tu32 crc_args = NVDEF(NV907D, HEAD_SET_CRC_CONTROL, CONTROLLING_CHANNEL, CORE) |\n\t\t       NVDEF(NV907D, HEAD_SET_CRC_CONTROL, EXPECT_BUFFER_COLLAPSE, FALSE) |\n\t\t       NVDEF(NV907D, HEAD_SET_CRC_CONTROL, TIMESTAMP_MODE, FALSE) |\n\t\t       NVDEF(NV907D, HEAD_SET_CRC_CONTROL, SECONDARY_OUTPUT, NONE) |\n\t\t       NVDEF(NV907D, HEAD_SET_CRC_CONTROL, CRC_DURING_SNOOZE, DISABLE) |\n\t\t       NVDEF(NV907D, HEAD_SET_CRC_CONTROL, WIDE_PIPE_CRC, ENABLE);\n\tint ret;\n\n\tswitch (source) {\n\tcase NV50_CRC_SOURCE_TYPE_SOR:\n\t\tcrc_args |= NVDEF(NV907D, HEAD_SET_CRC_CONTROL, PRIMARY_OUTPUT, SOR(or));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_TYPE_PIOR:\n\t\tcrc_args |= NVDEF(NV907D, HEAD_SET_CRC_CONTROL, PRIMARY_OUTPUT, PIOR(or));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_TYPE_DAC:\n\t\tcrc_args |= NVDEF(NV907D, HEAD_SET_CRC_CONTROL, PRIMARY_OUTPUT, DAC(or));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_TYPE_RG:\n\t\tcrc_args |= NVDEF(NV907D, HEAD_SET_CRC_CONTROL, PRIMARY_OUTPUT, RG(i));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_TYPE_SF:\n\t\tcrc_args |= NVDEF(NV907D, HEAD_SET_CRC_CONTROL, PRIMARY_OUTPUT, SF(i));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_NONE:\n\t\tcrc_args |= NVDEF(NV907D, HEAD_SET_CRC_CONTROL, PRIMARY_OUTPUT, NONE);\n\t\tbreak;\n\t}\n\n\tif ((ret = PUSH_WAIT(push, 4)))\n\t\treturn ret;\n\n\tif (source) {\n\t\tPUSH_MTHD(push, NV907D, HEAD_SET_CONTEXT_DMA_CRC(i), ctx->ntfy.handle);\n\t\tPUSH_MTHD(push, NV907D, HEAD_SET_CRC_CONTROL(i), crc_args);\n\t} else {\n\t\tPUSH_MTHD(push, NV907D, HEAD_SET_CRC_CONTROL(i), crc_args);\n\t\tPUSH_MTHD(push, NV907D, HEAD_SET_CONTEXT_DMA_CRC(i), 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncrc907d_set_ctx(struct nv50_head *head, struct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV907D, HEAD_SET_CONTEXT_DMA_CRC(i), ctx ? ctx->ntfy.handle : 0);\n\treturn 0;\n}\n\nstatic u32 crc907d_get_entry(struct nv50_head *head,\n\t\t\t     struct nv50_crc_notifier_ctx *ctx,\n\t\t\t     enum nv50_crc_source source, int idx)\n{\n\tstruct crc907d_notifier __iomem *notifier = ctx->mem.object.map.ptr;\n\n\treturn ioread32_native(&notifier->entries[idx].output_crc[0]);\n}\n\nstatic bool crc907d_ctx_finished(struct nv50_head *head,\n\t\t\t\t struct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(head->base.base.dev);\n\tstruct crc907d_notifier __iomem *notifier = ctx->mem.object.map.ptr;\n\tconst u32 status = ioread32_native(&notifier->status);\n\tconst u32 overflow = status & 0x0000003e;\n\n\tif (!(status & 0x00000001))\n\t\treturn false;\n\n\tif (overflow) {\n\t\tconst char *engine = NULL;\n\n\t\tswitch (overflow) {\n\t\tcase 0x00000004: engine = \"DSI\"; break;\n\t\tcase 0x00000008: engine = \"Compositor\"; break;\n\t\tcase 0x00000010: engine = \"CRC output 1\"; break;\n\t\tcase 0x00000020: engine = \"CRC output 2\"; break;\n\t\t}\n\n\t\tif (engine)\n\t\t\tNV_ERROR(drm,\n\t\t\t\t \"CRC notifier context for head %d overflowed on %s: %x\\n\",\n\t\t\t\t head->base.index, engine, status);\n\t\telse\n\t\t\tNV_ERROR(drm,\n\t\t\t\t \"CRC notifier context for head %d overflowed: %x\\n\",\n\t\t\t\t head->base.index, status);\n\t}\n\n\tNV_DEBUG(drm, \"Head %d CRC context status: %x\\n\",\n\t\t head->base.index, status);\n\n\treturn true;\n}\n\nconst struct nv50_crc_func crc907d = {\n\t.set_src = crc907d_set_src,\n\t.set_ctx = crc907d_set_ctx,\n\t.get_entry = crc907d_get_entry,\n\t.ctx_finished = crc907d_ctx_finished,\n\t.flip_threshold = CRC907D_MAX_ENTRIES - 10,\n\t.num_entries = CRC907D_MAX_ENTRIES,\n\t.notifier_len = sizeof(struct crc907d_notifier),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}