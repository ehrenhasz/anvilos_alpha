{
  "module_name": "head.c",
  "hash_id": "78ed90570119b79826f20e172701b1b2c23e9f798d7c7e707d31e253f373a555",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/head.c",
  "human_readable_source": " \n#include \"head.h\"\n#include \"base.h\"\n#include \"core.h\"\n#include \"curs.h\"\n#include \"ovly.h\"\n#include \"crc.h\"\n\n#include <nvif/class.h>\n#include <nvif/event.h>\n#include <nvif/cl0046.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_vblank.h>\n#include \"nouveau_connector.h\"\n\nvoid\nnv50_head_flush_clr(struct nv50_head *head,\n\t\t    struct nv50_head_atom *asyh, bool flush)\n{\n\tunion nv50_head_atom_mask clr = {\n\t\t.mask = asyh->clr.mask & ~(flush ? 0 : asyh->set.mask),\n\t};\n\tif (clr.crc)  nv50_crc_atomic_clr(head);\n\tif (clr.olut) head->func->olut_clr(head);\n\tif (clr.core) head->func->core_clr(head);\n\tif (clr.curs) head->func->curs_clr(head);\n}\n\nvoid\nnv50_head_flush_set_wndw(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tif (asyh->set.curs   ) head->func->curs_set(head, asyh);\n\tif (asyh->set.olut   ) {\n\t\tasyh->olut.offset = nv50_lut_load(&head->olut,\n\t\t\t\t\t\t  asyh->olut.buffer,\n\t\t\t\t\t\t  asyh->state.gamma_lut,\n\t\t\t\t\t\t  asyh->olut.load);\n\t\thead->func->olut_set(head, asyh);\n\t}\n}\n\nvoid\nnv50_head_flush_set(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tif (asyh->set.view   ) head->func->view    (head, asyh);\n\tif (asyh->set.mode   ) head->func->mode    (head, asyh);\n\tif (asyh->set.core   ) head->func->core_set(head, asyh);\n\tif (asyh->set.base   ) head->func->base    (head, asyh);\n\tif (asyh->set.ovly   ) head->func->ovly    (head, asyh);\n\tif (asyh->set.dither ) head->func->dither  (head, asyh);\n\tif (asyh->set.procamp) head->func->procamp (head, asyh);\n\tif (asyh->set.crc    ) nv50_crc_atomic_set (head, asyh);\n\tif (asyh->set.or     ) head->func->or      (head, asyh);\n}\n\nstatic void\nnv50_head_atomic_check_procamp(struct nv50_head_atom *armh,\n\t\t\t       struct nv50_head_atom *asyh,\n\t\t\t       struct nouveau_conn_atom *asyc)\n{\n\tconst int vib = asyc->procamp.color_vibrance - 100;\n\tconst int hue = asyc->procamp.vibrant_hue - 90;\n\tconst int adj = (vib > 0) ? 50 : 0;\n\tasyh->procamp.sat.cos = ((vib * 2047 + adj) / 100) & 0xfff;\n\tasyh->procamp.sat.sin = ((hue * 2047) / 100) & 0xfff;\n\tasyh->set.procamp = true;\n}\n\nstatic void\nnv50_head_atomic_check_dither(struct nv50_head_atom *armh,\n\t\t\t      struct nv50_head_atom *asyh,\n\t\t\t      struct nouveau_conn_atom *asyc)\n{\n\tu32 mode = 0x00;\n\n\tif (asyc->dither.mode) {\n\t\tif (asyc->dither.mode == DITHERING_MODE_AUTO) {\n\t\t\tif (asyh->base.depth > asyh->or.bpc * 3)\n\t\t\t\tmode = DITHERING_MODE_DYNAMIC2X2;\n\t\t} else {\n\t\t\tmode = asyc->dither.mode;\n\t\t}\n\n\t\tif (asyc->dither.depth == DITHERING_DEPTH_AUTO) {\n\t\t\tif (asyh->or.bpc >= 8)\n\t\t\t\tmode |= DITHERING_DEPTH_8BPC;\n\t\t} else {\n\t\t\tmode |= asyc->dither.depth;\n\t\t}\n\t}\n\n\tasyh->dither.enable = NVVAL_GET(mode, NV507D, HEAD_SET_DITHER_CONTROL, ENABLE);\n\tasyh->dither.bits = NVVAL_GET(mode, NV507D, HEAD_SET_DITHER_CONTROL, BITS);\n\tasyh->dither.mode = NVVAL_GET(mode, NV507D, HEAD_SET_DITHER_CONTROL, MODE);\n\tasyh->set.dither = true;\n}\n\nstatic void\nnv50_head_atomic_check_view(struct nv50_head_atom *armh,\n\t\t\t    struct nv50_head_atom *asyh,\n\t\t\t    struct nouveau_conn_atom *asyc)\n{\n\tstruct drm_connector *connector = asyc->state.connector;\n\tstruct drm_display_mode *omode = &asyh->state.adjusted_mode;\n\tstruct drm_display_mode *umode = &asyh->state.mode;\n\tint mode = asyc->scaler.mode;\n\tstruct edid *edid;\n\tint umode_vdisplay, omode_hdisplay, omode_vdisplay;\n\n\tif (connector->edid_blob_ptr)\n\t\tedid = (struct edid *)connector->edid_blob_ptr->data;\n\telse\n\t\tedid = NULL;\n\n\tif (!asyc->scaler.full) {\n\t\tif (mode == DRM_MODE_SCALE_NONE)\n\t\t\tomode = umode;\n\t} else {\n\t\t \n\t\tmode = DRM_MODE_SCALE_FULLSCREEN;\n\t}\n\n\t \n\tumode_vdisplay = umode->vdisplay;\n\tif ((umode->flags & DRM_MODE_FLAG_3D_MASK) == DRM_MODE_FLAG_3D_FRAME_PACKING)\n\t\tumode_vdisplay += umode->vtotal;\n\tasyh->view.iW = umode->hdisplay;\n\tasyh->view.iH = umode_vdisplay;\n\t \n\tdrm_mode_get_hv_timing(omode, &omode_hdisplay, &omode_vdisplay);\n\tasyh->view.oW = omode_hdisplay;\n\tasyh->view.oH = omode_vdisplay;\n\n\t \n\tif ((asyc->scaler.underscan.mode == UNDERSCAN_ON ||\n\t    (asyc->scaler.underscan.mode == UNDERSCAN_AUTO &&\n\t     drm_detect_hdmi_monitor(edid)))) {\n\t\tu32 bX = asyc->scaler.underscan.hborder;\n\t\tu32 bY = asyc->scaler.underscan.vborder;\n\t\tu32 r = (asyh->view.oH << 19) / asyh->view.oW;\n\n\t\tif (bX) {\n\t\t\tasyh->view.oW -= (bX * 2);\n\t\t\tif (bY) asyh->view.oH -= (bY * 2);\n\t\t\telse    asyh->view.oH  = ((asyh->view.oW * r) + (r / 2)) >> 19;\n\t\t} else {\n\t\t\tasyh->view.oW -= (asyh->view.oW >> 4) + 32;\n\t\t\tif (bY) asyh->view.oH -= (bY * 2);\n\t\t\telse    asyh->view.oH  = ((asyh->view.oW * r) + (r / 2)) >> 19;\n\t\t}\n\t}\n\n\t \n\tswitch (mode) {\n\tcase DRM_MODE_SCALE_CENTER:\n\t\t \n\t\tasyh->view.oW = min(asyh->view.iW, asyh->view.oW);\n\t\tasyh->view.oH = min(asyh->view.iH, asyh->view.oH);\n\t\tbreak;\n\tcase DRM_MODE_SCALE_ASPECT:\n\t\t \n\t\tif (asyh->view.oW * asyh->view.iH > asyh->view.iW * asyh->view.oH) {\n\t\t\t \n\t\t\tu32 r = (asyh->view.iW << 19) / asyh->view.iH;\n\t\t\tasyh->view.oW = ((asyh->view.oH * r) + (r / 2)) >> 19;\n\t\t} else {\n\t\t\t \n\t\t\tu32 r = (asyh->view.iH << 19) / asyh->view.iW;\n\t\t\tasyh->view.oH = ((asyh->view.oW * r) + (r / 2)) >> 19;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tasyh->set.view = true;\n}\n\nstatic int\nnv50_head_atomic_check_lut(struct nv50_head *head,\n\t\t\t   struct nv50_head_atom *asyh)\n{\n\tstruct drm_device *dev = head->base.base.dev;\n\tstruct drm_crtc *crtc = &head->base.base;\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_property_blob *olut = asyh->state.gamma_lut,\n\t\t\t\t *ilut = asyh->state.degamma_lut;\n\tint size;\n\n\t \n\tif (ilut) {\n\t\tsize = drm_color_lut_size(ilut);\n\t\tif (!head->func->ilut_check(size)) {\n\t\t\tNV_ATOMIC(drm, \"Invalid size %d for degamma on [CRTC:%d:%s]\\n\",\n\t\t\t\t  size, crtc->base.id, crtc->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (olut) {\n\t\t \n\t\tif (asyh->wndw.olut) {\n\t\t\t \n\t\t\tif (asyh->wndw.olut != asyh->wndw.mask)\n\t\t\t\treturn -EINVAL;\n\t\t\tolut = NULL;\n\t\t}\n\t}\n\n\tif (!olut) {\n\t\tif (!head->func->olut_identity) {\n\t\t\tasyh->olut.handle = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tsize = 0;\n\t} else {\n\t\tsize = drm_color_lut_size(olut);\n\t}\n\n\tif (!head->func->olut(head, asyh, size)) {\n\t\tNV_ATOMIC(drm, \"Invalid size %d for gamma on [CRTC:%d:%s]\\n\",\n\t\t\t  size, crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\tasyh->olut.handle = disp->core->chan.vram.handle;\n\tasyh->olut.buffer = !asyh->olut.buffer;\n\n\treturn 0;\n}\n\nstatic void\nnv50_head_atomic_check_mode(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tstruct drm_display_mode *mode = &asyh->state.adjusted_mode;\n\tstruct nv50_head_mode *m = &asyh->mode;\n\tu32 blankus;\n\n\tdrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V | CRTC_STEREO_DOUBLE);\n\n\t \n\n\tm->h.active = mode->crtc_htotal;\n\tm->h.synce  = mode->crtc_hsync_end - mode->crtc_hsync_start - 1;\n\tm->h.blanke = mode->crtc_hblank_end - mode->crtc_hsync_start - 1;\n\tm->h.blanks = m->h.blanke + mode->crtc_hdisplay;\n\n\tm->v.active = mode->crtc_vtotal;\n\tm->v.synce  = mode->crtc_vsync_end - mode->crtc_vsync_start - 1;\n\tm->v.blanke = mode->crtc_vblank_end - mode->crtc_vsync_start - 1;\n\tm->v.blanks = m->v.blanke + mode->crtc_vdisplay;\n\n\t \n\tblankus = (m->v.active - mode->crtc_vdisplay - 2) * m->h.active;\n\tblankus *= 1000;\n\tblankus /= mode->crtc_clock;\n\tm->v.blankus = blankus;\n\n\tif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\n\t\tm->v.blank2e =  m->v.active + m->v.blanke;\n\t\tm->v.blank2s =  m->v.blank2e + mode->crtc_vdisplay;\n\t\tm->v.active  = (m->v.active * 2) + 1;\n\t\tm->interlace = true;\n\t} else {\n\t\tm->v.blank2e = 0;\n\t\tm->v.blank2s = 1;\n\t\tm->interlace = false;\n\t}\n\tm->clock = mode->crtc_clock;\n\n\tasyh->or.nhsync = !!(mode->flags & DRM_MODE_FLAG_NHSYNC);\n\tasyh->or.nvsync = !!(mode->flags & DRM_MODE_FLAG_NVSYNC);\n\tasyh->set.or = head->func->or != NULL;\n\tasyh->set.mode = true;\n}\n\nstatic int\nnv50_head_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_crtc_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t      crtc);\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\n\tstruct nv50_head *head = nv50_head(crtc);\n\tstruct nv50_head_atom *armh = nv50_head_atom(old_crtc_state);\n\tstruct nv50_head_atom *asyh = nv50_head_atom(crtc_state);\n\tstruct nouveau_conn_atom *asyc = NULL;\n\tstruct drm_connector_state *conns;\n\tstruct drm_connector *conn;\n\tint i, ret;\n\tbool check_lut = asyh->state.color_mgmt_changed ||\n\t\t\t memcmp(&armh->wndw, &asyh->wndw, sizeof(asyh->wndw));\n\n\tNV_ATOMIC(drm, \"%s atomic_check %d\\n\", crtc->name, asyh->state.active);\n\n\tif (check_lut) {\n\t\tret = nv50_head_atomic_check_lut(head, asyh);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (asyh->state.active) {\n\t\tfor_each_new_connector_in_state(asyh->state.state, conn, conns, i) {\n\t\t\tif (conns->crtc == crtc) {\n\t\t\t\tasyc = nouveau_conn_atom(conns);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (armh->state.active) {\n\t\t\tif (asyc) {\n\t\t\t\tif (asyh->state.mode_changed)\n\t\t\t\t\tasyc->set.scaler = true;\n\t\t\t\tif (armh->base.depth != asyh->base.depth)\n\t\t\t\t\tasyc->set.dither = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (asyc)\n\t\t\t\tasyc->set.mask = ~0;\n\t\t\tasyh->set.mask = ~0;\n\t\t\tasyh->set.or = head->func->or != NULL;\n\t\t}\n\n\t\tif (asyh->state.mode_changed || asyh->state.connectors_changed)\n\t\t\tnv50_head_atomic_check_mode(head, asyh);\n\n\t\tif (check_lut)\n\t\t\tasyh->olut.visible = asyh->olut.handle != 0;\n\n\t\tif (asyc) {\n\t\t\tif (asyc->set.scaler)\n\t\t\t\tnv50_head_atomic_check_view(armh, asyh, asyc);\n\t\t\tif (asyc->set.dither)\n\t\t\t\tnv50_head_atomic_check_dither(armh, asyh, asyc);\n\t\t\tif (asyc->set.procamp)\n\t\t\t\tnv50_head_atomic_check_procamp(armh, asyh, asyc);\n\t\t}\n\n\t\tif (head->func->core_calc) {\n\t\t\thead->func->core_calc(head, asyh);\n\t\t\tif (!asyh->core.visible)\n\t\t\t\tasyh->olut.visible = false;\n\t\t}\n\n\t\tasyh->set.base = armh->base.cpp != asyh->base.cpp;\n\t\tasyh->set.ovly = armh->ovly.cpp != asyh->ovly.cpp;\n\t} else {\n\t\tasyh->olut.visible = false;\n\t\tasyh->core.visible = false;\n\t\tasyh->curs.visible = false;\n\t\tasyh->base.cpp = 0;\n\t\tasyh->ovly.cpp = 0;\n\t}\n\n\tif (!drm_atomic_crtc_needs_modeset(&asyh->state)) {\n\t\tif (asyh->core.visible) {\n\t\t\tif (memcmp(&armh->core, &asyh->core, sizeof(asyh->core)))\n\t\t\t\tasyh->set.core = true;\n\t\t} else\n\t\tif (armh->core.visible) {\n\t\t\tasyh->clr.core = true;\n\t\t}\n\n\t\tif (asyh->curs.visible) {\n\t\t\tif (memcmp(&armh->curs, &asyh->curs, sizeof(asyh->curs)))\n\t\t\t\tasyh->set.curs = true;\n\t\t} else\n\t\tif (armh->curs.visible) {\n\t\t\tasyh->clr.curs = true;\n\t\t}\n\n\t\tif (asyh->olut.visible) {\n\t\t\tif (memcmp(&armh->olut, &asyh->olut, sizeof(asyh->olut)))\n\t\t\t\tasyh->set.olut = true;\n\t\t} else\n\t\tif (armh->olut.visible) {\n\t\t\tasyh->clr.olut = true;\n\t\t}\n\t} else {\n\t\tasyh->clr.olut = armh->olut.visible;\n\t\tasyh->clr.core = armh->core.visible;\n\t\tasyh->clr.curs = armh->curs.visible;\n\t\tasyh->set.olut = asyh->olut.visible;\n\t\tasyh->set.core = asyh->core.visible;\n\t\tasyh->set.curs = asyh->curs.visible;\n\t}\n\n\tret = nv50_crc_atomic_check_head(head, asyh, armh);\n\tif (ret)\n\t\treturn ret;\n\n\tif (asyh->clr.mask || asyh->set.mask)\n\t\tnv50_atom(asyh->state.state)->lock_core = true;\n\treturn 0;\n}\n\nstatic const struct drm_crtc_helper_funcs\nnv50_head_help = {\n\t.atomic_check = nv50_head_atomic_check,\n\t.get_scanout_position = nouveau_display_scanoutpos,\n};\n\nstatic void\nnv50_head_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t       struct drm_crtc_state *state)\n{\n\tstruct nv50_head_atom *asyh = nv50_head_atom(state);\n\t__drm_atomic_helper_crtc_destroy_state(&asyh->state);\n\tkfree(asyh);\n}\n\nstatic struct drm_crtc_state *\nnv50_head_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct nv50_head_atom *armh = nv50_head_atom(crtc->state);\n\tstruct nv50_head_atom *asyh;\n\tif (!(asyh = kmalloc(sizeof(*asyh), GFP_KERNEL)))\n\t\treturn NULL;\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &asyh->state);\n\tasyh->wndw = armh->wndw;\n\tasyh->view = armh->view;\n\tasyh->mode = armh->mode;\n\tasyh->olut = armh->olut;\n\tasyh->core = armh->core;\n\tasyh->curs = armh->curs;\n\tasyh->base = armh->base;\n\tasyh->ovly = armh->ovly;\n\tasyh->dither = armh->dither;\n\tasyh->procamp = armh->procamp;\n\tasyh->crc = armh->crc;\n\tasyh->or = armh->or;\n\tasyh->dp = armh->dp;\n\tasyh->clr.mask = 0;\n\tasyh->set.mask = 0;\n\treturn &asyh->state;\n}\n\nstatic void\nnv50_head_reset(struct drm_crtc *crtc)\n{\n\tstruct nv50_head_atom *asyh;\n\n\tif (WARN_ON(!(asyh = kzalloc(sizeof(*asyh), GFP_KERNEL))))\n\t\treturn;\n\n\tif (crtc->state)\n\t\tnv50_head_atomic_destroy_state(crtc, crtc->state);\n\n\t__drm_atomic_helper_crtc_reset(crtc, &asyh->state);\n}\n\nstatic int\nnv50_head_late_register(struct drm_crtc *crtc)\n{\n\treturn nv50_head_crc_late_register(nv50_head(crtc));\n}\n\nstatic void\nnv50_head_destroy(struct drm_crtc *crtc)\n{\n\tstruct nv50_head *head = nv50_head(crtc);\n\n\tnvif_event_dtor(&head->base.vblank);\n\tnvif_head_dtor(&head->base.head);\n\tnv50_lut_fini(&head->olut);\n\tdrm_crtc_cleanup(crtc);\n\tkfree(head);\n}\n\nstatic const struct drm_crtc_funcs\nnv50_head_func = {\n\t.reset = nv50_head_reset,\n\t.destroy = nv50_head_destroy,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = nv50_head_atomic_duplicate_state,\n\t.atomic_destroy_state = nv50_head_atomic_destroy_state,\n\t.enable_vblank = nouveau_display_vblank_enable,\n\t.disable_vblank = nouveau_display_vblank_disable,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.late_register = nv50_head_late_register,\n};\n\nstatic const struct drm_crtc_funcs\nnvd9_head_func = {\n\t.reset = nv50_head_reset,\n\t.destroy = nv50_head_destroy,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.atomic_duplicate_state = nv50_head_atomic_duplicate_state,\n\t.atomic_destroy_state = nv50_head_atomic_destroy_state,\n\t.enable_vblank = nouveau_display_vblank_enable,\n\t.disable_vblank = nouveau_display_vblank_disable,\n\t.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,\n\t.verify_crc_source = nv50_crc_verify_source,\n\t.get_crc_sources = nv50_crc_get_sources,\n\t.set_crc_source = nv50_crc_set_source,\n\t.late_register = nv50_head_late_register,\n};\n\nstatic int\nnv50_head_vblank_handler(struct nvif_event *event, void *repv, u32 repc)\n{\n\tstruct nouveau_crtc *nv_crtc = container_of(event, struct nouveau_crtc, vblank);\n\n\tif (drm_crtc_handle_vblank(&nv_crtc->base))\n\t\tnv50_crc_handle_vblank(nv50_head(&nv_crtc->base));\n\n\treturn NVIF_EVENT_KEEP;\n}\n\nstruct nv50_head *\nnv50_head_create(struct drm_device *dev, int index)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv50_disp *disp = nv50_disp(dev);\n\tstruct nv50_head *head;\n\tstruct nv50_wndw *base, *ovly, *curs;\n\tstruct nouveau_crtc *nv_crtc;\n\tstruct drm_crtc *crtc;\n\tconst struct drm_crtc_funcs *funcs;\n\tint ret;\n\n\thead = kzalloc(sizeof(*head), GFP_KERNEL);\n\tif (!head)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thead->func = disp->core->func->head;\n\thead->base.index = index;\n\n\tif (disp->disp->object.oclass < GF110_DISP)\n\t\tfuncs = &nv50_head_func;\n\telse\n\t\tfuncs = &nvd9_head_func;\n\n\tif (disp->disp->object.oclass < GV100_DISP) {\n\t\tret = nv50_base_new(drm, head->base.index, &base);\n\t\tret = nv50_ovly_new(drm, head->base.index, &ovly);\n\t} else {\n\t\tret = nv50_wndw_new(drm, DRM_PLANE_TYPE_PRIMARY,\n\t\t\t\t    head->base.index * 2 + 0, &base);\n\t\tret = nv50_wndw_new(drm, DRM_PLANE_TYPE_OVERLAY,\n\t\t\t\t    head->base.index * 2 + 1, &ovly);\n\t}\n\tif (ret == 0)\n\t\tret = nv50_curs_new(drm, head->base.index, &curs);\n\tif (ret) {\n\t\tkfree(head);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tnv_crtc = &head->base;\n\tcrtc = &nv_crtc->base;\n\tdrm_crtc_init_with_planes(dev, crtc, &base->plane, &curs->plane,\n\t\t\t\t  funcs, \"head-%d\", head->base.index);\n\tdrm_crtc_helper_add(crtc, &nv50_head_help);\n\t \n\tdrm_mode_crtc_set_gamma_size(crtc, 256);\n\tdrm_crtc_enable_color_mgmt(crtc, base->func->ilut_size,\n\t\t\t\t   disp->disp->object.oclass >= GF110_DISP,\n\t\t\t\t   head->func->olut_size);\n\n\tif (head->func->olut_set) {\n\t\tret = nv50_lut_init(disp, &drm->client.mmu, &head->olut);\n\t\tif (ret) {\n\t\t\tnv50_head_destroy(crtc);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tret = nvif_head_ctor(disp->disp, head->base.base.name, head->base.index, &head->base.head);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = nvif_head_vblank_event_ctor(&head->base.head, \"kmsVbl\", nv50_head_vblank_handler,\n\t\t\t\t\t  false, &nv_crtc->vblank);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn head;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}