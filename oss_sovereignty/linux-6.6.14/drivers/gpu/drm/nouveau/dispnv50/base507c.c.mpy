{
  "module_name": "base507c.c",
  "hash_id": "d62fa41a5bbed4cde4b0298d7ea0b1325a9e4d5b0fd7f28bf3ac1febe1543c3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/base507c.c",
  "human_readable_source": " \n#include \"base.h\"\n\n#include <nvif/if0014.h>\n#include <nvif/push507c.h>\n#include <nvif/timer.h>\n\n#include <nvhw/class/cl507c.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include \"nouveau_bo.h\"\n\nint\nbase507c_update(struct nv50_wndw *wndw, u32 *interlock)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, UPDATE, interlock[NV50_DISP_INTERLOCK_CORE]);\n\treturn PUSH_KICK(push);\n}\n\nint\nbase507c_image_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 4)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_PRESENT_CONTROL,\n\t\t  NVDEF(NV507C, SET_PRESENT_CONTROL, BEGIN_MODE, NON_TEARING) |\n\t\t  NVVAL(NV507C, SET_PRESENT_CONTROL, MIN_PRESENT_INTERVAL, 0));\n\n\tPUSH_MTHD(push, NV507C, SET_CONTEXT_DMA_ISO, 0x00000000);\n\treturn 0;\n}\n\nstatic int\nbase507c_image_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 13)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_PRESENT_CONTROL,\n\t\t  NVVAL(NV507C, SET_PRESENT_CONTROL, BEGIN_MODE, asyw->image.mode) |\n\t\t  NVVAL(NV507C, SET_PRESENT_CONTROL, MIN_PRESENT_INTERVAL, asyw->image.interval));\n\n\tPUSH_MTHD(push, NV507C, SET_CONTEXT_DMA_ISO, asyw->image.handle[0]);\n\n\tif (asyw->image.format == NV507C_SURFACE_SET_PARAMS_FORMAT_RF16_GF16_BF16_AF16) {\n\t\tPUSH_MTHD(push, NV507C, SET_PROCESSING,\n\t\t\t  NVDEF(NV507C, SET_PROCESSING, USE_GAIN_OFS, ENABLE),\n\n\t\t\t\t\tSET_CONVERSION,\n\t\t\t  NVVAL(NV507C, SET_CONVERSION, GAIN, 0) |\n\t\t\t  NVVAL(NV507C, SET_CONVERSION, OFS, 0x64));\n\t} else {\n\t\tPUSH_MTHD(push, NV507C, SET_PROCESSING,\n\t\t\t  NVDEF(NV507C, SET_PROCESSING, USE_GAIN_OFS, DISABLE),\n\n\t\t\t\t\tSET_CONVERSION,\n\t\t\t  NVVAL(NV507C, SET_CONVERSION, GAIN, 0) |\n\t\t\t  NVVAL(NV507C, SET_CONVERSION, OFS, 0));\n\t}\n\n\tPUSH_MTHD(push, NV507C, SURFACE_SET_OFFSET(0, 0), asyw->image.offset[0] >> 8);\n\n\tPUSH_MTHD(push, NV507C, SURFACE_SET_SIZE(0),\n\t\t  NVVAL(NV507C, SURFACE_SET_SIZE, WIDTH, asyw->image.w) |\n\t\t  NVVAL(NV507C, SURFACE_SET_SIZE, HEIGHT, asyw->image.h),\n\n\t\t\t\tSURFACE_SET_STORAGE(0),\n\t\t  NVVAL(NV507C, SURFACE_SET_STORAGE, MEMORY_LAYOUT, asyw->image.layout) |\n\t\t  NVVAL(NV507C, SURFACE_SET_STORAGE, PITCH, asyw->image.pitch[0] >> 8) |\n\t\t  NVVAL(NV507C, SURFACE_SET_STORAGE, PITCH, asyw->image.blocks[0]) |\n\t\t  NVVAL(NV507C, SURFACE_SET_STORAGE, BLOCK_HEIGHT, asyw->image.blockh),\n\n\t\t\t\tSURFACE_SET_PARAMS(0),\n\t\t  NVVAL(NV507C, SURFACE_SET_PARAMS, FORMAT, asyw->image.format) |\n\t\t  NVDEF(NV507C, SURFACE_SET_PARAMS, SUPER_SAMPLE, X1_AA) |\n\t\t  NVDEF(NV507C, SURFACE_SET_PARAMS, GAMMA, LINEAR) |\n\t\t  NVDEF(NV507C, SURFACE_SET_PARAMS, LAYOUT, FRM) |\n\t\t  NVVAL(NV507C, SURFACE_SET_PARAMS, KIND, asyw->image.kind) |\n\t\t  NVDEF(NV507C, SURFACE_SET_PARAMS, PART_STRIDE, PARTSTRIDE_256));\n\treturn 0;\n}\n\nint\nbase507c_xlut_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_BASE_LUT_LO,\n\t\t  NVDEF(NV507C, SET_BASE_LUT_LO, ENABLE, DISABLE));\n\treturn 0;\n}\n\nint\nbase507c_xlut_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_BASE_LUT_LO,\n\t\t  NVDEF(NV507C, SET_BASE_LUT_LO, ENABLE, USE_CORE_LUT));\n\treturn 0;\n}\n\nint\nbase507c_ntfy_wait_begun(struct nouveau_bo *bo, u32 offset,\n\t\t\t struct nvif_device *device)\n{\n\ts64 time = nvif_msec(device, 2000ULL,\n\t\tif (NVBO_TD32(bo, offset, NV_DISP_BASE_NOTIFIER_1, _0, STATUS, ==, BEGUN))\n\t\t\tbreak;\n\t\tusleep_range(1, 2);\n\t);\n\treturn time < 0 ? time : 0;\n}\n\nint\nbase507c_ntfy_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_CONTEXT_DMA_NOTIFIER, 0x00000000);\n\treturn 0;\n}\n\nint\nbase507c_ntfy_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 3)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_NOTIFIER_CONTROL,\n\t\t  NVVAL(NV507C, SET_NOTIFIER_CONTROL, MODE, asyw->ntfy.awaken) |\n\t\t  NVVAL(NV507C, SET_NOTIFIER_CONTROL, OFFSET, asyw->ntfy.offset >> 2),\n\n\t\t\t\tSET_CONTEXT_DMA_NOTIFIER, asyw->ntfy.handle);\n\treturn 0;\n}\n\nvoid\nbase507c_ntfy_reset(struct nouveau_bo *bo, u32 offset)\n{\n\tNVBO_WR32(bo, offset, NV_DISP_BASE_NOTIFIER_1, _0,\n\t\t\tNVDEF(NV_DISP_BASE_NOTIFIER_1, _0, STATUS, NOT_BEGUN));\n}\n\nint\nbase507c_sema_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_CONTEXT_DMA_SEMAPHORE, 0x00000000);\n\treturn 0;\n}\n\nint\nbase507c_sema_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 5)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507C, SET_SEMAPHORE_CONTROL, asyw->sema.offset,\n\t\t\t\tSET_SEMAPHORE_ACQUIRE, asyw->sema.acquire,\n\t\t\t\tSET_SEMAPHORE_RELEASE, asyw->sema.release,\n\t\t\t\tSET_CONTEXT_DMA_SEMAPHORE, asyw->sema.handle);\n\treturn 0;\n}\n\nvoid\nbase507c_release(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\tasyh->base.cpp = 0;\n}\n\nint\nbase507c_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\tconst struct drm_framebuffer *fb = asyw->state.fb;\n\tint ret;\n\n\tret = drm_atomic_helper_check_plane_state(&asyw->state, &asyh->state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  false, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wndw->func->ilut) {\n\t\tif ((asyh->base.cpp != 1) ^ (fb->format->cpp[0] != 1))\n\t\t\tasyh->state.color_mgmt_changed = true;\n\t}\n\n\tasyh->base.depth = fb->format->depth;\n\tasyh->base.cpp = fb->format->cpp[0];\n\tasyh->base.x = asyw->state.src.x1 >> 16;\n\tasyh->base.y = asyw->state.src.y1 >> 16;\n\tasyh->base.w = asyw->state.fb->width;\n\tasyh->base.h = asyw->state.fb->height;\n\n\t \n\tif (!asyh->base.depth)\n\t\tasyh->base.depth = asyh->base.cpp * 8;\n\n\treturn 0;\n}\n\nconst u32\nbase507c_format[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_ABGR16161616F,\n\t0\n};\n\nstatic const struct nv50_wndw_func\nbase507c = {\n\t.acquire = base507c_acquire,\n\t.release = base507c_release,\n\t.sema_set = base507c_sema_set,\n\t.sema_clr = base507c_sema_clr,\n\t.ntfy_reset = base507c_ntfy_reset,\n\t.ntfy_set = base507c_ntfy_set,\n\t.ntfy_clr = base507c_ntfy_clr,\n\t.ntfy_wait_begun = base507c_ntfy_wait_begun,\n\t.olut_core = 1,\n\t.xlut_set = base507c_xlut_set,\n\t.xlut_clr = base507c_xlut_clr,\n\t.image_set = base507c_image_set,\n\t.image_clr = base507c_image_clr,\n\t.update = base507c_update,\n};\n\nint\nbase507c_new_(const struct nv50_wndw_func *func, const u32 *format,\n\t      struct nouveau_drm *drm, int head, s32 oclass, u32 interlock_data,\n\t      struct nv50_wndw **pwndw)\n{\n\tstruct nvif_disp_chan_v0 args = {\n\t\t.id = head,\n\t};\n\tstruct nouveau_display *disp = nouveau_display(drm->dev);\n\tstruct nv50_disp *disp50 = nv50_disp(drm->dev);\n\tstruct nv50_wndw *wndw;\n\tint ret;\n\n\tret = nv50_wndw_new_(func, drm->dev, DRM_PLANE_TYPE_PRIMARY,\n\t\t\t     \"base\", head, format, BIT(head),\n\t\t\t     NV50_DISP_INTERLOCK_BASE, interlock_data, &wndw);\n\tif (*pwndw = wndw, ret)\n\t\treturn ret;\n\n\tret = nv50_dmac_create(&drm->client.device, &disp->disp.object,\n\t\t\t       &oclass, head, &args, sizeof(args),\n\t\t\t       disp50->sync->offset, &wndw->wndw);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"base%04x allocation failed: %d\\n\", oclass, ret);\n\t\treturn ret;\n\t}\n\n\twndw->ntfy = NV50_DISP_BASE_NTFY(wndw->id);\n\twndw->sema = NV50_DISP_BASE_SEM0(wndw->id);\n\twndw->data = 0x00000000;\n\treturn 0;\n}\n\nint\nbase507c_new(struct nouveau_drm *drm, int head, s32 oclass,\n\t     struct nv50_wndw **pwndw)\n{\n\treturn base507c_new_(&base507c, base507c_format, drm, head, oclass,\n\t\t\t     0x00000002 << (head * 8), pwndw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}