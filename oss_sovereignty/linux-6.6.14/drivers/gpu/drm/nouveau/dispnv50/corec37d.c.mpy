{
  "module_name": "corec37d.c",
  "hash_id": "865d228a4edcd0472c2450ab1c3a9d80788f666238494f065e28762c847d6c91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/corec37d.c",
  "human_readable_source": " \n#include \"core.h\"\n#include \"head.h\"\n\n#include <nvif/class.h>\n#include <nvif/pushc37b.h>\n#include <nvif/timer.h>\n\n#include <nvhw/class/clc37d.h>\n\n#include <nouveau_bo.h>\n\nint\ncorec37d_wndw_owner(struct nv50_core *core)\n{\n\tstruct nvif_push *push = core->chan.push;\n\tconst u32 windows = 8;  \n\tint ret, i;\n\n\tif ((ret = PUSH_WAIT(push, windows * 2)))\n\t\treturn ret;\n\n\tfor (i = 0; i < windows; i++) {\n\t\tPUSH_MTHD(push, NVC37D, WINDOW_SET_CONTROL(i),\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_CONTROL, OWNER, HEAD(i >> 1)));\n\t}\n\n\treturn 0;\n}\n\nint\ncorec37d_update(struct nv50_core *core, u32 *interlock, bool ntfy)\n{\n\tstruct nvif_push *push = core->chan.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, (ntfy ? 2 * 2 : 0) + 5)))\n\t\treturn ret;\n\n\tif (ntfy) {\n\t\tPUSH_MTHD(push, NVC37D, SET_NOTIFIER_CONTROL,\n\t\t\t  NVDEF(NVC37D, SET_NOTIFIER_CONTROL, MODE, WRITE) |\n\t\t\t  NVVAL(NVC37D, SET_NOTIFIER_CONTROL, OFFSET, NV50_DISP_CORE_NTFY >> 4) |\n\t\t\t  NVDEF(NVC37D, SET_NOTIFIER_CONTROL, NOTIFY, ENABLE));\n\t}\n\n\tPUSH_MTHD(push, NVC37D, SET_INTERLOCK_FLAGS, interlock[NV50_DISP_INTERLOCK_CURS],\n\t\t\t\tSET_WINDOW_INTERLOCK_FLAGS, interlock[NV50_DISP_INTERLOCK_WNDW]);\n\tPUSH_MTHD(push, NVC37D, UPDATE, 0x00000001 |\n\t\t  NVDEF(NVC37D, UPDATE, SPECIAL_HANDLING, NONE) |\n\t\t  NVDEF(NVC37D, UPDATE, INHIBIT_INTERRUPTS, FALSE));\n\n\tif (ntfy) {\n\t\tPUSH_MTHD(push, NVC37D, SET_NOTIFIER_CONTROL,\n\t\t\t  NVDEF(NVC37D, SET_NOTIFIER_CONTROL, NOTIFY, DISABLE));\n\t}\n\n\treturn PUSH_KICK(push);\n}\n\nint\ncorec37d_ntfy_wait_done(struct nouveau_bo *bo, u32 offset,\n\t\t\tstruct nvif_device *device)\n{\n\ts64 time = nvif_msec(device, 2000ULL,\n\t\tif (NVBO_TD32(bo, offset, NV_DISP_NOTIFIER, _0, STATUS, ==, FINISHED))\n\t\t\tbreak;\n\t\tusleep_range(1, 2);\n\t);\n\treturn time < 0 ? time : 0;\n}\n\nvoid\ncorec37d_ntfy_init(struct nouveau_bo *bo, u32 offset)\n{\n\tNVBO_WR32(bo, offset, NV_DISP_NOTIFIER, _0,\n\t\t\tNVDEF(NV_DISP_NOTIFIER, _0, STATUS, NOT_BEGUN));\n\tNVBO_WR32(bo, offset, NV_DISP_NOTIFIER, _1, 0);\n\tNVBO_WR32(bo, offset, NV_DISP_NOTIFIER, _2, 0);\n\tNVBO_WR32(bo, offset, NV_DISP_NOTIFIER, _3, 0);\n}\n\nint corec37d_caps_init(struct nouveau_drm *drm, struct nv50_disp *disp)\n{\n\tint ret;\n\n\tret = nvif_object_ctor(&disp->disp->object, \"dispCaps\", 0,\n\t\t\t       GV100_DISP_CAPS, NULL, 0, &disp->caps);\n\tif (ret) {\n\t\tNV_ERROR(drm,\n\t\t\t \"Failed to init notifier caps region: %d\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\tret = nvif_object_map(&disp->caps, NULL, 0);\n\tif (ret) {\n\t\tNV_ERROR(drm,\n\t\t\t \"Failed to map notifier caps region: %d\\n\",\n\t\t\t ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\ncorec37d_init(struct nv50_core *core)\n{\n\tstruct nvif_push *push = core->chan.push;\n\tconst u32 windows = 8;  \n\tint ret, i;\n\n\tif ((ret = PUSH_WAIT(push, 2 + windows * 5)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37D, SET_CONTEXT_DMA_NOTIFIER, core->chan.sync.handle);\n\n\tfor (i = 0; i < windows; i++) {\n\t\tPUSH_MTHD(push, NVC37D, WINDOW_SET_WINDOW_FORMAT_USAGE_BOUNDS(i),\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_FORMAT_USAGE_BOUNDS, RGB_PACKED1BPP, TRUE) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_FORMAT_USAGE_BOUNDS, RGB_PACKED2BPP, TRUE) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_FORMAT_USAGE_BOUNDS, RGB_PACKED4BPP, TRUE) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_FORMAT_USAGE_BOUNDS, RGB_PACKED8BPP, TRUE) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_FORMAT_USAGE_BOUNDS, YUV_PACKED422, TRUE),\n\n\t\t\t\t\tWINDOW_SET_WINDOW_ROTATED_FORMAT_USAGE_BOUNDS(i), 0x00000000);\n\n\t\tPUSH_MTHD(push, NVC37D, WINDOW_SET_WINDOW_USAGE_BOUNDS(i),\n\t\t\t  NVVAL(NVC37D, WINDOW_SET_WINDOW_USAGE_BOUNDS, MAX_PIXELS_FETCHED_PER_LINE, 0x7fff) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_USAGE_BOUNDS, INPUT_LUT, USAGE_1025) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_USAGE_BOUNDS, INPUT_SCALER_TAPS, TAPS_2) |\n\t\t\t  NVDEF(NVC37D, WINDOW_SET_WINDOW_USAGE_BOUNDS, UPSCALING_ALLOWED, FALSE));\n\t}\n\n\tcore->assign_windows = true;\n\treturn PUSH_KICK(push);\n}\n\nstatic const struct nv50_core_func\ncorec37d = {\n\t.init = corec37d_init,\n\t.ntfy_init = corec37d_ntfy_init,\n\t.caps_init = corec37d_caps_init,\n\t.ntfy_wait_done = corec37d_ntfy_wait_done,\n\t.update = corec37d_update,\n\t.wndw.owner = corec37d_wndw_owner,\n\t.head = &headc37d,\n\t.sor = &sorc37d,\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\t.crc = &crcc37d,\n#endif\n};\n\nint\ncorec37d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)\n{\n\treturn core507d_new_(&corec37d, drm, oclass, pcore);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}