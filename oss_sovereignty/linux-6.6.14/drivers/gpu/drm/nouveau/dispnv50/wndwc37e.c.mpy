{
  "module_name": "wndwc37e.c",
  "hash_id": "b3551b450fb011fe21f0b5c464ae947159b7053a6c491b161417decd35f9b09b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/wndwc37e.c",
  "human_readable_source": " \n#include \"wndw.h\"\n#include \"atom.h\"\n\n#include <drm/drm_atomic_helper.h>\n#include <nouveau_bo.h>\n\n#include <nvif/if0014.h>\n#include <nvif/pushc37b.h>\n\n#include <nvhw/class/clc37e.h>\n\nstatic int\nwndwc37e_csc_clr(struct nv50_wndw *wndw)\n{\n\treturn 0;\n}\n\nstatic int\nwndwc37e_csc_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 13)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_CSC_RED2RED, asyw->csc.matrix, 12);\n\treturn 0;\n}\n\nstatic int\nwndwc37e_ilut_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTEXT_DMA_INPUT_LUT, 0x00000000);\n\treturn 0;\n}\n\nstatic int\nwndwc37e_ilut_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 4)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTROL_INPUT_LUT,\n\t\t  NVVAL(NVC37E, SET_CONTROL_INPUT_LUT, OUTPUT_MODE, asyw->xlut.i.output_mode) |\n\t\t  NVVAL(NVC37E, SET_CONTROL_INPUT_LUT, RANGE, asyw->xlut.i.range) |\n\t\t  NVVAL(NVC37E, SET_CONTROL_INPUT_LUT, SIZE, asyw->xlut.i.size),\n\n\t\t\t\tSET_OFFSET_INPUT_LUT, asyw->xlut.i.offset >> 8,\n\t\t\t\tSET_CONTEXT_DMA_INPUT_LUT, asyw->xlut.handle);\n\treturn 0;\n}\n\nstatic void\nwndwc37e_ilut(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw, int size)\n{\n\tasyw->xlut.i.size = size == 1024 ? NVC37E_SET_CONTROL_INPUT_LUT_SIZE_SIZE_1025 :\n\t\t\t\t\t   NVC37E_SET_CONTROL_INPUT_LUT_SIZE_SIZE_257;\n\tasyw->xlut.i.range = NVC37E_SET_CONTROL_INPUT_LUT_RANGE_UNITY;\n\tasyw->xlut.i.output_mode = NVC37E_SET_CONTROL_INPUT_LUT_OUTPUT_MODE_INTERPOLATE;\n\tasyw->xlut.i.load = head907d_olut_load;\n}\n\nint\nwndwc37e_blend_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 8)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_COMPOSITION_CONTROL,\n\t\t  NVDEF(NVC37E, SET_COMPOSITION_CONTROL, COLOR_KEY_SELECT, DISABLE) |\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_CONTROL, DEPTH, asyw->blend.depth),\n\n\t\t\t\tSET_COMPOSITION_CONSTANT_ALPHA,\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_CONSTANT_ALPHA, K1, asyw->blend.k1) |\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_CONSTANT_ALPHA, K2, 0),\n\n\t\t\t\tSET_COMPOSITION_FACTOR_SELECT,\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_FACTOR_SELECT, SRC_COLOR_FACTOR_MATCH_SELECT,\n\t\t\t\t\t\t\t       asyw->blend.src_color) |\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_FACTOR_SELECT, SRC_COLOR_FACTOR_NO_MATCH_SELECT,\n\t\t\t\t\t\t\t       asyw->blend.src_color) |\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_FACTOR_SELECT, DST_COLOR_FACTOR_MATCH_SELECT,\n\t\t\t\t\t\t\t       asyw->blend.dst_color) |\n\t\t  NVVAL(NVC37E, SET_COMPOSITION_FACTOR_SELECT, DST_COLOR_FACTOR_NO_MATCH_SELECT,\n\t\t\t\t\t\t\t       asyw->blend.dst_color),\n\n\t\t\t\tSET_KEY_ALPHA,\n\t\t  NVVAL(NVC37E, SET_KEY_ALPHA, MIN, 0x0000) |\n\t\t  NVVAL(NVC37E, SET_KEY_ALPHA, MAX, 0xffff),\n\n\t\t\t\tSET_KEY_RED_CR,\n\t\t  NVVAL(NVC37E, SET_KEY_RED_CR, MIN, 0x0000) |\n\t\t  NVVAL(NVC37E, SET_KEY_RED_CR, MAX, 0xffff),\n\n\t\t\t\tSET_KEY_GREEN_Y,\n\t\t  NVVAL(NVC37E, SET_KEY_GREEN_Y, MIN, 0x0000) |\n\t\t  NVVAL(NVC37E, SET_KEY_GREEN_Y, MAX, 0xffff),\n\n\t\t\t\tSET_KEY_BLUE_CB,\n\t\t  NVVAL(NVC37E, SET_KEY_BLUE_CB, MIN, 0x0000) |\n\t\t  NVVAL(NVC37E, SET_KEY_BLUE_CB, MAX, 0xffff));\n\treturn 0;\n}\n\nint\nwndwc37e_image_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 4)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_PRESENT_CONTROL,\n\t\t  NVVAL(NVC37E, SET_PRESENT_CONTROL, MIN_PRESENT_INTERVAL, 0) |\n\t\t  NVDEF(NVC37E, SET_PRESENT_CONTROL, BEGIN_MODE, NON_TEARING));\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTEXT_DMA_ISO(0), 0x00000000);\n\treturn 0;\n}\n\nstatic int\nwndwc37e_image_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 17)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_PRESENT_CONTROL,\n\t\t  NVVAL(NVC37E, SET_PRESENT_CONTROL, MIN_PRESENT_INTERVAL, asyw->image.interval) |\n\t\t  NVVAL(NVC37E, SET_PRESENT_CONTROL, BEGIN_MODE, asyw->image.mode) |\n\t\t  NVDEF(NVC37E, SET_PRESENT_CONTROL, TIMESTAMP_MODE, DISABLE));\n\n\tPUSH_MTHD(push, NVC37E, SET_SIZE,\n\t\t  NVVAL(NVC37E, SET_SIZE, WIDTH, asyw->image.w) |\n\t\t  NVVAL(NVC37E, SET_SIZE, HEIGHT, asyw->image.h),\n\n\t\t\t\tSET_STORAGE,\n\t\t  NVVAL(NVC37E, SET_STORAGE, BLOCK_HEIGHT, asyw->image.blockh) |\n\t\t  NVVAL(NVC37E, SET_STORAGE, MEMORY_LAYOUT, asyw->image.layout),\n\n\t\t\t\tSET_PARAMS,\n\t\t  NVVAL(NVC37E, SET_PARAMS, FORMAT, asyw->image.format) |\n\t\t  NVVAL(NVC37E, SET_PARAMS, COLOR_SPACE, asyw->image.colorspace) |\n\t\t  NVDEF(NVC37E, SET_PARAMS, INPUT_RANGE, BYPASS) |\n\t\t  NVDEF(NVC37E, SET_PARAMS, UNDERREPLICATE, DISABLE) |\n\t\t  NVDEF(NVC37E, SET_PARAMS, DE_GAMMA, NONE) |\n\t\t  NVVAL(NVC37E, SET_PARAMS, CSC, asyw->csc.valid) |\n\t\t  NVDEF(NVC37E, SET_PARAMS, CLAMP_BEFORE_BLEND, DISABLE) |\n\t\t  NVDEF(NVC37E, SET_PARAMS, SWAP_UV, DISABLE),\n\n\t\t\t\tSET_PLANAR_STORAGE(0),\n\t\t  NVVAL(NVC37E, SET_PLANAR_STORAGE, PITCH, asyw->image.blocks[0]) |\n\t\t  NVVAL(NVC37E, SET_PLANAR_STORAGE, PITCH, asyw->image.pitch[0] >> 6));\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTEXT_DMA_ISO(0), asyw->image.handle, 1);\n\tPUSH_MTHD(push, NVC37E, SET_OFFSET(0), asyw->image.offset[0] >> 8);\n\n\tPUSH_MTHD(push, NVC37E, SET_POINT_IN(0),\n\t\t  NVVAL(NVC37E, SET_POINT_IN, X, asyw->state.src_x >> 16) |\n\t\t  NVVAL(NVC37E, SET_POINT_IN, Y, asyw->state.src_y >> 16));\n\n\tPUSH_MTHD(push, NVC37E, SET_SIZE_IN,\n\t\t  NVVAL(NVC37E, SET_SIZE_IN, WIDTH, asyw->state.src_w >> 16) |\n\t\t  NVVAL(NVC37E, SET_SIZE_IN, HEIGHT, asyw->state.src_h >> 16));\n\n\tPUSH_MTHD(push, NVC37E, SET_SIZE_OUT,\n\t\t  NVVAL(NVC37E, SET_SIZE_OUT, WIDTH, asyw->state.crtc_w) |\n\t\t  NVVAL(NVC37E, SET_SIZE_OUT, HEIGHT, asyw->state.crtc_h));\n\treturn 0;\n}\n\nint\nwndwc37e_ntfy_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTEXT_DMA_NOTIFIER, 0x00000000);\n\treturn 0;\n}\n\nint\nwndwc37e_ntfy_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 3)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTEXT_DMA_NOTIFIER, asyw->ntfy.handle,\n\n\t\t\t\tSET_NOTIFIER_CONTROL,\n\t\t  NVVAL(NVC37E, SET_NOTIFIER_CONTROL, MODE, asyw->ntfy.awaken) |\n\t\t  NVVAL(NVC37E, SET_NOTIFIER_CONTROL, OFFSET, asyw->ntfy.offset >> 4));\n\treturn 0;\n}\n\nint\nwndwc37e_sema_clr(struct nv50_wndw *wndw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_CONTEXT_DMA_SEMAPHORE, 0x00000000);\n\treturn 0;\n}\n\nint\nwndwc37e_sema_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 5)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_SEMAPHORE_CONTROL, asyw->sema.offset,\n\t\t\t\tSET_SEMAPHORE_ACQUIRE, asyw->sema.acquire,\n\t\t\t\tSET_SEMAPHORE_RELEASE, asyw->sema.release,\n\t\t\t\tSET_CONTEXT_DMA_SEMAPHORE, asyw->sema.handle);\n\treturn 0;\n}\n\nint\nwndwc37e_update(struct nv50_wndw *wndw, u32 *interlock)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 5)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37E, SET_INTERLOCK_FLAGS, interlock[NV50_DISP_INTERLOCK_CURS] << 1 |\n\t\t\t\t\t\t     interlock[NV50_DISP_INTERLOCK_CORE],\n\t\t\t\tSET_WINDOW_INTERLOCK_FLAGS, interlock[NV50_DISP_INTERLOCK_WNDW]);\n\n\tPUSH_MTHD(push, NVC37E, UPDATE, 0x00000001 |\n\t\t  NVVAL(NVC37E, UPDATE, INTERLOCK_WITH_WIN_IMM,\n\t\t\t  !!(interlock[NV50_DISP_INTERLOCK_WIMM] & wndw->interlock.data)));\n\n\treturn PUSH_KICK(push);\n}\n\nvoid\nwndwc37e_release(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n}\n\nint\nwndwc37e_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\treturn drm_atomic_helper_check_plane_state(&asyw->state, &asyh->state,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t   true, true);\n}\n\nstatic const u32\nwndwc37e_format[] = {\n\tDRM_FORMAT_C8,\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_ARGB8888,\n\tDRM_FORMAT_RGB565,\n\tDRM_FORMAT_XRGB1555,\n\tDRM_FORMAT_ARGB1555,\n\tDRM_FORMAT_XBGR2101010,\n\tDRM_FORMAT_ABGR2101010,\n\tDRM_FORMAT_XBGR8888,\n\tDRM_FORMAT_ABGR8888,\n\tDRM_FORMAT_XRGB2101010,\n\tDRM_FORMAT_ARGB2101010,\n\tDRM_FORMAT_XBGR16161616F,\n\tDRM_FORMAT_ABGR16161616F,\n\t0\n};\n\nstatic const struct nv50_wndw_func\nwndwc37e = {\n\t.acquire = wndwc37e_acquire,\n\t.release = wndwc37e_release,\n\t.sema_set = wndwc37e_sema_set,\n\t.sema_clr = wndwc37e_sema_clr,\n\t.ntfy_set = wndwc37e_ntfy_set,\n\t.ntfy_clr = wndwc37e_ntfy_clr,\n\t.ntfy_reset = corec37d_ntfy_init,\n\t.ntfy_wait_begun = base507c_ntfy_wait_begun,\n\t.ilut = wndwc37e_ilut,\n\t.ilut_size = 1024,\n\t.xlut_set = wndwc37e_ilut_set,\n\t.xlut_clr = wndwc37e_ilut_clr,\n\t.csc = base907c_csc,\n\t.csc_set = wndwc37e_csc_set,\n\t.csc_clr = wndwc37e_csc_clr,\n\t.image_set = wndwc37e_image_set,\n\t.image_clr = wndwc37e_image_clr,\n\t.blend_set = wndwc37e_blend_set,\n\t.update = wndwc37e_update,\n};\n\nint\nwndwc37e_new_(const struct nv50_wndw_func *func, struct nouveau_drm *drm,\n\t      enum drm_plane_type type, int index, s32 oclass, u32 heads,\n\t      struct nv50_wndw **pwndw)\n{\n\tstruct nvif_disp_chan_v0 args = {\n\t\t.id = index,\n\t};\n\tstruct nv50_disp *disp = nv50_disp(drm->dev);\n\tstruct nv50_wndw *wndw;\n\tint ret;\n\n\tret = nv50_wndw_new_(func, drm->dev, type, \"wndw\", index,\n\t\t\t     wndwc37e_format, heads, NV50_DISP_INTERLOCK_WNDW,\n\t\t\t     BIT(index), &wndw);\n\tif (*pwndw = wndw, ret)\n\t\treturn ret;\n\n\tret = nv50_dmac_create(&drm->client.device, &disp->disp->object,\n\t\t\t       &oclass, 0, &args, sizeof(args),\n\t\t\t       disp->sync->offset, &wndw->wndw);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"qndw%04x allocation failed: %d\\n\", oclass, ret);\n\t\treturn ret;\n\t}\n\n\twndw->ntfy = NV50_DISP_WNDW_NTFY(wndw->id);\n\twndw->sema = NV50_DISP_WNDW_SEM0(wndw->id);\n\twndw->data = 0x00000000;\n\treturn 0;\n}\n\nint\nwndwc37e_new(struct nouveau_drm *drm, enum drm_plane_type type, int index,\n\t     s32 oclass, struct nv50_wndw **pwndw)\n{\n\treturn wndwc37e_new_(&wndwc37e, drm, type, index, oclass,\n\t\t\t     BIT(index >> 1), pwndw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}