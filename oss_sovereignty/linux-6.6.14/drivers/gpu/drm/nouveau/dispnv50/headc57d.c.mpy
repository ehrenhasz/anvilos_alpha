{
  "module_name": "headc57d.c",
  "hash_id": "bfa5d221084fb306dd8492d7013370af8d6965bba408d1333652a119d26d6bf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/headc57d.c",
  "human_readable_source": " \n#include \"head.h\"\n#include \"atom.h\"\n#include \"core.h\"\n\n#include <nvif/pushc37b.h>\n\n#include <nvhw/class/clc57d.h>\n\nstatic int\nheadc57d_or(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tu8 depth;\n\tint ret;\n\n\t \n\tswitch (asyh->or.depth) {\n\tcase 6: depth = 5; break;\n\tcase 5: depth = 4; break;\n\tcase 2: depth = 1; break;\n\tcase 0:\tdepth = 4; break;\n\tdefault:\n\t\tdepth = asyh->or.depth;\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE, CRC_MODE, asyh->or.crc_raster) |\n\t\t  NVVAL(NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE, HSYNC_POLARITY, asyh->or.nhsync) |\n\t\t  NVVAL(NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE, VSYNC_POLARITY, asyh->or.nvsync) |\n\t\t  NVVAL(NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE, PIXEL_DEPTH, depth) |\n\t\t  NVDEF(NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE, COLOR_SPACE_OVERRIDE, DISABLE) |\n\t\t  NVDEF(NVC57D, HEAD_SET_CONTROL_OUTPUT_RESOURCE, EXT_PACKET_WIN, NONE));\n\treturn 0;\n}\n\nstatic int\nheadc57d_procamp(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\t\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_PROCAMP(i),\n\t\t  NVDEF(NVC57D, HEAD_SET_PROCAMP, COLOR_SPACE, RGB) |\n\t\t  NVDEF(NVC57D, HEAD_SET_PROCAMP, CHROMA_LPF, DISABLE) |\n\t\t  NVDEF(NVC57D, HEAD_SET_PROCAMP, DYNAMIC_RANGE, VESA));\n\treturn 0;\n}\n\nstatic int\nheadc57d_olut_clr(struct nv50_head *head)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_CONTEXT_DMA_OLUT(i), 0x00000000);\n\treturn 0;\n}\n\nstatic int\nheadc57d_olut_set(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 5)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_OLUT_CONTROL(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_OLUT_CONTROL, INTERPOLATE, asyh->olut.output_mode) |\n\t\t  NVDEF(NVC57D, HEAD_SET_OLUT_CONTROL, MIRROR, DISABLE) |\n\t\t  NVVAL(NVC57D, HEAD_SET_OLUT_CONTROL, MODE, asyh->olut.mode) |\n\t\t  NVVAL(NVC57D, HEAD_SET_OLUT_CONTROL, SIZE, asyh->olut.size),\n\n\t\t\t\tHEAD_SET_OLUT_FP_NORM_SCALE(i), 0xffffffff,\n\t\t\t\tHEAD_SET_CONTEXT_DMA_OLUT(i), asyh->olut.handle,\n\t\t\t\tHEAD_SET_OFFSET_OLUT(i), asyh->olut.offset >> 8);\n\treturn 0;\n}\n\nstatic void\nheadc57d_olut_load_8(struct drm_color_lut *in, int size, void __iomem *mem)\n{\n\tmemset_io(mem, 0x00, 0x20);  \n\tmem += 0x20;\n\n\twhile (size--) {\n\t\tu16 r = drm_color_lut_extract(in->  red + 0, 16);\n\t\tu16 g = drm_color_lut_extract(in->green + 0, 16);\n\t\tu16 b = drm_color_lut_extract(in-> blue + 0, 16);\n\t\tu16 ri = 0, gi = 0, bi = 0, i;\n\n\t\tif (in++, size) {\n\t\t\tri = (drm_color_lut_extract(in->  red, 16) - r) / 4;\n\t\t\tgi = (drm_color_lut_extract(in->green, 16) - g) / 4;\n\t\t\tbi = (drm_color_lut_extract(in-> blue, 16) - b) / 4;\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++, mem += 8) {\n\t\t\twritew(r + ri * i, mem + 0);\n\t\t\twritew(g + gi * i, mem + 2);\n\t\t\twritew(b + bi * i, mem + 4);\n\t\t}\n\t}\n\n\t \n\twritew(readw(mem - 8), mem + 0);\n\twritew(readw(mem - 6), mem + 2);\n\twritew(readw(mem - 4), mem + 4);\n}\n\nstatic void\nheadc57d_olut_load(struct drm_color_lut *in, int size, void __iomem *mem)\n{\n\tmemset_io(mem, 0x00, 0x20);  \n\tmem += 0x20;\n\n\tfor (; size--; in++, mem += 0x08) {\n\t\twritew(drm_color_lut_extract(in->  red, 16), mem + 0);\n\t\twritew(drm_color_lut_extract(in->green, 16), mem + 2);\n\t\twritew(drm_color_lut_extract(in-> blue, 16), mem + 4);\n\t}\n\n\t \n\twritew(readw(mem - 8), mem + 0);\n\twritew(readw(mem - 6), mem + 2);\n\twritew(readw(mem - 4), mem + 4);\n}\n\nstatic bool\nheadc57d_olut(struct nv50_head *head, struct nv50_head_atom *asyh, int size)\n{\n\tif (size != 0 && size != 256 && size != 1024)\n\t\treturn false;\n\n\tasyh->olut.mode = NVC57D_HEAD_SET_OLUT_CONTROL_MODE_DIRECT10;\n\tasyh->olut.size = 4   + 1024 + 1  ;\n\tasyh->olut.output_mode = NVC57D_HEAD_SET_OLUT_CONTROL_INTERPOLATE_ENABLE;\n\tif (size == 256)\n\t\tasyh->olut.load = headc57d_olut_load_8;\n\telse\n\t\tasyh->olut.load = headc57d_olut_load;\n\treturn true;\n}\n\nstatic int\nheadc57d_mode(struct nv50_head *head, struct nv50_head_atom *asyh)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tstruct nv50_head_mode *m = &asyh->mode;\n\tconst int i = head->base.index;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 15)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_RASTER_SIZE(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_SIZE, WIDTH, m->h.active) |\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_SIZE, HEIGHT, m->v.active),\n\n\t\t\t\tHEAD_SET_RASTER_SYNC_END(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_SYNC_END, X, m->h.synce) |\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_SYNC_END, Y, m->v.synce),\n\n\t\t\t\tHEAD_SET_RASTER_BLANK_END(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_BLANK_END, X, m->h.blanke) |\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_BLANK_END, Y, m->v.blanke),\n\n\t\t\t\tHEAD_SET_RASTER_BLANK_START(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_BLANK_START, X, m->h.blanks) |\n\t\t  NVVAL(NVC57D, HEAD_SET_RASTER_BLANK_START, Y, m->v.blanks));\n\n\t\n\tPUSH_NVSQ(push, NVC57D, 0x2074 + (i * 0x400), m->v.blank2e << 16 | m->v.blank2s);\n\tPUSH_NVSQ(push, NVC57D, 0x2008 + (i * 0x400), m->interlace);\n\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_PIXEL_CLOCK_FREQUENCY(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_PIXEL_CLOCK_FREQUENCY, HERTZ, m->clock * 1000));\n\n\tPUSH_MTHD(push, NVC57D, HEAD_SET_PIXEL_CLOCK_FREQUENCY_MAX(i),\n\t\t  NVVAL(NVC57D, HEAD_SET_PIXEL_CLOCK_FREQUENCY_MAX, HERTZ, m->clock * 1000));\n\n\t \n\tPUSH_MTHD(push, NVC57D, HEAD_SET_HEAD_USAGE_BOUNDS(i),\n\t\t  NVDEF(NVC57D, HEAD_SET_HEAD_USAGE_BOUNDS, CURSOR, USAGE_W256_H256) |\n\t\t  NVDEF(NVC57D, HEAD_SET_HEAD_USAGE_BOUNDS, OLUT_ALLOWED, TRUE) |\n\t\t  NVDEF(NVC57D, HEAD_SET_HEAD_USAGE_BOUNDS, OUTPUT_SCALER_TAPS, TAPS_2) |\n\t\t  NVDEF(NVC57D, HEAD_SET_HEAD_USAGE_BOUNDS, UPSCALING_ALLOWED, TRUE));\n\treturn 0;\n}\n\nconst struct nv50_head_func\nheadc57d = {\n\t.view = headc37d_view,\n\t.mode = headc57d_mode,\n\t.olut = headc57d_olut,\n\t.ilut_check = head907d_ilut_check,\n\t.olut_identity = true,\n\t.olut_size = 1024,\n\t.olut_set = headc57d_olut_set,\n\t.olut_clr = headc57d_olut_clr,\n\t.curs_layout = head917d_curs_layout,\n\t.curs_format = headc37d_curs_format,\n\t.curs_set = headc37d_curs_set,\n\t.curs_clr = headc37d_curs_clr,\n\t.dither = headc37d_dither,\n\t.procamp = headc57d_procamp,\n\t.or = headc57d_or,\n\t \n\t.static_wndw_map = headc37d_static_wndw_map,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}