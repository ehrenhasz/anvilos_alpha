{
  "module_name": "ovly507e.c",
  "hash_id": "6c0e7853a864343ec7ee61d0ecd069ffb1380b9289e00a4d8f57482f49f649be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/ovly507e.c",
  "human_readable_source": " \n#include \"ovly.h\"\n#include \"atom.h\"\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n\n#include <nvif/if0014.h>\n#include <nvif/push507c.h>\n\n#include <nvhw/class/cl507e.h>\n\nint\novly507e_scale_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 4)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507E, SET_POINT_IN,\n\t\t  NVVAL(NV507E, SET_POINT_IN, X, asyw->scale.sx) |\n\t\t  NVVAL(NV507E, SET_POINT_IN, Y, asyw->scale.sy),\n\n\t\t\t\tSET_SIZE_IN,\n\t\t  NVVAL(NV507E, SET_SIZE_IN, WIDTH, asyw->scale.sw) |\n\t\t  NVVAL(NV507E, SET_SIZE_IN, HEIGHT, asyw->scale.sh),\n\n\t\t\t\tSET_SIZE_OUT,\n\t\t  NVVAL(NV507E, SET_SIZE_OUT, WIDTH, asyw->scale.dw));\n\treturn 0;\n}\n\nstatic int\novly507e_image_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_push *push = wndw->wndw.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 12)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507E, SET_PRESENT_CONTROL,\n\t\t  NVDEF(NV507E, SET_PRESENT_CONTROL, BEGIN_MODE, ASAP) |\n\t\t  NVVAL(NV507E, SET_PRESENT_CONTROL, MIN_PRESENT_INTERVAL, asyw->image.interval));\n\n\tPUSH_MTHD(push, NV507E, SET_CONTEXT_DMA_ISO, asyw->image.handle[0]);\n\n\tPUSH_MTHD(push, NV507E, SET_COMPOSITION_CONTROL,\n\t\t  NVDEF(NV507E, SET_COMPOSITION_CONTROL, MODE, OPAQUE_SUSPEND_BASE));\n\n\tPUSH_MTHD(push, NV507E, SURFACE_SET_OFFSET, asyw->image.offset[0] >> 8);\n\n\tPUSH_MTHD(push, NV507E, SURFACE_SET_SIZE,\n\t\t  NVVAL(NV507E, SURFACE_SET_SIZE, WIDTH, asyw->image.w) |\n\t\t  NVVAL(NV507E, SURFACE_SET_SIZE, HEIGHT, asyw->image.h),\n\n\t\t\t\tSURFACE_SET_STORAGE,\n\t\t  NVVAL(NV507E, SURFACE_SET_STORAGE, BLOCK_HEIGHT, asyw->image.blockh) |\n\t\t  NVVAL(NV507E, SURFACE_SET_STORAGE, PITCH, (asyw->image.pitch[0] >> 8)) |\n\t\t  NVVAL(NV507E, SURFACE_SET_STORAGE, PITCH, asyw->image.blocks[0]) |\n\t\t  NVVAL(NV507E, SURFACE_SET_STORAGE, MEMORY_LAYOUT, asyw->image.layout),\n\n\t\t\t\tSURFACE_SET_PARAMS,\n\t\t  NVVAL(NV507E, SURFACE_SET_PARAMS, FORMAT, asyw->image.format) |\n\t\t  NVVAL(NV507E, SURFACE_SET_PARAMS, COLOR_SPACE, asyw->image.colorspace) |\n\t\t  NVVAL(NV507E, SURFACE_SET_PARAMS, KIND, asyw->image.kind) |\n\t\t  NVDEF(NV507E, SURFACE_SET_PARAMS, PART_STRIDE, PARTSTRIDE_256));\n\treturn 0;\n}\n\nvoid\novly507e_release(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\tasyh->ovly.cpp = 0;\n}\n\nint\novly507e_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\tconst struct drm_framebuffer *fb = asyw->state.fb;\n\tint ret;\n\n\tret = drm_atomic_helper_check_plane_state(&asyw->state, &asyh->state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tif (ret)\n\t\treturn ret;\n\n\tasyh->ovly.cpp = fb->format->cpp[0];\n\treturn 0;\n}\n\n#include \"nouveau_bo.h\"\n\nstatic const struct nv50_wndw_func\novly507e = {\n\t.acquire = ovly507e_acquire,\n\t.release = ovly507e_release,\n\t.ntfy_set = base507c_ntfy_set,\n\t.ntfy_clr = base507c_ntfy_clr,\n\t.ntfy_reset = base507c_ntfy_reset,\n\t.ntfy_wait_begun = base507c_ntfy_wait_begun,\n\t.image_set = ovly507e_image_set,\n\t.image_clr = base507c_image_clr,\n\t.scale_set = ovly507e_scale_set,\n\t.update = base507c_update,\n};\n\nstatic const u32\novly507e_format[] = {\n\tDRM_FORMAT_YUYV,\n\tDRM_FORMAT_UYVY,\n\tDRM_FORMAT_XRGB8888,\n\tDRM_FORMAT_XRGB1555,\n\t0\n};\n\nint\novly507e_new_(const struct nv50_wndw_func *func, const u32 *format,\n\t      struct nouveau_drm *drm, int head, s32 oclass, u32 interlock_data,\n\t      struct nv50_wndw **pwndw)\n{\n\tstruct nvif_disp_chan_v0 args = {\n\t\t.id = head,\n\t};\n\tstruct nv50_disp *disp = nv50_disp(drm->dev);\n\tstruct nv50_wndw *wndw;\n\tint ret;\n\n\tret = nv50_wndw_new_(func, drm->dev, DRM_PLANE_TYPE_OVERLAY,\n\t\t\t     \"ovly\", head, format, BIT(head),\n\t\t\t     NV50_DISP_INTERLOCK_OVLY, interlock_data,\n\t\t\t     &wndw);\n\tif (*pwndw = wndw, ret)\n\t\treturn ret;\n\n\tret = nv50_dmac_create(&drm->client.device, &disp->disp->object,\n\t\t\t       &oclass, 0, &args, sizeof(args),\n\t\t\t       disp->sync->offset, &wndw->wndw);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"ovly%04x allocation failed: %d\\n\", oclass, ret);\n\t\treturn ret;\n\t}\n\n\twndw->ntfy = NV50_DISP_OVLY_NTFY(wndw->id);\n\twndw->sema = NV50_DISP_OVLY_SEM0(wndw->id);\n\twndw->data = 0x00000000;\n\treturn 0;\n}\n\nint\novly507e_new(struct nouveau_drm *drm, int head, s32 oclass,\n\t     struct nv50_wndw **pwndw)\n{\n\treturn ovly507e_new_(&ovly507e, ovly507e_format, drm, head, oclass,\n\t\t\t     0x00000004 << (head * 8), pwndw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}