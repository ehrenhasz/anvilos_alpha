{
  "module_name": "core507d.c",
  "hash_id": "e41a9214cd99e79ad5af7f768ab880a28c796dc6fc5cf80e5c4442d085856b79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/core507d.c",
  "human_readable_source": " \n#include \"core.h\"\n#include \"head.h\"\n\n#include <nvif/if0014.h>\n#include <nvif/push507c.h>\n#include <nvif/timer.h>\n\n#include <nvhw/class/cl507d.h>\n\n#include \"nouveau_bo.h\"\n\nint\ncore507d_update(struct nv50_core *core, u32 *interlock, bool ntfy)\n{\n\tstruct nvif_push *push = core->chan.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, (ntfy ? 2 : 0) + 3)))\n\t\treturn ret;\n\n\tif (ntfy) {\n\t\tPUSH_MTHD(push, NV507D, SET_NOTIFIER_CONTROL,\n\t\t\t  NVDEF(NV507D, SET_NOTIFIER_CONTROL, MODE, WRITE) |\n\t\t\t  NVVAL(NV507D, SET_NOTIFIER_CONTROL, OFFSET, NV50_DISP_CORE_NTFY >> 2) |\n\t\t\t  NVDEF(NV507D, SET_NOTIFIER_CONTROL, NOTIFY, ENABLE));\n\t}\n\n\tPUSH_MTHD(push, NV507D, UPDATE, interlock[NV50_DISP_INTERLOCK_BASE] |\n\t\t\t\t\tinterlock[NV50_DISP_INTERLOCK_OVLY] |\n\t\t  NVDEF(NV507D, UPDATE, NOT_DRIVER_FRIENDLY, FALSE) |\n\t\t  NVDEF(NV507D, UPDATE, NOT_DRIVER_UNFRIENDLY, FALSE) |\n\t\t  NVDEF(NV507D, UPDATE, INHIBIT_INTERRUPTS, FALSE),\n\n\t\t\t\tSET_NOTIFIER_CONTROL,\n\t\t  NVDEF(NV507D, SET_NOTIFIER_CONTROL, NOTIFY, DISABLE));\n\n\treturn PUSH_KICK(push);\n}\n\nint\ncore507d_ntfy_wait_done(struct nouveau_bo *bo, u32 offset,\n\t\t\tstruct nvif_device *device)\n{\n\ts64 time = nvif_msec(device, 2000ULL,\n\t\tif (NVBO_TD32(bo, offset, NV_DISP_CORE_NOTIFIER_1, COMPLETION_0, DONE, ==, TRUE))\n\t\t\tbreak;\n\t\tusleep_range(1, 2);\n\t);\n\treturn time < 0 ? time : 0;\n}\n\nvoid\ncore507d_ntfy_init(struct nouveau_bo *bo, u32 offset)\n{\n\tNVBO_WR32(bo, offset, NV_DISP_CORE_NOTIFIER_1, COMPLETION_0,\n\t\t\tNVDEF(NV_DISP_CORE_NOTIFIER_1, COMPLETION_0, DONE, FALSE));\n}\n\nint\ncore507d_read_caps(struct nv50_disp *disp)\n{\n\tstruct nvif_push *push = disp->core->chan.push;\n\tint ret;\n\n\tret = PUSH_WAIT(push, 6);\n\tif (ret)\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507D, SET_NOTIFIER_CONTROL,\n\t\t  NVDEF(NV507D, SET_NOTIFIER_CONTROL, MODE, WRITE) |\n\t\t  NVVAL(NV507D, SET_NOTIFIER_CONTROL, OFFSET, NV50_DISP_CORE_NTFY >> 2) |\n\t\t  NVDEF(NV507D, SET_NOTIFIER_CONTROL, NOTIFY, ENABLE));\n\n\tPUSH_MTHD(push, NV507D, GET_CAPABILITIES, 0x00000000);\n\n\tPUSH_MTHD(push, NV507D, SET_NOTIFIER_CONTROL,\n\t\t  NVDEF(NV507D, SET_NOTIFIER_CONTROL, NOTIFY, DISABLE));\n\n\treturn PUSH_KICK(push);\n}\n\nint\ncore507d_caps_init(struct nouveau_drm *drm, struct nv50_disp *disp)\n{\n\tstruct nv50_core *core = disp->core;\n\tstruct nouveau_bo *bo = disp->sync;\n\ts64 time;\n\tint ret;\n\n\tNVBO_WR32(bo, NV50_DISP_CORE_NTFY, NV_DISP_CORE_NOTIFIER_1, CAPABILITIES_1,\n\t\t\t\t     NVDEF(NV_DISP_CORE_NOTIFIER_1, CAPABILITIES_1, DONE, FALSE));\n\n\tret = core507d_read_caps(disp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttime = nvif_msec(core->chan.base.device, 2000ULL,\n\t\t\t if (NVBO_TD32(bo, NV50_DISP_CORE_NTFY,\n\t\t\t\t       NV_DISP_CORE_NOTIFIER_1, CAPABILITIES_1, DONE, ==, TRUE))\n\t\t\t\t break;\n\t\t\t usleep_range(1, 2);\n\t\t\t );\n\tif (time < 0)\n\t\tNV_ERROR(drm, \"core caps notifier timeout\\n\");\n\n\treturn 0;\n}\n\nint\ncore507d_init(struct nv50_core *core)\n{\n\tstruct nvif_push *push = core->chan.push;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NV507D, SET_CONTEXT_DMA_NOTIFIER, core->chan.sync.handle);\n\treturn PUSH_KICK(push);\n}\n\nstatic const struct nv50_core_func\ncore507d = {\n\t.init = core507d_init,\n\t.ntfy_init = core507d_ntfy_init,\n\t.caps_init = core507d_caps_init,\n\t.ntfy_wait_done = core507d_ntfy_wait_done,\n\t.update = core507d_update,\n\t.head = &head507d,\n\t.dac = &dac507d,\n\t.sor = &sor507d,\n\t.pior = &pior507d,\n};\n\nint\ncore507d_new_(const struct nv50_core_func *func, struct nouveau_drm *drm,\n\t      s32 oclass, struct nv50_core **pcore)\n{\n\tstruct nvif_disp_chan_v0 args = {};\n\tstruct nv50_disp *disp = nv50_disp(drm->dev);\n\tstruct nv50_core *core;\n\tint ret;\n\n\tif (!(core = *pcore = kzalloc(sizeof(*core), GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\tcore->func = func;\n\n\tret = nv50_dmac_create(&drm->client.device, &disp->disp->object,\n\t\t\t       &oclass, 0, &args, sizeof(args),\n\t\t\t       disp->sync->offset, &core->chan);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"core%04x allocation failed: %d\\n\", oclass, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint\ncore507d_new(struct nouveau_drm *drm, s32 oclass, struct nv50_core **pcore)\n{\n\treturn core507d_new_(&core507d, drm, oclass, pcore);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}