{
  "module_name": "crcc37d.c",
  "hash_id": "0fddccc2255754ab789e28dacd34a790338131b9c91f42bbef32e57d9027377a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/crcc37d.c",
  "human_readable_source": "\n#include <drm/drm_crtc.h>\n\n#include \"crc.h\"\n#include \"crcc37d.h\"\n#include \"core.h\"\n#include \"disp.h\"\n#include \"head.h\"\n\n#include <nvif/pushc37b.h>\n\n#include <nvhw/class/clc37d.h>\n\nstatic int\ncrcc37d_set_src(struct nv50_head *head, int or, enum nv50_crc_source_type source,\n\t\tstruct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tu32 crc_args = NVVAL(NVC37D, HEAD_SET_CRC_CONTROL, CONTROLLING_CHANNEL, i * 4) |\n\t\t       NVDEF(NVC37D, HEAD_SET_CRC_CONTROL, EXPECT_BUFFER_COLLAPSE, FALSE) |\n\t\t       NVDEF(NVC37D, HEAD_SET_CRC_CONTROL, SECONDARY_CRC, NONE) |\n\t\t       NVDEF(NVC37D, HEAD_SET_CRC_CONTROL, CRC_DURING_SNOOZE, DISABLE);\n\tint ret;\n\n\tswitch (source) {\n\tcase NV50_CRC_SOURCE_TYPE_SOR:\n\t\tcrc_args |= NVDEF(NVC37D, HEAD_SET_CRC_CONTROL, PRIMARY_CRC, SOR(or));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_TYPE_PIOR:\n\t\tcrc_args |= NVDEF(NVC37D, HEAD_SET_CRC_CONTROL, PRIMARY_CRC, PIOR(or));\n\t\tbreak;\n\tcase NV50_CRC_SOURCE_TYPE_SF:\n\t\tcrc_args |= NVDEF(NVC37D, HEAD_SET_CRC_CONTROL, PRIMARY_CRC, SF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((ret = PUSH_WAIT(push, 4)))\n\t\treturn ret;\n\n\tif (source) {\n\t\tPUSH_MTHD(push, NVC37D, HEAD_SET_CONTEXT_DMA_CRC(i), ctx->ntfy.handle);\n\t\tPUSH_MTHD(push, NVC37D, HEAD_SET_CRC_CONTROL(i), crc_args);\n\t} else {\n\t\tPUSH_MTHD(push, NVC37D, HEAD_SET_CRC_CONTROL(i), 0);\n\t\tPUSH_MTHD(push, NVC37D, HEAD_SET_CONTEXT_DMA_CRC(i), 0);\n\t}\n\n\treturn 0;\n}\n\nint crcc37d_set_ctx(struct nv50_head *head, struct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nvif_push *push = nv50_disp(head->base.base.dev)->core->chan.push;\n\tconst int i = head->base.index;\n\tint ret;\n\n\tif ((ret = PUSH_WAIT(push, 2)))\n\t\treturn ret;\n\n\tPUSH_MTHD(push, NVC37D, HEAD_SET_CONTEXT_DMA_CRC(i), ctx ? ctx->ntfy.handle : 0);\n\treturn 0;\n}\n\nu32 crcc37d_get_entry(struct nv50_head *head, struct nv50_crc_notifier_ctx *ctx,\n\t\t      enum nv50_crc_source source, int idx)\n{\n\tstruct crcc37d_notifier __iomem *notifier = ctx->mem.object.map.ptr;\n\tstruct crcc37d_entry __iomem *entry = &notifier->entries[idx];\n\tu32 __iomem *crc_addr;\n\n\tif (source == NV50_CRC_SOURCE_RG)\n\t\tcrc_addr = &entry->rg_crc;\n\telse\n\t\tcrc_addr = &entry->output_crc[0];\n\n\treturn ioread32_native(crc_addr);\n}\n\nbool crcc37d_ctx_finished(struct nv50_head *head, struct nv50_crc_notifier_ctx *ctx)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(head->base.base.dev);\n\tstruct crcc37d_notifier __iomem *notifier = ctx->mem.object.map.ptr;\n\tconst u32 status = ioread32_native(&notifier->status);\n\tconst u32 overflow = status & 0x0000007e;\n\n\tif (!(status & 0x00000001))\n\t\treturn false;\n\n\tif (overflow) {\n\t\tconst char *engine = NULL;\n\n\t\tswitch (overflow) {\n\t\tcase 0x00000004: engine = \"Front End\"; break;\n\t\tcase 0x00000008: engine = \"Compositor\"; break;\n\t\tcase 0x00000010: engine = \"RG\"; break;\n\t\tcase 0x00000020: engine = \"CRC output 1\"; break;\n\t\tcase 0x00000040: engine = \"CRC output 2\"; break;\n\t\t}\n\n\t\tif (engine)\n\t\t\tNV_ERROR(drm,\n\t\t\t\t \"CRC notifier context for head %d overflowed on %s: %x\\n\",\n\t\t\t\t head->base.index, engine, status);\n\t\telse\n\t\t\tNV_ERROR(drm,\n\t\t\t\t \"CRC notifier context for head %d overflowed: %x\\n\",\n\t\t\t\t head->base.index, status);\n\t}\n\n\tNV_DEBUG(drm, \"Head %d CRC context status: %x\\n\",\n\t\t head->base.index, status);\n\n\treturn true;\n}\n\nconst struct nv50_crc_func crcc37d = {\n\t.set_src = crcc37d_set_src,\n\t.set_ctx = crcc37d_set_ctx,\n\t.get_entry = crcc37d_get_entry,\n\t.ctx_finished = crcc37d_ctx_finished,\n\t.flip_threshold = CRCC37D_FLIP_THRESHOLD,\n\t.num_entries = CRCC37D_MAX_ENTRIES,\n\t.notifier_len = sizeof(struct crcc37d_notifier),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}