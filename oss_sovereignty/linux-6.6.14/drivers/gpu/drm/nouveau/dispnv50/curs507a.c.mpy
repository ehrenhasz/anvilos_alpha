{
  "module_name": "curs507a.c",
  "hash_id": "875cc753f8abfd970582cc8dcd4d949c208fe87b1df6cb4b9e459b7483edebd0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/dispnv50/curs507a.c",
  "human_readable_source": " \n#include \"curs.h\"\n#include \"core.h\"\n#include \"head.h\"\n\n#include <nvif/if0014.h>\n#include <nvif/timer.h>\n\n#include <nvhw/class/cl507a.h>\n\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_fourcc.h>\n\nbool\ncurs507a_space(struct nv50_wndw *wndw)\n{\n\tnvif_msec(&nouveau_drm(wndw->plane.dev)->client.device, 100,\n\t\tif (NVIF_TV32(&wndw->wimm.base.user, NV507A, FREE, COUNT, >=, 4))\n\t\t\treturn true;\n\t);\n\n\tWARN_ON(1);\n\treturn false;\n}\n\nstatic int\ncurs507a_update(struct nv50_wndw *wndw, u32 *interlock)\n{\n\tstruct nvif_object *user = &wndw->wimm.base.user;\n\tint ret = nvif_chan_wait(&wndw->wimm, 1);\n\tif (ret == 0) {\n\t\tNVIF_WR32(user, NV507A, UPDATE,\n\t\t\t  NVDEF(NV507A, UPDATE, INTERLOCK_WITH_CORE, DISABLE));\n\t}\n\treturn ret;\n}\n\nstatic int\ncurs507a_point(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)\n{\n\tstruct nvif_object *user = &wndw->wimm.base.user;\n\tint ret = nvif_chan_wait(&wndw->wimm, 1);\n\tif (ret == 0) {\n\t\tNVIF_WR32(user, NV507A, SET_CURSOR_HOT_SPOT_POINT_OUT,\n\t\t\t  NVVAL(NV507A, SET_CURSOR_HOT_SPOT_POINT_OUT, X, asyw->point.x) |\n\t\t\t  NVVAL(NV507A, SET_CURSOR_HOT_SPOT_POINT_OUT, Y, asyw->point.y));\n\t}\n\treturn ret;\n}\n\nconst struct nv50_wimm_func\ncurs507a = {\n\t.point = curs507a_point,\n\t.update = curs507a_update,\n};\n\nstatic void\ncurs507a_prepare(struct nv50_wndw *wndw, struct nv50_head_atom *asyh,\n\t\t struct nv50_wndw_atom *asyw)\n{\n\tu32 handle = nv50_disp(wndw->plane.dev)->core->chan.vram.handle;\n\tu32 offset = asyw->image.offset[0];\n\tif (asyh->curs.handle != handle || asyh->curs.offset != offset) {\n\t\tasyh->curs.handle = handle;\n\t\tasyh->curs.offset = offset;\n\t\tasyh->set.curs = asyh->curs.visible;\n\t}\n}\n\nstatic void\ncurs507a_release(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\tasyh->curs.visible = false;\n}\n\nstatic int\ncurs507a_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,\n\t\t struct nv50_head_atom *asyh)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(wndw->plane.dev);\n\tstruct nv50_head *head = nv50_head(asyw->state.crtc);\n\tstruct drm_framebuffer *fb = asyw->state.fb;\n\tint ret;\n\n\tret = drm_atomic_helper_check_plane_state(&asyw->state, &asyh->state,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t  true, true);\n\tasyh->curs.visible = asyw->state.visible;\n\tif (ret || !asyh->curs.visible)\n\t\treturn ret;\n\n\tif (asyw->state.crtc_w != asyw->state.crtc_h) {\n\t\tNV_ATOMIC(drm, \"Plane width/height must be equal for cursors\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (asyw->image.w != asyw->state.crtc_w) {\n\t\tNV_ATOMIC(drm, \"Plane width must be equal to fb width for cursors (height can be larger though)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (asyw->state.src_x || asyw->state.src_y) {\n\t\tNV_ATOMIC(drm, \"Cursor planes do not support framebuffer offsets\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (asyw->image.pitch[0] != asyw->image.w * fb->format->cpp[0]) {\n\t\tNV_ATOMIC(drm,\n\t\t\t  \"%s: invalid cursor image pitch: image must be packed (pitch = %d, width = %d)\\n\",\n\t\t\t  wndw->plane.name, asyw->image.pitch[0], asyw->image.w);\n\t\treturn -EINVAL;\n\t}\n\n\tret = head->func->curs_layout(head, asyw, asyh);\n\tif (ret) {\n\t\tNV_ATOMIC(drm,\n\t\t\t  \"%s: invalid cursor image size: unsupported size %dx%d\\n\",\n\t\t\t  wndw->plane.name, asyw->image.w, asyw->image.h);\n\t\treturn ret;\n\t}\n\n\tret = head->func->curs_format(head, asyw, asyh);\n\tif (ret) {\n\t\tNV_ATOMIC(drm,\n\t\t\t  \"%s: invalid cursor image format 0x%X\\n\",\n\t\t\t  wndw->plane.name, fb->format->format);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const u32\ncurs507a_format[] = {\n\tDRM_FORMAT_ARGB8888,\n\t0\n};\n\nstatic const struct nv50_wndw_func\ncurs507a_wndw = {\n\t.acquire = curs507a_acquire,\n\t.release = curs507a_release,\n\t.prepare = curs507a_prepare,\n};\n\nint\ncurs507a_new_(const struct nv50_wimm_func *func, struct nouveau_drm *drm,\n\t      int head, s32 oclass, u32 interlock_data,\n\t      struct nv50_wndw **pwndw)\n{\n\tstruct nvif_disp_chan_v0 args = {\n\t\t.id = head,\n\t};\n\tstruct nv50_disp *disp = nv50_disp(drm->dev);\n\tstruct nv50_wndw *wndw;\n\tint ret;\n\n\tret = nv50_wndw_new_(&curs507a_wndw, drm->dev, DRM_PLANE_TYPE_CURSOR,\n\t\t\t     \"curs\", head, curs507a_format, BIT(head),\n\t\t\t     NV50_DISP_INTERLOCK_CURS, interlock_data, &wndw);\n\tif (*pwndw = wndw, ret)\n\t\treturn ret;\n\n\tret = nvif_object_ctor(&disp->disp->object, \"kmsCurs\", 0, oclass,\n\t\t\t       &args, sizeof(args), &wndw->wimm.base.user);\n\tif (ret) {\n\t\tNV_ERROR(drm, \"curs%04x allocation failed: %d\\n\", oclass, ret);\n\t\treturn ret;\n\t}\n\n\tnvif_object_map(&wndw->wimm.base.user, NULL, 0);\n\twndw->immd = func;\n\twndw->ctxdma.parent = NULL;\n\treturn 0;\n}\n\nint\ncurs507a_new(struct nouveau_drm *drm, int head, s32 oclass,\n\t     struct nv50_wndw **pwndw)\n{\n\treturn curs507a_new_(&curs507a, drm, head, oclass,\n\t\t\t     0x00000001 << (head * 8), pwndw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}