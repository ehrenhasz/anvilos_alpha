{
  "module_name": "object.h",
  "hash_id": "94b79d21045efc12dd26fc67637536e579b99eae3ba6bb30b140a9f21f00be55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/include/nvif/object.h",
  "human_readable_source": " \n#ifndef __NVIF_OBJECT_H__\n#define __NVIF_OBJECT_H__\n#include <nvif/os.h>\n\nstruct nvif_sclass {\n\ts32 oclass;\n\tint minver;\n\tint maxver;\n};\n\nstruct nvif_object {\n\tstruct nvif_parent *parent;\n\tstruct nvif_client *client;\n\tconst char *name;\n\tu32 handle;\n\ts32 oclass;\n\tvoid *priv;  \n\tstruct {\n\t\tvoid __iomem *ptr;\n\t\tu64 size;\n\t} map;\n};\n\nstatic inline bool\nnvif_object_constructed(struct nvif_object *object)\n{\n\treturn object->client != NULL;\n}\n\nint  nvif_object_ctor(struct nvif_object *, const char *name, u32 handle,\n\t\t      s32 oclass, void *, u32, struct nvif_object *);\nvoid nvif_object_dtor(struct nvif_object *);\nint  nvif_object_ioctl(struct nvif_object *, void *, u32, void **);\nint  nvif_object_sclass_get(struct nvif_object *, struct nvif_sclass **);\nvoid nvif_object_sclass_put(struct nvif_sclass **);\nu32  nvif_object_rd(struct nvif_object *, int, u64);\nvoid nvif_object_wr(struct nvif_object *, int, u64, u32);\nint  nvif_object_mthd(struct nvif_object *, u32, void *, u32);\nint  nvif_object_map_handle(struct nvif_object *, void *, u32,\n\t\t\t    u64 *handle, u64 *length);\nvoid nvif_object_unmap_handle(struct nvif_object *);\nint  nvif_object_map(struct nvif_object *, void *, u32);\nvoid nvif_object_unmap(struct nvif_object *);\n\n#define nvif_handle(a) (unsigned long)(void *)(a)\n#define nvif_object(a) (a)->object\n\n#define nvif_rd(a,f,b,c) ({                                                    \\\n\tstruct nvif_object *_object = (a);                                     \\\n\tu32 _data;                                                             \\\n\tif (likely(_object->map.ptr))                                          \\\n\t\t_data = f((u8 __iomem *)_object->map.ptr + (c));               \\\n\telse                                                                   \\\n\t\t_data = nvif_object_rd(_object, (b), (c));                     \\\n\t_data;                                                                 \\\n})\n#define nvif_wr(a,f,b,c,d) ({                                                  \\\n\tstruct nvif_object *_object = (a);                                     \\\n\tif (likely(_object->map.ptr))                                          \\\n\t\tf((d), (u8 __iomem *)_object->map.ptr + (c));                  \\\n\telse                                                                   \\\n\t\tnvif_object_wr(_object, (b), (c), (d));                        \\\n})\n#define nvif_rd08(a,b) ({ ((u8)nvif_rd((a), ioread8, 1, (b))); })\n#define nvif_rd16(a,b) ({ ((u16)nvif_rd((a), ioread16_native, 2, (b))); })\n#define nvif_rd32(a,b) ({ ((u32)nvif_rd((a), ioread32_native, 4, (b))); })\n#define nvif_wr08(a,b,c) nvif_wr((a), iowrite8, 1, (b), (u8)(c))\n#define nvif_wr16(a,b,c) nvif_wr((a), iowrite16_native, 2, (b), (u16)(c))\n#define nvif_wr32(a,b,c) nvif_wr((a), iowrite32_native, 4, (b), (u32)(c))\n#define nvif_mask(a,b,c,d) ({                                                  \\\n\tstruct nvif_object *__object = (a);                                    \\\n\tu32 _addr = (b), _data = nvif_rd32(__object, _addr);                   \\\n\tnvif_wr32(__object, _addr, (_data & ~(c)) | (d));                      \\\n\t_data;                                                                 \\\n})\n\n#define nvif_mthd(a,b,c,d) nvif_object_mthd((a), (b), (c), (d))\n\nstruct nvif_mclass {\n\ts32 oclass;\n\tint version;\n};\n\n#define nvif_mclass(o,m) ({                                                    \\\n\tstruct nvif_object *object = (o);                                      \\\n\tstruct nvif_sclass *sclass;                                            \\\n\ttypeof(m[0]) *mclass = (m);                                            \\\n\tint ret = -ENODEV;                                                     \\\n\tint cnt, i, j;                                                         \\\n                                                                               \\\n\tcnt = nvif_object_sclass_get(object, &sclass);                         \\\n\tif (cnt >= 0) {                                                        \\\n\t\tfor (i = 0; ret < 0 && mclass[i].oclass; i++) {                \\\n\t\t\tfor (j = 0; j < cnt; j++) {                            \\\n\t\t\t\tif (mclass[i].oclass  == sclass[j].oclass &&   \\\n\t\t\t\t    mclass[i].version >= sclass[j].minver &&   \\\n\t\t\t\t    mclass[i].version <= sclass[j].maxver) {   \\\n\t\t\t\t\tret = i;                               \\\n\t\t\t\t\tbreak;                                 \\\n\t\t\t\t}                                              \\\n\t\t\t}                                                      \\\n\t\t}                                                              \\\n\t\tnvif_object_sclass_put(&sclass);                               \\\n\t}                                                                      \\\n\tret;                                                                   \\\n})\n\n#define nvif_sclass(o,m,u) ({                                                  \\\n\tconst typeof(m[0]) *_mclass = (m);                                     \\\n\ts32 _oclass = (u);                                                     \\\n\tint _cid;                                                              \\\n\tif (_oclass) {                                                         \\\n\t\tfor (_cid = 0; _mclass[_cid].oclass; _cid++) {                 \\\n\t\t\tif (_mclass[_cid].oclass == _oclass)                   \\\n\t\t\t\tbreak;                                         \\\n\t\t}                                                              \\\n\t\t_cid = _mclass[_cid].oclass ? _cid : -ENOSYS;                  \\\n\t} else {                                                               \\\n\t\t_cid = nvif_mclass((o), _mclass);                              \\\n\t}                                                                      \\\n\t_cid;                                                                  \\\n})\n\n#define NVIF_RD32_(p,o,dr)   nvif_rd32((p), (o) + (dr))\n#define NVIF_WR32_(p,o,dr,f) nvif_wr32((p), (o) + (dr), (f))\n#define NVIF_RD32(p,A...) DRF_RD(NVIF_RD32_,                  (p), 0, ##A)\n#define NVIF_RV32(p,A...) DRF_RV(NVIF_RD32_,                  (p), 0, ##A)\n#define NVIF_TV32(p,A...) DRF_TV(NVIF_RD32_,                  (p), 0, ##A)\n#define NVIF_TD32(p,A...) DRF_TD(NVIF_RD32_,                  (p), 0, ##A)\n#define NVIF_WR32(p,A...) DRF_WR(            NVIF_WR32_,      (p), 0, ##A)\n#define NVIF_WV32(p,A...) DRF_WV(            NVIF_WR32_,      (p), 0, ##A)\n#define NVIF_WD32(p,A...) DRF_WD(            NVIF_WR32_,      (p), 0, ##A)\n#define NVIF_MR32(p,A...) DRF_MR(NVIF_RD32_, NVIF_WR32_, u32, (p), 0, ##A)\n#define NVIF_MV32(p,A...) DRF_MV(NVIF_RD32_, NVIF_WR32_, u32, (p), 0, ##A)\n#define NVIF_MD32(p,A...) DRF_MD(NVIF_RD32_, NVIF_WR32_, u32, (p), 0, ##A)\n\n \n#include <core/object.h>\n#define nvxx_object(a) ({                                                      \\\n\tstruct nvif_object *_object = (a);                                     \\\n\t(struct nvkm_object *)_object->priv;                                   \\\n})\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}