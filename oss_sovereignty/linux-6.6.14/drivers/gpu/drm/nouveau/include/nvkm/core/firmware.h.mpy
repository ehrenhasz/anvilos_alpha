{
  "module_name": "firmware.h",
  "hash_id": "93eeb786ec0ef07f1c03c9b8c41df13e0be23555ca3785d46210995579cba0f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/include/nvkm/core/firmware.h",
  "human_readable_source": " \n#ifndef __NVKM_FIRMWARE_H__\n#define __NVKM_FIRMWARE_H__\n#include <core/memory.h>\n#include <core/option.h>\n#include <core/subdev.h>\n\nstruct nvkm_firmware {\n\tconst struct nvkm_firmware_func {\n\t\tenum nvkm_firmware_type {\n\t\t\tNVKM_FIRMWARE_IMG_RAM,\n\t\t\tNVKM_FIRMWARE_IMG_DMA,\n\t\t} type;\n\t} *func;\n\tconst char *name;\n\tstruct nvkm_device *device;\n\n\tint len;\n\tu8 *img;\n\tu64 phys;\n\n\tstruct nvkm_firmware_mem {\n\t\tstruct nvkm_memory memory;\n\t\tstruct scatterlist sgl;\n\t} mem;\n};\n\nint nvkm_firmware_ctor(const struct nvkm_firmware_func *, const char *name, struct nvkm_device *,\n\t\t       const void *ptr, int len, struct nvkm_firmware *);\nvoid nvkm_firmware_dtor(struct nvkm_firmware *);\n\nint nvkm_firmware_get(const struct nvkm_subdev *, const char *fwname, int ver,\n\t\t      const struct firmware **);\nvoid nvkm_firmware_put(const struct firmware *);\n\nint nvkm_firmware_load_blob(const struct nvkm_subdev *subdev, const char *path,\n\t\t\t    const char *name, int ver, struct nvkm_blob *);\nint nvkm_firmware_load_name(const struct nvkm_subdev *subdev, const char *path,\n\t\t\t    const char *name, int ver,\n\t\t\t    const struct firmware **);\n\n#define nvkm_firmware_load(s,l,o,p...) ({                                      \\\n\tstruct nvkm_subdev *_s = (s);                                          \\\n\tconst char *_opts = (o);                                               \\\n\tchar _option[32];                                                      \\\n\ttypeof(l[0]) *_list = (l), *_next, *_fwif = NULL;                      \\\n\tint _ver, _fwv, _ret = 0;                                              \\\n                                                                               \\\n\tsnprintf(_option, sizeof(_option), \"Nv%sFw\", _opts);                   \\\n\t_ver = nvkm_longopt(_s->device->cfgopt, _option, -2);                  \\\n\tif (_ver >= -1) {                                                      \\\n\t\tfor (_next = _list; !_fwif && _next->load; _next++) {          \\\n\t\t\tif (_next->version == _ver)                            \\\n\t\t\t\t_fwif = _next;                                 \\\n\t\t}                                                              \\\n\t\t_ret = _fwif ? 0 : -EINVAL;                                    \\\n\t}                                                                      \\\n                                                                               \\\n\tif (_ret == 0) {                                                       \\\n\t\tsnprintf(_option, sizeof(_option), \"Nv%sFwVer\", _opts);        \\\n\t\t_fwv = _fwif ? _fwif->version : -1;                            \\\n\t\t_ver = nvkm_longopt(_s->device->cfgopt, _option, _fwv);        \\\n\t\tfor (_next = _fwif ? _fwif : _list; _next->load; _next++) {    \\\n\t\t\t_fwv = (_ver >= 0) ? _ver : _next->version;            \\\n\t\t\t_ret = _next->load(p, _fwv, _next);                    \\\n\t\t\tif (_ret == 0 || _ver >= 0) {                          \\\n\t\t\t\t_fwif = _next;                                 \\\n\t\t\t\tbreak;                                         \\\n\t\t\t}                                                      \\\n\t\t}                                                              \\\n\t}                                                                      \\\n                                                                               \\\n\tif (_ret)                                                              \\\n\t\t_fwif = ERR_PTR(_ret);                                         \\\n\t_fwif;                                                                 \\\n})\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}