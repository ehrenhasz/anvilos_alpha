{
  "module_name": "i2c.h",
  "hash_id": "be709013e54d20189f13c6c40cdf552c6d5b43d96f0982e4fedd5d4a37cffda7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/include/nvkm/subdev/i2c.h",
  "human_readable_source": " \n#ifndef __NVKM_I2C_H__\n#define __NVKM_I2C_H__\n#include <core/subdev.h>\n#include <core/event.h>\n\n#include <subdev/bios.h>\n#include <subdev/bios/i2c.h>\n\nstruct nvkm_i2c_bus_probe {\n\tstruct i2c_board_info dev;\n\tu8 udelay;  \n};\n\nstruct nvkm_i2c_bus {\n\tconst struct nvkm_i2c_bus_func *func;\n\tstruct nvkm_i2c_pad *pad;\n#define NVKM_I2C_BUS_CCB(n)                             (n)\n#define NVKM_I2C_BUS_EXT(n)    ((n) + 0x10)\n#define NVKM_I2C_BUS_PRI                          -1\n#define NVKM_I2C_BUS_SEC                        -2\n\tint id;\n\n\tstruct mutex mutex;\n\tstruct list_head head;\n\tstruct i2c_adapter i2c;\n\tu8 enabled;\n};\n\nint nvkm_i2c_bus_acquire(struct nvkm_i2c_bus *);\nvoid nvkm_i2c_bus_release(struct nvkm_i2c_bus *);\nint nvkm_i2c_bus_probe(struct nvkm_i2c_bus *, const char *,\n\t\t       struct nvkm_i2c_bus_probe *,\n\t\t       bool (*)(struct nvkm_i2c_bus *,\n\t\t\t        struct i2c_board_info *, void *), void *);\n\nstruct nvkm_i2c_aux {\n\tconst struct nvkm_i2c_aux_func *func;\n\tstruct nvkm_i2c_pad *pad;\n#define NVKM_I2C_AUX_CCB(n)                             (n)\n#define NVKM_I2C_AUX_EXT(n)    ((n) + 0x10)\n\tint id;\n\n\tstruct mutex mutex;\n\tstruct list_head head;\n\tstruct i2c_adapter i2c;\n\tu8 enabled;\n\n\tu32 intr;\n};\n\nvoid nvkm_i2c_aux_monitor(struct nvkm_i2c_aux *, bool monitor);\nint nvkm_i2c_aux_acquire(struct nvkm_i2c_aux *);\nvoid nvkm_i2c_aux_release(struct nvkm_i2c_aux *);\nint nvkm_i2c_aux_xfer(struct nvkm_i2c_aux *, bool retry, u8 type,\n\t\t      u32 addr, u8 *data, u8 *size);\nint nvkm_i2c_aux_lnk_ctl(struct nvkm_i2c_aux *, int link_nr, int link_bw,\n\t\t\t bool enhanced_framing);\n\nstruct nvkm_i2c {\n\tconst struct nvkm_i2c_func *func;\n\tstruct nvkm_subdev subdev;\n\n\tstruct list_head pad;\n\tstruct list_head bus;\n\tstruct list_head aux;\n\n#define NVKM_I2C_PLUG   BIT(0)\n#define NVKM_I2C_UNPLUG BIT(1)\n#define NVKM_I2C_IRQ    BIT(2)\n#define NVKM_I2C_DONE   BIT(3)\n#define NVKM_I2C_ANY   (NVKM_I2C_PLUG | NVKM_I2C_UNPLUG | NVKM_I2C_IRQ | NVKM_I2C_DONE)\n\tstruct nvkm_event event;\n};\n\nstruct nvkm_i2c_bus *nvkm_i2c_bus_find(struct nvkm_i2c *, int);\nstruct nvkm_i2c_aux *nvkm_i2c_aux_find(struct nvkm_i2c *, int);\n\nint nv04_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint nv4e_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint nv50_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint g94_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint gf117_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint gf119_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint gk104_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint gk110_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\nint gm200_i2c_new(struct nvkm_device *, enum nvkm_subdev_type, int inst, struct nvkm_i2c **);\n\nstatic inline int\nnvkm_rdi2cr(struct i2c_adapter *adap, u8 addr, u8 reg)\n{\n\tu8 val;\n\tstruct i2c_msg msgs[] = {\n\t\t{ .addr = addr, .flags = 0, .len = 1, .buf = &reg },\n\t\t{ .addr = addr, .flags = I2C_M_RD, .len = 1, .buf = &val },\n\t};\n\n\tint ret = i2c_transfer(adap, msgs, ARRAY_SIZE(msgs));\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\treturn val;\n}\n\nstatic inline int\nnv_rd16i2cr(struct i2c_adapter *adap, u8 addr, u8 reg)\n{\n\tu8 val[2];\n\tstruct i2c_msg msgs[] = {\n\t\t{ .addr = addr, .flags = 0, .len = 1, .buf = &reg },\n\t\t{ .addr = addr, .flags = I2C_M_RD, .len = 2, .buf = val },\n\t};\n\n\tint ret = i2c_transfer(adap, msgs, ARRAY_SIZE(msgs));\n\tif (ret != 2)\n\t\treturn -EIO;\n\n\treturn val[0] << 8 | val[1];\n}\n\nstatic inline int\nnvkm_wri2cr(struct i2c_adapter *adap, u8 addr, u8 reg, u8 val)\n{\n\tu8 buf[2] = { reg, val };\n\tstruct i2c_msg msgs[] = {\n\t\t{ .addr = addr, .flags = 0, .len = 2, .buf = buf },\n\t};\n\n\tint ret = i2c_transfer(adap, msgs, ARRAY_SIZE(msgs));\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic inline int\nnv_wr16i2cr(struct i2c_adapter *adap, u8 addr, u8 reg, u16 val)\n{\n\tu8 buf[3] = { reg, val >> 8, val & 0xff};\n\tstruct i2c_msg msgs[] = {\n\t\t{ .addr = addr, .flags = 0, .len = 3, .buf = buf },\n\t};\n\n\tint ret = i2c_transfer(adap, msgs, ARRAY_SIZE(msgs));\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic inline bool\nnvkm_probe_i2c(struct i2c_adapter *adap, u8 addr)\n{\n\treturn nvkm_rdi2cr(adap, addr, 0) >= 0;\n}\n\nstatic inline int\nnvkm_rdaux(struct nvkm_i2c_aux *aux, u32 addr, u8 *data, u8 size)\n{\n\tconst u8 xfer = size;\n\tint ret = nvkm_i2c_aux_acquire(aux);\n\tif (ret == 0) {\n\t\tret = nvkm_i2c_aux_xfer(aux, true, 9, addr, data, &size);\n\t\tWARN_ON(!ret && size != xfer);\n\t\tnvkm_i2c_aux_release(aux);\n\t}\n\treturn ret;\n}\n\nstatic inline int\nnvkm_wraux(struct nvkm_i2c_aux *aux, u32 addr, u8 *data, u8 size)\n{\n\tint ret = nvkm_i2c_aux_acquire(aux);\n\tif (ret == 0) {\n\t\tret = nvkm_i2c_aux_xfer(aux, true, 8, addr, data, &size);\n\t\tnvkm_i2c_aux_release(aux);\n\t}\n\treturn ret;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}