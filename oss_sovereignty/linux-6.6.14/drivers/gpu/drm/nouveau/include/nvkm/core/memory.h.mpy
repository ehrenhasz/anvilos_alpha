{
  "module_name": "memory.h",
  "hash_id": "fbb4dd7e0d2ecfbf701aef2952a32ecd46121b09db218e519f5e69ce79ca14b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/include/nvkm/core/memory.h",
  "human_readable_source": " \n#ifndef __NVKM_MEMORY_H__\n#define __NVKM_MEMORY_H__\n#include <core/os.h>\nstruct nvkm_device;\nstruct nvkm_vma;\nstruct nvkm_vmm;\n\nstruct nvkm_tags {\n\tstruct nvkm_mm_node *mn;\n\trefcount_t refcount;\n};\n\nenum nvkm_memory_target {\n\tNVKM_MEM_TARGET_INST,  \n\tNVKM_MEM_TARGET_VRAM,  \n\tNVKM_MEM_TARGET_HOST,  \n\tNVKM_MEM_TARGET_NCOH,  \n};\n\nstruct nvkm_memory {\n\tconst struct nvkm_memory_func *func;\n\tconst struct nvkm_memory_ptrs *ptrs;\n\tstruct kref kref;\n\tstruct nvkm_tags *tags;\n};\n\nstruct nvkm_memory_func {\n\tvoid *(*dtor)(struct nvkm_memory *);\n\tenum nvkm_memory_target (*target)(struct nvkm_memory *);\n\tu8 (*page)(struct nvkm_memory *);\n\tu64 (*bar2)(struct nvkm_memory *);\n\tu64 (*addr)(struct nvkm_memory *);\n\tu64 (*size)(struct nvkm_memory *);\n\tvoid (*boot)(struct nvkm_memory *, struct nvkm_vmm *);\n\tvoid __iomem *(*acquire)(struct nvkm_memory *);\n\tvoid (*release)(struct nvkm_memory *);\n\tint (*map)(struct nvkm_memory *, u64 offset, struct nvkm_vmm *,\n\t\t   struct nvkm_vma *, void *argv, u32 argc);\n\tint (*kmap)(struct nvkm_memory *, struct nvkm_memory **);\n};\n\nstruct nvkm_memory_ptrs {\n\tu32 (*rd32)(struct nvkm_memory *, u64 offset);\n\tvoid (*wr32)(struct nvkm_memory *, u64 offset, u32 data);\n};\n\nvoid nvkm_memory_ctor(const struct nvkm_memory_func *, struct nvkm_memory *);\nint nvkm_memory_new(struct nvkm_device *, enum nvkm_memory_target,\n\t\t    u64 size, u32 align, bool zero, struct nvkm_memory **);\nstruct nvkm_memory *nvkm_memory_ref(struct nvkm_memory *);\nvoid nvkm_memory_unref(struct nvkm_memory **);\nint nvkm_memory_tags_get(struct nvkm_memory *, struct nvkm_device *, u32 tags,\n\t\t\t void (*clear)(struct nvkm_device *, u32, u32),\n\t\t\t struct nvkm_tags **);\nvoid nvkm_memory_tags_put(struct nvkm_memory *, struct nvkm_device *,\n\t\t\t  struct nvkm_tags **);\n\n#define nvkm_memory_target(p) (p)->func->target(p)\n#define nvkm_memory_page(p) (p)->func->page(p)\n#define nvkm_memory_bar2(p) (p)->func->bar2(p)\n#define nvkm_memory_addr(p) (p)->func->addr(p)\n#define nvkm_memory_size(p) (p)->func->size(p)\n#define nvkm_memory_boot(p,v) (p)->func->boot((p),(v))\n#define nvkm_memory_map(p,o,vm,va,av,ac)                                       \\\n\t(p)->func->map((p),(o),(vm),(va),(av),(ac))\n#define nvkm_memory_kmap(p,i) ((p)->func->kmap ? (p)->func->kmap((p), (i)) : -ENOSYS)\n\n \n#define nvkm_kmap(o)     (o)->func->acquire(o)\n#define nvkm_done(o)     (o)->func->release(o)\n\n#define nvkm_ro32(o,a)   (o)->ptrs->rd32((o), (a))\n#define nvkm_wo32(o,a,d) (o)->ptrs->wr32((o), (a), (d))\n#define nvkm_mo32(o,a,m,d) ({                                                  \\\n\tu32 _addr = (a), _data = nvkm_ro32((o), _addr);                        \\\n\tnvkm_wo32((o), _addr, (_data & ~(m)) | (d));                           \\\n\t_data;                                                                 \\\n})\n\n#define nvkm_wo64(o,a,d) do {                                                  \\\n\tu64 __a = (a), __d = (d);                                              \\\n\tnvkm_wo32((o), __a + 0, lower_32_bits(__d));                           \\\n\tnvkm_wo32((o), __a + 4, upper_32_bits(__d));                           \\\n} while(0)\n\n#define nvkm_robj(o,a,p,s) do {                                                \\\n\tu32 _addr = (a), _size = (s) >> 2, *_data = (void *)(p);               \\\n\twhile (_size--) {                                                      \\\n\t\t*(_data++) = nvkm_ro32((o), _addr);                            \\\n\t\t_addr += 4;                                                    \\\n\t}                                                                      \\\n} while(0)\n\n#define nvkm_wobj(o,a,p,s) do {                                                \\\n\tu32 _addr = (a), _size = (s) >> 2, *_data = (void *)(p);               \\\n\twhile (_size--) {                                                      \\\n\t\tnvkm_wo32((o), _addr, *(_data++));                             \\\n\t\t_addr += 4;                                                    \\\n\t}                                                                      \\\n} while(0)\n\n#define nvkm_fill(t,s,o,a,d,c) do {                                            \\\n\tu64 _a = (a), _c = (c), _d = (d), _o = _a >> s, _s = _c << s;          \\\n\tu##t __iomem *_m = nvkm_kmap(o);                                       \\\n\tif (likely(_m)) {                                                      \\\n\t\tif (_d) {                                                      \\\n\t\t\twhile (_c--)                                           \\\n\t\t\t\tiowrite##t##_native(_d, &_m[_o++]);            \\\n\t\t} else {                                                       \\\n\t\t\tmemset_io(&_m[_o], _d, _s);                            \\\n\t\t}                                                              \\\n\t} else {                                                               \\\n\t\tfor (; _c; _c--, _a += BIT(s))                                 \\\n\t\t\tnvkm_wo##t((o), _a, _d);                               \\\n\t}                                                                      \\\n\tnvkm_done(o);                                                          \\\n} while(0)\n#define nvkm_fo32(o,a,d,c) nvkm_fill(32, 2, (o), (a), (d), (c))\n#define nvkm_fo64(o,a,d,c) nvkm_fill(64, 3, (o), (a), (d), (c))\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}