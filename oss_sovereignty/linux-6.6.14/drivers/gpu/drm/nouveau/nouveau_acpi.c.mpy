{
  "module_name": "nouveau_acpi.c",
  "hash_id": "3f9a2c80ea2e2691a6d45bc3da71037615b76e8da68722b7b72bfc6e70a9bf57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_acpi.c",
  "human_readable_source": "\n#include <linux/pci.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <linux/mxm-wmi.h>\n#include <linux/vga_switcheroo.h>\n#include <drm/drm_edid.h>\n#include <acpi/video.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_acpi.h\"\n\n#define NOUVEAU_DSM_LED 0x02\n#define NOUVEAU_DSM_LED_STATE 0x00\n#define NOUVEAU_DSM_LED_OFF 0x10\n#define NOUVEAU_DSM_LED_STAMINA 0x11\n#define NOUVEAU_DSM_LED_SPEED 0x12\n\n#define NOUVEAU_DSM_POWER 0x03\n#define NOUVEAU_DSM_POWER_STATE 0x00\n#define NOUVEAU_DSM_POWER_SPEED 0x01\n#define NOUVEAU_DSM_POWER_STAMINA 0x02\n\n#define NOUVEAU_DSM_OPTIMUS_CAPS 0x1A\n#define NOUVEAU_DSM_OPTIMUS_FLAGS 0x1B\n\n#define NOUVEAU_DSM_OPTIMUS_POWERDOWN_PS3 (3 << 24)\n#define NOUVEAU_DSM_OPTIMUS_NO_POWERDOWN_PS3 (2 << 24)\n#define NOUVEAU_DSM_OPTIMUS_FLAGS_CHANGED (1)\n\n#define NOUVEAU_DSM_OPTIMUS_SET_POWERDOWN (NOUVEAU_DSM_OPTIMUS_POWERDOWN_PS3 | NOUVEAU_DSM_OPTIMUS_FLAGS_CHANGED)\n\n \n#define OPTIMUS_ENABLED (1 << 0)\n#define OPTIMUS_STATUS_MASK (3 << 3)\n#define OPTIMUS_STATUS_OFF  (0 << 3)\n#define OPTIMUS_STATUS_ON_ENABLED  (1 << 3)\n#define OPTIMUS_STATUS_PWR_STABLE  (3 << 3)\n#define OPTIMUS_DISPLAY_HOTPLUG (1 << 6)\n#define OPTIMUS_CAPS_MASK (7 << 24)\n#define OPTIMUS_DYNAMIC_PWR_CAP (1 << 24)\n\n#define OPTIMUS_AUDIO_CAPS_MASK (3 << 27)\n#define OPTIMUS_HDA_CODEC_MASK (2 << 27)  \n\nstatic struct nouveau_dsm_priv {\n\tbool dsm_detected;\n\tbool optimus_detected;\n\tbool optimus_flags_detected;\n\tbool optimus_skip_dsm;\n\tacpi_handle dhandle;\n} nouveau_dsm_priv;\n\nbool nouveau_is_optimus(void) {\n\treturn nouveau_dsm_priv.optimus_detected;\n}\n\nbool nouveau_is_v1_dsm(void) {\n\treturn nouveau_dsm_priv.dsm_detected;\n}\n\n#ifdef CONFIG_VGA_SWITCHEROO\nstatic const guid_t nouveau_dsm_muid =\n\tGUID_INIT(0x9D95A0A0, 0x0060, 0x4D48,\n\t\t  0xB3, 0x4D, 0x7E, 0x5F, 0xEA, 0x12, 0x9F, 0xD4);\n\nstatic const guid_t nouveau_op_dsm_muid =\n\tGUID_INIT(0xA486D8F8, 0x0BDA, 0x471B,\n\t\t  0xA7, 0x2B, 0x60, 0x42, 0xA6, 0xB5, 0xBE, 0xE0);\n\nstatic int nouveau_optimus_dsm(acpi_handle handle, int func, int arg, uint32_t *result)\n{\n\tint i;\n\tunion acpi_object *obj;\n\tchar args_buff[4];\n\tunion acpi_object argv4 = {\n\t\t.buffer.type = ACPI_TYPE_BUFFER,\n\t\t.buffer.length = 4,\n\t\t.buffer.pointer = args_buff\n\t};\n\n\t \n\tfor (i = 0; i < 4; i++)\n\t\targs_buff[i] = (arg >> i * 8) & 0xFF;\n\n\t*result = 0;\n\tobj = acpi_evaluate_dsm_typed(handle, &nouveau_op_dsm_muid, 0x00000100,\n\t\t\t\t      func, &argv4, ACPI_TYPE_BUFFER);\n\tif (!obj) {\n\t\tacpi_handle_info(handle, \"failed to evaluate _DSM\\n\");\n\t\treturn AE_ERROR;\n\t} else {\n\t\tif (obj->buffer.length == 4) {\n\t\t\t*result |= obj->buffer.pointer[0];\n\t\t\t*result |= (obj->buffer.pointer[1] << 8);\n\t\t\t*result |= (obj->buffer.pointer[2] << 16);\n\t\t\t*result |= (obj->buffer.pointer[3] << 24);\n\t\t}\n\t\tACPI_FREE(obj);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nouveau_dsm_get_optimus_functions(acpi_handle handle)\n{\n\tint result;\n\n\t \n\tif (nouveau_optimus_dsm(handle, 0, 0, &result))\n\t\treturn 0;\n\n\t \n\tif (result & 1 && result & (1 << NOUVEAU_DSM_OPTIMUS_CAPS))\n\t\treturn result;\n\treturn 0;\n}\n\nstatic int nouveau_dsm(acpi_handle handle, int func, int arg)\n{\n\tint ret = 0;\n\tunion acpi_object *obj;\n\tunion acpi_object argv4 = {\n\t\t.integer.type = ACPI_TYPE_INTEGER,\n\t\t.integer.value = arg,\n\t};\n\n\tobj = acpi_evaluate_dsm_typed(handle, &nouveau_dsm_muid, 0x00000102,\n\t\t\t\t      func, &argv4, ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\tacpi_handle_info(handle, \"failed to evaluate _DSM\\n\");\n\t\treturn AE_ERROR;\n\t} else {\n\t\tif (obj->integer.value == 0x80000002)\n\t\t\tret = -ENODEV;\n\t\tACPI_FREE(obj);\n\t}\n\n\treturn ret;\n}\n\nstatic int nouveau_dsm_switch_mux(acpi_handle handle, int mux_id)\n{\n\tmxm_wmi_call_mxmx(mux_id == NOUVEAU_DSM_LED_STAMINA ? MXM_MXDS_ADAPTER_IGD : MXM_MXDS_ADAPTER_0);\n\tmxm_wmi_call_mxds(mux_id == NOUVEAU_DSM_LED_STAMINA ? MXM_MXDS_ADAPTER_IGD : MXM_MXDS_ADAPTER_0);\n\treturn nouveau_dsm(handle, NOUVEAU_DSM_LED, mux_id);\n}\n\nstatic int nouveau_dsm_set_discrete_state(acpi_handle handle, enum vga_switcheroo_state state)\n{\n\tint arg;\n\tif (state == VGA_SWITCHEROO_ON)\n\t\targ = NOUVEAU_DSM_POWER_SPEED;\n\telse\n\t\targ = NOUVEAU_DSM_POWER_STAMINA;\n\tnouveau_dsm(handle, NOUVEAU_DSM_POWER, arg);\n\treturn 0;\n}\n\nstatic int nouveau_dsm_switchto(enum vga_switcheroo_client_id id)\n{\n\tif (!nouveau_dsm_priv.dsm_detected)\n\t\treturn 0;\n\tif (id == VGA_SWITCHEROO_IGD)\n\t\treturn nouveau_dsm_switch_mux(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_LED_STAMINA);\n\telse\n\t\treturn nouveau_dsm_switch_mux(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_LED_SPEED);\n}\n\nstatic int nouveau_dsm_power_state(enum vga_switcheroo_client_id id,\n\t\t\t\t   enum vga_switcheroo_state state)\n{\n\tif (id == VGA_SWITCHEROO_IGD)\n\t\treturn 0;\n\n\t \n\tif (!nouveau_dsm_priv.dsm_detected)\n\t\treturn 0;\n\n\treturn nouveau_dsm_set_discrete_state(nouveau_dsm_priv.dhandle, state);\n}\n\nstatic enum vga_switcheroo_client_id nouveau_dsm_get_client_id(struct pci_dev *pdev)\n{\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL)\n\t\treturn VGA_SWITCHEROO_IGD;\n\n\t \n\tif (pdev->bus->number == 0)\n\t\treturn VGA_SWITCHEROO_IGD;\n\n\treturn VGA_SWITCHEROO_DIS;\n}\n\nstatic const struct vga_switcheroo_handler nouveau_dsm_handler = {\n\t.switchto = nouveau_dsm_switchto,\n\t.power_state = nouveau_dsm_power_state,\n\t.get_client_id = nouveau_dsm_get_client_id,\n};\n\nstatic void nouveau_dsm_pci_probe(struct pci_dev *pdev, acpi_handle *dhandle_out,\n\t\t\t\t  bool *has_mux, bool *has_opt,\n\t\t\t\t  bool *has_opt_flags, bool *has_pr3)\n{\n\tacpi_handle dhandle;\n\tbool supports_mux;\n\tint optimus_funcs;\n\tstruct pci_dev *parent_pdev;\n\n\tif (pdev->vendor != PCI_VENDOR_ID_NVIDIA)\n\t\treturn;\n\n\t*has_pr3 = false;\n\tparent_pdev = pci_upstream_bridge(pdev);\n\tif (parent_pdev) {\n\t\tif (parent_pdev->bridge_d3)\n\t\t\t*has_pr3 = pci_pr3_present(parent_pdev);\n\t\telse\n\t\t\tpci_d3cold_disable(pdev);\n\t}\n\n\tdhandle = ACPI_HANDLE(&pdev->dev);\n\tif (!dhandle)\n\t\treturn;\n\n\tif (!acpi_has_method(dhandle, \"_DSM\"))\n\t\treturn;\n\n\tsupports_mux = acpi_check_dsm(dhandle, &nouveau_dsm_muid, 0x00000102,\n\t\t\t\t      1 << NOUVEAU_DSM_POWER);\n\toptimus_funcs = nouveau_dsm_get_optimus_functions(dhandle);\n\n\t \n\tif (!supports_mux && !optimus_funcs)\n\t\treturn;\n\n\t*dhandle_out = dhandle;\n\t*has_mux = supports_mux;\n\t*has_opt = !!optimus_funcs;\n\t*has_opt_flags = optimus_funcs & (1 << NOUVEAU_DSM_OPTIMUS_FLAGS);\n\n\tif (optimus_funcs) {\n\t\tuint32_t result;\n\t\tnouveau_optimus_dsm(dhandle, NOUVEAU_DSM_OPTIMUS_CAPS, 0,\n\t\t\t\t    &result);\n\t\tdev_info(&pdev->dev, \"optimus capabilities: %s, status %s%s\\n\",\n\t\t\t (result & OPTIMUS_ENABLED) ? \"enabled\" : \"disabled\",\n\t\t\t (result & OPTIMUS_DYNAMIC_PWR_CAP) ? \"dynamic power, \" : \"\",\n\t\t\t (result & OPTIMUS_HDA_CODEC_MASK) ? \"hda bios codec supported\" : \"\");\n\t}\n}\n\nstatic bool nouveau_dsm_detect(void)\n{\n\tchar acpi_method_name[255] = { 0 };\n\tstruct acpi_buffer buffer = {sizeof(acpi_method_name), acpi_method_name};\n\tstruct pci_dev *pdev = NULL;\n\tacpi_handle dhandle = NULL;\n\tbool has_mux = false;\n\tbool has_optimus = false;\n\tbool has_optimus_flags = false;\n\tbool has_power_resources = false;\n\tint vga_count = 0;\n\tbool guid_valid;\n\tbool ret = false;\n\n\t \n\tguid_valid = mxm_wmi_supported();\n\n\tif (guid_valid)\n\t\tprintk(\"MXM: GUID detected in BIOS\\n\");\n\n\t \n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\n\t\tnouveau_dsm_pci_probe(pdev, &dhandle, &has_mux, &has_optimus,\n\t\t\t\t      &has_optimus_flags, &has_power_resources);\n\t}\n\n\twhile ((pdev = pci_get_class(PCI_CLASS_DISPLAY_3D << 8, pdev)) != NULL) {\n\t\tvga_count++;\n\n\t\tnouveau_dsm_pci_probe(pdev, &dhandle, &has_mux, &has_optimus,\n\t\t\t\t      &has_optimus_flags, &has_power_resources);\n\t}\n\n\t \n\tif (has_optimus) {\n\t\tnouveau_dsm_priv.dhandle = dhandle;\n\t\tacpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,\n\t\t\t&buffer);\n\t\tpr_info(\"VGA switcheroo: detected Optimus DSM method %s handle\\n\",\n\t\t\tacpi_method_name);\n\t\tif (has_power_resources)\n\t\t\tpr_info(\"nouveau: detected PR support, will not use DSM\\n\");\n\t\tnouveau_dsm_priv.optimus_detected = true;\n\t\tnouveau_dsm_priv.optimus_flags_detected = has_optimus_flags;\n\t\tnouveau_dsm_priv.optimus_skip_dsm = has_power_resources;\n\t\tret = true;\n\t} else if (vga_count == 2 && has_mux && guid_valid) {\n\t\tnouveau_dsm_priv.dhandle = dhandle;\n\t\tacpi_get_name(nouveau_dsm_priv.dhandle, ACPI_FULL_PATHNAME,\n\t\t\t&buffer);\n\t\tpr_info(\"VGA switcheroo: detected DSM switching method %s handle\\n\",\n\t\t\tacpi_method_name);\n\t\tnouveau_dsm_priv.dsm_detected = true;\n\t\tret = true;\n\t}\n\n\n\treturn ret;\n}\n\nvoid nouveau_register_dsm_handler(void)\n{\n\tbool r;\n\n\tr = nouveau_dsm_detect();\n\tif (!r)\n\t\treturn;\n\n\tvga_switcheroo_register_handler(&nouveau_dsm_handler, 0);\n}\n\n \nvoid nouveau_switcheroo_optimus_dsm(void)\n{\n\tu32 result = 0;\n\tif (!nouveau_dsm_priv.optimus_detected || nouveau_dsm_priv.optimus_skip_dsm)\n\t\treturn;\n\n\tif (nouveau_dsm_priv.optimus_flags_detected)\n\t\tnouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_FLAGS,\n\t\t\t\t    0x3, &result);\n\n\tnouveau_optimus_dsm(nouveau_dsm_priv.dhandle, NOUVEAU_DSM_OPTIMUS_CAPS,\n\t\tNOUVEAU_DSM_OPTIMUS_SET_POWERDOWN, &result);\n\n}\n\nvoid nouveau_unregister_dsm_handler(void)\n{\n\tif (nouveau_dsm_priv.optimus_detected || nouveau_dsm_priv.dsm_detected)\n\t\tvga_switcheroo_unregister_handler();\n}\n#else\nvoid nouveau_register_dsm_handler(void) {}\nvoid nouveau_unregister_dsm_handler(void) {}\nvoid nouveau_switcheroo_optimus_dsm(void) {}\n#endif\n\nvoid *\nnouveau_acpi_edid(struct drm_device *dev, struct drm_connector *connector)\n{\n\tstruct acpi_device *acpidev;\n\tint type, ret;\n\tvoid *edid;\n\n\tswitch (connector->connector_type) {\n\tcase DRM_MODE_CONNECTOR_LVDS:\n\tcase DRM_MODE_CONNECTOR_eDP:\n\t\ttype = ACPI_VIDEO_DISPLAY_LCD;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tacpidev = ACPI_COMPANION(dev->dev);\n\tif (!acpidev)\n\t\treturn NULL;\n\n\tret = acpi_video_get_edid(acpidev, type, -1, &edid);\n\tif (ret < 0)\n\t\treturn NULL;\n\n\treturn kmemdup(edid, EDID_LENGTH, GFP_KERNEL);\n}\n\nbool nouveau_acpi_video_backlight_use_native(void)\n{\n\treturn acpi_video_backlight_use_native();\n}\n\nvoid nouveau_acpi_video_register_backlight(void)\n{\n\tacpi_video_register_backlight();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}