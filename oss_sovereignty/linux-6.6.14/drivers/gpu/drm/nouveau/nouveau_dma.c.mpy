{
  "module_name": "nouveau_dma.c",
  "hash_id": "9565a0b8c0ba6e1229209ae4b497b479b8e8314f1121983b583e6aa629bbe3f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_dma.c",
  "human_readable_source": " \n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_vmm.h\"\n\n#include <nvif/user.h>\n\n \nstatic inline int\nREAD_GET(struct nouveau_channel *chan, uint64_t *prev_get, int *timeout)\n{\n\tuint64_t val;\n\n\tval = nvif_rd32(chan->userd, chan->user_get);\n        if (chan->user_get_hi)\n\t\tval |= (uint64_t)nvif_rd32(chan->userd, chan->user_get_hi) << 32;\n\n\t \n\tif (val != *prev_get) {\n\t\t*prev_get = val;\n\t\t*timeout = 0;\n\t}\n\n\tif ((++*timeout & 0xff) == 0) {\n\t\tudelay(1);\n\t\tif (*timeout > 100000)\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (val < chan->push.addr ||\n\t    val > chan->push.addr + (chan->dma.max << 2))\n\t\treturn -EINVAL;\n\n\treturn (val - chan->push.addr) >> 2;\n}\n\nvoid\nnv50_dma_push(struct nouveau_channel *chan, u64 offset, u32 length,\n\t      bool no_prefetch)\n{\n\tstruct nvif_user *user = &chan->drm->client.device.user;\n\tstruct nouveau_bo *pb = chan->push.buffer;\n\tint ip = (chan->dma.ib_put * 2) + chan->dma.ib_base;\n\n\tBUG_ON(chan->dma.ib_free < 1);\n\tWARN_ON(length > NV50_DMA_PUSH_MAX_LENGTH);\n\n\tnouveau_bo_wr32(pb, ip++, lower_32_bits(offset));\n\tnouveau_bo_wr32(pb, ip++, upper_32_bits(offset) | length << 8 |\n\t\t\t(no_prefetch ? (1 << 31) : 0));\n\n\tchan->dma.ib_put = (chan->dma.ib_put + 1) & chan->dma.ib_max;\n\n\tmb();\n\t \n\tnouveau_bo_rd32(pb, 0);\n\n\tnvif_wr32(chan->userd, 0x8c, chan->dma.ib_put);\n\tif (user->func && user->func->doorbell)\n\t\tuser->func->doorbell(user, chan->token);\n\tchan->dma.ib_free--;\n}\n\nstatic int\nnv50_dma_push_wait(struct nouveau_channel *chan, int count)\n{\n\tuint32_t cnt = 0, prev_get = 0;\n\n\twhile (chan->dma.ib_free < count) {\n\t\tuint32_t get = nvif_rd32(chan->userd, 0x88);\n\t\tif (get != prev_get) {\n\t\t\tprev_get = get;\n\t\t\tcnt = 0;\n\t\t}\n\n\t\tif ((++cnt & 0xff) == 0) {\n\t\t\tudelay(1);\n\t\t\tif (cnt > 100000)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tchan->dma.ib_free = get - chan->dma.ib_put;\n\t\tif (chan->dma.ib_free <= 0)\n\t\t\tchan->dma.ib_free += chan->dma.ib_max;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnv50_dma_wait(struct nouveau_channel *chan, int slots, int count)\n{\n\tuint64_t prev_get = 0;\n\tint ret, cnt = 0;\n\n\tret = nv50_dma_push_wait(chan, slots + 1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\twhile (chan->dma.free < count) {\n\t\tint get = READ_GET(chan, &prev_get, &cnt);\n\t\tif (unlikely(get < 0)) {\n\t\t\tif (get == -EINVAL)\n\t\t\t\tcontinue;\n\n\t\t\treturn get;\n\t\t}\n\n\t\tif (get <= chan->dma.cur) {\n\t\t\tchan->dma.free = chan->dma.max - chan->dma.cur;\n\t\t\tif (chan->dma.free >= count)\n\t\t\t\tbreak;\n\n\t\t\tFIRE_RING(chan);\n\t\t\tdo {\n\t\t\t\tget = READ_GET(chan, &prev_get, &cnt);\n\t\t\t\tif (unlikely(get < 0)) {\n\t\t\t\t\tif (get == -EINVAL)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\treturn get;\n\t\t\t\t}\n\t\t\t} while (get == 0);\n\t\t\tchan->dma.cur = 0;\n\t\t\tchan->dma.put = 0;\n\t\t}\n\n\t\tchan->dma.free = get - chan->dma.cur - 1;\n\t}\n\n\treturn 0;\n}\n\nint\nnouveau_dma_wait(struct nouveau_channel *chan, int slots, int size)\n{\n\tuint64_t prev_get = 0;\n\tint cnt = 0, get;\n\n\tif (chan->dma.ib_max)\n\t\treturn nv50_dma_wait(chan, slots, size);\n\n\twhile (chan->dma.free < size) {\n\t\tget = READ_GET(chan, &prev_get, &cnt);\n\t\tif (unlikely(get == -EBUSY))\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tif (unlikely(get == -EINVAL) || get < NOUVEAU_DMA_SKIPS)\n\t\t\tcontinue;\n\n\t\tif (get <= chan->dma.cur) {\n\t\t\t \n\t\t\tchan->dma.free = chan->dma.max - chan->dma.cur;\n\t\t\tif (chan->dma.free >= size)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tOUT_RING(chan, chan->push.addr | 0x20000000);\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\tget = READ_GET(chan, &prev_get, &cnt);\n\t\t\t\tif (unlikely(get == -EBUSY))\n\t\t\t\t\treturn -EBUSY;\n\t\t\t\tif (unlikely(get == -EINVAL))\n\t\t\t\t\tcontinue;\n\t\t\t} while (get <= NOUVEAU_DMA_SKIPS);\n\t\t\tWRITE_PUT(NOUVEAU_DMA_SKIPS);\n\n\t\t\t \n\t\t\tchan->dma.cur  =\n\t\t\tchan->dma.put  = NOUVEAU_DMA_SKIPS;\n\t\t}\n\n\t\t \n\t\tchan->dma.free = get - chan->dma.cur - 1;\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}