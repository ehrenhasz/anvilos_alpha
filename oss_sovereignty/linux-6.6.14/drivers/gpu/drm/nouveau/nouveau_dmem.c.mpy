{
  "module_name": "nouveau_dmem.c",
  "hash_id": "586790e92971dcc35c7f654c859683f8d5cf15650c74b681c23e14a52daa9b23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_dmem.c",
  "human_readable_source": " \n#include \"nouveau_dmem.h\"\n#include \"nouveau_drv.h\"\n#include \"nouveau_chan.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_mem.h\"\n#include \"nouveau_bo.h\"\n#include \"nouveau_svm.h\"\n\n#include <nvif/class.h>\n#include <nvif/object.h>\n#include <nvif/push906f.h>\n#include <nvif/if000c.h>\n#include <nvif/if500b.h>\n#include <nvif/if900b.h>\n\n#include <nvhw/class/cla0b5.h>\n\n#include <linux/sched/mm.h>\n#include <linux/hmm.h>\n#include <linux/memremap.h>\n#include <linux/migrate.h>\n\n \n#define DMEM_CHUNK_SIZE (2UL << 20)\n#define DMEM_CHUNK_NPAGES (DMEM_CHUNK_SIZE >> PAGE_SHIFT)\n\nenum nouveau_aper {\n\tNOUVEAU_APER_VIRT,\n\tNOUVEAU_APER_VRAM,\n\tNOUVEAU_APER_HOST,\n};\n\ntypedef int (*nouveau_migrate_copy_t)(struct nouveau_drm *drm, u64 npages,\n\t\t\t\t      enum nouveau_aper, u64 dst_addr,\n\t\t\t\t      enum nouveau_aper, u64 src_addr);\ntypedef int (*nouveau_clear_page_t)(struct nouveau_drm *drm, u32 length,\n\t\t\t\t      enum nouveau_aper, u64 dst_addr);\n\nstruct nouveau_dmem_chunk {\n\tstruct list_head list;\n\tstruct nouveau_bo *bo;\n\tstruct nouveau_drm *drm;\n\tunsigned long callocated;\n\tstruct dev_pagemap pagemap;\n};\n\nstruct nouveau_dmem_migrate {\n\tnouveau_migrate_copy_t copy_func;\n\tnouveau_clear_page_t clear_func;\n\tstruct nouveau_channel *chan;\n};\n\nstruct nouveau_dmem {\n\tstruct nouveau_drm *drm;\n\tstruct nouveau_dmem_migrate migrate;\n\tstruct list_head chunks;\n\tstruct mutex mutex;\n\tstruct page *free_pages;\n\tspinlock_t lock;\n};\n\nstatic struct nouveau_dmem_chunk *nouveau_page_to_chunk(struct page *page)\n{\n\treturn container_of(page->pgmap, struct nouveau_dmem_chunk, pagemap);\n}\n\nstatic struct nouveau_drm *page_to_drm(struct page *page)\n{\n\tstruct nouveau_dmem_chunk *chunk = nouveau_page_to_chunk(page);\n\n\treturn chunk->drm;\n}\n\nunsigned long nouveau_dmem_page_addr(struct page *page)\n{\n\tstruct nouveau_dmem_chunk *chunk = nouveau_page_to_chunk(page);\n\tunsigned long off = (page_to_pfn(page) << PAGE_SHIFT) -\n\t\t\t\tchunk->pagemap.range.start;\n\n\treturn chunk->bo->offset + off;\n}\n\nstatic void nouveau_dmem_page_free(struct page *page)\n{\n\tstruct nouveau_dmem_chunk *chunk = nouveau_page_to_chunk(page);\n\tstruct nouveau_dmem *dmem = chunk->drm->dmem;\n\n\tspin_lock(&dmem->lock);\n\tpage->zone_device_data = dmem->free_pages;\n\tdmem->free_pages = page;\n\n\tWARN_ON(!chunk->callocated);\n\tchunk->callocated--;\n\t \n\tspin_unlock(&dmem->lock);\n}\n\nstatic void nouveau_dmem_fence_done(struct nouveau_fence **fence)\n{\n\tif (fence) {\n\t\tnouveau_fence_wait(*fence, true, false);\n\t\tnouveau_fence_unref(fence);\n\t} else {\n\t\t \n\t}\n}\n\nstatic int nouveau_dmem_copy_one(struct nouveau_drm *drm, struct page *spage,\n\t\t\t\tstruct page *dpage, dma_addr_t *dma_addr)\n{\n\tstruct device *dev = drm->dev->dev;\n\n\tlock_page(dpage);\n\n\t*dma_addr = dma_map_page(dev, dpage, 0, PAGE_SIZE, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, *dma_addr))\n\t\treturn -EIO;\n\n\tif (drm->dmem->migrate.copy_func(drm, 1, NOUVEAU_APER_HOST, *dma_addr,\n\t\t\t\t\t NOUVEAU_APER_VRAM, nouveau_dmem_page_addr(spage))) {\n\t\tdma_unmap_page(dev, *dma_addr, PAGE_SIZE, DMA_BIDIRECTIONAL);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic vm_fault_t nouveau_dmem_migrate_to_ram(struct vm_fault *vmf)\n{\n\tstruct nouveau_drm *drm = page_to_drm(vmf->page);\n\tstruct nouveau_dmem *dmem = drm->dmem;\n\tstruct nouveau_fence *fence;\n\tstruct nouveau_svmm *svmm;\n\tstruct page *spage, *dpage;\n\tunsigned long src = 0, dst = 0;\n\tdma_addr_t dma_addr = 0;\n\tvm_fault_t ret = 0;\n\tstruct migrate_vma args = {\n\t\t.vma\t\t= vmf->vma,\n\t\t.start\t\t= vmf->address,\n\t\t.end\t\t= vmf->address + PAGE_SIZE,\n\t\t.src\t\t= &src,\n\t\t.dst\t\t= &dst,\n\t\t.pgmap_owner\t= drm->dev,\n\t\t.fault_page\t= vmf->page,\n\t\t.flags\t\t= MIGRATE_VMA_SELECT_DEVICE_PRIVATE,\n\t};\n\n\t \n\tif (migrate_vma_setup(&args) < 0)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!args.cpages)\n\t\treturn 0;\n\n\tspage = migrate_pfn_to_page(src);\n\tif (!spage || !(src & MIGRATE_PFN_MIGRATE))\n\t\tgoto done;\n\n\tdpage = alloc_page_vma(GFP_HIGHUSER, vmf->vma, vmf->address);\n\tif (!dpage)\n\t\tgoto done;\n\n\tdst = migrate_pfn(page_to_pfn(dpage));\n\n\tsvmm = spage->zone_device_data;\n\tmutex_lock(&svmm->mutex);\n\tnouveau_svmm_invalidate(svmm, args.start, args.end);\n\tret = nouveau_dmem_copy_one(drm, spage, dpage, &dma_addr);\n\tmutex_unlock(&svmm->mutex);\n\tif (ret) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto done;\n\t}\n\n\tnouveau_fence_new(&fence, dmem->migrate.chan);\n\tmigrate_vma_pages(&args);\n\tnouveau_dmem_fence_done(&fence);\n\tdma_unmap_page(drm->dev->dev, dma_addr, PAGE_SIZE, DMA_BIDIRECTIONAL);\ndone:\n\tmigrate_vma_finalize(&args);\n\treturn ret;\n}\n\nstatic const struct dev_pagemap_ops nouveau_dmem_pagemap_ops = {\n\t.page_free\t\t= nouveau_dmem_page_free,\n\t.migrate_to_ram\t\t= nouveau_dmem_migrate_to_ram,\n};\n\nstatic int\nnouveau_dmem_chunk_alloc(struct nouveau_drm *drm, struct page **ppage)\n{\n\tstruct nouveau_dmem_chunk *chunk;\n\tstruct resource *res;\n\tstruct page *page;\n\tvoid *ptr;\n\tunsigned long i, pfn_first;\n\tint ret;\n\n\tchunk = kzalloc(sizeof(*chunk), GFP_KERNEL);\n\tif (chunk == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tres = request_free_mem_region(&iomem_resource, DMEM_CHUNK_SIZE,\n\t\t\t\t      \"nouveau_dmem\");\n\tif (IS_ERR(res)) {\n\t\tret = PTR_ERR(res);\n\t\tgoto out_free;\n\t}\n\n\tchunk->drm = drm;\n\tchunk->pagemap.type = MEMORY_DEVICE_PRIVATE;\n\tchunk->pagemap.range.start = res->start;\n\tchunk->pagemap.range.end = res->end;\n\tchunk->pagemap.nr_range = 1;\n\tchunk->pagemap.ops = &nouveau_dmem_pagemap_ops;\n\tchunk->pagemap.owner = drm->dev;\n\n\tret = nouveau_bo_new(&drm->client, DMEM_CHUNK_SIZE, 0,\n\t\t\t     NOUVEAU_GEM_DOMAIN_VRAM, 0, 0, NULL, NULL,\n\t\t\t     &chunk->bo);\n\tif (ret)\n\t\tgoto out_release;\n\n\tret = nouveau_bo_pin(chunk->bo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\tif (ret)\n\t\tgoto out_bo_free;\n\n\tptr = memremap_pages(&chunk->pagemap, numa_node_id());\n\tif (IS_ERR(ptr)) {\n\t\tret = PTR_ERR(ptr);\n\t\tgoto out_bo_unpin;\n\t}\n\n\tmutex_lock(&drm->dmem->mutex);\n\tlist_add(&chunk->list, &drm->dmem->chunks);\n\tmutex_unlock(&drm->dmem->mutex);\n\n\tpfn_first = chunk->pagemap.range.start >> PAGE_SHIFT;\n\tpage = pfn_to_page(pfn_first);\n\tspin_lock(&drm->dmem->lock);\n\tfor (i = 0; i < DMEM_CHUNK_NPAGES - 1; ++i, ++page) {\n\t\tpage->zone_device_data = drm->dmem->free_pages;\n\t\tdrm->dmem->free_pages = page;\n\t}\n\t*ppage = page;\n\tchunk->callocated++;\n\tspin_unlock(&drm->dmem->lock);\n\n\tNV_INFO(drm, \"DMEM: registered %ldMB of device memory\\n\",\n\t\tDMEM_CHUNK_SIZE >> 20);\n\n\treturn 0;\n\nout_bo_unpin:\n\tnouveau_bo_unpin(chunk->bo);\nout_bo_free:\n\tnouveau_bo_ref(NULL, &chunk->bo);\nout_release:\n\trelease_mem_region(chunk->pagemap.range.start, range_len(&chunk->pagemap.range));\nout_free:\n\tkfree(chunk);\nout:\n\treturn ret;\n}\n\nstatic struct page *\nnouveau_dmem_page_alloc_locked(struct nouveau_drm *drm)\n{\n\tstruct nouveau_dmem_chunk *chunk;\n\tstruct page *page = NULL;\n\tint ret;\n\n\tspin_lock(&drm->dmem->lock);\n\tif (drm->dmem->free_pages) {\n\t\tpage = drm->dmem->free_pages;\n\t\tdrm->dmem->free_pages = page->zone_device_data;\n\t\tchunk = nouveau_page_to_chunk(page);\n\t\tchunk->callocated++;\n\t\tspin_unlock(&drm->dmem->lock);\n\t} else {\n\t\tspin_unlock(&drm->dmem->lock);\n\t\tret = nouveau_dmem_chunk_alloc(drm, &page);\n\t\tif (ret)\n\t\t\treturn NULL;\n\t}\n\n\tzone_device_page_init(page);\n\treturn page;\n}\n\nstatic void\nnouveau_dmem_page_free_locked(struct nouveau_drm *drm, struct page *page)\n{\n\tunlock_page(page);\n\tput_page(page);\n}\n\nvoid\nnouveau_dmem_resume(struct nouveau_drm *drm)\n{\n\tstruct nouveau_dmem_chunk *chunk;\n\tint ret;\n\n\tif (drm->dmem == NULL)\n\t\treturn;\n\n\tmutex_lock(&drm->dmem->mutex);\n\tlist_for_each_entry(chunk, &drm->dmem->chunks, list) {\n\t\tret = nouveau_bo_pin(chunk->bo, NOUVEAU_GEM_DOMAIN_VRAM, false);\n\t\t \n\t\tWARN_ON(ret);\n\t}\n\tmutex_unlock(&drm->dmem->mutex);\n}\n\nvoid\nnouveau_dmem_suspend(struct nouveau_drm *drm)\n{\n\tstruct nouveau_dmem_chunk *chunk;\n\n\tif (drm->dmem == NULL)\n\t\treturn;\n\n\tmutex_lock(&drm->dmem->mutex);\n\tlist_for_each_entry(chunk, &drm->dmem->chunks, list)\n\t\tnouveau_bo_unpin(chunk->bo);\n\tmutex_unlock(&drm->dmem->mutex);\n}\n\n \nstatic void\nnouveau_dmem_evict_chunk(struct nouveau_dmem_chunk *chunk)\n{\n\tunsigned long i, npages = range_len(&chunk->pagemap.range) >> PAGE_SHIFT;\n\tunsigned long *src_pfns, *dst_pfns;\n\tdma_addr_t *dma_addrs;\n\tstruct nouveau_fence *fence;\n\n\tsrc_pfns = kcalloc(npages, sizeof(*src_pfns), GFP_KERNEL);\n\tdst_pfns = kcalloc(npages, sizeof(*dst_pfns), GFP_KERNEL);\n\tdma_addrs = kcalloc(npages, sizeof(*dma_addrs), GFP_KERNEL);\n\n\tmigrate_device_range(src_pfns, chunk->pagemap.range.start >> PAGE_SHIFT,\n\t\t\tnpages);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tif (src_pfns[i] & MIGRATE_PFN_MIGRATE) {\n\t\t\tstruct page *dpage;\n\n\t\t\t \n\t\t\tdpage = alloc_page(GFP_HIGHUSER | __GFP_NOFAIL);\n\t\t\tdst_pfns[i] = migrate_pfn(page_to_pfn(dpage));\n\t\t\tnouveau_dmem_copy_one(chunk->drm,\n\t\t\t\t\tmigrate_pfn_to_page(src_pfns[i]), dpage,\n\t\t\t\t\t&dma_addrs[i]);\n\t\t}\n\t}\n\n\tnouveau_fence_new(&fence, chunk->drm->dmem->migrate.chan);\n\tmigrate_device_pages(src_pfns, dst_pfns, npages);\n\tnouveau_dmem_fence_done(&fence);\n\tmigrate_device_finalize(src_pfns, dst_pfns, npages);\n\tkfree(src_pfns);\n\tkfree(dst_pfns);\n\tfor (i = 0; i < npages; i++)\n\t\tdma_unmap_page(chunk->drm->dev->dev, dma_addrs[i], PAGE_SIZE, DMA_BIDIRECTIONAL);\n\tkfree(dma_addrs);\n}\n\nvoid\nnouveau_dmem_fini(struct nouveau_drm *drm)\n{\n\tstruct nouveau_dmem_chunk *chunk, *tmp;\n\n\tif (drm->dmem == NULL)\n\t\treturn;\n\n\tmutex_lock(&drm->dmem->mutex);\n\n\tlist_for_each_entry_safe(chunk, tmp, &drm->dmem->chunks, list) {\n\t\tnouveau_dmem_evict_chunk(chunk);\n\t\tnouveau_bo_unpin(chunk->bo);\n\t\tnouveau_bo_ref(NULL, &chunk->bo);\n\t\tWARN_ON(chunk->callocated);\n\t\tlist_del(&chunk->list);\n\t\tmemunmap_pages(&chunk->pagemap);\n\t\trelease_mem_region(chunk->pagemap.range.start,\n\t\t\t\t   range_len(&chunk->pagemap.range));\n\t\tkfree(chunk);\n\t}\n\n\tmutex_unlock(&drm->dmem->mutex);\n}\n\nstatic int\nnvc0b5_migrate_copy(struct nouveau_drm *drm, u64 npages,\n\t\t    enum nouveau_aper dst_aper, u64 dst_addr,\n\t\t    enum nouveau_aper src_aper, u64 src_addr)\n{\n\tstruct nvif_push *push = drm->dmem->migrate.chan->chan.push;\n\tu32 launch_dma = 0;\n\tint ret;\n\n\tret = PUSH_WAIT(push, 13);\n\tif (ret)\n\t\treturn ret;\n\n\tif (src_aper != NOUVEAU_APER_VIRT) {\n\t\tswitch (src_aper) {\n\t\tcase NOUVEAU_APER_VRAM:\n\t\t\tPUSH_IMMD(push, NVA0B5, SET_SRC_PHYS_MODE,\n\t\t\t\t  NVDEF(NVA0B5, SET_SRC_PHYS_MODE, TARGET, LOCAL_FB));\n\t\t\tbreak;\n\t\tcase NOUVEAU_APER_HOST:\n\t\t\tPUSH_IMMD(push, NVA0B5, SET_SRC_PHYS_MODE,\n\t\t\t\t  NVDEF(NVA0B5, SET_SRC_PHYS_MODE, TARGET, COHERENT_SYSMEM));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlaunch_dma |= NVDEF(NVA0B5, LAUNCH_DMA, SRC_TYPE, PHYSICAL);\n\t}\n\n\tif (dst_aper != NOUVEAU_APER_VIRT) {\n\t\tswitch (dst_aper) {\n\t\tcase NOUVEAU_APER_VRAM:\n\t\t\tPUSH_IMMD(push, NVA0B5, SET_DST_PHYS_MODE,\n\t\t\t\t  NVDEF(NVA0B5, SET_DST_PHYS_MODE, TARGET, LOCAL_FB));\n\t\t\tbreak;\n\t\tcase NOUVEAU_APER_HOST:\n\t\t\tPUSH_IMMD(push, NVA0B5, SET_DST_PHYS_MODE,\n\t\t\t\t  NVDEF(NVA0B5, SET_DST_PHYS_MODE, TARGET, COHERENT_SYSMEM));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlaunch_dma |= NVDEF(NVA0B5, LAUNCH_DMA, DST_TYPE, PHYSICAL);\n\t}\n\n\tPUSH_MTHD(push, NVA0B5, OFFSET_IN_UPPER,\n\t\t  NVVAL(NVA0B5, OFFSET_IN_UPPER, UPPER, upper_32_bits(src_addr)),\n\n\t\t\t\tOFFSET_IN_LOWER, lower_32_bits(src_addr),\n\n\t\t\t\tOFFSET_OUT_UPPER,\n\t\t  NVVAL(NVA0B5, OFFSET_OUT_UPPER, UPPER, upper_32_bits(dst_addr)),\n\n\t\t\t\tOFFSET_OUT_LOWER, lower_32_bits(dst_addr),\n\t\t\t\tPITCH_IN, PAGE_SIZE,\n\t\t\t\tPITCH_OUT, PAGE_SIZE,\n\t\t\t\tLINE_LENGTH_IN, PAGE_SIZE,\n\t\t\t\tLINE_COUNT, npages);\n\n\tPUSH_MTHD(push, NVA0B5, LAUNCH_DMA, launch_dma |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, DATA_TRANSFER_TYPE, NON_PIPELINED) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, FLUSH_ENABLE, TRUE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, SEMAPHORE_TYPE, NONE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, INTERRUPT_TYPE, NONE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, SRC_MEMORY_LAYOUT, PITCH) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, DST_MEMORY_LAYOUT, PITCH) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, MULTI_LINE_ENABLE, TRUE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, REMAP_ENABLE, FALSE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, BYPASS_L2, USE_PTE_SETTING));\n\treturn 0;\n}\n\nstatic int\nnvc0b5_migrate_clear(struct nouveau_drm *drm, u32 length,\n\t\t     enum nouveau_aper dst_aper, u64 dst_addr)\n{\n\tstruct nvif_push *push = drm->dmem->migrate.chan->chan.push;\n\tu32 launch_dma = 0;\n\tint ret;\n\n\tret = PUSH_WAIT(push, 12);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dst_aper) {\n\tcase NOUVEAU_APER_VRAM:\n\t\tPUSH_IMMD(push, NVA0B5, SET_DST_PHYS_MODE,\n\t\t\t  NVDEF(NVA0B5, SET_DST_PHYS_MODE, TARGET, LOCAL_FB));\n\t\tbreak;\n\tcase NOUVEAU_APER_HOST:\n\t\tPUSH_IMMD(push, NVA0B5, SET_DST_PHYS_MODE,\n\t\t\t  NVDEF(NVA0B5, SET_DST_PHYS_MODE, TARGET, COHERENT_SYSMEM));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlaunch_dma |= NVDEF(NVA0B5, LAUNCH_DMA, DST_TYPE, PHYSICAL);\n\n\tPUSH_MTHD(push, NVA0B5, SET_REMAP_CONST_A, 0,\n\t\t\t\tSET_REMAP_CONST_B, 0,\n\n\t\t\t\tSET_REMAP_COMPONENTS,\n\t\t  NVDEF(NVA0B5, SET_REMAP_COMPONENTS, DST_X, CONST_A) |\n\t\t  NVDEF(NVA0B5, SET_REMAP_COMPONENTS, DST_Y, CONST_B) |\n\t\t  NVDEF(NVA0B5, SET_REMAP_COMPONENTS, COMPONENT_SIZE, FOUR) |\n\t\t  NVDEF(NVA0B5, SET_REMAP_COMPONENTS, NUM_DST_COMPONENTS, TWO));\n\n\tPUSH_MTHD(push, NVA0B5, OFFSET_OUT_UPPER,\n\t\t  NVVAL(NVA0B5, OFFSET_OUT_UPPER, UPPER, upper_32_bits(dst_addr)),\n\n\t\t\t\tOFFSET_OUT_LOWER, lower_32_bits(dst_addr));\n\n\tPUSH_MTHD(push, NVA0B5, LINE_LENGTH_IN, length >> 3);\n\n\tPUSH_MTHD(push, NVA0B5, LAUNCH_DMA, launch_dma |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, DATA_TRANSFER_TYPE, NON_PIPELINED) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, FLUSH_ENABLE, TRUE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, SEMAPHORE_TYPE, NONE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, INTERRUPT_TYPE, NONE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, SRC_MEMORY_LAYOUT, PITCH) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, DST_MEMORY_LAYOUT, PITCH) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, MULTI_LINE_ENABLE, FALSE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, REMAP_ENABLE, TRUE) |\n\t\t  NVDEF(NVA0B5, LAUNCH_DMA, BYPASS_L2, USE_PTE_SETTING));\n\treturn 0;\n}\n\nstatic int\nnouveau_dmem_migrate_init(struct nouveau_drm *drm)\n{\n\tswitch (drm->ttm.copy.oclass) {\n\tcase PASCAL_DMA_COPY_A:\n\tcase PASCAL_DMA_COPY_B:\n\tcase  VOLTA_DMA_COPY_A:\n\tcase TURING_DMA_COPY_A:\n\t\tdrm->dmem->migrate.copy_func = nvc0b5_migrate_copy;\n\t\tdrm->dmem->migrate.clear_func = nvc0b5_migrate_clear;\n\t\tdrm->dmem->migrate.chan = drm->ttm.chan;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENODEV;\n}\n\nvoid\nnouveau_dmem_init(struct nouveau_drm *drm)\n{\n\tint ret;\n\n\t \n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_PASCAL)\n\t\treturn;\n\n\tif (!(drm->dmem = kzalloc(sizeof(*drm->dmem), GFP_KERNEL)))\n\t\treturn;\n\n\tdrm->dmem->drm = drm;\n\tmutex_init(&drm->dmem->mutex);\n\tINIT_LIST_HEAD(&drm->dmem->chunks);\n\tmutex_init(&drm->dmem->mutex);\n\tspin_lock_init(&drm->dmem->lock);\n\n\t \n\tret = nouveau_dmem_migrate_init(drm);\n\tif (ret) {\n\t\tkfree(drm->dmem);\n\t\tdrm->dmem = NULL;\n\t}\n}\n\nstatic unsigned long nouveau_dmem_migrate_copy_one(struct nouveau_drm *drm,\n\t\tstruct nouveau_svmm *svmm, unsigned long src,\n\t\tdma_addr_t *dma_addr, u64 *pfn)\n{\n\tstruct device *dev = drm->dev->dev;\n\tstruct page *dpage, *spage;\n\tunsigned long paddr;\n\n\tspage = migrate_pfn_to_page(src);\n\tif (!(src & MIGRATE_PFN_MIGRATE))\n\t\tgoto out;\n\n\tdpage = nouveau_dmem_page_alloc_locked(drm);\n\tif (!dpage)\n\t\tgoto out;\n\n\tpaddr = nouveau_dmem_page_addr(dpage);\n\tif (spage) {\n\t\t*dma_addr = dma_map_page(dev, spage, 0, page_size(spage),\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(dev, *dma_addr))\n\t\t\tgoto out_free_page;\n\t\tif (drm->dmem->migrate.copy_func(drm, 1,\n\t\t\tNOUVEAU_APER_VRAM, paddr, NOUVEAU_APER_HOST, *dma_addr))\n\t\t\tgoto out_dma_unmap;\n\t} else {\n\t\t*dma_addr = DMA_MAPPING_ERROR;\n\t\tif (drm->dmem->migrate.clear_func(drm, page_size(dpage),\n\t\t\tNOUVEAU_APER_VRAM, paddr))\n\t\t\tgoto out_free_page;\n\t}\n\n\tdpage->zone_device_data = svmm;\n\t*pfn = NVIF_VMM_PFNMAP_V0_V | NVIF_VMM_PFNMAP_V0_VRAM |\n\t\t((paddr >> PAGE_SHIFT) << NVIF_VMM_PFNMAP_V0_ADDR_SHIFT);\n\tif (src & MIGRATE_PFN_WRITE)\n\t\t*pfn |= NVIF_VMM_PFNMAP_V0_W;\n\treturn migrate_pfn(page_to_pfn(dpage));\n\nout_dma_unmap:\n\tdma_unmap_page(dev, *dma_addr, PAGE_SIZE, DMA_BIDIRECTIONAL);\nout_free_page:\n\tnouveau_dmem_page_free_locked(drm, dpage);\nout:\n\t*pfn = NVIF_VMM_PFNMAP_V0_NONE;\n\treturn 0;\n}\n\nstatic void nouveau_dmem_migrate_chunk(struct nouveau_drm *drm,\n\t\tstruct nouveau_svmm *svmm, struct migrate_vma *args,\n\t\tdma_addr_t *dma_addrs, u64 *pfns)\n{\n\tstruct nouveau_fence *fence;\n\tunsigned long addr = args->start, nr_dma = 0, i;\n\n\tfor (i = 0; addr < args->end; i++) {\n\t\targs->dst[i] = nouveau_dmem_migrate_copy_one(drm, svmm,\n\t\t\t\targs->src[i], dma_addrs + nr_dma, pfns + i);\n\t\tif (!dma_mapping_error(drm->dev->dev, dma_addrs[nr_dma]))\n\t\t\tnr_dma++;\n\t\taddr += PAGE_SIZE;\n\t}\n\n\tnouveau_fence_new(&fence, drm->dmem->migrate.chan);\n\tmigrate_vma_pages(args);\n\tnouveau_dmem_fence_done(&fence);\n\tnouveau_pfns_map(svmm, args->vma->vm_mm, args->start, pfns, i);\n\n\twhile (nr_dma--) {\n\t\tdma_unmap_page(drm->dev->dev, dma_addrs[nr_dma], PAGE_SIZE,\n\t\t\t\tDMA_BIDIRECTIONAL);\n\t}\n\tmigrate_vma_finalize(args);\n}\n\nint\nnouveau_dmem_migrate_vma(struct nouveau_drm *drm,\n\t\t\t struct nouveau_svmm *svmm,\n\t\t\t struct vm_area_struct *vma,\n\t\t\t unsigned long start,\n\t\t\t unsigned long end)\n{\n\tunsigned long npages = (end - start) >> PAGE_SHIFT;\n\tunsigned long max = min(SG_MAX_SINGLE_ALLOC, npages);\n\tdma_addr_t *dma_addrs;\n\tstruct migrate_vma args = {\n\t\t.vma\t\t= vma,\n\t\t.start\t\t= start,\n\t\t.pgmap_owner\t= drm->dev,\n\t\t.flags\t\t= MIGRATE_VMA_SELECT_SYSTEM,\n\t};\n\tunsigned long i;\n\tu64 *pfns;\n\tint ret = -ENOMEM;\n\n\tif (drm->dmem == NULL)\n\t\treturn -ENODEV;\n\n\targs.src = kcalloc(max, sizeof(*args.src), GFP_KERNEL);\n\tif (!args.src)\n\t\tgoto out;\n\targs.dst = kcalloc(max, sizeof(*args.dst), GFP_KERNEL);\n\tif (!args.dst)\n\t\tgoto out_free_src;\n\n\tdma_addrs = kmalloc_array(max, sizeof(*dma_addrs), GFP_KERNEL);\n\tif (!dma_addrs)\n\t\tgoto out_free_dst;\n\n\tpfns = nouveau_pfns_alloc(max);\n\tif (!pfns)\n\t\tgoto out_free_dma;\n\n\tfor (i = 0; i < npages; i += max) {\n\t\tif (args.start + (max << PAGE_SHIFT) > end)\n\t\t\targs.end = end;\n\t\telse\n\t\t\targs.end = args.start + (max << PAGE_SHIFT);\n\n\t\tret = migrate_vma_setup(&args);\n\t\tif (ret)\n\t\t\tgoto out_free_pfns;\n\n\t\tif (args.cpages)\n\t\t\tnouveau_dmem_migrate_chunk(drm, svmm, &args, dma_addrs,\n\t\t\t\t\t\t   pfns);\n\t\targs.start = args.end;\n\t}\n\n\tret = 0;\nout_free_pfns:\n\tnouveau_pfns_free(pfns);\nout_free_dma:\n\tkfree(dma_addrs);\nout_free_dst:\n\tkfree(args.dst);\nout_free_src:\n\tkfree(args.src);\nout:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}