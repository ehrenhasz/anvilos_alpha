{
  "module_name": "nouveau_chan.c",
  "hash_id": "ae4cd2c4bdf0752245e7865cf42b2ac03c067718d9b9ff3ccb1abb2085589aa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_chan.c",
  "human_readable_source": " \n#include <nvif/push006c.h>\n\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n#include <nvif/if0020.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_bo.h\"\n#include \"nouveau_chan.h\"\n#include \"nouveau_fence.h\"\n#include \"nouveau_abi16.h\"\n#include \"nouveau_vmm.h\"\n#include \"nouveau_svm.h\"\n\nMODULE_PARM_DESC(vram_pushbuf, \"Create DMA push buffers in VRAM\");\nint nouveau_vram_pushbuf;\nmodule_param_named(vram_pushbuf, nouveau_vram_pushbuf, int, 0400);\n\nvoid\nnouveau_channel_kill(struct nouveau_channel *chan)\n{\n\tatomic_set(&chan->killed, 1);\n\tif (chan->fence)\n\t\tnouveau_fence_context_kill(chan->fence, -ENODEV);\n}\n\nstatic int\nnouveau_channel_killed(struct nvif_event *event, void *repv, u32 repc)\n{\n\tstruct nouveau_channel *chan = container_of(event, typeof(*chan), kill);\n\tstruct nouveau_cli *cli = (void *)chan->user.client;\n\n\tNV_PRINTK(warn, cli, \"channel %d killed!\\n\", chan->chid);\n\n\tif (unlikely(!atomic_read(&chan->killed)))\n\t\tnouveau_channel_kill(chan);\n\n\treturn NVIF_EVENT_DROP;\n}\n\nint\nnouveau_channel_idle(struct nouveau_channel *chan)\n{\n\tif (likely(chan && chan->fence && !atomic_read(&chan->killed))) {\n\t\tstruct nouveau_cli *cli = (void *)chan->user.client;\n\t\tstruct nouveau_fence *fence = NULL;\n\t\tint ret;\n\n\t\tret = nouveau_fence_new(&fence, chan);\n\t\tif (!ret) {\n\t\t\tret = nouveau_fence_wait(fence, false, false);\n\t\t\tnouveau_fence_unref(&fence);\n\t\t}\n\n\t\tif (ret) {\n\t\t\tNV_PRINTK(err, cli, \"failed to idle channel %d [%s]\\n\",\n\t\t\t\t  chan->chid, nvxx_client(&cli->base)->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid\nnouveau_channel_del(struct nouveau_channel **pchan)\n{\n\tstruct nouveau_channel *chan = *pchan;\n\tif (chan) {\n\t\tstruct nouveau_cli *cli = (void *)chan->user.client;\n\n\t\tif (chan->fence)\n\t\t\tnouveau_fence(chan->drm)->context_del(chan);\n\n\t\tif (cli)\n\t\t\tnouveau_svmm_part(chan->vmm->svmm, chan->inst);\n\n\t\tnvif_object_dtor(&chan->blit);\n\t\tnvif_object_dtor(&chan->nvsw);\n\t\tnvif_object_dtor(&chan->gart);\n\t\tnvif_object_dtor(&chan->vram);\n\t\tnvif_event_dtor(&chan->kill);\n\t\tnvif_object_dtor(&chan->user);\n\t\tnvif_mem_dtor(&chan->mem_userd);\n\t\tnvif_object_dtor(&chan->push.ctxdma);\n\t\tnouveau_vma_del(&chan->push.vma);\n\t\tnouveau_bo_unmap(chan->push.buffer);\n\t\tif (chan->push.buffer && chan->push.buffer->bo.pin_count)\n\t\t\tnouveau_bo_unpin(chan->push.buffer);\n\t\tnouveau_bo_ref(NULL, &chan->push.buffer);\n\t\tkfree(chan);\n\t}\n\t*pchan = NULL;\n}\n\nstatic void\nnouveau_channel_kick(struct nvif_push *push)\n{\n\tstruct nouveau_channel *chan = container_of(push, typeof(*chan), chan._push);\n\tchan->dma.cur = chan->dma.cur + (chan->chan._push.cur - chan->chan._push.bgn);\n\tFIRE_RING(chan);\n\tchan->chan._push.bgn = chan->chan._push.cur;\n}\n\nstatic int\nnouveau_channel_wait(struct nvif_push *push, u32 size)\n{\n\tstruct nouveau_channel *chan = container_of(push, typeof(*chan), chan._push);\n\tint ret;\n\tchan->dma.cur = chan->dma.cur + (chan->chan._push.cur - chan->chan._push.bgn);\n\tret = RING_SPACE(chan, size);\n\tif (ret == 0) {\n\t\tchan->chan._push.bgn = chan->chan._push.mem.object.map.ptr;\n\t\tchan->chan._push.bgn = chan->chan._push.bgn + chan->dma.cur;\n\t\tchan->chan._push.cur = chan->chan._push.bgn;\n\t\tchan->chan._push.end = chan->chan._push.bgn + size;\n\t}\n\treturn ret;\n}\n\nstatic int\nnouveau_channel_prep(struct nouveau_drm *drm, struct nvif_device *device,\n\t\t     u32 size, struct nouveau_channel **pchan)\n{\n\tstruct nouveau_cli *cli = (void *)device->object.client;\n\tstruct nv_dma_v0 args = {};\n\tstruct nouveau_channel *chan;\n\tu32 target;\n\tint ret;\n\n\tchan = *pchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn -ENOMEM;\n\n\tchan->device = device;\n\tchan->drm = drm;\n\tchan->vmm = nouveau_cli_vmm(cli);\n\tatomic_set(&chan->killed, 0);\n\n\t \n\ttarget = NOUVEAU_GEM_DOMAIN_GART | NOUVEAU_GEM_DOMAIN_COHERENT;\n\tif (nouveau_vram_pushbuf)\n\t\ttarget = NOUVEAU_GEM_DOMAIN_VRAM;\n\n\tret = nouveau_bo_new(cli, size, 0, target, 0, 0, NULL, NULL,\n\t\t\t    &chan->push.buffer);\n\tif (ret == 0) {\n\t\tret = nouveau_bo_pin(chan->push.buffer, target, false);\n\t\tif (ret == 0)\n\t\t\tret = nouveau_bo_map(chan->push.buffer);\n\t}\n\n\tif (ret) {\n\t\tnouveau_channel_del(pchan);\n\t\treturn ret;\n\t}\n\n\tchan->chan._push.mem.object.parent = cli->base.object.parent;\n\tchan->chan._push.mem.object.client = &cli->base;\n\tchan->chan._push.mem.object.name = \"chanPush\";\n\tchan->chan._push.mem.object.map.ptr = chan->push.buffer->kmap.virtual;\n\tchan->chan._push.wait = nouveau_channel_wait;\n\tchan->chan._push.kick = nouveau_channel_kick;\n\tchan->chan.push = &chan->chan._push;\n\n\t \n\tchan->push.addr = chan->push.buffer->offset;\n\n\tif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\n\t\tret = nouveau_vma_new(chan->push.buffer, chan->vmm,\n\t\t\t\t      &chan->push.vma);\n\t\tif (ret) {\n\t\t\tnouveau_channel_del(pchan);\n\t\t\treturn ret;\n\t\t}\n\n\t\tchan->push.addr = chan->push.vma->addr;\n\n\t\tif (device->info.family >= NV_DEVICE_INFO_V0_FERMI)\n\t\t\treturn 0;\n\n\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\targs.access = NV_DMA_V0_ACCESS_VM;\n\t\targs.start = 0;\n\t\targs.limit = chan->vmm->vmm.limit - 1;\n\t} else\n\tif (chan->push.buffer->bo.resource->mem_type == TTM_PL_VRAM) {\n\t\tif (device->info.family == NV_DEVICE_INFO_V0_TNT) {\n\t\t\t \n\t\t\targs.target = NV_DMA_V0_TARGET_PCI;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = nvxx_device(device)->func->\n\t\t\t\tresource_addr(nvxx_device(device), 1);\n\t\t\targs.limit = args.start + device->info.ram_user - 1;\n\t\t} else {\n\t\t\targs.target = NV_DMA_V0_TARGET_VRAM;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = 0;\n\t\t\targs.limit = device->info.ram_user - 1;\n\t\t}\n\t} else {\n\t\tif (chan->drm->agp.bridge) {\n\t\t\targs.target = NV_DMA_V0_TARGET_AGP;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = chan->drm->agp.base;\n\t\t\targs.limit = chan->drm->agp.base +\n\t\t\t\t     chan->drm->agp.size - 1;\n\t\t} else {\n\t\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = 0;\n\t\t\targs.limit = chan->vmm->vmm.limit - 1;\n\t\t}\n\t}\n\n\tret = nvif_object_ctor(&device->object, \"abi16PushCtxDma\", 0,\n\t\t\t       NV_DMA_FROM_MEMORY, &args, sizeof(args),\n\t\t\t       &chan->push.ctxdma);\n\tif (ret) {\n\t\tnouveau_channel_del(pchan);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_channel_ctor(struct nouveau_drm *drm, struct nvif_device *device, bool priv, u64 runm,\n\t\t     struct nouveau_channel **pchan)\n{\n\tconst struct nvif_mclass hosts[] = {\n\t\t{  AMPERE_CHANNEL_GPFIFO_B, 0 },\n\t\t{  AMPERE_CHANNEL_GPFIFO_A, 0 },\n\t\t{  TURING_CHANNEL_GPFIFO_A, 0 },\n\t\t{   VOLTA_CHANNEL_GPFIFO_A, 0 },\n\t\t{  PASCAL_CHANNEL_GPFIFO_A, 0 },\n\t\t{ MAXWELL_CHANNEL_GPFIFO_A, 0 },\n\t\t{  KEPLER_CHANNEL_GPFIFO_B, 0 },\n\t\t{  KEPLER_CHANNEL_GPFIFO_A, 0 },\n\t\t{   FERMI_CHANNEL_GPFIFO  , 0 },\n\t\t{     G82_CHANNEL_GPFIFO  , 0 },\n\t\t{    NV50_CHANNEL_GPFIFO  , 0 },\n\t\t{    NV40_CHANNEL_DMA     , 0 },\n\t\t{    NV17_CHANNEL_DMA     , 0 },\n\t\t{    NV10_CHANNEL_DMA     , 0 },\n\t\t{    NV03_CHANNEL_DMA     , 0 },\n\t\t{}\n\t};\n\tstruct {\n\t\tstruct nvif_chan_v0 chan;\n\t\tchar name[TASK_COMM_LEN+16];\n\t} args;\n\tstruct nouveau_cli *cli = (void *)device->object.client;\n\tstruct nouveau_channel *chan;\n\tconst u64 plength = 0x10000;\n\tconst u64 ioffset = plength;\n\tconst u64 ilength = 0x02000;\n\tchar name[TASK_COMM_LEN];\n\tint cid, ret;\n\tu64 size;\n\n\tcid = nvif_mclass(&device->object, hosts);\n\tif (cid < 0)\n\t\treturn cid;\n\n\tif (hosts[cid].oclass < NV50_CHANNEL_GPFIFO)\n\t\tsize = plength;\n\telse\n\t\tsize = ioffset + ilength;\n\n\t \n\tret = nouveau_channel_prep(drm, device, size, &chan);\n\t*pchan = chan;\n\tif (ret)\n\t\treturn ret;\n\n\t \n\targs.chan.version = 0;\n\targs.chan.namelen = sizeof(args.name);\n\targs.chan.runlist = __ffs64(runm);\n\targs.chan.runq = 0;\n\targs.chan.priv = priv;\n\targs.chan.devm = BIT(0);\n\tif (hosts[cid].oclass < NV50_CHANNEL_GPFIFO) {\n\t\targs.chan.vmm = 0;\n\t\targs.chan.ctxdma = nvif_handle(&chan->push.ctxdma);\n\t\targs.chan.offset = chan->push.addr;\n\t\targs.chan.length = 0;\n\t} else {\n\t\targs.chan.vmm = nvif_handle(&chan->vmm->vmm.object);\n\t\tif (hosts[cid].oclass < FERMI_CHANNEL_GPFIFO)\n\t\t\targs.chan.ctxdma = nvif_handle(&chan->push.ctxdma);\n\t\telse\n\t\t\targs.chan.ctxdma = 0;\n\t\targs.chan.offset = ioffset + chan->push.addr;\n\t\targs.chan.length = ilength;\n\t}\n\targs.chan.huserd = 0;\n\targs.chan.ouserd = 0;\n\n\t \n\tif (hosts[cid].oclass >= VOLTA_CHANNEL_GPFIFO_A) {\n\t\tret = nvif_mem_ctor(&cli->mmu, \"abi16ChanUSERD\", NVIF_CLASS_MEM_GF100,\n\t\t\t\t    NVIF_MEM_VRAM | NVIF_MEM_COHERENT | NVIF_MEM_MAPPABLE,\n\t\t\t\t    0, PAGE_SIZE, NULL, 0, &chan->mem_userd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\targs.chan.huserd = nvif_handle(&chan->mem_userd.object);\n\t\targs.chan.ouserd = 0;\n\n\t\tchan->userd = &chan->mem_userd.object;\n\t} else {\n\t\tchan->userd = &chan->user;\n\t}\n\n\tget_task_comm(name, current);\n\tsnprintf(args.name, sizeof(args.name), \"%s[%d]\", name, task_pid_nr(current));\n\n\tret = nvif_object_ctor(&device->object, \"abi16ChanUser\", 0, hosts[cid].oclass,\n\t\t\t       &args, sizeof(args), &chan->user);\n\tif (ret) {\n\t\tnouveau_channel_del(pchan);\n\t\treturn ret;\n\t}\n\n\tchan->runlist = args.chan.runlist;\n\tchan->chid = args.chan.chid;\n\tchan->inst = args.chan.inst;\n\tchan->token = args.chan.token;\n\treturn 0;\n}\n\nstatic int\nnouveau_channel_init(struct nouveau_channel *chan, u32 vram, u32 gart)\n{\n\tstruct nvif_device *device = chan->device;\n\tstruct nouveau_drm *drm = chan->drm;\n\tstruct nv_dma_v0 args = {};\n\tint ret, i;\n\n\tret = nvif_object_map(chan->userd, NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chan->user.oclass >= FERMI_CHANNEL_GPFIFO) {\n\t\tstruct {\n\t\t\tstruct nvif_event_v0 base;\n\t\t\tstruct nvif_chan_event_v0 host;\n\t\t} args;\n\n\t\targs.host.version = 0;\n\t\targs.host.type = NVIF_CHAN_EVENT_V0_KILLED;\n\n\t\tret = nvif_event_ctor(&chan->user, \"abi16ChanKilled\", chan->chid,\n\t\t\t\t      nouveau_channel_killed, false,\n\t\t\t\t      &args.base, sizeof(args), &chan->kill);\n\t\tif (ret == 0)\n\t\t\tret = nvif_event_allow(&chan->kill);\n\t\tif (ret) {\n\t\t\tNV_ERROR(drm, \"Failed to request channel kill \"\n\t\t\t\t      \"notification: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (device->info.family < NV_DEVICE_INFO_V0_FERMI) {\n\t\tif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\n\t\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\t\targs.access = NV_DMA_V0_ACCESS_VM;\n\t\t\targs.start = 0;\n\t\t\targs.limit = chan->vmm->vmm.limit - 1;\n\t\t} else {\n\t\t\targs.target = NV_DMA_V0_TARGET_VRAM;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = 0;\n\t\t\targs.limit = device->info.ram_user - 1;\n\t\t}\n\n\t\tret = nvif_object_ctor(&chan->user, \"abi16ChanVramCtxDma\", vram,\n\t\t\t\t       NV_DMA_IN_MEMORY, &args, sizeof(args),\n\t\t\t\t       &chan->vram);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\n\t\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\t\targs.access = NV_DMA_V0_ACCESS_VM;\n\t\t\targs.start = 0;\n\t\t\targs.limit = chan->vmm->vmm.limit - 1;\n\t\t} else\n\t\tif (chan->drm->agp.bridge) {\n\t\t\targs.target = NV_DMA_V0_TARGET_AGP;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = chan->drm->agp.base;\n\t\t\targs.limit = chan->drm->agp.base +\n\t\t\t\t     chan->drm->agp.size - 1;\n\t\t} else {\n\t\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\t\targs.start = 0;\n\t\t\targs.limit = chan->vmm->vmm.limit - 1;\n\t\t}\n\n\t\tret = nvif_object_ctor(&chan->user, \"abi16ChanGartCtxDma\", gart,\n\t\t\t\t       NV_DMA_IN_MEMORY, &args, sizeof(args),\n\t\t\t\t       &chan->gart);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tswitch (chan->user.oclass) {\n\tcase NV03_CHANNEL_DMA:\n\tcase NV10_CHANNEL_DMA:\n\tcase NV17_CHANNEL_DMA:\n\tcase NV40_CHANNEL_DMA:\n\t\tchan->user_put = 0x40;\n\t\tchan->user_get = 0x44;\n\t\tchan->dma.max = (0x10000 / 4) - 2;\n\t\tbreak;\n\tdefault:\n\t\tchan->user_put = 0x40;\n\t\tchan->user_get = 0x44;\n\t\tchan->user_get_hi = 0x60;\n\t\tchan->dma.ib_base =  0x10000 / 4;\n\t\tchan->dma.ib_max  = NV50_DMA_IB_MAX;\n\t\tchan->dma.ib_put  = 0;\n\t\tchan->dma.ib_free = chan->dma.ib_max - chan->dma.ib_put;\n\t\tchan->dma.max = chan->dma.ib_base;\n\t\tbreak;\n\t}\n\n\tchan->dma.put = 0;\n\tchan->dma.cur = chan->dma.put;\n\tchan->dma.free = chan->dma.max - chan->dma.cur;\n\n\tret = PUSH_WAIT(chan->chan.push, NOUVEAU_DMA_SKIPS);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < NOUVEAU_DMA_SKIPS; i++)\n\t\tPUSH_DATA(chan->chan.push, 0x00000000);\n\n\t \n\tif (device->info.family < NV_DEVICE_INFO_V0_CELSIUS) {\n\t\tret = nvif_object_ctor(&chan->user, \"abi16NvswFence\", 0x006e,\n\t\t\t\t       NVIF_CLASS_SW_NV04,\n\t\t\t\t       NULL, 0, &chan->nvsw);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = PUSH_WAIT(chan->chan.push, 2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tPUSH_NVSQ(chan->chan.push, NV_SW, 0x0000, chan->nvsw.handle);\n\t\tPUSH_KICK(chan->chan.push);\n\t}\n\n\t \n\treturn nouveau_fence(chan->drm)->context_new(chan);\n}\n\nint\nnouveau_channel_new(struct nouveau_drm *drm, struct nvif_device *device,\n\t\t    bool priv, u64 runm, u32 vram, u32 gart, struct nouveau_channel **pchan)\n{\n\tstruct nouveau_cli *cli = (void *)device->object.client;\n\tint ret;\n\n\tret = nouveau_channel_ctor(drm, device, priv, runm, pchan);\n\tif (ret) {\n\t\tNV_PRINTK(dbg, cli, \"channel create, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = nouveau_channel_init(*pchan, vram, gart);\n\tif (ret) {\n\t\tNV_PRINTK(err, cli, \"channel failed to initialise, %d\\n\", ret);\n\t\tnouveau_channel_del(pchan);\n\t\treturn ret;\n\t}\n\n\tret = nouveau_svmm_join((*pchan)->vmm->svmm, (*pchan)->inst);\n\tif (ret)\n\t\tnouveau_channel_del(pchan);\n\n\treturn ret;\n}\n\nvoid\nnouveau_channels_fini(struct nouveau_drm *drm)\n{\n\tkfree(drm->runl);\n}\n\nint\nnouveau_channels_init(struct nouveau_drm *drm)\n{\n\tstruct {\n\t\tstruct nv_device_info_v1 m;\n\t\tstruct {\n\t\t\tstruct nv_device_info_v1_data channels;\n\t\t\tstruct nv_device_info_v1_data runlists;\n\t\t} v;\n\t} args = {\n\t\t.m.version = 1,\n\t\t.m.count = sizeof(args.v) / sizeof(args.v.channels),\n\t\t.v.channels.mthd = NV_DEVICE_HOST_CHANNELS,\n\t\t.v.runlists.mthd = NV_DEVICE_HOST_RUNLISTS,\n\t};\n\tstruct nvif_object *device = &drm->client.device.object;\n\tint ret, i;\n\n\tret = nvif_object_mthd(device, NV_DEVICE_V0_INFO, &args, sizeof(args));\n\tif (ret ||\n\t    args.v.runlists.mthd == NV_DEVICE_INFO_INVALID || !args.v.runlists.data ||\n\t    args.v.channels.mthd == NV_DEVICE_INFO_INVALID)\n\t\treturn -ENODEV;\n\n\tdrm->chan_nr = drm->chan_total = args.v.channels.data;\n\tdrm->runl_nr = fls64(args.v.runlists.data);\n\tdrm->runl = kcalloc(drm->runl_nr, sizeof(*drm->runl), GFP_KERNEL);\n\tif (!drm->runl)\n\t\treturn -ENOMEM;\n\n\tif (drm->chan_nr == 0) {\n\t\tfor (i = 0; i < drm->runl_nr; i++) {\n\t\t\tif (!(args.v.runlists.data & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\targs.v.channels.mthd = NV_DEVICE_HOST_RUNLIST_CHANNELS;\n\t\t\targs.v.channels.data = i;\n\n\t\t\tret = nvif_object_mthd(device, NV_DEVICE_V0_INFO, &args, sizeof(args));\n\t\t\tif (ret || args.v.channels.mthd == NV_DEVICE_INFO_INVALID)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tdrm->runl[i].chan_nr = args.v.channels.data;\n\t\t\tdrm->runl[i].chan_id_base = drm->chan_total;\n\t\t\tdrm->runl[i].context_base = dma_fence_context_alloc(drm->runl[i].chan_nr);\n\n\t\t\tdrm->chan_total += drm->runl[i].chan_nr;\n\t\t}\n\t} else {\n\t\tdrm->runl[0].context_base = dma_fence_context_alloc(drm->chan_nr);\n\t\tfor (i = 1; i < drm->runl_nr; i++)\n\t\t\tdrm->runl[i].context_base = drm->runl[0].context_base;\n\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}