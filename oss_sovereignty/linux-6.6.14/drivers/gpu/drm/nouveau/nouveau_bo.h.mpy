{
  "module_name": "nouveau_bo.h",
  "hash_id": "da21921030b21667010778409c11463e037081150126a49dabf0059b049d7b5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_bo.h",
  "human_readable_source": " \n#ifndef __NOUVEAU_BO_H__\n#define __NOUVEAU_BO_H__\n#include <drm/drm_gem.h>\n#include <drm/ttm/ttm_bo.h>\n#include <drm/ttm/ttm_placement.h>\n\nstruct nouveau_channel;\nstruct nouveau_cli;\nstruct nouveau_drm;\nstruct nouveau_fence;\n\nstruct nouveau_bo {\n\tstruct ttm_buffer_object bo;\n\tstruct ttm_placement placement;\n\tu32 valid_domains;\n\tstruct ttm_place placements[3];\n\tstruct ttm_place busy_placements[3];\n\tbool force_coherent;\n\tstruct ttm_bo_kmap_obj kmap;\n\tstruct list_head head;\n\tstruct list_head io_reserve_lru;\n\n\t \n\tstruct drm_file *reserved_by;\n\tstruct list_head entry;\n\tint pbbo_index;\n\tbool validate_mapped;\n\tbool no_share;\n\n\t \n\tuint64_t offset;\n\n\tstruct list_head vma_list;\n\n\tunsigned contig:1;\n\tunsigned page:5;\n\tunsigned kind:8;\n\tunsigned comp:3;\n\tunsigned zeta:3;\n\tunsigned mode;\n\n\tstruct nouveau_drm_tile *tile;\n};\n\nstatic inline struct nouveau_bo *\nnouveau_bo(struct ttm_buffer_object *bo)\n{\n\treturn container_of(bo, struct nouveau_bo, bo);\n}\n\nstatic inline int\nnouveau_bo_ref(struct nouveau_bo *ref, struct nouveau_bo **pnvbo)\n{\n\tstruct nouveau_bo *prev;\n\n\tif (!pnvbo)\n\t\treturn -EINVAL;\n\tprev = *pnvbo;\n\n\tif (ref) {\n\t\tttm_bo_get(&ref->bo);\n\t\t*pnvbo = nouveau_bo(&ref->bo);\n\t} else {\n\t\t*pnvbo = NULL;\n\t}\n\tif (prev)\n\t\tttm_bo_put(&prev->bo);\n\n\treturn 0;\n}\n\nextern struct ttm_device_funcs nouveau_bo_driver;\n\nvoid nouveau_bo_move_init(struct nouveau_drm *);\nstruct nouveau_bo *nouveau_bo_alloc(struct nouveau_cli *, u64 *size, int *align,\n\t\t\t\t    u32 domain, u32 tile_mode, u32 tile_flags, bool internal);\nint  nouveau_bo_init(struct nouveau_bo *, u64 size, int align, u32 domain,\n\t\t     struct sg_table *sg, struct dma_resv *robj);\nint  nouveau_bo_new(struct nouveau_cli *, u64 size, int align, u32 domain,\n\t\t    u32 tile_mode, u32 tile_flags, struct sg_table *sg,\n\t\t    struct dma_resv *robj,\n\t\t    struct nouveau_bo **);\nint  nouveau_bo_pin(struct nouveau_bo *, u32 flags, bool contig);\nint  nouveau_bo_unpin(struct nouveau_bo *);\nint  nouveau_bo_map(struct nouveau_bo *);\nvoid nouveau_bo_unmap(struct nouveau_bo *);\nvoid nouveau_bo_placement_set(struct nouveau_bo *, u32 type, u32 busy);\nvoid nouveau_bo_wr16(struct nouveau_bo *, unsigned index, u16 val);\nu32  nouveau_bo_rd32(struct nouveau_bo *, unsigned index);\nvoid nouveau_bo_wr32(struct nouveau_bo *, unsigned index, u32 val);\nvm_fault_t nouveau_ttm_fault_reserve_notify(struct ttm_buffer_object *bo);\nvoid nouveau_bo_fence(struct nouveau_bo *, struct nouveau_fence *, bool exclusive);\nint  nouveau_bo_validate(struct nouveau_bo *, bool interruptible,\n\t\t\t bool no_wait_gpu);\nvoid nouveau_bo_sync_for_device(struct nouveau_bo *nvbo);\nvoid nouveau_bo_sync_for_cpu(struct nouveau_bo *nvbo);\nvoid nouveau_bo_add_io_reserve_lru(struct ttm_buffer_object *bo);\nvoid nouveau_bo_del_io_reserve_lru(struct ttm_buffer_object *bo);\n\n \nstatic inline void __iomem *\nnvbo_kmap_obj_iovirtual(struct nouveau_bo *nvbo)\n{\n\tbool is_iomem;\n\tvoid __iomem *ioptr = (void __force __iomem *)ttm_kmap_obj_virtual(\n\t\t\t\t\t\t&nvbo->kmap, &is_iomem);\n\tWARN_ON_ONCE(ioptr && !is_iomem);\n\treturn ioptr;\n}\n\nstatic inline void\nnouveau_bo_unmap_unpin_unref(struct nouveau_bo **pnvbo)\n{\n\tif (*pnvbo) {\n\t\tnouveau_bo_unmap(*pnvbo);\n\t\tnouveau_bo_unpin(*pnvbo);\n\t\tnouveau_bo_ref(NULL, pnvbo);\n\t}\n}\n\nstatic inline int\nnouveau_bo_new_pin_map(struct nouveau_cli *cli, u64 size, int align, u32 domain,\n\t\t       struct nouveau_bo **pnvbo)\n{\n\tint ret = nouveau_bo_new(cli, size, align, domain,\n\t\t\t\t 0, 0, NULL, NULL, pnvbo);\n\tif (ret == 0) {\n\t\tret = nouveau_bo_pin(*pnvbo, domain, true);\n\t\tif (ret == 0) {\n\t\t\tret = nouveau_bo_map(*pnvbo);\n\t\t\tif (ret == 0)\n\t\t\t\treturn ret;\n\t\t\tnouveau_bo_unpin(*pnvbo);\n\t\t}\n\t\tnouveau_bo_ref(NULL, pnvbo);\n\t}\n\treturn ret;\n}\n\nint nv04_bo_move_init(struct nouveau_channel *, u32);\nint nv04_bo_move_m2mf(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\nint nv50_bo_move_init(struct nouveau_channel *, u32);\nint nv50_bo_move_m2mf(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\nint nv84_bo_move_exec(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\nint nva3_bo_move_copy(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\nint nvc0_bo_move_init(struct nouveau_channel *, u32);\nint nvc0_bo_move_m2mf(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\nint nvc0_bo_move_copy(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\nint nve0_bo_move_init(struct nouveau_channel *, u32);\nint nve0_bo_move_copy(struct nouveau_channel *, struct ttm_buffer_object *,\n\t\t      struct ttm_resource *, struct ttm_resource *);\n\n#define NVBO_WR32_(b,o,dr,f) nouveau_bo_wr32((b), (o)/4 + (dr), (f))\n#define NVBO_RD32_(b,o,dr)   nouveau_bo_rd32((b), (o)/4 + (dr))\n#define NVBO_RD32(A...) DRF_RD(NVBO_RD32_,                  ##A)\n#define NVBO_RV32(A...) DRF_RV(NVBO_RD32_,                  ##A)\n#define NVBO_TV32(A...) DRF_TV(NVBO_RD32_,                  ##A)\n#define NVBO_TD32(A...) DRF_TD(NVBO_RD32_,                  ##A)\n#define NVBO_WR32(A...) DRF_WR(            NVBO_WR32_,      ##A)\n#define NVBO_WV32(A...) DRF_WV(            NVBO_WR32_,      ##A)\n#define NVBO_WD32(A...) DRF_WD(            NVBO_WR32_,      ##A)\n#define NVBO_MR32(A...) DRF_MR(NVBO_RD32_, NVBO_WR32_, u32, ##A)\n#define NVBO_MV32(A...) DRF_MV(NVBO_RD32_, NVBO_WR32_, u32, ##A)\n#define NVBO_MD32(A...) DRF_MD(NVBO_RD32_, NVBO_WR32_, u32, ##A)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}