{
  "module_name": "nouveau_encoder.h",
  "hash_id": "04a497c468bab91114827be5e26b828e4802c13e5b871796fca8eacab52b7d72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_encoder.h",
  "human_readable_source": " \n\n#ifndef __NOUVEAU_ENCODER_H__\n#define __NOUVEAU_ENCODER_H__\n#include <nvif/outp.h>\n#include <subdev/bios/dcb.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/drm_encoder_slave.h>\n\n#include \"dispnv04/disp.h\"\n\nstruct nv50_head_atom;\nstruct nouveau_connector;\n\n#define NV_DPMS_CLEARED 0x80\n\nstruct nvkm_i2c_port;\n\nstruct nouveau_encoder {\n\tstruct drm_encoder_slave base;\n\n\tstruct dcb_output *dcb;\n\tstruct nvif_outp outp;\n\tint or;\n\n\tstruct i2c_adapter *i2c;\n\tstruct nvkm_i2c_aux *aux;\n\n\t \n\tstruct drm_crtc *crtc;\n\tu32 ctrl;\n\n\t \n\tstruct {\n\t\tbool enabled;\n\t\tstruct drm_connector *connector;\n\t} audio;\n\n\tstruct drm_display_mode mode;\n\tint last_dpms;\n\n\tstruct nv04_output_reg restore;\n\n\tunion {\n\t\tstruct {\n\t\t\tstruct nv50_mstm *mstm;\n\t\t\tint link_nr;\n\t\t\tint link_bw;\n\n\t\t\t \n\t\t\tstruct mutex hpd_irq_lock;\n\n\t\t\tu8 dpcd[DP_RECEIVER_CAP_SIZE];\n\t\t\tu8 downstream_ports[DP_MAX_DOWNSTREAM_PORTS];\n\t\t\tstruct drm_dp_desc desc;\n\n\t\t\tu8 sink_count;\n\t\t} dp;\n\t};\n\n\tstruct {\n\t\tbool dp_interlace : 1;\n\t} caps;\n\n\tvoid (*enc_save)(struct drm_encoder *encoder);\n\tvoid (*enc_restore)(struct drm_encoder *encoder);\n\tvoid (*update)(struct nouveau_encoder *, u8 head,\n\t\t       struct nv50_head_atom *, u8 proto, u8 depth);\n};\n\nstruct nv50_mstm {\n\tstruct nouveau_encoder *outp;\n\n\tstruct drm_dp_mst_topology_mgr mgr;\n\n\t \n\tbool can_mst;\n\tbool is_mst;\n\tbool suspended;\n\n\tbool modified;\n\tbool disabled;\n\tint links;\n};\n\nstruct nouveau_encoder *\nfind_encoder(struct drm_connector *connector, int type);\n\nstatic inline struct nouveau_encoder *nouveau_encoder(struct drm_encoder *enc)\n{\n\tstruct drm_encoder_slave *slave = to_encoder_slave(enc);\n\n\treturn container_of(slave, struct nouveau_encoder, base);\n}\n\nstatic inline struct drm_encoder *to_drm_encoder(struct nouveau_encoder *enc)\n{\n\treturn &enc->base.base;\n}\n\nstatic inline const struct drm_encoder_slave_funcs *\nget_slave_funcs(struct drm_encoder *enc)\n{\n\treturn to_encoder_slave(enc)->slave_funcs;\n}\n\n \nenum nouveau_dp_status {\n\tNOUVEAU_DP_NONE,\n\tNOUVEAU_DP_SST,\n\tNOUVEAU_DP_MST,\n};\n\nint nouveau_dp_detect(struct nouveau_connector *, struct nouveau_encoder *);\nbool nouveau_dp_link_check(struct nouveau_connector *);\nvoid nouveau_dp_irq(struct work_struct *);\nenum drm_mode_status nv50_dp_mode_valid(struct nouveau_encoder *,\n\t\t\t\t\tconst struct drm_display_mode *,\n\t\t\t\t\tunsigned *clock);\n\nstruct nouveau_connector *\nnv50_outp_get_new_connector(struct drm_atomic_state *state, struct nouveau_encoder *outp);\nstruct nouveau_connector *\nnv50_outp_get_old_connector(struct drm_atomic_state *state, struct nouveau_encoder *outp);\n\nint nv50_mstm_detect(struct nouveau_encoder *encoder);\nvoid nv50_mstm_remove(struct nv50_mstm *mstm);\nbool nv50_mstm_service(struct nouveau_drm *drm,\n\t\t       struct nouveau_connector *nv_connector,\n\t\t       struct nv50_mstm *mstm);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}