{
  "module_name": "nv84_fence.c",
  "hash_id": "001d07e4022f9dde9778a650a47b7c97c85d3cb93716465559f0712a3a8e44d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nv84_fence.c",
  "human_readable_source": " \n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_fence.h\"\n#include \"nouveau_vmm.h\"\n\n#include \"nv50_display.h\"\n\n#include <nvif/push206e.h>\n\n#include <nvhw/class/cl826f.h>\n\nstatic int\nnv84_fence_emit32(struct nouveau_channel *chan, u64 virtual, u32 sequence)\n{\n\tstruct nvif_push *push = chan->chan.push;\n\tint ret = PUSH_WAIT(push, 8);\n\tif (ret == 0) {\n\t\tPUSH_MTHD(push, NV826F, SET_CONTEXT_DMA_SEMAPHORE, chan->vram.handle);\n\n\t\tPUSH_MTHD(push, NV826F, SEMAPHOREA,\n\t\t\t  NVVAL(NV826F, SEMAPHOREA, OFFSET_UPPER, upper_32_bits(virtual)),\n\n\t\t\t\t\tSEMAPHOREB, lower_32_bits(virtual),\n\t\t\t\t\tSEMAPHOREC, sequence,\n\n\t\t\t\t\tSEMAPHORED,\n\t\t\t  NVDEF(NV826F, SEMAPHORED, OPERATION, RELEASE),\n\n\t\t\t\t\tNON_STALLED_INTERRUPT, 0);\n\t\tPUSH_KICK(push);\n\t}\n\treturn ret;\n}\n\nstatic int\nnv84_fence_sync32(struct nouveau_channel *chan, u64 virtual, u32 sequence)\n{\n\tstruct nvif_push *push = chan->chan.push;\n\tint ret = PUSH_WAIT(push, 7);\n\tif (ret == 0) {\n\t\tPUSH_MTHD(push, NV826F, SET_CONTEXT_DMA_SEMAPHORE, chan->vram.handle);\n\n\t\tPUSH_MTHD(push, NV826F, SEMAPHOREA,\n\t\t\t  NVVAL(NV826F, SEMAPHOREA, OFFSET_UPPER, upper_32_bits(virtual)),\n\n\t\t\t\t\tSEMAPHOREB, lower_32_bits(virtual),\n\t\t\t\t\tSEMAPHOREC, sequence,\n\n\t\t\t\t\tSEMAPHORED,\n\t\t\t  NVDEF(NV826F, SEMAPHORED, OPERATION, ACQ_GEQ));\n\t\tPUSH_KICK(push);\n\t}\n\treturn ret;\n}\n\nstatic inline u32\nnv84_fence_chid(struct nouveau_channel *chan)\n{\n\treturn chan->drm->runl[chan->runlist].chan_id_base + chan->chid;\n}\n\nstatic int\nnv84_fence_emit(struct nouveau_fence *fence)\n{\n\tstruct nouveau_channel *chan = fence->channel;\n\tstruct nv84_fence_chan *fctx = chan->fence;\n\tu64 addr = fctx->vma->addr + nv84_fence_chid(chan) * 16;\n\n\treturn fctx->base.emit32(chan, addr, fence->base.seqno);\n}\n\nstatic int\nnv84_fence_sync(struct nouveau_fence *fence,\n\t\tstruct nouveau_channel *prev, struct nouveau_channel *chan)\n{\n\tstruct nv84_fence_chan *fctx = chan->fence;\n\tu64 addr = fctx->vma->addr + nv84_fence_chid(prev) * 16;\n\n\treturn fctx->base.sync32(chan, addr, fence->base.seqno);\n}\n\nstatic u32\nnv84_fence_read(struct nouveau_channel *chan)\n{\n\tstruct nv84_fence_priv *priv = chan->drm->fence;\n\treturn nouveau_bo_rd32(priv->bo, nv84_fence_chid(chan) * 16/4);\n}\n\nstatic void\nnv84_fence_context_del(struct nouveau_channel *chan)\n{\n\tstruct nv84_fence_priv *priv = chan->drm->fence;\n\tstruct nv84_fence_chan *fctx = chan->fence;\n\n\tnouveau_bo_wr32(priv->bo, nv84_fence_chid(chan) * 16 / 4, fctx->base.sequence);\n\tmutex_lock(&priv->mutex);\n\tnouveau_vma_del(&fctx->vma);\n\tmutex_unlock(&priv->mutex);\n\tnouveau_fence_context_del(&fctx->base);\n\tchan->fence = NULL;\n\tnouveau_fence_context_free(&fctx->base);\n}\n\nint\nnv84_fence_context_new(struct nouveau_channel *chan)\n{\n\tstruct nv84_fence_priv *priv = chan->drm->fence;\n\tstruct nv84_fence_chan *fctx;\n\tint ret;\n\n\tfctx = chan->fence = kzalloc(sizeof(*fctx), GFP_KERNEL);\n\tif (!fctx)\n\t\treturn -ENOMEM;\n\n\tnouveau_fence_context_new(chan, &fctx->base);\n\tfctx->base.emit = nv84_fence_emit;\n\tfctx->base.sync = nv84_fence_sync;\n\tfctx->base.read = nv84_fence_read;\n\tfctx->base.emit32 = nv84_fence_emit32;\n\tfctx->base.sync32 = nv84_fence_sync32;\n\tfctx->base.sequence = nv84_fence_read(chan);\n\n\tmutex_lock(&priv->mutex);\n\tret = nouveau_vma_new(priv->bo, chan->vmm, &fctx->vma);\n\tmutex_unlock(&priv->mutex);\n\n\tif (ret)\n\t\tnv84_fence_context_del(chan);\n\treturn ret;\n}\n\nstatic bool\nnv84_fence_suspend(struct nouveau_drm *drm)\n{\n\tstruct nv84_fence_priv *priv = drm->fence;\n\tint i;\n\n\tpriv->suspend = vmalloc(array_size(sizeof(u32), drm->chan_total));\n\tif (priv->suspend) {\n\t\tfor (i = 0; i < drm->chan_total; i++)\n\t\t\tpriv->suspend[i] = nouveau_bo_rd32(priv->bo, i*4);\n\t}\n\n\treturn priv->suspend != NULL;\n}\n\nstatic void\nnv84_fence_resume(struct nouveau_drm *drm)\n{\n\tstruct nv84_fence_priv *priv = drm->fence;\n\tint i;\n\n\tif (priv->suspend) {\n\t\tfor (i = 0; i < drm->chan_total; i++)\n\t\t\tnouveau_bo_wr32(priv->bo, i*4, priv->suspend[i]);\n\t\tvfree(priv->suspend);\n\t\tpriv->suspend = NULL;\n\t}\n}\n\nstatic void\nnv84_fence_destroy(struct nouveau_drm *drm)\n{\n\tstruct nv84_fence_priv *priv = drm->fence;\n\tnouveau_bo_unmap(priv->bo);\n\tif (priv->bo)\n\t\tnouveau_bo_unpin(priv->bo);\n\tnouveau_bo_ref(NULL, &priv->bo);\n\tdrm->fence = NULL;\n\tkfree(priv);\n}\n\nint\nnv84_fence_create(struct nouveau_drm *drm)\n{\n\tstruct nv84_fence_priv *priv;\n\tu32 domain;\n\tint ret;\n\n\tpriv = drm->fence = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base.dtor = nv84_fence_destroy;\n\tpriv->base.suspend = nv84_fence_suspend;\n\tpriv->base.resume = nv84_fence_resume;\n\tpriv->base.context_new = nv84_fence_context_new;\n\tpriv->base.context_del = nv84_fence_context_del;\n\n\tpriv->base.uevent = true;\n\n\tmutex_init(&priv->mutex);\n\n\t \n\tdomain = drm->client.device.info.ram_size != 0 ?\n\t\tNOUVEAU_GEM_DOMAIN_VRAM :\n\t\t  \n\t\tNOUVEAU_GEM_DOMAIN_GART | NOUVEAU_GEM_DOMAIN_COHERENT;\n\tret = nouveau_bo_new(&drm->client, 16 * drm->chan_total, 0,\n\t\t\t     domain, 0, 0, NULL, NULL, &priv->bo);\n\tif (ret == 0) {\n\t\tret = nouveau_bo_pin(priv->bo, domain, false);\n\t\tif (ret == 0) {\n\t\t\tret = nouveau_bo_map(priv->bo);\n\t\t\tif (ret)\n\t\t\t\tnouveau_bo_unpin(priv->bo);\n\t\t}\n\t\tif (ret)\n\t\t\tnouveau_bo_ref(NULL, &priv->bo);\n\t}\n\n\tif (ret)\n\t\tnv84_fence_destroy(drm);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}