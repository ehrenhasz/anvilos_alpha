{
  "module_name": "nouveau_bios.c",
  "hash_id": "fa398f2ad9e99be780a0e0187397d581b46c599cde337d6410eb7c182b81f4a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_bios.c",
  "human_readable_source": " \n\n#include \"nouveau_drv.h\"\n#include \"nouveau_reg.h\"\n#include \"dispnv04/hw.h\"\n#include \"nouveau_encoder.h\"\n\n#include <linux/io-mapping.h>\n#include <linux/firmware.h>\n\n \n#define NV_CIO_CRE_44_HEADA 0x0\n#define NV_CIO_CRE_44_HEADB 0x3\n#define FEATURE_MOBILE 0x10\t \n\n#define EDID1_LEN 128\n\n#define BIOSLOG(sip, fmt, arg...) NV_DEBUG(sip->dev, fmt, ##arg)\n#define LOG_OLD_VALUE(x)\n\nstruct init_exec {\n\tbool execute;\n\tbool repeat;\n};\n\nstatic bool nv_cksum(const uint8_t *data, unsigned int length)\n{\n\t \n\tint i;\n\tuint8_t sum = 0;\n\n\tfor (i = 0; i < length; i++)\n\t\tsum += data[i];\n\n\tif (sum)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic uint16_t clkcmptable(struct nvbios *bios, uint16_t clktable, int pxclk)\n{\n\tint compare_record_len, i = 0;\n\tuint16_t compareclk, scriptptr = 0;\n\n\tif (bios->major_version < 5)  \n\t\tcompare_record_len = 3;\n\telse\n\t\tcompare_record_len = 4;\n\n\tdo {\n\t\tcompareclk = ROM16(bios->data[clktable + compare_record_len * i]);\n\t\tif (pxclk >= compareclk * 10) {\n\t\t\tif (bios->major_version < 5) {\n\t\t\t\tuint8_t tmdssub = bios->data[clktable + 2 + compare_record_len * i];\n\t\t\t\tscriptptr = ROM16(bios->data[bios->init_script_tbls_ptr + tmdssub * 2]);\n\t\t\t} else\n\t\t\t\tscriptptr = ROM16(bios->data[clktable + 2 + compare_record_len * i]);\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t} while (compareclk);\n\n\treturn scriptptr;\n}\n\nstatic void\nrun_digital_op_script(struct drm_device *dev, uint16_t scriptptr,\n\t\t      struct dcb_output *dcbent, int head, bool dl)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tNV_INFO(drm, \"0x%04X: Parsing digital output script table\\n\",\n\t\t scriptptr);\n\tNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_44, head ? NV_CIO_CRE_44_HEADB :\n\t\t\t\t\t         NV_CIO_CRE_44_HEADA);\n\tnouveau_bios_run_init_table(dev, scriptptr, dcbent, head);\n\n\tnv04_dfp_bind_head(dev, dcbent, head, dl);\n}\n\nstatic int call_lvds_manufacturer_script(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tuint8_t sub = bios->data[bios->fp.xlated_entry + script] + (bios->fp.link_c_increment && dcbent->or & DCB_OUTPUT_C ? 1 : 0);\n\tuint16_t scriptofs = ROM16(bios->data[bios->init_script_tbls_ptr + sub * 2]);\n#ifdef __powerpc__\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n#endif\n\n\tif (!bios->fp.xlated_entry || !sub || !scriptofs)\n\t\treturn -EINVAL;\n\n\trun_digital_op_script(dev, scriptofs, dcbent, head, bios->fp.dual_link);\n\n\tif (script == LVDS_PANEL_OFF) {\n\t\t \n\t\tmdelay(ROM16(bios->data[bios->fp.xlated_entry + 7]));\n\t}\n#ifdef __powerpc__\n\t \n\tif (script == LVDS_RESET &&\n\t    (pdev->device == 0x0179 || pdev->device == 0x0189 ||\n\t     pdev->device == 0x0329))\n\t\tnv_write_tmds(dev, dcbent->or, 0, 0x02, 0x72);\n#endif\n\n\treturn 0;\n}\n\nstatic int run_lvds_table(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script, int pxclk)\n{\n\t \n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tunsigned int outputset = (dcbent->or == 4) ? 1 : 0;\n\tuint16_t scriptptr = 0, clktable;\n\n\t \n\n\tswitch (script) {\n\tcase LVDS_INIT:\n\t\treturn -ENOSYS;\n\tcase LVDS_BACKLIGHT_ON:\n\tcase LVDS_PANEL_ON:\n\t\tscriptptr = ROM16(bios->data[bios->fp.lvdsmanufacturerpointer + 7 + outputset * 2]);\n\t\tbreak;\n\tcase LVDS_BACKLIGHT_OFF:\n\tcase LVDS_PANEL_OFF:\n\t\tscriptptr = ROM16(bios->data[bios->fp.lvdsmanufacturerpointer + 11 + outputset * 2]);\n\t\tbreak;\n\tcase LVDS_RESET:\n\t\tclktable = bios->fp.lvdsmanufacturerpointer + 15;\n\t\tif (dcbent->or == 4)\n\t\t\tclktable += 8;\n\n\t\tif (dcbent->lvdsconf.use_straps_for_mode) {\n\t\t\tif (bios->fp.dual_link)\n\t\t\t\tclktable += 4;\n\t\t\tif (bios->fp.if_is_24bit)\n\t\t\t\tclktable += 2;\n\t\t} else {\n\t\t\t \n\t\t\tint cmpval_24bit = (dcbent->or == 4) ? 4 : 1;\n\n\t\t\tif (bios->fp.dual_link) {\n\t\t\t\tclktable += 4;\n\t\t\t\tcmpval_24bit <<= 1;\n\t\t\t}\n\n\t\t\tif (bios->fp.strapless_is_24bit & cmpval_24bit)\n\t\t\t\tclktable += 2;\n\t\t}\n\n\t\tclktable = ROM16(bios->data[clktable]);\n\t\tif (!clktable) {\n\t\t\tNV_ERROR(drm, \"Pixel clock comparison table not found\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tscriptptr = clkcmptable(bios, clktable, pxclk);\n\t}\n\n\tif (!scriptptr) {\n\t\tNV_ERROR(drm, \"LVDS output init script not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\trun_digital_op_script(dev, scriptptr, dcbent, head, bios->fp.dual_link);\n\n\treturn 0;\n}\n\nint call_lvds_script(struct drm_device *dev, struct dcb_output *dcbent, int head, enum LVDS_script script, int pxclk)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tstruct nvbios *bios = &drm->vbios;\n\tuint8_t lvds_ver = bios->data[bios->fp.lvdsmanufacturerpointer];\n\tuint32_t sel_clk_binding, sel_clk;\n\tint ret;\n\n\tif (bios->fp.last_script_invoc == (script << 1 | head) || !lvds_ver ||\n\t    (lvds_ver >= 0x30 && script == LVDS_INIT))\n\t\treturn 0;\n\n\tif (!bios->fp.lvds_init_run) {\n\t\tbios->fp.lvds_init_run = true;\n\t\tcall_lvds_script(dev, dcbent, head, LVDS_INIT, pxclk);\n\t}\n\n\tif (script == LVDS_PANEL_ON && bios->fp.reset_after_pclk_change)\n\t\tcall_lvds_script(dev, dcbent, head, LVDS_RESET, pxclk);\n\tif (script == LVDS_RESET && bios->fp.power_off_for_reset)\n\t\tcall_lvds_script(dev, dcbent, head, LVDS_PANEL_OFF, pxclk);\n\n\tNV_INFO(drm, \"Calling LVDS script %d:\\n\", script);\n\n\t \n\tsel_clk_binding = nvif_rd32(device, NV_PRAMDAC_SEL_CLK) & 0x50000;\n\n\tif (lvds_ver < 0x30)\n\t\tret = call_lvds_manufacturer_script(dev, dcbent, head, script);\n\telse\n\t\tret = run_lvds_table(dev, dcbent, head, script, pxclk);\n\n\tbios->fp.last_script_invoc = (script << 1 | head);\n\n\tsel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK) & ~0x50000;\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, sel_clk | sel_clk_binding);\n\t \n\tnvif_wr32(device, NV_PBUS_POWERCTRL_2, 0);\n\n\treturn ret;\n}\n\nstruct lvdstableheader {\n\tuint8_t lvds_ver, headerlen, recordlen;\n};\n\nstatic int parse_lvds_manufacturer_table_header(struct drm_device *dev, struct nvbios *bios, struct lvdstableheader *lth)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint8_t lvds_ver, headerlen, recordlen;\n\n\tmemset(lth, 0, sizeof(struct lvdstableheader));\n\n\tif (bios->fp.lvdsmanufacturerpointer == 0x0) {\n\t\tNV_ERROR(drm, \"Pointer to LVDS manufacturer table invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlvds_ver = bios->data[bios->fp.lvdsmanufacturerpointer];\n\n\tswitch (lvds_ver) {\n\tcase 0x0a:\t \n\t\theaderlen = 2;\n\t\trecordlen = bios->data[bios->fp.lvdsmanufacturerpointer + 1];\n\t\tbreak;\n\tcase 0x30:\t \n\t\theaderlen = bios->data[bios->fp.lvdsmanufacturerpointer + 1];\n\t\tif (headerlen < 0x1f) {\n\t\t\tNV_ERROR(drm, \"LVDS table header not understood\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trecordlen = bios->data[bios->fp.lvdsmanufacturerpointer + 2];\n\t\tbreak;\n\tcase 0x40:\t \n\t\theaderlen = bios->data[bios->fp.lvdsmanufacturerpointer + 1];\n\t\tif (headerlen < 0x7) {\n\t\t\tNV_ERROR(drm, \"LVDS table header not understood\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trecordlen = bios->data[bios->fp.lvdsmanufacturerpointer + 2];\n\t\tbreak;\n\tdefault:\n\t\tNV_ERROR(drm,\n\t\t\t \"LVDS table revision %d.%d not currently supported\\n\",\n\t\t\t lvds_ver >> 4, lvds_ver & 0xf);\n\t\treturn -ENOSYS;\n\t}\n\n\tlth->lvds_ver = lvds_ver;\n\tlth->headerlen = headerlen;\n\tlth->recordlen = recordlen;\n\n\treturn 0;\n}\n\nstatic int\nget_fp_strap(struct drm_device *dev, struct nvbios *bios)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\n\t \n\n\tif (bios->major_version < 5 && bios->data[0x48] & 0x4)\n\t\treturn NVReadVgaCrtc5758(dev, 0, 0xf) & 0xf;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_MAXWELL)\n\t\treturn nvif_rd32(device, 0x001800) & 0x0000000f;\n\telse\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_TESLA)\n\t\treturn (nvif_rd32(device, NV_PEXTDEV_BOOT_0) >> 24) & 0xf;\n\telse\n\t\treturn (nvif_rd32(device, NV_PEXTDEV_BOOT_0) >> 16) & 0xf;\n}\n\nstatic int parse_fp_mode_table(struct drm_device *dev, struct nvbios *bios)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint8_t *fptable;\n\tuint8_t fptable_ver, headerlen = 0, recordlen, fpentries = 0xf, fpindex;\n\tint ret, ofs, fpstrapping;\n\tstruct lvdstableheader lth;\n\n\tif (bios->fp.fptablepointer == 0x0) {\n\t\t \n\t\tNV_DEBUG(drm, \"Pointer to flat panel table invalid\\n\");\n\t\tbios->digital_min_front_porch = 0x4b;\n\t\treturn 0;\n\t}\n\n\tfptable = &bios->data[bios->fp.fptablepointer];\n\tfptable_ver = fptable[0];\n\n\tswitch (fptable_ver) {\n\t \n\tcase 0x05:\t \n\t\trecordlen = 42;\n\t\tofs = -1;\n\t\tbreak;\n\tcase 0x10:\t \n\t\trecordlen = 44;\n\t\tofs = 0;\n\t\tbreak;\n\tcase 0x20:\t \n\t\theaderlen = fptable[1];\n\t\trecordlen = fptable[2];\n\t\tfpentries = fptable[3];\n\t\t \n\t\tbios->digital_min_front_porch = fptable[4];\n\t\tofs = -7;\n\t\tbreak;\n\tdefault:\n\t\tNV_ERROR(drm,\n\t\t\t \"FP table revision %d.%d not currently supported\\n\",\n\t\t\t fptable_ver >> 4, fptable_ver & 0xf);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (!bios->is_mobile)  \n\t\treturn 0;\n\n\tret = parse_lvds_manufacturer_table_header(dev, bios, &lth);\n\tif (ret)\n\t\treturn ret;\n\n\tif (lth.lvds_ver == 0x30 || lth.lvds_ver == 0x40) {\n\t\tbios->fp.fpxlatetableptr = bios->fp.lvdsmanufacturerpointer +\n\t\t\t\t\t\t\tlth.headerlen + 1;\n\t\tbios->fp.xlatwidth = lth.recordlen;\n\t}\n\tif (bios->fp.fpxlatetableptr == 0x0) {\n\t\tNV_ERROR(drm, \"Pointer to flat panel xlat table invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfpstrapping = get_fp_strap(dev, bios);\n\n\tfpindex = bios->data[bios->fp.fpxlatetableptr +\n\t\t\t\t\tfpstrapping * bios->fp.xlatwidth];\n\n\tif (fpindex > fpentries) {\n\t\tNV_ERROR(drm, \"Bad flat panel table index\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (lth.lvds_ver > 0x10)\n\t\tbios->fp_no_ddc = fpstrapping != 0xf || fpindex != 0xf;\n\n\t \n\tif (fpstrapping == 0xf || fpindex == 0xf)\n\t\treturn 0;\n\n\tbios->fp.mode_ptr = bios->fp.fptablepointer + headerlen +\n\t\t\t    recordlen * fpindex + ofs;\n\n\tNV_INFO(drm, \"BIOS FP mode: %dx%d (%dkHz pixel clock)\\n\",\n\t\t ROM16(bios->data[bios->fp.mode_ptr + 11]) + 1,\n\t\t ROM16(bios->data[bios->fp.mode_ptr + 25]) + 1,\n\t\t ROM16(bios->data[bios->fp.mode_ptr + 7]) * 10);\n\n\treturn 0;\n}\n\nbool nouveau_bios_fp_mode(struct drm_device *dev, struct drm_display_mode *mode)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tuint8_t *mode_entry = &bios->data[bios->fp.mode_ptr];\n\n\tif (!mode)\t \n\t\treturn bios->fp.mode_ptr;\n\n\tmemset(mode, 0, sizeof(struct drm_display_mode));\n\t \n\tmode->clock = ROM16(mode_entry[7]) * 10;\n\t \n\tmode->hdisplay = ROM16(mode_entry[11]) + 1;\n\t \n\tmode->hsync_start = ROM16(mode_entry[17]) + 1;\n\tmode->hsync_end = ROM16(mode_entry[19]) + 1;\n\tmode->htotal = ROM16(mode_entry[21]) + 1;\n\t \n\tmode->vdisplay = ROM16(mode_entry[25]) + 1;\n\tmode->vsync_start = ROM16(mode_entry[31]) + 1;\n\tmode->vsync_end = ROM16(mode_entry[33]) + 1;\n\tmode->vtotal = ROM16(mode_entry[35]) + 1;\n\tmode->flags |= (mode_entry[37] & 0x10) ?\n\t\t\tDRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\n\tmode->flags |= (mode_entry[37] & 0x1) ?\n\t\t\tDRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\n\t \n\n\tmode->status = MODE_OK;\n\tmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\n\tdrm_mode_set_name(mode);\n\treturn bios->fp.mode_ptr;\n}\n\nint nouveau_bios_parse_lvds_table(struct drm_device *dev, int pxclk, bool *dl, bool *if_is_24bit)\n{\n\t \n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tint fpstrapping = get_fp_strap(dev, bios), lvdsmanufacturerindex = 0;\n\tstruct lvdstableheader lth;\n\tuint16_t lvdsofs;\n\tint ret, chip_version = bios->chip_version;\n\n\tret = parse_lvds_manufacturer_table_header(dev, bios, &lth);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (lth.lvds_ver) {\n\tcase 0x0a:\t \n\t\tlvdsmanufacturerindex = bios->data[\n\t\t\t\t\tbios->fp.fpxlatemanufacturertableptr +\n\t\t\t\t\tfpstrapping];\n\n\t\t \n\t\tif (!pxclk)\n\t\t\tbreak;\n\n\t\tif (chip_version < 0x25) {\n\t\t\t \n\t\t\tlvdsmanufacturerindex =\n\t\t\t\t(bios->legacy.lvds_single_a_script_ptr & 1) ?\n\t\t\t\t\t\t\t\t\t2 : 0;\n\t\t\tif (pxclk >= bios->fp.duallink_transition_clk)\n\t\t\t\tlvdsmanufacturerindex++;\n\t\t} else if (chip_version < 0x30) {\n\t\t\t \n\t\t\tlvdsmanufacturerindex = 0;\n\t\t} else {\n\t\t\t \n\t\t\tlvdsmanufacturerindex = 0;\n\t\t\tif (pxclk >= bios->fp.duallink_transition_clk)\n\t\t\t\tlvdsmanufacturerindex = 2;\n\t\t\tif (pxclk >= 140000)\n\t\t\t\tlvdsmanufacturerindex = 3;\n\t\t}\n\n\t\t \n\t\tbreak;\n\tcase 0x30:\t \n\tcase 0x40:\t \n\t\tlvdsmanufacturerindex = fpstrapping;\n\t\tbreak;\n\tdefault:\n\t\tNV_ERROR(drm, \"LVDS table revision not currently supported\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tlvdsofs = bios->fp.xlated_entry = bios->fp.lvdsmanufacturerpointer + lth.headerlen + lth.recordlen * lvdsmanufacturerindex;\n\tswitch (lth.lvds_ver) {\n\tcase 0x0a:\n\t\tbios->fp.power_off_for_reset = bios->data[lvdsofs] & 1;\n\t\tbios->fp.reset_after_pclk_change = bios->data[lvdsofs] & 2;\n\t\tbios->fp.dual_link = bios->data[lvdsofs] & 4;\n\t\tbios->fp.link_c_increment = bios->data[lvdsofs] & 8;\n\t\t*if_is_24bit = bios->data[lvdsofs] & 16;\n\t\tbreak;\n\tcase 0x30:\n\tcase 0x40:\n\t\t \n\t\tbios->fp.power_off_for_reset = true;\n\t\tbios->fp.reset_after_pclk_change = true;\n\n\t\t \n\t\tbios->fp.dual_link = bios->data[lvdsofs] & 1;\n\t\tbios->fp.if_is_24bit = bios->data[lvdsofs] & 2;\n\t\tbios->fp.strapless_is_24bit = bios->data[bios->fp.lvdsmanufacturerpointer + 4];\n\t\tbios->fp.duallink_transition_clk = ROM16(bios->data[bios->fp.lvdsmanufacturerpointer + 5]) * 10;\n\t\tbreak;\n\t}\n\n\t \n\tif (pxclk && (chip_version < 0x25 || chip_version > 0x28))\n\t\tbios->fp.dual_link = (pxclk >= bios->fp.duallink_transition_clk);\n\n\t*dl = bios->fp.dual_link;\n\n\treturn 0;\n}\n\nint run_tmds_table(struct drm_device *dev, struct dcb_output *dcbent, int head, int pxclk)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tstruct nvbios *bios = &drm->vbios;\n\tint cv = bios->chip_version;\n\tuint16_t clktable = 0, scriptptr;\n\tuint32_t sel_clk_binding, sel_clk;\n\n\t \n\tif (cv >= 0x17 && cv != 0x1a && cv != 0x20 &&\n\t    dcbent->location != DCB_LOC_ON_CHIP)\n\t\treturn 0;\n\n\tswitch (ffs(dcbent->or)) {\n\tcase 1:\n\t\tclktable = bios->tmds.output0_script_ptr;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tclktable = bios->tmds.output1_script_ptr;\n\t\tbreak;\n\t}\n\n\tif (!clktable) {\n\t\tNV_ERROR(drm, \"Pixel clock comparison table not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tscriptptr = clkcmptable(bios, clktable, pxclk);\n\n\tif (!scriptptr) {\n\t\tNV_ERROR(drm, \"TMDS output init script not found\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tsel_clk_binding = nvif_rd32(device, NV_PRAMDAC_SEL_CLK) & 0x50000;\n\trun_digital_op_script(dev, scriptptr, dcbent, head, pxclk >= 165000);\n\tsel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK) & ~0x50000;\n\tNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, sel_clk | sel_clk_binding);\n\n\treturn 0;\n}\n\nstatic void parse_script_table_pointers(struct nvbios *bios, uint16_t offset)\n{\n\t \n\n\tbios->init_script_tbls_ptr = ROM16(bios->data[offset]);\n}\n\nstatic int parse_bit_A_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint16_t load_table_ptr;\n\tuint8_t version, headerlen, entrylen, num_entries;\n\n\tif (bitentry->length != 3) {\n\t\tNV_ERROR(drm, \"Do not understand BIT A table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tload_table_ptr = ROM16(bios->data[bitentry->offset]);\n\n\tif (load_table_ptr == 0x0) {\n\t\tNV_DEBUG(drm, \"Pointer to BIT loadval table invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tversion = bios->data[load_table_ptr];\n\n\tif (version != 0x10) {\n\t\tNV_ERROR(drm, \"BIT loadval table version %d.%d not supported\\n\",\n\t\t\t version >> 4, version & 0xF);\n\t\treturn -ENOSYS;\n\t}\n\n\theaderlen = bios->data[load_table_ptr + 1];\n\tentrylen = bios->data[load_table_ptr + 2];\n\tnum_entries = bios->data[load_table_ptr + 3];\n\n\tif (headerlen != 4 || entrylen != 4 || num_entries != 2) {\n\t\tNV_ERROR(drm, \"Do not understand BIT loadval table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbios->dactestval = ROM32(bios->data[load_table_ptr + headerlen]) & 0x3ff;\n\n\treturn 0;\n}\n\nstatic int parse_bit_display_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\n{\n\t \n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (bitentry->length != 4) {\n\t\tNV_ERROR(drm, \"Do not understand BIT display table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbios->fp.fptablepointer = ROM16(bios->data[bitentry->offset + 2]);\n\n\treturn 0;\n}\n\nstatic int parse_bit_init_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\n{\n\t \n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (bitentry->length < 14) {\n\t\tNV_ERROR(drm, \"Do not understand init table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparse_script_table_pointers(bios, bitentry->offset);\n\treturn 0;\n}\n\nstatic int parse_bit_i_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint16_t daccmpoffset;\n\tuint8_t dacver, dacheaderlen;\n\n\tif (bitentry->length < 6) {\n\t\tNV_ERROR(drm, \"BIT i table too short for needed information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbios->feature_byte = bios->data[bitentry->offset + 5];\n\tbios->is_mobile = bios->feature_byte & FEATURE_MOBILE;\n\n\tif (bitentry->length < 15) {\n\t\tNV_WARN(drm, \"BIT i table not long enough for DAC load \"\n\t\t\t       \"detection comparison table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdaccmpoffset = ROM16(bios->data[bitentry->offset + 13]);\n\n\t \n\tif (!daccmpoffset)\n\t\treturn 0;\n\n\t \n\n\tdacver = bios->data[daccmpoffset];\n\tdacheaderlen = bios->data[daccmpoffset + 1];\n\n\tif (dacver != 0x00 && dacver != 0x10) {\n\t\tNV_WARN(drm, \"DAC load detection comparison table version \"\n\t\t\t       \"%d.%d not known\\n\", dacver >> 4, dacver & 0xf);\n\t\treturn -ENOSYS;\n\t}\n\n\tbios->dactestval = ROM32(bios->data[daccmpoffset + dacheaderlen]);\n\tbios->tvdactestval = ROM32(bios->data[daccmpoffset + dacheaderlen + 4]);\n\n\treturn 0;\n}\n\nstatic int parse_bit_lvds_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tif (bitentry->length != 2) {\n\t\tNV_ERROR(drm, \"Do not understand BIT LVDS table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbios->fp.lvdsmanufacturerpointer = ROM16(bios->data[bitentry->offset]);\n\n\treturn 0;\n}\n\nstatic int\nparse_bit_M_tbl_entry(struct drm_device *dev, struct nvbios *bios,\n\t\t      struct bit_entry *bitentry)\n{\n\t \n\n\t \n\tif (bitentry->length < 0x5)\n\t\treturn 0;\n\n\tif (bitentry->version < 2) {\n\t\tbios->ram_restrict_group_count = bios->data[bitentry->offset + 2];\n\t\tbios->ram_restrict_tbl_ptr = ROM16(bios->data[bitentry->offset + 3]);\n\t} else {\n\t\tbios->ram_restrict_group_count = bios->data[bitentry->offset + 0];\n\t\tbios->ram_restrict_tbl_ptr = ROM16(bios->data[bitentry->offset + 1]);\n\t}\n\n\treturn 0;\n}\n\nstatic int parse_bit_tmds_tbl_entry(struct drm_device *dev, struct nvbios *bios, struct bit_entry *bitentry)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint16_t tmdstableptr, script1, script2;\n\n\tif (bitentry->length != 2) {\n\t\tNV_ERROR(drm, \"Do not understand BIT TMDS table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttmdstableptr = ROM16(bios->data[bitentry->offset]);\n\tif (!tmdstableptr) {\n\t\tNV_INFO(drm, \"Pointer to TMDS table not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tNV_INFO(drm, \"TMDS table version %d.%d\\n\",\n\t\tbios->data[tmdstableptr] >> 4, bios->data[tmdstableptr] & 0xf);\n\n\t \n\tif (bios->data[tmdstableptr] != 0x11)\n\t\treturn -ENOSYS;\n\n\t \n\tscript1 = ROM16(bios->data[tmdstableptr + 7]);\n\tscript2 = ROM16(bios->data[tmdstableptr + 9]);\n\tif (bios->data[script1] != 'q' || bios->data[script2] != 'q')\n\t\tNV_WARN(drm, \"TMDS table script pointers not stubbed\\n\");\n\n\tbios->tmds.output0_script_ptr = ROM16(bios->data[tmdstableptr + 11]);\n\tbios->tmds.output1_script_ptr = ROM16(bios->data[tmdstableptr + 13]);\n\n\treturn 0;\n}\n\nstruct bit_table {\n\tconst char id;\n\tint (* const parse_fn)(struct drm_device *, struct nvbios *, struct bit_entry *);\n};\n\n#define BIT_TABLE(id, funcid) ((struct bit_table){ id, parse_bit_##funcid##_tbl_entry })\n\nint\nbit_table(struct drm_device *dev, u8 id, struct bit_entry *bit)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tu8 entries, *entry;\n\n\tif (bios->type != NVBIOS_BIT)\n\t\treturn -ENODEV;\n\n\tentries = bios->data[bios->offset + 10];\n\tentry   = &bios->data[bios->offset + 12];\n\twhile (entries--) {\n\t\tif (entry[0] == id) {\n\t\t\tbit->id = entry[0];\n\t\t\tbit->version = entry[1];\n\t\t\tbit->length = ROM16(entry[2]);\n\t\t\tbit->offset = ROM16(entry[4]);\n\t\t\tbit->data = ROMPTR(dev, entry[4]);\n\t\t\treturn 0;\n\t\t}\n\n\t\tentry += bios->data[bios->offset + 9];\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int\nparse_bit_table(struct nvbios *bios, const uint16_t bitoffset,\n\t\tstruct bit_table *table)\n{\n\tstruct drm_device *dev = bios->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct bit_entry bitentry;\n\n\tif (bit_table(dev, table->id, &bitentry) == 0)\n\t\treturn table->parse_fn(dev, bios, &bitentry);\n\n\tNV_INFO(drm, \"BIT table '%c' not found\\n\", table->id);\n\treturn -ENOSYS;\n}\n\nstatic int\nparse_bit_structure(struct nvbios *bios, const uint16_t bitoffset)\n{\n\tint ret;\n\n\t \n\tret = parse_bit_table(bios, bitoffset, &BIT_TABLE('i', i));\n\tif (ret)  \n\t\treturn ret;\n\tif (bios->major_version >= 0x60)  \n\t\tparse_bit_table(bios, bitoffset, &BIT_TABLE('A', A));\n\tparse_bit_table(bios, bitoffset, &BIT_TABLE('D', display));\n\tret = parse_bit_table(bios, bitoffset, &BIT_TABLE('I', init));\n\tif (ret)\n\t\treturn ret;\n\tparse_bit_table(bios, bitoffset, &BIT_TABLE('M', M));  \n\tparse_bit_table(bios, bitoffset, &BIT_TABLE('L', lvds));\n\tparse_bit_table(bios, bitoffset, &BIT_TABLE('T', tmds));\n\n\treturn 0;\n}\n\nstatic int parse_bmp_structure(struct drm_device *dev, struct nvbios *bios, unsigned int offset)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tuint8_t *bmp = &bios->data[offset], bmp_version_major, bmp_version_minor;\n\tuint16_t bmplength;\n\tuint16_t legacy_scripts_offset, legacy_i2c_offset;\n\n\t \n\tbios->digital_min_front_porch = 0x4b;\n\tbios->fmaxvco = 256000;\n\tbios->fminvco = 128000;\n\tbios->fp.duallink_transition_clk = 90000;\n\n\tbmp_version_major = bmp[5];\n\tbmp_version_minor = bmp[6];\n\n\tNV_INFO(drm, \"BMP version %d.%d\\n\",\n\t\t bmp_version_major, bmp_version_minor);\n\n\t \n\tif (bmp_version_major < 5)\n\t\t*(uint16_t *)&bios->data[0x36] = 0;\n\n\t \n\tif ((bmp_version_major < 5 && bmp_version_minor != 1) || bmp_version_major > 5) {\n\t\tNV_ERROR(drm, \"You have an unsupported BMP version. \"\n\t\t\t\t\"Please send in your bios\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (bmp_version_major == 0)\n\t\t \n\t\treturn 0;\n\telse if (bmp_version_major == 1)\n\t\tbmplength = 44;  \n\telse if (bmp_version_major == 2)\n\t\tbmplength = 48;  \n\telse if (bmp_version_major == 3)\n\t\tbmplength = 54;\n\t\t \n\telse if (bmp_version_major == 4 || bmp_version_minor < 0x1)\n\t\t \n\t\tbmplength = 62;\n\t\t \n\telse if (bmp_version_minor < 0x6)\n\t\tbmplength = 67;  \n\telse if (bmp_version_minor < 0x10)\n\t\tbmplength = 75;  \n\telse if (bmp_version_minor == 0x10)\n\t\tbmplength = 89;  \n\telse if (bmp_version_minor < 0x14)\n\t\tbmplength = 118;  \n\telse if (bmp_version_minor < 0x24)\n\t\t \n\t\t \n\t\tbmplength = 123;\n\telse if (bmp_version_minor < 0x27)\n\t\t \n\t\tbmplength = 144;\n\telse\n\t\t \n\t\tbmplength = 158;\n\n\t \n\tif (nv_cksum(bmp, 8)) {\n\t\tNV_ERROR(drm, \"Bad BMP checksum\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbios->feature_byte = bmp[9];\n\n\tif (bmp_version_major < 5 || bmp_version_minor < 0x10)\n\t\tbios->old_style_init = true;\n\tlegacy_scripts_offset = 18;\n\tif (bmp_version_major < 2)\n\t\tlegacy_scripts_offset -= 4;\n\tbios->init_script_tbls_ptr = ROM16(bmp[legacy_scripts_offset]);\n\tbios->extra_init_script_tbl_ptr = ROM16(bmp[legacy_scripts_offset + 2]);\n\n\tif (bmp_version_major > 2) {\t \n\t\tbios->legacy.mem_init_tbl_ptr = ROM16(bmp[24]);\n\t\tbios->legacy.sdr_seq_tbl_ptr = ROM16(bmp[26]);\n\t\tbios->legacy.ddr_seq_tbl_ptr = ROM16(bmp[28]);\n\t}\n\n\tlegacy_i2c_offset = 0x48;\t \n\tif (bmplength > 61)\n\t\tlegacy_i2c_offset = offset + 54;\n\tbios->legacy.i2c_indices.crt = bios->data[legacy_i2c_offset];\n\tbios->legacy.i2c_indices.tv = bios->data[legacy_i2c_offset + 1];\n\tbios->legacy.i2c_indices.panel = bios->data[legacy_i2c_offset + 2];\n\n\tif (bmplength > 74) {\n\t\tbios->fmaxvco = ROM32(bmp[67]);\n\t\tbios->fminvco = ROM32(bmp[71]);\n\t}\n\tif (bmplength > 88)\n\t\tparse_script_table_pointers(bios, offset + 75);\n\tif (bmplength > 94) {\n\t\tbios->tmds.output0_script_ptr = ROM16(bmp[89]);\n\t\tbios->tmds.output1_script_ptr = ROM16(bmp[91]);\n\t\t \n\t\tbios->legacy.lvds_single_a_script_ptr = ROM16(bmp[95]);\n\t}\n\tif (bmplength > 108) {\n\t\tbios->fp.fptablepointer = ROM16(bmp[105]);\n\t\tbios->fp.fpxlatetableptr = ROM16(bmp[107]);\n\t\tbios->fp.xlatwidth = 1;\n\t}\n\tif (bmplength > 120) {\n\t\tbios->fp.lvdsmanufacturerpointer = ROM16(bmp[117]);\n\t\tbios->fp.fpxlatemanufacturertableptr = ROM16(bmp[119]);\n\t}\n#if 0\n\tif (bmplength > 143)\n\t\tbios->pll_limit_tbl_ptr = ROM16(bmp[142]);\n#endif\n\n\tif (bmplength > 157)\n\t\tbios->fp.duallink_transition_clk = ROM16(bmp[156]) * 10;\n\n\treturn 0;\n}\n\nstatic uint16_t findstr(uint8_t *data, int n, const uint8_t *str, int len)\n{\n\tint i, j;\n\n\tfor (i = 0; i <= (n - len); i++) {\n\t\tfor (j = 0; j < len; j++)\n\t\t\tif (data[i + j] != str[j])\n\t\t\t\tbreak;\n\t\tif (j == len)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nvoid *\nolddcb_table(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tu8 *dcb = NULL;\n\n\tif (drm->client.device.info.family > NV_DEVICE_INFO_V0_TNT)\n\t\tdcb = ROMPTR(dev, drm->vbios.data[0x36]);\n\tif (!dcb) {\n\t\tNV_WARN(drm, \"No DCB data found in VBIOS\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (dcb[0] >= 0x42) {\n\t\tNV_WARN(drm, \"DCB version 0x%02x unknown\\n\", dcb[0]);\n\t\treturn NULL;\n\t} else\n\tif (dcb[0] >= 0x30) {\n\t\tif (ROM32(dcb[6]) == 0x4edcbdcb)\n\t\t\treturn dcb;\n\t} else\n\tif (dcb[0] >= 0x20) {\n\t\tif (ROM32(dcb[4]) == 0x4edcbdcb)\n\t\t\treturn dcb;\n\t} else\n\tif (dcb[0] >= 0x15) {\n\t\tif (!memcmp(&dcb[-7], \"DEV_REC\", 7))\n\t\t\treturn dcb;\n\t} else {\n\t\t \n\t\tNV_WARN(drm, \"No useful DCB data in VBIOS\\n\");\n\t\treturn NULL;\n\t}\n\n\tNV_WARN(drm, \"DCB header validation failed\\n\");\n\treturn NULL;\n}\n\nvoid *\nolddcb_outp(struct drm_device *dev, u8 idx)\n{\n\tu8 *dcb = olddcb_table(dev);\n\tif (dcb && dcb[0] >= 0x30) {\n\t\tif (idx < dcb[2])\n\t\t\treturn dcb + dcb[1] + (idx * dcb[3]);\n\t} else\n\tif (dcb && dcb[0] >= 0x20) {\n\t\tu8 *i2c = ROMPTR(dev, dcb[2]);\n\t\tu8 *ent = dcb + 8 + (idx * 8);\n\t\tif (i2c && ent < i2c)\n\t\t\treturn ent;\n\t} else\n\tif (dcb && dcb[0] >= 0x15) {\n\t\tu8 *i2c = ROMPTR(dev, dcb[2]);\n\t\tu8 *ent = dcb + 4 + (idx * 10);\n\t\tif (i2c && ent < i2c)\n\t\t\treturn ent;\n\t}\n\n\treturn NULL;\n}\n\nint\nolddcb_outp_foreach(struct drm_device *dev, void *data,\n\t\t int (*exec)(struct drm_device *, void *, int idx, u8 *outp))\n{\n\tint ret, idx = -1;\n\tu8 *outp = NULL;\n\twhile ((outp = olddcb_outp(dev, ++idx))) {\n\t\tif (ROM32(outp[0]) == 0x00000000)\n\t\t\tbreak;  \n\t\tif (ROM32(outp[0]) == 0xffffffff)\n\t\t\tbreak;  \n\n\t\tif ((outp[0] & 0x0f) == DCB_OUTPUT_UNUSED)\n\t\t\tcontinue;\n\t\tif ((outp[0] & 0x0f) == DCB_OUTPUT_EOL)\n\t\t\tbreak;\n\n\t\tret = exec(dev, data, idx, outp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nu8 *\nolddcb_conntab(struct drm_device *dev)\n{\n\tu8 *dcb = olddcb_table(dev);\n\tif (dcb && dcb[0] >= 0x30 && dcb[1] >= 0x16) {\n\t\tu8 *conntab = ROMPTR(dev, dcb[0x14]);\n\t\tif (conntab && conntab[0] >= 0x30 && conntab[0] <= 0x40)\n\t\t\treturn conntab;\n\t}\n\treturn NULL;\n}\n\nu8 *\nolddcb_conn(struct drm_device *dev, u8 idx)\n{\n\tu8 *conntab = olddcb_conntab(dev);\n\tif (conntab && idx < conntab[2])\n\t\treturn conntab + conntab[1] + (idx * conntab[3]);\n\treturn NULL;\n}\n\nstatic struct dcb_output *new_dcb_entry(struct dcb_table *dcb)\n{\n\tstruct dcb_output *entry = &dcb->entry[dcb->entries];\n\n\tmemset(entry, 0, sizeof(struct dcb_output));\n\tentry->index = dcb->entries++;\n\n\treturn entry;\n}\n\nstatic void fabricate_dcb_output(struct dcb_table *dcb, int type, int i2c,\n\t\t\t\t int heads, int or)\n{\n\tstruct dcb_output *entry = new_dcb_entry(dcb);\n\n\tentry->type = type;\n\tentry->i2c_index = i2c;\n\tentry->heads = heads;\n\tif (type != DCB_OUTPUT_ANALOG)\n\t\tentry->location = !DCB_LOC_ON_CHIP;  \n\tentry->or = or;\n}\n\nstatic bool\nparse_dcb20_entry(struct drm_device *dev, struct dcb_table *dcb,\n\t\t  uint32_t conn, uint32_t conf, struct dcb_output *entry)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint link = 0;\n\n\tentry->type = conn & 0xf;\n\tentry->i2c_index = (conn >> 4) & 0xf;\n\tentry->heads = (conn >> 8) & 0xf;\n\tentry->connector = (conn >> 12) & 0xf;\n\tentry->bus = (conn >> 16) & 0xf;\n\tentry->location = (conn >> 20) & 0x3;\n\tentry->or = (conn >> 24) & 0xf;\n\n\tswitch (entry->type) {\n\tcase DCB_OUTPUT_ANALOG:\n\t\t \n\t\tentry->crtconf.maxfreq = (dcb->version < 0x30) ?\n\t\t\t\t\t (conf & 0xffff) * 10 :\n\t\t\t\t\t (conf & 0xff) * 10000;\n\t\tbreak;\n\tcase DCB_OUTPUT_LVDS:\n\t\t{\n\t\tuint32_t mask;\n\t\tif (conf & 0x1)\n\t\t\tentry->lvdsconf.use_straps_for_mode = true;\n\t\tif (dcb->version < 0x22) {\n\t\t\tmask = ~0xd;\n\t\t\t \n\t\t\tentry->lvdsconf.use_straps_for_mode = true;\n\t\t\t \n\t\t\tif (conf & 0x4 || conf & 0x8)\n\t\t\t\tentry->lvdsconf.use_power_scripts = true;\n\t\t} else {\n\t\t\tmask = ~0x7;\n\t\t\tif (conf & 0x2)\n\t\t\t\tentry->lvdsconf.use_acpi_for_edid = true;\n\t\t\tif (conf & 0x4)\n\t\t\t\tentry->lvdsconf.use_power_scripts = true;\n\t\t\tentry->lvdsconf.sor.link = (conf & 0x00000030) >> 4;\n\t\t\tlink = entry->lvdsconf.sor.link;\n\t\t}\n\t\tif (conf & mask) {\n\t\t\t \n\t\t\tif (dcb->version >= 0x40)\n\t\t\t\tbreak;\n\n\t\t\tNV_ERROR(drm, \"Unknown LVDS configuration bits, \"\n\t\t\t\t      \"please report\\n\");\n\t\t}\n\t\tbreak;\n\t\t}\n\tcase DCB_OUTPUT_TV:\n\t{\n\t\tif (dcb->version >= 0x30)\n\t\t\tentry->tvconf.has_component_output = conf & (0x8 << 4);\n\t\telse\n\t\t\tentry->tvconf.has_component_output = false;\n\n\t\tbreak;\n\t}\n\tcase DCB_OUTPUT_DP:\n\t\tentry->dpconf.sor.link = (conf & 0x00000030) >> 4;\n\t\tentry->extdev = (conf & 0x0000ff00) >> 8;\n\t\tswitch ((conf & 0x00e00000) >> 21) {\n\t\tcase 0:\n\t\t\tentry->dpconf.link_bw = 162000;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tentry->dpconf.link_bw = 270000;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tentry->dpconf.link_bw = 540000;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\tentry->dpconf.link_bw = 810000;\n\t\t\tbreak;\n\t\t}\n\t\tswitch ((conf & 0x0f000000) >> 24) {\n\t\tcase 0xf:\n\t\tcase 0x4:\n\t\t\tentry->dpconf.link_nr = 4;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\tcase 0x2:\n\t\t\tentry->dpconf.link_nr = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tentry->dpconf.link_nr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tlink = entry->dpconf.sor.link;\n\t\tbreak;\n\tcase DCB_OUTPUT_TMDS:\n\t\tif (dcb->version >= 0x40) {\n\t\t\tentry->tmdsconf.sor.link = (conf & 0x00000030) >> 4;\n\t\t\tentry->extdev = (conf & 0x0000ff00) >> 8;\n\t\t\tlink = entry->tmdsconf.sor.link;\n\t\t}\n\t\telse if (dcb->version >= 0x30)\n\t\t\tentry->tmdsconf.slave_addr = (conf & 0x00000700) >> 8;\n\t\telse if (dcb->version >= 0x22)\n\t\t\tentry->tmdsconf.slave_addr = (conf & 0x00000070) >> 4;\n\t\tbreak;\n\tcase DCB_OUTPUT_EOL:\n\t\t \n\t\tdcb->entries--;\n\t\treturn false;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dcb->version < 0x40) {\n\t\t \n\t\tentry->duallink_possible =\n\t\t\t((1 << (ffs(entry->or) - 1)) * 3 == entry->or);\n\t} else {\n\t\tentry->duallink_possible = (entry->sorconf.link == 3);\n\t}\n\n\t \n\tif (conf & 0x100000)\n\t\tentry->i2c_upper_default = true;\n\n\tentry->hasht = (entry->extdev << 8) | (entry->location << 4) |\n\t\t\tentry->type;\n\tentry->hashm = (entry->heads << 8) | (link << 6) | entry->or;\n\treturn true;\n}\n\nstatic bool\nparse_dcb15_entry(struct drm_device *dev, struct dcb_table *dcb,\n\t\t  uint32_t conn, uint32_t conf, struct dcb_output *entry)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\n\tswitch (conn & 0x0000000f) {\n\tcase 0:\n\t\tentry->type = DCB_OUTPUT_ANALOG;\n\t\tbreak;\n\tcase 1:\n\t\tentry->type = DCB_OUTPUT_TV;\n\t\tbreak;\n\tcase 2:\n\tcase 4:\n\t\tif (conn & 0x10)\n\t\t\tentry->type = DCB_OUTPUT_LVDS;\n\t\telse\n\t\t\tentry->type = DCB_OUTPUT_TMDS;\n\t\tbreak;\n\tcase 3:\n\t\tentry->type = DCB_OUTPUT_LVDS;\n\t\tbreak;\n\tdefault:\n\t\tNV_ERROR(drm, \"Unknown DCB type %d\\n\", conn & 0x0000000f);\n\t\treturn false;\n\t}\n\n\tentry->i2c_index = (conn & 0x0003c000) >> 14;\n\tentry->heads = ((conn & 0x001c0000) >> 18) + 1;\n\tentry->or = entry->heads;  \n\tentry->location = (conn & 0x01e00000) >> 21;\n\tentry->bus = (conn & 0x0e000000) >> 25;\n\tentry->duallink_possible = false;\n\n\tswitch (entry->type) {\n\tcase DCB_OUTPUT_ANALOG:\n\t\tentry->crtconf.maxfreq = (conf & 0xffff) * 10;\n\t\tbreak;\n\tcase DCB_OUTPUT_TV:\n\t\tentry->tvconf.has_component_output = false;\n\t\tbreak;\n\tcase DCB_OUTPUT_LVDS:\n\t\tif ((conn & 0x00003f00) >> 8 != 0x10)\n\t\t\tentry->lvdsconf.use_straps_for_mode = true;\n\t\tentry->lvdsconf.use_power_scripts = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic\nvoid merge_like_dcb_entries(struct drm_device *dev, struct dcb_table *dcb)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tint i, newentries = 0;\n\n\tfor (i = 0; i < dcb->entries; i++) {\n\t\tstruct dcb_output *ient = &dcb->entry[i];\n\t\tint j;\n\n\t\tfor (j = i + 1; j < dcb->entries; j++) {\n\t\t\tstruct dcb_output *jent = &dcb->entry[j];\n\n\t\t\tif (jent->type == 100)  \n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (jent->i2c_index == ient->i2c_index &&\n\t\t\t    jent->type == ient->type &&\n\t\t\t    jent->location == ient->location &&\n\t\t\t    jent->or == ient->or) {\n\t\t\t\tNV_INFO(drm, \"Merging DCB entries %d and %d\\n\",\n\t\t\t\t\t i, j);\n\t\t\t\tient->heads |= jent->heads;\n\t\t\t\tjent->type = 100;  \n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dcb->entries; i++) {\n\t\tif (dcb->entry[i].type == 100)\n\t\t\tcontinue;\n\n\t\tif (newentries != i) {\n\t\t\tdcb->entry[newentries] = dcb->entry[i];\n\t\t\tdcb->entry[newentries].index = newentries;\n\t\t}\n\t\tnewentries++;\n\t}\n\n\tdcb->entries = newentries;\n}\n\nstatic bool\napply_dcb_encoder_quirks(struct drm_device *dev, int idx, u32 *conn, u32 *conf)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct dcb_table *dcb = &drm->vbios.dcb;\n\n\t \n\tif (nv_match_device(dev, 0x040d, 0x1028, 0x019b)) {\n\t\tif (*conn == 0x02026312 && *conf == 0x00000020)\n\t\t\treturn false;\n\t}\n\n\t \n\tif (nv_match_device(dev, 0x0201, 0x1462, 0x8851)) {\n\t\tif (*conn == 0xf2005014 && *conf == 0xffffffff) {\n\t\t\tfabricate_dcb_output(dcb, DCB_OUTPUT_TMDS, 1, 1, 1);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\tif (nv_match_device(dev, 0x0ca3, 0x1682, 0x3003)) {\n\t\tif (idx == 0) {\n\t\t\t*conn = 0x02001300;  \n\t\t\t*conf = 0x00000028;\n\t\t} else\n\t\tif (idx == 1) {\n\t\t\t*conn = 0x01010312;  \n\t\t\t*conf = 0x00020030;\n\t\t} else\n\t\tif (idx == 2) {\n\t\t\t*conn = 0x01010310;  \n\t\t\t*conf = 0x00000028;\n\t\t} else\n\t\tif (idx == 3) {\n\t\t\t*conn = 0x02022362;  \n\t\t\t*conf = 0x00020010;\n\t\t} else {\n\t\t\t*conn = 0x0000000e;  \n\t\t\t*conf = 0x00000000;\n\t\t}\n\t}\n\n\t \n\tif (nv_match_device(dev, 0x0615, 0x1682, 0x2605)) {\n\t\tif (idx == 0) {\n\t\t\t*conn = 0x02002300;  \n\t\t\t*conf = 0x00000028;\n\t\t} else\n\t\tif (idx == 1) {\n\t\t\t*conn = 0x01010312;  \n\t\t\t*conf = 0x00020030;\n\t\t} else\n\t\tif (idx == 2) {\n\t\t\t*conn = 0x04020310;  \n\t\t\t*conf = 0x00000028;\n\t\t} else\n\t\tif (idx == 3) {\n\t\t\t*conn = 0x02021322;  \n\t\t\t*conf = 0x00020010;\n\t\t} else {\n\t\t\t*conn = 0x0000000e;  \n\t\t\t*conf = 0x00000000;\n\t\t}\n\t}\n\n\t \n\tif (nv_match_device(dev, 0x0421, 0x3842, 0xc793)) {\n\t\tif (idx == 0 && *conn == 0x02000300)\n\t\t\t*conn = 0x02011300;\n\t\telse\n\t\tif (idx == 1 && *conn == 0x04011310)\n\t\t\t*conn = 0x04000310;\n\t\telse\n\t\tif (idx == 2 && *conn == 0x02011312)\n\t\t\t*conn = 0x02000312;\n\t}\n\n\treturn true;\n}\n\nstatic void\nfabricate_dcb_encoder_table(struct drm_device *dev, struct nvbios *bios)\n{\n\tstruct dcb_table *dcb = &bios->dcb;\n\tint all_heads = (nv_two_heads(dev) ? 3 : 1);\n\n#ifdef __powerpc__\n\t \n\tif (of_machine_is_compatible(\"PowerMac4,5\")) {\n\t\tfabricate_dcb_output(dcb, DCB_OUTPUT_TMDS, 0, all_heads, 1);\n\t\tfabricate_dcb_output(dcb, DCB_OUTPUT_ANALOG, 1, all_heads, 2);\n\t\treturn;\n\t}\n#endif\n\n\t \n\tfabricate_dcb_output(dcb, DCB_OUTPUT_ANALOG,\n\t\t\t     bios->legacy.i2c_indices.crt, 1, 1);\n\n\tif (nv04_tv_identify(dev, bios->legacy.i2c_indices.tv) >= 0)\n\t\tfabricate_dcb_output(dcb, DCB_OUTPUT_TV,\n\t\t\t\t     bios->legacy.i2c_indices.tv,\n\t\t\t\t     all_heads, 0);\n\n\telse if (bios->tmds.output0_script_ptr ||\n\t\t bios->tmds.output1_script_ptr)\n\t\tfabricate_dcb_output(dcb, DCB_OUTPUT_TMDS,\n\t\t\t\t     bios->legacy.i2c_indices.panel,\n\t\t\t\t     all_heads, 1);\n}\n\nstatic int\nparse_dcb_entry(struct drm_device *dev, void *data, int idx, u8 *outp)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct dcb_table *dcb = &drm->vbios.dcb;\n\tu32 conf = (dcb->version >= 0x20) ? ROM32(outp[4]) : ROM32(outp[6]);\n\tu32 conn = ROM32(outp[0]);\n\tbool ret;\n\n\tif (apply_dcb_encoder_quirks(dev, idx, &conn, &conf)) {\n\t\tstruct dcb_output *entry = new_dcb_entry(dcb);\n\n\t\tNV_INFO(drm, \"DCB outp %02d: %08x %08x\\n\", idx, conn, conf);\n\n\t\tif (dcb->version >= 0x20)\n\t\t\tret = parse_dcb20_entry(dev, dcb, conn, conf, entry);\n\t\telse\n\t\t\tret = parse_dcb15_entry(dev, dcb, conn, conf, entry);\n\t\tentry->id = idx;\n\n\t\tif (!ret)\n\t\t\treturn 1;  \n\n\t\t \n\t\tif (entry->type == DCB_OUTPUT_TV &&\n\t\t    entry->location == DCB_LOC_ON_CHIP)\n\t\t\tentry->i2c_index = 0x0f;\n\t}\n\n\treturn 0;\n}\n\nstatic void\ndcb_fake_connectors(struct nvbios *bios)\n{\n\tstruct dcb_table *dcbt = &bios->dcb;\n\tu8 map[16] = { };\n\tint i, idx = 0;\n\n\t \n\tif (!nv_match_device(bios->dev, 0x0392, 0x107d, 0x20a2)) {\n\t\tfor (i = 0; i < dcbt->entries; i++) {\n\t\t\tif (dcbt->entry[i].connector)\n\t\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < dcbt->entries; i++) {\n\t\tu8 i2c = dcbt->entry[i].i2c_index;\n\t\tif (i2c == 0x0f) {\n\t\t\tdcbt->entry[i].connector = idx++;\n\t\t} else {\n\t\t\tif (!map[i2c])\n\t\t\t\tmap[i2c] = ++idx;\n\t\t\tdcbt->entry[i].connector = map[i2c] - 1;\n\t\t}\n\t}\n\n\t \n\tif (i > 1) {\n\t\tu8 *conntab = olddcb_conntab(bios->dev);\n\t\tif (conntab)\n\t\t\tconntab[0] = 0x00;\n\t}\n}\n\nstatic int\nparse_dcb_table(struct drm_device *dev, struct nvbios *bios)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct dcb_table *dcb = &bios->dcb;\n\tu8 *dcbt, *conn;\n\tint idx;\n\n\tdcbt = olddcb_table(dev);\n\tif (!dcbt) {\n\t\t \n\t\tif (bios->type == NVBIOS_BMP) {\n\t\t\tfabricate_dcb_encoder_table(dev, bios);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\tNV_INFO(drm, \"DCB version %d.%d\\n\", dcbt[0] >> 4, dcbt[0] & 0xf);\n\n\tdcb->version = dcbt[0];\n\tolddcb_outp_foreach(dev, NULL, parse_dcb_entry);\n\n\t \n\tif (dcb->version < 0x21)\n\t\tmerge_like_dcb_entries(dev, dcb);\n\n\t \n\tidx = -1;\n\twhile ((conn = olddcb_conn(dev, ++idx))) {\n\t\tif (conn[0] != 0xff) {\n\t\t\tif (olddcb_conntab(dev)[3] < 4)\n\t\t\t\tNV_INFO(drm, \"DCB conn %02d: %04x\\n\",\n\t\t\t\t\tidx, ROM16(conn[0]));\n\t\t\telse\n\t\t\t\tNV_INFO(drm, \"DCB conn %02d: %08x\\n\",\n\t\t\t\t\tidx, ROM32(conn[0]));\n\t\t}\n\t}\n\tdcb_fake_connectors(bios);\n\treturn 0;\n}\n\nstatic int load_nv17_hwsq_ucode_entry(struct drm_device *dev, struct nvbios *bios, uint16_t hwsq_offset, int entry)\n{\n\t \n\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_object *device = &drm->client.device.object;\n\tuint8_t bytes_to_write;\n\tuint16_t hwsq_entry_offset;\n\tint i;\n\n\tif (bios->data[hwsq_offset] <= entry) {\n\t\tNV_ERROR(drm, \"Too few entries in HW sequencer table for \"\n\t\t\t\t\"requested entry\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbytes_to_write = bios->data[hwsq_offset + 1];\n\n\tif (bytes_to_write != 36) {\n\t\tNV_ERROR(drm, \"Unknown HW sequencer entry size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tNV_INFO(drm, \"Loading NV17 power sequencing microcode\\n\");\n\n\thwsq_entry_offset = hwsq_offset + 2 + entry * bytes_to_write;\n\n\t \n\tnvif_wr32(device, 0x00001304, ROM32(bios->data[hwsq_entry_offset]));\n\tbytes_to_write -= 4;\n\n\t \n\tfor (i = 0; i < bytes_to_write; i += 4)\n\t\tnvif_wr32(device, 0x00001400 + i, ROM32(bios->data[hwsq_entry_offset + i + 4]));\n\n\t \n\tnvif_wr32(device, NV_PBUS_DEBUG_4, nvif_rd32(device, NV_PBUS_DEBUG_4) | 0x18);\n\n\treturn 0;\n}\n\nstatic int load_nv17_hw_sequencer_ucode(struct drm_device *dev,\n\t\t\t\t\tstruct nvbios *bios)\n{\n\t \n\n\tstatic const uint8_t hwsq_signature[] = { 'H', 'W', 'S', 'Q' };\n\tconst int sz = sizeof(hwsq_signature);\n\tint hwsq_offset;\n\n\thwsq_offset = findstr(bios->data, bios->length, hwsq_signature, sz);\n\tif (!hwsq_offset)\n\t\treturn 0;\n\n\t \n\treturn load_nv17_hwsq_ucode_entry(dev, bios, hwsq_offset + sz, 0);\n}\n\nuint8_t *nouveau_bios_embedded_edid(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tstatic const uint8_t edid_sig[] = {\n\t\t\t0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 };\n\tuint16_t offset = 0;\n\tuint16_t newoffset;\n\tint searchlen = NV_PROM_SIZE;\n\n\tif (bios->fp.edid)\n\t\treturn bios->fp.edid;\n\n\twhile (searchlen) {\n\t\tnewoffset = findstr(&bios->data[offset], searchlen,\n\t\t\t\t\t\t\t\tedid_sig, 8);\n\t\tif (!newoffset)\n\t\t\treturn NULL;\n\t\toffset += newoffset;\n\t\tif (!nv_cksum(&bios->data[offset], EDID1_LEN))\n\t\t\tbreak;\n\n\t\tsearchlen -= offset;\n\t\toffset++;\n\t}\n\n\tNV_INFO(drm, \"Found EDID in BIOS\\n\");\n\n\treturn bios->fp.edid = &bios->data[offset];\n}\n\nstatic bool NVInitVBIOS(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvkm_bios *bios = nvxx_bios(&drm->client.device);\n\tstruct nvbios *legacy = &drm->vbios;\n\n\tmemset(legacy, 0, sizeof(struct nvbios));\n\tspin_lock_init(&legacy->lock);\n\tlegacy->dev = dev;\n\n\tlegacy->data = bios->data;\n\tlegacy->length = bios->size;\n\tlegacy->major_version = bios->version.major;\n\tlegacy->chip_version = bios->version.chip;\n\tif (bios->bit_offset) {\n\t\tlegacy->type = NVBIOS_BIT;\n\t\tlegacy->offset = bios->bit_offset;\n\t\treturn !parse_bit_structure(legacy, legacy->offset + 6);\n\t} else\n\tif (bios->bmp_offset) {\n\t\tlegacy->type = NVBIOS_BMP;\n\t\tlegacy->offset = bios->bmp_offset;\n\t\treturn !parse_bmp_structure(dev, legacy, legacy->offset);\n\t}\n\n\treturn false;\n}\n\nint\nnouveau_run_vbios_init(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\n\t \n\tbios->state.crtchead = 0;\n\n\tif (bios->major_version < 5)\t \n\t\tload_nv17_hw_sequencer_ucode(dev, bios);\n\n\tif (bios->execute) {\n\t\tbios->fp.last_script_invoc = 0;\n\t\tbios->fp.lvds_init_run = false;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nnouveau_bios_posted(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tunsigned htotal;\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_TESLA)\n\t\treturn true;\n\n\thtotal  = NVReadVgaCrtc(dev, 0, 0x06);\n\thtotal |= (NVReadVgaCrtc(dev, 0, 0x07) & 0x01) << 8;\n\thtotal |= (NVReadVgaCrtc(dev, 0, 0x07) & 0x20) << 4;\n\thtotal |= (NVReadVgaCrtc(dev, 0, 0x25) & 0x01) << 10;\n\thtotal |= (NVReadVgaCrtc(dev, 0, 0x41) & 0x01) << 11;\n\treturn (htotal != 0);\n}\n\nint\nnouveau_bios_init(struct drm_device *dev)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvbios *bios = &drm->vbios;\n\tint ret;\n\n\t \n\tif (!dev_is_pci(dev->dev))\n\t\treturn 0;\n\n\tif (!NVInitVBIOS(dev))\n\t\treturn -ENODEV;\n\n\tret = parse_dcb_table(dev, bios);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!bios->major_version)\t \n\t\treturn 0;\n\n\t \n\tbios->execute = false;\n\n\t \n\tif (!nouveau_bios_posted(dev)) {\n\t\tNV_INFO(drm, \"Adaptor not initialised, \"\n\t\t\t\"running VBIOS init tables.\\n\");\n\t\tbios->execute = true;\n\t}\n\n\tret = nouveau_run_vbios_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (bios->major_version < 5)\n\t\tbios->is_mobile = NVReadVgaCrtc(dev, 0, NV_CIO_CRE_4B) & 0x40;\n\n\t \n\tif (bios->is_mobile || bios->major_version >= 5)\n\t\tret = parse_fp_mode_table(dev, bios);\n\n\t \n\tbios->execute = true;\n\n\treturn 0;\n}\n\nvoid\nnouveau_bios_takedown(struct drm_device *dev)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}