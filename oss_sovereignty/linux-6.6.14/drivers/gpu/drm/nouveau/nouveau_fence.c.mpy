{
  "module_name": "nouveau_fence.c",
  "hash_id": "a60a13c82d0eaeedc27d9dd3006f7c25b6a1e79c4b660c40fa994dc5ffc501dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_fence.c",
  "human_readable_source": " \n\n#include <linux/ktime.h>\n#include <linux/hrtimer.h>\n#include <linux/sched/signal.h>\n#include <trace/events/dma_fence.h>\n\n#include <nvif/if0020.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_fence.h\"\n\nstatic const struct dma_fence_ops nouveau_fence_ops_uevent;\nstatic const struct dma_fence_ops nouveau_fence_ops_legacy;\n\nstatic inline struct nouveau_fence *\nfrom_fence(struct dma_fence *fence)\n{\n\treturn container_of(fence, struct nouveau_fence, base);\n}\n\nstatic inline struct nouveau_fence_chan *\nnouveau_fctx(struct nouveau_fence *fence)\n{\n\treturn container_of(fence->base.lock, struct nouveau_fence_chan, lock);\n}\n\nstatic int\nnouveau_fence_signal(struct nouveau_fence *fence)\n{\n\tint drop = 0;\n\n\tdma_fence_signal_locked(&fence->base);\n\tlist_del(&fence->head);\n\trcu_assign_pointer(fence->channel, NULL);\n\n\tif (test_bit(DMA_FENCE_FLAG_USER_BITS, &fence->base.flags)) {\n\t\tstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\n\n\t\tif (!--fctx->notify_ref)\n\t\t\tdrop = 1;\n\t}\n\n\tdma_fence_put(&fence->base);\n\treturn drop;\n}\n\nstatic struct nouveau_fence *\nnouveau_local_fence(struct dma_fence *fence, struct nouveau_drm *drm)\n{\n\tif (fence->ops != &nouveau_fence_ops_legacy &&\n\t    fence->ops != &nouveau_fence_ops_uevent)\n\t\treturn NULL;\n\n\treturn from_fence(fence);\n}\n\nvoid\nnouveau_fence_context_kill(struct nouveau_fence_chan *fctx, int error)\n{\n\tstruct nouveau_fence *fence;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fctx->lock, flags);\n\twhile (!list_empty(&fctx->pending)) {\n\t\tfence = list_entry(fctx->pending.next, typeof(*fence), head);\n\n\t\tif (error)\n\t\t\tdma_fence_set_error(&fence->base, error);\n\n\t\tif (nouveau_fence_signal(fence))\n\t\t\tnvif_event_block(&fctx->event);\n\t}\n\tfctx->killed = 1;\n\tspin_unlock_irqrestore(&fctx->lock, flags);\n}\n\nvoid\nnouveau_fence_context_del(struct nouveau_fence_chan *fctx)\n{\n\tnouveau_fence_context_kill(fctx, 0);\n\tnvif_event_dtor(&fctx->event);\n\tfctx->dead = 1;\n\n\t \n\tsynchronize_rcu();\n}\n\nstatic void\nnouveau_fence_context_put(struct kref *fence_ref)\n{\n\tkfree(container_of(fence_ref, struct nouveau_fence_chan, fence_ref));\n}\n\nvoid\nnouveau_fence_context_free(struct nouveau_fence_chan *fctx)\n{\n\tkref_put(&fctx->fence_ref, nouveau_fence_context_put);\n}\n\nstatic int\nnouveau_fence_update(struct nouveau_channel *chan, struct nouveau_fence_chan *fctx)\n{\n\tstruct nouveau_fence *fence;\n\tint drop = 0;\n\tu32 seq = fctx->read(chan);\n\n\twhile (!list_empty(&fctx->pending)) {\n\t\tfence = list_entry(fctx->pending.next, typeof(*fence), head);\n\n\t\tif ((int)(seq - fence->base.seqno) < 0)\n\t\t\tbreak;\n\n\t\tdrop |= nouveau_fence_signal(fence);\n\t}\n\n\treturn drop;\n}\n\nstatic int\nnouveau_fence_wait_uevent_handler(struct nvif_event *event, void *repv, u32 repc)\n{\n\tstruct nouveau_fence_chan *fctx = container_of(event, typeof(*fctx), event);\n\tunsigned long flags;\n\tint ret = NVIF_EVENT_KEEP;\n\n\tspin_lock_irqsave(&fctx->lock, flags);\n\tif (!list_empty(&fctx->pending)) {\n\t\tstruct nouveau_fence *fence;\n\t\tstruct nouveau_channel *chan;\n\n\t\tfence = list_entry(fctx->pending.next, typeof(*fence), head);\n\t\tchan = rcu_dereference_protected(fence->channel, lockdep_is_held(&fctx->lock));\n\t\tif (nouveau_fence_update(chan, fctx))\n\t\t\tret = NVIF_EVENT_DROP;\n\t}\n\tspin_unlock_irqrestore(&fctx->lock, flags);\n\n\treturn ret;\n}\n\nvoid\nnouveau_fence_context_new(struct nouveau_channel *chan, struct nouveau_fence_chan *fctx)\n{\n\tstruct nouveau_fence_priv *priv = (void*)chan->drm->fence;\n\tstruct nouveau_cli *cli = (void *)chan->user.client;\n\tstruct {\n\t\tstruct nvif_event_v0 base;\n\t\tstruct nvif_chan_event_v0 host;\n\t} args;\n\tint ret;\n\n\tINIT_LIST_HEAD(&fctx->flip);\n\tINIT_LIST_HEAD(&fctx->pending);\n\tspin_lock_init(&fctx->lock);\n\tfctx->context = chan->drm->runl[chan->runlist].context_base + chan->chid;\n\n\tif (chan == chan->drm->cechan)\n\t\tstrcpy(fctx->name, \"copy engine channel\");\n\telse if (chan == chan->drm->channel)\n\t\tstrcpy(fctx->name, \"generic kernel channel\");\n\telse\n\t\tstrcpy(fctx->name, nvxx_client(&cli->base)->name);\n\n\tkref_init(&fctx->fence_ref);\n\tif (!priv->uevent)\n\t\treturn;\n\n\targs.host.version = 0;\n\targs.host.type = NVIF_CHAN_EVENT_V0_NON_STALL_INTR;\n\n\tret = nvif_event_ctor(&chan->user, \"fenceNonStallIntr\", (chan->runlist << 16) | chan->chid,\n\t\t\t      nouveau_fence_wait_uevent_handler, false,\n\t\t\t      &args.base, sizeof(args), &fctx->event);\n\n\tWARN_ON(ret);\n}\n\nint\nnouveau_fence_emit(struct nouveau_fence *fence)\n{\n\tstruct nouveau_channel *chan = unrcu_pointer(fence->channel);\n\tstruct nouveau_fence_chan *fctx = chan->fence;\n\tstruct nouveau_fence_priv *priv = (void*)chan->drm->fence;\n\tint ret;\n\n\tfence->timeout  = jiffies + (15 * HZ);\n\n\tif (priv->uevent)\n\t\tdma_fence_init(&fence->base, &nouveau_fence_ops_uevent,\n\t\t\t       &fctx->lock, fctx->context, ++fctx->sequence);\n\telse\n\t\tdma_fence_init(&fence->base, &nouveau_fence_ops_legacy,\n\t\t\t       &fctx->lock, fctx->context, ++fctx->sequence);\n\tkref_get(&fctx->fence_ref);\n\n\tret = fctx->emit(fence);\n\tif (!ret) {\n\t\tdma_fence_get(&fence->base);\n\t\tspin_lock_irq(&fctx->lock);\n\n\t\tif (unlikely(fctx->killed)) {\n\t\t\tspin_unlock_irq(&fctx->lock);\n\t\t\tdma_fence_put(&fence->base);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (nouveau_fence_update(chan, fctx))\n\t\t\tnvif_event_block(&fctx->event);\n\n\t\tlist_add_tail(&fence->head, &fctx->pending);\n\t\tspin_unlock_irq(&fctx->lock);\n\t}\n\n\treturn ret;\n}\n\nbool\nnouveau_fence_done(struct nouveau_fence *fence)\n{\n\tif (fence->base.ops == &nouveau_fence_ops_legacy ||\n\t    fence->base.ops == &nouveau_fence_ops_uevent) {\n\t\tstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\n\t\tstruct nouveau_channel *chan;\n\t\tunsigned long flags;\n\n\t\tif (test_bit(DMA_FENCE_FLAG_SIGNALED_BIT, &fence->base.flags))\n\t\t\treturn true;\n\n\t\tspin_lock_irqsave(&fctx->lock, flags);\n\t\tchan = rcu_dereference_protected(fence->channel, lockdep_is_held(&fctx->lock));\n\t\tif (chan && nouveau_fence_update(chan, fctx))\n\t\t\tnvif_event_block(&fctx->event);\n\t\tspin_unlock_irqrestore(&fctx->lock, flags);\n\t}\n\treturn dma_fence_is_signaled(&fence->base);\n}\n\nstatic long\nnouveau_fence_wait_legacy(struct dma_fence *f, bool intr, long wait)\n{\n\tstruct nouveau_fence *fence = from_fence(f);\n\tunsigned long sleep_time = NSEC_PER_MSEC / 1000;\n\tunsigned long t = jiffies, timeout = t + wait;\n\n\twhile (!nouveau_fence_done(fence)) {\n\t\tktime_t kt;\n\n\t\tt = jiffies;\n\n\t\tif (wait != MAX_SCHEDULE_TIMEOUT && time_after_eq(t, timeout)) {\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t\treturn 0;\n\t\t}\n\n\t\t__set_current_state(intr ? TASK_INTERRUPTIBLE :\n\t\t\t\t\t   TASK_UNINTERRUPTIBLE);\n\n\t\tkt = sleep_time;\n\t\tschedule_hrtimeout(&kt, HRTIMER_MODE_REL);\n\t\tsleep_time *= 2;\n\t\tif (sleep_time > NSEC_PER_MSEC)\n\t\t\tsleep_time = NSEC_PER_MSEC;\n\n\t\tif (intr && signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn timeout - t;\n}\n\nstatic int\nnouveau_fence_wait_busy(struct nouveau_fence *fence, bool intr)\n{\n\tint ret = 0;\n\n\twhile (!nouveau_fence_done(fence)) {\n\t\tif (time_after_eq(jiffies, fence->timeout)) {\n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\t__set_current_state(intr ?\n\t\t\t\t    TASK_INTERRUPTIBLE :\n\t\t\t\t    TASK_UNINTERRUPTIBLE);\n\n\t\tif (intr && signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\treturn ret;\n}\n\nint\nnouveau_fence_wait(struct nouveau_fence *fence, bool lazy, bool intr)\n{\n\tlong ret;\n\n\tif (!lazy)\n\t\treturn nouveau_fence_wait_busy(fence, intr);\n\n\tret = dma_fence_wait_timeout(&fence->base, intr, 15 * HZ);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (!ret)\n\t\treturn -EBUSY;\n\telse\n\t\treturn 0;\n}\n\nint\nnouveau_fence_sync(struct nouveau_bo *nvbo, struct nouveau_channel *chan,\n\t\t   bool exclusive, bool intr)\n{\n\tstruct nouveau_fence_chan *fctx = chan->fence;\n\tstruct dma_resv *resv = nvbo->bo.base.resv;\n\tint i, ret;\n\n\tret = dma_resv_reserve_fences(resv, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < 2; ++i) {\n\t\tstruct dma_resv_iter cursor;\n\t\tstruct dma_fence *fence;\n\n\t\tdma_resv_for_each_fence(&cursor, resv,\n\t\t\t\t\tdma_resv_usage_rw(exclusive),\n\t\t\t\t\tfence) {\n\t\t\tenum dma_resv_usage usage;\n\t\t\tstruct nouveau_fence *f;\n\n\t\t\tusage = dma_resv_iter_usage(&cursor);\n\t\t\tif (i == 0 && usage == DMA_RESV_USAGE_WRITE)\n\t\t\t\tcontinue;\n\n\t\t\tf = nouveau_local_fence(fence, chan->drm);\n\t\t\tif (f) {\n\t\t\t\tstruct nouveau_channel *prev;\n\t\t\t\tbool must_wait = true;\n\n\t\t\t\trcu_read_lock();\n\t\t\t\tprev = rcu_dereference(f->channel);\n\t\t\t\tif (prev && (prev == chan ||\n\t\t\t\t\t     fctx->sync(f, prev, chan) == 0))\n\t\t\t\t\tmust_wait = false;\n\t\t\t\trcu_read_unlock();\n\t\t\t\tif (!must_wait)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = dma_fence_wait(fence, intr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid\nnouveau_fence_unref(struct nouveau_fence **pfence)\n{\n\tif (*pfence)\n\t\tdma_fence_put(&(*pfence)->base);\n\t*pfence = NULL;\n}\n\nint\nnouveau_fence_create(struct nouveau_fence **pfence,\n\t\t     struct nouveau_channel *chan)\n{\n\tstruct nouveau_fence *fence;\n\n\tif (unlikely(!chan->fence))\n\t\treturn -ENODEV;\n\n\tfence = kzalloc(sizeof(*fence), GFP_KERNEL);\n\tif (!fence)\n\t\treturn -ENOMEM;\n\n\tfence->channel = chan;\n\n\t*pfence = fence;\n\treturn 0;\n}\n\nint\nnouveau_fence_new(struct nouveau_fence **pfence,\n\t\t  struct nouveau_channel *chan)\n{\n\tint ret = 0;\n\n\tret = nouveau_fence_create(pfence, chan);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nouveau_fence_emit(*pfence);\n\tif (ret)\n\t\tnouveau_fence_unref(pfence);\n\n\treturn ret;\n}\n\nstatic const char *nouveau_fence_get_get_driver_name(struct dma_fence *fence)\n{\n\treturn \"nouveau\";\n}\n\nstatic const char *nouveau_fence_get_timeline_name(struct dma_fence *f)\n{\n\tstruct nouveau_fence *fence = from_fence(f);\n\tstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\n\n\treturn !fctx->dead ? fctx->name : \"dead channel\";\n}\n\n \nstatic bool nouveau_fence_is_signaled(struct dma_fence *f)\n{\n\tstruct nouveau_fence *fence = from_fence(f);\n\tstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\n\tstruct nouveau_channel *chan;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tchan = rcu_dereference(fence->channel);\n\tif (chan)\n\t\tret = (int)(fctx->read(chan) - fence->base.seqno) >= 0;\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic bool nouveau_fence_no_signaling(struct dma_fence *f)\n{\n\tstruct nouveau_fence *fence = from_fence(f);\n\n\t \n\tWARN_ON(kref_read(&fence->base.refcount) <= 1);\n\n\t \n\tif (nouveau_fence_is_signaled(f)) {\n\t\tlist_del(&fence->head);\n\n\t\tdma_fence_put(&fence->base);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void nouveau_fence_release(struct dma_fence *f)\n{\n\tstruct nouveau_fence *fence = from_fence(f);\n\tstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\n\n\tkref_put(&fctx->fence_ref, nouveau_fence_context_put);\n\tdma_fence_free(&fence->base);\n}\n\nstatic const struct dma_fence_ops nouveau_fence_ops_legacy = {\n\t.get_driver_name = nouveau_fence_get_get_driver_name,\n\t.get_timeline_name = nouveau_fence_get_timeline_name,\n\t.enable_signaling = nouveau_fence_no_signaling,\n\t.signaled = nouveau_fence_is_signaled,\n\t.wait = nouveau_fence_wait_legacy,\n\t.release = nouveau_fence_release\n};\n\nstatic bool nouveau_fence_enable_signaling(struct dma_fence *f)\n{\n\tstruct nouveau_fence *fence = from_fence(f);\n\tstruct nouveau_fence_chan *fctx = nouveau_fctx(fence);\n\tbool ret;\n\n\tif (!fctx->notify_ref++)\n\t\tnvif_event_allow(&fctx->event);\n\n\tret = nouveau_fence_no_signaling(f);\n\tif (ret)\n\t\tset_bit(DMA_FENCE_FLAG_USER_BITS, &fence->base.flags);\n\telse if (!--fctx->notify_ref)\n\t\tnvif_event_block(&fctx->event);\n\n\treturn ret;\n}\n\nstatic const struct dma_fence_ops nouveau_fence_ops_uevent = {\n\t.get_driver_name = nouveau_fence_get_get_driver_name,\n\t.get_timeline_name = nouveau_fence_get_timeline_name,\n\t.enable_signaling = nouveau_fence_enable_signaling,\n\t.signaled = nouveau_fence_is_signaled,\n\t.release = nouveau_fence_release\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}