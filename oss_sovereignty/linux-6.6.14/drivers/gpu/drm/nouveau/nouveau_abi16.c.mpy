{
  "module_name": "nouveau_abi16.c",
  "hash_id": "635a46e9b32f62db291d5783ad805172c3ee032d25eb1e7dd0cb8e8bd53c02ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_abi16.c",
  "human_readable_source": " \n\n#include <nvif/client.h>\n#include <nvif/driver.h>\n#include <nvif/fifo.h>\n#include <nvif/ioctl.h>\n#include <nvif/class.h>\n#include <nvif/cl0002.h>\n#include <nvif/unpack.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_exec.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_chan.h\"\n#include \"nouveau_abi16.h\"\n#include \"nouveau_vmm.h\"\n#include \"nouveau_sched.h\"\n\nstatic struct nouveau_abi16 *\nnouveau_abi16(struct drm_file *file_priv)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tif (!cli->abi16) {\n\t\tstruct nouveau_abi16 *abi16;\n\t\tcli->abi16 = abi16 = kzalloc(sizeof(*abi16), GFP_KERNEL);\n\t\tif (cli->abi16) {\n\t\t\tstruct nv_device_v0 args = {\n\t\t\t\t.device = ~0ULL,\n\t\t\t};\n\n\t\t\tINIT_LIST_HEAD(&abi16->channels);\n\n\t\t\t \n\t\t\tif (nvif_device_ctor(&cli->base.object, \"abi16Device\",\n\t\t\t\t\t     0, NV_DEVICE, &args, sizeof(args),\n\t\t\t\t\t     &abi16->device) == 0)\n\t\t\t\treturn cli->abi16;\n\n\t\t\tkfree(cli->abi16);\n\t\t\tcli->abi16 = NULL;\n\t\t}\n\t}\n\treturn cli->abi16;\n}\n\nstruct nouveau_abi16 *\nnouveau_abi16_get(struct drm_file *file_priv)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tmutex_lock(&cli->mutex);\n\tif (nouveau_abi16(file_priv))\n\t\treturn cli->abi16;\n\tmutex_unlock(&cli->mutex);\n\treturn NULL;\n}\n\nint\nnouveau_abi16_put(struct nouveau_abi16 *abi16, int ret)\n{\n\tstruct nouveau_cli *cli = (void *)abi16->device.object.client;\n\tmutex_unlock(&cli->mutex);\n\treturn ret;\n}\n\ns32\nnouveau_abi16_swclass(struct nouveau_drm *drm)\n{\n\tswitch (drm->client.device.info.family) {\n\tcase NV_DEVICE_INFO_V0_TNT:\n\t\treturn NVIF_CLASS_SW_NV04;\n\tcase NV_DEVICE_INFO_V0_CELSIUS:\n\tcase NV_DEVICE_INFO_V0_KELVIN:\n\tcase NV_DEVICE_INFO_V0_RANKINE:\n\tcase NV_DEVICE_INFO_V0_CURIE:\n\t\treturn NVIF_CLASS_SW_NV10;\n\tcase NV_DEVICE_INFO_V0_TESLA:\n\t\treturn NVIF_CLASS_SW_NV50;\n\tcase NV_DEVICE_INFO_V0_FERMI:\n\tcase NV_DEVICE_INFO_V0_KEPLER:\n\tcase NV_DEVICE_INFO_V0_MAXWELL:\n\tcase NV_DEVICE_INFO_V0_PASCAL:\n\tcase NV_DEVICE_INFO_V0_VOLTA:\n\t\treturn NVIF_CLASS_SW_GF100;\n\t}\n\n\treturn 0x0000;\n}\n\nstatic void\nnouveau_abi16_ntfy_fini(struct nouveau_abi16_chan *chan,\n\t\t\tstruct nouveau_abi16_ntfy *ntfy)\n{\n\tnvif_object_dtor(&ntfy->object);\n\tnvkm_mm_free(&chan->heap, &ntfy->node);\n\tlist_del(&ntfy->head);\n\tkfree(ntfy);\n}\n\nstatic void\nnouveau_abi16_chan_fini(struct nouveau_abi16 *abi16,\n\t\t\tstruct nouveau_abi16_chan *chan)\n{\n\tstruct nouveau_abi16_ntfy *ntfy, *temp;\n\n\t \n\tnouveau_sched_entity_fini(&chan->sched_entity);\n\n\t \n\tif (chan->chan)\n\t\tnouveau_channel_idle(chan->chan);\n\n\t \n\tlist_for_each_entry_safe(ntfy, temp, &chan->notifiers, head) {\n\t\tnouveau_abi16_ntfy_fini(chan, ntfy);\n\t}\n\n\tif (chan->ntfy) {\n\t\tnouveau_vma_del(&chan->ntfy_vma);\n\t\tnouveau_bo_unpin(chan->ntfy);\n\t\tdrm_gem_object_put(&chan->ntfy->bo.base);\n\t}\n\n\tif (chan->heap.block_size)\n\t\tnvkm_mm_fini(&chan->heap);\n\n\t \n\tif (chan->chan) {\n\t\tnvif_object_dtor(&chan->ce);\n\t\tnouveau_channel_del(&chan->chan);\n\t}\n\n\tlist_del(&chan->head);\n\tkfree(chan);\n}\n\nvoid\nnouveau_abi16_fini(struct nouveau_abi16 *abi16)\n{\n\tstruct nouveau_cli *cli = (void *)abi16->device.object.client;\n\tstruct nouveau_abi16_chan *chan, *temp;\n\n\t \n\tlist_for_each_entry_safe(chan, temp, &abi16->channels, head) {\n\t\tnouveau_abi16_chan_fini(abi16, chan);\n\t}\n\n\t \n\tnvif_device_dtor(&abi16->device);\n\n\tkfree(cli->abi16);\n\tcli->abi16 = NULL;\n}\n\nstatic inline int\ngetparam_dma_ib_max(struct nvif_device *device)\n{\n\tconst struct nvif_mclass dmas[] = {\n\t\t{ NV03_CHANNEL_DMA, 0 },\n\t\t{ NV10_CHANNEL_DMA, 0 },\n\t\t{ NV17_CHANNEL_DMA, 0 },\n\t\t{ NV40_CHANNEL_DMA, 0 },\n\t\t{}\n\t};\n\n\treturn nvif_mclass(&device->object, dmas) < 0 ? NV50_DMA_IB_MAX : 0;\n}\n\nint\nnouveau_abi16_ioctl_getparam(ABI16_IOCTL_ARGS)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nvif_device *device = &drm->client.device;\n\tstruct nvkm_gr *gr = nvxx_gr(device);\n\tstruct drm_nouveau_getparam *getparam = data;\n\tstruct pci_dev *pdev = to_pci_dev(dev->dev);\n\n\tswitch (getparam->param) {\n\tcase NOUVEAU_GETPARAM_CHIPSET_ID:\n\t\tgetparam->value = device->info.chipset;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_PCI_VENDOR:\n\t\tif (device->info.platform != NV_DEVICE_INFO_V0_SOC)\n\t\t\tgetparam->value = pdev->vendor;\n\t\telse\n\t\t\tgetparam->value = 0;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_PCI_DEVICE:\n\t\tif (device->info.platform != NV_DEVICE_INFO_V0_SOC)\n\t\t\tgetparam->value = pdev->device;\n\t\telse\n\t\t\tgetparam->value = 0;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_BUS_TYPE:\n\t\tswitch (device->info.platform) {\n\t\tcase NV_DEVICE_INFO_V0_AGP : getparam->value = 0; break;\n\t\tcase NV_DEVICE_INFO_V0_PCI : getparam->value = 1; break;\n\t\tcase NV_DEVICE_INFO_V0_PCIE: getparam->value = 2; break;\n\t\tcase NV_DEVICE_INFO_V0_SOC : getparam->value = 3; break;\n\t\tcase NV_DEVICE_INFO_V0_IGP :\n\t\t\tif (!pci_is_pcie(pdev))\n\t\t\t\tgetparam->value = 1;\n\t\t\telse\n\t\t\t\tgetparam->value = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_FB_SIZE:\n\t\tgetparam->value = drm->gem.vram_available;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_AGP_SIZE:\n\t\tgetparam->value = drm->gem.gart_available;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_VM_VRAM_BASE:\n\t\tgetparam->value = 0;  \n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_PTIMER_TIME:\n\t\tgetparam->value = nvif_device_time(device);\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_HAS_BO_USAGE:\n\t\tgetparam->value = 1;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_HAS_PAGEFLIP:\n\t\tgetparam->value = 1;\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_GRAPH_UNITS:\n\t\tgetparam->value = nvkm_gr_units(gr);\n\t\tbreak;\n\tcase NOUVEAU_GETPARAM_EXEC_PUSH_MAX: {\n\t\tint ib_max = getparam_dma_ib_max(device);\n\n\t\tgetparam->value = nouveau_exec_push_max_from_ib_max(ib_max);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tNV_PRINTK(dbg, cli, \"unknown parameter %lld\\n\", getparam->param);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint\nnouveau_abi16_ioctl_channel_alloc(ABI16_IOCTL_ARGS)\n{\n\tstruct drm_nouveau_channel_alloc *init = data;\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_abi16_chan *chan;\n\tstruct nvif_device *device;\n\tu64 engine, runm;\n\tint ret;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\tif (!drm->channel)\n\t\treturn nouveau_abi16_put(abi16, -ENODEV);\n\n\t \n\t__nouveau_cli_disable_uvmm_noinit(cli);\n\n\tdevice = &abi16->device;\n\tengine = NV_DEVICE_HOST_RUNLIST_ENGINES_GR;\n\n\t \n\tif (device->info.family >= NV_DEVICE_INFO_V0_KEPLER) {\n\t\tif (init->fb_ctxdma_handle == ~0) {\n\t\t\tswitch (init->tt_ctxdma_handle) {\n\t\t\tcase 0x01: engine = NV_DEVICE_HOST_RUNLIST_ENGINES_GR    ; break;\n\t\t\tcase 0x02: engine = NV_DEVICE_HOST_RUNLIST_ENGINES_MSPDEC; break;\n\t\t\tcase 0x04: engine = NV_DEVICE_HOST_RUNLIST_ENGINES_MSPPP ; break;\n\t\t\tcase 0x08: engine = NV_DEVICE_HOST_RUNLIST_ENGINES_MSVLD ; break;\n\t\t\tcase 0x30: engine = NV_DEVICE_HOST_RUNLIST_ENGINES_CE    ; break;\n\t\t\tdefault:\n\t\t\t\treturn nouveau_abi16_put(abi16, -ENOSYS);\n\t\t\t}\n\n\t\t\tinit->fb_ctxdma_handle = 0;\n\t\t\tinit->tt_ctxdma_handle = 0;\n\t\t}\n\t}\n\n\tif (engine != NV_DEVICE_HOST_RUNLIST_ENGINES_CE)\n\t\trunm = nvif_fifo_runlist(device, engine);\n\telse\n\t\trunm = nvif_fifo_runlist_ce(device);\n\n\tif (!runm || init->fb_ctxdma_handle == ~0 || init->tt_ctxdma_handle == ~0)\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\n\t \n\tchan = kzalloc(sizeof(*chan), GFP_KERNEL);\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -ENOMEM);\n\n\tINIT_LIST_HEAD(&chan->notifiers);\n\tlist_add(&chan->head, &abi16->channels);\n\n\t \n\tret = nouveau_channel_new(drm, device, false, runm, init->fb_ctxdma_handle,\n\t\t\t\t  init->tt_ctxdma_handle, &chan->chan);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nouveau_sched_entity_init(&chan->sched_entity, &drm->sched,\n\t\t\t\t\tdrm->sched_wq);\n\tif (ret)\n\t\tgoto done;\n\n\tinit->channel = chan->chan->chid;\n\n\tif (device->info.family >= NV_DEVICE_INFO_V0_TESLA)\n\t\tinit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM |\n\t\t\t\t\tNOUVEAU_GEM_DOMAIN_GART;\n\telse\n\tif (chan->chan->push.buffer->bo.resource->mem_type == TTM_PL_VRAM)\n\t\tinit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM;\n\telse\n\t\tinit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_GART;\n\n\tif (device->info.family < NV_DEVICE_INFO_V0_CELSIUS) {\n\t\tinit->subchan[0].handle = 0x00000000;\n\t\tinit->subchan[0].grclass = 0x0000;\n\t\tinit->subchan[1].handle = chan->chan->nvsw.handle;\n\t\tinit->subchan[1].grclass = 0x506e;\n\t\tinit->nr_subchan = 2;\n\t}\n\n\t \n\tswitch (device->info.family) {\n\tcase NV_DEVICE_INFO_V0_VOLTA:\n\t\tret = nvif_object_ctor(&chan->chan->user, \"abi16CeWar\", 0, VOLTA_DMA_COPY_A,\n\t\t\t\t       NULL, 0, &chan->ce);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tbreak;\n\tcase NV_DEVICE_INFO_V0_TURING:\n\t\tret = nvif_object_ctor(&chan->chan->user, \"abi16CeWar\", 0, TURING_DMA_COPY_A,\n\t\t\t\t       NULL, 0, &chan->ce);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = nouveau_gem_new(cli, PAGE_SIZE, 0, NOUVEAU_GEM_DOMAIN_GART,\n\t\t\t      0, 0, &chan->ntfy);\n\tif (ret == 0)\n\t\tret = nouveau_bo_pin(chan->ntfy, NOUVEAU_GEM_DOMAIN_GART,\n\t\t\t\t     false);\n\tif (ret)\n\t\tgoto done;\n\n\tif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\n\t\tret = nouveau_vma_new(chan->ntfy, chan->chan->vmm,\n\t\t\t\t      &chan->ntfy_vma);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tret = drm_gem_handle_create(file_priv, &chan->ntfy->bo.base,\n\t\t\t\t    &init->notifier_handle);\n\tif (ret)\n\t\tgoto done;\n\n\tret = nvkm_mm_init(&chan->heap, 0, 0, PAGE_SIZE, 1);\ndone:\n\tif (ret)\n\t\tnouveau_abi16_chan_fini(abi16, chan);\n\treturn nouveau_abi16_put(abi16, ret);\n}\n\nstatic struct nouveau_abi16_chan *\nnouveau_abi16_chan(struct nouveau_abi16 *abi16, int channel)\n{\n\tstruct nouveau_abi16_chan *chan;\n\n\tlist_for_each_entry(chan, &abi16->channels, head) {\n\t\tif (chan->chan->chid == channel)\n\t\t\treturn chan;\n\t}\n\n\treturn NULL;\n}\n\nint\nnouveau_abi16_usif(struct drm_file *file_priv, void *data, u32 size)\n{\n\tunion {\n\t\tstruct nvif_ioctl_v0 v0;\n\t} *args = data;\n\tstruct nouveau_abi16_chan *chan;\n\tstruct nouveau_abi16 *abi16;\n\tint ret = -ENOSYS;\n\n\tif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\n\t\tswitch (args->v0.type) {\n\t\tcase NVIF_IOCTL_V0_NEW:\n\t\tcase NVIF_IOCTL_V0_MTHD:\n\t\tcase NVIF_IOCTL_V0_SCLASS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EACCES;\n\t\t}\n\t} else\n\t\treturn ret;\n\n\tif (!(abi16 = nouveau_abi16(file_priv)))\n\t\treturn -ENOMEM;\n\n\tif (args->v0.token != ~0ULL) {\n\t\tif (!(chan = nouveau_abi16_chan(abi16, args->v0.token)))\n\t\t\treturn -EINVAL;\n\t\targs->v0.object = nvif_handle(&chan->chan->user);\n\t\targs->v0.owner  = NVIF_IOCTL_V0_OWNER_ANY;\n\t\treturn 0;\n\t}\n\n\targs->v0.object = nvif_handle(&abi16->device.object);\n\targs->v0.owner  = NVIF_IOCTL_V0_OWNER_ANY;\n\treturn 0;\n}\n\nint\nnouveau_abi16_ioctl_channel_free(ABI16_IOCTL_ARGS)\n{\n\tstruct drm_nouveau_channel_free *req = data;\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_abi16_chan *chan;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\tchan = nouveau_abi16_chan(abi16, req->channel);\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -ENOENT);\n\tnouveau_abi16_chan_fini(abi16, chan);\n\treturn nouveau_abi16_put(abi16, 0);\n}\n\nint\nnouveau_abi16_ioctl_grobj_alloc(ABI16_IOCTL_ARGS)\n{\n\tstruct drm_nouveau_grobj_alloc *init = data;\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_abi16_chan *chan;\n\tstruct nouveau_abi16_ntfy *ntfy;\n\tstruct nvif_client *client;\n\tstruct nvif_sclass *sclass;\n\ts32 oclass = 0;\n\tint ret, i;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\tif (init->handle == ~0)\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\tclient = abi16->device.object.client;\n\n\tchan = nouveau_abi16_chan(abi16, init->channel);\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -ENOENT);\n\n\tret = nvif_object_sclass_get(&chan->chan->user, &sclass);\n\tif (ret < 0)\n\t\treturn nouveau_abi16_put(abi16, ret);\n\n\tif ((init->class & 0x00ff) == 0x006e) {\n\t\t \n\t\tfor (i = 0; !oclass && i < ret; i++) {\n\t\t\tswitch (sclass[i].oclass) {\n\t\t\tcase NVIF_CLASS_SW_NV04:\n\t\t\tcase NVIF_CLASS_SW_NV10:\n\t\t\tcase NVIF_CLASS_SW_NV50:\n\t\t\tcase NVIF_CLASS_SW_GF100:\n\t\t\t\toclass = sclass[i].oclass;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else\n\tif ((init->class & 0x00ff) == 0x00b1) {\n\t\t \n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif ((sclass[i].oclass & 0x00ff) == 0x00b1) {\n\t\t\t\toclass = sclass[i].oclass;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else\n\tif ((init->class & 0x00ff) == 0x00b2) {  \n\t\t \n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif ((sclass[i].oclass & 0x00ff) == 0x00b2) {\n\t\t\t\toclass = sclass[i].oclass;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else\n\tif ((init->class & 0x00ff) == 0x00b3) {  \n\t\t \n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif ((sclass[i].oclass & 0x00ff) == 0x00b3) {\n\t\t\t\toclass = sclass[i].oclass;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\toclass = init->class;\n\t}\n\n\tnvif_object_sclass_put(&sclass);\n\tif (!oclass)\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\n\tntfy = kzalloc(sizeof(*ntfy), GFP_KERNEL);\n\tif (!ntfy)\n\t\treturn nouveau_abi16_put(abi16, -ENOMEM);\n\n\tlist_add(&ntfy->head, &chan->notifiers);\n\n\tclient->route = NVDRM_OBJECT_ABI16;\n\tret = nvif_object_ctor(&chan->chan->user, \"abi16EngObj\", init->handle,\n\t\t\t       oclass, NULL, 0, &ntfy->object);\n\tclient->route = NVDRM_OBJECT_NVIF;\n\n\tif (ret)\n\t\tnouveau_abi16_ntfy_fini(chan, ntfy);\n\treturn nouveau_abi16_put(abi16, ret);\n}\n\nint\nnouveau_abi16_ioctl_notifierobj_alloc(ABI16_IOCTL_ARGS)\n{\n\tstruct drm_nouveau_notifierobj_alloc *info = data;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_abi16_chan *chan;\n\tstruct nouveau_abi16_ntfy *ntfy;\n\tstruct nvif_device *device = &abi16->device;\n\tstruct nvif_client *client;\n\tstruct nv_dma_v0 args = {};\n\tint ret;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\t \n\tif (unlikely(device->info.family >= NV_DEVICE_INFO_V0_FERMI))\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\tclient = abi16->device.object.client;\n\n\tchan = nouveau_abi16_chan(abi16, info->channel);\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -ENOENT);\n\n\tntfy = kzalloc(sizeof(*ntfy), GFP_KERNEL);\n\tif (!ntfy)\n\t\treturn nouveau_abi16_put(abi16, -ENOMEM);\n\n\tlist_add(&ntfy->head, &chan->notifiers);\n\n\tret = nvkm_mm_head(&chan->heap, 0, 1, info->size, info->size, 1,\n\t\t\t   &ntfy->node);\n\tif (ret)\n\t\tgoto done;\n\n\targs.start = ntfy->node->offset;\n\targs.limit = ntfy->node->offset + ntfy->node->length - 1;\n\tif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\n\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\targs.access = NV_DMA_V0_ACCESS_VM;\n\t\targs.start += chan->ntfy_vma->addr;\n\t\targs.limit += chan->ntfy_vma->addr;\n\t} else\n\tif (drm->agp.bridge) {\n\t\targs.target = NV_DMA_V0_TARGET_AGP;\n\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\targs.start += drm->agp.base + chan->ntfy->offset;\n\t\targs.limit += drm->agp.base + chan->ntfy->offset;\n\t} else {\n\t\targs.target = NV_DMA_V0_TARGET_VM;\n\t\targs.access = NV_DMA_V0_ACCESS_RDWR;\n\t\targs.start += chan->ntfy->offset;\n\t\targs.limit += chan->ntfy->offset;\n\t}\n\n\tclient->route = NVDRM_OBJECT_ABI16;\n\tret = nvif_object_ctor(&chan->chan->user, \"abi16Ntfy\", info->handle,\n\t\t\t       NV_DMA_IN_MEMORY, &args, sizeof(args),\n\t\t\t       &ntfy->object);\n\tclient->route = NVDRM_OBJECT_NVIF;\n\tif (ret)\n\t\tgoto done;\n\n\tinfo->offset = ntfy->node->offset;\ndone:\n\tif (ret)\n\t\tnouveau_abi16_ntfy_fini(chan, ntfy);\n\treturn nouveau_abi16_put(abi16, ret);\n}\n\nint\nnouveau_abi16_ioctl_gpuobj_free(ABI16_IOCTL_ARGS)\n{\n\tstruct drm_nouveau_gpuobj_free *fini = data;\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_abi16_chan *chan;\n\tstruct nouveau_abi16_ntfy *ntfy;\n\tint ret = -ENOENT;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\tchan = nouveau_abi16_chan(abi16, fini->channel);\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\n\t \n\tnouveau_channel_idle(chan->chan);\n\n\tlist_for_each_entry(ntfy, &chan->notifiers, head) {\n\t\tif (ntfy->object.handle == fini->handle) {\n\t\t\tnouveau_abi16_ntfy_fini(chan, ntfy);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nouveau_abi16_put(abi16, ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}