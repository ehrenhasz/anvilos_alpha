{
  "module_name": "nouveau_vga.c",
  "hash_id": "b0758126a10bd33f9e7c12ca3ef1afbd6e9a39e29b462e5e710ef32f49a23ec9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_vga.c",
  "human_readable_source": "\n#include <linux/vgaarb.h>\n#include <linux/vga_switcheroo.h>\n\n#include <drm/drm_fb_helper.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_acpi.h\"\n#include \"nouveau_vga.h\"\n\nstatic unsigned int\nnouveau_vga_set_decode(struct pci_dev *pdev, bool state)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(pci_get_drvdata(pdev));\n\tstruct nvif_object *device = &drm->client.device.object;\n\n\tif (drm->client.device.info.family == NV_DEVICE_INFO_V0_CURIE &&\n\t    drm->client.device.info.chipset >= 0x4c)\n\t\tnvif_wr32(device, 0x088060, state);\n\telse\n\tif (drm->client.device.info.chipset >= 0x40)\n\t\tnvif_wr32(device, 0x088054, state);\n\telse\n\t\tnvif_wr32(device, 0x001854, state);\n\n\tif (state)\n\t\treturn VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |\n\t\t       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\n\telse\n\t\treturn VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\n}\n\nstatic void\nnouveau_switcheroo_set_state(struct pci_dev *pdev,\n\t\t\t     enum vga_switcheroo_state state)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\tif ((nouveau_is_optimus() || nouveau_is_v1_dsm()) && state == VGA_SWITCHEROO_OFF)\n\t\treturn;\n\n\tif (state == VGA_SWITCHEROO_ON) {\n\t\tpr_err(\"VGA switcheroo: switched nouveau on\\n\");\n\t\tdev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\n\t\tnouveau_pmops_resume(&pdev->dev);\n\t\tdev->switch_power_state = DRM_SWITCH_POWER_ON;\n\t} else {\n\t\tpr_err(\"VGA switcheroo: switched nouveau off\\n\");\n\t\tdev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\n\t\tnouveau_switcheroo_optimus_dsm();\n\t\tnouveau_pmops_suspend(&pdev->dev);\n\t\tdev->switch_power_state = DRM_SWITCH_POWER_OFF;\n\t}\n}\n\nstatic void\nnouveau_switcheroo_reprobe(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\tdrm_fb_helper_output_poll_changed(dev);\n}\n\nstatic bool\nnouveau_switcheroo_can_switch(struct pci_dev *pdev)\n{\n\tstruct drm_device *dev = pci_get_drvdata(pdev);\n\n\t \n\treturn atomic_read(&dev->open_count) == 0;\n}\n\nstatic const struct vga_switcheroo_client_ops\nnouveau_switcheroo_ops = {\n\t.set_gpu_state = nouveau_switcheroo_set_state,\n\t.reprobe = nouveau_switcheroo_reprobe,\n\t.can_switch = nouveau_switcheroo_can_switch,\n};\n\nvoid\nnouveau_vga_init(struct nouveau_drm *drm)\n{\n\tstruct drm_device *dev = drm->dev;\n\tbool runtime = nouveau_pmops_runtime();\n\tstruct pci_dev *pdev;\n\n\t \n\tif (!dev_is_pci(dev->dev))\n\t\treturn;\n\tpdev = to_pci_dev(dev->dev);\n\n\tvga_client_register(pdev, nouveau_vga_set_decode);\n\n\t \n\tif (pci_is_thunderbolt_attached(pdev))\n\t\treturn;\n\n\tvga_switcheroo_register_client(pdev, &nouveau_switcheroo_ops, runtime);\n\n\tif (runtime && nouveau_is_v1_dsm() && !nouveau_is_optimus())\n\t\tvga_switcheroo_init_domain_pm_ops(drm->dev->dev, &drm->vga_pm_domain);\n}\n\nvoid\nnouveau_vga_fini(struct nouveau_drm *drm)\n{\n\tstruct drm_device *dev = drm->dev;\n\tbool runtime = nouveau_pmops_runtime();\n\tstruct pci_dev *pdev;\n\n\t \n\tif (!dev_is_pci(dev->dev))\n\t\treturn;\n\tpdev = to_pci_dev(dev->dev);\n\n\tvga_client_unregister(pdev);\n\n\tif (pci_is_thunderbolt_attached(pdev))\n\t\treturn;\n\n\tvga_switcheroo_unregister_client(pdev);\n\tif (runtime && nouveau_is_v1_dsm() && !nouveau_is_optimus())\n\t\tvga_switcheroo_fini_domain_pm_ops(drm->dev->dev);\n}\n\n\nvoid\nnouveau_vga_lastclose(struct drm_device *dev)\n{\n\tvga_switcheroo_process_delayed_switch();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}