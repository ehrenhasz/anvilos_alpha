{
  "module_name": "nouveau_gem.c",
  "hash_id": "f56d7d2696ff85bbf39e5242cc63d7758f82960ad6eec79fe9692273fd9e1725",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_gem.c",
  "human_readable_source": " \n\n#include <drm/drm_gem_ttm_helper.h>\n\n#include \"nouveau_drv.h\"\n#include \"nouveau_dma.h\"\n#include \"nouveau_fence.h\"\n#include \"nouveau_abi16.h\"\n\n#include \"nouveau_ttm.h\"\n#include \"nouveau_gem.h\"\n#include \"nouveau_mem.h\"\n#include \"nouveau_vmm.h\"\n\n#include <nvif/class.h>\n#include <nvif/push206e.h>\n\nstatic vm_fault_t nouveau_ttm_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct ttm_buffer_object *bo = vma->vm_private_data;\n\tpgprot_t prot;\n\tvm_fault_t ret;\n\n\tret = ttm_bo_vm_reserve(bo, vmf);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nouveau_ttm_fault_reserve_notify(bo);\n\tif (ret)\n\t\tgoto error_unlock;\n\n\tnouveau_bo_del_io_reserve_lru(bo);\n\tprot = vm_get_page_prot(vma->vm_flags);\n\tret = ttm_bo_vm_fault_reserved(vmf, prot, TTM_BO_VM_NUM_PREFAULT);\n\tnouveau_bo_add_io_reserve_lru(bo);\n\tif (ret == VM_FAULT_RETRY && !(vmf->flags & FAULT_FLAG_RETRY_NOWAIT))\n\t\treturn ret;\n\nerror_unlock:\n\tdma_resv_unlock(bo->base.resv);\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct nouveau_ttm_vm_ops = {\n\t.fault = nouveau_ttm_fault,\n\t.open = ttm_bo_vm_open,\n\t.close = ttm_bo_vm_close,\n\t.access = ttm_bo_vm_access\n};\n\nvoid\nnouveau_gem_object_del(struct drm_gem_object *gem)\n{\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(gem);\n\tstruct nouveau_drm *drm = nouveau_bdev(nvbo->bo.bdev);\n\tstruct device *dev = drm->dev->dev;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (WARN_ON(ret < 0 && ret != -EACCES)) {\n\t\tpm_runtime_put_autosuspend(dev);\n\t\treturn;\n\t}\n\n\tif (gem->import_attach)\n\t\tdrm_prime_gem_destroy(gem, nvbo->bo.sg);\n\n\tttm_bo_put(&nvbo->bo);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n\nint\nnouveau_gem_object_open(struct drm_gem_object *gem, struct drm_file *file_priv)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(gem);\n\tstruct nouveau_drm *drm = nouveau_bdev(nvbo->bo.bdev);\n\tstruct device *dev = drm->dev->dev;\n\tstruct nouveau_uvmm *uvmm = nouveau_cli_uvmm(cli);\n\tstruct nouveau_vmm *vmm = nouveau_cli_vmm(cli);\n\tstruct nouveau_vma *vma;\n\tint ret;\n\n\tif (vmm->vmm.object.oclass < NVIF_CLASS_VMM_NV50)\n\t\treturn 0;\n\n\tif (nvbo->no_share && uvmm && &uvmm->resv != nvbo->bo.base.resv)\n\t\treturn -EPERM;\n\n\tret = ttm_bo_reserve(&nvbo->bo, false, false, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(dev);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!nouveau_cli_uvmm(cli))\n\t\tret = nouveau_vma_new(nvbo, vmm, &vma);\n\telse\n\t\tret = 0;\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\nout:\n\tttm_bo_unreserve(&nvbo->bo);\n\treturn ret;\n}\n\nstruct nouveau_gem_object_unmap {\n\tstruct nouveau_cli_work work;\n\tstruct nouveau_vma *vma;\n};\n\nstatic void\nnouveau_gem_object_delete(struct nouveau_vma *vma)\n{\n\tnouveau_fence_unref(&vma->fence);\n\tnouveau_vma_del(&vma);\n}\n\nstatic void\nnouveau_gem_object_delete_work(struct nouveau_cli_work *w)\n{\n\tstruct nouveau_gem_object_unmap *work =\n\t\tcontainer_of(w, typeof(*work), work);\n\tnouveau_gem_object_delete(work->vma);\n\tkfree(work);\n}\n\nstatic void\nnouveau_gem_object_unmap(struct nouveau_bo *nvbo, struct nouveau_vma *vma)\n{\n\tstruct dma_fence *fence = vma->fence ? &vma->fence->base : NULL;\n\tstruct nouveau_gem_object_unmap *work;\n\n\tlist_del_init(&vma->head);\n\n\tif (!fence) {\n\t\tnouveau_gem_object_delete(vma);\n\t\treturn;\n\t}\n\n\tif (!(work = kmalloc(sizeof(*work), GFP_KERNEL))) {\n\t\tWARN_ON(dma_fence_wait_timeout(fence, false, 2 * HZ) <= 0);\n\t\tnouveau_gem_object_delete(vma);\n\t\treturn;\n\t}\n\n\twork->work.func = nouveau_gem_object_delete_work;\n\twork->vma = vma;\n\tnouveau_cli_work_queue(vma->vmm->cli, fence, &work->work);\n}\n\nvoid\nnouveau_gem_object_close(struct drm_gem_object *gem, struct drm_file *file_priv)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(gem);\n\tstruct nouveau_drm *drm = nouveau_bdev(nvbo->bo.bdev);\n\tstruct device *dev = drm->dev->dev;\n\tstruct nouveau_vmm *vmm = nouveau_cli_vmm(cli);\n\tstruct nouveau_vma *vma;\n\tint ret;\n\n\tif (vmm->vmm.object.oclass < NVIF_CLASS_VMM_NV50)\n\t\treturn;\n\n\tif (nouveau_cli_uvmm(cli))\n\t\treturn;\n\n\tret = ttm_bo_reserve(&nvbo->bo, false, false, NULL);\n\tif (ret)\n\t\treturn;\n\n\tvma = nouveau_vma_find(nvbo, vmm);\n\tif (vma) {\n\t\tif (--vma->refs == 0) {\n\t\t\tret = pm_runtime_get_sync(dev);\n\t\t\tif (!WARN_ON(ret < 0 && ret != -EACCES)) {\n\t\t\t\tnouveau_gem_object_unmap(nvbo, vma);\n\t\t\t\tpm_runtime_mark_last_busy(dev);\n\t\t\t}\n\t\t\tpm_runtime_put_autosuspend(dev);\n\t\t}\n\t}\n\tttm_bo_unreserve(&nvbo->bo);\n}\n\nconst struct drm_gem_object_funcs nouveau_gem_object_funcs = {\n\t.free = nouveau_gem_object_del,\n\t.open = nouveau_gem_object_open,\n\t.close = nouveau_gem_object_close,\n\t.export = nouveau_gem_prime_export,\n\t.pin = nouveau_gem_prime_pin,\n\t.unpin = nouveau_gem_prime_unpin,\n\t.get_sg_table = nouveau_gem_prime_get_sg_table,\n\t.vmap = drm_gem_ttm_vmap,\n\t.vunmap = drm_gem_ttm_vunmap,\n\t.mmap = drm_gem_ttm_mmap,\n\t.vm_ops = &nouveau_ttm_vm_ops,\n};\n\nint\nnouveau_gem_new(struct nouveau_cli *cli, u64 size, int align, uint32_t domain,\n\t\tuint32_t tile_mode, uint32_t tile_flags,\n\t\tstruct nouveau_bo **pnvbo)\n{\n\tstruct nouveau_drm *drm = cli->drm;\n\tstruct nouveau_uvmm *uvmm = nouveau_cli_uvmm(cli);\n\tstruct dma_resv *resv = NULL;\n\tstruct nouveau_bo *nvbo;\n\tint ret;\n\n\tif (domain & NOUVEAU_GEM_DOMAIN_NO_SHARE) {\n\t\tif (unlikely(!uvmm))\n\t\t\treturn -EINVAL;\n\n\t\tresv = &uvmm->resv;\n\t}\n\n\tif (!(domain & (NOUVEAU_GEM_DOMAIN_VRAM | NOUVEAU_GEM_DOMAIN_GART)))\n\t\tdomain |= NOUVEAU_GEM_DOMAIN_CPU;\n\n\tnvbo = nouveau_bo_alloc(cli, &size, &align, domain, tile_mode,\n\t\t\t\ttile_flags, false);\n\tif (IS_ERR(nvbo))\n\t\treturn PTR_ERR(nvbo);\n\n\tnvbo->bo.base.funcs = &nouveau_gem_object_funcs;\n\tnvbo->no_share = domain & NOUVEAU_GEM_DOMAIN_NO_SHARE;\n\n\t \n\tret = drm_gem_object_init(drm->dev, &nvbo->bo.base, size);\n\tif (ret) {\n\t\tdrm_gem_object_release(&nvbo->bo.base);\n\t\tkfree(nvbo);\n\t\treturn ret;\n\t}\n\n\tif (resv)\n\t\tdma_resv_lock(resv, NULL);\n\n\tret = nouveau_bo_init(nvbo, size, align, domain, NULL, resv);\n\n\tif (resv)\n\t\tdma_resv_unlock(resv);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnvbo->valid_domains = NOUVEAU_GEM_DOMAIN_VRAM |\n\t\t\t      NOUVEAU_GEM_DOMAIN_GART;\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_TESLA)\n\t\tnvbo->valid_domains &= domain;\n\n\t*pnvbo = nvbo;\n\treturn 0;\n}\n\nstatic int\nnouveau_gem_info(struct drm_file *file_priv, struct drm_gem_object *gem,\n\t\t struct drm_nouveau_gem_info *rep)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(gem);\n\tstruct nouveau_vmm *vmm = nouveau_cli_vmm(cli);\n\tstruct nouveau_vma *vma;\n\n\tif (is_power_of_2(nvbo->valid_domains))\n\t\trep->domain = nvbo->valid_domains;\n\telse if (nvbo->bo.resource->mem_type == TTM_PL_TT)\n\t\trep->domain = NOUVEAU_GEM_DOMAIN_GART;\n\telse\n\t\trep->domain = NOUVEAU_GEM_DOMAIN_VRAM;\n\trep->offset = nvbo->offset;\n\tif (vmm->vmm.object.oclass >= NVIF_CLASS_VMM_NV50 &&\n\t    !nouveau_cli_uvmm(cli)) {\n\t\tvma = nouveau_vma_find(nvbo, vmm);\n\t\tif (!vma)\n\t\t\treturn -EINVAL;\n\n\t\trep->offset = vma->addr;\n\t} else\n\t\trep->offset = 0;\n\n\trep->size = nvbo->bo.base.size;\n\trep->map_handle = drm_vma_node_offset_addr(&nvbo->bo.base.vma_node);\n\trep->tile_mode = nvbo->mode;\n\trep->tile_flags = nvbo->contig ? 0 : NOUVEAU_GEM_TILE_NONCONTIG;\n\tif (cli->device.info.family >= NV_DEVICE_INFO_V0_FERMI)\n\t\trep->tile_flags |= nvbo->kind << 8;\n\telse\n\tif (cli->device.info.family >= NV_DEVICE_INFO_V0_TESLA)\n\t\trep->tile_flags |= nvbo->kind << 8 | nvbo->comp << 16;\n\telse\n\t\trep->tile_flags |= nvbo->zeta;\n\treturn 0;\n}\n\nint\nnouveau_gem_ioctl_new(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct drm_nouveau_gem_new *req = data;\n\tstruct nouveau_bo *nvbo = NULL;\n\tint ret = 0;\n\n\t \n\tnouveau_cli_disable_uvmm_noinit(cli);\n\n\tret = nouveau_gem_new(cli, req->info.size, req->align,\n\t\t\t      req->info.domain, req->info.tile_mode,\n\t\t\t      req->info.tile_flags, &nvbo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = drm_gem_handle_create(file_priv, &nvbo->bo.base,\n\t\t\t\t    &req->info.handle);\n\tif (ret == 0) {\n\t\tret = nouveau_gem_info(file_priv, &nvbo->bo.base, &req->info);\n\t\tif (ret)\n\t\t\tdrm_gem_handle_delete(file_priv, req->info.handle);\n\t}\n\n\t \n\tdrm_gem_object_put(&nvbo->bo.base);\n\treturn ret;\n}\n\nstatic int\nnouveau_gem_set_domain(struct drm_gem_object *gem, uint32_t read_domains,\n\t\t       uint32_t write_domains, uint32_t valid_domains)\n{\n\tstruct nouveau_bo *nvbo = nouveau_gem_object(gem);\n\tstruct ttm_buffer_object *bo = &nvbo->bo;\n\tuint32_t domains = valid_domains & nvbo->valid_domains &\n\t\t(write_domains ? write_domains : read_domains);\n\tuint32_t pref_domains = 0;\n\n\tif (!domains)\n\t\treturn -EINVAL;\n\n\tvalid_domains &= ~(NOUVEAU_GEM_DOMAIN_VRAM | NOUVEAU_GEM_DOMAIN_GART);\n\n\tif ((domains & NOUVEAU_GEM_DOMAIN_VRAM) &&\n\t    bo->resource->mem_type == TTM_PL_VRAM)\n\t\tpref_domains |= NOUVEAU_GEM_DOMAIN_VRAM;\n\n\telse if ((domains & NOUVEAU_GEM_DOMAIN_GART) &&\n\t\t bo->resource->mem_type == TTM_PL_TT)\n\t\tpref_domains |= NOUVEAU_GEM_DOMAIN_GART;\n\n\telse if (domains & NOUVEAU_GEM_DOMAIN_VRAM)\n\t\tpref_domains |= NOUVEAU_GEM_DOMAIN_VRAM;\n\n\telse\n\t\tpref_domains |= NOUVEAU_GEM_DOMAIN_GART;\n\n\tnouveau_bo_placement_set(nvbo, pref_domains, valid_domains);\n\n\treturn 0;\n}\n\nstruct validate_op {\n\tstruct list_head list;\n\tstruct ww_acquire_ctx ticket;\n};\n\nstatic void\nvalidate_fini_no_ticket(struct validate_op *op, struct nouveau_channel *chan,\n\t\t\tstruct nouveau_fence *fence,\n\t\t\tstruct drm_nouveau_gem_pushbuf_bo *pbbo)\n{\n\tstruct nouveau_bo *nvbo;\n\tstruct drm_nouveau_gem_pushbuf_bo *b;\n\n\twhile (!list_empty(&op->list)) {\n\t\tnvbo = list_entry(op->list.next, struct nouveau_bo, entry);\n\t\tb = &pbbo[nvbo->pbbo_index];\n\n\t\tif (likely(fence)) {\n\t\t\tnouveau_bo_fence(nvbo, fence, !!b->write_domains);\n\n\t\t\tif (chan->vmm->vmm.object.oclass >= NVIF_CLASS_VMM_NV50) {\n\t\t\t\tstruct nouveau_vma *vma =\n\t\t\t\t\t(void *)(unsigned long)b->user_priv;\n\t\t\t\tnouveau_fence_unref(&vma->fence);\n\t\t\t\tdma_fence_get(&fence->base);\n\t\t\t\tvma->fence = fence;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(nvbo->validate_mapped)) {\n\t\t\tttm_bo_kunmap(&nvbo->kmap);\n\t\t\tnvbo->validate_mapped = false;\n\t\t}\n\n\t\tlist_del(&nvbo->entry);\n\t\tnvbo->reserved_by = NULL;\n\t\tttm_bo_unreserve(&nvbo->bo);\n\t\tdrm_gem_object_put(&nvbo->bo.base);\n\t}\n}\n\nstatic void\nvalidate_fini(struct validate_op *op, struct nouveau_channel *chan,\n\t      struct nouveau_fence *fence,\n\t      struct drm_nouveau_gem_pushbuf_bo *pbbo)\n{\n\tvalidate_fini_no_ticket(op, chan, fence, pbbo);\n\tww_acquire_fini(&op->ticket);\n}\n\nstatic int\nvalidate_init(struct nouveau_channel *chan, struct drm_file *file_priv,\n\t      struct drm_nouveau_gem_pushbuf_bo *pbbo,\n\t      int nr_buffers, struct validate_op *op)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tint trycnt = 0;\n\tint ret = -EINVAL, i;\n\tstruct nouveau_bo *res_bo = NULL;\n\tLIST_HEAD(gart_list);\n\tLIST_HEAD(vram_list);\n\tLIST_HEAD(both_list);\n\n\tww_acquire_init(&op->ticket, &reservation_ww_class);\nretry:\n\tif (++trycnt > 100000) {\n\t\tNV_PRINTK(err, cli, \"%s failed and gave up.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < nr_buffers; i++) {\n\t\tstruct drm_nouveau_gem_pushbuf_bo *b = &pbbo[i];\n\t\tstruct drm_gem_object *gem;\n\t\tstruct nouveau_bo *nvbo;\n\n\t\tgem = drm_gem_object_lookup(file_priv, b->handle);\n\t\tif (!gem) {\n\t\t\tNV_PRINTK(err, cli, \"Unknown handle 0x%08x\\n\", b->handle);\n\t\t\tret = -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tnvbo = nouveau_gem_object(gem);\n\t\tif (nvbo == res_bo) {\n\t\t\tres_bo = NULL;\n\t\t\tdrm_gem_object_put(gem);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (nvbo->reserved_by && nvbo->reserved_by == file_priv) {\n\t\t\tNV_PRINTK(err, cli, \"multiple instances of buffer %d on \"\n\t\t\t\t      \"validation list\\n\", b->handle);\n\t\t\tdrm_gem_object_put(gem);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ttm_bo_reserve(&nvbo->bo, true, false, &op->ticket);\n\t\tif (ret) {\n\t\t\tlist_splice_tail_init(&vram_list, &op->list);\n\t\t\tlist_splice_tail_init(&gart_list, &op->list);\n\t\t\tlist_splice_tail_init(&both_list, &op->list);\n\t\t\tvalidate_fini_no_ticket(op, chan, NULL, NULL);\n\t\t\tif (unlikely(ret == -EDEADLK)) {\n\t\t\t\tret = ttm_bo_reserve_slowpath(&nvbo->bo, true,\n\t\t\t\t\t\t\t      &op->ticket);\n\t\t\t\tif (!ret)\n\t\t\t\t\tres_bo = nvbo;\n\t\t\t}\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret != -ERESTARTSYS)\n\t\t\t\t\tNV_PRINTK(err, cli, \"fail reserve\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (chan->vmm->vmm.object.oclass >= NVIF_CLASS_VMM_NV50) {\n\t\t\tstruct nouveau_vmm *vmm = chan->vmm;\n\t\t\tstruct nouveau_vma *vma = nouveau_vma_find(nvbo, vmm);\n\t\t\tif (!vma) {\n\t\t\t\tNV_PRINTK(err, cli, \"vma not found!\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tb->user_priv = (uint64_t)(unsigned long)vma;\n\t\t} else {\n\t\t\tb->user_priv = (uint64_t)(unsigned long)nvbo;\n\t\t}\n\n\t\tnvbo->reserved_by = file_priv;\n\t\tnvbo->pbbo_index = i;\n\t\tif ((b->valid_domains & NOUVEAU_GEM_DOMAIN_VRAM) &&\n\t\t    (b->valid_domains & NOUVEAU_GEM_DOMAIN_GART))\n\t\t\tlist_add_tail(&nvbo->entry, &both_list);\n\t\telse\n\t\tif (b->valid_domains & NOUVEAU_GEM_DOMAIN_VRAM)\n\t\t\tlist_add_tail(&nvbo->entry, &vram_list);\n\t\telse\n\t\tif (b->valid_domains & NOUVEAU_GEM_DOMAIN_GART)\n\t\t\tlist_add_tail(&nvbo->entry, &gart_list);\n\t\telse {\n\t\t\tNV_PRINTK(err, cli, \"invalid valid domains: 0x%08x\\n\",\n\t\t\t\t b->valid_domains);\n\t\t\tlist_add_tail(&nvbo->entry, &both_list);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (nvbo == res_bo)\n\t\t\tgoto retry;\n\t}\n\n\tww_acquire_done(&op->ticket);\n\tlist_splice_tail(&vram_list, &op->list);\n\tlist_splice_tail(&gart_list, &op->list);\n\tlist_splice_tail(&both_list, &op->list);\n\tif (ret)\n\t\tvalidate_fini(op, chan, NULL, NULL);\n\treturn ret;\n\n}\n\nstatic int\nvalidate_list(struct nouveau_channel *chan, struct nouveau_cli *cli,\n\t      struct list_head *list, struct drm_nouveau_gem_pushbuf_bo *pbbo)\n{\n\tstruct nouveau_drm *drm = chan->drm;\n\tstruct nouveau_bo *nvbo;\n\tint ret, relocs = 0;\n\n\tlist_for_each_entry(nvbo, list, entry) {\n\t\tstruct drm_nouveau_gem_pushbuf_bo *b = &pbbo[nvbo->pbbo_index];\n\n\t\tret = nouveau_gem_set_domain(&nvbo->bo.base, b->read_domains,\n\t\t\t\t\t     b->write_domains,\n\t\t\t\t\t     b->valid_domains);\n\t\tif (unlikely(ret)) {\n\t\t\tNV_PRINTK(err, cli, \"fail set_domain\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = nouveau_bo_validate(nvbo, true, false);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret != -ERESTARTSYS)\n\t\t\t\tNV_PRINTK(err, cli, \"fail ttm_validate\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = nouveau_fence_sync(nvbo, chan, !!b->write_domains, true);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret != -ERESTARTSYS)\n\t\t\t\tNV_PRINTK(err, cli, \"fail post-validate sync\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA) {\n\t\t\tif (nvbo->offset == b->presumed.offset &&\n\t\t\t    ((nvbo->bo.resource->mem_type == TTM_PL_VRAM &&\n\t\t\t      b->presumed.domain & NOUVEAU_GEM_DOMAIN_VRAM) ||\n\t\t\t     (nvbo->bo.resource->mem_type == TTM_PL_TT &&\n\t\t\t      b->presumed.domain & NOUVEAU_GEM_DOMAIN_GART)))\n\t\t\t\tcontinue;\n\n\t\t\tif (nvbo->bo.resource->mem_type == TTM_PL_TT)\n\t\t\t\tb->presumed.domain = NOUVEAU_GEM_DOMAIN_GART;\n\t\t\telse\n\t\t\t\tb->presumed.domain = NOUVEAU_GEM_DOMAIN_VRAM;\n\t\t\tb->presumed.offset = nvbo->offset;\n\t\t\tb->presumed.valid = 0;\n\t\t\trelocs++;\n\t\t}\n\t}\n\n\treturn relocs;\n}\n\nstatic int\nnouveau_gem_pushbuf_validate(struct nouveau_channel *chan,\n\t\t\t     struct drm_file *file_priv,\n\t\t\t     struct drm_nouveau_gem_pushbuf_bo *pbbo,\n\t\t\t     int nr_buffers,\n\t\t\t     struct validate_op *op, bool *apply_relocs)\n{\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tint ret;\n\n\tINIT_LIST_HEAD(&op->list);\n\n\tif (nr_buffers == 0)\n\t\treturn 0;\n\n\tret = validate_init(chan, file_priv, pbbo, nr_buffers, op);\n\tif (unlikely(ret)) {\n\t\tif (ret != -ERESTARTSYS)\n\t\t\tNV_PRINTK(err, cli, \"validate_init\\n\");\n\t\treturn ret;\n\t}\n\n\tret = validate_list(chan, cli, &op->list, pbbo);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret != -ERESTARTSYS)\n\t\t\tNV_PRINTK(err, cli, \"validating bo list\\n\");\n\t\tvalidate_fini(op, chan, NULL, NULL);\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\t*apply_relocs = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnouveau_gem_pushbuf_reloc_apply(struct nouveau_cli *cli,\n\t\t\t\tstruct drm_nouveau_gem_pushbuf *req,\n\t\t\t\tstruct drm_nouveau_gem_pushbuf_reloc *reloc,\n\t\t\t\tstruct drm_nouveau_gem_pushbuf_bo *bo)\n{\n\tint ret = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < req->nr_relocs; i++) {\n\t\tstruct drm_nouveau_gem_pushbuf_reloc *r = &reloc[i];\n\t\tstruct drm_nouveau_gem_pushbuf_bo *b;\n\t\tstruct nouveau_bo *nvbo;\n\t\tuint32_t data;\n\t\tlong lret;\n\n\t\tif (unlikely(r->bo_index >= req->nr_buffers)) {\n\t\t\tNV_PRINTK(err, cli, \"reloc bo index invalid\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tb = &bo[r->bo_index];\n\t\tif (b->presumed.valid)\n\t\t\tcontinue;\n\n\t\tif (unlikely(r->reloc_bo_index >= req->nr_buffers)) {\n\t\t\tNV_PRINTK(err, cli, \"reloc container bo index invalid\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tnvbo = (void *)(unsigned long)bo[r->reloc_bo_index].user_priv;\n\n\t\tif (unlikely(r->reloc_bo_offset + 4 >\n\t\t\t     nvbo->bo.base.size)) {\n\t\t\tNV_PRINTK(err, cli, \"reloc outside of bo\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!nvbo->kmap.virtual) {\n\t\t\tret = ttm_bo_kmap(&nvbo->bo, 0, PFN_UP(nvbo->bo.base.size),\n\t\t\t\t\t  &nvbo->kmap);\n\t\t\tif (ret) {\n\t\t\t\tNV_PRINTK(err, cli, \"failed kmap for reloc\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnvbo->validate_mapped = true;\n\t\t}\n\n\t\tif (r->flags & NOUVEAU_GEM_RELOC_LOW)\n\t\t\tdata = b->presumed.offset + r->data;\n\t\telse\n\t\tif (r->flags & NOUVEAU_GEM_RELOC_HIGH)\n\t\t\tdata = (b->presumed.offset + r->data) >> 32;\n\t\telse\n\t\t\tdata = r->data;\n\n\t\tif (r->flags & NOUVEAU_GEM_RELOC_OR) {\n\t\t\tif (b->presumed.domain == NOUVEAU_GEM_DOMAIN_GART)\n\t\t\t\tdata |= r->tor;\n\t\t\telse\n\t\t\t\tdata |= r->vor;\n\t\t}\n\n\t\tlret = dma_resv_wait_timeout(nvbo->bo.base.resv,\n\t\t\t\t\t     DMA_RESV_USAGE_BOOKKEEP,\n\t\t\t\t\t     false, 15 * HZ);\n\t\tif (!lret)\n\t\t\tret = -EBUSY;\n\t\telse if (lret > 0)\n\t\t\tret = 0;\n\t\telse\n\t\t\tret = lret;\n\n\t\tif (ret) {\n\t\t\tNV_PRINTK(err, cli, \"reloc wait_idle failed: %d\\n\",\n\t\t\t\t  ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tnouveau_bo_wr32(nvbo, r->reloc_bo_offset >> 2, data);\n\t}\n\n\treturn ret;\n}\n\nint\nnouveau_gem_ioctl_pushbuf(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv);\n\tstruct nouveau_cli *cli = nouveau_cli(file_priv);\n\tstruct nouveau_abi16_chan *temp;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct drm_nouveau_gem_pushbuf *req = data;\n\tstruct drm_nouveau_gem_pushbuf_push *push;\n\tstruct drm_nouveau_gem_pushbuf_reloc *reloc = NULL;\n\tstruct drm_nouveau_gem_pushbuf_bo *bo;\n\tstruct nouveau_channel *chan = NULL;\n\tstruct validate_op op;\n\tstruct nouveau_fence *fence = NULL;\n\tint i, j, ret = 0;\n\tbool do_reloc = false, sync = false;\n\n\tif (unlikely(!abi16))\n\t\treturn -ENOMEM;\n\n\tif (unlikely(nouveau_cli_uvmm(cli)))\n\t\treturn -ENOSYS;\n\n\tlist_for_each_entry(temp, &abi16->channels, head) {\n\t\tif (temp->chan->chid == req->channel) {\n\t\t\tchan = temp->chan;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!chan)\n\t\treturn nouveau_abi16_put(abi16, -ENOENT);\n\tif (unlikely(atomic_read(&chan->killed)))\n\t\treturn nouveau_abi16_put(abi16, -ENODEV);\n\n\tsync = req->vram_available & NOUVEAU_GEM_PUSHBUF_SYNC;\n\n\treq->vram_available = drm->gem.vram_available;\n\treq->gart_available = drm->gem.gart_available;\n\tif (unlikely(req->nr_push == 0))\n\t\tgoto out_next;\n\n\tif (unlikely(req->nr_push > NOUVEAU_GEM_MAX_PUSH)) {\n\t\tNV_PRINTK(err, cli, \"pushbuf push count exceeds limit: %d max %d\\n\",\n\t\t\t req->nr_push, NOUVEAU_GEM_MAX_PUSH);\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\t}\n\n\tif (unlikely(req->nr_buffers > NOUVEAU_GEM_MAX_BUFFERS)) {\n\t\tNV_PRINTK(err, cli, \"pushbuf bo count exceeds limit: %d max %d\\n\",\n\t\t\t req->nr_buffers, NOUVEAU_GEM_MAX_BUFFERS);\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\t}\n\n\tif (unlikely(req->nr_relocs > NOUVEAU_GEM_MAX_RELOCS)) {\n\t\tNV_PRINTK(err, cli, \"pushbuf reloc count exceeds limit: %d max %d\\n\",\n\t\t\t req->nr_relocs, NOUVEAU_GEM_MAX_RELOCS);\n\t\treturn nouveau_abi16_put(abi16, -EINVAL);\n\t}\n\n\tpush = u_memcpya(req->push, req->nr_push, sizeof(*push));\n\tif (IS_ERR(push))\n\t\treturn nouveau_abi16_put(abi16, PTR_ERR(push));\n\n\tbo = u_memcpya(req->buffers, req->nr_buffers, sizeof(*bo));\n\tif (IS_ERR(bo)) {\n\t\tu_free(push);\n\t\treturn nouveau_abi16_put(abi16, PTR_ERR(bo));\n\t}\n\n\t \n\tfor (i = 0; i < req->nr_push; i++) {\n\t\tif (push[i].bo_index >= req->nr_buffers) {\n\t\t\tNV_PRINTK(err, cli, \"push %d buffer not in list\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_prevalid;\n\t\t}\n\t}\n\n\t \nrevalidate:\n\tret = nouveau_gem_pushbuf_validate(chan, file_priv, bo,\n\t\t\t\t\t   req->nr_buffers, &op, &do_reloc);\n\tif (ret) {\n\t\tif (ret != -ERESTARTSYS)\n\t\t\tNV_PRINTK(err, cli, \"validate: %d\\n\", ret);\n\t\tgoto out_prevalid;\n\t}\n\n\t \n\tif (do_reloc) {\n\t\tif (!reloc) {\n\t\t\tvalidate_fini(&op, chan, NULL, bo);\n\t\t\treloc = u_memcpya(req->relocs, req->nr_relocs, sizeof(*reloc));\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out_prevalid;\n\t\t\t}\n\n\t\t\tgoto revalidate;\n\t\t}\n\n\t\tret = nouveau_gem_pushbuf_reloc_apply(cli, req, reloc, bo);\n\t\tif (ret) {\n\t\t\tNV_PRINTK(err, cli, \"reloc apply: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (chan->dma.ib_max) {\n\t\tret = nouveau_dma_wait(chan, req->nr_push + 1, 16);\n\t\tif (ret) {\n\t\t\tNV_PRINTK(err, cli, \"nv50cal_space: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < req->nr_push; i++) {\n\t\t\tstruct nouveau_vma *vma = (void *)(unsigned long)\n\t\t\t\tbo[push[i].bo_index].user_priv;\n\t\t\tu64 addr = vma->addr + push[i].offset;\n\t\t\tu32 length = push[i].length & ~NOUVEAU_GEM_PUSHBUF_NO_PREFETCH;\n\t\t\tbool no_prefetch = push[i].length & NOUVEAU_GEM_PUSHBUF_NO_PREFETCH;\n\n\t\t\tnv50_dma_push(chan, addr, length, no_prefetch);\n\t\t}\n\t} else\n\tif (drm->client.device.info.chipset >= 0x25) {\n\t\tret = PUSH_WAIT(chan->chan.push, req->nr_push * 2);\n\t\tif (ret) {\n\t\t\tNV_PRINTK(err, cli, \"cal_space: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < req->nr_push; i++) {\n\t\t\tstruct nouveau_bo *nvbo = (void *)(unsigned long)\n\t\t\t\tbo[push[i].bo_index].user_priv;\n\n\t\t\tPUSH_CALL(chan->chan.push, nvbo->offset + push[i].offset);\n\t\t\tPUSH_DATA(chan->chan.push, 0);\n\t\t}\n\t} else {\n\t\tret = PUSH_WAIT(chan->chan.push, req->nr_push * (2 + NOUVEAU_DMA_SKIPS));\n\t\tif (ret) {\n\t\t\tNV_PRINTK(err, cli, \"jmp_space: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < req->nr_push; i++) {\n\t\t\tstruct nouveau_bo *nvbo = (void *)(unsigned long)\n\t\t\t\tbo[push[i].bo_index].user_priv;\n\t\t\tuint32_t cmd;\n\n\t\t\tcmd = chan->push.addr + ((chan->dma.cur + 2) << 2);\n\t\t\tcmd |= 0x20000000;\n\t\t\tif (unlikely(cmd != req->suffix0)) {\n\t\t\t\tif (!nvbo->kmap.virtual) {\n\t\t\t\t\tret = ttm_bo_kmap(&nvbo->bo, 0,\n\t\t\t\t\t\t\t  PFN_UP(nvbo->bo.base.size),\n\t\t\t\t\t\t\t  &nvbo->kmap);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tWIND_RING(chan);\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tnvbo->validate_mapped = true;\n\t\t\t\t}\n\n\t\t\t\tnouveau_bo_wr32(nvbo, (push[i].offset +\n\t\t\t\t\t\tpush[i].length - 8) / 4, cmd);\n\t\t\t}\n\n\t\t\tPUSH_JUMP(chan->chan.push, nvbo->offset + push[i].offset);\n\t\t\tPUSH_DATA(chan->chan.push, 0);\n\t\t\tfor (j = 0; j < NOUVEAU_DMA_SKIPS; j++)\n\t\t\t\tPUSH_DATA(chan->chan.push, 0);\n\t\t}\n\t}\n\n\tret = nouveau_fence_new(&fence, chan);\n\tif (ret) {\n\t\tNV_PRINTK(err, cli, \"error fencing pushbuf: %d\\n\", ret);\n\t\tWIND_RING(chan);\n\t\tgoto out;\n\t}\n\n\tif (sync) {\n\t\tif (!(ret = nouveau_fence_wait(fence, false, false))) {\n\t\t\tif ((ret = dma_fence_get_status(&fence->base)) == 1)\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\nout:\n\tvalidate_fini(&op, chan, fence, bo);\n\tnouveau_fence_unref(&fence);\n\n\tif (do_reloc) {\n\t\tstruct drm_nouveau_gem_pushbuf_bo __user *upbbo =\n\t\t\tu64_to_user_ptr(req->buffers);\n\n\t\tfor (i = 0; i < req->nr_buffers; i++) {\n\t\t\tif (bo[i].presumed.valid)\n\t\t\t\tcontinue;\n\n\t\t\tif (copy_to_user(&upbbo[i].presumed, &bo[i].presumed,\n\t\t\t\t\t sizeof(bo[i].presumed))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\nout_prevalid:\n\tif (!IS_ERR(reloc))\n\t\tu_free(reloc);\n\tu_free(bo);\n\tu_free(push);\n\nout_next:\n\tif (chan->dma.ib_max) {\n\t\treq->suffix0 = 0x00000000;\n\t\treq->suffix1 = 0x00000000;\n\t} else\n\tif (drm->client.device.info.chipset >= 0x25) {\n\t\treq->suffix0 = 0x00020000;\n\t\treq->suffix1 = 0x00000000;\n\t} else {\n\t\treq->suffix0 = 0x20000000 |\n\t\t\t      (chan->push.addr + ((chan->dma.cur + 2) << 2));\n\t\treq->suffix1 = 0x00000000;\n\t}\n\n\treturn nouveau_abi16_put(abi16, ret);\n}\n\nint\nnouveau_gem_ioctl_cpu_prep(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_nouveau_gem_cpu_prep *req = data;\n\tstruct drm_gem_object *gem;\n\tstruct nouveau_bo *nvbo;\n\tbool no_wait = !!(req->flags & NOUVEAU_GEM_CPU_PREP_NOWAIT);\n\tbool write = !!(req->flags & NOUVEAU_GEM_CPU_PREP_WRITE);\n\tlong lret;\n\tint ret;\n\n\tgem = drm_gem_object_lookup(file_priv, req->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\tnvbo = nouveau_gem_object(gem);\n\n\tlret = dma_resv_wait_timeout(nvbo->bo.base.resv,\n\t\t\t\t     dma_resv_usage_rw(write), true,\n\t\t\t\t     no_wait ? 0 : 30 * HZ);\n\tif (!lret)\n\t\tret = -EBUSY;\n\telse if (lret > 0)\n\t\tret = 0;\n\telse\n\t\tret = lret;\n\n\tnouveau_bo_sync_for_cpu(nvbo);\n\tdrm_gem_object_put(gem);\n\n\treturn ret;\n}\n\nint\nnouveau_gem_ioctl_cpu_fini(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file_priv)\n{\n\tstruct drm_nouveau_gem_cpu_fini *req = data;\n\tstruct drm_gem_object *gem;\n\tstruct nouveau_bo *nvbo;\n\n\tgem = drm_gem_object_lookup(file_priv, req->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\tnvbo = nouveau_gem_object(gem);\n\n\tnouveau_bo_sync_for_device(nvbo);\n\tdrm_gem_object_put(gem);\n\treturn 0;\n}\n\nint\nnouveau_gem_ioctl_info(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv)\n{\n\tstruct drm_nouveau_gem_info *req = data;\n\tstruct drm_gem_object *gem;\n\tint ret;\n\n\tgem = drm_gem_object_lookup(file_priv, req->handle);\n\tif (!gem)\n\t\treturn -ENOENT;\n\n\tret = nouveau_gem_info(file_priv, gem, req);\n\tdrm_gem_object_put(gem);\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}