{
  "module_name": "nouveau_debugfs.c",
  "hash_id": "c8173c7c95e4bcc4105057dc3e8b00a7e06afc32f5e7f0f44e1d62b50375737b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nouveau_debugfs.c",
  "human_readable_source": " \n\n \n\n#include <linux/debugfs.h>\n#include <nvif/class.h>\n#include <nvif/if0001.h>\n#include \"nouveau_debugfs.h\"\n#include \"nouveau_drv.h\"\n\nstatic int\nnouveau_debugfs_vbios_image(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct nouveau_drm *drm = nouveau_drm(node->minor->dev);\n\tint i;\n\n\tfor (i = 0; i < drm->vbios.length; i++)\n\t\tseq_printf(m, \"%c\", drm->vbios.data[i]);\n\treturn 0;\n}\n\nstatic int\nnouveau_debugfs_strap_peek(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = m->private;\n\tstruct nouveau_drm *drm = nouveau_drm(node->minor->dev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(drm->dev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(drm->dev->dev);\n\t\treturn ret;\n\t}\n\n\tseq_printf(m, \"0x%08x\\n\",\n\t\t   nvif_rd32(&drm->client.device.object, 0x101000));\n\n\tpm_runtime_mark_last_busy(drm->dev->dev);\n\tpm_runtime_put_autosuspend(drm->dev->dev);\n\n\treturn 0;\n}\n\nstatic int\nnouveau_debugfs_pstate_get(struct seq_file *m, void *data)\n{\n\tstruct drm_device *drm = m->private;\n\tstruct nouveau_debugfs *debugfs = nouveau_debugfs(drm);\n\tstruct nvif_object *ctrl;\n\tstruct nvif_control_pstate_info_v0 info = {};\n\tint ret, i;\n\n\tif (!debugfs)\n\t\treturn -ENODEV;\n\n\tctrl = &debugfs->ctrl;\n\tret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_INFO, &info, sizeof(info));\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < info.count + 1; i++) {\n\t\tconst s32 state = i < info.count ? i :\n\t\t\tNVIF_CONTROL_PSTATE_ATTR_V0_STATE_CURRENT;\n\t\tstruct nvif_control_pstate_attr_v0 attr = {\n\t\t\t.state = state,\n\t\t\t.index = 0,\n\t\t};\n\n\t\tret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_ATTR,\n\t\t\t\t&attr, sizeof(attr));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (i < info.count)\n\t\t\tseq_printf(m, \"%02x:\", attr.state);\n\t\telse\n\t\t\tseq_printf(m, \"%s:\", info.pwrsrc == 0 ? \"DC\" :\n\t\t\t\t\t     info.pwrsrc == 1 ? \"AC\" : \"--\");\n\n\t\tattr.index = 0;\n\t\tdo {\n\t\t\tattr.state = state;\n\t\t\tret = nvif_mthd(ctrl, NVIF_CONTROL_PSTATE_ATTR,\n\t\t\t\t\t&attr, sizeof(attr));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tseq_printf(m, \" %s %d\", attr.name, attr.min);\n\t\t\tif (attr.min != attr.max)\n\t\t\t\tseq_printf(m, \"-%d\", attr.max);\n\t\t\tseq_printf(m, \" %s\", attr.unit);\n\t\t} while (attr.index);\n\n\t\tif (state >= 0) {\n\t\t\tif (info.ustate_ac == state)\n\t\t\t\tseq_puts(m, \" AC\");\n\t\t\tif (info.ustate_dc == state)\n\t\t\t\tseq_puts(m, \" DC\");\n\t\t\tif (info.pstate == state)\n\t\t\t\tseq_puts(m, \" *\");\n\t\t} else {\n\t\t\tif (info.ustate_ac < -1)\n\t\t\t\tseq_puts(m, \" AC\");\n\t\t\tif (info.ustate_dc < -1)\n\t\t\t\tseq_puts(m, \" DC\");\n\t\t}\n\n\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t\nnouveau_debugfs_pstate_set(struct file *file, const char __user *ubuf,\n\t\t\t   size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_device *drm = m->private;\n\tstruct nouveau_debugfs *debugfs = nouveau_debugfs(drm);\n\tstruct nvif_control_pstate_user_v0 args = { .pwrsrc = -EINVAL };\n\tchar buf[32] = {}, *tmp, *cur = buf;\n\tlong value, ret;\n\n\tif (!debugfs)\n\t\treturn -ENODEV;\n\n\tif (len >= sizeof(buf))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(buf, ubuf, len))\n\t\treturn -EFAULT;\n\n\tif ((tmp = strchr(buf, '\\n')))\n\t\t*tmp = '\\0';\n\n\tif (!strncasecmp(cur, \"dc:\", 3)) {\n\t\targs.pwrsrc = 0;\n\t\tcur += 3;\n\t} else\n\tif (!strncasecmp(cur, \"ac:\", 3)) {\n\t\targs.pwrsrc = 1;\n\t\tcur += 3;\n\t}\n\n\tif (!strcasecmp(cur, \"none\"))\n\t\targs.ustate = NVIF_CONTROL_PSTATE_USER_V0_STATE_UNKNOWN;\n\telse\n\tif (!strcasecmp(cur, \"auto\"))\n\t\targs.ustate = NVIF_CONTROL_PSTATE_USER_V0_STATE_PERFMON;\n\telse {\n\t\tret = kstrtol(cur, 16, &value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\targs.ustate = value;\n\t}\n\n\tret = pm_runtime_get_sync(drm->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tpm_runtime_put_autosuspend(drm->dev);\n\t\treturn ret;\n\t}\n\n\tret = nvif_mthd(&debugfs->ctrl, NVIF_CONTROL_PSTATE_USER,\n\t\t\t&args, sizeof(args));\n\tpm_runtime_put_autosuspend(drm->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn len;\n}\n\nstatic int\nnouveau_debugfs_pstate_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, nouveau_debugfs_pstate_get, inode->i_private);\n}\n\nstatic void\nnouveau_debugfs_gpuva_regions(struct seq_file *m, struct nouveau_uvmm *uvmm)\n{\n\tMA_STATE(mas, &uvmm->region_mt, 0, 0);\n\tstruct nouveau_uvma_region *reg;\n\n\tseq_puts  (m, \" VA regions  | start              | range              | end                \\n\");\n\tseq_puts  (m, \"----------------------------------------------------------------------------\\n\");\n\tmas_for_each(&mas, reg, ULONG_MAX)\n\t\tseq_printf(m, \"             | 0x%016llx | 0x%016llx | 0x%016llx\\n\",\n\t\t\t   reg->va.addr, reg->va.range, reg->va.addr + reg->va.range);\n}\n\nstatic int\nnouveau_debugfs_gpuva(struct seq_file *m, void *data)\n{\n\tstruct drm_info_node *node = (struct drm_info_node *) m->private;\n\tstruct nouveau_drm *drm = nouveau_drm(node->minor->dev);\n\tstruct nouveau_cli *cli;\n\n\tmutex_lock(&drm->clients_lock);\n\tlist_for_each_entry(cli, &drm->clients, head) {\n\t\tstruct nouveau_uvmm *uvmm = nouveau_cli_uvmm(cli);\n\n\t\tif (!uvmm)\n\t\t\tcontinue;\n\n\t\tnouveau_uvmm_lock(uvmm);\n\t\tdrm_debugfs_gpuva_info(m, &uvmm->umgr);\n\t\tseq_puts(m, \"\\n\");\n\t\tnouveau_debugfs_gpuva_regions(m, uvmm);\n\t\tnouveau_uvmm_unlock(uvmm);\n\t}\n\tmutex_unlock(&drm->clients_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations nouveau_pstate_fops = {\n\t.owner = THIS_MODULE,\n\t.open = nouveau_debugfs_pstate_open,\n\t.read = seq_read,\n\t.write = nouveau_debugfs_pstate_set,\n\t.release = single_release,\n};\n\nstatic struct drm_info_list nouveau_debugfs_list[] = {\n\t{ \"vbios.rom\",  nouveau_debugfs_vbios_image, 0, NULL },\n\t{ \"strap_peek\", nouveau_debugfs_strap_peek, 0, NULL },\n\tDRM_DEBUGFS_GPUVA_INFO(nouveau_debugfs_gpuva, NULL),\n};\n#define NOUVEAU_DEBUGFS_ENTRIES ARRAY_SIZE(nouveau_debugfs_list)\n\nstatic const struct nouveau_debugfs_files {\n\tconst char *name;\n\tconst struct file_operations *fops;\n} nouveau_debugfs_files[] = {\n\t{\"pstate\", &nouveau_pstate_fops},\n};\n\nvoid\nnouveau_drm_debugfs_init(struct drm_minor *minor)\n{\n\tstruct nouveau_drm *drm = nouveau_drm(minor->dev);\n\tstruct dentry *dentry;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nouveau_debugfs_files); i++) {\n\t\tdebugfs_create_file(nouveau_debugfs_files[i].name,\n\t\t\t\t    S_IRUGO | S_IWUSR,\n\t\t\t\t    minor->debugfs_root, minor->dev,\n\t\t\t\t    nouveau_debugfs_files[i].fops);\n\t}\n\n\tdrm_debugfs_create_files(nouveau_debugfs_list,\n\t\t\t\t NOUVEAU_DEBUGFS_ENTRIES,\n\t\t\t\t minor->debugfs_root, minor);\n\n\t \n\tdentry = debugfs_lookup(\"vbios.rom\", minor->debugfs_root);\n\tif (!dentry)\n\t\treturn;\n\n\td_inode(dentry)->i_size = drm->vbios.length;\n\tdput(dentry);\n}\n\nint\nnouveau_debugfs_init(struct nouveau_drm *drm)\n{\n\tdrm->debugfs = kzalloc(sizeof(*drm->debugfs), GFP_KERNEL);\n\tif (!drm->debugfs)\n\t\treturn -ENOMEM;\n\n\treturn nvif_object_ctor(&drm->client.device.object, \"debugfsCtrl\", 0,\n\t\t\t\tNVIF_CLASS_CONTROL, NULL, 0,\n\t\t\t\t&drm->debugfs->ctrl);\n}\n\nvoid\nnouveau_debugfs_fini(struct nouveau_drm *drm)\n{\n\tif (drm->debugfs && drm->debugfs->ctrl.priv)\n\t\tnvif_object_dtor(&drm->debugfs->ctrl);\n\n\tkfree(drm->debugfs);\n\tdrm->debugfs = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}