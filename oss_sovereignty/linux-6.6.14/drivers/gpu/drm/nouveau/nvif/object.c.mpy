{
  "module_name": "object.c",
  "hash_id": "602a15a37c06c62954ad48b6e0b2acaebf7294be41f3f492f5f6a59c7f3b514c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvif/object.c",
  "human_readable_source": " \n\n#include <nvif/object.h>\n#include <nvif/client.h>\n#include <nvif/driver.h>\n#include <nvif/ioctl.h>\n\nint\nnvif_object_ioctl(struct nvif_object *object, void *data, u32 size, void **hack)\n{\n\tstruct nvif_client *client = object->client;\n\tunion {\n\t\tstruct nvif_ioctl_v0 v0;\n\t} *args = data;\n\n\tif (size >= sizeof(*args) && args->v0.version == 0) {\n\t\tif (object != &client->object)\n\t\t\targs->v0.object = nvif_handle(object);\n\t\telse\n\t\t\targs->v0.object = 0;\n\t\targs->v0.owner = NVIF_IOCTL_V0_OWNER_ANY;\n\t} else\n\t\treturn -ENOSYS;\n\n\treturn client->driver->ioctl(client->object.priv, data, size, hack);\n}\n\nvoid\nnvif_object_sclass_put(struct nvif_sclass **psclass)\n{\n\tkfree(*psclass);\n\t*psclass = NULL;\n}\n\nint\nnvif_object_sclass_get(struct nvif_object *object, struct nvif_sclass **psclass)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_sclass_v0 sclass;\n\t} *args = NULL;\n\tint ret, cnt = 0, i;\n\tu32 size;\n\n\twhile (1) {\n\t\tsize = sizeof(*args) + cnt * sizeof(args->sclass.oclass[0]);\n\t\tif (!(args = kmalloc(size, GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\targs->ioctl.version = 0;\n\t\targs->ioctl.type = NVIF_IOCTL_V0_SCLASS;\n\t\targs->sclass.version = 0;\n\t\targs->sclass.count = cnt;\n\n\t\tret = nvif_object_ioctl(object, args, size, NULL);\n\t\tif (ret == 0 && args->sclass.count <= cnt)\n\t\t\tbreak;\n\t\tcnt = args->sclass.count;\n\t\tkfree(args);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t*psclass = kcalloc(args->sclass.count, sizeof(**psclass), GFP_KERNEL);\n\tif (*psclass) {\n\t\tfor (i = 0; i < args->sclass.count; i++) {\n\t\t\t(*psclass)[i].oclass = args->sclass.oclass[i].oclass;\n\t\t\t(*psclass)[i].minver = args->sclass.oclass[i].minver;\n\t\t\t(*psclass)[i].maxver = args->sclass.oclass[i].maxver;\n\t\t}\n\t\tret = args->sclass.count;\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\n\tkfree(args);\n\treturn ret;\n}\n\nu32\nnvif_object_rd(struct nvif_object *object, int size, u64 addr)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_rd_v0 rd;\n\t} args = {\n\t\t.ioctl.type = NVIF_IOCTL_V0_RD,\n\t\t.rd.size = size,\n\t\t.rd.addr = addr,\n\t};\n\tint ret = nvif_object_ioctl(object, &args, sizeof(args), NULL);\n\tif (ret) {\n\t\t \n\t\treturn 0;\n\t}\n\treturn args.rd.data;\n}\n\nvoid\nnvif_object_wr(struct nvif_object *object, int size, u64 addr, u32 data)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_wr_v0 wr;\n\t} args = {\n\t\t.ioctl.type = NVIF_IOCTL_V0_WR,\n\t\t.wr.size = size,\n\t\t.wr.addr = addr,\n\t\t.wr.data = data,\n\t};\n\tint ret = nvif_object_ioctl(object, &args, sizeof(args), NULL);\n\tif (ret) {\n\t\t \n\t}\n}\n\nint\nnvif_object_mthd(struct nvif_object *object, u32 mthd, void *data, u32 size)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_mthd_v0 mthd;\n\t} *args;\n\tu8 stack[128];\n\tint ret;\n\n\tif (sizeof(*args) + size > sizeof(stack)) {\n\t\tif (!(args = kmalloc(sizeof(*args) + size, GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\targs = (void *)stack;\n\t}\n\targs->ioctl.version = 0;\n\targs->ioctl.type = NVIF_IOCTL_V0_MTHD;\n\targs->mthd.version = 0;\n\targs->mthd.method = mthd;\n\n\tmemcpy(args->mthd.data, data, size);\n\tret = nvif_object_ioctl(object, args, sizeof(*args) + size, NULL);\n\tmemcpy(data, args->mthd.data, size);\n\tif (args != (void *)stack)\n\t\tkfree(args);\n\treturn ret;\n}\n\nvoid\nnvif_object_unmap_handle(struct nvif_object *object)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_unmap unmap;\n\t} args = {\n\t\t.ioctl.type = NVIF_IOCTL_V0_UNMAP,\n\t};\n\n\tnvif_object_ioctl(object, &args, sizeof(args), NULL);\n}\n\nint\nnvif_object_map_handle(struct nvif_object *object, void *argv, u32 argc,\n\t\t       u64 *handle, u64 *length)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_map_v0 map;\n\t} *args;\n\tu32 argn = sizeof(*args) + argc;\n\tint ret, maptype;\n\n\tif (!(args = kzalloc(argn, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\targs->ioctl.type = NVIF_IOCTL_V0_MAP;\n\tmemcpy(args->map.data, argv, argc);\n\n\tret = nvif_object_ioctl(object, args, argn, NULL);\n\t*handle = args->map.handle;\n\t*length = args->map.length;\n\tmaptype = args->map.type;\n\tkfree(args);\n\treturn ret ? ret : (maptype == NVIF_IOCTL_MAP_V0_IO);\n}\n\nvoid\nnvif_object_unmap(struct nvif_object *object)\n{\n\tstruct nvif_client *client = object->client;\n\tif (object->map.ptr) {\n\t\tif (object->map.size) {\n\t\t\tclient->driver->unmap(client, object->map.ptr,\n\t\t\t\t\t\t      object->map.size);\n\t\t\tobject->map.size = 0;\n\t\t}\n\t\tobject->map.ptr = NULL;\n\t\tnvif_object_unmap_handle(object);\n\t}\n}\n\nint\nnvif_object_map(struct nvif_object *object, void *argv, u32 argc)\n{\n\tstruct nvif_client *client = object->client;\n\tu64 handle, length;\n\tint ret = nvif_object_map_handle(object, argv, argc, &handle, &length);\n\tif (ret >= 0) {\n\t\tif (ret) {\n\t\t\tobject->map.ptr = client->driver->map(client,\n\t\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t\t      length);\n\t\t\tif (ret = -ENOMEM, object->map.ptr) {\n\t\t\t\tobject->map.size = length;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tobject->map.ptr = (void *)(unsigned long)handle;\n\t\t\treturn 0;\n\t\t}\n\t\tnvif_object_unmap_handle(object);\n\t}\n\treturn ret;\n}\n\nvoid\nnvif_object_dtor(struct nvif_object *object)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_del del;\n\t} args = {\n\t\t.ioctl.type = NVIF_IOCTL_V0_DEL,\n\t};\n\n\tif (!nvif_object_constructed(object))\n\t\treturn;\n\n\tnvif_object_unmap(object);\n\tnvif_object_ioctl(object, &args, sizeof(args), NULL);\n\tobject->client = NULL;\n}\n\nint\nnvif_object_ctor(struct nvif_object *parent, const char *name, u32 handle,\n\t\t s32 oclass, void *data, u32 size, struct nvif_object *object)\n{\n\tstruct {\n\t\tstruct nvif_ioctl_v0 ioctl;\n\t\tstruct nvif_ioctl_new_v0 new;\n\t} *args;\n\tint ret = 0;\n\n\tobject->client = NULL;\n\tobject->name = name ? name : \"nvifObject\";\n\tobject->handle = handle;\n\tobject->oclass = oclass;\n\tobject->map.ptr = NULL;\n\tobject->map.size = 0;\n\n\tif (parent) {\n\t\tif (!(args = kmalloc(sizeof(*args) + size, GFP_KERNEL))) {\n\t\t\tnvif_object_dtor(object);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tobject->parent = parent->parent;\n\n\t\targs->ioctl.version = 0;\n\t\targs->ioctl.type = NVIF_IOCTL_V0_NEW;\n\t\targs->new.version = 0;\n\t\targs->new.route = parent->client->route;\n\t\targs->new.token = nvif_handle(object);\n\t\targs->new.object = nvif_handle(object);\n\t\targs->new.handle = handle;\n\t\targs->new.oclass = oclass;\n\n\t\tmemcpy(args->new.data, data, size);\n\t\tret = nvif_object_ioctl(parent, args, sizeof(*args) + size,\n\t\t\t\t\t&object->priv);\n\t\tmemcpy(data, args->new.data, size);\n\t\tkfree(args);\n\t\tif (ret == 0)\n\t\t\tobject->client = parent->client;\n\t}\n\n\tif (ret)\n\t\tnvif_object_dtor(object);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}