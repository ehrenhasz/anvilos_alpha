{
  "module_name": "mem.c",
  "hash_id": "e265776a2a46c4a28af93ac1c9f5d761fd55cfb2e7153d47323cad03254c280c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvif/mem.c",
  "human_readable_source": " \n#include <nvif/mem.h>\n#include <nvif/client.h>\n\n#include <nvif/if000a.h>\n\nint\nnvif_mem_ctor_map(struct nvif_mmu *mmu, const char *name, u8 type, u64 size,\n\t\t  struct nvif_mem *mem)\n{\n\tint ret = nvif_mem_ctor(mmu, name, mmu->mem, NVIF_MEM_MAPPABLE | type,\n\t\t\t\t0, size, NULL, 0, mem);\n\tif (ret == 0) {\n\t\tret = nvif_object_map(&mem->object, NULL, 0);\n\t\tif (ret)\n\t\t\tnvif_mem_dtor(mem);\n\t}\n\treturn ret;\n}\n\nvoid\nnvif_mem_dtor(struct nvif_mem *mem)\n{\n\tnvif_object_dtor(&mem->object);\n}\n\nint\nnvif_mem_ctor_type(struct nvif_mmu *mmu, const char *name, s32 oclass,\n\t\t   int type, u8 page, u64 size, void *argv, u32 argc,\n\t\t   struct nvif_mem *mem)\n{\n\tstruct nvif_mem_v0 *args;\n\tu8 stack[128];\n\tint ret;\n\n\tmem->object.client = NULL;\n\tif (type < 0)\n\t\treturn -EINVAL;\n\n\tif (sizeof(*args) + argc > sizeof(stack)) {\n\t\tif (!(args = kmalloc(sizeof(*args) + argc, GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\targs = (void *)stack;\n\t}\n\targs->version = 0;\n\targs->type = type;\n\targs->page = page;\n\targs->size = size;\n\tmemcpy(args->data, argv, argc);\n\n\tret = nvif_object_ctor(&mmu->object, name ? name : \"nvifMem\", 0, oclass,\n\t\t\t       args, sizeof(*args) + argc, &mem->object);\n\tif (ret == 0) {\n\t\tmem->type = mmu->type[type].type;\n\t\tmem->page = args->page;\n\t\tmem->addr = args->addr;\n\t\tmem->size = args->size;\n\t}\n\n\tif (args != (void *)stack)\n\t\tkfree(args);\n\treturn ret;\n\n}\n\nint\nnvif_mem_ctor(struct nvif_mmu *mmu, const char *name, s32 oclass, u8 type,\n\t      u8 page, u64 size, void *argv, u32 argc, struct nvif_mem *mem)\n{\n\tint ret = -EINVAL, i;\n\n\tmem->object.client = NULL;\n\n\tfor (i = 0; ret && i < mmu->type_nr; i++) {\n\t\tif ((mmu->type[i].type & type) == type) {\n\t\t\tret = nvif_mem_ctor_type(mmu, name, oclass, i, page,\n\t\t\t\t\t\t size, argv, argc, mem);\n\t\t}\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}