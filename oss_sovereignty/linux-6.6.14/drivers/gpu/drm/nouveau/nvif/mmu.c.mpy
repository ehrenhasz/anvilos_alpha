{
  "module_name": "mmu.c",
  "hash_id": "fc7fdcabcf967cb6ea3f0844bf507c5e7e206b105b347f610b668ab24e08c32d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvif/mmu.c",
  "human_readable_source": " \n#include <nvif/mmu.h>\n\n#include <nvif/class.h>\n#include <nvif/if0008.h>\n\nvoid\nnvif_mmu_dtor(struct nvif_mmu *mmu)\n{\n\tif (!nvif_object_constructed(&mmu->object))\n\t\treturn;\n\n\tkfree(mmu->kind);\n\tkfree(mmu->type);\n\tkfree(mmu->heap);\n\tnvif_object_dtor(&mmu->object);\n}\n\nint\nnvif_mmu_ctor(struct nvif_object *parent, const char *name, s32 oclass,\n\t      struct nvif_mmu *mmu)\n{\n\tstatic const struct nvif_mclass mems[] = {\n\t\t{ NVIF_CLASS_MEM_GF100, -1 },\n\t\t{ NVIF_CLASS_MEM_NV50 , -1 },\n\t\t{ NVIF_CLASS_MEM_NV04 , -1 },\n\t\t{}\n\t};\n\tstruct nvif_mmu_v0 args;\n\tint ret, i;\n\n\targs.version = 0;\n\tmmu->heap = NULL;\n\tmmu->type = NULL;\n\tmmu->kind = NULL;\n\n\tret = nvif_object_ctor(parent, name ? name : \"nvifMmu\", 0, oclass,\n\t\t\t       &args, sizeof(args), &mmu->object);\n\tif (ret)\n\t\tgoto done;\n\n\tmmu->dmabits = args.dmabits;\n\tmmu->heap_nr = args.heap_nr;\n\tmmu->type_nr = args.type_nr;\n\tmmu->kind_nr = args.kind_nr;\n\n\tret = nvif_mclass(&mmu->object, mems);\n\tif (ret < 0)\n\t\tgoto done;\n\tmmu->mem = mems[ret].oclass;\n\n\tmmu->heap = kmalloc_array(mmu->heap_nr, sizeof(*mmu->heap),\n\t\t\t\t  GFP_KERNEL);\n\tmmu->type = kmalloc_array(mmu->type_nr, sizeof(*mmu->type),\n\t\t\t\t  GFP_KERNEL);\n\tif (ret = -ENOMEM, !mmu->heap || !mmu->type)\n\t\tgoto done;\n\n\tmmu->kind = kmalloc_array(mmu->kind_nr, sizeof(*mmu->kind),\n\t\t\t\t  GFP_KERNEL);\n\tif (!mmu->kind && mmu->kind_nr)\n\t\tgoto done;\n\n\tfor (i = 0; i < mmu->heap_nr; i++) {\n\t\tstruct nvif_mmu_heap_v0 args = { .index = i };\n\n\t\tret = nvif_object_mthd(&mmu->object, NVIF_MMU_V0_HEAP,\n\t\t\t\t       &args, sizeof(args));\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tmmu->heap[i].size = args.size;\n\t}\n\n\tfor (i = 0; i < mmu->type_nr; i++) {\n\t\tstruct nvif_mmu_type_v0 args = { .index = i };\n\n\t\tret = nvif_object_mthd(&mmu->object, NVIF_MMU_V0_TYPE,\n\t\t\t\t       &args, sizeof(args));\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tmmu->type[i].type = 0;\n\t\tif (args.vram) mmu->type[i].type |= NVIF_MEM_VRAM;\n\t\tif (args.host) mmu->type[i].type |= NVIF_MEM_HOST;\n\t\tif (args.comp) mmu->type[i].type |= NVIF_MEM_COMP;\n\t\tif (args.disp) mmu->type[i].type |= NVIF_MEM_DISP;\n\t\tif (args.kind    ) mmu->type[i].type |= NVIF_MEM_KIND;\n\t\tif (args.mappable) mmu->type[i].type |= NVIF_MEM_MAPPABLE;\n\t\tif (args.coherent) mmu->type[i].type |= NVIF_MEM_COHERENT;\n\t\tif (args.uncached) mmu->type[i].type |= NVIF_MEM_UNCACHED;\n\t\tmmu->type[i].heap = args.heap;\n\t}\n\n\tif (mmu->kind_nr) {\n\t\tstruct nvif_mmu_kind_v0 *kind;\n\t\tsize_t argc = struct_size(kind, data, mmu->kind_nr);\n\n\t\tif (ret = -ENOMEM, !(kind = kmalloc(argc, GFP_KERNEL)))\n\t\t\tgoto done;\n\t\tkind->version = 0;\n\t\tkind->count = mmu->kind_nr;\n\n\t\tret = nvif_object_mthd(&mmu->object, NVIF_MMU_V0_KIND,\n\t\t\t\t       kind, argc);\n\t\tif (ret == 0)\n\t\t\tmemcpy(mmu->kind, kind->data, kind->count);\n\t\tmmu->kind_inv = kind->kind_inv;\n\t\tkfree(kind);\n\t}\n\ndone:\n\tif (ret)\n\t\tnvif_mmu_dtor(mmu);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}