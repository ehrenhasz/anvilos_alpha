{
  "module_name": "vmm.c",
  "hash_id": "bf8aef72f6d5973e3284b4143d1b0b6e8147b27cc7ab826a3b2abea2c5970fe0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvif/vmm.c",
  "human_readable_source": " \n#include <nvif/vmm.h>\n#include <nvif/mem.h>\n\n#include <nvif/if000c.h>\n\nint\nnvif_vmm_unmap(struct nvif_vmm *vmm, u64 addr)\n{\n\treturn nvif_object_mthd(&vmm->object, NVIF_VMM_V0_UNMAP,\n\t\t\t\t&(struct nvif_vmm_unmap_v0) { .addr = addr },\n\t\t\t\tsizeof(struct nvif_vmm_unmap_v0));\n}\n\nint\nnvif_vmm_map(struct nvif_vmm *vmm, u64 addr, u64 size, void *argv, u32 argc,\n\t     struct nvif_mem *mem, u64 offset)\n{\n\tstruct nvif_vmm_map_v0 *args;\n\tu8 stack[48];\n\tint ret;\n\n\tif (sizeof(*args) + argc > sizeof(stack)) {\n\t\tif (!(args = kmalloc(sizeof(*args) + argc, GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\targs = (void *)stack;\n\t}\n\n\targs->version = 0;\n\targs->addr = addr;\n\targs->size = size;\n\targs->memory = nvif_handle(&mem->object);\n\targs->offset = offset;\n\tmemcpy(args->data, argv, argc);\n\n\tret = nvif_object_mthd(&vmm->object, NVIF_VMM_V0_MAP,\n\t\t\t       args, sizeof(*args) + argc);\n\tif (args != (void *)stack)\n\t\tkfree(args);\n\treturn ret;\n}\n\nvoid\nnvif_vmm_put(struct nvif_vmm *vmm, struct nvif_vma *vma)\n{\n\tif (vma->size) {\n\t\tWARN_ON(nvif_object_mthd(&vmm->object, NVIF_VMM_V0_PUT,\n\t\t\t\t\t &(struct nvif_vmm_put_v0) {\n\t\t\t\t\t\t.addr = vma->addr,\n\t\t\t\t\t }, sizeof(struct nvif_vmm_put_v0)));\n\t\tvma->size = 0;\n\t}\n}\n\nint\nnvif_vmm_get(struct nvif_vmm *vmm, enum nvif_vmm_get type, bool sparse,\n\t     u8 page, u8 align, u64 size, struct nvif_vma *vma)\n{\n\tstruct nvif_vmm_get_v0 args;\n\tint ret;\n\n\targs.version = vma->size = 0;\n\targs.sparse = sparse;\n\targs.page = page;\n\targs.align = align;\n\targs.size = size;\n\n\tswitch (type) {\n\tcase ADDR: args.type = NVIF_VMM_GET_V0_ADDR; break;\n\tcase PTES: args.type = NVIF_VMM_GET_V0_PTES; break;\n\tcase LAZY: args.type = NVIF_VMM_GET_V0_LAZY; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nvif_object_mthd(&vmm->object, NVIF_VMM_V0_GET,\n\t\t\t       &args, sizeof(args));\n\tif (ret == 0) {\n\t\tvma->addr = args.addr;\n\t\tvma->size = args.size;\n\t}\n\treturn ret;\n}\n\nint\nnvif_vmm_raw_get(struct nvif_vmm *vmm, u64 addr, u64 size,\n\t\t u8 shift)\n{\n\tstruct nvif_vmm_raw_v0 args = {\n\t\t.version = 0,\n\t\t.op = NVIF_VMM_RAW_V0_GET,\n\t\t.addr = addr,\n\t\t.size = size,\n\t\t.shift = shift,\n\t};\n\n\treturn nvif_object_mthd(&vmm->object, NVIF_VMM_V0_RAW,\n\t\t\t\t&args, sizeof(args));\n}\n\nint\nnvif_vmm_raw_put(struct nvif_vmm *vmm, u64 addr, u64 size, u8 shift)\n{\n\tstruct nvif_vmm_raw_v0 args = {\n\t\t.version = 0,\n\t\t.op = NVIF_VMM_RAW_V0_PUT,\n\t\t.addr = addr,\n\t\t.size = size,\n\t\t.shift = shift,\n\t};\n\n\treturn nvif_object_mthd(&vmm->object, NVIF_VMM_V0_RAW,\n\t\t\t\t&args, sizeof(args));\n}\n\nint\nnvif_vmm_raw_map(struct nvif_vmm *vmm, u64 addr, u64 size, u8 shift,\n\t\t void *argv, u32 argc, struct nvif_mem *mem, u64 offset)\n{\n\tstruct nvif_vmm_raw_v0 args = {\n\t\t.version = 0,\n\t\t.op = NVIF_VMM_RAW_V0_MAP,\n\t\t.addr = addr,\n\t\t.size = size,\n\t\t.shift = shift,\n\t\t.memory = nvif_handle(&mem->object),\n\t\t.offset = offset,\n\t\t.argv = (u64)(uintptr_t)argv,\n\t\t.argc = argc,\n\t};\n\n\n\treturn nvif_object_mthd(&vmm->object, NVIF_VMM_V0_RAW,\n\t\t\t\t&args, sizeof(args));\n}\n\nint\nnvif_vmm_raw_unmap(struct nvif_vmm *vmm, u64 addr, u64 size,\n\t\t   u8 shift, bool sparse)\n{\n\tstruct nvif_vmm_raw_v0 args = {\n\t\t.version = 0,\n\t\t.op = NVIF_VMM_RAW_V0_UNMAP,\n\t\t.addr = addr,\n\t\t.size = size,\n\t\t.shift = shift,\n\t\t.sparse = sparse,\n\t};\n\n\treturn nvif_object_mthd(&vmm->object, NVIF_VMM_V0_RAW,\n\t\t\t\t&args, sizeof(args));\n}\n\nint\nnvif_vmm_raw_sparse(struct nvif_vmm *vmm, u64 addr, u64 size, bool ref)\n{\n\tstruct nvif_vmm_raw_v0 args = {\n\t\t.version = 0,\n\t\t.op = NVIF_VMM_RAW_V0_SPARSE,\n\t\t.addr = addr,\n\t\t.size = size,\n\t\t.ref = ref,\n\t};\n\n\treturn nvif_object_mthd(&vmm->object, NVIF_VMM_V0_RAW,\n\t\t\t\t&args, sizeof(args));\n}\n\nvoid\nnvif_vmm_dtor(struct nvif_vmm *vmm)\n{\n\tkfree(vmm->page);\n\tnvif_object_dtor(&vmm->object);\n}\n\nint\nnvif_vmm_ctor(struct nvif_mmu *mmu, const char *name, s32 oclass,\n\t      enum nvif_vmm_type type, u64 addr, u64 size, void *argv, u32 argc,\n\t      struct nvif_vmm *vmm)\n{\n\tstruct nvif_vmm_v0 *args;\n\tu32 argn = sizeof(*args) + argc;\n\tint ret = -ENOSYS, i;\n\n\tvmm->object.client = NULL;\n\tvmm->page = NULL;\n\n\tif (!(args = kmalloc(argn, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\targs->version = 0;\n\targs->addr = addr;\n\targs->size = size;\n\n\tswitch (type) {\n\tcase UNMANAGED: args->type = NVIF_VMM_V0_TYPE_UNMANAGED; break;\n\tcase MANAGED: args->type = NVIF_VMM_V0_TYPE_MANAGED; break;\n\tcase RAW: args->type = NVIF_VMM_V0_TYPE_RAW; break;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(args->data, argv, argc);\n\n\tret = nvif_object_ctor(&mmu->object, name ? name : \"nvifVmm\", 0,\n\t\t\t       oclass, args, argn, &vmm->object);\n\tif (ret)\n\t\tgoto done;\n\n\tvmm->start = args->addr;\n\tvmm->limit = args->size;\n\n\tvmm->page_nr = args->page_nr;\n\tvmm->page = kmalloc_array(vmm->page_nr, sizeof(*vmm->page),\n\t\t\t\t  GFP_KERNEL);\n\tif (!vmm->page) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < vmm->page_nr; i++) {\n\t\tstruct nvif_vmm_page_v0 args = { .index = i };\n\n\t\tret = nvif_object_mthd(&vmm->object, NVIF_VMM_V0_PAGE,\n\t\t\t\t       &args, sizeof(args));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tvmm->page[i].shift = args.shift;\n\t\tvmm->page[i].sparse = args.sparse;\n\t\tvmm->page[i].vram = args.vram;\n\t\tvmm->page[i].host = args.host;\n\t\tvmm->page[i].comp = args.comp;\n\t}\n\ndone:\n\tif (ret)\n\t\tnvif_vmm_dtor(vmm);\n\tkfree(args);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}