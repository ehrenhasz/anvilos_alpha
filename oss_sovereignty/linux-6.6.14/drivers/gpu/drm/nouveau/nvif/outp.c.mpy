{
  "module_name": "outp.c",
  "hash_id": "f8e15d80fddde7b8479a4e462f18516156ad79e5008d7fbfe9915ad5fb9f6a7f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/nouveau/nvif/outp.c",
  "human_readable_source": " \n#include <nvif/outp.h>\n#include <nvif/disp.h>\n#include <nvif/printf.h>\n\n#include <nvif/class.h>\n\nint\nnvif_outp_dp_mst_vcpi(struct nvif_outp *outp, int head,\n\t\t      u8 start_slot, u8 num_slots, u16 pbn, u16 aligned_pbn)\n{\n\tstruct nvif_outp_dp_mst_vcpi_v0 args;\n\tint ret;\n\n\targs.version = 0;\n\targs.head = head;\n\targs.start_slot = start_slot;\n\targs.num_slots = num_slots;\n\targs.pbn = pbn;\n\targs.aligned_pbn = aligned_pbn;\n\n\tret = nvif_object_mthd(&outp->object, NVIF_OUTP_V0_DP_MST_VCPI, &args, sizeof(args));\n\tNVIF_ERRON(ret, &outp->object,\n\t\t   \"[DP_MST_VCPI head:%d start_slot:%02x num_slots:%02x pbn:%04x aligned_pbn:%04x]\",\n\t\t   args.head, args.start_slot, args.num_slots, args.pbn, args.aligned_pbn);\n\treturn ret;\n}\n\nint\nnvif_outp_dp_retrain(struct nvif_outp *outp)\n{\n\tint ret = nvif_object_mthd(&outp->object, NVIF_OUTP_V0_DP_RETRAIN, NULL, 0);\n\tNVIF_ERRON(ret, &outp->object, \"[DP_RETRAIN]\");\n\treturn ret;\n}\n\nint\nnvif_outp_dp_aux_pwr(struct nvif_outp *outp, bool enable)\n{\n\tstruct nvif_outp_dp_aux_pwr_v0 args;\n\tint ret;\n\n\targs.version = 0;\n\targs.state = enable;\n\n\tret = nvif_object_mthd(&outp->object, NVIF_OUTP_V0_DP_AUX_PWR, &args, sizeof(args));\n\tNVIF_ERRON(ret, &outp->object, \"[DP_AUX_PWR state:%d]\", args.state);\n\treturn ret;\n}\n\nint\nnvif_outp_hda_eld(struct nvif_outp *outp, int head, void *data, u32 size)\n{\n\tstruct {\n\t\tstruct nvif_outp_hda_eld_v0 mthd;\n\t\tu8 data[128];\n\t} args;\n\tint ret;\n\n\tif (WARN_ON(size > ARRAY_SIZE(args.data)))\n\t\treturn -EINVAL;\n\n\targs.mthd.version = 0;\n\targs.mthd.head = head;\n\n\tmemcpy(args.data, data, size);\n\tret = nvif_mthd(&outp->object, NVIF_OUTP_V0_HDA_ELD, &args, sizeof(args.mthd) + size);\n\tNVIF_ERRON(ret, &outp->object, \"[HDA_ELD head:%d size:%d]\", head, size);\n\treturn ret;\n}\n\nint\nnvif_outp_infoframe(struct nvif_outp *outp, u8 type, struct nvif_outp_infoframe_v0 *args, u32 size)\n{\n\tint ret;\n\n\targs->type = type;\n\n\tret = nvif_mthd(&outp->object, NVIF_OUTP_V0_INFOFRAME, args, sizeof(*args) + size);\n\tNVIF_ERRON(ret, &outp->object, \"[INFOFRAME type:%d size:%d]\", type, size);\n\treturn ret;\n}\n\nvoid\nnvif_outp_release(struct nvif_outp *outp)\n{\n\tint ret = nvif_mthd(&outp->object, NVIF_OUTP_V0_RELEASE, NULL, 0);\n\tNVIF_ERRON(ret, &outp->object, \"[RELEASE]\");\n\toutp->or.id = -1;\n}\n\nstatic inline int\nnvif_outp_acquire(struct nvif_outp *outp, u8 proto, struct nvif_outp_acquire_v0 *args)\n{\n\tint ret;\n\n\targs->version = 0;\n\targs->proto = proto;\n\n\tret = nvif_mthd(&outp->object, NVIF_OUTP_V0_ACQUIRE, args, sizeof(*args));\n\tif (ret)\n\t\treturn ret;\n\n\toutp->or.id = args->or;\n\toutp->or.link = args->link;\n\treturn 0;\n}\n\nint\nnvif_outp_acquire_dp(struct nvif_outp *outp, u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t     int link_nr, int link_bw, bool hda, bool mst)\n{\n\tstruct nvif_outp_acquire_v0 args;\n\tint ret;\n\n\targs.dp.link_nr = link_nr;\n\targs.dp.link_bw = link_bw;\n\targs.dp.hda = hda;\n\targs.dp.mst = mst;\n\tmemcpy(args.dp.dpcd, dpcd, sizeof(args.dp.dpcd));\n\n\tret = nvif_outp_acquire(outp, NVIF_OUTP_ACQUIRE_V0_DP, &args);\n\tNVIF_ERRON(ret, &outp->object,\n\t\t   \"[ACQUIRE proto:DP link_nr:%d link_bw:%02x hda:%d mst:%d] or:%d link:%d\",\n\t\t   args.dp.link_nr, args.dp.link_bw, args.dp.hda, args.dp.mst, args.or, args.link);\n\treturn ret;\n}\n\nint\nnvif_outp_acquire_lvds(struct nvif_outp *outp, bool dual, bool bpc8)\n{\n\tstruct nvif_outp_acquire_v0 args;\n\tint ret;\n\n\targs.lvds.dual = dual;\n\targs.lvds.bpc8 = bpc8;\n\n\tret = nvif_outp_acquire(outp, NVIF_OUTP_ACQUIRE_V0_LVDS, &args);\n\tNVIF_ERRON(ret, &outp->object,\n\t\t   \"[ACQUIRE proto:LVDS dual:%d 8bpc:%d] or:%d link:%d\",\n\t\t   args.lvds.dual, args.lvds.bpc8, args.or, args.link);\n\treturn ret;\n}\n\nint\nnvif_outp_acquire_tmds(struct nvif_outp *outp, int head,\n\t\t       bool hdmi, u8 max_ac_packet, u8 rekey, u8 scdc, bool hda)\n{\n\tstruct nvif_outp_acquire_v0 args;\n\tint ret;\n\n\targs.tmds.head = head;\n\targs.tmds.hdmi = hdmi;\n\targs.tmds.hdmi_max_ac_packet = max_ac_packet;\n\targs.tmds.hdmi_rekey = rekey;\n\targs.tmds.hdmi_scdc = scdc;\n\targs.tmds.hdmi_hda = hda;\n\n\tret = nvif_outp_acquire(outp, NVIF_OUTP_ACQUIRE_V0_TMDS, &args);\n\tNVIF_ERRON(ret, &outp->object,\n\t\t   \"[ACQUIRE proto:TMDS head:%d hdmi:%d max_ac_packet:%d rekey:%d scdc:%d hda:%d]\"\n\t\t   \" or:%d link:%d\", args.tmds.head, args.tmds.hdmi, args.tmds.hdmi_max_ac_packet,\n\t\t   args.tmds.hdmi_rekey, args.tmds.hdmi_scdc, args.tmds.hdmi_hda,\n\t\t   args.or, args.link);\n\treturn ret;\n}\n\nint\nnvif_outp_acquire_rgb_crt(struct nvif_outp *outp)\n{\n\tstruct nvif_outp_acquire_v0 args;\n\tint ret;\n\n\tret = nvif_outp_acquire(outp, NVIF_OUTP_ACQUIRE_V0_RGB_CRT, &args);\n\tNVIF_ERRON(ret, &outp->object, \"[ACQUIRE proto:RGB_CRT] or:%d\", args.or);\n\treturn ret;\n}\n\nint\nnvif_outp_load_detect(struct nvif_outp *outp, u32 loadval)\n{\n\tstruct nvif_outp_load_detect_v0 args;\n\tint ret;\n\n\targs.version = 0;\n\targs.data = loadval;\n\n\tret = nvif_mthd(&outp->object, NVIF_OUTP_V0_LOAD_DETECT, &args, sizeof(args));\n\tNVIF_ERRON(ret, &outp->object, \"[LOAD_DETECT data:%08x] load:%02x\", args.data, args.load);\n\treturn ret < 0 ? ret : args.load;\n}\n\nvoid\nnvif_outp_dtor(struct nvif_outp *outp)\n{\n\tnvif_object_dtor(&outp->object);\n}\n\nint\nnvif_outp_ctor(struct nvif_disp *disp, const char *name, int id, struct nvif_outp *outp)\n{\n\tstruct nvif_outp_v0 args;\n\tint ret;\n\n\targs.version = 0;\n\targs.id = id;\n\n\tret = nvif_object_ctor(&disp->object, name ?: \"nvifOutp\", id, NVIF_CLASS_OUTP,\n\t\t\t       &args, sizeof(args), &outp->object);\n\tNVIF_ERRON(ret, &disp->object, \"[NEW outp id:%d]\", id);\n\tif (ret)\n\t\treturn ret;\n\n\toutp->or.id = -1;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}