{
  "module_name": "drm_print.c",
  "hash_id": "be5153b531684be2f8a37e0198e3a60df6eaaf566ec9b76f5f0af9644d9a1b90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_print.c",
  "human_readable_source": " \n\n#include <linux/stdarg.h>\n\n#include <linux/io.h>\n#include <linux/moduleparam.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/dynamic_debug.h>\n\n#include <drm/drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_print.h>\n\n \nunsigned long __drm_debug;\nEXPORT_SYMBOL(__drm_debug);\n\nMODULE_PARM_DESC(debug, \"Enable debug output, where each bit enables a debug category.\\n\"\n\"\\t\\tBit 0 (0x01)  will enable CORE messages (drm core code)\\n\"\n\"\\t\\tBit 1 (0x02)  will enable DRIVER messages (drm controller code)\\n\"\n\"\\t\\tBit 2 (0x04)  will enable KMS messages (modesetting code)\\n\"\n\"\\t\\tBit 3 (0x08)  will enable PRIME messages (prime code)\\n\"\n\"\\t\\tBit 4 (0x10)  will enable ATOMIC messages (atomic code)\\n\"\n\"\\t\\tBit 5 (0x20)  will enable VBL messages (vblank code)\\n\"\n\"\\t\\tBit 7 (0x80)  will enable LEASE messages (leasing code)\\n\"\n\"\\t\\tBit 8 (0x100) will enable DP messages (displayport code)\");\n\n#if !defined(CONFIG_DRM_USE_DYNAMIC_DEBUG)\nmodule_param_named(debug, __drm_debug, ulong, 0600);\n#else\n \nDECLARE_DYNDBG_CLASSMAP(drm_debug_classes, DD_CLASS_TYPE_DISJOINT_BITS, 0,\n\t\t\t\"DRM_UT_CORE\",\n\t\t\t\"DRM_UT_DRIVER\",\n\t\t\t\"DRM_UT_KMS\",\n\t\t\t\"DRM_UT_PRIME\",\n\t\t\t\"DRM_UT_ATOMIC\",\n\t\t\t\"DRM_UT_VBL\",\n\t\t\t\"DRM_UT_STATE\",\n\t\t\t\"DRM_UT_LEASE\",\n\t\t\t\"DRM_UT_DP\",\n\t\t\t\"DRM_UT_DRMRES\");\n\nstatic struct ddebug_class_param drm_debug_bitmap = {\n\t.bits = &__drm_debug,\n\t.flags = \"p\",\n\t.map = &drm_debug_classes,\n};\nmodule_param_cb(debug, &param_ops_dyndbg_classes, &drm_debug_bitmap, 0600);\n#endif\n\nvoid __drm_puts_coredump(struct drm_printer *p, const char *str)\n{\n\tstruct drm_print_iterator *iterator = p->arg;\n\tssize_t len;\n\n\tif (!iterator->remain)\n\t\treturn;\n\n\tif (iterator->offset < iterator->start) {\n\t\tssize_t copy;\n\n\t\tlen = strlen(str);\n\n\t\tif (iterator->offset + len <= iterator->start) {\n\t\t\titerator->offset += len;\n\t\t\treturn;\n\t\t}\n\n\t\tcopy = len - (iterator->start - iterator->offset);\n\n\t\tif (copy > iterator->remain)\n\t\t\tcopy = iterator->remain;\n\n\t\t \n\t\tmemcpy(iterator->data,\n\t\t\tstr + (iterator->start - iterator->offset), copy);\n\n\t\titerator->offset = iterator->start + copy;\n\t\titerator->remain -= copy;\n\t} else {\n\t\tssize_t pos = iterator->offset - iterator->start;\n\n\t\tlen = min_t(ssize_t, strlen(str), iterator->remain);\n\n\t\tmemcpy(iterator->data + pos, str, len);\n\n\t\titerator->offset += len;\n\t\titerator->remain -= len;\n\t}\n}\nEXPORT_SYMBOL(__drm_puts_coredump);\n\nvoid __drm_printfn_coredump(struct drm_printer *p, struct va_format *vaf)\n{\n\tstruct drm_print_iterator *iterator = p->arg;\n\tsize_t len;\n\tchar *buf;\n\n\tif (!iterator->remain)\n\t\treturn;\n\n\t \n\tlen = snprintf(NULL, 0, \"%pV\", vaf);\n\n\t \n\tif (iterator->offset + len <= iterator->start) {\n\t\titerator->offset += len;\n\t\treturn;\n\t}\n\n\t \n\tif ((iterator->offset >= iterator->start) && (len < iterator->remain)) {\n\t\tssize_t pos = iterator->offset - iterator->start;\n\n\t\tsnprintf(((char *) iterator->data) + pos,\n\t\t\titerator->remain, \"%pV\", vaf);\n\n\t\titerator->offset += len;\n\t\titerator->remain -= len;\n\n\t\treturn;\n\t}\n\n\t \n\tbuf = kmalloc(len + 1, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!buf)\n\t\treturn;\n\n\tsnprintf(buf, len + 1, \"%pV\", vaf);\n\t__drm_puts_coredump(p, (const char *) buf);\n\n\tkfree(buf);\n}\nEXPORT_SYMBOL(__drm_printfn_coredump);\n\nvoid __drm_puts_seq_file(struct drm_printer *p, const char *str)\n{\n\tseq_puts(p->arg, str);\n}\nEXPORT_SYMBOL(__drm_puts_seq_file);\n\nvoid __drm_printfn_seq_file(struct drm_printer *p, struct va_format *vaf)\n{\n\tseq_printf(p->arg, \"%pV\", vaf);\n}\nEXPORT_SYMBOL(__drm_printfn_seq_file);\n\nvoid __drm_printfn_info(struct drm_printer *p, struct va_format *vaf)\n{\n\tdev_info(p->arg, \"[\" DRM_NAME \"] %pV\", vaf);\n}\nEXPORT_SYMBOL(__drm_printfn_info);\n\nvoid __drm_printfn_debug(struct drm_printer *p, struct va_format *vaf)\n{\n\t \n\tprintk(KERN_DEBUG \"%s %pV\", p->prefix, vaf);\n}\nEXPORT_SYMBOL(__drm_printfn_debug);\n\nvoid __drm_printfn_err(struct drm_printer *p, struct va_format *vaf)\n{\n\tpr_err(\"*ERROR* %s %pV\", p->prefix, vaf);\n}\nEXPORT_SYMBOL(__drm_printfn_err);\n\n \nvoid drm_puts(struct drm_printer *p, const char *str)\n{\n\tif (p->puts)\n\t\tp->puts(p, str);\n\telse\n\t\tdrm_printf(p, \"%s\", str);\n}\nEXPORT_SYMBOL(drm_puts);\n\n \nvoid drm_printf(struct drm_printer *p, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tdrm_vprintf(p, f, &args);\n\tva_end(args);\n}\nEXPORT_SYMBOL(drm_printf);\n\n \nvoid drm_print_bits(struct drm_printer *p, unsigned long value,\n\t\t    const char * const bits[], unsigned int nbits)\n{\n\tbool first = true;\n\tunsigned int i;\n\n\tif (WARN_ON_ONCE(nbits > BITS_PER_TYPE(value)))\n\t\tnbits = BITS_PER_TYPE(value);\n\n\tfor_each_set_bit(i, &value, nbits) {\n\t\tif (WARN_ON_ONCE(!bits[i]))\n\t\t\tcontinue;\n\t\tdrm_printf(p, \"%s%s\", first ? \"\" : \",\",\n\t\t\t   bits[i]);\n\t\tfirst = false;\n\t}\n\tif (first)\n\t\tdrm_printf(p, \"(none)\");\n}\nEXPORT_SYMBOL(drm_print_bits);\n\nvoid drm_dev_printk(const struct device *dev, const char *level,\n\t\t    const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tif (dev)\n\t\tdev_printk(level, dev, \"[\" DRM_NAME \":%ps] %pV\",\n\t\t\t   __builtin_return_address(0), &vaf);\n\telse\n\t\tprintk(\"%s\" \"[\" DRM_NAME \":%ps] %pV\",\n\t\t       level, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(drm_dev_printk);\n\nvoid __drm_dev_dbg(struct _ddebug *desc, const struct device *dev,\n\t\t   enum drm_debug_category category, const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!__drm_debug_enabled(category))\n\t\treturn;\n\n\t \n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tif (dev)\n\t\tdev_printk(KERN_DEBUG, dev, \"[\" DRM_NAME \":%ps] %pV\",\n\t\t\t   __builtin_return_address(0), &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"[\" DRM_NAME \":%ps] %pV\",\n\t\t       __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__drm_dev_dbg);\n\nvoid ___drm_dbg(struct _ddebug *desc, enum drm_debug_category category, const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!__drm_debug_enabled(category))\n\t\treturn;\n\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tprintk(KERN_DEBUG \"[\" DRM_NAME \":%ps] %pV\",\n\t       __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(___drm_dbg);\n\nvoid __drm_err(const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tprintk(KERN_ERR \"[\" DRM_NAME \":%ps] *ERROR* %pV\",\n\t       __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__drm_err);\n\n \nvoid drm_print_regset32(struct drm_printer *p, struct debugfs_regset32 *regset)\n{\n\tint namelen = 0;\n\tint i;\n\n\tfor (i = 0; i < regset->nregs; i++)\n\t\tnamelen = max(namelen, (int)strlen(regset->regs[i].name));\n\n\tfor (i = 0; i < regset->nregs; i++) {\n\t\tdrm_printf(p, \"%*s = 0x%08x\\n\",\n\t\t\t   namelen, regset->regs[i].name,\n\t\t\t   readl(regset->base + regset->regs[i].offset));\n\t}\n}\nEXPORT_SYMBOL(drm_print_regset32);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}