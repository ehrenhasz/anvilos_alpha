{
  "module_name": "drm_gem_dma_helper.c",
  "hash_id": "060a04e220cbd571ae7c52020b533ed0f6f687b4de5b283960cd34cb57f13d68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_gem_dma_helper.c",
  "human_readable_source": "\n \n\n#include <linux/dma-buf.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include <drm/drm.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_vma_manager.h>\n\n \n\nstatic const struct drm_gem_object_funcs drm_gem_dma_default_funcs = {\n\t.free = drm_gem_dma_object_free,\n\t.print_info = drm_gem_dma_object_print_info,\n\t.get_sg_table = drm_gem_dma_object_get_sg_table,\n\t.vmap = drm_gem_dma_object_vmap,\n\t.mmap = drm_gem_dma_object_mmap,\n\t.vm_ops = &drm_gem_dma_vm_ops,\n};\n\n \nstatic struct drm_gem_dma_object *\n__drm_gem_dma_create(struct drm_device *drm, size_t size, bool private)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_gem_object *gem_obj;\n\tint ret = 0;\n\n\tif (drm->driver->gem_create_object) {\n\t\tgem_obj = drm->driver->gem_create_object(drm, size);\n\t\tif (IS_ERR(gem_obj))\n\t\t\treturn ERR_CAST(gem_obj);\n\t\tdma_obj = to_drm_gem_dma_obj(gem_obj);\n\t} else {\n\t\tdma_obj = kzalloc(sizeof(*dma_obj), GFP_KERNEL);\n\t\tif (!dma_obj)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgem_obj = &dma_obj->base;\n\t}\n\n\tif (!gem_obj->funcs)\n\t\tgem_obj->funcs = &drm_gem_dma_default_funcs;\n\n\tif (private) {\n\t\tdrm_gem_private_object_init(drm, gem_obj, size);\n\n\t\t \n\t\tdma_obj->map_noncoherent = false;\n\t} else {\n\t\tret = drm_gem_object_init(drm, gem_obj, size);\n\t}\n\tif (ret)\n\t\tgoto error;\n\n\tret = drm_gem_create_mmap_offset(gem_obj);\n\tif (ret) {\n\t\tdrm_gem_object_release(gem_obj);\n\t\tgoto error;\n\t}\n\n\treturn dma_obj;\n\nerror:\n\tkfree(dma_obj);\n\treturn ERR_PTR(ret);\n}\n\n \nstruct drm_gem_dma_object *drm_gem_dma_create(struct drm_device *drm,\n\t\t\t\t\t      size_t size)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\tint ret;\n\n\tsize = round_up(size, PAGE_SIZE);\n\n\tdma_obj = __drm_gem_dma_create(drm, size, false);\n\tif (IS_ERR(dma_obj))\n\t\treturn dma_obj;\n\n\tif (dma_obj->map_noncoherent) {\n\t\tdma_obj->vaddr = dma_alloc_noncoherent(drm->dev, size,\n\t\t\t\t\t\t       &dma_obj->dma_addr,\n\t\t\t\t\t\t       DMA_TO_DEVICE,\n\t\t\t\t\t\t       GFP_KERNEL | __GFP_NOWARN);\n\t} else {\n\t\tdma_obj->vaddr = dma_alloc_wc(drm->dev, size,\n\t\t\t\t\t      &dma_obj->dma_addr,\n\t\t\t\t\t      GFP_KERNEL | __GFP_NOWARN);\n\t}\n\tif (!dma_obj->vaddr) {\n\t\tdrm_dbg(drm, \"failed to allocate buffer with size %zu\\n\",\n\t\t\t size);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn dma_obj;\n\nerror:\n\tdrm_gem_object_put(&dma_obj->base);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_create);\n\n \nstatic struct drm_gem_dma_object *\ndrm_gem_dma_create_with_handle(struct drm_file *file_priv,\n\t\t\t       struct drm_device *drm, size_t size,\n\t\t\t       uint32_t *handle)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_gem_object *gem_obj;\n\tint ret;\n\n\tdma_obj = drm_gem_dma_create(drm, size);\n\tif (IS_ERR(dma_obj))\n\t\treturn dma_obj;\n\n\tgem_obj = &dma_obj->base;\n\n\t \n\tret = drm_gem_handle_create(file_priv, gem_obj, handle);\n\t \n\tdrm_gem_object_put(gem_obj);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dma_obj;\n}\n\n \nvoid drm_gem_dma_free(struct drm_gem_dma_object *dma_obj)\n{\n\tstruct drm_gem_object *gem_obj = &dma_obj->base;\n\tstruct iosys_map map = IOSYS_MAP_INIT_VADDR(dma_obj->vaddr);\n\n\tif (gem_obj->import_attach) {\n\t\tif (dma_obj->vaddr)\n\t\t\tdma_buf_vunmap_unlocked(gem_obj->import_attach->dmabuf, &map);\n\t\tdrm_prime_gem_destroy(gem_obj, dma_obj->sgt);\n\t} else if (dma_obj->vaddr) {\n\t\tif (dma_obj->map_noncoherent)\n\t\t\tdma_free_noncoherent(gem_obj->dev->dev, dma_obj->base.size,\n\t\t\t\t\t     dma_obj->vaddr, dma_obj->dma_addr,\n\t\t\t\t\t     DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_free_wc(gem_obj->dev->dev, dma_obj->base.size,\n\t\t\t\t    dma_obj->vaddr, dma_obj->dma_addr);\n\t}\n\n\tdrm_gem_object_release(gem_obj);\n\n\tkfree(dma_obj);\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_free);\n\n \nint drm_gem_dma_dumb_create_internal(struct drm_file *file_priv,\n\t\t\t\t     struct drm_device *drm,\n\t\t\t\t     struct drm_mode_create_dumb *args)\n{\n\tunsigned int min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\tstruct drm_gem_dma_object *dma_obj;\n\n\tif (args->pitch < min_pitch)\n\t\targs->pitch = min_pitch;\n\n\tif (args->size < args->pitch * args->height)\n\t\targs->size = args->pitch * args->height;\n\n\tdma_obj = drm_gem_dma_create_with_handle(file_priv, drm, args->size,\n\t\t\t\t\t\t &args->handle);\n\treturn PTR_ERR_OR_ZERO(dma_obj);\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_dumb_create_internal);\n\n \nint drm_gem_dma_dumb_create(struct drm_file *file_priv,\n\t\t\t    struct drm_device *drm,\n\t\t\t    struct drm_mode_create_dumb *args)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\n\targs->pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\targs->size = args->pitch * args->height;\n\n\tdma_obj = drm_gem_dma_create_with_handle(file_priv, drm, args->size,\n\t\t\t\t\t\t &args->handle);\n\treturn PTR_ERR_OR_ZERO(dma_obj);\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_dumb_create);\n\nconst struct vm_operations_struct drm_gem_dma_vm_ops = {\n\t.open = drm_gem_vm_open,\n\t.close = drm_gem_vm_close,\n};\nEXPORT_SYMBOL_GPL(drm_gem_dma_vm_ops);\n\n#ifndef CONFIG_MMU\n \nunsigned long drm_gem_dma_get_unmapped_area(struct file *filp,\n\t\t\t\t\t    unsigned long addr,\n\t\t\t\t\t    unsigned long len,\n\t\t\t\t\t    unsigned long pgoff,\n\t\t\t\t\t    unsigned long flags)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_gem_object *obj = NULL;\n\tstruct drm_file *priv = filp->private_data;\n\tstruct drm_device *dev = priv->minor->dev;\n\tstruct drm_vma_offset_node *node;\n\n\tif (drm_dev_is_unplugged(dev))\n\t\treturn -ENODEV;\n\n\tdrm_vma_offset_lock_lookup(dev->vma_offset_manager);\n\tnode = drm_vma_offset_exact_lookup_locked(dev->vma_offset_manager,\n\t\t\t\t\t\t  pgoff,\n\t\t\t\t\t\t  len >> PAGE_SHIFT);\n\tif (likely(node)) {\n\t\tobj = container_of(node, struct drm_gem_object, vma_node);\n\t\t \n\t\tif (!kref_get_unless_zero(&obj->refcount))\n\t\t\tobj = NULL;\n\t}\n\n\tdrm_vma_offset_unlock_lookup(dev->vma_offset_manager);\n\n\tif (!obj)\n\t\treturn -EINVAL;\n\n\tif (!drm_vma_node_is_allowed(node, priv)) {\n\t\tdrm_gem_object_put(obj);\n\t\treturn -EACCES;\n\t}\n\n\tdma_obj = to_drm_gem_dma_obj(obj);\n\n\tdrm_gem_object_put(obj);\n\n\treturn dma_obj->vaddr ? (unsigned long)dma_obj->vaddr : -EINVAL;\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_get_unmapped_area);\n#endif\n\n \nvoid drm_gem_dma_print_info(const struct drm_gem_dma_object *dma_obj,\n\t\t\t    struct drm_printer *p, unsigned int indent)\n{\n\tdrm_printf_indent(p, indent, \"dma_addr=%pad\\n\", &dma_obj->dma_addr);\n\tdrm_printf_indent(p, indent, \"vaddr=%p\\n\", dma_obj->vaddr);\n}\nEXPORT_SYMBOL(drm_gem_dma_print_info);\n\n \nstruct sg_table *drm_gem_dma_get_sg_table(struct drm_gem_dma_object *dma_obj)\n{\n\tstruct drm_gem_object *obj = &dma_obj->base;\n\tstruct sg_table *sgt;\n\tint ret;\n\n\tsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\n\tif (!sgt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = dma_get_sgtable(obj->dev->dev, sgt, dma_obj->vaddr,\n\t\t\t      dma_obj->dma_addr, obj->size);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treturn sgt;\n\nout:\n\tkfree(sgt);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_get_sg_table);\n\n \nstruct drm_gem_object *\ndrm_gem_dma_prime_import_sg_table(struct drm_device *dev,\n\t\t\t\t  struct dma_buf_attachment *attach,\n\t\t\t\t  struct sg_table *sgt)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\n\t \n\tif (drm_prime_get_contiguous_size(sgt) < attach->dmabuf->size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tdma_obj = __drm_gem_dma_create(dev, attach->dmabuf->size, true);\n\tif (IS_ERR(dma_obj))\n\t\treturn ERR_CAST(dma_obj);\n\n\tdma_obj->dma_addr = sg_dma_address(sgt->sgl);\n\tdma_obj->sgt = sgt;\n\n\tdrm_dbg_prime(dev, \"dma_addr = %pad, size = %zu\\n\", &dma_obj->dma_addr,\n\t\t      attach->dmabuf->size);\n\n\treturn &dma_obj->base;\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_prime_import_sg_table);\n\n \nint drm_gem_dma_vmap(struct drm_gem_dma_object *dma_obj,\n\t\t     struct iosys_map *map)\n{\n\tiosys_map_set_vaddr(map, dma_obj->vaddr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_vmap);\n\n \nint drm_gem_dma_mmap(struct drm_gem_dma_object *dma_obj, struct vm_area_struct *vma)\n{\n\tstruct drm_gem_object *obj = &dma_obj->base;\n\tint ret;\n\n\t \n\tvma->vm_pgoff -= drm_vma_node_start(&obj->vma_node);\n\tvm_flags_mod(vma, VM_DONTEXPAND, VM_PFNMAP);\n\n\tif (dma_obj->map_noncoherent) {\n\t\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\n\t\tret = dma_mmap_pages(dma_obj->base.dev->dev,\n\t\t\t\t     vma, vma->vm_end - vma->vm_start,\n\t\t\t\t     virt_to_page(dma_obj->vaddr));\n\t} else {\n\t\tret = dma_mmap_wc(dma_obj->base.dev->dev, vma, dma_obj->vaddr,\n\t\t\t\t  dma_obj->dma_addr,\n\t\t\t\t  vma->vm_end - vma->vm_start);\n\t}\n\tif (ret)\n\t\tdrm_gem_vm_close(vma);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_gem_dma_mmap);\n\n \nstruct drm_gem_object *\ndrm_gem_dma_prime_import_sg_table_vmap(struct drm_device *dev,\n\t\t\t\t       struct dma_buf_attachment *attach,\n\t\t\t\t       struct sg_table *sgt)\n{\n\tstruct drm_gem_dma_object *dma_obj;\n\tstruct drm_gem_object *obj;\n\tstruct iosys_map map;\n\tint ret;\n\n\tret = dma_buf_vmap_unlocked(attach->dmabuf, &map);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to vmap PRIME buffer\\n\");\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tobj = drm_gem_dma_prime_import_sg_table(dev, attach, sgt);\n\tif (IS_ERR(obj)) {\n\t\tdma_buf_vunmap_unlocked(attach->dmabuf, &map);\n\t\treturn obj;\n\t}\n\n\tdma_obj = to_drm_gem_dma_obj(obj);\n\tdma_obj->vaddr = map.vaddr;\n\n\treturn obj;\n}\nEXPORT_SYMBOL(drm_gem_dma_prime_import_sg_table_vmap);\n\nMODULE_DESCRIPTION(\"DRM DMA memory-management helpers\");\nMODULE_IMPORT_NS(DMA_BUF);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}