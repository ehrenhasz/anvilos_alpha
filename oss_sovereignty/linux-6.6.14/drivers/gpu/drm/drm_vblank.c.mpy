{
  "module_name": "drm_vblank.c",
  "hash_id": "e392fc9105c63cb51402fe59aa9326b1936fa4d6171cce08627409de944d9672",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_vblank.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper_vtables.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n\n#include \"drm_internal.h\"\n#include \"drm_trace.h\"\n\n \n\n \n#define DRM_TIMESTAMP_MAXRETRIES 3\n\n \n#define DRM_REDUNDANT_VBLIRQ_THRESH_NS 1000000\n\nstatic bool\ndrm_get_last_vbltimestamp(struct drm_device *dev, unsigned int pipe,\n\t\t\t  ktime_t *tvblank, bool in_vblank_irq);\n\nstatic unsigned int drm_timestamp_precision = 20;   \n\nstatic int drm_vblank_offdelay = 5000;     \n\nmodule_param_named(vblankoffdelay, drm_vblank_offdelay, int, 0600);\nmodule_param_named(timestamp_precision_usec, drm_timestamp_precision, int, 0600);\nMODULE_PARM_DESC(vblankoffdelay, \"Delay until vblank irq auto-disable [msecs] (0: never disable, <0: disable immediately)\");\nMODULE_PARM_DESC(timestamp_precision_usec, \"Max. error on timestamps [usecs]\");\n\nstatic void store_vblank(struct drm_device *dev, unsigned int pipe,\n\t\t\t u32 vblank_count_inc,\n\t\t\t ktime_t t_vblank, u32 last)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\tassert_spin_locked(&dev->vblank_time_lock);\n\n\tvblank->last = last;\n\n\twrite_seqlock(&vblank->seqlock);\n\tvblank->time = t_vblank;\n\tatomic64_add(vblank_count_inc, &vblank->count);\n\twrite_sequnlock(&vblank->seqlock);\n}\n\nstatic u32 drm_max_vblank_count(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\treturn vblank->max_vblank_count ?: dev->max_vblank_count;\n}\n\n \nstatic u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe)\n{\n\tdrm_WARN_ON_ONCE(dev, drm_max_vblank_count(dev, pipe) != 0);\n\treturn 0;\n}\n\nstatic u32 __get_vblank_counter(struct drm_device *dev, unsigned int pipe)\n{\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\n\t\tif (drm_WARN_ON(dev, !crtc))\n\t\t\treturn 0;\n\n\t\tif (crtc->funcs->get_vblank_counter)\n\t\t\treturn crtc->funcs->get_vblank_counter(crtc);\n\t}\n#ifdef CONFIG_DRM_LEGACY\n\telse if (dev->driver->get_vblank_counter) {\n\t\treturn dev->driver->get_vblank_counter(dev, pipe);\n\t}\n#endif\n\n\treturn drm_vblank_no_hw_counter(dev, pipe);\n}\n\n \nstatic void drm_reset_vblank_timestamp(struct drm_device *dev, unsigned int pipe)\n{\n\tu32 cur_vblank;\n\tbool rc;\n\tktime_t t_vblank;\n\tint count = DRM_TIMESTAMP_MAXRETRIES;\n\n\tspin_lock(&dev->vblank_time_lock);\n\n\t \n\tdo {\n\t\tcur_vblank = __get_vblank_counter(dev, pipe);\n\t\trc = drm_get_last_vbltimestamp(dev, pipe, &t_vblank, false);\n\t} while (cur_vblank != __get_vblank_counter(dev, pipe) && --count > 0);\n\n\t \n\tif (!rc)\n\t\tt_vblank = 0;\n\n\t \n\tstore_vblank(dev, pipe, 1, t_vblank, cur_vblank);\n\n\tspin_unlock(&dev->vblank_time_lock);\n}\n\n \nstatic void drm_update_vblank_count(struct drm_device *dev, unsigned int pipe,\n\t\t\t\t    bool in_vblank_irq)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tu32 cur_vblank, diff;\n\tbool rc;\n\tktime_t t_vblank;\n\tint count = DRM_TIMESTAMP_MAXRETRIES;\n\tint framedur_ns = vblank->framedur_ns;\n\tu32 max_vblank_count = drm_max_vblank_count(dev, pipe);\n\n\t \n\tdo {\n\t\tcur_vblank = __get_vblank_counter(dev, pipe);\n\t\trc = drm_get_last_vbltimestamp(dev, pipe, &t_vblank, in_vblank_irq);\n\t} while (cur_vblank != __get_vblank_counter(dev, pipe) && --count > 0);\n\n\tif (max_vblank_count) {\n\t\t \n\t\tdiff = (cur_vblank - vblank->last) & max_vblank_count;\n\t} else if (rc && framedur_ns) {\n\t\tu64 diff_ns = ktime_to_ns(ktime_sub(t_vblank, vblank->time));\n\n\t\t \n\n\t\tdrm_dbg_vbl(dev, \"crtc %u: Calculating number of vblanks.\"\n\t\t\t    \" diff_ns = %lld, framedur_ns = %d)\\n\",\n\t\t\t    pipe, (long long)diff_ns, framedur_ns);\n\n\t\tdiff = DIV_ROUND_CLOSEST_ULL(diff_ns, framedur_ns);\n\n\t\tif (diff == 0 && in_vblank_irq)\n\t\t\tdrm_dbg_vbl(dev, \"crtc %u: Redundant vblirq ignored\\n\",\n\t\t\t\t    pipe);\n\t} else {\n\t\t \n\t\tdiff = in_vblank_irq ? 1 : 0;\n\t}\n\n\t \n\tif (diff > 1 && (vblank->inmodeset & 0x2)) {\n\t\tdrm_dbg_vbl(dev,\n\t\t\t    \"clamping vblank bump to 1 on crtc %u: diffr=%u\"\n\t\t\t    \" due to pre-modeset.\\n\", pipe, diff);\n\t\tdiff = 1;\n\t}\n\n\tdrm_dbg_vbl(dev, \"updating vblank count on crtc %u:\"\n\t\t    \" current=%llu, diff=%u, hw=%u hw_last=%u\\n\",\n\t\t    pipe, (unsigned long long)atomic64_read(&vblank->count),\n\t\t    diff, cur_vblank, vblank->last);\n\n\tif (diff == 0) {\n\t\tdrm_WARN_ON_ONCE(dev, cur_vblank != vblank->last);\n\t\treturn;\n\t}\n\n\t \n\tif (!rc && !in_vblank_irq)\n\t\tt_vblank = 0;\n\n\tstore_vblank(dev, pipe, diff, t_vblank, cur_vblank);\n}\n\nu64 drm_vblank_count(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tu64 count;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn 0;\n\n\tcount = atomic64_read(&vblank->count);\n\n\t \n\tsmp_rmb();\n\n\treturn count;\n}\n\n \nu64 drm_crtc_accurate_vblank_count(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tu64 vblank;\n\tunsigned long flags;\n\n\tdrm_WARN_ONCE(dev, drm_debug_enabled(DRM_UT_VBL) &&\n\t\t      !crtc->funcs->get_vblank_timestamp,\n\t\t      \"This function requires support for accurate vblank timestamps.\");\n\n\tspin_lock_irqsave(&dev->vblank_time_lock, flags);\n\n\tdrm_update_vblank_count(dev, pipe, false);\n\tvblank = drm_vblank_count(dev, pipe);\n\n\tspin_unlock_irqrestore(&dev->vblank_time_lock, flags);\n\n\treturn vblank;\n}\nEXPORT_SYMBOL(drm_crtc_accurate_vblank_count);\n\nstatic void __disable_vblank(struct drm_device *dev, unsigned int pipe)\n{\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\n\t\tif (drm_WARN_ON(dev, !crtc))\n\t\t\treturn;\n\n\t\tif (crtc->funcs->disable_vblank)\n\t\t\tcrtc->funcs->disable_vblank(crtc);\n\t}\n#ifdef CONFIG_DRM_LEGACY\n\telse {\n\t\tdev->driver->disable_vblank(dev, pipe);\n\t}\n#endif\n}\n\n \nvoid drm_vblank_disable_and_save(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tunsigned long irqflags;\n\n\tassert_spin_locked(&dev->vbl_lock);\n\n\t \n\tspin_lock_irqsave(&dev->vblank_time_lock, irqflags);\n\n\t \n\tif (!vblank->enabled)\n\t\tgoto out;\n\n\t \n\tdrm_update_vblank_count(dev, pipe, false);\n\t__disable_vblank(dev, pipe);\n\tvblank->enabled = false;\n\nout:\n\tspin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);\n}\n\nstatic void vblank_disable_fn(struct timer_list *t)\n{\n\tstruct drm_vblank_crtc *vblank = from_timer(vblank, t, disable_timer);\n\tstruct drm_device *dev = vblank->dev;\n\tunsigned int pipe = vblank->pipe;\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&dev->vbl_lock, irqflags);\n\tif (atomic_read(&vblank->refcount) == 0 && vblank->enabled) {\n\t\tdrm_dbg_core(dev, \"disabling vblank on crtc %u\\n\", pipe);\n\t\tdrm_vblank_disable_and_save(dev, pipe);\n\t}\n\tspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\n}\n\nstatic void drm_vblank_init_release(struct drm_device *dev, void *ptr)\n{\n\tstruct drm_vblank_crtc *vblank = ptr;\n\n\tdrm_WARN_ON(dev, READ_ONCE(vblank->enabled) &&\n\t\t    drm_core_check_feature(dev, DRIVER_MODESET));\n\n\tdrm_vblank_destroy_worker(vblank);\n\tdel_timer_sync(&vblank->disable_timer);\n}\n\n \nint drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs)\n{\n\tint ret;\n\tunsigned int i;\n\n\tspin_lock_init(&dev->vbl_lock);\n\tspin_lock_init(&dev->vblank_time_lock);\n\n\tdev->vblank = drmm_kcalloc(dev, num_crtcs, sizeof(*dev->vblank), GFP_KERNEL);\n\tif (!dev->vblank)\n\t\treturn -ENOMEM;\n\n\tdev->num_crtcs = num_crtcs;\n\n\tfor (i = 0; i < num_crtcs; i++) {\n\t\tstruct drm_vblank_crtc *vblank = &dev->vblank[i];\n\n\t\tvblank->dev = dev;\n\t\tvblank->pipe = i;\n\t\tinit_waitqueue_head(&vblank->queue);\n\t\ttimer_setup(&vblank->disable_timer, vblank_disable_fn, 0);\n\t\tseqlock_init(&vblank->seqlock);\n\n\t\tret = drmm_add_action_or_reset(dev, drm_vblank_init_release,\n\t\t\t\t\t       vblank);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = drm_vblank_worker_init(vblank);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_vblank_init);\n\n \nbool drm_dev_has_vblank(const struct drm_device *dev)\n{\n\treturn dev->num_crtcs != 0;\n}\nEXPORT_SYMBOL(drm_dev_has_vblank);\n\n \nwait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc)\n{\n\treturn &crtc->dev->vblank[drm_crtc_index(crtc)].queue;\n}\nEXPORT_SYMBOL(drm_crtc_vblank_waitqueue);\n\n\n \nvoid drm_calc_timestamping_constants(struct drm_crtc *crtc,\n\t\t\t\t     const struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tint linedur_ns = 0, framedur_ns = 0;\n\tint dotclock = mode->crtc_clock;\n\n\tif (!drm_dev_has_vblank(dev))\n\t\treturn;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\t \n\tif (dotclock > 0) {\n\t\tint frame_size = mode->crtc_htotal * mode->crtc_vtotal;\n\n\t\t \n\t\tlinedur_ns  = div_u64((u64) mode->crtc_htotal * 1000000, dotclock);\n\t\tframedur_ns = div_u64((u64) frame_size * 1000000, dotclock);\n\n\t\t \n\t\tif (mode->flags & DRM_MODE_FLAG_INTERLACE)\n\t\t\tframedur_ns /= 2;\n\t} else {\n\t\tdrm_err(dev, \"crtc %u: Can't calculate constants, dotclock = 0!\\n\",\n\t\t\tcrtc->base.id);\n\t}\n\n\tvblank->linedur_ns  = linedur_ns;\n\tvblank->framedur_ns = framedur_ns;\n\tdrm_mode_copy(&vblank->hwmode, mode);\n\n\tdrm_dbg_core(dev,\n\t\t     \"crtc %u: hwmode: htotal %d, vtotal %d, vdisplay %d\\n\",\n\t\t     crtc->base.id, mode->crtc_htotal,\n\t\t     mode->crtc_vtotal, mode->crtc_vdisplay);\n\tdrm_dbg_core(dev, \"crtc %u: clock %d kHz framedur %d linedur %d\\n\",\n\t\t     crtc->base.id, dotclock, framedur_ns, linedur_ns);\n}\nEXPORT_SYMBOL(drm_calc_timestamping_constants);\n\n \nbool\ndrm_crtc_vblank_helper_get_vblank_timestamp_internal(\n\tstruct drm_crtc *crtc, int *max_error, ktime_t *vblank_time,\n\tbool in_vblank_irq,\n\tdrm_vblank_get_scanout_position_func get_scanout_position)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = crtc->index;\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tstruct timespec64 ts_etime, ts_vblank_time;\n\tktime_t stime, etime;\n\tbool vbl_status;\n\tconst struct drm_display_mode *mode;\n\tint vpos, hpos, i;\n\tint delta_ns, duration_ns;\n\n\tif (pipe >= dev->num_crtcs) {\n\t\tdrm_err(dev, \"Invalid crtc %u\\n\", pipe);\n\t\treturn false;\n\t}\n\n\t \n\tif (!get_scanout_position) {\n\t\tdrm_err(dev, \"Called from CRTC w/o get_scanout_position()!?\\n\");\n\t\treturn false;\n\t}\n\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tmode = &vblank->hwmode;\n\telse\n\t\tmode = &crtc->hwmode;\n\n\t \n\tif (mode->crtc_clock == 0) {\n\t\tdrm_dbg_core(dev, \"crtc %u: Noop due to uninitialized mode.\\n\",\n\t\t\t     pipe);\n\t\tdrm_WARN_ON_ONCE(dev, drm_drv_uses_atomic_modeset(dev));\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < DRM_TIMESTAMP_MAXRETRIES; i++) {\n\t\t \n\t\tvbl_status = get_scanout_position(crtc, in_vblank_irq,\n\t\t\t\t\t\t  &vpos, &hpos,\n\t\t\t\t\t\t  &stime, &etime,\n\t\t\t\t\t\t  mode);\n\n\t\t \n\t\tif (!vbl_status) {\n\t\t\tdrm_dbg_core(dev,\n\t\t\t\t     \"crtc %u : scanoutpos query failed.\\n\",\n\t\t\t\t     pipe);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\tduration_ns = ktime_to_ns(etime) - ktime_to_ns(stime);\n\n\t\t \n\t\tif (duration_ns <= *max_error)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == DRM_TIMESTAMP_MAXRETRIES) {\n\t\tdrm_dbg_core(dev,\n\t\t\t     \"crtc %u: Noisy timestamp %d us > %d us [%d reps].\\n\",\n\t\t\t     pipe, duration_ns / 1000, *max_error / 1000, i);\n\t}\n\n\t \n\t*max_error = duration_ns;\n\n\t \n\tdelta_ns = div_s64(1000000LL * (vpos * mode->crtc_htotal + hpos),\n\t\t\t   mode->crtc_clock);\n\n\t \n\t*vblank_time = ktime_sub_ns(etime, delta_ns);\n\n\tif (!drm_debug_enabled(DRM_UT_VBL))\n\t\treturn true;\n\n\tts_etime = ktime_to_timespec64(etime);\n\tts_vblank_time = ktime_to_timespec64(*vblank_time);\n\n\tdrm_dbg_vbl(dev,\n\t\t    \"crtc %u : v p(%d,%d)@ %lld.%06ld -> %lld.%06ld [e %d us, %d rep]\\n\",\n\t\t    pipe, hpos, vpos,\n\t\t    (u64)ts_etime.tv_sec, ts_etime.tv_nsec / 1000,\n\t\t    (u64)ts_vblank_time.tv_sec, ts_vblank_time.tv_nsec / 1000,\n\t\t    duration_ns / 1000, i);\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_crtc_vblank_helper_get_vblank_timestamp_internal);\n\n \nbool drm_crtc_vblank_helper_get_vblank_timestamp(struct drm_crtc *crtc,\n\t\t\t\t\t\t int *max_error,\n\t\t\t\t\t\t ktime_t *vblank_time,\n\t\t\t\t\t\t bool in_vblank_irq)\n{\n\treturn drm_crtc_vblank_helper_get_vblank_timestamp_internal(\n\t\tcrtc, max_error, vblank_time, in_vblank_irq,\n\t\tcrtc->helper_private->get_scanout_position);\n}\nEXPORT_SYMBOL(drm_crtc_vblank_helper_get_vblank_timestamp);\n\n \nstatic bool\ndrm_crtc_get_last_vbltimestamp(struct drm_crtc *crtc, ktime_t *tvblank,\n\t\t\t       bool in_vblank_irq)\n{\n\tbool ret = false;\n\n\t \n\tint max_error = (int) drm_timestamp_precision * 1000;\n\n\t \n\tif (crtc && crtc->funcs->get_vblank_timestamp && max_error > 0) {\n\t\tret = crtc->funcs->get_vblank_timestamp(crtc, &max_error,\n\t\t\t\t\t\t\ttvblank, in_vblank_irq);\n\t}\n\n\t \n\tif (!ret)\n\t\t*tvblank = ktime_get();\n\n\treturn ret;\n}\n\nstatic bool\ndrm_get_last_vbltimestamp(struct drm_device *dev, unsigned int pipe,\n\t\t\t  ktime_t *tvblank, bool in_vblank_irq)\n{\n\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\n\treturn drm_crtc_get_last_vbltimestamp(crtc, tvblank, in_vblank_irq);\n}\n\n \nu64 drm_crtc_vblank_count(struct drm_crtc *crtc)\n{\n\treturn drm_vblank_count(crtc->dev, drm_crtc_index(crtc));\n}\nEXPORT_SYMBOL(drm_crtc_vblank_count);\n\n \nstatic u64 drm_vblank_count_and_time(struct drm_device *dev, unsigned int pipe,\n\t\t\t\t     ktime_t *vblanktime)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tu64 vblank_count;\n\tunsigned int seq;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs)) {\n\t\t*vblanktime = 0;\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tseq = read_seqbegin(&vblank->seqlock);\n\t\tvblank_count = atomic64_read(&vblank->count);\n\t\t*vblanktime = vblank->time;\n\t} while (read_seqretry(&vblank->seqlock, seq));\n\n\treturn vblank_count;\n}\n\n \nu64 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,\n\t\t\t\t   ktime_t *vblanktime)\n{\n\treturn drm_vblank_count_and_time(crtc->dev, drm_crtc_index(crtc),\n\t\t\t\t\t vblanktime);\n}\nEXPORT_SYMBOL(drm_crtc_vblank_count_and_time);\n\n \nint drm_crtc_next_vblank_start(struct drm_crtc *crtc, ktime_t *vblanktime)\n{\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank;\n\tstruct drm_display_mode *mode;\n\tu64 vblank_start;\n\n\tif (!drm_dev_has_vblank(crtc->dev))\n\t\treturn -EINVAL;\n\n\tvblank = &crtc->dev->vblank[pipe];\n\tmode = &vblank->hwmode;\n\n\tif (!vblank->framedur_ns || !vblank->linedur_ns)\n\t\treturn -EINVAL;\n\n\tif (!drm_crtc_get_last_vbltimestamp(crtc, vblanktime, false))\n\t\treturn -EINVAL;\n\n\tvblank_start = DIV_ROUND_DOWN_ULL(\n\t\t\t(u64)vblank->framedur_ns * mode->crtc_vblank_start,\n\t\t\tmode->crtc_vtotal);\n\t*vblanktime  = ktime_add(*vblanktime, ns_to_ktime(vblank_start));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_crtc_next_vblank_start);\n\nstatic void send_vblank_event(struct drm_device *dev,\n\t\tstruct drm_pending_vblank_event *e,\n\t\tu64 seq, ktime_t now)\n{\n\tstruct timespec64 tv;\n\n\tswitch (e->event.base.type) {\n\tcase DRM_EVENT_VBLANK:\n\tcase DRM_EVENT_FLIP_COMPLETE:\n\t\ttv = ktime_to_timespec64(now);\n\t\te->event.vbl.sequence = seq;\n\t\t \n\t\te->event.vbl.tv_sec = tv.tv_sec;\n\t\te->event.vbl.tv_usec = tv.tv_nsec / 1000;\n\t\tbreak;\n\tcase DRM_EVENT_CRTC_SEQUENCE:\n\t\tif (seq)\n\t\t\te->event.seq.sequence = seq;\n\t\te->event.seq.time_ns = ktime_to_ns(now);\n\t\tbreak;\n\t}\n\ttrace_drm_vblank_event_delivered(e->base.file_priv, e->pipe, seq);\n\t \n\tdrm_send_event_timestamp_locked(dev, &e->base, now);\n}\n\n \nvoid drm_crtc_arm_vblank_event(struct drm_crtc *crtc,\n\t\t\t       struct drm_pending_vblank_event *e)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\n\tassert_spin_locked(&dev->event_lock);\n\n\te->pipe = pipe;\n\te->sequence = drm_crtc_accurate_vblank_count(crtc) + 1;\n\tlist_add_tail(&e->base.link, &dev->vblank_event_list);\n}\nEXPORT_SYMBOL(drm_crtc_arm_vblank_event);\n\n \nvoid drm_crtc_send_vblank_event(struct drm_crtc *crtc,\n\t\t\t\tstruct drm_pending_vblank_event *e)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tu64 seq;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tktime_t now;\n\n\tif (drm_dev_has_vblank(dev)) {\n\t\tseq = drm_vblank_count_and_time(dev, pipe, &now);\n\t} else {\n\t\tseq = 0;\n\n\t\tnow = ktime_get();\n\t}\n\te->pipe = pipe;\n\tsend_vblank_event(dev, e, seq, now);\n}\nEXPORT_SYMBOL(drm_crtc_send_vblank_event);\n\nstatic int __enable_vblank(struct drm_device *dev, unsigned int pipe)\n{\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\n\t\tif (drm_WARN_ON(dev, !crtc))\n\t\t\treturn 0;\n\n\t\tif (crtc->funcs->enable_vblank)\n\t\t\treturn crtc->funcs->enable_vblank(crtc);\n\t}\n#ifdef CONFIG_DRM_LEGACY\n\telse if (dev->driver->enable_vblank) {\n\t\treturn dev->driver->enable_vblank(dev, pipe);\n\t}\n#endif\n\n\treturn -EINVAL;\n}\n\nstatic int drm_vblank_enable(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tint ret = 0;\n\n\tassert_spin_locked(&dev->vbl_lock);\n\n\tspin_lock(&dev->vblank_time_lock);\n\n\tif (!vblank->enabled) {\n\t\t \n\t\tret = __enable_vblank(dev, pipe);\n\t\tdrm_dbg_core(dev, \"enabling vblank on crtc %u, ret: %d\\n\",\n\t\t\t     pipe, ret);\n\t\tif (ret) {\n\t\t\tatomic_dec(&vblank->refcount);\n\t\t} else {\n\t\t\tdrm_update_vblank_count(dev, pipe, 0);\n\t\t\t \n\t\t\tWRITE_ONCE(vblank->enabled, true);\n\t\t}\n\t}\n\n\tspin_unlock(&dev->vblank_time_lock);\n\n\treturn ret;\n}\n\nint drm_vblank_get(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tunsigned long irqflags;\n\tint ret = 0;\n\n\tif (!drm_dev_has_vblank(dev))\n\t\treturn -EINVAL;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->vbl_lock, irqflags);\n\t \n\tif (atomic_add_return(1, &vblank->refcount) == 1) {\n\t\tret = drm_vblank_enable(dev, pipe);\n\t} else {\n\t\tif (!vblank->enabled) {\n\t\t\tatomic_dec(&vblank->refcount);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->vbl_lock, irqflags);\n\n\treturn ret;\n}\n\n \nint drm_crtc_vblank_get(struct drm_crtc *crtc)\n{\n\treturn drm_vblank_get(crtc->dev, drm_crtc_index(crtc));\n}\nEXPORT_SYMBOL(drm_crtc_vblank_get);\n\nvoid drm_vblank_put(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\tif (drm_WARN_ON(dev, atomic_read(&vblank->refcount) == 0))\n\t\treturn;\n\n\t \n\tif (atomic_dec_and_test(&vblank->refcount)) {\n\t\tif (drm_vblank_offdelay == 0)\n\t\t\treturn;\n\t\telse if (drm_vblank_offdelay < 0)\n\t\t\tvblank_disable_fn(&vblank->disable_timer);\n\t\telse if (!dev->vblank_disable_immediate)\n\t\t\tmod_timer(&vblank->disable_timer,\n\t\t\t\t  jiffies + ((drm_vblank_offdelay * HZ)/1000));\n\t}\n}\n\n \nvoid drm_crtc_vblank_put(struct drm_crtc *crtc)\n{\n\tdrm_vblank_put(crtc->dev, drm_crtc_index(crtc));\n}\nEXPORT_SYMBOL(drm_crtc_vblank_put);\n\n \nvoid drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tint ret;\n\tu64 last;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\tret = drm_vblank_get(dev, pipe);\n\tif (drm_WARN(dev, ret, \"vblank not available on crtc %i, ret=%i\\n\",\n\t\t     pipe, ret))\n\t\treturn;\n\n\tlast = drm_vblank_count(dev, pipe);\n\n\tret = wait_event_timeout(vblank->queue,\n\t\t\t\t last != drm_vblank_count(dev, pipe),\n\t\t\t\t msecs_to_jiffies(100));\n\n\tdrm_WARN(dev, ret == 0, \"vblank wait timed out on crtc %i\\n\", pipe);\n\n\tdrm_vblank_put(dev, pipe);\n}\nEXPORT_SYMBOL(drm_wait_one_vblank);\n\n \nvoid drm_crtc_wait_one_vblank(struct drm_crtc *crtc)\n{\n\tdrm_wait_one_vblank(crtc->dev, drm_crtc_index(crtc));\n}\nEXPORT_SYMBOL(drm_crtc_wait_one_vblank);\n\n \nvoid drm_crtc_vblank_off(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tstruct drm_pending_vblank_event *e, *t;\n\tktime_t now;\n\tu64 seq;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\t \n\tspin_lock_irq(&dev->event_lock);\n\n\tspin_lock(&dev->vbl_lock);\n\tdrm_dbg_vbl(dev, \"crtc %d, vblank enabled %d, inmodeset %d\\n\",\n\t\t    pipe, vblank->enabled, vblank->inmodeset);\n\n\t \n\tif (drm_core_check_feature(dev, DRIVER_ATOMIC) || !vblank->inmodeset)\n\t\tdrm_vblank_disable_and_save(dev, pipe);\n\n\twake_up(&vblank->queue);\n\n\t \n\tif (!vblank->inmodeset) {\n\t\tatomic_inc(&vblank->refcount);\n\t\tvblank->inmodeset = 1;\n\t}\n\tspin_unlock(&dev->vbl_lock);\n\n\t \n\tseq = drm_vblank_count_and_time(dev, pipe, &now);\n\n\tlist_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {\n\t\tif (e->pipe != pipe)\n\t\t\tcontinue;\n\t\tdrm_dbg_core(dev, \"Sending premature vblank event on disable: \"\n\t\t\t     \"wanted %llu, current %llu\\n\",\n\t\t\t     e->sequence, seq);\n\t\tlist_del(&e->base.link);\n\t\tdrm_vblank_put(dev, pipe);\n\t\tsend_vblank_event(dev, e, seq, now);\n\t}\n\n\t \n\tdrm_vblank_cancel_pending_works(vblank);\n\n\tspin_unlock_irq(&dev->event_lock);\n\n\t \n\tvblank->hwmode.crtc_clock = 0;\n\n\t \n\tdrm_vblank_flush_worker(vblank);\n}\nEXPORT_SYMBOL(drm_crtc_vblank_off);\n\n \nvoid drm_crtc_vblank_reset(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\tspin_lock_irq(&dev->vbl_lock);\n\t \n\tif (!vblank->inmodeset) {\n\t\tatomic_inc(&vblank->refcount);\n\t\tvblank->inmodeset = 1;\n\t}\n\tspin_unlock_irq(&dev->vbl_lock);\n\n\tdrm_WARN_ON(dev, !list_empty(&dev->vblank_event_list));\n\tdrm_WARN_ON(dev, !list_empty(&vblank->pending_work));\n}\nEXPORT_SYMBOL(drm_crtc_vblank_reset);\n\n \nvoid drm_crtc_set_max_vblank_count(struct drm_crtc *crtc,\n\t\t\t\t   u32 max_vblank_count)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\tdrm_WARN_ON(dev, dev->max_vblank_count);\n\tdrm_WARN_ON(dev, !READ_ONCE(vblank->inmodeset));\n\n\tvblank->max_vblank_count = max_vblank_count;\n}\nEXPORT_SYMBOL(drm_crtc_set_max_vblank_count);\n\n \nvoid drm_crtc_vblank_on(struct drm_crtc *crtc)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tunsigned int pipe = drm_crtc_index(crtc);\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\tspin_lock_irq(&dev->vbl_lock);\n\tdrm_dbg_vbl(dev, \"crtc %d, vblank enabled %d, inmodeset %d\\n\",\n\t\t    pipe, vblank->enabled, vblank->inmodeset);\n\n\t \n\tif (vblank->inmodeset) {\n\t\tatomic_dec(&vblank->refcount);\n\t\tvblank->inmodeset = 0;\n\t}\n\n\tdrm_reset_vblank_timestamp(dev, pipe);\n\n\t \n\tif (atomic_read(&vblank->refcount) != 0 || drm_vblank_offdelay == 0)\n\t\tdrm_WARN_ON(dev, drm_vblank_enable(dev, pipe));\n\tspin_unlock_irq(&dev->vbl_lock);\n}\nEXPORT_SYMBOL(drm_crtc_vblank_on);\n\nstatic void drm_vblank_restore(struct drm_device *dev, unsigned int pipe)\n{\n\tktime_t t_vblank;\n\tstruct drm_vblank_crtc *vblank;\n\tint framedur_ns;\n\tu64 diff_ns;\n\tu32 cur_vblank, diff = 1;\n\tint count = DRM_TIMESTAMP_MAXRETRIES;\n\tu32 max_vblank_count = drm_max_vblank_count(dev, pipe);\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\tassert_spin_locked(&dev->vbl_lock);\n\tassert_spin_locked(&dev->vblank_time_lock);\n\n\tvblank = &dev->vblank[pipe];\n\tdrm_WARN_ONCE(dev,\n\t\t      drm_debug_enabled(DRM_UT_VBL) && !vblank->framedur_ns,\n\t\t      \"Cannot compute missed vblanks without frame duration\\n\");\n\tframedur_ns = vblank->framedur_ns;\n\n\tdo {\n\t\tcur_vblank = __get_vblank_counter(dev, pipe);\n\t\tdrm_get_last_vbltimestamp(dev, pipe, &t_vblank, false);\n\t} while (cur_vblank != __get_vblank_counter(dev, pipe) && --count > 0);\n\n\tdiff_ns = ktime_to_ns(ktime_sub(t_vblank, vblank->time));\n\tif (framedur_ns)\n\t\tdiff = DIV_ROUND_CLOSEST_ULL(diff_ns, framedur_ns);\n\n\n\tdrm_dbg_vbl(dev,\n\t\t    \"missed %d vblanks in %lld ns, frame duration=%d ns, hw_diff=%d\\n\",\n\t\t    diff, diff_ns, framedur_ns, cur_vblank - vblank->last);\n\tvblank->last = (cur_vblank - diff) & max_vblank_count;\n}\n\n \nvoid drm_crtc_vblank_restore(struct drm_crtc *crtc)\n{\n\tWARN_ON_ONCE(!crtc->funcs->get_vblank_timestamp);\n\tWARN_ON_ONCE(!crtc->dev->vblank_disable_immediate);\n\n\tdrm_vblank_restore(crtc->dev, drm_crtc_index(crtc));\n}\nEXPORT_SYMBOL(drm_crtc_vblank_restore);\n\nstatic void drm_legacy_vblank_pre_modeset(struct drm_device *dev,\n\t\t\t\t\t  unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\t \n\tif (!drm_dev_has_vblank(dev))\n\t\treturn;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\t \n\tif (!vblank->inmodeset) {\n\t\tvblank->inmodeset = 0x1;\n\t\tif (drm_vblank_get(dev, pipe) == 0)\n\t\t\tvblank->inmodeset |= 0x2;\n\t}\n}\n\nstatic void drm_legacy_vblank_post_modeset(struct drm_device *dev,\n\t\t\t\t\t   unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\n\t \n\tif (!drm_dev_has_vblank(dev))\n\t\treturn;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn;\n\n\tif (vblank->inmodeset) {\n\t\tspin_lock_irq(&dev->vbl_lock);\n\t\tdrm_reset_vblank_timestamp(dev, pipe);\n\t\tspin_unlock_irq(&dev->vbl_lock);\n\n\t\tif (vblank->inmodeset & 0x2)\n\t\t\tdrm_vblank_put(dev, pipe);\n\n\t\tvblank->inmodeset = 0;\n\t}\n}\n\nint drm_legacy_modeset_ctl_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv)\n{\n\tstruct drm_modeset_ctl *modeset = data;\n\tunsigned int pipe;\n\n\t \n\tif (!drm_dev_has_vblank(dev))\n\t\treturn 0;\n\n\t \n\tif (!drm_core_check_feature(dev, DRIVER_LEGACY))\n\t\treturn 0;\n\n\tpipe = modeset->crtc;\n\tif (pipe >= dev->num_crtcs)\n\t\treturn -EINVAL;\n\n\tswitch (modeset->cmd) {\n\tcase _DRM_PRE_MODESET:\n\t\tdrm_legacy_vblank_pre_modeset(dev, pipe);\n\t\tbreak;\n\tcase _DRM_POST_MODESET:\n\t\tdrm_legacy_vblank_post_modeset(dev, pipe);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int drm_queue_vblank_event(struct drm_device *dev, unsigned int pipe,\n\t\t\t\t  u64 req_seq,\n\t\t\t\t  union drm_wait_vblank *vblwait,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tstruct drm_pending_vblank_event *e;\n\tktime_t now;\n\tu64 seq;\n\tint ret;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (e == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put;\n\t}\n\n\te->pipe = pipe;\n\te->event.base.type = DRM_EVENT_VBLANK;\n\te->event.base.length = sizeof(e->event.vbl);\n\te->event.vbl.user_data = vblwait->request.signal;\n\te->event.vbl.crtc_id = 0;\n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\n\t\tif (crtc)\n\t\t\te->event.vbl.crtc_id = crtc->base.id;\n\t}\n\n\tspin_lock_irq(&dev->event_lock);\n\n\t \n\tif (!READ_ONCE(vblank->enabled)) {\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tret = drm_event_reserve_init_locked(dev, file_priv, &e->base,\n\t\t\t\t\t    &e->event.base);\n\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tseq = drm_vblank_count_and_time(dev, pipe, &now);\n\n\tdrm_dbg_core(dev, \"event on vblank count %llu, current %llu, crtc %u\\n\",\n\t\t     req_seq, seq, pipe);\n\n\ttrace_drm_vblank_event_queued(file_priv, pipe, req_seq);\n\n\te->sequence = req_seq;\n\tif (drm_vblank_passed(seq, req_seq)) {\n\t\tdrm_vblank_put(dev, pipe);\n\t\tsend_vblank_event(dev, e, seq, now);\n\t\tvblwait->reply.sequence = seq;\n\t} else {\n\t\t \n\t\tlist_add_tail(&e->base.link, &dev->vblank_event_list);\n\t\tvblwait->reply.sequence = req_seq;\n\t}\n\n\tspin_unlock_irq(&dev->event_lock);\n\n\treturn 0;\n\nerr_unlock:\n\tspin_unlock_irq(&dev->event_lock);\n\tkfree(e);\nerr_put:\n\tdrm_vblank_put(dev, pipe);\n\treturn ret;\n}\n\nstatic bool drm_wait_vblank_is_query(union drm_wait_vblank *vblwait)\n{\n\tif (vblwait->request.sequence)\n\t\treturn false;\n\n\treturn _DRM_VBLANK_RELATIVE ==\n\t\t(vblwait->request.type & (_DRM_VBLANK_TYPES_MASK |\n\t\t\t\t\t  _DRM_VBLANK_EVENT |\n\t\t\t\t\t  _DRM_VBLANK_NEXTONMISS));\n}\n\n \n\nstatic u64 widen_32_to_64(u32 narrow, u64 near)\n{\n\treturn near + (s32) (narrow - near);\n}\n\nstatic void drm_wait_vblank_reply(struct drm_device *dev, unsigned int pipe,\n\t\t\t\t  struct drm_wait_vblank_reply *reply)\n{\n\tktime_t now;\n\tstruct timespec64 ts;\n\n\t \n\treply->sequence = drm_vblank_count_and_time(dev, pipe, &now);\n\tts = ktime_to_timespec64(now);\n\treply->tval_sec = (u32)ts.tv_sec;\n\treply->tval_usec = ts.tv_nsec / 1000;\n}\n\nstatic bool drm_wait_vblank_supported(struct drm_device *dev)\n{\n#if IS_ENABLED(CONFIG_DRM_LEGACY)\n\tif (unlikely(drm_core_check_feature(dev, DRIVER_LEGACY)))\n\t\treturn dev->irq_enabled;\n#endif\n\treturn drm_dev_has_vblank(dev);\n}\n\nint drm_wait_vblank_ioctl(struct drm_device *dev, void *data,\n\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_vblank_crtc *vblank;\n\tunion drm_wait_vblank *vblwait = data;\n\tint ret;\n\tu64 req_seq, seq;\n\tunsigned int pipe_index;\n\tunsigned int flags, pipe, high_pipe;\n\n\tif (!drm_wait_vblank_supported(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vblwait->request.type & _DRM_VBLANK_SIGNAL)\n\t\treturn -EINVAL;\n\n\tif (vblwait->request.type &\n\t    ~(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |\n\t      _DRM_VBLANK_HIGH_CRTC_MASK)) {\n\t\tdrm_dbg_core(dev,\n\t\t\t     \"Unsupported type value 0x%x, supported mask 0x%x\\n\",\n\t\t\t     vblwait->request.type,\n\t\t\t     (_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |\n\t\t\t      _DRM_VBLANK_HIGH_CRTC_MASK));\n\t\treturn -EINVAL;\n\t}\n\n\tflags = vblwait->request.type & _DRM_VBLANK_FLAGS_MASK;\n\thigh_pipe = (vblwait->request.type & _DRM_VBLANK_HIGH_CRTC_MASK);\n\tif (high_pipe)\n\t\tpipe_index = high_pipe >> _DRM_VBLANK_HIGH_CRTC_SHIFT;\n\telse\n\t\tpipe_index = flags & _DRM_VBLANK_SECONDARY ? 1 : 0;\n\n\t \n\tif (drm_core_check_feature(dev, DRIVER_MODESET)) {\n\t\tpipe = 0;\n\t\tdrm_for_each_crtc(crtc, dev) {\n\t\t\tif (drm_lease_held(file_priv, crtc->base.id)) {\n\t\t\t\tif (pipe_index == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tpipe_index--;\n\t\t\t}\n\t\t\tpipe++;\n\t\t}\n\t} else {\n\t\tpipe = pipe_index;\n\t}\n\n\tif (pipe >= dev->num_crtcs)\n\t\treturn -EINVAL;\n\n\tvblank = &dev->vblank[pipe];\n\n\t \n\tif (dev->vblank_disable_immediate &&\n\t    drm_wait_vblank_is_query(vblwait) &&\n\t    READ_ONCE(vblank->enabled)) {\n\t\tdrm_wait_vblank_reply(dev, pipe, &vblwait->reply);\n\t\treturn 0;\n\t}\n\n\tret = drm_vblank_get(dev, pipe);\n\tif (ret) {\n\t\tdrm_dbg_core(dev,\n\t\t\t     \"crtc %d failed to acquire vblank counter, %d\\n\",\n\t\t\t     pipe, ret);\n\t\treturn ret;\n\t}\n\tseq = drm_vblank_count(dev, pipe);\n\n\tswitch (vblwait->request.type & _DRM_VBLANK_TYPES_MASK) {\n\tcase _DRM_VBLANK_RELATIVE:\n\t\treq_seq = seq + vblwait->request.sequence;\n\t\tvblwait->request.sequence = req_seq;\n\t\tvblwait->request.type &= ~_DRM_VBLANK_RELATIVE;\n\t\tbreak;\n\tcase _DRM_VBLANK_ABSOLUTE:\n\t\treq_seq = widen_32_to_64(vblwait->request.sequence, seq);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif ((flags & _DRM_VBLANK_NEXTONMISS) &&\n\t    drm_vblank_passed(seq, req_seq)) {\n\t\treq_seq = seq + 1;\n\t\tvblwait->request.type &= ~_DRM_VBLANK_NEXTONMISS;\n\t\tvblwait->request.sequence = req_seq;\n\t}\n\n\tif (flags & _DRM_VBLANK_EVENT) {\n\t\t \n\t\treturn drm_queue_vblank_event(dev, pipe, req_seq, vblwait, file_priv);\n\t}\n\n\tif (req_seq != seq) {\n\t\tint wait;\n\n\t\tdrm_dbg_core(dev, \"waiting on vblank count %llu, crtc %u\\n\",\n\t\t\t     req_seq, pipe);\n\t\twait = wait_event_interruptible_timeout(vblank->queue,\n\t\t\tdrm_vblank_passed(drm_vblank_count(dev, pipe), req_seq) ||\n\t\t\t\t      !READ_ONCE(vblank->enabled),\n\t\t\tmsecs_to_jiffies(3000));\n\n\t\tswitch (wait) {\n\t\tcase 0:\n\t\t\t \n\t\t\tret = -EBUSY;\n\t\t\tbreak;\n\t\tcase -ERESTARTSYS:\n\t\t\t \n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != -EINTR) {\n\t\tdrm_wait_vblank_reply(dev, pipe, &vblwait->reply);\n\n\t\tdrm_dbg_core(dev, \"crtc %d returning %u to client\\n\",\n\t\t\t     pipe, vblwait->reply.sequence);\n\t} else {\n\t\tdrm_dbg_core(dev, \"crtc %d vblank wait interrupted by signal\\n\",\n\t\t\t     pipe);\n\t}\n\ndone:\n\tdrm_vblank_put(dev, pipe);\n\treturn ret;\n}\n\nstatic void drm_handle_vblank_events(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_crtc *crtc = drm_crtc_from_index(dev, pipe);\n\tbool high_prec = false;\n\tstruct drm_pending_vblank_event *e, *t;\n\tktime_t now;\n\tu64 seq;\n\n\tassert_spin_locked(&dev->event_lock);\n\n\tseq = drm_vblank_count_and_time(dev, pipe, &now);\n\n\tlist_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {\n\t\tif (e->pipe != pipe)\n\t\t\tcontinue;\n\t\tif (!drm_vblank_passed(seq, e->sequence))\n\t\t\tcontinue;\n\n\t\tdrm_dbg_core(dev, \"vblank event on %llu, current %llu\\n\",\n\t\t\t     e->sequence, seq);\n\n\t\tlist_del(&e->base.link);\n\t\tdrm_vblank_put(dev, pipe);\n\t\tsend_vblank_event(dev, e, seq, now);\n\t}\n\n\tif (crtc && crtc->funcs->get_vblank_timestamp)\n\t\thigh_prec = true;\n\n\ttrace_drm_vblank_event(pipe, seq, now, high_prec);\n}\n\n \nbool drm_handle_vblank(struct drm_device *dev, unsigned int pipe)\n{\n\tstruct drm_vblank_crtc *vblank = &dev->vblank[pipe];\n\tunsigned long irqflags;\n\tbool disable_irq;\n\n\tif (drm_WARN_ON_ONCE(dev, !drm_dev_has_vblank(dev)))\n\t\treturn false;\n\n\tif (drm_WARN_ON(dev, pipe >= dev->num_crtcs))\n\t\treturn false;\n\n\tspin_lock_irqsave(&dev->event_lock, irqflags);\n\n\t \n\tspin_lock(&dev->vblank_time_lock);\n\n\t \n\tif (!vblank->enabled) {\n\t\tspin_unlock(&dev->vblank_time_lock);\n\t\tspin_unlock_irqrestore(&dev->event_lock, irqflags);\n\t\treturn false;\n\t}\n\n\tdrm_update_vblank_count(dev, pipe, true);\n\n\tspin_unlock(&dev->vblank_time_lock);\n\n\twake_up(&vblank->queue);\n\n\t \n\tdisable_irq = (dev->vblank_disable_immediate &&\n\t\t       drm_vblank_offdelay > 0 &&\n\t\t       !atomic_read(&vblank->refcount));\n\n\tdrm_handle_vblank_events(dev, pipe);\n\tdrm_handle_vblank_works(vblank);\n\n\tspin_unlock_irqrestore(&dev->event_lock, irqflags);\n\n\tif (disable_irq)\n\t\tvblank_disable_fn(&vblank->disable_timer);\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_handle_vblank);\n\n \nbool drm_crtc_handle_vblank(struct drm_crtc *crtc)\n{\n\treturn drm_handle_vblank(crtc->dev, drm_crtc_index(crtc));\n}\nEXPORT_SYMBOL(drm_crtc_handle_vblank);\n\n \n\nint drm_crtc_get_sequence_ioctl(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_vblank_crtc *vblank;\n\tint pipe;\n\tstruct drm_crtc_get_sequence *get_seq = data;\n\tktime_t now;\n\tbool vblank_enabled;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!drm_dev_has_vblank(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tcrtc = drm_crtc_find(dev, file_priv, get_seq->crtc_id);\n\tif (!crtc)\n\t\treturn -ENOENT;\n\n\tpipe = drm_crtc_index(crtc);\n\n\tvblank = &dev->vblank[pipe];\n\tvblank_enabled = dev->vblank_disable_immediate && READ_ONCE(vblank->enabled);\n\n\tif (!vblank_enabled) {\n\t\tret = drm_crtc_vblank_get(crtc);\n\t\tif (ret) {\n\t\t\tdrm_dbg_core(dev,\n\t\t\t\t     \"crtc %d failed to acquire vblank counter, %d\\n\",\n\t\t\t\t     pipe, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdrm_modeset_lock(&crtc->mutex, NULL);\n\tif (crtc->state)\n\t\tget_seq->active = crtc->state->enable;\n\telse\n\t\tget_seq->active = crtc->enabled;\n\tdrm_modeset_unlock(&crtc->mutex);\n\tget_seq->sequence = drm_vblank_count_and_time(dev, pipe, &now);\n\tget_seq->sequence_ns = ktime_to_ns(now);\n\tif (!vblank_enabled)\n\t\tdrm_crtc_vblank_put(crtc);\n\treturn 0;\n}\n\n \n\nint drm_crtc_queue_sequence_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_vblank_crtc *vblank;\n\tint pipe;\n\tstruct drm_crtc_queue_sequence *queue_seq = data;\n\tktime_t now;\n\tstruct drm_pending_vblank_event *e;\n\tu32 flags;\n\tu64 seq;\n\tu64 req_seq;\n\tint ret;\n\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!drm_dev_has_vblank(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tcrtc = drm_crtc_find(dev, file_priv, queue_seq->crtc_id);\n\tif (!crtc)\n\t\treturn -ENOENT;\n\n\tflags = queue_seq->flags;\n\t \n\tif (flags & ~(DRM_CRTC_SEQUENCE_RELATIVE|\n\t\t      DRM_CRTC_SEQUENCE_NEXT_ON_MISS))\n\t\treturn -EINVAL;\n\n\tpipe = drm_crtc_index(crtc);\n\n\tvblank = &dev->vblank[pipe];\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (e == NULL)\n\t\treturn -ENOMEM;\n\n\tret = drm_crtc_vblank_get(crtc);\n\tif (ret) {\n\t\tdrm_dbg_core(dev,\n\t\t\t     \"crtc %d failed to acquire vblank counter, %d\\n\",\n\t\t\t     pipe, ret);\n\t\tgoto err_free;\n\t}\n\n\tseq = drm_vblank_count_and_time(dev, pipe, &now);\n\treq_seq = queue_seq->sequence;\n\n\tif (flags & DRM_CRTC_SEQUENCE_RELATIVE)\n\t\treq_seq += seq;\n\n\tif ((flags & DRM_CRTC_SEQUENCE_NEXT_ON_MISS) && drm_vblank_passed(seq, req_seq))\n\t\treq_seq = seq + 1;\n\n\te->pipe = pipe;\n\te->event.base.type = DRM_EVENT_CRTC_SEQUENCE;\n\te->event.base.length = sizeof(e->event.seq);\n\te->event.seq.user_data = queue_seq->user_data;\n\n\tspin_lock_irq(&dev->event_lock);\n\n\t \n\tif (!READ_ONCE(vblank->enabled)) {\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tret = drm_event_reserve_init_locked(dev, file_priv, &e->base,\n\t\t\t\t\t    &e->event.base);\n\n\tif (ret)\n\t\tgoto err_unlock;\n\n\te->sequence = req_seq;\n\n\tif (drm_vblank_passed(seq, req_seq)) {\n\t\tdrm_crtc_vblank_put(crtc);\n\t\tsend_vblank_event(dev, e, seq, now);\n\t\tqueue_seq->sequence = seq;\n\t} else {\n\t\t \n\t\tlist_add_tail(&e->base.link, &dev->vblank_event_list);\n\t\tqueue_seq->sequence = req_seq;\n\t}\n\n\tspin_unlock_irq(&dev->event_lock);\n\treturn 0;\n\nerr_unlock:\n\tspin_unlock_irq(&dev->event_lock);\n\tdrm_crtc_vblank_put(crtc);\nerr_free:\n\tkfree(e);\n\treturn ret;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}