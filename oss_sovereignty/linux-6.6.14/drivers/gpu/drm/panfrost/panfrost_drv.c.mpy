{
  "module_name": "panfrost_drv.c",
  "hash_id": "427f79c10b77e896f986d7323f5a9de003925a8d2616548746f9949f8b6727f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_drv.c",
  "human_readable_source": "\n \n \n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pagemap.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <drm/panfrost_drm.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_ioctl.h>\n#include <drm/drm_syncobj.h>\n#include <drm/drm_utils.h>\n\n#include \"panfrost_device.h\"\n#include \"panfrost_gem.h\"\n#include \"panfrost_mmu.h\"\n#include \"panfrost_job.h\"\n#include \"panfrost_gpu.h\"\n#include \"panfrost_perfcnt.h\"\n\nstatic bool unstable_ioctls;\nmodule_param_unsafe(unstable_ioctls, bool, 0600);\n\nstatic int panfrost_ioctl_get_param(struct drm_device *ddev, void *data, struct drm_file *file)\n{\n\tstruct drm_panfrost_get_param *param = data;\n\tstruct panfrost_device *pfdev = ddev->dev_private;\n\n\tif (param->pad != 0)\n\t\treturn -EINVAL;\n\n#define PANFROST_FEATURE(name, member)\t\t\t\\\n\tcase DRM_PANFROST_PARAM_ ## name:\t\t\\\n\t\tparam->value = pfdev->features.member;\t\\\n\t\tbreak\n#define PANFROST_FEATURE_ARRAY(name, member, max)\t\t\t\\\n\tcase DRM_PANFROST_PARAM_ ## name ## 0 ...\t\t\t\\\n\t\tDRM_PANFROST_PARAM_ ## name ## max:\t\t\t\\\n\t\tparam->value = pfdev->features.member[param->param -\t\\\n\t\t\tDRM_PANFROST_PARAM_ ## name ## 0];\t\t\\\n\t\tbreak\n\n\tswitch (param->param) {\n\t\tPANFROST_FEATURE(GPU_PROD_ID, id);\n\t\tPANFROST_FEATURE(GPU_REVISION, revision);\n\t\tPANFROST_FEATURE(SHADER_PRESENT, shader_present);\n\t\tPANFROST_FEATURE(TILER_PRESENT, tiler_present);\n\t\tPANFROST_FEATURE(L2_PRESENT, l2_present);\n\t\tPANFROST_FEATURE(STACK_PRESENT, stack_present);\n\t\tPANFROST_FEATURE(AS_PRESENT, as_present);\n\t\tPANFROST_FEATURE(JS_PRESENT, js_present);\n\t\tPANFROST_FEATURE(L2_FEATURES, l2_features);\n\t\tPANFROST_FEATURE(CORE_FEATURES, core_features);\n\t\tPANFROST_FEATURE(TILER_FEATURES, tiler_features);\n\t\tPANFROST_FEATURE(MEM_FEATURES, mem_features);\n\t\tPANFROST_FEATURE(MMU_FEATURES, mmu_features);\n\t\tPANFROST_FEATURE(THREAD_FEATURES, thread_features);\n\t\tPANFROST_FEATURE(MAX_THREADS, max_threads);\n\t\tPANFROST_FEATURE(THREAD_MAX_WORKGROUP_SZ,\n\t\t\t\tthread_max_workgroup_sz);\n\t\tPANFROST_FEATURE(THREAD_MAX_BARRIER_SZ,\n\t\t\t\tthread_max_barrier_sz);\n\t\tPANFROST_FEATURE(COHERENCY_FEATURES, coherency_features);\n\t\tPANFROST_FEATURE(AFBC_FEATURES, afbc_features);\n\t\tPANFROST_FEATURE_ARRAY(TEXTURE_FEATURES, texture_features, 3);\n\t\tPANFROST_FEATURE_ARRAY(JS_FEATURES, js_features, 15);\n\t\tPANFROST_FEATURE(NR_CORE_GROUPS, nr_core_groups);\n\t\tPANFROST_FEATURE(THREAD_TLS_ALLOC, thread_tls_alloc);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int panfrost_ioctl_create_bo(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct panfrost_file_priv *priv = file->driver_priv;\n\tstruct panfrost_gem_object *bo;\n\tstruct drm_panfrost_create_bo *args = data;\n\tstruct panfrost_gem_mapping *mapping;\n\tint ret;\n\n\tif (!args->size || args->pad ||\n\t    (args->flags & ~(PANFROST_BO_NOEXEC | PANFROST_BO_HEAP)))\n\t\treturn -EINVAL;\n\n\t \n\tif ((args->flags & PANFROST_BO_HEAP) &&\n\t    !(args->flags & PANFROST_BO_NOEXEC))\n\t\treturn -EINVAL;\n\n\tbo = panfrost_gem_create(dev, args->size, args->flags);\n\tif (IS_ERR(bo))\n\t\treturn PTR_ERR(bo);\n\n\tret = drm_gem_handle_create(file, &bo->base.base, &args->handle);\n\tif (ret)\n\t\tgoto out;\n\n\tmapping = panfrost_gem_mapping_get(bo, priv);\n\tif (mapping) {\n\t\targs->offset = mapping->mmnode.start << PAGE_SHIFT;\n\t\tpanfrost_gem_mapping_put(mapping);\n\t} else {\n\t\t \n\t\tret = -EINVAL;\n\t}\n\nout:\n\tdrm_gem_object_put(&bo->base.base);\n\treturn ret;\n}\n\n \nstatic int\npanfrost_lookup_bos(struct drm_device *dev,\n\t\t  struct drm_file *file_priv,\n\t\t  struct drm_panfrost_submit *args,\n\t\t  struct panfrost_job *job)\n{\n\tstruct panfrost_file_priv *priv = file_priv->driver_priv;\n\tstruct panfrost_gem_object *bo;\n\tunsigned int i;\n\tint ret;\n\n\tjob->bo_count = args->bo_handle_count;\n\n\tif (!job->bo_count)\n\t\treturn 0;\n\n\tret = drm_gem_objects_lookup(file_priv,\n\t\t\t\t     (void __user *)(uintptr_t)args->bo_handles,\n\t\t\t\t     job->bo_count, &job->bos);\n\tif (ret)\n\t\treturn ret;\n\n\tjob->mappings = kvmalloc_array(job->bo_count,\n\t\t\t\t       sizeof(struct panfrost_gem_mapping *),\n\t\t\t\t       GFP_KERNEL | __GFP_ZERO);\n\tif (!job->mappings)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tstruct panfrost_gem_mapping *mapping;\n\n\t\tbo = to_panfrost_bo(job->bos[i]);\n\t\tmapping = panfrost_gem_mapping_get(bo, priv);\n\t\tif (!mapping) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_inc(&bo->gpu_usecount);\n\t\tjob->mappings[i] = mapping;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\npanfrost_copy_in_sync(struct drm_device *dev,\n\t\t  struct drm_file *file_priv,\n\t\t  struct drm_panfrost_submit *args,\n\t\t  struct panfrost_job *job)\n{\n\tu32 *handles;\n\tint ret = 0;\n\tint i, in_fence_count;\n\n\tin_fence_count = args->in_sync_count;\n\n\tif (!in_fence_count)\n\t\treturn 0;\n\n\thandles = kvmalloc_array(in_fence_count, sizeof(u32), GFP_KERNEL);\n\tif (!handles) {\n\t\tret = -ENOMEM;\n\t\tDRM_DEBUG(\"Failed to allocate incoming syncobj handles\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (copy_from_user(handles,\n\t\t\t   (void __user *)(uintptr_t)args->in_syncs,\n\t\t\t   in_fence_count * sizeof(u32))) {\n\t\tret = -EFAULT;\n\t\tDRM_DEBUG(\"Failed to copy in syncobj handles\\n\");\n\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < in_fence_count; i++) {\n\t\tret = drm_sched_job_add_syncobj_dependency(&job->base, file_priv,\n\t\t\t\t\t\t\t   handles[i], 0);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\nfail:\n\tkvfree(handles);\n\treturn ret;\n}\n\nstatic int panfrost_ioctl_submit(struct drm_device *dev, void *data,\n\t\tstruct drm_file *file)\n{\n\tstruct panfrost_device *pfdev = dev->dev_private;\n\tstruct panfrost_file_priv *file_priv = file->driver_priv;\n\tstruct drm_panfrost_submit *args = data;\n\tstruct drm_syncobj *sync_out = NULL;\n\tstruct panfrost_job *job;\n\tint ret = 0, slot;\n\n\tif (!args->jc)\n\t\treturn -EINVAL;\n\n\tif (args->requirements && args->requirements != PANFROST_JD_REQ_FS)\n\t\treturn -EINVAL;\n\n\tif (args->out_sync > 0) {\n\t\tsync_out = drm_syncobj_find(file, args->out_sync);\n\t\tif (!sync_out)\n\t\t\treturn -ENODEV;\n\t}\n\n\tjob = kzalloc(sizeof(*job), GFP_KERNEL);\n\tif (!job) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_syncout;\n\t}\n\n\tkref_init(&job->refcount);\n\n\tjob->pfdev = pfdev;\n\tjob->jc = args->jc;\n\tjob->requirements = args->requirements;\n\tjob->flush_id = panfrost_gpu_get_latest_flush_id(pfdev);\n\tjob->mmu = file_priv->mmu;\n\n\tslot = panfrost_job_get_slot(job);\n\n\tret = drm_sched_job_init(&job->base,\n\t\t\t\t &file_priv->sched_entity[slot],\n\t\t\t\t NULL);\n\tif (ret)\n\t\tgoto out_put_job;\n\n\tret = panfrost_copy_in_sync(dev, file, args, job);\n\tif (ret)\n\t\tgoto out_cleanup_job;\n\n\tret = panfrost_lookup_bos(dev, file, args, job);\n\tif (ret)\n\t\tgoto out_cleanup_job;\n\n\tret = panfrost_job_push(job);\n\tif (ret)\n\t\tgoto out_cleanup_job;\n\n\t \n\tif (sync_out)\n\t\tdrm_syncobj_replace_fence(sync_out, job->render_done_fence);\n\nout_cleanup_job:\n\tif (ret)\n\t\tdrm_sched_job_cleanup(&job->base);\nout_put_job:\n\tpanfrost_job_put(job);\nout_put_syncout:\n\tif (sync_out)\n\t\tdrm_syncobj_put(sync_out);\n\n\treturn ret;\n}\n\nstatic int\npanfrost_ioctl_wait_bo(struct drm_device *dev, void *data,\n\t\t       struct drm_file *file_priv)\n{\n\tlong ret;\n\tstruct drm_panfrost_wait_bo *args = data;\n\tstruct drm_gem_object *gem_obj;\n\tunsigned long timeout = drm_timeout_abs_to_jiffies(args->timeout_ns);\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tgem_obj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!gem_obj)\n\t\treturn -ENOENT;\n\n\tret = dma_resv_wait_timeout(gem_obj->resv, DMA_RESV_USAGE_READ,\n\t\t\t\t    true, timeout);\n\tif (!ret)\n\t\tret = timeout ? -ETIMEDOUT : -EBUSY;\n\n\tdrm_gem_object_put(gem_obj);\n\n\treturn ret;\n}\n\nstatic int panfrost_ioctl_mmap_bo(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_panfrost_mmap_bo *args = data;\n\tstruct drm_gem_object *gem_obj;\n\tint ret;\n\n\tif (args->flags != 0) {\n\t\tDRM_INFO(\"unknown mmap_bo flags: %d\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tgem_obj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!gem_obj) {\n\t\tDRM_DEBUG(\"Failed to look up GEM BO %d\\n\", args->handle);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (to_panfrost_bo(gem_obj)->is_heap) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = drm_gem_create_mmap_offset(gem_obj);\n\tif (ret == 0)\n\t\targs->offset = drm_vma_node_offset_addr(&gem_obj->vma_node);\n\nout:\n\tdrm_gem_object_put(gem_obj);\n\treturn ret;\n}\n\nstatic int panfrost_ioctl_get_bo_offset(struct drm_device *dev, void *data,\n\t\t\t    struct drm_file *file_priv)\n{\n\tstruct panfrost_file_priv *priv = file_priv->driver_priv;\n\tstruct drm_panfrost_get_bo_offset *args = data;\n\tstruct panfrost_gem_mapping *mapping;\n\tstruct drm_gem_object *gem_obj;\n\tstruct panfrost_gem_object *bo;\n\n\tgem_obj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!gem_obj) {\n\t\tDRM_DEBUG(\"Failed to look up GEM BO %d\\n\", args->handle);\n\t\treturn -ENOENT;\n\t}\n\tbo = to_panfrost_bo(gem_obj);\n\n\tmapping = panfrost_gem_mapping_get(bo, priv);\n\tdrm_gem_object_put(gem_obj);\n\n\tif (!mapping)\n\t\treturn -EINVAL;\n\n\targs->offset = mapping->mmnode.start << PAGE_SHIFT;\n\tpanfrost_gem_mapping_put(mapping);\n\treturn 0;\n}\n\nstatic int panfrost_ioctl_madvise(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct panfrost_file_priv *priv = file_priv->driver_priv;\n\tstruct drm_panfrost_madvise *args = data;\n\tstruct panfrost_device *pfdev = dev->dev_private;\n\tstruct drm_gem_object *gem_obj;\n\tstruct panfrost_gem_object *bo;\n\tint ret = 0;\n\n\tgem_obj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!gem_obj) {\n\t\tDRM_DEBUG(\"Failed to look up GEM BO %d\\n\", args->handle);\n\t\treturn -ENOENT;\n\t}\n\n\tbo = to_panfrost_bo(gem_obj);\n\n\tret = dma_resv_lock_interruptible(bo->base.base.resv, NULL);\n\tif (ret)\n\t\tgoto out_put_object;\n\n\tmutex_lock(&pfdev->shrinker_lock);\n\tmutex_lock(&bo->mappings.lock);\n\tif (args->madv == PANFROST_MADV_DONTNEED) {\n\t\tstruct panfrost_gem_mapping *first;\n\n\t\tfirst = list_first_entry(&bo->mappings.list,\n\t\t\t\t\t struct panfrost_gem_mapping,\n\t\t\t\t\t node);\n\n\t\t \n\t\tif (!list_is_singular(&bo->mappings.list) ||\n\t\t    WARN_ON_ONCE(first->mmu != priv->mmu)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock_mappings;\n\t\t}\n\t}\n\n\targs->retained = drm_gem_shmem_madvise(&bo->base, args->madv);\n\n\tif (args->retained) {\n\t\tif (args->madv == PANFROST_MADV_DONTNEED)\n\t\t\tlist_move_tail(&bo->base.madv_list,\n\t\t\t\t       &pfdev->shrinker_list);\n\t\telse if (args->madv == PANFROST_MADV_WILLNEED)\n\t\t\tlist_del_init(&bo->base.madv_list);\n\t}\n\nout_unlock_mappings:\n\tmutex_unlock(&bo->mappings.lock);\n\tmutex_unlock(&pfdev->shrinker_lock);\n\tdma_resv_unlock(bo->base.base.resv);\nout_put_object:\n\tdrm_gem_object_put(gem_obj);\n\treturn ret;\n}\n\nint panfrost_unstable_ioctl_check(void)\n{\n\tif (!unstable_ioctls)\n\t\treturn -ENOSYS;\n\n\treturn 0;\n}\n\nstatic int\npanfrost_open(struct drm_device *dev, struct drm_file *file)\n{\n\tint ret;\n\tstruct panfrost_device *pfdev = dev->dev_private;\n\tstruct panfrost_file_priv *panfrost_priv;\n\n\tpanfrost_priv = kzalloc(sizeof(*panfrost_priv), GFP_KERNEL);\n\tif (!panfrost_priv)\n\t\treturn -ENOMEM;\n\n\tpanfrost_priv->pfdev = pfdev;\n\tfile->driver_priv = panfrost_priv;\n\n\tpanfrost_priv->mmu = panfrost_mmu_ctx_create(pfdev);\n\tif (IS_ERR(panfrost_priv->mmu)) {\n\t\tret = PTR_ERR(panfrost_priv->mmu);\n\t\tgoto err_free;\n\t}\n\n\tret = panfrost_job_open(panfrost_priv);\n\tif (ret)\n\t\tgoto err_job;\n\n\treturn 0;\n\nerr_job:\n\tpanfrost_mmu_ctx_put(panfrost_priv->mmu);\nerr_free:\n\tkfree(panfrost_priv);\n\treturn ret;\n}\n\nstatic void\npanfrost_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct panfrost_file_priv *panfrost_priv = file->driver_priv;\n\n\tpanfrost_perfcnt_close(file);\n\tpanfrost_job_close(panfrost_priv);\n\n\tpanfrost_mmu_ctx_put(panfrost_priv->mmu);\n\tkfree(panfrost_priv);\n}\n\nstatic const struct drm_ioctl_desc panfrost_drm_driver_ioctls[] = {\n#define PANFROST_IOCTL(n, func, flags) \\\n\tDRM_IOCTL_DEF_DRV(PANFROST_##n, panfrost_ioctl_##func, flags)\n\n\tPANFROST_IOCTL(SUBMIT,\t\tsubmit,\t\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(WAIT_BO,\t\twait_bo,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(CREATE_BO,\tcreate_bo,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(MMAP_BO,\t\tmmap_bo,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(GET_PARAM,\tget_param,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(GET_BO_OFFSET,\tget_bo_offset,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(PERFCNT_ENABLE,\tperfcnt_enable,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(PERFCNT_DUMP,\tperfcnt_dump,\tDRM_RENDER_ALLOW),\n\tPANFROST_IOCTL(MADVISE,\t\tmadvise,\tDRM_RENDER_ALLOW),\n};\n\nDEFINE_DRM_GEM_FOPS(panfrost_drm_driver_fops);\n\n \nstatic const struct drm_driver panfrost_drm_driver = {\n\t.driver_features\t= DRIVER_RENDER | DRIVER_GEM | DRIVER_SYNCOBJ,\n\t.open\t\t\t= panfrost_open,\n\t.postclose\t\t= panfrost_postclose,\n\t.ioctls\t\t\t= panfrost_drm_driver_ioctls,\n\t.num_ioctls\t\t= ARRAY_SIZE(panfrost_drm_driver_ioctls),\n\t.fops\t\t\t= &panfrost_drm_driver_fops,\n\t.name\t\t\t= \"panfrost\",\n\t.desc\t\t\t= \"panfrost DRM\",\n\t.date\t\t\t= \"20180908\",\n\t.major\t\t\t= 1,\n\t.minor\t\t\t= 2,\n\n\t.gem_create_object\t= panfrost_gem_create_object,\n\t.gem_prime_import_sg_table = panfrost_gem_prime_import_sg_table,\n};\n\nstatic int panfrost_probe(struct platform_device *pdev)\n{\n\tstruct panfrost_device *pfdev;\n\tstruct drm_device *ddev;\n\tint err;\n\n\tpfdev = devm_kzalloc(&pdev->dev, sizeof(*pfdev), GFP_KERNEL);\n\tif (!pfdev)\n\t\treturn -ENOMEM;\n\n\tpfdev->pdev = pdev;\n\tpfdev->dev = &pdev->dev;\n\n\tplatform_set_drvdata(pdev, pfdev);\n\n\tpfdev->comp = of_device_get_match_data(&pdev->dev);\n\tif (!pfdev->comp)\n\t\treturn -ENODEV;\n\n\tpfdev->coherent = device_get_dma_attr(&pdev->dev) == DEV_DMA_COHERENT;\n\n\t \n\tddev = drm_dev_alloc(&panfrost_drm_driver, &pdev->dev);\n\tif (IS_ERR(ddev))\n\t\treturn PTR_ERR(ddev);\n\n\tddev->dev_private = pfdev;\n\tpfdev->ddev = ddev;\n\n\tmutex_init(&pfdev->shrinker_lock);\n\tINIT_LIST_HEAD(&pfdev->shrinker_list);\n\n\terr = panfrost_device_init(pfdev);\n\tif (err) {\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Fatal error during GPU init\\n\");\n\t\tgoto err_out0;\n\t}\n\n\tpm_runtime_set_active(pfdev->dev);\n\tpm_runtime_mark_last_busy(pfdev->dev);\n\tpm_runtime_enable(pfdev->dev);\n\tpm_runtime_set_autosuspend_delay(pfdev->dev, 50);  \n\tpm_runtime_use_autosuspend(pfdev->dev);\n\n\t \n\terr = drm_dev_register(ddev, 0);\n\tif (err < 0)\n\t\tgoto err_out1;\n\n\tpanfrost_gem_shrinker_init(ddev);\n\n\treturn 0;\n\nerr_out1:\n\tpm_runtime_disable(pfdev->dev);\n\tpanfrost_device_fini(pfdev);\n\tpm_runtime_set_suspended(pfdev->dev);\nerr_out0:\n\tdrm_dev_put(ddev);\n\treturn err;\n}\n\nstatic void panfrost_remove(struct platform_device *pdev)\n{\n\tstruct panfrost_device *pfdev = platform_get_drvdata(pdev);\n\tstruct drm_device *ddev = pfdev->ddev;\n\n\tdrm_dev_unregister(ddev);\n\tpanfrost_gem_shrinker_cleanup(ddev);\n\n\tpm_runtime_get_sync(pfdev->dev);\n\tpm_runtime_disable(pfdev->dev);\n\tpanfrost_device_fini(pfdev);\n\tpm_runtime_set_suspended(pfdev->dev);\n\n\tdrm_dev_put(ddev);\n}\n\n \nstatic const char * const default_supplies[] = { \"mali\", NULL };\nstatic const struct panfrost_compatible default_data = {\n\t.num_supplies = ARRAY_SIZE(default_supplies) - 1,\n\t.supply_names = default_supplies,\n\t.num_pm_domains = 1,  \n\t.pm_domain_names = NULL,\n};\n\nstatic const struct panfrost_compatible amlogic_data = {\n\t.num_supplies = ARRAY_SIZE(default_supplies) - 1,\n\t.supply_names = default_supplies,\n\t.vendor_quirk = panfrost_gpu_amlogic_quirk,\n};\n\n \nstatic const char * const mediatek_mt8183_supplies[] = { \"mali\", \"sram\", NULL };\nstatic const char * const mediatek_mt8183_pm_domains[] = { \"core0\", \"core1\", \"core2\" };\nstatic const struct panfrost_compatible mediatek_mt8183_data = {\n\t.num_supplies = ARRAY_SIZE(mediatek_mt8183_supplies) - 1,\n\t.supply_names = mediatek_mt8183_supplies,\n\t.num_pm_domains = ARRAY_SIZE(mediatek_mt8183_pm_domains),\n\t.pm_domain_names = mediatek_mt8183_pm_domains,\n};\n\nstatic const char * const mediatek_mt8183_b_supplies[] = { \"mali\", NULL };\nstatic const struct panfrost_compatible mediatek_mt8183_b_data = {\n\t.num_supplies = ARRAY_SIZE(mediatek_mt8183_b_supplies) - 1,\n\t.supply_names = mediatek_mt8183_b_supplies,\n\t.num_pm_domains = ARRAY_SIZE(mediatek_mt8183_pm_domains),\n\t.pm_domain_names = mediatek_mt8183_pm_domains,\n};\n\nstatic const char * const mediatek_mt8186_pm_domains[] = { \"core0\", \"core1\" };\nstatic const struct panfrost_compatible mediatek_mt8186_data = {\n\t.num_supplies = ARRAY_SIZE(mediatek_mt8183_b_supplies) - 1,\n\t.supply_names = mediatek_mt8183_b_supplies,\n\t.num_pm_domains = ARRAY_SIZE(mediatek_mt8186_pm_domains),\n\t.pm_domain_names = mediatek_mt8186_pm_domains,\n};\n\nstatic const char * const mediatek_mt8192_supplies[] = { \"mali\", NULL };\nstatic const char * const mediatek_mt8192_pm_domains[] = { \"core0\", \"core1\", \"core2\",\n\t\t\t\t\t\t\t   \"core3\", \"core4\" };\nstatic const struct panfrost_compatible mediatek_mt8192_data = {\n\t.num_supplies = ARRAY_SIZE(mediatek_mt8192_supplies) - 1,\n\t.supply_names = mediatek_mt8192_supplies,\n\t.num_pm_domains = ARRAY_SIZE(mediatek_mt8192_pm_domains),\n\t.pm_domain_names = mediatek_mt8192_pm_domains,\n};\n\nstatic const struct of_device_id dt_match[] = {\n\t \n\t{ .compatible = \"amlogic,meson-gxm-mali\",\n\t  .data = &amlogic_data, },\n\t{ .compatible = \"amlogic,meson-g12a-mali\",\n\t  .data = &amlogic_data, },\n\t{ .compatible = \"arm,mali-t604\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t624\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t628\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t720\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t760\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t820\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t830\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t860\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-t880\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-bifrost\", .data = &default_data, },\n\t{ .compatible = \"arm,mali-valhall-jm\", .data = &default_data, },\n\t{ .compatible = \"mediatek,mt8183-mali\", .data = &mediatek_mt8183_data },\n\t{ .compatible = \"mediatek,mt8183b-mali\", .data = &mediatek_mt8183_b_data },\n\t{ .compatible = \"mediatek,mt8186-mali\", .data = &mediatek_mt8186_data },\n\t{ .compatible = \"mediatek,mt8192-mali\", .data = &mediatek_mt8192_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dt_match);\n\nstatic struct platform_driver panfrost_driver = {\n\t.probe\t\t= panfrost_probe,\n\t.remove_new\t= panfrost_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"panfrost\",\n\t\t.pm\t= pm_ptr(&panfrost_pm_ops),\n\t\t.of_match_table = dt_match,\n\t},\n};\nmodule_platform_driver(panfrost_driver);\n\nMODULE_AUTHOR(\"Panfrost Project Developers\");\nMODULE_DESCRIPTION(\"Panfrost DRM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}