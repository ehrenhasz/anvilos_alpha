{
  "module_name": "panfrost_perfcnt.c",
  "hash_id": "0c37b4875e3eaa6681beb66919a39c0ade3e1dd6e2e81e3762e46c9f883c3794",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_perfcnt.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/iopoll.h>\n#include <linux/iosys-map.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_file.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/panfrost_drm.h>\n\n#include \"panfrost_device.h\"\n#include \"panfrost_features.h\"\n#include \"panfrost_gem.h\"\n#include \"panfrost_issues.h\"\n#include \"panfrost_job.h\"\n#include \"panfrost_mmu.h\"\n#include \"panfrost_perfcnt.h\"\n#include \"panfrost_regs.h\"\n\n#define COUNTERS_PER_BLOCK\t\t64\n#define BYTES_PER_COUNTER\t\t4\n#define BLOCKS_PER_COREGROUP\t\t8\n#define V4_SHADERS_PER_COREGROUP\t4\n\nstruct panfrost_perfcnt {\n\tstruct panfrost_gem_mapping *mapping;\n\tsize_t bosize;\n\tvoid *buf;\n\tstruct panfrost_file_priv *user;\n\tstruct mutex lock;\n\tstruct completion dump_comp;\n};\n\nvoid panfrost_perfcnt_clean_cache_done(struct panfrost_device *pfdev)\n{\n\tcomplete(&pfdev->perfcnt->dump_comp);\n}\n\nvoid panfrost_perfcnt_sample_done(struct panfrost_device *pfdev)\n{\n\tgpu_write(pfdev, GPU_CMD, GPU_CMD_CLEAN_CACHES);\n}\n\nstatic int panfrost_perfcnt_dump_locked(struct panfrost_device *pfdev)\n{\n\tu64 gpuva;\n\tint ret;\n\n\treinit_completion(&pfdev->perfcnt->dump_comp);\n\tgpuva = pfdev->perfcnt->mapping->mmnode.start << PAGE_SHIFT;\n\tgpu_write(pfdev, GPU_PERFCNT_BASE_LO, lower_32_bits(gpuva));\n\tgpu_write(pfdev, GPU_PERFCNT_BASE_HI, upper_32_bits(gpuva));\n\tgpu_write(pfdev, GPU_INT_CLEAR,\n\t\t  GPU_IRQ_CLEAN_CACHES_COMPLETED |\n\t\t  GPU_IRQ_PERFCNT_SAMPLE_COMPLETED);\n\tgpu_write(pfdev, GPU_CMD, GPU_CMD_PERFCNT_SAMPLE);\n\tret = wait_for_completion_interruptible_timeout(&pfdev->perfcnt->dump_comp,\n\t\t\t\t\t\t\tmsecs_to_jiffies(1000));\n\tif (!ret)\n\t\tret = -ETIMEDOUT;\n\telse if (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int panfrost_perfcnt_enable_locked(struct panfrost_device *pfdev,\n\t\t\t\t\t  struct drm_file *file_priv,\n\t\t\t\t\t  unsigned int counterset)\n{\n\tstruct panfrost_file_priv *user = file_priv->driver_priv;\n\tstruct panfrost_perfcnt *perfcnt = pfdev->perfcnt;\n\tstruct iosys_map map;\n\tstruct drm_gem_shmem_object *bo;\n\tu32 cfg, as;\n\tint ret;\n\n\tif (user == perfcnt->user)\n\t\treturn 0;\n\telse if (perfcnt->user)\n\t\treturn -EBUSY;\n\n\tret = pm_runtime_get_sync(pfdev->dev);\n\tif (ret < 0)\n\t\tgoto err_put_pm;\n\n\tbo = drm_gem_shmem_create(pfdev->ddev, perfcnt->bosize);\n\tif (IS_ERR(bo)) {\n\t\tret = PTR_ERR(bo);\n\t\tgoto err_put_pm;\n\t}\n\n\t \n\tret = panfrost_gem_open(&bo->base, file_priv);\n\tif (ret)\n\t\tgoto err_put_bo;\n\n\tperfcnt->mapping = panfrost_gem_mapping_get(to_panfrost_bo(&bo->base),\n\t\t\t\t\t\t    user);\n\tif (!perfcnt->mapping) {\n\t\tret = -EINVAL;\n\t\tgoto err_close_bo;\n\t}\n\n\tret = drm_gem_vmap_unlocked(&bo->base, &map);\n\tif (ret)\n\t\tgoto err_put_mapping;\n\tperfcnt->buf = map.vaddr;\n\n\t \n\treinit_completion(&pfdev->perfcnt->dump_comp);\n\tgpu_write(pfdev, GPU_INT_CLEAR,\n\t\t  GPU_IRQ_CLEAN_CACHES_COMPLETED |\n\t\t  GPU_IRQ_PERFCNT_SAMPLE_COMPLETED);\n\tgpu_write(pfdev, GPU_CMD, GPU_CMD_PERFCNT_CLEAR);\n\tgpu_write(pfdev, GPU_CMD, GPU_CMD_CLEAN_INV_CACHES);\n\tret = wait_for_completion_timeout(&pfdev->perfcnt->dump_comp,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tif (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_vunmap;\n\t}\n\n\tperfcnt->user = user;\n\n\tas = panfrost_mmu_as_get(pfdev, perfcnt->mapping->mmu);\n\tcfg = GPU_PERFCNT_CFG_AS(as) |\n\t      GPU_PERFCNT_CFG_MODE(GPU_PERFCNT_CFG_MODE_MANUAL);\n\n\t \n\tif (panfrost_model_is_bifrost(pfdev))\n\t\tcfg |= GPU_PERFCNT_CFG_SETSEL(counterset);\n\n\tgpu_write(pfdev, GPU_PRFCNT_JM_EN, 0xffffffff);\n\tgpu_write(pfdev, GPU_PRFCNT_SHADER_EN, 0xffffffff);\n\tgpu_write(pfdev, GPU_PRFCNT_MMU_L2_EN, 0xffffffff);\n\n\t \n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_8186))\n\t\tgpu_write(pfdev, GPU_PRFCNT_TILER_EN, 0);\n\telse\n\t\tgpu_write(pfdev, GPU_PRFCNT_TILER_EN, 0xffffffff);\n\n\tgpu_write(pfdev, GPU_PERFCNT_CFG, cfg);\n\n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_8186))\n\t\tgpu_write(pfdev, GPU_PRFCNT_TILER_EN, 0xffffffff);\n\n\t \n\tdrm_gem_object_put(&bo->base);\n\n\treturn 0;\n\nerr_vunmap:\n\tdrm_gem_vunmap_unlocked(&bo->base, &map);\nerr_put_mapping:\n\tpanfrost_gem_mapping_put(perfcnt->mapping);\nerr_close_bo:\n\tpanfrost_gem_close(&bo->base, file_priv);\nerr_put_bo:\n\tdrm_gem_object_put(&bo->base);\nerr_put_pm:\n\tpm_runtime_put(pfdev->dev);\n\treturn ret;\n}\n\nstatic int panfrost_perfcnt_disable_locked(struct panfrost_device *pfdev,\n\t\t\t\t\t   struct drm_file *file_priv)\n{\n\tstruct panfrost_file_priv *user = file_priv->driver_priv;\n\tstruct panfrost_perfcnt *perfcnt = pfdev->perfcnt;\n\tstruct iosys_map map = IOSYS_MAP_INIT_VADDR(perfcnt->buf);\n\n\tif (user != perfcnt->user)\n\t\treturn -EINVAL;\n\n\tgpu_write(pfdev, GPU_PRFCNT_JM_EN, 0x0);\n\tgpu_write(pfdev, GPU_PRFCNT_SHADER_EN, 0x0);\n\tgpu_write(pfdev, GPU_PRFCNT_MMU_L2_EN, 0x0);\n\tgpu_write(pfdev, GPU_PRFCNT_TILER_EN, 0);\n\tgpu_write(pfdev, GPU_PERFCNT_CFG,\n\t\t  GPU_PERFCNT_CFG_MODE(GPU_PERFCNT_CFG_MODE_OFF));\n\n\tperfcnt->user = NULL;\n\tdrm_gem_vunmap_unlocked(&perfcnt->mapping->obj->base.base, &map);\n\tperfcnt->buf = NULL;\n\tpanfrost_gem_close(&perfcnt->mapping->obj->base.base, file_priv);\n\tpanfrost_mmu_as_put(pfdev, perfcnt->mapping->mmu);\n\tpanfrost_gem_mapping_put(perfcnt->mapping);\n\tperfcnt->mapping = NULL;\n\tpm_runtime_mark_last_busy(pfdev->dev);\n\tpm_runtime_put_autosuspend(pfdev->dev);\n\n\treturn 0;\n}\n\nint panfrost_ioctl_perfcnt_enable(struct drm_device *dev, void *data,\n\t\t\t\t  struct drm_file *file_priv)\n{\n\tstruct panfrost_device *pfdev = dev->dev_private;\n\tstruct panfrost_perfcnt *perfcnt = pfdev->perfcnt;\n\tstruct drm_panfrost_perfcnt_enable *req = data;\n\tint ret;\n\n\tret = panfrost_unstable_ioctl_check();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (req->counterset > (panfrost_model_is_bifrost(pfdev) ? 1 : 0))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&perfcnt->lock);\n\tif (req->enable)\n\t\tret = panfrost_perfcnt_enable_locked(pfdev, file_priv,\n\t\t\t\t\t\t     req->counterset);\n\telse\n\t\tret = panfrost_perfcnt_disable_locked(pfdev, file_priv);\n\tmutex_unlock(&perfcnt->lock);\n\n\treturn ret;\n}\n\nint panfrost_ioctl_perfcnt_dump(struct drm_device *dev, void *data,\n\t\t\t\tstruct drm_file *file_priv)\n{\n\tstruct panfrost_device *pfdev = dev->dev_private;\n\tstruct panfrost_perfcnt *perfcnt = pfdev->perfcnt;\n\tstruct drm_panfrost_perfcnt_dump *req = data;\n\tvoid __user *user_ptr = (void __user *)(uintptr_t)req->buf_ptr;\n\tint ret;\n\n\tret = panfrost_unstable_ioctl_check();\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&perfcnt->lock);\n\tif (perfcnt->user != file_priv->driver_priv) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = panfrost_perfcnt_dump_locked(pfdev);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(user_ptr, perfcnt->buf, perfcnt->bosize))\n\t\tret = -EFAULT;\n\nout:\n\tmutex_unlock(&perfcnt->lock);\n\n\treturn ret;\n}\n\nvoid panfrost_perfcnt_close(struct drm_file *file_priv)\n{\n\tstruct panfrost_file_priv *pfile = file_priv->driver_priv;\n\tstruct panfrost_device *pfdev = pfile->pfdev;\n\tstruct panfrost_perfcnt *perfcnt = pfdev->perfcnt;\n\n\tpm_runtime_get_sync(pfdev->dev);\n\tmutex_lock(&perfcnt->lock);\n\tif (perfcnt->user == pfile)\n\t\tpanfrost_perfcnt_disable_locked(pfdev, file_priv);\n\tmutex_unlock(&perfcnt->lock);\n\tpm_runtime_mark_last_busy(pfdev->dev);\n\tpm_runtime_put_autosuspend(pfdev->dev);\n}\n\nint panfrost_perfcnt_init(struct panfrost_device *pfdev)\n{\n\tstruct panfrost_perfcnt *perfcnt;\n\tsize_t size;\n\n\tif (panfrost_has_hw_feature(pfdev, HW_FEATURE_V4)) {\n\t\tunsigned int ncoregroups;\n\n\t\tncoregroups = hweight64(pfdev->features.l2_present);\n\t\tsize = ncoregroups * BLOCKS_PER_COREGROUP *\n\t\t       COUNTERS_PER_BLOCK * BYTES_PER_COUNTER;\n\t} else {\n\t\tunsigned int nl2c, ncores;\n\n\t\t \n\t\tnl2c = ((pfdev->features.mem_features >> 8) & GENMASK(3, 0)) + 1;\n\n\t\t \n\t\tncores = fls64(pfdev->features.shader_present);\n\n\t\t \n\t\tsize = (nl2c + ncores + 2) *\n\t\t       COUNTERS_PER_BLOCK * BYTES_PER_COUNTER;\n\t}\n\n\tperfcnt = devm_kzalloc(pfdev->dev, sizeof(*perfcnt), GFP_KERNEL);\n\tif (!perfcnt)\n\t\treturn -ENOMEM;\n\n\tperfcnt->bosize = size;\n\n\t \n\tgpu_write(pfdev, GPU_PERFCNT_CFG,\n\t\t  GPU_PERFCNT_CFG_MODE(GPU_PERFCNT_CFG_MODE_OFF));\n\tgpu_write(pfdev, GPU_PRFCNT_JM_EN, 0);\n\tgpu_write(pfdev, GPU_PRFCNT_SHADER_EN, 0);\n\tgpu_write(pfdev, GPU_PRFCNT_MMU_L2_EN, 0);\n\tgpu_write(pfdev, GPU_PRFCNT_TILER_EN, 0);\n\n\tinit_completion(&perfcnt->dump_comp);\n\tmutex_init(&perfcnt->lock);\n\tpfdev->perfcnt = perfcnt;\n\n\treturn 0;\n}\n\nvoid panfrost_perfcnt_fini(struct panfrost_device *pfdev)\n{\n\t \n\tgpu_write(pfdev, GPU_PERFCNT_CFG,\n\t\t  GPU_PERFCNT_CFG_MODE(GPU_PERFCNT_CFG_MODE_OFF));\n\tgpu_write(pfdev, GPU_PRFCNT_JM_EN, 0);\n\tgpu_write(pfdev, GPU_PRFCNT_SHADER_EN, 0);\n\tgpu_write(pfdev, GPU_PRFCNT_MMU_L2_EN, 0);\n\tgpu_write(pfdev, GPU_PRFCNT_TILER_EN, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}