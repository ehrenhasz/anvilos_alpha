{
  "module_name": "panfrost_gem.c",
  "hash_id": "25d5041eaaf54358f8d48719860a8724275fcfef01d493a5e03209c665a69c6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_gem.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/dma-buf.h>\n#include <linux/dma-mapping.h>\n\n#include <drm/panfrost_drm.h>\n#include \"panfrost_device.h\"\n#include \"panfrost_gem.h\"\n#include \"panfrost_mmu.h\"\n\n \nstatic void panfrost_gem_free_object(struct drm_gem_object *obj)\n{\n\tstruct panfrost_gem_object *bo = to_panfrost_bo(obj);\n\tstruct panfrost_device *pfdev = obj->dev->dev_private;\n\n\t \n\tmutex_lock(&pfdev->shrinker_lock);\n\tlist_del_init(&bo->base.madv_list);\n\tmutex_unlock(&pfdev->shrinker_lock);\n\n\t \n\tWARN_ON_ONCE(!list_empty(&bo->mappings.list));\n\n\tif (bo->sgts) {\n\t\tint i;\n\t\tint n_sgt = bo->base.base.size / SZ_2M;\n\n\t\tfor (i = 0; i < n_sgt; i++) {\n\t\t\tif (bo->sgts[i].sgl) {\n\t\t\t\tdma_unmap_sgtable(pfdev->dev, &bo->sgts[i],\n\t\t\t\t\t\t  DMA_BIDIRECTIONAL, 0);\n\t\t\t\tsg_free_table(&bo->sgts[i]);\n\t\t\t}\n\t\t}\n\t\tkvfree(bo->sgts);\n\t}\n\n\tdrm_gem_shmem_free(&bo->base);\n}\n\nstruct panfrost_gem_mapping *\npanfrost_gem_mapping_get(struct panfrost_gem_object *bo,\n\t\t\t struct panfrost_file_priv *priv)\n{\n\tstruct panfrost_gem_mapping *iter, *mapping = NULL;\n\n\tmutex_lock(&bo->mappings.lock);\n\tlist_for_each_entry(iter, &bo->mappings.list, node) {\n\t\tif (iter->mmu == priv->mmu) {\n\t\t\tkref_get(&iter->refcount);\n\t\t\tmapping = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&bo->mappings.lock);\n\n\treturn mapping;\n}\n\nstatic void\npanfrost_gem_teardown_mapping(struct panfrost_gem_mapping *mapping)\n{\n\tif (mapping->active)\n\t\tpanfrost_mmu_unmap(mapping);\n\n\tspin_lock(&mapping->mmu->mm_lock);\n\tif (drm_mm_node_allocated(&mapping->mmnode))\n\t\tdrm_mm_remove_node(&mapping->mmnode);\n\tspin_unlock(&mapping->mmu->mm_lock);\n}\n\nstatic void panfrost_gem_mapping_release(struct kref *kref)\n{\n\tstruct panfrost_gem_mapping *mapping;\n\n\tmapping = container_of(kref, struct panfrost_gem_mapping, refcount);\n\n\tpanfrost_gem_teardown_mapping(mapping);\n\tdrm_gem_object_put(&mapping->obj->base.base);\n\tpanfrost_mmu_ctx_put(mapping->mmu);\n\tkfree(mapping);\n}\n\nvoid panfrost_gem_mapping_put(struct panfrost_gem_mapping *mapping)\n{\n\tif (!mapping)\n\t\treturn;\n\n\tkref_put(&mapping->refcount, panfrost_gem_mapping_release);\n}\n\nvoid panfrost_gem_teardown_mappings_locked(struct panfrost_gem_object *bo)\n{\n\tstruct panfrost_gem_mapping *mapping;\n\n\tlist_for_each_entry(mapping, &bo->mappings.list, node)\n\t\tpanfrost_gem_teardown_mapping(mapping);\n}\n\nint panfrost_gem_open(struct drm_gem_object *obj, struct drm_file *file_priv)\n{\n\tint ret;\n\tsize_t size = obj->size;\n\tu64 align;\n\tstruct panfrost_gem_object *bo = to_panfrost_bo(obj);\n\tunsigned long color = bo->noexec ? PANFROST_BO_NOEXEC : 0;\n\tstruct panfrost_file_priv *priv = file_priv->driver_priv;\n\tstruct panfrost_gem_mapping *mapping;\n\n\tmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\n\tif (!mapping)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&mapping->node);\n\tkref_init(&mapping->refcount);\n\tdrm_gem_object_get(obj);\n\tmapping->obj = bo;\n\n\t \n\tif (!bo->noexec)\n\t\talign = size >> PAGE_SHIFT;\n\telse\n\t\talign = size >= SZ_2M ? SZ_2M >> PAGE_SHIFT : 0;\n\n\tmapping->mmu = panfrost_mmu_ctx_get(priv->mmu);\n\tspin_lock(&mapping->mmu->mm_lock);\n\tret = drm_mm_insert_node_generic(&mapping->mmu->mm, &mapping->mmnode,\n\t\t\t\t\t size >> PAGE_SHIFT, align, color, 0);\n\tspin_unlock(&mapping->mmu->mm_lock);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!bo->is_heap) {\n\t\tret = panfrost_mmu_map(mapping);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tmutex_lock(&bo->mappings.lock);\n\tWARN_ON(bo->base.madv != PANFROST_MADV_WILLNEED);\n\tlist_add_tail(&mapping->node, &bo->mappings.list);\n\tmutex_unlock(&bo->mappings.lock);\n\nerr:\n\tif (ret)\n\t\tpanfrost_gem_mapping_put(mapping);\n\treturn ret;\n}\n\nvoid panfrost_gem_close(struct drm_gem_object *obj, struct drm_file *file_priv)\n{\n\tstruct panfrost_file_priv *priv = file_priv->driver_priv;\n\tstruct panfrost_gem_object *bo = to_panfrost_bo(obj);\n\tstruct panfrost_gem_mapping *mapping = NULL, *iter;\n\n\tmutex_lock(&bo->mappings.lock);\n\tlist_for_each_entry(iter, &bo->mappings.list, node) {\n\t\tif (iter->mmu == priv->mmu) {\n\t\t\tmapping = iter;\n\t\t\tlist_del(&iter->node);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&bo->mappings.lock);\n\n\tpanfrost_gem_mapping_put(mapping);\n}\n\nstatic int panfrost_gem_pin(struct drm_gem_object *obj)\n{\n\tstruct panfrost_gem_object *bo = to_panfrost_bo(obj);\n\n\tif (bo->is_heap)\n\t\treturn -EINVAL;\n\n\treturn drm_gem_shmem_pin(&bo->base);\n}\n\nstatic const struct drm_gem_object_funcs panfrost_gem_funcs = {\n\t.free = panfrost_gem_free_object,\n\t.open = panfrost_gem_open,\n\t.close = panfrost_gem_close,\n\t.print_info = drm_gem_shmem_object_print_info,\n\t.pin = panfrost_gem_pin,\n\t.unpin = drm_gem_shmem_object_unpin,\n\t.get_sg_table = drm_gem_shmem_object_get_sg_table,\n\t.vmap = drm_gem_shmem_object_vmap,\n\t.vunmap = drm_gem_shmem_object_vunmap,\n\t.mmap = drm_gem_shmem_object_mmap,\n\t.vm_ops = &drm_gem_shmem_vm_ops,\n};\n\n \nstruct drm_gem_object *panfrost_gem_create_object(struct drm_device *dev, size_t size)\n{\n\tstruct panfrost_device *pfdev = dev->dev_private;\n\tstruct panfrost_gem_object *obj;\n\n\tobj = kzalloc(sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&obj->mappings.list);\n\tmutex_init(&obj->mappings.lock);\n\tobj->base.base.funcs = &panfrost_gem_funcs;\n\tobj->base.map_wc = !pfdev->coherent;\n\n\treturn &obj->base.base;\n}\n\nstruct panfrost_gem_object *\npanfrost_gem_create(struct drm_device *dev, size_t size, u32 flags)\n{\n\tstruct drm_gem_shmem_object *shmem;\n\tstruct panfrost_gem_object *bo;\n\n\t \n\tif (flags & PANFROST_BO_HEAP)\n\t\tsize = roundup(size, SZ_2M);\n\n\tshmem = drm_gem_shmem_create(dev, size);\n\tif (IS_ERR(shmem))\n\t\treturn ERR_CAST(shmem);\n\n\tbo = to_panfrost_bo(&shmem->base);\n\tbo->noexec = !!(flags & PANFROST_BO_NOEXEC);\n\tbo->is_heap = !!(flags & PANFROST_BO_HEAP);\n\n\treturn bo;\n}\n\nstruct drm_gem_object *\npanfrost_gem_prime_import_sg_table(struct drm_device *dev,\n\t\t\t\t   struct dma_buf_attachment *attach,\n\t\t\t\t   struct sg_table *sgt)\n{\n\tstruct drm_gem_object *obj;\n\tstruct panfrost_gem_object *bo;\n\n\tobj = drm_gem_shmem_prime_import_sg_table(dev, attach, sgt);\n\tif (IS_ERR(obj))\n\t\treturn ERR_CAST(obj);\n\n\tbo = to_panfrost_bo(obj);\n\tbo->noexec = true;\n\n\treturn obj;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}