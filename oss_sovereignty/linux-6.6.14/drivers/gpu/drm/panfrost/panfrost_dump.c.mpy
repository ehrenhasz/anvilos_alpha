{
  "module_name": "panfrost_dump.c",
  "hash_id": "a540cf4b714b19281263f671878253412d5d895464a4b3e2471b21bcaac21b83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_dump.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/devcoredump.h>\n#include <linux/moduleparam.h>\n#include <linux/iosys-map.h>\n#include <drm/panfrost_drm.h>\n#include <drm/drm_device.h>\n\n#include \"panfrost_job.h\"\n#include \"panfrost_gem.h\"\n#include \"panfrost_regs.h\"\n#include \"panfrost_dump.h\"\n#include \"panfrost_device.h\"\n\nstatic bool panfrost_dump_core = true;\nmodule_param_named(dump_core, panfrost_dump_core, bool, 0600);\n\nstruct panfrost_dump_iterator {\n\tvoid *start;\n\tstruct panfrost_dump_object_header *hdr;\n\tvoid *data;\n};\n\nstatic const unsigned short panfrost_dump_registers[] = {\n\tSHADER_READY_LO,\n\tSHADER_READY_HI,\n\tTILER_READY_LO,\n\tTILER_READY_HI,\n\tL2_READY_LO,\n\tL2_READY_HI,\n\tJOB_INT_MASK,\n\tJOB_INT_STAT,\n\tJS_HEAD_LO(0),\n\tJS_HEAD_HI(0),\n\tJS_TAIL_LO(0),\n\tJS_TAIL_HI(0),\n\tJS_AFFINITY_LO(0),\n\tJS_AFFINITY_HI(0),\n\tJS_CONFIG(0),\n\tJS_STATUS(0),\n\tJS_HEAD_NEXT_LO(0),\n\tJS_HEAD_NEXT_HI(0),\n\tJS_AFFINITY_NEXT_LO(0),\n\tJS_AFFINITY_NEXT_HI(0),\n\tJS_CONFIG_NEXT(0),\n\tMMU_INT_MASK,\n\tMMU_INT_STAT,\n\tAS_TRANSTAB_LO(0),\n\tAS_TRANSTAB_HI(0),\n\tAS_MEMATTR_LO(0),\n\tAS_MEMATTR_HI(0),\n\tAS_FAULTSTATUS(0),\n\tAS_FAULTADDRESS_LO(0),\n\tAS_FAULTADDRESS_HI(0),\n\tAS_STATUS(0),\n};\n\nstatic void panfrost_core_dump_header(struct panfrost_dump_iterator *iter,\n\t\t\t\t      u32 type, void *data_end)\n{\n\tstruct panfrost_dump_object_header *hdr = iter->hdr;\n\n\thdr->magic = PANFROSTDUMP_MAGIC;\n\thdr->type = type;\n\thdr->file_offset = iter->data - iter->start;\n\thdr->file_size = data_end - iter->data;\n\n\titer->hdr++;\n\titer->data += hdr->file_size;\n}\n\nstatic void\npanfrost_core_dump_registers(struct panfrost_dump_iterator *iter,\n\t\t\t     struct panfrost_device *pfdev,\n\t\t\t     u32 as_nr, int slot)\n{\n\tstruct panfrost_dump_registers *dumpreg = iter->data;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(panfrost_dump_registers); i++, dumpreg++) {\n\t\tunsigned int js_as_offset = 0;\n\t\tunsigned int reg;\n\n\t\tif (panfrost_dump_registers[i] >= JS_BASE &&\n\t\t    panfrost_dump_registers[i] <= JS_BASE + JS_SLOT_STRIDE)\n\t\t\tjs_as_offset = slot * JS_SLOT_STRIDE;\n\t\telse if (panfrost_dump_registers[i] >= MMU_BASE &&\n\t\t\t panfrost_dump_registers[i] <= MMU_BASE + MMU_AS_STRIDE)\n\t\t\tjs_as_offset = (as_nr << MMU_AS_SHIFT);\n\n\t\treg = panfrost_dump_registers[i] + js_as_offset;\n\n\t\tdumpreg->reg = reg;\n\t\tdumpreg->value = gpu_read(pfdev, reg);\n\t}\n\n\tpanfrost_core_dump_header(iter, PANFROSTDUMP_BUF_REG, dumpreg);\n}\n\nvoid panfrost_core_dump(struct panfrost_job *job)\n{\n\tstruct panfrost_device *pfdev = job->pfdev;\n\tstruct panfrost_dump_iterator iter;\n\tstruct drm_gem_object *dbo;\n\tunsigned int n_obj, n_bomap_pages;\n\tu64 *bomap, *bomap_start;\n\tsize_t file_size;\n\tu32 as_nr;\n\tint slot;\n\tint ret, i;\n\n\tas_nr = job->mmu->as;\n\tslot = panfrost_job_get_slot(job);\n\n\t \n\tif (!panfrost_dump_core)\n\t\treturn;\n\tpanfrost_dump_core = false;\n\n\t \n\tn_obj = 2;\n\tn_bomap_pages = 0;\n\tfile_size = ARRAY_SIZE(panfrost_dump_registers) *\n\t\t\tsizeof(struct panfrost_dump_registers);\n\n\t \n\tfor (i = 0; i < job->bo_count; i++) {\n\t\t \n\t\tdbo = job->bos[i];\n\t\tWARN_ON(!IS_ALIGNED(dbo->size, PAGE_SIZE));\n\n\t\tfile_size += dbo->size;\n\t\tn_bomap_pages += dbo->size >> PAGE_SHIFT;\n\t\tn_obj++;\n\t}\n\n\t \n\tif (n_bomap_pages) {\n\t\tfile_size += n_bomap_pages * sizeof(*bomap);\n\t\tn_obj++;\n\t}\n\n\t \n\tfile_size += sizeof(*iter.hdr) * n_obj;\n\n\t \n\titer.start = __vmalloc(file_size, GFP_KERNEL | __GFP_NOWARN |\n\t\t\t__GFP_NORETRY);\n\tif (!iter.start) {\n\t\tdev_warn(pfdev->dev, \"failed to allocate devcoredump file\\n\");\n\t\treturn;\n\t}\n\n\t \n\titer.hdr = iter.start;\n\titer.data = &iter.hdr[n_obj];\n\n\tmemset(iter.hdr, 0, iter.data - iter.start);\n\n\t \n\titer.hdr->reghdr.jc = job->jc;\n\titer.hdr->reghdr.major = PANFROSTDUMP_MAJOR;\n\titer.hdr->reghdr.minor = PANFROSTDUMP_MINOR;\n\titer.hdr->reghdr.gpu_id = pfdev->features.id;\n\titer.hdr->reghdr.nbos = job->bo_count;\n\n\tpanfrost_core_dump_registers(&iter, pfdev, as_nr, slot);\n\n\t \n\tif (job->bo_count) {\n\t\tbomap_start = bomap = iter.data;\n\t\tmemset(bomap, 0, sizeof(*bomap) * n_bomap_pages);\n\t\tpanfrost_core_dump_header(&iter, PANFROSTDUMP_BUF_BOMAP,\n\t\t\t\t\t  bomap + n_bomap_pages);\n\t}\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tstruct iosys_map map;\n\t\tstruct panfrost_gem_mapping *mapping;\n\t\tstruct panfrost_gem_object *bo;\n\t\tstruct sg_page_iter page_iter;\n\t\tvoid *vaddr;\n\n\t\tbo = to_panfrost_bo(job->bos[i]);\n\t\tmapping = job->mappings[i];\n\n\t\tif (!bo->base.sgt) {\n\t\t\tdev_err(pfdev->dev, \"Panfrost Dump: BO has no sgt, cannot dump\\n\");\n\t\t\titer.hdr->bomap.valid = 0;\n\t\t\tgoto dump_header;\n\t\t}\n\n\t\tret = drm_gem_vmap_unlocked(&bo->base.base, &map);\n\t\tif (ret) {\n\t\t\tdev_err(pfdev->dev, \"Panfrost Dump: couldn't map Buffer Object\\n\");\n\t\t\titer.hdr->bomap.valid = 0;\n\t\t\tgoto dump_header;\n\t\t}\n\n\t\tWARN_ON(!mapping->active);\n\n\t\titer.hdr->bomap.data[0] = bomap - bomap_start;\n\n\t\tfor_each_sgtable_page(bo->base.sgt, &page_iter, 0) {\n\t\t\tstruct page *page = sg_page_iter_page(&page_iter);\n\n\t\t\tif (!IS_ERR(page)) {\n\t\t\t\t*bomap++ = page_to_phys(page);\n\t\t\t} else {\n\t\t\t\tdev_err(pfdev->dev, \"Panfrost Dump: wrong page\\n\");\n\t\t\t\t*bomap++ = 0;\n\t\t\t}\n\t\t}\n\n\t\titer.hdr->bomap.iova = mapping->mmnode.start << PAGE_SHIFT;\n\n\t\tvaddr = map.vaddr;\n\t\tmemcpy(iter.data, vaddr, bo->base.base.size);\n\n\t\tdrm_gem_vunmap_unlocked(&bo->base.base, &map);\n\n\t\titer.hdr->bomap.valid = 1;\n\ndump_header:\tpanfrost_core_dump_header(&iter, PANFROSTDUMP_BUF_BO, iter.data +\n\t\t\t\t\t  bo->base.base.size);\n\t}\n\tpanfrost_core_dump_header(&iter, PANFROSTDUMP_BUF_TRAILER, iter.data);\n\n\tdev_coredumpv(pfdev->dev, iter.start, iter.data - iter.start, GFP_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}