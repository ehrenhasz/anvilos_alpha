{
  "module_name": "panfrost_mmu.c",
  "hash_id": "b2dae77cae21b2cb0a1ce8f063674e49ac69cbbfb51a45c3265207b17d57383d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_mmu.c",
  "human_readable_source": "\n \n\n#include <drm/panfrost_drm.h>\n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/io-pgtable.h>\n#include <linux/iommu.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/shmem_fs.h>\n#include <linux/sizes.h>\n\n#include \"panfrost_device.h\"\n#include \"panfrost_mmu.h\"\n#include \"panfrost_gem.h\"\n#include \"panfrost_features.h\"\n#include \"panfrost_regs.h\"\n\n#define mmu_write(dev, reg, data) writel(data, dev->iomem + reg)\n#define mmu_read(dev, reg) readl(dev->iomem + reg)\n\nstatic int wait_ready(struct panfrost_device *pfdev, u32 as_nr)\n{\n\tint ret;\n\tu32 val;\n\n\t \n\tret = readl_relaxed_poll_timeout_atomic(pfdev->iomem + AS_STATUS(as_nr),\n\t\tval, !(val & AS_STATUS_AS_ACTIVE), 10, 100000);\n\n\tif (ret) {\n\t\t \n\t\tpanfrost_device_schedule_reset(pfdev);\n\t\tdev_err(pfdev->dev, \"AS_ACTIVE bit stuck\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int write_cmd(struct panfrost_device *pfdev, u32 as_nr, u32 cmd)\n{\n\tint status;\n\n\t \n\tstatus = wait_ready(pfdev, as_nr);\n\tif (!status)\n\t\tmmu_write(pfdev, AS_COMMAND(as_nr), cmd);\n\n\treturn status;\n}\n\nstatic void lock_region(struct panfrost_device *pfdev, u32 as_nr,\n\t\t\tu64 region_start, u64 size)\n{\n\tu8 region_width;\n\tu64 region;\n\tu64 region_end = region_start + size;\n\n\tif (!size)\n\t\treturn;\n\n\t \n\tregion_width = max(fls64(region_start ^ (region_end - 1)),\n\t\t\t   const_ilog2(AS_LOCK_REGION_MIN_SIZE)) - 1;\n\n\t \n\tregion_start &= GENMASK_ULL(63, region_width);\n\n\tregion = region_width | region_start;\n\n\t \n\tmmu_write(pfdev, AS_LOCKADDR_LO(as_nr), lower_32_bits(region));\n\tmmu_write(pfdev, AS_LOCKADDR_HI(as_nr), upper_32_bits(region));\n\twrite_cmd(pfdev, as_nr, AS_COMMAND_LOCK);\n}\n\n\nstatic int mmu_hw_do_operation_locked(struct panfrost_device *pfdev, int as_nr,\n\t\t\t\t      u64 iova, u64 size, u32 op)\n{\n\tif (as_nr < 0)\n\t\treturn 0;\n\n\tif (op != AS_COMMAND_UNLOCK)\n\t\tlock_region(pfdev, as_nr, iova, size);\n\n\t \n\twrite_cmd(pfdev, as_nr, op);\n\n\t \n\treturn wait_ready(pfdev, as_nr);\n}\n\nstatic int mmu_hw_do_operation(struct panfrost_device *pfdev,\n\t\t\t       struct panfrost_mmu *mmu,\n\t\t\t       u64 iova, u64 size, u32 op)\n{\n\tint ret;\n\n\tspin_lock(&pfdev->as_lock);\n\tret = mmu_hw_do_operation_locked(pfdev, mmu->as, iova, size, op);\n\tspin_unlock(&pfdev->as_lock);\n\treturn ret;\n}\n\nstatic void panfrost_mmu_enable(struct panfrost_device *pfdev, struct panfrost_mmu *mmu)\n{\n\tint as_nr = mmu->as;\n\tstruct io_pgtable_cfg *cfg = &mmu->pgtbl_cfg;\n\tu64 transtab = cfg->arm_mali_lpae_cfg.transtab;\n\tu64 memattr = cfg->arm_mali_lpae_cfg.memattr;\n\n\tmmu_hw_do_operation_locked(pfdev, as_nr, 0, ~0ULL, AS_COMMAND_FLUSH_MEM);\n\n\tmmu_write(pfdev, AS_TRANSTAB_LO(as_nr), lower_32_bits(transtab));\n\tmmu_write(pfdev, AS_TRANSTAB_HI(as_nr), upper_32_bits(transtab));\n\n\t \n\tmmu_write(pfdev, AS_MEMATTR_LO(as_nr), lower_32_bits(memattr));\n\tmmu_write(pfdev, AS_MEMATTR_HI(as_nr), upper_32_bits(memattr));\n\n\twrite_cmd(pfdev, as_nr, AS_COMMAND_UPDATE);\n}\n\nstatic void panfrost_mmu_disable(struct panfrost_device *pfdev, u32 as_nr)\n{\n\tmmu_hw_do_operation_locked(pfdev, as_nr, 0, ~0ULL, AS_COMMAND_FLUSH_MEM);\n\n\tmmu_write(pfdev, AS_TRANSTAB_LO(as_nr), 0);\n\tmmu_write(pfdev, AS_TRANSTAB_HI(as_nr), 0);\n\n\tmmu_write(pfdev, AS_MEMATTR_LO(as_nr), 0);\n\tmmu_write(pfdev, AS_MEMATTR_HI(as_nr), 0);\n\n\twrite_cmd(pfdev, as_nr, AS_COMMAND_UPDATE);\n}\n\nu32 panfrost_mmu_as_get(struct panfrost_device *pfdev, struct panfrost_mmu *mmu)\n{\n\tint as;\n\n\tspin_lock(&pfdev->as_lock);\n\n\tas = mmu->as;\n\tif (as >= 0) {\n\t\tint en = atomic_inc_return(&mmu->as_count);\n\t\tu32 mask = BIT(as) | BIT(16 + as);\n\n\t\t \n\t\tWARN_ON(en >= (NUM_JOB_SLOTS + 1));\n\n\t\tlist_move(&mmu->list, &pfdev->as_lru_list);\n\n\t\tif (pfdev->as_faulty_mask & mask) {\n\t\t\t \n\t\t\tmmu_write(pfdev, MMU_INT_CLEAR, mask);\n\t\t\tmmu_write(pfdev, MMU_INT_MASK, ~pfdev->as_faulty_mask);\n\t\t\tpfdev->as_faulty_mask &= ~mask;\n\t\t\tpanfrost_mmu_enable(pfdev, mmu);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\t \n\tas = ffz(pfdev->as_alloc_mask);\n\tif (!(BIT(as) & pfdev->features.as_present)) {\n\t\tstruct panfrost_mmu *lru_mmu;\n\n\t\tlist_for_each_entry_reverse(lru_mmu, &pfdev->as_lru_list, list) {\n\t\t\tif (!atomic_read(&lru_mmu->as_count))\n\t\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(&lru_mmu->list == &pfdev->as_lru_list);\n\n\t\tlist_del_init(&lru_mmu->list);\n\t\tas = lru_mmu->as;\n\n\t\tWARN_ON(as < 0);\n\t\tlru_mmu->as = -1;\n\t}\n\n\t \n\tmmu->as = as;\n\tset_bit(as, &pfdev->as_alloc_mask);\n\tatomic_set(&mmu->as_count, 1);\n\tlist_add(&mmu->list, &pfdev->as_lru_list);\n\n\tdev_dbg(pfdev->dev, \"Assigned AS%d to mmu %p, alloc_mask=%lx\", as, mmu, pfdev->as_alloc_mask);\n\n\tpanfrost_mmu_enable(pfdev, mmu);\n\nout:\n\tspin_unlock(&pfdev->as_lock);\n\treturn as;\n}\n\nvoid panfrost_mmu_as_put(struct panfrost_device *pfdev, struct panfrost_mmu *mmu)\n{\n\tatomic_dec(&mmu->as_count);\n\tWARN_ON(atomic_read(&mmu->as_count) < 0);\n}\n\nvoid panfrost_mmu_reset(struct panfrost_device *pfdev)\n{\n\tstruct panfrost_mmu *mmu, *mmu_tmp;\n\n\tspin_lock(&pfdev->as_lock);\n\n\tpfdev->as_alloc_mask = 0;\n\tpfdev->as_faulty_mask = 0;\n\n\tlist_for_each_entry_safe(mmu, mmu_tmp, &pfdev->as_lru_list, list) {\n\t\tmmu->as = -1;\n\t\tatomic_set(&mmu->as_count, 0);\n\t\tlist_del_init(&mmu->list);\n\t}\n\n\tspin_unlock(&pfdev->as_lock);\n\n\tmmu_write(pfdev, MMU_INT_CLEAR, ~0);\n\tmmu_write(pfdev, MMU_INT_MASK, ~0);\n}\n\nstatic size_t get_pgsize(u64 addr, size_t size, size_t *count)\n{\n\t \n\tsize_t blk_offset = -addr % SZ_2M;\n\n\tif (blk_offset || size < SZ_2M) {\n\t\t*count = min_not_zero(blk_offset, size) / SZ_4K;\n\t\treturn SZ_4K;\n\t}\n\tblk_offset = -addr % SZ_1G ?: SZ_1G;\n\t*count = min(blk_offset, size) / SZ_2M;\n\treturn SZ_2M;\n}\n\nstatic void panfrost_mmu_flush_range(struct panfrost_device *pfdev,\n\t\t\t\t     struct panfrost_mmu *mmu,\n\t\t\t\t     u64 iova, u64 size)\n{\n\tif (mmu->as < 0)\n\t\treturn;\n\n\tpm_runtime_get_noresume(pfdev->dev);\n\n\t \n\tif (pm_runtime_active(pfdev->dev))\n\t\tmmu_hw_do_operation(pfdev, mmu, iova, size, AS_COMMAND_FLUSH_PT);\n\n\tpm_runtime_put_autosuspend(pfdev->dev);\n}\n\nstatic int mmu_map_sg(struct panfrost_device *pfdev, struct panfrost_mmu *mmu,\n\t\t      u64 iova, int prot, struct sg_table *sgt)\n{\n\tunsigned int count;\n\tstruct scatterlist *sgl;\n\tstruct io_pgtable_ops *ops = mmu->pgtbl_ops;\n\tu64 start_iova = iova;\n\n\tfor_each_sgtable_dma_sg(sgt, sgl, count) {\n\t\tunsigned long paddr = sg_dma_address(sgl);\n\t\tsize_t len = sg_dma_len(sgl);\n\n\t\tdev_dbg(pfdev->dev, \"map: as=%d, iova=%llx, paddr=%lx, len=%zx\", mmu->as, iova, paddr, len);\n\n\t\twhile (len) {\n\t\t\tsize_t pgcount, mapped = 0;\n\t\t\tsize_t pgsize = get_pgsize(iova | paddr, len, &pgcount);\n\n\t\t\tops->map_pages(ops, iova, paddr, pgsize, pgcount, prot,\n\t\t\t\t       GFP_KERNEL, &mapped);\n\t\t\t \n\t\t\tmapped = max(mapped, pgsize);\n\t\t\tiova += mapped;\n\t\t\tpaddr += mapped;\n\t\t\tlen -= mapped;\n\t\t}\n\t}\n\n\tpanfrost_mmu_flush_range(pfdev, mmu, start_iova, iova - start_iova);\n\n\treturn 0;\n}\n\nint panfrost_mmu_map(struct panfrost_gem_mapping *mapping)\n{\n\tstruct panfrost_gem_object *bo = mapping->obj;\n\tstruct drm_gem_shmem_object *shmem = &bo->base;\n\tstruct drm_gem_object *obj = &shmem->base;\n\tstruct panfrost_device *pfdev = to_panfrost_device(obj->dev);\n\tstruct sg_table *sgt;\n\tint prot = IOMMU_READ | IOMMU_WRITE;\n\n\tif (WARN_ON(mapping->active))\n\t\treturn 0;\n\n\tif (bo->noexec)\n\t\tprot |= IOMMU_NOEXEC;\n\n\tsgt = drm_gem_shmem_get_pages_sgt(shmem);\n\tif (WARN_ON(IS_ERR(sgt)))\n\t\treturn PTR_ERR(sgt);\n\n\tmmu_map_sg(pfdev, mapping->mmu, mapping->mmnode.start << PAGE_SHIFT,\n\t\t   prot, sgt);\n\tmapping->active = true;\n\n\treturn 0;\n}\n\nvoid panfrost_mmu_unmap(struct panfrost_gem_mapping *mapping)\n{\n\tstruct panfrost_gem_object *bo = mapping->obj;\n\tstruct drm_gem_object *obj = &bo->base.base;\n\tstruct panfrost_device *pfdev = to_panfrost_device(obj->dev);\n\tstruct io_pgtable_ops *ops = mapping->mmu->pgtbl_ops;\n\tu64 iova = mapping->mmnode.start << PAGE_SHIFT;\n\tsize_t len = mapping->mmnode.size << PAGE_SHIFT;\n\tsize_t unmapped_len = 0;\n\n\tif (WARN_ON(!mapping->active))\n\t\treturn;\n\n\tdev_dbg(pfdev->dev, \"unmap: as=%d, iova=%llx, len=%zx\",\n\t\tmapping->mmu->as, iova, len);\n\n\twhile (unmapped_len < len) {\n\t\tsize_t unmapped_page, pgcount;\n\t\tsize_t pgsize = get_pgsize(iova, len - unmapped_len, &pgcount);\n\n\t\tif (bo->is_heap)\n\t\t\tpgcount = 1;\n\t\tif (!bo->is_heap || ops->iova_to_phys(ops, iova)) {\n\t\t\tunmapped_page = ops->unmap_pages(ops, iova, pgsize, pgcount, NULL);\n\t\t\tWARN_ON(unmapped_page != pgsize * pgcount);\n\t\t}\n\t\tiova += pgsize * pgcount;\n\t\tunmapped_len += pgsize * pgcount;\n\t}\n\n\tpanfrost_mmu_flush_range(pfdev, mapping->mmu,\n\t\t\t\t mapping->mmnode.start << PAGE_SHIFT, len);\n\tmapping->active = false;\n}\n\nstatic void mmu_tlb_inv_context_s1(void *cookie)\n{}\n\nstatic void mmu_tlb_sync_context(void *cookie)\n{\n\t\n\t\n}\n\nstatic void mmu_tlb_flush_walk(unsigned long iova, size_t size, size_t granule,\n\t\t\t       void *cookie)\n{\n\tmmu_tlb_sync_context(cookie);\n}\n\nstatic const struct iommu_flush_ops mmu_tlb_ops = {\n\t.tlb_flush_all\t= mmu_tlb_inv_context_s1,\n\t.tlb_flush_walk = mmu_tlb_flush_walk,\n};\n\nstatic struct panfrost_gem_mapping *\naddr_to_mapping(struct panfrost_device *pfdev, int as, u64 addr)\n{\n\tstruct panfrost_gem_mapping *mapping = NULL;\n\tstruct drm_mm_node *node;\n\tu64 offset = addr >> PAGE_SHIFT;\n\tstruct panfrost_mmu *mmu;\n\n\tspin_lock(&pfdev->as_lock);\n\tlist_for_each_entry(mmu, &pfdev->as_lru_list, list) {\n\t\tif (as == mmu->as)\n\t\t\tgoto found_mmu;\n\t}\n\tgoto out;\n\nfound_mmu:\n\n\tspin_lock(&mmu->mm_lock);\n\n\tdrm_mm_for_each_node(node, &mmu->mm) {\n\t\tif (offset >= node->start &&\n\t\t    offset < (node->start + node->size)) {\n\t\t\tmapping = drm_mm_node_to_panfrost_mapping(node);\n\n\t\t\tkref_get(&mapping->refcount);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&mmu->mm_lock);\nout:\n\tspin_unlock(&pfdev->as_lock);\n\treturn mapping;\n}\n\n#define NUM_FAULT_PAGES (SZ_2M / PAGE_SIZE)\n\nstatic int panfrost_mmu_map_fault_addr(struct panfrost_device *pfdev, int as,\n\t\t\t\t       u64 addr)\n{\n\tint ret, i;\n\tstruct panfrost_gem_mapping *bomapping;\n\tstruct panfrost_gem_object *bo;\n\tstruct address_space *mapping;\n\tstruct drm_gem_object *obj;\n\tpgoff_t page_offset;\n\tstruct sg_table *sgt;\n\tstruct page **pages;\n\n\tbomapping = addr_to_mapping(pfdev, as, addr);\n\tif (!bomapping)\n\t\treturn -ENOENT;\n\n\tbo = bomapping->obj;\n\tif (!bo->is_heap) {\n\t\tdev_WARN(pfdev->dev, \"matching BO is not heap type (GPU VA = %llx)\",\n\t\t\t bomapping->mmnode.start << PAGE_SHIFT);\n\t\tret = -EINVAL;\n\t\tgoto err_bo;\n\t}\n\tWARN_ON(bomapping->mmu->as != as);\n\n\t \n\taddr &= ~((u64)SZ_2M - 1);\n\tpage_offset = addr >> PAGE_SHIFT;\n\tpage_offset -= bomapping->mmnode.start;\n\n\tobj = &bo->base.base;\n\n\tdma_resv_lock(obj->resv, NULL);\n\n\tif (!bo->base.pages) {\n\t\tbo->sgts = kvmalloc_array(bo->base.base.size / SZ_2M,\n\t\t\t\t     sizeof(struct sg_table), GFP_KERNEL | __GFP_ZERO);\n\t\tif (!bo->sgts) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_unlock;\n\t\t}\n\n\t\tpages = kvmalloc_array(bo->base.base.size >> PAGE_SHIFT,\n\t\t\t\t       sizeof(struct page *), GFP_KERNEL | __GFP_ZERO);\n\t\tif (!pages) {\n\t\t\tkvfree(bo->sgts);\n\t\t\tbo->sgts = NULL;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_unlock;\n\t\t}\n\t\tbo->base.pages = pages;\n\t\tbo->base.pages_use_count = 1;\n\t} else {\n\t\tpages = bo->base.pages;\n\t\tif (pages[page_offset]) {\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmapping = bo->base.base.filp->f_mapping;\n\tmapping_set_unevictable(mapping);\n\n\tfor (i = page_offset; i < page_offset + NUM_FAULT_PAGES; i++) {\n\t\tpages[i] = shmem_read_mapping_page(mapping, i);\n\t\tif (IS_ERR(pages[i])) {\n\t\t\tret = PTR_ERR(pages[i]);\n\t\t\tpages[i] = NULL;\n\t\t\tgoto err_pages;\n\t\t}\n\t}\n\n\tsgt = &bo->sgts[page_offset / (SZ_2M / PAGE_SIZE)];\n\tret = sg_alloc_table_from_pages(sgt, pages + page_offset,\n\t\t\t\t\tNUM_FAULT_PAGES, 0, SZ_2M, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_pages;\n\n\tret = dma_map_sgtable(pfdev->dev, sgt, DMA_BIDIRECTIONAL, 0);\n\tif (ret)\n\t\tgoto err_map;\n\n\tmmu_map_sg(pfdev, bomapping->mmu, addr,\n\t\t   IOMMU_WRITE | IOMMU_READ | IOMMU_NOEXEC, sgt);\n\n\tbomapping->active = true;\n\n\tdev_dbg(pfdev->dev, \"mapped page fault @ AS%d %llx\", as, addr);\n\nout:\n\tdma_resv_unlock(obj->resv);\n\n\tpanfrost_gem_mapping_put(bomapping);\n\n\treturn 0;\n\nerr_map:\n\tsg_free_table(sgt);\nerr_pages:\n\tdrm_gem_shmem_put_pages(&bo->base);\nerr_unlock:\n\tdma_resv_unlock(obj->resv);\nerr_bo:\n\tpanfrost_gem_mapping_put(bomapping);\n\treturn ret;\n}\n\nstatic void panfrost_mmu_release_ctx(struct kref *kref)\n{\n\tstruct panfrost_mmu *mmu = container_of(kref, struct panfrost_mmu,\n\t\t\t\t\t\trefcount);\n\tstruct panfrost_device *pfdev = mmu->pfdev;\n\n\tspin_lock(&pfdev->as_lock);\n\tif (mmu->as >= 0) {\n\t\tpm_runtime_get_noresume(pfdev->dev);\n\t\tif (pm_runtime_active(pfdev->dev))\n\t\t\tpanfrost_mmu_disable(pfdev, mmu->as);\n\t\tpm_runtime_put_autosuspend(pfdev->dev);\n\n\t\tclear_bit(mmu->as, &pfdev->as_alloc_mask);\n\t\tclear_bit(mmu->as, &pfdev->as_in_use_mask);\n\t\tlist_del(&mmu->list);\n\t}\n\tspin_unlock(&pfdev->as_lock);\n\n\tfree_io_pgtable_ops(mmu->pgtbl_ops);\n\tdrm_mm_takedown(&mmu->mm);\n\tkfree(mmu);\n}\n\nvoid panfrost_mmu_ctx_put(struct panfrost_mmu *mmu)\n{\n\tkref_put(&mmu->refcount, panfrost_mmu_release_ctx);\n}\n\nstruct panfrost_mmu *panfrost_mmu_ctx_get(struct panfrost_mmu *mmu)\n{\n\tkref_get(&mmu->refcount);\n\n\treturn mmu;\n}\n\n#define PFN_4G\t\t(SZ_4G >> PAGE_SHIFT)\n#define PFN_4G_MASK\t(PFN_4G - 1)\n#define PFN_16M\t\t(SZ_16M >> PAGE_SHIFT)\n\nstatic void panfrost_drm_mm_color_adjust(const struct drm_mm_node *node,\n\t\t\t\t\t unsigned long color,\n\t\t\t\t\t u64 *start, u64 *end)\n{\n\t \n\tif (!(color & PANFROST_BO_NOEXEC)) {\n\t\tu64 next_seg;\n\n\t\tif ((*start & PFN_4G_MASK) == 0)\n\t\t\t(*start)++;\n\n\t\tif ((*end & PFN_4G_MASK) == 0)\n\t\t\t(*end)--;\n\n\t\tnext_seg = ALIGN(*start, PFN_4G);\n\t\tif (next_seg - *start <= PFN_16M)\n\t\t\t*start = next_seg + 1;\n\n\t\t*end = min(*end, ALIGN(*start, PFN_4G) - 1);\n\t}\n}\n\nstruct panfrost_mmu *panfrost_mmu_ctx_create(struct panfrost_device *pfdev)\n{\n\tstruct panfrost_mmu *mmu;\n\n\tmmu = kzalloc(sizeof(*mmu), GFP_KERNEL);\n\tif (!mmu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmmu->pfdev = pfdev;\n\tspin_lock_init(&mmu->mm_lock);\n\n\t \n\tdrm_mm_init(&mmu->mm, SZ_32M >> PAGE_SHIFT, (SZ_4G - SZ_32M) >> PAGE_SHIFT);\n\tmmu->mm.color_adjust = panfrost_drm_mm_color_adjust;\n\n\tINIT_LIST_HEAD(&mmu->list);\n\tmmu->as = -1;\n\n\tmmu->pgtbl_cfg = (struct io_pgtable_cfg) {\n\t\t.pgsize_bitmap\t= SZ_4K | SZ_2M,\n\t\t.ias\t\t= FIELD_GET(0xff, pfdev->features.mmu_features),\n\t\t.oas\t\t= FIELD_GET(0xff00, pfdev->features.mmu_features),\n\t\t.coherent_walk\t= pfdev->coherent,\n\t\t.tlb\t\t= &mmu_tlb_ops,\n\t\t.iommu_dev\t= pfdev->dev,\n\t};\n\n\tmmu->pgtbl_ops = alloc_io_pgtable_ops(ARM_MALI_LPAE, &mmu->pgtbl_cfg,\n\t\t\t\t\t      mmu);\n\tif (!mmu->pgtbl_ops) {\n\t\tkfree(mmu);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tkref_init(&mmu->refcount);\n\n\treturn mmu;\n}\n\nstatic const char *access_type_name(struct panfrost_device *pfdev,\n\t\tu32 fault_status)\n{\n\tswitch (fault_status & AS_FAULTSTATUS_ACCESS_TYPE_MASK) {\n\tcase AS_FAULTSTATUS_ACCESS_TYPE_ATOMIC:\n\t\tif (panfrost_has_hw_feature(pfdev, HW_FEATURE_AARCH64_MMU))\n\t\t\treturn \"ATOMIC\";\n\t\telse\n\t\t\treturn \"UNKNOWN\";\n\tcase AS_FAULTSTATUS_ACCESS_TYPE_READ:\n\t\treturn \"READ\";\n\tcase AS_FAULTSTATUS_ACCESS_TYPE_WRITE:\n\t\treturn \"WRITE\";\n\tcase AS_FAULTSTATUS_ACCESS_TYPE_EX:\n\t\treturn \"EXECUTE\";\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n}\n\nstatic irqreturn_t panfrost_mmu_irq_handler(int irq, void *data)\n{\n\tstruct panfrost_device *pfdev = data;\n\n\tif (!mmu_read(pfdev, MMU_INT_STAT))\n\t\treturn IRQ_NONE;\n\n\tmmu_write(pfdev, MMU_INT_MASK, 0);\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t panfrost_mmu_irq_handler_thread(int irq, void *data)\n{\n\tstruct panfrost_device *pfdev = data;\n\tu32 status = mmu_read(pfdev, MMU_INT_RAWSTAT);\n\tint ret;\n\n\twhile (status) {\n\t\tu32 as = ffs(status | (status >> 16)) - 1;\n\t\tu32 mask = BIT(as) | BIT(as + 16);\n\t\tu64 addr;\n\t\tu32 fault_status;\n\t\tu32 exception_type;\n\t\tu32 access_type;\n\t\tu32 source_id;\n\n\t\tfault_status = mmu_read(pfdev, AS_FAULTSTATUS(as));\n\t\taddr = mmu_read(pfdev, AS_FAULTADDRESS_LO(as));\n\t\taddr |= (u64)mmu_read(pfdev, AS_FAULTADDRESS_HI(as)) << 32;\n\n\t\t \n\t\texception_type = fault_status & 0xFF;\n\t\taccess_type = (fault_status >> 8) & 0x3;\n\t\tsource_id = (fault_status >> 16);\n\n\t\tmmu_write(pfdev, MMU_INT_CLEAR, mask);\n\n\t\t \n\t\tret = -1;\n\t\tif ((status & mask) == BIT(as) && (exception_type & 0xF8) == 0xC0)\n\t\t\tret = panfrost_mmu_map_fault_addr(pfdev, as, addr);\n\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_err(pfdev->dev,\n\t\t\t\t\"Unhandled Page fault in AS%d at VA 0x%016llX\\n\"\n\t\t\t\t\"Reason: %s\\n\"\n\t\t\t\t\"raw fault status: 0x%X\\n\"\n\t\t\t\t\"decoded fault status: %s\\n\"\n\t\t\t\t\"exception type 0x%X: %s\\n\"\n\t\t\t\t\"access type 0x%X: %s\\n\"\n\t\t\t\t\"source id 0x%X\\n\",\n\t\t\t\tas, addr,\n\t\t\t\t\"TODO\",\n\t\t\t\tfault_status,\n\t\t\t\t(fault_status & (1 << 10) ? \"DECODER FAULT\" : \"SLAVE FAULT\"),\n\t\t\t\texception_type, panfrost_exception_name(exception_type),\n\t\t\t\taccess_type, access_type_name(pfdev, fault_status),\n\t\t\t\tsource_id);\n\n\t\t\tspin_lock(&pfdev->as_lock);\n\t\t\t \n\t\t\tpfdev->as_faulty_mask |= mask;\n\n\t\t\t \n\t\t\tpanfrost_mmu_disable(pfdev, as);\n\t\t\tspin_unlock(&pfdev->as_lock);\n\t\t}\n\n\t\tstatus &= ~mask;\n\n\t\t \n\t\tif (!status)\n\t\t\tstatus = mmu_read(pfdev, MMU_INT_RAWSTAT) & ~pfdev->as_faulty_mask;\n\t}\n\n\tspin_lock(&pfdev->as_lock);\n\tmmu_write(pfdev, MMU_INT_MASK, ~pfdev->as_faulty_mask);\n\tspin_unlock(&pfdev->as_lock);\n\n\treturn IRQ_HANDLED;\n};\n\nint panfrost_mmu_init(struct panfrost_device *pfdev)\n{\n\tint err, irq;\n\n\tirq = platform_get_irq_byname(to_platform_device(pfdev->dev), \"mmu\");\n\tif (irq <= 0)\n\t\treturn -ENODEV;\n\n\terr = devm_request_threaded_irq(pfdev->dev, irq,\n\t\t\t\t\tpanfrost_mmu_irq_handler,\n\t\t\t\t\tpanfrost_mmu_irq_handler_thread,\n\t\t\t\t\tIRQF_SHARED, KBUILD_MODNAME \"-mmu\",\n\t\t\t\t\tpfdev);\n\n\tif (err) {\n\t\tdev_err(pfdev->dev, \"failed to request mmu irq\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid panfrost_mmu_fini(struct panfrost_device *pfdev)\n{\n\tmmu_write(pfdev, MMU_INT_MASK, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}