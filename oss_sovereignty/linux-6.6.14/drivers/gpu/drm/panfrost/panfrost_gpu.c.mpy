{
  "module_name": "panfrost_gpu.c",
  "hash_id": "6dfe26abf6488abc1a20426849ec38538dc08249ce6d7b8b429c414bed240515",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_gpu.c",
  "human_readable_source": "\n \n \n \n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"panfrost_device.h\"\n#include \"panfrost_features.h\"\n#include \"panfrost_issues.h\"\n#include \"panfrost_gpu.h\"\n#include \"panfrost_perfcnt.h\"\n#include \"panfrost_regs.h\"\n\nstatic irqreturn_t panfrost_gpu_irq_handler(int irq, void *data)\n{\n\tstruct panfrost_device *pfdev = data;\n\tu32 state = gpu_read(pfdev, GPU_INT_STAT);\n\tu32 fault_status = gpu_read(pfdev, GPU_FAULT_STATUS);\n\n\tif (!state)\n\t\treturn IRQ_NONE;\n\n\tif (state & GPU_IRQ_MASK_ERROR) {\n\t\tu64 address = (u64) gpu_read(pfdev, GPU_FAULT_ADDRESS_HI) << 32;\n\t\taddress |= gpu_read(pfdev, GPU_FAULT_ADDRESS_LO);\n\n\t\tdev_warn(pfdev->dev, \"GPU Fault 0x%08x (%s) at 0x%016llx\\n\",\n\t\t\t fault_status, panfrost_exception_name(fault_status & 0xFF),\n\t\t\t address);\n\n\t\tif (state & GPU_IRQ_MULTIPLE_FAULT)\n\t\t\tdev_warn(pfdev->dev, \"There were multiple GPU faults - some have not been reported\\n\");\n\n\t\tgpu_write(pfdev, GPU_INT_MASK, 0);\n\t}\n\n\tif (state & GPU_IRQ_PERFCNT_SAMPLE_COMPLETED)\n\t\tpanfrost_perfcnt_sample_done(pfdev);\n\n\tif (state & GPU_IRQ_CLEAN_CACHES_COMPLETED)\n\t\tpanfrost_perfcnt_clean_cache_done(pfdev);\n\n\tgpu_write(pfdev, GPU_INT_CLEAR, state);\n\n\treturn IRQ_HANDLED;\n}\n\nint panfrost_gpu_soft_reset(struct panfrost_device *pfdev)\n{\n\tint ret;\n\tu32 val;\n\n\tgpu_write(pfdev, GPU_INT_MASK, 0);\n\tgpu_write(pfdev, GPU_INT_CLEAR, GPU_IRQ_RESET_COMPLETED);\n\tgpu_write(pfdev, GPU_CMD, GPU_CMD_SOFT_RESET);\n\n\tret = readl_relaxed_poll_timeout(pfdev->iomem + GPU_INT_RAWSTAT,\n\t\tval, val & GPU_IRQ_RESET_COMPLETED, 100, 10000);\n\n\tif (ret) {\n\t\tdev_err(pfdev->dev, \"gpu soft reset timed out\\n\");\n\t\treturn ret;\n\t}\n\n\tgpu_write(pfdev, GPU_INT_CLEAR, GPU_IRQ_MASK_ALL);\n\n\t \n\tgpu_write(pfdev, GPU_INT_MASK,\n\t\t  GPU_IRQ_MASK_ERROR |\n\t\t  GPU_IRQ_PERFCNT_SAMPLE_COMPLETED |\n\t\t  GPU_IRQ_CLEAN_CACHES_COMPLETED);\n\n\treturn 0;\n}\n\nvoid panfrost_gpu_amlogic_quirk(struct panfrost_device *pfdev)\n{\n\t \n\tgpu_write(pfdev, GPU_PWR_KEY, GPU_PWR_KEY_UNLOCK);\n\tgpu_write(pfdev, GPU_PWR_OVERRIDE1, 0xfff | (0x20 << 16));\n}\n\nstatic void panfrost_gpu_init_quirks(struct panfrost_device *pfdev)\n{\n\tu32 quirks = 0;\n\n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_8443) ||\n\t    panfrost_has_hw_issue(pfdev, HW_ISSUE_11035))\n\t\tquirks |= SC_LS_PAUSEBUFFER_DISABLE;\n\n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_10327))\n\t\tquirks |= SC_SDC_DISABLE_OQ_DISCARD;\n\n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_10797))\n\t\tquirks |= SC_ENABLE_TEXGRD_FLAGS;\n\n\tif (!panfrost_has_hw_issue(pfdev, GPUCORE_1619)) {\n\t\tif (panfrost_model_cmp(pfdev, 0x750) < 0)  \n\t\t\tquirks |= SC_LS_ATTR_CHECK_DISABLE;\n\t\telse if (panfrost_model_cmp(pfdev, 0x880) <= 0)  \n\t\t\tquirks |= SC_LS_ALLOW_ATTR_TYPES;\n\t}\n\n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_TTRX_2968_TTRX_3162))\n\t\tquirks |= SC_VAR_ALGORITHM;\n\n\tif (panfrost_has_hw_feature(pfdev, HW_FEATURE_TLS_HASHING))\n\t\tquirks |= SC_TLS_HASH_ENABLE;\n\n\tif (quirks)\n\t\tgpu_write(pfdev, GPU_SHADER_CONFIG, quirks);\n\n\n\tquirks = gpu_read(pfdev, GPU_TILER_CONFIG);\n\n\t \n\tif (panfrost_has_hw_issue(pfdev, HW_ISSUE_T76X_3953))\n\t\tquirks |= TC_CLOCK_GATE_OVERRIDE;\n\n\tgpu_write(pfdev, GPU_TILER_CONFIG, quirks);\n\n\n\tquirks = 0;\n\tif ((panfrost_model_eq(pfdev, 0x860) || panfrost_model_eq(pfdev, 0x880)) &&\n\t    pfdev->features.revision >= 0x2000)\n\t\tquirks |= JM_MAX_JOB_THROTTLE_LIMIT << JM_JOB_THROTTLE_LIMIT_SHIFT;\n\telse if (panfrost_model_eq(pfdev, 0x6000) &&\n\t\t pfdev->features.coherency_features == COHERENCY_ACE)\n\t\tquirks |= (COHERENCY_ACE_LITE | COHERENCY_ACE) <<\n\t\t\t   JM_FORCE_COHERENCY_FEATURES_SHIFT;\n\n\tif (panfrost_has_hw_feature(pfdev, HW_FEATURE_IDVS_GROUP_SIZE))\n\t\tquirks |= JM_DEFAULT_IDVS_GROUP_SIZE << JM_IDVS_GROUP_SIZE_SHIFT;\n\n\tif (quirks)\n\t\tgpu_write(pfdev, GPU_JM_CONFIG, quirks);\n\n\t \n\tif (pfdev->comp->vendor_quirk)\n\t\tpfdev->comp->vendor_quirk(pfdev);\n}\n\n#define MAX_HW_REVS 6\n\nstruct panfrost_model {\n\tconst char *name;\n\tu32 id;\n\tu32 id_mask;\n\tu64 features;\n\tu64 issues;\n\tstruct {\n\t\tu32 revision;\n\t\tu64 issues;\n\t} revs[MAX_HW_REVS];\n};\n\n#define GPU_MODEL(_name, _id, ...) \\\n{\\\n\t.name = __stringify(_name),\t\t\t\t\\\n\t.id = _id,\t\t\t\t\t\t\\\n\t.features = hw_features_##_name,\t\t\t\\\n\t.issues = hw_issues_##_name,\t\t\t\t\\\n\t.revs = { __VA_ARGS__ },\t\t\t\t\\\n}\n\n#define GPU_REV_EXT(name, _rev, _p, _s, stat) \\\n{\\\n\t.revision = (_rev) << 12 | (_p) << 4 | (_s),\t\t\\\n\t.issues = hw_issues_##name##_r##_rev##p##_p##stat,\t\\\n}\n#define GPU_REV(name, r, p) GPU_REV_EXT(name, r, p, 0, )\n\nstatic const struct panfrost_model gpu_models[] = {\n\t \n\tGPU_MODEL(t600, 0x600,\n\t\tGPU_REV_EXT(t600, 0, 0, 1, _15dev0)),\n\tGPU_MODEL(t620, 0x620,\n\t\tGPU_REV(t620, 0, 1), GPU_REV(t620, 1, 0)),\n\tGPU_MODEL(t720, 0x720),\n\tGPU_MODEL(t760, 0x750,\n\t\tGPU_REV(t760, 0, 0), GPU_REV(t760, 0, 1),\n\t\tGPU_REV_EXT(t760, 0, 1, 0, _50rel0),\n\t\tGPU_REV(t760, 0, 2), GPU_REV(t760, 0, 3)),\n\tGPU_MODEL(t820, 0x820),\n\tGPU_MODEL(t830, 0x830),\n\tGPU_MODEL(t860, 0x860),\n\tGPU_MODEL(t880, 0x880),\n\n\tGPU_MODEL(g71, 0x6000,\n\t\tGPU_REV_EXT(g71, 0, 0, 1, _05dev0)),\n\tGPU_MODEL(g72, 0x6001),\n\tGPU_MODEL(g51, 0x7000),\n\tGPU_MODEL(g76, 0x7001),\n\tGPU_MODEL(g52, 0x7002),\n\tGPU_MODEL(g31, 0x7003,\n\t\tGPU_REV(g31, 1, 0)),\n\n\tGPU_MODEL(g57, 0x9001,\n\t\tGPU_REV(g57, 0, 0)),\n\n\t \n\tGPU_MODEL(g57, 0x9003,\n\t\tGPU_REV(g57, 0, 0)),\n};\n\nstatic void panfrost_gpu_init_features(struct panfrost_device *pfdev)\n{\n\tu32 gpu_id, num_js, major, minor, status, rev;\n\tconst char *name = \"unknown\";\n\tu64 hw_feat = 0;\n\tu64 hw_issues = hw_issues_all;\n\tconst struct panfrost_model *model;\n\tint i;\n\n\tpfdev->features.l2_features = gpu_read(pfdev, GPU_L2_FEATURES);\n\tpfdev->features.core_features = gpu_read(pfdev, GPU_CORE_FEATURES);\n\tpfdev->features.tiler_features = gpu_read(pfdev, GPU_TILER_FEATURES);\n\tpfdev->features.mem_features = gpu_read(pfdev, GPU_MEM_FEATURES);\n\tpfdev->features.mmu_features = gpu_read(pfdev, GPU_MMU_FEATURES);\n\tpfdev->features.thread_features = gpu_read(pfdev, GPU_THREAD_FEATURES);\n\tpfdev->features.max_threads = gpu_read(pfdev, GPU_THREAD_MAX_THREADS);\n\tpfdev->features.thread_max_workgroup_sz = gpu_read(pfdev, GPU_THREAD_MAX_WORKGROUP_SIZE);\n\tpfdev->features.thread_max_barrier_sz = gpu_read(pfdev, GPU_THREAD_MAX_BARRIER_SIZE);\n\tpfdev->features.coherency_features = gpu_read(pfdev, GPU_COHERENCY_FEATURES);\n\tpfdev->features.afbc_features = gpu_read(pfdev, GPU_AFBC_FEATURES);\n\tfor (i = 0; i < 4; i++)\n\t\tpfdev->features.texture_features[i] = gpu_read(pfdev, GPU_TEXTURE_FEATURES(i));\n\n\tpfdev->features.as_present = gpu_read(pfdev, GPU_AS_PRESENT);\n\n\tpfdev->features.js_present = gpu_read(pfdev, GPU_JS_PRESENT);\n\tnum_js = hweight32(pfdev->features.js_present);\n\tfor (i = 0; i < num_js; i++)\n\t\tpfdev->features.js_features[i] = gpu_read(pfdev, GPU_JS_FEATURES(i));\n\n\tpfdev->features.shader_present = gpu_read(pfdev, GPU_SHADER_PRESENT_LO);\n\tpfdev->features.shader_present |= (u64)gpu_read(pfdev, GPU_SHADER_PRESENT_HI) << 32;\n\n\tpfdev->features.tiler_present = gpu_read(pfdev, GPU_TILER_PRESENT_LO);\n\tpfdev->features.tiler_present |= (u64)gpu_read(pfdev, GPU_TILER_PRESENT_HI) << 32;\n\n\tpfdev->features.l2_present = gpu_read(pfdev, GPU_L2_PRESENT_LO);\n\tpfdev->features.l2_present |= (u64)gpu_read(pfdev, GPU_L2_PRESENT_HI) << 32;\n\tpfdev->features.nr_core_groups = hweight64(pfdev->features.l2_present);\n\n\tpfdev->features.stack_present = gpu_read(pfdev, GPU_STACK_PRESENT_LO);\n\tpfdev->features.stack_present |= (u64)gpu_read(pfdev, GPU_STACK_PRESENT_HI) << 32;\n\n\tpfdev->features.thread_tls_alloc = gpu_read(pfdev, GPU_THREAD_TLS_ALLOC);\n\n\tgpu_id = gpu_read(pfdev, GPU_ID);\n\tpfdev->features.revision = gpu_id & 0xffff;\n\tpfdev->features.id = gpu_id >> 16;\n\n\t \n\tif (pfdev->features.id == 0x6956)\n\t\tpfdev->features.id = 0x0600;\n\n\tmajor = (pfdev->features.revision >> 12) & 0xf;\n\tminor = (pfdev->features.revision >> 4) & 0xff;\n\tstatus = pfdev->features.revision & 0xf;\n\trev = pfdev->features.revision;\n\n\tgpu_id = pfdev->features.id;\n\n\tfor (model = gpu_models; model->name; model++) {\n\t\tint best = -1;\n\n\t\tif (!panfrost_model_eq(pfdev, model->id))\n\t\t\tcontinue;\n\n\t\tname = model->name;\n\t\thw_feat = model->features;\n\t\thw_issues |= model->issues;\n\t\tfor (i = 0; i < MAX_HW_REVS; i++) {\n\t\t\tif (model->revs[i].revision == rev) {\n\t\t\t\tbest = i;\n\t\t\t\tbreak;\n\t\t\t} else if (model->revs[i].revision == (rev & ~0xf))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tif (best >= 0)\n\t\t\thw_issues |= model->revs[best].issues;\n\n\t\tbreak;\n\t}\n\n\tbitmap_from_u64(pfdev->features.hw_features, hw_feat);\n\tbitmap_from_u64(pfdev->features.hw_issues, hw_issues);\n\n\tdev_info(pfdev->dev, \"mali-%s id 0x%x major 0x%x minor 0x%x status 0x%x\",\n\t\t name, gpu_id, major, minor, status);\n\tdev_info(pfdev->dev, \"features: %64pb, issues: %64pb\",\n\t\t pfdev->features.hw_features,\n\t\t pfdev->features.hw_issues);\n\n\tdev_info(pfdev->dev, \"Features: L2:0x%08x Shader:0x%08x Tiler:0x%08x Mem:0x%0x MMU:0x%08x AS:0x%x JS:0x%x\",\n\t\t pfdev->features.l2_features,\n\t\t pfdev->features.core_features,\n\t\t pfdev->features.tiler_features,\n\t\t pfdev->features.mem_features,\n\t\t pfdev->features.mmu_features,\n\t\t pfdev->features.as_present,\n\t\t pfdev->features.js_present);\n\n\tdev_info(pfdev->dev, \"shader_present=0x%0llx l2_present=0x%0llx\",\n\t\t pfdev->features.shader_present, pfdev->features.l2_present);\n}\n\nstatic u64 panfrost_get_core_mask(struct panfrost_device *pfdev)\n{\n\tu64 core_mask;\n\n\tif (pfdev->features.l2_present == 1)\n\t\treturn U64_MAX;\n\n\t \n\tcore_mask = ~(pfdev->features.l2_present - 1) &\n\t\t     (pfdev->features.l2_present - 2);\n\tdev_info_once(pfdev->dev, \"using only 1st core group (%lu cores from %lu)\\n\",\n\t\t      hweight64(core_mask),\n\t\t      hweight64(pfdev->features.shader_present));\n\n\treturn core_mask;\n}\n\nvoid panfrost_gpu_power_on(struct panfrost_device *pfdev)\n{\n\tint ret;\n\tu32 val;\n\tu64 core_mask;\n\n\tpanfrost_gpu_init_quirks(pfdev);\n\tcore_mask = panfrost_get_core_mask(pfdev);\n\n\tgpu_write(pfdev, L2_PWRON_LO, pfdev->features.l2_present & core_mask);\n\tret = readl_relaxed_poll_timeout(pfdev->iomem + L2_READY_LO,\n\t\tval, val == (pfdev->features.l2_present & core_mask),\n\t\t100, 20000);\n\tif (ret)\n\t\tdev_err(pfdev->dev, \"error powering up gpu L2\");\n\n\tgpu_write(pfdev, SHADER_PWRON_LO,\n\t\t  pfdev->features.shader_present & core_mask);\n\tret = readl_relaxed_poll_timeout(pfdev->iomem + SHADER_READY_LO,\n\t\tval, val == (pfdev->features.shader_present & core_mask),\n\t\t100, 20000);\n\tif (ret)\n\t\tdev_err(pfdev->dev, \"error powering up gpu shader\");\n\n\tgpu_write(pfdev, TILER_PWRON_LO, pfdev->features.tiler_present);\n\tret = readl_relaxed_poll_timeout(pfdev->iomem + TILER_READY_LO,\n\t\tval, val == pfdev->features.tiler_present, 100, 1000);\n\tif (ret)\n\t\tdev_err(pfdev->dev, \"error powering up gpu tiler\");\n}\n\nvoid panfrost_gpu_power_off(struct panfrost_device *pfdev)\n{\n\tint ret;\n\tu32 val;\n\n\tgpu_write(pfdev, SHADER_PWROFF_LO, pfdev->features.shader_present);\n\tret = readl_relaxed_poll_timeout(pfdev->iomem + SHADER_PWRTRANS_LO,\n\t\t\t\t\t val, !val, 1, 1000);\n\tif (ret)\n\t\tdev_err(pfdev->dev, \"shader power transition timeout\");\n\n\tgpu_write(pfdev, TILER_PWROFF_LO, pfdev->features.tiler_present);\n\tret = readl_relaxed_poll_timeout(pfdev->iomem + TILER_PWRTRANS_LO,\n\t\t\t\t\t val, !val, 1, 1000);\n\tif (ret)\n\t\tdev_err(pfdev->dev, \"tiler power transition timeout\");\n\n\tgpu_write(pfdev, L2_PWROFF_LO, pfdev->features.l2_present);\n\tret = readl_poll_timeout(pfdev->iomem + L2_PWRTRANS_LO,\n\t\t\t\t val, !val, 0, 1000);\n\tif (ret)\n\t\tdev_err(pfdev->dev, \"l2 power transition timeout\");\n}\n\nint panfrost_gpu_init(struct panfrost_device *pfdev)\n{\n\tint err, irq;\n\n\terr = panfrost_gpu_soft_reset(pfdev);\n\tif (err)\n\t\treturn err;\n\n\tpanfrost_gpu_init_features(pfdev);\n\n\terr = dma_set_mask_and_coherent(pfdev->dev,\n\t\tDMA_BIT_MASK(FIELD_GET(0xff00, pfdev->features.mmu_features)));\n\tif (err)\n\t\treturn err;\n\n\tdma_set_max_seg_size(pfdev->dev, UINT_MAX);\n\n\tirq = platform_get_irq_byname(to_platform_device(pfdev->dev), \"gpu\");\n\tif (irq <= 0)\n\t\treturn -ENODEV;\n\n\terr = devm_request_irq(pfdev->dev, irq, panfrost_gpu_irq_handler,\n\t\t\t       IRQF_SHARED, KBUILD_MODNAME \"-gpu\", pfdev);\n\tif (err) {\n\t\tdev_err(pfdev->dev, \"failed to request gpu irq\");\n\t\treturn err;\n\t}\n\n\tpanfrost_gpu_power_on(pfdev);\n\n\treturn 0;\n}\n\nvoid panfrost_gpu_fini(struct panfrost_device *pfdev)\n{\n\tpanfrost_gpu_power_off(pfdev);\n}\n\nu32 panfrost_gpu_get_latest_flush_id(struct panfrost_device *pfdev)\n{\n\tu32 flush_id;\n\n\tif (panfrost_has_hw_feature(pfdev, HW_FEATURE_FLUSH_REDUCTION)) {\n\t\t \n\t\tif (pm_runtime_get_if_in_use(pfdev->dev)) {\n\t\t\tflush_id = gpu_read(pfdev, GPU_LATEST_FLUSH_ID);\n\t\t\tpm_runtime_put(pfdev->dev);\n\t\t\treturn flush_id;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}