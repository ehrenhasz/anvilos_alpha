{
  "module_name": "panfrost_devfreq.c",
  "hash_id": "7b31ad40534428d0cf0a5813860287d45d8a239234bb524412264c61aae08d81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_devfreq.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/devfreq.h>\n#include <linux/devfreq_cooling.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n\n#include \"panfrost_device.h\"\n#include \"panfrost_devfreq.h\"\n\nstatic void panfrost_devfreq_update_utilization(struct panfrost_devfreq *pfdevfreq)\n{\n\tktime_t now, last;\n\n\tnow = ktime_get();\n\tlast = pfdevfreq->time_last_update;\n\n\tif (pfdevfreq->busy_count > 0)\n\t\tpfdevfreq->busy_time += ktime_sub(now, last);\n\telse\n\t\tpfdevfreq->idle_time += ktime_sub(now, last);\n\n\tpfdevfreq->time_last_update = now;\n}\n\nstatic int panfrost_devfreq_target(struct device *dev, unsigned long *freq,\n\t\t\t\t   u32 flags)\n{\n\tstruct dev_pm_opp *opp;\n\n\topp = devfreq_recommended_opp(dev, freq, flags);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\tdev_pm_opp_put(opp);\n\n\treturn dev_pm_opp_set_rate(dev, *freq);\n}\n\nstatic void panfrost_devfreq_reset(struct panfrost_devfreq *pfdevfreq)\n{\n\tpfdevfreq->busy_time = 0;\n\tpfdevfreq->idle_time = 0;\n\tpfdevfreq->time_last_update = ktime_get();\n}\n\nstatic int panfrost_devfreq_get_dev_status(struct device *dev,\n\t\t\t\t\t   struct devfreq_dev_status *status)\n{\n\tstruct panfrost_device *pfdev = dev_get_drvdata(dev);\n\tstruct panfrost_devfreq *pfdevfreq = &pfdev->pfdevfreq;\n\tunsigned long irqflags;\n\n\tstatus->current_frequency = clk_get_rate(pfdev->clock);\n\n\tspin_lock_irqsave(&pfdevfreq->lock, irqflags);\n\n\tpanfrost_devfreq_update_utilization(pfdevfreq);\n\n\tstatus->total_time = ktime_to_ns(ktime_add(pfdevfreq->busy_time,\n\t\t\t\t\t\t   pfdevfreq->idle_time));\n\n\tstatus->busy_time = ktime_to_ns(pfdevfreq->busy_time);\n\n\tpanfrost_devfreq_reset(pfdevfreq);\n\n\tspin_unlock_irqrestore(&pfdevfreq->lock, irqflags);\n\n\tdev_dbg(pfdev->dev, \"busy %lu total %lu %lu %% freq %lu MHz\\n\",\n\t\tstatus->busy_time, status->total_time,\n\t\tstatus->busy_time / (status->total_time / 100),\n\t\tstatus->current_frequency / 1000 / 1000);\n\n\treturn 0;\n}\n\nstatic struct devfreq_dev_profile panfrost_devfreq_profile = {\n\t.timer = DEVFREQ_TIMER_DELAYED,\n\t.polling_ms = 50,  \n\t.target = panfrost_devfreq_target,\n\t.get_dev_status = panfrost_devfreq_get_dev_status,\n};\n\nstatic int panfrost_read_speedbin(struct device *dev)\n{\n\tu32 val;\n\tint ret;\n\n\tret = nvmem_cell_read_variable_le_u32(dev, \"speed-bin\", &val);\n\tif (ret) {\n\t\t \n\t\tif (ret != -ENOENT && ret != -EOPNOTSUPP) {\n\t\t\tDRM_DEV_ERROR(dev, \"Cannot read speed-bin (%d).\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\t}\n\tDRM_DEV_DEBUG(dev, \"Using speed-bin = 0x%x\\n\", val);\n\n\treturn devm_pm_opp_set_supported_hw(dev, &val, 1);\n}\n\nint panfrost_devfreq_init(struct panfrost_device *pfdev)\n{\n\tint ret;\n\tstruct dev_pm_opp *opp;\n\tunsigned long cur_freq;\n\tstruct device *dev = &pfdev->pdev->dev;\n\tstruct devfreq *devfreq;\n\tstruct thermal_cooling_device *cooling;\n\tstruct panfrost_devfreq *pfdevfreq = &pfdev->pfdevfreq;\n\n\tif (pfdev->comp->num_supplies > 1) {\n\t\t \n\t\tDRM_DEV_INFO(dev, \"More than 1 supply is not supported yet\\n\");\n\t\treturn 0;\n\t}\n\n\tret = panfrost_read_speedbin(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_pm_opp_set_regulators(dev, pfdev->comp->supply_names);\n\tif (ret) {\n\t\t \n\t\tif (ret != -ENODEV) {\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tDRM_DEV_ERROR(dev, \"Couldn't set OPP regulators\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_pm_opp_of_add_table(dev);\n\tif (ret) {\n\t\t \n\t\tif (ret == -ENODEV)\n\t\t\tret = 0;\n\t\treturn ret;\n\t}\n\tpfdevfreq->opp_of_table_added = true;\n\n\tspin_lock_init(&pfdevfreq->lock);\n\n\tpanfrost_devfreq_reset(pfdevfreq);\n\n\tcur_freq = clk_get_rate(pfdev->clock);\n\n\topp = devfreq_recommended_opp(dev, &cur_freq, 0);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\tpanfrost_devfreq_profile.initial_freq = cur_freq;\n\n\t \n\tret = dev_pm_opp_set_opp(dev, opp);\n\tif (ret) {\n\t\tDRM_DEV_ERROR(dev, \"Couldn't set recommended OPP\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_pm_opp_put(opp);\n\n\t \n\tpfdevfreq->gov_data.upthreshold = 45;\n\tpfdevfreq->gov_data.downdifferential = 5;\n\n\tdevfreq = devm_devfreq_add_device(dev, &panfrost_devfreq_profile,\n\t\t\t\t\t  DEVFREQ_GOV_SIMPLE_ONDEMAND,\n\t\t\t\t\t  &pfdevfreq->gov_data);\n\tif (IS_ERR(devfreq)) {\n\t\tDRM_DEV_ERROR(dev, \"Couldn't initialize GPU devfreq\\n\");\n\t\treturn PTR_ERR(devfreq);\n\t}\n\tpfdevfreq->devfreq = devfreq;\n\n\tcooling = devfreq_cooling_em_register(devfreq, NULL);\n\tif (IS_ERR(cooling))\n\t\tDRM_DEV_INFO(dev, \"Failed to register cooling device\\n\");\n\telse\n\t\tpfdevfreq->cooling = cooling;\n\n\treturn 0;\n}\n\nvoid panfrost_devfreq_fini(struct panfrost_device *pfdev)\n{\n\tstruct panfrost_devfreq *pfdevfreq = &pfdev->pfdevfreq;\n\n\tif (pfdevfreq->cooling) {\n\t\tdevfreq_cooling_unregister(pfdevfreq->cooling);\n\t\tpfdevfreq->cooling = NULL;\n\t}\n}\n\nvoid panfrost_devfreq_resume(struct panfrost_device *pfdev)\n{\n\tstruct panfrost_devfreq *pfdevfreq = &pfdev->pfdevfreq;\n\n\tif (!pfdevfreq->devfreq)\n\t\treturn;\n\n\tpanfrost_devfreq_reset(pfdevfreq);\n\n\tdevfreq_resume_device(pfdevfreq->devfreq);\n}\n\nvoid panfrost_devfreq_suspend(struct panfrost_device *pfdev)\n{\n\tstruct panfrost_devfreq *pfdevfreq = &pfdev->pfdevfreq;\n\n\tif (!pfdevfreq->devfreq)\n\t\treturn;\n\n\tdevfreq_suspend_device(pfdevfreq->devfreq);\n}\n\nvoid panfrost_devfreq_record_busy(struct panfrost_devfreq *pfdevfreq)\n{\n\tunsigned long irqflags;\n\n\tif (!pfdevfreq->devfreq)\n\t\treturn;\n\n\tspin_lock_irqsave(&pfdevfreq->lock, irqflags);\n\n\tpanfrost_devfreq_update_utilization(pfdevfreq);\n\n\tpfdevfreq->busy_count++;\n\n\tspin_unlock_irqrestore(&pfdevfreq->lock, irqflags);\n}\n\nvoid panfrost_devfreq_record_idle(struct panfrost_devfreq *pfdevfreq)\n{\n\tunsigned long irqflags;\n\n\tif (!pfdevfreq->devfreq)\n\t\treturn;\n\n\tspin_lock_irqsave(&pfdevfreq->lock, irqflags);\n\n\tpanfrost_devfreq_update_utilization(pfdevfreq);\n\n\tWARN_ON(--pfdevfreq->busy_count < 0);\n\n\tspin_unlock_irqrestore(&pfdevfreq->lock, irqflags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}