{
  "module_name": "panfrost_device.c",
  "hash_id": "a811371b0b090089003cba799ab346066af4e292819852d5f260e69ebf498eaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/panfrost/panfrost_device.c",
  "human_readable_source": "\n \n \n\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include \"panfrost_device.h\"\n#include \"panfrost_devfreq.h\"\n#include \"panfrost_features.h\"\n#include \"panfrost_issues.h\"\n#include \"panfrost_gpu.h\"\n#include \"panfrost_job.h\"\n#include \"panfrost_mmu.h\"\n#include \"panfrost_perfcnt.h\"\n\nstatic int panfrost_reset_init(struct panfrost_device *pfdev)\n{\n\tpfdev->rstc = devm_reset_control_array_get_optional_exclusive(pfdev->dev);\n\tif (IS_ERR(pfdev->rstc)) {\n\t\tdev_err(pfdev->dev, \"get reset failed %ld\\n\", PTR_ERR(pfdev->rstc));\n\t\treturn PTR_ERR(pfdev->rstc);\n\t}\n\n\treturn reset_control_deassert(pfdev->rstc);\n}\n\nstatic void panfrost_reset_fini(struct panfrost_device *pfdev)\n{\n\treset_control_assert(pfdev->rstc);\n}\n\nstatic int panfrost_clk_init(struct panfrost_device *pfdev)\n{\n\tint err;\n\tunsigned long rate;\n\n\tpfdev->clock = devm_clk_get(pfdev->dev, NULL);\n\tif (IS_ERR(pfdev->clock)) {\n\t\tdev_err(pfdev->dev, \"get clock failed %ld\\n\", PTR_ERR(pfdev->clock));\n\t\treturn PTR_ERR(pfdev->clock);\n\t}\n\n\trate = clk_get_rate(pfdev->clock);\n\tdev_info(pfdev->dev, \"clock rate = %lu\\n\", rate);\n\n\terr = clk_prepare_enable(pfdev->clock);\n\tif (err)\n\t\treturn err;\n\n\tpfdev->bus_clock = devm_clk_get_optional(pfdev->dev, \"bus\");\n\tif (IS_ERR(pfdev->bus_clock)) {\n\t\tdev_err(pfdev->dev, \"get bus_clock failed %ld\\n\",\n\t\t\tPTR_ERR(pfdev->bus_clock));\n\t\terr = PTR_ERR(pfdev->bus_clock);\n\t\tgoto disable_clock;\n\t}\n\n\tif (pfdev->bus_clock) {\n\t\trate = clk_get_rate(pfdev->bus_clock);\n\t\tdev_info(pfdev->dev, \"bus_clock rate = %lu\\n\", rate);\n\n\t\terr = clk_prepare_enable(pfdev->bus_clock);\n\t\tif (err)\n\t\t\tgoto disable_clock;\n\t}\n\n\treturn 0;\n\ndisable_clock:\n\tclk_disable_unprepare(pfdev->clock);\n\n\treturn err;\n}\n\nstatic void panfrost_clk_fini(struct panfrost_device *pfdev)\n{\n\tclk_disable_unprepare(pfdev->bus_clock);\n\tclk_disable_unprepare(pfdev->clock);\n}\n\nstatic int panfrost_regulator_init(struct panfrost_device *pfdev)\n{\n\tint ret, i;\n\n\tpfdev->regulators = devm_kcalloc(pfdev->dev, pfdev->comp->num_supplies,\n\t\t\t\t\t sizeof(*pfdev->regulators),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!pfdev->regulators)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < pfdev->comp->num_supplies; i++)\n\t\tpfdev->regulators[i].supply = pfdev->comp->supply_names[i];\n\n\tret = devm_regulator_bulk_get(pfdev->dev,\n\t\t\t\t      pfdev->comp->num_supplies,\n\t\t\t\t      pfdev->regulators);\n\tif (ret < 0) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(pfdev->dev, \"failed to get regulators: %d\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(pfdev->comp->num_supplies,\n\t\t\t\t    pfdev->regulators);\n\tif (ret < 0) {\n\t\tdev_err(pfdev->dev, \"failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void panfrost_regulator_fini(struct panfrost_device *pfdev)\n{\n\tif (!pfdev->regulators)\n\t\treturn;\n\n\tregulator_bulk_disable(pfdev->comp->num_supplies, pfdev->regulators);\n}\n\nstatic void panfrost_pm_domain_fini(struct panfrost_device *pfdev)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pfdev->pm_domain_devs); i++) {\n\t\tif (!pfdev->pm_domain_devs[i])\n\t\t\tbreak;\n\n\t\tif (pfdev->pm_domain_links[i])\n\t\t\tdevice_link_del(pfdev->pm_domain_links[i]);\n\n\t\tdev_pm_domain_detach(pfdev->pm_domain_devs[i], true);\n\t}\n}\n\nstatic int panfrost_pm_domain_init(struct panfrost_device *pfdev)\n{\n\tint err;\n\tint i, num_domains;\n\n\tnum_domains = of_count_phandle_with_args(pfdev->dev->of_node,\n\t\t\t\t\t\t \"power-domains\",\n\t\t\t\t\t\t \"#power-domain-cells\");\n\n\t \n\tif (num_domains < 2 && pfdev->comp->num_pm_domains < 2)\n\t\treturn 0;\n\n\tif (num_domains != pfdev->comp->num_pm_domains) {\n\t\tdev_err(pfdev->dev,\n\t\t\t\"Incorrect number of power domains: %d provided, %d needed\\n\",\n\t\t\tnum_domains, pfdev->comp->num_pm_domains);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN(num_domains > ARRAY_SIZE(pfdev->pm_domain_devs),\n\t\t\t\"Too many supplies in compatible structure.\\n\"))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_domains; i++) {\n\t\tpfdev->pm_domain_devs[i] =\n\t\t\tdev_pm_domain_attach_by_name(pfdev->dev,\n\t\t\t\t\tpfdev->comp->pm_domain_names[i]);\n\t\tif (IS_ERR_OR_NULL(pfdev->pm_domain_devs[i])) {\n\t\t\terr = PTR_ERR(pfdev->pm_domain_devs[i]) ? : -ENODATA;\n\t\t\tpfdev->pm_domain_devs[i] = NULL;\n\t\t\tdev_err(pfdev->dev,\n\t\t\t\t\"failed to get pm-domain %s(%d): %d\\n\",\n\t\t\t\tpfdev->comp->pm_domain_names[i], i, err);\n\t\t\tgoto err;\n\t\t}\n\n\t\tpfdev->pm_domain_links[i] = device_link_add(pfdev->dev,\n\t\t\t\tpfdev->pm_domain_devs[i], DL_FLAG_PM_RUNTIME |\n\t\t\t\tDL_FLAG_STATELESS | DL_FLAG_RPM_ACTIVE);\n\t\tif (!pfdev->pm_domain_links[i]) {\n\t\t\tdev_err(pfdev->pm_domain_devs[i],\n\t\t\t\t\"adding device link failed!\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tpanfrost_pm_domain_fini(pfdev);\n\treturn err;\n}\n\nint panfrost_device_init(struct panfrost_device *pfdev)\n{\n\tint err;\n\n\tmutex_init(&pfdev->sched_lock);\n\tINIT_LIST_HEAD(&pfdev->scheduled_jobs);\n\tINIT_LIST_HEAD(&pfdev->as_lru_list);\n\n\tspin_lock_init(&pfdev->as_lock);\n\n\terr = panfrost_clk_init(pfdev);\n\tif (err) {\n\t\tdev_err(pfdev->dev, \"clk init failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = panfrost_devfreq_init(pfdev);\n\tif (err) {\n\t\tif (err != -EPROBE_DEFER)\n\t\t\tdev_err(pfdev->dev, \"devfreq init failed %d\\n\", err);\n\t\tgoto out_clk;\n\t}\n\n\t \n\tif (!pfdev->pfdevfreq.opp_of_table_added) {\n\t\terr = panfrost_regulator_init(pfdev);\n\t\tif (err)\n\t\t\tgoto out_devfreq;\n\t}\n\n\terr = panfrost_reset_init(pfdev);\n\tif (err) {\n\t\tdev_err(pfdev->dev, \"reset init failed %d\\n\", err);\n\t\tgoto out_regulator;\n\t}\n\n\terr = panfrost_pm_domain_init(pfdev);\n\tif (err)\n\t\tgoto out_reset;\n\n\tpfdev->iomem = devm_platform_ioremap_resource(pfdev->pdev, 0);\n\tif (IS_ERR(pfdev->iomem)) {\n\t\terr = PTR_ERR(pfdev->iomem);\n\t\tgoto out_pm_domain;\n\t}\n\n\terr = panfrost_gpu_init(pfdev);\n\tif (err)\n\t\tgoto out_pm_domain;\n\n\terr = panfrost_mmu_init(pfdev);\n\tif (err)\n\t\tgoto out_gpu;\n\n\terr = panfrost_job_init(pfdev);\n\tif (err)\n\t\tgoto out_mmu;\n\n\terr = panfrost_perfcnt_init(pfdev);\n\tif (err)\n\t\tgoto out_job;\n\n\treturn 0;\nout_job:\n\tpanfrost_job_fini(pfdev);\nout_mmu:\n\tpanfrost_mmu_fini(pfdev);\nout_gpu:\n\tpanfrost_gpu_fini(pfdev);\nout_pm_domain:\n\tpanfrost_pm_domain_fini(pfdev);\nout_reset:\n\tpanfrost_reset_fini(pfdev);\nout_regulator:\n\tpanfrost_regulator_fini(pfdev);\nout_devfreq:\n\tpanfrost_devfreq_fini(pfdev);\nout_clk:\n\tpanfrost_clk_fini(pfdev);\n\treturn err;\n}\n\nvoid panfrost_device_fini(struct panfrost_device *pfdev)\n{\n\tpanfrost_perfcnt_fini(pfdev);\n\tpanfrost_job_fini(pfdev);\n\tpanfrost_mmu_fini(pfdev);\n\tpanfrost_gpu_fini(pfdev);\n\tpanfrost_pm_domain_fini(pfdev);\n\tpanfrost_reset_fini(pfdev);\n\tpanfrost_devfreq_fini(pfdev);\n\tpanfrost_regulator_fini(pfdev);\n\tpanfrost_clk_fini(pfdev);\n}\n\n#define PANFROST_EXCEPTION(id) \\\n\t[DRM_PANFROST_EXCEPTION_ ## id] = { \\\n\t\t.name = #id, \\\n\t}\n\nstruct panfrost_exception_info {\n\tconst char *name;\n};\n\nstatic const struct panfrost_exception_info panfrost_exception_infos[] = {\n\tPANFROST_EXCEPTION(OK),\n\tPANFROST_EXCEPTION(DONE),\n\tPANFROST_EXCEPTION(INTERRUPTED),\n\tPANFROST_EXCEPTION(STOPPED),\n\tPANFROST_EXCEPTION(TERMINATED),\n\tPANFROST_EXCEPTION(KABOOM),\n\tPANFROST_EXCEPTION(EUREKA),\n\tPANFROST_EXCEPTION(ACTIVE),\n\tPANFROST_EXCEPTION(JOB_CONFIG_FAULT),\n\tPANFROST_EXCEPTION(JOB_POWER_FAULT),\n\tPANFROST_EXCEPTION(JOB_READ_FAULT),\n\tPANFROST_EXCEPTION(JOB_WRITE_FAULT),\n\tPANFROST_EXCEPTION(JOB_AFFINITY_FAULT),\n\tPANFROST_EXCEPTION(JOB_BUS_FAULT),\n\tPANFROST_EXCEPTION(INSTR_INVALID_PC),\n\tPANFROST_EXCEPTION(INSTR_INVALID_ENC),\n\tPANFROST_EXCEPTION(INSTR_TYPE_MISMATCH),\n\tPANFROST_EXCEPTION(INSTR_OPERAND_FAULT),\n\tPANFROST_EXCEPTION(INSTR_TLS_FAULT),\n\tPANFROST_EXCEPTION(INSTR_BARRIER_FAULT),\n\tPANFROST_EXCEPTION(INSTR_ALIGN_FAULT),\n\tPANFROST_EXCEPTION(DATA_INVALID_FAULT),\n\tPANFROST_EXCEPTION(TILE_RANGE_FAULT),\n\tPANFROST_EXCEPTION(ADDR_RANGE_FAULT),\n\tPANFROST_EXCEPTION(IMPRECISE_FAULT),\n\tPANFROST_EXCEPTION(OOM),\n\tPANFROST_EXCEPTION(OOM_AFBC),\n\tPANFROST_EXCEPTION(UNKNOWN),\n\tPANFROST_EXCEPTION(DELAYED_BUS_FAULT),\n\tPANFROST_EXCEPTION(GPU_SHAREABILITY_FAULT),\n\tPANFROST_EXCEPTION(SYS_SHAREABILITY_FAULT),\n\tPANFROST_EXCEPTION(GPU_CACHEABILITY_FAULT),\n\tPANFROST_EXCEPTION(TRANSLATION_FAULT_0),\n\tPANFROST_EXCEPTION(TRANSLATION_FAULT_1),\n\tPANFROST_EXCEPTION(TRANSLATION_FAULT_2),\n\tPANFROST_EXCEPTION(TRANSLATION_FAULT_3),\n\tPANFROST_EXCEPTION(TRANSLATION_FAULT_4),\n\tPANFROST_EXCEPTION(TRANSLATION_FAULT_IDENTITY),\n\tPANFROST_EXCEPTION(PERM_FAULT_0),\n\tPANFROST_EXCEPTION(PERM_FAULT_1),\n\tPANFROST_EXCEPTION(PERM_FAULT_2),\n\tPANFROST_EXCEPTION(PERM_FAULT_3),\n\tPANFROST_EXCEPTION(TRANSTAB_BUS_FAULT_0),\n\tPANFROST_EXCEPTION(TRANSTAB_BUS_FAULT_1),\n\tPANFROST_EXCEPTION(TRANSTAB_BUS_FAULT_2),\n\tPANFROST_EXCEPTION(TRANSTAB_BUS_FAULT_3),\n\tPANFROST_EXCEPTION(ACCESS_FLAG_0),\n\tPANFROST_EXCEPTION(ACCESS_FLAG_1),\n\tPANFROST_EXCEPTION(ACCESS_FLAG_2),\n\tPANFROST_EXCEPTION(ACCESS_FLAG_3),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_IN0),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_IN1),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_IN2),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_IN3),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_OUT0),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_OUT1),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_OUT2),\n\tPANFROST_EXCEPTION(ADDR_SIZE_FAULT_OUT3),\n\tPANFROST_EXCEPTION(MEM_ATTR_FAULT_0),\n\tPANFROST_EXCEPTION(MEM_ATTR_FAULT_1),\n\tPANFROST_EXCEPTION(MEM_ATTR_FAULT_2),\n\tPANFROST_EXCEPTION(MEM_ATTR_FAULT_3),\n\tPANFROST_EXCEPTION(MEM_ATTR_NONCACHE_0),\n\tPANFROST_EXCEPTION(MEM_ATTR_NONCACHE_1),\n\tPANFROST_EXCEPTION(MEM_ATTR_NONCACHE_2),\n\tPANFROST_EXCEPTION(MEM_ATTR_NONCACHE_3),\n};\n\nconst char *panfrost_exception_name(u32 exception_code)\n{\n\tif (WARN_ON(exception_code >= ARRAY_SIZE(panfrost_exception_infos) ||\n\t\t    !panfrost_exception_infos[exception_code].name))\n\t\treturn \"Unknown exception type\";\n\n\treturn panfrost_exception_infos[exception_code].name;\n}\n\nbool panfrost_exception_needs_reset(const struct panfrost_device *pfdev,\n\t\t\t\t    u32 exception_code)\n{\n\t \n\tif (exception_code == DRM_PANFROST_EXCEPTION_JOB_BUS_FAULT)\n\t\treturn panfrost_has_hw_issue(pfdev, HW_ISSUE_TTRX_3076);\n\n\t \n\treturn false;\n}\n\nvoid panfrost_device_reset(struct panfrost_device *pfdev)\n{\n\tpanfrost_gpu_soft_reset(pfdev);\n\n\tpanfrost_gpu_power_on(pfdev);\n\tpanfrost_mmu_reset(pfdev);\n\tpanfrost_job_enable_interrupts(pfdev);\n}\n\nstatic int panfrost_device_resume(struct device *dev)\n{\n\tstruct panfrost_device *pfdev = dev_get_drvdata(dev);\n\n\tpanfrost_device_reset(pfdev);\n\tpanfrost_devfreq_resume(pfdev);\n\n\treturn 0;\n}\n\nstatic int panfrost_device_suspend(struct device *dev)\n{\n\tstruct panfrost_device *pfdev = dev_get_drvdata(dev);\n\n\tif (!panfrost_job_is_idle(pfdev))\n\t\treturn -EBUSY;\n\n\tpanfrost_devfreq_suspend(pfdev);\n\tpanfrost_gpu_power_off(pfdev);\n\n\treturn 0;\n}\n\nEXPORT_GPL_RUNTIME_DEV_PM_OPS(panfrost_pm_ops, panfrost_device_suspend,\n\t\t\t      panfrost_device_resume, NULL);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}