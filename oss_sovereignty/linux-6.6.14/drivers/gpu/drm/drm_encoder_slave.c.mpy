{
  "module_name": "drm_encoder_slave.c",
  "hash_id": "599ff5615736b3ea3dbb29d3c7a269f56eb42540cd9c8f99c5108319065675ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_encoder_slave.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <drm/drm_encoder_slave.h>\n\n \nint drm_i2c_encoder_init(struct drm_device *dev,\n\t\t\t struct drm_encoder_slave *encoder,\n\t\t\t struct i2c_adapter *adap,\n\t\t\t const struct i2c_board_info *info)\n{\n\tstruct module *module = NULL;\n\tstruct i2c_client *client;\n\tstruct drm_i2c_encoder_driver *encoder_drv;\n\tint err = 0;\n\n\trequest_module(\"%s%s\", I2C_MODULE_PREFIX, info->type);\n\n\tclient = i2c_new_client_device(adap, info);\n\tif (!i2c_client_has_driver(client)) {\n\t\terr = -ENODEV;\n\t\tgoto fail_unregister;\n\t}\n\n\tmodule = client->dev.driver->owner;\n\tif (!try_module_get(module)) {\n\t\terr = -ENODEV;\n\t\tgoto fail_unregister;\n\t}\n\n\tencoder->bus_priv = client;\n\n\tencoder_drv = to_drm_i2c_encoder_driver(to_i2c_driver(client->dev.driver));\n\n\terr = encoder_drv->encoder_init(client, dev, encoder);\n\tif (err)\n\t\tgoto fail_module_put;\n\n\tif (info->platform_data)\n\t\tencoder->slave_funcs->set_config(&encoder->base,\n\t\t\t\t\t\t info->platform_data);\n\n\treturn 0;\n\nfail_module_put:\n\tmodule_put(module);\nfail_unregister:\n\ti2c_unregister_device(client);\n\treturn err;\n}\nEXPORT_SYMBOL(drm_i2c_encoder_init);\n\n \nvoid drm_i2c_encoder_destroy(struct drm_encoder *drm_encoder)\n{\n\tstruct drm_encoder_slave *encoder = to_encoder_slave(drm_encoder);\n\tstruct i2c_client *client = drm_i2c_encoder_get_client(drm_encoder);\n\tstruct module *module = client->dev.driver->owner;\n\n\ti2c_unregister_device(client);\n\tencoder->bus_priv = NULL;\n\n\tmodule_put(module);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_destroy);\n\n \n\nstatic inline const struct drm_encoder_slave_funcs *\nget_slave_funcs(struct drm_encoder *enc)\n{\n\treturn to_encoder_slave(enc)->slave_funcs;\n}\n\nvoid drm_i2c_encoder_dpms(struct drm_encoder *encoder, int mode)\n{\n\tget_slave_funcs(encoder)->dpms(encoder, mode);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_dpms);\n\nbool drm_i2c_encoder_mode_fixup(struct drm_encoder *encoder,\n\t\tconst struct drm_display_mode *mode,\n\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tif (!get_slave_funcs(encoder)->mode_fixup)\n\t\treturn true;\n\n\treturn get_slave_funcs(encoder)->mode_fixup(encoder, mode, adjusted_mode);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_mode_fixup);\n\nvoid drm_i2c_encoder_prepare(struct drm_encoder *encoder)\n{\n\tdrm_i2c_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_prepare);\n\nvoid drm_i2c_encoder_commit(struct drm_encoder *encoder)\n{\n\tdrm_i2c_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_commit);\n\nvoid drm_i2c_encoder_mode_set(struct drm_encoder *encoder,\n\t\tstruct drm_display_mode *mode,\n\t\tstruct drm_display_mode *adjusted_mode)\n{\n\tget_slave_funcs(encoder)->mode_set(encoder, mode, adjusted_mode);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_mode_set);\n\nenum drm_connector_status drm_i2c_encoder_detect(struct drm_encoder *encoder,\n\t    struct drm_connector *connector)\n{\n\treturn get_slave_funcs(encoder)->detect(encoder, connector);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_detect);\n\nvoid drm_i2c_encoder_save(struct drm_encoder *encoder)\n{\n\tget_slave_funcs(encoder)->save(encoder);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_save);\n\nvoid drm_i2c_encoder_restore(struct drm_encoder *encoder)\n{\n\tget_slave_funcs(encoder)->restore(encoder);\n}\nEXPORT_SYMBOL(drm_i2c_encoder_restore);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}