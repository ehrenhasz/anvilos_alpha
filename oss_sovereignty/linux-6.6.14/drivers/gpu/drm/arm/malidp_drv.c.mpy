{
  "module_name": "malidp_drv.c",
  "hash_id": "d5315dcdb163efabcbd9143721f6a80cc6cc435c9687d17476afe2905d9dbbfc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/malidp_drv.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/debugfs.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"malidp_drv.h\"\n#include \"malidp_mw.h\"\n#include \"malidp_regs.h\"\n#include \"malidp_hw.h\"\n\n#define MALIDP_CONF_VALID_TIMEOUT\t250\n#define AFBC_HEADER_SIZE\t\t16\n#define AFBC_SUPERBLK_ALIGNMENT\t\t128\n\nstatic void malidp_write_gamma_table(struct malidp_hw_device *hwdev,\n\t\t\t\t     u32 data[MALIDP_COEFFTAB_NUM_COEFFS])\n{\n\tint i;\n\t \n\tconst u32 gamma_write_mask = GENMASK(18, 16);\n\t \n\tmalidp_hw_write(hwdev, gamma_write_mask,\n\t\t\thwdev->hw->map.coeffs_base + MALIDP_COEF_TABLE_ADDR);\n\tfor (i = 0; i < MALIDP_COEFFTAB_NUM_COEFFS; ++i)\n\t\tmalidp_hw_write(hwdev, data[i],\n\t\t\t\thwdev->hw->map.coeffs_base +\n\t\t\t\tMALIDP_COEF_TABLE_DATA);\n}\n\nstatic void malidp_atomic_commit_update_gamma(struct drm_crtc *crtc,\n\t\t\t\t\t      struct drm_crtc_state *old_state)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\tif (!crtc->state->color_mgmt_changed)\n\t\treturn;\n\n\tif (!crtc->state->gamma_lut) {\n\t\tmalidp_hw_clearbits(hwdev,\n\t\t\t\t    MALIDP_DISP_FUNC_GAMMA,\n\t\t\t\t    MALIDP_DE_DISPLAY_FUNC);\n\t} else {\n\t\tstruct malidp_crtc_state *mc =\n\t\t\tto_malidp_crtc_state(crtc->state);\n\n\t\tif (!old_state->gamma_lut || (crtc->state->gamma_lut->base.id !=\n\t\t\t\t\t      old_state->gamma_lut->base.id))\n\t\t\tmalidp_write_gamma_table(hwdev, mc->gamma_coeffs);\n\n\t\tmalidp_hw_setbits(hwdev, MALIDP_DISP_FUNC_GAMMA,\n\t\t\t\t  MALIDP_DE_DISPLAY_FUNC);\n\t}\n}\n\nstatic\nvoid malidp_atomic_commit_update_coloradj(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_crtc_state *old_state)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tint i;\n\n\tif (!crtc->state->color_mgmt_changed)\n\t\treturn;\n\n\tif (!crtc->state->ctm) {\n\t\tmalidp_hw_clearbits(hwdev, MALIDP_DISP_FUNC_CADJ,\n\t\t\t\t    MALIDP_DE_DISPLAY_FUNC);\n\t} else {\n\t\tstruct malidp_crtc_state *mc =\n\t\t\tto_malidp_crtc_state(crtc->state);\n\n\t\tif (!old_state->ctm || (crtc->state->ctm->base.id !=\n\t\t\t\t\told_state->ctm->base.id))\n\t\t\tfor (i = 0; i < MALIDP_COLORADJ_NUM_COEFFS; ++i)\n\t\t\t\tmalidp_hw_write(hwdev,\n\t\t\t\t\t\tmc->coloradj_coeffs[i],\n\t\t\t\t\t\thwdev->hw->map.coeffs_base +\n\t\t\t\t\t\tMALIDP_COLOR_ADJ_COEF + 4 * i);\n\n\t\tmalidp_hw_setbits(hwdev, MALIDP_DISP_FUNC_CADJ,\n\t\t\t\t  MALIDP_DE_DISPLAY_FUNC);\n\t}\n}\n\nstatic void malidp_atomic_commit_se_config(struct drm_crtc *crtc,\n\t\t\t\t\t   struct drm_crtc_state *old_state)\n{\n\tstruct malidp_crtc_state *cs = to_malidp_crtc_state(crtc->state);\n\tstruct malidp_crtc_state *old_cs = to_malidp_crtc_state(old_state);\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tstruct malidp_se_config *s = &cs->scaler_config;\n\tstruct malidp_se_config *old_s = &old_cs->scaler_config;\n\tu32 se_control = hwdev->hw->map.se_base +\n\t\t\t ((hwdev->hw->map.features & MALIDP_REGMAP_HAS_CLEARIRQ) ?\n\t\t\t 0x10 : 0xC);\n\tu32 layer_control = se_control + MALIDP_SE_LAYER_CONTROL;\n\tu32 scr = se_control + MALIDP_SE_SCALING_CONTROL;\n\tu32 val;\n\n\t \n\tif (!s->scale_enable) {\n\t\tval = malidp_hw_read(hwdev, se_control);\n\t\tval &= ~MALIDP_SE_SCALING_EN;\n\t\tmalidp_hw_write(hwdev, val, se_control);\n\t\treturn;\n\t}\n\n\thwdev->hw->se_set_scaling_coeffs(hwdev, s, old_s);\n\tval = malidp_hw_read(hwdev, se_control);\n\tval |= MALIDP_SE_SCALING_EN | MALIDP_SE_ALPHA_EN;\n\n\tval &= ~MALIDP_SE_ENH(MALIDP_SE_ENH_MASK);\n\tval |= s->enhancer_enable ? MALIDP_SE_ENH(3) : 0;\n\n\tval |= MALIDP_SE_RGBO_IF_EN;\n\tmalidp_hw_write(hwdev, val, se_control);\n\n\t \n\tval = MALIDP_SE_SET_V_SIZE(s->input_h) |\n\t      MALIDP_SE_SET_H_SIZE(s->input_w);\n\tmalidp_hw_write(hwdev, val, layer_control + MALIDP_SE_L0_IN_SIZE);\n\tval = MALIDP_SE_SET_V_SIZE(s->output_h) |\n\t      MALIDP_SE_SET_H_SIZE(s->output_w);\n\tmalidp_hw_write(hwdev, val, layer_control + MALIDP_SE_L0_OUT_SIZE);\n\n\t \n\tmalidp_hw_write(hwdev, s->h_init_phase, scr + MALIDP_SE_H_INIT_PH);\n\tmalidp_hw_write(hwdev, s->h_delta_phase, scr + MALIDP_SE_H_DELTA_PH);\n\tmalidp_hw_write(hwdev, s->v_init_phase, scr + MALIDP_SE_V_INIT_PH);\n\tmalidp_hw_write(hwdev, s->v_delta_phase, scr + MALIDP_SE_V_DELTA_PH);\n}\n\n \nstatic int malidp_set_and_wait_config_valid(struct drm_device *drm)\n{\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tint ret;\n\n\thwdev->hw->set_config_valid(hwdev, 1);\n\t \n\tif (hwdev->hw->in_config_mode(hwdev)) {\n\t\tatomic_set(&malidp->config_valid, MALIDP_CONFIG_VALID_DONE);\n\t\treturn 0;\n\t}\n\n\tret = wait_event_interruptible_timeout(malidp->wq,\n\t\t\tatomic_read(&malidp->config_valid) == MALIDP_CONFIG_VALID_DONE,\n\t\t\tmsecs_to_jiffies(MALIDP_CONF_VALID_TIMEOUT));\n\n\treturn (ret > 0) ? 0 : -ETIMEDOUT;\n}\n\nstatic void malidp_atomic_commit_hw_done(struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = state->dev;\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tint loop = 5;\n\n\tmalidp->event = malidp->crtc.state->event;\n\tmalidp->crtc.state->event = NULL;\n\n\tif (malidp->crtc.state->active) {\n\t\t \n\t\tif (malidp->event)\n\t\t\tdrm_crtc_vblank_get(&malidp->crtc);\n\n\t\t \n\t\tif (malidp_set_and_wait_config_valid(drm) < 0) {\n\t\t\t \n\t\t\twhile (loop--) {\n\t\t\t\tif (!malidp_set_and_wait_config_valid(drm))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tDRM_DEBUG_DRIVER(\"timed out waiting for updated configuration\\n\");\n\t\t}\n\n\t} else if (malidp->event) {\n\t\t \n\t\tspin_lock_irq(&drm->event_lock);\n\t\tdrm_crtc_send_vblank_event(&malidp->crtc, malidp->event);\n\t\tmalidp->event = NULL;\n\t\tspin_unlock_irq(&drm->event_lock);\n\t}\n\tdrm_atomic_helper_commit_hw_done(state);\n}\n\nstatic void malidp_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *drm = state->dev;\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tint i;\n\tbool fence_cookie = dma_fence_begin_signalling();\n\n\tpm_runtime_get_sync(drm->dev);\n\n\t \n\tatomic_set(&malidp->config_valid, MALIDP_CONFIG_START);\n\tmalidp->dev->hw->set_config_valid(malidp->dev, 0);\n\n\tdrm_atomic_helper_commit_modeset_disables(drm, state);\n\n\tfor_each_old_crtc_in_state(state, crtc, old_crtc_state, i) {\n\t\tmalidp_atomic_commit_update_gamma(crtc, old_crtc_state);\n\t\tmalidp_atomic_commit_update_coloradj(crtc, old_crtc_state);\n\t\tmalidp_atomic_commit_se_config(crtc, old_crtc_state);\n\t}\n\n\tdrm_atomic_helper_commit_planes(drm, state, DRM_PLANE_COMMIT_ACTIVE_ONLY);\n\n\tmalidp_mw_atomic_commit(drm, state);\n\n\tdrm_atomic_helper_commit_modeset_enables(drm, state);\n\n\tmalidp_atomic_commit_hw_done(state);\n\n\tdma_fence_end_signalling(fence_cookie);\n\n\tpm_runtime_put(drm->dev);\n\n\tdrm_atomic_helper_cleanup_planes(drm, state);\n}\n\nstatic const struct drm_mode_config_helper_funcs malidp_mode_config_helpers = {\n\t.atomic_commit_tail = malidp_atomic_commit_tail,\n};\n\nstatic bool\nmalidp_verify_afbc_framebuffer_caps(struct drm_device *dev,\n\t\t\t\t    const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tif (malidp_format_mod_supported(dev, mode_cmd->pixel_format,\n\t\t\t\t\tmode_cmd->modifier[0]) == false)\n\t\treturn false;\n\n\tif (mode_cmd->offsets[0] != 0) {\n\t\tDRM_DEBUG_KMS(\"AFBC buffers' plane offset should be 0\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (mode_cmd->modifier[0] & AFBC_SIZE_MASK) {\n\tcase AFBC_SIZE_16X16:\n\t\tif ((mode_cmd->width % 16) || (mode_cmd->height % 16)) {\n\t\t\tDRM_DEBUG_KMS(\"AFBC buffers must be aligned to 16 pixels\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"Unsupported AFBC block size\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nmalidp_verify_afbc_framebuffer_size(struct drm_device *dev,\n\t\t\t\t    struct drm_file *file,\n\t\t\t\t    const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tint n_superblocks = 0;\n\tconst struct drm_format_info *info;\n\tstruct drm_gem_object *objs = NULL;\n\tu32 afbc_superblock_size = 0, afbc_superblock_height = 0;\n\tu32 afbc_superblock_width = 0, afbc_size = 0;\n\tint bpp = 0;\n\n\tswitch (mode_cmd->modifier[0] & AFBC_SIZE_MASK) {\n\tcase AFBC_SIZE_16X16:\n\t\tafbc_superblock_height = 16;\n\t\tafbc_superblock_width = 16;\n\t\tbreak;\n\tdefault:\n\t\tDRM_DEBUG_KMS(\"AFBC superblock size is not supported\\n\");\n\t\treturn false;\n\t}\n\n\tinfo = drm_get_format_info(dev, mode_cmd);\n\n\tn_superblocks = (mode_cmd->width / afbc_superblock_width) *\n\t\t(mode_cmd->height / afbc_superblock_height);\n\n\tbpp = malidp_format_get_bpp(info->format);\n\n\tafbc_superblock_size = (bpp * afbc_superblock_width * afbc_superblock_height)\n\t\t\t\t/ BITS_PER_BYTE;\n\n\tafbc_size = ALIGN(n_superblocks * AFBC_HEADER_SIZE, AFBC_SUPERBLK_ALIGNMENT);\n\tafbc_size += n_superblocks * ALIGN(afbc_superblock_size, AFBC_SUPERBLK_ALIGNMENT);\n\n\tif ((mode_cmd->width * bpp) != (mode_cmd->pitches[0] * BITS_PER_BYTE)) {\n\t\tDRM_DEBUG_KMS(\"Invalid value of (pitch * BITS_PER_BYTE) (=%u) \"\n\t\t\t      \"should be same as width (=%u) * bpp (=%u)\\n\",\n\t\t\t      (mode_cmd->pitches[0] * BITS_PER_BYTE),\n\t\t\t      mode_cmd->width, bpp);\n\t\treturn false;\n\t}\n\n\tobjs = drm_gem_object_lookup(file, mode_cmd->handles[0]);\n\tif (!objs) {\n\t\tDRM_DEBUG_KMS(\"Failed to lookup GEM object\\n\");\n\t\treturn false;\n\t}\n\n\tif (objs->size < afbc_size) {\n\t\tDRM_DEBUG_KMS(\"buffer size (%zu) too small for AFBC buffer size = %u\\n\",\n\t\t\t      objs->size, afbc_size);\n\t\tdrm_gem_object_put(objs);\n\t\treturn false;\n\t}\n\n\tdrm_gem_object_put(objs);\n\n\treturn true;\n}\n\nstatic bool\nmalidp_verify_afbc_framebuffer(struct drm_device *dev, struct drm_file *file,\n\t\t\t       const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tif (malidp_verify_afbc_framebuffer_caps(dev, mode_cmd))\n\t\treturn malidp_verify_afbc_framebuffer_size(dev, file, mode_cmd);\n\n\treturn false;\n}\n\nstatic struct drm_framebuffer *\nmalidp_fb_create(struct drm_device *dev, struct drm_file *file,\n\t\t const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tif (mode_cmd->modifier[0]) {\n\t\tif (!malidp_verify_afbc_framebuffer(dev, file, mode_cmd))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn drm_gem_fb_create(dev, file, mode_cmd);\n}\n\nstatic const struct drm_mode_config_funcs malidp_mode_config_funcs = {\n\t.fb_create = malidp_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int malidp_init(struct drm_device *drm)\n{\n\tint ret;\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\tgoto out;\n\n\tdrm->mode_config.min_width = hwdev->min_line_size;\n\tdrm->mode_config.min_height = hwdev->min_line_size;\n\tdrm->mode_config.max_width = hwdev->max_line_size;\n\tdrm->mode_config.max_height = hwdev->max_line_size;\n\tdrm->mode_config.funcs = &malidp_mode_config_funcs;\n\tdrm->mode_config.helper_private = &malidp_mode_config_helpers;\n\n\tret = malidp_crtc_init(drm);\n\tif (ret)\n\t\tgoto out;\n\n\tret = malidp_mw_connector_init(drm);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstatic int malidp_irq_init(struct platform_device *pdev)\n{\n\tint irq_de, irq_se, ret = 0;\n\tstruct drm_device *drm = dev_get_drvdata(&pdev->dev);\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\t \n\tirq_de = platform_get_irq_byname(pdev, \"DE\");\n\tif (irq_de < 0) {\n\t\tDRM_ERROR(\"no 'DE' IRQ specified!\\n\");\n\t\treturn irq_de;\n\t}\n\tirq_se = platform_get_irq_byname(pdev, \"SE\");\n\tif (irq_se < 0) {\n\t\tDRM_ERROR(\"no 'SE' IRQ specified!\\n\");\n\t\treturn irq_se;\n\t}\n\n\tret = malidp_de_irq_init(drm, irq_de);\n\tif (ret)\n\t\treturn ret;\n\n\tret = malidp_se_irq_init(drm, irq_se);\n\tif (ret) {\n\t\tmalidp_de_irq_fini(hwdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic int malidp_dumb_create(struct drm_file *file_priv,\n\t\t\t      struct drm_device *drm,\n\t\t\t      struct drm_mode_create_dumb *args)\n{\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\t \n\tu8 alignment = malidp_hw_get_pitch_align(malidp->dev, 1);\n\n\targs->pitch = ALIGN(DIV_ROUND_UP(args->width * args->bpp, 8), alignment);\n\n\treturn drm_gem_dma_dumb_create_internal(file_priv, drm, args);\n}\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void malidp_error_stats_init(struct malidp_error_stats *error_stats)\n{\n\terror_stats->num_errors = 0;\n\terror_stats->last_error_status = 0;\n\terror_stats->last_error_vblank = -1;\n}\n\nvoid malidp_error(struct malidp_drm *malidp,\n\t\t  struct malidp_error_stats *error_stats, u32 status,\n\t\t  u64 vblank)\n{\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&malidp->errors_lock, irqflags);\n\terror_stats->last_error_status = status;\n\terror_stats->last_error_vblank = vblank;\n\terror_stats->num_errors++;\n\tspin_unlock_irqrestore(&malidp->errors_lock, irqflags);\n}\n\nstatic void malidp_error_stats_dump(const char *prefix,\n\t\t\t\t    struct malidp_error_stats error_stats,\n\t\t\t\t    struct seq_file *m)\n{\n\tseq_printf(m, \"[%s] num_errors : %d\\n\", prefix,\n\t\t   error_stats.num_errors);\n\tseq_printf(m, \"[%s] last_error_status  : 0x%08x\\n\", prefix,\n\t\t   error_stats.last_error_status);\n\tseq_printf(m, \"[%s] last_error_vblank : %lld\\n\", prefix,\n\t\t   error_stats.last_error_vblank);\n}\n\nstatic int malidp_show_stats(struct seq_file *m, void *arg)\n{\n\tstruct drm_device *drm = m->private;\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tunsigned long irqflags;\n\tstruct malidp_error_stats de_errors, se_errors;\n\n\tspin_lock_irqsave(&malidp->errors_lock, irqflags);\n\tde_errors = malidp->de_errors;\n\tse_errors = malidp->se_errors;\n\tspin_unlock_irqrestore(&malidp->errors_lock, irqflags);\n\tmalidp_error_stats_dump(\"DE\", de_errors, m);\n\tmalidp_error_stats_dump(\"SE\", se_errors, m);\n\treturn 0;\n}\n\nstatic int malidp_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, malidp_show_stats, inode->i_private);\n}\n\nstatic ssize_t malidp_debugfs_write(struct file *file, const char __user *ubuf,\n\t\t\t\t    size_t len, loff_t *offp)\n{\n\tstruct seq_file *m = file->private_data;\n\tstruct drm_device *drm = m->private;\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tunsigned long irqflags;\n\n\tspin_lock_irqsave(&malidp->errors_lock, irqflags);\n\tmalidp_error_stats_init(&malidp->de_errors);\n\tmalidp_error_stats_init(&malidp->se_errors);\n\tspin_unlock_irqrestore(&malidp->errors_lock, irqflags);\n\treturn len;\n}\n\nstatic const struct file_operations malidp_debugfs_fops = {\n\t.owner = THIS_MODULE,\n\t.open = malidp_debugfs_open,\n\t.read = seq_read,\n\t.write = malidp_debugfs_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void malidp_debugfs_init(struct drm_minor *minor)\n{\n\tstruct malidp_drm *malidp = drm_to_malidp(minor->dev);\n\n\tmalidp_error_stats_init(&malidp->de_errors);\n\tmalidp_error_stats_init(&malidp->se_errors);\n\tspin_lock_init(&malidp->errors_lock);\n\tdebugfs_create_file(\"debug\", S_IRUGO | S_IWUSR, minor->debugfs_root,\n\t\t\t    minor->dev, &malidp_debugfs_fops);\n}\n\n#endif  \n\nstatic const struct drm_driver malidp_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(malidp_dumb_create),\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_init = malidp_debugfs_init,\n#endif\n\t.fops = &fops,\n\t.name = \"mali-dp\",\n\t.desc = \"ARM Mali Display Processor driver\",\n\t.date = \"20160106\",\n\t.major = 1,\n\t.minor = 0,\n};\n\nstatic const struct of_device_id  malidp_drm_of_match[] = {\n\t{\n\t\t.compatible = \"arm,mali-dp500\",\n\t\t.data = &malidp_device[MALIDP_500]\n\t},\n\t{\n\t\t.compatible = \"arm,mali-dp550\",\n\t\t.data = &malidp_device[MALIDP_550]\n\t},\n\t{\n\t\t.compatible = \"arm,mali-dp650\",\n\t\t.data = &malidp_device[MALIDP_650]\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, malidp_drm_of_match);\n\nstatic bool malidp_is_compatible_hw_id(struct malidp_hw_device *hwdev,\n\t\t\t\t       const struct of_device_id *dev_id)\n{\n\tu32 core_id;\n\tconst char *compatstr_dp500 = \"arm,mali-dp500\";\n\tbool is_dp500;\n\tbool dt_is_dp500;\n\n\t \n\tcore_id = malidp_hw_read(hwdev, MALIDP500_DC_BASE + MALIDP_DE_CORE_ID);\n\t \n\tis_dp500 = (MALIDP_PRODUCT_ID(core_id) == 0x500);\n\tdt_is_dp500 = strnstr(dev_id->compatible, compatstr_dp500,\n\t\t\t      sizeof(dev_id->compatible)) != NULL;\n\tif (is_dp500 != dt_is_dp500) {\n\t\tDRM_ERROR(\"Device-tree expects %s, but hardware %s DP500.\\n\",\n\t\t\t  dev_id->compatible, is_dp500 ? \"is\" : \"is not\");\n\t\treturn false;\n\t} else if (!dt_is_dp500) {\n\t\tu16 product_id;\n\t\tchar buf[32];\n\n\t\tcore_id = malidp_hw_read(hwdev,\n\t\t\t\t\t MALIDP550_DC_BASE + MALIDP_DE_CORE_ID);\n\t\tproduct_id = MALIDP_PRODUCT_ID(core_id);\n\t\tsnprintf(buf, sizeof(buf), \"arm,mali-dp%X\", product_id);\n\t\tif (!strnstr(dev_id->compatible, buf,\n\t\t\t     sizeof(dev_id->compatible))) {\n\t\t\tDRM_ERROR(\"Device-tree expects %s, but hardware is DP%03X.\\n\",\n\t\t\t\t  dev_id->compatible, product_id);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool malidp_has_sufficient_address_space(const struct resource *res,\n\t\t\t\t\t\tconst struct of_device_id *dev_id)\n{\n\tresource_size_t res_size = resource_size(res);\n\tconst char *compatstr_dp500 = \"arm,mali-dp500\";\n\n\tif (!strnstr(dev_id->compatible, compatstr_dp500,\n\t\t     sizeof(dev_id->compatible)))\n\t\treturn res_size >= MALIDP550_ADDR_SPACE_SIZE;\n\telse if (res_size < MALIDP500_ADDR_SPACE_SIZE)\n\t\treturn false;\n\treturn true;\n}\n\nstatic ssize_t core_id_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\n\treturn sysfs_emit(buf, \"%08x\\n\", malidp->core_id);\n}\n\nstatic DEVICE_ATTR_RO(core_id);\n\nstatic struct attribute *mali_dp_attrs[] = {\n\t&dev_attr_core_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mali_dp);\n\n#define MAX_OUTPUT_CHANNELS\t3\n\nstatic int malidp_runtime_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\t \n\tWARN_ON(!hwdev->hw->in_config_mode(hwdev));\n\n\tmalidp_se_irq_fini(hwdev);\n\tmalidp_de_irq_fini(hwdev);\n\thwdev->pm_suspended = true;\n\tclk_disable_unprepare(hwdev->mclk);\n\tclk_disable_unprepare(hwdev->aclk);\n\tclk_disable_unprepare(hwdev->pclk);\n\n\treturn 0;\n}\n\nstatic int malidp_runtime_pm_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\tclk_prepare_enable(hwdev->pclk);\n\tclk_prepare_enable(hwdev->aclk);\n\tclk_prepare_enable(hwdev->mclk);\n\thwdev->pm_suspended = false;\n\tmalidp_de_irq_hw_init(hwdev);\n\tmalidp_se_irq_hw_init(hwdev);\n\n\treturn 0;\n}\n\nstatic int malidp_bind(struct device *dev)\n{\n\tstruct resource *res;\n\tstruct drm_device *drm;\n\tstruct malidp_drm *malidp;\n\tstruct malidp_hw_device *hwdev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct of_device_id const *dev_id;\n\tstruct drm_encoder *encoder;\n\t \n\tu8 output_width[MAX_OUTPUT_CHANNELS];\n\tint ret = 0, i;\n\tu32 version, out_depth = 0;\n\n\tmalidp = devm_drm_dev_alloc(dev, &malidp_driver, typeof(*malidp), base);\n\tif (IS_ERR(malidp))\n\t\treturn PTR_ERR(malidp);\n\n\tdrm = &malidp->base;\n\n\thwdev = drmm_kzalloc(drm, sizeof(*hwdev), GFP_KERNEL);\n\tif (!hwdev)\n\t\treturn -ENOMEM;\n\n\thwdev->hw = (struct malidp_hw *)of_device_get_match_data(dev);\n\tmalidp->dev = hwdev;\n\n\thwdev->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hwdev->regs))\n\t\treturn PTR_ERR(hwdev->regs);\n\n\thwdev->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(hwdev->pclk))\n\t\treturn PTR_ERR(hwdev->pclk);\n\n\thwdev->aclk = devm_clk_get(dev, \"aclk\");\n\tif (IS_ERR(hwdev->aclk))\n\t\treturn PTR_ERR(hwdev->aclk);\n\n\thwdev->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(hwdev->mclk))\n\t\treturn PTR_ERR(hwdev->mclk);\n\n\thwdev->pxlclk = devm_clk_get(dev, \"pxlclk\");\n\tif (IS_ERR(hwdev->pxlclk))\n\t\treturn PTR_ERR(hwdev->pxlclk);\n\n\t \n\tret = of_reserved_mem_device_init(dev);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, drm);\n\n\t \n\tpm_runtime_enable(dev);\n\n\t \n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_get_sync(dev);\n\telse\n\t\tmalidp_runtime_pm_resume(dev);\n\n\tdev_id = of_match_device(malidp_drm_of_match, dev);\n\tif (!dev_id) {\n\t\tret = -EINVAL;\n\t\tgoto query_hw_fail;\n\t}\n\n\tif (!malidp_has_sufficient_address_space(res, dev_id)) {\n\t\tDRM_ERROR(\"Insufficient address space in device-tree.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto query_hw_fail;\n\t}\n\n\tif (!malidp_is_compatible_hw_id(hwdev, dev_id)) {\n\t\tret = -EINVAL;\n\t\tgoto query_hw_fail;\n\t}\n\n\tret = hwdev->hw->query_hw(hwdev);\n\tif (ret) {\n\t\tDRM_ERROR(\"Invalid HW configuration\\n\");\n\t\tgoto query_hw_fail;\n\t}\n\n\tversion = malidp_hw_read(hwdev, hwdev->hw->map.dc_base + MALIDP_DE_CORE_ID);\n\tDRM_INFO(\"found ARM Mali-DP%3x version r%dp%d\\n\", version >> 16,\n\t\t (version >> 12) & 0xf, (version >> 8) & 0xf);\n\n\tmalidp->core_id = version;\n\n\tret = of_property_read_u32(dev->of_node,\n\t\t\t\t\t\"arm,malidp-arqos-value\",\n\t\t\t\t\t&hwdev->arqos_value);\n\tif (ret)\n\t\thwdev->arqos_value = 0x0;\n\n\t \n\tret = of_property_read_u8_array(dev->of_node,\n\t\t\t\t\t\"arm,malidp-output-port-lines\",\n\t\t\t\t\toutput_width, MAX_OUTPUT_CHANNELS);\n\tif (ret)\n\t\tgoto query_hw_fail;\n\n\tfor (i = 0; i < MAX_OUTPUT_CHANNELS; i++)\n\t\tout_depth = (out_depth << 8) | (output_width[i] & 0xf);\n\tmalidp_hw_write(hwdev, out_depth, hwdev->hw->map.out_depth_base);\n\thwdev->output_color_depth = out_depth;\n\n\tatomic_set(&malidp->config_valid, MALIDP_CONFIG_VALID_INIT);\n\tinit_waitqueue_head(&malidp->wq);\n\n\tret = malidp_init(drm);\n\tif (ret < 0)\n\t\tgoto query_hw_fail;\n\n\t \n\tmalidp->crtc.port = of_graph_get_port_by_id(dev->of_node, 0);\n\n\tret = component_bind_all(dev, drm);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to bind all components\\n\");\n\t\tgoto bind_fail;\n\t}\n\n\t \n\tWARN_ON(drm->mode_config.num_encoder > 2);\n\tlist_for_each_entry(encoder, &drm->mode_config.encoder_list, head) {\n\t\tencoder->possible_clones =\n\t\t\t\t(1 << drm->mode_config.num_encoder) -  1;\n\t}\n\n\tret = malidp_irq_init(pdev);\n\tif (ret < 0)\n\t\tgoto irq_init_fail;\n\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to initialise vblank\\n\");\n\t\tgoto vblank_fail;\n\t}\n\tpm_runtime_put(dev);\n\n\tdrm_mode_config_reset(drm);\n\n\tdrm_kms_helper_poll_init(drm);\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto register_fail;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn 0;\n\nregister_fail:\n\tdrm_kms_helper_poll_fini(drm);\n\tpm_runtime_get_sync(dev);\nvblank_fail:\n\tmalidp_se_irq_fini(hwdev);\n\tmalidp_de_irq_fini(hwdev);\nirq_init_fail:\n\tdrm_atomic_helper_shutdown(drm);\n\tcomponent_unbind_all(dev, drm);\nbind_fail:\n\tof_node_put(malidp->crtc.port);\n\tmalidp->crtc.port = NULL;\nquery_hw_fail:\n\tpm_runtime_put(dev);\n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\telse\n\t\tmalidp_runtime_pm_suspend(dev);\n\tdev_set_drvdata(dev, NULL);\n\tof_reserved_mem_device_release(dev);\n\n\treturn ret;\n}\n\nstatic void malidp_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tpm_runtime_get_sync(dev);\n\tdrm_atomic_helper_shutdown(drm);\n\tmalidp_se_irq_fini(hwdev);\n\tmalidp_de_irq_fini(hwdev);\n\tcomponent_unbind_all(dev, drm);\n\tof_node_put(malidp->crtc.port);\n\tmalidp->crtc.port = NULL;\n\tpm_runtime_put(dev);\n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\telse\n\t\tmalidp_runtime_pm_suspend(dev);\n\tdev_set_drvdata(dev, NULL);\n\tof_reserved_mem_device_release(dev);\n}\n\nstatic const struct component_master_ops malidp_master_ops = {\n\t.bind = malidp_bind,\n\t.unbind = malidp_unbind,\n};\n\nstatic int malidp_compare_dev(struct device *dev, void *data)\n{\n\tstruct device_node *np = data;\n\n\treturn dev->of_node == np;\n}\n\nstatic int malidp_platform_probe(struct platform_device *pdev)\n{\n\tstruct device_node *port;\n\tstruct component_match *match = NULL;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\t \n\tport = of_graph_get_remote_node(pdev->dev.of_node, 0, 0);\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tdrm_of_component_match_add(&pdev->dev, &match, malidp_compare_dev,\n\t\t\t\t   port);\n\tof_node_put(port);\n\treturn component_master_add_with_match(&pdev->dev, &malidp_master_ops,\n\t\t\t\t\t       match);\n}\n\nstatic void malidp_platform_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &malidp_master_ops);\n}\n\nstatic int __maybe_unused malidp_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm);\n}\n\nstatic int __maybe_unused malidp_pm_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_mode_config_helper_resume(drm);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused malidp_pm_suspend_late(struct device *dev)\n{\n\tif (!pm_runtime_status_suspended(dev)) {\n\t\tmalidp_runtime_pm_suspend(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused malidp_pm_resume_early(struct device *dev)\n{\n\tmalidp_runtime_pm_resume(dev);\n\tpm_runtime_set_active(dev);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops malidp_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(malidp_pm_suspend, malidp_pm_resume) \\\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(malidp_pm_suspend_late, malidp_pm_resume_early) \\\n\tSET_RUNTIME_PM_OPS(malidp_runtime_pm_suspend, malidp_runtime_pm_resume, NULL)\n};\n\nstatic struct platform_driver malidp_platform_driver = {\n\t.probe\t\t= malidp_platform_probe,\n\t.remove_new\t= malidp_platform_remove,\n\t.driver\t= {\n\t\t.name = \"mali-dp\",\n\t\t.pm = &malidp_pm_ops,\n\t\t.of_match_table\t= malidp_drm_of_match,\n\t\t.dev_groups = mali_dp_groups,\n\t},\n};\n\ndrm_module_platform_driver(malidp_platform_driver);\n\nMODULE_AUTHOR(\"Liviu Dudau <Liviu.Dudau@arm.com>\");\nMODULE_DESCRIPTION(\"ARM Mali DP DRM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}