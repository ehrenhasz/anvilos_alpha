{
  "module_name": "malidp_mw.c",
  "hash_id": "e74f8f6e231d92a311901eb9eca4beddd34a740213b576238461aeed20d48612",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/malidp_mw.c",
  "human_readable_source": "\n \n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_fourcc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_writeback.h>\n\n#include \"malidp_drv.h\"\n#include \"malidp_hw.h\"\n#include \"malidp_mw.h\"\n\n#define to_mw_state(_state) (struct malidp_mw_connector_state *)(_state)\n\nstruct malidp_mw_connector_state {\n\tstruct drm_connector_state base;\n\tdma_addr_t addrs[2];\n\ts32 pitches[2];\n\tu8 format;\n\tu8 n_planes;\n\tbool rgb2yuv_initialized;\n\tconst s16 *rgb2yuv_coeffs;\n};\n\nstatic int malidp_mw_connector_get_modes(struct drm_connector *connector)\n{\n\tstruct drm_device *dev = connector->dev;\n\n\treturn drm_add_modes_noedid(connector, dev->mode_config.max_width,\n\t\t\t\t    dev->mode_config.max_height);\n}\n\nstatic enum drm_mode_status\nmalidp_mw_connector_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tint w = mode->hdisplay, h = mode->vdisplay;\n\n\tif ((w < mode_config->min_width) || (w > mode_config->max_width))\n\t\treturn MODE_BAD_HVALUE;\n\n\tif ((h < mode_config->min_height) || (h > mode_config->max_height))\n\t\treturn MODE_BAD_VVALUE;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs malidp_mw_connector_helper_funcs = {\n\t.get_modes = malidp_mw_connector_get_modes,\n\t.mode_valid = malidp_mw_connector_mode_valid,\n};\n\nstatic void malidp_mw_connector_reset(struct drm_connector *connector)\n{\n\tstruct malidp_mw_connector_state *mw_state =\n\t\tkzalloc(sizeof(*mw_state), GFP_KERNEL);\n\n\tif (connector->state)\n\t\t__drm_atomic_helper_connector_destroy_state(connector->state);\n\n\tkfree(connector->state);\n\t__drm_atomic_helper_connector_reset(connector, &mw_state->base);\n}\n\nstatic enum drm_connector_status\nmalidp_mw_connector_detect(struct drm_connector *connector, bool force)\n{\n\treturn connector_status_connected;\n}\n\nstatic void malidp_mw_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_cleanup(connector);\n}\n\nstatic struct drm_connector_state *\nmalidp_mw_connector_duplicate_state(struct drm_connector *connector)\n{\n\tstruct malidp_mw_connector_state *mw_state, *mw_current_state;\n\n\tif (WARN_ON(!connector->state))\n\t\treturn NULL;\n\n\tmw_state = kzalloc(sizeof(*mw_state), GFP_KERNEL);\n\tif (!mw_state)\n\t\treturn NULL;\n\n\tmw_current_state = to_mw_state(connector->state);\n\tmw_state->rgb2yuv_coeffs = mw_current_state->rgb2yuv_coeffs;\n\tmw_state->rgb2yuv_initialized = mw_current_state->rgb2yuv_initialized;\n\n\t__drm_atomic_helper_connector_duplicate_state(connector, &mw_state->base);\n\n\treturn &mw_state->base;\n}\n\nstatic const struct drm_connector_funcs malidp_mw_connector_funcs = {\n\t.reset = malidp_mw_connector_reset,\n\t.detect = malidp_mw_connector_detect,\n\t.fill_modes = drm_helper_probe_single_connector_modes,\n\t.destroy = malidp_mw_connector_destroy,\n\t.atomic_duplicate_state = malidp_mw_connector_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,\n};\n\nstatic const s16 rgb2yuv_coeffs_bt709_limited[MALIDP_COLORADJ_NUM_COEFFS] = {\n\t47,  157,   16,\n\t-26,  -87,  112,\n\t112, -102,  -10,\n\t16,  128,  128\n};\n\nstatic int\nmalidp_mw_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t       struct drm_crtc_state *crtc_state,\n\t\t\t       struct drm_connector_state *conn_state)\n{\n\tstruct malidp_mw_connector_state *mw_state = to_mw_state(conn_state);\n\tstruct malidp_drm *malidp = drm_to_malidp(encoder->dev);\n\tstruct drm_framebuffer *fb;\n\tint i, n_planes;\n\n\tif (!conn_state->writeback_job)\n\t\treturn 0;\n\n\tfb = conn_state->writeback_job->fb;\n\tif ((fb->width != crtc_state->mode.hdisplay) ||\n\t    (fb->height != crtc_state->mode.vdisplay)) {\n\t\tDRM_DEBUG_KMS(\"Invalid framebuffer size %ux%u\\n\",\n\t\t\t\tfb->width, fb->height);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fb->modifier) {\n\t\tDRM_DEBUG_KMS(\"Writeback framebuffer does not support modifiers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmw_state->format =\n\t\tmalidp_hw_get_format_id(&malidp->dev->hw->map, SE_MEMWRITE,\n\t\t\t\t\tfb->format->format, !!fb->modifier);\n\tif (mw_state->format == MALIDP_INVALID_FORMAT_ID) {\n\t\tDRM_DEBUG_KMS(\"Invalid pixel format %p4cc\\n\",\n\t\t\t      &fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\tn_planes = fb->format->num_planes;\n\tfor (i = 0; i < n_planes; i++) {\n\t\tstruct drm_gem_dma_object *obj = drm_fb_dma_get_gem_obj(fb, i);\n\t\t \n\t\tu8 alignment = malidp_hw_get_pitch_align(malidp->dev, 0);\n\n\t\tif (fb->pitches[i] & (alignment - 1)) {\n\t\t\tDRM_DEBUG_KMS(\"Invalid pitch %u for plane %d\\n\",\n\t\t\t\t      fb->pitches[i], i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmw_state->pitches[i] = fb->pitches[i];\n\t\tmw_state->addrs[i] = obj->dma_addr + fb->offsets[i];\n\t}\n\tmw_state->n_planes = n_planes;\n\n\tif (fb->format->is_yuv)\n\t\tmw_state->rgb2yuv_coeffs = rgb2yuv_coeffs_bt709_limited;\n\n\treturn 0;\n}\n\nstatic const struct drm_encoder_helper_funcs malidp_mw_encoder_helper_funcs = {\n\t.atomic_check = malidp_mw_encoder_atomic_check,\n};\n\nstatic u32 *get_writeback_formats(struct malidp_drm *malidp, int *n_formats)\n{\n\tconst struct malidp_hw_regmap *map = &malidp->dev->hw->map;\n\tu32 *formats;\n\tint n, i;\n\n\tformats = kcalloc(map->n_pixel_formats, sizeof(*formats),\n\t\t\t  GFP_KERNEL);\n\tif (!formats)\n\t\treturn NULL;\n\n\tfor (n = 0, i = 0;  i < map->n_pixel_formats; i++) {\n\t\tif (map->pixel_formats[i].layer & SE_MEMWRITE)\n\t\t\tformats[n++] = map->pixel_formats[i].format;\n\t}\n\n\t*n_formats = n;\n\n\treturn formats;\n}\n\nint malidp_mw_connector_init(struct drm_device *drm)\n{\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tu32 *formats;\n\tint ret, n_formats;\n\n\tif (!malidp->dev->hw->enable_memwrite)\n\t\treturn 0;\n\n\tdrm_connector_helper_add(&malidp->mw_connector.base,\n\t\t\t\t &malidp_mw_connector_helper_funcs);\n\n\tformats = get_writeback_formats(malidp, &n_formats);\n\tif (!formats)\n\t\treturn -ENOMEM;\n\n\tret = drm_writeback_connector_init(drm, &malidp->mw_connector,\n\t\t\t\t\t   &malidp_mw_connector_funcs,\n\t\t\t\t\t   &malidp_mw_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats,\n\t\t\t\t\t   1 << drm_crtc_index(&malidp->crtc));\n\tkfree(formats);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid malidp_mw_atomic_commit(struct drm_device *drm,\n\t\t\t     struct drm_atomic_state *old_state)\n{\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct drm_writeback_connector *mw_conn = &malidp->mw_connector;\n\tstruct drm_connector_state *conn_state = mw_conn->base.state;\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tstruct malidp_mw_connector_state *mw_state;\n\n\tif (!conn_state)\n\t\treturn;\n\n\tmw_state = to_mw_state(conn_state);\n\n\tif (conn_state->writeback_job) {\n\t\tstruct drm_framebuffer *fb = conn_state->writeback_job->fb;\n\n\t\tDRM_DEV_DEBUG_DRIVER(drm->dev,\n\t\t\t\t     \"Enable memwrite %ux%u:%d %pad fmt: %u\\n\",\n\t\t\t\t     fb->width, fb->height,\n\t\t\t\t     mw_state->pitches[0],\n\t\t\t\t     &mw_state->addrs[0],\n\t\t\t\t     mw_state->format);\n\n\t\tdrm_writeback_queue_job(mw_conn, conn_state);\n\t\thwdev->hw->enable_memwrite(hwdev, mw_state->addrs,\n\t\t\t\t\t   mw_state->pitches, mw_state->n_planes,\n\t\t\t\t\t   fb->width, fb->height, mw_state->format,\n\t\t\t\t\t   !mw_state->rgb2yuv_initialized ?\n\t\t\t\t\t   mw_state->rgb2yuv_coeffs : NULL);\n\t\tmw_state->rgb2yuv_initialized = !!mw_state->rgb2yuv_coeffs;\n\t} else {\n\t\tDRM_DEV_DEBUG_DRIVER(drm->dev, \"Disable memwrite\\n\");\n\t\thwdev->hw->disable_memwrite(hwdev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}