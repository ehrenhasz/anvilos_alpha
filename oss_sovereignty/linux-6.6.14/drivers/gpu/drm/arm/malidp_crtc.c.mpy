{
  "module_name": "malidp_crtc.c",
  "hash_id": "aa53e3ac79c48a2f9018488a4c885854afbbd78fc05f4df8ac95190da1858c02",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/malidp_crtc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n\n#include <video/videomode.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_print.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"malidp_drv.h\"\n#include \"malidp_hw.h\"\n\nstatic enum drm_mode_status malidp_crtc_mode_valid(struct drm_crtc *crtc,\n\t\t\t\t\t\t   const struct drm_display_mode *mode)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\t \n\tlong rate, req_rate = mode->crtc_clock * 1000;\n\n\tif (req_rate) {\n\t\trate = clk_round_rate(hwdev->pxlclk, req_rate);\n\t\tif (rate != req_rate) {\n\t\t\tDRM_DEBUG_DRIVER(\"pxlclk doesn't support %ld Hz\\n\",\n\t\t\t\t\t req_rate);\n\t\t\treturn MODE_NOCLOCK;\n\t\t}\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic void malidp_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tstruct videomode vm;\n\tint err = pm_runtime_get_sync(crtc->dev->dev);\n\n\tif (err < 0) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to enable runtime power management: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tdrm_display_mode_to_videomode(&crtc->state->adjusted_mode, &vm);\n\tclk_prepare_enable(hwdev->pxlclk);\n\n\t \n\tclk_set_rate(hwdev->pxlclk, crtc->state->adjusted_mode.crtc_clock * 1000);\n\n\thwdev->hw->modeset(hwdev, &vm);\n\thwdev->hw->leave_config_mode(hwdev);\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void malidp_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old_state = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t\t crtc);\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tint err;\n\n\t \n\tdrm_atomic_helper_disable_planes_on_crtc(old_state, false);\n\n\tdrm_crtc_vblank_off(crtc);\n\thwdev->hw->enter_config_mode(hwdev);\n\n\tclk_disable_unprepare(hwdev->pxlclk);\n\n\terr = pm_runtime_put(crtc->dev->dev);\n\tif (err < 0) {\n\t\tDRM_DEBUG_DRIVER(\"Failed to disable runtime power management: %d\\n\", err);\n\t}\n}\n\nstatic const struct gamma_curve_segment {\n\tu16 start;\n\tu16 end;\n} segments[MALIDP_COEFFTAB_NUM_COEFFS] = {\n\t \n\t{    0,    0 }, {    1,    1 }, {    2,    2 }, {    3,    3 },\n\t{    4,    4 }, {    5,    5 }, {    6,    6 }, {    7,    7 },\n\t{    8,    8 }, {    9,    9 }, {   10,   10 }, {   11,   11 },\n\t{   12,   12 }, {   13,   13 }, {   14,   14 }, {   15,   15 },\n\t \n\t{   16,   19 }, {   20,   23 }, {   24,   27 }, {   28,   31 },\n\t \n\t{   32,   39 }, {   40,   47 }, {   48,   55 }, {   56,   63 },\n\t \n\t{   64,   79 }, {   80,   95 }, {   96,  111 }, {  112,  127 },\n\t \n\t{  128,  159 }, {  160,  191 }, {  192,  223 }, {  224,  255 },\n\t \n\t{  256,  319 }, {  320,  383 }, {  384,  447 }, {  448,  511 },\n\t \n\t{  512,  639 }, {  640,  767 }, {  768,  895 }, {  896, 1023 },\n\t{ 1024, 1151 }, { 1152, 1279 }, { 1280, 1407 }, { 1408, 1535 },\n\t{ 1536, 1663 }, { 1664, 1791 }, { 1792, 1919 }, { 1920, 2047 },\n\t{ 2048, 2175 }, { 2176, 2303 }, { 2304, 2431 }, { 2432, 2559 },\n\t{ 2560, 2687 }, { 2688, 2815 }, { 2816, 2943 }, { 2944, 3071 },\n\t{ 3072, 3199 }, { 3200, 3327 }, { 3328, 3455 }, { 3456, 3583 },\n\t{ 3584, 3711 }, { 3712, 3839 }, { 3840, 3967 }, { 3968, 4095 },\n};\n\n#define DE_COEFTAB_DATA(a, b) ((((a) & 0xfff) << 16) | (((b) & 0xfff)))\n\nstatic void malidp_generate_gamma_table(struct drm_property_blob *lut_blob,\n\t\t\t\t\tu32 coeffs[MALIDP_COEFFTAB_NUM_COEFFS])\n{\n\tstruct drm_color_lut *lut = (struct drm_color_lut *)lut_blob->data;\n\tint i;\n\n\tfor (i = 0; i < MALIDP_COEFFTAB_NUM_COEFFS; ++i) {\n\t\tu32 a, b, delta_in, out_start, out_end;\n\n\t\tdelta_in = segments[i].end - segments[i].start;\n\t\t \n\t\tout_start = drm_color_lut_extract(lut[segments[i].start].green,\n\t\t\t\t\t\t  12);\n\t\tout_end = drm_color_lut_extract(lut[segments[i].end].green, 12);\n\t\ta = (delta_in == 0) ? 0 : ((out_end - out_start) * 256) / delta_in;\n\t\tb = out_start;\n\t\tcoeffs[i] = DE_COEFTAB_DATA(a, b);\n\t}\n}\n\n \nstatic int malidp_crtc_atomic_check_gamma(struct drm_crtc *crtc,\n\t\t\t\t\t  struct drm_crtc_state *state)\n{\n\tstruct malidp_crtc_state *mc = to_malidp_crtc_state(state);\n\tstruct drm_color_lut *lut;\n\tsize_t lut_size;\n\tint i;\n\n\tif (!state->color_mgmt_changed || !state->gamma_lut)\n\t\treturn 0;\n\n\tif (crtc->state->gamma_lut &&\n\t    (crtc->state->gamma_lut->base.id == state->gamma_lut->base.id))\n\t\treturn 0;\n\n\tif (state->gamma_lut->length % sizeof(struct drm_color_lut))\n\t\treturn -EINVAL;\n\n\tlut_size = state->gamma_lut->length / sizeof(struct drm_color_lut);\n\tif (lut_size != MALIDP_GAMMA_LUT_SIZE)\n\t\treturn -EINVAL;\n\n\tlut = (struct drm_color_lut *)state->gamma_lut->data;\n\tfor (i = 0; i < lut_size; ++i)\n\t\tif (!((lut[i].red == lut[i].green) &&\n\t\t      (lut[i].red == lut[i].blue)))\n\t\t\treturn -EINVAL;\n\n\tif (!state->mode_changed) {\n\t\tint ret;\n\n\t\tstate->mode_changed = true;\n\t\t \n\t\tret = drm_atomic_helper_check_modeset(crtc->dev, state->state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmalidp_generate_gamma_table(state->gamma_lut, mc->gamma_coeffs);\n\treturn 0;\n}\n\n \nstatic int malidp_crtc_atomic_check_ctm(struct drm_crtc *crtc,\n\t\t\t\t\tstruct drm_crtc_state *state)\n{\n\tstruct malidp_crtc_state *mc = to_malidp_crtc_state(state);\n\tstruct drm_color_ctm *ctm;\n\tint i;\n\n\tif (!state->color_mgmt_changed)\n\t\treturn 0;\n\n\tif (!state->ctm)\n\t\treturn 0;\n\n\tif (crtc->state->ctm && (crtc->state->ctm->base.id ==\n\t\t\t\t state->ctm->base.id))\n\t\treturn 0;\n\n\t \n\tctm = (struct drm_color_ctm *)state->ctm->data;\n\tfor (i = 0; i < ARRAY_SIZE(ctm->matrix); ++i) {\n\t\t \n\t\ts64 val = ctm->matrix[i];\n\t\tu32 mag = ((((u64)val) & ~BIT_ULL(63)) >> 20) &\n\t\t\t  GENMASK_ULL(14, 0);\n\n\t\t \n\t\tif (val & BIT_ULL(63))\n\t\t\tmag = ~mag + 1;\n\t\tif (!!(val & BIT_ULL(63)) != !!(mag & BIT(14)))\n\t\t\treturn -EINVAL;\n\t\tmc->coloradj_coeffs[i] = mag;\n\t}\n\n\treturn 0;\n}\n\nstatic int malidp_crtc_atomic_check_scaling(struct drm_crtc *crtc,\n\t\t\t\t\t    struct drm_crtc_state *state)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tstruct malidp_crtc_state *cs = to_malidp_crtc_state(state);\n\tstruct malidp_se_config *s = &cs->scaler_config;\n\tstruct drm_plane *plane;\n\tstruct videomode vm;\n\tconst struct drm_plane_state *pstate;\n\tu32 h_upscale_factor = 0;  \n\tu32 v_upscale_factor = 0;  \n\tu8 scaling = cs->scaled_planes_mask;\n\tint ret;\n\n\tif (!scaling) {\n\t\ts->scale_enable = false;\n\t\tgoto mclk_calc;\n\t}\n\n\t \n\tif (scaling & (scaling - 1))\n\t\treturn -EINVAL;\n\n\tdrm_atomic_crtc_state_for_each_plane_state(plane, pstate, state) {\n\t\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\t\tu32 phase;\n\n\t\tif (!(mp->layer->id & scaling))\n\t\t\tcontinue;\n\n\t\t \n\t\th_upscale_factor = div_u64((u64)pstate->crtc_w << 32,\n\t\t\t\t\t   pstate->src_w);\n\t\tv_upscale_factor = div_u64((u64)pstate->crtc_h << 32,\n\t\t\t\t\t   pstate->src_h);\n\n\t\ts->enhancer_enable = ((h_upscale_factor >> 16) >= 2 ||\n\t\t\t\t      (v_upscale_factor >> 16) >= 2);\n\n\t\tif (pstate->rotation & MALIDP_ROTATED_MASK) {\n\t\t\ts->input_w = pstate->src_h >> 16;\n\t\t\ts->input_h = pstate->src_w >> 16;\n\t\t} else {\n\t\t\ts->input_w = pstate->src_w >> 16;\n\t\t\ts->input_h = pstate->src_h >> 16;\n\t\t}\n\n\t\ts->output_w = pstate->crtc_w;\n\t\ts->output_h = pstate->crtc_h;\n\n#define SE_N_PHASE 4\n#define SE_SHIFT_N_PHASE 12\n\t\t \n\t\tphase = s->input_w;\n\t\ts->h_init_phase =\n\t\t\t\t((phase << SE_N_PHASE) / s->output_w + 1) / 2;\n\n\t\tphase = s->input_w;\n\t\tphase <<= (SE_SHIFT_N_PHASE + SE_N_PHASE);\n\t\ts->h_delta_phase = phase / s->output_w;\n\n\t\t \n\t\tphase = s->input_h;\n\t\ts->v_init_phase =\n\t\t\t\t((phase << SE_N_PHASE) / s->output_h + 1) / 2;\n\n\t\tphase = s->input_h;\n\t\tphase <<= (SE_SHIFT_N_PHASE + SE_N_PHASE);\n\t\ts->v_delta_phase = phase / s->output_h;\n#undef SE_N_PHASE\n#undef SE_SHIFT_N_PHASE\n\t\ts->plane_src_id = mp->layer->id;\n\t}\n\n\ts->scale_enable = true;\n\ts->hcoeff = malidp_se_select_coeffs(h_upscale_factor);\n\ts->vcoeff = malidp_se_select_coeffs(v_upscale_factor);\n\nmclk_calc:\n\tdrm_display_mode_to_videomode(&state->adjusted_mode, &vm);\n\tret = hwdev->hw->se_calc_mclk(hwdev, s, &vm);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int malidp_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\tstruct drm_plane *plane;\n\tconst struct drm_plane_state *pstate;\n\tu32 rot_mem_free, rot_mem_usable;\n\tint rotated_planes = 0;\n\tint ret;\n\n\t \n\n\t \n\tdrm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) {\n\t\tstruct drm_framebuffer *fb = pstate->fb;\n\n\t\tif ((pstate->rotation & MALIDP_ROTATED_MASK) || fb->modifier)\n\t\t\trotated_planes++;\n\t}\n\n\trot_mem_free = hwdev->rotation_memory[0];\n\t \n\tif (rotated_planes > 1)\n\t\trot_mem_free += hwdev->rotation_memory[1];\n\n\t \n\tdrm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) {\n\t\tstruct malidp_plane *mp = to_malidp_plane(plane);\n\t\tstruct malidp_plane_state *ms = to_malidp_plane_state(pstate);\n\t\tstruct drm_framebuffer *fb = pstate->fb;\n\n\t\tif ((pstate->rotation & MALIDP_ROTATED_MASK) || fb->modifier) {\n\t\t\t \n\t\t\trotated_planes--;\n\n\t\t\tif (!rotated_planes) {\n\t\t\t\t \n\t\t\t\trot_mem_usable = rot_mem_free;\n\t\t\t} else {\n\t\t\t\tif ((mp->layer->id != DE_VIDEO1) ||\n\t\t\t\t    (hwdev->rotation_memory[1] == 0))\n\t\t\t\t\trot_mem_usable = rot_mem_free / 2;\n\t\t\t\telse\n\t\t\t\t\trot_mem_usable = hwdev->rotation_memory[0];\n\t\t\t}\n\n\t\t\trot_mem_free -= rot_mem_usable;\n\n\t\t\tif (ms->rotmem_size > rot_mem_usable)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (crtc_state->connectors_changed) {\n\t\tu32 old_mask = crtc->state->connector_mask;\n\t\tu32 new_mask = crtc_state->connector_mask;\n\n\t\tif ((old_mask ^ new_mask) ==\n\t\t    (1 << drm_connector_index(&malidp->mw_connector.base)))\n\t\t\tcrtc_state->connectors_changed = false;\n\t}\n\n\tret = malidp_crtc_atomic_check_gamma(crtc, crtc_state);\n\tret = ret ? ret : malidp_crtc_atomic_check_ctm(crtc, crtc_state);\n\tret = ret ? ret : malidp_crtc_atomic_check_scaling(crtc, crtc_state);\n\n\treturn ret;\n}\n\nstatic const struct drm_crtc_helper_funcs malidp_crtc_helper_funcs = {\n\t.mode_valid = malidp_crtc_mode_valid,\n\t.atomic_check = malidp_crtc_atomic_check,\n\t.atomic_enable = malidp_crtc_atomic_enable,\n\t.atomic_disable = malidp_crtc_atomic_disable,\n};\n\nstatic struct drm_crtc_state *malidp_crtc_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct malidp_crtc_state *state, *old_state;\n\n\tif (WARN_ON(!crtc->state))\n\t\treturn NULL;\n\n\told_state = to_malidp_crtc_state(crtc->state);\n\tstate = kmalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &state->base);\n\tmemcpy(state->gamma_coeffs, old_state->gamma_coeffs,\n\t       sizeof(state->gamma_coeffs));\n\tmemcpy(state->coloradj_coeffs, old_state->coloradj_coeffs,\n\t       sizeof(state->coloradj_coeffs));\n\tmemcpy(&state->scaler_config, &old_state->scaler_config,\n\t       sizeof(state->scaler_config));\n\tstate->scaled_planes_mask = 0;\n\n\treturn &state->base;\n}\n\nstatic void malidp_crtc_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_crtc_state *state)\n{\n\tstruct malidp_crtc_state *mali_state = NULL;\n\n\tif (state) {\n\t\tmali_state = to_malidp_crtc_state(state);\n\t\t__drm_atomic_helper_crtc_destroy_state(state);\n\t}\n\n\tkfree(mali_state);\n}\n\nstatic void malidp_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct malidp_crtc_state *state =\n\t\tkzalloc(sizeof(*state), GFP_KERNEL);\n\n\tif (crtc->state)\n\t\tmalidp_crtc_destroy_state(crtc, crtc->state);\n\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n\telse\n\t\t__drm_atomic_helper_crtc_reset(crtc, NULL);\n}\n\nstatic int malidp_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\tmalidp_hw_enable_irq(hwdev, MALIDP_DE_BLOCK,\n\t\t\t     hwdev->hw->map.de_irq_map.vsync_irq);\n\treturn 0;\n}\n\nstatic void malidp_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct malidp_drm *malidp = crtc_to_malidp_device(crtc);\n\tstruct malidp_hw_device *hwdev = malidp->dev;\n\n\tmalidp_hw_disable_irq(hwdev, MALIDP_DE_BLOCK,\n\t\t\t      hwdev->hw->map.de_irq_map.vsync_irq);\n}\n\nstatic const struct drm_crtc_funcs malidp_crtc_funcs = {\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = malidp_crtc_reset,\n\t.atomic_duplicate_state = malidp_crtc_duplicate_state,\n\t.atomic_destroy_state = malidp_crtc_destroy_state,\n\t.enable_vblank = malidp_crtc_enable_vblank,\n\t.disable_vblank = malidp_crtc_disable_vblank,\n};\n\nint malidp_crtc_init(struct drm_device *drm)\n{\n\tstruct malidp_drm *malidp = drm_to_malidp(drm);\n\tstruct drm_plane *primary = NULL, *plane;\n\tint ret;\n\n\tret = malidp_de_planes_init(drm);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"Failed to initialise planes\\n\");\n\t\treturn ret;\n\t}\n\n\tdrm_for_each_plane(plane, drm) {\n\t\tif (plane->type == DRM_PLANE_TYPE_PRIMARY) {\n\t\t\tprimary = plane;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!primary) {\n\t\tDRM_ERROR(\"no primary plane found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = drmm_crtc_init_with_planes(drm, &malidp->crtc, primary, NULL,\n\t\t\t\t\t &malidp_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_helper_add(&malidp->crtc, &malidp_crtc_helper_funcs);\n\tdrm_mode_crtc_set_gamma_size(&malidp->crtc, MALIDP_GAMMA_LUT_SIZE);\n\t \n\tdrm_crtc_enable_color_mgmt(&malidp->crtc, 0, true, MALIDP_GAMMA_LUT_SIZE);\n\n\tmalidp_se_set_enh_coeffs(malidp->dev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}