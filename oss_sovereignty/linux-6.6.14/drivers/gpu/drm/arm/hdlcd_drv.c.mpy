{
  "module_name": "hdlcd_drv.c",
  "hash_id": "b56fd32d46aebfc7262d75e3d4bda9c4e17218c2361b7365c2f1084a4b011c3e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/hdlcd_drv.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/clk.h>\n#include <linux/component.h>\n#include <linux/console.h>\n#include <linux/dma-mapping.h>\n#include <linux/list.h>\n#include <linux/of_graph.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/drm_aperture.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_debugfs.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_fbdev_dma.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_modeset_helper.h>\n#include <drm/drm_module.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"hdlcd_drv.h\"\n#include \"hdlcd_regs.h\"\n\nstatic irqreturn_t hdlcd_irq(int irq, void *arg)\n{\n\tstruct hdlcd_drm_private *hdlcd = arg;\n\tunsigned long irq_status;\n\n\tirq_status = hdlcd_read(hdlcd, HDLCD_REG_INT_STATUS);\n\n#ifdef CONFIG_DEBUG_FS\n\tif (irq_status & HDLCD_INTERRUPT_UNDERRUN)\n\t\tatomic_inc(&hdlcd->buffer_underrun_count);\n\n\tif (irq_status & HDLCD_INTERRUPT_DMA_END)\n\t\tatomic_inc(&hdlcd->dma_end_count);\n\n\tif (irq_status & HDLCD_INTERRUPT_BUS_ERROR)\n\t\tatomic_inc(&hdlcd->bus_error_count);\n\n\tif (irq_status & HDLCD_INTERRUPT_VSYNC)\n\t\tatomic_inc(&hdlcd->vsync_count);\n\n#endif\n\tif (irq_status & HDLCD_INTERRUPT_VSYNC)\n\t\tdrm_crtc_handle_vblank(&hdlcd->crtc);\n\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_INT_CLEAR, irq_status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int hdlcd_irq_install(struct hdlcd_drm_private *hdlcd)\n{\n\tint ret;\n\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_INT_MASK, 0);\n\thdlcd_write(hdlcd, HDLCD_REG_INT_CLEAR, ~0);\n\n\tret = request_irq(hdlcd->irq, hdlcd_irq, 0, \"hdlcd\", hdlcd);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_DEBUG_FS\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_INT_MASK, HDLCD_DEBUG_INT_MASK);\n#endif\n\n\treturn 0;\n}\n\nstatic void hdlcd_irq_uninstall(struct hdlcd_drm_private *hdlcd)\n{\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_INT_MASK, 0);\n\n\tfree_irq(hdlcd->irq, hdlcd);\n}\n\nstatic int hdlcd_load(struct drm_device *drm, unsigned long flags)\n{\n\tstruct hdlcd_drm_private *hdlcd = drm_to_hdlcd_priv(drm);\n\tstruct platform_device *pdev = to_platform_device(drm->dev);\n\tu32 version;\n\tint ret;\n\n\thdlcd->clk = devm_clk_get(drm->dev, \"pxlclk\");\n\tif (IS_ERR(hdlcd->clk))\n\t\treturn PTR_ERR(hdlcd->clk);\n\n#ifdef CONFIG_DEBUG_FS\n\tatomic_set(&hdlcd->buffer_underrun_count, 0);\n\tatomic_set(&hdlcd->bus_error_count, 0);\n\tatomic_set(&hdlcd->vsync_count, 0);\n\tatomic_set(&hdlcd->dma_end_count, 0);\n#endif\n\n\thdlcd->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hdlcd->mmio)) {\n\t\tDRM_ERROR(\"failed to map control registers area\\n\");\n\t\tret = PTR_ERR(hdlcd->mmio);\n\t\thdlcd->mmio = NULL;\n\t\treturn ret;\n\t}\n\n\tversion = hdlcd_read(hdlcd, HDLCD_REG_VERSION);\n\tif ((version & HDLCD_PRODUCT_MASK) != HDLCD_PRODUCT_ID) {\n\t\tDRM_ERROR(\"unknown product id: 0x%x\\n\", version);\n\t\treturn -EINVAL;\n\t}\n\tDRM_INFO(\"found ARM HDLCD version r%dp%d\\n\",\n\t\t(version & HDLCD_VERSION_MAJOR_MASK) >> 8,\n\t\tversion & HDLCD_VERSION_MINOR_MASK);\n\n\t \n\tret = of_reserved_mem_device_init(drm->dev);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tret = dma_set_mask_and_coherent(drm->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto setup_fail;\n\n\tret = hdlcd_setup_crtc(drm);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to create crtc\\n\");\n\t\tgoto setup_fail;\n\t}\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto irq_fail;\n\thdlcd->irq = ret;\n\n\tret = hdlcd_irq_install(hdlcd);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to install IRQ handler\\n\");\n\t\tgoto irq_fail;\n\t}\n\n\treturn 0;\n\nirq_fail:\n\tdrm_crtc_cleanup(&hdlcd->crtc);\nsetup_fail:\n\tof_reserved_mem_device_release(drm->dev);\n\n\treturn ret;\n}\n\nstatic const struct drm_mode_config_funcs hdlcd_mode_config_funcs = {\n\t.fb_create = drm_gem_fb_create,\n\t.atomic_check = drm_atomic_helper_check,\n\t.atomic_commit = drm_atomic_helper_commit,\n};\n\nstatic int hdlcd_setup_mode_config(struct drm_device *drm)\n{\n\tint ret;\n\n\tret = drmm_mode_config_init(drm);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm->mode_config.min_width = 0;\n\tdrm->mode_config.min_height = 0;\n\tdrm->mode_config.max_width = HDLCD_MAX_XRES;\n\tdrm->mode_config.max_height = HDLCD_MAX_YRES;\n\tdrm->mode_config.funcs = &hdlcd_mode_config_funcs;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic int hdlcd_show_underrun_count(struct seq_file *m, void *arg)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *drm = entry->dev;\n\tstruct hdlcd_drm_private *hdlcd = drm_to_hdlcd_priv(drm);\n\n\tseq_printf(m, \"underrun : %d\\n\", atomic_read(&hdlcd->buffer_underrun_count));\n\tseq_printf(m, \"dma_end  : %d\\n\", atomic_read(&hdlcd->dma_end_count));\n\tseq_printf(m, \"bus_error: %d\\n\", atomic_read(&hdlcd->bus_error_count));\n\tseq_printf(m, \"vsync    : %d\\n\", atomic_read(&hdlcd->vsync_count));\n\treturn 0;\n}\n\nstatic int hdlcd_show_pxlclock(struct seq_file *m, void *arg)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *drm = entry->dev;\n\tstruct hdlcd_drm_private *hdlcd = drm_to_hdlcd_priv(drm);\n\tunsigned long clkrate = clk_get_rate(hdlcd->clk);\n\tunsigned long mode_clock = hdlcd->crtc.mode.crtc_clock * 1000;\n\n\tseq_printf(m, \"hw  : %lu\\n\", clkrate);\n\tseq_printf(m, \"mode: %lu\\n\", mode_clock);\n\treturn 0;\n}\n\nstatic struct drm_debugfs_info hdlcd_debugfs_list[] = {\n\t{ \"interrupt_count\", hdlcd_show_underrun_count, 0 },\n\t{ \"clocks\", hdlcd_show_pxlclock, 0 },\n};\n#endif\n\nDEFINE_DRM_GEM_DMA_FOPS(fops);\n\nstatic const struct drm_driver hdlcd_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS,\n\t.fops = &fops,\n\t.name = \"hdlcd\",\n\t.desc = \"ARM HDLCD Controller DRM\",\n\t.date = \"20151021\",\n\t.major = 1,\n\t.minor = 0,\n};\n\nstatic int hdlcd_drm_bind(struct device *dev)\n{\n\tstruct drm_device *drm;\n\tstruct hdlcd_drm_private *hdlcd;\n\tint ret;\n\n\thdlcd = devm_drm_dev_alloc(dev, &hdlcd_driver, typeof(*hdlcd), base);\n\tif (IS_ERR(hdlcd))\n\t\treturn PTR_ERR(hdlcd);\n\n\tdrm = &hdlcd->base;\n\n\tdev_set_drvdata(dev, drm);\n\n\tret = hdlcd_setup_mode_config(drm);\n\tif (ret)\n\t\tgoto err_free;\n\n\tret = hdlcd_load(drm, 0);\n\tif (ret)\n\t\tgoto err_free;\n\n\t \n\thdlcd->crtc.port = of_graph_get_port_by_id(dev->of_node, 0);\n\n\tret = component_bind_all(dev, drm);\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to bind all components\\n\");\n\t\tgoto err_unload;\n\t}\n\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\tgoto err_pm_active;\n\n\tpm_runtime_enable(dev);\n\n\tret = drm_vblank_init(drm, drm->mode_config.num_crtc);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"failed to initialise vblank\\n\");\n\t\tgoto err_vblank;\n\t}\n\n\t \n\tif (hdlcd_read(hdlcd, HDLCD_REG_COMMAND)) {\n\t\thdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);\n\t\tdrm_aperture_remove_framebuffers(&hdlcd_driver);\n\t}\n\n\tdrm_mode_config_reset(drm);\n\tdrm_kms_helper_poll_init(drm);\n\n#ifdef CONFIG_DEBUG_FS\n\tdrm_debugfs_add_files(drm, hdlcd_debugfs_list, ARRAY_SIZE(hdlcd_debugfs_list));\n#endif\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto err_register;\n\n\tdrm_fbdev_dma_setup(drm, 32);\n\n\treturn 0;\n\nerr_register:\n\tdrm_kms_helper_poll_fini(drm);\nerr_vblank:\n\tpm_runtime_disable(drm->dev);\nerr_pm_active:\n\tdrm_atomic_helper_shutdown(drm);\n\tcomponent_unbind_all(dev, drm);\nerr_unload:\n\tof_node_put(hdlcd->crtc.port);\n\thdlcd->crtc.port = NULL;\n\thdlcd_irq_uninstall(hdlcd);\n\tof_reserved_mem_device_release(drm->dev);\nerr_free:\n\tdev_set_drvdata(dev, NULL);\n\treturn ret;\n}\n\nstatic void hdlcd_drm_unbind(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\tstruct hdlcd_drm_private *hdlcd = drm_to_hdlcd_priv(drm);\n\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tcomponent_unbind_all(dev, drm);\n\tof_node_put(hdlcd->crtc.port);\n\thdlcd->crtc.port = NULL;\n\tpm_runtime_get_sync(dev);\n\tdrm_atomic_helper_shutdown(drm);\n\thdlcd_irq_uninstall(hdlcd);\n\tpm_runtime_put(dev);\n\tif (pm_runtime_enabled(dev))\n\t\tpm_runtime_disable(dev);\n\tof_reserved_mem_device_release(dev);\n\tdev_set_drvdata(dev, NULL);\n}\n\nstatic const struct component_master_ops hdlcd_master_ops = {\n\t.bind\t\t= hdlcd_drm_bind,\n\t.unbind\t\t= hdlcd_drm_unbind,\n};\n\nstatic int compare_dev(struct device *dev, void *data)\n{\n\treturn dev->of_node == data;\n}\n\nstatic int hdlcd_probe(struct platform_device *pdev)\n{\n\tstruct device_node *port;\n\tstruct component_match *match = NULL;\n\n\t \n\tport = of_graph_get_remote_node(pdev->dev.of_node, 0, 0);\n\tif (!port)\n\t\treturn -ENODEV;\n\n\tdrm_of_component_match_add(&pdev->dev, &match, compare_dev, port);\n\tof_node_put(port);\n\n\treturn component_master_add_with_match(&pdev->dev, &hdlcd_master_ops,\n\t\t\t\t\t       match);\n}\n\nstatic void hdlcd_remove(struct platform_device *pdev)\n{\n\tcomponent_master_del(&pdev->dev, &hdlcd_master_ops);\n}\n\nstatic const struct of_device_id  hdlcd_of_match[] = {\n\t{ .compatible\t= \"arm,hdlcd\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hdlcd_of_match);\n\nstatic int __maybe_unused hdlcd_pm_suspend(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\treturn drm_mode_config_helper_suspend(drm);\n}\n\nstatic int __maybe_unused hdlcd_pm_resume(struct device *dev)\n{\n\tstruct drm_device *drm = dev_get_drvdata(dev);\n\n\tdrm_mode_config_helper_resume(drm);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(hdlcd_pm_ops, hdlcd_pm_suspend, hdlcd_pm_resume);\n\nstatic struct platform_driver hdlcd_platform_driver = {\n\t.probe\t\t= hdlcd_probe,\n\t.remove_new\t= hdlcd_remove,\n\t.driver\t= {\n\t\t.name = \"hdlcd\",\n\t\t.pm = &hdlcd_pm_ops,\n\t\t.of_match_table\t= hdlcd_of_match,\n\t},\n};\n\ndrm_module_platform_driver(hdlcd_platform_driver);\n\nMODULE_AUTHOR(\"Liviu Dudau\");\nMODULE_DESCRIPTION(\"ARM HDLCD DRM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}