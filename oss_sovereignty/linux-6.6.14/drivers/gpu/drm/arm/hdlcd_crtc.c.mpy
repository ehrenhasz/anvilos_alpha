{
  "module_name": "hdlcd_crtc.c",
  "hash_id": "7d81337c75730a4a6a885eca02e813fae9ab70f9169c04a6861836cec6380cfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/hdlcd_crtc.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/of_graph.h>\n#include <linux/platform_data/simplefb.h>\n\n#include <video/videomode.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_of.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"hdlcd_drv.h\"\n#include \"hdlcd_regs.h\"\n\n \n\nstatic void hdlcd_crtc_cleanup(struct drm_crtc *crtc)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);\n\tdrm_crtc_cleanup(crtc);\n}\n\nstatic int hdlcd_crtc_enable_vblank(struct drm_crtc *crtc)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\tunsigned int mask = hdlcd_read(hdlcd, HDLCD_REG_INT_MASK);\n\n\thdlcd_write(hdlcd, HDLCD_REG_INT_MASK, mask | HDLCD_INTERRUPT_VSYNC);\n\n\treturn 0;\n}\n\nstatic void hdlcd_crtc_disable_vblank(struct drm_crtc *crtc)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\tunsigned int mask = hdlcd_read(hdlcd, HDLCD_REG_INT_MASK);\n\n\thdlcd_write(hdlcd, HDLCD_REG_INT_MASK, mask & ~HDLCD_INTERRUPT_VSYNC);\n}\n\nstatic const struct drm_crtc_funcs hdlcd_crtc_funcs = {\n\t.destroy = hdlcd_crtc_cleanup,\n\t.set_config = drm_atomic_helper_set_config,\n\t.page_flip = drm_atomic_helper_page_flip,\n\t.reset = drm_atomic_helper_crtc_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,\n\t.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,\n\t.enable_vblank = hdlcd_crtc_enable_vblank,\n\t.disable_vblank = hdlcd_crtc_disable_vblank,\n};\n\nstatic struct simplefb_format supported_formats[] = SIMPLEFB_FORMATS;\n\n \nstatic int hdlcd_set_pxl_fmt(struct drm_crtc *crtc)\n{\n\tunsigned int btpp;\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\tconst struct drm_framebuffer *fb = crtc->primary->state->fb;\n\tuint32_t pixel_format;\n\tstruct simplefb_format *format = NULL;\n\tint i;\n\n\tpixel_format = fb->format->format;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_formats); i++) {\n\t\tif (supported_formats[i].fourcc == pixel_format)\n\t\t\tformat = &supported_formats[i];\n\t}\n\n\tif (WARN_ON(!format))\n\t\treturn 0;\n\n\t \n\tbtpp = (format->bits_per_pixel + 7) / 8;\n\thdlcd_write(hdlcd, HDLCD_REG_PIXEL_FORMAT, (btpp - 1) << 3);\n\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_RED_SELECT, format->red.offset |\n#ifdef CONFIG_DRM_HDLCD_SHOW_UNDERRUN\n\t\t    0x00ff0000 |\t \n#endif\n\t\t    ((format->red.length & 0xf) << 8));\n\thdlcd_write(hdlcd, HDLCD_REG_GREEN_SELECT, format->green.offset |\n\t\t    ((format->green.length & 0xf) << 8));\n\thdlcd_write(hdlcd, HDLCD_REG_BLUE_SELECT, format->blue.offset |\n\t\t    ((format->blue.length & 0xf) << 8));\n\n\treturn 0;\n}\n\nstatic void hdlcd_crtc_mode_set_nofb(struct drm_crtc *crtc)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\tstruct drm_display_mode *m = &crtc->state->adjusted_mode;\n\tstruct videomode vm;\n\tunsigned int polarities, err;\n\n\tvm.vfront_porch = m->crtc_vsync_start - m->crtc_vdisplay;\n\tvm.vback_porch = m->crtc_vtotal - m->crtc_vsync_end;\n\tvm.vsync_len = m->crtc_vsync_end - m->crtc_vsync_start;\n\tvm.hfront_porch = m->crtc_hsync_start - m->crtc_hdisplay;\n\tvm.hback_porch = m->crtc_htotal - m->crtc_hsync_end;\n\tvm.hsync_len = m->crtc_hsync_end - m->crtc_hsync_start;\n\n\tpolarities = HDLCD_POLARITY_DATAEN | HDLCD_POLARITY_DATA;\n\n\tif (m->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tpolarities |= HDLCD_POLARITY_HSYNC;\n\tif (m->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tpolarities |= HDLCD_POLARITY_VSYNC;\n\n\t \n\thdlcd_write(hdlcd, HDLCD_REG_BUS_OPTIONS,\n\t\t    HDLCD_BUS_MAX_OUTSTAND | HDLCD_BUS_BURST_16);\n\n\thdlcd_write(hdlcd, HDLCD_REG_V_DATA, m->crtc_vdisplay - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_V_BACK_PORCH, vm.vback_porch - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_V_FRONT_PORCH, vm.vfront_porch - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_V_SYNC, vm.vsync_len - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_H_DATA, m->crtc_hdisplay - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_H_BACK_PORCH, vm.hback_porch - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_H_FRONT_PORCH, vm.hfront_porch - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_H_SYNC, vm.hsync_len - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_POLARITIES, polarities);\n\n\terr = hdlcd_set_pxl_fmt(crtc);\n\tif (err)\n\t\treturn;\n\n\tclk_set_rate(hdlcd->clk, m->crtc_clock * 1000);\n}\n\nstatic void hdlcd_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\n\tclk_prepare_enable(hdlcd->clk);\n\thdlcd_crtc_mode_set_nofb(crtc);\n\thdlcd_write(hdlcd, HDLCD_REG_COMMAND, 1);\n\tdrm_crtc_vblank_on(crtc);\n}\n\nstatic void hdlcd_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\n\tdrm_crtc_vblank_off(crtc);\n\thdlcd_write(hdlcd, HDLCD_REG_COMMAND, 0);\n\tclk_disable_unprepare(hdlcd->clk);\n}\n\nstatic enum drm_mode_status hdlcd_crtc_mode_valid(struct drm_crtc *crtc,\n\t\tconst struct drm_display_mode *mode)\n{\n\tstruct hdlcd_drm_private *hdlcd = crtc_to_hdlcd_priv(crtc);\n\tlong rate, clk_rate = mode->clock * 1000;\n\n\trate = clk_round_rate(hdlcd->clk, clk_rate);\n\t \n\tif (abs(rate - clk_rate) * 1000 > clk_rate) {\n\t\t \n\t\treturn MODE_NOCLOCK;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic void hdlcd_crtc_atomic_begin(struct drm_crtc *crtc,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_pending_vblank_event *event = crtc->state->event;\n\n\tif (event) {\n\t\tcrtc->state->event = NULL;\n\n\t\tspin_lock_irq(&crtc->dev->event_lock);\n\t\tif (drm_crtc_vblank_get(crtc) == 0)\n\t\t\tdrm_crtc_arm_vblank_event(crtc, event);\n\t\telse\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\tspin_unlock_irq(&crtc->dev->event_lock);\n\t}\n}\n\nstatic const struct drm_crtc_helper_funcs hdlcd_crtc_helper_funcs = {\n\t.mode_valid\t= hdlcd_crtc_mode_valid,\n\t.atomic_begin\t= hdlcd_crtc_atomic_begin,\n\t.atomic_enable\t= hdlcd_crtc_atomic_enable,\n\t.atomic_disable\t= hdlcd_crtc_atomic_disable,\n};\n\nstatic int hdlcd_plane_atomic_check(struct drm_plane *plane,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tint i;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tu32 src_h = new_plane_state->src_h >> 16;\n\n\t \n\tif (src_h >= HDLCD_MAX_YRES) {\n\t\tDRM_DEBUG_KMS(\"Invalid source width: %d\\n\", src_h);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state,\n\t\t\t\t   i) {\n\t\t \n\t\tif (!new_plane_state->fb && crtc_state->active)\n\t\t\treturn -EINVAL;\n\t\treturn drm_atomic_helper_check_plane_state(new_plane_state,\n\t\t\t\t\t\t\t   crtc_state,\n\t\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t\t   DRM_PLANE_NO_SCALING,\n\t\t\t\t\t\t\t   false, true);\n\t}\n\n\treturn 0;\n}\n\nstatic void hdlcd_plane_atomic_update(struct drm_plane *plane,\n\t\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tstruct hdlcd_drm_private *hdlcd;\n\tu32 dest_h;\n\tdma_addr_t scanout_start;\n\n\tif (!fb)\n\t\treturn;\n\n\tdest_h = drm_rect_height(&new_plane_state->dst);\n\tscanout_start = drm_fb_dma_get_gem_addr(fb, new_plane_state, 0);\n\n\thdlcd = drm_to_hdlcd_priv(plane->dev);\n\thdlcd_write(hdlcd, HDLCD_REG_FB_LINE_LENGTH, fb->pitches[0]);\n\thdlcd_write(hdlcd, HDLCD_REG_FB_LINE_PITCH, fb->pitches[0]);\n\thdlcd_write(hdlcd, HDLCD_REG_FB_LINE_COUNT, dest_h - 1);\n\thdlcd_write(hdlcd, HDLCD_REG_FB_BASE, scanout_start);\n}\n\nstatic const struct drm_plane_helper_funcs hdlcd_plane_helper_funcs = {\n\t.atomic_check = hdlcd_plane_atomic_check,\n\t.atomic_update = hdlcd_plane_atomic_update,\n};\n\nstatic const struct drm_plane_funcs hdlcd_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.reset\t\t\t= drm_atomic_helper_plane_reset,\n\t.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_plane_destroy_state,\n};\n\nstatic struct drm_plane *hdlcd_plane_init(struct drm_device *drm)\n{\n\tstruct hdlcd_drm_private *hdlcd = drm_to_hdlcd_priv(drm);\n\tstruct drm_plane *plane = NULL;\n\tu32 formats[ARRAY_SIZE(supported_formats)], i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_formats); i++)\n\t\tformats[i] = supported_formats[i].fourcc;\n\n\tplane = drmm_universal_plane_alloc(drm, struct drm_plane, dev, 0xff,\n\t\t\t\t\t   &hdlcd_plane_funcs,\n\t\t\t\t\t   formats, ARRAY_SIZE(formats),\n\t\t\t\t\t   NULL, DRM_PLANE_TYPE_PRIMARY, NULL);\n\tif (IS_ERR(plane))\n\t\treturn plane;\n\n\tdrm_plane_helper_add(plane, &hdlcd_plane_helper_funcs);\n\thdlcd->plane = plane;\n\n\treturn plane;\n}\n\nint hdlcd_setup_crtc(struct drm_device *drm)\n{\n\tstruct hdlcd_drm_private *hdlcd = drm_to_hdlcd_priv(drm);\n\tstruct drm_plane *primary;\n\tint ret;\n\n\tprimary = hdlcd_plane_init(drm);\n\tif (IS_ERR(primary))\n\t\treturn PTR_ERR(primary);\n\n\tret = drm_crtc_init_with_planes(drm, &hdlcd->crtc, primary, NULL,\n\t\t\t\t\t&hdlcd_crtc_funcs, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tdrm_crtc_helper_add(&hdlcd->crtc, &hdlcd_crtc_helper_funcs);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}