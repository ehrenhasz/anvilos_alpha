{
  "module_name": "komeda_color_mgmt.c",
  "hash_id": "d535513d00f5f42a8afafb829c8f8ef26fd0141572ba26c82f025cc3be5ad5c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_color_mgmt.c",
  "human_readable_source": "\n \n\n#include \"komeda_color_mgmt.h\"\n\n \nstatic const s32 yuv2rgb_bt601_narrow[KOMEDA_N_YUV2RGB_COEFFS] = {\n\t1192,    0, 1634,\n\t1192, -401, -832,\n\t1192, 2066,    0,\n\t  64,  512,  512\n};\n\nstatic const s32 yuv2rgb_bt601_wide[KOMEDA_N_YUV2RGB_COEFFS] = {\n\t1024,    0, 1436,\n\t1024, -352, -731,\n\t1024, 1815,    0,\n\t   0,  512,  512\n};\n\nstatic const s32 yuv2rgb_bt709_narrow[KOMEDA_N_YUV2RGB_COEFFS] = {\n\t1192,    0, 1836,\n\t1192, -218, -546,\n\t1192, 2163,    0,\n\t  64,  512,  512\n};\n\nstatic const s32 yuv2rgb_bt709_wide[KOMEDA_N_YUV2RGB_COEFFS] = {\n\t1024,    0, 1613,\n\t1024, -192, -479,\n\t1024, 1900,    0,\n\t   0,  512,  512\n};\n\nstatic const s32 yuv2rgb_bt2020[KOMEDA_N_YUV2RGB_COEFFS] = {\n\t1024,    0, 1476,\n\t1024, -165, -572,\n\t1024, 1884,    0,\n\t   0,  512,  512\n};\n\nconst s32 *komeda_select_yuv2rgb_coeffs(u32 color_encoding, u32 color_range)\n{\n\tbool narrow = color_range == DRM_COLOR_YCBCR_LIMITED_RANGE;\n\tconst s32 *coeffs;\n\n\tswitch (color_encoding) {\n\tcase DRM_COLOR_YCBCR_BT709:\n\t\tcoeffs = narrow ? yuv2rgb_bt709_narrow : yuv2rgb_bt709_wide;\n\t\tbreak;\n\tcase DRM_COLOR_YCBCR_BT601:\n\t\tcoeffs = narrow ? yuv2rgb_bt601_narrow : yuv2rgb_bt601_wide;\n\t\tbreak;\n\tcase DRM_COLOR_YCBCR_BT2020:\n\t\tcoeffs = yuv2rgb_bt2020;\n\t\tbreak;\n\tdefault:\n\t\tcoeffs = NULL;\n\t\tbreak;\n\t}\n\n\treturn coeffs;\n}\n\nstruct gamma_curve_sector {\n\tu32 boundary_start;\n\tu32 num_of_segments;\n\tu32 segment_width;\n};\n\nstruct gamma_curve_segment {\n\tu32 start;\n\tu32 end;\n};\n\nstatic struct gamma_curve_sector sector_tbl[] = {\n\t{ 0,    4,  4   },\n\t{ 16,   4,  4   },\n\t{ 32,   4,  8   },\n\t{ 64,   4,  16  },\n\t{ 128,  4,  32  },\n\t{ 256,  4,  64  },\n\t{ 512,  16, 32  },\n\t{ 1024, 24, 128 },\n};\n\nstatic void\ndrm_lut_to_coeffs(struct drm_property_blob *lut_blob, u32 *coeffs,\n\t\t  struct gamma_curve_sector *sector_tbl, u32 num_sectors)\n{\n\tstruct drm_color_lut *lut;\n\tu32 i, j, in, num = 0;\n\n\tif (!lut_blob)\n\t\treturn;\n\n\tlut = lut_blob->data;\n\n\tfor (i = 0; i < num_sectors; i++) {\n\t\tfor (j = 0; j < sector_tbl[i].num_of_segments; j++) {\n\t\t\tin = sector_tbl[i].boundary_start +\n\t\t\t     j * sector_tbl[i].segment_width;\n\n\t\t\tcoeffs[num++] = drm_color_lut_extract(lut[in].red,\n\t\t\t\t\t\tKOMEDA_COLOR_PRECISION);\n\t\t}\n\t}\n\n\tcoeffs[num] = BIT(KOMEDA_COLOR_PRECISION);\n}\n\nvoid drm_lut_to_fgamma_coeffs(struct drm_property_blob *lut_blob, u32 *coeffs)\n{\n\tdrm_lut_to_coeffs(lut_blob, coeffs, sector_tbl, ARRAY_SIZE(sector_tbl));\n}\n\nvoid drm_ctm_to_coeffs(struct drm_property_blob *ctm_blob, u32 *coeffs)\n{\n\tstruct drm_color_ctm *ctm;\n\tu32 i;\n\n\tif (!ctm_blob)\n\t\treturn;\n\n\tctm = ctm_blob->data;\n\n\tfor (i = 0; i < KOMEDA_N_CTM_COEFFS; i++)\n\t\tcoeffs[i] = drm_color_ctm_s31_32_to_qm_n(ctm->matrix[i], 3, 12);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}