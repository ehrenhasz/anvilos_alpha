{
  "module_name": "komeda_format_caps.c",
  "hash_id": "ec3a23b3a78a2327bbbf40d8dbf1776c383d174a94afb27375c9e05419a771c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_format_caps.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"komeda_format_caps.h\"\n#include \"malidp_utils.h\"\n\nconst struct komeda_format_caps *\nkomeda_get_format_caps(struct komeda_format_caps_table *table,\n\t\t       u32 fourcc, u64 modifier)\n{\n\tconst struct komeda_format_caps *caps;\n\tu64 afbc_features = modifier & ~(AFBC_FORMAT_MOD_BLOCK_SIZE_MASK);\n\tu32 afbc_layout = modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK;\n\tint id;\n\n\tfor (id = 0; id < table->n_formats; id++) {\n\t\tcaps = &table->format_caps[id];\n\n\t\tif (fourcc != caps->fourcc)\n\t\t\tcontinue;\n\n\t\tif ((modifier == 0ULL) && (caps->supported_afbc_layouts == 0))\n\t\t\treturn caps;\n\n\t\tif (has_bits(afbc_features, caps->supported_afbc_features) &&\n\t\t    has_bit(afbc_layout, caps->supported_afbc_layouts))\n\t\t\treturn caps;\n\t}\n\n\treturn NULL;\n}\n\nu32 komeda_get_afbc_format_bpp(const struct drm_format_info *info, u64 modifier)\n{\n\tu32 bpp;\n\n\tswitch (info->format) {\n\tcase DRM_FORMAT_YUV420_8BIT:\n\t\tbpp = 12;\n\t\tbreak;\n\tcase DRM_FORMAT_YUV420_10BIT:\n\t\tbpp = 15;\n\t\tbreak;\n\tdefault:\n\t\tbpp = info->cpp[0] * 8;\n\t\tbreak;\n\t}\n\n\treturn bpp;\n}\n\n \nu64 komeda_supported_modifiers[] = {\n\t \n\tAFBC_16x16(0),\n\t \n\tAFBC_16x16(_SPARSE),\n\t \n\tAFBC_16x16(_YTR | _SPARSE),\n\tAFBC_16x16(_YTR),\n\t \n\t \n\tAFBC_16x16(_SPLIT | _SPARSE | _YTR),\n\t \n\t \n\tAFBC_16x16(_TILED | _SPARSE),\n\tAFBC_16x16(_TILED),\n\t \n\tAFBC_16x16(_TILED | _SC | _SPLIT | _SPARSE | _YTR),\n\tAFBC_16x16(_TILED | _SC | _SPARSE | _YTR),\n\tAFBC_16x16(_TILED | _SC | _YTR),\n\t \n\t \n\tAFBC_32x8(_YTR | _SPARSE),\n\tAFBC_32x8(_YTR),\n\t \n\t \n\tAFBC_32x8(_SPLIT | _SPARSE | _YTR),\n\t \n\tAFBC_32x8(_TILED | _SC | _SPLIT | _SPARSE | _YTR),\n\tAFBC_32x8(_TILED | _SC | _SPARSE | _YTR),\n\tAFBC_32x8(_TILED | _SC | _YTR),\n\tDRM_FORMAT_MOD_LINEAR,\n\tDRM_FORMAT_MOD_INVALID\n};\n\nbool komeda_format_mod_supported(struct komeda_format_caps_table *table,\n\t\t\t\t u32 layer_type, u32 fourcc, u64 modifier,\n\t\t\t\t u32 rot)\n{\n\tconst struct komeda_format_caps *caps;\n\n\tcaps = komeda_get_format_caps(table, fourcc, modifier);\n\tif (!caps)\n\t\treturn false;\n\n\tif (!(caps->supported_layer_types & layer_type))\n\t\treturn false;\n\n\tif (table->format_mod_supported)\n\t\treturn table->format_mod_supported(caps, layer_type, modifier,\n\t\t\t\t\t\t   rot);\n\n\treturn true;\n}\n\nu32 *komeda_get_layer_fourcc_list(struct komeda_format_caps_table *table,\n\t\t\t\t  u32 layer_type, u32 *n_fmts)\n{\n\tconst struct komeda_format_caps *cap;\n\tu32 *fmts;\n\tint i, j, n = 0;\n\n\tfmts = kcalloc(table->n_formats, sizeof(u32), GFP_KERNEL);\n\tif (!fmts)\n\t\treturn NULL;\n\n\tfor (i = 0; i < table->n_formats; i++) {\n\t\tcap = &table->format_caps[i];\n\t\tif (!(layer_type & cap->supported_layer_types) ||\n\t\t    (cap->fourcc == 0))\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (j = n - 1; j >= 0; j--)\n\t\t\tif (fmts[j] == cap->fourcc)\n\t\t\t\tbreak;\n\n\t\tif (j < 0)\n\t\t\tfmts[n++] = cap->fourcc;\n\t}\n\n\tif (n_fmts)\n\t\t*n_fmts = n;\n\n\treturn fmts;\n}\n\nvoid komeda_put_fourcc_list(u32 *fourcc_list)\n{\n\tkfree(fourcc_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}