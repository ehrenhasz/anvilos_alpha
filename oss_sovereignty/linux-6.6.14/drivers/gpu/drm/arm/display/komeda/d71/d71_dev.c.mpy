{
  "module_name": "d71_dev.c",
  "hash_id": "67c9e033b85114e8b4c4f874915748f9762c91b8864c51db5b96e7b297a5edd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/d71/d71_dev.c",
  "human_readable_source": "\n \n\n#include <drm/drm_blend.h>\n#include <drm/drm_print.h>\n#include \"d71_dev.h\"\n#include \"malidp_io.h\"\n\nstatic u64 get_lpu_event(struct d71_pipeline *d71_pipeline)\n{\n\tu32 __iomem *reg = d71_pipeline->lpu_addr;\n\tu32 status, raw_status;\n\tu64 evts = 0ULL;\n\n\traw_status = malidp_read32(reg, BLK_IRQ_RAW_STATUS);\n\tif (raw_status & LPU_IRQ_IBSY)\n\t\tevts |= KOMEDA_EVENT_IBSY;\n\tif (raw_status & LPU_IRQ_EOW)\n\t\tevts |= KOMEDA_EVENT_EOW;\n\tif (raw_status & LPU_IRQ_OVR)\n\t\tevts |= KOMEDA_EVENT_OVR;\n\n\tif (raw_status & (LPU_IRQ_ERR | LPU_IRQ_IBSY | LPU_IRQ_OVR)) {\n\t\tu32 restore = 0, tbu_status;\n\t\t \n\t\tstatus = malidp_read32(reg, BLK_STATUS);\n\t\tif (status & LPU_STATUS_AXIE) {\n\t\t\trestore |= LPU_STATUS_AXIE;\n\t\t\tevts |= KOMEDA_ERR_AXIE;\n\t\t}\n\t\tif (status & LPU_STATUS_ACE0) {\n\t\t\trestore |= LPU_STATUS_ACE0;\n\t\t\tevts |= KOMEDA_ERR_ACE0;\n\t\t}\n\t\tif (status & LPU_STATUS_ACE1) {\n\t\t\trestore |= LPU_STATUS_ACE1;\n\t\t\tevts |= KOMEDA_ERR_ACE1;\n\t\t}\n\t\tif (status & LPU_STATUS_ACE2) {\n\t\t\trestore |= LPU_STATUS_ACE2;\n\t\t\tevts |= KOMEDA_ERR_ACE2;\n\t\t}\n\t\tif (status & LPU_STATUS_ACE3) {\n\t\t\trestore |= LPU_STATUS_ACE3;\n\t\t\tevts |= KOMEDA_ERR_ACE3;\n\t\t}\n\t\tif (status & LPU_STATUS_FEMPTY) {\n\t\t\trestore |= LPU_STATUS_FEMPTY;\n\t\t\tevts |= KOMEDA_EVENT_EMPTY;\n\t\t}\n\t\tif (status & LPU_STATUS_FFULL) {\n\t\t\trestore |= LPU_STATUS_FFULL;\n\t\t\tevts |= KOMEDA_EVENT_FULL;\n\t\t}\n\n\t\tif (restore != 0)\n\t\t\tmalidp_write32_mask(reg, BLK_STATUS, restore, 0);\n\n\t\trestore = 0;\n\t\t \n\t\ttbu_status = malidp_read32(reg, LPU_TBU_STATUS);\n\t\tif (tbu_status & LPU_TBU_STATUS_TCF) {\n\t\t\trestore |= LPU_TBU_STATUS_TCF;\n\t\t\tevts |= KOMEDA_ERR_TCF;\n\t\t}\n\t\tif (tbu_status & LPU_TBU_STATUS_TTNG) {\n\t\t\trestore |= LPU_TBU_STATUS_TTNG;\n\t\t\tevts |= KOMEDA_ERR_TTNG;\n\t\t}\n\t\tif (tbu_status & LPU_TBU_STATUS_TITR) {\n\t\t\trestore |= LPU_TBU_STATUS_TITR;\n\t\t\tevts |= KOMEDA_ERR_TITR;\n\t\t}\n\t\tif (tbu_status & LPU_TBU_STATUS_TEMR) {\n\t\t\trestore |= LPU_TBU_STATUS_TEMR;\n\t\t\tevts |= KOMEDA_ERR_TEMR;\n\t\t}\n\t\tif (tbu_status & LPU_TBU_STATUS_TTF) {\n\t\t\trestore |= LPU_TBU_STATUS_TTF;\n\t\t\tevts |= KOMEDA_ERR_TTF;\n\t\t}\n\t\tif (restore != 0)\n\t\t\tmalidp_write32_mask(reg, LPU_TBU_STATUS, restore, 0);\n\t}\n\n\tmalidp_write32(reg, BLK_IRQ_CLEAR, raw_status);\n\treturn evts;\n}\n\nstatic u64 get_cu_event(struct d71_pipeline *d71_pipeline)\n{\n\tu32 __iomem *reg = d71_pipeline->cu_addr;\n\tu32 status, raw_status;\n\tu64 evts = 0ULL;\n\n\traw_status = malidp_read32(reg, BLK_IRQ_RAW_STATUS);\n\tif (raw_status & CU_IRQ_OVR)\n\t\tevts |= KOMEDA_EVENT_OVR;\n\n\tif (raw_status & (CU_IRQ_ERR | CU_IRQ_OVR)) {\n\t\tstatus = malidp_read32(reg, BLK_STATUS) & 0x7FFFFFFF;\n\t\tif (status & CU_STATUS_CPE)\n\t\t\tevts |= KOMEDA_ERR_CPE;\n\t\tif (status & CU_STATUS_ZME)\n\t\t\tevts |= KOMEDA_ERR_ZME;\n\t\tif (status & CU_STATUS_CFGE)\n\t\t\tevts |= KOMEDA_ERR_CFGE;\n\t\tif (status)\n\t\t\tmalidp_write32_mask(reg, BLK_STATUS, status, 0);\n\t}\n\n\tmalidp_write32(reg, BLK_IRQ_CLEAR, raw_status);\n\n\treturn evts;\n}\n\nstatic u64 get_dou_event(struct d71_pipeline *d71_pipeline)\n{\n\tu32 __iomem *reg = d71_pipeline->dou_addr;\n\tu32 status, raw_status;\n\tu64 evts = 0ULL;\n\n\traw_status = malidp_read32(reg, BLK_IRQ_RAW_STATUS);\n\tif (raw_status & DOU_IRQ_PL0)\n\t\tevts |= KOMEDA_EVENT_VSYNC;\n\tif (raw_status & DOU_IRQ_UND)\n\t\tevts |= KOMEDA_EVENT_URUN;\n\n\tif (raw_status & (DOU_IRQ_ERR | DOU_IRQ_UND)) {\n\t\tu32 restore  = 0;\n\n\t\tstatus = malidp_read32(reg, BLK_STATUS);\n\t\tif (status & DOU_STATUS_DRIFTTO) {\n\t\t\trestore |= DOU_STATUS_DRIFTTO;\n\t\t\tevts |= KOMEDA_ERR_DRIFTTO;\n\t\t}\n\t\tif (status & DOU_STATUS_FRAMETO) {\n\t\t\trestore |= DOU_STATUS_FRAMETO;\n\t\t\tevts |= KOMEDA_ERR_FRAMETO;\n\t\t}\n\t\tif (status & DOU_STATUS_TETO) {\n\t\t\trestore |= DOU_STATUS_TETO;\n\t\t\tevts |= KOMEDA_ERR_TETO;\n\t\t}\n\t\tif (status & DOU_STATUS_CSCE) {\n\t\t\trestore |= DOU_STATUS_CSCE;\n\t\t\tevts |= KOMEDA_ERR_CSCE;\n\t\t}\n\n\t\tif (restore != 0)\n\t\t\tmalidp_write32_mask(reg, BLK_STATUS, restore, 0);\n\t}\n\n\tmalidp_write32(reg, BLK_IRQ_CLEAR, raw_status);\n\treturn evts;\n}\n\nstatic u64 get_pipeline_event(struct d71_pipeline *d71_pipeline, u32 gcu_status)\n{\n\tu32 evts = 0ULL;\n\n\tif (gcu_status & (GLB_IRQ_STATUS_LPU0 | GLB_IRQ_STATUS_LPU1))\n\t\tevts |= get_lpu_event(d71_pipeline);\n\n\tif (gcu_status & (GLB_IRQ_STATUS_CU0 | GLB_IRQ_STATUS_CU1))\n\t\tevts |= get_cu_event(d71_pipeline);\n\n\tif (gcu_status & (GLB_IRQ_STATUS_DOU0 | GLB_IRQ_STATUS_DOU1))\n\t\tevts |= get_dou_event(d71_pipeline);\n\n\treturn evts;\n}\n\nstatic irqreturn_t\nd71_irq_handler(struct komeda_dev *mdev, struct komeda_events *evts)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tu32 status, gcu_status, raw_status;\n\n\tgcu_status = malidp_read32(d71->gcu_addr, GLB_IRQ_STATUS);\n\n\tif (gcu_status & GLB_IRQ_STATUS_GCU) {\n\t\traw_status = malidp_read32(d71->gcu_addr, BLK_IRQ_RAW_STATUS);\n\t\tif (raw_status & GCU_IRQ_CVAL0)\n\t\t\tevts->pipes[0] |= KOMEDA_EVENT_FLIP;\n\t\tif (raw_status & GCU_IRQ_CVAL1)\n\t\t\tevts->pipes[1] |= KOMEDA_EVENT_FLIP;\n\t\tif (raw_status & GCU_IRQ_ERR) {\n\t\t\tstatus = malidp_read32(d71->gcu_addr, BLK_STATUS);\n\t\t\tif (status & GCU_STATUS_MERR) {\n\t\t\t\tevts->global |= KOMEDA_ERR_MERR;\n\t\t\t\tmalidp_write32_mask(d71->gcu_addr, BLK_STATUS,\n\t\t\t\t\t\t    GCU_STATUS_MERR, 0);\n\t\t\t}\n\t\t}\n\n\t\tmalidp_write32(d71->gcu_addr, BLK_IRQ_CLEAR, raw_status);\n\t}\n\n\tif (gcu_status & GLB_IRQ_STATUS_PIPE0)\n\t\tevts->pipes[0] |= get_pipeline_event(d71->pipes[0], gcu_status);\n\n\tif (gcu_status & GLB_IRQ_STATUS_PIPE1)\n\t\tevts->pipes[1] |= get_pipeline_event(d71->pipes[1], gcu_status);\n\n\treturn IRQ_RETVAL(gcu_status);\n}\n\n#define ENABLED_GCU_IRQS\t(GCU_IRQ_CVAL0 | GCU_IRQ_CVAL1 | \\\n\t\t\t\t GCU_IRQ_MODE | GCU_IRQ_ERR)\n#define ENABLED_LPU_IRQS\t(LPU_IRQ_IBSY | LPU_IRQ_ERR | LPU_IRQ_EOW)\n#define ENABLED_CU_IRQS\t\t(CU_IRQ_OVR | CU_IRQ_ERR)\n#define ENABLED_DOU_IRQS\t(DOU_IRQ_UND | DOU_IRQ_ERR)\n\nstatic int d71_enable_irq(struct komeda_dev *mdev)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tstruct d71_pipeline *pipe;\n\tu32 i;\n\n\tmalidp_write32_mask(d71->gcu_addr, BLK_IRQ_MASK,\n\t\t\t    ENABLED_GCU_IRQS, ENABLED_GCU_IRQS);\n\tfor (i = 0; i < d71->num_pipelines; i++) {\n\t\tpipe = d71->pipes[i];\n\t\tmalidp_write32_mask(pipe->cu_addr,  BLK_IRQ_MASK,\n\t\t\t\t    ENABLED_CU_IRQS, ENABLED_CU_IRQS);\n\t\tmalidp_write32_mask(pipe->lpu_addr, BLK_IRQ_MASK,\n\t\t\t\t    ENABLED_LPU_IRQS, ENABLED_LPU_IRQS);\n\t\tmalidp_write32_mask(pipe->dou_addr, BLK_IRQ_MASK,\n\t\t\t\t    ENABLED_DOU_IRQS, ENABLED_DOU_IRQS);\n\t}\n\treturn 0;\n}\n\nstatic int d71_disable_irq(struct komeda_dev *mdev)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tstruct d71_pipeline *pipe;\n\tu32 i;\n\n\tmalidp_write32_mask(d71->gcu_addr, BLK_IRQ_MASK, ENABLED_GCU_IRQS, 0);\n\tfor (i = 0; i < d71->num_pipelines; i++) {\n\t\tpipe = d71->pipes[i];\n\t\tmalidp_write32_mask(pipe->cu_addr,  BLK_IRQ_MASK,\n\t\t\t\t    ENABLED_CU_IRQS, 0);\n\t\tmalidp_write32_mask(pipe->lpu_addr, BLK_IRQ_MASK,\n\t\t\t\t    ENABLED_LPU_IRQS, 0);\n\t\tmalidp_write32_mask(pipe->dou_addr, BLK_IRQ_MASK,\n\t\t\t\t    ENABLED_DOU_IRQS, 0);\n\t}\n\treturn 0;\n}\n\nstatic void d71_on_off_vblank(struct komeda_dev *mdev, int master_pipe, bool on)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tstruct d71_pipeline *pipe = d71->pipes[master_pipe];\n\n\tmalidp_write32_mask(pipe->dou_addr, BLK_IRQ_MASK,\n\t\t\t    DOU_IRQ_PL0, on ? DOU_IRQ_PL0 : 0);\n}\n\nstatic int to_d71_opmode(int core_mode)\n{\n\tswitch (core_mode) {\n\tcase KOMEDA_MODE_DISP0:\n\t\treturn DO0_ACTIVE_MODE;\n\tcase KOMEDA_MODE_DISP1:\n\t\treturn DO1_ACTIVE_MODE;\n\tcase KOMEDA_MODE_DUAL_DISP:\n\t\treturn DO01_ACTIVE_MODE;\n\tcase KOMEDA_MODE_INACTIVE:\n\t\treturn INACTIVE_MODE;\n\tdefault:\n\t\tWARN(1, \"Unknown operation mode\");\n\t\treturn INACTIVE_MODE;\n\t}\n}\n\nstatic int d71_change_opmode(struct komeda_dev *mdev, int new_mode)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tu32 opmode = to_d71_opmode(new_mode);\n\tint ret;\n\n\tmalidp_write32_mask(d71->gcu_addr, BLK_CONTROL, 0x7, opmode);\n\n\tret = dp_wait_cond(((malidp_read32(d71->gcu_addr, BLK_CONTROL) & 0x7) == opmode),\n\t\t\t   100, 1000, 10000);\n\n\treturn ret;\n}\n\nstatic void d71_flush(struct komeda_dev *mdev,\n\t\t      int master_pipe, u32 active_pipes)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tu32 reg_offset = (master_pipe == 0) ?\n\t\t\t GCU_CONFIG_VALID0 : GCU_CONFIG_VALID1;\n\n\tmalidp_write32(d71->gcu_addr, reg_offset, GCU_CONFIG_CVAL);\n}\n\nstatic int d71_reset(struct d71_dev *d71)\n{\n\tu32 __iomem *gcu = d71->gcu_addr;\n\tint ret;\n\n\tmalidp_write32(gcu, BLK_CONTROL, GCU_CONTROL_SRST);\n\n\tret = dp_wait_cond(!(malidp_read32(gcu, BLK_CONTROL) & GCU_CONTROL_SRST),\n\t\t\t   100, 1000, 10000);\n\n\treturn ret;\n}\n\nvoid d71_read_block_header(u32 __iomem *reg, struct block_header *blk)\n{\n\tint i;\n\n\tblk->block_info = malidp_read32(reg, BLK_BLOCK_INFO);\n\tif (BLOCK_INFO_BLK_TYPE(blk->block_info) == D71_BLK_TYPE_RESERVED)\n\t\treturn;\n\n\tblk->pipeline_info = malidp_read32(reg, BLK_PIPELINE_INFO);\n\n\t \n\tfor (i = 0; i < PIPELINE_INFO_N_VALID_INPUTS(blk->pipeline_info); i++)\n\t\tblk->input_ids[i] = malidp_read32(reg + i, BLK_VALID_INPUT_ID0);\n\tfor (i = 0; i < PIPELINE_INFO_N_OUTPUTS(blk->pipeline_info); i++)\n\t\tblk->output_ids[i] = malidp_read32(reg + i, BLK_OUTPUT_ID0);\n}\n\nstatic void d71_cleanup(struct komeda_dev *mdev)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\n\tif (!d71)\n\t\treturn;\n\n\tdevm_kfree(mdev->dev, d71);\n\tmdev->chip_data = NULL;\n}\n\nstatic int d71_enum_resources(struct komeda_dev *mdev)\n{\n\tstruct d71_dev *d71;\n\tstruct komeda_pipeline *pipe;\n\tstruct block_header blk;\n\tu32 __iomem *blk_base;\n\tu32 i, value, offset;\n\tint err;\n\n\td71 = devm_kzalloc(mdev->dev, sizeof(*d71), GFP_KERNEL);\n\tif (!d71)\n\t\treturn -ENOMEM;\n\n\tmdev->chip_data = d71;\n\td71->mdev = mdev;\n\td71->gcu_addr = mdev->reg_base;\n\td71->periph_addr = mdev->reg_base + (D71_BLOCK_OFFSET_PERIPH >> 2);\n\n\terr = d71_reset(d71);\n\tif (err) {\n\t\tDRM_ERROR(\"Fail to reset d71 device.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\tvalue = malidp_read32(d71->gcu_addr, GLB_CORE_INFO);\n\td71->num_blocks = value & 0xFF;\n\td71->num_pipelines = (value >> 8) & 0x7;\n\n\tif (d71->num_pipelines > D71_MAX_PIPELINE) {\n\t\tDRM_ERROR(\"d71 supports %d pipelines, but got: %d.\\n\",\n\t\t\t  D71_MAX_PIPELINE, d71->num_pipelines);\n\t\terr = -EINVAL;\n\t\tgoto err_cleanup;\n\t}\n\n\t \n\tvalue = malidp_read32(d71->periph_addr, BLK_BLOCK_INFO);\n\tif (BLOCK_INFO_BLK_TYPE(value) != D71_BLK_TYPE_PERIPH)\n\t\td71->periph_addr = NULL;\n\n\tif (d71->periph_addr) {\n\t\t \n\t\tvalue = malidp_read32(d71->periph_addr, PERIPH_CONFIGURATION_ID);\n\n\t\td71->max_line_size\t= value & PERIPH_MAX_LINE_SIZE ? 4096 : 2048;\n\t\td71->max_vsize\t\t= 4096;\n\t\td71->num_rich_layers\t= value & PERIPH_NUM_RICH_LAYERS ? 2 : 1;\n\t\td71->supports_dual_link\t= !!(value & PERIPH_SPLIT_EN);\n\t\td71->integrates_tbu\t= !!(value & PERIPH_TBU_EN);\n\t} else {\n\t\tvalue = malidp_read32(d71->gcu_addr, GCU_CONFIGURATION_ID0);\n\t\td71->max_line_size\t= GCU_MAX_LINE_SIZE(value);\n\t\td71->max_vsize\t\t= GCU_MAX_NUM_LINES(value);\n\n\t\tvalue = malidp_read32(d71->gcu_addr, GCU_CONFIGURATION_ID1);\n\t\td71->num_rich_layers\t= GCU_NUM_RICH_LAYERS(value);\n\t\td71->supports_dual_link\t= GCU_DISPLAY_SPLIT_EN(value);\n\t\td71->integrates_tbu\t= GCU_DISPLAY_TBU_EN(value);\n\t}\n\n\tfor (i = 0; i < d71->num_pipelines; i++) {\n\t\tpipe = komeda_pipeline_add(mdev, sizeof(struct d71_pipeline),\n\t\t\t\t\t   &d71_pipeline_funcs);\n\t\tif (IS_ERR(pipe)) {\n\t\t\terr = PTR_ERR(pipe);\n\t\t\tgoto err_cleanup;\n\t\t}\n\n\t\t \n\t\tvalue = KOMEDA_PIPELINE_IMPROCS |\n\t\t\tBIT(KOMEDA_COMPONENT_TIMING_CTRLR);\n\n\t\tpipe->standalone_disabled_comps = value;\n\n\t\td71->pipes[i] = to_d71_pipeline(pipe);\n\t}\n\n\t \n\ti = 1;  \n\toffset = D71_BLOCK_SIZE;  \n\twhile (i < d71->num_blocks) {\n\t\tblk_base = mdev->reg_base + (offset >> 2);\n\n\t\td71_read_block_header(blk_base, &blk);\n\t\tif (BLOCK_INFO_BLK_TYPE(blk.block_info) != D71_BLK_TYPE_RESERVED) {\n\t\t\terr = d71_probe_block(d71, &blk, blk_base);\n\t\t\tif (err)\n\t\t\t\tgoto err_cleanup;\n\t\t}\n\n\t\ti++;\n\t\toffset += D71_BLOCK_SIZE;\n\t}\n\n\tDRM_DEBUG(\"total %d (out of %d) blocks are found.\\n\",\n\t\t  i, d71->num_blocks);\n\n\treturn 0;\n\nerr_cleanup:\n\td71_cleanup(mdev);\n\treturn err;\n}\n\n#define __HW_ID(__group, __format) \\\n\t((((__group) & 0x7) << 3) | ((__format) & 0x7))\n\n#define RICH\t\tKOMEDA_FMT_RICH_LAYER\n#define SIMPLE\t\tKOMEDA_FMT_SIMPLE_LAYER\n#define RICH_SIMPLE\t(KOMEDA_FMT_RICH_LAYER | KOMEDA_FMT_SIMPLE_LAYER)\n#define RICH_WB\t\t(KOMEDA_FMT_RICH_LAYER | KOMEDA_FMT_WB_LAYER)\n#define RICH_SIMPLE_WB\t(RICH_SIMPLE | KOMEDA_FMT_WB_LAYER)\n\n#define Rot_0\t\tDRM_MODE_ROTATE_0\n#define Flip_H_V\t(DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y | Rot_0)\n#define Rot_ALL_H_V\t(DRM_MODE_ROTATE_MASK | Flip_H_V)\n\n#define LYT_NM\t\tBIT(AFBC_FORMAT_MOD_BLOCK_SIZE_16x16)\n#define LYT_WB\t\tBIT(AFBC_FORMAT_MOD_BLOCK_SIZE_32x8)\n#define LYT_NM_WB\t(LYT_NM | LYT_WB)\n\n#define AFB_TH\t\tAFBC(_TILED | _SPARSE)\n#define AFB_TH_SC_YTR\tAFBC(_TILED | _SC | _SPARSE | _YTR)\n#define AFB_TH_SC_YTR_BS AFBC(_TILED | _SC | _SPARSE | _YTR | _SPLIT)\n\nstatic struct komeda_format_caps d71_format_caps_table[] = {\n\t \n\t \n\t{__HW_ID(0, 0),\tDRM_FORMAT_ARGB2101010,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(0, 1),\tDRM_FORMAT_ABGR2101010,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(0, 1),\tDRM_FORMAT_ABGR2101010,\tRICH_SIMPLE,\tRot_ALL_H_V,\tLYT_NM_WB, AFB_TH_SC_YTR_BS},  \n\t{__HW_ID(0, 2),\tDRM_FORMAT_RGBA1010102,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(0, 3),\tDRM_FORMAT_BGRA1010102,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t \n\t{__HW_ID(1, 0),\tDRM_FORMAT_ARGB8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(1, 1),\tDRM_FORMAT_ABGR8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(1, 1),\tDRM_FORMAT_ABGR8888,\tRICH_SIMPLE,\tRot_ALL_H_V,\tLYT_NM_WB, AFB_TH_SC_YTR_BS},  \n\t{__HW_ID(1, 2),\tDRM_FORMAT_RGBA8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(1, 3),\tDRM_FORMAT_BGRA8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t \n\t{__HW_ID(2, 0),\tDRM_FORMAT_XRGB8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(2, 1),\tDRM_FORMAT_XBGR8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(2, 2),\tDRM_FORMAT_RGBX8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(2, 3),\tDRM_FORMAT_BGRX8888,\tRICH_SIMPLE_WB,\tFlip_H_V,\t\t0, 0},\n\t   \n\t{__HW_ID(3, 0),\tDRM_FORMAT_RGB888,\tRICH_SIMPLE_WB,\tRot_0,\t\t\t0, 0},\n\t{__HW_ID(3, 1),\tDRM_FORMAT_BGR888,\tRICH_SIMPLE_WB,\tRot_0,\t\t\t0, 0},\n\t{__HW_ID(3, 1),\tDRM_FORMAT_BGR888,\tRICH_SIMPLE,\tRot_ALL_H_V,\tLYT_NM_WB, AFB_TH_SC_YTR_BS},  \n\t \n\t{__HW_ID(4, 0),\tDRM_FORMAT_RGBA5551,\tRICH_SIMPLE,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(4, 1),\tDRM_FORMAT_ABGR1555,\tRICH_SIMPLE,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(4, 1),\tDRM_FORMAT_ABGR1555,\tRICH_SIMPLE,\tRot_ALL_H_V,\tLYT_NM_WB, AFB_TH_SC_YTR},  \n\t{__HW_ID(4, 2),\tDRM_FORMAT_RGB565,\tRICH_SIMPLE,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(4, 3),\tDRM_FORMAT_BGR565,\tRICH_SIMPLE,\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(4, 3),\tDRM_FORMAT_BGR565,\tRICH_SIMPLE,\tRot_ALL_H_V,\tLYT_NM_WB, AFB_TH_SC_YTR},  \n\t{__HW_ID(4, 4), DRM_FORMAT_R8,\t\tSIMPLE,\t\tRot_0,\t\t\t0, 0},\n\t \n\t{__HW_ID(5, 1),\tDRM_FORMAT_YUYV,\tRICH,\t\tRot_ALL_H_V,\tLYT_NM, AFB_TH},  \n\t{__HW_ID(5, 2),\tDRM_FORMAT_YUYV,\tRICH,\t\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(5, 3),\tDRM_FORMAT_UYVY,\tRICH,\t\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(5, 6),\tDRM_FORMAT_NV12,\tRICH,\t\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(5, 6),\tDRM_FORMAT_YUV420_8BIT,\tRICH,\t\tRot_ALL_H_V,\tLYT_NM, AFB_TH},  \n\t{__HW_ID(5, 7),\tDRM_FORMAT_YUV420,\tRICH,\t\tFlip_H_V,\t\t0, 0},\n\t \n\t{__HW_ID(6, 6),\tDRM_FORMAT_X0L2,\tRICH,\t\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(6, 7),\tDRM_FORMAT_P010,\tRICH,\t\tFlip_H_V,\t\t0, 0},\n\t{__HW_ID(6, 7),\tDRM_FORMAT_YUV420_10BIT, RICH,\t\tRot_ALL_H_V,\tLYT_NM, AFB_TH},\n};\n\nstatic bool d71_format_mod_supported(const struct komeda_format_caps *caps,\n\t\t\t\t     u32 layer_type, u64 modifier, u32 rot)\n{\n\tuint64_t layout = modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK;\n\n\tif ((layout == AFBC_FORMAT_MOD_BLOCK_SIZE_32x8) &&\n\t    drm_rotation_90_or_270(rot)) {\n\t\tDRM_DEBUG_ATOMIC(\"D71 doesn't support ROT90 for WB-AFBC.\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void d71_init_fmt_tbl(struct komeda_dev *mdev)\n{\n\tstruct komeda_format_caps_table *table = &mdev->fmt_tbl;\n\n\ttable->format_caps = d71_format_caps_table;\n\ttable->format_mod_supported = d71_format_mod_supported;\n\ttable->n_formats = ARRAY_SIZE(d71_format_caps_table);\n}\n\nstatic int d71_connect_iommu(struct komeda_dev *mdev)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tu32 __iomem *reg = d71->gcu_addr;\n\tu32 check_bits = (d71->num_pipelines == 2) ?\n\t\t\t GCU_STATUS_TCS0 | GCU_STATUS_TCS1 : GCU_STATUS_TCS0;\n\tint i, ret;\n\n\tif (!d71->integrates_tbu)\n\t\treturn -1;\n\n\tmalidp_write32_mask(reg, BLK_CONTROL, 0x7, TBU_CONNECT_MODE);\n\n\tret = dp_wait_cond(has_bits(check_bits, malidp_read32(reg, BLK_STATUS)),\n\t\t\t100, 1000, 1000);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"timed out connecting to TCU!\\n\");\n\t\tmalidp_write32_mask(reg, BLK_CONTROL, 0x7, INACTIVE_MODE);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < d71->num_pipelines; i++)\n\t\tmalidp_write32_mask(d71->pipes[i]->lpu_addr, LPU_TBU_CONTROL,\n\t\t\t\t    LPU_TBU_CTRL_TLBPEN, LPU_TBU_CTRL_TLBPEN);\n\treturn 0;\n}\n\nstatic int d71_disconnect_iommu(struct komeda_dev *mdev)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\tu32 __iomem *reg = d71->gcu_addr;\n\tu32 check_bits = (d71->num_pipelines == 2) ?\n\t\t\t GCU_STATUS_TCS0 | GCU_STATUS_TCS1 : GCU_STATUS_TCS0;\n\tint ret;\n\n\tmalidp_write32_mask(reg, BLK_CONTROL, 0x7, TBU_DISCONNECT_MODE);\n\n\tret = dp_wait_cond(((malidp_read32(reg, BLK_STATUS) & check_bits) == 0),\n\t\t\t100, 1000, 1000);\n\tif (ret < 0) {\n\t\tDRM_ERROR(\"timed out disconnecting from TCU!\\n\");\n\t\tmalidp_write32_mask(reg, BLK_CONTROL, 0x7, INACTIVE_MODE);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct komeda_dev_funcs d71_chip_funcs = {\n\t.init_format_table\t= d71_init_fmt_tbl,\n\t.enum_resources\t\t= d71_enum_resources,\n\t.cleanup\t\t= d71_cleanup,\n\t.irq_handler\t\t= d71_irq_handler,\n\t.enable_irq\t\t= d71_enable_irq,\n\t.disable_irq\t\t= d71_disable_irq,\n\t.on_off_vblank\t\t= d71_on_off_vblank,\n\t.change_opmode\t\t= d71_change_opmode,\n\t.flush\t\t\t= d71_flush,\n\t.connect_iommu\t\t= d71_connect_iommu,\n\t.disconnect_iommu\t= d71_disconnect_iommu,\n\t.dump_register\t\t= d71_dump,\n};\n\nconst struct komeda_dev_funcs *\nd71_identify(u32 __iomem *reg_base, struct komeda_chip_info *chip)\n{\n\tconst struct komeda_dev_funcs *funcs;\n\tu32 product_id;\n\n\tchip->core_id = malidp_read32(reg_base, GLB_CORE_ID);\n\n\tproduct_id = MALIDP_CORE_ID_PRODUCT_ID(chip->core_id);\n\n\tswitch (product_id) {\n\tcase MALIDP_D71_PRODUCT_ID:\n\tcase MALIDP_D32_PRODUCT_ID:\n\t\tfuncs = &d71_chip_funcs;\n\t\tbreak;\n\tdefault:\n\t\tDRM_ERROR(\"Unsupported product: 0x%x\\n\", product_id);\n\t\treturn NULL;\n\t}\n\n\tchip->arch_id\t= malidp_read32(reg_base, GLB_ARCH_ID);\n\tchip->core_info\t= malidp_read32(reg_base, GLB_CORE_INFO);\n\tchip->bus_width\t= D71_BUS_WIDTH_16_BYTES;\n\n\treturn funcs;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}