{
  "module_name": "komeda_pipeline_state.c",
  "hash_id": "3e9e68b153d9617b218659df0517597d20a3179b3bd6ad59f7415b1cda2c7cbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_pipeline_state.c",
  "human_readable_source": "\n \n\n#include <drm/drm_print.h>\n#include <linux/clk.h>\n#include \"komeda_dev.h\"\n#include \"komeda_kms.h\"\n#include \"komeda_pipeline.h\"\n#include \"komeda_framebuffer.h\"\n\nstatic inline bool is_switching_user(void *old, void *new)\n{\n\tif (!old || !new)\n\t\treturn false;\n\n\treturn old != new;\n}\n\nstatic struct komeda_pipeline_state *\nkomeda_pipeline_get_state(struct komeda_pipeline *pipe,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_st;\n\n\tpriv_st = drm_atomic_get_private_obj_state(state, &pipe->obj);\n\tif (IS_ERR(priv_st))\n\t\treturn ERR_CAST(priv_st);\n\n\treturn priv_to_pipe_st(priv_st);\n}\n\nstruct komeda_pipeline_state *\nkomeda_pipeline_get_old_state(struct komeda_pipeline *pipe,\n\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_st;\n\n\tpriv_st = drm_atomic_get_old_private_obj_state(state, &pipe->obj);\n\tif (priv_st)\n\t\treturn priv_to_pipe_st(priv_st);\n\treturn NULL;\n}\n\nstatic struct komeda_pipeline_state *\nkomeda_pipeline_get_new_state(struct komeda_pipeline *pipe,\n\t\t\t      struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_st;\n\n\tpriv_st = drm_atomic_get_new_private_obj_state(state, &pipe->obj);\n\tif (priv_st)\n\t\treturn priv_to_pipe_st(priv_st);\n\treturn NULL;\n}\n\n \nstatic struct komeda_pipeline_state *\nkomeda_pipeline_get_state_and_set_crtc(struct komeda_pipeline *pipe,\n\t\t\t\t       struct drm_atomic_state *state,\n\t\t\t\t       struct drm_crtc *crtc)\n{\n\tstruct komeda_pipeline_state *st;\n\n\tst = komeda_pipeline_get_state(pipe, state);\n\tif (IS_ERR(st))\n\t\treturn st;\n\n\tif (is_switching_user(crtc, st->crtc)) {\n\t\tDRM_DEBUG_ATOMIC(\"CRTC%d required pipeline%d is busy.\\n\",\n\t\t\t\t drm_crtc_index(crtc), pipe->id);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\t \n\tif (!crtc && st->active_comps) {\n\t\tDRM_DEBUG_ATOMIC(\"Disabling a busy pipeline:%d.\\n\", pipe->id);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tst->crtc = crtc;\n\n\tif (crtc) {\n\t\tstruct komeda_crtc_state *kcrtc_st;\n\n\t\tkcrtc_st = to_kcrtc_st(drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t     crtc));\n\n\t\tkcrtc_st->active_pipes |= BIT(pipe->id);\n\t\tkcrtc_st->affected_pipes |= BIT(pipe->id);\n\t}\n\treturn st;\n}\n\nstatic struct komeda_component_state *\nkomeda_component_get_state(struct komeda_component *c,\n\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_st;\n\n\tWARN_ON(!drm_modeset_is_locked(&c->pipeline->obj.lock));\n\n\tpriv_st = drm_atomic_get_private_obj_state(state, &c->obj);\n\tif (IS_ERR(priv_st))\n\t\treturn ERR_CAST(priv_st);\n\n\treturn priv_to_comp_st(priv_st);\n}\n\nstatic struct komeda_component_state *\nkomeda_component_get_old_state(struct komeda_component *c,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_private_state *priv_st;\n\n\tpriv_st = drm_atomic_get_old_private_obj_state(state, &c->obj);\n\tif (priv_st)\n\t\treturn priv_to_comp_st(priv_st);\n\treturn NULL;\n}\n\n \nstatic struct komeda_component_state *\nkomeda_component_get_state_and_set_user(struct komeda_component *c,\n\t\t\t\t\tstruct drm_atomic_state *state,\n\t\t\t\t\tvoid *user,\n\t\t\t\t\tstruct drm_crtc *crtc)\n{\n\tstruct komeda_pipeline_state *pipe_st;\n\tstruct komeda_component_state *st;\n\n\t \n\tpipe_st = komeda_pipeline_get_state_and_set_crtc(c->pipeline,\n\t\t\t\t\t\t\t state, crtc);\n\tif (IS_ERR(pipe_st))\n\t\treturn ERR_CAST(pipe_st);\n\n\tst = komeda_component_get_state(c, state);\n\tif (IS_ERR(st))\n\t\treturn st;\n\n\t \n\tif (is_switching_user(user, st->binding_user)) {\n\t\tDRM_DEBUG_ATOMIC(\"required %s is busy.\\n\", c->name);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tst->binding_user = user;\n\t \n\tif (st->binding_user)\n\t\tpipe_st->active_comps |= BIT(c->id);\n\n\treturn st;\n}\n\nstatic void\nkomeda_component_add_input(struct komeda_component_state *state,\n\t\t\t   struct komeda_component_output *input,\n\t\t\t   int idx)\n{\n\tstruct komeda_component *c = state->component;\n\n\tWARN_ON((idx < 0 || idx >= c->max_active_inputs));\n\n\t \n\tif (!has_bit(idx, state->affected_inputs) ||\n\t    memcmp(&state->inputs[idx], input, sizeof(*input))) {\n\t\tmemcpy(&state->inputs[idx], input, sizeof(*input));\n\t\tstate->changed_active_inputs |= BIT(idx);\n\t}\n\tstate->active_inputs |= BIT(idx);\n\tstate->affected_inputs |= BIT(idx);\n}\n\nstatic int\nkomeda_component_check_input(struct komeda_component_state *state,\n\t\t\t     struct komeda_component_output *input,\n\t\t\t     int idx)\n{\n\tstruct komeda_component *c = state->component;\n\n\tif ((idx < 0) || (idx >= c->max_active_inputs)) {\n\t\tDRM_DEBUG_ATOMIC(\"%s required an invalid %s-input[%d].\\n\",\n\t\t\t\t input->component->name, c->name, idx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (has_bit(idx, state->active_inputs)) {\n\t\tDRM_DEBUG_ATOMIC(\"%s required %s-input[%d] has been occupied already.\\n\",\n\t\t\t\t input->component->name, c->name, idx);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nkomeda_component_set_output(struct komeda_component_output *output,\n\t\t\t    struct komeda_component *comp,\n\t\t\t    u8 output_port)\n{\n\toutput->component = comp;\n\toutput->output_port = output_port;\n}\n\nstatic int\nkomeda_component_validate_private(struct komeda_component *c,\n\t\t\t\t  struct komeda_component_state *st)\n{\n\tint err;\n\n\tif (!c->funcs->validate)\n\t\treturn 0;\n\n\terr = c->funcs->validate(c, st);\n\tif (err)\n\t\tDRM_DEBUG_ATOMIC(\"%s validate private failed.\\n\", c->name);\n\n\treturn err;\n}\n\n \nstatic struct komeda_scaler *\nkomeda_component_get_avail_scaler(struct komeda_component *c,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct komeda_pipeline_state *pipe_st;\n\tu32 avail_scalers;\n\n\tpipe_st = komeda_pipeline_get_state(c->pipeline, state);\n\tif (!pipe_st)\n\t\treturn NULL;\n\n\tavail_scalers = (pipe_st->active_comps & KOMEDA_PIPELINE_SCALERS) ^\n\t\t\tKOMEDA_PIPELINE_SCALERS;\n\n\tc = komeda_component_pickup_output(c, avail_scalers);\n\n\treturn to_scaler(c);\n}\n\nstatic void\nkomeda_rotate_data_flow(struct komeda_data_flow_cfg *dflow, u32 rot)\n{\n\tif (drm_rotation_90_or_270(rot)) {\n\t\tswap(dflow->in_h, dflow->in_w);\n\t\tswap(dflow->total_in_h, dflow->total_in_w);\n\t}\n}\n\nstatic int\nkomeda_layer_check_cfg(struct komeda_layer *layer,\n\t\t       struct komeda_fb *kfb,\n\t\t       struct komeda_data_flow_cfg *dflow)\n{\n\tu32 src_x, src_y, src_w, src_h;\n\tu32 line_sz, max_line_sz;\n\n\tif (!komeda_fb_is_layer_supported(kfb, layer->layer_type, dflow->rot))\n\t\treturn -EINVAL;\n\n\tif (layer->base.id == KOMEDA_COMPONENT_WB_LAYER) {\n\t\tsrc_x = dflow->out_x;\n\t\tsrc_y = dflow->out_y;\n\t\tsrc_w = dflow->out_w;\n\t\tsrc_h = dflow->out_h;\n\t} else {\n\t\tsrc_x = dflow->in_x;\n\t\tsrc_y = dflow->in_y;\n\t\tsrc_w = dflow->in_w;\n\t\tsrc_h = dflow->in_h;\n\t}\n\n\tif (komeda_fb_check_src_coords(kfb, src_x, src_y, src_w, src_h))\n\t\treturn -EINVAL;\n\n\tif (!malidp_in_range(&layer->hsize_in, src_w)) {\n\t\tDRM_DEBUG_ATOMIC(\"invalidate src_w %d.\\n\", src_w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!malidp_in_range(&layer->vsize_in, src_h)) {\n\t\tDRM_DEBUG_ATOMIC(\"invalidate src_h %d.\\n\", src_h);\n\t\treturn -EINVAL;\n\t}\n\n\tif (drm_rotation_90_or_270(dflow->rot))\n\t\tline_sz = dflow->in_h;\n\telse\n\t\tline_sz = dflow->in_w;\n\n\tif (kfb->base.format->hsub > 1)\n\t\tmax_line_sz = layer->yuv_line_sz;\n\telse\n\t\tmax_line_sz = layer->line_sz;\n\n\tif (line_sz > max_line_sz) {\n\t\tDRM_DEBUG_ATOMIC(\"Required line_sz: %d exceeds the max size %d\\n\",\n\t\t\t\t line_sz, max_line_sz);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nkomeda_layer_validate(struct komeda_layer *layer,\n\t\t      struct komeda_plane_state *kplane_st,\n\t\t      struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_plane_state *plane_st = &kplane_st->base;\n\tstruct drm_framebuffer *fb = plane_st->fb;\n\tstruct komeda_fb *kfb = to_kfb(fb);\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_layer_state *st;\n\tint i, err;\n\n\terr = komeda_layer_check_cfg(layer, kfb, dflow);\n\tif (err)\n\t\treturn err;\n\n\tc_st = komeda_component_get_state_and_set_user(&layer->base,\n\t\t\tplane_st->state, plane_st->plane, plane_st->crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_layer_st(c_st);\n\n\tst->rot = dflow->rot;\n\n\tif (fb->modifier) {\n\t\tst->hsize = kfb->aligned_w;\n\t\tst->vsize = kfb->aligned_h;\n\t\tst->afbc_crop_l = dflow->in_x;\n\t\tst->afbc_crop_r = kfb->aligned_w - dflow->in_x - dflow->in_w;\n\t\tst->afbc_crop_t = dflow->in_y;\n\t\tst->afbc_crop_b = kfb->aligned_h - dflow->in_y - dflow->in_h;\n\t} else {\n\t\tst->hsize = dflow->in_w;\n\t\tst->vsize = dflow->in_h;\n\t\tst->afbc_crop_l = 0;\n\t\tst->afbc_crop_r = 0;\n\t\tst->afbc_crop_t = 0;\n\t\tst->afbc_crop_b = 0;\n\t}\n\n\tfor (i = 0; i < fb->format->num_planes; i++)\n\t\tst->addr[i] = komeda_fb_get_pixel_addr(kfb, dflow->in_x,\n\t\t\t\t\t\t       dflow->in_y, i);\n\n\terr = komeda_component_validate_private(&layer->base, c_st);\n\tif (err)\n\t\treturn err;\n\n\t \n\tkomeda_component_set_output(&dflow->input, &layer->base, 0);\n\n\t \n\tkomeda_rotate_data_flow(dflow, st->rot);\n\n\treturn 0;\n}\n\nstatic int\nkomeda_wb_layer_validate(struct komeda_layer *wb_layer,\n\t\t\t struct drm_connector_state *conn_st,\n\t\t\t struct komeda_data_flow_cfg *dflow)\n{\n\tstruct komeda_fb *kfb = to_kfb(conn_st->writeback_job->fb);\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_layer_state *st;\n\tint i, err;\n\n\terr = komeda_layer_check_cfg(wb_layer, kfb, dflow);\n\tif (err)\n\t\treturn err;\n\n\tc_st = komeda_component_get_state_and_set_user(&wb_layer->base,\n\t\t\tconn_st->state, conn_st->connector, conn_st->crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_layer_st(c_st);\n\n\tst->hsize = dflow->out_w;\n\tst->vsize = dflow->out_h;\n\n\tfor (i = 0; i < kfb->base.format->num_planes; i++)\n\t\tst->addr[i] = komeda_fb_get_pixel_addr(kfb, dflow->out_x,\n\t\t\t\t\t\t       dflow->out_y, i);\n\n\tkomeda_component_add_input(&st->base, &dflow->input, 0);\n\tkomeda_component_set_output(&dflow->input, &wb_layer->base, 0);\n\n\treturn 0;\n}\n\nstatic bool scaling_ratio_valid(u32 size_in, u32 size_out,\n\t\t\t\tu32 max_upscaling, u32 max_downscaling)\n{\n\tif (size_out > size_in * max_upscaling)\n\t\treturn false;\n\telse if (size_in > size_out * max_downscaling)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int\nkomeda_scaler_check_cfg(struct komeda_scaler *scaler,\n\t\t\tstruct komeda_crtc_state *kcrtc_st,\n\t\t\tstruct komeda_data_flow_cfg *dflow)\n{\n\tu32 hsize_in, vsize_in, hsize_out, vsize_out;\n\tu32 max_upscaling;\n\n\thsize_in = dflow->in_w;\n\tvsize_in = dflow->in_h;\n\thsize_out = dflow->out_w;\n\tvsize_out = dflow->out_h;\n\n\tif (!malidp_in_range(&scaler->hsize, hsize_in) ||\n\t    !malidp_in_range(&scaler->hsize, hsize_out)) {\n\t\tDRM_DEBUG_ATOMIC(\"Invalid horizontal sizes\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!malidp_in_range(&scaler->vsize, vsize_in) ||\n\t    !malidp_in_range(&scaler->vsize, vsize_out)) {\n\t\tDRM_DEBUG_ATOMIC(\"Invalid vertical sizes\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (has_bit(dflow->input.component->id, KOMEDA_PIPELINE_COMPIZS))\n\t\tmax_upscaling = 1;\n\telse\n\t\tmax_upscaling = scaler->max_upscaling;\n\n\tif (!scaling_ratio_valid(hsize_in, hsize_out, max_upscaling,\n\t\t\t\t scaler->max_downscaling)) {\n\t\tDRM_DEBUG_ATOMIC(\"Invalid horizontal scaling ratio\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!scaling_ratio_valid(vsize_in, vsize_out, max_upscaling,\n\t\t\t\t scaler->max_downscaling)) {\n\t\tDRM_DEBUG_ATOMIC(\"Invalid vertical scaling ratio\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hsize_in > hsize_out || vsize_in > vsize_out) {\n\t\tstruct komeda_pipeline *pipe = scaler->base.pipeline;\n\t\tint err;\n\n\t\terr = pipe->funcs->downscaling_clk_check(pipe,\n\t\t\t\t\t&kcrtc_st->base.adjusted_mode,\n\t\t\t\t\tkomeda_crtc_get_aclk(kcrtc_st), dflow);\n\t\tif (err) {\n\t\t\tDRM_DEBUG_ATOMIC(\"aclk can't satisfy the clock requirement of the downscaling\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nkomeda_scaler_validate(void *user,\n\t\t       struct komeda_crtc_state *kcrtc_st,\n\t\t       struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_atomic_state *drm_st = kcrtc_st->base.state;\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_scaler_state *st;\n\tstruct komeda_scaler *scaler;\n\tint err = 0;\n\n\tif (!(dflow->en_scaling || dflow->en_img_enhancement))\n\t\treturn 0;\n\n\tscaler = komeda_component_get_avail_scaler(dflow->input.component,\n\t\t\t\t\t\t   drm_st);\n\tif (!scaler) {\n\t\tDRM_DEBUG_ATOMIC(\"No scaler available\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = komeda_scaler_check_cfg(scaler, kcrtc_st, dflow);\n\tif (err)\n\t\treturn err;\n\n\tc_st = komeda_component_get_state_and_set_user(&scaler->base,\n\t\t\tdrm_st, user, kcrtc_st->base.crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_scaler_st(c_st);\n\n\tst->hsize_in = dflow->in_w;\n\tst->vsize_in = dflow->in_h;\n\tst->hsize_out = dflow->out_w;\n\tst->vsize_out = dflow->out_h;\n\tst->right_crop = dflow->right_crop;\n\tst->left_crop = dflow->left_crop;\n\tst->total_vsize_in = dflow->total_in_h;\n\tst->total_hsize_in = dflow->total_in_w;\n\tst->total_hsize_out = dflow->total_out_w;\n\n\t \n\tst->en_alpha = dflow->pixel_blend_mode != DRM_MODE_BLEND_PIXEL_NONE;\n\tst->en_scaling = dflow->en_scaling;\n\tst->en_img_enhancement = dflow->en_img_enhancement;\n\tst->en_split = dflow->en_split;\n\tst->right_part = dflow->right_part;\n\n\tkomeda_component_add_input(&st->base, &dflow->input, 0);\n\tkomeda_component_set_output(&dflow->input, &scaler->base, 0);\n\treturn err;\n}\n\nstatic void komeda_split_data_flow(struct komeda_scaler *scaler,\n\t\t\t\t   struct komeda_data_flow_cfg *dflow,\n\t\t\t\t   struct komeda_data_flow_cfg *l_dflow,\n\t\t\t\t   struct komeda_data_flow_cfg *r_dflow);\n\nstatic int\nkomeda_splitter_validate(struct komeda_splitter *splitter,\n\t\t\t struct drm_connector_state *conn_st,\n\t\t\t struct komeda_data_flow_cfg *dflow,\n\t\t\t struct komeda_data_flow_cfg *l_output,\n\t\t\t struct komeda_data_flow_cfg *r_output)\n{\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_splitter_state *st;\n\n\tif (!splitter) {\n\t\tDRM_DEBUG_ATOMIC(\"Current HW doesn't support splitter.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!malidp_in_range(&splitter->hsize, dflow->in_w)) {\n\t\tDRM_DEBUG_ATOMIC(\"split in_w:%d is out of the acceptable range.\\n\",\n\t\t\t\t dflow->in_w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!malidp_in_range(&splitter->vsize, dflow->in_h)) {\n\t\tDRM_DEBUG_ATOMIC(\"split in_h: %d exceeds the acceptable range.\\n\",\n\t\t\t\t dflow->in_h);\n\t\treturn -EINVAL;\n\t}\n\n\tc_st = komeda_component_get_state_and_set_user(&splitter->base,\n\t\t\tconn_st->state, conn_st->connector, conn_st->crtc);\n\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tkomeda_split_data_flow(splitter->base.pipeline->scalers[0],\n\t\t\t       dflow, l_output, r_output);\n\n\tst = to_splitter_st(c_st);\n\tst->hsize = dflow->in_w;\n\tst->vsize = dflow->in_h;\n\tst->overlap = dflow->overlap;\n\n\tkomeda_component_add_input(&st->base, &dflow->input, 0);\n\tkomeda_component_set_output(&l_output->input, &splitter->base, 0);\n\tkomeda_component_set_output(&r_output->input, &splitter->base, 1);\n\n\treturn 0;\n}\n\nstatic int\nkomeda_merger_validate(struct komeda_merger *merger,\n\t\t       void *user,\n\t\t       struct komeda_crtc_state *kcrtc_st,\n\t\t       struct komeda_data_flow_cfg *left_input,\n\t\t       struct komeda_data_flow_cfg *right_input,\n\t\t       struct komeda_data_flow_cfg *output)\n{\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_merger_state *st;\n\tint err = 0;\n\n\tif (!merger) {\n\t\tDRM_DEBUG_ATOMIC(\"No merger is available\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!malidp_in_range(&merger->hsize_merged, output->out_w)) {\n\t\tDRM_DEBUG_ATOMIC(\"merged_w: %d is out of the accepted range.\\n\",\n\t\t\t\t output->out_w);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!malidp_in_range(&merger->vsize_merged, output->out_h)) {\n\t\tDRM_DEBUG_ATOMIC(\"merged_h: %d is out of the accepted range.\\n\",\n\t\t\t\t output->out_h);\n\t\treturn -EINVAL;\n\t}\n\n\tc_st = komeda_component_get_state_and_set_user(&merger->base,\n\t\t\tkcrtc_st->base.state, kcrtc_st->base.crtc, kcrtc_st->base.crtc);\n\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_merger_st(c_st);\n\tst->hsize_merged = output->out_w;\n\tst->vsize_merged = output->out_h;\n\n\tkomeda_component_add_input(c_st, &left_input->input, 0);\n\tkomeda_component_add_input(c_st, &right_input->input, 1);\n\tkomeda_component_set_output(&output->input, &merger->base, 0);\n\n\treturn err;\n}\n\nvoid pipeline_composition_size(struct komeda_crtc_state *kcrtc_st,\n\t\t\t       u16 *hsize, u16 *vsize)\n{\n\tstruct drm_display_mode *m = &kcrtc_st->base.adjusted_mode;\n\n\tif (hsize)\n\t\t*hsize = m->hdisplay;\n\tif (vsize)\n\t\t*vsize = m->vdisplay;\n}\n\nstatic int\nkomeda_compiz_set_input(struct komeda_compiz *compiz,\n\t\t\tstruct komeda_crtc_state *kcrtc_st,\n\t\t\tstruct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_atomic_state *drm_st = kcrtc_st->base.state;\n\tstruct komeda_component_state *c_st, *old_st;\n\tstruct komeda_compiz_input_cfg *cin;\n\tu16 compiz_w, compiz_h;\n\tint idx = dflow->blending_zorder;\n\n\tpipeline_composition_size(kcrtc_st, &compiz_w, &compiz_h);\n\t \n\tif ((dflow->out_x + dflow->out_w > compiz_w) ||\n\t    (dflow->out_y + dflow->out_h > compiz_h) ||\n\t     dflow->out_w == 0 || dflow->out_h == 0) {\n\t\tDRM_DEBUG_ATOMIC(\"invalid disp rect [x=%d, y=%d, w=%d, h=%d]\\n\",\n\t\t\t\t dflow->out_x, dflow->out_y,\n\t\t\t\t dflow->out_w, dflow->out_h);\n\t\treturn -EINVAL;\n\t}\n\n\tc_st = komeda_component_get_state_and_set_user(&compiz->base, drm_st,\n\t\t\tkcrtc_st->base.crtc, kcrtc_st->base.crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tif (komeda_component_check_input(c_st, &dflow->input, idx))\n\t\treturn -EINVAL;\n\n\tcin = &(to_compiz_st(c_st)->cins[idx]);\n\n\tcin->hsize   = dflow->out_w;\n\tcin->vsize   = dflow->out_h;\n\tcin->hoffset = dflow->out_x;\n\tcin->voffset = dflow->out_y;\n\tcin->pixel_blend_mode = dflow->pixel_blend_mode;\n\tcin->layer_alpha = dflow->layer_alpha;\n\n\told_st = komeda_component_get_old_state(&compiz->base, drm_st);\n\n\t \n\tif (WARN_ON(!old_st) ||\n\t    memcmp(&(to_compiz_st(old_st)->cins[idx]), cin, sizeof(*cin)))\n\t\tc_st->changed_active_inputs |= BIT(idx);\n\n\tkomeda_component_add_input(c_st, &dflow->input, idx);\n\tkomeda_component_set_output(&dflow->input, &compiz->base, 0);\n\n\treturn 0;\n}\n\nstatic int\nkomeda_compiz_validate(struct komeda_compiz *compiz,\n\t\t       struct komeda_crtc_state *state,\n\t\t       struct komeda_data_flow_cfg *dflow)\n{\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_compiz_state *st;\n\n\tc_st = komeda_component_get_state_and_set_user(&compiz->base,\n\t\t\tstate->base.state, state->base.crtc, state->base.crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_compiz_st(c_st);\n\n\tpipeline_composition_size(state, &st->hsize, &st->vsize);\n\n\tkomeda_component_set_output(&dflow->input, &compiz->base, 0);\n\n\t \n\tif (dflow) {\n\t\tdflow->in_w = st->hsize;\n\t\tdflow->in_h = st->vsize;\n\t\tdflow->out_w = dflow->in_w;\n\t\tdflow->out_h = dflow->in_h;\n\t\t \n\t\tdflow->pixel_blend_mode = DRM_MODE_BLEND_PIXEL_NONE;\n\t\tdflow->layer_alpha = 0xFF;\n\t\tdflow->blending_zorder = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nkomeda_improc_validate(struct komeda_improc *improc,\n\t\t       struct komeda_crtc_state *kcrtc_st,\n\t\t       struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_crtc *crtc = kcrtc_st->base.crtc;\n\tstruct drm_crtc_state *crtc_st = &kcrtc_st->base;\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_improc_state *st;\n\n\tc_st = komeda_component_get_state_and_set_user(&improc->base,\n\t\t\tkcrtc_st->base.state, crtc, crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_improc_st(c_st);\n\n\tst->hsize = dflow->in_w;\n\tst->vsize = dflow->in_h;\n\n\tif (drm_atomic_crtc_needs_modeset(crtc_st)) {\n\t\tu32 output_depths, output_formats;\n\t\tu32 avail_depths, avail_formats;\n\n\t\tkomeda_crtc_get_color_config(crtc_st, &output_depths,\n\t\t\t\t\t     &output_formats);\n\n\t\tavail_depths = output_depths & improc->supported_color_depths;\n\t\tif (avail_depths == 0) {\n\t\t\tDRM_DEBUG_ATOMIC(\"No available color depths, conn depths: 0x%x & display: 0x%x\\n\",\n\t\t\t\t\t output_depths,\n\t\t\t\t\t improc->supported_color_depths);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tavail_formats = output_formats &\n\t\t\t\timproc->supported_color_formats;\n\t\tif (!avail_formats) {\n\t\t\tDRM_DEBUG_ATOMIC(\"No available color_formats, conn formats 0x%x & display: 0x%x\\n\",\n\t\t\t\t\t output_formats,\n\t\t\t\t\t improc->supported_color_formats);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tst->color_depth = __fls(avail_depths);\n\t\tst->color_format = BIT(__ffs(avail_formats));\n\t}\n\n\tif (kcrtc_st->base.color_mgmt_changed) {\n\t\tdrm_lut_to_fgamma_coeffs(kcrtc_st->base.gamma_lut,\n\t\t\t\t\t st->fgamma_coeffs);\n\t\tdrm_ctm_to_coeffs(kcrtc_st->base.ctm, st->ctm_coeffs);\n\t}\n\n\tkomeda_component_add_input(&st->base, &dflow->input, 0);\n\tkomeda_component_set_output(&dflow->input, &improc->base, 0);\n\n\treturn 0;\n}\n\nstatic int\nkomeda_timing_ctrlr_validate(struct komeda_timing_ctrlr *ctrlr,\n\t\t\t     struct komeda_crtc_state *kcrtc_st,\n\t\t\t     struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_crtc *crtc = kcrtc_st->base.crtc;\n\tstruct komeda_timing_ctrlr_state *st;\n\tstruct komeda_component_state *c_st;\n\n\tc_st = komeda_component_get_state_and_set_user(&ctrlr->base,\n\t\t\tkcrtc_st->base.state, crtc, crtc);\n\tif (IS_ERR(c_st))\n\t\treturn PTR_ERR(c_st);\n\n\tst = to_ctrlr_st(c_st);\n\n\tkomeda_component_add_input(&st->base, &dflow->input, 0);\n\tkomeda_component_set_output(&dflow->input, &ctrlr->base, 0);\n\n\treturn 0;\n}\n\nvoid komeda_complete_data_flow_cfg(struct komeda_layer *layer,\n\t\t\t\t   struct komeda_data_flow_cfg *dflow,\n\t\t\t\t   struct drm_framebuffer *fb)\n{\n\tstruct komeda_scaler *scaler = layer->base.pipeline->scalers[0];\n\tu32 w = dflow->in_w;\n\tu32 h = dflow->in_h;\n\n\tdflow->total_in_w = dflow->in_w;\n\tdflow->total_in_h = dflow->in_h;\n\tdflow->total_out_w = dflow->out_w;\n\n\t \n\tif (!fb->format->has_alpha)\n\t\tdflow->pixel_blend_mode = DRM_MODE_BLEND_PIXEL_NONE;\n\n\tif (drm_rotation_90_or_270(dflow->rot))\n\t\tswap(w, h);\n\n\tdflow->en_scaling = (w != dflow->out_w) || (h != dflow->out_h);\n\tdflow->is_yuv = fb->format->is_yuv;\n\n\t \n\tdflow->en_img_enhancement = dflow->out_w >= 2 * w ||\n\t\t\t\t    dflow->out_h >= 2 * h;\n\n\t \n\tif (dflow->en_scaling && scaler)\n\t\tdflow->en_split = !malidp_in_range(&scaler->hsize, dflow->in_w) ||\n\t\t\t\t  !malidp_in_range(&scaler->hsize, dflow->out_w);\n}\n\nstatic bool merger_is_available(struct komeda_pipeline *pipe,\n\t\t\t\tstruct komeda_data_flow_cfg *dflow)\n{\n\tu32 avail_inputs = pipe->merger ?\n\t\t\t   pipe->merger->base.supported_inputs : 0;\n\n\treturn has_bit(dflow->input.component->id, avail_inputs);\n}\n\nint komeda_build_layer_data_flow(struct komeda_layer *layer,\n\t\t\t\t struct komeda_plane_state *kplane_st,\n\t\t\t\t struct komeda_crtc_state *kcrtc_st,\n\t\t\t\t struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_plane *plane = kplane_st->base.plane;\n\tstruct komeda_pipeline *pipe = layer->base.pipeline;\n\tint err;\n\n\tDRM_DEBUG_ATOMIC(\"%s handling [PLANE:%d:%s]: src[x/y:%d/%d, w/h:%d/%d] disp[x/y:%d/%d, w/h:%d/%d]\",\n\t\t\t layer->base.name, plane->base.id, plane->name,\n\t\t\t dflow->in_x, dflow->in_y, dflow->in_w, dflow->in_h,\n\t\t\t dflow->out_x, dflow->out_y, dflow->out_w, dflow->out_h);\n\n\terr = komeda_layer_validate(layer, kplane_st, dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_scaler_validate(plane, kcrtc_st, dflow);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dflow->en_split && merger_is_available(pipe, dflow))\n\t\treturn 0;\n\n\terr = komeda_compiz_set_input(pipe->compiz, kcrtc_st, dflow);\n\n\treturn err;\n}\n\n \n\nstatic void komeda_split_data_flow(struct komeda_scaler *scaler,\n\t\t\t\t   struct komeda_data_flow_cfg *dflow,\n\t\t\t\t   struct komeda_data_flow_cfg *l_dflow,\n\t\t\t\t   struct komeda_data_flow_cfg *r_dflow)\n{\n\tbool r90 = drm_rotation_90_or_270(dflow->rot);\n\tbool flip_h = has_flip_h(dflow->rot);\n\tu32 l_out, r_out, overlap;\n\n\tmemcpy(l_dflow, dflow, sizeof(*dflow));\n\tmemcpy(r_dflow, dflow, sizeof(*dflow));\n\n\tl_dflow->right_part = false;\n\tr_dflow->right_part = true;\n\tr_dflow->blending_zorder = dflow->blending_zorder + 1;\n\n\toverlap = 0;\n\tif (dflow->en_scaling && scaler)\n\t\toverlap += scaler->scaling_split_overlap;\n\n\t \n\tdflow->overlap = overlap;\n\n\tif (dflow->en_img_enhancement && scaler)\n\t\toverlap += scaler->enh_split_overlap;\n\n\tl_dflow->overlap = overlap;\n\tr_dflow->overlap = overlap;\n\n\t \n\t \n\t \n\tif (r90) {\n\t\tif (dflow->en_scaling) {\n\t\t\tl_dflow->in_h = ALIGN(dflow->in_h, 2) / 2 + l_dflow->overlap;\n\t\t\tr_dflow->in_h = l_dflow->in_h;\n\t\t} else if (dflow->en_img_enhancement) {\n\t\t\t \n\t\t\tl_dflow->in_h = ALIGN(dflow->in_h, 2) / 2 + l_dflow->overlap;\n\t\t\tr_dflow->in_h = dflow->in_h / 2 + r_dflow->overlap;\n\t\t} else {\n\t\t\t \n\t\t\tl_dflow->in_h = ALIGN(((dflow->in_h + 1) >> 1), 2);\n\t\t\tr_dflow->in_h = dflow->in_h - l_dflow->in_h;\n\t\t}\n\n\t\t \n\t\tif ((overlap != 0) && dflow->is_yuv) {\n\t\t\tl_dflow->in_h = ALIGN(l_dflow->in_h, 2);\n\t\t\tr_dflow->in_h = ALIGN(r_dflow->in_h, 2);\n\t\t}\n\n\t\tif (flip_h)\n\t\t\tl_dflow->in_y = dflow->in_y + dflow->in_h - l_dflow->in_h;\n\t\telse\n\t\t\tr_dflow->in_y = dflow->in_y + dflow->in_h - r_dflow->in_h;\n\t} else {\n\t\tif (dflow->en_scaling) {\n\t\t\tl_dflow->in_w = ALIGN(dflow->in_w, 2) / 2 + l_dflow->overlap;\n\t\t\tr_dflow->in_w = l_dflow->in_w;\n\t\t} else if (dflow->en_img_enhancement) {\n\t\t\tl_dflow->in_w = ALIGN(dflow->in_w, 2) / 2 + l_dflow->overlap;\n\t\t\tr_dflow->in_w = dflow->in_w / 2 + r_dflow->overlap;\n\t\t} else {\n\t\t\tl_dflow->in_w = ALIGN(((dflow->in_w + 1) >> 1), 2);\n\t\t\tr_dflow->in_w = dflow->in_w - l_dflow->in_w;\n\t\t}\n\n\t\t \n\t\tif ((overlap != 0) && dflow->is_yuv) {\n\t\t\tl_dflow->in_w = ALIGN(l_dflow->in_w, 2);\n\t\t\tr_dflow->in_w = ALIGN(r_dflow->in_w, 2);\n\t\t}\n\n\t\t \n\t\tif (flip_h)\n\t\t\tl_dflow->in_x = dflow->in_w + dflow->in_x - l_dflow->in_w;\n\t\telse\n\t\t\tr_dflow->in_x = dflow->in_w + dflow->in_x - r_dflow->in_w;\n\t}\n\n\t \n\tif (dflow->en_scaling || dflow->en_img_enhancement)\n\t\tl_dflow->out_w = ((dflow->out_w + 1) >> 1);\n\telse\n\t\tl_dflow->out_w = ALIGN(((dflow->out_w + 1) >> 1), 2);\n\n\tr_dflow->out_w = dflow->out_w - l_dflow->out_w;\n\n\tl_dflow->out_x = dflow->out_x;\n\tr_dflow->out_x = l_dflow->out_w + l_dflow->out_x;\n\n\t \n\t \n\tif (r90) {\n\t\tl_out = (dflow->out_w * l_dflow->in_h) / dflow->in_h;\n\t\tr_out = (dflow->out_w * r_dflow->in_h) / dflow->in_h;\n\t} else {\n\t\tl_out = (dflow->out_w * l_dflow->in_w) / dflow->in_w;\n\t\tr_out = (dflow->out_w * r_dflow->in_w) / dflow->in_w;\n\t}\n\n\tl_dflow->left_crop  = 0;\n\tl_dflow->right_crop = l_out - l_dflow->out_w;\n\tr_dflow->left_crop  = r_out - r_dflow->out_w;\n\tr_dflow->right_crop = 0;\n\n\t \n\tl_dflow->out_w += l_dflow->right_crop + l_dflow->left_crop;\n\tr_dflow->out_w += r_dflow->right_crop + r_dflow->left_crop;\n}\n\n \nint komeda_build_layer_split_data_flow(struct komeda_layer *left,\n\t\t\t\t       struct komeda_plane_state *kplane_st,\n\t\t\t\t       struct komeda_crtc_state *kcrtc_st,\n\t\t\t\t       struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_plane *plane = kplane_st->base.plane;\n\tstruct komeda_pipeline *pipe = left->base.pipeline;\n\tstruct komeda_layer *right = left->right;\n\tstruct komeda_data_flow_cfg l_dflow, r_dflow;\n\tint err;\n\n\tkomeda_split_data_flow(pipe->scalers[0], dflow, &l_dflow, &r_dflow);\n\n\tDRM_DEBUG_ATOMIC(\"Assign %s + %s to [PLANE:%d:%s]: \"\n\t\t\t \"src[x/y:%d/%d, w/h:%d/%d] disp[x/y:%d/%d, w/h:%d/%d]\",\n\t\t\t left->base.name, right->base.name,\n\t\t\t plane->base.id, plane->name,\n\t\t\t dflow->in_x, dflow->in_y, dflow->in_w, dflow->in_h,\n\t\t\t dflow->out_x, dflow->out_y, dflow->out_w, dflow->out_h);\n\n\terr = komeda_build_layer_data_flow(left, kplane_st, kcrtc_st, &l_dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_build_layer_data_flow(right, kplane_st, kcrtc_st, &r_dflow);\n\tif (err)\n\t\treturn err;\n\n\t \n\tkomeda_rotate_data_flow(dflow, dflow->rot);\n\n\t \n\tif (r_dflow.input.component == l_dflow.input.component)\n\t\treturn 0;\n\n\t \n\terr = komeda_merger_validate(pipe->merger, plane, kcrtc_st,\n\t\t\t\t     &l_dflow, &r_dflow, dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_compiz_set_input(pipe->compiz, kcrtc_st, dflow);\n\n\treturn err;\n}\n\n \nint komeda_build_wb_data_flow(struct komeda_layer *wb_layer,\n\t\t\t      struct drm_connector_state *conn_st,\n\t\t\t      struct komeda_crtc_state *kcrtc_st,\n\t\t\t      struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_connector *conn = conn_st->connector;\n\tint err;\n\n\terr = komeda_scaler_validate(conn, kcrtc_st, dflow);\n\tif (err)\n\t\treturn err;\n\n\treturn komeda_wb_layer_validate(wb_layer, conn_st, dflow);\n}\n\n \nint komeda_build_wb_split_data_flow(struct komeda_layer *wb_layer,\n\t\t\t\t    struct drm_connector_state *conn_st,\n\t\t\t\t    struct komeda_crtc_state *kcrtc_st,\n\t\t\t\t    struct komeda_data_flow_cfg *dflow)\n{\n\tstruct komeda_pipeline *pipe = wb_layer->base.pipeline;\n\tstruct drm_connector *conn = conn_st->connector;\n\tstruct komeda_data_flow_cfg l_dflow, r_dflow;\n\tint err;\n\n\terr = komeda_splitter_validate(pipe->splitter, conn_st,\n\t\t\t\t       dflow, &l_dflow, &r_dflow);\n\tif (err)\n\t\treturn err;\n\terr = komeda_scaler_validate(conn, kcrtc_st, &l_dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_scaler_validate(conn, kcrtc_st, &r_dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_merger_validate(pipe->merger, conn_st, kcrtc_st,\n\t\t\t\t     &l_dflow, &r_dflow, dflow);\n\tif (err)\n\t\treturn err;\n\n\treturn komeda_wb_layer_validate(wb_layer, conn_st, dflow);\n}\n\n \nint komeda_build_display_data_flow(struct komeda_crtc *kcrtc,\n\t\t\t\t   struct komeda_crtc_state *kcrtc_st)\n{\n\tstruct komeda_pipeline *master = kcrtc->master;\n\tstruct komeda_pipeline *slave  = kcrtc->slave;\n\tstruct komeda_data_flow_cfg m_dflow;  \n\tstruct komeda_data_flow_cfg s_dflow;  \n\tint err;\n\n\tmemset(&m_dflow, 0, sizeof(m_dflow));\n\tmemset(&s_dflow, 0, sizeof(s_dflow));\n\n\tif (slave && has_bit(slave->id, kcrtc_st->active_pipes)) {\n\t\terr = komeda_compiz_validate(slave->compiz, kcrtc_st, &s_dflow);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = komeda_compiz_set_input(master->compiz, kcrtc_st,\n\t\t\t\t\t      &s_dflow);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = komeda_compiz_validate(master->compiz, kcrtc_st, &m_dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_improc_validate(master->improc, kcrtc_st, &m_dflow);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_timing_ctrlr_validate(master->ctrlr, kcrtc_st, &m_dflow);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int\nkomeda_pipeline_unbound_components(struct komeda_pipeline *pipe,\n\t\t\t\t   struct komeda_pipeline_state *new)\n{\n\tstruct drm_atomic_state *drm_st = new->obj.state;\n\tstruct komeda_pipeline_state *old = priv_to_pipe_st(pipe->obj.state);\n\tstruct komeda_component_state *c_st;\n\tstruct komeda_component *c;\n\tu32 id;\n\tunsigned long disabling_comps;\n\n\tWARN_ON(!old);\n\n\tdisabling_comps = (~new->active_comps) & old->active_comps;\n\n\t \n\tfor_each_set_bit(id, &disabling_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\t\tc_st = komeda_component_get_state_and_set_user(c,\n\t\t\t\tdrm_st, NULL, new->crtc);\n\t\tif (PTR_ERR(c_st) == -EDEADLK)\n\t\t\treturn -EDEADLK;\n\t\tWARN_ON(IS_ERR(c_st));\n\t}\n\n\treturn 0;\n}\n\n \nint komeda_release_unclaimed_resources(struct komeda_pipeline *pipe,\n\t\t\t\t       struct komeda_crtc_state *kcrtc_st)\n{\n\tstruct drm_atomic_state *drm_st = kcrtc_st->base.state;\n\tstruct komeda_pipeline_state *st;\n\n\t \n\tif (!pipe || !has_bit(pipe->id, kcrtc_st->affected_pipes))\n\t\treturn 0;\n\n\tif (has_bit(pipe->id, kcrtc_st->active_pipes))\n\t\tst = komeda_pipeline_get_new_state(pipe, drm_st);\n\telse\n\t\tst = komeda_pipeline_get_state_and_set_crtc(pipe, drm_st, NULL);\n\n\tif (WARN_ON(IS_ERR_OR_NULL(st)))\n\t\treturn -EINVAL;\n\n\treturn komeda_pipeline_unbound_components(pipe, st);\n\n}\n\n \nbool komeda_pipeline_disable(struct komeda_pipeline *pipe,\n\t\t\t     struct drm_atomic_state *old_state)\n{\n\tstruct komeda_pipeline_state *old;\n\tstruct komeda_component *c;\n\tstruct komeda_component_state *c_st;\n\tu32 id;\n\tunsigned long disabling_comps;\n\n\told = komeda_pipeline_get_old_state(pipe, old_state);\n\n\tdisabling_comps = old->active_comps &\n\t\t\t  (~pipe->standalone_disabled_comps);\n\tif (!disabling_comps)\n\t\tdisabling_comps = old->active_comps &\n\t\t\t\t  pipe->standalone_disabled_comps;\n\n\tDRM_DEBUG_ATOMIC(\"PIPE%d: active_comps: 0x%x, disabling_comps: 0x%lx.\\n\",\n\t\t\t pipe->id, old->active_comps, disabling_comps);\n\n\tfor_each_set_bit(id, &disabling_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\t\tc_st = priv_to_comp_st(c->obj.state);\n\n\t\t \n\t\tc_st->changed_active_inputs |= c_st->active_inputs;\n\n\t\tc->funcs->disable(c);\n\t}\n\n\t \n\told->active_comps &= ~disabling_comps;\n\n\treturn old->active_comps ? true : false;\n}\n\nvoid komeda_pipeline_update(struct komeda_pipeline *pipe,\n\t\t\t    struct drm_atomic_state *old_state)\n{\n\tstruct komeda_pipeline_state *new = priv_to_pipe_st(pipe->obj.state);\n\tstruct komeda_pipeline_state *old;\n\tstruct komeda_component *c;\n\tu32 id;\n\tunsigned long changed_comps;\n\n\told = komeda_pipeline_get_old_state(pipe, old_state);\n\n\tchanged_comps = new->active_comps | old->active_comps;\n\n\tDRM_DEBUG_ATOMIC(\"PIPE%d: active_comps: 0x%x, changed: 0x%lx.\\n\",\n\t\t\t pipe->id, new->active_comps, changed_comps);\n\n\tfor_each_set_bit(id, &changed_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\n\t\tif (new->active_comps & BIT(c->id))\n\t\t\tc->funcs->update(c, priv_to_comp_st(c->obj.state));\n\t\telse\n\t\t\tc->funcs->disable(c);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}