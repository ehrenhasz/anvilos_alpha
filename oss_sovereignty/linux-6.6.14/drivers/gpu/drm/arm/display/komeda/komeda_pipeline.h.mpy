{
  "module_name": "komeda_pipeline.h",
  "hash_id": "d9a2d05c93a8087b1216851a7624318bfa517bc0f173abde49aec19ac099c80a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_pipeline.h",
  "human_readable_source": " \n \n#ifndef _KOMEDA_PIPELINE_H_\n#define _KOMEDA_PIPELINE_H_\n\n#include <linux/types.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include \"malidp_utils.h\"\n#include \"komeda_color_mgmt.h\"\n\n#define KOMEDA_MAX_PIPELINES\t\t2\n#define KOMEDA_PIPELINE_MAX_LAYERS\t4\n#define KOMEDA_PIPELINE_MAX_SCALERS\t2\n#define KOMEDA_COMPONENT_N_INPUTS\t5\n\n \nenum {\n\tKOMEDA_COMPONENT_LAYER0\t\t= 0,\n\tKOMEDA_COMPONENT_LAYER1\t\t= 1,\n\tKOMEDA_COMPONENT_LAYER2\t\t= 2,\n\tKOMEDA_COMPONENT_LAYER3\t\t= 3,\n\tKOMEDA_COMPONENT_WB_LAYER\t= 7,  \n\tKOMEDA_COMPONENT_SCALER0\t= 8,\n\tKOMEDA_COMPONENT_SCALER1\t= 9,\n\tKOMEDA_COMPONENT_SPLITTER\t= 12,\n\tKOMEDA_COMPONENT_MERGER\t\t= 14,\n\tKOMEDA_COMPONENT_COMPIZ0\t= 16,  \n\tKOMEDA_COMPONENT_COMPIZ1\t= 17,\n\tKOMEDA_COMPONENT_IPS0\t\t= 20,  \n\tKOMEDA_COMPONENT_IPS1\t\t= 21,\n\tKOMEDA_COMPONENT_TIMING_CTRLR\t= 22,  \n};\n\n#define KOMEDA_PIPELINE_LAYERS\t\t(BIT(KOMEDA_COMPONENT_LAYER0) |\\\n\t\t\t\t\t BIT(KOMEDA_COMPONENT_LAYER1) |\\\n\t\t\t\t\t BIT(KOMEDA_COMPONENT_LAYER2) |\\\n\t\t\t\t\t BIT(KOMEDA_COMPONENT_LAYER3))\n\n#define KOMEDA_PIPELINE_SCALERS\t\t(BIT(KOMEDA_COMPONENT_SCALER0) |\\\n\t\t\t\t\t BIT(KOMEDA_COMPONENT_SCALER1))\n\n#define KOMEDA_PIPELINE_COMPIZS\t\t(BIT(KOMEDA_COMPONENT_COMPIZ0) |\\\n\t\t\t\t\t BIT(KOMEDA_COMPONENT_COMPIZ1))\n\n#define KOMEDA_PIPELINE_IMPROCS\t\t(BIT(KOMEDA_COMPONENT_IPS0) |\\\n\t\t\t\t\t BIT(KOMEDA_COMPONENT_IPS1))\nstruct komeda_component;\nstruct komeda_component_state;\n\n \nstruct komeda_component_funcs {\n\t \n\tint (*validate)(struct komeda_component *c,\n\t\t\tstruct komeda_component_state *state);\n\t \n\tvoid (*update)(struct komeda_component *c,\n\t\t       struct komeda_component_state *state);\n\t \n\tvoid (*disable)(struct komeda_component *c);\n\t \n\tvoid (*dump_register)(struct komeda_component *c, struct seq_file *seq);\n};\n\n \nstruct komeda_component {\n\t \n\tstruct drm_private_obj obj;\n\t \n\tstruct komeda_pipeline *pipeline;\n\t \n\tchar name[32];\n\t \n\tu32 __iomem *reg;\n\t \n\tu32 id;\n\t \n\tu32 hw_id;\n\n\t \n\tu8 max_active_inputs;\n\t \n\tu8 max_active_outputs;\n\t \n\tu32 supported_inputs;\n\t \n\tu32 supported_outputs;\n\n\t \n\tconst struct komeda_component_funcs *funcs;\n};\n\n \nstruct komeda_component_output {\n\t \n\tstruct komeda_component *component;\n\t \n\tu8 output_port;\n};\n\n \nstruct komeda_component_state {\n\t \n\tstruct drm_private_state obj;\n\t \n\tstruct komeda_component *component;\n\t \n\tunion {\n\t\t \n\t\tstruct drm_crtc *crtc;\n\t\t \n\t\tstruct drm_plane *plane;\n\t\t \n\t\tstruct drm_connector *wb_conn;\n\t\tvoid *binding_user;\n\t};\n\n\t \n\tu16 active_inputs;\n\t \n\tu16 changed_active_inputs;\n\t \n\tu16 affected_inputs;\n\t \n\tstruct komeda_component_output inputs[KOMEDA_COMPONENT_N_INPUTS];\n};\n\nstatic inline u16 component_disabling_inputs(struct komeda_component_state *st)\n{\n\treturn st->affected_inputs ^ st->active_inputs;\n}\n\nstatic inline u16 component_changed_inputs(struct komeda_component_state *st)\n{\n\treturn component_disabling_inputs(st) | st->changed_active_inputs;\n}\n\n#define for_each_changed_input(st, i)\t\\\n\tfor ((i) = 0; (i) < (st)->component->max_active_inputs; (i)++)\t\\\n\t\tif (has_bit((i), component_changed_inputs(st)))\n\n#define to_comp(__c)\t(((__c) == NULL) ? NULL : &((__c)->base))\n#define to_cpos(__c)\t((struct komeda_component **)&(__c))\n\nstruct komeda_layer {\n\tstruct komeda_component base;\n\t \n\tstruct malidp_range hsize_in, vsize_in;\n\tu32 layer_type;  \n\tu32 line_sz;\n\tu32 yuv_line_sz;  \n\tu32 supported_rots;\n\t \n\tstruct komeda_layer *right;\n};\n\nstruct komeda_layer_state {\n\tstruct komeda_component_state base;\n\t \n\tu16 hsize, vsize;\n\tu32 rot;\n\tu16 afbc_crop_l;\n\tu16 afbc_crop_r;\n\tu16 afbc_crop_t;\n\tu16 afbc_crop_b;\n\tdma_addr_t addr[3];\n};\n\nstruct komeda_scaler {\n\tstruct komeda_component base;\n\tstruct malidp_range hsize, vsize;\n\tu32 max_upscaling;\n\tu32 max_downscaling;\n\tu8 scaling_split_overlap;  \n\tu8 enh_split_overlap;  \n};\n\nstruct komeda_scaler_state {\n\tstruct komeda_component_state base;\n\tu16 hsize_in, vsize_in;\n\tu16 hsize_out, vsize_out;\n\tu16 total_hsize_in, total_vsize_in;\n\tu16 total_hsize_out;  \n\tu16 left_crop, right_crop;\n\tu8 en_scaling : 1,\n\t   en_alpha : 1,  \n\t   en_img_enhancement : 1,\n\t   en_split : 1,\n\t   right_part : 1;  \n};\n\nstruct komeda_compiz {\n\tstruct komeda_component base;\n\tstruct malidp_range hsize, vsize;\n};\n\nstruct komeda_compiz_input_cfg {\n\tu16 hsize, vsize;\n\tu16 hoffset, voffset;\n\tu8 pixel_blend_mode, layer_alpha;\n};\n\nstruct komeda_compiz_state {\n\tstruct komeda_component_state base;\n\t \n\tu16 hsize, vsize;\n\tstruct komeda_compiz_input_cfg cins[KOMEDA_COMPONENT_N_INPUTS];\n};\n\nstruct komeda_merger {\n\tstruct komeda_component base;\n\tstruct malidp_range hsize_merged;\n\tstruct malidp_range vsize_merged;\n};\n\nstruct komeda_merger_state {\n\tstruct komeda_component_state base;\n\tu16 hsize_merged;\n\tu16 vsize_merged;\n};\n\nstruct komeda_splitter {\n\tstruct komeda_component base;\n\tstruct malidp_range hsize, vsize;\n};\n\nstruct komeda_splitter_state {\n\tstruct komeda_component_state base;\n\tu16 hsize, vsize;\n\tu16 overlap;\n};\n\nstruct komeda_improc {\n\tstruct komeda_component base;\n\tu32 supported_color_formats;   \n\tu32 supported_color_depths;  \n\tu8 supports_degamma : 1;\n\tu8 supports_csc : 1;\n\tu8 supports_gamma : 1;\n};\n\nstruct komeda_improc_state {\n\tstruct komeda_component_state base;\n\tu8 color_format, color_depth;\n\tu16 hsize, vsize;\n\tu32 fgamma_coeffs[KOMEDA_N_GAMMA_COEFFS];\n\tu32 ctm_coeffs[KOMEDA_N_CTM_COEFFS];\n};\n\n \nstruct komeda_timing_ctrlr {\n\tstruct komeda_component base;\n\tu8 supports_dual_link : 1;\n};\n\nstruct komeda_timing_ctrlr_state {\n\tstruct komeda_component_state base;\n};\n\n \nstruct komeda_data_flow_cfg {\n\tstruct komeda_component_output input;\n\tu16 in_x, in_y, in_w, in_h;\n\tu32 out_x, out_y, out_w, out_h;\n\tu16 total_in_h, total_in_w;\n\tu16 total_out_w;\n\tu16 left_crop, right_crop, overlap;\n\tu32 rot;\n\tint blending_zorder;\n\tu8 pixel_blend_mode, layer_alpha;\n\tu8 en_scaling : 1,\n\t   en_img_enhancement : 1,\n\t   en_split : 1,\n\t   is_yuv : 1,\n\t   right_part : 1;  \n};\n\nstruct komeda_pipeline_funcs {\n\t \n\tint (*downscaling_clk_check)(struct komeda_pipeline *pipe,\n\t\t\t\t     struct drm_display_mode *mode,\n\t\t\t\t     unsigned long aclk_rate,\n\t\t\t\t     struct komeda_data_flow_cfg *dflow);\n\t \n\tvoid (*dump_register)(struct komeda_pipeline *pipe,\n\t\t\t      struct seq_file *sf);\n};\n\n \nstruct komeda_pipeline {\n\t \n\tstruct drm_private_obj obj;\n\t \n\tstruct komeda_dev *mdev;\n\t \n\tstruct clk *pxlclk;\n\t \n\tint id;\n\t \n\tu32 avail_comps;\n\t \n\tu32 standalone_disabled_comps;\n\t \n\tint n_layers;\n\t \n\tstruct komeda_layer *layers[KOMEDA_PIPELINE_MAX_LAYERS];\n\t \n\tint n_scalers;\n\t \n\tstruct komeda_scaler *scalers[KOMEDA_PIPELINE_MAX_SCALERS];\n\t \n\tstruct komeda_compiz *compiz;\n\t \n\tstruct komeda_splitter *splitter;\n\t \n\tstruct komeda_merger *merger;\n\t \n\tstruct komeda_layer  *wb_layer;\n\t \n\tstruct komeda_improc *improc;\n\t \n\tstruct komeda_timing_ctrlr *ctrlr;\n\t \n\tconst struct komeda_pipeline_funcs *funcs;\n\n\t \n\tstruct device_node *of_node;\n\t \n\tstruct device_node *of_output_port;\n\t \n\tstruct device_node *of_output_links[2];\n\t \n\tbool dual_link;\n};\n\n \nstruct komeda_pipeline_state {\n\t \n\tstruct drm_private_state obj;\n\t \n\tstruct komeda_pipeline *pipe;\n\t \n\tstruct drm_crtc *crtc;\n\t \n\tu32 active_comps;\n};\n\n#define to_layer(c)\tcontainer_of(c, struct komeda_layer, base)\n#define to_compiz(c)\tcontainer_of(c, struct komeda_compiz, base)\n#define to_scaler(c)\tcontainer_of(c, struct komeda_scaler, base)\n#define to_splitter(c)\tcontainer_of(c, struct komeda_splitter, base)\n#define to_merger(c)\tcontainer_of(c, struct komeda_merger, base)\n#define to_improc(c)\tcontainer_of(c, struct komeda_improc, base)\n#define to_ctrlr(c)\tcontainer_of(c, struct komeda_timing_ctrlr, base)\n\n#define to_layer_st(c)\tcontainer_of(c, struct komeda_layer_state, base)\n#define to_compiz_st(c)\tcontainer_of(c, struct komeda_compiz_state, base)\n#define to_scaler_st(c)\tcontainer_of(c, struct komeda_scaler_state, base)\n#define to_splitter_st(c) container_of(c, struct komeda_splitter_state, base)\n#define to_merger_st(c)\tcontainer_of(c, struct komeda_merger_state, base)\n#define to_improc_st(c)\tcontainer_of(c, struct komeda_improc_state, base)\n#define to_ctrlr_st(c)\tcontainer_of(c, struct komeda_timing_ctrlr_state, base)\n\n#define priv_to_comp_st(o) container_of(o, struct komeda_component_state, obj)\n#define priv_to_pipe_st(o) container_of(o, struct komeda_pipeline_state, obj)\n\n \nstruct komeda_pipeline *\nkomeda_pipeline_add(struct komeda_dev *mdev, size_t size,\n\t\t    const struct komeda_pipeline_funcs *funcs);\nvoid komeda_pipeline_destroy(struct komeda_dev *mdev,\n\t\t\t     struct komeda_pipeline *pipe);\nstruct komeda_pipeline *\nkomeda_pipeline_get_slave(struct komeda_pipeline *master);\nint komeda_assemble_pipelines(struct komeda_dev *mdev);\nstruct komeda_component *\nkomeda_pipeline_get_component(struct komeda_pipeline *pipe, int id);\nstruct komeda_component *\nkomeda_pipeline_get_first_component(struct komeda_pipeline *pipe,\n\t\t\t\t    u32 comp_mask);\n\nvoid komeda_pipeline_dump_register(struct komeda_pipeline *pipe,\n\t\t\t\t   struct seq_file *sf);\n\n \nextern __printf(10, 11)\nstruct komeda_component *\nkomeda_component_add(struct komeda_pipeline *pipe,\n\t\t     size_t comp_sz, u32 id, u32 hw_id,\n\t\t     const struct komeda_component_funcs *funcs,\n\t\t     u8 max_active_inputs, u32 supported_inputs,\n\t\t     u8 max_active_outputs, u32 __iomem *reg,\n\t\t     const char *name_fmt, ...);\n\nvoid komeda_component_destroy(struct komeda_dev *mdev,\n\t\t\t      struct komeda_component *c);\n\nstatic inline struct komeda_component *\nkomeda_component_pickup_output(struct komeda_component *c, u32 avail_comps)\n{\n\tu32 avail_inputs = c->supported_outputs & (avail_comps);\n\n\treturn komeda_pipeline_get_first_component(c->pipeline, avail_inputs);\n}\n\nstruct komeda_plane_state;\nstruct komeda_crtc_state;\nstruct komeda_crtc;\n\nvoid pipeline_composition_size(struct komeda_crtc_state *kcrtc_st,\n\t\t\t       u16 *hsize, u16 *vsize);\n\nint komeda_build_layer_data_flow(struct komeda_layer *layer,\n\t\t\t\t struct komeda_plane_state *kplane_st,\n\t\t\t\t struct komeda_crtc_state *kcrtc_st,\n\t\t\t\t struct komeda_data_flow_cfg *dflow);\nint komeda_build_wb_data_flow(struct komeda_layer *wb_layer,\n\t\t\t      struct drm_connector_state *conn_st,\n\t\t\t      struct komeda_crtc_state *kcrtc_st,\n\t\t\t      struct komeda_data_flow_cfg *dflow);\nint komeda_build_display_data_flow(struct komeda_crtc *kcrtc,\n\t\t\t\t   struct komeda_crtc_state *kcrtc_st);\n\nint komeda_build_layer_split_data_flow(struct komeda_layer *left,\n\t\t\t\t       struct komeda_plane_state *kplane_st,\n\t\t\t\t       struct komeda_crtc_state *kcrtc_st,\n\t\t\t\t       struct komeda_data_flow_cfg *dflow);\nint komeda_build_wb_split_data_flow(struct komeda_layer *wb_layer,\n\t\t\t\t    struct drm_connector_state *conn_st,\n\t\t\t\t    struct komeda_crtc_state *kcrtc_st,\n\t\t\t\t    struct komeda_data_flow_cfg *dflow);\n\nint komeda_release_unclaimed_resources(struct komeda_pipeline *pipe,\n\t\t\t\t       struct komeda_crtc_state *kcrtc_st);\n\nstruct komeda_pipeline_state *\nkomeda_pipeline_get_old_state(struct komeda_pipeline *pipe,\n\t\t\t      struct drm_atomic_state *state);\nbool komeda_pipeline_disable(struct komeda_pipeline *pipe,\n\t\t\t     struct drm_atomic_state *old_state);\nvoid komeda_pipeline_update(struct komeda_pipeline *pipe,\n\t\t\t    struct drm_atomic_state *old_state);\n\nvoid komeda_complete_data_flow_cfg(struct komeda_layer *layer,\n\t\t\t\t   struct komeda_data_flow_cfg *dflow,\n\t\t\t\t   struct drm_framebuffer *fb);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}