{
  "module_name": "d71_component.c",
  "hash_id": "9dc28b9a0ef4243f6428201ff2c9164bb5fa6a669b389081e160b70871374cfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/d71/d71_component.c",
  "human_readable_source": "\n \n#include \"d71_dev.h\"\n#include \"komeda_kms.h\"\n#include \"malidp_io.h\"\n#include \"komeda_framebuffer.h\"\n#include \"komeda_color_mgmt.h\"\n\nstatic void get_resources_id(u32 hw_id, u32 *pipe_id, u32 *comp_id)\n{\n\tu32 id = BLOCK_INFO_BLK_ID(hw_id);\n\tu32 pipe = id;\n\n\tswitch (BLOCK_INFO_BLK_TYPE(hw_id)) {\n\tcase D71_BLK_TYPE_LPU_WB_LAYER:\n\t\tid = KOMEDA_COMPONENT_WB_LAYER;\n\t\tbreak;\n\tcase D71_BLK_TYPE_CU_SPLITTER:\n\t\tid = KOMEDA_COMPONENT_SPLITTER;\n\t\tbreak;\n\tcase D71_BLK_TYPE_CU_SCALER:\n\t\tpipe = id / D71_PIPELINE_MAX_SCALERS;\n\t\tid %= D71_PIPELINE_MAX_SCALERS;\n\t\tid += KOMEDA_COMPONENT_SCALER0;\n\t\tbreak;\n\tcase D71_BLK_TYPE_CU:\n\t\tid += KOMEDA_COMPONENT_COMPIZ0;\n\t\tbreak;\n\tcase D71_BLK_TYPE_LPU_LAYER:\n\t\tpipe = id / D71_PIPELINE_MAX_LAYERS;\n\t\tid %= D71_PIPELINE_MAX_LAYERS;\n\t\tid += KOMEDA_COMPONENT_LAYER0;\n\t\tbreak;\n\tcase D71_BLK_TYPE_DOU_IPS:\n\t\tid += KOMEDA_COMPONENT_IPS0;\n\t\tbreak;\n\tcase D71_BLK_TYPE_CU_MERGER:\n\t\tid = KOMEDA_COMPONENT_MERGER;\n\t\tbreak;\n\tcase D71_BLK_TYPE_DOU:\n\t\tid = KOMEDA_COMPONENT_TIMING_CTRLR;\n\t\tbreak;\n\tdefault:\n\t\tid = 0xFFFFFFFF;\n\t}\n\n\tif (comp_id)\n\t\t*comp_id = id;\n\n\tif (pipe_id)\n\t\t*pipe_id = pipe;\n}\n\nstatic u32 get_valid_inputs(struct block_header *blk)\n{\n\tu32 valid_inputs = 0, comp_id;\n\tint i;\n\n\tfor (i = 0; i < PIPELINE_INFO_N_VALID_INPUTS(blk->pipeline_info); i++) {\n\t\tget_resources_id(blk->input_ids[i], NULL, &comp_id);\n\t\tif (comp_id == 0xFFFFFFFF)\n\t\t\tcontinue;\n\t\tvalid_inputs |= BIT(comp_id);\n\t}\n\n\treturn valid_inputs;\n}\n\nstatic void get_values_from_reg(void __iomem *reg, u32 offset,\n\t\t\t\tu32 count, u32 *val)\n{\n\tu32 i, addr;\n\n\tfor (i = 0; i < count; i++) {\n\t\taddr = offset + (i << 2);\n\t\t \n\t\tif (addr != 0xA4)\n\t\t\tval[i] = malidp_read32(reg, addr);\n\t\telse\n\t\t\tval[i] = 0xDEADDEAD;\n\t}\n}\n\nstatic void dump_block_header(struct seq_file *sf, void __iomem *reg)\n{\n\tstruct block_header hdr;\n\tu32 i, n_input, n_output;\n\n\td71_read_block_header(reg, &hdr);\n\tseq_printf(sf, \"BLOCK_INFO:\\t\\t0x%X\\n\", hdr.block_info);\n\tseq_printf(sf, \"PIPELINE_INFO:\\t\\t0x%X\\n\", hdr.pipeline_info);\n\n\tn_output = PIPELINE_INFO_N_OUTPUTS(hdr.pipeline_info);\n\tn_input  = PIPELINE_INFO_N_VALID_INPUTS(hdr.pipeline_info);\n\n\tfor (i = 0; i < n_input; i++)\n\t\tseq_printf(sf, \"VALID_INPUT_ID%u:\\t0x%X\\n\",\n\t\t\t   i, hdr.input_ids[i]);\n\n\tfor (i = 0; i < n_output; i++)\n\t\tseq_printf(sf, \"OUTPUT_ID%u:\\t\\t0x%X\\n\",\n\t\t\t   i, hdr.output_ids[i]);\n}\n\n \nstatic u32 __get_blk_line_size(struct d71_dev *d71, u32 __iomem *reg,\n\t\t\t       u32 max_default)\n{\n\tif (!d71->periph_addr)\n\t\tmax_default = malidp_read32(reg, BLK_MAX_LINE_SIZE);\n\n\treturn max_default;\n}\n\nstatic u32 get_blk_line_size(struct d71_dev *d71, u32 __iomem *reg)\n{\n\treturn __get_blk_line_size(d71, reg, d71->max_line_size);\n}\n\nstatic u32 to_rot_ctrl(u32 rot)\n{\n\tu32 lr_ctrl = 0;\n\n\tswitch (rot & DRM_MODE_ROTATE_MASK) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tlr_ctrl |= L_ROT(L_ROT_R0);\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\tlr_ctrl |= L_ROT(L_ROT_R90);\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\tlr_ctrl |= L_ROT(L_ROT_R180);\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\tlr_ctrl |= L_ROT(L_ROT_R270);\n\t\tbreak;\n\t}\n\n\tif (rot & DRM_MODE_REFLECT_X)\n\t\tlr_ctrl |= L_HFLIP;\n\tif (rot & DRM_MODE_REFLECT_Y)\n\t\tlr_ctrl |= L_VFLIP;\n\n\treturn lr_ctrl;\n}\n\nstatic u32 to_ad_ctrl(u64 modifier)\n{\n\tu32 afbc_ctrl = AD_AEN;\n\n\tif (!modifier)\n\t\treturn 0;\n\n\tif ((modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK) ==\n\t    AFBC_FORMAT_MOD_BLOCK_SIZE_32x8)\n\t\tafbc_ctrl |= AD_WB;\n\n\tif (modifier & AFBC_FORMAT_MOD_YTR)\n\t\tafbc_ctrl |= AD_YT;\n\tif (modifier & AFBC_FORMAT_MOD_SPLIT)\n\t\tafbc_ctrl |= AD_BS;\n\tif (modifier & AFBC_FORMAT_MOD_TILED)\n\t\tafbc_ctrl |= AD_TH;\n\n\treturn afbc_ctrl;\n}\n\nstatic inline u32 to_d71_input_id(struct komeda_component_state *st, int idx)\n{\n\tstruct komeda_component_output *input = &st->inputs[idx];\n\n\t \n\tif (has_bit(idx, st->active_inputs))\n\t\treturn input->component->hw_id + input->output_port;\n\telse\n\t\treturn 0;\n}\n\nstatic void d71_layer_update_fb(struct komeda_component *c,\n\t\t\t\tstruct komeda_fb *kfb,\n\t\t\t\tdma_addr_t *addr)\n{\n\tstruct drm_framebuffer *fb = &kfb->base;\n\tconst struct drm_format_info *info = fb->format;\n\tu32 __iomem *reg = c->reg;\n\tint block_h;\n\n\tif (info->num_planes > 2)\n\t\tmalidp_write64(reg, BLK_P2_PTR_LOW, addr[2]);\n\n\tif (info->num_planes > 1) {\n\t\tblock_h = drm_format_info_block_height(info, 1);\n\t\tmalidp_write32(reg, BLK_P1_STRIDE, fb->pitches[1] * block_h);\n\t\tmalidp_write64(reg, BLK_P1_PTR_LOW, addr[1]);\n\t}\n\n\tblock_h = drm_format_info_block_height(info, 0);\n\tmalidp_write32(reg, BLK_P0_STRIDE, fb->pitches[0] * block_h);\n\tmalidp_write64(reg, BLK_P0_PTR_LOW, addr[0]);\n\tmalidp_write32(reg, LAYER_FMT, kfb->format_caps->hw_id);\n}\n\nstatic void d71_layer_disable(struct komeda_component *c)\n{\n\tmalidp_write32_mask(c->reg, BLK_CONTROL, L_EN, 0);\n}\n\nstatic void d71_layer_update(struct komeda_component *c,\n\t\t\t     struct komeda_component_state *state)\n{\n\tstruct komeda_layer_state *st = to_layer_st(state);\n\tstruct drm_plane_state *plane_st = state->plane->state;\n\tstruct drm_framebuffer *fb = plane_st->fb;\n\tstruct komeda_fb *kfb = to_kfb(fb);\n\tu32 __iomem *reg = c->reg;\n\tu32 ctrl_mask = L_EN | L_ROT(L_ROT_R270) | L_HFLIP | L_VFLIP | L_TBU_EN;\n\tu32 ctrl = L_EN | to_rot_ctrl(st->rot);\n\n\td71_layer_update_fb(c, kfb, st->addr);\n\n\tmalidp_write32(reg, AD_CONTROL, to_ad_ctrl(fb->modifier));\n\tif (fb->modifier) {\n\t\tu64 addr;\n\n\t\tmalidp_write32(reg, LAYER_AD_H_CROP, HV_CROP(st->afbc_crop_l,\n\t\t\t\t\t\t\t     st->afbc_crop_r));\n\t\tmalidp_write32(reg, LAYER_AD_V_CROP, HV_CROP(st->afbc_crop_t,\n\t\t\t\t\t\t\t     st->afbc_crop_b));\n\t\t \n\t\tif (fb->modifier & AFBC_FORMAT_MOD_TILED)\n\t\t\taddr = st->addr[0] + kfb->offset_payload;\n\t\telse\n\t\t\taddr = st->addr[0] + kfb->afbc_size - 1;\n\n\t\tmalidp_write32(reg, BLK_P1_PTR_LOW, lower_32_bits(addr));\n\t\tmalidp_write32(reg, BLK_P1_PTR_HIGH, upper_32_bits(addr));\n\t}\n\n\tif (fb->format->is_yuv) {\n\t\tu32 upsampling = 0;\n\n\t\tswitch (kfb->format_caps->fourcc) {\n\t\tcase DRM_FORMAT_YUYV:\n\t\t\tupsampling = fb->modifier ? LR_CHI422_BILINEAR :\n\t\t\t\t     LR_CHI422_REPLICATION;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_UYVY:\n\t\t\tupsampling = LR_CHI422_REPLICATION;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_NV12:\n\t\tcase DRM_FORMAT_YUV420_8BIT:\n\t\tcase DRM_FORMAT_YUV420_10BIT:\n\t\tcase DRM_FORMAT_YUV420:\n\t\tcase DRM_FORMAT_P010:\n\t\t \n\t\t\tupsampling = LR_CHI420_JPEG;\n\t\t\tbreak;\n\t\tcase DRM_FORMAT_X0L2:\n\t\t\tupsampling = LR_CHI420_JPEG;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tmalidp_write32(reg, LAYER_R_CONTROL, upsampling);\n\t\tmalidp_write_group(reg, LAYER_YUV_RGB_COEFF0,\n\t\t\t\t   KOMEDA_N_YUV2RGB_COEFFS,\n\t\t\t\t   komeda_select_yuv2rgb_coeffs(\n\t\t\t\t\tplane_st->color_encoding,\n\t\t\t\t\tplane_st->color_range));\n\t}\n\n\tmalidp_write32(reg, BLK_IN_SIZE, HV_SIZE(st->hsize, st->vsize));\n\n\tif (kfb->is_va)\n\t\tctrl |= L_TBU_EN;\n\tmalidp_write32_mask(reg, BLK_CONTROL, ctrl_mask, ctrl);\n}\n\nstatic void d71_layer_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v[15], i;\n\tbool rich, rgb2rgb;\n\tchar *prefix;\n\n\tget_values_from_reg(c->reg, LAYER_INFO, 1, &v[14]);\n\tif (v[14] & 0x1) {\n\t\trich = true;\n\t\tprefix = \"LR_\";\n\t} else {\n\t\trich = false;\n\t\tprefix = \"LS_\";\n\t}\n\n\trgb2rgb = !!(v[14] & L_INFO_CM);\n\n\tdump_block_header(sf, c->reg);\n\n\tseq_printf(sf, \"%sLAYER_INFO:\\t\\t0x%X\\n\", prefix, v[14]);\n\n\tget_values_from_reg(c->reg, 0xD0, 1, v);\n\tseq_printf(sf, \"%sCONTROL:\\t\\t0x%X\\n\", prefix, v[0]);\n\tif (rich) {\n\t\tget_values_from_reg(c->reg, 0xD4, 1, v);\n\t\tseq_printf(sf, \"LR_RICH_CONTROL:\\t0x%X\\n\", v[0]);\n\t}\n\tget_values_from_reg(c->reg, 0xD8, 4, v);\n\tseq_printf(sf, \"%sFORMAT:\\t\\t0x%X\\n\", prefix, v[0]);\n\tseq_printf(sf, \"%sIT_COEFFTAB:\\t\\t0x%X\\n\", prefix, v[1]);\n\tseq_printf(sf, \"%sIN_SIZE:\\t\\t0x%X\\n\", prefix, v[2]);\n\tseq_printf(sf, \"%sPALPHA:\\t\\t0x%X\\n\", prefix, v[3]);\n\n\tget_values_from_reg(c->reg, 0x100, 3, v);\n\tseq_printf(sf, \"%sP0_PTR_LOW:\\t\\t0x%X\\n\", prefix, v[0]);\n\tseq_printf(sf, \"%sP0_PTR_HIGH:\\t\\t0x%X\\n\", prefix, v[1]);\n\tseq_printf(sf, \"%sP0_STRIDE:\\t\\t0x%X\\n\", prefix, v[2]);\n\n\tget_values_from_reg(c->reg, 0x110, 2, v);\n\tseq_printf(sf, \"%sP1_PTR_LOW:\\t\\t0x%X\\n\", prefix, v[0]);\n\tseq_printf(sf, \"%sP1_PTR_HIGH:\\t\\t0x%X\\n\", prefix, v[1]);\n\tif (rich) {\n\t\tget_values_from_reg(c->reg, 0x118, 1, v);\n\t\tseq_printf(sf, \"LR_P1_STRIDE:\\t\\t0x%X\\n\", v[0]);\n\n\t\tget_values_from_reg(c->reg, 0x120, 2, v);\n\t\tseq_printf(sf, \"LR_P2_PTR_LOW:\\t\\t0x%X\\n\", v[0]);\n\t\tseq_printf(sf, \"LR_P2_PTR_HIGH:\\t\\t0x%X\\n\", v[1]);\n\n\t\tget_values_from_reg(c->reg, 0x130, 12, v);\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tseq_printf(sf, \"LR_YUV_RGB_COEFF%u:\\t0x%X\\n\", i, v[i]);\n\t}\n\n\tif (rgb2rgb) {\n\t\tget_values_from_reg(c->reg, LAYER_RGB_RGB_COEFF0, 12, v);\n\t\tfor (i = 0; i < 12; i++)\n\t\t\tseq_printf(sf, \"LS_RGB_RGB_COEFF%u:\\t0x%X\\n\", i, v[i]);\n\t}\n\n\tget_values_from_reg(c->reg, 0x160, 3, v);\n\tseq_printf(sf, \"%sAD_CONTROL:\\t\\t0x%X\\n\", prefix, v[0]);\n\tseq_printf(sf, \"%sAD_H_CROP:\\t\\t0x%X\\n\", prefix, v[1]);\n\tseq_printf(sf, \"%sAD_V_CROP:\\t\\t0x%X\\n\", prefix, v[2]);\n}\n\nstatic int d71_layer_validate(struct komeda_component *c,\n\t\t\t      struct komeda_component_state *state)\n{\n\tstruct komeda_layer_state *st = to_layer_st(state);\n\tstruct komeda_layer *layer = to_layer(c);\n\tstruct drm_plane_state *plane_st;\n\tstruct drm_framebuffer *fb;\n\tu32 fourcc, line_sz, max_line_sz;\n\n\tplane_st = drm_atomic_get_new_plane_state(state->obj.state,\n\t\t\t\t\t\t  state->plane);\n\tfb = plane_st->fb;\n\tfourcc = fb->format->format;\n\n\tif (drm_rotation_90_or_270(st->rot))\n\t\tline_sz = st->vsize - st->afbc_crop_t - st->afbc_crop_b;\n\telse\n\t\tline_sz = st->hsize - st->afbc_crop_l - st->afbc_crop_r;\n\n\tif (fb->modifier) {\n\t\tif ((fb->modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK) ==\n\t\t\tAFBC_FORMAT_MOD_BLOCK_SIZE_32x8)\n\t\t\tmax_line_sz = layer->line_sz;\n\t\telse\n\t\t\tmax_line_sz = layer->line_sz / 2;\n\n\t\tif (line_sz > max_line_sz) {\n\t\t\tDRM_DEBUG_ATOMIC(\"afbc request line_sz: %d exceed the max afbc line_sz: %d.\\n\",\n\t\t\t\t\t line_sz, max_line_sz);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (fourcc == DRM_FORMAT_YUV420_10BIT && line_sz > 2046 && (st->afbc_crop_l % 4)) {\n\t\tDRM_DEBUG_ATOMIC(\"YUV420_10BIT input_hsize: %d exceed the max size 2046.\\n\",\n\t\t\t\t line_sz);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fourcc == DRM_FORMAT_X0L2 && line_sz > 2046 && (st->addr[0] % 16)) {\n\t\tDRM_DEBUG_ATOMIC(\"X0L2 input_hsize: %d exceed the max size 2046.\\n\",\n\t\t\t\t line_sz);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct komeda_component_funcs d71_layer_funcs = {\n\t.validate\t= d71_layer_validate,\n\t.update\t\t= d71_layer_update,\n\t.disable\t= d71_layer_disable,\n\t.dump_register\t= d71_layer_dump,\n};\n\nstatic int d71_layer_init(struct d71_dev *d71,\n\t\t\t  struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_layer *layer;\n\tu32 pipe_id, layer_id, layer_info;\n\n\tget_resources_id(blk->block_info, &pipe_id, &layer_id);\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*layer),\n\t\t\t\t layer_id,\n\t\t\t\t BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_layer_funcs, 0,\n\t\t\t\t get_valid_inputs(blk),\n\t\t\t\t 1, reg, \"LPU%d_LAYER%d\", pipe_id, layer_id);\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to add layer component\\n\");\n\t\treturn PTR_ERR(c);\n\t}\n\n\tlayer = to_layer(c);\n\tlayer_info = malidp_read32(reg, LAYER_INFO);\n\n\tif (layer_info & L_INFO_RF)\n\t\tlayer->layer_type = KOMEDA_FMT_RICH_LAYER;\n\telse\n\t\tlayer->layer_type = KOMEDA_FMT_SIMPLE_LAYER;\n\n\tif (!d71->periph_addr) {\n\t\t \n\t\tlayer->line_sz = malidp_read32(reg, BLK_MAX_LINE_SIZE);\n\t\tlayer->yuv_line_sz = L_INFO_YUV_MAX_LINESZ(layer_info);\n\t} else if (d71->max_line_size > 2048) {\n\t\t \n\t\tlayer->line_sz = d71->max_line_size;\n\t\tlayer->yuv_line_sz = layer->line_sz / 2;\n\t} else\t{\n\t\t \n\t\tif (layer->layer_type == KOMEDA_FMT_RICH_LAYER) {\n\t\t\t \n\t\t\tlayer->line_sz = d71->max_line_size * 2;\n\t\t\tlayer->yuv_line_sz = layer->line_sz / 2;\n\t\t} else {\n\t\t\tlayer->line_sz = d71->max_line_size;\n\t\t\tlayer->yuv_line_sz = 0;\n\t\t}\n\t}\n\n\tset_range(&layer->hsize_in, 4, layer->line_sz);\n\n\tset_range(&layer->vsize_in, 4, d71->max_vsize);\n\n\tmalidp_write32(reg, LAYER_PALPHA, D71_PALPHA_DEF_MAP);\n\n\tlayer->supported_rots = DRM_MODE_ROTATE_MASK | DRM_MODE_REFLECT_MASK;\n\n\treturn 0;\n}\n\nstatic void d71_wb_layer_update(struct komeda_component *c,\n\t\t\t\tstruct komeda_component_state *state)\n{\n\tstruct komeda_layer_state *st = to_layer_st(state);\n\tstruct drm_connector_state *conn_st = state->wb_conn->state;\n\tstruct komeda_fb *kfb = to_kfb(conn_st->writeback_job->fb);\n\tu32 ctrl = L_EN | LW_OFM, mask = L_EN | LW_OFM | LW_TBU_EN;\n\tu32 __iomem *reg = c->reg;\n\n\td71_layer_update_fb(c, kfb, st->addr);\n\n\tif (kfb->is_va)\n\t\tctrl |= LW_TBU_EN;\n\n\tmalidp_write32(reg, BLK_IN_SIZE, HV_SIZE(st->hsize, st->vsize));\n\tmalidp_write32(reg, BLK_INPUT_ID0, to_d71_input_id(state, 0));\n\tmalidp_write32_mask(reg, BLK_CONTROL, mask, ctrl);\n}\n\nstatic void d71_wb_layer_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v[12], i;\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, 0x80, 1, v);\n\tseq_printf(sf, \"LW_INPUT_ID0:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(c->reg, 0xD0, 3, v);\n\tseq_printf(sf, \"LW_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"LW_PROG_LINE:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"LW_FORMAT:\\t\\t0x%X\\n\", v[2]);\n\n\tget_values_from_reg(c->reg, 0xE0, 1, v);\n\tseq_printf(sf, \"LW_IN_SIZE:\\t\\t0x%X\\n\", v[0]);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tget_values_from_reg(c->reg, 0x100 + i * 0x10, 3, v);\n\t\tseq_printf(sf, \"LW_P%u_PTR_LOW:\\t\\t0x%X\\n\", i, v[0]);\n\t\tseq_printf(sf, \"LW_P%u_PTR_HIGH:\\t\\t0x%X\\n\", i, v[1]);\n\t\tseq_printf(sf, \"LW_P%u_STRIDE:\\t\\t0x%X\\n\", i, v[2]);\n\t}\n\n\tget_values_from_reg(c->reg, 0x130, 12, v);\n\tfor (i = 0; i < 12; i++)\n\t\tseq_printf(sf, \"LW_RGB_YUV_COEFF%u:\\t0x%X\\n\", i, v[i]);\n}\n\nstatic void d71_wb_layer_disable(struct komeda_component *c)\n{\n\tmalidp_write32(c->reg, BLK_INPUT_ID0, 0);\n\tmalidp_write32_mask(c->reg, BLK_CONTROL, L_EN, 0);\n}\n\nstatic const struct komeda_component_funcs d71_wb_layer_funcs = {\n\t.update\t\t= d71_wb_layer_update,\n\t.disable\t= d71_wb_layer_disable,\n\t.dump_register\t= d71_wb_layer_dump,\n};\n\nstatic int d71_wb_layer_init(struct d71_dev *d71,\n\t\t\t     struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_layer *wb_layer;\n\tu32 pipe_id, layer_id;\n\n\tget_resources_id(blk->block_info, &pipe_id, &layer_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*wb_layer),\n\t\t\t\t layer_id, BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_wb_layer_funcs,\n\t\t\t\t 1, get_valid_inputs(blk), 0, reg,\n\t\t\t\t \"LPU%d_LAYER_WR\", pipe_id);\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to add wb_layer component\\n\");\n\t\treturn PTR_ERR(c);\n\t}\n\n\twb_layer = to_layer(c);\n\twb_layer->layer_type = KOMEDA_FMT_WB_LAYER;\n\twb_layer->line_sz = get_blk_line_size(d71, reg);\n\twb_layer->yuv_line_sz = wb_layer->line_sz;\n\n\tset_range(&wb_layer->hsize_in, 64, wb_layer->line_sz);\n\tset_range(&wb_layer->vsize_in, 64, d71->max_vsize);\n\n\treturn 0;\n}\n\nstatic void d71_component_disable(struct komeda_component *c)\n{\n\tu32 __iomem *reg = c->reg;\n\tu32 i;\n\n\tmalidp_write32(reg, BLK_CONTROL, 0);\n\n\tfor (i = 0; i < c->max_active_inputs; i++) {\n\t\tmalidp_write32(reg, BLK_INPUT_ID0 + (i << 2), 0);\n\n\t\t \n\t\tif (has_bit(c->id, KOMEDA_PIPELINE_COMPIZS))\n\t\t\tmalidp_write32(reg, CU_INPUT0_CONTROL +\n\t\t\t\t       i * CU_PER_INPUT_REGS * 4,\n\t\t\t\t       CU_INPUT_CTRL_ALPHA(0xFF));\n\t}\n}\n\nstatic void compiz_enable_input(u32 __iomem *id_reg,\n\t\t\t\tu32 __iomem *cfg_reg,\n\t\t\t\tu32 input_hw_id,\n\t\t\t\tstruct komeda_compiz_input_cfg *cin)\n{\n\tu32 ctrl = CU_INPUT_CTRL_EN;\n\tu8 blend = cin->pixel_blend_mode;\n\n\tif (blend == DRM_MODE_BLEND_PIXEL_NONE)\n\t\tctrl |= CU_INPUT_CTRL_PAD;\n\telse if (blend == DRM_MODE_BLEND_PREMULTI)\n\t\tctrl |= CU_INPUT_CTRL_PMUL;\n\n\tctrl |= CU_INPUT_CTRL_ALPHA(cin->layer_alpha);\n\n\tmalidp_write32(id_reg, BLK_INPUT_ID0, input_hw_id);\n\n\tmalidp_write32(cfg_reg, CU_INPUT0_SIZE,\n\t\t       HV_SIZE(cin->hsize, cin->vsize));\n\tmalidp_write32(cfg_reg, CU_INPUT0_OFFSET,\n\t\t       HV_OFFSET(cin->hoffset, cin->voffset));\n\tmalidp_write32(cfg_reg, CU_INPUT0_CONTROL, ctrl);\n}\n\nstatic void d71_compiz_update(struct komeda_component *c,\n\t\t\t      struct komeda_component_state *state)\n{\n\tstruct komeda_compiz_state *st = to_compiz_st(state);\n\tu32 __iomem *reg = c->reg;\n\tu32 __iomem *id_reg, *cfg_reg;\n\tu32 index;\n\n\tfor_each_changed_input(state, index) {\n\t\tid_reg = reg + index;\n\t\tcfg_reg = reg + index * CU_PER_INPUT_REGS;\n\t\tif (state->active_inputs & BIT(index)) {\n\t\t\tcompiz_enable_input(id_reg, cfg_reg,\n\t\t\t\t\t    to_d71_input_id(state, index),\n\t\t\t\t\t    &st->cins[index]);\n\t\t} else {\n\t\t\tmalidp_write32(id_reg, BLK_INPUT_ID0, 0);\n\t\t\tmalidp_write32(cfg_reg, CU_INPUT0_CONTROL, 0);\n\t\t}\n\t}\n\n\tmalidp_write32(reg, BLK_SIZE, HV_SIZE(st->hsize, st->vsize));\n}\n\nstatic void d71_compiz_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v[8], i;\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, 0x80, 5, v);\n\tfor (i = 0; i < 5; i++)\n\t\tseq_printf(sf, \"CU_INPUT_ID%u:\\t\\t0x%X\\n\", i, v[i]);\n\n\tget_values_from_reg(c->reg, 0xA0, 5, v);\n\tseq_printf(sf, \"CU_IRQ_RAW_STATUS:\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"CU_IRQ_CLEAR:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"CU_IRQ_MASK:\\t\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"CU_IRQ_STATUS:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"CU_STATUS:\\t\\t0x%X\\n\", v[4]);\n\n\tget_values_from_reg(c->reg, 0xD0, 2, v);\n\tseq_printf(sf, \"CU_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"CU_SIZE:\\t\\t0x%X\\n\", v[1]);\n\n\tget_values_from_reg(c->reg, 0xDC, 1, v);\n\tseq_printf(sf, \"CU_BG_COLOR:\\t\\t0x%X\\n\", v[0]);\n\n\tfor (i = 0, v[4] = 0xE0; i < 5; i++, v[4] += 0x10) {\n\t\tget_values_from_reg(c->reg, v[4], 3, v);\n\t\tseq_printf(sf, \"CU_INPUT%u_SIZE:\\t\\t0x%X\\n\", i, v[0]);\n\t\tseq_printf(sf, \"CU_INPUT%u_OFFSET:\\t0x%X\\n\", i, v[1]);\n\t\tseq_printf(sf, \"CU_INPUT%u_CONTROL:\\t0x%X\\n\", i, v[2]);\n\t}\n\n\tget_values_from_reg(c->reg, 0x130, 2, v);\n\tseq_printf(sf, \"CU_USER_LOW:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"CU_USER_HIGH:\\t\\t0x%X\\n\", v[1]);\n}\n\nstatic const struct komeda_component_funcs d71_compiz_funcs = {\n\t.update\t\t= d71_compiz_update,\n\t.disable\t= d71_component_disable,\n\t.dump_register\t= d71_compiz_dump,\n};\n\nstatic int d71_compiz_init(struct d71_dev *d71,\n\t\t\t   struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_compiz *compiz;\n\tu32 pipe_id, comp_id;\n\n\tget_resources_id(blk->block_info, &pipe_id, &comp_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*compiz),\n\t\t\t\t comp_id,\n\t\t\t\t BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_compiz_funcs,\n\t\t\t\t CU_NUM_INPUT_IDS, get_valid_inputs(blk),\n\t\t\t\t CU_NUM_OUTPUT_IDS, reg,\n\t\t\t\t \"CU%d\", pipe_id);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\tcompiz = to_compiz(c);\n\n\tset_range(&compiz->hsize, 64, get_blk_line_size(d71, reg));\n\tset_range(&compiz->vsize, 64, d71->max_vsize);\n\n\treturn 0;\n}\n\nstatic void d71_scaler_update_filter_lut(u32 __iomem *reg, u32 hsize_in,\n\t\t\t\t\t u32 vsize_in, u32 hsize_out,\n\t\t\t\t\t u32 vsize_out)\n{\n\tu32 val = 0;\n\n\tif (hsize_in <= hsize_out)\n\t\tval  |= 0x62;\n\telse if (hsize_in <= (hsize_out + hsize_out / 2))\n\t\tval |= 0x63;\n\telse if (hsize_in <= hsize_out * 2)\n\t\tval |= 0x64;\n\telse if (hsize_in <= hsize_out * 2 + (hsize_out * 3) / 4)\n\t\tval |= 0x65;\n\telse\n\t\tval |= 0x66;\n\n\tif (vsize_in <= vsize_out)\n\t\tval  |= SC_VTSEL(0x6A);\n\telse if (vsize_in <= (vsize_out + vsize_out / 2))\n\t\tval |= SC_VTSEL(0x6B);\n\telse if (vsize_in <= vsize_out * 2)\n\t\tval |= SC_VTSEL(0x6C);\n\telse if (vsize_in <= vsize_out * 2 + vsize_out * 3 / 4)\n\t\tval |= SC_VTSEL(0x6D);\n\telse\n\t\tval |= SC_VTSEL(0x6E);\n\n\tmalidp_write32(reg, SC_COEFFTAB, val);\n}\n\nstatic void d71_scaler_update(struct komeda_component *c,\n\t\t\t      struct komeda_component_state *state)\n{\n\tstruct komeda_scaler_state *st = to_scaler_st(state);\n\tu32 __iomem *reg = c->reg;\n\tu32 init_ph, delta_ph, ctrl;\n\n\td71_scaler_update_filter_lut(reg, st->hsize_in, st->vsize_in,\n\t\t\t\t     st->hsize_out, st->vsize_out);\n\n\tmalidp_write32(reg, BLK_IN_SIZE, HV_SIZE(st->hsize_in, st->vsize_in));\n\tmalidp_write32(reg, SC_OUT_SIZE, HV_SIZE(st->hsize_out, st->vsize_out));\n\tmalidp_write32(reg, SC_H_CROP, HV_CROP(st->left_crop, st->right_crop));\n\n\t \n\tif (st->right_part) {\n\t\tu32 dst_a = st->total_hsize_out - st->hsize_out + st->left_crop;\n\n\t\tif (st->en_img_enhancement)\n\t\t\tdst_a -= 1;\n\n\t\tinit_ph = ((st->total_hsize_in * (2 * dst_a + 1) -\n\t\t\t    2 * st->total_hsize_out * (st->total_hsize_in -\n\t\t\t    st->hsize_in)) << 15) / st->total_hsize_out;\n\t} else {\n\t\tinit_ph = (st->total_hsize_in << 15) / st->total_hsize_out;\n\t}\n\n\tmalidp_write32(reg, SC_H_INIT_PH, init_ph);\n\n\tdelta_ph = (st->total_hsize_in << 16) / st->total_hsize_out;\n\tmalidp_write32(reg, SC_H_DELTA_PH, delta_ph);\n\n\tinit_ph = (st->total_vsize_in << 15) / st->vsize_out;\n\tmalidp_write32(reg, SC_V_INIT_PH, init_ph);\n\n\tdelta_ph = (st->total_vsize_in << 16) / st->vsize_out;\n\tmalidp_write32(reg, SC_V_DELTA_PH, delta_ph);\n\n\tctrl = 0;\n\tctrl |= st->en_scaling ? SC_CTRL_SCL : 0;\n\tctrl |= st->en_alpha ? SC_CTRL_AP : 0;\n\tctrl |= st->en_img_enhancement ? SC_CTRL_IENH : 0;\n\t \n\tif (st->en_split &&\n\t    state->inputs[0].component->id != KOMEDA_COMPONENT_SPLITTER)\n\t\tctrl |= SC_CTRL_LS;\n\n\tmalidp_write32(reg, BLK_CONTROL, ctrl);\n\tmalidp_write32(reg, BLK_INPUT_ID0, to_d71_input_id(state, 0));\n}\n\nstatic void d71_scaler_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v[10];\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, 0x80, 1, v);\n\tseq_printf(sf, \"SC_INPUT_ID0:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(c->reg, 0xD0, 1, v);\n\tseq_printf(sf, \"SC_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(c->reg, 0xDC, 9, v);\n\tseq_printf(sf, \"SC_COEFFTAB:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"SC_IN_SIZE:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"SC_OUT_SIZE:\\t\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"SC_H_CROP:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"SC_V_CROP:\\t\\t0x%X\\n\", v[4]);\n\tseq_printf(sf, \"SC_H_INIT_PH:\\t\\t0x%X\\n\", v[5]);\n\tseq_printf(sf, \"SC_H_DELTA_PH:\\t\\t0x%X\\n\", v[6]);\n\tseq_printf(sf, \"SC_V_INIT_PH:\\t\\t0x%X\\n\", v[7]);\n\tseq_printf(sf, \"SC_V_DELTA_PH:\\t\\t0x%X\\n\", v[8]);\n\n\tget_values_from_reg(c->reg, 0x130, 10, v);\n\tseq_printf(sf, \"SC_ENH_LIMITS:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"SC_ENH_COEFF0:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"SC_ENH_COEFF1:\\t\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"SC_ENH_COEFF2:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"SC_ENH_COEFF3:\\t\\t0x%X\\n\", v[4]);\n\tseq_printf(sf, \"SC_ENH_COEFF4:\\t\\t0x%X\\n\", v[5]);\n\tseq_printf(sf, \"SC_ENH_COEFF5:\\t\\t0x%X\\n\", v[6]);\n\tseq_printf(sf, \"SC_ENH_COEFF6:\\t\\t0x%X\\n\", v[7]);\n\tseq_printf(sf, \"SC_ENH_COEFF7:\\t\\t0x%X\\n\", v[8]);\n\tseq_printf(sf, \"SC_ENH_COEFF8:\\t\\t0x%X\\n\", v[9]);\n}\n\nstatic const struct komeda_component_funcs d71_scaler_funcs = {\n\t.update\t\t= d71_scaler_update,\n\t.disable\t= d71_component_disable,\n\t.dump_register\t= d71_scaler_dump,\n};\n\nstatic int d71_scaler_init(struct d71_dev *d71,\n\t\t\t   struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_scaler *scaler;\n\tu32 pipe_id, comp_id;\n\n\tget_resources_id(blk->block_info, &pipe_id, &comp_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*scaler),\n\t\t\t\t comp_id, BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_scaler_funcs,\n\t\t\t\t 1, get_valid_inputs(blk), 1, reg,\n\t\t\t\t \"CU%d_SCALER%d\",\n\t\t\t\t pipe_id, BLOCK_INFO_BLK_ID(blk->block_info));\n\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to initialize scaler\");\n\t\treturn PTR_ERR(c);\n\t}\n\n\tscaler = to_scaler(c);\n\tset_range(&scaler->hsize, 4, __get_blk_line_size(d71, reg, 2048));\n\tset_range(&scaler->vsize, 4, 4096);\n\tscaler->max_downscaling = 6;\n\tscaler->max_upscaling = 64;\n\tscaler->scaling_split_overlap = 8;\n\tscaler->enh_split_overlap = 1;\n\n\tmalidp_write32(c->reg, BLK_CONTROL, 0);\n\n\treturn 0;\n}\n\nstatic int d71_downscaling_clk_check(struct komeda_pipeline *pipe,\n\t\t\t\t     struct drm_display_mode *mode,\n\t\t\t\t     unsigned long aclk_rate,\n\t\t\t\t     struct komeda_data_flow_cfg *dflow)\n{\n\tu32 h_in = dflow->in_w;\n\tu32 v_in = dflow->in_h;\n\tu32 v_out = dflow->out_h;\n\tu64 fraction, denominator;\n\n\t \n\tif (v_in == v_out) {\n\t\tfraction = h_in;\n\t\tdenominator = mode->hdisplay - 3;\n\t} else {\n\t\tfraction = h_in * v_in;\n\t\tdenominator = (mode->htotal - 1) * v_out -  2 * v_in;\n\t}\n\n\treturn aclk_rate * denominator >= mode->crtc_clock * 1000 * fraction ?\n\t       0 : -EINVAL;\n}\n\nstatic void d71_splitter_update(struct komeda_component *c,\n\t\t\t\tstruct komeda_component_state *state)\n{\n\tstruct komeda_splitter_state *st = to_splitter_st(state);\n\tu32 __iomem *reg = c->reg;\n\n\tmalidp_write32(reg, BLK_INPUT_ID0, to_d71_input_id(state, 0));\n\tmalidp_write32(reg, BLK_SIZE, HV_SIZE(st->hsize, st->vsize));\n\tmalidp_write32(reg, SP_OVERLAP_SIZE, st->overlap & 0x1FFF);\n\tmalidp_write32(reg, BLK_CONTROL, BLK_CTRL_EN);\n}\n\nstatic void d71_splitter_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v[3];\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, BLK_INPUT_ID0, 1, v);\n\tseq_printf(sf, \"SP_INPUT_ID0:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(c->reg, BLK_CONTROL, 3, v);\n\tseq_printf(sf, \"SP_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"SP_SIZE:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"SP_OVERLAP_SIZE:\\t0x%X\\n\", v[2]);\n}\n\nstatic const struct komeda_component_funcs d71_splitter_funcs = {\n\t.update\t\t= d71_splitter_update,\n\t.disable\t= d71_component_disable,\n\t.dump_register\t= d71_splitter_dump,\n};\n\nstatic int d71_splitter_init(struct d71_dev *d71,\n\t\t\t     struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_splitter *splitter;\n\tu32 pipe_id, comp_id;\n\n\tget_resources_id(blk->block_info, &pipe_id, &comp_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*splitter),\n\t\t\t\t comp_id,\n\t\t\t\t BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_splitter_funcs,\n\t\t\t\t 1, get_valid_inputs(blk), 2, reg,\n\t\t\t\t \"CU%d_SPLITTER\", pipe_id);\n\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to initialize splitter\");\n\t\treturn -1;\n\t}\n\n\tsplitter = to_splitter(c);\n\n\tset_range(&splitter->hsize, 4, get_blk_line_size(d71, reg));\n\tset_range(&splitter->vsize, 4, d71->max_vsize);\n\n\treturn 0;\n}\n\nstatic void d71_merger_update(struct komeda_component *c,\n\t\t\t      struct komeda_component_state *state)\n{\n\tstruct komeda_merger_state *st = to_merger_st(state);\n\tu32 __iomem *reg = c->reg;\n\tu32 index;\n\n\tfor_each_changed_input(state, index)\n\t\tmalidp_write32(reg, MG_INPUT_ID0 + index * 4,\n\t\t\t       to_d71_input_id(state, index));\n\n\tmalidp_write32(reg, MG_SIZE, HV_SIZE(st->hsize_merged,\n\t\t\t\t\t     st->vsize_merged));\n\tmalidp_write32(reg, BLK_CONTROL, BLK_CTRL_EN);\n}\n\nstatic void d71_merger_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v;\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, MG_INPUT_ID0, 1, &v);\n\tseq_printf(sf, \"MG_INPUT_ID0:\\t\\t0x%X\\n\", v);\n\n\tget_values_from_reg(c->reg, MG_INPUT_ID1, 1, &v);\n\tseq_printf(sf, \"MG_INPUT_ID1:\\t\\t0x%X\\n\", v);\n\n\tget_values_from_reg(c->reg, BLK_CONTROL, 1, &v);\n\tseq_printf(sf, \"MG_CONTROL:\\t\\t0x%X\\n\", v);\n\n\tget_values_from_reg(c->reg, MG_SIZE, 1, &v);\n\tseq_printf(sf, \"MG_SIZE:\\t\\t0x%X\\n\", v);\n}\n\nstatic const struct komeda_component_funcs d71_merger_funcs = {\n\t.update\t\t= d71_merger_update,\n\t.disable\t= d71_component_disable,\n\t.dump_register\t= d71_merger_dump,\n};\n\nstatic int d71_merger_init(struct d71_dev *d71,\n\t\t\t   struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_merger *merger;\n\tu32 pipe_id, comp_id;\n\n\tget_resources_id(blk->block_info, &pipe_id, &comp_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*merger),\n\t\t\t\t comp_id,\n\t\t\t\t BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_merger_funcs,\n\t\t\t\t MG_NUM_INPUTS_IDS, get_valid_inputs(blk),\n\t\t\t\t MG_NUM_OUTPUTS_IDS, reg,\n\t\t\t\t \"CU%d_MERGER\", pipe_id);\n\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to initialize merger.\\n\");\n\t\treturn PTR_ERR(c);\n\t}\n\n\tmerger = to_merger(c);\n\n\tset_range(&merger->hsize_merged, 4,\n\t\t  __get_blk_line_size(d71, reg, 4032));\n\tset_range(&merger->vsize_merged, 4, 4096);\n\n\treturn 0;\n}\n\nstatic void d71_improc_update(struct komeda_component *c,\n\t\t\t      struct komeda_component_state *state)\n{\n\tstruct drm_crtc_state *crtc_st = state->crtc->state;\n\tstruct komeda_improc_state *st = to_improc_st(state);\n\tstruct d71_pipeline *pipe = to_d71_pipeline(c->pipeline);\n\tu32 __iomem *reg = c->reg;\n\tu32 index, mask = 0, ctrl = 0;\n\n\tfor_each_changed_input(state, index)\n\t\tmalidp_write32(reg, BLK_INPUT_ID0 + index * 4,\n\t\t\t       to_d71_input_id(state, index));\n\n\tmalidp_write32(reg, BLK_SIZE, HV_SIZE(st->hsize, st->vsize));\n\tmalidp_write32(reg, IPS_DEPTH, st->color_depth);\n\n\tif (crtc_st->color_mgmt_changed) {\n\t\tmask |= IPS_CTRL_FT | IPS_CTRL_RGB;\n\n\t\tif (crtc_st->gamma_lut) {\n\t\t\tmalidp_write_group(pipe->dou_ft_coeff_addr, FT_COEFF0,\n\t\t\t\t\t   KOMEDA_N_GAMMA_COEFFS,\n\t\t\t\t\t   st->fgamma_coeffs);\n\t\t\tctrl |= IPS_CTRL_FT;  \n\t\t}\n\n\t\tif (crtc_st->ctm) {\n\t\t\tmalidp_write_group(reg, IPS_RGB_RGB_COEFF0,\n\t\t\t\t\t   KOMEDA_N_CTM_COEFFS,\n\t\t\t\t\t   st->ctm_coeffs);\n\t\t\tctrl |= IPS_CTRL_RGB;  \n\t\t}\n\t}\n\n\tmask |= IPS_CTRL_YUV | IPS_CTRL_CHD422 | IPS_CTRL_CHD420;\n\n\t \n\tif (st->color_format == DRM_COLOR_FORMAT_YCBCR420)\n\t\tctrl |= IPS_CTRL_YUV | IPS_CTRL_CHD422 | IPS_CTRL_CHD420;\n\telse if (st->color_format == DRM_COLOR_FORMAT_YCBCR422)\n\t\tctrl |= IPS_CTRL_YUV | IPS_CTRL_CHD422;\n\telse if (st->color_format == DRM_COLOR_FORMAT_YCBCR444)\n\t\tctrl |= IPS_CTRL_YUV;\n\n\tmalidp_write32_mask(reg, BLK_CONTROL, mask, ctrl);\n}\n\nstatic void d71_improc_dump(struct komeda_component *c, struct seq_file *sf)\n{\n\tu32 v[12], i;\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, 0x80, 2, v);\n\tseq_printf(sf, \"IPS_INPUT_ID0:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"IPS_INPUT_ID1:\\t\\t0x%X\\n\", v[1]);\n\n\tget_values_from_reg(c->reg, 0xC0, 1, v);\n\tseq_printf(sf, \"IPS_INFO:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(c->reg, 0xD0, 3, v);\n\tseq_printf(sf, \"IPS_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"IPS_SIZE:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"IPS_DEPTH:\\t\\t0x%X\\n\", v[2]);\n\n\tget_values_from_reg(c->reg, 0x130, 12, v);\n\tfor (i = 0; i < 12; i++)\n\t\tseq_printf(sf, \"IPS_RGB_RGB_COEFF%u:\\t0x%X\\n\", i, v[i]);\n\n\tget_values_from_reg(c->reg, 0x170, 12, v);\n\tfor (i = 0; i < 12; i++)\n\t\tseq_printf(sf, \"IPS_RGB_YUV_COEFF%u:\\t0x%X\\n\", i, v[i]);\n}\n\nstatic const struct komeda_component_funcs d71_improc_funcs = {\n\t.update\t\t= d71_improc_update,\n\t.disable\t= d71_component_disable,\n\t.dump_register\t= d71_improc_dump,\n};\n\nstatic int d71_improc_init(struct d71_dev *d71,\n\t\t\t   struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_improc *improc;\n\tu32 pipe_id, comp_id, value;\n\n\tget_resources_id(blk->block_info, &pipe_id, &comp_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*improc),\n\t\t\t\t comp_id,\n\t\t\t\t BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_improc_funcs, IPS_NUM_INPUT_IDS,\n\t\t\t\t get_valid_inputs(blk),\n\t\t\t\t IPS_NUM_OUTPUT_IDS, reg, \"DOU%d_IPS\", pipe_id);\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to add improc component\\n\");\n\t\treturn PTR_ERR(c);\n\t}\n\n\timproc = to_improc(c);\n\timproc->supported_color_depths = BIT(8) | BIT(10);\n\timproc->supported_color_formats = DRM_COLOR_FORMAT_RGB444 |\n\t\t\t\t\t  DRM_COLOR_FORMAT_YCBCR444 |\n\t\t\t\t\t  DRM_COLOR_FORMAT_YCBCR422;\n\tvalue = malidp_read32(reg, BLK_INFO);\n\tif (value & IPS_INFO_CHD420)\n\t\timproc->supported_color_formats |= DRM_COLOR_FORMAT_YCBCR420;\n\n\timproc->supports_csc = true;\n\timproc->supports_gamma = true;\n\n\treturn 0;\n}\n\nstatic void d71_timing_ctrlr_disable(struct komeda_component *c)\n{\n\tmalidp_write32_mask(c->reg, BLK_CONTROL, BS_CTRL_EN, 0);\n}\n\nstatic void d71_timing_ctrlr_update(struct komeda_component *c,\n\t\t\t\t    struct komeda_component_state *state)\n{\n\tstruct drm_crtc_state *crtc_st = state->crtc->state;\n\tstruct drm_display_mode *mode = &crtc_st->adjusted_mode;\n\tu32 __iomem *reg = c->reg;\n\tu32 hactive, hfront_porch, hback_porch, hsync_len;\n\tu32 vactive, vfront_porch, vback_porch, vsync_len;\n\tu32 value;\n\n\thactive = mode->crtc_hdisplay;\n\thfront_porch = mode->crtc_hsync_start - mode->crtc_hdisplay;\n\thsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\n\thback_porch = mode->crtc_htotal - mode->crtc_hsync_end;\n\n\tvactive = mode->crtc_vdisplay;\n\tvfront_porch = mode->crtc_vsync_start - mode->crtc_vdisplay;\n\tvsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\n\tvback_porch = mode->crtc_vtotal - mode->crtc_vsync_end;\n\n\tmalidp_write32(reg, BS_ACTIVESIZE, HV_SIZE(hactive, vactive));\n\tmalidp_write32(reg, BS_HINTERVALS, BS_H_INTVALS(hfront_porch,\n\t\t\t\t\t\t\thback_porch));\n\tmalidp_write32(reg, BS_VINTERVALS, BS_V_INTVALS(vfront_porch,\n\t\t\t\t\t\t\tvback_porch));\n\n\tvalue = BS_SYNC_VSW(vsync_len) | BS_SYNC_HSW(hsync_len);\n\tvalue |= mode->flags & DRM_MODE_FLAG_PVSYNC ? BS_SYNC_VSP : 0;\n\tvalue |= mode->flags & DRM_MODE_FLAG_PHSYNC ? BS_SYNC_HSP : 0;\n\tmalidp_write32(reg, BS_SYNC, value);\n\n\tmalidp_write32(reg, BS_PROG_LINE, D71_DEFAULT_PREPRETCH_LINE - 1);\n\tmalidp_write32(reg, BS_PREFETCH_LINE, D71_DEFAULT_PREPRETCH_LINE);\n\n\t \n\tvalue = BS_CTRL_EN | BS_CTRL_VM;\n\tif (c->pipeline->dual_link) {\n\t\tmalidp_write32(reg, BS_DRIFT_TO, hfront_porch + 16);\n\t\tvalue |= BS_CTRL_DL;\n\t}\n\n\tmalidp_write32(reg, BLK_CONTROL, value);\n}\n\nstatic void d71_timing_ctrlr_dump(struct komeda_component *c,\n\t\t\t\t  struct seq_file *sf)\n{\n\tu32 v[8], i;\n\n\tdump_block_header(sf, c->reg);\n\n\tget_values_from_reg(c->reg, 0xC0, 1, v);\n\tseq_printf(sf, \"BS_INFO:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(c->reg, 0xD0, 8, v);\n\tseq_printf(sf, \"BS_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"BS_PROG_LINE:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"BS_PREFETCH_LINE:\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"BS_BG_COLOR:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"BS_ACTIVESIZE:\\t\\t0x%X\\n\", v[4]);\n\tseq_printf(sf, \"BS_HINTERVALS:\\t\\t0x%X\\n\", v[5]);\n\tseq_printf(sf, \"BS_VINTERVALS:\\t\\t0x%X\\n\", v[6]);\n\tseq_printf(sf, \"BS_SYNC:\\t\\t0x%X\\n\", v[7]);\n\n\tget_values_from_reg(c->reg, 0x100, 3, v);\n\tseq_printf(sf, \"BS_DRIFT_TO:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"BS_FRAME_TO:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"BS_TE_TO:\\t\\t0x%X\\n\", v[2]);\n\n\tget_values_from_reg(c->reg, 0x110, 3, v);\n\tfor (i = 0; i < 3; i++)\n\t\tseq_printf(sf, \"BS_T%u_INTERVAL:\\t\\t0x%X\\n\", i, v[i]);\n\n\tget_values_from_reg(c->reg, 0x120, 5, v);\n\tfor (i = 0; i < 2; i++) {\n\t\tseq_printf(sf, \"BS_CRC%u_LOW:\\t\\t0x%X\\n\", i, v[i << 1]);\n\t\tseq_printf(sf, \"BS_CRC%u_HIGH:\\t\\t0x%X\\n\", i, v[(i << 1) + 1]);\n\t}\n\tseq_printf(sf, \"BS_USER:\\t\\t0x%X\\n\", v[4]);\n}\n\nstatic const struct komeda_component_funcs d71_timing_ctrlr_funcs = {\n\t.update\t\t= d71_timing_ctrlr_update,\n\t.disable\t= d71_timing_ctrlr_disable,\n\t.dump_register\t= d71_timing_ctrlr_dump,\n};\n\nstatic int d71_timing_ctrlr_init(struct d71_dev *d71,\n\t\t\t\t struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_timing_ctrlr *ctrlr;\n\tu32 pipe_id, comp_id;\n\n\tget_resources_id(blk->block_info, &pipe_id, &comp_id);\n\n\tc = komeda_component_add(&d71->pipes[pipe_id]->base, sizeof(*ctrlr),\n\t\t\t\t KOMEDA_COMPONENT_TIMING_CTRLR,\n\t\t\t\t BLOCK_INFO_INPUT_ID(blk->block_info),\n\t\t\t\t &d71_timing_ctrlr_funcs,\n\t\t\t\t 1, BIT(KOMEDA_COMPONENT_IPS0 + pipe_id),\n\t\t\t\t BS_NUM_OUTPUT_IDS, reg, \"DOU%d_BS\", pipe_id);\n\tif (IS_ERR(c)) {\n\t\tDRM_ERROR(\"Failed to add display_ctrl component\\n\");\n\t\treturn PTR_ERR(c);\n\t}\n\n\tctrlr = to_ctrlr(c);\n\n\tctrlr->supports_dual_link = d71->supports_dual_link;\n\n\treturn 0;\n}\n\nint d71_probe_block(struct d71_dev *d71,\n\t\t    struct block_header *blk, u32 __iomem *reg)\n{\n\tstruct d71_pipeline *pipe;\n\tint blk_id = BLOCK_INFO_BLK_ID(blk->block_info);\n\n\tint err = 0;\n\n\tswitch (BLOCK_INFO_BLK_TYPE(blk->block_info)) {\n\tcase D71_BLK_TYPE_GCU:\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_LPU:\n\t\tpipe = d71->pipes[blk_id];\n\t\tpipe->lpu_addr = reg;\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_LPU_LAYER:\n\t\terr = d71_layer_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_LPU_WB_LAYER:\n\t\terr = d71_wb_layer_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_CU:\n\t\tpipe = d71->pipes[blk_id];\n\t\tpipe->cu_addr = reg;\n\t\terr = d71_compiz_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_CU_SCALER:\n\t\terr = d71_scaler_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_CU_SPLITTER:\n\t\terr = d71_splitter_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_CU_MERGER:\n\t\terr = d71_merger_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_DOU:\n\t\tpipe = d71->pipes[blk_id];\n\t\tpipe->dou_addr = reg;\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_DOU_IPS:\n\t\terr = d71_improc_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_DOU_FT_COEFF:\n\t\tpipe = d71->pipes[blk_id];\n\t\tpipe->dou_ft_coeff_addr = reg;\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_DOU_BS:\n\t\terr = d71_timing_ctrlr_init(d71, blk, reg);\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_GLB_LT_COEFF:\n\t\tbreak;\n\n\tcase D71_BLK_TYPE_GLB_SCL_COEFF:\n\t\td71->glb_scl_coeff_addr[blk_id] = reg;\n\t\tbreak;\n\n\tdefault:\n\t\tDRM_ERROR(\"Unknown block (block_info: 0x%x) is found\\n\",\n\t\t\t  blk->block_info);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic void d71_gcu_dump(struct d71_dev *d71, struct seq_file *sf)\n{\n\tu32 v[5];\n\n\tseq_puts(sf, \"\\n------ GCU ------\\n\");\n\n\tget_values_from_reg(d71->gcu_addr, 0, 3, v);\n\tseq_printf(sf, \"GLB_ARCH_ID:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"GLB_CORE_ID:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"GLB_CORE_INFO:\\t\\t0x%X\\n\", v[2]);\n\n\tget_values_from_reg(d71->gcu_addr, 0x10, 1, v);\n\tseq_printf(sf, \"GLB_IRQ_STATUS:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(d71->gcu_addr, 0xA0, 5, v);\n\tseq_printf(sf, \"GCU_IRQ_RAW_STATUS:\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"GCU_IRQ_CLEAR:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"GCU_IRQ_MASK:\\t\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"GCU_IRQ_STATUS:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"GCU_STATUS:\\t\\t0x%X\\n\", v[4]);\n\n\tget_values_from_reg(d71->gcu_addr, 0xD0, 3, v);\n\tseq_printf(sf, \"GCU_CONTROL:\\t\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"GCU_CONFIG_VALID0:\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"GCU_CONFIG_VALID1:\\t0x%X\\n\", v[2]);\n}\n\nstatic void d71_lpu_dump(struct d71_pipeline *pipe, struct seq_file *sf)\n{\n\tu32 v[6];\n\n\tseq_printf(sf, \"\\n------ LPU%d ------\\n\", pipe->base.id);\n\n\tdump_block_header(sf, pipe->lpu_addr);\n\n\tget_values_from_reg(pipe->lpu_addr, 0xA0, 6, v);\n\tseq_printf(sf, \"LPU_IRQ_RAW_STATUS:\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"LPU_IRQ_CLEAR:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"LPU_IRQ_MASK:\\t\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"LPU_IRQ_STATUS:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"LPU_STATUS:\\t\\t0x%X\\n\", v[4]);\n\tseq_printf(sf, \"LPU_TBU_STATUS:\\t\\t0x%X\\n\", v[5]);\n\n\tget_values_from_reg(pipe->lpu_addr, 0xC0, 1, v);\n\tseq_printf(sf, \"LPU_INFO:\\t\\t0x%X\\n\", v[0]);\n\n\tget_values_from_reg(pipe->lpu_addr, 0xD0, 3, v);\n\tseq_printf(sf, \"LPU_RAXI_CONTROL:\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"LPU_WAXI_CONTROL:\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"LPU_TBU_CONTROL:\\t0x%X\\n\", v[2]);\n}\n\nstatic void d71_dou_dump(struct d71_pipeline *pipe, struct seq_file *sf)\n{\n\tu32 v[5];\n\n\tseq_printf(sf, \"\\n------ DOU%d ------\\n\", pipe->base.id);\n\n\tdump_block_header(sf, pipe->dou_addr);\n\n\tget_values_from_reg(pipe->dou_addr, 0xA0, 5, v);\n\tseq_printf(sf, \"DOU_IRQ_RAW_STATUS:\\t0x%X\\n\", v[0]);\n\tseq_printf(sf, \"DOU_IRQ_CLEAR:\\t\\t0x%X\\n\", v[1]);\n\tseq_printf(sf, \"DOU_IRQ_MASK:\\t\\t0x%X\\n\", v[2]);\n\tseq_printf(sf, \"DOU_IRQ_STATUS:\\t\\t0x%X\\n\", v[3]);\n\tseq_printf(sf, \"DOU_STATUS:\\t\\t0x%X\\n\", v[4]);\n}\n\nstatic void d71_pipeline_dump(struct komeda_pipeline *pipe, struct seq_file *sf)\n{\n\tstruct d71_pipeline *d71_pipe = to_d71_pipeline(pipe);\n\n\td71_lpu_dump(d71_pipe, sf);\n\td71_dou_dump(d71_pipe, sf);\n}\n\nconst struct komeda_pipeline_funcs d71_pipeline_funcs = {\n\t.downscaling_clk_check\t= d71_downscaling_clk_check,\n\t.dump_register\t\t= d71_pipeline_dump,\n};\n\nvoid d71_dump(struct komeda_dev *mdev, struct seq_file *sf)\n{\n\tstruct d71_dev *d71 = mdev->chip_data;\n\n\td71_gcu_dump(d71, sf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}