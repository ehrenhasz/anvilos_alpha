{
  "module_name": "komeda_kms.c",
  "hash_id": "3960d93637eb3467df80ecf61796c98aff03fc0e4389e3c9082f101fce572891",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_kms.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n#include <drm/drm_managed.h>\n#include <drm/drm_probe_helper.h>\n#include <drm/drm_vblank.h>\n\n#include \"komeda_dev.h\"\n#include \"komeda_framebuffer.h\"\n#include \"komeda_kms.h\"\n\nDEFINE_DRM_GEM_DMA_FOPS(komeda_cma_fops);\n\nstatic int komeda_gem_dma_dumb_create(struct drm_file *file,\n\t\t\t\t      struct drm_device *dev,\n\t\t\t\t      struct drm_mode_create_dumb *args)\n{\n\tstruct komeda_dev *mdev = dev->dev_private;\n\tu32 pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\n\n\targs->pitch = ALIGN(pitch, mdev->chip.bus_width);\n\n\treturn drm_gem_dma_dumb_create_internal(file, dev, args);\n}\n\nstatic irqreturn_t komeda_kms_irq_handler(int irq, void *data)\n{\n\tstruct drm_device *drm = data;\n\tstruct komeda_dev *mdev = drm->dev_private;\n\tstruct komeda_kms_dev *kms = to_kdev(drm);\n\tstruct komeda_events evts;\n\tirqreturn_t status;\n\tu32 i;\n\n\t \n\tmemset(&evts, 0, sizeof(evts));\n\tstatus = mdev->funcs->irq_handler(mdev, &evts);\n\n\tkomeda_print_events(&evts, drm);\n\n\t \n\tfor (i = 0; i < kms->n_crtcs; i++)\n\t\tkomeda_crtc_handle_event(&kms->crtcs[i], &evts);\n\n\treturn status;\n}\n\nstatic const struct drm_driver komeda_kms_driver = {\n\t.driver_features = DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,\n\tDRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(komeda_gem_dma_dumb_create),\n\t.fops = &komeda_cma_fops,\n\t.name = \"komeda\",\n\t.desc = \"Arm Komeda Display Processor driver\",\n\t.date = \"20181101\",\n\t.major = 0,\n\t.minor = 1,\n};\n\nstatic void komeda_kms_atomic_commit_hw_done(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct komeda_kms_dev *kms = to_kdev(dev);\n\tint i;\n\n\tfor (i = 0; i < kms->n_crtcs; i++) {\n\t\tstruct komeda_crtc *kcrtc = &kms->crtcs[i];\n\n\t\tif (kcrtc->base.state->active) {\n\t\t\tstruct completion *flip_done = NULL;\n\t\t\tif (kcrtc->base.state->event)\n\t\t\t\tflip_done = kcrtc->base.state->event->base.completion;\n\t\t\tkomeda_crtc_flush_and_wait_for_flip_done(kcrtc, flip_done);\n\t\t}\n\t}\n\tdrm_atomic_helper_commit_hw_done(state);\n}\n\nstatic void komeda_kms_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\tbool fence_cookie = dma_fence_begin_signalling();\n\n\tdrm_atomic_helper_commit_modeset_disables(dev, old_state);\n\n\tdrm_atomic_helper_commit_planes(dev, old_state,\n\t\t\t\t\tDRM_PLANE_COMMIT_ACTIVE_ONLY);\n\n\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\n\tkomeda_kms_atomic_commit_hw_done(old_state);\n\n\tdrm_atomic_helper_wait_for_flip_done(dev, old_state);\n\n\tdma_fence_end_signalling(fence_cookie);\n\n\tdrm_atomic_helper_cleanup_planes(dev, old_state);\n}\n\nstatic const struct drm_mode_config_helper_funcs komeda_mode_config_helpers = {\n\t.atomic_commit_tail = komeda_kms_commit_tail,\n};\n\nstatic int komeda_plane_state_list_add(struct drm_plane_state *plane_st,\n\t\t\t\t       struct list_head *zorder_list)\n{\n\tstruct komeda_plane_state *new = to_kplane_st(plane_st);\n\tstruct komeda_plane_state *node, *last;\n\n\tlast = list_empty(zorder_list) ?\n\t       NULL : list_last_entry(zorder_list, typeof(*last), zlist_node);\n\n\t \n\tif (!last || (new->base.zpos > last->base.zpos)) {\n\t\tlist_add_tail(&new->zlist_node, zorder_list);\n\t\treturn 0;\n\t}\n\n\t \n\tlist_for_each_entry(node, zorder_list, zlist_node) {\n\t\tif (new->base.zpos < node->base.zpos) {\n\t\t\tlist_add_tail(&new->zlist_node, &node->zlist_node);\n\t\t\tbreak;\n\t\t} else if (node->base.zpos == new->base.zpos) {\n\t\t\tstruct drm_plane *a = node->base.plane;\n\t\t\tstruct drm_plane *b = new->base.plane;\n\n\t\t\t \n\t\t\tDRM_DEBUG_ATOMIC(\"PLANE: %s and PLANE: %s are configured same zpos: %d.\\n\",\n\t\t\t\t\t a->name, b->name, node->base.zpos);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int komeda_crtc_normalize_zpos(struct drm_crtc *crtc,\n\t\t\t\t      struct drm_crtc_state *crtc_st)\n{\n\tstruct drm_atomic_state *state = crtc_st->state;\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\tstruct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc_st);\n\tstruct komeda_plane_state *kplane_st;\n\tstruct drm_plane_state *plane_st;\n\tstruct drm_plane *plane;\n\tstruct list_head zorder_list;\n\tint order = 0, err;\n\n\tDRM_DEBUG_ATOMIC(\"[CRTC:%d:%s] calculating normalized zpos values\\n\",\n\t\t\t crtc->base.id, crtc->name);\n\n\tINIT_LIST_HEAD(&zorder_list);\n\n\t \n\tdrm_for_each_plane_mask(plane, crtc->dev, crtc_st->plane_mask) {\n\t\tplane_st = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_st))\n\t\t\treturn PTR_ERR(plane_st);\n\n\t\t \n\t\terr = komeda_plane_state_list_add(plane_st, &zorder_list);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tkcrtc_st->max_slave_zorder = 0;\n\n\tlist_for_each_entry(kplane_st, &zorder_list, zlist_node) {\n\t\tplane_st = &kplane_st->base;\n\t\tplane = plane_st->plane;\n\n\t\tplane_st->normalized_zpos = order++;\n\t\t \n\t\tif (to_kplane_st(plane_st)->layer_split)\n\t\t\torder++;\n\n\t\tDRM_DEBUG_ATOMIC(\"[PLANE:%d:%s] zpos:%d, normalized zpos: %d\\n\",\n\t\t\t\t plane->base.id, plane->name,\n\t\t\t\t plane_st->zpos, plane_st->normalized_zpos);\n\n\t\t \n\t\tif (has_bit(drm_plane_index(plane), kcrtc->slave_planes))\n\t\t\tkcrtc_st->max_slave_zorder =\n\t\t\t\tmax(plane_st->normalized_zpos,\n\t\t\t\t    kcrtc_st->max_slave_zorder);\n\t}\n\n\tcrtc_st->zpos_changed = true;\n\n\treturn 0;\n}\n\nstatic int komeda_kms_check(struct drm_device *dev,\n\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_st;\n\tint i, err;\n\n\terr = drm_atomic_helper_check_modeset(dev, state);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_st, i) {\n\t\terr = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = komeda_crtc_normalize_zpos(crtc, new_crtc_st);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = drm_atomic_helper_check_planes(dev, state);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic const struct drm_mode_config_funcs komeda_mode_config_funcs = {\n\t.fb_create\t\t= komeda_fb_create,\n\t.atomic_check\t\t= komeda_kms_check,\n\t.atomic_commit\t\t= drm_atomic_helper_commit,\n};\n\nstatic void komeda_kms_mode_config_init(struct komeda_kms_dev *kms,\n\t\t\t\t\tstruct komeda_dev *mdev)\n{\n\tstruct drm_mode_config *config = &kms->base.mode_config;\n\n\tdrm_mode_config_init(&kms->base);\n\n\tkomeda_kms_setup_crtcs(kms, mdev);\n\n\t \n\tconfig->min_width\t= 0;\n\tconfig->min_height\t= 0;\n\tconfig->max_width\t= 4096;\n\tconfig->max_height\t= 4096;\n\n\tconfig->funcs = &komeda_mode_config_funcs;\n\tconfig->helper_private = &komeda_mode_config_helpers;\n}\n\nstruct komeda_kms_dev *komeda_kms_attach(struct komeda_dev *mdev)\n{\n\tstruct komeda_kms_dev *kms;\n\tstruct drm_device *drm;\n\tint err;\n\n\tkms = devm_drm_dev_alloc(mdev->dev, &komeda_kms_driver,\n\t\t\t\t struct komeda_kms_dev, base);\n\tif (IS_ERR(kms))\n\t\treturn kms;\n\n\tdrm = &kms->base;\n\n\tdrm->dev_private = mdev;\n\n\tkomeda_kms_mode_config_init(kms, mdev);\n\n\terr = komeda_kms_add_private_objs(kms, mdev);\n\tif (err)\n\t\tgoto cleanup_mode_config;\n\n\terr = komeda_kms_add_planes(kms, mdev);\n\tif (err)\n\t\tgoto cleanup_mode_config;\n\n\terr = drm_vblank_init(drm, kms->n_crtcs);\n\tif (err)\n\t\tgoto cleanup_mode_config;\n\n\terr = komeda_kms_add_crtcs(kms, mdev);\n\tif (err)\n\t\tgoto cleanup_mode_config;\n\n\terr = komeda_kms_add_wb_connectors(kms, mdev);\n\tif (err)\n\t\tgoto cleanup_mode_config;\n\n\tdrm_mode_config_reset(drm);\n\n\terr = devm_request_irq(drm->dev, mdev->irq,\n\t\t\t       komeda_kms_irq_handler, IRQF_SHARED,\n\t\t\t       drm->driver->name, drm);\n\tif (err)\n\t\tgoto cleanup_mode_config;\n\n\tdrm_kms_helper_poll_init(drm);\n\n\terr = drm_dev_register(drm, 0);\n\tif (err)\n\t\tgoto free_interrupts;\n\n\treturn kms;\n\nfree_interrupts:\n\tdrm_kms_helper_poll_fini(drm);\ncleanup_mode_config:\n\tdrm_mode_config_cleanup(drm);\n\tkomeda_kms_cleanup_private_objs(kms);\n\tdrm->dev_private = NULL;\n\treturn ERR_PTR(err);\n}\n\nvoid komeda_kms_detach(struct komeda_kms_dev *kms)\n{\n\tstruct drm_device *drm = &kms->base;\n\n\tdrm_dev_unregister(drm);\n\tdrm_kms_helper_poll_fini(drm);\n\tdrm_atomic_helper_shutdown(drm);\n\tdrm_mode_config_cleanup(drm);\n\tkomeda_kms_cleanup_private_objs(kms);\n\tdrm->dev_private = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}