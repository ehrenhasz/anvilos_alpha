{
  "module_name": "komeda_wb_connector.c",
  "hash_id": "ec6c023e1ac6d97026ca9228482858fcbcb746d6fd5cacac0285c8220b476147",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_wb_connector.c",
  "human_readable_source": "\n \n#include <drm/drm_framebuffer.h>\n#include \"komeda_dev.h\"\n#include \"komeda_kms.h\"\n\nstatic int\nkomeda_wb_init_data_flow(struct komeda_layer *wb_layer,\n\t\t\t struct drm_connector_state *conn_st,\n\t\t\t struct komeda_crtc_state *kcrtc_st,\n\t\t\t struct komeda_data_flow_cfg *dflow)\n{\n\tstruct drm_framebuffer *fb = conn_st->writeback_job->fb;\n\n\tmemset(dflow, 0, sizeof(*dflow));\n\n\tdflow->out_w = fb->width;\n\tdflow->out_h = fb->height;\n\n\t \n\tpipeline_composition_size(kcrtc_st, &dflow->in_w, &dflow->in_h);\n\tdflow->input.component = &wb_layer->base.pipeline->compiz->base;\n\t \n\tdflow->pixel_blend_mode = DRM_MODE_BLEND_PIXEL_NONE;\n\tdflow->rot = DRM_MODE_ROTATE_0;\n\n\tkomeda_complete_data_flow_cfg(wb_layer, dflow, fb);\n\n\treturn 0;\n}\n\nstatic int\nkomeda_wb_encoder_atomic_check(struct drm_encoder *encoder,\n\t\t\t       struct drm_crtc_state *crtc_st,\n\t\t\t       struct drm_connector_state *conn_st)\n{\n\tstruct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc_st);\n\tstruct drm_writeback_job *writeback_job = conn_st->writeback_job;\n\tstruct komeda_layer *wb_layer;\n\tstruct komeda_data_flow_cfg dflow;\n\tint err;\n\n\tif (!writeback_job)\n\t\treturn 0;\n\n\tif (!crtc_st->active) {\n\t\tDRM_DEBUG_ATOMIC(\"Cannot write the composition result out on a inactive CRTC.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twb_layer = to_kconn(to_wb_conn(conn_st->connector))->wb_layer;\n\n\t \n\tif (crtc_st->connectors_changed &&\n\t    is_only_changed_connector(crtc_st, conn_st->connector))\n\t\tcrtc_st->connectors_changed = false;\n\n\terr = komeda_wb_init_data_flow(wb_layer, conn_st, kcrtc_st, &dflow);\n\tif (err)\n\t\treturn err;\n\n\tif (dflow.en_split)\n\t\terr = komeda_build_wb_split_data_flow(wb_layer,\n\t\t\t\tconn_st, kcrtc_st, &dflow);\n\telse\n\t\terr = komeda_build_wb_data_flow(wb_layer,\n\t\t\t\tconn_st, kcrtc_st, &dflow);\n\n\treturn err;\n}\n\nstatic const struct drm_encoder_helper_funcs komeda_wb_encoder_helper_funcs = {\n\t.atomic_check = komeda_wb_encoder_atomic_check,\n};\n\nstatic int\nkomeda_wb_connector_get_modes(struct drm_connector *connector)\n{\n\treturn 0;\n}\n\nstatic enum drm_mode_status\nkomeda_wb_connector_mode_valid(struct drm_connector *connector,\n\t\t\t       struct drm_display_mode *mode)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_mode_config *mode_config = &dev->mode_config;\n\tint w = mode->hdisplay, h = mode->vdisplay;\n\n\tif ((w < mode_config->min_width) || (w > mode_config->max_width))\n\t\treturn MODE_BAD_HVALUE;\n\n\tif ((h < mode_config->min_height) || (h > mode_config->max_height))\n\t\treturn MODE_BAD_VVALUE;\n\n\treturn MODE_OK;\n}\n\nstatic const struct drm_connector_helper_funcs komeda_wb_conn_helper_funcs = {\n\t.get_modes\t= komeda_wb_connector_get_modes,\n\t.mode_valid\t= komeda_wb_connector_mode_valid,\n};\n\nstatic enum drm_connector_status\nkomeda_wb_connector_detect(struct drm_connector *connector, bool force)\n{\n\treturn connector_status_connected;\n}\n\nstatic int\nkomeda_wb_connector_fill_modes(struct drm_connector *connector,\n\t\t\t       uint32_t maxX, uint32_t maxY)\n{\n\treturn 0;\n}\n\nstatic void komeda_wb_connector_destroy(struct drm_connector *connector)\n{\n\tdrm_connector_cleanup(connector);\n\tkfree(to_kconn(to_wb_conn(connector)));\n}\n\nstatic const struct drm_connector_funcs komeda_wb_connector_funcs = {\n\t.reset\t\t\t= drm_atomic_helper_connector_reset,\n\t.detect\t\t\t= komeda_wb_connector_detect,\n\t.fill_modes\t\t= komeda_wb_connector_fill_modes,\n\t.destroy\t\t= komeda_wb_connector_destroy,\n\t.atomic_duplicate_state\t= drm_atomic_helper_connector_duplicate_state,\n\t.atomic_destroy_state\t= drm_atomic_helper_connector_destroy_state,\n};\n\nstatic int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tstruct drm_display_info *info;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\n\twb_conn = &kwb_conn->base;\n\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats,\n\t\t\t\t\t   BIT(drm_crtc_index(&kcrtc->base)));\n\tkomeda_put_fourcc_list(formats);\n\tif (err) {\n\t\tkfree(kwb_conn);\n\t\treturn err;\n\t}\n\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\n\tinfo = &kwb_conn->base.base.display_info;\n\tinfo->bpc = __fls(kcrtc->master->improc->supported_color_depths);\n\tinfo->color_formats = kcrtc->master->improc->supported_color_formats;\n\n\tkcrtc->wb_conn = kwb_conn;\n\n\treturn 0;\n}\n\nint komeda_kms_add_wb_connectors(struct komeda_kms_dev *kms,\n\t\t\t\t struct komeda_dev *mdev)\n{\n\tint i, err;\n\n\tfor (i = 0; i < kms->n_crtcs; i++) {\n\t\terr = komeda_wb_connector_add(kms, &kms->crtcs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}