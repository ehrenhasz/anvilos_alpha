{
  "module_name": "komeda_kms.h",
  "hash_id": "6cf88796c3072e83e224f60fff1ec481fab47d470b831d7c153d028a5e3be0eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_kms.h",
  "human_readable_source": " \n \n#ifndef _KOMEDA_KMS_H_\n#define _KOMEDA_KMS_H_\n\n#include <linux/list.h>\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_device.h>\n#include <drm/drm_writeback.h>\n#include <drm/drm_print.h>\n\n \nstruct komeda_plane {\n\t \n\tstruct drm_plane base;\n\t \n\tstruct komeda_layer *layer;\n};\n\n \nstruct komeda_plane_state {\n\t \n\tstruct drm_plane_state base;\n\t \n\tstruct list_head zlist_node;\n\n\t \n\tu8 layer_split : 1;\n};\n\n \nstruct komeda_wb_connector {\n\t \n\tstruct drm_writeback_connector base;\n\n\t \n\tstruct komeda_layer *wb_layer;\n};\n\n \nstruct komeda_crtc {\n\t \n\tstruct drm_crtc base;\n\t \n\tstruct komeda_pipeline *master;\n\t \n\tstruct komeda_pipeline *slave;\n\n\t \n\tu32 slave_planes;\n\n\t \n\tstruct komeda_wb_connector *wb_conn;\n\n\t \n\tstruct completion *disable_done;\n\n\t \n\tstruct drm_encoder encoder;\n};\n\n \nstruct komeda_crtc_state {\n\t \n\tstruct drm_crtc_state base;\n\n\t \n\n\t \n\t \n\tu32 affected_pipes;\n\t \n\tu32 active_pipes;\n\n\t \n\tu64 clock_ratio;\n\n\t \n\tu32 max_slave_zorder;\n};\n\n \nstruct komeda_kms_dev {\n\t \n\tstruct drm_device base;\n\n\t \n\tint n_crtcs;\n\t \n\tstruct komeda_crtc crtcs[KOMEDA_MAX_PIPELINES];\n};\n\n#define to_kplane(p)\tcontainer_of(p, struct komeda_plane, base)\n#define to_kplane_st(p)\tcontainer_of(p, struct komeda_plane_state, base)\n#define to_kconn(p)\tcontainer_of(p, struct komeda_wb_connector, base)\n#define to_kcrtc(p)\tcontainer_of(p, struct komeda_crtc, base)\n#define to_kcrtc_st(p)\tcontainer_of(p, struct komeda_crtc_state, base)\n#define to_kdev(p)\tcontainer_of(p, struct komeda_kms_dev, base)\n#define to_wb_conn(x)\tcontainer_of(x, struct drm_writeback_connector, base)\n\nstatic inline bool is_writeback_only(struct drm_crtc_state *st)\n{\n\tstruct komeda_wb_connector *wb_conn = to_kcrtc(st->crtc)->wb_conn;\n\tstruct drm_connector *conn = wb_conn ? &wb_conn->base.base : NULL;\n\n\treturn conn && (st->connector_mask == BIT(drm_connector_index(conn)));\n}\n\nstatic inline bool\nis_only_changed_connector(struct drm_crtc_state *st, struct drm_connector *conn)\n{\n\tstruct drm_crtc_state *old_st;\n\tu32 changed_connectors;\n\n\told_st = drm_atomic_get_old_crtc_state(st->state, st->crtc);\n\tchanged_connectors = st->connector_mask ^ old_st->connector_mask;\n\n\treturn BIT(drm_connector_index(conn)) == changed_connectors;\n}\n\nstatic inline bool has_flip_h(u32 rot)\n{\n\tu32 rotation = drm_rotation_simplify(rot,\n\t\t\t\t\t     DRM_MODE_ROTATE_0 |\n\t\t\t\t\t     DRM_MODE_ROTATE_90 |\n\t\t\t\t\t     DRM_MODE_REFLECT_MASK);\n\n\tif (rotation & DRM_MODE_ROTATE_90)\n\t\treturn !!(rotation & DRM_MODE_REFLECT_Y);\n\telse\n\t\treturn !!(rotation & DRM_MODE_REFLECT_X);\n}\n\nvoid komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,\n\t\t\t\t  u32 *color_depths, u32 *color_formats);\nunsigned long komeda_crtc_get_aclk(struct komeda_crtc_state *kcrtc_st);\n\nint komeda_kms_setup_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);\n\nint komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev);\nint komeda_kms_add_planes(struct komeda_kms_dev *kms, struct komeda_dev *mdev);\nint komeda_kms_add_private_objs(struct komeda_kms_dev *kms,\n\t\t\t\tstruct komeda_dev *mdev);\nint komeda_kms_add_wb_connectors(struct komeda_kms_dev *kms,\n\t\t\t\t struct komeda_dev *mdev);\nvoid komeda_kms_cleanup_private_objs(struct komeda_kms_dev *kms);\n\nvoid komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,\n\t\t\t      struct komeda_events *evts);\nvoid komeda_crtc_flush_and_wait_for_flip_done(struct komeda_crtc *kcrtc,\n\t\t\t\t\t      struct completion *input_flip_done);\n\nstruct komeda_kms_dev *komeda_kms_attach(struct komeda_dev *mdev);\nvoid komeda_kms_detach(struct komeda_kms_dev *kms);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}