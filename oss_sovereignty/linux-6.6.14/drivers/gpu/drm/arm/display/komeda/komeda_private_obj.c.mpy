{
  "module_name": "komeda_private_obj.c",
  "hash_id": "90207833d9fab6a2e1ab9cd0e94869d46b7f1ba78932a451672483f5aa0e305e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_private_obj.c",
  "human_readable_source": "\n \n#include \"komeda_dev.h\"\n#include \"komeda_kms.h\"\n\nstatic void\nkomeda_component_state_reset(struct komeda_component_state *st)\n{\n\tst->binding_user = NULL;\n\tst->affected_inputs = st->active_inputs;\n\tst->active_inputs = 0;\n\tst->changed_active_inputs = 0;\n}\n\nstatic struct drm_private_state *\nkomeda_layer_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_layer_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void\nkomeda_layer_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t  struct drm_private_state *state)\n{\n\tstruct komeda_layer_state *st = to_layer_st(priv_to_comp_st(state));\n\n\tkfree(st);\n}\n\nstatic const struct drm_private_state_funcs komeda_layer_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_layer_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_layer_atomic_destroy_state,\n};\n\nstatic int komeda_layer_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\tstruct komeda_layer *layer)\n{\n\tstruct komeda_layer_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &layer->base;\n\tdrm_atomic_private_obj_init(&kms->base, &layer->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_layer_obj_funcs);\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_scaler_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_scaler_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void\nkomeda_scaler_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t   struct drm_private_state *state)\n{\n\tkfree(to_scaler_st(priv_to_comp_st(state)));\n}\n\nstatic const struct drm_private_state_funcs komeda_scaler_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_scaler_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_scaler_atomic_destroy_state,\n};\n\nstatic int komeda_scaler_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t struct komeda_scaler *scaler)\n{\n\tstruct komeda_scaler_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &scaler->base;\n\tdrm_atomic_private_obj_init(&kms->base,\n\t\t\t\t    &scaler->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_scaler_obj_funcs);\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_compiz_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_compiz_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void\nkomeda_compiz_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t   struct drm_private_state *state)\n{\n\tkfree(to_compiz_st(priv_to_comp_st(state)));\n}\n\nstatic const struct drm_private_state_funcs komeda_compiz_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_compiz_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_compiz_atomic_destroy_state,\n};\n\nstatic int komeda_compiz_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t struct komeda_compiz *compiz)\n{\n\tstruct komeda_compiz_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &compiz->base;\n\tdrm_atomic_private_obj_init(&kms->base, &compiz->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_compiz_obj_funcs);\n\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_splitter_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_splitter_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void\nkomeda_splitter_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t     struct drm_private_state *state)\n{\n\tkfree(to_splitter_st(priv_to_comp_st(state)));\n}\n\nstatic const struct drm_private_state_funcs komeda_splitter_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_splitter_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_splitter_atomic_destroy_state,\n};\n\nstatic int komeda_splitter_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_splitter *splitter)\n{\n\tstruct komeda_splitter_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &splitter->base;\n\tdrm_atomic_private_obj_init(&kms->base,\n\t\t\t\t    &splitter->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_splitter_obj_funcs);\n\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_merger_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_merger_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void komeda_merger_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t\t       struct drm_private_state *state)\n{\n\tkfree(to_merger_st(priv_to_comp_st(state)));\n}\n\nstatic const struct drm_private_state_funcs komeda_merger_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_merger_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_merger_atomic_destroy_state,\n};\n\nstatic int komeda_merger_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t struct komeda_merger *merger)\n{\n\tstruct komeda_merger_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &merger->base;\n\tdrm_atomic_private_obj_init(&kms->base,\n\t\t\t\t    &merger->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_merger_obj_funcs);\n\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_improc_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_improc_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void\nkomeda_improc_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t   struct drm_private_state *state)\n{\n\tkfree(to_improc_st(priv_to_comp_st(state)));\n}\n\nstatic const struct drm_private_state_funcs komeda_improc_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_improc_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_improc_atomic_destroy_state,\n};\n\nstatic int komeda_improc_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t struct komeda_improc *improc)\n{\n\tstruct komeda_improc_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &improc->base;\n\tdrm_atomic_private_obj_init(&kms->base, &improc->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_improc_obj_funcs);\n\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_timing_ctrlr_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_timing_ctrlr_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tkomeda_component_state_reset(&st->base);\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->base.obj);\n\n\treturn &st->base.obj;\n}\n\nstatic void\nkomeda_timing_ctrlr_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t\t struct drm_private_state *state)\n{\n\tkfree(to_ctrlr_st(priv_to_comp_st(state)));\n}\n\nstatic const struct drm_private_state_funcs komeda_timing_ctrlr_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_timing_ctrlr_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_timing_ctrlr_atomic_destroy_state,\n};\n\nstatic int komeda_timing_ctrlr_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t       struct komeda_timing_ctrlr *ctrlr)\n{\n\tstruct komeda_compiz_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->base.component = &ctrlr->base;\n\tdrm_atomic_private_obj_init(&kms->base, &ctrlr->base.obj, &st->base.obj,\n\t\t\t\t    &komeda_timing_ctrlr_obj_funcs);\n\n\treturn 0;\n}\n\nstatic struct drm_private_state *\nkomeda_pipeline_atomic_duplicate_state(struct drm_private_obj *obj)\n{\n\tstruct komeda_pipeline_state *st;\n\n\tst = kmemdup(obj->state, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn NULL;\n\n\tst->active_comps = 0;\n\n\t__drm_atomic_helper_private_obj_duplicate_state(obj, &st->obj);\n\n\treturn &st->obj;\n}\n\nstatic void\nkomeda_pipeline_atomic_destroy_state(struct drm_private_obj *obj,\n\t\t\t\t     struct drm_private_state *state)\n{\n\tkfree(priv_to_pipe_st(state));\n}\n\nstatic const struct drm_private_state_funcs komeda_pipeline_obj_funcs = {\n\t.atomic_duplicate_state\t= komeda_pipeline_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_pipeline_atomic_destroy_state,\n};\n\nstatic int komeda_pipeline_obj_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_pipeline *pipe)\n{\n\tstruct komeda_pipeline_state *st;\n\n\tst = kzalloc(sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->pipe = pipe;\n\tdrm_atomic_private_obj_init(&kms->base, &pipe->obj, &st->obj,\n\t\t\t\t    &komeda_pipeline_obj_funcs);\n\n\treturn 0;\n}\n\nint komeda_kms_add_private_objs(struct komeda_kms_dev *kms,\n\t\t\t\tstruct komeda_dev *mdev)\n{\n\tstruct komeda_pipeline *pipe;\n\tint i, j, err;\n\n\tfor (i = 0; i < mdev->n_pipelines; i++) {\n\t\tpipe = mdev->pipelines[i];\n\n\t\terr = komeda_pipeline_obj_add(kms, pipe);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor (j = 0; j < pipe->n_layers; j++) {\n\t\t\terr = komeda_layer_obj_add(kms, pipe->layers[j]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (pipe->wb_layer) {\n\t\t\terr = komeda_layer_obj_add(kms, pipe->wb_layer);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfor (j = 0; j < pipe->n_scalers; j++) {\n\t\t\terr = komeda_scaler_obj_add(kms, pipe->scalers[j]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = komeda_compiz_obj_add(kms, pipe->compiz);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (pipe->splitter) {\n\t\t\terr = komeda_splitter_obj_add(kms, pipe->splitter);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tif (pipe->merger) {\n\t\t\terr = komeda_merger_obj_add(kms, pipe->merger);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = komeda_improc_obj_add(kms, pipe->improc);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = komeda_timing_ctrlr_obj_add(kms, pipe->ctrlr);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid komeda_kms_cleanup_private_objs(struct komeda_kms_dev *kms)\n{\n\tstruct drm_mode_config *config = &kms->base.mode_config;\n\tstruct drm_private_obj *obj, *next;\n\n\tlist_for_each_entry_safe(obj, next, &config->privobj_list, head)\n\t\tdrm_atomic_private_obj_fini(obj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}