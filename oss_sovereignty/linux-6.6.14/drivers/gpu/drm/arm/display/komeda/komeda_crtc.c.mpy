{
  "module_name": "komeda_crtc.c",
  "hash_id": "598255483c678a07579b48aee3d39845e56fdc2a49e7581fa3971f441c093ed1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_crtc.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/spinlock.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_simple_kms_helper.h>\n#include <drm/drm_bridge.h>\n\n#include \"komeda_dev.h\"\n#include \"komeda_kms.h\"\n\nvoid komeda_crtc_get_color_config(struct drm_crtc_state *crtc_st,\n\t\t\t\t  u32 *color_depths, u32 *color_formats)\n{\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *conn_st;\n\tu32 conn_color_formats = ~0u;\n\tint i, min_bpc = 31, conn_bpc = 0;\n\n\tfor_each_new_connector_in_state(crtc_st->state, conn, conn_st, i) {\n\t\tif (conn_st->crtc != crtc_st->crtc)\n\t\t\tcontinue;\n\n\t\tconn_bpc = conn->display_info.bpc ? conn->display_info.bpc : 8;\n\t\tconn_color_formats &= conn->display_info.color_formats;\n\n\t\tif (conn_bpc < min_bpc)\n\t\t\tmin_bpc = conn_bpc;\n\t}\n\n\t \n\tif (!conn_color_formats)\n\t\tconn_color_formats = DRM_COLOR_FORMAT_RGB444;\n\n\t*color_depths = GENMASK(min_bpc, 0);\n\t*color_formats = conn_color_formats;\n}\n\nstatic void komeda_crtc_update_clock_ratio(struct komeda_crtc_state *kcrtc_st)\n{\n\tu64 pxlclk, aclk;\n\n\tif (!kcrtc_st->base.active) {\n\t\tkcrtc_st->clock_ratio = 0;\n\t\treturn;\n\t}\n\n\tpxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000ULL;\n\taclk = komeda_crtc_get_aclk(kcrtc_st);\n\n\tkcrtc_st->clock_ratio = div64_u64(aclk << 32, pxlclk);\n}\n\n \nstatic int\nkomeda_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\tstruct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc_state);\n\tint err;\n\n\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\tkomeda_crtc_update_clock_ratio(kcrtc_st);\n\n\tif (crtc_state->active) {\n\t\terr = komeda_build_display_data_flow(kcrtc, kcrtc_st);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = komeda_release_unclaimed_resources(kcrtc->slave, kcrtc_st);\n\tif (err)\n\t\treturn err;\n\n\terr = komeda_release_unclaimed_resources(kcrtc->master, kcrtc_st);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \nstatic int\nkomeda_crtc_prepare(struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kcrtc->base.dev->dev_private;\n\tstruct komeda_pipeline *master = kcrtc->master;\n\tstruct komeda_crtc_state *kcrtc_st = to_kcrtc_st(kcrtc->base.state);\n\tstruct drm_display_mode *mode = &kcrtc_st->base.adjusted_mode;\n\tu32 new_mode;\n\tint err;\n\n\tmutex_lock(&mdev->lock);\n\n\tnew_mode = mdev->dpmode | BIT(master->id);\n\tif (WARN_ON(new_mode == mdev->dpmode)) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\terr = mdev->funcs->change_opmode(mdev, new_mode);\n\tif (err) {\n\t\tDRM_ERROR(\"failed to change opmode: 0x%x -> 0x%x.\\n,\",\n\t\t\t  mdev->dpmode, new_mode);\n\t\tgoto unlock;\n\t}\n\n\tmdev->dpmode = new_mode;\n\t \n\tif (new_mode != KOMEDA_MODE_DUAL_DISP) {\n\t\terr = clk_set_rate(mdev->aclk, komeda_crtc_get_aclk(kcrtc_st));\n\t\tif (err)\n\t\t\tDRM_ERROR(\"failed to set aclk.\\n\");\n\t\terr = clk_prepare_enable(mdev->aclk);\n\t\tif (err)\n\t\t\tDRM_ERROR(\"failed to enable aclk.\\n\");\n\t}\n\n\terr = clk_set_rate(master->pxlclk, mode->crtc_clock * 1000);\n\tif (err)\n\t\tDRM_ERROR(\"failed to set pxlclk for pipe%d\\n\", master->id);\n\terr = clk_prepare_enable(master->pxlclk);\n\tif (err)\n\t\tDRM_ERROR(\"failed to enable pxl clk for pipe%d.\\n\", master->id);\n\nunlock:\n\tmutex_unlock(&mdev->lock);\n\n\treturn err;\n}\n\nstatic int\nkomeda_crtc_unprepare(struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kcrtc->base.dev->dev_private;\n\tstruct komeda_pipeline *master = kcrtc->master;\n\tu32 new_mode;\n\tint err;\n\n\tmutex_lock(&mdev->lock);\n\n\tnew_mode = mdev->dpmode & (~BIT(master->id));\n\n\tif (WARN_ON(new_mode == mdev->dpmode)) {\n\t\terr = 0;\n\t\tgoto unlock;\n\t}\n\n\terr = mdev->funcs->change_opmode(mdev, new_mode);\n\tif (err) {\n\t\tDRM_ERROR(\"failed to change opmode: 0x%x -> 0x%x.\\n,\",\n\t\t\t  mdev->dpmode, new_mode);\n\t\tgoto unlock;\n\t}\n\n\tmdev->dpmode = new_mode;\n\n\tclk_disable_unprepare(master->pxlclk);\n\tif (new_mode == KOMEDA_MODE_INACTIVE)\n\t\tclk_disable_unprepare(mdev->aclk);\n\nunlock:\n\tmutex_unlock(&mdev->lock);\n\n\treturn err;\n}\n\nvoid komeda_crtc_handle_event(struct komeda_crtc   *kcrtc,\n\t\t\t      struct komeda_events *evts)\n{\n\tstruct drm_crtc *crtc = &kcrtc->base;\n\tu32 events = evts->pipes[kcrtc->master->id];\n\n\tif (events & KOMEDA_EVENT_VSYNC)\n\t\tdrm_crtc_handle_vblank(crtc);\n\n\tif (events & KOMEDA_EVENT_EOW) {\n\t\tstruct komeda_wb_connector *wb_conn = kcrtc->wb_conn;\n\n\t\tif (wb_conn)\n\t\t\tdrm_writeback_signal_completion(&wb_conn->base, 0);\n\t\telse\n\t\t\tDRM_WARN(\"CRTC[%d]: EOW happen but no wb_connector.\\n\",\n\t\t\t\t drm_crtc_index(&kcrtc->base));\n\t}\n\t \n\tif (events & KOMEDA_EVENT_EOW)\n\t\tDRM_DEBUG(\"EOW.\\n\");\n\n\tif (events & KOMEDA_EVENT_FLIP) {\n\t\tunsigned long flags;\n\t\tstruct drm_pending_vblank_event *event;\n\n\t\tspin_lock_irqsave(&crtc->dev->event_lock, flags);\n\t\tif (kcrtc->disable_done) {\n\t\t\tcomplete_all(kcrtc->disable_done);\n\t\t\tkcrtc->disable_done = NULL;\n\t\t} else if (crtc->state->event) {\n\t\t\tevent = crtc->state->event;\n\t\t\t \n\t\t\tcrtc->state->event = NULL;\n\t\t\tdrm_crtc_send_vblank_event(crtc, event);\n\t\t} else {\n\t\t\tDRM_WARN(\"CRTC[%d]: FLIP happened but no pending commit.\\n\",\n\t\t\t\t drm_crtc_index(&kcrtc->base));\n\t\t}\n\t\tspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\n\t}\n}\n\nstatic void\nkomeda_crtc_do_flush(struct drm_crtc *crtc,\n\t\t     struct drm_crtc_state *old)\n{\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\tstruct komeda_crtc_state *kcrtc_st = to_kcrtc_st(crtc->state);\n\tstruct komeda_dev *mdev = kcrtc->base.dev->dev_private;\n\tstruct komeda_pipeline *master = kcrtc->master;\n\tstruct komeda_pipeline *slave = kcrtc->slave;\n\tstruct komeda_wb_connector *wb_conn = kcrtc->wb_conn;\n\tstruct drm_connector_state *conn_st;\n\n\tDRM_DEBUG_ATOMIC(\"CRTC%d_FLUSH: active_pipes: 0x%x, affected: 0x%x.\\n\",\n\t\t\t drm_crtc_index(crtc),\n\t\t\t kcrtc_st->active_pipes, kcrtc_st->affected_pipes);\n\n\t \n\tif (has_bit(master->id, kcrtc_st->affected_pipes))\n\t\tkomeda_pipeline_update(master, old->state);\n\n\tif (slave && has_bit(slave->id, kcrtc_st->affected_pipes))\n\t\tkomeda_pipeline_update(slave, old->state);\n\n\tconn_st = wb_conn ? wb_conn->base.base.state : NULL;\n\tif (conn_st && conn_st->writeback_job)\n\t\tdrm_writeback_queue_job(&wb_conn->base, conn_st);\n\n\t \n\tmdev->funcs->flush(mdev, master->id, kcrtc_st->active_pipes);\n}\n\nstatic void\nkomeda_crtc_atomic_enable(struct drm_crtc *crtc,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t   crtc);\n\tpm_runtime_get_sync(crtc->dev->dev);\n\tkomeda_crtc_prepare(to_kcrtc(crtc));\n\tdrm_crtc_vblank_on(crtc);\n\tWARN_ON(drm_crtc_vblank_get(crtc));\n\tkomeda_crtc_do_flush(crtc, old);\n}\n\nvoid\nkomeda_crtc_flush_and_wait_for_flip_done(struct komeda_crtc *kcrtc,\n\t\t\t\t\t struct completion *input_flip_done)\n{\n\tstruct drm_device *drm = kcrtc->base.dev;\n\tstruct komeda_dev *mdev = kcrtc->master->mdev;\n\tstruct completion *flip_done;\n\tstruct completion temp;\n\tint timeout;\n\n\t \n\tif (input_flip_done) {\n\t\tflip_done = input_flip_done;\n\t} else {\n\t\tinit_completion(&temp);\n\t\tkcrtc->disable_done = &temp;\n\t\tflip_done = &temp;\n\t}\n\n\tmdev->funcs->flush(mdev, kcrtc->master->id, 0);\n\n\t \n\ttimeout = wait_for_completion_timeout(flip_done, HZ);\n\tif (timeout == 0) {\n\t\tDRM_ERROR(\"wait pipe%d flip done timeout\\n\", kcrtc->master->id);\n\t\tif (!input_flip_done) {\n\t\t\tunsigned long flags;\n\n\t\t\tspin_lock_irqsave(&drm->event_lock, flags);\n\t\t\tkcrtc->disable_done = NULL;\n\t\t\tspin_unlock_irqrestore(&drm->event_lock, flags);\n\t\t}\n\t}\n}\n\nstatic void\nkomeda_crtc_atomic_disable(struct drm_crtc *crtc,\n\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *old = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t   crtc);\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\tstruct komeda_crtc_state *old_st = to_kcrtc_st(old);\n\tstruct komeda_pipeline *master = kcrtc->master;\n\tstruct komeda_pipeline *slave  = kcrtc->slave;\n\tstruct completion *disable_done;\n\tbool needs_phase2 = false;\n\n\tDRM_DEBUG_ATOMIC(\"CRTC%d_DISABLE: active_pipes: 0x%x, affected: 0x%x\\n\",\n\t\t\t drm_crtc_index(crtc),\n\t\t\t old_st->active_pipes, old_st->affected_pipes);\n\n\tif (slave && has_bit(slave->id, old_st->active_pipes))\n\t\tkomeda_pipeline_disable(slave, old->state);\n\n\tif (has_bit(master->id, old_st->active_pipes))\n\t\tneeds_phase2 = komeda_pipeline_disable(master, old->state);\n\n\t \n\tdisable_done = (needs_phase2 || crtc->state->active) ?\n\t\t       NULL : &crtc->state->commit->flip_done;\n\n\t \n\tkomeda_crtc_flush_and_wait_for_flip_done(kcrtc, disable_done);\n\n\t \n\tif (needs_phase2) {\n\t\tkomeda_pipeline_disable(kcrtc->master, old->state);\n\n\t\tdisable_done = crtc->state->active ?\n\t\t\t       NULL : &crtc->state->commit->flip_done;\n\n\t\tkomeda_crtc_flush_and_wait_for_flip_done(kcrtc, disable_done);\n\t}\n\n\tdrm_crtc_vblank_put(crtc);\n\tdrm_crtc_vblank_off(crtc);\n\tkomeda_crtc_unprepare(kcrtc);\n\tpm_runtime_put(crtc->dev->dev);\n}\n\nstatic void\nkomeda_crtc_atomic_flush(struct drm_crtc *crtc,\n\t\t\t struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct drm_crtc_state *old = drm_atomic_get_old_crtc_state(state,\n\t\t\t\t\t\t\t\t   crtc);\n\t \n\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\treturn;\n\n\tkomeda_crtc_do_flush(crtc, old);\n}\n\n \nstatic unsigned long\nkomeda_calc_min_aclk_rate(struct komeda_crtc *kcrtc,\n\t\t\t  unsigned long pxlclk)\n{\n\t \n\tif (kcrtc->master->dual_link)\n\t\treturn pxlclk * 2;\n\telse\n\t\treturn pxlclk;\n}\n\n \nunsigned long komeda_crtc_get_aclk(struct komeda_crtc_state *kcrtc_st)\n{\n\tstruct drm_crtc *crtc = kcrtc_st->base.crtc;\n\tstruct komeda_dev *mdev = crtc->dev->dev_private;\n\tunsigned long pxlclk = kcrtc_st->base.adjusted_mode.crtc_clock * 1000;\n\tunsigned long min_aclk;\n\n\tmin_aclk = komeda_calc_min_aclk_rate(to_kcrtc(crtc), pxlclk);\n\n\treturn clk_round_rate(mdev->aclk, min_aclk);\n}\n\nstatic enum drm_mode_status\nkomeda_crtc_mode_valid(struct drm_crtc *crtc, const struct drm_display_mode *m)\n{\n\tstruct komeda_dev *mdev = crtc->dev->dev_private;\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\tstruct komeda_pipeline *master = kcrtc->master;\n\tunsigned long min_pxlclk, min_aclk;\n\n\tif (m->flags & DRM_MODE_FLAG_INTERLACE)\n\t\treturn MODE_NO_INTERLACE;\n\n\tmin_pxlclk = m->clock * 1000;\n\tif (master->dual_link)\n\t\tmin_pxlclk /= 2;\n\n\tif (min_pxlclk != clk_round_rate(master->pxlclk, min_pxlclk)) {\n\t\tDRM_DEBUG_ATOMIC(\"pxlclk doesn't support %lu Hz\\n\", min_pxlclk);\n\n\t\treturn MODE_NOCLOCK;\n\t}\n\n\tmin_aclk = komeda_calc_min_aclk_rate(to_kcrtc(crtc), min_pxlclk);\n\tif (clk_round_rate(mdev->aclk, min_aclk) < min_aclk) {\n\t\tDRM_DEBUG_ATOMIC(\"engine clk can't satisfy the requirement of %s-clk: %lu.\\n\",\n\t\t\t\t m->name, min_pxlclk);\n\n\t\treturn MODE_CLOCK_HIGH;\n\t}\n\n\treturn MODE_OK;\n}\n\nstatic bool komeda_crtc_mode_fixup(struct drm_crtc *crtc,\n\t\t\t\t   const struct drm_display_mode *m,\n\t\t\t\t   struct drm_display_mode *adjusted_mode)\n{\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\tunsigned long clk_rate;\n\n\tdrm_mode_set_crtcinfo(adjusted_mode, 0);\n\t \n\tif (kcrtc->master->dual_link) {\n\t\tadjusted_mode->crtc_clock /= 2;\n\t\tadjusted_mode->crtc_hdisplay /= 2;\n\t\tadjusted_mode->crtc_hsync_start /= 2;\n\t\tadjusted_mode->crtc_hsync_end /= 2;\n\t\tadjusted_mode->crtc_htotal /= 2;\n\t}\n\n\tclk_rate = adjusted_mode->crtc_clock * 1000;\n\t \n\tadjusted_mode->crtc_clock = clk_round_rate(kcrtc->master->pxlclk,\n\t\t\t\t\t\t   clk_rate) / 1000;\n\n\treturn true;\n}\n\nstatic const struct drm_crtc_helper_funcs komeda_crtc_helper_funcs = {\n\t.atomic_check\t= komeda_crtc_atomic_check,\n\t.atomic_flush\t= komeda_crtc_atomic_flush,\n\t.atomic_enable\t= komeda_crtc_atomic_enable,\n\t.atomic_disable\t= komeda_crtc_atomic_disable,\n\t.mode_valid\t= komeda_crtc_mode_valid,\n\t.mode_fixup\t= komeda_crtc_mode_fixup,\n};\n\nstatic void komeda_crtc_reset(struct drm_crtc *crtc)\n{\n\tstruct komeda_crtc_state *state;\n\n\tif (crtc->state)\n\t\t__drm_atomic_helper_crtc_destroy_state(crtc->state);\n\n\tkfree(to_kcrtc_st(crtc->state));\n\tcrtc->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_crtc_reset(crtc, &state->base);\n}\n\nstatic struct drm_crtc_state *\nkomeda_crtc_atomic_duplicate_state(struct drm_crtc *crtc)\n{\n\tstruct komeda_crtc_state *old = to_kcrtc_st(crtc->state);\n\tstruct komeda_crtc_state *new;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_crtc_duplicate_state(crtc, &new->base);\n\n\tnew->affected_pipes = old->active_pipes;\n\tnew->clock_ratio = old->clock_ratio;\n\tnew->max_slave_zorder = old->max_slave_zorder;\n\n\treturn &new->base;\n}\n\nstatic void komeda_crtc_atomic_destroy_state(struct drm_crtc *crtc,\n\t\t\t\t\t     struct drm_crtc_state *state)\n{\n\t__drm_atomic_helper_crtc_destroy_state(state);\n\tkfree(to_kcrtc_st(state));\n}\n\nstatic int komeda_crtc_vblank_enable(struct drm_crtc *crtc)\n{\n\tstruct komeda_dev *mdev = crtc->dev->dev_private;\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\n\tmdev->funcs->on_off_vblank(mdev, kcrtc->master->id, true);\n\treturn 0;\n}\n\nstatic void komeda_crtc_vblank_disable(struct drm_crtc *crtc)\n{\n\tstruct komeda_dev *mdev = crtc->dev->dev_private;\n\tstruct komeda_crtc *kcrtc = to_kcrtc(crtc);\n\n\tmdev->funcs->on_off_vblank(mdev, kcrtc->master->id, false);\n}\n\nstatic const struct drm_crtc_funcs komeda_crtc_funcs = {\n\t.destroy\t\t= drm_crtc_cleanup,\n\t.set_config\t\t= drm_atomic_helper_set_config,\n\t.page_flip\t\t= drm_atomic_helper_page_flip,\n\t.reset\t\t\t= komeda_crtc_reset,\n\t.atomic_duplicate_state\t= komeda_crtc_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_crtc_atomic_destroy_state,\n\t.enable_vblank\t\t= komeda_crtc_vblank_enable,\n\t.disable_vblank\t\t= komeda_crtc_vblank_disable,\n};\n\nint komeda_kms_setup_crtcs(struct komeda_kms_dev *kms,\n\t\t\t   struct komeda_dev *mdev)\n{\n\tstruct komeda_crtc *crtc;\n\tstruct komeda_pipeline *master;\n\tchar str[16];\n\tint i;\n\n\tkms->n_crtcs = 0;\n\n\tfor (i = 0; i < mdev->n_pipelines; i++) {\n\t\tcrtc = &kms->crtcs[kms->n_crtcs];\n\t\tmaster = mdev->pipelines[i];\n\n\t\tcrtc->master = master;\n\t\tcrtc->slave  = komeda_pipeline_get_slave(master);\n\n\t\tif (crtc->slave)\n\t\t\tsprintf(str, \"pipe-%d\", crtc->slave->id);\n\t\telse\n\t\t\tsprintf(str, \"None\");\n\n\t\tDRM_INFO(\"CRTC-%d: master(pipe-%d) slave(%s).\\n\",\n\t\t\t kms->n_crtcs, master->id, str);\n\n\t\tkms->n_crtcs++;\n\t}\n\n\treturn 0;\n}\n\nstatic struct drm_plane *\nget_crtc_primary(struct komeda_kms_dev *kms, struct komeda_crtc *crtc)\n{\n\tstruct komeda_plane *kplane;\n\tstruct drm_plane *plane;\n\n\tdrm_for_each_plane(plane, &kms->base) {\n\t\tif (plane->type != DRM_PLANE_TYPE_PRIMARY)\n\t\t\tcontinue;\n\n\t\tkplane = to_kplane(plane);\n\t\t \n\t\tif (kplane->layer->base.pipeline == crtc->master)\n\t\t\treturn plane;\n\t}\n\n\treturn NULL;\n}\n\nstatic int komeda_crtc_add(struct komeda_kms_dev *kms,\n\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct drm_crtc *crtc = &kcrtc->base;\n\tstruct drm_device *base = &kms->base;\n\tstruct drm_bridge *bridge;\n\tint err;\n\n\terr = drm_crtc_init_with_planes(base, crtc,\n\t\t\t\t\tget_crtc_primary(kms, kcrtc), NULL,\n\t\t\t\t\t&komeda_crtc_funcs, NULL);\n\tif (err)\n\t\treturn err;\n\n\tdrm_crtc_helper_add(crtc, &komeda_crtc_helper_funcs);\n\n\tcrtc->port = kcrtc->master->of_output_port;\n\n\t \n\tkcrtc->encoder.possible_crtcs = drm_crtc_mask(crtc);\n\terr = drm_simple_encoder_init(base, &kcrtc->encoder,\n\t\t\t\t      DRM_MODE_ENCODER_TMDS);\n\tif (err)\n\t\treturn err;\n\n\tbridge = devm_drm_of_get_bridge(base->dev, kcrtc->master->of_node,\n\t\t\t\t\tKOMEDA_OF_PORT_OUTPUT, 0);\n\tif (IS_ERR(bridge))\n\t\treturn PTR_ERR(bridge);\n\n\terr = drm_bridge_attach(&kcrtc->encoder, bridge, NULL, 0);\n\n\tdrm_crtc_enable_color_mgmt(crtc, 0, true, KOMEDA_COLOR_LUT_SIZE);\n\n\treturn err;\n}\n\nint komeda_kms_add_crtcs(struct komeda_kms_dev *kms, struct komeda_dev *mdev)\n{\n\tint i, err;\n\n\tfor (i = 0; i < kms->n_crtcs; i++) {\n\t\terr = komeda_crtc_add(kms, &kms->crtcs[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}