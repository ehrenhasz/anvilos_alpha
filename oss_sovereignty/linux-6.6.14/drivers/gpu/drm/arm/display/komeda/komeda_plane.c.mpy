{
  "module_name": "komeda_plane.c",
  "hash_id": "f8a0ed296a0966edea69d932c5e60525557a3860fcca26941b1c7c9f06324c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_plane.c",
  "human_readable_source": "\n \n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_print.h>\n#include \"komeda_dev.h\"\n#include \"komeda_kms.h\"\n#include \"komeda_framebuffer.h\"\n\nstatic int\nkomeda_plane_init_data_flow(struct drm_plane_state *st,\n\t\t\t    struct komeda_crtc_state *kcrtc_st,\n\t\t\t    struct komeda_data_flow_cfg *dflow)\n{\n\tstruct komeda_plane *kplane = to_kplane(st->plane);\n\tstruct drm_framebuffer *fb = st->fb;\n\tconst struct komeda_format_caps *caps = to_kfb(fb)->format_caps;\n\tstruct komeda_pipeline *pipe = kplane->layer->base.pipeline;\n\n\tmemset(dflow, 0, sizeof(*dflow));\n\n\tdflow->blending_zorder = st->normalized_zpos;\n\tif (pipe == to_kcrtc(st->crtc)->master)\n\t\tdflow->blending_zorder -= kcrtc_st->max_slave_zorder;\n\tif (dflow->blending_zorder < 0) {\n\t\tDRM_DEBUG_ATOMIC(\"%s zorder:%d < max_slave_zorder: %d.\\n\",\n\t\t\t\t st->plane->name, st->normalized_zpos,\n\t\t\t\t kcrtc_st->max_slave_zorder);\n\t\treturn -EINVAL;\n\t}\n\n\tdflow->pixel_blend_mode = st->pixel_blend_mode;\n\tdflow->layer_alpha = st->alpha >> 8;\n\n\tdflow->out_x = st->crtc_x;\n\tdflow->out_y = st->crtc_y;\n\tdflow->out_w = st->crtc_w;\n\tdflow->out_h = st->crtc_h;\n\n\tdflow->in_x = st->src_x >> 16;\n\tdflow->in_y = st->src_y >> 16;\n\tdflow->in_w = st->src_w >> 16;\n\tdflow->in_h = st->src_h >> 16;\n\n\tdflow->rot = drm_rotation_simplify(st->rotation, caps->supported_rots);\n\tif (!has_bits(dflow->rot, caps->supported_rots)) {\n\t\tDRM_DEBUG_ATOMIC(\"rotation(0x%x) isn't supported by %p4cc with modifier: 0x%llx.\\n\",\n\t\t\t\t dflow->rot, &caps->fourcc, fb->modifier);\n\t\treturn -EINVAL;\n\t}\n\n\tkomeda_complete_data_flow_cfg(kplane->layer, dflow, fb);\n\n\treturn 0;\n}\n\n \nstatic int\nkomeda_plane_atomic_check(struct drm_plane *plane,\n\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,\n\t\t\t\t\t\t\t\t\t\t plane);\n\tstruct komeda_plane *kplane = to_kplane(plane);\n\tstruct komeda_plane_state *kplane_st = to_kplane_st(new_plane_state);\n\tstruct komeda_layer *layer = kplane->layer;\n\tstruct drm_crtc_state *crtc_st;\n\tstruct komeda_crtc_state *kcrtc_st;\n\tstruct komeda_data_flow_cfg dflow;\n\tint err;\n\n\tif (!new_plane_state->crtc || !new_plane_state->fb)\n\t\treturn 0;\n\n\tcrtc_st = drm_atomic_get_crtc_state(state,\n\t\t\t\t\t    new_plane_state->crtc);\n\tif (IS_ERR(crtc_st) || !crtc_st->enable) {\n\t\tDRM_DEBUG_ATOMIC(\"Cannot update plane on a disabled CRTC.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!crtc_st->active)\n\t\treturn 0;\n\n\tkcrtc_st = to_kcrtc_st(crtc_st);\n\n\terr = komeda_plane_init_data_flow(new_plane_state, kcrtc_st, &dflow);\n\tif (err)\n\t\treturn err;\n\n\tif (dflow.en_split)\n\t\terr = komeda_build_layer_split_data_flow(layer,\n\t\t\t\tkplane_st, kcrtc_st, &dflow);\n\telse\n\t\terr = komeda_build_layer_data_flow(layer,\n\t\t\t\tkplane_st, kcrtc_st, &dflow);\n\n\treturn err;\n}\n\n \nstatic void\nkomeda_plane_atomic_update(struct drm_plane *plane,\n\t\t\t   struct drm_atomic_state *state)\n{\n}\n\nstatic const struct drm_plane_helper_funcs komeda_plane_helper_funcs = {\n\t.atomic_check\t= komeda_plane_atomic_check,\n\t.atomic_update\t= komeda_plane_atomic_update,\n};\n\nstatic void komeda_plane_destroy(struct drm_plane *plane)\n{\n\tdrm_plane_cleanup(plane);\n\n\tkfree(to_kplane(plane));\n}\n\nstatic void komeda_plane_reset(struct drm_plane *plane)\n{\n\tstruct komeda_plane_state *state;\n\n\tif (plane->state)\n\t\t__drm_atomic_helper_plane_destroy_state(plane->state);\n\n\tkfree(plane->state);\n\tplane->state = NULL;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (state)\n\t\t__drm_atomic_helper_plane_reset(plane, &state->base);\n}\n\nstatic struct drm_plane_state *\nkomeda_plane_atomic_duplicate_state(struct drm_plane *plane)\n{\n\tstruct komeda_plane_state *new;\n\n\tif (WARN_ON(!plane->state))\n\t\treturn NULL;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\t__drm_atomic_helper_plane_duplicate_state(plane, &new->base);\n\n\treturn &new->base;\n}\n\nstatic void\nkomeda_plane_atomic_destroy_state(struct drm_plane *plane,\n\t\t\t\t  struct drm_plane_state *state)\n{\n\t__drm_atomic_helper_plane_destroy_state(state);\n\tkfree(to_kplane_st(state));\n}\n\nstatic bool\nkomeda_plane_format_mod_supported(struct drm_plane *plane,\n\t\t\t\t  u32 format, u64 modifier)\n{\n\tstruct komeda_dev *mdev = plane->dev->dev_private;\n\tstruct komeda_plane *kplane = to_kplane(plane);\n\tu32 layer_type = kplane->layer->layer_type;\n\n\treturn komeda_format_mod_supported(&mdev->fmt_tbl, layer_type,\n\t\t\t\t\t   format, modifier, 0);\n}\n\nstatic const struct drm_plane_funcs komeda_plane_funcs = {\n\t.update_plane\t\t= drm_atomic_helper_update_plane,\n\t.disable_plane\t\t= drm_atomic_helper_disable_plane,\n\t.destroy\t\t= komeda_plane_destroy,\n\t.reset\t\t\t= komeda_plane_reset,\n\t.atomic_duplicate_state\t= komeda_plane_atomic_duplicate_state,\n\t.atomic_destroy_state\t= komeda_plane_atomic_destroy_state,\n\t.format_mod_supported\t= komeda_plane_format_mod_supported,\n};\n\n \nstatic u32 get_possible_crtcs(struct komeda_kms_dev *kms,\n\t\t\t      struct komeda_pipeline *pipe)\n{\n\tstruct komeda_crtc *crtc;\n\tu32 possible_crtcs = 0;\n\tint i;\n\n\tfor (i = 0; i < kms->n_crtcs; i++) {\n\t\tcrtc = &kms->crtcs[i];\n\n\t\tif ((pipe == crtc->master) || (pipe == crtc->slave))\n\t\t\tpossible_crtcs |= BIT(i);\n\t}\n\n\treturn possible_crtcs;\n}\n\nstatic void\nkomeda_set_crtc_plane_mask(struct komeda_kms_dev *kms,\n\t\t\t   struct komeda_pipeline *pipe,\n\t\t\t   struct drm_plane *plane)\n{\n\tstruct komeda_crtc *kcrtc;\n\tint i;\n\n\tfor (i = 0; i < kms->n_crtcs; i++) {\n\t\tkcrtc = &kms->crtcs[i];\n\n\t\tif (pipe == kcrtc->slave)\n\t\t\tkcrtc->slave_planes |= BIT(drm_plane_index(plane));\n\t}\n}\n\n \nstatic u32 get_plane_type(struct komeda_kms_dev *kms,\n\t\t\t  struct komeda_component *c)\n{\n\tbool is_primary = (c->id == KOMEDA_COMPONENT_LAYER0);\n\n\treturn is_primary ? DRM_PLANE_TYPE_PRIMARY : DRM_PLANE_TYPE_OVERLAY;\n}\n\nstatic int komeda_plane_add(struct komeda_kms_dev *kms,\n\t\t\t    struct komeda_layer *layer)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_component *c = &layer->base;\n\tstruct komeda_plane *kplane;\n\tstruct drm_plane *plane;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\n\tkplane = kzalloc(sizeof(*kplane), GFP_KERNEL);\n\tif (!kplane)\n\t\treturn -ENOMEM;\n\n\tplane = &kplane->base;\n\tkplane->layer = layer;\n\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       layer->layer_type, &n_formats);\n\tif (!formats) {\n\t\tkfree(kplane);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = drm_universal_plane_init(&kms->base, plane,\n\t\t\tget_possible_crtcs(kms, c->pipeline),\n\t\t\t&komeda_plane_funcs,\n\t\t\tformats, n_formats, komeda_supported_modifiers,\n\t\t\tget_plane_type(kms, c),\n\t\t\t\"%s\", c->name);\n\n\tkomeda_put_fourcc_list(formats);\n\n\tif (err) {\n\t\tkfree(kplane);\n\t\treturn err;\n\t}\n\n\tdrm_plane_helper_add(plane, &komeda_plane_helper_funcs);\n\n\terr = drm_plane_create_rotation_property(plane, DRM_MODE_ROTATE_0,\n\t\t\t\t\t\t layer->supported_rots);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = drm_plane_create_alpha_property(plane);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = drm_plane_create_blend_mode_property(plane,\n\t\t\tBIT(DRM_MODE_BLEND_PIXEL_NONE) |\n\t\t\tBIT(DRM_MODE_BLEND_PREMULTI)   |\n\t\t\tBIT(DRM_MODE_BLEND_COVERAGE));\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = drm_plane_create_color_properties(plane,\n\t\t\tBIT(DRM_COLOR_YCBCR_BT601) |\n\t\t\tBIT(DRM_COLOR_YCBCR_BT709) |\n\t\t\tBIT(DRM_COLOR_YCBCR_BT2020),\n\t\t\tBIT(DRM_COLOR_YCBCR_LIMITED_RANGE) |\n\t\t\tBIT(DRM_COLOR_YCBCR_FULL_RANGE),\n\t\t\tDRM_COLOR_YCBCR_BT601,\n\t\t\tDRM_COLOR_YCBCR_LIMITED_RANGE);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = drm_plane_create_zpos_property(plane, layer->base.id, 0, 8);\n\tif (err)\n\t\tgoto cleanup;\n\n\tkomeda_set_crtc_plane_mask(kms, c->pipeline, plane);\n\n\treturn 0;\ncleanup:\n\tkomeda_plane_destroy(plane);\n\treturn err;\n}\n\nint komeda_kms_add_planes(struct komeda_kms_dev *kms, struct komeda_dev *mdev)\n{\n\tstruct komeda_pipeline *pipe;\n\tint i, j, err;\n\n\tfor (i = 0; i < mdev->n_pipelines; i++) {\n\t\tpipe = mdev->pipelines[i];\n\n\t\tfor (j = 0; j < pipe->n_layers; j++) {\n\t\t\terr = komeda_plane_add(kms, pipe->layers[j]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}