{
  "module_name": "komeda_dev.c",
  "hash_id": "71a1bc061c9f15125a57866091d5d805f304a4712877952273434972dc7fe5b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_dev.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/iommu.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#ifdef CONFIG_DEBUG_FS\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#endif\n\n#include <drm/drm_print.h>\n\n#include \"komeda_dev.h\"\n\nstatic int komeda_register_show(struct seq_file *sf, void *x)\n{\n\tstruct komeda_dev *mdev = sf->private;\n\tint i;\n\n\tseq_puts(sf, \"\\n====== Komeda register dump =========\\n\");\n\n\tpm_runtime_get_sync(mdev->dev);\n\n\tif (mdev->funcs->dump_register)\n\t\tmdev->funcs->dump_register(mdev, sf);\n\n\tfor (i = 0; i < mdev->n_pipelines; i++)\n\t\tkomeda_pipeline_dump_register(mdev->pipelines[i], sf);\n\n\tpm_runtime_put(mdev->dev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(komeda_register);\n\n#ifdef CONFIG_DEBUG_FS\nstatic void komeda_debugfs_init(struct komeda_dev *mdev)\n{\n\tif (!debugfs_initialized())\n\t\treturn;\n\n\tmdev->debugfs_root = debugfs_create_dir(\"komeda\", NULL);\n\tdebugfs_create_file(\"register\", 0444, mdev->debugfs_root,\n\t\t\t    mdev, &komeda_register_fops);\n\tdebugfs_create_x16(\"err_verbosity\", 0664, mdev->debugfs_root,\n\t\t\t   &mdev->err_verbosity);\n}\n#endif\n\nstatic ssize_t\ncore_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct komeda_dev *mdev = dev_to_mdev(dev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", mdev->chip.core_id);\n}\nstatic DEVICE_ATTR_RO(core_id);\n\nstatic ssize_t\nconfig_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct komeda_dev *mdev = dev_to_mdev(dev);\n\tstruct komeda_pipeline *pipe = mdev->pipelines[0];\n\tunion komeda_config_id config_id;\n\tint i;\n\n\tmemset(&config_id, 0, sizeof(config_id));\n\n\tconfig_id.max_line_sz = pipe->layers[0]->hsize_in.end;\n\tconfig_id.n_pipelines = mdev->n_pipelines;\n\tconfig_id.n_scalers = pipe->n_scalers;\n\tconfig_id.n_layers = pipe->n_layers;\n\tconfig_id.n_richs = 0;\n\tfor (i = 0; i < pipe->n_layers; i++) {\n\t\tif (pipe->layers[i]->layer_type == KOMEDA_FMT_RICH_LAYER)\n\t\t\tconfig_id.n_richs++;\n\t}\n\treturn sysfs_emit(buf, \"0x%08x\\n\", config_id.value);\n}\nstatic DEVICE_ATTR_RO(config_id);\n\nstatic ssize_t\naclk_hz_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct komeda_dev *mdev = dev_to_mdev(dev);\n\n\treturn sysfs_emit(buf, \"%lu\\n\", clk_get_rate(mdev->aclk));\n}\nstatic DEVICE_ATTR_RO(aclk_hz);\n\nstatic struct attribute *komeda_sysfs_entries[] = {\n\t&dev_attr_core_id.attr,\n\t&dev_attr_config_id.attr,\n\t&dev_attr_aclk_hz.attr,\n\tNULL,\n};\n\nstatic struct attribute_group komeda_sysfs_attr_group = {\n\t.attrs = komeda_sysfs_entries,\n};\n\nstatic int komeda_parse_pipe_dt(struct komeda_pipeline *pipe)\n{\n\tstruct device_node *np = pipe->of_node;\n\tstruct clk *clk;\n\n\tclk = of_clk_get_by_name(np, \"pxclk\");\n\tif (IS_ERR(clk)) {\n\t\tDRM_ERROR(\"get pxclk for pipeline %d failed!\\n\", pipe->id);\n\t\treturn PTR_ERR(clk);\n\t}\n\tpipe->pxlclk = clk;\n\n\t \n\tpipe->of_output_links[0] =\n\t\tof_graph_get_remote_node(np, KOMEDA_OF_PORT_OUTPUT, 0);\n\tpipe->of_output_links[1] =\n\t\tof_graph_get_remote_node(np, KOMEDA_OF_PORT_OUTPUT, 1);\n\tpipe->of_output_port =\n\t\tof_graph_get_port_by_id(np, KOMEDA_OF_PORT_OUTPUT);\n\n\tpipe->dual_link = pipe->of_output_links[0] && pipe->of_output_links[1];\n\n\treturn 0;\n}\n\nstatic int komeda_parse_dt(struct device *dev, struct komeda_dev *mdev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct device_node *child, *np = dev->of_node;\n\tstruct komeda_pipeline *pipe;\n\tu32 pipe_id = U32_MAX;\n\tint ret = -1;\n\n\tmdev->irq  = platform_get_irq(pdev, 0);\n\tif (mdev->irq < 0) {\n\t\tDRM_ERROR(\"could not get IRQ number.\\n\");\n\t\treturn mdev->irq;\n\t}\n\n\t \n\tret = of_reserved_mem_device_init(dev);\n\tif (ret && ret != -ENODEV)\n\t\treturn ret;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tif (of_node_name_eq(child, \"pipeline\")) {\n\t\t\tof_property_read_u32(child, \"reg\", &pipe_id);\n\t\t\tif (pipe_id >= mdev->n_pipelines) {\n\t\t\t\tDRM_WARN(\"Skip the redundant DT node: pipeline-%u.\\n\",\n\t\t\t\t\t pipe_id);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmdev->pipelines[pipe_id]->of_node = of_node_get(child);\n\t\t}\n\t}\n\n\tfor (pipe_id = 0; pipe_id < mdev->n_pipelines; pipe_id++) {\n\t\tpipe = mdev->pipelines[pipe_id];\n\n\t\tif (!pipe->of_node) {\n\t\t\tDRM_ERROR(\"Pipeline-%d doesn't have a DT node.\\n\",\n\t\t\t\t  pipe->id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = komeda_parse_pipe_dt(pipe);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct komeda_dev *komeda_dev_create(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tkomeda_identify_func komeda_identify;\n\tstruct komeda_dev *mdev;\n\tint err = 0;\n\n\tkomeda_identify = of_device_get_match_data(dev);\n\tif (!komeda_identify)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmdev = devm_kzalloc(dev, sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&mdev->lock);\n\n\tmdev->dev = dev;\n\tmdev->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mdev->reg_base)) {\n\t\tDRM_ERROR(\"Map register space failed.\\n\");\n\t\terr = PTR_ERR(mdev->reg_base);\n\t\tmdev->reg_base = NULL;\n\t\tgoto err_cleanup;\n\t}\n\n\tmdev->aclk = devm_clk_get(dev, \"aclk\");\n\tif (IS_ERR(mdev->aclk)) {\n\t\tDRM_ERROR(\"Get engine clk failed.\\n\");\n\t\terr = PTR_ERR(mdev->aclk);\n\t\tmdev->aclk = NULL;\n\t\tgoto err_cleanup;\n\t}\n\n\tclk_prepare_enable(mdev->aclk);\n\n\tmdev->funcs = komeda_identify(mdev->reg_base, &mdev->chip);\n\tif (!mdev->funcs) {\n\t\tDRM_ERROR(\"Failed to identify the HW.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto disable_clk;\n\t}\n\n\tDRM_INFO(\"Found ARM Mali-D%x version r%dp%d\\n\",\n\t\t MALIDP_CORE_ID_PRODUCT_ID(mdev->chip.core_id),\n\t\t MALIDP_CORE_ID_MAJOR(mdev->chip.core_id),\n\t\t MALIDP_CORE_ID_MINOR(mdev->chip.core_id));\n\n\tmdev->funcs->init_format_table(mdev);\n\n\terr = mdev->funcs->enum_resources(mdev);\n\tif (err) {\n\t\tDRM_ERROR(\"enumerate display resource failed.\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\terr = komeda_parse_dt(dev, mdev);\n\tif (err) {\n\t\tDRM_ERROR(\"parse device tree failed.\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\terr = komeda_assemble_pipelines(mdev);\n\tif (err) {\n\t\tDRM_ERROR(\"assemble display pipelines failed.\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\tdma_set_max_seg_size(dev, U32_MAX);\n\n\tmdev->iommu = iommu_get_domain_for_dev(mdev->dev);\n\tif (!mdev->iommu)\n\t\tDRM_INFO(\"continue without IOMMU support!\\n\");\n\n\tclk_disable_unprepare(mdev->aclk);\n\n\terr = sysfs_create_group(&dev->kobj, &komeda_sysfs_attr_group);\n\tif (err) {\n\t\tDRM_ERROR(\"create sysfs group failed.\\n\");\n\t\tgoto err_cleanup;\n\t}\n\n\tmdev->err_verbosity = KOMEDA_DEV_PRINT_ERR_EVENTS;\n\n#ifdef CONFIG_DEBUG_FS\n\tkomeda_debugfs_init(mdev);\n#endif\n\n\treturn mdev;\n\ndisable_clk:\n\tclk_disable_unprepare(mdev->aclk);\nerr_cleanup:\n\tkomeda_dev_destroy(mdev);\n\treturn ERR_PTR(err);\n}\n\nvoid komeda_dev_destroy(struct komeda_dev *mdev)\n{\n\tstruct device *dev = mdev->dev;\n\tconst struct komeda_dev_funcs *funcs = mdev->funcs;\n\tint i;\n\n\tsysfs_remove_group(&dev->kobj, &komeda_sysfs_attr_group);\n\n#ifdef CONFIG_DEBUG_FS\n\tdebugfs_remove_recursive(mdev->debugfs_root);\n#endif\n\n\tif (mdev->aclk)\n\t\tclk_prepare_enable(mdev->aclk);\n\n\tfor (i = 0; i < mdev->n_pipelines; i++) {\n\t\tkomeda_pipeline_destroy(mdev, mdev->pipelines[i]);\n\t\tmdev->pipelines[i] = NULL;\n\t}\n\n\tmdev->n_pipelines = 0;\n\n\tof_reserved_mem_device_release(dev);\n\n\tif (funcs && funcs->cleanup)\n\t\tfuncs->cleanup(mdev);\n\n\tif (mdev->reg_base) {\n\t\tdevm_iounmap(dev, mdev->reg_base);\n\t\tmdev->reg_base = NULL;\n\t}\n\n\tif (mdev->aclk) {\n\t\tclk_disable_unprepare(mdev->aclk);\n\t\tdevm_clk_put(dev, mdev->aclk);\n\t\tmdev->aclk = NULL;\n\t}\n\n\tdevm_kfree(dev, mdev);\n}\n\nint komeda_dev_resume(struct komeda_dev *mdev)\n{\n\tclk_prepare_enable(mdev->aclk);\n\n\tmdev->funcs->enable_irq(mdev);\n\n\tif (mdev->iommu && mdev->funcs->connect_iommu)\n\t\tif (mdev->funcs->connect_iommu(mdev))\n\t\t\tDRM_ERROR(\"connect iommu failed.\\n\");\n\n\treturn 0;\n}\n\nint komeda_dev_suspend(struct komeda_dev *mdev)\n{\n\tif (mdev->iommu && mdev->funcs->disconnect_iommu)\n\t\tif (mdev->funcs->disconnect_iommu(mdev))\n\t\t\tDRM_ERROR(\"disconnect iommu failed.\\n\");\n\n\tmdev->funcs->disable_irq(mdev);\n\n\tclk_disable_unprepare(mdev->aclk);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}