{
  "module_name": "komeda_framebuffer.c",
  "hash_id": "2b694a03719b23df37029c330c33f7fc047b871de853a1856b543f2ddc58ae28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_framebuffer.c",
  "human_readable_source": "\n \n#include <drm/drm_device.h>\n#include <drm/drm_fb_dma_helper.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_dma_helper.h>\n#include <drm/drm_gem_framebuffer_helper.h>\n\n#include \"komeda_framebuffer.h\"\n#include \"komeda_dev.h\"\n\nstatic void komeda_fb_destroy(struct drm_framebuffer *fb)\n{\n\tstruct komeda_fb *kfb = to_kfb(fb);\n\tu32 i;\n\n\tfor (i = 0; i < fb->format->num_planes; i++)\n\t\tdrm_gem_object_put(fb->obj[i]);\n\n\tdrm_framebuffer_cleanup(fb);\n\tkfree(kfb);\n}\n\nstatic int komeda_fb_create_handle(struct drm_framebuffer *fb,\n\t\t\t\t   struct drm_file *file, u32 *handle)\n{\n\treturn drm_gem_handle_create(file, fb->obj[0], handle);\n}\n\nstatic const struct drm_framebuffer_funcs komeda_fb_funcs = {\n\t.destroy\t= komeda_fb_destroy,\n\t.create_handle\t= komeda_fb_create_handle,\n};\n\nstatic int\nkomeda_fb_afbc_size_check(struct komeda_fb *kfb, struct drm_file *file,\n\t\t\t  const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_framebuffer *fb = &kfb->base;\n\tconst struct drm_format_info *info = fb->format;\n\tstruct drm_gem_object *obj;\n\tu32 alignment_w = 0, alignment_h = 0, alignment_header, n_blocks, bpp;\n\tu64 min_size;\n\n\tobj = drm_gem_object_lookup(file, mode_cmd->handles[0]);\n\tif (!obj) {\n\t\tDRM_DEBUG_KMS(\"Failed to lookup GEM object\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tswitch (fb->modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK) {\n\tcase AFBC_FORMAT_MOD_BLOCK_SIZE_32x8:\n\t\talignment_w = 32;\n\t\talignment_h = 8;\n\t\tbreak;\n\tcase AFBC_FORMAT_MOD_BLOCK_SIZE_16x16:\n\t\talignment_w = 16;\n\t\talignment_h = 16;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid AFBC_FORMAT_MOD_BLOCK_SIZE: %lld.\\n\",\n\t\t     fb->modifier & AFBC_FORMAT_MOD_BLOCK_SIZE_MASK);\n\t\tbreak;\n\t}\n\n\t \n\tif (fb->modifier & AFBC_FORMAT_MOD_TILED) {\n\t\talignment_w *= AFBC_TH_LAYOUT_ALIGNMENT;\n\t\talignment_h *= AFBC_TH_LAYOUT_ALIGNMENT;\n\t\talignment_header = AFBC_TH_BODY_START_ALIGNMENT;\n\t} else {\n\t\talignment_header = AFBC_BODY_START_ALIGNMENT;\n\t}\n\n\tkfb->aligned_w = ALIGN(fb->width, alignment_w);\n\tkfb->aligned_h = ALIGN(fb->height, alignment_h);\n\n\tif (fb->offsets[0] % alignment_header) {\n\t\tDRM_DEBUG_KMS(\"afbc offset alignment check failed.\\n\");\n\t\tgoto check_failed;\n\t}\n\n\tn_blocks = (kfb->aligned_w * kfb->aligned_h) / AFBC_SUPERBLK_PIXELS;\n\tkfb->offset_payload = ALIGN(n_blocks * AFBC_HEADER_SIZE,\n\t\t\t\t    alignment_header);\n\n\tbpp = komeda_get_afbc_format_bpp(info, fb->modifier);\n\tkfb->afbc_size = kfb->offset_payload + n_blocks *\n\t\t\t ALIGN(bpp * AFBC_SUPERBLK_PIXELS / 8,\n\t\t\t       AFBC_SUPERBLK_ALIGNMENT);\n\tmin_size = kfb->afbc_size + fb->offsets[0];\n\tif (min_size > obj->size) {\n\t\tDRM_DEBUG_KMS(\"afbc size check failed, obj_size: 0x%zx. min_size 0x%llx.\\n\",\n\t\t\t      obj->size, min_size);\n\t\tgoto check_failed;\n\t}\n\n\tfb->obj[0] = obj;\n\treturn 0;\n\ncheck_failed:\n\tdrm_gem_object_put(obj);\n\treturn -EINVAL;\n}\n\nstatic int\nkomeda_fb_none_afbc_size_check(struct komeda_dev *mdev, struct komeda_fb *kfb,\n\t\t\t       struct drm_file *file,\n\t\t\t       const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct drm_framebuffer *fb = &kfb->base;\n\tconst struct drm_format_info *info = fb->format;\n\tstruct drm_gem_object *obj;\n\tu32 i, block_h;\n\tu64 min_size;\n\n\tif (komeda_fb_check_src_coords(kfb, 0, 0, fb->width, fb->height))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < info->num_planes; i++) {\n\t\tobj = drm_gem_object_lookup(file, mode_cmd->handles[i]);\n\t\tif (!obj) {\n\t\t\tDRM_DEBUG_KMS(\"Failed to lookup GEM object\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tfb->obj[i] = obj;\n\n\t\tblock_h = drm_format_info_block_height(info, i);\n\t\tif ((fb->pitches[i] * block_h) % mdev->chip.bus_width) {\n\t\t\tDRM_DEBUG_KMS(\"Pitch[%d]: 0x%x doesn't align to 0x%x\\n\",\n\t\t\t\t      i, fb->pitches[i], mdev->chip.bus_width);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmin_size = komeda_fb_get_pixel_addr(kfb, 0, fb->height, i)\n\t\t\t - to_drm_gem_dma_obj(obj)->dma_addr;\n\t\tif (obj->size < min_size) {\n\t\t\tDRM_DEBUG_KMS(\"The fb->obj[%d] size: 0x%zx lower than the minimum requirement: 0x%llx.\\n\",\n\t\t\t\t      i, obj->size, min_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (fb->format->num_planes == 3) {\n\t\tif (fb->pitches[1] != fb->pitches[2]) {\n\t\t\tDRM_DEBUG_KMS(\"The pitch[1] and [2] are not same\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstruct drm_framebuffer *\nkomeda_fb_create(struct drm_device *dev, struct drm_file *file,\n\t\t const struct drm_mode_fb_cmd2 *mode_cmd)\n{\n\tstruct komeda_dev *mdev = dev->dev_private;\n\tstruct komeda_fb *kfb;\n\tint ret = 0, i;\n\n\tkfb = kzalloc(sizeof(*kfb), GFP_KERNEL);\n\tif (!kfb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkfb->format_caps = komeda_get_format_caps(&mdev->fmt_tbl,\n\t\t\t\t\t\t  mode_cmd->pixel_format,\n\t\t\t\t\t\t  mode_cmd->modifier[0]);\n\tif (!kfb->format_caps) {\n\t\tDRM_DEBUG_KMS(\"FMT %x is not supported.\\n\",\n\t\t\t      mode_cmd->pixel_format);\n\t\tkfree(kfb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdrm_helper_mode_fill_fb_struct(dev, &kfb->base, mode_cmd);\n\n\tif (kfb->base.modifier)\n\t\tret = komeda_fb_afbc_size_check(kfb, file, mode_cmd);\n\telse\n\t\tret = komeda_fb_none_afbc_size_check(mdev, kfb, file, mode_cmd);\n\tif (ret < 0)\n\t\tgoto err_cleanup;\n\n\tret = drm_framebuffer_init(dev, &kfb->base, &komeda_fb_funcs);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"failed to initialize fb\\n\");\n\n\t\tgoto err_cleanup;\n\t}\n\n\tkfb->is_va = mdev->iommu ? true : false;\n\n\treturn &kfb->base;\n\nerr_cleanup:\n\tfor (i = 0; i < kfb->base.format->num_planes; i++)\n\t\tdrm_gem_object_put(kfb->base.obj[i]);\n\n\tkfree(kfb);\n\treturn ERR_PTR(ret);\n}\n\nint komeda_fb_check_src_coords(const struct komeda_fb *kfb,\n\t\t\t       u32 src_x, u32 src_y, u32 src_w, u32 src_h)\n{\n\tconst struct drm_framebuffer *fb = &kfb->base;\n\tconst struct drm_format_info *info = fb->format;\n\tu32 block_w = drm_format_info_block_width(fb->format, 0);\n\tu32 block_h = drm_format_info_block_height(fb->format, 0);\n\n\tif ((src_x + src_w > fb->width) || (src_y + src_h > fb->height)) {\n\t\tDRM_DEBUG_ATOMIC(\"Invalid source coordinate.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((src_x % info->hsub) || (src_w % info->hsub) ||\n\t    (src_y % info->vsub) || (src_h % info->vsub)) {\n\t\tDRM_DEBUG_ATOMIC(\"Wrong subsampling dimension x:%d, y:%d, w:%d, h:%d for format: %x.\\n\",\n\t\t\t\t src_x, src_y, src_w, src_h, info->format);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((src_x % block_w) || (src_w % block_w) ||\n\t    (src_y % block_h) || (src_h % block_h)) {\n\t\tDRM_DEBUG_ATOMIC(\"x:%d, y:%d, w:%d, h:%d should be multiple of block_w/h for format: %x.\\n\",\n\t\t\t\t src_x, src_y, src_w, src_h, info->format);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\ndma_addr_t\nkomeda_fb_get_pixel_addr(struct komeda_fb *kfb, int x, int y, int plane)\n{\n\tstruct drm_framebuffer *fb = &kfb->base;\n\tconst struct drm_gem_dma_object *obj;\n\tu32 offset, plane_x, plane_y, block_w, block_sz;\n\n\tif (plane >= fb->format->num_planes) {\n\t\tDRM_DEBUG_KMS(\"Out of max plane num.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tobj = drm_fb_dma_get_gem_obj(fb, plane);\n\n\toffset = fb->offsets[plane];\n\tif (!fb->modifier) {\n\t\tblock_w = drm_format_info_block_width(fb->format, plane);\n\t\tblock_sz = fb->format->char_per_block[plane];\n\t\tplane_x = x / (plane ? fb->format->hsub : 1);\n\t\tplane_y = y / (plane ? fb->format->vsub : 1);\n\n\t\toffset += (plane_x / block_w) * block_sz\n\t\t\t+ plane_y * fb->pitches[plane];\n\t}\n\n\treturn obj->dma_addr + offset;\n}\n\n \nbool komeda_fb_is_layer_supported(struct komeda_fb *kfb, u32 layer_type,\n\t\t\t\t  u32 rot)\n{\n\tstruct drm_framebuffer *fb = &kfb->base;\n\tstruct komeda_dev *mdev = fb->dev->dev_private;\n\tu32 fourcc = fb->format->format;\n\tu64 modifier = fb->modifier;\n\tbool supported;\n\n\tsupported = komeda_format_mod_supported(&mdev->fmt_tbl, layer_type,\n\t\t\t\t\t\tfourcc, modifier, rot);\n\tif (!supported)\n\t\tDRM_DEBUG_ATOMIC(\"Layer TYPE: %d doesn't support fb FMT: %p4cc with modifier: 0x%llx.\\n\",\n\t\t\t\t layer_type, &fourcc, modifier);\n\n\treturn supported;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}