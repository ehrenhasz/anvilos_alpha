{
  "module_name": "komeda_pipeline.c",
  "hash_id": "50c923251991eceb8a1ab5cc390b4870c3657e6a6343c0642a8e23da727f9237",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/arm/display/komeda/komeda_pipeline.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n\n#include <drm/drm_print.h>\n\n#include \"komeda_dev.h\"\n#include \"komeda_pipeline.h\"\n\n \nstruct komeda_pipeline *\nkomeda_pipeline_add(struct komeda_dev *mdev, size_t size,\n\t\t    const struct komeda_pipeline_funcs *funcs)\n{\n\tstruct komeda_pipeline *pipe;\n\n\tif (mdev->n_pipelines + 1 > KOMEDA_MAX_PIPELINES) {\n\t\tDRM_ERROR(\"Exceed max support %d pipelines.\\n\",\n\t\t\t  KOMEDA_MAX_PIPELINES);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tif (size < sizeof(*pipe)) {\n\t\tDRM_ERROR(\"Request pipeline size too small.\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpipe = devm_kzalloc(mdev->dev, size, GFP_KERNEL);\n\tif (!pipe)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpipe->mdev = mdev;\n\tpipe->id   = mdev->n_pipelines;\n\tpipe->funcs = funcs;\n\n\tmdev->pipelines[mdev->n_pipelines] = pipe;\n\tmdev->n_pipelines++;\n\n\treturn pipe;\n}\n\nvoid komeda_pipeline_destroy(struct komeda_dev *mdev,\n\t\t\t     struct komeda_pipeline *pipe)\n{\n\tstruct komeda_component *c;\n\tint i;\n\tunsigned long avail_comps = pipe->avail_comps;\n\n\tfor_each_set_bit(i, &avail_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, i);\n\t\tkomeda_component_destroy(mdev, c);\n\t}\n\n\tclk_put(pipe->pxlclk);\n\n\tof_node_put(pipe->of_output_links[0]);\n\tof_node_put(pipe->of_output_links[1]);\n\tof_node_put(pipe->of_output_port);\n\tof_node_put(pipe->of_node);\n\n\tdevm_kfree(mdev->dev, pipe);\n}\n\nstatic struct komeda_component **\nkomeda_pipeline_get_component_pos(struct komeda_pipeline *pipe, int id)\n{\n\tstruct komeda_dev *mdev = pipe->mdev;\n\tstruct komeda_pipeline *temp = NULL;\n\tstruct komeda_component **pos = NULL;\n\n\tswitch (id) {\n\tcase KOMEDA_COMPONENT_LAYER0:\n\tcase KOMEDA_COMPONENT_LAYER1:\n\tcase KOMEDA_COMPONENT_LAYER2:\n\tcase KOMEDA_COMPONENT_LAYER3:\n\t\tpos = to_cpos(pipe->layers[id - KOMEDA_COMPONENT_LAYER0]);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_WB_LAYER:\n\t\tpos = to_cpos(pipe->wb_layer);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_COMPIZ0:\n\tcase KOMEDA_COMPONENT_COMPIZ1:\n\t\ttemp = mdev->pipelines[id - KOMEDA_COMPONENT_COMPIZ0];\n\t\tif (!temp) {\n\t\t\tDRM_ERROR(\"compiz-%d doesn't exist.\\n\", id);\n\t\t\treturn NULL;\n\t\t}\n\t\tpos = to_cpos(temp->compiz);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_SCALER0:\n\tcase KOMEDA_COMPONENT_SCALER1:\n\t\tpos = to_cpos(pipe->scalers[id - KOMEDA_COMPONENT_SCALER0]);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_SPLITTER:\n\t\tpos = to_cpos(pipe->splitter);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_MERGER:\n\t\tpos = to_cpos(pipe->merger);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_IPS0:\n\tcase KOMEDA_COMPONENT_IPS1:\n\t\ttemp = mdev->pipelines[id - KOMEDA_COMPONENT_IPS0];\n\t\tif (!temp) {\n\t\t\tDRM_ERROR(\"ips-%d doesn't exist.\\n\", id);\n\t\t\treturn NULL;\n\t\t}\n\t\tpos = to_cpos(temp->improc);\n\t\tbreak;\n\tcase KOMEDA_COMPONENT_TIMING_CTRLR:\n\t\tpos = to_cpos(pipe->ctrlr);\n\t\tbreak;\n\tdefault:\n\t\tpos = NULL;\n\t\tDRM_ERROR(\"Unknown pipeline resource ID: %d.\\n\", id);\n\t\tbreak;\n\t}\n\n\treturn pos;\n}\n\nstruct komeda_component *\nkomeda_pipeline_get_component(struct komeda_pipeline *pipe, int id)\n{\n\tstruct komeda_component **pos = NULL;\n\tstruct komeda_component *c = NULL;\n\n\tpos = komeda_pipeline_get_component_pos(pipe, id);\n\tif (pos)\n\t\tc = *pos;\n\n\treturn c;\n}\n\nstruct komeda_component *\nkomeda_pipeline_get_first_component(struct komeda_pipeline *pipe,\n\t\t\t\t    u32 comp_mask)\n{\n\tstruct komeda_component *c = NULL;\n\tunsigned long comp_mask_local = (unsigned long)comp_mask;\n\tint id;\n\n\tid = find_first_bit(&comp_mask_local, 32);\n\tif (id < 32)\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\n\treturn c;\n}\n\nstatic struct komeda_component *\nkomeda_component_pickup_input(struct komeda_component *c, u32 avail_comps)\n{\n\tu32 avail_inputs = c->supported_inputs & (avail_comps);\n\n\treturn komeda_pipeline_get_first_component(c->pipeline, avail_inputs);\n}\n\n \nstruct komeda_component *\nkomeda_component_add(struct komeda_pipeline *pipe,\n\t\t     size_t comp_sz, u32 id, u32 hw_id,\n\t\t     const struct komeda_component_funcs *funcs,\n\t\t     u8 max_active_inputs, u32 supported_inputs,\n\t\t     u8 max_active_outputs, u32 __iomem *reg,\n\t\t     const char *name_fmt, ...)\n{\n\tstruct komeda_component **pos;\n\tstruct komeda_component *c;\n\tint idx, *num = NULL;\n\n\tif (max_active_inputs > KOMEDA_COMPONENT_N_INPUTS) {\n\t\tWARN(1, \"please large KOMEDA_COMPONENT_N_INPUTS to %d.\\n\",\n\t\t     max_active_inputs);\n\t\treturn ERR_PTR(-ENOSPC);\n\t}\n\n\tpos = komeda_pipeline_get_component_pos(pipe, id);\n\tif (!pos || (*pos))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (has_bit(id, KOMEDA_PIPELINE_LAYERS)) {\n\t\tidx = id - KOMEDA_COMPONENT_LAYER0;\n\t\tnum = &pipe->n_layers;\n\t\tif (idx != pipe->n_layers) {\n\t\t\tDRM_ERROR(\"please add Layer by id sequence.\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t} else if (has_bit(id,  KOMEDA_PIPELINE_SCALERS)) {\n\t\tidx = id - KOMEDA_COMPONENT_SCALER0;\n\t\tnum = &pipe->n_scalers;\n\t\tif (idx != pipe->n_scalers) {\n\t\t\tDRM_ERROR(\"please add Scaler by id sequence.\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\tc = devm_kzalloc(pipe->mdev->dev, comp_sz, GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tc->id = id;\n\tc->hw_id = hw_id;\n\tc->reg = reg;\n\tc->pipeline = pipe;\n\tc->max_active_inputs = max_active_inputs;\n\tc->max_active_outputs = max_active_outputs;\n\tc->supported_inputs = supported_inputs;\n\tc->funcs = funcs;\n\n\tif (name_fmt) {\n\t\tva_list args;\n\n\t\tva_start(args, name_fmt);\n\t\tvsnprintf(c->name, sizeof(c->name), name_fmt, args);\n\t\tva_end(args);\n\t}\n\n\tif (num)\n\t\t*num = *num + 1;\n\n\tpipe->avail_comps |= BIT(c->id);\n\t*pos = c;\n\n\treturn c;\n}\n\nvoid komeda_component_destroy(struct komeda_dev *mdev,\n\t\t\t      struct komeda_component *c)\n{\n\tdevm_kfree(mdev->dev, c);\n}\n\nstatic void komeda_component_dump(struct komeda_component *c)\n{\n\tif (!c)\n\t\treturn;\n\n\tDRM_DEBUG(\"\t%s: ID %d-0x%08lx.\\n\",\n\t\t  c->name, c->id, BIT(c->id));\n\tDRM_DEBUG(\"\t\tmax_active_inputs:%d, supported_inputs: 0x%08x.\\n\",\n\t\t  c->max_active_inputs, c->supported_inputs);\n\tDRM_DEBUG(\"\t\tmax_active_outputs:%d, supported_outputs: 0x%08x.\\n\",\n\t\t  c->max_active_outputs, c->supported_outputs);\n}\n\nstatic void komeda_pipeline_dump(struct komeda_pipeline *pipe)\n{\n\tstruct komeda_component *c;\n\tint id;\n\tunsigned long avail_comps = pipe->avail_comps;\n\n\tDRM_INFO(\"Pipeline-%d: n_layers: %d, n_scalers: %d, output: %s.\\n\",\n\t\t pipe->id, pipe->n_layers, pipe->n_scalers,\n\t\t pipe->dual_link ? \"dual-link\" : \"single-link\");\n\tDRM_INFO(\"\toutput_link[0]: %s.\\n\",\n\t\t pipe->of_output_links[0] ?\n\t\t pipe->of_output_links[0]->full_name : \"none\");\n\tDRM_INFO(\"\toutput_link[1]: %s.\\n\",\n\t\t pipe->of_output_links[1] ?\n\t\t pipe->of_output_links[1]->full_name : \"none\");\n\n\tfor_each_set_bit(id, &avail_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\n\t\tkomeda_component_dump(c);\n\t}\n}\n\nstatic void komeda_component_verify_inputs(struct komeda_component *c)\n{\n\tstruct komeda_pipeline *pipe = c->pipeline;\n\tstruct komeda_component *input;\n\tint id;\n\tunsigned long supported_inputs = c->supported_inputs;\n\n\tfor_each_set_bit(id, &supported_inputs, 32) {\n\t\tinput = komeda_pipeline_get_component(pipe, id);\n\t\tif (!input) {\n\t\t\tc->supported_inputs &= ~(BIT(id));\n\t\t\tDRM_WARN(\"Can not find input(ID-%d) for component: %s.\\n\",\n\t\t\t\t id, c->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinput->supported_outputs |= BIT(c->id);\n\t}\n}\n\nstatic struct komeda_layer *\nkomeda_get_layer_split_right_layer(struct komeda_pipeline *pipe,\n\t\t\t\t   struct komeda_layer *left)\n{\n\tint index = left->base.id - KOMEDA_COMPONENT_LAYER0;\n\tint i;\n\n\tfor (i = index + 1; i < pipe->n_layers; i++)\n\t\tif (left->layer_type == pipe->layers[i]->layer_type)\n\t\t\treturn pipe->layers[i];\n\treturn NULL;\n}\n\nstatic void komeda_pipeline_assemble(struct komeda_pipeline *pipe)\n{\n\tstruct komeda_component *c;\n\tstruct komeda_layer *layer;\n\tint i, id;\n\tunsigned long avail_comps = pipe->avail_comps;\n\n\tfor_each_set_bit(id, &avail_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\t\tkomeda_component_verify_inputs(c);\n\t}\n\t \n\tfor (i = 0; i < pipe->n_layers; i++) {\n\t\tlayer = pipe->layers[i];\n\n\t\tlayer->right = komeda_get_layer_split_right_layer(pipe, layer);\n\t}\n\n\tif (pipe->dual_link && !pipe->ctrlr->supports_dual_link) {\n\t\tpipe->dual_link = false;\n\t\tDRM_WARN(\"PIPE-%d doesn't support dual-link, ignore DT dual-link configuration.\\n\",\n\t\t\t pipe->id);\n\t}\n}\n\n \nstruct komeda_pipeline *\nkomeda_pipeline_get_slave(struct komeda_pipeline *master)\n{\n\tstruct komeda_component *slave;\n\n\tslave = komeda_component_pickup_input(&master->compiz->base,\n\t\t\t\t\t      KOMEDA_PIPELINE_COMPIZS);\n\n\treturn slave ? slave->pipeline : NULL;\n}\n\nint komeda_assemble_pipelines(struct komeda_dev *mdev)\n{\n\tstruct komeda_pipeline *pipe;\n\tint i;\n\n\tfor (i = 0; i < mdev->n_pipelines; i++) {\n\t\tpipe = mdev->pipelines[i];\n\n\t\tkomeda_pipeline_assemble(pipe);\n\t\tkomeda_pipeline_dump(pipe);\n\t}\n\n\treturn 0;\n}\n\nvoid komeda_pipeline_dump_register(struct komeda_pipeline *pipe,\n\t\t\t\t   struct seq_file *sf)\n{\n\tstruct komeda_component *c;\n\tu32 id;\n\tunsigned long avail_comps;\n\n\tseq_printf(sf, \"\\n======== Pipeline-%d ==========\\n\", pipe->id);\n\n\tif (pipe->funcs && pipe->funcs->dump_register)\n\t\tpipe->funcs->dump_register(pipe, sf);\n\n\tavail_comps = pipe->avail_comps;\n\tfor_each_set_bit(id, &avail_comps, 32) {\n\t\tc = komeda_pipeline_get_component(pipe, id);\n\n\t\tseq_printf(sf, \"\\n------%s------\\n\", c->name);\n\t\tif (c->funcs->dump_register)\n\t\t\tc->funcs->dump_register(c, sf);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}