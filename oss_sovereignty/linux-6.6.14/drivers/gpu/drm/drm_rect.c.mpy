{
  "module_name": "drm_rect.c",
  "hash_id": "4fae639ddf66d09db834c14e61e336921d756e96606b7c26179726c2ed3bce0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_rect.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#include <drm/drm_mode.h>\n#include <drm/drm_print.h>\n#include <drm/drm_rect.h>\n\n \nbool drm_rect_intersect(struct drm_rect *r1, const struct drm_rect *r2)\n{\n\tr1->x1 = max(r1->x1, r2->x1);\n\tr1->y1 = max(r1->y1, r2->y1);\n\tr1->x2 = min(r1->x2, r2->x2);\n\tr1->y2 = min(r1->y2, r2->y2);\n\n\treturn drm_rect_visible(r1);\n}\nEXPORT_SYMBOL(drm_rect_intersect);\n\nstatic u32 clip_scaled(int src, int dst, int *clip)\n{\n\tu64 tmp;\n\n\tif (dst == 0)\n\t\treturn 0;\n\n\t \n\t*clip = min(*clip, dst);\n\n\ttmp = mul_u32_u32(src, dst - *clip);\n\n\t \n\tif (src < (dst << 16))\n\t\treturn DIV_ROUND_UP_ULL(tmp, dst);\n\telse\n\t\treturn DIV_ROUND_DOWN_ULL(tmp, dst);\n}\n\n \nbool drm_rect_clip_scaled(struct drm_rect *src, struct drm_rect *dst,\n\t\t\t  const struct drm_rect *clip)\n{\n\tint diff;\n\n\tdiff = clip->x1 - dst->x1;\n\tif (diff > 0) {\n\t\tu32 new_src_w = clip_scaled(drm_rect_width(src),\n\t\t\t\t\t    drm_rect_width(dst), &diff);\n\n\t\tsrc->x1 = src->x2 - new_src_w;\n\t\tdst->x1 += diff;\n\t}\n\tdiff = clip->y1 - dst->y1;\n\tif (diff > 0) {\n\t\tu32 new_src_h = clip_scaled(drm_rect_height(src),\n\t\t\t\t\t    drm_rect_height(dst), &diff);\n\n\t\tsrc->y1 = src->y2 - new_src_h;\n\t\tdst->y1 += diff;\n\t}\n\tdiff = dst->x2 - clip->x2;\n\tif (diff > 0) {\n\t\tu32 new_src_w = clip_scaled(drm_rect_width(src),\n\t\t\t\t\t    drm_rect_width(dst), &diff);\n\n\t\tsrc->x2 = src->x1 + new_src_w;\n\t\tdst->x2 -= diff;\n\t}\n\tdiff = dst->y2 - clip->y2;\n\tif (diff > 0) {\n\t\tu32 new_src_h = clip_scaled(drm_rect_height(src),\n\t\t\t\t\t    drm_rect_height(dst), &diff);\n\n\t\tsrc->y2 = src->y1 + new_src_h;\n\t\tdst->y2 -= diff;\n\t}\n\n\treturn drm_rect_visible(dst);\n}\nEXPORT_SYMBOL(drm_rect_clip_scaled);\n\nstatic int drm_calc_scale(int src, int dst)\n{\n\tint scale = 0;\n\n\tif (WARN_ON(src < 0 || dst < 0))\n\t\treturn -EINVAL;\n\n\tif (dst == 0)\n\t\treturn 0;\n\n\tif (src > (dst << 16))\n\t\treturn DIV_ROUND_UP(src, dst);\n\telse\n\t\tscale = src / dst;\n\n\treturn scale;\n}\n\n \nint drm_rect_calc_hscale(const struct drm_rect *src,\n\t\t\t const struct drm_rect *dst,\n\t\t\t int min_hscale, int max_hscale)\n{\n\tint src_w = drm_rect_width(src);\n\tint dst_w = drm_rect_width(dst);\n\tint hscale = drm_calc_scale(src_w, dst_w);\n\n\tif (hscale < 0 || dst_w == 0)\n\t\treturn hscale;\n\n\tif (hscale < min_hscale || hscale > max_hscale)\n\t\treturn -ERANGE;\n\n\treturn hscale;\n}\nEXPORT_SYMBOL(drm_rect_calc_hscale);\n\n \nint drm_rect_calc_vscale(const struct drm_rect *src,\n\t\t\t const struct drm_rect *dst,\n\t\t\t int min_vscale, int max_vscale)\n{\n\tint src_h = drm_rect_height(src);\n\tint dst_h = drm_rect_height(dst);\n\tint vscale = drm_calc_scale(src_h, dst_h);\n\n\tif (vscale < 0 || dst_h == 0)\n\t\treturn vscale;\n\n\tif (vscale < min_vscale || vscale > max_vscale)\n\t\treturn -ERANGE;\n\n\treturn vscale;\n}\nEXPORT_SYMBOL(drm_rect_calc_vscale);\n\n \nvoid drm_rect_debug_print(const char *prefix, const struct drm_rect *r, bool fixed_point)\n{\n\tif (fixed_point)\n\t\tDRM_DEBUG_KMS(\"%s\" DRM_RECT_FP_FMT \"\\n\", prefix, DRM_RECT_FP_ARG(r));\n\telse\n\t\tDRM_DEBUG_KMS(\"%s\" DRM_RECT_FMT \"\\n\", prefix, DRM_RECT_ARG(r));\n}\nEXPORT_SYMBOL(drm_rect_debug_print);\n\n \nvoid drm_rect_rotate(struct drm_rect *r,\n\t\t     int width, int height,\n\t\t     unsigned int rotation)\n{\n\tstruct drm_rect tmp;\n\n\tif (rotation & (DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y)) {\n\t\ttmp = *r;\n\n\t\tif (rotation & DRM_MODE_REFLECT_X) {\n\t\t\tr->x1 = width - tmp.x2;\n\t\t\tr->x2 = width - tmp.x1;\n\t\t}\n\n\t\tif (rotation & DRM_MODE_REFLECT_Y) {\n\t\t\tr->y1 = height - tmp.y2;\n\t\t\tr->y2 = height - tmp.y1;\n\t\t}\n\t}\n\n\tswitch (rotation & DRM_MODE_ROTATE_MASK) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\ttmp = *r;\n\t\tr->x1 = tmp.y1;\n\t\tr->x2 = tmp.y2;\n\t\tr->y1 = width - tmp.x2;\n\t\tr->y2 = width - tmp.x1;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\ttmp = *r;\n\t\tr->x1 = width - tmp.x2;\n\t\tr->x2 = width - tmp.x1;\n\t\tr->y1 = height - tmp.y2;\n\t\tr->y2 = height - tmp.y1;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\ttmp = *r;\n\t\tr->x1 = height - tmp.y2;\n\t\tr->x2 = height - tmp.y1;\n\t\tr->y1 = tmp.x1;\n\t\tr->y2 = tmp.x2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(drm_rect_rotate);\n\n \nvoid drm_rect_rotate_inv(struct drm_rect *r,\n\t\t\t int width, int height,\n\t\t\t unsigned int rotation)\n{\n\tstruct drm_rect tmp;\n\n\tswitch (rotation & DRM_MODE_ROTATE_MASK) {\n\tcase DRM_MODE_ROTATE_0:\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_90:\n\t\ttmp = *r;\n\t\tr->x1 = width - tmp.y2;\n\t\tr->x2 = width - tmp.y1;\n\t\tr->y1 = tmp.x1;\n\t\tr->y2 = tmp.x2;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_180:\n\t\ttmp = *r;\n\t\tr->x1 = width - tmp.x2;\n\t\tr->x2 = width - tmp.x1;\n\t\tr->y1 = height - tmp.y2;\n\t\tr->y2 = height - tmp.y1;\n\t\tbreak;\n\tcase DRM_MODE_ROTATE_270:\n\t\ttmp = *r;\n\t\tr->x1 = tmp.y1;\n\t\tr->x2 = tmp.y2;\n\t\tr->y1 = height - tmp.x2;\n\t\tr->y2 = height - tmp.x1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rotation & (DRM_MODE_REFLECT_X | DRM_MODE_REFLECT_Y)) {\n\t\ttmp = *r;\n\n\t\tif (rotation & DRM_MODE_REFLECT_X) {\n\t\t\tr->x1 = width - tmp.x2;\n\t\t\tr->x2 = width - tmp.x1;\n\t\t}\n\n\t\tif (rotation & DRM_MODE_REFLECT_Y) {\n\t\t\tr->y1 = height - tmp.y2;\n\t\t\tr->y2 = height - tmp.y1;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_rect_rotate_inv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}