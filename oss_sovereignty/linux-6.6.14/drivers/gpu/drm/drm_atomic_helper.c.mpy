{
  "module_name": "drm_atomic_helper.c",
  "hash_id": "ce0a0b8b2b51725e92069d23154811848ff7f220babdd1b618160e335ba74e93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_atomic_helper.c",
  "human_readable_source": " \n\n#include <linux/dma-fence.h>\n#include <linux/ktime.h>\n\n#include <drm/drm_atomic.h>\n#include <drm/drm_atomic_helper.h>\n#include <drm/drm_atomic_uapi.h>\n#include <drm/drm_blend.h>\n#include <drm/drm_bridge.h>\n#include <drm/drm_damage_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_drv.h>\n#include <drm/drm_framebuffer.h>\n#include <drm/drm_gem_atomic_helper.h>\n#include <drm/drm_print.h>\n#include <drm/drm_self_refresh_helper.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_writeback.h>\n\n#include \"drm_crtc_helper_internal.h\"\n#include \"drm_crtc_internal.h\"\n\n \nstatic void\ndrm_atomic_helper_plane_changed(struct drm_atomic_state *state,\n\t\t\t\tstruct drm_plane_state *old_plane_state,\n\t\t\t\tstruct drm_plane_state *plane_state,\n\t\t\t\tstruct drm_plane *plane)\n{\n\tstruct drm_crtc_state *crtc_state;\n\n\tif (old_plane_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t   old_plane_state->crtc);\n\n\t\tif (WARN_ON(!crtc_state))\n\t\t\treturn;\n\n\t\tcrtc_state->planes_changed = true;\n\t}\n\n\tif (plane_state->crtc) {\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, plane_state->crtc);\n\n\t\tif (WARN_ON(!crtc_state))\n\t\t\treturn;\n\n\t\tcrtc_state->planes_changed = true;\n\t}\n}\n\nstatic int handle_conflicting_encoders(struct drm_atomic_state *state,\n\t\t\t\t       bool disable_conflicting_encoders)\n{\n\tstruct drm_connector_state *new_conn_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_encoder *encoder;\n\tunsigned int encoder_mask = 0;\n\tint i, ret = 0;\n\n\t \n\tfor_each_new_connector_in_state(state, connector, new_conn_state, i) {\n\t\tconst struct drm_connector_helper_funcs *funcs = connector->helper_private;\n\t\tstruct drm_encoder *new_encoder;\n\n\t\tif (!new_conn_state->crtc)\n\t\t\tcontinue;\n\n\t\tif (funcs->atomic_best_encoder)\n\t\t\tnew_encoder = funcs->atomic_best_encoder(connector,\n\t\t\t\t\t\t\t\t state);\n\t\telse if (funcs->best_encoder)\n\t\t\tnew_encoder = funcs->best_encoder(connector);\n\t\telse\n\t\t\tnew_encoder = drm_connector_get_single_encoder(connector);\n\n\t\tif (new_encoder) {\n\t\t\tif (encoder_mask & drm_encoder_mask(new_encoder)) {\n\t\t\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t\t\t       \"[ENCODER:%d:%s] on [CONNECTOR:%d:%s] already assigned\\n\",\n\t\t\t\t\t       new_encoder->base.id, new_encoder->name,\n\t\t\t\t\t       connector->base.id, connector->name);\n\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tencoder_mask |= drm_encoder_mask(new_encoder);\n\t\t}\n\t}\n\n\tif (!encoder_mask)\n\t\treturn 0;\n\n\t \n\tdrm_connector_list_iter_begin(state->dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tif (drm_atomic_get_new_connector_state(state, connector))\n\t\t\tcontinue;\n\n\t\tencoder = connector->state->best_encoder;\n\t\tif (!encoder || !(encoder_mask & drm_encoder_mask(encoder)))\n\t\t\tcontinue;\n\n\t\tif (!disable_conflicting_encoders) {\n\t\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t\t       \"[ENCODER:%d:%s] in use on [CRTC:%d:%s] by [CONNECTOR:%d:%s]\\n\",\n\t\t\t\t       encoder->base.id, encoder->name,\n\t\t\t\t       connector->state->crtc->base.id,\n\t\t\t\t       connector->state->crtc->name,\n\t\t\t\t       connector->base.id, connector->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnew_conn_state = drm_atomic_get_connector_state(state, connector);\n\t\tif (IS_ERR(new_conn_state)) {\n\t\t\tret = PTR_ERR(new_conn_state);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[ENCODER:%d:%s] in use on [CRTC:%d:%s], disabling [CONNECTOR:%d:%s]\\n\",\n\t\t\t       encoder->base.id, encoder->name,\n\t\t\t       new_conn_state->crtc->base.id, new_conn_state->crtc->name,\n\t\t\t       connector->base.id, connector->name);\n\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, new_conn_state->crtc);\n\n\t\tret = drm_atomic_set_crtc_for_connector(new_conn_state, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!crtc_state->connector_mask) {\n\t\t\tret = drm_atomic_set_mode_prop_for_crtc(crtc_state,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tcrtc_state->active = false;\n\t\t}\n\t}\nout:\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\treturn ret;\n}\n\nstatic void\nset_best_encoder(struct drm_atomic_state *state,\n\t\t struct drm_connector_state *conn_state,\n\t\t struct drm_encoder *encoder)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\n\tif (conn_state->best_encoder) {\n\t\t \n\t\tcrtc = conn_state->connector->state->crtc;\n\n\t\t \n\t\tWARN_ON(!crtc && encoder != conn_state->best_encoder);\n\t\tif (crtc) {\n\t\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\t\t\tcrtc_state->encoder_mask &=\n\t\t\t\t~drm_encoder_mask(conn_state->best_encoder);\n\t\t}\n\t}\n\n\tif (encoder) {\n\t\tcrtc = conn_state->crtc;\n\t\tWARN_ON(!crtc);\n\t\tif (crtc) {\n\t\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\t\t\tcrtc_state->encoder_mask |=\n\t\t\t\tdrm_encoder_mask(encoder);\n\t\t}\n\t}\n\n\tconn_state->best_encoder = encoder;\n}\n\nstatic void\nsteal_encoder(struct drm_atomic_state *state,\n\t      struct drm_encoder *encoder)\n{\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_connector_state, *new_connector_state;\n\tint i;\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i) {\n\t\tstruct drm_crtc *encoder_crtc;\n\n\t\tif (new_connector_state->best_encoder != encoder)\n\t\t\tcontinue;\n\n\t\tencoder_crtc = old_connector_state->crtc;\n\n\t\tdrm_dbg_atomic(encoder->dev,\n\t\t\t       \"[ENCODER:%d:%s] in use on [CRTC:%d:%s], stealing it\\n\",\n\t\t\t       encoder->base.id, encoder->name,\n\t\t\t       encoder_crtc->base.id, encoder_crtc->name);\n\n\t\tset_best_encoder(state, new_connector_state, NULL);\n\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, encoder_crtc);\n\t\tcrtc_state->connectors_changed = true;\n\n\t\treturn;\n\t}\n}\n\nstatic int\nupdate_connector_routing(struct drm_atomic_state *state,\n\t\t\t struct drm_connector *connector,\n\t\t\t struct drm_connector_state *old_connector_state,\n\t\t\t struct drm_connector_state *new_connector_state,\n\t\t\t bool added_by_user)\n{\n\tconst struct drm_connector_helper_funcs *funcs;\n\tstruct drm_encoder *new_encoder;\n\tstruct drm_crtc_state *crtc_state;\n\n\tdrm_dbg_atomic(connector->dev, \"Updating routing for [CONNECTOR:%d:%s]\\n\",\n\t\t       connector->base.id, connector->name);\n\n\tif (old_connector_state->crtc != new_connector_state->crtc) {\n\t\tif (old_connector_state->crtc) {\n\t\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, old_connector_state->crtc);\n\t\t\tcrtc_state->connectors_changed = true;\n\t\t}\n\n\t\tif (new_connector_state->crtc) {\n\t\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, new_connector_state->crtc);\n\t\t\tcrtc_state->connectors_changed = true;\n\t\t}\n\t}\n\n\tif (!new_connector_state->crtc) {\n\t\tdrm_dbg_atomic(connector->dev, \"Disabling [CONNECTOR:%d:%s]\\n\",\n\t\t\t\tconnector->base.id, connector->name);\n\n\t\tset_best_encoder(state, new_connector_state, NULL);\n\n\t\treturn 0;\n\t}\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t   new_connector_state->crtc);\n\t \n\tif (!state->duplicated && drm_connector_is_unregistered(connector) &&\n\t    added_by_user && crtc_state->active) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] is not registered\\n\",\n\t\t\t       connector->base.id, connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfuncs = connector->helper_private;\n\n\tif (funcs->atomic_best_encoder)\n\t\tnew_encoder = funcs->atomic_best_encoder(connector, state);\n\telse if (funcs->best_encoder)\n\t\tnew_encoder = funcs->best_encoder(connector);\n\telse\n\t\tnew_encoder = drm_connector_get_single_encoder(connector);\n\n\tif (!new_encoder) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"No suitable encoder found for [CONNECTOR:%d:%s]\\n\",\n\t\t\t       connector->base.id, connector->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!drm_encoder_crtc_ok(new_encoder, new_connector_state->crtc)) {\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[ENCODER:%d:%s] incompatible with [CRTC:%d:%s]\\n\",\n\t\t\t       new_encoder->base.id,\n\t\t\t       new_encoder->name,\n\t\t\t       new_connector_state->crtc->base.id,\n\t\t\t       new_connector_state->crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_encoder == new_connector_state->best_encoder) {\n\t\tset_best_encoder(state, new_connector_state, new_encoder);\n\n\t\tdrm_dbg_atomic(connector->dev,\n\t\t\t       \"[CONNECTOR:%d:%s] keeps [ENCODER:%d:%s], now on [CRTC:%d:%s]\\n\",\n\t\t\t       connector->base.id,\n\t\t\t       connector->name,\n\t\t\t       new_encoder->base.id,\n\t\t\t       new_encoder->name,\n\t\t\t       new_connector_state->crtc->base.id,\n\t\t\t       new_connector_state->crtc->name);\n\n\t\treturn 0;\n\t}\n\n\tsteal_encoder(state, new_encoder);\n\n\tset_best_encoder(state, new_connector_state, new_encoder);\n\n\tcrtc_state->connectors_changed = true;\n\n\tdrm_dbg_atomic(connector->dev,\n\t\t       \"[CONNECTOR:%d:%s] using [ENCODER:%d:%s] on [CRTC:%d:%s]\\n\",\n\t\t       connector->base.id,\n\t\t       connector->name,\n\t\t       new_encoder->base.id,\n\t\t       new_encoder->name,\n\t\t       new_connector_state->crtc->base.id,\n\t\t       new_connector_state->crtc->name);\n\n\treturn 0;\n}\n\nstatic int\nmode_fixup(struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\tint ret;\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (!new_crtc_state->mode_changed &&\n\t\t    !new_crtc_state->connectors_changed)\n\t\t\tcontinue;\n\n\t\tdrm_mode_copy(&new_crtc_state->adjusted_mode, &new_crtc_state->mode);\n\t}\n\n\tfor_each_new_connector_in_state(state, connector, new_conn_state, i) {\n\t\tconst struct drm_encoder_helper_funcs *funcs;\n\t\tstruct drm_encoder *encoder;\n\t\tstruct drm_bridge *bridge;\n\n\t\tWARN_ON(!!new_conn_state->best_encoder != !!new_conn_state->crtc);\n\n\t\tif (!new_conn_state->crtc || !new_conn_state->best_encoder)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state =\n\t\t\tdrm_atomic_get_new_crtc_state(state, new_conn_state->crtc);\n\n\t\t \n\t\tencoder = new_conn_state->best_encoder;\n\t\tfuncs = encoder->helper_private;\n\n\t\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\t\tret = drm_atomic_bridge_chain_check(bridge,\n\t\t\t\t\t\t    new_crtc_state,\n\t\t\t\t\t\t    new_conn_state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(encoder->dev, \"Bridge atomic check failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (funcs && funcs->atomic_check) {\n\t\t\tret = funcs->atomic_check(encoder, new_crtc_state,\n\t\t\t\t\t\t  new_conn_state);\n\t\t\tif (ret) {\n\t\t\t\tdrm_dbg_atomic(encoder->dev,\n\t\t\t\t\t       \"[ENCODER:%d:%s] check failed\\n\",\n\t\t\t\t\t       encoder->base.id, encoder->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (funcs && funcs->mode_fixup) {\n\t\t\tret = funcs->mode_fixup(encoder, &new_crtc_state->mode,\n\t\t\t\t\t\t&new_crtc_state->adjusted_mode);\n\t\t\tif (!ret) {\n\t\t\t\tdrm_dbg_atomic(encoder->dev,\n\t\t\t\t\t       \"[ENCODER:%d:%s] fixup failed\\n\",\n\t\t\t\t\t       encoder->base.id, encoder->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tif (!new_crtc_state->enable)\n\t\t\tcontinue;\n\n\t\tif (!new_crtc_state->mode_changed &&\n\t\t    !new_crtc_state->connectors_changed)\n\t\t\tcontinue;\n\n\t\tfuncs = crtc->helper_private;\n\t\tif (!funcs || !funcs->mode_fixup)\n\t\t\tcontinue;\n\n\t\tret = funcs->mode_fixup(crtc, &new_crtc_state->mode,\n\t\t\t\t\t&new_crtc_state->adjusted_mode);\n\t\tif (!ret) {\n\t\t\tdrm_dbg_atomic(crtc->dev, \"[CRTC:%d:%s] fixup failed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic enum drm_mode_status mode_valid_path(struct drm_connector *connector,\n\t\t\t\t\t    struct drm_encoder *encoder,\n\t\t\t\t\t    struct drm_crtc *crtc,\n\t\t\t\t\t    const struct drm_display_mode *mode)\n{\n\tstruct drm_bridge *bridge;\n\tenum drm_mode_status ret;\n\n\tret = drm_encoder_mode_valid(encoder, mode);\n\tif (ret != MODE_OK) {\n\t\tdrm_dbg_atomic(encoder->dev,\n\t\t\t       \"[ENCODER:%d:%s] mode_valid() failed\\n\",\n\t\t\t       encoder->base.id, encoder->name);\n\t\treturn ret;\n\t}\n\n\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\tret = drm_bridge_chain_mode_valid(bridge, &connector->display_info,\n\t\t\t\t\t  mode);\n\tif (ret != MODE_OK) {\n\t\tdrm_dbg_atomic(encoder->dev, \"[BRIDGE] mode_valid() failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drm_crtc_mode_valid(crtc, mode);\n\tif (ret != MODE_OK) {\n\t\tdrm_dbg_atomic(encoder->dev, \"[CRTC:%d:%s] mode_valid() failed\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmode_valid(struct drm_atomic_state *state)\n{\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *connector;\n\tint i;\n\n\tfor_each_new_connector_in_state(state, connector, conn_state, i) {\n\t\tstruct drm_encoder *encoder = conn_state->best_encoder;\n\t\tstruct drm_crtc *crtc = conn_state->crtc;\n\t\tstruct drm_crtc_state *crtc_state;\n\t\tenum drm_mode_status mode_status;\n\t\tconst struct drm_display_mode *mode;\n\n\t\tif (!crtc || !encoder)\n\t\t\tcontinue;\n\n\t\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\t\tif (!crtc_state)\n\t\t\tcontinue;\n\t\tif (!crtc_state->mode_changed && !crtc_state->connectors_changed)\n\t\t\tcontinue;\n\n\t\tmode = &crtc_state->mode;\n\n\t\tmode_status = mode_valid_path(connector, encoder, crtc, mode);\n\t\tif (mode_status != MODE_OK)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint\ndrm_atomic_helper_check_modeset(struct drm_device *dev,\n\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_connector_state, *new_connector_state;\n\tint i, ret;\n\tunsigned int connectors_mask = 0, user_connectors_mask = 0;\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i)\n\t\tuser_connectors_mask |= BIT(i);\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tbool has_connectors =\n\t\t\t!!new_crtc_state->connector_mask;\n\n\t\tWARN_ON(!drm_modeset_is_locked(&crtc->mutex));\n\n\t\tif (!drm_mode_equal(&old_crtc_state->mode, &new_crtc_state->mode)) {\n\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] mode changed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\tnew_crtc_state->mode_changed = true;\n\t\t}\n\n\t\tif (old_crtc_state->enable != new_crtc_state->enable) {\n\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] enable changed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\n\t\t\t \n\t\t\tnew_crtc_state->mode_changed = true;\n\t\t\tnew_crtc_state->connectors_changed = true;\n\t\t}\n\n\t\tif (old_crtc_state->active != new_crtc_state->active) {\n\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] active changed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\tnew_crtc_state->active_changed = true;\n\t\t}\n\n\t\tif (new_crtc_state->enable != has_connectors) {\n\t\t\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] enabled/connectors mismatch\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (drm_dev_has_vblank(dev))\n\t\t\tnew_crtc_state->no_vblank = false;\n\t\telse\n\t\t\tnew_crtc_state->no_vblank = true;\n\t}\n\n\tret = handle_conflicting_encoders(state, false);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i) {\n\t\tconst struct drm_connector_helper_funcs *funcs = connector->helper_private;\n\n\t\tWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\n\t\t \n\t\tret = update_connector_routing(state, connector,\n\t\t\t\t\t       old_connector_state,\n\t\t\t\t\t       new_connector_state,\n\t\t\t\t\t       BIT(i) & user_connectors_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (old_connector_state->crtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t       old_connector_state->crtc);\n\t\t\tif (old_connector_state->link_status !=\n\t\t\t    new_connector_state->link_status)\n\t\t\t\tnew_crtc_state->connectors_changed = true;\n\n\t\t\tif (old_connector_state->max_requested_bpc !=\n\t\t\t    new_connector_state->max_requested_bpc)\n\t\t\t\tnew_crtc_state->connectors_changed = true;\n\t\t}\n\n\t\tif (funcs->atomic_check)\n\t\t\tret = funcs->atomic_check(connector, state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"[CONNECTOR:%d:%s] driver check failed\\n\",\n\t\t\t\t       connector->base.id, connector->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tconnectors_mask |= BIT(i);\n\t}\n\n\t \n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[CRTC:%d:%s] needs all connectors, enable: %c, active: %c\\n\",\n\t\t\t       crtc->base.id, crtc->name,\n\t\t\t       new_crtc_state->enable ? 'y' : 'n',\n\t\t\t       new_crtc_state->active ? 'y' : 'n');\n\n\t\tret = drm_atomic_add_affected_connectors(state, crtc);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor_each_oldnew_connector_in_state(state, connector, old_connector_state, new_connector_state, i) {\n\t\tconst struct drm_connector_helper_funcs *funcs = connector->helper_private;\n\n\t\tif (connectors_mask & BIT(i))\n\t\t\tcontinue;\n\n\t\tif (funcs->atomic_check)\n\t\t\tret = funcs->atomic_check(connector, state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(dev,\n\t\t\t\t       \"[CONNECTOR:%d:%s] driver check failed\\n\",\n\t\t\t\t       connector->base.id, connector->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor_each_oldnew_connector_in_state(state, connector,\n\t\t\t\t\t   old_connector_state,\n\t\t\t\t\t   new_connector_state, i) {\n\t\tstruct drm_encoder *encoder;\n\n\t\tencoder = old_connector_state->best_encoder;\n\t\tret = drm_atomic_add_encoder_bridges(state, encoder);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tencoder = new_connector_state->best_encoder;\n\t\tret = drm_atomic_add_encoder_bridges(state, encoder);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = mode_valid(state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mode_fixup(state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_check_modeset);\n\n \nint\ndrm_atomic_helper_check_wb_encoder_state(struct drm_encoder *encoder,\n\t\t\t\t\t struct drm_connector_state *conn_state)\n{\n\tstruct drm_writeback_job *wb_job = conn_state->writeback_job;\n\tstruct drm_property_blob *pixel_format_blob;\n\tstruct drm_framebuffer *fb;\n\tsize_t i, nformats;\n\tu32 *formats;\n\n\tif (!wb_job || !wb_job->fb)\n\t\treturn 0;\n\n\tpixel_format_blob = wb_job->connector->pixel_formats_blob_ptr;\n\tnformats = pixel_format_blob->length / sizeof(u32);\n\tformats = pixel_format_blob->data;\n\tfb = wb_job->fb;\n\n\tfor (i = 0; i < nformats; i++)\n\t\tif (fb->format->format == formats[i])\n\t\t\treturn 0;\n\n\tdrm_dbg_kms(encoder->dev, \"Invalid pixel format %p4cc\\n\", &fb->format->format);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_atomic_helper_check_wb_encoder_state);\n\n \nint drm_atomic_helper_check_plane_state(struct drm_plane_state *plane_state,\n\t\t\t\t\tconst struct drm_crtc_state *crtc_state,\n\t\t\t\t\tint min_scale,\n\t\t\t\t\tint max_scale,\n\t\t\t\t\tbool can_position,\n\t\t\t\t\tbool can_update_disabled)\n{\n\tstruct drm_framebuffer *fb = plane_state->fb;\n\tstruct drm_rect *src = &plane_state->src;\n\tstruct drm_rect *dst = &plane_state->dst;\n\tunsigned int rotation = plane_state->rotation;\n\tstruct drm_rect clip = {};\n\tint hscale, vscale;\n\n\tWARN_ON(plane_state->crtc && plane_state->crtc != crtc_state->crtc);\n\n\t*src = drm_plane_state_src(plane_state);\n\t*dst = drm_plane_state_dest(plane_state);\n\n\tif (!fb) {\n\t\tplane_state->visible = false;\n\t\treturn 0;\n\t}\n\n\t \n\tif (WARN_ON(!plane_state->crtc)) {\n\t\tplane_state->visible = false;\n\t\treturn 0;\n\t}\n\n\tif (!crtc_state->enable && !can_update_disabled) {\n\t\tdrm_dbg_kms(plane_state->plane->dev,\n\t\t\t    \"Cannot update plane of a disabled CRTC.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrm_rect_rotate(src, fb->width << 16, fb->height << 16, rotation);\n\n\t \n\thscale = drm_rect_calc_hscale(src, dst, min_scale, max_scale);\n\tvscale = drm_rect_calc_vscale(src, dst, min_scale, max_scale);\n\tif (hscale < 0 || vscale < 0) {\n\t\tdrm_dbg_kms(plane_state->plane->dev,\n\t\t\t    \"Invalid scaling of plane\\n\");\n\t\tdrm_rect_debug_print(\"src: \", &plane_state->src, true);\n\t\tdrm_rect_debug_print(\"dst: \", &plane_state->dst, false);\n\t\treturn -ERANGE;\n\t}\n\n\tif (crtc_state->enable)\n\t\tdrm_mode_get_hv_timing(&crtc_state->mode, &clip.x2, &clip.y2);\n\n\tplane_state->visible = drm_rect_clip_scaled(src, dst, &clip);\n\n\tdrm_rect_rotate_inv(src, fb->width << 16, fb->height << 16, rotation);\n\n\tif (!plane_state->visible)\n\t\t \n\t\treturn 0;\n\n\tif (!can_position && !drm_rect_equals(dst, &clip)) {\n\t\tdrm_dbg_kms(plane_state->plane->dev,\n\t\t\t    \"Plane must cover entire CRTC\\n\");\n\t\tdrm_rect_debug_print(\"dst: \", dst, false);\n\t\tdrm_rect_debug_print(\"clip: \", &clip, false);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_helper_check_plane_state);\n\n \nint drm_atomic_helper_check_crtc_primary_plane(struct drm_crtc_state *crtc_state)\n{\n\tstruct drm_crtc *crtc = crtc_state->crtc;\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_plane *plane;\n\n\t \n\tdrm_for_each_plane_mask(plane, dev, crtc_state->plane_mask) {\n\t\tif (plane->type == DRM_PLANE_TYPE_PRIMARY)\n\t\t\treturn 0;\n\t}\n\n\tdrm_dbg_atomic(dev, \"[CRTC:%d:%s] primary plane missing\\n\", crtc->base.id, crtc->name);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(drm_atomic_helper_check_crtc_primary_plane);\n\n \nint\ndrm_atomic_helper_check_planes(struct drm_device *dev,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state, *old_plane_state;\n\tint i, ret = 0;\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs;\n\n\t\tWARN_ON(!drm_modeset_is_locked(&plane->mutex));\n\n\t\tfuncs = plane->helper_private;\n\n\t\tdrm_atomic_helper_plane_changed(state, old_plane_state, new_plane_state, plane);\n\n\t\tdrm_atomic_helper_check_plane_damage(state, new_plane_state);\n\n\t\tif (!funcs || !funcs->atomic_check)\n\t\t\tcontinue;\n\n\t\tret = funcs->atomic_check(plane, state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t\t       \"[PLANE:%d:%s] atomic driver check failed\\n\",\n\t\t\t\t       plane->base.id, plane->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (!funcs || !funcs->atomic_check)\n\t\t\tcontinue;\n\n\t\tret = funcs->atomic_check(crtc, state);\n\t\tif (ret) {\n\t\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t\t       \"[CRTC:%d:%s] atomic driver check failed\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_check_planes);\n\n \nint drm_atomic_helper_check(struct drm_device *dev,\n\t\t\t    struct drm_atomic_state *state)\n{\n\tint ret;\n\n\tret = drm_atomic_helper_check_modeset(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev->mode_config.normalize_zpos) {\n\t\tret = drm_atomic_normalize_zpos(dev, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = drm_atomic_helper_check_planes(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state->legacy_cursor_update)\n\t\tstate->async_update = !drm_atomic_helper_async_check(dev, state);\n\n\tdrm_self_refresh_helper_alter_state(state);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_check);\n\nstatic bool\ncrtc_needs_disable(struct drm_crtc_state *old_state,\n\t\t   struct drm_crtc_state *new_state)\n{\n\t \n\tif (!new_state)\n\t\treturn drm_atomic_crtc_effectively_active(old_state);\n\n\t \n\tif (old_state->self_refresh_active &&\n\t    old_state->crtc != new_state->crtc)\n\t\treturn true;\n\n\t \n\treturn old_state->active ||\n\t       (old_state->self_refresh_active && !new_state->active) ||\n\t       new_state->self_refresh_active;\n}\n\nstatic void\ndisable_outputs(struct drm_device *dev, struct drm_atomic_state *old_state)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tint i;\n\n\tfor_each_oldnew_connector_in_state(old_state, connector, old_conn_state, new_conn_state, i) {\n\t\tconst struct drm_encoder_helper_funcs *funcs;\n\t\tstruct drm_encoder *encoder;\n\t\tstruct drm_bridge *bridge;\n\n\t\t \n\t\tif (!old_conn_state->crtc)\n\t\t\tcontinue;\n\n\t\told_crtc_state = drm_atomic_get_old_crtc_state(old_state, old_conn_state->crtc);\n\n\t\tif (new_conn_state->crtc)\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(\n\t\t\t\t\t\told_state,\n\t\t\t\t\t\tnew_conn_state->crtc);\n\t\telse\n\t\t\tnew_crtc_state = NULL;\n\n\t\tif (!crtc_needs_disable(old_crtc_state, new_crtc_state) ||\n\t\t    !drm_atomic_crtc_needs_modeset(old_conn_state->crtc->state))\n\t\t\tcontinue;\n\n\t\tencoder = old_conn_state->best_encoder;\n\n\t\t \n\t\tif (WARN_ON(!encoder))\n\t\t\tcontinue;\n\n\t\tfuncs = encoder->helper_private;\n\n\t\tdrm_dbg_atomic(dev, \"disabling [ENCODER:%d:%s]\\n\",\n\t\t\t       encoder->base.id, encoder->name);\n\n\t\t \n\t\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\t\tdrm_atomic_bridge_chain_disable(bridge, old_state);\n\n\t\t \n\t\tif (funcs) {\n\t\t\tif (funcs->atomic_disable)\n\t\t\t\tfuncs->atomic_disable(encoder, old_state);\n\t\t\telse if (new_conn_state->crtc && funcs->prepare)\n\t\t\t\tfuncs->prepare(encoder);\n\t\t\telse if (funcs->disable)\n\t\t\t\tfuncs->disable(encoder);\n\t\t\telse if (funcs->dpms)\n\t\t\t\tfuncs->dpms(encoder, DRM_MODE_DPMS_OFF);\n\t\t}\n\n\t\tdrm_atomic_bridge_chain_post_disable(bridge, old_state);\n\t}\n\n\tfor_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\t\tint ret;\n\n\t\t \n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (!crtc_needs_disable(old_crtc_state, new_crtc_state))\n\t\t\tcontinue;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tdrm_dbg_atomic(dev, \"disabling [CRTC:%d:%s]\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\n\n\t\t \n\t\tif (new_crtc_state->enable && funcs->prepare)\n\t\t\tfuncs->prepare(crtc);\n\t\telse if (funcs->atomic_disable)\n\t\t\tfuncs->atomic_disable(crtc, old_state);\n\t\telse if (funcs->disable)\n\t\t\tfuncs->disable(crtc);\n\t\telse if (funcs->dpms)\n\t\t\tfuncs->dpms(crtc, DRM_MODE_DPMS_OFF);\n\n\t\tif (!drm_dev_has_vblank(dev))\n\t\t\tcontinue;\n\n\t\tret = drm_crtc_vblank_get(crtc);\n\t\t \n\t\tif (new_crtc_state->self_refresh_active)\n\t\t\tWARN_ONCE(ret != 0,\n\t\t\t\t  \"driver disabled vblank in self-refresh\\n\");\n\t\telse\n\t\t\tWARN_ONCE(ret != -EINVAL,\n\t\t\t\t  \"driver forgot to call drm_crtc_vblank_off()\\n\");\n\t\tif (ret == 0)\n\t\t\tdrm_crtc_vblank_put(crtc);\n\t}\n}\n\n \nvoid\ndrm_atomic_helper_update_legacy_modeset_state(struct drm_device *dev,\n\t\t\t\t\t      struct drm_atomic_state *old_state)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tint i;\n\n\t \n\tfor_each_oldnew_connector_in_state(old_state, connector, old_conn_state, new_conn_state, i) {\n\t\tif (connector->encoder) {\n\t\t\tWARN_ON(!connector->encoder->crtc);\n\n\t\t\tconnector->encoder->crtc = NULL;\n\t\t\tconnector->encoder = NULL;\n\t\t}\n\n\t\tcrtc = new_conn_state->crtc;\n\t\tif ((!crtc && old_conn_state->crtc) ||\n\t\t    (crtc && drm_atomic_crtc_needs_modeset(crtc->state))) {\n\t\t\tint mode = DRM_MODE_DPMS_OFF;\n\n\t\t\tif (crtc && crtc->state->active)\n\t\t\t\tmode = DRM_MODE_DPMS_ON;\n\n\t\t\tconnector->dpms = mode;\n\t\t}\n\t}\n\n\t \n\tfor_each_new_connector_in_state(old_state, connector, new_conn_state, i) {\n\t\tif (!new_conn_state->crtc)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!new_conn_state->best_encoder))\n\t\t\tcontinue;\n\n\t\tconnector->encoder = new_conn_state->best_encoder;\n\t\tconnector->encoder->crtc = new_conn_state->crtc;\n\t}\n\n\t \n\tfor_each_new_crtc_in_state(old_state, crtc, new_crtc_state, i) {\n\t\tstruct drm_plane *primary = crtc->primary;\n\t\tstruct drm_plane_state *new_plane_state;\n\n\t\tcrtc->mode = new_crtc_state->mode;\n\t\tcrtc->enabled = new_crtc_state->enable;\n\n\t\tnew_plane_state =\n\t\t\tdrm_atomic_get_new_plane_state(old_state, primary);\n\n\t\tif (new_plane_state && new_plane_state->crtc == crtc) {\n\t\t\tcrtc->x = new_plane_state->src_x >> 16;\n\t\t\tcrtc->y = new_plane_state->src_y >> 16;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_update_legacy_modeset_state);\n\n \nvoid drm_atomic_helper_calc_timestamping_constants(struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tif (new_crtc_state->enable)\n\t\t\tdrm_calc_timestamping_constants(crtc,\n\t\t\t\t\t\t\t&new_crtc_state->adjusted_mode);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_calc_timestamping_constants);\n\nstatic void\ncrtc_set_mode(struct drm_device *dev, struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\n\tfor_each_new_crtc_in_state(old_state, crtc, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tif (!new_crtc_state->mode_changed)\n\t\t\tcontinue;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (new_crtc_state->enable && funcs->mode_set_nofb) {\n\t\t\tdrm_dbg_atomic(dev, \"modeset on [CRTC:%d:%s]\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\n\t\t\tfuncs->mode_set_nofb(crtc);\n\t\t}\n\t}\n\n\tfor_each_new_connector_in_state(old_state, connector, new_conn_state, i) {\n\t\tconst struct drm_encoder_helper_funcs *funcs;\n\t\tstruct drm_encoder *encoder;\n\t\tstruct drm_display_mode *mode, *adjusted_mode;\n\t\tstruct drm_bridge *bridge;\n\n\t\tif (!new_conn_state->best_encoder)\n\t\t\tcontinue;\n\n\t\tencoder = new_conn_state->best_encoder;\n\t\tfuncs = encoder->helper_private;\n\t\tnew_crtc_state = new_conn_state->crtc->state;\n\t\tmode = &new_crtc_state->mode;\n\t\tadjusted_mode = &new_crtc_state->adjusted_mode;\n\n\t\tif (!new_crtc_state->mode_changed)\n\t\t\tcontinue;\n\n\t\tdrm_dbg_atomic(dev, \"modeset on [ENCODER:%d:%s]\\n\",\n\t\t\t       encoder->base.id, encoder->name);\n\n\t\t \n\t\tif (funcs && funcs->atomic_mode_set) {\n\t\t\tfuncs->atomic_mode_set(encoder, new_crtc_state,\n\t\t\t\t\t       new_conn_state);\n\t\t} else if (funcs && funcs->mode_set) {\n\t\t\tfuncs->mode_set(encoder, mode, adjusted_mode);\n\t\t}\n\n\t\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\t\tdrm_bridge_chain_mode_set(bridge, mode, adjusted_mode);\n\t}\n}\n\n \nvoid drm_atomic_helper_commit_modeset_disables(struct drm_device *dev,\n\t\t\t\t\t       struct drm_atomic_state *old_state)\n{\n\tdisable_outputs(dev, old_state);\n\n\tdrm_atomic_helper_update_legacy_modeset_state(dev, old_state);\n\tdrm_atomic_helper_calc_timestamping_constants(old_state);\n\n\tcrtc_set_mode(dev, old_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_modeset_disables);\n\nstatic void drm_atomic_helper_commit_writebacks(struct drm_device *dev,\n\t\t\t\t\t\tstruct drm_atomic_state *old_state)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\n\tfor_each_new_connector_in_state(old_state, connector, new_conn_state, i) {\n\t\tconst struct drm_connector_helper_funcs *funcs;\n\n\t\tfuncs = connector->helper_private;\n\t\tif (!funcs->atomic_commit)\n\t\t\tcontinue;\n\n\t\tif (new_conn_state->writeback_job && new_conn_state->writeback_job->fb) {\n\t\t\tWARN_ON(connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK);\n\t\t\tfuncs->atomic_commit(connector, old_state);\n\t\t}\n\t}\n}\n\n \nvoid drm_atomic_helper_commit_modeset_enables(struct drm_device *dev,\n\t\t\t\t\t      struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tint i;\n\n\tfor_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\t \n\t\tif (!drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (!new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (new_crtc_state->enable) {\n\t\t\tdrm_dbg_atomic(dev, \"enabling [CRTC:%d:%s]\\n\",\n\t\t\t\t       crtc->base.id, crtc->name);\n\t\t\tif (funcs->atomic_enable)\n\t\t\t\tfuncs->atomic_enable(crtc, old_state);\n\t\t\telse if (funcs->commit)\n\t\t\t\tfuncs->commit(crtc);\n\t\t}\n\t}\n\n\tfor_each_new_connector_in_state(old_state, connector, new_conn_state, i) {\n\t\tconst struct drm_encoder_helper_funcs *funcs;\n\t\tstruct drm_encoder *encoder;\n\t\tstruct drm_bridge *bridge;\n\n\t\tif (!new_conn_state->best_encoder)\n\t\t\tcontinue;\n\n\t\tif (!new_conn_state->crtc->state->active ||\n\t\t    !drm_atomic_crtc_needs_modeset(new_conn_state->crtc->state))\n\t\t\tcontinue;\n\n\t\tencoder = new_conn_state->best_encoder;\n\t\tfuncs = encoder->helper_private;\n\n\t\tdrm_dbg_atomic(dev, \"enabling [ENCODER:%d:%s]\\n\",\n\t\t\t       encoder->base.id, encoder->name);\n\n\t\t \n\t\tbridge = drm_bridge_chain_get_first_bridge(encoder);\n\t\tdrm_atomic_bridge_chain_pre_enable(bridge, old_state);\n\n\t\tif (funcs) {\n\t\t\tif (funcs->atomic_enable)\n\t\t\t\tfuncs->atomic_enable(encoder, old_state);\n\t\t\telse if (funcs->enable)\n\t\t\t\tfuncs->enable(encoder);\n\t\t\telse if (funcs->commit)\n\t\t\t\tfuncs->commit(encoder);\n\t\t}\n\n\t\tdrm_atomic_bridge_chain_enable(bridge, old_state);\n\t}\n\n\tdrm_atomic_helper_commit_writebacks(dev, old_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_modeset_enables);\n\n \nstatic void set_fence_deadline(struct drm_device *dev,\n\t\t\t       struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tktime_t vbltime = 0;\n\tint i;\n\n\tfor_each_new_crtc_in_state (state, crtc, new_crtc_state, i) {\n\t\tktime_t v;\n\n\t\tif (drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tif (!new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tif (drm_crtc_next_vblank_start(crtc, &v))\n\t\t\tcontinue;\n\n\t\tif (!vbltime || ktime_before(v, vbltime))\n\t\t\tvbltime = v;\n\t}\n\n\t \n\tif (!vbltime)\n\t\treturn;\n\n\tfor_each_new_plane_in_state (state, plane, new_plane_state, i) {\n\t\tif (!new_plane_state->fence)\n\t\t\tcontinue;\n\t\tdma_fence_set_deadline(new_plane_state->fence, vbltime);\n\t}\n}\n\n \nint drm_atomic_helper_wait_for_fences(struct drm_device *dev,\n\t\t\t\t      struct drm_atomic_state *state,\n\t\t\t\t      bool pre_swap)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tint i, ret;\n\n\tset_fence_deadline(dev, state);\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tif (!new_plane_state->fence)\n\t\t\tcontinue;\n\n\t\tWARN_ON(!new_plane_state->fb);\n\n\t\t \n\t\tret = dma_fence_wait(new_plane_state->fence, pre_swap);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdma_fence_put(new_plane_state->fence);\n\t\tnew_plane_state->fence = NULL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_helper_wait_for_fences);\n\n \nvoid\ndrm_atomic_helper_wait_for_vblanks(struct drm_device *dev,\n\t\tstruct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tint i, ret;\n\tunsigned int crtc_mask = 0;\n\n\t  \n\tif (old_state->legacy_cursor_update)\n\t\treturn;\n\n\tfor_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tif (!new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tret = drm_crtc_vblank_get(crtc);\n\t\tif (ret != 0)\n\t\t\tcontinue;\n\n\t\tcrtc_mask |= drm_crtc_mask(crtc);\n\t\told_state->crtcs[i].last_vblank_count = drm_crtc_vblank_count(crtc);\n\t}\n\n\tfor_each_old_crtc_in_state(old_state, crtc, old_crtc_state, i) {\n\t\tif (!(crtc_mask & drm_crtc_mask(crtc)))\n\t\t\tcontinue;\n\n\t\tret = wait_event_timeout(dev->vblank[i].queue,\n\t\t\t\told_state->crtcs[i].last_vblank_count !=\n\t\t\t\t\tdrm_crtc_vblank_count(crtc),\n\t\t\t\tmsecs_to_jiffies(100));\n\n\t\tWARN(!ret, \"[CRTC:%d:%s] vblank wait timed out\\n\",\n\t\t     crtc->base.id, crtc->name);\n\n\t\tdrm_crtc_vblank_put(crtc);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_wait_for_vblanks);\n\n \nvoid drm_atomic_helper_wait_for_flip_done(struct drm_device *dev,\n\t\t\t\t\t  struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor (i = 0; i < dev->mode_config.num_crtc; i++) {\n\t\tstruct drm_crtc_commit *commit = old_state->crtcs[i].commit;\n\t\tint ret;\n\n\t\tcrtc = old_state->crtcs[i].ptr;\n\n\t\tif (!crtc || !commit)\n\t\t\tcontinue;\n\n\t\tret = wait_for_completion_timeout(&commit->flip_done, 10 * HZ);\n\t\tif (ret == 0)\n\t\t\tdrm_err(dev, \"[CRTC:%d:%s] flip_done timed out\\n\",\n\t\t\t\tcrtc->base.id, crtc->name);\n\t}\n\n\tif (old_state->fake_commit)\n\t\tcomplete_all(&old_state->fake_commit->flip_done);\n}\nEXPORT_SYMBOL(drm_atomic_helper_wait_for_flip_done);\n\n \nvoid drm_atomic_helper_commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\n\tdrm_atomic_helper_commit_modeset_disables(dev, old_state);\n\n\tdrm_atomic_helper_commit_planes(dev, old_state, 0);\n\n\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\n\tdrm_atomic_helper_fake_vblank(old_state);\n\n\tdrm_atomic_helper_commit_hw_done(old_state);\n\n\tdrm_atomic_helper_wait_for_vblanks(dev, old_state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, old_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_tail);\n\n \nvoid drm_atomic_helper_commit_tail_rpm(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\n\tdrm_atomic_helper_commit_modeset_disables(dev, old_state);\n\n\tdrm_atomic_helper_commit_modeset_enables(dev, old_state);\n\n\tdrm_atomic_helper_commit_planes(dev, old_state,\n\t\t\t\t\tDRM_PLANE_COMMIT_ACTIVE_ONLY);\n\n\tdrm_atomic_helper_fake_vblank(old_state);\n\n\tdrm_atomic_helper_commit_hw_done(old_state);\n\n\tdrm_atomic_helper_wait_for_vblanks(dev, old_state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, old_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_tail_rpm);\n\nstatic void commit_tail(struct drm_atomic_state *old_state)\n{\n\tstruct drm_device *dev = old_state->dev;\n\tconst struct drm_mode_config_helper_funcs *funcs;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tktime_t start;\n\ts64 commit_time_ms;\n\tunsigned int i, new_self_refresh_mask = 0;\n\n\tfuncs = dev->mode_config.helper_private;\n\n\t \n\tstart = ktime_get();\n\n\tdrm_atomic_helper_wait_for_fences(dev, old_state, false);\n\n\tdrm_atomic_helper_wait_for_dependencies(old_state);\n\n\t \n\tfor_each_new_crtc_in_state(old_state, crtc, new_crtc_state, i)\n\t\tif (new_crtc_state->self_refresh_active)\n\t\t\tnew_self_refresh_mask |= BIT(i);\n\n\tif (funcs && funcs->atomic_commit_tail)\n\t\tfuncs->atomic_commit_tail(old_state);\n\telse\n\t\tdrm_atomic_helper_commit_tail(old_state);\n\n\tcommit_time_ms = ktime_ms_delta(ktime_get(), start);\n\tif (commit_time_ms > 0)\n\t\tdrm_self_refresh_helper_update_avg_times(old_state,\n\t\t\t\t\t\t (unsigned long)commit_time_ms,\n\t\t\t\t\t\t new_self_refresh_mask);\n\n\tdrm_atomic_helper_commit_cleanup_done(old_state);\n\n\tdrm_atomic_state_put(old_state);\n}\n\nstatic void commit_work(struct work_struct *work)\n{\n\tstruct drm_atomic_state *state = container_of(work,\n\t\t\t\t\t\t      struct drm_atomic_state,\n\t\t\t\t\t\t      commit_work);\n\tcommit_tail(state);\n}\n\n \nint drm_atomic_helper_async_check(struct drm_device *dev,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane *plane = NULL;\n\tstruct drm_plane_state *old_plane_state = NULL;\n\tstruct drm_plane_state *new_plane_state = NULL;\n\tconst struct drm_plane_helper_funcs *funcs;\n\tint i, ret, n_planes = 0;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i)\n\t\tn_planes++;\n\n\t \n\tif (n_planes != 1) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"only single plane async updates are supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!new_plane_state->crtc ||\n\t    old_plane_state->crtc != new_plane_state->crtc) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] async update cannot change CRTC\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfuncs = plane->helper_private;\n\tif (!funcs->atomic_async_update) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] driver does not support async updates\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_plane_state->fence) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] missing fence for async update\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (old_plane_state->commit &&\n\t    !try_wait_for_completion(&old_plane_state->commit->hw_done)) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] inflight previous commit preventing async commit\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EBUSY;\n\t}\n\n\tret = funcs->atomic_async_check(plane, state);\n\tif (ret != 0)\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] driver async check failed\\n\",\n\t\t\t       plane->base.id, plane->name);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_async_check);\n\n \nvoid drm_atomic_helper_async_commit(struct drm_device *dev,\n\t\t\t\t    struct drm_atomic_state *state)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tconst struct drm_plane_helper_funcs *funcs;\n\tint i;\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tstruct drm_framebuffer *new_fb = plane_state->fb;\n\t\tstruct drm_framebuffer *old_fb = plane->state->fb;\n\n\t\tfuncs = plane->helper_private;\n\t\tfuncs->atomic_async_update(plane, state);\n\n\t\t \n\t\tWARN_ON_ONCE(plane->state->fb != new_fb);\n\t\tWARN_ON_ONCE(plane->state->crtc_x != plane_state->crtc_x);\n\t\tWARN_ON_ONCE(plane->state->crtc_y != plane_state->crtc_y);\n\t\tWARN_ON_ONCE(plane->state->src_x != plane_state->src_x);\n\t\tWARN_ON_ONCE(plane->state->src_y != plane_state->src_y);\n\n\t\t \n\t\tWARN_ON_ONCE(plane_state->fb != old_fb);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_async_commit);\n\n \nint drm_atomic_helper_commit(struct drm_device *dev,\n\t\t\t     struct drm_atomic_state *state,\n\t\t\t     bool nonblock)\n{\n\tint ret;\n\n\tif (state->async_update) {\n\t\tret = drm_atomic_helper_prepare_planes(dev, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdrm_atomic_helper_async_commit(dev, state);\n\t\tdrm_atomic_helper_unprepare_planes(dev, state);\n\n\t\treturn 0;\n\t}\n\n\tret = drm_atomic_helper_setup_commit(state, nonblock);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&state->commit_work, commit_work);\n\n\tret = drm_atomic_helper_prepare_planes(dev, state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!nonblock) {\n\t\tret = drm_atomic_helper_wait_for_fences(dev, state, true);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\n\tret = drm_atomic_helper_swap_state(state, true);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\n\tdrm_atomic_state_get(state);\n\tif (nonblock)\n\t\tqueue_work(system_unbound_wq, &state->commit_work);\n\telse\n\t\tcommit_tail(state);\n\n\treturn 0;\n\nerr:\n\tdrm_atomic_helper_unprepare_planes(dev, state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit);\n\n \n\nstatic int stall_checks(struct drm_crtc *crtc, bool nonblock)\n{\n\tstruct drm_crtc_commit *commit, *stall_commit = NULL;\n\tbool completed = true;\n\tint i;\n\tlong ret = 0;\n\n\tspin_lock(&crtc->commit_lock);\n\ti = 0;\n\tlist_for_each_entry(commit, &crtc->commit_list, commit_entry) {\n\t\tif (i == 0) {\n\t\t\tcompleted = try_wait_for_completion(&commit->flip_done);\n\t\t\t \n\t\t\tif (!completed && nonblock) {\n\t\t\t\tspin_unlock(&crtc->commit_lock);\n\t\t\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t\t\t       \"[CRTC:%d:%s] busy with a previous commit\\n\",\n\t\t\t\t\t       crtc->base.id, crtc->name);\n\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t} else if (i == 1) {\n\t\t\tstall_commit = drm_crtc_commit_get(commit);\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\tspin_unlock(&crtc->commit_lock);\n\n\tif (!stall_commit)\n\t\treturn 0;\n\n\t \n\tret = wait_for_completion_interruptible_timeout(&stall_commit->cleanup_done,\n\t\t\t\t\t\t\t10*HZ);\n\tif (ret == 0)\n\t\tdrm_err(crtc->dev, \"[CRTC:%d:%s] cleanup_done timed out\\n\",\n\t\t\tcrtc->base.id, crtc->name);\n\n\tdrm_crtc_commit_put(stall_commit);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void release_crtc_commit(struct completion *completion)\n{\n\tstruct drm_crtc_commit *commit = container_of(completion,\n\t\t\t\t\t\t      typeof(*commit),\n\t\t\t\t\t\t      flip_done);\n\n\tdrm_crtc_commit_put(commit);\n}\n\nstatic void init_commit(struct drm_crtc_commit *commit, struct drm_crtc *crtc)\n{\n\tinit_completion(&commit->flip_done);\n\tinit_completion(&commit->hw_done);\n\tinit_completion(&commit->cleanup_done);\n\tINIT_LIST_HEAD(&commit->commit_entry);\n\tkref_init(&commit->ref);\n\tcommit->crtc = crtc;\n}\n\nstatic struct drm_crtc_commit *\ncrtc_or_fake_commit(struct drm_atomic_state *state, struct drm_crtc *crtc)\n{\n\tif (crtc) {\n\t\tstruct drm_crtc_state *new_crtc_state;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\n\t\treturn new_crtc_state->commit;\n\t}\n\n\tif (!state->fake_commit) {\n\t\tstate->fake_commit = kzalloc(sizeof(*state->fake_commit), GFP_KERNEL);\n\t\tif (!state->fake_commit)\n\t\t\treturn NULL;\n\n\t\tinit_commit(state->fake_commit, NULL);\n\t}\n\n\treturn state->fake_commit;\n}\n\n \nint drm_atomic_helper_setup_commit(struct drm_atomic_state *state,\n\t\t\t\t   bool nonblock)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tstruct drm_crtc_commit *commit;\n\tconst struct drm_mode_config_helper_funcs *funcs;\n\tint i, ret;\n\n\tfuncs = state->dev->mode_config.helper_private;\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tcommit = kzalloc(sizeof(*commit), GFP_KERNEL);\n\t\tif (!commit)\n\t\t\treturn -ENOMEM;\n\n\t\tinit_commit(commit, crtc);\n\n\t\tnew_crtc_state->commit = commit;\n\n\t\tret = stall_checks(crtc, nonblock);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!old_crtc_state->active && !new_crtc_state->active) {\n\t\t\tcomplete_all(&commit->flip_done);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (state->legacy_cursor_update) {\n\t\t\tcomplete_all(&commit->flip_done);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!new_crtc_state->event) {\n\t\t\tcommit->event = kzalloc(sizeof(*commit->event),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!commit->event)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tnew_crtc_state->event = commit->event;\n\t\t}\n\n\t\tnew_crtc_state->event->base.completion = &commit->flip_done;\n\t\tnew_crtc_state->event->base.completion_release = release_crtc_commit;\n\t\tdrm_crtc_commit_get(commit);\n\n\t\tcommit->abort_completion = true;\n\n\t\tstate->crtcs[i].commit = commit;\n\t\tdrm_crtc_commit_get(commit);\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, conn, old_conn_state, new_conn_state, i) {\n\t\t \n\t\tif (nonblock && old_conn_state->commit &&\n\t\t    !try_wait_for_completion(&old_conn_state->commit->flip_done)) {\n\t\t\tdrm_dbg_atomic(conn->dev,\n\t\t\t\t       \"[CONNECTOR:%d:%s] busy with a previous commit\\n\",\n\t\t\t\t       conn->base.id, conn->name);\n\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tcommit = crtc_or_fake_commit(state, new_conn_state->crtc ?: old_conn_state->crtc);\n\t\tif (!commit)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_conn_state->commit = drm_crtc_commit_get(commit);\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\t \n\t\tif (nonblock && old_plane_state->commit &&\n\t\t    !try_wait_for_completion(&old_plane_state->commit->flip_done)) {\n\t\t\tdrm_dbg_atomic(plane->dev,\n\t\t\t\t       \"[PLANE:%d:%s] busy with a previous commit\\n\",\n\t\t\t\t       plane->base.id, plane->name);\n\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\t \n\t\tcommit = crtc_or_fake_commit(state, new_plane_state->crtc ?: old_plane_state->crtc);\n\t\tif (!commit)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_plane_state->commit = drm_crtc_commit_get(commit);\n\t}\n\n\tif (funcs && funcs->atomic_commit_setup)\n\t\treturn funcs->atomic_commit_setup(state);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_helper_setup_commit);\n\n \nvoid drm_atomic_helper_wait_for_dependencies(struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state;\n\tstruct drm_connector *conn;\n\tstruct drm_connector_state *old_conn_state;\n\tint i;\n\tlong ret;\n\n\tfor_each_old_crtc_in_state(old_state, crtc, old_crtc_state, i) {\n\t\tret = drm_crtc_commit_wait(old_crtc_state->commit);\n\t\tif (ret)\n\t\t\tdrm_err(crtc->dev,\n\t\t\t\t\"[CRTC:%d:%s] commit wait timed out\\n\",\n\t\t\t\tcrtc->base.id, crtc->name);\n\t}\n\n\tfor_each_old_connector_in_state(old_state, conn, old_conn_state, i) {\n\t\tret = drm_crtc_commit_wait(old_conn_state->commit);\n\t\tif (ret)\n\t\t\tdrm_err(conn->dev,\n\t\t\t\t\"[CONNECTOR:%d:%s] commit wait timed out\\n\",\n\t\t\t\tconn->base.id, conn->name);\n\t}\n\n\tfor_each_old_plane_in_state(old_state, plane, old_plane_state, i) {\n\t\tret = drm_crtc_commit_wait(old_plane_state->commit);\n\t\tif (ret)\n\t\t\tdrm_err(plane->dev,\n\t\t\t\t\"[PLANE:%d:%s] commit wait timed out\\n\",\n\t\t\t\tplane->base.id, plane->name);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_wait_for_dependencies);\n\n \nvoid drm_atomic_helper_fake_vblank(struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct drm_crtc *crtc;\n\tint i;\n\n\tfor_each_new_crtc_in_state(old_state, crtc, new_crtc_state, i) {\n\t\tunsigned long flags;\n\n\t\tif (!new_crtc_state->no_vblank)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&old_state->dev->event_lock, flags);\n\t\tif (new_crtc_state->event) {\n\t\t\tdrm_crtc_send_vblank_event(crtc,\n\t\t\t\t\t\t   new_crtc_state->event);\n\t\t\tnew_crtc_state->event = NULL;\n\t\t}\n\t\tspin_unlock_irqrestore(&old_state->dev->event_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_fake_vblank);\n\n \nvoid drm_atomic_helper_commit_hw_done(struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_crtc_commit *commit;\n\tint i;\n\n\tfor_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tcommit = new_crtc_state->commit;\n\t\tif (!commit)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (old_crtc_state->commit)\n\t\t\tdrm_crtc_commit_put(old_crtc_state->commit);\n\n\t\told_crtc_state->commit = drm_crtc_commit_get(commit);\n\n\t\t \n\t\tWARN_ON(new_crtc_state->event);\n\t\tcomplete_all(&commit->hw_done);\n\t}\n\n\tif (old_state->fake_commit) {\n\t\tcomplete_all(&old_state->fake_commit->hw_done);\n\t\tcomplete_all(&old_state->fake_commit->flip_done);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_hw_done);\n\n \nvoid drm_atomic_helper_commit_cleanup_done(struct drm_atomic_state *old_state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state;\n\tstruct drm_crtc_commit *commit;\n\tint i;\n\n\tfor_each_old_crtc_in_state(old_state, crtc, old_crtc_state, i) {\n\t\tcommit = old_crtc_state->commit;\n\t\tif (WARN_ON(!commit))\n\t\t\tcontinue;\n\n\t\tcomplete_all(&commit->cleanup_done);\n\t\tWARN_ON(!try_wait_for_completion(&commit->hw_done));\n\n\t\tspin_lock(&crtc->commit_lock);\n\t\tlist_del(&commit->commit_entry);\n\t\tspin_unlock(&crtc->commit_lock);\n\t}\n\n\tif (old_state->fake_commit) {\n\t\tcomplete_all(&old_state->fake_commit->cleanup_done);\n\t\tWARN_ON(!try_wait_for_completion(&old_state->fake_commit->hw_done));\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_cleanup_done);\n\n \nint drm_atomic_helper_prepare_planes(struct drm_device *dev,\n\t\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tint ret, i, j;\n\n\tfor_each_new_connector_in_state(state, connector, new_conn_state, i) {\n\t\tif (!new_conn_state->writeback_job)\n\t\t\tcontinue;\n\n\t\tret = drm_writeback_prepare_job(new_conn_state->writeback_job);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs;\n\n\t\tfuncs = plane->helper_private;\n\n\t\tif (funcs->prepare_fb) {\n\t\t\tret = funcs->prepare_fb(plane, new_plane_state);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_prepare_fb;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(funcs->cleanup_fb);\n\n\t\t\tif (!drm_core_check_feature(dev, DRIVER_GEM))\n\t\t\t\tcontinue;\n\n\t\t\tret = drm_gem_plane_helper_prepare_fb(plane, new_plane_state);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_prepare_fb;\n\t\t}\n\t}\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs = plane->helper_private;\n\n\t\tif (funcs->begin_fb_access) {\n\t\t\tret = funcs->begin_fb_access(plane, new_plane_state);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_begin_fb_access;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail_begin_fb_access:\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, j) {\n\t\tconst struct drm_plane_helper_funcs *funcs = plane->helper_private;\n\n\t\tif (j >= i)\n\t\t\tcontinue;\n\n\t\tif (funcs->end_fb_access)\n\t\t\tfuncs->end_fb_access(plane, new_plane_state);\n\t}\n\ti = j;  \nfail_prepare_fb:\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, j) {\n\t\tconst struct drm_plane_helper_funcs *funcs;\n\n\t\tif (j >= i)\n\t\t\tcontinue;\n\n\t\tfuncs = plane->helper_private;\n\n\t\tif (funcs->cleanup_fb)\n\t\t\tfuncs->cleanup_fb(plane, new_plane_state);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_prepare_planes);\n\n \nvoid drm_atomic_helper_unprepare_planes(struct drm_device *dev,\n\t\t\t\t\tstruct drm_atomic_state *state)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tint i;\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs = plane->helper_private;\n\n\t\tif (funcs->end_fb_access)\n\t\t\tfuncs->end_fb_access(plane, new_plane_state);\n\t}\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs = plane->helper_private;\n\n\t\tif (funcs->cleanup_fb)\n\t\t\tfuncs->cleanup_fb(plane, new_plane_state);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_unprepare_planes);\n\nstatic bool plane_crtc_active(const struct drm_plane_state *state)\n{\n\treturn state->crtc && state->crtc->state->active;\n}\n\n \nvoid drm_atomic_helper_commit_planes(struct drm_device *dev,\n\t\t\t\t     struct drm_atomic_state *old_state,\n\t\t\t\t     uint32_t flags)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tint i;\n\tbool active_only = flags & DRM_PLANE_COMMIT_ACTIVE_ONLY;\n\tbool no_disable = flags & DRM_PLANE_COMMIT_NO_DISABLE_AFTER_MODESET;\n\n\tfor_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (!funcs || !funcs->atomic_begin)\n\t\t\tcontinue;\n\n\t\tif (active_only && !new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tfuncs->atomic_begin(crtc, old_state);\n\t}\n\n\tfor_each_oldnew_plane_in_state(old_state, plane, old_plane_state, new_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs;\n\t\tbool disabling;\n\n\t\tfuncs = plane->helper_private;\n\n\t\tif (!funcs)\n\t\t\tcontinue;\n\n\t\tdisabling = drm_atomic_plane_disabling(old_plane_state,\n\t\t\t\t\t\t       new_plane_state);\n\n\t\tif (active_only) {\n\t\t\t \n\t\t\tif (!disabling && !plane_crtc_active(new_plane_state))\n\t\t\t\tcontinue;\n\t\t\tif (disabling && !plane_crtc_active(old_plane_state))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (disabling && funcs->atomic_disable) {\n\t\t\tstruct drm_crtc_state *crtc_state;\n\n\t\t\tcrtc_state = old_plane_state->crtc->state;\n\n\t\t\tif (drm_atomic_crtc_needs_modeset(crtc_state) &&\n\t\t\t    no_disable)\n\t\t\t\tcontinue;\n\n\t\t\tfuncs->atomic_disable(plane, old_state);\n\t\t} else if (new_plane_state->crtc || disabling) {\n\t\t\tfuncs->atomic_update(plane, old_state);\n\n\t\t\tif (!disabling && funcs->atomic_enable) {\n\t\t\t\tif (drm_atomic_plane_enabling(old_plane_state, new_plane_state))\n\t\t\t\t\tfuncs->atomic_enable(plane, old_state);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_oldnew_crtc_in_state(old_state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tconst struct drm_crtc_helper_funcs *funcs;\n\n\t\tfuncs = crtc->helper_private;\n\n\t\tif (!funcs || !funcs->atomic_flush)\n\t\t\tcontinue;\n\n\t\tif (active_only && !new_crtc_state->active)\n\t\t\tcontinue;\n\n\t\tfuncs->atomic_flush(crtc, old_state);\n\t}\n\n\t \n\tfor_each_old_plane_in_state(old_state, plane, old_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs = plane->helper_private;\n\n\t\tif (funcs->end_fb_access)\n\t\t\tfuncs->end_fb_access(plane, old_plane_state);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_planes);\n\n \nvoid\ndrm_atomic_helper_commit_planes_on_crtc(struct drm_crtc_state *old_crtc_state)\n{\n\tconst struct drm_crtc_helper_funcs *crtc_funcs;\n\tstruct drm_crtc *crtc = old_crtc_state->crtc;\n\tstruct drm_atomic_state *old_state = old_crtc_state->state;\n\tstruct drm_crtc_state *new_crtc_state =\n\t\tdrm_atomic_get_new_crtc_state(old_state, crtc);\n\tstruct drm_plane *plane;\n\tunsigned int plane_mask;\n\n\tplane_mask = old_crtc_state->plane_mask;\n\tplane_mask |= new_crtc_state->plane_mask;\n\n\tcrtc_funcs = crtc->helper_private;\n\tif (crtc_funcs && crtc_funcs->atomic_begin)\n\t\tcrtc_funcs->atomic_begin(crtc, old_state);\n\n\tdrm_for_each_plane_mask(plane, crtc->dev, plane_mask) {\n\t\tstruct drm_plane_state *old_plane_state =\n\t\t\tdrm_atomic_get_old_plane_state(old_state, plane);\n\t\tstruct drm_plane_state *new_plane_state =\n\t\t\tdrm_atomic_get_new_plane_state(old_state, plane);\n\t\tconst struct drm_plane_helper_funcs *plane_funcs;\n\t\tbool disabling;\n\n\t\tplane_funcs = plane->helper_private;\n\n\t\tif (!old_plane_state || !plane_funcs)\n\t\t\tcontinue;\n\n\t\tWARN_ON(new_plane_state->crtc &&\n\t\t\tnew_plane_state->crtc != crtc);\n\n\t\tdisabling = drm_atomic_plane_disabling(old_plane_state, new_plane_state);\n\n\t\tif (disabling && plane_funcs->atomic_disable) {\n\t\t\tplane_funcs->atomic_disable(plane, old_state);\n\t\t} else if (new_plane_state->crtc || disabling) {\n\t\t\tplane_funcs->atomic_update(plane, old_state);\n\n\t\t\tif (!disabling && plane_funcs->atomic_enable) {\n\t\t\t\tif (drm_atomic_plane_enabling(old_plane_state, new_plane_state))\n\t\t\t\t\tplane_funcs->atomic_enable(plane, old_state);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (crtc_funcs && crtc_funcs->atomic_flush)\n\t\tcrtc_funcs->atomic_flush(crtc, old_state);\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_planes_on_crtc);\n\n \nvoid\ndrm_atomic_helper_disable_planes_on_crtc(struct drm_crtc_state *old_crtc_state,\n\t\t\t\t\t bool atomic)\n{\n\tstruct drm_crtc *crtc = old_crtc_state->crtc;\n\tconst struct drm_crtc_helper_funcs *crtc_funcs =\n\t\tcrtc->helper_private;\n\tstruct drm_plane *plane;\n\n\tif (atomic && crtc_funcs && crtc_funcs->atomic_begin)\n\t\tcrtc_funcs->atomic_begin(crtc, NULL);\n\n\tdrm_atomic_crtc_state_for_each_plane(plane, old_crtc_state) {\n\t\tconst struct drm_plane_helper_funcs *plane_funcs =\n\t\t\tplane->helper_private;\n\n\t\tif (!plane_funcs)\n\t\t\tcontinue;\n\n\t\tWARN_ON(!plane_funcs->atomic_disable);\n\t\tif (plane_funcs->atomic_disable)\n\t\t\tplane_funcs->atomic_disable(plane, NULL);\n\t}\n\n\tif (atomic && crtc_funcs && crtc_funcs->atomic_flush)\n\t\tcrtc_funcs->atomic_flush(crtc, NULL);\n}\nEXPORT_SYMBOL(drm_atomic_helper_disable_planes_on_crtc);\n\n \nvoid drm_atomic_helper_cleanup_planes(struct drm_device *dev,\n\t\t\t\t      struct drm_atomic_state *old_state)\n{\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state;\n\tint i;\n\n\tfor_each_old_plane_in_state(old_state, plane, old_plane_state, i) {\n\t\tconst struct drm_plane_helper_funcs *funcs = plane->helper_private;\n\n\t\tif (funcs->cleanup_fb)\n\t\t\tfuncs->cleanup_fb(plane, old_plane_state);\n\t}\n}\nEXPORT_SYMBOL(drm_atomic_helper_cleanup_planes);\n\n \nint drm_atomic_helper_swap_state(struct drm_atomic_state *state,\n\t\t\t\t  bool stall)\n{\n\tint i, ret;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_conn_state, *new_conn_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *old_plane_state, *new_plane_state;\n\tstruct drm_crtc_commit *commit;\n\tstruct drm_private_obj *obj;\n\tstruct drm_private_state *old_obj_state, *new_obj_state;\n\n\tif (stall) {\n\t\t \n\n\t\tfor_each_old_crtc_in_state(state, crtc, old_crtc_state, i) {\n\t\t\tcommit = old_crtc_state->commit;\n\n\t\t\tif (!commit)\n\t\t\t\tcontinue;\n\n\t\t\tret = wait_for_completion_interruptible(&commit->hw_done);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor_each_old_connector_in_state(state, connector, old_conn_state, i) {\n\t\t\tcommit = old_conn_state->commit;\n\n\t\t\tif (!commit)\n\t\t\t\tcontinue;\n\n\t\t\tret = wait_for_completion_interruptible(&commit->hw_done);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor_each_old_plane_in_state(state, plane, old_plane_state, i) {\n\t\t\tcommit = old_plane_state->commit;\n\n\t\t\tif (!commit)\n\t\t\t\tcontinue;\n\n\t\t\tret = wait_for_completion_interruptible(&commit->hw_done);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_conn_state, new_conn_state, i) {\n\t\tWARN_ON(connector->state != old_conn_state);\n\n\t\told_conn_state->state = state;\n\t\tnew_conn_state->state = NULL;\n\n\t\tstate->connectors[i].state = old_conn_state;\n\t\tconnector->state = new_conn_state;\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tWARN_ON(crtc->state != old_crtc_state);\n\n\t\told_crtc_state->state = state;\n\t\tnew_crtc_state->state = NULL;\n\n\t\tstate->crtcs[i].state = old_crtc_state;\n\t\tcrtc->state = new_crtc_state;\n\n\t\tif (new_crtc_state->commit) {\n\t\t\tspin_lock(&crtc->commit_lock);\n\t\t\tlist_add(&new_crtc_state->commit->commit_entry,\n\t\t\t\t &crtc->commit_list);\n\t\t\tspin_unlock(&crtc->commit_lock);\n\n\t\t\tnew_crtc_state->commit->event = NULL;\n\t\t}\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i) {\n\t\tWARN_ON(plane->state != old_plane_state);\n\n\t\told_plane_state->state = state;\n\t\tnew_plane_state->state = NULL;\n\n\t\tstate->planes[i].state = old_plane_state;\n\t\tplane->state = new_plane_state;\n\t}\n\n\tfor_each_oldnew_private_obj_in_state(state, obj, old_obj_state, new_obj_state, i) {\n\t\tWARN_ON(obj->state != old_obj_state);\n\n\t\told_obj_state->state = state;\n\t\tnew_obj_state->state = NULL;\n\n\t\tstate->private_objs[i].state = old_obj_state;\n\t\tobj->state = new_obj_state;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_atomic_helper_swap_state);\n\n \nint drm_atomic_helper_update_plane(struct drm_plane *plane,\n\t\t\t\t   struct drm_crtc *crtc,\n\t\t\t\t   struct drm_framebuffer *fb,\n\t\t\t\t   int crtc_x, int crtc_y,\n\t\t\t\t   unsigned int crtc_w, unsigned int crtc_h,\n\t\t\t\t   uint32_t src_x, uint32_t src_y,\n\t\t\t\t   uint32_t src_w, uint32_t src_h,\n\t\t\t\t   struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_plane_state *plane_state;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(plane->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\tplane_state = drm_atomic_get_plane_state(state, plane);\n\tif (IS_ERR(plane_state)) {\n\t\tret = PTR_ERR(plane_state);\n\t\tgoto fail;\n\t}\n\n\tret = drm_atomic_set_crtc_for_plane(plane_state, crtc);\n\tif (ret != 0)\n\t\tgoto fail;\n\tdrm_atomic_set_fb_for_plane(plane_state, fb);\n\tplane_state->crtc_x = crtc_x;\n\tplane_state->crtc_y = crtc_y;\n\tplane_state->crtc_w = crtc_w;\n\tplane_state->crtc_h = crtc_h;\n\tplane_state->src_x = src_x;\n\tplane_state->src_y = src_y;\n\tplane_state->src_w = src_w;\n\tplane_state->src_h = src_h;\n\n\tif (plane == crtc->cursor)\n\t\tstate->legacy_cursor_update = true;\n\n\tret = drm_atomic_commit(state);\nfail:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_update_plane);\n\n \nint drm_atomic_helper_disable_plane(struct drm_plane *plane,\n\t\t\t\t    struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_plane_state *plane_state;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(plane->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\tplane_state = drm_atomic_get_plane_state(state, plane);\n\tif (IS_ERR(plane_state)) {\n\t\tret = PTR_ERR(plane_state);\n\t\tgoto fail;\n\t}\n\n\tif (plane_state->crtc && plane_state->crtc->cursor == plane)\n\t\tplane_state->state->legacy_cursor_update = true;\n\n\tret = __drm_atomic_helper_disable_plane(plane, plane_state);\n\tif (ret != 0)\n\t\tgoto fail;\n\n\tret = drm_atomic_commit(state);\nfail:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_disable_plane);\n\n \nint drm_atomic_helper_set_config(struct drm_mode_set *set,\n\t\t\t\t struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_crtc *crtc = set->crtc;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(crtc->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\tret = __drm_atomic_helper_set_config(set, state);\n\tif (ret != 0)\n\t\tgoto fail;\n\n\tret = handle_conflicting_encoders(state, true);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = drm_atomic_commit(state);\n\nfail:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_set_config);\n\n \nint drm_atomic_helper_disable_all(struct drm_device *dev,\n\t\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_connector_state *conn_state;\n\tstruct drm_connector *conn;\n\tstruct drm_plane_state *plane_state;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_crtc *crtc;\n\tint ret, i;\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\tret = PTR_ERR(crtc_state);\n\t\t\tgoto free;\n\t\t}\n\n\t\tcrtc_state->active = false;\n\n\t\tret = drm_atomic_set_mode_prop_for_crtc(crtc_state, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto free;\n\n\t\tret = drm_atomic_add_affected_planes(state, crtc);\n\t\tif (ret < 0)\n\t\t\tgoto free;\n\n\t\tret = drm_atomic_add_affected_connectors(state, crtc);\n\t\tif (ret < 0)\n\t\t\tgoto free;\n\t}\n\n\tfor_each_new_connector_in_state(state, conn, conn_state, i) {\n\t\tret = drm_atomic_set_crtc_for_connector(conn_state, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto free;\n\t}\n\n\tfor_each_new_plane_in_state(state, plane, plane_state, i) {\n\t\tret = drm_atomic_set_crtc_for_plane(plane_state, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto free;\n\n\t\tdrm_atomic_set_fb_for_plane(plane_state, NULL);\n\t}\n\n\tret = drm_atomic_commit(state);\nfree:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_disable_all);\n\n \nvoid drm_atomic_helper_shutdown(struct drm_device *dev)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint ret;\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, ret);\n\n\tret = drm_atomic_helper_disable_all(dev, &ctx);\n\tif (ret)\n\t\tdrm_err(dev,\n\t\t\t\"Disabling all crtc's during unload failed with %i\\n\",\n\t\t\tret);\n\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, ret);\n}\nEXPORT_SYMBOL(drm_atomic_helper_shutdown);\n\n \nstruct drm_atomic_state *\ndrm_atomic_helper_duplicate_state(struct drm_device *dev,\n\t\t\t\t  struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_atomic_state *state;\n\tstruct drm_connector *conn;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_plane *plane;\n\tstruct drm_crtc *crtc;\n\tint err = 0;\n\n\tstate = drm_atomic_state_alloc(dev);\n\tif (!state)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstate->acquire_ctx = ctx;\n\tstate->duplicated = true;\n\n\tdrm_for_each_crtc(crtc, dev) {\n\t\tstruct drm_crtc_state *crtc_state;\n\n\t\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\t\tif (IS_ERR(crtc_state)) {\n\t\t\terr = PTR_ERR(crtc_state);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tdrm_for_each_plane(plane, dev) {\n\t\tstruct drm_plane_state *plane_state;\n\n\t\tplane_state = drm_atomic_get_plane_state(state, plane);\n\t\tif (IS_ERR(plane_state)) {\n\t\t\terr = PTR_ERR(plane_state);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(conn, &conn_iter) {\n\t\tstruct drm_connector_state *conn_state;\n\n\t\tconn_state = drm_atomic_get_connector_state(state, conn);\n\t\tif (IS_ERR(conn_state)) {\n\t\t\terr = PTR_ERR(conn_state);\n\t\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\t\tgoto free;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\t \n\tstate->acquire_ctx = NULL;\n\nfree:\n\tif (err < 0) {\n\t\tdrm_atomic_state_put(state);\n\t\tstate = ERR_PTR(err);\n\t}\n\n\treturn state;\n}\nEXPORT_SYMBOL(drm_atomic_helper_duplicate_state);\n\n \nstruct drm_atomic_state *drm_atomic_helper_suspend(struct drm_device *dev)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tstruct drm_atomic_state *state;\n\tint err;\n\n\t \n\tstate = ERR_PTR(-EINVAL);\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, err);\n\n\tstate = drm_atomic_helper_duplicate_state(dev, &ctx);\n\tif (IS_ERR(state))\n\t\tgoto unlock;\n\n\terr = drm_atomic_helper_disable_all(dev, &ctx);\n\tif (err < 0) {\n\t\tdrm_atomic_state_put(state);\n\t\tstate = ERR_PTR(err);\n\t\tgoto unlock;\n\t}\n\nunlock:\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, err);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn state;\n}\nEXPORT_SYMBOL(drm_atomic_helper_suspend);\n\n \nint drm_atomic_helper_commit_duplicated_state(struct drm_atomic_state *state,\n\t\t\t\t\t      struct drm_modeset_acquire_ctx *ctx)\n{\n\tint i, ret;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *new_conn_state;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\n\tstate->acquire_ctx = ctx;\n\n\tfor_each_new_plane_in_state(state, plane, new_plane_state, i)\n\t\tstate->planes[i].old_state = plane->state;\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i)\n\t\tstate->crtcs[i].old_state = crtc->state;\n\n\tfor_each_new_connector_in_state(state, connector, new_conn_state, i)\n\t\tstate->connectors[i].old_state = connector->state;\n\n\tret = drm_atomic_commit(state);\n\n\tstate->acquire_ctx = NULL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_commit_duplicated_state);\n\n \nint drm_atomic_helper_resume(struct drm_device *dev,\n\t\t\t     struct drm_atomic_state *state)\n{\n\tstruct drm_modeset_acquire_ctx ctx;\n\tint err;\n\n\tdrm_mode_config_reset(dev);\n\n\tDRM_MODESET_LOCK_ALL_BEGIN(dev, ctx, 0, err);\n\n\terr = drm_atomic_helper_commit_duplicated_state(state, &ctx);\n\n\tDRM_MODESET_LOCK_ALL_END(dev, ctx, err);\n\tdrm_atomic_state_put(state);\n\n\treturn err;\n}\nEXPORT_SYMBOL(drm_atomic_helper_resume);\n\nstatic int page_flip_common(struct drm_atomic_state *state,\n\t\t\t    struct drm_crtc *crtc,\n\t\t\t    struct drm_framebuffer *fb,\n\t\t\t    struct drm_pending_vblank_event *event,\n\t\t\t    uint32_t flags)\n{\n\tstruct drm_plane *plane = crtc->primary;\n\tstruct drm_plane_state *plane_state;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret = 0;\n\n\tcrtc_state = drm_atomic_get_crtc_state(state, crtc);\n\tif (IS_ERR(crtc_state))\n\t\treturn PTR_ERR(crtc_state);\n\n\tcrtc_state->event = event;\n\tcrtc_state->async_flip = flags & DRM_MODE_PAGE_FLIP_ASYNC;\n\n\tplane_state = drm_atomic_get_plane_state(state, plane);\n\tif (IS_ERR(plane_state))\n\t\treturn PTR_ERR(plane_state);\n\n\tret = drm_atomic_set_crtc_for_plane(plane_state, crtc);\n\tif (ret != 0)\n\t\treturn ret;\n\tdrm_atomic_set_fb_for_plane(plane_state, fb);\n\n\t \n\tstate->allow_modeset = false;\n\tif (!crtc_state->active) {\n\t\tdrm_dbg_atomic(crtc->dev,\n\t\t\t       \"[CRTC:%d:%s] disabled, rejecting legacy flip\\n\",\n\t\t\t       crtc->base.id, crtc->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nint drm_atomic_helper_page_flip(struct drm_crtc *crtc,\n\t\t\t\tstruct drm_framebuffer *fb,\n\t\t\t\tstruct drm_pending_vblank_event *event,\n\t\t\t\tuint32_t flags,\n\t\t\t\tstruct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_plane *plane = crtc->primary;\n\tstruct drm_atomic_state *state;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(plane->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\n\tret = page_flip_common(state, crtc, fb, event, flags);\n\tif (ret != 0)\n\t\tgoto fail;\n\n\tret = drm_atomic_nonblocking_commit(state);\nfail:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_page_flip);\n\n \nint drm_atomic_helper_page_flip_target(struct drm_crtc *crtc,\n\t\t\t\t       struct drm_framebuffer *fb,\n\t\t\t\t       struct drm_pending_vblank_event *event,\n\t\t\t\t       uint32_t flags,\n\t\t\t\t       uint32_t target,\n\t\t\t\t       struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_plane *plane = crtc->primary;\n\tstruct drm_atomic_state *state;\n\tstruct drm_crtc_state *crtc_state;\n\tint ret = 0;\n\n\tstate = drm_atomic_state_alloc(plane->dev);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->acquire_ctx = ctx;\n\n\tret = page_flip_common(state, crtc, fb, event, flags);\n\tif (ret != 0)\n\t\tgoto fail;\n\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, crtc);\n\tif (WARN_ON(!crtc_state)) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\tcrtc_state->target_vblank = target;\n\n\tret = drm_atomic_nonblocking_commit(state);\nfail:\n\tdrm_atomic_state_put(state);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_atomic_helper_page_flip_target);\n\n \nu32 *\ndrm_atomic_helper_bridge_propagate_bus_fmt(struct drm_bridge *bridge,\n\t\t\t\t\tstruct drm_bridge_state *bridge_state,\n\t\t\t\t\tstruct drm_crtc_state *crtc_state,\n\t\t\t\t\tstruct drm_connector_state *conn_state,\n\t\t\t\t\tu32 output_fmt,\n\t\t\t\t\tunsigned int *num_input_fmts)\n{\n\tu32 *input_fmts;\n\n\tinput_fmts = kzalloc(sizeof(*input_fmts), GFP_KERNEL);\n\tif (!input_fmts) {\n\t\t*num_input_fmts = 0;\n\t\treturn NULL;\n\t}\n\n\t*num_input_fmts = 1;\n\tinput_fmts[0] = output_fmt;\n\treturn input_fmts;\n}\nEXPORT_SYMBOL(drm_atomic_helper_bridge_propagate_bus_fmt);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}