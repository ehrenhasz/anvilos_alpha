{
  "module_name": "drm_mm.c",
  "hash_id": "286c7173f67a661984a7687093cd973b291dfcfcb6c8308910384b6150904529",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/drm_mm.c",
  "human_readable_source": " \n\n \n\n#include <linux/export.h>\n#include <linux/interval_tree_generic.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/stacktrace.h>\n\n#include <drm/drm_mm.h>\n\n \n\n#ifdef CONFIG_DRM_DEBUG_MM\n#include <linux/stackdepot.h>\n\n#define STACKDEPTH 32\n#define BUFSZ 4096\n\nstatic noinline void save_stack(struct drm_mm_node *node)\n{\n\tunsigned long entries[STACKDEPTH];\n\tunsigned int n;\n\n\tn = stack_trace_save(entries, ARRAY_SIZE(entries), 1);\n\n\t \n\tnode->stack = stack_depot_save(entries, n, GFP_NOWAIT);\n}\n\nstatic void show_leaks(struct drm_mm *mm)\n{\n\tstruct drm_mm_node *node;\n\tchar *buf;\n\n\tbuf = kmalloc(BUFSZ, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\tlist_for_each_entry(node, drm_mm_nodes(mm), node_list) {\n\t\tif (!node->stack) {\n\t\t\tDRM_ERROR(\"node [%08llx + %08llx]: unknown owner\\n\",\n\t\t\t\t  node->start, node->size);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstack_depot_snprint(node->stack, buf, BUFSZ, 0);\n\t\tDRM_ERROR(\"node [%08llx + %08llx]: inserted at\\n%s\",\n\t\t\t  node->start, node->size, buf);\n\t}\n\n\tkfree(buf);\n}\n\n#undef STACKDEPTH\n#undef BUFSZ\n#else\nstatic void save_stack(struct drm_mm_node *node) { }\nstatic void show_leaks(struct drm_mm *mm) { }\n#endif\n\n#define START(node) ((node)->start)\n#define LAST(node)  ((node)->start + (node)->size - 1)\n\nINTERVAL_TREE_DEFINE(struct drm_mm_node, rb,\n\t\t     u64, __subtree_last,\n\t\t     START, LAST, static inline, drm_mm_interval_tree)\n\nstruct drm_mm_node *\n__drm_mm_interval_first(const struct drm_mm *mm, u64 start, u64 last)\n{\n\treturn drm_mm_interval_tree_iter_first((struct rb_root_cached *)&mm->interval_tree,\n\t\t\t\t\t       start, last) ?: (struct drm_mm_node *)&mm->head_node;\n}\nEXPORT_SYMBOL(__drm_mm_interval_first);\n\nstatic void drm_mm_interval_tree_add_node(struct drm_mm_node *hole_node,\n\t\t\t\t\t  struct drm_mm_node *node)\n{\n\tstruct drm_mm *mm = hole_node->mm;\n\tstruct rb_node **link, *rb;\n\tstruct drm_mm_node *parent;\n\tbool leftmost;\n\n\tnode->__subtree_last = LAST(node);\n\n\tif (drm_mm_node_allocated(hole_node)) {\n\t\trb = &hole_node->rb;\n\t\twhile (rb) {\n\t\t\tparent = rb_entry(rb, struct drm_mm_node, rb);\n\t\t\tif (parent->__subtree_last >= node->__subtree_last)\n\t\t\t\tbreak;\n\n\t\t\tparent->__subtree_last = node->__subtree_last;\n\t\t\trb = rb_parent(rb);\n\t\t}\n\n\t\trb = &hole_node->rb;\n\t\tlink = &hole_node->rb.rb_right;\n\t\tleftmost = false;\n\t} else {\n\t\trb = NULL;\n\t\tlink = &mm->interval_tree.rb_root.rb_node;\n\t\tleftmost = true;\n\t}\n\n\twhile (*link) {\n\t\trb = *link;\n\t\tparent = rb_entry(rb, struct drm_mm_node, rb);\n\t\tif (parent->__subtree_last < node->__subtree_last)\n\t\t\tparent->__subtree_last = node->__subtree_last;\n\t\tif (node->start < parent->start) {\n\t\t\tlink = &parent->rb.rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb.rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\trb_link_node(&node->rb, rb, link);\n\trb_insert_augmented_cached(&node->rb, &mm->interval_tree, leftmost,\n\t\t\t\t   &drm_mm_interval_tree_augment);\n}\n\n#define HOLE_SIZE(NODE) ((NODE)->hole_size)\n#define HOLE_ADDR(NODE) (__drm_mm_hole_node_start(NODE))\n\nstatic u64 rb_to_hole_size(struct rb_node *rb)\n{\n\treturn rb_entry(rb, struct drm_mm_node, rb_hole_size)->hole_size;\n}\n\nstatic void insert_hole_size(struct rb_root_cached *root,\n\t\t\t     struct drm_mm_node *node)\n{\n\tstruct rb_node **link = &root->rb_root.rb_node, *rb = NULL;\n\tu64 x = node->hole_size;\n\tbool first = true;\n\n\twhile (*link) {\n\t\trb = *link;\n\t\tif (x > rb_to_hole_size(rb)) {\n\t\t\tlink = &rb->rb_left;\n\t\t} else {\n\t\t\tlink = &rb->rb_right;\n\t\t\tfirst = false;\n\t\t}\n\t}\n\n\trb_link_node(&node->rb_hole_size, rb, link);\n\trb_insert_color_cached(&node->rb_hole_size, root, first);\n}\n\nRB_DECLARE_CALLBACKS_MAX(static, augment_callbacks,\n\t\t\t struct drm_mm_node, rb_hole_addr,\n\t\t\t u64, subtree_max_hole, HOLE_SIZE)\n\nstatic void insert_hole_addr(struct rb_root *root, struct drm_mm_node *node)\n{\n\tstruct rb_node **link = &root->rb_node, *rb_parent = NULL;\n\tu64 start = HOLE_ADDR(node), subtree_max_hole = node->subtree_max_hole;\n\tstruct drm_mm_node *parent;\n\n\twhile (*link) {\n\t\trb_parent = *link;\n\t\tparent = rb_entry(rb_parent, struct drm_mm_node, rb_hole_addr);\n\t\tif (parent->subtree_max_hole < subtree_max_hole)\n\t\t\tparent->subtree_max_hole = subtree_max_hole;\n\t\tif (start < HOLE_ADDR(parent))\n\t\t\tlink = &parent->rb_hole_addr.rb_left;\n\t\telse\n\t\t\tlink = &parent->rb_hole_addr.rb_right;\n\t}\n\n\trb_link_node(&node->rb_hole_addr, rb_parent, link);\n\trb_insert_augmented(&node->rb_hole_addr, root, &augment_callbacks);\n}\n\nstatic void add_hole(struct drm_mm_node *node)\n{\n\tstruct drm_mm *mm = node->mm;\n\n\tnode->hole_size =\n\t\t__drm_mm_hole_node_end(node) - __drm_mm_hole_node_start(node);\n\tnode->subtree_max_hole = node->hole_size;\n\tDRM_MM_BUG_ON(!drm_mm_hole_follows(node));\n\n\tinsert_hole_size(&mm->holes_size, node);\n\tinsert_hole_addr(&mm->holes_addr, node);\n\n\tlist_add(&node->hole_stack, &mm->hole_stack);\n}\n\nstatic void rm_hole(struct drm_mm_node *node)\n{\n\tDRM_MM_BUG_ON(!drm_mm_hole_follows(node));\n\n\tlist_del(&node->hole_stack);\n\trb_erase_cached(&node->rb_hole_size, &node->mm->holes_size);\n\trb_erase_augmented(&node->rb_hole_addr, &node->mm->holes_addr,\n\t\t\t   &augment_callbacks);\n\tnode->hole_size = 0;\n\tnode->subtree_max_hole = 0;\n\n\tDRM_MM_BUG_ON(drm_mm_hole_follows(node));\n}\n\nstatic inline struct drm_mm_node *rb_hole_size_to_node(struct rb_node *rb)\n{\n\treturn rb_entry_safe(rb, struct drm_mm_node, rb_hole_size);\n}\n\nstatic inline struct drm_mm_node *rb_hole_addr_to_node(struct rb_node *rb)\n{\n\treturn rb_entry_safe(rb, struct drm_mm_node, rb_hole_addr);\n}\n\nstatic struct drm_mm_node *best_hole(struct drm_mm *mm, u64 size)\n{\n\tstruct rb_node *rb = mm->holes_size.rb_root.rb_node;\n\tstruct drm_mm_node *best = NULL;\n\n\tdo {\n\t\tstruct drm_mm_node *node =\n\t\t\trb_entry(rb, struct drm_mm_node, rb_hole_size);\n\n\t\tif (size <= node->hole_size) {\n\t\t\tbest = node;\n\t\t\trb = rb->rb_right;\n\t\t} else {\n\t\t\trb = rb->rb_left;\n\t\t}\n\t} while (rb);\n\n\treturn best;\n}\n\nstatic bool usable_hole_addr(struct rb_node *rb, u64 size)\n{\n\treturn rb && rb_hole_addr_to_node(rb)->subtree_max_hole >= size;\n}\n\nstatic struct drm_mm_node *find_hole_addr(struct drm_mm *mm, u64 addr, u64 size)\n{\n\tstruct rb_node *rb = mm->holes_addr.rb_node;\n\tstruct drm_mm_node *node = NULL;\n\n\twhile (rb) {\n\t\tu64 hole_start;\n\n\t\tif (!usable_hole_addr(rb, size))\n\t\t\tbreak;\n\n\t\tnode = rb_hole_addr_to_node(rb);\n\t\thole_start = __drm_mm_hole_node_start(node);\n\n\t\tif (addr < hole_start)\n\t\t\trb = node->rb_hole_addr.rb_left;\n\t\telse if (addr > hole_start + node->hole_size)\n\t\t\trb = node->rb_hole_addr.rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn node;\n}\n\nstatic struct drm_mm_node *\nfirst_hole(struct drm_mm *mm,\n\t   u64 start, u64 end, u64 size,\n\t   enum drm_mm_insert_mode mode)\n{\n\tswitch (mode) {\n\tdefault:\n\tcase DRM_MM_INSERT_BEST:\n\t\treturn best_hole(mm, size);\n\n\tcase DRM_MM_INSERT_LOW:\n\t\treturn find_hole_addr(mm, start, size);\n\n\tcase DRM_MM_INSERT_HIGH:\n\t\treturn find_hole_addr(mm, end, size);\n\n\tcase DRM_MM_INSERT_EVICT:\n\t\treturn list_first_entry_or_null(&mm->hole_stack,\n\t\t\t\t\t\tstruct drm_mm_node,\n\t\t\t\t\t\thole_stack);\n\t}\n}\n\n \n\n#define DECLARE_NEXT_HOLE_ADDR(name, first, last)\t\t\t\\\nstatic struct drm_mm_node *name(struct drm_mm_node *entry, u64 size)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct rb_node *parent, *node = &entry->rb_hole_addr;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!entry || RB_EMPTY_NODE(node))\t\t\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (usable_hole_addr(node->first, size)) {\t\t\t\\\n\t\tnode = node->first;\t\t\t\t\t\\\n\t\twhile (usable_hole_addr(node->last, size))\t\t\\\n\t\t\tnode = node->last;\t\t\t\t\\\n\t\treturn rb_hole_addr_to_node(node);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\twhile ((parent = rb_parent(node)) && node == parent->first)\t\\\n\t\tnode = parent;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn rb_hole_addr_to_node(parent);\t\t\t\t\\\n}\n\nDECLARE_NEXT_HOLE_ADDR(next_hole_high_addr, rb_left, rb_right)\nDECLARE_NEXT_HOLE_ADDR(next_hole_low_addr, rb_right, rb_left)\n\nstatic struct drm_mm_node *\nnext_hole(struct drm_mm *mm,\n\t  struct drm_mm_node *node,\n\t  u64 size,\n\t  enum drm_mm_insert_mode mode)\n{\n\tswitch (mode) {\n\tdefault:\n\tcase DRM_MM_INSERT_BEST:\n\t\treturn rb_hole_size_to_node(rb_prev(&node->rb_hole_size));\n\n\tcase DRM_MM_INSERT_LOW:\n\t\treturn next_hole_low_addr(node, size);\n\n\tcase DRM_MM_INSERT_HIGH:\n\t\treturn next_hole_high_addr(node, size);\n\n\tcase DRM_MM_INSERT_EVICT:\n\t\tnode = list_next_entry(node, hole_stack);\n\t\treturn &node->hole_stack == &mm->hole_stack ? NULL : node;\n\t}\n}\n\n \nint drm_mm_reserve_node(struct drm_mm *mm, struct drm_mm_node *node)\n{\n\tstruct drm_mm_node *hole;\n\tu64 hole_start, hole_end;\n\tu64 adj_start, adj_end;\n\tu64 end;\n\n\tend = node->start + node->size;\n\tif (unlikely(end <= node->start))\n\t\treturn -ENOSPC;\n\n\t \n\thole = find_hole_addr(mm, node->start, 0);\n\tif (!hole)\n\t\treturn -ENOSPC;\n\n\tadj_start = hole_start = __drm_mm_hole_node_start(hole);\n\tadj_end = hole_end = hole_start + hole->hole_size;\n\n\tif (mm->color_adjust)\n\t\tmm->color_adjust(hole, node->color, &adj_start, &adj_end);\n\n\tif (adj_start > node->start || adj_end < end)\n\t\treturn -ENOSPC;\n\n\tnode->mm = mm;\n\n\t__set_bit(DRM_MM_NODE_ALLOCATED_BIT, &node->flags);\n\tlist_add(&node->node_list, &hole->node_list);\n\tdrm_mm_interval_tree_add_node(hole, node);\n\tnode->hole_size = 0;\n\n\trm_hole(hole);\n\tif (node->start > hole_start)\n\t\tadd_hole(hole);\n\tif (end < hole_end)\n\t\tadd_hole(node);\n\n\tsave_stack(node);\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_mm_reserve_node);\n\nstatic u64 rb_to_hole_size_or_zero(struct rb_node *rb)\n{\n\treturn rb ? rb_to_hole_size(rb) : 0;\n}\n\n \nint drm_mm_insert_node_in_range(struct drm_mm * const mm,\n\t\t\t\tstruct drm_mm_node * const node,\n\t\t\t\tu64 size, u64 alignment,\n\t\t\t\tunsigned long color,\n\t\t\t\tu64 range_start, u64 range_end,\n\t\t\t\tenum drm_mm_insert_mode mode)\n{\n\tstruct drm_mm_node *hole;\n\tu64 remainder_mask;\n\tbool once;\n\n\tDRM_MM_BUG_ON(range_start > range_end);\n\n\tif (unlikely(size == 0 || range_end - range_start < size))\n\t\treturn -ENOSPC;\n\n\tif (rb_to_hole_size_or_zero(rb_first_cached(&mm->holes_size)) < size)\n\t\treturn -ENOSPC;\n\n\tif (alignment <= 1)\n\t\talignment = 0;\n\n\tonce = mode & DRM_MM_INSERT_ONCE;\n\tmode &= ~DRM_MM_INSERT_ONCE;\n\n\tremainder_mask = is_power_of_2(alignment) ? alignment - 1 : 0;\n\tfor (hole = first_hole(mm, range_start, range_end, size, mode);\n\t     hole;\n\t     hole = once ? NULL : next_hole(mm, hole, size, mode)) {\n\t\tu64 hole_start = __drm_mm_hole_node_start(hole);\n\t\tu64 hole_end = hole_start + hole->hole_size;\n\t\tu64 adj_start, adj_end;\n\t\tu64 col_start, col_end;\n\n\t\tif (mode == DRM_MM_INSERT_LOW && hole_start >= range_end)\n\t\t\tbreak;\n\n\t\tif (mode == DRM_MM_INSERT_HIGH && hole_end <= range_start)\n\t\t\tbreak;\n\n\t\tcol_start = hole_start;\n\t\tcol_end = hole_end;\n\t\tif (mm->color_adjust)\n\t\t\tmm->color_adjust(hole, color, &col_start, &col_end);\n\n\t\tadj_start = max(col_start, range_start);\n\t\tadj_end = min(col_end, range_end);\n\n\t\tif (adj_end <= adj_start || adj_end - adj_start < size)\n\t\t\tcontinue;\n\n\t\tif (mode == DRM_MM_INSERT_HIGH)\n\t\t\tadj_start = adj_end - size;\n\n\t\tif (alignment) {\n\t\t\tu64 rem;\n\n\t\t\tif (likely(remainder_mask))\n\t\t\t\trem = adj_start & remainder_mask;\n\t\t\telse\n\t\t\t\tdiv64_u64_rem(adj_start, alignment, &rem);\n\t\t\tif (rem) {\n\t\t\t\tadj_start -= rem;\n\t\t\t\tif (mode != DRM_MM_INSERT_HIGH)\n\t\t\t\t\tadj_start += alignment;\n\n\t\t\t\tif (adj_start < max(col_start, range_start) ||\n\t\t\t\t    min(col_end, range_end) - adj_start < size)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (adj_end <= adj_start ||\n\t\t\t\t    adj_end - adj_start < size)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tnode->mm = mm;\n\t\tnode->size = size;\n\t\tnode->start = adj_start;\n\t\tnode->color = color;\n\t\tnode->hole_size = 0;\n\n\t\t__set_bit(DRM_MM_NODE_ALLOCATED_BIT, &node->flags);\n\t\tlist_add(&node->node_list, &hole->node_list);\n\t\tdrm_mm_interval_tree_add_node(hole, node);\n\n\t\trm_hole(hole);\n\t\tif (adj_start > hole_start)\n\t\t\tadd_hole(hole);\n\t\tif (adj_start + size < hole_end)\n\t\t\tadd_hole(node);\n\n\t\tsave_stack(node);\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\nEXPORT_SYMBOL(drm_mm_insert_node_in_range);\n\nstatic inline bool drm_mm_node_scanned_block(const struct drm_mm_node *node)\n{\n\treturn test_bit(DRM_MM_NODE_SCANNED_BIT, &node->flags);\n}\n\n \nvoid drm_mm_remove_node(struct drm_mm_node *node)\n{\n\tstruct drm_mm *mm = node->mm;\n\tstruct drm_mm_node *prev_node;\n\n\tDRM_MM_BUG_ON(!drm_mm_node_allocated(node));\n\tDRM_MM_BUG_ON(drm_mm_node_scanned_block(node));\n\n\tprev_node = list_prev_entry(node, node_list);\n\n\tif (drm_mm_hole_follows(node))\n\t\trm_hole(node);\n\n\tdrm_mm_interval_tree_remove(node, &mm->interval_tree);\n\tlist_del(&node->node_list);\n\n\tif (drm_mm_hole_follows(prev_node))\n\t\trm_hole(prev_node);\n\tadd_hole(prev_node);\n\n\tclear_bit_unlock(DRM_MM_NODE_ALLOCATED_BIT, &node->flags);\n}\nEXPORT_SYMBOL(drm_mm_remove_node);\n\n \nvoid drm_mm_replace_node(struct drm_mm_node *old, struct drm_mm_node *new)\n{\n\tstruct drm_mm *mm = old->mm;\n\n\tDRM_MM_BUG_ON(!drm_mm_node_allocated(old));\n\n\t*new = *old;\n\n\t__set_bit(DRM_MM_NODE_ALLOCATED_BIT, &new->flags);\n\tlist_replace(&old->node_list, &new->node_list);\n\trb_replace_node_cached(&old->rb, &new->rb, &mm->interval_tree);\n\n\tif (drm_mm_hole_follows(old)) {\n\t\tlist_replace(&old->hole_stack, &new->hole_stack);\n\t\trb_replace_node_cached(&old->rb_hole_size,\n\t\t\t\t       &new->rb_hole_size,\n\t\t\t\t       &mm->holes_size);\n\t\trb_replace_node(&old->rb_hole_addr,\n\t\t\t\t&new->rb_hole_addr,\n\t\t\t\t&mm->holes_addr);\n\t}\n\n\tclear_bit_unlock(DRM_MM_NODE_ALLOCATED_BIT, &old->flags);\n}\nEXPORT_SYMBOL(drm_mm_replace_node);\n\n \n\n \nvoid drm_mm_scan_init_with_range(struct drm_mm_scan *scan,\n\t\t\t\t struct drm_mm *mm,\n\t\t\t\t u64 size,\n\t\t\t\t u64 alignment,\n\t\t\t\t unsigned long color,\n\t\t\t\t u64 start,\n\t\t\t\t u64 end,\n\t\t\t\t enum drm_mm_insert_mode mode)\n{\n\tDRM_MM_BUG_ON(start >= end);\n\tDRM_MM_BUG_ON(!size || size > end - start);\n\tDRM_MM_BUG_ON(mm->scan_active);\n\n\tscan->mm = mm;\n\n\tif (alignment <= 1)\n\t\talignment = 0;\n\n\tscan->color = color;\n\tscan->alignment = alignment;\n\tscan->remainder_mask = is_power_of_2(alignment) ? alignment - 1 : 0;\n\tscan->size = size;\n\tscan->mode = mode;\n\n\tDRM_MM_BUG_ON(end <= start);\n\tscan->range_start = start;\n\tscan->range_end = end;\n\n\tscan->hit_start = U64_MAX;\n\tscan->hit_end = 0;\n}\nEXPORT_SYMBOL(drm_mm_scan_init_with_range);\n\n \nbool drm_mm_scan_add_block(struct drm_mm_scan *scan,\n\t\t\t   struct drm_mm_node *node)\n{\n\tstruct drm_mm *mm = scan->mm;\n\tstruct drm_mm_node *hole;\n\tu64 hole_start, hole_end;\n\tu64 col_start, col_end;\n\tu64 adj_start, adj_end;\n\n\tDRM_MM_BUG_ON(node->mm != mm);\n\tDRM_MM_BUG_ON(!drm_mm_node_allocated(node));\n\tDRM_MM_BUG_ON(drm_mm_node_scanned_block(node));\n\t__set_bit(DRM_MM_NODE_SCANNED_BIT, &node->flags);\n\tmm->scan_active++;\n\n\t \n\thole = list_prev_entry(node, node_list);\n\tDRM_MM_BUG_ON(list_next_entry(hole, node_list) != node);\n\t__list_del_entry(&node->node_list);\n\n\thole_start = __drm_mm_hole_node_start(hole);\n\thole_end = __drm_mm_hole_node_end(hole);\n\n\tcol_start = hole_start;\n\tcol_end = hole_end;\n\tif (mm->color_adjust)\n\t\tmm->color_adjust(hole, scan->color, &col_start, &col_end);\n\n\tadj_start = max(col_start, scan->range_start);\n\tadj_end = min(col_end, scan->range_end);\n\tif (adj_end <= adj_start || adj_end - adj_start < scan->size)\n\t\treturn false;\n\n\tif (scan->mode == DRM_MM_INSERT_HIGH)\n\t\tadj_start = adj_end - scan->size;\n\n\tif (scan->alignment) {\n\t\tu64 rem;\n\n\t\tif (likely(scan->remainder_mask))\n\t\t\trem = adj_start & scan->remainder_mask;\n\t\telse\n\t\t\tdiv64_u64_rem(adj_start, scan->alignment, &rem);\n\t\tif (rem) {\n\t\t\tadj_start -= rem;\n\t\t\tif (scan->mode != DRM_MM_INSERT_HIGH)\n\t\t\t\tadj_start += scan->alignment;\n\t\t\tif (adj_start < max(col_start, scan->range_start) ||\n\t\t\t    min(col_end, scan->range_end) - adj_start < scan->size)\n\t\t\t\treturn false;\n\n\t\t\tif (adj_end <= adj_start ||\n\t\t\t    adj_end - adj_start < scan->size)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tscan->hit_start = adj_start;\n\tscan->hit_end = adj_start + scan->size;\n\n\tDRM_MM_BUG_ON(scan->hit_start >= scan->hit_end);\n\tDRM_MM_BUG_ON(scan->hit_start < hole_start);\n\tDRM_MM_BUG_ON(scan->hit_end > hole_end);\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_mm_scan_add_block);\n\n \nbool drm_mm_scan_remove_block(struct drm_mm_scan *scan,\n\t\t\t      struct drm_mm_node *node)\n{\n\tstruct drm_mm_node *prev_node;\n\n\tDRM_MM_BUG_ON(node->mm != scan->mm);\n\tDRM_MM_BUG_ON(!drm_mm_node_scanned_block(node));\n\t__clear_bit(DRM_MM_NODE_SCANNED_BIT, &node->flags);\n\n\tDRM_MM_BUG_ON(!node->mm->scan_active);\n\tnode->mm->scan_active--;\n\n\t \n\tprev_node = list_prev_entry(node, node_list);\n\tDRM_MM_BUG_ON(list_next_entry(prev_node, node_list) !=\n\t\t      list_next_entry(node, node_list));\n\tlist_add(&node->node_list, &prev_node->node_list);\n\n\treturn (node->start + node->size > scan->hit_start &&\n\t\tnode->start < scan->hit_end);\n}\nEXPORT_SYMBOL(drm_mm_scan_remove_block);\n\n \nstruct drm_mm_node *drm_mm_scan_color_evict(struct drm_mm_scan *scan)\n{\n\tstruct drm_mm *mm = scan->mm;\n\tstruct drm_mm_node *hole;\n\tu64 hole_start, hole_end;\n\n\tDRM_MM_BUG_ON(list_empty(&mm->hole_stack));\n\n\tif (!mm->color_adjust)\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(hole, &mm->hole_stack, hole_stack) {\n\t\thole_start = __drm_mm_hole_node_start(hole);\n\t\thole_end = hole_start + hole->hole_size;\n\n\t\tif (hole_start <= scan->hit_start &&\n\t\t    hole_end >= scan->hit_end)\n\t\t\tbreak;\n\t}\n\n\t \n\tDRM_MM_BUG_ON(&hole->hole_stack == &mm->hole_stack);\n\tif (unlikely(&hole->hole_stack == &mm->hole_stack))\n\t\treturn NULL;\n\n\tDRM_MM_BUG_ON(hole_start > scan->hit_start);\n\tDRM_MM_BUG_ON(hole_end < scan->hit_end);\n\n\tmm->color_adjust(hole, scan->color, &hole_start, &hole_end);\n\tif (hole_start > scan->hit_start)\n\t\treturn hole;\n\tif (hole_end < scan->hit_end)\n\t\treturn list_next_entry(hole, node_list);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(drm_mm_scan_color_evict);\n\n \nvoid drm_mm_init(struct drm_mm *mm, u64 start, u64 size)\n{\n\tDRM_MM_BUG_ON(start + size <= start);\n\n\tmm->color_adjust = NULL;\n\n\tINIT_LIST_HEAD(&mm->hole_stack);\n\tmm->interval_tree = RB_ROOT_CACHED;\n\tmm->holes_size = RB_ROOT_CACHED;\n\tmm->holes_addr = RB_ROOT;\n\n\t \n\tINIT_LIST_HEAD(&mm->head_node.node_list);\n\tmm->head_node.flags = 0;\n\tmm->head_node.mm = mm;\n\tmm->head_node.start = start + size;\n\tmm->head_node.size = -size;\n\tadd_hole(&mm->head_node);\n\n\tmm->scan_active = 0;\n\n#ifdef CONFIG_DRM_DEBUG_MM\n\tstack_depot_init();\n#endif\n}\nEXPORT_SYMBOL(drm_mm_init);\n\n \nvoid drm_mm_takedown(struct drm_mm *mm)\n{\n\tif (WARN(!drm_mm_clean(mm),\n\t\t \"Memory manager not clean during takedown.\\n\"))\n\t\tshow_leaks(mm);\n}\nEXPORT_SYMBOL(drm_mm_takedown);\n\nstatic u64 drm_mm_dump_hole(struct drm_printer *p, const struct drm_mm_node *entry)\n{\n\tu64 start, size;\n\n\tsize = entry->hole_size;\n\tif (size) {\n\t\tstart = drm_mm_hole_node_start(entry);\n\t\tdrm_printf(p, \"%#018llx-%#018llx: %llu: free\\n\",\n\t\t\t   start, start + size, size);\n\t}\n\n\treturn size;\n}\n \nvoid drm_mm_print(const struct drm_mm *mm, struct drm_printer *p)\n{\n\tconst struct drm_mm_node *entry;\n\tu64 total_used = 0, total_free = 0, total = 0;\n\n\ttotal_free += drm_mm_dump_hole(p, &mm->head_node);\n\n\tdrm_mm_for_each_node(entry, mm) {\n\t\tdrm_printf(p, \"%#018llx-%#018llx: %llu: used\\n\", entry->start,\n\t\t\t   entry->start + entry->size, entry->size);\n\t\ttotal_used += entry->size;\n\t\ttotal_free += drm_mm_dump_hole(p, entry);\n\t}\n\ttotal = total_free + total_used;\n\n\tdrm_printf(p, \"total: %llu, used %llu free %llu\\n\", total,\n\t\t   total_used, total_free);\n}\nEXPORT_SYMBOL(drm_mm_print);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}