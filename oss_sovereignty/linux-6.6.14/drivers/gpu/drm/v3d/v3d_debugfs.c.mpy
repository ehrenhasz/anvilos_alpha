{
  "module_name": "v3d_debugfs.c",
  "hash_id": "d72a269119e0eead6bd2dc43b984d8d0abdc678694277eb29a56057004ec59fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/circ_buf.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/string_helpers.h>\n\n#include <drm/drm_debugfs.h>\n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n\n#define REGDEF(reg) { reg, #reg }\nstruct v3d_reg_def {\n\tu32 reg;\n\tconst char *name;\n};\n\nstatic const struct v3d_reg_def v3d_hub_reg_defs[] = {\n\tREGDEF(V3D_HUB_AXICFG),\n\tREGDEF(V3D_HUB_UIFCFG),\n\tREGDEF(V3D_HUB_IDENT0),\n\tREGDEF(V3D_HUB_IDENT1),\n\tREGDEF(V3D_HUB_IDENT2),\n\tREGDEF(V3D_HUB_IDENT3),\n\tREGDEF(V3D_HUB_INT_STS),\n\tREGDEF(V3D_HUB_INT_MSK_STS),\n\n\tREGDEF(V3D_MMU_CTL),\n\tREGDEF(V3D_MMU_VIO_ADDR),\n\tREGDEF(V3D_MMU_VIO_ID),\n\tREGDEF(V3D_MMU_DEBUG_INFO),\n};\n\nstatic const struct v3d_reg_def v3d_gca_reg_defs[] = {\n\tREGDEF(V3D_GCA_SAFE_SHUTDOWN),\n\tREGDEF(V3D_GCA_SAFE_SHUTDOWN_ACK),\n};\n\nstatic const struct v3d_reg_def v3d_core_reg_defs[] = {\n\tREGDEF(V3D_CTL_IDENT0),\n\tREGDEF(V3D_CTL_IDENT1),\n\tREGDEF(V3D_CTL_IDENT2),\n\tREGDEF(V3D_CTL_MISCCFG),\n\tREGDEF(V3D_CTL_INT_STS),\n\tREGDEF(V3D_CTL_INT_MSK_STS),\n\tREGDEF(V3D_CLE_CT0CS),\n\tREGDEF(V3D_CLE_CT0CA),\n\tREGDEF(V3D_CLE_CT0EA),\n\tREGDEF(V3D_CLE_CT1CS),\n\tREGDEF(V3D_CLE_CT1CA),\n\tREGDEF(V3D_CLE_CT1EA),\n\n\tREGDEF(V3D_PTB_BPCA),\n\tREGDEF(V3D_PTB_BPCS),\n\n\tREGDEF(V3D_GMP_STATUS),\n\tREGDEF(V3D_GMP_CFG),\n\tREGDEF(V3D_GMP_VIO_ADDR),\n\n\tREGDEF(V3D_ERR_FDBGO),\n\tREGDEF(V3D_ERR_FDBGB),\n\tREGDEF(V3D_ERR_FDBGS),\n\tREGDEF(V3D_ERR_STAT),\n};\n\nstatic const struct v3d_reg_def v3d_csd_reg_defs[] = {\n\tREGDEF(V3D_CSD_STATUS),\n\tREGDEF(V3D_CSD_CURRENT_CFG0),\n\tREGDEF(V3D_CSD_CURRENT_CFG1),\n\tREGDEF(V3D_CSD_CURRENT_CFG2),\n\tREGDEF(V3D_CSD_CURRENT_CFG3),\n\tREGDEF(V3D_CSD_CURRENT_CFG4),\n\tREGDEF(V3D_CSD_CURRENT_CFG5),\n\tREGDEF(V3D_CSD_CURRENT_CFG6),\n};\n\nstatic int v3d_v3d_debugfs_regs(struct seq_file *m, void *unused)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tint i, core;\n\n\tfor (i = 0; i < ARRAY_SIZE(v3d_hub_reg_defs); i++) {\n\t\tseq_printf(m, \"%s (0x%04x): 0x%08x\\n\",\n\t\t\t   v3d_hub_reg_defs[i].name, v3d_hub_reg_defs[i].reg,\n\t\t\t   V3D_READ(v3d_hub_reg_defs[i].reg));\n\t}\n\n\tif (v3d->ver < 41) {\n\t\tfor (i = 0; i < ARRAY_SIZE(v3d_gca_reg_defs); i++) {\n\t\t\tseq_printf(m, \"%s (0x%04x): 0x%08x\\n\",\n\t\t\t\t   v3d_gca_reg_defs[i].name,\n\t\t\t\t   v3d_gca_reg_defs[i].reg,\n\t\t\t\t   V3D_GCA_READ(v3d_gca_reg_defs[i].reg));\n\t\t}\n\t}\n\n\tfor (core = 0; core < v3d->cores; core++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(v3d_core_reg_defs); i++) {\n\t\t\tseq_printf(m, \"core %d %s (0x%04x): 0x%08x\\n\",\n\t\t\t\t   core,\n\t\t\t\t   v3d_core_reg_defs[i].name,\n\t\t\t\t   v3d_core_reg_defs[i].reg,\n\t\t\t\t   V3D_CORE_READ(core,\n\t\t\t\t\t\t v3d_core_reg_defs[i].reg));\n\t\t}\n\n\t\tif (v3d_has_csd(v3d)) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(v3d_csd_reg_defs); i++) {\n\t\t\t\tseq_printf(m, \"core %d %s (0x%04x): 0x%08x\\n\",\n\t\t\t\t\t   core,\n\t\t\t\t\t   v3d_csd_reg_defs[i].name,\n\t\t\t\t\t   v3d_csd_reg_defs[i].reg,\n\t\t\t\t\t   V3D_CORE_READ(core,\n\t\t\t\t\t\t\t v3d_csd_reg_defs[i].reg));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int v3d_v3d_debugfs_ident(struct seq_file *m, void *unused)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tu32 ident0, ident1, ident2, ident3, cores;\n\tint core;\n\n\tident0 = V3D_READ(V3D_HUB_IDENT0);\n\tident1 = V3D_READ(V3D_HUB_IDENT1);\n\tident2 = V3D_READ(V3D_HUB_IDENT2);\n\tident3 = V3D_READ(V3D_HUB_IDENT3);\n\tcores = V3D_GET_FIELD(ident1, V3D_HUB_IDENT1_NCORES);\n\n\tseq_printf(m, \"Revision:   %d.%d.%d.%d\\n\",\n\t\t   V3D_GET_FIELD(ident1, V3D_HUB_IDENT1_TVER),\n\t\t   V3D_GET_FIELD(ident1, V3D_HUB_IDENT1_REV),\n\t\t   V3D_GET_FIELD(ident3, V3D_HUB_IDENT3_IPREV),\n\t\t   V3D_GET_FIELD(ident3, V3D_HUB_IDENT3_IPIDX));\n\tseq_printf(m, \"MMU:        %s\\n\",\n\t\t   str_yes_no(ident2 & V3D_HUB_IDENT2_WITH_MMU));\n\tseq_printf(m, \"TFU:        %s\\n\",\n\t\t   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_TFU));\n\tseq_printf(m, \"TSY:        %s\\n\",\n\t\t   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_TSY));\n\tseq_printf(m, \"MSO:        %s\\n\",\n\t\t   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_MSO));\n\tseq_printf(m, \"L3C:        %s (%dkb)\\n\",\n\t\t   str_yes_no(ident1 & V3D_HUB_IDENT1_WITH_L3C),\n\t\t   V3D_GET_FIELD(ident2, V3D_HUB_IDENT2_L3C_NKB));\n\n\tfor (core = 0; core < cores; core++) {\n\t\tu32 misccfg;\n\t\tu32 nslc, ntmu, qups;\n\n\t\tident0 = V3D_CORE_READ(core, V3D_CTL_IDENT0);\n\t\tident1 = V3D_CORE_READ(core, V3D_CTL_IDENT1);\n\t\tident2 = V3D_CORE_READ(core, V3D_CTL_IDENT2);\n\t\tmisccfg = V3D_CORE_READ(core, V3D_CTL_MISCCFG);\n\n\t\tnslc = V3D_GET_FIELD(ident1, V3D_IDENT1_NSLC);\n\t\tntmu = V3D_GET_FIELD(ident1, V3D_IDENT1_NTMU);\n\t\tqups = V3D_GET_FIELD(ident1, V3D_IDENT1_QUPS);\n\n\t\tseq_printf(m, \"Core %d:\\n\", core);\n\t\tseq_printf(m, \"  Revision:     %d.%d\\n\",\n\t\t\t   V3D_GET_FIELD(ident0, V3D_IDENT0_VER),\n\t\t\t   V3D_GET_FIELD(ident1, V3D_IDENT1_REV));\n\t\tseq_printf(m, \"  Slices:       %d\\n\", nslc);\n\t\tseq_printf(m, \"  TMUs:         %d\\n\", nslc * ntmu);\n\t\tseq_printf(m, \"  QPUs:         %d\\n\", nslc * qups);\n\t\tseq_printf(m, \"  Semaphores:   %d\\n\",\n\t\t\t   V3D_GET_FIELD(ident1, V3D_IDENT1_NSEM));\n\t\tseq_printf(m, \"  BCG int:      %d\\n\",\n\t\t\t   (ident2 & V3D_IDENT2_BCG_INT) != 0);\n\t\tseq_printf(m, \"  Override TMU: %d\\n\",\n\t\t\t   (misccfg & V3D_MISCCFG_OVRTMUOUT) != 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int v3d_debugfs_bo_stats(struct seq_file *m, void *unused)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\n\tmutex_lock(&v3d->bo_lock);\n\tseq_printf(m, \"allocated bos:          %d\\n\",\n\t\t   v3d->bo_stats.num_allocated);\n\tseq_printf(m, \"allocated bo size (kb): %ld\\n\",\n\t\t   (long)v3d->bo_stats.pages_allocated << (PAGE_SHIFT - 10));\n\tmutex_unlock(&v3d->bo_lock);\n\n\treturn 0;\n}\n\nstatic int v3d_measure_clock(struct seq_file *m, void *unused)\n{\n\tstruct drm_debugfs_entry *entry = m->private;\n\tstruct drm_device *dev = entry->dev;\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tuint32_t cycles;\n\tint core = 0;\n\tint measure_ms = 1000;\n\n\tif (v3d->ver >= 40) {\n\t\tV3D_CORE_WRITE(core, V3D_V4_PCTR_0_SRC_0_3,\n\t\t\t       V3D_SET_FIELD(V3D_PCTR_CYCLE_COUNT,\n\t\t\t\t\t     V3D_PCTR_S0));\n\t\tV3D_CORE_WRITE(core, V3D_V4_PCTR_0_CLR, 1);\n\t\tV3D_CORE_WRITE(core, V3D_V4_PCTR_0_EN, 1);\n\t} else {\n\t\tV3D_CORE_WRITE(core, V3D_V3_PCTR_0_PCTRS0,\n\t\t\t       V3D_PCTR_CYCLE_COUNT);\n\t\tV3D_CORE_WRITE(core, V3D_V3_PCTR_0_CLR, 1);\n\t\tV3D_CORE_WRITE(core, V3D_V3_PCTR_0_EN,\n\t\t\t       V3D_V3_PCTR_0_EN_ENABLE |\n\t\t\t       1);\n\t}\n\tmsleep(measure_ms);\n\tcycles = V3D_CORE_READ(core, V3D_PCTR_0_PCTR0);\n\n\tseq_printf(m, \"cycles: %d (%d.%d Mhz)\\n\",\n\t\t   cycles,\n\t\t   cycles / (measure_ms * 1000),\n\t\t   (cycles / (measure_ms * 100)) % 10);\n\n\treturn 0;\n}\n\nstatic const struct drm_debugfs_info v3d_debugfs_list[] = {\n\t{\"v3d_ident\", v3d_v3d_debugfs_ident, 0},\n\t{\"v3d_regs\", v3d_v3d_debugfs_regs, 0},\n\t{\"measure_clock\", v3d_measure_clock, 0},\n\t{\"bo_stats\", v3d_debugfs_bo_stats, 0},\n};\n\nvoid\nv3d_debugfs_init(struct drm_minor *minor)\n{\n\tdrm_debugfs_add_files(minor->dev, v3d_debugfs_list, ARRAY_SIZE(v3d_debugfs_list));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}