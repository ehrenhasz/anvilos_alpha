{
  "module_name": "v3d_perfmon.c",
  "hash_id": "b261bde5a3b1f6d01422e6bd6d3a14dd006ab73beebb073c318b85ef0038635a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_perfmon.c",
  "human_readable_source": "\n \n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n\n#define V3D_PERFMONID_MIN\t1\n#define V3D_PERFMONID_MAX\tU32_MAX\n\nvoid v3d_perfmon_get(struct v3d_perfmon *perfmon)\n{\n\tif (perfmon)\n\t\trefcount_inc(&perfmon->refcnt);\n}\n\nvoid v3d_perfmon_put(struct v3d_perfmon *perfmon)\n{\n\tif (perfmon && refcount_dec_and_test(&perfmon->refcnt)) {\n\t\tmutex_destroy(&perfmon->lock);\n\t\tkfree(perfmon);\n\t}\n}\n\nvoid v3d_perfmon_start(struct v3d_dev *v3d, struct v3d_perfmon *perfmon)\n{\n\tunsigned int i;\n\tu32 mask;\n\tu8 ncounters;\n\n\tif (WARN_ON_ONCE(!perfmon || v3d->active_perfmon))\n\t\treturn;\n\n\tncounters = perfmon->ncounters;\n\tmask = GENMASK(ncounters - 1, 0);\n\n\tfor (i = 0; i < ncounters; i++) {\n\t\tu32 source = i / 4;\n\t\tu32 channel = V3D_SET_FIELD(perfmon->counters[i], V3D_PCTR_S0);\n\n\t\ti++;\n\t\tchannel |= V3D_SET_FIELD(i < ncounters ? perfmon->counters[i] : 0,\n\t\t\t\t\t V3D_PCTR_S1);\n\t\ti++;\n\t\tchannel |= V3D_SET_FIELD(i < ncounters ? perfmon->counters[i] : 0,\n\t\t\t\t\t V3D_PCTR_S2);\n\t\ti++;\n\t\tchannel |= V3D_SET_FIELD(i < ncounters ? perfmon->counters[i] : 0,\n\t\t\t\t\t V3D_PCTR_S3);\n\t\tV3D_CORE_WRITE(0, V3D_V4_PCTR_0_SRC_X(source), channel);\n\t}\n\n\tV3D_CORE_WRITE(0, V3D_V4_PCTR_0_CLR, mask);\n\tV3D_CORE_WRITE(0, V3D_PCTR_0_OVERFLOW, mask);\n\tV3D_CORE_WRITE(0, V3D_V4_PCTR_0_EN, mask);\n\n\tv3d->active_perfmon = perfmon;\n}\n\nvoid v3d_perfmon_stop(struct v3d_dev *v3d, struct v3d_perfmon *perfmon,\n\t\t      bool capture)\n{\n\tunsigned int i;\n\n\tif (!perfmon || !v3d->active_perfmon)\n\t\treturn;\n\n\tmutex_lock(&perfmon->lock);\n\tif (perfmon != v3d->active_perfmon) {\n\t\tmutex_unlock(&perfmon->lock);\n\t\treturn;\n\t}\n\n\tif (capture)\n\t\tfor (i = 0; i < perfmon->ncounters; i++)\n\t\t\tperfmon->values[i] += V3D_CORE_READ(0, V3D_PCTR_0_PCTRX(i));\n\n\tV3D_CORE_WRITE(0, V3D_V4_PCTR_0_EN, 0);\n\n\tv3d->active_perfmon = NULL;\n\tmutex_unlock(&perfmon->lock);\n}\n\nstruct v3d_perfmon *v3d_perfmon_find(struct v3d_file_priv *v3d_priv, int id)\n{\n\tstruct v3d_perfmon *perfmon;\n\n\tmutex_lock(&v3d_priv->perfmon.lock);\n\tperfmon = idr_find(&v3d_priv->perfmon.idr, id);\n\tv3d_perfmon_get(perfmon);\n\tmutex_unlock(&v3d_priv->perfmon.lock);\n\n\treturn perfmon;\n}\n\nvoid v3d_perfmon_open_file(struct v3d_file_priv *v3d_priv)\n{\n\tmutex_init(&v3d_priv->perfmon.lock);\n\tidr_init_base(&v3d_priv->perfmon.idr, 1);\n}\n\nstatic int v3d_perfmon_idr_del(int id, void *elem, void *data)\n{\n\tstruct v3d_perfmon *perfmon = elem;\n\n\tv3d_perfmon_put(perfmon);\n\n\treturn 0;\n}\n\nvoid v3d_perfmon_close_file(struct v3d_file_priv *v3d_priv)\n{\n\tmutex_lock(&v3d_priv->perfmon.lock);\n\tidr_for_each(&v3d_priv->perfmon.idr, v3d_perfmon_idr_del, NULL);\n\tidr_destroy(&v3d_priv->perfmon.idr);\n\tmutex_unlock(&v3d_priv->perfmon.lock);\n\tmutex_destroy(&v3d_priv->perfmon.lock);\n}\n\nint v3d_perfmon_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_perfmon_create *req = data;\n\tstruct v3d_perfmon *perfmon;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tif (req->ncounters > DRM_V3D_MAX_PERF_COUNTERS ||\n\t    !req->ncounters)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < req->ncounters; i++) {\n\t\tif (req->counters[i] >= V3D_PERFCNT_NUM)\n\t\t\treturn -EINVAL;\n\t}\n\n\tperfmon = kzalloc(struct_size(perfmon, values, req->ncounters),\n\t\t\t  GFP_KERNEL);\n\tif (!perfmon)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < req->ncounters; i++)\n\t\tperfmon->counters[i] = req->counters[i];\n\n\tperfmon->ncounters = req->ncounters;\n\n\trefcount_set(&perfmon->refcnt, 1);\n\tmutex_init(&perfmon->lock);\n\n\tmutex_lock(&v3d_priv->perfmon.lock);\n\tret = idr_alloc(&v3d_priv->perfmon.idr, perfmon, V3D_PERFMONID_MIN,\n\t\t\tV3D_PERFMONID_MAX, GFP_KERNEL);\n\tmutex_unlock(&v3d_priv->perfmon.lock);\n\n\tif (ret < 0) {\n\t\tmutex_destroy(&perfmon->lock);\n\t\tkfree(perfmon);\n\t\treturn ret;\n\t}\n\n\treq->id = ret;\n\n\treturn 0;\n}\n\nint v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv)\n{\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_perfmon_destroy *req = data;\n\tstruct v3d_perfmon *perfmon;\n\n\tmutex_lock(&v3d_priv->perfmon.lock);\n\tperfmon = idr_remove(&v3d_priv->perfmon.idr, req->id);\n\tmutex_unlock(&v3d_priv->perfmon.lock);\n\n\tif (!perfmon)\n\t\treturn -EINVAL;\n\n\tv3d_perfmon_put(perfmon);\n\n\treturn 0;\n}\n\nint v3d_perfmon_get_values_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_perfmon_get_values *req = data;\n\tstruct v3d_perfmon *perfmon;\n\tint ret = 0;\n\n\tif (req->pad != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&v3d_priv->perfmon.lock);\n\tperfmon = idr_find(&v3d_priv->perfmon.idr, req->id);\n\tv3d_perfmon_get(perfmon);\n\tmutex_unlock(&v3d_priv->perfmon.lock);\n\n\tif (!perfmon)\n\t\treturn -EINVAL;\n\n\tv3d_perfmon_stop(v3d, perfmon, true);\n\n\tif (copy_to_user(u64_to_user_ptr(req->values_ptr), perfmon->values,\n\t\t\t perfmon->ncounters * sizeof(u64)))\n\t\tret = -EFAULT;\n\n\tv3d_perfmon_put(perfmon);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}