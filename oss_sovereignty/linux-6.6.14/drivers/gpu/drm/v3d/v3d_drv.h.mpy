{
  "module_name": "v3d_drv.h",
  "hash_id": "733208e58685145bf80f7153b1140f36463db275c27dde1226497323ef6e79dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_drv.h",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/spinlock_types.h>\n#include <linux/workqueue.h>\n\n#include <drm/drm_encoder.h>\n#include <drm/drm_gem.h>\n#include <drm/drm_gem_shmem_helper.h>\n#include <drm/gpu_scheduler.h>\n\n#include \"uapi/drm/v3d_drm.h\"\n\nstruct clk;\nstruct platform_device;\nstruct reset_control;\n\n#define GMP_GRANULARITY (128 * 1024)\n\n#define V3D_MAX_QUEUES (V3D_CACHE_CLEAN + 1)\n\nstruct v3d_queue_state {\n\tstruct drm_gpu_scheduler sched;\n\n\tu64 fence_context;\n\tu64 emit_seqno;\n};\n\n \nstruct v3d_perfmon {\n\t \n\trefcount_t refcnt;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tu8 ncounters;\n\n\t \n\tu8 counters[DRM_V3D_MAX_PERF_COUNTERS];\n\n\t \n\tu64 values[];\n};\n\nstruct v3d_dev {\n\tstruct drm_device drm;\n\n\t \n\tint ver;\n\tbool single_irq_line;\n\n\tvoid __iomem *hub_regs;\n\tvoid __iomem *core_regs[3];\n\tvoid __iomem *bridge_regs;\n\tvoid __iomem *gca_regs;\n\tstruct clk *clk;\n\tstruct reset_control *reset;\n\n\t \n\tvolatile u32 *pt;\n\tdma_addr_t pt_paddr;\n\n\t \n\tvoid *mmu_scratch;\n\tdma_addr_t mmu_scratch_paddr;\n\t \n\tint va_width;\n\n\t \n\tu32 cores;\n\n\t \n\tstruct drm_mm mm;\n\tspinlock_t mm_lock;\n\n\tstruct work_struct overflow_mem_work;\n\n\tstruct v3d_bin_job *bin_job;\n\tstruct v3d_render_job *render_job;\n\tstruct v3d_tfu_job *tfu_job;\n\tstruct v3d_csd_job *csd_job;\n\n\tstruct v3d_queue_state queue[V3D_MAX_QUEUES];\n\n\t \n\tspinlock_t job_lock;\n\n\t \n\tstruct v3d_perfmon *active_perfmon;\n\n\t \n\tstruct mutex bo_lock;\n\n\t \n\tstruct mutex reset_lock;\n\n\t \n\tstruct mutex sched_lock;\n\n\t \n\tstruct mutex cache_clean_lock;\n\n\tstruct {\n\t\tu32 num_allocated;\n\t\tu32 pages_allocated;\n\t} bo_stats;\n};\n\nstatic inline struct v3d_dev *\nto_v3d_dev(struct drm_device *dev)\n{\n\treturn container_of(dev, struct v3d_dev, drm);\n}\n\nstatic inline bool\nv3d_has_csd(struct v3d_dev *v3d)\n{\n\treturn v3d->ver >= 41;\n}\n\n#define v3d_to_pdev(v3d) to_platform_device((v3d)->drm.dev)\n\n \nstruct v3d_file_priv {\n\tstruct v3d_dev *v3d;\n\n\tstruct {\n\t\tstruct idr idr;\n\t\tstruct mutex lock;\n\t} perfmon;\n\n\tstruct drm_sched_entity sched_entity[V3D_MAX_QUEUES];\n};\n\nstruct v3d_bo {\n\tstruct drm_gem_shmem_object base;\n\n\tstruct drm_mm_node node;\n\n\t \n\tstruct list_head unref_head;\n};\n\nstatic inline struct v3d_bo *\nto_v3d_bo(struct drm_gem_object *bo)\n{\n\treturn (struct v3d_bo *)bo;\n}\n\nstruct v3d_fence {\n\tstruct dma_fence base;\n\tstruct drm_device *dev;\n\t \n\tu64 seqno;\n\tenum v3d_queue queue;\n};\n\nstatic inline struct v3d_fence *\nto_v3d_fence(struct dma_fence *fence)\n{\n\treturn (struct v3d_fence *)fence;\n}\n\n#define V3D_READ(offset) readl(v3d->hub_regs + offset)\n#define V3D_WRITE(offset, val) writel(val, v3d->hub_regs + offset)\n\n#define V3D_BRIDGE_READ(offset) readl(v3d->bridge_regs + offset)\n#define V3D_BRIDGE_WRITE(offset, val) writel(val, v3d->bridge_regs + offset)\n\n#define V3D_GCA_READ(offset) readl(v3d->gca_regs + offset)\n#define V3D_GCA_WRITE(offset, val) writel(val, v3d->gca_regs + offset)\n\n#define V3D_CORE_READ(core, offset) readl(v3d->core_regs[core] + offset)\n#define V3D_CORE_WRITE(core, offset, val) writel(val, v3d->core_regs[core] + offset)\n\nstruct v3d_job {\n\tstruct drm_sched_job base;\n\n\tstruct kref refcount;\n\n\tstruct v3d_dev *v3d;\n\n\t \n\tstruct drm_gem_object **bo;\n\tu32 bo_count;\n\n\t \n\tstruct dma_fence *irq_fence;\n\n\t \n\tstruct dma_fence *done_fence;\n\n\t \n\tstruct v3d_perfmon *perfmon;\n\n\t \n\tvoid (*free)(struct kref *ref);\n};\n\nstruct v3d_bin_job {\n\tstruct v3d_job base;\n\n\t \n\tu32 start, end;\n\n\tu32 timedout_ctca, timedout_ctra;\n\n\t \n\tstruct v3d_render_job *render;\n\n\t \n\tu32 qma, qms, qts;\n};\n\nstruct v3d_render_job {\n\tstruct v3d_job base;\n\n\t \n\tu32 start, end;\n\n\tu32 timedout_ctca, timedout_ctra;\n\n\t \n\tstruct list_head unref_list;\n};\n\nstruct v3d_tfu_job {\n\tstruct v3d_job base;\n\n\tstruct drm_v3d_submit_tfu args;\n};\n\nstruct v3d_csd_job {\n\tstruct v3d_job base;\n\n\tu32 timedout_batches;\n\n\tstruct drm_v3d_submit_csd args;\n};\n\nstruct v3d_submit_outsync {\n\tstruct drm_syncobj *syncobj;\n};\n\nstruct v3d_submit_ext {\n\tu32 flags;\n\tu32 wait_stage;\n\n\tu32 in_sync_count;\n\tu64 in_syncs;\n\n\tu32 out_sync_count;\n\tstruct v3d_submit_outsync *out_syncs;\n};\n\n \n#define __wait_for(OP, COND, US, Wmin, Wmax) ({ \\\n\tconst ktime_t end__ = ktime_add_ns(ktime_get_raw(), 1000ll * (US)); \\\n\tlong wait__ = (Wmin);  \t\\\n\tint ret__;\t\t\t\t\t\t\t\\\n\tmight_sleep();\t\t\t\t\t\t\t\\\n\tfor (;;) {\t\t\t\t\t\t\t\\\n\t\tconst bool expired__ = ktime_after(ktime_get_raw(), end__); \\\n\t\tOP;\t\t\t\t\t\t\t\\\n\t\t \t\t\\\n\t\tbarrier();\t\t\t\t\t\t\\\n\t\tif (COND) {\t\t\t\t\t\t\\\n\t\t\tret__ = 0;\t\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (expired__) {\t\t\t\t\t\\\n\t\t\tret__ = -ETIMEDOUT;\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tusleep_range(wait__, wait__ * 2);\t\t\t\\\n\t\tif (wait__ < (Wmax))\t\t\t\t\t\\\n\t\t\twait__ <<= 1;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tret__;\t\t\t\t\t\t\t\t\\\n})\n\n#define _wait_for(COND, US, Wmin, Wmax)\t__wait_for(, (COND), (US), (Wmin), \\\n\t\t\t\t\t\t   (Wmax))\n#define wait_for(COND, MS)\t\t_wait_for((COND), (MS) * 1000, 10, 1000)\n\nstatic inline unsigned long nsecs_to_jiffies_timeout(const u64 n)\n{\n\t \n\tif ((NSEC_PER_SEC % HZ) != 0 &&\n\t    div_u64(n, NSEC_PER_SEC) >= MAX_JIFFY_OFFSET / HZ)\n\t\treturn MAX_JIFFY_OFFSET;\n\n\treturn min_t(u64, MAX_JIFFY_OFFSET, nsecs_to_jiffies64(n) + 1);\n}\n\n \nstruct drm_gem_object *v3d_create_object(struct drm_device *dev, size_t size);\nvoid v3d_free_object(struct drm_gem_object *gem_obj);\nstruct v3d_bo *v3d_bo_create(struct drm_device *dev, struct drm_file *file_priv,\n\t\t\t     size_t size);\nint v3d_create_bo_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv);\nint v3d_mmap_bo_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nint v3d_get_bo_offset_ioctl(struct drm_device *dev, void *data,\n\t\t\t    struct drm_file *file_priv);\nstruct drm_gem_object *v3d_prime_import_sg_table(struct drm_device *dev,\n\t\t\t\t\t\t struct dma_buf_attachment *attach,\n\t\t\t\t\t\t struct sg_table *sgt);\n\n \nvoid v3d_debugfs_init(struct drm_minor *minor);\n\n \nextern const struct dma_fence_ops v3d_fence_ops;\nstruct dma_fence *v3d_fence_create(struct v3d_dev *v3d, enum v3d_queue queue);\n\n \nint v3d_gem_init(struct drm_device *dev);\nvoid v3d_gem_destroy(struct drm_device *dev);\nint v3d_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv);\nint v3d_submit_tfu_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv);\nint v3d_submit_csd_ioctl(struct drm_device *dev, void *data,\n\t\t\t struct drm_file *file_priv);\nint v3d_wait_bo_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv);\nvoid v3d_job_cleanup(struct v3d_job *job);\nvoid v3d_job_put(struct v3d_job *job);\nvoid v3d_reset(struct v3d_dev *v3d);\nvoid v3d_invalidate_caches(struct v3d_dev *v3d);\nvoid v3d_clean_caches(struct v3d_dev *v3d);\n\n \nint v3d_irq_init(struct v3d_dev *v3d);\nvoid v3d_irq_enable(struct v3d_dev *v3d);\nvoid v3d_irq_disable(struct v3d_dev *v3d);\nvoid v3d_irq_reset(struct v3d_dev *v3d);\n\n \nint v3d_mmu_get_offset(struct drm_file *file_priv, struct v3d_bo *bo,\n\t\t       u32 *offset);\nint v3d_mmu_set_page_table(struct v3d_dev *v3d);\nvoid v3d_mmu_insert_ptes(struct v3d_bo *bo);\nvoid v3d_mmu_remove_ptes(struct v3d_bo *bo);\n\n \nint v3d_sched_init(struct v3d_dev *v3d);\nvoid v3d_sched_fini(struct v3d_dev *v3d);\n\n \nvoid v3d_perfmon_get(struct v3d_perfmon *perfmon);\nvoid v3d_perfmon_put(struct v3d_perfmon *perfmon);\nvoid v3d_perfmon_start(struct v3d_dev *v3d, struct v3d_perfmon *perfmon);\nvoid v3d_perfmon_stop(struct v3d_dev *v3d, struct v3d_perfmon *perfmon,\n\t\t      bool capture);\nstruct v3d_perfmon *v3d_perfmon_find(struct v3d_file_priv *v3d_priv, int id);\nvoid v3d_perfmon_open_file(struct v3d_file_priv *v3d_priv);\nvoid v3d_perfmon_close_file(struct v3d_file_priv *v3d_priv);\nint v3d_perfmon_create_ioctl(struct drm_device *dev, void *data,\n\t\t\t     struct drm_file *file_priv);\nint v3d_perfmon_destroy_ioctl(struct drm_device *dev, void *data,\n\t\t\t      struct drm_file *file_priv);\nint v3d_perfmon_get_values_ioctl(struct drm_device *dev, void *data,\n\t\t\t\t struct drm_file *file_priv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}