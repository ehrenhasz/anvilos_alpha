{
  "module_name": "v3d_gem.c",
  "hash_id": "f427cb84a51f49f3e968f841031b4ccc885c8839686e8e8adbdb00b3b54472e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_gem.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/sched/signal.h>\n#include <linux/uaccess.h>\n\n#include <drm/drm_managed.h>\n#include <drm/drm_syncobj.h>\n#include <uapi/drm/v3d_drm.h>\n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n#include \"v3d_trace.h\"\n\nstatic void\nv3d_init_core(struct v3d_dev *v3d, int core)\n{\n\t \n\tif (v3d->ver < 40)\n\t\tV3D_CORE_WRITE(core, V3D_CTL_MISCCFG, V3D_MISCCFG_OVRTMUOUT);\n\n\t \n\tV3D_CORE_WRITE(core, V3D_CTL_L2TFLSTA, 0);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TFLEND, ~0);\n}\n\n \nstatic void\nv3d_init_hw_state(struct v3d_dev *v3d)\n{\n\tv3d_init_core(v3d, 0);\n}\n\nstatic void\nv3d_idle_axi(struct v3d_dev *v3d, int core)\n{\n\tV3D_CORE_WRITE(core, V3D_GMP_CFG, V3D_GMP_CFG_STOP_REQ);\n\n\tif (wait_for((V3D_CORE_READ(core, V3D_GMP_STATUS) &\n\t\t      (V3D_GMP_STATUS_RD_COUNT_MASK |\n\t\t       V3D_GMP_STATUS_WR_COUNT_MASK |\n\t\t       V3D_GMP_STATUS_CFG_BUSY)) == 0, 100)) {\n\t\tDRM_ERROR(\"Failed to wait for safe GMP shutdown\\n\");\n\t}\n}\n\nstatic void\nv3d_idle_gca(struct v3d_dev *v3d)\n{\n\tif (v3d->ver >= 41)\n\t\treturn;\n\n\tV3D_GCA_WRITE(V3D_GCA_SAFE_SHUTDOWN, V3D_GCA_SAFE_SHUTDOWN_EN);\n\n\tif (wait_for((V3D_GCA_READ(V3D_GCA_SAFE_SHUTDOWN_ACK) &\n\t\t      V3D_GCA_SAFE_SHUTDOWN_ACK_ACKED) ==\n\t\t     V3D_GCA_SAFE_SHUTDOWN_ACK_ACKED, 100)) {\n\t\tDRM_ERROR(\"Failed to wait for safe GCA shutdown\\n\");\n\t}\n}\n\nstatic void\nv3d_reset_by_bridge(struct v3d_dev *v3d)\n{\n\tint version = V3D_BRIDGE_READ(V3D_TOP_GR_BRIDGE_REVISION);\n\n\tif (V3D_GET_FIELD(version, V3D_TOP_GR_BRIDGE_MAJOR) == 2) {\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_0_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_0, 0);\n\n\t\t \n\t\tV3D_WRITE(V3D_HUB_AXICFG, V3D_HUB_AXICFG_MAX_LEN_MASK);\n\t} else {\n\t\tWARN_ON_ONCE(V3D_GET_FIELD(version,\n\t\t\t\t\t   V3D_TOP_GR_BRIDGE_MAJOR) != 7);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1,\n\t\t\t\t V3D_TOP_GR_BRIDGE_SW_INIT_1_V3D_CLK_108_SW_INIT);\n\t\tV3D_BRIDGE_WRITE(V3D_TOP_GR_BRIDGE_SW_INIT_1, 0);\n\t}\n}\n\nstatic void\nv3d_reset_v3d(struct v3d_dev *v3d)\n{\n\tif (v3d->reset)\n\t\treset_control_reset(v3d->reset);\n\telse\n\t\tv3d_reset_by_bridge(v3d);\n\n\tv3d_init_hw_state(v3d);\n}\n\nvoid\nv3d_reset(struct v3d_dev *v3d)\n{\n\tstruct drm_device *dev = &v3d->drm;\n\n\tDRM_DEV_ERROR(dev->dev, \"Resetting GPU for hang.\\n\");\n\tDRM_DEV_ERROR(dev->dev, \"V3D_ERR_STAT: 0x%08x\\n\",\n\t\t      V3D_CORE_READ(0, V3D_ERR_STAT));\n\ttrace_v3d_reset_begin(dev);\n\n\t \n\tif (false)\n\t\tv3d_idle_axi(v3d, 0);\n\n\tv3d_idle_gca(v3d);\n\tv3d_reset_v3d(v3d);\n\n\tv3d_mmu_set_page_table(v3d);\n\tv3d_irq_reset(v3d);\n\n\tv3d_perfmon_stop(v3d, v3d->active_perfmon, false);\n\n\ttrace_v3d_reset_end(dev);\n}\n\nstatic void\nv3d_flush_l3(struct v3d_dev *v3d)\n{\n\tif (v3d->ver < 41) {\n\t\tu32 gca_ctrl = V3D_GCA_READ(V3D_GCA_CACHE_CTRL);\n\n\t\tV3D_GCA_WRITE(V3D_GCA_CACHE_CTRL,\n\t\t\t      gca_ctrl | V3D_GCA_CACHE_CTRL_FLUSH);\n\n\t\tif (v3d->ver < 33) {\n\t\t\tV3D_GCA_WRITE(V3D_GCA_CACHE_CTRL,\n\t\t\t\t      gca_ctrl & ~V3D_GCA_CACHE_CTRL_FLUSH);\n\t\t}\n\t}\n}\n\n \nstatic void\nv3d_invalidate_l2c(struct v3d_dev *v3d, int core)\n{\n\tif (v3d->ver > 32)\n\t\treturn;\n\n\tV3D_CORE_WRITE(core, V3D_CTL_L2CACTL,\n\t\t       V3D_L2CACTL_L2CCLR |\n\t\t       V3D_L2CACTL_L2CENA);\n}\n\n \nstatic void\nv3d_flush_l2t(struct v3d_dev *v3d, int core)\n{\n\t \n\tmutex_lock(&v3d->cache_clean_lock);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL,\n\t\t       V3D_L2TCACTL_L2TFLS |\n\t\t       V3D_SET_FIELD(V3D_L2TCACTL_FLM_FLUSH, V3D_L2TCACTL_FLM));\n\tmutex_unlock(&v3d->cache_clean_lock);\n}\n\n \nvoid\nv3d_clean_caches(struct v3d_dev *v3d)\n{\n\tstruct drm_device *dev = &v3d->drm;\n\tint core = 0;\n\n\ttrace_v3d_cache_clean_begin(dev);\n\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL, V3D_L2TCACTL_TMUWCF);\n\tif (wait_for(!(V3D_CORE_READ(core, V3D_CTL_L2TCACTL) &\n\t\t       V3D_L2TCACTL_TMUWCF), 100)) {\n\t\tDRM_ERROR(\"Timeout waiting for TMU write combiner flush\\n\");\n\t}\n\n\tmutex_lock(&v3d->cache_clean_lock);\n\tV3D_CORE_WRITE(core, V3D_CTL_L2TCACTL,\n\t\t       V3D_L2TCACTL_L2TFLS |\n\t\t       V3D_SET_FIELD(V3D_L2TCACTL_FLM_CLEAN, V3D_L2TCACTL_FLM));\n\n\tif (wait_for(!(V3D_CORE_READ(core, V3D_CTL_L2TCACTL) &\n\t\t       V3D_L2TCACTL_L2TFLS), 100)) {\n\t\tDRM_ERROR(\"Timeout waiting for L2T clean\\n\");\n\t}\n\n\tmutex_unlock(&v3d->cache_clean_lock);\n\n\ttrace_v3d_cache_clean_end(dev);\n}\n\n \nstatic void\nv3d_invalidate_slices(struct v3d_dev *v3d, int core)\n{\n\tV3D_CORE_WRITE(core, V3D_CTL_SLCACTL,\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_TVCCS) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_TDCCS) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_UCC) |\n\t\t       V3D_SET_FIELD(0xf, V3D_SLCACTL_ICC));\n}\n\nvoid\nv3d_invalidate_caches(struct v3d_dev *v3d)\n{\n\t \n\tv3d_flush_l3(v3d);\n\tv3d_invalidate_l2c(v3d, 0);\n\tv3d_flush_l2t(v3d, 0);\n\tv3d_invalidate_slices(v3d, 0);\n}\n\n \nstatic int\nv3d_lock_bo_reservations(struct v3d_job *job,\n\t\t\t struct ww_acquire_ctx *acquire_ctx)\n{\n\tint i, ret;\n\n\tret = drm_gem_lock_reservations(job->bo, job->bo_count, acquire_ctx);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\tret = dma_resv_reserve_fences(job->bo[i]->resv, 1);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = drm_sched_job_add_implicit_dependencies(&job->base,\n\t\t\t\t\t\t\t      job->bo[i], true);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdrm_gem_unlock_reservations(job->bo, job->bo_count, acquire_ctx);\n\treturn ret;\n}\n\n \nstatic int\nv3d_lookup_bos(struct drm_device *dev,\n\t       struct drm_file *file_priv,\n\t       struct v3d_job *job,\n\t       u64 bo_handles,\n\t       u32 bo_count)\n{\n\tjob->bo_count = bo_count;\n\n\tif (!job->bo_count) {\n\t\t \n\t\tDRM_DEBUG(\"Rendering requires BOs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn drm_gem_objects_lookup(file_priv,\n\t\t\t\t      (void __user *)(uintptr_t)bo_handles,\n\t\t\t\t      job->bo_count, &job->bo);\n}\n\nstatic void\nv3d_job_free(struct kref *ref)\n{\n\tstruct v3d_job *job = container_of(ref, struct v3d_job, refcount);\n\tint i;\n\n\tif (job->bo) {\n\t\tfor (i = 0; i < job->bo_count; i++)\n\t\t\tdrm_gem_object_put(job->bo[i]);\n\t\tkvfree(job->bo);\n\t}\n\n\tdma_fence_put(job->irq_fence);\n\tdma_fence_put(job->done_fence);\n\n\tif (job->perfmon)\n\t\tv3d_perfmon_put(job->perfmon);\n\n\tkfree(job);\n}\n\nstatic void\nv3d_render_job_free(struct kref *ref)\n{\n\tstruct v3d_render_job *job = container_of(ref, struct v3d_render_job,\n\t\t\t\t\t\t  base.refcount);\n\tstruct v3d_bo *bo, *save;\n\n\tlist_for_each_entry_safe(bo, save, &job->unref_list, unref_head) {\n\t\tdrm_gem_object_put(&bo->base.base);\n\t}\n\n\tv3d_job_free(ref);\n}\n\nvoid v3d_job_cleanup(struct v3d_job *job)\n{\n\tif (!job)\n\t\treturn;\n\n\tdrm_sched_job_cleanup(&job->base);\n\tv3d_job_put(job);\n}\n\nvoid v3d_job_put(struct v3d_job *job)\n{\n\tkref_put(&job->refcount, job->free);\n}\n\nint\nv3d_wait_bo_ioctl(struct drm_device *dev, void *data,\n\t\t  struct drm_file *file_priv)\n{\n\tint ret;\n\tstruct drm_v3d_wait_bo *args = data;\n\tktime_t start = ktime_get();\n\tu64 delta_ns;\n\tunsigned long timeout_jiffies =\n\t\tnsecs_to_jiffies_timeout(args->timeout_ns);\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\tret = drm_gem_dma_resv_wait(file_priv, args->handle,\n\t\t\t\t    true, timeout_jiffies);\n\n\t \n\tdelta_ns = ktime_to_ns(ktime_sub(ktime_get(), start));\n\tif (delta_ns < args->timeout_ns)\n\t\targs->timeout_ns -= delta_ns;\n\telse\n\t\targs->timeout_ns = 0;\n\n\t \n\tif (ret == -ETIME && args->timeout_ns)\n\t\tret = -EAGAIN;\n\n\treturn ret;\n}\n\nstatic int\nv3d_job_init(struct v3d_dev *v3d, struct drm_file *file_priv,\n\t     void **container, size_t size, void (*free)(struct kref *ref),\n\t     u32 in_sync, struct v3d_submit_ext *se, enum v3d_queue queue)\n{\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct v3d_job *job;\n\tbool has_multisync = se && (se->flags & DRM_V3D_EXT_ID_MULTI_SYNC);\n\tint ret, i;\n\n\t*container = kcalloc(1, size, GFP_KERNEL);\n\tif (!*container) {\n\t\tDRM_ERROR(\"Cannot allocate memory for v3d job.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tjob = *container;\n\tjob->v3d = v3d;\n\tjob->free = free;\n\n\tret = drm_sched_job_init(&job->base, &v3d_priv->sched_entity[queue],\n\t\t\t\t v3d_priv);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (has_multisync) {\n\t\tif (se->in_sync_count && se->wait_stage == queue) {\n\t\t\tstruct drm_v3d_sem __user *handle = u64_to_user_ptr(se->in_syncs);\n\n\t\t\tfor (i = 0; i < se->in_sync_count; i++) {\n\t\t\t\tstruct drm_v3d_sem in;\n\n\t\t\t\tif (copy_from_user(&in, handle++, sizeof(in))) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tDRM_DEBUG(\"Failed to copy wait dep handle.\\n\");\n\t\t\t\t\tgoto fail_deps;\n\t\t\t\t}\n\t\t\t\tret = drm_sched_job_add_syncobj_dependency(&job->base, file_priv, in.handle, 0);\n\n\t\t\t\t\n\t\t\t\tif (ret && ret != -ENOENT)\n\t\t\t\t\tgoto fail_deps;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = drm_sched_job_add_syncobj_dependency(&job->base, file_priv, in_sync, 0);\n\n\t\t\n\t\tif (ret && ret != -ENOENT)\n\t\t\tgoto fail_deps;\n\t}\n\n\tkref_init(&job->refcount);\n\n\treturn 0;\n\nfail_deps:\n\tdrm_sched_job_cleanup(&job->base);\nfail:\n\tkfree(*container);\n\t*container = NULL;\n\n\treturn ret;\n}\n\nstatic void\nv3d_push_job(struct v3d_job *job)\n{\n\tdrm_sched_job_arm(&job->base);\n\n\tjob->done_fence = dma_fence_get(&job->base.s_fence->finished);\n\n\t \n\tkref_get(&job->refcount);\n\n\tdrm_sched_entity_push_job(&job->base);\n}\n\nstatic void\nv3d_attach_fences_and_unlock_reservation(struct drm_file *file_priv,\n\t\t\t\t\t struct v3d_job *job,\n\t\t\t\t\t struct ww_acquire_ctx *acquire_ctx,\n\t\t\t\t\t u32 out_sync,\n\t\t\t\t\t struct v3d_submit_ext *se,\n\t\t\t\t\t struct dma_fence *done_fence)\n{\n\tstruct drm_syncobj *sync_out;\n\tbool has_multisync = se && (se->flags & DRM_V3D_EXT_ID_MULTI_SYNC);\n\tint i;\n\n\tfor (i = 0; i < job->bo_count; i++) {\n\t\t \n\t\tdma_resv_add_fence(job->bo[i]->resv, job->done_fence,\n\t\t\t\t   DMA_RESV_USAGE_WRITE);\n\t}\n\n\tdrm_gem_unlock_reservations(job->bo, job->bo_count, acquire_ctx);\n\n\t \n\t \n\tif (!has_multisync) {\n\t\tsync_out = drm_syncobj_find(file_priv, out_sync);\n\t\tif (sync_out) {\n\t\t\tdrm_syncobj_replace_fence(sync_out, done_fence);\n\t\t\tdrm_syncobj_put(sync_out);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (se->out_sync_count) {\n\t\tfor (i = 0; i < se->out_sync_count; i++) {\n\t\t\tdrm_syncobj_replace_fence(se->out_syncs[i].syncobj,\n\t\t\t\t\t\t  done_fence);\n\t\t\tdrm_syncobj_put(se->out_syncs[i].syncobj);\n\t\t}\n\t\tkvfree(se->out_syncs);\n\t}\n}\n\nstatic void\nv3d_put_multisync_post_deps(struct v3d_submit_ext *se)\n{\n\tunsigned int i;\n\n\tif (!(se && se->out_sync_count))\n\t\treturn;\n\n\tfor (i = 0; i < se->out_sync_count; i++)\n\t\tdrm_syncobj_put(se->out_syncs[i].syncobj);\n\tkvfree(se->out_syncs);\n}\n\nstatic int\nv3d_get_multisync_post_deps(struct drm_file *file_priv,\n\t\t\t    struct v3d_submit_ext *se,\n\t\t\t    u32 count, u64 handles)\n{\n\tstruct drm_v3d_sem __user *post_deps;\n\tint i, ret;\n\n\tif (!count)\n\t\treturn 0;\n\n\tse->out_syncs = (struct v3d_submit_outsync *)\n\t\t\tkvmalloc_array(count,\n\t\t\t\t       sizeof(struct v3d_submit_outsync),\n\t\t\t\t       GFP_KERNEL);\n\tif (!se->out_syncs)\n\t\treturn -ENOMEM;\n\n\tpost_deps = u64_to_user_ptr(handles);\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct drm_v3d_sem out;\n\n\t\tif (copy_from_user(&out, post_deps++, sizeof(out))) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"Failed to copy post dep handles\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tse->out_syncs[i].syncobj = drm_syncobj_find(file_priv,\n\t\t\t\t\t\t\t    out.handle);\n\t\tif (!se->out_syncs[i].syncobj) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tse->out_sync_count = count;\n\n\treturn 0;\n\nfail:\n\tfor (i--; i >= 0; i--)\n\t\tdrm_syncobj_put(se->out_syncs[i].syncobj);\n\tkvfree(se->out_syncs);\n\n\treturn ret;\n}\n\n \nstatic int\nv3d_get_multisync_submit_deps(struct drm_file *file_priv,\n\t\t\t      struct drm_v3d_extension __user *ext,\n\t\t\t      void *data)\n{\n\tstruct drm_v3d_multi_sync multisync;\n\tstruct v3d_submit_ext *se = data;\n\tint ret;\n\n\tif (copy_from_user(&multisync, ext, sizeof(multisync)))\n\t\treturn -EFAULT;\n\n\tif (multisync.pad)\n\t\treturn -EINVAL;\n\n\tret = v3d_get_multisync_post_deps(file_priv, data, multisync.out_sync_count,\n\t\t\t\t\t  multisync.out_syncs);\n\tif (ret)\n\t\treturn ret;\n\n\tse->in_sync_count = multisync.in_sync_count;\n\tse->in_syncs = multisync.in_syncs;\n\tse->flags |= DRM_V3D_EXT_ID_MULTI_SYNC;\n\tse->wait_stage = multisync.wait_stage;\n\n\treturn 0;\n}\n\n \nstatic int\nv3d_get_extensions(struct drm_file *file_priv,\n\t\t   u64 ext_handles,\n\t\t   void *data)\n{\n\tstruct drm_v3d_extension __user *user_ext;\n\tint ret;\n\n\tuser_ext = u64_to_user_ptr(ext_handles);\n\twhile (user_ext) {\n\t\tstruct drm_v3d_extension ext;\n\n\t\tif (copy_from_user(&ext, user_ext, sizeof(ext))) {\n\t\t\tDRM_DEBUG(\"Failed to copy submit extension\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (ext.id) {\n\t\tcase DRM_V3D_EXT_ID_MULTI_SYNC:\n\t\t\tret = v3d_get_multisync_submit_deps(file_priv, user_ext, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tDRM_DEBUG_DRIVER(\"Unknown extension id: %d\\n\", ext.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tuser_ext = u64_to_user_ptr(ext.next);\n\t}\n\n\treturn 0;\n}\n\n \nint\nv3d_submit_cl_ioctl(struct drm_device *dev, void *data,\n\t\t    struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_cl *args = data;\n\tstruct v3d_submit_ext se = {0};\n\tstruct v3d_bin_job *bin = NULL;\n\tstruct v3d_render_job *render = NULL;\n\tstruct v3d_job *clean_job = NULL;\n\tstruct v3d_job *last_job;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_cl_ioctl(&v3d->drm, args->rcl_start, args->rcl_end);\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tif (args->flags &&\n\t    args->flags & ~(DRM_V3D_SUBMIT_CL_FLUSH_CACHE |\n\t\t\t    DRM_V3D_SUBMIT_EXTENSION)) {\n\t\tDRM_INFO(\"invalid flags: %d\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->flags & DRM_V3D_SUBMIT_EXTENSION) {\n\t\tret = v3d_get_extensions(file_priv, args->extensions, &se);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG(\"Failed to get extensions.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = v3d_job_init(v3d, file_priv, (void *)&render, sizeof(*render),\n\t\t\t   v3d_render_job_free, args->in_sync_rcl, &se, V3D_RENDER);\n\tif (ret)\n\t\tgoto fail;\n\n\trender->start = args->rcl_start;\n\trender->end = args->rcl_end;\n\tINIT_LIST_HEAD(&render->unref_list);\n\n\tif (args->bcl_start != args->bcl_end) {\n\t\tret = v3d_job_init(v3d, file_priv, (void *)&bin, sizeof(*bin),\n\t\t\t\t   v3d_job_free, args->in_sync_bcl, &se, V3D_BIN);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tbin->start = args->bcl_start;\n\t\tbin->end = args->bcl_end;\n\t\tbin->qma = args->qma;\n\t\tbin->qms = args->qms;\n\t\tbin->qts = args->qts;\n\t\tbin->render = render;\n\t}\n\n\tif (args->flags & DRM_V3D_SUBMIT_CL_FLUSH_CACHE) {\n\t\tret = v3d_job_init(v3d, file_priv, (void *)&clean_job, sizeof(*clean_job),\n\t\t\t\t   v3d_job_free, 0, NULL, V3D_CACHE_CLEAN);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tlast_job = clean_job;\n\t} else {\n\t\tlast_job = &render->base;\n\t}\n\n\tret = v3d_lookup_bos(dev, file_priv, last_job,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(last_job, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (args->perfmon_id) {\n\t\trender->base.perfmon = v3d_perfmon_find(v3d_priv,\n\t\t\t\t\t\t\targs->perfmon_id);\n\n\t\tif (!render->base.perfmon) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto fail_perfmon;\n\t\t}\n\t}\n\n\tmutex_lock(&v3d->sched_lock);\n\tif (bin) {\n\t\tbin->base.perfmon = render->base.perfmon;\n\t\tv3d_perfmon_get(bin->base.perfmon);\n\t\tv3d_push_job(&bin->base);\n\n\t\tret = drm_sched_job_add_dependency(&render->base.base,\n\t\t\t\t\t\t   dma_fence_get(bin->base.done_fence));\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\t}\n\n\tv3d_push_job(&render->base);\n\n\tif (clean_job) {\n\t\tstruct dma_fence *render_fence =\n\t\t\tdma_fence_get(render->base.done_fence);\n\t\tret = drm_sched_job_add_dependency(&clean_job->base,\n\t\t\t\t\t\t   render_fence);\n\t\tif (ret)\n\t\t\tgoto fail_unreserve;\n\t\tclean_job->perfmon = render->base.perfmon;\n\t\tv3d_perfmon_get(clean_job->perfmon);\n\t\tv3d_push_job(clean_job);\n\t}\n\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t last_job,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t &se,\n\t\t\t\t\t\t last_job->done_fence);\n\n\tif (bin)\n\t\tv3d_job_put(&bin->base);\n\tv3d_job_put(&render->base);\n\tif (clean_job)\n\t\tv3d_job_put(clean_job);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\nfail_perfmon:\n\tdrm_gem_unlock_reservations(last_job->bo,\n\t\t\t\t    last_job->bo_count, &acquire_ctx);\nfail:\n\tv3d_job_cleanup((void *)bin);\n\tv3d_job_cleanup((void *)render);\n\tv3d_job_cleanup(clean_job);\n\tv3d_put_multisync_post_deps(&se);\n\n\treturn ret;\n}\n\n \nint\nv3d_submit_tfu_ioctl(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct drm_v3d_submit_tfu *args = data;\n\tstruct v3d_submit_ext se = {0};\n\tstruct v3d_tfu_job *job = NULL;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret = 0;\n\n\ttrace_v3d_submit_tfu_ioctl(&v3d->drm, args->iia);\n\n\tif (args->flags && !(args->flags & DRM_V3D_SUBMIT_EXTENSION)) {\n\t\tDRM_DEBUG(\"invalid flags: %d\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->flags & DRM_V3D_SUBMIT_EXTENSION) {\n\t\tret = v3d_get_extensions(file_priv, args->extensions, &se);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG(\"Failed to get extensions.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = v3d_job_init(v3d, file_priv, (void *)&job, sizeof(*job),\n\t\t\t   v3d_job_free, args->in_sync, &se, V3D_TFU);\n\tif (ret)\n\t\tgoto fail;\n\n\tjob->base.bo = kcalloc(ARRAY_SIZE(args->bo_handles),\n\t\t\t       sizeof(*job->base.bo), GFP_KERNEL);\n\tif (!job->base.bo) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tjob->args = *args;\n\n\tfor (job->base.bo_count = 0;\n\t     job->base.bo_count < ARRAY_SIZE(args->bo_handles);\n\t     job->base.bo_count++) {\n\t\tstruct drm_gem_object *bo;\n\n\t\tif (!args->bo_handles[job->base.bo_count])\n\t\t\tbreak;\n\n\t\tbo = drm_gem_object_lookup(file_priv, args->bo_handles[job->base.bo_count]);\n\t\tif (!bo) {\n\t\t\tDRM_DEBUG(\"Failed to look up GEM BO %d: %d\\n\",\n\t\t\t\t  job->base.bo_count,\n\t\t\t\t  args->bo_handles[job->base.bo_count]);\n\t\t\tret = -ENOENT;\n\t\t\tgoto fail;\n\t\t}\n\t\tjob->base.bo[job->base.bo_count] = bo;\n\t}\n\n\tret = v3d_lock_bo_reservations(&job->base, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&v3d->sched_lock);\n\tv3d_push_job(&job->base);\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t &job->base, &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t &se,\n\t\t\t\t\t\t job->base.done_fence);\n\n\tv3d_job_put(&job->base);\n\n\treturn 0;\n\nfail:\n\tv3d_job_cleanup((void *)job);\n\tv3d_put_multisync_post_deps(&se);\n\n\treturn ret;\n}\n\n \nint\nv3d_submit_csd_ioctl(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv = file_priv->driver_priv;\n\tstruct drm_v3d_submit_csd *args = data;\n\tstruct v3d_submit_ext se = {0};\n\tstruct v3d_csd_job *job = NULL;\n\tstruct v3d_job *clean_job = NULL;\n\tstruct ww_acquire_ctx acquire_ctx;\n\tint ret;\n\n\ttrace_v3d_submit_csd_ioctl(&v3d->drm, args->cfg[5], args->cfg[6]);\n\n\tif (args->pad)\n\t\treturn -EINVAL;\n\n\tif (!v3d_has_csd(v3d)) {\n\t\tDRM_DEBUG(\"Attempting CSD submit on non-CSD hardware\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->flags && !(args->flags & DRM_V3D_SUBMIT_EXTENSION)) {\n\t\tDRM_INFO(\"invalid flags: %d\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (args->flags & DRM_V3D_SUBMIT_EXTENSION) {\n\t\tret = v3d_get_extensions(file_priv, args->extensions, &se);\n\t\tif (ret) {\n\t\t\tDRM_DEBUG(\"Failed to get extensions.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = v3d_job_init(v3d, file_priv, (void *)&job, sizeof(*job),\n\t\t\t   v3d_job_free, args->in_sync, &se, V3D_CSD);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_job_init(v3d, file_priv, (void *)&clean_job, sizeof(*clean_job),\n\t\t\t   v3d_job_free, 0, NULL, V3D_CACHE_CLEAN);\n\tif (ret)\n\t\tgoto fail;\n\n\tjob->args = *args;\n\n\tret = v3d_lookup_bos(dev, file_priv, clean_job,\n\t\t\t     args->bo_handles, args->bo_handle_count);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = v3d_lock_bo_reservations(clean_job, &acquire_ctx);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (args->perfmon_id) {\n\t\tjob->base.perfmon = v3d_perfmon_find(v3d_priv,\n\t\t\t\t\t\t     args->perfmon_id);\n\t\tif (!job->base.perfmon) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto fail_perfmon;\n\t\t}\n\t}\n\n\tmutex_lock(&v3d->sched_lock);\n\tv3d_push_job(&job->base);\n\n\tret = drm_sched_job_add_dependency(&clean_job->base,\n\t\t\t\t\t   dma_fence_get(job->base.done_fence));\n\tif (ret)\n\t\tgoto fail_unreserve;\n\n\tv3d_push_job(clean_job);\n\tmutex_unlock(&v3d->sched_lock);\n\n\tv3d_attach_fences_and_unlock_reservation(file_priv,\n\t\t\t\t\t\t clean_job,\n\t\t\t\t\t\t &acquire_ctx,\n\t\t\t\t\t\t args->out_sync,\n\t\t\t\t\t\t &se,\n\t\t\t\t\t\t clean_job->done_fence);\n\n\tv3d_job_put(&job->base);\n\tv3d_job_put(clean_job);\n\n\treturn 0;\n\nfail_unreserve:\n\tmutex_unlock(&v3d->sched_lock);\nfail_perfmon:\n\tdrm_gem_unlock_reservations(clean_job->bo, clean_job->bo_count,\n\t\t\t\t    &acquire_ctx);\nfail:\n\tv3d_job_cleanup((void *)job);\n\tv3d_job_cleanup(clean_job);\n\tv3d_put_multisync_post_deps(&se);\n\n\treturn ret;\n}\n\nint\nv3d_gem_init(struct drm_device *dev)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tu32 pt_size = 4096 * 1024;\n\tint ret, i;\n\n\tfor (i = 0; i < V3D_MAX_QUEUES; i++)\n\t\tv3d->queue[i].fence_context = dma_fence_context_alloc(1);\n\n\tspin_lock_init(&v3d->mm_lock);\n\tspin_lock_init(&v3d->job_lock);\n\tret = drmm_mutex_init(dev, &v3d->bo_lock);\n\tif (ret)\n\t\treturn ret;\n\tret = drmm_mutex_init(dev, &v3d->reset_lock);\n\tif (ret)\n\t\treturn ret;\n\tret = drmm_mutex_init(dev, &v3d->sched_lock);\n\tif (ret)\n\t\treturn ret;\n\tret = drmm_mutex_init(dev, &v3d->cache_clean_lock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdrm_mm_init(&v3d->mm, 1, pt_size / sizeof(u32) - 1);\n\n\tv3d->pt = dma_alloc_wc(v3d->drm.dev, pt_size,\n\t\t\t       &v3d->pt_paddr,\n\t\t\t       GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\tif (!v3d->pt) {\n\t\tdrm_mm_takedown(&v3d->mm);\n\t\tdev_err(v3d->drm.dev,\n\t\t\t\"Failed to allocate page tables. Please ensure you have DMA enabled.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tv3d_init_hw_state(v3d);\n\tv3d_mmu_set_page_table(v3d);\n\n\tret = v3d_sched_init(v3d);\n\tif (ret) {\n\t\tdrm_mm_takedown(&v3d->mm);\n\t\tdma_free_coherent(v3d->drm.dev, 4096 * 1024, (void *)v3d->pt,\n\t\t\t\t  v3d->pt_paddr);\n\t}\n\n\treturn 0;\n}\n\nvoid\nv3d_gem_destroy(struct drm_device *dev)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\n\tv3d_sched_fini(v3d);\n\n\t \n\tWARN_ON(v3d->bin_job);\n\tWARN_ON(v3d->render_job);\n\n\tdrm_mm_takedown(&v3d->mm);\n\n\tdma_free_coherent(v3d->drm.dev, 4096 * 1024, (void *)v3d->pt,\n\t\t\t  v3d->pt_paddr);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}