{
  "module_name": "v3d_drv.c",
  "hash_id": "adc9e4a65f83c4804d679e10ff918712b9a92adfb4858690121e3d8715f2d902",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include <drm/drm_drv.h>\n#include <drm/drm_managed.h>\n#include <uapi/drm/v3d_drm.h>\n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n\n#define DRIVER_NAME \"v3d\"\n#define DRIVER_DESC \"Broadcom V3D graphics\"\n#define DRIVER_DATE \"20180419\"\n#define DRIVER_MAJOR 1\n#define DRIVER_MINOR 0\n#define DRIVER_PATCHLEVEL 0\n\nstatic int v3d_get_param_ioctl(struct drm_device *dev, void *data,\n\t\t\t       struct drm_file *file_priv)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct drm_v3d_get_param *args = data;\n\tstatic const u32 reg_map[] = {\n\t\t[DRM_V3D_PARAM_V3D_UIFCFG] = V3D_HUB_UIFCFG,\n\t\t[DRM_V3D_PARAM_V3D_HUB_IDENT1] = V3D_HUB_IDENT1,\n\t\t[DRM_V3D_PARAM_V3D_HUB_IDENT2] = V3D_HUB_IDENT2,\n\t\t[DRM_V3D_PARAM_V3D_HUB_IDENT3] = V3D_HUB_IDENT3,\n\t\t[DRM_V3D_PARAM_V3D_CORE0_IDENT0] = V3D_CTL_IDENT0,\n\t\t[DRM_V3D_PARAM_V3D_CORE0_IDENT1] = V3D_CTL_IDENT1,\n\t\t[DRM_V3D_PARAM_V3D_CORE0_IDENT2] = V3D_CTL_IDENT2,\n\t};\n\n\tif (args->pad != 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (args->param < ARRAY_SIZE(reg_map) &&\n\t    (reg_map[args->param] ||\n\t     args->param == DRM_V3D_PARAM_V3D_CORE0_IDENT0)) {\n\t\tu32 offset = reg_map[args->param];\n\n\t\tif (args->value != 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (args->param >= DRM_V3D_PARAM_V3D_CORE0_IDENT0 &&\n\t\t    args->param <= DRM_V3D_PARAM_V3D_CORE0_IDENT2) {\n\t\t\targs->value = V3D_CORE_READ(0, offset);\n\t\t} else {\n\t\t\targs->value = V3D_READ(offset);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (args->param) {\n\tcase DRM_V3D_PARAM_SUPPORTS_TFU:\n\t\targs->value = 1;\n\t\treturn 0;\n\tcase DRM_V3D_PARAM_SUPPORTS_CSD:\n\t\targs->value = v3d_has_csd(v3d);\n\t\treturn 0;\n\tcase DRM_V3D_PARAM_SUPPORTS_CACHE_FLUSH:\n\t\targs->value = 1;\n\t\treturn 0;\n\tcase DRM_V3D_PARAM_SUPPORTS_PERFMON:\n\t\targs->value = (v3d->ver >= 40);\n\t\treturn 0;\n\tcase DRM_V3D_PARAM_SUPPORTS_MULTISYNC_EXT:\n\t\targs->value = 1;\n\t\treturn 0;\n\tdefault:\n\t\tDRM_DEBUG(\"Unknown parameter %d\\n\", args->param);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nv3d_open(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(dev);\n\tstruct v3d_file_priv *v3d_priv;\n\tstruct drm_gpu_scheduler *sched;\n\tint i;\n\n\tv3d_priv = kzalloc(sizeof(*v3d_priv), GFP_KERNEL);\n\tif (!v3d_priv)\n\t\treturn -ENOMEM;\n\n\tv3d_priv->v3d = v3d;\n\n\tfor (i = 0; i < V3D_MAX_QUEUES; i++) {\n\t\tsched = &v3d->queue[i].sched;\n\t\tdrm_sched_entity_init(&v3d_priv->sched_entity[i],\n\t\t\t\t      DRM_SCHED_PRIORITY_NORMAL, &sched,\n\t\t\t\t      1, NULL);\n\t}\n\n\tv3d_perfmon_open_file(v3d_priv);\n\tfile->driver_priv = v3d_priv;\n\n\treturn 0;\n}\n\nstatic void\nv3d_postclose(struct drm_device *dev, struct drm_file *file)\n{\n\tstruct v3d_file_priv *v3d_priv = file->driver_priv;\n\tenum v3d_queue q;\n\n\tfor (q = 0; q < V3D_MAX_QUEUES; q++)\n\t\tdrm_sched_entity_destroy(&v3d_priv->sched_entity[q]);\n\n\tv3d_perfmon_close_file(v3d_priv);\n\tkfree(v3d_priv);\n}\n\nDEFINE_DRM_GEM_FOPS(v3d_drm_fops);\n\n \nstatic const struct drm_ioctl_desc v3d_drm_ioctls[] = {\n\tDRM_IOCTL_DEF_DRV(V3D_SUBMIT_CL, v3d_submit_cl_ioctl, DRM_RENDER_ALLOW | DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(V3D_WAIT_BO, v3d_wait_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_CREATE_BO, v3d_create_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_MMAP_BO, v3d_mmap_bo_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_GET_PARAM, v3d_get_param_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_GET_BO_OFFSET, v3d_get_bo_offset_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_SUBMIT_TFU, v3d_submit_tfu_ioctl, DRM_RENDER_ALLOW | DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(V3D_SUBMIT_CSD, v3d_submit_csd_ioctl, DRM_RENDER_ALLOW | DRM_AUTH),\n\tDRM_IOCTL_DEF_DRV(V3D_PERFMON_CREATE, v3d_perfmon_create_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_PERFMON_DESTROY, v3d_perfmon_destroy_ioctl, DRM_RENDER_ALLOW),\n\tDRM_IOCTL_DEF_DRV(V3D_PERFMON_GET_VALUES, v3d_perfmon_get_values_ioctl, DRM_RENDER_ALLOW),\n};\n\nstatic const struct drm_driver v3d_drm_driver = {\n\t.driver_features = (DRIVER_GEM |\n\t\t\t    DRIVER_RENDER |\n\t\t\t    DRIVER_SYNCOBJ),\n\n\t.open = v3d_open,\n\t.postclose = v3d_postclose,\n\n#if defined(CONFIG_DEBUG_FS)\n\t.debugfs_init = v3d_debugfs_init,\n#endif\n\n\t.gem_create_object = v3d_create_object,\n\t.gem_prime_import_sg_table = v3d_prime_import_sg_table,\n\n\t.ioctls = v3d_drm_ioctls,\n\t.num_ioctls = ARRAY_SIZE(v3d_drm_ioctls),\n\t.fops = &v3d_drm_fops,\n\n\t.name = DRIVER_NAME,\n\t.desc = DRIVER_DESC,\n\t.date = DRIVER_DATE,\n\t.major = DRIVER_MAJOR,\n\t.minor = DRIVER_MINOR,\n\t.patchlevel = DRIVER_PATCHLEVEL,\n};\n\nstatic const struct of_device_id v3d_of_match[] = {\n\t{ .compatible = \"brcm,2711-v3d\" },\n\t{ .compatible = \"brcm,7268-v3d\" },\n\t{ .compatible = \"brcm,7278-v3d\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, v3d_of_match);\n\nstatic int\nmap_regs(struct v3d_dev *v3d, void __iomem **regs, const char *name)\n{\n\t*regs = devm_platform_ioremap_resource_byname(v3d_to_pdev(v3d), name);\n\treturn PTR_ERR_OR_ZERO(*regs);\n}\n\nstatic int v3d_platform_drm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct drm_device *drm;\n\tstruct v3d_dev *v3d;\n\tint ret;\n\tu32 mmu_debug;\n\tu32 ident1;\n\tu64 mask;\n\n\tv3d = devm_drm_dev_alloc(dev, &v3d_drm_driver, struct v3d_dev, drm);\n\tif (IS_ERR(v3d))\n\t\treturn PTR_ERR(v3d);\n\n\tdrm = &v3d->drm;\n\n\tplatform_set_drvdata(pdev, drm);\n\n\tret = map_regs(v3d, &v3d->hub_regs, \"hub\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = map_regs(v3d, &v3d->core_regs[0], \"core0\");\n\tif (ret)\n\t\treturn ret;\n\n\tmmu_debug = V3D_READ(V3D_MMU_DEBUG_INFO);\n\tmask = DMA_BIT_MASK(30 + V3D_GET_FIELD(mmu_debug, V3D_MMU_PA_WIDTH));\n\tret = dma_set_mask_and_coherent(dev, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tv3d->va_width = 30 + V3D_GET_FIELD(mmu_debug, V3D_MMU_VA_WIDTH);\n\n\tident1 = V3D_READ(V3D_HUB_IDENT1);\n\tv3d->ver = (V3D_GET_FIELD(ident1, V3D_HUB_IDENT1_TVER) * 10 +\n\t\t    V3D_GET_FIELD(ident1, V3D_HUB_IDENT1_REV));\n\tv3d->cores = V3D_GET_FIELD(ident1, V3D_HUB_IDENT1_NCORES);\n\tWARN_ON(v3d->cores > 1);  \n\n\tv3d->reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(v3d->reset)) {\n\t\tret = PTR_ERR(v3d->reset);\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tv3d->reset = NULL;\n\t\tret = map_regs(v3d, &v3d->bridge_regs, \"bridge\");\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to get reset control or bridge regs\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (v3d->ver < 41) {\n\t\tret = map_regs(v3d, &v3d->gca_regs, \"gca\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tv3d->mmu_scratch = dma_alloc_wc(dev, 4096, &v3d->mmu_scratch_paddr,\n\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\tif (!v3d->mmu_scratch) {\n\t\tdev_err(dev, \"Failed to allocate MMU scratch page\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = v3d_gem_init(drm);\n\tif (ret)\n\t\tgoto dma_free;\n\n\tret = v3d_irq_init(v3d);\n\tif (ret)\n\t\tgoto gem_destroy;\n\n\tret = drm_dev_register(drm, 0);\n\tif (ret)\n\t\tgoto irq_disable;\n\n\treturn 0;\n\nirq_disable:\n\tv3d_irq_disable(v3d);\ngem_destroy:\n\tv3d_gem_destroy(drm);\ndma_free:\n\tdma_free_wc(dev, 4096, v3d->mmu_scratch, v3d->mmu_scratch_paddr);\n\treturn ret;\n}\n\nstatic void v3d_platform_drm_remove(struct platform_device *pdev)\n{\n\tstruct drm_device *drm = platform_get_drvdata(pdev);\n\tstruct v3d_dev *v3d = to_v3d_dev(drm);\n\n\tdrm_dev_unregister(drm);\n\n\tv3d_gem_destroy(drm);\n\n\tdma_free_wc(v3d->drm.dev, 4096, v3d->mmu_scratch,\n\t\t    v3d->mmu_scratch_paddr);\n}\n\nstatic struct platform_driver v3d_platform_driver = {\n\t.probe\t\t= v3d_platform_drm_probe,\n\t.remove_new\t= v3d_platform_drm_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"v3d\",\n\t\t.of_match_table = v3d_of_match,\n\t},\n};\n\nmodule_platform_driver(v3d_platform_driver);\n\nMODULE_ALIAS(\"platform:v3d-drm\");\nMODULE_DESCRIPTION(\"Broadcom V3D DRM Driver\");\nMODULE_AUTHOR(\"Eric Anholt <eric@anholt.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}