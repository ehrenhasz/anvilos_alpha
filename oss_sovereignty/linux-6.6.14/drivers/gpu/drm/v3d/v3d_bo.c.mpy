{
  "module_name": "v3d_bo.c",
  "hash_id": "75b2386e78ae0908094a97be95ee16328ecbfd786c8d207e008ef4b198782f55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_bo.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dma-buf.h>\n#include <linux/pfn_t.h>\n\n#include \"v3d_drv.h\"\n#include \"uapi/drm/v3d_drm.h\"\n\n \nvoid v3d_free_object(struct drm_gem_object *obj)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(obj->dev);\n\tstruct v3d_bo *bo = to_v3d_bo(obj);\n\n\tv3d_mmu_remove_ptes(bo);\n\n\tmutex_lock(&v3d->bo_lock);\n\tv3d->bo_stats.num_allocated--;\n\tv3d->bo_stats.pages_allocated -= obj->size >> PAGE_SHIFT;\n\tmutex_unlock(&v3d->bo_lock);\n\n\tspin_lock(&v3d->mm_lock);\n\tdrm_mm_remove_node(&bo->node);\n\tspin_unlock(&v3d->mm_lock);\n\n\t \n\tbo->base.pages_mark_dirty_on_put = true;\n\n\tdrm_gem_shmem_free(&bo->base);\n}\n\nstatic const struct drm_gem_object_funcs v3d_gem_funcs = {\n\t.free = v3d_free_object,\n\t.print_info = drm_gem_shmem_object_print_info,\n\t.pin = drm_gem_shmem_object_pin,\n\t.unpin = drm_gem_shmem_object_unpin,\n\t.get_sg_table = drm_gem_shmem_object_get_sg_table,\n\t.vmap = drm_gem_shmem_object_vmap,\n\t.vunmap = drm_gem_shmem_object_vunmap,\n\t.mmap = drm_gem_shmem_object_mmap,\n\t.vm_ops = &drm_gem_shmem_vm_ops,\n};\n\n \nstruct drm_gem_object *v3d_create_object(struct drm_device *dev, size_t size)\n{\n\tstruct v3d_bo *bo;\n\tstruct drm_gem_object *obj;\n\n\tif (size == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbo = kzalloc(sizeof(*bo), GFP_KERNEL);\n\tif (!bo)\n\t\treturn ERR_PTR(-ENOMEM);\n\tobj = &bo->base.base;\n\n\tobj->funcs = &v3d_gem_funcs;\n\tbo->base.map_wc = true;\n\tINIT_LIST_HEAD(&bo->unref_head);\n\n\treturn &bo->base.base;\n}\n\nstatic int\nv3d_bo_create_finish(struct drm_gem_object *obj)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(obj->dev);\n\tstruct v3d_bo *bo = to_v3d_bo(obj);\n\tstruct sg_table *sgt;\n\tint ret;\n\n\t \n\tsgt = drm_gem_shmem_get_pages_sgt(&bo->base);\n\tif (IS_ERR(sgt))\n\t\treturn PTR_ERR(sgt);\n\n\tspin_lock(&v3d->mm_lock);\n\t \n\tret = drm_mm_insert_node_generic(&v3d->mm, &bo->node,\n\t\t\t\t\t obj->size >> PAGE_SHIFT,\n\t\t\t\t\t GMP_GRANULARITY >> PAGE_SHIFT, 0, 0);\n\tspin_unlock(&v3d->mm_lock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmutex_lock(&v3d->bo_lock);\n\tv3d->bo_stats.num_allocated++;\n\tv3d->bo_stats.pages_allocated += obj->size >> PAGE_SHIFT;\n\tmutex_unlock(&v3d->bo_lock);\n\n\tv3d_mmu_insert_ptes(bo);\n\n\treturn 0;\n}\n\nstruct v3d_bo *v3d_bo_create(struct drm_device *dev, struct drm_file *file_priv,\n\t\t\t     size_t unaligned_size)\n{\n\tstruct drm_gem_shmem_object *shmem_obj;\n\tstruct v3d_bo *bo;\n\tint ret;\n\n\tshmem_obj = drm_gem_shmem_create(dev, unaligned_size);\n\tif (IS_ERR(shmem_obj))\n\t\treturn ERR_CAST(shmem_obj);\n\tbo = to_v3d_bo(&shmem_obj->base);\n\n\tret = v3d_bo_create_finish(&shmem_obj->base);\n\tif (ret)\n\t\tgoto free_obj;\n\n\treturn bo;\n\nfree_obj:\n\tdrm_gem_shmem_free(shmem_obj);\n\treturn ERR_PTR(ret);\n}\n\nstruct drm_gem_object *\nv3d_prime_import_sg_table(struct drm_device *dev,\n\t\t\t  struct dma_buf_attachment *attach,\n\t\t\t  struct sg_table *sgt)\n{\n\tstruct drm_gem_object *obj;\n\tint ret;\n\n\tobj = drm_gem_shmem_prime_import_sg_table(dev, attach, sgt);\n\tif (IS_ERR(obj))\n\t\treturn obj;\n\n\tret = v3d_bo_create_finish(obj);\n\tif (ret) {\n\t\tdrm_gem_shmem_free(&to_v3d_bo(obj)->base);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn obj;\n}\n\nint v3d_create_bo_ioctl(struct drm_device *dev, void *data,\n\t\t\tstruct drm_file *file_priv)\n{\n\tstruct drm_v3d_create_bo *args = data;\n\tstruct v3d_bo *bo = NULL;\n\tint ret;\n\n\tif (args->flags != 0) {\n\t\tDRM_INFO(\"unknown create_bo flags: %d\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tbo = v3d_bo_create(dev, file_priv, PAGE_ALIGN(args->size));\n\tif (IS_ERR(bo))\n\t\treturn PTR_ERR(bo);\n\n\targs->offset = bo->node.start << PAGE_SHIFT;\n\n\tret = drm_gem_handle_create(file_priv, &bo->base.base, &args->handle);\n\tdrm_gem_object_put(&bo->base.base);\n\n\treturn ret;\n}\n\nint v3d_mmap_bo_ioctl(struct drm_device *dev, void *data,\n\t\t      struct drm_file *file_priv)\n{\n\tstruct drm_v3d_mmap_bo *args = data;\n\tstruct drm_gem_object *gem_obj;\n\n\tif (args->flags != 0) {\n\t\tDRM_INFO(\"unknown mmap_bo flags: %d\\n\", args->flags);\n\t\treturn -EINVAL;\n\t}\n\n\tgem_obj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!gem_obj) {\n\t\tDRM_DEBUG(\"Failed to look up GEM BO %d\\n\", args->handle);\n\t\treturn -ENOENT;\n\t}\n\n\targs->offset = drm_vma_node_offset_addr(&gem_obj->vma_node);\n\tdrm_gem_object_put(gem_obj);\n\n\treturn 0;\n}\n\nint v3d_get_bo_offset_ioctl(struct drm_device *dev, void *data,\n\t\t\t    struct drm_file *file_priv)\n{\n\tstruct drm_v3d_get_bo_offset *args = data;\n\tstruct drm_gem_object *gem_obj;\n\tstruct v3d_bo *bo;\n\n\tgem_obj = drm_gem_object_lookup(file_priv, args->handle);\n\tif (!gem_obj) {\n\t\tDRM_DEBUG(\"Failed to look up GEM BO %d\\n\", args->handle);\n\t\treturn -ENOENT;\n\t}\n\tbo = to_v3d_bo(gem_obj);\n\n\targs->offset = bo->node.start << PAGE_SHIFT;\n\n\tdrm_gem_object_put(gem_obj);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}