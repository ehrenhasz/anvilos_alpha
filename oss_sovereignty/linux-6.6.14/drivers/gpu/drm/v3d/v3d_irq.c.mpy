{
  "module_name": "v3d_irq.c",
  "hash_id": "046e0fea46034de6473755a8d379cc0fe0a6ff49ae9f1901e08ec4ef8e455c78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_irq.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/platform_device.h>\n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n#include \"v3d_trace.h\"\n\n#define V3D_CORE_IRQS ((u32)(V3D_INT_OUTOMEM |\t\\\n\t\t\t     V3D_INT_FLDONE |\t\\\n\t\t\t     V3D_INT_FRDONE |\t\\\n\t\t\t     V3D_INT_CSDDONE |\t\\\n\t\t\t     V3D_INT_GMPV))\n\n#define V3D_HUB_IRQS ((u32)(V3D_HUB_INT_MMU_WRV |\t\\\n\t\t\t    V3D_HUB_INT_MMU_PTI |\t\\\n\t\t\t    V3D_HUB_INT_MMU_CAP |\t\\\n\t\t\t    V3D_HUB_INT_TFUC))\n\nstatic irqreturn_t\nv3d_hub_irq(int irq, void *arg);\n\nstatic void\nv3d_overflow_mem_work(struct work_struct *work)\n{\n\tstruct v3d_dev *v3d =\n\t\tcontainer_of(work, struct v3d_dev, overflow_mem_work);\n\tstruct drm_device *dev = &v3d->drm;\n\tstruct v3d_bo *bo = v3d_bo_create(dev, NULL  , 256 * 1024);\n\tstruct drm_gem_object *obj;\n\tunsigned long irqflags;\n\n\tif (IS_ERR(bo)) {\n\t\tDRM_ERROR(\"Couldn't allocate binner overflow mem\\n\");\n\t\treturn;\n\t}\n\tobj = &bo->base.base;\n\n\t \n\tspin_lock_irqsave(&v3d->job_lock, irqflags);\n\tif (!v3d->bin_job) {\n\t\tspin_unlock_irqrestore(&v3d->job_lock, irqflags);\n\t\tgoto out;\n\t}\n\n\tdrm_gem_object_get(obj);\n\tlist_add_tail(&bo->unref_head, &v3d->bin_job->render->unref_list);\n\tspin_unlock_irqrestore(&v3d->job_lock, irqflags);\n\n\tV3D_CORE_WRITE(0, V3D_PTB_BPOA, bo->node.start << PAGE_SHIFT);\n\tV3D_CORE_WRITE(0, V3D_PTB_BPOS, obj->size);\n\nout:\n\tdrm_gem_object_put(obj);\n}\n\nstatic irqreturn_t\nv3d_irq(int irq, void *arg)\n{\n\tstruct v3d_dev *v3d = arg;\n\tu32 intsts;\n\tirqreturn_t status = IRQ_NONE;\n\n\tintsts = V3D_CORE_READ(0, V3D_CTL_INT_STS);\n\n\t \n\tV3D_CORE_WRITE(0, V3D_CTL_INT_CLR, intsts);\n\n\tif (intsts & V3D_INT_OUTOMEM) {\n\t\t \n\t\tschedule_work(&v3d->overflow_mem_work);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (intsts & V3D_INT_FLDONE) {\n\t\tstruct v3d_fence *fence =\n\t\t\tto_v3d_fence(v3d->bin_job->base.irq_fence);\n\n\t\ttrace_v3d_bcl_irq(&v3d->drm, fence->seqno);\n\t\tdma_fence_signal(&fence->base);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (intsts & V3D_INT_FRDONE) {\n\t\tstruct v3d_fence *fence =\n\t\t\tto_v3d_fence(v3d->render_job->base.irq_fence);\n\n\t\ttrace_v3d_rcl_irq(&v3d->drm, fence->seqno);\n\t\tdma_fence_signal(&fence->base);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (intsts & V3D_INT_CSDDONE) {\n\t\tstruct v3d_fence *fence =\n\t\t\tto_v3d_fence(v3d->csd_job->base.irq_fence);\n\n\t\ttrace_v3d_csd_irq(&v3d->drm, fence->seqno);\n\t\tdma_fence_signal(&fence->base);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tif (intsts & V3D_INT_GMPV)\n\t\tdev_err(v3d->drm.dev, \"GMP violation\\n\");\n\n\t \n\tif (v3d->single_irq_line && status == IRQ_NONE)\n\t\treturn v3d_hub_irq(irq, arg);\n\n\treturn status;\n}\n\nstatic irqreturn_t\nv3d_hub_irq(int irq, void *arg)\n{\n\tstruct v3d_dev *v3d = arg;\n\tu32 intsts;\n\tirqreturn_t status = IRQ_NONE;\n\n\tintsts = V3D_READ(V3D_HUB_INT_STS);\n\n\t \n\tV3D_WRITE(V3D_HUB_INT_CLR, intsts);\n\n\tif (intsts & V3D_HUB_INT_TFUC) {\n\t\tstruct v3d_fence *fence =\n\t\t\tto_v3d_fence(v3d->tfu_job->base.irq_fence);\n\n\t\ttrace_v3d_tfu_irq(&v3d->drm, fence->seqno);\n\t\tdma_fence_signal(&fence->base);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (intsts & (V3D_HUB_INT_MMU_WRV |\n\t\t      V3D_HUB_INT_MMU_PTI |\n\t\t      V3D_HUB_INT_MMU_CAP)) {\n\t\tu32 axi_id = V3D_READ(V3D_MMU_VIO_ID);\n\t\tu64 vio_addr = ((u64)V3D_READ(V3D_MMU_VIO_ADDR) <<\n\t\t\t\t(v3d->va_width - 32));\n\t\tstatic const char *const v3d41_axi_ids[] = {\n\t\t\t\"L2T\",\n\t\t\t\"PTB\",\n\t\t\t\"PSE\",\n\t\t\t\"TLB\",\n\t\t\t\"CLE\",\n\t\t\t\"TFU\",\n\t\t\t\"MMU\",\n\t\t\t\"GMP\",\n\t\t};\n\t\tconst char *client = \"?\";\n\n\t\tV3D_WRITE(V3D_MMU_CTL, V3D_READ(V3D_MMU_CTL));\n\n\t\tif (v3d->ver >= 41) {\n\t\t\taxi_id = axi_id >> 5;\n\t\t\tif (axi_id < ARRAY_SIZE(v3d41_axi_ids))\n\t\t\t\tclient = v3d41_axi_ids[axi_id];\n\t\t}\n\n\t\tdev_err(v3d->drm.dev, \"MMU error from client %s (%d) at 0x%llx%s%s%s\\n\",\n\t\t\tclient, axi_id, (long long)vio_addr,\n\t\t\t((intsts & V3D_HUB_INT_MMU_WRV) ?\n\t\t\t \", write violation\" : \"\"),\n\t\t\t((intsts & V3D_HUB_INT_MMU_PTI) ?\n\t\t\t \", pte invalid\" : \"\"),\n\t\t\t((intsts & V3D_HUB_INT_MMU_CAP) ?\n\t\t\t \", cap exceeded\" : \"\"));\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\treturn status;\n}\n\nint\nv3d_irq_init(struct v3d_dev *v3d)\n{\n\tint irq1, ret, core;\n\n\tINIT_WORK(&v3d->overflow_mem_work, v3d_overflow_mem_work);\n\n\t \n\tfor (core = 0; core < v3d->cores; core++)\n\t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS);\n\tV3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS);\n\n\tirq1 = platform_get_irq_optional(v3d_to_pdev(v3d), 1);\n\tif (irq1 == -EPROBE_DEFER)\n\t\treturn irq1;\n\tif (irq1 > 0) {\n\t\tret = devm_request_irq(v3d->drm.dev, irq1,\n\t\t\t\t       v3d_irq, IRQF_SHARED,\n\t\t\t\t       \"v3d_core0\", v3d);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tret = devm_request_irq(v3d->drm.dev,\n\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n\t\t\t\t       v3d_hub_irq, IRQF_SHARED,\n\t\t\t\t       \"v3d_hub\", v3d);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t} else {\n\t\tv3d->single_irq_line = true;\n\n\t\tret = devm_request_irq(v3d->drm.dev,\n\t\t\t\t       platform_get_irq(v3d_to_pdev(v3d), 0),\n\t\t\t\t       v3d_irq, IRQF_SHARED,\n\t\t\t\t       \"v3d\", v3d);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\tv3d_irq_enable(v3d);\n\treturn 0;\n\nfail:\n\tif (ret != -EPROBE_DEFER)\n\t\tdev_err(v3d->drm.dev, \"IRQ setup failed: %d\\n\", ret);\n\treturn ret;\n}\n\nvoid\nv3d_irq_enable(struct v3d_dev *v3d)\n{\n\tint core;\n\n\t \n\tfor (core = 0; core < v3d->cores; core++) {\n\t\tV3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~V3D_CORE_IRQS);\n\t\tV3D_CORE_WRITE(core, V3D_CTL_INT_MSK_CLR, V3D_CORE_IRQS);\n\t}\n\n\tV3D_WRITE(V3D_HUB_INT_MSK_SET, ~V3D_HUB_IRQS);\n\tV3D_WRITE(V3D_HUB_INT_MSK_CLR, V3D_HUB_IRQS);\n}\n\nvoid\nv3d_irq_disable(struct v3d_dev *v3d)\n{\n\tint core;\n\n\t \n\tfor (core = 0; core < v3d->cores; core++)\n\t\tV3D_CORE_WRITE(core, V3D_CTL_INT_MSK_SET, ~0);\n\tV3D_WRITE(V3D_HUB_INT_MSK_SET, ~0);\n\n\t \n\tfor (core = 0; core < v3d->cores; core++)\n\t\tV3D_CORE_WRITE(core, V3D_CTL_INT_CLR, V3D_CORE_IRQS);\n\tV3D_WRITE(V3D_HUB_INT_CLR, V3D_HUB_IRQS);\n\n\tcancel_work_sync(&v3d->overflow_mem_work);\n}\n\n \nvoid v3d_irq_reset(struct v3d_dev *v3d)\n{\n\tv3d_irq_enable(v3d);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}