{
  "module_name": "v3d_mmu.c",
  "hash_id": "7776583d9babbab966e8f939c9a3ecd1330e1f9185e2dc18aa743fa92756b9a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/v3d/v3d_mmu.c",
  "human_readable_source": "\n \n\n \n\n#include \"v3d_drv.h\"\n#include \"v3d_regs.h\"\n\n#define V3D_MMU_PAGE_SHIFT 12\n\n \n#define V3D_PTE_SUPERPAGE BIT(31)\n#define V3D_PTE_WRITEABLE BIT(29)\n#define V3D_PTE_VALID BIT(28)\n\nstatic int v3d_mmu_flush_all(struct v3d_dev *v3d)\n{\n\tint ret;\n\n\t \n\tret = wait_for(!(V3D_READ(V3D_MMU_CTL) &\n\t\t\t V3D_MMU_CTL_TLB_CLEARING), 100);\n\tif (ret)\n\t\tdev_err(v3d->drm.dev, \"TLB clear wait idle pre-wait failed\\n\");\n\n\tV3D_WRITE(V3D_MMU_CTL, V3D_READ(V3D_MMU_CTL) |\n\t\t  V3D_MMU_CTL_TLB_CLEAR);\n\n\tV3D_WRITE(V3D_MMUC_CONTROL,\n\t\t  V3D_MMUC_CONTROL_FLUSH |\n\t\t  V3D_MMUC_CONTROL_ENABLE);\n\n\tret = wait_for(!(V3D_READ(V3D_MMU_CTL) &\n\t\t\t V3D_MMU_CTL_TLB_CLEARING), 100);\n\tif (ret) {\n\t\tdev_err(v3d->drm.dev, \"TLB clear wait idle failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = wait_for(!(V3D_READ(V3D_MMUC_CONTROL) &\n\t\t\t V3D_MMUC_CONTROL_FLUSHING), 100);\n\tif (ret)\n\t\tdev_err(v3d->drm.dev, \"MMUC flush wait idle failed\\n\");\n\n\treturn ret;\n}\n\nint v3d_mmu_set_page_table(struct v3d_dev *v3d)\n{\n\tV3D_WRITE(V3D_MMU_PT_PA_BASE, v3d->pt_paddr >> V3D_MMU_PAGE_SHIFT);\n\tV3D_WRITE(V3D_MMU_CTL,\n\t\t  V3D_MMU_CTL_ENABLE |\n\t\t  V3D_MMU_CTL_PT_INVALID_ENABLE |\n\t\t  V3D_MMU_CTL_PT_INVALID_ABORT |\n\t\t  V3D_MMU_CTL_PT_INVALID_INT |\n\t\t  V3D_MMU_CTL_WRITE_VIOLATION_ABORT |\n\t\t  V3D_MMU_CTL_WRITE_VIOLATION_INT |\n\t\t  V3D_MMU_CTL_CAP_EXCEEDED_ABORT |\n\t\t  V3D_MMU_CTL_CAP_EXCEEDED_INT);\n\tV3D_WRITE(V3D_MMU_ILLEGAL_ADDR,\n\t\t  (v3d->mmu_scratch_paddr >> V3D_MMU_PAGE_SHIFT) |\n\t\t  V3D_MMU_ILLEGAL_ADDR_ENABLE);\n\tV3D_WRITE(V3D_MMUC_CONTROL, V3D_MMUC_CONTROL_ENABLE);\n\n\treturn v3d_mmu_flush_all(v3d);\n}\n\nvoid v3d_mmu_insert_ptes(struct v3d_bo *bo)\n{\n\tstruct drm_gem_shmem_object *shmem_obj = &bo->base;\n\tstruct v3d_dev *v3d = to_v3d_dev(shmem_obj->base.dev);\n\tu32 page = bo->node.start;\n\tu32 page_prot = V3D_PTE_WRITEABLE | V3D_PTE_VALID;\n\tstruct sg_dma_page_iter dma_iter;\n\n\tfor_each_sgtable_dma_page(shmem_obj->sgt, &dma_iter, 0) {\n\t\tdma_addr_t dma_addr = sg_page_iter_dma_address(&dma_iter);\n\t\tu32 page_address = dma_addr >> V3D_MMU_PAGE_SHIFT;\n\t\tu32 pte = page_prot | page_address;\n\t\tu32 i;\n\n\t\tBUG_ON(page_address + (PAGE_SIZE >> V3D_MMU_PAGE_SHIFT) >=\n\t\t       BIT(24));\n\t\tfor (i = 0; i < PAGE_SIZE >> V3D_MMU_PAGE_SHIFT; i++)\n\t\t\tv3d->pt[page++] = pte + i;\n\t}\n\n\tWARN_ON_ONCE(page - bo->node.start !=\n\t\t     shmem_obj->base.size >> V3D_MMU_PAGE_SHIFT);\n\n\tif (v3d_mmu_flush_all(v3d))\n\t\tdev_err(v3d->drm.dev, \"MMU flush timeout\\n\");\n}\n\nvoid v3d_mmu_remove_ptes(struct v3d_bo *bo)\n{\n\tstruct v3d_dev *v3d = to_v3d_dev(bo->base.base.dev);\n\tu32 npages = bo->base.base.size >> V3D_MMU_PAGE_SHIFT;\n\tu32 page;\n\n\tfor (page = bo->node.start; page < bo->node.start + npages; page++)\n\t\tv3d->pt[page] = 0;\n\n\tif (v3d_mmu_flush_all(v3d))\n\t\tdev_err(v3d->drm.dev, \"MMU flush timeout\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}