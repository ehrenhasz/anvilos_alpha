{
  "module_name": "drm_dp_cec.c",
  "hash_id": "13e70cb6582a014b4fff1546ca45a7981e58f74451f1849797c4a2c17aa91a7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_dp_cec.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <media/cec.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_device.h>\n\n \n\n \n\n \n#define NEVER_UNREG_DELAY 1000\nstatic unsigned int drm_dp_cec_unregister_delay = 1;\nmodule_param(drm_dp_cec_unregister_delay, uint, 0600);\nMODULE_PARM_DESC(drm_dp_cec_unregister_delay,\n\t\t \"CEC unregister delay in seconds, 0: no delay, >= 1000: never unregister\");\n\nstatic int drm_dp_cec_adap_enable(struct cec_adapter *adap, bool enable)\n{\n\tstruct drm_dp_aux *aux = cec_get_drvdata(adap);\n\tu32 val = enable ? DP_CEC_TUNNELING_ENABLE : 0;\n\tssize_t err = 0;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_CEC_TUNNELING_CONTROL, val);\n\treturn (enable && err < 0) ? err : 0;\n}\n\nstatic int drm_dp_cec_adap_log_addr(struct cec_adapter *adap, u8 addr)\n{\n\tstruct drm_dp_aux *aux = cec_get_drvdata(adap);\n\t \n\tu16 la_mask = 1 << CEC_LOG_ADDR_BROADCAST;\n\tu8 mask[2];\n\tssize_t err;\n\n\tif (addr != CEC_LOG_ADDR_INVALID)\n\t\tla_mask |= adap->log_addrs.log_addr_mask | (1 << addr);\n\tmask[0] = la_mask & 0xff;\n\tmask[1] = la_mask >> 8;\n\terr = drm_dp_dpcd_write(aux, DP_CEC_LOGICAL_ADDRESS_MASK, mask, 2);\n\treturn (addr != CEC_LOG_ADDR_INVALID && err < 0) ? err : 0;\n}\n\nstatic int drm_dp_cec_adap_transmit(struct cec_adapter *adap, u8 attempts,\n\t\t\t\t    u32 signal_free_time, struct cec_msg *msg)\n{\n\tstruct drm_dp_aux *aux = cec_get_drvdata(adap);\n\tunsigned int retries = min(5, attempts - 1);\n\tssize_t err;\n\n\terr = drm_dp_dpcd_write(aux, DP_CEC_TX_MESSAGE_BUFFER,\n\t\t\t\tmsg->msg, msg->len);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = drm_dp_dpcd_writeb(aux, DP_CEC_TX_MESSAGE_INFO,\n\t\t\t\t (msg->len - 1) | (retries << 4) |\n\t\t\t\t DP_CEC_TX_MESSAGE_SEND);\n\treturn err < 0 ? err : 0;\n}\n\nstatic int drm_dp_cec_adap_monitor_all_enable(struct cec_adapter *adap,\n\t\t\t\t\t      bool enable)\n{\n\tstruct drm_dp_aux *aux = cec_get_drvdata(adap);\n\tssize_t err;\n\tu8 val;\n\n\tif (!(adap->capabilities & CEC_CAP_MONITOR_ALL))\n\t\treturn 0;\n\n\terr = drm_dp_dpcd_readb(aux, DP_CEC_TUNNELING_CONTROL, &val);\n\tif (err >= 0) {\n\t\tif (enable)\n\t\t\tval |= DP_CEC_SNOOPING_ENABLE;\n\t\telse\n\t\t\tval &= ~DP_CEC_SNOOPING_ENABLE;\n\t\terr = drm_dp_dpcd_writeb(aux, DP_CEC_TUNNELING_CONTROL, val);\n\t}\n\treturn (enable && err < 0) ? err : 0;\n}\n\nstatic void drm_dp_cec_adap_status(struct cec_adapter *adap,\n\t\t\t\t   struct seq_file *file)\n{\n\tstruct drm_dp_aux *aux = cec_get_drvdata(adap);\n\tstruct drm_dp_desc desc;\n\tstruct drm_dp_dpcd_ident *id = &desc.ident;\n\n\tif (drm_dp_read_desc(aux, &desc, true))\n\t\treturn;\n\tseq_printf(file, \"OUI: %*phD\\n\",\n\t\t   (int)sizeof(id->oui), id->oui);\n\tseq_printf(file, \"ID: %*pE\\n\",\n\t\t   (int)strnlen(id->device_id, sizeof(id->device_id)),\n\t\t   id->device_id);\n\tseq_printf(file, \"HW Rev: %d.%d\\n\", id->hw_rev >> 4, id->hw_rev & 0xf);\n\t \n\tseq_printf(file, \"FW/SW Rev: %d.%d (0x%02x.0x%02x)\\n\",\n\t\t   id->sw_major_rev, id->sw_minor_rev,\n\t\t   id->sw_major_rev, id->sw_minor_rev);\n}\n\nstatic const struct cec_adap_ops drm_dp_cec_adap_ops = {\n\t.adap_enable = drm_dp_cec_adap_enable,\n\t.adap_log_addr = drm_dp_cec_adap_log_addr,\n\t.adap_transmit = drm_dp_cec_adap_transmit,\n\t.adap_monitor_all_enable = drm_dp_cec_adap_monitor_all_enable,\n\t.adap_status = drm_dp_cec_adap_status,\n};\n\nstatic int drm_dp_cec_received(struct drm_dp_aux *aux)\n{\n\tstruct cec_adapter *adap = aux->cec.adap;\n\tstruct cec_msg msg;\n\tu8 rx_msg_info;\n\tssize_t err;\n\n\terr = drm_dp_dpcd_readb(aux, DP_CEC_RX_MESSAGE_INFO, &rx_msg_info);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(rx_msg_info & DP_CEC_RX_MESSAGE_ENDED))\n\t\treturn 0;\n\n\tmsg.len = (rx_msg_info & DP_CEC_RX_MESSAGE_LEN_MASK) + 1;\n\terr = drm_dp_dpcd_read(aux, DP_CEC_RX_MESSAGE_BUFFER, msg.msg, msg.len);\n\tif (err < 0)\n\t\treturn err;\n\n\tcec_received_msg(adap, &msg);\n\treturn 0;\n}\n\nstatic void drm_dp_cec_handle_irq(struct drm_dp_aux *aux)\n{\n\tstruct cec_adapter *adap = aux->cec.adap;\n\tu8 flags;\n\n\tif (drm_dp_dpcd_readb(aux, DP_CEC_TUNNELING_IRQ_FLAGS, &flags) < 0)\n\t\treturn;\n\n\tif (flags & DP_CEC_RX_MESSAGE_INFO_VALID)\n\t\tdrm_dp_cec_received(aux);\n\n\tif (flags & DP_CEC_TX_MESSAGE_SENT)\n\t\tcec_transmit_attempt_done(adap, CEC_TX_STATUS_OK);\n\telse if (flags & DP_CEC_TX_LINE_ERROR)\n\t\tcec_transmit_attempt_done(adap, CEC_TX_STATUS_ERROR |\n\t\t\t\t\t\tCEC_TX_STATUS_MAX_RETRIES);\n\telse if (flags &\n\t\t (DP_CEC_TX_ADDRESS_NACK_ERROR | DP_CEC_TX_DATA_NACK_ERROR))\n\t\tcec_transmit_attempt_done(adap, CEC_TX_STATUS_NACK |\n\t\t\t\t\t\tCEC_TX_STATUS_MAX_RETRIES);\n\tdrm_dp_dpcd_writeb(aux, DP_CEC_TUNNELING_IRQ_FLAGS, flags);\n}\n\n \nvoid drm_dp_cec_irq(struct drm_dp_aux *aux)\n{\n\tu8 cec_irq;\n\tint ret;\n\n\t \n\tif (!aux->transfer)\n\t\treturn;\n\n\tmutex_lock(&aux->cec.lock);\n\tif (!aux->cec.adap)\n\t\tgoto unlock;\n\n\tret = drm_dp_dpcd_readb(aux, DP_DEVICE_SERVICE_IRQ_VECTOR_ESI1,\n\t\t\t\t&cec_irq);\n\tif (ret < 0 || !(cec_irq & DP_CEC_IRQ))\n\t\tgoto unlock;\n\n\tdrm_dp_cec_handle_irq(aux);\n\tdrm_dp_dpcd_writeb(aux, DP_DEVICE_SERVICE_IRQ_VECTOR_ESI1, DP_CEC_IRQ);\nunlock:\n\tmutex_unlock(&aux->cec.lock);\n}\nEXPORT_SYMBOL(drm_dp_cec_irq);\n\nstatic bool drm_dp_cec_cap(struct drm_dp_aux *aux, u8 *cec_cap)\n{\n\tu8 cap = 0;\n\n\tif (drm_dp_dpcd_readb(aux, DP_CEC_TUNNELING_CAPABILITY, &cap) != 1 ||\n\t    !(cap & DP_CEC_TUNNELING_CAPABLE))\n\t\treturn false;\n\tif (cec_cap)\n\t\t*cec_cap = cap;\n\treturn true;\n}\n\n \nstatic void drm_dp_cec_unregister_work(struct work_struct *work)\n{\n\tstruct drm_dp_aux *aux = container_of(work, struct drm_dp_aux,\n\t\t\t\t\t      cec.unregister_work.work);\n\n\tmutex_lock(&aux->cec.lock);\n\tcec_unregister_adapter(aux->cec.adap);\n\taux->cec.adap = NULL;\n\tmutex_unlock(&aux->cec.lock);\n}\n\n \nvoid drm_dp_cec_set_edid(struct drm_dp_aux *aux, const struct edid *edid)\n{\n\tstruct drm_connector *connector = aux->cec.connector;\n\tu32 cec_caps = CEC_CAP_DEFAULTS | CEC_CAP_NEEDS_HPD |\n\t\t       CEC_CAP_CONNECTOR_INFO;\n\tstruct cec_connector_info conn_info;\n\tunsigned int num_las = 1;\n\tu8 cap;\n\n\t \n\tif (!aux->transfer)\n\t\treturn;\n\n#ifndef CONFIG_MEDIA_CEC_RC\n\t \n\tcec_caps &= ~CEC_CAP_RC;\n#endif\n\tcancel_delayed_work_sync(&aux->cec.unregister_work);\n\n\tmutex_lock(&aux->cec.lock);\n\tif (!drm_dp_cec_cap(aux, &cap)) {\n\t\t \n\t\tcec_unregister_adapter(aux->cec.adap);\n\t\taux->cec.adap = NULL;\n\t\tgoto unlock;\n\t}\n\n\tif (cap & DP_CEC_SNOOPING_CAPABLE)\n\t\tcec_caps |= CEC_CAP_MONITOR_ALL;\n\tif (cap & DP_CEC_MULTIPLE_LA_CAPABLE)\n\t\tnum_las = CEC_MAX_LOG_ADDRS;\n\n\tif (aux->cec.adap) {\n\t\tif (aux->cec.adap->capabilities == cec_caps &&\n\t\t    aux->cec.adap->available_log_addrs == num_las) {\n\t\t\t \n\t\t\tcec_s_phys_addr_from_edid(aux->cec.adap, edid);\n\t\t\tgoto unlock;\n\t\t}\n\t\t \n\t\tcec_unregister_adapter(aux->cec.adap);\n\t}\n\n\t \n\taux->cec.adap = cec_allocate_adapter(&drm_dp_cec_adap_ops,\n\t\t\t\t\t     aux, connector->name, cec_caps,\n\t\t\t\t\t     num_las);\n\tif (IS_ERR(aux->cec.adap)) {\n\t\taux->cec.adap = NULL;\n\t\tgoto unlock;\n\t}\n\n\tcec_fill_conn_info_from_drm(&conn_info, connector);\n\tcec_s_conn_info(aux->cec.adap, &conn_info);\n\n\tif (cec_register_adapter(aux->cec.adap, connector->dev->dev)) {\n\t\tcec_delete_adapter(aux->cec.adap);\n\t\taux->cec.adap = NULL;\n\t} else {\n\t\t \n\t\tcec_s_phys_addr_from_edid(aux->cec.adap, edid);\n\t}\nunlock:\n\tmutex_unlock(&aux->cec.lock);\n}\nEXPORT_SYMBOL(drm_dp_cec_set_edid);\n\n \nvoid drm_dp_cec_unset_edid(struct drm_dp_aux *aux)\n{\n\t \n\tif (!aux->transfer)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&aux->cec.unregister_work);\n\n\tmutex_lock(&aux->cec.lock);\n\tif (!aux->cec.adap)\n\t\tgoto unlock;\n\n\tcec_phys_addr_invalidate(aux->cec.adap);\n\t \n\tif (drm_dp_cec_unregister_delay < NEVER_UNREG_DELAY &&\n\t    !drm_dp_cec_cap(aux, NULL)) {\n\t\t \n\t\tschedule_delayed_work(&aux->cec.unregister_work,\n\t\t\t\t      drm_dp_cec_unregister_delay * HZ);\n\t}\nunlock:\n\tmutex_unlock(&aux->cec.lock);\n}\nEXPORT_SYMBOL(drm_dp_cec_unset_edid);\n\n \nvoid drm_dp_cec_register_connector(struct drm_dp_aux *aux,\n\t\t\t\t   struct drm_connector *connector)\n{\n\tWARN_ON(aux->cec.adap);\n\tif (WARN_ON(!aux->transfer))\n\t\treturn;\n\taux->cec.connector = connector;\n\tINIT_DELAYED_WORK(&aux->cec.unregister_work,\n\t\t\t  drm_dp_cec_unregister_work);\n}\nEXPORT_SYMBOL(drm_dp_cec_register_connector);\n\n \nvoid drm_dp_cec_unregister_connector(struct drm_dp_aux *aux)\n{\n\tif (!aux->cec.adap)\n\t\treturn;\n\tcancel_delayed_work_sync(&aux->cec.unregister_work);\n\tcec_unregister_adapter(aux->cec.adap);\n\taux->cec.adap = NULL;\n}\nEXPORT_SYMBOL(drm_dp_cec_unregister_connector);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}