{
  "module_name": "drm_hdcp_helper.c",
  "hash_id": "d98af5af33bb127cee68eecf1d772c8bb42a0053bb839a1f4c46afc8a63b32bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_hdcp_helper.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n\n#include <drm/display/drm_hdcp_helper.h>\n#include <drm/drm_sysfs.h>\n#include <drm/drm_print.h>\n#include <drm/drm_device.h>\n#include <drm/drm_property.h>\n#include <drm/drm_mode_object.h>\n#include <drm/drm_connector.h>\n\nstatic inline void drm_hdcp_print_ksv(const u8 *ksv)\n{\n\tDRM_DEBUG(\"\\t%#02x, %#02x, %#02x, %#02x, %#02x\\n\",\n\t\t  ksv[0], ksv[1], ksv[2], ksv[3], ksv[4]);\n}\n\nstatic u32 drm_hdcp_get_revoked_ksv_count(const u8 *buf, u32 vrls_length)\n{\n\tu32 parsed_bytes = 0, ksv_count = 0, vrl_ksv_cnt, vrl_sz;\n\n\twhile (parsed_bytes < vrls_length) {\n\t\tvrl_ksv_cnt = *buf;\n\t\tksv_count += vrl_ksv_cnt;\n\n\t\tvrl_sz = (vrl_ksv_cnt * DRM_HDCP_KSV_LEN) + 1;\n\t\tbuf += vrl_sz;\n\t\tparsed_bytes += vrl_sz;\n\t}\n\n\t \n\tif (parsed_bytes != vrls_length)\n\t\tksv_count = 0;\n\n\treturn ksv_count;\n}\n\nstatic u32 drm_hdcp_get_revoked_ksvs(const u8 *buf, u8 **revoked_ksv_list,\n\t\t\t\t     u32 vrls_length)\n{\n\tu32 vrl_ksv_cnt, vrl_ksv_sz, vrl_idx = 0;\n\tu32 parsed_bytes = 0, ksv_count = 0;\n\n\tdo {\n\t\tvrl_ksv_cnt = *buf;\n\t\tvrl_ksv_sz = vrl_ksv_cnt * DRM_HDCP_KSV_LEN;\n\n\t\tbuf++;\n\n\t\tDRM_DEBUG(\"vrl: %d, Revoked KSVs: %d\\n\", vrl_idx++,\n\t\t\t  vrl_ksv_cnt);\n\t\tmemcpy((*revoked_ksv_list) + (ksv_count * DRM_HDCP_KSV_LEN),\n\t\t       buf, vrl_ksv_sz);\n\n\t\tksv_count += vrl_ksv_cnt;\n\t\tbuf += vrl_ksv_sz;\n\n\t\tparsed_bytes += (vrl_ksv_sz + 1);\n\t} while (parsed_bytes < vrls_length);\n\n\treturn ksv_count;\n}\n\nstatic inline u32 get_vrl_length(const u8 *buf)\n{\n\treturn drm_hdcp_be24_to_cpu(buf);\n}\n\nstatic int drm_hdcp_parse_hdcp1_srm(const u8 *buf, size_t count,\n\t\t\t\t    u8 **revoked_ksv_list, u32 *revoked_ksv_cnt)\n{\n\tstruct hdcp_srm_header *header;\n\tu32 vrl_length, ksv_count;\n\n\tif (count < (sizeof(struct hdcp_srm_header) +\n\t    DRM_HDCP_1_4_VRL_LENGTH_SIZE + DRM_HDCP_1_4_DCP_SIG_SIZE)) {\n\t\tDRM_ERROR(\"Invalid blob length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\theader = (struct hdcp_srm_header *)buf;\n\tDRM_DEBUG(\"SRM ID: 0x%x, SRM Ver: 0x%x, SRM Gen No: 0x%x\\n\",\n\t\t  header->srm_id,\n\t\t  be16_to_cpu(header->srm_version), header->srm_gen_no);\n\n\tWARN_ON(header->reserved);\n\n\tbuf = buf + sizeof(*header);\n\tvrl_length = get_vrl_length(buf);\n\tif (count < (sizeof(struct hdcp_srm_header) + vrl_length) ||\n\t    vrl_length < (DRM_HDCP_1_4_VRL_LENGTH_SIZE +\n\t\t\t  DRM_HDCP_1_4_DCP_SIG_SIZE)) {\n\t\tDRM_ERROR(\"Invalid blob length or vrl length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvrl_length -= (DRM_HDCP_1_4_VRL_LENGTH_SIZE +\n\t\t       DRM_HDCP_1_4_DCP_SIG_SIZE);\n\n\tif (!vrl_length) {\n\t\tDRM_ERROR(\"No vrl found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuf += DRM_HDCP_1_4_VRL_LENGTH_SIZE;\n\tksv_count = drm_hdcp_get_revoked_ksv_count(buf, vrl_length);\n\tif (!ksv_count) {\n\t\tDRM_DEBUG(\"Revoked KSV count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\t*revoked_ksv_list = kcalloc(ksv_count, DRM_HDCP_KSV_LEN, GFP_KERNEL);\n\tif (!*revoked_ksv_list) {\n\t\tDRM_ERROR(\"Out of Memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (drm_hdcp_get_revoked_ksvs(buf, revoked_ksv_list,\n\t\t\t\t      vrl_length) != ksv_count) {\n\t\t*revoked_ksv_cnt = 0;\n\t\tkfree(*revoked_ksv_list);\n\t\treturn -EINVAL;\n\t}\n\n\t*revoked_ksv_cnt = ksv_count;\n\treturn 0;\n}\n\nstatic int drm_hdcp_parse_hdcp2_srm(const u8 *buf, size_t count,\n\t\t\t\t    u8 **revoked_ksv_list, u32 *revoked_ksv_cnt)\n{\n\tstruct hdcp_srm_header *header;\n\tu32 vrl_length, ksv_count, ksv_sz;\n\n\tif (count < (sizeof(struct hdcp_srm_header) +\n\t    DRM_HDCP_2_VRL_LENGTH_SIZE + DRM_HDCP_2_DCP_SIG_SIZE)) {\n\t\tDRM_ERROR(\"Invalid blob length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\theader = (struct hdcp_srm_header *)buf;\n\tDRM_DEBUG(\"SRM ID: 0x%x, SRM Ver: 0x%x, SRM Gen No: 0x%x\\n\",\n\t\t  header->srm_id & DRM_HDCP_SRM_ID_MASK,\n\t\t  be16_to_cpu(header->srm_version), header->srm_gen_no);\n\n\tif (header->reserved)\n\t\treturn -EINVAL;\n\n\tbuf = buf + sizeof(*header);\n\tvrl_length = get_vrl_length(buf);\n\n\tif (count < (sizeof(struct hdcp_srm_header) + vrl_length) ||\n\t    vrl_length < (DRM_HDCP_2_VRL_LENGTH_SIZE +\n\t    DRM_HDCP_2_DCP_SIG_SIZE)) {\n\t\tDRM_ERROR(\"Invalid blob length or vrl length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvrl_length -= (DRM_HDCP_2_VRL_LENGTH_SIZE +\n\t\t       DRM_HDCP_2_DCP_SIG_SIZE);\n\n\tif (!vrl_length) {\n\t\tDRM_ERROR(\"No vrl found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuf += DRM_HDCP_2_VRL_LENGTH_SIZE;\n\tksv_count = (*buf << 2) | DRM_HDCP_2_KSV_COUNT_2_LSBITS(*(buf + 1));\n\tif (!ksv_count) {\n\t\tDRM_DEBUG(\"Revoked KSV count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\t*revoked_ksv_list = kcalloc(ksv_count, DRM_HDCP_KSV_LEN, GFP_KERNEL);\n\tif (!*revoked_ksv_list) {\n\t\tDRM_ERROR(\"Out of Memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tksv_sz = ksv_count * DRM_HDCP_KSV_LEN;\n\tbuf += DRM_HDCP_2_NO_OF_DEV_PLUS_RESERVED_SZ;\n\n\tDRM_DEBUG(\"Revoked KSVs: %d\\n\", ksv_count);\n\tmemcpy(*revoked_ksv_list, buf, ksv_sz);\n\n\t*revoked_ksv_cnt = ksv_count;\n\treturn 0;\n}\n\nstatic inline bool is_srm_version_hdcp1(const u8 *buf)\n{\n\treturn *buf == (u8)(DRM_HDCP_1_4_SRM_ID << 4);\n}\n\nstatic inline bool is_srm_version_hdcp2(const u8 *buf)\n{\n\treturn *buf == (u8)(DRM_HDCP_2_SRM_ID << 4 | DRM_HDCP_2_INDICATOR);\n}\n\nstatic int drm_hdcp_srm_update(const u8 *buf, size_t count,\n\t\t\t       u8 **revoked_ksv_list, u32 *revoked_ksv_cnt)\n{\n\tif (count < sizeof(struct hdcp_srm_header))\n\t\treturn -EINVAL;\n\n\tif (is_srm_version_hdcp1(buf))\n\t\treturn drm_hdcp_parse_hdcp1_srm(buf, count, revoked_ksv_list,\n\t\t\t\t\t\trevoked_ksv_cnt);\n\telse if (is_srm_version_hdcp2(buf))\n\t\treturn drm_hdcp_parse_hdcp2_srm(buf, count, revoked_ksv_list,\n\t\t\t\t\t\trevoked_ksv_cnt);\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int drm_hdcp_request_srm(struct drm_device *drm_dev,\n\t\t\t\tu8 **revoked_ksv_list, u32 *revoked_ksv_cnt)\n{\n\tchar fw_name[36] = \"display_hdcp_srm.bin\";\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware_direct(&fw, (const char *)fw_name,\n\t\t\t\t      drm_dev->dev);\n\tif (ret < 0) {\n\t\t*revoked_ksv_cnt = 0;\n\t\t*revoked_ksv_list = NULL;\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tif (fw->size && fw->data)\n\t\tret = drm_hdcp_srm_update(fw->data, fw->size, revoked_ksv_list,\n\t\t\t\t\t  revoked_ksv_cnt);\n\nexit:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\n \nint drm_hdcp_check_ksvs_revoked(struct drm_device *drm_dev, u8 *ksvs,\n\t\t\t\tu32 ksv_count)\n{\n\tu32 revoked_ksv_cnt = 0, i, j;\n\tu8 *revoked_ksv_list = NULL;\n\tint ret = 0;\n\n\tret = drm_hdcp_request_srm(drm_dev, &revoked_ksv_list,\n\t\t\t\t   &revoked_ksv_cnt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < revoked_ksv_cnt; i++)\n\t\tfor  (j = 0; j < ksv_count; j++)\n\t\t\tif (!memcmp(&ksvs[j * DRM_HDCP_KSV_LEN],\n\t\t\t\t    &revoked_ksv_list[i * DRM_HDCP_KSV_LEN],\n\t\t\t\t    DRM_HDCP_KSV_LEN)) {\n\t\t\t\tDRM_DEBUG(\"Revoked KSV is \");\n\t\t\t\tdrm_hdcp_print_ksv(&ksvs[j * DRM_HDCP_KSV_LEN]);\n\t\t\t\tret++;\n\t\t\t}\n\n\tkfree(revoked_ksv_list);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(drm_hdcp_check_ksvs_revoked);\n\nstatic struct drm_prop_enum_list drm_cp_enum_list[] = {\n\t{ DRM_MODE_CONTENT_PROTECTION_UNDESIRED, \"Undesired\" },\n\t{ DRM_MODE_CONTENT_PROTECTION_DESIRED, \"Desired\" },\n\t{ DRM_MODE_CONTENT_PROTECTION_ENABLED, \"Enabled\" },\n};\nDRM_ENUM_NAME_FN(drm_get_content_protection_name, drm_cp_enum_list)\n\nstatic struct drm_prop_enum_list drm_hdcp_content_type_enum_list[] = {\n\t{ DRM_MODE_HDCP_CONTENT_TYPE0, \"HDCP Type0\" },\n\t{ DRM_MODE_HDCP_CONTENT_TYPE1, \"HDCP Type1\" },\n};\nDRM_ENUM_NAME_FN(drm_get_hdcp_content_type_name,\n\t\t drm_hdcp_content_type_enum_list)\n\n \nint drm_connector_attach_content_protection_property(\n\t\tstruct drm_connector *connector, bool hdcp_content_type)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_property *prop =\n\t\t\tdev->mode_config.content_protection_property;\n\n\tif (!prop)\n\t\tprop = drm_property_create_enum(dev, 0, \"Content Protection\",\n\t\t\t\t\t\tdrm_cp_enum_list,\n\t\t\t\t\t\tARRAY_SIZE(drm_cp_enum_list));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&connector->base, prop,\n\t\t\t\t   DRM_MODE_CONTENT_PROTECTION_UNDESIRED);\n\tdev->mode_config.content_protection_property = prop;\n\n\tif (!hdcp_content_type)\n\t\treturn 0;\n\n\tprop = dev->mode_config.hdcp_content_type_property;\n\tif (!prop)\n\t\tprop = drm_property_create_enum(dev, 0, \"HDCP Content Type\",\n\t\t\t\t\tdrm_hdcp_content_type_enum_list,\n\t\t\t\t\tARRAY_SIZE(\n\t\t\t\t\tdrm_hdcp_content_type_enum_list));\n\tif (!prop)\n\t\treturn -ENOMEM;\n\n\tdrm_object_attach_property(&connector->base, prop,\n\t\t\t\t   DRM_MODE_HDCP_CONTENT_TYPE0);\n\tdev->mode_config.hdcp_content_type_property = prop;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_connector_attach_content_protection_property);\n\n \nvoid drm_hdcp_update_content_protection(struct drm_connector *connector,\n\t\t\t\t\tu64 val)\n{\n\tstruct drm_device *dev = connector->dev;\n\tstruct drm_connector_state *state = connector->state;\n\n\tWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\n\tif (state->content_protection == val)\n\t\treturn;\n\n\tstate->content_protection = val;\n\tdrm_sysfs_connector_property_event(connector,\n\t\t\t\t\t   dev->mode_config.content_protection_property);\n}\nEXPORT_SYMBOL(drm_hdcp_update_content_protection);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}