{
  "module_name": "drm_dp_helper.c",
  "hash_id": "45c7b1b463964f433f870853449d1d0cf94afccf3c4d45b5e65ca67284cb431f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_dp_helper.c",
  "human_readable_source": " \n\n#include <linux/backlight.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/string_helpers.h>\n#include <linux/dynamic_debug.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/drm_edid.h>\n#include <drm/drm_print.h>\n#include <drm/drm_vblank.h>\n#include <drm/drm_panel.h>\n\n#include \"drm_dp_helper_internal.h\"\n\nDECLARE_DYNDBG_CLASSMAP(drm_debug_classes, DD_CLASS_TYPE_DISJOINT_BITS, 0,\n\t\t\t\"DRM_UT_CORE\",\n\t\t\t\"DRM_UT_DRIVER\",\n\t\t\t\"DRM_UT_KMS\",\n\t\t\t\"DRM_UT_PRIME\",\n\t\t\t\"DRM_UT_ATOMIC\",\n\t\t\t\"DRM_UT_VBL\",\n\t\t\t\"DRM_UT_STATE\",\n\t\t\t\"DRM_UT_LEASE\",\n\t\t\t\"DRM_UT_DP\",\n\t\t\t\"DRM_UT_DRMRES\");\n\nstruct dp_aux_backlight {\n\tstruct backlight_device *base;\n\tstruct drm_dp_aux *aux;\n\tstruct drm_edp_backlight_info info;\n\tbool enabled;\n};\n\n \n\n \nstatic u8 dp_link_status(const u8 link_status[DP_LINK_STATUS_SIZE], int r)\n{\n\treturn link_status[r - DP_LANE0_1_STATUS];\n}\n\nstatic u8 dp_get_lane_status(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t     int lane)\n{\n\tint i = DP_LANE0_1_STATUS + (lane >> 1);\n\tint s = (lane & 1) * 4;\n\tu8 l = dp_link_status(link_status, i);\n\n\treturn (l >> s) & 0xf;\n}\n\nbool drm_dp_channel_eq_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t  int lane_count)\n{\n\tu8 lane_align;\n\tu8 lane_status;\n\tint lane;\n\n\tlane_align = dp_link_status(link_status,\n\t\t\t\t    DP_LANE_ALIGN_STATUS_UPDATED);\n\tif ((lane_align & DP_INTERLANE_ALIGN_DONE) == 0)\n\t\treturn false;\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = dp_get_lane_status(link_status, lane);\n\t\tif ((lane_status & DP_CHANNEL_EQ_BITS) != DP_CHANNEL_EQ_BITS)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(drm_dp_channel_eq_ok);\n\nbool drm_dp_clock_recovery_ok(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t      int lane_count)\n{\n\tint lane;\n\tu8 lane_status;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = dp_get_lane_status(link_status, lane);\n\t\tif ((lane_status & DP_LANE_CR_DONE) == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(drm_dp_clock_recovery_ok);\n\nu8 drm_dp_get_adjust_request_voltage(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t     int lane)\n{\n\tint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\n\tint s = ((lane & 1) ?\n\t\t DP_ADJUST_VOLTAGE_SWING_LANE1_SHIFT :\n\t\t DP_ADJUST_VOLTAGE_SWING_LANE0_SHIFT);\n\tu8 l = dp_link_status(link_status, i);\n\n\treturn ((l >> s) & 0x3) << DP_TRAIN_VOLTAGE_SWING_SHIFT;\n}\nEXPORT_SYMBOL(drm_dp_get_adjust_request_voltage);\n\nu8 drm_dp_get_adjust_request_pre_emphasis(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t  int lane)\n{\n\tint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\n\tint s = ((lane & 1) ?\n\t\t DP_ADJUST_PRE_EMPHASIS_LANE1_SHIFT :\n\t\t DP_ADJUST_PRE_EMPHASIS_LANE0_SHIFT);\n\tu8 l = dp_link_status(link_status, i);\n\n\treturn ((l >> s) & 0x3) << DP_TRAIN_PRE_EMPHASIS_SHIFT;\n}\nEXPORT_SYMBOL(drm_dp_get_adjust_request_pre_emphasis);\n\n \nu8 drm_dp_get_adjust_tx_ffe_preset(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t   int lane)\n{\n\tint i = DP_ADJUST_REQUEST_LANE0_1 + (lane >> 1);\n\tint s = ((lane & 1) ?\n\t\t DP_ADJUST_TX_FFE_PRESET_LANE1_SHIFT :\n\t\t DP_ADJUST_TX_FFE_PRESET_LANE0_SHIFT);\n\tu8 l = dp_link_status(link_status, i);\n\n\treturn (l >> s) & 0xf;\n}\nEXPORT_SYMBOL(drm_dp_get_adjust_tx_ffe_preset);\n\n \nbool drm_dp_128b132b_lane_channel_eq_done(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\t  int lane_count)\n{\n\tu8 lane_align, lane_status;\n\tint lane;\n\n\tlane_align = dp_link_status(link_status, DP_LANE_ALIGN_STATUS_UPDATED);\n\tif (!(lane_align & DP_INTERLANE_ALIGN_DONE))\n\t\treturn false;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = dp_get_lane_status(link_status, lane);\n\t\tif (!(lane_status & DP_LANE_CHANNEL_EQ_DONE))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(drm_dp_128b132b_lane_channel_eq_done);\n\n \nbool drm_dp_128b132b_lane_symbol_locked(const u8 link_status[DP_LINK_STATUS_SIZE],\n\t\t\t\t\tint lane_count)\n{\n\tu8 lane_status;\n\tint lane;\n\n\tfor (lane = 0; lane < lane_count; lane++) {\n\t\tlane_status = dp_get_lane_status(link_status, lane);\n\t\tif (!(lane_status & DP_LANE_SYMBOL_LOCKED))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL(drm_dp_128b132b_lane_symbol_locked);\n\n \nbool drm_dp_128b132b_eq_interlane_align_done(const u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tu8 status = dp_link_status(link_status, DP_LANE_ALIGN_STATUS_UPDATED);\n\n\treturn status & DP_128B132B_DPRX_EQ_INTERLANE_ALIGN_DONE;\n}\nEXPORT_SYMBOL(drm_dp_128b132b_eq_interlane_align_done);\n\n \nbool drm_dp_128b132b_cds_interlane_align_done(const u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tu8 status = dp_link_status(link_status, DP_LANE_ALIGN_STATUS_UPDATED);\n\n\treturn status & DP_128B132B_DPRX_CDS_INTERLANE_ALIGN_DONE;\n}\nEXPORT_SYMBOL(drm_dp_128b132b_cds_interlane_align_done);\n\n \nbool drm_dp_128b132b_link_training_failed(const u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tu8 status = dp_link_status(link_status, DP_LANE_ALIGN_STATUS_UPDATED);\n\n\treturn status & DP_128B132B_LT_FAILED;\n}\nEXPORT_SYMBOL(drm_dp_128b132b_link_training_failed);\n\nstatic int __8b10b_clock_recovery_delay_us(const struct drm_dp_aux *aux, u8 rd_interval)\n{\n\tif (rd_interval > 4)\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: invalid AUX interval 0x%02x (max 4)\\n\",\n\t\t\t    aux->name, rd_interval);\n\n\tif (rd_interval == 0)\n\t\treturn 100;\n\n\treturn rd_interval * 4 * USEC_PER_MSEC;\n}\n\nstatic int __8b10b_channel_eq_delay_us(const struct drm_dp_aux *aux, u8 rd_interval)\n{\n\tif (rd_interval > 4)\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: invalid AUX interval 0x%02x (max 4)\\n\",\n\t\t\t    aux->name, rd_interval);\n\n\tif (rd_interval == 0)\n\t\treturn 400;\n\n\treturn rd_interval * 4 * USEC_PER_MSEC;\n}\n\nstatic int __128b132b_channel_eq_delay_us(const struct drm_dp_aux *aux, u8 rd_interval)\n{\n\tswitch (rd_interval) {\n\tdefault:\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: invalid AUX interval 0x%02x\\n\",\n\t\t\t    aux->name, rd_interval);\n\t\tfallthrough;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_400_US:\n\t\treturn 400;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_4_MS:\n\t\treturn 4000;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_8_MS:\n\t\treturn 8000;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_12_MS:\n\t\treturn 12000;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_16_MS:\n\t\treturn 16000;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_32_MS:\n\t\treturn 32000;\n\tcase DP_128B132B_TRAINING_AUX_RD_INTERVAL_64_MS:\n\t\treturn 64000;\n\t}\n}\n\n \nstatic int __read_delay(struct drm_dp_aux *aux, const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\tenum drm_dp_phy dp_phy, bool uhbr, bool cr)\n{\n\tint (*parse)(const struct drm_dp_aux *aux, u8 rd_interval);\n\tunsigned int offset;\n\tu8 rd_interval, mask;\n\n\tif (dp_phy == DP_PHY_DPRX) {\n\t\tif (uhbr) {\n\t\t\tif (cr)\n\t\t\t\treturn 100;\n\n\t\t\toffset = DP_128B132B_TRAINING_AUX_RD_INTERVAL;\n\t\t\tmask = DP_128B132B_TRAINING_AUX_RD_INTERVAL_MASK;\n\t\t\tparse = __128b132b_channel_eq_delay_us;\n\t\t} else {\n\t\t\tif (cr && dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14)\n\t\t\t\treturn 100;\n\n\t\t\toffset = DP_TRAINING_AUX_RD_INTERVAL;\n\t\t\tmask = DP_TRAINING_AUX_RD_MASK;\n\t\t\tif (cr)\n\t\t\t\tparse = __8b10b_clock_recovery_delay_us;\n\t\t\telse\n\t\t\t\tparse = __8b10b_channel_eq_delay_us;\n\t\t}\n\t} else {\n\t\tif (uhbr) {\n\t\t\toffset = DP_128B132B_TRAINING_AUX_RD_INTERVAL_PHY_REPEATER(dp_phy);\n\t\t\tmask = DP_128B132B_TRAINING_AUX_RD_INTERVAL_MASK;\n\t\t\tparse = __128b132b_channel_eq_delay_us;\n\t\t} else {\n\t\t\tif (cr)\n\t\t\t\treturn 100;\n\n\t\t\toffset = DP_TRAINING_AUX_RD_INTERVAL_PHY_REPEATER(dp_phy);\n\t\t\tmask = DP_TRAINING_AUX_RD_MASK;\n\t\t\tparse = __8b10b_channel_eq_delay_us;\n\t\t}\n\t}\n\n\tif (offset < DP_RECEIVER_CAP_SIZE) {\n\t\trd_interval = dpcd[offset];\n\t} else {\n\t\tif (drm_dp_dpcd_readb(aux, offset, &rd_interval) != 1) {\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: failed rd interval read\\n\",\n\t\t\t\t    aux->name);\n\t\t\t \n\t\t\treturn 400;\n\t\t}\n\t}\n\n\treturn parse(aux, rd_interval & mask);\n}\n\nint drm_dp_read_clock_recovery_delay(struct drm_dp_aux *aux, const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t     enum drm_dp_phy dp_phy, bool uhbr)\n{\n\treturn __read_delay(aux, dpcd, dp_phy, uhbr, true);\n}\nEXPORT_SYMBOL(drm_dp_read_clock_recovery_delay);\n\nint drm_dp_read_channel_eq_delay(struct drm_dp_aux *aux, const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t enum drm_dp_phy dp_phy, bool uhbr)\n{\n\treturn __read_delay(aux, dpcd, dp_phy, uhbr, false);\n}\nEXPORT_SYMBOL(drm_dp_read_channel_eq_delay);\n\n \nint drm_dp_128b132b_read_aux_rd_interval(struct drm_dp_aux *aux)\n{\n\tint unit;\n\tu8 val;\n\n\tif (drm_dp_dpcd_readb(aux, DP_128B132B_TRAINING_AUX_RD_INTERVAL, &val) != 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: failed rd interval read\\n\",\n\t\t\taux->name);\n\t\t \n\t\tval = DP_128B132B_TRAINING_AUX_RD_INTERVAL_MASK;\n\t}\n\n\tunit = (val & DP_128B132B_TRAINING_AUX_RD_INTERVAL_1MS_UNIT) ? 1 : 2;\n\tval &= DP_128B132B_TRAINING_AUX_RD_INTERVAL_MASK;\n\n\treturn (val + 1) * unit * 1000;\n}\nEXPORT_SYMBOL(drm_dp_128b132b_read_aux_rd_interval);\n\nvoid drm_dp_link_train_clock_recovery_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\t    const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tu8 rd_interval = dpcd[DP_TRAINING_AUX_RD_INTERVAL] &\n\t\tDP_TRAINING_AUX_RD_MASK;\n\tint delay_us;\n\n\tif (dpcd[DP_DPCD_REV] >= DP_DPCD_REV_14)\n\t\tdelay_us = 100;\n\telse\n\t\tdelay_us = __8b10b_clock_recovery_delay_us(aux, rd_interval);\n\n\tusleep_range(delay_us, delay_us * 2);\n}\nEXPORT_SYMBOL(drm_dp_link_train_clock_recovery_delay);\n\nstatic void __drm_dp_link_train_channel_eq_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\t\t u8 rd_interval)\n{\n\tint delay_us = __8b10b_channel_eq_delay_us(aux, rd_interval);\n\n\tusleep_range(delay_us, delay_us * 2);\n}\n\nvoid drm_dp_link_train_channel_eq_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\t__drm_dp_link_train_channel_eq_delay(aux,\n\t\t\t\t\t     dpcd[DP_TRAINING_AUX_RD_INTERVAL] &\n\t\t\t\t\t     DP_TRAINING_AUX_RD_MASK);\n}\nEXPORT_SYMBOL(drm_dp_link_train_channel_eq_delay);\n\n \nconst char *drm_dp_phy_name(enum drm_dp_phy dp_phy)\n{\n\tstatic const char * const phy_names[] = {\n\t\t[DP_PHY_DPRX] = \"DPRX\",\n\t\t[DP_PHY_LTTPR1] = \"LTTPR 1\",\n\t\t[DP_PHY_LTTPR2] = \"LTTPR 2\",\n\t\t[DP_PHY_LTTPR3] = \"LTTPR 3\",\n\t\t[DP_PHY_LTTPR4] = \"LTTPR 4\",\n\t\t[DP_PHY_LTTPR5] = \"LTTPR 5\",\n\t\t[DP_PHY_LTTPR6] = \"LTTPR 6\",\n\t\t[DP_PHY_LTTPR7] = \"LTTPR 7\",\n\t\t[DP_PHY_LTTPR8] = \"LTTPR 8\",\n\t};\n\n\tif (dp_phy < 0 || dp_phy >= ARRAY_SIZE(phy_names) ||\n\t    WARN_ON(!phy_names[dp_phy]))\n\t\treturn \"<INVALID DP PHY>\";\n\n\treturn phy_names[dp_phy];\n}\nEXPORT_SYMBOL(drm_dp_phy_name);\n\nvoid drm_dp_lttpr_link_train_clock_recovery_delay(void)\n{\n\tusleep_range(100, 200);\n}\nEXPORT_SYMBOL(drm_dp_lttpr_link_train_clock_recovery_delay);\n\nstatic u8 dp_lttpr_phy_cap(const u8 phy_cap[DP_LTTPR_PHY_CAP_SIZE], int r)\n{\n\treturn phy_cap[r - DP_TRAINING_AUX_RD_INTERVAL_PHY_REPEATER1];\n}\n\nvoid drm_dp_lttpr_link_train_channel_eq_delay(const struct drm_dp_aux *aux,\n\t\t\t\t\t      const u8 phy_cap[DP_LTTPR_PHY_CAP_SIZE])\n{\n\tu8 interval = dp_lttpr_phy_cap(phy_cap,\n\t\t\t\t       DP_TRAINING_AUX_RD_INTERVAL_PHY_REPEATER1) &\n\t\t      DP_TRAINING_AUX_RD_MASK;\n\n\t__drm_dp_link_train_channel_eq_delay(aux, interval);\n}\nEXPORT_SYMBOL(drm_dp_lttpr_link_train_channel_eq_delay);\n\nu8 drm_dp_link_rate_to_bw_code(int link_rate)\n{\n\tswitch (link_rate) {\n\tcase 1000000:\n\t\treturn DP_LINK_BW_10;\n\tcase 1350000:\n\t\treturn DP_LINK_BW_13_5;\n\tcase 2000000:\n\t\treturn DP_LINK_BW_20;\n\tdefault:\n\t\t \n\t\treturn link_rate / 27000;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_link_rate_to_bw_code);\n\nint drm_dp_bw_code_to_link_rate(u8 link_bw)\n{\n\tswitch (link_bw) {\n\tcase DP_LINK_BW_10:\n\t\treturn 1000000;\n\tcase DP_LINK_BW_13_5:\n\t\treturn 1350000;\n\tcase DP_LINK_BW_20:\n\t\treturn 2000000;\n\tdefault:\n\t\t \n\t\treturn link_bw * 27000;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_bw_code_to_link_rate);\n\n#define AUX_RETRY_INTERVAL 500  \n\nstatic inline void\ndrm_dp_dump_access(const struct drm_dp_aux *aux,\n\t\t   u8 request, uint offset, void *buffer, int ret)\n{\n\tconst char *arrow = request == DP_AUX_NATIVE_READ ? \"->\" : \"<-\";\n\n\tif (ret > 0)\n\t\tdrm_dbg_dp(aux->drm_dev, \"%s: 0x%05x AUX %s (ret=%3d) %*ph\\n\",\n\t\t\t   aux->name, offset, arrow, ret, min(ret, 20), buffer);\n\telse\n\t\tdrm_dbg_dp(aux->drm_dev, \"%s: 0x%05x AUX %s (ret=%3d)\\n\",\n\t\t\t   aux->name, offset, arrow, ret);\n}\n\n \n\nstatic int drm_dp_dpcd_access(struct drm_dp_aux *aux, u8 request,\n\t\t\t      unsigned int offset, void *buffer, size_t size)\n{\n\tstruct drm_dp_aux_msg msg;\n\tunsigned int retry, native_reply;\n\tint err = 0, ret = 0;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.address = offset;\n\tmsg.request = request;\n\tmsg.buffer = buffer;\n\tmsg.size = size;\n\n\tmutex_lock(&aux->hw_mutex);\n\n\t \n\tfor (retry = 0; retry < 32; retry++) {\n\t\tif (ret != 0 && ret != -ETIMEDOUT) {\n\t\t\tusleep_range(AUX_RETRY_INTERVAL,\n\t\t\t\t     AUX_RETRY_INTERVAL + 100);\n\t\t}\n\n\t\tret = aux->transfer(aux, &msg);\n\t\tif (ret >= 0) {\n\t\t\tnative_reply = msg.reply & DP_AUX_NATIVE_REPLY_MASK;\n\t\t\tif (native_reply == DP_AUX_NATIVE_REPLY_ACK) {\n\t\t\t\tif (ret == size)\n\t\t\t\t\tgoto unlock;\n\n\t\t\t\tret = -EPROTO;\n\t\t\t} else\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t \n\t\tif (!err)\n\t\t\terr = ret;\n\t}\n\n\tdrm_dbg_kms(aux->drm_dev, \"%s: Too many retries, giving up. First error: %d\\n\",\n\t\t    aux->name, err);\n\tret = err;\n\nunlock:\n\tmutex_unlock(&aux->hw_mutex);\n\treturn ret;\n}\n\n \nint drm_dp_dpcd_probe(struct drm_dp_aux *aux, unsigned int offset)\n{\n\tu8 buffer;\n\tint ret;\n\n\tret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset, &buffer, 1);\n\tWARN_ON(ret == 0);\n\n\tdrm_dp_dump_access(aux, DP_AUX_NATIVE_READ, offset, &buffer, ret);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL(drm_dp_dpcd_probe);\n\n \nssize_t drm_dp_dpcd_read(struct drm_dp_aux *aux, unsigned int offset,\n\t\t\t void *buffer, size_t size)\n{\n\tint ret;\n\n\t \n\tif (!aux->is_remote) {\n\t\tret = drm_dp_dpcd_probe(aux, DP_DPCD_REV);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (aux->is_remote)\n\t\tret = drm_dp_mst_dpcd_read(aux, offset, buffer, size);\n\telse\n\t\tret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_READ, offset,\n\t\t\t\t\t buffer, size);\n\n\tdrm_dp_dump_access(aux, DP_AUX_NATIVE_READ, offset, buffer, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_dp_dpcd_read);\n\n \nssize_t drm_dp_dpcd_write(struct drm_dp_aux *aux, unsigned int offset,\n\t\t\t  void *buffer, size_t size)\n{\n\tint ret;\n\n\tif (aux->is_remote)\n\t\tret = drm_dp_mst_dpcd_write(aux, offset, buffer, size);\n\telse\n\t\tret = drm_dp_dpcd_access(aux, DP_AUX_NATIVE_WRITE, offset,\n\t\t\t\t\t buffer, size);\n\n\tdrm_dp_dump_access(aux, DP_AUX_NATIVE_WRITE, offset, buffer, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_dp_dpcd_write);\n\n \nint drm_dp_dpcd_read_link_status(struct drm_dp_aux *aux,\n\t\t\t\t u8 status[DP_LINK_STATUS_SIZE])\n{\n\treturn drm_dp_dpcd_read(aux, DP_LANE0_1_STATUS, status,\n\t\t\t\tDP_LINK_STATUS_SIZE);\n}\nEXPORT_SYMBOL(drm_dp_dpcd_read_link_status);\n\n \nint drm_dp_dpcd_read_phy_link_status(struct drm_dp_aux *aux,\n\t\t\t\t     enum drm_dp_phy dp_phy,\n\t\t\t\t     u8 link_status[DP_LINK_STATUS_SIZE])\n{\n\tint ret;\n\n\tif (dp_phy == DP_PHY_DPRX) {\n\t\tret = drm_dp_dpcd_read(aux,\n\t\t\t\t       DP_LANE0_1_STATUS,\n\t\t\t\t       link_status,\n\t\t\t\t       DP_LINK_STATUS_SIZE);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tWARN_ON(ret != DP_LINK_STATUS_SIZE);\n\n\t\treturn 0;\n\t}\n\n\tret = drm_dp_dpcd_read(aux,\n\t\t\t       DP_LANE0_1_STATUS_PHY_REPEATER(dp_phy),\n\t\t\t       link_status,\n\t\t\t       DP_LINK_STATUS_SIZE - 1);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tWARN_ON(ret != DP_LINK_STATUS_SIZE - 1);\n\n\t \n\tmemmove(&link_status[DP_SINK_STATUS - DP_LANE0_1_STATUS + 1],\n\t\t&link_status[DP_SINK_STATUS - DP_LANE0_1_STATUS],\n\t\tDP_LINK_STATUS_SIZE - (DP_SINK_STATUS - DP_LANE0_1_STATUS) - 1);\n\tlink_status[DP_SINK_STATUS - DP_LANE0_1_STATUS] = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_dpcd_read_phy_link_status);\n\nstatic bool is_edid_digital_input_dp(const struct edid *edid)\n{\n\treturn edid && edid->revision >= 4 &&\n\t\tedid->input & DRM_EDID_INPUT_DIGITAL &&\n\t\t(edid->input & DRM_EDID_DIGITAL_TYPE_MASK) == DRM_EDID_DIGITAL_TYPE_DP;\n}\n\n \nbool drm_dp_downstream_is_type(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       const u8 port_cap[4], u8 type)\n{\n\treturn drm_dp_is_branch(dpcd) &&\n\t\tdpcd[DP_DPCD_REV] >= 0x11 &&\n\t\t(port_cap[0] & DP_DS_PORT_TYPE_MASK) == type;\n}\nEXPORT_SYMBOL(drm_dp_downstream_is_type);\n\n \nbool drm_dp_downstream_is_tmds(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       const u8 port_cap[4],\n\t\t\t       const struct edid *edid)\n{\n\tif (dpcd[DP_DPCD_REV] < 0x11) {\n\t\tswitch (dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_TYPE_MASK) {\n\t\tcase DP_DWN_STRM_PORT_TYPE_TMDS:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_DP_DUALMODE:\n\t\tif (is_edid_digital_input_dp(edid))\n\t\t\treturn false;\n\t\tfallthrough;\n\tcase DP_DS_PORT_TYPE_DVI:\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_is_tmds);\n\n \nbool drm_dp_send_real_edid_checksum(struct drm_dp_aux *aux,\n\t\t\t\t    u8 real_edid_checksum)\n{\n\tu8 link_edid_read = 0, auto_test_req = 0, test_resp = 0;\n\n\tif (drm_dp_dpcd_read(aux, DP_DEVICE_SERVICE_IRQ_VECTOR,\n\t\t\t     &auto_test_req, 1) < 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: DPCD failed read at register 0x%x\\n\",\n\t\t\taux->name, DP_DEVICE_SERVICE_IRQ_VECTOR);\n\t\treturn false;\n\t}\n\tauto_test_req &= DP_AUTOMATED_TEST_REQUEST;\n\n\tif (drm_dp_dpcd_read(aux, DP_TEST_REQUEST, &link_edid_read, 1) < 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: DPCD failed read at register 0x%x\\n\",\n\t\t\taux->name, DP_TEST_REQUEST);\n\t\treturn false;\n\t}\n\tlink_edid_read &= DP_TEST_LINK_EDID_READ;\n\n\tif (!auto_test_req || !link_edid_read) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Source DUT does not support TEST_EDID_READ\\n\",\n\t\t\t    aux->name);\n\t\treturn false;\n\t}\n\n\tif (drm_dp_dpcd_write(aux, DP_DEVICE_SERVICE_IRQ_VECTOR,\n\t\t\t      &auto_test_req, 1) < 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: DPCD failed write at register 0x%x\\n\",\n\t\t\taux->name, DP_DEVICE_SERVICE_IRQ_VECTOR);\n\t\treturn false;\n\t}\n\n\t \n\tif (drm_dp_dpcd_write(aux, DP_TEST_EDID_CHECKSUM,\n\t\t\t      &real_edid_checksum, 1) < 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: DPCD failed write at register 0x%x\\n\",\n\t\t\taux->name, DP_TEST_EDID_CHECKSUM);\n\t\treturn false;\n\t}\n\n\ttest_resp |= DP_TEST_EDID_CHECKSUM_WRITE;\n\tif (drm_dp_dpcd_write(aux, DP_TEST_RESPONSE, &test_resp, 1) < 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: DPCD failed write at register 0x%x\\n\",\n\t\t\taux->name, DP_TEST_RESPONSE);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_dp_send_real_edid_checksum);\n\nstatic u8 drm_dp_downstream_port_count(const u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tu8 port_count = dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_PORT_COUNT_MASK;\n\n\tif (dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE && port_count > 4)\n\t\tport_count = 4;\n\n\treturn port_count;\n}\n\nstatic int drm_dp_read_extended_dpcd_caps(struct drm_dp_aux *aux,\n\t\t\t\t\t  u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tu8 dpcd_ext[DP_RECEIVER_CAP_SIZE];\n\tint ret;\n\n\t \n\tif (!(dpcd[DP_TRAINING_AUX_RD_INTERVAL] &\n\t      DP_EXTENDED_RECEIVER_CAP_FIELD_PRESENT))\n\t\treturn 0;\n\n\tret = drm_dp_dpcd_read(aux, DP_DP13_DPCD_REV, &dpcd_ext,\n\t\t\t       sizeof(dpcd_ext));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(dpcd_ext))\n\t\treturn -EIO;\n\n\tif (dpcd[DP_DPCD_REV] > dpcd_ext[DP_DPCD_REV]) {\n\t\tdrm_dbg_kms(aux->drm_dev,\n\t\t\t    \"%s: Extended DPCD rev less than base DPCD rev (%d > %d)\\n\",\n\t\t\t    aux->name, dpcd[DP_DPCD_REV], dpcd_ext[DP_DPCD_REV]);\n\t\treturn 0;\n\t}\n\n\tif (!memcmp(dpcd, dpcd_ext, sizeof(dpcd_ext)))\n\t\treturn 0;\n\n\tdrm_dbg_kms(aux->drm_dev, \"%s: Base DPCD: %*ph\\n\", aux->name, DP_RECEIVER_CAP_SIZE, dpcd);\n\n\tmemcpy(dpcd, dpcd_ext, sizeof(dpcd_ext));\n\n\treturn 0;\n}\n\n \nint drm_dp_read_dpcd_caps(struct drm_dp_aux *aux,\n\t\t\t  u8 dpcd[DP_RECEIVER_CAP_SIZE])\n{\n\tint ret;\n\n\tret = drm_dp_dpcd_read(aux, DP_DPCD_REV, dpcd, DP_RECEIVER_CAP_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != DP_RECEIVER_CAP_SIZE || dpcd[DP_DPCD_REV] == 0)\n\t\treturn -EIO;\n\n\tret = drm_dp_read_extended_dpcd_caps(aux, dpcd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_dbg_kms(aux->drm_dev, \"%s: DPCD: %*ph\\n\", aux->name, DP_RECEIVER_CAP_SIZE, dpcd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_dp_read_dpcd_caps);\n\n \nint drm_dp_read_downstream_info(struct drm_dp_aux *aux,\n\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\tu8 downstream_ports[DP_MAX_DOWNSTREAM_PORTS])\n{\n\tint ret;\n\tu8 len;\n\n\tmemset(downstream_ports, 0, DP_MAX_DOWNSTREAM_PORTS);\n\n\t \n\tif (!drm_dp_is_branch(dpcd) || dpcd[DP_DPCD_REV] == DP_DPCD_REV_10)\n\t\treturn 0;\n\n\t \n\tlen = drm_dp_downstream_port_count(dpcd);\n\tif (!len)\n\t\treturn 0;\n\n\tif (dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE)\n\t\tlen *= 4;\n\n\tret = drm_dp_dpcd_read(aux, DP_DOWNSTREAM_PORT_0, downstream_ports, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != len)\n\t\treturn -EIO;\n\n\tdrm_dbg_kms(aux->drm_dev, \"%s: DPCD DFP: %*ph\\n\", aux->name, len, downstream_ports);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_read_downstream_info);\n\n \nint drm_dp_downstream_max_dotclock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t   const u8 port_cap[4])\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn 0;\n\n\tif (dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn 0;\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_VGA:\n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn 0;\n\t\treturn port_cap[1] * 8000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_max_dotclock);\n\n \nint drm_dp_downstream_max_tmds_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t     const u8 port_cap[4],\n\t\t\t\t     const struct edid *edid)\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn 0;\n\n\tif (dpcd[DP_DPCD_REV] < 0x11) {\n\t\tswitch (dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_TYPE_MASK) {\n\t\tcase DP_DWN_STRM_PORT_TYPE_TMDS:\n\t\t\treturn 165000;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_DP_DUALMODE:\n\t\tif (is_edid_digital_input_dp(edid))\n\t\t\treturn 0;\n\t\t \n\t\tfallthrough;\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\t  \n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn 300000;\n\t\treturn port_cap[1] * 2500;\n\tcase DP_DS_PORT_TYPE_DVI:\n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn 165000;\n\t\t \n\t\treturn port_cap[1] * 2500;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_max_tmds_clock);\n\n \nint drm_dp_downstream_min_tmds_clock(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t     const u8 port_cap[4],\n\t\t\t\t     const struct edid *edid)\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn 0;\n\n\tif (dpcd[DP_DPCD_REV] < 0x11) {\n\t\tswitch (dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_TYPE_MASK) {\n\t\tcase DP_DWN_STRM_PORT_TYPE_TMDS:\n\t\t\treturn 25000;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_DP_DUALMODE:\n\t\tif (is_edid_digital_input_dp(edid))\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase DP_DS_PORT_TYPE_DVI:\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\t \n\t\treturn 25000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_min_tmds_clock);\n\n \nint drm_dp_downstream_max_bpc(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t      const u8 port_cap[4],\n\t\t\t      const struct edid *edid)\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn 0;\n\n\tif (dpcd[DP_DPCD_REV] < 0x11) {\n\t\tswitch (dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_TYPE_MASK) {\n\t\tcase DP_DWN_STRM_PORT_TYPE_DP:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn 8;\n\t\t}\n\t}\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_DP:\n\t\treturn 0;\n\tcase DP_DS_PORT_TYPE_DP_DUALMODE:\n\t\tif (is_edid_digital_input_dp(edid))\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase DP_DS_PORT_TYPE_HDMI:\n\tcase DP_DS_PORT_TYPE_DVI:\n\tcase DP_DS_PORT_TYPE_VGA:\n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn 8;\n\n\t\tswitch (port_cap[2] & DP_DS_MAX_BPC_MASK) {\n\t\tcase DP_DS_8BPC:\n\t\t\treturn 8;\n\t\tcase DP_DS_10BPC:\n\t\t\treturn 10;\n\t\tcase DP_DS_12BPC:\n\t\t\treturn 12;\n\t\tcase DP_DS_16BPC:\n\t\t\treturn 16;\n\t\tdefault:\n\t\t\treturn 8;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 8;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_max_bpc);\n\n \nbool drm_dp_downstream_420_passthrough(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t       const u8 port_cap[4])\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn false;\n\n\tif (dpcd[DP_DPCD_REV] < 0x13)\n\t\treturn false;\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_DP:\n\t\treturn true;\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn false;\n\n\t\treturn port_cap[3] & DP_DS_HDMI_YCBCR420_PASS_THROUGH;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_420_passthrough);\n\n \nbool drm_dp_downstream_444_to_420_conversion(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t\t     const u8 port_cap[4])\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn false;\n\n\tif (dpcd[DP_DPCD_REV] < 0x13)\n\t\treturn false;\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn false;\n\n\t\treturn port_cap[3] & DP_DS_HDMI_YCBCR444_TO_420_CONV;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_444_to_420_conversion);\n\n \nbool drm_dp_downstream_rgb_to_ycbcr_conversion(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t\t       const u8 port_cap[4],\n\t\t\t\t\t       u8 color_spc)\n{\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn false;\n\n\tif (dpcd[DP_DPCD_REV] < 0x13)\n\t\treturn false;\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\tif ((dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DETAILED_CAP_INFO_AVAILABLE) == 0)\n\t\t\treturn false;\n\n\t\treturn port_cap[3] & color_spc;\n\tdefault:\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_rgb_to_ycbcr_conversion);\n\n \nstruct drm_display_mode *\ndrm_dp_downstream_mode(struct drm_device *dev,\n\t\t       const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t       const u8 port_cap[4])\n\n{\n\tu8 vic;\n\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn NULL;\n\n\tif (dpcd[DP_DPCD_REV] < 0x11)\n\t\treturn NULL;\n\n\tswitch (port_cap[0] & DP_DS_PORT_TYPE_MASK) {\n\tcase DP_DS_PORT_TYPE_NON_EDID:\n\t\tswitch (port_cap[0] & DP_DS_NON_EDID_MASK) {\n\t\tcase DP_DS_NON_EDID_720x480i_60:\n\t\t\tvic = 6;\n\t\t\tbreak;\n\t\tcase DP_DS_NON_EDID_720x480i_50:\n\t\t\tvic = 21;\n\t\t\tbreak;\n\t\tcase DP_DS_NON_EDID_1920x1080i_60:\n\t\t\tvic = 5;\n\t\t\tbreak;\n\t\tcase DP_DS_NON_EDID_1920x1080i_50:\n\t\t\tvic = 20;\n\t\t\tbreak;\n\t\tcase DP_DS_NON_EDID_1280x720_60:\n\t\t\tvic = 4;\n\t\t\tbreak;\n\t\tcase DP_DS_NON_EDID_1280x720_50:\n\t\t\tvic = 19;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t\t}\n\t\treturn drm_display_mode_from_cea_vic(dev, vic);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_mode);\n\n \nint drm_dp_downstream_id(struct drm_dp_aux *aux, char id[6])\n{\n\treturn drm_dp_dpcd_read(aux, DP_BRANCH_ID, id, 6);\n}\nEXPORT_SYMBOL(drm_dp_downstream_id);\n\n \nvoid drm_dp_downstream_debug(struct seq_file *m,\n\t\t\t     const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t     const u8 port_cap[4],\n\t\t\t     const struct edid *edid,\n\t\t\t     struct drm_dp_aux *aux)\n{\n\tbool detailed_cap_info = dpcd[DP_DOWNSTREAMPORT_PRESENT] &\n\t\t\t\t DP_DETAILED_CAP_INFO_AVAILABLE;\n\tint clk;\n\tint bpc;\n\tchar id[7];\n\tint len;\n\tuint8_t rev[2];\n\tint type = port_cap[0] & DP_DS_PORT_TYPE_MASK;\n\tbool branch_device = drm_dp_is_branch(dpcd);\n\n\tseq_printf(m, \"\\tDP branch device present: %s\\n\",\n\t\t   str_yes_no(branch_device));\n\n\tif (!branch_device)\n\t\treturn;\n\n\tswitch (type) {\n\tcase DP_DS_PORT_TYPE_DP:\n\t\tseq_puts(m, \"\\t\\tType: DisplayPort\\n\");\n\t\tbreak;\n\tcase DP_DS_PORT_TYPE_VGA:\n\t\tseq_puts(m, \"\\t\\tType: VGA\\n\");\n\t\tbreak;\n\tcase DP_DS_PORT_TYPE_DVI:\n\t\tseq_puts(m, \"\\t\\tType: DVI\\n\");\n\t\tbreak;\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\tseq_puts(m, \"\\t\\tType: HDMI\\n\");\n\t\tbreak;\n\tcase DP_DS_PORT_TYPE_NON_EDID:\n\t\tseq_puts(m, \"\\t\\tType: others without EDID support\\n\");\n\t\tbreak;\n\tcase DP_DS_PORT_TYPE_DP_DUALMODE:\n\t\tseq_puts(m, \"\\t\\tType: DP++\\n\");\n\t\tbreak;\n\tcase DP_DS_PORT_TYPE_WIRELESS:\n\t\tseq_puts(m, \"\\t\\tType: Wireless\\n\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(m, \"\\t\\tType: N/A\\n\");\n\t}\n\n\tmemset(id, 0, sizeof(id));\n\tdrm_dp_downstream_id(aux, id);\n\tseq_printf(m, \"\\t\\tID: %s\\n\", id);\n\n\tlen = drm_dp_dpcd_read(aux, DP_BRANCH_HW_REV, &rev[0], 1);\n\tif (len > 0)\n\t\tseq_printf(m, \"\\t\\tHW: %d.%d\\n\",\n\t\t\t   (rev[0] & 0xf0) >> 4, rev[0] & 0xf);\n\n\tlen = drm_dp_dpcd_read(aux, DP_BRANCH_SW_REV, rev, 2);\n\tif (len > 0)\n\t\tseq_printf(m, \"\\t\\tSW: %d.%d\\n\", rev[0], rev[1]);\n\n\tif (detailed_cap_info) {\n\t\tclk = drm_dp_downstream_max_dotclock(dpcd, port_cap);\n\t\tif (clk > 0)\n\t\t\tseq_printf(m, \"\\t\\tMax dot clock: %d kHz\\n\", clk);\n\n\t\tclk = drm_dp_downstream_max_tmds_clock(dpcd, port_cap, edid);\n\t\tif (clk > 0)\n\t\t\tseq_printf(m, \"\\t\\tMax TMDS clock: %d kHz\\n\", clk);\n\n\t\tclk = drm_dp_downstream_min_tmds_clock(dpcd, port_cap, edid);\n\t\tif (clk > 0)\n\t\t\tseq_printf(m, \"\\t\\tMin TMDS clock: %d kHz\\n\", clk);\n\n\t\tbpc = drm_dp_downstream_max_bpc(dpcd, port_cap, edid);\n\n\t\tif (bpc > 0)\n\t\t\tseq_printf(m, \"\\t\\tMax bpc: %d\\n\", bpc);\n\t}\n}\nEXPORT_SYMBOL(drm_dp_downstream_debug);\n\n \nenum drm_mode_subconnector\ndrm_dp_subconnector_type(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t const u8 port_cap[4])\n{\n\tint type;\n\tif (!drm_dp_is_branch(dpcd))\n\t\treturn DRM_MODE_SUBCONNECTOR_Native;\n\t \n\tif (dpcd[DP_DPCD_REV] == DP_DPCD_REV_10) {\n\t\ttype = dpcd[DP_DOWNSTREAMPORT_PRESENT] &\n\t\t       DP_DWN_STRM_PORT_TYPE_MASK;\n\n\t\tswitch (type) {\n\t\tcase DP_DWN_STRM_PORT_TYPE_TMDS:\n\t\t\t \n\t\t\treturn DRM_MODE_SUBCONNECTOR_DVID;\n\t\tcase DP_DWN_STRM_PORT_TYPE_ANALOG:\n\t\t\t \n\t\t\treturn DRM_MODE_SUBCONNECTOR_VGA;\n\t\tcase DP_DWN_STRM_PORT_TYPE_DP:\n\t\t\treturn DRM_MODE_SUBCONNECTOR_DisplayPort;\n\t\tcase DP_DWN_STRM_PORT_TYPE_OTHER:\n\t\tdefault:\n\t\t\treturn DRM_MODE_SUBCONNECTOR_Unknown;\n\t\t}\n\t}\n\ttype = port_cap[0] & DP_DS_PORT_TYPE_MASK;\n\n\tswitch (type) {\n\tcase DP_DS_PORT_TYPE_DP:\n\tcase DP_DS_PORT_TYPE_DP_DUALMODE:\n\t\treturn DRM_MODE_SUBCONNECTOR_DisplayPort;\n\tcase DP_DS_PORT_TYPE_VGA:\n\t\treturn DRM_MODE_SUBCONNECTOR_VGA;\n\tcase DP_DS_PORT_TYPE_DVI:\n\t\treturn DRM_MODE_SUBCONNECTOR_DVID;\n\tcase DP_DS_PORT_TYPE_HDMI:\n\t\treturn DRM_MODE_SUBCONNECTOR_HDMIA;\n\tcase DP_DS_PORT_TYPE_WIRELESS:\n\t\treturn DRM_MODE_SUBCONNECTOR_Wireless;\n\tcase DP_DS_PORT_TYPE_NON_EDID:\n\tdefault:\n\t\treturn DRM_MODE_SUBCONNECTOR_Unknown;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_subconnector_type);\n\n \nvoid drm_dp_set_subconnector_property(struct drm_connector *connector,\n\t\t\t\t      enum drm_connector_status status,\n\t\t\t\t      const u8 *dpcd,\n\t\t\t\t      const u8 port_cap[4])\n{\n\tenum drm_mode_subconnector subconnector = DRM_MODE_SUBCONNECTOR_Unknown;\n\n\tif (status == connector_status_connected)\n\t\tsubconnector = drm_dp_subconnector_type(dpcd, port_cap);\n\tdrm_object_property_set_value(&connector->base,\n\t\t\tconnector->dev->mode_config.dp_subconnector_property,\n\t\t\tsubconnector);\n}\nEXPORT_SYMBOL(drm_dp_set_subconnector_property);\n\n \nbool drm_dp_read_sink_count_cap(struct drm_connector *connector,\n\t\t\t\tconst u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\tconst struct drm_dp_desc *desc)\n{\n\t \n\treturn connector->connector_type != DRM_MODE_CONNECTOR_eDP &&\n\t\tdpcd[DP_DPCD_REV] >= DP_DPCD_REV_11 &&\n\t\tdpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_PRESENT &&\n\t\t!drm_dp_has_quirk(desc, DP_DPCD_QUIRK_NO_SINK_COUNT);\n}\nEXPORT_SYMBOL(drm_dp_read_sink_count_cap);\n\n \nint drm_dp_read_sink_count(struct drm_dp_aux *aux)\n{\n\tu8 count;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_SINK_COUNT, &count);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 1)\n\t\treturn -EIO;\n\n\treturn DP_GET_SINK_COUNT(count);\n}\nEXPORT_SYMBOL(drm_dp_read_sink_count);\n\n \n\nstatic u32 drm_dp_i2c_functionality(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |\n\t       I2C_FUNC_SMBUS_READ_BLOCK_DATA |\n\t       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |\n\t       I2C_FUNC_10BIT_ADDR;\n}\n\nstatic void drm_dp_i2c_msg_write_status_update(struct drm_dp_aux_msg *msg)\n{\n\t \n\tif ((msg->request & ~DP_AUX_I2C_MOT) == DP_AUX_I2C_WRITE) {\n\t\tmsg->request &= DP_AUX_I2C_MOT;\n\t\tmsg->request |= DP_AUX_I2C_WRITE_STATUS_UPDATE;\n\t}\n}\n\n#define AUX_PRECHARGE_LEN 10  \n#define AUX_SYNC_LEN (16 + 4)  \n#define AUX_STOP_LEN 4\n#define AUX_CMD_LEN 4\n#define AUX_ADDRESS_LEN 20\n#define AUX_REPLY_PAD_LEN 4\n#define AUX_LENGTH_LEN 8\n\n \nstatic int drm_dp_aux_req_duration(const struct drm_dp_aux_msg *msg)\n{\n\tint len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +\n\t\tAUX_CMD_LEN + AUX_ADDRESS_LEN + AUX_LENGTH_LEN;\n\n\tif ((msg->request & DP_AUX_I2C_READ) == 0)\n\t\tlen += msg->size * 8;\n\n\treturn len;\n}\n\nstatic int drm_dp_aux_reply_duration(const struct drm_dp_aux_msg *msg)\n{\n\tint len = AUX_PRECHARGE_LEN + AUX_SYNC_LEN + AUX_STOP_LEN +\n\t\tAUX_CMD_LEN + AUX_REPLY_PAD_LEN;\n\n\t \n\tif (msg->request & DP_AUX_I2C_READ)\n\t\tlen += msg->size * 8;\n\n\treturn len;\n}\n\n#define I2C_START_LEN 1\n#define I2C_STOP_LEN 1\n#define I2C_ADDR_LEN 9  \n#define I2C_DATA_LEN 9  \n\n \nstatic int drm_dp_i2c_msg_duration(const struct drm_dp_aux_msg *msg,\n\t\t\t\t   int i2c_speed_khz)\n{\n\t \n\treturn DIV_ROUND_UP((I2C_START_LEN + I2C_ADDR_LEN +\n\t\t\t     msg->size * I2C_DATA_LEN +\n\t\t\t     I2C_STOP_LEN) * 1000, i2c_speed_khz);\n}\n\n \nstatic int drm_dp_i2c_retry_count(const struct drm_dp_aux_msg *msg,\n\t\t\t      int i2c_speed_khz)\n{\n\tint aux_time_us = drm_dp_aux_req_duration(msg) +\n\t\tdrm_dp_aux_reply_duration(msg);\n\tint i2c_time_us = drm_dp_i2c_msg_duration(msg, i2c_speed_khz);\n\n\treturn DIV_ROUND_UP(i2c_time_us, aux_time_us + AUX_RETRY_INTERVAL);\n}\n\n \nstatic int dp_aux_i2c_speed_khz __read_mostly = 10;\nmodule_param_unsafe(dp_aux_i2c_speed_khz, int, 0644);\nMODULE_PARM_DESC(dp_aux_i2c_speed_khz,\n\t\t \"Assumed speed of the i2c bus in kHz, (1-400, default 10)\");\n\n \nstatic int drm_dp_i2c_do_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)\n{\n\tunsigned int retry, defer_i2c;\n\tint ret;\n\t \n\tint max_retries = max(7, drm_dp_i2c_retry_count(msg, dp_aux_i2c_speed_khz));\n\n\tfor (retry = 0, defer_i2c = 0; retry < (max_retries + defer_i2c); retry++) {\n\t\tret = aux->transfer(aux, msg);\n\t\tif (ret < 0) {\n\t\t\tif (ret == -EBUSY)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (ret == -ETIMEDOUT)\n\t\t\t\tdrm_dbg_kms_ratelimited(aux->drm_dev, \"%s: transaction timed out\\n\",\n\t\t\t\t\t\t\taux->name);\n\t\t\telse\n\t\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: transaction failed: %d\\n\",\n\t\t\t\t\t    aux->name, ret);\n\t\t\treturn ret;\n\t\t}\n\n\n\t\tswitch (msg->reply & DP_AUX_NATIVE_REPLY_MASK) {\n\t\tcase DP_AUX_NATIVE_REPLY_ACK:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase DP_AUX_NATIVE_REPLY_NACK:\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: native nack (result=%d, size=%zu)\\n\",\n\t\t\t\t    aux->name, ret, msg->size);\n\t\t\treturn -EREMOTEIO;\n\n\t\tcase DP_AUX_NATIVE_REPLY_DEFER:\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: native defer\\n\", aux->name);\n\t\t\t \n\t\t\tusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tdrm_err(aux->drm_dev, \"%s: invalid native reply %#04x\\n\",\n\t\t\t\taux->name, msg->reply);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\n\t\tswitch (msg->reply & DP_AUX_I2C_REPLY_MASK) {\n\t\tcase DP_AUX_I2C_REPLY_ACK:\n\t\t\t \n\t\t\tif (ret != msg->size)\n\t\t\t\tdrm_dp_i2c_msg_write_status_update(msg);\n\t\t\treturn ret;\n\n\t\tcase DP_AUX_I2C_REPLY_NACK:\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: I2C nack (result=%d, size=%zu)\\n\",\n\t\t\t\t    aux->name, ret, msg->size);\n\t\t\taux->i2c_nack_count++;\n\t\t\treturn -EREMOTEIO;\n\n\t\tcase DP_AUX_I2C_REPLY_DEFER:\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: I2C defer\\n\", aux->name);\n\t\t\t \n\t\t\taux->i2c_defer_count++;\n\t\t\tif (defer_i2c < 7)\n\t\t\t\tdefer_i2c++;\n\t\t\tusleep_range(AUX_RETRY_INTERVAL, AUX_RETRY_INTERVAL + 100);\n\t\t\tdrm_dp_i2c_msg_write_status_update(msg);\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tdrm_err(aux->drm_dev, \"%s: invalid I2C reply %#04x\\n\",\n\t\t\t\taux->name, msg->reply);\n\t\t\treturn -EREMOTEIO;\n\t\t}\n\t}\n\n\tdrm_dbg_kms(aux->drm_dev, \"%s: Too many retries, giving up\\n\", aux->name);\n\treturn -EREMOTEIO;\n}\n\nstatic void drm_dp_i2c_msg_set_request(struct drm_dp_aux_msg *msg,\n\t\t\t\t       const struct i2c_msg *i2c_msg)\n{\n\tmsg->request = (i2c_msg->flags & I2C_M_RD) ?\n\t\tDP_AUX_I2C_READ : DP_AUX_I2C_WRITE;\n\tif (!(i2c_msg->flags & I2C_M_STOP))\n\t\tmsg->request |= DP_AUX_I2C_MOT;\n}\n\n \nstatic int drm_dp_i2c_drain_msg(struct drm_dp_aux *aux, struct drm_dp_aux_msg *orig_msg)\n{\n\tint err, ret = orig_msg->size;\n\tstruct drm_dp_aux_msg msg = *orig_msg;\n\n\twhile (msg.size > 0) {\n\t\terr = drm_dp_i2c_do_msg(aux, &msg);\n\t\tif (err <= 0)\n\t\t\treturn err == 0 ? -EPROTO : err;\n\n\t\tif (err < msg.size && err < ret) {\n\t\t\tdrm_dbg_kms(aux->drm_dev,\n\t\t\t\t    \"%s: Partial I2C reply: requested %zu bytes got %d bytes\\n\",\n\t\t\t\t    aux->name, msg.size, err);\n\t\t\tret = err;\n\t\t}\n\n\t\tmsg.size -= err;\n\t\tmsg.buffer += err;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int dp_aux_i2c_transfer_size __read_mostly = DP_AUX_MAX_PAYLOAD_BYTES;\nmodule_param_unsafe(dp_aux_i2c_transfer_size, int, 0644);\nMODULE_PARM_DESC(dp_aux_i2c_transfer_size,\n\t\t \"Number of bytes to transfer in a single I2C over DP AUX CH message, (1-16, default 16)\");\n\nstatic int drm_dp_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs,\n\t\t\t   int num)\n{\n\tstruct drm_dp_aux *aux = adapter->algo_data;\n\tunsigned int i, j;\n\tunsigned transfer_size;\n\tstruct drm_dp_aux_msg msg;\n\tint err = 0;\n\n\tdp_aux_i2c_transfer_size = clamp(dp_aux_i2c_transfer_size, 1, DP_AUX_MAX_PAYLOAD_BYTES);\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tfor (i = 0; i < num; i++) {\n\t\tmsg.address = msgs[i].addr;\n\t\tdrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\n\t\t \n\t\tmsg.buffer = NULL;\n\t\tmsg.size = 0;\n\t\terr = drm_dp_i2c_do_msg(aux, &msg);\n\n\t\t \n\t\tdrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\t \n\t\ttransfer_size = dp_aux_i2c_transfer_size;\n\t\tfor (j = 0; j < msgs[i].len; j += msg.size) {\n\t\t\tmsg.buffer = msgs[i].buf + j;\n\t\t\tmsg.size = min(transfer_size, msgs[i].len - j);\n\n\t\t\terr = drm_dp_i2c_drain_msg(aux, &msg);\n\n\t\t\t \n\t\t\tdrm_dp_i2c_msg_set_request(&msg, &msgs[i]);\n\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\ttransfer_size = err;\n\t\t}\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\tif (err >= 0)\n\t\terr = num;\n\t \n\tmsg.request &= ~DP_AUX_I2C_MOT;\n\tmsg.buffer = NULL;\n\tmsg.size = 0;\n\t(void)drm_dp_i2c_do_msg(aux, &msg);\n\n\treturn err;\n}\n\nstatic const struct i2c_algorithm drm_dp_i2c_algo = {\n\t.functionality = drm_dp_i2c_functionality,\n\t.master_xfer = drm_dp_i2c_xfer,\n};\n\nstatic struct drm_dp_aux *i2c_to_aux(struct i2c_adapter *i2c)\n{\n\treturn container_of(i2c, struct drm_dp_aux, ddc);\n}\n\nstatic void lock_bus(struct i2c_adapter *i2c, unsigned int flags)\n{\n\tmutex_lock(&i2c_to_aux(i2c)->hw_mutex);\n}\n\nstatic int trylock_bus(struct i2c_adapter *i2c, unsigned int flags)\n{\n\treturn mutex_trylock(&i2c_to_aux(i2c)->hw_mutex);\n}\n\nstatic void unlock_bus(struct i2c_adapter *i2c, unsigned int flags)\n{\n\tmutex_unlock(&i2c_to_aux(i2c)->hw_mutex);\n}\n\nstatic const struct i2c_lock_operations drm_dp_i2c_lock_ops = {\n\t.lock_bus = lock_bus,\n\t.trylock_bus = trylock_bus,\n\t.unlock_bus = unlock_bus,\n};\n\nstatic int drm_dp_aux_get_crc(struct drm_dp_aux *aux, u8 *crc)\n{\n\tu8 buf, count;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tWARN_ON(!(buf & DP_TEST_SINK_START));\n\n\tret = drm_dp_dpcd_readb(aux, DP_TEST_SINK_MISC, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcount = buf & DP_TEST_COUNT_MASK;\n\tif (count == aux->crc_count)\n\t\treturn -EAGAIN;  \n\n\taux->crc_count = count;\n\n\t \n\tret = drm_dp_dpcd_read(aux, DP_TEST_CRC_R_CR, crc, 6);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void drm_dp_aux_crc_work(struct work_struct *work)\n{\n\tstruct drm_dp_aux *aux = container_of(work, struct drm_dp_aux,\n\t\t\t\t\t      crc_work);\n\tstruct drm_crtc *crtc;\n\tu8 crc_bytes[6];\n\tuint32_t crcs[3];\n\tint ret;\n\n\tif (WARN_ON(!aux->crtc))\n\t\treturn;\n\n\tcrtc = aux->crtc;\n\twhile (crtc->crc.opened) {\n\t\tdrm_crtc_wait_one_vblank(crtc);\n\t\tif (!crtc->crc.opened)\n\t\t\tbreak;\n\n\t\tret = drm_dp_aux_get_crc(aux, crc_bytes);\n\t\tif (ret == -EAGAIN) {\n\t\t\tusleep_range(1000, 2000);\n\t\t\tret = drm_dp_aux_get_crc(aux, crc_bytes);\n\t\t}\n\n\t\tif (ret == -EAGAIN) {\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Get CRC failed after retrying: %d\\n\",\n\t\t\t\t    aux->name, ret);\n\t\t\tcontinue;\n\t\t} else if (ret) {\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to get a CRC: %d\\n\", aux->name, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcrcs[0] = crc_bytes[0] | crc_bytes[1] << 8;\n\t\tcrcs[1] = crc_bytes[2] | crc_bytes[3] << 8;\n\t\tcrcs[2] = crc_bytes[4] | crc_bytes[5] << 8;\n\t\tdrm_crtc_add_crc_entry(crtc, false, 0, crcs);\n\t}\n}\n\n \nvoid drm_dp_remote_aux_init(struct drm_dp_aux *aux)\n{\n\tINIT_WORK(&aux->crc_work, drm_dp_aux_crc_work);\n}\nEXPORT_SYMBOL(drm_dp_remote_aux_init);\n\n \nvoid drm_dp_aux_init(struct drm_dp_aux *aux)\n{\n\tmutex_init(&aux->hw_mutex);\n\tmutex_init(&aux->cec.lock);\n\tINIT_WORK(&aux->crc_work, drm_dp_aux_crc_work);\n\n\taux->ddc.algo = &drm_dp_i2c_algo;\n\taux->ddc.algo_data = aux;\n\taux->ddc.retries = 3;\n\n\taux->ddc.lock_ops = &drm_dp_i2c_lock_ops;\n}\nEXPORT_SYMBOL(drm_dp_aux_init);\n\n \nint drm_dp_aux_register(struct drm_dp_aux *aux)\n{\n\tint ret;\n\n\tWARN_ON_ONCE(!aux->drm_dev);\n\n\tif (!aux->ddc.algo)\n\t\tdrm_dp_aux_init(aux);\n\n\taux->ddc.class = I2C_CLASS_DDC;\n\taux->ddc.owner = THIS_MODULE;\n\taux->ddc.dev.parent = aux->dev;\n\n\tstrscpy(aux->ddc.name, aux->name ? aux->name : dev_name(aux->dev),\n\t\tsizeof(aux->ddc.name));\n\n\tret = drm_dp_aux_register_devnode(aux);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i2c_add_adapter(&aux->ddc);\n\tif (ret) {\n\t\tdrm_dp_aux_unregister_devnode(aux);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_aux_register);\n\n \nvoid drm_dp_aux_unregister(struct drm_dp_aux *aux)\n{\n\tdrm_dp_aux_unregister_devnode(aux);\n\ti2c_del_adapter(&aux->ddc);\n}\nEXPORT_SYMBOL(drm_dp_aux_unregister);\n\n#define PSR_SETUP_TIME(x) [DP_PSR_SETUP_TIME_ ## x >> DP_PSR_SETUP_TIME_SHIFT] = (x)\n\n \nint drm_dp_psr_setup_time(const u8 psr_cap[EDP_PSR_RECEIVER_CAP_SIZE])\n{\n\tstatic const u16 psr_setup_time_us[] = {\n\t\tPSR_SETUP_TIME(330),\n\t\tPSR_SETUP_TIME(275),\n\t\tPSR_SETUP_TIME(220),\n\t\tPSR_SETUP_TIME(165),\n\t\tPSR_SETUP_TIME(110),\n\t\tPSR_SETUP_TIME(55),\n\t\tPSR_SETUP_TIME(0),\n\t};\n\tint i;\n\n\ti = (psr_cap[1] & DP_PSR_SETUP_TIME_MASK) >> DP_PSR_SETUP_TIME_SHIFT;\n\tif (i >= ARRAY_SIZE(psr_setup_time_us))\n\t\treturn -EINVAL;\n\n\treturn psr_setup_time_us[i];\n}\nEXPORT_SYMBOL(drm_dp_psr_setup_time);\n\n#undef PSR_SETUP_TIME\n\n \nint drm_dp_start_crc(struct drm_dp_aux *aux, struct drm_crtc *crtc)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_TEST_SINK, buf | DP_TEST_SINK_START);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taux->crc_count = 0;\n\taux->crtc = crtc;\n\tschedule_work(&aux->crc_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_start_crc);\n\n \nint drm_dp_stop_crc(struct drm_dp_aux *aux)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_TEST_SINK, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_TEST_SINK, buf & ~DP_TEST_SINK_START);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tflush_work(&aux->crc_work);\n\taux->crtc = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_stop_crc);\n\nstruct dpcd_quirk {\n\tu8 oui[3];\n\tu8 device_id[6];\n\tbool is_branch;\n\tu32 quirks;\n};\n\n#define OUI(first, second, third) { (first), (second), (third) }\n#define DEVICE_ID(first, second, third, fourth, fifth, sixth) \\\n\t{ (first), (second), (third), (fourth), (fifth), (sixth) }\n\n#define DEVICE_ID_ANY\tDEVICE_ID(0, 0, 0, 0, 0, 0)\n\nstatic const struct dpcd_quirk dpcd_quirk_list[] = {\n\t \n\t{ OUI(0x00, 0x22, 0xb9), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_CONSTANT_N) },\n\t \n\t{ OUI(0x00, 0x22, 0xb9), DEVICE_ID('s', 'i', 'v', 'a', 'r', 'T'), false, BIT(DP_DPCD_QUIRK_CONSTANT_N) },\n\t \n\t{ OUI(0x00, 0x10, 0xfa), DEVICE_ID_ANY, false, BIT(DP_DPCD_QUIRK_NO_PSR) },\n\t \n\t{ OUI(0x00, 0x00, 0x00), DEVICE_ID('C', 'H', '7', '5', '1', '1'), false, BIT(DP_DPCD_QUIRK_NO_SINK_COUNT) },\n\t \n\t{ OUI(0x90, 0xCC, 0x24), DEVICE_ID_ANY, true, BIT(DP_DPCD_QUIRK_DSC_WITHOUT_VIRTUAL_DPCD) },\n\t \n\t{ OUI(0x00, 0x10, 0xfa), DEVICE_ID(101, 68, 21, 101, 98, 97), false, BIT(DP_DPCD_QUIRK_CAN_DO_MAX_LINK_RATE_3_24_GBPS) },\n};\n\n#undef OUI\n\n \nstatic u32\ndrm_dp_get_quirks(const struct drm_dp_dpcd_ident *ident, bool is_branch)\n{\n\tconst struct dpcd_quirk *quirk;\n\tu32 quirks = 0;\n\tint i;\n\tu8 any_device[] = DEVICE_ID_ANY;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpcd_quirk_list); i++) {\n\t\tquirk = &dpcd_quirk_list[i];\n\n\t\tif (quirk->is_branch != is_branch)\n\t\t\tcontinue;\n\n\t\tif (memcmp(quirk->oui, ident->oui, sizeof(ident->oui)) != 0)\n\t\t\tcontinue;\n\n\t\tif (memcmp(quirk->device_id, any_device, sizeof(any_device)) != 0 &&\n\t\t    memcmp(quirk->device_id, ident->device_id, sizeof(ident->device_id)) != 0)\n\t\t\tcontinue;\n\n\t\tquirks |= quirk->quirks;\n\t}\n\n\treturn quirks;\n}\n\n#undef DEVICE_ID_ANY\n#undef DEVICE_ID\n\n \nint drm_dp_read_desc(struct drm_dp_aux *aux, struct drm_dp_desc *desc,\n\t\t     bool is_branch)\n{\n\tstruct drm_dp_dpcd_ident *ident = &desc->ident;\n\tunsigned int offset = is_branch ? DP_BRANCH_OUI : DP_SINK_OUI;\n\tint ret, dev_id_len;\n\n\tret = drm_dp_dpcd_read(aux, offset, ident, sizeof(*ident));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdesc->quirks = drm_dp_get_quirks(ident, is_branch);\n\n\tdev_id_len = strnlen(ident->device_id, sizeof(ident->device_id));\n\n\tdrm_dbg_kms(aux->drm_dev,\n\t\t    \"%s: DP %s: OUI %*phD dev-ID %*pE HW-rev %d.%d SW-rev %d.%d quirks 0x%04x\\n\",\n\t\t    aux->name, is_branch ? \"branch\" : \"sink\",\n\t\t    (int)sizeof(ident->oui), ident->oui, dev_id_len,\n\t\t    ident->device_id, ident->hw_rev >> 4, ident->hw_rev & 0xf,\n\t\t    ident->sw_major_rev, ident->sw_minor_rev, desc->quirks);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_read_desc);\n\n \nu8 drm_dp_dsc_sink_max_slice_count(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],\n\t\t\t\t   bool is_edp)\n{\n\tu8 slice_cap1 = dsc_dpcd[DP_DSC_SLICE_CAP_1 - DP_DSC_SUPPORT];\n\n\tif (is_edp) {\n\t\t \n\t\tif (slice_cap1 & DP_DSC_4_PER_DP_DSC_SINK)\n\t\t\treturn 4;\n\t\tif (slice_cap1 & DP_DSC_2_PER_DP_DSC_SINK)\n\t\t\treturn 2;\n\t\tif (slice_cap1 & DP_DSC_1_PER_DP_DSC_SINK)\n\t\t\treturn 1;\n\t} else {\n\t\t \n\t\tu8 slice_cap2 = dsc_dpcd[DP_DSC_SLICE_CAP_2 - DP_DSC_SUPPORT];\n\n\t\tif (slice_cap2 & DP_DSC_24_PER_DP_DSC_SINK)\n\t\t\treturn 24;\n\t\tif (slice_cap2 & DP_DSC_20_PER_DP_DSC_SINK)\n\t\t\treturn 20;\n\t\tif (slice_cap2 & DP_DSC_16_PER_DP_DSC_SINK)\n\t\t\treturn 16;\n\t\tif (slice_cap1 & DP_DSC_12_PER_DP_DSC_SINK)\n\t\t\treturn 12;\n\t\tif (slice_cap1 & DP_DSC_10_PER_DP_DSC_SINK)\n\t\t\treturn 10;\n\t\tif (slice_cap1 & DP_DSC_8_PER_DP_DSC_SINK)\n\t\t\treturn 8;\n\t\tif (slice_cap1 & DP_DSC_6_PER_DP_DSC_SINK)\n\t\t\treturn 6;\n\t\tif (slice_cap1 & DP_DSC_4_PER_DP_DSC_SINK)\n\t\t\treturn 4;\n\t\tif (slice_cap1 & DP_DSC_2_PER_DP_DSC_SINK)\n\t\t\treturn 2;\n\t\tif (slice_cap1 & DP_DSC_1_PER_DP_DSC_SINK)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_dsc_sink_max_slice_count);\n\n \nu8 drm_dp_dsc_sink_line_buf_depth(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE])\n{\n\tu8 line_buf_depth = dsc_dpcd[DP_DSC_LINE_BUF_BIT_DEPTH - DP_DSC_SUPPORT];\n\n\tswitch (line_buf_depth & DP_DSC_LINE_BUF_BIT_DEPTH_MASK) {\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_9:\n\t\treturn 9;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_10:\n\t\treturn 10;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_11:\n\t\treturn 11;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_12:\n\t\treturn 12;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_13:\n\t\treturn 13;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_14:\n\t\treturn 14;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_15:\n\t\treturn 15;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_16:\n\t\treturn 16;\n\tcase DP_DSC_LINE_BUF_BIT_DEPTH_8:\n\t\treturn 8;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_dsc_sink_line_buf_depth);\n\n \nint drm_dp_dsc_sink_supported_input_bpcs(const u8 dsc_dpcd[DP_DSC_RECEIVER_CAP_SIZE],\n\t\t\t\t\t u8 dsc_bpc[3])\n{\n\tint num_bpc = 0;\n\tu8 color_depth = dsc_dpcd[DP_DSC_DEC_COLOR_DEPTH_CAP - DP_DSC_SUPPORT];\n\n\tif (color_depth & DP_DSC_12_BPC)\n\t\tdsc_bpc[num_bpc++] = 12;\n\tif (color_depth & DP_DSC_10_BPC)\n\t\tdsc_bpc[num_bpc++] = 10;\n\tif (color_depth & DP_DSC_8_BPC)\n\t\tdsc_bpc[num_bpc++] = 8;\n\n\treturn num_bpc;\n}\nEXPORT_SYMBOL(drm_dp_dsc_sink_supported_input_bpcs);\n\nstatic int drm_dp_read_lttpr_regs(struct drm_dp_aux *aux,\n\t\t\t\t  const u8 dpcd[DP_RECEIVER_CAP_SIZE], int address,\n\t\t\t\t  u8 *buf, int buf_size)\n{\n\t \n\tint block_size = dpcd[DP_DPCD_REV] < 0x14 ? 1 : buf_size;\n\tint offset;\n\tint ret;\n\n\tfor (offset = 0; offset < buf_size; offset += block_size) {\n\t\tret = drm_dp_dpcd_read(aux,\n\t\t\t\t       address + offset,\n\t\t\t\t       &buf[offset], block_size);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tWARN_ON(ret != block_size);\n\t}\n\n\treturn 0;\n}\n\n \nint drm_dp_read_lttpr_common_caps(struct drm_dp_aux *aux,\n\t\t\t\t  const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t\t  u8 caps[DP_LTTPR_COMMON_CAP_SIZE])\n{\n\treturn drm_dp_read_lttpr_regs(aux, dpcd,\n\t\t\t\t      DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV,\n\t\t\t\t      caps, DP_LTTPR_COMMON_CAP_SIZE);\n}\nEXPORT_SYMBOL(drm_dp_read_lttpr_common_caps);\n\n \nint drm_dp_read_lttpr_phy_caps(struct drm_dp_aux *aux,\n\t\t\t       const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       enum drm_dp_phy dp_phy,\n\t\t\t       u8 caps[DP_LTTPR_PHY_CAP_SIZE])\n{\n\treturn drm_dp_read_lttpr_regs(aux, dpcd,\n\t\t\t\t      DP_TRAINING_AUX_RD_INTERVAL_PHY_REPEATER(dp_phy),\n\t\t\t\t      caps, DP_LTTPR_PHY_CAP_SIZE);\n}\nEXPORT_SYMBOL(drm_dp_read_lttpr_phy_caps);\n\nstatic u8 dp_lttpr_common_cap(const u8 caps[DP_LTTPR_COMMON_CAP_SIZE], int r)\n{\n\treturn caps[r - DP_LT_TUNABLE_PHY_REPEATER_FIELD_DATA_STRUCTURE_REV];\n}\n\n \nint drm_dp_lttpr_count(const u8 caps[DP_LTTPR_COMMON_CAP_SIZE])\n{\n\tu8 count = dp_lttpr_common_cap(caps, DP_PHY_REPEATER_CNT);\n\n\tswitch (hweight8(count)) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn 8 - ilog2(count);\n\tcase 8:\n\t\treturn -ERANGE;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL(drm_dp_lttpr_count);\n\n \nint drm_dp_lttpr_max_link_rate(const u8 caps[DP_LTTPR_COMMON_CAP_SIZE])\n{\n\tu8 rate = dp_lttpr_common_cap(caps, DP_MAX_LINK_RATE_PHY_REPEATER);\n\n\treturn drm_dp_bw_code_to_link_rate(rate);\n}\nEXPORT_SYMBOL(drm_dp_lttpr_max_link_rate);\n\n \nint drm_dp_lttpr_max_lane_count(const u8 caps[DP_LTTPR_COMMON_CAP_SIZE])\n{\n\tu8 max_lanes = dp_lttpr_common_cap(caps, DP_MAX_LANE_COUNT_PHY_REPEATER);\n\n\treturn max_lanes & DP_MAX_LANE_COUNT_MASK;\n}\nEXPORT_SYMBOL(drm_dp_lttpr_max_lane_count);\n\n \nbool\ndrm_dp_lttpr_voltage_swing_level_3_supported(const u8 caps[DP_LTTPR_PHY_CAP_SIZE])\n{\n\tu8 txcap = dp_lttpr_phy_cap(caps, DP_TRANSMITTER_CAPABILITY_PHY_REPEATER1);\n\n\treturn txcap & DP_VOLTAGE_SWING_LEVEL_3_SUPPORTED;\n}\nEXPORT_SYMBOL(drm_dp_lttpr_voltage_swing_level_3_supported);\n\n \nbool\ndrm_dp_lttpr_pre_emphasis_level_3_supported(const u8 caps[DP_LTTPR_PHY_CAP_SIZE])\n{\n\tu8 txcap = dp_lttpr_phy_cap(caps, DP_TRANSMITTER_CAPABILITY_PHY_REPEATER1);\n\n\treturn txcap & DP_PRE_EMPHASIS_LEVEL_3_SUPPORTED;\n}\nEXPORT_SYMBOL(drm_dp_lttpr_pre_emphasis_level_3_supported);\n\n \nint drm_dp_get_phy_test_pattern(struct drm_dp_aux *aux,\n\t\t\t\tstruct drm_dp_phy_test_params *data)\n{\n\tint err;\n\tu8 rate, lanes;\n\n\terr = drm_dp_dpcd_readb(aux, DP_TEST_LINK_RATE, &rate);\n\tif (err < 0)\n\t\treturn err;\n\tdata->link_rate = drm_dp_bw_code_to_link_rate(rate);\n\n\terr = drm_dp_dpcd_readb(aux, DP_TEST_LANE_COUNT, &lanes);\n\tif (err < 0)\n\t\treturn err;\n\tdata->num_lanes = lanes & DP_MAX_LANE_COUNT_MASK;\n\n\tif (lanes & DP_ENHANCED_FRAME_CAP)\n\t\tdata->enhanced_frame_cap = true;\n\n\terr = drm_dp_dpcd_readb(aux, DP_PHY_TEST_PATTERN, &data->phy_pattern);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (data->phy_pattern) {\n\tcase DP_PHY_TEST_PATTERN_80BIT_CUSTOM:\n\t\terr = drm_dp_dpcd_read(aux, DP_TEST_80BIT_CUSTOM_PATTERN_7_0,\n\t\t\t\t       &data->custom80, sizeof(data->custom80));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tbreak;\n\tcase DP_PHY_TEST_PATTERN_CP2520:\n\t\terr = drm_dp_dpcd_read(aux, DP_TEST_HBR2_SCRAMBLER_RESET,\n\t\t\t\t       &data->hbr2_reset,\n\t\t\t\t       sizeof(data->hbr2_reset));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_get_phy_test_pattern);\n\n \nint drm_dp_set_phy_test_pattern(struct drm_dp_aux *aux,\n\t\t\t\tstruct drm_dp_phy_test_params *data, u8 dp_rev)\n{\n\tint err, i;\n\tu8 test_pattern;\n\n\ttest_pattern = data->phy_pattern;\n\tif (dp_rev < 0x12) {\n\t\ttest_pattern = (test_pattern << 2) &\n\t\t\t       DP_LINK_QUAL_PATTERN_11_MASK;\n\t\terr = drm_dp_dpcd_writeb(aux, DP_TRAINING_PATTERN_SET,\n\t\t\t\t\t test_pattern);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tfor (i = 0; i < data->num_lanes; i++) {\n\t\t\terr = drm_dp_dpcd_writeb(aux,\n\t\t\t\t\t\t DP_LINK_QUAL_LANE0_SET + i,\n\t\t\t\t\t\t test_pattern);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_set_phy_test_pattern);\n\nstatic const char *dp_pixelformat_get_name(enum dp_pixelformat pixelformat)\n{\n\tif (pixelformat < 0 || pixelformat > DP_PIXELFORMAT_RESERVED)\n\t\treturn \"Invalid\";\n\n\tswitch (pixelformat) {\n\tcase DP_PIXELFORMAT_RGB:\n\t\treturn \"RGB\";\n\tcase DP_PIXELFORMAT_YUV444:\n\t\treturn \"YUV444\";\n\tcase DP_PIXELFORMAT_YUV422:\n\t\treturn \"YUV422\";\n\tcase DP_PIXELFORMAT_YUV420:\n\t\treturn \"YUV420\";\n\tcase DP_PIXELFORMAT_Y_ONLY:\n\t\treturn \"Y_ONLY\";\n\tcase DP_PIXELFORMAT_RAW:\n\t\treturn \"RAW\";\n\tdefault:\n\t\treturn \"Reserved\";\n\t}\n}\n\nstatic const char *dp_colorimetry_get_name(enum dp_pixelformat pixelformat,\n\t\t\t\t\t   enum dp_colorimetry colorimetry)\n{\n\tif (pixelformat < 0 || pixelformat > DP_PIXELFORMAT_RESERVED)\n\t\treturn \"Invalid\";\n\n\tswitch (colorimetry) {\n\tcase DP_COLORIMETRY_DEFAULT:\n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"sRGB\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"BT.601\";\n\t\tcase DP_PIXELFORMAT_Y_ONLY:\n\t\t\treturn \"DICOM PS3.14\";\n\t\tcase DP_PIXELFORMAT_RAW:\n\t\t\treturn \"Custom Color Profile\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_RGB_WIDE_FIXED:  \n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"Wide Fixed\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"BT.709\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_RGB_WIDE_FLOAT:  \n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"Wide Float\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"xvYCC 601\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_OPRGB:  \n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"OpRGB\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"xvYCC 709\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_DCI_P3_RGB:  \n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"DCI-P3\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"sYCC 601\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_RGB_CUSTOM:  \n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"Custom Profile\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"OpYCC 601\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_BT2020_RGB:  \n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_RGB:\n\t\t\treturn \"BT.2020 RGB\";\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"BT.2020 CYCC\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tcase DP_COLORIMETRY_BT2020_YCC:\n\t\tswitch (pixelformat) {\n\t\tcase DP_PIXELFORMAT_YUV444:\n\t\tcase DP_PIXELFORMAT_YUV422:\n\t\tcase DP_PIXELFORMAT_YUV420:\n\t\t\treturn \"BT.2020 YCC\";\n\t\tdefault:\n\t\t\treturn \"Reserved\";\n\t\t}\n\tdefault:\n\t\treturn \"Invalid\";\n\t}\n}\n\nstatic const char *dp_dynamic_range_get_name(enum dp_dynamic_range dynamic_range)\n{\n\tswitch (dynamic_range) {\n\tcase DP_DYNAMIC_RANGE_VESA:\n\t\treturn \"VESA range\";\n\tcase DP_DYNAMIC_RANGE_CTA:\n\t\treturn \"CTA range\";\n\tdefault:\n\t\treturn \"Invalid\";\n\t}\n}\n\nstatic const char *dp_content_type_get_name(enum dp_content_type content_type)\n{\n\tswitch (content_type) {\n\tcase DP_CONTENT_TYPE_NOT_DEFINED:\n\t\treturn \"Not defined\";\n\tcase DP_CONTENT_TYPE_GRAPHICS:\n\t\treturn \"Graphics\";\n\tcase DP_CONTENT_TYPE_PHOTO:\n\t\treturn \"Photo\";\n\tcase DP_CONTENT_TYPE_VIDEO:\n\t\treturn \"Video\";\n\tcase DP_CONTENT_TYPE_GAME:\n\t\treturn \"Game\";\n\tdefault:\n\t\treturn \"Reserved\";\n\t}\n}\n\nvoid drm_dp_vsc_sdp_log(const char *level, struct device *dev,\n\t\t\tconst struct drm_dp_vsc_sdp *vsc)\n{\n#define DP_SDP_LOG(fmt, ...) dev_printk(level, dev, fmt, ##__VA_ARGS__)\n\tDP_SDP_LOG(\"DP SDP: %s, revision %u, length %u\\n\", \"VSC\",\n\t\t   vsc->revision, vsc->length);\n\tDP_SDP_LOG(\"    pixelformat: %s\\n\",\n\t\t   dp_pixelformat_get_name(vsc->pixelformat));\n\tDP_SDP_LOG(\"    colorimetry: %s\\n\",\n\t\t   dp_colorimetry_get_name(vsc->pixelformat, vsc->colorimetry));\n\tDP_SDP_LOG(\"    bpc: %u\\n\", vsc->bpc);\n\tDP_SDP_LOG(\"    dynamic range: %s\\n\",\n\t\t   dp_dynamic_range_get_name(vsc->dynamic_range));\n\tDP_SDP_LOG(\"    content type: %s\\n\",\n\t\t   dp_content_type_get_name(vsc->content_type));\n#undef DP_SDP_LOG\n}\nEXPORT_SYMBOL(drm_dp_vsc_sdp_log);\n\n \nint drm_dp_get_pcon_max_frl_bw(const u8 dpcd[DP_RECEIVER_CAP_SIZE],\n\t\t\t       const u8 port_cap[4])\n{\n\tint bw;\n\tu8 buf;\n\n\tbuf = port_cap[2];\n\tbw = buf & DP_PCON_MAX_FRL_BW;\n\n\tswitch (bw) {\n\tcase DP_PCON_MAX_9GBPS:\n\t\treturn 9;\n\tcase DP_PCON_MAX_18GBPS:\n\t\treturn 18;\n\tcase DP_PCON_MAX_24GBPS:\n\t\treturn 24;\n\tcase DP_PCON_MAX_32GBPS:\n\t\treturn 32;\n\tcase DP_PCON_MAX_40GBPS:\n\t\treturn 40;\n\tcase DP_PCON_MAX_48GBPS:\n\t\treturn 48;\n\tcase DP_PCON_MAX_0GBPS:\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_get_pcon_max_frl_bw);\n\n \nint drm_dp_pcon_frl_prepare(struct drm_dp_aux *aux, bool enable_frl_ready_hpd)\n{\n\tint ret;\n\tu8 buf = DP_PCON_ENABLE_SOURCE_CTL_MODE |\n\t\t DP_PCON_ENABLE_LINK_FRL_MODE;\n\n\tif (enable_frl_ready_hpd)\n\t\tbuf |= DP_PCON_ENABLE_HPD_READY;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_PCON_HDMI_LINK_CONFIG_1, buf);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(drm_dp_pcon_frl_prepare);\n\n \nbool drm_dp_pcon_is_frl_ready(struct drm_dp_aux *aux)\n{\n\tint ret;\n\tu8 buf;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PCON_HDMI_TX_LINK_STATUS, &buf);\n\tif (ret < 0)\n\t\treturn false;\n\n\tif (buf & DP_PCON_FRL_READY)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(drm_dp_pcon_is_frl_ready);\n\n \n\nint drm_dp_pcon_frl_configure_1(struct drm_dp_aux *aux, int max_frl_gbps,\n\t\t\t\tu8 frl_mode)\n{\n\tint ret;\n\tu8 buf;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PCON_HDMI_LINK_CONFIG_1, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (frl_mode == DP_PCON_ENABLE_CONCURRENT_LINK)\n\t\tbuf |= DP_PCON_ENABLE_CONCURRENT_LINK;\n\telse\n\t\tbuf &= ~DP_PCON_ENABLE_CONCURRENT_LINK;\n\n\tswitch (max_frl_gbps) {\n\tcase 9:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_9GBPS;\n\t\tbreak;\n\tcase 18:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_18GBPS;\n\t\tbreak;\n\tcase 24:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_24GBPS;\n\t\tbreak;\n\tcase 32:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_32GBPS;\n\t\tbreak;\n\tcase 40:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_40GBPS;\n\t\tbreak;\n\tcase 48:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_48GBPS;\n\t\tbreak;\n\tcase 0:\n\t\tbuf |=  DP_PCON_ENABLE_MAX_BW_0GBPS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_dp_dpcd_writeb(aux, DP_PCON_HDMI_LINK_CONFIG_1, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_frl_configure_1);\n\n \nint drm_dp_pcon_frl_configure_2(struct drm_dp_aux *aux, int max_frl_mask,\n\t\t\t\tu8 frl_type)\n{\n\tint ret;\n\tu8 buf = max_frl_mask;\n\n\tif (frl_type == DP_PCON_FRL_LINK_TRAIN_EXTENDED)\n\t\tbuf |= DP_PCON_FRL_LINK_TRAIN_EXTENDED;\n\telse\n\t\tbuf &= ~DP_PCON_FRL_LINK_TRAIN_EXTENDED;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_PCON_HDMI_LINK_CONFIG_2, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_frl_configure_2);\n\n \nint drm_dp_pcon_reset_frl_config(struct drm_dp_aux *aux)\n{\n\tint ret;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_PCON_HDMI_LINK_CONFIG_1, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_reset_frl_config);\n\n \nint drm_dp_pcon_frl_enable(struct drm_dp_aux *aux)\n{\n\tint ret;\n\tu8 buf = 0;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PCON_HDMI_LINK_CONFIG_1, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!(buf & DP_PCON_ENABLE_SOURCE_CTL_MODE)) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: PCON in Autonomous mode, can't enable FRL\\n\",\n\t\t\t    aux->name);\n\t\treturn -EINVAL;\n\t}\n\tbuf |= DP_PCON_ENABLE_HDMI_LINK;\n\tret = drm_dp_dpcd_writeb(aux, DP_PCON_HDMI_LINK_CONFIG_1, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_frl_enable);\n\n \nbool drm_dp_pcon_hdmi_link_active(struct drm_dp_aux *aux)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PCON_HDMI_TX_LINK_STATUS, &buf);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn buf & DP_PCON_HDMI_TX_LINK_ACTIVE;\n}\nEXPORT_SYMBOL(drm_dp_pcon_hdmi_link_active);\n\n \nint drm_dp_pcon_hdmi_link_mode(struct drm_dp_aux *aux, u8 *frl_trained_mask)\n{\n\tu8 buf;\n\tint mode;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PCON_HDMI_POST_FRL_STATUS, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmode = buf & DP_PCON_HDMI_LINK_MODE;\n\n\tif (frl_trained_mask && DP_PCON_HDMI_MODE_FRL == mode)\n\t\t*frl_trained_mask = (buf & DP_PCON_HDMI_FRL_TRAINED_BW) >> 1;\n\n\treturn mode;\n}\nEXPORT_SYMBOL(drm_dp_pcon_hdmi_link_mode);\n\n \n\nvoid drm_dp_pcon_hdmi_frl_link_error_count(struct drm_dp_aux *aux,\n\t\t\t\t\t   struct drm_connector *connector)\n{\n\tu8 buf, error_count;\n\tint i, num_error;\n\tstruct drm_hdmi_info *hdmi = &connector->display_info.hdmi;\n\n\tfor (i = 0; i < hdmi->max_lanes; i++) {\n\t\tif (drm_dp_dpcd_readb(aux, DP_PCON_HDMI_ERROR_STATUS_LN0 + i, &buf) < 0)\n\t\t\treturn;\n\n\t\terror_count = buf & DP_PCON_HDMI_ERROR_COUNT_MASK;\n\t\tswitch (error_count) {\n\t\tcase DP_PCON_HDMI_ERROR_COUNT_HUNDRED_PLUS:\n\t\t\tnum_error = 100;\n\t\t\tbreak;\n\t\tcase DP_PCON_HDMI_ERROR_COUNT_TEN_PLUS:\n\t\t\tnum_error = 10;\n\t\t\tbreak;\n\t\tcase DP_PCON_HDMI_ERROR_COUNT_THREE_PLUS:\n\t\t\tnum_error = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnum_error = 0;\n\t\t}\n\n\t\tdrm_err(aux->drm_dev, \"%s: More than %d errors since the last read for lane %d\",\n\t\t\taux->name, num_error, i);\n\t}\n}\nEXPORT_SYMBOL(drm_dp_pcon_hdmi_frl_link_error_count);\n\n \nbool drm_dp_pcon_enc_is_dsc_1_2(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE])\n{\n\tu8 buf;\n\tu8 major_v, minor_v;\n\n\tbuf = pcon_dsc_dpcd[DP_PCON_DSC_VERSION - DP_PCON_DSC_ENCODER];\n\tmajor_v = (buf & DP_PCON_DSC_MAJOR_MASK) >> DP_PCON_DSC_MAJOR_SHIFT;\n\tminor_v = (buf & DP_PCON_DSC_MINOR_MASK) >> DP_PCON_DSC_MINOR_SHIFT;\n\n\tif (major_v == 1 && minor_v == 2)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(drm_dp_pcon_enc_is_dsc_1_2);\n\n \nint drm_dp_pcon_dsc_max_slices(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE])\n{\n\tu8 slice_cap1, slice_cap2;\n\n\tslice_cap1 = pcon_dsc_dpcd[DP_PCON_DSC_SLICE_CAP_1 - DP_PCON_DSC_ENCODER];\n\tslice_cap2 = pcon_dsc_dpcd[DP_PCON_DSC_SLICE_CAP_2 - DP_PCON_DSC_ENCODER];\n\n\tif (slice_cap2 & DP_PCON_DSC_24_PER_DSC_ENC)\n\t\treturn 24;\n\tif (slice_cap2 & DP_PCON_DSC_20_PER_DSC_ENC)\n\t\treturn 20;\n\tif (slice_cap2 & DP_PCON_DSC_16_PER_DSC_ENC)\n\t\treturn 16;\n\tif (slice_cap1 & DP_PCON_DSC_12_PER_DSC_ENC)\n\t\treturn 12;\n\tif (slice_cap1 & DP_PCON_DSC_10_PER_DSC_ENC)\n\t\treturn 10;\n\tif (slice_cap1 & DP_PCON_DSC_8_PER_DSC_ENC)\n\t\treturn 8;\n\tif (slice_cap1 & DP_PCON_DSC_6_PER_DSC_ENC)\n\t\treturn 6;\n\tif (slice_cap1 & DP_PCON_DSC_4_PER_DSC_ENC)\n\t\treturn 4;\n\tif (slice_cap1 & DP_PCON_DSC_2_PER_DSC_ENC)\n\t\treturn 2;\n\tif (slice_cap1 & DP_PCON_DSC_1_PER_DSC_ENC)\n\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_dsc_max_slices);\n\n \nint drm_dp_pcon_dsc_max_slice_width(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE])\n{\n\tu8 buf;\n\n\tbuf = pcon_dsc_dpcd[DP_PCON_DSC_MAX_SLICE_WIDTH - DP_PCON_DSC_ENCODER];\n\n\treturn buf * DP_DSC_SLICE_WIDTH_MULTIPLIER;\n}\nEXPORT_SYMBOL(drm_dp_pcon_dsc_max_slice_width);\n\n \nint drm_dp_pcon_dsc_bpp_incr(const u8 pcon_dsc_dpcd[DP_PCON_DSC_ENCODER_CAP_SIZE])\n{\n\tu8 buf;\n\n\tbuf = pcon_dsc_dpcd[DP_PCON_DSC_BPP_INCR - DP_PCON_DSC_ENCODER];\n\n\tswitch (buf & DP_PCON_DSC_BPP_INCR_MASK) {\n\tcase DP_PCON_DSC_ONE_16TH_BPP:\n\t\treturn 16;\n\tcase DP_PCON_DSC_ONE_8TH_BPP:\n\t\treturn 8;\n\tcase DP_PCON_DSC_ONE_4TH_BPP:\n\t\treturn 4;\n\tcase DP_PCON_DSC_ONE_HALF_BPP:\n\t\treturn 2;\n\tcase DP_PCON_DSC_ONE_BPP:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_dsc_bpp_incr);\n\nstatic\nint drm_dp_pcon_configure_dsc_enc(struct drm_dp_aux *aux, u8 pps_buf_config)\n{\n\tu8 buf;\n\tint ret;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PROTOCOL_CONVERTER_CONTROL_2, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf |= DP_PCON_ENABLE_DSC_ENCODER;\n\n\tif (pps_buf_config <= DP_PCON_ENC_PPS_OVERRIDE_EN_BUFFER) {\n\t\tbuf &= ~DP_PCON_ENCODER_PPS_OVERRIDE_MASK;\n\t\tbuf |= pps_buf_config << 2;\n\t}\n\n\tret = drm_dp_dpcd_writeb(aux, DP_PROTOCOL_CONVERTER_CONTROL_2, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nint drm_dp_pcon_pps_default(struct drm_dp_aux *aux)\n{\n\tint ret;\n\n\tret = drm_dp_pcon_configure_dsc_enc(aux, DP_PCON_ENC_PPS_OVERRIDE_DISABLED);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_pps_default);\n\n \nint drm_dp_pcon_pps_override_buf(struct drm_dp_aux *aux, u8 pps_buf[128])\n{\n\tint ret;\n\n\tret = drm_dp_dpcd_write(aux, DP_PCON_HDMI_PPS_OVERRIDE_BASE, &pps_buf, 128);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_dp_pcon_configure_dsc_enc(aux, DP_PCON_ENC_PPS_OVERRIDE_EN_BUFFER);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_pps_override_buf);\n\n \nint drm_dp_pcon_pps_override_param(struct drm_dp_aux *aux, u8 pps_param[6])\n{\n\tint ret;\n\n\tret = drm_dp_dpcd_write(aux, DP_PCON_HDMI_PPS_OVRD_SLICE_HEIGHT, &pps_param[0], 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = drm_dp_dpcd_write(aux, DP_PCON_HDMI_PPS_OVRD_SLICE_WIDTH, &pps_param[2], 2);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = drm_dp_dpcd_write(aux, DP_PCON_HDMI_PPS_OVRD_BPP, &pps_param[4], 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_dp_pcon_configure_dsc_enc(aux, DP_PCON_ENC_PPS_OVERRIDE_EN_BUFFER);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_pps_override_param);\n\n \nint drm_dp_pcon_convert_rgb_to_ycbcr(struct drm_dp_aux *aux, u8 color_spc)\n{\n\tint ret;\n\tu8 buf;\n\n\tret = drm_dp_dpcd_readb(aux, DP_PROTOCOL_CONVERTER_CONTROL_2, &buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (color_spc & DP_CONVERSION_RGB_YCBCR_MASK)\n\t\tbuf |= (color_spc & DP_CONVERSION_RGB_YCBCR_MASK);\n\telse\n\t\tbuf &= ~DP_CONVERSION_RGB_YCBCR_MASK;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_PROTOCOL_CONVERTER_CONTROL_2, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_pcon_convert_rgb_to_ycbcr);\n\n \nint drm_edp_backlight_set_level(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl,\n\t\t\t\tu16 level)\n{\n\tint ret;\n\tu8 buf[2] = { 0 };\n\n\t \n\tif (!bl->aux_set)\n\t\treturn 0;\n\n\tif (bl->lsb_reg_used) {\n\t\tbuf[0] = (level & 0xff00) >> 8;\n\t\tbuf[1] = (level & 0x00ff);\n\t} else {\n\t\tbuf[0] = level;\n\t}\n\n\tret = drm_dp_dpcd_write(aux, DP_EDP_BACKLIGHT_BRIGHTNESS_MSB, buf, sizeof(buf));\n\tif (ret != sizeof(buf)) {\n\t\tdrm_err(aux->drm_dev,\n\t\t\t\"%s: Failed to write aux backlight level: %d\\n\",\n\t\t\taux->name, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_edp_backlight_set_level);\n\nstatic int\ndrm_edp_backlight_set_enable(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl,\n\t\t\t     bool enable)\n{\n\tint ret;\n\tu8 buf;\n\n\t \n\tif (!bl->aux_enable)\n\t\treturn 0;\n\n\tret = drm_dp_dpcd_readb(aux, DP_EDP_DISPLAY_CONTROL_REGISTER, &buf);\n\tif (ret != 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: Failed to read eDP display control register: %d\\n\",\n\t\t\taux->name, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\tif (enable)\n\t\tbuf |= DP_EDP_BACKLIGHT_ENABLE;\n\telse\n\t\tbuf &= ~DP_EDP_BACKLIGHT_ENABLE;\n\n\tret = drm_dp_dpcd_writeb(aux, DP_EDP_DISPLAY_CONTROL_REGISTER, buf);\n\tif (ret != 1) {\n\t\tdrm_err(aux->drm_dev, \"%s: Failed to write eDP display control register: %d\\n\",\n\t\t\taux->name, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nint drm_edp_backlight_enable(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl,\n\t\t\t     const u16 level)\n{\n\tint ret;\n\tu8 dpcd_buf;\n\n\tif (bl->aux_set)\n\t\tdpcd_buf = DP_EDP_BACKLIGHT_CONTROL_MODE_DPCD;\n\telse\n\t\tdpcd_buf = DP_EDP_BACKLIGHT_CONTROL_MODE_PWM;\n\n\tif (bl->pwmgen_bit_count) {\n\t\tret = drm_dp_dpcd_writeb(aux, DP_EDP_PWMGEN_BIT_COUNT, bl->pwmgen_bit_count);\n\t\tif (ret != 1)\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to write aux pwmgen bit count: %d\\n\",\n\t\t\t\t    aux->name, ret);\n\t}\n\n\tif (bl->pwm_freq_pre_divider) {\n\t\tret = drm_dp_dpcd_writeb(aux, DP_EDP_BACKLIGHT_FREQ_SET, bl->pwm_freq_pre_divider);\n\t\tif (ret != 1)\n\t\t\tdrm_dbg_kms(aux->drm_dev,\n\t\t\t\t    \"%s: Failed to write aux backlight frequency: %d\\n\",\n\t\t\t\t    aux->name, ret);\n\t\telse\n\t\t\tdpcd_buf |= DP_EDP_BACKLIGHT_FREQ_AUX_SET_ENABLE;\n\t}\n\n\tret = drm_dp_dpcd_writeb(aux, DP_EDP_BACKLIGHT_MODE_SET_REGISTER, dpcd_buf);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to write aux backlight mode: %d\\n\",\n\t\t\t    aux->name, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\tret = drm_edp_backlight_set_level(aux, bl, level);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = drm_edp_backlight_set_enable(aux, bl, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_edp_backlight_enable);\n\n \nint drm_edp_backlight_disable(struct drm_dp_aux *aux, const struct drm_edp_backlight_info *bl)\n{\n\tint ret;\n\n\tret = drm_edp_backlight_set_enable(aux, bl, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_edp_backlight_disable);\n\nstatic inline int\ndrm_edp_backlight_probe_max(struct drm_dp_aux *aux, struct drm_edp_backlight_info *bl,\n\t\t\t    u16 driver_pwm_freq_hz, const u8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE])\n{\n\tint fxp, fxp_min, fxp_max, fxp_actual, f = 1;\n\tint ret;\n\tu8 pn, pn_min, pn_max;\n\n\tif (!bl->aux_set)\n\t\treturn 0;\n\n\tret = drm_dp_dpcd_readb(aux, DP_EDP_PWMGEN_BIT_COUNT, &pn);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to read pwmgen bit count cap: %d\\n\",\n\t\t\t    aux->name, ret);\n\t\treturn -ENODEV;\n\t}\n\n\tpn &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\tbl->max = (1 << pn) - 1;\n\tif (!driver_pwm_freq_hz)\n\t\treturn 0;\n\n\t \n\n\t \n\tfxp = DIV_ROUND_CLOSEST(1000 * DP_EDP_BACKLIGHT_FREQ_BASE_KHZ, driver_pwm_freq_hz);\n\n\t \n\tret = drm_dp_dpcd_readb(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MIN, &pn_min);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to read pwmgen bit count cap min: %d\\n\",\n\t\t\t    aux->name, ret);\n\t\treturn 0;\n\t}\n\tret = drm_dp_dpcd_readb(aux, DP_EDP_PWMGEN_BIT_COUNT_CAP_MAX, &pn_max);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to read pwmgen bit count cap max: %d\\n\",\n\t\t\t    aux->name, ret);\n\t\treturn 0;\n\t}\n\tpn_min &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\tpn_max &= DP_EDP_PWMGEN_BIT_COUNT_MASK;\n\n\t \n\tfxp_min = DIV_ROUND_CLOSEST(fxp * 3, 4);\n\tfxp_max = DIV_ROUND_CLOSEST(fxp * 5, 4);\n\tif (fxp_min < (1 << pn_min) || (255 << pn_max) < fxp_max) {\n\t\tdrm_dbg_kms(aux->drm_dev,\n\t\t\t    \"%s: Driver defined backlight frequency (%d) out of range\\n\",\n\t\t\t    aux->name, driver_pwm_freq_hz);\n\t\treturn 0;\n\t}\n\n\tfor (pn = pn_max; pn >= pn_min; pn--) {\n\t\tf = clamp(DIV_ROUND_CLOSEST(fxp, 1 << pn), 1, 255);\n\t\tfxp_actual = f << pn;\n\t\tif (fxp_min <= fxp_actual && fxp_actual <= fxp_max)\n\t\t\tbreak;\n\t}\n\n\tret = drm_dp_dpcd_writeb(aux, DP_EDP_PWMGEN_BIT_COUNT, pn);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to write aux pwmgen bit count: %d\\n\",\n\t\t\t    aux->name, ret);\n\t\treturn 0;\n\t}\n\tbl->pwmgen_bit_count = pn;\n\tbl->max = (1 << pn) - 1;\n\n\tif (edp_dpcd[2] & DP_EDP_BACKLIGHT_FREQ_AUX_SET_CAP) {\n\t\tbl->pwm_freq_pre_divider = f;\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Using backlight frequency from driver (%dHz)\\n\",\n\t\t\t    aux->name, driver_pwm_freq_hz);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int\ndrm_edp_backlight_probe_state(struct drm_dp_aux *aux, struct drm_edp_backlight_info *bl,\n\t\t\t      u8 *current_mode)\n{\n\tint ret;\n\tu8 buf[2];\n\tu8 mode_reg;\n\n\tret = drm_dp_dpcd_readb(aux, DP_EDP_BACKLIGHT_MODE_SET_REGISTER, &mode_reg);\n\tif (ret != 1) {\n\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to read backlight mode: %d\\n\",\n\t\t\t    aux->name, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\t*current_mode = (mode_reg & DP_EDP_BACKLIGHT_CONTROL_MODE_MASK);\n\tif (!bl->aux_set)\n\t\treturn 0;\n\n\tif (*current_mode == DP_EDP_BACKLIGHT_CONTROL_MODE_DPCD) {\n\t\tint size = 1 + bl->lsb_reg_used;\n\n\t\tret = drm_dp_dpcd_read(aux, DP_EDP_BACKLIGHT_BRIGHTNESS_MSB, buf, size);\n\t\tif (ret != size) {\n\t\t\tdrm_dbg_kms(aux->drm_dev, \"%s: Failed to read backlight level: %d\\n\",\n\t\t\t\t    aux->name, ret);\n\t\t\treturn ret < 0 ? ret : -EIO;\n\t\t}\n\n\t\tif (bl->lsb_reg_used)\n\t\t\treturn (buf[0] << 8) | buf[1];\n\t\telse\n\t\t\treturn buf[0];\n\t}\n\n\t \n\treturn bl->max;\n}\n\n \nint\ndrm_edp_backlight_init(struct drm_dp_aux *aux, struct drm_edp_backlight_info *bl,\n\t\t       u16 driver_pwm_freq_hz, const u8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE],\n\t\t       u16 *current_level, u8 *current_mode)\n{\n\tint ret;\n\n\tif (edp_dpcd[1] & DP_EDP_BACKLIGHT_AUX_ENABLE_CAP)\n\t\tbl->aux_enable = true;\n\tif (edp_dpcd[2] & DP_EDP_BACKLIGHT_BRIGHTNESS_AUX_SET_CAP)\n\t\tbl->aux_set = true;\n\tif (edp_dpcd[2] & DP_EDP_BACKLIGHT_BRIGHTNESS_BYTE_COUNT)\n\t\tbl->lsb_reg_used = true;\n\n\t \n\tif (!bl->aux_set && !(edp_dpcd[2] & DP_EDP_BACKLIGHT_BRIGHTNESS_PWM_PIN_CAP)) {\n\t\tdrm_dbg_kms(aux->drm_dev,\n\t\t\t    \"%s: Panel supports neither AUX or PWM brightness control? Aborting\\n\",\n\t\t\t    aux->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = drm_edp_backlight_probe_max(aux, bl, driver_pwm_freq_hz, edp_dpcd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = drm_edp_backlight_probe_state(aux, bl, current_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\t*current_level = ret;\n\n\tdrm_dbg_kms(aux->drm_dev,\n\t\t    \"%s: Found backlight: aux_set=%d aux_enable=%d mode=%d\\n\",\n\t\t    aux->name, bl->aux_set, bl->aux_enable, *current_mode);\n\tif (bl->aux_set) {\n\t\tdrm_dbg_kms(aux->drm_dev,\n\t\t\t    \"%s: Backlight caps: level=%d/%d pwm_freq_pre_divider=%d lsb_reg_used=%d\\n\",\n\t\t\t    aux->name, *current_level, bl->max, bl->pwm_freq_pre_divider,\n\t\t\t    bl->lsb_reg_used);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_edp_backlight_init);\n\n#if IS_BUILTIN(CONFIG_BACKLIGHT_CLASS_DEVICE) || \\\n\t(IS_MODULE(CONFIG_DRM_KMS_HELPER) && IS_MODULE(CONFIG_BACKLIGHT_CLASS_DEVICE))\n\nstatic int dp_aux_backlight_update_status(struct backlight_device *bd)\n{\n\tstruct dp_aux_backlight *bl = bl_get_data(bd);\n\tu16 brightness = backlight_get_brightness(bd);\n\tint ret = 0;\n\n\tif (!backlight_is_blank(bd)) {\n\t\tif (!bl->enabled) {\n\t\t\tdrm_edp_backlight_enable(bl->aux, &bl->info, brightness);\n\t\t\tbl->enabled = true;\n\t\t\treturn 0;\n\t\t}\n\t\tret = drm_edp_backlight_set_level(bl->aux, &bl->info, brightness);\n\t} else {\n\t\tif (bl->enabled) {\n\t\t\tdrm_edp_backlight_disable(bl->aux, &bl->info);\n\t\t\tbl->enabled = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct backlight_ops dp_aux_bl_ops = {\n\t.update_status = dp_aux_backlight_update_status,\n};\n\n \nint drm_panel_dp_aux_backlight(struct drm_panel *panel, struct drm_dp_aux *aux)\n{\n\tstruct dp_aux_backlight *bl;\n\tstruct backlight_properties props = { 0 };\n\tu16 current_level;\n\tu8 current_mode;\n\tu8 edp_dpcd[EDP_DISPLAY_CTL_CAP_SIZE];\n\tint ret;\n\n\tif (!panel || !panel->dev || !aux)\n\t\treturn -EINVAL;\n\n\tret = drm_dp_dpcd_read(aux, DP_EDP_DPCD_REV, edp_dpcd,\n\t\t\t       EDP_DISPLAY_CTL_CAP_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!drm_edp_backlight_supported(edp_dpcd)) {\n\t\tDRM_DEV_INFO(panel->dev, \"DP AUX backlight is not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tbl = devm_kzalloc(panel->dev, sizeof(*bl), GFP_KERNEL);\n\tif (!bl)\n\t\treturn -ENOMEM;\n\n\tbl->aux = aux;\n\n\tret = drm_edp_backlight_init(aux, &bl->info, 0, edp_dpcd,\n\t\t\t\t     &current_level, &current_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprops.type = BACKLIGHT_RAW;\n\tprops.brightness = current_level;\n\tprops.max_brightness = bl->info.max;\n\n\tbl->base = devm_backlight_device_register(panel->dev, \"dp_aux_backlight\",\n\t\t\t\t\t\t  panel->dev, bl,\n\t\t\t\t\t\t  &dp_aux_bl_ops, &props);\n\tif (IS_ERR(bl->base))\n\t\treturn PTR_ERR(bl->base);\n\n\tbacklight_disable(bl->base);\n\n\tpanel->backlight = bl->base;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_panel_dp_aux_backlight);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}