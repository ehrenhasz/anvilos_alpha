{
  "module_name": "drm_dp_aux_bus.c",
  "hash_id": "650f3185b7e03a13a92b84344360573c40945451dd54a62b4a6f1f40355f6a7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_dp_aux_bus.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n\n#include <drm/display/drm_dp_aux_bus.h>\n#include <drm/display/drm_dp_helper.h>\n\nstruct dp_aux_ep_device_with_data {\n\tstruct dp_aux_ep_device aux_ep;\n\tint (*done_probing)(struct drm_dp_aux *aux);\n};\n\n \nstatic int dp_aux_ep_match(struct device *dev, struct device_driver *drv)\n{\n\treturn !!of_match_device(drv->of_match_table, dev);\n}\n\n \nstatic int dp_aux_ep_probe(struct device *dev)\n{\n\tstruct dp_aux_ep_driver *aux_ep_drv = to_dp_aux_ep_drv(dev->driver);\n\tstruct dp_aux_ep_device *aux_ep = to_dp_aux_ep_dev(dev);\n\tstruct dp_aux_ep_device_with_data *aux_ep_with_data =\n\t\tcontainer_of(aux_ep, struct dp_aux_ep_device_with_data, aux_ep);\n\tint ret;\n\n\tret = dev_pm_domain_attach(dev, true);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to attach to PM Domain\\n\");\n\n\tret = aux_ep_drv->probe(aux_ep);\n\tif (ret)\n\t\tgoto err_attached;\n\n\tif (aux_ep_with_data->done_probing) {\n\t\tret = aux_ep_with_data->done_probing(aux_ep->aux);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ret == -EPROBE_DEFER) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"DP AUX done_probing() can't defer\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\tgoto err_probed;\n\t\t}\n\t}\n\n\treturn 0;\nerr_probed:\n\tif (aux_ep_drv->remove)\n\t\taux_ep_drv->remove(aux_ep);\nerr_attached:\n\tdev_pm_domain_detach(dev, true);\n\n\treturn ret;\n}\n\n \nstatic void dp_aux_ep_remove(struct device *dev)\n{\n\tstruct dp_aux_ep_driver *aux_ep_drv = to_dp_aux_ep_drv(dev->driver);\n\tstruct dp_aux_ep_device *aux_ep = to_dp_aux_ep_dev(dev);\n\n\tif (aux_ep_drv->remove)\n\t\taux_ep_drv->remove(aux_ep);\n\tdev_pm_domain_detach(dev, true);\n}\n\n \nstatic void dp_aux_ep_shutdown(struct device *dev)\n{\n\tstruct dp_aux_ep_driver *aux_ep_drv;\n\n\tif (!dev->driver)\n\t\treturn;\n\n\taux_ep_drv = to_dp_aux_ep_drv(dev->driver);\n\tif (aux_ep_drv->shutdown)\n\t\taux_ep_drv->shutdown(to_dp_aux_ep_dev(dev));\n}\n\nstatic struct bus_type dp_aux_bus_type = {\n\t.name\t\t= \"dp-aux\",\n\t.match\t\t= dp_aux_ep_match,\n\t.probe\t\t= dp_aux_ep_probe,\n\t.remove\t\t= dp_aux_ep_remove,\n\t.shutdown\t= dp_aux_ep_shutdown,\n};\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn of_device_modalias(dev, buf, PAGE_SIZE);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *dp_aux_ep_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(dp_aux_ep_dev);\n\n \nstatic void dp_aux_ep_dev_release(struct device *dev)\n{\n\tstruct dp_aux_ep_device *aux_ep = to_dp_aux_ep_dev(dev);\n\tstruct dp_aux_ep_device_with_data *aux_ep_with_data =\n\t\tcontainer_of(aux_ep, struct dp_aux_ep_device_with_data, aux_ep);\n\n\tkfree(aux_ep_with_data);\n}\n\nstatic int dp_aux_ep_dev_modalias(const struct device *dev, struct kobj_uevent_env *env)\n{\n\treturn of_device_uevent_modalias(dev, env);\n}\n\nstatic struct device_type dp_aux_device_type_type = {\n\t.groups\t\t= dp_aux_ep_dev_groups,\n\t.uevent\t\t= dp_aux_ep_dev_modalias,\n\t.release\t= dp_aux_ep_dev_release,\n};\n\n \nstatic int of_dp_aux_ep_destroy(struct device *dev, void *data)\n{\n\tstruct device_node *np = dev->of_node;\n\n\tif (dev->bus != &dp_aux_bus_type)\n\t\treturn 0;\n\n\tif (!of_node_check_flag(np, OF_POPULATED))\n\t\treturn 0;\n\n\tof_node_clear_flag(np, OF_POPULATED);\n\tof_node_put(np);\n\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\n \nvoid of_dp_aux_depopulate_bus(struct drm_dp_aux *aux)\n{\n\tdevice_for_each_child_reverse(aux->dev, NULL, of_dp_aux_ep_destroy);\n}\nEXPORT_SYMBOL_GPL(of_dp_aux_depopulate_bus);\n\n \nint of_dp_aux_populate_bus(struct drm_dp_aux *aux,\n\t\t\t   int (*done_probing)(struct drm_dp_aux *aux))\n{\n\tstruct device_node *bus = NULL, *np = NULL;\n\tstruct dp_aux_ep_device *aux_ep;\n\tstruct dp_aux_ep_device_with_data *aux_ep_with_data;\n\tint ret;\n\n\t \n\tWARN_ON_ONCE(!aux->ddc.algo);\n\n\tif (!aux->dev->of_node)\n\t\treturn -ENODEV;\n\tbus = of_get_child_by_name(aux->dev->of_node, \"aux-bus\");\n\tif (!bus)\n\t\treturn -ENODEV;\n\n\tnp = of_get_next_available_child(bus, NULL);\n\tof_node_put(bus);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tif (of_node_test_and_set_flag(np, OF_POPULATED)) {\n\t\tdev_err(aux->dev, \"DP AUX EP device already populated\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_did_get_np;\n\t}\n\n\taux_ep_with_data = kzalloc(sizeof(*aux_ep_with_data), GFP_KERNEL);\n\tif (!aux_ep_with_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err_did_set_populated;\n\t}\n\n\taux_ep_with_data->done_probing = done_probing;\n\n\taux_ep = &aux_ep_with_data->aux_ep;\n\taux_ep->aux = aux;\n\taux_ep->dev.parent = aux->dev;\n\taux_ep->dev.bus = &dp_aux_bus_type;\n\taux_ep->dev.type = &dp_aux_device_type_type;\n\taux_ep->dev.of_node = of_node_get(np);\n\tdev_set_name(&aux_ep->dev, \"aux-%s\", dev_name(aux->dev));\n\n\tret = device_register(&aux_ep->dev);\n\tif (ret) {\n\t\tdev_err(aux->dev, \"Failed to create AUX EP for %pOF: %d\\n\", np, ret);\n\n\t\t \n\t\tput_device(&aux_ep->dev);\n\n\t\tgoto err_did_set_populated;\n\t}\n\n\treturn 0;\n\nerr_did_set_populated:\n\tof_node_clear_flag(np, OF_POPULATED);\n\nerr_did_get_np:\n\tof_node_put(np);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(of_dp_aux_populate_bus);\n\nstatic void of_dp_aux_depopulate_bus_void(void *data)\n{\n\tof_dp_aux_depopulate_bus(data);\n}\n\n \nint devm_of_dp_aux_populate_bus(struct drm_dp_aux *aux,\n\t\t\t\tint (*done_probing)(struct drm_dp_aux *aux))\n{\n\tint ret;\n\n\tret = of_dp_aux_populate_bus(aux, done_probing);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(aux->dev,\n\t\t\t\t\tof_dp_aux_depopulate_bus_void, aux);\n}\nEXPORT_SYMBOL_GPL(devm_of_dp_aux_populate_bus);\n\nint __dp_aux_dp_driver_register(struct dp_aux_ep_driver *drv, struct module *owner)\n{\n\tdrv->driver.owner = owner;\n\tdrv->driver.bus = &dp_aux_bus_type;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__dp_aux_dp_driver_register);\n\nvoid dp_aux_dp_driver_unregister(struct dp_aux_ep_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(dp_aux_dp_driver_unregister);\n\nstatic int __init dp_aux_bus_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&dp_aux_bus_type);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void __exit dp_aux_bus_exit(void)\n{\n\tbus_unregister(&dp_aux_bus_type);\n}\n\nsubsys_initcall(dp_aux_bus_init);\nmodule_exit(dp_aux_bus_exit);\n\nMODULE_AUTHOR(\"Douglas Anderson <dianders@chromium.org>\");\nMODULE_DESCRIPTION(\"DRM DisplayPort AUX bus\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}