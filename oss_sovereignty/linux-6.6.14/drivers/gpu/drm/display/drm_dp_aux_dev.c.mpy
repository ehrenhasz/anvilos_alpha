{
  "module_name": "drm_dp_aux_dev.c",
  "hash_id": "161cdbb4631605bbace53dd1b0c182327bfa5e8a4f23af3090571dd0a490c530",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_dp_aux_dev.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n\n#include <drm/display/drm_dp_helper.h>\n#include <drm/display/drm_dp_mst_helper.h>\n#include <drm/drm_crtc.h>\n#include <drm/drm_print.h>\n\n#include \"drm_dp_helper_internal.h\"\n\nstruct drm_dp_aux_dev {\n\tunsigned index;\n\tstruct drm_dp_aux *aux;\n\tstruct device *dev;\n\tstruct kref refcount;\n\tatomic_t usecount;\n};\n\n#define DRM_AUX_MINORS\t256\n#define AUX_MAX_OFFSET\t(1 << 20)\nstatic DEFINE_IDR(aux_idr);\nstatic DEFINE_MUTEX(aux_idr_mutex);\nstatic struct class *drm_dp_aux_dev_class;\nstatic int drm_dev_major = -1;\n\nstatic struct drm_dp_aux_dev *drm_dp_aux_dev_get_by_minor(unsigned index)\n{\n\tstruct drm_dp_aux_dev *aux_dev = NULL;\n\n\tmutex_lock(&aux_idr_mutex);\n\taux_dev = idr_find(&aux_idr, index);\n\tif (aux_dev && !kref_get_unless_zero(&aux_dev->refcount))\n\t\taux_dev = NULL;\n\tmutex_unlock(&aux_idr_mutex);\n\n\treturn aux_dev;\n}\n\nstatic struct drm_dp_aux_dev *alloc_drm_dp_aux_dev(struct drm_dp_aux *aux)\n{\n\tstruct drm_dp_aux_dev *aux_dev;\n\tint index;\n\n\taux_dev = kzalloc(sizeof(*aux_dev), GFP_KERNEL);\n\tif (!aux_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\taux_dev->aux = aux;\n\tatomic_set(&aux_dev->usecount, 1);\n\tkref_init(&aux_dev->refcount);\n\n\tmutex_lock(&aux_idr_mutex);\n\tindex = idr_alloc(&aux_idr, aux_dev, 0, DRM_AUX_MINORS, GFP_KERNEL);\n\tmutex_unlock(&aux_idr_mutex);\n\tif (index < 0) {\n\t\tkfree(aux_dev);\n\t\treturn ERR_PTR(index);\n\t}\n\taux_dev->index = index;\n\n\treturn aux_dev;\n}\n\nstatic void release_drm_dp_aux_dev(struct kref *ref)\n{\n\tstruct drm_dp_aux_dev *aux_dev =\n\t\tcontainer_of(ref, struct drm_dp_aux_dev, refcount);\n\n\tkfree(aux_dev);\n}\n\nstatic ssize_t name_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tssize_t res;\n\tstruct drm_dp_aux_dev *aux_dev =\n\t\tdrm_dp_aux_dev_get_by_minor(MINOR(dev->devt));\n\n\tif (!aux_dev)\n\t\treturn -ENODEV;\n\n\tres = sprintf(buf, \"%s\\n\", aux_dev->aux->name);\n\tkref_put(&aux_dev->refcount, release_drm_dp_aux_dev);\n\n\treturn res;\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic struct attribute *drm_dp_aux_attrs[] = {\n\t&dev_attr_name.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(drm_dp_aux);\n\nstatic int auxdev_open(struct inode *inode, struct file *file)\n{\n\tunsigned int minor = iminor(inode);\n\tstruct drm_dp_aux_dev *aux_dev;\n\n\taux_dev = drm_dp_aux_dev_get_by_minor(minor);\n\tif (!aux_dev)\n\t\treturn -ENODEV;\n\n\tfile->private_data = aux_dev;\n\treturn 0;\n}\n\nstatic loff_t auxdev_llseek(struct file *file, loff_t offset, int whence)\n{\n\treturn fixed_size_llseek(file, offset, whence, AUX_MAX_OFFSET);\n}\n\nstatic ssize_t auxdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct drm_dp_aux_dev *aux_dev = iocb->ki_filp->private_data;\n\tloff_t pos = iocb->ki_pos;\n\tssize_t res = 0;\n\n\tif (!atomic_inc_not_zero(&aux_dev->usecount))\n\t\treturn -ENODEV;\n\n\tiov_iter_truncate(to, AUX_MAX_OFFSET - pos);\n\n\twhile (iov_iter_count(to)) {\n\t\tuint8_t buf[DP_AUX_MAX_PAYLOAD_BYTES];\n\t\tssize_t todo = min(iov_iter_count(to), sizeof(buf));\n\n\t\tif (signal_pending(current)) {\n\t\t\tres = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tres = drm_dp_dpcd_read(aux_dev->aux, pos, buf, todo);\n\n\t\tif (res <= 0)\n\t\t\tbreak;\n\n\t\tif (copy_to_iter(buf, res, to) != res) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += res;\n\t}\n\n\tif (pos != iocb->ki_pos)\n\t\tres = pos - iocb->ki_pos;\n\tiocb->ki_pos = pos;\n\n\tif (atomic_dec_and_test(&aux_dev->usecount))\n\t\twake_up_var(&aux_dev->usecount);\n\n\treturn res;\n}\n\nstatic ssize_t auxdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct drm_dp_aux_dev *aux_dev = iocb->ki_filp->private_data;\n\tloff_t pos = iocb->ki_pos;\n\tssize_t res = 0;\n\n\tif (!atomic_inc_not_zero(&aux_dev->usecount))\n\t\treturn -ENODEV;\n\n\tiov_iter_truncate(from, AUX_MAX_OFFSET - pos);\n\n\twhile (iov_iter_count(from)) {\n\t\tuint8_t buf[DP_AUX_MAX_PAYLOAD_BYTES];\n\t\tssize_t todo = min(iov_iter_count(from), sizeof(buf));\n\n\t\tif (signal_pending(current)) {\n\t\t\tres = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!copy_from_iter_full(buf, todo, from)) {\n\t\t\tres = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tres = drm_dp_dpcd_write(aux_dev->aux, pos, buf, todo);\n\n\t\tif (res <= 0)\n\t\t\tbreak;\n\n\t\tpos += res;\n\t}\n\n\tif (pos != iocb->ki_pos)\n\t\tres = pos - iocb->ki_pos;\n\tiocb->ki_pos = pos;\n\n\tif (atomic_dec_and_test(&aux_dev->usecount))\n\t\twake_up_var(&aux_dev->usecount);\n\n\treturn res;\n}\n\nstatic int auxdev_release(struct inode *inode, struct file *file)\n{\n\tstruct drm_dp_aux_dev *aux_dev = file->private_data;\n\n\tkref_put(&aux_dev->refcount, release_drm_dp_aux_dev);\n\treturn 0;\n}\n\nstatic const struct file_operations auxdev_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.llseek\t\t= auxdev_llseek,\n\t.read_iter\t= auxdev_read_iter,\n\t.write_iter\t= auxdev_write_iter,\n\t.open\t\t= auxdev_open,\n\t.release\t= auxdev_release,\n};\n\n#define to_auxdev(d) container_of(d, struct drm_dp_aux_dev, aux)\n\nstatic struct drm_dp_aux_dev *drm_dp_aux_dev_get_by_aux(struct drm_dp_aux *aux)\n{\n\tstruct drm_dp_aux_dev *iter, *aux_dev = NULL;\n\tint id;\n\n\t \n\tmutex_lock(&aux_idr_mutex);\n\tidr_for_each_entry(&aux_idr, iter, id) {\n\t\tif (iter->aux == aux) {\n\t\t\taux_dev = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&aux_idr_mutex);\n\treturn aux_dev;\n}\n\nvoid drm_dp_aux_unregister_devnode(struct drm_dp_aux *aux)\n{\n\tstruct drm_dp_aux_dev *aux_dev;\n\tunsigned int minor;\n\n\taux_dev = drm_dp_aux_dev_get_by_aux(aux);\n\tif (!aux_dev)  \n\t\treturn;\n\n\t \n\taux->drm_dev = NULL;\n\n\tmutex_lock(&aux_idr_mutex);\n\tidr_remove(&aux_idr, aux_dev->index);\n\tmutex_unlock(&aux_idr_mutex);\n\n\tatomic_dec(&aux_dev->usecount);\n\twait_var_event(&aux_dev->usecount, !atomic_read(&aux_dev->usecount));\n\n\tminor = aux_dev->index;\n\tif (aux_dev->dev)\n\t\tdevice_destroy(drm_dp_aux_dev_class,\n\t\t\t       MKDEV(drm_dev_major, minor));\n\n\tDRM_DEBUG(\"drm_dp_aux_dev: aux [%s] unregistering\\n\", aux->name);\n\tkref_put(&aux_dev->refcount, release_drm_dp_aux_dev);\n}\n\nint drm_dp_aux_register_devnode(struct drm_dp_aux *aux)\n{\n\tstruct drm_dp_aux_dev *aux_dev;\n\tint res;\n\n\taux_dev = alloc_drm_dp_aux_dev(aux);\n\tif (IS_ERR(aux_dev))\n\t\treturn PTR_ERR(aux_dev);\n\n\taux_dev->dev = device_create(drm_dp_aux_dev_class, aux->dev,\n\t\t\t\t     MKDEV(drm_dev_major, aux_dev->index), NULL,\n\t\t\t\t     \"drm_dp_aux%d\", aux_dev->index);\n\tif (IS_ERR(aux_dev->dev)) {\n\t\tres = PTR_ERR(aux_dev->dev);\n\t\taux_dev->dev = NULL;\n\t\tgoto error;\n\t}\n\n\tDRM_DEBUG(\"drm_dp_aux_dev: aux [%s] registered as minor %d\\n\",\n\t\t  aux->name, aux_dev->index);\n\treturn 0;\nerror:\n\tdrm_dp_aux_unregister_devnode(aux);\n\treturn res;\n}\n\nint drm_dp_aux_dev_init(void)\n{\n\tint res;\n\n\tdrm_dp_aux_dev_class = class_create(\"drm_dp_aux_dev\");\n\tif (IS_ERR(drm_dp_aux_dev_class)) {\n\t\treturn PTR_ERR(drm_dp_aux_dev_class);\n\t}\n\tdrm_dp_aux_dev_class->dev_groups = drm_dp_aux_groups;\n\n\tres = register_chrdev(0, \"aux\", &auxdev_fops);\n\tif (res < 0)\n\t\tgoto out;\n\tdrm_dev_major = res;\n\n\treturn 0;\nout:\n\tclass_destroy(drm_dp_aux_dev_class);\n\treturn res;\n}\n\nvoid drm_dp_aux_dev_exit(void)\n{\n\tunregister_chrdev(drm_dev_major, \"aux\");\n\tclass_destroy(drm_dp_aux_dev_class);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}