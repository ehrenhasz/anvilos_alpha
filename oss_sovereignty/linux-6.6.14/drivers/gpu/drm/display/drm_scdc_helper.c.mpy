{
  "module_name": "drm_scdc_helper.c",
  "hash_id": "59399e9c5c03d6aad04fca8e2e0678d059b910c53ffac43d2a8d007b7852c21f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_scdc_helper.c",
  "human_readable_source": " \n\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n\n#include <drm/display/drm_scdc_helper.h>\n#include <drm/drm_connector.h>\n#include <drm/drm_device.h>\n#include <drm/drm_print.h>\n\n \n\n#define SCDC_I2C_SLAVE_ADDRESS 0x54\n\n \nssize_t drm_scdc_read(struct i2c_adapter *adapter, u8 offset, void *buffer,\n\t\t      size_t size)\n{\n\tint ret;\n\tstruct i2c_msg msgs[2] = {\n\t\t{\n\t\t\t.addr = SCDC_I2C_SLAVE_ADDRESS,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &offset,\n\t\t}, {\n\t\t\t.addr = SCDC_I2C_SLAVE_ADDRESS,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = size,\n\t\t\t.buf = buffer,\n\t\t}\n\t};\n\n\tret = i2c_transfer(adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_scdc_read);\n\n \nssize_t drm_scdc_write(struct i2c_adapter *adapter, u8 offset,\n\t\t       const void *buffer, size_t size)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = SCDC_I2C_SLAVE_ADDRESS,\n\t\t.flags = 0,\n\t\t.len = 1 + size,\n\t\t.buf = NULL,\n\t};\n\tvoid *data;\n\tint err;\n\n\tdata = kmalloc(1 + size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmsg.buf = data;\n\n\tmemcpy(data, &offset, sizeof(offset));\n\tmemcpy(data + 1, buffer, size);\n\n\terr = i2c_transfer(adapter, &msg, 1);\n\n\tkfree(data);\n\n\tif (err < 0)\n\t\treturn err;\n\tif (err != 1)\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_scdc_write);\n\n \nbool drm_scdc_get_scrambling_status(struct drm_connector *connector)\n{\n\tu8 status;\n\tint ret;\n\n\tret = drm_scdc_readb(connector->ddc, SCDC_SCRAMBLER_STATUS, &status);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to read scrambling status: %d\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\treturn false;\n\t}\n\n\treturn status & SCDC_SCRAMBLING_STATUS;\n}\nEXPORT_SYMBOL(drm_scdc_get_scrambling_status);\n\n \nbool drm_scdc_set_scrambling(struct drm_connector *connector,\n\t\t\t     bool enable)\n{\n\tu8 config;\n\tint ret;\n\n\tret = drm_scdc_readb(connector->ddc, SCDC_TMDS_CONFIG, &config);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to read TMDS config: %d\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\treturn false;\n\t}\n\n\tif (enable)\n\t\tconfig |= SCDC_SCRAMBLING_ENABLE;\n\telse\n\t\tconfig &= ~SCDC_SCRAMBLING_ENABLE;\n\n\tret = drm_scdc_writeb(connector->ddc, SCDC_TMDS_CONFIG, config);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to enable scrambling: %d\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(drm_scdc_set_scrambling);\n\n \nbool drm_scdc_set_high_tmds_clock_ratio(struct drm_connector *connector,\n\t\t\t\t\tbool set)\n{\n\tu8 config;\n\tint ret;\n\n\tret = drm_scdc_readb(connector->ddc, SCDC_TMDS_CONFIG, &config);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to read TMDS config: %d\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\treturn false;\n\t}\n\n\tif (set)\n\t\tconfig |= SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;\n\telse\n\t\tconfig &= ~SCDC_TMDS_BIT_CLOCK_RATIO_BY_40;\n\n\tret = drm_scdc_writeb(connector->ddc, SCDC_TMDS_CONFIG, config);\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(connector->dev,\n\t\t\t    \"[CONNECTOR:%d:%s] Failed to set TMDS clock ratio: %d\\n\",\n\t\t\t    connector->base.id, connector->name, ret);\n\t\treturn false;\n\t}\n\n\t \n\tusleep_range(1000, 2000);\n\treturn true;\n}\nEXPORT_SYMBOL(drm_scdc_set_high_tmds_clock_ratio);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}