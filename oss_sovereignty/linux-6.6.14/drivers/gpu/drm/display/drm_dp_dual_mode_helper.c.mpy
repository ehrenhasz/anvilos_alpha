{
  "module_name": "drm_dp_dual_mode_helper.c",
  "hash_id": "e8fd375c942a1151ee4b8b47a889e11263ef087143f6f384fb52b771f69914b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/display/drm_dp_dual_mode_helper.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\n#include <drm/display/drm_dp_dual_mode_helper.h>\n#include <drm/drm_device.h>\n#include <drm/drm_print.h>\n\n \n\n#define DP_DUAL_MODE_SLAVE_ADDRESS 0x40\n\n \nssize_t drm_dp_dual_mode_read(struct i2c_adapter *adapter,\n\t\t\t      u8 offset, void *buffer, size_t size)\n{\n\tu8 zero = 0;\n\tchar *tmpbuf = NULL;\n\t \n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = DP_DUAL_MODE_SLAVE_ADDRESS,\n\t\t\t.flags = 0,\n\t\t\t.len = 1,\n\t\t\t.buf = &zero,\n\t\t},\n\t\t{\n\t\t\t.addr = DP_DUAL_MODE_SLAVE_ADDRESS,\n\t\t\t.flags = I2C_M_RD,\n\t\t\t.len = size + offset,\n\t\t\t.buf = buffer,\n\t\t},\n\t};\n\tint ret;\n\n\tif (offset) {\n\t\ttmpbuf = kmalloc(size + offset, GFP_KERNEL);\n\t\tif (!tmpbuf)\n\t\t\treturn -ENOMEM;\n\n\t\tmsgs[1].buf = tmpbuf;\n\t}\n\n\tret = i2c_transfer(adapter, msgs, ARRAY_SIZE(msgs));\n\tif (tmpbuf)\n\t\tmemcpy(buffer, tmpbuf + offset, size);\n\n\tkfree(tmpbuf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != ARRAY_SIZE(msgs))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_dual_mode_read);\n\n \nssize_t drm_dp_dual_mode_write(struct i2c_adapter *adapter,\n\t\t\t       u8 offset, const void *buffer, size_t size)\n{\n\tstruct i2c_msg msg = {\n\t\t.addr = DP_DUAL_MODE_SLAVE_ADDRESS,\n\t\t.flags = 0,\n\t\t.len = 1 + size,\n\t\t.buf = NULL,\n\t};\n\tvoid *data;\n\tint ret;\n\n\tdata = kmalloc(msg.len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tmsg.buf = data;\n\n\tmemcpy(data, &offset, 1);\n\tmemcpy(data + 1, buffer, size);\n\n\tret = i2c_transfer(adapter, &msg, 1);\n\n\tkfree(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != 1)\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_dual_mode_write);\n\nstatic bool is_hdmi_adaptor(const char hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN])\n{\n\tstatic const char dp_dual_mode_hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN] =\n\t\t\"DP-HDMI ADAPTOR\\x04\";\n\n\treturn memcmp(hdmi_id, dp_dual_mode_hdmi_id,\n\t\t      sizeof(dp_dual_mode_hdmi_id)) == 0;\n}\n\nstatic bool is_type1_adaptor(uint8_t adaptor_id)\n{\n\treturn adaptor_id == 0 || adaptor_id == 0xff;\n}\n\nstatic bool is_type2_adaptor(uint8_t adaptor_id)\n{\n\treturn adaptor_id == (DP_DUAL_MODE_TYPE_TYPE2 |\n\t\t\t      DP_DUAL_MODE_REV_TYPE2);\n}\n\nstatic bool is_lspcon_adaptor(const char hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN],\n\t\t\t      const uint8_t adaptor_id)\n{\n\treturn is_hdmi_adaptor(hdmi_id) &&\n\t\t(adaptor_id == (DP_DUAL_MODE_TYPE_TYPE2 |\n\t\t DP_DUAL_MODE_TYPE_HAS_DPCD));\n}\n\n \nenum drm_dp_dual_mode_type drm_dp_dual_mode_detect(const struct drm_device *dev,\n\t\t\t\t\t\t   struct i2c_adapter *adapter)\n{\n\tchar hdmi_id[DP_DUAL_MODE_HDMI_ID_LEN] = {};\n\tuint8_t adaptor_id = 0x00;\n\tssize_t ret;\n\n\t \n\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_HDMI_ID,\n\t\t\t\t    hdmi_id, sizeof(hdmi_id));\n\tdrm_dbg_kms(dev, \"DP dual mode HDMI ID: %*pE (err %zd)\\n\",\n\t\t    ret ? 0 : (int)sizeof(hdmi_id), hdmi_id, ret);\n\tif (ret)\n\t\treturn DRM_DP_DUAL_MODE_UNKNOWN;\n\n\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_ADAPTOR_ID,\n\t\t\t\t    &adaptor_id, sizeof(adaptor_id));\n\tdrm_dbg_kms(dev, \"DP dual mode adaptor ID: %02x (err %zd)\\n\", adaptor_id, ret);\n\tif (ret == 0) {\n\t\tif (is_lspcon_adaptor(hdmi_id, adaptor_id))\n\t\t\treturn DRM_DP_DUAL_MODE_LSPCON;\n\t\tif (is_type2_adaptor(adaptor_id)) {\n\t\t\tif (is_hdmi_adaptor(hdmi_id))\n\t\t\t\treturn DRM_DP_DUAL_MODE_TYPE2_HDMI;\n\t\t\telse\n\t\t\t\treturn DRM_DP_DUAL_MODE_TYPE2_DVI;\n\t\t}\n\t\t \n\t\tif (!is_type1_adaptor(adaptor_id))\n\t\t\tdrm_err(dev, \"Unexpected DP dual mode adaptor ID %02x\\n\", adaptor_id);\n\n\t}\n\n\tif (is_hdmi_adaptor(hdmi_id))\n\t\treturn DRM_DP_DUAL_MODE_TYPE1_HDMI;\n\telse\n\t\treturn DRM_DP_DUAL_MODE_TYPE1_DVI;\n}\nEXPORT_SYMBOL(drm_dp_dual_mode_detect);\n\n \nint drm_dp_dual_mode_max_tmds_clock(const struct drm_device *dev, enum drm_dp_dual_mode_type type,\n\t\t\t\t    struct i2c_adapter *adapter)\n{\n\tuint8_t max_tmds_clock;\n\tssize_t ret;\n\n\t \n\tif (type == DRM_DP_DUAL_MODE_NONE)\n\t\treturn 0;\n\n\t \n\tif (type < DRM_DP_DUAL_MODE_TYPE2_DVI)\n\t\treturn 165000;\n\n\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_MAX_TMDS_CLOCK,\n\t\t\t\t    &max_tmds_clock, sizeof(max_tmds_clock));\n\tif (ret || max_tmds_clock == 0x00 || max_tmds_clock == 0xff) {\n\t\tdrm_dbg_kms(dev, \"Failed to query max TMDS clock\\n\");\n\t\treturn 165000;\n\t}\n\n\treturn max_tmds_clock * 5000 / 2;\n}\nEXPORT_SYMBOL(drm_dp_dual_mode_max_tmds_clock);\n\n \nint drm_dp_dual_mode_get_tmds_output(const struct drm_device *dev,\n\t\t\t\t     enum drm_dp_dual_mode_type type, struct i2c_adapter *adapter,\n\t\t\t\t     bool *enabled)\n{\n\tuint8_t tmds_oen;\n\tssize_t ret;\n\n\tif (type < DRM_DP_DUAL_MODE_TYPE2_DVI) {\n\t\t*enabled = true;\n\t\treturn 0;\n\t}\n\n\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_TMDS_OEN,\n\t\t\t\t    &tmds_oen, sizeof(tmds_oen));\n\tif (ret) {\n\t\tdrm_dbg_kms(dev, \"Failed to query state of TMDS output buffers\\n\");\n\t\treturn ret;\n\t}\n\n\t*enabled = !(tmds_oen & DP_DUAL_MODE_TMDS_DISABLE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_dp_dual_mode_get_tmds_output);\n\n \nint drm_dp_dual_mode_set_tmds_output(const struct drm_device *dev, enum drm_dp_dual_mode_type type,\n\t\t\t\t     struct i2c_adapter *adapter, bool enable)\n{\n\tuint8_t tmds_oen = enable ? 0 : DP_DUAL_MODE_TMDS_DISABLE;\n\tssize_t ret;\n\tint retry;\n\n\tif (type < DRM_DP_DUAL_MODE_TYPE2_DVI)\n\t\treturn 0;\n\n\t \n\tfor (retry = 0; retry < 3; retry++) {\n\t\tuint8_t tmp;\n\n\t\tret = drm_dp_dual_mode_write(adapter, DP_DUAL_MODE_TMDS_OEN,\n\t\t\t\t\t     &tmds_oen, sizeof(tmds_oen));\n\t\tif (ret) {\n\t\t\tdrm_dbg_kms(dev, \"Failed to %s TMDS output buffers (%d attempts)\\n\",\n\t\t\t\t    enable ? \"enable\" : \"disable\", retry + 1);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = drm_dp_dual_mode_read(adapter, DP_DUAL_MODE_TMDS_OEN,\n\t\t\t\t\t    &tmp, sizeof(tmp));\n\t\tif (ret) {\n\t\t\tdrm_dbg_kms(dev,\n\t\t\t\t    \"I2C read failed during TMDS output buffer %s (%d attempts)\\n\",\n\t\t\t\t    enable ? \"enabling\" : \"disabling\", retry + 1);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (tmp == tmds_oen)\n\t\t\treturn 0;\n\t}\n\n\tdrm_dbg_kms(dev, \"I2C write value mismatch during TMDS output buffer %s\\n\",\n\t\t    enable ? \"enabling\" : \"disabling\");\n\n\treturn -EIO;\n}\nEXPORT_SYMBOL(drm_dp_dual_mode_set_tmds_output);\n\n \nconst char *drm_dp_get_dual_mode_type_name(enum drm_dp_dual_mode_type type)\n{\n\tswitch (type) {\n\tcase DRM_DP_DUAL_MODE_NONE:\n\t\treturn \"none\";\n\tcase DRM_DP_DUAL_MODE_TYPE1_DVI:\n\t\treturn \"type 1 DVI\";\n\tcase DRM_DP_DUAL_MODE_TYPE1_HDMI:\n\t\treturn \"type 1 HDMI\";\n\tcase DRM_DP_DUAL_MODE_TYPE2_DVI:\n\t\treturn \"type 2 DVI\";\n\tcase DRM_DP_DUAL_MODE_TYPE2_HDMI:\n\t\treturn \"type 2 HDMI\";\n\tcase DRM_DP_DUAL_MODE_LSPCON:\n\t\treturn \"lspcon\";\n\tdefault:\n\t\tWARN_ON(type != DRM_DP_DUAL_MODE_UNKNOWN);\n\t\treturn \"unknown\";\n\t}\n}\nEXPORT_SYMBOL(drm_dp_get_dual_mode_type_name);\n\n \nint drm_lspcon_get_mode(const struct drm_device *dev, struct i2c_adapter *adapter,\n\t\t\tenum drm_lspcon_mode *mode)\n{\n\tu8 data;\n\tint ret = 0;\n\tint retry;\n\n\tif (!mode) {\n\t\tdrm_err(dev, \"NULL input\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (retry = 0; retry < 6; retry++) {\n\t\tif (retry)\n\t\t\tusleep_range(500, 1000);\n\n\t\tret = drm_dp_dual_mode_read(adapter,\n\t\t\t\t\t    DP_DUAL_MODE_LSPCON_CURRENT_MODE,\n\t\t\t\t\t    &data, sizeof(data));\n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tdrm_dbg_kms(dev, \"LSPCON read(0x80, 0x41) failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (data & DP_DUAL_MODE_LSPCON_MODE_PCON)\n\t\t*mode = DRM_LSPCON_MODE_PCON;\n\telse\n\t\t*mode = DRM_LSPCON_MODE_LS;\n\treturn 0;\n}\nEXPORT_SYMBOL(drm_lspcon_get_mode);\n\n \nint drm_lspcon_set_mode(const struct drm_device *dev, struct i2c_adapter *adapter,\n\t\t\tenum drm_lspcon_mode mode)\n{\n\tu8 data = 0;\n\tint ret;\n\tint time_out = 200;\n\tenum drm_lspcon_mode current_mode;\n\n\tif (mode == DRM_LSPCON_MODE_PCON)\n\t\tdata = DP_DUAL_MODE_LSPCON_MODE_PCON;\n\n\t \n\tret = drm_dp_dual_mode_write(adapter, DP_DUAL_MODE_LSPCON_MODE_CHANGE,\n\t\t\t\t     &data, sizeof(data));\n\tif (ret < 0) {\n\t\tdrm_err(dev, \"LSPCON mode change failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdo {\n\t\tret = drm_lspcon_get_mode(dev, adapter, &current_mode);\n\t\tif (ret) {\n\t\t\tdrm_err(dev, \"can't confirm LSPCON mode change\\n\");\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tif (current_mode != mode) {\n\t\t\t\tmsleep(10);\n\t\t\t\ttime_out -= 10;\n\t\t\t} else {\n\t\t\t\tdrm_dbg_kms(dev, \"LSPCON mode changed to %s\\n\",\n\t\t\t\t\t    mode == DRM_LSPCON_MODE_LS ? \"LS\" : \"PCON\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} while (time_out);\n\n\tdrm_err(dev, \"LSPCON mode change timed out\\n\");\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL(drm_lspcon_set_mode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}