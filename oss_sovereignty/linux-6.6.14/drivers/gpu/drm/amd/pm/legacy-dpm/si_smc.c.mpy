{
  "module_name": "si_smc.c",
  "hash_id": "0c9851fa1e9af5fc6ac67f7addb4a36d49c3b299f8766a3ced3abfe28958c7d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/legacy-dpm/si_smc.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n\n#include \"amdgpu.h\"\n#include \"sid.h\"\n#include \"ppsmc.h\"\n#include \"amdgpu_ucode.h\"\n#include \"sislands_smc.h\"\n\nstatic int si_set_smc_sram_address(struct amdgpu_device *adev,\n\t\t\t\t   u32 smc_address, u32 limit)\n{\n\tif (smc_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_address + 3) > limit)\n\t\treturn -EINVAL;\n\n\tWREG32(SMC_IND_INDEX_0, smc_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\n\treturn 0;\n}\n\nint amdgpu_si_copy_bytes_to_smc(struct amdgpu_device *adev,\n\t\t\t\tu32 smc_start_address,\n\t\t\t\tconst u8 *src, u32 byte_count, u32 limit)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 data, original_data, addr, extra_shift;\n\n\tif (smc_start_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_start_address + byte_count) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_start_address;\n\n\tspin_lock_irqsave(&adev->smc_idx_lock, flags);\n\twhile (byte_count >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tret = si_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\t \n\tif (byte_count > 0) {\n\t\tdata = 0;\n\n\t\tret = si_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\toriginal_data = RREG32(SMC_IND_DATA_0);\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (data << 8) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tret = si_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nvoid amdgpu_si_start_smc(struct amdgpu_device *adev)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\n\ttmp &= ~RST_REG;\n\n\tWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\n}\n\nvoid amdgpu_si_reset_smc(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\tRREG32(CB_CGTT_SCLK_CTRL);\n\n\ttmp = RREG32_SMC(SMC_SYSCON_RESET_CNTL) |\n\t      RST_REG;\n\tWREG32_SMC(SMC_SYSCON_RESET_CNTL, tmp);\n}\n\nint amdgpu_si_program_jump_on_start(struct amdgpu_device *adev)\n{\n\tstatic const u8 data[] = { 0x0E, 0x00, 0x40, 0x40 };\n\n\treturn amdgpu_si_copy_bytes_to_smc(adev, 0x0, data, 4, sizeof(data)+1);\n}\n\nvoid amdgpu_si_smc_clock(struct amdgpu_device *adev, bool enable)\n{\n\tu32 tmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\tif (enable)\n\t\ttmp &= ~CK_DISABLE;\n\telse\n\t\ttmp |= CK_DISABLE;\n\n\tWREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0, tmp);\n}\n\nbool amdgpu_si_is_smc_running(struct amdgpu_device *adev)\n{\n\tu32 rst = RREG32_SMC(SMC_SYSCON_RESET_CNTL);\n\tu32 clk = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\n\tif (!(rst & RST_REG) && !(clk & CK_DISABLE))\n\t\treturn true;\n\n\treturn false;\n}\n\nPPSMC_Result amdgpu_si_send_msg_to_smc(struct amdgpu_device *adev,\n\t\t\t\t       PPSMC_Msg msg)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!amdgpu_si_is_smc_running(adev))\n\t\treturn PPSMC_Result_Failed;\n\n\tWREG32(SMC_MESSAGE_0, msg);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32(SMC_RESP_0);\n\t\tif (tmp != 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn (PPSMC_Result)RREG32(SMC_RESP_0);\n}\n\nPPSMC_Result amdgpu_si_wait_for_smc_inactive(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\tint i;\n\n\tif (!amdgpu_si_is_smc_running(adev))\n\t\treturn PPSMC_Result_OK;\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\ttmp = RREG32_SMC(SMC_SYSCON_CLOCK_CNTL_0);\n\t\tif ((tmp & CKEN) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\treturn PPSMC_Result_OK;\n}\n\nint amdgpu_si_load_smc_ucode(struct amdgpu_device *adev, u32 limit)\n{\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tunsigned long flags;\n\tu32 ucode_start_address;\n\tu32 ucode_size;\n\tconst u8 *src;\n\tu32 data;\n\n\tif (!adev->pm.fw)\n\t\treturn -EINVAL;\n\n\thdr = (const struct smc_firmware_header_v1_0 *)adev->pm.fw->data;\n\n\tamdgpu_ucode_print_smc_hdr(&hdr->header);\n\n\tadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\n\tucode_start_address = le32_to_cpu(hdr->ucode_start_addr);\n\tucode_size = le32_to_cpu(hdr->header.ucode_size_bytes);\n\tsrc = (const u8 *)\n\t\t(adev->pm.fw->data + le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\tif (ucode_size & 3)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&adev->smc_idx_lock, flags);\n\tWREG32(SMC_IND_INDEX_0, ucode_start_address);\n\tWREG32_P(SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, ~AUTO_INCREMENT_IND_0);\n\twhile (ucode_size >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) | (src[1] << 16) | (src[2] << 8) | src[3];\n\n\t\tWREG32(SMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tucode_size -= 4;\n\t}\n\tWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\n\tspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\n\n\treturn 0;\n}\n\nint amdgpu_si_read_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,\n\t\t\t\t  u32 *value, u32 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&adev->smc_idx_lock, flags);\n\tret = si_set_smc_sram_address(adev, smc_address, limit);\n\tif (ret == 0)\n\t\t*value = RREG32(SMC_IND_DATA_0);\n\tspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n\nint amdgpu_si_write_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,\n\t\t\t\t   u32 value, u32 limit)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&adev->smc_idx_lock, flags);\n\tret = si_set_smc_sram_address(adev, smc_address, limit);\n\tif (ret == 0)\n\t\tWREG32(SMC_IND_DATA_0, value);\n\tspin_unlock_irqrestore(&adev->smc_idx_lock, flags);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}