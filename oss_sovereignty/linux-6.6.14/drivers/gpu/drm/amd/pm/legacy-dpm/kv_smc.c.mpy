{
  "module_name": "kv_smc.c",
  "hash_id": "c3c9775d048fab71ea504c2fcf2ccc1e808a6786e9912005156898e1452e1ecc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/legacy-dpm/kv_smc.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"cikd.h\"\n#include \"kv_dpm.h\"\n\n#include \"smu/smu_7_0_0_d.h\"\n#include \"smu/smu_7_0_0_sh_mask.h\"\n\nint amdgpu_kv_notify_message_to_smu(struct amdgpu_device *adev, u32 id)\n{\n\tu32 i;\n\tu32 tmp = 0;\n\n\tWREG32(mmSMC_MESSAGE_0, id & SMC_MESSAGE_0__SMC_MSG_MASK);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif ((RREG32(mmSMC_RESP_0) & SMC_RESP_0__SMC_RESP_MASK) != 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\ttmp = RREG32(mmSMC_RESP_0) & SMC_RESP_0__SMC_RESP_MASK;\n\n\tif (tmp != 1) {\n\t\tif (tmp == 0xFF)\n\t\t\treturn -EINVAL;\n\t\telse if (tmp == 0xFE)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_kv_dpm_get_enable_mask(struct amdgpu_device *adev, u32 *enable_mask)\n{\n\tint ret;\n\n\tret = amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_SCLKDPM_GetEnabledMask);\n\n\tif (ret == 0)\n\t\t*enable_mask = RREG32_SMC(ixSMC_SYSCON_MSG_ARG_0);\n\n\treturn ret;\n}\n\nint amdgpu_kv_send_msg_to_smc_with_parameter(struct amdgpu_device *adev,\n\t\t\t\t      PPSMC_Msg msg, u32 parameter)\n{\n\n\tWREG32(mmSMC_MSG_ARG_0, parameter);\n\n\treturn amdgpu_kv_notify_message_to_smu(adev, msg);\n}\n\nstatic int kv_set_smc_sram_address(struct amdgpu_device *adev,\n\t\t\t\t   u32 smc_address, u32 limit)\n{\n\tif (smc_address & 3)\n\t\treturn -EINVAL;\n\tif ((smc_address + 3) > limit)\n\t\treturn -EINVAL;\n\n\tWREG32(mmSMC_IND_INDEX_0, smc_address);\n\tWREG32_P(mmSMC_IND_ACCESS_CNTL, 0,\n\t\t\t~SMC_IND_ACCESS_CNTL__AUTO_INCREMENT_IND_0_MASK);\n\n\treturn 0;\n}\n\nint amdgpu_kv_read_smc_sram_dword(struct amdgpu_device *adev, u32 smc_address,\n\t\t\t   u32 *value, u32 limit)\n{\n\tint ret;\n\n\tret = kv_set_smc_sram_address(adev, smc_address, limit);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = RREG32(mmSMC_IND_DATA_0);\n\treturn 0;\n}\n\nint amdgpu_kv_smc_dpm_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\treturn amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_DPM_Enable);\n\telse\n\t\treturn amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_DPM_Disable);\n}\n\nint amdgpu_kv_smc_bapm_enable(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\treturn amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_EnableBAPM);\n\telse\n\t\treturn amdgpu_kv_notify_message_to_smu(adev, PPSMC_MSG_DisableBAPM);\n}\n\nint amdgpu_kv_copy_bytes_to_smc(struct amdgpu_device *adev,\n\t\t\t u32 smc_start_address,\n\t\t\t const u8 *src, u32 byte_count, u32 limit)\n{\n\tint ret;\n\tu32 data, original_data, addr, extra_shift, t_byte, count, mask;\n\n\tif ((smc_start_address + byte_count) > limit)\n\t\treturn -EINVAL;\n\n\taddr = smc_start_address;\n\tt_byte = addr & 3;\n\n\t \n\tif  (t_byte != 0) {\n\t\taddr -= t_byte;\n\n\t\tret = kv_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toriginal_data = RREG32(mmSMC_IND_DATA_0);\n\n\t\tdata = 0;\n\t\tmask = 0;\n\t\tcount = 4;\n\t\twhile (count > 0) {\n\t\t\tif (t_byte > 0) {\n\t\t\t\tmask = (mask << 8) | 0xff;\n\t\t\t\tt_byte--;\n\t\t\t} else if (byte_count > 0) {\n\t\t\t\tdata = (data << 8) + *src++;\n\t\t\t\tbyte_count--;\n\t\t\t\tmask <<= 8;\n\t\t\t} else {\n\t\t\t\tdata <<= 8;\n\t\t\t\tmask = (mask << 8) | 0xff;\n\t\t\t}\n\t\t\tcount--;\n\t\t}\n\n\t\tdata |= original_data & mask;\n\n\t\tret = kv_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(mmSMC_IND_DATA_0, data);\n\n\t\taddr += 4;\n\t}\n\n\twhile (byte_count >= 4) {\n\t\t \n\t\tdata = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];\n\n\t\tret = kv_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(mmSMC_IND_DATA_0, data);\n\n\t\tsrc += 4;\n\t\tbyte_count -= 4;\n\t\taddr += 4;\n\t}\n\n\t \n\tif (byte_count > 0) {\n\t\tdata = 0;\n\n\t\tret = kv_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\toriginal_data = RREG32(mmSMC_IND_DATA_0);\n\n\t\textra_shift = 8 * (4 - byte_count);\n\n\t\twhile (byte_count > 0) {\n\t\t\t \n\t\t\tdata = (data << 8) + *src++;\n\t\t\tbyte_count--;\n\t\t}\n\n\t\tdata <<= extra_shift;\n\n\t\tdata |= (original_data & ~((~0UL) << extra_shift));\n\n\t\tret = kv_set_smc_sram_address(adev, addr, limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(mmSMC_IND_DATA_0, data);\n\t}\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}