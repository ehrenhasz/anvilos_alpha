{
  "module_name": "legacy_dpm.c",
  "hash_id": "d831ecf7665675e0df6bc401faa3ca1405b281627d679307f4ceca86f2114823",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/legacy-dpm/legacy_dpm.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_i2c.h\"\n#include \"amdgpu_atombios.h\"\n#include \"atom.h\"\n#include \"amd_pcie.h\"\n#include \"legacy_dpm.h\"\n#include \"amdgpu_dpm_internal.h\"\n#include \"amdgpu_display.h\"\n\n#define amdgpu_dpm_pre_set_power_state(adev) \\\n\t\t((adev)->powerplay.pp_funcs->pre_set_power_state((adev)->powerplay.pp_handle))\n\n#define amdgpu_dpm_post_set_power_state(adev) \\\n\t\t((adev)->powerplay.pp_funcs->post_set_power_state((adev)->powerplay.pp_handle))\n\n#define amdgpu_dpm_display_configuration_changed(adev) \\\n\t\t((adev)->powerplay.pp_funcs->display_configuration_changed((adev)->powerplay.pp_handle))\n\n#define amdgpu_dpm_print_power_state(adev, ps) \\\n\t\t((adev)->powerplay.pp_funcs->print_power_state((adev)->powerplay.pp_handle, (ps)))\n\n#define amdgpu_dpm_vblank_too_short(adev) \\\n\t\t((adev)->powerplay.pp_funcs->vblank_too_short((adev)->powerplay.pp_handle))\n\n#define amdgpu_dpm_check_state_equal(adev, cps, rps, equal) \\\n\t\t((adev)->powerplay.pp_funcs->check_state_equal((adev)->powerplay.pp_handle, (cps), (rps), (equal)))\n\nvoid amdgpu_dpm_print_class_info(u32 class, u32 class2)\n{\n\tconst char *s;\n\n\tswitch (class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) {\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_NONE:\n\tdefault:\n\t\ts = \"none\";\n\t\tbreak;\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_BATTERY:\n\t\ts = \"battery\";\n\t\tbreak;\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_BALANCED:\n\t\ts = \"balanced\";\n\t\tbreak;\n\tcase ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE:\n\t\ts = \"performance\";\n\t\tbreak;\n\t}\n\tprintk(\"\\tui class: %s\\n\", s);\n\tprintk(\"\\tinternal class:\");\n\tif (((class & ~ATOM_PPLIB_CLASSIFICATION_UI_MASK) == 0) &&\n\t    (class2 == 0))\n\t\tpr_cont(\" none\");\n\telse {\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\t\tpr_cont(\" boot\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\t\tpr_cont(\" thermal\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\n\t\t\tpr_cont(\" limited_pwr\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_REST)\n\t\t\tpr_cont(\" rest\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_FORCED)\n\t\t\tpr_cont(\" forced\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\n\t\t\tpr_cont(\" 3d_perf\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_OVERDRIVETEMPLATE)\n\t\t\tpr_cont(\" ovrdrv\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\t\tpr_cont(\" uvd\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_3DLOW)\n\t\t\tpr_cont(\" 3d_low\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\t\tpr_cont(\" acpi\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\n\t\t\tpr_cont(\" uvd_hd2\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\n\t\t\tpr_cont(\" uvd_hd\");\n\t\tif (class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\n\t\t\tpr_cont(\" uvd_sd\");\n\t\tif (class2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\n\t\t\tpr_cont(\" limited_pwr2\");\n\t\tif (class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\n\t\t\tpr_cont(\" ulv\");\n\t\tif (class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\n\t\t\tpr_cont(\" uvd_mvc\");\n\t}\n\tpr_cont(\"\\n\");\n}\n\nvoid amdgpu_dpm_print_cap_info(u32 caps)\n{\n\tprintk(\"\\tcaps:\");\n\tif (caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY)\n\t\tpr_cont(\" single_disp\");\n\tif (caps & ATOM_PPLIB_SUPPORTS_VIDEO_PLAYBACK)\n\t\tpr_cont(\" video\");\n\tif (caps & ATOM_PPLIB_DISALLOW_ON_DC)\n\t\tpr_cont(\" no_dc\");\n\tpr_cont(\"\\n\");\n}\n\nvoid amdgpu_dpm_print_ps_status(struct amdgpu_device *adev,\n\t\t\t\tstruct amdgpu_ps *rps)\n{\n\tprintk(\"\\tstatus:\");\n\tif (rps == adev->pm.dpm.current_ps)\n\t\tpr_cont(\" c\");\n\tif (rps == adev->pm.dpm.requested_ps)\n\t\tpr_cont(\" r\");\n\tif (rps == adev->pm.dpm.boot_ps)\n\t\tpr_cont(\" b\");\n\tpr_cont(\"\\n\");\n}\n\nvoid amdgpu_pm_print_power_states(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tif (adev->powerplay.pp_funcs->print_power_state == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < adev->pm.dpm.num_ps; i++)\n\t\tamdgpu_dpm_print_power_state(adev, &adev->pm.dpm.ps[i]);\n\n}\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE4 pplib4;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE5 pplib5;\n};\n\nint amdgpu_get_platform_caps(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\n\tif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tadev->pm.dpm.platform_caps = le32_to_cpu(power_info->pplib.ulPlatformCaps);\n\tadev->pm.dpm.backbias_response_time = le16_to_cpu(power_info->pplib.usBackbiasTime);\n\tadev->pm.dpm.voltage_response_time = le16_to_cpu(power_info->pplib.usVoltageTime);\n\n\treturn 0;\n}\n\nunion fan_info {\n\tstruct _ATOM_PPLIB_FANTABLE fan;\n\tstruct _ATOM_PPLIB_FANTABLE2 fan2;\n\tstruct _ATOM_PPLIB_FANTABLE3 fan3;\n};\n\nstatic int amdgpu_parse_clk_voltage_dep_table(struct amdgpu_clock_voltage_dependency_table *amdgpu_table,\n\t\t\t\t\t      ATOM_PPLIB_Clock_Voltage_Dependency_Table *atom_table)\n{\n\tu32 size = atom_table->ucNumEntries *\n\t\tsizeof(struct amdgpu_clock_voltage_dependency_entry);\n\tint i;\n\tATOM_PPLIB_Clock_Voltage_Dependency_Record *entry;\n\n\tamdgpu_table->entries = kzalloc(size, GFP_KERNEL);\n\tif (!amdgpu_table->entries)\n\t\treturn -ENOMEM;\n\n\tentry = &atom_table->entries[0];\n\tfor (i = 0; i < atom_table->ucNumEntries; i++) {\n\t\tamdgpu_table->entries[i].clk = le16_to_cpu(entry->usClockLow) |\n\t\t\t(entry->ucClockHigh << 16);\n\t\tamdgpu_table->entries[i].v = le16_to_cpu(entry->usVoltage);\n\t\tentry = (ATOM_PPLIB_Clock_Voltage_Dependency_Record *)\n\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_Clock_Voltage_Dependency_Record));\n\t}\n\tamdgpu_table->count = atom_table->ucNumEntries;\n\n\treturn 0;\n}\n\n \n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2 12\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3 14\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4 16\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5 18\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6 20\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7 22\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V8 24\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V9 26\n\nint amdgpu_parse_extended_power_table(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tunion power_info *power_info;\n\tunion fan_info *fan_info;\n\tATOM_PPLIB_Clock_Voltage_Dependency_Table *dep_table;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tint ret, i;\n\n\tif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\t \n\tif (le16_to_cpu(power_info->pplib.usTableSize) >=\n\t    sizeof(struct _ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tif (power_info->pplib3.usFanTableOffset) {\n\t\t\tfan_info = (union fan_info *)(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t\t      le16_to_cpu(power_info->pplib3.usFanTableOffset));\n\t\t\tadev->pm.dpm.fan.t_hyst = fan_info->fan.ucTHyst;\n\t\t\tadev->pm.dpm.fan.t_min = le16_to_cpu(fan_info->fan.usTMin);\n\t\t\tadev->pm.dpm.fan.t_med = le16_to_cpu(fan_info->fan.usTMed);\n\t\t\tadev->pm.dpm.fan.t_high = le16_to_cpu(fan_info->fan.usTHigh);\n\t\t\tadev->pm.dpm.fan.pwm_min = le16_to_cpu(fan_info->fan.usPWMMin);\n\t\t\tadev->pm.dpm.fan.pwm_med = le16_to_cpu(fan_info->fan.usPWMMed);\n\t\t\tadev->pm.dpm.fan.pwm_high = le16_to_cpu(fan_info->fan.usPWMHigh);\n\t\t\tif (fan_info->fan.ucFanTableFormat >= 2)\n\t\t\t\tadev->pm.dpm.fan.t_max = le16_to_cpu(fan_info->fan2.usTMax);\n\t\t\telse\n\t\t\t\tadev->pm.dpm.fan.t_max = 10900;\n\t\t\tadev->pm.dpm.fan.cycle_delay = 100000;\n\t\t\tif (fan_info->fan.ucFanTableFormat >= 3) {\n\t\t\t\tadev->pm.dpm.fan.control_mode = fan_info->fan3.ucFanControlMode;\n\t\t\t\tadev->pm.dpm.fan.default_max_fan_pwm =\n\t\t\t\t\tle16_to_cpu(fan_info->fan3.usFanPWMMax);\n\t\t\t\tadev->pm.dpm.fan.default_fan_output_sensitivity = 4836;\n\t\t\t\tadev->pm.dpm.fan.fan_output_sensitivity =\n\t\t\t\t\tle16_to_cpu(fan_info->fan3.usFanOutputSensitivity);\n\t\t\t}\n\t\t\tadev->pm.dpm.fan.ucode_fan_control = true;\n\t\t}\n\t}\n\n\t \n\tif (le16_to_cpu(power_info->pplib.usTableSize) >=\n\t    sizeof(struct _ATOM_PPLIB_POWERPLAYTABLE4)) {\n\t\tif (power_info->pplib4.usVddcDependencyOnSCLKOffset) {\n\t\t\tdep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib4.usVddcDependencyOnSCLKOffset));\n\t\t\tret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\n\t\t\t\t\t\t\t\t dep_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (power_info->pplib4.usVddciDependencyOnMCLKOffset) {\n\t\t\tdep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib4.usVddciDependencyOnMCLKOffset));\n\t\t\tret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\n\t\t\t\t\t\t\t\t dep_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (power_info->pplib4.usVddcDependencyOnMCLKOffset) {\n\t\t\tdep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib4.usVddcDependencyOnMCLKOffset));\n\t\t\tret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\n\t\t\t\t\t\t\t\t dep_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (power_info->pplib4.usMvddDependencyOnMCLKOffset) {\n\t\t\tdep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib4.usMvddDependencyOnMCLKOffset));\n\t\t\tret = amdgpu_parse_clk_voltage_dep_table(&adev->pm.dpm.dyn_state.mvdd_dependency_on_mclk,\n\t\t\t\t\t\t\t\t dep_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (power_info->pplib4.usMaxClockVoltageOnDCOffset) {\n\t\t\tATOM_PPLIB_Clock_Voltage_Limit_Table *clk_v =\n\t\t\t\t(ATOM_PPLIB_Clock_Voltage_Limit_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib4.usMaxClockVoltageOnDCOffset));\n\t\t\tif (clk_v->ucNumEntries) {\n\t\t\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk =\n\t\t\t\t\tle16_to_cpu(clk_v->entries[0].usSclkLow) |\n\t\t\t\t\t(clk_v->entries[0].ucSclkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk =\n\t\t\t\t\tle16_to_cpu(clk_v->entries[0].usMclkLow) |\n\t\t\t\t\t(clk_v->entries[0].ucMclkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc =\n\t\t\t\t\tle16_to_cpu(clk_v->entries[0].usVddc);\n\t\t\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddci =\n\t\t\t\t\tle16_to_cpu(clk_v->entries[0].usVddci);\n\t\t\t}\n\t\t}\n\t\tif (power_info->pplib4.usVddcPhaseShedLimitsTableOffset) {\n\t\t\tATOM_PPLIB_PhaseSheddingLimits_Table *psl =\n\t\t\t\t(ATOM_PPLIB_PhaseSheddingLimits_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib4.usVddcPhaseShedLimitsTableOffset));\n\t\t\tATOM_PPLIB_PhaseSheddingLimits_Record *entry;\n\n\t\t\tadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries =\n\t\t\t\tkcalloc(psl->ucNumEntries,\n\t\t\t\t\tsizeof(struct amdgpu_phase_shedding_limits_entry),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.phase_shedding_limits_table.entries)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tentry = &psl->entries[0];\n\t\t\tfor (i = 0; i < psl->ucNumEntries; i++) {\n\t\t\t\tadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].sclk =\n\t\t\t\t\tle16_to_cpu(entry->usSclkLow) | (entry->ucSclkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].mclk =\n\t\t\t\t\tle16_to_cpu(entry->usMclkLow) | (entry->ucMclkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.phase_shedding_limits_table.entries[i].voltage =\n\t\t\t\t\tle16_to_cpu(entry->usVoltage);\n\t\t\t\tentry = (ATOM_PPLIB_PhaseSheddingLimits_Record *)\n\t\t\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_PhaseSheddingLimits_Record));\n\t\t\t}\n\t\t\tadev->pm.dpm.dyn_state.phase_shedding_limits_table.count =\n\t\t\t\tpsl->ucNumEntries;\n\t\t}\n\t}\n\n\t \n\tif (le16_to_cpu(power_info->pplib.usTableSize) >=\n\t    sizeof(struct _ATOM_PPLIB_POWERPLAYTABLE5)) {\n\t\tadev->pm.dpm.tdp_limit = le32_to_cpu(power_info->pplib5.ulTDPLimit);\n\t\tadev->pm.dpm.near_tdp_limit = le32_to_cpu(power_info->pplib5.ulNearTDPLimit);\n\t\tadev->pm.dpm.near_tdp_limit_adjusted = adev->pm.dpm.near_tdp_limit;\n\t\tadev->pm.dpm.tdp_od_limit = le16_to_cpu(power_info->pplib5.usTDPODLimit);\n\t\tif (adev->pm.dpm.tdp_od_limit)\n\t\t\tadev->pm.dpm.power_control = true;\n\t\telse\n\t\t\tadev->pm.dpm.power_control = false;\n\t\tadev->pm.dpm.tdp_adjustment = 0;\n\t\tadev->pm.dpm.sq_ramping_threshold = le32_to_cpu(power_info->pplib5.ulSQRampingThreshold);\n\t\tadev->pm.dpm.cac_leakage = le32_to_cpu(power_info->pplib5.ulCACLeakage);\n\t\tadev->pm.dpm.load_line_slope = le16_to_cpu(power_info->pplib5.usLoadLineSlope);\n\t\tif (power_info->pplib5.usCACLeakageTableOffset) {\n\t\t\tATOM_PPLIB_CAC_Leakage_Table *cac_table =\n\t\t\t\t(ATOM_PPLIB_CAC_Leakage_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(power_info->pplib5.usCACLeakageTableOffset));\n\t\t\tATOM_PPLIB_CAC_Leakage_Record *entry;\n\t\t\tu32 size = cac_table->ucNumEntries * sizeof(struct amdgpu_cac_leakage_table);\n\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.cac_leakage_table.entries)\n\t\t\t\treturn -ENOMEM;\n\t\t\tentry = &cac_table->entries[0];\n\t\t\tfor (i = 0; i < cac_table->ucNumEntries; i++) {\n\t\t\t\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_EVV) {\n\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc1 =\n\t\t\t\t\t\tle16_to_cpu(entry->usVddc1);\n\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc2 =\n\t\t\t\t\t\tle16_to_cpu(entry->usVddc2);\n\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc3 =\n\t\t\t\t\t\tle16_to_cpu(entry->usVddc3);\n\t\t\t\t} else {\n\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].vddc =\n\t\t\t\t\t\tle16_to_cpu(entry->usVddc);\n\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[i].leakage =\n\t\t\t\t\t\tle32_to_cpu(entry->ulLeakageValue);\n\t\t\t\t}\n\t\t\t\tentry = (ATOM_PPLIB_CAC_Leakage_Record *)\n\t\t\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_CAC_Leakage_Record));\n\t\t\t}\n\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.count = cac_table->ucNumEntries;\n\t\t}\n\t}\n\n\t \n\tif (le16_to_cpu(power_info->pplib.usTableSize) >=\n\t    sizeof(struct _ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tATOM_PPLIB_EXTENDEDHEADER *ext_hdr = (ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t le16_to_cpu(power_info->pplib3.usExtendendedHeaderOffset));\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2) &&\n\t\t\text_hdr->usVCETableOffset) {\n\t\t\tVCEClockInfoArray *array = (VCEClockInfoArray *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usVCETableOffset) + 1);\n\t\t\tATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *limits =\n\t\t\t\t(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usVCETableOffset) + 1 +\n\t\t\t\t 1 + array->ucNumEntries * sizeof(VCEClockInfo));\n\t\t\tATOM_PPLIB_VCE_State_Table *states =\n\t\t\t\t(ATOM_PPLIB_VCE_State_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usVCETableOffset) + 1 +\n\t\t\t\t 1 + (array->ucNumEntries * sizeof (VCEClockInfo)) +\n\t\t\t\t 1 + (limits->numEntries * sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record)));\n\t\t\tATOM_PPLIB_VCE_Clock_Voltage_Limit_Record *entry;\n\t\t\tATOM_PPLIB_VCE_State_Record *state_entry;\n\t\t\tVCEClockInfo *vce_clk;\n\t\t\tu32 size = limits->numEntries *\n\t\t\t\tsizeof(struct amdgpu_vce_clock_voltage_dependency_entry);\n\t\t\tadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries =\n\t\t\t\tkzalloc(size, GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries)\n\t\t\t\treturn -ENOMEM;\n\t\t\tadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count =\n\t\t\t\tlimits->numEntries;\n\t\t\tentry = &limits->entries[0];\n\t\t\tstate_entry = &states->entries[0];\n\t\t\tfor (i = 0; i < limits->numEntries; i++) {\n\t\t\t\tvce_clk = (VCEClockInfo *)\n\t\t\t\t\t((u8 *)&array->entries[0] +\n\t\t\t\t\t (entry->ucVCEClockInfoIndex * sizeof(VCEClockInfo)));\n\t\t\t\tadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].evclk =\n\t\t\t\t\tle16_to_cpu(vce_clk->usEVClkLow) | (vce_clk->ucEVClkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].ecclk =\n\t\t\t\t\tle16_to_cpu(vce_clk->usECClkLow) | (vce_clk->ucECClkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries[i].v =\n\t\t\t\t\tle16_to_cpu(entry->usVoltage);\n\t\t\t\tentry = (ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record *)\n\t\t\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record));\n\t\t\t}\n\t\t\tadev->pm.dpm.num_of_vce_states =\n\t\t\t\t\tstates->numEntries > AMD_MAX_VCE_LEVELS ?\n\t\t\t\t\tAMD_MAX_VCE_LEVELS : states->numEntries;\n\t\t\tfor (i = 0; i < adev->pm.dpm.num_of_vce_states; i++) {\n\t\t\t\tvce_clk = (VCEClockInfo *)\n\t\t\t\t\t((u8 *)&array->entries[0] +\n\t\t\t\t\t (state_entry->ucVCEClockInfoIndex * sizeof(VCEClockInfo)));\n\t\t\t\tadev->pm.dpm.vce_states[i].evclk =\n\t\t\t\t\tle16_to_cpu(vce_clk->usEVClkLow) | (vce_clk->ucEVClkHigh << 16);\n\t\t\t\tadev->pm.dpm.vce_states[i].ecclk =\n\t\t\t\t\tle16_to_cpu(vce_clk->usECClkLow) | (vce_clk->ucECClkHigh << 16);\n\t\t\t\tadev->pm.dpm.vce_states[i].clk_idx =\n\t\t\t\t\tstate_entry->ucClockInfoIndex & 0x3f;\n\t\t\t\tadev->pm.dpm.vce_states[i].pstate =\n\t\t\t\t\t(state_entry->ucClockInfoIndex & 0xc0) >> 6;\n\t\t\t\tstate_entry = (ATOM_PPLIB_VCE_State_Record *)\n\t\t\t\t\t((u8 *)state_entry + sizeof(ATOM_PPLIB_VCE_State_Record));\n\t\t\t}\n\t\t}\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3) &&\n\t\t\text_hdr->usUVDTableOffset) {\n\t\t\tUVDClockInfoArray *array = (UVDClockInfoArray *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usUVDTableOffset) + 1);\n\t\t\tATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *limits =\n\t\t\t\t(ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usUVDTableOffset) + 1 +\n\t\t\t\t 1 + (array->ucNumEntries * sizeof (UVDClockInfo)));\n\t\t\tATOM_PPLIB_UVD_Clock_Voltage_Limit_Record *entry;\n\t\t\tu32 size = limits->numEntries *\n\t\t\t\tsizeof(struct amdgpu_uvd_clock_voltage_dependency_entry);\n\t\t\tadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries =\n\t\t\t\tkzalloc(size, GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries)\n\t\t\t\treturn -ENOMEM;\n\t\t\tadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count =\n\t\t\t\tlimits->numEntries;\n\t\t\tentry = &limits->entries[0];\n\t\t\tfor (i = 0; i < limits->numEntries; i++) {\n\t\t\t\tUVDClockInfo *uvd_clk = (UVDClockInfo *)\n\t\t\t\t\t((u8 *)&array->entries[0] +\n\t\t\t\t\t (entry->ucUVDClockInfoIndex * sizeof(UVDClockInfo)));\n\t\t\t\tadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].vclk =\n\t\t\t\t\tle16_to_cpu(uvd_clk->usVClkLow) | (uvd_clk->ucVClkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].dclk =\n\t\t\t\t\tle16_to_cpu(uvd_clk->usDClkLow) | (uvd_clk->ucDClkHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries[i].v =\n\t\t\t\t\tle16_to_cpu(entry->usVoltage);\n\t\t\t\tentry = (ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record *)\n\t\t\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_UVD_Clock_Voltage_Limit_Record));\n\t\t\t}\n\t\t}\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4) &&\n\t\t\text_hdr->usSAMUTableOffset) {\n\t\t\tATOM_PPLIB_SAMClk_Voltage_Limit_Table *limits =\n\t\t\t\t(ATOM_PPLIB_SAMClk_Voltage_Limit_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usSAMUTableOffset) + 1);\n\t\t\tATOM_PPLIB_SAMClk_Voltage_Limit_Record *entry;\n\t\t\tu32 size = limits->numEntries *\n\t\t\t\tsizeof(struct amdgpu_clock_voltage_dependency_entry);\n\t\t\tadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries =\n\t\t\t\tkzalloc(size, GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries)\n\t\t\t\treturn -ENOMEM;\n\t\t\tadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.count =\n\t\t\t\tlimits->numEntries;\n\t\t\tentry = &limits->entries[0];\n\t\t\tfor (i = 0; i < limits->numEntries; i++) {\n\t\t\t\tadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[i].clk =\n\t\t\t\t\tle16_to_cpu(entry->usSAMClockLow) | (entry->ucSAMClockHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries[i].v =\n\t\t\t\t\tle16_to_cpu(entry->usVoltage);\n\t\t\t\tentry = (ATOM_PPLIB_SAMClk_Voltage_Limit_Record *)\n\t\t\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_SAMClk_Voltage_Limit_Record));\n\t\t\t}\n\t\t}\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5) &&\n\t\t    ext_hdr->usPPMTableOffset) {\n\t\t\tATOM_PPLIB_PPM_Table *ppm = (ATOM_PPLIB_PPM_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usPPMTableOffset));\n\t\t\tadev->pm.dpm.dyn_state.ppm_table =\n\t\t\t\tkzalloc(sizeof(struct amdgpu_ppm_table), GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.ppm_table)\n\t\t\t\treturn -ENOMEM;\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->ppm_design = ppm->ucPpmDesign;\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->cpu_core_number =\n\t\t\t\tle16_to_cpu(ppm->usCpuCoreNumber);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->platform_tdp =\n\t\t\t\tle32_to_cpu(ppm->ulPlatformTDP);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->small_ac_platform_tdp =\n\t\t\t\tle32_to_cpu(ppm->ulSmallACPlatformTDP);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->platform_tdc =\n\t\t\t\tle32_to_cpu(ppm->ulPlatformTDC);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->small_ac_platform_tdc =\n\t\t\t\tle32_to_cpu(ppm->ulSmallACPlatformTDC);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->apu_tdp =\n\t\t\t\tle32_to_cpu(ppm->ulApuTDP);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->dgpu_tdp =\n\t\t\t\tle32_to_cpu(ppm->ulDGpuTDP);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->dgpu_ulv_power =\n\t\t\t\tle32_to_cpu(ppm->ulDGpuUlvPower);\n\t\t\tadev->pm.dpm.dyn_state.ppm_table->tj_max =\n\t\t\t\tle32_to_cpu(ppm->ulTjmax);\n\t\t}\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6) &&\n\t\t\text_hdr->usACPTableOffset) {\n\t\t\tATOM_PPLIB_ACPClk_Voltage_Limit_Table *limits =\n\t\t\t\t(ATOM_PPLIB_ACPClk_Voltage_Limit_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usACPTableOffset) + 1);\n\t\t\tATOM_PPLIB_ACPClk_Voltage_Limit_Record *entry;\n\t\t\tu32 size = limits->numEntries *\n\t\t\t\tsizeof(struct amdgpu_clock_voltage_dependency_entry);\n\t\t\tadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries =\n\t\t\t\tkzalloc(size, GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries)\n\t\t\t\treturn -ENOMEM;\n\t\t\tadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.count =\n\t\t\t\tlimits->numEntries;\n\t\t\tentry = &limits->entries[0];\n\t\t\tfor (i = 0; i < limits->numEntries; i++) {\n\t\t\t\tadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[i].clk =\n\t\t\t\t\tle16_to_cpu(entry->usACPClockLow) | (entry->ucACPClockHigh << 16);\n\t\t\t\tadev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries[i].v =\n\t\t\t\t\tle16_to_cpu(entry->usVoltage);\n\t\t\t\tentry = (ATOM_PPLIB_ACPClk_Voltage_Limit_Record *)\n\t\t\t\t\t((u8 *)entry + sizeof(ATOM_PPLIB_ACPClk_Voltage_Limit_Record));\n\t\t\t}\n\t\t}\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7) &&\n\t\t\text_hdr->usPowerTuneTableOffset) {\n\t\t\tu8 rev = *(u8 *)(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(ext_hdr->usPowerTuneTableOffset));\n\t\t\tATOM_PowerTune_Table *pt;\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table =\n\t\t\t\tkzalloc(sizeof(struct amdgpu_cac_tdp_table), GFP_KERNEL);\n\t\t\tif (!adev->pm.dpm.dyn_state.cac_tdp_table)\n\t\t\t\treturn -ENOMEM;\n\t\t\tif (rev > 0) {\n\t\t\t\tATOM_PPLIB_POWERTUNE_Table_V1 *ppt = (ATOM_PPLIB_POWERTUNE_Table_V1 *)\n\t\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(ext_hdr->usPowerTuneTableOffset));\n\t\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->maximum_power_delivery_limit =\n\t\t\t\t\tppt->usMaximumPowerDeliveryLimit;\n\t\t\t\tpt = &ppt->power_tune_table;\n\t\t\t} else {\n\t\t\t\tATOM_PPLIB_POWERTUNE_Table *ppt = (ATOM_PPLIB_POWERTUNE_Table *)\n\t\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t\t le16_to_cpu(ext_hdr->usPowerTuneTableOffset));\n\t\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->maximum_power_delivery_limit = 255;\n\t\t\t\tpt = &ppt->power_tune_table;\n\t\t\t}\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->tdp = le16_to_cpu(pt->usTDP);\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->configurable_tdp =\n\t\t\t\tle16_to_cpu(pt->usConfigurableTDP);\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->tdc = le16_to_cpu(pt->usTDC);\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->battery_power_limit =\n\t\t\t\tle16_to_cpu(pt->usBatteryPowerLimit);\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->small_power_limit =\n\t\t\t\tle16_to_cpu(pt->usSmallPowerLimit);\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->low_cac_leakage =\n\t\t\t\tle16_to_cpu(pt->usLowCACLeakage);\n\t\t\tadev->pm.dpm.dyn_state.cac_tdp_table->high_cac_leakage =\n\t\t\t\tle16_to_cpu(pt->usHighCACLeakage);\n\t\t}\n\t\tif ((le16_to_cpu(ext_hdr->usSize) >= SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V8) &&\n\t\t\t\text_hdr->usSclkVddgfxTableOffset) {\n\t\t\tdep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(mode_info->atom_context->bios + data_offset +\n\t\t\t\t le16_to_cpu(ext_hdr->usSclkVddgfxTableOffset));\n\t\t\tret = amdgpu_parse_clk_voltage_dep_table(\n\t\t\t\t\t&adev->pm.dpm.dyn_state.vddgfx_dependency_on_sclk,\n\t\t\t\t\tdep_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid amdgpu_free_extended_power_table(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_dpm_dynamic_state *dyn_state = &adev->pm.dpm.dyn_state;\n\n\tkfree(dyn_state->vddc_dependency_on_sclk.entries);\n\tkfree(dyn_state->vddci_dependency_on_mclk.entries);\n\tkfree(dyn_state->vddc_dependency_on_mclk.entries);\n\tkfree(dyn_state->mvdd_dependency_on_mclk.entries);\n\tkfree(dyn_state->cac_leakage_table.entries);\n\tkfree(dyn_state->phase_shedding_limits_table.entries);\n\tkfree(dyn_state->ppm_table);\n\tkfree(dyn_state->cac_tdp_table);\n\tkfree(dyn_state->vce_clock_voltage_dependency_table.entries);\n\tkfree(dyn_state->uvd_clock_voltage_dependency_table.entries);\n\tkfree(dyn_state->samu_clock_voltage_dependency_table.entries);\n\tkfree(dyn_state->acp_clock_voltage_dependency_table.entries);\n\tkfree(dyn_state->vddgfx_dependency_on_sclk.entries);\n}\n\nstatic const char *pp_lib_thermal_controller_names[] = {\n\t\"NONE\",\n\t\"lm63\",\n\t\"adm1032\",\n\t\"adm1030\",\n\t\"max6649\",\n\t\"lm64\",\n\t\"f75375\",\n\t\"RV6xx\",\n\t\"RV770\",\n\t\"adt7473\",\n\t\"NONE\",\n\t\"External GPIO\",\n\t\"Evergreen\",\n\t\"emc2103\",\n\t\"Sumo\",\n\t\"Northern Islands\",\n\t\"Southern Islands\",\n\t\"lm96163\",\n\t\"Sea Islands\",\n\t\"Kaveri/Kabini\",\n};\n\nvoid amdgpu_add_thermal_controller(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tATOM_PPLIB_POWERPLAYTABLE *power_table;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tATOM_PPLIB_THERMALCONTROLLER *controller;\n\tstruct amdgpu_i2c_bus_rec i2c_bus;\n\tu16 data_offset;\n\tu8 frev, crev;\n\n\tif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn;\n\tpower_table = (ATOM_PPLIB_POWERPLAYTABLE *)\n\t\t(mode_info->atom_context->bios + data_offset);\n\tcontroller = &power_table->sThermalController;\n\n\t \n\tif (controller->ucType > 0) {\n\t\tif (controller->ucFanParameters & ATOM_PP_FANPARAMETERS_NOFAN)\n\t\t\tadev->pm.no_fan = true;\n\t\tadev->pm.fan_pulses_per_revolution =\n\t\t\tcontroller->ucFanParameters & ATOM_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\t\tif (adev->pm.fan_pulses_per_revolution) {\n\t\t\tadev->pm.fan_min_rpm = controller->ucFanMinRPM;\n\t\t\tadev->pm.fan_max_rpm = controller->ucFanMaxRPM;\n\t\t}\n\t\tif (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV6xx) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_RV6XX;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_RV770) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_RV770;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_EVERGREEN) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_EVERGREEN;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SUMO) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_SUMO;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_NISLANDS) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_NI;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_SISLANDS) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_SI;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_CISLANDS) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_CI;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_KAVERI) {\n\t\t\tDRM_INFO(\"Internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_KV;\n\t\t} else if (controller->ucType == ATOM_PP_THERMALCONTROLLER_EXTERNAL_GPIO) {\n\t\t\tDRM_INFO(\"External GPIO thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_EXTERNAL_GPIO;\n\t\t} else if (controller->ucType ==\n\t\t\t   ATOM_PP_THERMALCONTROLLER_ADT7473_WITH_INTERNAL) {\n\t\t\tDRM_INFO(\"ADT7473 with internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_ADT7473_WITH_INTERNAL;\n\t\t} else if (controller->ucType ==\n\t\t\t   ATOM_PP_THERMALCONTROLLER_EMC2103_WITH_INTERNAL) {\n\t\t\tDRM_INFO(\"EMC2103 with internal thermal controller %s fan control\\n\",\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_EMC2103_WITH_INTERNAL;\n\t\t} else if (controller->ucType < ARRAY_SIZE(pp_lib_thermal_controller_names)) {\n\t\t\tDRM_INFO(\"Possible %s thermal controller at 0x%02x %s fan control\\n\",\n\t\t\t\t pp_lib_thermal_controller_names[controller->ucType],\n\t\t\t\t controller->ucI2cAddress >> 1,\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t\tadev->pm.int_thermal_type = THERMAL_TYPE_EXTERNAL;\n\t\t\ti2c_bus = amdgpu_atombios_lookup_i2c_gpio(adev, controller->ucI2cLine);\n\t\t\tadev->pm.i2c_bus = amdgpu_i2c_lookup(adev, &i2c_bus);\n\t\t\tif (adev->pm.i2c_bus) {\n\t\t\t\tstruct i2c_board_info info = { };\n\t\t\t\tconst char *name = pp_lib_thermal_controller_names[controller->ucType];\n\t\t\t\tinfo.addr = controller->ucI2cAddress >> 1;\n\t\t\t\tstrscpy(info.type, name, sizeof(info.type));\n\t\t\t\ti2c_new_client_device(&adev->pm.i2c_bus->adapter, &info);\n\t\t\t}\n\t\t} else {\n\t\t\tDRM_INFO(\"Unknown thermal controller type %d at 0x%02x %s fan control\\n\",\n\t\t\t\t controller->ucType,\n\t\t\t\t controller->ucI2cAddress >> 1,\n\t\t\t\t (controller->ucFanParameters &\n\t\t\t\t  ATOM_PP_FANPARAMETERS_NOFAN) ? \"without\" : \"with\");\n\t\t}\n\t}\n}\n\nstruct amd_vce_state* amdgpu_get_vce_clock_state(void *handle, u32 idx)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (idx < adev->pm.dpm.num_of_vce_states)\n\t\treturn &adev->pm.dpm.vce_states[idx];\n\n\treturn NULL;\n}\n\nstatic struct amdgpu_ps *amdgpu_dpm_pick_power_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t     enum amd_pm_state_type dpm_state)\n{\n\tint i;\n\tstruct amdgpu_ps *ps;\n\tu32 ui_class;\n\tbool single_display = (adev->pm.dpm.new_active_crtc_count < 2) ?\n\t\ttrue : false;\n\n\t \n\tif (single_display && adev->powerplay.pp_funcs->vblank_too_short) {\n\t\tif (amdgpu_dpm_vblank_too_short(adev))\n\t\t\tsingle_display = false;\n\t}\n\n\t \n\tif (dpm_state == POWER_STATE_TYPE_PERFORMANCE)\n\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_3DPERF;\n\t \n\tif (dpm_state == POWER_STATE_TYPE_BALANCED)\n\t\tdpm_state = POWER_STATE_TYPE_PERFORMANCE;\n\nrestart_search:\n\t \n\tfor (i = 0; i < adev->pm.dpm.num_ps; i++) {\n\t\tps = &adev->pm.dpm.ps[i];\n\t\tui_class = ps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK;\n\t\tswitch (dpm_state) {\n\t\t \n\t\tcase POWER_STATE_TYPE_BATTERY:\n\t\t\tif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BATTERY) {\n\t\t\t\tif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\n\t\t\t\t\tif (single_display)\n\t\t\t\t\t\treturn ps;\n\t\t\t\t} else\n\t\t\t\t\treturn ps;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_BALANCED:\n\t\t\tif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_BALANCED) {\n\t\t\t\tif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\n\t\t\t\t\tif (single_display)\n\t\t\t\t\t\treturn ps;\n\t\t\t\t} else\n\t\t\t\t\treturn ps;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_PERFORMANCE:\n\t\t\tif (ui_class == ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\n\t\t\t\tif (ps->caps & ATOM_PPLIB_SINGLE_DISPLAY_ONLY) {\n\t\t\t\t\tif (single_display)\n\t\t\t\t\t\treturn ps;\n\t\t\t\t} else\n\t\t\t\t\treturn ps;\n\t\t\t}\n\t\t\tbreak;\n\t\t \n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD:\n\t\t\tif (adev->pm.dpm.uvd_ps)\n\t\t\t\treturn adev->pm.dpm.uvd_ps;\n\t\t\telse\n\t\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_SD:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\n\t\t\tif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_BOOT:\n\t\t\treturn adev->pm.dpm.boot_ps;\n\t\tcase POWER_STATE_TYPE_INTERNAL_THERMAL:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_ACPI:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_ULV:\n\t\t\tif (ps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tcase POWER_STATE_TYPE_INTERNAL_3DPERF:\n\t\t\tif (ps->class & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\n\t\t\t\treturn ps;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tswitch (dpm_state) {\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_SD:\n\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_UVD_HD;\n\t\tgoto restart_search;\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD:\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_HD2:\n\tcase POWER_STATE_TYPE_INTERNAL_UVD_MVC:\n\t\tif (adev->pm.dpm.uvd_ps) {\n\t\t\treturn adev->pm.dpm.uvd_ps;\n\t\t} else {\n\t\t\tdpm_state = POWER_STATE_TYPE_PERFORMANCE;\n\t\t\tgoto restart_search;\n\t\t}\n\tcase POWER_STATE_TYPE_INTERNAL_THERMAL:\n\t\tdpm_state = POWER_STATE_TYPE_INTERNAL_ACPI;\n\t\tgoto restart_search;\n\tcase POWER_STATE_TYPE_INTERNAL_ACPI:\n\t\tdpm_state = POWER_STATE_TYPE_BATTERY;\n\t\tgoto restart_search;\n\tcase POWER_STATE_TYPE_BATTERY:\n\tcase POWER_STATE_TYPE_BALANCED:\n\tcase POWER_STATE_TYPE_INTERNAL_3DPERF:\n\t\tdpm_state = POWER_STATE_TYPE_PERFORMANCE;\n\t\tgoto restart_search;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic int amdgpu_dpm_change_power_state_locked(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tstruct amdgpu_ps *ps;\n\tenum amd_pm_state_type dpm_state;\n\tint ret;\n\tbool equal = false;\n\n\t \n\tif (!adev->pm.dpm_enabled)\n\t\treturn 0;\n\n\tif (adev->pm.dpm.user_state != adev->pm.dpm.state) {\n\t\t \n\t\tif ((!adev->pm.dpm.thermal_active) &&\n\t\t    (!adev->pm.dpm.uvd_active))\n\t\t\tadev->pm.dpm.state = adev->pm.dpm.user_state;\n\t}\n\tdpm_state = adev->pm.dpm.state;\n\n\tps = amdgpu_dpm_pick_power_state(adev, dpm_state);\n\tif (ps)\n\t\tadev->pm.dpm.requested_ps = ps;\n\telse\n\t\treturn -EINVAL;\n\n\tif (amdgpu_dpm == 1 && pp_funcs->print_power_state) {\n\t\tprintk(\"switching from power state:\\n\");\n\t\tamdgpu_dpm_print_power_state(adev, adev->pm.dpm.current_ps);\n\t\tprintk(\"switching to power state:\\n\");\n\t\tamdgpu_dpm_print_power_state(adev, adev->pm.dpm.requested_ps);\n\t}\n\n\t \n\tps->vce_active = adev->pm.dpm.vce_active;\n\tif (pp_funcs->display_configuration_changed)\n\t\tamdgpu_dpm_display_configuration_changed(adev);\n\n\tret = amdgpu_dpm_pre_set_power_state(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pp_funcs->check_state_equal) {\n\t\tif (0 != amdgpu_dpm_check_state_equal(adev, adev->pm.dpm.current_ps, adev->pm.dpm.requested_ps, &equal))\n\t\t\tequal = false;\n\t}\n\n\tif (equal)\n\t\treturn 0;\n\n\tif (pp_funcs->set_power_state)\n\t\tpp_funcs->set_power_state(adev->powerplay.pp_handle);\n\n\tamdgpu_dpm_post_set_power_state(adev);\n\n\tadev->pm.dpm.current_active_crtcs = adev->pm.dpm.new_active_crtcs;\n\tadev->pm.dpm.current_active_crtc_count = adev->pm.dpm.new_active_crtc_count;\n\n\tif (pp_funcs->force_performance_level) {\n\t\tif (adev->pm.dpm.thermal_active) {\n\t\t\tenum amd_dpm_forced_level level = adev->pm.dpm.forced_level;\n\t\t\t \n\t\t\tpp_funcs->force_performance_level(adev, AMD_DPM_FORCED_LEVEL_LOW);\n\t\t\t \n\t\t\tadev->pm.dpm.forced_level = level;\n\t\t} else {\n\t\t\t \n\t\t\tpp_funcs->force_performance_level(adev, adev->pm.dpm.forced_level);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid amdgpu_legacy_dpm_compute_clocks(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tamdgpu_dpm_get_active_displays(adev);\n\n\tamdgpu_dpm_change_power_state_locked(adev);\n}\n\nvoid amdgpu_dpm_thermal_work_handler(struct work_struct *work)\n{\n\tstruct amdgpu_device *adev =\n\t\tcontainer_of(work, struct amdgpu_device,\n\t\t\t     pm.dpm.thermal.work);\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\t \n\tenum amd_pm_state_type dpm_state = POWER_STATE_TYPE_INTERNAL_THERMAL;\n\tint temp, size = sizeof(temp);\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn;\n\n\tif (!pp_funcs->read_sensor(adev->powerplay.pp_handle,\n\t\t\t\t   AMDGPU_PP_SENSOR_GPU_TEMP,\n\t\t\t\t   (void *)&temp,\n\t\t\t\t   &size)) {\n\t\tif (temp < adev->pm.dpm.thermal.min_temp)\n\t\t\t \n\t\t\tdpm_state = adev->pm.dpm.user_state;\n\t} else {\n\t\tif (adev->pm.dpm.thermal.high_to_low)\n\t\t\t \n\t\t\tdpm_state = adev->pm.dpm.user_state;\n\t}\n\n\tif (dpm_state == POWER_STATE_TYPE_INTERNAL_THERMAL)\n\t\tadev->pm.dpm.thermal_active = true;\n\telse\n\t\tadev->pm.dpm.thermal_active = false;\n\n\tadev->pm.dpm.state = dpm_state;\n\n\tamdgpu_legacy_dpm_compute_clocks(adev->powerplay.pp_handle);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}