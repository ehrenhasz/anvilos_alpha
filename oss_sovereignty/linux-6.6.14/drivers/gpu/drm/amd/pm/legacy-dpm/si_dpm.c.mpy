{
  "module_name": "si_dpm.c",
  "hash_id": "ea8b9f5cd79d218ac883f7925e2abb1b02da6e107ae57a9b1cefed9301f4e548",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"amdgpu.h\"\n#include \"amdgpu_pm.h\"\n#include \"amdgpu_dpm.h\"\n#include \"amdgpu_atombios.h\"\n#include \"amdgpu_dpm_internal.h\"\n#include \"amd_pcie.h\"\n#include \"sid.h\"\n#include \"r600_dpm.h\"\n#include \"si_dpm.h\"\n#include \"atom.h\"\n#include \"../include/pptable.h\"\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/firmware.h>\n#include <legacy_dpm.h>\n\n#define MC_CG_ARB_FREQ_F0           0x0a\n#define MC_CG_ARB_FREQ_F1           0x0b\n#define MC_CG_ARB_FREQ_F2           0x0c\n#define MC_CG_ARB_FREQ_F3           0x0d\n\n#define SMC_RAM_END                 0x20000\n\n#define SCLK_MIN_DEEPSLEEP_FREQ     1350\n\n\n \n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2 12\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3 14\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4 16\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5 18\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6 20\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7 22\n\n#define BIOS_SCRATCH_4                                    0x5cd\n\nMODULE_FIRMWARE(\"amdgpu/tahiti_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/pitcairn_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/pitcairn_k_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/verde_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/verde_k_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/oland_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/oland_k_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/hainan_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/hainan_k_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/banks_k_2_smc.bin\");\n\nstatic const struct amd_pm_funcs si_dpm_funcs;\n\nunion power_info {\n\tstruct _ATOM_POWERPLAY_INFO info;\n\tstruct _ATOM_POWERPLAY_INFO_V2 info_2;\n\tstruct _ATOM_POWERPLAY_INFO_V3 info_3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE pplib;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE2 pplib2;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE3 pplib3;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE4 pplib4;\n\tstruct _ATOM_PPLIB_POWERPLAYTABLE5 pplib5;\n};\n\nunion fan_info {\n\tstruct _ATOM_PPLIB_FANTABLE fan;\n\tstruct _ATOM_PPLIB_FANTABLE2 fan2;\n\tstruct _ATOM_PPLIB_FANTABLE3 fan3;\n};\n\nunion pplib_clock_info {\n\tstruct _ATOM_PPLIB_R600_CLOCK_INFO r600;\n\tstruct _ATOM_PPLIB_RS780_CLOCK_INFO rs780;\n\tstruct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO evergreen;\n\tstruct _ATOM_PPLIB_SUMO_CLOCK_INFO sumo;\n\tstruct _ATOM_PPLIB_SI_CLOCK_INFO si;\n};\n\nenum si_dpm_auto_throttle_src {\n\tSI_DPM_AUTO_THROTTLE_SRC_THERMAL,\n\tSI_DPM_AUTO_THROTTLE_SRC_EXTERNAL\n};\n\nenum si_dpm_event_src {\n\tSI_DPM_EVENT_SRC_ANALOG = 0,\n\tSI_DPM_EVENT_SRC_EXTERNAL = 1,\n\tSI_DPM_EVENT_SRC_DIGITAL = 2,\n\tSI_DPM_EVENT_SRC_ANALOG_OR_EXTERNAL = 3,\n\tSI_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL = 4\n};\n\nstatic const u32 r600_utc[R600_PM_NUMBER_OF_TC] =\n{\n\tR600_UTC_DFLT_00,\n\tR600_UTC_DFLT_01,\n\tR600_UTC_DFLT_02,\n\tR600_UTC_DFLT_03,\n\tR600_UTC_DFLT_04,\n\tR600_UTC_DFLT_05,\n\tR600_UTC_DFLT_06,\n\tR600_UTC_DFLT_07,\n\tR600_UTC_DFLT_08,\n\tR600_UTC_DFLT_09,\n\tR600_UTC_DFLT_10,\n\tR600_UTC_DFLT_11,\n\tR600_UTC_DFLT_12,\n\tR600_UTC_DFLT_13,\n\tR600_UTC_DFLT_14,\n};\n\nstatic const u32 r600_dtc[R600_PM_NUMBER_OF_TC] =\n{\n\tR600_DTC_DFLT_00,\n\tR600_DTC_DFLT_01,\n\tR600_DTC_DFLT_02,\n\tR600_DTC_DFLT_03,\n\tR600_DTC_DFLT_04,\n\tR600_DTC_DFLT_05,\n\tR600_DTC_DFLT_06,\n\tR600_DTC_DFLT_07,\n\tR600_DTC_DFLT_08,\n\tR600_DTC_DFLT_09,\n\tR600_DTC_DFLT_10,\n\tR600_DTC_DFLT_11,\n\tR600_DTC_DFLT_12,\n\tR600_DTC_DFLT_13,\n\tR600_DTC_DFLT_14,\n};\n\nstatic const struct si_cac_config_reg cac_weights_tahiti[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0xc, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x101, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0xc, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x8fc, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x95, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x34e, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x1a1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0xda, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x46, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x208, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0xe7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x948, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x167, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x31, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x18e, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg lcac_tahiti[] =\n{\n\t{ 0x143, 0x0001fffe, 1, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x146, 0x0001fffe, 1, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x146, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x149, 0x0001fffe, 1, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x149, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14c, 0x0001fffe, 1, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x98, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x98, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9b, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9e, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x101, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x101, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x107, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x107, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10a, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10d, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8f, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x92, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x92, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x95, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x95, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x152, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x152, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x155, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x155, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x158, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x158, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x113, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x113, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x116, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x116, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x119, 0x0001fffe, 1, 0x8, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x119, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x122, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x122, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x125, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x125, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x128, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x128, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12b, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n\n};\n\nstatic const struct si_cac_config_reg cac_override_tahiti[] =\n{\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_powertune_data powertune_data_tahiti =\n{\n\t((1 << 16) | 27027),\n\t6,\n\t0,\n\t4,\n\t95,\n\t{\n\t\t0UL,\n\t\t0UL,\n\t\t4521550UL,\n\t\t309631529UL,\n\t\t-1270850L,\n\t\t4513710L,\n\t\t40\n\t},\n\t595000000UL,\n\t12,\n\t{\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0\n\t},\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_tahiti =\n{\n\t{ 1159409, 0, 0, 0, 0 },\n\t{ 777, 0, 0, 0, 0 },\n\t2,\n\t54000,\n\t127000,\n\t25,\n\t2,\n\t10,\n\t13,\n\t{ 27, 31, 35, 39, 43, 47, 54, 61, 67, 74, 81, 88, 95, 0, 0, 0 },\n\t{ 240888759, 221057860, 235370597, 162287531, 158510299, 131423027, 116673180, 103067515, 87941937, 76209048, 68209175, 64090048, 58301890, 0, 0, 0 },\n\t{ 12024, 11189, 11451, 8411, 7939, 6666, 5681, 4905, 4241, 3720, 3354, 3122, 2890, 0, 0, 0 },\n\t85,\n\tfalse\n};\n\nstatic const struct si_dte_data dte_data_tahiti_pro =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t45000,\n\t100,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0x7D0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_new_zealand =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0 },\n\t{ 0x29B, 0x3E9, 0x537, 0x7D2, 0 },\n\t0x5,\n\t0xAFC8,\n\t0x69,\n\t0x32,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x82, 0xA0, 0xB4, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0xDAC, 0x1388, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685, 0x685 },\n\t85,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_aruba_pro =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t45000,\n\t100,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0x1000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_malta =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t45000,\n\t100,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_cac_config_reg cac_weights_pitcairn[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x8a, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x24d, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x19, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x76, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0xc11, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x7f3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x403, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x367, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x4c9, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x45d, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x36d, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x534, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x5da, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x880, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0x201, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x9f, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x1f, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5de, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x7b, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x13, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0xf9, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x66, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x13, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x186, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg lcac_pitcairn[] =\n{\n\t{ 0x98, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x98, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9b, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x107, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x107, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x113, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x113, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x152, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x152, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8f, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x146, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x146, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9e, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10a, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x116, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x116, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x155, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x155, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x92, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x92, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x149, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x149, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x101, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x101, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10d, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x119, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x119, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x158, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x158, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x95, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x95, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x122, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x122, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x125, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x125, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x128, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x128, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12b, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_override_pitcairn[] =\n{\n    { 0xFFFFFFFF }\n};\n\nstatic const struct si_powertune_data powertune_data_pitcairn =\n{\n\t((1 << 16) | 27027),\n\t5,\n\t0,\n\t6,\n\t100,\n\t{\n\t\t51600000UL,\n\t\t1800000UL,\n\t\t7194395UL,\n\t\t309631529UL,\n\t\t-1270850L,\n\t\t4513710L,\n\t\t100\n\t},\n\t117830498UL,\n\t12,\n\t{\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0\n\t},\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_pitcairn =\n{\n\t{ 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0 },\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t0,\n\tfalse\n};\n\nstatic const struct si_dte_data dte_data_curacao_xt =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t45000,\n\t100,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0x1D17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_curacao_pro =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t45000,\n\t100,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0x1D17, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_neptune_xt =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t45000,\n\t100,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0x3A2F, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_cac_config_reg cac_weights_chelsea_pro[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x82, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x153, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x52, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0xAC, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0xBE, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x110, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x4CD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x37, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x27, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0xC3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x28, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x26C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3B2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x99D, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA3F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x34, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x2BD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x100, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_chelsea_xt[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x82, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x153, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x52, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0xAC, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0xBE, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x110, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x4CD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x37, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x27, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0xC3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x28, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x26C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3B2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x99D, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA3F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x34, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x30A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x100, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_heathrow[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x82, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x153, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x52, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0xAC, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0xBE, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x110, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x4CD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x37, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x27, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0xC3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x28, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x26C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3B2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x99D, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA3F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x34, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x362, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x100, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_cape_verde_pro[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x82, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x153, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x52, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0xAC, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0xBE, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x110, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x4CD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x37, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x27, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0xC3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x28, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x26C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3B2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x99D, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA3F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x34, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x315, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x100, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_cape_verde[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x82, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x153, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x52, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0xAC, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0xBE, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x110, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x4CD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x37, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x27, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0xC3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x28, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x26C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3B2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x99D, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA3F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x34, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x3BA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x100, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg lcac_cape_verde[] =\n{\n\t{ 0x98, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x98, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9b, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x107, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x107, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x113, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x113, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x152, 0x0001fffe, 1, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x152, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8f, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x146, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x146, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_override_cape_verde[] =\n{\n    { 0xFFFFFFFF }\n};\n\nstatic const struct si_powertune_data powertune_data_cape_verde =\n{\n\t((1 << 16) | 0x6993),\n\t5,\n\t0,\n\t7,\n\t105,\n\t{\n\t\t0UL,\n\t\t0UL,\n\t\t7194395UL,\n\t\t309631529UL,\n\t\t-1270850L,\n\t\t4513710L,\n\t\t100\n\t},\n\t117830498UL,\n\t12,\n\t{\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0\n\t},\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_cape_verde =\n{\n\t{ 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0 },\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t0,\n\tfalse\n};\n\nstatic const struct si_dte_data dte_data_venus_xtx =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x71C, 0xAAB, 0xE39, 0x11C7, 0x0 },\n\t5,\n\t55000,\n\t0x69,\n\t0xA,\n\t1,\n\t0,\n\t0x3,\n\t{ 0x96, 0xB4, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t{ 0xD6D8, 0x88B8, 0x1555, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_venus_xt =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0xBDA, 0x11C7, 0x17B4, 0x1DA1, 0x0 },\n\t5,\n\t55000,\n\t0x69,\n\t0xA,\n\t1,\n\t0,\n\t0x3,\n\t{ 0x96, 0xB4, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t{ 0xAFC8, 0x88B8, 0x238E, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_venus_pro =\n{\n\t{  0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x11C7, 0x1AAB, 0x238E, 0x2C72, 0x0 },\n\t5,\n\t55000,\n\t0x69,\n\t0xA,\n\t1,\n\t0,\n\t0x3,\n\t{ 0x96, 0xB4, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t{ 0x88B8, 0x88B8, 0x3555, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_cac_config_reg cac_weights_oland[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x82, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x153, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x52, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x4F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x135, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0xAC, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x118, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0xBE, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x110, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x4CD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x37, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x27, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0xC3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x35, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0x28, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x26C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3B2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x99D, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA3F, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0xA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x34, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x3BA, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x30, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x100, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_mars_pro[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x43, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0xAF, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x2A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x59, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x1A5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x1D6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x2A3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x8FD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x76, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x8A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0xA3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x71, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0xA6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x81, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3D2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x27C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA96, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0xB, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x32, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7E, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0x280, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0x3C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0x203, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0xB4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_mars_xt[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x43, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0xAF, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x2A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x59, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x1A5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x1D6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x2A3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x8FD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x76, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x8A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0xA3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x71, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0xA6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x81, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3D2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x27C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA96, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0xB, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x60, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x32, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7E, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0x280, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0x3C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0x203, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0xB4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_oland_pro[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x43, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0xAF, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x2A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x59, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x1A5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x1D6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x2A3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x8FD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x76, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x8A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0xA3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x71, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0xA6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x81, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3D2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x27C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA96, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0xB, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x90, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x32, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7E, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0x280, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0x3C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0x203, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0xB4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_weights_oland_xt[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x43, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0xAF, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x2A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x29, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0xA0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x59, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x1A5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x1D6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0x2A3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x8FD, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x76, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x8A, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0xA3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x71, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0xA6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x81, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0x3D2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0x27C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xA96, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x5, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0xB, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x15, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x36, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x10, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x120, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x32, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x7E, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0x280, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0x7, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0x3C, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0x203, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0xB4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg lcac_oland[] =\n{\n\t{ 0x98, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x98, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x0001fffe, 1, 0x4, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg lcac_mars_pro[] =\n{\n\t{ 0x98, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x98, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x104, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x110, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x0001fffe, 1, 0x6, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x143, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x164, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x167, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16a, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15e, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x161, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15b, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x0001fffe, 1, 0x2, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16d, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x170, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x173, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x176, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x179, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17c, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x0001fffe, 1, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17f, 0x00000001, 0, 0x1, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_cac_config_reg cac_override_oland[] =\n{\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_powertune_data powertune_data_oland =\n{\n\t((1 << 16) | 0x6993),\n\t5,\n\t0,\n\t7,\n\t105,\n\t{\n\t\t0UL,\n\t\t0UL,\n\t\t7194395UL,\n\t\t309631529UL,\n\t\t-1270850L,\n\t\t4513710L,\n\t\t100\n\t},\n\t117830498UL,\n\t12,\n\t{\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0\n\t},\n\ttrue\n};\n\nstatic const struct si_powertune_data powertune_data_mars_pro =\n{\n\t((1 << 16) | 0x6993),\n\t5,\n\t0,\n\t7,\n\t105,\n\t{\n\t\t0UL,\n\t\t0UL,\n\t\t7194395UL,\n\t\t309631529UL,\n\t\t-1270850L,\n\t\t4513710L,\n\t\t100\n\t},\n\t117830498UL,\n\t12,\n\t{\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0\n\t},\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_oland =\n{\n\t{ 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0 },\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n\t0,\n\tfalse\n};\n\nstatic const struct si_dte_data dte_data_mars_pro =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t55000,\n\t105,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0xF627, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\nstatic const struct si_dte_data dte_data_sun_xt =\n{\n\t{ 0x1E8480, 0x3D0900, 0x989680, 0x2625A00, 0x0 },\n\t{ 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t5,\n\t55000,\n\t105,\n\t0xA,\n\t1,\n\t0,\n\t0x10,\n\t{ 0x96, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },\n\t{ 0x895440, 0x3D0900, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680, 0x989680 },\n\t{ 0xD555, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },\n\t90,\n\ttrue\n};\n\n\nstatic const struct si_cac_config_reg cac_weights_hainan[] =\n{\n\t{ 0x0, 0x0000ffff, 0, 0x2d9, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x0, 0xffff0000, 16, 0x22b, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0x0000ffff, 0, 0x21c, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1, 0xffff0000, 16, 0x1dc, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x2, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0x0000ffff, 0, 0x24e, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x3, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0x0000ffff, 0, 0x35e, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x5, 0xffff0000, 16, 0x1143, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0x0000ffff, 0, 0xe17, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6, 0xffff0000, 16, 0x441, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18f, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0x0000ffff, 0, 0x28b, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x7, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x8, 0xffff0000, 16, 0xabe, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x9, 0x0000ffff, 0, 0xf11, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xa, 0x0000ffff, 0, 0x907, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0x0000ffff, 0, 0xb45, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xb, 0xffff0000, 16, 0xd1e, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xc, 0x0000ffff, 0, 0xa2c, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0x0000ffff, 0, 0x62, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xd, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xe, 0x0000ffff, 0, 0x1f3, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0x0000ffff, 0, 0x42, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xf, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x10, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0x0000ffff, 0, 0x709, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x11, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x12, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x13, 0xffff0000, 16, 0x3a, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x14, 0x0000ffff, 0, 0x357, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0x0000ffff, 0, 0x9f, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x15, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x4e, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0x0000ffff, 0, 0x314, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x16, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x17, 0x0000ffff, 0, 0x6d, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x18, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0x0000ffff, 0, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x19, 0xffff0000, 16, 0x0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1a, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1b, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1c, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1d, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1e, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x1f, 0xffff0000, 16, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x20, 0x0000ffff, 0, 0, SISLANDS_CACCONFIG_CGIND },\n\t{ 0x6d, 0x0000ffff, 0, 0x1b9, SISLANDS_CACCONFIG_CGIND },\n\t{ 0xFFFFFFFF }\n};\n\nstatic const struct si_powertune_data powertune_data_hainan =\n{\n\t((1 << 16) | 0x6993),\n\t5,\n\t0,\n\t9,\n\t105,\n\t{\n\t\t0UL,\n\t\t0UL,\n\t\t7194395UL,\n\t\t309631529UL,\n\t\t-1270850L,\n\t\t4513710L,\n\t\t100\n\t},\n\t117830498UL,\n\t12,\n\t{\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0,\n\t\t0\n\t},\n\ttrue\n};\n\nstatic struct rv7xx_power_info *rv770_get_pi(struct amdgpu_device *adev);\nstatic struct evergreen_power_info *evergreen_get_pi(struct amdgpu_device *adev);\nstatic struct ni_power_info *ni_get_pi(struct amdgpu_device *adev);\nstatic struct  si_ps *si_get_ps(struct amdgpu_ps *rps);\n\nstatic int si_populate_voltage_value(struct amdgpu_device *adev,\n\t\t\t\t     const struct atom_voltage_table *table,\n\t\t\t\t     u16 value, SISLANDS_SMC_VOLTAGE_VALUE *voltage);\nstatic int si_get_std_voltage_value(struct amdgpu_device *adev,\n\t\t\t\t    SISLANDS_SMC_VOLTAGE_VALUE *voltage,\n\t\t\t\t    u16 *std_voltage);\nstatic int si_write_smc_soft_register(struct amdgpu_device *adev,\n\t\t\t\t      u16 reg_offset, u32 value);\nstatic int si_convert_power_level_to_smc(struct amdgpu_device *adev,\n\t\t\t\t\t struct rv7xx_pl *pl,\n\t\t\t\t\t SISLANDS_SMC_HW_PERFORMANCE_LEVEL *level);\nstatic int si_calculate_sclk_params(struct amdgpu_device *adev,\n\t\t\t\t    u32 engine_clock,\n\t\t\t\t    SISLANDS_SMC_SCLK_VALUE *sclk);\n\nstatic void si_thermal_start_smc_fan_control(struct amdgpu_device *adev);\nstatic void si_fan_ctrl_set_default_mode(struct amdgpu_device *adev);\nstatic void si_dpm_set_irq_funcs(struct amdgpu_device *adev);\n\nstatic struct si_power_info *si_get_pi(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *pi = adev->pm.dpm.priv;\n\treturn pi;\n}\n\nstatic void si_calculate_leakage_for_v_and_t_formula(const struct ni_leakage_coeffients *coeff,\n\t\t\t\t\t\t     u16 v, s32 t, u32 ileakage, u32 *leakage)\n{\n\ts64 kt, kv, leakage_w, i_leakage, vddc;\n\ts64 temperature, t_slope, t_intercept, av, bv, t_ref;\n\ts64 tmp;\n\n\ti_leakage = div64_s64(drm_int2fixp(ileakage), 100);\n\tvddc = div64_s64(drm_int2fixp(v), 1000);\n\ttemperature = div64_s64(drm_int2fixp(t), 1000);\n\n\tt_slope = div64_s64(drm_int2fixp(coeff->t_slope), 100000000);\n\tt_intercept = div64_s64(drm_int2fixp(coeff->t_intercept), 100000000);\n\tav = div64_s64(drm_int2fixp(coeff->av), 100000000);\n\tbv = div64_s64(drm_int2fixp(coeff->bv), 100000000);\n\tt_ref = drm_int2fixp(coeff->t_ref);\n\n\ttmp = drm_fixp_mul(t_slope, vddc) + t_intercept;\n\tkt = drm_fixp_exp(drm_fixp_mul(tmp, temperature));\n\tkt = drm_fixp_div(kt, drm_fixp_exp(drm_fixp_mul(tmp, t_ref)));\n\tkv = drm_fixp_mul(av, drm_fixp_exp(drm_fixp_mul(bv, vddc)));\n\n\tleakage_w = drm_fixp_mul(drm_fixp_mul(drm_fixp_mul(i_leakage, kt), kv), vddc);\n\n\t*leakage = drm_fixp2int(leakage_w * 1000);\n}\n\nstatic void si_calculate_leakage_for_v_and_t(struct amdgpu_device *adev,\n\t\t\t\t\t     const struct ni_leakage_coeffients *coeff,\n\t\t\t\t\t     u16 v,\n\t\t\t\t\t     s32 t,\n\t\t\t\t\t     u32 i_leakage,\n\t\t\t\t\t     u32 *leakage)\n{\n\tsi_calculate_leakage_for_v_and_t_formula(coeff, v, t, i_leakage, leakage);\n}\n\nstatic void si_calculate_leakage_for_v_formula(const struct ni_leakage_coeffients *coeff,\n\t\t\t\t\t       const u32 fixed_kt, u16 v,\n\t\t\t\t\t       u32 ileakage, u32 *leakage)\n{\n\ts64 kt, kv, leakage_w, i_leakage, vddc;\n\n\ti_leakage = div64_s64(drm_int2fixp(ileakage), 100);\n\tvddc = div64_s64(drm_int2fixp(v), 1000);\n\n\tkt = div64_s64(drm_int2fixp(fixed_kt), 100000000);\n\tkv = drm_fixp_mul(div64_s64(drm_int2fixp(coeff->av), 100000000),\n\t\t\t  drm_fixp_exp(drm_fixp_mul(div64_s64(drm_int2fixp(coeff->bv), 100000000), vddc)));\n\n\tleakage_w = drm_fixp_mul(drm_fixp_mul(drm_fixp_mul(i_leakage, kt), kv), vddc);\n\n\t*leakage = drm_fixp2int(leakage_w * 1000);\n}\n\nstatic void si_calculate_leakage_for_v(struct amdgpu_device *adev,\n\t\t\t\t       const struct ni_leakage_coeffients *coeff,\n\t\t\t\t       const u32 fixed_kt,\n\t\t\t\t       u16 v,\n\t\t\t\t       u32 i_leakage,\n\t\t\t\t       u32 *leakage)\n{\n\tsi_calculate_leakage_for_v_formula(coeff, fixed_kt, v, i_leakage, leakage);\n}\n\n\nstatic void si_update_dte_from_pl2(struct amdgpu_device *adev,\n\t\t\t\t   struct si_dte_data *dte_data)\n{\n\tu32 p_limit1 = adev->pm.dpm.tdp_limit;\n\tu32 p_limit2 = adev->pm.dpm.near_tdp_limit;\n\tu32 k = dte_data->k;\n\tu32 t_max = dte_data->max_t;\n\tu32 t_split[5] = { 10, 15, 20, 25, 30 };\n\tu32 t_0 = dte_data->t0;\n\tu32 i;\n\n\tif (p_limit2 != 0 && p_limit2 <= p_limit1) {\n\t\tdte_data->tdep_count = 3;\n\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tdte_data->r[i] =\n\t\t\t\t(t_split[i] * (t_max - t_0/(u32)1000) * (1 << 14)) /\n\t\t\t\t(p_limit2  * (u32)100);\n\t\t}\n\n\t\tdte_data->tdep_r[1] = dte_data->r[4] * 2;\n\n\t\tfor (i = 2; i < SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE; i++) {\n\t\t\tdte_data->tdep_r[i] = dte_data->r[4];\n\t\t}\n\t} else {\n\t\tDRM_ERROR(\"Invalid PL2! DTE will not be updated.\\n\");\n\t}\n}\n\nstatic struct rv7xx_power_info *rv770_get_pi(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = adev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic struct ni_power_info *ni_get_pi(struct amdgpu_device *adev)\n{\n\tstruct ni_power_info *pi = adev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic struct si_ps *si_get_ps(struct amdgpu_ps *aps)\n{\n\tstruct  si_ps *ps = aps->ps_priv;\n\n\treturn ps;\n}\n\nstatic void si_initialize_powertune_defaults(struct amdgpu_device *adev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tbool update_dte_from_pl2 = false;\n\n\tif (adev->asic_type == CHIP_TAHITI) {\n\t\tsi_pi->cac_weights = cac_weights_tahiti;\n\t\tsi_pi->lcac_config = lcac_tahiti;\n\t\tsi_pi->cac_override = cac_override_tahiti;\n\t\tsi_pi->powertune_data = &powertune_data_tahiti;\n\t\tsi_pi->dte_data = dte_data_tahiti;\n\n\t\tswitch (adev->pdev->device) {\n\t\tcase 0x6798:\n\t\t\tsi_pi->dte_data.enable_dte_by_default = true;\n\t\t\tbreak;\n\t\tcase 0x6799:\n\t\t\tsi_pi->dte_data = dte_data_new_zealand;\n\t\t\tbreak;\n\t\tcase 0x6790:\n\t\tcase 0x6791:\n\t\tcase 0x6792:\n\t\tcase 0x679E:\n\t\t\tsi_pi->dte_data = dte_data_aruba_pro;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x679B:\n\t\t\tsi_pi->dte_data = dte_data_malta;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x679A:\n\t\t\tsi_pi->dte_data = dte_data_tahiti_pro;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (si_pi->dte_data.enable_dte_by_default == true)\n\t\t\t\tDRM_ERROR(\"DTE is not enabled!\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else if (adev->asic_type == CHIP_PITCAIRN) {\n\t\tsi_pi->cac_weights = cac_weights_pitcairn;\n\t\tsi_pi->lcac_config = lcac_pitcairn;\n\t\tsi_pi->cac_override = cac_override_pitcairn;\n\t\tsi_pi->powertune_data = &powertune_data_pitcairn;\n\n\t\tswitch (adev->pdev->device) {\n\t\tcase 0x6810:\n\t\tcase 0x6818:\n\t\t\tsi_pi->dte_data = dte_data_curacao_xt;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x6819:\n\t\tcase 0x6811:\n\t\t\tsi_pi->dte_data = dte_data_curacao_pro;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x6800:\n\t\tcase 0x6806:\n\t\t\tsi_pi->dte_data = dte_data_neptune_xt;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi_pi->dte_data = dte_data_pitcairn;\n\t\t\tbreak;\n\t\t}\n\t} else if (adev->asic_type == CHIP_VERDE) {\n\t\tsi_pi->lcac_config = lcac_cape_verde;\n\t\tsi_pi->cac_override = cac_override_cape_verde;\n\t\tsi_pi->powertune_data = &powertune_data_cape_verde;\n\n\t\tswitch (adev->pdev->device) {\n\t\tcase 0x683B:\n\t\tcase 0x683F:\n\t\tcase 0x6829:\n\t\tcase 0x6835:\n\t\t\tsi_pi->cac_weights = cac_weights_cape_verde_pro;\n\t\t\tsi_pi->dte_data = dte_data_cape_verde;\n\t\t\tbreak;\n\t\tcase 0x682C:\n\t\t\tsi_pi->cac_weights = cac_weights_cape_verde_pro;\n\t\t\tsi_pi->dte_data = dte_data_sun_xt;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x6825:\n\t\tcase 0x6827:\n\t\t\tsi_pi->cac_weights = cac_weights_heathrow;\n\t\t\tsi_pi->dte_data = dte_data_cape_verde;\n\t\t\tbreak;\n\t\tcase 0x6824:\n\t\tcase 0x682D:\n\t\t\tsi_pi->cac_weights = cac_weights_chelsea_xt;\n\t\t\tsi_pi->dte_data = dte_data_cape_verde;\n\t\t\tbreak;\n\t\tcase 0x682F:\n\t\t\tsi_pi->cac_weights = cac_weights_chelsea_pro;\n\t\t\tsi_pi->dte_data = dte_data_cape_verde;\n\t\t\tbreak;\n\t\tcase 0x6820:\n\t\t\tsi_pi->cac_weights = cac_weights_heathrow;\n\t\t\tsi_pi->dte_data = dte_data_venus_xtx;\n\t\t\tbreak;\n\t\tcase 0x6821:\n\t\t\tsi_pi->cac_weights = cac_weights_heathrow;\n\t\t\tsi_pi->dte_data = dte_data_venus_xt;\n\t\t\tbreak;\n\t\tcase 0x6823:\n\t\tcase 0x682B:\n\t\tcase 0x6822:\n\t\tcase 0x682A:\n\t\t\tsi_pi->cac_weights = cac_weights_chelsea_pro;\n\t\t\tsi_pi->dte_data = dte_data_venus_pro;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi_pi->cac_weights = cac_weights_cape_verde;\n\t\t\tsi_pi->dte_data = dte_data_cape_verde;\n\t\t\tbreak;\n\t\t}\n\t} else if (adev->asic_type == CHIP_OLAND) {\n\t\tsi_pi->lcac_config = lcac_mars_pro;\n\t\tsi_pi->cac_override = cac_override_oland;\n\t\tsi_pi->powertune_data = &powertune_data_mars_pro;\n\t\tsi_pi->dte_data = dte_data_mars_pro;\n\n\t\tswitch (adev->pdev->device) {\n\t\tcase 0x6601:\n\t\tcase 0x6621:\n\t\tcase 0x6603:\n\t\tcase 0x6605:\n\t\t\tsi_pi->cac_weights = cac_weights_mars_pro;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x6600:\n\t\tcase 0x6606:\n\t\tcase 0x6620:\n\t\tcase 0x6604:\n\t\t\tsi_pi->cac_weights = cac_weights_mars_xt;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x6611:\n\t\tcase 0x6613:\n\t\tcase 0x6608:\n\t\t\tsi_pi->cac_weights = cac_weights_oland_pro;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tcase 0x6610:\n\t\t\tsi_pi->cac_weights = cac_weights_oland_xt;\n\t\t\tupdate_dte_from_pl2 = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi_pi->cac_weights = cac_weights_oland;\n\t\t\tsi_pi->lcac_config = lcac_oland;\n\t\t\tsi_pi->cac_override = cac_override_oland;\n\t\t\tsi_pi->powertune_data = &powertune_data_oland;\n\t\t\tsi_pi->dte_data = dte_data_oland;\n\t\t\tbreak;\n\t\t}\n\t} else if (adev->asic_type == CHIP_HAINAN) {\n\t\tsi_pi->cac_weights = cac_weights_hainan;\n\t\tsi_pi->lcac_config = lcac_oland;\n\t\tsi_pi->cac_override = cac_override_oland;\n\t\tsi_pi->powertune_data = &powertune_data_hainan;\n\t\tsi_pi->dte_data = dte_data_sun_xt;\n\t\tupdate_dte_from_pl2 = true;\n\t} else {\n\t\tDRM_ERROR(\"Unknown SI asic revision, failed to initialize PowerTune!\\n\");\n\t\treturn;\n\t}\n\n\tni_pi->enable_power_containment = false;\n\tni_pi->enable_cac = false;\n\tni_pi->enable_sq_ramping = false;\n\tsi_pi->enable_dte = false;\n\n\tif (si_pi->powertune_data->enable_powertune_by_default) {\n\t\tni_pi->enable_power_containment = true;\n\t\tni_pi->enable_cac = true;\n\t\tif (si_pi->dte_data.enable_dte_by_default) {\n\t\t\tsi_pi->enable_dte = true;\n\t\t\tif (update_dte_from_pl2)\n\t\t\t\tsi_update_dte_from_pl2(adev, &si_pi->dte_data);\n\n\t\t}\n\t\tni_pi->enable_sq_ramping = true;\n\t}\n\n\tni_pi->driver_calculate_cac_leakage = true;\n\tni_pi->cac_configuration_required = true;\n\n\tif (ni_pi->cac_configuration_required) {\n\t\tni_pi->support_cac_long_term_average = true;\n\t\tsi_pi->dyn_powertune_data.l2_lta_window_size =\n\t\t\tsi_pi->powertune_data->l2_lta_window_size_default;\n\t\tsi_pi->dyn_powertune_data.lts_truncate =\n\t\t\tsi_pi->powertune_data->lts_truncate_default;\n\t} else {\n\t\tni_pi->support_cac_long_term_average = false;\n\t\tsi_pi->dyn_powertune_data.l2_lta_window_size = 0;\n\t\tsi_pi->dyn_powertune_data.lts_truncate = 0;\n\t}\n\n\tsi_pi->dyn_powertune_data.disable_uvd_powertune = false;\n}\n\nstatic u32 si_get_smc_power_scaling_factor(struct amdgpu_device *adev)\n{\n\treturn 1;\n}\n\nstatic u32 si_calculate_cac_wintime(struct amdgpu_device *adev)\n{\n\tu32 xclk;\n\tu32 wintime;\n\tu32 cac_window;\n\tu32 cac_window_size;\n\n\txclk = amdgpu_asic_get_xclk(adev);\n\n\tif (xclk == 0)\n\t\treturn 0;\n\n\tcac_window = RREG32(CG_CAC_CTRL) & CAC_WINDOW_MASK;\n\tcac_window_size = ((cac_window & 0xFFFF0000) >> 16) * (cac_window & 0x0000FFFF);\n\n\twintime = (cac_window_size * 100) / xclk;\n\n\treturn wintime;\n}\n\nstatic u32 si_scale_power_for_smc(u32 power_in_watts, u32 scaling_factor)\n{\n\treturn power_in_watts;\n}\n\nstatic int si_calculate_adjusted_tdp_limits(struct amdgpu_device *adev,\n\t\t\t\t\t    bool adjust_polarity,\n\t\t\t\t\t    u32 tdp_adjustment,\n\t\t\t\t\t    u32 *tdp_limit,\n\t\t\t\t\t    u32 *near_tdp_limit)\n{\n\tu32 adjustment_delta, max_tdp_limit;\n\n\tif (tdp_adjustment > (u32)adev->pm.dpm.tdp_od_limit)\n\t\treturn -EINVAL;\n\n\tmax_tdp_limit = ((100 + 100) * adev->pm.dpm.tdp_limit) / 100;\n\n\tif (adjust_polarity) {\n\t\t*tdp_limit = ((100 + tdp_adjustment) * adev->pm.dpm.tdp_limit) / 100;\n\t\t*near_tdp_limit = adev->pm.dpm.near_tdp_limit_adjusted + (*tdp_limit - adev->pm.dpm.tdp_limit);\n\t} else {\n\t\t*tdp_limit = ((100 - tdp_adjustment) * adev->pm.dpm.tdp_limit) / 100;\n\t\tadjustment_delta  = adev->pm.dpm.tdp_limit - *tdp_limit;\n\t\tif (adjustment_delta < adev->pm.dpm.near_tdp_limit_adjusted)\n\t\t\t*near_tdp_limit = adev->pm.dpm.near_tdp_limit_adjusted - adjustment_delta;\n\t\telse\n\t\t\t*near_tdp_limit = 0;\n\t}\n\n\tif ((*tdp_limit <= 0) || (*tdp_limit > max_tdp_limit))\n\t\treturn -EINVAL;\n\tif ((*near_tdp_limit <= 0) || (*near_tdp_limit > *tdp_limit))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int si_populate_smc_tdp_limits(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_ps *amdgpu_state)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tif (ni_pi->enable_power_containment) {\n\t\tSISLANDS_SMC_STATETABLE *smc_table = &si_pi->smc_statetable;\n\t\tPP_SIslands_PAPMParameters *papm_parm;\n\t\tstruct amdgpu_ppm_table *ppm = adev->pm.dpm.dyn_state.ppm_table;\n\t\tu32 scaling_factor = si_get_smc_power_scaling_factor(adev);\n\t\tu32 tdp_limit;\n\t\tu32 near_tdp_limit;\n\t\tint ret;\n\n\t\tif (scaling_factor == 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(smc_table, 0, sizeof(SISLANDS_SMC_STATETABLE));\n\n\t\tret = si_calculate_adjusted_tdp_limits(adev,\n\t\t\t\t\t\t       false,  \n\t\t\t\t\t\t       adev->pm.dpm.tdp_adjustment,\n\t\t\t\t\t\t       &tdp_limit,\n\t\t\t\t\t\t       &near_tdp_limit);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsmc_table->dpm2Params.TDPLimit =\n\t\t\tcpu_to_be32(si_scale_power_for_smc(tdp_limit, scaling_factor) * 1000);\n\t\tsmc_table->dpm2Params.NearTDPLimit =\n\t\t\tcpu_to_be32(si_scale_power_for_smc(near_tdp_limit, scaling_factor) * 1000);\n\t\tsmc_table->dpm2Params.SafePowerLimit =\n\t\t\tcpu_to_be32(si_scale_power_for_smc((near_tdp_limit * SISLANDS_DPM2_TDP_SAFE_LIMIT_PERCENT) / 100, scaling_factor) * 1000);\n\n\t\tret = amdgpu_si_copy_bytes_to_smc(adev,\n\t\t\t\t\t\t  (si_pi->state_table_start + offsetof(SISLANDS_SMC_STATETABLE, dpm2Params) +\n\t\t\t\t\t\t   offsetof(PP_SIslands_DPM2Parameters, TDPLimit)),\n\t\t\t\t\t\t  (u8 *)(&(smc_table->dpm2Params.TDPLimit)),\n\t\t\t\t\t\t  sizeof(u32) * 3,\n\t\t\t\t\t\t  si_pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (si_pi->enable_ppm) {\n\t\t\tpapm_parm = &si_pi->papm_parm;\n\t\t\tmemset(papm_parm, 0, sizeof(PP_SIslands_PAPMParameters));\n\t\t\tpapm_parm->NearTDPLimitTherm = cpu_to_be32(ppm->dgpu_tdp);\n\t\t\tpapm_parm->dGPU_T_Limit = cpu_to_be32(ppm->tj_max);\n\t\t\tpapm_parm->dGPU_T_Warning = cpu_to_be32(95);\n\t\t\tpapm_parm->dGPU_T_Hysteresis = cpu_to_be32(5);\n\t\t\tpapm_parm->PlatformPowerLimit = 0xffffffff;\n\t\t\tpapm_parm->NearTDPLimitPAPM = 0xffffffff;\n\n\t\t\tret = amdgpu_si_copy_bytes_to_smc(adev, si_pi->papm_cfg_table_start,\n\t\t\t\t\t\t\t  (u8 *)papm_parm,\n\t\t\t\t\t\t\t  sizeof(PP_SIslands_PAPMParameters),\n\t\t\t\t\t\t\t  si_pi->sram_end);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int si_populate_smc_tdp_limits_2(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_ps *amdgpu_state)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tif (ni_pi->enable_power_containment) {\n\t\tSISLANDS_SMC_STATETABLE *smc_table = &si_pi->smc_statetable;\n\t\tu32 scaling_factor = si_get_smc_power_scaling_factor(adev);\n\t\tint ret;\n\n\t\tmemset(smc_table, 0, sizeof(SISLANDS_SMC_STATETABLE));\n\n\t\tsmc_table->dpm2Params.NearTDPLimit =\n\t\t\tcpu_to_be32(si_scale_power_for_smc(adev->pm.dpm.near_tdp_limit_adjusted, scaling_factor) * 1000);\n\t\tsmc_table->dpm2Params.SafePowerLimit =\n\t\t\tcpu_to_be32(si_scale_power_for_smc((adev->pm.dpm.near_tdp_limit_adjusted * SISLANDS_DPM2_TDP_SAFE_LIMIT_PERCENT) / 100, scaling_factor) * 1000);\n\n\t\tret = amdgpu_si_copy_bytes_to_smc(adev,\n\t\t\t\t\t\t  (si_pi->state_table_start +\n\t\t\t\t\t\t   offsetof(SISLANDS_SMC_STATETABLE, dpm2Params) +\n\t\t\t\t\t\t   offsetof(PP_SIslands_DPM2Parameters, NearTDPLimit)),\n\t\t\t\t\t\t  (u8 *)(&(smc_table->dpm2Params.NearTDPLimit)),\n\t\t\t\t\t\t  sizeof(u32) * 2,\n\t\t\t\t\t\t  si_pi->sram_end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic u16 si_calculate_power_efficiency_ratio(struct amdgpu_device *adev,\n\t\t\t\t\t       const u16 prev_std_vddc,\n\t\t\t\t\t       const u16 curr_std_vddc)\n{\n\tu64 margin = (u64)SISLANDS_DPM2_PWREFFICIENCYRATIO_MARGIN;\n\tu64 prev_vddc = (u64)prev_std_vddc;\n\tu64 curr_vddc = (u64)curr_std_vddc;\n\tu64 pwr_efficiency_ratio, n, d;\n\n\tif ((prev_vddc == 0) || (curr_vddc == 0))\n\t\treturn 0;\n\n\tn = div64_u64((u64)1024 * curr_vddc * curr_vddc * ((u64)1000 + margin), (u64)1000);\n\td = prev_vddc * prev_vddc;\n\tpwr_efficiency_ratio = div64_u64(n, d);\n\n\tif (pwr_efficiency_ratio > (u64)0xFFFF)\n\t\treturn 0;\n\n\treturn (u16)pwr_efficiency_ratio;\n}\n\nstatic bool si_should_disable_uvd_powertune(struct amdgpu_device *adev,\n\t\t\t\t\t    struct amdgpu_ps *amdgpu_state)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tif (si_pi->dyn_powertune_data.disable_uvd_powertune &&\n\t    amdgpu_state->vclk && amdgpu_state->dclk)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct evergreen_power_info *evergreen_get_pi(struct amdgpu_device *adev)\n{\n\tstruct evergreen_power_info *pi = adev->pm.dpm.priv;\n\n\treturn pi;\n}\n\nstatic int si_populate_power_containment_values(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct amdgpu_ps *amdgpu_state,\n\t\t\t\t\t\tSISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct  si_ps *state = si_get_ps(amdgpu_state);\n\tSISLANDS_SMC_VOLTAGE_VALUE vddc;\n\tu32 prev_sclk;\n\tu32 max_sclk;\n\tu32 min_sclk;\n\tu16 prev_std_vddc;\n\tu16 curr_std_vddc;\n\tint i;\n\tu16 pwr_efficiency_ratio;\n\tu8 max_ps_percent;\n\tbool disable_uvd_power_tune;\n\tint ret;\n\n\tif (ni_pi->enable_power_containment == false)\n\t\treturn 0;\n\n\tif (state->performance_level_count == 0)\n\t\treturn -EINVAL;\n\n\tif (smc_state->levelCount != state->performance_level_count)\n\t\treturn -EINVAL;\n\n\tdisable_uvd_power_tune = si_should_disable_uvd_powertune(adev, amdgpu_state);\n\n\tsmc_state->levels[0].dpm2.MaxPS = 0;\n\tsmc_state->levels[0].dpm2.NearTDPDec = 0;\n\tsmc_state->levels[0].dpm2.AboveSafeInc = 0;\n\tsmc_state->levels[0].dpm2.BelowSafeInc = 0;\n\tsmc_state->levels[0].dpm2.PwrEfficiencyRatio = 0;\n\n\tfor (i = 1; i < state->performance_level_count; i++) {\n\t\tprev_sclk = state->performance_levels[i-1].sclk;\n\t\tmax_sclk  = state->performance_levels[i].sclk;\n\t\tif (i == 1)\n\t\t\tmax_ps_percent = SISLANDS_DPM2_MAXPS_PERCENT_M;\n\t\telse\n\t\t\tmax_ps_percent = SISLANDS_DPM2_MAXPS_PERCENT_H;\n\n\t\tif (prev_sclk > max_sclk)\n\t\t\treturn -EINVAL;\n\n\t\tif ((max_ps_percent == 0) ||\n\t\t    (prev_sclk == max_sclk) ||\n\t\t    disable_uvd_power_tune)\n\t\t\tmin_sclk = max_sclk;\n\t\telse if (i == 1)\n\t\t\tmin_sclk = prev_sclk;\n\t\telse\n\t\t\tmin_sclk = (prev_sclk * (u32)max_ps_percent) / 100;\n\n\t\tif (min_sclk < state->performance_levels[0].sclk)\n\t\t\tmin_sclk = state->performance_levels[0].sclk;\n\n\t\tif (min_sclk == 0)\n\t\t\treturn -EINVAL;\n\n\t\tret = si_populate_voltage_value(adev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tstate->performance_levels[i-1].vddc, &vddc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = si_get_std_voltage_value(adev, &vddc, &prev_std_vddc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = si_populate_voltage_value(adev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tstate->performance_levels[i].vddc, &vddc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = si_get_std_voltage_value(adev, &vddc, &curr_std_vddc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpwr_efficiency_ratio = si_calculate_power_efficiency_ratio(adev,\n\t\t\t\t\t\t\t\t\t   prev_std_vddc, curr_std_vddc);\n\n\t\tsmc_state->levels[i].dpm2.MaxPS = (u8)((SISLANDS_DPM2_MAX_PULSE_SKIP * (max_sclk - min_sclk)) / max_sclk);\n\t\tsmc_state->levels[i].dpm2.NearTDPDec = SISLANDS_DPM2_NEAR_TDP_DEC;\n\t\tsmc_state->levels[i].dpm2.AboveSafeInc = SISLANDS_DPM2_ABOVE_SAFE_INC;\n\t\tsmc_state->levels[i].dpm2.BelowSafeInc = SISLANDS_DPM2_BELOW_SAFE_INC;\n\t\tsmc_state->levels[i].dpm2.PwrEfficiencyRatio = cpu_to_be16(pwr_efficiency_ratio);\n\t}\n\n\treturn 0;\n}\n\nstatic int si_populate_sq_ramping_values(struct amdgpu_device *adev,\n\t\t\t\t\t struct amdgpu_ps *amdgpu_state,\n\t\t\t\t\t SISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct  si_ps *state = si_get_ps(amdgpu_state);\n\tu32 sq_power_throttle, sq_power_throttle2;\n\tbool enable_sq_ramping = ni_pi->enable_sq_ramping;\n\tint i;\n\n\tif (state->performance_level_count == 0)\n\t\treturn -EINVAL;\n\n\tif (smc_state->levelCount != state->performance_level_count)\n\t\treturn -EINVAL;\n\n\tif (adev->pm.dpm.sq_ramping_threshold == 0)\n\t\treturn -EINVAL;\n\n\tif (SISLANDS_DPM2_SQ_RAMP_MAX_POWER > (MAX_POWER_MASK >> MAX_POWER_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (SISLANDS_DPM2_SQ_RAMP_MIN_POWER > (MIN_POWER_MASK >> MIN_POWER_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (SISLANDS_DPM2_SQ_RAMP_MAX_POWER_DELTA > (MAX_POWER_DELTA_MASK >> MAX_POWER_DELTA_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (SISLANDS_DPM2_SQ_RAMP_STI_SIZE > (STI_SIZE_MASK >> STI_SIZE_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tif (SISLANDS_DPM2_SQ_RAMP_LTI_RATIO > (LTI_RATIO_MASK >> LTI_RATIO_SHIFT))\n\t\tenable_sq_ramping = false;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tsq_power_throttle = 0;\n\t\tsq_power_throttle2 = 0;\n\n\t\tif ((state->performance_levels[i].sclk >= adev->pm.dpm.sq_ramping_threshold) &&\n\t\t    enable_sq_ramping) {\n\t\t\tsq_power_throttle |= MAX_POWER(SISLANDS_DPM2_SQ_RAMP_MAX_POWER);\n\t\t\tsq_power_throttle |= MIN_POWER(SISLANDS_DPM2_SQ_RAMP_MIN_POWER);\n\t\t\tsq_power_throttle2 |= MAX_POWER_DELTA(SISLANDS_DPM2_SQ_RAMP_MAX_POWER_DELTA);\n\t\t\tsq_power_throttle2 |= STI_SIZE(SISLANDS_DPM2_SQ_RAMP_STI_SIZE);\n\t\t\tsq_power_throttle2 |= LTI_RATIO(SISLANDS_DPM2_SQ_RAMP_LTI_RATIO);\n\t\t} else {\n\t\t\tsq_power_throttle |= MAX_POWER_MASK | MIN_POWER_MASK;\n\t\t\tsq_power_throttle2 |= MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;\n\t\t}\n\n\t\tsmc_state->levels[i].SQPowerThrottle = cpu_to_be32(sq_power_throttle);\n\t\tsmc_state->levels[i].SQPowerThrottle_2 = cpu_to_be32(sq_power_throttle2);\n\t}\n\n\treturn 0;\n}\n\nstatic int si_enable_power_containment(struct amdgpu_device *adev,\n\t\t\t\t       struct amdgpu_ps *amdgpu_new_state,\n\t\t\t\t       bool enable)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tPPSMC_Result smc_result;\n\tint ret = 0;\n\n\tif (ni_pi->enable_power_containment) {\n\t\tif (enable) {\n\t\t\tif (!si_should_disable_uvd_powertune(adev, amdgpu_new_state)) {\n\t\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_TDPClampingActive);\n\t\t\t\tif (smc_result != PPSMC_Result_OK) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tni_pi->pc_enabled = false;\n\t\t\t\t} else {\n\t\t\t\t\tni_pi->pc_enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_TDPClampingInactive);\n\t\t\tif (smc_result != PPSMC_Result_OK)\n\t\t\t\tret = -EINVAL;\n\t\t\tni_pi->pc_enabled = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int si_initialize_smc_dte_tables(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint ret = 0;\n\tstruct si_dte_data *dte_data = &si_pi->dte_data;\n\tSmc_SIslands_DTE_Configuration *dte_tables = NULL;\n\tu32 table_size;\n\tu8 tdep_count;\n\tu32 i;\n\n\tif (dte_data == NULL)\n\t\tsi_pi->enable_dte = false;\n\n\tif (si_pi->enable_dte == false)\n\t\treturn 0;\n\n\tif (dte_data->k <= 0)\n\t\treturn -EINVAL;\n\n\tdte_tables = kzalloc(sizeof(Smc_SIslands_DTE_Configuration), GFP_KERNEL);\n\tif (dte_tables == NULL) {\n\t\tsi_pi->enable_dte = false;\n\t\treturn -ENOMEM;\n\t}\n\n\ttable_size = dte_data->k;\n\n\tif (table_size > SMC_SISLANDS_DTE_MAX_FILTER_STAGES)\n\t\ttable_size = SMC_SISLANDS_DTE_MAX_FILTER_STAGES;\n\n\ttdep_count = dte_data->tdep_count;\n\tif (tdep_count > SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE)\n\t\ttdep_count = SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE;\n\n\tdte_tables->K = cpu_to_be32(table_size);\n\tdte_tables->T0 = cpu_to_be32(dte_data->t0);\n\tdte_tables->MaxT = cpu_to_be32(dte_data->max_t);\n\tdte_tables->WindowSize = dte_data->window_size;\n\tdte_tables->temp_select = dte_data->temp_select;\n\tdte_tables->DTE_mode = dte_data->dte_mode;\n\tdte_tables->Tthreshold = cpu_to_be32(dte_data->t_threshold);\n\n\tif (tdep_count > 0)\n\t\ttable_size--;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tdte_tables->tau[i] = cpu_to_be32(dte_data->tau[i]);\n\t\tdte_tables->R[i]   = cpu_to_be32(dte_data->r[i]);\n\t}\n\n\tdte_tables->Tdep_count = tdep_count;\n\n\tfor (i = 0; i < (u32)tdep_count; i++) {\n\t\tdte_tables->T_limits[i] = dte_data->t_limits[i];\n\t\tdte_tables->Tdep_tau[i] = cpu_to_be32(dte_data->tdep_tau[i]);\n\t\tdte_tables->Tdep_R[i] = cpu_to_be32(dte_data->tdep_r[i]);\n\t}\n\n\tret = amdgpu_si_copy_bytes_to_smc(adev, si_pi->dte_table_start,\n\t\t\t\t\t  (u8 *)dte_tables,\n\t\t\t\t\t  sizeof(Smc_SIslands_DTE_Configuration),\n\t\t\t\t\t  si_pi->sram_end);\n\tkfree(dte_tables);\n\n\treturn ret;\n}\n\nstatic int si_get_cac_std_voltage_max_min(struct amdgpu_device *adev,\n\t\t\t\t\t  u16 *max, u16 *min)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct amdgpu_cac_leakage_table *table =\n\t\t&adev->pm.dpm.dyn_state.cac_leakage_table;\n\tu32 i;\n\tu32 v0_loadline;\n\n\tif (table == NULL)\n\t\treturn -EINVAL;\n\n\t*max = 0;\n\t*min = 0xFFFF;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (table->entries[i].vddc > *max)\n\t\t\t*max = table->entries[i].vddc;\n\t\tif (table->entries[i].vddc < *min)\n\t\t\t*min = table->entries[i].vddc;\n\t}\n\n\tif (si_pi->powertune_data->lkge_lut_v0_percent > 100)\n\t\treturn -EINVAL;\n\n\tv0_loadline = (*min) * (100 - si_pi->powertune_data->lkge_lut_v0_percent) / 100;\n\n\tif (v0_loadline > 0xFFFFUL)\n\t\treturn -EINVAL;\n\n\t*min = (u16)v0_loadline;\n\n\tif ((*min > *max) || (*max == 0) || (*min == 0))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic u16 si_get_cac_std_voltage_step(u16 max, u16 min)\n{\n\treturn ((max - min) + (SMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES - 1)) /\n\t\tSMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES;\n}\n\nstatic int si_init_dte_leakage_table(struct amdgpu_device *adev,\n\t\t\t\t     PP_SIslands_CacConfig *cac_tables,\n\t\t\t\t     u16 vddc_max, u16 vddc_min, u16 vddc_step,\n\t\t\t\t     u16 t0, u16 t_step)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 leakage;\n\tunsigned int i, j;\n\ts32 t;\n\tu32 smc_leakage;\n\tu32 scaling_factor;\n\tu16 voltage;\n\n\tscaling_factor = si_get_smc_power_scaling_factor(adev);\n\n\tfor (i = 0; i < SMC_SISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES ; i++) {\n\t\tt = (1000 * (i * t_step + t0));\n\n\t\tfor (j = 0; j < SMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES; j++) {\n\t\t\tvoltage = vddc_max - (vddc_step * j);\n\n\t\t\tsi_calculate_leakage_for_v_and_t(adev,\n\t\t\t\t\t\t\t &si_pi->powertune_data->leakage_coefficients,\n\t\t\t\t\t\t\t voltage,\n\t\t\t\t\t\t\t t,\n\t\t\t\t\t\t\t si_pi->dyn_powertune_data.cac_leakage,\n\t\t\t\t\t\t\t &leakage);\n\n\t\t\tsmc_leakage = si_scale_power_for_smc(leakage, scaling_factor) / 4;\n\n\t\t\tif (smc_leakage > 0xFFFF)\n\t\t\t\tsmc_leakage = 0xFFFF;\n\n\t\t\tcac_tables->cac_lkge_lut[i][SMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES-1-j] =\n\t\t\t\tcpu_to_be16((u16)smc_leakage);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int si_init_simplified_leakage_table(struct amdgpu_device *adev,\n\t\t\t\t\t    PP_SIslands_CacConfig *cac_tables,\n\t\t\t\t\t    u16 vddc_max, u16 vddc_min, u16 vddc_step)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 leakage;\n\tunsigned int i, j;\n\tu32 smc_leakage;\n\tu32 scaling_factor;\n\tu16 voltage;\n\n\tscaling_factor = si_get_smc_power_scaling_factor(adev);\n\n\tfor (j = 0; j < SMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES; j++) {\n\t\tvoltage = vddc_max - (vddc_step * j);\n\n\t\tsi_calculate_leakage_for_v(adev,\n\t\t\t\t\t   &si_pi->powertune_data->leakage_coefficients,\n\t\t\t\t\t   si_pi->powertune_data->fixed_kt,\n\t\t\t\t\t   voltage,\n\t\t\t\t\t   si_pi->dyn_powertune_data.cac_leakage,\n\t\t\t\t\t   &leakage);\n\n\t\tsmc_leakage = si_scale_power_for_smc(leakage, scaling_factor) / 4;\n\n\t\tif (smc_leakage > 0xFFFF)\n\t\t\tsmc_leakage = 0xFFFF;\n\n\t\tfor (i = 0; i < SMC_SISLANDS_LKGE_LUT_NUM_OF_TEMP_ENTRIES ; i++)\n\t\t\tcac_tables->cac_lkge_lut[i][SMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES-1-j] =\n\t\t\t\tcpu_to_be16((u16)smc_leakage);\n\t}\n\treturn 0;\n}\n\nstatic int si_initialize_smc_cac_tables(struct amdgpu_device *adev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tPP_SIslands_CacConfig *cac_tables = NULL;\n\tu16 vddc_max, vddc_min, vddc_step;\n\tu16 t0, t_step;\n\tu32 load_line_slope, reg;\n\tint ret = 0;\n\tu32 ticks_per_us = amdgpu_asic_get_xclk(adev) / 100;\n\n\tif (ni_pi->enable_cac == false)\n\t\treturn 0;\n\n\tcac_tables = kzalloc(sizeof(PP_SIslands_CacConfig), GFP_KERNEL);\n\tif (!cac_tables)\n\t\treturn -ENOMEM;\n\n\treg = RREG32(CG_CAC_CTRL) & ~CAC_WINDOW_MASK;\n\treg |= CAC_WINDOW(si_pi->powertune_data->cac_window);\n\tWREG32(CG_CAC_CTRL, reg);\n\n\tsi_pi->dyn_powertune_data.cac_leakage = adev->pm.dpm.cac_leakage;\n\tsi_pi->dyn_powertune_data.dc_pwr_value =\n\t\tsi_pi->powertune_data->dc_cac[NISLANDS_DCCAC_LEVEL_0];\n\tsi_pi->dyn_powertune_data.wintime = si_calculate_cac_wintime(adev);\n\tsi_pi->dyn_powertune_data.shift_n = si_pi->powertune_data->shift_n_default;\n\n\tsi_pi->dyn_powertune_data.leakage_minimum_temperature = 80 * 1000;\n\n\tret = si_get_cac_std_voltage_max_min(adev, &vddc_max, &vddc_min);\n\tif (ret)\n\t\tgoto done_free;\n\n\tvddc_step = si_get_cac_std_voltage_step(vddc_max, vddc_min);\n\tvddc_min = vddc_max - (vddc_step * (SMC_SISLANDS_LKGE_LUT_NUM_OF_VOLT_ENTRIES - 1));\n\tt_step = 4;\n\tt0 = 60;\n\n\tif (si_pi->enable_dte || ni_pi->driver_calculate_cac_leakage)\n\t\tret = si_init_dte_leakage_table(adev, cac_tables,\n\t\t\t\t\t\tvddc_max, vddc_min, vddc_step,\n\t\t\t\t\t\tt0, t_step);\n\telse\n\t\tret = si_init_simplified_leakage_table(adev, cac_tables,\n\t\t\t\t\t\t       vddc_max, vddc_min, vddc_step);\n\tif (ret)\n\t\tgoto done_free;\n\n\tload_line_slope = ((u32)adev->pm.dpm.load_line_slope << SMC_SISLANDS_SCALE_R) / 100;\n\n\tcac_tables->l2numWin_TDP = cpu_to_be32(si_pi->dyn_powertune_data.l2_lta_window_size);\n\tcac_tables->lts_truncate_n = si_pi->dyn_powertune_data.lts_truncate;\n\tcac_tables->SHIFT_N = si_pi->dyn_powertune_data.shift_n;\n\tcac_tables->lkge_lut_V0 = cpu_to_be32((u32)vddc_min);\n\tcac_tables->lkge_lut_Vstep = cpu_to_be32((u32)vddc_step);\n\tcac_tables->R_LL = cpu_to_be32(load_line_slope);\n\tcac_tables->WinTime = cpu_to_be32(si_pi->dyn_powertune_data.wintime);\n\tcac_tables->calculation_repeats = cpu_to_be32(2);\n\tcac_tables->dc_cac = cpu_to_be32(0);\n\tcac_tables->log2_PG_LKG_SCALE = 12;\n\tcac_tables->cac_temp = si_pi->powertune_data->operating_temp;\n\tcac_tables->lkge_lut_T0 = cpu_to_be32((u32)t0);\n\tcac_tables->lkge_lut_Tstep = cpu_to_be32((u32)t_step);\n\n\tret = amdgpu_si_copy_bytes_to_smc(adev, si_pi->cac_table_start,\n\t\t\t\t\t  (u8 *)cac_tables,\n\t\t\t\t\t  sizeof(PP_SIslands_CacConfig),\n\t\t\t\t\t  si_pi->sram_end);\n\n\tif (ret)\n\t\tgoto done_free;\n\n\tret = si_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_ticks_per_us, ticks_per_us);\n\ndone_free:\n\tif (ret) {\n\t\tni_pi->enable_cac = false;\n\t\tni_pi->enable_power_containment = false;\n\t}\n\n\tkfree(cac_tables);\n\n\treturn ret;\n}\n\nstatic int si_program_cac_config_registers(struct amdgpu_device *adev,\n\t\t\t\t\t   const struct si_cac_config_reg *cac_config_regs)\n{\n\tconst struct si_cac_config_reg *config_regs = cac_config_regs;\n\tu32 data = 0, offset;\n\n\tif (!config_regs)\n\t\treturn -EINVAL;\n\n\twhile (config_regs->offset != 0xFFFFFFFF) {\n\t\tswitch (config_regs->type) {\n\t\tcase SISLANDS_CACCONFIG_CGIND:\n\t\t\toffset = SMC_CG_IND_START + config_regs->offset;\n\t\t\tif (offset < SMC_CG_IND_END)\n\t\t\t\tdata = RREG32_SMC(offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata = RREG32(config_regs->offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata &= ~config_regs->mask;\n\t\tdata |= ((config_regs->value << config_regs->shift) & config_regs->mask);\n\n\t\tswitch (config_regs->type) {\n\t\tcase SISLANDS_CACCONFIG_CGIND:\n\t\t\toffset = SMC_CG_IND_START + config_regs->offset;\n\t\t\tif (offset < SMC_CG_IND_END)\n\t\t\t\tWREG32_SMC(offset, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWREG32(config_regs->offset, data);\n\t\t\tbreak;\n\t\t}\n\t\tconfig_regs++;\n\t}\n\treturn 0;\n}\n\nstatic int si_initialize_hardware_cac_manager(struct amdgpu_device *adev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint ret;\n\n\tif ((ni_pi->enable_cac == false) ||\n\t    (ni_pi->cac_configuration_required == false))\n\t\treturn 0;\n\n\tret = si_program_cac_config_registers(adev, si_pi->lcac_config);\n\tif (ret)\n\t\treturn ret;\n\tret = si_program_cac_config_registers(adev, si_pi->cac_override);\n\tif (ret)\n\t\treturn ret;\n\tret = si_program_cac_config_registers(adev, si_pi->cac_weights);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int si_enable_smc_cac(struct amdgpu_device *adev,\n\t\t\t     struct amdgpu_ps *amdgpu_new_state,\n\t\t\t     bool enable)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tPPSMC_Result smc_result;\n\tint ret = 0;\n\n\tif (ni_pi->enable_cac) {\n\t\tif (enable) {\n\t\t\tif (!si_should_disable_uvd_powertune(adev, amdgpu_new_state)) {\n\t\t\t\tif (ni_pi->support_cac_long_term_average) {\n\t\t\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_CACLongTermAvgEnable);\n\t\t\t\t\tif (smc_result != PPSMC_Result_OK)\n\t\t\t\t\t\tni_pi->support_cac_long_term_average = false;\n\t\t\t\t}\n\n\t\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_EnableCac);\n\t\t\t\tif (smc_result != PPSMC_Result_OK) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tni_pi->cac_enabled = false;\n\t\t\t\t} else {\n\t\t\t\t\tni_pi->cac_enabled = true;\n\t\t\t\t}\n\n\t\t\t\tif (si_pi->enable_dte) {\n\t\t\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_EnableDTE);\n\t\t\t\t\tif (smc_result != PPSMC_Result_OK)\n\t\t\t\t\t\tret = -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ni_pi->cac_enabled) {\n\t\t\tif (si_pi->enable_dte)\n\t\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_DisableDTE);\n\n\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_DisableCac);\n\n\t\t\tni_pi->cac_enabled = false;\n\n\t\t\tif (ni_pi->support_cac_long_term_average)\n\t\t\t\tsmc_result = amdgpu_si_send_msg_to_smc(adev, PPSMC_CACLongTermAvgDisable);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int si_init_smc_spll_table(struct amdgpu_device *adev)\n{\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tSMC_SISLANDS_SPLL_DIV_TABLE *spll_table;\n\tSISLANDS_SMC_SCLK_VALUE sclk_params;\n\tu32 fb_div, p_div;\n\tu32 clk_s, clk_v;\n\tu32 sclk = 0;\n\tint ret = 0;\n\tu32 tmp;\n\tint i;\n\n\tif (si_pi->spll_table_start == 0)\n\t\treturn -EINVAL;\n\n\tspll_table = kzalloc(sizeof(SMC_SISLANDS_SPLL_DIV_TABLE), GFP_KERNEL);\n\tif (spll_table == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tret = si_calculate_sclk_params(adev, sclk, &sclk_params);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tp_div = (sclk_params.vCG_SPLL_FUNC_CNTL & SPLL_PDIV_A_MASK) >> SPLL_PDIV_A_SHIFT;\n\t\tfb_div = (sclk_params.vCG_SPLL_FUNC_CNTL_3 & SPLL_FB_DIV_MASK) >> SPLL_FB_DIV_SHIFT;\n\t\tclk_s = (sclk_params.vCG_SPLL_SPREAD_SPECTRUM & CLK_S_MASK) >> CLK_S_SHIFT;\n\t\tclk_v = (sclk_params.vCG_SPLL_SPREAD_SPECTRUM_2 & CLK_V_MASK) >> CLK_V_SHIFT;\n\n\t\tfb_div &= ~0x00001FFF;\n\t\tfb_div >>= 1;\n\t\tclk_v >>= 6;\n\n\t\tif (p_div & ~(SMC_SISLANDS_SPLL_DIV_TABLE_PDIV_MASK >> SMC_SISLANDS_SPLL_DIV_TABLE_PDIV_SHIFT))\n\t\t\tret = -EINVAL;\n\t\tif (fb_div & ~(SMC_SISLANDS_SPLL_DIV_TABLE_FBDIV_MASK >> SMC_SISLANDS_SPLL_DIV_TABLE_FBDIV_SHIFT))\n\t\t\tret = -EINVAL;\n\t\tif (clk_s & ~(SMC_SISLANDS_SPLL_DIV_TABLE_CLKS_MASK >> SMC_SISLANDS_SPLL_DIV_TABLE_CLKS_SHIFT))\n\t\t\tret = -EINVAL;\n\t\tif (clk_v & ~(SMC_SISLANDS_SPLL_DIV_TABLE_CLKV_MASK >> SMC_SISLANDS_SPLL_DIV_TABLE_CLKV_SHIFT))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\ttmp = ((fb_div << SMC_SISLANDS_SPLL_DIV_TABLE_FBDIV_SHIFT) & SMC_SISLANDS_SPLL_DIV_TABLE_FBDIV_MASK) |\n\t\t\t((p_div << SMC_SISLANDS_SPLL_DIV_TABLE_PDIV_SHIFT) & SMC_SISLANDS_SPLL_DIV_TABLE_PDIV_MASK);\n\t\tspll_table->freq[i] = cpu_to_be32(tmp);\n\n\t\ttmp = ((clk_v << SMC_SISLANDS_SPLL_DIV_TABLE_CLKV_SHIFT) & SMC_SISLANDS_SPLL_DIV_TABLE_CLKV_MASK) |\n\t\t\t((clk_s << SMC_SISLANDS_SPLL_DIV_TABLE_CLKS_SHIFT) & SMC_SISLANDS_SPLL_DIV_TABLE_CLKS_MASK);\n\t\tspll_table->ss[i] = cpu_to_be32(tmp);\n\n\t\tsclk += 512;\n\t}\n\n\n\tif (!ret)\n\t\tret = amdgpu_si_copy_bytes_to_smc(adev, si_pi->spll_table_start,\n\t\t\t\t\t\t  (u8 *)spll_table,\n\t\t\t\t\t\t  sizeof(SMC_SISLANDS_SPLL_DIV_TABLE),\n\t\t\t\t\t\t  si_pi->sram_end);\n\n\tif (ret)\n\t\tni_pi->enable_power_containment = false;\n\n\tkfree(spll_table);\n\n\treturn ret;\n}\n\nstatic u16 si_get_lower_of_leakage_and_vce_voltage(struct amdgpu_device *adev,\n\t\t\t\t\t\t   u16 vce_voltage)\n{\n\tu16 highest_leakage = 0;\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint i;\n\n\tfor (i = 0; i < si_pi->leakage_voltage.count; i++){\n\t\tif (highest_leakage < si_pi->leakage_voltage.entries[i].voltage)\n\t\t\thighest_leakage = si_pi->leakage_voltage.entries[i].voltage;\n\t}\n\n\tif (si_pi->leakage_voltage.count && (highest_leakage < vce_voltage))\n\t\treturn highest_leakage;\n\n\treturn vce_voltage;\n}\n\nstatic int si_get_vce_clock_voltage(struct amdgpu_device *adev,\n\t\t\t\t    u32 evclk, u32 ecclk, u16 *voltage)\n{\n\tu32 i;\n\tint ret = -EINVAL;\n\tstruct amdgpu_vce_clock_voltage_dependency_table *table =\n\t\t&adev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\n\n\tif (((evclk == 0) && (ecclk == 0)) ||\n\t    (table && (table->count == 0))) {\n\t\t*voltage = 0;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif ((evclk <= table->entries[i].evclk) &&\n\t\t    (ecclk <= table->entries[i].ecclk)) {\n\t\t\t*voltage = table->entries[i].v;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ret)\n\t\t*voltage = table->entries[table->count - 1].v;\n\n\t*voltage = si_get_lower_of_leakage_and_vce_voltage(adev, *voltage);\n\n\treturn ret;\n}\n\nstatic bool si_dpm_vblank_too_short(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tu32 vblank_time = amdgpu_dpm_get_vblank_time(adev);\n\t \n\tu32 switch_limit = adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5 ? 450 : 0;\n\n\tif (vblank_time < switch_limit)\n\t\treturn true;\n\telse\n\t\treturn false;\n\n}\n\nstatic int ni_copy_and_switch_arb_sets(struct amdgpu_device *adev,\n\t\t\t\tu32 arb_freq_src, u32 arb_freq_dest)\n{\n\tu32 mc_arb_dram_timing;\n\tu32 mc_arb_dram_timing2;\n\tu32 burst_time;\n\tu32 mc_cg_config;\n\n\tswitch (arb_freq_src) {\n\tcase MC_CG_ARB_FREQ_F0:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE0_MASK) >> STATE0_SHIFT;\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F1:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_1);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_1);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE1_MASK) >> STATE1_SHIFT;\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F2:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_2);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_2);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE2_MASK) >> STATE2_SHIFT;\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F3:\n\t\tmc_arb_dram_timing  = RREG32(MC_ARB_DRAM_TIMING_3);\n\t\tmc_arb_dram_timing2 = RREG32(MC_ARB_DRAM_TIMING2_3);\n\t\tburst_time = (RREG32(MC_ARB_BURST_TIME) & STATE3_MASK) >> STATE3_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (arb_freq_dest) {\n\tcase MC_CG_ARB_FREQ_F0:\n\t\tWREG32(MC_ARB_DRAM_TIMING, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE0(burst_time), ~STATE0_MASK);\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F1:\n\t\tWREG32(MC_ARB_DRAM_TIMING_1, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2_1, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE1(burst_time), ~STATE1_MASK);\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F2:\n\t\tWREG32(MC_ARB_DRAM_TIMING_2, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2_2, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE2(burst_time), ~STATE2_MASK);\n\t\tbreak;\n\tcase MC_CG_ARB_FREQ_F3:\n\t\tWREG32(MC_ARB_DRAM_TIMING_3, mc_arb_dram_timing);\n\t\tWREG32(MC_ARB_DRAM_TIMING2_3, mc_arb_dram_timing2);\n\t\tWREG32_P(MC_ARB_BURST_TIME, STATE3(burst_time), ~STATE3_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmc_cg_config = RREG32(MC_CG_CONFIG) | 0x0000000F;\n\tWREG32(MC_CG_CONFIG, mc_cg_config);\n\tWREG32_P(MC_ARB_CG, CG_ARB_REQ(arb_freq_dest), ~CG_ARB_REQ_MASK);\n\n\treturn 0;\n}\n\nstatic void ni_update_current_ps(struct amdgpu_device *adev,\n\t\t\t  struct amdgpu_ps *rps)\n{\n\tstruct si_ps *new_ps = si_get_ps(rps);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\n\teg_pi->current_rps = *rps;\n\tni_pi->current_ps = *new_ps;\n\teg_pi->current_rps.ps_priv = &ni_pi->current_ps;\n\tadev->pm.dpm.current_ps = &eg_pi->current_rps;\n}\n\nstatic void ni_update_requested_ps(struct amdgpu_device *adev,\n\t\t\t    struct amdgpu_ps *rps)\n{\n\tstruct si_ps *new_ps = si_get_ps(rps);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\n\teg_pi->requested_rps = *rps;\n\tni_pi->requested_ps = *new_ps;\n\teg_pi->requested_rps.ps_priv = &ni_pi->requested_ps;\n\tadev->pm.dpm.requested_ps = &eg_pi->requested_rps;\n}\n\nstatic void ni_set_uvd_clock_before_set_eng_clock(struct amdgpu_device *adev,\n\t\t\t\t\t   struct amdgpu_ps *new_ps,\n\t\t\t\t\t   struct amdgpu_ps *old_ps)\n{\n\tstruct si_ps *new_state = si_get_ps(new_ps);\n\tstruct si_ps *current_state = si_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->performance_levels[new_state->performance_level_count - 1].sclk >=\n\t    current_state->performance_levels[current_state->performance_level_count - 1].sclk)\n\t\treturn;\n\n\tamdgpu_asic_set_uvd_clocks(adev, new_ps->vclk, new_ps->dclk);\n}\n\nstatic void ni_set_uvd_clock_after_set_eng_clock(struct amdgpu_device *adev,\n\t\t\t\t\t  struct amdgpu_ps *new_ps,\n\t\t\t\t\t  struct amdgpu_ps *old_ps)\n{\n\tstruct si_ps *new_state = si_get_ps(new_ps);\n\tstruct si_ps *current_state = si_get_ps(old_ps);\n\n\tif ((new_ps->vclk == old_ps->vclk) &&\n\t    (new_ps->dclk == old_ps->dclk))\n\t\treturn;\n\n\tif (new_state->performance_levels[new_state->performance_level_count - 1].sclk <\n\t    current_state->performance_levels[current_state->performance_level_count - 1].sclk)\n\t\treturn;\n\n\tamdgpu_asic_set_uvd_clocks(adev, new_ps->vclk, new_ps->dclk);\n}\n\nstatic u16 btc_find_voltage(struct atom_voltage_table *table, u16 voltage)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table->count; i++)\n\t\tif (voltage <= table->entries[i].value)\n\t\t\treturn table->entries[i].value;\n\n\treturn table->entries[table->count - 1].value;\n}\n\nstatic u32 btc_find_valid_clock(struct amdgpu_clock_array *clocks,\n\t\t                u32 max_clock, u32 requested_clock)\n{\n\tunsigned int i;\n\n\tif ((clocks == NULL) || (clocks->count == 0))\n\t\treturn (requested_clock < max_clock) ? requested_clock : max_clock;\n\n\tfor (i = 0; i < clocks->count; i++) {\n\t\tif (clocks->values[i] >= requested_clock)\n\t\t\treturn (clocks->values[i] < max_clock) ? clocks->values[i] : max_clock;\n\t}\n\n\treturn (clocks->values[clocks->count - 1] < max_clock) ?\n\t\tclocks->values[clocks->count - 1] : max_clock;\n}\n\nstatic u32 btc_get_valid_mclk(struct amdgpu_device *adev,\n\t\t\t      u32 max_mclk, u32 requested_mclk)\n{\n\treturn btc_find_valid_clock(&adev->pm.dpm.dyn_state.valid_mclk_values,\n\t\t\t\t    max_mclk, requested_mclk);\n}\n\nstatic u32 btc_get_valid_sclk(struct amdgpu_device *adev,\n\t\t              u32 max_sclk, u32 requested_sclk)\n{\n\treturn btc_find_valid_clock(&adev->pm.dpm.dyn_state.valid_sclk_values,\n\t\t\t\t    max_sclk, requested_sclk);\n}\n\nstatic void btc_get_max_clock_from_voltage_dependency_table(struct amdgpu_clock_voltage_dependency_table *table,\n\t\t\t\t\t\t\t    u32 *max_clock)\n{\n\tu32 i, clock = 0;\n\n\tif ((table == NULL) || (table->count == 0)) {\n\t\t*max_clock = clock;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (clock < table->entries[i].clk)\n\t\t\tclock = table->entries[i].clk;\n\t}\n\t*max_clock = clock;\n}\n\nstatic void btc_apply_voltage_dependency_rules(struct amdgpu_clock_voltage_dependency_table *table,\n\t\t\t\t\t       u32 clock, u16 max_voltage, u16 *voltage)\n{\n\tu32 i;\n\n\tif ((table == NULL) || (table->count == 0))\n\t\treturn;\n\n\tfor (i= 0; i < table->count; i++) {\n\t\tif (clock <= table->entries[i].clk) {\n\t\t\tif (*voltage < table->entries[i].v)\n\t\t\t\t*voltage = (u16)((table->entries[i].v < max_voltage) ?\n\t\t\t\t\t   table->entries[i].v : max_voltage);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t*voltage = (*voltage > max_voltage) ? *voltage : max_voltage;\n}\n\nstatic void btc_adjust_clock_combinations(struct amdgpu_device *adev,\n\t\t\t\t\t  const struct amdgpu_clock_and_voltage_limits *max_limits,\n\t\t\t\t\t  struct rv7xx_pl *pl)\n{\n\n\tif ((pl->mclk == 0) || (pl->sclk == 0))\n\t\treturn;\n\n\tif (pl->mclk == pl->sclk)\n\t\treturn;\n\n\tif (pl->mclk > pl->sclk) {\n\t\tif (((pl->mclk + (pl->sclk - 1)) / pl->sclk) > adev->pm.dpm.dyn_state.mclk_sclk_ratio)\n\t\t\tpl->sclk = btc_get_valid_sclk(adev,\n\t\t\t\t\t\t      max_limits->sclk,\n\t\t\t\t\t\t      (pl->mclk +\n\t\t\t\t\t\t      (adev->pm.dpm.dyn_state.mclk_sclk_ratio - 1)) /\n\t\t\t\t\t\t      adev->pm.dpm.dyn_state.mclk_sclk_ratio);\n\t} else {\n\t\tif ((pl->sclk - pl->mclk) > adev->pm.dpm.dyn_state.sclk_mclk_delta)\n\t\t\tpl->mclk = btc_get_valid_mclk(adev,\n\t\t\t\t\t\t      max_limits->mclk,\n\t\t\t\t\t\t      pl->sclk -\n\t\t\t\t\t\t      adev->pm.dpm.dyn_state.sclk_mclk_delta);\n\t}\n}\n\nstatic void btc_apply_voltage_delta_rules(struct amdgpu_device *adev,\n\t\t\t\t\t  u16 max_vddc, u16 max_vddci,\n\t\t\t\t\t  u16 *vddc, u16 *vddci)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tu16 new_voltage;\n\n\tif ((0 == *vddc) || (0 == *vddci))\n\t\treturn;\n\n\tif (*vddc > *vddci) {\n\t\tif ((*vddc - *vddci) > adev->pm.dpm.dyn_state.vddc_vddci_delta) {\n\t\t\tnew_voltage = btc_find_voltage(&eg_pi->vddci_voltage_table,\n\t\t\t\t\t\t       (*vddc - adev->pm.dpm.dyn_state.vddc_vddci_delta));\n\t\t\t*vddci = (new_voltage < max_vddci) ? new_voltage : max_vddci;\n\t\t}\n\t} else {\n\t\tif ((*vddci - *vddc) > adev->pm.dpm.dyn_state.vddc_vddci_delta) {\n\t\t\tnew_voltage = btc_find_voltage(&eg_pi->vddc_voltage_table,\n\t\t\t\t\t\t       (*vddci - adev->pm.dpm.dyn_state.vddc_vddci_delta));\n\t\t\t*vddc = (new_voltage < max_vddc) ? new_voltage : max_vddc;\n\t\t}\n\t}\n}\n\nstatic void r600_calculate_u_and_p(u32 i, u32 r_c, u32 p_b,\n\t\t\t    u32 *p, u32 *u)\n{\n\tu32 b_c = 0;\n\tu32 i_c;\n\tu32 tmp;\n\n\ti_c = (i * r_c) / 100;\n\ttmp = i_c >> p_b;\n\n\twhile (tmp) {\n\t\tb_c++;\n\t\ttmp >>= 1;\n\t}\n\n\t*u = (b_c + 1) / 2;\n\t*p = i_c / (1 << (2 * (*u)));\n}\n\nstatic int r600_calculate_at(u32 t, u32 h, u32 fh, u32 fl, u32 *tl, u32 *th)\n{\n\tu32 k, a, ah, al;\n\tu32 t1;\n\n\tif ((fl == 0) || (fh == 0) || (fl > fh))\n\t\treturn -EINVAL;\n\n\tk = (100 * fh) / fl;\n\tt1 = (t * (k - 100));\n\ta = (1000 * (100 * h + t1)) / (10000 + (t1 / 100));\n\ta = (a + 5) / 10;\n\tah = ((a * t) + 5000) / 10000;\n\tal = a - ah;\n\n\t*th = t - ah;\n\t*tl = t + al;\n\n\treturn 0;\n}\n\nstatic bool r600_is_uvd_state(u32 class, u32 class2)\n{\n\tif (class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\treturn true;\n\tif (class & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\n\t\treturn true;\n\tif (class & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\n\t\treturn true;\n\tif (class & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\n\t\treturn true;\n\tif (class2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\n\t\treturn true;\n\treturn false;\n}\n\nstatic u8 rv770_get_memory_module_index(struct amdgpu_device *adev)\n{\n\treturn (u8) ((RREG32(BIOS_SCRATCH_4) >> 16) & 0xff);\n}\n\nstatic void rv770_get_max_vddc(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tu16 vddc;\n\n\tif (amdgpu_atombios_get_max_vddc(adev, 0, 0, &vddc))\n\t\tpi->max_vddc = 0;\n\telse\n\t\tpi->max_vddc = vddc;\n}\n\nstatic void rv770_get_engine_memory_ss(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct amdgpu_atom_ss ss;\n\n\tpi->sclk_ss = amdgpu_atombios_get_asic_ss_info(adev, &ss,\n\t\t\t\t\t\t       ASIC_INTERNAL_ENGINE_SS, 0);\n\tpi->mclk_ss = amdgpu_atombios_get_asic_ss_info(adev, &ss,\n\t\t\t\t\t\t       ASIC_INTERNAL_MEMORY_SS, 0);\n\n\tif (pi->sclk_ss || pi->mclk_ss)\n\t\tpi->dynamic_ss = true;\n\telse\n\t\tpi->dynamic_ss = false;\n}\n\n\nstatic void si_apply_state_adjust_rules(struct amdgpu_device *adev,\n\t\t\t\t\tstruct amdgpu_ps *rps)\n{\n\tstruct  si_ps *ps = si_get_ps(rps);\n\tstruct amdgpu_clock_and_voltage_limits *max_limits;\n\tbool disable_mclk_switching = false;\n\tbool disable_sclk_switching = false;\n\tu32 mclk, sclk;\n\tu16 vddc, vddci, min_vce_voltage = 0;\n\tu32 max_sclk_vddc, max_mclk_vddci, max_mclk_vddc;\n\tu32 max_sclk = 0, max_mclk = 0;\n\tint i;\n\n\tif (adev->asic_type == CHIP_HAINAN) {\n\t\tif ((adev->pdev->revision == 0x81) ||\n\t\t    (adev->pdev->revision == 0xC3) ||\n\t\t    (adev->pdev->device == 0x6664) ||\n\t\t    (adev->pdev->device == 0x6665) ||\n\t\t    (adev->pdev->device == 0x6667)) {\n\t\t\tmax_sclk = 75000;\n\t\t}\n\t\tif ((adev->pdev->revision == 0xC3) ||\n\t\t    (adev->pdev->device == 0x6665)) {\n\t\t\tmax_sclk = 60000;\n\t\t\tmax_mclk = 80000;\n\t\t}\n\t} else if (adev->asic_type == CHIP_OLAND) {\n\t\tif ((adev->pdev->revision == 0xC7) ||\n\t\t    (adev->pdev->revision == 0x80) ||\n\t\t    (adev->pdev->revision == 0x81) ||\n\t\t    (adev->pdev->revision == 0x83) ||\n\t\t    (adev->pdev->revision == 0x87) ||\n\t\t    (adev->pdev->device == 0x6604) ||\n\t\t    (adev->pdev->device == 0x6605)) {\n\t\t\tmax_sclk = 75000;\n\t\t}\n\t}\n\n\tif (rps->vce_active) {\n\t\trps->evclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].evclk;\n\t\trps->ecclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].ecclk;\n\t\tsi_get_vce_clock_voltage(adev, rps->evclk, rps->ecclk,\n\t\t\t\t\t &min_vce_voltage);\n\t} else {\n\t\trps->evclk = 0;\n\t\trps->ecclk = 0;\n\t}\n\n\tif ((adev->pm.dpm.new_active_crtc_count > 1) ||\n\t    si_dpm_vblank_too_short(adev))\n\t\tdisable_mclk_switching = true;\n\n\tif (rps->vclk || rps->dclk) {\n\t\tdisable_mclk_switching = true;\n\t\tdisable_sclk_switching = true;\n\t}\n\n\tif (adev->pm.ac_power)\n\t\tmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\n\telse\n\t\tmax_limits = &adev->pm.dpm.dyn_state.max_clock_voltage_on_dc;\n\n\tfor (i = ps->performance_level_count - 2; i >= 0; i--) {\n\t\tif (ps->performance_levels[i].vddc > ps->performance_levels[i+1].vddc)\n\t\t\tps->performance_levels[i].vddc = ps->performance_levels[i+1].vddc;\n\t}\n\tif (adev->pm.ac_power == false) {\n\t\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\t\tif (ps->performance_levels[i].mclk > max_limits->mclk)\n\t\t\t\tps->performance_levels[i].mclk = max_limits->mclk;\n\t\t\tif (ps->performance_levels[i].sclk > max_limits->sclk)\n\t\t\t\tps->performance_levels[i].sclk = max_limits->sclk;\n\t\t\tif (ps->performance_levels[i].vddc > max_limits->vddc)\n\t\t\t\tps->performance_levels[i].vddc = max_limits->vddc;\n\t\t\tif (ps->performance_levels[i].vddci > max_limits->vddci)\n\t\t\t\tps->performance_levels[i].vddci = max_limits->vddci;\n\t\t}\n\t}\n\n\t \n\tbtc_get_max_clock_from_voltage_dependency_table(&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\n\t\t\t\t\t\t\t&max_sclk_vddc);\n\tbtc_get_max_clock_from_voltage_dependency_table(&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\n\t\t\t\t\t\t\t&max_mclk_vddci);\n\tbtc_get_max_clock_from_voltage_dependency_table(&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\n\t\t\t\t\t\t\t&max_mclk_vddc);\n\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tif (max_sclk_vddc) {\n\t\t\tif (ps->performance_levels[i].sclk > max_sclk_vddc)\n\t\t\t\tps->performance_levels[i].sclk = max_sclk_vddc;\n\t\t}\n\t\tif (max_mclk_vddci) {\n\t\t\tif (ps->performance_levels[i].mclk > max_mclk_vddci)\n\t\t\t\tps->performance_levels[i].mclk = max_mclk_vddci;\n\t\t}\n\t\tif (max_mclk_vddc) {\n\t\t\tif (ps->performance_levels[i].mclk > max_mclk_vddc)\n\t\t\t\tps->performance_levels[i].mclk = max_mclk_vddc;\n\t\t}\n\t\tif (max_mclk) {\n\t\t\tif (ps->performance_levels[i].mclk > max_mclk)\n\t\t\t\tps->performance_levels[i].mclk = max_mclk;\n\t\t}\n\t\tif (max_sclk) {\n\t\t\tif (ps->performance_levels[i].sclk > max_sclk)\n\t\t\t\tps->performance_levels[i].sclk = max_sclk;\n\t\t}\n\t}\n\n\t \n\n\tif (disable_mclk_switching) {\n\t\tmclk  = ps->performance_levels[ps->performance_level_count - 1].mclk;\n\t\tvddci = ps->performance_levels[ps->performance_level_count - 1].vddci;\n\t} else {\n\t\tmclk = ps->performance_levels[0].mclk;\n\t\tvddci = ps->performance_levels[0].vddci;\n\t}\n\n\tif (disable_sclk_switching) {\n\t\tsclk = ps->performance_levels[ps->performance_level_count - 1].sclk;\n\t\tvddc = ps->performance_levels[ps->performance_level_count - 1].vddc;\n\t} else {\n\t\tsclk = ps->performance_levels[0].sclk;\n\t\tvddc = ps->performance_levels[0].vddc;\n\t}\n\n\tif (rps->vce_active) {\n\t\tif (sclk < adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].sclk)\n\t\t\tsclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].sclk;\n\t\tif (mclk < adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].mclk)\n\t\t\tmclk = adev->pm.dpm.vce_states[adev->pm.dpm.vce_level].mclk;\n\t}\n\n\t \n\tps->performance_levels[0].sclk = sclk;\n\tps->performance_levels[0].mclk = mclk;\n\tps->performance_levels[0].vddc = vddc;\n\tps->performance_levels[0].vddci = vddci;\n\n\tif (disable_sclk_switching) {\n\t\tsclk = ps->performance_levels[0].sclk;\n\t\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\t\tif (sclk < ps->performance_levels[i].sclk)\n\t\t\t\tsclk = ps->performance_levels[i].sclk;\n\t\t}\n\t\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\t\tps->performance_levels[i].sclk = sclk;\n\t\t\tps->performance_levels[i].vddc = vddc;\n\t\t}\n\t} else {\n\t\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\t\tif (ps->performance_levels[i].sclk < ps->performance_levels[i - 1].sclk)\n\t\t\t\tps->performance_levels[i].sclk = ps->performance_levels[i - 1].sclk;\n\t\t\tif (ps->performance_levels[i].vddc < ps->performance_levels[i - 1].vddc)\n\t\t\t\tps->performance_levels[i].vddc = ps->performance_levels[i - 1].vddc;\n\t\t}\n\t}\n\n\tif (disable_mclk_switching) {\n\t\tmclk = ps->performance_levels[0].mclk;\n\t\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\t\tif (mclk < ps->performance_levels[i].mclk)\n\t\t\t\tmclk = ps->performance_levels[i].mclk;\n\t\t}\n\t\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\t\tps->performance_levels[i].mclk = mclk;\n\t\t\tps->performance_levels[i].vddci = vddci;\n\t\t}\n\t} else {\n\t\tfor (i = 1; i < ps->performance_level_count; i++) {\n\t\t\tif (ps->performance_levels[i].mclk < ps->performance_levels[i - 1].mclk)\n\t\t\t\tps->performance_levels[i].mclk = ps->performance_levels[i - 1].mclk;\n\t\t\tif (ps->performance_levels[i].vddci < ps->performance_levels[i - 1].vddci)\n\t\t\t\tps->performance_levels[i].vddci = ps->performance_levels[i - 1].vddci;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ps->performance_level_count; i++)\n\t\tbtc_adjust_clock_combinations(adev, max_limits,\n\t\t\t\t\t      &ps->performance_levels[i]);\n\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tif (ps->performance_levels[i].vddc < min_vce_voltage)\n\t\t\tps->performance_levels[i].vddc = min_vce_voltage;\n\t\tbtc_apply_voltage_dependency_rules(&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk,\n\t\t\t\t\t\t   ps->performance_levels[i].sclk,\n\t\t\t\t\t\t   max_limits->vddc,  &ps->performance_levels[i].vddc);\n\t\tbtc_apply_voltage_dependency_rules(&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\n\t\t\t\t\t\t   ps->performance_levels[i].mclk,\n\t\t\t\t\t\t   max_limits->vddci, &ps->performance_levels[i].vddci);\n\t\tbtc_apply_voltage_dependency_rules(&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\n\t\t\t\t\t\t   ps->performance_levels[i].mclk,\n\t\t\t\t\t\t   max_limits->vddc,  &ps->performance_levels[i].vddc);\n\t\tbtc_apply_voltage_dependency_rules(&adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk,\n\t\t\t\t\t\t   adev->clock.current_dispclk,\n\t\t\t\t\t\t   max_limits->vddc,  &ps->performance_levels[i].vddc);\n\t}\n\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tbtc_apply_voltage_delta_rules(adev,\n\t\t\t\t\t      max_limits->vddc, max_limits->vddci,\n\t\t\t\t\t      &ps->performance_levels[i].vddc,\n\t\t\t\t\t      &ps->performance_levels[i].vddci);\n\t}\n\n\tps->dc_compatible = true;\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tif (ps->performance_levels[i].vddc > adev->pm.dpm.dyn_state.max_clock_voltage_on_dc.vddc)\n\t\t\tps->dc_compatible = false;\n\t}\n}\n\n#if 0\nstatic int si_read_smc_soft_register(struct amdgpu_device *adev,\n\t\t\t\t     u16 reg_offset, u32 *value)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\treturn amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t     si_pi->soft_regs_start + reg_offset, value,\n\t\t\t\t\t     si_pi->sram_end);\n}\n#endif\n\nstatic int si_write_smc_soft_register(struct amdgpu_device *adev,\n\t\t\t\t      u16 reg_offset, u32 value)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\treturn amdgpu_si_write_smc_sram_dword(adev,\n\t\t\t\t\t      si_pi->soft_regs_start + reg_offset,\n\t\t\t\t\t      value, si_pi->sram_end);\n}\n\nstatic bool si_is_special_1gb_platform(struct amdgpu_device *adev)\n{\n\tbool ret = false;\n\tu32 tmp, width, row, column, bank, density;\n\tbool is_memory_gddr5, is_special;\n\n\ttmp = RREG32(MC_SEQ_MISC0);\n\tis_memory_gddr5 = (MC_SEQ_MISC0_GDDR5_VALUE == ((tmp & MC_SEQ_MISC0_GDDR5_MASK) >> MC_SEQ_MISC0_GDDR5_SHIFT));\n\tis_special = (MC_SEQ_MISC0_REV_ID_VALUE == ((tmp & MC_SEQ_MISC0_REV_ID_MASK) >> MC_SEQ_MISC0_REV_ID_SHIFT))\n\t\t& (MC_SEQ_MISC0_VEN_ID_VALUE == ((tmp & MC_SEQ_MISC0_VEN_ID_MASK) >> MC_SEQ_MISC0_VEN_ID_SHIFT));\n\n\tWREG32(MC_SEQ_IO_DEBUG_INDEX, 0xb);\n\twidth = ((RREG32(MC_SEQ_IO_DEBUG_DATA) >> 1) & 1) ? 16 : 32;\n\n\ttmp = RREG32(MC_ARB_RAMCFG);\n\trow = ((tmp & NOOFROWS_MASK) >> NOOFROWS_SHIFT) + 10;\n\tcolumn = ((tmp & NOOFCOLS_MASK) >> NOOFCOLS_SHIFT) + 8;\n\tbank = ((tmp & NOOFBANK_MASK) >> NOOFBANK_SHIFT) + 2;\n\n\tdensity = (1 << (row + column - 20 + bank)) * width;\n\n\tif ((adev->pdev->device == 0x6819) &&\n\t    is_memory_gddr5 && is_special && (density == 0x400))\n\t\tret = true;\n\n\treturn ret;\n}\n\nstatic void si_get_leakage_vddc(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu16 vddc, count = 0;\n\tint i, ret;\n\n\tfor (i = 0; i < SISLANDS_MAX_LEAKAGE_COUNT; i++) {\n\t\tret = amdgpu_atombios_get_leakage_vddc_based_on_leakage_idx(adev, &vddc, SISLANDS_LEAKAGE_INDEX0 + i);\n\n\t\tif (!ret && (vddc > 0) && (vddc != (SISLANDS_LEAKAGE_INDEX0 + i))) {\n\t\t\tsi_pi->leakage_voltage.entries[count].voltage = vddc;\n\t\t\tsi_pi->leakage_voltage.entries[count].leakage_index =\n\t\t\t\tSISLANDS_LEAKAGE_INDEX0 + i;\n\t\t\tcount++;\n\t\t}\n\t}\n\tsi_pi->leakage_voltage.count = count;\n}\n\nstatic int si_get_leakage_voltage_from_leakage_index(struct amdgpu_device *adev,\n\t\t\t\t\t\t     u32 index, u16 *leakage_voltage)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint i;\n\n\tif (leakage_voltage == NULL)\n\t\treturn -EINVAL;\n\n\tif ((index & 0xff00) != 0xff00)\n\t\treturn -EINVAL;\n\n\tif ((index & 0xff) > SISLANDS_MAX_LEAKAGE_COUNT + 1)\n\t\treturn -EINVAL;\n\n\tif (index < SISLANDS_LEAKAGE_INDEX0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < si_pi->leakage_voltage.count; i++) {\n\t\tif (si_pi->leakage_voltage.entries[i].leakage_index == index) {\n\t\t\t*leakage_voltage = si_pi->leakage_voltage.entries[i].voltage;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EAGAIN;\n}\n\nstatic void si_set_dpm_event_sources(struct amdgpu_device *adev, u32 sources)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tbool want_thermal_protection;\n\tenum si_dpm_event_src dpm_event_src;\n\n\tswitch (sources) {\n\tcase 0:\n\tdefault:\n\t\twant_thermal_protection = false;\n\t\tbreak;\n\tcase (1 << SI_DPM_AUTO_THROTTLE_SRC_THERMAL):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = SI_DPM_EVENT_SRC_DIGITAL;\n\t\tbreak;\n\tcase (1 << SI_DPM_AUTO_THROTTLE_SRC_EXTERNAL):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = SI_DPM_EVENT_SRC_EXTERNAL;\n\t\tbreak;\n\tcase ((1 << SI_DPM_AUTO_THROTTLE_SRC_EXTERNAL) |\n\t      (1 << SI_DPM_AUTO_THROTTLE_SRC_THERMAL)):\n\t\twant_thermal_protection = true;\n\t\tdpm_event_src = SI_DPM_EVENT_SRC_DIGIAL_OR_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (want_thermal_protection) {\n\t\tWREG32_P(CG_THERMAL_CTRL, DPM_EVENT_SRC(dpm_event_src), ~DPM_EVENT_SRC_MASK);\n\t\tif (pi->thermal_protection)\n\t\t\tWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\n\t} else {\n\t\tWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\n\t}\n}\n\nstatic void si_enable_auto_throttle_source(struct amdgpu_device *adev,\n\t\t\t\t\t   enum si_dpm_auto_throttle_src source,\n\t\t\t\t\t   bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\n\tif (enable) {\n\t\tif (!(pi->active_auto_throttle_sources & (1 << source))) {\n\t\t\tpi->active_auto_throttle_sources |= 1 << source;\n\t\t\tsi_set_dpm_event_sources(adev, pi->active_auto_throttle_sources);\n\t\t}\n\t} else {\n\t\tif (pi->active_auto_throttle_sources & (1 << source)) {\n\t\t\tpi->active_auto_throttle_sources &= ~(1 << source);\n\t\t\tsi_set_dpm_event_sources(adev, pi->active_auto_throttle_sources);\n\t\t}\n\t}\n}\n\nstatic void si_start_dpm(struct amdgpu_device *adev)\n{\n\tWREG32_P(GENERAL_PWRMGT, GLOBAL_PWRMGT_EN, ~GLOBAL_PWRMGT_EN);\n}\n\nstatic void si_stop_dpm(struct amdgpu_device *adev)\n{\n\tWREG32_P(GENERAL_PWRMGT, 0, ~GLOBAL_PWRMGT_EN);\n}\n\nstatic void si_enable_sclk_control(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~SCLK_PWRMGT_OFF);\n\telse\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, SCLK_PWRMGT_OFF, ~SCLK_PWRMGT_OFF);\n\n}\n\n#if 0\nstatic int si_notify_hardware_of_thermal_state(struct amdgpu_device *adev,\n\t\t\t\t\t       u32 thermal_level)\n{\n\tPPSMC_Result ret;\n\n\tif (thermal_level == 0) {\n\t\tret = amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_EnableThermalInterrupt);\n\t\tif (ret == PPSMC_Result_OK)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void si_notify_hardware_vpu_recovery_event(struct amdgpu_device *adev)\n{\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_tdr_is_about_to_happen, true);\n}\n#endif\n\n#if 0\nstatic int si_notify_hw_of_powersource(struct amdgpu_device *adev, bool ac_power)\n{\n\tif (ac_power)\n\t\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_RunningOnAC) == PPSMC_Result_OK) ?\n\t\t\t0 : -EINVAL;\n\n\treturn 0;\n}\n#endif\n\nstatic PPSMC_Result si_send_msg_to_smc_with_parameter(struct amdgpu_device *adev,\n\t\t\t\t\t\t      PPSMC_Msg msg, u32 parameter)\n{\n\tWREG32(SMC_SCRATCH0, parameter);\n\treturn amdgpu_si_send_msg_to_smc(adev, msg);\n}\n\nstatic int si_restrict_performance_levels_before_switch(struct amdgpu_device *adev)\n{\n\tif (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_NoForcedLevel) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetEnabledLevels, 1) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nstatic int si_dpm_force_performance_level(void *handle,\n\t\t\t\t   enum amd_dpm_forced_level level)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ps *rps = adev->pm.dpm.current_ps;\n\tstruct  si_ps *ps = si_get_ps(rps);\n\tu32 levels = ps->performance_level_count;\n\n\tif (level == AMD_DPM_FORCED_LEVEL_HIGH) {\n\t\tif (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetEnabledLevels, levels) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\n\t\tif (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetForcedLevels, 1) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_LOW) {\n\t\tif (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetForcedLevels, 0) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\n\t\tif (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetEnabledLevels, 1) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_AUTO) {\n\t\tif (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetForcedLevels, 0) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\n\t\tif (si_send_msg_to_smc_with_parameter(adev, PPSMC_MSG_SetEnabledLevels, levels) != PPSMC_Result_OK)\n\t\t\treturn -EINVAL;\n\t}\n\n\tadev->pm.dpm.forced_level = level;\n\n\treturn 0;\n}\n\n#if 0\nstatic int si_set_boot_state(struct amdgpu_device *adev)\n{\n\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_SwitchToInitialState) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n#endif\n\nstatic int si_set_sw_state(struct amdgpu_device *adev)\n{\n\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_SwitchToSwState) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nstatic int si_halt_smc(struct amdgpu_device *adev)\n{\n\tif (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_Halt) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn (amdgpu_si_wait_for_smc_inactive(adev) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nstatic int si_resume_smc(struct amdgpu_device *adev)\n{\n\tif (amdgpu_si_send_msg_to_smc(adev, PPSMC_FlushDataCache) != PPSMC_Result_OK)\n\t\treturn -EINVAL;\n\n\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_Resume) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nstatic void si_dpm_start_smc(struct amdgpu_device *adev)\n{\n\tamdgpu_si_program_jump_on_start(adev);\n\tamdgpu_si_start_smc(adev);\n\tamdgpu_si_smc_clock(adev, true);\n}\n\nstatic void si_dpm_stop_smc(struct amdgpu_device *adev)\n{\n\tamdgpu_si_reset_smc(adev);\n\tamdgpu_si_smc_clock(adev, false);\n}\n\nstatic int si_process_firmware_header(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\tint ret;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_stateTable,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->state_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_softRegisters,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->soft_regs_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_mcRegisterTable,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->mc_reg_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_fanTable,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->fan_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_mcArbDramAutoRefreshTable,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->arb_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_CacConfigTable,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->cac_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_DteConfiguration,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->dte_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_spllTable,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->spll_table_start = tmp;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev,\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_LOCATION +\n\t\t\t\t\t    SISLANDS_SMC_FIRMWARE_HEADER_PAPMParameters,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_pi->papm_cfg_table_start = tmp;\n\n\treturn ret;\n}\n\nstatic void si_read_clock_registers(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tsi_pi->clock_registers.cg_spll_func_cntl = RREG32(CG_SPLL_FUNC_CNTL);\n\tsi_pi->clock_registers.cg_spll_func_cntl_2 = RREG32(CG_SPLL_FUNC_CNTL_2);\n\tsi_pi->clock_registers.cg_spll_func_cntl_3 = RREG32(CG_SPLL_FUNC_CNTL_3);\n\tsi_pi->clock_registers.cg_spll_func_cntl_4 = RREG32(CG_SPLL_FUNC_CNTL_4);\n\tsi_pi->clock_registers.cg_spll_spread_spectrum = RREG32(CG_SPLL_SPREAD_SPECTRUM);\n\tsi_pi->clock_registers.cg_spll_spread_spectrum_2 = RREG32(CG_SPLL_SPREAD_SPECTRUM_2);\n\tsi_pi->clock_registers.dll_cntl = RREG32(DLL_CNTL);\n\tsi_pi->clock_registers.mclk_pwrmgt_cntl = RREG32(MCLK_PWRMGT_CNTL);\n\tsi_pi->clock_registers.mpll_ad_func_cntl = RREG32(MPLL_AD_FUNC_CNTL);\n\tsi_pi->clock_registers.mpll_dq_func_cntl = RREG32(MPLL_DQ_FUNC_CNTL);\n\tsi_pi->clock_registers.mpll_func_cntl = RREG32(MPLL_FUNC_CNTL);\n\tsi_pi->clock_registers.mpll_func_cntl_1 = RREG32(MPLL_FUNC_CNTL_1);\n\tsi_pi->clock_registers.mpll_func_cntl_2 = RREG32(MPLL_FUNC_CNTL_2);\n\tsi_pi->clock_registers.mpll_ss1 = RREG32(MPLL_SS1);\n\tsi_pi->clock_registers.mpll_ss2 = RREG32(MPLL_SS2);\n}\n\nstatic void si_enable_thermal_protection(struct amdgpu_device *adev,\n\t\t\t\t\t  bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~THERMAL_PROTECTION_DIS);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, THERMAL_PROTECTION_DIS, ~THERMAL_PROTECTION_DIS);\n}\n\nstatic void si_enable_acpi_power_management(struct amdgpu_device *adev)\n{\n\tWREG32_P(GENERAL_PWRMGT, STATIC_PM_EN, ~STATIC_PM_EN);\n}\n\n#if 0\nstatic int si_enter_ulp_state(struct amdgpu_device *adev)\n{\n\tWREG32(SMC_MESSAGE_0, PPSMC_MSG_SwitchToMinimumPower);\n\n\tudelay(25000);\n\n\treturn 0;\n}\n\nstatic int si_exit_ulp_state(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tWREG32(SMC_MESSAGE_0, PPSMC_MSG_ResumeFromMinimumPower);\n\n\tudelay(7000);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tif (RREG32(SMC_RESP_0) == 1)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int si_notify_smc_display_change(struct amdgpu_device *adev,\n\t\t\t\t     bool has_display)\n{\n\tPPSMC_Msg msg = has_display ?\n\t\tPPSMC_MSG_HasDisplay : PPSMC_MSG_NoDisplay;\n\n\treturn (amdgpu_si_send_msg_to_smc(adev, msg) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nstatic void si_program_response_times(struct amdgpu_device *adev)\n{\n\tu32 voltage_response_time, acpi_delay_time, vbi_time_out;\n\tu32 vddc_dly, acpi_dly, vbi_dly;\n\tu32 reference_clock;\n\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_mvdd_chg_time, 1);\n\n\tvoltage_response_time = (u32)adev->pm.dpm.voltage_response_time;\n\n\tif (voltage_response_time == 0)\n\t\tvoltage_response_time = 1000;\n\n\tacpi_delay_time = 15000;\n\tvbi_time_out = 100000;\n\n\treference_clock = amdgpu_asic_get_xclk(adev);\n\n\tvddc_dly = (voltage_response_time  * reference_clock) / 100;\n\tacpi_dly = (acpi_delay_time * reference_clock) / 100;\n\tvbi_dly  = (vbi_time_out * reference_clock) / 100;\n\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_delay_vreg,  vddc_dly);\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_delay_acpi,  acpi_dly);\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_mclk_chg_timeout, vbi_dly);\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_mc_block_delay, 0xAA);\n}\n\nstatic void si_program_ds_registers(struct amdgpu_device *adev)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tu32 tmp;\n\n\t \n\tif (adev->asic_type == CHIP_TAHITI && adev->rev_id == 0x0)\n\t\ttmp = 0x10;\n\telse\n\t\ttmp = 0x1;\n\n\tif (eg_pi->sclk_deep_sleep) {\n\t\tWREG32_P(MISC_CLK_CNTL, DEEP_SLEEP_CLK_SEL(tmp), ~DEEP_SLEEP_CLK_SEL_MASK);\n\t\tWREG32_P(CG_SPLL_AUTOSCALE_CNTL, AUTOSCALE_ON_SS_CLEAR,\n\t\t\t ~AUTOSCALE_ON_SS_CLEAR);\n\t}\n}\n\nstatic void si_program_display_gap(struct amdgpu_device *adev)\n{\n\tu32 tmp, pipe;\n\tint i;\n\n\ttmp = RREG32(CG_DISPLAY_GAP_CNTL) & ~(DISP1_GAP_MASK | DISP2_GAP_MASK);\n\tif (adev->pm.dpm.new_active_crtc_count > 0)\n\t\ttmp |= DISP1_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\n\telse\n\t\ttmp |= DISP1_GAP(R600_PM_DISPLAY_GAP_IGNORE);\n\n\tif (adev->pm.dpm.new_active_crtc_count > 1)\n\t\ttmp |= DISP2_GAP(R600_PM_DISPLAY_GAP_VBLANK_OR_WM);\n\telse\n\t\ttmp |= DISP2_GAP(R600_PM_DISPLAY_GAP_IGNORE);\n\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n\n\ttmp = RREG32(DCCG_DISP_SLOW_SELECT_REG);\n\tpipe = (tmp & DCCG_DISP1_SLOW_SELECT_MASK) >> DCCG_DISP1_SLOW_SELECT_SHIFT;\n\n\tif ((adev->pm.dpm.new_active_crtc_count > 0) &&\n\t    (!(adev->pm.dpm.new_active_crtcs & (1 << pipe)))) {\n\t\t \n\t\tfor (i = 0; i < adev->mode_info.num_crtc; i++) {\n\t\t\tif (adev->pm.dpm.new_active_crtcs & (1 << i))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == adev->mode_info.num_crtc)\n\t\t\tpipe = 0;\n\t\telse\n\t\t\tpipe = i;\n\n\t\ttmp &= ~DCCG_DISP1_SLOW_SELECT_MASK;\n\t\ttmp |= DCCG_DISP1_SLOW_SELECT(pipe);\n\t\tWREG32(DCCG_DISP_SLOW_SELECT_REG, tmp);\n\t}\n\n\t \n\tsi_notify_smc_display_change(adev, adev->pm.dpm.new_active_crtc_count > 0);\n}\n\nstatic void si_enable_spread_spectrum(struct amdgpu_device *adev, bool enable)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\n\tif (enable) {\n\t\tif (pi->sclk_ss)\n\t\t\tWREG32_P(GENERAL_PWRMGT, DYN_SPREAD_SPECTRUM_EN, ~DYN_SPREAD_SPECTRUM_EN);\n\t} else {\n\t\tWREG32_P(CG_SPLL_SPREAD_SPECTRUM, 0, ~SSEN);\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~DYN_SPREAD_SPECTRUM_EN);\n\t}\n}\n\nstatic void si_setup_bsp(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tu32 xclk = amdgpu_asic_get_xclk(adev);\n\n\tr600_calculate_u_and_p(pi->asi,\n\t\t\t       xclk,\n\t\t\t       16,\n\t\t\t       &pi->bsp,\n\t\t\t       &pi->bsu);\n\n\tr600_calculate_u_and_p(pi->pasi,\n\t\t\t       xclk,\n\t\t\t       16,\n\t\t\t       &pi->pbsp,\n\t\t\t       &pi->pbsu);\n\n\n        pi->dsp = BSP(pi->bsp) | BSU(pi->bsu);\n\tpi->psp = BSP(pi->pbsp) | BSU(pi->pbsu);\n\n\tWREG32(CG_BSP, pi->dsp);\n}\n\nstatic void si_program_git(struct amdgpu_device *adev)\n{\n\tWREG32_P(CG_GIT, CG_GICST(R600_GICST_DFLT), ~CG_GICST_MASK);\n}\n\nstatic void si_program_tp(struct amdgpu_device *adev)\n{\n\tint i;\n\tenum r600_td td = R600_TD_DFLT;\n\n\tfor (i = 0; i < R600_PM_NUMBER_OF_TC; i++)\n\t\tWREG32(CG_FFCT_0 + i, (UTC_0(r600_utc[i]) | DTC_0(r600_dtc[i])));\n\n\tif (td == R600_TD_AUTO)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_FORCE_TREND_SEL);\n\telse\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_FORCE_TREND_SEL, ~FIR_FORCE_TREND_SEL);\n\n\tif (td == R600_TD_UP)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, 0, ~FIR_TREND_MODE);\n\n\tif (td == R600_TD_DOWN)\n\t\tWREG32_P(SCLK_PWRMGT_CNTL, FIR_TREND_MODE, ~FIR_TREND_MODE);\n}\n\nstatic void si_program_tpp(struct amdgpu_device *adev)\n{\n\tWREG32(CG_TPC, R600_TPC_DFLT);\n}\n\nstatic void si_program_sstp(struct amdgpu_device *adev)\n{\n\tWREG32(CG_SSP, (SSTU(R600_SSTU_DFLT) | SST(R600_SST_DFLT)));\n}\n\nstatic void si_enable_display_gap(struct amdgpu_device *adev)\n{\n\tu32 tmp = RREG32(CG_DISPLAY_GAP_CNTL);\n\n\ttmp &= ~(DISP1_GAP_MASK | DISP2_GAP_MASK);\n\ttmp |= (DISP1_GAP(R600_PM_DISPLAY_GAP_IGNORE) |\n\t\tDISP2_GAP(R600_PM_DISPLAY_GAP_IGNORE));\n\n\ttmp &= ~(DISP1_GAP_MCHG_MASK | DISP2_GAP_MCHG_MASK);\n\ttmp |= (DISP1_GAP_MCHG(R600_PM_DISPLAY_GAP_VBLANK) |\n\t\tDISP2_GAP_MCHG(R600_PM_DISPLAY_GAP_IGNORE));\n\tWREG32(CG_DISPLAY_GAP_CNTL, tmp);\n}\n\nstatic void si_program_vc(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\n\tWREG32(CG_FTV, pi->vrc);\n}\n\nstatic void si_clear_vc(struct amdgpu_device *adev)\n{\n\tWREG32(CG_FTV, 0);\n}\n\nstatic u8 si_get_ddr3_mclk_frequency_ratio(u32 memory_clock)\n{\n\tu8 mc_para_index;\n\n\tif (memory_clock < 10000)\n\t\tmc_para_index = 0;\n\telse if (memory_clock >= 80000)\n\t\tmc_para_index = 0x0f;\n\telse\n\t\tmc_para_index = (u8)((memory_clock - 10000) / 5000 + 1);\n\treturn mc_para_index;\n}\n\nstatic u8 si_get_mclk_frequency_ratio(u32 memory_clock, bool strobe_mode)\n{\n\tu8 mc_para_index;\n\n\tif (strobe_mode) {\n\t\tif (memory_clock < 12500)\n\t\t\tmc_para_index = 0x00;\n\t\telse if (memory_clock > 47500)\n\t\t\tmc_para_index = 0x0f;\n\t\telse\n\t\t\tmc_para_index = (u8)((memory_clock - 10000) / 2500);\n\t} else {\n\t\tif (memory_clock < 65000)\n\t\t\tmc_para_index = 0x00;\n\t\telse if (memory_clock > 135000)\n\t\t\tmc_para_index = 0x0f;\n\t\telse\n\t\t\tmc_para_index = (u8)((memory_clock - 60000) / 5000);\n\t}\n\treturn mc_para_index;\n}\n\nstatic u8 si_get_strobe_mode_settings(struct amdgpu_device *adev, u32 mclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tbool strobe_mode = false;\n\tu8 result = 0;\n\n\tif (mclk <= pi->mclk_strobe_mode_threshold)\n\t\tstrobe_mode = true;\n\n\tif (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5)\n\t\tresult = si_get_mclk_frequency_ratio(mclk, strobe_mode);\n\telse\n\t\tresult = si_get_ddr3_mclk_frequency_ratio(mclk);\n\n\tif (strobe_mode)\n\t\tresult |= SISLANDS_SMC_STROBE_ENABLE;\n\n\treturn result;\n}\n\nstatic int si_upload_firmware(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tamdgpu_si_reset_smc(adev);\n\tamdgpu_si_smc_clock(adev, false);\n\n\treturn amdgpu_si_load_smc_ucode(adev, si_pi->sram_end);\n}\n\nstatic bool si_validate_phase_shedding_tables(struct amdgpu_device *adev,\n\t\t\t\t\t      const struct atom_voltage_table *table,\n\t\t\t\t\t      const struct amdgpu_phase_shedding_limits_table *limits)\n{\n\tu32 data, num_bits, num_levels;\n\n\tif ((table == NULL) || (limits == NULL))\n\t\treturn false;\n\n\tdata = table->mask_low;\n\n\tnum_bits = hweight32(data);\n\n\tif (num_bits == 0)\n\t\treturn false;\n\n\tnum_levels = (1 << num_bits);\n\n\tif (table->count != num_levels)\n\t\treturn false;\n\n\tif (limits->count != (num_levels - 1))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void si_trim_voltage_table_to_fit_state_table(struct amdgpu_device *adev,\n\t\t\t\t\t      u32 max_voltage_steps,\n\t\t\t\t\t      struct atom_voltage_table *voltage_table)\n{\n\tunsigned int i, diff;\n\n\tif (voltage_table->count <= max_voltage_steps)\n\t\treturn;\n\n\tdiff = voltage_table->count - max_voltage_steps;\n\n\tfor (i= 0; i < max_voltage_steps; i++)\n\t\tvoltage_table->entries[i] = voltage_table->entries[i + diff];\n\n\tvoltage_table->count = max_voltage_steps;\n}\n\nstatic int si_get_svi2_voltage_table(struct amdgpu_device *adev,\n\t\t\t\t     struct amdgpu_clock_voltage_dependency_table *voltage_dependency_table,\n\t\t\t\t     struct atom_voltage_table *voltage_table)\n{\n\tu32 i;\n\n\tif (voltage_dependency_table == NULL)\n\t\treturn -EINVAL;\n\n\tvoltage_table->mask_low = 0;\n\tvoltage_table->phase_delay = 0;\n\n\tvoltage_table->count = voltage_dependency_table->count;\n\tfor (i = 0; i < voltage_table->count; i++) {\n\t\tvoltage_table->entries[i].value = voltage_dependency_table->entries[i].v;\n\t\tvoltage_table->entries[i].smio_low = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int si_construct_voltage_tables(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint ret;\n\n\tif (pi->voltage_control) {\n\t\tret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_VDDC,\n\t\t\t\t\t\t    VOLTAGE_OBJ_GPIO_LUT, &eg_pi->vddc_voltage_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (eg_pi->vddc_voltage_table.count > SISLANDS_MAX_NO_VREG_STEPS)\n\t\t\tsi_trim_voltage_table_to_fit_state_table(adev,\n\t\t\t\t\t\t\t\t SISLANDS_MAX_NO_VREG_STEPS,\n\t\t\t\t\t\t\t\t &eg_pi->vddc_voltage_table);\n\t} else if (si_pi->voltage_control_svi2) {\n\t\tret = si_get_svi2_voltage_table(adev,\n\t\t\t\t\t\t&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk,\n\t\t\t\t\t\t&eg_pi->vddc_voltage_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (eg_pi->vddci_control) {\n\t\tret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_VDDCI,\n\t\t\t\t\t\t    VOLTAGE_OBJ_GPIO_LUT, &eg_pi->vddci_voltage_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (eg_pi->vddci_voltage_table.count > SISLANDS_MAX_NO_VREG_STEPS)\n\t\t\tsi_trim_voltage_table_to_fit_state_table(adev,\n\t\t\t\t\t\t\t\t SISLANDS_MAX_NO_VREG_STEPS,\n\t\t\t\t\t\t\t\t &eg_pi->vddci_voltage_table);\n\t}\n\tif (si_pi->vddci_control_svi2) {\n\t\tret = si_get_svi2_voltage_table(adev,\n\t\t\t\t\t\t&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk,\n\t\t\t\t\t\t&eg_pi->vddci_voltage_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pi->mvdd_control) {\n\t\tret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_MVDDC,\n\t\t\t\t\t\t    VOLTAGE_OBJ_GPIO_LUT, &si_pi->mvdd_voltage_table);\n\n\t\tif (ret) {\n\t\t\tpi->mvdd_control = false;\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (si_pi->mvdd_voltage_table.count == 0) {\n\t\t\tpi->mvdd_control = false;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (si_pi->mvdd_voltage_table.count > SISLANDS_MAX_NO_VREG_STEPS)\n\t\t\tsi_trim_voltage_table_to_fit_state_table(adev,\n\t\t\t\t\t\t\t\t SISLANDS_MAX_NO_VREG_STEPS,\n\t\t\t\t\t\t\t\t &si_pi->mvdd_voltage_table);\n\t}\n\n\tif (si_pi->vddc_phase_shed_control) {\n\t\tret = amdgpu_atombios_get_voltage_table(adev, VOLTAGE_TYPE_VDDC,\n\t\t\t\t\t\t    VOLTAGE_OBJ_PHASE_LUT, &si_pi->vddc_phase_shed_table);\n\t\tif (ret)\n\t\t\tsi_pi->vddc_phase_shed_control = false;\n\n\t\tif ((si_pi->vddc_phase_shed_table.count == 0) ||\n\t\t    (si_pi->vddc_phase_shed_table.count > SISLANDS_MAX_NO_VREG_STEPS))\n\t\t\tsi_pi->vddc_phase_shed_control = false;\n\t}\n\n\treturn 0;\n}\n\nstatic void si_populate_smc_voltage_table(struct amdgpu_device *adev,\n\t\t\t\t\t  const struct atom_voltage_table *voltage_table,\n\t\t\t\t\t  SISLANDS_SMC_STATETABLE *table)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < voltage_table->count; i++)\n\t\ttable->lowSMIO[i] |= cpu_to_be32(voltage_table->entries[i].smio_low);\n}\n\nstatic int si_populate_smc_voltage_tables(struct amdgpu_device *adev,\n\t\t\t\t\t  SISLANDS_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu8 i;\n\n\tif (si_pi->voltage_control_svi2) {\n\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_svi_rework_gpio_id_svc,\n\t\t\tsi_pi->svc_gpio_id);\n\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_svi_rework_gpio_id_svd,\n\t\t\tsi_pi->svd_gpio_id);\n\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_svi_rework_plat_type,\n\t\t\t\t\t   2);\n\t} else {\n\t\tif (eg_pi->vddc_voltage_table.count) {\n\t\t\tsi_populate_smc_voltage_table(adev, &eg_pi->vddc_voltage_table, table);\n\t\t\ttable->voltageMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC] =\n\t\t\t\tcpu_to_be32(eg_pi->vddc_voltage_table.mask_low);\n\n\t\t\tfor (i = 0; i < eg_pi->vddc_voltage_table.count; i++) {\n\t\t\t\tif (pi->max_vddc_in_table <= eg_pi->vddc_voltage_table.entries[i].value) {\n\t\t\t\t\ttable->maxVDDCIndexInPPTable = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (eg_pi->vddci_voltage_table.count) {\n\t\t\tsi_populate_smc_voltage_table(adev, &eg_pi->vddci_voltage_table, table);\n\n\t\t\ttable->voltageMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDCI] =\n\t\t\t\tcpu_to_be32(eg_pi->vddci_voltage_table.mask_low);\n\t\t}\n\n\n\t\tif (si_pi->mvdd_voltage_table.count) {\n\t\t\tsi_populate_smc_voltage_table(adev, &si_pi->mvdd_voltage_table, table);\n\n\t\t\ttable->voltageMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_MVDD] =\n\t\t\t\tcpu_to_be32(si_pi->mvdd_voltage_table.mask_low);\n\t\t}\n\n\t\tif (si_pi->vddc_phase_shed_control) {\n\t\t\tif (si_validate_phase_shedding_tables(adev, &si_pi->vddc_phase_shed_table,\n\t\t\t\t\t\t\t      &adev->pm.dpm.dyn_state.phase_shedding_limits_table)) {\n\t\t\t\tsi_populate_smc_voltage_table(adev, &si_pi->vddc_phase_shed_table, table);\n\n\t\t\t\ttable->phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING] =\n\t\t\t\t\tcpu_to_be32(si_pi->vddc_phase_shed_table.mask_low);\n\n\t\t\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_phase_shedding_delay,\n\t\t\t\t\t\t\t   (u32)si_pi->vddc_phase_shed_table.phase_delay);\n\t\t\t} else {\n\t\t\t\tsi_pi->vddc_phase_shed_control = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int si_populate_voltage_value(struct amdgpu_device *adev,\n\t\t\t\t     const struct atom_voltage_table *table,\n\t\t\t\t     u16 value, SISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (value <= table->entries[i].value) {\n\t\t\tvoltage->index = (u8)i;\n\t\t\tvoltage->value = cpu_to_be16(table->entries[i].value);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= table->count)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int si_populate_mvdd_value(struct amdgpu_device *adev, u32 mclk,\n\t\t\t\t  SISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tif (pi->mvdd_control) {\n\t\tif (mclk <= pi->mvdd_split_frequency)\n\t\t\tvoltage->index = 0;\n\t\telse\n\t\t\tvoltage->index = (u8)(si_pi->mvdd_voltage_table.count) - 1;\n\n\t\tvoltage->value = cpu_to_be16(si_pi->mvdd_voltage_table.entries[voltage->index].value);\n\t}\n\treturn 0;\n}\n\nstatic int si_get_std_voltage_value(struct amdgpu_device *adev,\n\t\t\t\t    SISLANDS_SMC_VOLTAGE_VALUE *voltage,\n\t\t\t\t    u16 *std_voltage)\n{\n\tu16 v_index;\n\tbool voltage_found = false;\n\t*std_voltage = be16_to_cpu(voltage->value);\n\n\tif (adev->pm.dpm.dyn_state.cac_leakage_table.entries) {\n\t\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_NEW_CAC_VOLTAGE) {\n\t\t\tif (adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries == NULL)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tfor (v_index = 0; (u32)v_index < adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) {\n\t\t\t\tif (be16_to_cpu(voltage->value) ==\n\t\t\t\t    (u16)adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) {\n\t\t\t\t\tvoltage_found = true;\n\t\t\t\t\tif ((u32)v_index < adev->pm.dpm.dyn_state.cac_leakage_table.count)\n\t\t\t\t\t\t*std_voltage =\n\t\t\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[v_index].vddc;\n\t\t\t\t\telse\n\t\t\t\t\t\t*std_voltage =\n\t\t\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[adev->pm.dpm.dyn_state.cac_leakage_table.count-1].vddc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!voltage_found) {\n\t\t\t\tfor (v_index = 0; (u32)v_index < adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.count; v_index++) {\n\t\t\t\t\tif (be16_to_cpu(voltage->value) <=\n\t\t\t\t\t    (u16)adev->pm.dpm.dyn_state.vddc_dependency_on_sclk.entries[v_index].v) {\n\t\t\t\t\t\tvoltage_found = true;\n\t\t\t\t\t\tif ((u32)v_index < adev->pm.dpm.dyn_state.cac_leakage_table.count)\n\t\t\t\t\t\t\t*std_voltage =\n\t\t\t\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[v_index].vddc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*std_voltage =\n\t\t\t\t\t\t\t\tadev->pm.dpm.dyn_state.cac_leakage_table.entries[adev->pm.dpm.dyn_state.cac_leakage_table.count-1].vddc;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif ((u32)voltage->index < adev->pm.dpm.dyn_state.cac_leakage_table.count)\n\t\t\t\t*std_voltage = adev->pm.dpm.dyn_state.cac_leakage_table.entries[voltage->index].vddc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int si_populate_std_voltage_value(struct amdgpu_device *adev,\n\t\t\t\t\t u16 value, u8 index,\n\t\t\t\t\t SISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tvoltage->index = index;\n\tvoltage->value = cpu_to_be16(value);\n\n\treturn 0;\n}\n\nstatic int si_populate_phase_shedding_value(struct amdgpu_device *adev,\n\t\t\t\t\t    const struct amdgpu_phase_shedding_limits_table *limits,\n\t\t\t\t\t    u16 voltage, u32 sclk, u32 mclk,\n\t\t\t\t\t    SISLANDS_SMC_VOLTAGE_VALUE *smc_voltage)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < limits->count; i++) {\n\t\tif ((voltage <= limits->entries[i].voltage) &&\n\t\t    (sclk <= limits->entries[i].sclk) &&\n\t\t    (mclk <= limits->entries[i].mclk))\n\t\t\tbreak;\n\t}\n\n\tsmc_voltage->phase_settings = (u8)i;\n\n\treturn 0;\n}\n\nstatic int si_init_arb_table_index(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\tint ret;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev, si_pi->arb_table_start,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= 0x00FFFFFF;\n\ttmp |= MC_CG_ARB_FREQ_F1 << 24;\n\n\treturn amdgpu_si_write_smc_sram_dword(adev, si_pi->arb_table_start,\n\t\t\t\t\t      tmp, si_pi->sram_end);\n}\n\nstatic int si_initial_switch_from_arb_f0_to_f1(struct amdgpu_device *adev)\n{\n\treturn ni_copy_and_switch_arb_sets(adev, MC_CG_ARB_FREQ_F0, MC_CG_ARB_FREQ_F1);\n}\n\nstatic int si_reset_to_default(struct amdgpu_device *adev)\n{\n\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_ResetToDefaults) == PPSMC_Result_OK) ?\n\t\t0 : -EINVAL;\n}\n\nstatic int si_force_switch_to_arb_f0(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\tint ret;\n\n\tret = amdgpu_si_read_smc_sram_dword(adev, si_pi->arb_table_start,\n\t\t\t\t\t    &tmp, si_pi->sram_end);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = (tmp >> 24) & 0xff;\n\n\tif (tmp == MC_CG_ARB_FREQ_F0)\n\t\treturn 0;\n\n\treturn ni_copy_and_switch_arb_sets(adev, tmp, MC_CG_ARB_FREQ_F0);\n}\n\nstatic u32 si_calculate_memory_refresh_rate(struct amdgpu_device *adev,\n\t\t\t\t\t    u32 engine_clock)\n{\n\tu32 dram_rows;\n\tu32 dram_refresh_rate;\n\tu32 mc_arb_rfsh_rate;\n\tu32 tmp = (RREG32(MC_ARB_RAMCFG) & NOOFROWS_MASK) >> NOOFROWS_SHIFT;\n\n\tif (tmp >= 4)\n\t\tdram_rows = 16384;\n\telse\n\t\tdram_rows = 1 << (tmp + 10);\n\n\tdram_refresh_rate = 1 << ((RREG32(MC_SEQ_MISC0) & 0x3) + 3);\n\tmc_arb_rfsh_rate = ((engine_clock * 10) * dram_refresh_rate / dram_rows - 32) / 64;\n\n\treturn mc_arb_rfsh_rate;\n}\n\nstatic int si_populate_memory_timing_parameters(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct rv7xx_pl *pl,\n\t\t\t\t\t\tSMC_SIslands_MCArbDramTimingRegisterSet *arb_regs)\n{\n\tu32 dram_timing;\n\tu32 dram_timing2;\n\tu32 burst_time;\n\n\tarb_regs->mc_arb_rfsh_rate =\n\t\t(u8)si_calculate_memory_refresh_rate(adev, pl->sclk);\n\n\tamdgpu_atombios_set_engine_dram_timings(adev,\n\t\t\t\t\t    pl->sclk,\n\t\t                            pl->mclk);\n\n\tdram_timing  = RREG32(MC_ARB_DRAM_TIMING);\n\tdram_timing2 = RREG32(MC_ARB_DRAM_TIMING2);\n\tburst_time = RREG32(MC_ARB_BURST_TIME) & STATE0_MASK;\n\n\tarb_regs->mc_arb_dram_timing  = cpu_to_be32(dram_timing);\n\tarb_regs->mc_arb_dram_timing2 = cpu_to_be32(dram_timing2);\n\tarb_regs->mc_arb_burst_time = (u8)burst_time;\n\n\treturn 0;\n}\n\nstatic int si_do_program_memory_timing_parameters(struct amdgpu_device *adev,\n\t\t\t\t\t\t  struct amdgpu_ps *amdgpu_state,\n\t\t\t\t\t\t  unsigned int first_arb_set)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct  si_ps *state = si_get_ps(amdgpu_state);\n\tSMC_SIslands_MCArbDramTimingRegisterSet arb_regs = { 0 };\n\tint i, ret = 0;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tret = si_populate_memory_timing_parameters(adev, &state->performance_levels[i], &arb_regs);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = amdgpu_si_copy_bytes_to_smc(adev,\n\t\t\t\t\t\t  si_pi->arb_table_start +\n\t\t\t\t\t\t  offsetof(SMC_SIslands_MCArbDramTimingRegisters, data) +\n\t\t\t\t\t\t  sizeof(SMC_SIslands_MCArbDramTimingRegisterSet) * (first_arb_set + i),\n\t\t\t\t\t\t  (u8 *)&arb_regs,\n\t\t\t\t\t\t  sizeof(SMC_SIslands_MCArbDramTimingRegisterSet),\n\t\t\t\t\t\t  si_pi->sram_end);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int si_program_memory_timing_parameters(struct amdgpu_device *adev,\n\t\t\t\t\t       struct amdgpu_ps *amdgpu_new_state)\n{\n\treturn si_do_program_memory_timing_parameters(adev, amdgpu_new_state,\n\t\t\t\t\t\t      SISLANDS_DRIVER_STATE_ARB_INDEX);\n}\n\nstatic int si_populate_initial_mvdd_value(struct amdgpu_device *adev,\n\t\t\t\t\t  struct SISLANDS_SMC_VOLTAGE_VALUE *voltage)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tif (pi->mvdd_control)\n\t\treturn si_populate_voltage_value(adev, &si_pi->mvdd_voltage_table,\n\t\t\t\t\t\t si_pi->mvdd_bootup_value, voltage);\n\n\treturn 0;\n}\n\nstatic int si_populate_smc_initial_state(struct amdgpu_device *adev,\n\t\t\t\t\t struct amdgpu_ps *amdgpu_initial_state,\n\t\t\t\t\t SISLANDS_SMC_STATETABLE *table)\n{\n\tstruct  si_ps *initial_state = si_get_ps(amdgpu_initial_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 reg;\n\tint ret;\n\n\ttable->initialState.level.mclk.vDLL_CNTL =\n\t\tcpu_to_be32(si_pi->clock_registers.dll_cntl);\n\ttable->initialState.level.mclk.vMCLK_PWRMGT_CNTL =\n\t\tcpu_to_be32(si_pi->clock_registers.mclk_pwrmgt_cntl);\n\ttable->initialState.level.mclk.vMPLL_AD_FUNC_CNTL =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_ad_func_cntl);\n\ttable->initialState.level.mclk.vMPLL_DQ_FUNC_CNTL =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_dq_func_cntl);\n\ttable->initialState.level.mclk.vMPLL_FUNC_CNTL =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_func_cntl);\n\ttable->initialState.level.mclk.vMPLL_FUNC_CNTL_1 =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_func_cntl_1);\n\ttable->initialState.level.mclk.vMPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_func_cntl_2);\n\ttable->initialState.level.mclk.vMPLL_SS =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_ss1);\n\ttable->initialState.level.mclk.vMPLL_SS2 =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_ss2);\n\n\ttable->initialState.level.mclk.mclk_value =\n\t\tcpu_to_be32(initial_state->performance_levels[0].mclk);\n\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL =\n\t\tcpu_to_be32(si_pi->clock_registers.cg_spll_func_cntl);\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(si_pi->clock_registers.cg_spll_func_cntl_2);\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_3 =\n\t\tcpu_to_be32(si_pi->clock_registers.cg_spll_func_cntl_3);\n\ttable->initialState.level.sclk.vCG_SPLL_FUNC_CNTL_4 =\n\t\tcpu_to_be32(si_pi->clock_registers.cg_spll_func_cntl_4);\n\ttable->initialState.level.sclk.vCG_SPLL_SPREAD_SPECTRUM =\n\t\tcpu_to_be32(si_pi->clock_registers.cg_spll_spread_spectrum);\n\ttable->initialState.level.sclk.vCG_SPLL_SPREAD_SPECTRUM_2  =\n\t\tcpu_to_be32(si_pi->clock_registers.cg_spll_spread_spectrum_2);\n\n\ttable->initialState.level.sclk.sclk_value =\n\t\tcpu_to_be32(initial_state->performance_levels[0].sclk);\n\n\ttable->initialState.level.arbRefreshState =\n\t\tSISLANDS_INITIAL_STATE_ARB_INDEX;\n\n\ttable->initialState.level.ACIndex = 0;\n\n\tret = si_populate_voltage_value(adev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\tinitial_state->performance_levels[0].vddc,\n\t\t\t\t\t&table->initialState.level.vddc);\n\n\tif (!ret) {\n\t\tu16 std_vddc;\n\n\t\tret = si_get_std_voltage_value(adev,\n\t\t\t\t\t       &table->initialState.level.vddc,\n\t\t\t\t\t       &std_vddc);\n\t\tif (!ret)\n\t\t\tsi_populate_std_voltage_value(adev, std_vddc,\n\t\t\t\t\t\t      table->initialState.level.vddc.index,\n\t\t\t\t\t\t      &table->initialState.level.std_vddc);\n\t}\n\n\tif (eg_pi->vddci_control)\n\t\tsi_populate_voltage_value(adev,\n\t\t\t\t\t  &eg_pi->vddci_voltage_table,\n\t\t\t\t\t  initial_state->performance_levels[0].vddci,\n\t\t\t\t\t  &table->initialState.level.vddci);\n\n\tif (si_pi->vddc_phase_shed_control)\n\t\tsi_populate_phase_shedding_value(adev,\n\t\t\t\t\t\t &adev->pm.dpm.dyn_state.phase_shedding_limits_table,\n\t\t\t\t\t\t initial_state->performance_levels[0].vddc,\n\t\t\t\t\t\t initial_state->performance_levels[0].sclk,\n\t\t\t\t\t\t initial_state->performance_levels[0].mclk,\n\t\t\t\t\t\t &table->initialState.level.vddc);\n\n\tsi_populate_initial_mvdd_value(adev, &table->initialState.level.mvdd);\n\n\treg = CG_R(0xffff) | CG_L(0);\n\ttable->initialState.level.aT = cpu_to_be32(reg);\n\ttable->initialState.level.bSP = cpu_to_be32(pi->dsp);\n\ttable->initialState.level.gen2PCIE = (u8)si_pi->boot_pcie_gen;\n\n\tif (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5) {\n\t\ttable->initialState.level.strobeMode =\n\t\t\tsi_get_strobe_mode_settings(adev,\n\t\t\t\t\t\t    initial_state->performance_levels[0].mclk);\n\n\t\tif (initial_state->performance_levels[0].mclk > pi->mclk_edc_enable_threshold)\n\t\t\ttable->initialState.level.mcFlags = SISLANDS_SMC_MC_EDC_RD_FLAG | SISLANDS_SMC_MC_EDC_WR_FLAG;\n\t\telse\n\t\t\ttable->initialState.level.mcFlags =  0;\n\t}\n\n\ttable->initialState.levelCount = 1;\n\n\ttable->initialState.flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\ttable->initialState.level.dpm2.MaxPS = 0;\n\ttable->initialState.level.dpm2.NearTDPDec = 0;\n\ttable->initialState.level.dpm2.AboveSafeInc = 0;\n\ttable->initialState.level.dpm2.BelowSafeInc = 0;\n\ttable->initialState.level.dpm2.PwrEfficiencyRatio = 0;\n\n\treg = MIN_POWER_MASK | MAX_POWER_MASK;\n\ttable->initialState.level.SQPowerThrottle = cpu_to_be32(reg);\n\n\treg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;\n\ttable->initialState.level.SQPowerThrottle_2 = cpu_to_be32(reg);\n\n\treturn 0;\n}\n\nstatic enum si_pcie_gen si_gen_pcie_gen_support(struct amdgpu_device *adev,\n\t\t\t\t\t\tu32 sys_mask,\n\t\t\t\t\t\tenum si_pcie_gen asic_gen,\n\t\t\t\t\t\tenum si_pcie_gen default_gen)\n{\n\tswitch (asic_gen) {\n\tcase SI_PCIE_GEN1:\n\t\treturn SI_PCIE_GEN1;\n\tcase SI_PCIE_GEN2:\n\t\treturn SI_PCIE_GEN2;\n\tcase SI_PCIE_GEN3:\n\t\treturn SI_PCIE_GEN3;\n\tdefault:\n\t\tif ((sys_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3) &&\n\t\t    (default_gen == SI_PCIE_GEN3))\n\t\t\treturn SI_PCIE_GEN3;\n\t\telse if ((sys_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2) &&\n\t\t\t (default_gen == SI_PCIE_GEN2))\n\t\t\treturn SI_PCIE_GEN2;\n\t\telse\n\t\t\treturn SI_PCIE_GEN1;\n\t}\n\treturn SI_PCIE_GEN1;\n}\n\nstatic int si_populate_smc_acpi_state(struct amdgpu_device *adev,\n\t\t\t\t      SISLANDS_SMC_STATETABLE *table)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 spll_func_cntl = si_pi->clock_registers.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 = si_pi->clock_registers.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 = si_pi->clock_registers.cg_spll_func_cntl_3;\n\tu32 spll_func_cntl_4 = si_pi->clock_registers.cg_spll_func_cntl_4;\n\tu32 dll_cntl = si_pi->clock_registers.dll_cntl;\n\tu32 mclk_pwrmgt_cntl = si_pi->clock_registers.mclk_pwrmgt_cntl;\n\tu32 mpll_ad_func_cntl = si_pi->clock_registers.mpll_ad_func_cntl;\n\tu32 mpll_dq_func_cntl = si_pi->clock_registers.mpll_dq_func_cntl;\n\tu32 mpll_func_cntl = si_pi->clock_registers.mpll_func_cntl;\n\tu32 mpll_func_cntl_1 = si_pi->clock_registers.mpll_func_cntl_1;\n\tu32 mpll_func_cntl_2 = si_pi->clock_registers.mpll_func_cntl_2;\n\tu32 reg;\n\tint ret;\n\n\ttable->ACPIState = table->initialState;\n\n\ttable->ACPIState.flags &= ~PPSMC_SWSTATE_FLAG_DC;\n\n\tif (pi->acpi_vddc) {\n\t\tret = si_populate_voltage_value(adev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tpi->acpi_vddc, &table->ACPIState.level.vddc);\n\t\tif (!ret) {\n\t\t\tu16 std_vddc;\n\n\t\t\tret = si_get_std_voltage_value(adev,\n\t\t\t\t\t\t       &table->ACPIState.level.vddc, &std_vddc);\n\t\t\tif (!ret)\n\t\t\t\tsi_populate_std_voltage_value(adev, std_vddc,\n\t\t\t\t\t\t\t      table->ACPIState.level.vddc.index,\n\t\t\t\t\t\t\t      &table->ACPIState.level.std_vddc);\n\t\t}\n\t\ttable->ACPIState.level.gen2PCIE = si_pi->acpi_pcie_gen;\n\n\t\tif (si_pi->vddc_phase_shed_control) {\n\t\t\tsi_populate_phase_shedding_value(adev,\n\t\t\t\t\t\t\t &adev->pm.dpm.dyn_state.phase_shedding_limits_table,\n\t\t\t\t\t\t\t pi->acpi_vddc,\n\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t &table->ACPIState.level.vddc);\n\t\t}\n\t} else {\n\t\tret = si_populate_voltage_value(adev, &eg_pi->vddc_voltage_table,\n\t\t\t\t\t\tpi->min_vddc_in_table, &table->ACPIState.level.vddc);\n\t\tif (!ret) {\n\t\t\tu16 std_vddc;\n\n\t\t\tret = si_get_std_voltage_value(adev,\n\t\t\t\t\t\t       &table->ACPIState.level.vddc, &std_vddc);\n\n\t\t\tif (!ret)\n\t\t\t\tsi_populate_std_voltage_value(adev, std_vddc,\n\t\t\t\t\t\t\t      table->ACPIState.level.vddc.index,\n\t\t\t\t\t\t\t      &table->ACPIState.level.std_vddc);\n\t\t}\n\t\ttable->ACPIState.level.gen2PCIE =\n\t\t\t(u8)si_gen_pcie_gen_support(adev,\n\t\t\t\t\t\t    si_pi->sys_pcie_mask,\n\t\t\t\t\t\t    si_pi->boot_pcie_gen,\n\t\t\t\t\t\t    SI_PCIE_GEN1);\n\n\t\tif (si_pi->vddc_phase_shed_control)\n\t\t\tsi_populate_phase_shedding_value(adev,\n\t\t\t\t\t\t\t &adev->pm.dpm.dyn_state.phase_shedding_limits_table,\n\t\t\t\t\t\t\t pi->min_vddc_in_table,\n\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t 0,\n\t\t\t\t\t\t\t &table->ACPIState.level.vddc);\n\t}\n\n\tif (pi->acpi_vddc) {\n\t\tif (eg_pi->acpi_vddci)\n\t\t\tsi_populate_voltage_value(adev, &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\t  eg_pi->acpi_vddci,\n\t\t\t\t\t\t  &table->ACPIState.level.vddci);\n\t}\n\n\tmclk_pwrmgt_cntl |= MRDCK0_RESET | MRDCK1_RESET;\n\tmclk_pwrmgt_cntl &= ~(MRDCK0_PDNB | MRDCK1_PDNB);\n\n\tdll_cntl &= ~(MRDCK0_BYPASS | MRDCK1_BYPASS);\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(4);\n\n\ttable->ACPIState.level.mclk.vDLL_CNTL =\n\t\tcpu_to_be32(dll_cntl);\n\ttable->ACPIState.level.mclk.vMCLK_PWRMGT_CNTL =\n\t\tcpu_to_be32(mclk_pwrmgt_cntl);\n\ttable->ACPIState.level.mclk.vMPLL_AD_FUNC_CNTL =\n\t\tcpu_to_be32(mpll_ad_func_cntl);\n\ttable->ACPIState.level.mclk.vMPLL_DQ_FUNC_CNTL =\n\t\tcpu_to_be32(mpll_dq_func_cntl);\n\ttable->ACPIState.level.mclk.vMPLL_FUNC_CNTL =\n\t\tcpu_to_be32(mpll_func_cntl);\n\ttable->ACPIState.level.mclk.vMPLL_FUNC_CNTL_1 =\n\t\tcpu_to_be32(mpll_func_cntl_1);\n\ttable->ACPIState.level.mclk.vMPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(mpll_func_cntl_2);\n\ttable->ACPIState.level.mclk.vMPLL_SS =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_ss1);\n\ttable->ACPIState.level.mclk.vMPLL_SS2 =\n\t\tcpu_to_be32(si_pi->clock_registers.mpll_ss2);\n\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL =\n\t\tcpu_to_be32(spll_func_cntl);\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_2 =\n\t\tcpu_to_be32(spll_func_cntl_2);\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_3 =\n\t\tcpu_to_be32(spll_func_cntl_3);\n\ttable->ACPIState.level.sclk.vCG_SPLL_FUNC_CNTL_4 =\n\t\tcpu_to_be32(spll_func_cntl_4);\n\n\ttable->ACPIState.level.mclk.mclk_value = 0;\n\ttable->ACPIState.level.sclk.sclk_value = 0;\n\n\tsi_populate_mvdd_value(adev, 0, &table->ACPIState.level.mvdd);\n\n\tif (eg_pi->dynamic_ac_timing)\n\t\ttable->ACPIState.level.ACIndex = 0;\n\n\ttable->ACPIState.level.dpm2.MaxPS = 0;\n\ttable->ACPIState.level.dpm2.NearTDPDec = 0;\n\ttable->ACPIState.level.dpm2.AboveSafeInc = 0;\n\ttable->ACPIState.level.dpm2.BelowSafeInc = 0;\n\ttable->ACPIState.level.dpm2.PwrEfficiencyRatio = 0;\n\n\treg = MIN_POWER_MASK | MAX_POWER_MASK;\n\ttable->ACPIState.level.SQPowerThrottle = cpu_to_be32(reg);\n\n\treg = MAX_POWER_DELTA_MASK | STI_SIZE_MASK | LTI_RATIO_MASK;\n\ttable->ACPIState.level.SQPowerThrottle_2 = cpu_to_be32(reg);\n\n\treturn 0;\n}\n\nstatic int si_populate_ulv_state(struct amdgpu_device *adev,\n\t\t\t\t struct SISLANDS_SMC_SWSTATE_SINGLE *state)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct si_ulv_param *ulv = &si_pi->ulv;\n\tu32 sclk_in_sr = 1350;  \n\tint ret;\n\n\tret = si_convert_power_level_to_smc(adev, &ulv->pl,\n\t\t\t\t\t    &state->level);\n\tif (!ret) {\n\t\tif (eg_pi->sclk_deep_sleep) {\n\t\t\tif (sclk_in_sr <= SCLK_MIN_DEEPSLEEP_FREQ)\n\t\t\t\tstate->level.stateFlags |= PPSMC_STATEFLAG_DEEPSLEEP_BYPASS;\n\t\t\telse\n\t\t\t\tstate->level.stateFlags |= PPSMC_STATEFLAG_DEEPSLEEP_THROTTLE;\n\t\t}\n\t\tif (ulv->one_pcie_lane_in_ulv)\n\t\t\tstate->flags |= PPSMC_SWSTATE_FLAG_PCIE_X1;\n\t\tstate->level.arbRefreshState = (u8)(SISLANDS_ULV_STATE_ARB_INDEX);\n\t\tstate->level.ACIndex = 1;\n\t\tstate->level.std_vddc = state->level.vddc;\n\t\tstate->levelCount = 1;\n\n\t\tstate->flags |= PPSMC_SWSTATE_FLAG_DC;\n\t}\n\n\treturn ret;\n}\n\nstatic int si_program_ulv_memory_timing_parameters(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct si_ulv_param *ulv = &si_pi->ulv;\n\tSMC_SIslands_MCArbDramTimingRegisterSet arb_regs = { 0 };\n\tint ret;\n\n\tret = si_populate_memory_timing_parameters(adev, &ulv->pl,\n\t\t\t\t\t\t   &arb_regs);\n\tif (ret)\n\t\treturn ret;\n\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_ulv_volt_change_delay,\n\t\t\t\t   ulv->volt_change_delay);\n\n\tret = amdgpu_si_copy_bytes_to_smc(adev,\n\t\t\t\t\t  si_pi->arb_table_start +\n\t\t\t\t\t  offsetof(SMC_SIslands_MCArbDramTimingRegisters, data) +\n\t\t\t\t\t  sizeof(SMC_SIslands_MCArbDramTimingRegisterSet) * SISLANDS_ULV_STATE_ARB_INDEX,\n\t\t\t\t\t  (u8 *)&arb_regs,\n\t\t\t\t\t  sizeof(SMC_SIslands_MCArbDramTimingRegisterSet),\n\t\t\t\t\t  si_pi->sram_end);\n\n\treturn ret;\n}\n\nstatic void si_get_mvdd_configuration(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\n\tpi->mvdd_split_frequency = 30000;\n}\n\nstatic int si_init_smc_table(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct amdgpu_ps *amdgpu_boot_state = adev->pm.dpm.boot_ps;\n\tconst struct si_ulv_param *ulv = &si_pi->ulv;\n\tSISLANDS_SMC_STATETABLE  *table = &si_pi->smc_statetable;\n\tint ret;\n\tu32 lane_width;\n\tu32 vr_hot_gpio;\n\n\tsi_populate_smc_voltage_tables(adev, table);\n\n\tswitch (adev->pm.int_thermal_type) {\n\tcase THERMAL_TYPE_SI:\n\tcase THERMAL_TYPE_EMC2103_WITH_INTERNAL:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_INTERNAL;\n\t\tbreak;\n\tcase THERMAL_TYPE_NONE:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_NONE;\n\t\tbreak;\n\tdefault:\n\t\ttable->thermalProtectType = PPSMC_THERMAL_PROTECT_TYPE_EXTERNAL;\n\t\tbreak;\n\t}\n\n\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GPIO_DC;\n\n\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT) {\n\t\tif ((adev->pdev->device != 0x6818) && (adev->pdev->device != 0x6819))\n\t\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT;\n\t}\n\n\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_STEPVDDC;\n\n\tif (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5)\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_GDDR5;\n\n\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_REVERT_GPIO5_POLARITY)\n\t\ttable->extraFlags |= PPSMC_EXTRAFLAGS_AC2DC_GPIO5_POLARITY_HIGH;\n\n\tif (adev->pm.dpm.platform_caps & ATOM_PP_PLATFORM_CAP_VRHOT_GPIO_CONFIGURABLE) {\n\t\ttable->systemFlags |= PPSMC_SYSTEMFLAG_REGULATOR_HOT_PROG_GPIO;\n\t\tvr_hot_gpio = adev->pm.dpm.backbias_response_time;\n\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_vr_hot_gpio,\n\t\t\t\t\t   vr_hot_gpio);\n\t}\n\n\tret = si_populate_smc_initial_state(adev, amdgpu_boot_state, table);\n\tif (ret)\n\t\treturn ret;\n\n\tret = si_populate_smc_acpi_state(adev, table);\n\tif (ret)\n\t\treturn ret;\n\n\ttable->driverState.flags = table->initialState.flags;\n\ttable->driverState.levelCount = table->initialState.levelCount;\n\ttable->driverState.levels[0] = table->initialState.level;\n\n\tret = si_do_program_memory_timing_parameters(adev, amdgpu_boot_state,\n\t\t\t\t\t\t     SISLANDS_INITIAL_STATE_ARB_INDEX);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ulv->supported && ulv->pl.vddc) {\n\t\tret = si_populate_ulv_state(adev, &table->ULVState);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = si_program_ulv_memory_timing_parameters(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tWREG32(CG_ULV_CONTROL, ulv->cg_ulv_control);\n\t\tWREG32(CG_ULV_PARAMETER, ulv->cg_ulv_parameter);\n\n\t\tlane_width = amdgpu_get_pcie_lanes(adev);\n\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_non_ulv_pcie_link_width, lane_width);\n\t} else {\n\t\ttable->ULVState = table->initialState;\n\t}\n\n\treturn amdgpu_si_copy_bytes_to_smc(adev, si_pi->state_table_start,\n\t\t\t\t\t   (u8 *)table, sizeof(SISLANDS_SMC_STATETABLE),\n\t\t\t\t\t   si_pi->sram_end);\n}\n\nstatic int si_calculate_sclk_params(struct amdgpu_device *adev,\n\t\t\t\t    u32 engine_clock,\n\t\t\t\t    SISLANDS_SMC_SCLK_VALUE *sclk)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct atom_clock_dividers dividers;\n\tu32 spll_func_cntl = si_pi->clock_registers.cg_spll_func_cntl;\n\tu32 spll_func_cntl_2 = si_pi->clock_registers.cg_spll_func_cntl_2;\n\tu32 spll_func_cntl_3 = si_pi->clock_registers.cg_spll_func_cntl_3;\n\tu32 spll_func_cntl_4 = si_pi->clock_registers.cg_spll_func_cntl_4;\n\tu32 cg_spll_spread_spectrum = si_pi->clock_registers.cg_spll_spread_spectrum;\n\tu32 cg_spll_spread_spectrum_2 = si_pi->clock_registers.cg_spll_spread_spectrum_2;\n\tu64 tmp;\n\tu32 reference_clock = adev->clock.spll.reference_freq;\n\tu32 reference_divider;\n\tu32 fbdiv;\n\tint ret;\n\n\tret = amdgpu_atombios_get_clock_dividers(adev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     engine_clock, false, &dividers);\n\tif (ret)\n\t\treturn ret;\n\n\treference_divider = 1 + dividers.ref_div;\n\n\ttmp = (u64) engine_clock * reference_divider * dividers.post_div * 16384;\n\tdo_div(tmp, reference_clock);\n\tfbdiv = (u32) tmp;\n\n\tspll_func_cntl &= ~(SPLL_PDIV_A_MASK | SPLL_REF_DIV_MASK);\n\tspll_func_cntl |= SPLL_REF_DIV(dividers.ref_div);\n\tspll_func_cntl |= SPLL_PDIV_A(dividers.post_div);\n\n\tspll_func_cntl_2 &= ~SCLK_MUX_SEL_MASK;\n\tspll_func_cntl_2 |= SCLK_MUX_SEL(2);\n\n\tspll_func_cntl_3 &= ~SPLL_FB_DIV_MASK;\n\tspll_func_cntl_3 |= SPLL_FB_DIV(fbdiv);\n\tspll_func_cntl_3 |= SPLL_DITHEN;\n\n\tif (pi->sclk_ss) {\n\t\tstruct amdgpu_atom_ss ss;\n\t\tu32 vco_freq = engine_clock * dividers.post_div;\n\n\t\tif (amdgpu_atombios_get_asic_ss_info(adev, &ss,\n\t\t\t\t\t\t     ASIC_INTERNAL_ENGINE_SS, vco_freq)) {\n\t\t\tu32 clk_s = reference_clock * 5 / (reference_divider * ss.rate);\n\t\t\tu32 clk_v = 4 * ss.percentage * fbdiv / (clk_s * 10000);\n\n\t\t\tcg_spll_spread_spectrum &= ~CLK_S_MASK;\n\t\t\tcg_spll_spread_spectrum |= CLK_S(clk_s);\n\t\t\tcg_spll_spread_spectrum |= SSEN;\n\n\t\t\tcg_spll_spread_spectrum_2 &= ~CLK_V_MASK;\n\t\t\tcg_spll_spread_spectrum_2 |= CLK_V(clk_v);\n\t\t}\n\t}\n\n\tsclk->sclk_value = engine_clock;\n\tsclk->vCG_SPLL_FUNC_CNTL = spll_func_cntl;\n\tsclk->vCG_SPLL_FUNC_CNTL_2 = spll_func_cntl_2;\n\tsclk->vCG_SPLL_FUNC_CNTL_3 = spll_func_cntl_3;\n\tsclk->vCG_SPLL_FUNC_CNTL_4 = spll_func_cntl_4;\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM = cg_spll_spread_spectrum;\n\tsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cg_spll_spread_spectrum_2;\n\n\treturn 0;\n}\n\nstatic int si_populate_sclk_value(struct amdgpu_device *adev,\n\t\t\t\t  u32 engine_clock,\n\t\t\t\t  SISLANDS_SMC_SCLK_VALUE *sclk)\n{\n\tSISLANDS_SMC_SCLK_VALUE sclk_tmp;\n\tint ret;\n\n\tret = si_calculate_sclk_params(adev, engine_clock, &sclk_tmp);\n\tif (!ret) {\n\t\tsclk->sclk_value = cpu_to_be32(sclk_tmp.sclk_value);\n\t\tsclk->vCG_SPLL_FUNC_CNTL = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL);\n\t\tsclk->vCG_SPLL_FUNC_CNTL_2 = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL_2);\n\t\tsclk->vCG_SPLL_FUNC_CNTL_3 = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL_3);\n\t\tsclk->vCG_SPLL_FUNC_CNTL_4 = cpu_to_be32(sclk_tmp.vCG_SPLL_FUNC_CNTL_4);\n\t\tsclk->vCG_SPLL_SPREAD_SPECTRUM = cpu_to_be32(sclk_tmp.vCG_SPLL_SPREAD_SPECTRUM);\n\t\tsclk->vCG_SPLL_SPREAD_SPECTRUM_2 = cpu_to_be32(sclk_tmp.vCG_SPLL_SPREAD_SPECTRUM_2);\n\t}\n\n\treturn ret;\n}\n\nstatic int si_populate_mclk_value(struct amdgpu_device *adev,\n\t\t\t\t  u32 engine_clock,\n\t\t\t\t  u32 memory_clock,\n\t\t\t\t  SISLANDS_SMC_MCLK_VALUE *mclk,\n\t\t\t\t  bool strobe_mode,\n\t\t\t\t  bool dll_state_on)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32  dll_cntl = si_pi->clock_registers.dll_cntl;\n\tu32  mclk_pwrmgt_cntl = si_pi->clock_registers.mclk_pwrmgt_cntl;\n\tu32  mpll_ad_func_cntl = si_pi->clock_registers.mpll_ad_func_cntl;\n\tu32  mpll_dq_func_cntl = si_pi->clock_registers.mpll_dq_func_cntl;\n\tu32  mpll_func_cntl = si_pi->clock_registers.mpll_func_cntl;\n\tu32  mpll_func_cntl_1 = si_pi->clock_registers.mpll_func_cntl_1;\n\tu32  mpll_func_cntl_2 = si_pi->clock_registers.mpll_func_cntl_2;\n\tu32  mpll_ss1 = si_pi->clock_registers.mpll_ss1;\n\tu32  mpll_ss2 = si_pi->clock_registers.mpll_ss2;\n\tstruct atom_mpll_param mpll_param;\n\tint ret;\n\n\tret = amdgpu_atombios_get_memory_pll_dividers(adev, memory_clock, strobe_mode, &mpll_param);\n\tif (ret)\n\t\treturn ret;\n\n\tmpll_func_cntl &= ~BWCTRL_MASK;\n\tmpll_func_cntl |= BWCTRL(mpll_param.bwcntl);\n\n\tmpll_func_cntl_1 &= ~(CLKF_MASK | CLKFRAC_MASK | VCO_MODE_MASK);\n\tmpll_func_cntl_1 |= CLKF(mpll_param.clkf) |\n\t\tCLKFRAC(mpll_param.clkfrac) | VCO_MODE(mpll_param.vco_mode);\n\n\tmpll_ad_func_cntl &= ~YCLK_POST_DIV_MASK;\n\tmpll_ad_func_cntl |= YCLK_POST_DIV(mpll_param.post_div);\n\n\tif (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5) {\n\t\tmpll_dq_func_cntl &= ~(YCLK_SEL_MASK | YCLK_POST_DIV_MASK);\n\t\tmpll_dq_func_cntl |= YCLK_SEL(mpll_param.yclk_sel) |\n\t\t\tYCLK_POST_DIV(mpll_param.post_div);\n\t}\n\n\tif (pi->mclk_ss) {\n\t\tstruct amdgpu_atom_ss ss;\n\t\tu32 freq_nom;\n\t\tu32 tmp;\n\t\tu32 reference_clock = adev->clock.mpll.reference_freq;\n\n\t\tif (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5)\n\t\t\tfreq_nom = memory_clock * 4;\n\t\telse\n\t\t\tfreq_nom = memory_clock * 2;\n\n\t\ttmp = freq_nom / reference_clock;\n\t\ttmp = tmp * tmp;\n\t\tif (amdgpu_atombios_get_asic_ss_info(adev, &ss,\n\t\t                                     ASIC_INTERNAL_MEMORY_SS, freq_nom)) {\n\t\t\tu32 clks = reference_clock * 5 / ss.rate;\n\t\t\tu32 clkv = (u32)((((131 * ss.percentage * ss.rate) / 100) * tmp) / freq_nom);\n\n\t\t        mpll_ss1 &= ~CLKV_MASK;\n\t\t        mpll_ss1 |= CLKV(clkv);\n\n\t\t        mpll_ss2 &= ~CLKS_MASK;\n\t\t        mpll_ss2 |= CLKS(clks);\n\t\t}\n\t}\n\n\tmclk_pwrmgt_cntl &= ~DLL_SPEED_MASK;\n\tmclk_pwrmgt_cntl |= DLL_SPEED(mpll_param.dll_speed);\n\n\tif (dll_state_on)\n\t\tmclk_pwrmgt_cntl |= MRDCK0_PDNB | MRDCK1_PDNB;\n\telse\n\t\tmclk_pwrmgt_cntl &= ~(MRDCK0_PDNB | MRDCK1_PDNB);\n\n\tmclk->mclk_value = cpu_to_be32(memory_clock);\n\tmclk->vMPLL_FUNC_CNTL = cpu_to_be32(mpll_func_cntl);\n\tmclk->vMPLL_FUNC_CNTL_1 = cpu_to_be32(mpll_func_cntl_1);\n\tmclk->vMPLL_FUNC_CNTL_2 = cpu_to_be32(mpll_func_cntl_2);\n\tmclk->vMPLL_AD_FUNC_CNTL = cpu_to_be32(mpll_ad_func_cntl);\n\tmclk->vMPLL_DQ_FUNC_CNTL = cpu_to_be32(mpll_dq_func_cntl);\n\tmclk->vMCLK_PWRMGT_CNTL = cpu_to_be32(mclk_pwrmgt_cntl);\n\tmclk->vDLL_CNTL = cpu_to_be32(dll_cntl);\n\tmclk->vMPLL_SS = cpu_to_be32(mpll_ss1);\n\tmclk->vMPLL_SS2 = cpu_to_be32(mpll_ss2);\n\n\treturn 0;\n}\n\nstatic void si_populate_smc_sp(struct amdgpu_device *adev,\n\t\t\t       struct amdgpu_ps *amdgpu_state,\n\t\t\t       SISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct  si_ps *ps = si_get_ps(amdgpu_state);\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tint i;\n\n\tfor (i = 0; i < ps->performance_level_count - 1; i++)\n\t\tsmc_state->levels[i].bSP = cpu_to_be32(pi->dsp);\n\n\tsmc_state->levels[ps->performance_level_count - 1].bSP =\n\t\tcpu_to_be32(pi->psp);\n}\n\nstatic int si_convert_power_level_to_smc(struct amdgpu_device *adev,\n\t\t\t\t\t struct rv7xx_pl *pl,\n\t\t\t\t\t SISLANDS_SMC_HW_PERFORMANCE_LEVEL *level)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint ret;\n\tbool dll_state_on;\n\tu16 std_vddc;\n\tbool gmc_pg = false;\n\n\tif (eg_pi->pcie_performance_request &&\n\t    (si_pi->force_pcie_gen != SI_PCIE_GEN_INVALID))\n\t\tlevel->gen2PCIE = (u8)si_pi->force_pcie_gen;\n\telse\n\t\tlevel->gen2PCIE = (u8)pl->pcie_gen;\n\n\tret = si_populate_sclk_value(adev, pl->sclk, &level->sclk);\n\tif (ret)\n\t\treturn ret;\n\n\tlevel->mcFlags =  0;\n\n\tif (pi->mclk_stutter_mode_threshold &&\n\t    (pl->mclk <= pi->mclk_stutter_mode_threshold) &&\n\t    !eg_pi->uvd_enabled &&\n\t    (RREG32(DPG_PIPE_STUTTER_CONTROL) & STUTTER_ENABLE) &&\n\t    (adev->pm.dpm.new_active_crtc_count <= 2)) {\n\t\tlevel->mcFlags |= SISLANDS_SMC_MC_STUTTER_EN;\n\n\t\tif (gmc_pg)\n\t\t\tlevel->mcFlags |= SISLANDS_SMC_MC_PG_EN;\n\t}\n\n\tif (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5) {\n\t\tif (pl->mclk > pi->mclk_edc_enable_threshold)\n\t\t\tlevel->mcFlags |= SISLANDS_SMC_MC_EDC_RD_FLAG;\n\n\t\tif (pl->mclk > eg_pi->mclk_edc_wr_enable_threshold)\n\t\t\tlevel->mcFlags |= SISLANDS_SMC_MC_EDC_WR_FLAG;\n\n\t\tlevel->strobeMode = si_get_strobe_mode_settings(adev, pl->mclk);\n\n\t\tif (level->strobeMode & SISLANDS_SMC_STROBE_ENABLE) {\n\t\t\tif (si_get_mclk_frequency_ratio(pl->mclk, true) >=\n\t\t\t    ((RREG32(MC_SEQ_MISC7) >> 16) & 0xf))\n\t\t\t\tdll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\n\t\t\telse\n\t\t\t\tdll_state_on = ((RREG32(MC_SEQ_MISC6) >> 1) & 0x1) ? true : false;\n\t\t} else {\n\t\t\tdll_state_on = false;\n\t\t}\n\t} else {\n\t\tlevel->strobeMode = si_get_strobe_mode_settings(adev,\n\t\t\t\t\t\t\t\tpl->mclk);\n\n\t\tdll_state_on = ((RREG32(MC_SEQ_MISC5) >> 1) & 0x1) ? true : false;\n\t}\n\n\tret = si_populate_mclk_value(adev,\n\t\t\t\t     pl->sclk,\n\t\t\t\t     pl->mclk,\n\t\t\t\t     &level->mclk,\n\t\t\t\t     (level->strobeMode & SISLANDS_SMC_STROBE_ENABLE) != 0, dll_state_on);\n\tif (ret)\n\t\treturn ret;\n\n\tret = si_populate_voltage_value(adev,\n\t\t\t\t\t&eg_pi->vddc_voltage_table,\n\t\t\t\t\tpl->vddc, &level->vddc);\n\tif (ret)\n\t\treturn ret;\n\n\n\tret = si_get_std_voltage_value(adev, &level->vddc, &std_vddc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = si_populate_std_voltage_value(adev, std_vddc,\n\t\t\t\t\t    level->vddc.index, &level->std_vddc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (eg_pi->vddci_control) {\n\t\tret = si_populate_voltage_value(adev, &eg_pi->vddci_voltage_table,\n\t\t\t\t\t\tpl->vddci, &level->vddci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (si_pi->vddc_phase_shed_control) {\n\t\tret = si_populate_phase_shedding_value(adev,\n\t\t\t\t\t\t       &adev->pm.dpm.dyn_state.phase_shedding_limits_table,\n\t\t\t\t\t\t       pl->vddc,\n\t\t\t\t\t\t       pl->sclk,\n\t\t\t\t\t\t       pl->mclk,\n\t\t\t\t\t\t       &level->vddc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tlevel->MaxPoweredUpCU = si_pi->max_cu;\n\n\tret = si_populate_mvdd_value(adev, pl->mclk, &level->mvdd);\n\n\treturn ret;\n}\n\nstatic int si_populate_smc_t(struct amdgpu_device *adev,\n\t\t\t     struct amdgpu_ps *amdgpu_state,\n\t\t\t     SISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct  si_ps *state = si_get_ps(amdgpu_state);\n\tu32 a_t;\n\tu32 t_l, t_h;\n\tu32 high_bsp;\n\tint i, ret;\n\n\tif (state->performance_level_count >= 9)\n\t\treturn -EINVAL;\n\n\tif (state->performance_level_count < 2) {\n\t\ta_t = CG_R(0xffff) | CG_L(0);\n\t\tsmc_state->levels[0].aT = cpu_to_be32(a_t);\n\t\treturn 0;\n\t}\n\n\tsmc_state->levels[0].aT = cpu_to_be32(0);\n\n\tfor (i = 0; i <= state->performance_level_count - 2; i++) {\n\t\tret = r600_calculate_at(\n\t\t\t(50 / SISLANDS_MAX_HARDWARE_POWERLEVELS) * 100 * (i + 1),\n\t\t\t100 * R600_AH_DFLT,\n\t\t\tstate->performance_levels[i + 1].sclk,\n\t\t\tstate->performance_levels[i].sclk,\n\t\t\t&t_l,\n\t\t\t&t_h);\n\n\t\tif (ret) {\n\t\t\tt_h = (i + 1) * 1000 - 50 * R600_AH_DFLT;\n\t\t\tt_l = (i + 1) * 1000 + 50 * R600_AH_DFLT;\n\t\t}\n\n\t\ta_t = be32_to_cpu(smc_state->levels[i].aT) & ~CG_R_MASK;\n\t\ta_t |= CG_R(t_l * pi->bsp / 20000);\n\t\tsmc_state->levels[i].aT = cpu_to_be32(a_t);\n\n\t\thigh_bsp = (i == state->performance_level_count - 2) ?\n\t\t\tpi->pbsp : pi->bsp;\n\t\ta_t = CG_R(0xffff) | CG_L(t_h * high_bsp / 20000);\n\t\tsmc_state->levels[i + 1].aT = cpu_to_be32(a_t);\n\t}\n\n\treturn 0;\n}\n\nstatic int si_disable_ulv(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct si_ulv_param *ulv = &si_pi->ulv;\n\n\tif (ulv->supported)\n\t\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_DisableULV) == PPSMC_Result_OK) ?\n\t\t\t0 : -EINVAL;\n\n\treturn 0;\n}\n\nstatic bool si_is_state_ulv_compatible(struct amdgpu_device *adev,\n\t\t\t\t       struct amdgpu_ps *amdgpu_state)\n{\n\tconst struct si_power_info *si_pi = si_get_pi(adev);\n\tconst struct si_ulv_param *ulv = &si_pi->ulv;\n\tconst struct  si_ps *state = si_get_ps(amdgpu_state);\n\tint i;\n\n\tif (state->performance_levels[0].mclk != ulv->pl.mclk)\n\t\treturn false;\n\n\t \n\n\tfor (i = 0; i < adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count; i++) {\n\t\tif (adev->clock.current_dispclk <=\n\t\t    adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[i].clk) {\n\t\t\tif (ulv->pl.vddc <\n\t\t\t    adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[i].v)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tif ((amdgpu_state->vclk != 0) || (amdgpu_state->dclk != 0))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int si_set_power_state_conditionally_enable_ulv(struct amdgpu_device *adev,\n\t\t\t\t\t\t       struct amdgpu_ps *amdgpu_new_state)\n{\n\tconst struct si_power_info *si_pi = si_get_pi(adev);\n\tconst struct si_ulv_param *ulv = &si_pi->ulv;\n\n\tif (ulv->supported) {\n\t\tif (si_is_state_ulv_compatible(adev, amdgpu_new_state))\n\t\t\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_EnableULV) == PPSMC_Result_OK) ?\n\t\t\t\t0 : -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int si_convert_power_state_to_smc(struct amdgpu_device *adev,\n\t\t\t\t\t struct amdgpu_ps *amdgpu_state,\n\t\t\t\t\t SISLANDS_SMC_SWSTATE *smc_state)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct ni_power_info *ni_pi = ni_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct  si_ps *state = si_get_ps(amdgpu_state);\n\tint i, ret;\n\tu32 threshold;\n\tu32 sclk_in_sr = 1350;  \n\n\tif (state->performance_level_count > SISLANDS_MAX_HARDWARE_POWERLEVELS)\n\t\treturn -EINVAL;\n\n\tthreshold = state->performance_levels[state->performance_level_count-1].sclk * 100 / 100;\n\n\tif (amdgpu_state->vclk && amdgpu_state->dclk) {\n\t\teg_pi->uvd_enabled = true;\n\t\tif (eg_pi->smu_uvd_hs)\n\t\t\tsmc_state->flags |= PPSMC_SWSTATE_FLAG_UVD;\n\t} else {\n\t\teg_pi->uvd_enabled = false;\n\t}\n\n\tif (state->dc_compatible)\n\t\tsmc_state->flags |= PPSMC_SWSTATE_FLAG_DC;\n\n\tsmc_state->levelCount = 0;\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tif (eg_pi->sclk_deep_sleep) {\n\t\t\tif ((i == 0) || si_pi->sclk_deep_sleep_above_low) {\n\t\t\t\tif (sclk_in_sr <= SCLK_MIN_DEEPSLEEP_FREQ)\n\t\t\t\t\tsmc_state->levels[i].stateFlags |= PPSMC_STATEFLAG_DEEPSLEEP_BYPASS;\n\t\t\t\telse\n\t\t\t\t\tsmc_state->levels[i].stateFlags |= PPSMC_STATEFLAG_DEEPSLEEP_THROTTLE;\n\t\t\t}\n\t\t}\n\n\t\tret = si_convert_power_level_to_smc(adev, &state->performance_levels[i],\n\t\t\t\t\t\t    &smc_state->levels[i]);\n\t\tsmc_state->levels[i].arbRefreshState =\n\t\t\t(u8)(SISLANDS_DRIVER_STATE_ARB_INDEX + i);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (ni_pi->enable_power_containment)\n\t\t\tsmc_state->levels[i].displayWatermark =\n\t\t\t\t(state->performance_levels[i].sclk < threshold) ?\n\t\t\t\tPPSMC_DISPLAY_WATERMARK_LOW : PPSMC_DISPLAY_WATERMARK_HIGH;\n\t\telse\n\t\t\tsmc_state->levels[i].displayWatermark = (i < 2) ?\n\t\t\t\tPPSMC_DISPLAY_WATERMARK_LOW : PPSMC_DISPLAY_WATERMARK_HIGH;\n\n\t\tif (eg_pi->dynamic_ac_timing)\n\t\t\tsmc_state->levels[i].ACIndex = SISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT + i;\n\t\telse\n\t\t\tsmc_state->levels[i].ACIndex = 0;\n\n\t\tsmc_state->levelCount++;\n\t}\n\n\tsi_write_smc_soft_register(adev,\n\t\t\t\t   SI_SMC_SOFT_REGISTER_watermark_threshold,\n\t\t\t\t   threshold / 512);\n\n\tsi_populate_smc_sp(adev, amdgpu_state, smc_state);\n\n\tret = si_populate_power_containment_values(adev, amdgpu_state, smc_state);\n\tif (ret)\n\t\tni_pi->enable_power_containment = false;\n\n\tret = si_populate_sq_ramping_values(adev, amdgpu_state, smc_state);\n\tif (ret)\n\t\tni_pi->enable_sq_ramping = false;\n\n\treturn si_populate_smc_t(adev, amdgpu_state, smc_state);\n}\n\nstatic int si_upload_sw_state(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_ps *amdgpu_new_state)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct  si_ps *new_state = si_get_ps(amdgpu_new_state);\n\tint ret;\n\tu32 address = si_pi->state_table_start +\n\t\toffsetof(SISLANDS_SMC_STATETABLE, driverState);\n\tSISLANDS_SMC_SWSTATE *smc_state = &si_pi->smc_statetable.driverState;\n\tsize_t state_size = struct_size(smc_state, levels,\n\t\t\t\t\tnew_state->performance_level_count);\n\tmemset(smc_state, 0, state_size);\n\n\tret = si_convert_power_state_to_smc(adev, amdgpu_new_state, smc_state);\n\tif (ret)\n\t\treturn ret;\n\n\treturn amdgpu_si_copy_bytes_to_smc(adev, address, (u8 *)smc_state,\n\t\t\t\t\t   state_size, si_pi->sram_end);\n}\n\nstatic int si_upload_ulv_state(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct si_ulv_param *ulv = &si_pi->ulv;\n\tint ret = 0;\n\n\tif (ulv->supported && ulv->pl.vddc) {\n\t\tu32 address = si_pi->state_table_start +\n\t\t\toffsetof(SISLANDS_SMC_STATETABLE, ULVState);\n\t\tstruct SISLANDS_SMC_SWSTATE_SINGLE *smc_state = &si_pi->smc_statetable.ULVState;\n\t\tu32 state_size = sizeof(struct SISLANDS_SMC_SWSTATE_SINGLE);\n\n\t\tmemset(smc_state, 0, state_size);\n\n\t\tret = si_populate_ulv_state(adev, smc_state);\n\t\tif (!ret)\n\t\t\tret = amdgpu_si_copy_bytes_to_smc(adev, address, (u8 *)smc_state,\n\t\t\t\t\t\t\t  state_size, si_pi->sram_end);\n\t}\n\n\treturn ret;\n}\n\nstatic int si_upload_smc_data(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_crtc *amdgpu_crtc = NULL;\n\tint i;\n\n\tif (adev->pm.dpm.new_active_crtc_count == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < adev->mode_info.num_crtc; i++) {\n\t\tif (adev->pm.dpm.new_active_crtcs & (1 << i)) {\n\t\t\tamdgpu_crtc = adev->mode_info.crtcs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (amdgpu_crtc == NULL)\n\t\treturn 0;\n\n\tif (amdgpu_crtc->line_time <= 0)\n\t\treturn 0;\n\n\tif (si_write_smc_soft_register(adev,\n\t\t\t\t       SI_SMC_SOFT_REGISTER_crtc_index,\n\t\t\t\t       amdgpu_crtc->crtc_id) != PPSMC_Result_OK)\n\t\treturn 0;\n\n\tif (si_write_smc_soft_register(adev,\n\t\t\t\t       SI_SMC_SOFT_REGISTER_mclk_change_block_cp_min,\n\t\t\t\t       amdgpu_crtc->wm_high / amdgpu_crtc->line_time) != PPSMC_Result_OK)\n\t\treturn 0;\n\n\tif (si_write_smc_soft_register(adev,\n\t\t\t\t       SI_SMC_SOFT_REGISTER_mclk_change_block_cp_max,\n\t\t\t\t       amdgpu_crtc->wm_low / amdgpu_crtc->line_time) != PPSMC_Result_OK)\n\t\treturn 0;\n\n\treturn 0;\n}\n\nstatic int si_set_mc_special_registers(struct amdgpu_device *adev,\n\t\t\t\t       struct si_mc_reg_table *table)\n{\n\tu8 i, j, k;\n\tu32 temp_reg;\n\n\tfor (i = 0, j = table->last; i < table->last; i++) {\n\t\tif (j >= SMC_SISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tswitch (table->mc_reg_address[i].s1) {\n\t\tcase MC_SEQ_MISC1:\n\t\t\ttemp_reg = RREG32(MC_PMG_CMD_EMRS);\n\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_CMD_EMRS;\n\t\t\ttable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_EMRS_LP;\n\t\t\tfor (k = 0; k < table->num_entries; k++)\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t((temp_reg & 0xffff0000)) |\n\t\t\t\t\t((table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16);\n\t\t\tj++;\n\n\t\t\tif (j >= SMC_SISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\ttemp_reg = RREG32(MC_PMG_CMD_MRS);\n\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS;\n\t\t\ttable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS_LP;\n\t\t\tfor (k = 0; k < table->num_entries; k++) {\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t(temp_reg & 0xffff0000) |\n\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\n\t\t\t\tif (adev->gmc.vram_type != AMDGPU_VRAM_TYPE_GDDR5)\n\t\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] |= 0x100;\n\t\t\t}\n\t\t\tj++;\n\n\t\t\tif (adev->gmc.vram_type != AMDGPU_VRAM_TYPE_GDDR5) {\n\t\t\t\tif (j >= SMC_SISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_AUTO_CMD;\n\t\t\t\ttable->mc_reg_address[j].s0 = MC_PMG_AUTO_CMD;\n\t\t\t\tfor (k = 0; k < table->num_entries; k++)\n\t\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0xffff0000) >> 16;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase MC_SEQ_RESERVE_M:\n\t\t\ttemp_reg = RREG32(MC_PMG_CMD_MRS1);\n\t\t\ttable->mc_reg_address[j].s1 = MC_PMG_CMD_MRS1;\n\t\t\ttable->mc_reg_address[j].s0 = MC_SEQ_PMG_CMD_MRS1_LP;\n\t\t\tfor(k = 0; k < table->num_entries; k++)\n\t\t\t\ttable->mc_reg_table_entry[k].mc_data[j] =\n\t\t\t\t\t(temp_reg & 0xffff0000) |\n\t\t\t\t\t(table->mc_reg_table_entry[k].mc_data[i] & 0x0000ffff);\n\t\t\tj++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttable->last = j;\n\n\treturn 0;\n}\n\nstatic bool si_check_s0_mc_reg_index(u16 in_reg, u16 *out_reg)\n{\n\tbool result = true;\n\tswitch (in_reg) {\n\tcase  MC_SEQ_RAS_TIMING:\n\t\t*out_reg = MC_SEQ_RAS_TIMING_LP;\n\t\tbreak;\n\tcase MC_SEQ_CAS_TIMING:\n\t\t*out_reg = MC_SEQ_CAS_TIMING_LP;\n\t\tbreak;\n\tcase MC_SEQ_MISC_TIMING:\n\t\t*out_reg = MC_SEQ_MISC_TIMING_LP;\n\t\tbreak;\n\tcase MC_SEQ_MISC_TIMING2:\n\t\t*out_reg = MC_SEQ_MISC_TIMING2_LP;\n\t\tbreak;\n\tcase MC_SEQ_RD_CTL_D0:\n\t\t*out_reg = MC_SEQ_RD_CTL_D0_LP;\n\t\tbreak;\n\tcase MC_SEQ_RD_CTL_D1:\n\t\t*out_reg = MC_SEQ_RD_CTL_D1_LP;\n\t\tbreak;\n\tcase MC_SEQ_WR_CTL_D0:\n\t\t*out_reg = MC_SEQ_WR_CTL_D0_LP;\n\t\tbreak;\n\tcase MC_SEQ_WR_CTL_D1:\n\t\t*out_reg = MC_SEQ_WR_CTL_D1_LP;\n\t\tbreak;\n\tcase MC_PMG_CMD_EMRS:\n\t\t*out_reg = MC_SEQ_PMG_CMD_EMRS_LP;\n\t\tbreak;\n\tcase MC_PMG_CMD_MRS:\n\t\t*out_reg = MC_SEQ_PMG_CMD_MRS_LP;\n\t\tbreak;\n\tcase MC_PMG_CMD_MRS1:\n\t\t*out_reg = MC_SEQ_PMG_CMD_MRS1_LP;\n\t\tbreak;\n\tcase MC_SEQ_PMG_TIMING:\n\t\t*out_reg = MC_SEQ_PMG_TIMING_LP;\n\t\tbreak;\n\tcase MC_PMG_CMD_MRS2:\n\t\t*out_reg = MC_SEQ_PMG_CMD_MRS2_LP;\n\t\tbreak;\n\tcase MC_SEQ_WR_CTL_2:\n\t\t*out_reg = MC_SEQ_WR_CTL_2_LP;\n\t\tbreak;\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic void si_set_valid_flag(struct si_mc_reg_table *table)\n{\n\tu8 i, j;\n\n\tfor (i = 0; i < table->last; i++) {\n\t\tfor (j = 1; j < table->num_entries; j++) {\n\t\t\tif (table->mc_reg_table_entry[j-1].mc_data[i] != table->mc_reg_table_entry[j].mc_data[i]) {\n\t\t\t\ttable->valid_flag |= 1 << i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void si_set_s0_mc_reg_index(struct si_mc_reg_table *table)\n{\n\tu32 i;\n\tu16 address;\n\n\tfor (i = 0; i < table->last; i++)\n\t\ttable->mc_reg_address[i].s0 = si_check_s0_mc_reg_index(table->mc_reg_address[i].s1, &address) ?\n\t\t\taddress : table->mc_reg_address[i].s1;\n\n}\n\nstatic int si_copy_vbios_mc_reg_table(struct atom_mc_reg_table *table,\n\t\t\t\t      struct si_mc_reg_table *si_table)\n{\n\tu8 i, j;\n\n\tif (table->last > SMC_SISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\treturn -EINVAL;\n\tif (table->num_entries > MAX_AC_TIMING_ENTRIES)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < table->last; i++)\n\t\tsi_table->mc_reg_address[i].s1 = table->mc_reg_address[i].s1;\n\tsi_table->last = table->last;\n\n\tfor (i = 0; i < table->num_entries; i++) {\n\t\tsi_table->mc_reg_table_entry[i].mclk_max =\n\t\t\ttable->mc_reg_table_entry[i].mclk_max;\n\t\tfor (j = 0; j < table->last; j++) {\n\t\t\tsi_table->mc_reg_table_entry[i].mc_data[j] =\n\t\t\t\ttable->mc_reg_table_entry[i].mc_data[j];\n\t\t}\n\t}\n\tsi_table->num_entries = table->num_entries;\n\n\treturn 0;\n}\n\nstatic int si_initialize_mc_reg_table(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct atom_mc_reg_table *table;\n\tstruct si_mc_reg_table *si_table = &si_pi->mc_reg_table;\n\tu8 module_index = rv770_get_memory_module_index(adev);\n\tint ret;\n\n\ttable = kzalloc(sizeof(struct atom_mc_reg_table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tWREG32(MC_SEQ_RAS_TIMING_LP, RREG32(MC_SEQ_RAS_TIMING));\n\tWREG32(MC_SEQ_CAS_TIMING_LP, RREG32(MC_SEQ_CAS_TIMING));\n\tWREG32(MC_SEQ_MISC_TIMING_LP, RREG32(MC_SEQ_MISC_TIMING));\n\tWREG32(MC_SEQ_MISC_TIMING2_LP, RREG32(MC_SEQ_MISC_TIMING2));\n\tWREG32(MC_SEQ_PMG_CMD_EMRS_LP, RREG32(MC_PMG_CMD_EMRS));\n\tWREG32(MC_SEQ_PMG_CMD_MRS_LP, RREG32(MC_PMG_CMD_MRS));\n\tWREG32(MC_SEQ_PMG_CMD_MRS1_LP, RREG32(MC_PMG_CMD_MRS1));\n\tWREG32(MC_SEQ_WR_CTL_D0_LP, RREG32(MC_SEQ_WR_CTL_D0));\n\tWREG32(MC_SEQ_WR_CTL_D1_LP, RREG32(MC_SEQ_WR_CTL_D1));\n\tWREG32(MC_SEQ_RD_CTL_D0_LP, RREG32(MC_SEQ_RD_CTL_D0));\n\tWREG32(MC_SEQ_RD_CTL_D1_LP, RREG32(MC_SEQ_RD_CTL_D1));\n\tWREG32(MC_SEQ_PMG_TIMING_LP, RREG32(MC_SEQ_PMG_TIMING));\n\tWREG32(MC_SEQ_PMG_CMD_MRS2_LP, RREG32(MC_PMG_CMD_MRS2));\n\tWREG32(MC_SEQ_WR_CTL_2_LP, RREG32(MC_SEQ_WR_CTL_2));\n\n\tret = amdgpu_atombios_init_mc_reg_table(adev, module_index, table);\n\tif (ret)\n\t\tgoto init_mc_done;\n\n\tret = si_copy_vbios_mc_reg_table(table, si_table);\n\tif (ret)\n\t\tgoto init_mc_done;\n\n\tsi_set_s0_mc_reg_index(si_table);\n\n\tret = si_set_mc_special_registers(adev, si_table);\n\tif (ret)\n\t\tgoto init_mc_done;\n\n\tsi_set_valid_flag(si_table);\n\ninit_mc_done:\n\tkfree(table);\n\n\treturn ret;\n\n}\n\nstatic void si_populate_mc_reg_addresses(struct amdgpu_device *adev,\n\t\t\t\t\t SMC_SIslands_MCRegisters *mc_reg_table)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 i, j;\n\n\tfor (i = 0, j = 0; j < si_pi->mc_reg_table.last; j++) {\n\t\tif (si_pi->mc_reg_table.valid_flag & (1 << j)) {\n\t\t\tif (i >= SMC_SISLANDS_MC_REGISTER_ARRAY_SIZE)\n\t\t\t\tbreak;\n\t\t\tmc_reg_table->address[i].s0 =\n\t\t\t\tcpu_to_be16(si_pi->mc_reg_table.mc_reg_address[j].s0);\n\t\t\tmc_reg_table->address[i].s1 =\n\t\t\t\tcpu_to_be16(si_pi->mc_reg_table.mc_reg_address[j].s1);\n\t\t\ti++;\n\t\t}\n\t}\n\tmc_reg_table->last = (u8)i;\n}\n\nstatic void si_convert_mc_registers(const struct si_mc_reg_entry *entry,\n\t\t\t\t    SMC_SIslands_MCRegisterSet *data,\n\t\t\t\t    u32 num_entries, u32 valid_flag)\n{\n\tu32 i, j;\n\n\tfor(i = 0, j = 0; j < num_entries; j++) {\n\t\tif (valid_flag & (1 << j)) {\n\t\t\tdata->value[i] = cpu_to_be32(entry->mc_data[j]);\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic void si_convert_mc_reg_table_entry_to_smc(struct amdgpu_device *adev,\n\t\t\t\t\t\t struct rv7xx_pl *pl,\n\t\t\t\t\t\t SMC_SIslands_MCRegisterSet *mc_reg_table_data)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 i = 0;\n\n\tfor (i = 0; i < si_pi->mc_reg_table.num_entries; i++) {\n\t\tif (pl->mclk <= si_pi->mc_reg_table.mc_reg_table_entry[i].mclk_max)\n\t\t\tbreak;\n\t}\n\n\tif ((i == si_pi->mc_reg_table.num_entries) && (i > 0))\n\t\t--i;\n\n\tsi_convert_mc_registers(&si_pi->mc_reg_table.mc_reg_table_entry[i],\n\t\t\t\tmc_reg_table_data, si_pi->mc_reg_table.last,\n\t\t\t\tsi_pi->mc_reg_table.valid_flag);\n}\n\nstatic void si_convert_mc_reg_table_to_smc(struct amdgpu_device *adev,\n\t\t\t\t\t   struct amdgpu_ps *amdgpu_state,\n\t\t\t\t\t   SMC_SIslands_MCRegisters *mc_reg_table)\n{\n\tstruct si_ps *state = si_get_ps(amdgpu_state);\n\tint i;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tsi_convert_mc_reg_table_entry_to_smc(adev,\n\t\t\t\t\t\t     &state->performance_levels[i],\n\t\t\t\t\t\t     &mc_reg_table->data[SISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT + i]);\n\t}\n}\n\nstatic int si_populate_mc_reg_table(struct amdgpu_device *adev,\n\t\t\t\t    struct amdgpu_ps *amdgpu_boot_state)\n{\n\tstruct  si_ps *boot_state = si_get_ps(amdgpu_boot_state);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct si_ulv_param *ulv = &si_pi->ulv;\n\tSMC_SIslands_MCRegisters *smc_mc_reg_table = &si_pi->smc_mc_reg_table;\n\n\tmemset(smc_mc_reg_table, 0, sizeof(SMC_SIslands_MCRegisters));\n\n\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_seq_index, 1);\n\n\tsi_populate_mc_reg_addresses(adev, smc_mc_reg_table);\n\n\tsi_convert_mc_reg_table_entry_to_smc(adev, &boot_state->performance_levels[0],\n\t\t\t\t\t     &smc_mc_reg_table->data[SISLANDS_MCREGISTERTABLE_INITIAL_SLOT]);\n\n\tsi_convert_mc_registers(&si_pi->mc_reg_table.mc_reg_table_entry[0],\n\t\t\t\t&smc_mc_reg_table->data[SISLANDS_MCREGISTERTABLE_ACPI_SLOT],\n\t\t\t\tsi_pi->mc_reg_table.last,\n\t\t\t\tsi_pi->mc_reg_table.valid_flag);\n\n\tif (ulv->supported && ulv->pl.vddc != 0)\n\t\tsi_convert_mc_reg_table_entry_to_smc(adev, &ulv->pl,\n\t\t\t\t\t\t     &smc_mc_reg_table->data[SISLANDS_MCREGISTERTABLE_ULV_SLOT]);\n\telse\n\t\tsi_convert_mc_registers(&si_pi->mc_reg_table.mc_reg_table_entry[0],\n\t\t\t\t\t&smc_mc_reg_table->data[SISLANDS_MCREGISTERTABLE_ULV_SLOT],\n\t\t\t\t\tsi_pi->mc_reg_table.last,\n\t\t\t\t\tsi_pi->mc_reg_table.valid_flag);\n\n\tsi_convert_mc_reg_table_to_smc(adev, amdgpu_boot_state, smc_mc_reg_table);\n\n\treturn amdgpu_si_copy_bytes_to_smc(adev, si_pi->mc_reg_table_start,\n\t\t\t\t\t   (u8 *)smc_mc_reg_table,\n\t\t\t\t\t   sizeof(SMC_SIslands_MCRegisters), si_pi->sram_end);\n}\n\nstatic int si_upload_mc_reg_table(struct amdgpu_device *adev,\n\t\t\t\t  struct amdgpu_ps *amdgpu_new_state)\n{\n\tstruct si_ps *new_state = si_get_ps(amdgpu_new_state);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 address = si_pi->mc_reg_table_start +\n\t\toffsetof(SMC_SIslands_MCRegisters,\n\t\t\t data[SISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT]);\n\tSMC_SIslands_MCRegisters *smc_mc_reg_table = &si_pi->smc_mc_reg_table;\n\n\tmemset(smc_mc_reg_table, 0, sizeof(SMC_SIslands_MCRegisters));\n\n\tsi_convert_mc_reg_table_to_smc(adev, amdgpu_new_state, smc_mc_reg_table);\n\n\treturn amdgpu_si_copy_bytes_to_smc(adev, address,\n\t\t\t\t\t   (u8 *)&smc_mc_reg_table->data[SISLANDS_MCREGISTERTABLE_FIRST_DRIVERSTATE_SLOT],\n\t\t\t\t\t   sizeof(SMC_SIslands_MCRegisterSet) * new_state->performance_level_count,\n\t\t\t\t\t   si_pi->sram_end);\n}\n\nstatic void si_enable_voltage_control(struct amdgpu_device *adev, bool enable)\n{\n\tif (enable)\n\t\tWREG32_P(GENERAL_PWRMGT, VOLT_PWRMGT_EN, ~VOLT_PWRMGT_EN);\n\telse\n\t\tWREG32_P(GENERAL_PWRMGT, 0, ~VOLT_PWRMGT_EN);\n}\n\nstatic enum si_pcie_gen si_get_maximum_link_speed(struct amdgpu_device *adev,\n\t\t\t\t\t\t  struct amdgpu_ps *amdgpu_state)\n{\n\tstruct si_ps *state = si_get_ps(amdgpu_state);\n\tint i;\n\tu16 pcie_speed, max_speed = 0;\n\n\tfor (i = 0; i < state->performance_level_count; i++) {\n\t\tpcie_speed = state->performance_levels[i].pcie_gen;\n\t\tif (max_speed < pcie_speed)\n\t\t\tmax_speed = pcie_speed;\n\t}\n\treturn max_speed;\n}\n\nstatic u16 si_get_current_pcie_speed(struct amdgpu_device *adev)\n{\n\tu32 speed_cntl;\n\n\tspeed_cntl = RREG32_PCIE_PORT(PCIE_LC_SPEED_CNTL) & LC_CURRENT_DATA_RATE_MASK;\n\tspeed_cntl >>= LC_CURRENT_DATA_RATE_SHIFT;\n\n\treturn (u16)speed_cntl;\n}\n\nstatic void si_request_link_speed_change_before_state_change(struct amdgpu_device *adev,\n\t\t\t\t\t\t\t     struct amdgpu_ps *amdgpu_new_state,\n\t\t\t\t\t\t\t     struct amdgpu_ps *amdgpu_current_state)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tenum si_pcie_gen target_link_speed = si_get_maximum_link_speed(adev, amdgpu_new_state);\n\tenum si_pcie_gen current_link_speed;\n\n\tif (si_pi->force_pcie_gen == SI_PCIE_GEN_INVALID)\n\t\tcurrent_link_speed = si_get_maximum_link_speed(adev, amdgpu_current_state);\n\telse\n\t\tcurrent_link_speed = si_pi->force_pcie_gen;\n\n\tsi_pi->force_pcie_gen = SI_PCIE_GEN_INVALID;\n\tsi_pi->pspp_notify_required = false;\n\tif (target_link_speed > current_link_speed) {\n\t\tswitch (target_link_speed) {\n#if defined(CONFIG_ACPI)\n\t\tcase SI_PCIE_GEN3:\n\t\t\tif (amdgpu_acpi_pcie_performance_request(adev, PCIE_PERF_REQ_PECI_GEN3, false) == 0)\n\t\t\t\tbreak;\n\t\t\tsi_pi->force_pcie_gen = SI_PCIE_GEN2;\n\t\t\tif (current_link_speed == SI_PCIE_GEN2)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase SI_PCIE_GEN2:\n\t\t\tif (amdgpu_acpi_pcie_performance_request(adev, PCIE_PERF_REQ_PECI_GEN2, false) == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n#endif\n\t\tdefault:\n\t\t\tsi_pi->force_pcie_gen = si_get_current_pcie_speed(adev);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (target_link_speed < current_link_speed)\n\t\t\tsi_pi->pspp_notify_required = true;\n\t}\n}\n\nstatic void si_notify_link_speed_change_after_state_change(struct amdgpu_device *adev,\n\t\t\t\t\t\t\t   struct amdgpu_ps *amdgpu_new_state,\n\t\t\t\t\t\t\t   struct amdgpu_ps *amdgpu_current_state)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tenum si_pcie_gen target_link_speed = si_get_maximum_link_speed(adev, amdgpu_new_state);\n\tu8 request;\n\n\tif (si_pi->pspp_notify_required) {\n\t\tif (target_link_speed == SI_PCIE_GEN3)\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN3;\n\t\telse if (target_link_speed == SI_PCIE_GEN2)\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN2;\n\t\telse\n\t\t\trequest = PCIE_PERF_REQ_PECI_GEN1;\n\n\t\tif ((request == PCIE_PERF_REQ_PECI_GEN1) &&\n\t\t    (si_get_current_pcie_speed(adev) > 0))\n\t\t\treturn;\n\n#if defined(CONFIG_ACPI)\n\t\tamdgpu_acpi_pcie_performance_request(adev, request, false);\n#endif\n\t}\n}\n\n#if 0\nstatic int si_ds_request(struct amdgpu_device *adev,\n\t\t\t bool ds_status_on, u32 count_write)\n{\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\n\tif (eg_pi->sclk_deep_sleep) {\n\t\tif (ds_status_on)\n\t\t\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_CancelThrottleOVRDSCLKDS) ==\n\t\t\t\tPPSMC_Result_OK) ?\n\t\t\t\t0 : -EINVAL;\n\t\telse\n\t\t\treturn (amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_ThrottleOVRDSCLKDS) ==\n\t\t\t\tPPSMC_Result_OK) ? 0 : -EINVAL;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void si_set_max_cu_value(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\n\tif (adev->asic_type == CHIP_VERDE) {\n\t\tswitch (adev->pdev->device) {\n\t\tcase 0x6820:\n\t\tcase 0x6825:\n\t\tcase 0x6821:\n\t\tcase 0x6823:\n\t\tcase 0x6827:\n\t\t\tsi_pi->max_cu = 10;\n\t\t\tbreak;\n\t\tcase 0x682D:\n\t\tcase 0x6824:\n\t\tcase 0x682F:\n\t\tcase 0x6826:\n\t\t\tsi_pi->max_cu = 8;\n\t\t\tbreak;\n\t\tcase 0x6828:\n\t\tcase 0x6830:\n\t\tcase 0x6831:\n\t\tcase 0x6838:\n\t\tcase 0x6839:\n\t\tcase 0x683D:\n\t\t\tsi_pi->max_cu = 10;\n\t\t\tbreak;\n\t\tcase 0x683B:\n\t\tcase 0x683F:\n\t\tcase 0x6829:\n\t\t\tsi_pi->max_cu = 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsi_pi->max_cu = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsi_pi->max_cu = 0;\n\t}\n}\n\nstatic int si_patch_single_dependency_table_based_on_leakage(struct amdgpu_device *adev,\n\t\t\t\t\t\t\t     struct amdgpu_clock_voltage_dependency_table *table)\n{\n\tu32 i;\n\tint j;\n\tu16 leakage_voltage;\n\n\tif (table) {\n\t\tfor (i = 0; i < table->count; i++) {\n\t\t\tswitch (si_get_leakage_voltage_from_leakage_index(adev,\n\t\t\t\t\t\t\t\t\t  table->entries[i].v,\n\t\t\t\t\t\t\t\t\t  &leakage_voltage)) {\n\t\t\tcase 0:\n\t\t\t\ttable->entries[i].v = leakage_voltage;\n\t\t\t\tbreak;\n\t\t\tcase -EAGAIN:\n\t\t\t\treturn -EINVAL;\n\t\t\tcase -EINVAL:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (j = (table->count - 2); j >= 0; j--) {\n\t\t\ttable->entries[j].v = (table->entries[j].v <= table->entries[j + 1].v) ?\n\t\t\t\ttable->entries[j].v : table->entries[j + 1].v;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int si_patch_dependency_tables_based_on_leakage(struct amdgpu_device *adev)\n{\n\tint ret = 0;\n\n\tret = si_patch_single_dependency_table_based_on_leakage(adev,\n\t\t\t\t\t\t\t\t&adev->pm.dpm.dyn_state.vddc_dependency_on_sclk);\n\tif (ret)\n\t\tDRM_ERROR(\"Could not patch vddc_on_sclk leakage table\\n\");\n\tret = si_patch_single_dependency_table_based_on_leakage(adev,\n\t\t\t\t\t\t\t\t&adev->pm.dpm.dyn_state.vddc_dependency_on_mclk);\n\tif (ret)\n\t\tDRM_ERROR(\"Could not patch vddc_on_mclk leakage table\\n\");\n\tret = si_patch_single_dependency_table_based_on_leakage(adev,\n\t\t\t\t\t\t\t\t&adev->pm.dpm.dyn_state.vddci_dependency_on_mclk);\n\tif (ret)\n\t\tDRM_ERROR(\"Could not patch vddci_on_mclk leakage table\\n\");\n\treturn ret;\n}\n\nstatic void si_set_pcie_lane_width_in_smc(struct amdgpu_device *adev,\n\t\t\t\t\t  struct amdgpu_ps *amdgpu_new_state,\n\t\t\t\t\t  struct amdgpu_ps *amdgpu_current_state)\n{\n\tu32 lane_width;\n\tu32 new_lane_width =\n\t\t((amdgpu_new_state->caps & ATOM_PPLIB_PCIE_LINK_WIDTH_MASK) >> ATOM_PPLIB_PCIE_LINK_WIDTH_SHIFT) + 1;\n\tu32 current_lane_width =\n\t\t((amdgpu_current_state->caps & ATOM_PPLIB_PCIE_LINK_WIDTH_MASK) >> ATOM_PPLIB_PCIE_LINK_WIDTH_SHIFT) + 1;\n\n\tif (new_lane_width != current_lane_width) {\n\t\tamdgpu_set_pcie_lanes(adev, new_lane_width);\n\t\tlane_width = amdgpu_get_pcie_lanes(adev);\n\t\tsi_write_smc_soft_register(adev, SI_SMC_SOFT_REGISTER_non_ulv_pcie_link_width, lane_width);\n\t}\n}\n\nstatic void si_dpm_setup_asic(struct amdgpu_device *adev)\n{\n\tsi_read_clock_registers(adev);\n\tsi_enable_acpi_power_management(adev);\n}\n\nstatic int si_thermal_enable_alert(struct amdgpu_device *adev,\n\t\t\t\t   bool enable)\n{\n\tu32 thermal_int = RREG32(CG_THERMAL_INT);\n\n\tif (enable) {\n\t\tPPSMC_Result result;\n\n\t\tthermal_int &= ~(THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW);\n\t\tWREG32(CG_THERMAL_INT, thermal_int);\n\t\tresult = amdgpu_si_send_msg_to_smc(adev, PPSMC_MSG_EnableThermalInterrupt);\n\t\tif (result != PPSMC_Result_OK) {\n\t\t\tDRM_DEBUG_KMS(\"Could not enable thermal interrupts.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tthermal_int |= THERM_INT_MASK_HIGH | THERM_INT_MASK_LOW;\n\t\tWREG32(CG_THERMAL_INT, thermal_int);\n\t}\n\n\treturn 0;\n}\n\nstatic int si_thermal_set_temperature_range(struct amdgpu_device *adev,\n\t\t\t\t\t    int min_temp, int max_temp)\n{\n\tint low_temp = 0 * 1000;\n\tint high_temp = 255 * 1000;\n\n\tif (low_temp < min_temp)\n\t\tlow_temp = min_temp;\n\tif (high_temp > max_temp)\n\t\thigh_temp = max_temp;\n\tif (high_temp < low_temp) {\n\t\tDRM_ERROR(\"invalid thermal range: %d - %d\\n\", low_temp, high_temp);\n\t\treturn -EINVAL;\n\t}\n\n\tWREG32_P(CG_THERMAL_INT, DIG_THERM_INTH(high_temp / 1000), ~DIG_THERM_INTH_MASK);\n\tWREG32_P(CG_THERMAL_INT, DIG_THERM_INTL(low_temp / 1000), ~DIG_THERM_INTL_MASK);\n\tWREG32_P(CG_THERMAL_CTRL, DIG_THERM_DPM(high_temp / 1000), ~DIG_THERM_DPM_MASK);\n\n\tadev->pm.dpm.thermal.min_temp = low_temp;\n\tadev->pm.dpm.thermal.max_temp = high_temp;\n\n\treturn 0;\n}\n\nstatic void si_fan_ctrl_set_static_mode(struct amdgpu_device *adev, u32 mode)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\n\tif (si_pi->fan_ctrl_is_in_default_mode) {\n\t\ttmp = (RREG32(CG_FDO_CTRL2) & FDO_PWM_MODE_MASK) >> FDO_PWM_MODE_SHIFT;\n\t\tsi_pi->fan_ctrl_default_mode = tmp;\n\t\ttmp = (RREG32(CG_FDO_CTRL2) & TMIN_MASK) >> TMIN_SHIFT;\n\t\tsi_pi->t_min = tmp;\n\t\tsi_pi->fan_ctrl_is_in_default_mode = false;\n\t}\n\n\ttmp = RREG32(CG_FDO_CTRL2) & ~TMIN_MASK;\n\ttmp |= TMIN(0);\n\tWREG32(CG_FDO_CTRL2, tmp);\n\n\ttmp = RREG32(CG_FDO_CTRL2) & ~FDO_PWM_MODE_MASK;\n\ttmp |= FDO_PWM_MODE(mode);\n\tWREG32(CG_FDO_CTRL2, tmp);\n}\n\nstatic int si_thermal_setup_fan_table(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tPP_SIslands_FanTable fan_table = { FDO_MODE_HARDWARE };\n\tu32 duty100;\n\tu32 t_diff1, t_diff2, pwm_diff1, pwm_diff2;\n\tu16 fdo_min, slope1, slope2;\n\tu32 reference_clock, tmp;\n\tint ret;\n\tu64 tmp64;\n\n\tif (!si_pi->fan_table_start) {\n\t\tadev->pm.dpm.fan.ucode_fan_control = false;\n\t\treturn 0;\n\t}\n\n\tduty100 = (RREG32(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;\n\n\tif (duty100 == 0) {\n\t\tadev->pm.dpm.fan.ucode_fan_control = false;\n\t\treturn 0;\n\t}\n\n\ttmp64 = (u64)adev->pm.dpm.fan.pwm_min * duty100;\n\tdo_div(tmp64, 10000);\n\tfdo_min = (u16)tmp64;\n\n\tt_diff1 = adev->pm.dpm.fan.t_med - adev->pm.dpm.fan.t_min;\n\tt_diff2 = adev->pm.dpm.fan.t_high - adev->pm.dpm.fan.t_med;\n\n\tpwm_diff1 = adev->pm.dpm.fan.pwm_med - adev->pm.dpm.fan.pwm_min;\n\tpwm_diff2 = adev->pm.dpm.fan.pwm_high - adev->pm.dpm.fan.pwm_med;\n\n\tslope1 = (u16)((50 + ((16 * duty100 * pwm_diff1) / t_diff1)) / 100);\n\tslope2 = (u16)((50 + ((16 * duty100 * pwm_diff2) / t_diff2)) / 100);\n\n\tfan_table.temp_min = cpu_to_be16((50 + adev->pm.dpm.fan.t_min) / 100);\n\tfan_table.temp_med = cpu_to_be16((50 + adev->pm.dpm.fan.t_med) / 100);\n\tfan_table.temp_max = cpu_to_be16((50 + adev->pm.dpm.fan.t_max) / 100);\n\tfan_table.slope1 = cpu_to_be16(slope1);\n\tfan_table.slope2 = cpu_to_be16(slope2);\n\tfan_table.fdo_min = cpu_to_be16(fdo_min);\n\tfan_table.hys_down = cpu_to_be16(adev->pm.dpm.fan.t_hyst);\n\tfan_table.hys_up = cpu_to_be16(1);\n\tfan_table.hys_slope = cpu_to_be16(1);\n\tfan_table.temp_resp_lim = cpu_to_be16(5);\n\treference_clock = amdgpu_asic_get_xclk(adev);\n\n\tfan_table.refresh_period = cpu_to_be32((adev->pm.dpm.fan.cycle_delay *\n\t\t\t\t\t\treference_clock) / 1600);\n\tfan_table.fdo_max = cpu_to_be16((u16)duty100);\n\n\ttmp = (RREG32(CG_MULT_THERMAL_CTRL) & TEMP_SEL_MASK) >> TEMP_SEL_SHIFT;\n\tfan_table.temp_src = (uint8_t)tmp;\n\n\tret = amdgpu_si_copy_bytes_to_smc(adev,\n\t\t\t\t\t  si_pi->fan_table_start,\n\t\t\t\t\t  (u8 *)(&fan_table),\n\t\t\t\t\t  sizeof(fan_table),\n\t\t\t\t\t  si_pi->sram_end);\n\n\tif (ret) {\n\t\tDRM_ERROR(\"Failed to load fan table to the SMC.\");\n\t\tadev->pm.dpm.fan.ucode_fan_control = false;\n\t}\n\n\treturn ret;\n}\n\nstatic int si_fan_ctrl_start_smc_fan_control(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tPPSMC_Result ret;\n\n\tret = amdgpu_si_send_msg_to_smc(adev, PPSMC_StartFanControl);\n\tif (ret == PPSMC_Result_OK) {\n\t\tsi_pi->fan_is_controlled_by_smc = true;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si_fan_ctrl_stop_smc_fan_control(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tPPSMC_Result ret;\n\n\tret = amdgpu_si_send_msg_to_smc(adev, PPSMC_StopFanControl);\n\n\tif (ret == PPSMC_Result_OK) {\n\t\tsi_pi->fan_is_controlled_by_smc = false;\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int si_dpm_get_fan_speed_pwm(void *handle,\n\t\t\t\t      u32 *speed)\n{\n\tu32 duty, duty100;\n\tu64 tmp64;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\tif (adev->pm.no_fan)\n\t\treturn -ENOENT;\n\n\tduty100 = (RREG32(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;\n\tduty = (RREG32(CG_THERMAL_STATUS) & FDO_PWM_DUTY_MASK) >> FDO_PWM_DUTY_SHIFT;\n\n\tif (duty100 == 0)\n\t\treturn -EINVAL;\n\n\ttmp64 = (u64)duty * 255;\n\tdo_div(tmp64, duty100);\n\t*speed = MIN((u32)tmp64, 255);\n\n\treturn 0;\n}\n\nstatic int si_dpm_set_fan_speed_pwm(void *handle,\n\t\t\t\t      u32 speed)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\tu32 duty, duty100;\n\tu64 tmp64;\n\n\tif (adev->pm.no_fan)\n\t\treturn -ENOENT;\n\n\tif (si_pi->fan_is_controlled_by_smc)\n\t\treturn -EINVAL;\n\n\tif (speed > 255)\n\t\treturn -EINVAL;\n\n\tduty100 = (RREG32(CG_FDO_CTRL1) & FMAX_DUTY100_MASK) >> FMAX_DUTY100_SHIFT;\n\n\tif (duty100 == 0)\n\t\treturn -EINVAL;\n\n\ttmp64 = (u64)speed * duty100;\n\tdo_div(tmp64, 255);\n\tduty = (u32)tmp64;\n\n\ttmp = RREG32(CG_FDO_CTRL0) & ~FDO_STATIC_DUTY_MASK;\n\ttmp |= FDO_STATIC_DUTY(duty);\n\tWREG32(CG_FDO_CTRL0, tmp);\n\n\treturn 0;\n}\n\nstatic int si_dpm_set_fan_control_mode(void *handle, u32 mode)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (mode == U32_MAX)\n\t\treturn -EINVAL;\n\n\tif (mode) {\n\t\t \n\t\tif (adev->pm.dpm.fan.ucode_fan_control)\n\t\t\tsi_fan_ctrl_stop_smc_fan_control(adev);\n\t\tsi_fan_ctrl_set_static_mode(adev, mode);\n\t} else {\n\t\t \n\t\tif (adev->pm.dpm.fan.ucode_fan_control)\n\t\t\tsi_thermal_start_smc_fan_control(adev);\n\t\telse\n\t\t\tsi_fan_ctrl_set_default_mode(adev);\n\t}\n\n\treturn 0;\n}\n\nstatic int si_dpm_get_fan_control_mode(void *handle, u32 *fan_mode)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\n\tif (!fan_mode)\n\t\treturn -EINVAL;\n\n\tif (si_pi->fan_is_controlled_by_smc)\n\t\treturn 0;\n\n\ttmp = RREG32(CG_FDO_CTRL2) & FDO_PWM_MODE_MASK;\n\t*fan_mode = (tmp >> FDO_PWM_MODE_SHIFT);\n\n\treturn 0;\n}\n\n#if 0\nstatic int si_fan_ctrl_get_fan_speed_rpm(struct amdgpu_device *adev,\n\t\t\t\t\t u32 *speed)\n{\n\tu32 tach_period;\n\tu32 xclk = amdgpu_asic_get_xclk(adev);\n\n\tif (adev->pm.no_fan)\n\t\treturn -ENOENT;\n\n\tif (adev->pm.fan_pulses_per_revolution == 0)\n\t\treturn -ENOENT;\n\n\ttach_period = (RREG32(CG_TACH_STATUS) & TACH_PERIOD_MASK) >> TACH_PERIOD_SHIFT;\n\tif (tach_period == 0)\n\t\treturn -ENOENT;\n\n\t*speed = 60 * xclk * 10000 / tach_period;\n\n\treturn 0;\n}\n\nstatic int si_fan_ctrl_set_fan_speed_rpm(struct amdgpu_device *adev,\n\t\t\t\t\t u32 speed)\n{\n\tu32 tach_period, tmp;\n\tu32 xclk = amdgpu_asic_get_xclk(adev);\n\n\tif (adev->pm.no_fan)\n\t\treturn -ENOENT;\n\n\tif (adev->pm.fan_pulses_per_revolution == 0)\n\t\treturn -ENOENT;\n\n\tif ((speed < adev->pm.fan_min_rpm) ||\n\t    (speed > adev->pm.fan_max_rpm))\n\t\treturn -EINVAL;\n\n\tif (adev->pm.dpm.fan.ucode_fan_control)\n\t\tsi_fan_ctrl_stop_smc_fan_control(adev);\n\n\ttach_period = 60 * xclk * 10000 / (8 * speed);\n\ttmp = RREG32(CG_TACH_CTRL) & ~TARGET_PERIOD_MASK;\n\ttmp |= TARGET_PERIOD(tach_period);\n\tWREG32(CG_TACH_CTRL, tmp);\n\n\tsi_fan_ctrl_set_static_mode(adev, FDO_PWM_MODE_STATIC_RPM);\n\n\treturn 0;\n}\n#endif\n\nstatic void si_fan_ctrl_set_default_mode(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tu32 tmp;\n\n\tif (!si_pi->fan_ctrl_is_in_default_mode) {\n\t\ttmp = RREG32(CG_FDO_CTRL2) & ~FDO_PWM_MODE_MASK;\n\t\ttmp |= FDO_PWM_MODE(si_pi->fan_ctrl_default_mode);\n\t\tWREG32(CG_FDO_CTRL2, tmp);\n\n\t\ttmp = RREG32(CG_FDO_CTRL2) & ~TMIN_MASK;\n\t\ttmp |= TMIN(si_pi->t_min);\n\t\tWREG32(CG_FDO_CTRL2, tmp);\n\t\tsi_pi->fan_ctrl_is_in_default_mode = true;\n\t}\n}\n\nstatic void si_thermal_start_smc_fan_control(struct amdgpu_device *adev)\n{\n\tif (adev->pm.dpm.fan.ucode_fan_control) {\n\t\tsi_fan_ctrl_start_smc_fan_control(adev);\n\t\tsi_fan_ctrl_set_static_mode(adev, FDO_PWM_MODE_STATIC);\n\t}\n}\n\nstatic void si_thermal_initialize(struct amdgpu_device *adev)\n{\n\tu32 tmp;\n\n\tif (adev->pm.fan_pulses_per_revolution) {\n\t\ttmp = RREG32(CG_TACH_CTRL) & ~EDGE_PER_REV_MASK;\n\t\ttmp |= EDGE_PER_REV(adev->pm.fan_pulses_per_revolution -1);\n\t\tWREG32(CG_TACH_CTRL, tmp);\n\t}\n\n\ttmp = RREG32(CG_FDO_CTRL2) & ~TACH_PWM_RESP_RATE_MASK;\n\ttmp |= TACH_PWM_RESP_RATE(0x28);\n\tWREG32(CG_FDO_CTRL2, tmp);\n}\n\nstatic int si_thermal_start_thermal_controller(struct amdgpu_device *adev)\n{\n\tint ret;\n\n\tsi_thermal_initialize(adev);\n\tret = si_thermal_set_temperature_range(adev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\n\tif (ret)\n\t\treturn ret;\n\tret = si_thermal_enable_alert(adev, true);\n\tif (ret)\n\t\treturn ret;\n\tif (adev->pm.dpm.fan.ucode_fan_control) {\n\t\tret = si_halt_smc(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = si_thermal_setup_fan_table(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = si_resume_smc(adev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsi_thermal_start_smc_fan_control(adev);\n\t}\n\n\treturn 0;\n}\n\nstatic void si_thermal_stop_thermal_controller(struct amdgpu_device *adev)\n{\n\tif (!adev->pm.no_fan) {\n\t\tsi_fan_ctrl_set_default_mode(adev);\n\t\tsi_fan_ctrl_stop_smc_fan_control(adev);\n\t}\n}\n\nstatic int si_dpm_enable(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct amdgpu_ps *boot_ps = adev->pm.dpm.boot_ps;\n\tint ret;\n\n\tif (amdgpu_si_is_smc_running(adev))\n\t\treturn -EINVAL;\n\tif (pi->voltage_control || si_pi->voltage_control_svi2)\n\t\tsi_enable_voltage_control(adev, true);\n\tif (pi->mvdd_control)\n\t\tsi_get_mvdd_configuration(adev);\n\tif (pi->voltage_control || si_pi->voltage_control_svi2) {\n\t\tret = si_construct_voltage_tables(adev);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"si_construct_voltage_tables failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = si_initialize_mc_reg_table(adev);\n\t\tif (ret)\n\t\t\teg_pi->dynamic_ac_timing = false;\n\t}\n\tif (pi->dynamic_ss)\n\t\tsi_enable_spread_spectrum(adev, true);\n\tif (pi->thermal_protection)\n\t\tsi_enable_thermal_protection(adev, true);\n\tsi_setup_bsp(adev);\n\tsi_program_git(adev);\n\tsi_program_tp(adev);\n\tsi_program_tpp(adev);\n\tsi_program_sstp(adev);\n\tsi_enable_display_gap(adev);\n\tsi_program_vc(adev);\n\tret = si_upload_firmware(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_upload_firmware failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_process_firmware_header(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_process_firmware_header failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_initial_switch_from_arb_f0_to_f1(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_initial_switch_from_arb_f0_to_f1 failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_init_smc_table(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_init_smc_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_init_smc_spll_table(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_init_smc_spll_table failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_init_arb_table_index(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_init_arb_table_index failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = si_populate_mc_reg_table(adev, boot_ps);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"si_populate_mc_reg_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = si_initialize_smc_cac_tables(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_initialize_smc_cac_tables failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_initialize_hardware_cac_manager(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_initialize_hardware_cac_manager failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_initialize_smc_dte_tables(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_initialize_smc_dte_tables failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_populate_smc_tdp_limits(adev, boot_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_populate_smc_tdp_limits failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_populate_smc_tdp_limits_2(adev, boot_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_populate_smc_tdp_limits_2 failed\\n\");\n\t\treturn ret;\n\t}\n\tsi_program_response_times(adev);\n\tsi_program_ds_registers(adev);\n\tsi_dpm_start_smc(adev);\n\tret = si_notify_smc_display_change(adev, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_notify_smc_display_change failed\\n\");\n\t\treturn ret;\n\t}\n\tsi_enable_sclk_control(adev, true);\n\tsi_start_dpm(adev);\n\n\tsi_enable_auto_throttle_source(adev, SI_DPM_AUTO_THROTTLE_SRC_THERMAL, true);\n\tsi_thermal_start_thermal_controller(adev);\n\n\tni_update_current_ps(adev, boot_ps);\n\n\treturn 0;\n}\n\nstatic void si_dpm_disable(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct amdgpu_ps *boot_ps = adev->pm.dpm.boot_ps;\n\n\tif (!amdgpu_si_is_smc_running(adev))\n\t\treturn;\n\tsi_thermal_stop_thermal_controller(adev);\n\tsi_disable_ulv(adev);\n\tsi_clear_vc(adev);\n\tif (pi->thermal_protection)\n\t\tsi_enable_thermal_protection(adev, false);\n\tsi_enable_power_containment(adev, boot_ps, false);\n\tsi_enable_smc_cac(adev, boot_ps, false);\n\tsi_enable_spread_spectrum(adev, false);\n\tsi_enable_auto_throttle_source(adev, SI_DPM_AUTO_THROTTLE_SRC_THERMAL, false);\n\tsi_stop_dpm(adev);\n\tsi_reset_to_default(adev);\n\tsi_dpm_stop_smc(adev);\n\tsi_force_switch_to_arb_f0(adev);\n\n\tni_update_current_ps(adev, boot_ps);\n}\n\nstatic int si_dpm_pre_set_power_state(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct amdgpu_ps requested_ps = *adev->pm.dpm.requested_ps;\n\tstruct amdgpu_ps *new_ps = &requested_ps;\n\n\tni_update_requested_ps(adev, new_ps);\n\tsi_apply_state_adjust_rules(adev, &eg_pi->requested_rps);\n\n\treturn 0;\n}\n\nstatic int si_power_control_set_level(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ps *new_ps = adev->pm.dpm.requested_ps;\n\tint ret;\n\n\tret = si_restrict_performance_levels_before_switch(adev);\n\tif (ret)\n\t\treturn ret;\n\tret = si_halt_smc(adev);\n\tif (ret)\n\t\treturn ret;\n\tret = si_populate_smc_tdp_limits(adev, new_ps);\n\tif (ret)\n\t\treturn ret;\n\tret = si_populate_smc_tdp_limits_2(adev, new_ps);\n\tif (ret)\n\t\treturn ret;\n\tret = si_resume_smc(adev);\n\tif (ret)\n\t\treturn ret;\n\treturn si_set_sw_state(adev);\n}\n\nstatic void si_set_vce_clock(struct amdgpu_device *adev,\n\t\t\t     struct amdgpu_ps *new_rps,\n\t\t\t     struct amdgpu_ps *old_rps)\n{\n\tif ((old_rps->evclk != new_rps->evclk) ||\n\t    (old_rps->ecclk != new_rps->ecclk)) {\n\t\t \n\t\tif (new_rps->evclk || new_rps->ecclk) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t}\n\t}\n}\n\nstatic int si_dpm_set_power_state(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct amdgpu_ps *new_ps = &eg_pi->requested_rps;\n\tstruct amdgpu_ps *old_ps = &eg_pi->current_rps;\n\tint ret;\n\n\tret = si_disable_ulv(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_disable_ulv failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_restrict_performance_levels_before_switch(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_restrict_performance_levels_before_switch failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->pcie_performance_request)\n\t\tsi_request_link_speed_change_before_state_change(adev, new_ps, old_ps);\n\tni_set_uvd_clock_before_set_eng_clock(adev, new_ps, old_ps);\n\tret = si_enable_power_containment(adev, new_ps, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_enable_power_containment failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_enable_smc_cac(adev, new_ps, false);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_enable_smc_cac failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_halt_smc(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_halt_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_upload_sw_state(adev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_upload_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_upload_smc_data(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_upload_smc_data failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_upload_ulv_state(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_upload_ulv_state failed\\n\");\n\t\treturn ret;\n\t}\n\tif (eg_pi->dynamic_ac_timing) {\n\t\tret = si_upload_mc_reg_table(adev, new_ps);\n\t\tif (ret) {\n\t\t\tDRM_ERROR(\"si_upload_mc_reg_table failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = si_program_memory_timing_parameters(adev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_program_memory_timing_parameters failed\\n\");\n\t\treturn ret;\n\t}\n\tsi_set_pcie_lane_width_in_smc(adev, new_ps, old_ps);\n\n\tret = si_resume_smc(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_resume_smc failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_set_sw_state(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_set_sw_state failed\\n\");\n\t\treturn ret;\n\t}\n\tni_set_uvd_clock_after_set_eng_clock(adev, new_ps, old_ps);\n\tsi_set_vce_clock(adev, new_ps, old_ps);\n\tif (eg_pi->pcie_performance_request)\n\t\tsi_notify_link_speed_change_after_state_change(adev, new_ps, old_ps);\n\tret = si_set_power_state_conditionally_enable_ulv(adev, new_ps);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_set_power_state_conditionally_enable_ulv failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_enable_smc_cac(adev, new_ps, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_enable_smc_cac failed\\n\");\n\t\treturn ret;\n\t}\n\tret = si_enable_power_containment(adev, new_ps, true);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_enable_power_containment failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = si_power_control_set_level(adev);\n\tif (ret) {\n\t\tDRM_ERROR(\"si_power_control_set_level failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void si_dpm_post_set_power_state(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct amdgpu_ps *new_ps = &eg_pi->requested_rps;\n\n\tni_update_current_ps(adev, new_ps);\n}\n\n#if 0\nvoid si_dpm_reset_asic(struct amdgpu_device *adev)\n{\n\tsi_restrict_performance_levels_before_switch(adev);\n\tsi_disable_ulv(adev);\n\tsi_set_boot_state(adev);\n}\n#endif\n\nstatic void si_dpm_display_configuration_changed(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tsi_program_display_gap(adev);\n}\n\n\nstatic void si_parse_pplib_non_clock_info(struct amdgpu_device *adev,\n\t\t\t\t\t  struct amdgpu_ps *rps,\n\t\t\t\t\t  struct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\n\t\t\t\t\t  u8 table_rev)\n{\n\trps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\n\trps->class = le16_to_cpu(non_clock_info->usClassification);\n\trps->class2 = le16_to_cpu(non_clock_info->usClassification2);\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\n\t\trps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\n\t\trps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\n\t} else if (r600_is_uvd_state(rps->class, rps->class2)) {\n\t\trps->vclk = RV770_DEFAULT_VCLK_FREQ;\n\t\trps->dclk = RV770_DEFAULT_DCLK_FREQ;\n\t} else {\n\t\trps->vclk = 0;\n\t\trps->dclk = 0;\n\t}\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\tadev->pm.dpm.boot_ps = rps;\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\tadev->pm.dpm.uvd_ps = rps;\n}\n\nstatic void si_parse_pplib_clock_info(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_ps *rps, int index,\n\t\t\t\t      union pplib_clock_info *clock_info)\n{\n\tstruct rv7xx_power_info *pi = rv770_get_pi(adev);\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tstruct  si_ps *ps = si_get_ps(rps);\n\tu16 leakage_voltage;\n\tstruct rv7xx_pl *pl = &ps->performance_levels[index];\n\tint ret;\n\n\tps->performance_level_count = index + 1;\n\n\tpl->sclk = le16_to_cpu(clock_info->si.usEngineClockLow);\n\tpl->sclk |= clock_info->si.ucEngineClockHigh << 16;\n\tpl->mclk = le16_to_cpu(clock_info->si.usMemoryClockLow);\n\tpl->mclk |= clock_info->si.ucMemoryClockHigh << 16;\n\n\tpl->vddc = le16_to_cpu(clock_info->si.usVDDC);\n\tpl->vddci = le16_to_cpu(clock_info->si.usVDDCI);\n\tpl->flags = le32_to_cpu(clock_info->si.ulFlags);\n\tpl->pcie_gen = si_gen_pcie_gen_support(adev,\n\t\t\t\t\t       si_pi->sys_pcie_mask,\n\t\t\t\t\t       si_pi->boot_pcie_gen,\n\t\t\t\t\t       clock_info->si.ucPCIEGen);\n\n\t \n\tret = si_get_leakage_voltage_from_leakage_index(adev, pl->vddc,\n\t\t\t\t\t\t\t&leakage_voltage);\n\tif (ret == 0)\n\t\tpl->vddc = leakage_voltage;\n\n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_ACPI) {\n\t\tpi->acpi_vddc = pl->vddc;\n\t\teg_pi->acpi_vddci = pl->vddci;\n\t\tsi_pi->acpi_pcie_gen = pl->pcie_gen;\n\t}\n\n\tif ((rps->class2 & ATOM_PPLIB_CLASSIFICATION2_ULV) &&\n\t    index == 0) {\n\t\t \n\t\tsi_pi->ulv.supported = false;\n\t\tsi_pi->ulv.pl = *pl;\n\t\tsi_pi->ulv.one_pcie_lane_in_ulv = false;\n\t\tsi_pi->ulv.volt_change_delay = SISLANDS_ULVVOLTAGECHANGEDELAY_DFLT;\n\t\tsi_pi->ulv.cg_ulv_parameter = SISLANDS_CGULVPARAMETER_DFLT;\n\t\tsi_pi->ulv.cg_ulv_control = SISLANDS_CGULVCONTROL_DFLT;\n\t}\n\n\tif (pi->min_vddc_in_table > pl->vddc)\n\t\tpi->min_vddc_in_table = pl->vddc;\n\n\tif (pi->max_vddc_in_table < pl->vddc)\n\t\tpi->max_vddc_in_table = pl->vddc;\n\n\t \n\tif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\n\t\tu16 vddc, vddci, mvdd;\n\t\tamdgpu_atombios_get_default_voltages(adev, &vddc, &vddci, &mvdd);\n\t\tpl->mclk = adev->clock.default_mclk;\n\t\tpl->sclk = adev->clock.default_sclk;\n\t\tpl->vddc = vddc;\n\t\tpl->vddci = vddci;\n\t\tsi_pi->mvdd_bootup_value = mvdd;\n\t}\n\n\tif ((rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==\n\t    ATOM_PPLIB_CLASSIFICATION_UI_PERFORMANCE) {\n\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.sclk = pl->sclk;\n\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.mclk = pl->mclk;\n\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddc = pl->vddc;\n\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_ac.vddci = pl->vddci;\n\t}\n}\n\nunion pplib_power_state {\n\tstruct _ATOM_PPLIB_STATE v1;\n\tstruct _ATOM_PPLIB_STATE_V2 v2;\n};\n\nstatic int si_parse_power_table(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_mode_info *mode_info = &adev->mode_info;\n\tstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\n\tunion pplib_power_state *power_state;\n\tint i, j, k, non_clock_array_index, clock_array_index;\n\tunion pplib_clock_info *clock_info;\n\tstruct _StateArray *state_array;\n\tstruct _ClockInfoArray *clock_info_array;\n\tstruct _NonClockInfoArray *non_clock_info_array;\n\tunion power_info *power_info;\n\tint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\n\tu16 data_offset;\n\tu8 frev, crev;\n\tu8 *power_state_offset;\n\tstruct  si_ps *ps;\n\n\tif (!amdgpu_atom_parse_data_header(mode_info->atom_context, index, NULL,\n\t\t\t\t   &frev, &crev, &data_offset))\n\t\treturn -EINVAL;\n\tpower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\n\n\tamdgpu_add_thermal_controller(adev);\n\n\tstate_array = (struct _StateArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usStateArrayOffset));\n\tclock_info_array = (struct _ClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\n\tnon_clock_info_array = (struct _NonClockInfoArray *)\n\t\t(mode_info->atom_context->bios + data_offset +\n\t\t le16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\n\n\tadev->pm.dpm.ps = kcalloc(state_array->ucNumEntries,\n\t\t\t\t  sizeof(struct amdgpu_ps),\n\t\t\t\t  GFP_KERNEL);\n\tif (!adev->pm.dpm.ps)\n\t\treturn -ENOMEM;\n\tpower_state_offset = (u8 *)state_array->states;\n\tfor (adev->pm.dpm.num_ps = 0, i = 0; i < state_array->ucNumEntries; i++) {\n\t\tu8 *idx;\n\t\tpower_state = (union pplib_power_state *)power_state_offset;\n\t\tnon_clock_array_index = power_state->v2.nonClockInfoIndex;\n\t\tnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\n\t\t\t&non_clock_info_array->nonClockInfo[non_clock_array_index];\n\t\tps = kzalloc(sizeof(struct  si_ps), GFP_KERNEL);\n\t\tif (ps == NULL)\n\t\t\treturn -ENOMEM;\n\t\tadev->pm.dpm.ps[i].ps_priv = ps;\n\t\tsi_parse_pplib_non_clock_info(adev, &adev->pm.dpm.ps[i],\n\t\t\t\t\t      non_clock_info,\n\t\t\t\t\t      non_clock_info_array->ucEntrySize);\n\t\tk = 0;\n\t\tidx = (u8 *)&power_state->v2.clockInfoIndex[0];\n\t\tfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\n\t\t\tclock_array_index = idx[j];\n\t\t\tif (clock_array_index >= clock_info_array->ucNumEntries)\n\t\t\t\tcontinue;\n\t\t\tif (k >= SISLANDS_MAX_HARDWARE_POWERLEVELS)\n\t\t\t\tbreak;\n\t\t\tclock_info = (union pplib_clock_info *)\n\t\t\t\t((u8 *)&clock_info_array->clockInfo[0] +\n\t\t\t\t (clock_array_index * clock_info_array->ucEntrySize));\n\t\t\tsi_parse_pplib_clock_info(adev,\n\t\t\t\t\t\t  &adev->pm.dpm.ps[i], k,\n\t\t\t\t\t\t  clock_info);\n\t\t\tk++;\n\t\t}\n\t\tpower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\n\t\tadev->pm.dpm.num_ps++;\n\t}\n\n\t \n\tfor (i = 0; i < adev->pm.dpm.num_of_vce_states; i++) {\n\t\tu32 sclk, mclk;\n\t\tclock_array_index = adev->pm.dpm.vce_states[i].clk_idx;\n\t\tclock_info = (union pplib_clock_info *)\n\t\t\t&clock_info_array->clockInfo[clock_array_index * clock_info_array->ucEntrySize];\n\t\tsclk = le16_to_cpu(clock_info->si.usEngineClockLow);\n\t\tsclk |= clock_info->si.ucEngineClockHigh << 16;\n\t\tmclk = le16_to_cpu(clock_info->si.usMemoryClockLow);\n\t\tmclk |= clock_info->si.ucMemoryClockHigh << 16;\n\t\tadev->pm.dpm.vce_states[i].sclk = sclk;\n\t\tadev->pm.dpm.vce_states[i].mclk = mclk;\n\t}\n\n\treturn 0;\n}\n\nstatic int si_dpm_init(struct amdgpu_device *adev)\n{\n\tstruct rv7xx_power_info *pi;\n\tstruct evergreen_power_info *eg_pi;\n\tstruct ni_power_info *ni_pi;\n\tstruct si_power_info *si_pi;\n\tstruct atom_clock_dividers dividers;\n\tint ret;\n\n\tsi_pi = kzalloc(sizeof(struct si_power_info), GFP_KERNEL);\n\tif (si_pi == NULL)\n\t\treturn -ENOMEM;\n\tadev->pm.dpm.priv = si_pi;\n\tni_pi = &si_pi->ni;\n\teg_pi = &ni_pi->eg;\n\tpi = &eg_pi->rv7xx;\n\n\tsi_pi->sys_pcie_mask =\n\t\tadev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_MASK;\n\tsi_pi->force_pcie_gen = SI_PCIE_GEN_INVALID;\n\tsi_pi->boot_pcie_gen = si_get_current_pcie_speed(adev);\n\n\tsi_set_max_cu_value(adev);\n\n\trv770_get_max_vddc(adev);\n\tsi_get_leakage_vddc(adev);\n\tsi_patch_dependency_tables_based_on_leakage(adev);\n\n\tpi->acpi_vddc = 0;\n\teg_pi->acpi_vddci = 0;\n\tpi->min_vddc_in_table = 0;\n\tpi->max_vddc_in_table = 0;\n\n\tret = amdgpu_get_platform_caps(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_parse_extended_power_table(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = si_parse_power_table(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries =\n\t\tkcalloc(4,\n\t\t\tsizeof(struct amdgpu_clock_voltage_dependency_entry),\n\t\t\tGFP_KERNEL);\n\tif (!adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries)\n\t\treturn -ENOMEM;\n\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].clk = 36000;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[1].v = 720;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].clk = 54000;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[2].v = 810;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].clk = 72000;\n\tadev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[3].v = 900;\n\n\tif (adev->pm.dpm.voltage_response_time == 0)\n\t\tadev->pm.dpm.voltage_response_time = R600_VOLTAGERESPONSETIME_DFLT;\n\tif (adev->pm.dpm.backbias_response_time == 0)\n\t\tadev->pm.dpm.backbias_response_time = R600_BACKBIASRESPONSETIME_DFLT;\n\n\tret = amdgpu_atombios_get_clock_dividers(adev, COMPUTE_ENGINE_PLL_PARAM,\n\t\t\t\t\t     0, false, &dividers);\n\tif (ret)\n\t\tpi->ref_div = dividers.ref_div + 1;\n\telse\n\t\tpi->ref_div = R600_REFERENCEDIVIDER_DFLT;\n\n\teg_pi->smu_uvd_hs = false;\n\n\tpi->mclk_strobe_mode_threshold = 40000;\n\tif (si_is_special_1gb_platform(adev))\n\t\tpi->mclk_stutter_mode_threshold = 0;\n\telse\n\t\tpi->mclk_stutter_mode_threshold = pi->mclk_strobe_mode_threshold;\n\tpi->mclk_edc_enable_threshold = 40000;\n\teg_pi->mclk_edc_wr_enable_threshold = 40000;\n\n\tni_pi->mclk_rtt_mode_threshold = eg_pi->mclk_edc_wr_enable_threshold;\n\n\tpi->voltage_control =\n\t\tamdgpu_atombios_is_voltage_gpio(adev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t    VOLTAGE_OBJ_GPIO_LUT);\n\tif (!pi->voltage_control) {\n\t\tsi_pi->voltage_control_svi2 =\n\t\t\tamdgpu_atombios_is_voltage_gpio(adev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t\t    VOLTAGE_OBJ_SVID2);\n\t\tif (si_pi->voltage_control_svi2)\n\t\t\tamdgpu_atombios_get_svi2_info(adev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t\t  &si_pi->svd_gpio_id, &si_pi->svc_gpio_id);\n\t}\n\n\tpi->mvdd_control =\n\t\tamdgpu_atombios_is_voltage_gpio(adev, SET_VOLTAGE_TYPE_ASIC_MVDDC,\n\t\t\t\t\t    VOLTAGE_OBJ_GPIO_LUT);\n\n\teg_pi->vddci_control =\n\t\tamdgpu_atombios_is_voltage_gpio(adev, SET_VOLTAGE_TYPE_ASIC_VDDCI,\n\t\t\t\t\t    VOLTAGE_OBJ_GPIO_LUT);\n\tif (!eg_pi->vddci_control)\n\t\tsi_pi->vddci_control_svi2 =\n\t\t\tamdgpu_atombios_is_voltage_gpio(adev, SET_VOLTAGE_TYPE_ASIC_VDDCI,\n\t\t\t\t\t\t    VOLTAGE_OBJ_SVID2);\n\n\tsi_pi->vddc_phase_shed_control =\n\t\tamdgpu_atombios_is_voltage_gpio(adev, SET_VOLTAGE_TYPE_ASIC_VDDC,\n\t\t\t\t\t    VOLTAGE_OBJ_PHASE_LUT);\n\n\trv770_get_engine_memory_ss(adev);\n\n\tpi->asi = RV770_ASI_DFLT;\n\tpi->pasi = CYPRESS_HASI_DFLT;\n\tpi->vrc = SISLANDS_VRC_DFLT;\n\n\tpi->gfx_clock_gating = true;\n\n\teg_pi->sclk_deep_sleep = true;\n\tsi_pi->sclk_deep_sleep_above_low = false;\n\n\tif (adev->pm.int_thermal_type != THERMAL_TYPE_NONE)\n\t\tpi->thermal_protection = true;\n\telse\n\t\tpi->thermal_protection = false;\n\n\teg_pi->dynamic_ac_timing = true;\n\n\teg_pi->light_sleep = true;\n#if defined(CONFIG_ACPI)\n\teg_pi->pcie_performance_request =\n\t\tamdgpu_acpi_is_pcie_performance_request_supported(adev);\n#else\n\teg_pi->pcie_performance_request = false;\n#endif\n\n\tsi_pi->sram_end = SMC_RAM_END;\n\n\tadev->pm.dpm.dyn_state.mclk_sclk_ratio = 4;\n\tadev->pm.dpm.dyn_state.sclk_mclk_delta = 15000;\n\tadev->pm.dpm.dyn_state.vddc_vddci_delta = 200;\n\tadev->pm.dpm.dyn_state.valid_sclk_values.count = 0;\n\tadev->pm.dpm.dyn_state.valid_sclk_values.values = NULL;\n\tadev->pm.dpm.dyn_state.valid_mclk_values.count = 0;\n\tadev->pm.dpm.dyn_state.valid_mclk_values.values = NULL;\n\n\tsi_initialize_powertune_defaults(adev);\n\n\t \n\tif ((adev->pm.dpm.dyn_state.max_clock_voltage_on_dc.sclk == 0) ||\n\t    (adev->pm.dpm.dyn_state.max_clock_voltage_on_dc.mclk == 0))\n\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_dc =\n\t\t\tadev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\n\n\tsi_pi->fan_ctrl_is_in_default_mode = true;\n\n\treturn 0;\n}\n\nstatic void si_dpm_fini(struct amdgpu_device *adev)\n{\n\tint i;\n\n\tif (adev->pm.dpm.ps)\n\t\tfor (i = 0; i < adev->pm.dpm.num_ps; i++)\n\t\t\tkfree(adev->pm.dpm.ps[i].ps_priv);\n\tkfree(adev->pm.dpm.ps);\n\tkfree(adev->pm.dpm.priv);\n\tkfree(adev->pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries);\n\tamdgpu_free_extended_power_table(adev);\n}\n\nstatic void si_dpm_debugfs_print_current_performance_level(void *handle,\n\t\t\t\t\t\t    struct seq_file *m)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct amdgpu_ps *rps = &eg_pi->current_rps;\n\tstruct  si_ps *ps = si_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tu32 current_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_INDEX_MASK) >>\n\t\tCURRENT_STATE_INDEX_SHIFT;\n\n\tif (current_index >= ps->performance_level_count) {\n\t\tseq_printf(m, \"invalid dpm profile %d\\n\", current_index);\n\t} else {\n\t\tpl = &ps->performance_levels[current_index];\n\t\tseq_printf(m, \"uvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\t\tseq_printf(m, \"power level %d    sclk: %u mclk: %u vddc: %u vddci: %u pcie gen: %u\\n\",\n\t\t\t   current_index, pl->sclk, pl->mclk, pl->vddc, pl->vddci, pl->pcie_gen + 1);\n\t}\n}\n\nstatic int si_dpm_set_interrupt_state(struct amdgpu_device *adev,\n\t\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t\t      unsigned type,\n\t\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tu32 cg_thermal_int;\n\n\tswitch (type) {\n\tcase AMDGPU_THERMAL_IRQ_LOW_TO_HIGH:\n\t\tswitch (state) {\n\t\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\t\tcg_thermal_int = RREG32_SMC(CG_THERMAL_INT);\n\t\t\tcg_thermal_int |= THERM_INT_MASK_HIGH;\n\t\t\tWREG32_SMC(CG_THERMAL_INT, cg_thermal_int);\n\t\t\tbreak;\n\t\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\t\tcg_thermal_int = RREG32_SMC(CG_THERMAL_INT);\n\t\t\tcg_thermal_int &= ~THERM_INT_MASK_HIGH;\n\t\t\tWREG32_SMC(CG_THERMAL_INT, cg_thermal_int);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase AMDGPU_THERMAL_IRQ_HIGH_TO_LOW:\n\t\tswitch (state) {\n\t\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\t\tcg_thermal_int = RREG32_SMC(CG_THERMAL_INT);\n\t\t\tcg_thermal_int |= THERM_INT_MASK_LOW;\n\t\t\tWREG32_SMC(CG_THERMAL_INT, cg_thermal_int);\n\t\t\tbreak;\n\t\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\t\tcg_thermal_int = RREG32_SMC(CG_THERMAL_INT);\n\t\t\tcg_thermal_int &= ~THERM_INT_MASK_LOW;\n\t\t\tWREG32_SMC(CG_THERMAL_INT, cg_thermal_int);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int si_dpm_process_interrupt(struct amdgpu_device *adev,\n\t\t\t\t    struct amdgpu_irq_src *source,\n\t\t\t\t    struct amdgpu_iv_entry *entry)\n{\n\tbool queue_thermal = false;\n\n\tif (entry == NULL)\n\t\treturn -EINVAL;\n\n\tswitch (entry->src_id) {\n\tcase 230:  \n\t\tDRM_DEBUG(\"IH: thermal low to high\\n\");\n\t\tadev->pm.dpm.thermal.high_to_low = false;\n\t\tqueue_thermal = true;\n\t\tbreak;\n\tcase 231:  \n\t\tDRM_DEBUG(\"IH: thermal high to low\\n\");\n\t\tadev->pm.dpm.thermal.high_to_low = true;\n\t\tqueue_thermal = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (queue_thermal)\n\t\tschedule_work(&adev->pm.dpm.thermal.work);\n\n\treturn 0;\n}\n\nstatic int si_dpm_late_init(void *handle)\n{\n\treturn 0;\n}\n\n \nstatic int si_dpm_init_microcode(struct amdgpu_device *adev)\n{\n\tconst char *chip_name;\n\tchar fw_name[30];\n\tint err;\n\n\tDRM_DEBUG(\"\\n\");\n\tswitch (adev->asic_type) {\n\tcase CHIP_TAHITI:\n\t\tchip_name = \"tahiti\";\n\t\tbreak;\n\tcase CHIP_PITCAIRN:\n\t\tif ((adev->pdev->revision == 0x81) &&\n\t\t    ((adev->pdev->device == 0x6810) ||\n\t\t    (adev->pdev->device == 0x6811)))\n\t\t\tchip_name = \"pitcairn_k\";\n\t\telse\n\t\t\tchip_name = \"pitcairn\";\n\t\tbreak;\n\tcase CHIP_VERDE:\n\t\tif (((adev->pdev->device == 0x6820) &&\n\t\t\t((adev->pdev->revision == 0x81) ||\n\t\t\t(adev->pdev->revision == 0x83))) ||\n\t\t    ((adev->pdev->device == 0x6821) &&\n\t\t\t((adev->pdev->revision == 0x83) ||\n\t\t\t(adev->pdev->revision == 0x87))) ||\n\t\t    ((adev->pdev->revision == 0x87) &&\n\t\t\t((adev->pdev->device == 0x6823) ||\n\t\t\t(adev->pdev->device == 0x682b))))\n\t\t\tchip_name = \"verde_k\";\n\t\telse\n\t\t\tchip_name = \"verde\";\n\t\tbreak;\n\tcase CHIP_OLAND:\n\t\tif (((adev->pdev->revision == 0x81) &&\n\t\t\t((adev->pdev->device == 0x6600) ||\n\t\t\t(adev->pdev->device == 0x6604) ||\n\t\t\t(adev->pdev->device == 0x6605) ||\n\t\t\t(adev->pdev->device == 0x6610))) ||\n\t\t    ((adev->pdev->revision == 0x83) &&\n\t\t\t(adev->pdev->device == 0x6610)))\n\t\t\tchip_name = \"oland_k\";\n\t\telse\n\t\t\tchip_name = \"oland\";\n\t\tbreak;\n\tcase CHIP_HAINAN:\n\t\tif (((adev->pdev->revision == 0x81) &&\n\t\t\t(adev->pdev->device == 0x6660)) ||\n\t\t    ((adev->pdev->revision == 0x83) &&\n\t\t\t((adev->pdev->device == 0x6660) ||\n\t\t\t(adev->pdev->device == 0x6663) ||\n\t\t\t(adev->pdev->device == 0x6665) ||\n\t\t\t (adev->pdev->device == 0x6667))))\n\t\t\tchip_name = \"hainan_k\";\n\t\telse if ((adev->pdev->revision == 0xc3) &&\n\t\t\t (adev->pdev->device == 0x6665))\n\t\t\tchip_name = \"banks_k_2\";\n\t\telse\n\t\t\tchip_name = \"hainan\";\n\t\tbreak;\n\tdefault: BUG();\n\t}\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s_smc.bin\", chip_name);\n\terr = amdgpu_ucode_request(adev, &adev->pm.fw, fw_name);\n\tif (err) {\n\t\tDRM_ERROR(\"si_smc: Failed to load firmware. err = %d\\\"%s\\\"\\n\",\n\t\t\t  err, fw_name);\n\t\tamdgpu_ucode_release(&adev->pm.fw);\n\t}\n\treturn err;\n}\n\nstatic int si_dpm_sw_init(void *handle)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tret = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, 230, &adev->pm.dpm.thermal.irq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_irq_add_id(adev, AMDGPU_IRQ_CLIENTID_LEGACY, 231, &adev->pm.dpm.thermal.irq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tadev->pm.dpm.state = POWER_STATE_TYPE_BALANCED;\n\tadev->pm.dpm.user_state = POWER_STATE_TYPE_BALANCED;\n\tadev->pm.dpm.forced_level = AMD_DPM_FORCED_LEVEL_AUTO;\n\tadev->pm.default_sclk = adev->clock.default_sclk;\n\tadev->pm.default_mclk = adev->clock.default_mclk;\n\tadev->pm.current_sclk = adev->clock.default_sclk;\n\tadev->pm.current_mclk = adev->clock.default_mclk;\n\tadev->pm.int_thermal_type = THERMAL_TYPE_NONE;\n\n\tif (amdgpu_dpm == 0)\n\t\treturn 0;\n\n\tret = si_dpm_init_microcode(adev);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&adev->pm.dpm.thermal.work, amdgpu_dpm_thermal_work_handler);\n\tret = si_dpm_init(adev);\n\tif (ret)\n\t\tgoto dpm_failed;\n\tadev->pm.dpm.current_ps = adev->pm.dpm.requested_ps = adev->pm.dpm.boot_ps;\n\tif (amdgpu_dpm == 1)\n\t\tamdgpu_pm_print_power_states(adev);\n\tDRM_INFO(\"amdgpu: dpm initialized\\n\");\n\n\treturn 0;\n\ndpm_failed:\n\tsi_dpm_fini(adev);\n\tDRM_ERROR(\"amdgpu: dpm initialization failed\\n\");\n\treturn ret;\n}\n\nstatic int si_dpm_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tflush_work(&adev->pm.dpm.thermal.work);\n\n\tsi_dpm_fini(adev);\n\n\treturn 0;\n}\n\nstatic int si_dpm_hw_init(void *handle)\n{\n\tint ret;\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (!amdgpu_dpm)\n\t\treturn 0;\n\n\tsi_dpm_setup_asic(adev);\n\tret = si_dpm_enable(adev);\n\tif (ret)\n\t\tadev->pm.dpm_enabled = false;\n\telse\n\t\tadev->pm.dpm_enabled = true;\n\tamdgpu_legacy_dpm_compute_clocks(adev);\n\treturn ret;\n}\n\nstatic int si_dpm_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->pm.dpm_enabled)\n\t\tsi_dpm_disable(adev);\n\n\treturn 0;\n}\n\nstatic int si_dpm_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->pm.dpm_enabled) {\n\t\t \n\t\tsi_dpm_disable(adev);\n\t\t \n\t\tadev->pm.dpm.current_ps = adev->pm.dpm.requested_ps = adev->pm.dpm.boot_ps;\n\t}\n\treturn 0;\n}\n\nstatic int si_dpm_resume(void *handle)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->pm.dpm_enabled) {\n\t\t \n\t\tsi_dpm_setup_asic(adev);\n\t\tret = si_dpm_enable(adev);\n\t\tif (ret)\n\t\t\tadev->pm.dpm_enabled = false;\n\t\telse\n\t\t\tadev->pm.dpm_enabled = true;\n\t\tif (adev->pm.dpm_enabled)\n\t\t\tamdgpu_legacy_dpm_compute_clocks(adev);\n\t}\n\treturn 0;\n}\n\nstatic bool si_dpm_is_idle(void *handle)\n{\n\t \n\treturn true;\n}\n\nstatic int si_dpm_wait_for_idle(void *handle)\n{\n\t \n\treturn 0;\n}\n\nstatic int si_dpm_soft_reset(void *handle)\n{\n\treturn 0;\n}\n\nstatic int si_dpm_set_clockgating_state(void *handle,\n\t\t\t\t\tenum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int si_dpm_set_powergating_state(void *handle,\n\t\t\t\t\tenum amd_powergating_state state)\n{\n\treturn 0;\n}\n\n \nstatic int si_dpm_get_temp(void *handle)\n{\n\tu32 temp;\n\tint actual_temp = 0;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\ttemp = (RREG32(CG_MULT_THERMAL_STATUS) & CTF_TEMP_MASK) >>\n\t\tCTF_TEMP_SHIFT;\n\n\tif (temp & 0x200)\n\t\tactual_temp = 255;\n\telse\n\t\tactual_temp = temp & 0x1ff;\n\n\tactual_temp = (actual_temp * 1000);\n\n\treturn actual_temp;\n}\n\nstatic u32 si_dpm_get_sclk(void *handle, bool low)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct  si_ps *requested_state = si_get_ps(&eg_pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->performance_levels[0].sclk;\n\telse\n\t\treturn requested_state->performance_levels[requested_state->performance_level_count - 1].sclk;\n}\n\nstatic u32 si_dpm_get_mclk(void *handle, bool low)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct  si_ps *requested_state = si_get_ps(&eg_pi->requested_rps);\n\n\tif (low)\n\t\treturn requested_state->performance_levels[0].mclk;\n\telse\n\t\treturn requested_state->performance_levels[requested_state->performance_level_count - 1].mclk;\n}\n\nstatic void si_dpm_print_power_state(void *handle,\n\t\t\t\t     void *current_ps)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct amdgpu_ps *rps = (struct amdgpu_ps *)current_ps;\n\tstruct  si_ps *ps = si_get_ps(rps);\n\tstruct rv7xx_pl *pl;\n\tint i;\n\n\tamdgpu_dpm_print_class_info(rps->class, rps->class2);\n\tamdgpu_dpm_print_cap_info(rps->caps);\n\tDRM_INFO(\"\\tuvd    vclk: %d dclk: %d\\n\", rps->vclk, rps->dclk);\n\tfor (i = 0; i < ps->performance_level_count; i++) {\n\t\tpl = &ps->performance_levels[i];\n\t\tif (adev->asic_type >= CHIP_TAHITI)\n\t\t\tDRM_INFO(\"\\t\\tpower level %d    sclk: %u mclk: %u vddc: %u vddci: %u pcie gen: %u\\n\",\n\t\t\t\t i, pl->sclk, pl->mclk, pl->vddc, pl->vddci, pl->pcie_gen + 1);\n\t\telse\n\t\t\tDRM_INFO(\"\\t\\tpower level %d    sclk: %u mclk: %u vddc: %u vddci: %u\\n\",\n\t\t\t\t i, pl->sclk, pl->mclk, pl->vddc, pl->vddci);\n\t}\n\tamdgpu_dpm_print_ps_status(adev, rps);\n}\n\nstatic int si_dpm_early_init(void *handle)\n{\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->powerplay.pp_funcs = &si_dpm_funcs;\n\tadev->powerplay.pp_handle = adev;\n\tsi_dpm_set_irq_funcs(adev);\n\treturn 0;\n}\n\nstatic inline bool si_are_power_levels_equal(const struct rv7xx_pl  *si_cpl1,\n\t\t\t\t\t\tconst struct rv7xx_pl *si_cpl2)\n{\n\treturn ((si_cpl1->mclk == si_cpl2->mclk) &&\n\t\t  (si_cpl1->sclk == si_cpl2->sclk) &&\n\t\t  (si_cpl1->pcie_gen == si_cpl2->pcie_gen) &&\n\t\t  (si_cpl1->vddc == si_cpl2->vddc) &&\n\t\t  (si_cpl1->vddci == si_cpl2->vddci));\n}\n\nstatic int si_check_state_equal(void *handle,\n\t\t\t\tvoid *current_ps,\n\t\t\t\tvoid *request_ps,\n\t\t\t\tbool *equal)\n{\n\tstruct si_ps *si_cps;\n\tstruct si_ps *si_rps;\n\tint i;\n\tstruct amdgpu_ps *cps = (struct amdgpu_ps *)current_ps;\n\tstruct amdgpu_ps *rps = (struct amdgpu_ps *)request_ps;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev == NULL || cps == NULL || rps == NULL || equal == NULL)\n\t\treturn -EINVAL;\n\n\tsi_cps = si_get_ps((struct amdgpu_ps *)cps);\n\tsi_rps = si_get_ps((struct amdgpu_ps *)rps);\n\n\tif (si_cps == NULL) {\n\t\tprintk(\"si_cps is NULL\\n\");\n\t\t*equal = false;\n\t\treturn 0;\n\t}\n\n\tif (si_cps->performance_level_count != si_rps->performance_level_count) {\n\t\t*equal = false;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < si_cps->performance_level_count; i++) {\n\t\tif (!si_are_power_levels_equal(&(si_cps->performance_levels[i]),\n\t\t\t\t\t&(si_rps->performance_levels[i]))) {\n\t\t\t*equal = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\t*equal = ((cps->vclk == rps->vclk) && (cps->dclk == rps->dclk));\n\t*equal &= ((cps->evclk == rps->evclk) && (cps->ecclk == rps->ecclk));\n\n\treturn 0;\n}\n\nstatic int si_dpm_read_sensor(void *handle, int idx,\n\t\t\t      void *value, int *size)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tstruct evergreen_power_info *eg_pi = evergreen_get_pi(adev);\n\tstruct amdgpu_ps *rps = &eg_pi->current_rps;\n\tstruct  si_ps *ps = si_get_ps(rps);\n\tuint32_t sclk, mclk;\n\tu32 pl_index =\n\t\t(RREG32(TARGET_AND_CURRENT_PROFILE_INDEX) & CURRENT_STATE_INDEX_MASK) >>\n\t\tCURRENT_STATE_INDEX_SHIFT;\n\n\t \n\tif (*size < 4)\n\t\treturn -EINVAL;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tif (pl_index < ps->performance_level_count) {\n\t\t\tsclk = ps->performance_levels[pl_index].sclk;\n\t\t\t*((uint32_t *)value) = sclk;\n\t\t\t*size = 4;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tif (pl_index < ps->performance_level_count) {\n\t\t\tmclk = ps->performance_levels[pl_index].mclk;\n\t\t\t*((uint32_t *)value) = mclk;\n\t\t\t*size = 4;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\tcase AMDGPU_PP_SENSOR_GPU_TEMP:\n\t\t*((uint32_t *)value) = si_dpm_get_temp(adev);\n\t\t*size = 4;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct amd_ip_funcs si_dpm_ip_funcs = {\n\t.name = \"si_dpm\",\n\t.early_init = si_dpm_early_init,\n\t.late_init = si_dpm_late_init,\n\t.sw_init = si_dpm_sw_init,\n\t.sw_fini = si_dpm_sw_fini,\n\t.hw_init = si_dpm_hw_init,\n\t.hw_fini = si_dpm_hw_fini,\n\t.suspend = si_dpm_suspend,\n\t.resume = si_dpm_resume,\n\t.is_idle = si_dpm_is_idle,\n\t.wait_for_idle = si_dpm_wait_for_idle,\n\t.soft_reset = si_dpm_soft_reset,\n\t.set_clockgating_state = si_dpm_set_clockgating_state,\n\t.set_powergating_state = si_dpm_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version si_smu_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_SMC,\n\t.major = 6,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &si_dpm_ip_funcs,\n};\n\nstatic const struct amd_pm_funcs si_dpm_funcs = {\n\t.pre_set_power_state = &si_dpm_pre_set_power_state,\n\t.set_power_state = &si_dpm_set_power_state,\n\t.post_set_power_state = &si_dpm_post_set_power_state,\n\t.display_configuration_changed = &si_dpm_display_configuration_changed,\n\t.get_sclk = &si_dpm_get_sclk,\n\t.get_mclk = &si_dpm_get_mclk,\n\t.print_power_state = &si_dpm_print_power_state,\n\t.debugfs_print_current_performance_level = &si_dpm_debugfs_print_current_performance_level,\n\t.force_performance_level = &si_dpm_force_performance_level,\n\t.vblank_too_short = &si_dpm_vblank_too_short,\n\t.set_fan_control_mode = &si_dpm_set_fan_control_mode,\n\t.get_fan_control_mode = &si_dpm_get_fan_control_mode,\n\t.set_fan_speed_pwm = &si_dpm_set_fan_speed_pwm,\n\t.get_fan_speed_pwm = &si_dpm_get_fan_speed_pwm,\n\t.check_state_equal = &si_check_state_equal,\n\t.get_vce_clock_state = amdgpu_get_vce_clock_state,\n\t.read_sensor = &si_dpm_read_sensor,\n\t.pm_compute_clocks = amdgpu_legacy_dpm_compute_clocks,\n};\n\nstatic const struct amdgpu_irq_src_funcs si_dpm_irq_funcs = {\n\t.set = si_dpm_set_interrupt_state,\n\t.process = si_dpm_process_interrupt,\n};\n\nstatic void si_dpm_set_irq_funcs(struct amdgpu_device *adev)\n{\n\tadev->pm.dpm.thermal.irq.num_types = AMDGPU_THERMAL_IRQ_LAST;\n\tadev->pm.dpm.thermal.irq.funcs = &si_dpm_irq_funcs;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}