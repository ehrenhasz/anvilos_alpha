{
  "module_name": "smu_v12_0.c",
  "hash_id": "8b610e58d6c7b7aaa66252ce66112b626daa886d9c32ba6604ed564fb5fd51c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu12/smu_v12_0.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L3\n\n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v12_0.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"smu_cmn.h\"\n\n#include \"asic_reg/mp/mp_12_0_0_offset.h\"\n#include \"asic_reg/mp/mp_12_0_0_sh_mask.h\"\n#include \"asic_reg/smuio/smuio_12_0_0_offset.h\"\n#include \"asic_reg/smuio/smuio_12_0_0_sh_mask.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n\n\n\n#undef mmPWR_MISC_CNTL_STATUS\n\n#define smnMP1_FIRMWARE_FLAGS                                0x3010024\n\nint smu_v12_0_check_fw_status(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t mp1_fw_flags;\n\n\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t(smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\n\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t\tMP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint smu_v12_0_check_fw_version(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t if_version = 0xff, smu_version = 0xff;\n\tuint8_t smu_program, smu_major, smu_minor, smu_debug;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_program = (smu_version >> 24) & 0xff;\n\tsmu_major = (smu_version >> 16) & 0xff;\n\tsmu_minor = (smu_version >> 8) & 0xff;\n\tsmu_debug = (smu_version >> 0) & 0xff;\n\tif (smu->is_apu)\n\t\tadev->pm.fw_version = smu_version;\n\n\t \n\tif (if_version != smu->smc_driver_if_version) {\n\t\tdev_info(smu->adev->dev, \"smu driver if version = 0x%08x, smu fw if version = 0x%08x, \"\n\t\t\t\"smu fw program = %d, smu fw version = 0x%08x (%d.%d.%d)\\n\",\n\t\t\tsmu->smc_driver_if_version, if_version,\n\t\t\tsmu_program, smu_version, smu_major, smu_minor, smu_debug);\n\t\tdev_info(smu->adev->dev, \"SMU driver if version not matched\\n\");\n\t}\n\n\treturn ret;\n}\n\nint smu_v12_0_powergate_sdma(struct smu_context *smu, bool gate)\n{\n\tif (!smu->is_apu)\n\t\treturn 0;\n\n\tif (gate)\n\t\treturn smu_cmn_send_smc_msg(smu, SMU_MSG_PowerDownSdma, NULL);\n\telse\n\t\treturn smu_cmn_send_smc_msg(smu, SMU_MSG_PowerUpSdma, NULL);\n}\n\nint smu_v12_0_set_gfx_cgpg(struct smu_context *smu, bool enable)\n{\n\t \n\tif (!(smu->adev->pg_flags & AMD_PG_SUPPORT_GFX_PG) || smu->adev->in_s0ix)\n\t\treturn 0;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\tSMU_MSG_SetGfxCGPG,\n\t\tenable ? 1 : 0,\n\t\tNULL);\n}\n\n \nuint32_t smu_v12_0_get_gfxoff_status(struct smu_context *smu)\n{\n\tuint32_t reg;\n\tuint32_t gfxOff_Status = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treg = RREG32_SOC15(SMUIO, 0, mmSMUIO_GFX_MISC_CNTL);\n\tgfxOff_Status = (reg & SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS_MASK)\n\t\t>> SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS__SHIFT;\n\n\treturn gfxOff_Status;\n}\n\nint smu_v12_0_gfx_off_control(struct smu_context *smu, bool enable)\n{\n\tint ret = 0, timeout = 500;\n\n\tif (enable) {\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_AllowGfxOff, NULL);\n\n\t} else {\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_DisallowGfxOff, NULL);\n\n\t\t \n\t\twhile (!(smu_v12_0_get_gfxoff_status(smu) == 2)) {\n\t\t\tmsleep(1);\n\t\t\ttimeout--;\n\t\t\tif (timeout == 0) {\n\t\t\t\tDRM_ERROR(\"disable gfxoff timeout and failed!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint smu_v12_0_fini_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\tkfree(smu_table->clocks_table);\n\tsmu_table->clocks_table = NULL;\n\n\tkfree(smu_table->metrics_table);\n\tsmu_table->metrics_table = NULL;\n\n\tkfree(smu_table->watermarks_table);\n\tsmu_table->watermarks_table = NULL;\n\n\tkfree(smu_table->gpu_metrics_table);\n\tsmu_table->gpu_metrics_table = NULL;\n\n\treturn 0;\n}\n\nint smu_v12_0_set_default_dpm_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\treturn smu_cmn_update_table(smu, SMU_TABLE_DPMCLOCKS, 0, smu_table->clocks_table, false);\n}\n\nint smu_v12_0_mode2_reset(struct smu_context *smu)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GfxDeviceDriverReset, SMU_RESET_MODE_2, NULL);\n}\n\nint smu_v12_0_set_soft_freq_limited_range(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t    uint32_t min, uint32_t max)\n{\n\tint ret = 0;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinGfxClk, min, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk, max, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\tbreak;\n\tcase SMU_FCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinFclkByFreq, min, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxFclkByFreq, max, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\tbreak;\n\tcase SMU_SOCCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinSocclkByFreq, min, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxSocclkByFreq, max, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\tbreak;\n\tcase SMU_VCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinVcn, min, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxVcn, max, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nint smu_v12_0_set_driver_table_location(struct smu_context *smu)\n{\n\tstruct smu_table *driver_table = &smu->smu_table.driver_table;\n\tint ret = 0;\n\n\tif (driver_table->mc_address) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetDriverDramAddrHigh,\n\t\t\t\tupper_32_bits(driver_table->mc_address),\n\t\t\t\tNULL);\n\t\tif (!ret)\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetDriverDramAddrLow,\n\t\t\t\tlower_32_bits(driver_table->mc_address),\n\t\t\t\tNULL);\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v12_0_atom_get_smu_clockinfo(struct amdgpu_device *adev,\n\t\t\t\t\t    uint8_t clk_id,\n\t\t\t\t\t    uint8_t syspll_id,\n\t\t\t\t\t    uint32_t *clk_freq)\n{\n\tstruct atom_get_smu_clock_info_parameters_v3_1 input = {0};\n\tstruct atom_get_smu_clock_info_output_parameters_v3_1 *output;\n\tint ret, index;\n\n\tinput.clk_id = clk_id;\n\tinput.syspll_id = syspll_id;\n\tinput.command = GET_SMU_CLOCK_INFO_V3_1_GET_CLOCK_FREQ;\n\tindex = get_index_into_master_table(atom_master_list_of_command_functions_v2_1,\n\t\t\t\t\t    getsmuclockinfo);\n\n\tret = amdgpu_atom_execute_table(adev->mode_info.atom_context, index,\n\t\t\t\t\t(uint32_t *)&input);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\toutput = (struct atom_get_smu_clock_info_output_parameters_v3_1 *)&input;\n\t*clk_freq = le32_to_cpu(output->atom_smu_outputclkfreq.smu_clock_freq_hz) / 10000;\n\n\treturn 0;\n}\n\nint smu_v12_0_get_vbios_bootup_values(struct smu_context *smu)\n{\n\tint ret, index;\n\tuint16_t size;\n\tuint8_t frev, crev;\n\tstruct atom_common_table_header *header;\n\tstruct atom_firmware_info_v3_1 *v_3_1;\n\tstruct atom_firmware_info_v3_3 *v_3_3;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    firmwareinfo);\n\n\tret = amdgpu_atombios_get_data_table(smu->adev, index, &size, &frev, &crev,\n\t\t\t\t      (uint8_t **)&header);\n\tif (ret)\n\t\treturn ret;\n\n\tif (header->format_revision != 3) {\n\t\tdev_err(smu->adev->dev, \"unknown atom_firmware_info version! for smu12\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (header->content_revision) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tv_3_1 = (struct atom_firmware_info_v3_1 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_1->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_1->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_1->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_1->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_1->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_1->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_1->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_1->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = 0;\n\t\tsmu->smu_table.boot_values.firmware_caps = v_3_1->firmware_capability;\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\tdefault:\n\t\tv_3_3 = (struct atom_firmware_info_v3_3 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_3->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_3->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_3->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_3->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_3->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_3->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_3->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_3->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = v_3_3->pplib_pptable_id;\n\t\tsmu->smu_table.boot_values.firmware_caps = v_3_3->firmware_capability;\n\t}\n\n\tsmu->smu_table.boot_values.format_revision = header->format_revision;\n\tsmu->smu_table.boot_values.content_revision = header->content_revision;\n\n\tsmu_v12_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_SOCCLK_ID,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_ID,\n\t\t\t\t\t &smu->smu_table.boot_values.socclk);\n\n\tsmu_v12_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL1_DCFCLK_ID,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL1_ID,\n\t\t\t\t\t &smu->smu_table.boot_values.dcefclk);\n\n\tsmu_v12_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_VCLK_ID,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_ID,\n\t\t\t\t\t &smu->smu_table.boot_values.vclk);\n\n\tsmu_v12_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_DCLK_ID,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_ID,\n\t\t\t\t\t &smu->smu_table.boot_values.dclk);\n\n\tif ((smu->smu_table.boot_values.format_revision == 3) &&\n\t    (smu->smu_table.boot_values.content_revision >= 2))\n\t\tsmu_v12_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t\t (uint8_t)SMU12_SYSPLL3_0_FCLK_ID,\n\t\t\t\t\t\t (uint8_t)SMU12_SYSPLL3_0_ID,\n\t\t\t\t\t\t &smu->smu_table.boot_values.fclk);\n\n\tsmu_v12_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_LCLK_ID,\n\t\t\t\t\t (uint8_t)SMU12_SYSPLL0_ID,\n\t\t\t\t\t &smu->smu_table.boot_values.lclk);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}