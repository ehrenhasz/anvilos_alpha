{
  "module_name": "smu_v11_0.h",
  "hash_id": "f6c8bbfcb4452f648e9415ddd515e0b2a57f7ced302dcdf07a77edfc5a21acea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/inc/smu_v11_0.h",
  "human_readable_source": " \n#ifndef __SMU_V11_0_H__\n#define __SMU_V11_0_H__\n\n#include \"amdgpu_smu.h\"\n\n#define SMU11_DRIVER_IF_VERSION_INV 0xFFFFFFFF\n#define SMU11_DRIVER_IF_VERSION_ARCT 0x17\n#define SMU11_DRIVER_IF_VERSION_NV10 0x37\n#define SMU11_DRIVER_IF_VERSION_NV12 0x38\n#define SMU11_DRIVER_IF_VERSION_NV14 0x38\n#define SMU11_DRIVER_IF_VERSION_Sienna_Cichlid 0x40\n#define SMU11_DRIVER_IF_VERSION_Navy_Flounder 0xE\n#define SMU11_DRIVER_IF_VERSION_VANGOGH 0x03\n#define SMU11_DRIVER_IF_VERSION_Dimgrey_Cavefish 0xF\n#define SMU11_DRIVER_IF_VERSION_Beige_Goby 0xD\n#define SMU11_DRIVER_IF_VERSION_Cyan_Skillfish 0x8\n\n \n#define MP0_Public\t\t\t0x03800000\n#define MP0_SRAM\t\t\t0x03900000\n#define MP1_Public\t\t\t0x03b00000\n#define MP1_SRAM\t\t\t0x03c00004\n\n \n#define smnMP1_FIRMWARE_FLAGS\t\t0x3010024\n#define smnMP0_FW_INTF\t\t\t0x30101c0\n#define smnMP1_PUB_CTRL\t\t\t0x3010b14\n\n#define TEMP_RANGE_MIN\t\t\t(0)\n#define TEMP_RANGE_MAX\t\t\t(80 * 1000)\n\n#define SMU11_TOOL_SIZE\t\t\t0x19000\n\n#define MAX_DPM_LEVELS 16\n#define MAX_PCIE_CONF 2\n\n#define CTF_OFFSET_EDGE\t\t\t5\n#define CTF_OFFSET_HOTSPOT\t\t5\n#define CTF_OFFSET_MEM\t\t\t5\n\n#define LINK_WIDTH_MAX\t\t\t6\n#define LINK_SPEED_MAX\t\t\t3\n\nstatic const __maybe_unused uint16_t link_width[] = {0, 1, 2, 4, 8, 12, 16};\n\nstatic const\nstruct smu_temperature_range __maybe_unused smu11_thermal_policy[] = {\n\t{-273150,  99000, 99000, -273150, 99000, 99000, -273150, 99000, 99000},\n\t{ 120000, 120000, 120000, 120000, 120000, 120000, 120000, 120000, 120000},\n};\n\nstruct smu_11_0_max_sustainable_clocks {\n\tuint32_t display_clock;\n\tuint32_t phy_clock;\n\tuint32_t pixel_clock;\n\tuint32_t uclock;\n\tuint32_t dcef_clock;\n\tuint32_t soc_clock;\n};\n\nstruct smu_11_0_dpm_clk_level {\n\tbool\t\t\t\tenabled;\n\tuint32_t\t\t\tvalue;\n};\n\nstruct smu_11_0_dpm_table {\n\tuint32_t\t\t\tmin;         \n\tuint32_t\t\t\tmax;         \n\tuint32_t\t\t\tcount;\n\tbool\t\t\t\tis_fine_grained;\n\tstruct smu_11_0_dpm_clk_level\tdpm_levels[MAX_DPM_LEVELS];\n};\n\nstruct smu_11_0_pcie_table {\n\tuint8_t  pcie_gen[MAX_PCIE_CONF];\n\tuint8_t  pcie_lane[MAX_PCIE_CONF];\n};\n\nstruct smu_11_0_dpm_tables {\n\tstruct smu_11_0_dpm_table        soc_table;\n\tstruct smu_11_0_dpm_table        gfx_table;\n\tstruct smu_11_0_dpm_table        uclk_table;\n\tstruct smu_11_0_dpm_table        eclk_table;\n\tstruct smu_11_0_dpm_table        vclk_table;\n\tstruct smu_11_0_dpm_table        vclk1_table;\n\tstruct smu_11_0_dpm_table        dclk_table;\n\tstruct smu_11_0_dpm_table        dclk1_table;\n\tstruct smu_11_0_dpm_table        dcef_table;\n\tstruct smu_11_0_dpm_table        pixel_table;\n\tstruct smu_11_0_dpm_table        display_table;\n\tstruct smu_11_0_dpm_table        phy_table;\n\tstruct smu_11_0_dpm_table        fclk_table;\n\tstruct smu_11_0_pcie_table       pcie_table;\n};\n\nstruct smu_11_0_dpm_context {\n\tstruct smu_11_0_dpm_tables  dpm_tables;\n\tuint32_t                    workload_policy_mask;\n\tuint32_t                    dcef_min_ds_clk;\n};\n\nenum smu_11_0_power_state {\n\tSMU_11_0_POWER_STATE__D0 = 0,\n\tSMU_11_0_POWER_STATE__D1,\n\tSMU_11_0_POWER_STATE__D3,  \n\tSMU_11_0_POWER_STATE__D4,  \n\tSMU_11_0_POWER_STATE__D5,  \n};\n\nstruct smu_11_0_power_context {\n\tuint32_t\tpower_source;\n\tuint8_t\t\tin_power_limit_boost_mode;\n\tenum smu_11_0_power_state power_state;\n};\n\nstruct smu_11_5_power_context {\n\tuint32_t\tpower_source;\n\tuint8_t\t\tin_power_limit_boost_mode;\n\tenum smu_11_0_power_state power_state;\n\n\tuint32_t\tcurrent_fast_ppt_limit;\n\tuint32_t\tdefault_fast_ppt_limit;\n\tuint32_t\tmax_fast_ppt_limit;\n};\n\n#if defined(SWSMU_CODE_LAYER_L2) || defined(SWSMU_CODE_LAYER_L3)\n\nint smu_v11_0_init_microcode(struct smu_context *smu);\n\nvoid smu_v11_0_fini_microcode(struct smu_context *smu);\n\nint smu_v11_0_load_microcode(struct smu_context *smu);\n\nint smu_v11_0_init_smc_tables(struct smu_context *smu);\n\nint smu_v11_0_fini_smc_tables(struct smu_context *smu);\n\nint smu_v11_0_init_power(struct smu_context *smu);\n\nint smu_v11_0_fini_power(struct smu_context *smu);\n\nint smu_v11_0_check_fw_status(struct smu_context *smu);\n\nint smu_v11_0_setup_pptable(struct smu_context *smu);\n\nint smu_v11_0_get_vbios_bootup_values(struct smu_context *smu);\n\nint smu_v11_0_check_fw_version(struct smu_context *smu);\n\nint smu_v11_0_set_driver_table_location(struct smu_context *smu);\n\nint smu_v11_0_set_tool_table_location(struct smu_context *smu);\n\nint smu_v11_0_notify_memory_pool_location(struct smu_context *smu);\n\nint smu_v11_0_system_features_control(struct smu_context *smu,\n\t\t\t\t\t     bool en);\n\nint smu_v11_0_init_display_count(struct smu_context *smu, uint32_t count);\n\nint smu_v11_0_set_allowed_mask(struct smu_context *smu);\n\nint smu_v11_0_notify_display_change(struct smu_context *smu);\n\nint smu_v11_0_get_current_power_limit(struct smu_context *smu,\n\t\t\t\t      uint32_t *power_limit);\n\nint smu_v11_0_set_power_limit(struct smu_context *smu,\n\t\t\t      enum smu_ppt_limit_type limit_type,\n\t\t\t      uint32_t limit);\n\nint smu_v11_0_init_max_sustainable_clocks(struct smu_context *smu);\n\nint smu_v11_0_enable_thermal_alert(struct smu_context *smu);\n\nint smu_v11_0_disable_thermal_alert(struct smu_context *smu);\n\nint smu_v11_0_get_gfx_vdd(struct smu_context *smu, uint32_t *value);\n\nint smu_v11_0_set_min_deep_sleep_dcefclk(struct smu_context *smu, uint32_t clk);\n\nint\nsmu_v11_0_display_clock_voltage_request(struct smu_context *smu,\n\t\t\t\t\tstruct pp_display_clock_request\n\t\t\t\t\t*clock_req);\n\nuint32_t\nsmu_v11_0_get_fan_control_mode(struct smu_context *smu);\n\nint\nsmu_v11_0_set_fan_control_mode(struct smu_context *smu,\n\t\t\t       uint32_t mode);\n\nint smu_v11_0_set_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\t    uint32_t speed);\n\nint smu_v11_0_set_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\tuint32_t speed);\n\nint smu_v11_0_get_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\t    uint32_t *speed);\n\nint smu_v11_0_get_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\tuint32_t *speed);\n\nint smu_v11_0_set_xgmi_pstate(struct smu_context *smu,\n\t\t\t\t     uint32_t pstate);\n\nint smu_v11_0_gfx_off_control(struct smu_context *smu, bool enable);\n\nint smu_v11_0_register_irq_handler(struct smu_context *smu);\n\nint smu_v11_0_set_azalia_d3_pme(struct smu_context *smu);\n\nint smu_v11_0_get_max_sustainable_clocks_by_dc(struct smu_context *smu,\n\t\tstruct pp_smu_nv_clock_table *max_clocks);\n\nbool smu_v11_0_baco_is_support(struct smu_context *smu);\n\nenum smu_baco_state smu_v11_0_baco_get_state(struct smu_context *smu);\n\nint smu_v11_0_baco_set_state(struct smu_context *smu, enum smu_baco_state state);\n\nint smu_v11_0_baco_enter(struct smu_context *smu);\nint smu_v11_0_baco_exit(struct smu_context *smu);\n\nint smu_v11_0_baco_set_armd3_sequence(struct smu_context *smu,\n\t\t\t\t      enum smu_baco_seq baco_seq);\n\nint smu_v11_0_mode1_reset(struct smu_context *smu);\n\nint smu_v11_0_get_dpm_ultimate_freq(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t\t\t\t uint32_t *min, uint32_t *max);\n\nint smu_v11_0_set_soft_freq_limited_range(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t    uint32_t min, uint32_t max);\n\nint smu_v11_0_set_hard_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t min,\n\t\t\t\t\t  uint32_t max);\n\nint smu_v11_0_set_performance_level(struct smu_context *smu,\n\t\t\t\t    enum amd_dpm_forced_level level);\n\nint smu_v11_0_set_power_source(struct smu_context *smu,\n\t\t\t       enum smu_power_src_type power_src);\n\nint smu_v11_0_get_dpm_freq_by_index(struct smu_context *smu,\n\t\t\t\t    enum smu_clk_type clk_type,\n\t\t\t\t    uint16_t level,\n\t\t\t\t    uint32_t *value);\n\nint smu_v11_0_get_dpm_level_count(struct smu_context *smu,\n\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t  uint32_t *value);\n\nint smu_v11_0_set_single_dpm_table(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type,\n\t\t\t\t   struct smu_11_0_dpm_table *single_dpm_table);\n\nint smu_v11_0_get_dpm_level_range(struct smu_context *smu,\n\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t  uint32_t *min_value,\n\t\t\t\t  uint32_t *max_value);\n\nint smu_v11_0_get_current_pcie_link_width_level(struct smu_context *smu);\n\nuint16_t smu_v11_0_get_current_pcie_link_width(struct smu_context *smu);\n\nint smu_v11_0_get_current_pcie_link_speed_level(struct smu_context *smu);\n\nuint16_t smu_v11_0_get_current_pcie_link_speed(struct smu_context *smu);\n\nint smu_v11_0_gfx_ulv_control(struct smu_context *smu,\n\t\t\t      bool enablement);\n\nint smu_v11_0_deep_sleep_control(struct smu_context *smu,\n\t\t\t\t bool enablement);\n\nvoid smu_v11_0_interrupt_work(struct smu_context *smu);\n\nint smu_v11_0_handle_passthrough_sbr(struct smu_context *smu, bool enable);\n\nint smu_v11_0_restore_user_od_settings(struct smu_context *smu);\n\nvoid smu_v11_0_set_smu_mailbox_registers(struct smu_context *smu);\n\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}