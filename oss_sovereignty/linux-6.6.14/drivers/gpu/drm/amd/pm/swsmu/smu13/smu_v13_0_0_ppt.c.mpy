{
  "module_name": "smu_v13_0_0_ppt.c",
  "hash_id": "5955d6d20685667f0a663d69886c4829a8383b69e73f0507621f1693b273ffb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_0_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/i2c.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v13_0.h\"\n#include \"smu13_driver_if_v13_0_0.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"smu_v13_0_0_ppt.h\"\n#include \"smu_v13_0_0_pptable.h\"\n#include \"smu_v13_0_0_ppsmc.h\"\n#include \"nbio/nbio_4_3_0_offset.h\"\n#include \"nbio/nbio_4_3_0_sh_mask.h\"\n#include \"mp/mp_13_0_0_offset.h\"\n#include \"mp/mp_13_0_0_sh_mask.h\"\n\n#include \"asic_reg/mp/mp_13_0_0_sh_mask.h\"\n#include \"smu_cmn.h\"\n#include \"amdgpu_ras.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define to_amdgpu_device(x) (container_of(x, struct amdgpu_device, pm.smu_i2c))\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_DPM_GFXCLK_BIT)     | \\\n\tFEATURE_MASK(FEATURE_DPM_UCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_LINK_BIT)       | \\\n\tFEATURE_MASK(FEATURE_DPM_SOCCLK_BIT)     | \\\n\tFEATURE_MASK(FEATURE_DPM_FCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_MP0CLK_BIT))\n\n#define MP0_MP1_DATA_REGION_SIZE_COMBOPPTABLE\t0x4000\n\n#define mmMP1_SMN_C2PMSG_66                                                                            0x0282\n#define mmMP1_SMN_C2PMSG_66_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_82                                                                            0x0292\n#define mmMP1_SMN_C2PMSG_82_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_90                                                                            0x029a\n#define mmMP1_SMN_C2PMSG_90_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_75                                                                            0x028b\n#define mmMP1_SMN_C2PMSG_75_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_53                                                                            0x0275\n#define mmMP1_SMN_C2PMSG_53_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_54                                                                            0x0276\n#define mmMP1_SMN_C2PMSG_54_BASE_IDX                                                                   0\n\n#define DEBUGSMC_MSG_Mode1Reset\t2\n\n \n#define SUPPORT_ECCTABLE_SMU_13_0_10_VERSION 0x00502200\n\n#define PP_OD_FEATURE_GFXCLK_FMIN\t\t\t0\n#define PP_OD_FEATURE_GFXCLK_FMAX\t\t\t1\n#define PP_OD_FEATURE_UCLK_FMIN\t\t\t\t2\n#define PP_OD_FEATURE_UCLK_FMAX\t\t\t\t3\n#define PP_OD_FEATURE_GFX_VF_CURVE\t\t\t4\n\n#define LINK_SPEED_MAX\t\t\t\t\t3\n\nstatic struct cmn2asic_msg_mapping smu_v13_0_0_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,\t\t\tPPSMC_MSG_TestMessage,                 1),\n\tMSG_MAP(GetSmuVersion,\t\t\tPPSMC_MSG_GetSmuVersion,               1),\n\tMSG_MAP(GetDriverIfVersion,\t\tPPSMC_MSG_GetDriverIfVersion,          1),\n\tMSG_MAP(SetAllowedFeaturesMaskLow,\tPPSMC_MSG_SetAllowedFeaturesMaskLow,   0),\n\tMSG_MAP(SetAllowedFeaturesMaskHigh,\tPPSMC_MSG_SetAllowedFeaturesMaskHigh,  0),\n\tMSG_MAP(EnableAllSmuFeatures,\t\tPPSMC_MSG_EnableAllSmuFeatures,        0),\n\tMSG_MAP(DisableAllSmuFeatures,\t\tPPSMC_MSG_DisableAllSmuFeatures,       0),\n\tMSG_MAP(EnableSmuFeaturesLow,\t\tPPSMC_MSG_EnableSmuFeaturesLow,        1),\n\tMSG_MAP(EnableSmuFeaturesHigh,\t\tPPSMC_MSG_EnableSmuFeaturesHigh,       1),\n\tMSG_MAP(DisableSmuFeaturesLow,\t\tPPSMC_MSG_DisableSmuFeaturesLow,       1),\n\tMSG_MAP(DisableSmuFeaturesHigh,\t\tPPSMC_MSG_DisableSmuFeaturesHigh,      1),\n\tMSG_MAP(GetEnabledSmuFeaturesLow,       PPSMC_MSG_GetRunningSmuFeaturesLow,    1),\n\tMSG_MAP(GetEnabledSmuFeaturesHigh,\tPPSMC_MSG_GetRunningSmuFeaturesHigh,   1),\n\tMSG_MAP(SetWorkloadMask,\t\tPPSMC_MSG_SetWorkloadMask,             1),\n\tMSG_MAP(SetPptLimit,\t\t\tPPSMC_MSG_SetPptLimit,                 0),\n\tMSG_MAP(SetDriverDramAddrHigh,\t\tPPSMC_MSG_SetDriverDramAddrHigh,       1),\n\tMSG_MAP(SetDriverDramAddrLow,\t\tPPSMC_MSG_SetDriverDramAddrLow,        1),\n\tMSG_MAP(SetToolsDramAddrHigh,\t\tPPSMC_MSG_SetToolsDramAddrHigh,        0),\n\tMSG_MAP(SetToolsDramAddrLow,\t\tPPSMC_MSG_SetToolsDramAddrLow,         0),\n\tMSG_MAP(TransferTableSmu2Dram,\t\tPPSMC_MSG_TransferTableSmu2Dram,       1),\n\tMSG_MAP(TransferTableDram2Smu,\t\tPPSMC_MSG_TransferTableDram2Smu,       0),\n\tMSG_MAP(UseDefaultPPTable,\t\tPPSMC_MSG_UseDefaultPPTable,           0),\n\tMSG_MAP(RunDcBtc,\t\t\tPPSMC_MSG_RunDcBtc,                    0),\n\tMSG_MAP(EnterBaco,\t\t\tPPSMC_MSG_EnterBaco,                   0),\n\tMSG_MAP(ExitBaco,\t\t\tPPSMC_MSG_ExitBaco,                    0),\n\tMSG_MAP(SetSoftMinByFreq,\t\tPPSMC_MSG_SetSoftMinByFreq,            1),\n\tMSG_MAP(SetSoftMaxByFreq,\t\tPPSMC_MSG_SetSoftMaxByFreq,            1),\n\tMSG_MAP(SetHardMinByFreq,\t\tPPSMC_MSG_SetHardMinByFreq,            1),\n\tMSG_MAP(SetHardMaxByFreq,\t\tPPSMC_MSG_SetHardMaxByFreq,            0),\n\tMSG_MAP(GetMinDpmFreq,\t\t\tPPSMC_MSG_GetMinDpmFreq,               1),\n\tMSG_MAP(GetMaxDpmFreq,\t\t\tPPSMC_MSG_GetMaxDpmFreq,               1),\n\tMSG_MAP(GetDpmFreqByIndex,\t\tPPSMC_MSG_GetDpmFreqByIndex,           1),\n\tMSG_MAP(PowerUpVcn,\t\t\tPPSMC_MSG_PowerUpVcn,                  0),\n\tMSG_MAP(PowerDownVcn,\t\t\tPPSMC_MSG_PowerDownVcn,                0),\n\tMSG_MAP(PowerUpJpeg,\t\t\tPPSMC_MSG_PowerUpJpeg,                 0),\n\tMSG_MAP(PowerDownJpeg,\t\t\tPPSMC_MSG_PowerDownJpeg,               0),\n\tMSG_MAP(GetDcModeMaxDpmFreq,\t\tPPSMC_MSG_GetDcModeMaxDpmFreq,         1),\n\tMSG_MAP(OverridePcieParameters,\t\tPPSMC_MSG_OverridePcieParameters,      0),\n\tMSG_MAP(DramLogSetDramAddrHigh,\t\tPPSMC_MSG_DramLogSetDramAddrHigh,      0),\n\tMSG_MAP(DramLogSetDramAddrLow,\t\tPPSMC_MSG_DramLogSetDramAddrLow,       0),\n\tMSG_MAP(DramLogSetDramSize,\t\tPPSMC_MSG_DramLogSetDramSize,          0),\n\tMSG_MAP(AllowGfxOff,\t\t\tPPSMC_MSG_AllowGfxOff,                 0),\n\tMSG_MAP(DisallowGfxOff,\t\t\tPPSMC_MSG_DisallowGfxOff,              0),\n\tMSG_MAP(SetMGpuFanBoostLimitRpm,\tPPSMC_MSG_SetMGpuFanBoostLimitRpm,     0),\n\tMSG_MAP(GetPptLimit,\t\t\tPPSMC_MSG_GetPptLimit,                 0),\n\tMSG_MAP(NotifyPowerSource,\t\tPPSMC_MSG_NotifyPowerSource,           0),\n\tMSG_MAP(Mode1Reset,\t\t\tPPSMC_MSG_Mode1Reset,                  0),\n\tMSG_MAP(Mode2Reset,\t\t\tPPSMC_MSG_Mode2Reset,\t       \t\t   0),\n\tMSG_MAP(PrepareMp1ForUnload,\t\tPPSMC_MSG_PrepareMp1ForUnload,         0),\n\tMSG_MAP(DFCstateControl,\t\tPPSMC_MSG_SetExternalClientDfCstateAllow, 0),\n\tMSG_MAP(ArmD3,\t\t\t\tPPSMC_MSG_ArmD3,                       0),\n\tMSG_MAP(SetNumBadMemoryPagesRetired,\tPPSMC_MSG_SetNumBadMemoryPagesRetired,   0),\n\tMSG_MAP(SetBadMemoryPagesRetiredFlagsPerChannel,\n\t\t\t    PPSMC_MSG_SetBadMemoryPagesRetiredFlagsPerChannel,   0),\n\tMSG_MAP(AllowGpo,\t\t\tPPSMC_MSG_SetGpoAllow,           0),\n\tMSG_MAP(AllowIHHostInterrupt,\t\tPPSMC_MSG_AllowIHHostInterrupt,       0),\n\tMSG_MAP(ReenableAcDcInterrupt,\t\tPPSMC_MSG_ReenableAcDcInterrupt,       0),\n\tMSG_MAP(DALNotPresent,\t\tPPSMC_MSG_DALNotPresent,       0),\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_0_clk_map[SMU_CLK_COUNT] = {\n\tCLK_MAP(GFXCLK,\t\tPPCLK_GFXCLK),\n\tCLK_MAP(SCLK,\t\tPPCLK_GFXCLK),\n\tCLK_MAP(SOCCLK,\t\tPPCLK_SOCCLK),\n\tCLK_MAP(FCLK,\t\tPPCLK_FCLK),\n\tCLK_MAP(UCLK,\t\tPPCLK_UCLK),\n\tCLK_MAP(MCLK,\t\tPPCLK_UCLK),\n\tCLK_MAP(VCLK,\t\tPPCLK_VCLK_0),\n\tCLK_MAP(VCLK1,\t\tPPCLK_VCLK_1),\n\tCLK_MAP(DCLK,\t\tPPCLK_DCLK_0),\n\tCLK_MAP(DCLK1,\t\tPPCLK_DCLK_1),\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_0_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(FW_DATA_READ),\n\tFEA_MAP(DPM_GFXCLK),\n\tFEA_MAP(DPM_GFX_POWER_OPTIMIZER),\n\tFEA_MAP(DPM_UCLK),\n\tFEA_MAP(DPM_FCLK),\n\tFEA_MAP(DPM_SOCCLK),\n\tFEA_MAP(DPM_MP0CLK),\n\tFEA_MAP(DPM_LINK),\n\tFEA_MAP(DPM_DCN),\n\tFEA_MAP(VMEMP_SCALING),\n\tFEA_MAP(VDDIO_MEM_SCALING),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_FCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_DCFCLK),\n\tFEA_MAP(DS_UCLK),\n\tFEA_MAP(GFX_ULV),\n\tFEA_MAP(FW_DSTATE),\n\tFEA_MAP(GFXOFF),\n\tFEA_MAP(BACO),\n\tFEA_MAP(MM_DPM),\n\tFEA_MAP(SOC_MPCLK_DS),\n\tFEA_MAP(BACO_MPCLK_DS),\n\tFEA_MAP(THROTTLERS),\n\tFEA_MAP(SMARTSHIFT),\n\tFEA_MAP(GTHR),\n\tFEA_MAP(ACDC),\n\tFEA_MAP(VR0HOT),\n\tFEA_MAP(FW_CTF),\n\tFEA_MAP(FAN_CONTROL),\n\tFEA_MAP(GFX_DCS),\n\tFEA_MAP(GFX_READ_MARGIN),\n\tFEA_MAP(LED_DISPLAY),\n\tFEA_MAP(GFXCLK_SPREAD_SPECTRUM),\n\tFEA_MAP(OUT_OF_BAND_MONITOR),\n\tFEA_MAP(OPTIMIZED_VMIN),\n\tFEA_MAP(GFX_IMU),\n\tFEA_MAP(BOOT_TIME_CAL),\n\tFEA_MAP(GFX_PCC_DFLL),\n\tFEA_MAP(SOC_CG),\n\tFEA_MAP(DF_CSTATE),\n\tFEA_MAP(GFX_EDC),\n\tFEA_MAP(BOOT_POWER_OPT),\n\tFEA_MAP(CLOCK_POWER_DOWN_BYPASS),\n\tFEA_MAP(DS_VCN),\n\tFEA_MAP(BACO_CG),\n\tFEA_MAP(MEM_TEMP_READ),\n\tFEA_MAP(ATHUB_MMHUB_PG),\n\tFEA_MAP(SOC_PCC),\n\t[SMU_FEATURE_DPM_VCLK_BIT] = {1, FEATURE_MM_DPM_BIT},\n\t[SMU_FEATURE_DPM_DCLK_BIT] = {1, FEATURE_MM_DPM_BIT},\n\t[SMU_FEATURE_PPT_BIT] = {1, FEATURE_THROTTLERS_BIT},\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_0_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP(PPTABLE),\n\tTAB_MAP(WATERMARKS),\n\tTAB_MAP(AVFS_PSM_DEBUG),\n\tTAB_MAP(PMSTATUSLOG),\n\tTAB_MAP(SMU_METRICS),\n\tTAB_MAP(DRIVER_SMU_CONFIG),\n\tTAB_MAP(ACTIVITY_MONITOR_COEFF),\n\t[SMU_TABLE_COMBO_PPTABLE] = {1, TABLE_COMBO_PPTABLE},\n\tTAB_MAP(I2C_COMMANDS),\n\tTAB_MAP(ECCINFO),\n\tTAB_MAP(OVERDRIVE),\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_0_pwr_src_map[SMU_POWER_SOURCE_COUNT] = {\n\tPWR_MAP(AC),\n\tPWR_MAP(DC),\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_0_workload_map[PP_SMC_POWER_PROFILE_COUNT] = {\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT,\tWORKLOAD_PPLIB_DEFAULT_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_FULLSCREEN3D,\t\tWORKLOAD_PPLIB_FULL_SCREEN_3D_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_POWERSAVING,\t\tWORKLOAD_PPLIB_POWER_SAVING_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VIDEO,\t\tWORKLOAD_PPLIB_VIDEO_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VR,\t\t\tWORKLOAD_PPLIB_VR_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_COMPUTE,\t\tWORKLOAD_PPLIB_COMPUTE_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CUSTOM,\t\tWORKLOAD_PPLIB_CUSTOM_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_WINDOW3D,\t\tWORKLOAD_PPLIB_WINDOW_3D_BIT),\n};\n\nstatic const uint8_t smu_v13_0_0_throttler_map[] = {\n\t[THROTTLER_PPT0_BIT]\t\t= (SMU_THROTTLER_PPT0_BIT),\n\t[THROTTLER_PPT1_BIT]\t\t= (SMU_THROTTLER_PPT1_BIT),\n\t[THROTTLER_PPT2_BIT]\t\t= (SMU_THROTTLER_PPT2_BIT),\n\t[THROTTLER_PPT3_BIT]\t\t= (SMU_THROTTLER_PPT3_BIT),\n\t[THROTTLER_TDC_GFX_BIT]\t\t= (SMU_THROTTLER_TDC_GFX_BIT),\n\t[THROTTLER_TDC_SOC_BIT]\t\t= (SMU_THROTTLER_TDC_SOC_BIT),\n\t[THROTTLER_TEMP_EDGE_BIT]\t= (SMU_THROTTLER_TEMP_EDGE_BIT),\n\t[THROTTLER_TEMP_HOTSPOT_BIT]\t= (SMU_THROTTLER_TEMP_HOTSPOT_BIT),\n\t[THROTTLER_TEMP_MEM_BIT]\t= (SMU_THROTTLER_TEMP_MEM_BIT),\n\t[THROTTLER_TEMP_VR_GFX_BIT]\t= (SMU_THROTTLER_TEMP_VR_GFX_BIT),\n\t[THROTTLER_TEMP_VR_SOC_BIT]\t= (SMU_THROTTLER_TEMP_VR_SOC_BIT),\n\t[THROTTLER_TEMP_VR_MEM0_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM0_BIT),\n\t[THROTTLER_TEMP_VR_MEM1_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM1_BIT),\n\t[THROTTLER_TEMP_LIQUID0_BIT]\t= (SMU_THROTTLER_TEMP_LIQUID0_BIT),\n\t[THROTTLER_TEMP_LIQUID1_BIT]\t= (SMU_THROTTLER_TEMP_LIQUID1_BIT),\n\t[THROTTLER_GFX_APCC_PLUS_BIT]\t= (SMU_THROTTLER_APCC_BIT),\n\t[THROTTLER_FIT_BIT]\t\t= (SMU_THROTTLER_FIT_BIT),\n};\n\nstatic int\nsmu_v13_0_0_get_allowed_feature_mask(struct smu_context *smu,\n\t\t\t\t  uint32_t *feature_mask, uint32_t num)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tu32 smu_version;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tmemset(feature_mask, 0xff, sizeof(uint32_t) * num);\n\n\tif (!(adev->pm.pp_feature & PP_SCLK_DPM_MASK)) {\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_DPM_GFXCLK_BIT);\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_GFX_IMU_BIT);\n\t}\n\n\tif (!(adev->pg_flags & AMD_PG_SUPPORT_ATHUB) ||\n\t    !(adev->pg_flags & AMD_PG_SUPPORT_MMHUB))\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_ATHUB_MMHUB_PG_BIT);\n\n\tif (!(adev->pm.pp_feature & PP_SOCCLK_DPM_MASK))\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_DPM_SOCCLK_BIT);\n\n\t \n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif ((smu_version < 0x004e3a00) ||\n\t     !(adev->pm.pp_feature & PP_GFXOFF_MASK))\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_GFXOFF_BIT);\n\n\tif (!(adev->pm.pp_feature & PP_MCLK_DPM_MASK)) {\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_DPM_UCLK_BIT);\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_VMEMP_SCALING_BIT);\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_VDDIO_MEM_SCALING_BIT);\n\t}\n\n\tif (!(adev->pm.pp_feature & PP_SCLK_DEEP_SLEEP_MASK))\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_DS_GFXCLK_BIT);\n\n\tif (!(adev->pm.pp_feature & PP_PCIE_DPM_MASK)) {\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_DPM_LINK_BIT);\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_DS_LCLK_BIT);\n\t}\n\n\tif (!(adev->pm.pp_feature & PP_ULV_MASK))\n\t\t*(uint64_t *)feature_mask &= ~FEATURE_MASK(FEATURE_GFX_ULV_BIT);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_check_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n#if 0\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tconst OverDriveLimits_t * const overdrive_upperlimits =\n\t\t\t\t&pptable->SkuTable.OverDriveLimitsBasicMax;\n\tconst OverDriveLimits_t * const overdrive_lowerlimits =\n\t\t\t\t&pptable->SkuTable.OverDriveLimitsMin;\n#endif\n\n\tif (powerplay_table->platform_caps & SMU_13_0_0_PP_PLATFORM_CAP_HARDWAREDC)\n\t\tsmu->dc_controlled_by_gpio = true;\n\n\tif (powerplay_table->platform_caps & SMU_13_0_0_PP_PLATFORM_CAP_BACO) {\n\t\tsmu_baco->platform_support = true;\n\n\t\tif (powerplay_table->platform_caps & SMU_13_0_0_PP_PLATFORM_CAP_MACO)\n\t\t\tsmu_baco->maco_support = true;\n\t}\n\n\t \n#if 0\n\tif (!overdrive_lowerlimits->FeatureCtrlMask ||\n\t    !overdrive_upperlimits->FeatureCtrlMask)\n\t\tsmu->od_enabled = false;\n\n\t \n\tsmu->od_settings = &powerplay_table->overdrive_table;\n#else\n\tsmu->od_enabled = false;\n#endif\n\n\ttable_context->thermal_controller_type =\n\t\tpowerplay_table->thermal_controller_type;\n\n\tsmu->adev->pm.no_fan =\n\t\t!(pptable->SkuTable.FeaturesToRun[0] & (1 << FEATURE_FAN_CONTROL_BIT));\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_store_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\n\tmemcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t));\n\n\treturn 0;\n}\n\n#ifndef atom_smc_dpm_info_table_13_0_0\nstruct atom_smc_dpm_info_table_13_0_0 {\n\tstruct atom_common_table_header table_header;\n\tBoardTable_t BoardTable;\n};\n#endif\n\nstatic int smu_v13_0_0_append_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *smc_pptable = table_context->driver_pptable;\n\tstruct atom_smc_dpm_info_table_13_0_0 *smc_dpm_table;\n\tBoardTable_t *BoardTable = &smc_pptable->BoardTable;\n\tint index, ret;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    smc_dpm_info);\n\n\tret = amdgpu_atombios_get_data_table(smu->adev, index, NULL, NULL, NULL,\n\t\t\t\t\t     (uint8_t **)&smc_dpm_table);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(BoardTable, &smc_dpm_table->BoardTable, sizeof(BoardTable_t));\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_get_pptable_from_pmfw(struct smu_context *smu,\n\t\t\t\t\t     void **table,\n\t\t\t\t\t     uint32_t *size)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tvoid *combo_pptable = smu_table->combo_pptable;\n\tint ret = 0;\n\n\tret = smu_cmn_get_combo_pptable(smu);\n\tif (ret)\n\t\treturn ret;\n\n\t*table = combo_pptable;\n\t*size = sizeof(struct smu_13_0_0_powerplay_table);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_setup_pptable(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (amdgpu_sriov_vf(smu->adev))\n\t\treturn 0;\n\n\tret = smu_v13_0_0_get_pptable_from_pmfw(smu,\n\t\t\t\t\t\t&smu_table->power_play_table,\n\t\t\t\t\t\t&smu_table->power_play_table_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_v13_0_0_store_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!adev->scpm_enabled) {\n\t\tret = smu_v13_0_0_append_powerplay_table(smu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = smu_v13_0_0_check_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PPTABLE, sizeof(PPTable_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetricsExternal_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_I2C_COMMANDS, sizeof(SwI2cRequest_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_OVERDRIVE, sizeof(OverDriveTableExternal_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PMSTATUSLOG, SMU13_TOOL_SIZE,\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t       sizeof(DpmActivityMonitorCoeffIntExternal_t), PAGE_SIZE,\n\t\t       AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_COMBO_PPTABLE, MP0_MP1_DATA_REGION_SIZE_COMBOPPTABLE,\n\t\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ECCINFO, sizeof(EccInfoTable_t),\n\t\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetricsExternal_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err0_out;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v1_3);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err1_out;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->ecc_table = kzalloc(tables[SMU_TABLE_ECCINFO].size, GFP_KERNEL);\n\tif (!smu_table->ecc_table)\n\t\tgoto err3_out;\n\n\treturn 0;\n\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->gpu_metrics_table);\nerr1_out:\n\tkfree(smu_table->metrics_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic int smu_v13_0_0_allocate_dpm_context(struct smu_context *smu)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tsmu_dpm->dpm_context = kzalloc(sizeof(struct smu_13_0_dpm_context),\n\t\t\t\t       GFP_KERNEL);\n\tif (!smu_dpm->dpm_context)\n\t\treturn -ENOMEM;\n\n\tsmu_dpm->dpm_context_size = sizeof(struct smu_13_0_dpm_context);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_init_smc_tables(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v13_0_0_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_v13_0_0_allocate_dpm_context(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_v13_0_init_smc_tables(smu);\n}\n\nstatic int smu_v13_0_0_set_default_dpm_table(struct smu_context *smu)\n{\n\tstruct smu_13_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tSkuTable_t *skutable = &pptable->SkuTable;\n\tstruct smu_13_0_dpm_table *dpm_table;\n\tstruct smu_13_0_pcie_table *pcie_table;\n\tuint32_t link_level;\n\tint ret = 0;\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.soc_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_v13_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_SOCCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.socclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.gfx_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {\n\t\tret = smu_v13_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_GFXCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (skutable->DriverReportedClocks.GameClockAc &&\n\t\t    (dpm_table->dpm_levels[dpm_table->count - 1].value >\n\t\t    skutable->DriverReportedClocks.GameClockAc)) {\n\t\t\tdpm_table->dpm_levels[dpm_table->count - 1].value =\n\t\t\t\tskutable->DriverReportedClocks.GameClockAc;\n\t\t\tdpm_table->max = skutable->DriverReportedClocks.GameClockAc;\n\t\t}\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.gfxclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.uclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v13_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_UCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.uclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.fclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_FCLK_BIT)) {\n\t\tret = smu_v13_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_FCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.fclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.vclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_VCLK_BIT)) {\n\t\tret = smu_v13_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_VCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.vclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.dclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCLK_BIT)) {\n\t\tret = smu_v13_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_DCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tpcie_table = &dpm_context->dpm_tables.pcie_table;\n\tpcie_table->num_of_link_levels = 0;\n\tfor (link_level = 0; link_level < NUM_LINK_LEVELS; link_level++) {\n\t\tif (!skutable->PcieGenSpeed[link_level] &&\n\t\t    !skutable->PcieLaneCount[link_level] &&\n\t\t    !skutable->LclkFreq[link_level])\n\t\t\tcontinue;\n\n\t\tpcie_table->pcie_gen[pcie_table->num_of_link_levels] =\n\t\t\t\t\tskutable->PcieGenSpeed[link_level];\n\t\tpcie_table->pcie_lane[pcie_table->num_of_link_levels] =\n\t\t\t\t\tskutable->PcieLaneCount[link_level];\n\t\tpcie_table->clk_freq[pcie_table->num_of_link_levels] =\n\t\t\t\t\tskutable->LclkFreq[link_level];\n\t\tpcie_table->num_of_link_levels++;\n\t}\n\n\treturn 0;\n}\n\nstatic bool smu_v13_0_0_is_dpm_running(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic void smu_v13_0_0_dump_pptable(struct smu_context *smu)\n{\n       struct smu_table_context *table_context = &smu->smu_table;\n       PPTable_t *pptable = table_context->driver_pptable;\n       SkuTable_t *skutable = &pptable->SkuTable;\n\n       dev_info(smu->adev->dev, \"Dumped PPTable:\\n\");\n\n       dev_info(smu->adev->dev, \"Version = 0x%08x\\n\", skutable->Version);\n       dev_info(smu->adev->dev, \"FeaturesToRun[0] = 0x%08x\\n\", skutable->FeaturesToRun[0]);\n       dev_info(smu->adev->dev, \"FeaturesToRun[1] = 0x%08x\\n\", skutable->FeaturesToRun[1]);\n}\n\nstatic int smu_v13_0_0_system_features_control(struct smu_context *smu,\n\t\t\t\t\t\t  bool en)\n{\n\treturn smu_v13_0_system_features_control(smu, en);\n}\n\nstatic uint32_t smu_v13_0_get_throttler_status(SmuMetrics_t *metrics)\n{\n\tuint32_t throttler_status = 0;\n\tint i;\n\n\tfor (i = 0; i < THROTTLER_COUNT; i++)\n\t\tthrottler_status |=\n\t\t\t(metrics->ThrottlingPercentage[i] ? 1U << i : 0);\n\n\treturn throttler_status;\n}\n\n#define SMU_13_0_0_BUSY_THRESHOLD\t15\nstatic int smu_v13_0_0_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t    MetricsMember_t member,\n\t\t\t\t\t    uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_t *metrics =\n\t\t&(((SmuMetricsExternal_t *)(smu_table->metrics_table))->SmuMetrics);\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK_0];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK1:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK_1];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK_0];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK1:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK_1];\n\t\tbreak;\n\tcase METRICS_CURR_FCLK:\n\t\t*value = metrics->CurrClock[PPCLK_FCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\tif (metrics->AverageGfxActivity <= SMU_13_0_0_BUSY_THRESHOLD)\n\t\t\t*value = metrics->AverageGfxclkFrequencyPostDs;\n\t\telse\n\t\t\t*value = metrics->AverageGfxclkFrequencyPreDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_FCLK:\n\t\tif (metrics->AverageUclkActivity <= SMU_13_0_0_BUSY_THRESHOLD)\n\t\t\t*value = metrics->AverageFclkFrequencyPostDs;\n\t\telse\n\t\t\t*value = metrics->AverageFclkFrequencyPreDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\tif (metrics->AverageUclkActivity <= SMU_13_0_0_BUSY_THRESHOLD)\n\t\t\t*value = metrics->AverageMemclkFrequencyPostDs;\n\t\telse\n\t\t\t*value = metrics->AverageMemclkFrequencyPreDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK:\n\t\t*value = metrics->AverageVclk0Frequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK:\n\t\t*value = metrics->AverageDclk0Frequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK1:\n\t\t*value = metrics->AverageVclk1Frequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK1:\n\t\t*value = metrics->AverageDclk1Frequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = metrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = metrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->AvgTemperature[TEMP_EDGE] *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->AvgTemperature[TEMP_HOTSPOT] *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = metrics->AvgTemperature[TEMP_MEM] *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = metrics->AvgTemperature[TEMP_VR_GFX] *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = metrics->AvgTemperature[TEMP_VR_SOC] *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = smu_v13_0_get_throttler_status(metrics);\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = metrics->AvgFanRpm;\n\t\tbreak;\n\tcase METRICS_CURR_FANPWM:\n\t\t*value = metrics->AvgFanPwm;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->AvgVoltage[SVI_PLANE_GFX];\n\t\tbreak;\n\tcase METRICS_PCIE_RATE:\n\t\t*value = metrics->PcieRate;\n\t\tbreak;\n\tcase METRICS_PCIE_WIDTH:\n\t\t*value = metrics->PcieWidth;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t     uint32_t *min,\n\t\t\t\t\t     uint32_t *max)\n{\n\tstruct smu_13_0_dpm_context *dpm_context =\n\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_13_0_dpm_table *dpm_table;\n\n\tswitch (clk_type) {\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\t\t \n\t\tdpm_table = &dpm_context->dpm_tables.uclk_table;\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\t \n\t\tdpm_table = &dpm_context->dpm_tables.gfx_table;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\t \n\t\tdpm_table = &dpm_context->dpm_tables.soc_table;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\t \n\t\tdpm_table = &dpm_context->dpm_tables.fclk_table;\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_VCLK1:\n\t\t \n\t\tdpm_table = &dpm_context->dpm_tables.vclk_table;\n\t\tbreak;\n\tcase SMU_DCLK:\n\tcase SMU_DCLK1:\n\t\t \n\t\tdpm_table = &dpm_context->dpm_tables.dclk_table;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(smu->adev->dev, \"Unsupported clock type!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (min)\n\t\t*min = dpm_table->min;\n\tif (max)\n\t\t*max = dpm_table->max;\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_read_sensor(struct smu_context *smu,\n\t\t\t\t   enum amd_pp_sensors sensor,\n\t\t\t\t   void *data,\n\t\t\t\t   uint32_t *size)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *smc_pptable = table_context->driver_pptable;\n\tint ret = 0;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_MAX_FAN_RPM:\n\t\t*(uint16_t *)data = smc_pptable->SkuTable.FanMaximumRpm;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_MEMACTIVITY,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_TEMPERATURE_MEM,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_CURR_UCLK,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_GFXCLK,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_VOLTAGE_VDDGFX,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_get_current_clk_freq_by_table(struct smu_context *smu,\n\t\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t\t     uint32_t *value)\n{\n\tMetricsMember_t member_type;\n\tint clk_id = 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn -EINVAL;\n\n\tswitch (clk_id) {\n\tcase PPCLK_GFXCLK:\n\t\tmember_type = METRICS_AVERAGE_GFXCLK;\n\t\tbreak;\n\tcase PPCLK_UCLK:\n\t\tmember_type = METRICS_CURR_UCLK;\n\t\tbreak;\n\tcase PPCLK_FCLK:\n\t\tmember_type = METRICS_CURR_FCLK;\n\t\tbreak;\n\tcase PPCLK_SOCCLK:\n\t\tmember_type = METRICS_CURR_SOCCLK;\n\t\tbreak;\n\tcase PPCLK_VCLK_0:\n\t\tmember_type = METRICS_AVERAGE_VCLK;\n\t\tbreak;\n\tcase PPCLK_DCLK_0:\n\t\tmember_type = METRICS_AVERAGE_DCLK;\n\t\tbreak;\n\tcase PPCLK_VCLK_1:\n\t\tmember_type = METRICS_AVERAGE_VCLK1;\n\t\tbreak;\n\tcase PPCLK_DCLK_1:\n\t\tmember_type = METRICS_AVERAGE_DCLK1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\tmember_type,\n\t\t\t\t\t\tvalue);\n}\n\nstatic bool smu_v13_0_0_is_od_feature_supported(struct smu_context *smu,\n\t\t\t\t\t\tint od_feature_bit)\n{\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tconst OverDriveLimits_t * const overdrive_upperlimits =\n\t\t\t\t&pptable->SkuTable.OverDriveLimitsBasicMax;\n\n\treturn overdrive_upperlimits->FeatureCtrlMask & (1U << od_feature_bit);\n}\n\nstatic void smu_v13_0_0_get_od_setting_limits(struct smu_context *smu,\n\t\t\t\t\t      int od_feature_bit,\n\t\t\t\t\t      int32_t *min,\n\t\t\t\t\t      int32_t *max)\n{\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tconst OverDriveLimits_t * const overdrive_upperlimits =\n\t\t\t\t&pptable->SkuTable.OverDriveLimitsBasicMax;\n\tconst OverDriveLimits_t * const overdrive_lowerlimits =\n\t\t\t\t&pptable->SkuTable.OverDriveLimitsMin;\n\tint32_t od_min_setting, od_max_setting;\n\n\tswitch (od_feature_bit) {\n\tcase PP_OD_FEATURE_GFXCLK_FMIN:\n\t\tod_min_setting = overdrive_lowerlimits->GfxclkFmin;\n\t\tod_max_setting = overdrive_upperlimits->GfxclkFmin;\n\t\tbreak;\n\tcase PP_OD_FEATURE_GFXCLK_FMAX:\n\t\tod_min_setting = overdrive_lowerlimits->GfxclkFmax;\n\t\tod_max_setting = overdrive_upperlimits->GfxclkFmax;\n\t\tbreak;\n\tcase PP_OD_FEATURE_UCLK_FMIN:\n\t\tod_min_setting = overdrive_lowerlimits->UclkFmin;\n\t\tod_max_setting = overdrive_upperlimits->UclkFmin;\n\t\tbreak;\n\tcase PP_OD_FEATURE_UCLK_FMAX:\n\t\tod_min_setting = overdrive_lowerlimits->UclkFmax;\n\t\tod_max_setting = overdrive_upperlimits->UclkFmax;\n\t\tbreak;\n\tcase PP_OD_FEATURE_GFX_VF_CURVE:\n\t\tod_min_setting = overdrive_lowerlimits->VoltageOffsetPerZoneBoundary;\n\t\tod_max_setting = overdrive_upperlimits->VoltageOffsetPerZoneBoundary;\n\t\tbreak;\n\tdefault:\n\t\tod_min_setting = od_max_setting = INT_MAX;\n\t\tbreak;\n\t}\n\n\tif (min)\n\t\t*min = od_min_setting;\n\tif (max)\n\t\t*max = od_max_setting;\n}\n\nstatic void smu_v13_0_0_dump_od_table(struct smu_context *smu,\n\t\t\t\t      OverDriveTableExternal_t *od_table)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tdev_dbg(adev->dev, \"OD: Gfxclk: (%d, %d)\\n\", od_table->OverDriveTable.GfxclkFmin,\n\t\t\t\t\t\t     od_table->OverDriveTable.GfxclkFmax);\n\tdev_dbg(adev->dev, \"OD: Uclk: (%d, %d)\\n\", od_table->OverDriveTable.UclkFmin,\n\t\t\t\t\t\t   od_table->OverDriveTable.UclkFmax);\n}\n\nstatic int smu_v13_0_0_get_overdrive_table(struct smu_context *smu,\n\t\t\t\t\t   OverDriveTableExternal_t *od_table)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_update_table(smu,\n\t\t\t\t   SMU_TABLE_OVERDRIVE,\n\t\t\t\t   0,\n\t\t\t\t   (void *)od_table,\n\t\t\t\t   false);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"Failed to get overdrive table!\\n\");\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_upload_overdrive_table(struct smu_context *smu,\n\t\t\t\t\t      OverDriveTableExternal_t *od_table)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_update_table(smu,\n\t\t\t\t   SMU_TABLE_OVERDRIVE,\n\t\t\t\t   0,\n\t\t\t\t   (void *)od_table,\n\t\t\t\t   true);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"Failed to upload overdrive table!\\n\");\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_print_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tchar *buf)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_13_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tOverDriveTableExternal_t *od_table =\n\t\t(OverDriveTableExternal_t *)smu->smu_table.overdrive_table;\n\tstruct smu_13_0_dpm_table *single_dpm_table;\n\tstruct smu_13_0_pcie_table *pcie_table;\n\tuint32_t gen_speed, lane_width;\n\tint i, curr_freq, size = 0;\n\tint32_t min_value, max_value;\n\tint ret = 0;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tif (amdgpu_ras_intr_triggered()) {\n\t\tsize += sysfs_emit_at(buf, size, \"unavailable\\n\");\n\t\treturn size;\n\t}\n\n\tswitch (clk_type) {\n\tcase SMU_SCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.gfx_table);\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.uclk_table);\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.soc_table);\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.fclk_table);\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_VCLK1:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.vclk_table);\n\t\tbreak;\n\tcase SMU_DCLK:\n\tcase SMU_DCLK1:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.dclk_table);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (clk_type) {\n\tcase SMU_SCLK:\n\tcase SMU_MCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_VCLK1:\n\tcase SMU_DCLK:\n\tcase SMU_DCLK1:\n\t\tret = smu_v13_0_0_get_current_clk_freq_by_table(smu, clk_type, &curr_freq);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to get current clock freq!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (single_dpm_table->is_fine_grained) {\n\t\t\t \n\t\t\tif ((single_dpm_table->dpm_levels[0].value != curr_freq) &&\n\t\t\t     (single_dpm_table->dpm_levels[1].value != curr_freq)) {\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n\",\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[0].value);\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz *\\n\",\n\t\t\t\t\t\tcurr_freq);\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz\\n\",\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[1].value);\n\t\t\t} else {\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\",\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[0].value,\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[0].value == curr_freq ? \"*\" : \"\");\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[1].value,\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[1].value == curr_freq ? \"*\" : \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\t\ti, single_dpm_table->dpm_levels[i].value,\n\t\t\t\t\t\tsingle_dpm_table->dpm_levels[i].value == curr_freq ? \"*\" : \"\");\n\t\t}\n\t\tbreak;\n\tcase SMU_PCIE:\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_PCIE_RATE,\n\t\t\t\t\t\t       &gen_speed);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_PCIE_WIDTH,\n\t\t\t\t\t\t       &lane_width);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpcie_table = &(dpm_context->dpm_tables.pcie_table);\n\t\tfor (i = 0; i < pcie_table->num_of_link_levels; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %s %s %dMhz %s\\n\", i,\n\t\t\t\t\t(pcie_table->pcie_gen[i] == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(pcie_table->pcie_gen[i] == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(pcie_table->pcie_gen[i] == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(pcie_table->pcie_gen[i] == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(pcie_table->pcie_lane[i] == 1) ? \"x1\" :\n\t\t\t\t\t(pcie_table->pcie_lane[i] == 2) ? \"x2\" :\n\t\t\t\t\t(pcie_table->pcie_lane[i] == 3) ? \"x4\" :\n\t\t\t\t\t(pcie_table->pcie_lane[i] == 4) ? \"x8\" :\n\t\t\t\t\t(pcie_table->pcie_lane[i] == 5) ? \"x12\" :\n\t\t\t\t\t(pcie_table->pcie_lane[i] == 6) ? \"x16\" : \"\",\n\t\t\t\t\tpcie_table->clk_freq[i],\n\t\t\t\t\t(gen_speed == DECODE_GEN_SPEED(pcie_table->pcie_gen[i])) &&\n\t\t\t\t\t(lane_width == DECODE_LANE_WIDTH(pcie_table->pcie_lane[i])) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\tbreak;\n\n\tcase SMU_OD_SCLK:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu,\n\t\t\t\t\t\t\t PP_OD_FEATURE_GFXCLK_BIT))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"OD_SCLK:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n1: %uMhz\\n\",\n\t\t\t\t\tod_table->OverDriveTable.GfxclkFmin,\n\t\t\t\t\tod_table->OverDriveTable.GfxclkFmax);\n\t\tbreak;\n\n\tcase SMU_OD_MCLK:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu,\n\t\t\t\t\t\t\t PP_OD_FEATURE_UCLK_BIT))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"OD_MCLK:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n1: %uMHz\\n\",\n\t\t\t\t\tod_table->OverDriveTable.UclkFmin,\n\t\t\t\t\tod_table->OverDriveTable.UclkFmax);\n\t\tbreak;\n\n\tcase SMU_OD_VDDC_CURVE:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu,\n\t\t\t\t\t\t\t PP_OD_FEATURE_GFX_VF_CURVE_BIT))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"OD_VDDC_CURVE:\\n\");\n\t\tfor (i = 0; i < PP_NUM_OD_VF_CURVE_POINTS; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %dmv\\n\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\tod_table->OverDriveTable.VoltageOffsetPerZoneBoundary[i]);\n\t\tbreak;\n\n\tcase SMU_OD_RANGE:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_GFXCLK_BIT) &&\n\t\t    !smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_UCLK_BIT) &&\n\t\t    !smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_GFX_VF_CURVE_BIT))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\n\t\tif (smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_GFXCLK_BIT)) {\n\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t  PP_OD_FEATURE_GFXCLK_FMIN,\n\t\t\t\t\t\t\t  &min_value,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t  PP_OD_FEATURE_GFXCLK_FMAX,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t}\n\n\t\tif (smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_UCLK_BIT)) {\n\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t  PP_OD_FEATURE_UCLK_FMIN,\n\t\t\t\t\t\t\t  &min_value,\n\t\t\t\t\t\t\t  NULL);\n\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t  PP_OD_FEATURE_UCLK_FMAX,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"MCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t}\n\n\t\tif (smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_GFX_VF_CURVE_BIT)) {\n\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t  PP_OD_FEATURE_GFX_VF_CURVE,\n\t\t\t\t\t\t\t  &min_value,\n\t\t\t\t\t\t\t  &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE: %7dmv %10dmv\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int smu_v13_0_0_od_edit_dpm_table(struct smu_context *smu,\n\t\t\t\t\t enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\t long input[],\n\t\t\t\t\t uint32_t size)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tOverDriveTableExternal_t *od_table =\n\t\t(OverDriveTableExternal_t *)table_context->overdrive_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t offset_of_voltageoffset;\n\tint32_t minimum, maximum;\n\tuint32_t feature_ctrlmask;\n\tint i, ret = 0;\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_GFXCLK_BIT)) {\n\t\t\tdev_warn(adev->dev, \"GFXCLK_LIMITS setting not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tdev_info(adev->dev, \"invalid number of input parameters %d\\n\", size);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tswitch (input[i]) {\n\t\t\tcase 0:\n\t\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t\t  PP_OD_FEATURE_GFXCLK_FMIN,\n\t\t\t\t\t\t\t\t  &minimum,\n\t\t\t\t\t\t\t\t  &maximum);\n\t\t\t\tif (input[i + 1] < minimum ||\n\t\t\t\t    input[i + 1] > maximum) {\n\t\t\t\t\tdev_info(adev->dev, \"GfxclkFmin (%ld) must be within [%u, %u]!\\n\",\n\t\t\t\t\t\tinput[i + 1], minimum, maximum);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tod_table->OverDriveTable.GfxclkFmin = input[i + 1];\n\t\t\t\tod_table->OverDriveTable.FeatureCtrlMask |= 1U << PP_OD_FEATURE_GFXCLK_BIT;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t\t  PP_OD_FEATURE_GFXCLK_FMAX,\n\t\t\t\t\t\t\t\t  &minimum,\n\t\t\t\t\t\t\t\t  &maximum);\n\t\t\t\tif (input[i + 1] < minimum ||\n\t\t\t\t    input[i + 1] > maximum) {\n\t\t\t\t\tdev_info(adev->dev, \"GfxclkFmax (%ld) must be within [%u, %u]!\\n\",\n\t\t\t\t\t\tinput[i + 1], minimum, maximum);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tod_table->OverDriveTable.GfxclkFmax = input[i + 1];\n\t\t\t\tod_table->OverDriveTable.FeatureCtrlMask |= 1U << PP_OD_FEATURE_GFXCLK_BIT;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_info(adev->dev, \"Invalid SCLK_VDDC_TABLE index: %ld\\n\", input[i]);\n\t\t\t\tdev_info(adev->dev, \"Supported indices: [0:min,1:max]\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (od_table->OverDriveTable.GfxclkFmin > od_table->OverDriveTable.GfxclkFmax) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Invalid setting: GfxclkFmin(%u) is bigger than GfxclkFmax(%u)\\n\",\n\t\t\t\t(uint32_t)od_table->OverDriveTable.GfxclkFmin,\n\t\t\t\t(uint32_t)od_table->OverDriveTable.GfxclkFmax);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase PP_OD_EDIT_MCLK_VDDC_TABLE:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_UCLK_BIT)) {\n\t\t\tdev_warn(adev->dev, \"UCLK_LIMITS setting not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tdev_info(adev->dev, \"invalid number of input parameters %d\\n\", size);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tswitch (input[i]) {\n\t\t\tcase 0:\n\t\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t\t  PP_OD_FEATURE_UCLK_FMIN,\n\t\t\t\t\t\t\t\t  &minimum,\n\t\t\t\t\t\t\t\t  &maximum);\n\t\t\t\tif (input[i + 1] < minimum ||\n\t\t\t\t    input[i + 1] > maximum) {\n\t\t\t\t\tdev_info(adev->dev, \"UclkFmin (%ld) must be within [%u, %u]!\\n\",\n\t\t\t\t\t\tinput[i + 1], minimum, maximum);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tod_table->OverDriveTable.UclkFmin = input[i + 1];\n\t\t\t\tod_table->OverDriveTable.FeatureCtrlMask |= 1U << PP_OD_FEATURE_UCLK_BIT;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t\t\t  PP_OD_FEATURE_UCLK_FMAX,\n\t\t\t\t\t\t\t\t  &minimum,\n\t\t\t\t\t\t\t\t  &maximum);\n\t\t\t\tif (input[i + 1] < minimum ||\n\t\t\t\t    input[i + 1] > maximum) {\n\t\t\t\t\tdev_info(adev->dev, \"UclkFmax (%ld) must be within [%u, %u]!\\n\",\n\t\t\t\t\t\tinput[i + 1], minimum, maximum);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tod_table->OverDriveTable.UclkFmax = input[i + 1];\n\t\t\t\tod_table->OverDriveTable.FeatureCtrlMask |= 1U << PP_OD_FEATURE_UCLK_BIT;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_info(adev->dev, \"Invalid MCLK_VDDC_TABLE index: %ld\\n\", input[i]);\n\t\t\t\tdev_info(adev->dev, \"Supported indices: [0:min,1:max]\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (od_table->OverDriveTable.UclkFmin > od_table->OverDriveTable.UclkFmax) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"Invalid setting: UclkFmin(%u) is bigger than UclkFmax(%u)\\n\",\n\t\t\t\t(uint32_t)od_table->OverDriveTable.UclkFmin,\n\t\t\t\t(uint32_t)od_table->OverDriveTable.UclkFmax);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase PP_OD_EDIT_VDDC_CURVE:\n\t\tif (!smu_v13_0_0_is_od_feature_supported(smu, PP_OD_FEATURE_GFX_VF_CURVE_BIT)) {\n\t\t\tdev_warn(adev->dev, \"VF curve setting not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tif (input[0] >= PP_NUM_OD_VF_CURVE_POINTS ||\n\t\t    input[0] < 0)\n\t\t\treturn -EINVAL;\n\n\t\tsmu_v13_0_0_get_od_setting_limits(smu,\n\t\t\t\t\t\t  PP_OD_FEATURE_GFX_VF_CURVE,\n\t\t\t\t\t\t  &minimum,\n\t\t\t\t\t\t  &maximum);\n\t\tif (input[1] < minimum ||\n\t\t    input[1] > maximum) {\n\t\t\tdev_info(adev->dev, \"Voltage offset (%ld) must be within [%d, %d]!\\n\",\n\t\t\t\t input[1], minimum, maximum);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tod_table->OverDriveTable.VoltageOffsetPerZoneBoundary[input[0]] = input[1];\n\t\tod_table->OverDriveTable.FeatureCtrlMask |= 1U << PP_OD_FEATURE_GFX_VF_CURVE_BIT;\n\t\tbreak;\n\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tfeature_ctrlmask = od_table->OverDriveTable.FeatureCtrlMask;\n\t\tmemcpy(od_table,\n\t\t       table_context->boot_overdrive_table,\n\t\t       sizeof(OverDriveTableExternal_t));\n\t\tod_table->OverDriveTable.FeatureCtrlMask = feature_ctrlmask;\n\t\tfallthrough;\n\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\t \n\t\toffset_of_voltageoffset = offsetof(OverDriveTable_t, VoltageOffsetPerZoneBoundary);\n\t\tif (memcmp((u8 *)od_table + offset_of_voltageoffset,\n\t\t\t   table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t   sizeof(OverDriveTableExternal_t) - offset_of_voltageoffset)) {\n\t\t\tsmu_v13_0_0_dump_od_table(smu, od_table);\n\n\t\t\tret = smu_v13_0_0_upload_overdrive_table(smu, od_table);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(adev->dev, \"Failed to upload overdrive table!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tod_table->OverDriveTable.FeatureCtrlMask = 0;\n\t\t\tmemcpy(table_context->user_overdrive_table + offset_of_voltageoffset,\n\t\t\t       (u8 *)od_table + offset_of_voltageoffset,\n\t\t\t       sizeof(OverDriveTableExternal_t) - offset_of_voltageoffset);\n\n\t\t\tif (!memcmp(table_context->user_overdrive_table,\n\t\t\t\t    table_context->boot_overdrive_table,\n\t\t\t\t    sizeof(OverDriveTableExternal_t)))\n\t\t\t\tsmu->user_dpm_profile.user_od = false;\n\t\t\telse\n\t\t\t\tsmu->user_dpm_profile.user_od = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_force_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tuint32_t mask)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_13_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tstruct smu_13_0_dpm_table *single_dpm_table;\n\tuint32_t soft_min_level, soft_max_level;\n\tuint32_t min_freq, max_freq;\n\tint ret = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.gfx_table);\n\t\tbreak;\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.uclk_table);\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.soc_table);\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.fclk_table);\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_VCLK1:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.vclk_table);\n\t\tbreak;\n\tcase SMU_DCLK:\n\tcase SMU_DCLK1:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.dclk_table);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_VCLK1:\n\tcase SMU_DCLK:\n\tcase SMU_DCLK1:\n\t\tif (single_dpm_table->is_fine_grained) {\n\t\t\t \n\t\t\tsoft_max_level = (soft_max_level >= 1 ? 1 : 0);\n\t\t\tsoft_min_level = (soft_min_level >= 1 ? 1 : 0);\n\t\t} else {\n\t\t\tif ((soft_max_level >= single_dpm_table->count) ||\n\t\t\t    (soft_min_level >= single_dpm_table->count))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmin_freq = single_dpm_table->dpm_levels[soft_min_level].value;\n\t\tmax_freq = single_dpm_table->dpm_levels[soft_max_level].value;\n\n\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    clk_type,\n\t\t\t\t\t\t\t    min_freq,\n\t\t\t\t\t\t\t    max_freq);\n\t\tbreak;\n\tcase SMU_DCEFCLK:\n\tcase SMU_PCIE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct smu_temperature_range smu13_thermal_policy[] = {\n\t{-273150,  99000, 99000, -273150, 99000, 99000, -273150, 99000, 99000},\n\t{ 120000, 120000, 120000, 120000, 120000, 120000, 120000, 120000, 120000},\n};\n\nstatic int smu_v13_0_0_get_thermal_temperature_range(struct smu_context *smu,\n\t\t\t\t\t\t     struct smu_temperature_range *range)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\n\tif (amdgpu_sriov_vf(smu->adev))\n\t\treturn 0;\n\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tmemcpy(range, &smu13_thermal_policy[0], sizeof(struct smu_temperature_range));\n\n\trange->max = pptable->SkuTable.TemperatureLimit[TEMP_EDGE] *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->edge_emergency_max = (pptable->SkuTable.TemperatureLimit[TEMP_EDGE] + CTF_OFFSET_EDGE) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_crit_max = pptable->SkuTable.TemperatureLimit[TEMP_HOTSPOT] *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_emergency_max = (pptable->SkuTable.TemperatureLimit[TEMP_HOTSPOT] + CTF_OFFSET_HOTSPOT) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_crit_max = pptable->SkuTable.TemperatureLimit[TEMP_MEM] *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_emergency_max = (pptable->SkuTable.TemperatureLimit[TEMP_MEM] + CTF_OFFSET_MEM)*\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->software_shutdown_temp = powerplay_table->software_shutdown_temp;\n\trange->software_shutdown_temp_offset = pptable->SkuTable.FanAbnormalTempLimitOffset;\n\n\treturn 0;\n}\n\n#define MAX(a, b)\t((a) > (b) ? (a) : (b))\nstatic ssize_t smu_v13_0_0_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t   void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetricsExternal_t metrics_ext;\n\tSmuMetrics_t *metrics = &metrics_ext.SmuMetrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\t&metrics_ext,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = metrics->AvgTemperature[TEMP_EDGE];\n\tgpu_metrics->temperature_hotspot = metrics->AvgTemperature[TEMP_HOTSPOT];\n\tgpu_metrics->temperature_mem = metrics->AvgTemperature[TEMP_MEM];\n\tgpu_metrics->temperature_vrgfx = metrics->AvgTemperature[TEMP_VR_GFX];\n\tgpu_metrics->temperature_vrsoc = metrics->AvgTemperature[TEMP_VR_SOC];\n\tgpu_metrics->temperature_vrmem = MAX(metrics->AvgTemperature[TEMP_VR_MEM0],\n\t\t\t\t\t     metrics->AvgTemperature[TEMP_VR_MEM1]);\n\n\tgpu_metrics->average_gfx_activity = metrics->AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics->AverageUclkActivity;\n\tgpu_metrics->average_mm_activity = MAX(metrics->Vcn0ActivityPercentage,\n\t\t\t\t\t       metrics->Vcn1ActivityPercentage);\n\n\tgpu_metrics->average_socket_power = metrics->AverageSocketPower;\n\tgpu_metrics->energy_accumulator = metrics->EnergyAccumulator;\n\n\tif (metrics->AverageGfxActivity <= SMU_13_0_0_BUSY_THRESHOLD)\n\t\tgpu_metrics->average_gfxclk_frequency = metrics->AverageGfxclkFrequencyPostDs;\n\telse\n\t\tgpu_metrics->average_gfxclk_frequency = metrics->AverageGfxclkFrequencyPreDs;\n\n\tif (metrics->AverageUclkActivity <= SMU_13_0_0_BUSY_THRESHOLD)\n\t\tgpu_metrics->average_uclk_frequency = metrics->AverageMemclkFrequencyPostDs;\n\telse\n\t\tgpu_metrics->average_uclk_frequency = metrics->AverageMemclkFrequencyPreDs;\n\n\tgpu_metrics->average_vclk0_frequency = metrics->AverageVclk0Frequency;\n\tgpu_metrics->average_dclk0_frequency = metrics->AverageDclk0Frequency;\n\tgpu_metrics->average_vclk1_frequency = metrics->AverageVclk1Frequency;\n\tgpu_metrics->average_dclk1_frequency = metrics->AverageDclk1Frequency;\n\n\tgpu_metrics->current_gfxclk = gpu_metrics->average_gfxclk_frequency;\n\tgpu_metrics->current_socclk = metrics->CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics->CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics->CurrClock[PPCLK_VCLK_0];\n\tgpu_metrics->current_dclk0 = metrics->CurrClock[PPCLK_DCLK_0];\n\tgpu_metrics->current_vclk1 = metrics->CurrClock[PPCLK_VCLK_1];\n\tgpu_metrics->current_dclk1 = metrics->CurrClock[PPCLK_DCLK_1];\n\n\tgpu_metrics->throttle_status =\n\t\t\tsmu_v13_0_get_throttler_status(metrics);\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(gpu_metrics->throttle_status,\n\t\t\t\t\t\t\t   smu_v13_0_0_throttler_map);\n\n\tgpu_metrics->current_fan_speed = metrics->AvgFanRpm;\n\n\tgpu_metrics->pcie_link_width = metrics->PcieWidth;\n\tif ((metrics->PcieRate - 1) > LINK_SPEED_MAX)\n\t\tgpu_metrics->pcie_link_speed = pcie_gen_to_speed(1);\n\telse\n\t\tgpu_metrics->pcie_link_speed = pcie_gen_to_speed(metrics->PcieRate);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\tgpu_metrics->voltage_gfx = metrics->AvgVoltage[SVI_PLANE_GFX];\n\tgpu_metrics->voltage_soc = metrics->AvgVoltage[SVI_PLANE_SOC];\n\tgpu_metrics->voltage_mem = metrics->AvgVoltage[SVI_PLANE_VMEMP];\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic int smu_v13_0_0_set_default_od_settings(struct smu_context *smu)\n{\n\tOverDriveTableExternal_t *od_table =\n\t\t(OverDriveTableExternal_t *)smu->smu_table.overdrive_table;\n\tOverDriveTableExternal_t *boot_od_table =\n\t\t(OverDriveTableExternal_t *)smu->smu_table.boot_overdrive_table;\n\tOverDriveTableExternal_t *user_od_table =\n\t\t(OverDriveTableExternal_t *)smu->smu_table.user_overdrive_table;\n\tOverDriveTableExternal_t user_od_table_bak;\n\tint ret = 0;\n\tint i;\n\n\tret = smu_v13_0_0_get_overdrive_table(smu, boot_od_table);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_v13_0_0_dump_od_table(smu, boot_od_table);\n\n\tmemcpy(od_table,\n\t       boot_od_table,\n\t       sizeof(OverDriveTableExternal_t));\n\n\t \n\tif (!smu->adev->in_suspend) {\n\t\tmemcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t));\n\t\tsmu->user_dpm_profile.user_od = false;\n\t} else if (smu->user_dpm_profile.user_od) {\n\t\tmemcpy(&user_od_table_bak,\n\t\t       user_od_table,\n\t\t       sizeof(OverDriveTableExternal_t));\n\t\tmemcpy(user_od_table,\n\t\t       boot_od_table,\n\t\t       sizeof(OverDriveTableExternal_t));\n\t\tuser_od_table->OverDriveTable.GfxclkFmin =\n\t\t\t\tuser_od_table_bak.OverDriveTable.GfxclkFmin;\n\t\tuser_od_table->OverDriveTable.GfxclkFmax =\n\t\t\t\tuser_od_table_bak.OverDriveTable.GfxclkFmax;\n\t\tuser_od_table->OverDriveTable.UclkFmin =\n\t\t\t\tuser_od_table_bak.OverDriveTable.UclkFmin;\n\t\tuser_od_table->OverDriveTable.UclkFmax =\n\t\t\t\tuser_od_table_bak.OverDriveTable.UclkFmax;\n\t\tfor (i = 0; i < PP_NUM_OD_VF_CURVE_POINTS; i++)\n\t\t\tuser_od_table->OverDriveTable.VoltageOffsetPerZoneBoundary[i] =\n\t\t\t\tuser_od_table_bak.OverDriveTable.VoltageOffsetPerZoneBoundary[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_restore_user_od_settings(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tOverDriveTableExternal_t *od_table = table_context->overdrive_table;\n\tOverDriveTableExternal_t *user_od_table = table_context->user_overdrive_table;\n\tint res;\n\n\tuser_od_table->OverDriveTable.FeatureCtrlMask = 1U << PP_OD_FEATURE_GFXCLK_BIT |\n\t\t\t\t\t\t\t1U << PP_OD_FEATURE_UCLK_BIT |\n\t\t\t\t\t\t\t1U << PP_OD_FEATURE_GFX_VF_CURVE_BIT;\n\tres = smu_v13_0_0_upload_overdrive_table(smu, user_od_table);\n\tuser_od_table->OverDriveTable.FeatureCtrlMask = 0;\n\tif (res == 0)\n\t\tmemcpy(od_table, user_od_table, sizeof(OverDriveTableExternal_t));\n\n\treturn res;\n}\n\nstatic int smu_v13_0_0_populate_umd_state_clk(struct smu_context *smu)\n{\n\tstruct smu_13_0_dpm_context *dpm_context =\n\t\t\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_13_0_dpm_table *gfx_table =\n\t\t\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_13_0_dpm_table *mem_table =\n\t\t\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_13_0_dpm_table *soc_table =\n\t\t\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_13_0_dpm_table *vclk_table =\n\t\t\t\t&dpm_context->dpm_tables.vclk_table;\n\tstruct smu_13_0_dpm_table *dclk_table =\n\t\t\t\t&dpm_context->dpm_tables.dclk_table;\n\tstruct smu_13_0_dpm_table *fclk_table =\n\t\t\t\t&dpm_context->dpm_tables.fclk_table;\n\tstruct smu_umd_pstate_table *pstate_table =\n\t\t\t\t&smu->pstate_table;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tDriverReportedClocks_t driver_clocks =\n\t\t\tpptable->SkuTable.DriverReportedClocks;\n\n\tpstate_table->gfxclk_pstate.min = gfx_table->min;\n\tif (driver_clocks.GameClockAc &&\n\t    (driver_clocks.GameClockAc < gfx_table->max))\n\t\tpstate_table->gfxclk_pstate.peak = driver_clocks.GameClockAc;\n\telse\n\t\tpstate_table->gfxclk_pstate.peak = gfx_table->max;\n\n\tpstate_table->uclk_pstate.min = mem_table->min;\n\tpstate_table->uclk_pstate.peak = mem_table->max;\n\n\tpstate_table->socclk_pstate.min = soc_table->min;\n\tpstate_table->socclk_pstate.peak = soc_table->max;\n\n\tpstate_table->vclk_pstate.min = vclk_table->min;\n\tpstate_table->vclk_pstate.peak = vclk_table->max;\n\n\tpstate_table->dclk_pstate.min = dclk_table->min;\n\tpstate_table->dclk_pstate.peak = dclk_table->max;\n\n\tpstate_table->fclk_pstate.min = fclk_table->min;\n\tpstate_table->fclk_pstate.peak = fclk_table->max;\n\n\tif (driver_clocks.BaseClockAc &&\n\t    driver_clocks.BaseClockAc < gfx_table->max)\n\t\tpstate_table->gfxclk_pstate.standard = driver_clocks.BaseClockAc;\n\telse\n\t\tpstate_table->gfxclk_pstate.standard = gfx_table->max;\n\tpstate_table->uclk_pstate.standard = mem_table->max;\n\tpstate_table->socclk_pstate.standard = soc_table->min;\n\tpstate_table->vclk_pstate.standard = vclk_table->min;\n\tpstate_table->dclk_pstate.standard = dclk_table->min;\n\tpstate_table->fclk_pstate.standard = fclk_table->min;\n\n\treturn 0;\n}\n\nstatic void smu_v13_0_0_get_unique_id(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_t *metrics =\n\t\t&(((SmuMetricsExternal_t *)(smu_table->metrics_table))->SmuMetrics);\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t upper32 = 0, lower32 = 0;\n\tint ret;\n\n\tret = smu_cmn_get_metrics_table(smu, NULL, false);\n\tif (ret)\n\t\tgoto out;\n\n\tupper32 = metrics->PublicSerialNumberUpper;\n\tlower32 = metrics->PublicSerialNumberLower;\n\nout:\n\tadev->unique_id = ((uint64_t)upper32 << 32) | lower32;\n\tif (adev->serial[0] == '\\0')\n\t\tsprintf(adev->serial, \"%016llx\", adev->unique_id);\n}\n\nstatic int smu_v13_0_0_get_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\t\t uint32_t *speed)\n{\n\tint ret;\n\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\tret = smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t       METRICS_CURR_FANPWM,\n\t\t\t\t\t       speed);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get fan speed(PWM)!\");\n\t\treturn ret;\n\t}\n\n\t \n\t*speed = MIN(*speed * 255 / 100, 255);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_get_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\t\t uint32_t *speed)\n{\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\treturn smu_v13_0_0_get_smu_metrics_data(smu,\n\t\t\t\t\t\tMETRICS_CURR_FANSPEED,\n\t\t\t\t\t\tspeed);\n}\n\nstatic int smu_v13_0_0_enable_mgpu_fan_boost(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tSkuTable_t *skutable = &pptable->SkuTable;\n\n\t \n\tif (skutable->MGpuAcousticLimitRpmThreshold == 0)\n\t\treturn 0;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SetMGpuFanBoostLimitRpm,\n\t\t\t\t\t       0,\n\t\t\t\t\t       NULL);\n}\n\nstatic int smu_v13_0_0_get_power_limit(struct smu_context *smu,\n\t\t\t\t       uint32_t *current_power_limit,\n\t\t\t\t       uint32_t *default_power_limit,\n\t\t\t\t       uint32_t *max_power_limit)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_0_powerplay_table *powerplay_table =\n\t\t(struct smu_13_0_0_powerplay_table *)table_context->power_play_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tSkuTable_t *skutable = &pptable->SkuTable;\n\tuint32_t power_limit, od_percent;\n\n\tif (smu_v13_0_get_current_power_limit(smu, &power_limit))\n\t\tpower_limit = smu->adev->pm.ac_power ?\n\t\t\t      skutable->SocketPowerLimitAc[PPT_THROTTLER_PPT0] :\n\t\t\t      skutable->SocketPowerLimitDc[PPT_THROTTLER_PPT0];\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (max_power_limit) {\n\t\tif (smu->od_enabled) {\n\t\t\tod_percent = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_13_0_0_ODSETTING_POWERPERCENTAGE]);\n\n\t\t\tdev_dbg(smu->adev->dev, \"ODSETTING_POWERPERCENTAGE: %d (default: %d)\\n\", od_percent, power_limit);\n\n\t\t\tpower_limit *= (100 + od_percent);\n\t\t\tpower_limit /= 100;\n\t\t}\n\t\t*max_power_limit = power_limit;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_0_get_power_profile_mode(struct smu_context *smu,\n\t\t\t\t\t      char *buf)\n{\n\tDpmActivityMonitorCoeffIntExternal_t activity_monitor_external;\n\tDpmActivityMonitorCoeffInt_t *activity_monitor =\n\t\t&(activity_monitor_external.DpmActivityMonitorCoeffInt);\n\tstatic const char *title[] = {\n\t\t\t\"PROFILE_INDEX(NAME)\",\n\t\t\t\"CLOCK_TYPE(NAME)\",\n\t\t\t\"FPS\",\n\t\t\t\"MinActiveFreqType\",\n\t\t\t\"MinActiveFreq\",\n\t\t\t\"BoosterFreqType\",\n\t\t\t\"BoosterFreq\",\n\t\t\t\"PD_Data_limit_c\",\n\t\t\t\"PD_Data_error_coeff\",\n\t\t\t\"PD_Data_error_rate_coeff\"};\n\tint16_t workload_type = 0;\n\tuint32_t i, size = 0;\n\tint result = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tsize += sysfs_emit_at(buf, size, \"%16s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\ttitle[0], title[1], title[2], title[3], title[4], title[5],\n\t\t\ttitle[6], title[7], title[8], title[9]);\n\n\tfor (i = 0; i < PP_SMC_POWER_PROFILE_COUNT; i++) {\n\t\t \n\t\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t\t       i);\n\t\tif (workload_type == -ENOTSUPP)\n\t\t\tcontinue;\n\t\telse if (workload_type < 0)\n\t\t\treturn -EINVAL;\n\n\t\tresult = smu_cmn_update_table(smu,\n\t\t\t\t\t      SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t\t\t\t      workload_type,\n\t\t\t\t\t      (void *)(&activity_monitor_external),\n\t\t\t\t\t      false);\n\t\tif (result) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn result;\n\t\t}\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s:\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == smu->power_profile_mode) ? \"*\" : \" \");\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t0,\n\t\t\t\"GFXCLK\",\n\t\t\tactivity_monitor->Gfx_FPS,\n\t\t\tactivity_monitor->Gfx_MinActiveFreqType,\n\t\t\tactivity_monitor->Gfx_MinActiveFreq,\n\t\t\tactivity_monitor->Gfx_BoosterFreqType,\n\t\t\tactivity_monitor->Gfx_BoosterFreq,\n\t\t\tactivity_monitor->Gfx_PD_Data_limit_c,\n\t\t\tactivity_monitor->Gfx_PD_Data_error_coeff,\n\t\t\tactivity_monitor->Gfx_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t1,\n\t\t\t\"FCLK\",\n\t\t\tactivity_monitor->Fclk_FPS,\n\t\t\tactivity_monitor->Fclk_MinActiveFreqType,\n\t\t\tactivity_monitor->Fclk_MinActiveFreq,\n\t\t\tactivity_monitor->Fclk_BoosterFreqType,\n\t\t\tactivity_monitor->Fclk_BoosterFreq,\n\t\t\tactivity_monitor->Fclk_PD_Data_limit_c,\n\t\t\tactivity_monitor->Fclk_PD_Data_error_coeff,\n\t\t\tactivity_monitor->Fclk_PD_Data_error_rate_coeff);\n\t}\n\n\treturn size;\n}\n\nstatic int smu_v13_0_0_set_power_profile_mode(struct smu_context *smu,\n\t\t\t\t\t      long *input,\n\t\t\t\t\t      uint32_t size)\n{\n\tDpmActivityMonitorCoeffIntExternal_t activity_monitor_external;\n\tDpmActivityMonitorCoeffInt_t *activity_monitor =\n\t\t&(activity_monitor_external.DpmActivityMonitorCoeffInt);\n\tint workload_type, ret = 0;\n\n\tsmu->power_profile_mode = input[size];\n\n\tif (smu->power_profile_mode >= PP_SMC_POWER_PROFILE_COUNT) {\n\t\tdev_err(smu->adev->dev, \"Invalid power profile mode %d\\n\", smu->power_profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t\t   SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t\t\t\t   WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t\t   (void *)(&activity_monitor_external),\n\t\t\t\t\t   false);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (input[0]) {\n\t\tcase 0:  \n\t\t\tactivity_monitor->Gfx_FPS = input[1];\n\t\t\tactivity_monitor->Gfx_MinActiveFreqType = input[2];\n\t\t\tactivity_monitor->Gfx_MinActiveFreq = input[3];\n\t\t\tactivity_monitor->Gfx_BoosterFreqType = input[4];\n\t\t\tactivity_monitor->Gfx_BoosterFreq = input[5];\n\t\t\tactivity_monitor->Gfx_PD_Data_limit_c = input[6];\n\t\t\tactivity_monitor->Gfx_PD_Data_error_coeff = input[7];\n\t\t\tactivity_monitor->Gfx_PD_Data_error_rate_coeff = input[8];\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tactivity_monitor->Fclk_FPS = input[1];\n\t\t\tactivity_monitor->Fclk_MinActiveFreqType = input[2];\n\t\t\tactivity_monitor->Fclk_MinActiveFreq = input[3];\n\t\t\tactivity_monitor->Fclk_BoosterFreqType = input[4];\n\t\t\tactivity_monitor->Fclk_BoosterFreq = input[5];\n\t\t\tactivity_monitor->Fclk_PD_Data_limit_c = input[6];\n\t\t\tactivity_monitor->Fclk_PD_Data_error_coeff = input[7];\n\t\t\tactivity_monitor->Fclk_PD_Data_error_rate_coeff = input[8];\n\t\t\tbreak;\n\t\t}\n\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t\t   SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t\t\t\t   WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t\t   (void *)(&activity_monitor_external),\n\t\t\t\t\t   true);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to set activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t       smu->power_profile_mode);\n\n\tif (workload_type < 0)\n\t\treturn -EINVAL;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SetWorkloadMask,\n\t\t\t\t\t       1 << workload_type,\n\t\t\t\t\t       NULL);\n}\n\nstatic int smu_v13_0_0_baco_enter(struct smu_context *smu)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->in_runpm && smu_cmn_is_audio_func_enabled(adev))\n\t\treturn smu_v13_0_baco_set_armd3_sequence(smu,\n\t\t\t\t(smu_baco->maco_support && amdgpu_runtime_pm != 1) ?\n\t\t\t\t\tBACO_SEQ_BAMACO : BACO_SEQ_BACO);\n\telse\n\t\treturn smu_v13_0_baco_enter(smu);\n}\n\nstatic int smu_v13_0_0_baco_exit(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->in_runpm && smu_cmn_is_audio_func_enabled(adev)) {\n\t\t \n\t\tusleep_range(10000, 11000);\n\t\treturn smu_v13_0_baco_set_armd3_sequence(smu, BACO_SEQ_ULPS);\n\t} else {\n\t\treturn smu_v13_0_baco_exit(smu);\n\t}\n}\n\nstatic bool smu_v13_0_0_is_mode1_reset_supported(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tu32 smu_version;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\treturn false;\n\n\t \n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (smu_version < 0x004e2900)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int smu_v13_0_0_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t\t   struct i2c_msg *msg, int num_msgs)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tSwI2cRequest_t *req, *res = (SwI2cRequest_t *)table->cpu_addr;\n\tint i, j, r, c;\n\tu16 dir;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn -EBUSY;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->I2CcontrollerPort = smu_i2c->port;\n\treq->I2CSpeed = I2C_SPEED_FAST_400K;\n\treq->SlaveAddress = msg[0].addr << 1;  \n\tdir = msg[0].flags & I2C_M_RD;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &req->SwI2cCmds[c];\n\n\t\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\t\t \n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_READWRITE_MASK;\n\t\t\t\tcmd->ReadWriteData = msg[i].buf[j];\n\t\t\t}\n\n\t\t\tif ((dir ^ msg[i].flags) & I2C_M_RD) {\n\t\t\t\t \n\t\t\t\tdir = msg[i].flags & I2C_M_RD;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_RESTART_MASK;\n\t\t\t}\n\n\t\t\treq->NumCmds++;\n\n\t\t\t \n\t\t\tif ((j == msg[i].len - 1) &&\n\t\t\t    ((i == num_msgs - 1) || (msg[i].flags & I2C_M_STOP))) {\n\t\t\t\tcmd->CmdConfig &= ~CMDCONFIG_RESTART_MASK;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_STOP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&adev->pm.mutex);\n\tr = smu_cmn_update_table(smu, SMU_TABLE_I2C_COMMANDS, 0, req, true);\n\tif (r)\n\t\tgoto fail;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\tc += msg[i].len;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &res->SwI2cCmds[c];\n\n\t\t\tmsg[i].buf[j] = cmd->ReadWriteData;\n\t\t}\n\t}\n\tr = num_msgs;\nfail:\n\tmutex_unlock(&adev->pm.mutex);\n\tkfree(req);\n\treturn r;\n}\n\nstatic u32 smu_v13_0_0_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm smu_v13_0_0_i2c_algo = {\n\t.master_xfer = smu_v13_0_0_i2c_xfer,\n\t.functionality = smu_v13_0_0_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks smu_v13_0_0_i2c_control_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_SAME_ADDR | I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len  = MAX_SW_I2C_COMMANDS,\n\t.max_write_len = MAX_SW_I2C_COMMANDS,\n\t.max_comb_1st_msg_len = 2,\n\t.max_comb_2nd_msg_len = MAX_SW_I2C_COMMANDS - 2,\n};\n\nstatic int smu_v13_0_0_i2c_control_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint res, i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\tsmu_i2c->adev = adev;\n\t\tsmu_i2c->port = i;\n\t\tmutex_init(&smu_i2c->mutex);\n\t\tcontrol->owner = THIS_MODULE;\n\t\tcontrol->class = I2C_CLASS_SPD;\n\t\tcontrol->dev.parent = &adev->pdev->dev;\n\t\tcontrol->algo = &smu_v13_0_0_i2c_algo;\n\t\tsnprintf(control->name, sizeof(control->name), \"AMDGPU SMU %d\", i);\n\t\tcontrol->quirks = &smu_v13_0_0_i2c_control_quirks;\n\t\ti2c_set_adapdata(control, smu_i2c);\n\n\t\tres = i2c_add_adapter(control);\n\t\tif (res) {\n\t\t\tDRM_ERROR(\"Failed to register hw i2c, err: %d\\n\", res);\n\t\t\tgoto Out_err;\n\t\t}\n\t}\n\n\t \n\t \n\tadev->pm.ras_eeprom_i2c_bus = &adev->pm.smu_i2c[1].adapter;\n\tadev->pm.fru_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\n\treturn 0;\nOut_err:\n\tfor ( ; i >= 0; i--) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\treturn res;\n}\n\nstatic void smu_v13_0_0_i2c_control_fini(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\tadev->pm.ras_eeprom_i2c_bus = NULL;\n\tadev->pm.fru_eeprom_i2c_bus = NULL;\n}\n\nstatic int smu_v13_0_0_set_mp1_state(struct smu_context *smu,\n\t\t\t\t     enum pp_mp1_state mp1_state)\n{\n\tint ret;\n\n\tswitch (mp1_state) {\n\tcase PP_MP1_STATE_UNLOAD:\n\t\tret = smu_cmn_set_mp1_state(smu, mp1_state);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_set_df_cstate(struct smu_context *smu,\n\t\t\t\t     enum pp_df_cstate state)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_DFCstateControl,\n\t\t\t\t\t       state,\n\t\t\t\t\t       NULL);\n}\n\nstatic void smu_v13_0_0_set_mode1_reset_param(struct smu_context *smu,\n\t\t\t\t\t\tuint32_t supported_version,\n\t\t\t\t\t\tuint32_t *param)\n{\n\tuint32_t smu_version;\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\n\tif ((smu_version >= supported_version) &&\n\t\t\tras && atomic_read(&ras->in_recovery))\n\t\t \n\t\t*param = 1 << 16;\n\telse\n\t\t*param = 0;\n}\n\nstatic int smu_v13_0_0_mode1_reset(struct smu_context *smu)\n{\n\tint ret;\n\tuint32_t param;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(13, 0, 0):\n\t\t \n\t\tsmu_v13_0_0_set_mode1_reset_param(smu, 0x004e4d00, &param);\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\tSMU_MSG_Mode1Reset, param, NULL);\n\t\tbreak;\n\n\tcase IP_VERSION(13, 0, 10):\n\t\t \n\t\tsmu_v13_0_0_set_mode1_reset_param(smu, 0x00501c00, &param);\n\n\t\tret = smu_cmn_send_debug_smc_msg_with_param(smu,\n\t\t\t\t\t\tDEBUGSMC_MSG_Mode1Reset, param);\n\t\tbreak;\n\n\tdefault:\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_Mode1Reset, NULL);\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tmsleep(SMU13_MODE1_RESET_WAIT_TIME_IN_MS);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_mode2_reset(struct smu_context *smu)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 10))\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_Mode2Reset, NULL);\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_enable_gfx_features(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 10))\n\t\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_EnableAllSmuFeatures,\n\t\t\t\t\t\t\t\t\t\t   FEATURE_PWR_GFX, NULL);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic void smu_v13_0_0_set_smu_mailbox_registers(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tsmu->param_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_82);\n\tsmu->msg_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_66);\n\tsmu->resp_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n\n\tsmu->debug_param_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_53);\n\tsmu->debug_msg_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_75);\n\tsmu->debug_resp_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_54);\n}\n\nstatic int smu_v13_0_0_smu_send_bad_mem_page_num(struct smu_context *smu,\n\t\tuint32_t size)\n{\n\tint ret = 0;\n\n\t \n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_SetNumBadMemoryPagesRetired,\n\t\t\t\t\t  size, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev,\n\t\t\t  \"[%s] failed to message SMU to update bad memory pages number\\n\",\n\t\t\t  __func__);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_send_bad_mem_channel_flag(struct smu_context *smu,\n\t\tuint32_t size)\n{\n\tint ret = 0;\n\n\t \n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t  SMU_MSG_SetBadMemoryPagesRetiredFlagsPerChannel,\n\t\t\t\t  size, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev,\n\t\t\t  \"[%s] failed to message SMU to update bad memory pages channel info\\n\",\n\t\t\t  __func__);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_0_check_ecc_table_support(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t if_version = 0xff, smu_version = 0xff;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 10)) &&\n\t\t(smu_version >= SUPPORT_ECCTABLE_SMU_13_0_10_VERSION))\n\t\treturn ret;\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic ssize_t smu_v13_0_0_get_ecc_info(struct smu_context *smu,\n\t\t\t\t\t\t\t\t\tvoid *table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tEccInfoTable_t *ecc_table = NULL;\n\tstruct ecc_info_per_ch *ecc_info_per_channel = NULL;\n\tint i, ret = 0;\n\tstruct umc_ecc_info *eccinfo = (struct umc_ecc_info *)table;\n\n\tret = smu_v13_0_0_check_ecc_table_support(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_cmn_update_table(smu,\n\t\t\t\t\tSMU_TABLE_ECCINFO,\n\t\t\t\t\t0,\n\t\t\t\t\tsmu_table->ecc_table,\n\t\t\t\t\tfalse);\n\tif (ret) {\n\t\tdev_info(adev->dev, \"Failed to export SMU ecc table!\\n\");\n\t\treturn ret;\n\t}\n\n\tecc_table = (EccInfoTable_t *)smu_table->ecc_table;\n\n\tfor (i = 0; i < ARRAY_SIZE(ecc_table->EccInfo); i++) {\n\t\tecc_info_per_channel = &(eccinfo->ecc[i]);\n\t\tecc_info_per_channel->ce_count_lo_chip =\n\t\t\t\tecc_table->EccInfo[i].ce_count_lo_chip;\n\t\tecc_info_per_channel->ce_count_hi_chip =\n\t\t\t\tecc_table->EccInfo[i].ce_count_hi_chip;\n\t\tecc_info_per_channel->mca_umc_status =\n\t\t\t\tecc_table->EccInfo[i].mca_umc_status;\n\t\tecc_info_per_channel->mca_umc_addr =\n\t\t\t\tecc_table->EccInfo[i].mca_umc_addr;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct pptable_funcs smu_v13_0_0_ppt_funcs = {\n\t.get_allowed_feature_mask = smu_v13_0_0_get_allowed_feature_mask,\n\t.set_default_dpm_table = smu_v13_0_0_set_default_dpm_table,\n\t.i2c_init = smu_v13_0_0_i2c_control_init,\n\t.i2c_fini = smu_v13_0_0_i2c_control_fini,\n\t.is_dpm_running = smu_v13_0_0_is_dpm_running,\n\t.dump_pptable = smu_v13_0_0_dump_pptable,\n\t.init_microcode = smu_v13_0_init_microcode,\n\t.load_microcode = smu_v13_0_load_microcode,\n\t.fini_microcode = smu_v13_0_fini_microcode,\n\t.init_smc_tables = smu_v13_0_0_init_smc_tables,\n\t.fini_smc_tables = smu_v13_0_fini_smc_tables,\n\t.init_power = smu_v13_0_init_power,\n\t.fini_power = smu_v13_0_fini_power,\n\t.check_fw_status = smu_v13_0_check_fw_status,\n\t.setup_pptable = smu_v13_0_0_setup_pptable,\n\t.check_fw_version = smu_v13_0_check_fw_version,\n\t.write_pptable = smu_cmn_write_pptable,\n\t.set_driver_table_location = smu_v13_0_set_driver_table_location,\n\t.system_features_control = smu_v13_0_0_system_features_control,\n\t.set_allowed_mask = smu_v13_0_set_allowed_mask,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.dpm_set_vcn_enable = smu_v13_0_set_vcn_enable,\n\t.dpm_set_jpeg_enable = smu_v13_0_set_jpeg_enable,\n\t.get_dpm_ultimate_freq = smu_v13_0_0_get_dpm_ultimate_freq,\n\t.get_vbios_bootup_values = smu_v13_0_get_vbios_bootup_values,\n\t.read_sensor = smu_v13_0_0_read_sensor,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.print_clk_levels = smu_v13_0_0_print_clk_levels,\n\t.force_clk_levels = smu_v13_0_0_force_clk_levels,\n\t.update_pcie_parameters = smu_v13_0_update_pcie_parameters,\n\t.get_thermal_temperature_range = smu_v13_0_0_get_thermal_temperature_range,\n\t.register_irq_handler = smu_v13_0_register_irq_handler,\n\t.enable_thermal_alert = smu_v13_0_enable_thermal_alert,\n\t.disable_thermal_alert = smu_v13_0_disable_thermal_alert,\n\t.notify_memory_pool_location = smu_v13_0_notify_memory_pool_location,\n\t.get_gpu_metrics = smu_v13_0_0_get_gpu_metrics,\n\t.set_soft_freq_limited_range = smu_v13_0_set_soft_freq_limited_range,\n\t.set_default_od_settings = smu_v13_0_0_set_default_od_settings,\n\t.restore_user_od_settings = smu_v13_0_0_restore_user_od_settings,\n\t.od_edit_dpm_table = smu_v13_0_0_od_edit_dpm_table,\n\t.init_pptable_microcode = smu_v13_0_init_pptable_microcode,\n\t.populate_umd_state_clk = smu_v13_0_0_populate_umd_state_clk,\n\t.set_performance_level = smu_v13_0_set_performance_level,\n\t.gfx_off_control = smu_v13_0_gfx_off_control,\n\t.get_unique_id = smu_v13_0_0_get_unique_id,\n\t.get_fan_speed_pwm = smu_v13_0_0_get_fan_speed_pwm,\n\t.get_fan_speed_rpm = smu_v13_0_0_get_fan_speed_rpm,\n\t.set_fan_speed_pwm = smu_v13_0_set_fan_speed_pwm,\n\t.set_fan_speed_rpm = smu_v13_0_set_fan_speed_rpm,\n\t.get_fan_control_mode = smu_v13_0_get_fan_control_mode,\n\t.set_fan_control_mode = smu_v13_0_set_fan_control_mode,\n\t.enable_mgpu_fan_boost = smu_v13_0_0_enable_mgpu_fan_boost,\n\t.get_power_limit = smu_v13_0_0_get_power_limit,\n\t.set_power_limit = smu_v13_0_set_power_limit,\n\t.set_power_source = smu_v13_0_set_power_source,\n\t.get_power_profile_mode = smu_v13_0_0_get_power_profile_mode,\n\t.set_power_profile_mode = smu_v13_0_0_set_power_profile_mode,\n\t.run_btc = smu_v13_0_run_btc,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_pp_feature_mask = smu_cmn_set_pp_feature_mask,\n\t.set_tool_table_location = smu_v13_0_set_tool_table_location,\n\t.deep_sleep_control = smu_v13_0_deep_sleep_control,\n\t.gfx_ulv_control = smu_v13_0_gfx_ulv_control,\n\t.baco_is_support = smu_v13_0_baco_is_support,\n\t.baco_get_state = smu_v13_0_baco_get_state,\n\t.baco_set_state = smu_v13_0_baco_set_state,\n\t.baco_enter = smu_v13_0_0_baco_enter,\n\t.baco_exit = smu_v13_0_0_baco_exit,\n\t.mode1_reset_is_support = smu_v13_0_0_is_mode1_reset_supported,\n\t.mode1_reset = smu_v13_0_0_mode1_reset,\n\t.mode2_reset = smu_v13_0_0_mode2_reset,\n\t.enable_gfx_features = smu_v13_0_0_enable_gfx_features,\n\t.set_mp1_state = smu_v13_0_0_set_mp1_state,\n\t.set_df_cstate = smu_v13_0_0_set_df_cstate,\n\t.send_hbm_bad_pages_num = smu_v13_0_0_smu_send_bad_mem_page_num,\n\t.send_hbm_bad_channel_flag = smu_v13_0_0_send_bad_mem_channel_flag,\n\t.gpo_control = smu_v13_0_gpo_control,\n\t.get_ecc_info = smu_v13_0_0_get_ecc_info,\n\t.notify_display_change = smu_v13_0_notify_display_change,\n};\n\nvoid smu_v13_0_0_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &smu_v13_0_0_ppt_funcs;\n\tsmu->message_map = smu_v13_0_0_message_map;\n\tsmu->clock_map = smu_v13_0_0_clk_map;\n\tsmu->feature_map = smu_v13_0_0_feature_mask_map;\n\tsmu->table_map = smu_v13_0_0_table_map;\n\tsmu->pwr_src_map = smu_v13_0_0_pwr_src_map;\n\tsmu->workload_map = smu_v13_0_0_workload_map;\n\tsmu->smc_driver_if_version = SMU13_0_0_DRIVER_IF_VERSION;\n\tsmu_v13_0_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}