{
  "module_name": "smu_v13_0.c",
  "hash_id": "2a6a0c4debf99359a6d43d9ae03c02c041fac6a032d6a46d62788ee9ec679ae7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/reboot.h>\n\n#define SMU_13_0_PARTIAL_PPTABLE\n#define SWSMU_CODE_LAYER_L3\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v13_0.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"amdgpu_ras.h\"\n#include \"smu_cmn.h\"\n\n#include \"asic_reg/thm/thm_13_0_2_offset.h\"\n#include \"asic_reg/thm/thm_13_0_2_sh_mask.h\"\n#include \"asic_reg/mp/mp_13_0_2_offset.h\"\n#include \"asic_reg/mp/mp_13_0_2_sh_mask.h\"\n#include \"asic_reg/smuio/smuio_13_0_2_offset.h\"\n#include \"asic_reg/smuio/smuio_13_0_2_sh_mask.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\nMODULE_FIRMWARE(\"amdgpu/aldebaran_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/smu_13_0_0.bin\");\nMODULE_FIRMWARE(\"amdgpu/smu_13_0_7.bin\");\nMODULE_FIRMWARE(\"amdgpu/smu_13_0_10.bin\");\n\n#define mmMP1_SMN_C2PMSG_66                                                                            0x0282\n#define mmMP1_SMN_C2PMSG_66_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_82                                                                            0x0292\n#define mmMP1_SMN_C2PMSG_82_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_90                                                                            0x029a\n#define mmMP1_SMN_C2PMSG_90_BASE_IDX                                                                   0\n\n#define SMU13_VOLTAGE_SCALE 4\n\n#define LINK_WIDTH_MAX\t\t\t\t6\n#define LINK_SPEED_MAX\t\t\t\t3\n\n#define smnPCIE_LC_LINK_WIDTH_CNTL\t\t0x11140288\n#define PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK 0x00000070L\n#define PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT 0x4\n#define smnPCIE_LC_SPEED_CNTL\t\t\t0x11140290\n#define PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK 0xC000\n#define PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT 0xE\n\nstatic const int link_width[] = {0, 1, 2, 4, 8, 12, 16};\n\nconst int pmfw_decoded_link_speed[5] = {1, 2, 3, 4, 5};\nconst int pmfw_decoded_link_width[7] = {0, 1, 2, 4, 8, 12, 16};\n\nint smu_v13_0_init_microcode(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tchar fw_name[30];\n\tchar ucode_prefix[30];\n\tint err = 0;\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tconst struct common_firmware_header *header;\n\tstruct amdgpu_firmware_info *ucode = NULL;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tamdgpu_ucode_ip_version_decode(adev, MP1_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s.bin\", ucode_prefix);\n\n\terr = amdgpu_ucode_request(adev, &adev->pm.fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\thdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\n\tamdgpu_ucode_print_smc_hdr(&hdr->header);\n\tadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tucode = &adev->firmware.ucode[AMDGPU_UCODE_ID_SMC];\n\t\tucode->ucode_id = AMDGPU_UCODE_ID_SMC;\n\t\tucode->fw = adev->pm.fw;\n\t\theader = (const struct common_firmware_header *)ucode->fw->data;\n\t\tadev->firmware.fw_size +=\n\t\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\t}\n\nout:\n\tif (err)\n\t\tamdgpu_ucode_release(&adev->pm.fw);\n\treturn err;\n}\n\nvoid smu_v13_0_fini_microcode(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tamdgpu_ucode_release(&adev->pm.fw);\n\tadev->pm.fw_version = 0;\n}\n\nint smu_v13_0_load_microcode(struct smu_context *smu)\n{\n#if 0\n\tstruct amdgpu_device *adev = smu->adev;\n\tconst uint32_t *src;\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tuint32_t addr_start = MP1_SRAM;\n\tuint32_t i;\n\tuint32_t smc_fw_size;\n\tuint32_t mp1_fw_flags;\n\n\thdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\n\tsrc = (const uint32_t *)(adev->pm.fw->data +\n\t\t\t\t le32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\tsmc_fw_size = hdr->header.ucode_size_bytes;\n\n\tfor (i = 1; i < smc_fw_size/4 - 1; i++) {\n\t\tWREG32_PCIE(addr_start, src[i]);\n\t\taddr_start += 4;\n\t}\n\n\tWREG32_PCIE(MP1_Public | (smnMP1_PUB_CTRL & 0xffffffff),\n\t\t    1 & MP1_SMN_PUB_CTRL__RESET_MASK);\n\tWREG32_PCIE(MP1_Public | (smnMP1_PUB_CTRL & 0xffffffff),\n\t\t    1 & ~MP1_SMN_PUB_CTRL__RESET_MASK);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t\t\t\t   (smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\t\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t\t    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i == adev->usec_timeout)\n\t\treturn -ETIME;\n#endif\n\n\treturn 0;\n}\n\nint smu_v13_0_init_pptable_microcode(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_firmware_info *ucode = NULL;\n\tuint32_t size = 0, pptable_id = 0;\n\tint ret = 0;\n\tvoid *table;\n\n\t \n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tif (adev->firmware.load_type != AMDGPU_FW_LOAD_PSP)\n\t\treturn 0;\n\n\tif (!adev->scpm_enabled)\n\t\treturn 0;\n\n\tif ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 7)) ||\n\t    (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 0)) ||\n\t    (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 10)))\n\t\treturn 0;\n\n\t \n\tif (amdgpu_smu_pptable_id >= 0) {\n\t\tpptable_id = amdgpu_smu_pptable_id;\n\t\tdev_info(adev->dev, \"override pptable id %d\\n\", pptable_id);\n\t} else {\n\t\tpptable_id = smu->smu_table.boot_values.pp_table_id;\n\t}\n\n\t \n\tif (!pptable_id)\n\t\treturn 0;\n\n\tret = smu_v13_0_get_pptable_from_firmware(smu, &table, &size, pptable_id);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu->pptable_firmware.data = table;\n\tsmu->pptable_firmware.size = size;\n\n\tucode = &adev->firmware.ucode[AMDGPU_UCODE_ID_PPTABLE];\n\tucode->ucode_id = AMDGPU_UCODE_ID_PPTABLE;\n\tucode->fw = &smu->pptable_firmware;\n\tadev->firmware.fw_size +=\n\t\tALIGN(smu->pptable_firmware.size, PAGE_SIZE);\n\n\treturn 0;\n}\n\nint smu_v13_0_check_fw_status(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t mp1_fw_flags;\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(13, 0, 4):\n\tcase IP_VERSION(13, 0, 11):\n\t\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t\t\t\t   (smnMP1_V13_0_4_FIRMWARE_FLAGS & 0xffffffff));\n\t\tbreak;\n\tdefault:\n\t\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t\t\t\t   (smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\t\tbreak;\n\t}\n\n\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint smu_v13_0_check_fw_version(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t if_version = 0xff, smu_version = 0xff;\n\tuint8_t smu_program, smu_major, smu_minor, smu_debug;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_program = (smu_version >> 24) & 0xff;\n\tsmu_major = (smu_version >> 16) & 0xff;\n\tsmu_minor = (smu_version >> 8) & 0xff;\n\tsmu_debug = (smu_version >> 0) & 0xff;\n\tif (smu->is_apu ||\n\t    adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 6))\n\t\tadev->pm.fw_version = smu_version;\n\n\t \n\tif (adev->pm.fw)\n\t\tdev_dbg(smu->adev->dev, \"smu fw reported program %d, version = 0x%08x (%d.%d.%d)\\n\",\n\t\t\t smu_program, smu_version, smu_major, smu_minor, smu_debug);\n\n\t \n\tif (if_version != smu->smc_driver_if_version) {\n\t\tdev_info(adev->dev, \"smu driver if version = 0x%08x, smu fw if version = 0x%08x, \"\n\t\t\t \"smu fw program = %d, smu fw version = 0x%08x (%d.%d.%d)\\n\",\n\t\t\t smu->smc_driver_if_version, if_version,\n\t\t\t smu_program, smu_version, smu_major, smu_minor, smu_debug);\n\t\tdev_info(adev->dev, \"SMU driver if version not matched\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_set_pptable_v2_0(struct smu_context *smu, void **table, uint32_t *size)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t ppt_offset_bytes;\n\tconst struct smc_firmware_header_v2_0 *v2;\n\n\tv2 = (const struct smc_firmware_header_v2_0 *) adev->pm.fw->data;\n\n\tppt_offset_bytes = le32_to_cpu(v2->ppt_offset_bytes);\n\t*size = le32_to_cpu(v2->ppt_size_bytes);\n\t*table = (uint8_t *)v2 + ppt_offset_bytes;\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_set_pptable_v2_1(struct smu_context *smu, void **table,\n\t\t\t\t      uint32_t *size, uint32_t pptable_id)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tconst struct smc_firmware_header_v2_1 *v2_1;\n\tstruct smc_soft_pptable_entry *entries;\n\tuint32_t pptable_count = 0;\n\tint i = 0;\n\n\tv2_1 = (const struct smc_firmware_header_v2_1 *) adev->pm.fw->data;\n\tentries = (struct smc_soft_pptable_entry *)\n\t\t((uint8_t *)v2_1 + le32_to_cpu(v2_1->pptable_entry_offset));\n\tpptable_count = le32_to_cpu(v2_1->pptable_count);\n\tfor (i = 0; i < pptable_count; i++) {\n\t\tif (le32_to_cpu(entries[i].id) == pptable_id) {\n\t\t\t*table = ((uint8_t *)v2_1 + le32_to_cpu(entries[i].ppt_offset_bytes));\n\t\t\t*size = le32_to_cpu(entries[i].ppt_size_bytes);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == pptable_count)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_get_pptable_from_vbios(struct smu_context *smu, void **table, uint32_t *size)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint16_t atom_table_size;\n\tuint8_t frev, crev;\n\tint ret, index;\n\n\tdev_info(adev->dev, \"use vbios provided pptable\\n\");\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    powerplayinfo);\n\n\tret = amdgpu_atombios_get_data_table(adev, index, &atom_table_size, &frev, &crev,\n\t\t\t\t\t     (uint8_t **)table);\n\tif (ret)\n\t\treturn ret;\n\n\tif (size)\n\t\t*size = atom_table_size;\n\n\treturn 0;\n}\n\nint smu_v13_0_get_pptable_from_firmware(struct smu_context *smu,\n\t\t\t\t\tvoid **table,\n\t\t\t\t\tuint32_t *size,\n\t\t\t\t\tuint32_t pptable_id)\n{\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint16_t version_major, version_minor;\n\tint ret;\n\n\thdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\n\tif (!hdr)\n\t\treturn -EINVAL;\n\n\tdev_info(adev->dev, \"use driver provided pptable %d\\n\", pptable_id);\n\n\tversion_major = le16_to_cpu(hdr->header.header_version_major);\n\tversion_minor = le16_to_cpu(hdr->header.header_version_minor);\n\tif (version_major != 2) {\n\t\tdev_err(adev->dev, \"Unsupported smu firmware version %d.%d\\n\",\n\t\t\tversion_major, version_minor);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (version_minor) {\n\tcase 0:\n\t\tret = smu_v13_0_set_pptable_v2_0(smu, table, size);\n\t\tbreak;\n\tcase 1:\n\t\tret = smu_v13_0_set_pptable_v2_1(smu, table, size, pptable_id);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_setup_pptable(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t size = 0, pptable_id = 0;\n\tvoid *table;\n\tint ret = 0;\n\n\t \n\tif (amdgpu_smu_pptable_id >= 0) {\n\t\tpptable_id = amdgpu_smu_pptable_id;\n\t\tdev_info(adev->dev, \"override pptable id %d\\n\", pptable_id);\n\t} else {\n\t\tpptable_id = smu->smu_table.boot_values.pp_table_id;\n\t}\n\n\t \n\tif ((amdgpu_sriov_vf(adev) || !pptable_id) && (amdgpu_emu_mode != 1))\n\t\tret = smu_v13_0_get_pptable_from_vbios(smu, &table, &size);\n\telse\n\t\tret = smu_v13_0_get_pptable_from_firmware(smu, &table, &size, pptable_id);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (!smu->smu_table.power_play_table)\n\t\tsmu->smu_table.power_play_table = table;\n\tif (!smu->smu_table.power_play_table_size)\n\t\tsmu->smu_table.power_play_table_size = size;\n\n\treturn 0;\n}\n\nint smu_v13_0_init_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\tint ret = 0;\n\n\tsmu_table->driver_pptable =\n\t\tkzalloc(tables[SMU_TABLE_PPTABLE].size, GFP_KERNEL);\n\tif (!smu_table->driver_pptable) {\n\t\tret = -ENOMEM;\n\t\tgoto err0_out;\n\t}\n\n\tsmu_table->max_sustainable_clocks =\n\t\tkzalloc(sizeof(struct smu_13_0_max_sustainable_clocks), GFP_KERNEL);\n\tif (!smu_table->max_sustainable_clocks) {\n\t\tret = -ENOMEM;\n\t\tgoto err1_out;\n\t}\n\n\t \n\tif (tables[SMU_TABLE_OVERDRIVE].size) {\n\t\tsmu_table->overdrive_table =\n\t\t\tkzalloc(tables[SMU_TABLE_OVERDRIVE].size, GFP_KERNEL);\n\t\tif (!smu_table->overdrive_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err2_out;\n\t\t}\n\n\t\tsmu_table->boot_overdrive_table =\n\t\t\tkzalloc(tables[SMU_TABLE_OVERDRIVE].size, GFP_KERNEL);\n\t\tif (!smu_table->boot_overdrive_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err3_out;\n\t\t}\n\n\t\tsmu_table->user_overdrive_table =\n\t\t\tkzalloc(tables[SMU_TABLE_OVERDRIVE].size, GFP_KERNEL);\n\t\tif (!smu_table->user_overdrive_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err4_out;\n\t\t}\n\t}\n\n\tsmu_table->combo_pptable =\n\t\tkzalloc(tables[SMU_TABLE_COMBO_PPTABLE].size, GFP_KERNEL);\n\tif (!smu_table->combo_pptable) {\n\t\tret = -ENOMEM;\n\t\tgoto err5_out;\n\t}\n\n\treturn 0;\n\nerr5_out:\n\tkfree(smu_table->user_overdrive_table);\nerr4_out:\n\tkfree(smu_table->boot_overdrive_table);\nerr3_out:\n\tkfree(smu_table->overdrive_table);\nerr2_out:\n\tkfree(smu_table->max_sustainable_clocks);\nerr1_out:\n\tkfree(smu_table->driver_pptable);\nerr0_out:\n\treturn ret;\n}\n\nint smu_v13_0_fini_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tkfree(smu_table->gpu_metrics_table);\n\tkfree(smu_table->combo_pptable);\n\tkfree(smu_table->user_overdrive_table);\n\tkfree(smu_table->boot_overdrive_table);\n\tkfree(smu_table->overdrive_table);\n\tkfree(smu_table->max_sustainable_clocks);\n\tkfree(smu_table->driver_pptable);\n\tsmu_table->gpu_metrics_table = NULL;\n\tsmu_table->combo_pptable = NULL;\n\tsmu_table->user_overdrive_table = NULL;\n\tsmu_table->boot_overdrive_table = NULL;\n\tsmu_table->overdrive_table = NULL;\n\tsmu_table->max_sustainable_clocks = NULL;\n\tsmu_table->driver_pptable = NULL;\n\tkfree(smu_table->hardcode_pptable);\n\tsmu_table->hardcode_pptable = NULL;\n\n\tkfree(smu_table->ecc_table);\n\tkfree(smu_table->metrics_table);\n\tkfree(smu_table->watermarks_table);\n\tsmu_table->ecc_table = NULL;\n\tsmu_table->metrics_table = NULL;\n\tsmu_table->watermarks_table = NULL;\n\tsmu_table->metrics_time = 0;\n\n\tkfree(smu_dpm->dpm_context);\n\tkfree(smu_dpm->golden_dpm_context);\n\tkfree(smu_dpm->dpm_current_power_state);\n\tkfree(smu_dpm->dpm_request_power_state);\n\tsmu_dpm->dpm_context = NULL;\n\tsmu_dpm->golden_dpm_context = NULL;\n\tsmu_dpm->dpm_context_size = 0;\n\tsmu_dpm->dpm_current_power_state = NULL;\n\tsmu_dpm->dpm_request_power_state = NULL;\n\n\treturn 0;\n}\n\nint smu_v13_0_init_power(struct smu_context *smu)\n{\n\tstruct smu_power_context *smu_power = &smu->smu_power;\n\n\tif (smu_power->power_context || smu_power->power_context_size != 0)\n\t\treturn -EINVAL;\n\n\tsmu_power->power_context = kzalloc(sizeof(struct smu_13_0_power_context),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!smu_power->power_context)\n\t\treturn -ENOMEM;\n\tsmu_power->power_context_size = sizeof(struct smu_13_0_power_context);\n\n\treturn 0;\n}\n\nint smu_v13_0_fini_power(struct smu_context *smu)\n{\n\tstruct smu_power_context *smu_power = &smu->smu_power;\n\n\tif (!smu_power->power_context || smu_power->power_context_size == 0)\n\t\treturn -EINVAL;\n\n\tkfree(smu_power->power_context);\n\tsmu_power->power_context = NULL;\n\tsmu_power->power_context_size = 0;\n\n\treturn 0;\n}\n\nint smu_v13_0_get_vbios_bootup_values(struct smu_context *smu)\n{\n\tint ret, index;\n\tuint16_t size;\n\tuint8_t frev, crev;\n\tstruct atom_common_table_header *header;\n\tstruct atom_firmware_info_v3_4 *v_3_4;\n\tstruct atom_firmware_info_v3_3 *v_3_3;\n\tstruct atom_firmware_info_v3_1 *v_3_1;\n\tstruct atom_smu_info_v3_6 *smu_info_v3_6;\n\tstruct atom_smu_info_v4_0 *smu_info_v4_0;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    firmwareinfo);\n\n\tret = amdgpu_atombios_get_data_table(smu->adev, index, &size, &frev, &crev,\n\t\t\t\t\t     (uint8_t **)&header);\n\tif (ret)\n\t\treturn ret;\n\n\tif (header->format_revision != 3) {\n\t\tdev_err(smu->adev->dev, \"unknown atom_firmware_info version! for smu13\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (header->content_revision) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tv_3_1 = (struct atom_firmware_info_v3_1 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_1->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_1->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_1->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_1->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_1->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_1->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_1->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_1->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = 0;\n\t\tbreak;\n\tcase 3:\n\t\tv_3_3 = (struct atom_firmware_info_v3_3 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_3->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_3->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_3->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_3->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_3->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_3->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_3->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_3->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = v_3_3->pplib_pptable_id;\n\t\tbreak;\n\tcase 4:\n\tdefault:\n\t\tv_3_4 = (struct atom_firmware_info_v3_4 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_4->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_4->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_4->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_4->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_4->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_4->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_4->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_4->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = v_3_4->pplib_pptable_id;\n\t\tbreak;\n\t}\n\n\tsmu->smu_table.boot_values.format_revision = header->format_revision;\n\tsmu->smu_table.boot_values.content_revision = header->content_revision;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    smu_info);\n\tif (!amdgpu_atombios_get_data_table(smu->adev, index, &size, &frev, &crev,\n\t\t\t\t\t    (uint8_t **)&header)) {\n\n\t\tif ((frev == 3) && (crev == 6)) {\n\t\t\tsmu_info_v3_6 = (struct atom_smu_info_v3_6 *)header;\n\n\t\t\tsmu->smu_table.boot_values.socclk = smu_info_v3_6->bootup_socclk_10khz;\n\t\t\tsmu->smu_table.boot_values.vclk = smu_info_v3_6->bootup_vclk_10khz;\n\t\t\tsmu->smu_table.boot_values.dclk = smu_info_v3_6->bootup_dclk_10khz;\n\t\t\tsmu->smu_table.boot_values.fclk = smu_info_v3_6->bootup_fclk_10khz;\n\t\t} else if ((frev == 3) && (crev == 1)) {\n\t\t\treturn 0;\n\t\t} else if ((frev == 4) && (crev == 0)) {\n\t\t\tsmu_info_v4_0 = (struct atom_smu_info_v4_0 *)header;\n\n\t\t\tsmu->smu_table.boot_values.socclk = smu_info_v4_0->bootup_socclk_10khz;\n\t\t\tsmu->smu_table.boot_values.dcefclk = smu_info_v4_0->bootup_dcefclk_10khz;\n\t\t\tsmu->smu_table.boot_values.vclk = smu_info_v4_0->bootup_vclk0_10khz;\n\t\t\tsmu->smu_table.boot_values.dclk = smu_info_v4_0->bootup_dclk0_10khz;\n\t\t\tsmu->smu_table.boot_values.fclk = smu_info_v4_0->bootup_fclk_10khz;\n\t\t} else {\n\t\t\tdev_warn(smu->adev->dev, \"Unexpected and unhandled version: %d.%d\\n\",\n\t\t\t\t\t\t(uint32_t)frev, (uint32_t)crev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nint smu_v13_0_notify_memory_pool_location(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *memory_pool = &smu_table->memory_pool;\n\tint ret = 0;\n\tuint64_t address;\n\tuint32_t address_low, address_high;\n\n\tif (memory_pool->size == 0 || memory_pool->cpu_addr == NULL)\n\t\treturn ret;\n\n\taddress = memory_pool->mc_address;\n\taddress_high = (uint32_t)upper_32_bits(address);\n\taddress_low  = (uint32_t)lower_32_bits(address);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DramLogSetDramAddrHigh,\n\t\t\t\t\t      address_high, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DramLogSetDramAddrLow,\n\t\t\t\t\t      address_low, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DramLogSetDramSize,\n\t\t\t\t\t      (uint32_t)memory_pool->size, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nint smu_v13_0_set_min_deep_sleep_dcefclk(struct smu_context *smu, uint32_t clk)\n{\n\tint ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_SetMinDeepSleepDcefclk, clk, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"SMU13 attempt to set divider for DCEFCLK Failed!\");\n\n\treturn ret;\n}\n\nint smu_v13_0_set_driver_table_location(struct smu_context *smu)\n{\n\tstruct smu_table *driver_table = &smu->smu_table.driver_table;\n\tint ret = 0;\n\n\tif (driver_table->mc_address) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetDriverDramAddrHigh,\n\t\t\t\t\t\t      upper_32_bits(driver_table->mc_address),\n\t\t\t\t\t\t      NULL);\n\t\tif (!ret)\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t      SMU_MSG_SetDriverDramAddrLow,\n\t\t\t\t\t\t\t      lower_32_bits(driver_table->mc_address),\n\t\t\t\t\t\t\t      NULL);\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_set_tool_table_location(struct smu_context *smu)\n{\n\tint ret = 0;\n\tstruct smu_table *tool_table = &smu->smu_table.tables[SMU_TABLE_PMSTATUSLOG];\n\n\tif (tool_table->mc_address) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetToolsDramAddrHigh,\n\t\t\t\t\t\t      upper_32_bits(tool_table->mc_address),\n\t\t\t\t\t\t      NULL);\n\t\tif (!ret)\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t      SMU_MSG_SetToolsDramAddrLow,\n\t\t\t\t\t\t\t      lower_32_bits(tool_table->mc_address),\n\t\t\t\t\t\t\t      NULL);\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_init_display_count(struct smu_context *smu, uint32_t count)\n{\n\tint ret = 0;\n\n\tif (!smu->pm_enabled)\n\t\treturn ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays, count, NULL);\n\n\treturn ret;\n}\n\nint smu_v13_0_set_allowed_mask(struct smu_context *smu)\n{\n\tstruct smu_feature *feature = &smu->smu_feature;\n\tint ret = 0;\n\tuint32_t feature_mask[2];\n\n\tif (bitmap_empty(feature->allowed, SMU_FEATURE_MAX) ||\n\t    feature->feature_num < 64)\n\t\treturn -EINVAL;\n\n\tbitmap_to_arr32(feature_mask, feature->allowed, 64);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetAllowedFeaturesMaskHigh,\n\t\t\t\t\t      feature_mask[1], NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SetAllowedFeaturesMaskLow,\n\t\t\t\t\t       feature_mask[0],\n\t\t\t\t\t       NULL);\n}\n\nint smu_v13_0_gfx_off_control(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(13, 0, 0):\n\tcase IP_VERSION(13, 0, 1):\n\tcase IP_VERSION(13, 0, 3):\n\tcase IP_VERSION(13, 0, 4):\n\tcase IP_VERSION(13, 0, 5):\n\tcase IP_VERSION(13, 0, 7):\n\tcase IP_VERSION(13, 0, 8):\n\tcase IP_VERSION(13, 0, 10):\n\tcase IP_VERSION(13, 0, 11):\n\t\tif (!(adev->pm.pp_feature & PP_GFXOFF_MASK))\n\t\t\treturn 0;\n\t\tif (enable)\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_AllowGfxOff, NULL);\n\t\telse\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_DisallowGfxOff, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_system_features_control(struct smu_context *smu,\n\t\t\t\t      bool en)\n{\n\treturn smu_cmn_send_smc_msg(smu, (en ? SMU_MSG_EnableAllSmuFeatures :\n\t\t\t\t\t  SMU_MSG_DisableAllSmuFeatures), NULL);\n}\n\nint smu_v13_0_notify_display_change(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif (!amdgpu_device_has_dc_support(smu->adev))\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_DALNotPresent, NULL);\n\n\treturn ret;\n}\n\n\tstatic int\nsmu_v13_0_get_max_sustainable_clock(struct smu_context *smu, uint32_t *clock,\n\t\t\t\t    enum smu_clk_type clock_select)\n{\n\tint ret = 0;\n\tint clk_id;\n\n\tif ((smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG, SMU_MSG_GetDcModeMaxDpmFreq) < 0) ||\n\t    (smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG, SMU_MSG_GetMaxDpmFreq) < 0))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclock_select);\n\tif (clk_id < 0)\n\t\treturn -EINVAL;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetDcModeMaxDpmFreq,\n\t\t\t\t\t      clk_id << 16, clock);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[GetMaxSustainableClock] Failed to get max DC clock from SMC!\");\n\t\treturn ret;\n\t}\n\n\tif (*clock != 0)\n\t\treturn 0;\n\n\t \n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetMaxDpmFreq,\n\t\t\t\t\t      clk_id << 16, clock);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[GetMaxSustainableClock] failed to get max AC clock from SMC!\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint smu_v13_0_init_max_sustainable_clocks(struct smu_context *smu)\n{\n\tstruct smu_13_0_max_sustainable_clocks *max_sustainable_clocks =\n\t\tsmu->smu_table.max_sustainable_clocks;\n\tint ret = 0;\n\n\tmax_sustainable_clocks->uclock = smu->smu_table.boot_values.uclk / 100;\n\tmax_sustainable_clocks->soc_clock = smu->smu_table.boot_values.socclk / 100;\n\tmax_sustainable_clocks->dcef_clock = smu->smu_table.boot_values.dcefclk / 100;\n\tmax_sustainable_clocks->display_clock = 0xFFFFFFFF;\n\tmax_sustainable_clocks->phy_clock = 0xFFFFFFFF;\n\tmax_sustainable_clocks->pixel_clock = 0xFFFFFFFF;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v13_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->uclock),\n\t\t\t\t\t\t\t  SMU_UCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max UCLK from SMC!\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_v13_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->soc_clock),\n\t\t\t\t\t\t\t  SMU_SOCCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max SOCCLK from SMC!\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v13_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->dcef_clock),\n\t\t\t\t\t\t\t  SMU_DCEFCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max DCEFCLK from SMC!\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smu_v13_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->display_clock),\n\t\t\t\t\t\t\t  SMU_DISPCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max DISPCLK from SMC!\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t\tret = smu_v13_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->phy_clock),\n\t\t\t\t\t\t\t  SMU_PHYCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max PHYCLK from SMC!\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t\tret = smu_v13_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->pixel_clock),\n\t\t\t\t\t\t\t  SMU_PIXCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max PIXCLK from SMC!\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (max_sustainable_clocks->soc_clock < max_sustainable_clocks->uclock)\n\t\tmax_sustainable_clocks->uclock = max_sustainable_clocks->soc_clock;\n\n\treturn 0;\n}\n\nint smu_v13_0_get_current_power_limit(struct smu_context *smu,\n\t\t\t\t      uint32_t *power_limit)\n{\n\tint power_src;\n\tint ret = 0;\n\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_PPT_BIT))\n\t\treturn -EINVAL;\n\n\tpower_src = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t   CMN2ASIC_MAPPING_PWR,\n\t\t\t\t\t\t   smu->adev->pm.ac_power ?\n\t\t\t\t\t\t   SMU_POWER_SOURCE_AC :\n\t\t\t\t\t\t   SMU_POWER_SOURCE_DC);\n\tif (power_src < 0)\n\t\treturn -EINVAL;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_GetPptLimit,\n\t\t\t\t\t      power_src << 16,\n\t\t\t\t\t      power_limit);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"[%s] get PPT limit failed!\", __func__);\n\n\treturn ret;\n}\n\nint smu_v13_0_set_power_limit(struct smu_context *smu,\n\t\t\t      enum smu_ppt_limit_type limit_type,\n\t\t\t      uint32_t limit)\n{\n\tint ret = 0;\n\n\tif (limit_type != SMU_DEFAULT_PPT_LIMIT)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_PPT_BIT)) {\n\t\tdev_err(smu->adev->dev, \"Setting new power limit is not supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetPptLimit, limit, NULL);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[%s] Set power limit Failed!\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsmu->current_power_limit = limit;\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_allow_ih_interrupt(struct smu_context *smu)\n{\n\treturn smu_cmn_send_smc_msg(smu,\n\t\t\t\t    SMU_MSG_AllowIHHostInterrupt,\n\t\t\t\t    NULL);\n}\n\nstatic int smu_v13_0_process_pending_interrupt(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif (smu->dc_controlled_by_gpio &&\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_ACDC_BIT))\n\t\tret = smu_v13_0_allow_ih_interrupt(smu);\n\n\treturn ret;\n}\n\nint smu_v13_0_enable_thermal_alert(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif (!smu->irq_source.num_types)\n\t\treturn 0;\n\n\tret = amdgpu_irq_get(smu->adev, &smu->irq_source, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_v13_0_process_pending_interrupt(smu);\n}\n\nint smu_v13_0_disable_thermal_alert(struct smu_context *smu)\n{\n\tif (!smu->irq_source.num_types)\n\t\treturn 0;\n\n\treturn amdgpu_irq_put(smu->adev, &smu->irq_source, 0);\n}\n\nstatic uint16_t convert_to_vddc(uint8_t vid)\n{\n\treturn (uint16_t) ((6200 - (vid * 25)) / SMU13_VOLTAGE_SCALE);\n}\n\nint smu_v13_0_get_gfx_vdd(struct smu_context *smu, uint32_t *value)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t vdd = 0, val_vid = 0;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\tval_vid = (RREG32_SOC15(SMUIO, 0, regSMUSVI0_TEL_PLANE0) &\n\t\t   SMUSVI0_TEL_PLANE0__SVI0_PLANE0_VDDCOR_MASK) >>\n\t\tSMUSVI0_TEL_PLANE0__SVI0_PLANE0_VDDCOR__SHIFT;\n\n\tvdd = (uint32_t)convert_to_vddc((uint8_t)val_vid);\n\n\t*value = vdd;\n\n\treturn 0;\n\n}\n\nint\nsmu_v13_0_display_clock_voltage_request(struct smu_context *smu,\n\t\t\t\t\tstruct pp_display_clock_request\n\t\t\t\t\t*clock_req)\n{\n\tenum amd_pp_clock_type clk_type = clock_req->clock_type;\n\tint ret = 0;\n\tenum smu_clk_type clk_select = 0;\n\tuint32_t clk_freq = clock_req->clock_freq_in_khz / 1000;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) ||\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tswitch (clk_type) {\n\t\tcase amd_pp_dcef_clock:\n\t\t\tclk_select = SMU_DCEFCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_disp_clock:\n\t\t\tclk_select = SMU_DISPCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_pixel_clock:\n\t\t\tclk_select = SMU_PIXCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_phy_clock:\n\t\t\tclk_select = SMU_PHYCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_mem_clock:\n\t\t\tclk_select = SMU_UCLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(smu->adev->dev, \"[%s] Invalid Clock Type!\", __func__);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\tif (clk_select == SMU_UCLK && smu->disable_uclk_switch)\n\t\t\treturn 0;\n\n\t\tret = smu_v13_0_set_hard_freq_limited_range(smu, clk_select, clk_freq, 0);\n\n\t\tif (clk_select == SMU_UCLK)\n\t\t\tsmu->hard_min_uclk_req_from_dal = clk_freq;\n\t}\n\nfailed:\n\treturn ret;\n}\n\nuint32_t smu_v13_0_get_fan_control_mode(struct smu_context *smu)\n{\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT))\n\t\treturn AMD_FAN_CTRL_MANUAL;\n\telse\n\t\treturn AMD_FAN_CTRL_AUTO;\n}\n\n\tstatic int\nsmu_v13_0_auto_fan_control(struct smu_context *smu, bool auto_fan_control)\n{\n\tint ret = 0;\n\n\tif (!smu_cmn_feature_is_supported(smu, SMU_FEATURE_FAN_CONTROL_BIT))\n\t\treturn 0;\n\n\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT, auto_fan_control);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"[%s]%s smc FAN CONTROL feature failed!\",\n\t\t\t__func__, (auto_fan_control ? \"Start\" : \"Stop\"));\n\n\treturn ret;\n}\n\n\tstatic int\nsmu_v13_0_set_fan_static_mode(struct smu_context *smu, uint32_t mode)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tWREG32_SOC15(THM, 0, regCG_FDO_CTRL2,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, regCG_FDO_CTRL2),\n\t\t\t\t   CG_FDO_CTRL2, TMIN, 0));\n\tWREG32_SOC15(THM, 0, regCG_FDO_CTRL2,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, regCG_FDO_CTRL2),\n\t\t\t\t   CG_FDO_CTRL2, FDO_PWM_MODE, mode));\n\n\treturn 0;\n}\n\nint smu_v13_0_set_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\tuint32_t speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t duty100, duty;\n\tuint64_t tmp64;\n\n\tspeed = MIN(speed, 255);\n\n\tif (smu_v13_0_auto_fan_control(smu, 0))\n\t\treturn -EINVAL;\n\n\tduty100 = REG_GET_FIELD(RREG32_SOC15(THM, 0, regCG_FDO_CTRL1),\n\t\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\tif (!duty100)\n\t\treturn -EINVAL;\n\n\ttmp64 = (uint64_t)speed * duty100;\n\tdo_div(tmp64, 255);\n\tduty = (uint32_t)tmp64;\n\n\tWREG32_SOC15(THM, 0, regCG_FDO_CTRL0,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, regCG_FDO_CTRL0),\n\t\t\t\t   CG_FDO_CTRL0, FDO_STATIC_DUTY, duty));\n\n\treturn smu_v13_0_set_fan_static_mode(smu, FDO_PWM_MODE_STATIC);\n}\n\n\tint\nsmu_v13_0_set_fan_control_mode(struct smu_context *smu,\n\t\t\t       uint32_t mode)\n{\n\tint ret = 0;\n\n\tswitch (mode) {\n\tcase AMD_FAN_CTRL_NONE:\n\t\tret = smu_v13_0_set_fan_speed_pwm(smu, 255);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_MANUAL:\n\t\tret = smu_v13_0_auto_fan_control(smu, 0);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_AUTO:\n\t\tret = smu_v13_0_auto_fan_control(smu, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[%s]Set fan control mode failed!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_set_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\tuint32_t speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t crystal_clock_freq = 2500;\n\tuint32_t tach_period;\n\tint ret;\n\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\tret = smu_v13_0_auto_fan_control(smu, 0);\n\tif (ret)\n\t\treturn ret;\n\n\ttach_period = 60 * crystal_clock_freq * 10000 / (8 * speed);\n\tWREG32_SOC15(THM, 0, regCG_TACH_CTRL,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, regCG_TACH_CTRL),\n\t\t\t\t   CG_TACH_CTRL, TARGET_PERIOD,\n\t\t\t\t   tach_period));\n\n\treturn smu_v13_0_set_fan_static_mode(smu, FDO_PWM_MODE_STATIC_RPM);\n}\n\nint smu_v13_0_set_xgmi_pstate(struct smu_context *smu,\n\t\t\t      uint32_t pstate)\n{\n\tint ret = 0;\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_SetXgmiMode,\n\t\t\t\t\t      pstate ? XGMI_MODE_PSTATE_D0 : XGMI_MODE_PSTATE_D3,\n\t\t\t\t\t      NULL);\n\treturn ret;\n}\n\nstatic int smu_v13_0_set_irq_state(struct amdgpu_device *adev,\n\t\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t\t   unsigned tyep,\n\t\t\t\t   enum amdgpu_interrupt_state state)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tuint32_t low, high;\n\tuint32_t val = 0;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\t \n\t\tval = RREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTH_MASK, 1);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTL_MASK, 1);\n\t\tWREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL, val);\n\n\t\tWREG32_SOC15(THM, 0, regTHM_THERMAL_INT_ENA, 0);\n\n\t\t \n\t\tval = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT_CTRL, INT_MASK, 1);\n\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL, val);\n\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\t \n\t\tlow = max(SMU_THERMAL_MINIMUM_ALERT_TEMP,\n\t\t\t  smu->thermal_range.min / SMU_TEMPERATURE_UNITS_PER_CENTIGRADES);\n\t\thigh = min(SMU_THERMAL_MAXIMUM_ALERT_TEMP,\n\t\t\t   smu->thermal_range.software_shutdown_temp);\n\n\t\tval = RREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, MAX_IH_CREDIT, 5);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_IH_HW_ENA, 1);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTH_MASK, 0);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTL_MASK, 0);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTH, (high & 0xff));\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTL, (low & 0xff));\n\t\tval = val & (~THM_THERMAL_INT_CTRL__THERM_TRIGGER_MASK_MASK);\n\t\tWREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL, val);\n\n\t\tval = (1 << THM_THERMAL_INT_ENA__THERM_INTH_CLR__SHIFT);\n\t\tval |= (1 << THM_THERMAL_INT_ENA__THERM_INTL_CLR__SHIFT);\n\t\tval |= (1 << THM_THERMAL_INT_ENA__THERM_TRIGGER_CLR__SHIFT);\n\t\tWREG32_SOC15(THM, 0, regTHM_THERMAL_INT_ENA, val);\n\n\t\t \n\t\tval = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT, ID, 0xFE);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT, VALID, 0);\n\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT, val);\n\n\t\tval = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT_CTRL, INT_MASK, 0);\n\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL, val);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_ack_ac_dc_interrupt(struct smu_context *smu)\n{\n\treturn smu_cmn_send_smc_msg(smu,\n\t\t\t\t    SMU_MSG_ReenableAcDcInterrupt,\n\t\t\t\t    NULL);\n}\n\n#define THM_11_0__SRCID__THM_DIG_THERM_L2H\t\t0\t\t \n#define THM_11_0__SRCID__THM_DIG_THERM_H2L\t\t1\t\t \n#define SMUIO_11_0__SRCID__SMUIO_GPIO19\t\t\t83\n\nstatic int smu_v13_0_irq_process(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tuint32_t client_id = entry->client_id;\n\tuint32_t src_id = entry->src_id;\n\t \n\tuint32_t ctxid = entry->src_data[0];\n\tuint32_t data;\n\tuint32_t high;\n\n\tif (client_id == SOC15_IH_CLIENTID_THM) {\n\t\tswitch (src_id) {\n\t\tcase THM_11_0__SRCID__THM_DIG_THERM_L2H:\n\t\t\tschedule_delayed_work(&smu->swctf_delayed_work,\n\t\t\t\t\t      msecs_to_jiffies(AMDGPU_SWCTF_EXTRA_DELAY));\n\t\t\tbreak;\n\t\tcase THM_11_0__SRCID__THM_DIG_THERM_H2L:\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU under temperature range detected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU under temperature range unknown src id (%d)\\n\",\n\t\t\t\t  src_id);\n\t\t\tbreak;\n\t\t}\n\t} else if (client_id == SOC15_IH_CLIENTID_ROM_SMUIO) {\n\t\tdev_emerg(adev->dev, \"ERROR: GPU HW Critical Temperature Fault(aka CTF) detected!\\n\");\n\t\t \n\t\tdev_emerg(adev->dev, \"ERROR: System is going to shutdown due to GPU HW CTF!\\n\");\n\t\torderly_poweroff(true);\n\t} else if (client_id == SOC15_IH_CLIENTID_MP1) {\n\t\tif (src_id == 0xfe) {\n\t\t\t \n\t\t\tdata = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL);\n\t\t\tdata = REG_SET_FIELD(data, MP1_SMN_IH_SW_INT_CTRL, INT_ACK, 1);\n\t\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL, data);\n\n\t\t\tswitch (ctxid) {\n\t\t\tcase 0x3:\n\t\t\t\tdev_dbg(adev->dev, \"Switched to AC mode!\\n\");\n\t\t\t\tsmu_v13_0_ack_ac_dc_interrupt(smu);\n\t\t\t\tbreak;\n\t\t\tcase 0x4:\n\t\t\t\tdev_dbg(adev->dev, \"Switched to DC mode!\\n\");\n\t\t\t\tsmu_v13_0_ack_ac_dc_interrupt(smu);\n\t\t\t\tbreak;\n\t\t\tcase 0x7:\n\t\t\t\t \n\t\t\t\tatomic64_inc(&smu->throttle_int_counter);\n\n\t\t\t\tif (!atomic_read(&adev->throttling_logging_enabled))\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (__ratelimit(&adev->throttling_logging_rs))\n\t\t\t\t\tschedule_work(&smu->throttling_logging_work);\n\n\t\t\t\tbreak;\n\t\t\tcase 0x8:\n\t\t\t\thigh = smu->thermal_range.software_shutdown_temp +\n\t\t\t\t\tsmu->thermal_range.software_shutdown_temp_offset;\n\t\t\t\thigh = min_t(typeof(high),\n\t\t\t\t\t     SMU_THERMAL_MAXIMUM_ALERT_TEMP,\n\t\t\t\t\t     high);\n\t\t\t\tdev_emerg(adev->dev, \"Reduce soft CTF limit to %d (by an offset %d)\\n\",\n\t\t\t\t\t\t\thigh,\n\t\t\t\t\t\t\tsmu->thermal_range.software_shutdown_temp_offset);\n\n\t\t\t\tdata = RREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL);\n\t\t\t\tdata = REG_SET_FIELD(data, THM_THERMAL_INT_CTRL,\n\t\t\t\t\t\t\tDIG_THERM_INTH,\n\t\t\t\t\t\t\t(high & 0xff));\n\t\t\t\tdata = data & (~THM_THERMAL_INT_CTRL__THERM_TRIGGER_MASK_MASK);\n\t\t\t\tWREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL, data);\n\t\t\t\tbreak;\n\t\t\tcase 0x9:\n\t\t\t\thigh = min_t(typeof(high),\n\t\t\t\t\t     SMU_THERMAL_MAXIMUM_ALERT_TEMP,\n\t\t\t\t\t     smu->thermal_range.software_shutdown_temp);\n\t\t\t\tdev_emerg(adev->dev, \"Recover soft CTF limit to %d\\n\", high);\n\n\t\t\t\tdata = RREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL);\n\t\t\t\tdata = REG_SET_FIELD(data, THM_THERMAL_INT_CTRL,\n\t\t\t\t\t\t\tDIG_THERM_INTH,\n\t\t\t\t\t\t\t(high & 0xff));\n\t\t\t\tdata = data & (~THM_THERMAL_INT_CTRL__THERM_TRIGGER_MASK_MASK);\n\t\t\t\tWREG32_SOC15(THM, 0, regTHM_THERMAL_INT_CTRL, data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs smu_v13_0_irq_funcs = {\n\t.set = smu_v13_0_set_irq_state,\n\t.process = smu_v13_0_irq_process,\n};\n\nint smu_v13_0_register_irq_handler(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_irq_src *irq_src = &smu->irq_source;\n\tint ret = 0;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tirq_src->num_types = 1;\n\tirq_src->funcs = &smu_v13_0_irq_funcs;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_THM,\n\t\t\t\tTHM_11_0__SRCID__THM_DIG_THERM_L2H,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_THM,\n\t\t\t\tTHM_11_0__SRCID__THM_DIG_THERM_H2L,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_ROM_SMUIO,\n\t\t\t\tSMUIO_11_0__SRCID__SMUIO_GPIO19,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_MP1,\n\t\t\t\t0xfe,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nint smu_v13_0_get_max_sustainable_clocks_by_dc(struct smu_context *smu,\n\t\t\t\t\t       struct pp_smu_nv_clock_table *max_clocks)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_13_0_max_sustainable_clocks *sustainable_clocks = NULL;\n\n\tif (!max_clocks || !table_context->max_sustainable_clocks)\n\t\treturn -EINVAL;\n\n\tsustainable_clocks = table_context->max_sustainable_clocks;\n\n\tmax_clocks->dcfClockInKhz =\n\t\t(unsigned int) sustainable_clocks->dcef_clock * 1000;\n\tmax_clocks->displayClockInKhz =\n\t\t(unsigned int) sustainable_clocks->display_clock * 1000;\n\tmax_clocks->phyClockInKhz =\n\t\t(unsigned int) sustainable_clocks->phy_clock * 1000;\n\tmax_clocks->pixelClockInKhz =\n\t\t(unsigned int) sustainable_clocks->pixel_clock * 1000;\n\tmax_clocks->uClockInKhz =\n\t\t(unsigned int) sustainable_clocks->uclock * 1000;\n\tmax_clocks->socClockInKhz =\n\t\t(unsigned int) sustainable_clocks->soc_clock * 1000;\n\tmax_clocks->dscClockInKhz = 0;\n\tmax_clocks->dppClockInKhz = 0;\n\tmax_clocks->fabricClockInKhz = 0;\n\n\treturn 0;\n}\n\nint smu_v13_0_set_azalia_d3_pme(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_BacoAudioD3PME, NULL);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_wait_for_reset_complete(struct smu_context *smu,\n\t\t\t\t\t     uint64_t event_arg)\n{\n\tint ret = 0;\n\n\tdev_dbg(smu->adev->dev, \"waiting for smu reset complete\\n\");\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GfxDriverResetRecovery, NULL);\n\n\treturn ret;\n}\n\nint smu_v13_0_wait_for_event(struct smu_context *smu, enum smu_event_type event,\n\t\t\t     uint64_t event_arg)\n{\n\tint ret = -EINVAL;\n\n\tswitch (event) {\n\tcase SMU_EVENT_RESET_COMPLETE:\n\t\tret = smu_v13_0_wait_for_reset_complete(smu, event_arg);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_get_dpm_ultimate_freq(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t\t    uint32_t *min, uint32_t *max)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param = 0;\n\tuint32_t clock_limit;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.uclk;\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.gfxclk;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.socclk;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclock_limit = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (min)\n\t\t\t*min = clock_limit / 100;\n\t\tif (max)\n\t\t\t*max = clock_limit / 100;\n\n\t\treturn 0;\n\t}\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\tparam = (clk_id & 0xffff) << 16;\n\n\tif (max) {\n\t\tif (smu->adev->pm.ac_power)\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t      SMU_MSG_GetMaxDpmFreq,\n\t\t\t\t\t\t\t      param,\n\t\t\t\t\t\t\t      max);\n\t\telse\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t      SMU_MSG_GetDcModeMaxDpmFreq,\n\t\t\t\t\t\t\t      param,\n\t\t\t\t\t\t\t      max);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (min) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetMinDpmFreq, param, min);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\nfailed:\n\treturn ret;\n}\n\nint smu_v13_0_set_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t min,\n\t\t\t\t\t  uint32_t max)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tif (max > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (max & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t\t      param, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (min > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (min & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinByFreq,\n\t\t\t\t\t\t      param, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nint smu_v13_0_set_hard_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t min,\n\t\t\t\t\t  uint32_t max)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\n\tif (min <= 0 && max <= 0)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tif (max > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (max & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMaxByFreq,\n\t\t\t\t\t\t      param, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (min > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (min & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinByFreq,\n\t\t\t\t\t\t      param, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_set_performance_level(struct smu_context *smu,\n\t\t\t\t    enum amd_dpm_forced_level level)\n{\n\tstruct smu_13_0_dpm_context *dpm_context =\n\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_13_0_dpm_table *gfx_table =\n\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_13_0_dpm_table *mem_table =\n\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_13_0_dpm_table *soc_table =\n\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_13_0_dpm_table *vclk_table =\n\t\t&dpm_context->dpm_tables.vclk_table;\n\tstruct smu_13_0_dpm_table *dclk_table =\n\t\t&dpm_context->dpm_tables.dclk_table;\n\tstruct smu_13_0_dpm_table *fclk_table =\n\t\t&dpm_context->dpm_tables.fclk_table;\n\tstruct smu_umd_pstate_table *pstate_table =\n\t\t&smu->pstate_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t sclk_min = 0, sclk_max = 0;\n\tuint32_t mclk_min = 0, mclk_max = 0;\n\tuint32_t socclk_min = 0, socclk_max = 0;\n\tuint32_t vclk_min = 0, vclk_max = 0;\n\tuint32_t dclk_min = 0, dclk_max = 0;\n\tuint32_t fclk_min = 0, fclk_max = 0;\n\tint ret = 0, i;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tsclk_min = sclk_max = gfx_table->max;\n\t\tmclk_min = mclk_max = mem_table->max;\n\t\tsocclk_min = socclk_max = soc_table->max;\n\t\tvclk_min = vclk_max = vclk_table->max;\n\t\tdclk_min = dclk_max = dclk_table->max;\n\t\tfclk_min = fclk_max = fclk_table->max;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tsclk_min = sclk_max = gfx_table->min;\n\t\tmclk_min = mclk_max = mem_table->min;\n\t\tsocclk_min = socclk_max = soc_table->min;\n\t\tvclk_min = vclk_max = vclk_table->min;\n\t\tdclk_min = dclk_max = dclk_table->min;\n\t\tfclk_min = fclk_max = fclk_table->min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tsclk_min = gfx_table->min;\n\t\tsclk_max = gfx_table->max;\n\t\tmclk_min = mem_table->min;\n\t\tmclk_max = mem_table->max;\n\t\tsocclk_min = soc_table->min;\n\t\tsocclk_max = soc_table->max;\n\t\tvclk_min = vclk_table->min;\n\t\tvclk_max = vclk_table->max;\n\t\tdclk_min = dclk_table->min;\n\t\tdclk_max = dclk_table->max;\n\t\tfclk_min = fclk_table->min;\n\t\tfclk_max = fclk_table->max;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\t\tsclk_min = sclk_max = pstate_table->gfxclk_pstate.standard;\n\t\tmclk_min = mclk_max = pstate_table->uclk_pstate.standard;\n\t\tsocclk_min = socclk_max = pstate_table->socclk_pstate.standard;\n\t\tvclk_min = vclk_max = pstate_table->vclk_pstate.standard;\n\t\tdclk_min = dclk_max = pstate_table->dclk_pstate.standard;\n\t\tfclk_min = fclk_max = pstate_table->fclk_pstate.standard;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\t\tsclk_min = sclk_max = pstate_table->gfxclk_pstate.min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\t\tmclk_min = mclk_max = pstate_table->uclk_pstate.min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tsclk_min = sclk_max = pstate_table->gfxclk_pstate.peak;\n\t\tmclk_min = mclk_max = pstate_table->uclk_pstate.peak;\n\t\tsocclk_min = socclk_max = pstate_table->socclk_pstate.peak;\n\t\tvclk_min = vclk_max = pstate_table->vclk_pstate.peak;\n\t\tdclk_min = dclk_max = pstate_table->dclk_pstate.peak;\n\t\tfclk_min = fclk_max = pstate_table->fclk_pstate.peak;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(adev->dev, \"Invalid performance level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 2)) {\n\t\tmclk_min = mclk_max = 0;\n\t\tsocclk_min = socclk_max = 0;\n\t\tvclk_min = vclk_max = 0;\n\t\tdclk_min = dclk_max = 0;\n\t\tfclk_min = fclk_max = 0;\n\t}\n\n\tif (sclk_min && sclk_max) {\n\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_GFXCLK,\n\t\t\t\t\t\t\t    sclk_min,\n\t\t\t\t\t\t\t    sclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpstate_table->gfxclk_pstate.curr.min = sclk_min;\n\t\tpstate_table->gfxclk_pstate.curr.max = sclk_max;\n\t}\n\n\tif (mclk_min && mclk_max) {\n\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_MCLK,\n\t\t\t\t\t\t\t    mclk_min,\n\t\t\t\t\t\t\t    mclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpstate_table->uclk_pstate.curr.min = mclk_min;\n\t\tpstate_table->uclk_pstate.curr.max = mclk_max;\n\t}\n\n\tif (socclk_min && socclk_max) {\n\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_SOCCLK,\n\t\t\t\t\t\t\t    socclk_min,\n\t\t\t\t\t\t\t    socclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpstate_table->socclk_pstate.curr.min = socclk_min;\n\t\tpstate_table->socclk_pstate.curr.max = socclk_max;\n\t}\n\n\tif (vclk_min && vclk_max) {\n\t\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\t\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t\t    i ? SMU_VCLK1 : SMU_VCLK,\n\t\t\t\t\t\t\t\t    vclk_min,\n\t\t\t\t\t\t\t\t    vclk_max);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tpstate_table->vclk_pstate.curr.min = vclk_min;\n\t\tpstate_table->vclk_pstate.curr.max = vclk_max;\n\t}\n\n\tif (dclk_min && dclk_max) {\n\t\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\t\tcontinue;\n\t\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t\t    i ? SMU_DCLK1 : SMU_DCLK,\n\t\t\t\t\t\t\t\t    dclk_min,\n\t\t\t\t\t\t\t\t    dclk_max);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tpstate_table->dclk_pstate.curr.min = dclk_min;\n\t\tpstate_table->dclk_pstate.curr.max = dclk_max;\n\t}\n\n\tif (fclk_min && fclk_max) {\n\t\tret = smu_v13_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_FCLK,\n\t\t\t\t\t\t\t    fclk_min,\n\t\t\t\t\t\t\t    fclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpstate_table->fclk_pstate.curr.min = fclk_min;\n\t\tpstate_table->fclk_pstate.curr.max = fclk_max;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_set_power_source(struct smu_context *smu,\n\t\t\t       enum smu_power_src_type power_src)\n{\n\tint pwr_source;\n\n\tpwr_source = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t    CMN2ASIC_MAPPING_PWR,\n\t\t\t\t\t\t    (uint32_t)power_src);\n\tif (pwr_source < 0)\n\t\treturn -EINVAL;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_NotifyPowerSource,\n\t\t\t\t\t       pwr_source,\n\t\t\t\t\t       NULL);\n}\n\nint smu_v13_0_get_dpm_freq_by_index(struct smu_context *smu,\n\t\t\t\t    enum smu_clk_type clk_type, uint16_t level,\n\t\t\t\t    uint32_t *value)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tparam = (uint32_t)(((clk_id & 0xffff) << 16) | (level & 0xffff));\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_GetDpmFreqByIndex,\n\t\t\t\t\t      param,\n\t\t\t\t\t      value);\n\tif (ret)\n\t\treturn ret;\n\n\t*value = *value & 0x7fffffff;\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_get_dpm_level_count(struct smu_context *smu,\n\t\t\t\t\t enum smu_clk_type clk_type,\n\t\t\t\t\t uint32_t *value)\n{\n\tint ret;\n\n\tret = smu_v13_0_get_dpm_freq_by_index(smu, clk_type, 0xff, value);\n\t \n\tif ((smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 2)) && (!ret && value))\n\t\t++(*value);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_get_fine_grained_status(struct smu_context *smu,\n\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t     bool *is_fine_grained_dpm)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\tuint32_t value;\n\n\tif (!is_fine_grained_dpm)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tparam = (uint32_t)(((clk_id & 0xffff) << 16) | 0xff);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_GetDpmFreqByIndex,\n\t\t\t\t\t      param,\n\t\t\t\t\t      &value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*is_fine_grained_dpm = value & 0x80000000;\n\n\treturn 0;\n}\n\nint smu_v13_0_set_single_dpm_table(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type,\n\t\t\t\t   struct smu_13_0_dpm_table *single_dpm_table)\n{\n\tint ret = 0;\n\tuint32_t clk;\n\tint i;\n\n\tret = smu_v13_0_get_dpm_level_count(smu,\n\t\t\t\t\t    clk_type,\n\t\t\t\t\t    &single_dpm_table->count);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[%s] failed to get dpm levels!\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (smu->adev->ip_versions[MP1_HWIP][0] != IP_VERSION(13, 0, 2)) {\n\t\tret = smu_v13_0_get_fine_grained_status(smu,\n\t\t\t\t\t\t\tclk_type,\n\t\t\t\t\t\t\t&single_dpm_table->is_fine_grained);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get fine grained status!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < single_dpm_table->count; i++) {\n\t\tret = smu_v13_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t      clk_type,\n\t\t\t\t\t\t      i,\n\t\t\t\t\t\t      &clk);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get dpm freq by index!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table->dpm_levels[i].value = clk;\n\t\tsingle_dpm_table->dpm_levels[i].enabled = true;\n\n\t\tif (i == 0)\n\t\t\tsingle_dpm_table->min = clk;\n\t\telse if (i == single_dpm_table->count - 1)\n\t\t\tsingle_dpm_table->max = clk;\n\t}\n\n\treturn 0;\n}\n\nint smu_v13_0_get_current_pcie_link_width_level(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_LINK_WIDTH_CNTL) &\n\t\tPCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK)\n\t\t>> PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT;\n}\n\nint smu_v13_0_get_current_pcie_link_width(struct smu_context *smu)\n{\n\tuint32_t width_level;\n\n\twidth_level = smu_v13_0_get_current_pcie_link_width_level(smu);\n\tif (width_level > LINK_WIDTH_MAX)\n\t\twidth_level = 0;\n\n\treturn link_width[width_level];\n}\n\nint smu_v13_0_get_current_pcie_link_speed_level(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_SPEED_CNTL) &\n\t\tPCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK)\n\t\t>> PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;\n}\n\nint smu_v13_0_get_current_pcie_link_speed(struct smu_context *smu)\n{\n\tuint32_t speed_level;\n\n\tspeed_level = smu_v13_0_get_current_pcie_link_speed_level(smu);\n\tif (speed_level > LINK_SPEED_MAX)\n\t\tspeed_level = 0;\n\n\treturn link_speed[speed_level];\n}\n\nint smu_v13_0_set_vcn_enable(struct smu_context *smu,\n\t\t\t     bool enable)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, enable ?\n\t\t\t\t\t\t      SMU_MSG_PowerUpVcn : SMU_MSG_PowerDownVcn,\n\t\t\t\t\t\t      i << 16U, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_set_jpeg_enable(struct smu_context *smu,\n\t\t\t      bool enable)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu, enable ?\n\t\t\t\t\t       SMU_MSG_PowerUpJpeg : SMU_MSG_PowerDownJpeg,\n\t\t\t\t\t       0, NULL);\n}\n\nint smu_v13_0_run_btc(struct smu_context *smu)\n{\n\tint res;\n\n\tres = smu_cmn_send_smc_msg(smu, SMU_MSG_RunDcBtc, NULL);\n\tif (res)\n\t\tdev_err(smu->adev->dev, \"RunDcBtc failed!\\n\");\n\n\treturn res;\n}\n\nint smu_v13_0_gpo_control(struct smu_context *smu,\n\t\t\t  bool enablement)\n{\n\tint res;\n\n\tres = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_AllowGpo,\n\t\t\t\t\t      enablement ? 1 : 0,\n\t\t\t\t\t      NULL);\n\tif (res)\n\t\tdev_err(smu->adev->dev, \"SetGpoAllow %d failed!\\n\", enablement);\n\n\treturn res;\n}\n\nint smu_v13_0_deep_sleep_control(struct smu_context *smu,\n\t\t\t\t bool enablement)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_GFXCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_GFXCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s GFXCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_UCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_UCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s UCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_FCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_FCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s FCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_SOCCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_SOCCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s SOCCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_LCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_LCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s LCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_VCN_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_VCN_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s VCN DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_MP0CLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_MP0CLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s MP0/MPIOCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_MP1CLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_MP1CLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s MP1CLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_gfx_ulv_control(struct smu_context *smu,\n\t\t\t      bool enablement)\n{\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_GFX_ULV_BIT))\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_GFX_ULV_BIT, enablement);\n\n\treturn ret;\n}\n\nint smu_v13_0_baco_set_armd3_sequence(struct smu_context *smu,\n\t\t\t\t      enum smu_baco_seq baco_seq)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tint ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_ArmD3,\n\t\t\t\t\t      baco_seq,\n\t\t\t\t\t      NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (baco_seq == BACO_SEQ_BAMACO ||\n\t    baco_seq == BACO_SEQ_BACO)\n\t\tsmu_baco->state = SMU_BACO_STATE_ENTER;\n\telse\n\t\tsmu_baco->state = SMU_BACO_STATE_EXIT;\n\n\treturn 0;\n}\n\nbool smu_v13_0_baco_is_support(struct smu_context *smu)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\n\tif (amdgpu_sriov_vf(smu->adev) ||\n\t    !smu_baco->platform_support)\n\t\treturn false;\n\n\t \n\tif (smu_v13_0_baco_get_state(smu) == SMU_BACO_STATE_ENTER)\n\t\treturn true;\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_BACO_BIT) &&\n\t    !smu_cmn_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT))\n\t\treturn false;\n\n\treturn true;\n}\n\nenum smu_baco_state smu_v13_0_baco_get_state(struct smu_context *smu)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\n\treturn smu_baco->state;\n}\n\nint smu_v13_0_baco_set_state(struct smu_context *smu,\n\t\t\t     enum smu_baco_state state)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (smu_v13_0_baco_get_state(smu) == state)\n\t\treturn 0;\n\n\tif (state == SMU_BACO_STATE_ENTER) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_EnterBaco,\n\t\t\t\t\t\t      (smu_baco->maco_support && amdgpu_runtime_pm != 1) ?\n\t\t\t\t\t\t      BACO_SEQ_BAMACO : BACO_SEQ_BACO,\n\t\t\t\t\t\t      NULL);\n\t} else {\n\t\tret = smu_cmn_send_smc_msg(smu,\n\t\t\t\t\t   SMU_MSG_ExitBaco,\n\t\t\t\t\t   NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tWREG32(adev->bios_scratch_reg_offset + 6, 0);\n\t\tWREG32(adev->bios_scratch_reg_offset + 7, 0);\n\t}\n\n\tif (!ret)\n\t\tsmu_baco->state = state;\n\n\treturn ret;\n}\n\nint smu_v13_0_baco_enter(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v13_0_baco_set_state(smu,\n\t\t\t\t       SMU_BACO_STATE_ENTER);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(10);\n\n\treturn ret;\n}\n\nint smu_v13_0_baco_exit(struct smu_context *smu)\n{\n\treturn smu_v13_0_baco_set_state(smu,\n\t\t\t\t\tSMU_BACO_STATE_EXIT);\n}\n\nint smu_v13_0_set_gfx_power_up_by_imu(struct smu_context *smu)\n{\n\tuint16_t index;\n\n\tindex = smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG,\n\t\t\t\t\t       SMU_MSG_EnableGfxImu);\n\t \n\treturn smu_cmn_send_msg_without_waiting(smu, index, 1);\n}\n\nint smu_v13_0_od_edit_dpm_table(struct smu_context *smu,\n\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\tlong input[], uint32_t size)\n{\n\tstruct smu_dpm_context *smu_dpm = &(smu->smu_dpm);\n\tint ret = 0;\n\n\t \n\tif (smu_dpm->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (size != 2) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[0] == 0) {\n\t\t\tif (input[1] < smu->gfx_default_hard_min_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t \"Fine grain setting minimum sclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\t input[1], smu->gfx_default_hard_min_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_hard_min_freq = input[1];\n\t\t} else if (input[0] == 1) {\n\t\t\tif (input[1] > smu->gfx_default_soft_max_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t \"Fine grain setting maximum sclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\t input[1], smu->gfx_default_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_soft_max_freq = input[1];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (smu->gfx_actual_hard_min_freq > smu->gfx_actual_soft_max_freq) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"The setting minimum sclk (%d) MHz is greater than the setting maximum sclk (%d) MHz\\n\",\n\t\t\t\tsmu->gfx_actual_hard_min_freq,\n\t\t\t\tsmu->gfx_actual_soft_max_freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\t      smu->gfx_actual_hard_min_freq,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Set hard min sclk failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\t      smu->gfx_actual_soft_max_freq,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Set soft max sclk failed!\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nint smu_v13_0_set_default_dpm_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\treturn smu_cmn_update_table(smu, SMU_TABLE_DPMCLOCKS, 0,\n\t\t\t\t    smu_table->clocks_table, false);\n}\n\nvoid smu_v13_0_set_smu_mailbox_registers(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tsmu->param_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_82);\n\tsmu->msg_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_66);\n\tsmu->resp_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n}\n\nint smu_v13_0_mode1_reset(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_Mode1Reset, NULL);\n\tif (!ret)\n\t\tmsleep(SMU13_MODE1_RESET_WAIT_TIME_IN_MS);\n\n\treturn ret;\n}\n\nint smu_v13_0_update_pcie_parameters(struct smu_context *smu,\n\t\t\t\t     uint8_t pcie_gen_cap,\n\t\t\t\t     uint8_t pcie_width_cap)\n{\n\tstruct smu_13_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_13_0_pcie_table *pcie_table =\n\t\t\t\t&dpm_context->dpm_tables.pcie_table;\n\tint num_of_levels = pcie_table->num_of_link_levels;\n\tuint32_t smu_pcie_arg;\n\tint ret, i;\n\n\tif (!num_of_levels)\n\t\treturn 0;\n\n\tif (!(smu->adev->pm.pp_feature & PP_PCIE_DPM_MASK)) {\n\t\tif (pcie_table->pcie_gen[num_of_levels - 1] < pcie_gen_cap)\n\t\t\tpcie_gen_cap = pcie_table->pcie_gen[num_of_levels - 1];\n\n\t\tif (pcie_table->pcie_lane[num_of_levels - 1] < pcie_width_cap)\n\t\t\tpcie_width_cap = pcie_table->pcie_lane[num_of_levels - 1];\n\n\t\t \n\t\tfor (i = 0; i < num_of_levels; i++) {\n\t\t\tpcie_table->pcie_gen[i] = pcie_gen_cap;\n\t\t\tpcie_table->pcie_lane[i] = pcie_width_cap;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < num_of_levels; i++) {\n\t\t\tif (pcie_table->pcie_gen[i] > pcie_gen_cap)\n\t\t\t\tpcie_table->pcie_gen[i] = pcie_gen_cap;\n\t\t\tif (pcie_table->pcie_lane[i] > pcie_width_cap)\n\t\t\t\tpcie_table->pcie_lane[i] = pcie_width_cap;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_of_levels; i++) {\n\t\tsmu_pcie_arg = i << 16;\n\t\tsmu_pcie_arg |= pcie_table->pcie_gen[i] << 8;\n\t\tsmu_pcie_arg |= pcie_table->pcie_lane[i];\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_OverridePcieParameters,\n\t\t\t\t\t\t      smu_pcie_arg,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}