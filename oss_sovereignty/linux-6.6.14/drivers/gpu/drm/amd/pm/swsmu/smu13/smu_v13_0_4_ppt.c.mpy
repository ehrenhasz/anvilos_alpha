{
  "module_name": "smu_v13_0_4_ppt.c",
  "hash_id": "a9e0b68e517bd41beda464bf789cd1dad6af27c5bfb90d3a3fca2995497d3715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_4_ppt.c",
  "human_readable_source": " \n\n#include \"smu_types.h\"\n#define SWSMU_CODE_LAYER_L2\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"smu_v13_0.h\"\n#include \"smu13_driver_if_v13_0_4.h\"\n#include \"smu_v13_0_4_ppt.h\"\n#include \"smu_v13_0_4_ppsmc.h\"\n#include \"smu_v13_0_4_pmfw.h\"\n#include \"smu_cmn.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define mmMP1_SMN_C2PMSG_66\t\t\t0x0282\n#define mmMP1_SMN_C2PMSG_66_BASE_IDX            1\n\n#define mmMP1_SMN_C2PMSG_82\t\t\t0x0292\n#define mmMP1_SMN_C2PMSG_82_BASE_IDX            1\n\n#define mmMP1_SMN_C2PMSG_90\t\t\t0x029a\n#define mmMP1_SMN_C2PMSG_90_BASE_IDX\t\t1\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n\n#define SMU_13_0_4_UMD_PSTATE_GFXCLK\t\t\t938\n#define SMU_13_0_4_UMD_PSTATE_SOCCLK\t\t\t938\n#define SMU_13_0_4_UMD_PSTATE_FCLK\t\t\t1875\n\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_CCLK_DPM_BIT) | \\\n\tFEATURE_MASK(FEATURE_VCN_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_FCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_SOCCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_MP0CLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_LCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_SHUBCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DCFCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_ISP_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_IPU_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_GFX_DPM_BIT))\n\nstatic struct cmn2asic_msg_mapping smu_v13_0_4_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,                    PPSMC_MSG_TestMessage,\t\t\t1),\n\tMSG_MAP(GetSmuVersion,                  PPSMC_MSG_GetPmfwVersion,\t\t1),\n\tMSG_MAP(GetDriverIfVersion,             PPSMC_MSG_GetDriverIfVersion,\t\t1),\n\tMSG_MAP(AllowGfxOff,                    PPSMC_MSG_AllowGfxOff,\t\t\t1),\n\tMSG_MAP(DisallowGfxOff,                 PPSMC_MSG_DisallowGfxOff,\t\t1),\n\tMSG_MAP(PowerDownVcn,                   PPSMC_MSG_PowerDownVcn,\t\t\t1),\n\tMSG_MAP(PowerUpVcn,                     PPSMC_MSG_PowerUpVcn,\t\t\t1),\n\tMSG_MAP(SetHardMinVcn,                  PPSMC_MSG_SetHardMinVcn,\t\t1),\n\tMSG_MAP(PrepareMp1ForUnload,            PPSMC_MSG_PrepareMp1ForUnload,\t\t1),\n\tMSG_MAP(SetDriverDramAddrHigh,          PPSMC_MSG_SetDriverDramAddrHigh,\t1),\n\tMSG_MAP(SetDriverDramAddrLow,           PPSMC_MSG_SetDriverDramAddrLow,\t\t1),\n\tMSG_MAP(TransferTableSmu2Dram,          PPSMC_MSG_TransferTableSmu2Dram,\t1),\n\tMSG_MAP(TransferTableDram2Smu,          PPSMC_MSG_TransferTableDram2Smu,\t1),\n\tMSG_MAP(GfxDeviceDriverReset,           PPSMC_MSG_GfxDeviceDriverReset,\t\t1),\n\tMSG_MAP(GetEnabledSmuFeatures,          PPSMC_MSG_GetEnabledSmuFeatures,\t1),\n\tMSG_MAP(SetHardMinSocclkByFreq,         PPSMC_MSG_SetHardMinSocclkByFreq,\t1),\n\tMSG_MAP(SetSoftMinVcn,                  PPSMC_MSG_SetSoftMinVcn,\t\t1),\n\tMSG_MAP(GetGfxclkFrequency,             PPSMC_MSG_GetGfxclkFrequency,\t\t1),\n\tMSG_MAP(GetFclkFrequency,               PPSMC_MSG_GetFclkFrequency,\t\t1),\n\tMSG_MAP(SetSoftMaxGfxClk,               PPSMC_MSG_SetSoftMaxGfxClk,\t\t1),\n\tMSG_MAP(SetHardMinGfxClk,               PPSMC_MSG_SetHardMinGfxClk,\t\t1),\n\tMSG_MAP(SetSoftMaxSocclkByFreq,         PPSMC_MSG_SetSoftMaxSocclkByFreq,\t1),\n\tMSG_MAP(SetSoftMaxFclkByFreq,           PPSMC_MSG_SetSoftMaxFclkByFreq,\t\t1),\n\tMSG_MAP(SetSoftMaxVcn,                  PPSMC_MSG_SetSoftMaxVcn,\t\t1),\n\tMSG_MAP(SetPowerLimitPercentage,        PPSMC_MSG_SetPowerLimitPercentage,\t1),\n\tMSG_MAP(PowerDownJpeg,                  PPSMC_MSG_PowerDownJpeg,\t\t1),\n\tMSG_MAP(PowerUpJpeg,                    PPSMC_MSG_PowerUpJpeg,\t\t\t1),\n\tMSG_MAP(SetHardMinFclkByFreq,           PPSMC_MSG_SetHardMinFclkByFreq,\t\t1),\n\tMSG_MAP(SetSoftMinSocclkByFreq,         PPSMC_MSG_SetSoftMinSocclkByFreq,\t1),\n\tMSG_MAP(EnableGfxImu,                   PPSMC_MSG_EnableGfxImu,\t\t\t1),\n\tMSG_MAP(PowerUpIspByTile,               PPSMC_MSG_PowerUpIspByTile,\t\t1),\n\tMSG_MAP(PowerDownIspByTile,             PPSMC_MSG_PowerDownIspByTile,\t\t1),\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_4_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(CCLK_DPM),\n\tFEA_MAP(FAN_CONTROLLER),\n\tFEA_MAP(PPT),\n\tFEA_MAP(TDC),\n\tFEA_MAP(THERMAL),\n\tFEA_MAP(VCN_DPM),\n\tFEA_MAP_REVERSE(FCLK),\n\tFEA_MAP_REVERSE(SOCCLK),\n\tFEA_MAP(LCLK_DPM),\n\tFEA_MAP(SHUBCLK_DPM),\n\tFEA_MAP(DCFCLK_DPM),\n\tFEA_MAP_HALF_REVERSE(GFX),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_DCFCLK),\n\tFEA_MAP(DS_FCLK),\n\tFEA_MAP(DS_MP1CLK),\n\tFEA_MAP(DS_MP0CLK),\n\tFEA_MAP(GFX_DEM),\n\tFEA_MAP(PSI),\n\tFEA_MAP(PROCHOT),\n\tFEA_MAP(CPUOFF),\n\tFEA_MAP(STAPM),\n\tFEA_MAP(S0I3),\n\tFEA_MAP(PERF_LIMIT),\n\tFEA_MAP(CORE_DLDO),\n\tFEA_MAP(DS_VCN),\n\tFEA_MAP(CPPC),\n\tFEA_MAP(DF_CSTATES),\n\tFEA_MAP(ATHUB_PG),\n};\n\nstatic struct cmn2asic_mapping smu_v13_0_4_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP_VALID(WATERMARKS),\n\tTAB_MAP_VALID(SMU_METRICS),\n\tTAB_MAP_VALID(CUSTOM_DPM),\n\tTAB_MAP_VALID(DPMCLOCKS),\n};\n\nstatic int smu_v13_0_4_init_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_DPMCLOCKS, sizeof(DpmClocks_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->clocks_table = kzalloc(sizeof(DpmClocks_t), GFP_KERNEL);\n\tif (!smu_table->clocks_table)\n\t\tgoto err0_out;\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err1_out;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v2_1);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err3_out;\n\n\treturn 0;\n\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->metrics_table);\nerr1_out:\n\tkfree(smu_table->clocks_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic int smu_v13_0_4_fini_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\tkfree(smu_table->clocks_table);\n\tsmu_table->clocks_table = NULL;\n\n\tkfree(smu_table->metrics_table);\n\tsmu_table->metrics_table = NULL;\n\n\tkfree(smu_table->watermarks_table);\n\tsmu_table->watermarks_table = NULL;\n\n\tkfree(smu_table->gpu_metrics_table);\n\tsmu_table->gpu_metrics_table = NULL;\n\n\treturn 0;\n}\n\nstatic bool smu_v13_0_4_is_dpm_running(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int smu_v13_0_4_system_features_control(struct smu_context *smu, bool en)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (!en && !adev->in_s0ix)\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_PrepareMp1ForUnload, NULL);\n\n\treturn ret;\n}\n\nstatic ssize_t smu_v13_0_4_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t   void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_1 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_1 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 1);\n\n\tgpu_metrics->temperature_gfx = metrics.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 8);\n\tgpu_metrics->temperature_l3[0] = metrics.L3Temperature;\n\n\tgpu_metrics->average_gfx_activity = metrics.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\tgpu_metrics->average_gfx_power = metrics.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Power[1];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t) * 8);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 8);\n\tgpu_metrics->current_l3clk[0] = metrics.L3Frequency;\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_1);\n}\n\nstatic int smu_v13_0_4_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t    MetricsMember_t member,\n\t\t\t\t\t    uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\tSmuMetrics_t *metrics = (SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, NULL, false);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\t*value = metrics->GfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->SocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK:\n\t\t*value = metrics->VclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK:\n\t\t*value = metrics->DclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->MemclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->GfxActivity / 100;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCNACTIVITY:\n\t\t*value = metrics->UvdActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = (metrics->AverageSocketPower << 8) / 1000;\n\t\tbreak;\n\tcase METRICS_CURR_SOCKETPOWER:\n\t\t*value = (metrics->CurrentSocketPower << 8) / 1000;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->GfxTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->SocTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->Voltage[0];\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDSOC:\n\t\t*value = metrics->Voltage[1];\n\t\tbreak;\n\tcase METRICS_SS_APU_SHARE:\n\t\t \n\t\tif (metrics->StapmOpnLimit > 0)\n\t\t\t*value =  (metrics->ApuPower * 100) / metrics->StapmOpnLimit;\n\t\telse\n\t\t\t*value = 0;\n\t\tbreak;\n\tcase METRICS_SS_DGPU_SHARE:\n\t\t \n\t\tif ((metrics->dGpuPower > 0) &&\n\t\t    (metrics->StapmCurrentLimit > metrics->StapmOpnLimit))\n\t\t\t*value = (metrics->dGpuPower * 100) /\n\t\t\t\t (metrics->StapmCurrentLimit - metrics->StapmOpnLimit);\n\t\telse\n\t\t\t*value = 0;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_4_get_current_clk_freq(struct smu_context *smu,\n\t\t\t\t\t    enum smu_clk_type clk_type,\n\t\t\t\t\t    uint32_t *value)\n{\n\tMetricsMember_t member_type;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tmember_type = METRICS_AVERAGE_SOCCLK;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tmember_type = METRICS_AVERAGE_VCLK;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tmember_type = METRICS_AVERAGE_DCLK;\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\tmember_type = METRICS_AVERAGE_UCLK;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t       SMU_MSG_GetFclkFrequency,\n\t\t\t\t\t\t       0, value);\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t       SMU_MSG_GetGfxclkFrequency,\n\t\t\t\t\t\t       0, value);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smu_v13_0_4_get_smu_metrics_data(smu, member_type, value);\n}\n\nstatic int smu_v13_0_4_get_dpm_freq_by_index(struct smu_context *smu,\n\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t     uint32_t dpm_level,\n\t\t\t\t\t     uint32_t *freq)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tif (!clk_table || clk_type >= SMU_CLK_COUNT)\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tif (dpm_level >= clk_table->NumSocClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->SocClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tif (dpm_level >= clk_table->VcnClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->VClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tif (dpm_level >= clk_table->VcnClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_UCLK:\n\tcase SMU_MCLK:\n\t\tif (dpm_level >= clk_table->NumDfPstatesEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DfPstateTable[dpm_level].MemClk;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tif (dpm_level >= clk_table->NumDfPstatesEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DfPstateTable[dpm_level].FClk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_4_get_dpm_level_count(struct smu_context *smu,\n\t\t\t\t\t   enum smu_clk_type clk_type,\n\t\t\t\t\t   uint32_t *count)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\t*count = clk_table->NumSocClkLevelsEnabled;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\t*count = clk_table->VcnClkLevelsEnabled;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\t*count = clk_table->VcnClkLevelsEnabled;\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\t*count = clk_table->NumDfPstatesEnabled;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\t*count = clk_table->NumDfPstatesEnabled;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_4_print_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tint i, idx, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0;\n\tuint32_t min, max;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_OD_SCLK:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_SCLK\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %10uMhz\\n\",\n\t\t(smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq);\n\t\tsize += sysfs_emit_at(buf, size, \"1: %10uMhz\\n\",\n\t\t(smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq);\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t      smu->gfx_default_hard_min_freq,\n\t\t\t\t      smu->gfx_default_soft_max_freq);\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\tcase SMU_MCLK:\n\tcase SMU_FCLK:\n\t\tret = smu_v13_0_4_get_current_clk_freq(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = smu_v13_0_4_get_dpm_level_count(smu, clk_type, &count);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tidx = (clk_type == SMU_FCLK || clk_type == SMU_MCLK) ? (count - i - 1) : i;\n\t\t\tret = smu_v13_0_4_get_dpm_freq_by_index(smu, clk_type, idx, &value);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\t      cur_value == value ? \"*\" : \"\");\n\t\t}\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tret = smu_v13_0_4_get_current_clk_freq(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tmin = (smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq;\n\t\tmax = (smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq;\n\t\tif (cur_value  == max)\n\t\t\ti = 2;\n\t\telse if (cur_value == min)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = 1;\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\", min,\n\t\t\t\t      i == 0 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\t      i == 1 ? cur_value : 1100,  \n\t\t\t\t      i == 1 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz %s\\n\", max,\n\t\t\t\t      i == 2 ? \"*\" : \"\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int smu_v13_0_4_read_sensor(struct smu_context *smu,\n\t\t\t\t   enum amd_pp_sensors sensor,\n\t\t\t\t   void *data, uint32_t *size)\n{\n\tint ret = 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_CURR_SOCKETPOWER,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_UCLK,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_AVERAGE_GFXCLK,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_VOLTAGE_VDDGFX,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDNB:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_VOLTAGE_VDDSOC,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_APU_SHARE:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_SS_APU_SHARE,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_DGPU_SHARE:\n\t\tret = smu_v13_0_4_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_SS_DGPU_SHARE,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_4_set_watermarks_table(struct smu_context *smu,\n\t\t\t\t\t    struct pp_smu_wm_range_sets *clock_ranges)\n{\n\tint i;\n\tint ret = 0;\n\tWatermarks_t *table = smu->smu_table.watermarks_table;\n\n\tif (!table || !clock_ranges)\n\t\treturn -EINVAL;\n\n\tif (clock_ranges->num_reader_wm_sets > NUM_WM_RANGES ||\n\t\tclock_ranges->num_writer_wm_sets > NUM_WM_RANGES)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < clock_ranges->num_reader_wm_sets; i++) {\n\t\ttable->WatermarkRow[WM_DCFCLK][i].MinClock =\n\t\t\tclock_ranges->reader_wm_sets[i].min_drain_clk_mhz;\n\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxClock =\n\t\t\tclock_ranges->reader_wm_sets[i].max_drain_clk_mhz;\n\t\ttable->WatermarkRow[WM_DCFCLK][i].MinMclk =\n\t\t\tclock_ranges->reader_wm_sets[i].min_fill_clk_mhz;\n\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxMclk =\n\t\t\tclock_ranges->reader_wm_sets[i].max_fill_clk_mhz;\n\n\t\ttable->WatermarkRow[WM_DCFCLK][i].WmSetting =\n\t\t\tclock_ranges->reader_wm_sets[i].wm_inst;\n\t}\n\n\tfor (i = 0; i < clock_ranges->num_writer_wm_sets; i++) {\n\t\ttable->WatermarkRow[WM_SOCCLK][i].MinClock =\n\t\t\tclock_ranges->writer_wm_sets[i].min_fill_clk_mhz;\n\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxClock =\n\t\t\tclock_ranges->writer_wm_sets[i].max_fill_clk_mhz;\n\t\ttable->WatermarkRow[WM_SOCCLK][i].MinMclk =\n\t\t\tclock_ranges->writer_wm_sets[i].min_drain_clk_mhz;\n\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxMclk =\n\t\t\tclock_ranges->writer_wm_sets[i].max_drain_clk_mhz;\n\n\t\ttable->WatermarkRow[WM_SOCCLK][i].WmSetting =\n\t\t\tclock_ranges->writer_wm_sets[i].wm_inst;\n\t}\n\n\tsmu->watermarks_bitmap |= WATERMARKS_EXIST;\n\n\t \n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t     !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {\n\t\tret = smu_cmn_write_watermarks_table(smu);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to update WMTABLE!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsmu->watermarks_bitmap |= WATERMARKS_LOADED;\n\t}\n\n\treturn 0;\n}\n\nstatic bool smu_v13_0_4_clk_dpm_is_enabled(struct smu_context *smu,\n\t\t\t\t\t   enum smu_clk_type clk_type)\n{\n\tenum smu_feature_mask feature_id = 0;\n\n\tswitch (clk_type) {\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_FCLK_BIT;\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_GFXCLK_BIT;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_SOCCLK_BIT;\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tfeature_id = SMU_FEATURE_VCN_DPM_BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn true;\n\t}\n\n\treturn smu_cmn_feature_is_enabled(smu, feature_id);\n}\n\nstatic int smu_v13_0_4_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t     uint32_t *min,\n\t\t\t\t\t     uint32_t *max)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\tuint32_t clock_limit;\n\tuint32_t max_dpm_level, min_dpm_level;\n\tint ret = 0;\n\n\tif (!smu_v13_0_4_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.uclk;\n\t\t\tbreak;\n\t\tcase SMU_FCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.fclk;\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.gfxclk;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.socclk;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.vclk;\n\t\t\tbreak;\n\t\tcase SMU_DCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.dclk;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclock_limit = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (min)\n\t\t\t*min = clock_limit / 100;\n\t\tif (max)\n\t\t\t*max = clock_limit / 100;\n\n\t\treturn 0;\n\t}\n\n\tif (max) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\t*max = clk_table->MaxGfxClk;\n\t\t\tbreak;\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\tcase SMU_FCLK:\n\t\t\tmax_dpm_level = 0;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tmax_dpm_level = clk_table->NumSocClkLevelsEnabled - 1;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\tcase SMU_DCLK:\n\t\t\tmax_dpm_level = clk_table->VcnClkLevelsEnabled - 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (clk_type != SMU_GFXCLK && clk_type != SMU_SCLK) {\n\t\t\tret = smu_v13_0_4_get_dpm_freq_by_index(smu, clk_type,\n\t\t\t\t\t\t\t\tmax_dpm_level,\n\t\t\t\t\t\t\t\tmax);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (min) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\t*min = clk_table->MinGfxClk;\n\t\t\tbreak;\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\tcase SMU_FCLK:\n\t\t\tmin_dpm_level = clk_table->NumDfPstatesEnabled - 1;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tmin_dpm_level = 0;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\tcase SMU_DCLK:\n\t\t\tmin_dpm_level = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (clk_type != SMU_GFXCLK && clk_type != SMU_SCLK) {\n\t\t\tret = smu_v13_0_4_get_dpm_freq_by_index(smu, clk_type,\n\t\t\t\t\t\t\t\tmin_dpm_level,\n\t\t\t\t\t\t\t\tmin);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_4_set_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t\t   enum smu_clk_type clk_type,\n\t\t\t\t\t\t   uint32_t min,\n\t\t\t\t\t\t   uint32_t max)\n{\n\tenum smu_message_type msg_set_min, msg_set_max;\n\tuint32_t min_clk = min;\n\tuint32_t max_clk = max;\n\tint ret = 0;\n\n\tif (!smu_v13_0_4_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinGfxClk;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxGfxClk;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinFclkByFreq;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxFclkByFreq;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinSocclkByFreq;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxSocclkByFreq;\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinVcn;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxVcn;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_type == SMU_VCLK) {\n\t\tmin_clk = min << SMU_13_VCLK_SHIFT;\n\t\tmax_clk = max << SMU_13_VCLK_SHIFT;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, msg_set_min, min_clk, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu, msg_set_max,\n\t\t\t\t\t       max_clk, NULL);\n}\n\nstatic int smu_v13_0_4_force_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tuint32_t mask)\n{\n\tuint32_t soft_min_level = 0, soft_max_level = 0;\n\tuint32_t min_freq = 0, max_freq = 0;\n\tint ret = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tret = smu_v13_0_4_get_dpm_freq_by_index(smu, clk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = smu_v13_0_4_get_dpm_freq_by_index(smu, clk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = smu_v13_0_4_set_soft_freq_limited_range(smu, clk_type, min_freq, max_freq);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_4_get_dpm_profile_freq(struct smu_context *smu,\n\t\t\t\t\tenum amd_dpm_forced_level level,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tuint32_t *min_clk,\n\t\t\t\t\tuint32_t *max_clk)\n{\n\tint ret = 0;\n\tuint32_t clk_limit = 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tclk_limit = SMU_13_0_4_UMD_PSTATE_GFXCLK;\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SCLK, NULL, &clk_limit);\n\t\telse if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK)\n\t\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SCLK, &clk_limit, NULL);\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tclk_limit = SMU_13_0_4_UMD_PSTATE_SOCCLK;\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SOCCLK, NULL, &clk_limit);\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tclk_limit = SMU_13_0_4_UMD_PSTATE_FCLK;\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_FCLK, NULL, &clk_limit);\n\t\telse if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK)\n\t\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_FCLK, &clk_limit, NULL);\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_VCLK, NULL, &clk_limit);\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_DCLK, NULL, &clk_limit);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\t*min_clk = *max_clk = clk_limit;\n\treturn ret;\n}\n\nstatic int smu_v13_0_4_set_performance_level(struct smu_context *smu,\n\t\t\t\t\t     enum amd_dpm_forced_level level)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t sclk_min = 0, sclk_max = 0;\n\tuint32_t fclk_min = 0, fclk_max = 0;\n\tuint32_t socclk_min = 0, socclk_max = 0;\n\tuint32_t vclk_min = 0, vclk_max = 0;\n\tuint32_t dclk_min = 0, dclk_max = 0;\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SCLK, NULL, &sclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_FCLK, NULL, &fclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SOCCLK, NULL, &socclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_VCLK, NULL, &vclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_DCLK, NULL, &dclk_max);\n\t\tsclk_min = sclk_max;\n\t\tfclk_min = fclk_max;\n\t\tsocclk_min = socclk_max;\n\t\tvclk_min = vclk_max;\n\t\tdclk_min = dclk_max;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SCLK, &sclk_min, NULL);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_FCLK, &fclk_min, NULL);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SOCCLK, &socclk_min, NULL);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_VCLK, &vclk_min, NULL);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_DCLK, &dclk_min, NULL);\n\t\tsclk_max = sclk_min;\n\t\tfclk_max = fclk_min;\n\t\tsocclk_max = socclk_min;\n\t\tvclk_max = vclk_min;\n\t\tdclk_max = dclk_min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SCLK, &sclk_min, &sclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_FCLK, &fclk_min, &fclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_SOCCLK, &socclk_min, &socclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_VCLK, &vclk_min, &vclk_max);\n\t\tsmu_v13_0_4_get_dpm_ultimate_freq(smu, SMU_DCLK, &dclk_min, &dclk_max);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tsmu_v13_0_4_get_dpm_profile_freq(smu, level, SMU_SCLK, &sclk_min, &sclk_max);\n\t\tsmu_v13_0_4_get_dpm_profile_freq(smu, level, SMU_FCLK, &fclk_min, &fclk_max);\n\t\tsmu_v13_0_4_get_dpm_profile_freq(smu, level, SMU_SOCCLK, &socclk_min, &socclk_max);\n\t\tsmu_v13_0_4_get_dpm_profile_freq(smu, level, SMU_VCLK, &vclk_min, &vclk_max);\n\t\tsmu_v13_0_4_get_dpm_profile_freq(smu, level, SMU_DCLK, &dclk_min, &dclk_max);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(adev->dev, \"Invalid performance level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sclk_min && sclk_max) {\n\t\tret = smu_v13_0_4_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_SCLK,\n\t\t\t\t\t\t\t      sclk_min,\n\t\t\t\t\t\t\t      sclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsmu->gfx_actual_hard_min_freq = sclk_min;\n\t\tsmu->gfx_actual_soft_max_freq = sclk_max;\n\t}\n\n\tif (fclk_min && fclk_max) {\n\t\tret = smu_v13_0_4_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_FCLK,\n\t\t\t\t\t\t\t      fclk_min,\n\t\t\t\t\t\t\t      fclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (socclk_min && socclk_max) {\n\t\tret = smu_v13_0_4_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_SOCCLK,\n\t\t\t\t\t\t\t      socclk_min,\n\t\t\t\t\t\t\t      socclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (vclk_min && vclk_max) {\n\t\tret = smu_v13_0_4_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_VCLK,\n\t\t\t\t\t\t\t      vclk_min,\n\t\t\t\t\t\t\t      vclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dclk_min && dclk_max) {\n\t\tret = smu_v13_0_4_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_DCLK,\n\t\t\t\t\t\t\t      dclk_min,\n\t\t\t\t\t\t\t      dclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic int smu_v13_0_4_mode2_reset(struct smu_context *smu)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GfxDeviceDriverReset,\n\t\t\t\t\t       SMU_RESET_MODE_2, NULL);\n}\n\nstatic int smu_v13_0_4_set_fine_grain_gfx_freq_parameters(struct smu_context *smu)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tsmu->gfx_default_hard_min_freq = clk_table->MinGfxClk;\n\tsmu->gfx_default_soft_max_freq = clk_table->MaxGfxClk;\n\tsmu->gfx_actual_hard_min_freq = 0;\n\tsmu->gfx_actual_soft_max_freq = 0;\n\n\treturn 0;\n}\n\nstatic const struct pptable_funcs smu_v13_0_4_ppt_funcs = {\n\t.check_fw_status = smu_v13_0_check_fw_status,\n\t.check_fw_version = smu_v13_0_check_fw_version,\n\t.init_smc_tables = smu_v13_0_4_init_smc_tables,\n\t.fini_smc_tables = smu_v13_0_4_fini_smc_tables,\n\t.get_vbios_bootup_values = smu_v13_0_get_vbios_bootup_values,\n\t.system_features_control = smu_v13_0_4_system_features_control,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.dpm_set_vcn_enable = smu_v13_0_set_vcn_enable,\n\t.dpm_set_jpeg_enable = smu_v13_0_set_jpeg_enable,\n\t.set_default_dpm_table = smu_v13_0_set_default_dpm_tables,\n\t.read_sensor = smu_v13_0_4_read_sensor,\n\t.is_dpm_running = smu_v13_0_4_is_dpm_running,\n\t.set_watermarks_table = smu_v13_0_4_set_watermarks_table,\n\t.get_gpu_metrics = smu_v13_0_4_get_gpu_metrics,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_driver_table_location = smu_v13_0_set_driver_table_location,\n\t.gfx_off_control = smu_v13_0_gfx_off_control,\n\t.mode2_reset = smu_v13_0_4_mode2_reset,\n\t.get_dpm_ultimate_freq = smu_v13_0_4_get_dpm_ultimate_freq,\n\t.od_edit_dpm_table = smu_v13_0_od_edit_dpm_table,\n\t.print_clk_levels = smu_v13_0_4_print_clk_levels,\n\t.force_clk_levels = smu_v13_0_4_force_clk_levels,\n\t.set_performance_level = smu_v13_0_4_set_performance_level,\n\t.set_fine_grain_gfx_freq_parameters = smu_v13_0_4_set_fine_grain_gfx_freq_parameters,\n\t.set_gfx_power_up_by_imu = smu_v13_0_set_gfx_power_up_by_imu,\n};\n\nstatic void smu_v13_0_4_set_smu_mailbox_registers(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tsmu->param_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_82);\n\tsmu->msg_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_66);\n\tsmu->resp_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n}\n\nvoid smu_v13_0_4_set_ppt_funcs(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tsmu->ppt_funcs = &smu_v13_0_4_ppt_funcs;\n\tsmu->message_map = smu_v13_0_4_message_map;\n\tsmu->feature_map = smu_v13_0_4_feature_mask_map;\n\tsmu->table_map = smu_v13_0_4_table_map;\n\tsmu->smc_driver_if_version = SMU13_0_4_DRIVER_IF_VERSION;\n\tsmu->is_apu = true;\n\n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(13, 0, 4))\n\t\tsmu_v13_0_4_set_smu_mailbox_registers(smu);\n\telse\n\t\tsmu_v13_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}