{
  "module_name": "arcturus_ppt.c",
  "hash_id": "8c7f7d14eb58888039b3d8b0033b886bf3e77c88ede0b588848329d136fe0c26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu11/arcturus_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_dpm.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v11_0.h\"\n#include \"smu11_driver_if_arcturus.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"arcturus_ppt.h\"\n#include \"smu_v11_0_pptable.h\"\n#include \"arcturus_ppsmc.h\"\n#include \"nbio/nbio_7_4_offset.h\"\n#include \"nbio/nbio_7_4_sh_mask.h\"\n#include \"thm/thm_11_0_2_offset.h\"\n#include \"thm/thm_11_0_2_sh_mask.h\"\n#include \"amdgpu_xgmi.h\"\n#include <linux/i2c.h>\n#include <linux/pci.h>\n#include \"amdgpu_ras.h\"\n#include \"smu_cmn.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define ARCTURUS_FEA_MAP(smu_feature, arcturus_feature) \\\n\t[smu_feature] = {1, (arcturus_feature)}\n\n#define SMU_FEATURES_LOW_MASK        0x00000000FFFFFFFF\n#define SMU_FEATURES_LOW_SHIFT       0\n#define SMU_FEATURES_HIGH_MASK       0xFFFFFFFF00000000\n#define SMU_FEATURES_HIGH_SHIFT      32\n\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_DPM_PREFETCHER_MASK | \\\n\tFEATURE_DPM_GFXCLK_MASK | \\\n\tFEATURE_DPM_UCLK_MASK | \\\n\tFEATURE_DPM_SOCCLK_MASK | \\\n\tFEATURE_DPM_MP0CLK_MASK | \\\n\tFEATURE_DPM_FCLK_MASK | \\\n\tFEATURE_DPM_XGMI_MASK)\n\n \n#define EPSILON\t\t\t\t1\n\n#define smnPCIE_ESM_CTRL\t\t\t0x111003D0\n\n#define mmCG_FDO_CTRL0_ARCT\t\t\t0x8B\n#define mmCG_FDO_CTRL0_ARCT_BASE_IDX\t\t0\n\n#define mmCG_FDO_CTRL1_ARCT\t\t\t0x8C\n#define mmCG_FDO_CTRL1_ARCT_BASE_IDX\t\t0\n\n#define mmCG_FDO_CTRL2_ARCT\t\t\t0x8D\n#define mmCG_FDO_CTRL2_ARCT_BASE_IDX\t\t0\n\n#define mmCG_TACH_CTRL_ARCT\t\t\t0x8E\n#define mmCG_TACH_CTRL_ARCT_BASE_IDX\t\t0\n\n#define mmCG_TACH_STATUS_ARCT\t\t\t0x8F\n#define mmCG_TACH_STATUS_ARCT_BASE_IDX\t\t0\n\n#define mmCG_THERMAL_STATUS_ARCT\t\t0x90\n#define mmCG_THERMAL_STATUS_ARCT_BASE_IDX\t0\n\nstatic const struct cmn2asic_msg_mapping arcturus_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,\t\t\t     PPSMC_MSG_TestMessage,\t\t\t0),\n\tMSG_MAP(GetSmuVersion,\t\t\t     PPSMC_MSG_GetSmuVersion,\t\t\t1),\n\tMSG_MAP(GetDriverIfVersion,\t\t     PPSMC_MSG_GetDriverIfVersion,\t\t1),\n\tMSG_MAP(SetAllowedFeaturesMaskLow,\t     PPSMC_MSG_SetAllowedFeaturesMaskLow,\t0),\n\tMSG_MAP(SetAllowedFeaturesMaskHigh,\t     PPSMC_MSG_SetAllowedFeaturesMaskHigh,\t0),\n\tMSG_MAP(EnableAllSmuFeatures,\t\t     PPSMC_MSG_EnableAllSmuFeatures,\t\t0),\n\tMSG_MAP(DisableAllSmuFeatures,\t\t     PPSMC_MSG_DisableAllSmuFeatures,\t\t0),\n\tMSG_MAP(EnableSmuFeaturesLow,\t\t     PPSMC_MSG_EnableSmuFeaturesLow,\t\t1),\n\tMSG_MAP(EnableSmuFeaturesHigh,\t\t     PPSMC_MSG_EnableSmuFeaturesHigh,\t\t1),\n\tMSG_MAP(DisableSmuFeaturesLow,\t\t     PPSMC_MSG_DisableSmuFeaturesLow,\t\t0),\n\tMSG_MAP(DisableSmuFeaturesHigh,\t\t     PPSMC_MSG_DisableSmuFeaturesHigh,\t\t0),\n\tMSG_MAP(GetEnabledSmuFeaturesLow,\t     PPSMC_MSG_GetEnabledSmuFeaturesLow,\t0),\n\tMSG_MAP(GetEnabledSmuFeaturesHigh,\t     PPSMC_MSG_GetEnabledSmuFeaturesHigh,\t0),\n\tMSG_MAP(SetDriverDramAddrHigh,\t\t     PPSMC_MSG_SetDriverDramAddrHigh,\t\t1),\n\tMSG_MAP(SetDriverDramAddrLow,\t\t     PPSMC_MSG_SetDriverDramAddrLow,\t\t1),\n\tMSG_MAP(SetToolsDramAddrHigh,\t\t     PPSMC_MSG_SetToolsDramAddrHigh,\t\t0),\n\tMSG_MAP(SetToolsDramAddrLow,\t\t     PPSMC_MSG_SetToolsDramAddrLow,\t\t0),\n\tMSG_MAP(TransferTableSmu2Dram,\t\t     PPSMC_MSG_TransferTableSmu2Dram,\t\t1),\n\tMSG_MAP(TransferTableDram2Smu,\t\t     PPSMC_MSG_TransferTableDram2Smu,\t\t0),\n\tMSG_MAP(UseDefaultPPTable,\t\t     PPSMC_MSG_UseDefaultPPTable,\t\t0),\n\tMSG_MAP(UseBackupPPTable,\t\t     PPSMC_MSG_UseBackupPPTable,\t\t0),\n\tMSG_MAP(SetSystemVirtualDramAddrHigh,\t     PPSMC_MSG_SetSystemVirtualDramAddrHigh,\t0),\n\tMSG_MAP(SetSystemVirtualDramAddrLow,\t     PPSMC_MSG_SetSystemVirtualDramAddrLow,\t0),\n\tMSG_MAP(EnterBaco,\t\t\t     PPSMC_MSG_EnterBaco,\t\t\t0),\n\tMSG_MAP(ExitBaco,\t\t\t     PPSMC_MSG_ExitBaco,\t\t\t0),\n\tMSG_MAP(ArmD3,\t\t\t\t     PPSMC_MSG_ArmD3,\t\t\t\t0),\n\tMSG_MAP(SetSoftMinByFreq,\t\t     PPSMC_MSG_SetSoftMinByFreq,\t\t0),\n\tMSG_MAP(SetSoftMaxByFreq,\t\t     PPSMC_MSG_SetSoftMaxByFreq,\t\t0),\n\tMSG_MAP(SetHardMinByFreq,\t\t     PPSMC_MSG_SetHardMinByFreq,\t\t0),\n\tMSG_MAP(SetHardMaxByFreq,\t\t     PPSMC_MSG_SetHardMaxByFreq,\t\t0),\n\tMSG_MAP(GetMinDpmFreq,\t\t\t     PPSMC_MSG_GetMinDpmFreq,\t\t\t0),\n\tMSG_MAP(GetMaxDpmFreq,\t\t\t     PPSMC_MSG_GetMaxDpmFreq,\t\t\t0),\n\tMSG_MAP(GetDpmFreqByIndex,\t\t     PPSMC_MSG_GetDpmFreqByIndex,\t\t1),\n\tMSG_MAP(SetWorkloadMask,\t\t     PPSMC_MSG_SetWorkloadMask,\t\t\t1),\n\tMSG_MAP(SetDfSwitchType,\t\t     PPSMC_MSG_SetDfSwitchType,\t\t\t0),\n\tMSG_MAP(GetVoltageByDpm,\t\t     PPSMC_MSG_GetVoltageByDpm,\t\t\t0),\n\tMSG_MAP(GetVoltageByDpmOverdrive,\t     PPSMC_MSG_GetVoltageByDpmOverdrive,\t0),\n\tMSG_MAP(SetPptLimit,\t\t\t     PPSMC_MSG_SetPptLimit,\t\t\t0),\n\tMSG_MAP(GetPptLimit,\t\t\t     PPSMC_MSG_GetPptLimit,\t\t\t1),\n\tMSG_MAP(PowerUpVcn0,\t\t\t     PPSMC_MSG_PowerUpVcn0,\t\t\t0),\n\tMSG_MAP(PowerDownVcn0,\t\t\t     PPSMC_MSG_PowerDownVcn0,\t\t\t0),\n\tMSG_MAP(PowerUpVcn1,\t\t\t     PPSMC_MSG_PowerUpVcn1,\t\t\t0),\n\tMSG_MAP(PowerDownVcn1,\t\t\t     PPSMC_MSG_PowerDownVcn1,\t\t\t0),\n\tMSG_MAP(PrepareMp1ForUnload,\t\t     PPSMC_MSG_PrepareMp1ForUnload,\t\t0),\n\tMSG_MAP(PrepareMp1ForReset,\t\t     PPSMC_MSG_PrepareMp1ForReset,\t\t0),\n\tMSG_MAP(PrepareMp1ForShutdown,\t\t     PPSMC_MSG_PrepareMp1ForShutdown,\t\t0),\n\tMSG_MAP(SoftReset,\t\t\t     PPSMC_MSG_SoftReset,\t\t\t0),\n\tMSG_MAP(RunAfllBtc,\t\t\t     PPSMC_MSG_RunAfllBtc,\t\t\t0),\n\tMSG_MAP(RunDcBtc,\t\t\t     PPSMC_MSG_RunDcBtc,\t\t\t0),\n\tMSG_MAP(DramLogSetDramAddrHigh,\t\t     PPSMC_MSG_DramLogSetDramAddrHigh,\t\t0),\n\tMSG_MAP(DramLogSetDramAddrLow,\t\t     PPSMC_MSG_DramLogSetDramAddrLow,\t\t0),\n\tMSG_MAP(DramLogSetDramSize,\t\t     PPSMC_MSG_DramLogSetDramSize,\t\t0),\n\tMSG_MAP(GetDebugData,\t\t\t     PPSMC_MSG_GetDebugData,\t\t\t0),\n\tMSG_MAP(WaflTest,\t\t\t     PPSMC_MSG_WaflTest,\t\t\t0),\n\tMSG_MAP(SetXgmiMode,\t\t\t     PPSMC_MSG_SetXgmiMode,\t\t\t0),\n\tMSG_MAP(SetMemoryChannelEnable,\t\t     PPSMC_MSG_SetMemoryChannelEnable,\t\t0),\n\tMSG_MAP(DFCstateControl,\t\t     PPSMC_MSG_DFCstateControl,\t\t\t0),\n\tMSG_MAP(GmiPwrDnControl,\t\t     PPSMC_MSG_GmiPwrDnControl,\t\t\t0),\n\tMSG_MAP(ReadSerialNumTop32,\t\t     PPSMC_MSG_ReadSerialNumTop32,\t\t1),\n\tMSG_MAP(ReadSerialNumBottom32,\t\t     PPSMC_MSG_ReadSerialNumBottom32,\t\t1),\n\tMSG_MAP(LightSBR,\t\t\t     PPSMC_MSG_LightSBR,\t\t\t0),\n};\n\nstatic const struct cmn2asic_mapping arcturus_clk_map[SMU_CLK_COUNT] = {\n\tCLK_MAP(GFXCLK, PPCLK_GFXCLK),\n\tCLK_MAP(SCLK,\tPPCLK_GFXCLK),\n\tCLK_MAP(SOCCLK, PPCLK_SOCCLK),\n\tCLK_MAP(FCLK, PPCLK_FCLK),\n\tCLK_MAP(UCLK, PPCLK_UCLK),\n\tCLK_MAP(MCLK, PPCLK_UCLK),\n\tCLK_MAP(DCLK, PPCLK_DCLK),\n\tCLK_MAP(VCLK, PPCLK_VCLK),\n};\n\nstatic const struct cmn2asic_mapping arcturus_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(DPM_PREFETCHER),\n\tFEA_MAP(DPM_GFXCLK),\n\tFEA_MAP(DPM_UCLK),\n\tFEA_MAP(DPM_SOCCLK),\n\tFEA_MAP(DPM_FCLK),\n\tFEA_MAP(DPM_MP0CLK),\n\tFEA_MAP(DPM_XGMI),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_FCLK),\n\tFEA_MAP(DS_UCLK),\n\tFEA_MAP(GFX_ULV),\n\tARCTURUS_FEA_MAP(SMU_FEATURE_VCN_DPM_BIT, FEATURE_DPM_VCN_BIT),\n\tFEA_MAP(RSMU_SMN_CG),\n\tFEA_MAP(WAFL_CG),\n\tFEA_MAP(PPT),\n\tFEA_MAP(TDC),\n\tFEA_MAP(APCC_PLUS),\n\tFEA_MAP(VR0HOT),\n\tFEA_MAP(VR1HOT),\n\tFEA_MAP(FW_CTF),\n\tFEA_MAP(FAN_CONTROL),\n\tFEA_MAP(THERMAL),\n\tFEA_MAP(OUT_OF_BAND_MONITOR),\n\tFEA_MAP(TEMP_DEPENDENT_VMIN),\n};\n\nstatic const struct cmn2asic_mapping arcturus_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP(PPTABLE),\n\tTAB_MAP(AVFS),\n\tTAB_MAP(AVFS_PSM_DEBUG),\n\tTAB_MAP(AVFS_FUSE_OVERRIDE),\n\tTAB_MAP(PMSTATUSLOG),\n\tTAB_MAP(SMU_METRICS),\n\tTAB_MAP(DRIVER_SMU_CONFIG),\n\tTAB_MAP(OVERDRIVE),\n\tTAB_MAP(I2C_COMMANDS),\n\tTAB_MAP(ACTIVITY_MONITOR_COEFF),\n};\n\nstatic const struct cmn2asic_mapping arcturus_pwr_src_map[SMU_POWER_SOURCE_COUNT] = {\n\tPWR_MAP(AC),\n\tPWR_MAP(DC),\n};\n\nstatic const struct cmn2asic_mapping arcturus_workload_map[PP_SMC_POWER_PROFILE_COUNT] = {\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT,\tWORKLOAD_PPLIB_DEFAULT_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_POWERSAVING,\t\tWORKLOAD_PPLIB_POWER_SAVING_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VIDEO,\t\tWORKLOAD_PPLIB_VIDEO_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_COMPUTE,\t\tWORKLOAD_PPLIB_COMPUTE_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CUSTOM,\t\tWORKLOAD_PPLIB_CUSTOM_BIT),\n};\n\nstatic const uint8_t arcturus_throttler_map[] = {\n\t[THROTTLER_TEMP_EDGE_BIT]\t= (SMU_THROTTLER_TEMP_EDGE_BIT),\n\t[THROTTLER_TEMP_HOTSPOT_BIT]\t= (SMU_THROTTLER_TEMP_HOTSPOT_BIT),\n\t[THROTTLER_TEMP_MEM_BIT]\t= (SMU_THROTTLER_TEMP_MEM_BIT),\n\t[THROTTLER_TEMP_VR_GFX_BIT]\t= (SMU_THROTTLER_TEMP_VR_GFX_BIT),\n\t[THROTTLER_TEMP_VR_MEM_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM0_BIT),\n\t[THROTTLER_TEMP_VR_SOC_BIT]\t= (SMU_THROTTLER_TEMP_VR_SOC_BIT),\n\t[THROTTLER_TDC_GFX_BIT]\t\t= (SMU_THROTTLER_TDC_GFX_BIT),\n\t[THROTTLER_TDC_SOC_BIT]\t\t= (SMU_THROTTLER_TDC_SOC_BIT),\n\t[THROTTLER_PPT0_BIT]\t\t= (SMU_THROTTLER_PPT0_BIT),\n\t[THROTTLER_PPT1_BIT]\t\t= (SMU_THROTTLER_PPT1_BIT),\n\t[THROTTLER_PPT2_BIT]\t\t= (SMU_THROTTLER_PPT2_BIT),\n\t[THROTTLER_PPT3_BIT]\t\t= (SMU_THROTTLER_PPT3_BIT),\n\t[THROTTLER_PPM_BIT]\t\t= (SMU_THROTTLER_PPM_BIT),\n\t[THROTTLER_FIT_BIT]\t\t= (SMU_THROTTLER_FIT_BIT),\n\t[THROTTLER_APCC_BIT]\t\t= (SMU_THROTTLER_APCC_BIT),\n\t[THROTTLER_VRHOT0_BIT]\t\t= (SMU_THROTTLER_VRHOT0_BIT),\n\t[THROTTLER_VRHOT1_BIT]\t\t= (SMU_THROTTLER_VRHOT1_BIT),\n};\n\nstatic int arcturus_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PPTABLE, sizeof(PPTable_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PMSTATUSLOG, SMU11_TOOL_SIZE,\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_I2C_COMMANDS, sizeof(SwI2cRequest_t),\n\t\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t       sizeof(DpmActivityMonitorCoeffInt_t), PAGE_SIZE,\n\t\t       AMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\treturn -ENOMEM;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v1_3);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table) {\n\t\tkfree(smu_table->metrics_table);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int arcturus_allocate_dpm_context(struct smu_context *smu)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tsmu_dpm->dpm_context = kzalloc(sizeof(struct smu_11_0_dpm_context),\n\t\t\t\t       GFP_KERNEL);\n\tif (!smu_dpm->dpm_context)\n\t\treturn -ENOMEM;\n\tsmu_dpm->dpm_context_size = sizeof(struct smu_11_0_dpm_context);\n\n\treturn 0;\n}\n\nstatic int arcturus_init_smc_tables(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = arcturus_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arcturus_allocate_dpm_context(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_v11_0_init_smc_tables(smu);\n}\n\nstatic int\narcturus_get_allowed_feature_mask(struct smu_context *smu,\n\t\t\t\t  uint32_t *feature_mask, uint32_t num)\n{\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\t \n\tmemset(feature_mask, 0xFF, sizeof(uint32_t) * num);\n\n\treturn 0;\n}\n\nstatic int arcturus_set_default_dpm_table(struct smu_context *smu)\n{\n\tstruct smu_11_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tPPTable_t *driver_ppt = smu->smu_table.driver_pptable;\n\tstruct smu_11_0_dpm_table *dpm_table = NULL;\n\tint ret = 0;\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.soc_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_SOCCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_SOCCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.socclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.gfx_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_GFXCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_GFXCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.gfxclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.uclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_UCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_UCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.uclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.fclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_FCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_FCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_FCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.fclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\treturn 0;\n}\n\nstatic void arcturus_check_bxco_support(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t val;\n\n\tif (powerplay_table->platform_caps & SMU_11_0_PP_PLATFORM_CAP_BACO ||\n\t    powerplay_table->platform_caps & SMU_11_0_PP_PLATFORM_CAP_MACO) {\n\t\tval = RREG32_SOC15(NBIO, 0, mmRCC_BIF_STRAP0);\n\t\tsmu_baco->platform_support =\n\t\t\t(val & RCC_BIF_STRAP0__STRAP_PX_CAPABLE_MASK) ? true :\n\t\t\t\t\t\t\t\t\tfalse;\n\t}\n}\n\nstatic void arcturus_check_fan_support(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\n\t \n\tsmu->adev->pm.no_fan =\n\t\t!(pptable->FeaturesToRun[0] & FEATURE_FAN_CONTROL_MASK);\n\tif (smu->adev->pm.no_fan)\n\t\tdev_info_once(smu->adev->dev,\n\t\t\t      \"PMFW based fan control disabled\");\n}\n\nstatic int arcturus_check_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\n\tarcturus_check_bxco_support(smu);\n\tarcturus_check_fan_support(smu);\n\n\ttable_context->thermal_controller_type =\n\t\tpowerplay_table->thermal_controller_type;\n\n\treturn 0;\n}\n\nstatic int arcturus_store_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\n\tmemcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t));\n\n\treturn 0;\n}\n\nstatic int arcturus_append_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *smc_pptable = table_context->driver_pptable;\n\tstruct atom_smc_dpm_info_v4_6 *smc_dpm_table;\n\tint index, ret;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t   smc_dpm_info);\n\n\tret = amdgpu_atombios_get_data_table(smu->adev, index, NULL, NULL, NULL,\n\t\t\t\t      (uint8_t **)&smc_dpm_table);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(smu->adev->dev, \"smc_dpm_info table revision(format.content): %d.%d\\n\",\n\t\t\tsmc_dpm_table->table_header.format_revision,\n\t\t\tsmc_dpm_table->table_header.content_revision);\n\n\tif ((smc_dpm_table->table_header.format_revision == 4) &&\n\t    (smc_dpm_table->table_header.content_revision == 6))\n\t\tsmu_memcpy_trailing(smc_pptable, MaxVoltageStepGfx, BoardReserved,\n\t\t\t\t    smc_dpm_table, maxvoltagestepgfx);\n\treturn 0;\n}\n\nstatic int arcturus_setup_pptable(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v11_0_setup_pptable(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arcturus_store_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arcturus_append_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = arcturus_check_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int arcturus_run_btc(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_RunAfllBtc, NULL);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"RunAfllBtc failed!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn smu_cmn_send_smc_msg(smu, SMU_MSG_RunDcBtc, NULL);\n}\n\nstatic int arcturus_populate_umd_state_clk(struct smu_context *smu)\n{\n\tstruct smu_11_0_dpm_context *dpm_context =\n\t\t\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_11_0_dpm_table *gfx_table =\n\t\t\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_11_0_dpm_table *mem_table =\n\t\t\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_11_0_dpm_table *soc_table =\n\t\t\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_umd_pstate_table *pstate_table =\n\t\t\t\t&smu->pstate_table;\n\n\tpstate_table->gfxclk_pstate.min = gfx_table->min;\n\tpstate_table->gfxclk_pstate.peak = gfx_table->max;\n\n\tpstate_table->uclk_pstate.min = mem_table->min;\n\tpstate_table->uclk_pstate.peak = mem_table->max;\n\n\tpstate_table->socclk_pstate.min = soc_table->min;\n\tpstate_table->socclk_pstate.peak = soc_table->max;\n\n\tif (gfx_table->count > ARCTURUS_UMD_PSTATE_GFXCLK_LEVEL &&\n\t    mem_table->count > ARCTURUS_UMD_PSTATE_MCLK_LEVEL &&\n\t    soc_table->count > ARCTURUS_UMD_PSTATE_SOCCLK_LEVEL) {\n\t\tpstate_table->gfxclk_pstate.standard =\n\t\t\tgfx_table->dpm_levels[ARCTURUS_UMD_PSTATE_GFXCLK_LEVEL].value;\n\t\tpstate_table->uclk_pstate.standard =\n\t\t\tmem_table->dpm_levels[ARCTURUS_UMD_PSTATE_MCLK_LEVEL].value;\n\t\tpstate_table->socclk_pstate.standard =\n\t\t\tsoc_table->dpm_levels[ARCTURUS_UMD_PSTATE_SOCCLK_LEVEL].value;\n\t} else {\n\t\tpstate_table->gfxclk_pstate.standard =\n\t\t\tpstate_table->gfxclk_pstate.min;\n\t\tpstate_table->uclk_pstate.standard =\n\t\t\tpstate_table->uclk_pstate.min;\n\t\tpstate_table->socclk_pstate.standard =\n\t\t\tpstate_table->socclk_pstate.min;\n\t}\n\n\treturn 0;\n}\n\nstatic int arcturus_get_clk_table(struct smu_context *smu,\n\t\t\tstruct pp_clock_levels_with_latency *clocks,\n\t\t\tstruct smu_11_0_dpm_table *dpm_table)\n{\n\tuint32_t i;\n\n\tclocks->num_levels = min_t(uint32_t,\n\t\t\t\t   dpm_table->count,\n\t\t\t\t   (uint32_t)PP_MAX_CLOCK_LEVELS);\n\n\tfor (i = 0; i < clocks->num_levels; i++) {\n\t\tclocks->data[i].clocks_in_khz =\n\t\t\tdpm_table->dpm_levels[i].value * 1000;\n\t\tclocks->data[i].latency_in_us = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int arcturus_freqs_in_same_level(int32_t frequency1,\n\t\t\t\t\tint32_t frequency2)\n{\n\treturn (abs(frequency1 - frequency2) <= EPSILON);\n}\n\nstatic int arcturus_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t MetricsMember_t member,\n\t\t\t\t\t uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_t *metrics = (SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK];\n\t\tbreak;\n\tcase METRICS_CURR_FCLK:\n\t\t*value = metrics->CurrClock[PPCLK_FCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\t*value = metrics->AverageGfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->AverageSocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->AverageUclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK:\n\t\t*value = metrics->AverageVclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK:\n\t\t*value = metrics->AverageDclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = metrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCNACTIVITY:\n\t\t*value = metrics->VcnActivityPercentage;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = metrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->TemperatureEdge *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->TemperatureHotspot *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = metrics->TemperatureHBM *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = metrics->TemperatureVrGfx *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = metrics->TemperatureVrSoc *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRMEM:\n\t\t*value = metrics->TemperatureVrMem *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = metrics->CurrFanSpeed;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int arcturus_get_current_clk_freq_by_table(struct smu_context *smu,\n\t\t\t\t       enum smu_clk_type clk_type,\n\t\t\t\t       uint32_t *value)\n{\n\tMetricsMember_t member_type;\n\tint clk_id = 0;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn -EINVAL;\n\n\tswitch (clk_id) {\n\tcase PPCLK_GFXCLK:\n\t\t \n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT))\n\t\t\tmember_type = METRICS_CURR_GFXCLK;\n\t\telse\n\t\t\tmember_type = METRICS_AVERAGE_GFXCLK;\n\t\tbreak;\n\tcase PPCLK_UCLK:\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT))\n\t\t\tmember_type = METRICS_CURR_UCLK;\n\t\telse\n\t\t\tmember_type = METRICS_AVERAGE_UCLK;\n\t\tbreak;\n\tcase PPCLK_SOCCLK:\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT))\n\t\t\tmember_type = METRICS_CURR_SOCCLK;\n\t\telse\n\t\t\tmember_type = METRICS_AVERAGE_SOCCLK;\n\t\tbreak;\n\tcase PPCLK_VCLK:\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_DPM_BIT))\n\t\t\tmember_type = METRICS_CURR_VCLK;\n\t\telse\n\t\t\tmember_type = METRICS_AVERAGE_VCLK;\n\t\tbreak;\n\tcase PPCLK_DCLK:\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_DPM_BIT))\n\t\t\tmember_type = METRICS_CURR_DCLK;\n\t\telse\n\t\t\tmember_type = METRICS_AVERAGE_DCLK;\n\t\tbreak;\n\tcase PPCLK_FCLK:\n\t\tmember_type = METRICS_CURR_FCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t     member_type,\n\t\t\t\t\t     value);\n}\n\nstatic int arcturus_print_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type type, char *buf)\n{\n\tint i, now, size = 0;\n\tint ret = 0;\n\tstruct pp_clock_levels_with_latency clocks;\n\tstruct smu_11_0_dpm_table *single_dpm_table;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_11_0_dpm_context *dpm_context = NULL;\n\tuint32_t gen_speed, lane_width;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tif (amdgpu_ras_intr_triggered()) {\n\t\tsize += sysfs_emit_at(buf, size, \"unavailable\\n\");\n\t\treturn size;\n\t}\n\n\tdpm_context = smu_dpm->dpm_context;\n\n\tswitch (type) {\n\tcase SMU_SCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_GFXCLK, &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get current gfx clk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.gfx_table);\n\t\tret = arcturus_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get gfx clk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i,\n\t\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t\t(clocks.num_levels == 1) ? \"*\" :\n\t\t\t\t\t(arcturus_freqs_in_same_level(\n\t\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t\tnow) ? \"*\" : \"\"));\n\t\tbreak;\n\n\tcase SMU_MCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_UCLK, &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get current mclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.uclk_table);\n\t\tret = arcturus_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get memory clk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, clocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.num_levels == 1) ? \"*\" :\n\t\t\t\t(arcturus_freqs_in_same_level(\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\tnow) ? \"*\" : \"\"));\n\t\tbreak;\n\n\tcase SMU_SOCCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_SOCCLK, &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get current socclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.soc_table);\n\t\tret = arcturus_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get socclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, clocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.num_levels == 1) ? \"*\" :\n\t\t\t\t(arcturus_freqs_in_same_level(\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\tnow) ? \"*\" : \"\"));\n\t\tbreak;\n\n\tcase SMU_FCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_FCLK, &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get current fclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.fclk_table);\n\t\tret = arcturus_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get fclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, single_dpm_table->dpm_levels[i].value,\n\t\t\t\t(clocks.num_levels == 1) ? \"*\" :\n\t\t\t\t(arcturus_freqs_in_same_level(\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\tnow) ? \"*\" : \"\"));\n\t\tbreak;\n\n\tcase SMU_VCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_VCLK, &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get current vclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.vclk_table);\n\t\tret = arcturus_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get vclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, single_dpm_table->dpm_levels[i].value,\n\t\t\t\t(clocks.num_levels == 1) ? \"*\" :\n\t\t\t\t(arcturus_freqs_in_same_level(\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\tnow) ? \"*\" : \"\"));\n\t\tbreak;\n\n\tcase SMU_DCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_DCLK, &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get current dclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.dclk_table);\n\t\tret = arcturus_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Attempt to get dclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\",\n\t\t\t\ti, single_dpm_table->dpm_levels[i].value,\n\t\t\t\t(clocks.num_levels == 1) ? \"*\" :\n\t\t\t\t(arcturus_freqs_in_same_level(\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\tnow) ? \"*\" : \"\"));\n\t\tbreak;\n\n\tcase SMU_PCIE:\n\t\tgen_speed = smu_v11_0_get_current_pcie_link_speed_level(smu);\n\t\tlane_width = smu_v11_0_get_current_pcie_link_width_level(smu);\n\t\tsize += sysfs_emit_at(buf, size, \"0: %s %s %dMhz *\\n\",\n\t\t\t\t(gen_speed == 0) ? \"2.5GT/s,\" :\n\t\t\t\t(gen_speed == 1) ? \"5.0GT/s,\" :\n\t\t\t\t(gen_speed == 2) ? \"8.0GT/s,\" :\n\t\t\t\t(gen_speed == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t(lane_width == 1) ? \"x1\" :\n\t\t\t\t(lane_width == 2) ? \"x2\" :\n\t\t\t\t(lane_width == 3) ? \"x4\" :\n\t\t\t\t(lane_width == 4) ? \"x8\" :\n\t\t\t\t(lane_width == 5) ? \"x12\" :\n\t\t\t\t(lane_width == 6) ? \"x16\" : \"\",\n\t\t\t\tsmu->smu_table.boot_values.lclk / 100);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int arcturus_upload_dpm_level(struct smu_context *smu,\n\t\t\t\t     bool max,\n\t\t\t\t     uint32_t feature_mask,\n\t\t\t\t     uint32_t level)\n{\n\tstruct smu_11_0_dpm_context *dpm_context =\n\t\t\tsmu->smu_dpm.dpm_context;\n\tuint32_t freq;\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT) &&\n\t    (feature_mask & FEATURE_DPM_GFXCLK_MASK)) {\n\t\tfreq = dpm_context->dpm_tables.gfx_table.dpm_levels[level].value;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t(max ? SMU_MSG_SetSoftMaxByFreq : SMU_MSG_SetSoftMinByFreq),\n\t\t\t(PPCLK_GFXCLK << 16) | (freq & 0xffff),\n\t\t\tNULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to set soft %s gfxclk !\\n\",\n\t\t\t\t\t\tmax ? \"max\" : \"min\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT) &&\n\t    (feature_mask & FEATURE_DPM_UCLK_MASK)) {\n\t\tfreq = dpm_context->dpm_tables.uclk_table.dpm_levels[level].value;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t(max ? SMU_MSG_SetSoftMaxByFreq : SMU_MSG_SetSoftMinByFreq),\n\t\t\t(PPCLK_UCLK << 16) | (freq & 0xffff),\n\t\t\tNULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to set soft %s memclk !\\n\",\n\t\t\t\t\t\tmax ? \"max\" : \"min\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT) &&\n\t    (feature_mask & FEATURE_DPM_SOCCLK_MASK)) {\n\t\tfreq = dpm_context->dpm_tables.soc_table.dpm_levels[level].value;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t(max ? SMU_MSG_SetSoftMaxByFreq : SMU_MSG_SetSoftMinByFreq),\n\t\t\t(PPCLK_SOCCLK << 16) | (freq & 0xffff),\n\t\t\tNULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to set soft %s socclk !\\n\",\n\t\t\t\t\t\tmax ? \"max\" : \"min\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int arcturus_force_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type type, uint32_t mask)\n{\n\tstruct smu_11_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_11_0_dpm_table *single_dpm_table = NULL;\n\tuint32_t soft_min_level, soft_max_level;\n\tuint32_t smu_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((smu_version >= 0x361200) &&\n\t    (smu_version <= 0x361a00)) {\n\t\tdev_err(smu->adev->dev, \"Forcing clock level is not supported with \"\n\t\t       \"54.18 - 54.26(included) SMU firmwares\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (type) {\n\tcase SMU_SCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.gfx_table);\n\t\tif (soft_max_level >= single_dpm_table->count) {\n\t\t\tdev_err(smu->adev->dev, \"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\t\tsoft_max_level, single_dpm_table->count - 1);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = arcturus_upload_dpm_level(smu,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tFEATURE_DPM_GFXCLK_MASK,\n\t\t\t\t\t\tsoft_min_level);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to upload boot level to lowest!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tret = arcturus_upload_dpm_level(smu,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tFEATURE_DPM_GFXCLK_MASK,\n\t\t\t\t\t\tsoft_max_level);\n\t\tif (ret)\n\t\t\tdev_err(smu->adev->dev, \"Failed to upload dpm max level to highest!\\n\");\n\n\t\tbreak;\n\n\tcase SMU_MCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_FCLK:\n\t\t \n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int arcturus_get_thermal_temperature_range(struct smu_context *smu,\n\t\t\t\t\t\tstruct smu_temperature_range *range)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\t\t\ttable_context->power_play_table;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tmemcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range));\n\n\trange->max = pptable->TedgeLimit *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->edge_emergency_max = (pptable->TedgeLimit + CTF_OFFSET_EDGE) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_crit_max = pptable->ThotspotLimit *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_emergency_max = (pptable->ThotspotLimit + CTF_OFFSET_HOTSPOT) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_crit_max = pptable->TmemLimit *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_emergency_max = (pptable->TmemLimit + CTF_OFFSET_MEM)*\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->software_shutdown_temp = powerplay_table->software_shutdown_temp;\n\n\treturn 0;\n}\n\nstatic int arcturus_read_sensor(struct smu_context *smu,\n\t\t\t\tenum amd_pp_sensors sensor,\n\t\t\t\tvoid *data, uint32_t *size)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tint ret = 0;\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_MAX_FAN_RPM:\n\t\t*(uint32_t *)data = pptable->FanMaximumRpm;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_AVERAGE_MEMACTIVITY,\n\t\t\t\t\t\t    (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t    (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t    (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t    (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t    (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_TEMPERATURE_MEM,\n\t\t\t\t\t\t    (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_UCLK, (uint32_t *)data);\n\t\t \n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = arcturus_get_current_clk_freq_by_table(smu, SMU_GFXCLK, (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = smu_v11_0_get_gfx_vdd(smu, (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int arcturus_set_fan_static_mode(struct smu_context *smu,\n\t\t\t\t\tuint32_t mode)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tWREG32_SOC15(THM, 0, mmCG_FDO_CTRL2_ARCT,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL2_ARCT),\n\t\t\t\t   CG_FDO_CTRL2, TMIN, 0));\n\tWREG32_SOC15(THM, 0, mmCG_FDO_CTRL2_ARCT,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL2_ARCT),\n\t\t\t\t   CG_FDO_CTRL2, FDO_PWM_MODE, mode));\n\n\treturn 0;\n}\n\nstatic int arcturus_get_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\t      uint32_t *speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t crystal_clock_freq = 2500;\n\tuint32_t tach_status;\n\tuint64_t tmp64;\n\tint ret = 0;\n\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\tswitch (smu_v11_0_get_fan_control_mode(smu)) {\n\tcase AMD_FAN_CTRL_AUTO:\n\t\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t\t    METRICS_CURR_FANSPEED,\n\t\t\t\t\t\t    speed);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif ((smu->user_dpm_profile.flags & SMU_CUSTOM_FAN_SPEED_RPM)\n\t\t     && !smu->user_dpm_profile.fan_speed_rpm) {\n\t\t\t*speed = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\ttmp64 = (uint64_t)crystal_clock_freq * 60 * 10000;\n\t\ttach_status = RREG32_SOC15(THM, 0, mmCG_TACH_STATUS_ARCT);\n\t\tif (tach_status) {\n\t\t\tdo_div(tmp64, tach_status);\n\t\t\t*speed = (uint32_t)tmp64;\n\t\t} else {\n\t\t\t*speed = 0;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int arcturus_set_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\t      uint32_t speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t duty100, duty;\n\tuint64_t tmp64;\n\n\tspeed = MIN(speed, 255);\n\n\tduty100 = REG_GET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL1_ARCT),\n\t\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\tif (!duty100)\n\t\treturn -EINVAL;\n\n\ttmp64 = (uint64_t)speed * duty100;\n\tdo_div(tmp64, 255);\n\tduty = (uint32_t)tmp64;\n\n\tWREG32_SOC15(THM, 0, mmCG_FDO_CTRL0_ARCT,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL0_ARCT),\n\t\t\t\t   CG_FDO_CTRL0, FDO_STATIC_DUTY, duty));\n\n\treturn arcturus_set_fan_static_mode(smu, FDO_PWM_MODE_STATIC);\n}\n\nstatic int arcturus_set_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\t      uint32_t speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\t \n\tuint32_t crystal_clock_freq = 2500;\n\tuint32_t tach_period;\n\n\ttach_period = 60 * crystal_clock_freq * 10000 / (8 * speed);\n\tWREG32_SOC15(THM, 0, mmCG_TACH_CTRL_ARCT,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_TACH_CTRL_ARCT),\n\t\t\t\t   CG_TACH_CTRL, TARGET_PERIOD,\n\t\t\t\t   tach_period));\n\n\treturn arcturus_set_fan_static_mode(smu, FDO_PWM_MODE_STATIC_RPM);\n}\n\nstatic int arcturus_get_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\t      uint32_t *speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t duty100, duty;\n\tuint64_t tmp64;\n\n\t \n\tif ((smu->user_dpm_profile.flags & SMU_CUSTOM_FAN_SPEED_PWM)\n\t     && !smu->user_dpm_profile.fan_speed_pwm) {\n\t\t*speed = 0;\n\t\treturn 0;\n\t}\n\n\tduty100 = REG_GET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL1_ARCT),\n\t\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\tduty = REG_GET_FIELD(RREG32_SOC15(THM, 0, mmCG_THERMAL_STATUS_ARCT),\n\t\t\t\tCG_THERMAL_STATUS, FDO_PWM_DUTY);\n\n\tif (duty100) {\n\t\ttmp64 = (uint64_t)duty * 255;\n\t\tdo_div(tmp64, duty100);\n\t\t*speed = MIN((uint32_t)tmp64, 255);\n\t} else {\n\t\t*speed = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int arcturus_get_fan_parameters(struct smu_context *smu)\n{\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\n\tsmu->fan_max_rpm = pptable->FanMaximumRpm;\n\n\treturn 0;\n}\n\nstatic int arcturus_get_power_limit(struct smu_context *smu,\n\t\t\t\t    uint32_t *current_power_limit,\n\t\t\t\t    uint32_t *default_power_limit,\n\t\t\t\t    uint32_t *max_power_limit)\n{\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\t(struct smu_11_0_powerplay_table *)smu->smu_table.power_play_table;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tuint32_t power_limit, od_percent;\n\n\tif (smu_v11_0_get_current_power_limit(smu, &power_limit)) {\n\t\t \n\t\tif (!pptable) {\n\t\t\tdev_err(smu->adev->dev, \"Cannot get PPT limit due to pptable missing!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpower_limit =\n\t\t\tpptable->SocketPowerLimitAc[PPT_THROTTLER_PPT0];\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (max_power_limit) {\n\t\tif (smu->od_enabled) {\n\t\t\tod_percent = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_11_0_ODSETTING_POWERPERCENTAGE]);\n\n\t\t\tdev_dbg(smu->adev->dev, \"ODSETTING_POWERPERCENTAGE: %d (default: %d)\\n\", od_percent, power_limit);\n\n\t\t\tpower_limit *= (100 + od_percent);\n\t\t\tpower_limit /= 100;\n\t\t}\n\n\t\t*max_power_limit = power_limit;\n\t}\n\n\treturn 0;\n}\n\nstatic int arcturus_get_power_profile_mode(struct smu_context *smu,\n\t\t\t\t\t   char *buf)\n{\n\tDpmActivityMonitorCoeffInt_t activity_monitor;\n\tstatic const char *title[] = {\n\t\t\t\"PROFILE_INDEX(NAME)\",\n\t\t\t\"CLOCK_TYPE(NAME)\",\n\t\t\t\"FPS\",\n\t\t\t\"UseRlcBusy\",\n\t\t\t\"MinActiveFreqType\",\n\t\t\t\"MinActiveFreq\",\n\t\t\t\"BoosterFreqType\",\n\t\t\t\"BoosterFreq\",\n\t\t\t\"PD_Data_limit_c\",\n\t\t\t\"PD_Data_error_coeff\",\n\t\t\t\"PD_Data_error_rate_coeff\"};\n\tuint32_t i, size = 0;\n\tint16_t workload_type = 0;\n\tint result = 0;\n\tuint32_t smu_version;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tresult = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (result)\n\t\treturn result;\n\n\tif (smu_version >= 0x360d00)\n\t\tsize += sysfs_emit_at(buf, size, \"%16s %s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\ttitle[0], title[1], title[2], title[3], title[4], title[5],\n\t\t\ttitle[6], title[7], title[8], title[9], title[10]);\n\telse\n\t\tsize += sysfs_emit_at(buf, size, \"%16s\\n\",\n\t\t\ttitle[0]);\n\n\tfor (i = 0; i <= PP_SMC_POWER_PROFILE_CUSTOM; i++) {\n\t\t \n\t\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t\t       i);\n\t\tif (workload_type < 0)\n\t\t\tcontinue;\n\n\t\tif (smu_version >= 0x360d00) {\n\t\t\tresult = smu_cmn_update_table(smu,\n\t\t\t\t\t\t  SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t\t\t\t\t  workload_type,\n\t\t\t\t\t\t  (void *)(&activity_monitor),\n\t\t\t\t\t\t  false);\n\t\t\tif (result) {\n\t\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == smu->power_profile_mode) ? \"*\" : \" \");\n\n\t\tif (smu_version >= 0x360d00) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t0,\n\t\t\t\t\"GFXCLK\",\n\t\t\t\tactivity_monitor.Gfx_FPS,\n\t\t\t\tactivity_monitor.Gfx_UseRlcBusy,\n\t\t\t\tactivity_monitor.Gfx_MinActiveFreqType,\n\t\t\t\tactivity_monitor.Gfx_MinActiveFreq,\n\t\t\t\tactivity_monitor.Gfx_BoosterFreqType,\n\t\t\t\tactivity_monitor.Gfx_BoosterFreq,\n\t\t\t\tactivity_monitor.Gfx_PD_Data_limit_c,\n\t\t\t\tactivity_monitor.Gfx_PD_Data_error_coeff,\n\t\t\t\tactivity_monitor.Gfx_PD_Data_error_rate_coeff);\n\n\t\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\t\" \",\n\t\t\t\t1,\n\t\t\t\t\"UCLK\",\n\t\t\t\tactivity_monitor.Mem_FPS,\n\t\t\t\tactivity_monitor.Mem_UseRlcBusy,\n\t\t\t\tactivity_monitor.Mem_MinActiveFreqType,\n\t\t\t\tactivity_monitor.Mem_MinActiveFreq,\n\t\t\t\tactivity_monitor.Mem_BoosterFreqType,\n\t\t\t\tactivity_monitor.Mem_BoosterFreq,\n\t\t\t\tactivity_monitor.Mem_PD_Data_limit_c,\n\t\t\t\tactivity_monitor.Mem_PD_Data_error_coeff,\n\t\t\t\tactivity_monitor.Mem_PD_Data_error_rate_coeff);\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic int arcturus_set_power_profile_mode(struct smu_context *smu,\n\t\t\t\t\t   long *input,\n\t\t\t\t\t   uint32_t size)\n{\n\tDpmActivityMonitorCoeffInt_t activity_monitor;\n\tint workload_type = 0;\n\tuint32_t profile_mode = input[size];\n\tint ret = 0;\n\tuint32_t smu_version;\n\n\tif (profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tdev_err(smu->adev->dev, \"Invalid power profile mode %d\\n\", profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) &&\n\t     (smu_version >= 0x360d00)) {\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t       SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t\t\t       WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t       (void *)(&activity_monitor),\n\t\t\t\t       false);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (input[0]) {\n\t\tcase 0:  \n\t\t\tactivity_monitor.Gfx_FPS = input[1];\n\t\t\tactivity_monitor.Gfx_UseRlcBusy = input[2];\n\t\t\tactivity_monitor.Gfx_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Gfx_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Gfx_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Gfx_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Gfx_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Gfx_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tactivity_monitor.Mem_FPS = input[1];\n\t\t\tactivity_monitor.Mem_UseRlcBusy = input[2];\n\t\t\tactivity_monitor.Mem_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Mem_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Mem_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Mem_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Mem_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Mem_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Mem_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\t}\n\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t       SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t\t\t       WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t       (void *)(&activity_monitor),\n\t\t\t\t       true);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to set activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t       profile_mode);\n\tif (workload_type < 0) {\n\t\tdev_dbg(smu->adev->dev, \"Unsupported power profile mode %d on arcturus\\n\", profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_SetWorkloadMask,\n\t\t\t\t\t  1 << workload_type,\n\t\t\t\t\t  NULL);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Fail to set workload type %d\\n\", workload_type);\n\t\treturn ret;\n\t}\n\n\tsmu->power_profile_mode = profile_mode;\n\n\treturn 0;\n}\n\nstatic int arcturus_set_performance_level(struct smu_context *smu,\n\t\t\t\t\t  enum amd_dpm_forced_level level)\n{\n\tuint32_t smu_version;\n\tint ret;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tif ((smu_version >= 0x361200) &&\n\t\t    (smu_version <= 0x361a00)) {\n\t\t\tdev_err(smu->adev->dev, \"Forcing clock level is not supported with \"\n\t\t\t       \"54.18 - 54.26(included) SMU firmwares\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn smu_v11_0_set_performance_level(smu, level);\n}\n\nstatic void arcturus_dump_pptable(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tint i;\n\n\tdev_info(smu->adev->dev, \"Dumped PPTable:\\n\");\n\n\tdev_info(smu->adev->dev, \"Version = 0x%08x\\n\", pptable->Version);\n\n\tdev_info(smu->adev->dev, \"FeaturesToRun[0] = 0x%08x\\n\", pptable->FeaturesToRun[0]);\n\tdev_info(smu->adev->dev, \"FeaturesToRun[1] = 0x%08x\\n\", pptable->FeaturesToRun[1]);\n\n\tfor (i = 0; i < PPT_THROTTLER_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitAc[%d] = %d\\n\", i, pptable->SocketPowerLimitAc[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitAcTau[%d] = %d\\n\", i, pptable->SocketPowerLimitAcTau[i]);\n\t}\n\n\tdev_info(smu->adev->dev, \"TdcLimitSoc = %d\\n\", pptable->TdcLimitSoc);\n\tdev_info(smu->adev->dev, \"TdcLimitSocTau = %d\\n\", pptable->TdcLimitSocTau);\n\tdev_info(smu->adev->dev, \"TdcLimitGfx = %d\\n\", pptable->TdcLimitGfx);\n\tdev_info(smu->adev->dev, \"TdcLimitGfxTau = %d\\n\", pptable->TdcLimitGfxTau);\n\n\tdev_info(smu->adev->dev, \"TedgeLimit = %d\\n\", pptable->TedgeLimit);\n\tdev_info(smu->adev->dev, \"ThotspotLimit = %d\\n\", pptable->ThotspotLimit);\n\tdev_info(smu->adev->dev, \"TmemLimit = %d\\n\", pptable->TmemLimit);\n\tdev_info(smu->adev->dev, \"Tvr_gfxLimit = %d\\n\", pptable->Tvr_gfxLimit);\n\tdev_info(smu->adev->dev, \"Tvr_memLimit = %d\\n\", pptable->Tvr_memLimit);\n\tdev_info(smu->adev->dev, \"Tvr_socLimit = %d\\n\", pptable->Tvr_socLimit);\n\tdev_info(smu->adev->dev, \"FitLimit = %d\\n\", pptable->FitLimit);\n\n\tdev_info(smu->adev->dev, \"PpmPowerLimit = %d\\n\", pptable->PpmPowerLimit);\n\tdev_info(smu->adev->dev, \"PpmTemperatureThreshold = %d\\n\", pptable->PpmTemperatureThreshold);\n\n\tdev_info(smu->adev->dev, \"ThrottlerControlMask = %d\\n\", pptable->ThrottlerControlMask);\n\n\tdev_info(smu->adev->dev, \"UlvVoltageOffsetGfx = %d\\n\", pptable->UlvVoltageOffsetGfx);\n\tdev_info(smu->adev->dev, \"UlvPadding = 0x%08x\\n\", pptable->UlvPadding);\n\n\tdev_info(smu->adev->dev, \"UlvGfxclkBypass = %d\\n\", pptable->UlvGfxclkBypass);\n\tdev_info(smu->adev->dev, \"Padding234[0] = 0x%02x\\n\", pptable->Padding234[0]);\n\tdev_info(smu->adev->dev, \"Padding234[1] = 0x%02x\\n\", pptable->Padding234[1]);\n\tdev_info(smu->adev->dev, \"Padding234[2] = 0x%02x\\n\", pptable->Padding234[2]);\n\n\tdev_info(smu->adev->dev, \"MinVoltageGfx = %d\\n\", pptable->MinVoltageGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageSoc = %d\\n\", pptable->MinVoltageSoc);\n\tdev_info(smu->adev->dev, \"MaxVoltageGfx = %d\\n\", pptable->MaxVoltageGfx);\n\tdev_info(smu->adev->dev, \"MaxVoltageSoc = %d\\n\", pptable->MaxVoltageSoc);\n\n\tdev_info(smu->adev->dev, \"LoadLineResistanceGfx = %d\\n\", pptable->LoadLineResistanceGfx);\n\tdev_info(smu->adev->dev, \"LoadLineResistanceSoc = %d\\n\", pptable->LoadLineResistanceSoc);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_GFXCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_VCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_DCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_SOCCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_UCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_FCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].Padding16);\n\n\n\tdev_info(smu->adev->dev, \"FreqTableGfx\\n\");\n\tfor (i = 0; i < NUM_GFXCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = %d\\n\", i, pptable->FreqTableGfx[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableVclk\\n\");\n\tfor (i = 0; i < NUM_VCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = %d\\n\", i, pptable->FreqTableVclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableDclk\\n\");\n\tfor (i = 0; i < NUM_DCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = %d\\n\", i, pptable->FreqTableDclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableSocclk\\n\");\n\tfor (i = 0; i < NUM_SOCCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = %d\\n\", i, pptable->FreqTableSocclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableUclk\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = %d\\n\", i, pptable->FreqTableUclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableFclk\\n\");\n\tfor (i = 0; i < NUM_FCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = %d\\n\", i, pptable->FreqTableFclk[i]);\n\n\tdev_info(smu->adev->dev, \"Mp0clkFreq\\n\");\n\tfor (i = 0; i < NUM_MP0CLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->Mp0clkFreq[i]);\n\n\tdev_info(smu->adev->dev, \"Mp0DpmVoltage\\n\");\n\tfor (i = 0; i < NUM_MP0CLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->Mp0DpmVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"GfxclkFidle = 0x%x\\n\", pptable->GfxclkFidle);\n\tdev_info(smu->adev->dev, \"GfxclkSlewRate = 0x%x\\n\", pptable->GfxclkSlewRate);\n\tdev_info(smu->adev->dev, \"Padding567[0] = 0x%x\\n\", pptable->Padding567[0]);\n\tdev_info(smu->adev->dev, \"Padding567[1] = 0x%x\\n\", pptable->Padding567[1]);\n\tdev_info(smu->adev->dev, \"Padding567[2] = 0x%x\\n\", pptable->Padding567[2]);\n\tdev_info(smu->adev->dev, \"Padding567[3] = 0x%x\\n\", pptable->Padding567[3]);\n\tdev_info(smu->adev->dev, \"GfxclkDsMaxFreq = %d\\n\", pptable->GfxclkDsMaxFreq);\n\tdev_info(smu->adev->dev, \"GfxclkSource = 0x%x\\n\", pptable->GfxclkSource);\n\tdev_info(smu->adev->dev, \"Padding456 = 0x%x\\n\", pptable->Padding456);\n\n\tdev_info(smu->adev->dev, \"EnableTdpm = %d\\n\", pptable->EnableTdpm);\n\tdev_info(smu->adev->dev, \"TdpmHighHystTemperature = %d\\n\", pptable->TdpmHighHystTemperature);\n\tdev_info(smu->adev->dev, \"TdpmLowHystTemperature = %d\\n\", pptable->TdpmLowHystTemperature);\n\tdev_info(smu->adev->dev, \"GfxclkFreqHighTempLimit = %d\\n\", pptable->GfxclkFreqHighTempLimit);\n\n\tdev_info(smu->adev->dev, \"FanStopTemp = %d\\n\", pptable->FanStopTemp);\n\tdev_info(smu->adev->dev, \"FanStartTemp = %d\\n\", pptable->FanStartTemp);\n\n\tdev_info(smu->adev->dev, \"FanGainEdge = %d\\n\", pptable->FanGainEdge);\n\tdev_info(smu->adev->dev, \"FanGainHotspot = %d\\n\", pptable->FanGainHotspot);\n\tdev_info(smu->adev->dev, \"FanGainVrGfx = %d\\n\", pptable->FanGainVrGfx);\n\tdev_info(smu->adev->dev, \"FanGainVrSoc = %d\\n\", pptable->FanGainVrSoc);\n\tdev_info(smu->adev->dev, \"FanGainVrMem = %d\\n\", pptable->FanGainVrMem);\n\tdev_info(smu->adev->dev, \"FanGainHbm = %d\\n\", pptable->FanGainHbm);\n\n\tdev_info(smu->adev->dev, \"FanPwmMin = %d\\n\", pptable->FanPwmMin);\n\tdev_info(smu->adev->dev, \"FanAcousticLimitRpm = %d\\n\", pptable->FanAcousticLimitRpm);\n\tdev_info(smu->adev->dev, \"FanThrottlingRpm = %d\\n\", pptable->FanThrottlingRpm);\n\tdev_info(smu->adev->dev, \"FanMaximumRpm = %d\\n\", pptable->FanMaximumRpm);\n\tdev_info(smu->adev->dev, \"FanTargetTemperature = %d\\n\", pptable->FanTargetTemperature);\n\tdev_info(smu->adev->dev, \"FanTargetGfxclk = %d\\n\", pptable->FanTargetGfxclk);\n\tdev_info(smu->adev->dev, \"FanZeroRpmEnable = %d\\n\", pptable->FanZeroRpmEnable);\n\tdev_info(smu->adev->dev, \"FanTachEdgePerRev = %d\\n\", pptable->FanTachEdgePerRev);\n\tdev_info(smu->adev->dev, \"FanTempInputSelect = %d\\n\", pptable->FanTempInputSelect);\n\n\tdev_info(smu->adev->dev, \"FuzzyFan_ErrorSetDelta = %d\\n\", pptable->FuzzyFan_ErrorSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_ErrorRateSetDelta = %d\\n\", pptable->FuzzyFan_ErrorRateSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_PwmSetDelta = %d\\n\", pptable->FuzzyFan_PwmSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_Reserved = %d\\n\", pptable->FuzzyFan_Reserved);\n\n\tdev_info(smu->adev->dev, \"OverrideAvfsGb[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->OverrideAvfsGb[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"OverrideAvfsGb[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->OverrideAvfsGb[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"Padding8_Avfs[0] = %d\\n\", pptable->Padding8_Avfs[0]);\n\tdev_info(smu->adev->dev, \"Padding8_Avfs[1] = %d\\n\", pptable->Padding8_Avfs[1]);\n\n\tdev_info(smu->adev->dev, \"dBtcGbGfxPll{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbGfxPll.a,\n\t\t\tpptable->dBtcGbGfxPll.b,\n\t\t\tpptable->dBtcGbGfxPll.c);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxAfll{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbGfxAfll.a,\n\t\t\tpptable->dBtcGbGfxAfll.b,\n\t\t\tpptable->dBtcGbGfxAfll.c);\n\tdev_info(smu->adev->dev, \"dBtcGbSoc{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbSoc.a,\n\t\t\tpptable->dBtcGbSoc.b,\n\t\t\tpptable->dBtcGbSoc.c);\n\n\tdev_info(smu->adev->dev, \"qAgingGb[AVFS_VOLTAGE_GFX]{m = 0x%x b = 0x%x}\\n\",\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_GFX].m,\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_GFX].b);\n\tdev_info(smu->adev->dev, \"qAgingGb[AVFS_VOLTAGE_SOC]{m = 0x%x b = 0x%x}\\n\",\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_SOC].m,\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_SOC].b);\n\n\tdev_info(smu->adev->dev, \"qStaticVoltageOffset[AVFS_VOLTAGE_GFX]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].a,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].b,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].c);\n\tdev_info(smu->adev->dev, \"qStaticVoltageOffset[AVFS_VOLTAGE_SOC]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].a,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].b,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].c);\n\n\tdev_info(smu->adev->dev, \"DcTol[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcTol[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcTol[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcTol[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"DcBtcEnabled[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcEnabled[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcEnabled[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcEnabled[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"Padding8_GfxBtc[0] = 0x%x\\n\", pptable->Padding8_GfxBtc[0]);\n\tdev_info(smu->adev->dev, \"Padding8_GfxBtc[1] = 0x%x\\n\", pptable->Padding8_GfxBtc[1]);\n\n\tdev_info(smu->adev->dev, \"DcBtcMin[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcMin[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcMin[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcMin[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"DcBtcMax[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcMax[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcMax[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcMax[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"DcBtcGb[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcGb[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcGb[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcGb[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"XgmiDpmPstates\\n\");\n\tfor (i = 0; i < NUM_XGMI_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->XgmiDpmPstates[i]);\n\tdev_info(smu->adev->dev, \"XgmiDpmSpare[0] = 0x%02x\\n\", pptable->XgmiDpmSpare[0]);\n\tdev_info(smu->adev->dev, \"XgmiDpmSpare[1] = 0x%02x\\n\", pptable->XgmiDpmSpare[1]);\n\n\tdev_info(smu->adev->dev, \"VDDGFX_TVmin = %d\\n\", pptable->VDDGFX_TVmin);\n\tdev_info(smu->adev->dev, \"VDDSOC_TVmin = %d\\n\", pptable->VDDSOC_TVmin);\n\tdev_info(smu->adev->dev, \"VDDGFX_Vmin_HiTemp = %d\\n\", pptable->VDDGFX_Vmin_HiTemp);\n\tdev_info(smu->adev->dev, \"VDDGFX_Vmin_LoTemp = %d\\n\", pptable->VDDGFX_Vmin_LoTemp);\n\tdev_info(smu->adev->dev, \"VDDSOC_Vmin_HiTemp = %d\\n\", pptable->VDDSOC_Vmin_HiTemp);\n\tdev_info(smu->adev->dev, \"VDDSOC_Vmin_LoTemp = %d\\n\", pptable->VDDSOC_Vmin_LoTemp);\n\tdev_info(smu->adev->dev, \"VDDGFX_TVminHystersis = %d\\n\", pptable->VDDGFX_TVminHystersis);\n\tdev_info(smu->adev->dev, \"VDDSOC_TVminHystersis = %d\\n\", pptable->VDDSOC_TVminHystersis);\n\n\tdev_info(smu->adev->dev, \"DebugOverrides = 0x%x\\n\", pptable->DebugOverrides);\n\tdev_info(smu->adev->dev, \"ReservedEquation0{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation0.a,\n\t\t\tpptable->ReservedEquation0.b,\n\t\t\tpptable->ReservedEquation0.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation1{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation1.a,\n\t\t\tpptable->ReservedEquation1.b,\n\t\t\tpptable->ReservedEquation1.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation2{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation2.a,\n\t\t\tpptable->ReservedEquation2.b,\n\t\t\tpptable->ReservedEquation2.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation3{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation3.a,\n\t\t\tpptable->ReservedEquation3.b,\n\t\t\tpptable->ReservedEquation3.c);\n\n\tdev_info(smu->adev->dev, \"MinVoltageUlvGfx = %d\\n\", pptable->MinVoltageUlvGfx);\n\tdev_info(smu->adev->dev, \"PaddingUlv = %d\\n\", pptable->PaddingUlv);\n\n\tdev_info(smu->adev->dev, \"TotalPowerConfig = %d\\n\", pptable->TotalPowerConfig);\n\tdev_info(smu->adev->dev, \"TotalPowerSpare1 = %d\\n\", pptable->TotalPowerSpare1);\n\tdev_info(smu->adev->dev, \"TotalPowerSpare2 = %d\\n\", pptable->TotalPowerSpare2);\n\n\tdev_info(smu->adev->dev, \"PccThresholdLow = %d\\n\", pptable->PccThresholdLow);\n\tdev_info(smu->adev->dev, \"PccThresholdHigh = %d\\n\", pptable->PccThresholdHigh);\n\n\tdev_info(smu->adev->dev, \"Board Parameters:\\n\");\n\tdev_info(smu->adev->dev, \"MaxVoltageStepGfx = 0x%x\\n\", pptable->MaxVoltageStepGfx);\n\tdev_info(smu->adev->dev, \"MaxVoltageStepSoc = 0x%x\\n\", pptable->MaxVoltageStepSoc);\n\n\tdev_info(smu->adev->dev, \"VddGfxVrMapping = 0x%x\\n\", pptable->VddGfxVrMapping);\n\tdev_info(smu->adev->dev, \"VddSocVrMapping = 0x%x\\n\", pptable->VddSocVrMapping);\n\tdev_info(smu->adev->dev, \"VddMemVrMapping = 0x%x\\n\", pptable->VddMemVrMapping);\n\tdev_info(smu->adev->dev, \"BoardVrMapping = 0x%x\\n\", pptable->BoardVrMapping);\n\n\tdev_info(smu->adev->dev, \"GfxUlvPhaseSheddingMask = 0x%x\\n\", pptable->GfxUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"ExternalSensorPresent = 0x%x\\n\", pptable->ExternalSensorPresent);\n\n\tdev_info(smu->adev->dev, \"GfxMaxCurrent = 0x%x\\n\", pptable->GfxMaxCurrent);\n\tdev_info(smu->adev->dev, \"GfxOffset = 0x%x\\n\", pptable->GfxOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryGfx = 0x%x\\n\", pptable->Padding_TelemetryGfx);\n\n\tdev_info(smu->adev->dev, \"SocMaxCurrent = 0x%x\\n\", pptable->SocMaxCurrent);\n\tdev_info(smu->adev->dev, \"SocOffset = 0x%x\\n\", pptable->SocOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetrySoc = 0x%x\\n\", pptable->Padding_TelemetrySoc);\n\n\tdev_info(smu->adev->dev, \"MemMaxCurrent = 0x%x\\n\", pptable->MemMaxCurrent);\n\tdev_info(smu->adev->dev, \"MemOffset = 0x%x\\n\", pptable->MemOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryMem = 0x%x\\n\", pptable->Padding_TelemetryMem);\n\n\tdev_info(smu->adev->dev, \"BoardMaxCurrent = 0x%x\\n\", pptable->BoardMaxCurrent);\n\tdev_info(smu->adev->dev, \"BoardOffset = 0x%x\\n\", pptable->BoardOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryBoardInput = 0x%x\\n\", pptable->Padding_TelemetryBoardInput);\n\n\tdev_info(smu->adev->dev, \"VR0HotGpio = %d\\n\", pptable->VR0HotGpio);\n\tdev_info(smu->adev->dev, \"VR0HotPolarity = %d\\n\", pptable->VR0HotPolarity);\n\tdev_info(smu->adev->dev, \"VR1HotGpio = %d\\n\", pptable->VR1HotGpio);\n\tdev_info(smu->adev->dev, \"VR1HotPolarity = %d\\n\", pptable->VR1HotPolarity);\n\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadEnabled = %d\\n\", pptable->PllGfxclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadPercent = %d\\n\", pptable->PllGfxclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadFreq = %d\\n\", pptable->PllGfxclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"UclkSpreadEnabled = %d\\n\", pptable->UclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"UclkSpreadPercent = %d\\n\", pptable->UclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"UclkSpreadFreq = %d\\n\", pptable->UclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"FclkSpreadEnabled = %d\\n\", pptable->FclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"FclkSpreadPercent = %d\\n\", pptable->FclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"FclkSpreadFreq = %d\\n\", pptable->FclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"FllGfxclkSpreadEnabled = %d\\n\", pptable->FllGfxclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"FllGfxclkSpreadPercent = %d\\n\", pptable->FllGfxclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"FllGfxclkSpreadFreq = %d\\n\", pptable->FllGfxclkSpreadFreq);\n\n\tfor (i = 0; i < NUM_I2C_CONTROLLERS; i++) {\n\t\tdev_info(smu->adev->dev, \"I2cControllers[%d]:\\n\", i);\n\t\tdev_info(smu->adev->dev, \"                   .Enabled = %d\\n\",\n\t\t\t\tpptable->I2cControllers[i].Enabled);\n\t\tdev_info(smu->adev->dev, \"                   .SlaveAddress = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].SlaveAddress);\n\t\tdev_info(smu->adev->dev, \"                   .ControllerPort = %d\\n\",\n\t\t\t\tpptable->I2cControllers[i].ControllerPort);\n\t\tdev_info(smu->adev->dev, \"                   .ControllerName = %d\\n\",\n\t\t\t\tpptable->I2cControllers[i].ControllerName);\n\t\tdev_info(smu->adev->dev, \"                   .ThermalThrottler = %d\\n\",\n\t\t\t\tpptable->I2cControllers[i].ThermalThrotter);\n\t\tdev_info(smu->adev->dev, \"                   .I2cProtocol = %d\\n\",\n\t\t\t\tpptable->I2cControllers[i].I2cProtocol);\n\t\tdev_info(smu->adev->dev, \"                   .Speed = %d\\n\",\n\t\t\t\tpptable->I2cControllers[i].Speed);\n\t}\n\n\tdev_info(smu->adev->dev, \"MemoryChannelEnabled = %d\\n\", pptable->MemoryChannelEnabled);\n\tdev_info(smu->adev->dev, \"DramBitWidth = %d\\n\", pptable->DramBitWidth);\n\n\tdev_info(smu->adev->dev, \"TotalBoardPower = %d\\n\", pptable->TotalBoardPower);\n\n\tdev_info(smu->adev->dev, \"XgmiLinkSpeed\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->XgmiLinkSpeed[i]);\n\tdev_info(smu->adev->dev, \"XgmiLinkWidth\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->XgmiLinkWidth[i]);\n\tdev_info(smu->adev->dev, \"XgmiFclkFreq\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->XgmiFclkFreq[i]);\n\tdev_info(smu->adev->dev, \"XgmiSocVoltage\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = %d\\n\", i, pptable->XgmiSocVoltage[i]);\n\n}\n\nstatic bool arcturus_is_dpm_running(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int arcturus_dpm_set_vcn_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_DPM_BIT)) {\n\t\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_VCN_DPM_BIT, 1);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"[EnableVCNDPM] failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_DPM_BIT)) {\n\t\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_VCN_DPM_BIT, 0);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"[DisableVCNDPM] failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int arcturus_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t     struct i2c_msg *msg, int num_msgs)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tSwI2cRequest_t *req, *res = (SwI2cRequest_t *)table->cpu_addr;\n\tint i, j, r, c;\n\tu16 dir;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn -EBUSY;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->I2CcontrollerPort = smu_i2c->port;\n\treq->I2CSpeed = I2C_SPEED_FAST_400K;\n\treq->SlaveAddress = msg[0].addr << 1;  \n\tdir = msg[0].flags & I2C_M_RD;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &req->SwI2cCmds[c];\n\n\t\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\t\t \n\t\t\t\tcmd->Cmd = I2C_CMD_WRITE;\n\t\t\t\tcmd->RegisterAddr = msg[i].buf[j];\n\t\t\t}\n\n\t\t\tif ((dir ^ msg[i].flags) & I2C_M_RD) {\n\t\t\t\t \n\t\t\t\tdir = msg[i].flags & I2C_M_RD;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_RESTART_MASK;\n\t\t\t}\n\n\t\t\treq->NumCmds++;\n\n\t\t\t \n\t\t\tif ((j == msg[i].len - 1) &&\n\t\t\t    ((i == num_msgs - 1) || (msg[i].flags & I2C_M_STOP))) {\n\t\t\t\tcmd->CmdConfig &= ~CMDCONFIG_RESTART_MASK;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_STOP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&adev->pm.mutex);\n\tr = smu_cmn_update_table(smu, SMU_TABLE_I2C_COMMANDS, 0, req, true);\n\tif (r)\n\t\tgoto fail;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\tc += msg[i].len;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &res->SwI2cCmds[c];\n\n\t\t\tmsg[i].buf[j] = cmd->Data;\n\t\t}\n\t}\n\tr = num_msgs;\nfail:\n\tmutex_unlock(&adev->pm.mutex);\n\tkfree(req);\n\treturn r;\n}\n\nstatic u32 arcturus_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\n\nstatic const struct i2c_algorithm arcturus_i2c_algo = {\n\t.master_xfer = arcturus_i2c_xfer,\n\t.functionality = arcturus_i2c_func,\n};\n\n\nstatic const struct i2c_adapter_quirks arcturus_i2c_control_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_SAME_ADDR | I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len  = MAX_SW_I2C_COMMANDS,\n\t.max_write_len = MAX_SW_I2C_COMMANDS,\n\t.max_comb_1st_msg_len = 2,\n\t.max_comb_2nd_msg_len = MAX_SW_I2C_COMMANDS - 2,\n};\n\nstatic int arcturus_i2c_control_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint res, i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\tsmu_i2c->adev = adev;\n\t\tsmu_i2c->port = i;\n\t\tmutex_init(&smu_i2c->mutex);\n\t\tcontrol->owner = THIS_MODULE;\n\t\tcontrol->class = I2C_CLASS_HWMON;\n\t\tcontrol->dev.parent = &adev->pdev->dev;\n\t\tcontrol->algo = &arcturus_i2c_algo;\n\t\tcontrol->quirks = &arcturus_i2c_control_quirks;\n\t\tsnprintf(control->name, sizeof(control->name), \"AMDGPU SMU %d\", i);\n\t\ti2c_set_adapdata(control, smu_i2c);\n\n\t\tres = i2c_add_adapter(control);\n\t\tif (res) {\n\t\t\tDRM_ERROR(\"Failed to register hw i2c, err: %d\\n\", res);\n\t\t\tgoto Out_err;\n\t\t}\n\t}\n\n\tadev->pm.ras_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\tadev->pm.fru_eeprom_i2c_bus = &adev->pm.smu_i2c[1].adapter;\n\n\treturn 0;\nOut_err:\n\tfor ( ; i >= 0; i--) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\treturn res;\n}\n\nstatic void arcturus_i2c_control_fini(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\tadev->pm.ras_eeprom_i2c_bus = NULL;\n\tadev->pm.fru_eeprom_i2c_bus = NULL;\n}\n\nstatic void arcturus_get_unique_id(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t top32 = 0, bottom32 = 0, smu_version;\n\tuint64_t id;\n\n\tif (smu_cmn_get_smc_version(smu, NULL, &smu_version)) {\n\t\tdev_warn(adev->dev, \"Failed to get smu version, cannot get unique_id or serial_number\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (smu_version < 0x361700) {\n\t\tdev_warn(adev->dev, \"ReadSerial is only supported by PMFW 54.23.0 and onwards\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsmu_cmn_send_smc_msg(smu, SMU_MSG_ReadSerialNumTop32, &top32);\n\tsmu_cmn_send_smc_msg(smu, SMU_MSG_ReadSerialNumBottom32, &bottom32);\n\n\tid = ((uint64_t)bottom32 << 32) | top32;\n\tadev->unique_id = id;\n\t \n\tsprintf(adev->serial, \"%llx\", id);\n}\n\nstatic int arcturus_set_df_cstate(struct smu_context *smu,\n\t\t\t\t  enum pp_df_cstate state)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t smu_version;\n\tint ret;\n\n\t \n\tif (amdgpu_in_reset(adev) || adev->in_suspend)\n\t\treturn 0;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (smu_version < 0x360F00) {\n\t\tdev_err(smu->adev->dev, \"DFCstateControl is only supported by PMFW 54.15.0 and onwards\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DFCstateControl, state, NULL);\n}\n\nstatic int arcturus_allow_xgmi_power_down(struct smu_context *smu, bool en)\n{\n\tuint32_t smu_version;\n\tint ret;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (smu_version < 0x00361700) {\n\t\tdev_err(smu->adev->dev, \"XGMI power down control is only supported by PMFW 54.23.0 and onwards\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (en)\n\t\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t   SMU_MSG_GmiPwrDnControl,\n\t\t\t\t\t\t   1,\n\t\t\t\t\t\t   NULL);\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t   SMU_MSG_GmiPwrDnControl,\n\t\t\t\t\t   0,\n\t\t\t\t\t   NULL);\n}\n\nstatic const struct throttling_logging_label {\n\tuint32_t feature_mask;\n\tconst char *label;\n} logging_label[] = {\n\t{(1U << THROTTLER_TEMP_HOTSPOT_BIT), \"GPU\"},\n\t{(1U << THROTTLER_TEMP_MEM_BIT), \"HBM\"},\n\t{(1U << THROTTLER_TEMP_VR_GFX_BIT), \"VR of GFX rail\"},\n\t{(1U << THROTTLER_TEMP_VR_MEM_BIT), \"VR of HBM rail\"},\n\t{(1U << THROTTLER_TEMP_VR_SOC_BIT), \"VR of SOC rail\"},\n\t{(1U << THROTTLER_VRHOT0_BIT), \"VR0 HOT\"},\n\t{(1U << THROTTLER_VRHOT1_BIT), \"VR1 HOT\"},\n};\nstatic void arcturus_log_thermal_throttling_event(struct smu_context *smu)\n{\n\tint ret;\n\tint throttler_idx, throtting_events = 0, buf_idx = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t throttler_status;\n\tchar log_buf[256];\n\n\tret = arcturus_get_smu_metrics_data(smu,\n\t\t\t\t\t    METRICS_THROTTLER_STATUS,\n\t\t\t\t\t    &throttler_status);\n\tif (ret)\n\t\treturn;\n\n\tmemset(log_buf, 0, sizeof(log_buf));\n\tfor (throttler_idx = 0; throttler_idx < ARRAY_SIZE(logging_label);\n\t     throttler_idx++) {\n\t\tif (throttler_status & logging_label[throttler_idx].feature_mask) {\n\t\t\tthrotting_events++;\n\t\t\tbuf_idx += snprintf(log_buf + buf_idx,\n\t\t\t\t\t    sizeof(log_buf) - buf_idx,\n\t\t\t\t\t    \"%s%s\",\n\t\t\t\t\t    throtting_events > 1 ? \" and \" : \"\",\n\t\t\t\t\t    logging_label[throttler_idx].label);\n\t\t\tif (buf_idx >= sizeof(log_buf)) {\n\t\t\t\tdev_err(adev->dev, \"buffer overflow!\\n\");\n\t\t\t\tlog_buf[sizeof(log_buf) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_warn(adev->dev, \"WARN: GPU thermal throttling temperature reached, expect performance decrease. %s.\\n\",\n\t\t\tlog_buf);\n\tkgd2kfd_smi_event_throttle(smu->adev->kfd.dev,\n\t\tsmu_cmn_get_indep_throttler_status(throttler_status,\n\t\t\t\t\t\t   arcturus_throttler_map));\n}\n\nstatic uint16_t arcturus_get_current_pcie_link_speed(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t esm_ctrl;\n\n\t \n\tesm_ctrl = RREG32_PCIE(smnPCIE_ESM_CTRL);\n\tif ((esm_ctrl >> 15) & 0x1FFFF)\n\t\treturn (uint16_t)(((esm_ctrl >> 8) & 0x3F) + 128);\n\n\treturn smu_v11_0_get_current_pcie_link_speed(smu);\n}\n\nstatic ssize_t arcturus_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\tvoid **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\t&metrics,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = metrics.TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;\n\tgpu_metrics->temperature_mem = metrics.TemperatureHBM;\n\tgpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = metrics.TemperatureVrMem;\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics.AverageUclkActivity;\n\tgpu_metrics->average_mm_activity = metrics.VcnActivityPercentage;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\tgpu_metrics->energy_accumulator = metrics.EnergyAccumulator;\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequency;\n\tgpu_metrics->average_vclk0_frequency = metrics.AverageVclkFrequency;\n\tgpu_metrics->average_dclk0_frequency = metrics.AverageDclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];\n\tgpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   arcturus_throttler_map);\n\n\tgpu_metrics->current_fan_speed = metrics.CurrFanSpeed;\n\n\tgpu_metrics->pcie_link_width =\n\t\t\tsmu_v11_0_get_current_pcie_link_width(smu);\n\tgpu_metrics->pcie_link_speed =\n\t\t\tarcturus_get_current_pcie_link_speed(smu);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic const struct pptable_funcs arcturus_ppt_funcs = {\n\t \n\t.get_allowed_feature_mask = arcturus_get_allowed_feature_mask,\n\t \n\t.run_btc = arcturus_run_btc,\n\t \n\t.set_default_dpm_table = arcturus_set_default_dpm_table,\n\t.populate_umd_state_clk = arcturus_populate_umd_state_clk,\n\t.get_thermal_temperature_range = arcturus_get_thermal_temperature_range,\n\t.print_clk_levels = arcturus_print_clk_levels,\n\t.force_clk_levels = arcturus_force_clk_levels,\n\t.read_sensor = arcturus_read_sensor,\n\t.get_fan_speed_pwm = arcturus_get_fan_speed_pwm,\n\t.get_fan_speed_rpm = arcturus_get_fan_speed_rpm,\n\t.get_power_profile_mode = arcturus_get_power_profile_mode,\n\t.set_power_profile_mode = arcturus_set_power_profile_mode,\n\t.set_performance_level = arcturus_set_performance_level,\n\t \n\t.dump_pptable = arcturus_dump_pptable,\n\t.get_power_limit = arcturus_get_power_limit,\n\t.is_dpm_running = arcturus_is_dpm_running,\n\t.dpm_set_vcn_enable = arcturus_dpm_set_vcn_enable,\n\t.i2c_init = arcturus_i2c_control_init,\n\t.i2c_fini = arcturus_i2c_control_fini,\n\t.get_unique_id = arcturus_get_unique_id,\n\t.init_microcode = smu_v11_0_init_microcode,\n\t.load_microcode = smu_v11_0_load_microcode,\n\t.fini_microcode = smu_v11_0_fini_microcode,\n\t.init_smc_tables = arcturus_init_smc_tables,\n\t.fini_smc_tables = smu_v11_0_fini_smc_tables,\n\t.init_power = smu_v11_0_init_power,\n\t.fini_power = smu_v11_0_fini_power,\n\t.check_fw_status = smu_v11_0_check_fw_status,\n\t \n\t.setup_pptable = arcturus_setup_pptable,\n\t.get_vbios_bootup_values = smu_v11_0_get_vbios_bootup_values,\n\t.check_fw_version = smu_v11_0_check_fw_version,\n\t.write_pptable = smu_cmn_write_pptable,\n\t.set_driver_table_location = smu_v11_0_set_driver_table_location,\n\t.set_tool_table_location = smu_v11_0_set_tool_table_location,\n\t.notify_memory_pool_location = smu_v11_0_notify_memory_pool_location,\n\t.system_features_control = smu_v11_0_system_features_control,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.init_display_count = NULL,\n\t.set_allowed_mask = smu_v11_0_set_allowed_mask,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.disable_all_features_with_exception = smu_cmn_disable_all_features_with_exception,\n\t.notify_display_change = NULL,\n\t.set_power_limit = smu_v11_0_set_power_limit,\n\t.init_max_sustainable_clocks = smu_v11_0_init_max_sustainable_clocks,\n\t.enable_thermal_alert = smu_v11_0_enable_thermal_alert,\n\t.disable_thermal_alert = smu_v11_0_disable_thermal_alert,\n\t.set_min_dcef_deep_sleep = NULL,\n\t.display_clock_voltage_request = smu_v11_0_display_clock_voltage_request,\n\t.get_fan_control_mode = smu_v11_0_get_fan_control_mode,\n\t.set_fan_control_mode = smu_v11_0_set_fan_control_mode,\n\t.set_fan_speed_pwm = arcturus_set_fan_speed_pwm,\n\t.set_fan_speed_rpm = arcturus_set_fan_speed_rpm,\n\t.set_xgmi_pstate = smu_v11_0_set_xgmi_pstate,\n\t.gfx_off_control = smu_v11_0_gfx_off_control,\n\t.register_irq_handler = smu_v11_0_register_irq_handler,\n\t.set_azalia_d3_pme = smu_v11_0_set_azalia_d3_pme,\n\t.get_max_sustainable_clocks_by_dc = smu_v11_0_get_max_sustainable_clocks_by_dc,\n\t.baco_is_support = smu_v11_0_baco_is_support,\n\t.baco_get_state = smu_v11_0_baco_get_state,\n\t.baco_set_state = smu_v11_0_baco_set_state,\n\t.baco_enter = smu_v11_0_baco_enter,\n\t.baco_exit = smu_v11_0_baco_exit,\n\t.get_dpm_ultimate_freq = smu_v11_0_get_dpm_ultimate_freq,\n\t.set_soft_freq_limited_range = smu_v11_0_set_soft_freq_limited_range,\n\t.set_df_cstate = arcturus_set_df_cstate,\n\t.allow_xgmi_power_down = arcturus_allow_xgmi_power_down,\n\t.log_thermal_throttling_event = arcturus_log_thermal_throttling_event,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_pp_feature_mask = smu_cmn_set_pp_feature_mask,\n\t.get_gpu_metrics = arcturus_get_gpu_metrics,\n\t.gfx_ulv_control = smu_v11_0_gfx_ulv_control,\n\t.deep_sleep_control = smu_v11_0_deep_sleep_control,\n\t.get_fan_parameters = arcturus_get_fan_parameters,\n\t.interrupt_work = smu_v11_0_interrupt_work,\n\t.smu_handle_passthrough_sbr = smu_v11_0_handle_passthrough_sbr,\n\t.set_mp1_state = smu_cmn_set_mp1_state,\n};\n\nvoid arcturus_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &arcturus_ppt_funcs;\n\tsmu->message_map = arcturus_message_map;\n\tsmu->clock_map = arcturus_clk_map;\n\tsmu->feature_map = arcturus_feature_mask_map;\n\tsmu->table_map = arcturus_table_map;\n\tsmu->pwr_src_map = arcturus_pwr_src_map;\n\tsmu->workload_map = arcturus_workload_map;\n\tsmu_v11_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}