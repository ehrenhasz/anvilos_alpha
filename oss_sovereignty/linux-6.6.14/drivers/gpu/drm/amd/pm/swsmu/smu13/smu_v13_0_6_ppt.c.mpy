{
  "module_name": "smu_v13_0_6_ppt.c",
  "hash_id": "209bf90713e31e2ad83131b40704dc1fecbdee4432cbfa32be04ecd8fe040d95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu13/smu_v13_0_6_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include <linux/firmware.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v13_0_6_pmfw.h\"\n#include \"smu13_driver_if_v13_0_6.h\"\n#include \"smu_v13_0_6_ppsmc.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"power_state.h\"\n#include \"smu_v13_0.h\"\n#include \"smu_v13_0_6_ppt.h\"\n#include \"nbio/nbio_7_4_offset.h\"\n#include \"nbio/nbio_7_4_sh_mask.h\"\n#include \"thm/thm_11_0_2_offset.h\"\n#include \"thm/thm_11_0_2_sh_mask.h\"\n#include \"amdgpu_xgmi.h\"\n#include <linux/pci.h>\n#include \"amdgpu_ras.h\"\n#include \"smu_cmn.h\"\n#include \"mp/mp_13_0_6_offset.h\"\n#include \"mp/mp_13_0_6_sh_mask.h\"\n\n#undef MP1_Public\n#undef smnMP1_FIRMWARE_FLAGS\n\n \n#define MP1_Public 0x03b00000\n#define smnMP1_FIRMWARE_FLAGS 0x3010028\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define to_amdgpu_device(x) (container_of(x, struct amdgpu_device, pm.smu_i2c))\n\n#define SMU_13_0_6_FEA_MAP(smu_feature, smu_13_0_6_feature)                    \\\n\t[smu_feature] = { 1, (smu_13_0_6_feature) }\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE                                                        \\\n\t(FEATURE_MASK(FEATURE_DATA_CALCULATION) |                              \\\n\t FEATURE_MASK(FEATURE_DPM_GFXCLK) | FEATURE_MASK(FEATURE_DPM_UCLK) |   \\\n\t FEATURE_MASK(FEATURE_DPM_SOCCLK) | FEATURE_MASK(FEATURE_DPM_FCLK) |   \\\n\t FEATURE_MASK(FEATURE_DPM_LCLK) | FEATURE_MASK(FEATURE_DPM_XGMI) |     \\\n\t FEATURE_MASK(FEATURE_DPM_VCN))\n\n \n#define EPSILON 1\n\n#define smnPCIE_ESM_CTRL 0x93D0\n#define smnPCIE_LC_LINK_WIDTH_CNTL 0x1a340288\n#define PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK 0x00000070L\n#define PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT 0x4\n#define MAX_LINK_WIDTH 6\n\n#define smnPCIE_LC_SPEED_CNTL                   0x1a340290\n#define PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK 0xE0\n#define PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT 0x5\n#define LINK_SPEED_MAX\t\t\t\t4\n\nstatic const struct cmn2asic_msg_mapping smu_v13_0_6_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,\t\t\t     PPSMC_MSG_TestMessage,\t\t\t0),\n\tMSG_MAP(GetSmuVersion,\t\t\t     PPSMC_MSG_GetSmuVersion,\t\t\t1),\n\tMSG_MAP(GetDriverIfVersion,\t\t     PPSMC_MSG_GetDriverIfVersion,\t\t1),\n\tMSG_MAP(EnableAllSmuFeatures,\t\t     PPSMC_MSG_EnableAllSmuFeatures,\t\t0),\n\tMSG_MAP(DisableAllSmuFeatures,\t\t     PPSMC_MSG_DisableAllSmuFeatures,\t\t0),\n\tMSG_MAP(RequestI2cTransaction,\t\t     PPSMC_MSG_RequestI2cTransaction,\t\t0),\n\tMSG_MAP(GetMetricsTable,\t\t     PPSMC_MSG_GetMetricsTable,\t\t\t1),\n\tMSG_MAP(GetEnabledSmuFeaturesHigh,\t     PPSMC_MSG_GetEnabledSmuFeaturesHigh,\t1),\n\tMSG_MAP(GetEnabledSmuFeaturesLow,\t     PPSMC_MSG_GetEnabledSmuFeaturesLow,\t1),\n\tMSG_MAP(SetDriverDramAddrHigh,\t\t     PPSMC_MSG_SetDriverDramAddrHigh,\t\t1),\n\tMSG_MAP(SetDriverDramAddrLow,\t\t     PPSMC_MSG_SetDriverDramAddrLow,\t\t1),\n\tMSG_MAP(SetToolsDramAddrHigh,\t\t     PPSMC_MSG_SetToolsDramAddrHigh,\t\t0),\n\tMSG_MAP(SetToolsDramAddrLow,\t\t     PPSMC_MSG_SetToolsDramAddrLow,\t\t0),\n\tMSG_MAP(SetSoftMinByFreq,\t\t     PPSMC_MSG_SetSoftMinByFreq,\t\t0),\n\tMSG_MAP(SetSoftMaxByFreq,\t\t     PPSMC_MSG_SetSoftMaxByFreq,\t\t0),\n\tMSG_MAP(GetMinDpmFreq,\t\t\t     PPSMC_MSG_GetMinDpmFreq,\t\t\t1),\n\tMSG_MAP(GetMaxDpmFreq,\t\t\t     PPSMC_MSG_GetMaxDpmFreq,\t\t\t1),\n\tMSG_MAP(GetDpmFreqByIndex,\t\t     PPSMC_MSG_GetDpmFreqByIndex,\t\t1),\n\tMSG_MAP(SetPptLimit,\t\t\t     PPSMC_MSG_SetPptLimit,\t\t\t0),\n\tMSG_MAP(GetPptLimit,\t\t\t     PPSMC_MSG_GetPptLimit,\t\t\t1),\n\tMSG_MAP(GfxDeviceDriverReset,\t\t     PPSMC_MSG_GfxDriverReset,\t\t\t0),\n\tMSG_MAP(DramLogSetDramAddrHigh,\t\t     PPSMC_MSG_DramLogSetDramAddrHigh,\t\t0),\n\tMSG_MAP(DramLogSetDramAddrLow,\t\t     PPSMC_MSG_DramLogSetDramAddrLow,\t\t0),\n\tMSG_MAP(DramLogSetDramSize,\t\t     PPSMC_MSG_DramLogSetDramSize,\t\t0),\n\tMSG_MAP(GetDebugData,\t\t\t     PPSMC_MSG_GetDebugData,\t\t\t0),\n\tMSG_MAP(SetNumBadHbmPagesRetired,\t     PPSMC_MSG_SetNumBadHbmPagesRetired,\t0),\n\tMSG_MAP(DFCstateControl,\t\t     PPSMC_MSG_DFCstateControl,\t\t\t0),\n\tMSG_MAP(GetGmiPwrDnHyst,\t\t     PPSMC_MSG_GetGmiPwrDnHyst,\t\t\t0),\n\tMSG_MAP(SetGmiPwrDnHyst,\t\t     PPSMC_MSG_SetGmiPwrDnHyst,\t\t\t0),\n\tMSG_MAP(GmiPwrDnControl,\t\t     PPSMC_MSG_GmiPwrDnControl,\t\t\t0),\n\tMSG_MAP(EnterGfxoff,\t\t\t     PPSMC_MSG_EnterGfxoff,\t\t\t0),\n\tMSG_MAP(ExitGfxoff,\t\t\t     PPSMC_MSG_ExitGfxoff,\t\t\t0),\n\tMSG_MAP(EnableDeterminism,\t\t     PPSMC_MSG_EnableDeterminism,\t\t0),\n\tMSG_MAP(DisableDeterminism,\t\t     PPSMC_MSG_DisableDeterminism,\t\t0),\n\tMSG_MAP(GfxDriverResetRecovery,\t\t     PPSMC_MSG_GfxDriverResetRecovery,\t\t0),\n\tMSG_MAP(GetMinGfxclkFrequency,               PPSMC_MSG_GetMinGfxDpmFreq,                1),\n\tMSG_MAP(GetMaxGfxclkFrequency,               PPSMC_MSG_GetMaxGfxDpmFreq,                1),\n\tMSG_MAP(SetSoftMinGfxclk,                    PPSMC_MSG_SetSoftMinGfxClk,                0),\n\tMSG_MAP(SetSoftMaxGfxClk,                    PPSMC_MSG_SetSoftMaxGfxClk,                0),\n\tMSG_MAP(PrepareMp1ForUnload,                 PPSMC_MSG_PrepareForDriverUnload,          0),\n\tMSG_MAP(GetCTFLimit,                         PPSMC_MSG_GetCTFLimit,                     0),\n};\n\nstatic const struct cmn2asic_mapping smu_v13_0_6_clk_map[SMU_CLK_COUNT] = {\n\tCLK_MAP(SOCCLK, PPCLK_SOCCLK),\n\tCLK_MAP(FCLK, PPCLK_FCLK),\n\tCLK_MAP(UCLK, PPCLK_UCLK),\n\tCLK_MAP(MCLK, PPCLK_UCLK),\n\tCLK_MAP(DCLK, PPCLK_DCLK),\n\tCLK_MAP(VCLK, PPCLK_VCLK),\n\tCLK_MAP(LCLK, PPCLK_LCLK),\n};\n\nstatic const struct cmn2asic_mapping smu_v13_0_6_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DATA_CALCULATIONS_BIT, \t\tFEATURE_DATA_CALCULATION),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_GFXCLK_BIT, \t\t\tFEATURE_DPM_GFXCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_UCLK_BIT, \t\t\tFEATURE_DPM_UCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_SOCCLK_BIT, \t\t\tFEATURE_DPM_SOCCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_FCLK_BIT, \t\t\tFEATURE_DPM_FCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_LCLK_BIT, \t\t\tFEATURE_DPM_LCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_VCLK_BIT,\t\t\tFEATURE_DPM_VCN),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_DCLK_BIT,\t\t\tFEATURE_DPM_VCN),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DPM_XGMI_BIT, \t\t\tFEATURE_DPM_XGMI),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DS_GFXCLK_BIT, \t\t\tFEATURE_DS_GFXCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DS_SOCCLK_BIT, \t\t\tFEATURE_DS_SOCCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DS_LCLK_BIT, \t\t\tFEATURE_DS_LCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DS_FCLK_BIT, \t\t\tFEATURE_DS_FCLK),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_VCN_DPM_BIT, \t\t\tFEATURE_DPM_VCN),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_PPT_BIT, \t\t\tFEATURE_PPT),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_TDC_BIT, \t\t\tFEATURE_TDC),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_APCC_DFLL_BIT, \t\t\tFEATURE_APCC_DFLL),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_MP1_CG_BIT, \t\t\tFEATURE_SMU_CG),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_GFXOFF_BIT, \t\t\tFEATURE_GFXOFF),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_FW_CTF_BIT, \t\t\tFEATURE_FW_CTF),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_THERMAL_BIT, \t\t\tFEATURE_THERMAL),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_XGMI_PER_LINK_PWR_DWN_BIT,\tFEATURE_XGMI_PER_LINK_PWR_DOWN),\n\tSMU_13_0_6_FEA_MAP(SMU_FEATURE_DF_CSTATE_BIT, \t\t\tFEATURE_DF_CSTATE),\n};\n\n#define TABLE_PMSTATUSLOG             0\n#define TABLE_SMU_METRICS             1\n#define TABLE_I2C_COMMANDS            2\n#define TABLE_COUNT                   3\n\nstatic const struct cmn2asic_mapping smu_v13_0_6_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP(PMSTATUSLOG),\n\tTAB_MAP(SMU_METRICS),\n\tTAB_MAP(I2C_COMMANDS),\n};\n\nstatic const uint8_t smu_v13_0_6_throttler_map[] = {\n\t[THROTTLER_PPT_BIT]\t\t= (SMU_THROTTLER_PPT0_BIT),\n\t[THROTTLER_THERMAL_SOCKET_BIT]\t= (SMU_THROTTLER_TEMP_GPU_BIT),\n\t[THROTTLER_THERMAL_HBM_BIT]\t= (SMU_THROTTLER_TEMP_MEM_BIT),\n\t[THROTTLER_THERMAL_VR_BIT]\t= (SMU_THROTTLER_TEMP_VR_GFX_BIT),\n\t[THROTTLER_PROCHOT_BIT]\t\t= (SMU_THROTTLER_PROCHOT_GFX_BIT),\n};\n\nstruct PPTable_t {\n\tuint32_t MaxSocketPowerLimit;\n\tuint32_t MaxGfxclkFrequency;\n\tuint32_t MinGfxclkFrequency;\n\tuint32_t FclkFrequencyTable[4];\n\tuint32_t UclkFrequencyTable[4];\n\tuint32_t SocclkFrequencyTable[4];\n\tuint32_t VclkFrequencyTable[4];\n\tuint32_t DclkFrequencyTable[4];\n\tuint32_t LclkFrequencyTable[4];\n\tuint32_t MaxLclkDpmRange;\n\tuint32_t MinLclkDpmRange;\n\tuint64_t PublicSerialNumber_AID;\n\tbool Init;\n};\n\n#define SMUQ10_TO_UINT(x) ((x) >> 10)\n\nstruct smu_v13_0_6_dpm_map {\n\tenum smu_clk_type clk_type;\n\tuint32_t feature_num;\n\tstruct smu_13_0_dpm_table *dpm_table;\n\tuint32_t *freq_table;\n};\n\nstatic int smu_v13_0_6_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (!(adev->flags & AMD_IS_APU))\n\t\tSMU_TABLE_INIT(tables, SMU_TABLE_PMSTATUSLOG, SMU13_TOOL_SIZE,\n\t\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(MetricsTable_t),\n\t\t       PAGE_SIZE,\n\t\t       AMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT);\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_I2C_COMMANDS, sizeof(SwI2cRequest_t),\n\t\t       PAGE_SIZE,\n\t\t       AMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT);\n\n\tsmu_table->metrics_table = kzalloc(sizeof(MetricsTable_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\treturn -ENOMEM;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v1_3);\n\tsmu_table->gpu_metrics_table =\n\t\tkzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table) {\n\t\tkfree(smu_table->metrics_table);\n\t\treturn -ENOMEM;\n\t}\n\n\tsmu_table->driver_pptable =\n\t\tkzalloc(sizeof(struct PPTable_t), GFP_KERNEL);\n\tif (!smu_table->driver_pptable) {\n\t\tkfree(smu_table->metrics_table);\n\t\tkfree(smu_table->gpu_metrics_table);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_allocate_dpm_context(struct smu_context *smu)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tsmu_dpm->dpm_context =\n\t\tkzalloc(sizeof(struct smu_13_0_dpm_context), GFP_KERNEL);\n\tif (!smu_dpm->dpm_context)\n\t\treturn -ENOMEM;\n\tsmu_dpm->dpm_context_size = sizeof(struct smu_13_0_dpm_context);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_init_smc_tables(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v13_0_6_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_v13_0_6_allocate_dpm_context(smu);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_allowed_feature_mask(struct smu_context *smu,\n\t\t\t\t\t\tuint32_t *feature_mask,\n\t\t\t\t\t\tuint32_t num)\n{\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\t \n\tmemset(feature_mask, 0xFF, sizeof(uint32_t) * num);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_get_metrics_table(struct smu_context *smu,\n\t\t\t\t\t void *metrics_table, bool bypass_cache)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tuint32_t table_size = smu_table->tables[SMU_TABLE_SMU_METRICS].size;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tint ret;\n\n\tif (bypass_cache || !smu_table->metrics_time ||\n\t    time_after(jiffies,\n\t\t       smu_table->metrics_time + msecs_to_jiffies(1))) {\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetMetricsTable, NULL);\n\t\tif (ret) {\n\t\t\tdev_info(smu->adev->dev,\n\t\t\t\t \"Failed to export SMU metrics table!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tamdgpu_asic_invalidate_hdp(smu->adev, NULL);\n\t\tmemcpy(smu_table->metrics_table, table->cpu_addr, table_size);\n\n\t\tsmu_table->metrics_time = jiffies;\n\t}\n\n\tif (metrics_table)\n\t\tmemcpy(metrics_table, smu_table->metrics_table, table_size);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_setup_driver_pptable(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tMetricsTable_t *metrics = (MetricsTable_t *)smu_table->metrics_table;\n\tstruct PPTable_t *pptable =\n\t\t(struct PPTable_t *)smu_table->driver_pptable;\n\tint ret, i, retry = 100;\n\n\t \n\tif (!pptable->Init) {\n\t\twhile (--retry) {\n\t\t\tret = smu_v13_0_6_get_metrics_table(smu, NULL, true);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (metrics->AccumulationCounter)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(1000, 1100);\n\t\t}\n\n\t\tif (!retry)\n\t\t\treturn -ETIME;\n\n\t\tpptable->MaxSocketPowerLimit =\n\t\t\tSMUQ10_TO_UINT(metrics->MaxSocketPowerLimit);\n\t\tpptable->MaxGfxclkFrequency =\n\t\t\tSMUQ10_TO_UINT(metrics->MaxGfxclkFrequency);\n\t\tpptable->MinGfxclkFrequency =\n\t\t\tSMUQ10_TO_UINT(metrics->MinGfxclkFrequency);\n\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tpptable->FclkFrequencyTable[i] =\n\t\t\t\tSMUQ10_TO_UINT(metrics->FclkFrequencyTable[i]);\n\t\t\tpptable->UclkFrequencyTable[i] =\n\t\t\t\tSMUQ10_TO_UINT(metrics->UclkFrequencyTable[i]);\n\t\t\tpptable->SocclkFrequencyTable[i] = SMUQ10_TO_UINT(\n\t\t\t\tmetrics->SocclkFrequencyTable[i]);\n\t\t\tpptable->VclkFrequencyTable[i] =\n\t\t\t\tSMUQ10_TO_UINT(metrics->VclkFrequencyTable[i]);\n\t\t\tpptable->DclkFrequencyTable[i] =\n\t\t\t\tSMUQ10_TO_UINT(metrics->DclkFrequencyTable[i]);\n\t\t\tpptable->LclkFrequencyTable[i] =\n\t\t\t\tSMUQ10_TO_UINT(metrics->LclkFrequencyTable[i]);\n\t\t}\n\n\t\t \n\t\tpptable->PublicSerialNumber_AID = metrics->PublicSerialNumber_AID[0];\n\n\t\tpptable->Init = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t     uint32_t *min, uint32_t *max)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct PPTable_t *pptable =\n\t\t(struct PPTable_t *)smu_table->driver_pptable;\n\tuint32_t clock_limit = 0, param;\n\tint ret = 0, clk_id = 0;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tif (pptable->Init)\n\t\t\t\tclock_limit = pptable->UclkFrequencyTable[0];\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tif (pptable->Init)\n\t\t\t\tclock_limit = pptable->MinGfxclkFrequency;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tif (pptable->Init)\n\t\t\t\tclock_limit = pptable->SocclkFrequencyTable[0];\n\t\t\tbreak;\n\t\tcase SMU_FCLK:\n\t\t\tif (pptable->Init)\n\t\t\t\tclock_limit = pptable->FclkFrequencyTable[0];\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\t\tif (pptable->Init)\n\t\t\t\tclock_limit = pptable->VclkFrequencyTable[0];\n\t\t\tbreak;\n\t\tcase SMU_DCLK:\n\t\t\tif (pptable->Init)\n\t\t\t\tclock_limit = pptable->DclkFrequencyTable[0];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (min)\n\t\t\t*min = clock_limit;\n\n\t\tif (max)\n\t\t\t*max = clock_limit;\n\n\t\treturn 0;\n\t}\n\n\tif (!(clk_type == SMU_GFXCLK || clk_type == SMU_SCLK)) {\n\t\tclk_id = smu_cmn_to_asic_specific_index(\n\t\t\tsmu, CMN2ASIC_MAPPING_CLK, clk_type);\n\t\tif (clk_id < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\t\tparam = (clk_id & 0xffff) << 16;\n\t}\n\n\tif (max) {\n\t\tif (clk_type == SMU_GFXCLK || clk_type == SMU_SCLK)\n\t\t\tret = smu_cmn_send_smc_msg(\n\t\t\t\tsmu, SMU_MSG_GetMaxGfxclkFrequency, max);\n\t\telse\n\t\t\tret = smu_cmn_send_smc_msg_with_param(\n\t\t\t\tsmu, SMU_MSG_GetMaxDpmFreq, param, max);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (min) {\n\t\tif (clk_type == SMU_GFXCLK || clk_type == SMU_SCLK)\n\t\t\tret = smu_cmn_send_smc_msg(\n\t\t\t\tsmu, SMU_MSG_GetMinGfxclkFrequency, min);\n\t\telse\n\t\t\tret = smu_cmn_send_smc_msg_with_param(\n\t\t\t\tsmu, SMU_MSG_GetMinDpmFreq, param, min);\n\t}\n\nfailed:\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_dpm_level_count(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t *levels)\n{\n\tint ret;\n\n\tret = smu_v13_0_get_dpm_freq_by_index(smu, clk_type, 0xff, levels);\n\tif (!ret)\n\t\t++(*levels);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_set_default_dpm_table(struct smu_context *smu)\n{\n\tstruct smu_13_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_13_0_dpm_table *dpm_table = NULL;\n\tstruct PPTable_t *pptable =\n\t\t(struct PPTable_t *)smu_table->driver_pptable;\n\tuint32_t gfxclkmin, gfxclkmax, levels;\n\tint ret = 0, i, j;\n\tstruct smu_v13_0_6_dpm_map dpm_map[] = {\n\t\t{ SMU_SOCCLK, SMU_FEATURE_DPM_SOCCLK_BIT,\n\t\t  &dpm_context->dpm_tables.soc_table,\n\t\t  pptable->SocclkFrequencyTable },\n\t\t{ SMU_UCLK, SMU_FEATURE_DPM_UCLK_BIT,\n\t\t  &dpm_context->dpm_tables.uclk_table,\n\t\t  pptable->UclkFrequencyTable },\n\t\t{ SMU_FCLK, SMU_FEATURE_DPM_FCLK_BIT,\n\t\t  &dpm_context->dpm_tables.fclk_table,\n\t\t  pptable->FclkFrequencyTable },\n\t\t{ SMU_VCLK, SMU_FEATURE_DPM_VCLK_BIT,\n\t\t  &dpm_context->dpm_tables.vclk_table,\n\t\t  pptable->VclkFrequencyTable },\n\t\t{ SMU_DCLK, SMU_FEATURE_DPM_DCLK_BIT,\n\t\t  &dpm_context->dpm_tables.dclk_table,\n\t\t  pptable->DclkFrequencyTable },\n\t};\n\n\tsmu_v13_0_6_setup_driver_pptable(smu);\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.gfx_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {\n\t\t \n\t\tret = smu_v13_0_6_get_dpm_ultimate_freq(smu, SMU_GFXCLK,\n\t\t\t\t\t\t\t&gfxclkmin, &gfxclkmax);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdpm_table->count = 2;\n\t\tdpm_table->dpm_levels[0].value = gfxclkmin;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->dpm_levels[1].value = gfxclkmax;\n\t\tdpm_table->dpm_levels[1].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[1].value;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = pptable->MinGfxclkFrequency;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\tfor (j = 0; j < ARRAY_SIZE(dpm_map); j++) {\n\t\tdpm_table = dpm_map[j].dpm_table;\n\t\tlevels = 1;\n\t\tif (smu_cmn_feature_is_enabled(smu, dpm_map[j].feature_num)) {\n\t\t\tret = smu_v13_0_6_get_dpm_level_count(\n\t\t\t\tsmu, dpm_map[j].clk_type, &levels);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tdpm_table->count = levels;\n\t\tfor (i = 0; i < dpm_table->count; ++i) {\n\t\t\tdpm_table->dpm_levels[i].value =\n\t\t\t\tdpm_map[j].freq_table[i];\n\t\t\tdpm_table->dpm_levels[i].enabled = true;\n\n\t\t}\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[levels - 1].value;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_setup_pptable(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\n\t \n\ttable_context->thermal_controller_type = 0;\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_check_fw_status(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t mp1_fw_flags;\n\n\tmp1_fw_flags =\n\t\tRREG32_PCIE(MP1_Public | (smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\n\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nstatic int smu_v13_0_6_populate_umd_state_clk(struct smu_context *smu)\n{\n\tstruct smu_13_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_13_0_dpm_table *gfx_table =\n\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_13_0_dpm_table *mem_table =\n\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_13_0_dpm_table *soc_table =\n\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_umd_pstate_table *pstate_table = &smu->pstate_table;\n\n\tpstate_table->gfxclk_pstate.min = gfx_table->min;\n\tpstate_table->gfxclk_pstate.peak = gfx_table->max;\n\tpstate_table->gfxclk_pstate.curr.min = gfx_table->min;\n\tpstate_table->gfxclk_pstate.curr.max = gfx_table->max;\n\n\tpstate_table->uclk_pstate.min = mem_table->min;\n\tpstate_table->uclk_pstate.peak = mem_table->max;\n\tpstate_table->uclk_pstate.curr.min = mem_table->min;\n\tpstate_table->uclk_pstate.curr.max = mem_table->max;\n\n\tpstate_table->socclk_pstate.min = soc_table->min;\n\tpstate_table->socclk_pstate.peak = soc_table->max;\n\tpstate_table->socclk_pstate.curr.min = soc_table->min;\n\tpstate_table->socclk_pstate.curr.max = soc_table->max;\n\n\tif (gfx_table->count > SMU_13_0_6_UMD_PSTATE_GFXCLK_LEVEL &&\n\t    mem_table->count > SMU_13_0_6_UMD_PSTATE_MCLK_LEVEL &&\n\t    soc_table->count > SMU_13_0_6_UMD_PSTATE_SOCCLK_LEVEL) {\n\t\tpstate_table->gfxclk_pstate.standard =\n\t\t\tgfx_table->dpm_levels[SMU_13_0_6_UMD_PSTATE_GFXCLK_LEVEL].value;\n\t\tpstate_table->uclk_pstate.standard =\n\t\t\tmem_table->dpm_levels[SMU_13_0_6_UMD_PSTATE_MCLK_LEVEL].value;\n\t\tpstate_table->socclk_pstate.standard =\n\t\t\tsoc_table->dpm_levels[SMU_13_0_6_UMD_PSTATE_SOCCLK_LEVEL].value;\n\t} else {\n\t\tpstate_table->gfxclk_pstate.standard =\n\t\t\tpstate_table->gfxclk_pstate.min;\n\t\tpstate_table->uclk_pstate.standard =\n\t\t\tpstate_table->uclk_pstate.min;\n\t\tpstate_table->socclk_pstate.standard =\n\t\t\tpstate_table->socclk_pstate.min;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_get_clk_table(struct smu_context *smu,\n\t\t\t\t     struct pp_clock_levels_with_latency *clocks,\n\t\t\t\t     struct smu_13_0_dpm_table *dpm_table)\n{\n\tint i, count;\n\n\tcount = (dpm_table->count > MAX_NUM_CLOCKS) ? MAX_NUM_CLOCKS :\n\t\t\t\t\t\t      dpm_table->count;\n\tclocks->num_levels = count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tclocks->data[i].clocks_in_khz =\n\t\t\tdpm_table->dpm_levels[i].value * 1000;\n\t\tclocks->data[i].latency_in_us = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_freqs_in_same_level(int32_t frequency1,\n\t\t\t\t\t   int32_t frequency2)\n{\n\treturn (abs(frequency1 - frequency2) <= EPSILON);\n}\n\nstatic uint32_t smu_v13_0_6_get_throttler_status(struct smu_context *smu)\n{\n\tstruct smu_power_context *smu_power = &smu->smu_power;\n\tstruct smu_13_0_power_context *power_context = smu_power->power_context;\n\tuint32_t  throttler_status = 0;\n\n\tthrottler_status = atomic_read(&power_context->throttle_status);\n\tdev_dbg(smu->adev->dev, \"SMU Throttler status: %u\", throttler_status);\n\n\treturn throttler_status;\n}\n\nstatic int smu_v13_0_6_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t    MetricsMember_t member,\n\t\t\t\t\t    uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tMetricsTable_t *metrics = (MetricsTable_t *)smu_table->metrics_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t smu_version;\n\tint ret = 0;\n\tint xcc_id;\n\n\tret = smu_v13_0_6_get_metrics_table(smu, NULL, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\t\tif (smu_version >= 0x552F00) {\n\t\t\txcc_id = GET_INST(GC, 0);\n\t\t\t*value = SMUQ10_TO_UINT(metrics->GfxclkFrequency[xcc_id]);\n\t\t} else {\n\t\t\t*value = 0;\n\t\t}\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = SMUQ10_TO_UINT(metrics->SocclkFrequency[0]);\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = SMUQ10_TO_UINT(metrics->UclkFrequency);\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = SMUQ10_TO_UINT(metrics->VclkFrequency[0]);\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = SMUQ10_TO_UINT(metrics->DclkFrequency[0]);\n\t\tbreak;\n\tcase METRICS_CURR_FCLK:\n\t\t*value = SMUQ10_TO_UINT(metrics->FclkFrequency);\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = SMUQ10_TO_UINT(metrics->SocketGfxBusy);\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = SMUQ10_TO_UINT(metrics->DramBandwidthUtilization);\n\t\tbreak;\n\tcase METRICS_CURR_SOCKETPOWER:\n\t\t*value = SMUQ10_TO_UINT(metrics->SocketPower) << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = SMUQ10_TO_UINT(metrics->MaxSocketTemperature) *\n\t\t\t SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = SMUQ10_TO_UINT(metrics->MaxHbmTemperature) *\n\t\t\t SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\t \n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = SMUQ10_TO_UINT(metrics->MaxVrTemperature) *\n\t\t\t SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_current_clk_freq_by_table(struct smu_context *smu,\n\t\t\t\t\t\t     enum smu_clk_type clk_type,\n\t\t\t\t\t\t     uint32_t *value)\n{\n\tMetricsMember_t member_type;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\t\tmember_type = METRICS_CURR_GFXCLK;\n\t\tbreak;\n\tcase SMU_UCLK:\n\t\tmember_type = METRICS_CURR_UCLK;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tmember_type = METRICS_CURR_SOCCLK;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tmember_type = METRICS_CURR_VCLK;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tmember_type = METRICS_CURR_DCLK;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tmember_type = METRICS_CURR_FCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn smu_v13_0_6_get_smu_metrics_data(smu, member_type, value);\n}\n\nstatic int smu_v13_0_6_print_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type type, char *buf)\n{\n\tint i, now, size = 0;\n\tint ret = 0;\n\tstruct smu_umd_pstate_table *pstate_table = &smu->pstate_table;\n\tstruct pp_clock_levels_with_latency clocks;\n\tstruct smu_13_0_dpm_table *single_dpm_table;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_13_0_dpm_context *dpm_context = NULL;\n\tuint32_t min_clk, max_clk;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tif (amdgpu_ras_intr_triggered()) {\n\t\tsize += sysfs_emit_at(buf, size, \"unavailable\\n\");\n\t\treturn size;\n\t}\n\n\tdpm_context = smu_dpm->dpm_context;\n\n\tswitch (type) {\n\tcase SMU_OD_SCLK:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"GFXCLK\");\n\t\tfallthrough;\n\tcase SMU_SCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(smu, SMU_GFXCLK,\n\t\t\t\t\t\t\t\t&now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get current gfx clk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tmin_clk = pstate_table->gfxclk_pstate.curr.min;\n\t\tmax_clk = pstate_table->gfxclk_pstate.curr.max;\n\n\t\tif (!smu_v13_0_6_freqs_in_same_level(now, min_clk) &&\n\t\t    !smu_v13_0_6_freqs_in_same_level(now, max_clk)) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n\",\n\t\t\t\t\t      min_clk);\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz *\\n\",\n\t\t\t\t\t      now);\n\t\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz\\n\",\n\t\t\t\t\t      max_clk);\n\t\t} else {\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\",\n\t\t\t\t\t      min_clk,\n\t\t\t\t\t      smu_v13_0_6_freqs_in_same_level(now, min_clk) ? \"*\" : \"\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\t\t      max_clk,\n\t\t\t\t\t      smu_v13_0_6_freqs_in_same_level(now, max_clk) ? \"*\" : \"\");\n\t\t}\n\n\t\tbreak;\n\n\tcase SMU_OD_MCLK:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"MCLK\");\n\t\tfallthrough;\n\tcase SMU_MCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(smu, SMU_UCLK,\n\t\t\t\t\t\t\t\t&now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get current mclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.uclk_table);\n\t\tret = smu_v13_0_6_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get memory clk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sysfs_emit_at(\n\t\t\t\tbuf, size, \"%d: %uMhz %s\\n\", i,\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.num_levels == 1) ?\n\t\t\t\t\t\"*\" :\n\t\t\t\t\t(smu_v13_0_6_freqs_in_same_level(\n\t\t\t\t\t\t clocks.data[i].clocks_in_khz /\n\t\t\t\t\t\t\t 1000,\n\t\t\t\t\t\t now) ?\n\t\t\t\t\t\t \"*\" :\n\t\t\t\t\t\t \"\"));\n\t\tbreak;\n\n\tcase SMU_SOCCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(smu, SMU_SOCCLK,\n\t\t\t\t\t\t\t\t&now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get current socclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.soc_table);\n\t\tret = smu_v13_0_6_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get socclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < clocks.num_levels; i++)\n\t\t\tsize += sysfs_emit_at(\n\t\t\t\tbuf, size, \"%d: %uMhz %s\\n\", i,\n\t\t\t\tclocks.data[i].clocks_in_khz / 1000,\n\t\t\t\t(clocks.num_levels == 1) ?\n\t\t\t\t\t\"*\" :\n\t\t\t\t\t(smu_v13_0_6_freqs_in_same_level(\n\t\t\t\t\t\t clocks.data[i].clocks_in_khz /\n\t\t\t\t\t\t\t 1000,\n\t\t\t\t\t\t now) ?\n\t\t\t\t\t\t \"*\" :\n\t\t\t\t\t\t \"\"));\n\t\tbreak;\n\n\tcase SMU_FCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(smu, SMU_FCLK,\n\t\t\t\t\t\t\t\t&now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get current fclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.fclk_table);\n\t\tret = smu_v13_0_6_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get fclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\tsize += sysfs_emit_at(\n\t\t\t\tbuf, size, \"%d: %uMhz %s\\n\", i,\n\t\t\t\tsingle_dpm_table->dpm_levels[i].value,\n\t\t\t\t(clocks.num_levels == 1) ?\n\t\t\t\t\t\"*\" :\n\t\t\t\t\t(smu_v13_0_6_freqs_in_same_level(\n\t\t\t\t\t\t clocks.data[i].clocks_in_khz /\n\t\t\t\t\t\t\t 1000,\n\t\t\t\t\t\t now) ?\n\t\t\t\t\t\t \"*\" :\n\t\t\t\t\t\t \"\"));\n\t\tbreak;\n\n\tcase SMU_VCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(smu, SMU_VCLK,\n\t\t\t\t\t\t\t\t&now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get current vclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.vclk_table);\n\t\tret = smu_v13_0_6_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get vclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\tsize += sysfs_emit_at(\n\t\t\t\tbuf, size, \"%d: %uMhz %s\\n\", i,\n\t\t\t\tsingle_dpm_table->dpm_levels[i].value,\n\t\t\t\t(clocks.num_levels == 1) ?\n\t\t\t\t\t\"*\" :\n\t\t\t\t\t(smu_v13_0_6_freqs_in_same_level(\n\t\t\t\t\t\t clocks.data[i].clocks_in_khz /\n\t\t\t\t\t\t\t 1000,\n\t\t\t\t\t\t now) ?\n\t\t\t\t\t\t \"*\" :\n\t\t\t\t\t\t \"\"));\n\t\tbreak;\n\n\tcase SMU_DCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(smu, SMU_DCLK,\n\t\t\t\t\t\t\t       &now);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get current dclk Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.dclk_table);\n\t\tret = smu_v13_0_6_get_clk_table(smu, &clocks, single_dpm_table);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Attempt to get dclk levels Failed!\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < single_dpm_table->count; i++)\n\t\t\tsize += sysfs_emit_at(\n\t\t\t\tbuf, size, \"%d: %uMhz %s\\n\", i,\n\t\t\t\tsingle_dpm_table->dpm_levels[i].value,\n\t\t\t\t(clocks.num_levels == 1) ?\n\t\t\t\t\t\"*\" :\n\t\t\t\t\t(smu_v13_0_6_freqs_in_same_level(\n\t\t\t\t\t\t clocks.data[i].clocks_in_khz /\n\t\t\t\t\t\t\t 1000,\n\t\t\t\t\t\t now) ?\n\t\t\t\t\t\t \"*\" :\n\t\t\t\t\t\t \"\"));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int smu_v13_0_6_upload_dpm_level(struct smu_context *smu, bool max,\n\t\t\t\t\tuint32_t feature_mask, uint32_t level)\n{\n\tstruct smu_13_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tuint32_t freq;\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT) &&\n\t    (feature_mask & FEATURE_MASK(FEATURE_DPM_GFXCLK))) {\n\t\tfreq = dpm_context->dpm_tables.gfx_table.dpm_levels[level].value;\n\t\tret = smu_cmn_send_smc_msg_with_param(\n\t\t\tsmu,\n\t\t\t(max ? SMU_MSG_SetSoftMaxGfxClk :\n\t\t\t       SMU_MSG_SetSoftMinGfxclk),\n\t\t\tfreq & 0xffff, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Failed to set soft %s gfxclk !\\n\",\n\t\t\t\tmax ? \"max\" : \"min\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT) &&\n\t    (feature_mask & FEATURE_MASK(FEATURE_DPM_UCLK))) {\n\t\tfreq = dpm_context->dpm_tables.uclk_table.dpm_levels[level]\n\t\t\t       .value;\n\t\tret = smu_cmn_send_smc_msg_with_param(\n\t\t\tsmu,\n\t\t\t(max ? SMU_MSG_SetSoftMaxByFreq :\n\t\t\t       SMU_MSG_SetSoftMinByFreq),\n\t\t\t(PPCLK_UCLK << 16) | (freq & 0xffff), NULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Failed to set soft %s memclk !\\n\",\n\t\t\t\tmax ? \"max\" : \"min\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT) &&\n\t    (feature_mask & FEATURE_MASK(FEATURE_DPM_SOCCLK))) {\n\t\tfreq = dpm_context->dpm_tables.soc_table.dpm_levels[level].value;\n\t\tret = smu_cmn_send_smc_msg_with_param(\n\t\t\tsmu,\n\t\t\t(max ? SMU_MSG_SetSoftMaxByFreq :\n\t\t\t       SMU_MSG_SetSoftMinByFreq),\n\t\t\t(PPCLK_SOCCLK << 16) | (freq & 0xffff), NULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Failed to set soft %s socclk !\\n\",\n\t\t\t\tmax ? \"max\" : \"min\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_force_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type type, uint32_t mask)\n{\n\tstruct smu_13_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_13_0_dpm_table *single_dpm_table = NULL;\n\tuint32_t soft_min_level, soft_max_level;\n\tint ret = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (type) {\n\tcase SMU_SCLK:\n\t\tsingle_dpm_table = &(dpm_context->dpm_tables.gfx_table);\n\t\tif (soft_max_level >= single_dpm_table->count) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Clock level specified %d is over max allowed %d\\n\",\n\t\t\t\tsoft_max_level, single_dpm_table->count - 1);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = smu_v13_0_6_upload_dpm_level(\n\t\t\tsmu, false, FEATURE_MASK(FEATURE_DPM_GFXCLK),\n\t\t\tsoft_min_level);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Failed to upload boot level to lowest!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tret = smu_v13_0_6_upload_dpm_level(\n\t\t\tsmu, true, FEATURE_MASK(FEATURE_DPM_GFXCLK),\n\t\t\tsoft_max_level);\n\t\tif (ret)\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Failed to upload dpm max level to highest!\\n\");\n\n\t\tbreak;\n\n\tcase SMU_MCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_FCLK:\n\t\t \n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_current_activity_percent(struct smu_context *smu,\n\t\t\t\t\t\t    enum amd_pp_sensors sensor,\n\t\t\t\t\t\t    uint32_t *value)\n{\n\tint ret = 0;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = smu_v13_0_6_get_smu_metrics_data(\n\t\t\tsmu, METRICS_AVERAGE_GFXACTIVITY, value);\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\tret = smu_v13_0_6_get_smu_metrics_data(\n\t\t\tsmu, METRICS_AVERAGE_MEMACTIVITY, value);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(smu->adev->dev,\n\t\t\t\"Invalid sensor for retrieving clock activity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_thermal_get_temperature(struct smu_context *smu,\n\t\t\t\t\t       enum amd_pp_sensors sensor,\n\t\t\t\t\t       uint32_t *value)\n{\n\tint ret = 0;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = smu_v13_0_6_get_smu_metrics_data(\n\t\t\tsmu, METRICS_TEMPERATURE_HOTSPOT, value);\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = smu_v13_0_6_get_smu_metrics_data(\n\t\t\tsmu, METRICS_TEMPERATURE_MEM, value);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(smu->adev->dev, \"Invalid sensor for retrieving temp\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_read_sensor(struct smu_context *smu,\n\t\t\t\t   enum amd_pp_sensors sensor, void *data,\n\t\t\t\t   uint32_t *size)\n{\n\tint ret = 0;\n\n\tif (amdgpu_ras_intr_triggered())\n\t\treturn 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = smu_v13_0_6_get_current_activity_percent(smu, sensor,\n\t\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = smu_v13_0_6_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_CURR_SOCKETPOWER,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = smu_v13_0_6_thermal_get_temperature(smu, sensor,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(\n\t\t\tsmu, SMU_UCLK, (uint32_t *)data);\n\t\t \n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = smu_v13_0_6_get_current_clk_freq_by_table(\n\t\t\tsmu, SMU_GFXCLK, (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = smu_v13_0_get_gfx_vdd(smu, (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_power_limit(struct smu_context *smu,\n\t\t\t\t       uint32_t *current_power_limit,\n\t\t\t\t       uint32_t *default_power_limit,\n\t\t\t\t       uint32_t *max_power_limit)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct PPTable_t *pptable =\n\t\t(struct PPTable_t *)smu_table->driver_pptable;\n\tuint32_t power_limit = 0;\n\tint ret;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetPptLimit, &power_limit);\n\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Couldn't get PPT limit\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (max_power_limit) {\n\t\t*max_power_limit = pptable->MaxSocketPowerLimit;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_set_power_limit(struct smu_context *smu,\n\t\t\t\t       enum smu_ppt_limit_type limit_type,\n\t\t\t\t       uint32_t limit)\n{\n\treturn smu_v13_0_set_power_limit(smu, limit_type, limit);\n}\n\nstatic int smu_v13_0_6_irq_process(struct amdgpu_device *adev,\n\t\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tstruct smu_power_context *smu_power = &smu->smu_power;\n\tstruct smu_13_0_power_context *power_context = smu_power->power_context;\n\tuint32_t client_id = entry->client_id;\n\tuint32_t ctxid = entry->src_data[0];\n\tuint32_t src_id = entry->src_id;\n\tuint32_t data;\n\n\tif (client_id == SOC15_IH_CLIENTID_MP1) {\n\t\tif (src_id == IH_INTERRUPT_ID_TO_DRIVER) {\n\t\t\t \n\t\t\tdata = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL);\n\t\t\tdata = REG_SET_FIELD(data, MP1_SMN_IH_SW_INT_CTRL, INT_ACK, 1);\n\t\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL, data);\n\t\t\t \n\t\t\tswitch (ctxid) {\n\t\t\tcase IH_INTERRUPT_CONTEXT_ID_THERMAL_THROTTLING:\n\t\t\t\t \n\t\t\t\tatomic64_inc(&smu->throttle_int_counter);\n\n\t\t\t\tif (!atomic_read(&adev->throttling_logging_enabled))\n\t\t\t\t\treturn 0;\n\n\t\t\t\t \n\t\t\t\tif (__ratelimit(&adev->throttling_logging_rs)) {\n\t\t\t\t\tatomic_set(\n\t\t\t\t\t\t&power_context->throttle_status,\n\t\t\t\t\t\t\tentry->src_data[1]);\n\t\t\t\t\tschedule_work(&smu->throttling_logging_work);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_set_irq_state(struct amdgpu_device *adev,\n\t\t\t      struct amdgpu_irq_src *source,\n\t\t\t      unsigned tyep,\n\t\t\t      enum amdgpu_interrupt_state state)\n{\n\tuint32_t val = 0;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\t \n\t\tval = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT_CTRL, INT_MASK, 1);\n\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL, val);\n\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\t \n\t\tval = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT, ID, 0xFE);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT, VALID, 0);\n\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT, val);\n\n\t\tval = RREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT_CTRL, INT_MASK, 0);\n\t\tWREG32_SOC15(MP1, 0, regMP1_SMN_IH_SW_INT_CTRL, val);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs smu_v13_0_6_irq_funcs = {\n\t.set = smu_v13_0_6_set_irq_state,\n\t.process = smu_v13_0_6_irq_process,\n};\n\nstatic int smu_v13_0_6_register_irq_handler(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_irq_src *irq_src = &smu->irq_source;\n\tint ret = 0;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tirq_src->num_types = 1;\n\tirq_src->funcs = &smu_v13_0_6_irq_funcs;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_MP1,\n\t\t\t\tIH_INTERRUPT_ID_TO_DRIVER,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_notify_unload(struct smu_context *smu)\n{\n\tuint32_t smu_version;\n\n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (smu_version <= 0x553500)\n\t\treturn 0;\n\n\tdev_dbg(smu->adev->dev, \"Notify PMFW about driver unload\");\n\t \n\tsmu_cmn_send_smc_msg(smu, SMU_MSG_PrepareMp1ForUnload, NULL);\n\n\treturn 0;\n}\n\nstatic int smu_v13_0_6_system_features_control(struct smu_context *smu,\n\t\t\t\t\t       bool enable)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tif (enable) {\n\t\tif (!(adev->flags & AMD_IS_APU))\n\t\t\tret = smu_v13_0_system_features_control(smu, enable);\n\t} else {\n\t\t \n\t\tsmu_v13_0_6_notify_unload(smu);\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_set_gfx_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t\t       uint32_t min,\n\t\t\t\t\t\t       uint32_t max)\n{\n\tint ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t      max & 0xffff, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinGfxclk,\n\t\t\t\t\t      min & 0xffff, NULL);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_set_performance_level(struct smu_context *smu,\n\t\t\t\t\t     enum amd_dpm_forced_level level)\n{\n\tstruct smu_dpm_context *smu_dpm = &(smu->smu_dpm);\n\tstruct smu_13_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tstruct smu_13_0_dpm_table *gfx_table =\n\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_umd_pstate_table *pstate_table = &smu->pstate_table;\n\tint ret;\n\n\t \n\tif ((smu_dpm->dpm_level == AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM) &&\n\t    (level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM)) {\n\t\tsmu_cmn_send_smc_msg(smu, SMU_MSG_DisableDeterminism, NULL);\n\t\tpstate_table->gfxclk_pstate.curr.max = gfx_table->max;\n\t}\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM:\n\t\treturn 0;\n\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tif ((gfx_table->min == pstate_table->gfxclk_pstate.curr.min) &&\n\t\t    (gfx_table->max == pstate_table->gfxclk_pstate.curr.max))\n\t\t\treturn 0;\n\n\t\tret = smu_v13_0_6_set_gfx_soft_freq_limited_range(\n\t\t\tsmu, gfx_table->min, gfx_table->max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpstate_table->gfxclk_pstate.curr.min = gfx_table->min;\n\t\tpstate_table->gfxclk_pstate.curr.max = gfx_table->max;\n\t\treturn 0;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int smu_v13_0_6_set_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t\t   enum smu_clk_type clk_type,\n\t\t\t\t\t\t   uint32_t min, uint32_t max)\n{\n\tstruct smu_dpm_context *smu_dpm = &(smu->smu_dpm);\n\tstruct smu_13_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tstruct smu_umd_pstate_table *pstate_table = &smu->pstate_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t min_clk;\n\tuint32_t max_clk;\n\tint ret = 0;\n\n\tif (clk_type != SMU_GFXCLK && clk_type != SMU_SCLK)\n\t\treturn -EINVAL;\n\n\tif ((smu_dpm->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) &&\n\t    (smu_dpm->dpm_level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM))\n\t\treturn -EINVAL;\n\n\tif (smu_dpm->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\tif (min >= max) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Minimum GFX clk should be less than the maximum allowed clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((min == pstate_table->gfxclk_pstate.curr.min) &&\n\t\t    (max == pstate_table->gfxclk_pstate.curr.max))\n\t\t\treturn 0;\n\n\t\tret = smu_v13_0_6_set_gfx_soft_freq_limited_range(smu, min, max);\n\t\tif (!ret) {\n\t\t\tpstate_table->gfxclk_pstate.curr.min = min;\n\t\t\tpstate_table->gfxclk_pstate.curr.max = max;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tif (smu_dpm->dpm_level == AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM) {\n\t\tif (!max || (max < dpm_context->dpm_tables.gfx_table.min) ||\n\t\t    (max > dpm_context->dpm_tables.gfx_table.max)) {\n\t\t\tdev_warn(\n\t\t\t\tadev->dev,\n\t\t\t\t\"Invalid max frequency %d MHz specified for determinism\\n\",\n\t\t\t\tmax);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tmin_clk = dpm_context->dpm_tables.gfx_table.min;\n\t\tmax_clk = dpm_context->dpm_tables.gfx_table.max;\n\t\tret = smu_v13_0_6_set_gfx_soft_freq_limited_range(smu, min_clk,\n\t\t\t\t\t\t\t\t max_clk);\n\t\tif (!ret) {\n\t\t\tusleep_range(500, 1000);\n\t\t\tret = smu_cmn_send_smc_msg_with_param(\n\t\t\t\tsmu, SMU_MSG_EnableDeterminism, max, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(adev->dev,\n\t\t\t\t\t\"Failed to enable determinism at GFX clock %d MHz\\n\",\n\t\t\t\t\tmax);\n\t\t\t} else {\n\t\t\t\tpstate_table->gfxclk_pstate.curr.min = min_clk;\n\t\t\t\tpstate_table->gfxclk_pstate.curr.max = max;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_usr_edit_dpm_table(struct smu_context *smu,\n\t\t\t\t\t  enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\t  long input[], uint32_t size)\n{\n\tstruct smu_dpm_context *smu_dpm = &(smu->smu_dpm);\n\tstruct smu_13_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tstruct smu_umd_pstate_table *pstate_table = &smu->pstate_table;\n\tuint32_t min_clk;\n\tuint32_t max_clk;\n\tint ret = 0;\n\n\t \n\tif ((smu_dpm->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) &&\n\t    (smu_dpm->dpm_level != AMD_DPM_FORCED_LEVEL_PERF_DETERMINISM))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (size != 2) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[0] == 0) {\n\t\t\tif (input[1] < dpm_context->dpm_tables.gfx_table.min) {\n\t\t\t\tdev_warn(\n\t\t\t\t\tsmu->adev->dev,\n\t\t\t\t\t\"Minimum GFX clk (%ld) MHz specified is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1],\n\t\t\t\t\tdpm_context->dpm_tables.gfx_table.min);\n\t\t\t\tpstate_table->gfxclk_pstate.custom.min =\n\t\t\t\t\tpstate_table->gfxclk_pstate.curr.min;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpstate_table->gfxclk_pstate.custom.min = input[1];\n\t\t} else if (input[0] == 1) {\n\t\t\tif (input[1] > dpm_context->dpm_tables.gfx_table.max) {\n\t\t\t\tdev_warn(\n\t\t\t\t\tsmu->adev->dev,\n\t\t\t\t\t\"Maximum GFX clk (%ld) MHz specified is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1],\n\t\t\t\t\tdpm_context->dpm_tables.gfx_table.max);\n\t\t\t\tpstate_table->gfxclk_pstate.custom.max =\n\t\t\t\t\tpstate_table->gfxclk_pstate.curr.max;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tpstate_table->gfxclk_pstate.custom.max = input[1];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\t \n\t\t\tmin_clk = dpm_context->dpm_tables.gfx_table.min;\n\t\t\tmax_clk = dpm_context->dpm_tables.gfx_table.max;\n\n\t\t\treturn smu_v13_0_6_set_soft_freq_limited_range(\n\t\t\t\tsmu, SMU_GFXCLK, min_clk, max_clk);\n\t\t}\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (!pstate_table->gfxclk_pstate.custom.min)\n\t\t\t\tpstate_table->gfxclk_pstate.custom.min =\n\t\t\t\t\tpstate_table->gfxclk_pstate.curr.min;\n\n\t\t\tif (!pstate_table->gfxclk_pstate.custom.max)\n\t\t\t\tpstate_table->gfxclk_pstate.custom.max =\n\t\t\t\t\tpstate_table->gfxclk_pstate.curr.max;\n\n\t\t\tmin_clk = pstate_table->gfxclk_pstate.custom.min;\n\t\t\tmax_clk = pstate_table->gfxclk_pstate.custom.max;\n\n\t\t\treturn smu_v13_0_6_set_soft_freq_limited_range(\n\t\t\t\tsmu, SMU_GFXCLK, min_clk, max_clk);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_enabled_mask(struct smu_context *smu,\n\t\t\t\t\tuint64_t *feature_mask)\n{\n\tuint32_t smu_version;\n\tint ret;\n\n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tret = smu_cmn_get_enabled_mask(smu, feature_mask);\n\n\tif (ret == -EIO && smu_version < 0x552F00) {\n\t\t*feature_mask = 0;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic bool smu_v13_0_6_is_dpm_running(struct smu_context *smu)\n{\n\tint ret;\n\tuint64_t feature_enabled;\n\n\tret = smu_v13_0_6_get_enabled_mask(smu, &feature_enabled);\n\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int smu_v13_0_6_request_i2c_xfer(struct smu_context *smu,\n\t\t\t\t\tvoid *table_data)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t table_size;\n\tint ret = 0;\n\n\tif (!table_data)\n\t\treturn -EINVAL;\n\n\ttable_size = smu_table->tables[SMU_TABLE_I2C_COMMANDS].size;\n\n\tmemcpy(table->cpu_addr, table_data, table_size);\n\t \n\tamdgpu_asic_flush_hdp(adev, NULL);\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_RequestI2cTransaction,\n\t\t\t\t\t  NULL);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t\tstruct i2c_msg *msg, int num_msgs)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tSwI2cRequest_t *req, *res = (SwI2cRequest_t *)table->cpu_addr;\n\tint i, j, r, c;\n\tu16 dir;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn -EBUSY;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->I2CcontrollerPort = smu_i2c->port;\n\treq->I2CSpeed = I2C_SPEED_FAST_400K;\n\treq->SlaveAddress = msg[0].addr << 1;  \n\tdir = msg[0].flags & I2C_M_RD;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &req->SwI2cCmds[c];\n\n\t\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\t\t \n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_READWRITE_MASK;\n\t\t\t\tcmd->ReadWriteData = msg[i].buf[j];\n\t\t\t}\n\n\t\t\tif ((dir ^ msg[i].flags) & I2C_M_RD) {\n\t\t\t\t \n\t\t\t\tdir = msg[i].flags & I2C_M_RD;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_RESTART_MASK;\n\t\t\t}\n\n\t\t\treq->NumCmds++;\n\n\t\t\t \n\t\t\tif ((j == msg[i].len - 1) &&\n\t\t\t    ((i == num_msgs - 1) || (msg[i].flags & I2C_M_STOP))) {\n\t\t\t\tcmd->CmdConfig &= ~CMDCONFIG_RESTART_MASK;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_STOP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&adev->pm.mutex);\n\tr = smu_v13_0_6_request_i2c_xfer(smu, req);\n\tif (r)\n\t\tgoto fail;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\tc += msg[i].len;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &res->SwI2cCmds[c];\n\n\t\t\tmsg[i].buf[j] = cmd->ReadWriteData;\n\t\t}\n\t}\n\tr = num_msgs;\nfail:\n\tmutex_unlock(&adev->pm.mutex);\n\tkfree(req);\n\treturn r;\n}\n\nstatic u32 smu_v13_0_6_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\nstatic const struct i2c_algorithm smu_v13_0_6_i2c_algo = {\n\t.master_xfer = smu_v13_0_6_i2c_xfer,\n\t.functionality = smu_v13_0_6_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks smu_v13_0_6_i2c_control_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_SAME_ADDR | I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len = MAX_SW_I2C_COMMANDS,\n\t.max_write_len = MAX_SW_I2C_COMMANDS,\n\t.max_comb_1st_msg_len = 2,\n\t.max_comb_2nd_msg_len = MAX_SW_I2C_COMMANDS - 2,\n};\n\nstatic int smu_v13_0_6_i2c_control_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint res, i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\tsmu_i2c->adev = adev;\n\t\tsmu_i2c->port = i;\n\t\tmutex_init(&smu_i2c->mutex);\n\t\tcontrol->owner = THIS_MODULE;\n\t\tcontrol->class = I2C_CLASS_SPD;\n\t\tcontrol->dev.parent = &adev->pdev->dev;\n\t\tcontrol->algo = &smu_v13_0_6_i2c_algo;\n\t\tsnprintf(control->name, sizeof(control->name), \"AMDGPU SMU %d\", i);\n\t\tcontrol->quirks = &smu_v13_0_6_i2c_control_quirks;\n\t\ti2c_set_adapdata(control, smu_i2c);\n\n\t\tres = i2c_add_adapter(control);\n\t\tif (res) {\n\t\t\tDRM_ERROR(\"Failed to register hw i2c, err: %d\\n\", res);\n\t\t\tgoto Out_err;\n\t\t}\n\t}\n\n\tadev->pm.ras_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\tadev->pm.fru_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\n\treturn 0;\nOut_err:\n\tfor ( ; i >= 0; i--) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\treturn res;\n}\n\nstatic void smu_v13_0_6_i2c_control_fini(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\tadev->pm.ras_eeprom_i2c_bus = NULL;\n\tadev->pm.fru_eeprom_i2c_bus = NULL;\n}\n\nstatic void smu_v13_0_6_get_unique_id(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct PPTable_t *pptable =\n\t\t(struct PPTable_t *)smu_table->driver_pptable;\n\n\tadev->unique_id = pptable->PublicSerialNumber_AID;\n\tif (adev->serial[0] == '\\0')\n\t\tsprintf(adev->serial, \"%016llx\", adev->unique_id);\n}\n\nstatic bool smu_v13_0_6_is_baco_supported(struct smu_context *smu)\n{\n\t \n\n\treturn false;\n}\n\nstatic int smu_v13_0_6_set_df_cstate(struct smu_context *smu,\n\t\t\t\t     enum pp_df_cstate state)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DFCstateControl,\n\t\t\t\t\t       state, NULL);\n}\n\nstatic int smu_v13_0_6_allow_xgmi_power_down(struct smu_context *smu, bool en)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GmiPwrDnControl,\n\t\t\t\t\t       en ? 0 : 1, NULL);\n}\n\nstatic const char *const throttling_logging_label[] = {\n\t[THROTTLER_PROCHOT_BIT] = \"Prochot\",\n\t[THROTTLER_PPT_BIT] = \"PPT\",\n\t[THROTTLER_THERMAL_SOCKET_BIT] = \"SOC\",\n\t[THROTTLER_THERMAL_VR_BIT] = \"VR\",\n\t[THROTTLER_THERMAL_HBM_BIT] = \"HBM\"\n};\n\nstatic void smu_v13_0_6_log_thermal_throttling_event(struct smu_context *smu)\n{\n\tint throttler_idx, throtting_events = 0, buf_idx = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t throttler_status;\n\tchar log_buf[256];\n\n\tthrottler_status = smu_v13_0_6_get_throttler_status(smu);\n\tif (!throttler_status)\n\t\treturn;\n\n\tmemset(log_buf, 0, sizeof(log_buf));\n\tfor (throttler_idx = 0;\n\t     throttler_idx < ARRAY_SIZE(throttling_logging_label);\n\t     throttler_idx++) {\n\t\tif (throttler_status & (1U << throttler_idx)) {\n\t\t\tthrotting_events++;\n\t\t\tbuf_idx += snprintf(\n\t\t\t\tlog_buf + buf_idx, sizeof(log_buf) - buf_idx,\n\t\t\t\t\"%s%s\", throtting_events > 1 ? \" and \" : \"\",\n\t\t\t\tthrottling_logging_label[throttler_idx]);\n\t\t\tif (buf_idx >= sizeof(log_buf)) {\n\t\t\t\tdev_err(adev->dev, \"buffer overflow!\\n\");\n\t\t\t\tlog_buf[sizeof(log_buf) - 1] = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_warn(adev->dev,\n\t\t \"WARN: GPU is throttled, expect performance decrease. %s.\\n\",\n\t\t log_buf);\n\tkgd2kfd_smi_event_throttle(\n\t\tsmu->adev->kfd.dev,\n\t\tsmu_cmn_get_indep_throttler_status(throttler_status,\n\t\t\t\t\t\t   smu_v13_0_6_throttler_map));\n}\n\nstatic int\nsmu_v13_0_6_get_current_pcie_link_width_level(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treturn REG_GET_FIELD(RREG32_PCIE(smnPCIE_LC_LINK_WIDTH_CNTL),\n\t\t\t     PCIE_LC_LINK_WIDTH_CNTL, LC_LINK_WIDTH_RD);\n}\n\nstatic int smu_v13_0_6_get_current_pcie_link_speed(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t speed_level;\n\tuint32_t esm_ctrl;\n\n\t \n\tesm_ctrl = RREG32_PCIE(smnPCIE_ESM_CTRL);\n\tif ((esm_ctrl >> 15) & 0x1FFFF)\n\t\treturn (((esm_ctrl >> 8) & 0x3F) + 128);\n\n\tspeed_level = (RREG32_PCIE(smnPCIE_LC_SPEED_CNTL) &\n\t\tPCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK)\n\t\t>> PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;\n\tif (speed_level > LINK_SPEED_MAX)\n\t\tspeed_level = 0;\n\n\treturn pcie_gen_to_speed(speed_level + 1);\n}\n\nstatic ssize_t smu_v13_0_6_get_gpu_metrics(struct smu_context *smu, void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0, inst0, xcc0;\n\tMetricsTable_t *metrics;\n\tu16 link_width_level;\n\n\tinst0 = adev->sdma.instance[0].aid_id;\n\txcc0 = GET_INST(GC, 0);\n\n\tmetrics = kzalloc(sizeof(MetricsTable_t), GFP_KERNEL);\n\tret = smu_v13_0_6_get_metrics_table(smu, metrics, true);\n\tif (ret) {\n\t\tkfree(metrics);\n\t\treturn ret;\n\t}\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_hotspot =\n\t\tSMUQ10_TO_UINT(metrics->MaxSocketTemperature);\n\t \n\tgpu_metrics->temperature_mem =\n\t\tSMUQ10_TO_UINT(metrics->MaxHbmTemperature);\n\t \n\tgpu_metrics->temperature_vrsoc =\n\t\tSMUQ10_TO_UINT(metrics->MaxVrTemperature);\n\n\tgpu_metrics->average_gfx_activity =\n\t\tSMUQ10_TO_UINT(metrics->SocketGfxBusy);\n\tgpu_metrics->average_umc_activity =\n\t\tSMUQ10_TO_UINT(metrics->DramBandwidthUtilization);\n\n\tgpu_metrics->average_socket_power =\n\t\tSMUQ10_TO_UINT(metrics->SocketPower);\n\t \n\tgpu_metrics->energy_accumulator = metrics->SocketEnergyAcc;\n\n\tgpu_metrics->current_gfxclk =\n\t\tSMUQ10_TO_UINT(metrics->GfxclkFrequency[xcc0]);\n\tgpu_metrics->current_socclk =\n\t\tSMUQ10_TO_UINT(metrics->SocclkFrequency[inst0]);\n\tgpu_metrics->current_uclk = SMUQ10_TO_UINT(metrics->UclkFrequency);\n\tgpu_metrics->current_vclk0 =\n\t\tSMUQ10_TO_UINT(metrics->VclkFrequency[inst0]);\n\tgpu_metrics->current_dclk0 =\n\t\tSMUQ10_TO_UINT(metrics->DclkFrequency[inst0]);\n\n\tgpu_metrics->average_gfxclk_frequency = gpu_metrics->current_gfxclk;\n\tgpu_metrics->average_socclk_frequency = gpu_metrics->current_socclk;\n\tgpu_metrics->average_uclk_frequency = gpu_metrics->current_uclk;\n\tgpu_metrics->average_vclk0_frequency = gpu_metrics->current_vclk0;\n\tgpu_metrics->average_dclk0_frequency = gpu_metrics->current_dclk0;\n\n\t \n\tgpu_metrics->throttle_status = 0;\n\n\tif (!(adev->flags & AMD_IS_APU)) {\n\t\tlink_width_level = smu_v13_0_6_get_current_pcie_link_width_level(smu);\n\t\tif (link_width_level > MAX_LINK_WIDTH)\n\t\t\tlink_width_level = 0;\n\n\t\tgpu_metrics->pcie_link_width =\n\t\t\tDECODE_LANE_WIDTH(link_width_level);\n\t\tgpu_metrics->pcie_link_speed =\n\t\t\tsmu_v13_0_6_get_current_pcie_link_speed(smu);\n\t}\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\tgpu_metrics->gfx_activity_acc =\n\t\tSMUQ10_TO_UINT(metrics->SocketGfxBusyAcc);\n\tgpu_metrics->mem_activity_acc =\n\t\tSMUQ10_TO_UINT(metrics->DramBandwidthUtilizationAcc);\n\n\tgpu_metrics->firmware_timestamp = metrics->Timestamp;\n\n\t*table = (void *)gpu_metrics;\n\tkfree(metrics);\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic int smu_v13_0_6_mode2_reset(struct smu_context *smu)\n{\n\tint ret = 0, index;\n\tstruct amdgpu_device *adev = smu->adev;\n\tint timeout = 10;\n\n\tindex = smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG,\n\t\t\t\t\t       SMU_MSG_GfxDeviceDriverReset);\n\n\tmutex_lock(&smu->message_lock);\n\n\tret = smu_cmn_send_msg_without_waiting(smu, (uint16_t)index,\n\t\t\t\t\t       SMU_RESET_MODE_2);\n\n\t \n\tmsleep(100);\n\n\tdev_dbg(smu->adev->dev, \"restore config space...\\n\");\n\t \n\tamdgpu_device_load_pci_state(adev->pdev);\n\n\tdev_dbg(smu->adev->dev, \"wait for reset ack\\n\");\n\tdo {\n\t\tret = smu_cmn_wait_for_response(smu);\n\t\t \n\t\tif (ret == -ETIME) {\n\t\t\t--timeout;\n\t\t\tusleep_range(500, 1000);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev,\n\t\t\t\t\"failed to send mode2 message \\tparam: 0x%08x error code %d\\n\",\n\t\t\t\tSMU_RESET_MODE_2, ret);\n\t\t\tgoto out;\n\t\t}\n\t} while (ret == -ETIME && timeout);\n\nout:\n\tmutex_unlock(&smu->message_lock);\n\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_get_thermal_temperature_range(struct smu_context *smu,\n\t\t\t\t\t\t     struct smu_temperature_range *range)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tu32 aid_temp, xcd_temp, mem_temp;\n\tuint32_t smu_version;\n\tu32 ccd_temp = 0;\n\tint ret;\n\n\tif (amdgpu_sriov_vf(smu->adev))\n\t\treturn 0;\n\n\tif (!range)\n\t\treturn -EINVAL;\n\n\t \n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (smu_version < 0x554500)\n\t\treturn 0;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetCTFLimit,\n\t\t\t\t\t      PPSMC_AID_THM_TYPE, &aid_temp);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (adev->flags & AMD_IS_APU) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetCTFLimit,\n\t\t\t\t\t\t      PPSMC_CCD_THM_TYPE, &ccd_temp);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetCTFLimit,\n\t\t\t\t\t      PPSMC_XCD_THM_TYPE, &xcd_temp);\n\tif (ret)\n\t\tgoto failed;\n\n\trange->hotspot_crit_max = max3(aid_temp, xcd_temp, ccd_temp) *\n\t\t\t\t       SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetCTFLimit,\n\t\t\t\t\t      PPSMC_HBM_THM_TYPE, &mem_temp);\n\tif (ret)\n\t\tgoto failed;\n\n\trange->mem_crit_max = mem_temp * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\nfailed:\n\treturn ret;\n}\n\nstatic int smu_v13_0_6_mode1_reset(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_ras *ras;\n\tu32 fatal_err, param;\n\tint ret = 0;\n\n\tras = amdgpu_ras_get_context(adev);\n\tfatal_err = 0;\n\tparam = SMU_RESET_MODE_1;\n\n\t \n\tif (ras && atomic_read(&ras->in_recovery))\n\t\tfatal_err = 1;\n\n\tparam |= (fatal_err << 16);\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GfxDeviceDriverReset,\n\t\t\t\t\t      param, NULL);\n\n\tif (!ret)\n\t\tmsleep(SMU13_MODE1_RESET_WAIT_TIME_IN_MS);\n\n\treturn ret;\n}\n\nstatic bool smu_v13_0_6_is_mode1_reset_supported(struct smu_context *smu)\n{\n\treturn true;\n}\n\nstatic bool smu_v13_0_6_is_mode2_reset_supported(struct smu_context *smu)\n{\n\treturn true;\n}\n\nstatic int smu_v13_0_6_smu_send_hbm_bad_page_num(struct smu_context *smu,\n\t\t\t\t\t\t uint32_t size)\n{\n\tint ret = 0;\n\n\t \n\tret = smu_cmn_send_smc_msg_with_param(\n\t\tsmu, SMU_MSG_SetNumBadHbmPagesRetired, size, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev,\n\t\t\t\"[%s] failed to message SMU to update HBM bad pages number\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\nstatic const struct pptable_funcs smu_v13_0_6_ppt_funcs = {\n\t \n\t.get_allowed_feature_mask = smu_v13_0_6_get_allowed_feature_mask,\n\t \n\t.set_default_dpm_table = smu_v13_0_6_set_default_dpm_table,\n\t.populate_umd_state_clk = smu_v13_0_6_populate_umd_state_clk,\n\t.print_clk_levels = smu_v13_0_6_print_clk_levels,\n\t.force_clk_levels = smu_v13_0_6_force_clk_levels,\n\t.read_sensor = smu_v13_0_6_read_sensor,\n\t.set_performance_level = smu_v13_0_6_set_performance_level,\n\t.get_power_limit = smu_v13_0_6_get_power_limit,\n\t.is_dpm_running = smu_v13_0_6_is_dpm_running,\n\t.get_unique_id = smu_v13_0_6_get_unique_id,\n\t.init_smc_tables = smu_v13_0_6_init_smc_tables,\n\t.fini_smc_tables = smu_v13_0_fini_smc_tables,\n\t.init_power = smu_v13_0_init_power,\n\t.fini_power = smu_v13_0_fini_power,\n\t.check_fw_status = smu_v13_0_6_check_fw_status,\n\t \n\t.check_fw_version = smu_v13_0_check_fw_version,\n\t.set_driver_table_location = smu_v13_0_set_driver_table_location,\n\t.set_tool_table_location = smu_v13_0_set_tool_table_location,\n\t.notify_memory_pool_location = smu_v13_0_notify_memory_pool_location,\n\t.system_features_control = smu_v13_0_6_system_features_control,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.get_enabled_mask = smu_v13_0_6_get_enabled_mask,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.set_power_limit = smu_v13_0_6_set_power_limit,\n\t.set_xgmi_pstate = smu_v13_0_set_xgmi_pstate,\n\t.register_irq_handler = smu_v13_0_6_register_irq_handler,\n\t.enable_thermal_alert = smu_v13_0_enable_thermal_alert,\n\t.disable_thermal_alert = smu_v13_0_disable_thermal_alert,\n\t.setup_pptable = smu_v13_0_6_setup_pptable,\n\t.baco_is_support = smu_v13_0_6_is_baco_supported,\n\t.get_dpm_ultimate_freq = smu_v13_0_6_get_dpm_ultimate_freq,\n\t.set_soft_freq_limited_range = smu_v13_0_6_set_soft_freq_limited_range,\n\t.od_edit_dpm_table = smu_v13_0_6_usr_edit_dpm_table,\n\t.set_df_cstate = smu_v13_0_6_set_df_cstate,\n\t.allow_xgmi_power_down = smu_v13_0_6_allow_xgmi_power_down,\n\t.log_thermal_throttling_event = smu_v13_0_6_log_thermal_throttling_event,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_pp_feature_mask = smu_cmn_set_pp_feature_mask,\n\t.get_gpu_metrics = smu_v13_0_6_get_gpu_metrics,\n\t.get_thermal_temperature_range = smu_v13_0_6_get_thermal_temperature_range,\n\t.mode1_reset_is_support = smu_v13_0_6_is_mode1_reset_supported,\n\t.mode2_reset_is_support = smu_v13_0_6_is_mode2_reset_supported,\n\t.mode1_reset = smu_v13_0_6_mode1_reset,\n\t.mode2_reset = smu_v13_0_6_mode2_reset,\n\t.wait_for_event = smu_v13_0_wait_for_event,\n\t.i2c_init = smu_v13_0_6_i2c_control_init,\n\t.i2c_fini = smu_v13_0_6_i2c_control_fini,\n\t.send_hbm_bad_pages_num = smu_v13_0_6_smu_send_hbm_bad_page_num,\n};\n\nvoid smu_v13_0_6_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &smu_v13_0_6_ppt_funcs;\n\tsmu->message_map = smu_v13_0_6_message_map;\n\tsmu->clock_map = smu_v13_0_6_clk_map;\n\tsmu->feature_map = smu_v13_0_6_feature_mask_map;\n\tsmu->table_map = smu_v13_0_6_table_map;\n\tsmu->smc_driver_if_version = SMU13_0_6_DRIVER_IF_VERSION;\n\tsmu_v13_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}