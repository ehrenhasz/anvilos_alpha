{
  "module_name": "navi10_ppt.c",
  "hash_id": "9b0ab7d2eda23c5b067b98663f2fb1269a36361017f0a8dab03edbdaec31ac16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu11/navi10_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/i2c.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_dpm.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"soc15_common.h\"\n#include \"smu_v11_0.h\"\n#include \"smu11_driver_if_navi10.h\"\n#include \"atom.h\"\n#include \"navi10_ppt.h\"\n#include \"smu_v11_0_pptable.h\"\n#include \"smu_v11_0_ppsmc.h\"\n#include \"nbio/nbio_2_3_offset.h\"\n#include \"nbio/nbio_2_3_sh_mask.h\"\n#include \"thm/thm_11_0_2_offset.h\"\n#include \"thm/thm_11_0_2_sh_mask.h\"\n\n#include \"asic_reg/mp/mp_11_0_sh_mask.h\"\n#include \"smu_cmn.h\"\n#include \"smu_11_0_cdr_table.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_DPM_PREFETCHER_BIT) | \\\n\tFEATURE_MASK(FEATURE_DPM_GFXCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_GFX_PACE_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_UCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_SOCCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_MP0CLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_LINK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_DCEFCLK_BIT))\n\n#define SMU_11_0_GFX_BUSY_THRESHOLD 15\n\nstatic struct cmn2asic_msg_mapping navi10_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,\t\t\tPPSMC_MSG_TestMessage,\t\t\t1),\n\tMSG_MAP(GetSmuVersion,\t\t\tPPSMC_MSG_GetSmuVersion,\t\t1),\n\tMSG_MAP(GetDriverIfVersion,\t\tPPSMC_MSG_GetDriverIfVersion,\t\t1),\n\tMSG_MAP(SetAllowedFeaturesMaskLow,\tPPSMC_MSG_SetAllowedFeaturesMaskLow,\t0),\n\tMSG_MAP(SetAllowedFeaturesMaskHigh,\tPPSMC_MSG_SetAllowedFeaturesMaskHigh,\t0),\n\tMSG_MAP(EnableAllSmuFeatures,\t\tPPSMC_MSG_EnableAllSmuFeatures,\t\t0),\n\tMSG_MAP(DisableAllSmuFeatures,\t\tPPSMC_MSG_DisableAllSmuFeatures,\t0),\n\tMSG_MAP(EnableSmuFeaturesLow,\t\tPPSMC_MSG_EnableSmuFeaturesLow,\t\t0),\n\tMSG_MAP(EnableSmuFeaturesHigh,\t\tPPSMC_MSG_EnableSmuFeaturesHigh,\t0),\n\tMSG_MAP(DisableSmuFeaturesLow,\t\tPPSMC_MSG_DisableSmuFeaturesLow,\t0),\n\tMSG_MAP(DisableSmuFeaturesHigh,\t\tPPSMC_MSG_DisableSmuFeaturesHigh,\t0),\n\tMSG_MAP(GetEnabledSmuFeaturesLow,\tPPSMC_MSG_GetEnabledSmuFeaturesLow,\t1),\n\tMSG_MAP(GetEnabledSmuFeaturesHigh,\tPPSMC_MSG_GetEnabledSmuFeaturesHigh,\t1),\n\tMSG_MAP(SetWorkloadMask,\t\tPPSMC_MSG_SetWorkloadMask,\t\t0),\n\tMSG_MAP(SetPptLimit,\t\t\tPPSMC_MSG_SetPptLimit,\t\t\t0),\n\tMSG_MAP(SetDriverDramAddrHigh,\t\tPPSMC_MSG_SetDriverDramAddrHigh,\t1),\n\tMSG_MAP(SetDriverDramAddrLow,\t\tPPSMC_MSG_SetDriverDramAddrLow,\t\t1),\n\tMSG_MAP(SetToolsDramAddrHigh,\t\tPPSMC_MSG_SetToolsDramAddrHigh,\t\t0),\n\tMSG_MAP(SetToolsDramAddrLow,\t\tPPSMC_MSG_SetToolsDramAddrLow,\t\t0),\n\tMSG_MAP(TransferTableSmu2Dram,\t\tPPSMC_MSG_TransferTableSmu2Dram,\t1),\n\tMSG_MAP(TransferTableDram2Smu,\t\tPPSMC_MSG_TransferTableDram2Smu,\t0),\n\tMSG_MAP(UseDefaultPPTable,\t\tPPSMC_MSG_UseDefaultPPTable,\t\t0),\n\tMSG_MAP(UseBackupPPTable,\t\tPPSMC_MSG_UseBackupPPTable,\t\t0),\n\tMSG_MAP(RunBtc,\t\t\t\tPPSMC_MSG_RunBtc,\t\t\t0),\n\tMSG_MAP(EnterBaco,\t\t\tPPSMC_MSG_EnterBaco,\t\t\t0),\n\tMSG_MAP(SetSoftMinByFreq,\t\tPPSMC_MSG_SetSoftMinByFreq,\t\t1),\n\tMSG_MAP(SetSoftMaxByFreq,\t\tPPSMC_MSG_SetSoftMaxByFreq,\t\t1),\n\tMSG_MAP(SetHardMinByFreq,\t\tPPSMC_MSG_SetHardMinByFreq,\t\t0),\n\tMSG_MAP(SetHardMaxByFreq,\t\tPPSMC_MSG_SetHardMaxByFreq,\t\t0),\n\tMSG_MAP(GetMinDpmFreq,\t\t\tPPSMC_MSG_GetMinDpmFreq,\t\t1),\n\tMSG_MAP(GetMaxDpmFreq,\t\t\tPPSMC_MSG_GetMaxDpmFreq,\t\t1),\n\tMSG_MAP(GetDpmFreqByIndex,\t\tPPSMC_MSG_GetDpmFreqByIndex,\t\t1),\n\tMSG_MAP(SetMemoryChannelConfig,\t\tPPSMC_MSG_SetMemoryChannelConfig,\t0),\n\tMSG_MAP(SetGeminiMode,\t\t\tPPSMC_MSG_SetGeminiMode,\t\t0),\n\tMSG_MAP(SetGeminiApertureHigh,\t\tPPSMC_MSG_SetGeminiApertureHigh,\t0),\n\tMSG_MAP(SetGeminiApertureLow,\t\tPPSMC_MSG_SetGeminiApertureLow,\t\t0),\n\tMSG_MAP(OverridePcieParameters,\t\tPPSMC_MSG_OverridePcieParameters,\t0),\n\tMSG_MAP(SetMinDeepSleepDcefclk,\t\tPPSMC_MSG_SetMinDeepSleepDcefclk,\t0),\n\tMSG_MAP(ReenableAcDcInterrupt,\t\tPPSMC_MSG_ReenableAcDcInterrupt,\t0),\n\tMSG_MAP(NotifyPowerSource,\t\tPPSMC_MSG_NotifyPowerSource,\t\t0),\n\tMSG_MAP(SetUclkFastSwitch,\t\tPPSMC_MSG_SetUclkFastSwitch,\t\t0),\n\tMSG_MAP(SetVideoFps,\t\t\tPPSMC_MSG_SetVideoFps,\t\t\t0),\n\tMSG_MAP(PrepareMp1ForUnload,\t\tPPSMC_MSG_PrepareMp1ForUnload,\t\t1),\n\tMSG_MAP(DramLogSetDramAddrHigh,\t\tPPSMC_MSG_DramLogSetDramAddrHigh,\t0),\n\tMSG_MAP(DramLogSetDramAddrLow,\t\tPPSMC_MSG_DramLogSetDramAddrLow,\t0),\n\tMSG_MAP(DramLogSetDramSize,\t\tPPSMC_MSG_DramLogSetDramSize,\t\t0),\n\tMSG_MAP(ConfigureGfxDidt,\t\tPPSMC_MSG_ConfigureGfxDidt,\t\t0),\n\tMSG_MAP(NumOfDisplays,\t\t\tPPSMC_MSG_NumOfDisplays,\t\t0),\n\tMSG_MAP(SetSystemVirtualDramAddrHigh,\tPPSMC_MSG_SetSystemVirtualDramAddrHigh,\t0),\n\tMSG_MAP(SetSystemVirtualDramAddrLow,\tPPSMC_MSG_SetSystemVirtualDramAddrLow,\t0),\n\tMSG_MAP(AllowGfxOff,\t\t\tPPSMC_MSG_AllowGfxOff,\t\t\t0),\n\tMSG_MAP(DisallowGfxOff,\t\t\tPPSMC_MSG_DisallowGfxOff,\t\t0),\n\tMSG_MAP(GetPptLimit,\t\t\tPPSMC_MSG_GetPptLimit,\t\t\t0),\n\tMSG_MAP(GetDcModeMaxDpmFreq,\t\tPPSMC_MSG_GetDcModeMaxDpmFreq,\t\t1),\n\tMSG_MAP(GetDebugData,\t\t\tPPSMC_MSG_GetDebugData,\t\t\t0),\n\tMSG_MAP(ExitBaco,\t\t\tPPSMC_MSG_ExitBaco,\t\t\t0),\n\tMSG_MAP(PrepareMp1ForReset,\t\tPPSMC_MSG_PrepareMp1ForReset,\t\t0),\n\tMSG_MAP(PrepareMp1ForShutdown,\t\tPPSMC_MSG_PrepareMp1ForShutdown,\t0),\n\tMSG_MAP(PowerUpVcn,\t\t\tPPSMC_MSG_PowerUpVcn,\t\t\t0),\n\tMSG_MAP(PowerDownVcn,\t\t\tPPSMC_MSG_PowerDownVcn,\t\t\t0),\n\tMSG_MAP(PowerUpJpeg,\t\t\tPPSMC_MSG_PowerUpJpeg,\t\t\t0),\n\tMSG_MAP(PowerDownJpeg,\t\t\tPPSMC_MSG_PowerDownJpeg,\t\t0),\n\tMSG_MAP(BacoAudioD3PME,\t\t\tPPSMC_MSG_BacoAudioD3PME,\t\t0),\n\tMSG_MAP(ArmD3,\t\t\t\tPPSMC_MSG_ArmD3,\t\t\t0),\n\tMSG_MAP(DAL_DISABLE_DUMMY_PSTATE_CHANGE, PPSMC_MSG_DALDisableDummyPstateChange,\t0),\n\tMSG_MAP(DAL_ENABLE_DUMMY_PSTATE_CHANGE,\tPPSMC_MSG_DALEnableDummyPstateChange,\t0),\n\tMSG_MAP(GetVoltageByDpm,\t\tPPSMC_MSG_GetVoltageByDpm,\t\t0),\n\tMSG_MAP(GetVoltageByDpmOverdrive,\tPPSMC_MSG_GetVoltageByDpmOverdrive,\t0),\n\tMSG_MAP(SetMGpuFanBoostLimitRpm,\tPPSMC_MSG_SetMGpuFanBoostLimitRpm,\t0),\n\tMSG_MAP(SET_DRIVER_DUMMY_TABLE_DRAM_ADDR_HIGH, PPSMC_MSG_SetDriverDummyTableDramAddrHigh, 0),\n\tMSG_MAP(SET_DRIVER_DUMMY_TABLE_DRAM_ADDR_LOW, PPSMC_MSG_SetDriverDummyTableDramAddrLow, 0),\n\tMSG_MAP(GET_UMC_FW_WA,\t\t\tPPSMC_MSG_GetUMCFWWA,\t\t\t0),\n};\n\nstatic struct cmn2asic_mapping navi10_clk_map[SMU_CLK_COUNT] = {\n\tCLK_MAP(GFXCLK, PPCLK_GFXCLK),\n\tCLK_MAP(SCLK,\tPPCLK_GFXCLK),\n\tCLK_MAP(SOCCLK, PPCLK_SOCCLK),\n\tCLK_MAP(FCLK, PPCLK_SOCCLK),\n\tCLK_MAP(UCLK, PPCLK_UCLK),\n\tCLK_MAP(MCLK, PPCLK_UCLK),\n\tCLK_MAP(DCLK, PPCLK_DCLK),\n\tCLK_MAP(VCLK, PPCLK_VCLK),\n\tCLK_MAP(DCEFCLK, PPCLK_DCEFCLK),\n\tCLK_MAP(DISPCLK, PPCLK_DISPCLK),\n\tCLK_MAP(PIXCLK, PPCLK_PIXCLK),\n\tCLK_MAP(PHYCLK, PPCLK_PHYCLK),\n};\n\nstatic struct cmn2asic_mapping navi10_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(DPM_PREFETCHER),\n\tFEA_MAP(DPM_GFXCLK),\n\tFEA_MAP(DPM_GFX_PACE),\n\tFEA_MAP(DPM_UCLK),\n\tFEA_MAP(DPM_SOCCLK),\n\tFEA_MAP(DPM_MP0CLK),\n\tFEA_MAP(DPM_LINK),\n\tFEA_MAP(DPM_DCEFCLK),\n\tFEA_MAP(MEM_VDDCI_SCALING),\n\tFEA_MAP(MEM_MVDD_SCALING),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_DCEFCLK),\n\tFEA_MAP(DS_UCLK),\n\tFEA_MAP(GFX_ULV),\n\tFEA_MAP(FW_DSTATE),\n\tFEA_MAP(GFXOFF),\n\tFEA_MAP(BACO),\n\tFEA_MAP(VCN_PG),\n\tFEA_MAP(JPEG_PG),\n\tFEA_MAP(USB_PG),\n\tFEA_MAP(RSMU_SMN_CG),\n\tFEA_MAP(PPT),\n\tFEA_MAP(TDC),\n\tFEA_MAP(GFX_EDC),\n\tFEA_MAP(APCC_PLUS),\n\tFEA_MAP(GTHR),\n\tFEA_MAP(ACDC),\n\tFEA_MAP(VR0HOT),\n\tFEA_MAP(VR1HOT),\n\tFEA_MAP(FW_CTF),\n\tFEA_MAP(FAN_CONTROL),\n\tFEA_MAP(THERMAL),\n\tFEA_MAP(GFX_DCS),\n\tFEA_MAP(RM),\n\tFEA_MAP(LED_DISPLAY),\n\tFEA_MAP(GFX_SS),\n\tFEA_MAP(OUT_OF_BAND_MONITOR),\n\tFEA_MAP(TEMP_DEPENDENT_VMIN),\n\tFEA_MAP(MMHUB_PG),\n\tFEA_MAP(ATHUB_PG),\n\tFEA_MAP(APCC_DFLL),\n};\n\nstatic struct cmn2asic_mapping navi10_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP(PPTABLE),\n\tTAB_MAP(WATERMARKS),\n\tTAB_MAP(AVFS),\n\tTAB_MAP(AVFS_PSM_DEBUG),\n\tTAB_MAP(AVFS_FUSE_OVERRIDE),\n\tTAB_MAP(PMSTATUSLOG),\n\tTAB_MAP(SMU_METRICS),\n\tTAB_MAP(DRIVER_SMU_CONFIG),\n\tTAB_MAP(ACTIVITY_MONITOR_COEFF),\n\tTAB_MAP(OVERDRIVE),\n\tTAB_MAP(I2C_COMMANDS),\n\tTAB_MAP(PACE),\n};\n\nstatic struct cmn2asic_mapping navi10_pwr_src_map[SMU_POWER_SOURCE_COUNT] = {\n\tPWR_MAP(AC),\n\tPWR_MAP(DC),\n};\n\nstatic struct cmn2asic_mapping navi10_workload_map[PP_SMC_POWER_PROFILE_COUNT] = {\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT,\tWORKLOAD_PPLIB_DEFAULT_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_FULLSCREEN3D,\t\tWORKLOAD_PPLIB_FULL_SCREEN_3D_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_POWERSAVING,\t\tWORKLOAD_PPLIB_POWER_SAVING_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VIDEO,\t\tWORKLOAD_PPLIB_VIDEO_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VR,\t\t\tWORKLOAD_PPLIB_VR_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_COMPUTE,\t\tWORKLOAD_PPLIB_COMPUTE_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CUSTOM,\t\tWORKLOAD_PPLIB_CUSTOM_BIT),\n};\n\nstatic const uint8_t navi1x_throttler_map[] = {\n\t[THROTTLER_TEMP_EDGE_BIT]\t= (SMU_THROTTLER_TEMP_EDGE_BIT),\n\t[THROTTLER_TEMP_HOTSPOT_BIT]\t= (SMU_THROTTLER_TEMP_HOTSPOT_BIT),\n\t[THROTTLER_TEMP_MEM_BIT]\t= (SMU_THROTTLER_TEMP_MEM_BIT),\n\t[THROTTLER_TEMP_VR_GFX_BIT]\t= (SMU_THROTTLER_TEMP_VR_GFX_BIT),\n\t[THROTTLER_TEMP_VR_MEM0_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM0_BIT),\n\t[THROTTLER_TEMP_VR_MEM1_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM1_BIT),\n\t[THROTTLER_TEMP_VR_SOC_BIT]\t= (SMU_THROTTLER_TEMP_VR_SOC_BIT),\n\t[THROTTLER_TEMP_LIQUID0_BIT]\t= (SMU_THROTTLER_TEMP_LIQUID0_BIT),\n\t[THROTTLER_TEMP_LIQUID1_BIT]\t= (SMU_THROTTLER_TEMP_LIQUID1_BIT),\n\t[THROTTLER_TDC_GFX_BIT]\t\t= (SMU_THROTTLER_TDC_GFX_BIT),\n\t[THROTTLER_TDC_SOC_BIT]\t\t= (SMU_THROTTLER_TDC_SOC_BIT),\n\t[THROTTLER_PPT0_BIT]\t\t= (SMU_THROTTLER_PPT0_BIT),\n\t[THROTTLER_PPT1_BIT]\t\t= (SMU_THROTTLER_PPT1_BIT),\n\t[THROTTLER_PPT2_BIT]\t\t= (SMU_THROTTLER_PPT2_BIT),\n\t[THROTTLER_PPT3_BIT]\t\t= (SMU_THROTTLER_PPT3_BIT),\n\t[THROTTLER_FIT_BIT]\t\t= (SMU_THROTTLER_FIT_BIT),\n\t[THROTTLER_PPM_BIT]\t\t= (SMU_THROTTLER_PPM_BIT),\n\t[THROTTLER_APCC_BIT]\t\t= (SMU_THROTTLER_APCC_BIT),\n};\n\n\nstatic bool is_asic_secure(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tbool is_secure = true;\n\tuint32_t mp0_fw_intf;\n\n\tmp0_fw_intf = RREG32_PCIE(MP0_Public |\n\t\t\t\t   (smnMP0_FW_INTF & 0xffffffff));\n\n\tif (!(mp0_fw_intf & (1 << 19)))\n\t\tis_secure = false;\n\n\treturn is_secure;\n}\n\nstatic int\nnavi10_get_allowed_feature_mask(struct smu_context *smu,\n\t\t\t\t  uint32_t *feature_mask, uint32_t num)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tmemset(feature_mask, 0, sizeof(uint32_t) * num);\n\n\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_PREFETCHER_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DPM_MP0CLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_RSMU_SMN_CG_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_SOCCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_PPT_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_TDC_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_GFX_EDC_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_APCC_PLUS_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_VR0HOT_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_FAN_CONTROL_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_THERMAL_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_LED_DISPLAY_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_LCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_DCEFCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_FW_DSTATE_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_BACO_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_GFX_SS_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_APCC_DFLL_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_FW_CTF_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_OUT_OF_BAND_MONITOR_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_TEMP_DEPENDENT_VMIN_BIT);\n\n\tif (adev->pm.pp_feature & PP_SCLK_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_GFXCLK_BIT);\n\n\tif (adev->pm.pp_feature & PP_PCIE_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_LINK_BIT);\n\n\tif (adev->pm.pp_feature & PP_DCEFCLK_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_DCEFCLK_BIT);\n\n\tif (adev->pm.pp_feature & PP_ULV_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_GFX_ULV_BIT);\n\n\tif (adev->pm.pp_feature & PP_SCLK_DEEP_SLEEP_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DS_GFXCLK_BIT);\n\n\tif (adev->pm.pp_feature & PP_GFXOFF_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_GFXOFF_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_MMHUB)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_MMHUB_PG_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_ATHUB)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_ATHUB_PG_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_VCN)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_VCN_PG_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_JPEG)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_JPEG_PG_BIT);\n\n\tif (smu->dc_controlled_by_gpio)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_ACDC_BIT);\n\n\tif (adev->pm.pp_feature & PP_SOCCLK_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_SOCCLK_BIT);\n\n\t \n\tif (!(is_asic_secure(smu) &&\n\t     (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0)) &&\n\t     (adev->rev_id == 0)) &&\n\t    (adev->pm.pp_feature & PP_MCLK_DPM_MASK))\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_UCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_MEM_VDDCI_SCALING_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_MEM_MVDD_SCALING_BIT);\n\n\t \n\tif (is_asic_secure(smu) &&\n\t    (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0)) &&\n\t    (adev->rev_id == 0))\n\t\t*(uint64_t *)feature_mask &=\n\t\t\t\t~FEATURE_MASK(FEATURE_DS_SOCCLK_BIT);\n\n\treturn 0;\n}\n\nstatic void navi10_check_bxco_support(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t val;\n\n\tif (powerplay_table->platform_caps & SMU_11_0_PP_PLATFORM_CAP_BACO ||\n\t    powerplay_table->platform_caps & SMU_11_0_PP_PLATFORM_CAP_MACO) {\n\t\tval = RREG32_SOC15(NBIO, 0, mmRCC_BIF_STRAP0);\n\t\tsmu_baco->platform_support =\n\t\t\t(val & RCC_BIF_STRAP0__STRAP_PX_CAPABLE_MASK) ? true :\n\t\t\t\t\t\t\t\t\tfalse;\n\t}\n}\n\nstatic int navi10_check_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\n\tif (powerplay_table->platform_caps & SMU_11_0_PP_PLATFORM_CAP_HARDWAREDC)\n\t\tsmu->dc_controlled_by_gpio = true;\n\n\tnavi10_check_bxco_support(smu);\n\n\ttable_context->thermal_controller_type =\n\t\tpowerplay_table->thermal_controller_type;\n\n\t \n\tsmu->od_settings = &powerplay_table->overdrive_table;\n\n\treturn 0;\n}\n\nstatic int navi10_append_powerplay_table(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *smc_pptable = table_context->driver_pptable;\n\tstruct atom_smc_dpm_info_v4_5 *smc_dpm_table;\n\tstruct atom_smc_dpm_info_v4_7 *smc_dpm_table_v4_7;\n\tint index, ret;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t   smc_dpm_info);\n\n\tret = amdgpu_atombios_get_data_table(adev, index, NULL, NULL, NULL,\n\t\t\t\t      (uint8_t **)&smc_dpm_table);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(adev->dev, \"smc_dpm_info table revision(format.content): %d.%d\\n\",\n\t\t\tsmc_dpm_table->table_header.format_revision,\n\t\t\tsmc_dpm_table->table_header.content_revision);\n\n\tif (smc_dpm_table->table_header.format_revision != 4) {\n\t\tdev_err(adev->dev, \"smc_dpm_info table format revision is not 4!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (smc_dpm_table->table_header.content_revision) {\n\tcase 5:  \n\t\tsmu_memcpy_trailing(smc_pptable, I2cControllers, BoardReserved,\n\t\t\t\t    smc_dpm_table, I2cControllers);\n\t\tbreak;\n\tcase 7:  \n\t\tret = amdgpu_atombios_get_data_table(adev, index, NULL, NULL, NULL,\n\t\t\t\t\t      (uint8_t **)&smc_dpm_table_v4_7);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsmu_memcpy_trailing(smc_pptable, I2cControllers, BoardReserved,\n\t\t\t\t    smc_dpm_table_v4_7, I2cControllers);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(smu->adev->dev, \"smc_dpm_info with unsupported content revision %d!\\n\",\n\t\t\t\tsmc_dpm_table->table_header.content_revision);\n\t\treturn -EINVAL;\n\t}\n\n\tif (adev->pm.pp_feature & PP_GFXOFF_MASK) {\n\t\t \n\t\tsmc_pptable->DebugOverrides |= DPM_OVERRIDE_DISABLE_DFLL_PLL_SHUTDOWN;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_store_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\n\tmemcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       sizeof(PPTable_t));\n\n\treturn 0;\n}\n\nstatic int navi10_setup_pptable(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v11_0_setup_pptable(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = navi10_store_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = navi10_append_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = navi10_check_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int navi10_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\tstruct smu_table *dummy_read_1_table =\n\t\t\t&smu_table->dummy_read_1_table;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PPTABLE, sizeof(PPTable_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_NV1X_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_I2C_COMMANDS, sizeof(SwI2cRequest_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_OVERDRIVE, sizeof(OverDriveTable_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PMSTATUSLOG, SMU11_TOOL_SIZE,\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t       sizeof(DpmActivityMonitorCoeffInt_t), PAGE_SIZE,\n\t\t       AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_DRIVER_SMU_CONFIG, sizeof(DriverSmuConfig_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tdummy_read_1_table->size = 0x40000;\n\tdummy_read_1_table->align = PAGE_SIZE;\n\tdummy_read_1_table->domain = AMDGPU_GEM_DOMAIN_VRAM;\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_NV1X_t),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err0_out;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v1_3);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err1_out;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->driver_smu_config_table =\n\t\tkzalloc(tables[SMU_TABLE_DRIVER_SMU_CONFIG].size, GFP_KERNEL);\n\tif (!smu_table->driver_smu_config_table)\n\t\tgoto err3_out;\n\n\treturn 0;\n\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->gpu_metrics_table);\nerr1_out:\n\tkfree(smu_table->metrics_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic int navi10_get_legacy_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t      MetricsMember_t member,\n\t\t\t\t\t      uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_legacy_t *metrics =\n\t\t(SmuMetrics_legacy_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCEFCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCEFCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\t*value = metrics->AverageGfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->AverageSocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->AverageUclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = metrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = metrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->TemperatureEdge *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->TemperatureHotspot *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = metrics->TemperatureMem *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = metrics->TemperatureVrGfx *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = metrics->TemperatureVrSoc *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = metrics->CurrFanSpeed;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_t *metrics =\n\t\t(SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCEFCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCEFCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\tif (metrics->AverageGfxActivity > SMU_11_0_GFX_BUSY_THRESHOLD)\n\t\t\t*value = metrics->AverageGfxclkFrequencyPreDs;\n\t\telse\n\t\t\t*value = metrics->AverageGfxclkFrequencyPostDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->AverageSocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->AverageUclkFrequencyPostDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = metrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = metrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->TemperatureEdge *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->TemperatureHotspot *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = metrics->TemperatureMem *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = metrics->TemperatureVrGfx *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = metrics->TemperatureVrSoc *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = metrics->CurrFanSpeed;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi12_get_legacy_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t      MetricsMember_t member,\n\t\t\t\t\t      uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_NV12_legacy_t *metrics =\n\t\t(SmuMetrics_NV12_legacy_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCEFCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCEFCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\t*value = metrics->AverageGfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->AverageSocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->AverageUclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = metrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = metrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->TemperatureEdge *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->TemperatureHotspot *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = metrics->TemperatureMem *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = metrics->TemperatureVrGfx *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = metrics->TemperatureVrSoc *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = metrics->CurrFanSpeed;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi12_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_NV12_t *metrics =\n\t\t(SmuMetrics_NV12_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->CurrClock[PPCLK_VCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCLK];\n\t\tbreak;\n\tcase METRICS_CURR_DCEFCLK:\n\t\t*value = metrics->CurrClock[PPCLK_DCEFCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\tif (metrics->AverageGfxActivity > SMU_11_0_GFX_BUSY_THRESHOLD)\n\t\t\t*value = metrics->AverageGfxclkFrequencyPreDs;\n\t\telse\n\t\t\t*value = metrics->AverageGfxclkFrequencyPostDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->AverageSocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->AverageUclkFrequencyPostDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = metrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = metrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->TemperatureEdge *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->TemperatureHotspot *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = metrics->TemperatureMem *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = metrics->TemperatureVrGfx *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = metrics->TemperatureVrSoc *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = metrics->CurrFanSpeed;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi1x_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t smu_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 9):\n\t\tif (smu_version > 0x00341C00)\n\t\t\tret = navi12_get_smu_metrics_data(smu, member, value);\n\t\telse\n\t\t\tret = navi12_get_legacy_smu_metrics_data(smu, member, value);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 5):\n\tdefault:\n\t\tif (((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 5)) && smu_version > 0x00351F00) ||\n\t\t      ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0)) && smu_version > 0x002A3B00))\n\t\t\tret = navi10_get_smu_metrics_data(smu, member, value);\n\t\telse\n\t\t\tret = navi10_get_legacy_smu_metrics_data(smu, member, value);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_allocate_dpm_context(struct smu_context *smu)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tsmu_dpm->dpm_context = kzalloc(sizeof(struct smu_11_0_dpm_context),\n\t\t\t\t       GFP_KERNEL);\n\tif (!smu_dpm->dpm_context)\n\t\treturn -ENOMEM;\n\n\tsmu_dpm->dpm_context_size = sizeof(struct smu_11_0_dpm_context);\n\n\treturn 0;\n}\n\nstatic int navi10_init_smc_tables(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = navi10_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = navi10_allocate_dpm_context(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_v11_0_init_smc_tables(smu);\n}\n\nstatic int navi10_set_default_dpm_table(struct smu_context *smu)\n{\n\tstruct smu_11_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tPPTable_t *driver_ppt = smu->smu_table.driver_pptable;\n\tstruct smu_11_0_dpm_table *dpm_table;\n\tint ret = 0;\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.soc_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_SOCCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_SOCCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.socclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.gfx_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_GFXCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_GFXCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.gfxclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.uclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_UCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_UCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.uclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.vclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_VCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_VCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.vclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.dclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_DCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_DCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.dcef_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_DCEFCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_DCEFCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.pixel_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_PIXCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_PIXCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.display_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_DISPCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_DISPCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.phy_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_PHYCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!driver_ppt->DpmDescriptor[PPCLK_PHYCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_dpm_set_vcn_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\t \n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpVcn, 1, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_PowerDownVcn, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_dpm_set_jpeg_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_JPEG_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_PowerUpJpeg, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_JPEG_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_PowerDownJpeg, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_get_current_clk_freq_by_table(struct smu_context *smu,\n\t\t\t\t       enum smu_clk_type clk_type,\n\t\t\t\t       uint32_t *value)\n{\n\tMetricsMember_t member_type;\n\tint clk_id = 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tswitch (clk_id) {\n\tcase PPCLK_GFXCLK:\n\t\tmember_type = METRICS_CURR_GFXCLK;\n\t\tbreak;\n\tcase PPCLK_UCLK:\n\t\tmember_type = METRICS_CURR_UCLK;\n\t\tbreak;\n\tcase PPCLK_SOCCLK:\n\t\tmember_type = METRICS_CURR_SOCCLK;\n\t\tbreak;\n\tcase PPCLK_VCLK:\n\t\tmember_type = METRICS_CURR_VCLK;\n\t\tbreak;\n\tcase PPCLK_DCLK:\n\t\tmember_type = METRICS_CURR_DCLK;\n\t\tbreak;\n\tcase PPCLK_DCEFCLK:\n\t\tmember_type = METRICS_CURR_DCEFCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t   member_type,\n\t\t\t\t\t   value);\n}\n\nstatic bool navi10_is_support_fine_grained_dpm(struct smu_context *smu, enum smu_clk_type clk_type)\n{\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tDpmDescriptor_t *dpm_desc = NULL;\n\tuint32_t clk_index = 0;\n\n\tclk_index = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t   CMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\t   clk_type);\n\tdpm_desc = &pptable->DpmDescriptor[clk_index];\n\n\t \n\treturn dpm_desc->SnapToDiscrete == 0;\n}\n\nstatic inline bool navi10_od_feature_is_supported(struct smu_11_0_overdrive_table *od_table, enum SMU_11_0_ODFEATURE_CAP cap)\n{\n\treturn od_table->cap[cap];\n}\n\nstatic void navi10_od_setting_get_range(struct smu_11_0_overdrive_table *od_table,\n\t\t\t\t\tenum SMU_11_0_ODSETTING_ID setting,\n\t\t\t\t\tuint32_t *min, uint32_t *max)\n{\n\tif (min)\n\t\t*min = od_table->min[setting];\n\tif (max)\n\t\t*max = od_table->max[setting];\n}\n\nstatic int navi10_emit_clk_levels(struct smu_context *smu,\n\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t  char *buf,\n\t\t\t\t  int *offset)\n{\n\tuint16_t *curve_settings;\n\tint ret = 0;\n\tuint32_t cur_value = 0, value = 0;\n\tuint32_t freq_values[3] = {0};\n\tuint32_t i, levels, mark_index = 0, count = 0;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tuint32_t gen_speed, lane_width;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_11_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tPPTable_t *pptable = (PPTable_t *)table_context->driver_pptable;\n\tOverDriveTable_t *od_table =\n\t\t(OverDriveTable_t *)table_context->overdrive_table;\n\tstruct smu_11_0_overdrive_table *od_settings = smu->od_settings;\n\tuint32_t min_value, max_value;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\tcase SMU_DCEFCLK:\n\t\tret = navi10_get_current_clk_freq_by_table(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_v11_0_get_dpm_level_count(smu, clk_type, &count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!navi10_is_support_fine_grained_dpm(smu, clk_type)) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t\t\t      clk_type, i, &value);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t\"%d: %uMhz %s\\n\",\n\t\t\t\t\t\ti, value,\n\t\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t\t      clk_type, 0, &freq_values[0]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t\t      clk_type,\n\t\t\t\t\t\t\t      count - 1,\n\t\t\t\t\t\t\t      &freq_values[2]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tfreq_values[1] = cur_value;\n\t\t\tmark_index = cur_value == freq_values[0] ? 0 :\n\t\t\t\t     cur_value == freq_values[2] ? 2 : 1;\n\n\t\t\tlevels = 3;\n\t\t\tif (mark_index != 1) {\n\t\t\t\tlevels = 2;\n\t\t\t\tfreq_values[1] = freq_values[2];\n\t\t\t}\n\n\t\t\tfor (i = 0; i < levels; i++) {\n\t\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t\"%d: %uMhz %s\\n\",\n\t\t\t\t\t\ti, freq_values[i],\n\t\t\t\t\t\ti == mark_index ? \"*\" : \"\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SMU_PCIE:\n\t\tgen_speed = smu_v11_0_get_current_pcie_link_speed_level(smu);\n\t\tlane_width = smu_v11_0_get_current_pcie_link_width_level(smu);\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %s %s %dMhz %s\\n\", i,\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 1) ? \"x1\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 2) ? \"x2\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 3) ? \"x4\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 4) ? \"x8\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 5) ? \"x12\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 6) ? \"x16\" : \"\",\n\t\t\t\t\tpptable->LclkFreq[i],\n\t\t\t\t\t(gen_speed == dpm_context->dpm_tables.pcie_table.pcie_gen[i]) &&\n\t\t\t\t\t(lane_width == dpm_context->dpm_tables.pcie_table.pcie_lane[i]) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_SCLK:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_LIMITS))\n\t\t\tbreak;\n\t\t*offset += sysfs_emit_at(buf, *offset, \"OD_SCLK:\\n0: %uMhz\\n1: %uMhz\\n\",\n\t\t\t\t\t  od_table->GfxclkFmin, od_table->GfxclkFmax);\n\t\tbreak;\n\tcase SMU_OD_MCLK:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_UCLK_MAX))\n\t\t\tbreak;\n\t\t*offset += sysfs_emit_at(buf, *offset, \"OD_MCLK:\\n1: %uMHz\\n\", od_table->UclkFmax);\n\t\tbreak;\n\tcase SMU_OD_VDDC_CURVE:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_CURVE))\n\t\t\tbreak;\n\t\t*offset += sysfs_emit_at(buf, *offset, \"OD_VDDC_CURVE:\\n\");\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tcurve_settings = &od_table->GfxclkFreq1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcurve_settings = &od_table->GfxclkFreq2;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcurve_settings = &od_table->GfxclkFreq3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %uMHz %umV\\n\",\n\t\t\t\t\t\t  i, curve_settings[0],\n\t\t\t\t\tcurve_settings[1] / NAVI10_VOLTAGE_SCALE);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\treturn -EOPNOTSUPP;\n\t\t*offset += sysfs_emit_at(buf, *offset, \"%s:\\n\", \"OD_RANGE\");\n\n\t\tif (navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_LIMITS)) {\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_GFXCLKFMIN,\n\t\t\t\t\t\t    &min_value, NULL);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_GFXCLKFMAX,\n\t\t\t\t\t\t    NULL, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\tmin_value, max_value);\n\t\t}\n\n\t\tif (navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_UCLK_MAX)) {\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_UCLKFMAX,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"MCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\tmin_value, max_value);\n\t\t}\n\n\t\tif (navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_CURVE)) {\n\t\t\tnavi10_od_setting_get_range(od_settings,\n\t\t\t\t\t\t    SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P1,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t \"VDDC_CURVE_SCLK[0]: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t\t min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings,\n\t\t\t\t\t\t    SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P1,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t \"VDDC_CURVE_VOLT[0]: %7dmV %11dmV\\n\",\n\t\t\t\t\t\t min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings,\n\t\t\t\t\t\t    SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P2,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t \"VDDC_CURVE_SCLK[1]: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t\t min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings,\n\t\t\t\t\t\t    SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P2,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t \"VDDC_CURVE_VOLT[1]: %7dmV %11dmV\\n\",\n\t\t\t\t\t\t min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings,\n\t\t\t\t\t\t    SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P3,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t \"VDDC_CURVE_SCLK[2]: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t\t min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings,\n\t\t\t\t\t\t    SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P3,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\t*offset += sysfs_emit_at(buf, *offset,\n\t\t\t\t\t\t \"VDDC_CURVE_VOLT[2]: %7dmV %11dmV\\n\",\n\t\t\t\t\t\t min_value, max_value);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_print_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tuint16_t *curve_settings;\n\tint i, levels, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0;\n\tuint32_t freq_values[3] = {0};\n\tuint32_t mark_index = 0;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tuint32_t gen_speed, lane_width;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_11_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tPPTable_t *pptable = (PPTable_t *)table_context->driver_pptable;\n\tOverDriveTable_t *od_table =\n\t\t(OverDriveTable_t *)table_context->overdrive_table;\n\tstruct smu_11_0_overdrive_table *od_settings = smu->od_settings;\n\tuint32_t min_value, max_value;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\tcase SMU_DCEFCLK:\n\t\tret = navi10_get_current_clk_freq_by_table(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\treturn size;\n\n\t\tret = smu_v11_0_get_dpm_level_count(smu, clk_type, &count);\n\t\tif (ret)\n\t\t\treturn size;\n\n\t\tif (!navi10_is_support_fine_grained_dpm(smu, clk_type)) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, i, &value);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn size;\n\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, 0, &freq_values[0]);\n\t\t\tif (ret)\n\t\t\t\treturn size;\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, count - 1, &freq_values[2]);\n\t\t\tif (ret)\n\t\t\t\treturn size;\n\n\t\t\tfreq_values[1] = cur_value;\n\t\t\tmark_index = cur_value == freq_values[0] ? 0 :\n\t\t\t\t     cur_value == freq_values[2] ? 2 : 1;\n\n\t\t\tlevels = 3;\n\t\t\tif (mark_index != 1) {\n\t\t\t\tlevels = 2;\n\t\t\t\tfreq_values[1] = freq_values[2];\n\t\t\t}\n\n\t\t\tfor (i = 0; i < levels; i++) {\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, freq_values[i],\n\t\t\t\t\t\ti == mark_index ? \"*\" : \"\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SMU_PCIE:\n\t\tgen_speed = smu_v11_0_get_current_pcie_link_speed_level(smu);\n\t\tlane_width = smu_v11_0_get_current_pcie_link_width_level(smu);\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %s %s %dMhz %s\\n\", i,\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 1) ? \"x1\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 2) ? \"x2\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 3) ? \"x4\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 4) ? \"x8\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 5) ? \"x12\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 6) ? \"x16\" : \"\",\n\t\t\t\t\tpptable->LclkFreq[i],\n\t\t\t\t\t(gen_speed == dpm_context->dpm_tables.pcie_table.pcie_gen[i]) &&\n\t\t\t\t\t(lane_width == dpm_context->dpm_tables.pcie_table.pcie_lane[i]) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\tbreak;\n\tcase SMU_OD_SCLK:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_LIMITS))\n\t\t\tbreak;\n\t\tsize += sysfs_emit_at(buf, size, \"OD_SCLK:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n1: %uMhz\\n\",\n\t\t\t\t      od_table->GfxclkFmin, od_table->GfxclkFmax);\n\t\tbreak;\n\tcase SMU_OD_MCLK:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_UCLK_MAX))\n\t\t\tbreak;\n\t\tsize += sysfs_emit_at(buf, size, \"OD_MCLK:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"1: %uMHz\\n\", od_table->UclkFmax);\n\t\tbreak;\n\tcase SMU_OD_VDDC_CURVE:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_CURVE))\n\t\t\tbreak;\n\t\tsize += sysfs_emit_at(buf, size, \"OD_VDDC_CURVE:\\n\");\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tcurve_settings = &od_table->GfxclkFreq1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tcurve_settings = &od_table->GfxclkFreq2;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcurve_settings = &od_table->GfxclkFreq3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMHz %umV\\n\",\n\t\t\t\t\t      i, curve_settings[0],\n\t\t\t\t\tcurve_settings[1] / NAVI10_VOLTAGE_SCALE);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\n\t\tif (navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_LIMITS)) {\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_GFXCLKFMIN,\n\t\t\t\t\t\t    &min_value, NULL);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_GFXCLKFMAX,\n\t\t\t\t\t\t    NULL, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\tmin_value, max_value);\n\t\t}\n\n\t\tif (navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_UCLK_MAX)) {\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_UCLKFMAX,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"MCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\tmin_value, max_value);\n\t\t}\n\n\t\tif (navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_CURVE)) {\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P1,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE_SCLK[0]: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P1,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE_VOLT[0]: %7dmV %11dmV\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P2,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE_SCLK[1]: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P2,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE_VOLT[1]: %7dmV %11dmV\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P3,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE_SCLK[2]: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t\tnavi10_od_setting_get_range(od_settings, SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P3,\n\t\t\t\t\t\t    &min_value, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"VDDC_CURVE_VOLT[2]: %7dmV %11dmV\\n\",\n\t\t\t\t\t      min_value, max_value);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int navi10_force_clk_levels(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type, uint32_t mask)\n{\n\n\tint ret = 0;\n\tuint32_t soft_min_level = 0, soft_max_level = 0, min_freq = 0, max_freq = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\t\t \n\t\tif (navi10_is_support_fine_grained_dpm(smu, clk_type)) {\n\t\t\tsoft_max_level = (soft_max_level >= 1 ? 1 : 0);\n\t\t\tsoft_min_level = (soft_min_level >= 1 ? 1 : 0);\n\t\t}\n\n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn 0;\n\n\t\tret = smu_v11_0_set_soft_freq_limited_range(smu, clk_type, min_freq, max_freq);\n\t\tif (ret)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase SMU_DCEFCLK:\n\t\tdev_info(smu->adev->dev, \"Setting DCEFCLK min/max dpm level is not supported!\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_populate_umd_state_clk(struct smu_context *smu)\n{\n\tstruct smu_11_0_dpm_context *dpm_context =\n\t\t\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_11_0_dpm_table *gfx_table =\n\t\t\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_11_0_dpm_table *mem_table =\n\t\t\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_11_0_dpm_table *soc_table =\n\t\t\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_umd_pstate_table *pstate_table =\n\t\t\t\t&smu->pstate_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t sclk_freq;\n\n\tpstate_table->gfxclk_pstate.min = gfx_table->min;\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\t\tswitch (adev->pdev->revision) {\n\t\tcase 0xf0:  \n\t\tcase 0xc0:\n\t\t\tsclk_freq = NAVI10_PEAK_SCLK_XTX;\n\t\t\tbreak;\n\t\tcase 0xf1:  \n\t\tcase 0xc1:\n\t\t\tsclk_freq = NAVI10_PEAK_SCLK_XT;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tsclk_freq = NAVI10_PEAK_SCLK_XL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 5):\n\t\tswitch (adev->pdev->revision) {\n\t\tcase 0xc7:  \n\t\tcase 0xf4:\n\t\t\tsclk_freq = NAVI14_UMD_PSTATE_PEAK_XT_GFXCLK;\n\t\t\tbreak;\n\t\tcase 0xc1:  \n\t\tcase 0xf2:\n\t\t\tsclk_freq = NAVI14_UMD_PSTATE_PEAK_XTM_GFXCLK;\n\t\t\tbreak;\n\t\tcase 0xc3:  \n\t\tcase 0xf3:\n\t\t\tsclk_freq = NAVI14_UMD_PSTATE_PEAK_XLM_GFXCLK;\n\t\t\tbreak;\n\t\tcase 0xc5:  \n\t\tcase 0xf6:\n\t\t\tsclk_freq = NAVI14_UMD_PSTATE_PEAK_XLM_GFXCLK;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tsclk_freq = NAVI14_UMD_PSTATE_PEAK_XL_GFXCLK;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 9):\n\t\tsclk_freq = NAVI12_UMD_PSTATE_PEAK_GFXCLK;\n\t\tbreak;\n\tdefault:\n\t\tsclk_freq = gfx_table->dpm_levels[gfx_table->count - 1].value;\n\t\tbreak;\n\t}\n\tpstate_table->gfxclk_pstate.peak = sclk_freq;\n\n\tpstate_table->uclk_pstate.min = mem_table->min;\n\tpstate_table->uclk_pstate.peak = mem_table->max;\n\n\tpstate_table->socclk_pstate.min = soc_table->min;\n\tpstate_table->socclk_pstate.peak = soc_table->max;\n\n\tif (gfx_table->max > NAVI10_UMD_PSTATE_PROFILING_GFXCLK &&\n\t    mem_table->max > NAVI10_UMD_PSTATE_PROFILING_MEMCLK &&\n\t    soc_table->max > NAVI10_UMD_PSTATE_PROFILING_SOCCLK) {\n\t\tpstate_table->gfxclk_pstate.standard =\n\t\t\tNAVI10_UMD_PSTATE_PROFILING_GFXCLK;\n\t\tpstate_table->uclk_pstate.standard =\n\t\t\tNAVI10_UMD_PSTATE_PROFILING_MEMCLK;\n\t\tpstate_table->socclk_pstate.standard =\n\t\t\tNAVI10_UMD_PSTATE_PROFILING_SOCCLK;\n\t} else {\n\t\tpstate_table->gfxclk_pstate.standard =\n\t\t\tpstate_table->gfxclk_pstate.min;\n\t\tpstate_table->uclk_pstate.standard =\n\t\t\tpstate_table->uclk_pstate.min;\n\t\tpstate_table->socclk_pstate.standard =\n\t\t\tpstate_table->socclk_pstate.min;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_get_clock_by_type_with_latency(struct smu_context *smu,\n\t\t\t\t\t\t enum smu_clk_type clk_type,\n\t\t\t\t\t\t struct pp_clock_levels_with_latency *clocks)\n{\n\tint ret = 0, i = 0;\n\tuint32_t level_count = 0, freq = 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_DCEFCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\t\tret = smu_v11_0_get_dpm_level_count(smu, clk_type, &level_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlevel_count = min(level_count, (uint32_t)MAX_NUM_CLOCKS);\n\t\tclocks->num_levels = level_count;\n\n\t\tfor (i = 0; i < level_count; i++) {\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, i, &freq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tclocks->data[i].clocks_in_khz = freq * 1000;\n\t\t\tclocks->data[i].latency_in_us = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_pre_display_config_changed(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint32_t max_freq = 0;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_get_dpm_ultimate_freq(smu, SMU_UCLK, NULL, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, 0, max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_display_config_changed(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays,\n\t\t\t\t\t\t  smu->display_config->num_display,\n\t\t\t\t\t\t  NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic bool navi10_is_dpm_running(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int navi10_get_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\t    uint32_t *speed)\n{\n\tint ret = 0;\n\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\tswitch (smu_v11_0_get_fan_control_mode(smu)) {\n\tcase AMD_FAN_CTRL_AUTO:\n\t\tret = navi10_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_CURR_FANSPEED,\n\t\t\t\t\t\t  speed);\n\t\tbreak;\n\tdefault:\n\t\tret = smu_v11_0_get_fan_speed_rpm(smu,\n\t\t\t\t\t\t  speed);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_get_fan_parameters(struct smu_context *smu)\n{\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\n\tsmu->fan_max_rpm = pptable->FanMaximumRpm;\n\n\treturn 0;\n}\n\nstatic int navi10_get_power_profile_mode(struct smu_context *smu, char *buf)\n{\n\tDpmActivityMonitorCoeffInt_t activity_monitor;\n\tuint32_t i, size = 0;\n\tint16_t workload_type = 0;\n\tstatic const char *title[] = {\n\t\t\t\"PROFILE_INDEX(NAME)\",\n\t\t\t\"CLOCK_TYPE(NAME)\",\n\t\t\t\"FPS\",\n\t\t\t\"MinFreqType\",\n\t\t\t\"MinActiveFreqType\",\n\t\t\t\"MinActiveFreq\",\n\t\t\t\"BoosterFreqType\",\n\t\t\t\"BoosterFreq\",\n\t\t\t\"PD_Data_limit_c\",\n\t\t\t\"PD_Data_error_coeff\",\n\t\t\t\"PD_Data_error_rate_coeff\"};\n\tint result = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tsize += sysfs_emit_at(buf, size, \"%16s %s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\ttitle[0], title[1], title[2], title[3], title[4], title[5],\n\t\t\ttitle[6], title[7], title[8], title[9], title[10]);\n\n\tfor (i = 0; i <= PP_SMC_POWER_PROFILE_CUSTOM; i++) {\n\t\t \n\t\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t\t       i);\n\t\tif (workload_type < 0)\n\t\t\treturn -EINVAL;\n\n\t\tresult = smu_cmn_update_table(smu,\n\t\t\t\t\t  SMU_TABLE_ACTIVITY_MONITOR_COEFF, workload_type,\n\t\t\t\t\t  (void *)(&activity_monitor), false);\n\t\tif (result) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn result;\n\t\t}\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s:\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == smu->power_profile_mode) ? \"*\" : \" \");\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t0,\n\t\t\t\"GFXCLK\",\n\t\t\tactivity_monitor.Gfx_FPS,\n\t\t\tactivity_monitor.Gfx_MinFreqStep,\n\t\t\tactivity_monitor.Gfx_MinActiveFreqType,\n\t\t\tactivity_monitor.Gfx_MinActiveFreq,\n\t\t\tactivity_monitor.Gfx_BoosterFreqType,\n\t\t\tactivity_monitor.Gfx_BoosterFreq,\n\t\t\tactivity_monitor.Gfx_PD_Data_limit_c,\n\t\t\tactivity_monitor.Gfx_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Gfx_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t1,\n\t\t\t\"SOCCLK\",\n\t\t\tactivity_monitor.Soc_FPS,\n\t\t\tactivity_monitor.Soc_MinFreqStep,\n\t\t\tactivity_monitor.Soc_MinActiveFreqType,\n\t\t\tactivity_monitor.Soc_MinActiveFreq,\n\t\t\tactivity_monitor.Soc_BoosterFreqType,\n\t\t\tactivity_monitor.Soc_BoosterFreq,\n\t\t\tactivity_monitor.Soc_PD_Data_limit_c,\n\t\t\tactivity_monitor.Soc_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Soc_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t2,\n\t\t\t\"MEMLK\",\n\t\t\tactivity_monitor.Mem_FPS,\n\t\t\tactivity_monitor.Mem_MinFreqStep,\n\t\t\tactivity_monitor.Mem_MinActiveFreqType,\n\t\t\tactivity_monitor.Mem_MinActiveFreq,\n\t\t\tactivity_monitor.Mem_BoosterFreqType,\n\t\t\tactivity_monitor.Mem_BoosterFreq,\n\t\t\tactivity_monitor.Mem_PD_Data_limit_c,\n\t\t\tactivity_monitor.Mem_PD_Data_error_coeff,\n\t\t\tactivity_monitor.Mem_PD_Data_error_rate_coeff);\n\t}\n\n\treturn size;\n}\n\nstatic int navi10_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)\n{\n\tDpmActivityMonitorCoeffInt_t activity_monitor;\n\tint workload_type, ret = 0;\n\n\tsmu->power_profile_mode = input[size];\n\n\tif (smu->power_profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tdev_err(smu->adev->dev, \"Invalid power profile mode %d\\n\", smu->power_profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {\n\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t       (void *)(&activity_monitor), false);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (input[0]) {\n\t\tcase 0:  \n\t\t\tactivity_monitor.Gfx_FPS = input[1];\n\t\t\tactivity_monitor.Gfx_MinFreqStep = input[2];\n\t\t\tactivity_monitor.Gfx_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Gfx_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Gfx_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Gfx_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Gfx_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Gfx_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Gfx_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tactivity_monitor.Soc_FPS = input[1];\n\t\t\tactivity_monitor.Soc_MinFreqStep = input[2];\n\t\t\tactivity_monitor.Soc_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Soc_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Soc_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Soc_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Soc_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Soc_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Soc_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tactivity_monitor.Mem_FPS = input[1];\n\t\t\tactivity_monitor.Mem_MinFreqStep = input[2];\n\t\t\tactivity_monitor.Mem_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor.Mem_MinActiveFreq = input[4];\n\t\t\tactivity_monitor.Mem_BoosterFreqType = input[5];\n\t\t\tactivity_monitor.Mem_BoosterFreq = input[6];\n\t\t\tactivity_monitor.Mem_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor.Mem_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor.Mem_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\t}\n\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t       (void *)(&activity_monitor), true);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to set activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t       smu->power_profile_mode);\n\tif (workload_type < 0)\n\t\treturn -EINVAL;\n\tsmu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetWorkloadMask,\n\t\t\t\t    1 << workload_type, NULL);\n\n\treturn ret;\n}\n\nstatic int navi10_notify_smc_display_config(struct smu_context *smu)\n{\n\tstruct smu_clocks min_clocks = {0};\n\tstruct pp_display_clock_request clock_req;\n\tint ret = 0;\n\n\tmin_clocks.dcef_clock = smu->display_config->min_dcef_set_clk;\n\tmin_clocks.dcef_clock_in_sr = smu->display_config->min_dcef_deep_sleep_set_clk;\n\tmin_clocks.memory_clock = smu->display_config->min_mem_set_clock;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tclock_req.clock_type = amd_pp_dcef_clock;\n\t\tclock_req.clock_freq_in_khz = min_clocks.dcef_clock * 10;\n\n\t\tret = smu_v11_0_display_clock_voltage_request(smu, &clock_req);\n\t\tif (!ret) {\n\t\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DS_DCEFCLK_BIT)) {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t  SMU_MSG_SetMinDeepSleepDcefclk,\n\t\t\t\t\t\t\t\t  min_clocks.dcef_clock_in_sr/100,\n\t\t\t\t\t\t\t\t  NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(smu->adev->dev, \"Attempt to set divider for DCEFCLK Failed!\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(smu->adev->dev, \"Attempt to set Hard Min for DCEFCLK Failed!\");\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, min_clocks.memory_clock/100, 0);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Set hard min uclk failed!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_set_watermarks_table(struct smu_context *smu,\n\t\t\t\t       struct pp_smu_wm_range_sets *clock_ranges)\n{\n\tWatermarks_t *table = smu->smu_table.watermarks_table;\n\tint ret = 0;\n\tint i;\n\n\tif (clock_ranges) {\n\t\tif (clock_ranges->num_reader_wm_sets > NUM_WM_RANGES ||\n\t\t    clock_ranges->num_writer_wm_sets > NUM_WM_RANGES)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < clock_ranges->num_reader_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MinClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MaxClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MinUclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MaxUclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_fill_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].WmSetting =\n\t\t\t\tclock_ranges->reader_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tfor (i = 0; i < clock_ranges->num_writer_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinUclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxUclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_drain_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmSetting =\n\t\t\t\tclock_ranges->writer_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tsmu->watermarks_bitmap |= WATERMARKS_EXIST;\n\t}\n\n\t \n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t     !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {\n\t\tret = smu_cmn_write_watermarks_table(smu);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to update WMTABLE!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsmu->watermarks_bitmap |= WATERMARKS_LOADED;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_read_sensor(struct smu_context *smu,\n\t\t\t\t enum amd_pp_sensors sensor,\n\t\t\t\t void *data, uint32_t *size)\n{\n\tint ret = 0;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_MAX_FAN_RPM:\n\t\t*(uint32_t *)data = pptable->FanMaximumRpm;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\tret = navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_AVERAGE_MEMACTIVITY,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = navi1x_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_TEMPERATURE_MEM,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = navi10_get_current_clk_freq_by_table(smu, SMU_UCLK, (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = navi1x_get_smu_metrics_data(smu, METRICS_AVERAGE_GFXCLK, (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = smu_v11_0_get_gfx_vdd(smu, (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_get_uclk_dpm_states(struct smu_context *smu, uint32_t *clocks_in_khz, uint32_t *num_states)\n{\n\tuint32_t num_discrete_levels = 0;\n\tuint16_t *dpm_levels = NULL;\n\tuint16_t i = 0;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *driver_ppt = NULL;\n\n\tif (!clocks_in_khz || !num_states || !table_context->driver_pptable)\n\t\treturn -EINVAL;\n\n\tdriver_ppt = table_context->driver_pptable;\n\tnum_discrete_levels = driver_ppt->DpmDescriptor[PPCLK_UCLK].NumDiscreteLevels;\n\tdpm_levels = driver_ppt->FreqTableUclk;\n\n\tif (num_discrete_levels == 0 || dpm_levels == NULL)\n\t\treturn -EINVAL;\n\n\t*num_states = num_discrete_levels;\n\tfor (i = 0; i < num_discrete_levels; i++) {\n\t\t \n\t\t*clocks_in_khz = (*dpm_levels) * 1000;\n\t\tclocks_in_khz++;\n\t\tdpm_levels++;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_get_thermal_temperature_range(struct smu_context *smu,\n\t\t\t\t\t\tstruct smu_temperature_range *range)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\t\t\ttable_context->power_play_table;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tmemcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range));\n\n\trange->max = pptable->TedgeLimit *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->edge_emergency_max = (pptable->TedgeLimit + CTF_OFFSET_EDGE) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_crit_max = pptable->ThotspotLimit *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_emergency_max = (pptable->ThotspotLimit + CTF_OFFSET_HOTSPOT) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_crit_max = pptable->TmemLimit *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_emergency_max = (pptable->TmemLimit + CTF_OFFSET_MEM)*\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->software_shutdown_temp = powerplay_table->software_shutdown_temp;\n\n\treturn 0;\n}\n\nstatic int navi10_display_disable_memory_clock_switch(struct smu_context *smu,\n\t\t\t\t\t\tbool disable_memory_clock_switch)\n{\n\tint ret = 0;\n\tstruct smu_11_0_max_sustainable_clocks *max_sustainable_clocks =\n\t\t(struct smu_11_0_max_sustainable_clocks *)\n\t\t\tsmu->smu_table.max_sustainable_clocks;\n\tuint32_t min_memory_clock = smu->hard_min_uclk_req_from_dal;\n\tuint32_t max_memory_clock = max_sustainable_clocks->uclock;\n\n\tif (smu->disable_uclk_switch == disable_memory_clock_switch)\n\t\treturn 0;\n\n\tif (disable_memory_clock_switch)\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, max_memory_clock, 0);\n\telse\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, min_memory_clock, 0);\n\n\tif (!ret)\n\t\tsmu->disable_uclk_switch = disable_memory_clock_switch;\n\n\treturn ret;\n}\n\nstatic int navi10_get_power_limit(struct smu_context *smu,\n\t\t\t\t  uint32_t *current_power_limit,\n\t\t\t\t  uint32_t *default_power_limit,\n\t\t\t\t  uint32_t *max_power_limit)\n{\n\tstruct smu_11_0_powerplay_table *powerplay_table =\n\t\t(struct smu_11_0_powerplay_table *)smu->smu_table.power_play_table;\n\tstruct smu_11_0_overdrive_table *od_settings = smu->od_settings;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tuint32_t power_limit, od_percent;\n\n\tif (smu_v11_0_get_current_power_limit(smu, &power_limit)) {\n\t\t \n\t\tif (!pptable) {\n\t\t\tdev_err(smu->adev->dev, \"Cannot get PPT limit due to pptable missing!\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpower_limit =\n\t\t\tpptable->SocketPowerLimitAc[PPT_THROTTLER_PPT0];\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (max_power_limit) {\n\t\tif (smu->od_enabled &&\n\t\t    navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_POWER_LIMIT)) {\n\t\t\tod_percent = le32_to_cpu(powerplay_table->overdrive_table.max[SMU_11_0_ODSETTING_POWERPERCENTAGE]);\n\n\t\t\tdev_dbg(smu->adev->dev, \"ODSETTING_POWERPERCENTAGE: %d (default: %d)\\n\", od_percent, power_limit);\n\n\t\t\tpower_limit *= (100 + od_percent);\n\t\t\tpower_limit /= 100;\n\t\t}\n\n\t\t*max_power_limit = power_limit;\n\t}\n\n\treturn 0;\n}\n\nstatic int navi10_update_pcie_parameters(struct smu_context *smu,\n\t\t\t\t\t uint8_t pcie_gen_cap,\n\t\t\t\t\t uint8_t pcie_width_cap)\n{\n\tstruct smu_11_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tPPTable_t *pptable = smu->smu_table.driver_pptable;\n\tuint32_t smu_pcie_arg;\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < MAX_PCIE_CONF; i++) {\n\t\tdpm_context->dpm_tables.pcie_table.pcie_gen[i] = pptable->PcieGenSpeed[i];\n\t\tdpm_context->dpm_tables.pcie_table.pcie_lane[i] = pptable->PcieLaneCount[i];\n\t}\n\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\tsmu_pcie_arg = (i << 16) |\n\t\t\t((pptable->PcieGenSpeed[i] <= pcie_gen_cap) ? (pptable->PcieGenSpeed[i] << 8) :\n\t\t\t\t(pcie_gen_cap << 8)) | ((pptable->PcieLaneCount[i] <= pcie_width_cap) ?\n\t\t\t\t\tpptable->PcieLaneCount[i] : pcie_width_cap);\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_OverridePcieParameters,\n\t\t\t\t\t  smu_pcie_arg,\n\t\t\t\t\t  NULL);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (pptable->PcieGenSpeed[i] > pcie_gen_cap)\n\t\t\tdpm_context->dpm_tables.pcie_table.pcie_gen[i] = pcie_gen_cap;\n\t\tif (pptable->PcieLaneCount[i] > pcie_width_cap)\n\t\t\tdpm_context->dpm_tables.pcie_table.pcie_lane[i] = pcie_width_cap;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void navi10_dump_od_table(struct smu_context *smu,\n\t\t\t\t\tOverDriveTable_t *od_table)\n{\n\tdev_dbg(smu->adev->dev, \"OD: Gfxclk: (%d, %d)\\n\", od_table->GfxclkFmin, od_table->GfxclkFmax);\n\tdev_dbg(smu->adev->dev, \"OD: Gfx1: (%d, %d)\\n\", od_table->GfxclkFreq1, od_table->GfxclkVolt1);\n\tdev_dbg(smu->adev->dev, \"OD: Gfx2: (%d, %d)\\n\", od_table->GfxclkFreq2, od_table->GfxclkVolt2);\n\tdev_dbg(smu->adev->dev, \"OD: Gfx3: (%d, %d)\\n\", od_table->GfxclkFreq3, od_table->GfxclkVolt3);\n\tdev_dbg(smu->adev->dev, \"OD: UclkFmax: %d\\n\", od_table->UclkFmax);\n\tdev_dbg(smu->adev->dev, \"OD: OverDrivePct: %d\\n\", od_table->OverDrivePct);\n}\n\nstatic int navi10_od_setting_check_range(struct smu_context *smu,\n\t\t\t\t\t struct smu_11_0_overdrive_table *od_table,\n\t\t\t\t\t enum SMU_11_0_ODSETTING_ID setting,\n\t\t\t\t\t uint32_t value)\n{\n\tif (value < od_table->min[setting]) {\n\t\tdev_warn(smu->adev->dev, \"OD setting (%d, %d) is less than the minimum allowed (%d)\\n\", setting, value, od_table->min[setting]);\n\t\treturn -EINVAL;\n\t}\n\tif (value > od_table->max[setting]) {\n\t\tdev_warn(smu->adev->dev, \"OD setting (%d, %d) is greater than the maximum allowed (%d)\\n\", setting, value, od_table->max[setting]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int navi10_overdrive_get_gfx_clk_base_voltage(struct smu_context *smu,\n\t\t\t\t\t\t     uint16_t *voltage,\n\t\t\t\t\t\t     uint32_t freq)\n{\n\tuint32_t param = (freq & 0xFFFF) | (PPCLK_GFXCLK << 16);\n\tuint32_t value = 0;\n\tint ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_GetVoltageByDpm,\n\t\t\t\t\t  param,\n\t\t\t\t\t  &value);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[GetBaseVoltage] failed to get GFXCLK AVFS voltage from SMU!\");\n\t\treturn ret;\n\t}\n\n\t*voltage = (uint16_t)value;\n\n\treturn 0;\n}\n\nstatic int navi10_baco_enter(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\t \n\tif (adev->in_runpm && smu_cmn_is_audio_func_enabled(adev))\n\t\treturn smu_v11_0_baco_set_armd3_sequence(smu, BACO_SEQ_BACO);\n\telse\n\t\treturn smu_v11_0_baco_enter(smu);\n}\n\nstatic int navi10_baco_exit(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->in_runpm && smu_cmn_is_audio_func_enabled(adev)) {\n\t\t \n\t\tmsleep(10);\n\t\treturn smu_v11_0_baco_set_armd3_sequence(smu, BACO_SEQ_ULPS);\n\t} else {\n\t\treturn smu_v11_0_baco_exit(smu);\n\t}\n}\n\nstatic int navi10_set_default_od_settings(struct smu_context *smu)\n{\n\tOverDriveTable_t *od_table =\n\t\t(OverDriveTable_t *)smu->smu_table.overdrive_table;\n\tOverDriveTable_t *boot_od_table =\n\t\t(OverDriveTable_t *)smu->smu_table.boot_overdrive_table;\n\tOverDriveTable_t *user_od_table =\n\t\t(OverDriveTable_t *)smu->smu_table.user_overdrive_table;\n\tint ret = 0;\n\n\t \n\tif (smu->adev->in_suspend)\n\t\treturn 0;\n\n\tret = smu_cmn_update_table(smu, SMU_TABLE_OVERDRIVE, 0, (void *)boot_od_table, false);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get overdrive table!\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!boot_od_table->GfxclkVolt1) {\n\t\tret = navi10_overdrive_get_gfx_clk_base_voltage(smu,\n\t\t\t\t\t\t\t\t&boot_od_table->GfxclkVolt1,\n\t\t\t\t\t\t\t\tboot_od_table->GfxclkFreq1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!boot_od_table->GfxclkVolt2) {\n\t\tret = navi10_overdrive_get_gfx_clk_base_voltage(smu,\n\t\t\t\t\t\t\t\t&boot_od_table->GfxclkVolt2,\n\t\t\t\t\t\t\t\tboot_od_table->GfxclkFreq2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!boot_od_table->GfxclkVolt3) {\n\t\tret = navi10_overdrive_get_gfx_clk_base_voltage(smu,\n\t\t\t\t\t\t\t\t&boot_od_table->GfxclkVolt3,\n\t\t\t\t\t\t\t\tboot_od_table->GfxclkFreq3);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnavi10_dump_od_table(smu, boot_od_table);\n\n\tmemcpy(od_table, boot_od_table, sizeof(OverDriveTable_t));\n\tmemcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t));\n\n\treturn 0;\n}\n\nstatic int navi10_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TABLE_COMMAND type, long input[], uint32_t size)\n{\n\tint i;\n\tint ret = 0;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tOverDriveTable_t *od_table;\n\tstruct smu_11_0_overdrive_table *od_settings;\n\tenum SMU_11_0_ODSETTING_ID freq_setting, voltage_setting;\n\tuint16_t *freq_ptr, *voltage_ptr;\n\tod_table = (OverDriveTable_t *)table_context->overdrive_table;\n\n\tif (!smu->od_enabled) {\n\t\tdev_warn(smu->adev->dev, \"OverDrive is not enabled!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!smu->od_settings) {\n\t\tdev_err(smu->adev->dev, \"OD board limits are not set!\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tod_settings = smu->od_settings;\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_LIMITS)) {\n\t\t\tdev_warn(smu->adev->dev, \"GFXCLK_LIMITS not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tif (!table_context->overdrive_table) {\n\t\t\tdev_err(smu->adev->dev, \"Overdrive is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tdev_info(smu->adev->dev, \"invalid number of input parameters %d\\n\", size);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tswitch (input[i]) {\n\t\t\tcase 0:\n\t\t\t\tfreq_setting = SMU_11_0_ODSETTING_GFXCLKFMIN;\n\t\t\t\tfreq_ptr = &od_table->GfxclkFmin;\n\t\t\t\tif (input[i + 1] > od_table->GfxclkFmax) {\n\t\t\t\t\tdev_info(smu->adev->dev, \"GfxclkFmin (%ld) must be <= GfxclkFmax (%u)!\\n\",\n\t\t\t\t\t\tinput[i + 1],\n\t\t\t\t\t\tod_table->GfxclkFmin);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfreq_setting = SMU_11_0_ODSETTING_GFXCLKFMAX;\n\t\t\t\tfreq_ptr = &od_table->GfxclkFmax;\n\t\t\t\tif (input[i + 1] < od_table->GfxclkFmin) {\n\t\t\t\t\tdev_info(smu->adev->dev, \"GfxclkFmax (%ld) must be >= GfxclkFmin (%u)!\\n\",\n\t\t\t\t\t\tinput[i + 1],\n\t\t\t\t\t\tod_table->GfxclkFmax);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_info(smu->adev->dev, \"Invalid SCLK_VDDC_TABLE index: %ld\\n\", input[i]);\n\t\t\t\tdev_info(smu->adev->dev, \"Supported indices: [0:min,1:max]\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = navi10_od_setting_check_range(smu, od_settings, freq_setting, input[i + 1]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*freq_ptr = input[i + 1];\n\t\t}\n\t\tbreak;\n\tcase PP_OD_EDIT_MCLK_VDDC_TABLE:\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_UCLK_MAX)) {\n\t\t\tdev_warn(smu->adev->dev, \"UCLK_MAX not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tif (size < 2) {\n\t\t\tdev_info(smu->adev->dev, \"invalid number of parameters: %d\\n\", size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (input[0] != 1) {\n\t\t\tdev_info(smu->adev->dev, \"Invalid MCLK_VDDC_TABLE index: %ld\\n\", input[0]);\n\t\t\tdev_info(smu->adev->dev, \"Supported indices: [1:max]\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = navi10_od_setting_check_range(smu, od_settings, SMU_11_0_ODSETTING_UCLKFMAX, input[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tod_table->UclkFmax = input[1];\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (!(table_context->overdrive_table && table_context->boot_overdrive_table)) {\n\t\t\tdev_err(smu->adev->dev, \"Overdrive table was not initialized!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(table_context->overdrive_table, table_context->boot_overdrive_table, sizeof(OverDriveTable_t));\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (memcmp(od_table, table_context->user_overdrive_table, sizeof(OverDriveTable_t))) {\n\t\t\tnavi10_dump_od_table(smu, od_table);\n\t\t\tret = smu_cmn_update_table(smu, SMU_TABLE_OVERDRIVE, 0, (void *)od_table, true);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Failed to import overdrive table!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmemcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t));\n\t\t\tsmu->user_dpm_profile.user_od = true;\n\n\t\t\tif (!memcmp(table_context->user_overdrive_table,\n\t\t\t\t    table_context->boot_overdrive_table,\n\t\t\t\t    sizeof(OverDriveTable_t)))\n\t\t\t\tsmu->user_dpm_profile.user_od = false;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_EDIT_VDDC_CURVE:\n\t\tif (!navi10_od_feature_is_supported(od_settings, SMU_11_0_ODCAP_GFXCLK_CURVE)) {\n\t\t\tdev_warn(smu->adev->dev, \"GFXCLK_CURVE not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tif (size < 3) {\n\t\t\tdev_info(smu->adev->dev, \"invalid number of parameters: %d\\n\", size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!od_table) {\n\t\t\tdev_info(smu->adev->dev, \"Overdrive is not initialized\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (input[0]) {\n\t\tcase 0:\n\t\t\tfreq_setting = SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P1;\n\t\t\tvoltage_setting = SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P1;\n\t\t\tfreq_ptr = &od_table->GfxclkFreq1;\n\t\t\tvoltage_ptr = &od_table->GfxclkVolt1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfreq_setting = SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P2;\n\t\t\tvoltage_setting = SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P2;\n\t\t\tfreq_ptr = &od_table->GfxclkFreq2;\n\t\t\tvoltage_ptr = &od_table->GfxclkVolt2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfreq_setting = SMU_11_0_ODSETTING_VDDGFXCURVEFREQ_P3;\n\t\t\tvoltage_setting = SMU_11_0_ODSETTING_VDDGFXCURVEVOLTAGE_P3;\n\t\t\tfreq_ptr = &od_table->GfxclkFreq3;\n\t\t\tvoltage_ptr = &od_table->GfxclkVolt3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(smu->adev->dev, \"Invalid VDDC_CURVE index: %ld\\n\", input[0]);\n\t\t\tdev_info(smu->adev->dev, \"Supported indices: [0, 1, 2]\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = navi10_od_setting_check_range(smu, od_settings, freq_setting, input[1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t\n\t\tif (input[2] != 0) {\n\t\t\tret = navi10_od_setting_check_range(smu, od_settings, voltage_setting, input[2]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\t*freq_ptr = input[1];\n\t\t\t*voltage_ptr = ((uint16_t)input[2]) * NAVI10_VOLTAGE_SCALE;\n\t\t\tdev_dbg(smu->adev->dev, \"OD: set curve %ld: (%d, %d)\\n\", input[0], *freq_ptr, *voltage_ptr);\n\t\t} else {\n\t\t\t\n\t\t\tod_table->GfxclkVolt1 = 0;\n\t\t\tod_table->GfxclkVolt2 = 0;\n\t\t\tod_table->GfxclkVolt3 = 0;\n\t\t}\n\t\tnavi10_dump_od_table(smu, od_table);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\treturn ret;\n}\n\nstatic int navi10_run_btc(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_RunBtc, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"RunBtc failed!\\n\");\n\n\treturn ret;\n}\n\nstatic bool navi10_need_umc_cdr_workaround(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT))\n\t\treturn false;\n\n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0) ||\n\t    adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 5))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int navi10_umc_hybrid_cdr_workaround(struct smu_context *smu)\n{\n\tuint32_t uclk_count, uclk_min, uclk_max;\n\tint ret = 0;\n\n\t \n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT))\n\t\treturn 0;\n\n\tret = smu_v11_0_get_dpm_level_count(smu, SMU_UCLK, &uclk_count);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_v11_0_get_dpm_freq_by_index(smu, SMU_UCLK, (uint16_t)(uclk_count - 1), &uclk_max);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (uclk_max > 0x2EE)\n\t\treturn 0;\n\n\tret = smu_v11_0_get_dpm_freq_by_index(smu, SMU_UCLK, (uint16_t)0, &uclk_min);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, 0, uclk_min);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, 0, uclk_max);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn smu_cmn_send_smc_msg(smu, SMU_MSG_DAL_ENABLE_DUMMY_PSTATE_CHANGE, NULL);\n}\n\nstatic int navi10_set_dummy_pstates_table_location(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *dummy_read_table =\n\t\t\t\t&smu_table->dummy_read_1_table;\n\tchar *dummy_table = dummy_read_table->cpu_addr;\n\tint ret = 0;\n\tuint32_t i;\n\n\tfor (i = 0; i < 0x40000; i += 0x1000 * 2) {\n\t\tmemcpy(dummy_table, &NoDbiPrbs7[0], 0x1000);\n\t\tdummy_table += 0x1000;\n\t\tmemcpy(dummy_table, &DbiPrbs7[0], 0x1000);\n\t\tdummy_table += 0x1000;\n\t}\n\n\tamdgpu_asic_flush_hdp(smu->adev, NULL);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_SET_DRIVER_DUMMY_TABLE_DRAM_ADDR_HIGH,\n\t\t\t\t\t      upper_32_bits(dummy_read_table->mc_address),\n\t\t\t\t\t      NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SET_DRIVER_DUMMY_TABLE_DRAM_ADDR_LOW,\n\t\t\t\t\t       lower_32_bits(dummy_read_table->mc_address),\n\t\t\t\t\t       NULL);\n}\n\nstatic int navi10_run_umc_cdr_workaround(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint8_t umc_fw_greater_than_v136 = false;\n\tuint8_t umc_fw_disable_cdr = false;\n\tuint32_t pmfw_version;\n\tuint32_t param;\n\tint ret = 0;\n\n\tif (!navi10_need_umc_cdr_workaround(smu))\n\t\treturn 0;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &pmfw_version);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0)) && (pmfw_version >= 0x2a3500)) ||\n\t    ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 5)) && (pmfw_version >= 0x351D00))) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_GET_UMC_FW_WA,\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      &param);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tumc_fw_greater_than_v136 = param & 0x1;\n\n\t\t \n\t\tumc_fw_disable_cdr = param & 0x2;\n\n\t\t \n\t\tif (umc_fw_greater_than_v136)\n\t\t\treturn 0;\n\n\t\tif (umc_fw_disable_cdr) {\n\t\t\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0))\n\t\t\t\treturn navi10_umc_hybrid_cdr_workaround(smu);\n\t\t} else {\n\t\t\treturn navi10_set_dummy_pstates_table_location(smu);\n\t\t}\n\t} else {\n\t\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0))\n\t\t\treturn navi10_umc_hybrid_cdr_workaround(smu);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t navi10_get_legacy_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t     void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_legacy_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_legacy_t));\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = metrics.TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;\n\tgpu_metrics->temperature_mem = metrics.TemperatureMem;\n\tgpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = metrics.TemperatureVrMem0;\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics.AverageUclkActivity;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];\n\tgpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   navi1x_throttler_map);\n\n\tgpu_metrics->current_fan_speed = metrics.CurrFanSpeed;\n\n\tgpu_metrics->pcie_link_width =\n\t\t\tsmu_v11_0_get_current_pcie_link_width(smu);\n\tgpu_metrics->pcie_link_speed =\n\t\t\tsmu_v11_0_get_current_pcie_link_speed(smu);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\tif (metrics.CurrGfxVoltageOffset)\n\t\tgpu_metrics->voltage_gfx =\n\t\t\t(155000 - 625 * metrics.CurrGfxVoltageOffset) / 100;\n\tif (metrics.CurrMemVidOffset)\n\t\tgpu_metrics->voltage_mem =\n\t\t\t(155000 - 625 * metrics.CurrMemVidOffset) / 100;\n\tif (metrics.CurrSocVoltageOffset)\n\t\tgpu_metrics->voltage_soc =\n\t\t\t(155000 - 625 * metrics.CurrSocVoltageOffset) / 100;\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic int navi10_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t   struct i2c_msg *msg, int num_msgs)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tSwI2cRequest_t *req, *res = (SwI2cRequest_t *)table->cpu_addr;\n\tint i, j, r, c;\n\tu16 dir;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn -EBUSY;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->I2CcontrollerPort = smu_i2c->port;\n\treq->I2CSpeed = I2C_SPEED_FAST_400K;\n\treq->SlaveAddress = msg[0].addr << 1;  \n\tdir = msg[0].flags & I2C_M_RD;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &req->SwI2cCmds[c];\n\n\t\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\t\t \n\t\t\t\tcmd->Cmd = I2C_CMD_WRITE;\n\t\t\t\tcmd->RegisterAddr = msg[i].buf[j];\n\t\t\t}\n\n\t\t\tif ((dir ^ msg[i].flags) & I2C_M_RD) {\n\t\t\t\t \n\t\t\t\tdir = msg[i].flags & I2C_M_RD;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_RESTART_MASK;\n\t\t\t}\n\n\t\t\treq->NumCmds++;\n\n\t\t\t \n\t\t\tif ((j == msg[i].len - 1) &&\n\t\t\t    ((i == num_msgs - 1) || (msg[i].flags & I2C_M_STOP))) {\n\t\t\t\tcmd->CmdConfig &= ~CMDCONFIG_RESTART_MASK;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_STOP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&adev->pm.mutex);\n\tr = smu_cmn_update_table(smu, SMU_TABLE_I2C_COMMANDS, 0, req, true);\n\tif (r)\n\t\tgoto fail;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\tc += msg[i].len;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &res->SwI2cCmds[c];\n\n\t\t\tmsg[i].buf[j] = cmd->Data;\n\t\t}\n\t}\n\tr = num_msgs;\nfail:\n\tmutex_unlock(&adev->pm.mutex);\n\tkfree(req);\n\treturn r;\n}\n\nstatic u32 navi10_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\n\nstatic const struct i2c_algorithm navi10_i2c_algo = {\n\t.master_xfer = navi10_i2c_xfer,\n\t.functionality = navi10_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks navi10_i2c_control_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_SAME_ADDR | I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len  = MAX_SW_I2C_COMMANDS,\n\t.max_write_len = MAX_SW_I2C_COMMANDS,\n\t.max_comb_1st_msg_len = 2,\n\t.max_comb_2nd_msg_len = MAX_SW_I2C_COMMANDS - 2,\n};\n\nstatic int navi10_i2c_control_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint res, i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\tsmu_i2c->adev = adev;\n\t\tsmu_i2c->port = i;\n\t\tmutex_init(&smu_i2c->mutex);\n\t\tcontrol->owner = THIS_MODULE;\n\t\tcontrol->class = I2C_CLASS_HWMON;\n\t\tcontrol->dev.parent = &adev->pdev->dev;\n\t\tcontrol->algo = &navi10_i2c_algo;\n\t\tsnprintf(control->name, sizeof(control->name), \"AMDGPU SMU %d\", i);\n\t\tcontrol->quirks = &navi10_i2c_control_quirks;\n\t\ti2c_set_adapdata(control, smu_i2c);\n\n\t\tres = i2c_add_adapter(control);\n\t\tif (res) {\n\t\t\tDRM_ERROR(\"Failed to register hw i2c, err: %d\\n\", res);\n\t\t\tgoto Out_err;\n\t\t}\n\t}\n\n\tadev->pm.ras_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\tadev->pm.fru_eeprom_i2c_bus = &adev->pm.smu_i2c[1].adapter;\n\n\treturn 0;\nOut_err:\n\tfor ( ; i >= 0; i--) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\treturn res;\n}\n\nstatic void navi10_i2c_control_fini(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\tadev->pm.ras_eeprom_i2c_bus = NULL;\n\tadev->pm.fru_eeprom_i2c_bus = NULL;\n}\n\nstatic ssize_t navi10_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_t));\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = metrics.TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;\n\tgpu_metrics->temperature_mem = metrics.TemperatureMem;\n\tgpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = metrics.TemperatureVrMem0;\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics.AverageUclkActivity;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\n\tif (metrics.AverageGfxActivity > SMU_11_0_GFX_BUSY_THRESHOLD)\n\t\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequencyPreDs;\n\telse\n\t\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequencyPostDs;\n\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequencyPostDs;\n\n\tgpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];\n\tgpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   navi1x_throttler_map);\n\n\tgpu_metrics->current_fan_speed = metrics.CurrFanSpeed;\n\n\tgpu_metrics->pcie_link_width = metrics.PcieWidth;\n\tgpu_metrics->pcie_link_speed = link_speed[metrics.PcieRate];\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\tif (metrics.CurrGfxVoltageOffset)\n\t\tgpu_metrics->voltage_gfx =\n\t\t\t(155000 - 625 * metrics.CurrGfxVoltageOffset) / 100;\n\tif (metrics.CurrMemVidOffset)\n\t\tgpu_metrics->voltage_mem =\n\t\t\t(155000 - 625 * metrics.CurrMemVidOffset) / 100;\n\tif (metrics.CurrSocVoltageOffset)\n\t\tgpu_metrics->voltage_soc =\n\t\t\t(155000 - 625 * metrics.CurrSocVoltageOffset) / 100;\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic ssize_t navi12_get_legacy_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t     void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_NV12_legacy_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_legacy_t));\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = metrics.TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;\n\tgpu_metrics->temperature_mem = metrics.TemperatureMem;\n\tgpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = metrics.TemperatureVrMem0;\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics.AverageUclkActivity;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequency;\n\n\tgpu_metrics->energy_accumulator = metrics.EnergyAccumulator;\n\tgpu_metrics->average_vclk0_frequency = metrics.AverageVclkFrequency;\n\tgpu_metrics->average_dclk0_frequency = metrics.AverageDclkFrequency;\n\tgpu_metrics->average_mm_activity = metrics.VcnActivityPercentage;\n\n\tgpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];\n\tgpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   navi1x_throttler_map);\n\n\tgpu_metrics->current_fan_speed = metrics.CurrFanSpeed;\n\n\tgpu_metrics->pcie_link_width =\n\t\t\tsmu_v11_0_get_current_pcie_link_width(smu);\n\tgpu_metrics->pcie_link_speed =\n\t\t\tsmu_v11_0_get_current_pcie_link_speed(smu);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\tif (metrics.CurrGfxVoltageOffset)\n\t\tgpu_metrics->voltage_gfx =\n\t\t\t(155000 - 625 * metrics.CurrGfxVoltageOffset) / 100;\n\tif (metrics.CurrMemVidOffset)\n\t\tgpu_metrics->voltage_mem =\n\t\t\t(155000 - 625 * metrics.CurrMemVidOffset) / 100;\n\tif (metrics.CurrSocVoltageOffset)\n\t\tgpu_metrics->voltage_soc =\n\t\t\t(155000 - 625 * metrics.CurrSocVoltageOffset) / 100;\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic ssize_t navi12_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_NV12_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&metrics, smu_table->metrics_table, sizeof(SmuMetrics_NV12_t));\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = metrics.TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = metrics.TemperatureHotspot;\n\tgpu_metrics->temperature_mem = metrics.TemperatureMem;\n\tgpu_metrics->temperature_vrgfx = metrics.TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = metrics.TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = metrics.TemperatureVrMem0;\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = metrics.AverageUclkActivity;\n\n\tgpu_metrics->average_socket_power = metrics.AverageSocketPower;\n\n\tif (metrics.AverageGfxActivity > SMU_11_0_GFX_BUSY_THRESHOLD)\n\t\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequencyPreDs;\n\telse\n\t\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequencyPostDs;\n\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.AverageUclkFrequencyPostDs;\n\n\tgpu_metrics->energy_accumulator = metrics.EnergyAccumulator;\n\tgpu_metrics->average_vclk0_frequency = metrics.AverageVclkFrequency;\n\tgpu_metrics->average_dclk0_frequency = metrics.AverageDclkFrequency;\n\tgpu_metrics->average_mm_activity = metrics.VcnActivityPercentage;\n\n\tgpu_metrics->current_gfxclk = metrics.CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = metrics.CurrClock[PPCLK_VCLK];\n\tgpu_metrics->current_dclk0 = metrics.CurrClock[PPCLK_DCLK];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   navi1x_throttler_map);\n\n\tgpu_metrics->current_fan_speed = metrics.CurrFanSpeed;\n\n\tgpu_metrics->pcie_link_width = metrics.PcieWidth;\n\tgpu_metrics->pcie_link_speed = link_speed[metrics.PcieRate];\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\tif (metrics.CurrGfxVoltageOffset)\n\t\tgpu_metrics->voltage_gfx =\n\t\t\t(155000 - 625 * metrics.CurrGfxVoltageOffset) / 100;\n\tif (metrics.CurrMemVidOffset)\n\t\tgpu_metrics->voltage_mem =\n\t\t\t(155000 - 625 * metrics.CurrMemVidOffset) / 100;\n\tif (metrics.CurrSocVoltageOffset)\n\t\tgpu_metrics->voltage_soc =\n\t\t\t(155000 - 625 * metrics.CurrSocVoltageOffset) / 100;\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic ssize_t navi1x_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t smu_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"Failed to get smu version!\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 9):\n\t\tif (smu_version > 0x00341C00)\n\t\t\tret = navi12_get_gpu_metrics(smu, table);\n\t\telse\n\t\t\tret = navi12_get_legacy_gpu_metrics(smu, table);\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 5):\n\tdefault:\n\t\tif (((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 5)) && smu_version > 0x00351F00) ||\n\t\t      ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 0)) && smu_version > 0x002A3B00))\n\t\t\tret = navi10_get_gpu_metrics(smu, table);\n\t\telse\n\t\t\tret = navi10_get_legacy_gpu_metrics(smu, table);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int navi10_enable_mgpu_fan_boost(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *smc_pptable = table_context->driver_pptable;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t param = 0;\n\n\t \n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 9))\n\t\treturn 0;\n\n\t \n\tif (!smc_pptable->MGpuFanBoostLimitRpm)\n\t\treturn 0;\n\n\t \n\tif (adev->pdev->device == 0x7312 &&\n\t    adev->pdev->revision == 0)\n\t\tparam = 0xD188;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SetMGpuFanBoostLimitRpm,\n\t\t\t\t\t       param,\n\t\t\t\t\t       NULL);\n}\n\nstatic int navi10_post_smu_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tret = navi10_run_umc_cdr_workaround(smu);\n\tif (ret)\n\t\tdev_err(adev->dev, \"Failed to apply umc cdr workaround!\\n\");\n\n\treturn ret;\n}\n\nstatic int navi10_get_default_config_table_settings(struct smu_context *smu,\n\t\t\t\t\t\t    struct config_table_setting *table)\n{\n\tif (!table)\n\t\treturn -EINVAL;\n\n\ttable->gfxclk_average_tau = 10;\n\ttable->socclk_average_tau = 10;\n\ttable->uclk_average_tau = 10;\n\ttable->gfx_activity_average_tau = 10;\n\ttable->mem_activity_average_tau = 10;\n\ttable->socket_power_average_tau = 10;\n\n\treturn 0;\n}\n\nstatic int navi10_set_config_table(struct smu_context *smu,\n\t\t\t\t   struct config_table_setting *table)\n{\n\tDriverSmuConfig_t driver_smu_config_table;\n\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tmemset(&driver_smu_config_table,\n\t       0,\n\t       sizeof(driver_smu_config_table));\n\n\tdriver_smu_config_table.GfxclkAverageLpfTau =\n\t\t\t\ttable->gfxclk_average_tau;\n\tdriver_smu_config_table.SocclkAverageLpfTau =\n\t\t\t\ttable->socclk_average_tau;\n\tdriver_smu_config_table.UclkAverageLpfTau =\n\t\t\t\ttable->uclk_average_tau;\n\tdriver_smu_config_table.GfxActivityLpfTau =\n\t\t\t\ttable->gfx_activity_average_tau;\n\tdriver_smu_config_table.UclkActivityLpfTau =\n\t\t\t\ttable->mem_activity_average_tau;\n\tdriver_smu_config_table.SocketPowerLpfTau =\n\t\t\t\ttable->socket_power_average_tau;\n\n\treturn smu_cmn_update_table(smu,\n\t\t\t\t    SMU_TABLE_DRIVER_SMU_CONFIG,\n\t\t\t\t    0,\n\t\t\t\t    (void *)&driver_smu_config_table,\n\t\t\t\t    true);\n}\n\nstatic const struct pptable_funcs navi10_ppt_funcs = {\n\t.get_allowed_feature_mask = navi10_get_allowed_feature_mask,\n\t.set_default_dpm_table = navi10_set_default_dpm_table,\n\t.dpm_set_vcn_enable = navi10_dpm_set_vcn_enable,\n\t.dpm_set_jpeg_enable = navi10_dpm_set_jpeg_enable,\n\t.i2c_init = navi10_i2c_control_init,\n\t.i2c_fini = navi10_i2c_control_fini,\n\t.print_clk_levels = navi10_print_clk_levels,\n\t.emit_clk_levels = navi10_emit_clk_levels,\n\t.force_clk_levels = navi10_force_clk_levels,\n\t.populate_umd_state_clk = navi10_populate_umd_state_clk,\n\t.get_clock_by_type_with_latency = navi10_get_clock_by_type_with_latency,\n\t.pre_display_config_changed = navi10_pre_display_config_changed,\n\t.display_config_changed = navi10_display_config_changed,\n\t.notify_smc_display_config = navi10_notify_smc_display_config,\n\t.is_dpm_running = navi10_is_dpm_running,\n\t.get_fan_speed_pwm = smu_v11_0_get_fan_speed_pwm,\n\t.get_fan_speed_rpm = navi10_get_fan_speed_rpm,\n\t.get_power_profile_mode = navi10_get_power_profile_mode,\n\t.set_power_profile_mode = navi10_set_power_profile_mode,\n\t.set_watermarks_table = navi10_set_watermarks_table,\n\t.read_sensor = navi10_read_sensor,\n\t.get_uclk_dpm_states = navi10_get_uclk_dpm_states,\n\t.set_performance_level = smu_v11_0_set_performance_level,\n\t.get_thermal_temperature_range = navi10_get_thermal_temperature_range,\n\t.display_disable_memory_clock_switch = navi10_display_disable_memory_clock_switch,\n\t.get_power_limit = navi10_get_power_limit,\n\t.update_pcie_parameters = navi10_update_pcie_parameters,\n\t.init_microcode = smu_v11_0_init_microcode,\n\t.load_microcode = smu_v11_0_load_microcode,\n\t.fini_microcode = smu_v11_0_fini_microcode,\n\t.init_smc_tables = navi10_init_smc_tables,\n\t.fini_smc_tables = smu_v11_0_fini_smc_tables,\n\t.init_power = smu_v11_0_init_power,\n\t.fini_power = smu_v11_0_fini_power,\n\t.check_fw_status = smu_v11_0_check_fw_status,\n\t.setup_pptable = navi10_setup_pptable,\n\t.get_vbios_bootup_values = smu_v11_0_get_vbios_bootup_values,\n\t.check_fw_version = smu_v11_0_check_fw_version,\n\t.write_pptable = smu_cmn_write_pptable,\n\t.set_driver_table_location = smu_v11_0_set_driver_table_location,\n\t.set_tool_table_location = smu_v11_0_set_tool_table_location,\n\t.notify_memory_pool_location = smu_v11_0_notify_memory_pool_location,\n\t.system_features_control = smu_v11_0_system_features_control,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.init_display_count = smu_v11_0_init_display_count,\n\t.set_allowed_mask = smu_v11_0_set_allowed_mask,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.disable_all_features_with_exception = smu_cmn_disable_all_features_with_exception,\n\t.notify_display_change = smu_v11_0_notify_display_change,\n\t.set_power_limit = smu_v11_0_set_power_limit,\n\t.init_max_sustainable_clocks = smu_v11_0_init_max_sustainable_clocks,\n\t.enable_thermal_alert = smu_v11_0_enable_thermal_alert,\n\t.disable_thermal_alert = smu_v11_0_disable_thermal_alert,\n\t.set_min_dcef_deep_sleep = smu_v11_0_set_min_deep_sleep_dcefclk,\n\t.display_clock_voltage_request = smu_v11_0_display_clock_voltage_request,\n\t.get_fan_control_mode = smu_v11_0_get_fan_control_mode,\n\t.set_fan_control_mode = smu_v11_0_set_fan_control_mode,\n\t.set_fan_speed_pwm = smu_v11_0_set_fan_speed_pwm,\n\t.set_fan_speed_rpm = smu_v11_0_set_fan_speed_rpm,\n\t.set_xgmi_pstate = smu_v11_0_set_xgmi_pstate,\n\t.gfx_off_control = smu_v11_0_gfx_off_control,\n\t.register_irq_handler = smu_v11_0_register_irq_handler,\n\t.set_azalia_d3_pme = smu_v11_0_set_azalia_d3_pme,\n\t.get_max_sustainable_clocks_by_dc = smu_v11_0_get_max_sustainable_clocks_by_dc,\n\t.baco_is_support = smu_v11_0_baco_is_support,\n\t.baco_get_state = smu_v11_0_baco_get_state,\n\t.baco_set_state = smu_v11_0_baco_set_state,\n\t.baco_enter = navi10_baco_enter,\n\t.baco_exit = navi10_baco_exit,\n\t.get_dpm_ultimate_freq = smu_v11_0_get_dpm_ultimate_freq,\n\t.set_soft_freq_limited_range = smu_v11_0_set_soft_freq_limited_range,\n\t.set_default_od_settings = navi10_set_default_od_settings,\n\t.od_edit_dpm_table = navi10_od_edit_dpm_table,\n\t.restore_user_od_settings = smu_v11_0_restore_user_od_settings,\n\t.run_btc = navi10_run_btc,\n\t.set_power_source = smu_v11_0_set_power_source,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_pp_feature_mask = smu_cmn_set_pp_feature_mask,\n\t.get_gpu_metrics = navi1x_get_gpu_metrics,\n\t.enable_mgpu_fan_boost = navi10_enable_mgpu_fan_boost,\n\t.gfx_ulv_control = smu_v11_0_gfx_ulv_control,\n\t.deep_sleep_control = smu_v11_0_deep_sleep_control,\n\t.get_fan_parameters = navi10_get_fan_parameters,\n\t.post_init = navi10_post_smu_init,\n\t.interrupt_work = smu_v11_0_interrupt_work,\n\t.set_mp1_state = smu_cmn_set_mp1_state,\n\t.get_default_config_table_settings = navi10_get_default_config_table_settings,\n\t.set_config_table = navi10_set_config_table,\n};\n\nvoid navi10_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &navi10_ppt_funcs;\n\tsmu->message_map = navi10_message_map;\n\tsmu->clock_map = navi10_clk_map;\n\tsmu->feature_map = navi10_feature_mask_map;\n\tsmu->table_map = navi10_table_map;\n\tsmu->pwr_src_map = navi10_pwr_src_map;\n\tsmu->workload_map = navi10_workload_map;\n\tsmu_v11_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}