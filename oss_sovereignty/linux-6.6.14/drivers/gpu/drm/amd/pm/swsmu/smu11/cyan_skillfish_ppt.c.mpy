{
  "module_name": "cyan_skillfish_ppt.c",
  "hash_id": "2284fcba3868c937af61cd3a79a9a1c7062c0b7aecee68c2ad06230951218413",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu11/cyan_skillfish_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"smu_v11_0.h\"\n#include \"smu11_driver_if_cyan_skillfish.h\"\n#include \"cyan_skillfish_ppt.h\"\n#include \"smu_v11_8_ppsmc.h\"\n#include \"smu_v11_8_pmfw.h\"\n#include \"smu_cmn.h\"\n#include \"soc15_common.h\"\n\n \n\n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n \n#define CYAN_SKILLFISH_SCLK_MIN\t\t\t1000\n#define CYAN_SKILLFISH_SCLK_MAX\t\t\t2000\n\n \n#define CYAN_SKILLFISH_VDDC_MIN\t\t\t700\n#define CYAN_SKILLFISH_VDDC_MAX\t\t\t1129\n#define CYAN_SKILLFISH_VDDC_MAGIC\t\t\t5118 \n\nstatic struct gfx_user_settings {\n\tuint32_t sclk;\n\tuint32_t vddc;\n} cyan_skillfish_user_settings;\n\nstatic uint32_t cyan_skillfish_sclk_default;\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_FCLK_DPM_BIT)\t|\t\\\n\tFEATURE_MASK(FEATURE_SOC_DPM_BIT)\t|\t\\\n\tFEATURE_MASK(FEATURE_GFX_DPM_BIT))\n\nstatic struct cmn2asic_msg_mapping cyan_skillfish_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,                    PPSMC_MSG_TestMessage,\t\t\t0),\n\tMSG_MAP(GetSmuVersion,                  PPSMC_MSG_GetSmuVersion,\t\t0),\n\tMSG_MAP(GetDriverIfVersion,             PPSMC_MSG_GetDriverIfVersion,\t\t0),\n\tMSG_MAP(SetDriverDramAddrHigh,          PPSMC_MSG_SetDriverTableDramAddrHigh,\t0),\n\tMSG_MAP(SetDriverDramAddrLow,           PPSMC_MSG_SetDriverTableDramAddrLow,\t0),\n\tMSG_MAP(TransferTableSmu2Dram,          PPSMC_MSG_TransferTableSmu2Dram,\t0),\n\tMSG_MAP(TransferTableDram2Smu,          PPSMC_MSG_TransferTableDram2Smu,\t0),\n\tMSG_MAP(GetEnabledSmuFeatures,          PPSMC_MSG_GetEnabledSmuFeatures,\t0),\n\tMSG_MAP(RequestGfxclk,                  PPSMC_MSG_RequestGfxclk,\t\t0),\n\tMSG_MAP(ForceGfxVid,                    PPSMC_MSG_ForceGfxVid,\t\t\t0),\n\tMSG_MAP(UnforceGfxVid,                  PPSMC_MSG_UnforceGfxVid,\t\t0),\n};\n\nstatic struct cmn2asic_mapping cyan_skillfish_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP_VALID(SMU_METRICS),\n};\n\nstatic int cyan_skillfish_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS,\n\t\t\t\tsizeof(SmuMetrics_t),\n\t\t\t\tPAGE_SIZE,\n\t\t\t\tAMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err0_out;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v2_2);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err1_out;\n\n\tsmu_table->metrics_time = 0;\n\n\treturn 0;\n\nerr1_out:\n\tsmu_table->gpu_metrics_table_size = 0;\n\tkfree(smu_table->metrics_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic int cyan_skillfish_init_smc_tables(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = cyan_skillfish_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smu_v11_0_init_smc_tables(smu);\n}\n\nstatic int\ncyan_skillfish_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\tMetricsMember_t member,\n\t\t\t\t\tuint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_t *metrics = (SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, NULL, false);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->Current.GfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = metrics->Current.SocclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = metrics->Current.VclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = metrics->Current.DclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->Current.MemclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_SOCKETPOWER:\n\t\t*value = (metrics->Current.CurrentSocketPower << 8) /\n\t\t\t\t1000;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = (metrics->Average.CurrentSocketPower << 8) /\n\t\t\t\t1000;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->Current.GfxTemperature / 100 *\n\t\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->Current.SocTemperature / 100 *\n\t\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDSOC:\n\t\t*value = metrics->Current.Voltage[0];\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->Current.Voltage[1];\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->Current.ThrottlerStatus;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int cyan_skillfish_read_sensor(struct smu_context *smu,\n\t\t\t\t\tenum amd_pp_sensors sensor,\n\t\t\t\t\tvoid *data,\n\t\t\t\t\tuint32_t *size)\n{\n\tint ret = 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_GFXCLK,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_UCLK,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_SOCKETPOWER,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDNB:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_VOLTAGE_VDDSOC,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = cyan_skillfish_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_VOLTAGE_VDDGFX,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int cyan_skillfish_get_current_clk_freq(struct smu_context *smu,\n\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t *value)\n{\n\tMetricsMember_t member_type;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tmember_type = METRICS_CURR_GFXCLK;\n\t\tbreak;\n\tcase SMU_FCLK:\n\tcase SMU_MCLK:\n\t\tmember_type = METRICS_CURR_UCLK;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tmember_type = METRICS_CURR_SOCCLK;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tmember_type = METRICS_CURR_VCLK;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tmember_type = METRICS_CURR_DCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cyan_skillfish_get_smu_metrics_data(smu, member_type, value);\n}\n\nstatic int cyan_skillfish_print_clk_levels(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tchar *buf)\n{\n\tint ret = 0, size = 0;\n\tuint32_t cur_value = 0;\n\tint i;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_OD_SCLK:\n\t\tret  = cyan_skillfish_get_smu_metrics_data(smu, METRICS_CURR_GFXCLK, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsize += sysfs_emit_at(buf, size,\"%s:\\n\", \"OD_SCLK\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz *\\n\", cur_value);\n\t\tbreak;\n\tcase SMU_OD_VDDC_CURVE:\n\t\tret  = cyan_skillfish_get_smu_metrics_data(smu, METRICS_VOLTAGE_VDDGFX, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsize += sysfs_emit_at(buf, size,\"%s:\\n\", \"OD_VDDC\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %umV *\\n\", cur_value);\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t\tCYAN_SKILLFISH_SCLK_MIN, CYAN_SKILLFISH_SCLK_MAX);\n\t\tsize += sysfs_emit_at(buf, size, \"VDDC: %7umV  %10umV\\n\",\n\t\t\t\t\t\tCYAN_SKILLFISH_VDDC_MIN, CYAN_SKILLFISH_VDDC_MAX);\n\t\tbreak;\n\tcase SMU_FCLK:\n\tcase SMU_MCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tret = cyan_skillfish_get_current_clk_freq(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz *\\n\", cur_value);\n\t\tbreak;\n\tcase SMU_SCLK:\n\tcase SMU_GFXCLK:\n\t\tret = cyan_skillfish_get_current_clk_freq(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (cur_value  == CYAN_SKILLFISH_SCLK_MAX)\n\t\t\ti = 2;\n\t\telse if (cur_value == CYAN_SKILLFISH_SCLK_MIN)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = 1;\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\", CYAN_SKILLFISH_SCLK_MIN,\n\t\t\t\ti == 0 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\ti == 1 ? cur_value : cyan_skillfish_sclk_default,\n\t\t\t\ti == 1 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz %s\\n\", CYAN_SKILLFISH_SCLK_MAX,\n\t\t\t\ti == 2 ? \"*\" : \"\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(smu->adev->dev, \"Unsupported clock type\\n\");\n\t\treturn ret;\n\t}\n\n\treturn size;\n}\n\nstatic bool cyan_skillfish_is_dpm_running(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\t \n\tif (adev->in_suspend)\n\t\treturn false;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\tif (ret)\n\t\treturn false;\n\n\t \n\tif (!cyan_skillfish_sclk_default)\n\t\tcyan_skillfish_get_smu_metrics_data(smu, METRICS_CURR_GFXCLK,\n\t\t\t&cyan_skillfish_sclk_default);\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic ssize_t cyan_skillfish_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t\tvoid **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_2 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_2 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint i, ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 2);\n\n\tgpu_metrics->temperature_gfx = metrics.Current.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.Current.SocTemperature;\n\n\tgpu_metrics->average_socket_power = metrics.Current.CurrentSocketPower;\n\tgpu_metrics->average_soc_power = metrics.Current.Power[0];\n\tgpu_metrics->average_gfx_power = metrics.Current.Power[1];\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.Average.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.Average.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.Average.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.Average.DclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.Current.GfxclkFrequency;\n\tgpu_metrics->current_socclk = metrics.Current.SocclkFrequency;\n\tgpu_metrics->current_uclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_fclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_vclk = metrics.Current.VclkFrequency;\n\tgpu_metrics->current_dclk = metrics.Current.DclkFrequency;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tgpu_metrics->temperature_core[i] = metrics.Current.CoreTemperature[i];\n\t\tgpu_metrics->average_core_power[i] = metrics.Average.CorePower[i];\n\t\tgpu_metrics->current_coreclk[i] = metrics.Current.CoreFrequency[i];\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tgpu_metrics->temperature_l3[i] = metrics.Current.L3Temperature[i];\n\t\tgpu_metrics->current_l3clk[i] = metrics.Current.L3Frequency[i];\n\t}\n\n\tgpu_metrics->throttle_status = metrics.Current.ThrottlerStatus;\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_2);\n}\n\nstatic int cyan_skillfish_od_edit_dpm_table(struct smu_context *smu,\n\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tlong input[], uint32_t size)\n{\n\tint ret = 0;\n\tuint32_t vid;\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_VDDC_CURVE:\n\t\tif (size != 3 || input[0] != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid parameter!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[1] < CYAN_SKILLFISH_SCLK_MIN ||\n\t\t\tinput[1] > CYAN_SKILLFISH_SCLK_MAX) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid sclk! Valid sclk range: %uMHz - %uMhz\\n\",\n\t\t\t\t\tCYAN_SKILLFISH_SCLK_MIN, CYAN_SKILLFISH_SCLK_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[2] < CYAN_SKILLFISH_VDDC_MIN ||\n\t\t\tinput[2] > CYAN_SKILLFISH_VDDC_MAX) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid vddc! Valid vddc range: %umV - %umV\\n\",\n\t\t\t\t\tCYAN_SKILLFISH_VDDC_MIN, CYAN_SKILLFISH_VDDC_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcyan_skillfish_user_settings.sclk = input[1];\n\t\tcyan_skillfish_user_settings.vddc = input[2];\n\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid parameter!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcyan_skillfish_user_settings.sclk = cyan_skillfish_sclk_default;\n\t\tcyan_skillfish_user_settings.vddc = CYAN_SKILLFISH_VDDC_MAGIC;\n\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid parameter!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cyan_skillfish_user_settings.sclk < CYAN_SKILLFISH_SCLK_MIN ||\n\t\t    cyan_skillfish_user_settings.sclk > CYAN_SKILLFISH_SCLK_MAX) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid sclk! Valid sclk range: %uMHz - %uMhz\\n\",\n\t\t\t\t\tCYAN_SKILLFISH_SCLK_MIN, CYAN_SKILLFISH_SCLK_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((cyan_skillfish_user_settings.vddc != CYAN_SKILLFISH_VDDC_MAGIC) &&\n\t\t\t(cyan_skillfish_user_settings.vddc < CYAN_SKILLFISH_VDDC_MIN ||\n\t\t\tcyan_skillfish_user_settings.vddc > CYAN_SKILLFISH_VDDC_MAX)) {\n\t\t\tdev_err(smu->adev->dev, \"Invalid vddc! Valid vddc range: %umV - %umV\\n\",\n\t\t\t\t\tCYAN_SKILLFISH_VDDC_MIN, CYAN_SKILLFISH_VDDC_MAX);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_RequestGfxclk,\n\t\t\t\t\tcyan_skillfish_user_settings.sclk, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Set sclk failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (cyan_skillfish_user_settings.vddc == CYAN_SKILLFISH_VDDC_MAGIC) {\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_UnforceGfxVid, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Unforce vddc failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tvid = (1550 - cyan_skillfish_user_settings.vddc) * 160 / 1000;\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_ForceGfxVid, vid, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Force vddc failed!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int cyan_skillfish_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t *min,\n\t\t\t\t\t\tuint32_t *max)\n{\n\tint ret = 0;\n\tuint32_t low, high;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tlow = CYAN_SKILLFISH_SCLK_MIN;\n\t\thigh = CYAN_SKILLFISH_SCLK_MAX;\n\t\tbreak;\n\tdefault:\n\t\tret = cyan_skillfish_get_current_clk_freq(smu, clk_type, &low);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\thigh = low;\n\t\tbreak;\n\t}\n\n\tif (min)\n\t\t*min = low;\n\tif (max)\n\t\t*max = high;\n\n\treturn 0;\n}\n\nstatic int cyan_skillfish_get_enabled_mask(struct smu_context *smu,\n\t\t\t\t\t   uint64_t *feature_mask)\n{\n\tif (!feature_mask)\n\t\treturn -EINVAL;\n\tmemset(feature_mask, 0xff, sizeof(*feature_mask));\n\n\treturn 0;\n}\n\nstatic const struct pptable_funcs cyan_skillfish_ppt_funcs = {\n\n\t.check_fw_status = smu_v11_0_check_fw_status,\n\t.check_fw_version = smu_v11_0_check_fw_version,\n\t.init_power = smu_v11_0_init_power,\n\t.fini_power = smu_v11_0_fini_power,\n\t.init_smc_tables = cyan_skillfish_init_smc_tables,\n\t.fini_smc_tables = smu_v11_0_fini_smc_tables,\n\t.read_sensor = cyan_skillfish_read_sensor,\n\t.print_clk_levels = cyan_skillfish_print_clk_levels,\n\t.get_enabled_mask = cyan_skillfish_get_enabled_mask,\n\t.is_dpm_running = cyan_skillfish_is_dpm_running,\n\t.get_gpu_metrics = cyan_skillfish_get_gpu_metrics,\n\t.od_edit_dpm_table = cyan_skillfish_od_edit_dpm_table,\n\t.get_dpm_ultimate_freq = cyan_skillfish_get_dpm_ultimate_freq,\n\t.register_irq_handler = smu_v11_0_register_irq_handler,\n\t.notify_memory_pool_location = smu_v11_0_notify_memory_pool_location,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.set_driver_table_location = smu_v11_0_set_driver_table_location,\n\t.interrupt_work = smu_v11_0_interrupt_work,\n};\n\nvoid cyan_skillfish_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &cyan_skillfish_ppt_funcs;\n\tsmu->message_map = cyan_skillfish_message_map;\n\tsmu->table_map = cyan_skillfish_table_map;\n\tsmu->is_apu = true;\n\tsmu_v11_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}