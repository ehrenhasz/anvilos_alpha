{
  "module_name": "vangogh_ppt.c",
  "hash_id": "aebf5ef06eac9499645c95081571569564a7a3be0a60eb93fc1a5d6b2303eed3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu11/vangogh_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"smu_v11_0.h\"\n#include \"smu11_driver_if_vangogh.h\"\n#include \"vangogh_ppt.h\"\n#include \"smu_v11_5_ppsmc.h\"\n#include \"smu_v11_5_pmfw.h\"\n#include \"smu_cmn.h\"\n#include \"soc15_common.h\"\n#include \"asic_reg/gc/gc_10_3_0_offset.h\"\n#include \"asic_reg/gc/gc_10_3_0_sh_mask.h\"\n#include <asm/processor.h>\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n\n\n\n#define mmSMUIO_GFX_MISC_CNTL\t\t\t0x00c5\n#define mmSMUIO_GFX_MISC_CNTL_BASE_IDX\t\t0\n\n\n#define SMUIO_GFX_MISC_CNTL__SMU_GFX_cold_vs_gfxoff__SHIFT\t0x0\n#define SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS__SHIFT\t\t0x1\n#define SMUIO_GFX_MISC_CNTL__SMU_GFX_cold_vs_gfxoff_MASK\t0x00000001L\n#define SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS_MASK\t\t0x00000006L\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_CCLK_DPM_BIT) | \\\n\tFEATURE_MASK(FEATURE_VCN_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_FCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_SOCCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_MP0CLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_LCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_SHUBCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DCFCLK_DPM_BIT)| \\\n\tFEATURE_MASK(FEATURE_GFX_DPM_BIT))\n\nstatic struct cmn2asic_msg_mapping vangogh_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,                    PPSMC_MSG_TestMessage,\t\t\t0),\n\tMSG_MAP(GetSmuVersion,                  PPSMC_MSG_GetSmuVersion,\t\t0),\n\tMSG_MAP(GetDriverIfVersion,             PPSMC_MSG_GetDriverIfVersion,\t0),\n\tMSG_MAP(EnableGfxOff,                   PPSMC_MSG_EnableGfxOff,\t\t\t0),\n\tMSG_MAP(AllowGfxOff,                    PPSMC_MSG_AllowGfxOff,          0),\n\tMSG_MAP(DisallowGfxOff,                 PPSMC_MSG_DisallowGfxOff,\t\t0),\n\tMSG_MAP(PowerDownIspByTile,             PPSMC_MSG_PowerDownIspByTile,\t0),\n\tMSG_MAP(PowerUpIspByTile,               PPSMC_MSG_PowerUpIspByTile,\t\t0),\n\tMSG_MAP(PowerDownVcn,                   PPSMC_MSG_PowerDownVcn,\t\t\t0),\n\tMSG_MAP(PowerUpVcn,                     PPSMC_MSG_PowerUpVcn,\t\t\t0),\n\tMSG_MAP(RlcPowerNotify,                 PPSMC_MSG_RlcPowerNotify,\t\t0),\n\tMSG_MAP(SetHardMinVcn,                  PPSMC_MSG_SetHardMinVcn,\t\t0),\n\tMSG_MAP(SetSoftMinGfxclk,               PPSMC_MSG_SetSoftMinGfxclk,\t\t0),\n\tMSG_MAP(ActiveProcessNotify,            PPSMC_MSG_ActiveProcessNotify,\t\t0),\n\tMSG_MAP(SetHardMinIspiclkByFreq,        PPSMC_MSG_SetHardMinIspiclkByFreq,\t0),\n\tMSG_MAP(SetHardMinIspxclkByFreq,        PPSMC_MSG_SetHardMinIspxclkByFreq,\t0),\n\tMSG_MAP(SetDriverDramAddrHigh,          PPSMC_MSG_SetDriverDramAddrHigh,\t0),\n\tMSG_MAP(SetDriverDramAddrLow,           PPSMC_MSG_SetDriverDramAddrLow,\t\t0),\n\tMSG_MAP(TransferTableSmu2Dram,          PPSMC_MSG_TransferTableSmu2Dram,\t0),\n\tMSG_MAP(TransferTableDram2Smu,          PPSMC_MSG_TransferTableDram2Smu,\t0),\n\tMSG_MAP(GfxDeviceDriverReset,           PPSMC_MSG_GfxDeviceDriverReset,\t\t0),\n\tMSG_MAP(GetEnabledSmuFeatures,          PPSMC_MSG_GetEnabledSmuFeatures,\t0),\n\tMSG_MAP(SetHardMinSocclkByFreq,         PPSMC_MSG_SetHardMinSocclkByFreq,\t0),\n\tMSG_MAP(SetSoftMinFclk,                 PPSMC_MSG_SetSoftMinFclk,\t\t0),\n\tMSG_MAP(SetSoftMinVcn,                  PPSMC_MSG_SetSoftMinVcn,\t\t0),\n\tMSG_MAP(EnablePostCode,                 PPSMC_MSG_EnablePostCode,\t\t0),\n\tMSG_MAP(GetGfxclkFrequency,             PPSMC_MSG_GetGfxclkFrequency,\t0),\n\tMSG_MAP(GetFclkFrequency,               PPSMC_MSG_GetFclkFrequency,\t\t0),\n\tMSG_MAP(SetSoftMaxGfxClk,               PPSMC_MSG_SetSoftMaxGfxClk,\t\t0),\n\tMSG_MAP(SetHardMinGfxClk,               PPSMC_MSG_SetHardMinGfxClk,\t\t0),\n\tMSG_MAP(SetSoftMaxSocclkByFreq,         PPSMC_MSG_SetSoftMaxSocclkByFreq,\t0),\n\tMSG_MAP(SetSoftMaxFclkByFreq,           PPSMC_MSG_SetSoftMaxFclkByFreq,\t\t0),\n\tMSG_MAP(SetSoftMaxVcn,                  PPSMC_MSG_SetSoftMaxVcn,\t\t\t0),\n\tMSG_MAP(SetPowerLimitPercentage,        PPSMC_MSG_SetPowerLimitPercentage,\t0),\n\tMSG_MAP(PowerDownJpeg,                  PPSMC_MSG_PowerDownJpeg,\t\t\t0),\n\tMSG_MAP(PowerUpJpeg,                    PPSMC_MSG_PowerUpJpeg,\t\t\t\t0),\n\tMSG_MAP(SetHardMinFclkByFreq,           PPSMC_MSG_SetHardMinFclkByFreq,\t\t0),\n\tMSG_MAP(SetSoftMinSocclkByFreq,         PPSMC_MSG_SetSoftMinSocclkByFreq,\t0),\n\tMSG_MAP(PowerUpCvip,                    PPSMC_MSG_PowerUpCvip,\t\t\t\t0),\n\tMSG_MAP(PowerDownCvip,                  PPSMC_MSG_PowerDownCvip,\t\t\t0),\n\tMSG_MAP(GetPptLimit,                        PPSMC_MSG_GetPptLimit,\t\t\t0),\n\tMSG_MAP(GetThermalLimit,                    PPSMC_MSG_GetThermalLimit,\t\t0),\n\tMSG_MAP(GetCurrentTemperature,              PPSMC_MSG_GetCurrentTemperature, 0),\n\tMSG_MAP(GetCurrentPower,                    PPSMC_MSG_GetCurrentPower,\t\t 0),\n\tMSG_MAP(GetCurrentVoltage,                  PPSMC_MSG_GetCurrentVoltage,\t 0),\n\tMSG_MAP(GetCurrentCurrent,                  PPSMC_MSG_GetCurrentCurrent,\t 0),\n\tMSG_MAP(GetAverageCpuActivity,              PPSMC_MSG_GetAverageCpuActivity, 0),\n\tMSG_MAP(GetAverageGfxActivity,              PPSMC_MSG_GetAverageGfxActivity, 0),\n\tMSG_MAP(GetAveragePower,                    PPSMC_MSG_GetAveragePower,\t\t 0),\n\tMSG_MAP(GetAverageTemperature,              PPSMC_MSG_GetAverageTemperature, 0),\n\tMSG_MAP(SetAveragePowerTimeConstant,        PPSMC_MSG_SetAveragePowerTimeConstant,\t\t\t0),\n\tMSG_MAP(SetAverageActivityTimeConstant,     PPSMC_MSG_SetAverageActivityTimeConstant,\t\t0),\n\tMSG_MAP(SetAverageTemperatureTimeConstant,  PPSMC_MSG_SetAverageTemperatureTimeConstant,\t0),\n\tMSG_MAP(SetMitigationEndHysteresis,         PPSMC_MSG_SetMitigationEndHysteresis,\t\t\t0),\n\tMSG_MAP(GetCurrentFreq,                     PPSMC_MSG_GetCurrentFreq,\t\t\t\t\t\t0),\n\tMSG_MAP(SetReducedPptLimit,                 PPSMC_MSG_SetReducedPptLimit,\t\t\t\t\t0),\n\tMSG_MAP(SetReducedThermalLimit,             PPSMC_MSG_SetReducedThermalLimit,\t\t\t\t0),\n\tMSG_MAP(DramLogSetDramAddr,                 PPSMC_MSG_DramLogSetDramAddr,\t\t\t\t\t0),\n\tMSG_MAP(StartDramLogging,                   PPSMC_MSG_StartDramLogging,\t\t\t\t\t\t0),\n\tMSG_MAP(StopDramLogging,                    PPSMC_MSG_StopDramLogging,\t\t\t\t\t\t0),\n\tMSG_MAP(SetSoftMinCclk,                     PPSMC_MSG_SetSoftMinCclk,\t\t\t\t\t\t0),\n\tMSG_MAP(SetSoftMaxCclk,                     PPSMC_MSG_SetSoftMaxCclk,\t\t\t\t\t\t0),\n\tMSG_MAP(RequestActiveWgp,                   PPSMC_MSG_RequestActiveWgp,                     0),\n\tMSG_MAP(SetFastPPTLimit,                    PPSMC_MSG_SetFastPPTLimit,\t\t\t\t\t\t0),\n\tMSG_MAP(SetSlowPPTLimit,                    PPSMC_MSG_SetSlowPPTLimit,\t\t\t\t\t\t0),\n\tMSG_MAP(GetFastPPTLimit,                    PPSMC_MSG_GetFastPPTLimit,\t\t\t\t\t\t0),\n\tMSG_MAP(GetSlowPPTLimit,                    PPSMC_MSG_GetSlowPPTLimit,\t\t\t\t\t\t0),\n\tMSG_MAP(GetGfxOffStatus,\t\t    PPSMC_MSG_GetGfxOffStatus,\t\t\t\t\t\t0),\n\tMSG_MAP(GetGfxOffEntryCount,\t\t    PPSMC_MSG_GetGfxOffEntryCount,\t\t\t\t\t0),\n\tMSG_MAP(LogGfxOffResidency,\t\t    PPSMC_MSG_LogGfxOffResidency,\t\t\t\t\t0),\n};\n\nstatic struct cmn2asic_mapping vangogh_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(PPT),\n\tFEA_MAP(TDC),\n\tFEA_MAP(THERMAL),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_FCLK),\n\tFEA_MAP(DS_MP1CLK),\n\tFEA_MAP(DS_MP0CLK),\n\tFEA_MAP(ATHUB_PG),\n\tFEA_MAP(CCLK_DPM),\n\tFEA_MAP(FAN_CONTROLLER),\n\tFEA_MAP(ULV),\n\tFEA_MAP(VCN_DPM),\n\tFEA_MAP(LCLK_DPM),\n\tFEA_MAP(SHUBCLK_DPM),\n\tFEA_MAP(DCFCLK_DPM),\n\tFEA_MAP(DS_DCFCLK),\n\tFEA_MAP(S0I2),\n\tFEA_MAP(SMU_LOW_POWER),\n\tFEA_MAP(GFX_DEM),\n\tFEA_MAP(PSI),\n\tFEA_MAP(PROCHOT),\n\tFEA_MAP(CPUOFF),\n\tFEA_MAP(STAPM),\n\tFEA_MAP(S0I3),\n\tFEA_MAP(DF_CSTATES),\n\tFEA_MAP(PERF_LIMIT),\n\tFEA_MAP(CORE_DLDO),\n\tFEA_MAP(RSMU_LOW_POWER),\n\tFEA_MAP(SMN_LOW_POWER),\n\tFEA_MAP(THM_LOW_POWER),\n\tFEA_MAP(SMUIO_LOW_POWER),\n\tFEA_MAP(MP1_LOW_POWER),\n\tFEA_MAP(DS_VCN),\n\tFEA_MAP(CPPC),\n\tFEA_MAP(OS_CSTATES),\n\tFEA_MAP(ISP_DPM),\n\tFEA_MAP(A55_DPM),\n\tFEA_MAP(CVIP_DSP_DPM),\n\tFEA_MAP(MSMU_LOW_POWER),\n\tFEA_MAP_REVERSE(SOCCLK),\n\tFEA_MAP_REVERSE(FCLK),\n\tFEA_MAP_HALF_REVERSE(GFX),\n};\n\nstatic struct cmn2asic_mapping vangogh_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP_VALID(WATERMARKS),\n\tTAB_MAP_VALID(SMU_METRICS),\n\tTAB_MAP_VALID(CUSTOM_DPM),\n\tTAB_MAP_VALID(DPMCLOCKS),\n};\n\nstatic struct cmn2asic_mapping vangogh_workload_map[PP_SMC_POWER_PROFILE_COUNT] = {\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_FULLSCREEN3D,\t\tWORKLOAD_PPLIB_FULL_SCREEN_3D_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VIDEO,\t\tWORKLOAD_PPLIB_VIDEO_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VR,\t\t\tWORKLOAD_PPLIB_VR_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_COMPUTE,\t\tWORKLOAD_PPLIB_COMPUTE_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CUSTOM,\t\tWORKLOAD_PPLIB_CUSTOM_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CAPPED,\t\tWORKLOAD_PPLIB_CAPPED_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_UNCAPPED,\t\tWORKLOAD_PPLIB_UNCAPPED_BIT),\n};\n\nstatic const uint8_t vangogh_throttler_map[] = {\n\t[THROTTLER_STATUS_BIT_SPL]\t= (SMU_THROTTLER_SPL_BIT),\n\t[THROTTLER_STATUS_BIT_FPPT]\t= (SMU_THROTTLER_FPPT_BIT),\n\t[THROTTLER_STATUS_BIT_SPPT]\t= (SMU_THROTTLER_SPPT_BIT),\n\t[THROTTLER_STATUS_BIT_SPPT_APU]\t= (SMU_THROTTLER_SPPT_APU_BIT),\n\t[THROTTLER_STATUS_BIT_THM_CORE]\t= (SMU_THROTTLER_TEMP_CORE_BIT),\n\t[THROTTLER_STATUS_BIT_THM_GFX]\t= (SMU_THROTTLER_TEMP_GPU_BIT),\n\t[THROTTLER_STATUS_BIT_THM_SOC]\t= (SMU_THROTTLER_TEMP_SOC_BIT),\n\t[THROTTLER_STATUS_BIT_TDC_VDD]\t= (SMU_THROTTLER_TDC_VDD_BIT),\n\t[THROTTLER_STATUS_BIT_TDC_SOC]\t= (SMU_THROTTLER_TDC_SOC_BIT),\n\t[THROTTLER_STATUS_BIT_TDC_GFX]\t= (SMU_THROTTLER_TDC_GFX_BIT),\n\t[THROTTLER_STATUS_BIT_TDC_CVIP]\t= (SMU_THROTTLER_TDC_CVIP_BIT),\n};\n\nstatic int vangogh_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\tuint32_t if_version;\n\tuint32_t smu_version;\n\tuint32_t ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_DPMCLOCKS, sizeof(DpmClocks_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PMSTATUSLOG, SMU11_TOOL_SIZE,\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ACTIVITY_MONITOR_COEFF, sizeof(DpmActivityMonitorCoeffExt_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tif (if_version < 0x3) {\n\t\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_legacy_t),\n\t\t\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\t\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_legacy_t), GFP_KERNEL);\n\t} else {\n\t\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_t),\n\t\t\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\t\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_t), GFP_KERNEL);\n\t}\n\tif (!smu_table->metrics_table)\n\t\tgoto err0_out;\n\tsmu_table->metrics_time = 0;\n\n\tif (smu_version >= 0x043F3E00)\n\t\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v2_3);\n\telse\n\t\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v2_2);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err1_out;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->clocks_table = kzalloc(sizeof(DpmClocks_t), GFP_KERNEL);\n\tif (!smu_table->clocks_table)\n\t\tgoto err3_out;\n\n\treturn 0;\n\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->gpu_metrics_table);\nerr1_out:\n\tkfree(smu_table->metrics_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic int vangogh_get_legacy_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_legacy_t *metrics = (SmuMetrics_legacy_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->GfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->SocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK:\n\t\t*value = metrics->VclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK:\n\t\t*value = metrics->DclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->MemclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->GfxActivity / 100;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCNACTIVITY:\n\t\t*value = metrics->UvdActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = (metrics->CurrentSocketPower << 8) /\n\t\t1000 ;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->GfxTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->SocTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->Voltage[2];\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDSOC:\n\t\t*value = metrics->Voltage[1];\n\t\tbreak;\n\tcase METRICS_AVERAGE_CPUCLK:\n\t\tmemcpy(value, &metrics->CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t));\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_t *metrics = (SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = metrics->Current.GfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->Current.SocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK:\n\t\t*value = metrics->Current.VclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK:\n\t\t*value = metrics->Current.DclkFrequency;\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = metrics->Current.MemclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->Current.GfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCNACTIVITY:\n\t\t*value = metrics->Current.UvdActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = (metrics->Average.CurrentSocketPower << 8) /\n\t\t1000;\n\t\tbreak;\n\tcase METRICS_CURR_SOCKETPOWER:\n\t\t*value = (metrics->Current.CurrentSocketPower << 8) /\n\t\t1000;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->Current.GfxTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->Current.SocTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->Current.ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->Current.Voltage[2];\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDSOC:\n\t\t*value = metrics->Current.Voltage[1];\n\t\tbreak;\n\tcase METRICS_AVERAGE_CPUCLK:\n\t\tmemcpy(value, &metrics->Current.CoreFrequency[0],\n\t\t       smu->cpu_core_num * sizeof(uint16_t));\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_common_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t if_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, NULL);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"Failed to get smu if version!\\n\");\n\t\treturn ret;\n\t}\n\n\tif (if_version < 0x3)\n\t\tret = vangogh_get_legacy_smu_metrics_data(smu, member, value);\n\telse\n\t\tret = vangogh_get_smu_metrics_data(smu, member, value);\n\n\treturn ret;\n}\n\nstatic int vangogh_allocate_dpm_context(struct smu_context *smu)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tsmu_dpm->dpm_context = kzalloc(sizeof(struct smu_11_0_dpm_context),\n\t\t\t\t       GFP_KERNEL);\n\tif (!smu_dpm->dpm_context)\n\t\treturn -ENOMEM;\n\n\tsmu_dpm->dpm_context_size = sizeof(struct smu_11_0_dpm_context);\n\n\treturn 0;\n}\n\nstatic int vangogh_init_smc_tables(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = vangogh_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_allocate_dpm_context(smu);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_X86\n\t \n\tsmu->cpu_core_num = boot_cpu_data.x86_max_cores;\n#else\n\tsmu->cpu_core_num = 4;\n#endif\n\n\treturn smu_v11_0_init_smc_tables(smu);\n}\n\nstatic int vangogh_dpm_set_vcn_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\t \n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpVcn, 0, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerDownVcn, 0, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_dpm_set_jpeg_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpJpeg, 0, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerDownJpeg, 0, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic bool vangogh_is_dpm_running(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\t \n\tif (adev->in_suspend)\n\t\treturn false;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int vangogh_get_dpm_clk_limited(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t dpm_level, uint32_t *freq)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tif (!clk_table || clk_type >= SMU_CLK_COUNT)\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tif (dpm_level >= clk_table->NumSocClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->SocClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tif (dpm_level >= clk_table->VcnClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->VcnClocks[dpm_level].vclk;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tif (dpm_level >= clk_table->VcnClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->VcnClocks[dpm_level].dclk;\n\t\tbreak;\n\tcase SMU_UCLK:\n\tcase SMU_MCLK:\n\t\tif (dpm_level >= clk_table->NumDfPstatesEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DfPstateTable[dpm_level].memclk;\n\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tif (dpm_level >= clk_table->NumDfPstatesEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DfPstateTable[dpm_level].fclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vangogh_print_legacy_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\tSmuMetrics_legacy_t metrics;\n\tstruct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);\n\tint i, idx, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0;\n\tbool cur_value_match_level = false;\n\n\tmemset(&metrics, 0, sizeof(metrics));\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, false);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_OD_SCLK:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_SCLK\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %10uMhz\\n\",\n\t\t\t(smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq);\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %10uMhz\\n\",\n\t\t\t(smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_CCLK:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"CCLK_RANGE in Core%d:\\n\",  smu->cpu_core_id_select);\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %10uMhz\\n\",\n\t\t\t(smu->cpu_actual_soft_min_freq > 0) ? smu->cpu_actual_soft_min_freq : smu->cpu_default_soft_min_freq);\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %10uMhz\\n\",\n\t\t\t(smu->cpu_actual_soft_max_freq > 0) ? smu->cpu_actual_soft_max_freq : smu->cpu_default_soft_max_freq);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\tsmu->gfx_default_hard_min_freq, smu->gfx_default_soft_max_freq);\n\t\t\tsize += sysfs_emit_at(buf, size, \"CCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\tsmu->cpu_default_soft_min_freq, smu->cpu_default_soft_max_freq);\n\t\t}\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\t \n\t\tcount = clk_table->NumSocClkLevelsEnabled;\n\t\tcur_value = metrics.SocclkFrequency;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tcount = clk_table->VcnClkLevelsEnabled;\n\t\tcur_value = metrics.VclkFrequency;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tcount = clk_table->VcnClkLevelsEnabled;\n\t\tcur_value = metrics.DclkFrequency;\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\tcount = clk_table->NumDfPstatesEnabled;\n\t\tcur_value = metrics.MemclkFrequency;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tcount = clk_table->NumDfPstatesEnabled;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetFclkFrequency, 0, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\tcase SMU_MCLK:\n\tcase SMU_FCLK:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tidx = (clk_type == SMU_FCLK || clk_type == SMU_MCLK) ? (count - i - 1) : i;\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, idx, &value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (!value)\n\t\t\t\tcontinue;\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t\tif (cur_value == value)\n\t\t\t\tcur_value_match_level = true;\n\t\t}\n\n\t\tif (!cur_value_match_level)\n\t\t\tsize += sysfs_emit_at(buf, size, \"   %uMhz *\\n\", cur_value);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int vangogh_print_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\tSmuMetrics_t metrics;\n\tstruct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);\n\tint i, idx, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0;\n\tbool cur_value_match_level = false;\n\tuint32_t min, max;\n\n\tmemset(&metrics, 0, sizeof(metrics));\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, false);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_OD_SCLK:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_SCLK\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %10uMhz\\n\",\n\t\t\t(smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq);\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %10uMhz\\n\",\n\t\t\t(smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_CCLK:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"CCLK_RANGE in Core%d:\\n\",  smu->cpu_core_id_select);\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %10uMhz\\n\",\n\t\t\t(smu->cpu_actual_soft_min_freq > 0) ? smu->cpu_actual_soft_min_freq : smu->cpu_default_soft_min_freq);\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %10uMhz\\n\",\n\t\t\t(smu->cpu_actual_soft_max_freq > 0) ? smu->cpu_actual_soft_max_freq : smu->cpu_default_soft_max_freq);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\tsmu->gfx_default_hard_min_freq, smu->gfx_default_soft_max_freq);\n\t\t\tsize += sysfs_emit_at(buf, size, \"CCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\tsmu->cpu_default_soft_min_freq, smu->cpu_default_soft_max_freq);\n\t\t}\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\t \n\t\tcount = clk_table->NumSocClkLevelsEnabled;\n\t\tcur_value = metrics.Current.SocclkFrequency;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tcount = clk_table->VcnClkLevelsEnabled;\n\t\tcur_value = metrics.Current.VclkFrequency;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tcount = clk_table->VcnClkLevelsEnabled;\n\t\tcur_value = metrics.Current.DclkFrequency;\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\tcount = clk_table->NumDfPstatesEnabled;\n\t\tcur_value = metrics.Current.MemclkFrequency;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tcount = clk_table->NumDfPstatesEnabled;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetFclkFrequency, 0, &cur_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetGfxclkFrequency, 0, &cur_value);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\tcase SMU_MCLK:\n\tcase SMU_FCLK:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tidx = (clk_type == SMU_FCLK || clk_type == SMU_MCLK) ? (count - i - 1) : i;\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, idx, &value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (!value)\n\t\t\t\tcontinue;\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t\tif (cur_value == value)\n\t\t\t\tcur_value_match_level = true;\n\t\t}\n\n\t\tif (!cur_value_match_level)\n\t\t\tsize += sysfs_emit_at(buf, size, \"   %uMhz *\\n\", cur_value);\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tmin = (smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq;\n\t\tmax = (smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq;\n\t\tif (cur_value  == max)\n\t\t\ti = 2;\n\t\telse if (cur_value == min)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = 1;\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\", min,\n\t\t\t\ti == 0 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\ti == 1 ? cur_value : VANGOGH_UMD_PSTATE_STANDARD_GFXCLK,\n\t\t\t\ti == 1 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz %s\\n\", max,\n\t\t\t\ti == 2 ? \"*\" : \"\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic int vangogh_common_print_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t if_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, NULL);\n\tif (ret) {\n\t\tdev_err(adev->dev, \"Failed to get smu if version!\\n\");\n\t\treturn ret;\n\t}\n\n\tif (if_version < 0x3)\n\t\tret = vangogh_print_legacy_clk_levels(smu, clk_type, buf);\n\telse\n\t\tret = vangogh_print_clk_levels(smu, clk_type, buf);\n\n\treturn ret;\n}\n\nstatic int vangogh_get_profiling_clk_mask(struct smu_context *smu,\n\t\t\t\t\t enum amd_dpm_forced_level level,\n\t\t\t\t\t uint32_t *vclk_mask,\n\t\t\t\t\t uint32_t *dclk_mask,\n\t\t\t\t\t uint32_t *mclk_mask,\n\t\t\t\t\t uint32_t *fclk_mask,\n\t\t\t\t\t uint32_t *soc_mask)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK) {\n\t\tif (mclk_mask)\n\t\t\t*mclk_mask = clk_table->NumDfPstatesEnabled - 1;\n\n\t\tif (fclk_mask)\n\t\t\t*fclk_mask = clk_table->NumDfPstatesEnabled - 1;\n\n\t\tif (soc_mask)\n\t\t\t*soc_mask = 0;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\tif (mclk_mask)\n\t\t\t*mclk_mask = 0;\n\n\t\tif (fclk_mask)\n\t\t\t*fclk_mask = 0;\n\n\t\tif (soc_mask)\n\t\t\t*soc_mask = 1;\n\n\t\tif (vclk_mask)\n\t\t\t*vclk_mask = 1;\n\n\t\tif (dclk_mask)\n\t\t\t*dclk_mask = 1;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD) {\n\t\tif (mclk_mask)\n\t\t\t*mclk_mask = 0;\n\n\t\tif (fclk_mask)\n\t\t\t*fclk_mask = 0;\n\n\t\tif (soc_mask)\n\t\t\t*soc_mask = 1;\n\n\t\tif (vclk_mask)\n\t\t\t*vclk_mask = 1;\n\n\t\tif (dclk_mask)\n\t\t\t*dclk_mask = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic bool vangogh_clk_dpm_is_enabled(struct smu_context *smu,\n\t\t\t\tenum smu_clk_type clk_type)\n{\n\tenum smu_feature_mask feature_id = 0;\n\n\tswitch (clk_type) {\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_FCLK_BIT;\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_GFXCLK_BIT;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_SOCCLK_BIT;\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tfeature_id = SMU_FEATURE_VCN_DPM_BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn true;\n\t}\n\n\tif (!smu_cmn_feature_is_enabled(smu, feature_id))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int vangogh_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tuint32_t *min,\n\t\t\t\t\tuint32_t *max)\n{\n\tint ret = 0;\n\tuint32_t soc_mask;\n\tuint32_t vclk_mask;\n\tuint32_t dclk_mask;\n\tuint32_t mclk_mask;\n\tuint32_t fclk_mask;\n\tuint32_t clock_limit;\n\n\tif (!vangogh_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.uclk;\n\t\t\tbreak;\n\t\tcase SMU_FCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.fclk;\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.gfxclk;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.socclk;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.vclk;\n\t\t\tbreak;\n\t\tcase SMU_DCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.dclk;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclock_limit = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (min)\n\t\t\t*min = clock_limit / 100;\n\t\tif (max)\n\t\t\t*max = clock_limit / 100;\n\n\t\treturn 0;\n\t}\n\tif (max) {\n\t\tret = vangogh_get_profiling_clk_mask(smu,\n\t\t\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_PEAK,\n\t\t\t\t\t\t\t&vclk_mask,\n\t\t\t\t\t\t\t&dclk_mask,\n\t\t\t\t\t\t\t&mclk_mask,\n\t\t\t\t\t\t\t&fclk_mask,\n\t\t\t\t\t\t\t&soc_mask);\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\tswitch (clk_type) {\n\t\tcase SMU_UCLK:\n\t\tcase SMU_MCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, mclk_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, soc_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_FCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, fclk_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, vclk_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_DCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, dclk_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tif (min) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_UCLK:\n\t\tcase SMU_MCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, mclk_mask, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, soc_mask, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_FCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, fclk_mask, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, vclk_mask, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_DCLK:\n\t\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type, dclk_mask, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\t}\nfailed:\n\treturn ret;\n}\n\nstatic int vangogh_get_power_profile_mode(struct smu_context *smu,\n\t\t\t\t\t   char *buf)\n{\n\tuint32_t i, size = 0;\n\tint16_t workload_type = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < PP_SMC_POWER_PROFILE_COUNT; i++) {\n\t\t \n\t\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t\t       i);\n\n\t\tif (workload_type < 0)\n\t\t\tcontinue;\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == smu->power_profile_mode) ? \"*\" : \" \");\n\t}\n\n\treturn size;\n}\n\nstatic int vangogh_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)\n{\n\tint workload_type, ret;\n\tuint32_t profile_mode = input[size];\n\n\tif (profile_mode >= PP_SMC_POWER_PROFILE_COUNT) {\n\t\tdev_err(smu->adev->dev, \"Invalid power profile mode %d\\n\", profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (profile_mode == PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT ||\n\t\t\tprofile_mode == PP_SMC_POWER_PROFILE_POWERSAVING)\n\t\treturn 0;\n\n\t \n\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t       profile_mode);\n\tif (workload_type < 0) {\n\t\tdev_dbg(smu->adev->dev, \"Unsupported power profile mode %d on VANGOGH\\n\",\n\t\t\t\t\tprofile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_ActiveProcessNotify,\n\t\t\t\t    1 << workload_type,\n\t\t\t\t    NULL);\n\tif (ret) {\n\t\tdev_err_once(smu->adev->dev, \"Fail to set workload type %d\\n\",\n\t\t\t\t\tworkload_type);\n\t\treturn ret;\n\t}\n\n\tsmu->power_profile_mode = profile_mode;\n\n\treturn 0;\n}\n\nstatic int vangogh_set_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t min,\n\t\t\t\t\t  uint32_t max)\n{\n\tint ret = 0;\n\n\tif (!vangogh_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\t\tmin, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\t\tmax, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\t\tmin, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\t\tmax, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetHardMinSocclkByFreq,\n\t\t\t\t\t\t\tmin, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxSocclkByFreq,\n\t\t\t\t\t\t\tmax, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetHardMinVcn,\n\t\t\t\t\t\t\tmin << 16, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\t\tmax << 16, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetHardMinVcn,\n\t\t\t\t\t\t\tmin, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\t\tmax, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_force_clk_levels(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type, uint32_t mask)\n{\n\tuint32_t soft_min_level = 0, soft_max_level = 0;\n\tuint32_t min_freq = 0, max_freq = 0;\n\tint ret = 0 ;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type,\n\t\t\t\t\t\tsoft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = vangogh_get_dpm_clk_limited(smu, clk_type,\n\t\t\t\t\t\tsoft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxSocclkByFreq,\n\t\t\t\t\t\t\t\tmax_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetHardMinSocclkByFreq,\n\t\t\t\t\t\t\t\tmin_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tret = vangogh_get_dpm_clk_limited(smu,\n\t\t\t\t\t\t\tclk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = vangogh_get_dpm_clk_limited(smu,\n\t\t\t\t\t\t\tclk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\t\t\tmax_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\t\t\tmin_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tret = vangogh_get_dpm_clk_limited(smu,\n\t\t\t\t\t\t\tclk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vangogh_get_dpm_clk_limited(smu,\n\t\t\t\t\t\t\tclk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetHardMinVcn,\n\t\t\t\t\t\t\t\tmin_freq << 16, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\t\t\tmax_freq << 16, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tret = vangogh_get_dpm_clk_limited(smu,\n\t\t\t\t\t\t\tclk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vangogh_get_dpm_clk_limited(smu,\n\t\t\t\t\t\t\tclk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetHardMinVcn,\n\t\t\t\t\t\t\tmin_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\t\tmax_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_force_dpm_limit_value(struct smu_context *smu, bool highest)\n{\n\tint ret = 0, i = 0;\n\tuint32_t min_freq, max_freq, force_freq;\n\tenum smu_clk_type clk_type;\n\n\tenum smu_clk_type clks[] = {\n\t\tSMU_SOCCLK,\n\t\tSMU_VCLK,\n\t\tSMU_DCLK,\n\t\tSMU_FCLK,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(clks); i++) {\n\t\tclk_type = clks[i];\n\t\tret = vangogh_get_dpm_ultimate_freq(smu, clk_type, &min_freq, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tforce_freq = highest ? max_freq : min_freq;\n\t\tret = vangogh_set_soft_freq_limited_range(smu, clk_type, force_freq, force_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_unforce_dpm_levels(struct smu_context *smu)\n{\n\tint ret = 0, i = 0;\n\tuint32_t min_freq, max_freq;\n\tenum smu_clk_type clk_type;\n\n\tstruct clk_feature_map {\n\t\tenum smu_clk_type clk_type;\n\t\tuint32_t\tfeature;\n\t} clk_feature_map[] = {\n\t\t{SMU_FCLK, SMU_FEATURE_DPM_FCLK_BIT},\n\t\t{SMU_SOCCLK, SMU_FEATURE_DPM_SOCCLK_BIT},\n\t\t{SMU_VCLK, SMU_FEATURE_VCN_DPM_BIT},\n\t\t{SMU_DCLK, SMU_FEATURE_VCN_DPM_BIT},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_feature_map); i++) {\n\n\t\tif (!smu_cmn_feature_is_enabled(smu, clk_feature_map[i].feature))\n\t\t    continue;\n\n\t\tclk_type = clk_feature_map[i].clk_type;\n\n\t\tret = vangogh_get_dpm_ultimate_freq(smu, clk_type, &min_freq, &max_freq);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = vangogh_set_soft_freq_limited_range(smu, clk_type, min_freq, max_freq);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_set_peak_clock_by_device(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint32_t socclk_freq = 0, fclk_freq = 0;\n\tuint32_t vclk_freq = 0, dclk_freq = 0;\n\n\tret = vangogh_get_dpm_ultimate_freq(smu, SMU_FCLK, NULL, &fclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_set_soft_freq_limited_range(smu, SMU_FCLK, fclk_freq, fclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_get_dpm_ultimate_freq(smu, SMU_SOCCLK, NULL, &socclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_set_soft_freq_limited_range(smu, SMU_SOCCLK, socclk_freq, socclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_get_dpm_ultimate_freq(smu, SMU_VCLK, NULL, &vclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_set_soft_freq_limited_range(smu, SMU_VCLK, vclk_freq, vclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_get_dpm_ultimate_freq(smu, SMU_DCLK, NULL, &dclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vangogh_set_soft_freq_limited_range(smu, SMU_DCLK, dclk_freq, dclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int vangogh_set_performance_level(struct smu_context *smu,\n\t\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tint ret = 0, i;\n\tuint32_t soc_mask, mclk_mask, fclk_mask;\n\tuint32_t vclk_mask = 0, dclk_mask = 0;\n\n\tsmu->cpu_actual_soft_min_freq = smu->cpu_default_soft_min_freq;\n\tsmu->cpu_actual_soft_max_freq = smu->cpu_default_soft_max_freq;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_soft_max_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\n\t\tret = vangogh_force_dpm_limit_value(smu, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_hard_min_freq;\n\n\t\tret = vangogh_force_dpm_limit_value(smu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = vangogh_unforce_dpm_levels(smu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\t\tsmu->gfx_actual_hard_min_freq = VANGOGH_UMD_PSTATE_STANDARD_GFXCLK;\n\t\tsmu->gfx_actual_soft_max_freq = VANGOGH_UMD_PSTATE_STANDARD_GFXCLK;\n\n\t\tret = vangogh_get_profiling_clk_mask(smu, level,\n\t\t\t\t\t\t\t&vclk_mask,\n\t\t\t\t\t\t\t&dclk_mask,\n\t\t\t\t\t\t\t&mclk_mask,\n\t\t\t\t\t\t\t&fclk_mask,\n\t\t\t\t\t\t\t&soc_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvangogh_force_clk_levels(smu, SMU_FCLK, 1 << fclk_mask);\n\t\tvangogh_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask);\n\t\tvangogh_force_clk_levels(smu, SMU_VCLK, 1 << vclk_mask);\n\t\tvangogh_force_clk_levels(smu, SMU_DCLK, 1 << dclk_mask);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_hard_min_freq;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = vangogh_get_profiling_clk_mask(smu, level,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t&mclk_mask,\n\t\t\t\t\t\t\t&fclk_mask,\n\t\t\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvangogh_force_clk_levels(smu, SMU_FCLK, 1 << fclk_mask);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tsmu->gfx_actual_hard_min_freq = VANGOGH_UMD_PSTATE_PEAK_GFXCLK;\n\t\tsmu->gfx_actual_soft_max_freq = VANGOGH_UMD_PSTATE_PEAK_GFXCLK;\n\n\t\tret = vangogh_set_peak_clock_by_device(smu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t      smu->gfx_actual_hard_min_freq, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t      smu->gfx_actual_soft_max_freq, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (smu->adev->pm.fw_version >= 0x43f1b00) {\n\t\tfor (i = 0; i < smu->cpu_core_num; i++) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinCclk,\n\t\t\t\t\t\t\t      ((i << 20)\n\t\t\t\t\t\t\t       | smu->cpu_actual_soft_min_freq),\n\t\t\t\t\t\t\t      NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxCclk,\n\t\t\t\t\t\t\t      ((i << 20)\n\t\t\t\t\t\t\t       | smu->cpu_actual_soft_max_freq),\n\t\t\t\t\t\t\t      NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_read_sensor(struct smu_context *smu,\n\t\t\t\t enum amd_pp_sensors sensor,\n\t\t\t\t void *data, uint32_t *size)\n{\n\tint ret = 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_SOCKETPOWER,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_UCLK,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_GFXCLK,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_VOLTAGE_VDDGFX,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDNB:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_VOLTAGE_VDDSOC,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_CPU_CLK:\n\t\tret = vangogh_common_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_AVERAGE_CPUCLK,\n\t\t\t\t\t\t   (uint32_t *)data);\n\t\t*size = smu->cpu_core_num * sizeof(uint16_t);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_get_apu_thermal_limit(struct smu_context *smu, uint32_t *limit)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_GetThermalLimit,\n\t\t\t\t\t      0, limit);\n}\n\nstatic int vangogh_set_apu_thermal_limit(struct smu_context *smu, uint32_t limit)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t      SMU_MSG_SetReducedThermalLimit,\n\t\t\t\t\t      limit, NULL);\n}\n\n\nstatic int vangogh_set_watermarks_table(struct smu_context *smu,\n\t\t\t\t       struct pp_smu_wm_range_sets *clock_ranges)\n{\n\tint i;\n\tint ret = 0;\n\tWatermarks_t *table = smu->smu_table.watermarks_table;\n\n\tif (!table || !clock_ranges)\n\t\treturn -EINVAL;\n\n\tif (clock_ranges) {\n\t\tif (clock_ranges->num_reader_wm_sets > NUM_WM_RANGES ||\n\t\t\tclock_ranges->num_writer_wm_sets > NUM_WM_RANGES)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < clock_ranges->num_reader_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MinClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MinMclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxMclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_fill_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].WmSetting =\n\t\t\t\tclock_ranges->reader_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tfor (i = 0; i < clock_ranges->num_writer_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinMclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxMclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_drain_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmSetting =\n\t\t\t\tclock_ranges->writer_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tsmu->watermarks_bitmap |= WATERMARKS_EXIST;\n\t}\n\n\t \n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t     !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {\n\t\tret = smu_cmn_write_watermarks_table(smu);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to update WMTABLE!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsmu->watermarks_bitmap |= WATERMARKS_LOADED;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t vangogh_get_legacy_gpu_metrics_v2_3(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_legacy_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 3);\n\n\tgpu_metrics->temperature_gfx = metrics.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->temperature_l3[0] = metrics.L3Temperature[0];\n\n\tgpu_metrics->average_gfx_activity = metrics.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.CurrentSocketPower;\n\tgpu_metrics->average_cpu_power = metrics.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Power[1];\n\tgpu_metrics->average_gfx_power = metrics.Power[2];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t) * 4);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->current_l3clk[0] = metrics.L3Frequency[0];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   vangogh_throttler_map);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_3);\n}\n\nstatic ssize_t vangogh_get_legacy_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_2 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_2 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_legacy_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 2);\n\n\tgpu_metrics->temperature_gfx = metrics.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->temperature_l3[0] = metrics.L3Temperature[0];\n\n\tgpu_metrics->average_gfx_activity = metrics.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.CurrentSocketPower;\n\tgpu_metrics->average_cpu_power = metrics.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Power[1];\n\tgpu_metrics->average_gfx_power = metrics.Power[2];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t) * 4);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->current_l3clk[0] = metrics.L3Frequency[0];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t\t   vangogh_throttler_map);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_2);\n}\n\nstatic ssize_t vangogh_get_gpu_metrics_v2_3(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_3 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 3);\n\n\tgpu_metrics->temperature_gfx = metrics.Current.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.Current.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->temperature_l3[0] = metrics.Current.L3Temperature[0];\n\n\tgpu_metrics->average_temperature_gfx = metrics.Average.GfxTemperature;\n\tgpu_metrics->average_temperature_soc = metrics.Average.SocTemperature;\n\tmemcpy(&gpu_metrics->average_temperature_core[0],\n\t\t&metrics.Average.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->average_temperature_l3[0] = metrics.Average.L3Temperature[0];\n\n\tgpu_metrics->average_gfx_activity = metrics.Current.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.Current.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.Current.CurrentSocketPower;\n\tgpu_metrics->average_cpu_power = metrics.Current.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Current.Power[1];\n\tgpu_metrics->average_gfx_power = metrics.Current.Power[2];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t) * 4);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.Average.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.Average.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.Average.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.Average.DclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.Current.GfxclkFrequency;\n\tgpu_metrics->current_socclk = metrics.Current.SocclkFrequency;\n\tgpu_metrics->current_uclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_fclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_vclk = metrics.Current.VclkFrequency;\n\tgpu_metrics->current_dclk = metrics.Current.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->current_l3clk[0] = metrics.Current.L3Frequency[0];\n\n\tgpu_metrics->throttle_status = metrics.Current.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.Current.ThrottlerStatus,\n\t\t\t\t\t\t\t   vangogh_throttler_map);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_3);\n}\n\nstatic ssize_t vangogh_get_gpu_metrics_v2_4(struct smu_context *smu,\n\t\t\t\t\t    void **table)\n{\n\tSmuMetrics_t metrics;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_4 *gpu_metrics =\n\t\t\t\t(struct gpu_metrics_v2_4 *)smu_table->gpu_metrics_table;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 4);\n\n\tgpu_metrics->temperature_gfx = metrics.Current.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.Current.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t       &metrics.Current.CoreTemperature[0],\n\t       sizeof(uint16_t) * 4);\n\tgpu_metrics->temperature_l3[0] = metrics.Current.L3Temperature[0];\n\n\tgpu_metrics->average_temperature_gfx = metrics.Average.GfxTemperature;\n\tgpu_metrics->average_temperature_soc = metrics.Average.SocTemperature;\n\tmemcpy(&gpu_metrics->average_temperature_core[0],\n\t       &metrics.Average.CoreTemperature[0],\n\t       sizeof(uint16_t) * 4);\n\tgpu_metrics->average_temperature_l3[0] = metrics.Average.L3Temperature[0];\n\n\tgpu_metrics->average_gfx_activity = metrics.Current.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.Current.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.Current.CurrentSocketPower;\n\tgpu_metrics->average_cpu_power = metrics.Current.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Current.Power[1];\n\tgpu_metrics->average_gfx_power = metrics.Current.Power[2];\n\n\tgpu_metrics->average_cpu_voltage = metrics.Current.Voltage[0];\n\tgpu_metrics->average_soc_voltage = metrics.Current.Voltage[1];\n\tgpu_metrics->average_gfx_voltage = metrics.Current.Voltage[2];\n\n\tgpu_metrics->average_cpu_current = metrics.Current.Current[0];\n\tgpu_metrics->average_soc_current = metrics.Current.Current[1];\n\tgpu_metrics->average_gfx_current = metrics.Current.Current[2];\n\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t       &metrics.Average.CorePower[0],\n\t       sizeof(uint16_t) * 4);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.Average.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.Average.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.Average.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.Average.DclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.Current.GfxclkFrequency;\n\tgpu_metrics->current_socclk = metrics.Current.SocclkFrequency;\n\tgpu_metrics->current_uclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_fclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_vclk = metrics.Current.VclkFrequency;\n\tgpu_metrics->current_dclk = metrics.Current.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t       &metrics.Current.CoreFrequency[0],\n\t       sizeof(uint16_t) * 4);\n\tgpu_metrics->current_l3clk[0] = metrics.Current.L3Frequency[0];\n\n\tgpu_metrics->throttle_status = metrics.Current.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.Current.ThrottlerStatus,\n\t\t\t\t\t\t\t   vangogh_throttler_map);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_4);\n}\n\nstatic ssize_t vangogh_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_2 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_2 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 2);\n\n\tgpu_metrics->temperature_gfx = metrics.Current.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.Current.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.Current.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->temperature_l3[0] = metrics.Current.L3Temperature[0];\n\n\tgpu_metrics->average_gfx_activity = metrics.Current.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.Current.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.Current.CurrentSocketPower;\n\tgpu_metrics->average_cpu_power = metrics.Current.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Current.Power[1];\n\tgpu_metrics->average_gfx_power = metrics.Current.Power[2];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.Average.CorePower[0],\n\t\tsizeof(uint16_t) * 4);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.Average.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.Average.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.Average.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.Average.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.Average.DclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.Current.GfxclkFrequency;\n\tgpu_metrics->current_socclk = metrics.Current.SocclkFrequency;\n\tgpu_metrics->current_uclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_fclk = metrics.Current.MemclkFrequency;\n\tgpu_metrics->current_vclk = metrics.Current.VclkFrequency;\n\tgpu_metrics->current_dclk = metrics.Current.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.Current.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 4);\n\tgpu_metrics->current_l3clk[0] = metrics.Current.L3Frequency[0];\n\n\tgpu_metrics->throttle_status = metrics.Current.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(metrics.Current.ThrottlerStatus,\n\t\t\t\t\t\t\t   vangogh_throttler_map);\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_2);\n}\n\nstatic ssize_t vangogh_common_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tuint32_t if_version;\n\tuint32_t smu_version;\n\tuint32_t smu_program;\n\tuint32_t fw_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_program = (smu_version >> 24) & 0xff;\n\tfw_version = smu_version & 0xffffff;\n\tif (smu_program == 6) {\n\t\tif (fw_version >= 0x3F0800)\n\t\t\tret = vangogh_get_gpu_metrics_v2_4(smu, table);\n\t\telse\n\t\t\tret = vangogh_get_gpu_metrics_v2_3(smu, table);\n\n\t} else {\n\t\tif (smu_version >= 0x043F3E00) {\n\t\t\tif (if_version < 0x3)\n\t\t\t\tret = vangogh_get_legacy_gpu_metrics_v2_3(smu, table);\n\t\t\telse\n\t\t\t\tret = vangogh_get_gpu_metrics_v2_3(smu, table);\n\t\t} else {\n\t\t\tif (if_version < 0x3)\n\t\t\t\tret = vangogh_get_legacy_gpu_metrics(smu, table);\n\t\t\telse\n\t\t\t\tret = vangogh_get_gpu_metrics(smu, table);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tlong input[], uint32_t size)\n{\n\tint ret = 0;\n\tstruct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);\n\n\tif (!(smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)) {\n\t\tdev_warn(smu->adev->dev,\n\t\t\t\"pp_od_clk_voltage is not accessible if power_dpm_force_performance_level is not in manual mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_CCLK_VDDC_TABLE:\n\t\tif (size != 3) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct (should be 4 for processor)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (input[0] >= smu->cpu_core_num) {\n\t\t\tdev_err(smu->adev->dev, \"core index is overflow, should be less than %d\\n\",\n\t\t\t\tsmu->cpu_core_num);\n\t\t}\n\t\tsmu->cpu_core_id_select = input[0];\n\t\tif (input[1] == 0) {\n\t\t\tif (input[2] < smu->cpu_default_soft_min_freq) {\n\t\t\t\tdev_warn(smu->adev->dev, \"Fine grain setting minimum cclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[2], smu->cpu_default_soft_min_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->cpu_actual_soft_min_freq = input[2];\n\t\t} else if (input[1] == 1) {\n\t\t\tif (input[2] > smu->cpu_default_soft_max_freq) {\n\t\t\t\tdev_warn(smu->adev->dev, \"Fine grain setting maximum cclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[2], smu->cpu_default_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->cpu_actual_soft_max_freq = input[2];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (size != 2) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[0] == 0) {\n\t\t\tif (input[1] < smu->gfx_default_hard_min_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t\"Fine grain setting minimum sclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], smu->gfx_default_hard_min_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_hard_min_freq = input[1];\n\t\t} else if (input[0] == 1) {\n\t\t\tif (input[1] > smu->gfx_default_soft_max_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t\"Fine grain setting maximum sclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], smu->gfx_default_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_soft_max_freq = input[1];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\t\t\tsmu->cpu_actual_soft_min_freq = smu->cpu_default_soft_min_freq;\n\t\t\tsmu->cpu_actual_soft_max_freq = smu->cpu_default_soft_max_freq;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (smu->gfx_actual_hard_min_freq > smu->gfx_actual_soft_max_freq) {\n\t\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\t\"The setting minimum sclk (%d) MHz is greater than the setting maximum sclk (%d) MHz\\n\",\n\t\t\t\t\tsmu->gfx_actual_hard_min_freq,\n\t\t\t\t\tsmu->gfx_actual_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\t\t\t\tsmu->gfx_actual_hard_min_freq, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set hard min sclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\t\t\t\tsmu->gfx_actual_soft_max_freq, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set soft max sclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (smu->adev->pm.fw_version < 0x43f1b00) {\n\t\t\t\tdev_warn(smu->adev->dev, \"CPUSoftMax/CPUSoftMin are not supported, please update SBIOS!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinCclk,\n\t\t\t\t\t\t\t      ((smu->cpu_core_id_select << 20)\n\t\t\t\t\t\t\t       | smu->cpu_actual_soft_min_freq),\n\t\t\t\t\t\t\t      NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set hard min cclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxCclk,\n\t\t\t\t\t\t\t      ((smu->cpu_core_id_select << 20)\n\t\t\t\t\t\t\t       | smu->cpu_actual_soft_max_freq),\n\t\t\t\t\t\t\t      NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set soft max cclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int vangogh_set_default_dpm_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\treturn smu_cmn_update_table(smu, SMU_TABLE_DPMCLOCKS, 0, smu_table->clocks_table, false);\n}\n\nstatic int vangogh_set_fine_grain_gfx_freq_parameters(struct smu_context *smu)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tsmu->gfx_default_hard_min_freq = clk_table->MinGfxClk;\n\tsmu->gfx_default_soft_max_freq = clk_table->MaxGfxClk;\n\tsmu->gfx_actual_hard_min_freq = 0;\n\tsmu->gfx_actual_soft_max_freq = 0;\n\n\tsmu->cpu_default_soft_min_freq = 1400;\n\tsmu->cpu_default_soft_max_freq = 3500;\n\tsmu->cpu_actual_soft_min_freq = 0;\n\tsmu->cpu_actual_soft_max_freq = 0;\n\n\treturn 0;\n}\n\nstatic int vangogh_get_dpm_clock_table(struct smu_context *smu, struct dpm_clocks *clock_table)\n{\n\tDpmClocks_t *table = smu->smu_table.clocks_table;\n\tint i;\n\n\tif (!clock_table || !table)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NUM_SOCCLK_DPM_LEVELS; i++) {\n\t\tclock_table->SocClocks[i].Freq = table->SocClocks[i];\n\t\tclock_table->SocClocks[i].Vol = table->SocVoltage[i];\n\t}\n\n\tfor (i = 0; i < NUM_FCLK_DPM_LEVELS; i++) {\n\t\tclock_table->FClocks[i].Freq = table->DfPstateTable[i].fclk;\n\t\tclock_table->FClocks[i].Vol = table->DfPstateTable[i].voltage;\n\t}\n\n\tfor (i = 0; i < NUM_FCLK_DPM_LEVELS; i++) {\n\t\tclock_table->MemClocks[i].Freq = table->DfPstateTable[i].memclk;\n\t\tclock_table->MemClocks[i].Vol = table->DfPstateTable[i].voltage;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int vangogh_system_features_control(struct smu_context *smu, bool en)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (adev->pm.fw_version >= 0x43f1700 && !en)\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_RlcPowerNotify,\n\t\t\t\t\t\t      RLC_STATUS_OFF, NULL);\n\n\treturn ret;\n}\n\nstatic int vangogh_post_smu_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t tmp;\n\tint ret = 0;\n\tuint8_t aon_bits = 0;\n\t \n\tuint32_t req_active_wgps = adev->gfx.cu_info.number/2;\n\tuint32_t total_cu = adev->gfx.config.max_cu_per_sh *\n\t\tadev->gfx.config.max_sh_per_se * adev->gfx.config.max_shader_engines;\n\n\t \n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT) &&\n\t\t\t(adev->pg_flags & AMD_PG_SUPPORT_GFX_PG)) {\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_EnableGfxOff, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to Enable GfxOff!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tadev->pm.pp_feature &= ~PP_GFXOFF_MASK;\n\t\tdev_info(adev->dev, \"If GFX DPM or power gate disabled, disable GFXOFF\\n\");\n\t}\n\n\t \n\tif (total_cu == adev->gfx.cu_info.number)\n\t\treturn 0;\n\n\t \n\ttmp = RREG32_KIQ(SOC15_REG_OFFSET(GC, 0, mmRLC_PG_ALWAYS_ON_WGP_MASK));\n\ttmp &= RLC_PG_ALWAYS_ON_WGP_MASK__AON_WGP_MASK_MASK;\n\n\taon_bits = hweight32(tmp) * adev->gfx.config.max_sh_per_se * adev->gfx.config.max_shader_engines;\n\n\t \n\tif (aon_bits > req_active_wgps) {\n\t\tdev_info(adev->dev, \"Number of always on WGPs greater than active WGPs: WGP power save not requested.\\n\");\n\t\treturn 0;\n\t} else {\n\t\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_RequestActiveWgp, req_active_wgps, NULL);\n\t}\n}\n\nstatic int vangogh_mode_reset(struct smu_context *smu, int type)\n{\n\tint ret = 0, index = 0;\n\n\tindex = smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG,\n\t\t\t\t\t       SMU_MSG_GfxDeviceDriverReset);\n\tif (index < 0)\n\t\treturn index == -EACCES ? 0 : index;\n\n\tmutex_lock(&smu->message_lock);\n\n\tret = smu_cmn_send_msg_without_waiting(smu, (uint16_t)index, type);\n\n\tmutex_unlock(&smu->message_lock);\n\n\tmdelay(10);\n\n\treturn ret;\n}\n\nstatic int vangogh_mode2_reset(struct smu_context *smu)\n{\n\treturn vangogh_mode_reset(smu, SMU_RESET_MODE_2);\n}\n\n \nstatic u32 vangogh_get_gfxoff_status(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tu32 reg, gfxoff_status;\n\n\treg = RREG32_SOC15(SMUIO, 0, mmSMUIO_GFX_MISC_CNTL);\n\tgfxoff_status = (reg & SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS_MASK)\n\t\t>> SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS__SHIFT;\n\n\treturn gfxoff_status;\n}\n\nstatic int vangogh_get_power_limit(struct smu_context *smu,\n\t\t\t\t   uint32_t *current_power_limit,\n\t\t\t\t   uint32_t *default_power_limit,\n\t\t\t\t   uint32_t *max_power_limit)\n{\n\tstruct smu_11_5_power_context *power_context =\n\t\t\t\t\t\t\t\tsmu->smu_power.power_context;\n\tuint32_t ppt_limit;\n\tint ret = 0;\n\n\tif (smu->adev->pm.fw_version < 0x43f1e00)\n\t\treturn ret;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetSlowPPTLimit, &ppt_limit);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Get slow PPT limit failed!\\n\");\n\t\treturn ret;\n\t}\n\t \n\tif (current_power_limit)\n\t\t*current_power_limit = ppt_limit / 1000;\n\tif (default_power_limit)\n\t\t*default_power_limit = ppt_limit / 1000;\n\tif (max_power_limit)\n\t\t*max_power_limit = 29;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetFastPPTLimit, &ppt_limit);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Get fast PPT limit failed!\\n\");\n\t\treturn ret;\n\t}\n\t \n\tpower_context->current_fast_ppt_limit =\n\t\t\tpower_context->default_fast_ppt_limit = ppt_limit / 1000;\n\tpower_context->max_fast_ppt_limit = 30;\n\n\treturn ret;\n}\n\nstatic int vangogh_get_ppt_limit(struct smu_context *smu,\n\t\t\t\t\t\t\t\tuint32_t *ppt_limit,\n\t\t\t\t\t\t\t\tenum smu_ppt_limit_type type,\n\t\t\t\t\t\t\t\tenum smu_ppt_limit_level level)\n{\n\tstruct smu_11_5_power_context *power_context =\n\t\t\t\t\t\t\tsmu->smu_power.power_context;\n\n\tif (!power_context)\n\t\treturn -EOPNOTSUPP;\n\n\tif (type == SMU_FAST_PPT_LIMIT) {\n\t\tswitch (level) {\n\t\tcase SMU_PPT_LIMIT_MAX:\n\t\t\t*ppt_limit = power_context->max_fast_ppt_limit;\n\t\t\tbreak;\n\t\tcase SMU_PPT_LIMIT_CURRENT:\n\t\t\t*ppt_limit = power_context->current_fast_ppt_limit;\n\t\t\tbreak;\n\t\tcase SMU_PPT_LIMIT_DEFAULT:\n\t\t\t*ppt_limit = power_context->default_fast_ppt_limit;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vangogh_set_power_limit(struct smu_context *smu,\n\t\t\t\t   enum smu_ppt_limit_type limit_type,\n\t\t\t\t   uint32_t ppt_limit)\n{\n\tstruct smu_11_5_power_context *power_context =\n\t\t\tsmu->smu_power.power_context;\n\tint ret = 0;\n\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_PPT_BIT)) {\n\t\tdev_err(smu->adev->dev, \"Setting new power limit is not supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (limit_type) {\n\tcase SMU_DEFAULT_PPT_LIMIT:\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetSlowPPTLimit,\n\t\t\t\tppt_limit * 1000,  \n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsmu->current_power_limit = ppt_limit;\n\t\tbreak;\n\tcase SMU_FAST_PPT_LIMIT:\n\t\tppt_limit &= ~(SMU_FAST_PPT_LIMIT << 24);\n\t\tif (ppt_limit > power_context->max_fast_ppt_limit) {\n\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\"New power limit (%d) is over the max allowed %d\\n\",\n\t\t\t\tppt_limit, power_context->max_fast_ppt_limit);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetFastPPTLimit,\n\t\t\t\tppt_limit * 1000,  \n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpower_context->current_fast_ppt_limit = ppt_limit;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic u32 vangogh_set_gfxoff_residency(struct smu_context *smu, bool start)\n{\n\tint ret = 0;\n\tu32 residency;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (!(adev->pm.pp_feature & PP_GFXOFF_MASK))\n\t\treturn 0;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_LogGfxOffResidency,\n\t\t\t\t\t      start, &residency);\n\n\tif (!start)\n\t\tadev->gfx.gfx_off_residency = residency;\n\n\treturn ret;\n}\n\n \nstatic u32 vangogh_get_gfxoff_residency(struct smu_context *smu, uint32_t *residency)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\t*residency = adev->gfx.gfx_off_residency;\n\n\treturn 0;\n}\n\n \nstatic u32 vangogh_get_gfxoff_entrycount(struct smu_context *smu, uint64_t *entrycount)\n{\n\tint ret = 0, value = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (!(adev->pm.pp_feature & PP_GFXOFF_MASK))\n\t\treturn 0;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetGfxOffEntryCount, &value);\n\t*entrycount = value + adev->gfx.gfx_off_entrycount;\n\n\treturn ret;\n}\n\nstatic const struct pptable_funcs vangogh_ppt_funcs = {\n\n\t.check_fw_status = smu_v11_0_check_fw_status,\n\t.check_fw_version = smu_v11_0_check_fw_version,\n\t.init_smc_tables = vangogh_init_smc_tables,\n\t.fini_smc_tables = smu_v11_0_fini_smc_tables,\n\t.init_power = smu_v11_0_init_power,\n\t.fini_power = smu_v11_0_fini_power,\n\t.register_irq_handler = smu_v11_0_register_irq_handler,\n\t.notify_memory_pool_location = smu_v11_0_notify_memory_pool_location,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.dpm_set_vcn_enable = vangogh_dpm_set_vcn_enable,\n\t.dpm_set_jpeg_enable = vangogh_dpm_set_jpeg_enable,\n\t.is_dpm_running = vangogh_is_dpm_running,\n\t.read_sensor = vangogh_read_sensor,\n\t.get_apu_thermal_limit = vangogh_get_apu_thermal_limit,\n\t.set_apu_thermal_limit = vangogh_set_apu_thermal_limit,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_watermarks_table = vangogh_set_watermarks_table,\n\t.set_driver_table_location = smu_v11_0_set_driver_table_location,\n\t.interrupt_work = smu_v11_0_interrupt_work,\n\t.get_gpu_metrics = vangogh_common_get_gpu_metrics,\n\t.od_edit_dpm_table = vangogh_od_edit_dpm_table,\n\t.print_clk_levels = vangogh_common_print_clk_levels,\n\t.set_default_dpm_table = vangogh_set_default_dpm_tables,\n\t.set_fine_grain_gfx_freq_parameters = vangogh_set_fine_grain_gfx_freq_parameters,\n\t.system_features_control = vangogh_system_features_control,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.set_power_profile_mode = vangogh_set_power_profile_mode,\n\t.get_power_profile_mode = vangogh_get_power_profile_mode,\n\t.get_dpm_clock_table = vangogh_get_dpm_clock_table,\n\t.force_clk_levels = vangogh_force_clk_levels,\n\t.set_performance_level = vangogh_set_performance_level,\n\t.post_init = vangogh_post_smu_init,\n\t.mode2_reset = vangogh_mode2_reset,\n\t.gfx_off_control = smu_v11_0_gfx_off_control,\n\t.get_gfx_off_status = vangogh_get_gfxoff_status,\n\t.get_gfx_off_entrycount = vangogh_get_gfxoff_entrycount,\n\t.get_gfx_off_residency = vangogh_get_gfxoff_residency,\n\t.set_gfx_off_residency = vangogh_set_gfxoff_residency,\n\t.get_ppt_limit = vangogh_get_ppt_limit,\n\t.get_power_limit = vangogh_get_power_limit,\n\t.set_power_limit = vangogh_set_power_limit,\n\t.get_vbios_bootup_values = smu_v11_0_get_vbios_bootup_values,\n};\n\nvoid vangogh_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &vangogh_ppt_funcs;\n\tsmu->message_map = vangogh_message_map;\n\tsmu->feature_map = vangogh_feature_mask_map;\n\tsmu->table_map = vangogh_table_map;\n\tsmu->workload_map = vangogh_workload_map;\n\tsmu->is_apu = true;\n\tsmu_v11_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}