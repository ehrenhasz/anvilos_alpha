{
  "module_name": "amdgpu_smu.h",
  "hash_id": "b820b50e1e98548d210bdf125429040d35451b278468860c2414536ba1941bcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/inc/amdgpu_smu.h",
  "human_readable_source": " \n#ifndef __AMDGPU_SMU_H__\n#define __AMDGPU_SMU_H__\n\n#include \"amdgpu.h\"\n#include \"kgd_pp_interface.h\"\n#include \"dm_pp_interface.h\"\n#include \"dm_pp_smu.h\"\n#include \"smu_types.h\"\n#include \"linux/firmware.h\"\n\n#define SMU_THERMAL_MINIMUM_ALERT_TEMP\t\t0\n#define SMU_THERMAL_MAXIMUM_ALERT_TEMP\t\t255\n#define SMU_TEMPERATURE_UNITS_PER_CENTIGRADES\t1000\n#define SMU_FW_NAME_LEN\t\t\t0x24\n\n#define SMU_DPM_USER_PROFILE_RESTORE (1 << 0)\n#define SMU_CUSTOM_FAN_SPEED_RPM     (1 << 1)\n#define SMU_CUSTOM_FAN_SPEED_PWM     (1 << 2)\n\n\n#define SMU_THROTTLER_PPT0_BIT\t\t\t0\n#define SMU_THROTTLER_PPT1_BIT\t\t\t1\n#define SMU_THROTTLER_PPT2_BIT\t\t\t2\n#define SMU_THROTTLER_PPT3_BIT\t\t\t3\n#define SMU_THROTTLER_SPL_BIT\t\t\t4\n#define SMU_THROTTLER_FPPT_BIT\t\t\t5\n#define SMU_THROTTLER_SPPT_BIT\t\t\t6\n#define SMU_THROTTLER_SPPT_APU_BIT\t\t7\n\n\n#define SMU_THROTTLER_TDC_GFX_BIT\t\t16\n#define SMU_THROTTLER_TDC_SOC_BIT\t\t17\n#define SMU_THROTTLER_TDC_MEM_BIT\t\t18\n#define SMU_THROTTLER_TDC_VDD_BIT\t\t19\n#define SMU_THROTTLER_TDC_CVIP_BIT\t\t20\n#define SMU_THROTTLER_EDC_CPU_BIT\t\t21\n#define SMU_THROTTLER_EDC_GFX_BIT\t\t22\n#define SMU_THROTTLER_APCC_BIT\t\t\t23\n\n\n#define SMU_THROTTLER_TEMP_GPU_BIT\t\t32\n#define SMU_THROTTLER_TEMP_CORE_BIT\t\t33\n#define SMU_THROTTLER_TEMP_MEM_BIT\t\t34\n#define SMU_THROTTLER_TEMP_EDGE_BIT\t\t35\n#define SMU_THROTTLER_TEMP_HOTSPOT_BIT\t\t36\n#define SMU_THROTTLER_TEMP_SOC_BIT\t\t37\n#define SMU_THROTTLER_TEMP_VR_GFX_BIT\t\t38\n#define SMU_THROTTLER_TEMP_VR_SOC_BIT\t\t39\n#define SMU_THROTTLER_TEMP_VR_MEM0_BIT\t\t40\n#define SMU_THROTTLER_TEMP_VR_MEM1_BIT\t\t41\n#define SMU_THROTTLER_TEMP_LIQUID0_BIT\t\t42\n#define SMU_THROTTLER_TEMP_LIQUID1_BIT\t\t43\n#define SMU_THROTTLER_VRHOT0_BIT\t\t44\n#define SMU_THROTTLER_VRHOT1_BIT\t\t45\n#define SMU_THROTTLER_PROCHOT_CPU_BIT\t\t46\n#define SMU_THROTTLER_PROCHOT_GFX_BIT\t\t47\n\n\n#define SMU_THROTTLER_PPM_BIT\t\t\t56\n#define SMU_THROTTLER_FIT_BIT\t\t\t57\n\nstruct smu_hw_power_state {\n\tunsigned int magic;\n};\n\nstruct smu_power_state;\n\nenum smu_state_ui_label {\n\tSMU_STATE_UI_LABEL_NONE,\n\tSMU_STATE_UI_LABEL_BATTERY,\n\tSMU_STATE_UI_TABEL_MIDDLE_LOW,\n\tSMU_STATE_UI_LABEL_BALLANCED,\n\tSMU_STATE_UI_LABEL_MIDDLE_HIGHT,\n\tSMU_STATE_UI_LABEL_PERFORMANCE,\n\tSMU_STATE_UI_LABEL_BACO,\n};\n\nenum smu_state_classification_flag {\n\tSMU_STATE_CLASSIFICATION_FLAG_BOOT                     = 0x0001,\n\tSMU_STATE_CLASSIFICATION_FLAG_THERMAL                  = 0x0002,\n\tSMU_STATE_CLASSIFICATIN_FLAG_LIMITED_POWER_SOURCE      = 0x0004,\n\tSMU_STATE_CLASSIFICATION_FLAG_RESET                    = 0x0008,\n\tSMU_STATE_CLASSIFICATION_FLAG_FORCED                   = 0x0010,\n\tSMU_STATE_CLASSIFICATION_FLAG_USER_3D_PERFORMANCE      = 0x0020,\n\tSMU_STATE_CLASSIFICATION_FLAG_USER_2D_PERFORMANCE      = 0x0040,\n\tSMU_STATE_CLASSIFICATION_FLAG_3D_PERFORMANCE           = 0x0080,\n\tSMU_STATE_CLASSIFICATION_FLAG_AC_OVERDIRVER_TEMPLATE   = 0x0100,\n\tSMU_STATE_CLASSIFICATION_FLAG_UVD                      = 0x0200,\n\tSMU_STATE_CLASSIFICATION_FLAG_3D_PERFORMANCE_LOW       = 0x0400,\n\tSMU_STATE_CLASSIFICATION_FLAG_ACPI                     = 0x0800,\n\tSMU_STATE_CLASSIFICATION_FLAG_HD2                      = 0x1000,\n\tSMU_STATE_CLASSIFICATION_FLAG_UVD_HD                   = 0x2000,\n\tSMU_STATE_CLASSIFICATION_FLAG_UVD_SD                   = 0x4000,\n\tSMU_STATE_CLASSIFICATION_FLAG_USER_DC_PERFORMANCE      = 0x8000,\n\tSMU_STATE_CLASSIFICATION_FLAG_DC_OVERDIRVER_TEMPLATE   = 0x10000,\n\tSMU_STATE_CLASSIFICATION_FLAG_BACO                     = 0x20000,\n\tSMU_STATE_CLASSIFICATIN_FLAG_LIMITED_POWER_SOURCE2      = 0x40000,\n\tSMU_STATE_CLASSIFICATION_FLAG_ULV                      = 0x80000,\n\tSMU_STATE_CLASSIFICATION_FLAG_UVD_MVC                  = 0x100000,\n};\n\nstruct smu_state_classification_block {\n\tenum smu_state_ui_label         ui_label;\n\tenum smu_state_classification_flag  flags;\n\tint                          bios_index;\n\tbool                      temporary_state;\n\tbool                      to_be_deleted;\n};\n\nstruct smu_state_pcie_block {\n\tunsigned int lanes;\n};\n\nenum smu_refreshrate_source {\n\tSMU_REFRESHRATE_SOURCE_EDID,\n\tSMU_REFRESHRATE_SOURCE_EXPLICIT\n};\n\nstruct smu_state_display_block {\n\tbool              disable_frame_modulation;\n\tbool              limit_refreshrate;\n\tenum smu_refreshrate_source refreshrate_source;\n\tint                  explicit_refreshrate;\n\tint                  edid_refreshrate_index;\n\tbool              enable_vari_bright;\n};\n\nstruct smu_state_memory_block {\n\tbool              dll_off;\n\tuint8_t                 m3arb;\n\tuint8_t                 unused[3];\n};\n\nstruct smu_state_software_algorithm_block {\n\tbool disable_load_balancing;\n\tbool enable_sleep_for_timestamps;\n};\n\nstruct smu_temperature_range {\n\tint min;\n\tint max;\n\tint edge_emergency_max;\n\tint hotspot_min;\n\tint hotspot_crit_max;\n\tint hotspot_emergency_max;\n\tint mem_min;\n\tint mem_crit_max;\n\tint mem_emergency_max;\n\tint software_shutdown_temp;\n\tint software_shutdown_temp_offset;\n};\n\nstruct smu_state_validation_block {\n\tbool single_display_only;\n\tbool disallow_on_dc;\n\tuint8_t supported_power_levels;\n};\n\nstruct smu_uvd_clocks {\n\tuint32_t vclk;\n\tuint32_t dclk;\n};\n\n \nstruct smu_power_state {\n\tuint32_t                                      id;\n\tstruct list_head                              ordered_list;\n\tstruct list_head                              all_states_list;\n\n\tstruct smu_state_classification_block         classification;\n\tstruct smu_state_validation_block             validation;\n\tstruct smu_state_pcie_block                   pcie;\n\tstruct smu_state_display_block                display;\n\tstruct smu_state_memory_block                 memory;\n\tstruct smu_state_software_algorithm_block     software;\n\tstruct smu_uvd_clocks                         uvd_clocks;\n\tstruct smu_hw_power_state                     hardware;\n};\n\nenum smu_power_src_type {\n\tSMU_POWER_SOURCE_AC,\n\tSMU_POWER_SOURCE_DC,\n\tSMU_POWER_SOURCE_COUNT,\n};\n\nenum smu_ppt_limit_type {\n\tSMU_DEFAULT_PPT_LIMIT = 0,\n\tSMU_FAST_PPT_LIMIT,\n};\n\nenum smu_ppt_limit_level {\n\tSMU_PPT_LIMIT_MIN = -1,\n\tSMU_PPT_LIMIT_CURRENT,\n\tSMU_PPT_LIMIT_DEFAULT,\n\tSMU_PPT_LIMIT_MAX,\n};\n\nenum smu_memory_pool_size {\n    SMU_MEMORY_POOL_SIZE_ZERO   = 0,\n    SMU_MEMORY_POOL_SIZE_256_MB = 0x10000000,\n    SMU_MEMORY_POOL_SIZE_512_MB = 0x20000000,\n    SMU_MEMORY_POOL_SIZE_1_GB   = 0x40000000,\n    SMU_MEMORY_POOL_SIZE_2_GB   = 0x80000000,\n};\n\nstruct smu_user_dpm_profile {\n\tuint32_t fan_mode;\n\tuint32_t power_limit;\n\tuint32_t fan_speed_pwm;\n\tuint32_t fan_speed_rpm;\n\tuint32_t flags;\n\tuint32_t user_od;\n\n\t \n\tuint32_t clk_mask[SMU_CLK_COUNT];\n\tuint32_t clk_dependency;\n};\n\n#define SMU_TABLE_INIT(tables, table_id, s, a, d)\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ttables[table_id].size = s;\t\t\\\n\t\ttables[table_id].align = a;\t\t\\\n\t\ttables[table_id].domain = d;\t\t\\\n\t} while (0)\n\nstruct smu_table {\n\tuint64_t size;\n\tuint32_t align;\n\tuint8_t domain;\n\tuint64_t mc_address;\n\tvoid *cpu_addr;\n\tstruct amdgpu_bo *bo;\n};\n\nenum smu_perf_level_designation {\n\tPERF_LEVEL_ACTIVITY,\n\tPERF_LEVEL_POWER_CONTAINMENT,\n};\n\nstruct smu_performance_level {\n\tuint32_t core_clock;\n\tuint32_t memory_clock;\n\tuint32_t vddc;\n\tuint32_t vddci;\n\tuint32_t non_local_mem_freq;\n\tuint32_t non_local_mem_width;\n};\n\nstruct smu_clock_info {\n\tuint32_t min_mem_clk;\n\tuint32_t max_mem_clk;\n\tuint32_t min_eng_clk;\n\tuint32_t max_eng_clk;\n\tuint32_t min_bus_bandwidth;\n\tuint32_t max_bus_bandwidth;\n};\n\nstruct smu_bios_boot_up_values {\n\tuint32_t\t\t\trevision;\n\tuint32_t\t\t\tgfxclk;\n\tuint32_t\t\t\tuclk;\n\tuint32_t\t\t\tsocclk;\n\tuint32_t\t\t\tdcefclk;\n\tuint32_t\t\t\teclk;\n\tuint32_t\t\t\tvclk;\n\tuint32_t\t\t\tdclk;\n\tuint16_t\t\t\tvddc;\n\tuint16_t\t\t\tvddci;\n\tuint16_t\t\t\tmvddc;\n\tuint16_t\t\t\tvdd_gfx;\n\tuint8_t\t\t\t\tcooling_id;\n\tuint32_t\t\t\tpp_table_id;\n\tuint32_t\t\t\tformat_revision;\n\tuint32_t\t\t\tcontent_revision;\n\tuint32_t\t\t\tfclk;\n\tuint32_t\t\t\tlclk;\n\tuint32_t\t\t\tfirmware_caps;\n};\n\nenum smu_table_id {\n\tSMU_TABLE_PPTABLE = 0,\n\tSMU_TABLE_WATERMARKS,\n\tSMU_TABLE_CUSTOM_DPM,\n\tSMU_TABLE_DPMCLOCKS,\n\tSMU_TABLE_AVFS,\n\tSMU_TABLE_AVFS_PSM_DEBUG,\n\tSMU_TABLE_AVFS_FUSE_OVERRIDE,\n\tSMU_TABLE_PMSTATUSLOG,\n\tSMU_TABLE_SMU_METRICS,\n\tSMU_TABLE_DRIVER_SMU_CONFIG,\n\tSMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\tSMU_TABLE_OVERDRIVE,\n\tSMU_TABLE_I2C_COMMANDS,\n\tSMU_TABLE_PACE,\n\tSMU_TABLE_ECCINFO,\n\tSMU_TABLE_COMBO_PPTABLE,\n\tSMU_TABLE_COUNT,\n};\n\nstruct smu_table_context {\n\tvoid\t\t\t\t*power_play_table;\n\tuint32_t\t\t\tpower_play_table_size;\n\tvoid\t\t\t\t*hardcode_pptable;\n\tunsigned long\t\t\tmetrics_time;\n\tvoid\t\t\t\t*metrics_table;\n\tvoid\t\t\t\t*clocks_table;\n\tvoid\t\t\t\t*watermarks_table;\n\n\tvoid\t\t\t\t*max_sustainable_clocks;\n\tstruct smu_bios_boot_up_values\tboot_values;\n\tvoid\t\t\t\t*driver_pptable;\n\tvoid\t\t\t\t*combo_pptable;\n\tvoid                            *ecc_table;\n\tvoid\t\t\t\t*driver_smu_config_table;\n\tstruct smu_table\t\ttables[SMU_TABLE_COUNT];\n\t \n\tstruct smu_table\t\tdriver_table;\n\tstruct smu_table\t\tmemory_pool;\n\tstruct smu_table\t\tdummy_read_1_table;\n\tuint8_t                         thermal_controller_type;\n\n\tvoid\t\t\t\t*overdrive_table;\n\tvoid                            *boot_overdrive_table;\n\tvoid\t\t\t\t*user_overdrive_table;\n\n\tuint32_t\t\t\tgpu_metrics_table_size;\n\tvoid\t\t\t\t*gpu_metrics_table;\n};\n\nstruct smu_dpm_context {\n\tuint32_t dpm_context_size;\n\tvoid *dpm_context;\n\tvoid *golden_dpm_context;\n\tenum amd_dpm_forced_level dpm_level;\n\tenum amd_dpm_forced_level saved_dpm_level;\n\tenum amd_dpm_forced_level requested_dpm_level;\n\tstruct smu_power_state *dpm_request_power_state;\n\tstruct smu_power_state *dpm_current_power_state;\n\tstruct mclock_latency_table *mclk_latency_table;\n};\n\nstruct smu_power_gate {\n\tbool uvd_gated;\n\tbool vce_gated;\n\tatomic_t vcn_gated;\n\tatomic_t jpeg_gated;\n};\n\nstruct smu_power_context {\n\tvoid *power_context;\n\tuint32_t power_context_size;\n\tstruct smu_power_gate power_gate;\n};\n\n#define SMU_FEATURE_MAX\t(64)\nstruct smu_feature {\n\tuint32_t feature_num;\n\tDECLARE_BITMAP(supported, SMU_FEATURE_MAX);\n\tDECLARE_BITMAP(allowed, SMU_FEATURE_MAX);\n};\n\nstruct smu_clocks {\n\tuint32_t engine_clock;\n\tuint32_t memory_clock;\n\tuint32_t bus_bandwidth;\n\tuint32_t engine_clock_in_sr;\n\tuint32_t dcef_clock;\n\tuint32_t dcef_clock_in_sr;\n};\n\n#define MAX_REGULAR_DPM_NUM 16\nstruct mclk_latency_entries {\n\tuint32_t  frequency;\n\tuint32_t  latency;\n};\nstruct mclock_latency_table {\n\tuint32_t  count;\n\tstruct mclk_latency_entries  entries[MAX_REGULAR_DPM_NUM];\n};\n\nenum smu_reset_mode {\n    SMU_RESET_MODE_0,\n    SMU_RESET_MODE_1,\n    SMU_RESET_MODE_2,\n};\n\nenum smu_baco_state {\n\tSMU_BACO_STATE_ENTER = 0,\n\tSMU_BACO_STATE_EXIT,\n};\n\nstruct smu_baco_context {\n\tuint32_t state;\n\tbool platform_support;\n\tbool maco_support;\n};\n\nstruct smu_freq_info {\n\tuint32_t min;\n\tuint32_t max;\n\tuint32_t freq_level;\n};\n\nstruct pstates_clk_freq {\n\tuint32_t\t\t\tmin;\n\tuint32_t\t\t\tstandard;\n\tuint32_t\t\t\tpeak;\n\tstruct smu_freq_info\t\tcustom;\n\tstruct smu_freq_info\t\tcurr;\n};\n\nstruct smu_umd_pstate_table {\n\tstruct pstates_clk_freq\t\tgfxclk_pstate;\n\tstruct pstates_clk_freq\t\tsocclk_pstate;\n\tstruct pstates_clk_freq\t\tuclk_pstate;\n\tstruct pstates_clk_freq\t\tvclk_pstate;\n\tstruct pstates_clk_freq\t\tdclk_pstate;\n\tstruct pstates_clk_freq\t\tfclk_pstate;\n};\n\nstruct cmn2asic_msg_mapping {\n\tint\tvalid_mapping;\n\tint\tmap_to;\n\tint\tvalid_in_vf;\n};\n\nstruct cmn2asic_mapping {\n\tint\tvalid_mapping;\n\tint\tmap_to;\n};\n\nstruct stb_context {\n\tuint32_t stb_buf_size;\n\tbool enabled;\n\tspinlock_t lock;\n};\n\n#define WORKLOAD_POLICY_MAX 7\n\nstruct smu_context {\n\tstruct amdgpu_device            *adev;\n\tstruct amdgpu_irq_src\t\tirq_source;\n\n\tconst struct pptable_funcs\t*ppt_funcs;\n\tconst struct cmn2asic_msg_mapping\t*message_map;\n\tconst struct cmn2asic_mapping\t*clock_map;\n\tconst struct cmn2asic_mapping\t*feature_map;\n\tconst struct cmn2asic_mapping\t*table_map;\n\tconst struct cmn2asic_mapping\t*pwr_src_map;\n\tconst struct cmn2asic_mapping\t*workload_map;\n\tstruct mutex\t\t\tmessage_lock;\n\tuint64_t pool_size;\n\n\tstruct smu_table_context\tsmu_table;\n\tstruct smu_dpm_context\t\tsmu_dpm;\n\tstruct smu_power_context\tsmu_power;\n\tstruct smu_feature\t\tsmu_feature;\n\tstruct amd_pp_display_configuration  *display_config;\n\tstruct smu_baco_context\t\tsmu_baco;\n\tstruct smu_temperature_range\tthermal_range;\n\tvoid *od_settings;\n\n\tstruct smu_umd_pstate_table\tpstate_table;\n\tuint32_t pstate_sclk;\n\tuint32_t pstate_mclk;\n\n\tbool od_enabled;\n\tuint32_t current_power_limit;\n\tuint32_t default_power_limit;\n\tuint32_t max_power_limit;\n\n\t \n\tuint32_t ppt_offset_bytes;\n\tuint32_t ppt_size_bytes;\n\tuint8_t  *ppt_start_addr;\n\n\tbool support_power_containment;\n\tbool disable_watermark;\n\n#define WATERMARKS_EXIST\t(1 << 0)\n#define WATERMARKS_LOADED\t(1 << 1)\n\tuint32_t watermarks_bitmap;\n\tuint32_t hard_min_uclk_req_from_dal;\n\tbool disable_uclk_switch;\n\n\tuint32_t workload_mask;\n\tuint32_t workload_prority[WORKLOAD_POLICY_MAX];\n\tuint32_t workload_setting[WORKLOAD_POLICY_MAX];\n\tuint32_t power_profile_mode;\n\tuint32_t default_power_profile_mode;\n\tbool pm_enabled;\n\tbool is_apu;\n\n\tuint32_t smc_driver_if_version;\n\tuint32_t smc_fw_if_version;\n\tuint32_t smc_fw_version;\n\n\tbool uploading_custom_pp_table;\n\tbool dc_controlled_by_gpio;\n\n\tstruct work_struct throttling_logging_work;\n\tatomic64_t throttle_int_counter;\n\tstruct work_struct interrupt_work;\n\n\tunsigned fan_max_rpm;\n\tunsigned manual_fan_speed_pwm;\n\n\tuint32_t gfx_default_hard_min_freq;\n\tuint32_t gfx_default_soft_max_freq;\n\tuint32_t gfx_actual_hard_min_freq;\n\tuint32_t gfx_actual_soft_max_freq;\n\n\t \n\tuint32_t cpu_default_soft_min_freq;\n\tuint32_t cpu_default_soft_max_freq;\n\tuint32_t cpu_actual_soft_min_freq;\n\tuint32_t cpu_actual_soft_max_freq;\n\tuint32_t cpu_core_id_select;\n\tuint16_t cpu_core_num;\n\n\tstruct smu_user_dpm_profile user_dpm_profile;\n\n\tstruct stb_context stb_context;\n\n\tstruct firmware pptable_firmware;\n\n\tu32 param_reg;\n\tu32 msg_reg;\n\tu32 resp_reg;\n\n\tu32 debug_param_reg;\n\tu32 debug_msg_reg;\n\tu32 debug_resp_reg;\n\n\tstruct delayed_work\t\tswctf_delayed_work;\n};\n\nstruct i2c_adapter;\n\n \nstruct pptable_funcs {\n\t \n\tint (*run_btc)(struct smu_context *smu);\n\n\t \n\tint (*get_allowed_feature_mask)(struct smu_context *smu, uint32_t *feature_mask, uint32_t num);\n\n\t \n\tenum amd_pm_state_type (*get_current_power_state)(struct smu_context *smu);\n\n\t \n\tint (*set_default_dpm_table)(struct smu_context *smu);\n\n\tint (*set_power_state)(struct smu_context *smu);\n\n\t \n\tint (*populate_umd_state_clk)(struct smu_context *smu);\n\n\t \n\tint (*print_clk_levels)(struct smu_context *smu, enum smu_clk_type clk_type, char *buf);\n\n\t \n\tint (*emit_clk_levels)(struct smu_context *smu, enum smu_clk_type clk_type, char *buf, int *offset);\n\n\t \n\tint (*force_clk_levels)(struct smu_context *smu, enum smu_clk_type clk_type, uint32_t mask);\n\n\t \n\tint (*od_edit_dpm_table)(struct smu_context *smu,\n\t\t\t\t enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t long *input, uint32_t size);\n\n\t \n\tint (*restore_user_od_settings)(struct smu_context *smu);\n\n\t \n\tint (*get_clock_by_type_with_latency)(struct smu_context *smu,\n\t\t\t\t\t      enum smu_clk_type clk_type,\n\t\t\t\t\t      struct\n\t\t\t\t\t      pp_clock_levels_with_latency\n\t\t\t\t\t      *clocks);\n\t \n\tint (*get_clock_by_type_with_voltage)(struct smu_context *smu,\n\t\t\t\t\t      enum amd_pp_clock_type type,\n\t\t\t\t\t      struct\n\t\t\t\t\t      pp_clock_levels_with_voltage\n\t\t\t\t\t      *clocks);\n\n\t \n\tint (*get_power_profile_mode)(struct smu_context *smu, char *buf);\n\n\t \n\tint (*set_power_profile_mode)(struct smu_context *smu, long *input, uint32_t size);\n\n\t \n\tint (*dpm_set_vcn_enable)(struct smu_context *smu, bool enable);\n\n\t \n\tint (*dpm_set_jpeg_enable)(struct smu_context *smu, bool enable);\n\n\t \n\tint (*set_gfx_power_up_by_imu)(struct smu_context *smu);\n\n\t \n\tint (*read_sensor)(struct smu_context *smu, enum amd_pp_sensors sensor,\n\t\t\t   void *data, uint32_t *size);\n\n\t \n\tint (*get_apu_thermal_limit)(struct smu_context *smu, uint32_t *limit);\n\n\t \n\tint (*set_apu_thermal_limit)(struct smu_context *smu, uint32_t limit);\n\n\t \n\tint (*pre_display_config_changed)(struct smu_context *smu);\n\n\t \n\tint (*display_config_changed)(struct smu_context *smu);\n\n\tint (*apply_clocks_adjust_rules)(struct smu_context *smu);\n\n\t \n\tint (*notify_smc_display_config)(struct smu_context *smu);\n\n\t \n\tbool (*is_dpm_running)(struct smu_context *smu);\n\n\t \n\tint (*get_fan_speed_pwm)(struct smu_context *smu, uint32_t *speed);\n\n\t \n\tint (*get_fan_speed_rpm)(struct smu_context *smu, uint32_t *speed);\n\n\t \n\tint (*set_watermarks_table)(struct smu_context *smu,\n\t\t\t\t    struct pp_smu_wm_range_sets *clock_ranges);\n\n\t \n\tint (*get_thermal_temperature_range)(struct smu_context *smu, struct smu_temperature_range *range);\n\n\t \n\tint (*get_uclk_dpm_states)(struct smu_context *smu, uint32_t *clocks_in_khz, uint32_t *num_states);\n\n\t \n\tint (*set_default_od_settings)(struct smu_context *smu);\n\n\t \n\tint (*set_performance_level)(struct smu_context *smu, enum amd_dpm_forced_level level);\n\n\t \n\tint (*display_disable_memory_clock_switch)(struct smu_context *smu, bool disable_memory_clock_switch);\n\n\t \n\tvoid (*dump_pptable)(struct smu_context *smu);\n\n\t \n\tint (*get_power_limit)(struct smu_context *smu,\n\t\t\t       uint32_t *current_power_limit,\n\t\t\t       uint32_t *default_power_limit,\n\t\t\t       uint32_t *max_power_limit);\n\n\t \n\tint (*get_ppt_limit)(struct smu_context *smu, uint32_t *ppt_limit,\n\t\t\tenum smu_ppt_limit_type limit_type, enum smu_ppt_limit_level limit_level);\n\n\t \n\tint (*set_df_cstate)(struct smu_context *smu, enum pp_df_cstate state);\n\n\t \n\tint (*allow_xgmi_power_down)(struct smu_context *smu, bool en);\n\n\t \n\tint (*update_pcie_parameters)(struct smu_context *smu, uint8_t pcie_gen_cap, uint8_t pcie_width_cap);\n\n\t \n\tint (*i2c_init)(struct smu_context *smu);\n\n\t \n\tvoid (*i2c_fini)(struct smu_context *smu);\n\n\t \n\tvoid (*get_unique_id)(struct smu_context *smu);\n\n\t \n\tint (*get_dpm_clock_table)(struct smu_context *smu, struct dpm_clocks *clock_table);\n\n\t \n\tint (*init_microcode)(struct smu_context *smu);\n\n\t \n\tint (*load_microcode)(struct smu_context *smu);\n\n\t \n\tvoid (*fini_microcode)(struct smu_context *smu);\n\n\t \n\tint (*init_smc_tables)(struct smu_context *smu);\n\n\t \n\tint (*fini_smc_tables)(struct smu_context *smu);\n\n\t \n\tint (*init_power)(struct smu_context *smu);\n\n\t \n\tint (*fini_power)(struct smu_context *smu);\n\n\t \n\tint (*check_fw_status)(struct smu_context *smu);\n\n\t \n\tint (*set_mp1_state)(struct smu_context *smu,\n\t\t\t     enum pp_mp1_state mp1_state);\n\n\t \n\tint (*setup_pptable)(struct smu_context *smu);\n\n\t \n\tint (*get_vbios_bootup_values)(struct smu_context *smu);\n\n\t \n\tint (*check_fw_version)(struct smu_context *smu);\n\n\t \n\tint (*powergate_sdma)(struct smu_context *smu, bool gate);\n\n\t \n\tint (*set_gfx_cgpg)(struct smu_context *smu, bool enable);\n\n\t \n\tint (*write_pptable)(struct smu_context *smu);\n\n\t \n\tint (*set_driver_table_location)(struct smu_context *smu);\n\n\t \n\tint (*set_tool_table_location)(struct smu_context *smu);\n\n\t \n\tint (*notify_memory_pool_location)(struct smu_context *smu);\n\n\t \n\tint (*system_features_control)(struct smu_context *smu, bool en);\n\n\t \n\tint (*send_smc_msg_with_param)(struct smu_context *smu,\n\t\t\t\t       enum smu_message_type msg, uint32_t param, uint32_t *read_arg);\n\n\t \n\tint (*send_smc_msg)(struct smu_context *smu,\n\t\t\t    enum smu_message_type msg,\n\t\t\t    uint32_t *read_arg);\n\n\t \n\tint (*init_display_count)(struct smu_context *smu, uint32_t count);\n\n\t \n\tint (*set_allowed_mask)(struct smu_context *smu);\n\n\t \n\tint (*get_enabled_mask)(struct smu_context *smu, uint64_t *feature_mask);\n\n\t \n\tint (*feature_is_enabled)(struct smu_context *smu, enum smu_feature_mask mask);\n\n\t \n\tint (*disable_all_features_with_exception)(struct smu_context *smu,\n\t\t\t\t\t\t   enum smu_feature_mask mask);\n\n\t \n\tint (*notify_display_change)(struct smu_context *smu);\n\n\t \n\tint (*set_power_limit)(struct smu_context *smu,\n\t\t\t       enum smu_ppt_limit_type limit_type,\n\t\t\t       uint32_t limit);\n\n\t \n\tint (*init_max_sustainable_clocks)(struct smu_context *smu);\n\n\t \n\tint (*enable_thermal_alert)(struct smu_context *smu);\n\n\t \n\tint (*disable_thermal_alert)(struct smu_context *smu);\n\n\t \n\tint (*set_min_dcef_deep_sleep)(struct smu_context *smu, uint32_t clk);\n\n\t \n\tint (*display_clock_voltage_request)(struct smu_context *smu, struct\n\t\t\t\t\t     pp_display_clock_request\n\t\t\t\t\t     *clock_req);\n\n\t \n\tuint32_t (*get_fan_control_mode)(struct smu_context *smu);\n\n\t \n\tint (*set_fan_control_mode)(struct smu_context *smu, uint32_t mode);\n\n\t \n\tint (*set_fan_speed_pwm)(struct smu_context *smu, uint32_t speed);\n\n\t \n\tint (*set_fan_speed_rpm)(struct smu_context *smu, uint32_t speed);\n\n\t \n\tint (*set_xgmi_pstate)(struct smu_context *smu, uint32_t pstate);\n\n\t \n\tint (*gfx_off_control)(struct smu_context *smu, bool enable);\n\n\n\t \n\tuint32_t (*get_gfx_off_status)(struct smu_context *smu);\n\n\t \n\tu32 (*get_gfx_off_entrycount)(struct smu_context *smu, uint64_t *entrycount);\n\n\t \n\tu32 (*set_gfx_off_residency)(struct smu_context *smu, bool start);\n\n\t \n\tu32 (*get_gfx_off_residency)(struct smu_context *smu, uint32_t *residency);\n\n\t \n\tint (*register_irq_handler)(struct smu_context *smu);\n\n\t \n\tint (*set_azalia_d3_pme)(struct smu_context *smu);\n\n\t \n\tint (*get_max_sustainable_clocks_by_dc)(struct smu_context *smu, struct pp_smu_nv_clock_table *max_clocks);\n\n\t \n\tbool (*baco_is_support)(struct smu_context *smu);\n\n\t \n\tenum smu_baco_state (*baco_get_state)(struct smu_context *smu);\n\n\t \n\tint (*baco_set_state)(struct smu_context *smu, enum smu_baco_state state);\n\n\t \n\tint (*baco_enter)(struct smu_context *smu);\n\n\t \n\tint (*baco_exit)(struct smu_context *smu);\n\n\t \n\tbool (*mode1_reset_is_support)(struct smu_context *smu);\n\t \n\tbool (*mode2_reset_is_support)(struct smu_context *smu);\n\n\t \n\tint (*mode1_reset)(struct smu_context *smu);\n\n\t \n\tint (*mode2_reset)(struct smu_context *smu);\n\t \n\tint (*enable_gfx_features)(struct smu_context *smu);\n\n\t \n\tint (*get_dpm_ultimate_freq)(struct smu_context *smu, enum smu_clk_type clk_type, uint32_t *min, uint32_t *max);\n\n\t \n\tint (*set_soft_freq_limited_range)(struct smu_context *smu, enum smu_clk_type clk_type, uint32_t min, uint32_t max);\n\n\t \n\tint (*set_power_source)(struct smu_context *smu, enum smu_power_src_type power_src);\n\n\t \n\tvoid (*log_thermal_throttling_event)(struct smu_context *smu);\n\n\t \n\tsize_t (*get_pp_feature_mask)(struct smu_context *smu, char *buf);\n\n\t \n\tint (*set_pp_feature_mask)(struct smu_context *smu, uint64_t new_mask);\n\n\t \n\tssize_t (*get_gpu_metrics)(struct smu_context *smu, void **table);\n\n\t \n\tint (*enable_mgpu_fan_boost)(struct smu_context *smu);\n\n\t \n\tint (*gfx_ulv_control)(struct smu_context *smu, bool enablement);\n\n\t \n\tint (*deep_sleep_control)(struct smu_context *smu, bool enablement);\n\n\t \n\tint (*get_fan_parameters)(struct smu_context *smu);\n\n\t \n\tint (*post_init)(struct smu_context *smu);\n\n\t \n\tvoid (*interrupt_work)(struct smu_context *smu);\n\n\t \n\tint (*gpo_control)(struct smu_context *smu, bool enablement);\n\n\t \n\tint (*gfx_state_change_set)(struct smu_context *smu, uint32_t state);\n\n\t \n\tint (*set_fine_grain_gfx_freq_parameters)(struct smu_context *smu);\n\n\t \n\tint (*smu_handle_passthrough_sbr)(struct smu_context *smu, bool enable);\n\n\t \n\tint (*wait_for_event)(struct smu_context *smu,\n\t\t\t      enum smu_event_type event, uint64_t event_arg);\n\n\t \n\tint (*send_hbm_bad_pages_num)(struct smu_context *smu, uint32_t size);\n\n\t \n\tssize_t (*get_ecc_info)(struct smu_context *smu, void *table);\n\t\n\t\n\t \n\tint (*stb_collect_info)(struct smu_context *smu, void *buf, uint32_t size);\n\n\t \n\tint (*get_default_config_table_settings)(struct smu_context *smu, struct config_table_setting *table);\n\n\t \n\tint (*set_config_table)(struct smu_context *smu, struct config_table_setting *table);\n\n\t \n\tint (*send_hbm_bad_channel_flag)(struct smu_context *smu, uint32_t size);\n\n\t \n\tint (*init_pptable_microcode)(struct smu_context *smu);\n};\n\ntypedef enum {\n\tMETRICS_CURR_GFXCLK,\n\tMETRICS_CURR_SOCCLK,\n\tMETRICS_CURR_UCLK,\n\tMETRICS_CURR_VCLK,\n\tMETRICS_CURR_VCLK1,\n\tMETRICS_CURR_DCLK,\n\tMETRICS_CURR_DCLK1,\n\tMETRICS_CURR_FCLK,\n\tMETRICS_CURR_DCEFCLK,\n\tMETRICS_AVERAGE_CPUCLK,\n\tMETRICS_AVERAGE_GFXCLK,\n\tMETRICS_AVERAGE_SOCCLK,\n\tMETRICS_AVERAGE_FCLK,\n\tMETRICS_AVERAGE_UCLK,\n\tMETRICS_AVERAGE_VCLK,\n\tMETRICS_AVERAGE_DCLK,\n\tMETRICS_AVERAGE_VCLK1,\n\tMETRICS_AVERAGE_DCLK1,\n\tMETRICS_AVERAGE_GFXACTIVITY,\n\tMETRICS_AVERAGE_MEMACTIVITY,\n\tMETRICS_AVERAGE_VCNACTIVITY,\n\tMETRICS_AVERAGE_SOCKETPOWER,\n\tMETRICS_TEMPERATURE_EDGE,\n\tMETRICS_TEMPERATURE_HOTSPOT,\n\tMETRICS_TEMPERATURE_MEM,\n\tMETRICS_TEMPERATURE_VRGFX,\n\tMETRICS_TEMPERATURE_VRSOC,\n\tMETRICS_TEMPERATURE_VRMEM,\n\tMETRICS_THROTTLER_STATUS,\n\tMETRICS_CURR_FANSPEED,\n\tMETRICS_VOLTAGE_VDDSOC,\n\tMETRICS_VOLTAGE_VDDGFX,\n\tMETRICS_SS_APU_SHARE,\n\tMETRICS_SS_DGPU_SHARE,\n\tMETRICS_UNIQUE_ID_UPPER32,\n\tMETRICS_UNIQUE_ID_LOWER32,\n\tMETRICS_PCIE_RATE,\n\tMETRICS_PCIE_WIDTH,\n\tMETRICS_CURR_FANPWM,\n\tMETRICS_CURR_SOCKETPOWER,\n} MetricsMember_t;\n\nenum smu_cmn2asic_mapping_type {\n\tCMN2ASIC_MAPPING_MSG,\n\tCMN2ASIC_MAPPING_CLK,\n\tCMN2ASIC_MAPPING_FEATURE,\n\tCMN2ASIC_MAPPING_TABLE,\n\tCMN2ASIC_MAPPING_PWR,\n\tCMN2ASIC_MAPPING_WORKLOAD,\n};\n\nenum smu_baco_seq {\n\tBACO_SEQ_BACO = 0,\n\tBACO_SEQ_MSR,\n\tBACO_SEQ_BAMACO,\n\tBACO_SEQ_ULPS,\n\tBACO_SEQ_COUNT,\n};\n\n#define MSG_MAP(msg, index, valid_in_vf) \\\n\t[SMU_MSG_##msg] = {1, (index), (valid_in_vf)}\n\n#define CLK_MAP(clk, index) \\\n\t[SMU_##clk] = {1, (index)}\n\n#define FEA_MAP(fea) \\\n\t[SMU_FEATURE_##fea##_BIT] = {1, FEATURE_##fea##_BIT}\n\n#define FEA_MAP_REVERSE(fea) \\\n\t[SMU_FEATURE_DPM_##fea##_BIT] = {1, FEATURE_##fea##_DPM_BIT}\n\n#define FEA_MAP_HALF_REVERSE(fea) \\\n\t[SMU_FEATURE_DPM_##fea##CLK_BIT] = {1, FEATURE_##fea##_DPM_BIT}\n\n#define TAB_MAP(tab) \\\n\t[SMU_TABLE_##tab] = {1, TABLE_##tab}\n\n#define TAB_MAP_VALID(tab) \\\n\t[SMU_TABLE_##tab] = {1, TABLE_##tab}\n\n#define TAB_MAP_INVALID(tab) \\\n\t[SMU_TABLE_##tab] = {0, TABLE_##tab}\n\n#define PWR_MAP(tab) \\\n\t[SMU_POWER_SOURCE_##tab] = {1, POWER_SOURCE_##tab}\n\n#define WORKLOAD_MAP(profile, workload) \\\n\t[profile] = {1, (workload)}\n\n \n#define smu_memcpy_trailing(dst, first_dst_member, last_dst_member,\t   \\\n\t\t\t    src, first_src_member)\t\t\t   \\\n({\t\t\t\t\t\t\t\t\t   \\\n\tsize_t __src_offset = offsetof(typeof(*(src)), first_src_member);  \\\n\tsize_t __src_size = sizeof(*(src)) - __src_offset;\t\t   \\\n\tsize_t __dst_offset = offsetof(typeof(*(dst)), first_dst_member);  \\\n\tsize_t __dst_size = offsetofend(typeof(*(dst)), last_dst_member) - \\\n\t\t\t    __dst_offset;\t\t\t\t   \\\n\tBUILD_BUG_ON(__src_size != __dst_size);\t\t\t\t   \\\n\t__builtin_memcpy((u8 *)(dst) + __dst_offset,\t\t\t   \\\n\t\t\t (u8 *)(src) + __src_offset,\t\t\t   \\\n\t\t\t __dst_size);\t\t\t\t\t   \\\n})\n\n#if !defined(SWSMU_CODE_LAYER_L2) && !defined(SWSMU_CODE_LAYER_L3) && !defined(SWSMU_CODE_LAYER_L4)\nint smu_get_power_limit(void *handle,\n\t\t\tuint32_t *limit,\n\t\t\tenum pp_power_limit_level pp_limit_level,\n\t\t\tenum pp_power_type pp_power_type);\n\nbool smu_mode1_reset_is_support(struct smu_context *smu);\nbool smu_mode2_reset_is_support(struct smu_context *smu);\nint smu_mode1_reset(struct smu_context *smu);\n\nextern const struct amd_ip_funcs smu_ip_funcs;\n\nbool is_support_sw_smu(struct amdgpu_device *adev);\nbool is_support_cclk_dpm(struct amdgpu_device *adev);\nint smu_write_watermarks_table(struct smu_context *smu);\n\nint smu_get_dpm_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t   uint32_t *min, uint32_t *max);\n\nint smu_set_soft_freq_range(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t    uint32_t min, uint32_t max);\n\nint smu_set_gfx_power_up_by_imu(struct smu_context *smu);\n\nint smu_set_ac_dc(struct smu_context *smu);\n\nint smu_allow_xgmi_power_down(struct smu_context *smu, bool en);\n\nint smu_get_entrycount_gfxoff(struct smu_context *smu, u64 *value);\n\nint smu_get_residency_gfxoff(struct smu_context *smu, u32 *value);\n\nint smu_set_residency_gfxoff(struct smu_context *smu, bool value);\n\nint smu_get_status_gfxoff(struct smu_context *smu, uint32_t *value);\n\nint smu_handle_passthrough_sbr(struct smu_context *smu, bool enable);\n\nint smu_wait_for_event(struct smu_context *smu, enum smu_event_type event,\n\t\t       uint64_t event_arg);\nint smu_get_ecc_info(struct smu_context *smu, void *umc_ecc);\nint smu_stb_collect_info(struct smu_context *smu, void *buff, uint32_t size);\nvoid amdgpu_smu_stb_debug_fs_init(struct amdgpu_device *adev);\nint smu_send_hbm_bad_pages_num(struct smu_context *smu, uint32_t size);\nint smu_send_hbm_bad_channel_flag(struct smu_context *smu, uint32_t size);\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}