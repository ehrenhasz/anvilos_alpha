{
  "module_name": "sienna_cichlid_ppt.c",
  "hash_id": "c61603de5c4436d3ff8a70de490e95049e2f25a333c8c8d18c99e4cc2a70b530",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu11/sienna_cichlid_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include <linux/firmware.h>\n#include <linux/pci.h>\n#include <linux/i2c.h>\n#include \"amdgpu.h\"\n#include \"amdgpu_dpm.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v11_0.h\"\n#include \"smu11_driver_if_sienna_cichlid.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"sienna_cichlid_ppt.h\"\n#include \"smu_v11_0_7_pptable.h\"\n#include \"smu_v11_0_7_ppsmc.h\"\n#include \"nbio/nbio_2_3_offset.h\"\n#include \"nbio/nbio_2_3_sh_mask.h\"\n#include \"thm/thm_11_0_2_offset.h\"\n#include \"thm/thm_11_0_2_sh_mask.h\"\n#include \"mp/mp_11_0_offset.h\"\n#include \"mp/mp_11_0_sh_mask.h\"\n\n#include \"asic_reg/mp/mp_11_0_sh_mask.h\"\n#include \"amdgpu_ras.h\"\n#include \"smu_cmn.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_DPM_PREFETCHER_BIT) | \\\n\tFEATURE_MASK(FEATURE_DPM_GFXCLK_BIT)     | \\\n\tFEATURE_MASK(FEATURE_DPM_UCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_LINK_BIT)       | \\\n\tFEATURE_MASK(FEATURE_DPM_SOCCLK_BIT)     | \\\n\tFEATURE_MASK(FEATURE_DPM_FCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_DCEFCLK_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DPM_MP0CLK_BIT))\n\n#define SMU_11_0_7_GFX_BUSY_THRESHOLD 15\n\n#define GET_PPTABLE_MEMBER(field, member) do {\\\n\tif (smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 13))\\\n\t\t(*member) = (smu->smu_table.driver_pptable + offsetof(PPTable_beige_goby_t, field));\\\n\telse\\\n\t\t(*member) = (smu->smu_table.driver_pptable + offsetof(PPTable_t, field));\\\n} while(0)\n\n \n#define SIENNA_CICHLID_STB_DEPTH_UNIT_BYTES 8\n\n \n#define SUPPORT_ECCTABLE_SMU_VERSION 0x003a4600\n\nstatic int get_table_size(struct smu_context *smu)\n{\n\tif (smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 13))\n\t\treturn sizeof(PPTable_beige_goby_t);\n\telse\n\t\treturn sizeof(PPTable_t);\n}\n\nstatic struct cmn2asic_msg_mapping sienna_cichlid_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,\t\t\tPPSMC_MSG_TestMessage,                 1),\n\tMSG_MAP(GetSmuVersion,\t\t\tPPSMC_MSG_GetSmuVersion,               1),\n\tMSG_MAP(GetDriverIfVersion,\t\tPPSMC_MSG_GetDriverIfVersion,          1),\n\tMSG_MAP(SetAllowedFeaturesMaskLow,\tPPSMC_MSG_SetAllowedFeaturesMaskLow,   0),\n\tMSG_MAP(SetAllowedFeaturesMaskHigh,\tPPSMC_MSG_SetAllowedFeaturesMaskHigh,  0),\n\tMSG_MAP(EnableAllSmuFeatures,\t\tPPSMC_MSG_EnableAllSmuFeatures,        0),\n\tMSG_MAP(DisableAllSmuFeatures,\t\tPPSMC_MSG_DisableAllSmuFeatures,       0),\n\tMSG_MAP(EnableSmuFeaturesLow,\t\tPPSMC_MSG_EnableSmuFeaturesLow,        1),\n\tMSG_MAP(EnableSmuFeaturesHigh,\t\tPPSMC_MSG_EnableSmuFeaturesHigh,       1),\n\tMSG_MAP(DisableSmuFeaturesLow,\t\tPPSMC_MSG_DisableSmuFeaturesLow,       1),\n\tMSG_MAP(DisableSmuFeaturesHigh,\t\tPPSMC_MSG_DisableSmuFeaturesHigh,      1),\n\tMSG_MAP(GetEnabledSmuFeaturesLow,       PPSMC_MSG_GetRunningSmuFeaturesLow,    1),\n\tMSG_MAP(GetEnabledSmuFeaturesHigh,\tPPSMC_MSG_GetRunningSmuFeaturesHigh,   1),\n\tMSG_MAP(SetWorkloadMask,\t\tPPSMC_MSG_SetWorkloadMask,             1),\n\tMSG_MAP(SetPptLimit,\t\t\tPPSMC_MSG_SetPptLimit,                 0),\n\tMSG_MAP(SetDriverDramAddrHigh,\t\tPPSMC_MSG_SetDriverDramAddrHigh,       1),\n\tMSG_MAP(SetDriverDramAddrLow,\t\tPPSMC_MSG_SetDriverDramAddrLow,        1),\n\tMSG_MAP(SetToolsDramAddrHigh,\t\tPPSMC_MSG_SetToolsDramAddrHigh,        0),\n\tMSG_MAP(SetToolsDramAddrLow,\t\tPPSMC_MSG_SetToolsDramAddrLow,         0),\n\tMSG_MAP(TransferTableSmu2Dram,\t\tPPSMC_MSG_TransferTableSmu2Dram,       1),\n\tMSG_MAP(TransferTableDram2Smu,\t\tPPSMC_MSG_TransferTableDram2Smu,       0),\n\tMSG_MAP(UseDefaultPPTable,\t\tPPSMC_MSG_UseDefaultPPTable,           0),\n\tMSG_MAP(RunDcBtc,\t\t\tPPSMC_MSG_RunDcBtc,                    0),\n\tMSG_MAP(EnterBaco,\t\t\tPPSMC_MSG_EnterBaco,                   0),\n\tMSG_MAP(SetSoftMinByFreq,\t\tPPSMC_MSG_SetSoftMinByFreq,            1),\n\tMSG_MAP(SetSoftMaxByFreq,\t\tPPSMC_MSG_SetSoftMaxByFreq,            1),\n\tMSG_MAP(SetHardMinByFreq,\t\tPPSMC_MSG_SetHardMinByFreq,            1),\n\tMSG_MAP(SetHardMaxByFreq,\t\tPPSMC_MSG_SetHardMaxByFreq,            0),\n\tMSG_MAP(GetMinDpmFreq,\t\t\tPPSMC_MSG_GetMinDpmFreq,               1),\n\tMSG_MAP(GetMaxDpmFreq,\t\t\tPPSMC_MSG_GetMaxDpmFreq,               1),\n\tMSG_MAP(GetDpmFreqByIndex,\t\tPPSMC_MSG_GetDpmFreqByIndex,           1),\n\tMSG_MAP(SetGeminiMode,\t\t\tPPSMC_MSG_SetGeminiMode,               0),\n\tMSG_MAP(SetGeminiApertureHigh,\t\tPPSMC_MSG_SetGeminiApertureHigh,       0),\n\tMSG_MAP(SetGeminiApertureLow,\t\tPPSMC_MSG_SetGeminiApertureLow,        0),\n\tMSG_MAP(OverridePcieParameters,\t\tPPSMC_MSG_OverridePcieParameters,      0),\n\tMSG_MAP(ReenableAcDcInterrupt,\t\tPPSMC_MSG_ReenableAcDcInterrupt,       0),\n\tMSG_MAP(NotifyPowerSource,\t\tPPSMC_MSG_NotifyPowerSource,           0),\n\tMSG_MAP(SetUclkFastSwitch,\t\tPPSMC_MSG_SetUclkFastSwitch,           0),\n\tMSG_MAP(SetVideoFps,\t\t\tPPSMC_MSG_SetVideoFps,                 0),\n\tMSG_MAP(PrepareMp1ForUnload,\t\tPPSMC_MSG_PrepareMp1ForUnload,         1),\n\tMSG_MAP(AllowGfxOff,\t\t\tPPSMC_MSG_AllowGfxOff,                 0),\n\tMSG_MAP(DisallowGfxOff,\t\t\tPPSMC_MSG_DisallowGfxOff,              0),\n\tMSG_MAP(GetPptLimit,\t\t\tPPSMC_MSG_GetPptLimit,                 0),\n\tMSG_MAP(GetDcModeMaxDpmFreq,\t\tPPSMC_MSG_GetDcModeMaxDpmFreq,         1),\n\tMSG_MAP(ExitBaco,\t\t\tPPSMC_MSG_ExitBaco,                    0),\n\tMSG_MAP(PowerUpVcn,\t\t\tPPSMC_MSG_PowerUpVcn,                  0),\n\tMSG_MAP(PowerDownVcn,\t\t\tPPSMC_MSG_PowerDownVcn,                0),\n\tMSG_MAP(PowerUpJpeg,\t\t\tPPSMC_MSG_PowerUpJpeg,                 0),\n\tMSG_MAP(PowerDownJpeg,\t\t\tPPSMC_MSG_PowerDownJpeg,               0),\n\tMSG_MAP(BacoAudioD3PME,\t\t\tPPSMC_MSG_BacoAudioD3PME,              0),\n\tMSG_MAP(ArmD3,\t\t\t\tPPSMC_MSG_ArmD3,                       0),\n\tMSG_MAP(Mode1Reset,                     PPSMC_MSG_Mode1Reset,\t\t       0),\n\tMSG_MAP(SetMGpuFanBoostLimitRpm,\tPPSMC_MSG_SetMGpuFanBoostLimitRpm,     0),\n\tMSG_MAP(SetGpoFeaturePMask,\t\tPPSMC_MSG_SetGpoFeaturePMask,          0),\n\tMSG_MAP(DisallowGpo,\t\t\tPPSMC_MSG_DisallowGpo,                 0),\n\tMSG_MAP(Enable2ndUSB20Port,\t\tPPSMC_MSG_Enable2ndUSB20Port,          0),\n\tMSG_MAP(DriverMode2Reset,\t\tPPSMC_MSG_DriverMode2Reset,\t       0),\n};\n\nstatic struct cmn2asic_mapping sienna_cichlid_clk_map[SMU_CLK_COUNT] = {\n\tCLK_MAP(GFXCLK,\t\tPPCLK_GFXCLK),\n\tCLK_MAP(SCLK,\t\tPPCLK_GFXCLK),\n\tCLK_MAP(SOCCLK,\t\tPPCLK_SOCCLK),\n\tCLK_MAP(FCLK,\t\tPPCLK_FCLK),\n\tCLK_MAP(UCLK,\t\tPPCLK_UCLK),\n\tCLK_MAP(MCLK,\t\tPPCLK_UCLK),\n\tCLK_MAP(DCLK,\t\tPPCLK_DCLK_0),\n\tCLK_MAP(DCLK1,\t\tPPCLK_DCLK_1),\n\tCLK_MAP(VCLK,\t\tPPCLK_VCLK_0),\n\tCLK_MAP(VCLK1,\t\tPPCLK_VCLK_1),\n\tCLK_MAP(DCEFCLK,\tPPCLK_DCEFCLK),\n\tCLK_MAP(DISPCLK,\tPPCLK_DISPCLK),\n\tCLK_MAP(PIXCLK,\t\tPPCLK_PIXCLK),\n\tCLK_MAP(PHYCLK,\t\tPPCLK_PHYCLK),\n};\n\nstatic struct cmn2asic_mapping sienna_cichlid_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(DPM_PREFETCHER),\n\tFEA_MAP(DPM_GFXCLK),\n\tFEA_MAP(DPM_GFX_GPO),\n\tFEA_MAP(DPM_UCLK),\n\tFEA_MAP(DPM_FCLK),\n\tFEA_MAP(DPM_SOCCLK),\n\tFEA_MAP(DPM_MP0CLK),\n\tFEA_MAP(DPM_LINK),\n\tFEA_MAP(DPM_DCEFCLK),\n\tFEA_MAP(DPM_XGMI),\n\tFEA_MAP(MEM_VDDCI_SCALING),\n\tFEA_MAP(MEM_MVDD_SCALING),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_FCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_DCEFCLK),\n\tFEA_MAP(DS_UCLK),\n\tFEA_MAP(GFX_ULV),\n\tFEA_MAP(FW_DSTATE),\n\tFEA_MAP(GFXOFF),\n\tFEA_MAP(BACO),\n\tFEA_MAP(MM_DPM_PG),\n\tFEA_MAP(RSMU_SMN_CG),\n\tFEA_MAP(PPT),\n\tFEA_MAP(TDC),\n\tFEA_MAP(APCC_PLUS),\n\tFEA_MAP(GTHR),\n\tFEA_MAP(ACDC),\n\tFEA_MAP(VR0HOT),\n\tFEA_MAP(VR1HOT),\n\tFEA_MAP(FW_CTF),\n\tFEA_MAP(FAN_CONTROL),\n\tFEA_MAP(THERMAL),\n\tFEA_MAP(GFX_DCS),\n\tFEA_MAP(RM),\n\tFEA_MAP(LED_DISPLAY),\n\tFEA_MAP(GFX_SS),\n\tFEA_MAP(OUT_OF_BAND_MONITOR),\n\tFEA_MAP(TEMP_DEPENDENT_VMIN),\n\tFEA_MAP(MMHUB_PG),\n\tFEA_MAP(ATHUB_PG),\n\tFEA_MAP(APCC_DFLL),\n};\n\nstatic struct cmn2asic_mapping sienna_cichlid_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP(PPTABLE),\n\tTAB_MAP(WATERMARKS),\n\tTAB_MAP(AVFS_PSM_DEBUG),\n\tTAB_MAP(AVFS_FUSE_OVERRIDE),\n\tTAB_MAP(PMSTATUSLOG),\n\tTAB_MAP(SMU_METRICS),\n\tTAB_MAP(DRIVER_SMU_CONFIG),\n\tTAB_MAP(ACTIVITY_MONITOR_COEFF),\n\tTAB_MAP(OVERDRIVE),\n\tTAB_MAP(I2C_COMMANDS),\n\tTAB_MAP(PACE),\n\tTAB_MAP(ECCINFO),\n};\n\nstatic struct cmn2asic_mapping sienna_cichlid_pwr_src_map[SMU_POWER_SOURCE_COUNT] = {\n\tPWR_MAP(AC),\n\tPWR_MAP(DC),\n};\n\nstatic struct cmn2asic_mapping sienna_cichlid_workload_map[PP_SMC_POWER_PROFILE_COUNT] = {\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT,\tWORKLOAD_PPLIB_DEFAULT_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_FULLSCREEN3D,\t\tWORKLOAD_PPLIB_FULL_SCREEN_3D_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_POWERSAVING,\t\tWORKLOAD_PPLIB_POWER_SAVING_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VIDEO,\t\tWORKLOAD_PPLIB_VIDEO_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VR,\t\t\tWORKLOAD_PPLIB_VR_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_COMPUTE,\t\tWORKLOAD_PPLIB_COMPUTE_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CUSTOM,\t\tWORKLOAD_PPLIB_CUSTOM_BIT),\n};\n\nstatic const uint8_t sienna_cichlid_throttler_map[] = {\n\t[THROTTLER_TEMP_EDGE_BIT]\t= (SMU_THROTTLER_TEMP_EDGE_BIT),\n\t[THROTTLER_TEMP_HOTSPOT_BIT]\t= (SMU_THROTTLER_TEMP_HOTSPOT_BIT),\n\t[THROTTLER_TEMP_MEM_BIT]\t= (SMU_THROTTLER_TEMP_MEM_BIT),\n\t[THROTTLER_TEMP_VR_GFX_BIT]\t= (SMU_THROTTLER_TEMP_VR_GFX_BIT),\n\t[THROTTLER_TEMP_VR_MEM0_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM0_BIT),\n\t[THROTTLER_TEMP_VR_MEM1_BIT]\t= (SMU_THROTTLER_TEMP_VR_MEM1_BIT),\n\t[THROTTLER_TEMP_VR_SOC_BIT]\t= (SMU_THROTTLER_TEMP_VR_SOC_BIT),\n\t[THROTTLER_TEMP_LIQUID0_BIT]\t= (SMU_THROTTLER_TEMP_LIQUID0_BIT),\n\t[THROTTLER_TEMP_LIQUID1_BIT]\t= (SMU_THROTTLER_TEMP_LIQUID1_BIT),\n\t[THROTTLER_TDC_GFX_BIT]\t\t= (SMU_THROTTLER_TDC_GFX_BIT),\n\t[THROTTLER_TDC_SOC_BIT]\t\t= (SMU_THROTTLER_TDC_SOC_BIT),\n\t[THROTTLER_PPT0_BIT]\t\t= (SMU_THROTTLER_PPT0_BIT),\n\t[THROTTLER_PPT1_BIT]\t\t= (SMU_THROTTLER_PPT1_BIT),\n\t[THROTTLER_PPT2_BIT]\t\t= (SMU_THROTTLER_PPT2_BIT),\n\t[THROTTLER_PPT3_BIT]\t\t= (SMU_THROTTLER_PPT3_BIT),\n\t[THROTTLER_FIT_BIT]\t\t= (SMU_THROTTLER_FIT_BIT),\n\t[THROTTLER_PPM_BIT]\t\t= (SMU_THROTTLER_PPM_BIT),\n\t[THROTTLER_APCC_BIT]\t\t= (SMU_THROTTLER_APCC_BIT),\n};\n\nstatic int\nsienna_cichlid_get_allowed_feature_mask(struct smu_context *smu,\n\t\t\t\t  uint32_t *feature_mask, uint32_t num)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (num > 2)\n\t\treturn -EINVAL;\n\n\tmemset(feature_mask, 0, sizeof(uint32_t) * num);\n\n\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_PREFETCHER_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DPM_FCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DPM_MP0CLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_SOCCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_DCEFCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_FCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DS_UCLK_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_FW_DSTATE_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_DF_CSTATE_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_RSMU_SMN_CG_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_GFX_SS_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_VR0HOT_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_PPT_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_TDC_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_BACO_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_APCC_DFLL_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_FW_CTF_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_FAN_CONTROL_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_THERMAL_BIT)\n\t\t\t\t| FEATURE_MASK(FEATURE_OUT_OF_BAND_MONITOR_BIT);\n\n\tif (adev->pm.pp_feature & PP_SCLK_DPM_MASK) {\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_GFXCLK_BIT);\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_GFX_GPO_BIT);\n\t}\n\n\tif ((adev->pm.pp_feature & PP_GFX_DCS_MASK) &&\n\t    (adev->ip_versions[MP1_HWIP][0] > IP_VERSION(11, 0, 7)) &&\n\t    !(adev->flags & AMD_IS_APU))\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_GFX_DCS_BIT);\n\n\tif (adev->pm.pp_feature & PP_MCLK_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_UCLK_BIT)\n\t\t\t\t\t| FEATURE_MASK(FEATURE_MEM_VDDCI_SCALING_BIT)\n\t\t\t\t\t| FEATURE_MASK(FEATURE_MEM_MVDD_SCALING_BIT);\n\n\tif (adev->pm.pp_feature & PP_PCIE_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_LINK_BIT);\n\n\tif (adev->pm.pp_feature & PP_DCEFCLK_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_DCEFCLK_BIT);\n\n\tif (adev->pm.pp_feature & PP_SOCCLK_DPM_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DPM_SOCCLK_BIT);\n\n\tif (adev->pm.pp_feature & PP_ULV_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_GFX_ULV_BIT);\n\n\tif (adev->pm.pp_feature & PP_SCLK_DEEP_SLEEP_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DS_GFXCLK_BIT);\n\n\tif (adev->pm.pp_feature & PP_GFXOFF_MASK)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_GFXOFF_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_ATHUB)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_ATHUB_PG_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_MMHUB)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_MMHUB_PG_BIT);\n\n\tif (smu->adev->pg_flags & AMD_PG_SUPPORT_VCN ||\n\t    smu->adev->pg_flags & AMD_PG_SUPPORT_JPEG)\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_MM_DPM_PG_BIT);\n\n\tif (smu->dc_controlled_by_gpio)\n       *(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_ACDC_BIT);\n\n\tif (amdgpu_device_should_use_aspm(adev))\n\t\t*(uint64_t *)feature_mask |= FEATURE_MASK(FEATURE_DS_LCLK_BIT);\n\n\treturn 0;\n}\n\nstatic void sienna_cichlid_check_bxco_support(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_7_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t val;\n\n\tif (powerplay_table->platform_caps & SMU_11_0_7_PP_PLATFORM_CAP_BACO) {\n\t\tval = RREG32_SOC15(NBIO, 0, mmRCC_BIF_STRAP0);\n\t\tsmu_baco->platform_support =\n\t\t\t(val & RCC_BIF_STRAP0__STRAP_PX_CAPABLE_MASK) ? true :\n\t\t\t\t\t\t\t\t\tfalse;\n\n\t\t \n\t\tif (((adev->pdev->device == 0x73A1) &&\n\t\t    (adev->pdev->revision == 0x00)) ||\n\t\t    ((adev->pdev->device == 0x73BF) &&\n\t\t    (adev->pdev->revision == 0xCF)) ||\n\t\t    ((adev->pdev->device == 0x7422) &&\n\t\t    (adev->pdev->revision == 0x00)) ||\n\t\t    ((adev->pdev->device == 0x73A3) &&\n\t\t    (adev->pdev->revision == 0x00)) ||\n\t\t    ((adev->pdev->device == 0x73E3) &&\n\t\t    (adev->pdev->revision == 0x00)))\n\t\t\tsmu_baco->platform_support = false;\n\n\t}\n}\n\nstatic void sienna_cichlid_check_fan_support(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tuint64_t features = *(uint64_t *) pptable->FeaturesToRun;\n\n\t \n\tsmu->adev->pm.no_fan =\n\t\t!(features & (1ULL << FEATURE_FAN_CONTROL_BIT));\n\tif (smu->adev->pm.no_fan)\n\t\tdev_info_once(smu->adev->dev,\n\t\t\t      \"PMFW based fan control disabled\");\n}\n\nstatic int sienna_cichlid_check_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_7_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\n\tif (powerplay_table->platform_caps & SMU_11_0_7_PP_PLATFORM_CAP_HARDWAREDC)\n\t\tsmu->dc_controlled_by_gpio = true;\n\n\tsienna_cichlid_check_bxco_support(smu);\n\tsienna_cichlid_check_fan_support(smu);\n\n\ttable_context->thermal_controller_type =\n\t\tpowerplay_table->thermal_controller_type;\n\n\t \n\tsmu->od_settings = &powerplay_table->overdrive_table;\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_append_powerplay_table(struct smu_context *smu)\n{\n\tstruct atom_smc_dpm_info_v4_9 *smc_dpm_table;\n\tint index, ret;\n\tPPTable_beige_goby_t *ppt_beige_goby;\n\tPPTable_t *ppt;\n\n\tif (smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 13))\n\t\tppt_beige_goby = smu->smu_table.driver_pptable;\n\telse\n\t\tppt = smu->smu_table.driver_pptable;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    smc_dpm_info);\n\n\tret = amdgpu_atombios_get_data_table(smu->adev, index, NULL, NULL, NULL,\n\t\t\t\t      (uint8_t **)&smc_dpm_table);\n\tif (ret)\n\t\treturn ret;\n\n\tif (smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 13))\n\t\tsmu_memcpy_trailing(ppt_beige_goby, I2cControllers, BoardReserved,\n\t\t\t\t    smc_dpm_table, I2cControllers);\n\telse\n\t\tsmu_memcpy_trailing(ppt, I2cControllers, BoardReserved,\n\t\t\t\t    smc_dpm_table, I2cControllers);\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_store_powerplay_table(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_7_powerplay_table *powerplay_table =\n\t\ttable_context->power_play_table;\n\tint table_size;\n\n\ttable_size = get_table_size(smu);\n\tmemcpy(table_context->driver_pptable, &powerplay_table->smc_pptable,\n\t       table_size);\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_patch_pptable_quirk(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t *board_reserved;\n\tuint16_t *freq_table_gfx;\n\tuint32_t i;\n\n\t \n\tGET_PPTABLE_MEMBER(BoardReserved, &board_reserved);\n\tif ((adev->pdev->device == 0x73DF) &&\n\t    (adev->pdev->revision == 0XC3) &&\n\t    (adev->pdev->subsystem_device == 0x16C2) &&\n\t    (adev->pdev->subsystem_vendor == 0x1043))\n\t\tboard_reserved[0] = 1387;\n\n\tGET_PPTABLE_MEMBER(FreqTableGfx, &freq_table_gfx);\n\tif ((adev->pdev->device == 0x73DF) &&\n\t    (adev->pdev->revision == 0XC3) &&\n\t    ((adev->pdev->subsystem_device == 0x16C2) ||\n\t    (adev->pdev->subsystem_device == 0x133C)) &&\n\t    (adev->pdev->subsystem_vendor == 0x1043)) {\n\t\tfor (i = 0; i < NUM_GFXCLK_DPM_LEVELS; i++) {\n\t\t\tif (freq_table_gfx[i] > 2500)\n\t\t\t\tfreq_table_gfx[i] = 2500;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_setup_pptable(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v11_0_setup_pptable(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sienna_cichlid_store_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sienna_cichlid_append_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sienna_cichlid_check_powerplay_table(smu);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sienna_cichlid_patch_pptable_quirk(smu);\n}\n\nstatic int sienna_cichlid_tables_init(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\tint table_size;\n\n\ttable_size = get_table_size(smu);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PPTABLE, table_size,\n\t\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetricsExternal_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_I2C_COMMANDS, sizeof(SwI2cRequest_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_OVERDRIVE, sizeof(OverDriveTable_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_PMSTATUSLOG, SMU11_TOOL_SIZE,\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ACTIVITY_MONITOR_COEFF,\n\t\t       sizeof(DpmActivityMonitorCoeffIntExternal_t), PAGE_SIZE,\n\t               AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_ECCINFO, sizeof(EccInfoTable_t),\n\t\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_DRIVER_SMU_CONFIG, sizeof(DriverSmuConfigExternal_t),\n\t\t       PAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetricsExternal_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err0_out;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v1_3);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err1_out;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->ecc_table = kzalloc(tables[SMU_TABLE_ECCINFO].size, GFP_KERNEL);\n\tif (!smu_table->ecc_table)\n\t\tgoto err3_out;\n\n\tsmu_table->driver_smu_config_table =\n\t\tkzalloc(tables[SMU_TABLE_DRIVER_SMU_CONFIG].size, GFP_KERNEL);\n\tif (!smu_table->driver_smu_config_table)\n\t\tgoto err4_out;\n\n\treturn 0;\n\nerr4_out:\n\tkfree(smu_table->ecc_table);\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->gpu_metrics_table);\nerr1_out:\n\tkfree(smu_table->metrics_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic uint32_t sienna_cichlid_get_throttler_status_locked(struct smu_context *smu,\n\t\t\t\t\t\t\t   bool use_metrics_v3,\n\t\t\t\t\t\t\t   bool use_metrics_v2)\n{\n\tstruct smu_table_context *smu_table= &smu->smu_table;\n\tSmuMetricsExternal_t *metrics_ext =\n\t\t(SmuMetricsExternal_t *)(smu_table->metrics_table);\n\tuint32_t throttler_status = 0;\n\tint i;\n\n\tif (use_metrics_v3) {\n\t\tfor (i = 0; i < THROTTLER_COUNT; i++)\n\t\t\tthrottler_status |=\n\t\t\t\t(metrics_ext->SmuMetrics_V3.ThrottlingPercentage[i] ? 1U << i : 0);\n\t} else if (use_metrics_v2) {\n\t\tfor (i = 0; i < THROTTLER_COUNT; i++)\n\t\t\tthrottler_status |=\n\t\t\t\t(metrics_ext->SmuMetrics_V2.ThrottlingPercentage[i] ? 1U << i : 0);\n\t} else {\n\t\tthrottler_status = metrics_ext->SmuMetrics.ThrottlerStatus;\n\t}\n\n\treturn throttler_status;\n}\n\nstatic int sienna_cichlid_get_power_limit(struct smu_context *smu,\n\t\t\t\t\t  uint32_t *current_power_limit,\n\t\t\t\t\t  uint32_t *default_power_limit,\n\t\t\t\t\t  uint32_t *max_power_limit)\n{\n\tstruct smu_11_0_7_powerplay_table *powerplay_table =\n\t\t(struct smu_11_0_7_powerplay_table *)smu->smu_table.power_play_table;\n\tuint32_t power_limit, od_percent;\n\tuint16_t *table_member;\n\n\tGET_PPTABLE_MEMBER(SocketPowerLimitAc, &table_member);\n\n\tif (smu_v11_0_get_current_power_limit(smu, &power_limit)) {\n\t\tpower_limit =\n\t\t\ttable_member[PPT_THROTTLER_PPT0];\n\t}\n\n\tif (current_power_limit)\n\t\t*current_power_limit = power_limit;\n\tif (default_power_limit)\n\t\t*default_power_limit = power_limit;\n\n\tif (max_power_limit) {\n\t\tif (smu->od_enabled) {\n\t\t\tod_percent =\n\t\t\t\tle32_to_cpu(powerplay_table->overdrive_table.max[\n\t\t\t\t\t\t\tSMU_11_0_7_ODSETTING_POWERPERCENTAGE]);\n\n\t\t\tdev_dbg(smu->adev->dev, \"ODSETTING_POWERPERCENTAGE: %d (default: %d)\\n\",\n\t\t\t\t\tod_percent, power_limit);\n\n\t\t\tpower_limit *= (100 + od_percent);\n\t\t\tpower_limit /= 100;\n\t\t}\n\t\t*max_power_limit = power_limit;\n\t}\n\n\treturn 0;\n}\n\nstatic void sienna_cichlid_get_smartshift_power_percentage(struct smu_context *smu,\n\t\t\t\t\tuint32_t *apu_percent,\n\t\t\t\t\tuint32_t *dgpu_percent)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tSmuMetrics_V4_t *metrics_v4 =\n\t\t&(((SmuMetricsExternal_t *)(smu_table->metrics_table))->SmuMetrics_V4);\n\tuint16_t powerRatio = 0;\n\tuint16_t apu_power_limit = 0;\n\tuint16_t dgpu_power_limit = 0;\n\tuint32_t apu_boost = 0;\n\tuint32_t dgpu_boost = 0;\n\tuint32_t cur_power_limit;\n\n\tif (metrics_v4->ApuSTAPMSmartShiftLimit != 0) {\n\t\tsienna_cichlid_get_power_limit(smu, &cur_power_limit, NULL, NULL);\n\t\tapu_power_limit = metrics_v4->ApuSTAPMLimit;\n\t\tdgpu_power_limit = cur_power_limit;\n\t\tpowerRatio = (((apu_power_limit +\n\t\t\t\t\t\t  dgpu_power_limit) * 100) /\n\t\t\t\t\t\t  metrics_v4->ApuSTAPMSmartShiftLimit);\n\t\tif (powerRatio > 100) {\n\t\t\tapu_power_limit = (apu_power_limit * 100) /\n\t\t\t\t\t\t\t\t\t powerRatio;\n\t\t\tdgpu_power_limit = (dgpu_power_limit * 100) /\n\t\t\t\t\t\t\t\t\t  powerRatio;\n\t\t}\n\t\tif (metrics_v4->AverageApuSocketPower > apu_power_limit &&\n\t\t\t apu_power_limit != 0) {\n\t\t\tapu_boost = ((metrics_v4->AverageApuSocketPower -\n\t\t\t\t\t\t\tapu_power_limit) * 100) /\n\t\t\t\t\t\t\tapu_power_limit;\n\t\t\tif (apu_boost > 100)\n\t\t\t\tapu_boost = 100;\n\t\t}\n\n\t\tif (metrics_v4->AverageSocketPower > dgpu_power_limit &&\n\t\t\t dgpu_power_limit != 0) {\n\t\t\tdgpu_boost = ((metrics_v4->AverageSocketPower -\n\t\t\t\t\t\t\t dgpu_power_limit) * 100) /\n\t\t\t\t\t\t\t dgpu_power_limit;\n\t\t\tif (dgpu_boost > 100)\n\t\t\t\tdgpu_boost = 100;\n\t\t}\n\n\t\tif (dgpu_boost >= apu_boost)\n\t\t\tapu_boost = 0;\n\t\telse\n\t\t\tdgpu_boost = 0;\n\t}\n\t*apu_percent = apu_boost;\n\t*dgpu_percent = dgpu_boost;\n}\n\nstatic int sienna_cichlid_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t       MetricsMember_t member,\n\t\t\t\t\t       uint32_t *value)\n{\n\tstruct smu_table_context *smu_table= &smu->smu_table;\n\tSmuMetrics_t *metrics =\n\t\t&(((SmuMetricsExternal_t *)(smu_table->metrics_table))->SmuMetrics);\n\tSmuMetrics_V2_t *metrics_v2 =\n\t\t&(((SmuMetricsExternal_t *)(smu_table->metrics_table))->SmuMetrics_V2);\n\tSmuMetrics_V3_t *metrics_v3 =\n\t\t&(((SmuMetricsExternal_t *)(smu_table->metrics_table))->SmuMetrics_V3);\n\tbool use_metrics_v2 = false;\n\tbool use_metrics_v3 = false;\n\tuint16_t average_gfx_activity;\n\tint ret = 0;\n\tuint32_t apu_percent = 0;\n\tuint32_t dgpu_percent = 0;\n\n\tswitch (smu->adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 7):\n\t\tif (smu->smc_fw_version >= 0x3A4900)\n\t\t\tuse_metrics_v3 = true;\n\t\telse if (smu->smc_fw_version >= 0x3A4300)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 11):\n\t\tif (smu->smc_fw_version >= 0x412D00)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 12):\n\t\tif (smu->smc_fw_version >= 0x3B2300)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 13):\n\t\tif (smu->smc_fw_version >= 0x491100)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_CURR_GFXCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_GFXCLK] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_GFXCLK] :\n\t\t\tmetrics->CurrClock[PPCLK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_CURR_SOCCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_SOCCLK] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_SOCCLK] :\n\t\t\tmetrics->CurrClock[PPCLK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_CURR_UCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_UCLK] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_UCLK] :\n\t\t\tmetrics->CurrClock[PPCLK_UCLK];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_VCLK_0] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_VCLK_0] :\n\t\t\tmetrics->CurrClock[PPCLK_VCLK_0];\n\t\tbreak;\n\tcase METRICS_CURR_VCLK1:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_VCLK_1] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_VCLK_1] :\n\t\t\tmetrics->CurrClock[PPCLK_VCLK_1];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_DCLK_0] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_DCLK_0] :\n\t\t\tmetrics->CurrClock[PPCLK_DCLK_0];\n\t\tbreak;\n\tcase METRICS_CURR_DCLK1:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_DCLK_1] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_DCLK_1] :\n\t\t\tmetrics->CurrClock[PPCLK_DCLK_1];\n\t\tbreak;\n\tcase METRICS_CURR_DCEFCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_DCEFCLK] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_DCEFCLK] :\n\t\t\tmetrics->CurrClock[PPCLK_DCEFCLK];\n\t\tbreak;\n\tcase METRICS_CURR_FCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_FCLK] :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_FCLK] :\n\t\t\tmetrics->CurrClock[PPCLK_FCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\taverage_gfx_activity = use_metrics_v3 ? metrics_v3->AverageGfxActivity :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageGfxActivity :\n\t\t\tmetrics->AverageGfxActivity;\n\t\tif (average_gfx_activity <= SMU_11_0_7_GFX_BUSY_THRESHOLD)\n\t\t\t*value = use_metrics_v3 ? metrics_v3->AverageGfxclkFrequencyPostDs :\n\t\t\t\tuse_metrics_v2 ? metrics_v2->AverageGfxclkFrequencyPostDs :\n\t\t\t\tmetrics->AverageGfxclkFrequencyPostDs;\n\t\telse\n\t\t\t*value = use_metrics_v3 ? metrics_v3->AverageGfxclkFrequencyPreDs :\n\t\t\t\tuse_metrics_v2 ? metrics_v2->AverageGfxclkFrequencyPreDs :\n\t\t\t\tmetrics->AverageGfxclkFrequencyPreDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_FCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->AverageFclkFrequencyPostDs :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageFclkFrequencyPostDs :\n\t\t\tmetrics->AverageFclkFrequencyPostDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = use_metrics_v3 ? metrics_v3->AverageUclkFrequencyPostDs :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageUclkFrequencyPostDs :\n\t\t\tmetrics->AverageUclkFrequencyPostDs;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = use_metrics_v3 ? metrics_v3->AverageGfxActivity :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageGfxActivity :\n\t\t\tmetrics->AverageGfxActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_MEMACTIVITY:\n\t\t*value = use_metrics_v3 ? metrics_v3->AverageUclkActivity :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageUclkActivity :\n\t\t\tmetrics->AverageUclkActivity;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCKETPOWER:\n\t\t*value = use_metrics_v3 ? metrics_v3->AverageSocketPower << 8 :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageSocketPower << 8 :\n\t\t\tmetrics->AverageSocketPower << 8;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = (use_metrics_v3 ? metrics_v3->TemperatureEdge :\n\t\t\tuse_metrics_v2 ? metrics_v2->TemperatureEdge :\n\t\t\tmetrics->TemperatureEdge) * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = (use_metrics_v3 ? metrics_v3->TemperatureHotspot :\n\t\t\tuse_metrics_v2 ? metrics_v2->TemperatureHotspot :\n\t\t\tmetrics->TemperatureHotspot) * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_MEM:\n\t\t*value = (use_metrics_v3 ? metrics_v3->TemperatureMem :\n\t\t\tuse_metrics_v2 ? metrics_v2->TemperatureMem :\n\t\t\tmetrics->TemperatureMem) * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRGFX:\n\t\t*value = (use_metrics_v3 ? metrics_v3->TemperatureVrGfx :\n\t\t\tuse_metrics_v2 ? metrics_v2->TemperatureVrGfx :\n\t\t\tmetrics->TemperatureVrGfx) * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_VRSOC:\n\t\t*value = (use_metrics_v3 ? metrics_v3->TemperatureVrSoc :\n\t\t\tuse_metrics_v2 ? metrics_v2->TemperatureVrSoc :\n\t\t\tmetrics->TemperatureVrSoc) * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = sienna_cichlid_get_throttler_status_locked(smu, use_metrics_v3, use_metrics_v2);\n\t\tbreak;\n\tcase METRICS_CURR_FANSPEED:\n\t\t*value = use_metrics_v3 ? metrics_v3->CurrFanSpeed :\n\t\t\tuse_metrics_v2 ? metrics_v2->CurrFanSpeed : metrics->CurrFanSpeed;\n\t\tbreak;\n\tcase METRICS_UNIQUE_ID_UPPER32:\n\t\t \n\t\t*value = use_metrics_v3 ? metrics_v3->PublicSerialNumUpper32 : 0;\n\t\tbreak;\n\tcase METRICS_UNIQUE_ID_LOWER32:\n\t\t \n\t\t*value = use_metrics_v3 ? metrics_v3->PublicSerialNumLower32 : 0;\n\t\tbreak;\n\tcase METRICS_SS_APU_SHARE:\n\t\tsienna_cichlid_get_smartshift_power_percentage(smu, &apu_percent, &dgpu_percent);\n\t\t*value = apu_percent;\n\t\tbreak;\n\tcase METRICS_SS_DGPU_SHARE:\n\t\tsienna_cichlid_get_smartshift_power_percentage(smu, &apu_percent, &dgpu_percent);\n\t\t*value = dgpu_percent;\n\t\tbreak;\n\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n\n}\n\nstatic int sienna_cichlid_allocate_dpm_context(struct smu_context *smu)\n{\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tsmu_dpm->dpm_context = kzalloc(sizeof(struct smu_11_0_dpm_context),\n\t\t\t\t       GFP_KERNEL);\n\tif (!smu_dpm->dpm_context)\n\t\treturn -ENOMEM;\n\n\tsmu_dpm->dpm_context_size = sizeof(struct smu_11_0_dpm_context);\n\n\treturn 0;\n}\n\nstatic void sienna_cichlid_stb_init(struct smu_context *smu);\n\nstatic int sienna_cichlid_init_smc_tables(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tret = sienna_cichlid_tables_init(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sienna_cichlid_allocate_dpm_context(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!amdgpu_sriov_vf(adev))\n\t\tsienna_cichlid_stb_init(smu);\n\n\treturn smu_v11_0_init_smc_tables(smu);\n}\n\nstatic int sienna_cichlid_set_default_dpm_table(struct smu_context *smu)\n{\n\tstruct smu_11_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_11_0_dpm_table *dpm_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i, ret = 0;\n\tDpmDescriptor_t *table_member;\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.soc_table;\n\tGET_PPTABLE_MEMBER(DpmDescriptor, &table_member);\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_SOCCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_SOCCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.socclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.gfx_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFXCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_GFXCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_GFXCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.gfxclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.uclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_UCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_UCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.uclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.fclk_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_FCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_FCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_FCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.fclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\tcontinue;\n\n\t\tdpm_table = &dpm_context->dpm_tables.vclk_table;\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_MM_DPM_PG_BIT)) {\n\t\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t\t     i ? SMU_VCLK1 : SMU_VCLK,\n\t\t\t\t\t\t\t     dpm_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdpm_table->is_fine_grained =\n\t\t\t\t!table_member[i ? PPCLK_VCLK_1 : PPCLK_VCLK_0].SnapToDiscrete;\n\t\t} else {\n\t\t\tdpm_table->count = 1;\n\t\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.vclk / 100;\n\t\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\tcontinue;\n\t\tdpm_table = &dpm_context->dpm_tables.dclk_table;\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_MM_DPM_PG_BIT)) {\n\t\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t\t     i ? SMU_DCLK1 : SMU_DCLK,\n\t\t\t\t\t\t\t     dpm_table);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdpm_table->is_fine_grained =\n\t\t\t\t!table_member[i ? PPCLK_DCLK_1 : PPCLK_DCLK_0].SnapToDiscrete;\n\t\t} else {\n\t\t\tdpm_table->count = 1;\n\t\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dclk / 100;\n\t\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t\t}\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.dcef_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_DCEFCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_DCEFCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.pixel_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_PIXCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_PIXCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.display_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_DISPCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_DISPCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\t \n\tdpm_table = &dpm_context->dpm_tables.phy_table;\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_set_single_dpm_table(smu,\n\t\t\t\t\t\t     SMU_PHYCLK,\n\t\t\t\t\t\t     dpm_table);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdpm_table->is_fine_grained =\n\t\t\t!table_member[PPCLK_PHYCLK].SnapToDiscrete;\n\t} else {\n\t\tdpm_table->count = 1;\n\t\tdpm_table->dpm_levels[0].value = smu->smu_table.boot_values.dcefclk / 100;\n\t\tdpm_table->dpm_levels[0].enabled = true;\n\t\tdpm_table->min = dpm_table->dpm_levels[0].value;\n\t\tdpm_table->max = dpm_table->dpm_levels[0].value;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_dpm_set_vcn_enable(struct smu_context *smu, bool enable)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < adev->vcn.num_vcn_inst; i++) {\n\t\tif (adev->vcn.harvest_config & (1 << i))\n\t\t\tcontinue;\n\t\t \n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_MM_DPM_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, enable ?\n\t\t\t\t\t\t\t      SMU_MSG_PowerUpVcn : SMU_MSG_PowerDownVcn,\n\t\t\t\t\t\t\t      0x10000 * i, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sienna_cichlid_dpm_set_jpeg_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_MM_DPM_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpJpeg, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_MM_DPM_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerDownJpeg, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sienna_cichlid_get_current_clk_freq_by_table(struct smu_context *smu,\n\t\t\t\t       enum smu_clk_type clk_type,\n\t\t\t\t       uint32_t *value)\n{\n\tMetricsMember_t member_type;\n\tint clk_id = 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tswitch (clk_id) {\n\tcase PPCLK_GFXCLK:\n\t\tmember_type = METRICS_CURR_GFXCLK;\n\t\tbreak;\n\tcase PPCLK_UCLK:\n\t\tmember_type = METRICS_CURR_UCLK;\n\t\tbreak;\n\tcase PPCLK_SOCCLK:\n\t\tmember_type = METRICS_CURR_SOCCLK;\n\t\tbreak;\n\tcase PPCLK_FCLK:\n\t\tmember_type = METRICS_CURR_FCLK;\n\t\tbreak;\n\tcase PPCLK_VCLK_0:\n\t\tmember_type = METRICS_CURR_VCLK;\n\t\tbreak;\n\tcase PPCLK_VCLK_1:\n\t\tmember_type = METRICS_CURR_VCLK1;\n\t\tbreak;\n\tcase PPCLK_DCLK_0:\n\t\tmember_type = METRICS_CURR_DCLK;\n\t\tbreak;\n\tcase PPCLK_DCLK_1:\n\t\tmember_type = METRICS_CURR_DCLK1;\n\t\tbreak;\n\tcase PPCLK_DCEFCLK:\n\t\tmember_type = METRICS_CURR_DCEFCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   member_type,\n\t\t\t\t\t\t   value);\n\n}\n\nstatic bool sienna_cichlid_is_support_fine_grained_dpm(struct smu_context *smu, enum smu_clk_type clk_type)\n{\n\tDpmDescriptor_t *dpm_desc = NULL;\n\tDpmDescriptor_t *table_member;\n\tuint32_t clk_index = 0;\n\n\tGET_PPTABLE_MEMBER(DpmDescriptor, &table_member);\n\tclk_index = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t   CMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\t   clk_type);\n\tdpm_desc = &table_member[clk_index];\n\n\t \n\treturn dpm_desc->SnapToDiscrete == 0;\n}\n\nstatic bool sienna_cichlid_is_od_feature_supported(struct smu_11_0_7_overdrive_table *od_table,\n\t\t\t\t\t\t   enum SMU_11_0_7_ODFEATURE_CAP cap)\n{\n\treturn od_table->cap[cap];\n}\n\nstatic void sienna_cichlid_get_od_setting_range(struct smu_11_0_7_overdrive_table *od_table,\n\t\t\t\t\t\tenum SMU_11_0_7_ODSETTING_ID setting,\n\t\t\t\t\t\tuint32_t *min, uint32_t *max)\n{\n\tif (min)\n\t\t*min = od_table->min[setting];\n\tif (max)\n\t\t*max = od_table->max[setting];\n}\n\nstatic int sienna_cichlid_print_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\tstruct smu_11_0_dpm_context *dpm_context = smu_dpm->dpm_context;\n\tuint16_t *table_member;\n\n\tstruct smu_11_0_7_overdrive_table *od_settings = smu->od_settings;\n\tOverDriveTable_t *od_table =\n\t\t(OverDriveTable_t *)table_context->overdrive_table;\n\tint i, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0;\n\tuint32_t freq_values[3] = {0};\n\tuint32_t mark_index = 0;\n\tuint32_t gen_speed, lane_width;\n\tuint32_t min_value, max_value;\n\tuint32_t smu_version;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_VCLK1:\n\tcase SMU_DCLK:\n\tcase SMU_DCLK1:\n\tcase SMU_DCEFCLK:\n\t\tret = sienna_cichlid_get_current_clk_freq_by_table(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\tgoto print_clk_out;\n\n\t\tret = smu_v11_0_get_dpm_level_count(smu, clk_type, &count);\n\t\tif (ret)\n\t\t\tgoto print_clk_out;\n\n\t\tif (!sienna_cichlid_is_support_fine_grained_dpm(smu, clk_type)) {\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, i, &value);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto print_clk_out;\n\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, 0, &freq_values[0]);\n\t\t\tif (ret)\n\t\t\t\tgoto print_clk_out;\n\t\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, count - 1, &freq_values[2]);\n\t\t\tif (ret)\n\t\t\t\tgoto print_clk_out;\n\n\t\t\tfreq_values[1] = cur_value;\n\t\t\tmark_index = cur_value == freq_values[0] ? 0 :\n\t\t\t\t     cur_value == freq_values[2] ? 2 : 1;\n\n\t\t\tcount = 3;\n\t\t\tif (mark_index != 1) {\n\t\t\t\tcount = 2;\n\t\t\t\tfreq_values[1] = freq_values[2];\n\t\t\t}\n\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, freq_values[i],\n\t\t\t\t\t\tcur_value  == freq_values[i] ? \"*\" : \"\");\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\tcase SMU_PCIE:\n\t\tgen_speed = smu_v11_0_get_current_pcie_link_speed_level(smu);\n\t\tlane_width = smu_v11_0_get_current_pcie_link_width_level(smu);\n\t\tGET_PPTABLE_MEMBER(LclkFreq, &table_member);\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %s %s %dMhz %s\\n\", i,\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_gen[i] == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 1) ? \"x1\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 2) ? \"x2\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 3) ? \"x4\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 4) ? \"x8\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 5) ? \"x12\" :\n\t\t\t\t\t(dpm_context->dpm_tables.pcie_table.pcie_lane[i] == 6) ? \"x16\" : \"\",\n\t\t\t\t\ttable_member[i],\n\t\t\t\t\t(gen_speed == dpm_context->dpm_tables.pcie_table.pcie_gen[i]) &&\n\t\t\t\t\t(lane_width == dpm_context->dpm_tables.pcie_table.pcie_lane[i]) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\tbreak;\n\tcase SMU_OD_SCLK:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\n\t\tif (!sienna_cichlid_is_od_feature_supported(od_settings, SMU_11_0_7_ODCAP_GFXCLK_LIMITS))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"OD_SCLK:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n1: %uMhz\\n\", od_table->GfxclkFmin, od_table->GfxclkFmax);\n\t\tbreak;\n\n\tcase SMU_OD_MCLK:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\n\t\tif (!sienna_cichlid_is_od_feature_supported(od_settings, SMU_11_0_7_ODCAP_UCLK_LIMITS))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"OD_MCLK:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz\\n1: %uMHz\\n\", od_table->UclkFmin, od_table->UclkFmax);\n\t\tbreak;\n\n\tcase SMU_OD_VDDGFX_OFFSET:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\n\t\t \n\t\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\t\tif ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 7)) &&\n\t\t     (smu_version < 0x003a2900))\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"OD_VDDGFX_OFFSET:\\n\");\n\t\tsize += sysfs_emit_at(buf, size, \"%dmV\\n\", od_table->VddGfxOffset);\n\t\tbreak;\n\n\tcase SMU_OD_RANGE:\n\t\tif (!smu->od_enabled || !od_table || !od_settings)\n\t\t\tbreak;\n\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\n\t\tif (sienna_cichlid_is_od_feature_supported(od_settings, SMU_11_0_7_ODCAP_GFXCLK_LIMITS)) {\n\t\t\tsienna_cichlid_get_od_setting_range(od_settings, SMU_11_0_7_ODSETTING_GFXCLKFMIN,\n\t\t\t\t\t\t\t    &min_value, NULL);\n\t\t\tsienna_cichlid_get_od_setting_range(od_settings, SMU_11_0_7_ODSETTING_GFXCLKFMAX,\n\t\t\t\t\t\t\t    NULL, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\tmin_value, max_value);\n\t\t}\n\n\t\tif (sienna_cichlid_is_od_feature_supported(od_settings, SMU_11_0_7_ODCAP_UCLK_LIMITS)) {\n\t\t\tsienna_cichlid_get_od_setting_range(od_settings, SMU_11_0_7_ODSETTING_UCLKFMIN,\n\t\t\t\t\t\t\t    &min_value, NULL);\n\t\t\tsienna_cichlid_get_od_setting_range(od_settings, SMU_11_0_7_ODSETTING_UCLKFMAX,\n\t\t\t\t\t\t\t    NULL, &max_value);\n\t\t\tsize += sysfs_emit_at(buf, size, \"MCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\tmin_value, max_value);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\nprint_clk_out:\n\treturn size;\n}\n\nstatic int sienna_cichlid_force_clk_levels(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type, uint32_t mask)\n{\n\tint ret = 0;\n\tuint32_t soft_min_level = 0, soft_max_level = 0, min_freq = 0, max_freq = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\t\t \n\t\tif (sienna_cichlid_is_support_fine_grained_dpm(smu, clk_type)) {\n\t\t\tsoft_max_level = (soft_max_level >= 1 ? 1 : 0);\n\t\t\tsoft_min_level = (soft_min_level >= 1 ? 1 : 0);\n\t\t}\n\n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\tgoto forec_level_out;\n\n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu, clk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\tgoto forec_level_out;\n\n\t\tret = smu_v11_0_set_soft_freq_limited_range(smu, clk_type, min_freq, max_freq);\n\t\tif (ret)\n\t\t\tgoto forec_level_out;\n\t\tbreak;\n\tcase SMU_DCEFCLK:\n\t\tdev_info(smu->adev->dev,\"Setting DCEFCLK min/max dpm level is not supported!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nforec_level_out:\n\treturn 0;\n}\n\nstatic int sienna_cichlid_populate_umd_state_clk(struct smu_context *smu)\n{\n\tstruct smu_11_0_dpm_context *dpm_context =\n\t\t\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_11_0_dpm_table *gfx_table =\n\t\t\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_11_0_dpm_table *mem_table =\n\t\t\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_11_0_dpm_table *soc_table =\n\t\t\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_umd_pstate_table *pstate_table =\n\t\t\t\t&smu->pstate_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tpstate_table->gfxclk_pstate.min = gfx_table->min;\n\tpstate_table->gfxclk_pstate.peak = gfx_table->max;\n\n\tpstate_table->uclk_pstate.min = mem_table->min;\n\tpstate_table->uclk_pstate.peak = mem_table->max;\n\n\tpstate_table->socclk_pstate.min = soc_table->min;\n\tpstate_table->socclk_pstate.peak = soc_table->max;\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 11):\n\t\tpstate_table->gfxclk_pstate.standard = SIENNA_CICHLID_UMD_PSTATE_PROFILING_GFXCLK;\n\t\tpstate_table->uclk_pstate.standard = SIENNA_CICHLID_UMD_PSTATE_PROFILING_MEMCLK;\n\t\tpstate_table->socclk_pstate.standard = SIENNA_CICHLID_UMD_PSTATE_PROFILING_SOCCLK;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 12):\n\t\tpstate_table->gfxclk_pstate.standard = DIMGREY_CAVEFISH_UMD_PSTATE_PROFILING_GFXCLK;\n\t\tpstate_table->uclk_pstate.standard = DIMGREY_CAVEFISH_UMD_PSTATE_PROFILING_MEMCLK;\n\t\tpstate_table->socclk_pstate.standard = DIMGREY_CAVEFISH_UMD_PSTATE_PROFILING_SOCCLK;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 13):\n\t\tpstate_table->gfxclk_pstate.standard = BEIGE_GOBY_UMD_PSTATE_PROFILING_GFXCLK;\n\t\tpstate_table->uclk_pstate.standard = BEIGE_GOBY_UMD_PSTATE_PROFILING_MEMCLK;\n\t\tpstate_table->socclk_pstate.standard = BEIGE_GOBY_UMD_PSTATE_PROFILING_SOCCLK;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_pre_display_config_changed(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint32_t max_freq = 0;\n\n\t \n\treturn 0;\n#if 0\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n#endif\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_get_dpm_ultimate_freq(smu, SMU_UCLK, NULL, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, 0, max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int sienna_cichlid_display_config_changed(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) &&\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n#if 0\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_NumOfDisplays,\n\t\t\t\t\t\t  smu->display_config->num_display,\n\t\t\t\t\t\t  NULL);\n#endif\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic bool sienna_cichlid_is_dpm_running(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int sienna_cichlid_get_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\t\t    uint32_t *speed)\n{\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\t \n\treturn sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t   METRICS_CURR_FANSPEED,\n\t\t\t\t\t\t   speed);\n}\n\nstatic int sienna_cichlid_get_fan_parameters(struct smu_context *smu)\n{\n\tuint16_t *table_member;\n\n\tGET_PPTABLE_MEMBER(FanMaximumRpm, &table_member);\n\tsmu->fan_max_rpm = *table_member;\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_get_power_profile_mode(struct smu_context *smu, char *buf)\n{\n\tDpmActivityMonitorCoeffIntExternal_t activity_monitor_external;\n\tDpmActivityMonitorCoeffInt_t *activity_monitor =\n\t\t&(activity_monitor_external.DpmActivityMonitorCoeffInt);\n\tuint32_t i, size = 0;\n\tint16_t workload_type = 0;\n\tstatic const char *title[] = {\n\t\t\t\"PROFILE_INDEX(NAME)\",\n\t\t\t\"CLOCK_TYPE(NAME)\",\n\t\t\t\"FPS\",\n\t\t\t\"MinFreqType\",\n\t\t\t\"MinActiveFreqType\",\n\t\t\t\"MinActiveFreq\",\n\t\t\t\"BoosterFreqType\",\n\t\t\t\"BoosterFreq\",\n\t\t\t\"PD_Data_limit_c\",\n\t\t\t\"PD_Data_error_coeff\",\n\t\t\t\"PD_Data_error_rate_coeff\"};\n\tint result = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tsize += sysfs_emit_at(buf, size, \"%16s %s %s %s %s %s %s %s %s %s %s\\n\",\n\t\t\ttitle[0], title[1], title[2], title[3], title[4], title[5],\n\t\t\ttitle[6], title[7], title[8], title[9], title[10]);\n\n\tfor (i = 0; i <= PP_SMC_POWER_PROFILE_CUSTOM; i++) {\n\t\t \n\t\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t\t       i);\n\t\tif (workload_type < 0)\n\t\t\treturn -EINVAL;\n\n\t\tresult = smu_cmn_update_table(smu,\n\t\t\t\t\t  SMU_TABLE_ACTIVITY_MONITOR_COEFF, workload_type,\n\t\t\t\t\t  (void *)(&activity_monitor_external), false);\n\t\tif (result) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn result;\n\t\t}\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s:\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == smu->power_profile_mode) ? \"*\" : \" \");\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t0,\n\t\t\t\"GFXCLK\",\n\t\t\tactivity_monitor->Gfx_FPS,\n\t\t\tactivity_monitor->Gfx_MinFreqStep,\n\t\t\tactivity_monitor->Gfx_MinActiveFreqType,\n\t\t\tactivity_monitor->Gfx_MinActiveFreq,\n\t\t\tactivity_monitor->Gfx_BoosterFreqType,\n\t\t\tactivity_monitor->Gfx_BoosterFreq,\n\t\t\tactivity_monitor->Gfx_PD_Data_limit_c,\n\t\t\tactivity_monitor->Gfx_PD_Data_error_coeff,\n\t\t\tactivity_monitor->Gfx_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t1,\n\t\t\t\"SOCCLK\",\n\t\t\tactivity_monitor->Fclk_FPS,\n\t\t\tactivity_monitor->Fclk_MinFreqStep,\n\t\t\tactivity_monitor->Fclk_MinActiveFreqType,\n\t\t\tactivity_monitor->Fclk_MinActiveFreq,\n\t\t\tactivity_monitor->Fclk_BoosterFreqType,\n\t\t\tactivity_monitor->Fclk_BoosterFreq,\n\t\t\tactivity_monitor->Fclk_PD_Data_limit_c,\n\t\t\tactivity_monitor->Fclk_PD_Data_error_coeff,\n\t\t\tactivity_monitor->Fclk_PD_Data_error_rate_coeff);\n\n\t\tsize += sysfs_emit_at(buf, size, \"%19s %d(%13s) %7d %7d %7d %7d %7d %7d %7d %7d %7d\\n\",\n\t\t\t\" \",\n\t\t\t2,\n\t\t\t\"MEMLK\",\n\t\t\tactivity_monitor->Mem_FPS,\n\t\t\tactivity_monitor->Mem_MinFreqStep,\n\t\t\tactivity_monitor->Mem_MinActiveFreqType,\n\t\t\tactivity_monitor->Mem_MinActiveFreq,\n\t\t\tactivity_monitor->Mem_BoosterFreqType,\n\t\t\tactivity_monitor->Mem_BoosterFreq,\n\t\t\tactivity_monitor->Mem_PD_Data_limit_c,\n\t\t\tactivity_monitor->Mem_PD_Data_error_coeff,\n\t\t\tactivity_monitor->Mem_PD_Data_error_rate_coeff);\n\t}\n\n\treturn size;\n}\n\nstatic int sienna_cichlid_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)\n{\n\n\tDpmActivityMonitorCoeffIntExternal_t activity_monitor_external;\n\tDpmActivityMonitorCoeffInt_t *activity_monitor =\n\t\t&(activity_monitor_external.DpmActivityMonitorCoeffInt);\n\tint workload_type, ret = 0;\n\n\tsmu->power_profile_mode = input[size];\n\n\tif (smu->power_profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tdev_err(smu->adev->dev, \"Invalid power profile mode %d\\n\", smu->power_profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (smu->power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {\n\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t       (void *)(&activity_monitor_external), false);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to get activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (input[0]) {\n\t\tcase 0:  \n\t\t\tactivity_monitor->Gfx_FPS = input[1];\n\t\t\tactivity_monitor->Gfx_MinFreqStep = input[2];\n\t\t\tactivity_monitor->Gfx_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor->Gfx_MinActiveFreq = input[4];\n\t\t\tactivity_monitor->Gfx_BoosterFreqType = input[5];\n\t\t\tactivity_monitor->Gfx_BoosterFreq = input[6];\n\t\t\tactivity_monitor->Gfx_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor->Gfx_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor->Gfx_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tactivity_monitor->Fclk_FPS = input[1];\n\t\t\tactivity_monitor->Fclk_MinFreqStep = input[2];\n\t\t\tactivity_monitor->Fclk_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor->Fclk_MinActiveFreq = input[4];\n\t\t\tactivity_monitor->Fclk_BoosterFreqType = input[5];\n\t\t\tactivity_monitor->Fclk_BoosterFreq = input[6];\n\t\t\tactivity_monitor->Fclk_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor->Fclk_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor->Fclk_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tactivity_monitor->Mem_FPS = input[1];\n\t\t\tactivity_monitor->Mem_MinFreqStep = input[2];\n\t\t\tactivity_monitor->Mem_MinActiveFreqType = input[3];\n\t\t\tactivity_monitor->Mem_MinActiveFreq = input[4];\n\t\t\tactivity_monitor->Mem_BoosterFreqType = input[5];\n\t\t\tactivity_monitor->Mem_BoosterFreq = input[6];\n\t\t\tactivity_monitor->Mem_PD_Data_limit_c = input[7];\n\t\t\tactivity_monitor->Mem_PD_Data_error_coeff = input[8];\n\t\t\tactivity_monitor->Mem_PD_Data_error_rate_coeff = input[9];\n\t\t\tbreak;\n\t\t}\n\n\t\tret = smu_cmn_update_table(smu,\n\t\t\t\t       SMU_TABLE_ACTIVITY_MONITOR_COEFF, WORKLOAD_PPLIB_CUSTOM_BIT,\n\t\t\t\t       (void *)(&activity_monitor_external), true);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Failed to set activity monitor!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t       smu->power_profile_mode);\n\tif (workload_type < 0)\n\t\treturn -EINVAL;\n\tsmu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetWorkloadMask,\n\t\t\t\t    1 << workload_type, NULL);\n\n\treturn ret;\n}\n\nstatic int sienna_cichlid_notify_smc_display_config(struct smu_context *smu)\n{\n\tstruct smu_clocks min_clocks = {0};\n\tstruct pp_display_clock_request clock_req;\n\tint ret = 0;\n\n\tmin_clocks.dcef_clock = smu->display_config->min_dcef_set_clk;\n\tmin_clocks.dcef_clock_in_sr = smu->display_config->min_dcef_deep_sleep_set_clk;\n\tmin_clocks.memory_clock = smu->display_config->min_mem_set_clock;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tclock_req.clock_type = amd_pp_dcef_clock;\n\t\tclock_req.clock_freq_in_khz = min_clocks.dcef_clock * 10;\n\n\t\tret = smu_v11_0_display_clock_voltage_request(smu, &clock_req);\n\t\tif (!ret) {\n\t\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DS_DCEFCLK_BIT)) {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t  SMU_MSG_SetMinDeepSleepDcefclk,\n\t\t\t\t\t\t\t\t  min_clocks.dcef_clock_in_sr/100,\n\t\t\t\t\t\t\t\t  NULL);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(smu->adev->dev, \"Attempt to set divider for DCEFCLK Failed!\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(smu->adev->dev, \"Attempt to set Hard Min for DCEFCLK Failed!\");\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, min_clocks.memory_clock/100, 0);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] Set hard min uclk failed!\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_set_watermarks_table(struct smu_context *smu,\n\t\t\t\t\t       struct pp_smu_wm_range_sets *clock_ranges)\n{\n\tWatermarks_t *table = smu->smu_table.watermarks_table;\n\tint ret = 0;\n\tint i;\n\n\tif (clock_ranges) {\n\t\tif (clock_ranges->num_reader_wm_sets > NUM_WM_RANGES ||\n\t\t    clock_ranges->num_writer_wm_sets > NUM_WM_RANGES)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < clock_ranges->num_reader_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MinClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MaxClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MinUclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].MaxUclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_fill_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_DCEFCLK][i].WmSetting =\n\t\t\t\tclock_ranges->reader_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tfor (i = 0; i < clock_ranges->num_writer_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinUclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxUclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_drain_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmSetting =\n\t\t\t\tclock_ranges->writer_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tsmu->watermarks_bitmap |= WATERMARKS_EXIST;\n\t}\n\n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t     !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {\n\t\tret = smu_cmn_write_watermarks_table(smu);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to update WMTABLE!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsmu->watermarks_bitmap |= WATERMARKS_LOADED;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_read_sensor(struct smu_context *smu,\n\t\t\t\t enum amd_pp_sensors sensor,\n\t\t\t\t void *data, uint32_t *size)\n{\n\tint ret = 0;\n\tuint16_t *temp;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif(!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_MAX_FAN_RPM:\n\t\tGET_PPTABLE_MEMBER(FanMaximumRpm, &temp);\n\t\t*(uint16_t *)data = *temp;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_LOAD:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_AVERAGE_MEMACTIVITY,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_AVERAGE_SOCKETPOWER,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_TEMPERATURE_MEM,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_CURR_UCLK,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t  METRICS_AVERAGE_GFXCLK,\n\t\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = smu_v11_0_get_gfx_vdd(smu, (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_APU_SHARE:\n\t\tif (adev->ip_versions[MP1_HWIP][0] != IP_VERSION(11, 0, 7)) {\n\t\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\tMETRICS_SS_APU_SHARE, (uint32_t *)data);\n\t\t\t*size = 4;\n\t\t} else {\n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_DGPU_SHARE:\n\t\tif (adev->ip_versions[MP1_HWIP][0] != IP_VERSION(11, 0, 7)) {\n\t\t\tret = sienna_cichlid_get_smu_metrics_data(smu,\n\t\t\t\t\t\tMETRICS_SS_DGPU_SHARE, (uint32_t *)data);\n\t\t\t*size = 4;\n\t\t} else {\n\t\t\tret = -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void sienna_cichlid_get_unique_id(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t upper32 = 0, lower32 = 0;\n\n\t \n\tif (smu->smc_fw_version < 0x3A5300 ||\n\t    smu->adev->ip_versions[MP1_HWIP][0] != IP_VERSION(11, 0, 7))\n\t\treturn;\n\n\tif (sienna_cichlid_get_smu_metrics_data(smu, METRICS_UNIQUE_ID_UPPER32, &upper32))\n\t\tgoto out;\n\tif (sienna_cichlid_get_smu_metrics_data(smu, METRICS_UNIQUE_ID_LOWER32, &lower32))\n\t\tgoto out;\n\nout:\n\n\tadev->unique_id = ((uint64_t)upper32 << 32) | lower32;\n\tif (adev->serial[0] == '\\0')\n\t\tsprintf(adev->serial, \"%016llx\", adev->unique_id);\n}\n\nstatic int sienna_cichlid_get_uclk_dpm_states(struct smu_context *smu, uint32_t *clocks_in_khz, uint32_t *num_states)\n{\n\tuint32_t num_discrete_levels = 0;\n\tuint16_t *dpm_levels = NULL;\n\tuint16_t i = 0;\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tDpmDescriptor_t *table_member1;\n\tuint16_t *table_member2;\n\n\tif (!clocks_in_khz || !num_states || !table_context->driver_pptable)\n\t\treturn -EINVAL;\n\n\tGET_PPTABLE_MEMBER(DpmDescriptor, &table_member1);\n\tnum_discrete_levels = table_member1[PPCLK_UCLK].NumDiscreteLevels;\n\tGET_PPTABLE_MEMBER(FreqTableUclk, &table_member2);\n\tdpm_levels = table_member2;\n\n\tif (num_discrete_levels == 0 || dpm_levels == NULL)\n\t\treturn -EINVAL;\n\n\t*num_states = num_discrete_levels;\n\tfor (i = 0; i < num_discrete_levels; i++) {\n\t\t \n\t\t*clocks_in_khz = (*dpm_levels) * 1000;\n\t\tclocks_in_khz++;\n\t\tdpm_levels++;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_get_thermal_temperature_range(struct smu_context *smu,\n\t\t\t\t\t\tstruct smu_temperature_range *range)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_7_powerplay_table *powerplay_table =\n\t\t\t\ttable_context->power_play_table;\n\tuint16_t *table_member;\n\tuint16_t temp_edge, temp_hotspot, temp_mem;\n\n\tif (!range)\n\t\treturn -EINVAL;\n\n\tmemcpy(range, &smu11_thermal_policy[0], sizeof(struct smu_temperature_range));\n\n\tGET_PPTABLE_MEMBER(TemperatureLimit, &table_member);\n\ttemp_edge = table_member[TEMP_EDGE];\n\ttemp_hotspot = table_member[TEMP_HOTSPOT];\n\ttemp_mem = table_member[TEMP_MEM];\n\n\trange->max = temp_edge * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->edge_emergency_max = (temp_edge + CTF_OFFSET_EDGE) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_crit_max = temp_hotspot * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->hotspot_emergency_max = (temp_hotspot + CTF_OFFSET_HOTSPOT) *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_crit_max = temp_mem * SMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\trange->mem_emergency_max = (temp_mem + CTF_OFFSET_MEM)*\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\trange->software_shutdown_temp = powerplay_table->software_shutdown_temp;\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_display_disable_memory_clock_switch(struct smu_context *smu,\n\t\t\t\t\t\tbool disable_memory_clock_switch)\n{\n\tint ret = 0;\n\tstruct smu_11_0_max_sustainable_clocks *max_sustainable_clocks =\n\t\t(struct smu_11_0_max_sustainable_clocks *)\n\t\t\tsmu->smu_table.max_sustainable_clocks;\n\tuint32_t min_memory_clock = smu->hard_min_uclk_req_from_dal;\n\tuint32_t max_memory_clock = max_sustainable_clocks->uclock;\n\n\tif(smu->disable_uclk_switch == disable_memory_clock_switch)\n\t\treturn 0;\n\n\tif(disable_memory_clock_switch)\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, max_memory_clock, 0);\n\telse\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, SMU_UCLK, min_memory_clock, 0);\n\n\tif(!ret)\n\t\tsmu->disable_uclk_switch = disable_memory_clock_switch;\n\n\treturn ret;\n}\n\n#define MAX(a, b)\t((a) > (b) ? (a) : (b))\n\nstatic int sienna_cichlid_update_pcie_parameters(struct smu_context *smu,\n\t\t\t\t\t\t uint8_t pcie_gen_cap,\n\t\t\t\t\t\t uint8_t pcie_width_cap)\n{\n\tstruct smu_11_0_dpm_context *dpm_context = smu->smu_dpm.dpm_context;\n\tstruct smu_11_0_pcie_table *pcie_table = &dpm_context->dpm_tables.pcie_table;\n\tuint8_t *table_member1, *table_member2;\n\tuint8_t min_gen_speed, max_gen_speed;\n\tuint8_t min_lane_width, max_lane_width;\n\tuint32_t smu_pcie_arg;\n\tint ret, i;\n\n\tGET_PPTABLE_MEMBER(PcieGenSpeed, &table_member1);\n\tGET_PPTABLE_MEMBER(PcieLaneCount, &table_member2);\n\n\tmin_gen_speed = MAX(0, table_member1[0]);\n\tmax_gen_speed = MIN(pcie_gen_cap, table_member1[1]);\n\tmin_gen_speed = min_gen_speed > max_gen_speed ?\n\t\t\tmax_gen_speed : min_gen_speed;\n\tmin_lane_width = MAX(1, table_member2[0]);\n\tmax_lane_width = MIN(pcie_width_cap, table_member2[1]);\n\tmin_lane_width = min_lane_width > max_lane_width ?\n\t\t\t max_lane_width : min_lane_width;\n\n\tif (!(smu->adev->pm.pp_feature & PP_PCIE_DPM_MASK)) {\n\t\tpcie_table->pcie_gen[0] = max_gen_speed;\n\t\tpcie_table->pcie_lane[0] = max_lane_width;\n\t} else {\n\t\tpcie_table->pcie_gen[0] = min_gen_speed;\n\t\tpcie_table->pcie_lane[0] = min_lane_width;\n\t}\n\tpcie_table->pcie_gen[1] = max_gen_speed;\n\tpcie_table->pcie_lane[1] = max_lane_width;\n\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\tsmu_pcie_arg = (i << 16 |\n\t\t\t\tpcie_table->pcie_gen[i] << 8 |\n\t\t\t\tpcie_table->pcie_lane[i]);\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_OverridePcieParameters,\n\t\t\t\tsmu_pcie_arg,\n\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\tuint32_t *min, uint32_t *max)\n{\n\treturn smu_v11_0_get_dpm_ultimate_freq(smu, clk_type, min, max);\n}\n\nstatic void sienna_cichlid_dump_od_table(struct smu_context *smu,\n\t\t\t\t\t OverDriveTable_t *od_table)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t smu_version;\n\n\tdev_dbg(smu->adev->dev, \"OD: Gfxclk: (%d, %d)\\n\", od_table->GfxclkFmin,\n\t\t\t\t\t\t\t  od_table->GfxclkFmax);\n\tdev_dbg(smu->adev->dev, \"OD: Uclk: (%d, %d)\\n\", od_table->UclkFmin,\n\t\t\t\t\t\t\tod_table->UclkFmax);\n\n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (!((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 7)) &&\n\t       (smu_version < 0x003a2900)))\n\t\tdev_dbg(smu->adev->dev, \"OD: VddGfxOffset: %d\\n\", od_table->VddGfxOffset);\n}\n\nstatic int sienna_cichlid_set_default_od_settings(struct smu_context *smu)\n{\n\tOverDriveTable_t *od_table =\n\t\t(OverDriveTable_t *)smu->smu_table.overdrive_table;\n\tOverDriveTable_t *boot_od_table =\n\t\t(OverDriveTable_t *)smu->smu_table.boot_overdrive_table;\n\tOverDriveTable_t *user_od_table =\n\t\t(OverDriveTable_t *)smu->smu_table.user_overdrive_table;\n\tOverDriveTable_t user_od_table_bak;\n\tint ret = 0;\n\n\tret = smu_cmn_update_table(smu, SMU_TABLE_OVERDRIVE,\n\t\t\t\t   0, (void *)boot_od_table, false);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"Failed to get overdrive table!\\n\");\n\t\treturn ret;\n\t}\n\n\tsienna_cichlid_dump_od_table(smu, boot_od_table);\n\n\tmemcpy(od_table, boot_od_table, sizeof(OverDriveTable_t));\n\n\t \n\tif (!smu->adev->in_suspend) {\n\t\tmemcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t));\n\t\tsmu->user_dpm_profile.user_od = false;\n\t} else if (smu->user_dpm_profile.user_od) {\n\t\tmemcpy(&user_od_table_bak, user_od_table, sizeof(OverDriveTable_t));\n\t\tmemcpy(user_od_table, boot_od_table, sizeof(OverDriveTable_t));\n\t\tuser_od_table->GfxclkFmin = user_od_table_bak.GfxclkFmin;\n\t\tuser_od_table->GfxclkFmax = user_od_table_bak.GfxclkFmax;\n\t\tuser_od_table->UclkFmin = user_od_table_bak.UclkFmin;\n\t\tuser_od_table->UclkFmax = user_od_table_bak.UclkFmax;\n\t\tuser_od_table->VddGfxOffset = user_od_table_bak.VddGfxOffset;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_od_setting_check_range(struct smu_context *smu,\n\t\t\t\t\t\t struct smu_11_0_7_overdrive_table *od_table,\n\t\t\t\t\t\t enum SMU_11_0_7_ODSETTING_ID setting,\n\t\t\t\t\t\t uint32_t value)\n{\n\tif (value < od_table->min[setting]) {\n\t\tdev_warn(smu->adev->dev, \"OD setting (%d, %d) is less than the minimum allowed (%d)\\n\",\n\t\t\t\t\t  setting, value, od_table->min[setting]);\n\t\treturn -EINVAL;\n\t}\n\tif (value > od_table->max[setting]) {\n\t\tdev_warn(smu->adev->dev, \"OD setting (%d, %d) is greater than the maximum allowed (%d)\\n\",\n\t\t\t\t\t  setting, value, od_table->max[setting]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_od_edit_dpm_table(struct smu_context *smu,\n\t\t\t\t\t    enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\t    long input[], uint32_t size)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tOverDriveTable_t *od_table =\n\t\t(OverDriveTable_t *)table_context->overdrive_table;\n\tstruct smu_11_0_7_overdrive_table *od_settings =\n\t\t(struct smu_11_0_7_overdrive_table *)smu->od_settings;\n\tstruct amdgpu_device *adev = smu->adev;\n\tenum SMU_11_0_7_ODSETTING_ID freq_setting;\n\tuint16_t *freq_ptr;\n\tint i, ret = 0;\n\tuint32_t smu_version;\n\n\tif (!smu->od_enabled) {\n\t\tdev_warn(smu->adev->dev, \"OverDrive is not enabled!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!smu->od_settings) {\n\t\tdev_err(smu->adev->dev, \"OD board limits are not set!\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!(table_context->overdrive_table && table_context->boot_overdrive_table)) {\n\t\tdev_err(smu->adev->dev, \"Overdrive table was not initialized!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (!sienna_cichlid_is_od_feature_supported(od_settings,\n\t\t\t\t\t\t\t    SMU_11_0_7_ODCAP_GFXCLK_LIMITS)) {\n\t\t\tdev_warn(smu->adev->dev, \"GFXCLK_LIMITS not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tdev_info(smu->adev->dev, \"invalid number of input parameters %d\\n\", size);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tswitch (input[i]) {\n\t\t\tcase 0:\n\t\t\t\tif (input[i + 1] > od_table->GfxclkFmax) {\n\t\t\t\t\tdev_info(smu->adev->dev, \"GfxclkFmin (%ld) must be <= GfxclkFmax (%u)!\\n\",\n\t\t\t\t\t\tinput[i + 1], od_table->GfxclkFmax);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tfreq_setting = SMU_11_0_7_ODSETTING_GFXCLKFMIN;\n\t\t\t\tfreq_ptr = &od_table->GfxclkFmin;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tif (input[i + 1] < od_table->GfxclkFmin) {\n\t\t\t\t\tdev_info(smu->adev->dev, \"GfxclkFmax (%ld) must be >= GfxclkFmin (%u)!\\n\",\n\t\t\t\t\t\tinput[i + 1], od_table->GfxclkFmin);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tfreq_setting = SMU_11_0_7_ODSETTING_GFXCLKFMAX;\n\t\t\t\tfreq_ptr = &od_table->GfxclkFmax;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_info(smu->adev->dev, \"Invalid SCLK_VDDC_TABLE index: %ld\\n\", input[i]);\n\t\t\t\tdev_info(smu->adev->dev, \"Supported indices: [0:min,1:max]\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = sienna_cichlid_od_setting_check_range(smu, od_settings,\n\t\t\t\t\t\t\t\t    freq_setting, input[i + 1]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*freq_ptr = (uint16_t)input[i + 1];\n\t\t}\n\t\tbreak;\n\n\tcase PP_OD_EDIT_MCLK_VDDC_TABLE:\n\t\tif (!sienna_cichlid_is_od_feature_supported(od_settings, SMU_11_0_7_ODCAP_UCLK_LIMITS)) {\n\t\t\tdev_warn(smu->adev->dev, \"UCLK_LIMITS not supported!\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tfor (i = 0; i < size; i += 2) {\n\t\t\tif (i + 2 > size) {\n\t\t\t\tdev_info(smu->adev->dev, \"invalid number of input parameters %d\\n\", size);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tswitch (input[i]) {\n\t\t\tcase 0:\n\t\t\t\tif (input[i + 1] > od_table->UclkFmax) {\n\t\t\t\t\tdev_info(smu->adev->dev, \"UclkFmin (%ld) must be <= UclkFmax (%u)!\\n\",\n\t\t\t\t\t\tinput[i + 1], od_table->UclkFmax);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tfreq_setting = SMU_11_0_7_ODSETTING_UCLKFMIN;\n\t\t\t\tfreq_ptr = &od_table->UclkFmin;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tif (input[i + 1] < od_table->UclkFmin) {\n\t\t\t\t\tdev_info(smu->adev->dev, \"UclkFmax (%ld) must be >= UclkFmin (%u)!\\n\",\n\t\t\t\t\t\tinput[i + 1], od_table->UclkFmin);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tfreq_setting = SMU_11_0_7_ODSETTING_UCLKFMAX;\n\t\t\t\tfreq_ptr = &od_table->UclkFmax;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_info(smu->adev->dev, \"Invalid MCLK_VDDC_TABLE index: %ld\\n\", input[i]);\n\t\t\t\tdev_info(smu->adev->dev, \"Supported indices: [0:min,1:max]\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = sienna_cichlid_od_setting_check_range(smu, od_settings,\n\t\t\t\t\t\t\t\t    freq_setting, input[i + 1]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t*freq_ptr = (uint16_t)input[i + 1];\n\t\t}\n\t\tbreak;\n\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tmemcpy(table_context->overdrive_table,\n\t\t\t\ttable_context->boot_overdrive_table,\n\t\t\t\tsizeof(OverDriveTable_t));\n\t\tfallthrough;\n\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (memcmp(od_table, table_context->user_overdrive_table, sizeof(OverDriveTable_t))) {\n\t\t\tsienna_cichlid_dump_od_table(smu, od_table);\n\t\t\tret = smu_cmn_update_table(smu, SMU_TABLE_OVERDRIVE, 0, (void *)od_table, true);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Failed to import overdrive table!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tmemcpy(table_context->user_overdrive_table, od_table, sizeof(OverDriveTable_t));\n\t\t\tsmu->user_dpm_profile.user_od = true;\n\n\t\t\tif (!memcmp(table_context->user_overdrive_table,\n\t\t\t\t    table_context->boot_overdrive_table,\n\t\t\t\t    sizeof(OverDriveTable_t)))\n\t\t\t\tsmu->user_dpm_profile.user_od = false;\n\t\t}\n\t\tbreak;\n\n\tcase PP_OD_EDIT_VDDGFX_OFFSET:\n\t\tif (size != 1) {\n\t\t\tdev_info(smu->adev->dev, \"invalid number of parameters: %d\\n\", size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\t\tif ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 7)) &&\n\t\t     (smu_version < 0x003a2900)) {\n\t\t\tdev_err(smu->adev->dev, \"OD GFX Voltage offset functionality is supported \"\n\t\t\t\t\t\t\"only by 58.41.0 and onwards SMU firmwares!\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tod_table->VddGfxOffset = (int16_t)input[0];\n\n\t\tsienna_cichlid_dump_od_table(smu, od_table);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int sienna_cichlid_restore_user_od_settings(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tOverDriveTable_t *od_table = table_context->overdrive_table;\n\tOverDriveTable_t *user_od_table = table_context->user_overdrive_table;\n\tint res;\n\n\tres = smu_v11_0_restore_user_od_settings(smu);\n\tif (res == 0)\n\t\tmemcpy(od_table, user_od_table, sizeof(OverDriveTable_t));\n\n\treturn res;\n}\n\nstatic int sienna_cichlid_run_btc(struct smu_context *smu)\n{\n\tint res;\n\n\tres = smu_cmn_send_smc_msg(smu, SMU_MSG_RunDcBtc, NULL);\n\tif (res)\n\t\tdev_err(smu->adev->dev, \"RunDcBtc failed!\\n\");\n\n\treturn res;\n}\n\nstatic int sienna_cichlid_baco_enter(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->in_runpm && smu_cmn_is_audio_func_enabled(adev))\n\t\treturn smu_v11_0_baco_set_armd3_sequence(smu, BACO_SEQ_BACO);\n\telse\n\t\treturn smu_v11_0_baco_enter(smu);\n}\n\nstatic int sienna_cichlid_baco_exit(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (adev->in_runpm && smu_cmn_is_audio_func_enabled(adev)) {\n\t\t \n\t\tmsleep(10);\n\t\treturn smu_v11_0_baco_set_armd3_sequence(smu, BACO_SEQ_ULPS);\n\t} else {\n\t\treturn smu_v11_0_baco_exit(smu);\n\t}\n}\n\nstatic bool sienna_cichlid_is_mode1_reset_supported(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t val;\n\tu32 smu_version;\n\n\t \n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (amdgpu_sriov_vf(adev) || (smu_version < 0x003a1a00))\n\t\treturn false;\n\n\t \n\tval = RREG32_SOC15(MP0, 0, mmMP0_SMN_C2PMSG_81);\n\treturn val != 0x0;\n}\n\nstatic void beige_goby_dump_pptable(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_beige_goby_t *pptable = table_context->driver_pptable;\n\tint i;\n\n\tdev_info(smu->adev->dev, \"Dumped PPTable:\\n\");\n\n\tdev_info(smu->adev->dev, \"Version = 0x%08x\\n\", pptable->Version);\n\tdev_info(smu->adev->dev, \"FeaturesToRun[0] = 0x%08x\\n\", pptable->FeaturesToRun[0]);\n\tdev_info(smu->adev->dev, \"FeaturesToRun[1] = 0x%08x\\n\", pptable->FeaturesToRun[1]);\n\n\tfor (i = 0; i < PPT_THROTTLER_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitAc[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitAc[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitAcTau[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitAcTau[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitDc[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitDc[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitDcTau[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitDcTau[i]);\n\t}\n\n\tfor (i = 0; i < TDC_THROTTLER_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"TdcLimit[%d] = 0x%x\\n\", i, pptable->TdcLimit[i]);\n\t\tdev_info(smu->adev->dev, \"TdcLimitTau[%d] = 0x%x\\n\", i, pptable->TdcLimitTau[i]);\n\t}\n\n\tfor (i = 0; i < TEMP_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"TemperatureLimit[%d] = 0x%x\\n\", i, pptable->TemperatureLimit[i]);\n\t}\n\n\tdev_info(smu->adev->dev, \"FitLimit = 0x%x\\n\", pptable->FitLimit);\n\tdev_info(smu->adev->dev, \"TotalPowerConfig = 0x%x\\n\", pptable->TotalPowerConfig);\n\tdev_info(smu->adev->dev, \"TotalPowerPadding[0] = 0x%x\\n\", pptable->TotalPowerPadding[0]);\n\tdev_info(smu->adev->dev, \"TotalPowerPadding[1] = 0x%x\\n\", pptable->TotalPowerPadding[1]);\n\tdev_info(smu->adev->dev, \"TotalPowerPadding[2] = 0x%x\\n\", pptable->TotalPowerPadding[2]);\n\n\tdev_info(smu->adev->dev, \"ApccPlusResidencyLimit = 0x%x\\n\", pptable->ApccPlusResidencyLimit);\n\tfor (i = 0; i < NUM_SMNCLK_DPM_LEVELS; i++) {\n\t\tdev_info(smu->adev->dev, \"SmnclkDpmFreq[%d] = 0x%x\\n\", i, pptable->SmnclkDpmFreq[i]);\n\t\tdev_info(smu->adev->dev, \"SmnclkDpmVoltage[%d] = 0x%x\\n\", i, pptable->SmnclkDpmVoltage[i]);\n\t}\n\tdev_info(smu->adev->dev, \"ThrottlerControlMask = 0x%x\\n\", pptable->ThrottlerControlMask);\n\n\tdev_info(smu->adev->dev, \"FwDStateMask = 0x%x\\n\", pptable->FwDStateMask);\n\n\tdev_info(smu->adev->dev, \"UlvVoltageOffsetSoc = 0x%x\\n\", pptable->UlvVoltageOffsetSoc);\n\tdev_info(smu->adev->dev, \"UlvVoltageOffsetGfx = 0x%x\\n\", pptable->UlvVoltageOffsetGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageUlvGfx = 0x%x\\n\", pptable->MinVoltageUlvGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageUlvSoc = 0x%x\\n\", pptable->MinVoltageUlvSoc);\n\n\tdev_info(smu->adev->dev, \"SocLIVmin = 0x%x\\n\", pptable->SocLIVmin);\n\n\tdev_info(smu->adev->dev, \"GceaLinkMgrIdleThreshold = 0x%x\\n\", pptable->GceaLinkMgrIdleThreshold);\n\n\tdev_info(smu->adev->dev, \"MinVoltageGfx = 0x%x\\n\", pptable->MinVoltageGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageSoc = 0x%x\\n\", pptable->MinVoltageSoc);\n\tdev_info(smu->adev->dev, \"MaxVoltageGfx = 0x%x\\n\", pptable->MaxVoltageGfx);\n\tdev_info(smu->adev->dev, \"MaxVoltageSoc = 0x%x\\n\", pptable->MaxVoltageSoc);\n\n\tdev_info(smu->adev->dev, \"LoadLineResistanceGfx = 0x%x\\n\", pptable->LoadLineResistanceGfx);\n\tdev_info(smu->adev->dev, \"LoadLineResistanceSoc = 0x%x\\n\", pptable->LoadLineResistanceSoc);\n\n\tdev_info(smu->adev->dev, \"VDDGFX_TVmin = 0x%x\\n\", pptable->VDDGFX_TVmin);\n\tdev_info(smu->adev->dev, \"VDDSOC_TVmin = 0x%x\\n\", pptable->VDDSOC_TVmin);\n\tdev_info(smu->adev->dev, \"VDDGFX_Vmin_HiTemp = 0x%x\\n\", pptable->VDDGFX_Vmin_HiTemp);\n\tdev_info(smu->adev->dev, \"VDDGFX_Vmin_LoTemp = 0x%x\\n\", pptable->VDDGFX_Vmin_LoTemp);\n\tdev_info(smu->adev->dev, \"VDDSOC_Vmin_HiTemp = 0x%x\\n\", pptable->VDDSOC_Vmin_HiTemp);\n\tdev_info(smu->adev->dev, \"VDDSOC_Vmin_LoTemp = 0x%x\\n\", pptable->VDDSOC_Vmin_LoTemp);\n\tdev_info(smu->adev->dev, \"VDDGFX_TVminHystersis = 0x%x\\n\", pptable->VDDGFX_TVminHystersis);\n\tdev_info(smu->adev->dev, \"VDDSOC_TVminHystersis = 0x%x\\n\", pptable->VDDSOC_TVminHystersis);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_GFXCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_SOCCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_UCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_FCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_DCLK_0]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_VCLK_0]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_DCLK_1]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_VCLK_1]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].Padding16);\n\n\tdev_info(smu->adev->dev, \"FreqTableGfx\\n\");\n\tfor (i = 0; i < NUM_GFXCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableGfx[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableVclk\\n\");\n\tfor (i = 0; i < NUM_VCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableVclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableDclk\\n\");\n\tfor (i = 0; i < NUM_DCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableDclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableSocclk\\n\");\n\tfor (i = 0; i < NUM_SOCCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableSocclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableUclk\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableUclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableFclk\\n\");\n\tfor (i = 0; i < NUM_FCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableFclk[i]);\n\n\tdev_info(smu->adev->dev, \"DcModeMaxFreq\\n\");\n\tdev_info(smu->adev->dev, \"  .PPCLK_GFXCLK = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_GFXCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_SOCCLK = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_SOCCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_UCLK   = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_UCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_FCLK   = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_FCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_DCLK_0 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_DCLK_0]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_VCLK_0 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_VCLK_0]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_DCLK_1 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_DCLK_1]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_VCLK_1 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_VCLK_1]);\n\n\tdev_info(smu->adev->dev, \"FreqTableUclkDiv\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->FreqTableUclkDiv[i]);\n\n\tdev_info(smu->adev->dev, \"FclkBoostFreq = 0x%x\\n\", pptable->FclkBoostFreq);\n\tdev_info(smu->adev->dev, \"FclkParamPadding = 0x%x\\n\", pptable->FclkParamPadding);\n\n\tdev_info(smu->adev->dev, \"Mp0clkFreq\\n\");\n\tfor (i = 0; i < NUM_MP0CLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->Mp0clkFreq[i]);\n\n\tdev_info(smu->adev->dev, \"Mp0DpmVoltage\\n\");\n\tfor (i = 0; i < NUM_MP0CLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->Mp0DpmVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"MemVddciVoltage\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->MemVddciVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"MemMvddVoltage\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->MemMvddVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"GfxclkFgfxoffEntry = 0x%x\\n\", pptable->GfxclkFgfxoffEntry);\n\tdev_info(smu->adev->dev, \"GfxclkFinit = 0x%x\\n\", pptable->GfxclkFinit);\n\tdev_info(smu->adev->dev, \"GfxclkFidle = 0x%x\\n\", pptable->GfxclkFidle);\n\tdev_info(smu->adev->dev, \"GfxclkSource = 0x%x\\n\", pptable->GfxclkSource);\n\tdev_info(smu->adev->dev, \"GfxclkPadding = 0x%x\\n\", pptable->GfxclkPadding);\n\n\tdev_info(smu->adev->dev, \"GfxGpoSubFeatureMask = 0x%x\\n\", pptable->GfxGpoSubFeatureMask);\n\n\tdev_info(smu->adev->dev, \"GfxGpoEnabledWorkPolicyMask = 0x%x\\n\", pptable->GfxGpoEnabledWorkPolicyMask);\n\tdev_info(smu->adev->dev, \"GfxGpoDisabledWorkPolicyMask = 0x%x\\n\", pptable->GfxGpoDisabledWorkPolicyMask);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding[0] = 0x%x\\n\", pptable->GfxGpoPadding[0]);\n\tdev_info(smu->adev->dev, \"GfxGpoVotingAllow = 0x%x\\n\", pptable->GfxGpoVotingAllow);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[0] = 0x%x\\n\", pptable->GfxGpoPadding32[0]);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[1] = 0x%x\\n\", pptable->GfxGpoPadding32[1]);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[2] = 0x%x\\n\", pptable->GfxGpoPadding32[2]);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[3] = 0x%x\\n\", pptable->GfxGpoPadding32[3]);\n\tdev_info(smu->adev->dev, \"GfxDcsFopt = 0x%x\\n\", pptable->GfxDcsFopt);\n\tdev_info(smu->adev->dev, \"GfxDcsFclkFopt = 0x%x\\n\", pptable->GfxDcsFclkFopt);\n\tdev_info(smu->adev->dev, \"GfxDcsUclkFopt = 0x%x\\n\", pptable->GfxDcsUclkFopt);\n\n\tdev_info(smu->adev->dev, \"DcsGfxOffVoltage = 0x%x\\n\", pptable->DcsGfxOffVoltage);\n\tdev_info(smu->adev->dev, \"DcsMinGfxOffTime = 0x%x\\n\", pptable->DcsMinGfxOffTime);\n\tdev_info(smu->adev->dev, \"DcsMaxGfxOffTime = 0x%x\\n\", pptable->DcsMaxGfxOffTime);\n\tdev_info(smu->adev->dev, \"DcsMinCreditAccum = 0x%x\\n\", pptable->DcsMinCreditAccum);\n\tdev_info(smu->adev->dev, \"DcsExitHysteresis = 0x%x\\n\", pptable->DcsExitHysteresis);\n\tdev_info(smu->adev->dev, \"DcsTimeout = 0x%x\\n\", pptable->DcsTimeout);\n\n\tdev_info(smu->adev->dev, \"DcsParamPadding[0] = 0x%x\\n\", pptable->DcsParamPadding[0]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[1] = 0x%x\\n\", pptable->DcsParamPadding[1]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[2] = 0x%x\\n\", pptable->DcsParamPadding[2]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[3] = 0x%x\\n\", pptable->DcsParamPadding[3]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[4] = 0x%x\\n\", pptable->DcsParamPadding[4]);\n\n\tdev_info(smu->adev->dev, \"FlopsPerByteTable\\n\");\n\tfor (i = 0; i < RLC_PACE_TABLE_NUM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->FlopsPerByteTable[i]);\n\n\tdev_info(smu->adev->dev, \"LowestUclkReservedForUlv = 0x%x\\n\", pptable->LowestUclkReservedForUlv);\n\tdev_info(smu->adev->dev, \"vddingMem[0] = 0x%x\\n\", pptable->PaddingMem[0]);\n\tdev_info(smu->adev->dev, \"vddingMem[1] = 0x%x\\n\", pptable->PaddingMem[1]);\n\tdev_info(smu->adev->dev, \"vddingMem[2] = 0x%x\\n\", pptable->PaddingMem[2]);\n\n\tdev_info(smu->adev->dev, \"UclkDpmPstates\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->UclkDpmPstates[i]);\n\n\tdev_info(smu->adev->dev, \"UclkDpmSrcFreqRange\\n\");\n\tdev_info(smu->adev->dev, \"  .Fmin = 0x%x\\n\",\n\t\tpptable->UclkDpmSrcFreqRange.Fmin);\n\tdev_info(smu->adev->dev, \"  .Fmax = 0x%x\\n\",\n\t\tpptable->UclkDpmSrcFreqRange.Fmax);\n\tdev_info(smu->adev->dev, \"UclkDpmTargFreqRange\\n\");\n\tdev_info(smu->adev->dev, \"  .Fmin = 0x%x\\n\",\n\t\tpptable->UclkDpmTargFreqRange.Fmin);\n\tdev_info(smu->adev->dev, \"  .Fmax = 0x%x\\n\",\n\t\tpptable->UclkDpmTargFreqRange.Fmax);\n\tdev_info(smu->adev->dev, \"UclkDpmMidstepFreq = 0x%x\\n\", pptable->UclkDpmMidstepFreq);\n\tdev_info(smu->adev->dev, \"UclkMidstepPadding = 0x%x\\n\", pptable->UclkMidstepPadding);\n\n\tdev_info(smu->adev->dev, \"PcieGenSpeed\\n\");\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->PcieGenSpeed[i]);\n\n\tdev_info(smu->adev->dev, \"PcieLaneCount\\n\");\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->PcieLaneCount[i]);\n\n\tdev_info(smu->adev->dev, \"LclkFreq\\n\");\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->LclkFreq[i]);\n\n\tdev_info(smu->adev->dev, \"FanStopTemp = 0x%x\\n\", pptable->FanStopTemp);\n\tdev_info(smu->adev->dev, \"FanStartTemp = 0x%x\\n\", pptable->FanStartTemp);\n\n\tdev_info(smu->adev->dev, \"FanGain\\n\");\n\tfor (i = 0; i < TEMP_COUNT; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->FanGain[i]);\n\n\tdev_info(smu->adev->dev, \"FanPwmMin = 0x%x\\n\", pptable->FanPwmMin);\n\tdev_info(smu->adev->dev, \"FanAcousticLimitRpm = 0x%x\\n\", pptable->FanAcousticLimitRpm);\n\tdev_info(smu->adev->dev, \"FanThrottlingRpm = 0x%x\\n\", pptable->FanThrottlingRpm);\n\tdev_info(smu->adev->dev, \"FanMaximumRpm = 0x%x\\n\", pptable->FanMaximumRpm);\n\tdev_info(smu->adev->dev, \"MGpuFanBoostLimitRpm = 0x%x\\n\", pptable->MGpuFanBoostLimitRpm);\n\tdev_info(smu->adev->dev, \"FanTargetTemperature = 0x%x\\n\", pptable->FanTargetTemperature);\n\tdev_info(smu->adev->dev, \"FanTargetGfxclk = 0x%x\\n\", pptable->FanTargetGfxclk);\n\tdev_info(smu->adev->dev, \"FanPadding16 = 0x%x\\n\", pptable->FanPadding16);\n\tdev_info(smu->adev->dev, \"FanTempInputSelect = 0x%x\\n\", pptable->FanTempInputSelect);\n\tdev_info(smu->adev->dev, \"FanPadding = 0x%x\\n\", pptable->FanPadding);\n\tdev_info(smu->adev->dev, \"FanZeroRpmEnable = 0x%x\\n\", pptable->FanZeroRpmEnable);\n\tdev_info(smu->adev->dev, \"FanTachEdgePerRev = 0x%x\\n\", pptable->FanTachEdgePerRev);\n\n\tdev_info(smu->adev->dev, \"FuzzyFan_ErrorSetDelta = 0x%x\\n\", pptable->FuzzyFan_ErrorSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_ErrorRateSetDelta = 0x%x\\n\", pptable->FuzzyFan_ErrorRateSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_PwmSetDelta = 0x%x\\n\", pptable->FuzzyFan_PwmSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_Reserved = 0x%x\\n\", pptable->FuzzyFan_Reserved);\n\n\tdev_info(smu->adev->dev, \"OverrideAvfsGb[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->OverrideAvfsGb[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"OverrideAvfsGb[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->OverrideAvfsGb[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxDfllModelSelect = 0x%x\\n\", pptable->dBtcGbGfxDfllModelSelect);\n\tdev_info(smu->adev->dev, \"Padding8_Avfs = 0x%x\\n\", pptable->Padding8_Avfs);\n\n\tdev_info(smu->adev->dev, \"qAvfsGb[AVFS_VOLTAGE_GFX]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_GFX].a,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_GFX].b,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_GFX].c);\n\tdev_info(smu->adev->dev, \"qAvfsGb[AVFS_VOLTAGE_SOC]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_SOC].a,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_SOC].b,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_SOC].c);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxPll{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbGfxPll.a,\n\t\t\tpptable->dBtcGbGfxPll.b,\n\t\t\tpptable->dBtcGbGfxPll.c);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxAfll{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbGfxDfll.a,\n\t\t\tpptable->dBtcGbGfxDfll.b,\n\t\t\tpptable->dBtcGbGfxDfll.c);\n\tdev_info(smu->adev->dev, \"dBtcGbSoc{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbSoc.a,\n\t\t\tpptable->dBtcGbSoc.b,\n\t\t\tpptable->dBtcGbSoc.c);\n\tdev_info(smu->adev->dev, \"qAgingGb[AVFS_VOLTAGE_GFX]{m = 0x%x b = 0x%x}\\n\",\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_GFX].m,\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_GFX].b);\n\tdev_info(smu->adev->dev, \"qAgingGb[AVFS_VOLTAGE_SOC]{m = 0x%x b = 0x%x}\\n\",\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_SOC].m,\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_SOC].b);\n\n\tdev_info(smu->adev->dev, \"PiecewiseLinearDroopIntGfxDfll\\n\");\n\tfor (i = 0; i < NUM_PIECE_WISE_LINEAR_DROOP_MODEL_VF_POINTS; i++) {\n\t\tdev_info(smu->adev->dev, \"\t\tFset[%d] = 0x%x\\n\",\n\t\t\ti, pptable->PiecewiseLinearDroopIntGfxDfll.Fset[i]);\n\t\tdev_info(smu->adev->dev, \"\t\tVdroop[%d] = 0x%x\\n\",\n\t\t\ti, pptable->PiecewiseLinearDroopIntGfxDfll.Vdroop[i]);\n\t}\n\n\tdev_info(smu->adev->dev, \"qStaticVoltageOffset[AVFS_VOLTAGE_GFX]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].a,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].b,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].c);\n\tdev_info(smu->adev->dev, \"qStaticVoltageOffset[AVFS_VOLTAGE_SOC]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].a,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].b,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].c);\n\n\tdev_info(smu->adev->dev, \"DcTol[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcTol[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcTol[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcTol[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"DcBtcEnabled[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcEnabled[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcEnabled[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcEnabled[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"Padding8_GfxBtc[0] = 0x%x\\n\", pptable->Padding8_GfxBtc[0]);\n\tdev_info(smu->adev->dev, \"Padding8_GfxBtc[1] = 0x%x\\n\", pptable->Padding8_GfxBtc[1]);\n\n\tdev_info(smu->adev->dev, \"DcBtcMin[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcMin[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcMin[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcMin[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"DcBtcMax[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcMax[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcMax[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcMax[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"DcBtcGb[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcGb[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcGb[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcGb[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"XgmiDpmPstates\\n\");\n\tfor (i = 0; i < NUM_XGMI_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiDpmPstates[i]);\n\tdev_info(smu->adev->dev, \"XgmiDpmSpare[0] = 0x%02x\\n\", pptable->XgmiDpmSpare[0]);\n\tdev_info(smu->adev->dev, \"XgmiDpmSpare[1] = 0x%02x\\n\", pptable->XgmiDpmSpare[1]);\n\n\tdev_info(smu->adev->dev, \"DebugOverrides = 0x%x\\n\", pptable->DebugOverrides);\n\tdev_info(smu->adev->dev, \"ReservedEquation0{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation0.a,\n\t\t\tpptable->ReservedEquation0.b,\n\t\t\tpptable->ReservedEquation0.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation1{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation1.a,\n\t\t\tpptable->ReservedEquation1.b,\n\t\t\tpptable->ReservedEquation1.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation2{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation2.a,\n\t\t\tpptable->ReservedEquation2.b,\n\t\t\tpptable->ReservedEquation2.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation3{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation3.a,\n\t\t\tpptable->ReservedEquation3.b,\n\t\t\tpptable->ReservedEquation3.c);\n\n\tdev_info(smu->adev->dev, \"SkuReserved[0] = 0x%x\\n\", pptable->SkuReserved[0]);\n\tdev_info(smu->adev->dev, \"SkuReserved[1] = 0x%x\\n\", pptable->SkuReserved[1]);\n\tdev_info(smu->adev->dev, \"SkuReserved[2] = 0x%x\\n\", pptable->SkuReserved[2]);\n\tdev_info(smu->adev->dev, \"SkuReserved[3] = 0x%x\\n\", pptable->SkuReserved[3]);\n\tdev_info(smu->adev->dev, \"SkuReserved[4] = 0x%x\\n\", pptable->SkuReserved[4]);\n\tdev_info(smu->adev->dev, \"SkuReserved[5] = 0x%x\\n\", pptable->SkuReserved[5]);\n\tdev_info(smu->adev->dev, \"SkuReserved[6] = 0x%x\\n\", pptable->SkuReserved[6]);\n\tdev_info(smu->adev->dev, \"SkuReserved[7] = 0x%x\\n\", pptable->SkuReserved[7]);\n\n\tdev_info(smu->adev->dev, \"GamingClk[0] = 0x%x\\n\", pptable->GamingClk[0]);\n\tdev_info(smu->adev->dev, \"GamingClk[1] = 0x%x\\n\", pptable->GamingClk[1]);\n\tdev_info(smu->adev->dev, \"GamingClk[2] = 0x%x\\n\", pptable->GamingClk[2]);\n\tdev_info(smu->adev->dev, \"GamingClk[3] = 0x%x\\n\", pptable->GamingClk[3]);\n\tdev_info(smu->adev->dev, \"GamingClk[4] = 0x%x\\n\", pptable->GamingClk[4]);\n\tdev_info(smu->adev->dev, \"GamingClk[5] = 0x%x\\n\", pptable->GamingClk[5]);\n\n\tfor (i = 0; i < NUM_I2C_CONTROLLERS; i++) {\n\t\tdev_info(smu->adev->dev, \"I2cControllers[%d]:\\n\", i);\n\t\tdev_info(smu->adev->dev, \"                   .Enabled = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].Enabled);\n\t\tdev_info(smu->adev->dev, \"                   .Speed = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].Speed);\n\t\tdev_info(smu->adev->dev, \"                   .SlaveAddress = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].SlaveAddress);\n\t\tdev_info(smu->adev->dev, \"                   .ControllerPort = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].ControllerPort);\n\t\tdev_info(smu->adev->dev, \"                   .ControllerName = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].ControllerName);\n\t\tdev_info(smu->adev->dev, \"                   .ThermalThrottler = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].ThermalThrotter);\n\t\tdev_info(smu->adev->dev, \"                   .I2cProtocol = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].I2cProtocol);\n\t\tdev_info(smu->adev->dev, \"                   .PaddingConfig = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].PaddingConfig);\n\t}\n\n\tdev_info(smu->adev->dev, \"GpioScl = 0x%x\\n\", pptable->GpioScl);\n\tdev_info(smu->adev->dev, \"GpioSda = 0x%x\\n\", pptable->GpioSda);\n\tdev_info(smu->adev->dev, \"FchUsbPdSlaveAddr = 0x%x\\n\", pptable->FchUsbPdSlaveAddr);\n\tdev_info(smu->adev->dev, \"I2cSpare[0] = 0x%x\\n\", pptable->I2cSpare[0]);\n\n\tdev_info(smu->adev->dev, \"Board Parameters:\\n\");\n\tdev_info(smu->adev->dev, \"VddGfxVrMapping = 0x%x\\n\", pptable->VddGfxVrMapping);\n\tdev_info(smu->adev->dev, \"VddSocVrMapping = 0x%x\\n\", pptable->VddSocVrMapping);\n\tdev_info(smu->adev->dev, \"VddMem0VrMapping = 0x%x\\n\", pptable->VddMem0VrMapping);\n\tdev_info(smu->adev->dev, \"VddMem1VrMapping = 0x%x\\n\", pptable->VddMem1VrMapping);\n\tdev_info(smu->adev->dev, \"GfxUlvPhaseSheddingMask = 0x%x\\n\", pptable->GfxUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"SocUlvPhaseSheddingMask = 0x%x\\n\", pptable->SocUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"VddciUlvPhaseSheddingMask = 0x%x\\n\", pptable->VddciUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"MvddUlvPhaseSheddingMask = 0x%x\\n\", pptable->MvddUlvPhaseSheddingMask);\n\n\tdev_info(smu->adev->dev, \"GfxMaxCurrent = 0x%x\\n\", pptable->GfxMaxCurrent);\n\tdev_info(smu->adev->dev, \"GfxOffset = 0x%x\\n\", pptable->GfxOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryGfx = 0x%x\\n\", pptable->Padding_TelemetryGfx);\n\n\tdev_info(smu->adev->dev, \"SocMaxCurrent = 0x%x\\n\", pptable->SocMaxCurrent);\n\tdev_info(smu->adev->dev, \"SocOffset = 0x%x\\n\", pptable->SocOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetrySoc = 0x%x\\n\", pptable->Padding_TelemetrySoc);\n\n\tdev_info(smu->adev->dev, \"Mem0MaxCurrent = 0x%x\\n\", pptable->Mem0MaxCurrent);\n\tdev_info(smu->adev->dev, \"Mem0Offset = 0x%x\\n\", pptable->Mem0Offset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryMem0 = 0x%x\\n\", pptable->Padding_TelemetryMem0);\n\n\tdev_info(smu->adev->dev, \"Mem1MaxCurrent = 0x%x\\n\", pptable->Mem1MaxCurrent);\n\tdev_info(smu->adev->dev, \"Mem1Offset = 0x%x\\n\", pptable->Mem1Offset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryMem1 = 0x%x\\n\", pptable->Padding_TelemetryMem1);\n\n\tdev_info(smu->adev->dev, \"MvddRatio = 0x%x\\n\", pptable->MvddRatio);\n\n\tdev_info(smu->adev->dev, \"AcDcGpio = 0x%x\\n\", pptable->AcDcGpio);\n\tdev_info(smu->adev->dev, \"AcDcPolarity = 0x%x\\n\", pptable->AcDcPolarity);\n\tdev_info(smu->adev->dev, \"VR0HotGpio = 0x%x\\n\", pptable->VR0HotGpio);\n\tdev_info(smu->adev->dev, \"VR0HotPolarity = 0x%x\\n\", pptable->VR0HotPolarity);\n\tdev_info(smu->adev->dev, \"VR1HotGpio = 0x%x\\n\", pptable->VR1HotGpio);\n\tdev_info(smu->adev->dev, \"VR1HotPolarity = 0x%x\\n\", pptable->VR1HotPolarity);\n\tdev_info(smu->adev->dev, \"GthrGpio = 0x%x\\n\", pptable->GthrGpio);\n\tdev_info(smu->adev->dev, \"GthrPolarity = 0x%x\\n\", pptable->GthrPolarity);\n\tdev_info(smu->adev->dev, \"LedPin0 = 0x%x\\n\", pptable->LedPin0);\n\tdev_info(smu->adev->dev, \"LedPin1 = 0x%x\\n\", pptable->LedPin1);\n\tdev_info(smu->adev->dev, \"LedPin2 = 0x%x\\n\", pptable->LedPin2);\n\tdev_info(smu->adev->dev, \"LedEnableMask = 0x%x\\n\", pptable->LedEnableMask);\n\tdev_info(smu->adev->dev, \"LedPcie = 0x%x\\n\", pptable->LedPcie);\n\tdev_info(smu->adev->dev, \"LedError = 0x%x\\n\", pptable->LedError);\n\tdev_info(smu->adev->dev, \"LedSpare1[0] = 0x%x\\n\", pptable->LedSpare1[0]);\n\tdev_info(smu->adev->dev, \"LedSpare1[1] = 0x%x\\n\", pptable->LedSpare1[1]);\n\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadEnabled = 0x%x\\n\", pptable->PllGfxclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadPercent = 0x%x\\n\", pptable->PllGfxclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadFreq = 0x%x\\n\",    pptable->PllGfxclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"DfllGfxclkSpreadEnabled = 0x%x\\n\", pptable->DfllGfxclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"DfllGfxclkSpreadPercent = 0x%x\\n\", pptable->DfllGfxclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"DfllGfxclkSpreadFreq = 0x%x\\n\",    pptable->DfllGfxclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"UclkSpreadPadding = 0x%x\\n\", pptable->UclkSpreadPadding);\n\tdev_info(smu->adev->dev, \"UclkSpreadFreq = 0x%x\\n\", pptable->UclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"FclkSpreadEnabled = 0x%x\\n\", pptable->FclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"FclkSpreadPercent = 0x%x\\n\", pptable->FclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"FclkSpreadFreq = 0x%x\\n\", pptable->FclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"MemoryChannelEnabled = 0x%x\\n\", pptable->MemoryChannelEnabled);\n\tdev_info(smu->adev->dev, \"DramBitWidth = 0x%x\\n\", pptable->DramBitWidth);\n\tdev_info(smu->adev->dev, \"PaddingMem1[0] = 0x%x\\n\", pptable->PaddingMem1[0]);\n\tdev_info(smu->adev->dev, \"PaddingMem1[1] = 0x%x\\n\", pptable->PaddingMem1[1]);\n\tdev_info(smu->adev->dev, \"PaddingMem1[2] = 0x%x\\n\", pptable->PaddingMem1[2]);\n\n\tdev_info(smu->adev->dev, \"TotalBoardPower = 0x%x\\n\", pptable->TotalBoardPower);\n\tdev_info(smu->adev->dev, \"BoardPowerPadding = 0x%x\\n\", pptable->BoardPowerPadding);\n\n\tdev_info(smu->adev->dev, \"XgmiLinkSpeed\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiLinkSpeed[i]);\n\tdev_info(smu->adev->dev, \"XgmiLinkWidth\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiLinkWidth[i]);\n\tdev_info(smu->adev->dev, \"XgmiFclkFreq\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiFclkFreq[i]);\n\tdev_info(smu->adev->dev, \"XgmiSocVoltage\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiSocVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"HsrEnabled = 0x%x\\n\", pptable->HsrEnabled);\n\tdev_info(smu->adev->dev, \"VddqOffEnabled = 0x%x\\n\", pptable->VddqOffEnabled);\n\tdev_info(smu->adev->dev, \"PaddingUmcFlags[0] = 0x%x\\n\", pptable->PaddingUmcFlags[0]);\n\tdev_info(smu->adev->dev, \"PaddingUmcFlags[1] = 0x%x\\n\", pptable->PaddingUmcFlags[1]);\n\n\tdev_info(smu->adev->dev, \"BoardReserved[0] = 0x%x\\n\", pptable->BoardReserved[0]);\n\tdev_info(smu->adev->dev, \"BoardReserved[1] = 0x%x\\n\", pptable->BoardReserved[1]);\n\tdev_info(smu->adev->dev, \"BoardReserved[2] = 0x%x\\n\", pptable->BoardReserved[2]);\n\tdev_info(smu->adev->dev, \"BoardReserved[3] = 0x%x\\n\", pptable->BoardReserved[3]);\n\tdev_info(smu->adev->dev, \"BoardReserved[4] = 0x%x\\n\", pptable->BoardReserved[4]);\n\tdev_info(smu->adev->dev, \"BoardReserved[5] = 0x%x\\n\", pptable->BoardReserved[5]);\n\tdev_info(smu->adev->dev, \"BoardReserved[6] = 0x%x\\n\", pptable->BoardReserved[6]);\n\tdev_info(smu->adev->dev, \"BoardReserved[7] = 0x%x\\n\", pptable->BoardReserved[7]);\n\tdev_info(smu->adev->dev, \"BoardReserved[8] = 0x%x\\n\", pptable->BoardReserved[8]);\n\tdev_info(smu->adev->dev, \"BoardReserved[9] = 0x%x\\n\", pptable->BoardReserved[9]);\n\tdev_info(smu->adev->dev, \"BoardReserved[10] = 0x%x\\n\", pptable->BoardReserved[10]);\n\n\tdev_info(smu->adev->dev, \"MmHubPadding[0] = 0x%x\\n\", pptable->MmHubPadding[0]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[1] = 0x%x\\n\", pptable->MmHubPadding[1]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[2] = 0x%x\\n\", pptable->MmHubPadding[2]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[3] = 0x%x\\n\", pptable->MmHubPadding[3]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[4] = 0x%x\\n\", pptable->MmHubPadding[4]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[5] = 0x%x\\n\", pptable->MmHubPadding[5]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[6] = 0x%x\\n\", pptable->MmHubPadding[6]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[7] = 0x%x\\n\", pptable->MmHubPadding[7]);\n}\n\nstatic void sienna_cichlid_dump_pptable(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tPPTable_t *pptable = table_context->driver_pptable;\n\tint i;\n\n\tif (smu->adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 13)) {\n\t\tbeige_goby_dump_pptable(smu);\n\t\treturn;\n\t}\n\n\tdev_info(smu->adev->dev, \"Dumped PPTable:\\n\");\n\n\tdev_info(smu->adev->dev, \"Version = 0x%08x\\n\", pptable->Version);\n\tdev_info(smu->adev->dev, \"FeaturesToRun[0] = 0x%08x\\n\", pptable->FeaturesToRun[0]);\n\tdev_info(smu->adev->dev, \"FeaturesToRun[1] = 0x%08x\\n\", pptable->FeaturesToRun[1]);\n\n\tfor (i = 0; i < PPT_THROTTLER_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitAc[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitAc[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitAcTau[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitAcTau[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitDc[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitDc[i]);\n\t\tdev_info(smu->adev->dev, \"SocketPowerLimitDcTau[%d] = 0x%x\\n\", i, pptable->SocketPowerLimitDcTau[i]);\n\t}\n\n\tfor (i = 0; i < TDC_THROTTLER_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"TdcLimit[%d] = 0x%x\\n\", i, pptable->TdcLimit[i]);\n\t\tdev_info(smu->adev->dev, \"TdcLimitTau[%d] = 0x%x\\n\", i, pptable->TdcLimitTau[i]);\n\t}\n\n\tfor (i = 0; i < TEMP_COUNT; i++) {\n\t\tdev_info(smu->adev->dev, \"TemperatureLimit[%d] = 0x%x\\n\", i, pptable->TemperatureLimit[i]);\n\t}\n\n\tdev_info(smu->adev->dev, \"FitLimit = 0x%x\\n\", pptable->FitLimit);\n\tdev_info(smu->adev->dev, \"TotalPowerConfig = 0x%x\\n\", pptable->TotalPowerConfig);\n\tdev_info(smu->adev->dev, \"TotalPowerPadding[0] = 0x%x\\n\", pptable->TotalPowerPadding[0]);\n\tdev_info(smu->adev->dev, \"TotalPowerPadding[1] = 0x%x\\n\", pptable->TotalPowerPadding[1]);\n\tdev_info(smu->adev->dev, \"TotalPowerPadding[2] = 0x%x\\n\", pptable->TotalPowerPadding[2]);\n\n\tdev_info(smu->adev->dev, \"ApccPlusResidencyLimit = 0x%x\\n\", pptable->ApccPlusResidencyLimit);\n\tfor (i = 0; i < NUM_SMNCLK_DPM_LEVELS; i++) {\n\t\tdev_info(smu->adev->dev, \"SmnclkDpmFreq[%d] = 0x%x\\n\", i, pptable->SmnclkDpmFreq[i]);\n\t\tdev_info(smu->adev->dev, \"SmnclkDpmVoltage[%d] = 0x%x\\n\", i, pptable->SmnclkDpmVoltage[i]);\n\t}\n\tdev_info(smu->adev->dev, \"ThrottlerControlMask = 0x%x\\n\", pptable->ThrottlerControlMask);\n\n\tdev_info(smu->adev->dev, \"FwDStateMask = 0x%x\\n\", pptable->FwDStateMask);\n\n\tdev_info(smu->adev->dev, \"UlvVoltageOffsetSoc = 0x%x\\n\", pptable->UlvVoltageOffsetSoc);\n\tdev_info(smu->adev->dev, \"UlvVoltageOffsetGfx = 0x%x\\n\", pptable->UlvVoltageOffsetGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageUlvGfx = 0x%x\\n\", pptable->MinVoltageUlvGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageUlvSoc = 0x%x\\n\", pptable->MinVoltageUlvSoc);\n\n\tdev_info(smu->adev->dev, \"SocLIVmin = 0x%x\\n\", pptable->SocLIVmin);\n\tdev_info(smu->adev->dev, \"PaddingLIVmin = 0x%x\\n\", pptable->PaddingLIVmin);\n\n\tdev_info(smu->adev->dev, \"GceaLinkMgrIdleThreshold = 0x%x\\n\", pptable->GceaLinkMgrIdleThreshold);\n\tdev_info(smu->adev->dev, \"paddingRlcUlvParams[0] = 0x%x\\n\", pptable->paddingRlcUlvParams[0]);\n\tdev_info(smu->adev->dev, \"paddingRlcUlvParams[1] = 0x%x\\n\", pptable->paddingRlcUlvParams[1]);\n\tdev_info(smu->adev->dev, \"paddingRlcUlvParams[2] = 0x%x\\n\", pptable->paddingRlcUlvParams[2]);\n\n\tdev_info(smu->adev->dev, \"MinVoltageGfx = 0x%x\\n\", pptable->MinVoltageGfx);\n\tdev_info(smu->adev->dev, \"MinVoltageSoc = 0x%x\\n\", pptable->MinVoltageSoc);\n\tdev_info(smu->adev->dev, \"MaxVoltageGfx = 0x%x\\n\", pptable->MaxVoltageGfx);\n\tdev_info(smu->adev->dev, \"MaxVoltageSoc = 0x%x\\n\", pptable->MaxVoltageSoc);\n\n\tdev_info(smu->adev->dev, \"LoadLineResistanceGfx = 0x%x\\n\", pptable->LoadLineResistanceGfx);\n\tdev_info(smu->adev->dev, \"LoadLineResistanceSoc = 0x%x\\n\", pptable->LoadLineResistanceSoc);\n\n\tdev_info(smu->adev->dev, \"VDDGFX_TVmin = 0x%x\\n\", pptable->VDDGFX_TVmin);\n\tdev_info(smu->adev->dev, \"VDDSOC_TVmin = 0x%x\\n\", pptable->VDDSOC_TVmin);\n\tdev_info(smu->adev->dev, \"VDDGFX_Vmin_HiTemp = 0x%x\\n\", pptable->VDDGFX_Vmin_HiTemp);\n\tdev_info(smu->adev->dev, \"VDDGFX_Vmin_LoTemp = 0x%x\\n\", pptable->VDDGFX_Vmin_LoTemp);\n\tdev_info(smu->adev->dev, \"VDDSOC_Vmin_HiTemp = 0x%x\\n\", pptable->VDDSOC_Vmin_HiTemp);\n\tdev_info(smu->adev->dev, \"VDDSOC_Vmin_LoTemp = 0x%x\\n\", pptable->VDDSOC_Vmin_LoTemp);\n\tdev_info(smu->adev->dev, \"VDDGFX_TVminHystersis = 0x%x\\n\", pptable->VDDGFX_TVminHystersis);\n\tdev_info(smu->adev->dev, \"VDDSOC_TVminHystersis = 0x%x\\n\", pptable->VDDSOC_TVminHystersis);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_GFXCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_GFXCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_SOCCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_SOCCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_UCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_UCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_FCLK]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_FCLK].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_DCLK_0]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_0].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_VCLK_0]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_0].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_DCLK_1]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_DCLK_1].Padding16);\n\n\tdev_info(smu->adev->dev, \"[PPCLK_VCLK_1]\\n\"\n\t\t\t\"  .VoltageMode          = 0x%02x\\n\"\n\t\t\t\"  .SnapToDiscrete       = 0x%02x\\n\"\n\t\t\t\"  .NumDiscreteLevels    = 0x%02x\\n\"\n\t\t\t\"  .padding              = 0x%02x\\n\"\n\t\t\t\"  .ConversionToAvfsClk{m = 0x%08x b = 0x%08x}\\n\"\n\t\t\t\"  .SsCurve            {a = 0x%08x b = 0x%08x c = 0x%08x}\\n\"\n\t\t\t\"  .SsFmin               = 0x%04x\\n\"\n\t\t\t\"  .Padding_16           = 0x%04x\\n\",\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].VoltageMode,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SnapToDiscrete,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].NumDiscreteLevels,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].Padding,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].ConversionToAvfsClk.m,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].ConversionToAvfsClk.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsCurve.a,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsCurve.b,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsCurve.c,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].SsFmin,\n\t\t\tpptable->DpmDescriptor[PPCLK_VCLK_1].Padding16);\n\n\tdev_info(smu->adev->dev, \"FreqTableGfx\\n\");\n\tfor (i = 0; i < NUM_GFXCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableGfx[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableVclk\\n\");\n\tfor (i = 0; i < NUM_VCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableVclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableDclk\\n\");\n\tfor (i = 0; i < NUM_DCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableDclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableSocclk\\n\");\n\tfor (i = 0; i < NUM_SOCCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableSocclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableUclk\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableUclk[i]);\n\n\tdev_info(smu->adev->dev, \"FreqTableFclk\\n\");\n\tfor (i = 0; i < NUM_FCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%02d] = 0x%x\\n\", i, pptable->FreqTableFclk[i]);\n\n\tdev_info(smu->adev->dev, \"DcModeMaxFreq\\n\");\n\tdev_info(smu->adev->dev, \"  .PPCLK_GFXCLK = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_GFXCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_SOCCLK = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_SOCCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_UCLK   = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_UCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_FCLK   = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_FCLK]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_DCLK_0 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_DCLK_0]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_VCLK_0 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_VCLK_0]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_DCLK_1 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_DCLK_1]);\n\tdev_info(smu->adev->dev, \"  .PPCLK_VCLK_1 = 0x%x\\n\", pptable->DcModeMaxFreq[PPCLK_VCLK_1]);\n\n\tdev_info(smu->adev->dev, \"FreqTableUclkDiv\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->FreqTableUclkDiv[i]);\n\n\tdev_info(smu->adev->dev, \"FclkBoostFreq = 0x%x\\n\", pptable->FclkBoostFreq);\n\tdev_info(smu->adev->dev, \"FclkParamPadding = 0x%x\\n\", pptable->FclkParamPadding);\n\n\tdev_info(smu->adev->dev, \"Mp0clkFreq\\n\");\n\tfor (i = 0; i < NUM_MP0CLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->Mp0clkFreq[i]);\n\n\tdev_info(smu->adev->dev, \"Mp0DpmVoltage\\n\");\n\tfor (i = 0; i < NUM_MP0CLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->Mp0DpmVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"MemVddciVoltage\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->MemVddciVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"MemMvddVoltage\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->MemMvddVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"GfxclkFgfxoffEntry = 0x%x\\n\", pptable->GfxclkFgfxoffEntry);\n\tdev_info(smu->adev->dev, \"GfxclkFinit = 0x%x\\n\", pptable->GfxclkFinit);\n\tdev_info(smu->adev->dev, \"GfxclkFidle = 0x%x\\n\", pptable->GfxclkFidle);\n\tdev_info(smu->adev->dev, \"GfxclkSource = 0x%x\\n\", pptable->GfxclkSource);\n\tdev_info(smu->adev->dev, \"GfxclkPadding = 0x%x\\n\", pptable->GfxclkPadding);\n\n\tdev_info(smu->adev->dev, \"GfxGpoSubFeatureMask = 0x%x\\n\", pptable->GfxGpoSubFeatureMask);\n\n\tdev_info(smu->adev->dev, \"GfxGpoEnabledWorkPolicyMask = 0x%x\\n\", pptable->GfxGpoEnabledWorkPolicyMask);\n\tdev_info(smu->adev->dev, \"GfxGpoDisabledWorkPolicyMask = 0x%x\\n\", pptable->GfxGpoDisabledWorkPolicyMask);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding[0] = 0x%x\\n\", pptable->GfxGpoPadding[0]);\n\tdev_info(smu->adev->dev, \"GfxGpoVotingAllow = 0x%x\\n\", pptable->GfxGpoVotingAllow);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[0] = 0x%x\\n\", pptable->GfxGpoPadding32[0]);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[1] = 0x%x\\n\", pptable->GfxGpoPadding32[1]);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[2] = 0x%x\\n\", pptable->GfxGpoPadding32[2]);\n\tdev_info(smu->adev->dev, \"GfxGpoPadding32[3] = 0x%x\\n\", pptable->GfxGpoPadding32[3]);\n\tdev_info(smu->adev->dev, \"GfxDcsFopt = 0x%x\\n\", pptable->GfxDcsFopt);\n\tdev_info(smu->adev->dev, \"GfxDcsFclkFopt = 0x%x\\n\", pptable->GfxDcsFclkFopt);\n\tdev_info(smu->adev->dev, \"GfxDcsUclkFopt = 0x%x\\n\", pptable->GfxDcsUclkFopt);\n\n\tdev_info(smu->adev->dev, \"DcsGfxOffVoltage = 0x%x\\n\", pptable->DcsGfxOffVoltage);\n\tdev_info(smu->adev->dev, \"DcsMinGfxOffTime = 0x%x\\n\", pptable->DcsMinGfxOffTime);\n\tdev_info(smu->adev->dev, \"DcsMaxGfxOffTime = 0x%x\\n\", pptable->DcsMaxGfxOffTime);\n\tdev_info(smu->adev->dev, \"DcsMinCreditAccum = 0x%x\\n\", pptable->DcsMinCreditAccum);\n\tdev_info(smu->adev->dev, \"DcsExitHysteresis = 0x%x\\n\", pptable->DcsExitHysteresis);\n\tdev_info(smu->adev->dev, \"DcsTimeout = 0x%x\\n\", pptable->DcsTimeout);\n\n\tdev_info(smu->adev->dev, \"DcsParamPadding[0] = 0x%x\\n\", pptable->DcsParamPadding[0]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[1] = 0x%x\\n\", pptable->DcsParamPadding[1]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[2] = 0x%x\\n\", pptable->DcsParamPadding[2]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[3] = 0x%x\\n\", pptable->DcsParamPadding[3]);\n\tdev_info(smu->adev->dev, \"DcsParamPadding[4] = 0x%x\\n\", pptable->DcsParamPadding[4]);\n\n\tdev_info(smu->adev->dev, \"FlopsPerByteTable\\n\");\n\tfor (i = 0; i < RLC_PACE_TABLE_NUM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->FlopsPerByteTable[i]);\n\n\tdev_info(smu->adev->dev, \"LowestUclkReservedForUlv = 0x%x\\n\", pptable->LowestUclkReservedForUlv);\n\tdev_info(smu->adev->dev, \"vddingMem[0] = 0x%x\\n\", pptable->PaddingMem[0]);\n\tdev_info(smu->adev->dev, \"vddingMem[1] = 0x%x\\n\", pptable->PaddingMem[1]);\n\tdev_info(smu->adev->dev, \"vddingMem[2] = 0x%x\\n\", pptable->PaddingMem[2]);\n\n\tdev_info(smu->adev->dev, \"UclkDpmPstates\\n\");\n\tfor (i = 0; i < NUM_UCLK_DPM_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->UclkDpmPstates[i]);\n\n\tdev_info(smu->adev->dev, \"UclkDpmSrcFreqRange\\n\");\n\tdev_info(smu->adev->dev, \"  .Fmin = 0x%x\\n\",\n\t\tpptable->UclkDpmSrcFreqRange.Fmin);\n\tdev_info(smu->adev->dev, \"  .Fmax = 0x%x\\n\",\n\t\tpptable->UclkDpmSrcFreqRange.Fmax);\n\tdev_info(smu->adev->dev, \"UclkDpmTargFreqRange\\n\");\n\tdev_info(smu->adev->dev, \"  .Fmin = 0x%x\\n\",\n\t\tpptable->UclkDpmTargFreqRange.Fmin);\n\tdev_info(smu->adev->dev, \"  .Fmax = 0x%x\\n\",\n\t\tpptable->UclkDpmTargFreqRange.Fmax);\n\tdev_info(smu->adev->dev, \"UclkDpmMidstepFreq = 0x%x\\n\", pptable->UclkDpmMidstepFreq);\n\tdev_info(smu->adev->dev, \"UclkMidstepPadding = 0x%x\\n\", pptable->UclkMidstepPadding);\n\n\tdev_info(smu->adev->dev, \"PcieGenSpeed\\n\");\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->PcieGenSpeed[i]);\n\n\tdev_info(smu->adev->dev, \"PcieLaneCount\\n\");\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->PcieLaneCount[i]);\n\n\tdev_info(smu->adev->dev, \"LclkFreq\\n\");\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->LclkFreq[i]);\n\n\tdev_info(smu->adev->dev, \"FanStopTemp = 0x%x\\n\", pptable->FanStopTemp);\n\tdev_info(smu->adev->dev, \"FanStartTemp = 0x%x\\n\", pptable->FanStartTemp);\n\n\tdev_info(smu->adev->dev, \"FanGain\\n\");\n\tfor (i = 0; i < TEMP_COUNT; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->FanGain[i]);\n\n\tdev_info(smu->adev->dev, \"FanPwmMin = 0x%x\\n\", pptable->FanPwmMin);\n\tdev_info(smu->adev->dev, \"FanAcousticLimitRpm = 0x%x\\n\", pptable->FanAcousticLimitRpm);\n\tdev_info(smu->adev->dev, \"FanThrottlingRpm = 0x%x\\n\", pptable->FanThrottlingRpm);\n\tdev_info(smu->adev->dev, \"FanMaximumRpm = 0x%x\\n\", pptable->FanMaximumRpm);\n\tdev_info(smu->adev->dev, \"MGpuFanBoostLimitRpm = 0x%x\\n\", pptable->MGpuFanBoostLimitRpm);\n\tdev_info(smu->adev->dev, \"FanTargetTemperature = 0x%x\\n\", pptable->FanTargetTemperature);\n\tdev_info(smu->adev->dev, \"FanTargetGfxclk = 0x%x\\n\", pptable->FanTargetGfxclk);\n\tdev_info(smu->adev->dev, \"FanPadding16 = 0x%x\\n\", pptable->FanPadding16);\n\tdev_info(smu->adev->dev, \"FanTempInputSelect = 0x%x\\n\", pptable->FanTempInputSelect);\n\tdev_info(smu->adev->dev, \"FanPadding = 0x%x\\n\", pptable->FanPadding);\n\tdev_info(smu->adev->dev, \"FanZeroRpmEnable = 0x%x\\n\", pptable->FanZeroRpmEnable);\n\tdev_info(smu->adev->dev, \"FanTachEdgePerRev = 0x%x\\n\", pptable->FanTachEdgePerRev);\n\n\tdev_info(smu->adev->dev, \"FuzzyFan_ErrorSetDelta = 0x%x\\n\", pptable->FuzzyFan_ErrorSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_ErrorRateSetDelta = 0x%x\\n\", pptable->FuzzyFan_ErrorRateSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_PwmSetDelta = 0x%x\\n\", pptable->FuzzyFan_PwmSetDelta);\n\tdev_info(smu->adev->dev, \"FuzzyFan_Reserved = 0x%x\\n\", pptable->FuzzyFan_Reserved);\n\n\tdev_info(smu->adev->dev, \"OverrideAvfsGb[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->OverrideAvfsGb[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"OverrideAvfsGb[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->OverrideAvfsGb[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxDfllModelSelect = 0x%x\\n\", pptable->dBtcGbGfxDfllModelSelect);\n\tdev_info(smu->adev->dev, \"Padding8_Avfs = 0x%x\\n\", pptable->Padding8_Avfs);\n\n\tdev_info(smu->adev->dev, \"qAvfsGb[AVFS_VOLTAGE_GFX]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_GFX].a,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_GFX].b,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_GFX].c);\n\tdev_info(smu->adev->dev, \"qAvfsGb[AVFS_VOLTAGE_SOC]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_SOC].a,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_SOC].b,\n\t\t\tpptable->qAvfsGb[AVFS_VOLTAGE_SOC].c);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxPll{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbGfxPll.a,\n\t\t\tpptable->dBtcGbGfxPll.b,\n\t\t\tpptable->dBtcGbGfxPll.c);\n\tdev_info(smu->adev->dev, \"dBtcGbGfxAfll{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbGfxDfll.a,\n\t\t\tpptable->dBtcGbGfxDfll.b,\n\t\t\tpptable->dBtcGbGfxDfll.c);\n\tdev_info(smu->adev->dev, \"dBtcGbSoc{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->dBtcGbSoc.a,\n\t\t\tpptable->dBtcGbSoc.b,\n\t\t\tpptable->dBtcGbSoc.c);\n\tdev_info(smu->adev->dev, \"qAgingGb[AVFS_VOLTAGE_GFX]{m = 0x%x b = 0x%x}\\n\",\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_GFX].m,\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_GFX].b);\n\tdev_info(smu->adev->dev, \"qAgingGb[AVFS_VOLTAGE_SOC]{m = 0x%x b = 0x%x}\\n\",\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_SOC].m,\n\t\t\tpptable->qAgingGb[AVFS_VOLTAGE_SOC].b);\n\n\tdev_info(smu->adev->dev, \"PiecewiseLinearDroopIntGfxDfll\\n\");\n\tfor (i = 0; i < NUM_PIECE_WISE_LINEAR_DROOP_MODEL_VF_POINTS; i++) {\n\t\tdev_info(smu->adev->dev, \"\t\tFset[%d] = 0x%x\\n\",\n\t\t\ti, pptable->PiecewiseLinearDroopIntGfxDfll.Fset[i]);\n\t\tdev_info(smu->adev->dev, \"\t\tVdroop[%d] = 0x%x\\n\",\n\t\t\ti, pptable->PiecewiseLinearDroopIntGfxDfll.Vdroop[i]);\n\t}\n\n\tdev_info(smu->adev->dev, \"qStaticVoltageOffset[AVFS_VOLTAGE_GFX]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].a,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].b,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_GFX].c);\n\tdev_info(smu->adev->dev, \"qStaticVoltageOffset[AVFS_VOLTAGE_SOC]{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].a,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].b,\n\t\t\tpptable->qStaticVoltageOffset[AVFS_VOLTAGE_SOC].c);\n\n\tdev_info(smu->adev->dev, \"DcTol[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcTol[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcTol[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcTol[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"DcBtcEnabled[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcEnabled[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcEnabled[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcEnabled[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"Padding8_GfxBtc[0] = 0x%x\\n\", pptable->Padding8_GfxBtc[0]);\n\tdev_info(smu->adev->dev, \"Padding8_GfxBtc[1] = 0x%x\\n\", pptable->Padding8_GfxBtc[1]);\n\n\tdev_info(smu->adev->dev, \"DcBtcMin[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcMin[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcMin[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcMin[AVFS_VOLTAGE_SOC]);\n\tdev_info(smu->adev->dev, \"DcBtcMax[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcMax[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcMax[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcMax[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"DcBtcGb[AVFS_VOLTAGE_GFX] = 0x%x\\n\", pptable->DcBtcGb[AVFS_VOLTAGE_GFX]);\n\tdev_info(smu->adev->dev, \"DcBtcGb[AVFS_VOLTAGE_SOC] = 0x%x\\n\", pptable->DcBtcGb[AVFS_VOLTAGE_SOC]);\n\n\tdev_info(smu->adev->dev, \"XgmiDpmPstates\\n\");\n\tfor (i = 0; i < NUM_XGMI_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiDpmPstates[i]);\n\tdev_info(smu->adev->dev, \"XgmiDpmSpare[0] = 0x%02x\\n\", pptable->XgmiDpmSpare[0]);\n\tdev_info(smu->adev->dev, \"XgmiDpmSpare[1] = 0x%02x\\n\", pptable->XgmiDpmSpare[1]);\n\n\tdev_info(smu->adev->dev, \"DebugOverrides = 0x%x\\n\", pptable->DebugOverrides);\n\tdev_info(smu->adev->dev, \"ReservedEquation0{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation0.a,\n\t\t\tpptable->ReservedEquation0.b,\n\t\t\tpptable->ReservedEquation0.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation1{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation1.a,\n\t\t\tpptable->ReservedEquation1.b,\n\t\t\tpptable->ReservedEquation1.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation2{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation2.a,\n\t\t\tpptable->ReservedEquation2.b,\n\t\t\tpptable->ReservedEquation2.c);\n\tdev_info(smu->adev->dev, \"ReservedEquation3{a = 0x%x b = 0x%x c = 0x%x}\\n\",\n\t\t\tpptable->ReservedEquation3.a,\n\t\t\tpptable->ReservedEquation3.b,\n\t\t\tpptable->ReservedEquation3.c);\n\n\tdev_info(smu->adev->dev, \"SkuReserved[0] = 0x%x\\n\", pptable->SkuReserved[0]);\n\tdev_info(smu->adev->dev, \"SkuReserved[1] = 0x%x\\n\", pptable->SkuReserved[1]);\n\tdev_info(smu->adev->dev, \"SkuReserved[2] = 0x%x\\n\", pptable->SkuReserved[2]);\n\tdev_info(smu->adev->dev, \"SkuReserved[3] = 0x%x\\n\", pptable->SkuReserved[3]);\n\tdev_info(smu->adev->dev, \"SkuReserved[4] = 0x%x\\n\", pptable->SkuReserved[4]);\n\tdev_info(smu->adev->dev, \"SkuReserved[5] = 0x%x\\n\", pptable->SkuReserved[5]);\n\tdev_info(smu->adev->dev, \"SkuReserved[6] = 0x%x\\n\", pptable->SkuReserved[6]);\n\tdev_info(smu->adev->dev, \"SkuReserved[7] = 0x%x\\n\", pptable->SkuReserved[7]);\n\n\tdev_info(smu->adev->dev, \"GamingClk[0] = 0x%x\\n\", pptable->GamingClk[0]);\n\tdev_info(smu->adev->dev, \"GamingClk[1] = 0x%x\\n\", pptable->GamingClk[1]);\n\tdev_info(smu->adev->dev, \"GamingClk[2] = 0x%x\\n\", pptable->GamingClk[2]);\n\tdev_info(smu->adev->dev, \"GamingClk[3] = 0x%x\\n\", pptable->GamingClk[3]);\n\tdev_info(smu->adev->dev, \"GamingClk[4] = 0x%x\\n\", pptable->GamingClk[4]);\n\tdev_info(smu->adev->dev, \"GamingClk[5] = 0x%x\\n\", pptable->GamingClk[5]);\n\n\tfor (i = 0; i < NUM_I2C_CONTROLLERS; i++) {\n\t\tdev_info(smu->adev->dev, \"I2cControllers[%d]:\\n\", i);\n\t\tdev_info(smu->adev->dev, \"                   .Enabled = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].Enabled);\n\t\tdev_info(smu->adev->dev, \"                   .Speed = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].Speed);\n\t\tdev_info(smu->adev->dev, \"                   .SlaveAddress = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].SlaveAddress);\n\t\tdev_info(smu->adev->dev, \"                   .ControllerPort = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].ControllerPort);\n\t\tdev_info(smu->adev->dev, \"                   .ControllerName = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].ControllerName);\n\t\tdev_info(smu->adev->dev, \"                   .ThermalThrottler = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].ThermalThrotter);\n\t\tdev_info(smu->adev->dev, \"                   .I2cProtocol = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].I2cProtocol);\n\t\tdev_info(smu->adev->dev, \"                   .PaddingConfig = 0x%x\\n\",\n\t\t\t\tpptable->I2cControllers[i].PaddingConfig);\n\t}\n\n\tdev_info(smu->adev->dev, \"GpioScl = 0x%x\\n\", pptable->GpioScl);\n\tdev_info(smu->adev->dev, \"GpioSda = 0x%x\\n\", pptable->GpioSda);\n\tdev_info(smu->adev->dev, \"FchUsbPdSlaveAddr = 0x%x\\n\", pptable->FchUsbPdSlaveAddr);\n\tdev_info(smu->adev->dev, \"I2cSpare[0] = 0x%x\\n\", pptable->I2cSpare[0]);\n\n\tdev_info(smu->adev->dev, \"Board Parameters:\\n\");\n\tdev_info(smu->adev->dev, \"VddGfxVrMapping = 0x%x\\n\", pptable->VddGfxVrMapping);\n\tdev_info(smu->adev->dev, \"VddSocVrMapping = 0x%x\\n\", pptable->VddSocVrMapping);\n\tdev_info(smu->adev->dev, \"VddMem0VrMapping = 0x%x\\n\", pptable->VddMem0VrMapping);\n\tdev_info(smu->adev->dev, \"VddMem1VrMapping = 0x%x\\n\", pptable->VddMem1VrMapping);\n\tdev_info(smu->adev->dev, \"GfxUlvPhaseSheddingMask = 0x%x\\n\", pptable->GfxUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"SocUlvPhaseSheddingMask = 0x%x\\n\", pptable->SocUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"VddciUlvPhaseSheddingMask = 0x%x\\n\", pptable->VddciUlvPhaseSheddingMask);\n\tdev_info(smu->adev->dev, \"MvddUlvPhaseSheddingMask = 0x%x\\n\", pptable->MvddUlvPhaseSheddingMask);\n\n\tdev_info(smu->adev->dev, \"GfxMaxCurrent = 0x%x\\n\", pptable->GfxMaxCurrent);\n\tdev_info(smu->adev->dev, \"GfxOffset = 0x%x\\n\", pptable->GfxOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryGfx = 0x%x\\n\", pptable->Padding_TelemetryGfx);\n\n\tdev_info(smu->adev->dev, \"SocMaxCurrent = 0x%x\\n\", pptable->SocMaxCurrent);\n\tdev_info(smu->adev->dev, \"SocOffset = 0x%x\\n\", pptable->SocOffset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetrySoc = 0x%x\\n\", pptable->Padding_TelemetrySoc);\n\n\tdev_info(smu->adev->dev, \"Mem0MaxCurrent = 0x%x\\n\", pptable->Mem0MaxCurrent);\n\tdev_info(smu->adev->dev, \"Mem0Offset = 0x%x\\n\", pptable->Mem0Offset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryMem0 = 0x%x\\n\", pptable->Padding_TelemetryMem0);\n\n\tdev_info(smu->adev->dev, \"Mem1MaxCurrent = 0x%x\\n\", pptable->Mem1MaxCurrent);\n\tdev_info(smu->adev->dev, \"Mem1Offset = 0x%x\\n\", pptable->Mem1Offset);\n\tdev_info(smu->adev->dev, \"Padding_TelemetryMem1 = 0x%x\\n\", pptable->Padding_TelemetryMem1);\n\n\tdev_info(smu->adev->dev, \"MvddRatio = 0x%x\\n\", pptable->MvddRatio);\n\n\tdev_info(smu->adev->dev, \"AcDcGpio = 0x%x\\n\", pptable->AcDcGpio);\n\tdev_info(smu->adev->dev, \"AcDcPolarity = 0x%x\\n\", pptable->AcDcPolarity);\n\tdev_info(smu->adev->dev, \"VR0HotGpio = 0x%x\\n\", pptable->VR0HotGpio);\n\tdev_info(smu->adev->dev, \"VR0HotPolarity = 0x%x\\n\", pptable->VR0HotPolarity);\n\tdev_info(smu->adev->dev, \"VR1HotGpio = 0x%x\\n\", pptable->VR1HotGpio);\n\tdev_info(smu->adev->dev, \"VR1HotPolarity = 0x%x\\n\", pptable->VR1HotPolarity);\n\tdev_info(smu->adev->dev, \"GthrGpio = 0x%x\\n\", pptable->GthrGpio);\n\tdev_info(smu->adev->dev, \"GthrPolarity = 0x%x\\n\", pptable->GthrPolarity);\n\tdev_info(smu->adev->dev, \"LedPin0 = 0x%x\\n\", pptable->LedPin0);\n\tdev_info(smu->adev->dev, \"LedPin1 = 0x%x\\n\", pptable->LedPin1);\n\tdev_info(smu->adev->dev, \"LedPin2 = 0x%x\\n\", pptable->LedPin2);\n\tdev_info(smu->adev->dev, \"LedEnableMask = 0x%x\\n\", pptable->LedEnableMask);\n\tdev_info(smu->adev->dev, \"LedPcie = 0x%x\\n\", pptable->LedPcie);\n\tdev_info(smu->adev->dev, \"LedError = 0x%x\\n\", pptable->LedError);\n\tdev_info(smu->adev->dev, \"LedSpare1[0] = 0x%x\\n\", pptable->LedSpare1[0]);\n\tdev_info(smu->adev->dev, \"LedSpare1[1] = 0x%x\\n\", pptable->LedSpare1[1]);\n\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadEnabled = 0x%x\\n\", pptable->PllGfxclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadPercent = 0x%x\\n\", pptable->PllGfxclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"PllGfxclkSpreadFreq = 0x%x\\n\",    pptable->PllGfxclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"DfllGfxclkSpreadEnabled = 0x%x\\n\", pptable->DfllGfxclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"DfllGfxclkSpreadPercent = 0x%x\\n\", pptable->DfllGfxclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"DfllGfxclkSpreadFreq = 0x%x\\n\",    pptable->DfllGfxclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"UclkSpreadPadding = 0x%x\\n\", pptable->UclkSpreadPadding);\n\tdev_info(smu->adev->dev, \"UclkSpreadFreq = 0x%x\\n\", pptable->UclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"FclkSpreadEnabled = 0x%x\\n\", pptable->FclkSpreadEnabled);\n\tdev_info(smu->adev->dev, \"FclkSpreadPercent = 0x%x\\n\", pptable->FclkSpreadPercent);\n\tdev_info(smu->adev->dev, \"FclkSpreadFreq = 0x%x\\n\", pptable->FclkSpreadFreq);\n\n\tdev_info(smu->adev->dev, \"MemoryChannelEnabled = 0x%x\\n\", pptable->MemoryChannelEnabled);\n\tdev_info(smu->adev->dev, \"DramBitWidth = 0x%x\\n\", pptable->DramBitWidth);\n\tdev_info(smu->adev->dev, \"PaddingMem1[0] = 0x%x\\n\", pptable->PaddingMem1[0]);\n\tdev_info(smu->adev->dev, \"PaddingMem1[1] = 0x%x\\n\", pptable->PaddingMem1[1]);\n\tdev_info(smu->adev->dev, \"PaddingMem1[2] = 0x%x\\n\", pptable->PaddingMem1[2]);\n\n\tdev_info(smu->adev->dev, \"TotalBoardPower = 0x%x\\n\", pptable->TotalBoardPower);\n\tdev_info(smu->adev->dev, \"BoardPowerPadding = 0x%x\\n\", pptable->BoardPowerPadding);\n\n\tdev_info(smu->adev->dev, \"XgmiLinkSpeed\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiLinkSpeed[i]);\n\tdev_info(smu->adev->dev, \"XgmiLinkWidth\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiLinkWidth[i]);\n\tdev_info(smu->adev->dev, \"XgmiFclkFreq\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiFclkFreq[i]);\n\tdev_info(smu->adev->dev, \"XgmiSocVoltage\\n\");\n\tfor (i = 0; i < NUM_XGMI_PSTATE_LEVELS; i++)\n\t\tdev_info(smu->adev->dev, \"  .[%d] = 0x%x\\n\", i, pptable->XgmiSocVoltage[i]);\n\n\tdev_info(smu->adev->dev, \"HsrEnabled = 0x%x\\n\", pptable->HsrEnabled);\n\tdev_info(smu->adev->dev, \"VddqOffEnabled = 0x%x\\n\", pptable->VddqOffEnabled);\n\tdev_info(smu->adev->dev, \"PaddingUmcFlags[0] = 0x%x\\n\", pptable->PaddingUmcFlags[0]);\n\tdev_info(smu->adev->dev, \"PaddingUmcFlags[1] = 0x%x\\n\", pptable->PaddingUmcFlags[1]);\n\n\tdev_info(smu->adev->dev, \"BoardReserved[0] = 0x%x\\n\", pptable->BoardReserved[0]);\n\tdev_info(smu->adev->dev, \"BoardReserved[1] = 0x%x\\n\", pptable->BoardReserved[1]);\n\tdev_info(smu->adev->dev, \"BoardReserved[2] = 0x%x\\n\", pptable->BoardReserved[2]);\n\tdev_info(smu->adev->dev, \"BoardReserved[3] = 0x%x\\n\", pptable->BoardReserved[3]);\n\tdev_info(smu->adev->dev, \"BoardReserved[4] = 0x%x\\n\", pptable->BoardReserved[4]);\n\tdev_info(smu->adev->dev, \"BoardReserved[5] = 0x%x\\n\", pptable->BoardReserved[5]);\n\tdev_info(smu->adev->dev, \"BoardReserved[6] = 0x%x\\n\", pptable->BoardReserved[6]);\n\tdev_info(smu->adev->dev, \"BoardReserved[7] = 0x%x\\n\", pptable->BoardReserved[7]);\n\tdev_info(smu->adev->dev, \"BoardReserved[8] = 0x%x\\n\", pptable->BoardReserved[8]);\n\tdev_info(smu->adev->dev, \"BoardReserved[9] = 0x%x\\n\", pptable->BoardReserved[9]);\n\tdev_info(smu->adev->dev, \"BoardReserved[10] = 0x%x\\n\", pptable->BoardReserved[10]);\n\n\tdev_info(smu->adev->dev, \"MmHubPadding[0] = 0x%x\\n\", pptable->MmHubPadding[0]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[1] = 0x%x\\n\", pptable->MmHubPadding[1]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[2] = 0x%x\\n\", pptable->MmHubPadding[2]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[3] = 0x%x\\n\", pptable->MmHubPadding[3]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[4] = 0x%x\\n\", pptable->MmHubPadding[4]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[5] = 0x%x\\n\", pptable->MmHubPadding[5]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[6] = 0x%x\\n\", pptable->MmHubPadding[6]);\n\tdev_info(smu->adev->dev, \"MmHubPadding[7] = 0x%x\\n\", pptable->MmHubPadding[7]);\n}\n\nstatic int sienna_cichlid_i2c_xfer(struct i2c_adapter *i2c_adap,\n\t\t\t\t   struct i2c_msg *msg, int num_msgs)\n{\n\tstruct amdgpu_smu_i2c_bus *smu_i2c = i2c_get_adapdata(i2c_adap);\n\tstruct amdgpu_device *adev = smu_i2c->adev;\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *table = &smu_table->driver_table;\n\tSwI2cRequest_t *req, *res = (SwI2cRequest_t *)table->cpu_addr;\n\tint i, j, r, c;\n\tu16 dir;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn -EBUSY;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->I2CcontrollerPort = smu_i2c->port;\n\treq->I2CSpeed = I2C_SPEED_FAST_400K;\n\treq->SlaveAddress = msg[0].addr << 1;  \n\tdir = msg[0].flags & I2C_M_RD;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &req->SwI2cCmds[c];\n\n\t\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\t\t \n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_READWRITE_MASK;\n\t\t\t\tcmd->ReadWriteData = msg[i].buf[j];\n\t\t\t}\n\n\t\t\tif ((dir ^ msg[i].flags) & I2C_M_RD) {\n\t\t\t\t \n\t\t\t\tdir = msg[i].flags & I2C_M_RD;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_RESTART_MASK;\n\t\t\t}\n\n\t\t\treq->NumCmds++;\n\n\t\t\t \n\t\t\tif ((j == msg[i].len - 1) &&\n\t\t\t    ((i == num_msgs - 1) || (msg[i].flags & I2C_M_STOP))) {\n\t\t\t\tcmd->CmdConfig &= ~CMDCONFIG_RESTART_MASK;\n\t\t\t\tcmd->CmdConfig |= CMDCONFIG_STOP_MASK;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&adev->pm.mutex);\n\tr = smu_cmn_update_table(smu, SMU_TABLE_I2C_COMMANDS, 0, req, true);\n\tif (r)\n\t\tgoto fail;\n\n\tfor (c = i = 0; i < num_msgs; i++) {\n\t\tif (!(msg[i].flags & I2C_M_RD)) {\n\t\t\tc += msg[i].len;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < msg[i].len; j++, c++) {\n\t\t\tSwI2cCmd_t *cmd = &res->SwI2cCmds[c];\n\n\t\t\tmsg[i].buf[j] = cmd->ReadWriteData;\n\t\t}\n\t}\n\tr = num_msgs;\nfail:\n\tmutex_unlock(&adev->pm.mutex);\n\tkfree(req);\n\treturn r;\n}\n\nstatic u32 sienna_cichlid_i2c_func(struct i2c_adapter *adap)\n{\n\treturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\n}\n\n\nstatic const struct i2c_algorithm sienna_cichlid_i2c_algo = {\n\t.master_xfer = sienna_cichlid_i2c_xfer,\n\t.functionality = sienna_cichlid_i2c_func,\n};\n\nstatic const struct i2c_adapter_quirks sienna_cichlid_i2c_control_quirks = {\n\t.flags = I2C_AQ_COMB | I2C_AQ_COMB_SAME_ADDR | I2C_AQ_NO_ZERO_LEN,\n\t.max_read_len  = MAX_SW_I2C_COMMANDS,\n\t.max_write_len = MAX_SW_I2C_COMMANDS,\n\t.max_comb_1st_msg_len = 2,\n\t.max_comb_2nd_msg_len = MAX_SW_I2C_COMMANDS - 2,\n};\n\nstatic int sienna_cichlid_i2c_control_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint res, i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\tsmu_i2c->adev = adev;\n\t\tsmu_i2c->port = i;\n\t\tmutex_init(&smu_i2c->mutex);\n\t\tcontrol->owner = THIS_MODULE;\n\t\tcontrol->class = I2C_CLASS_HWMON;\n\t\tcontrol->dev.parent = &adev->pdev->dev;\n\t\tcontrol->algo = &sienna_cichlid_i2c_algo;\n\t\tsnprintf(control->name, sizeof(control->name), \"AMDGPU SMU %d\", i);\n\t\tcontrol->quirks = &sienna_cichlid_i2c_control_quirks;\n\t\ti2c_set_adapdata(control, smu_i2c);\n\n\t\tres = i2c_add_adapter(control);\n\t\tif (res) {\n\t\t\tDRM_ERROR(\"Failed to register hw i2c, err: %d\\n\", res);\n\t\t\tgoto Out_err;\n\t\t}\n\t}\n\t \n\t \n\tadev->pm.ras_eeprom_i2c_bus = &adev->pm.smu_i2c[1].adapter;\n\tadev->pm.fru_eeprom_i2c_bus = &adev->pm.smu_i2c[0].adapter;\n\n\treturn 0;\nOut_err:\n\tfor ( ; i >= 0; i--) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\treturn res;\n}\n\nstatic void sienna_cichlid_i2c_control_fini(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint i;\n\n\tfor (i = 0; i < MAX_SMU_I2C_BUSES; i++) {\n\t\tstruct amdgpu_smu_i2c_bus *smu_i2c = &adev->pm.smu_i2c[i];\n\t\tstruct i2c_adapter *control = &smu_i2c->adapter;\n\n\t\ti2c_del_adapter(control);\n\t}\n\tadev->pm.ras_eeprom_i2c_bus = NULL;\n\tadev->pm.fru_eeprom_i2c_bus = NULL;\n}\n\nstatic ssize_t sienna_cichlid_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v1_3 *gpu_metrics =\n\t\t(struct gpu_metrics_v1_3 *)smu_table->gpu_metrics_table;\n\tSmuMetricsExternal_t metrics_external;\n\tSmuMetrics_t *metrics =\n\t\t&(metrics_external.SmuMetrics);\n\tSmuMetrics_V2_t *metrics_v2 =\n\t\t&(metrics_external.SmuMetrics_V2);\n\tSmuMetrics_V3_t *metrics_v3 =\n\t\t&(metrics_external.SmuMetrics_V3);\n\tstruct amdgpu_device *adev = smu->adev;\n\tbool use_metrics_v2 = false;\n\tbool use_metrics_v3 = false;\n\tuint16_t average_gfx_activity;\n\tint ret = 0;\n\n\tswitch (smu->adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 7):\n\t\tif (smu->smc_fw_version >= 0x3A4900)\n\t\t\tuse_metrics_v3 = true;\n\t\telse if (smu->smc_fw_version >= 0x3A4300)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 11):\n\t\tif (smu->smc_fw_version >= 0x412D00)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 12):\n\t\tif (smu->smc_fw_version >= 0x3B2300)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 13):\n\t\tif (smu->smc_fw_version >= 0x491100)\n\t\t\tuse_metrics_v2 = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\t&metrics_external,\n\t\t\t\t\ttrue);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 1, 3);\n\n\tgpu_metrics->temperature_edge = use_metrics_v3 ? metrics_v3->TemperatureEdge :\n\t\tuse_metrics_v2 ? metrics_v2->TemperatureEdge : metrics->TemperatureEdge;\n\tgpu_metrics->temperature_hotspot = use_metrics_v3 ? metrics_v3->TemperatureHotspot :\n\t\tuse_metrics_v2 ? metrics_v2->TemperatureHotspot : metrics->TemperatureHotspot;\n\tgpu_metrics->temperature_mem = use_metrics_v3 ? metrics_v3->TemperatureMem :\n\t\tuse_metrics_v2 ? metrics_v2->TemperatureMem : metrics->TemperatureMem;\n\tgpu_metrics->temperature_vrgfx = use_metrics_v3 ? metrics_v3->TemperatureVrGfx :\n\t\tuse_metrics_v2 ? metrics_v2->TemperatureVrGfx : metrics->TemperatureVrGfx;\n\tgpu_metrics->temperature_vrsoc = use_metrics_v3 ? metrics_v3->TemperatureVrSoc :\n\t\tuse_metrics_v2 ? metrics_v2->TemperatureVrSoc : metrics->TemperatureVrSoc;\n\tgpu_metrics->temperature_vrmem = use_metrics_v3 ? metrics_v3->TemperatureVrMem0 :\n\t\tuse_metrics_v2 ? metrics_v2->TemperatureVrMem0 : metrics->TemperatureVrMem0;\n\n\tgpu_metrics->average_gfx_activity = use_metrics_v3 ? metrics_v3->AverageGfxActivity :\n\t\tuse_metrics_v2 ? metrics_v2->AverageGfxActivity : metrics->AverageGfxActivity;\n\tgpu_metrics->average_umc_activity = use_metrics_v3 ? metrics_v3->AverageUclkActivity :\n\t\tuse_metrics_v2 ? metrics_v2->AverageUclkActivity : metrics->AverageUclkActivity;\n\tgpu_metrics->average_mm_activity = use_metrics_v3 ?\n\t\t(metrics_v3->VcnUsagePercentage0 + metrics_v3->VcnUsagePercentage1) / 2 :\n\t\tuse_metrics_v2 ? metrics_v2->VcnActivityPercentage : metrics->VcnActivityPercentage;\n\n\tgpu_metrics->average_socket_power = use_metrics_v3 ? metrics_v3->AverageSocketPower :\n\t\tuse_metrics_v2 ? metrics_v2->AverageSocketPower : metrics->AverageSocketPower;\n\tgpu_metrics->energy_accumulator = use_metrics_v3 ? metrics_v3->EnergyAccumulator :\n\t\tuse_metrics_v2 ? metrics_v2->EnergyAccumulator : metrics->EnergyAccumulator;\n\n\tif (metrics->CurrGfxVoltageOffset)\n\t\tgpu_metrics->voltage_gfx =\n\t\t\t(155000 - 625 * metrics->CurrGfxVoltageOffset) / 100;\n\tif (metrics->CurrMemVidOffset)\n\t\tgpu_metrics->voltage_mem =\n\t\t\t(155000 - 625 * metrics->CurrMemVidOffset) / 100;\n\tif (metrics->CurrSocVoltageOffset)\n\t\tgpu_metrics->voltage_soc =\n\t\t\t(155000 - 625 * metrics->CurrSocVoltageOffset) / 100;\n\n\taverage_gfx_activity = use_metrics_v3 ? metrics_v3->AverageGfxActivity :\n\t\tuse_metrics_v2 ? metrics_v2->AverageGfxActivity : metrics->AverageGfxActivity;\n\tif (average_gfx_activity <= SMU_11_0_7_GFX_BUSY_THRESHOLD)\n\t\tgpu_metrics->average_gfxclk_frequency =\n\t\t\tuse_metrics_v3 ? metrics_v3->AverageGfxclkFrequencyPostDs :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageGfxclkFrequencyPostDs :\n\t\t\tmetrics->AverageGfxclkFrequencyPostDs;\n\telse\n\t\tgpu_metrics->average_gfxclk_frequency =\n\t\t\tuse_metrics_v3 ? metrics_v3->AverageGfxclkFrequencyPreDs :\n\t\t\tuse_metrics_v2 ? metrics_v2->AverageGfxclkFrequencyPreDs :\n\t\t\tmetrics->AverageGfxclkFrequencyPreDs;\n\n\tgpu_metrics->average_uclk_frequency =\n\t\tuse_metrics_v3 ? metrics_v3->AverageUclkFrequencyPostDs :\n\t\tuse_metrics_v2 ? metrics_v2->AverageUclkFrequencyPostDs :\n\t\tmetrics->AverageUclkFrequencyPostDs;\n\tgpu_metrics->average_vclk0_frequency = use_metrics_v3 ? metrics_v3->AverageVclk0Frequency :\n\t\tuse_metrics_v2 ? metrics_v2->AverageVclk0Frequency : metrics->AverageVclk0Frequency;\n\tgpu_metrics->average_dclk0_frequency = use_metrics_v3 ? metrics_v3->AverageDclk0Frequency :\n\t\tuse_metrics_v2 ? metrics_v2->AverageDclk0Frequency : metrics->AverageDclk0Frequency;\n\tgpu_metrics->average_vclk1_frequency = use_metrics_v3 ? metrics_v3->AverageVclk1Frequency :\n\t\tuse_metrics_v2 ? metrics_v2->AverageVclk1Frequency : metrics->AverageVclk1Frequency;\n\tgpu_metrics->average_dclk1_frequency = use_metrics_v3 ? metrics_v3->AverageDclk1Frequency :\n\t\tuse_metrics_v2 ? metrics_v2->AverageDclk1Frequency : metrics->AverageDclk1Frequency;\n\n\tgpu_metrics->current_gfxclk = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_GFXCLK] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_GFXCLK] : metrics->CurrClock[PPCLK_GFXCLK];\n\tgpu_metrics->current_socclk = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_SOCCLK] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_SOCCLK] : metrics->CurrClock[PPCLK_SOCCLK];\n\tgpu_metrics->current_uclk = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_UCLK] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_UCLK] : metrics->CurrClock[PPCLK_UCLK];\n\tgpu_metrics->current_vclk0 = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_VCLK_0] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_VCLK_0] : metrics->CurrClock[PPCLK_VCLK_0];\n\tgpu_metrics->current_dclk0 = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_DCLK_0] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_DCLK_0] : metrics->CurrClock[PPCLK_DCLK_0];\n\tgpu_metrics->current_vclk1 = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_VCLK_1] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_VCLK_1] : metrics->CurrClock[PPCLK_VCLK_1];\n\tgpu_metrics->current_dclk1 = use_metrics_v3 ? metrics_v3->CurrClock[PPCLK_DCLK_1] :\n\t\tuse_metrics_v2 ? metrics_v2->CurrClock[PPCLK_DCLK_1] : metrics->CurrClock[PPCLK_DCLK_1];\n\n\tgpu_metrics->throttle_status = sienna_cichlid_get_throttler_status_locked(smu, use_metrics_v3, use_metrics_v2);\n\tgpu_metrics->indep_throttle_status =\n\t\t\tsmu_cmn_get_indep_throttler_status(gpu_metrics->throttle_status,\n\t\t\t\t\t\t\t   sienna_cichlid_throttler_map);\n\n\tgpu_metrics->current_fan_speed = use_metrics_v3 ? metrics_v3->CurrFanSpeed :\n\t\tuse_metrics_v2 ? metrics_v2->CurrFanSpeed : metrics->CurrFanSpeed;\n\n\tif (((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 7)) && smu->smc_fw_version > 0x003A1E00) ||\n\t      ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 11)) && smu->smc_fw_version > 0x00410400)) {\n\t\tgpu_metrics->pcie_link_width = use_metrics_v3 ? metrics_v3->PcieWidth :\n\t\t\tuse_metrics_v2 ? metrics_v2->PcieWidth : metrics->PcieWidth;\n\t\tgpu_metrics->pcie_link_speed = link_speed[use_metrics_v3 ? metrics_v3->PcieRate :\n\t\t\tuse_metrics_v2 ? metrics_v2->PcieRate : metrics->PcieRate];\n\t} else {\n\t\tgpu_metrics->pcie_link_width =\n\t\t\t\tsmu_v11_0_get_current_pcie_link_width(smu);\n\t\tgpu_metrics->pcie_link_speed =\n\t\t\t\tsmu_v11_0_get_current_pcie_link_speed(smu);\n\t}\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v1_3);\n}\n\nstatic int sienna_cichlid_check_ecc_table_support(struct smu_context *smu)\n{\n\tuint32_t if_version = 0xff, smu_version = 0xff;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret)\n\t\treturn -EOPNOTSUPP;\n\n\tif (smu_version < SUPPORT_ECCTABLE_SMU_VERSION)\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic ssize_t sienna_cichlid_get_ecc_info(struct smu_context *smu,\n\t\t\t\t\tvoid *table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tEccInfoTable_t *ecc_table = NULL;\n\tstruct ecc_info_per_ch *ecc_info_per_channel = NULL;\n\tint i, ret = 0;\n\tstruct umc_ecc_info *eccinfo = (struct umc_ecc_info *)table;\n\n\tret = sienna_cichlid_check_ecc_table_support(smu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_cmn_update_table(smu,\n\t\t\t\tSMU_TABLE_ECCINFO,\n\t\t\t\t0,\n\t\t\t\tsmu_table->ecc_table,\n\t\t\t\tfalse);\n\tif (ret) {\n\t\tdev_info(smu->adev->dev, \"Failed to export SMU ecc table!\\n\");\n\t\treturn ret;\n\t}\n\n\tecc_table = (EccInfoTable_t *)smu_table->ecc_table;\n\n\tfor (i = 0; i < SIENNA_CICHLID_UMC_CHANNEL_NUM; i++) {\n\t\tecc_info_per_channel = &(eccinfo->ecc[i]);\n\t\tecc_info_per_channel->ce_count_lo_chip =\n\t\t\tecc_table->EccInfo[i].ce_count_lo_chip;\n\t\tecc_info_per_channel->ce_count_hi_chip =\n\t\t\tecc_table->EccInfo[i].ce_count_hi_chip;\n\t\tecc_info_per_channel->mca_umc_status =\n\t\t\tecc_table->EccInfo[i].mca_umc_status;\n\t\tecc_info_per_channel->mca_umc_addr =\n\t\t\tecc_table->EccInfo[i].mca_umc_addr;\n\t}\n\n\treturn ret;\n}\nstatic int sienna_cichlid_enable_mgpu_fan_boost(struct smu_context *smu)\n{\n\tuint16_t *mgpu_fan_boost_limit_rpm;\n\n\tGET_PPTABLE_MEMBER(MGpuFanBoostLimitRpm, &mgpu_fan_boost_limit_rpm);\n\t \n\tif (*mgpu_fan_boost_limit_rpm == 0)\n\t\treturn 0;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SetMGpuFanBoostLimitRpm,\n\t\t\t\t\t       0,\n\t\t\t\t\t       NULL);\n}\n\nstatic int sienna_cichlid_gpo_control(struct smu_context *smu,\n\t\t\t\t      bool enablement)\n{\n\tuint32_t smu_version;\n\tint ret = 0;\n\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_GFX_GPO_BIT)) {\n\t\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (enablement) {\n\t\t\tif (smu_version < 0x003a2500) {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t      SMU_MSG_SetGpoFeaturePMask,\n\t\t\t\t\t\t\t\t      GFX_GPO_PACE_MASK | GFX_GPO_DEM_MASK,\n\t\t\t\t\t\t\t\t      NULL);\n\t\t\t} else {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t      SMU_MSG_DisallowGpo,\n\t\t\t\t\t\t\t\t      0,\n\t\t\t\t\t\t\t\t      NULL);\n\t\t\t}\n\t\t} else {\n\t\t\tif (smu_version < 0x003a2500) {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t      SMU_MSG_SetGpoFeaturePMask,\n\t\t\t\t\t\t\t\t      0,\n\t\t\t\t\t\t\t\t      NULL);\n\t\t\t} else {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t      SMU_MSG_DisallowGpo,\n\t\t\t\t\t\t\t\t      1,\n\t\t\t\t\t\t\t\t      NULL);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sienna_cichlid_notify_2nd_usb20_port(struct smu_context *smu)\n{\n\tuint32_t smu_version;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, NULL, &smu_version);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (smu_version < 0x003A2D00)\n\t\treturn 0;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_Enable2ndUSB20Port,\n\t\t\t\t\t       smu->smu_table.boot_values.firmware_caps & ATOM_FIRMWARE_CAP_ENABLE_2ND_USB20PORT ?\n\t\t\t\t\t       1 : 0,\n\t\t\t\t\t       NULL);\n}\n\nstatic int sienna_cichlid_system_features_control(struct smu_context *smu,\n\t\t\t\t\t\t  bool en)\n{\n\tint ret = 0;\n\n\tif (en) {\n\t\tret = sienna_cichlid_notify_2nd_usb20_port(smu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn smu_v11_0_system_features_control(smu, en);\n}\n\nstatic int sienna_cichlid_set_mp1_state(struct smu_context *smu,\n\t\t\t\t\tenum pp_mp1_state mp1_state)\n{\n\tint ret;\n\n\tswitch (mp1_state) {\n\tcase PP_MP1_STATE_UNLOAD:\n\t\tret = smu_cmn_set_mp1_state(smu, mp1_state);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void sienna_cichlid_stb_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t reg;\n\n\treg = RREG32_PCIE(MP1_Public | smnMP1_PMI_3_START);\n\tsmu->stb_context.enabled = REG_GET_FIELD(reg, MP1_PMI_3_START, ENABLE);\n\n\t \n\tif (!smu->stb_context.enabled)\n\t\treturn;\n\n\tspin_lock_init(&smu->stb_context.lock);\n\n\t \n\treg = RREG32_PCIE(MP1_Public | smnMP1_PMI_3_FIFO);\n\tsmu->stb_context.stb_buf_size = 1 << REG_GET_FIELD(reg, MP1_PMI_3_FIFO, DEPTH);\n\tsmu->stb_context.stb_buf_size *=  SIENNA_CICHLID_STB_DEPTH_UNIT_BYTES;\n\n\tdev_info(smu->adev->dev, \"STB initialized to %d entries\",\n\t\t smu->stb_context.stb_buf_size / SIENNA_CICHLID_STB_DEPTH_UNIT_BYTES);\n\n}\n\nstatic int sienna_cichlid_get_default_config_table_settings(struct smu_context *smu,\n\t\t\t\t\t\t\t    struct config_table_setting *table)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tif (!table)\n\t\treturn -EINVAL;\n\n\ttable->gfxclk_average_tau = 10;\n\ttable->socclk_average_tau = 10;\n\ttable->fclk_average_tau = 10;\n\ttable->uclk_average_tau = 10;\n\ttable->gfx_activity_average_tau = 10;\n\ttable->mem_activity_average_tau = 10;\n\ttable->socket_power_average_tau = 100;\n\tif (adev->ip_versions[MP1_HWIP][0] != IP_VERSION(11, 0, 7))\n\t\ttable->apu_socket_power_average_tau = 100;\n\n\treturn 0;\n}\n\nstatic int sienna_cichlid_set_config_table(struct smu_context *smu,\n\t\t\t\t\t   struct config_table_setting *table)\n{\n\tDriverSmuConfigExternal_t driver_smu_config_table;\n\n\tif (!table)\n\t\treturn -EINVAL;\n\n\tmemset(&driver_smu_config_table,\n\t       0,\n\t       sizeof(driver_smu_config_table));\n\tdriver_smu_config_table.DriverSmuConfig.GfxclkAverageLpfTau =\n\t\t\t\ttable->gfxclk_average_tau;\n\tdriver_smu_config_table.DriverSmuConfig.FclkAverageLpfTau =\n\t\t\t\ttable->fclk_average_tau;\n\tdriver_smu_config_table.DriverSmuConfig.UclkAverageLpfTau =\n\t\t\t\ttable->uclk_average_tau;\n\tdriver_smu_config_table.DriverSmuConfig.GfxActivityLpfTau =\n\t\t\t\ttable->gfx_activity_average_tau;\n\tdriver_smu_config_table.DriverSmuConfig.UclkActivityLpfTau =\n\t\t\t\ttable->mem_activity_average_tau;\n\tdriver_smu_config_table.DriverSmuConfig.SocketPowerLpfTau =\n\t\t\t\ttable->socket_power_average_tau;\n\n\treturn smu_cmn_update_table(smu,\n\t\t\t\t    SMU_TABLE_DRIVER_SMU_CONFIG,\n\t\t\t\t    0,\n\t\t\t\t    (void *)&driver_smu_config_table,\n\t\t\t\t    true);\n}\n\nstatic int sienna_cichlid_stb_get_data_direct(struct smu_context *smu,\n\t\t\t\t\t      void *buf,\n\t\t\t\t\t      uint32_t size)\n{\n\tuint32_t *p = buf;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\t \n\tspin_lock(&smu->stb_context.lock);\n\n\t \n\tbuf = ((char *) buf) + size;\n\twhile ((void *)p < buf)\n\t\t*p++ = cpu_to_le32(RREG32_PCIE(MP1_Public | smnMP1_PMI_3));\n\n\tspin_unlock(&smu->stb_context.lock);\n\n\treturn 0;\n}\n\nstatic bool sienna_cichlid_is_mode2_reset_supported(struct smu_context *smu)\n{\n\treturn true;\n}\n\nstatic int sienna_cichlid_mode2_reset(struct smu_context *smu)\n{\n\tu32 smu_version;\n\tint ret = 0, index;\n\tstruct amdgpu_device *adev = smu->adev;\n\tint timeout = 100;\n\n\tsmu_cmn_get_smc_version(smu, NULL, &smu_version);\n\n\tindex = smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG,\n\t\t\t\t\t\tSMU_MSG_DriverMode2Reset);\n\n\tmutex_lock(&smu->message_lock);\n\n\tret = smu_cmn_send_msg_without_waiting(smu, (uint16_t)index,\n\t\t\t\t\t       SMU_RESET_MODE_2);\n\n\tret = smu_cmn_wait_for_response(smu);\n\twhile (ret != 0 && timeout) {\n\t\tret = smu_cmn_wait_for_response(smu);\n\t\t \n\t\tif (ret != 0) {\n\t\t\t--timeout;\n\t\t\tusleep_range(500, 1000);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!timeout) {\n\t\tdev_err(adev->dev,\n\t\t\t\"failed to send mode2 message \\tparam: 0x%08x response %#x\\n\",\n\t\t\tSMU_RESET_MODE_2, ret);\n\t\tgoto out;\n\t}\n\n\tdev_info(smu->adev->dev, \"restore config space...\\n\");\n\t \n\tamdgpu_device_load_pci_state(adev->pdev);\nout:\n\tmutex_unlock(&smu->message_lock);\n\n\treturn ret;\n}\n\nstatic const struct pptable_funcs sienna_cichlid_ppt_funcs = {\n\t.get_allowed_feature_mask = sienna_cichlid_get_allowed_feature_mask,\n\t.set_default_dpm_table = sienna_cichlid_set_default_dpm_table,\n\t.dpm_set_vcn_enable = sienna_cichlid_dpm_set_vcn_enable,\n\t.dpm_set_jpeg_enable = sienna_cichlid_dpm_set_jpeg_enable,\n\t.i2c_init = sienna_cichlid_i2c_control_init,\n\t.i2c_fini = sienna_cichlid_i2c_control_fini,\n\t.print_clk_levels = sienna_cichlid_print_clk_levels,\n\t.force_clk_levels = sienna_cichlid_force_clk_levels,\n\t.populate_umd_state_clk = sienna_cichlid_populate_umd_state_clk,\n\t.pre_display_config_changed = sienna_cichlid_pre_display_config_changed,\n\t.display_config_changed = sienna_cichlid_display_config_changed,\n\t.notify_smc_display_config = sienna_cichlid_notify_smc_display_config,\n\t.is_dpm_running = sienna_cichlid_is_dpm_running,\n\t.get_fan_speed_pwm = smu_v11_0_get_fan_speed_pwm,\n\t.get_fan_speed_rpm = sienna_cichlid_get_fan_speed_rpm,\n\t.get_power_profile_mode = sienna_cichlid_get_power_profile_mode,\n\t.set_power_profile_mode = sienna_cichlid_set_power_profile_mode,\n\t.set_watermarks_table = sienna_cichlid_set_watermarks_table,\n\t.read_sensor = sienna_cichlid_read_sensor,\n\t.get_uclk_dpm_states = sienna_cichlid_get_uclk_dpm_states,\n\t.set_performance_level = smu_v11_0_set_performance_level,\n\t.get_thermal_temperature_range = sienna_cichlid_get_thermal_temperature_range,\n\t.display_disable_memory_clock_switch = sienna_cichlid_display_disable_memory_clock_switch,\n\t.get_power_limit = sienna_cichlid_get_power_limit,\n\t.update_pcie_parameters = sienna_cichlid_update_pcie_parameters,\n\t.dump_pptable = sienna_cichlid_dump_pptable,\n\t.init_microcode = smu_v11_0_init_microcode,\n\t.load_microcode = smu_v11_0_load_microcode,\n\t.fini_microcode = smu_v11_0_fini_microcode,\n\t.init_smc_tables = sienna_cichlid_init_smc_tables,\n\t.fini_smc_tables = smu_v11_0_fini_smc_tables,\n\t.init_power = smu_v11_0_init_power,\n\t.fini_power = smu_v11_0_fini_power,\n\t.check_fw_status = smu_v11_0_check_fw_status,\n\t.setup_pptable = sienna_cichlid_setup_pptable,\n\t.get_vbios_bootup_values = smu_v11_0_get_vbios_bootup_values,\n\t.check_fw_version = smu_v11_0_check_fw_version,\n\t.write_pptable = smu_cmn_write_pptable,\n\t.set_driver_table_location = smu_v11_0_set_driver_table_location,\n\t.set_tool_table_location = smu_v11_0_set_tool_table_location,\n\t.notify_memory_pool_location = smu_v11_0_notify_memory_pool_location,\n\t.system_features_control = sienna_cichlid_system_features_control,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.init_display_count = NULL,\n\t.set_allowed_mask = smu_v11_0_set_allowed_mask,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.disable_all_features_with_exception = smu_cmn_disable_all_features_with_exception,\n\t.notify_display_change = NULL,\n\t.set_power_limit = smu_v11_0_set_power_limit,\n\t.init_max_sustainable_clocks = smu_v11_0_init_max_sustainable_clocks,\n\t.enable_thermal_alert = smu_v11_0_enable_thermal_alert,\n\t.disable_thermal_alert = smu_v11_0_disable_thermal_alert,\n\t.set_min_dcef_deep_sleep = NULL,\n\t.display_clock_voltage_request = smu_v11_0_display_clock_voltage_request,\n\t.get_fan_control_mode = smu_v11_0_get_fan_control_mode,\n\t.set_fan_control_mode = smu_v11_0_set_fan_control_mode,\n\t.set_fan_speed_pwm = smu_v11_0_set_fan_speed_pwm,\n\t.set_fan_speed_rpm = smu_v11_0_set_fan_speed_rpm,\n\t.set_xgmi_pstate = smu_v11_0_set_xgmi_pstate,\n\t.gfx_off_control = smu_v11_0_gfx_off_control,\n\t.register_irq_handler = smu_v11_0_register_irq_handler,\n\t.set_azalia_d3_pme = smu_v11_0_set_azalia_d3_pme,\n\t.get_max_sustainable_clocks_by_dc = smu_v11_0_get_max_sustainable_clocks_by_dc,\n\t.baco_is_support = smu_v11_0_baco_is_support,\n\t.baco_get_state = smu_v11_0_baco_get_state,\n\t.baco_set_state = smu_v11_0_baco_set_state,\n\t.baco_enter = sienna_cichlid_baco_enter,\n\t.baco_exit = sienna_cichlid_baco_exit,\n\t.mode1_reset_is_support = sienna_cichlid_is_mode1_reset_supported,\n\t.mode1_reset = smu_v11_0_mode1_reset,\n\t.get_dpm_ultimate_freq = sienna_cichlid_get_dpm_ultimate_freq,\n\t.set_soft_freq_limited_range = smu_v11_0_set_soft_freq_limited_range,\n\t.set_default_od_settings = sienna_cichlid_set_default_od_settings,\n\t.od_edit_dpm_table = sienna_cichlid_od_edit_dpm_table,\n\t.restore_user_od_settings = sienna_cichlid_restore_user_od_settings,\n\t.run_btc = sienna_cichlid_run_btc,\n\t.set_power_source = smu_v11_0_set_power_source,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_pp_feature_mask = smu_cmn_set_pp_feature_mask,\n\t.get_gpu_metrics = sienna_cichlid_get_gpu_metrics,\n\t.enable_mgpu_fan_boost = sienna_cichlid_enable_mgpu_fan_boost,\n\t.gfx_ulv_control = smu_v11_0_gfx_ulv_control,\n\t.deep_sleep_control = smu_v11_0_deep_sleep_control,\n\t.get_fan_parameters = sienna_cichlid_get_fan_parameters,\n\t.interrupt_work = smu_v11_0_interrupt_work,\n\t.gpo_control = sienna_cichlid_gpo_control,\n\t.set_mp1_state = sienna_cichlid_set_mp1_state,\n\t.stb_collect_info = sienna_cichlid_stb_get_data_direct,\n\t.get_ecc_info = sienna_cichlid_get_ecc_info,\n\t.get_default_config_table_settings = sienna_cichlid_get_default_config_table_settings,\n\t.set_config_table = sienna_cichlid_set_config_table,\n\t.get_unique_id = sienna_cichlid_get_unique_id,\n\t.mode2_reset_is_support = sienna_cichlid_is_mode2_reset_supported,\n\t.mode2_reset = sienna_cichlid_mode2_reset,\n};\n\nvoid sienna_cichlid_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &sienna_cichlid_ppt_funcs;\n\tsmu->message_map = sienna_cichlid_message_map;\n\tsmu->clock_map = sienna_cichlid_clk_map;\n\tsmu->feature_map = sienna_cichlid_feature_mask_map;\n\tsmu->table_map = sienna_cichlid_table_map;\n\tsmu->pwr_src_map = sienna_cichlid_pwr_src_map;\n\tsmu->workload_map = sienna_cichlid_workload_map;\n\tsmu_v11_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}