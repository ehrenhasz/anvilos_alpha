{
  "module_name": "smu_v11_0.c",
  "hash_id": "31e48cefdf58c140e830a687539aee730b17c233313e24ce7dd5859bd0aa7c7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu11/smu_v11_0.c",
  "human_readable_source": " \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/reboot.h>\n\n#define SMU_11_0_PARTIAL_PPTABLE\n#define SWSMU_CODE_LAYER_L3\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"atomfirmware.h\"\n#include \"amdgpu_atomfirmware.h\"\n#include \"amdgpu_atombios.h\"\n#include \"smu_v11_0.h\"\n#include \"soc15_common.h\"\n#include \"atom.h\"\n#include \"amdgpu_ras.h\"\n#include \"smu_cmn.h\"\n\n#include \"asic_reg/thm/thm_11_0_2_offset.h\"\n#include \"asic_reg/thm/thm_11_0_2_sh_mask.h\"\n#include \"asic_reg/mp/mp_11_0_offset.h\"\n#include \"asic_reg/mp/mp_11_0_sh_mask.h\"\n#include \"asic_reg/smuio/smuio_11_0_0_offset.h\"\n#include \"asic_reg/smuio/smuio_11_0_0_sh_mask.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\nMODULE_FIRMWARE(\"amdgpu/arcturus_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi10_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi14_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/navi12_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/sienna_cichlid_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/navy_flounder_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/dimgrey_cavefish_smc.bin\");\nMODULE_FIRMWARE(\"amdgpu/beige_goby_smc.bin\");\n\n#define SMU11_VOLTAGE_SCALE 4\n\n#define SMU11_MODE1_RESET_WAIT_TIME_IN_MS 500  \n\n#define smnPCIE_LC_LINK_WIDTH_CNTL\t\t0x11140288\n#define PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK 0x00000070L\n#define PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT 0x4\n#define smnPCIE_LC_SPEED_CNTL\t\t\t0x11140290\n#define PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK 0xC000\n#define PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT 0xE\n\n#define mmTHM_BACO_CNTL_ARCT\t\t\t0xA7\n#define mmTHM_BACO_CNTL_ARCT_BASE_IDX\t\t0\n\nstatic void smu_v11_0_poll_baco_exit(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t data, loop = 0;\n\n\tdo {\n\t\tusleep_range(1000, 1100);\n\t\tdata = RREG32_SOC15(THM, 0, mmTHM_BACO_CNTL);\n\t} while ((data & 0x100) && (++loop < 100));\n}\n\nint smu_v11_0_init_microcode(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tchar ucode_prefix[30];\n\tchar fw_name[SMU_FW_NAME_LEN];\n\tint err = 0;\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tconst struct common_firmware_header *header;\n\tstruct amdgpu_firmware_info *ucode = NULL;\n\n\tif (amdgpu_sriov_vf(adev) &&\n\t    ((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 9)) ||\n\t     (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 7))))\n\t\treturn 0;\n\n\tamdgpu_ucode_ip_version_decode(adev, MP1_HWIP, ucode_prefix, sizeof(ucode_prefix));\n\n\tsnprintf(fw_name, sizeof(fw_name), \"amdgpu/%s.bin\", ucode_prefix);\n\n\terr = amdgpu_ucode_request(adev, &adev->pm.fw, fw_name);\n\tif (err)\n\t\tgoto out;\n\n\thdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\n\tamdgpu_ucode_print_smc_hdr(&hdr->header);\n\tadev->pm.fw_version = le32_to_cpu(hdr->header.ucode_version);\n\n\tif (adev->firmware.load_type == AMDGPU_FW_LOAD_PSP) {\n\t\tucode = &adev->firmware.ucode[AMDGPU_UCODE_ID_SMC];\n\t\tucode->ucode_id = AMDGPU_UCODE_ID_SMC;\n\t\tucode->fw = adev->pm.fw;\n\t\theader = (const struct common_firmware_header *)ucode->fw->data;\n\t\tadev->firmware.fw_size +=\n\t\t\tALIGN(le32_to_cpu(header->ucode_size_bytes), PAGE_SIZE);\n\t}\n\nout:\n\tif (err)\n\t\tamdgpu_ucode_release(&adev->pm.fw);\n\treturn err;\n}\n\nvoid smu_v11_0_fini_microcode(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tamdgpu_ucode_release(&adev->pm.fw);\n\tadev->pm.fw_version = 0;\n}\n\nint smu_v11_0_load_microcode(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tconst uint32_t *src;\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tuint32_t addr_start = MP1_SRAM;\n\tuint32_t i;\n\tuint32_t smc_fw_size;\n\tuint32_t mp1_fw_flags;\n\n\thdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\n\tsrc = (const uint32_t *)(adev->pm.fw->data +\n\t\tle32_to_cpu(hdr->header.ucode_array_offset_bytes));\n\tsmc_fw_size = hdr->header.ucode_size_bytes;\n\n\tfor (i = 1; i < smc_fw_size/4 - 1; i++) {\n\t\tWREG32_PCIE(addr_start, src[i]);\n\t\taddr_start += 4;\n\t}\n\n\tWREG32_PCIE(MP1_Public | (smnMP1_PUB_CTRL & 0xffffffff),\n\t\t1 & MP1_SMN_PUB_CTRL__RESET_MASK);\n\tWREG32_PCIE(MP1_Public | (smnMP1_PUB_CTRL & 0xffffffff),\n\t\t1 & ~MP1_SMN_PUB_CTRL__RESET_MASK);\n\n\tfor (i = 0; i < adev->usec_timeout; i++) {\n\t\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t\t(smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\t\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t\t\tMP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i == adev->usec_timeout)\n\t\treturn -ETIME;\n\n\treturn 0;\n}\n\nint smu_v11_0_check_fw_status(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t mp1_fw_flags;\n\n\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t\t\t   (smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\n\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\treturn 0;\n\n\treturn -EIO;\n}\n\nint smu_v11_0_check_fw_version(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t if_version = 0xff, smu_version = 0xff;\n\tuint8_t smu_program, smu_major, smu_minor, smu_debug;\n\tint ret = 0;\n\n\tret = smu_cmn_get_smc_version(smu, &if_version, &smu_version);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_program = (smu_version >> 24) & 0xff;\n\tsmu_major = (smu_version >> 16) & 0xff;\n\tsmu_minor = (smu_version >> 8) & 0xff;\n\tsmu_debug = (smu_version >> 0) & 0xff;\n\tif (smu->is_apu)\n\t\tadev->pm.fw_version = smu_version;\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_NV10;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 9):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_NV12;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 5):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_NV14;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 7):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_Sienna_Cichlid;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 11):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_Navy_Flounder;\n\t\tbreak;\n\tcase IP_VERSION(11, 5, 0):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_VANGOGH;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 12):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_Dimgrey_Cavefish;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 13):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_Beige_Goby;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 8):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_Cyan_Skillfish;\n\t\tbreak;\n\tcase IP_VERSION(11, 0, 2):\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_ARCT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(smu->adev->dev, \"smu unsupported IP version: 0x%x.\\n\",\n\t\t\tadev->ip_versions[MP1_HWIP][0]);\n\t\tsmu->smc_driver_if_version = SMU11_DRIVER_IF_VERSION_INV;\n\t\tbreak;\n\t}\n\n\t \n\tif (if_version != smu->smc_driver_if_version) {\n\t\tdev_info(smu->adev->dev, \"smu driver if version = 0x%08x, smu fw if version = 0x%08x, \"\n\t\t\t\"smu fw program = %d, version = 0x%08x (%d.%d.%d)\\n\",\n\t\t\tsmu->smc_driver_if_version, if_version,\n\t\t\tsmu_program, smu_version, smu_major, smu_minor, smu_debug);\n\t\tdev_info(smu->adev->dev, \"SMU driver if version not matched\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int smu_v11_0_set_pptable_v2_0(struct smu_context *smu, void **table, uint32_t *size)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t ppt_offset_bytes;\n\tconst struct smc_firmware_header_v2_0 *v2;\n\n\tv2 = (const struct smc_firmware_header_v2_0 *) adev->pm.fw->data;\n\n\tppt_offset_bytes = le32_to_cpu(v2->ppt_offset_bytes);\n\t*size = le32_to_cpu(v2->ppt_size_bytes);\n\t*table = (uint8_t *)v2 + ppt_offset_bytes;\n\n\treturn 0;\n}\n\nstatic int smu_v11_0_set_pptable_v2_1(struct smu_context *smu, void **table,\n\t\t\t\t      uint32_t *size, uint32_t pptable_id)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tconst struct smc_firmware_header_v2_1 *v2_1;\n\tstruct smc_soft_pptable_entry *entries;\n\tuint32_t pptable_count = 0;\n\tint i = 0;\n\n\tv2_1 = (const struct smc_firmware_header_v2_1 *) adev->pm.fw->data;\n\tentries = (struct smc_soft_pptable_entry *)\n\t\t((uint8_t *)v2_1 + le32_to_cpu(v2_1->pptable_entry_offset));\n\tpptable_count = le32_to_cpu(v2_1->pptable_count);\n\tfor (i = 0; i < pptable_count; i++) {\n\t\tif (le32_to_cpu(entries[i].id) == pptable_id) {\n\t\t\t*table = ((uint8_t *)v2_1 + le32_to_cpu(entries[i].ppt_offset_bytes));\n\t\t\t*size = le32_to_cpu(entries[i].ppt_size_bytes);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == pptable_count)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint smu_v11_0_setup_pptable(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tconst struct smc_firmware_header_v1_0 *hdr;\n\tint ret, index;\n\tuint32_t size = 0;\n\tuint16_t atom_table_size;\n\tuint8_t frev, crev;\n\tvoid *table;\n\tuint16_t version_major, version_minor;\n\n\tif (!amdgpu_sriov_vf(adev)) {\n\t\thdr = (const struct smc_firmware_header_v1_0 *) adev->pm.fw->data;\n\t\tversion_major = le16_to_cpu(hdr->header.header_version_major);\n\t\tversion_minor = le16_to_cpu(hdr->header.header_version_minor);\n\t\tif (version_major == 2 && smu->smu_table.boot_values.pp_table_id > 0) {\n\t\t\tdev_info(adev->dev, \"use driver provided pptable %d\\n\", smu->smu_table.boot_values.pp_table_id);\n\t\t\tswitch (version_minor) {\n\t\t\tcase 0:\n\t\t\t\tret = smu_v11_0_set_pptable_v2_0(smu, &table, &size);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tret = smu_v11_0_set_pptable_v2_1(smu, &table, &size,\n\t\t\t\t\t\t\t\tsmu->smu_table.boot_values.pp_table_id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev_info(adev->dev, \"use vbios provided pptable\\n\");\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t\tpowerplayinfo);\n\n\tret = amdgpu_atombios_get_data_table(adev, index, &atom_table_size, &frev, &crev,\n\t\t\t\t\t\t(uint8_t **)&table);\n\tif (ret)\n\t\treturn ret;\n\tsize = atom_table_size;\n\nout:\n\tif (!smu->smu_table.power_play_table)\n\t\tsmu->smu_table.power_play_table = table;\n\tif (!smu->smu_table.power_play_table_size)\n\t\tsmu->smu_table.power_play_table_size = size;\n\n\treturn 0;\n}\n\nint smu_v11_0_init_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\tint ret = 0;\n\n\tsmu_table->driver_pptable =\n\t\tkzalloc(tables[SMU_TABLE_PPTABLE].size, GFP_KERNEL);\n\tif (!smu_table->driver_pptable) {\n\t\tret = -ENOMEM;\n\t\tgoto err0_out;\n\t}\n\n\tsmu_table->max_sustainable_clocks =\n\t\tkzalloc(sizeof(struct smu_11_0_max_sustainable_clocks), GFP_KERNEL);\n\tif (!smu_table->max_sustainable_clocks) {\n\t\tret = -ENOMEM;\n\t\tgoto err1_out;\n\t}\n\n\t \n\tif (tables[SMU_TABLE_OVERDRIVE].size) {\n\t\tsmu_table->overdrive_table =\n\t\t\tkzalloc(tables[SMU_TABLE_OVERDRIVE].size, GFP_KERNEL);\n\t\tif (!smu_table->overdrive_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err2_out;\n\t\t}\n\n\t\tsmu_table->boot_overdrive_table =\n\t\t\tkzalloc(tables[SMU_TABLE_OVERDRIVE].size, GFP_KERNEL);\n\t\tif (!smu_table->boot_overdrive_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err3_out;\n\t\t}\n\n\t\tsmu_table->user_overdrive_table =\n\t\t\tkzalloc(tables[SMU_TABLE_OVERDRIVE].size, GFP_KERNEL);\n\t\tif (!smu_table->user_overdrive_table) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err4_out;\n\t\t}\n\n\t}\n\n\treturn 0;\n\nerr4_out:\n\tkfree(smu_table->boot_overdrive_table);\nerr3_out:\n\tkfree(smu_table->overdrive_table);\nerr2_out:\n\tkfree(smu_table->max_sustainable_clocks);\nerr1_out:\n\tkfree(smu_table->driver_pptable);\nerr0_out:\n\treturn ret;\n}\n\nint smu_v11_0_fini_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_dpm_context *smu_dpm = &smu->smu_dpm;\n\n\tkfree(smu_table->gpu_metrics_table);\n\tkfree(smu_table->user_overdrive_table);\n\tkfree(smu_table->boot_overdrive_table);\n\tkfree(smu_table->overdrive_table);\n\tkfree(smu_table->max_sustainable_clocks);\n\tkfree(smu_table->driver_pptable);\n\tkfree(smu_table->clocks_table);\n\tsmu_table->gpu_metrics_table = NULL;\n\tsmu_table->user_overdrive_table = NULL;\n\tsmu_table->boot_overdrive_table = NULL;\n\tsmu_table->overdrive_table = NULL;\n\tsmu_table->max_sustainable_clocks = NULL;\n\tsmu_table->driver_pptable = NULL;\n\tsmu_table->clocks_table = NULL;\n\tkfree(smu_table->hardcode_pptable);\n\tsmu_table->hardcode_pptable = NULL;\n\n\tkfree(smu_table->driver_smu_config_table);\n\tkfree(smu_table->ecc_table);\n\tkfree(smu_table->metrics_table);\n\tkfree(smu_table->watermarks_table);\n\tsmu_table->driver_smu_config_table = NULL;\n\tsmu_table->ecc_table = NULL;\n\tsmu_table->metrics_table = NULL;\n\tsmu_table->watermarks_table = NULL;\n\tsmu_table->metrics_time = 0;\n\n\tkfree(smu_dpm->dpm_context);\n\tkfree(smu_dpm->golden_dpm_context);\n\tkfree(smu_dpm->dpm_current_power_state);\n\tkfree(smu_dpm->dpm_request_power_state);\n\tsmu_dpm->dpm_context = NULL;\n\tsmu_dpm->golden_dpm_context = NULL;\n\tsmu_dpm->dpm_context_size = 0;\n\tsmu_dpm->dpm_current_power_state = NULL;\n\tsmu_dpm->dpm_request_power_state = NULL;\n\n\treturn 0;\n}\n\nint smu_v11_0_init_power(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct smu_power_context *smu_power = &smu->smu_power;\n\tsize_t size = adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 5, 0) ?\n\t\t\tsizeof(struct smu_11_5_power_context) :\n\t\t\tsizeof(struct smu_11_0_power_context);\n\n\tsmu_power->power_context = kzalloc(size, GFP_KERNEL);\n\tif (!smu_power->power_context)\n\t\treturn -ENOMEM;\n\tsmu_power->power_context_size = size;\n\n\treturn 0;\n}\n\nint smu_v11_0_fini_power(struct smu_context *smu)\n{\n\tstruct smu_power_context *smu_power = &smu->smu_power;\n\n\tkfree(smu_power->power_context);\n\tsmu_power->power_context = NULL;\n\tsmu_power->power_context_size = 0;\n\n\treturn 0;\n}\n\nstatic int smu_v11_0_atom_get_smu_clockinfo(struct amdgpu_device *adev,\n\t\t\t\t\t    uint8_t clk_id,\n\t\t\t\t\t    uint8_t syspll_id,\n\t\t\t\t\t    uint32_t *clk_freq)\n{\n\tstruct atom_get_smu_clock_info_parameters_v3_1 input = {0};\n\tstruct atom_get_smu_clock_info_output_parameters_v3_1 *output;\n\tint ret, index;\n\n\tinput.clk_id = clk_id;\n\tinput.syspll_id = syspll_id;\n\tinput.command = GET_SMU_CLOCK_INFO_V3_1_GET_CLOCK_FREQ;\n\tindex = get_index_into_master_table(atom_master_list_of_command_functions_v2_1,\n\t\t\t\t\t    getsmuclockinfo);\n\n\tret = amdgpu_atom_execute_table(adev->mode_info.atom_context, index,\n\t\t\t\t\t(uint32_t *)&input);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\toutput = (struct atom_get_smu_clock_info_output_parameters_v3_1 *)&input;\n\t*clk_freq = le32_to_cpu(output->atom_smu_outputclkfreq.smu_clock_freq_hz) / 10000;\n\n\treturn 0;\n}\n\nint smu_v11_0_get_vbios_bootup_values(struct smu_context *smu)\n{\n\tint ret, index;\n\tuint16_t size;\n\tuint8_t frev, crev;\n\tstruct atom_common_table_header *header;\n\tstruct atom_firmware_info_v3_3 *v_3_3;\n\tstruct atom_firmware_info_v3_1 *v_3_1;\n\n\tindex = get_index_into_master_table(atom_master_list_of_data_tables_v2_1,\n\t\t\t\t\t    firmwareinfo);\n\n\tret = amdgpu_atombios_get_data_table(smu->adev, index, &size, &frev, &crev,\n\t\t\t\t      (uint8_t **)&header);\n\tif (ret)\n\t\treturn ret;\n\n\tif (header->format_revision != 3) {\n\t\tdev_err(smu->adev->dev, \"unknown atom_firmware_info version! for smu11\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (header->content_revision) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tv_3_1 = (struct atom_firmware_info_v3_1 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_1->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_1->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_1->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_1->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_1->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_1->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_1->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_1->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = 0;\n\t\tsmu->smu_table.boot_values.firmware_caps = v_3_1->firmware_capability;\n\t\tbreak;\n\tcase 3:\n\tcase 4:\n\tdefault:\n\t\tv_3_3 = (struct atom_firmware_info_v3_3 *)header;\n\t\tsmu->smu_table.boot_values.revision = v_3_3->firmware_revision;\n\t\tsmu->smu_table.boot_values.gfxclk = v_3_3->bootup_sclk_in10khz;\n\t\tsmu->smu_table.boot_values.uclk = v_3_3->bootup_mclk_in10khz;\n\t\tsmu->smu_table.boot_values.socclk = 0;\n\t\tsmu->smu_table.boot_values.dcefclk = 0;\n\t\tsmu->smu_table.boot_values.vddc = v_3_3->bootup_vddc_mv;\n\t\tsmu->smu_table.boot_values.vddci = v_3_3->bootup_vddci_mv;\n\t\tsmu->smu_table.boot_values.mvddc = v_3_3->bootup_mvddc_mv;\n\t\tsmu->smu_table.boot_values.vdd_gfx = v_3_3->bootup_vddgfx_mv;\n\t\tsmu->smu_table.boot_values.cooling_id = v_3_3->coolingsolution_id;\n\t\tsmu->smu_table.boot_values.pp_table_id = v_3_3->pplib_pptable_id;\n\t\tsmu->smu_table.boot_values.firmware_caps = v_3_3->firmware_capability;\n\t}\n\n\tsmu->smu_table.boot_values.format_revision = header->format_revision;\n\tsmu->smu_table.boot_values.content_revision = header->content_revision;\n\n\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL0_SOCCLK_ID,\n\t\t\t\t\t (uint8_t)0,\n\t\t\t\t\t &smu->smu_table.boot_values.socclk);\n\n\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL0_DCEFCLK_ID,\n\t\t\t\t\t (uint8_t)0,\n\t\t\t\t\t &smu->smu_table.boot_values.dcefclk);\n\n\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL0_ECLK_ID,\n\t\t\t\t\t (uint8_t)0,\n\t\t\t\t\t &smu->smu_table.boot_values.eclk);\n\n\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL0_VCLK_ID,\n\t\t\t\t\t (uint8_t)0,\n\t\t\t\t\t &smu->smu_table.boot_values.vclk);\n\n\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL0_DCLK_ID,\n\t\t\t\t\t (uint8_t)0,\n\t\t\t\t\t &smu->smu_table.boot_values.dclk);\n\n\tif ((smu->smu_table.boot_values.format_revision == 3) &&\n\t    (smu->smu_table.boot_values.content_revision >= 2))\n\t\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t\t (uint8_t)SMU11_SYSPLL1_0_FCLK_ID,\n\t\t\t\t\t\t (uint8_t)SMU11_SYSPLL1_2_ID,\n\t\t\t\t\t\t &smu->smu_table.boot_values.fclk);\n\n\tsmu_v11_0_atom_get_smu_clockinfo(smu->adev,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL3_1_LCLK_ID,\n\t\t\t\t\t (uint8_t)SMU11_SYSPLL3_1_ID,\n\t\t\t\t\t &smu->smu_table.boot_values.lclk);\n\n\treturn 0;\n}\n\nint smu_v11_0_notify_memory_pool_location(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *memory_pool = &smu_table->memory_pool;\n\tint ret = 0;\n\tuint64_t address;\n\tuint32_t address_low, address_high;\n\n\tif (memory_pool->size == 0 || memory_pool->cpu_addr == NULL)\n\t\treturn ret;\n\n\taddress = (uintptr_t)memory_pool->cpu_addr;\n\taddress_high = (uint32_t)upper_32_bits(address);\n\taddress_low  = (uint32_t)lower_32_bits(address);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_SetSystemVirtualDramAddrHigh,\n\t\t\t\t\t  address_high,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_SetSystemVirtualDramAddrLow,\n\t\t\t\t\t  address_low,\n\t\t\t\t\t  NULL);\n\tif (ret)\n\t\treturn ret;\n\n\taddress = memory_pool->mc_address;\n\taddress_high = (uint32_t)upper_32_bits(address);\n\taddress_low  = (uint32_t)lower_32_bits(address);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DramLogSetDramAddrHigh,\n\t\t\t\t\t  address_high, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DramLogSetDramAddrLow,\n\t\t\t\t\t  address_low, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_DramLogSetDramSize,\n\t\t\t\t\t  (uint32_t)memory_pool->size, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nint smu_v11_0_set_min_deep_sleep_dcefclk(struct smu_context *smu, uint32_t clk)\n{\n\tint ret;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_SetMinDeepSleepDcefclk, clk, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"SMU11 attempt to set divider for DCEFCLK Failed!\");\n\n\treturn ret;\n}\n\nint smu_v11_0_set_driver_table_location(struct smu_context *smu)\n{\n\tstruct smu_table *driver_table = &smu->smu_table.driver_table;\n\tint ret = 0;\n\n\tif (driver_table->mc_address) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetDriverDramAddrHigh,\n\t\t\t\tupper_32_bits(driver_table->mc_address),\n\t\t\t\tNULL);\n\t\tif (!ret)\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetDriverDramAddrLow,\n\t\t\t\tlower_32_bits(driver_table->mc_address),\n\t\t\t\tNULL);\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_set_tool_table_location(struct smu_context *smu)\n{\n\tint ret = 0;\n\tstruct smu_table *tool_table = &smu->smu_table.tables[SMU_TABLE_PMSTATUSLOG];\n\n\tif (tool_table->mc_address) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetToolsDramAddrHigh,\n\t\t\t\tupper_32_bits(tool_table->mc_address),\n\t\t\t\tNULL);\n\t\tif (!ret)\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_SetToolsDramAddrLow,\n\t\t\t\tlower_32_bits(tool_table->mc_address),\n\t\t\t\tNULL);\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_init_display_count(struct smu_context *smu, uint32_t count)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\t \n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 11) ||\n\t    adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 5, 0) ||\n\t    adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 12) ||\n\t    adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 13))\n\t\treturn 0;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_NumOfDisplays,\n\t\t\t\t\t       count,\n\t\t\t\t\t       NULL);\n}\n\n\nint smu_v11_0_set_allowed_mask(struct smu_context *smu)\n{\n\tstruct smu_feature *feature = &smu->smu_feature;\n\tint ret = 0;\n\tuint32_t feature_mask[2];\n\n\tif (bitmap_empty(feature->allowed, SMU_FEATURE_MAX) || feature->feature_num < 64) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tbitmap_to_arr32(feature_mask, feature->allowed, 64);\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetAllowedFeaturesMaskHigh,\n\t\t\t\t\t  feature_mask[1], NULL);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetAllowedFeaturesMaskLow,\n\t\t\t\t\t  feature_mask[0], NULL);\n\tif (ret)\n\t\tgoto failed;\n\nfailed:\n\treturn ret;\n}\n\nint smu_v11_0_system_features_control(struct smu_context *smu,\n\t\t\t\t\t     bool en)\n{\n\treturn smu_cmn_send_smc_msg(smu, (en ? SMU_MSG_EnableAllSmuFeatures :\n\t\t\t\t\t  SMU_MSG_DisableAllSmuFeatures), NULL);\n}\n\nint smu_v11_0_notify_display_change(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT) &&\n\t    smu->adev->gmc.vram_type == AMDGPU_VRAM_TYPE_HBM)\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetUclkFastSwitch, 1, NULL);\n\n\treturn ret;\n}\n\nstatic int\nsmu_v11_0_get_max_sustainable_clock(struct smu_context *smu, uint32_t *clock,\n\t\t\t\t    enum smu_clk_type clock_select)\n{\n\tint ret = 0;\n\tint clk_id;\n\n\tif ((smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG, SMU_MSG_GetDcModeMaxDpmFreq) < 0) ||\n\t    (smu_cmn_to_asic_specific_index(smu, CMN2ASIC_MAPPING_MSG, SMU_MSG_GetMaxDpmFreq) < 0))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclock_select);\n\tif (clk_id < 0)\n\t\treturn -EINVAL;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetDcModeMaxDpmFreq,\n\t\t\t\t\t  clk_id << 16, clock);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[GetMaxSustainableClock] Failed to get max DC clock from SMC!\");\n\t\treturn ret;\n\t}\n\n\tif (*clock != 0)\n\t\treturn 0;\n\n\t \n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetMaxDpmFreq,\n\t\t\t\t\t  clk_id << 16, clock);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[GetMaxSustainableClock] failed to get max AC clock from SMC!\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint smu_v11_0_init_max_sustainable_clocks(struct smu_context *smu)\n{\n\tstruct smu_11_0_max_sustainable_clocks *max_sustainable_clocks =\n\t\t\tsmu->smu_table.max_sustainable_clocks;\n\tint ret = 0;\n\n\tmax_sustainable_clocks->uclock = smu->smu_table.boot_values.uclk / 100;\n\tmax_sustainable_clocks->soc_clock = smu->smu_table.boot_values.socclk / 100;\n\tmax_sustainable_clocks->dcef_clock = smu->smu_table.boot_values.dcefclk / 100;\n\tmax_sustainable_clocks->display_clock = 0xFFFFFFFF;\n\tmax_sustainable_clocks->phy_clock = 0xFFFFFFFF;\n\tmax_sustainable_clocks->pixel_clock = 0xFFFFFFFF;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tret = smu_v11_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->uclock),\n\t\t\t\t\t\t\t  SMU_UCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max UCLK from SMC!\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_SOCCLK_BIT)) {\n\t\tret = smu_v11_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->soc_clock),\n\t\t\t\t\t\t\t  SMU_SOCCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max SOCCLK from SMC!\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT)) {\n\t\tret = smu_v11_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->dcef_clock),\n\t\t\t\t\t\t\t  SMU_DCEFCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max DCEFCLK from SMC!\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = smu_v11_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->display_clock),\n\t\t\t\t\t\t\t  SMU_DISPCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max DISPCLK from SMC!\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\t\tret = smu_v11_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->phy_clock),\n\t\t\t\t\t\t\t  SMU_PHYCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max PHYCLK from SMC!\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\t\tret = smu_v11_0_get_max_sustainable_clock(smu,\n\t\t\t\t\t\t\t  &(max_sustainable_clocks->pixel_clock),\n\t\t\t\t\t\t\t  SMU_PIXCLK);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get max PIXCLK from SMC!\",\n\t\t\t       __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (max_sustainable_clocks->soc_clock < max_sustainable_clocks->uclock)\n\t\tmax_sustainable_clocks->uclock = max_sustainable_clocks->soc_clock;\n\n\treturn 0;\n}\n\nint smu_v11_0_get_current_power_limit(struct smu_context *smu,\n\t\t\t\t      uint32_t *power_limit)\n{\n\tint power_src;\n\tint ret = 0;\n\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_PPT_BIT))\n\t\treturn -EINVAL;\n\n\tpower_src = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\tCMN2ASIC_MAPPING_PWR,\n\t\t\t\t\tsmu->adev->pm.ac_power ?\n\t\t\t\t\tSMU_POWER_SOURCE_AC :\n\t\t\t\t\tSMU_POWER_SOURCE_DC);\n\tif (power_src < 0)\n\t\treturn -EINVAL;\n\n\t \n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_GetPptLimit,\n\t\t\t\t\t  (0 << 24) | (power_src << 16),\n\t\t\t\t\t  power_limit);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"[%s] get PPT limit failed!\", __func__);\n\n\treturn ret;\n}\n\nint smu_v11_0_set_power_limit(struct smu_context *smu,\n\t\t\t      enum smu_ppt_limit_type limit_type,\n\t\t\t      uint32_t limit)\n{\n\tint power_src;\n\tint ret = 0;\n\tuint32_t limit_param;\n\n\tif (limit_type != SMU_DEFAULT_PPT_LIMIT)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_feature_is_enabled(smu, SMU_FEATURE_PPT_BIT)) {\n\t\tdev_err(smu->adev->dev, \"Setting new power limit is not supported!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpower_src = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\tCMN2ASIC_MAPPING_PWR,\n\t\t\t\t\tsmu->adev->pm.ac_power ?\n\t\t\t\t\tSMU_POWER_SOURCE_AC :\n\t\t\t\t\tSMU_POWER_SOURCE_DC);\n\tif (power_src < 0)\n\t\treturn -EINVAL;\n\n\t \n\tlimit_param  = (limit & 0xFFFF);\n\tlimit_param |= 0 << 24;\n\tlimit_param |= (power_src) << 16;\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetPptLimit, limit_param, NULL);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[%s] Set power limit Failed!\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsmu->current_power_limit = limit;\n\n\treturn 0;\n}\n\nstatic int smu_v11_0_ack_ac_dc_interrupt(struct smu_context *smu)\n{\n\treturn smu_cmn_send_smc_msg(smu,\n\t\t\t\tSMU_MSG_ReenableAcDcInterrupt,\n\t\t\t\tNULL);\n}\n\nstatic int smu_v11_0_process_pending_interrupt(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif (smu->dc_controlled_by_gpio &&\n\t    smu_cmn_feature_is_enabled(smu, SMU_FEATURE_ACDC_BIT))\n\t\tret = smu_v11_0_ack_ac_dc_interrupt(smu);\n\n\treturn ret;\n}\n\nvoid smu_v11_0_interrupt_work(struct smu_context *smu)\n{\n\tif (smu_v11_0_ack_ac_dc_interrupt(smu))\n\t\tdev_err(smu->adev->dev, \"Ack AC/DC interrupt Failed!\\n\");\n}\n\nint smu_v11_0_enable_thermal_alert(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tif (smu->smu_table.thermal_controller_type) {\n\t\tret = amdgpu_irq_get(smu->adev, &smu->irq_source, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn smu_v11_0_process_pending_interrupt(smu);\n}\n\nint smu_v11_0_disable_thermal_alert(struct smu_context *smu)\n{\n\treturn amdgpu_irq_put(smu->adev, &smu->irq_source, 0);\n}\n\nstatic uint16_t convert_to_vddc(uint8_t vid)\n{\n\treturn (uint16_t) ((6200 - (vid * 25)) / SMU11_VOLTAGE_SCALE);\n}\n\nint smu_v11_0_get_gfx_vdd(struct smu_context *smu, uint32_t *value)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t vdd = 0, val_vid = 0;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\tval_vid = (RREG32_SOC15(SMUIO, 0, mmSMUSVI0_TEL_PLANE0) &\n\t\tSMUSVI0_TEL_PLANE0__SVI0_PLANE0_VDDCOR_MASK) >>\n\t\tSMUSVI0_TEL_PLANE0__SVI0_PLANE0_VDDCOR__SHIFT;\n\n\tvdd = (uint32_t)convert_to_vddc((uint8_t)val_vid);\n\n\t*value = vdd;\n\n\treturn 0;\n\n}\n\nint\nsmu_v11_0_display_clock_voltage_request(struct smu_context *smu,\n\t\t\t\t\tstruct pp_display_clock_request\n\t\t\t\t\t*clock_req)\n{\n\tenum amd_pp_clock_type clk_type = clock_req->clock_type;\n\tint ret = 0;\n\tenum smu_clk_type clk_select = 0;\n\tuint32_t clk_freq = clock_req->clock_freq_in_khz / 1000;\n\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_DCEFCLK_BIT) ||\n\t\tsmu_cmn_feature_is_enabled(smu, SMU_FEATURE_DPM_UCLK_BIT)) {\n\t\tswitch (clk_type) {\n\t\tcase amd_pp_dcef_clock:\n\t\t\tclk_select = SMU_DCEFCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_disp_clock:\n\t\t\tclk_select = SMU_DISPCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_pixel_clock:\n\t\t\tclk_select = SMU_PIXCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_phy_clock:\n\t\t\tclk_select = SMU_PHYCLK;\n\t\t\tbreak;\n\t\tcase amd_pp_mem_clock:\n\t\t\tclk_select = SMU_UCLK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(smu->adev->dev, \"[%s] Invalid Clock Type!\", __func__);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\tif (clk_select == SMU_UCLK && smu->disable_uclk_switch)\n\t\t\treturn 0;\n\n\t\tret = smu_v11_0_set_hard_freq_limited_range(smu, clk_select, clk_freq, 0);\n\n\t\tif(clk_select == SMU_UCLK)\n\t\t\tsmu->hard_min_uclk_req_from_dal = clk_freq;\n\t}\n\nfailed:\n\treturn ret;\n}\n\nint smu_v11_0_gfx_off_control(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\tcase IP_VERSION(11, 0, 0):\n\tcase IP_VERSION(11, 0, 5):\n\tcase IP_VERSION(11, 0, 9):\n\tcase IP_VERSION(11, 0, 7):\n\tcase IP_VERSION(11, 0, 11):\n\tcase IP_VERSION(11, 0, 12):\n\tcase IP_VERSION(11, 0, 13):\n\tcase IP_VERSION(11, 5, 0):\n\t\tif (!(adev->pm.pp_feature & PP_GFXOFF_MASK))\n\t\t\treturn 0;\n\t\tif (enable)\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_AllowGfxOff, NULL);\n\t\telse\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_DisallowGfxOff, NULL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nuint32_t\nsmu_v11_0_get_fan_control_mode(struct smu_context *smu)\n{\n\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT))\n\t\treturn AMD_FAN_CTRL_AUTO;\n\telse\n\t\treturn smu->user_dpm_profile.fan_mode;\n}\n\nstatic int\nsmu_v11_0_auto_fan_control(struct smu_context *smu, bool auto_fan_control)\n{\n\tint ret = 0;\n\n\tif (!smu_cmn_feature_is_supported(smu, SMU_FEATURE_FAN_CONTROL_BIT))\n\t\treturn 0;\n\n\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_FAN_CONTROL_BIT, auto_fan_control);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"[%s]%s smc FAN CONTROL feature failed!\",\n\t\t       __func__, (auto_fan_control ? \"Start\" : \"Stop\"));\n\n\treturn ret;\n}\n\nstatic int\nsmu_v11_0_set_fan_static_mode(struct smu_context *smu, uint32_t mode)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tWREG32_SOC15(THM, 0, mmCG_FDO_CTRL2,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL2),\n\t\t\t\t   CG_FDO_CTRL2, TMIN, 0));\n\tWREG32_SOC15(THM, 0, mmCG_FDO_CTRL2,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL2),\n\t\t\t\t   CG_FDO_CTRL2, FDO_PWM_MODE, mode));\n\n\treturn 0;\n}\n\nint\nsmu_v11_0_set_fan_speed_pwm(struct smu_context *smu, uint32_t speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t duty100, duty;\n\tuint64_t tmp64;\n\n\tspeed = MIN(speed, 255);\n\n\tduty100 = REG_GET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL1),\n\t\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\tif (!duty100)\n\t\treturn -EINVAL;\n\n\ttmp64 = (uint64_t)speed * duty100;\n\tdo_div(tmp64, 255);\n\tduty = (uint32_t)tmp64;\n\n\tWREG32_SOC15(THM, 0, mmCG_FDO_CTRL0,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL0),\n\t\t\t\t   CG_FDO_CTRL0, FDO_STATIC_DUTY, duty));\n\n\treturn smu_v11_0_set_fan_static_mode(smu, FDO_PWM_MODE_STATIC);\n}\n\nint smu_v11_0_set_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\tuint32_t speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\t \n\tuint32_t crystal_clock_freq = 2500;\n\tuint32_t tach_period;\n\n\tif (speed == 0)\n\t\treturn -EINVAL;\n\t \n\ttach_period = 60 * crystal_clock_freq * 10000 / (8 * speed);\n\tWREG32_SOC15(THM, 0, mmCG_TACH_CTRL,\n\t\t     REG_SET_FIELD(RREG32_SOC15(THM, 0, mmCG_TACH_CTRL),\n\t\t\t\t   CG_TACH_CTRL, TARGET_PERIOD,\n\t\t\t\t   tach_period));\n\n\treturn smu_v11_0_set_fan_static_mode(smu, FDO_PWM_MODE_STATIC_RPM);\n}\n\nint smu_v11_0_get_fan_speed_pwm(struct smu_context *smu,\n\t\t\t\tuint32_t *speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t duty100, duty;\n\tuint64_t tmp64;\n\n\t \n\tif ((smu->user_dpm_profile.flags & SMU_CUSTOM_FAN_SPEED_PWM)\n\t     && !smu->user_dpm_profile.fan_speed_pwm) {\n\t\t*speed = 0;\n\t\treturn 0;\n\t}\n\n\tduty100 = REG_GET_FIELD(RREG32_SOC15(THM, 0, mmCG_FDO_CTRL1),\n\t\t\t\tCG_FDO_CTRL1, FMAX_DUTY100);\n\tduty = REG_GET_FIELD(RREG32_SOC15(THM, 0, mmCG_THERMAL_STATUS),\n\t\t\t\tCG_THERMAL_STATUS, FDO_PWM_DUTY);\n\tif (!duty100)\n\t\treturn -EINVAL;\n\n\ttmp64 = (uint64_t)duty * 255;\n\tdo_div(tmp64, duty100);\n\t*speed = MIN((uint32_t)tmp64, 255);\n\n\treturn 0;\n}\n\nint smu_v11_0_get_fan_speed_rpm(struct smu_context *smu,\n\t\t\t\tuint32_t *speed)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t crystal_clock_freq = 2500;\n\tuint32_t tach_status;\n\tuint64_t tmp64;\n\n\t \n\tif ((smu->user_dpm_profile.flags & SMU_CUSTOM_FAN_SPEED_RPM)\n\t     && !smu->user_dpm_profile.fan_speed_rpm) {\n\t\t*speed = 0;\n\t\treturn 0;\n\t}\n\n\ttmp64 = (uint64_t)crystal_clock_freq * 60 * 10000;\n\n\ttach_status = RREG32_SOC15(THM, 0, mmCG_TACH_STATUS);\n\tif (tach_status) {\n\t\tdo_div(tmp64, tach_status);\n\t\t*speed = (uint32_t)tmp64;\n\t} else {\n\t\tdev_warn_once(adev->dev, \"Got zero output on CG_TACH_STATUS reading!\\n\");\n\t\t*speed = 0;\n\t}\n\n\treturn 0;\n}\n\nint\nsmu_v11_0_set_fan_control_mode(struct smu_context *smu,\n\t\t\t       uint32_t mode)\n{\n\tint ret = 0;\n\n\tswitch (mode) {\n\tcase AMD_FAN_CTRL_NONE:\n\t\tret = smu_v11_0_auto_fan_control(smu, 0);\n\t\tif (!ret)\n\t\t\tret = smu_v11_0_set_fan_speed_pwm(smu, 255);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_MANUAL:\n\t\tret = smu_v11_0_auto_fan_control(smu, 0);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_AUTO:\n\t\tret = smu_v11_0_auto_fan_control(smu, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[%s]Set fan control mode failed!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_set_xgmi_pstate(struct smu_context *smu,\n\t\t\t\t     uint32_t pstate)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t       SMU_MSG_SetXgmiMode,\n\t\t\t\t\t       pstate ? XGMI_MODE_PSTATE_D0 : XGMI_MODE_PSTATE_D3,\n\t\t\t\t\t  NULL);\n}\n\nstatic int smu_v11_0_set_irq_state(struct amdgpu_device *adev,\n\t\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t\t   unsigned tyep,\n\t\t\t\t   enum amdgpu_interrupt_state state)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tuint32_t low, high;\n\tuint32_t val = 0;\n\n\tswitch (state) {\n\tcase AMDGPU_IRQ_STATE_DISABLE:\n\t\t \n\t\tval = RREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTH_MASK, 1);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTL_MASK, 1);\n\t\tWREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_CTRL, val);\n\n\t\tWREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_ENA, 0);\n\n\t\t \n\t\tval = RREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT_CTRL, INT_MASK, 1);\n\t\tWREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT_CTRL, val);\n\n\t\tbreak;\n\tcase AMDGPU_IRQ_STATE_ENABLE:\n\t\t \n\t\tlow = max(SMU_THERMAL_MINIMUM_ALERT_TEMP,\n\t\t\t\tsmu->thermal_range.min / SMU_TEMPERATURE_UNITS_PER_CENTIGRADES);\n\t\thigh = min(SMU_THERMAL_MAXIMUM_ALERT_TEMP,\n\t\t\t\tsmu->thermal_range.software_shutdown_temp);\n\n\t\tval = RREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, MAX_IH_CREDIT, 5);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_IH_HW_ENA, 1);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTH_MASK, 0);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, THERM_INTL_MASK, 0);\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTH, (high & 0xff));\n\t\tval = REG_SET_FIELD(val, THM_THERMAL_INT_CTRL, DIG_THERM_INTL, (low & 0xff));\n\t\tval = val & (~THM_THERMAL_INT_CTRL__THERM_TRIGGER_MASK_MASK);\n\t\tWREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_CTRL, val);\n\n\t\tval = (1 << THM_THERMAL_INT_ENA__THERM_INTH_CLR__SHIFT);\n\t\tval |= (1 << THM_THERMAL_INT_ENA__THERM_INTL_CLR__SHIFT);\n\t\tval |= (1 << THM_THERMAL_INT_ENA__THERM_TRIGGER_CLR__SHIFT);\n\t\tWREG32_SOC15(THM, 0, mmTHM_THERMAL_INT_ENA, val);\n\n\t\t \n\t\tval = RREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT, ID, 0xFE);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT, VALID, 0);\n\t\tWREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT, val);\n\n\t\tval = RREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT_CTRL);\n\t\tval = REG_SET_FIELD(val, MP1_SMN_IH_SW_INT_CTRL, INT_MASK, 0);\n\t\tWREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT_CTRL, val);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define THM_11_0__SRCID__THM_DIG_THERM_L2H\t\t0\t\t \n#define THM_11_0__SRCID__THM_DIG_THERM_H2L\t\t1\t\t \n\n#define SMUIO_11_0__SRCID__SMUIO_GPIO19\t\t\t83\n\nstatic int smu_v11_0_irq_process(struct amdgpu_device *adev,\n\t\t\t\t struct amdgpu_irq_src *source,\n\t\t\t\t struct amdgpu_iv_entry *entry)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tuint32_t client_id = entry->client_id;\n\tuint32_t src_id = entry->src_id;\n\t \n\tuint32_t ctxid = entry->src_data[0];\n\tuint32_t data;\n\n\tif (client_id == SOC15_IH_CLIENTID_THM) {\n\t\tswitch (src_id) {\n\t\tcase THM_11_0__SRCID__THM_DIG_THERM_L2H:\n\t\t\tschedule_delayed_work(&smu->swctf_delayed_work,\n\t\t\t\t\t      msecs_to_jiffies(AMDGPU_SWCTF_EXTRA_DELAY));\n\t\tbreak;\n\t\tcase THM_11_0__SRCID__THM_DIG_THERM_H2L:\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU under temperature range detected\\n\");\n\t\tbreak;\n\t\tdefault:\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU under temperature range unknown src id (%d)\\n\",\n\t\t\t\tsrc_id);\n\t\tbreak;\n\t\t}\n\t} else if (client_id == SOC15_IH_CLIENTID_ROM_SMUIO) {\n\t\tdev_emerg(adev->dev, \"ERROR: GPU HW Critical Temperature Fault(aka CTF) detected!\\n\");\n\t\t \n\t\tdev_emerg(adev->dev, \"ERROR: System is going to shutdown due to GPU HW CTF!\\n\");\n\t\torderly_poweroff(true);\n\t} else if (client_id == SOC15_IH_CLIENTID_MP1) {\n\t\tif (src_id == 0xfe) {\n\t\t\t \n\t\t\tdata = RREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT_CTRL);\n\t\t\tdata = REG_SET_FIELD(data, MP1_SMN_IH_SW_INT_CTRL, INT_ACK, 1);\n\t\t\tWREG32_SOC15(MP1, 0, mmMP1_SMN_IH_SW_INT_CTRL, data);\n\n\t\t\tswitch (ctxid) {\n\t\t\tcase 0x3:\n\t\t\t\tdev_dbg(adev->dev, \"Switched to AC mode!\\n\");\n\t\t\t\tschedule_work(&smu->interrupt_work);\n\t\t\t\tbreak;\n\t\t\tcase 0x4:\n\t\t\t\tdev_dbg(adev->dev, \"Switched to DC mode!\\n\");\n\t\t\t\tschedule_work(&smu->interrupt_work);\n\t\t\t\tbreak;\n\t\t\tcase 0x7:\n\t\t\t\t \n\t\t\t\tatomic64_inc(&smu->throttle_int_counter);\n\n\t\t\t\tif (!atomic_read(&adev->throttling_logging_enabled))\n\t\t\t\t\treturn 0;\n\n\t\t\t\tif (__ratelimit(&adev->throttling_logging_rs))\n\t\t\t\t\tschedule_work(&smu->throttling_logging_work);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs smu_v11_0_irq_funcs =\n{\n\t.set = smu_v11_0_set_irq_state,\n\t.process = smu_v11_0_irq_process,\n};\n\nint smu_v11_0_register_irq_handler(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_irq_src *irq_src = &smu->irq_source;\n\tint ret = 0;\n\n\tirq_src->num_types = 1;\n\tirq_src->funcs = &smu_v11_0_irq_funcs;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_THM,\n\t\t\t\tTHM_11_0__SRCID__THM_DIG_THERM_L2H,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_THM,\n\t\t\t\tTHM_11_0__SRCID__THM_DIG_THERM_H2L,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_ROM_SMUIO,\n\t\t\t\tSMUIO_11_0__SRCID__SMUIO_GPIO19,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\tret = amdgpu_irq_add_id(adev, SOC15_IH_CLIENTID_MP1,\n\t\t\t\t0xfe,\n\t\t\t\tirq_src);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nint smu_v11_0_get_max_sustainable_clocks_by_dc(struct smu_context *smu,\n\t\tstruct pp_smu_nv_clock_table *max_clocks)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tstruct smu_11_0_max_sustainable_clocks *sustainable_clocks = NULL;\n\n\tif (!max_clocks || !table_context->max_sustainable_clocks)\n\t\treturn -EINVAL;\n\n\tsustainable_clocks = table_context->max_sustainable_clocks;\n\n\tmax_clocks->dcfClockInKhz =\n\t\t\t(unsigned int) sustainable_clocks->dcef_clock * 1000;\n\tmax_clocks->displayClockInKhz =\n\t\t\t(unsigned int) sustainable_clocks->display_clock * 1000;\n\tmax_clocks->phyClockInKhz =\n\t\t\t(unsigned int) sustainable_clocks->phy_clock * 1000;\n\tmax_clocks->pixelClockInKhz =\n\t\t\t(unsigned int) sustainable_clocks->pixel_clock * 1000;\n\tmax_clocks->uClockInKhz =\n\t\t\t(unsigned int) sustainable_clocks->uclock * 1000;\n\tmax_clocks->socClockInKhz =\n\t\t\t(unsigned int) sustainable_clocks->soc_clock * 1000;\n\tmax_clocks->dscClockInKhz = 0;\n\tmax_clocks->dppClockInKhz = 0;\n\tmax_clocks->fabricClockInKhz = 0;\n\n\treturn 0;\n}\n\nint smu_v11_0_set_azalia_d3_pme(struct smu_context *smu)\n{\n\treturn smu_cmn_send_smc_msg(smu, SMU_MSG_BacoAudioD3PME, NULL);\n}\n\nint smu_v11_0_baco_set_armd3_sequence(struct smu_context *smu,\n\t\t\t\t      enum smu_baco_seq baco_seq)\n{\n\treturn smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_ArmD3, baco_seq, NULL);\n}\n\nbool smu_v11_0_baco_is_support(struct smu_context *smu)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\n\tif (amdgpu_sriov_vf(smu->adev) || !smu_baco->platform_support)\n\t\treturn false;\n\n\t \n\tif (smu_v11_0_baco_get_state(smu) == SMU_BACO_STATE_ENTER)\n\t\treturn true;\n\n\t \n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_BACO_BIT) &&\n\t   !smu_cmn_feature_is_enabled(smu, SMU_FEATURE_BACO_BIT))\n\t\treturn false;\n\n\treturn true;\n}\n\nenum smu_baco_state smu_v11_0_baco_get_state(struct smu_context *smu)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\n\treturn smu_baco->state;\n}\n\n#define D3HOT_BACO_SEQUENCE 0\n#define D3HOT_BAMACO_SEQUENCE 2\n\nint smu_v11_0_baco_set_state(struct smu_context *smu, enum smu_baco_state state)\n{\n\tstruct smu_baco_context *smu_baco = &smu->smu_baco;\n\tstruct amdgpu_device *adev = smu->adev;\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tuint32_t data;\n\tint ret = 0;\n\n\tif (smu_v11_0_baco_get_state(smu) == state)\n\t\treturn 0;\n\n\tif (state == SMU_BACO_STATE_ENTER) {\n\t\tswitch (adev->ip_versions[MP1_HWIP][0]) {\n\t\tcase IP_VERSION(11, 0, 7):\n\t\tcase IP_VERSION(11, 0, 11):\n\t\tcase IP_VERSION(11, 0, 12):\n\t\tcase IP_VERSION(11, 0, 13):\n\t\t\tif (amdgpu_runtime_pm == 2)\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t      SMU_MSG_EnterBaco,\n\t\t\t\t\t\t\t\t      D3HOT_BAMACO_SEQUENCE,\n\t\t\t\t\t\t\t\t      NULL);\n\t\t\telse\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\t      SMU_MSG_EnterBaco,\n\t\t\t\t\t\t\t\t      D3HOT_BACO_SEQUENCE,\n\t\t\t\t\t\t\t\t      NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!ras || !adev->ras_enabled ||\n\t\t\t    adev->gmc.xgmi.pending_reset) {\n\t\t\t\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 2)) {\n\t\t\t\t\tdata = RREG32_SOC15(THM, 0, mmTHM_BACO_CNTL_ARCT);\n\t\t\t\t\tdata |= 0x80000000;\n\t\t\t\t\tWREG32_SOC15(THM, 0, mmTHM_BACO_CNTL_ARCT, data);\n\t\t\t\t} else {\n\t\t\t\t\tdata = RREG32_SOC15(THM, 0, mmTHM_BACO_CNTL);\n\t\t\t\t\tdata |= 0x80000000;\n\t\t\t\t\tWREG32_SOC15(THM, 0, mmTHM_BACO_CNTL, data);\n\t\t\t\t}\n\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_EnterBaco, 0, NULL);\n\t\t\t} else {\n\t\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_EnterBaco, 1, NULL);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_ExitBaco, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tWREG32(adev->bios_scratch_reg_offset + 6, 0);\n\t\tWREG32(adev->bios_scratch_reg_offset + 7, 0);\n\t}\n\n\tif (!ret)\n\t\tsmu_baco->state = state;\n\n\treturn ret;\n}\n\nint smu_v11_0_baco_enter(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_v11_0_baco_set_state(smu, SMU_BACO_STATE_ENTER);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(10);\n\n\treturn ret;\n}\n\nint smu_v11_0_baco_exit(struct smu_context *smu)\n{\n\tint ret;\n\n\tret = smu_v11_0_baco_set_state(smu, SMU_BACO_STATE_EXIT);\n\tif (!ret) {\n\t\t \n\t\tsmu_v11_0_poll_baco_exit(smu);\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_mode1_reset(struct smu_context *smu)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_Mode1Reset, NULL);\n\tif (!ret)\n\t\tmsleep(SMU11_MODE1_RESET_WAIT_TIME_IN_MS);\n\n\treturn ret;\n}\n\nint smu_v11_0_handle_passthrough_sbr(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tret =  smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_LightSBR, enable ? 1 : 0, NULL);\n\n\treturn ret;\n}\n\n\nint smu_v11_0_get_dpm_ultimate_freq(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t\t\t\t uint32_t *min, uint32_t *max)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param = 0;\n\tuint32_t clock_limit;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.uclk;\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.gfxclk;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.socclk;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclock_limit = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (min)\n\t\t\t*min = clock_limit / 100;\n\t\tif (max)\n\t\t\t*max = clock_limit / 100;\n\n\t\treturn 0;\n\t}\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\tparam = (clk_id & 0xffff) << 16;\n\n\tif (max) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetMaxDpmFreq, param, max);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\tif (min) {\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GetMinDpmFreq, param, min);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\nfailed:\n\treturn ret;\n}\n\nint smu_v11_0_set_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t min,\n\t\t\t\t\t  uint32_t max)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tif (max > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (max & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxByFreq,\n\t\t\t\t\t\t  param, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (min > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (min & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMinByFreq,\n\t\t\t\t\t\t  param, NULL);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nint smu_v11_0_set_hard_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t\t  uint32_t min,\n\t\t\t\t\t  uint32_t max)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\n\tif (min <= 0 && max <= 0)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tif (max > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (max & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMaxByFreq,\n\t\t\t\t\t\t  param, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (min > 0) {\n\t\tparam = (uint32_t)((clk_id << 16) | (min & 0xffff));\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinByFreq,\n\t\t\t\t\t\t  param, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_set_performance_level(struct smu_context *smu,\n\t\t\t\t    enum amd_dpm_forced_level level)\n{\n\tstruct smu_11_0_dpm_context *dpm_context =\n\t\t\t\tsmu->smu_dpm.dpm_context;\n\tstruct smu_11_0_dpm_table *gfx_table =\n\t\t\t\t&dpm_context->dpm_tables.gfx_table;\n\tstruct smu_11_0_dpm_table *mem_table =\n\t\t\t\t&dpm_context->dpm_tables.uclk_table;\n\tstruct smu_11_0_dpm_table *soc_table =\n\t\t\t\t&dpm_context->dpm_tables.soc_table;\n\tstruct smu_umd_pstate_table *pstate_table =\n\t\t\t\t&smu->pstate_table;\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t sclk_min = 0, sclk_max = 0;\n\tuint32_t mclk_min = 0, mclk_max = 0;\n\tuint32_t socclk_min = 0, socclk_max = 0;\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tsclk_min = sclk_max = gfx_table->max;\n\t\tmclk_min = mclk_max = mem_table->max;\n\t\tsocclk_min = socclk_max = soc_table->max;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tsclk_min = sclk_max = gfx_table->min;\n\t\tmclk_min = mclk_max = mem_table->min;\n\t\tsocclk_min = socclk_max = soc_table->min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tsclk_min = gfx_table->min;\n\t\tsclk_max = gfx_table->max;\n\t\tmclk_min = mem_table->min;\n\t\tmclk_max = mem_table->max;\n\t\tsocclk_min = soc_table->min;\n\t\tsocclk_max = soc_table->max;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\t\tsclk_min = sclk_max = pstate_table->gfxclk_pstate.standard;\n\t\tmclk_min = mclk_max = pstate_table->uclk_pstate.standard;\n\t\tsocclk_min = socclk_max = pstate_table->socclk_pstate.standard;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\t\tsclk_min = sclk_max = pstate_table->gfxclk_pstate.min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\t\tmclk_min = mclk_max = pstate_table->uclk_pstate.min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tsclk_min = sclk_max = pstate_table->gfxclk_pstate.peak;\n\t\tmclk_min = mclk_max = pstate_table->uclk_pstate.peak;\n\t\tsocclk_min = socclk_max = pstate_table->socclk_pstate.peak;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(adev->dev, \"Invalid performance level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (adev->ip_versions[MP1_HWIP][0] == IP_VERSION(11, 0, 2)) {\n\t\tmclk_min = mclk_max = 0;\n\t\tsocclk_min = socclk_max = 0;\n\t}\n\n\tif (sclk_min && sclk_max) {\n\t\tret = smu_v11_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_GFXCLK,\n\t\t\t\t\t\t\t    sclk_min,\n\t\t\t\t\t\t\t    sclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (mclk_min && mclk_max) {\n\t\tret = smu_v11_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_MCLK,\n\t\t\t\t\t\t\t    mclk_min,\n\t\t\t\t\t\t\t    mclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (socclk_min && socclk_max) {\n\t\tret = smu_v11_0_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_SOCCLK,\n\t\t\t\t\t\t\t    socclk_min,\n\t\t\t\t\t\t\t    socclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_set_power_source(struct smu_context *smu,\n\t\t\t       enum smu_power_src_type power_src)\n{\n\tint pwr_source;\n\n\tpwr_source = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t    CMN2ASIC_MAPPING_PWR,\n\t\t\t\t\t\t    (uint32_t)power_src);\n\tif (pwr_source < 0)\n\t\treturn -EINVAL;\n\n\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\tSMU_MSG_NotifyPowerSource,\n\t\t\t\t\tpwr_source,\n\t\t\t\t\tNULL);\n}\n\nint smu_v11_0_get_dpm_freq_by_index(struct smu_context *smu,\n\t\t\t\t    enum smu_clk_type clk_type,\n\t\t\t\t    uint16_t level,\n\t\t\t\t    uint32_t *value)\n{\n\tint ret = 0, clk_id = 0;\n\tuint32_t param;\n\n\tif (!value)\n\t\treturn -EINVAL;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn 0;\n\n\tclk_id = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\tCMN2ASIC_MAPPING_CLK,\n\t\t\t\t\t\tclk_type);\n\tif (clk_id < 0)\n\t\treturn clk_id;\n\n\tparam = (uint32_t)(((clk_id & 0xffff) << 16) | (level & 0xffff));\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t  SMU_MSG_GetDpmFreqByIndex,\n\t\t\t\t\t  param,\n\t\t\t\t\t  value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*value = *value & 0x7fffffff;\n\n\treturn ret;\n}\n\nint smu_v11_0_get_dpm_level_count(struct smu_context *smu,\n\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t  uint32_t *value)\n{\n\treturn smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t       clk_type,\n\t\t\t\t\t       0xff,\n\t\t\t\t\t       value);\n}\n\nint smu_v11_0_set_single_dpm_table(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type,\n\t\t\t\t   struct smu_11_0_dpm_table *single_dpm_table)\n{\n\tint ret = 0;\n\tuint32_t clk;\n\tint i;\n\n\tret = smu_v11_0_get_dpm_level_count(smu,\n\t\t\t\t\t    clk_type,\n\t\t\t\t\t    &single_dpm_table->count);\n\tif (ret) {\n\t\tdev_err(smu->adev->dev, \"[%s] failed to get dpm levels!\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < single_dpm_table->count; i++) {\n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t      clk_type,\n\t\t\t\t\t\t      i,\n\t\t\t\t\t\t      &clk);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"[%s] failed to get dpm freq by index!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsingle_dpm_table->dpm_levels[i].value = clk;\n\t\tsingle_dpm_table->dpm_levels[i].enabled = true;\n\n\t\tif (i == 0)\n\t\t\tsingle_dpm_table->min = clk;\n\t\telse if (i == single_dpm_table->count - 1)\n\t\t\tsingle_dpm_table->max = clk;\n\t}\n\n\treturn 0;\n}\n\nint smu_v11_0_get_dpm_level_range(struct smu_context *smu,\n\t\t\t\t  enum smu_clk_type clk_type,\n\t\t\t\t  uint32_t *min_value,\n\t\t\t\t  uint32_t *max_value)\n{\n\tuint32_t level_count = 0;\n\tint ret = 0;\n\n\tif (!min_value && !max_value)\n\t\treturn -EINVAL;\n\n\tif (min_value) {\n\t\t \n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t      clk_type,\n\t\t\t\t\t\t      0,\n\t\t\t\t\t\t      min_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (max_value) {\n\t\tret = smu_v11_0_get_dpm_level_count(smu,\n\t\t\t\t\t\t    clk_type,\n\t\t\t\t\t\t    &level_count);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_v11_0_get_dpm_freq_by_index(smu,\n\t\t\t\t\t\t      clk_type,\n\t\t\t\t\t\t      level_count - 1,\n\t\t\t\t\t\t      max_value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_get_current_pcie_link_width_level(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_LINK_WIDTH_CNTL) &\n\t\tPCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK)\n\t\t>> PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT;\n}\n\nuint16_t smu_v11_0_get_current_pcie_link_width(struct smu_context *smu)\n{\n\tuint32_t width_level;\n\n\twidth_level = smu_v11_0_get_current_pcie_link_width_level(smu);\n\tif (width_level > LINK_WIDTH_MAX)\n\t\twidth_level = 0;\n\n\treturn link_width[width_level];\n}\n\nint smu_v11_0_get_current_pcie_link_speed_level(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_SPEED_CNTL) &\n\t\tPCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK)\n\t\t>> PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;\n}\n\nuint16_t smu_v11_0_get_current_pcie_link_speed(struct smu_context *smu)\n{\n\tuint32_t speed_level;\n\n\tspeed_level = smu_v11_0_get_current_pcie_link_speed_level(smu);\n\tif (speed_level > LINK_SPEED_MAX)\n\t\tspeed_level = 0;\n\n\treturn link_speed[speed_level];\n}\n\nint smu_v11_0_gfx_ulv_control(struct smu_context *smu,\n\t\t\t      bool enablement)\n{\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_GFX_ULV_BIT))\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_GFX_ULV_BIT, enablement);\n\n\treturn ret;\n}\n\nint smu_v11_0_deep_sleep_control(struct smu_context *smu,\n\t\t\t\t bool enablement)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_GFXCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_GFXCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s GFXCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_UCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_UCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s UCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_FCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_FCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s FCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_SOCCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_SOCCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s SOCCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (smu_cmn_feature_is_supported(smu, SMU_FEATURE_DS_LCLK_BIT)) {\n\t\tret = smu_cmn_feature_set_enabled(smu, SMU_FEATURE_DS_LCLK_BIT, enablement);\n\t\tif (ret) {\n\t\t\tdev_err(adev->dev, \"Failed to %s LCLK DS!\\n\", enablement ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint smu_v11_0_restore_user_od_settings(struct smu_context *smu)\n{\n\tstruct smu_table_context *table_context = &smu->smu_table;\n\tvoid *user_od_table = table_context->user_overdrive_table;\n\tint ret = 0;\n\n\tret = smu_cmn_update_table(smu, SMU_TABLE_OVERDRIVE, 0, (void *)user_od_table, true);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"Failed to import overdrive table!\\n\");\n\n\treturn ret;\n}\n\nvoid smu_v11_0_set_smu_mailbox_registers(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tsmu->param_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_82);\n\tsmu->msg_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_66);\n\tsmu->resp_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}