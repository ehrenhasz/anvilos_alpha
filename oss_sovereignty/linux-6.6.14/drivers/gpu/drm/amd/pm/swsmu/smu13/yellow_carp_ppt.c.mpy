{
  "module_name": "yellow_carp_ppt.c",
  "hash_id": "def5ac0e0157550e3cfa56a9e6018e2826ec83c0f2902988e58b933bb31488a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu13/yellow_carp_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"smu_v13_0.h\"\n#include \"smu13_driver_if_yellow_carp.h\"\n#include \"yellow_carp_ppt.h\"\n#include \"smu_v13_0_1_ppsmc.h\"\n#include \"smu_v13_0_1_pmfw.h\"\n#include \"smu_cmn.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define regSMUIO_GFX_MISC_CNTL  \t\t\t\t\t\t0x00c5\n#define regSMUIO_GFX_MISC_CNTL_BASE_IDX\t\t\t\t\t0\n#define SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS_MASK\t\t0x00000006L\n#define SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS__SHIFT          0x1L\n\n#define SMU_13_0_8_UMD_PSTATE_GFXCLK                   533\n#define SMU_13_0_8_UMD_PSTATE_SOCCLK                   533\n#define SMU_13_0_8_UMD_PSTATE_FCLK                     800\n\n#define SMU_13_0_1_UMD_PSTATE_GFXCLK\t\t\t\t\t700\n#define SMU_13_0_1_UMD_PSTATE_SOCCLK\t\t              678\n#define SMU_13_0_1_UMD_PSTATE_FCLK\t\t\t          1800\n\n#define FEATURE_MASK(feature) (1ULL << feature)\n#define SMC_DPM_FEATURE ( \\\n\tFEATURE_MASK(FEATURE_CCLK_DPM_BIT) | \\\n\tFEATURE_MASK(FEATURE_VCN_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_FCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_SOCCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_MP0CLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_LCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_SHUBCLK_DPM_BIT)\t | \\\n\tFEATURE_MASK(FEATURE_DCFCLK_DPM_BIT)| \\\n\tFEATURE_MASK(FEATURE_GFX_DPM_BIT))\n\nstatic struct cmn2asic_msg_mapping yellow_carp_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,                    PPSMC_MSG_TestMessage,\t\t\t1),\n\tMSG_MAP(GetSmuVersion,                  PPSMC_MSG_GetSmuVersion,\t\t1),\n\tMSG_MAP(GetDriverIfVersion,             PPSMC_MSG_GetDriverIfVersion,\t\t1),\n\tMSG_MAP(EnableGfxOff,                   PPSMC_MSG_EnableGfxOff,\t\t\t1),\n\tMSG_MAP(AllowGfxOff,                    PPSMC_MSG_AllowGfxOff,\t\t\t1),\n\tMSG_MAP(DisallowGfxOff,                 PPSMC_MSG_DisallowGfxOff,\t\t1),\n\tMSG_MAP(PowerDownVcn,                   PPSMC_MSG_PowerDownVcn,\t\t\t1),\n\tMSG_MAP(PowerUpVcn,                     PPSMC_MSG_PowerUpVcn,\t\t\t1),\n\tMSG_MAP(SetHardMinVcn,                  PPSMC_MSG_SetHardMinVcn,\t\t1),\n\tMSG_MAP(PrepareMp1ForUnload,            PPSMC_MSG_PrepareMp1ForUnload,      1),\n\tMSG_MAP(SetDriverDramAddrHigh,          PPSMC_MSG_SetDriverDramAddrHigh,\t1),\n\tMSG_MAP(SetDriverDramAddrLow,           PPSMC_MSG_SetDriverDramAddrLow,\t\t1),\n\tMSG_MAP(TransferTableSmu2Dram,          PPSMC_MSG_TransferTableSmu2Dram,\t1),\n\tMSG_MAP(TransferTableDram2Smu,          PPSMC_MSG_TransferTableDram2Smu,\t1),\n\tMSG_MAP(GfxDeviceDriverReset,           PPSMC_MSG_GfxDeviceDriverReset,\t\t1),\n\tMSG_MAP(GetEnabledSmuFeatures,          PPSMC_MSG_GetEnabledSmuFeatures,\t1),\n\tMSG_MAP(SetHardMinSocclkByFreq,         PPSMC_MSG_SetHardMinSocclkByFreq,\t1),\n\tMSG_MAP(SetSoftMinVcn,                  PPSMC_MSG_SetSoftMinVcn,\t\t1),\n\tMSG_MAP(GetGfxclkFrequency,             PPSMC_MSG_GetGfxclkFrequency,\t\t1),\n\tMSG_MAP(GetFclkFrequency,               PPSMC_MSG_GetFclkFrequency,\t\t1),\n\tMSG_MAP(SetSoftMaxGfxClk,               PPSMC_MSG_SetSoftMaxGfxClk,\t\t1),\n\tMSG_MAP(SetHardMinGfxClk,               PPSMC_MSG_SetHardMinGfxClk,\t\t1),\n\tMSG_MAP(SetSoftMaxSocclkByFreq,         PPSMC_MSG_SetSoftMaxSocclkByFreq,\t1),\n\tMSG_MAP(SetSoftMaxFclkByFreq,           PPSMC_MSG_SetSoftMaxFclkByFreq,\t\t1),\n\tMSG_MAP(SetSoftMaxVcn,                  PPSMC_MSG_SetSoftMaxVcn,\t\t1),\n\tMSG_MAP(SetPowerLimitPercentage,        PPSMC_MSG_SetPowerLimitPercentage,\t1),\n\tMSG_MAP(PowerDownJpeg,                  PPSMC_MSG_PowerDownJpeg,\t\t1),\n\tMSG_MAP(PowerUpJpeg,                    PPSMC_MSG_PowerUpJpeg,\t\t\t1),\n\tMSG_MAP(SetHardMinFclkByFreq,           PPSMC_MSG_SetHardMinFclkByFreq,\t\t1),\n\tMSG_MAP(SetSoftMinSocclkByFreq,         PPSMC_MSG_SetSoftMinSocclkByFreq,\t1),\n};\n\nstatic struct cmn2asic_mapping yellow_carp_feature_mask_map[SMU_FEATURE_COUNT] = {\n\tFEA_MAP(CCLK_DPM),\n\tFEA_MAP(FAN_CONTROLLER),\n\tFEA_MAP(PPT),\n\tFEA_MAP(TDC),\n\tFEA_MAP(THERMAL),\n\tFEA_MAP(ULV),\n\tFEA_MAP(VCN_DPM),\n\tFEA_MAP_REVERSE(FCLK),\n\tFEA_MAP_REVERSE(SOCCLK),\n\tFEA_MAP(LCLK_DPM),\n\tFEA_MAP(SHUBCLK_DPM),\n\tFEA_MAP(DCFCLK_DPM),\n\tFEA_MAP_HALF_REVERSE(GFX),\n\tFEA_MAP(DS_GFXCLK),\n\tFEA_MAP(DS_SOCCLK),\n\tFEA_MAP(DS_LCLK),\n\tFEA_MAP(DS_DCFCLK),\n\tFEA_MAP(DS_FCLK),\n\tFEA_MAP(DS_MP1CLK),\n\tFEA_MAP(DS_MP0CLK),\n\tFEA_MAP(GFX_DEM),\n\tFEA_MAP(PSI),\n\tFEA_MAP(PROCHOT),\n\tFEA_MAP(CPUOFF),\n\tFEA_MAP(STAPM),\n\tFEA_MAP(S0I3),\n\tFEA_MAP(PERF_LIMIT),\n\tFEA_MAP(CORE_DLDO),\n\tFEA_MAP(RSMU_LOW_POWER),\n\tFEA_MAP(SMN_LOW_POWER),\n\tFEA_MAP(THM_LOW_POWER),\n\tFEA_MAP(SMUIO_LOW_POWER),\n\tFEA_MAP(MP1_LOW_POWER),\n\tFEA_MAP(DS_VCN),\n\tFEA_MAP(CPPC),\n\tFEA_MAP(DF_CSTATES),\n\tFEA_MAP(MSMU_LOW_POWER),\n\tFEA_MAP(ATHUB_PG),\n};\n\nstatic struct cmn2asic_mapping yellow_carp_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP_VALID(WATERMARKS),\n\tTAB_MAP_VALID(SMU_METRICS),\n\tTAB_MAP_VALID(CUSTOM_DPM),\n\tTAB_MAP_VALID(DPMCLOCKS),\n};\n\t\nstatic int yellow_carp_init_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_DPMCLOCKS, sizeof(DpmClocks_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->clocks_table = kzalloc(sizeof(DpmClocks_t), GFP_KERNEL);\n\tif (!smu_table->clocks_table)\n\t\tgoto err0_out;\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err1_out;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v2_1);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err3_out;\n\n\treturn 0;\n\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->metrics_table);\nerr1_out:\n\tkfree(smu_table->clocks_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\nstatic int yellow_carp_fini_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\tkfree(smu_table->clocks_table);\n\tsmu_table->clocks_table = NULL;\n\n\tkfree(smu_table->metrics_table);\n\tsmu_table->metrics_table = NULL;\n\n\tkfree(smu_table->watermarks_table);\n\tsmu_table->watermarks_table = NULL;\n\n\tkfree(smu_table->gpu_metrics_table);\n\tsmu_table->gpu_metrics_table = NULL;\n\n\treturn 0;\n}\n\nstatic int yellow_carp_system_features_control(struct smu_context *smu, bool en)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\tif (!en && !adev->in_s0ix)\n\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_PrepareMp1ForUnload, NULL);\n\n\treturn ret;\n}\n\nstatic int yellow_carp_dpm_set_vcn_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\t \n\tif (enable)\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpVcn,\n\t\t\t\t\t\t      0, NULL);\n\telse\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerDownVcn,\n\t\t\t\t\t\t      0, NULL);\n\n\treturn ret;\n}\n\nstatic int yellow_carp_dpm_set_jpeg_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable)\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpJpeg,\n\t\t\t\t\t\t      0, NULL);\n\telse\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_PowerDownJpeg, 0,\n\t\t\t\t\t\t      NULL);\n\n\treturn ret;\n}\n\n\nstatic bool yellow_carp_is_dpm_running(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint64_t feature_enabled;\n\n\tret = smu_cmn_get_enabled_mask(smu, &feature_enabled);\n\n\tif (ret)\n\t\treturn false;\n\n\treturn !!(feature_enabled & SMC_DPM_FEATURE);\n}\n\nstatic int yellow_carp_post_smu_init(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tint ret = 0;\n\n\t \n\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_EnableGfxOff, NULL);\n\tif (ret)\n\t\tdev_err(adev->dev, \"Failed to Enable GfxOff!\\n\");\n\treturn ret;\n}\n\nstatic int yellow_carp_mode_reset(struct smu_context *smu, int type)\n{\n\tint ret = 0;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_GfxDeviceDriverReset, type, NULL);\n\tif (ret)\n\t\tdev_err(smu->adev->dev, \"Failed to mode reset!\\n\");\n\n\treturn ret;\n}\n\nstatic int yellow_carp_mode2_reset(struct smu_context *smu)\n{\n\treturn yellow_carp_mode_reset(smu, SMU_RESET_MODE_2);\n}\n\n\nstatic void yellow_carp_get_ss_power_percent(SmuMetrics_t *metrics,\n\t\t\t\t\tuint32_t *apu_percent, uint32_t *dgpu_percent)\n{\n\tuint32_t apu_boost = 0;\n\tuint32_t dgpu_boost = 0;\n\tuint16_t apu_limit = 0;\n\tuint16_t dgpu_limit = 0;\n\tuint16_t apu_power = 0;\n\tuint16_t dgpu_power = 0;\n\n\t \n\tapu_power = metrics->ApuPower/1000;\n\tapu_limit = metrics->StapmOpnLimit;\n\tif (apu_power > apu_limit && apu_limit != 0)\n\t\tapu_boost =  ((apu_power - apu_limit) * 100) / apu_limit;\n\tapu_boost = (apu_boost > 100) ? 100 : apu_boost;\n\n\tdgpu_power = metrics->dGpuPower/1000;\n\tif (metrics->StapmCurrentLimit > metrics->StapmOpnLimit)\n\t\tdgpu_limit = metrics->StapmCurrentLimit - metrics->StapmOpnLimit;\n\tif (dgpu_power > dgpu_limit && dgpu_limit != 0)\n\t\tdgpu_boost = ((dgpu_power - dgpu_limit) * 100) / dgpu_limit;\n\tdgpu_boost = (dgpu_boost > 100) ? 100 : dgpu_boost;\n\n\tif (dgpu_boost >= apu_boost)\n\t\tapu_boost = 0;\n\telse\n\t\tdgpu_boost = 0;\n\n\t*apu_percent = apu_boost;\n\t*dgpu_percent = dgpu_boost;\n\n}\n\nstatic int yellow_carp_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t\t\t\tMetricsMember_t member,\n\t\t\t\t\t\t\tuint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\tSmuMetrics_t *metrics = (SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\tuint32_t apu_percent = 0;\n\tuint32_t dgpu_percent = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, NULL, false);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\t*value = metrics->GfxclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->SocclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCLK:\n\t\t*value = metrics->VclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_DCLK:\n\t\t*value = metrics->DclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->MemclkFrequency;\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->GfxActivity / 100;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCNACTIVITY:\n\t\t*value = metrics->UvdActivity;\n\t\tbreak;\n\tcase METRICS_CURR_SOCKETPOWER:\n\t\t*value = (metrics->CurrentSocketPower << 8) / 1000;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = metrics->GfxTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = metrics->SocTemperature / 100 *\n\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->Voltage[0];\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDSOC:\n\t\t*value = metrics->Voltage[1];\n\t\tbreak;\n\tcase METRICS_SS_APU_SHARE:\n\t\t \n\t\tyellow_carp_get_ss_power_percent(metrics, &apu_percent, &dgpu_percent);\n\t\t*value = apu_percent;\n\t\tbreak;\n\tcase METRICS_SS_DGPU_SHARE:\n\t\t \n\t\tyellow_carp_get_ss_power_percent(metrics, &apu_percent, &dgpu_percent);\n\t\t*value = dgpu_percent;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int yellow_carp_read_sensor(struct smu_context *smu,\n\t\t\t\t\tenum amd_pp_sensors sensor,\n\t\t\t\t\tvoid *data, uint32_t *size)\n{\n\tint ret = 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_CURR_SOCKETPOWER,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_AVERAGE_UCLK,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_AVERAGE_GFXCLK,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_VOLTAGE_VDDGFX,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDNB:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t\t\tMETRICS_VOLTAGE_VDDSOC,\n\t\t\t\t\t\t\t\t(uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_APU_SHARE:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_SS_APU_SHARE,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_DGPU_SHARE:\n\t\tret = yellow_carp_get_smu_metrics_data(smu,\n\t\t\t\t\t\t       METRICS_SS_DGPU_SHARE,\n\t\t\t\t\t\t       (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int yellow_carp_set_watermarks_table(struct smu_context *smu,\n\t\t\t\tstruct pp_smu_wm_range_sets *clock_ranges)\n{\n\tint i;\n\tint ret = 0;\n\tWatermarks_t *table = smu->smu_table.watermarks_table;\n\n\tif (!table || !clock_ranges)\n\t\treturn -EINVAL;\n\n\tif (clock_ranges) {\n\t\tif (clock_ranges->num_reader_wm_sets > NUM_WM_RANGES ||\n\t\t\tclock_ranges->num_writer_wm_sets > NUM_WM_RANGES)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < clock_ranges->num_reader_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MinClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MinMclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxMclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_fill_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].WmSetting =\n\t\t\t\tclock_ranges->reader_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tfor (i = 0; i < clock_ranges->num_writer_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinMclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxMclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_drain_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmSetting =\n\t\t\t\tclock_ranges->writer_wm_sets[i].wm_inst;\n\t\t}\n\n\t\tsmu->watermarks_bitmap |= WATERMARKS_EXIST;\n\t}\n\n\t \n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t     !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {\n\t\tret = smu_cmn_write_watermarks_table(smu);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to update WMTABLE!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsmu->watermarks_bitmap |= WATERMARKS_LOADED;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t yellow_carp_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t\t\tvoid **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_1 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_1 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 1);\n\n\tgpu_metrics->temperature_gfx = metrics.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 8);\n\tgpu_metrics->temperature_l3[0] = metrics.L3Temperature;\n\n\tgpu_metrics->average_gfx_activity = metrics.GfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.UvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.CurrentSocketPower;\n\tgpu_metrics->average_gfx_power = metrics.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Power[1];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t) * 8);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.GfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.SocclkFrequency;\n\tgpu_metrics->average_uclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.MemclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.VclkFrequency;\n\tgpu_metrics->average_dclk_frequency = metrics.DclkFrequency;\n\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 8);\n\tgpu_metrics->current_l3clk[0] = metrics.L3Frequency;\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_1);\n}\n\n \nstatic uint32_t yellow_carp_get_gfxoff_status(struct smu_context *smu)\n{\n\tuint32_t reg;\n\tuint32_t gfxoff_status = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\treg = RREG32_SOC15(SMUIO, 0, regSMUIO_GFX_MISC_CNTL);\n\tgfxoff_status = (reg & SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS_MASK)\n\t\t>> SMUIO_GFX_MISC_CNTL__PWR_GFXOFF_STATUS__SHIFT;\n\n\treturn gfxoff_status;\n}\n\nstatic int yellow_carp_set_default_dpm_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\treturn smu_cmn_update_table(smu, SMU_TABLE_DPMCLOCKS, 0, smu_table->clocks_table, false);\n}\n\nstatic int yellow_carp_od_edit_dpm_table(struct smu_context *smu, enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tlong input[], uint32_t size)\n{\n\tstruct smu_dpm_context *smu_dpm = &(smu->smu_dpm);\n\tint ret = 0;\n\n\t \n\tif (smu_dpm->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (size != 2) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[0] == 0) {\n\t\t\tif (input[1] < smu->gfx_default_hard_min_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t\"Fine grain setting minimum sclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], smu->gfx_default_hard_min_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_hard_min_freq = input[1];\n\t\t} else if (input[0] == 1) {\n\t\t\tif (input[1] > smu->gfx_default_soft_max_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t\"Fine grain setting maximum sclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], smu->gfx_default_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_soft_max_freq = input[1];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (smu->gfx_actual_hard_min_freq > smu->gfx_actual_soft_max_freq) {\n\t\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\t\"The setting minimum sclk (%d) MHz is greater than the setting maximum sclk (%d) MHz\\n\",\n\t\t\t\t\tsmu->gfx_actual_hard_min_freq,\n\t\t\t\t\tsmu->gfx_actual_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\t\t\t\tsmu->gfx_actual_hard_min_freq, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set hard min sclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\t\t\t\tsmu->gfx_actual_soft_max_freq, NULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set soft max sclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int yellow_carp_get_current_clk_freq(struct smu_context *smu,\n\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t *value)\n{\n\tMetricsMember_t member_type;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tmember_type = METRICS_AVERAGE_SOCCLK;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t    member_type = METRICS_AVERAGE_VCLK;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tmember_type = METRICS_AVERAGE_DCLK;\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\tmember_type = METRICS_AVERAGE_UCLK;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_GetFclkFrequency, 0, value);\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\treturn smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\tSMU_MSG_GetGfxclkFrequency, 0, value);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn yellow_carp_get_smu_metrics_data(smu, member_type, value);\n}\n\nstatic int yellow_carp_get_dpm_level_count(struct smu_context *smu,\n\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t *count)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\t*count = clk_table->NumSocClkLevelsEnabled;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\t*count = clk_table->VcnClkLevelsEnabled;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\t*count = clk_table->VcnClkLevelsEnabled;\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\t*count = clk_table->NumDfPstatesEnabled;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\t*count = clk_table->NumDfPstatesEnabled;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int yellow_carp_get_dpm_freq_by_index(struct smu_context *smu,\n\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t dpm_level,\n\t\t\t\t\t\tuint32_t *freq)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tif (!clk_table || clk_type >= SMU_CLK_COUNT)\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tif (dpm_level >= clk_table->NumSocClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->SocClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tif (dpm_level >= clk_table->VcnClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->VClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tif (dpm_level >= clk_table->VcnClkLevelsEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DClocks[dpm_level];\n\t\tbreak;\n\tcase SMU_UCLK:\n\tcase SMU_MCLK:\n\t\tif (dpm_level >= clk_table->NumDfPstatesEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DfPstateTable[dpm_level].MemClk;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tif (dpm_level >= clk_table->NumDfPstatesEnabled)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DfPstateTable[dpm_level].FClk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool yellow_carp_clk_dpm_is_enabled(struct smu_context *smu,\n\t\t\t\t\t\tenum smu_clk_type clk_type)\n{\n\tenum smu_feature_mask feature_id = 0;\n\n\tswitch (clk_type) {\n\tcase SMU_MCLK:\n\tcase SMU_UCLK:\n\tcase SMU_FCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_FCLK_BIT;\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_GFXCLK_BIT;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tfeature_id = SMU_FEATURE_DPM_SOCCLK_BIT;\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tfeature_id = SMU_FEATURE_VCN_DPM_BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn true;\n\t}\n\n\treturn smu_cmn_feature_is_enabled(smu, feature_id);\n}\n\nstatic int yellow_carp_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\t\tuint32_t *min,\n\t\t\t\t\t\t\tuint32_t *max)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\tuint32_t clock_limit;\n\tuint32_t max_dpm_level, min_dpm_level;\n\tint ret = 0;\n\n\tif (!yellow_carp_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.uclk;\n\t\t\tbreak;\n\t\tcase SMU_FCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.fclk;\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.gfxclk;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.socclk;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.vclk;\n\t\t\tbreak;\n\t\tcase SMU_DCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.dclk;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclock_limit = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (min)\n\t\t\t*min = clock_limit / 100;\n\t\tif (max)\n\t\t\t*max = clock_limit / 100;\n\n\t\treturn 0;\n\t}\n\n\tif (max) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\t*max = clk_table->MaxGfxClk;\n\t\t\tbreak;\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\tcase SMU_FCLK:\n\t\t\tmax_dpm_level = 0;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tmax_dpm_level = clk_table->NumSocClkLevelsEnabled - 1;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\tcase SMU_DCLK:\n\t\t\tmax_dpm_level = clk_table->VcnClkLevelsEnabled - 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (clk_type != SMU_GFXCLK && clk_type != SMU_SCLK) {\n\t\t\tret = yellow_carp_get_dpm_freq_by_index(smu, clk_type, max_dpm_level, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (min) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\t*min = clk_table->MinGfxClk;\n\t\t\tbreak;\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\tcase SMU_FCLK:\n\t\t\tmin_dpm_level = clk_table->NumDfPstatesEnabled - 1;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tmin_dpm_level = 0;\n\t\t\tbreak;\n\t\tcase SMU_VCLK:\n\t\tcase SMU_DCLK:\n\t\t\tmin_dpm_level = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (clk_type != SMU_GFXCLK && clk_type != SMU_SCLK) {\n\t\t\tret = yellow_carp_get_dpm_freq_by_index(smu, clk_type, min_dpm_level, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t}\n\t}\n\nfailed:\n\treturn ret;\n}\n\nstatic int yellow_carp_set_soft_freq_limited_range(struct smu_context *smu,\n\t\t\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\t\t\tuint32_t min,\n\t\t\t\t\t\t\tuint32_t max)\n{\n\tenum smu_message_type msg_set_min, msg_set_max;\n\tuint32_t min_clk = min;\n\tuint32_t max_clk = max;\n\n\tint ret = 0;\n\n\tif (!yellow_carp_clk_dpm_is_enabled(smu, clk_type))\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinGfxClk;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxGfxClk;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinFclkByFreq;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxFclkByFreq;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinSocclkByFreq;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxSocclkByFreq;\n\t\tbreak;\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tmsg_set_min = SMU_MSG_SetHardMinVcn;\n\t\tmsg_set_max = SMU_MSG_SetSoftMaxVcn;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_type == SMU_VCLK) {\n\t\tmin_clk = min << SMU_13_VCLK_SHIFT;\n\t\tmax_clk = max << SMU_13_VCLK_SHIFT;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, msg_set_min, min_clk, NULL);\n\n\tif (ret)\n\t\tgoto out;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, msg_set_max, max_clk, NULL);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\treturn ret;\n}\n\nstatic uint32_t yellow_carp_get_umd_pstate_clk_default(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type)\n{\n\tuint32_t clk_limit = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tif ((adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 8))\n\t\t\tclk_limit = SMU_13_0_8_UMD_PSTATE_GFXCLK;\n\t\tif ((adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 1) ||\n\t\t\t(adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 3))\n\t\t\tclk_limit = SMU_13_0_1_UMD_PSTATE_GFXCLK;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tif ((adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 8))\n\t\t\tclk_limit = SMU_13_0_8_UMD_PSTATE_SOCCLK;\n\t\tif ((adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 1) ||\n\t\t\t(adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 3))\n\t\t\tclk_limit = SMU_13_0_1_UMD_PSTATE_SOCCLK;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tif ((adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 8))\n\t\t\tclk_limit = SMU_13_0_8_UMD_PSTATE_FCLK;\n\t\tif ((adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 1) ||\n\t\t\t(adev->ip_versions[MP1_HWIP][0]) == IP_VERSION(13, 0, 3))\n\t\t\tclk_limit = SMU_13_0_1_UMD_PSTATE_FCLK;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn clk_limit;\n}\n\nstatic int yellow_carp_print_clk_levels(struct smu_context *smu,\n\t\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tint i, idx, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0;\n\tuint32_t min, max;\n\tuint32_t clk_limit = 0;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_OD_SCLK:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_SCLK\");\n\t\tsize += sysfs_emit_at(buf, size, \"0: %10uMhz\\n\",\n\t\t(smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq);\n\t\tsize += sysfs_emit_at(buf, size, \"1: %10uMhz\\n\",\n\t\t(smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq);\n\t\tbreak;\n\tcase SMU_OD_RANGE:\n\t\tsize += sysfs_emit_at(buf, size, \"%s:\\n\", \"OD_RANGE\");\n\t\tsize += sysfs_emit_at(buf, size, \"SCLK: %7uMhz %10uMhz\\n\",\n\t\t\t\t\t\tsmu->gfx_default_hard_min_freq, smu->gfx_default_soft_max_freq);\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\tcase SMU_MCLK:\n\tcase SMU_FCLK:\n\t\tret = yellow_carp_get_current_clk_freq(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\tgoto print_clk_out;\n\n\t\tret = yellow_carp_get_dpm_level_count(smu, clk_type, &count);\n\t\tif (ret)\n\t\t\tgoto print_clk_out;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tidx = (clk_type == SMU_FCLK || clk_type == SMU_MCLK) ? (count - i - 1) : i;\n\t\t\tret = yellow_carp_get_dpm_freq_by_index(smu, clk_type, idx, &value);\n\t\t\tif (ret)\n\t\t\t\tgoto print_clk_out;\n\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t}\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tclk_limit = yellow_carp_get_umd_pstate_clk_default(smu, clk_type);\n\t\tret = yellow_carp_get_current_clk_freq(smu, clk_type, &cur_value);\n\t\tif (ret)\n\t\t\tgoto print_clk_out;\n\t\tmin = (smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq;\n\t\tmax = (smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq;\n\t\tif (cur_value  == max)\n\t\t\ti = 2;\n\t\telse if (cur_value == min)\n\t\t\ti = 0;\n\t\telse\n\t\t\ti = 1;\n\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\", min,\n\t\t\t\ti == 0 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\ti == 1 ? cur_value : clk_limit,\n\t\t\t\ti == 1 ? \"*\" : \"\");\n\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz %s\\n\", max,\n\t\t\t\ti == 2 ? \"*\" : \"\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nprint_clk_out:\n\treturn size;\n}\n\nstatic int yellow_carp_force_clk_levels(struct smu_context *smu,\n\t\t\t\tenum smu_clk_type clk_type, uint32_t mask)\n{\n\tuint32_t soft_min_level = 0, soft_max_level = 0;\n\tuint32_t min_freq = 0, max_freq = 0;\n\tint ret = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tret = yellow_carp_get_dpm_freq_by_index(smu, clk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\tgoto force_level_out;\n\n\t\tret = yellow_carp_get_dpm_freq_by_index(smu, clk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\tgoto force_level_out;\n\n\t\tret = yellow_carp_set_soft_freq_limited_range(smu, clk_type, min_freq, max_freq);\n\t\tif (ret)\n\t\t\tgoto force_level_out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nforce_level_out:\n\treturn ret;\n}\n\nstatic int yellow_carp_get_dpm_profile_freq(struct smu_context *smu,\n\t\t\t\t\tenum amd_dpm_forced_level level,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tuint32_t *min_clk,\n\t\t\t\t\tuint32_t *max_clk)\n{\n\tint ret = 0;\n\tuint32_t clk_limit = 0;\n\n\tclk_limit = yellow_carp_get_umd_pstate_clk_default(smu, clk_type);\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SCLK, NULL, &clk_limit);\n\t\telse if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK)\n\t\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SCLK, &clk_limit, NULL);\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SOCCLK, NULL, &clk_limit);\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_FCLK, NULL, &clk_limit);\n\t\telse if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK)\n\t\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_FCLK, &clk_limit, NULL);\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_VCLK, NULL, &clk_limit);\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_DCLK, NULL, &clk_limit);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\t*min_clk = *max_clk = clk_limit;\n\treturn ret;\n}\n\nstatic int yellow_carp_set_performance_level(struct smu_context *smu,\n\t\t\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\tuint32_t sclk_min = 0, sclk_max = 0;\n\tuint32_t fclk_min = 0, fclk_max = 0;\n\tuint32_t socclk_min = 0, socclk_max = 0;\n\tuint32_t vclk_min = 0, vclk_max = 0;\n\tuint32_t dclk_min = 0, dclk_max = 0;\n\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SCLK, NULL, &sclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_FCLK, NULL, &fclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SOCCLK, NULL, &socclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_VCLK, NULL, &vclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_DCLK, NULL, &dclk_max);\n\t\tsclk_min = sclk_max;\n\t\tfclk_min = fclk_max;\n\t\tsocclk_min = socclk_max;\n\t\tvclk_min = vclk_max;\n\t\tdclk_min = dclk_max;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SCLK, &sclk_min, NULL);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_FCLK, &fclk_min, NULL);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SOCCLK, &socclk_min, NULL);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_VCLK, &vclk_min, NULL);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_DCLK, &dclk_min, NULL);\n\t\tsclk_max = sclk_min;\n\t\tfclk_max = fclk_min;\n\t\tsocclk_max = socclk_min;\n\t\tvclk_max = vclk_min;\n\t\tdclk_max = dclk_min;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SCLK, &sclk_min, &sclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_FCLK, &fclk_min, &fclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_SOCCLK, &socclk_min, &socclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_VCLK, &vclk_min, &vclk_max);\n\t\tyellow_carp_get_dpm_ultimate_freq(smu, SMU_DCLK, &dclk_min, &dclk_max);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tyellow_carp_get_dpm_profile_freq(smu, level, SMU_SCLK, &sclk_min, &sclk_max);\n\t\tyellow_carp_get_dpm_profile_freq(smu, level, SMU_FCLK, &fclk_min, &fclk_max);\n\t\tyellow_carp_get_dpm_profile_freq(smu, level, SMU_SOCCLK, &socclk_min, &socclk_max);\n\t\tyellow_carp_get_dpm_profile_freq(smu, level, SMU_VCLK, &vclk_min, &vclk_max);\n\t\tyellow_carp_get_dpm_profile_freq(smu, level, SMU_DCLK, &dclk_min, &dclk_max);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(adev->dev, \"Invalid performance level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sclk_min && sclk_max) {\n\t\tret = yellow_carp_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_SCLK,\n\t\t\t\t\t\t\t    sclk_min,\n\t\t\t\t\t\t\t    sclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsmu->gfx_actual_hard_min_freq = sclk_min;\n\t\tsmu->gfx_actual_soft_max_freq = sclk_max;\n\t}\n\n\tif (fclk_min && fclk_max) {\n\t\tret = yellow_carp_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_FCLK,\n\t\t\t\t\t\t\t    fclk_min,\n\t\t\t\t\t\t\t    fclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (socclk_min && socclk_max) {\n\t\tret = yellow_carp_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t    SMU_SOCCLK,\n\t\t\t\t\t\t\t    socclk_min,\n\t\t\t\t\t\t\t    socclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (vclk_min && vclk_max) {\n\t\tret = yellow_carp_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_VCLK,\n\t\t\t\t\t\t\t      vclk_min,\n\t\t\t\t\t\t\t      vclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dclk_min && dclk_max) {\n\t\tret = yellow_carp_set_soft_freq_limited_range(smu,\n\t\t\t\t\t\t\t      SMU_DCLK,\n\t\t\t\t\t\t\t      dclk_min,\n\t\t\t\t\t\t\t      dclk_max);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int yellow_carp_set_fine_grain_gfx_freq_parameters(struct smu_context *smu)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tsmu->gfx_default_hard_min_freq = clk_table->MinGfxClk;\n\tsmu->gfx_default_soft_max_freq = clk_table->MaxGfxClk;\n\tsmu->gfx_actual_hard_min_freq = 0;\n\tsmu->gfx_actual_soft_max_freq = 0;\n\n\treturn 0;\n}\n\nstatic const struct pptable_funcs yellow_carp_ppt_funcs = {\n\t.check_fw_status = smu_v13_0_check_fw_status,\n\t.check_fw_version = smu_v13_0_check_fw_version,\n\t.init_smc_tables = yellow_carp_init_smc_tables,\n\t.fini_smc_tables = yellow_carp_fini_smc_tables,\n\t.get_vbios_bootup_values = smu_v13_0_get_vbios_bootup_values,\n\t.system_features_control = yellow_carp_system_features_control,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.dpm_set_vcn_enable = yellow_carp_dpm_set_vcn_enable,\n\t.dpm_set_jpeg_enable = yellow_carp_dpm_set_jpeg_enable,\n\t.set_default_dpm_table = yellow_carp_set_default_dpm_tables,\n\t.read_sensor = yellow_carp_read_sensor,\n\t.is_dpm_running = yellow_carp_is_dpm_running,\n\t.set_watermarks_table = yellow_carp_set_watermarks_table,\n\t.get_gpu_metrics = yellow_carp_get_gpu_metrics,\n\t.get_enabled_mask = smu_cmn_get_enabled_mask,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_driver_table_location = smu_v13_0_set_driver_table_location,\n\t.gfx_off_control = smu_v13_0_gfx_off_control,\n\t.get_gfx_off_status = yellow_carp_get_gfxoff_status,\n\t.post_init = yellow_carp_post_smu_init,\n\t.mode2_reset = yellow_carp_mode2_reset,\n\t.get_dpm_ultimate_freq = yellow_carp_get_dpm_ultimate_freq,\n\t.od_edit_dpm_table = yellow_carp_od_edit_dpm_table,\n\t.print_clk_levels = yellow_carp_print_clk_levels,\n\t.force_clk_levels = yellow_carp_force_clk_levels,\n\t.set_performance_level = yellow_carp_set_performance_level,\n\t.set_fine_grain_gfx_freq_parameters = yellow_carp_set_fine_grain_gfx_freq_parameters,\n};\n\nvoid yellow_carp_set_ppt_funcs(struct smu_context *smu)\n{\n\tsmu->ppt_funcs = &yellow_carp_ppt_funcs;\n\tsmu->message_map = yellow_carp_message_map;\n\tsmu->feature_map = yellow_carp_feature_mask_map;\n\tsmu->table_map = yellow_carp_table_map;\n\tsmu->is_apu = true;\n\tsmu->smc_driver_if_version = SMU13_YELLOW_CARP_DRIVER_IF_VERSION;\n\tsmu_v13_0_set_smu_mailbox_registers(smu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}