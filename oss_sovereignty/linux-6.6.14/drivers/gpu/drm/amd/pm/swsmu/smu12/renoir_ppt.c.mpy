{
  "module_name": "renoir_ppt.c",
  "hash_id": "2e1109538ee407340347cabcd55e818ad5e3e6999bafd45fa2c8a6bde7bbb403",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/swsmu/smu12/renoir_ppt.c",
  "human_readable_source": " \n\n#define SWSMU_CODE_LAYER_L2\n\n#include \"amdgpu.h\"\n#include \"amdgpu_smu.h\"\n#include \"smu_v12_0_ppsmc.h\"\n#include \"smu12_driver_if.h\"\n#include \"smu_v12_0.h\"\n#include \"renoir_ppt.h\"\n#include \"smu_cmn.h\"\n\n \n#undef pr_err\n#undef pr_warn\n#undef pr_info\n#undef pr_debug\n\n#define mmMP1_SMN_C2PMSG_66                                                                            0x0282\n#define mmMP1_SMN_C2PMSG_66_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_82                                                                            0x0292\n#define mmMP1_SMN_C2PMSG_82_BASE_IDX                                                                   0\n\n#define mmMP1_SMN_C2PMSG_90                                                                            0x029a\n#define mmMP1_SMN_C2PMSG_90_BASE_IDX                                                                   0\n\nstatic struct cmn2asic_msg_mapping renoir_message_map[SMU_MSG_MAX_COUNT] = {\n\tMSG_MAP(TestMessage,                    PPSMC_MSG_TestMessage,                  1),\n\tMSG_MAP(GetSmuVersion,                  PPSMC_MSG_GetSmuVersion,                1),\n\tMSG_MAP(GetDriverIfVersion,             PPSMC_MSG_GetDriverIfVersion,           1),\n\tMSG_MAP(PowerUpGfx,                     PPSMC_MSG_PowerUpGfx,                   1),\n\tMSG_MAP(AllowGfxOff,                    PPSMC_MSG_EnableGfxOff,                 1),\n\tMSG_MAP(DisallowGfxOff,                 PPSMC_MSG_DisableGfxOff,                1),\n\tMSG_MAP(PowerDownIspByTile,             PPSMC_MSG_PowerDownIspByTile,           1),\n\tMSG_MAP(PowerUpIspByTile,               PPSMC_MSG_PowerUpIspByTile,             1),\n\tMSG_MAP(PowerDownVcn,                   PPSMC_MSG_PowerDownVcn,                 1),\n\tMSG_MAP(PowerUpVcn,                     PPSMC_MSG_PowerUpVcn,                   1),\n\tMSG_MAP(PowerDownSdma,                  PPSMC_MSG_PowerDownSdma,                1),\n\tMSG_MAP(PowerUpSdma,                    PPSMC_MSG_PowerUpSdma,                  1),\n\tMSG_MAP(SetHardMinIspclkByFreq,         PPSMC_MSG_SetHardMinIspclkByFreq,       1),\n\tMSG_MAP(SetHardMinVcn,                  PPSMC_MSG_SetHardMinVcn,                1),\n\tMSG_MAP(SetAllowFclkSwitch,             PPSMC_MSG_SetAllowFclkSwitch,           1),\n\tMSG_MAP(SetMinVideoGfxclkFreq,          PPSMC_MSG_SetMinVideoGfxclkFreq,        1),\n\tMSG_MAP(ActiveProcessNotify,            PPSMC_MSG_ActiveProcessNotify,          1),\n\tMSG_MAP(SetCustomPolicy,                PPSMC_MSG_SetCustomPolicy,              1),\n\tMSG_MAP(SetVideoFps,                    PPSMC_MSG_SetVideoFps,                  1),\n\tMSG_MAP(NumOfDisplays,                  PPSMC_MSG_SetDisplayCount,              1),\n\tMSG_MAP(QueryPowerLimit,                PPSMC_MSG_QueryPowerLimit,              1),\n\tMSG_MAP(SetDriverDramAddrHigh,          PPSMC_MSG_SetDriverDramAddrHigh,        1),\n\tMSG_MAP(SetDriverDramAddrLow,           PPSMC_MSG_SetDriverDramAddrLow,         1),\n\tMSG_MAP(TransferTableSmu2Dram,          PPSMC_MSG_TransferTableSmu2Dram,        1),\n\tMSG_MAP(TransferTableDram2Smu,          PPSMC_MSG_TransferTableDram2Smu,        1),\n\tMSG_MAP(GfxDeviceDriverReset,           PPSMC_MSG_GfxDeviceDriverReset,         1),\n\tMSG_MAP(SetGfxclkOverdriveByFreqVid,    PPSMC_MSG_SetGfxclkOverdriveByFreqVid,  1),\n\tMSG_MAP(SetHardMinDcfclkByFreq,         PPSMC_MSG_SetHardMinDcfclkByFreq,       1),\n\tMSG_MAP(SetHardMinSocclkByFreq,         PPSMC_MSG_SetHardMinSocclkByFreq,       1),\n\tMSG_MAP(ControlIgpuATS,                 PPSMC_MSG_ControlIgpuATS,               1),\n\tMSG_MAP(SetMinVideoFclkFreq,            PPSMC_MSG_SetMinVideoFclkFreq,          1),\n\tMSG_MAP(SetMinDeepSleepDcfclk,          PPSMC_MSG_SetMinDeepSleepDcfclk,        1),\n\tMSG_MAP(ForcePowerDownGfx,              PPSMC_MSG_ForcePowerDownGfx,            1),\n\tMSG_MAP(SetPhyclkVoltageByFreq,         PPSMC_MSG_SetPhyclkVoltageByFreq,       1),\n\tMSG_MAP(SetDppclkVoltageByFreq,         PPSMC_MSG_SetDppclkVoltageByFreq,       1),\n\tMSG_MAP(SetSoftMinVcn,                  PPSMC_MSG_SetSoftMinVcn,                1),\n\tMSG_MAP(EnablePostCode,                 PPSMC_MSG_EnablePostCode,               1),\n\tMSG_MAP(GetGfxclkFrequency,             PPSMC_MSG_GetGfxclkFrequency,           1),\n\tMSG_MAP(GetFclkFrequency,               PPSMC_MSG_GetFclkFrequency,             1),\n\tMSG_MAP(GetMinGfxclkFrequency,          PPSMC_MSG_GetMinGfxclkFrequency,        1),\n\tMSG_MAP(GetMaxGfxclkFrequency,          PPSMC_MSG_GetMaxGfxclkFrequency,        1),\n\tMSG_MAP(SoftReset,                      PPSMC_MSG_SoftReset,                    1),\n\tMSG_MAP(SetGfxCGPG,                     PPSMC_MSG_SetGfxCGPG,                   1),\n\tMSG_MAP(SetSoftMaxGfxClk,               PPSMC_MSG_SetSoftMaxGfxClk,             1),\n\tMSG_MAP(SetHardMinGfxClk,               PPSMC_MSG_SetHardMinGfxClk,             1),\n\tMSG_MAP(SetSoftMaxSocclkByFreq,         PPSMC_MSG_SetSoftMaxSocclkByFreq,       1),\n\tMSG_MAP(SetSoftMaxFclkByFreq,           PPSMC_MSG_SetSoftMaxFclkByFreq,         1),\n\tMSG_MAP(SetSoftMaxVcn,                  PPSMC_MSG_SetSoftMaxVcn,                1),\n\tMSG_MAP(PowerGateMmHub,                 PPSMC_MSG_PowerGateMmHub,               1),\n\tMSG_MAP(UpdatePmeRestore,               PPSMC_MSG_UpdatePmeRestore,             1),\n\tMSG_MAP(GpuChangeState,                 PPSMC_MSG_GpuChangeState,               1),\n\tMSG_MAP(SetPowerLimitPercentage,        PPSMC_MSG_SetPowerLimitPercentage,      1),\n\tMSG_MAP(ForceGfxContentSave,            PPSMC_MSG_ForceGfxContentSave,          1),\n\tMSG_MAP(EnableTmdp48MHzRefclkPwrDown,   PPSMC_MSG_EnableTmdp48MHzRefclkPwrDown, 1),\n\tMSG_MAP(PowerDownJpeg,                  PPSMC_MSG_PowerDownJpeg,                1),\n\tMSG_MAP(PowerUpJpeg,                    PPSMC_MSG_PowerUpJpeg,                  1),\n\tMSG_MAP(PowerGateAtHub,                 PPSMC_MSG_PowerGateAtHub,               1),\n\tMSG_MAP(SetSoftMinJpeg,                 PPSMC_MSG_SetSoftMinJpeg,               1),\n\tMSG_MAP(SetHardMinFclkByFreq,           PPSMC_MSG_SetHardMinFclkByFreq,         1),\n};\n\nstatic struct cmn2asic_mapping renoir_clk_map[SMU_CLK_COUNT] = {\n\tCLK_MAP(GFXCLK, CLOCK_GFXCLK),\n\tCLK_MAP(SCLK,\tCLOCK_GFXCLK),\n\tCLK_MAP(SOCCLK, CLOCK_SOCCLK),\n\tCLK_MAP(UCLK, CLOCK_FCLK),\n\tCLK_MAP(MCLK, CLOCK_FCLK),\n\tCLK_MAP(VCLK, CLOCK_VCLK),\n\tCLK_MAP(DCLK, CLOCK_DCLK),\n};\n\nstatic struct cmn2asic_mapping renoir_table_map[SMU_TABLE_COUNT] = {\n\tTAB_MAP_VALID(WATERMARKS),\n\tTAB_MAP_INVALID(CUSTOM_DPM),\n\tTAB_MAP_VALID(DPMCLOCKS),\n\tTAB_MAP_VALID(SMU_METRICS),\n};\n\nstatic struct cmn2asic_mapping renoir_workload_map[PP_SMC_POWER_PROFILE_COUNT] = {\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_FULLSCREEN3D,\t\tWORKLOAD_PPLIB_FULL_SCREEN_3D_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VIDEO,\t\tWORKLOAD_PPLIB_VIDEO_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_VR,\t\t\tWORKLOAD_PPLIB_VR_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_COMPUTE,\t\tWORKLOAD_PPLIB_COMPUTE_BIT),\n\tWORKLOAD_MAP(PP_SMC_POWER_PROFILE_CUSTOM,\t\tWORKLOAD_PPLIB_CUSTOM_BIT),\n};\n\nstatic const uint8_t renoir_throttler_map[] = {\n\t[THROTTLER_STATUS_BIT_SPL]\t\t= (SMU_THROTTLER_SPL_BIT),\n\t[THROTTLER_STATUS_BIT_FPPT]\t\t= (SMU_THROTTLER_FPPT_BIT),\n\t[THROTTLER_STATUS_BIT_SPPT]\t\t= (SMU_THROTTLER_SPPT_BIT),\n\t[THROTTLER_STATUS_BIT_SPPT_APU]\t\t= (SMU_THROTTLER_SPPT_APU_BIT),\n\t[THROTTLER_STATUS_BIT_THM_CORE]\t\t= (SMU_THROTTLER_TEMP_CORE_BIT),\n\t[THROTTLER_STATUS_BIT_THM_GFX]\t\t= (SMU_THROTTLER_TEMP_GPU_BIT),\n\t[THROTTLER_STATUS_BIT_THM_SOC]\t\t= (SMU_THROTTLER_TEMP_SOC_BIT),\n\t[THROTTLER_STATUS_BIT_TDC_VDD]\t\t= (SMU_THROTTLER_TDC_VDD_BIT),\n\t[THROTTLER_STATUS_BIT_TDC_SOC]\t\t= (SMU_THROTTLER_TDC_SOC_BIT),\n\t[THROTTLER_STATUS_BIT_PROCHOT_CPU]\t= (SMU_THROTTLER_PROCHOT_CPU_BIT),\n\t[THROTTLER_STATUS_BIT_PROCHOT_GFX]\t= (SMU_THROTTLER_PROCHOT_GFX_BIT),\n\t[THROTTLER_STATUS_BIT_EDC_CPU]\t\t= (SMU_THROTTLER_EDC_CPU_BIT),\n\t[THROTTLER_STATUS_BIT_EDC_GFX]\t\t= (SMU_THROTTLER_EDC_GFX_BIT),\n};\n\nstatic int renoir_init_smc_tables(struct smu_context *smu)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct smu_table *tables = smu_table->tables;\n\n\tSMU_TABLE_INIT(tables, SMU_TABLE_WATERMARKS, sizeof(Watermarks_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_DPMCLOCKS, sizeof(DpmClocks_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\tSMU_TABLE_INIT(tables, SMU_TABLE_SMU_METRICS, sizeof(SmuMetrics_t),\n\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_VRAM);\n\n\tsmu_table->clocks_table = kzalloc(sizeof(DpmClocks_t), GFP_KERNEL);\n\tif (!smu_table->clocks_table)\n\t\tgoto err0_out;\n\n\tsmu_table->metrics_table = kzalloc(sizeof(SmuMetrics_t), GFP_KERNEL);\n\tif (!smu_table->metrics_table)\n\t\tgoto err1_out;\n\tsmu_table->metrics_time = 0;\n\n\tsmu_table->watermarks_table = kzalloc(sizeof(Watermarks_t), GFP_KERNEL);\n\tif (!smu_table->watermarks_table)\n\t\tgoto err2_out;\n\n\tsmu_table->gpu_metrics_table_size = sizeof(struct gpu_metrics_v2_2);\n\tsmu_table->gpu_metrics_table = kzalloc(smu_table->gpu_metrics_table_size, GFP_KERNEL);\n\tif (!smu_table->gpu_metrics_table)\n\t\tgoto err3_out;\n\n\treturn 0;\n\nerr3_out:\n\tkfree(smu_table->watermarks_table);\nerr2_out:\n\tkfree(smu_table->metrics_table);\nerr1_out:\n\tkfree(smu_table->clocks_table);\nerr0_out:\n\treturn -ENOMEM;\n}\n\n \nstatic int renoir_get_dpm_clk_limited(struct smu_context *smu, enum smu_clk_type clk_type,\n\t\t\t\t\t\tuint32_t dpm_level, uint32_t *freq)\n{\n\tDpmClocks_t *clk_table = smu->smu_table.clocks_table;\n\n\tif (!clk_table || clk_type >= SMU_CLK_COUNT)\n\t\treturn -EINVAL;\n\n\tswitch (clk_type) {\n\tcase SMU_SOCCLK:\n\t\tif (dpm_level >= NUM_SOCCLK_DPM_LEVELS)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->SocClocks[dpm_level].Freq;\n\t\tbreak;\n\tcase SMU_UCLK:\n\tcase SMU_MCLK:\n\t\tif (dpm_level >= NUM_FCLK_DPM_LEVELS)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->FClocks[dpm_level].Freq;\n\t\tbreak;\n\tcase SMU_DCEFCLK:\n\t\tif (dpm_level >= NUM_DCFCLK_DPM_LEVELS)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DcfClocks[dpm_level].Freq;\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tif (dpm_level >= NUM_FCLK_DPM_LEVELS)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->FClocks[dpm_level].Freq;\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tif (dpm_level >= NUM_VCN_DPM_LEVELS)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->VClocks[dpm_level].Freq;\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tif (dpm_level >= NUM_VCN_DPM_LEVELS)\n\t\t\treturn -EINVAL;\n\t\t*freq = clk_table->DClocks[dpm_level].Freq;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int renoir_get_profiling_clk_mask(struct smu_context *smu,\n\t\t\t\t\t enum amd_dpm_forced_level level,\n\t\t\t\t\t uint32_t *sclk_mask,\n\t\t\t\t\t uint32_t *mclk_mask,\n\t\t\t\t\t uint32_t *soc_mask)\n{\n\n\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK) {\n\t\tif (sclk_mask)\n\t\t\t*sclk_mask = 0;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK) {\n\t\tif (mclk_mask)\n\t\t\t \n\t\t\t*mclk_mask = NUM_MEMCLK_DPM_LEVELS - 1;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\tif (sclk_mask)\n\t\t\t \n\t\t\t*sclk_mask = 3 - 1;\n\n\t\tif (mclk_mask)\n\t\t\t \n\t\t\t*mclk_mask = 0;\n\n\t\tif (soc_mask)\n\t\t\t*soc_mask = NUM_SOCCLK_DPM_LEVELS - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int renoir_get_dpm_ultimate_freq(struct smu_context *smu,\n\t\t\t\t\tenum smu_clk_type clk_type,\n\t\t\t\t\tuint32_t *min,\n\t\t\t\t\tuint32_t *max)\n{\n\tint ret = 0;\n\tuint32_t mclk_mask, soc_mask;\n\tuint32_t clock_limit;\n\n\tif (!smu_cmn_clk_dpm_is_enabled(smu, clk_type)) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_MCLK:\n\t\tcase SMU_UCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.uclk;\n\t\t\tbreak;\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.gfxclk;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tclock_limit = smu->smu_table.boot_values.socclk;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tclock_limit = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (min)\n\t\t\t*min = clock_limit / 100;\n\t\tif (max)\n\t\t\t*max = clock_limit / 100;\n\n\t\treturn 0;\n\t}\n\n\tif (max) {\n\t\tret = renoir_get_profiling_clk_mask(smu,\n\t\t\t\t\t\t    AMD_DPM_FORCED_LEVEL_PROFILE_PEAK,\n\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t    &mclk_mask,\n\t\t\t\t\t\t    &soc_mask);\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\tswitch (clk_type) {\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetMaxGfxclkFrequency, max);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Attempt to get max GX frequency from SMC Failed !\\n\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SMU_UCLK:\n\t\tcase SMU_FCLK:\n\t\tcase SMU_MCLK:\n\t\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, mclk_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, soc_mask, max);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (min) {\n\t\tswitch (clk_type) {\n\t\tcase SMU_GFXCLK:\n\t\tcase SMU_SCLK:\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_GetMinGfxclkFrequency, min);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Attempt to get min GX frequency from SMC Failed !\\n\");\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SMU_UCLK:\n\t\tcase SMU_FCLK:\n\t\tcase SMU_MCLK:\n\t\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, NUM_MEMCLK_DPM_LEVELS - 1, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tcase SMU_SOCCLK:\n\t\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, 0, min);\n\t\t\tif (ret)\n\t\t\t\tgoto failed;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\t}\nfailed:\n\treturn ret;\n}\n\nstatic int renoir_od_edit_dpm_table(struct smu_context *smu,\n\t\t\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\t\t\tlong input[], uint32_t size)\n{\n\tint ret = 0;\n\tstruct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);\n\n\tif (!(smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL)) {\n\t\tdev_warn(smu->adev->dev,\n\t\t\t\"pp_od_clk_voltage is not accessible if power_dpm_force_performance_level is not in manual mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase PP_OD_EDIT_SCLK_VDDC_TABLE:\n\t\tif (size != 2) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (input[0] == 0) {\n\t\t\tif (input[1] < smu->gfx_default_hard_min_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t\"Fine grain setting minimum sclk (%ld) MHz is less than the minimum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], smu->gfx_default_hard_min_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_hard_min_freq = input[1];\n\t\t} else if (input[0] == 1) {\n\t\t\tif (input[1] > smu->gfx_default_soft_max_freq) {\n\t\t\t\tdev_warn(smu->adev->dev,\n\t\t\t\t\t\"Fine grain setting maximum sclk (%ld) MHz is greater than the maximum allowed (%d) MHz\\n\",\n\t\t\t\t\tinput[1], smu->gfx_default_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsmu->gfx_actual_soft_max_freq = input[1];\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase PP_OD_RESTORE_DEFAULT_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\t\tbreak;\n\tcase PP_OD_COMMIT_DPM_TABLE:\n\t\tif (size != 0) {\n\t\t\tdev_err(smu->adev->dev, \"Input parameter number not correct\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (smu->gfx_actual_hard_min_freq > smu->gfx_actual_soft_max_freq) {\n\t\t\t\tdev_err(smu->adev->dev,\n\t\t\t\t\t\"The setting minimum sclk (%d) MHz is greater than the setting maximum sclk (%d) MHz\\n\",\n\t\t\t\t\tsmu->gfx_actual_hard_min_freq,\n\t\t\t\t\tsmu->gfx_actual_soft_max_freq);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\t\t\tsmu->gfx_actual_hard_min_freq,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set hard min sclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\t\t\tsmu->gfx_actual_soft_max_freq,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(smu->adev->dev, \"Set soft max sclk failed!\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn ret;\n}\n\nstatic int renoir_set_fine_grain_gfx_freq_parameters(struct smu_context *smu)\n{\n\tuint32_t min = 0, max = 0;\n\tuint32_t ret = 0;\n\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_GetMinGfxclkFrequency,\n\t\t\t\t\t\t\t\t0, &min);\n\tif (ret)\n\t\treturn ret;\n\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t\t\tSMU_MSG_GetMaxGfxclkFrequency,\n\t\t\t\t\t\t\t\t0, &max);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu->gfx_default_hard_min_freq = min;\n\tsmu->gfx_default_soft_max_freq = max;\n\tsmu->gfx_actual_hard_min_freq = 0;\n\tsmu->gfx_actual_soft_max_freq = 0;\n\n\treturn 0;\n}\n\nstatic int renoir_print_clk_levels(struct smu_context *smu,\n\t\t\tenum smu_clk_type clk_type, char *buf)\n{\n\tint i, idx, size = 0, ret = 0;\n\tuint32_t cur_value = 0, value = 0, count = 0, min = 0, max = 0;\n\tSmuMetrics_t metrics;\n\tstruct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);\n\tbool cur_value_match_level = false;\n\n\tmemset(&metrics, 0, sizeof(metrics));\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, false);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_get_sysfs_buf(&buf, &size);\n\n\tswitch (clk_type) {\n\tcase SMU_OD_RANGE:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\tSMU_MSG_GetMinGfxclkFrequency,\n\t\t\t\t\t\t0, &min);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\tSMU_MSG_GetMaxGfxclkFrequency,\n\t\t\t\t\t\t0, &max);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsize += sysfs_emit_at(buf, size, \"OD_RANGE\\nSCLK: %10uMhz %10uMhz\\n\", min, max);\n\t\t}\n\t\tbreak;\n\tcase SMU_OD_SCLK:\n\t\tif (smu_dpm_ctx->dpm_level == AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\t\tmin = (smu->gfx_actual_hard_min_freq > 0) ? smu->gfx_actual_hard_min_freq : smu->gfx_default_hard_min_freq;\n\t\t\tmax = (smu->gfx_actual_soft_max_freq > 0) ? smu->gfx_actual_soft_max_freq : smu->gfx_default_soft_max_freq;\n\t\t\tsize += sysfs_emit_at(buf, size, \"OD_SCLK\\n\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"0:%10uMhz\\n\", min);\n\t\t\tsize += sysfs_emit_at(buf, size, \"1:%10uMhz\\n\", max);\n\t\t}\n\t\tbreak;\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\t \n\t\tcur_value = metrics.ClockFrequency[CLOCK_GFXCLK];\n\t\tret = renoir_get_dpm_ultimate_freq(smu, SMU_GFXCLK, &min, &max);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tif (cur_value  == max)\n\t\t\t\ti = 2;\n\t\t\telse if (cur_value == min)\n\t\t\t\ti = 0;\n\t\t\telse\n\t\t\t\ti = 1;\n\n\t\t\tsize += sysfs_emit_at(buf, size, \"0: %uMhz %s\\n\", min,\n\t\t\t\t\ti == 0 ? \"*\" : \"\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"1: %uMhz %s\\n\",\n\t\t\t\t\ti == 1 ? cur_value : RENOIR_UMD_PSTATE_GFXCLK,\n\t\t\t\t\ti == 1 ? \"*\" : \"\");\n\t\t\tsize += sysfs_emit_at(buf, size, \"2: %uMhz %s\\n\", max,\n\t\t\t\t\ti == 2 ? \"*\" : \"\");\n\t\t}\n\t\treturn size;\n\tcase SMU_SOCCLK:\n\t\tcount = NUM_SOCCLK_DPM_LEVELS;\n\t\tcur_value = metrics.ClockFrequency[CLOCK_SOCCLK];\n\t\tbreak;\n\tcase SMU_MCLK:\n\t\tcount = NUM_MEMCLK_DPM_LEVELS;\n\t\tcur_value = metrics.ClockFrequency[CLOCK_FCLK];\n\t\tbreak;\n\tcase SMU_DCEFCLK:\n\t\tcount = NUM_DCFCLK_DPM_LEVELS;\n\t\tcur_value = metrics.ClockFrequency[CLOCK_DCFCLK];\n\t\tbreak;\n\tcase SMU_FCLK:\n\t\tcount = NUM_FCLK_DPM_LEVELS;\n\t\tcur_value = metrics.ClockFrequency[CLOCK_FCLK];\n\t\tbreak;\n\tcase SMU_VCLK:\n\t\tcount = NUM_VCN_DPM_LEVELS;\n\t\tcur_value = metrics.ClockFrequency[CLOCK_VCLK];\n\t\tbreak;\n\tcase SMU_DCLK:\n\t\tcount = NUM_VCN_DPM_LEVELS;\n\t\tcur_value = metrics.ClockFrequency[CLOCK_DCLK];\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\tcase SMU_SOCCLK:\n\tcase SMU_MCLK:\n\tcase SMU_DCEFCLK:\n\tcase SMU_FCLK:\n\tcase SMU_VCLK:\n\tcase SMU_DCLK:\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tidx = (clk_type == SMU_FCLK || clk_type == SMU_MCLK) ? (count - i - 1) : i;\n\t\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, idx, &value);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (!value)\n\t\t\t\tcontinue;\n\t\t\tsize += sysfs_emit_at(buf, size, \"%d: %uMhz %s\\n\", i, value,\n\t\t\t\t\tcur_value == value ? \"*\" : \"\");\n\t\t\tif (cur_value == value)\n\t\t\t\tcur_value_match_level = true;\n\t\t}\n\n\t\tif (!cur_value_match_level)\n\t\t\tsize += sysfs_emit_at(buf, size, \"   %uMhz *\\n\", cur_value);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic enum amd_pm_state_type renoir_get_current_power_state(struct smu_context *smu)\n{\n\tenum amd_pm_state_type pm_type;\n\tstruct smu_dpm_context *smu_dpm_ctx = &(smu->smu_dpm);\n\n\tif (!smu_dpm_ctx->dpm_context ||\n\t    !smu_dpm_ctx->dpm_current_power_state)\n\t\treturn -EINVAL;\n\n\tswitch (smu_dpm_ctx->dpm_current_power_state->classification.ui_label) {\n\tcase SMU_STATE_UI_LABEL_BATTERY:\n\t\tpm_type = POWER_STATE_TYPE_BATTERY;\n\t\tbreak;\n\tcase SMU_STATE_UI_LABEL_BALLANCED:\n\t\tpm_type = POWER_STATE_TYPE_BALANCED;\n\t\tbreak;\n\tcase SMU_STATE_UI_LABEL_PERFORMANCE:\n\t\tpm_type = POWER_STATE_TYPE_PERFORMANCE;\n\t\tbreak;\n\tdefault:\n\t\tif (smu_dpm_ctx->dpm_current_power_state->classification.flags & SMU_STATE_CLASSIFICATION_FLAG_BOOT)\n\t\t\tpm_type = POWER_STATE_TYPE_INTERNAL_BOOT;\n\t\telse\n\t\t\tpm_type = POWER_STATE_TYPE_DEFAULT;\n\t\tbreak;\n\t}\n\n\treturn pm_type;\n}\n\nstatic int renoir_dpm_set_vcn_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\t \n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpVcn, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_VCN_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg(smu, SMU_MSG_PowerDownVcn, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int renoir_dpm_set_jpeg_enable(struct smu_context *smu, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_JPEG_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerUpJpeg, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (smu_cmn_feature_is_enabled(smu, SMU_FEATURE_JPEG_PG_BIT)) {\n\t\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_PowerDownJpeg, 0, NULL);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int renoir_force_dpm_limit_value(struct smu_context *smu, bool highest)\n{\n\tint ret = 0, i = 0;\n\tuint32_t min_freq, max_freq, force_freq;\n\tenum smu_clk_type clk_type;\n\n\tenum smu_clk_type clks[] = {\n\t\tSMU_GFXCLK,\n\t\tSMU_MCLK,\n\t\tSMU_SOCCLK,\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(clks); i++) {\n\t\tclk_type = clks[i];\n\t\tret = renoir_get_dpm_ultimate_freq(smu, clk_type, &min_freq, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tforce_freq = highest ? max_freq : min_freq;\n\t\tret = smu_v12_0_set_soft_freq_limited_range(smu, clk_type, force_freq, force_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int renoir_unforce_dpm_levels(struct smu_context *smu) {\n\n\tint ret = 0, i = 0;\n\tuint32_t min_freq, max_freq;\n\tenum smu_clk_type clk_type;\n\n\tstruct clk_feature_map {\n\t\tenum smu_clk_type clk_type;\n\t\tuint32_t\tfeature;\n\t} clk_feature_map[] = {\n\t\t{SMU_GFXCLK, SMU_FEATURE_DPM_GFXCLK_BIT},\n\t\t{SMU_MCLK,   SMU_FEATURE_DPM_UCLK_BIT},\n\t\t{SMU_SOCCLK, SMU_FEATURE_DPM_SOCCLK_BIT},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_feature_map); i++) {\n\t\tif (!smu_cmn_feature_is_enabled(smu, clk_feature_map[i].feature))\n\t\t    continue;\n\n\t\tclk_type = clk_feature_map[i].clk_type;\n\n\t\tret = renoir_get_dpm_ultimate_freq(smu, clk_type, &min_freq, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_v12_0_set_soft_freq_limited_range(smu, clk_type, min_freq, max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int renoir_get_dpm_clock_table(struct smu_context *smu, struct dpm_clocks *clock_table)\n{\n\tDpmClocks_t *table = smu->smu_table.clocks_table;\n\tint i;\n\n\tif (!clock_table || !table)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < NUM_DCFCLK_DPM_LEVELS; i++) {\n\t\tclock_table->DcfClocks[i].Freq = table->DcfClocks[i].Freq;\n\t\tclock_table->DcfClocks[i].Vol = table->DcfClocks[i].Vol;\n\t}\n\n\tfor (i = 0; i < NUM_SOCCLK_DPM_LEVELS; i++) {\n\t\tclock_table->SocClocks[i].Freq = table->SocClocks[i].Freq;\n\t\tclock_table->SocClocks[i].Vol = table->SocClocks[i].Vol;\n\t}\n\n\tfor (i = 0; i < NUM_FCLK_DPM_LEVELS; i++) {\n\t\tclock_table->FClocks[i].Freq = table->FClocks[i].Freq;\n\t\tclock_table->FClocks[i].Vol = table->FClocks[i].Vol;\n\t}\n\n\tfor (i = 0; i<  NUM_MEMCLK_DPM_LEVELS; i++) {\n\t\tclock_table->MemClocks[i].Freq = table->MemClocks[i].Freq;\n\t\tclock_table->MemClocks[i].Vol = table->MemClocks[i].Vol;\n\t}\n\n\tfor (i = 0; i < NUM_VCN_DPM_LEVELS; i++) {\n\t\tclock_table->VClocks[i].Freq = table->VClocks[i].Freq;\n\t\tclock_table->VClocks[i].Vol = table->VClocks[i].Vol;\n\t}\n\n\tfor (i = 0; i < NUM_VCN_DPM_LEVELS; i++) {\n\t\tclock_table->DClocks[i].Freq = table->DClocks[i].Freq;\n\t\tclock_table->DClocks[i].Vol = table->DClocks[i].Vol;\n\t}\n\n\treturn 0;\n}\n\nstatic int renoir_force_clk_levels(struct smu_context *smu,\n\t\t\t\t   enum smu_clk_type clk_type, uint32_t mask)\n{\n\n\tint ret = 0 ;\n\tuint32_t soft_min_level = 0, soft_max_level = 0, min_freq = 0, max_freq = 0;\n\n\tsoft_min_level = mask ? (ffs(mask) - 1) : 0;\n\tsoft_max_level = mask ? (fls(mask) - 1) : 0;\n\n\tswitch (clk_type) {\n\tcase SMU_GFXCLK:\n\tcase SMU_SCLK:\n\t\tif (soft_min_level > 2 || soft_max_level > 2) {\n\t\t\tdev_info(smu->adev->dev, \"Currently sclk only support 3 levels on APU\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = renoir_get_dpm_ultimate_freq(smu, SMU_GFXCLK, &min_freq, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\tsoft_max_level == 0 ? min_freq :\n\t\t\t\t\tsoft_max_level == 1 ? RENOIR_UMD_PSTATE_GFXCLK : max_freq,\n\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\tsoft_min_level == 2 ? max_freq :\n\t\t\t\t\tsoft_min_level == 1 ? RENOIR_UMD_PSTATE_GFXCLK : min_freq,\n\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_SOCCLK:\n\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxSocclkByFreq, max_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinSocclkByFreq, min_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SMU_MCLK:\n\tcase SMU_FCLK:\n\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, soft_min_level, &min_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = renoir_get_dpm_clk_limited(smu, clk_type, soft_max_level, &max_freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetSoftMaxFclkByFreq, max_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_SetHardMinFclkByFreq, min_freq, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int renoir_set_power_profile_mode(struct smu_context *smu, long *input, uint32_t size)\n{\n\tint workload_type, ret;\n\tuint32_t profile_mode = input[size];\n\n\tif (profile_mode > PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tdev_err(smu->adev->dev, \"Invalid power profile mode %d\\n\", profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (profile_mode == PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT ||\n\t\t\tprofile_mode == PP_SMC_POWER_PROFILE_POWERSAVING)\n\t\treturn 0;\n\n\t \n\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t       profile_mode);\n\tif (workload_type < 0) {\n\t\t \n\t\tdev_dbg(smu->adev->dev, \"Unsupported power profile mode %d on RENOIR\\n\", profile_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tret = smu_cmn_send_smc_msg_with_param(smu, SMU_MSG_ActiveProcessNotify,\n\t\t\t\t    1 << workload_type,\n\t\t\t\t    NULL);\n\tif (ret) {\n\t\tdev_err_once(smu->adev->dev, \"Fail to set workload type %d\\n\", workload_type);\n\t\treturn ret;\n\t}\n\n\tsmu->power_profile_mode = profile_mode;\n\n\treturn 0;\n}\n\nstatic int renoir_set_peak_clock_by_device(struct smu_context *smu)\n{\n\tint ret = 0;\n\tuint32_t sclk_freq = 0, uclk_freq = 0;\n\n\tret = renoir_get_dpm_ultimate_freq(smu, SMU_SCLK, NULL, &sclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_v12_0_set_soft_freq_limited_range(smu, SMU_SCLK, sclk_freq, sclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = renoir_get_dpm_ultimate_freq(smu, SMU_UCLK, NULL, &uclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = smu_v12_0_set_soft_freq_limited_range(smu, SMU_UCLK, uclk_freq, uclk_freq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int renoir_set_performance_level(struct smu_context *smu,\n\t\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tint ret = 0;\n\tuint32_t sclk_mask, mclk_mask, soc_mask;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = renoir_force_dpm_limit_value(smu, true);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = renoir_force_dpm_limit_value(smu, false);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = renoir_unforce_dpm_levels(smu);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetHardMinGfxClk,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_GFXCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetHardMinFclkByFreq,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_FCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetHardMinSocclkByFreq,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_SOCCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetHardMinVcn,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_VCNCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetSoftMaxGfxClk,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_GFXCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetSoftMaxFclkByFreq,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_FCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetSoftMaxSocclkByFreq,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_SOCCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = smu_cmn_send_smc_msg_with_param(smu,\n\t\t\t\t\t\t      SMU_MSG_SetSoftMaxVcn,\n\t\t\t\t\t\t      RENOIR_UMD_PSTATE_VCNCLK,\n\t\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = renoir_get_profiling_clk_mask(smu, level,\n\t\t\t\t\t\t    &sclk_mask,\n\t\t\t\t\t\t    &mclk_mask,\n\t\t\t\t\t\t    &soc_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trenoir_force_clk_levels(smu, SMU_SCLK, 1 << sclk_mask);\n\t\trenoir_force_clk_levels(smu, SMU_MCLK, 1 << mclk_mask);\n\t\trenoir_force_clk_levels(smu, SMU_SOCCLK, 1 << soc_mask);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tsmu->gfx_actual_hard_min_freq = smu->gfx_default_hard_min_freq;\n\t\tsmu->gfx_actual_soft_max_freq = smu->gfx_default_soft_max_freq;\n\n\t\tret = renoir_set_peak_clock_by_device(smu);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int renoir_set_watermarks_table(\n\t\tstruct smu_context *smu,\n\t\tstruct pp_smu_wm_range_sets *clock_ranges)\n{\n\tWatermarks_t *table = smu->smu_table.watermarks_table;\n\tint ret = 0;\n\tint i;\n\n\tif (clock_ranges) {\n\t\tif (clock_ranges->num_reader_wm_sets > NUM_WM_RANGES ||\n\t\t    clock_ranges->num_writer_wm_sets > NUM_WM_RANGES)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tfor (i = 0; i < clock_ranges->num_reader_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MinClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxClock =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MinMclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].MaxMclk =\n\t\t\t\tclock_ranges->reader_wm_sets[i].max_fill_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].WmSetting =\n\t\t\t\tclock_ranges->reader_wm_sets[i].wm_inst;\n\t\t\ttable->WatermarkRow[WM_DCFCLK][i].WmType =\n\t\t\t\tclock_ranges->reader_wm_sets[i].wm_type;\n\t\t}\n\n\t\tfor (i = 0; i < clock_ranges->num_writer_wm_sets; i++) {\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxClock =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_fill_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MinMclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].min_drain_clk_mhz;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].MaxMclk =\n\t\t\t\tclock_ranges->writer_wm_sets[i].max_drain_clk_mhz;\n\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmSetting =\n\t\t\t\tclock_ranges->writer_wm_sets[i].wm_inst;\n\t\t\ttable->WatermarkRow[WM_SOCCLK][i].WmType =\n\t\t\t\tclock_ranges->writer_wm_sets[i].wm_type;\n\t\t}\n\n\t\tsmu->watermarks_bitmap |= WATERMARKS_EXIST;\n\t}\n\n\t \n\tif ((smu->watermarks_bitmap & WATERMARKS_EXIST) &&\n\t     !(smu->watermarks_bitmap & WATERMARKS_LOADED)) {\n\t\tret = smu_cmn_write_watermarks_table(smu);\n\t\tif (ret) {\n\t\t\tdev_err(smu->adev->dev, \"Failed to update WMTABLE!\");\n\t\t\treturn ret;\n\t\t}\n\t\tsmu->watermarks_bitmap |= WATERMARKS_LOADED;\n\t}\n\n\treturn 0;\n}\n\nstatic int renoir_get_power_profile_mode(struct smu_context *smu,\n\t\t\t\t\t   char *buf)\n{\n\tuint32_t i, size = 0;\n\tint16_t workload_type = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i <= PP_SMC_POWER_PROFILE_CUSTOM; i++) {\n\t\t \n\t\tworkload_type = smu_cmn_to_asic_specific_index(smu,\n\t\t\t\t\t\t\t       CMN2ASIC_MAPPING_WORKLOAD,\n\t\t\t\t\t\t\t       i);\n\t\tif (workload_type < 0)\n\t\t\tcontinue;\n\n\t\tsize += sysfs_emit_at(buf, size, \"%2d %14s%s\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == smu->power_profile_mode) ? \"*\" : \" \");\n\t}\n\n\treturn size;\n}\n\nstatic void renoir_get_ss_power_percent(SmuMetrics_t *metrics,\n\t\t\t\t\tuint32_t *apu_percent, uint32_t *dgpu_percent)\n{\n\tuint32_t apu_boost = 0;\n\tuint32_t dgpu_boost = 0;\n\tuint16_t apu_limit = 0;\n\tuint16_t dgpu_limit = 0;\n\tuint16_t apu_power = 0;\n\tuint16_t dgpu_power = 0;\n\n\tapu_power = metrics->ApuPower;\n\tapu_limit = metrics->StapmOriginalLimit;\n\tif (apu_power > apu_limit && apu_limit != 0)\n\t\tapu_boost =  ((apu_power - apu_limit) * 100) / apu_limit;\n\tapu_boost = (apu_boost > 100) ? 100 : apu_boost;\n\n\tdgpu_power = metrics->dGpuPower;\n\tif (metrics->StapmCurrentLimit > metrics->StapmOriginalLimit)\n\t\tdgpu_limit = metrics->StapmCurrentLimit - metrics->StapmOriginalLimit;\n\tif (dgpu_power > dgpu_limit && dgpu_limit != 0)\n\t\tdgpu_boost = ((dgpu_power - dgpu_limit) * 100) / dgpu_limit;\n\tdgpu_boost = (dgpu_boost > 100) ? 100 : dgpu_boost;\n\n\tif (dgpu_boost >= apu_boost)\n\t\tapu_boost = 0;\n\telse\n\t\tdgpu_boost = 0;\n\n\t*apu_percent = apu_boost;\n\t*dgpu_percent = dgpu_boost;\n}\n\n\nstatic int renoir_get_smu_metrics_data(struct smu_context *smu,\n\t\t\t\t       MetricsMember_t member,\n\t\t\t\t       uint32_t *value)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\n\tSmuMetrics_t *metrics = (SmuMetrics_t *)smu_table->metrics_table;\n\tint ret = 0;\n\tuint32_t apu_percent = 0;\n\tuint32_t dgpu_percent = 0;\n\tstruct amdgpu_device *adev = smu->adev;\n\n\n\tret = smu_cmn_get_metrics_table(smu,\n\t\t\t\t\tNULL,\n\t\t\t\t\tfalse);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (member) {\n\tcase METRICS_AVERAGE_GFXCLK:\n\t\t*value = metrics->ClockFrequency[CLOCK_GFXCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_SOCCLK:\n\t\t*value = metrics->ClockFrequency[CLOCK_SOCCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_UCLK:\n\t\t*value = metrics->ClockFrequency[CLOCK_FCLK];\n\t\tbreak;\n\tcase METRICS_AVERAGE_GFXACTIVITY:\n\t\t*value = metrics->AverageGfxActivity / 100;\n\t\tbreak;\n\tcase METRICS_AVERAGE_VCNACTIVITY:\n\t\t*value = metrics->AverageUvdActivity / 100;\n\t\tbreak;\n\tcase METRICS_CURR_SOCKETPOWER:\n\t\tif (((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(12, 0, 1)) && (adev->pm.fw_version >= 0x40000f)) ||\n\t\t((adev->ip_versions[MP1_HWIP][0] == IP_VERSION(12, 0, 0)) && (adev->pm.fw_version >= 0x373200)))\n\t\t\t*value = metrics->CurrentSocketPower << 8;\n\t\telse\n\t\t\t*value = (metrics->CurrentSocketPower << 8) / 1000;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_EDGE:\n\t\t*value = (metrics->GfxTemperature / 100) *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_TEMPERATURE_HOTSPOT:\n\t\t*value = (metrics->SocTemperature / 100) *\n\t\t\tSMU_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\tbreak;\n\tcase METRICS_THROTTLER_STATUS:\n\t\t*value = metrics->ThrottlerStatus;\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDGFX:\n\t\t*value = metrics->Voltage[0];\n\t\tbreak;\n\tcase METRICS_VOLTAGE_VDDSOC:\n\t\t*value = metrics->Voltage[1];\n\t\tbreak;\n\tcase METRICS_SS_APU_SHARE:\n\t\t \n\t\trenoir_get_ss_power_percent(metrics, &apu_percent, &dgpu_percent);\n\t\t*value = apu_percent;\n\t\tbreak;\n\tcase METRICS_SS_DGPU_SHARE:\n\t\t \n\t\trenoir_get_ss_power_percent(metrics, &apu_percent, &dgpu_percent);\n\t\t*value = dgpu_percent;\n\t\tbreak;\n\tdefault:\n\t\t*value = UINT_MAX;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int renoir_read_sensor(struct smu_context *smu,\n\t\t\t\t enum amd_pp_sensors sensor,\n\t\t\t\t void *data, uint32_t *size)\n{\n\tint ret = 0;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tswitch (sensor) {\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_AVERAGE_GFXACTIVITY,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_EDGE_TEMP:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_TEMPERATURE_EDGE,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_TEMPERATURE_HOTSPOT,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_AVERAGE_UCLK,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_AVERAGE_GFXCLK,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*(uint32_t *)data *= 100;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_VOLTAGE_VDDGFX,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDNB:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_VOLTAGE_VDDSOC,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_CURR_SOCKETPOWER,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_APU_SHARE:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_SS_APU_SHARE,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_SS_DGPU_SHARE:\n\t\tret = renoir_get_smu_metrics_data(smu,\n\t\t\t\t\t\t  METRICS_SS_DGPU_SHARE,\n\t\t\t\t\t\t  (uint32_t *)data);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_AVG_POWER:\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool renoir_is_dpm_running(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\t \n\tif (adev->in_suspend)\n\t\treturn false;\n\telse\n\t\treturn true;\n\n}\n\nstatic ssize_t renoir_get_gpu_metrics(struct smu_context *smu,\n\t\t\t\t      void **table)\n{\n\tstruct smu_table_context *smu_table = &smu->smu_table;\n\tstruct gpu_metrics_v2_2 *gpu_metrics =\n\t\t(struct gpu_metrics_v2_2 *)smu_table->gpu_metrics_table;\n\tSmuMetrics_t metrics;\n\tint ret = 0;\n\n\tret = smu_cmn_get_metrics_table(smu, &metrics, true);\n\tif (ret)\n\t\treturn ret;\n\n\tsmu_cmn_init_soft_gpu_metrics(gpu_metrics, 2, 2);\n\n\tgpu_metrics->temperature_gfx = metrics.GfxTemperature;\n\tgpu_metrics->temperature_soc = metrics.SocTemperature;\n\tmemcpy(&gpu_metrics->temperature_core[0],\n\t\t&metrics.CoreTemperature[0],\n\t\tsizeof(uint16_t) * 8);\n\tgpu_metrics->temperature_l3[0] = metrics.L3Temperature[0];\n\tgpu_metrics->temperature_l3[1] = metrics.L3Temperature[1];\n\n\tgpu_metrics->average_gfx_activity = metrics.AverageGfxActivity;\n\tgpu_metrics->average_mm_activity = metrics.AverageUvdActivity;\n\n\tgpu_metrics->average_socket_power = metrics.CurrentSocketPower;\n\tgpu_metrics->average_cpu_power = metrics.Power[0];\n\tgpu_metrics->average_soc_power = metrics.Power[1];\n\tmemcpy(&gpu_metrics->average_core_power[0],\n\t\t&metrics.CorePower[0],\n\t\tsizeof(uint16_t) * 8);\n\n\tgpu_metrics->average_gfxclk_frequency = metrics.AverageGfxclkFrequency;\n\tgpu_metrics->average_socclk_frequency = metrics.AverageSocclkFrequency;\n\tgpu_metrics->average_fclk_frequency = metrics.AverageFclkFrequency;\n\tgpu_metrics->average_vclk_frequency = metrics.AverageVclkFrequency;\n\n\tgpu_metrics->current_gfxclk = metrics.ClockFrequency[CLOCK_GFXCLK];\n\tgpu_metrics->current_socclk = metrics.ClockFrequency[CLOCK_SOCCLK];\n\tgpu_metrics->current_uclk = metrics.ClockFrequency[CLOCK_UMCCLK];\n\tgpu_metrics->current_fclk = metrics.ClockFrequency[CLOCK_FCLK];\n\tgpu_metrics->current_vclk = metrics.ClockFrequency[CLOCK_VCLK];\n\tgpu_metrics->current_dclk = metrics.ClockFrequency[CLOCK_DCLK];\n\tmemcpy(&gpu_metrics->current_coreclk[0],\n\t\t&metrics.CoreFrequency[0],\n\t\tsizeof(uint16_t) * 8);\n\tgpu_metrics->current_l3clk[0] = metrics.L3Frequency[0];\n\tgpu_metrics->current_l3clk[1] = metrics.L3Frequency[1];\n\n\tgpu_metrics->throttle_status = metrics.ThrottlerStatus;\n\tgpu_metrics->indep_throttle_status =\n\t\tsmu_cmn_get_indep_throttler_status(metrics.ThrottlerStatus,\n\t\t\t\t\t\t   renoir_throttler_map);\n\n\tgpu_metrics->fan_pwm = metrics.FanPwm;\n\n\tgpu_metrics->system_clock_counter = ktime_get_boottime_ns();\n\n\t*table = (void *)gpu_metrics;\n\n\treturn sizeof(struct gpu_metrics_v2_2);\n}\n\nstatic int renoir_gfx_state_change_set(struct smu_context *smu, uint32_t state)\n{\n\n\treturn 0;\n}\n\nstatic int renoir_get_enabled_mask(struct smu_context *smu,\n\t\t\t\t   uint64_t *feature_mask)\n{\n\tif (!feature_mask)\n\t\treturn -EINVAL;\n\tmemset(feature_mask, 0xff, sizeof(*feature_mask));\n\n\treturn 0;\n}\n\nstatic const struct pptable_funcs renoir_ppt_funcs = {\n\t.set_power_state = NULL,\n\t.print_clk_levels = renoir_print_clk_levels,\n\t.get_current_power_state = renoir_get_current_power_state,\n\t.dpm_set_vcn_enable = renoir_dpm_set_vcn_enable,\n\t.dpm_set_jpeg_enable = renoir_dpm_set_jpeg_enable,\n\t.force_clk_levels = renoir_force_clk_levels,\n\t.set_power_profile_mode = renoir_set_power_profile_mode,\n\t.set_performance_level = renoir_set_performance_level,\n\t.get_dpm_clock_table = renoir_get_dpm_clock_table,\n\t.set_watermarks_table = renoir_set_watermarks_table,\n\t.get_power_profile_mode = renoir_get_power_profile_mode,\n\t.read_sensor = renoir_read_sensor,\n\t.check_fw_status = smu_v12_0_check_fw_status,\n\t.check_fw_version = smu_v12_0_check_fw_version,\n\t.powergate_sdma = smu_v12_0_powergate_sdma,\n\t.send_smc_msg_with_param = smu_cmn_send_smc_msg_with_param,\n\t.send_smc_msg = smu_cmn_send_smc_msg,\n\t.set_gfx_cgpg = smu_v12_0_set_gfx_cgpg,\n\t.gfx_off_control = smu_v12_0_gfx_off_control,\n\t.get_gfx_off_status = smu_v12_0_get_gfxoff_status,\n\t.init_smc_tables = renoir_init_smc_tables,\n\t.fini_smc_tables = smu_v12_0_fini_smc_tables,\n\t.set_default_dpm_table = smu_v12_0_set_default_dpm_tables,\n\t.get_enabled_mask = renoir_get_enabled_mask,\n\t.feature_is_enabled = smu_cmn_feature_is_enabled,\n\t.disable_all_features_with_exception = smu_cmn_disable_all_features_with_exception,\n\t.get_dpm_ultimate_freq = renoir_get_dpm_ultimate_freq,\n\t.mode2_reset = smu_v12_0_mode2_reset,\n\t.set_soft_freq_limited_range = smu_v12_0_set_soft_freq_limited_range,\n\t.set_driver_table_location = smu_v12_0_set_driver_table_location,\n\t.is_dpm_running = renoir_is_dpm_running,\n\t.get_pp_feature_mask = smu_cmn_get_pp_feature_mask,\n\t.set_pp_feature_mask = smu_cmn_set_pp_feature_mask,\n\t.get_gpu_metrics = renoir_get_gpu_metrics,\n\t.gfx_state_change_set = renoir_gfx_state_change_set,\n\t.set_fine_grain_gfx_freq_parameters = renoir_set_fine_grain_gfx_freq_parameters,\n\t.od_edit_dpm_table = renoir_od_edit_dpm_table,\n\t.get_vbios_bootup_values = smu_v12_0_get_vbios_bootup_values,\n};\n\nvoid renoir_set_ppt_funcs(struct smu_context *smu)\n{\n\tstruct amdgpu_device *adev = smu->adev;\n\n\tsmu->ppt_funcs = &renoir_ppt_funcs;\n\tsmu->message_map = renoir_message_map;\n\tsmu->clock_map = renoir_clk_map;\n\tsmu->table_map = renoir_table_map;\n\tsmu->workload_map = renoir_workload_map;\n\tsmu->smc_driver_if_version = SMU12_DRIVER_IF_VERSION;\n\tsmu->is_apu = true;\n\tsmu->param_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_82);\n\tsmu->msg_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_66);\n\tsmu->resp_reg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}