{
  "module_name": "amdgpu_dpm.c",
  "hash_id": "20549f770869f41c1e9c633663037e123afd5770efb658af02bcd064cad49013",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/amdgpu_dpm.c",
  "human_readable_source": " \n\n#include \"amdgpu.h\"\n#include \"amdgpu_atombios.h\"\n#include \"amdgpu_i2c.h\"\n#include \"amdgpu_dpm.h\"\n#include \"atom.h\"\n#include \"amd_pcie.h\"\n#include \"amdgpu_display.h\"\n#include \"hwmgr.h\"\n#include <linux/power_supply.h>\n#include \"amdgpu_smu.h\"\n\n#define amdgpu_dpm_enable_bapm(adev, e) \\\n\t\t((adev)->powerplay.pp_funcs->enable_bapm((adev)->powerplay.pp_handle, (e)))\n\n#define amdgpu_dpm_is_legacy_dpm(adev) ((adev)->powerplay.pp_handle == (adev))\n\nint amdgpu_dpm_get_sclk(struct amdgpu_device *adev, bool low)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_sclk)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_sclk((adev)->powerplay.pp_handle,\n\t\t\t\t low);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_mclk(struct amdgpu_device *adev, bool low)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_mclk)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_mclk((adev)->powerplay.pp_handle,\n\t\t\t\t low);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_powergating_by_smu(struct amdgpu_device *adev, uint32_t block_type, bool gate)\n{\n\tint ret = 0;\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tenum ip_power_state pwr_state = gate ? POWER_STATE_OFF : POWER_STATE_ON;\n\n\tif (atomic_read(&adev->pm.pwr_state[block_type]) == pwr_state) {\n\t\tdev_dbg(adev->dev, \"IP block%d already in the target %s state!\",\n\t\t\t\tblock_type, gate ? \"gate\" : \"ungate\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tswitch (block_type) {\n\tcase AMD_IP_BLOCK_TYPE_UVD:\n\tcase AMD_IP_BLOCK_TYPE_VCE:\n\tcase AMD_IP_BLOCK_TYPE_GFX:\n\tcase AMD_IP_BLOCK_TYPE_VCN:\n\tcase AMD_IP_BLOCK_TYPE_SDMA:\n\tcase AMD_IP_BLOCK_TYPE_JPEG:\n\tcase AMD_IP_BLOCK_TYPE_GMC:\n\tcase AMD_IP_BLOCK_TYPE_ACP:\n\t\tif (pp_funcs && pp_funcs->set_powergating_by_smu)\n\t\t\tret = (pp_funcs->set_powergating_by_smu(\n\t\t\t\t(adev)->powerplay.pp_handle, block_type, gate));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tatomic_set(&adev->pm.pwr_state[block_type], pwr_state);\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_gfx_power_up_by_imu(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_set_gfx_power_up_by_imu(smu);\n\tmutex_unlock(&adev->pm.mutex);\n\n\tmsleep(10);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_baco_enter(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!pp_funcs || !pp_funcs->set_asic_baco_state)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\t \n\tret = pp_funcs->set_asic_baco_state(pp_handle, 1);\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_baco_exit(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!pp_funcs || !pp_funcs->set_asic_baco_state)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\t \n\tret = pp_funcs->set_asic_baco_state(pp_handle, 0);\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_mp1_state(struct amdgpu_device *adev,\n\t\t\t     enum pp_mp1_state mp1_state)\n{\n\tint ret = 0;\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (pp_funcs && pp_funcs->set_mp1_state) {\n\t\tmutex_lock(&adev->pm.mutex);\n\n\t\tret = pp_funcs->set_mp1_state(\n\t\t\t\tadev->powerplay.pp_handle,\n\t\t\t\tmp1_state);\n\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nbool amdgpu_dpm_is_baco_supported(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tbool baco_cap;\n\tint ret = 0;\n\n\tif (!pp_funcs || !pp_funcs->get_asic_baco_capability)\n\t\treturn false;\n\t \n\tif (adev->in_s3)\n\t\treturn false;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tret = pp_funcs->get_asic_baco_capability(pp_handle,\n\t\t\t\t\t\t &baco_cap);\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret ? false : baco_cap;\n}\n\nint amdgpu_dpm_mode2_reset(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!pp_funcs || !pp_funcs->asic_reset_mode_2)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tret = pp_funcs->asic_reset_mode_2(pp_handle);\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_enable_gfx_features(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!pp_funcs || !pp_funcs->asic_reset_enable_gfx_features)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tret = pp_funcs->asic_reset_enable_gfx_features(pp_handle);\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_baco_reset(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!pp_funcs || !pp_funcs->set_asic_baco_state)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\t \n\tret = pp_funcs->set_asic_baco_state(pp_handle, 1);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = pp_funcs->set_asic_baco_state(pp_handle, 0);\n\nout:\n\tmutex_unlock(&adev->pm.mutex);\n\treturn ret;\n}\n\nbool amdgpu_dpm_is_mode1_reset_supported(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tbool support_mode1_reset = false;\n\n\tif (is_support_sw_smu(adev)) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tsupport_mode1_reset = smu_mode1_reset_is_support(smu);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn support_mode1_reset;\n}\n\nint amdgpu_dpm_mode1_reset(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = -EOPNOTSUPP;\n\n\tif (is_support_sw_smu(adev)) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = smu_mode1_reset(smu);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_switch_power_profile(struct amdgpu_device *adev,\n\t\t\t\t    enum PP_SMC_POWER_PROFILE type,\n\t\t\t\t    bool en)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (amdgpu_sriov_vf(adev))\n\t\treturn 0;\n\n\tif (pp_funcs && pp_funcs->switch_power_profile) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->switch_power_profile(\n\t\t\tadev->powerplay.pp_handle, type, en);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_xgmi_pstate(struct amdgpu_device *adev,\n\t\t\t       uint32_t pstate)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (pp_funcs && pp_funcs->set_xgmi_pstate) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->set_xgmi_pstate(adev->powerplay.pp_handle,\n\t\t\t\t\t\t\t\tpstate);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_df_cstate(struct amdgpu_device *adev,\n\t\t\t     uint32_t cstate)\n{\n\tint ret = 0;\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\n\tif (pp_funcs && pp_funcs->set_df_cstate) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->set_df_cstate(pp_handle, cstate);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_allow_xgmi_power_down(struct amdgpu_device *adev, bool en)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (is_support_sw_smu(adev)) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = smu_allow_xgmi_power_down(smu, en);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_enable_mgpu_fan_boost(struct amdgpu_device *adev)\n{\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tconst struct amd_pm_funcs *pp_funcs =\n\t\t\tadev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (pp_funcs && pp_funcs->enable_mgpu_fan_boost) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->enable_mgpu_fan_boost(pp_handle);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_clockgating_by_smu(struct amdgpu_device *adev,\n\t\t\t\t      uint32_t msg_id)\n{\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tconst struct amd_pm_funcs *pp_funcs =\n\t\t\tadev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (pp_funcs && pp_funcs->set_clockgating_by_smu) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->set_clockgating_by_smu(pp_handle,\n\t\t\t\t\t\t       msg_id);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_smu_i2c_bus_access(struct amdgpu_device *adev,\n\t\t\t\t  bool acquire)\n{\n\tvoid *pp_handle = adev->powerplay.pp_handle;\n\tconst struct amd_pm_funcs *pp_funcs =\n\t\t\tadev->powerplay.pp_funcs;\n\tint ret = -EOPNOTSUPP;\n\n\tif (pp_funcs && pp_funcs->smu_i2c_bus_access) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->smu_i2c_bus_access(pp_handle,\n\t\t\t\t\t\t   acquire);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nvoid amdgpu_pm_acpi_event_handler(struct amdgpu_device *adev)\n{\n\tif (adev->pm.dpm_enabled) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tif (power_supply_is_system_supplied() > 0)\n\t\t\tadev->pm.ac_power = true;\n\t\telse\n\t\t\tadev->pm.ac_power = false;\n\n\t\tif (adev->powerplay.pp_funcs &&\n\t\t    adev->powerplay.pp_funcs->enable_bapm)\n\t\t\tamdgpu_dpm_enable_bapm(adev, adev->pm.ac_power);\n\n\t\tif (is_support_sw_smu(adev))\n\t\t\tsmu_set_ac_dc(adev->powerplay.pp_handle);\n\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n}\n\nint amdgpu_dpm_read_sensor(struct amdgpu_device *adev, enum amd_pp_sensors sensor,\n\t\t\t   void *data, uint32_t *size)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = -EINVAL;\n\n\tif (!data || !size)\n\t\treturn -EINVAL;\n\n\tif (pp_funcs && pp_funcs->read_sensor) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->read_sensor(adev->powerplay.pp_handle,\n\t\t\t\t\t    sensor,\n\t\t\t\t\t    data,\n\t\t\t\t\t    size);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_apu_thermal_limit(struct amdgpu_device *adev, uint32_t *limit)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = -EINVAL;\n\n\tif (pp_funcs && pp_funcs->get_apu_thermal_limit) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->get_apu_thermal_limit(adev->powerplay.pp_handle, limit);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_apu_thermal_limit(struct amdgpu_device *adev, uint32_t limit)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = -EINVAL;\n\n\tif (pp_funcs && pp_funcs->set_apu_thermal_limit) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = pp_funcs->set_apu_thermal_limit(adev->powerplay.pp_handle, limit);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nvoid amdgpu_dpm_compute_clocks(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint i;\n\n\tif (!adev->pm.dpm_enabled)\n\t\treturn;\n\n\tif (!pp_funcs->pm_compute_clocks)\n\t\treturn;\n\n\tif (adev->mode_info.num_crtc)\n\t\tamdgpu_display_bandwidth_update(adev);\n\n\tfor (i = 0; i < AMDGPU_MAX_RINGS; i++) {\n\t\tstruct amdgpu_ring *ring = adev->rings[i];\n\t\tif (ring && ring->sched.ready)\n\t\t\tamdgpu_fence_wait_empty(ring);\n\t}\n\n\tmutex_lock(&adev->pm.mutex);\n\tpp_funcs->pm_compute_clocks(adev->powerplay.pp_handle);\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nvoid amdgpu_dpm_enable_uvd(struct amdgpu_device *adev, bool enable)\n{\n\tint ret = 0;\n\n\tif (adev->family == AMDGPU_FAMILY_SI) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tif (enable) {\n\t\t\tadev->pm.dpm.uvd_active = true;\n\t\t\tadev->pm.dpm.state = POWER_STATE_TYPE_INTERNAL_UVD;\n\t\t} else {\n\t\t\tadev->pm.dpm.uvd_active = false;\n\t\t}\n\t\tmutex_unlock(&adev->pm.mutex);\n\n\t\tamdgpu_dpm_compute_clocks(adev);\n\t\treturn;\n\t}\n\n\tret = amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_UVD, !enable);\n\tif (ret)\n\t\tDRM_ERROR(\"Dpm %s uvd failed, ret = %d. \\n\",\n\t\t\t  enable ? \"enable\" : \"disable\", ret);\n}\n\nvoid amdgpu_dpm_enable_vce(struct amdgpu_device *adev, bool enable)\n{\n\tint ret = 0;\n\n\tif (adev->family == AMDGPU_FAMILY_SI) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tif (enable) {\n\t\t\tadev->pm.dpm.vce_active = true;\n\t\t\t \n\t\t\tadev->pm.dpm.vce_level = AMD_VCE_LEVEL_AC_ALL;\n\t\t} else {\n\t\t\tadev->pm.dpm.vce_active = false;\n\t\t}\n\t\tmutex_unlock(&adev->pm.mutex);\n\n\t\tamdgpu_dpm_compute_clocks(adev);\n\t\treturn;\n\t}\n\n\tret = amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_VCE, !enable);\n\tif (ret)\n\t\tDRM_ERROR(\"Dpm %s vce failed, ret = %d. \\n\",\n\t\t\t  enable ? \"enable\" : \"disable\", ret);\n}\n\nvoid amdgpu_dpm_enable_jpeg(struct amdgpu_device *adev, bool enable)\n{\n\tint ret = 0;\n\n\tret = amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_JPEG, !enable);\n\tif (ret)\n\t\tDRM_ERROR(\"Dpm %s jpeg failed, ret = %d. \\n\",\n\t\t\t  enable ? \"enable\" : \"disable\", ret);\n}\n\nint amdgpu_pm_load_smu_firmware(struct amdgpu_device *adev, uint32_t *smu_version)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint r = 0;\n\n\tif (!pp_funcs || !pp_funcs->load_firmware)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tr = pp_funcs->load_firmware(adev->powerplay.pp_handle);\n\tif (r) {\n\t\tpr_err(\"smu firmware loading failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif (smu_version)\n\t\t*smu_version = adev->pm.fw_version;\n\nout:\n\tmutex_unlock(&adev->pm.mutex);\n\treturn r;\n}\n\nint amdgpu_dpm_handle_passthrough_sbr(struct amdgpu_device *adev, bool enable)\n{\n\tint ret = 0;\n\n\tif (is_support_sw_smu(adev)) {\n\t\tmutex_lock(&adev->pm.mutex);\n\t\tret = smu_handle_passthrough_sbr(adev->powerplay.pp_handle,\n\t\t\t\t\t\t enable);\n\t\tmutex_unlock(&adev->pm.mutex);\n\t}\n\n\treturn ret;\n}\n\nint amdgpu_dpm_send_hbm_bad_pages_num(struct amdgpu_device *adev, uint32_t size)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_send_hbm_bad_pages_num(smu, size);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_send_hbm_bad_channel_flag(struct amdgpu_device *adev, uint32_t size)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_send_hbm_bad_channel_flag(smu, size);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_dpm_freq_range(struct amdgpu_device *adev,\n\t\t\t\t  enum pp_clock_type type,\n\t\t\t\t  uint32_t *min,\n\t\t\t\t  uint32_t *max)\n{\n\tint ret = 0;\n\n\tif (type != PP_SCLK)\n\t\treturn -EINVAL;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_get_dpm_freq_range(adev->powerplay.pp_handle,\n\t\t\t\t     SMU_SCLK,\n\t\t\t\t     min,\n\t\t\t\t     max);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_soft_freq_range(struct amdgpu_device *adev,\n\t\t\t\t   enum pp_clock_type type,\n\t\t\t\t   uint32_t min,\n\t\t\t\t   uint32_t max)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (type != PP_SCLK)\n\t\treturn -EINVAL;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_set_soft_freq_range(smu,\n\t\t\t\t      SMU_SCLK,\n\t\t\t\t      min,\n\t\t\t\t      max);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_write_watermarks_table(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_write_watermarks_table(smu);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_wait_for_event(struct amdgpu_device *adev,\n\t\t\t      enum smu_event_type event,\n\t\t\t      uint64_t event_arg)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_wait_for_event(smu, event, event_arg);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_residency_gfxoff(struct amdgpu_device *adev, bool value)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_set_residency_gfxoff(smu, value);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_residency_gfxoff(struct amdgpu_device *adev, u32 *value)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_get_residency_gfxoff(smu, value);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_entrycount_gfxoff(struct amdgpu_device *adev, u64 *value)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_get_entrycount_gfxoff(smu, value);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_status_gfxoff(struct amdgpu_device *adev, uint32_t *value)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_get_status_gfxoff(smu, value);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nuint64_t amdgpu_dpm_get_thermal_throttling_counter(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn 0;\n\n\treturn atomic64_read(&smu->throttle_int_counter);\n}\n\n \nvoid amdgpu_dpm_gfx_state_change(struct amdgpu_device *adev,\n\t\t\t\t enum gfx_change_state state)\n{\n\tmutex_lock(&adev->pm.mutex);\n\tif (adev->powerplay.pp_funcs &&\n\t    adev->powerplay.pp_funcs->gfx_state_change_set)\n\t\t((adev)->powerplay.pp_funcs->gfx_state_change_set(\n\t\t\t(adev)->powerplay.pp_handle, state));\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nint amdgpu_dpm_get_ecc_info(struct amdgpu_device *adev,\n\t\t\t    void *umc_ecc)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = smu_get_ecc_info(smu, umc_ecc);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nstruct amd_vce_state *amdgpu_dpm_get_vce_clock_state(struct amdgpu_device *adev,\n\t\t\t\t\t\t     uint32_t idx)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tstruct amd_vce_state *vstate = NULL;\n\n\tif (!pp_funcs->get_vce_clock_state)\n\t\treturn NULL;\n\n\tmutex_lock(&adev->pm.mutex);\n\tvstate = pp_funcs->get_vce_clock_state(adev->powerplay.pp_handle,\n\t\t\t\t\t       idx);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn vstate;\n}\n\nvoid amdgpu_dpm_get_current_power_state(struct amdgpu_device *adev,\n\t\t\t\t\tenum amd_pm_state_type *state)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tif (!pp_funcs->get_current_power_state) {\n\t\t*state = adev->pm.dpm.user_state;\n\t\tgoto out;\n\t}\n\n\t*state = pp_funcs->get_current_power_state(adev->powerplay.pp_handle);\n\tif (*state < POWER_STATE_TYPE_DEFAULT ||\n\t    *state > POWER_STATE_TYPE_INTERNAL_3DPERF)\n\t\t*state = adev->pm.dpm.user_state;\n\nout:\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nvoid amdgpu_dpm_set_power_state(struct amdgpu_device *adev,\n\t\t\t\tenum amd_pm_state_type state)\n{\n\tmutex_lock(&adev->pm.mutex);\n\tadev->pm.dpm.user_state = state;\n\tmutex_unlock(&adev->pm.mutex);\n\n\tif (is_support_sw_smu(adev))\n\t\treturn;\n\n\tif (amdgpu_dpm_dispatch_task(adev,\n\t\t\t\t     AMD_PP_TASK_ENABLE_USER_STATE,\n\t\t\t\t     &state) == -EOPNOTSUPP)\n\t\tamdgpu_dpm_compute_clocks(adev);\n}\n\nenum amd_dpm_forced_level amdgpu_dpm_get_performance_level(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tenum amd_dpm_forced_level level;\n\n\tif (!pp_funcs)\n\t\treturn AMD_DPM_FORCED_LEVEL_AUTO;\n\n\tmutex_lock(&adev->pm.mutex);\n\tif (pp_funcs->get_performance_level)\n\t\tlevel = pp_funcs->get_performance_level(adev->powerplay.pp_handle);\n\telse\n\t\tlevel = adev->pm.dpm.forced_level;\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn level;\n}\n\nint amdgpu_dpm_force_performance_level(struct amdgpu_device *adev,\n\t\t\t\t       enum amd_dpm_forced_level level)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tenum amd_dpm_forced_level current_level;\n\tuint32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_PEAK;\n\n\tif (!pp_funcs || !pp_funcs->force_performance_level)\n\t\treturn 0;\n\n\tif (adev->pm.dpm.thermal_active)\n\t\treturn -EINVAL;\n\n\tcurrent_level = amdgpu_dpm_get_performance_level(adev);\n\tif (current_level == level)\n\t\treturn 0;\n\n\tif (adev->asic_type == CHIP_RAVEN) {\n\t\tif (!(adev->apu_flags & AMD_APU_IS_RAVEN2)) {\n\t\t\tif (current_level != AMD_DPM_FORCED_LEVEL_MANUAL &&\n\t\t\t    level == AMD_DPM_FORCED_LEVEL_MANUAL)\n\t\t\t\tamdgpu_gfx_off_ctrl(adev, false);\n\t\t\telse if (current_level == AMD_DPM_FORCED_LEVEL_MANUAL &&\n\t\t\t\t level != AMD_DPM_FORCED_LEVEL_MANUAL)\n\t\t\t\tamdgpu_gfx_off_ctrl(adev, true);\n\t\t}\n\t}\n\n\tif (!(current_level & profile_mode_mask) &&\n\t    (level == AMD_DPM_FORCED_LEVEL_PROFILE_EXIT))\n\t\treturn -EINVAL;\n\n\tif (!(current_level & profile_mode_mask) &&\n\t      (level & profile_mode_mask)) {\n\t\t \n\t\tamdgpu_device_ip_set_powergating_state(adev,\n\t\t\t\t\t\t       AMD_IP_BLOCK_TYPE_GFX,\n\t\t\t\t\t\t       AMD_PG_STATE_UNGATE);\n\t\tamdgpu_device_ip_set_clockgating_state(adev,\n\t\t\t\t\t\t       AMD_IP_BLOCK_TYPE_GFX,\n\t\t\t\t\t\t       AMD_CG_STATE_UNGATE);\n\t} else if ((current_level & profile_mode_mask) &&\n\t\t    !(level & profile_mode_mask)) {\n\t\t \n\t\tamdgpu_device_ip_set_clockgating_state(adev,\n\t\t\t\t\t\t       AMD_IP_BLOCK_TYPE_GFX,\n\t\t\t\t\t\t       AMD_CG_STATE_GATE);\n\t\tamdgpu_device_ip_set_powergating_state(adev,\n\t\t\t\t\t\t       AMD_IP_BLOCK_TYPE_GFX,\n\t\t\t\t\t\t       AMD_PG_STATE_GATE);\n\t}\n\n\tmutex_lock(&adev->pm.mutex);\n\n\tif (pp_funcs->force_performance_level(adev->powerplay.pp_handle,\n\t\t\t\t\t      level)) {\n\t\tmutex_unlock(&adev->pm.mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tadev->pm.dpm.forced_level = level;\n\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn 0;\n}\n\nint amdgpu_dpm_get_pp_num_states(struct amdgpu_device *adev,\n\t\t\t\t struct pp_states_info *states)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_pp_num_states)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_pp_num_states(adev->powerplay.pp_handle,\n\t\t\t\t\t  states);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_dispatch_task(struct amdgpu_device *adev,\n\t\t\t      enum amd_pp_task task_id,\n\t\t\t      enum amd_pm_state_type *user_state)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->dispatch_tasks)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->dispatch_tasks(adev->powerplay.pp_handle,\n\t\t\t\t       task_id,\n\t\t\t\t       user_state);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_pp_table(struct amdgpu_device *adev, char **table)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_pp_table)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_pp_table(adev->powerplay.pp_handle,\n\t\t\t\t     table);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_fine_grain_clk_vol(struct amdgpu_device *adev,\n\t\t\t\t      uint32_t type,\n\t\t\t\t      long *input,\n\t\t\t\t      uint32_t size)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_fine_grain_clk_vol)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_fine_grain_clk_vol(adev->powerplay.pp_handle,\n\t\t\t\t\t       type,\n\t\t\t\t\t       input,\n\t\t\t\t\t       size);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_odn_edit_dpm_table(struct amdgpu_device *adev,\n\t\t\t\t  uint32_t type,\n\t\t\t\t  long *input,\n\t\t\t\t  uint32_t size)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->odn_edit_dpm_table)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->odn_edit_dpm_table(adev->powerplay.pp_handle,\n\t\t\t\t\t   type,\n\t\t\t\t\t   input,\n\t\t\t\t\t   size);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_print_clock_levels(struct amdgpu_device *adev,\n\t\t\t\t  enum pp_clock_type type,\n\t\t\t\t  char *buf)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->print_clock_levels)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->print_clock_levels(adev->powerplay.pp_handle,\n\t\t\t\t\t   type,\n\t\t\t\t\t   buf);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_emit_clock_levels(struct amdgpu_device *adev,\n\t\t\t\t  enum pp_clock_type type,\n\t\t\t\t  char *buf,\n\t\t\t\t  int *offset)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->emit_clock_levels)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->emit_clock_levels(adev->powerplay.pp_handle,\n\t\t\t\t\t   type,\n\t\t\t\t\t   buf,\n\t\t\t\t\t   offset);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_ppfeature_status(struct amdgpu_device *adev,\n\t\t\t\t    uint64_t ppfeature_masks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_ppfeature_status)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_ppfeature_status(adev->powerplay.pp_handle,\n\t\t\t\t\t     ppfeature_masks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_ppfeature_status(struct amdgpu_device *adev, char *buf)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_ppfeature_status)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_ppfeature_status(adev->powerplay.pp_handle,\n\t\t\t\t\t     buf);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_force_clock_level(struct amdgpu_device *adev,\n\t\t\t\t enum pp_clock_type type,\n\t\t\t\t uint32_t mask)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->force_clock_level)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->force_clock_level(adev->powerplay.pp_handle,\n\t\t\t\t\t  type,\n\t\t\t\t\t  mask);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_sclk_od(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_sclk_od)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_sclk_od(adev->powerplay.pp_handle);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_sclk_od(struct amdgpu_device *adev, uint32_t value)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (is_support_sw_smu(adev))\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tif (pp_funcs->set_sclk_od)\n\t\tpp_funcs->set_sclk_od(adev->powerplay.pp_handle, value);\n\tmutex_unlock(&adev->pm.mutex);\n\n\tif (amdgpu_dpm_dispatch_task(adev,\n\t\t\t\t     AMD_PP_TASK_READJUST_POWER_STATE,\n\t\t\t\t     NULL) == -EOPNOTSUPP) {\n\t\tadev->pm.dpm.current_ps = adev->pm.dpm.boot_ps;\n\t\tamdgpu_dpm_compute_clocks(adev);\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_dpm_get_mclk_od(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_mclk_od)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_mclk_od(adev->powerplay.pp_handle);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_mclk_od(struct amdgpu_device *adev, uint32_t value)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (is_support_sw_smu(adev))\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tif (pp_funcs->set_mclk_od)\n\t\tpp_funcs->set_mclk_od(adev->powerplay.pp_handle, value);\n\tmutex_unlock(&adev->pm.mutex);\n\n\tif (amdgpu_dpm_dispatch_task(adev,\n\t\t\t\t     AMD_PP_TASK_READJUST_POWER_STATE,\n\t\t\t\t     NULL) == -EOPNOTSUPP) {\n\t\tadev->pm.dpm.current_ps = adev->pm.dpm.boot_ps;\n\t\tamdgpu_dpm_compute_clocks(adev);\n\t}\n\n\treturn 0;\n}\n\nint amdgpu_dpm_get_power_profile_mode(struct amdgpu_device *adev,\n\t\t\t\t      char *buf)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_power_profile_mode)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_power_profile_mode(adev->powerplay.pp_handle,\n\t\t\t\t\t       buf);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_power_profile_mode(struct amdgpu_device *adev,\n\t\t\t\t      long *input, uint32_t size)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_power_profile_mode)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_power_profile_mode(adev->powerplay.pp_handle,\n\t\t\t\t\t       input,\n\t\t\t\t\t       size);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_gpu_metrics(struct amdgpu_device *adev, void **table)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_gpu_metrics)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_gpu_metrics(adev->powerplay.pp_handle,\n\t\t\t\t\ttable);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_fan_control_mode(struct amdgpu_device *adev,\n\t\t\t\t    uint32_t *fan_mode)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_fan_control_mode)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_fan_control_mode(adev->powerplay.pp_handle,\n\t\t\t\t\t     fan_mode);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_fan_speed_pwm(struct amdgpu_device *adev,\n\t\t\t\t uint32_t speed)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_fan_speed_pwm)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_fan_speed_pwm(adev->powerplay.pp_handle,\n\t\t\t\t\t  speed);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_fan_speed_pwm(struct amdgpu_device *adev,\n\t\t\t\t uint32_t *speed)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_fan_speed_pwm)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_fan_speed_pwm(adev->powerplay.pp_handle,\n\t\t\t\t\t  speed);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_fan_speed_rpm(struct amdgpu_device *adev,\n\t\t\t\t uint32_t *speed)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_fan_speed_rpm)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_fan_speed_rpm(adev->powerplay.pp_handle,\n\t\t\t\t\t  speed);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_fan_speed_rpm(struct amdgpu_device *adev,\n\t\t\t\t uint32_t speed)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_fan_speed_rpm)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_fan_speed_rpm(adev->powerplay.pp_handle,\n\t\t\t\t\t  speed);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_fan_control_mode(struct amdgpu_device *adev,\n\t\t\t\t    uint32_t mode)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_fan_control_mode)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_fan_control_mode(adev->powerplay.pp_handle,\n\t\t\t\t\t     mode);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_power_limit(struct amdgpu_device *adev,\n\t\t\t       uint32_t *limit,\n\t\t\t       enum pp_power_limit_level pp_limit_level,\n\t\t\t       enum pp_power_type power_type)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_power_limit)\n\t\treturn -ENODATA;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_power_limit(adev->powerplay.pp_handle,\n\t\t\t\t\tlimit,\n\t\t\t\t\tpp_limit_level,\n\t\t\t\t\tpower_type);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_power_limit(struct amdgpu_device *adev,\n\t\t\t       uint32_t limit)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_power_limit)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_power_limit(adev->powerplay.pp_handle,\n\t\t\t\t\tlimit);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_is_cclk_dpm_supported(struct amdgpu_device *adev)\n{\n\tbool cclk_dpm_supported = false;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn false;\n\n\tmutex_lock(&adev->pm.mutex);\n\tcclk_dpm_supported = is_support_cclk_dpm(adev);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn (int)cclk_dpm_supported;\n}\n\nint amdgpu_dpm_debugfs_print_current_performance_level(struct amdgpu_device *adev,\n\t\t\t\t\t\t       struct seq_file *m)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (!pp_funcs->debugfs_print_current_performance_level)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tpp_funcs->debugfs_print_current_performance_level(adev->powerplay.pp_handle,\n\t\t\t\t\t\t\t  m);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn 0;\n}\n\nint amdgpu_dpm_get_smu_prv_buf_details(struct amdgpu_device *adev,\n\t\t\t\t       void **addr,\n\t\t\t\t       size_t *size)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_smu_prv_buf_details)\n\t\treturn -ENOSYS;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_smu_prv_buf_details(adev->powerplay.pp_handle,\n\t\t\t\t\t\taddr,\n\t\t\t\t\t\tsize);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_is_overdrive_supported(struct amdgpu_device *adev)\n{\n\tif (is_support_sw_smu(adev)) {\n\t\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\n\t\treturn (smu->od_enabled || smu->is_apu);\n\t} else {\n\t\tstruct pp_hwmgr *hwmgr;\n\n\t\t \n\t\tif (amdgpu_dpm_is_legacy_dpm(adev))\n\t\t\treturn false;\n\n\t\thwmgr = (struct pp_hwmgr *)adev->powerplay.pp_handle;\n\n\t\treturn hwmgr->od_enabled;\n\t}\n}\n\nint amdgpu_dpm_set_pp_table(struct amdgpu_device *adev,\n\t\t\t    const char *buf,\n\t\t\t    size_t size)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_pp_table)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_pp_table(adev->powerplay.pp_handle,\n\t\t\t\t     buf,\n\t\t\t\t     size);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_num_cpu_cores(struct amdgpu_device *adev)\n{\n\tstruct smu_context *smu = adev->powerplay.pp_handle;\n\n\tif (!is_support_sw_smu(adev))\n\t\treturn INT_MAX;\n\n\treturn smu->cpu_core_num;\n}\n\nvoid amdgpu_dpm_stb_debug_fs_init(struct amdgpu_device *adev)\n{\n\tif (!is_support_sw_smu(adev))\n\t\treturn;\n\n\tamdgpu_smu_stb_debug_fs_init(adev);\n}\n\nint amdgpu_dpm_display_configuration_change(struct amdgpu_device *adev,\n\t\t\t\t\t    const struct amd_pp_display_configuration *input)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->display_configuration_change)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->display_configuration_change(adev->powerplay.pp_handle,\n\t\t\t\t\t\t     input);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_clock_by_type(struct amdgpu_device *adev,\n\t\t\t\t enum amd_pp_clock_type type,\n\t\t\t\t struct amd_pp_clocks *clocks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_clock_by_type)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_clock_by_type(adev->powerplay.pp_handle,\n\t\t\t\t\t  type,\n\t\t\t\t\t  clocks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_display_mode_validation_clks(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct amd_pp_simple_clock_info *clocks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_display_mode_validation_clocks)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_display_mode_validation_clocks(adev->powerplay.pp_handle,\n\t\t\t\t\t\t\t   clocks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_clock_by_type_with_latency(struct amdgpu_device *adev,\n\t\t\t\t\t      enum amd_pp_clock_type type,\n\t\t\t\t\t      struct pp_clock_levels_with_latency *clocks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_clock_by_type_with_latency)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_clock_by_type_with_latency(adev->powerplay.pp_handle,\n\t\t\t\t\t\t       type,\n\t\t\t\t\t\t       clocks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_clock_by_type_with_voltage(struct amdgpu_device *adev,\n\t\t\t\t\t      enum amd_pp_clock_type type,\n\t\t\t\t\t      struct pp_clock_levels_with_voltage *clocks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_clock_by_type_with_voltage)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_clock_by_type_with_voltage(adev->powerplay.pp_handle,\n\t\t\t\t\t\t       type,\n\t\t\t\t\t\t       clocks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_watermarks_for_clocks_ranges(struct amdgpu_device *adev,\n\t\t\t\t\t       void *clock_ranges)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_watermarks_for_clocks_ranges)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_watermarks_for_clocks_ranges(adev->powerplay.pp_handle,\n\t\t\t\t\t\t\t clock_ranges);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_display_clock_voltage_request(struct amdgpu_device *adev,\n\t\t\t\t\t     struct pp_display_clock_request *clock)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->display_clock_voltage_request)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->display_clock_voltage_request(adev->powerplay.pp_handle,\n\t\t\t\t\t\t      clock);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_current_clocks(struct amdgpu_device *adev,\n\t\t\t\t  struct amd_pp_clock_info *clocks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_current_clocks)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_current_clocks(adev->powerplay.pp_handle,\n\t\t\t\t\t   clocks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nvoid amdgpu_dpm_notify_smu_enable_pwe(struct amdgpu_device *adev)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (!pp_funcs->notify_smu_enable_pwe)\n\t\treturn;\n\n\tmutex_lock(&adev->pm.mutex);\n\tpp_funcs->notify_smu_enable_pwe(adev->powerplay.pp_handle);\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nint amdgpu_dpm_set_active_display_count(struct amdgpu_device *adev,\n\t\t\t\t\tuint32_t count)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_active_display_count)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_active_display_count(adev->powerplay.pp_handle,\n\t\t\t\t\t\t count);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_set_min_deep_sleep_dcefclk(struct amdgpu_device *adev,\n\t\t\t\t\t  uint32_t clock)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->set_min_deep_sleep_dcefclk)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->set_min_deep_sleep_dcefclk(adev->powerplay.pp_handle,\n\t\t\t\t\t\t   clock);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nvoid amdgpu_dpm_set_hard_min_dcefclk_by_freq(struct amdgpu_device *adev,\n\t\t\t\t\t     uint32_t clock)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (!pp_funcs->set_hard_min_dcefclk_by_freq)\n\t\treturn;\n\n\tmutex_lock(&adev->pm.mutex);\n\tpp_funcs->set_hard_min_dcefclk_by_freq(adev->powerplay.pp_handle,\n\t\t\t\t\t       clock);\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nvoid amdgpu_dpm_set_hard_min_fclk_by_freq(struct amdgpu_device *adev,\n\t\t\t\t\t  uint32_t clock)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\n\tif (!pp_funcs->set_hard_min_fclk_by_freq)\n\t\treturn;\n\n\tmutex_lock(&adev->pm.mutex);\n\tpp_funcs->set_hard_min_fclk_by_freq(adev->powerplay.pp_handle,\n\t\t\t\t\t    clock);\n\tmutex_unlock(&adev->pm.mutex);\n}\n\nint amdgpu_dpm_display_disable_memory_clock_switch(struct amdgpu_device *adev,\n\t\t\t\t\t\t   bool disable_memory_clock_switch)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->display_disable_memory_clock_switch)\n\t\treturn 0;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->display_disable_memory_clock_switch(adev->powerplay.pp_handle,\n\t\t\t\t\t\t\t    disable_memory_clock_switch);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_max_sustainable_clocks_by_dc(struct amdgpu_device *adev,\n\t\t\t\t\t\tstruct pp_smu_nv_clock_table *max_clocks)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_max_sustainable_clocks_by_dc)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_max_sustainable_clocks_by_dc(adev->powerplay.pp_handle,\n\t\t\t\t\t\t\t max_clocks);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nenum pp_smu_status amdgpu_dpm_get_uclk_dpm_states(struct amdgpu_device *adev,\n\t\t\t\t\t\t  unsigned int *clock_values_in_khz,\n\t\t\t\t\t\t  unsigned int *num_states)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_uclk_dpm_states)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_uclk_dpm_states(adev->powerplay.pp_handle,\n\t\t\t\t\t    clock_values_in_khz,\n\t\t\t\t\t    num_states);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n\nint amdgpu_dpm_get_dpm_clock_table(struct amdgpu_device *adev,\n\t\t\t\t   struct dpm_clocks *clock_table)\n{\n\tconst struct amd_pm_funcs *pp_funcs = adev->powerplay.pp_funcs;\n\tint ret = 0;\n\n\tif (!pp_funcs->get_dpm_clock_table)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&adev->pm.mutex);\n\tret = pp_funcs->get_dpm_clock_table(adev->powerplay.pp_handle,\n\t\t\t\t\t    clock_table);\n\tmutex_unlock(&adev->pm.mutex);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}