{
  "module_name": "vega10_hwmgr.c",
  "hash_id": "71b2e12caac8d87bb2d319ba3707192f1310f3cb438d85b167d89bdb71f0d71a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega10_hwmgr.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n\n#include \"hwmgr.h\"\n#include \"amd_powerplay.h\"\n#include \"hardwaremanager.h\"\n#include \"ppatomfwctrl.h\"\n#include \"atomfirmware.h\"\n#include \"cgs_common.h\"\n#include \"vega10_powertune.h\"\n#include \"smu9.h\"\n#include \"smu9_driver_if.h\"\n#include \"vega10_inc.h\"\n#include \"soc15_common.h\"\n#include \"pppcielanes.h\"\n#include \"vega10_hwmgr.h\"\n#include \"vega10_smumgr.h\"\n#include \"vega10_processpptables.h\"\n#include \"vega10_pptable.h\"\n#include \"vega10_thermal.h\"\n#include \"pp_debug.h\"\n#include \"amd_pcie_helpers.h\"\n#include \"ppinterrupt.h\"\n#include \"pp_overdriver.h\"\n#include \"pp_thermal.h\"\n#include \"vega10_baco.h\"\n\n#include \"smuio/smuio_9_0_offset.h\"\n#include \"smuio/smuio_9_0_sh_mask.h\"\n\n#define smnPCIE_LC_SPEED_CNTL\t\t\t0x11140290\n#define smnPCIE_LC_LINK_WIDTH_CNTL\t\t0x11140288\n\n#define HBM_MEMORY_CHANNEL_WIDTH    128\n\nstatic const uint32_t channel_number[] = {1, 2, 0, 4, 0, 8, 0, 16, 2};\n\n#define mmDF_CS_AON0_DramBaseAddress0                                                                  0x0044\n#define mmDF_CS_AON0_DramBaseAddress0_BASE_IDX                                                         0\n\n\n#define DF_CS_AON0_DramBaseAddress0__AddrRngVal__SHIFT                                                        0x0\n#define DF_CS_AON0_DramBaseAddress0__LgcyMmioHoleEn__SHIFT                                                    0x1\n#define DF_CS_AON0_DramBaseAddress0__IntLvNumChan__SHIFT                                                      0x4\n#define DF_CS_AON0_DramBaseAddress0__IntLvAddrSel__SHIFT                                                      0x8\n#define DF_CS_AON0_DramBaseAddress0__DramBaseAddr__SHIFT                                                      0xc\n#define DF_CS_AON0_DramBaseAddress0__AddrRngVal_MASK                                                          0x00000001L\n#define DF_CS_AON0_DramBaseAddress0__LgcyMmioHoleEn_MASK                                                      0x00000002L\n#define DF_CS_AON0_DramBaseAddress0__IntLvNumChan_MASK                                                        0x000000F0L\n#define DF_CS_AON0_DramBaseAddress0__IntLvAddrSel_MASK                                                        0x00000700L\n#define DF_CS_AON0_DramBaseAddress0__DramBaseAddr_MASK                                                        0xFFFFF000L\n\ntypedef enum {\n\tCLK_SMNCLK = 0,\n\tCLK_SOCCLK,\n\tCLK_MP0CLK,\n\tCLK_MP1CLK,\n\tCLK_LCLK,\n\tCLK_DCEFCLK,\n\tCLK_VCLK,\n\tCLK_DCLK,\n\tCLK_ECLK,\n\tCLK_UCLK,\n\tCLK_GFXCLK,\n\tCLK_COUNT,\n} CLOCK_ID_e;\n\nstatic const ULONG PhwVega10_Magic = (ULONG)(PHM_VIslands_Magic);\n\nstatic struct vega10_power_state *cast_phw_vega10_power_state(\n\t\t\t\t  struct pp_hw_power_state *hw_ps)\n{\n\tPP_ASSERT_WITH_CODE((PhwVega10_Magic == hw_ps->magic),\n\t\t\t\t\"Invalid Powerstate Type!\",\n\t\t\t\t return NULL;);\n\n\treturn (struct vega10_power_state *)hw_ps;\n}\n\nstatic const struct vega10_power_state *cast_const_phw_vega10_power_state(\n\t\t\t\t const struct pp_hw_power_state *hw_ps)\n{\n\tPP_ASSERT_WITH_CODE((PhwVega10_Magic == hw_ps->magic),\n\t\t\t\t\"Invalid Powerstate Type!\",\n\t\t\t\t return NULL;);\n\n\treturn (const struct vega10_power_state *)hw_ps;\n}\n\nstatic void vega10_set_default_registry_data(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->registry_data.sclk_dpm_key_disabled =\n\t\t\thwmgr->feature_mask & PP_SCLK_DPM_MASK ? false : true;\n\tdata->registry_data.socclk_dpm_key_disabled =\n\t\t\thwmgr->feature_mask & PP_SOCCLK_DPM_MASK ? false : true;\n\tdata->registry_data.mclk_dpm_key_disabled =\n\t\t\thwmgr->feature_mask & PP_MCLK_DPM_MASK ? false : true;\n\tdata->registry_data.pcie_dpm_key_disabled =\n\t\t\thwmgr->feature_mask & PP_PCIE_DPM_MASK ? false : true;\n\n\tdata->registry_data.dcefclk_dpm_key_disabled =\n\t\t\thwmgr->feature_mask & PP_DCEFCLK_DPM_MASK ? false : true;\n\n\tif (hwmgr->feature_mask & PP_POWER_CONTAINMENT_MASK) {\n\t\tdata->registry_data.power_containment_support = 1;\n\t\tdata->registry_data.enable_pkg_pwr_tracking_feature = 1;\n\t\tdata->registry_data.enable_tdc_limit_feature = 1;\n\t}\n\n\tdata->registry_data.clock_stretcher_support =\n\t\t\thwmgr->feature_mask & PP_CLOCK_STRETCH_MASK ? true : false;\n\n\tdata->registry_data.ulv_support =\n\t\t\thwmgr->feature_mask & PP_ULV_MASK ? true : false;\n\n\tdata->registry_data.sclk_deep_sleep_support =\n\t\t\thwmgr->feature_mask & PP_SCLK_DEEP_SLEEP_MASK ? true : false;\n\n\tdata->registry_data.disable_water_mark = 0;\n\n\tdata->registry_data.fan_control_support = 1;\n\tdata->registry_data.thermal_support = 1;\n\tdata->registry_data.fw_ctf_enabled = 1;\n\n\tdata->registry_data.avfs_support =\n\t\thwmgr->feature_mask & PP_AVFS_MASK ? true : false;\n\tdata->registry_data.led_dpm_enabled = 1;\n\n\tdata->registry_data.vr0hot_enabled = 1;\n\tdata->registry_data.vr1hot_enabled = 1;\n\tdata->registry_data.regulator_hot_gpio_support = 1;\n\n\tdata->registry_data.didt_support = 1;\n\tif (data->registry_data.didt_support) {\n\t\tdata->registry_data.didt_mode = 6;\n\t\tdata->registry_data.sq_ramping_support = 1;\n\t\tdata->registry_data.db_ramping_support = 0;\n\t\tdata->registry_data.td_ramping_support = 0;\n\t\tdata->registry_data.tcp_ramping_support = 0;\n\t\tdata->registry_data.dbr_ramping_support = 0;\n\t\tdata->registry_data.edc_didt_support = 1;\n\t\tdata->registry_data.gc_didt_support = 0;\n\t\tdata->registry_data.psm_didt_support = 0;\n\t}\n\n\tdata->display_voltage_mode = PPVEGA10_VEGA10DISPLAYVOLTAGEMODE_DFLT;\n\tdata->dcef_clk_quad_eqn_a = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->dcef_clk_quad_eqn_b = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->dcef_clk_quad_eqn_c = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->disp_clk_quad_eqn_a = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->disp_clk_quad_eqn_b = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->disp_clk_quad_eqn_c = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->pixel_clk_quad_eqn_a = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->pixel_clk_quad_eqn_b = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->pixel_clk_quad_eqn_c = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->phy_clk_quad_eqn_a = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->phy_clk_quad_eqn_b = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\tdata->phy_clk_quad_eqn_c = PPREGKEY_VEGA10QUADRATICEQUATION_DFLT;\n\n\tdata->gfxclk_average_alpha = PPVEGA10_VEGA10GFXCLKAVERAGEALPHA_DFLT;\n\tdata->socclk_average_alpha = PPVEGA10_VEGA10SOCCLKAVERAGEALPHA_DFLT;\n\tdata->uclk_average_alpha = PPVEGA10_VEGA10UCLKCLKAVERAGEALPHA_DFLT;\n\tdata->gfx_activity_average_alpha = PPVEGA10_VEGA10GFXACTIVITYAVERAGEALPHA_DFLT;\n}\n\nstatic int vega10_set_features_platform_caps(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SclkDeepSleep);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DynamicPatchPowerState);\n\n\tif (data->vddci_control == VEGA10_VOLTAGE_CONTROL_NONE)\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ControlVDDCI);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_EnableSMU7ThermalManagement);\n\n\tif (adev->pg_flags & AMD_PG_SUPPORT_UVD)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_UVDPowerGating);\n\n\tif (adev->pg_flags & AMD_PG_SUPPORT_VCE)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_VCEPowerGating);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_UnTabledHardwareInterface);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_FanSpeedInTableIsRPM);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_ODFuzzyFanControlSupport);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_DynamicPowerManagement);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SMC);\n\n\t \n\t \n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PowerContainment);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DiDtSupport);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_SQRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DBRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_TDRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_TCPRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DBRRamping);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_DiDtEDCEnable);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_GCEDC);\n\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_PSM);\n\n\tif (data->registry_data.didt_support) {\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DiDtSupport);\n\t\tif (data->registry_data.sq_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_SQRamping);\n\t\tif (data->registry_data.db_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DBRamping);\n\t\tif (data->registry_data.td_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TDRamping);\n\t\tif (data->registry_data.tcp_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_TCPRamping);\n\t\tif (data->registry_data.dbr_ramping_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DBRRamping);\n\t\tif (data->registry_data.edc_didt_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DiDtEDCEnable);\n\t\tif (data->registry_data.gc_didt_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_GCEDC);\n\t\tif (data->registry_data.psm_didt_support)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_PSM);\n\t}\n\n\tif (data->registry_data.power_containment_support)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_PowerContainment);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_CAC);\n\n\tif (table_info->tdp_table->usClockStretchAmount &&\n\t\t\tdata->registry_data.clock_stretcher_support)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_ClockStretcher);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_RegulatorHot);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_AutomaticDCTransition);\n\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_UVDDPM);\n\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\tPHM_PlatformCaps_VCEDPM);\n\n\treturn 0;\n}\n\nstatic int vega10_odn_initial_default_setting(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct vega10_odn_dpm_table *odn_table = &(data->odn_dpm_table);\n\tstruct vega10_odn_vddc_lookup_table *od_lookup_table;\n\tstruct phm_ppt_v1_voltage_lookup_table *vddc_lookup_table;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table[3];\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *od_table[3];\n\tstruct pp_atomfwctrl_avfs_parameters avfs_params = {0};\n\tuint32_t i;\n\tint result;\n\n\tresult = pp_atomfwctrl_get_avfs_information(hwmgr, &avfs_params);\n\tif (!result) {\n\t\tdata->odn_dpm_table.max_vddc = avfs_params.ulMaxVddc;\n\t\tdata->odn_dpm_table.min_vddc = avfs_params.ulMinVddc;\n\t}\n\n\tod_lookup_table = &odn_table->vddc_lookup_table;\n\tvddc_lookup_table = table_info->vddc_lookup_table;\n\n\tfor (i = 0; i < vddc_lookup_table->count; i++)\n\t\tod_lookup_table->entries[i].us_vdd = vddc_lookup_table->entries[i].us_vdd;\n\n\tod_lookup_table->count = vddc_lookup_table->count;\n\n\tdep_table[0] = table_info->vdd_dep_on_sclk;\n\tdep_table[1] = table_info->vdd_dep_on_mclk;\n\tdep_table[2] = table_info->vdd_dep_on_socclk;\n\tod_table[0] = (struct phm_ppt_v1_clock_voltage_dependency_table *)&odn_table->vdd_dep_on_sclk;\n\tod_table[1] = (struct phm_ppt_v1_clock_voltage_dependency_table *)&odn_table->vdd_dep_on_mclk;\n\tod_table[2] = (struct phm_ppt_v1_clock_voltage_dependency_table *)&odn_table->vdd_dep_on_socclk;\n\n\tfor (i = 0; i < 3; i++)\n\t\tsmu_get_voltage_dependency_table_ppt_v1(dep_table[i], od_table[i]);\n\n\tif (odn_table->max_vddc == 0 || odn_table->max_vddc > 2000)\n\t\todn_table->max_vddc = dep_table[0]->entries[dep_table[0]->count - 1].vddc;\n\tif (odn_table->min_vddc == 0 || odn_table->min_vddc > 2000)\n\t\todn_table->min_vddc = dep_table[0]->entries[0].vddc;\n\n\ti = od_table[2]->count - 1;\n\tod_table[2]->entries[i].clk = hwmgr->platform_descriptor.overdriveLimit.memoryClock > od_table[2]->entries[i].clk ?\n\t\t\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock :\n\t\t\t\t\tod_table[2]->entries[i].clk;\n\tod_table[2]->entries[i].vddc = odn_table->max_vddc > od_table[2]->entries[i].vddc ?\n\t\t\t\t\todn_table->max_vddc :\n\t\t\t\t\tod_table[2]->entries[i].vddc;\n\n\treturn 0;\n}\n\nstatic void vega10_init_dpm_defaults(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tint i;\n\tuint32_t sub_vendor_id, hw_revision;\n\tuint32_t top32, bottom32;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tvega10_initialize_power_tune_defaults(hwmgr);\n\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++) {\n\t\tdata->smu_features[i].smu_feature_id = 0xffff;\n\t\tdata->smu_features[i].smu_feature_bitmap = 1 << i;\n\t\tdata->smu_features[i].enabled = false;\n\t\tdata->smu_features[i].supported = false;\n\t}\n\n\tdata->smu_features[GNLD_DPM_PREFETCHER].smu_feature_id =\n\t\t\tFEATURE_DPM_PREFETCHER_BIT;\n\tdata->smu_features[GNLD_DPM_GFXCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_GFXCLK_BIT;\n\tdata->smu_features[GNLD_DPM_UCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_UCLK_BIT;\n\tdata->smu_features[GNLD_DPM_SOCCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_SOCCLK_BIT;\n\tdata->smu_features[GNLD_DPM_UVD].smu_feature_id =\n\t\t\tFEATURE_DPM_UVD_BIT;\n\tdata->smu_features[GNLD_DPM_VCE].smu_feature_id =\n\t\t\tFEATURE_DPM_VCE_BIT;\n\tdata->smu_features[GNLD_DPM_MP0CLK].smu_feature_id =\n\t\t\tFEATURE_DPM_MP0CLK_BIT;\n\tdata->smu_features[GNLD_DPM_LINK].smu_feature_id =\n\t\t\tFEATURE_DPM_LINK_BIT;\n\tdata->smu_features[GNLD_DPM_DCEFCLK].smu_feature_id =\n\t\t\tFEATURE_DPM_DCEFCLK_BIT;\n\tdata->smu_features[GNLD_ULV].smu_feature_id =\n\t\t\tFEATURE_ULV_BIT;\n\tdata->smu_features[GNLD_AVFS].smu_feature_id =\n\t\t\tFEATURE_AVFS_BIT;\n\tdata->smu_features[GNLD_DS_GFXCLK].smu_feature_id =\n\t\t\tFEATURE_DS_GFXCLK_BIT;\n\tdata->smu_features[GNLD_DS_SOCCLK].smu_feature_id =\n\t\t\tFEATURE_DS_SOCCLK_BIT;\n\tdata->smu_features[GNLD_DS_LCLK].smu_feature_id =\n\t\t\tFEATURE_DS_LCLK_BIT;\n\tdata->smu_features[GNLD_PPT].smu_feature_id =\n\t\t\tFEATURE_PPT_BIT;\n\tdata->smu_features[GNLD_TDC].smu_feature_id =\n\t\t\tFEATURE_TDC_BIT;\n\tdata->smu_features[GNLD_THERMAL].smu_feature_id =\n\t\t\tFEATURE_THERMAL_BIT;\n\tdata->smu_features[GNLD_GFX_PER_CU_CG].smu_feature_id =\n\t\t\tFEATURE_GFX_PER_CU_CG_BIT;\n\tdata->smu_features[GNLD_RM].smu_feature_id =\n\t\t\tFEATURE_RM_BIT;\n\tdata->smu_features[GNLD_DS_DCEFCLK].smu_feature_id =\n\t\t\tFEATURE_DS_DCEFCLK_BIT;\n\tdata->smu_features[GNLD_ACDC].smu_feature_id =\n\t\t\tFEATURE_ACDC_BIT;\n\tdata->smu_features[GNLD_VR0HOT].smu_feature_id =\n\t\t\tFEATURE_VR0HOT_BIT;\n\tdata->smu_features[GNLD_VR1HOT].smu_feature_id =\n\t\t\tFEATURE_VR1HOT_BIT;\n\tdata->smu_features[GNLD_FW_CTF].smu_feature_id =\n\t\t\tFEATURE_FW_CTF_BIT;\n\tdata->smu_features[GNLD_LED_DISPLAY].smu_feature_id =\n\t\t\tFEATURE_LED_DISPLAY_BIT;\n\tdata->smu_features[GNLD_FAN_CONTROL].smu_feature_id =\n\t\t\tFEATURE_FAN_CONTROL_BIT;\n\tdata->smu_features[GNLD_ACG].smu_feature_id = FEATURE_ACG_BIT;\n\tdata->smu_features[GNLD_DIDT].smu_feature_id = FEATURE_GFX_EDC_BIT;\n\tdata->smu_features[GNLD_PCC_LIMIT].smu_feature_id = FEATURE_PCC_LIMIT_CONTROL_BIT;\n\n\tif (!data->registry_data.prefetcher_dpm_key_disabled)\n\t\tdata->smu_features[GNLD_DPM_PREFETCHER].supported = true;\n\n\tif (!data->registry_data.sclk_dpm_key_disabled)\n\t\tdata->smu_features[GNLD_DPM_GFXCLK].supported = true;\n\n\tif (!data->registry_data.mclk_dpm_key_disabled)\n\t\tdata->smu_features[GNLD_DPM_UCLK].supported = true;\n\n\tif (!data->registry_data.socclk_dpm_key_disabled)\n\t\tdata->smu_features[GNLD_DPM_SOCCLK].supported = true;\n\n\tif (PP_CAP(PHM_PlatformCaps_UVDDPM))\n\t\tdata->smu_features[GNLD_DPM_UVD].supported = true;\n\n\tif (PP_CAP(PHM_PlatformCaps_VCEDPM))\n\t\tdata->smu_features[GNLD_DPM_VCE].supported = true;\n\n\tdata->smu_features[GNLD_DPM_LINK].supported = true;\n\n\tif (!data->registry_data.dcefclk_dpm_key_disabled)\n\t\tdata->smu_features[GNLD_DPM_DCEFCLK].supported = true;\n\n\tif (PP_CAP(PHM_PlatformCaps_SclkDeepSleep) &&\n\t    data->registry_data.sclk_deep_sleep_support) {\n\t\tdata->smu_features[GNLD_DS_GFXCLK].supported = true;\n\t\tdata->smu_features[GNLD_DS_SOCCLK].supported = true;\n\t\tdata->smu_features[GNLD_DS_LCLK].supported = true;\n\t\tdata->smu_features[GNLD_DS_DCEFCLK].supported = true;\n\t}\n\n\tif (data->registry_data.enable_pkg_pwr_tracking_feature)\n\t\tdata->smu_features[GNLD_PPT].supported = true;\n\n\tif (data->registry_data.enable_tdc_limit_feature)\n\t\tdata->smu_features[GNLD_TDC].supported = true;\n\n\tif (data->registry_data.thermal_support)\n\t\tdata->smu_features[GNLD_THERMAL].supported = true;\n\n\tif (data->registry_data.fan_control_support)\n\t\tdata->smu_features[GNLD_FAN_CONTROL].supported = true;\n\n\tif (data->registry_data.fw_ctf_enabled)\n\t\tdata->smu_features[GNLD_FW_CTF].supported = true;\n\n\tif (data->registry_data.avfs_support)\n\t\tdata->smu_features[GNLD_AVFS].supported = true;\n\n\tif (data->registry_data.led_dpm_enabled)\n\t\tdata->smu_features[GNLD_LED_DISPLAY].supported = true;\n\n\tif (data->registry_data.vr1hot_enabled)\n\t\tdata->smu_features[GNLD_VR1HOT].supported = true;\n\n\tif (data->registry_data.vr0hot_enabled)\n\t\tdata->smu_features[GNLD_VR0HOT].supported = true;\n\n\tsmum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetSmuVersion,\n\t\t\t&hwmgr->smu_version);\n\t\t \n\tif ((hwmgr->smu_version & 0xff000000) == 0x5000000)\n\t\tdata->smu_features[GNLD_ACG].supported = true;\n\tif (data->registry_data.didt_support)\n\t\tdata->smu_features[GNLD_DIDT].supported = true;\n\n\thw_revision = adev->pdev->revision;\n\tsub_vendor_id = adev->pdev->subsystem_vendor;\n\n\tif ((hwmgr->chip_id == 0x6862 ||\n\t\thwmgr->chip_id == 0x6861 ||\n\t\thwmgr->chip_id == 0x6868) &&\n\t\t(hw_revision == 0) &&\n\t\t(sub_vendor_id != 0x1002))\n\t\tdata->smu_features[GNLD_PCC_LIMIT].supported = true;\n\n\t \n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumTop32, &top32);\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumBottom32, &bottom32);\n\n\tadev->unique_id = ((uint64_t)bottom32 << 32) | top32;\n}\n\n#ifdef PPLIB_VEGA10_EVV_SUPPORT\nstatic int vega10_get_socclk_for_voltage_evv(struct pp_hwmgr *hwmgr,\n\tphm_ppt_v1_voltage_lookup_table *lookup_table,\n\tuint16_t virtual_voltage_id, int32_t *socclk)\n{\n\tuint8_t entry_id;\n\tuint8_t voltage_id;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tPP_ASSERT_WITH_CODE(lookup_table->count != 0,\n\t\t\t\"Lookup table is empty\",\n\t\t\treturn -EINVAL);\n\n\t \n\tfor (entry_id = 0; entry_id < table_info->vdd_dep_on_sclk->count; entry_id++) {\n\t\tvoltage_id = table_info->vdd_dep_on_socclk->entries[entry_id].vddInd;\n\t\tif (lookup_table->entries[voltage_id].us_vdd == virtual_voltage_id)\n\t\t\tbreak;\n\t}\n\n\tPP_ASSERT_WITH_CODE(entry_id < table_info->vdd_dep_on_socclk->count,\n\t\t\t\"Can't find requested voltage id in vdd_dep_on_socclk table!\",\n\t\t\treturn -EINVAL);\n\n\t*socclk = table_info->vdd_dep_on_socclk->entries[entry_id].clk;\n\n\treturn 0;\n}\n\n#define ATOM_VIRTUAL_VOLTAGE_ID0             0xff01\n \nstatic int vega10_get_evv_voltages(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint16_t vv_id;\n\tuint32_t vddc = 0;\n\tuint16_t i, j;\n\tuint32_t sclk = 0;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *socclk_table =\n\t\t\ttable_info->vdd_dep_on_socclk;\n\tint result;\n\n\tfor (i = 0; i < VEGA10_MAX_LEAKAGE_COUNT; i++) {\n\t\tvv_id = ATOM_VIRTUAL_VOLTAGE_ID0 + i;\n\n\t\tif (!vega10_get_socclk_for_voltage_evv(hwmgr,\n\t\t\t\ttable_info->vddc_lookup_table, vv_id, &sclk)) {\n\t\t\tif (PP_CAP(PHM_PlatformCaps_ClockStretcher)) {\n\t\t\t\tfor (j = 1; j < socclk_table->count; j++) {\n\t\t\t\t\tif (socclk_table->entries[j].clk == sclk &&\n\t\t\t\t\t\t\tsocclk_table->entries[j].cks_enable == 0) {\n\t\t\t\t\t\tsclk += 5000;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPP_ASSERT_WITH_CODE(!atomctrl_get_voltage_evv_on_sclk_ai(hwmgr,\n\t\t\t\t\tVOLTAGE_TYPE_VDDC, sclk, vv_id, &vddc),\n\t\t\t\t\t\"Error retrieving EVV voltage value!\",\n\t\t\t\t\tcontinue);\n\n\n\t\t\t \n\t\t\tPP_ASSERT_WITH_CODE((vddc < 2000 && vddc != 0),\n\t\t\t\t\t\"Invalid VDDC value\", result = -EINVAL;);\n\n\t\t\t \n\t\t\tif (vddc != 0 && vddc != vv_id) {\n\t\t\t\tdata->vddc_leakage.actual_voltage[data->vddc_leakage.count] = (uint16_t)(vddc/100);\n\t\t\t\tdata->vddc_leakage.leakage_id[data->vddc_leakage.count] = vv_id;\n\t\t\t\tdata->vddc_leakage.count++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vega10_patch_with_vdd_leakage(struct pp_hwmgr *hwmgr,\n\t\tuint16_t *voltage, struct vega10_leakage_voltage *leakage_table)\n{\n\tuint32_t index;\n\n\t \n\tfor (index = 0; index < leakage_table->count; index++) {\n\t\t \n\t\t \n\t\tif (leakage_table->leakage_id[index] == *voltage) {\n\t\t\t*voltage = leakage_table->actual_voltage[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*voltage > ATOM_VIRTUAL_VOLTAGE_ID0)\n\t\tpr_info(\"Voltage value looks like a Leakage ID but it's not patched\\n\");\n}\n\n \nstatic int vega10_patch_lookup_table_with_leakage(struct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_voltage_lookup_table *lookup_table,\n\t\tstruct vega10_leakage_voltage *leakage_table)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < lookup_table->count; i++)\n\t\tvega10_patch_with_vdd_leakage(hwmgr,\n\t\t\t\t&lookup_table->entries[i].us_vdd, leakage_table);\n\n\treturn 0;\n}\n\nstatic int vega10_patch_clock_voltage_limits_with_vddc_leakage(\n\t\tstruct pp_hwmgr *hwmgr, struct vega10_leakage_voltage *leakage_table,\n\t\tuint16_t *vddc)\n{\n\tvega10_patch_with_vdd_leakage(hwmgr, (uint16_t *)vddc, leakage_table);\n\n\treturn 0;\n}\n#endif\n\nstatic int vega10_patch_voltage_dependency_tables_with_lookup_table(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tuint8_t entry_id, voltage_id;\n\tunsigned i;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *mm_table =\n\t\t\ttable_info->mm_dep_table;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *mclk_table =\n\t\t\ttable_info->vdd_dep_on_mclk;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table *vdt;\n\t\tswitch (i) {\n\t\t\tcase 0: vdt = table_info->vdd_dep_on_socclk; break;\n\t\t\tcase 1: vdt = table_info->vdd_dep_on_sclk; break;\n\t\t\tcase 2: vdt = table_info->vdd_dep_on_dcefclk; break;\n\t\t\tcase 3: vdt = table_info->vdd_dep_on_pixclk; break;\n\t\t\tcase 4: vdt = table_info->vdd_dep_on_dispclk; break;\n\t\t\tcase 5: vdt = table_info->vdd_dep_on_phyclk; break;\n\t\t}\n\n\t\tfor (entry_id = 0; entry_id < vdt->count; entry_id++) {\n\t\t\tvoltage_id = vdt->entries[entry_id].vddInd;\n\t\t\tvdt->entries[entry_id].vddc =\n\t\t\t\t\ttable_info->vddc_lookup_table->entries[voltage_id].us_vdd;\n\t\t}\n\t}\n\n\tfor (entry_id = 0; entry_id < mm_table->count; ++entry_id) {\n\t\tvoltage_id = mm_table->entries[entry_id].vddcInd;\n\t\tmm_table->entries[entry_id].vddc =\n\t\t\ttable_info->vddc_lookup_table->entries[voltage_id].us_vdd;\n\t}\n\n\tfor (entry_id = 0; entry_id < mclk_table->count; ++entry_id) {\n\t\tvoltage_id = mclk_table->entries[entry_id].vddInd;\n\t\tmclk_table->entries[entry_id].vddc =\n\t\t\t\ttable_info->vddc_lookup_table->entries[voltage_id].us_vdd;\n\t\tvoltage_id = mclk_table->entries[entry_id].vddciInd;\n\t\tmclk_table->entries[entry_id].vddci =\n\t\t\t\ttable_info->vddci_lookup_table->entries[voltage_id].us_vdd;\n\t\tvoltage_id = mclk_table->entries[entry_id].mvddInd;\n\t\tmclk_table->entries[entry_id].mvdd =\n\t\t\t\ttable_info->vddmem_lookup_table->entries[voltage_id].us_vdd;\n\t}\n\n\n\treturn 0;\n\n}\n\nstatic int vega10_sort_lookup_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_ppt_v1_voltage_lookup_table *lookup_table)\n{\n\tuint32_t table_size, i, j;\n\n\tPP_ASSERT_WITH_CODE(lookup_table && lookup_table->count,\n\t\t\"Lookup table is empty\", return -EINVAL);\n\n\ttable_size = lookup_table->count;\n\n\t \n\tfor (i = 0; i < table_size - 1; i++) {\n\t\tfor (j = i + 1; j > 0; j--) {\n\t\t\tif (lookup_table->entries[j].us_vdd <\n\t\t\t\t\tlookup_table->entries[j - 1].us_vdd) {\n\t\t\t\tswap(lookup_table->entries[j - 1],\n\t\t\t\t     lookup_table->entries[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_complete_dependency_tables(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tint tmp_result;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n#ifdef PPLIB_VEGA10_EVV_SUPPORT\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\ttmp_result = vega10_patch_lookup_table_with_leakage(hwmgr,\n\t\t\ttable_info->vddc_lookup_table, &(data->vddc_leakage));\n\tif (tmp_result)\n\t\tresult = tmp_result;\n\n\ttmp_result = vega10_patch_clock_voltage_limits_with_vddc_leakage(hwmgr,\n\t\t\t&(data->vddc_leakage), &table_info->max_clock_voltage_on_dc.vddc);\n\tif (tmp_result)\n\t\tresult = tmp_result;\n#endif\n\n\ttmp_result = vega10_patch_voltage_dependency_tables_with_lookup_table(hwmgr);\n\tif (tmp_result)\n\t\tresult = tmp_result;\n\n\ttmp_result = vega10_sort_lookup_table(hwmgr, table_info->vddc_lookup_table);\n\tif (tmp_result)\n\t\tresult = tmp_result;\n\n\treturn result;\n}\n\nstatic int vega10_set_private_data_based_on_pptable(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *allowed_sclk_vdd_table =\n\t\t\ttable_info->vdd_dep_on_socclk;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *allowed_mclk_vdd_table =\n\t\t\ttable_info->vdd_dep_on_mclk;\n\n\tPP_ASSERT_WITH_CODE(allowed_sclk_vdd_table,\n\t\t\"VDD dependency on SCLK table is missing. This table is mandatory\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(allowed_sclk_vdd_table->count >= 1,\n\t\t\"VDD dependency on SCLK table is empty. This table is mandatory\", return -EINVAL);\n\n\tPP_ASSERT_WITH_CODE(allowed_mclk_vdd_table,\n\t\t\"VDD dependency on MCLK table is missing.  This table is mandatory\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(allowed_mclk_vdd_table->count >= 1,\n\t\t\"VDD dependency on MCLK table is empty.  This table is mandatory\", return -EINVAL);\n\n\ttable_info->max_clock_voltage_on_ac.sclk =\n\t\tallowed_sclk_vdd_table->entries[allowed_sclk_vdd_table->count - 1].clk;\n\ttable_info->max_clock_voltage_on_ac.mclk =\n\t\tallowed_mclk_vdd_table->entries[allowed_mclk_vdd_table->count - 1].clk;\n\ttable_info->max_clock_voltage_on_ac.vddc =\n\t\tallowed_sclk_vdd_table->entries[allowed_sclk_vdd_table->count - 1].vddc;\n\ttable_info->max_clock_voltage_on_ac.vddci =\n\t\tallowed_mclk_vdd_table->entries[allowed_mclk_vdd_table->count - 1].vddci;\n\n\thwmgr->dyn_state.max_clock_voltage_on_ac.sclk =\n\t\ttable_info->max_clock_voltage_on_ac.sclk;\n\thwmgr->dyn_state.max_clock_voltage_on_ac.mclk =\n\t\ttable_info->max_clock_voltage_on_ac.mclk;\n\thwmgr->dyn_state.max_clock_voltage_on_ac.vddc =\n\t\ttable_info->max_clock_voltage_on_ac.vddc;\n\thwmgr->dyn_state.max_clock_voltage_on_ac.vddci =\n\t\ttable_info->max_clock_voltage_on_ac.vddci;\n\n\treturn 0;\n}\n\nstatic int vega10_hwmgr_backend_fini(struct pp_hwmgr *hwmgr)\n{\n\tkfree(hwmgr->dyn_state.vddc_dep_on_dal_pwrl);\n\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = NULL;\n\n\tkfree(hwmgr->backend);\n\thwmgr->backend = NULL;\n\n\treturn 0;\n}\n\nstatic int vega10_hwmgr_backend_init(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\tstruct vega10_hwmgr *data;\n\tuint32_t config_telemetry = 0;\n\tstruct pp_atomfwctrl_voltage_table vol_table;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tdata = kzalloc(sizeof(struct vega10_hwmgr), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->backend = data;\n\n\thwmgr->workload_mask = 1 << hwmgr->workload_prority[PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT];\n\thwmgr->power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;\n\thwmgr->default_power_profile_mode = PP_SMC_POWER_PROFILE_BOOTUP_DEFAULT;\n\n\tvega10_set_default_registry_data(hwmgr);\n\tdata->disable_dpm_mask = 0xff;\n\n\t \n\tdata->vddc_control = VEGA10_VOLTAGE_CONTROL_NONE;\n\tdata->mvdd_control = VEGA10_VOLTAGE_CONTROL_NONE;\n\tdata->vddci_control = VEGA10_VOLTAGE_CONTROL_NONE;\n\n\t \n\tif (pp_atomfwctrl_is_voltage_controlled_by_gpio_v4(hwmgr,\n\t\t\tVOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_SVID2)) {\n\t\tif (!pp_atomfwctrl_get_voltage_table_v4(hwmgr,\n\t\t\t\tVOLTAGE_TYPE_VDDC, VOLTAGE_OBJ_SVID2,\n\t\t\t\t&vol_table)) {\n\t\t\tconfig_telemetry = ((vol_table.telemetry_slope << 8) & 0xff00) |\n\t\t\t\t\t(vol_table.telemetry_offset & 0xff);\n\t\t\tdata->vddc_control = VEGA10_VOLTAGE_CONTROL_BY_SVID2;\n\t\t}\n\t} else {\n\t\tkfree(hwmgr->backend);\n\t\thwmgr->backend = NULL;\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"VDDCR_SOC is not SVID2!\",\n\t\t\t\treturn -1);\n\t}\n\n\t \n\tif (pp_atomfwctrl_is_voltage_controlled_by_gpio_v4(hwmgr,\n\t\t\tVOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_SVID2)) {\n\t\tif (!pp_atomfwctrl_get_voltage_table_v4(hwmgr,\n\t\t\t\tVOLTAGE_TYPE_MVDDC, VOLTAGE_OBJ_SVID2,\n\t\t\t\t&vol_table)) {\n\t\t\tconfig_telemetry |=\n\t\t\t\t\t((vol_table.telemetry_slope << 24) & 0xff000000) |\n\t\t\t\t\t((vol_table.telemetry_offset << 16) & 0xff0000);\n\t\t\tdata->mvdd_control = VEGA10_VOLTAGE_CONTROL_BY_SVID2;\n\t\t}\n\t}\n\n\t  \n\tif (PP_CAP(PHM_PlatformCaps_ControlVDDCI)) {\n\t\tif (pp_atomfwctrl_is_voltage_controlled_by_gpio_v4(hwmgr,\n\t\t\t\tVOLTAGE_TYPE_VDDCI, VOLTAGE_OBJ_GPIO_LUT))\n\t\t\tdata->vddci_control = VEGA10_VOLTAGE_CONTROL_BY_GPIO;\n\t}\n\n\tdata->config_telemetry = config_telemetry;\n\n\tvega10_set_features_platform_caps(hwmgr);\n\n\tvega10_init_dpm_defaults(hwmgr);\n\n#ifdef PPLIB_VEGA10_EVV_SUPPORT\n\t \n\tPP_ASSERT_WITH_CODE(!vega10_get_evv_voltages(hwmgr),\n\t\t\t\"Get EVV Voltage Failed.  Abort Driver loading!\",\n\t\t\treturn -1);\n#endif\n\n\t \n\tvega10_complete_dependency_tables(hwmgr);\n\n\t \n\tvega10_set_private_data_based_on_pptable(hwmgr);\n\n\tdata->is_tlu_enabled = false;\n\n\thwmgr->platform_descriptor.hardwareActivityPerformanceLevels =\n\t\t\tVEGA10_MAX_HARDWARE_POWERLEVELS;\n\thwmgr->platform_descriptor.hardwarePerformanceLevels = 2;\n\thwmgr->platform_descriptor.minimumClocksReductionPercentage = 50;\n\n\thwmgr->platform_descriptor.vbiosInterruptId = 0x20000400;  \n\t \n\thwmgr->platform_descriptor.clockStep.engineClock = 500;\n\thwmgr->platform_descriptor.clockStep.memoryClock = 500;\n\n\tdata->total_active_cus = adev->gfx.cu_info.number;\n\tif (!hwmgr->not_vf)\n\t\treturn result;\n\n\t \n\tdata->odn_fan_table.target_fan_speed =\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usMaxFanRPM;\n\tdata->odn_fan_table.target_temperature =\n\t\t\thwmgr->thermal_controller.\n\t\t\tadvanceFanControlParameters.ucTargetTemperature;\n\tdata->odn_fan_table.min_performance_clock =\n\t\t\thwmgr->thermal_controller.advanceFanControlParameters.\n\t\t\tulMinFanSCLKAcousticLimit;\n\tdata->odn_fan_table.min_fan_limit =\n\t\t\thwmgr->thermal_controller.\n\t\t\tadvanceFanControlParameters.usFanPWMMinLimit *\n\t\t\thwmgr->thermal_controller.fanInfo.ulMaxRPM / 100;\n\n\tdata->mem_channels = (RREG32_SOC15(DF, 0, mmDF_CS_AON0_DramBaseAddress0) &\n\t\t\tDF_CS_AON0_DramBaseAddress0__IntLvNumChan_MASK) >>\n\t\t\tDF_CS_AON0_DramBaseAddress0__IntLvNumChan__SHIFT;\n\tPP_ASSERT_WITH_CODE(data->mem_channels < ARRAY_SIZE(channel_number),\n\t\t\t\"Mem Channel Index Exceeded maximum!\",\n\t\t\treturn -EINVAL);\n\n\treturn result;\n}\n\nstatic int vega10_init_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->low_sclk_interrupt_threshold = 0;\n\n\treturn 0;\n}\n\nstatic int vega10_setup_dpm_led_config(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\n\tstruct pp_atomfwctrl_voltage_table table;\n\tuint8_t i, j;\n\tuint32_t mask = 0;\n\tuint32_t tmp;\n\tint32_t ret = 0;\n\n\tret = pp_atomfwctrl_get_voltage_table_v4(hwmgr, VOLTAGE_TYPE_LEDDPM,\n\t\t\t\t\t\tVOLTAGE_OBJ_GPIO_LUT, &table);\n\n\tif (!ret) {\n\t\ttmp = table.mask_low;\n\t\tfor (i = 0, j = 0; i < 32; i++) {\n\t\t\tif (tmp & 1) {\n\t\t\t\tmask |= (uint32_t)(i << (8 * j));\n\t\t\t\tif (++j >= 3)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp >>= 1;\n\t\t}\n\t}\n\n\tpp_table->LedPin0 = (uint8_t)(mask & 0xff);\n\tpp_table->LedPin1 = (uint8_t)((mask >> 8) & 0xff);\n\tpp_table->LedPin2 = (uint8_t)((mask >> 16) & 0xff);\n\treturn 0;\n}\n\nstatic int vega10_setup_asic_task(struct pp_hwmgr *hwmgr)\n{\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tPP_ASSERT_WITH_CODE(!vega10_init_sclk_threshold(hwmgr),\n\t\t\t\"Failed to init sclk threshold!\",\n\t\t\treturn -EINVAL);\n\n\tPP_ASSERT_WITH_CODE(!vega10_setup_dpm_led_config(hwmgr),\n\t\t\t\"Failed to set up led dpm config!\",\n\t\t\treturn -EINVAL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_NumOfDisplays,\n\t\t\t\t0,\n\t\t\t\tNULL);\n\n\treturn 0;\n}\n\n \nstatic int vega10_trim_voltage_table(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_atomfwctrl_voltage_table *vol_table)\n{\n\tuint32_t i, j;\n\tuint16_t vvalue;\n\tbool found = false;\n\tstruct pp_atomfwctrl_voltage_table *table;\n\n\tPP_ASSERT_WITH_CODE(vol_table,\n\t\t\t\"Voltage Table empty.\", return -EINVAL);\n\ttable = kzalloc(sizeof(struct pp_atomfwctrl_voltage_table),\n\t\t\tGFP_KERNEL);\n\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\ttable->mask_low = vol_table->mask_low;\n\ttable->phase_delay = vol_table->phase_delay;\n\n\tfor (i = 0; i < vol_table->count; i++) {\n\t\tvvalue = vol_table->entries[i].value;\n\t\tfound = false;\n\n\t\tfor (j = 0; j < table->count; j++) {\n\t\t\tif (vvalue == table->entries[j].value) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\ttable->entries[table->count].value = vvalue;\n\t\t\ttable->entries[table->count].smio_low =\n\t\t\t\t\tvol_table->entries[i].smio_low;\n\t\t\ttable->count++;\n\t\t}\n\t}\n\n\tmemcpy(vol_table, table, sizeof(struct pp_atomfwctrl_voltage_table));\n\tkfree(table);\n\n\treturn 0;\n}\n\nstatic int vega10_get_mvdd_voltage_table(struct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table *dep_table,\n\t\tstruct pp_atomfwctrl_voltage_table *vol_table)\n{\n\tint i;\n\n\tPP_ASSERT_WITH_CODE(dep_table->count,\n\t\t\t\"Voltage Dependency Table empty.\",\n\t\t\treturn -EINVAL);\n\n\tvol_table->mask_low = 0;\n\tvol_table->phase_delay = 0;\n\tvol_table->count = dep_table->count;\n\n\tfor (i = 0; i < vol_table->count; i++) {\n\t\tvol_table->entries[i].value = dep_table->entries[i].mvdd;\n\t\tvol_table->entries[i].smio_low = 0;\n\t}\n\n\tPP_ASSERT_WITH_CODE(!vega10_trim_voltage_table(hwmgr,\n\t\t\tvol_table),\n\t\t\t\"Failed to trim MVDD Table!\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\nstatic int vega10_get_vddci_voltage_table(struct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table *dep_table,\n\t\tstruct pp_atomfwctrl_voltage_table *vol_table)\n{\n\tuint32_t i;\n\n\tPP_ASSERT_WITH_CODE(dep_table->count,\n\t\t\t\"Voltage Dependency Table empty.\",\n\t\t\treturn -EINVAL);\n\n\tvol_table->mask_low = 0;\n\tvol_table->phase_delay = 0;\n\tvol_table->count = dep_table->count;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tvol_table->entries[i].value = dep_table->entries[i].vddci;\n\t\tvol_table->entries[i].smio_low = 0;\n\t}\n\n\tPP_ASSERT_WITH_CODE(!vega10_trim_voltage_table(hwmgr, vol_table),\n\t\t\t\"Failed to trim VDDCI table.\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\nstatic int vega10_get_vdd_voltage_table(struct pp_hwmgr *hwmgr,\n\t\tphm_ppt_v1_clock_voltage_dependency_table *dep_table,\n\t\tstruct pp_atomfwctrl_voltage_table *vol_table)\n{\n\tint i;\n\n\tPP_ASSERT_WITH_CODE(dep_table->count,\n\t\t\t\"Voltage Dependency Table empty.\",\n\t\t\treturn -EINVAL);\n\n\tvol_table->mask_low = 0;\n\tvol_table->phase_delay = 0;\n\tvol_table->count = dep_table->count;\n\n\tfor (i = 0; i < vol_table->count; i++) {\n\t\tvol_table->entries[i].value = dep_table->entries[i].vddc;\n\t\tvol_table->entries[i].smio_low = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vega10_trim_voltage_table_to_fit_state_table(\n\t\tstruct pp_hwmgr *hwmgr,\n\t\tuint32_t max_vol_steps,\n\t\tstruct pp_atomfwctrl_voltage_table *vol_table)\n{\n\tunsigned int i, diff;\n\n\tif (vol_table->count <= max_vol_steps)\n\t\treturn;\n\n\tdiff = vol_table->count - max_vol_steps;\n\n\tfor (i = 0; i < max_vol_steps; i++)\n\t\tvol_table->entries[i] = vol_table->entries[i + diff];\n\n\tvol_table->count = max_vol_steps;\n}\n\n \nstatic int vega10_construct_voltage_tables(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tint result;\n\n\tif (data->mvdd_control == VEGA10_VOLTAGE_CONTROL_BY_SVID2 ||\n\t\t\tdata->mvdd_control == VEGA10_VOLTAGE_CONTROL_NONE) {\n\t\tresult = vega10_get_mvdd_voltage_table(hwmgr,\n\t\t\t\ttable_info->vdd_dep_on_mclk,\n\t\t\t\t&(data->mvdd_voltage_table));\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"Failed to retrieve MVDDC table!\",\n\t\t\t\treturn result);\n\t}\n\n\tif (data->vddci_control == VEGA10_VOLTAGE_CONTROL_NONE) {\n\t\tresult = vega10_get_vddci_voltage_table(hwmgr,\n\t\t\t\ttable_info->vdd_dep_on_mclk,\n\t\t\t\t&(data->vddci_voltage_table));\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"Failed to retrieve VDDCI_MEM table!\",\n\t\t\t\treturn result);\n\t}\n\n\tif (data->vddc_control == VEGA10_VOLTAGE_CONTROL_BY_SVID2 ||\n\t\t\tdata->vddc_control == VEGA10_VOLTAGE_CONTROL_NONE) {\n\t\tresult = vega10_get_vdd_voltage_table(hwmgr,\n\t\t\t\ttable_info->vdd_dep_on_sclk,\n\t\t\t\t&(data->vddc_voltage_table));\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"Failed to retrieve VDDCR_SOC table!\",\n\t\t\t\treturn result);\n\t}\n\n\tPP_ASSERT_WITH_CODE(data->vddc_voltage_table.count <= 16,\n\t\t\t\"Too many voltage values for VDDC. Trimming to fit state table.\",\n\t\t\tvega10_trim_voltage_table_to_fit_state_table(hwmgr,\n\t\t\t\t\t16, &(data->vddc_voltage_table)));\n\n\tPP_ASSERT_WITH_CODE(data->vddci_voltage_table.count <= 16,\n\t\t\t\"Too many voltage values for VDDCI. Trimming to fit state table.\",\n\t\t\tvega10_trim_voltage_table_to_fit_state_table(hwmgr,\n\t\t\t\t\t16, &(data->vddci_voltage_table)));\n\n\tPP_ASSERT_WITH_CODE(data->mvdd_voltage_table.count <= 16,\n\t\t\t\"Too many voltage values for MVDD. Trimming to fit state table.\",\n\t\t\tvega10_trim_voltage_table_to_fit_state_table(hwmgr,\n\t\t\t\t\t16, &(data->mvdd_voltage_table)));\n\n\n\treturn 0;\n}\n\n \nstatic void vega10_init_dpm_state(struct vega10_dpm_state *dpm_state)\n{\n\tdpm_state->soft_min_level = 0xff;\n\tdpm_state->soft_max_level = 0xff;\n\tdpm_state->hard_min_level = 0xff;\n\tdpm_state->hard_max_level = 0xff;\n}\n\nstatic void vega10_setup_default_single_dpm_table(struct pp_hwmgr *hwmgr,\n\t\tstruct vega10_single_dpm_table *dpm_table,\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table)\n{\n\tint i;\n\n\tdpm_table->count = 0;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (i == 0 || dpm_table->dpm_levels[dpm_table->count - 1].value <=\n\t\t\t\tdep_table->entries[i].clk) {\n\t\t\tdpm_table->dpm_levels[dpm_table->count].value =\n\t\t\t\t\tdep_table->entries[i].clk;\n\t\t\tdpm_table->dpm_levels[dpm_table->count].enabled = true;\n\t\t\tdpm_table->count++;\n\t\t}\n\t}\n}\nstatic int vega10_setup_default_pcie_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_pcie_table *pcie_table = &(data->dpm_table.pcie_table);\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_pcie_table *bios_pcie_table =\n\t\t\ttable_info->pcie_table;\n\tuint32_t i;\n\n\tPP_ASSERT_WITH_CODE(bios_pcie_table->count,\n\t\t\t\"Incorrect number of PCIE States from VBIOS!\",\n\t\t\treturn -1);\n\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\tif (data->registry_data.pcieSpeedOverride)\n\t\t\tpcie_table->pcie_gen[i] =\n\t\t\t\t\tdata->registry_data.pcieSpeedOverride;\n\t\telse\n\t\t\tpcie_table->pcie_gen[i] =\n\t\t\t\t\tbios_pcie_table->entries[i].gen_speed;\n\n\t\tif (data->registry_data.pcieLaneOverride)\n\t\t\tpcie_table->pcie_lane[i] = (uint8_t)encode_pcie_lane_width(\n\t\t\t\t\tdata->registry_data.pcieLaneOverride);\n\t\telse\n\t\t\tpcie_table->pcie_lane[i] = (uint8_t)encode_pcie_lane_width(\n\t\t\t\t\t\t\tbios_pcie_table->entries[i].lane_width);\n\t\tif (data->registry_data.pcieClockOverride)\n\t\t\tpcie_table->lclk[i] =\n\t\t\t\t\tdata->registry_data.pcieClockOverride;\n\t\telse\n\t\t\tpcie_table->lclk[i] =\n\t\t\t\t\tbios_pcie_table->entries[i].pcie_sclk;\n\t}\n\n\tpcie_table->count = NUM_LINK_LEVELS;\n\n\treturn 0;\n}\n\n \nstatic int vega10_setup_default_dpm_tables(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct vega10_single_dpm_table *dpm_table;\n\tuint32_t i;\n\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_soc_table =\n\t\t\ttable_info->vdd_dep_on_socclk;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_gfx_table =\n\t\t\ttable_info->vdd_dep_on_sclk;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_mclk_table =\n\t\t\ttable_info->vdd_dep_on_mclk;\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *dep_mm_table =\n\t\t\ttable_info->mm_dep_table;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_dcef_table =\n\t\t\ttable_info->vdd_dep_on_dcefclk;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_pix_table =\n\t\t\ttable_info->vdd_dep_on_pixclk;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_disp_table =\n\t\t\ttable_info->vdd_dep_on_dispclk;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_phy_table =\n\t\t\ttable_info->vdd_dep_on_phyclk;\n\n\tPP_ASSERT_WITH_CODE(dep_soc_table,\n\t\t\t\"SOCCLK dependency table is missing. This table is mandatory\",\n\t\t\treturn -EINVAL);\n\tPP_ASSERT_WITH_CODE(dep_soc_table->count >= 1,\n\t\t\t\"SOCCLK dependency table is empty. This table is mandatory\",\n\t\t\treturn -EINVAL);\n\n\tPP_ASSERT_WITH_CODE(dep_gfx_table,\n\t\t\t\"GFXCLK dependency table is missing. This table is mandatory\",\n\t\t\treturn -EINVAL);\n\tPP_ASSERT_WITH_CODE(dep_gfx_table->count >= 1,\n\t\t\t\"GFXCLK dependency table is empty. This table is mandatory\",\n\t\t\treturn -EINVAL);\n\n\tPP_ASSERT_WITH_CODE(dep_mclk_table,\n\t\t\t\"MCLK dependency table is missing. This table is mandatory\",\n\t\t\treturn -EINVAL);\n\tPP_ASSERT_WITH_CODE(dep_mclk_table->count >= 1,\n\t\t\t\"MCLK dependency table has to have is missing. This table is mandatory\",\n\t\t\treturn -EINVAL);\n\n\t \n\tdpm_table = &(data->dpm_table.soc_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_soc_table);\n\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdpm_table = &(data->dpm_table.gfx_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_gfx_table);\n\tif (hwmgr->platform_descriptor.overdriveLimit.engineClock == 0)\n\t\thwmgr->platform_descriptor.overdriveLimit.engineClock =\n\t\t\t\t\tdpm_table->dpm_levels[dpm_table->count-1].value;\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdata->dpm_table.mem_table.count = 0;\n\tdpm_table = &(data->dpm_table.mem_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_mclk_table);\n\tif (hwmgr->platform_descriptor.overdriveLimit.memoryClock == 0)\n\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock =\n\t\t\t\t\tdpm_table->dpm_levels[dpm_table->count-1].value;\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdata->dpm_table.eclk_table.count = 0;\n\tdpm_table = &(data->dpm_table.eclk_table);\n\tfor (i = 0; i < dep_mm_table->count; i++) {\n\t\tif (i == 0 || dpm_table->dpm_levels\n\t\t\t\t[dpm_table->count - 1].value <=\n\t\t\t\t\t\tdep_mm_table->entries[i].eclk) {\n\t\t\tdpm_table->dpm_levels[dpm_table->count].value =\n\t\t\t\t\tdep_mm_table->entries[i].eclk;\n\t\t\tdpm_table->dpm_levels[dpm_table->count].enabled = i == 0;\n\t\t\tdpm_table->count++;\n\t\t}\n\t}\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdata->dpm_table.vclk_table.count = 0;\n\tdata->dpm_table.dclk_table.count = 0;\n\tdpm_table = &(data->dpm_table.vclk_table);\n\tfor (i = 0; i < dep_mm_table->count; i++) {\n\t\tif (i == 0 || dpm_table->dpm_levels\n\t\t\t\t[dpm_table->count - 1].value <=\n\t\t\t\t\t\tdep_mm_table->entries[i].vclk) {\n\t\t\tdpm_table->dpm_levels[dpm_table->count].value =\n\t\t\t\t\tdep_mm_table->entries[i].vclk;\n\t\t\tdpm_table->dpm_levels[dpm_table->count].enabled = i == 0;\n\t\t\tdpm_table->count++;\n\t\t}\n\t}\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdpm_table = &(data->dpm_table.dclk_table);\n\tfor (i = 0; i < dep_mm_table->count; i++) {\n\t\tif (i == 0 || dpm_table->dpm_levels\n\t\t\t\t[dpm_table->count - 1].value <=\n\t\t\t\t\t\tdep_mm_table->entries[i].dclk) {\n\t\t\tdpm_table->dpm_levels[dpm_table->count].value =\n\t\t\t\t\tdep_mm_table->entries[i].dclk;\n\t\t\tdpm_table->dpm_levels[dpm_table->count].enabled = i == 0;\n\t\t\tdpm_table->count++;\n\t\t}\n\t}\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\t \n\tdpm_table = &(data->dpm_table.dcef_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_dcef_table);\n\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdpm_table = &(data->dpm_table.pixel_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_pix_table);\n\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdpm_table = &(data->dpm_table.display_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_disp_table);\n\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tdpm_table = &(data->dpm_table.phy_table);\n\tvega10_setup_default_single_dpm_table(hwmgr,\n\t\t\tdpm_table,\n\t\t\tdep_phy_table);\n\n\tvega10_init_dpm_state(&(dpm_table->dpm_state));\n\n\tvega10_setup_default_pcie_table(hwmgr);\n\n\t \n\tdata->custom_profile_mode[0] = 0;\n\tdata->custom_profile_mode[1] = 0;\n\tdata->custom_profile_mode[2] = 0;\n\tdata->custom_profile_mode[3] = 0;\n\n\t \n\tmemcpy(&(data->golden_dpm_table), &(data->dpm_table),\n\t\t\tsizeof(struct vega10_dpm_table));\n\n\treturn 0;\n}\n\n \nstatic int vega10_populate_ulv_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tdata->smc_state_table.pp_table.UlvOffsetVid =\n\t\t\t(uint8_t)table_info->us_ulv_voltage_offset;\n\n\tdata->smc_state_table.pp_table.UlvSmnclkDid =\n\t\t\t(uint8_t)(table_info->us_ulv_smnclk_did);\n\tdata->smc_state_table.pp_table.UlvMp1clkDid =\n\t\t\t(uint8_t)(table_info->us_ulv_mp1clk_did);\n\tdata->smc_state_table.pp_table.UlvGfxclkBypass =\n\t\t\t(uint8_t)(table_info->us_ulv_gfxclk_bypass);\n\tdata->smc_state_table.pp_table.UlvPhaseSheddingPsi0 =\n\t\t\t(uint8_t)(data->vddc_voltage_table.psi0_enable);\n\tdata->smc_state_table.pp_table.UlvPhaseSheddingPsi1 =\n\t\t\t(uint8_t)(data->vddc_voltage_table.psi1_enable);\n\n\treturn 0;\n}\n\nstatic int vega10_populate_single_lclk_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t lclock, uint8_t *curr_lclk_did)\n{\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(\n\t\t\thwmgr,\n\t\t\tCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\tlclock, &dividers),\n\t\t\t\"Failed to get LCLK clock settings from VBIOS!\",\n\t\t\treturn -1);\n\n\t*curr_lclk_did = dividers.ulDid;\n\n\treturn 0;\n}\n\nstatic int vega10_override_pcie_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tstruct vega10_hwmgr *data =\n\t\t\t(struct vega10_hwmgr *)(hwmgr->backend);\n\tuint32_t pcie_gen = 0, pcie_width = 0;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tint i;\n\n\tif (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN4)\n\t\tpcie_gen = 3;\n\telse if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN3)\n\t\tpcie_gen = 2;\n\telse if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN2)\n\t\tpcie_gen = 1;\n\telse if (adev->pm.pcie_gen_mask & CAIL_PCIE_LINK_SPEED_SUPPORT_GEN1)\n\t\tpcie_gen = 0;\n\n\tif (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X16)\n\t\tpcie_width = 6;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X12)\n\t\tpcie_width = 5;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X8)\n\t\tpcie_width = 4;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X4)\n\t\tpcie_width = 3;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X2)\n\t\tpcie_width = 2;\n\telse if (adev->pm.pcie_mlw_mask & CAIL_PCIE_LINK_WIDTH_SUPPORT_X1)\n\t\tpcie_width = 1;\n\n\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\tif (pp_table->PcieGenSpeed[i] > pcie_gen)\n\t\t\tpp_table->PcieGenSpeed[i] = pcie_gen;\n\n\t\tif (pp_table->PcieLaneCount[i] > pcie_width)\n\t\t\tpp_table->PcieLaneCount[i] = pcie_width;\n\t}\n\n\tif (data->registry_data.pcie_dpm_key_disabled) {\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\t\tpp_table->PcieGenSpeed[i] = pcie_gen;\n\t\t\tpp_table->PcieLaneCount[i] = pcie_width;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_smc_link_levels(struct pp_hwmgr *hwmgr)\n{\n\tint result = -1;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct vega10_pcie_table *pcie_table =\n\t\t\t&(data->dpm_table.pcie_table);\n\tuint32_t i, j;\n\n\tfor (i = 0; i < pcie_table->count; i++) {\n\t\tpp_table->PcieGenSpeed[i] = pcie_table->pcie_gen[i];\n\t\tpp_table->PcieLaneCount[i] = pcie_table->pcie_lane[i];\n\n\t\tresult = vega10_populate_single_lclk_level(hwmgr,\n\t\t\t\tpcie_table->lclk[i], &(pp_table->LclkDid[i]));\n\t\tif (result) {\n\t\t\tpr_info(\"Populate LClock Level %d Failed!\\n\", i);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_LINK_LEVELS) {\n\t\tpp_table->PcieGenSpeed[i] = pcie_table->pcie_gen[j];\n\t\tpp_table->PcieLaneCount[i] = pcie_table->pcie_lane[j];\n\n\t\tresult = vega10_populate_single_lclk_level(hwmgr,\n\t\t\t\tpcie_table->lclk[j], &(pp_table->LclkDid[i]));\n\t\tif (result) {\n\t\t\tpr_info(\"Populate LClock Level %d Failed!\\n\", i);\n\t\t\treturn result;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn result;\n}\n\n \nstatic int vega10_populate_single_gfx_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t gfx_clock, PllSetting_t *current_gfxclk_level,\n\t\tuint32_t *acg_freq)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_on_sclk;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\tuint32_t gfx_max_clock =\n\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock;\n\tuint32_t i = 0;\n\n\tif (hwmgr->od_enabled)\n\t\tdep_on_sclk = (struct phm_ppt_v1_clock_voltage_dependency_table *)\n\t\t\t\t\t\t&(data->odn_dpm_table.vdd_dep_on_sclk);\n\telse\n\t\tdep_on_sclk = table_info->vdd_dep_on_sclk;\n\n\tPP_ASSERT_WITH_CODE(dep_on_sclk,\n\t\t\t\"Invalid SOC_VDD-GFX_CLK Dependency Table!\",\n\t\t\treturn -EINVAL);\n\n\tif (data->need_update_dpm_table & DPMTABLE_OD_UPDATE_SCLK)\n\t\tgfx_clock = gfx_clock > gfx_max_clock ? gfx_max_clock : gfx_clock;\n\telse {\n\t\tfor (i = 0; i < dep_on_sclk->count; i++) {\n\t\t\tif (dep_on_sclk->entries[i].clk == gfx_clock)\n\t\t\t\tbreak;\n\t\t}\n\t\tPP_ASSERT_WITH_CODE(dep_on_sclk->count > i,\n\t\t\t\t\"Cannot find gfx_clk in SOC_VDD-GFX_CLK!\",\n\t\t\t\treturn -EINVAL);\n\t}\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(hwmgr,\n\t\t\tCOMPUTE_GPUCLK_INPUT_FLAG_GFXCLK,\n\t\t\tgfx_clock, &dividers),\n\t\t\t\"Failed to get GFX Clock settings from VBIOS!\",\n\t\t\treturn -EINVAL);\n\n\t \n\tcurrent_gfxclk_level->FbMult =\n\t\t\tcpu_to_le32(dividers.ulPll_fb_mult);\n\t \n\tcurrent_gfxclk_level->SsOn = dividers.ucPll_ss_enable;\n\tcurrent_gfxclk_level->SsFbMult =\n\t\t\tcpu_to_le32(dividers.ulPll_ss_fbsmult);\n\tcurrent_gfxclk_level->SsSlewFrac =\n\t\t\tcpu_to_le16(dividers.usPll_ss_slew_frac);\n\tcurrent_gfxclk_level->Did = (uint8_t)(dividers.ulDid);\n\n\t*acg_freq = gfx_clock / 100;  \n\n\treturn 0;\n}\n\n \nstatic int vega10_populate_single_soc_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t soc_clock, uint8_t *current_soc_did,\n\t\tuint8_t *current_vol_index)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_on_soc;\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\tuint32_t i;\n\n\tif (hwmgr->od_enabled) {\n\t\tdep_on_soc = (struct phm_ppt_v1_clock_voltage_dependency_table *)\n\t\t\t\t\t\t&data->odn_dpm_table.vdd_dep_on_socclk;\n\t\tfor (i = 0; i < dep_on_soc->count; i++) {\n\t\t\tif (dep_on_soc->entries[i].clk >= soc_clock)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdep_on_soc = table_info->vdd_dep_on_socclk;\n\t\tfor (i = 0; i < dep_on_soc->count; i++) {\n\t\t\tif (dep_on_soc->entries[i].clk == soc_clock)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tPP_ASSERT_WITH_CODE(dep_on_soc->count > i,\n\t\t\t\"Cannot find SOC_CLK in SOC_VDD-SOC_CLK Dependency Table\",\n\t\t\treturn -EINVAL);\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(hwmgr,\n\t\t\tCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\tsoc_clock, &dividers),\n\t\t\t\"Failed to get SOC Clock settings from VBIOS!\",\n\t\t\treturn -EINVAL);\n\n\t*current_soc_did = (uint8_t)dividers.ulDid;\n\t*current_vol_index = (uint8_t)(dep_on_soc->entries[i].vddInd);\n\treturn 0;\n}\n\n \nstatic int vega10_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct vega10_single_dpm_table *dpm_table = &(data->dpm_table.gfx_table);\n\tint result = 0;\n\tuint32_t i, j;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tresult = vega10_populate_single_gfx_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[i].value,\n\t\t\t\t&(pp_table->GfxclkLevel[i]),\n\t\t\t\t&(pp_table->AcgFreqTable[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_GFXCLK_DPM_LEVELS) {\n\t\tresult = vega10_populate_single_gfx_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[j].value,\n\t\t\t\t&(pp_table->GfxclkLevel[i]),\n\t\t\t\t&(pp_table->AcgFreqTable[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t\ti++;\n\t}\n\n\tpp_table->GfxclkSlewRate =\n\t\t\tcpu_to_le16(table_info->us_gfxclk_slew_rate);\n\n\tdpm_table = &(data->dpm_table.soc_table);\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tresult = vega10_populate_single_soc_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[i].value,\n\t\t\t\t&(pp_table->SocclkDid[i]),\n\t\t\t\t&(pp_table->SocDpmVoltageIndex[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_SOCCLK_DPM_LEVELS) {\n\t\tresult = vega10_populate_single_soc_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[j].value,\n\t\t\t\t&(pp_table->SocclkDid[i]),\n\t\t\t\t&(pp_table->SocDpmVoltageIndex[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t\ti++;\n\t}\n\n\treturn result;\n}\n\nstatic void vega10_populate_vddc_soc_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct phm_ppt_v2_information *table_info = hwmgr->pptable;\n\tstruct phm_ppt_v1_voltage_lookup_table *vddc_lookup_table;\n\n\tuint8_t soc_vid = 0;\n\tuint32_t i, max_vddc_level;\n\n\tif (hwmgr->od_enabled)\n\t\tvddc_lookup_table = (struct phm_ppt_v1_voltage_lookup_table *)&data->odn_dpm_table.vddc_lookup_table;\n\telse\n\t\tvddc_lookup_table = table_info->vddc_lookup_table;\n\n\tmax_vddc_level = vddc_lookup_table->count;\n\tfor (i = 0; i < max_vddc_level; i++) {\n\t\tsoc_vid = (uint8_t)convert_to_vid(vddc_lookup_table->entries[i].us_vdd);\n\t\tpp_table->SocVid[i] = soc_vid;\n\t}\n\twhile (i < MAX_REGULAR_DPM_NUMBER) {\n\t\tpp_table->SocVid[i] = soc_vid;\n\t\ti++;\n\t}\n}\n\n \nstatic int vega10_populate_single_memory_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t mem_clock, uint8_t *current_mem_vid,\n\t\tPllSetting_t *current_memclk_level, uint8_t *current_mem_soc_vind)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_on_mclk;\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\tuint32_t mem_max_clock =\n\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock;\n\tuint32_t i = 0;\n\n\tif (hwmgr->od_enabled)\n\t\tdep_on_mclk = (struct phm_ppt_v1_clock_voltage_dependency_table *)\n\t\t\t\t\t&data->odn_dpm_table.vdd_dep_on_mclk;\n\telse\n\t\tdep_on_mclk = table_info->vdd_dep_on_mclk;\n\n\tPP_ASSERT_WITH_CODE(dep_on_mclk,\n\t\t\t\"Invalid SOC_VDD-UCLK Dependency Table!\",\n\t\t\treturn -EINVAL);\n\n\tif (data->need_update_dpm_table & DPMTABLE_OD_UPDATE_MCLK) {\n\t\tmem_clock = mem_clock > mem_max_clock ? mem_max_clock : mem_clock;\n\t} else {\n\t\tfor (i = 0; i < dep_on_mclk->count; i++) {\n\t\t\tif (dep_on_mclk->entries[i].clk == mem_clock)\n\t\t\t\tbreak;\n\t\t}\n\t\tPP_ASSERT_WITH_CODE(dep_on_mclk->count > i,\n\t\t\t\t\"Cannot find UCLK in SOC_VDD-UCLK Dependency Table!\",\n\t\t\t\treturn -EINVAL);\n\t}\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(\n\t\t\thwmgr, COMPUTE_GPUCLK_INPUT_FLAG_UCLK, mem_clock, &dividers),\n\t\t\t\"Failed to get UCLK settings from VBIOS!\",\n\t\t\treturn -1);\n\n\t*current_mem_vid =\n\t\t\t(uint8_t)(convert_to_vid(dep_on_mclk->entries[i].mvdd));\n\t*current_mem_soc_vind =\n\t\t\t(uint8_t)(dep_on_mclk->entries[i].vddInd);\n\tcurrent_memclk_level->FbMult = cpu_to_le32(dividers.ulPll_fb_mult);\n\tcurrent_memclk_level->Did = (uint8_t)(dividers.ulDid);\n\n\tPP_ASSERT_WITH_CODE(current_memclk_level->Did >= 1,\n\t\t\t\"Invalid Divider ID!\",\n\t\t\treturn -EINVAL);\n\n\treturn 0;\n}\n\n \nstatic int vega10_populate_all_memory_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct vega10_single_dpm_table *dpm_table =\n\t\t\t&(data->dpm_table.mem_table);\n\tint result = 0;\n\tuint32_t i, j;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tresult = vega10_populate_single_memory_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[i].value,\n\t\t\t\t&(pp_table->MemVid[i]),\n\t\t\t\t&(pp_table->UclkLevel[i]),\n\t\t\t\t&(pp_table->MemSocVoltageIndex[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_UCLK_DPM_LEVELS) {\n\t\tresult = vega10_populate_single_memory_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[j].value,\n\t\t\t\t&(pp_table->MemVid[i]),\n\t\t\t\t&(pp_table->UclkLevel[i]),\n\t\t\t\t&(pp_table->MemSocVoltageIndex[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t\ti++;\n\t}\n\n\tpp_table->NumMemoryChannels = (uint16_t)(data->mem_channels);\n\tpp_table->MemoryChannelWidth =\n\t\t\t(uint16_t)(HBM_MEMORY_CHANNEL_WIDTH *\n\t\t\t\t\tchannel_number[data->mem_channels]);\n\n\tpp_table->LowestUclkReservedForUlv =\n\t\t\t(uint8_t)(data->lowest_uclk_reserved_for_ulv);\n\n\treturn result;\n}\n\nstatic int vega10_populate_single_display_type(struct pp_hwmgr *hwmgr,\n\t\tDSPCLK_e disp_clock)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)\n\t\t\t(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table;\n\tuint32_t i;\n\tuint16_t clk = 0, vddc = 0;\n\tuint8_t vid = 0;\n\n\tswitch (disp_clock) {\n\tcase DSPCLK_DCEFCLK:\n\t\tdep_table = table_info->vdd_dep_on_dcefclk;\n\t\tbreak;\n\tcase DSPCLK_DISPCLK:\n\t\tdep_table = table_info->vdd_dep_on_dispclk;\n\t\tbreak;\n\tcase DSPCLK_PIXCLK:\n\t\tdep_table = table_info->vdd_dep_on_pixclk;\n\t\tbreak;\n\tcase DSPCLK_PHYCLK:\n\t\tdep_table = table_info->vdd_dep_on_phyclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tPP_ASSERT_WITH_CODE(dep_table->count <= NUM_DSPCLK_LEVELS,\n\t\t\t\"Number Of Entries Exceeded maximum!\",\n\t\t\treturn -1);\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tclk = (uint16_t)(dep_table->entries[i].clk / 100);\n\t\tvddc = table_info->vddc_lookup_table->\n\t\t\t\tentries[dep_table->entries[i].vddInd].us_vdd;\n\t\tvid = (uint8_t)convert_to_vid(vddc);\n\t\tpp_table->DisplayClockTable[disp_clock][i].Freq =\n\t\t\t\tcpu_to_le16(clk);\n\t\tpp_table->DisplayClockTable[disp_clock][i].Vid =\n\t\t\t\tcpu_to_le16(vid);\n\t}\n\n\twhile (i < NUM_DSPCLK_LEVELS) {\n\t\tpp_table->DisplayClockTable[disp_clock][i].Freq =\n\t\t\t\tcpu_to_le16(clk);\n\t\tpp_table->DisplayClockTable[disp_clock][i].Vid =\n\t\t\t\tcpu_to_le16(vid);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_all_display_clock_levels(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < DSPCLK_COUNT; i++) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_populate_single_display_type(hwmgr, i),\n\t\t\t\t\"Failed to populate Clock in DisplayClockTable!\",\n\t\t\t\treturn -1);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_single_eclock_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t eclock, uint8_t *current_eclk_did,\n\t\tuint8_t *current_soc_vol)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->mm_dep_table;\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\tuint32_t i;\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(hwmgr,\n\t\t\tCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\teclock, &dividers),\n\t\t\t\"Failed to get ECLK clock settings from VBIOS!\",\n\t\t\treturn -1);\n\n\t*current_eclk_did = (uint8_t)dividers.ulDid;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (dep_table->entries[i].eclk == eclock)\n\t\t\t*current_soc_vol = dep_table->entries[i].vddcInd;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_smc_vce_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct vega10_single_dpm_table *dpm_table = &(data->dpm_table.eclk_table);\n\tint result = -EINVAL;\n\tuint32_t i, j;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tresult = vega10_populate_single_eclock_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[i].value,\n\t\t\t\t&(pp_table->EclkDid[i]),\n\t\t\t\t&(pp_table->VceDpmVoltageIndex[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_VCE_DPM_LEVELS) {\n\t\tresult = vega10_populate_single_eclock_level(hwmgr,\n\t\t\t\tdpm_table->dpm_levels[j].value,\n\t\t\t\t&(pp_table->EclkDid[i]),\n\t\t\t\t&(pp_table->VceDpmVoltageIndex[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t\ti++;\n\t}\n\n\treturn result;\n}\n\nstatic int vega10_populate_single_vclock_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t vclock, uint8_t *current_vclk_did)\n{\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(hwmgr,\n\t\t\tCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\tvclock, &dividers),\n\t\t\t\"Failed to get VCLK clock settings from VBIOS!\",\n\t\t\treturn -EINVAL);\n\n\t*current_vclk_did = (uint8_t)dividers.ulDid;\n\n\treturn 0;\n}\n\nstatic int vega10_populate_single_dclock_level(struct pp_hwmgr *hwmgr,\n\t\tuint32_t dclock, uint8_t *current_dclk_did)\n{\n\tstruct pp_atomfwctrl_clock_dividers_soc15 dividers;\n\n\tPP_ASSERT_WITH_CODE(!pp_atomfwctrl_get_gpu_pll_dividers_vega10(hwmgr,\n\t\t\tCOMPUTE_GPUCLK_INPUT_FLAG_DEFAULT_GPUCLK,\n\t\t\tdclock, &dividers),\n\t\t\t\"Failed to get DCLK clock settings from VBIOS!\",\n\t\t\treturn -EINVAL);\n\n\t*current_dclk_did = (uint8_t)dividers.ulDid;\n\n\treturn 0;\n}\n\nstatic int vega10_populate_smc_uvd_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct vega10_single_dpm_table *vclk_dpm_table =\n\t\t\t&(data->dpm_table.vclk_table);\n\tstruct vega10_single_dpm_table *dclk_dpm_table =\n\t\t\t&(data->dpm_table.dclk_table);\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_mm_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->mm_dep_table;\n\tint result = -EINVAL;\n\tuint32_t i, j;\n\n\tfor (i = 0; i < vclk_dpm_table->count; i++) {\n\t\tresult = vega10_populate_single_vclock_level(hwmgr,\n\t\t\t\tvclk_dpm_table->dpm_levels[i].value,\n\t\t\t\t&(pp_table->VclkDid[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_UVD_DPM_LEVELS) {\n\t\tresult = vega10_populate_single_vclock_level(hwmgr,\n\t\t\t\tvclk_dpm_table->dpm_levels[j].value,\n\t\t\t\t&(pp_table->VclkDid[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < dclk_dpm_table->count; i++) {\n\t\tresult = vega10_populate_single_dclock_level(hwmgr,\n\t\t\t\tdclk_dpm_table->dpm_levels[i].value,\n\t\t\t\t&(pp_table->DclkDid[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_UVD_DPM_LEVELS) {\n\t\tresult = vega10_populate_single_dclock_level(hwmgr,\n\t\t\t\tdclk_dpm_table->dpm_levels[j].value,\n\t\t\t\t&(pp_table->DclkDid[i]));\n\t\tif (result)\n\t\t\treturn result;\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (dep_table->entries[i].vclk ==\n\t\t\t\tvclk_dpm_table->dpm_levels[i].value &&\n\t\t\tdep_table->entries[i].dclk ==\n\t\t\t\tdclk_dpm_table->dpm_levels[i].value)\n\t\t\tpp_table->UvdDpmVoltageIndex[i] =\n\t\t\t\t\tdep_table->entries[i].vddcInd;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tj = i - 1;\n\twhile (i < NUM_UVD_DPM_LEVELS) {\n\t\tpp_table->UvdDpmVoltageIndex[i] = dep_table->entries[j].vddcInd;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_clock_stretcher_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->vdd_dep_on_sclk;\n\tuint32_t i;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tpp_table->CksEnable[i] = dep_table->entries[i].cks_enable;\n\t\tpp_table->CksVidOffset[i] = (uint8_t)(dep_table->entries[i].cks_voffset\n\t\t\t\t* VOLTAGE_VID_OFFSET_SCALE2 / VOLTAGE_VID_OFFSET_SCALE1);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_avfs_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->vdd_dep_on_sclk;\n\tstruct pp_atomfwctrl_avfs_parameters avfs_params = {0};\n\tint result = 0;\n\tuint32_t i;\n\n\tpp_table->MinVoltageVid = (uint8_t)0xff;\n\tpp_table->MaxVoltageVid = (uint8_t)0;\n\n\tif (data->smu_features[GNLD_AVFS].supported) {\n\t\tresult = pp_atomfwctrl_get_avfs_information(hwmgr, &avfs_params);\n\t\tif (!result) {\n\t\t\tpp_table->MinVoltageVid = (uint8_t)\n\t\t\t\t\tconvert_to_vid((uint16_t)(avfs_params.ulMinVddc));\n\t\t\tpp_table->MaxVoltageVid = (uint8_t)\n\t\t\t\t\tconvert_to_vid((uint16_t)(avfs_params.ulMaxVddc));\n\n\t\t\tpp_table->AConstant[0] = cpu_to_le32(avfs_params.ulMeanNsigmaAcontant0);\n\t\t\tpp_table->AConstant[1] = cpu_to_le32(avfs_params.ulMeanNsigmaAcontant1);\n\t\t\tpp_table->AConstant[2] = cpu_to_le32(avfs_params.ulMeanNsigmaAcontant2);\n\t\t\tpp_table->DC_tol_sigma = cpu_to_le16(avfs_params.usMeanNsigmaDcTolSigma);\n\t\t\tpp_table->Platform_mean = cpu_to_le16(avfs_params.usMeanNsigmaPlatformMean);\n\t\t\tpp_table->Platform_sigma = cpu_to_le16(avfs_params.usMeanNsigmaDcTolSigma);\n\t\t\tpp_table->PSM_Age_CompFactor = cpu_to_le16(avfs_params.usPsmAgeComfactor);\n\n\t\t\tpp_table->BtcGbVdroopTableCksOff.a0 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbVdroopTableCksoffA0);\n\t\t\tpp_table->BtcGbVdroopTableCksOff.a0_shift = 20;\n\t\t\tpp_table->BtcGbVdroopTableCksOff.a1 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbVdroopTableCksoffA1);\n\t\t\tpp_table->BtcGbVdroopTableCksOff.a1_shift = 20;\n\t\t\tpp_table->BtcGbVdroopTableCksOff.a2 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbVdroopTableCksoffA2);\n\t\t\tpp_table->BtcGbVdroopTableCksOff.a2_shift = 20;\n\n\t\t\tpp_table->OverrideBtcGbCksOn = avfs_params.ucEnableGbVdroopTableCkson;\n\t\t\tpp_table->BtcGbVdroopTableCksOn.a0 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbVdroopTableCksonA0);\n\t\t\tpp_table->BtcGbVdroopTableCksOn.a0_shift = 20;\n\t\t\tpp_table->BtcGbVdroopTableCksOn.a1 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbVdroopTableCksonA1);\n\t\t\tpp_table->BtcGbVdroopTableCksOn.a1_shift = 20;\n\t\t\tpp_table->BtcGbVdroopTableCksOn.a2 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbVdroopTableCksonA2);\n\t\t\tpp_table->BtcGbVdroopTableCksOn.a2_shift = 20;\n\n\t\t\tpp_table->AvfsGbCksOn.m1 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbFuseTableCksonM1);\n\t\t\tpp_table->AvfsGbCksOn.m2 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbFuseTableCksonM2);\n\t\t\tpp_table->AvfsGbCksOn.b =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbFuseTableCksonB);\n\t\t\tpp_table->AvfsGbCksOn.m1_shift = 24;\n\t\t\tpp_table->AvfsGbCksOn.m2_shift = 12;\n\t\t\tpp_table->AvfsGbCksOn.b_shift = 0;\n\n\t\t\tpp_table->OverrideAvfsGbCksOn =\n\t\t\t\t\tavfs_params.ucEnableGbFuseTableCkson;\n\t\t\tpp_table->AvfsGbCksOff.m1 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbFuseTableCksoffM1);\n\t\t\tpp_table->AvfsGbCksOff.m2 =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbFuseTableCksoffM2);\n\t\t\tpp_table->AvfsGbCksOff.b =\n\t\t\t\t\tcpu_to_le32(avfs_params.ulGbFuseTableCksoffB);\n\t\t\tpp_table->AvfsGbCksOff.m1_shift = 24;\n\t\t\tpp_table->AvfsGbCksOff.m2_shift = 12;\n\t\t\tpp_table->AvfsGbCksOff.b_shift = 0;\n\n\t\t\tfor (i = 0; i < dep_table->count; i++)\n\t\t\t\tpp_table->StaticVoltageOffsetVid[i] =\n\t\t\t\t\t\tconvert_to_vid((uint8_t)(dep_table->entries[i].sclk_offset));\n\n\t\t\tif ((PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->disp_clk_quad_eqn_a) &&\n\t\t\t\t(PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->disp_clk_quad_eqn_b)) {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].m1 =\n\t\t\t\t\t\t(int32_t)data->disp_clk_quad_eqn_a;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].m2 =\n\t\t\t\t\t\t(int32_t)data->disp_clk_quad_eqn_b;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].b =\n\t\t\t\t\t\t(int32_t)data->disp_clk_quad_eqn_c;\n\t\t\t} else {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].m1 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulDispclk2GfxclkM1;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].m2 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulDispclk2GfxclkM2;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].b =\n\t\t\t\t\t\t(int32_t)avfs_params.ulDispclk2GfxclkB;\n\t\t\t}\n\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].m1_shift = 24;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].m2_shift = 12;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DISPCLK].b_shift = 12;\n\n\t\t\tif ((PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->dcef_clk_quad_eqn_a) &&\n\t\t\t\t(PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->dcef_clk_quad_eqn_b)) {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].m1 =\n\t\t\t\t\t\t(int32_t)data->dcef_clk_quad_eqn_a;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].m2 =\n\t\t\t\t\t\t(int32_t)data->dcef_clk_quad_eqn_b;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].b =\n\t\t\t\t\t\t(int32_t)data->dcef_clk_quad_eqn_c;\n\t\t\t} else {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].m1 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulDcefclk2GfxclkM1;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].m2 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulDcefclk2GfxclkM2;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].b =\n\t\t\t\t\t\t(int32_t)avfs_params.ulDcefclk2GfxclkB;\n\t\t\t}\n\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].m1_shift = 24;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].m2_shift = 12;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_DCEFCLK].b_shift = 12;\n\n\t\t\tif ((PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->pixel_clk_quad_eqn_a) &&\n\t\t\t\t(PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->pixel_clk_quad_eqn_b)) {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].m1 =\n\t\t\t\t\t\t(int32_t)data->pixel_clk_quad_eqn_a;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].m2 =\n\t\t\t\t\t\t(int32_t)data->pixel_clk_quad_eqn_b;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].b =\n\t\t\t\t\t\t(int32_t)data->pixel_clk_quad_eqn_c;\n\t\t\t} else {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].m1 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulPixelclk2GfxclkM1;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].m2 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulPixelclk2GfxclkM2;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].b =\n\t\t\t\t\t\t(int32_t)avfs_params.ulPixelclk2GfxclkB;\n\t\t\t}\n\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].m1_shift = 24;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].m2_shift = 12;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PIXCLK].b_shift = 12;\n\t\t\tif ((PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->phy_clk_quad_eqn_a) &&\n\t\t\t\t(PPREGKEY_VEGA10QUADRATICEQUATION_DFLT !=\n\t\t\t\t\tdata->phy_clk_quad_eqn_b)) {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].m1 =\n\t\t\t\t\t\t(int32_t)data->phy_clk_quad_eqn_a;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].m2 =\n\t\t\t\t\t\t(int32_t)data->phy_clk_quad_eqn_b;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].b =\n\t\t\t\t\t\t(int32_t)data->phy_clk_quad_eqn_c;\n\t\t\t} else {\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].m1 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulPhyclk2GfxclkM1;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].m2 =\n\t\t\t\t\t\t(int32_t)avfs_params.ulPhyclk2GfxclkM2;\n\t\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].b =\n\t\t\t\t\t\t(int32_t)avfs_params.ulPhyclk2GfxclkB;\n\t\t\t}\n\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].m1_shift = 24;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].m2_shift = 12;\n\t\t\tpp_table->DisplayClock2Gfxclk[DSPCLK_PHYCLK].b_shift = 12;\n\n\t\t\tpp_table->AcgBtcGbVdroopTable.a0       = avfs_params.ulAcgGbVdroopTableA0;\n\t\t\tpp_table->AcgBtcGbVdroopTable.a0_shift = 20;\n\t\t\tpp_table->AcgBtcGbVdroopTable.a1       = avfs_params.ulAcgGbVdroopTableA1;\n\t\t\tpp_table->AcgBtcGbVdroopTable.a1_shift = 20;\n\t\t\tpp_table->AcgBtcGbVdroopTable.a2       = avfs_params.ulAcgGbVdroopTableA2;\n\t\t\tpp_table->AcgBtcGbVdroopTable.a2_shift = 20;\n\n\t\t\tpp_table->AcgAvfsGb.m1                   = avfs_params.ulAcgGbFuseTableM1;\n\t\t\tpp_table->AcgAvfsGb.m2                   = avfs_params.ulAcgGbFuseTableM2;\n\t\t\tpp_table->AcgAvfsGb.b                    = avfs_params.ulAcgGbFuseTableB;\n\t\t\tpp_table->AcgAvfsGb.m1_shift             = 24;\n\t\t\tpp_table->AcgAvfsGb.m2_shift             = 12;\n\t\t\tpp_table->AcgAvfsGb.b_shift              = 0;\n\n\t\t} else {\n\t\t\tdata->smu_features[GNLD_AVFS].supported = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_acg_enable(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t agc_btc_response;\n\n\tif (data->smu_features[GNLD_ACG].supported) {\n\t\tif (0 == vega10_enable_smc_features(hwmgr, true,\n\t\t\t\t\tdata->smu_features[GNLD_DPM_PREFETCHER].smu_feature_bitmap))\n\t\t\tdata->smu_features[GNLD_DPM_PREFETCHER].enabled = true;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_InitializeAcg, NULL);\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_RunAcgBtc, &agc_btc_response);\n\n\t\tif (1 == agc_btc_response) {\n\t\t\tif (1 == data->acg_loop_state)\n\t\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_RunAcgInClosedLoop, NULL);\n\t\t\telse if (2 == data->acg_loop_state)\n\t\t\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_RunAcgInOpenLoop, NULL);\n\t\t\tif (0 == vega10_enable_smc_features(hwmgr, true,\n\t\t\t\tdata->smu_features[GNLD_ACG].smu_feature_bitmap))\n\t\t\t\t\tdata->smu_features[GNLD_ACG].enabled = true;\n\t\t} else {\n\t\t\tpr_info(\"[ACG_Enable] ACG BTC Returned Failed Status!\\n\");\n\t\t\tdata->smu_features[GNLD_ACG].enabled = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_acg_disable(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_ACG].supported &&\n\t    data->smu_features[GNLD_ACG].enabled)\n\t\tif (!vega10_enable_smc_features(hwmgr, false,\n\t\t\tdata->smu_features[GNLD_ACG].smu_feature_bitmap))\n\t\t\tdata->smu_features[GNLD_ACG].enabled = false;\n\n\treturn 0;\n}\n\nstatic int vega10_populate_gpio_parameters(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct pp_atomfwctrl_gpio_parameters gpio_params = {0};\n\tint result;\n\n\tresult = pp_atomfwctrl_get_gpio_information(hwmgr, &gpio_params);\n\tif (!result) {\n\t\tif (PP_CAP(PHM_PlatformCaps_RegulatorHot) &&\n\t\t    data->registry_data.regulator_hot_gpio_support) {\n\t\t\tpp_table->VR0HotGpio = gpio_params.ucVR0HotGpio;\n\t\t\tpp_table->VR0HotPolarity = gpio_params.ucVR0HotPolarity;\n\t\t\tpp_table->VR1HotGpio = gpio_params.ucVR1HotGpio;\n\t\t\tpp_table->VR1HotPolarity = gpio_params.ucVR1HotPolarity;\n\t\t} else {\n\t\t\tpp_table->VR0HotGpio = 0;\n\t\t\tpp_table->VR0HotPolarity = 0;\n\t\t\tpp_table->VR1HotGpio = 0;\n\t\t\tpp_table->VR1HotPolarity = 0;\n\t\t}\n\n\t\tif (PP_CAP(PHM_PlatformCaps_AutomaticDCTransition) &&\n\t\t    data->registry_data.ac_dc_switch_gpio_support) {\n\t\t\tpp_table->AcDcGpio = gpio_params.ucAcDcGpio;\n\t\t\tpp_table->AcDcPolarity = gpio_params.ucAcDcPolarity;\n\t\t} else {\n\t\t\tpp_table->AcDcGpio = 0;\n\t\t\tpp_table->AcDcPolarity = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nstatic int vega10_avfs_enable(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_AVFS].supported) {\n\t\t \n\t\tif (!(enable ^ data->smu_features[GNLD_AVFS].enabled))\n\t\t\treturn 0;\n\n\t\tif (enable) {\n\t\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\t\ttrue,\n\t\t\t\t\tdata->smu_features[GNLD_AVFS].smu_feature_bitmap),\n\t\t\t\t\t\"[avfs_control] Attempt to Enable AVFS feature Failed!\",\n\t\t\t\t\treturn -1);\n\t\t\tdata->smu_features[GNLD_AVFS].enabled = true;\n\t\t} else {\n\t\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\t\tfalse,\n\t\t\t\t\tdata->smu_features[GNLD_AVFS].smu_feature_bitmap),\n\t\t\t\t\t\"[avfs_control] Attempt to Disable AVFS feature Failed!\",\n\t\t\t\t\treturn -1);\n\t\t\tdata->smu_features[GNLD_AVFS].enabled = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_update_avfs(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->need_update_dpm_table & DPMTABLE_OD_UPDATE_VDDC) {\n\t\tvega10_avfs_enable(hwmgr, false);\n\t} else if (data->need_update_dpm_table) {\n\t\tvega10_avfs_enable(hwmgr, false);\n\t\tvega10_avfs_enable(hwmgr, true);\n\t} else {\n\t\tvega10_avfs_enable(hwmgr, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_populate_and_upload_avfs_fuse_override(struct pp_hwmgr *hwmgr)\n{\n\tint result = 0;\n\n\tuint64_t serial_number = 0;\n\tuint32_t top32, bottom32;\n\tstruct phm_fuses_default fuse;\n\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tAvfsFuseOverride_t *avfs_fuse_table = &(data->smc_state_table.avfs_fuse_override_table);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumTop32, &top32);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ReadSerialNumBottom32, &bottom32);\n\n\tserial_number = ((uint64_t)bottom32 << 32) | top32;\n\n\tif (pp_override_get_default_fuse_value(serial_number, &fuse) == 0) {\n\t\tavfs_fuse_table->VFT0_b  = fuse.VFT0_b;\n\t\tavfs_fuse_table->VFT0_m1 = fuse.VFT0_m1;\n\t\tavfs_fuse_table->VFT0_m2 = fuse.VFT0_m2;\n\t\tavfs_fuse_table->VFT1_b  = fuse.VFT1_b;\n\t\tavfs_fuse_table->VFT1_m1 = fuse.VFT1_m1;\n\t\tavfs_fuse_table->VFT1_m2 = fuse.VFT1_m2;\n\t\tavfs_fuse_table->VFT2_b  = fuse.VFT2_b;\n\t\tavfs_fuse_table->VFT2_m1 = fuse.VFT2_m1;\n\t\tavfs_fuse_table->VFT2_m2 = fuse.VFT2_m2;\n\t\tresult = smum_smc_table_manager(hwmgr,  (uint8_t *)avfs_fuse_table,\n\t\t\t\t\t\tAVFSFUSETABLE, false);\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to upload FuseOVerride!\",\n\t\t\t);\n\t}\n\n\treturn result;\n}\n\nstatic void vega10_check_dpm_table_updated(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_odn_dpm_table *odn_table = &(data->odn_dpm_table);\n\tstruct phm_ppt_v2_information *table_info = hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *odn_dep_table;\n\tuint32_t i;\n\n\tdep_table = table_info->vdd_dep_on_mclk;\n\todn_dep_table = (struct phm_ppt_v1_clock_voltage_dependency_table *)&(odn_table->vdd_dep_on_mclk);\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (dep_table->entries[i].vddc != odn_dep_table->entries[i].vddc) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_VDDC | DPMTABLE_OD_UPDATE_MCLK;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdep_table = table_info->vdd_dep_on_sclk;\n\todn_dep_table = (struct phm_ppt_v1_clock_voltage_dependency_table *)&(odn_table->vdd_dep_on_sclk);\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (dep_table->entries[i].vddc != odn_dep_table->entries[i].vddc) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_VDDC | DPMTABLE_OD_UPDATE_SCLK;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n \nstatic int vega10_init_smc_table(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct pp_atomfwctrl_voltage_table voltage_table;\n\tstruct pp_atomfwctrl_bios_boot_up_values boot_up_values;\n\tstruct vega10_odn_dpm_table *odn_table = &(data->odn_dpm_table);\n\n\tresult = vega10_setup_default_dpm_tables(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to setup default DPM tables!\",\n\t\t\treturn result);\n\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\t \n\tif (hwmgr->od_enabled) {\n\t\tif (odn_table->max_vddc) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_OD_UPDATE_MCLK;\n\t\t\tvega10_check_dpm_table_updated(hwmgr);\n\t\t} else {\n\t\t\tvega10_odn_initial_default_setting(hwmgr);\n\t\t}\n\t}\n\n\tpp_atomfwctrl_get_voltage_table_v4(hwmgr, VOLTAGE_TYPE_VDDC,\n\t\t\tVOLTAGE_OBJ_SVID2,  &voltage_table);\n\tpp_table->MaxVidStep = voltage_table.max_vid_step;\n\n\tpp_table->GfxDpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_gfx_dpm_voltage_mode);\n\tpp_table->SocDpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_soc_dpm_voltage_mode);\n\tpp_table->UclkDpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_uclk_dpm_voltage_mode);\n\tpp_table->UvdDpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_uvd_dpm_voltage_mode);\n\tpp_table->VceDpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_vce_dpm_voltage_mode);\n\tpp_table->Mp0DpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_mp0_dpm_voltage_mode);\n\n\tpp_table->DisplayDpmVoltageMode =\n\t\t\t(uint8_t)(table_info->uc_dcef_dpm_voltage_mode);\n\n\tdata->vddc_voltage_table.psi0_enable = voltage_table.psi0_enable;\n\tdata->vddc_voltage_table.psi1_enable = voltage_table.psi1_enable;\n\n\tif (data->registry_data.ulv_support &&\n\t\t\ttable_info->us_ulv_voltage_offset) {\n\t\tresult = vega10_populate_ulv_state(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"Failed to initialize ULV state!\",\n\t\t\t\treturn result);\n\t}\n\n\tresult = vega10_populate_smc_link_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize Link Level!\",\n\t\t\treturn result);\n\n\tresult = vega10_override_pcie_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to override pcie parameters!\",\n\t\t\treturn result);\n\n\tresult = vega10_populate_all_graphic_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize Graphics Level!\",\n\t\t\treturn result);\n\n\tresult = vega10_populate_all_memory_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize Memory Level!\",\n\t\t\treturn result);\n\n\tvega10_populate_vddc_soc_levels(hwmgr);\n\n\tresult = vega10_populate_all_display_clock_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize Display Level!\",\n\t\t\treturn result);\n\n\tresult = vega10_populate_smc_vce_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize VCE Level!\",\n\t\t\treturn result);\n\n\tresult = vega10_populate_smc_uvd_levels(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize UVD Level!\",\n\t\t\treturn result);\n\n\tif (data->registry_data.clock_stretcher_support) {\n\t\tresult = vega10_populate_clock_stretcher_table(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\t\"Failed to populate Clock Stretcher Table!\",\n\t\t\t\treturn result);\n\t}\n\n\tresult = pp_atomfwctrl_get_vbios_bootup_values(hwmgr, &boot_up_values);\n\tif (!result) {\n\t\tdata->vbios_boot_state.vddc     = boot_up_values.usVddc;\n\t\tdata->vbios_boot_state.vddci    = boot_up_values.usVddci;\n\t\tdata->vbios_boot_state.mvddc    = boot_up_values.usMvddc;\n\t\tdata->vbios_boot_state.gfx_clock = boot_up_values.ulGfxClk;\n\t\tdata->vbios_boot_state.mem_clock = boot_up_values.ulUClk;\n\t\tpp_atomfwctrl_get_clk_information_by_clkid(hwmgr,\n\t\t\t\tSMU9_SYSPLL0_SOCCLK_ID, 0, &boot_up_values.ulSocClk);\n\n\t\tpp_atomfwctrl_get_clk_information_by_clkid(hwmgr,\n\t\t\t\tSMU9_SYSPLL0_DCEFCLK_ID, 0, &boot_up_values.ulDCEFClk);\n\n\t\tdata->vbios_boot_state.soc_clock = boot_up_values.ulSocClk;\n\t\tdata->vbios_boot_state.dcef_clock = boot_up_values.ulDCEFClk;\n\t\tif (0 != boot_up_values.usVddc) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetFloorSocVoltage,\n\t\t\t\t\t\t(boot_up_values.usVddc * 4),\n\t\t\t\t\t\tNULL);\n\t\t\tdata->vbios_boot_state.bsoc_vddc_lock = true;\n\t\t} else {\n\t\t\tdata->vbios_boot_state.bsoc_vddc_lock = false;\n\t\t}\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetMinDeepSleepDcefclk,\n\t\t\t(uint32_t)(data->vbios_boot_state.dcef_clock / 100),\n\t\t\t\tNULL);\n\t}\n\n\tresult = vega10_populate_avfs_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize AVFS Parameters!\",\n\t\t\treturn result);\n\n\tresult = vega10_populate_gpio_parameters(hwmgr);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to initialize GPIO Parameters!\",\n\t\t\treturn result);\n\n\tpp_table->GfxclkAverageAlpha = (uint8_t)\n\t\t\t(data->gfxclk_average_alpha);\n\tpp_table->SocclkAverageAlpha = (uint8_t)\n\t\t\t(data->socclk_average_alpha);\n\tpp_table->UclkAverageAlpha = (uint8_t)\n\t\t\t(data->uclk_average_alpha);\n\tpp_table->GfxActivityAverageAlpha = (uint8_t)\n\t\t\t(data->gfx_activity_average_alpha);\n\n\tvega10_populate_and_upload_avfs_fuse_override(hwmgr);\n\n\tresult = smum_smc_table_manager(hwmgr, (uint8_t *)pp_table, PPTABLE, false);\n\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to upload PPtable!\", return result);\n\n\tresult = vega10_avfs_enable(hwmgr, true);\n\tPP_ASSERT_WITH_CODE(!result, \"Attempt to enable AVFS feature Failed!\",\n\t\t\t\t\treturn result);\n\tvega10_acg_enable(hwmgr);\n\n\treturn 0;\n}\n\nstatic int vega10_enable_thermal_protection(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_THERMAL].supported) {\n\t\tif (data->smu_features[GNLD_THERMAL].enabled)\n\t\t\tpr_info(\"THERMAL Feature Already enabled!\");\n\n\t\tPP_ASSERT_WITH_CODE(\n\t\t\t\t!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue,\n\t\t\t\tdata->smu_features[GNLD_THERMAL].smu_feature_bitmap),\n\t\t\t\t\"Enable THERMAL Feature Failed!\",\n\t\t\t\treturn -1);\n\t\tdata->smu_features[GNLD_THERMAL].enabled = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_disable_thermal_protection(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_THERMAL].supported) {\n\t\tif (!data->smu_features[GNLD_THERMAL].enabled)\n\t\t\tpr_info(\"THERMAL Feature Already disabled!\");\n\n\t\tPP_ASSERT_WITH_CODE(\n\t\t\t\t!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse,\n\t\t\t\tdata->smu_features[GNLD_THERMAL].smu_feature_bitmap),\n\t\t\t\t\"disable THERMAL Feature Failed!\",\n\t\t\t\treturn -1);\n\t\tdata->smu_features[GNLD_THERMAL].enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_enable_vrhot_feature(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (PP_CAP(PHM_PlatformCaps_RegulatorHot)) {\n\t\tif (data->smu_features[GNLD_VR0HOT].supported) {\n\t\t\tPP_ASSERT_WITH_CODE(\n\t\t\t\t\t!vega10_enable_smc_features(hwmgr,\n\t\t\t\t\ttrue,\n\t\t\t\t\tdata->smu_features[GNLD_VR0HOT].smu_feature_bitmap),\n\t\t\t\t\t\"Attempt to Enable VR0 Hot feature Failed!\",\n\t\t\t\t\treturn -1);\n\t\t\tdata->smu_features[GNLD_VR0HOT].enabled = true;\n\t\t} else {\n\t\t\tif (data->smu_features[GNLD_VR1HOT].supported) {\n\t\t\t\tPP_ASSERT_WITH_CODE(\n\t\t\t\t\t\t!vega10_enable_smc_features(hwmgr,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tdata->smu_features[GNLD_VR1HOT].smu_feature_bitmap),\n\t\t\t\t\t\t\"Attempt to Enable VR0 Hot feature Failed!\",\n\t\t\t\t\t\treturn -1);\n\t\t\t\tdata->smu_features[GNLD_VR1HOT].enabled = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int vega10_enable_ulv(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->registry_data.ulv_support) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue, data->smu_features[GNLD_ULV].smu_feature_bitmap),\n\t\t\t\t\"Enable ULV Feature Failed!\",\n\t\t\t\treturn -1);\n\t\tdata->smu_features[GNLD_ULV].enabled = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_disable_ulv(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->registry_data.ulv_support) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_ULV].smu_feature_bitmap),\n\t\t\t\t\"disable ULV Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_ULV].enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_enable_deep_sleep_master_switch(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_DS_GFXCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue, data->smu_features[GNLD_DS_GFXCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable DS_GFXCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_GFXCLK].enabled = true;\n\t}\n\n\tif (data->smu_features[GNLD_DS_SOCCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue, data->smu_features[GNLD_DS_SOCCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable DS_SOCCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_SOCCLK].enabled = true;\n\t}\n\n\tif (data->smu_features[GNLD_DS_LCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue, data->smu_features[GNLD_DS_LCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable DS_LCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_LCLK].enabled = true;\n\t}\n\n\tif (data->smu_features[GNLD_DS_DCEFCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue, data->smu_features[GNLD_DS_DCEFCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable DS_DCEFCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_DCEFCLK].enabled = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_disable_deep_sleep_master_switch(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_DS_GFXCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_DS_GFXCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to disable DS_GFXCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_GFXCLK].enabled = false;\n\t}\n\n\tif (data->smu_features[GNLD_DS_SOCCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_DS_SOCCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to disable DS_ Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_SOCCLK].enabled = false;\n\t}\n\n\tif (data->smu_features[GNLD_DS_LCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_DS_LCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to disable DS_LCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_LCLK].enabled = false;\n\t}\n\n\tif (data->smu_features[GNLD_DS_DCEFCLK].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_DS_DCEFCLK].smu_feature_bitmap),\n\t\t\t\t\"Attempt to disable DS_DCEFCLK Feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_DS_DCEFCLK].enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_stop_dpm(struct pp_hwmgr *hwmgr, uint32_t bitmap)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t i, feature_mask = 0;\n\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tif(data->smu_features[GNLD_LED_DISPLAY].supported == true){\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_LED_DISPLAY].smu_feature_bitmap),\n\t\t\"Attempt to disable LED DPM feature failed!\", return -EINVAL);\n\t\tdata->smu_features[GNLD_LED_DISPLAY].enabled = false;\n\t}\n\n\tfor (i = 0; i < GNLD_DPM_MAX; i++) {\n\t\tif (data->smu_features[i].smu_feature_bitmap & bitmap) {\n\t\t\tif (data->smu_features[i].supported) {\n\t\t\t\tif (data->smu_features[i].enabled) {\n\t\t\t\t\tfeature_mask |= data->smu_features[i].\n\t\t\t\t\t\t\tsmu_feature_bitmap;\n\t\t\t\t\tdata->smu_features[i].enabled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvega10_enable_smc_features(hwmgr, false, feature_mask);\n\n\treturn 0;\n}\n\n \nstatic int vega10_start_dpm(struct pp_hwmgr *hwmgr, uint32_t bitmap)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t i, feature_mask = 0;\n\n\tfor (i = 0; i < GNLD_DPM_MAX; i++) {\n\t\tif (data->smu_features[i].smu_feature_bitmap & bitmap) {\n\t\t\tif (data->smu_features[i].supported) {\n\t\t\t\tif (!data->smu_features[i].enabled) {\n\t\t\t\t\tfeature_mask |= data->smu_features[i].\n\t\t\t\t\t\t\tsmu_feature_bitmap;\n\t\t\t\t\tdata->smu_features[i].enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vega10_enable_smc_features(hwmgr,\n\t\t\ttrue, feature_mask)) {\n\t\tfor (i = 0; i < GNLD_DPM_MAX; i++) {\n\t\t\tif (data->smu_features[i].smu_feature_bitmap &\n\t\t\t\t\tfeature_mask)\n\t\t\t\tdata->smu_features[i].enabled = false;\n\t\t}\n\t}\n\n\tif(data->smu_features[GNLD_LED_DISPLAY].supported == true){\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\ttrue, data->smu_features[GNLD_LED_DISPLAY].smu_feature_bitmap),\n\t\t\"Attempt to Enable LED DPM feature Failed!\", return -EINVAL);\n\t\tdata->smu_features[GNLD_LED_DISPLAY].enabled = true;\n\t}\n\n\tif (data->vbios_boot_state.bsoc_vddc_lock) {\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetFloorSocVoltage, 0,\n\t\t\t\t\t\tNULL);\n\t\tdata->vbios_boot_state.bsoc_vddc_lock = false;\n\t}\n\n\tif (PP_CAP(PHM_PlatformCaps_Falcon_QuickTransition)) {\n\t\tif (data->smu_features[GNLD_ACDC].supported) {\n\t\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\t\ttrue, data->smu_features[GNLD_ACDC].smu_feature_bitmap),\n\t\t\t\t\t\"Attempt to Enable DS_GFXCLK Feature Failed!\",\n\t\t\t\t\treturn -1);\n\t\t\tdata->smu_features[GNLD_ACDC].enabled = true;\n\t\t}\n\t}\n\n\tif (data->registry_data.pcie_dpm_key_disabled) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tfalse, data->smu_features[GNLD_DPM_LINK].smu_feature_bitmap),\n\t\t\"Attempt to Disable Link DPM feature Failed!\", return -EINVAL);\n\t\tdata->smu_features[GNLD_DPM_LINK].enabled = false;\n\t\tdata->smu_features[GNLD_DPM_LINK].supported = false;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int vega10_enable_disable_PCC_limit_feature(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_PCC_LIMIT].supported) {\n\t\tif (enable == data->smu_features[GNLD_PCC_LIMIT].enabled)\n\t\t\tpr_info(\"GNLD_PCC_LIMIT has been %s \\n\", enable ? \"enabled\" : \"disabled\");\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tenable, data->smu_features[GNLD_PCC_LIMIT].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable PCC Limit feature Failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tdata->smu_features[GNLD_PCC_LIMIT].enabled = enable;\n\t}\n\n\treturn 0;\n}\n\nstatic void vega10_populate_umdpstate_clocks(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tif (table_info->vdd_dep_on_sclk->count > VEGA10_UMD_PSTATE_GFXCLK_LEVEL &&\n\t    table_info->vdd_dep_on_mclk->count > VEGA10_UMD_PSTATE_MCLK_LEVEL) {\n\t\thwmgr->pstate_sclk = table_info->vdd_dep_on_sclk->entries[VEGA10_UMD_PSTATE_GFXCLK_LEVEL].clk;\n\t\thwmgr->pstate_mclk = table_info->vdd_dep_on_mclk->entries[VEGA10_UMD_PSTATE_MCLK_LEVEL].clk;\n\t} else {\n\t\thwmgr->pstate_sclk = table_info->vdd_dep_on_sclk->entries[0].clk;\n\t\thwmgr->pstate_mclk = table_info->vdd_dep_on_mclk->entries[0].clk;\n\t}\n\n\thwmgr->pstate_sclk_peak = table_info->vdd_dep_on_sclk->entries[table_info->vdd_dep_on_sclk->count - 1].clk;\n\thwmgr->pstate_mclk_peak = table_info->vdd_dep_on_mclk->entries[table_info->vdd_dep_on_mclk->count - 1].clk;\n\n\t \n\thwmgr->pstate_sclk /= 100;\n\thwmgr->pstate_mclk /= 100;\n\thwmgr->pstate_sclk_peak /= 100;\n\thwmgr->pstate_mclk_peak /= 100;\n}\n\nstatic int vega10_enable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tint tmp_result, result = 0;\n\n\tif (hwmgr->not_vf) {\n\t\tvega10_enable_disable_PCC_limit_feature(hwmgr, true);\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_ConfigureTelemetry, data->config_telemetry,\n\t\t\tNULL);\n\n\t\ttmp_result = vega10_construct_voltage_tables(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to construct voltage tables!\",\n\t\t\t\t    result = tmp_result);\n\t}\n\n\tif (hwmgr->not_vf || hwmgr->pp_one_vf) {\n\t\ttmp_result = vega10_init_smc_table(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to initialize SMC table!\",\n\t\t\t\t    result = tmp_result);\n\t}\n\n\tif (hwmgr->not_vf) {\n\t\tif (PP_CAP(PHM_PlatformCaps_ThermalController)) {\n\t\t\ttmp_result = vega10_enable_thermal_protection(hwmgr);\n\t\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t\t    \"Failed to enable thermal protection!\",\n\t\t\t\t\t    result = tmp_result);\n\t\t}\n\n\t\ttmp_result = vega10_enable_vrhot_feature(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to enable VR hot feature!\",\n\t\t\t\t    result = tmp_result);\n\n\t\ttmp_result = vega10_enable_deep_sleep_master_switch(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to enable deep sleep master switch!\",\n\t\t\t\t    result = tmp_result);\n\t}\n\n\tif (hwmgr->not_vf) {\n\t\ttmp_result = vega10_start_dpm(hwmgr, SMC_DPM_FEATURES);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to start DPM!\", result = tmp_result);\n\t}\n\n\tif (hwmgr->not_vf) {\n\t\t \n\t\ttmp_result = vega10_enable_didt_config(hwmgr);\n\t\tPP_ASSERT(!tmp_result,\n\t\t\t  \"Failed to enable didt config!\");\n\t}\n\n\ttmp_result = vega10_enable_power_containment(hwmgr);\n\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t    \"Failed to enable power containment!\",\n\t\t\t    result = tmp_result);\n\n\tif (hwmgr->not_vf) {\n\t\ttmp_result = vega10_power_control_set_level(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to power control set level!\",\n\t\t\t\t    result = tmp_result);\n\n\t\ttmp_result = vega10_enable_ulv(hwmgr);\n\t\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\t    \"Failed to enable ULV!\",\n\t\t\t\t    result = tmp_result);\n\t}\n\n\tvega10_populate_umdpstate_clocks(hwmgr);\n\n\treturn result;\n}\n\nstatic int vega10_get_power_state_size(struct pp_hwmgr *hwmgr)\n{\n\treturn sizeof(struct vega10_power_state);\n}\n\nstatic int vega10_get_pp_table_entry_callback_func(struct pp_hwmgr *hwmgr,\n\t\tvoid *state, struct pp_power_state *power_state,\n\t\tvoid *pp_table, uint32_t classification_flag)\n{\n\tATOM_Vega10_GFXCLK_Dependency_Record_V2 *patom_record_V2;\n\tstruct vega10_power_state *vega10_ps =\n\t\t\tcast_phw_vega10_power_state(&(power_state->hardware));\n\tstruct vega10_performance_level *performance_level;\n\tATOM_Vega10_State *state_entry = (ATOM_Vega10_State *)state;\n\tATOM_Vega10_POWERPLAYTABLE *powerplay_table =\n\t\t\t(ATOM_Vega10_POWERPLAYTABLE *)pp_table;\n\tATOM_Vega10_SOCCLK_Dependency_Table *socclk_dep_table =\n\t\t\t(ATOM_Vega10_SOCCLK_Dependency_Table *)\n\t\t\t(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usSocclkDependencyTableOffset));\n\tATOM_Vega10_GFXCLK_Dependency_Table *gfxclk_dep_table =\n\t\t\t(ATOM_Vega10_GFXCLK_Dependency_Table *)\n\t\t\t(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usGfxclkDependencyTableOffset));\n\tATOM_Vega10_MCLK_Dependency_Table *mclk_dep_table =\n\t\t\t(ATOM_Vega10_MCLK_Dependency_Table *)\n\t\t\t(((unsigned long)powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table->usMclkDependencyTableOffset));\n\n\n\t \n\tpower_state->classification.ui_label =\n\t\t\t(le16_to_cpu(state_entry->usClassification) &\n\t\t\tATOM_PPLIB_CLASSIFICATION_UI_MASK) >>\n\t\t\tATOM_PPLIB_CLASSIFICATION_UI_SHIFT;\n\tpower_state->classification.flags = classification_flag;\n\t \n\tpower_state->classification.temporary_state = false;\n\tpower_state->classification.to_be_deleted = false;\n\n\tpower_state->validation.disallowOnDC =\n\t\t\t((le32_to_cpu(state_entry->ulCapsAndSettings) &\n\t\t\t\t\tATOM_Vega10_DISALLOW_ON_DC) != 0);\n\n\tpower_state->display.disableFrameModulation = false;\n\tpower_state->display.limitRefreshrate = false;\n\tpower_state->display.enableVariBright =\n\t\t\t((le32_to_cpu(state_entry->ulCapsAndSettings) &\n\t\t\t\t\tATOM_Vega10_ENABLE_VARIBRIGHT) != 0);\n\n\tpower_state->validation.supportedPowerLevels = 0;\n\tpower_state->uvd_clocks.VCLK = 0;\n\tpower_state->uvd_clocks.DCLK = 0;\n\tpower_state->temperatures.min = 0;\n\tpower_state->temperatures.max = 0;\n\n\tperformance_level = &(vega10_ps->performance_levels\n\t\t\t[vega10_ps->performance_level_count++]);\n\n\tPP_ASSERT_WITH_CODE(\n\t\t\t(vega10_ps->performance_level_count <\n\t\t\t\t\tNUM_GFXCLK_DPM_LEVELS),\n\t\t\t\"Performance levels exceeds SMC limit!\",\n\t\t\treturn -1);\n\n\tPP_ASSERT_WITH_CODE(\n\t\t\t(vega10_ps->performance_level_count <\n\t\t\t\t\thwmgr->platform_descriptor.\n\t\t\t\t\thardwareActivityPerformanceLevels),\n\t\t\t\"Performance levels exceeds Driver limit!\",\n\t\t\treturn -1);\n\n\t \n\tperformance_level->soc_clock = socclk_dep_table->entries\n\t\t\t[state_entry->ucSocClockIndexLow].ulClk;\n\tperformance_level->gfx_clock = gfxclk_dep_table->entries\n\t\t\t[state_entry->ucGfxClockIndexLow].ulClk;\n\tperformance_level->mem_clock = mclk_dep_table->entries\n\t\t\t[state_entry->ucMemClockIndexLow].ulMemClk;\n\n\tperformance_level = &(vega10_ps->performance_levels\n\t\t\t\t[vega10_ps->performance_level_count++]);\n\tperformance_level->soc_clock = socclk_dep_table->entries\n\t\t\t\t[state_entry->ucSocClockIndexHigh].ulClk;\n\tif (gfxclk_dep_table->ucRevId == 0) {\n\t\t \n\t\tif (hwmgr->pp_one_vf && (state_entry->ucGfxClockIndexHigh > 0))\n\t\t\tperformance_level->gfx_clock =\n\t\t\t\tgfxclk_dep_table->entries[4].ulClk;\n\t\telse\n\t\t\tperformance_level->gfx_clock = gfxclk_dep_table->entries\n\t\t\t\t[state_entry->ucGfxClockIndexHigh].ulClk;\n\t} else if (gfxclk_dep_table->ucRevId == 1) {\n\t\tpatom_record_V2 = (ATOM_Vega10_GFXCLK_Dependency_Record_V2 *)gfxclk_dep_table->entries;\n\t\tif (hwmgr->pp_one_vf && (state_entry->ucGfxClockIndexHigh > 0))\n\t\t\tperformance_level->gfx_clock = patom_record_V2[4].ulClk;\n\t\telse\n\t\t\tperformance_level->gfx_clock =\n\t\t\t\tpatom_record_V2[state_entry->ucGfxClockIndexHigh].ulClk;\n\t}\n\n\tperformance_level->mem_clock = mclk_dep_table->entries\n\t\t\t[state_entry->ucMemClockIndexHigh].ulMemClk;\n\treturn 0;\n}\n\nstatic int vega10_get_pp_table_entry(struct pp_hwmgr *hwmgr,\n\t\tunsigned long entry_index, struct pp_power_state *state)\n{\n\tint result;\n\tstruct vega10_power_state *vega10_ps;\n\n\tstate->hardware.magic = PhwVega10_Magic;\n\n\tvega10_ps = cast_phw_vega10_power_state(&state->hardware);\n\n\tresult = vega10_get_powerplay_table_entry(hwmgr, entry_index, state,\n\t\t\tvega10_get_pp_table_entry_callback_func);\n\tif (result)\n\t\treturn result;\n\n\t \n\t \n\tif (!state->validation.disallowOnDC)\n\t\tvega10_ps->dc_compatible = true;\n\n\tvega10_ps->uvd_clks.vclk = state->uvd_clocks.VCLK;\n\tvega10_ps->uvd_clks.dclk = state->uvd_clocks.DCLK;\n\n\treturn 0;\n}\n\nstatic int vega10_patch_boot_state(struct pp_hwmgr *hwmgr,\n\t     struct pp_hw_power_state *hw_ps)\n{\n\treturn 0;\n}\n\nstatic int vega10_apply_state_adjust_rules(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct pp_power_state  *request_ps,\n\t\t\tconst struct pp_power_state *current_ps)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct vega10_power_state *vega10_ps =\n\t\t\t\tcast_phw_vega10_power_state(&request_ps->hardware);\n\tuint32_t sclk;\n\tuint32_t mclk;\n\tstruct PP_Clocks minimum_clocks = {0};\n\tbool disable_mclk_switching;\n\tbool disable_mclk_switching_for_frame_lock;\n\tbool disable_mclk_switching_for_vr;\n\tbool force_mclk_high;\n\tconst struct phm_clock_and_voltage_limits *max_limits;\n\tuint32_t i;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tint32_t count;\n\tuint32_t stable_pstate_sclk_dpm_percentage;\n\tuint32_t stable_pstate_sclk = 0, stable_pstate_mclk = 0;\n\tuint32_t latency;\n\n\tdata->battery_state = (PP_StateUILabel_Battery ==\n\t\t\trequest_ps->classification.ui_label);\n\n\tif (vega10_ps->performance_level_count != 2)\n\t\tpr_info(\"VI should always have 2 performance levels\");\n\n\tmax_limits = adev->pm.ac_power ?\n\t\t\t&(hwmgr->dyn_state.max_clock_voltage_on_ac) :\n\t\t\t&(hwmgr->dyn_state.max_clock_voltage_on_dc);\n\n\t \n\tif (!adev->pm.ac_power) {\n\t\tfor (i = 0; i < vega10_ps->performance_level_count; i++) {\n\t\t\tif (vega10_ps->performance_levels[i].mem_clock >\n\t\t\t\tmax_limits->mclk)\n\t\t\t\tvega10_ps->performance_levels[i].mem_clock =\n\t\t\t\t\t\tmax_limits->mclk;\n\t\t\tif (vega10_ps->performance_levels[i].gfx_clock >\n\t\t\t\tmax_limits->sclk)\n\t\t\t\tvega10_ps->performance_levels[i].gfx_clock =\n\t\t\t\t\t\tmax_limits->sclk;\n\t\t}\n\t}\n\n\t \n\tminimum_clocks.engineClock = hwmgr->display_config->min_core_set_clock;\n\tminimum_clocks.memoryClock = hwmgr->display_config->min_mem_set_clock;\n\n\tif (PP_CAP(PHM_PlatformCaps_StablePState)) {\n\t\tstable_pstate_sclk_dpm_percentage =\n\t\t\tdata->registry_data.stable_pstate_sclk_dpm_percentage;\n\t\tPP_ASSERT_WITH_CODE(\n\t\t\tdata->registry_data.stable_pstate_sclk_dpm_percentage >= 1 &&\n\t\t\tdata->registry_data.stable_pstate_sclk_dpm_percentage <= 100,\n\t\t\t\"percent sclk value must range from 1% to 100%, setting default value\",\n\t\t\tstable_pstate_sclk_dpm_percentage = 75);\n\n\t\tmax_limits = &(hwmgr->dyn_state.max_clock_voltage_on_ac);\n\t\tstable_pstate_sclk = (max_limits->sclk *\n\t\t\t\tstable_pstate_sclk_dpm_percentage) / 100;\n\n\t\tfor (count = table_info->vdd_dep_on_sclk->count - 1;\n\t\t\t\tcount >= 0; count--) {\n\t\t\tif (stable_pstate_sclk >=\n\t\t\t\t\ttable_info->vdd_dep_on_sclk->entries[count].clk) {\n\t\t\t\tstable_pstate_sclk =\n\t\t\t\t\t\ttable_info->vdd_dep_on_sclk->entries[count].clk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (count < 0)\n\t\t\tstable_pstate_sclk = table_info->vdd_dep_on_sclk->entries[0].clk;\n\n\t\tstable_pstate_mclk = max_limits->mclk;\n\n\t\tminimum_clocks.engineClock = stable_pstate_sclk;\n\t\tminimum_clocks.memoryClock = stable_pstate_mclk;\n\t}\n\n\tdisable_mclk_switching_for_frame_lock =\n\t\tPP_CAP(PHM_PlatformCaps_DisableMclkSwitchingForFrameLock);\n\tdisable_mclk_switching_for_vr =\n\t\tPP_CAP(PHM_PlatformCaps_DisableMclkSwitchForVR);\n\tforce_mclk_high = PP_CAP(PHM_PlatformCaps_ForceMclkHigh);\n\n\tif (hwmgr->display_config->num_display == 0)\n\t\tdisable_mclk_switching = false;\n\telse\n\t\tdisable_mclk_switching = ((1 < hwmgr->display_config->num_display) &&\n\t\t\t\t\t  !hwmgr->display_config->multi_monitor_in_sync) ||\n\t\t\tdisable_mclk_switching_for_frame_lock ||\n\t\t\tdisable_mclk_switching_for_vr ||\n\t\t\tforce_mclk_high;\n\n\tsclk = vega10_ps->performance_levels[0].gfx_clock;\n\tmclk = vega10_ps->performance_levels[0].mem_clock;\n\n\tif (sclk < minimum_clocks.engineClock)\n\t\tsclk = (minimum_clocks.engineClock > max_limits->sclk) ?\n\t\t\t\tmax_limits->sclk : minimum_clocks.engineClock;\n\n\tif (mclk < minimum_clocks.memoryClock)\n\t\tmclk = (minimum_clocks.memoryClock > max_limits->mclk) ?\n\t\t\t\tmax_limits->mclk : minimum_clocks.memoryClock;\n\n\tvega10_ps->performance_levels[0].gfx_clock = sclk;\n\tvega10_ps->performance_levels[0].mem_clock = mclk;\n\n\tif (vega10_ps->performance_levels[1].gfx_clock <\n\t\t\tvega10_ps->performance_levels[0].gfx_clock)\n\t\tvega10_ps->performance_levels[0].gfx_clock =\n\t\t\t\tvega10_ps->performance_levels[1].gfx_clock;\n\n\tif (disable_mclk_switching) {\n\t\t \n\t\tif (mclk < vega10_ps->performance_levels[1].mem_clock)\n\t\t\tmclk = vega10_ps->performance_levels[1].mem_clock;\n\n\t\t \n\t\tlatency = hwmgr->display_config->dce_tolerable_mclk_in_active_latency;\n\t\tfor (i = 0; i < data->mclk_latency_table.count; i++) {\n\t\t\tif ((data->mclk_latency_table.entries[i].latency <= latency) &&\n\t\t\t\t(data->mclk_latency_table.entries[i].frequency >=\n\t\t\t\t\t\tvega10_ps->performance_levels[0].mem_clock) &&\n\t\t\t\t(data->mclk_latency_table.entries[i].frequency <=\n\t\t\t\t\t\tvega10_ps->performance_levels[1].mem_clock))\n\t\t\t\tmclk = data->mclk_latency_table.entries[i].frequency;\n\t\t}\n\t\tvega10_ps->performance_levels[0].mem_clock = mclk;\n\t} else {\n\t\tif (vega10_ps->performance_levels[1].mem_clock <\n\t\t\t\tvega10_ps->performance_levels[0].mem_clock)\n\t\t\tvega10_ps->performance_levels[0].mem_clock =\n\t\t\t\t\tvega10_ps->performance_levels[1].mem_clock;\n\t}\n\n\tif (PP_CAP(PHM_PlatformCaps_StablePState)) {\n\t\tfor (i = 0; i < vega10_ps->performance_level_count; i++) {\n\t\t\tvega10_ps->performance_levels[i].gfx_clock = stable_pstate_sclk;\n\t\t\tvega10_ps->performance_levels[i].mem_clock = stable_pstate_mclk;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_find_dpm_states_clocks_in_dpm_table(struct pp_hwmgr *hwmgr, const void *input)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tconst struct phm_set_power_state_input *states =\n\t\t\t(const struct phm_set_power_state_input *)input;\n\tconst struct vega10_power_state *vega10_ps =\n\t\t\tcast_const_phw_vega10_power_state(states->pnew_state);\n\tstruct vega10_single_dpm_table *sclk_table = &(data->dpm_table.gfx_table);\n\tuint32_t sclk = vega10_ps->performance_levels\n\t\t\t[vega10_ps->performance_level_count - 1].gfx_clock;\n\tstruct vega10_single_dpm_table *mclk_table = &(data->dpm_table.mem_table);\n\tuint32_t mclk = vega10_ps->performance_levels\n\t\t\t[vega10_ps->performance_level_count - 1].mem_clock;\n\tuint32_t i;\n\n\tfor (i = 0; i < sclk_table->count; i++) {\n\t\tif (sclk == sclk_table->dpm_levels[i].value)\n\t\t\tbreak;\n\t}\n\n\tif (i >= sclk_table->count) {\n\t\tif (sclk > sclk_table->dpm_levels[i-1].value) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_SCLK;\n\t\t\tsclk_table->dpm_levels[i-1].value = sclk;\n\t\t}\n\t}\n\n\tfor (i = 0; i < mclk_table->count; i++) {\n\t\tif (mclk == mclk_table->dpm_levels[i].value)\n\t\t\tbreak;\n\t}\n\n\tif (i >= mclk_table->count) {\n\t\tif (mclk > mclk_table->dpm_levels[i-1].value) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_MCLK;\n\t\t\tmclk_table->dpm_levels[i-1].value = mclk;\n\t\t}\n\t}\n\n\tif (data->display_timing.num_existing_displays != hwmgr->display_config->num_display)\n\t\tdata->need_update_dpm_table |= DPMTABLE_UPDATE_MCLK;\n\n\treturn 0;\n}\n\nstatic int vega10_populate_and_upload_sclk_mclk_dpm_levels(\n\t\tstruct pp_hwmgr *hwmgr, const void *input)\n{\n\tint result = 0;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_dpm_table *dpm_table = &data->dpm_table;\n\tstruct vega10_odn_dpm_table *odn_table = &data->odn_dpm_table;\n\tstruct vega10_odn_clock_voltage_dependency_table *odn_clk_table = &odn_table->vdd_dep_on_sclk;\n\tint count;\n\n\tif (!data->need_update_dpm_table)\n\t\treturn 0;\n\n\tif (hwmgr->od_enabled && data->need_update_dpm_table & DPMTABLE_OD_UPDATE_SCLK) {\n\t\tfor (count = 0; count < dpm_table->gfx_table.count; count++)\n\t\t\tdpm_table->gfx_table.dpm_levels[count].value = odn_clk_table->entries[count].clk;\n\t}\n\n\todn_clk_table = &odn_table->vdd_dep_on_mclk;\n\tif (hwmgr->od_enabled && data->need_update_dpm_table & DPMTABLE_OD_UPDATE_MCLK) {\n\t\tfor (count = 0; count < dpm_table->mem_table.count; count++)\n\t\t\tdpm_table->mem_table.dpm_levels[count].value = odn_clk_table->entries[count].clk;\n\t}\n\n\tif (data->need_update_dpm_table &\n\t\t\t(DPMTABLE_OD_UPDATE_SCLK | DPMTABLE_UPDATE_SCLK | DPMTABLE_UPDATE_SOCCLK)) {\n\t\tresult = vega10_populate_all_graphic_levels(hwmgr);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"Failed to populate SCLK during PopulateNewDPMClocksStates Function!\",\n\t\t\t\treturn result);\n\t}\n\n\tif (data->need_update_dpm_table &\n\t\t\t(DPMTABLE_OD_UPDATE_MCLK | DPMTABLE_UPDATE_MCLK)) {\n\t\tresult = vega10_populate_all_memory_levels(hwmgr);\n\t\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\t\"Failed to populate MCLK during PopulateNewDPMClocksStates Function!\",\n\t\t\t\treturn result);\n\t}\n\n\tvega10_populate_vddc_soc_levels(hwmgr);\n\n\treturn result;\n}\n\nstatic int vega10_trim_single_dpm_states(struct pp_hwmgr *hwmgr,\n\t\tstruct vega10_single_dpm_table *dpm_table,\n\t\tuint32_t low_limit, uint32_t high_limit)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tif ((dpm_table->dpm_levels[i].value < low_limit) ||\n\t\t    (dpm_table->dpm_levels[i].value > high_limit))\n\t\t\tdpm_table->dpm_levels[i].enabled = false;\n\t\telse\n\t\t\tdpm_table->dpm_levels[i].enabled = true;\n\t}\n\treturn 0;\n}\n\nstatic int vega10_trim_single_dpm_states_with_mask(struct pp_hwmgr *hwmgr,\n\t\tstruct vega10_single_dpm_table *dpm_table,\n\t\tuint32_t low_limit, uint32_t high_limit,\n\t\tuint32_t disable_dpm_mask)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tif ((dpm_table->dpm_levels[i].value < low_limit) ||\n\t\t    (dpm_table->dpm_levels[i].value > high_limit))\n\t\t\tdpm_table->dpm_levels[i].enabled = false;\n\t\telse if (!((1 << i) & disable_dpm_mask))\n\t\t\tdpm_table->dpm_levels[i].enabled = false;\n\t\telse\n\t\t\tdpm_table->dpm_levels[i].enabled = true;\n\t}\n\treturn 0;\n}\n\nstatic int vega10_trim_dpm_states(struct pp_hwmgr *hwmgr,\n\t\tconst struct vega10_power_state *vega10_ps)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t high_limit_count;\n\n\tPP_ASSERT_WITH_CODE((vega10_ps->performance_level_count >= 1),\n\t\t\t\"power state did not have any performance level\",\n\t\t\treturn -1);\n\n\thigh_limit_count = (vega10_ps->performance_level_count == 1) ? 0 : 1;\n\n\tvega10_trim_single_dpm_states(hwmgr,\n\t\t\t&(data->dpm_table.soc_table),\n\t\t\tvega10_ps->performance_levels[0].soc_clock,\n\t\t\tvega10_ps->performance_levels[high_limit_count].soc_clock);\n\n\tvega10_trim_single_dpm_states_with_mask(hwmgr,\n\t\t\t&(data->dpm_table.gfx_table),\n\t\t\tvega10_ps->performance_levels[0].gfx_clock,\n\t\t\tvega10_ps->performance_levels[high_limit_count].gfx_clock,\n\t\t\tdata->disable_dpm_mask);\n\n\tvega10_trim_single_dpm_states(hwmgr,\n\t\t\t&(data->dpm_table.mem_table),\n\t\t\tvega10_ps->performance_levels[0].mem_clock,\n\t\t\tvega10_ps->performance_levels[high_limit_count].mem_clock);\n\n\treturn 0;\n}\n\nstatic uint32_t vega10_find_lowest_dpm_level(\n\t\tstruct vega10_single_dpm_table *table)\n{\n\tuint32_t i;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (table->dpm_levels[i].enabled)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic uint32_t vega10_find_highest_dpm_level(\n\t\tstruct vega10_single_dpm_table *table)\n{\n\tuint32_t i = 0;\n\n\tif (table->count <= MAX_REGULAR_DPM_NUMBER) {\n\t\tfor (i = table->count; i > 0; i--) {\n\t\t\tif (table->dpm_levels[i - 1].enabled)\n\t\t\t\treturn i - 1;\n\t\t}\n\t} else {\n\t\tpr_info(\"DPM Table Has Too Many Entries!\");\n\t\treturn MAX_REGULAR_DPM_NUMBER - 1;\n\t}\n\n\treturn i;\n}\n\nstatic void vega10_apply_dal_minimum_voltage_request(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\treturn;\n}\n\nstatic int vega10_get_soc_index_for_max_uclk(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *vdd_dep_table_on_mclk;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tvdd_dep_table_on_mclk  = table_info->vdd_dep_on_mclk;\n\n\treturn vdd_dep_table_on_mclk->entries[NUM_UCLK_DPM_LEVELS - 1].vddInd + 1;\n}\n\nstatic int vega10_upload_dpm_bootup_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t socclk_idx;\n\n\tvega10_apply_dal_minimum_voltage_request(hwmgr);\n\n\tif (!data->registry_data.sclk_dpm_key_disabled) {\n\t\tif (data->smc_state_table.gfx_boot_level !=\n\t\t\t\tdata->dpm_table.gfx_table.dpm_state.soft_min_level) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSoftMinGfxclkByIndex,\n\t\t\t\tdata->smc_state_table.gfx_boot_level,\n\t\t\t\tNULL);\n\n\t\t\tdata->dpm_table.gfx_table.dpm_state.soft_min_level =\n\t\t\t\t\tdata->smc_state_table.gfx_boot_level;\n\t\t}\n\t}\n\n\tif (!data->registry_data.mclk_dpm_key_disabled) {\n\t\tif (data->smc_state_table.mem_boot_level !=\n\t\t\t\tdata->dpm_table.mem_table.dpm_state.soft_min_level) {\n\t\t\tif ((data->smc_state_table.mem_boot_level == NUM_UCLK_DPM_LEVELS - 1)\n\t\t\t    && hwmgr->not_vf) {\n\t\t\t\tsocclk_idx = vega10_get_soc_index_for_max_uclk(hwmgr);\n\t\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMinSocclkByIndex,\n\t\t\t\t\t\tsocclk_idx,\n\t\t\t\t\t\tNULL);\n\t\t\t} else {\n\t\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\tPPSMC_MSG_SetSoftMinUclkByIndex,\n\t\t\t\t\t\tdata->smc_state_table.mem_boot_level,\n\t\t\t\t\t\tNULL);\n\t\t\t}\n\t\t\tdata->dpm_table.mem_table.dpm_state.soft_min_level =\n\t\t\t\t\tdata->smc_state_table.mem_boot_level;\n\t\t}\n\t}\n\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tif (!data->registry_data.socclk_dpm_key_disabled) {\n\t\tif (data->smc_state_table.soc_boot_level !=\n\t\t\t\tdata->dpm_table.soc_table.dpm_state.soft_min_level) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSoftMinSocclkByIndex,\n\t\t\t\tdata->smc_state_table.soc_boot_level,\n\t\t\t\tNULL);\n\t\t\tdata->dpm_table.soc_table.dpm_state.soft_min_level =\n\t\t\t\t\tdata->smc_state_table.soc_boot_level;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_upload_dpm_max_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tvega10_apply_dal_minimum_voltage_request(hwmgr);\n\n\tif (!data->registry_data.sclk_dpm_key_disabled) {\n\t\tif (data->smc_state_table.gfx_max_level !=\n\t\t\tdata->dpm_table.gfx_table.dpm_state.soft_max_level) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSoftMaxGfxclkByIndex,\n\t\t\t\tdata->smc_state_table.gfx_max_level,\n\t\t\t\tNULL);\n\t\t\tdata->dpm_table.gfx_table.dpm_state.soft_max_level =\n\t\t\t\t\tdata->smc_state_table.gfx_max_level;\n\t\t}\n\t}\n\n\tif (!data->registry_data.mclk_dpm_key_disabled) {\n\t\tif (data->smc_state_table.mem_max_level !=\n\t\t\tdata->dpm_table.mem_table.dpm_state.soft_max_level) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSoftMaxUclkByIndex,\n\t\t\t\t\tdata->smc_state_table.mem_max_level,\n\t\t\t\t\tNULL);\n\t\t\tdata->dpm_table.mem_table.dpm_state.soft_max_level =\n\t\t\t\t\tdata->smc_state_table.mem_max_level;\n\t\t}\n\t}\n\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tif (!data->registry_data.socclk_dpm_key_disabled) {\n\t\tif (data->smc_state_table.soc_max_level !=\n\t\t\tdata->dpm_table.soc_table.dpm_state.soft_max_level) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetSoftMaxSocclkByIndex,\n\t\t\t\tdata->smc_state_table.soc_max_level,\n\t\t\t\tNULL);\n\t\t\tdata->dpm_table.soc_table.dpm_state.soft_max_level =\n\t\t\t\t\tdata->smc_state_table.soc_max_level;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_generate_dpm_level_enable_mask(\n\t\tstruct pp_hwmgr *hwmgr, const void *input)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tconst struct phm_set_power_state_input *states =\n\t\t\t(const struct phm_set_power_state_input *)input;\n\tconst struct vega10_power_state *vega10_ps =\n\t\t\tcast_const_phw_vega10_power_state(states->pnew_state);\n\tint i;\n\n\tPP_ASSERT_WITH_CODE(!vega10_trim_dpm_states(hwmgr, vega10_ps),\n\t\t\t\"Attempt to Trim DPM States Failed!\",\n\t\t\treturn -1);\n\n\tdata->smc_state_table.gfx_boot_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.gfx_table));\n\tdata->smc_state_table.gfx_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.gfx_table));\n\tdata->smc_state_table.mem_boot_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.mem_table));\n\tdata->smc_state_table.mem_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.mem_table));\n\tdata->smc_state_table.soc_boot_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.soc_table));\n\tdata->smc_state_table.soc_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.soc_table));\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Attempt to upload DPM Bootup Levels Failed!\",\n\t\t\treturn -1);\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Attempt to upload DPM Max Levels Failed!\",\n\t\t\treturn -1);\n\tfor(i = data->smc_state_table.gfx_boot_level; i < data->smc_state_table.gfx_max_level; i++)\n\t\tdata->dpm_table.gfx_table.dpm_levels[i].enabled = true;\n\n\n\tfor(i = data->smc_state_table.mem_boot_level; i < data->smc_state_table.mem_max_level; i++)\n\t\tdata->dpm_table.mem_table.dpm_levels[i].enabled = true;\n\n\tfor (i = data->smc_state_table.soc_boot_level; i < data->smc_state_table.soc_max_level; i++)\n\t\tdata->dpm_table.soc_table.dpm_levels[i].enabled = true;\n\n\treturn 0;\n}\n\nint vega10_enable_disable_vce_dpm(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_DPM_VCE].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tenable,\n\t\t\t\tdata->smu_features[GNLD_DPM_VCE].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable/Disable DPM VCE Failed!\",\n\t\t\t\treturn -1);\n\t\tdata->smu_features[GNLD_DPM_VCE].enabled = enable;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_update_sclk_threshold(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t low_sclk_interrupt_threshold = 0;\n\n\tif (PP_CAP(PHM_PlatformCaps_SclkThrottleLowNotification) &&\n\t\t(data->low_sclk_interrupt_threshold != 0)) {\n\t\tlow_sclk_interrupt_threshold =\n\t\t\t\tdata->low_sclk_interrupt_threshold;\n\n\t\tdata->smc_state_table.pp_table.LowGfxclkInterruptThreshold =\n\t\t\t\tcpu_to_le32(low_sclk_interrupt_threshold);\n\n\t\t \n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetLowGfxclkInterruptThreshold,\n\t\t\t\t(uint32_t)low_sclk_interrupt_threshold,\n\t\t\t\tNULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_set_power_state_tasks(struct pp_hwmgr *hwmgr,\n\t\tconst void *input)\n{\n\tint tmp_result, result = 0;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\n\ttmp_result = vega10_find_dpm_states_clocks_in_dpm_table(hwmgr, input);\n\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\"Failed to find DPM states clocks in DPM table!\",\n\t\t\tresult = tmp_result);\n\n\ttmp_result = vega10_populate_and_upload_sclk_mclk_dpm_levels(hwmgr, input);\n\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\"Failed to populate and upload SCLK MCLK DPM levels!\",\n\t\t\tresult = tmp_result);\n\n\ttmp_result = vega10_generate_dpm_level_enable_mask(hwmgr, input);\n\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\"Failed to generate DPM level enabled mask!\",\n\t\t\tresult = tmp_result);\n\n\ttmp_result = vega10_update_sclk_threshold(hwmgr);\n\tPP_ASSERT_WITH_CODE(!tmp_result,\n\t\t\t\"Failed to update SCLK threshold!\",\n\t\t\tresult = tmp_result);\n\n\tresult = smum_smc_table_manager(hwmgr, (uint8_t *)pp_table, PPTABLE, false);\n\tPP_ASSERT_WITH_CODE(!result,\n\t\t\t\"Failed to upload PPtable!\", return result);\n\n\t \n\tif(hwmgr->hardcode_pp_table != NULL)\n\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_VDDC;\n\n\tvega10_update_avfs(hwmgr);\n\n\t \n\tdata->need_update_dpm_table &= DPMTABLE_OD_UPDATE_VDDC;\n\n\treturn 0;\n}\n\nstatic uint32_t vega10_dpm_get_sclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct pp_power_state *ps;\n\tstruct vega10_power_state *vega10_ps;\n\n\tif (hwmgr == NULL)\n\t\treturn -EINVAL;\n\n\tps = hwmgr->request_ps;\n\n\tif (ps == NULL)\n\t\treturn -EINVAL;\n\n\tvega10_ps = cast_phw_vega10_power_state(&ps->hardware);\n\n\tif (low)\n\t\treturn vega10_ps->performance_levels[0].gfx_clock;\n\telse\n\t\treturn vega10_ps->performance_levels\n\t\t\t\t[vega10_ps->performance_level_count - 1].gfx_clock;\n}\n\nstatic uint32_t vega10_dpm_get_mclk(struct pp_hwmgr *hwmgr, bool low)\n{\n\tstruct pp_power_state *ps;\n\tstruct vega10_power_state *vega10_ps;\n\n\tif (hwmgr == NULL)\n\t\treturn -EINVAL;\n\n\tps = hwmgr->request_ps;\n\n\tif (ps == NULL)\n\t\treturn -EINVAL;\n\n\tvega10_ps = cast_phw_vega10_power_state(&ps->hardware);\n\n\tif (low)\n\t\treturn vega10_ps->performance_levels[0].mem_clock;\n\telse\n\t\treturn vega10_ps->performance_levels\n\t\t\t\t[vega10_ps->performance_level_count-1].mem_clock;\n}\n\nstatic int vega10_get_gpu_power(struct pp_hwmgr *hwmgr,\n\t\tuint32_t *query)\n{\n\tuint32_t value;\n\n\tif (!query)\n\t\treturn -EINVAL;\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrPkgPwr, &value);\n\n\t \n\t*query = value << 8;\n\n\treturn 0;\n}\n\nstatic int vega10_read_sensor(struct pp_hwmgr *hwmgr, int idx,\n\t\t\t      void *value, int *size)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t sclk_mhz, mclk_idx, activity_percent = 0;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_dpm_table *dpm_table = &data->dpm_table;\n\tint ret = 0;\n\tuint32_t val_vid;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_GFX_SCLK:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetAverageGfxclkActualFrequency, &sclk_mhz);\n\t\t*((uint32_t *)value) = sclk_mhz * 100;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GFX_MCLK:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentUclkIndex, &mclk_idx);\n\t\tif (mclk_idx < dpm_table->mem_table.count) {\n\t\t\t*((uint32_t *)value) = dpm_table->mem_table.dpm_levels[mclk_idx].value;\n\t\t\t*size = 4;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_LOAD:\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_GetAverageGfxActivity, 0,\n\t\t\t\t\t\t&activity_percent);\n\t\t*((uint32_t *)value) = activity_percent > 100 ? 100 : activity_percent;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_TEMP:\n\t\t*((uint32_t *)value) = vega10_thermal_get_temperature(hwmgr);\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_HOTSPOT_TEMP:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetTemperatureHotspot, (uint32_t *)value);\n\t\t*((uint32_t *)value) = *((uint32_t *)value) *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_MEM_TEMP:\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetTemperatureHBM, (uint32_t *)value);\n\t\t*((uint32_t *)value) = *((uint32_t *)value) *\n\t\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_UVD_POWER:\n\t\t*((uint32_t *)value) = data->uvd_power_gated ? 0 : 1;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VCE_POWER:\n\t\t*((uint32_t *)value) = data->vce_power_gated ? 0 : 1;\n\t\t*size = 4;\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_GPU_INPUT_POWER:\n\t\tret = vega10_get_gpu_power(hwmgr, (uint32_t *)value);\n\t\tbreak;\n\tcase AMDGPU_PP_SENSOR_VDDGFX:\n\t\tval_vid = (RREG32_SOC15(SMUIO, 0, mmSMUSVI0_PLANE0_CURRENTVID) &\n\t\t\tSMUSVI0_PLANE0_CURRENTVID__CURRENT_SVI0_PLANE0_VID_MASK) >>\n\t\t\tSMUSVI0_PLANE0_CURRENTVID__CURRENT_SVI0_PLANE0_VID__SHIFT;\n\t\t*((uint32_t *)value) = (uint32_t)convert_to_vddc((uint8_t)val_vid);\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_ENABLED_SMC_FEATURES_MASK:\n\t\tret = vega10_get_enabled_smc_features(hwmgr, (uint64_t *)value);\n\t\tif (!ret)\n\t\t\t*size = 8;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void vega10_notify_smc_display_change(struct pp_hwmgr *hwmgr,\n\t\tbool has_disp)\n{\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetUclkFastSwitch,\n\t\t\thas_disp ? 1 : 0,\n\t\t\tNULL);\n}\n\nstatic int vega10_display_clock_voltage_request(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_display_clock_request *clock_req)\n{\n\tint result = 0;\n\tenum amd_pp_clock_type clk_type = clock_req->clock_type;\n\tuint32_t clk_freq = clock_req->clock_freq_in_khz / 1000;\n\tDSPCLK_e clk_select = 0;\n\tuint32_t clk_request = 0;\n\n\tswitch (clk_type) {\n\tcase amd_pp_dcef_clock:\n\t\tclk_select = DSPCLK_DCEFCLK;\n\t\tbreak;\n\tcase amd_pp_disp_clock:\n\t\tclk_select = DSPCLK_DISPCLK;\n\t\tbreak;\n\tcase amd_pp_pixel_clock:\n\t\tclk_select = DSPCLK_PIXCLK;\n\t\tbreak;\n\tcase amd_pp_phy_clock:\n\t\tclk_select = DSPCLK_PHYCLK;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"[DisplayClockVoltageRequest]Invalid Clock Type!\");\n\t\tresult = -1;\n\t\tbreak;\n\t}\n\n\tif (!result) {\n\t\tclk_request = (clk_freq << 16) | clk_select;\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_RequestDisplayClockByFreq,\n\t\t\t\tclk_request,\n\t\t\t\tNULL);\n\t}\n\n\treturn result;\n}\n\nstatic uint8_t vega10_get_uclk_index(struct pp_hwmgr *hwmgr,\n\t\t\tstruct phm_ppt_v1_clock_voltage_dependency_table *mclk_table,\n\t\t\t\t\t\tuint32_t frequency)\n{\n\tuint8_t count;\n\tuint8_t i;\n\n\tif (mclk_table == NULL || mclk_table->count == 0)\n\t\treturn 0;\n\n\tcount = (uint8_t)(mclk_table->count);\n\n\tfor(i = 0; i < count; i++) {\n\t\tif(mclk_table->entries[i].clk >= frequency)\n\t\t\treturn i;\n\t}\n\n\treturn i-1;\n}\n\nstatic int vega10_notify_smc_display_config_after_ps_adjustment(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *dpm_table =\n\t\t\t&data->dpm_table.dcef_table;\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *mclk_table = table_info->vdd_dep_on_mclk;\n\tuint32_t idx;\n\tstruct PP_Clocks min_clocks = {0};\n\tuint32_t i;\n\tstruct pp_display_clock_request clock_req;\n\n\tif ((hwmgr->display_config->num_display > 1) &&\n\t     !hwmgr->display_config->multi_monitor_in_sync &&\n\t     !hwmgr->display_config->nb_pstate_switch_disable)\n\t\tvega10_notify_smc_display_change(hwmgr, false);\n\telse\n\t\tvega10_notify_smc_display_change(hwmgr, true);\n\n\tmin_clocks.dcefClock = hwmgr->display_config->min_dcef_set_clk;\n\tmin_clocks.dcefClockInSR = hwmgr->display_config->min_dcef_deep_sleep_set_clk;\n\tmin_clocks.memoryClock = hwmgr->display_config->min_mem_set_clock;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tif (dpm_table->dpm_levels[i].value == min_clocks.dcefClock)\n\t\t\tbreak;\n\t}\n\n\tif (i < dpm_table->count) {\n\t\tclock_req.clock_type = amd_pp_dcef_clock;\n\t\tclock_req.clock_freq_in_khz = dpm_table->dpm_levels[i].value * 10;\n\t\tif (!vega10_display_clock_voltage_request(hwmgr, &clock_req)) {\n\t\t\tsmum_send_msg_to_smc_with_parameter(\n\t\t\t\t\thwmgr, PPSMC_MSG_SetMinDeepSleepDcefclk,\n\t\t\t\t\tmin_clocks.dcefClockInSR / 100,\n\t\t\t\t\tNULL);\n\t\t} else {\n\t\t\tpr_info(\"Attempt to set Hard Min for DCEFCLK Failed!\");\n\t\t}\n\t} else {\n\t\tpr_debug(\"Cannot find requested DCEFCLK!\");\n\t}\n\n\tif (min_clocks.memoryClock != 0) {\n\t\tidx = vega10_get_uclk_index(hwmgr, mclk_table, min_clocks.memoryClock);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_SetSoftMinUclkByIndex, idx,\n\t\t\t\t\t\tNULL);\n\t\tdata->dpm_table.mem_table.dpm_state.soft_min_level= idx;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_force_dpm_highest(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->smc_state_table.gfx_boot_level =\n\tdata->smc_state_table.gfx_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.gfx_table));\n\tdata->smc_state_table.mem_boot_level =\n\tdata->smc_state_table.mem_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.mem_table));\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Failed to upload boot level to highest!\",\n\t\t\treturn -1);\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn -1);\n\n\treturn 0;\n}\n\nstatic int vega10_force_dpm_lowest(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->smc_state_table.gfx_boot_level =\n\tdata->smc_state_table.gfx_max_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.gfx_table));\n\tdata->smc_state_table.mem_boot_level =\n\tdata->smc_state_table.mem_max_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.mem_table));\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Failed to upload boot level to highest!\",\n\t\t\treturn -1);\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn -1);\n\n\treturn 0;\n\n}\n\nstatic int vega10_unforce_dpm_levels(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->smc_state_table.gfx_boot_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.gfx_table));\n\tdata->smc_state_table.gfx_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.gfx_table));\n\tdata->smc_state_table.mem_boot_level =\n\t\t\tvega10_find_lowest_dpm_level(&(data->dpm_table.mem_table));\n\tdata->smc_state_table.mem_max_level =\n\t\t\tvega10_find_highest_dpm_level(&(data->dpm_table.mem_table));\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Failed to upload DPM Bootup Levels!\",\n\t\t\treturn -1);\n\n\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Failed to upload DPM Max Levels!\",\n\t\t\treturn -1);\n\treturn 0;\n}\n\nstatic int vega10_get_profiling_clk_mask(struct pp_hwmgr *hwmgr, enum amd_dpm_forced_level level,\n\t\t\t\tuint32_t *sclk_mask, uint32_t *mclk_mask, uint32_t *soc_mask)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\n\tif (table_info->vdd_dep_on_sclk->count > VEGA10_UMD_PSTATE_GFXCLK_LEVEL &&\n\t\ttable_info->vdd_dep_on_socclk->count > VEGA10_UMD_PSTATE_SOCCLK_LEVEL &&\n\t\ttable_info->vdd_dep_on_mclk->count > VEGA10_UMD_PSTATE_MCLK_LEVEL) {\n\t\t*sclk_mask = VEGA10_UMD_PSTATE_GFXCLK_LEVEL;\n\t\t*soc_mask = VEGA10_UMD_PSTATE_SOCCLK_LEVEL;\n\t\t*mclk_mask = VEGA10_UMD_PSTATE_MCLK_LEVEL;\n\t}\n\n\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK) {\n\t\t*sclk_mask = 0;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK) {\n\t\t*mclk_mask = 0;\n\t} else if (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK) {\n\t\t \n\t\tif (hwmgr->pp_one_vf)\n\t\t\t*sclk_mask = 4;\n\t\telse\n\t\t\t*sclk_mask = table_info->vdd_dep_on_sclk->count - 1;\n\t\t*soc_mask = table_info->vdd_dep_on_socclk->count - 1;\n\t\t*mclk_mask = table_info->vdd_dep_on_mclk->count - 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void vega10_set_fan_control_mode(struct pp_hwmgr *hwmgr, uint32_t mode)\n{\n\tif (!hwmgr->not_vf)\n\t\treturn;\n\n\tswitch (mode) {\n\tcase AMD_FAN_CTRL_NONE:\n\t\tvega10_fan_ctrl_set_fan_speed_pwm(hwmgr, 255);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_MANUAL:\n\t\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl))\n\t\t\tvega10_fan_ctrl_stop_smc_fan_control(hwmgr);\n\t\tbreak;\n\tcase AMD_FAN_CTRL_AUTO:\n\t\tif (PP_CAP(PHM_PlatformCaps_MicrocodeFanControl))\n\t\t\tvega10_fan_ctrl_start_smc_fan_control(hwmgr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int vega10_force_clock_level(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, uint32_t mask)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tdata->smc_state_table.gfx_boot_level = mask ? (ffs(mask) - 1) : 0;\n\t\tdata->smc_state_table.gfx_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn -EINVAL);\n\n\t\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn -EINVAL);\n\t\tbreak;\n\n\tcase PP_MCLK:\n\t\tdata->smc_state_table.mem_boot_level = mask ? (ffs(mask) - 1) : 0;\n\t\tdata->smc_state_table.mem_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn -EINVAL);\n\n\t\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn -EINVAL);\n\n\t\tbreak;\n\n\tcase PP_SOCCLK:\n\t\tdata->smc_state_table.soc_boot_level = mask ? (ffs(mask) - 1) : 0;\n\t\tdata->smc_state_table.soc_max_level = mask ? (fls(mask) - 1) : 0;\n\n\t\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_bootup_level(hwmgr),\n\t\t\t\"Failed to upload boot level to lowest!\",\n\t\t\treturn -EINVAL);\n\n\t\tPP_ASSERT_WITH_CODE(!vega10_upload_dpm_max_level(hwmgr),\n\t\t\t\"Failed to upload dpm max level to highest!\",\n\t\t\treturn -EINVAL);\n\n\t\tbreak;\n\n\tcase PP_DCEFCLK:\n\t\tpr_info(\"Setting DCEFCLK min/max dpm level is not supported!\\n\");\n\t\tbreak;\n\n\tcase PP_PCIE:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_dpm_force_dpm_level(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tint ret = 0;\n\tuint32_t sclk_mask = 0;\n\tuint32_t mclk_mask = 0;\n\tuint32_t soc_mask = 0;\n\n\tswitch (level) {\n\tcase AMD_DPM_FORCED_LEVEL_HIGH:\n\t\tret = vega10_force_dpm_highest(hwmgr);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_LOW:\n\t\tret = vega10_force_dpm_lowest(hwmgr);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_AUTO:\n\t\tret = vega10_unforce_dpm_levels(hwmgr);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_PEAK:\n\t\tret = vega10_get_profiling_clk_mask(hwmgr, level, &sclk_mask, &mclk_mask, &soc_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvega10_force_clock_level(hwmgr, PP_SCLK, 1<<sclk_mask);\n\t\tvega10_force_clock_level(hwmgr, PP_MCLK, 1<<mclk_mask);\n\t\tbreak;\n\tcase AMD_DPM_FORCED_LEVEL_MANUAL:\n\tcase AMD_DPM_FORCED_LEVEL_PROFILE_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!hwmgr->not_vf)\n\t\treturn ret;\n\n\tif (!ret) {\n\t\tif (level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK && hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tvega10_set_fan_control_mode(hwmgr, AMD_FAN_CTRL_NONE);\n\t\telse if (level != AMD_DPM_FORCED_LEVEL_PROFILE_PEAK && hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK)\n\t\t\tvega10_set_fan_control_mode(hwmgr, AMD_FAN_CTRL_AUTO);\n\t}\n\n\treturn ret;\n}\n\nstatic uint32_t vega10_get_fan_control_mode(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_FAN_CONTROL].enabled == false)\n\t\treturn AMD_FAN_CTRL_MANUAL;\n\telse\n\t\treturn AMD_FAN_CTRL_AUTO;\n}\n\nstatic int vega10_get_dal_power_level(struct pp_hwmgr *hwmgr,\n\t\tstruct amd_pp_simple_clock_info *info)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_clock_and_voltage_limits *max_limits =\n\t\t\t&table_info->max_clock_voltage_on_ac;\n\n\tinfo->engine_max_clock = max_limits->sclk;\n\tinfo->memory_max_clock = max_limits->mclk;\n\n\treturn 0;\n}\n\nstatic void vega10_get_sclks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->vdd_dep_on_sclk;\n\tuint32_t i;\n\n\tclocks->num_levels = 0;\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (dep_table->entries[i].clk) {\n\t\t\tclocks->data[clocks->num_levels].clocks_in_khz =\n\t\t\t\t\tdep_table->entries[i].clk * 10;\n\t\t\tclocks->num_levels++;\n\t\t}\n\t}\n\n}\n\nstatic void vega10_get_memclocks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->vdd_dep_on_mclk;\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t j = 0;\n\tuint32_t i;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tif (dep_table->entries[i].clk) {\n\n\t\t\tclocks->data[j].clocks_in_khz =\n\t\t\t\t\t\tdep_table->entries[i].clk * 10;\n\t\t\tdata->mclk_latency_table.entries[j].frequency =\n\t\t\t\t\t\t\tdep_table->entries[i].clk;\n\t\t\tclocks->data[j].latency_in_us =\n\t\t\t\tdata->mclk_latency_table.entries[j].latency = 25;\n\t\t\tj++;\n\t\t}\n\t}\n\tclocks->num_levels = data->mclk_latency_table.count = j;\n}\n\nstatic void vega10_get_dcefclocks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->vdd_dep_on_dcefclk;\n\tuint32_t i;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tclocks->data[i].clocks_in_khz = dep_table->entries[i].clk * 10;\n\t\tclocks->data[i].latency_in_us = 0;\n\t\tclocks->num_levels++;\n\t}\n}\n\nstatic void vega10_get_socclocks(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table =\n\t\t\ttable_info->vdd_dep_on_socclk;\n\tuint32_t i;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tclocks->data[i].clocks_in_khz = dep_table->entries[i].clk * 10;\n\t\tclocks->data[i].latency_in_us = 0;\n\t\tclocks->num_levels++;\n\t}\n}\n\nstatic int vega10_get_clock_by_type_with_latency(struct pp_hwmgr *hwmgr,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tswitch (type) {\n\tcase amd_pp_sys_clock:\n\t\tvega10_get_sclks(hwmgr, clocks);\n\t\tbreak;\n\tcase amd_pp_mem_clock:\n\t\tvega10_get_memclocks(hwmgr, clocks);\n\t\tbreak;\n\tcase amd_pp_dcef_clock:\n\t\tvega10_get_dcefclocks(hwmgr, clocks);\n\t\tbreak;\n\tcase amd_pp_soc_clock:\n\t\tvega10_get_socclocks(hwmgr, clocks);\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_get_clock_by_type_with_voltage(struct pp_hwmgr *hwmgr,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_voltage *clocks)\n{\n\tstruct phm_ppt_v2_information *table_info =\n\t\t\t(struct phm_ppt_v2_information *)hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table;\n\tuint32_t i;\n\n\tswitch (type) {\n\tcase amd_pp_mem_clock:\n\t\tdep_table = table_info->vdd_dep_on_mclk;\n\t\tbreak;\n\tcase amd_pp_dcef_clock:\n\t\tdep_table = table_info->vdd_dep_on_dcefclk;\n\t\tbreak;\n\tcase amd_pp_disp_clock:\n\t\tdep_table = table_info->vdd_dep_on_dispclk;\n\t\tbreak;\n\tcase amd_pp_pixel_clock:\n\t\tdep_table = table_info->vdd_dep_on_pixclk;\n\t\tbreak;\n\tcase amd_pp_phy_clock:\n\t\tdep_table = table_info->vdd_dep_on_phyclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tclocks->data[i].clocks_in_khz = dep_table->entries[i].clk  * 10;\n\t\tclocks->data[i].voltage_in_mv = (uint32_t)(table_info->vddc_lookup_table->\n\t\t\t\tentries[dep_table->entries[i].vddInd].us_vdd);\n\t\tclocks->num_levels++;\n\t}\n\n\tif (i < dep_table->count)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int vega10_set_watermarks_for_clocks_ranges(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\t\tvoid *clock_range)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges = clock_range;\n\tWatermarks_t *table = &(data->smc_state_table.water_marks_table);\n\n\tif (!data->registry_data.disable_water_mark) {\n\t\tsmu_set_watermarks_for_clocks_ranges(table, wm_with_clock_ranges);\n\t\tdata->water_marks_bitmap = WaterMarksExist;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_get_ppfeature_status(struct pp_hwmgr *hwmgr, char *buf)\n{\n\tstatic const char *ppfeature_name[] = {\n\t\t\t\t\"DPM_PREFETCHER\",\n\t\t\t\t\"GFXCLK_DPM\",\n\t\t\t\t\"UCLK_DPM\",\n\t\t\t\t\"SOCCLK_DPM\",\n\t\t\t\t\"UVD_DPM\",\n\t\t\t\t\"VCE_DPM\",\n\t\t\t\t\"ULV\",\n\t\t\t\t\"MP0CLK_DPM\",\n\t\t\t\t\"LINK_DPM\",\n\t\t\t\t\"DCEFCLK_DPM\",\n\t\t\t\t\"AVFS\",\n\t\t\t\t\"GFXCLK_DS\",\n\t\t\t\t\"SOCCLK_DS\",\n\t\t\t\t\"LCLK_DS\",\n\t\t\t\t\"PPT\",\n\t\t\t\t\"TDC\",\n\t\t\t\t\"THERMAL\",\n\t\t\t\t\"GFX_PER_CU_CG\",\n\t\t\t\t\"RM\",\n\t\t\t\t\"DCEFCLK_DS\",\n\t\t\t\t\"ACDC\",\n\t\t\t\t\"VR0HOT\",\n\t\t\t\t\"VR1HOT\",\n\t\t\t\t\"FW_CTF\",\n\t\t\t\t\"LED_DISPLAY\",\n\t\t\t\t\"FAN_CONTROL\",\n\t\t\t\t\"FAST_PPT\",\n\t\t\t\t\"DIDT\",\n\t\t\t\t\"ACG\",\n\t\t\t\t\"PCC_LIMIT\"};\n\tstatic const char *output_title[] = {\n\t\t\t\t\"FEATURES\",\n\t\t\t\t\"BITMASK\",\n\t\t\t\t\"ENABLEMENT\"};\n\tuint64_t features_enabled;\n\tint i;\n\tint ret = 0;\n\tint size = 0;\n\n\tphm_get_sysfs_buf(&buf, &size);\n\n\tret = vega10_get_enabled_smc_features(hwmgr, &features_enabled);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[EnableAllSmuFeatures] Failed to get enabled smc features!\",\n\t\t\treturn ret);\n\n\tsize += sysfs_emit_at(buf, size, \"Current ppfeatures: 0x%016llx\\n\", features_enabled);\n\tsize += sysfs_emit_at(buf, size, \"%-19s %-22s %s\\n\",\n\t\t\t\toutput_title[0],\n\t\t\t\toutput_title[1],\n\t\t\t\toutput_title[2]);\n\tfor (i = 0; i < GNLD_FEATURES_MAX; i++) {\n\t\tsize += sysfs_emit_at(buf, size, \"%-19s 0x%016llx %6s\\n\",\n\t\t\t\t\tppfeature_name[i],\n\t\t\t\t\t1ULL << i,\n\t\t\t\t\t(features_enabled & (1ULL << i)) ? \"Y\" : \"N\");\n\t}\n\n\treturn size;\n}\n\nstatic int vega10_set_ppfeature_status(struct pp_hwmgr *hwmgr, uint64_t new_ppfeature_masks)\n{\n\tuint64_t features_enabled;\n\tuint64_t features_to_enable;\n\tuint64_t features_to_disable;\n\tint ret = 0;\n\n\tif (new_ppfeature_masks >= (1ULL << GNLD_FEATURES_MAX))\n\t\treturn -EINVAL;\n\n\tret = vega10_get_enabled_smc_features(hwmgr, &features_enabled);\n\tif (ret)\n\t\treturn ret;\n\n\tfeatures_to_disable =\n\t\tfeatures_enabled & ~new_ppfeature_masks;\n\tfeatures_to_enable =\n\t\t~features_enabled & new_ppfeature_masks;\n\n\tpr_debug(\"features_to_disable 0x%llx\\n\", features_to_disable);\n\tpr_debug(\"features_to_enable 0x%llx\\n\", features_to_enable);\n\n\tif (features_to_disable) {\n\t\tret = vega10_enable_smc_features(hwmgr, false, features_to_disable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (features_to_enable) {\n\t\tret = vega10_enable_smc_features(hwmgr, true, features_to_enable);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_get_current_pcie_link_width_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_LINK_WIDTH_CNTL) &\n\t\tPCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD_MASK)\n\t\t>> PCIE_LC_LINK_WIDTH_CNTL__LC_LINK_WIDTH_RD__SHIFT;\n}\n\nstatic int vega10_get_current_pcie_link_speed_level(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn (RREG32_PCIE(smnPCIE_LC_SPEED_CNTL) &\n\t\tPSWUSP0_PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE_MASK)\n\t\t>> PSWUSP0_PCIE_LC_SPEED_CNTL__LC_CURRENT_DATA_RATE__SHIFT;\n}\n\nstatic int vega10_emit_clock_levels(struct pp_hwmgr *hwmgr,\n\t\t\t\t    enum pp_clock_type type, char *buf, int *offset)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *sclk_table = &(data->dpm_table.gfx_table);\n\tstruct vega10_single_dpm_table *mclk_table = &(data->dpm_table.mem_table);\n\tstruct vega10_single_dpm_table *soc_table = &(data->dpm_table.soc_table);\n\tstruct vega10_single_dpm_table *dcef_table = &(data->dpm_table.dcef_table);\n\tstruct vega10_odn_clock_voltage_dependency_table *podn_vdd_dep = NULL;\n\tuint32_t gen_speed, lane_width, current_gen_speed, current_lane_width;\n\tPPTable_t *pptable = &(data->smc_state_table.pp_table);\n\n\tuint32_t i, now, count = 0;\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tif (data->registry_data.sclk_dpm_key_disabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentGfxclkIndex, &now);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tif (hwmgr->pp_one_vf &&\n\t\t    (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK))\n\t\t\tcount = 5;\n\t\telse\n\t\t\tcount = sclk_table->count;\n\t\tfor (i = 0; i < count; i++)\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, sclk_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_MCLK:\n\t\tif (data->registry_data.mclk_dpm_key_disabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentUclkIndex, &now);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < mclk_table->count; i++)\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, mclk_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_SOCCLK:\n\t\tif (data->registry_data.socclk_dpm_key_disabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = smum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentSocclkIndex, &now);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < soc_table->count; i++)\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, soc_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_DCEFCLK:\n\t\tif (data->registry_data.dcefclk_dpm_key_disabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\t\t\t  PPSMC_MSG_GetClockFreqMHz,\n\t\t\t\t\t\t\t  CLK_DCEFCLK, &now);\n\t\tif (unlikely(ret != 0))\n\t\t\treturn ret;\n\n\t\tfor (i = 0; i < dcef_table->count; i++)\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, dcef_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(dcef_table->dpm_levels[i].value / 100 == now) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\tbreak;\n\tcase PP_PCIE:\n\t\tcurrent_gen_speed =\n\t\t\tvega10_get_current_pcie_link_speed_level(hwmgr);\n\t\tcurrent_lane_width =\n\t\t\tvega10_get_current_pcie_link_width_level(hwmgr);\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\t\tgen_speed = pptable->PcieGenSpeed[i];\n\t\t\tlane_width = pptable->PcieLaneCount[i];\n\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %s %s %s\\n\", i,\n\t\t\t\t\t(gen_speed == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(gen_speed == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(gen_speed == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(gen_speed == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(lane_width == 1) ? \"x1\" :\n\t\t\t\t\t(lane_width == 2) ? \"x2\" :\n\t\t\t\t\t(lane_width == 3) ? \"x4\" :\n\t\t\t\t\t(lane_width == 4) ? \"x8\" :\n\t\t\t\t\t(lane_width == 5) ? \"x12\" :\n\t\t\t\t\t(lane_width == 6) ? \"x16\" : \"\",\n\t\t\t\t\t(current_gen_speed == gen_speed) &&\n\t\t\t\t\t(current_lane_width == lane_width) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\t}\n\t\tbreak;\n\n\tcase OD_SCLK:\n\t\tif (!hwmgr->od_enabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t*offset += sysfs_emit_at(buf, *offset, \"%s:\\n\", \"OD_SCLK\");\n\t\tpodn_vdd_dep = &data->odn_dpm_table.vdd_dep_on_sclk;\n\t\tfor (i = 0; i < podn_vdd_dep->count; i++)\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %10uMhz %10umV\\n\",\n\t\t\t\t\t\t i, podn_vdd_dep->entries[i].clk / 100,\n\t\t\t\t\t\t podn_vdd_dep->entries[i].vddc);\n\t\tbreak;\n\tcase OD_MCLK:\n\t\tif (!hwmgr->od_enabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t*offset += sysfs_emit_at(buf, *offset, \"%s:\\n\", \"OD_MCLK\");\n\t\tpodn_vdd_dep = &data->odn_dpm_table.vdd_dep_on_mclk;\n\t\tfor (i = 0; i < podn_vdd_dep->count; i++)\n\t\t\t*offset += sysfs_emit_at(buf, *offset, \"%d: %10uMhz %10umV\\n\",\n\t\t\t\t\t\t i, podn_vdd_dep->entries[i].clk/100,\n\t\t\t\t\t\t podn_vdd_dep->entries[i].vddc);\n\t\tbreak;\n\tcase OD_RANGE:\n\t\tif (!hwmgr->od_enabled)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t*offset += sysfs_emit_at(buf, *offset, \"%s:\\n\", \"OD_RANGE\");\n\t\t*offset += sysfs_emit_at(buf, *offset, \"SCLK: %7uMHz %10uMHz\\n\",\n\t\t\t\t\t data->golden_dpm_table.gfx_table.dpm_levels[0].value/100,\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock/100);\n\t\t*offset += sysfs_emit_at(buf, *offset, \"MCLK: %7uMHz %10uMHz\\n\",\n\t\t\t\t\t data->golden_dpm_table.mem_table.dpm_levels[0].value/100,\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock/100);\n\t\t*offset += sysfs_emit_at(buf, *offset, \"VDDC: %7umV %11umV\\n\",\n\t\t\t\t\t data->odn_dpm_table.min_vddc,\n\t\t\t\t\t data->odn_dpm_table.max_vddc);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOENT;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int vega10_print_clock_levels(struct pp_hwmgr *hwmgr,\n\t\tenum pp_clock_type type, char *buf)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *sclk_table = &(data->dpm_table.gfx_table);\n\tstruct vega10_single_dpm_table *mclk_table = &(data->dpm_table.mem_table);\n\tstruct vega10_single_dpm_table *soc_table = &(data->dpm_table.soc_table);\n\tstruct vega10_single_dpm_table *dcef_table = &(data->dpm_table.dcef_table);\n\tstruct vega10_odn_clock_voltage_dependency_table *podn_vdd_dep = NULL;\n\tuint32_t gen_speed, lane_width, current_gen_speed, current_lane_width;\n\tPPTable_t *pptable = &(data->smc_state_table.pp_table);\n\n\tint i, now, size = 0, count = 0;\n\n\tswitch (type) {\n\tcase PP_SCLK:\n\t\tif (data->registry_data.sclk_dpm_key_disabled)\n\t\t\tbreak;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentGfxclkIndex, &now);\n\n\t\tif (hwmgr->pp_one_vf &&\n\t\t    (hwmgr->dpm_level == AMD_DPM_FORCED_LEVEL_PROFILE_PEAK))\n\t\t\tcount = 5;\n\t\telse\n\t\t\tcount = sclk_table->count;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, sclk_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_MCLK:\n\t\tif (data->registry_data.mclk_dpm_key_disabled)\n\t\t\tbreak;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentUclkIndex, &now);\n\n\t\tfor (i = 0; i < mclk_table->count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, mclk_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_SOCCLK:\n\t\tif (data->registry_data.socclk_dpm_key_disabled)\n\t\t\tbreak;\n\n\t\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_GetCurrentSocclkIndex, &now);\n\n\t\tfor (i = 0; i < soc_table->count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, soc_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(i == now) ? \"*\" : \"\");\n\t\tbreak;\n\tcase PP_DCEFCLK:\n\t\tif (data->registry_data.dcefclk_dpm_key_disabled)\n\t\t\tbreak;\n\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_GetClockFreqMHz, CLK_DCEFCLK, &now);\n\n\t\tfor (i = 0; i < dcef_table->count; i++)\n\t\t\tsize += sprintf(buf + size, \"%d: %uMhz %s\\n\",\n\t\t\t\t\ti, dcef_table->dpm_levels[i].value / 100,\n\t\t\t\t\t(dcef_table->dpm_levels[i].value / 100 == now) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\tbreak;\n\tcase PP_PCIE:\n\t\tcurrent_gen_speed =\n\t\t\tvega10_get_current_pcie_link_speed_level(hwmgr);\n\t\tcurrent_lane_width =\n\t\t\tvega10_get_current_pcie_link_width_level(hwmgr);\n\t\tfor (i = 0; i < NUM_LINK_LEVELS; i++) {\n\t\t\tgen_speed = pptable->PcieGenSpeed[i];\n\t\t\tlane_width = pptable->PcieLaneCount[i];\n\n\t\t\tsize += sprintf(buf + size, \"%d: %s %s %s\\n\", i,\n\t\t\t\t\t(gen_speed == 0) ? \"2.5GT/s,\" :\n\t\t\t\t\t(gen_speed == 1) ? \"5.0GT/s,\" :\n\t\t\t\t\t(gen_speed == 2) ? \"8.0GT/s,\" :\n\t\t\t\t\t(gen_speed == 3) ? \"16.0GT/s,\" : \"\",\n\t\t\t\t\t(lane_width == 1) ? \"x1\" :\n\t\t\t\t\t(lane_width == 2) ? \"x2\" :\n\t\t\t\t\t(lane_width == 3) ? \"x4\" :\n\t\t\t\t\t(lane_width == 4) ? \"x8\" :\n\t\t\t\t\t(lane_width == 5) ? \"x12\" :\n\t\t\t\t\t(lane_width == 6) ? \"x16\" : \"\",\n\t\t\t\t\t(current_gen_speed == gen_speed) &&\n\t\t\t\t\t(current_lane_width == lane_width) ?\n\t\t\t\t\t\"*\" : \"\");\n\t\t}\n\t\tbreak;\n\n\tcase OD_SCLK:\n\t\tif (hwmgr->od_enabled) {\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_SCLK\");\n\t\t\tpodn_vdd_dep = &data->odn_dpm_table.vdd_dep_on_sclk;\n\t\t\tfor (i = 0; i < podn_vdd_dep->count; i++)\n\t\t\t\tsize += sprintf(buf + size, \"%d: %10uMhz %10umV\\n\",\n\t\t\t\t\ti, podn_vdd_dep->entries[i].clk / 100,\n\t\t\t\t\t\tpodn_vdd_dep->entries[i].vddc);\n\t\t}\n\t\tbreak;\n\tcase OD_MCLK:\n\t\tif (hwmgr->od_enabled) {\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_MCLK\");\n\t\t\tpodn_vdd_dep = &data->odn_dpm_table.vdd_dep_on_mclk;\n\t\t\tfor (i = 0; i < podn_vdd_dep->count; i++)\n\t\t\t\tsize += sprintf(buf + size, \"%d: %10uMhz %10umV\\n\",\n\t\t\t\t\ti, podn_vdd_dep->entries[i].clk/100,\n\t\t\t\t\t\tpodn_vdd_dep->entries[i].vddc);\n\t\t}\n\t\tbreak;\n\tcase OD_RANGE:\n\t\tif (hwmgr->od_enabled) {\n\t\t\tsize += sprintf(buf + size, \"%s:\\n\", \"OD_RANGE\");\n\t\t\tsize += sprintf(buf + size, \"SCLK: %7uMHz %10uMHz\\n\",\n\t\t\t\tdata->golden_dpm_table.gfx_table.dpm_levels[0].value/100,\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock/100);\n\t\t\tsize += sprintf(buf + size, \"MCLK: %7uMHz %10uMHz\\n\",\n\t\t\t\tdata->golden_dpm_table.mem_table.dpm_levels[0].value/100,\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock/100);\n\t\t\tsize += sprintf(buf + size, \"VDDC: %7umV %11umV\\n\",\n\t\t\t\tdata->odn_dpm_table.min_vddc,\n\t\t\t\tdata->odn_dpm_table.max_vddc);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn size;\n}\n\nstatic int vega10_display_configuration_changed_task(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tWatermarks_t *wm_table = &(data->smc_state_table.water_marks_table);\n\tint result = 0;\n\n\tif ((data->water_marks_bitmap & WaterMarksExist) &&\n\t\t\t!(data->water_marks_bitmap & WaterMarksLoaded)) {\n\t\tresult = smum_smc_table_manager(hwmgr, (uint8_t *)wm_table, WMTABLE, false);\n\t\tPP_ASSERT_WITH_CODE(result, \"Failed to update WMTABLE!\", return -EINVAL);\n\t\tdata->water_marks_bitmap |= WaterMarksLoaded;\n\t}\n\n\tif (data->water_marks_bitmap & WaterMarksLoaded) {\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_NumOfDisplays, hwmgr->display_config->num_display,\n\t\t\tNULL);\n\t}\n\n\treturn result;\n}\n\nstatic int vega10_enable_disable_uvd_dpm(struct pp_hwmgr *hwmgr, bool enable)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tif (data->smu_features[GNLD_DPM_UVD].supported) {\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\tenable,\n\t\t\t\tdata->smu_features[GNLD_DPM_UVD].smu_feature_bitmap),\n\t\t\t\t\"Attempt to Enable/Disable DPM UVD Failed!\",\n\t\t\t\treturn -1);\n\t\tdata->smu_features[GNLD_DPM_UVD].enabled = enable;\n\t}\n\treturn 0;\n}\n\nstatic void vega10_power_gate_vce(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->vce_power_gated = bgate;\n\tvega10_enable_disable_vce_dpm(hwmgr, !bgate);\n}\n\nstatic void vega10_power_gate_uvd(struct pp_hwmgr *hwmgr, bool bgate)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\n\tdata->uvd_power_gated = bgate;\n\tvega10_enable_disable_uvd_dpm(hwmgr, !bgate);\n}\n\nstatic inline bool vega10_are_power_levels_equal(\n\t\t\t\tconst struct vega10_performance_level *pl1,\n\t\t\t\tconst struct vega10_performance_level *pl2)\n{\n\treturn ((pl1->soc_clock == pl2->soc_clock) &&\n\t\t\t(pl1->gfx_clock == pl2->gfx_clock) &&\n\t\t\t(pl1->mem_clock == pl2->mem_clock));\n}\n\nstatic int vega10_check_states_equal(struct pp_hwmgr *hwmgr,\n\t\t\t\tconst struct pp_hw_power_state *pstate1,\n\t\t\tconst struct pp_hw_power_state *pstate2, bool *equal)\n{\n\tconst struct vega10_power_state *vega10_psa;\n\tconst struct vega10_power_state *vega10_psb;\n\tint i;\n\n\tif (pstate1 == NULL || pstate2 == NULL || equal == NULL)\n\t\treturn -EINVAL;\n\n\tvega10_psa = cast_const_phw_vega10_power_state(pstate1);\n\tvega10_psb = cast_const_phw_vega10_power_state(pstate2);\n\n\t \n\tif (vega10_psa->performance_level_count != vega10_psb->performance_level_count) {\n\t\t*equal = false;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < vega10_psa->performance_level_count; i++) {\n\t\tif (!vega10_are_power_levels_equal(&(vega10_psa->performance_levels[i]),\n\t\t\t\t\t\t   &(vega10_psb->performance_levels[i]))) {\n\t\t\t \n\t\t\t*equal = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\t*equal = ((vega10_psa->uvd_clks.vclk == vega10_psb->uvd_clks.vclk) &&\n\t\t  (vega10_psa->uvd_clks.dclk == vega10_psb->uvd_clks.dclk));\n\t*equal &= ((vega10_psa->vce_clks.evclk == vega10_psb->vce_clks.evclk) &&\n\t\t   (vega10_psa->vce_clks.ecclk == vega10_psb->vce_clks.ecclk));\n\t*equal &= (vega10_psa->sclk_threshold == vega10_psb->sclk_threshold);\n\n\treturn 0;\n}\n\nstatic bool\nvega10_check_smc_update_required_for_display_configuration(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tbool is_update_required = false;\n\n\tif (data->display_timing.num_existing_displays != hwmgr->display_config->num_display)\n\t\tis_update_required = true;\n\n\tif (PP_CAP(PHM_PlatformCaps_SclkDeepSleep)) {\n\t\tif (data->display_timing.min_clock_in_sr != hwmgr->display_config->min_core_set_clock_in_sr)\n\t\t\tis_update_required = true;\n\t}\n\n\treturn is_update_required;\n}\n\nstatic int vega10_disable_dpm_tasks(struct pp_hwmgr *hwmgr)\n{\n\tint tmp_result, result = 0;\n\n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tif (PP_CAP(PHM_PlatformCaps_ThermalController))\n\t\tvega10_disable_thermal_protection(hwmgr);\n\n\ttmp_result = vega10_disable_power_containment(hwmgr);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to disable power containment!\", result = tmp_result);\n\n\ttmp_result = vega10_disable_didt_config(hwmgr);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to disable didt config!\", result = tmp_result);\n\n\ttmp_result = vega10_avfs_enable(hwmgr, false);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to disable AVFS!\", result = tmp_result);\n\n\ttmp_result = vega10_stop_dpm(hwmgr, SMC_DPM_FEATURES);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to stop DPM!\", result = tmp_result);\n\n\ttmp_result = vega10_disable_deep_sleep_master_switch(hwmgr);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to disable deep sleep!\", result = tmp_result);\n\n\ttmp_result = vega10_disable_ulv(hwmgr);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to disable ulv!\", result = tmp_result);\n\n\ttmp_result =  vega10_acg_disable(hwmgr);\n\tPP_ASSERT_WITH_CODE((tmp_result == 0),\n\t\t\t\"Failed to disable acg!\", result = tmp_result);\n\n\tvega10_enable_disable_PCC_limit_feature(hwmgr, false);\n\treturn result;\n}\n\nstatic int vega10_power_off_asic(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tint result;\n\n\tresult = vega10_disable_dpm_tasks(hwmgr);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"[disable_dpm_tasks] Failed to disable DPM!\",\n\t\t\t);\n\tdata->water_marks_bitmap &= ~(WaterMarksLoaded);\n\n\treturn result;\n}\n\nstatic int vega10_get_sclk_od(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *sclk_table = &(data->dpm_table.gfx_table);\n\tstruct vega10_single_dpm_table *golden_sclk_table =\n\t\t\t&(data->golden_dpm_table.gfx_table);\n\tint value = sclk_table->dpm_levels[sclk_table->count - 1].value;\n\tint golden_value = golden_sclk_table->dpm_levels\n\t\t\t[golden_sclk_table->count - 1].value;\n\n\tvalue -= golden_value;\n\tvalue = DIV_ROUND_UP(value * 100, golden_value);\n\n\treturn value;\n}\n\nstatic int vega10_set_sclk_od(struct pp_hwmgr *hwmgr, uint32_t value)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *golden_sclk_table =\n\t\t\t&(data->golden_dpm_table.gfx_table);\n\tstruct pp_power_state *ps;\n\tstruct vega10_power_state *vega10_ps;\n\n\tps = hwmgr->request_ps;\n\n\tif (ps == NULL)\n\t\treturn -EINVAL;\n\n\tvega10_ps = cast_phw_vega10_power_state(&ps->hardware);\n\n\tvega10_ps->performance_levels\n\t[vega10_ps->performance_level_count - 1].gfx_clock =\n\t\t\tgolden_sclk_table->dpm_levels\n\t\t\t[golden_sclk_table->count - 1].value *\n\t\t\tvalue / 100 +\n\t\t\tgolden_sclk_table->dpm_levels\n\t\t\t[golden_sclk_table->count - 1].value;\n\n\tif (vega10_ps->performance_levels\n\t\t\t[vega10_ps->performance_level_count - 1].gfx_clock >\n\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock) {\n\t\tvega10_ps->performance_levels\n\t\t[vega10_ps->performance_level_count - 1].gfx_clock =\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock;\n\t\tpr_warn(\"max sclk supported by vbios is %d\\n\",\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock);\n\t}\n\treturn 0;\n}\n\nstatic int vega10_get_mclk_od(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *mclk_table = &(data->dpm_table.mem_table);\n\tstruct vega10_single_dpm_table *golden_mclk_table =\n\t\t\t&(data->golden_dpm_table.mem_table);\n\tint value = mclk_table->dpm_levels[mclk_table->count - 1].value;\n\tint golden_value = golden_mclk_table->dpm_levels\n\t\t\t[golden_mclk_table->count - 1].value;\n\n\tvalue -= golden_value;\n\tvalue = DIV_ROUND_UP(value * 100, golden_value);\n\n\treturn value;\n}\n\nstatic int vega10_set_mclk_od(struct pp_hwmgr *hwmgr, uint32_t value)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_single_dpm_table *golden_mclk_table =\n\t\t\t&(data->golden_dpm_table.mem_table);\n\tstruct pp_power_state  *ps;\n\tstruct vega10_power_state  *vega10_ps;\n\n\tps = hwmgr->request_ps;\n\n\tif (ps == NULL)\n\t\treturn -EINVAL;\n\n\tvega10_ps = cast_phw_vega10_power_state(&ps->hardware);\n\n\tvega10_ps->performance_levels\n\t[vega10_ps->performance_level_count - 1].mem_clock =\n\t\t\tgolden_mclk_table->dpm_levels\n\t\t\t[golden_mclk_table->count - 1].value *\n\t\t\tvalue / 100 +\n\t\t\tgolden_mclk_table->dpm_levels\n\t\t\t[golden_mclk_table->count - 1].value;\n\n\tif (vega10_ps->performance_levels\n\t\t\t[vega10_ps->performance_level_count - 1].mem_clock >\n\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock) {\n\t\tvega10_ps->performance_levels\n\t\t[vega10_ps->performance_level_count - 1].mem_clock =\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock;\n\t\tpr_warn(\"max mclk supported by vbios is %d\\n\",\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock);\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_notify_cac_buffer_info(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t virtual_addr_low,\n\t\t\t\t\tuint32_t virtual_addr_hi,\n\t\t\t\t\tuint32_t mc_addr_low,\n\t\t\t\t\tuint32_t mc_addr_hi,\n\t\t\t\t\tuint32_t size)\n{\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSystemVirtualDramAddrHigh,\n\t\t\t\t\tvirtual_addr_hi,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetSystemVirtualDramAddrLow,\n\t\t\t\t\tvirtual_addr_low,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramLogSetDramAddrHigh,\n\t\t\t\t\tmc_addr_hi,\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramLogSetDramAddrLow,\n\t\t\t\t\tmc_addr_low,\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DramLogSetDramSize,\n\t\t\t\t\tsize,\n\t\t\t\t\tNULL);\n\treturn 0;\n}\n\nstatic int vega10_get_thermal_temperature_range(struct pp_hwmgr *hwmgr,\n\t\tstruct PP_TemperatureRange *thermal_data)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tPPTable_t *pp_table = &(data->smc_state_table.pp_table);\n\tstruct phm_ppt_v2_information *pp_table_info =\n\t\t(struct phm_ppt_v2_information *)(hwmgr->pptable);\n\tstruct phm_tdp_table *tdp_table = pp_table_info->tdp_table;\n\n\tmemcpy(thermal_data, &SMU7ThermalWithDelayPolicy[0], sizeof(struct PP_TemperatureRange));\n\n\tthermal_data->max = pp_table->TedgeLimit *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->edge_emergency_max = (pp_table->TedgeLimit + CTF_OFFSET_EDGE) *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->hotspot_crit_max = pp_table->ThotspotLimit *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->hotspot_emergency_max = (pp_table->ThotspotLimit + CTF_OFFSET_HOTSPOT) *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->mem_crit_max = pp_table->ThbmLimit *\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\tthermal_data->mem_emergency_max = (pp_table->ThbmLimit + CTF_OFFSET_HBM)*\n\t\tPP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\tif (tdp_table->usSoftwareShutdownTemp > pp_table->ThotspotLimit &&\n\t    tdp_table->usSoftwareShutdownTemp < VEGA10_THERMAL_MAXIMUM_ALERT_TEMP)\n\t\tthermal_data->sw_ctf_threshold = tdp_table->usSoftwareShutdownTemp;\n\telse\n\t\tthermal_data->sw_ctf_threshold = VEGA10_THERMAL_MAXIMUM_ALERT_TEMP;\n\tthermal_data->sw_ctf_threshold *= PP_TEMPERATURE_UNITS_PER_CENTIGRADES;\n\n\treturn 0;\n}\n\nstatic int vega10_get_power_profile_mode(struct pp_hwmgr *hwmgr, char *buf)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t i, size = 0;\n\tstatic const uint8_t profile_mode_setting[6][4] = {{70, 60, 0, 0,},\n\t\t\t\t\t\t{70, 60, 1, 3,},\n\t\t\t\t\t\t{90, 60, 0, 0,},\n\t\t\t\t\t\t{70, 60, 0, 0,},\n\t\t\t\t\t\t{70, 90, 0, 0,},\n\t\t\t\t\t\t{30, 60, 0, 6,},\n\t\t\t\t\t\t};\n\tstatic const char *title[6] = {\"NUM\",\n\t\t\t\"MODE_NAME\",\n\t\t\t\"BUSY_SET_POINT\",\n\t\t\t\"FPS\",\n\t\t\t\"USE_RLC_BUSY\",\n\t\t\t\"MIN_ACTIVE_LEVEL\"};\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tphm_get_sysfs_buf(&buf, &size);\n\n\tsize += sysfs_emit_at(buf, size, \"%s %16s %s %s %s %s\\n\",title[0],\n\t\t\ttitle[1], title[2], title[3], title[4], title[5]);\n\n\tfor (i = 0; i < PP_SMC_POWER_PROFILE_CUSTOM; i++)\n\t\tsize += sysfs_emit_at(buf, size, \"%3d %14s%s: %14d %3d %10d %14d\\n\",\n\t\t\ti, amdgpu_pp_profile_name[i], (i == hwmgr->power_profile_mode) ? \"*\" : \" \",\n\t\t\tprofile_mode_setting[i][0], profile_mode_setting[i][1],\n\t\t\tprofile_mode_setting[i][2], profile_mode_setting[i][3]);\n\n\tsize += sysfs_emit_at(buf, size, \"%3d %14s%s: %14d %3d %10d %14d\\n\", i,\n\t\t\tamdgpu_pp_profile_name[i], (i == hwmgr->power_profile_mode) ? \"*\" : \" \",\n\t\t\tdata->custom_profile_mode[0], data->custom_profile_mode[1],\n\t\t\tdata->custom_profile_mode[2], data->custom_profile_mode[3]);\n\treturn size;\n}\n\nstatic bool vega10_get_power_profile_mode_quirks(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn (adev->pdev->device == 0x6860);\n}\n\nstatic int vega10_set_power_profile_mode(struct pp_hwmgr *hwmgr, long *input, uint32_t size)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint8_t busy_set_point;\n\tuint8_t FPS;\n\tuint8_t use_rlc_busy;\n\tuint8_t min_active_level;\n\tuint32_t power_profile_mode = input[size];\n\n\tif (power_profile_mode == PP_SMC_POWER_PROFILE_CUSTOM) {\n\t\tif (size != 0 && size != 4)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (size == 0) {\n\t\t\tif (data->custom_profile_mode[0] != 0)\n\t\t\t\tgoto out;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdata->custom_profile_mode[0] = busy_set_point = input[0];\n\t\tdata->custom_profile_mode[1] = FPS = input[1];\n\t\tdata->custom_profile_mode[2] = use_rlc_busy = input[2];\n\t\tdata->custom_profile_mode[3] = min_active_level = input[3];\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetCustomGfxDpmParameters,\n\t\t\t\t\tbusy_set_point | FPS<<8 |\n\t\t\t\t\tuse_rlc_busy << 16 | min_active_level<<24,\n\t\t\t\t\tNULL);\n\t}\n\nout:\n\tif (vega10_get_power_profile_mode_quirks(hwmgr))\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_SetWorkloadMask,\n\t\t\t\t\t\t1 << power_profile_mode,\n\t\t\t\t\t\tNULL);\n\telse\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_SetWorkloadMask,\n\t\t\t\t\t\t(!power_profile_mode) ? 0 : 1 << (power_profile_mode - 1),\n\t\t\t\t\t\tNULL);\n\n\thwmgr->power_profile_mode = power_profile_mode;\n\n\treturn 0;\n}\n\n\nstatic bool vega10_check_clk_voltage_valid(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tuint32_t clk,\n\t\t\t\t\tuint32_t voltage)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_odn_dpm_table *odn_table = &(data->odn_dpm_table);\n\tstruct vega10_single_dpm_table *golden_table;\n\n\tif (voltage < odn_table->min_vddc || voltage > odn_table->max_vddc) {\n\t\tpr_info(\"OD voltage is out of range [%d - %d] mV\\n\", odn_table->min_vddc, odn_table->max_vddc);\n\t\treturn false;\n\t}\n\n\tif (type == PP_OD_EDIT_SCLK_VDDC_TABLE) {\n\t\tgolden_table = &(data->golden_dpm_table.gfx_table);\n\t\tif (golden_table->dpm_levels[0].value > clk ||\n\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock < clk) {\n\t\t\tpr_info(\"OD engine clock is out of range [%d - %d] MHz\\n\",\n\t\t\t\tgolden_table->dpm_levels[0].value/100,\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.engineClock/100);\n\t\t\treturn false;\n\t\t}\n\t} else if (type == PP_OD_EDIT_MCLK_VDDC_TABLE) {\n\t\tgolden_table = &(data->golden_dpm_table.mem_table);\n\t\tif (golden_table->dpm_levels[0].value > clk ||\n\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock < clk) {\n\t\t\tpr_info(\"OD memory clock is out of range [%d - %d] MHz\\n\",\n\t\t\t\tgolden_table->dpm_levels[0].value/100,\n\t\t\t\thwmgr->platform_descriptor.overdriveLimit.memoryClock/100);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void vega10_odn_update_power_state(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct pp_power_state *ps = hwmgr->request_ps;\n\tstruct vega10_power_state *vega10_ps;\n\tstruct vega10_single_dpm_table *gfx_dpm_table =\n\t\t&data->dpm_table.gfx_table;\n\tstruct vega10_single_dpm_table *soc_dpm_table =\n\t\t&data->dpm_table.soc_table;\n\tstruct vega10_single_dpm_table *mem_dpm_table =\n\t\t&data->dpm_table.mem_table;\n\tint max_level;\n\n\tif (!ps)\n\t\treturn;\n\n\tvega10_ps = cast_phw_vega10_power_state(&ps->hardware);\n\tmax_level = vega10_ps->performance_level_count - 1;\n\n\tif (vega10_ps->performance_levels[max_level].gfx_clock !=\n\t    gfx_dpm_table->dpm_levels[gfx_dpm_table->count - 1].value)\n\t\tvega10_ps->performance_levels[max_level].gfx_clock =\n\t\t\tgfx_dpm_table->dpm_levels[gfx_dpm_table->count - 1].value;\n\n\tif (vega10_ps->performance_levels[max_level].soc_clock !=\n\t    soc_dpm_table->dpm_levels[soc_dpm_table->count - 1].value)\n\t\tvega10_ps->performance_levels[max_level].soc_clock =\n\t\t\tsoc_dpm_table->dpm_levels[soc_dpm_table->count - 1].value;\n\n\tif (vega10_ps->performance_levels[max_level].mem_clock !=\n\t    mem_dpm_table->dpm_levels[mem_dpm_table->count - 1].value)\n\t\tvega10_ps->performance_levels[max_level].mem_clock =\n\t\t\tmem_dpm_table->dpm_levels[mem_dpm_table->count - 1].value;\n\n\tif (!hwmgr->ps)\n\t\treturn;\n\n\tps = (struct pp_power_state *)((unsigned long)(hwmgr->ps) + hwmgr->ps_size * (hwmgr->num_ps - 1));\n\tvega10_ps = cast_phw_vega10_power_state(&ps->hardware);\n\tmax_level = vega10_ps->performance_level_count - 1;\n\n\tif (vega10_ps->performance_levels[max_level].gfx_clock !=\n\t    gfx_dpm_table->dpm_levels[gfx_dpm_table->count - 1].value)\n\t\tvega10_ps->performance_levels[max_level].gfx_clock =\n\t\t\tgfx_dpm_table->dpm_levels[gfx_dpm_table->count - 1].value;\n\n\tif (vega10_ps->performance_levels[max_level].soc_clock !=\n\t    soc_dpm_table->dpm_levels[soc_dpm_table->count - 1].value)\n\t\tvega10_ps->performance_levels[max_level].soc_clock =\n\t\t\tsoc_dpm_table->dpm_levels[soc_dpm_table->count - 1].value;\n\n\tif (vega10_ps->performance_levels[max_level].mem_clock !=\n\t    mem_dpm_table->dpm_levels[mem_dpm_table->count - 1].value)\n\t\tvega10_ps->performance_levels[max_level].mem_clock =\n\t\t\tmem_dpm_table->dpm_levels[mem_dpm_table->count - 1].value;\n}\n\nstatic void vega10_odn_update_soc_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct phm_ppt_v2_information *table_info = hwmgr->pptable;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table = table_info->vdd_dep_on_socclk;\n\tstruct vega10_single_dpm_table *dpm_table = &data->golden_dpm_table.mem_table;\n\n\tstruct vega10_odn_clock_voltage_dependency_table *podn_vdd_dep_on_socclk =\n\t\t\t\t\t\t\t&data->odn_dpm_table.vdd_dep_on_socclk;\n\tstruct vega10_odn_vddc_lookup_table *od_vddc_lookup_table = &data->odn_dpm_table.vddc_lookup_table;\n\n\tstruct vega10_odn_clock_voltage_dependency_table *podn_vdd_dep;\n\tuint8_t i, j;\n\n\tif (type == PP_OD_EDIT_SCLK_VDDC_TABLE) {\n\t\tpodn_vdd_dep = &data->odn_dpm_table.vdd_dep_on_sclk;\n\t\tfor (i = 0; i < podn_vdd_dep->count; i++)\n\t\t\tod_vddc_lookup_table->entries[i].us_vdd = podn_vdd_dep->entries[i].vddc;\n\t} else if (type == PP_OD_EDIT_MCLK_VDDC_TABLE) {\n\t\tpodn_vdd_dep = &data->odn_dpm_table.vdd_dep_on_mclk;\n\t\tfor (i = 0; i < dpm_table->count; i++) {\n\t\t\tfor (j = 0; j < od_vddc_lookup_table->count; j++) {\n\t\t\t\tif (od_vddc_lookup_table->entries[j].us_vdd >\n\t\t\t\t\tpodn_vdd_dep->entries[i].vddc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == od_vddc_lookup_table->count) {\n\t\t\t\tj = od_vddc_lookup_table->count - 1;\n\t\t\t\tod_vddc_lookup_table->entries[j].us_vdd =\n\t\t\t\t\tpodn_vdd_dep->entries[i].vddc;\n\t\t\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_VDDC;\n\t\t\t}\n\t\t\tpodn_vdd_dep->entries[i].vddInd = j;\n\t\t}\n\t\tdpm_table = &data->dpm_table.soc_table;\n\t\tfor (i = 0; i < dep_table->count; i++) {\n\t\t\tif (dep_table->entries[i].vddInd == podn_vdd_dep->entries[podn_vdd_dep->count-1].vddInd &&\n\t\t\t\t\tdep_table->entries[i].clk < podn_vdd_dep->entries[podn_vdd_dep->count-1].clk) {\n\t\t\t\tdata->need_update_dpm_table |= DPMTABLE_UPDATE_SOCCLK;\n\t\t\t\tfor (; (i < dep_table->count) &&\n\t\t\t\t       (dep_table->entries[i].clk < podn_vdd_dep->entries[podn_vdd_dep->count - 1].clk); i++) {\n\t\t\t\t\tpodn_vdd_dep_on_socclk->entries[i].clk = podn_vdd_dep->entries[podn_vdd_dep->count-1].clk;\n\t\t\t\t\tdpm_table->dpm_levels[i].value = podn_vdd_dep_on_socclk->entries[i].clk;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdpm_table->dpm_levels[i].value = dep_table->entries[i].clk;\n\t\t\t\tpodn_vdd_dep_on_socclk->entries[i].vddc = dep_table->entries[i].vddc;\n\t\t\t\tpodn_vdd_dep_on_socclk->entries[i].vddInd = dep_table->entries[i].vddInd;\n\t\t\t\tpodn_vdd_dep_on_socclk->entries[i].clk = dep_table->entries[i].clk;\n\t\t\t}\n\t\t}\n\t\tif (podn_vdd_dep_on_socclk->entries[podn_vdd_dep_on_socclk->count - 1].clk <\n\t\t\t\t\tpodn_vdd_dep->entries[podn_vdd_dep->count - 1].clk) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_UPDATE_SOCCLK;\n\t\t\tpodn_vdd_dep_on_socclk->entries[podn_vdd_dep_on_socclk->count - 1].clk =\n\t\t\t\tpodn_vdd_dep->entries[podn_vdd_dep->count - 1].clk;\n\t\t\tdpm_table->dpm_levels[podn_vdd_dep_on_socclk->count - 1].value =\n\t\t\t\tpodn_vdd_dep->entries[podn_vdd_dep->count - 1].clk;\n\t\t}\n\t\tif (podn_vdd_dep_on_socclk->entries[podn_vdd_dep_on_socclk->count - 1].vddInd <\n\t\t\t\t\tpodn_vdd_dep->entries[podn_vdd_dep->count - 1].vddInd) {\n\t\t\tdata->need_update_dpm_table |= DPMTABLE_UPDATE_SOCCLK;\n\t\t\tpodn_vdd_dep_on_socclk->entries[podn_vdd_dep_on_socclk->count - 1].vddInd =\n\t\t\t\tpodn_vdd_dep->entries[podn_vdd_dep->count - 1].vddInd;\n\t\t}\n\t}\n\tvega10_odn_update_power_state(hwmgr);\n}\n\nstatic int vega10_odn_edit_dpm_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t\tlong *input, uint32_t size)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tstruct vega10_odn_clock_voltage_dependency_table *podn_vdd_dep_table;\n\tstruct vega10_single_dpm_table *dpm_table;\n\n\tuint32_t input_clk;\n\tuint32_t input_vol;\n\tuint32_t input_level;\n\tuint32_t i;\n\n\tPP_ASSERT_WITH_CODE(input, \"NULL user input for clock and voltage\",\n\t\t\t\treturn -EINVAL);\n\n\tif (!hwmgr->od_enabled) {\n\t\tpr_info(\"OverDrive feature not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (PP_OD_EDIT_SCLK_VDDC_TABLE == type) {\n\t\tdpm_table = &data->dpm_table.gfx_table;\n\t\tpodn_vdd_dep_table = &data->odn_dpm_table.vdd_dep_on_sclk;\n\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_SCLK;\n\t} else if (PP_OD_EDIT_MCLK_VDDC_TABLE == type) {\n\t\tdpm_table = &data->dpm_table.mem_table;\n\t\tpodn_vdd_dep_table = &data->odn_dpm_table.vdd_dep_on_mclk;\n\t\tdata->need_update_dpm_table |= DPMTABLE_OD_UPDATE_MCLK;\n\t} else if (PP_OD_RESTORE_DEFAULT_TABLE == type) {\n\t\tmemcpy(&(data->dpm_table), &(data->golden_dpm_table), sizeof(struct vega10_dpm_table));\n\t\tvega10_odn_initial_default_setting(hwmgr);\n\t\tvega10_odn_update_power_state(hwmgr);\n\t\t \n\t\tdata->need_update_dpm_table = DPMTABLE_UPDATE_SCLK |\n\t\t\t\t\t      DPMTABLE_UPDATE_MCLK |\n\t\t\t\t\t      DPMTABLE_UPDATE_SOCCLK;\n\t\treturn 0;\n\t} else if (PP_OD_COMMIT_DPM_TABLE == type) {\n\t\tvega10_check_dpm_table_updated(hwmgr);\n\t\treturn 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < size; i += 3) {\n\t\tif (i + 3 > size || input[i] >= podn_vdd_dep_table->count) {\n\t\t\tpr_info(\"invalid clock voltage input\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tinput_level = input[i];\n\t\tinput_clk = input[i+1] * 100;\n\t\tinput_vol = input[i+2];\n\n\t\tif (vega10_check_clk_voltage_valid(hwmgr, type, input_clk, input_vol)) {\n\t\t\tdpm_table->dpm_levels[input_level].value = input_clk;\n\t\t\tpodn_vdd_dep_table->entries[input_level].clk = input_clk;\n\t\t\tpodn_vdd_dep_table->entries[input_level].vddc = input_vol;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tvega10_odn_update_soc_table(hwmgr, type);\n\treturn 0;\n}\n\nstatic int vega10_set_mp1_state(struct pp_hwmgr *hwmgr,\n\t\t\t\tenum pp_mp1_state mp1_state)\n{\n\tuint16_t msg;\n\tint ret;\n\n\tswitch (mp1_state) {\n\tcase PP_MP1_STATE_UNLOAD:\n\t\tmsg = PPSMC_MSG_PrepareMp1ForUnload;\n\t\tbreak;\n\tcase PP_MP1_STATE_SHUTDOWN:\n\tcase PP_MP1_STATE_RESET:\n\tcase PP_MP1_STATE_NONE:\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc(hwmgr, msg, NULL)) == 0,\n\t\t\t    \"[PrepareMp1] Failed!\",\n\t\t\t    return ret);\n\n\treturn 0;\n}\n\nstatic int vega10_get_performance_level(struct pp_hwmgr *hwmgr, const struct pp_hw_power_state *state,\n\t\t\t\tPHM_PerformanceLevelDesignation designation, uint32_t index,\n\t\t\t\tPHM_PerformanceLevel *level)\n{\n\tconst struct vega10_power_state *vega10_ps;\n\tuint32_t i;\n\n\tif (level == NULL || hwmgr == NULL || state == NULL)\n\t\treturn -EINVAL;\n\n\tvega10_ps = cast_const_phw_vega10_power_state(state);\n\n\ti = index > vega10_ps->performance_level_count - 1 ?\n\t\t\tvega10_ps->performance_level_count - 1 : index;\n\n\tlevel->coreClock = vega10_ps->performance_levels[i].gfx_clock;\n\tlevel->memory_clock = vega10_ps->performance_levels[i].mem_clock;\n\n\treturn 0;\n}\n\nstatic int vega10_disable_power_features_for_compute_performance(struct pp_hwmgr *hwmgr, bool disable)\n{\n\tstruct vega10_hwmgr *data = hwmgr->backend;\n\tuint32_t feature_mask = 0;\n\n\tif (disable) {\n\t\tfeature_mask |= data->smu_features[GNLD_ULV].enabled ?\n\t\t\tdata->smu_features[GNLD_ULV].smu_feature_bitmap : 0;\n\t\tfeature_mask |= data->smu_features[GNLD_DS_GFXCLK].enabled ?\n\t\t\tdata->smu_features[GNLD_DS_GFXCLK].smu_feature_bitmap : 0;\n\t\tfeature_mask |= data->smu_features[GNLD_DS_SOCCLK].enabled ?\n\t\t\tdata->smu_features[GNLD_DS_SOCCLK].smu_feature_bitmap : 0;\n\t\tfeature_mask |= data->smu_features[GNLD_DS_LCLK].enabled ?\n\t\t\tdata->smu_features[GNLD_DS_LCLK].smu_feature_bitmap : 0;\n\t\tfeature_mask |= data->smu_features[GNLD_DS_DCEFCLK].enabled ?\n\t\t\tdata->smu_features[GNLD_DS_DCEFCLK].smu_feature_bitmap : 0;\n\t} else {\n\t\tfeature_mask |= (!data->smu_features[GNLD_ULV].enabled) ?\n\t\t\tdata->smu_features[GNLD_ULV].smu_feature_bitmap : 0;\n\t\tfeature_mask |= (!data->smu_features[GNLD_DS_GFXCLK].enabled) ?\n\t\t\tdata->smu_features[GNLD_DS_GFXCLK].smu_feature_bitmap : 0;\n\t\tfeature_mask |= (!data->smu_features[GNLD_DS_SOCCLK].enabled) ?\n\t\t\tdata->smu_features[GNLD_DS_SOCCLK].smu_feature_bitmap : 0;\n\t\tfeature_mask |= (!data->smu_features[GNLD_DS_LCLK].enabled) ?\n\t\t\tdata->smu_features[GNLD_DS_LCLK].smu_feature_bitmap : 0;\n\t\tfeature_mask |= (!data->smu_features[GNLD_DS_DCEFCLK].enabled) ?\n\t\t\tdata->smu_features[GNLD_DS_DCEFCLK].smu_feature_bitmap : 0;\n\t}\n\n\tif (feature_mask)\n\t\tPP_ASSERT_WITH_CODE(!vega10_enable_smc_features(hwmgr,\n\t\t\t\t!disable, feature_mask),\n\t\t\t\t\"enable/disable power features for compute performance Failed!\",\n\t\t\t\treturn -EINVAL);\n\n\tif (disable) {\n\t\tdata->smu_features[GNLD_ULV].enabled = false;\n\t\tdata->smu_features[GNLD_DS_GFXCLK].enabled = false;\n\t\tdata->smu_features[GNLD_DS_SOCCLK].enabled = false;\n\t\tdata->smu_features[GNLD_DS_LCLK].enabled = false;\n\t\tdata->smu_features[GNLD_DS_DCEFCLK].enabled = false;\n\t} else {\n\t\tdata->smu_features[GNLD_ULV].enabled = true;\n\t\tdata->smu_features[GNLD_DS_GFXCLK].enabled = true;\n\t\tdata->smu_features[GNLD_DS_SOCCLK].enabled = true;\n\t\tdata->smu_features[GNLD_DS_LCLK].enabled = true;\n\t\tdata->smu_features[GNLD_DS_DCEFCLK].enabled = true;\n\t}\n\n\treturn 0;\n\n}\n\nstatic const struct pp_hwmgr_func vega10_hwmgr_funcs = {\n\t.backend_init = vega10_hwmgr_backend_init,\n\t.backend_fini = vega10_hwmgr_backend_fini,\n\t.asic_setup = vega10_setup_asic_task,\n\t.dynamic_state_management_enable = vega10_enable_dpm_tasks,\n\t.dynamic_state_management_disable = vega10_disable_dpm_tasks,\n\t.get_num_of_pp_table_entries =\n\t\t\tvega10_get_number_of_powerplay_table_entries,\n\t.get_power_state_size = vega10_get_power_state_size,\n\t.get_pp_table_entry = vega10_get_pp_table_entry,\n\t.patch_boot_state = vega10_patch_boot_state,\n\t.apply_state_adjust_rules = vega10_apply_state_adjust_rules,\n\t.power_state_set = vega10_set_power_state_tasks,\n\t.get_sclk = vega10_dpm_get_sclk,\n\t.get_mclk = vega10_dpm_get_mclk,\n\t.notify_smc_display_config_after_ps_adjustment =\n\t\t\tvega10_notify_smc_display_config_after_ps_adjustment,\n\t.force_dpm_level = vega10_dpm_force_dpm_level,\n\t.stop_thermal_controller = vega10_thermal_stop_thermal_controller,\n\t.get_fan_speed_info = vega10_fan_ctrl_get_fan_speed_info,\n\t.get_fan_speed_pwm = vega10_fan_ctrl_get_fan_speed_pwm,\n\t.set_fan_speed_pwm = vega10_fan_ctrl_set_fan_speed_pwm,\n\t.reset_fan_speed_to_default =\n\t\t\tvega10_fan_ctrl_reset_fan_speed_to_default,\n\t.get_fan_speed_rpm = vega10_fan_ctrl_get_fan_speed_rpm,\n\t.set_fan_speed_rpm = vega10_fan_ctrl_set_fan_speed_rpm,\n\t.uninitialize_thermal_controller =\n\t\t\tvega10_thermal_ctrl_uninitialize_thermal_controller,\n\t.set_fan_control_mode = vega10_set_fan_control_mode,\n\t.get_fan_control_mode = vega10_get_fan_control_mode,\n\t.read_sensor = vega10_read_sensor,\n\t.get_dal_power_level = vega10_get_dal_power_level,\n\t.get_clock_by_type_with_latency = vega10_get_clock_by_type_with_latency,\n\t.get_clock_by_type_with_voltage = vega10_get_clock_by_type_with_voltage,\n\t.set_watermarks_for_clocks_ranges = vega10_set_watermarks_for_clocks_ranges,\n\t.display_clock_voltage_request = vega10_display_clock_voltage_request,\n\t.force_clock_level = vega10_force_clock_level,\n\t.emit_clock_levels = vega10_emit_clock_levels,\n\t.print_clock_levels = vega10_print_clock_levels,\n\t.display_config_changed = vega10_display_configuration_changed_task,\n\t.powergate_uvd = vega10_power_gate_uvd,\n\t.powergate_vce = vega10_power_gate_vce,\n\t.check_states_equal = vega10_check_states_equal,\n\t.check_smc_update_required_for_display_configuration =\n\t\t\tvega10_check_smc_update_required_for_display_configuration,\n\t.power_off_asic = vega10_power_off_asic,\n\t.disable_smc_firmware_ctf = vega10_thermal_disable_alert,\n\t.get_sclk_od = vega10_get_sclk_od,\n\t.set_sclk_od = vega10_set_sclk_od,\n\t.get_mclk_od = vega10_get_mclk_od,\n\t.set_mclk_od = vega10_set_mclk_od,\n\t.avfs_control = vega10_avfs_enable,\n\t.notify_cac_buffer_info = vega10_notify_cac_buffer_info,\n\t.get_thermal_temperature_range = vega10_get_thermal_temperature_range,\n\t.register_irq_handlers = smu9_register_irq_handlers,\n\t.start_thermal_controller = vega10_start_thermal_controller,\n\t.get_power_profile_mode = vega10_get_power_profile_mode,\n\t.set_power_profile_mode = vega10_set_power_profile_mode,\n\t.set_power_limit = vega10_set_power_limit,\n\t.odn_edit_dpm_table = vega10_odn_edit_dpm_table,\n\t.get_performance_level = vega10_get_performance_level,\n\t.get_asic_baco_capability = smu9_baco_get_capability,\n\t.get_asic_baco_state = smu9_baco_get_state,\n\t.set_asic_baco_state = vega10_baco_set_state,\n\t.enable_mgpu_fan_boost = vega10_enable_mgpu_fan_boost,\n\t.get_ppfeature_status = vega10_get_ppfeature_status,\n\t.set_ppfeature_status = vega10_set_ppfeature_status,\n\t.set_mp1_state = vega10_set_mp1_state,\n\t.disable_power_features_for_compute_performance =\n\t\t\tvega10_disable_power_features_for_compute_performance,\n};\n\nint vega10_hwmgr_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\thwmgr->hwmgr_func = &vega10_hwmgr_funcs;\n\thwmgr->pptable_func = &vega10_pptable_funcs;\n\tif (amdgpu_passthrough(adev))\n\t\treturn vega10_baco_set_cap(hwmgr);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}