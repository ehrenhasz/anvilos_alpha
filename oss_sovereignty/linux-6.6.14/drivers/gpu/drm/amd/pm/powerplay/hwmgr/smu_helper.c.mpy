{
  "module_name": "smu_helper.c",
  "hash_id": "f94f7a6af037476c4cf693ad493737e4d95cb88a4a33d52e06c17f7de0d752b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu_helper.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/reboot.h>\n\n#include \"hwmgr.h\"\n#include \"pp_debug.h\"\n#include \"ppatomctrl.h\"\n#include \"ppsmc.h\"\n#include \"atom.h\"\n#include \"ivsrcid/thm/irqsrcs_thm_9_0.h\"\n#include \"ivsrcid/smuio/irqsrcs_smuio_9_0.h\"\n#include \"ivsrcid/ivsrcid_vislands30.h\"\n\nuint8_t convert_to_vid(uint16_t vddc)\n{\n\treturn (uint8_t) ((6200 - (vddc * VOLTAGE_SCALE)) / 25);\n}\n\nuint16_t convert_to_vddc(uint8_t vid)\n{\n\treturn (uint16_t) ((6200 - (vid * 25)) / VOLTAGE_SCALE);\n}\n\nint phm_copy_clock_limits_array(\n\tstruct pp_hwmgr *hwmgr,\n\tuint32_t **pptable_info_array,\n\tconst uint32_t *pptable_array,\n\tuint32_t power_saving_clock_count)\n{\n\tuint32_t array_size, i;\n\tuint32_t *table;\n\n\tarray_size = sizeof(uint32_t) * power_saving_clock_count;\n\ttable = kzalloc(array_size, GFP_KERNEL);\n\tif (NULL == table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < power_saving_clock_count; i++)\n\t\ttable[i] = le32_to_cpu(pptable_array[i]);\n\n\t*pptable_info_array = table;\n\n\treturn 0;\n}\n\nint phm_copy_overdrive_settings_limits_array(\n\tstruct pp_hwmgr *hwmgr,\n\tuint32_t **pptable_info_array,\n\tconst uint32_t *pptable_array,\n\tuint32_t od_setting_count)\n{\n\tuint32_t array_size, i;\n\tuint32_t *table;\n\n\tarray_size = sizeof(uint32_t) * od_setting_count;\n\ttable = kzalloc(array_size, GFP_KERNEL);\n\tif (NULL == table)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < od_setting_count; i++)\n\t\ttable[i] = le32_to_cpu(pptable_array[i]);\n\n\t*pptable_info_array = table;\n\n\treturn 0;\n}\n\nuint32_t phm_set_field_to_u32(u32 offset, u32 original_data, u32 field, u32 size)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\n\tshift = (offset % 4) << 3;\n\tif (size == sizeof(uint8_t))\n\t\tmask = 0xFF << shift;\n\telse if (size == sizeof(uint16_t))\n\t\tmask = 0xFFFF << shift;\n\n\toriginal_data &= ~mask;\n\toriginal_data |= (field << shift);\n\treturn original_data;\n}\n\n \nint phm_wait_on_register(struct pp_hwmgr *hwmgr, uint32_t index,\n\t\t\t uint32_t value, uint32_t mask)\n{\n\tuint32_t i;\n\tuint32_t cur_value;\n\n\tif (hwmgr == NULL || hwmgr->device == NULL) {\n\t\tpr_err(\"Invalid Hardware Manager!\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < hwmgr->usec_timeout; i++) {\n\t\tcur_value = cgs_read_register(hwmgr->device, index);\n\t\tif ((cur_value & mask) == (value & mask))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tif (i == hwmgr->usec_timeout)\n\t\treturn -1;\n\treturn 0;\n}\n\n\n \nint phm_wait_on_indirect_register(struct pp_hwmgr *hwmgr,\n\t\t\t\tuint32_t indirect_port,\n\t\t\t\tuint32_t index,\n\t\t\t\tuint32_t value,\n\t\t\t\tuint32_t mask)\n{\n\tif (hwmgr == NULL || hwmgr->device == NULL) {\n\t\tpr_err(\"Invalid Hardware Manager!\");\n\t\treturn -EINVAL;\n\t}\n\n\tcgs_write_register(hwmgr->device, indirect_port, index);\n\treturn phm_wait_on_register(hwmgr, indirect_port + 1, mask, value);\n}\n\nint phm_wait_for_register_unequal(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t index,\n\t\t\t\t\tuint32_t value, uint32_t mask)\n{\n\tuint32_t i;\n\tuint32_t cur_value;\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < hwmgr->usec_timeout; i++) {\n\t\tcur_value = cgs_read_register(hwmgr->device,\n\t\t\t\t\t\t\t\t\tindex);\n\t\tif ((cur_value & mask) != (value & mask))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\t \n\tif (i == hwmgr->usec_timeout)\n\t\treturn -ETIME;\n\treturn 0;\n}\n\nint phm_wait_for_indirect_register_unequal(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\tuint32_t indirect_port,\n\t\t\t\t\t\tuint32_t index,\n\t\t\t\t\t\tuint32_t value,\n\t\t\t\t\t\tuint32_t mask)\n{\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tcgs_write_register(hwmgr->device, indirect_port, index);\n\treturn phm_wait_for_register_unequal(hwmgr, indirect_port + 1,\n\t\t\t\t\t\tvalue, mask);\n}\n\nbool phm_cf_want_uvd_power_gating(struct pp_hwmgr *hwmgr)\n{\n\treturn phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_UVDPowerGating);\n}\n\nbool phm_cf_want_vce_power_gating(struct pp_hwmgr *hwmgr)\n{\n\treturn phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_VCEPowerGating);\n}\n\n\nint phm_trim_voltage_table(struct pp_atomctrl_voltage_table *vol_table)\n{\n\tuint32_t i, j;\n\tuint16_t vvalue;\n\tbool found = false;\n\tstruct pp_atomctrl_voltage_table *table;\n\n\tPP_ASSERT_WITH_CODE((NULL != vol_table),\n\t\t\t\"Voltage Table empty.\", return -EINVAL);\n\n\ttable = kzalloc(sizeof(struct pp_atomctrl_voltage_table),\n\t\t\tGFP_KERNEL);\n\n\tif (NULL == table)\n\t\treturn -EINVAL;\n\n\ttable->mask_low = vol_table->mask_low;\n\ttable->phase_delay = vol_table->phase_delay;\n\n\tfor (i = 0; i < vol_table->count; i++) {\n\t\tvvalue = vol_table->entries[i].value;\n\t\tfound = false;\n\n\t\tfor (j = 0; j < table->count; j++) {\n\t\t\tif (vvalue == table->entries[j].value) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\ttable->entries[table->count].value = vvalue;\n\t\t\ttable->entries[table->count].smio_low =\n\t\t\t\t\tvol_table->entries[i].smio_low;\n\t\t\ttable->count++;\n\t\t}\n\t}\n\n\tmemcpy(vol_table, table, sizeof(struct pp_atomctrl_voltage_table));\n\tkfree(table);\n\ttable = NULL;\n\treturn 0;\n}\n\nint phm_get_svi2_mvdd_voltage_table(struct pp_atomctrl_voltage_table *vol_table,\n\t\tphm_ppt_v1_clock_voltage_dependency_table *dep_table)\n{\n\tuint32_t i;\n\tint result;\n\n\tPP_ASSERT_WITH_CODE((0 != dep_table->count),\n\t\t\t\"Voltage Dependency Table empty.\", return -EINVAL);\n\n\tPP_ASSERT_WITH_CODE((NULL != vol_table),\n\t\t\t\"vol_table empty.\", return -EINVAL);\n\n\tvol_table->mask_low = 0;\n\tvol_table->phase_delay = 0;\n\tvol_table->count = dep_table->count;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tvol_table->entries[i].value = dep_table->entries[i].mvdd;\n\t\tvol_table->entries[i].smio_low = 0;\n\t}\n\n\tresult = phm_trim_voltage_table(vol_table);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"Failed to trim MVDD table.\", return result);\n\n\treturn 0;\n}\n\nint phm_get_svi2_vddci_voltage_table(struct pp_atomctrl_voltage_table *vol_table,\n\t\tphm_ppt_v1_clock_voltage_dependency_table *dep_table)\n{\n\tuint32_t i;\n\tint result;\n\n\tPP_ASSERT_WITH_CODE((0 != dep_table->count),\n\t\t\t\"Voltage Dependency Table empty.\", return -EINVAL);\n\n\tPP_ASSERT_WITH_CODE((NULL != vol_table),\n\t\t\t\"vol_table empty.\", return -EINVAL);\n\n\tvol_table->mask_low = 0;\n\tvol_table->phase_delay = 0;\n\tvol_table->count = dep_table->count;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tvol_table->entries[i].value = dep_table->entries[i].vddci;\n\t\tvol_table->entries[i].smio_low = 0;\n\t}\n\n\tresult = phm_trim_voltage_table(vol_table);\n\tPP_ASSERT_WITH_CODE((0 == result),\n\t\t\t\"Failed to trim VDDCI table.\", return result);\n\n\treturn 0;\n}\n\nint phm_get_svi2_vdd_voltage_table(struct pp_atomctrl_voltage_table *vol_table,\n\t\tphm_ppt_v1_voltage_lookup_table *lookup_table)\n{\n\tint i = 0;\n\n\tPP_ASSERT_WITH_CODE((0 != lookup_table->count),\n\t\t\t\"Voltage Lookup Table empty.\", return -EINVAL);\n\n\tPP_ASSERT_WITH_CODE((NULL != vol_table),\n\t\t\t\"vol_table empty.\", return -EINVAL);\n\n\tvol_table->mask_low = 0;\n\tvol_table->phase_delay = 0;\n\n\tvol_table->count = lookup_table->count;\n\n\tfor (i = 0; i < vol_table->count; i++) {\n\t\tvol_table->entries[i].value = lookup_table->entries[i].us_vdd;\n\t\tvol_table->entries[i].smio_low = 0;\n\t}\n\n\treturn 0;\n}\n\nvoid phm_trim_voltage_table_to_fit_state_table(uint32_t max_vol_steps,\n\t\t\t\tstruct pp_atomctrl_voltage_table *vol_table)\n{\n\tunsigned int i, diff;\n\n\tif (vol_table->count <= max_vol_steps)\n\t\treturn;\n\n\tdiff = vol_table->count - max_vol_steps;\n\n\tfor (i = 0; i < max_vol_steps; i++)\n\t\tvol_table->entries[i] = vol_table->entries[i + diff];\n\n\tvol_table->count = max_vol_steps;\n\n\treturn;\n}\n\nint phm_reset_single_dpm_table(void *table,\n\t\t\t\tuint32_t count, int max)\n{\n\tint i;\n\n\tstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\n\n\tdpm_table->count = count > max ? max : count;\n\n\tfor (i = 0; i < dpm_table->count; i++)\n\t\tdpm_table->dpm_level[i].enabled = false;\n\n\treturn 0;\n}\n\nvoid phm_setup_pcie_table_entry(\n\tvoid *table,\n\tuint32_t index, uint32_t pcie_gen,\n\tuint32_t pcie_lanes)\n{\n\tstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\n\tdpm_table->dpm_level[index].value = pcie_gen;\n\tdpm_table->dpm_level[index].param1 = pcie_lanes;\n\tdpm_table->dpm_level[index].enabled = 1;\n}\n\nint32_t phm_get_dpm_level_enable_mask_value(void *table)\n{\n\tint32_t i;\n\tint32_t mask = 0;\n\tstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\n\n\tfor (i = dpm_table->count; i > 0; i--) {\n\t\tmask = mask << 1;\n\t\tif (dpm_table->dpm_level[i - 1].enabled)\n\t\t\tmask |= 0x1;\n\t\telse\n\t\t\tmask &= 0xFFFFFFFE;\n\t}\n\n\treturn mask;\n}\n\nuint8_t phm_get_voltage_index(\n\t\tstruct phm_ppt_v1_voltage_lookup_table *lookup_table, uint16_t voltage)\n{\n\tuint8_t count = (uint8_t) (lookup_table->count);\n\tuint8_t i;\n\n\tPP_ASSERT_WITH_CODE((NULL != lookup_table),\n\t\t\t\"Lookup Table empty.\", return 0);\n\tPP_ASSERT_WITH_CODE((0 != count),\n\t\t\t\"Lookup Table empty.\", return 0);\n\n\tfor (i = 0; i < lookup_table->count; i++) {\n\t\t \n\t\tif (lookup_table->entries[i].us_vdd >= voltage)\n\t\t\treturn i;\n\t}\n\t \n\treturn i - 1;\n}\n\nuint8_t phm_get_voltage_id(pp_atomctrl_voltage_table *voltage_table,\n\t\tuint32_t voltage)\n{\n\tuint8_t count = (uint8_t) (voltage_table->count);\n\tuint8_t i = 0;\n\n\tPP_ASSERT_WITH_CODE((NULL != voltage_table),\n\t\t\"Voltage Table empty.\", return 0;);\n\tPP_ASSERT_WITH_CODE((0 != count),\n\t\t\"Voltage Table empty.\", return 0;);\n\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tif (voltage_table->entries[i].value >= voltage)\n\t\t\treturn i;\n\t}\n\n\t \n\treturn i - 1;\n}\n\nuint16_t phm_find_closest_vddci(struct pp_atomctrl_voltage_table *vddci_table, uint16_t vddci)\n{\n\tuint32_t  i;\n\n\tfor (i = 0; i < vddci_table->count; i++) {\n\t\tif (vddci_table->entries[i].value >= vddci)\n\t\t\treturn vddci_table->entries[i].value;\n\t}\n\n\tpr_debug(\"vddci is larger than max value in vddci_table\\n\");\n\treturn vddci_table->entries[i-1].value;\n}\n\nint phm_find_boot_level(void *table,\n\t\tuint32_t value, uint32_t *boot_level)\n{\n\tint result = -EINVAL;\n\tuint32_t i;\n\tstruct vi_dpm_table *dpm_table = (struct vi_dpm_table *)table;\n\n\tfor (i = 0; i < dpm_table->count; i++) {\n\t\tif (value == dpm_table->dpm_level[i].value) {\n\t\t\t*boot_level = i;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint phm_get_sclk_for_voltage_evv(struct pp_hwmgr *hwmgr,\n\tphm_ppt_v1_voltage_lookup_table *lookup_table,\n\tuint16_t virtual_voltage_id, int32_t *sclk)\n{\n\tuint8_t entry_id;\n\tuint8_t voltage_id;\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\tPP_ASSERT_WITH_CODE(lookup_table->count != 0, \"Lookup table is empty\", return -EINVAL);\n\n\t \n\tfor (entry_id = 0; entry_id < table_info->vdd_dep_on_sclk->count; entry_id++) {\n\t\tvoltage_id = table_info->vdd_dep_on_sclk->entries[entry_id].vddInd;\n\t\tif (lookup_table->entries[voltage_id].us_vdd == virtual_voltage_id)\n\t\t\tbreak;\n\t}\n\n\tif (entry_id >= table_info->vdd_dep_on_sclk->count) {\n\t\tpr_debug(\"Can't find requested voltage id in vdd_dep_on_sclk table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t*sclk = table_info->vdd_dep_on_sclk->entries[entry_id].clk;\n\n\treturn 0;\n}\n\n \nint phm_initializa_dynamic_state_adjustment_rule_settings(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_clock_voltage_dependency_table *table_clk_vlt;\n\tstruct phm_ppt_v1_information *pptable_info = (struct phm_ppt_v1_information *)(hwmgr->pptable);\n\n\t \n\ttable_clk_vlt = kzalloc(struct_size(table_clk_vlt, entries, 4),\n\t\t\t\tGFP_KERNEL);\n\n\tif (NULL == table_clk_vlt) {\n\t\tpr_err(\"Can not allocate space for vddc_dep_on_dal_pwrl! \\n\");\n\t\treturn -ENOMEM;\n\t} else {\n\t\ttable_clk_vlt->count = 4;\n\t\ttable_clk_vlt->entries[0].clk = PP_DAL_POWERLEVEL_ULTRALOW;\n\t\tif (hwmgr->chip_id >= CHIP_POLARIS10 &&\n\t\t    hwmgr->chip_id <= CHIP_VEGAM)\n\t\t\ttable_clk_vlt->entries[0].v = 700;\n\t\telse\n\t\t\ttable_clk_vlt->entries[0].v = 0;\n\t\ttable_clk_vlt->entries[1].clk = PP_DAL_POWERLEVEL_LOW;\n\t\tif (hwmgr->chip_id >= CHIP_POLARIS10 &&\n\t\t    hwmgr->chip_id <= CHIP_VEGAM)\n\t\t\ttable_clk_vlt->entries[1].v = 740;\n\t\telse\n\t\t\ttable_clk_vlt->entries[1].v = 720;\n\t\ttable_clk_vlt->entries[2].clk = PP_DAL_POWERLEVEL_NOMINAL;\n\t\tif (hwmgr->chip_id >= CHIP_POLARIS10 &&\n\t\t    hwmgr->chip_id <= CHIP_VEGAM)\n\t\t\ttable_clk_vlt->entries[2].v = 800;\n\t\telse\n\t\t\ttable_clk_vlt->entries[2].v = 810;\n\t\ttable_clk_vlt->entries[3].clk = PP_DAL_POWERLEVEL_PERFORMANCE;\n\t\ttable_clk_vlt->entries[3].v = 900;\n\t\tif (pptable_info != NULL)\n\t\t\tpptable_info->vddc_dep_on_dal_pwrl = table_clk_vlt;\n\t\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = table_clk_vlt;\n\t}\n\n\treturn 0;\n}\n\nuint32_t phm_get_lowest_enabled_level(struct pp_hwmgr *hwmgr, uint32_t mask)\n{\n\tuint32_t level = 0;\n\n\twhile (0 == (mask & (1 << level)))\n\t\tlevel++;\n\n\treturn level;\n}\n\nvoid phm_apply_dal_min_voltage_request(struct pp_hwmgr *hwmgr)\n{\n\tstruct phm_ppt_v1_information *table_info =\n\t\t\t(struct phm_ppt_v1_information *)hwmgr->pptable;\n\tstruct phm_clock_voltage_dependency_table *table =\n\t\t\t\ttable_info->vddc_dep_on_dal_pwrl;\n\tstruct phm_ppt_v1_clock_voltage_dependency_table *vddc_table;\n\tenum PP_DAL_POWERLEVEL dal_power_level = hwmgr->dal_power_level;\n\tuint32_t req_vddc = 0, req_volt, i;\n\n\tif (!table || table->count <= 0\n\t\t|| dal_power_level < PP_DAL_POWERLEVEL_ULTRALOW\n\t\t|| dal_power_level > PP_DAL_POWERLEVEL_PERFORMANCE)\n\t\treturn;\n\n\tfor (i = 0; i < table->count; i++) {\n\t\tif (dal_power_level == table->entries[i].clk) {\n\t\t\treq_vddc = table->entries[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvddc_table = table_info->vdd_dep_on_sclk;\n\tfor (i = 0; i < vddc_table->count; i++) {\n\t\tif (req_vddc <= vddc_table->entries[i].vddc) {\n\t\t\treq_volt = (((uint32_t)vddc_table->entries[i].vddc) * VOLTAGE_SCALE);\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_VddC_Request,\n\t\t\t\t\treq_volt,\n\t\t\t\t\tNULL);\n\t\t\treturn;\n\t\t}\n\t}\n\tpr_err(\"DAL requested level can not\"\n\t\t\t\" found a available voltage in VDDC DPM Table \\n\");\n}\n\nint phm_get_voltage_evv_on_sclk(struct pp_hwmgr *hwmgr, uint8_t voltage_type,\n\t\t\t\tuint32_t sclk, uint16_t id, uint16_t *voltage)\n{\n\tuint32_t vol;\n\tint ret = 0;\n\n\tif (hwmgr->chip_id < CHIP_TONGA) {\n\t\tret = atomctrl_get_voltage_evv(hwmgr, id, voltage);\n\t} else if (hwmgr->chip_id < CHIP_POLARIS10) {\n\t\tret = atomctrl_get_voltage_evv_on_sclk(hwmgr, voltage_type, sclk, id, voltage);\n\t\tif (*voltage >= 2000 || *voltage == 0)\n\t\t\t*voltage = 1150;\n\t} else {\n\t\tret = atomctrl_get_voltage_evv_on_sclk_ai(hwmgr, voltage_type, sclk, id, &vol);\n\t\t*voltage = (uint16_t)(vol/100);\n\t}\n\treturn ret;\n}\n\n\nint phm_irq_process(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t   struct amdgpu_iv_entry *entry)\n{\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\tuint32_t client_id = entry->client_id;\n\tuint32_t src_id = entry->src_id;\n\n\tif (client_id == AMDGPU_IRQ_CLIENTID_LEGACY) {\n\t\tif (src_id == VISLANDS30_IV_SRCID_CG_TSS_THERMAL_LOW_TO_HIGH) {\n\t\t\tschedule_delayed_work(&hwmgr->swctf_delayed_work,\n\t\t\t\t\t      msecs_to_jiffies(AMDGPU_SWCTF_EXTRA_DELAY));\n\t\t} else if (src_id == VISLANDS30_IV_SRCID_CG_TSS_THERMAL_HIGH_TO_LOW) {\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU under temperature range detected!\\n\");\n\t\t} else if (src_id == VISLANDS30_IV_SRCID_GPIO_19) {\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU HW Critical Temperature Fault(aka CTF) detected!\\n\");\n\t\t\t \n\t\t\tdev_emerg(adev->dev, \"ERROR: System is going to shutdown due to GPU HW CTF!\\n\");\n\t\t\torderly_poweroff(true);\n\t\t}\n\t} else if (client_id == SOC15_IH_CLIENTID_THM) {\n\t\tif (src_id == 0)\n\t\t\tschedule_delayed_work(&hwmgr->swctf_delayed_work,\n\t\t\t\t\t      msecs_to_jiffies(AMDGPU_SWCTF_EXTRA_DELAY));\n\t\telse\n\t\t\tdev_emerg(adev->dev, \"ERROR: GPU under temperature range detected!\\n\");\n\t} else if (client_id == SOC15_IH_CLIENTID_ROM_SMUIO) {\n\t\tdev_emerg(adev->dev, \"ERROR: GPU HW Critical Temperature Fault(aka CTF) detected!\\n\");\n\t\t \n\t\tdev_emerg(adev->dev, \"ERROR: System is going to shutdown due to GPU HW CTF!\\n\");\n\t\torderly_poweroff(true);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct amdgpu_irq_src_funcs smu9_irq_funcs = {\n\t.process = phm_irq_process,\n};\n\nint smu9_register_irq_handlers(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_irq_src *source =\n\t\tkzalloc(sizeof(struct amdgpu_irq_src), GFP_KERNEL);\n\n\tif (!source)\n\t\treturn -ENOMEM;\n\n\tsource->funcs = &smu9_irq_funcs;\n\n\tamdgpu_irq_add_id((struct amdgpu_device *)(hwmgr->adev),\n\t\t\tSOC15_IH_CLIENTID_THM,\n\t\t\tTHM_9_0__SRCID__THM_DIG_THERM_L2H,\n\t\t\tsource);\n\tamdgpu_irq_add_id((struct amdgpu_device *)(hwmgr->adev),\n\t\t\tSOC15_IH_CLIENTID_THM,\n\t\t\tTHM_9_0__SRCID__THM_DIG_THERM_H2L,\n\t\t\tsource);\n\n\t \n\tamdgpu_irq_add_id((struct amdgpu_device *)(hwmgr->adev),\n\t\t\tSOC15_IH_CLIENTID_ROM_SMUIO,\n\t\t\tSMUIO_9_0__SRCID__SMUIO_GPIO19,\n\t\t\tsource);\n\n\treturn 0;\n}\n\nvoid *smu_atom_get_data_table(void *dev, uint32_t table, uint16_t *size,\n\t\t\t\t\t\tuint8_t *frev, uint8_t *crev)\n{\n\tstruct amdgpu_device *adev = dev;\n\tuint16_t data_start;\n\n\tif (amdgpu_atom_parse_data_header(\n\t\t    adev->mode_info.atom_context, table, size,\n\t\t    frev, crev, &data_start))\n\t\treturn (uint8_t *)adev->mode_info.atom_context->bios +\n\t\t\tdata_start;\n\n\treturn NULL;\n}\n\nint smu_get_voltage_dependency_table_ppt_v1(\n\t\t\tconst struct phm_ppt_v1_clock_voltage_dependency_table *allowed_dep_table,\n\t\t\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table)\n{\n\tuint8_t i = 0;\n\tPP_ASSERT_WITH_CODE((0 != allowed_dep_table->count),\n\t\t\t\t\"Voltage Lookup Table empty\",\n\t\t\t\treturn -EINVAL);\n\n\tdep_table->count = allowed_dep_table->count;\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tdep_table->entries[i].clk = allowed_dep_table->entries[i].clk;\n\t\tdep_table->entries[i].vddInd = allowed_dep_table->entries[i].vddInd;\n\t\tdep_table->entries[i].vdd_offset = allowed_dep_table->entries[i].vdd_offset;\n\t\tdep_table->entries[i].vddc = allowed_dep_table->entries[i].vddc;\n\t\tdep_table->entries[i].vddgfx = allowed_dep_table->entries[i].vddgfx;\n\t\tdep_table->entries[i].vddci = allowed_dep_table->entries[i].vddci;\n\t\tdep_table->entries[i].mvdd = allowed_dep_table->entries[i].mvdd;\n\t\tdep_table->entries[i].phases = allowed_dep_table->entries[i].phases;\n\t\tdep_table->entries[i].cks_enable = allowed_dep_table->entries[i].cks_enable;\n\t\tdep_table->entries[i].cks_voffset = allowed_dep_table->entries[i].cks_voffset;\n\t}\n\n\treturn 0;\n}\n\nint smu_set_watermarks_for_clocks_ranges(void *wt_table,\n\t\tstruct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges)\n{\n\tuint32_t i;\n\tstruct watermarks *table = wt_table;\n\n\tif (!table || !wm_with_clock_ranges)\n\t\treturn -EINVAL;\n\n\tif (wm_with_clock_ranges->num_wm_dmif_sets > 4 || wm_with_clock_ranges->num_wm_mcif_sets > 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < wm_with_clock_ranges->num_wm_dmif_sets; i++) {\n\t\ttable->WatermarkRow[1][i].MinClock =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_dmif_clocks_ranges[i].wm_min_dcfclk_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[1][i].MaxClock =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_dmif_clocks_ranges[i].wm_max_dcfclk_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[1][i].MinUclk =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_dmif_clocks_ranges[i].wm_min_mem_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[1][i].MaxUclk =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_dmif_clocks_ranges[i].wm_max_mem_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[1][i].WmSetting = (uint8_t)\n\t\t\t\twm_with_clock_ranges->wm_dmif_clocks_ranges[i].wm_set_id;\n\t}\n\n\tfor (i = 0; i < wm_with_clock_ranges->num_wm_mcif_sets; i++) {\n\t\ttable->WatermarkRow[0][i].MinClock =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_mcif_clocks_ranges[i].wm_min_socclk_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[0][i].MaxClock =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_mcif_clocks_ranges[i].wm_max_socclk_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[0][i].MinUclk =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_mcif_clocks_ranges[i].wm_min_mem_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[0][i].MaxUclk =\n\t\t\tcpu_to_le16((uint16_t)\n\t\t\t(wm_with_clock_ranges->wm_mcif_clocks_ranges[i].wm_max_mem_clk_in_khz /\n\t\t\t1000));\n\t\ttable->WatermarkRow[0][i].WmSetting = (uint8_t)\n\t\t\t\twm_with_clock_ranges->wm_mcif_clocks_ranges[i].wm_set_id;\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}