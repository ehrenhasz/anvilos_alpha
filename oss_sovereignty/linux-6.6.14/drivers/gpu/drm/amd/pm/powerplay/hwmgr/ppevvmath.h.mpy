{
  "module_name": "ppevvmath.h",
  "hash_id": "dba66d1e3f06b73d1f061d89021f95cf30d70c08f68bb70c26778dec0137e582",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/ppevvmath.h",
  "human_readable_source": " \n#include <asm/div64.h>\n\n#define SHIFT_AMOUNT 16  \n\n#define PRECISION 5  \n\n#define SHIFTED_2 (2 << SHIFT_AMOUNT)\n#define MAX (1 << (SHIFT_AMOUNT - 1)) - 1  \n\n \ntypedef union _fInt {\n    int full;\n    struct _partial {\n        unsigned int decimal: SHIFT_AMOUNT;  \n        int real: 32 - SHIFT_AMOUNT;\n    } partial;\n} fInt;\n\n \nstatic fInt ConvertToFraction(int);                        \nstatic fInt Convert_ULONG_ToFraction(uint32_t);            \nstatic fInt GetScaledFraction(int, int);                   \nstatic int ConvertBackToInteger(fInt);                     \n\nstatic fInt fNegate(fInt);                                 \nstatic fInt fAdd (fInt, fInt);                             \nstatic fInt fSubtract (fInt A, fInt B);                    \nstatic fInt fMultiply (fInt, fInt);                        \nstatic fInt fDivide (fInt A, fInt B);                      \nstatic fInt fGetSquare(fInt);                              \nstatic fInt fSqrt(fInt);                                   \n\nstatic int uAbs(int);                                      \nstatic int uPow(int base, int exponent);                   \n\nstatic void SolveQuadracticEqn(fInt, fInt, fInt, fInt[]);  \nstatic bool Equal(fInt, fInt);                             \nstatic bool GreaterThan(fInt A, fInt B);                   \n\nstatic fInt fExponential(fInt exponent);                   \nstatic fInt fNaturalLog(fInt value);                       \n\n \nstatic fInt fDecodeLinearFuse(uint32_t fuse_value, fInt f_min, fInt f_range, uint32_t bitlength);\nstatic fInt fDecodeLogisticFuse(uint32_t fuse_value, fInt f_average, fInt f_range, uint32_t bitlength);\nstatic fInt fDecodeLeakageID (uint32_t leakageID_fuse, fInt ln_max_div_min, fInt f_min, uint32_t bitlength);\n\n \nstatic fInt Divide (int, int);                             \nstatic fInt fNegate(fInt);\n\nstatic int uGetScaledDecimal (fInt);                       \nstatic int GetReal (fInt A);                               \n\n \n\n \nstatic fInt fExponential(fInt exponent)         \n{\n\tuint32_t i;\n\tbool bNegated = false;\n\n\tfInt fPositiveOne = ConvertToFraction(1);\n\tfInt fZERO = ConvertToFraction(0);\n\n\tfInt lower_bound = Divide(78, 10000);\n\tfInt solution = fPositiveOne;  \n\tfInt error_term;\n\n\tstatic const uint32_t k_array[11] = {55452, 27726, 13863, 6931, 4055, 2231, 1178, 606, 308, 155, 78};\n\tstatic const uint32_t expk_array[11] = {2560000, 160000, 40000, 20000, 15000, 12500, 11250, 10625, 10313, 10156, 10078};\n\n\tif (GreaterThan(fZERO, exponent)) {\n\t\texponent = fNegate(exponent);\n\t\tbNegated = true;\n\t}\n\n\twhile (GreaterThan(exponent, lower_bound)) {\n\t\tfor (i = 0; i < 11; i++) {\n\t\t\tif (GreaterThan(exponent, GetScaledFraction(k_array[i], 10000))) {\n\t\t\t\texponent = fSubtract(exponent, GetScaledFraction(k_array[i], 10000));\n\t\t\t\tsolution = fMultiply(solution, GetScaledFraction(expk_array[i], 10000));\n\t\t\t}\n\t\t}\n\t}\n\n\terror_term = fAdd(fPositiveOne, exponent);\n\n\tsolution = fMultiply(solution, error_term);\n\n\tif (bNegated)\n\t\tsolution = fDivide(fPositiveOne, solution);\n\n\treturn solution;\n}\n\nstatic fInt fNaturalLog(fInt value)\n{\n\tuint32_t i;\n\tfInt upper_bound = Divide(8, 1000);\n\tfInt fNegativeOne = ConvertToFraction(-1);\n\tfInt solution = ConvertToFraction(0);  \n\tfInt error_term;\n\n\tstatic const uint32_t k_array[10] = {160000, 40000, 20000, 15000, 12500, 11250, 10625, 10313, 10156, 10078};\n\tstatic const uint32_t logk_array[10] = {27726, 13863, 6931, 4055, 2231, 1178, 606, 308, 155, 78};\n\n\twhile (GreaterThan(fAdd(value, fNegativeOne), upper_bound)) {\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tif (GreaterThan(value, GetScaledFraction(k_array[i], 10000))) {\n\t\t\t\tvalue = fDivide(value, GetScaledFraction(k_array[i], 10000));\n\t\t\t\tsolution = fAdd(solution, GetScaledFraction(logk_array[i], 10000));\n\t\t\t}\n\t\t}\n\t}\n\n\terror_term = fAdd(fNegativeOne, value);\n\n\treturn fAdd(solution, error_term);\n}\n\nstatic fInt fDecodeLinearFuse(uint32_t fuse_value, fInt f_min, fInt f_range, uint32_t bitlength)\n{\n\tfInt f_fuse_value = Convert_ULONG_ToFraction(fuse_value);\n\tfInt f_bit_max_value = Convert_ULONG_ToFraction((uPow(2, bitlength)) - 1);\n\n\tfInt f_decoded_value;\n\n\tf_decoded_value = fDivide(f_fuse_value, f_bit_max_value);\n\tf_decoded_value = fMultiply(f_decoded_value, f_range);\n\tf_decoded_value = fAdd(f_decoded_value, f_min);\n\n\treturn f_decoded_value;\n}\n\n\nstatic fInt fDecodeLogisticFuse(uint32_t fuse_value, fInt f_average, fInt f_range, uint32_t bitlength)\n{\n\tfInt f_fuse_value = Convert_ULONG_ToFraction(fuse_value);\n\tfInt f_bit_max_value = Convert_ULONG_ToFraction((uPow(2, bitlength)) - 1);\n\n\tfInt f_CONSTANT_NEG13 = ConvertToFraction(-13);\n\tfInt f_CONSTANT1 = ConvertToFraction(1);\n\n\tfInt f_decoded_value;\n\n\tf_decoded_value = fSubtract(fDivide(f_bit_max_value, f_fuse_value), f_CONSTANT1);\n\tf_decoded_value = fNaturalLog(f_decoded_value);\n\tf_decoded_value = fMultiply(f_decoded_value, fDivide(f_range, f_CONSTANT_NEG13));\n\tf_decoded_value = fAdd(f_decoded_value, f_average);\n\n\treturn f_decoded_value;\n}\n\nstatic fInt fDecodeLeakageID (uint32_t leakageID_fuse, fInt ln_max_div_min, fInt f_min, uint32_t bitlength)\n{\n\tfInt fLeakage;\n\tfInt f_bit_max_value = Convert_ULONG_ToFraction((uPow(2, bitlength)) - 1);\n\n\tfLeakage = fMultiply(ln_max_div_min, Convert_ULONG_ToFraction(leakageID_fuse));\n\tfLeakage = fDivide(fLeakage, f_bit_max_value);\n\tfLeakage = fExponential(fLeakage);\n\tfLeakage = fMultiply(fLeakage, f_min);\n\n\treturn fLeakage;\n}\n\nstatic fInt ConvertToFraction(int X)  \n{\n\tfInt temp;\n\n\tif (X <= MAX)\n\t\ttemp.full = (X << SHIFT_AMOUNT);\n\telse\n\t\ttemp.full = 0;\n\n\treturn temp;\n}\n\nstatic fInt fNegate(fInt X)\n{\n\tfInt CONSTANT_NEGONE = ConvertToFraction(-1);\n\treturn fMultiply(X, CONSTANT_NEGONE);\n}\n\nstatic fInt Convert_ULONG_ToFraction(uint32_t X)\n{\n\tfInt temp;\n\n\tif (X <= MAX)\n\t\ttemp.full = (X << SHIFT_AMOUNT);\n\telse\n\t\ttemp.full = 0;\n\n\treturn temp;\n}\n\nstatic fInt GetScaledFraction(int X, int factor)\n{\n\tint times_shifted, factor_shifted;\n\tbool bNEGATED;\n\tfInt fValue;\n\n\ttimes_shifted = 0;\n\tfactor_shifted = 0;\n\tbNEGATED = false;\n\n\tif (X < 0) {\n\t\tX = -1*X;\n\t\tbNEGATED = true;\n\t}\n\n\tif (factor < 0) {\n\t\tfactor = -1*factor;\n\t\tbNEGATED = !bNEGATED;  \n\t}\n\n\tif ((X > MAX) || factor > MAX) {\n\t\tif ((X/factor) <= MAX) {\n\t\t\twhile (X > MAX) {\n\t\t\t\tX = X >> 1;\n\t\t\t\ttimes_shifted++;\n\t\t\t}\n\n\t\t\twhile (factor > MAX) {\n\t\t\t\tfactor = factor >> 1;\n\t\t\t\tfactor_shifted++;\n\t\t\t}\n\t\t} else {\n\t\t\tfValue.full = 0;\n\t\t\treturn fValue;\n\t\t}\n\t}\n\n\tif (factor == 1)\n\t\treturn ConvertToFraction(X);\n\n\tfValue = fDivide(ConvertToFraction(X * uPow(-1, bNEGATED)), ConvertToFraction(factor));\n\n\tfValue.full = fValue.full << times_shifted;\n\tfValue.full = fValue.full >> factor_shifted;\n\n\treturn fValue;\n}\n\n \nstatic fInt fAdd (fInt X, fInt Y)\n{\n\tfInt Sum;\n\n\tSum.full = X.full + Y.full;\n\n\treturn Sum;\n}\n\n \nstatic fInt fSubtract (fInt X, fInt Y)\n{\n\tfInt Difference;\n\n\tDifference.full = X.full - Y.full;\n\n\treturn Difference;\n}\n\nstatic bool Equal(fInt A, fInt B)\n{\n\tif (A.full == B.full)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool GreaterThan(fInt A, fInt B)\n{\n\tif (A.full > B.full)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic fInt fMultiply (fInt X, fInt Y)  \n{\n\tfInt Product;\n\tint64_t tempProduct;\n\n\t \n\t \n\n\ttempProduct = ((int64_t)X.full) * ((int64_t)Y.full);  \n\ttempProduct = tempProduct >> 16;  \n\tProduct.full = (int)tempProduct;  \n\n\treturn Product;\n}\n\nstatic fInt fDivide (fInt X, fInt Y)\n{\n\tfInt fZERO, fQuotient;\n\tint64_t longlongX, longlongY;\n\n\tfZERO = ConvertToFraction(0);\n\n\tif (Equal(Y, fZERO))\n\t\treturn fZERO;\n\n\tlonglongX = (int64_t)X.full;\n\tlonglongY = (int64_t)Y.full;\n\n\tlonglongX = longlongX << 16;  \n\n\tdiv64_s64(longlongX, longlongY);  \n\n\tfQuotient.full = (int)longlongX;\n\treturn fQuotient;\n}\n\nstatic int ConvertBackToInteger (fInt A)  \n{\n\tfInt fullNumber, scaledDecimal, scaledReal;\n\n\tscaledReal.full = GetReal(A) * uPow(10, PRECISION-1);  \n\n\tscaledDecimal.full = uGetScaledDecimal(A);\n\n\tfullNumber = fAdd(scaledDecimal, scaledReal);\n\n\treturn fullNumber.full;\n}\n\nstatic fInt fGetSquare(fInt A)\n{\n\treturn fMultiply(A, A);\n}\n\n \nstatic fInt fSqrt(fInt num)\n{\n\tfInt F_divide_Fprime, Fprime;\n\tfInt test;\n\tfInt twoShifted;\n\tint seed, counter, error;\n\tfInt x_new, x_old, C, y;\n\n\tfInt fZERO = ConvertToFraction(0);\n\n\t \n\n\tif (GreaterThan(fZERO, num) || Equal(fZERO, num))\n\t\treturn fZERO;\n\n\tC = num;\n\n\tif (num.partial.real > 3000)\n\t\tseed = 60;\n\telse if (num.partial.real > 1000)\n\t\tseed = 30;\n\telse if (num.partial.real > 100)\n\t\tseed = 10;\n\telse\n\t\tseed = 2;\n\n\tcounter = 0;\n\n\tif (Equal(num, fZERO))  \n\t\treturn fZERO;\n\n\ttwoShifted = ConvertToFraction(2);\n\tx_new = ConvertToFraction(seed);\n\n\tdo {\n\t\tcounter++;\n\n\t\tx_old.full = x_new.full;\n\n\t\ttest = fGetSquare(x_old);  \n\t\ty = fSubtract(test, C);  \n\n\t\tFprime = fMultiply(twoShifted, x_old);\n\t\tF_divide_Fprime = fDivide(y, Fprime);\n\n\t\tx_new = fSubtract(x_old, F_divide_Fprime);\n\n\t\terror = ConvertBackToInteger(x_new) - ConvertBackToInteger(x_old);\n\n\t\tif (counter > 20)  \n\t\t\treturn x_new;\n\n\t} while (uAbs(error) > 0);\n\n\treturn x_new;\n}\n\nstatic void SolveQuadracticEqn(fInt A, fInt B, fInt C, fInt Roots[])\n{\n\tfInt *pRoots = &Roots[0];\n\tfInt temp, root_first, root_second;\n\tfInt f_CONSTANT10, f_CONSTANT100;\n\n\tf_CONSTANT100 = ConvertToFraction(100);\n\tf_CONSTANT10 = ConvertToFraction(10);\n\n\twhile (GreaterThan(A, f_CONSTANT100) || GreaterThan(B, f_CONSTANT100) || GreaterThan(C, f_CONSTANT100)) {\n\t\tA = fDivide(A, f_CONSTANT10);\n\t\tB = fDivide(B, f_CONSTANT10);\n\t\tC = fDivide(C, f_CONSTANT10);\n\t}\n\n\ttemp = fMultiply(ConvertToFraction(4), A);  \n\ttemp = fMultiply(temp, C);  \n\ttemp = fSubtract(fGetSquare(B), temp);  \n\ttemp = fSqrt(temp);  \n\n\troot_first = fSubtract(fNegate(B), temp);  \n\troot_second = fAdd(fNegate(B), temp);  \n\n\troot_first = fDivide(root_first, ConvertToFraction(2));  \n\troot_first = fDivide(root_first, A);  \n\n\troot_second = fDivide(root_second, ConvertToFraction(2));  \n\troot_second = fDivide(root_second, A);  \n\n\t*(pRoots + 0) = root_first;\n\t*(pRoots + 1) = root_second;\n}\n\n \n\n \nstatic int GetReal (fInt A)\n{\n\treturn (A.full >> SHIFT_AMOUNT);\n}\n\nstatic fInt Divide (int X, int Y)\n{\n\tfInt A, B, Quotient;\n\n\tA.full = X << SHIFT_AMOUNT;\n\tB.full = Y << SHIFT_AMOUNT;\n\n\tQuotient = fDivide(A, B);\n\n\treturn Quotient;\n}\n\nstatic int uGetScaledDecimal (fInt A)  \n{\n\tint dec[PRECISION];\n\tint i, scaledDecimal = 0, tmp = A.partial.decimal;\n\n\tfor (i = 0; i < PRECISION; i++) {\n\t\tdec[i] = tmp / (1 << SHIFT_AMOUNT);\n\t\ttmp = tmp - ((1 << SHIFT_AMOUNT)*dec[i]);\n\t\ttmp *= 10;\n\t\tscaledDecimal = scaledDecimal + dec[i]*uPow(10, PRECISION - 1 - i);\n\t}\n\n\treturn scaledDecimal;\n}\n\nstatic int uPow(int base, int power)\n{\n\tif (power == 0)\n\t\treturn 1;\n\telse\n\t\treturn (base)*uPow(base, power - 1);\n}\n\nstatic int uAbs(int X)\n{\n\tif (X < 0)\n\t\treturn (X * -1);\n\telse\n\t\treturn X;\n}\n\nstatic fInt fRoundUpByStepSize(fInt A, fInt fStepSize, bool error_term)\n{\n\tfInt solution;\n\n\tsolution = fDivide(A, fStepSize);\n\tsolution.partial.decimal = 0;  \n\n\tif (error_term)\n\t\tsolution.partial.real += 1;  \n\n\tsolution = fMultiply(solution, fStepSize);\n\tsolution = fAdd(solution, fStepSize);\n\n\treturn solution;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}