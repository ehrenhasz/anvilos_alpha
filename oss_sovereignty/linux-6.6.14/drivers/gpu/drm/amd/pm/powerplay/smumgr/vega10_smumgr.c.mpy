{
  "module_name": "vega10_smumgr.c",
  "hash_id": "59eb1c68f9403dc72b2ddf6a7bc8cb4f89835298a8704a2a0318f7b768f1ec90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/vega10_smumgr.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n\n#include \"smumgr.h\"\n#include \"vega10_inc.h\"\n#include \"soc15_common.h\"\n#include \"vega10_smumgr.h\"\n#include \"vega10_hwmgr.h\"\n#include \"vega10_ppsmc.h\"\n#include \"smu9_driver_if.h\"\n#include \"smu9_smumgr.h\"\n#include \"ppatomctrl.h\"\n#include \"pp_debug.h\"\n\n\nstatic int vega10_copy_table_from_smc(struct pp_hwmgr *hwmgr,\n\t\tuint8_t *table, int16_t table_id)\n{\n\tstruct vega10_smumgr *priv = hwmgr->smu_backend;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tPP_ASSERT_WITH_CODE(table_id < MAX_SMU_TABLE,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableSmu2Dram,\n\t\t\tpriv->smu_tables.entry[table_id].table_id,\n\t\t\tNULL);\n\n\tamdgpu_asic_invalidate_hdp(adev, NULL);\n\n\tmemcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\treturn 0;\n}\n\nstatic int vega10_copy_table_to_smc(struct pp_hwmgr *hwmgr,\n\t\tuint8_t *table, int16_t table_id)\n{\n\tstruct vega10_smumgr *priv = hwmgr->smu_backend;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\t \n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\tPP_ASSERT_WITH_CODE(table_id < MAX_SMU_TABLE,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL);\n\n\tmemcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\tamdgpu_asic_flush_hdp(adev, NULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableDram2Smu,\n\t\t\tpriv->smu_tables.entry[table_id].table_id,\n\t\t\tNULL);\n\n\treturn 0;\n}\n\nint vega10_enable_smc_features(struct pp_hwmgr *hwmgr,\n\t\t\t       bool enable, uint32_t feature_mask)\n{\n\tint msg = enable ? PPSMC_MSG_EnableSmuFeatures :\n\t\t\tPPSMC_MSG_DisableSmuFeatures;\n\n\t \n\tif (!hwmgr->not_vf)\n\t\treturn 0;\n\n\treturn smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tmsg, feature_mask, NULL);\n}\n\nint vega10_get_enabled_smc_features(struct pp_hwmgr *hwmgr,\n\t\t\t    uint64_t *features_enabled)\n{\n\tuint32_t enabled_features;\n\n\tif (features_enabled == NULL)\n\t\treturn -EINVAL;\n\n\tsmum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetEnabledSmuFeatures,\n\t\t\t&enabled_features);\n\t*features_enabled = enabled_features;\n\n\treturn 0;\n}\n\nstatic bool vega10_is_dpm_running(struct pp_hwmgr *hwmgr)\n{\n\tuint64_t features_enabled = 0;\n\n\tvega10_get_enabled_smc_features(hwmgr, &features_enabled);\n\n\tif (features_enabled & SMC_DPM_FEATURES)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int vega10_set_tools_address(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_smumgr *priv = hwmgr->smu_backend;\n\n\tif (priv->smu_tables.entry[TOOLSTABLE].mc_addr) {\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetToolsDramAddrHigh,\n\t\t\t\tupper_32_bits(priv->smu_tables.entry[TOOLSTABLE].mc_addr),\n\t\t\t\tNULL);\n\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetToolsDramAddrLow,\n\t\t\t\tlower_32_bits(priv->smu_tables.entry[TOOLSTABLE].mc_addr),\n\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int vega10_verify_smc_interface(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t smc_driver_if_version;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t dev_id;\n\tuint32_t rev_id;\n\n\tPP_ASSERT_WITH_CODE(!smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetDriverIfVersion,\n\t\t\t&smc_driver_if_version),\n\t\t\t\"Attempt to get SMC IF Version Number Failed!\",\n\t\t\treturn -EINVAL);\n\n\tdev_id = adev->pdev->device;\n\trev_id = adev->pdev->revision;\n\n\tif (!((dev_id == 0x687f) &&\n\t\t((rev_id == 0xc0) ||\n\t\t(rev_id == 0xc1) ||\n\t\t(rev_id == 0xc3)))) {\n\t\tif (smc_driver_if_version != SMU9_DRIVER_IF_VERSION) {\n\t\t\tpr_err(\"Your firmware(0x%x) doesn't match SMU9_DRIVER_IF_VERSION(0x%x). Please update your firmware!\\n\",\n\t\t\t       smc_driver_if_version, SMU9_DRIVER_IF_VERSION);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vega10_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_smumgr *priv;\n\tunsigned long tools_size;\n\tint ret;\n\tstruct cgs_firmware_info info = {0};\n\n\tret = cgs_get_firmware_info(hwmgr->device,\n\t\t\t\t\tCGS_UCODE_ID_SMU,\n\t\t\t\t\t&info);\n\tif (ret || !info.kptr)\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(struct vega10_smumgr), GFP_KERNEL);\n\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = priv;\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(PPTable_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[PPTABLE].handle,\n\t\t\t&priv->smu_tables.entry[PPTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[PPTABLE].table);\n\tif (ret)\n\t\tgoto free_backend;\n\n\tpriv->smu_tables.entry[PPTABLE].version = 0x01;\n\tpriv->smu_tables.entry[PPTABLE].size = sizeof(PPTable_t);\n\tpriv->smu_tables.entry[PPTABLE].table_id = TABLE_PPTABLE;\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(Watermarks_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[WMTABLE].handle,\n\t\t\t&priv->smu_tables.entry[WMTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[WMTABLE].table);\n\n\tif (ret)\n\t\tgoto err0;\n\n\tpriv->smu_tables.entry[WMTABLE].version = 0x01;\n\tpriv->smu_tables.entry[WMTABLE].size = sizeof(Watermarks_t);\n\tpriv->smu_tables.entry[WMTABLE].table_id = TABLE_WATERMARKS;\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(AvfsTable_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[AVFSTABLE].handle,\n\t\t\t&priv->smu_tables.entry[AVFSTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[AVFSTABLE].table);\n\n\tif (ret)\n\t\tgoto err1;\n\n\tpriv->smu_tables.entry[AVFSTABLE].version = 0x01;\n\tpriv->smu_tables.entry[AVFSTABLE].size = sizeof(AvfsTable_t);\n\tpriv->smu_tables.entry[AVFSTABLE].table_id = TABLE_AVFS;\n\n\ttools_size = 0x19000;\n\tif (tools_size) {\n\t\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\ttools_size,\n\t\t\t\tPAGE_SIZE,\n\t\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].table);\n\t\tif (ret)\n\t\t\tgoto err2;\n\t\tpriv->smu_tables.entry[TOOLSTABLE].version = 0x01;\n\t\tpriv->smu_tables.entry[TOOLSTABLE].size = tools_size;\n\t\tpriv->smu_tables.entry[TOOLSTABLE].table_id = TABLE_PMSTATUSLOG;\n\t}\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(AvfsFuseOverride_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[AVFSFUSETABLE].handle,\n\t\t\t&priv->smu_tables.entry[AVFSFUSETABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[AVFSFUSETABLE].table);\n\tif (ret)\n\t\tgoto err3;\n\n\tpriv->smu_tables.entry[AVFSFUSETABLE].version = 0x01;\n\tpriv->smu_tables.entry[AVFSFUSETABLE].size = sizeof(AvfsFuseOverride_t);\n\tpriv->smu_tables.entry[AVFSFUSETABLE].table_id = TABLE_AVFS_FUSE_OVERRIDE;\n\n\n\treturn 0;\n\nerr3:\n\tif (priv->smu_tables.entry[TOOLSTABLE].table)\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TOOLSTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].table);\nerr2:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[AVFSTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[AVFSTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[AVFSTABLE].table);\nerr1:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[WMTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[WMTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[WMTABLE].table);\nerr0:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[PPTABLE].handle,\n\t\t\t&priv->smu_tables.entry[PPTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[PPTABLE].table);\nfree_backend:\n\tkfree(hwmgr->smu_backend);\n\n\treturn -EINVAL;\n}\n\nstatic int vega10_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega10_smumgr *priv = hwmgr->smu_backend;\n\n\tif (priv) {\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[PPTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[PPTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[PPTABLE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[WMTABLE].handle,\n\t\t\t\t\t&priv->smu_tables.entry[WMTABLE].mc_addr,\n\t\t\t\t\t&priv->smu_tables.entry[WMTABLE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[AVFSTABLE].handle,\n\t\t\t\t\t&priv->smu_tables.entry[AVFSTABLE].mc_addr,\n\t\t\t\t\t&priv->smu_tables.entry[AVFSTABLE].table);\n\t\tif (priv->smu_tables.entry[TOOLSTABLE].table)\n\t\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TOOLSTABLE].handle,\n\t\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].mc_addr,\n\t\t\t\t\t&priv->smu_tables.entry[TOOLSTABLE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[AVFSFUSETABLE].handle,\n\t\t\t\t\t&priv->smu_tables.entry[AVFSFUSETABLE].mc_addr,\n\t\t\t\t\t&priv->smu_tables.entry[AVFSFUSETABLE].table);\n\t\tkfree(hwmgr->smu_backend);\n\t\thwmgr->smu_backend = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int vega10_start_smu(struct pp_hwmgr *hwmgr)\n{\n\tif (!smu9_is_smc_ram_running(hwmgr))\n\t\treturn -EINVAL;\n\n\tPP_ASSERT_WITH_CODE(!vega10_verify_smc_interface(hwmgr),\n\t\t\t\"Failed to verify SMC interface!\",\n\t\t\treturn -EINVAL);\n\n\tvega10_set_tools_address(hwmgr);\n\n\treturn 0;\n}\n\nstatic int vega10_smc_table_manager(struct pp_hwmgr *hwmgr, uint8_t *table,\n\t\t\t\t    uint16_t table_id, bool rw)\n{\n\tint ret;\n\n\tif (rw)\n\t\tret = vega10_copy_table_from_smc(hwmgr, table, table_id);\n\telse\n\t\tret = vega10_copy_table_to_smc(hwmgr, table, table_id);\n\n\treturn ret;\n}\n\nconst struct pp_smumgr_func vega10_smu_funcs = {\n\t.name = \"vega10_smu\",\n\t.smu_init = &vega10_smu_init,\n\t.smu_fini = &vega10_smu_fini,\n\t.start_smu = &vega10_start_smu,\n\t.request_smu_load_specific_fw = NULL,\n\t.send_msg_to_smc = &smu9_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = &smu9_send_msg_to_smc_with_parameter,\n\t.download_pptable_settings = NULL,\n\t.upload_pptable_settings = NULL,\n\t.is_dpm_running = vega10_is_dpm_running,\n\t.get_argument = smu9_get_argument,\n\t.smc_table_manager = vega10_smc_table_manager,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}