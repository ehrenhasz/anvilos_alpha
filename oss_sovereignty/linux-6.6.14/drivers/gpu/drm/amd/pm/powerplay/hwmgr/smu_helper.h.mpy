{
  "module_name": "smu_helper.h",
  "hash_id": "dde29e53395b2659acc705e92d5d4eb14c49f471e65b958b66fc3481f438d743",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu_helper.h",
  "human_readable_source": " \n#ifndef _SMU_HELPER_H_\n#define _SMU_HELPER_H_\n\nstruct pp_atomctrl_voltage_table;\nstruct pp_hwmgr;\nstruct phm_ppt_v1_voltage_lookup_table;\nstruct Watermarks_t;\nstruct pp_wm_sets_with_clock_ranges_soc15;\n\nuint8_t convert_to_vid(uint16_t vddc);\nuint16_t convert_to_vddc(uint8_t vid);\n\nstruct watermark_row_generic_t {\n\tuint16_t MinClock;\n\tuint16_t MaxClock;\n\tuint16_t MinUclk;\n\tuint16_t MaxUclk;\n\n\tuint8_t  WmSetting;\n\tuint8_t  Padding[3];\n};\n\nstruct watermarks {\n\tstruct watermark_row_generic_t WatermarkRow[2][4];\n\tuint32_t     padding[7];\n};\n\nint phm_copy_clock_limits_array(\n\tstruct pp_hwmgr *hwmgr,\n\tuint32_t **pptable_info_array,\n\tconst uint32_t *pptable_array,\n\tuint32_t power_saving_clock_count);\n\nint phm_copy_overdrive_settings_limits_array(\n\tstruct pp_hwmgr *hwmgr,\n\tuint32_t **pptable_info_array,\n\tconst uint32_t *pptable_array,\n\tuint32_t od_setting_count);\n\nextern int phm_wait_for_register_unequal(struct pp_hwmgr *hwmgr,\n\t\t\t\t\tuint32_t index,\n\t\t\t\t\tuint32_t value, uint32_t mask);\nextern int phm_wait_for_indirect_register_unequal(\n\t\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\t\tuint32_t indirect_port, uint32_t index,\n\t\t\t\tuint32_t value, uint32_t mask);\n\n\nextern bool phm_cf_want_uvd_power_gating(struct pp_hwmgr *hwmgr);\nextern bool phm_cf_want_vce_power_gating(struct pp_hwmgr *hwmgr);\nextern bool phm_cf_want_microcode_fan_ctrl(struct pp_hwmgr *hwmgr);\n\nextern int phm_trim_voltage_table(struct pp_atomctrl_voltage_table *vol_table);\nextern int phm_get_svi2_mvdd_voltage_table(struct pp_atomctrl_voltage_table *vol_table, phm_ppt_v1_clock_voltage_dependency_table *dep_table);\nextern int phm_get_svi2_vddci_voltage_table(struct pp_atomctrl_voltage_table *vol_table, phm_ppt_v1_clock_voltage_dependency_table *dep_table);\nextern int phm_get_svi2_vdd_voltage_table(struct pp_atomctrl_voltage_table *vol_table, phm_ppt_v1_voltage_lookup_table *lookup_table);\nextern void phm_trim_voltage_table_to_fit_state_table(uint32_t max_vol_steps, struct pp_atomctrl_voltage_table *vol_table);\nextern int phm_reset_single_dpm_table(void *table, uint32_t count, int max);\nextern void phm_setup_pcie_table_entry(void *table, uint32_t index, uint32_t pcie_gen, uint32_t pcie_lanes);\nextern int32_t phm_get_dpm_level_enable_mask_value(void *table);\nextern uint8_t phm_get_voltage_id(struct pp_atomctrl_voltage_table *voltage_table,\n\t\tuint32_t voltage);\nextern uint8_t phm_get_voltage_index(struct phm_ppt_v1_voltage_lookup_table *lookup_table, uint16_t voltage);\nextern uint16_t phm_find_closest_vddci(struct pp_atomctrl_voltage_table *vddci_table, uint16_t vddci);\nextern int phm_find_boot_level(void *table, uint32_t value, uint32_t *boot_level);\nextern int phm_get_sclk_for_voltage_evv(struct pp_hwmgr *hwmgr, phm_ppt_v1_voltage_lookup_table *lookup_table,\n\t\t\t\t\t\t\t\tuint16_t virtual_voltage_id, int32_t *sclk);\nextern int phm_initializa_dynamic_state_adjustment_rule_settings(struct pp_hwmgr *hwmgr);\nextern uint32_t phm_get_lowest_enabled_level(struct pp_hwmgr *hwmgr, uint32_t mask);\nextern void phm_apply_dal_min_voltage_request(struct pp_hwmgr *hwmgr);\n\nextern int phm_get_voltage_evv_on_sclk(struct pp_hwmgr *hwmgr, uint8_t voltage_type,\n\t\t\t\tuint32_t sclk, uint16_t id, uint16_t *voltage);\n\nextern uint32_t phm_set_field_to_u32(u32 offset, u32 original_data, u32 field, u32 size);\n\nextern int phm_wait_on_register(struct pp_hwmgr *hwmgr, uint32_t index,\n\t\t\t\tuint32_t value, uint32_t mask);\n\nextern int phm_wait_on_indirect_register(struct pp_hwmgr *hwmgr,\n\t\t\t\tuint32_t indirect_port,\n\t\t\t\tuint32_t index,\n\t\t\t\tuint32_t value,\n\t\t\t\tuint32_t mask);\n\nint phm_irq_process(struct amdgpu_device *adev,\n\t\t\t   struct amdgpu_irq_src *source,\n\t\t\t   struct amdgpu_iv_entry *entry);\n\n \nstatic inline void phm_get_sysfs_buf(char **buf, int *offset)\n{\n\tif (!*buf || !offset)\n\t\treturn;\n\n\t*offset = offset_in_page(*buf);\n\t*buf -= *offset;\n}\n\nint smu9_register_irq_handlers(struct pp_hwmgr *hwmgr);\n\nvoid *smu_atom_get_data_table(void *dev, uint32_t table, uint16_t *size,\n\t\t\t\t\t\tuint8_t *frev, uint8_t *crev);\n\nint smu_get_voltage_dependency_table_ppt_v1(\n\tconst struct phm_ppt_v1_clock_voltage_dependency_table *allowed_dep_table,\n\t\tstruct phm_ppt_v1_clock_voltage_dependency_table *dep_table);\n\nint smu_set_watermarks_for_clocks_ranges(void *wt_table,\n\t\tstruct dm_pp_wm_sets_with_clock_ranges_soc15 *wm_with_clock_ranges);\n\n#define PHM_FIELD_SHIFT(reg, field) reg##__##field##__SHIFT\n#define PHM_FIELD_MASK(reg, field) reg##__##field##_MASK\n\n#define PHM_SET_FIELD(origval, reg, field, fieldval)\t\\\n\t(((origval) & ~PHM_FIELD_MASK(reg, field)) |\t\\\n\t (PHM_FIELD_MASK(reg, field) & ((fieldval) << PHM_FIELD_SHIFT(reg, field))))\n\n#define PHM_GET_FIELD(value, reg, field)\t\\\n\t(((value) & PHM_FIELD_MASK(reg, field)) >>\t\\\n\t PHM_FIELD_SHIFT(reg, field))\n\n\n \n\n#define PHM_READ_FIELD(device, reg, field)\t\\\n\tPHM_GET_FIELD(cgs_read_register(device, mm##reg), reg, field)\n\n#define PHM_READ_INDIRECT_FIELD(device, port, reg, field)\t\\\n\tPHM_GET_FIELD(cgs_read_ind_register(device, port, ix##reg),\t\\\n\t\t\treg, field)\n\n#define PHM_READ_VFPF_INDIRECT_FIELD(device, port, reg, field)\t\\\n\tPHM_GET_FIELD(cgs_read_ind_register(device, port, ix##reg),\t\\\n\t\t\treg, field)\n\n#define PHM_WRITE_FIELD(device, reg, field, fieldval)\t\\\n\tcgs_write_register(device, mm##reg, PHM_SET_FIELD(\t\\\n\t\t\t\tcgs_read_register(device, mm##reg), reg, field, fieldval))\n\n#define PHM_WRITE_INDIRECT_FIELD(device, port, reg, field, fieldval)\t\\\n\tcgs_write_ind_register(device, port, ix##reg,\t\\\n\t\t\tPHM_SET_FIELD(cgs_read_ind_register(device, port, ix##reg),\t\\\n\t\t\t\treg, field, fieldval))\n\n#define PHM_WRITE_VFPF_INDIRECT_FIELD(device, port, reg, field, fieldval)\t\\\n\tcgs_write_ind_register(device, port, ix##reg,\t\\\n\t\t\tPHM_SET_FIELD(cgs_read_ind_register(device, port, ix##reg),\t\\\n\t\t\t\treg, field, fieldval))\n\n#define PHM_WAIT_INDIRECT_REGISTER_GIVEN_INDEX(hwmgr, port, index, value, mask)        \\\n       phm_wait_on_indirect_register(hwmgr, mm##port##_INDEX, index, value, mask)\n\n\n#define PHM_WAIT_INDIRECT_REGISTER(hwmgr, port, reg, value, mask)      \\\n       PHM_WAIT_INDIRECT_REGISTER_GIVEN_INDEX(hwmgr, port, ix##reg, value, mask)\n\n#define PHM_WAIT_INDIRECT_FIELD(hwmgr, port, reg, field, fieldval)\t\\\n\tPHM_WAIT_INDIRECT_REGISTER(hwmgr, port, reg, (fieldval)\t\\\n\t\t\t<< PHM_FIELD_SHIFT(reg, field), PHM_FIELD_MASK(reg, field))\n\n#define PHM_WAIT_INDIRECT_REGISTER_UNEQUAL_GIVEN_INDEX(hwmgr, port, index, value, mask)    \\\n\t\tphm_wait_for_indirect_register_unequal(hwmgr,                   \\\n\t\t\t\tmm##port##_INDEX, index, value, mask)\n\n#define PHM_WAIT_INDIRECT_REGISTER_UNEQUAL(hwmgr, port, reg, value, mask)    \\\n\t\tPHM_WAIT_INDIRECT_REGISTER_UNEQUAL_GIVEN_INDEX(hwmgr, port, ix##reg, value, mask)\n\n#define PHM_WAIT_INDIRECT_FIELD_UNEQUAL(hwmgr, port, reg, field, fieldval)                          \\\n\t\tPHM_WAIT_INDIRECT_REGISTER_UNEQUAL(hwmgr, port, reg, \\\n\t\t\t\t(fieldval) << PHM_FIELD_SHIFT(reg, field), \\\n\t\t\t\t\tPHM_FIELD_MASK(reg, field))\n\n\n#define PHM_WAIT_VFPF_INDIRECT_REGISTER_UNEQUAL_GIVEN_INDEX(hwmgr,\t\\\n\t\t\t\tport, index, value, mask)\t\t\\\n\tphm_wait_for_indirect_register_unequal(hwmgr,\t\t\t\\\n\t\tmm##port##_INDEX_11, index, value, mask)\n\n#define PHM_WAIT_VFPF_INDIRECT_REGISTER_UNEQUAL(hwmgr, port, reg, value, mask)     \\\n\t\tPHM_WAIT_VFPF_INDIRECT_REGISTER_UNEQUAL_GIVEN_INDEX(hwmgr, port, ix##reg, value, mask)\n\n#define PHM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(hwmgr, port, reg, field, fieldval) \\\n\tPHM_WAIT_VFPF_INDIRECT_REGISTER_UNEQUAL(hwmgr, port, reg,\t\\\n\t\t(fieldval) << PHM_FIELD_SHIFT(reg, field),\t\t\\\n\t\tPHM_FIELD_MASK(reg, field))\n\n\n#define PHM_WAIT_VFPF_INDIRECT_REGISTER_GIVEN_INDEX(hwmgr,\t\t\\\n\t\t\t\tport, index, value, mask)\t\t\\\n\tphm_wait_on_indirect_register(hwmgr,\t\t\t\t\\\n\t\tmm##port##_INDEX_11, index, value, mask)\n\n#define PHM_WAIT_VFPF_INDIRECT_REGISTER(hwmgr, port, reg, value, mask) \\\n\tPHM_WAIT_VFPF_INDIRECT_REGISTER_GIVEN_INDEX(hwmgr, port, ix##reg, value, mask)\n\n#define PHM_WAIT_VFPF_INDIRECT_FIELD(hwmgr, port, reg, field, fieldval) \\\n\tPHM_WAIT_VFPF_INDIRECT_REGISTER(hwmgr, port, reg,\t\t\\\n\t\t(fieldval) << PHM_FIELD_SHIFT(reg, field),\t\t\\\n\t\tPHM_FIELD_MASK(reg, field))\n\n#define PHM_WAIT_REGISTER_UNEQUAL_GIVEN_INDEX(hwmgr,         \\\n\t\t\t\t\t\t\tindex, value, mask) \\\n\t\tphm_wait_for_register_unequal(hwmgr,            \\\n\t\t\t\t\tindex, value, mask)\n\n#define PHM_WAIT_REGISTER_UNEQUAL(hwmgr, reg, value, mask)\t\t\\\n\tPHM_WAIT_REGISTER_UNEQUAL_GIVEN_INDEX(hwmgr,\t\t\t\\\n\t\t\t\tmm##reg, value, mask)\n\n#define PHM_WAIT_FIELD_UNEQUAL(hwmgr, reg, field, fieldval)\t\t\\\n\tPHM_WAIT_REGISTER_UNEQUAL(hwmgr, reg,\t\t\t\t\\\n\t\t(fieldval) << PHM_FIELD_SHIFT(reg, field),\t\t\\\n\t\tPHM_FIELD_MASK(reg, field))\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}