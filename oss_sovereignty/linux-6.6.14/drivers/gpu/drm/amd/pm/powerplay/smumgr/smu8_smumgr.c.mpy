{
  "module_name": "smu8_smumgr.c",
  "hash_id": "6c7f699491e1942bfb893458758d2a95a3f40dc5e0e3906cd4fe3de1c6217d12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/smu8_smumgr.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#include \"cgs_common.h\"\n#include \"smu/smu_8_0_d.h\"\n#include \"smu/smu_8_0_sh_mask.h\"\n#include \"smu8.h\"\n#include \"smu8_fusion.h\"\n#include \"smu8_smumgr.h\"\n#include \"cz_ppsmc.h\"\n#include \"smu_ucode_xfer_cz.h\"\n#include \"gca/gfx_8_0_d.h\"\n#include \"gca/gfx_8_0_sh_mask.h\"\n#include \"smumgr.h\"\n\n#define SIZE_ALIGN_32(x)    (((x) + 31) / 32 * 32)\n\nstatic const enum smu8_scratch_entry firmware_list[] = {\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_SDMA0,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_SDMA1,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2,\n\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G,\n};\n\nstatic uint32_t smu8_get_argument(struct pp_hwmgr *hwmgr)\n{\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn 0;\n\n\treturn cgs_read_register(hwmgr->device,\n\t\t\t\t\tmmSMU_MP1_SRBM2P_ARG_0);\n}\n\n \nstatic int smu8_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t    uint16_t msg, uint32_t parameter)\n{\n\tint result = 0;\n\tktime_t t_start;\n\ts64 elapsed_us;\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tresult = PHM_WAIT_FIELD_UNEQUAL(hwmgr,\n\t\t\t\t\tSMU_MP1_SRBM2P_RESP_0, CONTENT, 0);\n\tif (result != 0) {\n\t\t \n\t\tuint32_t val = cgs_read_register(hwmgr->device,\n\t\t\t\t\t\t mmSMU_MP1_SRBM2P_MSG_0);\n\t\tpr_err(\"%s(0x%04x) aborted; SMU still servicing msg (0x%04x)\\n\",\n\t\t\t__func__, msg, val);\n\t\treturn result;\n\t}\n\tt_start = ktime_get();\n\n\tcgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_ARG_0, parameter);\n\n\tcgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_RESP_0, 0);\n\tcgs_write_register(hwmgr->device, mmSMU_MP1_SRBM2P_MSG_0, msg);\n\n\tresult = PHM_WAIT_FIELD_UNEQUAL(hwmgr,\n\t\t\t\t\tSMU_MP1_SRBM2P_RESP_0, CONTENT, 0);\n\n\telapsed_us = ktime_us_delta(ktime_get(), t_start);\n\n\tWARN(result, \"%s(0x%04x, %#x) timed out after %lld us\\n\",\n\t\t\t__func__, msg, parameter, elapsed_us);\n\n\treturn result;\n}\n\nstatic int smu8_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)\n{\n\treturn smu8_send_msg_to_smc_with_parameter(hwmgr, msg, 0);\n}\n\nstatic int smu8_set_smc_sram_address(struct pp_hwmgr *hwmgr,\n\t\t\t\t     uint32_t smc_address, uint32_t limit)\n{\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tif (0 != (3 & smc_address)) {\n\t\tpr_err(\"SMC address must be 4 byte aligned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (limit <= (smc_address + 3)) {\n\t\tpr_err(\"SMC address beyond the SMC RAM area\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX_0,\n\t\t\t\tSMN_MP1_SRAM_START_ADDR + smc_address);\n\n\treturn 0;\n}\n\nstatic int smu8_write_smc_sram_dword(struct pp_hwmgr *hwmgr,\n\t\tuint32_t smc_address, uint32_t value, uint32_t limit)\n{\n\tint result;\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tresult = smu8_set_smc_sram_address(hwmgr, smc_address, limit);\n\tif (!result)\n\t\tcgs_write_register(hwmgr->device, mmMP0PUB_IND_DATA_0, value);\n\n\treturn result;\n}\n\nstatic int smu8_check_fw_load_finish(struct pp_hwmgr *hwmgr,\n\t\t\t\t   uint32_t firmware)\n{\n\tint i;\n\tuint32_t index = SMN_MP1_SRAM_START_ADDR +\n\t\t\t SMU8_FIRMWARE_HEADER_LOCATION +\n\t\t\t offsetof(struct SMU8_Firmware_Header, UcodeLoadStatus);\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tcgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);\n\n\tfor (i = 0; i < hwmgr->usec_timeout; i++) {\n\t\tif (firmware ==\n\t\t\t(cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA) & firmware))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (i >= hwmgr->usec_timeout) {\n\t\tpr_err(\"SMU check loaded firmware failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_load_mec_firmware(struct pp_hwmgr *hwmgr)\n{\n\tuint32_t reg_data;\n\tuint32_t tmp;\n\tint ret = 0;\n\tstruct cgs_firmware_info info = {0};\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tret = cgs_get_firmware_info(hwmgr->device,\n\t\t\t\t\t\tCGS_UCODE_ID_CP_MEC, &info);\n\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\ttmp = cgs_read_register(hwmgr->device,\n\t\t\t\t\tmmCP_MEC_CNTL);\n\ttmp = PHM_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME1_HALT, 1);\n\ttmp = PHM_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME2_HALT, 1);\n\tcgs_write_register(hwmgr->device, mmCP_MEC_CNTL, tmp);\n\n\ttmp = cgs_read_register(hwmgr->device,\n\t\t\t\t\tmmCP_CPC_IC_BASE_CNTL);\n\n\ttmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, VMID, 0);\n\ttmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, ATC, 0);\n\ttmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);\n\ttmp = PHM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, MTYPE, 1);\n\tcgs_write_register(hwmgr->device, mmCP_CPC_IC_BASE_CNTL, tmp);\n\n\treg_data = lower_32_bits(info.mc_addr) &\n\t\t\tPHM_FIELD_MASK(CP_CPC_IC_BASE_LO, IC_BASE_LO);\n\tcgs_write_register(hwmgr->device, mmCP_CPC_IC_BASE_LO, reg_data);\n\n\treg_data = upper_32_bits(info.mc_addr) &\n\t\t\tPHM_FIELD_MASK(CP_CPC_IC_BASE_HI, IC_BASE_HI);\n\tcgs_write_register(hwmgr->device, mmCP_CPC_IC_BASE_HI, reg_data);\n\n\treturn 0;\n}\n\nstatic uint8_t smu8_translate_firmware_enum_to_arg(struct pp_hwmgr *hwmgr,\n\t\t\tenum smu8_scratch_entry firmware_enum)\n{\n\tuint8_t ret = 0;\n\n\tswitch (firmware_enum) {\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA0:\n\t\tret = UCODE_ID_SDMA0;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_SDMA1:\n\t\tif (hwmgr->chip_id == CHIP_STONEY)\n\t\t\tret = UCODE_ID_SDMA0;\n\t\telse\n\t\t\tret = UCODE_ID_SDMA1;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE:\n\t\tret = UCODE_ID_CP_CE;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP:\n\t\tret = UCODE_ID_CP_PFP;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME:\n\t\tret = UCODE_ID_CP_ME;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1:\n\t\tret = UCODE_ID_CP_MEC_JT1;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2:\n\t\tif (hwmgr->chip_id == CHIP_STONEY)\n\t\t\tret = UCODE_ID_CP_MEC_JT1;\n\t\telse\n\t\t\tret = UCODE_ID_CP_MEC_JT2;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_GMCON_RENG:\n\t\tret = UCODE_ID_GMCON_RENG;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G:\n\t\tret = UCODE_ID_RLC_G;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH:\n\t\tret = UCODE_ID_RLC_SCRATCH;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM:\n\t\tret = UCODE_ID_RLC_SRM_ARAM;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM:\n\t\tret = UCODE_ID_RLC_SRM_DRAM;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_DMCU_ERAM:\n\t\tret = UCODE_ID_DMCU_ERAM;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_DMCU_IRAM:\n\t\tret = UCODE_ID_DMCU_IRAM;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING:\n\t\tret = TASK_ARG_INIT_MM_PWR_LOG;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_DATA_ID_SDMA_HALT:\n\tcase SMU8_SCRATCH_ENTRY_DATA_ID_SYS_CLOCKGATING:\n\tcase SMU8_SCRATCH_ENTRY_DATA_ID_SDMA_RING_REGS:\n\tcase SMU8_SCRATCH_ENTRY_DATA_ID_NONGFX_REINIT:\n\tcase SMU8_SCRATCH_ENTRY_DATA_ID_SDMA_START:\n\tcase SMU8_SCRATCH_ENTRY_DATA_ID_IH_REGISTERS:\n\t\tret = TASK_ARG_REG_MMIO;\n\t\tbreak;\n\tcase SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE:\n\t\tret = TASK_ARG_INIT_CLK_TABLE;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic enum cgs_ucode_id smu8_convert_fw_type_to_cgs(uint32_t fw_type)\n{\n\tenum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;\n\n\tswitch (fw_type) {\n\tcase UCODE_ID_SDMA0:\n\t\tresult = CGS_UCODE_ID_SDMA0;\n\t\tbreak;\n\tcase UCODE_ID_SDMA1:\n\t\tresult = CGS_UCODE_ID_SDMA1;\n\t\tbreak;\n\tcase UCODE_ID_CP_CE:\n\t\tresult = CGS_UCODE_ID_CP_CE;\n\t\tbreak;\n\tcase UCODE_ID_CP_PFP:\n\t\tresult = CGS_UCODE_ID_CP_PFP;\n\t\tbreak;\n\tcase UCODE_ID_CP_ME:\n\t\tresult = CGS_UCODE_ID_CP_ME;\n\t\tbreak;\n\tcase UCODE_ID_CP_MEC_JT1:\n\t\tresult = CGS_UCODE_ID_CP_MEC_JT1;\n\t\tbreak;\n\tcase UCODE_ID_CP_MEC_JT2:\n\t\tresult = CGS_UCODE_ID_CP_MEC_JT2;\n\t\tbreak;\n\tcase UCODE_ID_RLC_G:\n\t\tresult = CGS_UCODE_ID_RLC_G;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic int smu8_smu_populate_single_scratch_task(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tenum smu8_scratch_entry fw_enum,\n\t\t\tuint8_t type, bool is_last)\n{\n\tuint8_t i;\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tstruct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;\n\tstruct SMU_Task *task = &toc->tasks[smu8_smu->toc_entry_used_count++];\n\n\ttask->type = type;\n\ttask->arg = smu8_translate_firmware_enum_to_arg(hwmgr, fw_enum);\n\ttask->next = is_last ? END_OF_TASK_LIST : smu8_smu->toc_entry_used_count;\n\n\tfor (i = 0; i < smu8_smu->scratch_buffer_length; i++)\n\t\tif (smu8_smu->scratch_buffer[i].firmware_ID == fw_enum)\n\t\t\tbreak;\n\n\tif (i >= smu8_smu->scratch_buffer_length) {\n\t\tpr_err(\"Invalid Firmware Type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttask->addr.low = lower_32_bits(smu8_smu->scratch_buffer[i].mc_addr);\n\ttask->addr.high = upper_32_bits(smu8_smu->scratch_buffer[i].mc_addr);\n\ttask->size_bytes = smu8_smu->scratch_buffer[i].data_size;\n\n\tif (SMU8_SCRATCH_ENTRY_DATA_ID_IH_REGISTERS == fw_enum) {\n\t\tstruct smu8_ih_meta_data *pIHReg_restore =\n\t\t     (struct smu8_ih_meta_data *)smu8_smu->scratch_buffer[i].kaddr;\n\t\tpIHReg_restore->command =\n\t\t\tMETADATA_CMD_MODE0 | METADATA_PERFORM_ON_LOAD;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_smu_populate_single_ucode_load_task(\n\t\t\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\t\t\tenum smu8_scratch_entry fw_enum,\n\t\t\t\t\tbool is_last)\n{\n\tuint8_t i;\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tstruct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;\n\tstruct SMU_Task *task = &toc->tasks[smu8_smu->toc_entry_used_count++];\n\n\ttask->type = TASK_TYPE_UCODE_LOAD;\n\ttask->arg = smu8_translate_firmware_enum_to_arg(hwmgr, fw_enum);\n\ttask->next = is_last ? END_OF_TASK_LIST : smu8_smu->toc_entry_used_count;\n\n\tfor (i = 0; i < smu8_smu->driver_buffer_length; i++)\n\t\tif (smu8_smu->driver_buffer[i].firmware_ID == fw_enum)\n\t\t\tbreak;\n\n\tif (i >= smu8_smu->driver_buffer_length) {\n\t\tpr_err(\"Invalid Firmware Type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttask->addr.low = lower_32_bits(smu8_smu->driver_buffer[i].mc_addr);\n\ttask->addr.high = upper_32_bits(smu8_smu->driver_buffer[i].mc_addr);\n\ttask->size_bytes = smu8_smu->driver_buffer[i].data_size;\n\n\treturn 0;\n}\n\nstatic int smu8_smu_construct_toc_for_rlc_aram_save(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\n\tsmu8_smu->toc_entry_aram = smu8_smu->toc_entry_used_count;\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,\n\t\t\t\tTASK_TYPE_UCODE_SAVE, true);\n\n\treturn 0;\n}\n\nstatic int smu8_smu_initialize_toc_empty_job_list(struct pp_hwmgr *hwmgr)\n{\n\tint i;\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tstruct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;\n\n\tfor (i = 0; i < NUM_JOBLIST_ENTRIES; i++)\n\t\ttoc->JobList[i] = (uint8_t)IGNORE_JOB;\n\n\treturn 0;\n}\n\nstatic int smu8_smu_construct_toc_for_vddgfx_enter(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tstruct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;\n\n\ttoc->JobList[JOB_GFX_SAVE] = (uint8_t)smu8_smu->toc_entry_used_count;\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\t    SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,\n\t\t\t\t    TASK_TYPE_UCODE_SAVE, false);\n\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\t    SMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,\n\t\t\t\t    TASK_TYPE_UCODE_SAVE, true);\n\n\treturn 0;\n}\n\n\nstatic int smu8_smu_construct_toc_for_vddgfx_exit(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tstruct TOC *toc = (struct TOC *)smu8_smu->toc_buffer.kaddr;\n\n\ttoc->JobList[JOB_GFX_RESTORE] = (uint8_t)smu8_smu->toc_entry_used_count;\n\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);\n\n\tif (hwmgr->chip_id == CHIP_STONEY)\n\t\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);\n\telse\n\t\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2, false);\n\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G, false);\n\n\t \n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,\n\t\t\t\tTASK_TYPE_UCODE_LOAD, false);\n\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,\n\t\t\t\tTASK_TYPE_UCODE_LOAD, false);\n\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,\n\t\t\t\tTASK_TYPE_UCODE_LOAD, true);\n\n\treturn 0;\n}\n\nstatic int smu8_smu_construct_toc_for_power_profiling(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\n\tsmu8_smu->toc_entry_power_profiling_index = smu8_smu->toc_entry_used_count;\n\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING,\n\t\t\t\tTASK_TYPE_INITIALIZE, true);\n\treturn 0;\n}\n\nstatic int smu8_smu_construct_toc_for_bootup(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\n\tsmu8_smu->toc_entry_initialize_index = smu8_smu->toc_entry_used_count;\n\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_SDMA0, false);\n\tif (hwmgr->chip_id != CHIP_STONEY)\n\t\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_SDMA1, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_CE, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_PFP, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_ME, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);\n\tif (hwmgr->chip_id != CHIP_STONEY)\n\t\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2, false);\n\tsmu8_smu_populate_single_ucode_load_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_G, true);\n\n\treturn 0;\n}\n\nstatic int smu8_smu_construct_toc_for_clock_table(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\n\tsmu8_smu->toc_entry_clock_table = smu8_smu->toc_entry_used_count;\n\n\tsmu8_smu_populate_single_scratch_task(hwmgr,\n\t\t\t\tSMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE,\n\t\t\t\tTASK_TYPE_INITIALIZE, true);\n\n\treturn 0;\n}\n\nstatic int smu8_smu_construct_toc(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\n\tsmu8_smu->toc_entry_used_count = 0;\n\tsmu8_smu_initialize_toc_empty_job_list(hwmgr);\n\tsmu8_smu_construct_toc_for_rlc_aram_save(hwmgr);\n\tsmu8_smu_construct_toc_for_vddgfx_enter(hwmgr);\n\tsmu8_smu_construct_toc_for_vddgfx_exit(hwmgr);\n\tsmu8_smu_construct_toc_for_power_profiling(hwmgr);\n\tsmu8_smu_construct_toc_for_bootup(hwmgr);\n\tsmu8_smu_construct_toc_for_clock_table(hwmgr);\n\n\treturn 0;\n}\n\nstatic int smu8_smu_populate_firmware_entries(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tuint32_t firmware_type;\n\tuint32_t i;\n\tint ret;\n\tenum cgs_ucode_id ucode_id;\n\tstruct cgs_firmware_info info = {0};\n\n\tsmu8_smu->driver_buffer_length = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(firmware_list); i++) {\n\n\t\tfirmware_type = smu8_translate_firmware_enum_to_arg(hwmgr,\n\t\t\t\t\tfirmware_list[i]);\n\n\t\tucode_id = smu8_convert_fw_type_to_cgs(firmware_type);\n\n\t\tret = cgs_get_firmware_info(hwmgr->device,\n\t\t\t\t\t\t\tucode_id, &info);\n\n\t\tif (ret == 0) {\n\t\t\tsmu8_smu->driver_buffer[i].mc_addr = info.mc_addr;\n\n\t\t\tsmu8_smu->driver_buffer[i].data_size = info.image_size;\n\n\t\t\tsmu8_smu->driver_buffer[i].firmware_ID = firmware_list[i];\n\t\t\tsmu8_smu->driver_buffer_length++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_smu_populate_single_scratch_entry(\n\t\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\t\tenum smu8_scratch_entry scratch_type,\n\t\t\t\tuint32_t ulsize_byte,\n\t\t\t\tstruct smu8_buffer_entry *entry)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tuint32_t ulsize_aligned = SIZE_ALIGN_32(ulsize_byte);\n\n\tentry->data_size = ulsize_byte;\n\tentry->kaddr = (char *) smu8_smu->smu_buffer.kaddr +\n\t\t\t\tsmu8_smu->smu_buffer_used_bytes;\n\tentry->mc_addr = smu8_smu->smu_buffer.mc_addr + smu8_smu->smu_buffer_used_bytes;\n\tentry->firmware_ID = scratch_type;\n\n\tsmu8_smu->smu_buffer_used_bytes += ulsize_aligned;\n\n\treturn 0;\n}\n\nstatic int smu8_download_pptable_settings(struct pp_hwmgr *hwmgr, void **table)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tunsigned long i;\n\n\tfor (i = 0; i < smu8_smu->scratch_buffer_length; i++) {\n\t\tif (smu8_smu->scratch_buffer[i].firmware_ID\n\t\t\t== SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE)\n\t\t\tbreak;\n\t}\n\n\t*table = (struct SMU8_Fusion_ClkTable *)smu8_smu->scratch_buffer[i].kaddr;\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetClkTableAddrHi,\n\t\t\t\tupper_32_bits(smu8_smu->scratch_buffer[i].mc_addr),\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetClkTableAddrLo,\n\t\t\t\tlower_32_bits(smu8_smu->scratch_buffer[i].mc_addr),\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,\n\t\t\t\tsmu8_smu->toc_entry_clock_table,\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToDram, NULL);\n\n\treturn 0;\n}\n\nstatic int smu8_upload_pptable_settings(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tunsigned long i;\n\n\tfor (i = 0; i < smu8_smu->scratch_buffer_length; i++) {\n\t\tif (smu8_smu->scratch_buffer[i].firmware_ID\n\t\t\t\t== SMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE)\n\t\t\tbreak;\n\t}\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetClkTableAddrHi,\n\t\t\t\tupper_32_bits(smu8_smu->scratch_buffer[i].mc_addr),\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetClkTableAddrLo,\n\t\t\t\tlower_32_bits(smu8_smu->scratch_buffer[i].mc_addr),\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,\n\t\t\t\tsmu8_smu->toc_entry_clock_table,\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_ClkTableXferToSmu, NULL);\n\n\treturn 0;\n}\n\nstatic int smu8_request_smu_load_fw(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu = hwmgr->smu_backend;\n\tuint32_t smc_address;\n\tuint32_t fw_to_check = 0;\n\tint ret;\n\n\tamdgpu_ucode_init_bo(hwmgr->adev);\n\n\tsmu8_smu_populate_firmware_entries(hwmgr);\n\n\tsmu8_smu_construct_toc(hwmgr);\n\n\tsmc_address = SMU8_FIRMWARE_HEADER_LOCATION +\n\t\toffsetof(struct SMU8_Firmware_Header, UcodeLoadStatus);\n\n\tsmu8_write_smc_sram_dword(hwmgr, smc_address, 0, smc_address+4);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DriverDramAddrHi,\n\t\t\t\t\tupper_32_bits(smu8_smu->toc_buffer.mc_addr),\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_DriverDramAddrLo,\n\t\t\t\t\tlower_32_bits(smu8_smu->toc_buffer.mc_addr),\n\t\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc(hwmgr, PPSMC_MSG_InitJobs, NULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_ExecuteJob,\n\t\t\t\t\tsmu8_smu->toc_entry_aram,\n\t\t\t\t\tNULL);\n\tsmum_send_msg_to_smc_with_parameter(hwmgr, PPSMC_MSG_ExecuteJob,\n\t\t\t\tsmu8_smu->toc_entry_power_profiling_index,\n\t\t\t\tNULL);\n\n\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_ExecuteJob,\n\t\t\t\t\tsmu8_smu->toc_entry_initialize_index,\n\t\t\t\t\tNULL);\n\n\tfw_to_check = UCODE_ID_RLC_G_MASK |\n\t\t\tUCODE_ID_SDMA0_MASK |\n\t\t\tUCODE_ID_SDMA1_MASK |\n\t\t\tUCODE_ID_CP_CE_MASK |\n\t\t\tUCODE_ID_CP_ME_MASK |\n\t\t\tUCODE_ID_CP_PFP_MASK |\n\t\t\tUCODE_ID_CP_MEC_JT1_MASK |\n\t\t\tUCODE_ID_CP_MEC_JT2_MASK;\n\n\tif (hwmgr->chip_id == CHIP_STONEY)\n\t\tfw_to_check &= ~(UCODE_ID_SDMA1_MASK | UCODE_ID_CP_MEC_JT2_MASK);\n\n\tret = smu8_check_fw_load_finish(hwmgr, fw_to_check);\n\tif (ret) {\n\t\tpr_err(\"SMU firmware load failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = smu8_load_mec_firmware(hwmgr);\n\tif (ret) {\n\t\tpr_err(\"Mec Firmware load failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int smu8_start_smu(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev;\n\n\tuint32_t index = SMN_MP1_SRAM_START_ADDR +\n\t\t\t SMU8_FIRMWARE_HEADER_LOCATION +\n\t\t\t offsetof(struct SMU8_Firmware_Header, Version);\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tadev = hwmgr->adev;\n\n\tcgs_write_register(hwmgr->device, mmMP0PUB_IND_INDEX, index);\n\thwmgr->smu_version = cgs_read_register(hwmgr->device, mmMP0PUB_IND_DATA);\n\tpr_info(\"smu version %02d.%02d.%02d\\n\",\n\t\t((hwmgr->smu_version >> 16) & 0xFF),\n\t\t((hwmgr->smu_version >> 8) & 0xFF),\n\t\t(hwmgr->smu_version & 0xFF));\n\tadev->pm.fw_version = hwmgr->smu_version >> 8;\n\n\treturn smu8_request_smu_load_fw(hwmgr);\n}\n\nstatic int smu8_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tint ret = 0;\n\tstruct smu8_smumgr *smu8_smu;\n\n\tsmu8_smu = kzalloc(sizeof(struct smu8_smumgr), GFP_KERNEL);\n\tif (smu8_smu == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = smu8_smu;\n\n\tsmu8_smu->toc_buffer.data_size = 4096;\n\tsmu8_smu->smu_buffer.data_size =\n\t\tALIGN(UCODE_ID_RLC_SCRATCH_SIZE_BYTE, 32) +\n\t\tALIGN(UCODE_ID_RLC_SRM_ARAM_SIZE_BYTE, 32) +\n\t\tALIGN(UCODE_ID_RLC_SRM_DRAM_SIZE_BYTE, 32) +\n\t\tALIGN(sizeof(struct SMU8_MultimediaPowerLogData), 32) +\n\t\tALIGN(sizeof(struct SMU8_Fusion_ClkTable), 32);\n\n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\tsmu8_smu->toc_buffer.data_size,\n\t\t\t\tPAGE_SIZE,\n\t\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t&smu8_smu->toc_buffer.handle,\n\t\t\t\t&smu8_smu->toc_buffer.mc_addr,\n\t\t\t\t&smu8_smu->toc_buffer.kaddr);\n\tif (ret)\n\t\tgoto err2;\n\n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\tsmu8_smu->smu_buffer.data_size,\n\t\t\t\tPAGE_SIZE,\n\t\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t&smu8_smu->smu_buffer.handle,\n\t\t\t\t&smu8_smu->smu_buffer.mc_addr,\n\t\t\t\t&smu8_smu->smu_buffer.kaddr);\n\tif (ret)\n\t\tgoto err1;\n\n\tif (0 != smu8_smu_populate_single_scratch_entry(hwmgr,\n\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,\n\t\tUCODE_ID_RLC_SCRATCH_SIZE_BYTE,\n\t\t&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {\n\t\tpr_err(\"Error when Populate Firmware Entry.\\n\");\n\t\tgoto err0;\n\t}\n\n\tif (0 != smu8_smu_populate_single_scratch_entry(hwmgr,\n\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,\n\t\tUCODE_ID_RLC_SRM_ARAM_SIZE_BYTE,\n\t\t&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {\n\t\tpr_err(\"Error when Populate Firmware Entry.\\n\");\n\t\tgoto err0;\n\t}\n\tif (0 != smu8_smu_populate_single_scratch_entry(hwmgr,\n\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,\n\t\tUCODE_ID_RLC_SRM_DRAM_SIZE_BYTE,\n\t\t&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {\n\t\tpr_err(\"Error when Populate Firmware Entry.\\n\");\n\t\tgoto err0;\n\t}\n\n\tif (0 != smu8_smu_populate_single_scratch_entry(hwmgr,\n\t\tSMU8_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING,\n\t\tsizeof(struct SMU8_MultimediaPowerLogData),\n\t\t&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {\n\t\tpr_err(\"Error when Populate Firmware Entry.\\n\");\n\t\tgoto err0;\n\t}\n\n\tif (0 != smu8_smu_populate_single_scratch_entry(hwmgr,\n\t\tSMU8_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE,\n\t\tsizeof(struct SMU8_Fusion_ClkTable),\n\t\t&smu8_smu->scratch_buffer[smu8_smu->scratch_buffer_length++])) {\n\t\tpr_err(\"Error when Populate Firmware Entry.\\n\");\n\t\tgoto err0;\n\t}\n\n\treturn 0;\n\nerr0:\n\tamdgpu_bo_free_kernel(&smu8_smu->smu_buffer.handle,\n\t\t\t\t&smu8_smu->smu_buffer.mc_addr,\n\t\t\t\t&smu8_smu->smu_buffer.kaddr);\nerr1:\n\tamdgpu_bo_free_kernel(&smu8_smu->toc_buffer.handle,\n\t\t\t\t&smu8_smu->toc_buffer.mc_addr,\n\t\t\t\t&smu8_smu->toc_buffer.kaddr);\nerr2:\n\tkfree(smu8_smu);\n\treturn -EINVAL;\n}\n\nstatic int smu8_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu8_smumgr *smu8_smu;\n\n\tif (hwmgr == NULL || hwmgr->device == NULL)\n\t\treturn -EINVAL;\n\n\tsmu8_smu = hwmgr->smu_backend;\n\tif (smu8_smu) {\n\t\tamdgpu_bo_free_kernel(&smu8_smu->toc_buffer.handle,\n\t\t\t\t\t&smu8_smu->toc_buffer.mc_addr,\n\t\t\t\t\t&smu8_smu->toc_buffer.kaddr);\n\t\tamdgpu_bo_free_kernel(&smu8_smu->smu_buffer.handle,\n\t\t\t\t\t&smu8_smu->smu_buffer.mc_addr,\n\t\t\t\t\t&smu8_smu->smu_buffer.kaddr);\n\t\tkfree(smu8_smu);\n\t}\n\n\treturn 0;\n}\n\nstatic bool smu8_dpm_check_smu_features(struct pp_hwmgr *hwmgr,\n\t\t\t\tunsigned long check_feature)\n{\n\tint result;\n\tuint32_t features;\n\n\tresult = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_GetFeatureStatus,\n\t\t\t\t0,\n\t\t\t\t&features);\n\tif (result == 0) {\n\t\tif (features & check_feature)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool smu8_is_dpm_running(struct pp_hwmgr *hwmgr)\n{\n\tif (smu8_dpm_check_smu_features(hwmgr, SMU_EnabledFeatureScoreboard_SclkDpmOn))\n\t\treturn true;\n\treturn false;\n}\n\nconst struct pp_smumgr_func smu8_smu_funcs = {\n\t.name = \"smu8_smu\",\n\t.smu_init = smu8_smu_init,\n\t.smu_fini = smu8_smu_fini,\n\t.start_smu = smu8_start_smu,\n\t.check_fw_load_finish = smu8_check_fw_load_finish,\n\t.request_smu_load_fw = NULL,\n\t.request_smu_load_specific_fw = NULL,\n\t.get_argument = smu8_get_argument,\n\t.send_msg_to_smc = smu8_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = smu8_send_msg_to_smc_with_parameter,\n\t.download_pptable_settings = smu8_download_pptable_settings,\n\t.upload_pptable_settings = smu8_upload_pptable_settings,\n\t.is_dpm_running = smu8_is_dpm_running,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}