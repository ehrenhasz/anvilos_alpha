{
  "module_name": "amd_powerplay.c",
  "hash_id": "6b733f94c11af76a0407749f9441dbc8181fb37b526bf5d7d053b63a749701a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/amd_powerplay.c",
  "human_readable_source": " \n#include \"pp_debug.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/reboot.h>\n#include \"amd_shared.h\"\n#include \"amd_powerplay.h\"\n#include \"power_state.h\"\n#include \"amdgpu.h\"\n#include \"hwmgr.h\"\n#include \"amdgpu_dpm_internal.h\"\n#include \"amdgpu_display.h\"\n\nstatic const struct amd_pm_funcs pp_dpm_funcs;\n\nstatic int amd_powerplay_create(struct amdgpu_device *adev)\n{\n\tstruct pp_hwmgr *hwmgr;\n\n\tif (adev == NULL)\n\t\treturn -EINVAL;\n\n\thwmgr = kzalloc(sizeof(struct pp_hwmgr), GFP_KERNEL);\n\tif (hwmgr == NULL)\n\t\treturn -ENOMEM;\n\n\thwmgr->adev = adev;\n\thwmgr->not_vf = !amdgpu_sriov_vf(adev);\n\thwmgr->device = amdgpu_cgs_create_device(adev);\n\tmutex_init(&hwmgr->msg_lock);\n\thwmgr->chip_family = adev->family;\n\thwmgr->chip_id = adev->asic_type;\n\thwmgr->feature_mask = adev->pm.pp_feature;\n\thwmgr->display_config = &adev->pm.pm_display_cfg;\n\tadev->powerplay.pp_handle = hwmgr;\n\tadev->powerplay.pp_funcs = &pp_dpm_funcs;\n\treturn 0;\n}\n\n\nstatic void amd_powerplay_destroy(struct amdgpu_device *adev)\n{\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\tmutex_destroy(&hwmgr->msg_lock);\n\n\tkfree(hwmgr->hardcode_pp_table);\n\thwmgr->hardcode_pp_table = NULL;\n\n\tkfree(hwmgr);\n\thwmgr = NULL;\n}\n\nstatic int pp_early_init(void *handle)\n{\n\tint ret;\n\tstruct amdgpu_device *adev = handle;\n\n\tret = amd_powerplay_create(adev);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = hwmgr_early_init(adev->powerplay.pp_handle);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void pp_swctf_delayed_work_handler(struct work_struct *work)\n{\n\tstruct pp_hwmgr *hwmgr =\n\t\tcontainer_of(work, struct pp_hwmgr, swctf_delayed_work.work);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct amdgpu_dpm_thermal *range =\n\t\t\t\t&adev->pm.dpm.thermal;\n\tuint32_t gpu_temperature, size;\n\tint ret;\n\n\t \n\tif (range->sw_ctf_threshold &&\n\t    hwmgr->hwmgr_func->read_sensor) {\n\t\tret = hwmgr->hwmgr_func->read_sensor(hwmgr,\n\t\t\t\t\t\t     AMDGPU_PP_SENSOR_HOTSPOT_TEMP,\n\t\t\t\t\t\t     &gpu_temperature,\n\t\t\t\t\t\t     &size);\n\t\t \n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tret = hwmgr->hwmgr_func->read_sensor(hwmgr,\n\t\t\t\t\t\t\t     AMDGPU_PP_SENSOR_EDGE_TEMP,\n\t\t\t\t\t\t\t     &gpu_temperature,\n\t\t\t\t\t\t\t     &size);\n\t\tif (!ret && gpu_temperature / 1000 < range->sw_ctf_threshold)\n\t\t\treturn;\n\t}\n\n\tdev_emerg(adev->dev, \"ERROR: GPU over temperature range(SW CTF) detected!\\n\");\n\tdev_emerg(adev->dev, \"ERROR: System is going to shutdown due to GPU SW CTF!\\n\");\n\torderly_poweroff(true);\n}\n\nstatic int pp_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\tint ret = 0;\n\n\tret = hwmgr_sw_init(hwmgr);\n\n\tpr_debug(\"powerplay sw init %s\\n\", ret ? \"failed\" : \"successfully\");\n\n\tif (!ret)\n\t\tINIT_DELAYED_WORK(&hwmgr->swctf_delayed_work,\n\t\t\t\t  pp_swctf_delayed_work_handler);\n\n\treturn ret;\n}\n\nstatic int pp_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\thwmgr_sw_fini(hwmgr);\n\n\tamdgpu_ucode_release(&adev->pm.fw);\n\n\treturn 0;\n}\n\nstatic int pp_hw_init(void *handle)\n{\n\tint ret = 0;\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\tret = hwmgr_hw_init(hwmgr);\n\n\tif (ret)\n\t\tpr_err(\"powerplay hw init failed\\n\");\n\n\treturn ret;\n}\n\nstatic int pp_hw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\tcancel_delayed_work_sync(&hwmgr->swctf_delayed_work);\n\n\thwmgr_hw_fini(hwmgr);\n\n\treturn 0;\n}\n\nstatic void pp_reserve_vram_for_smu(struct amdgpu_device *adev)\n{\n\tint r = -EINVAL;\n\tvoid *cpu_ptr = NULL;\n\tuint64_t gpu_addr;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\tif (amdgpu_bo_create_kernel(adev, adev->pm.smu_prv_buffer_size,\n\t\t\t\t\t\tPAGE_SIZE, AMDGPU_GEM_DOMAIN_GTT,\n\t\t\t\t\t\t&adev->pm.smu_prv_buffer,\n\t\t\t\t\t\t&gpu_addr,\n\t\t\t\t\t\t&cpu_ptr)) {\n\t\tDRM_ERROR(\"amdgpu: failed to create smu prv buffer\\n\");\n\t\treturn;\n\t}\n\n\tif (hwmgr->hwmgr_func->notify_cac_buffer_info)\n\t\tr = hwmgr->hwmgr_func->notify_cac_buffer_info(hwmgr,\n\t\t\t\t\tlower_32_bits((unsigned long)cpu_ptr),\n\t\t\t\t\tupper_32_bits((unsigned long)cpu_ptr),\n\t\t\t\t\tlower_32_bits(gpu_addr),\n\t\t\t\t\tupper_32_bits(gpu_addr),\n\t\t\t\t\tadev->pm.smu_prv_buffer_size);\n\n\tif (r) {\n\t\tamdgpu_bo_free_kernel(&adev->pm.smu_prv_buffer, NULL, NULL);\n\t\tadev->pm.smu_prv_buffer = NULL;\n\t\tDRM_ERROR(\"amdgpu: failed to notify SMU buffer address\\n\");\n\t}\n}\n\nstatic int pp_late_init(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\tif (hwmgr && hwmgr->pm_en)\n\t\thwmgr_handle_task(hwmgr,\n\t\t\t\t\tAMD_PP_TASK_COMPLETE_INIT, NULL);\n\tif (adev->pm.smu_prv_buffer_size != 0)\n\t\tpp_reserve_vram_for_smu(adev);\n\n\treturn 0;\n}\n\nstatic void pp_late_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\n\tif (adev->pm.smu_prv_buffer)\n\t\tamdgpu_bo_free_kernel(&adev->pm.smu_prv_buffer, NULL, NULL);\n\tamd_powerplay_destroy(adev);\n}\n\n\nstatic bool pp_is_idle(void *handle)\n{\n\treturn false;\n}\n\nstatic int pp_wait_for_idle(void *handle)\n{\n\treturn 0;\n}\n\nstatic int pp_sw_reset(void *handle)\n{\n\treturn 0;\n}\n\nstatic int pp_set_powergating_state(void *handle,\n\t\t\t\t    enum amd_powergating_state state)\n{\n\treturn 0;\n}\n\nstatic int pp_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\tcancel_delayed_work_sync(&hwmgr->swctf_delayed_work);\n\n\treturn hwmgr_suspend(hwmgr);\n}\n\nstatic int pp_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct pp_hwmgr *hwmgr = adev->powerplay.pp_handle;\n\n\treturn hwmgr_resume(hwmgr);\n}\n\nstatic int pp_set_clockgating_state(void *handle,\n\t\t\t\t\t  enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs pp_ip_funcs = {\n\t.name = \"powerplay\",\n\t.early_init = pp_early_init,\n\t.late_init = pp_late_init,\n\t.sw_init = pp_sw_init,\n\t.sw_fini = pp_sw_fini,\n\t.hw_init = pp_hw_init,\n\t.hw_fini = pp_hw_fini,\n\t.late_fini = pp_late_fini,\n\t.suspend = pp_suspend,\n\t.resume = pp_resume,\n\t.is_idle = pp_is_idle,\n\t.wait_for_idle = pp_wait_for_idle,\n\t.soft_reset = pp_sw_reset,\n\t.set_clockgating_state = pp_set_clockgating_state,\n\t.set_powergating_state = pp_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version pp_smu_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_SMC,\n\t.major = 1,\n\t.minor = 0,\n\t.rev = 0,\n\t.funcs = &pp_ip_funcs,\n};\n\n \nstatic int pp_dpm_load_fw(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->smumgr_funcs || !hwmgr->smumgr_funcs->start_smu)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->smumgr_funcs->start_smu(hwmgr)) {\n\t\tpr_err(\"fw load failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int pp_dpm_fw_loading_complete(void *handle)\n{\n\treturn 0;\n}\n\nstatic int pp_set_clockgating_by_smu(void *handle, uint32_t msg_id)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->update_clock_gatings == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn hwmgr->hwmgr_func->update_clock_gatings(hwmgr, &msg_id);\n}\n\nstatic void pp_dpm_en_umd_pstate(struct pp_hwmgr  *hwmgr,\n\t\t\t\t\t\tenum amd_dpm_forced_level *level)\n{\n\tuint32_t profile_mode_mask = AMD_DPM_FORCED_LEVEL_PROFILE_STANDARD |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_SCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_MIN_MCLK |\n\t\t\t\t\tAMD_DPM_FORCED_LEVEL_PROFILE_PEAK;\n\n\tif (!(hwmgr->dpm_level & profile_mode_mask)) {\n\t\t \n\t\tif (*level & profile_mode_mask) {\n\t\t\thwmgr->saved_dpm_level = hwmgr->dpm_level;\n\t\t\thwmgr->en_umd_pstate = true;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!(*level & profile_mode_mask)) {\n\t\t\tif (*level == AMD_DPM_FORCED_LEVEL_PROFILE_EXIT)\n\t\t\t\t*level = hwmgr->saved_dpm_level;\n\t\t\thwmgr->en_umd_pstate = false;\n\t\t}\n\t}\n}\n\nstatic int pp_dpm_force_performance_level(void *handle,\n\t\t\t\t\tenum amd_dpm_forced_level level)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (level == hwmgr->dpm_level)\n\t\treturn 0;\n\n\tpp_dpm_en_umd_pstate(hwmgr, &level);\n\thwmgr->request_dpm_level = level;\n\thwmgr_handle_task(hwmgr, AMD_PP_TASK_READJUST_POWER_STATE, NULL);\n\n\treturn 0;\n}\n\nstatic enum amd_dpm_forced_level pp_dpm_get_performance_level(\n\t\t\t\t\t\t\t\tvoid *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\treturn hwmgr->dpm_level;\n}\n\nstatic uint32_t pp_dpm_get_sclk(void *handle, bool low)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn 0;\n\n\tif (hwmgr->hwmgr_func->get_sclk == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\treturn hwmgr->hwmgr_func->get_sclk(hwmgr, low);\n}\n\nstatic uint32_t pp_dpm_get_mclk(void *handle, bool low)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn 0;\n\n\tif (hwmgr->hwmgr_func->get_mclk == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\treturn hwmgr->hwmgr_func->get_mclk(hwmgr, low);\n}\n\nstatic void pp_dpm_powergate_vce(void *handle, bool gate)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn;\n\n\tif (hwmgr->hwmgr_func->powergate_vce == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn;\n\t}\n\thwmgr->hwmgr_func->powergate_vce(hwmgr, gate);\n}\n\nstatic void pp_dpm_powergate_uvd(void *handle, bool gate)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn;\n\n\tif (hwmgr->hwmgr_func->powergate_uvd == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn;\n\t}\n\thwmgr->hwmgr_func->powergate_uvd(hwmgr, gate);\n}\n\nstatic int pp_dpm_dispatch_tasks(void *handle, enum amd_pp_task task_id,\n\t\tenum amd_pm_state_type *user_state)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\treturn hwmgr_handle_task(hwmgr, task_id, user_state);\n}\n\nstatic enum amd_pm_state_type pp_dpm_get_current_power_state(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tstruct pp_power_state *state;\n\tenum amd_pm_state_type pm_type;\n\n\tif (!hwmgr || !hwmgr->pm_en || !hwmgr->current_ps)\n\t\treturn -EINVAL;\n\n\tstate = hwmgr->current_ps;\n\n\tswitch (state->classification.ui_label) {\n\tcase PP_StateUILabel_Battery:\n\t\tpm_type = POWER_STATE_TYPE_BATTERY;\n\t\tbreak;\n\tcase PP_StateUILabel_Balanced:\n\t\tpm_type = POWER_STATE_TYPE_BALANCED;\n\t\tbreak;\n\tcase PP_StateUILabel_Performance:\n\t\tpm_type = POWER_STATE_TYPE_PERFORMANCE;\n\t\tbreak;\n\tdefault:\n\t\tif (state->classification.flags & PP_StateClassificationFlag_Boot)\n\t\t\tpm_type = POWER_STATE_TYPE_INTERNAL_BOOT;\n\t\telse\n\t\t\tpm_type = POWER_STATE_TYPE_DEFAULT;\n\t\tbreak;\n\t}\n\n\treturn pm_type;\n}\n\nstatic int pp_dpm_set_fan_control_mode(void *handle, uint32_t mode)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->hwmgr_func->set_fan_control_mode == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode == U32_MAX)\n\t\treturn -EINVAL;\n\n\thwmgr->hwmgr_func->set_fan_control_mode(hwmgr, mode);\n\n\treturn 0;\n}\n\nstatic int pp_dpm_get_fan_control_mode(void *handle, uint32_t *fan_mode)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->hwmgr_func->get_fan_control_mode == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!fan_mode)\n\t\treturn -EINVAL;\n\n\t*fan_mode = hwmgr->hwmgr_func->get_fan_control_mode(hwmgr);\n\treturn 0;\n}\n\nstatic int pp_dpm_set_fan_speed_pwm(void *handle, uint32_t speed)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->hwmgr_func->set_fan_speed_pwm == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == U32_MAX)\n\t\treturn -EINVAL;\n\n\treturn hwmgr->hwmgr_func->set_fan_speed_pwm(hwmgr, speed);\n}\n\nstatic int pp_dpm_get_fan_speed_pwm(void *handle, uint32_t *speed)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->hwmgr_func->get_fan_speed_pwm == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!speed)\n\t\treturn -EINVAL;\n\n\treturn hwmgr->hwmgr_func->get_fan_speed_pwm(hwmgr, speed);\n}\n\nstatic int pp_dpm_get_fan_speed_rpm(void *handle, uint32_t *rpm)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->hwmgr_func->get_fan_speed_rpm == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!rpm)\n\t\treturn -EINVAL;\n\n\treturn hwmgr->hwmgr_func->get_fan_speed_rpm(hwmgr, rpm);\n}\n\nstatic int pp_dpm_set_fan_speed_rpm(void *handle, uint32_t rpm)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->hwmgr_func->set_fan_speed_rpm == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tif (rpm == U32_MAX)\n\t\treturn -EINVAL;\n\n\treturn hwmgr->hwmgr_func->set_fan_speed_rpm(hwmgr, rpm);\n}\n\nstatic int pp_dpm_get_pp_num_states(void *handle,\n\t\tstruct pp_states_info *data)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tint i;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tif (!hwmgr || !hwmgr->pm_en || !hwmgr->ps)\n\t\treturn -EINVAL;\n\n\tdata->nums = hwmgr->num_ps;\n\n\tfor (i = 0; i < hwmgr->num_ps; i++) {\n\t\tstruct pp_power_state *state = (struct pp_power_state *)\n\t\t\t\t((unsigned long)hwmgr->ps + i * hwmgr->ps_size);\n\t\tswitch (state->classification.ui_label) {\n\t\tcase PP_StateUILabel_Battery:\n\t\t\tdata->states[i] = POWER_STATE_TYPE_BATTERY;\n\t\t\tbreak;\n\t\tcase PP_StateUILabel_Balanced:\n\t\t\tdata->states[i] = POWER_STATE_TYPE_BALANCED;\n\t\t\tbreak;\n\t\tcase PP_StateUILabel_Performance:\n\t\t\tdata->states[i] = POWER_STATE_TYPE_PERFORMANCE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (state->classification.flags & PP_StateClassificationFlag_Boot)\n\t\t\t\tdata->states[i] = POWER_STATE_TYPE_INTERNAL_BOOT;\n\t\t\telse\n\t\t\t\tdata->states[i] = POWER_STATE_TYPE_DEFAULT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pp_dpm_get_pp_table(void *handle, char **table)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !hwmgr->soft_pp_table)\n\t\treturn -EINVAL;\n\n\t*table = (char *)hwmgr->soft_pp_table;\n\treturn hwmgr->soft_pp_table_size;\n}\n\nstatic int amd_powerplay_reset(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tint ret;\n\n\tret = hwmgr_hw_fini(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hwmgr_hw_init(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hwmgr_handle_task(hwmgr, AMD_PP_TASK_COMPLETE_INIT, NULL);\n}\n\nstatic int pp_dpm_set_pp_table(void *handle, const char *buf, size_t size)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tint ret = -ENOMEM;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->hardcode_pp_table) {\n\t\thwmgr->hardcode_pp_table = kmemdup(hwmgr->soft_pp_table,\n\t\t\t\t\t\t   hwmgr->soft_pp_table_size,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!hwmgr->hardcode_pp_table)\n\t\t\treturn ret;\n\t}\n\n\tmemcpy(hwmgr->hardcode_pp_table, buf, size);\n\n\thwmgr->soft_pp_table = hwmgr->hardcode_pp_table;\n\n\tret = amd_powerplay_reset(handle);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hwmgr->hwmgr_func->avfs_control)\n\t\tret = hwmgr->hwmgr_func->avfs_control(hwmgr, false);\n\n\treturn ret;\n}\n\nstatic int pp_dpm_force_clock_level(void *handle,\n\t\tenum pp_clock_type type, uint32_t mask)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->force_clock_level == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\tpr_debug(\"force clock level is for dpm manual mode only.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwmgr->hwmgr_func->force_clock_level(hwmgr, type, mask);\n}\n\nstatic int pp_dpm_emit_clock_levels(void *handle,\n\t\t\t\t    enum pp_clock_type type,\n\t\t\t\t    char *buf,\n\t\t\t\t    int *offset)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!hwmgr->hwmgr_func->emit_clock_levels)\n\t\treturn -ENOENT;\n\n\treturn hwmgr->hwmgr_func->emit_clock_levels(hwmgr, type, buf, offset);\n}\n\nstatic int pp_dpm_print_clock_levels(void *handle,\n\t\tenum pp_clock_type type, char *buf)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->print_clock_levels == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\treturn hwmgr->hwmgr_func->print_clock_levels(hwmgr, type, buf);\n}\n\nstatic int pp_dpm_get_sclk_od(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->get_sclk_od == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\treturn hwmgr->hwmgr_func->get_sclk_od(hwmgr);\n}\n\nstatic int pp_dpm_set_sclk_od(void *handle, uint32_t value)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_sclk_od == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn hwmgr->hwmgr_func->set_sclk_od(hwmgr, value);\n}\n\nstatic int pp_dpm_get_mclk_od(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->get_mclk_od == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\treturn hwmgr->hwmgr_func->get_mclk_od(hwmgr);\n}\n\nstatic int pp_dpm_set_mclk_od(void *handle, uint32_t value)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_mclk_od == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\treturn hwmgr->hwmgr_func->set_mclk_od(hwmgr, value);\n}\n\nstatic int pp_dpm_read_sensor(void *handle, int idx,\n\t\t\t      void *value, int *size)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !value)\n\t\treturn -EINVAL;\n\n\tswitch (idx) {\n\tcase AMDGPU_PP_SENSOR_STABLE_PSTATE_SCLK:\n\t\t*((uint32_t *)value) = hwmgr->pstate_sclk * 100;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_STABLE_PSTATE_MCLK:\n\t\t*((uint32_t *)value) = hwmgr->pstate_mclk * 100;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_PEAK_PSTATE_SCLK:\n\t\t*((uint32_t *)value) = hwmgr->pstate_sclk_peak * 100;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_PEAK_PSTATE_MCLK:\n\t\t*((uint32_t *)value) = hwmgr->pstate_mclk_peak * 100;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_MIN_FAN_RPM:\n\t\t*((uint32_t *)value) = hwmgr->thermal_controller.fanInfo.ulMinRPM;\n\t\treturn 0;\n\tcase AMDGPU_PP_SENSOR_MAX_FAN_RPM:\n\t\t*((uint32_t *)value) = hwmgr->thermal_controller.fanInfo.ulMaxRPM;\n\t\treturn 0;\n\tdefault:\n\t\treturn hwmgr->hwmgr_func->read_sensor(hwmgr, idx, value, size);\n\t}\n}\n\nstatic struct amd_vce_state*\npp_dpm_get_vce_clock_state(void *handle, unsigned idx)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn NULL;\n\n\tif (idx < hwmgr->num_vce_state_tables)\n\t\treturn &hwmgr->vce_states[idx];\n\treturn NULL;\n}\n\nstatic int pp_get_power_profile_mode(void *handle, char *buf)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !hwmgr->hwmgr_func->get_power_profile_mode)\n\t\treturn -EOPNOTSUPP;\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\treturn hwmgr->hwmgr_func->get_power_profile_mode(hwmgr, buf);\n}\n\nstatic int pp_set_power_profile_mode(void *handle, long *input, uint32_t size)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !hwmgr->hwmgr_func->set_power_profile_mode)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL) {\n\t\tpr_debug(\"power profile setting is for manual dpm mode only.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwmgr->hwmgr_func->set_power_profile_mode(hwmgr, input, size);\n}\n\nstatic int pp_set_fine_grain_clk_vol(void *handle, uint32_t type, long *input, uint32_t size)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_fine_grain_clk_vol == NULL)\n\t\treturn 0;\n\n\treturn hwmgr->hwmgr_func->set_fine_grain_clk_vol(hwmgr, type, input, size);\n}\n\nstatic int pp_odn_edit_dpm_table(void *handle, enum PP_OD_DPM_TABLE_COMMAND type,\n\t\t\t\t long *input, uint32_t size)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->odn_edit_dpm_table == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn hwmgr->hwmgr_func->odn_edit_dpm_table(hwmgr, type, input, size);\n}\n\nstatic int pp_dpm_set_mp1_state(void *handle, enum pp_mp1_state mp1_state)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->pm_en)\n\t\treturn 0;\n\n\tif (hwmgr->hwmgr_func->set_mp1_state)\n\t\treturn hwmgr->hwmgr_func->set_mp1_state(hwmgr, mp1_state);\n\n\treturn 0;\n}\n\nstatic int pp_dpm_switch_power_profile(void *handle,\n\t\tenum PP_SMC_POWER_PROFILE type, bool en)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tlong workload;\n\tuint32_t index;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_power_profile_mode == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(type < PP_SMC_POWER_PROFILE_CUSTOM))\n\t\treturn -EINVAL;\n\n\tif (!en) {\n\t\thwmgr->workload_mask &= ~(1 << hwmgr->workload_prority[type]);\n\t\tindex = fls(hwmgr->workload_mask);\n\t\tindex = index > 0 && index <= Workload_Policy_Max ? index - 1 : 0;\n\t\tworkload = hwmgr->workload_setting[index];\n\t} else {\n\t\thwmgr->workload_mask |= (1 << hwmgr->workload_prority[type]);\n\t\tindex = fls(hwmgr->workload_mask);\n\t\tindex = index <= Workload_Policy_Max ? index - 1 : 0;\n\t\tworkload = hwmgr->workload_setting[index];\n\t}\n\n\tif (type == PP_SMC_POWER_PROFILE_COMPUTE &&\n\t\thwmgr->hwmgr_func->disable_power_features_for_compute_performance) {\n\t\t\tif (hwmgr->hwmgr_func->disable_power_features_for_compute_performance(hwmgr, en))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (hwmgr->dpm_level != AMD_DPM_FORCED_LEVEL_MANUAL)\n\t\thwmgr->hwmgr_func->set_power_profile_mode(hwmgr, &workload, 0);\n\n\treturn 0;\n}\n\nstatic int pp_set_power_limit(void *handle, uint32_t limit)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tuint32_t max_power_limit;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_power_limit == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (limit == 0)\n\t\tlimit = hwmgr->default_power_limit;\n\n\tmax_power_limit = hwmgr->default_power_limit;\n\tif (hwmgr->od_enabled) {\n\t\tmax_power_limit *= (100 + hwmgr->platform_descriptor.TDPODLimit);\n\t\tmax_power_limit /= 100;\n\t}\n\n\tif (limit > max_power_limit)\n\t\treturn -EINVAL;\n\n\thwmgr->hwmgr_func->set_power_limit(hwmgr, limit);\n\thwmgr->power_limit = limit;\n\treturn 0;\n}\n\nstatic int pp_get_power_limit(void *handle, uint32_t *limit,\n\t\t\t      enum pp_power_limit_level pp_limit_level,\n\t\t\t      enum pp_power_type power_type)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tint ret = 0;\n\n\tif (!hwmgr || !hwmgr->pm_en || !limit)\n\t\treturn -EINVAL;\n\n\tif (power_type != PP_PWR_TYPE_SUSTAINED)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (pp_limit_level) {\n\t\tcase PP_PWR_LIMIT_CURRENT:\n\t\t\t*limit = hwmgr->power_limit;\n\t\t\tbreak;\n\t\tcase PP_PWR_LIMIT_DEFAULT:\n\t\t\t*limit = hwmgr->default_power_limit;\n\t\t\tbreak;\n\t\tcase PP_PWR_LIMIT_MAX:\n\t\t\t*limit = hwmgr->default_power_limit;\n\t\t\tif (hwmgr->od_enabled) {\n\t\t\t\t*limit *= (100 + hwmgr->platform_descriptor.TDPODLimit);\n\t\t\t\t*limit /= 100;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int pp_display_configuration_change(void *handle,\n\tconst struct amd_pp_display_configuration *display_config)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tphm_store_dal_configuration_data(hwmgr, display_config);\n\treturn 0;\n}\n\nstatic int pp_get_display_power_level(void *handle,\n\t\tstruct amd_pp_simple_clock_info *output)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !output)\n\t\treturn -EINVAL;\n\n\treturn phm_get_dal_power_level(hwmgr, output);\n}\n\nstatic int pp_get_current_clocks(void *handle,\n\t\tstruct amd_pp_clock_info *clocks)\n{\n\tstruct amd_pp_simple_clock_info simple_clocks = { 0 };\n\tstruct pp_clock_info hw_clocks;\n\tstruct pp_hwmgr *hwmgr = handle;\n\tint ret = 0;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tphm_get_dal_power_level(hwmgr, &simple_clocks);\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_PowerContainment))\n\t\tret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,\n\t\t\t\t\t&hw_clocks, PHM_PerformanceLevelDesignation_PowerContainment);\n\telse\n\t\tret = phm_get_clock_info(hwmgr, &hwmgr->current_ps->hardware,\n\t\t\t\t\t&hw_clocks, PHM_PerformanceLevelDesignation_Activity);\n\n\tif (ret) {\n\t\tpr_debug(\"Error in phm_get_clock_info \\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclocks->min_engine_clock = hw_clocks.min_eng_clk;\n\tclocks->max_engine_clock = hw_clocks.max_eng_clk;\n\tclocks->min_memory_clock = hw_clocks.min_mem_clk;\n\tclocks->max_memory_clock = hw_clocks.max_mem_clk;\n\tclocks->min_bus_bandwidth = hw_clocks.min_bus_bandwidth;\n\tclocks->max_bus_bandwidth = hw_clocks.max_bus_bandwidth;\n\n\tclocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;\n\tclocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;\n\n\tif (simple_clocks.level == 0)\n\t\tclocks->max_clocks_state = PP_DAL_POWERLEVEL_7;\n\telse\n\t\tclocks->max_clocks_state = simple_clocks.level;\n\n\tif (0 == phm_get_current_shallow_sleep_clocks(hwmgr, &hwmgr->current_ps->hardware, &hw_clocks)) {\n\t\tclocks->max_engine_clock_in_sr = hw_clocks.max_eng_clk;\n\t\tclocks->min_engine_clock_in_sr = hw_clocks.min_eng_clk;\n\t}\n\treturn 0;\n}\n\nstatic int pp_get_clock_by_type(void *handle, enum amd_pp_clock_type type, struct amd_pp_clocks *clocks)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (clocks == NULL)\n\t\treturn -EINVAL;\n\n\treturn phm_get_clock_by_type(hwmgr, type, clocks);\n}\n\nstatic int pp_get_clock_by_type_with_latency(void *handle,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_latency *clocks)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !clocks)\n\t\treturn -EINVAL;\n\n\treturn phm_get_clock_by_type_with_latency(hwmgr, type, clocks);\n}\n\nstatic int pp_get_clock_by_type_with_voltage(void *handle,\n\t\tenum amd_pp_clock_type type,\n\t\tstruct pp_clock_levels_with_voltage *clocks)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !clocks)\n\t\treturn -EINVAL;\n\n\treturn phm_get_clock_by_type_with_voltage(hwmgr, type, clocks);\n}\n\nstatic int pp_set_watermarks_for_clocks_ranges(void *handle,\n\t\tvoid *clock_ranges)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !clock_ranges)\n\t\treturn -EINVAL;\n\n\treturn phm_set_watermarks_for_clocks_ranges(hwmgr,\n\t\t\t\t\t\t    clock_ranges);\n}\n\nstatic int pp_display_clock_voltage_request(void *handle,\n\t\tstruct pp_display_clock_request *clock)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !clock)\n\t\treturn -EINVAL;\n\n\treturn phm_display_clock_voltage_request(hwmgr, clock);\n}\n\nstatic int pp_get_display_mode_validation_clocks(void *handle,\n\t\tstruct amd_pp_simple_clock_info *clocks)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tint ret = 0;\n\n\tif (!hwmgr || !hwmgr->pm_en || !clocks)\n\t\treturn -EINVAL;\n\n\tclocks->level = PP_DAL_POWERLEVEL_7;\n\n\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_DynamicPatchPowerState))\n\t\tret = phm_get_max_high_clocks(hwmgr, clocks);\n\n\treturn ret;\n}\n\nstatic int pp_dpm_powergate_mmhub(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->powergate_mmhub == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn hwmgr->hwmgr_func->powergate_mmhub(hwmgr);\n}\n\nstatic int pp_dpm_powergate_gfx(void *handle, bool gate)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn 0;\n\n\tif (hwmgr->hwmgr_func->powergate_gfx == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn hwmgr->hwmgr_func->powergate_gfx(hwmgr, gate);\n}\n\nstatic void pp_dpm_powergate_acp(void *handle, bool gate)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn;\n\n\tif (hwmgr->hwmgr_func->powergate_acp == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn;\n\t}\n\n\thwmgr->hwmgr_func->powergate_acp(hwmgr, gate);\n}\n\nstatic void pp_dpm_powergate_sdma(void *handle, bool gate)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn;\n\n\tif (hwmgr->hwmgr_func->powergate_sdma == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn;\n\t}\n\n\thwmgr->hwmgr_func->powergate_sdma(hwmgr, gate);\n}\n\nstatic int pp_set_powergating_by_smu(void *handle,\n\t\t\t\tuint32_t block_type, bool gate)\n{\n\tint ret = 0;\n\n\tswitch (block_type) {\n\tcase AMD_IP_BLOCK_TYPE_UVD:\n\tcase AMD_IP_BLOCK_TYPE_VCN:\n\t\tpp_dpm_powergate_uvd(handle, gate);\n\t\tbreak;\n\tcase AMD_IP_BLOCK_TYPE_VCE:\n\t\tpp_dpm_powergate_vce(handle, gate);\n\t\tbreak;\n\tcase AMD_IP_BLOCK_TYPE_GMC:\n\t\t \n\t\tif (gate)\n\t\t\tpp_dpm_powergate_mmhub(handle);\n\t\tbreak;\n\tcase AMD_IP_BLOCK_TYPE_GFX:\n\t\tret = pp_dpm_powergate_gfx(handle, gate);\n\t\tbreak;\n\tcase AMD_IP_BLOCK_TYPE_ACP:\n\t\tpp_dpm_powergate_acp(handle, gate);\n\t\tbreak;\n\tcase AMD_IP_BLOCK_TYPE_SDMA:\n\t\tpp_dpm_powergate_sdma(handle, gate);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int pp_notify_smu_enable_pwe(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->smus_notify_pwe == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thwmgr->hwmgr_func->smus_notify_pwe(hwmgr);\n\n\treturn 0;\n}\n\nstatic int pp_enable_mgpu_fan_boost(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->pm_en ||\n\t     hwmgr->hwmgr_func->enable_mgpu_fan_boost == NULL)\n\t\treturn 0;\n\n\thwmgr->hwmgr_func->enable_mgpu_fan_boost(hwmgr);\n\n\treturn 0;\n}\n\nstatic int pp_set_min_deep_sleep_dcefclk(void *handle, uint32_t clock)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_min_deep_sleep_dcefclk == NULL) {\n\t\tpr_debug(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thwmgr->hwmgr_func->set_min_deep_sleep_dcefclk(hwmgr, clock);\n\n\treturn 0;\n}\n\nstatic int pp_set_hard_min_dcefclk_by_freq(void *handle, uint32_t clock)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_hard_min_dcefclk_by_freq == NULL) {\n\t\tpr_debug(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thwmgr->hwmgr_func->set_hard_min_dcefclk_by_freq(hwmgr, clock);\n\n\treturn 0;\n}\n\nstatic int pp_set_hard_min_fclk_by_freq(void *handle, uint32_t clock)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_hard_min_fclk_by_freq == NULL) {\n\t\tpr_debug(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thwmgr->hwmgr_func->set_hard_min_fclk_by_freq(hwmgr, clock);\n\n\treturn 0;\n}\n\nstatic int pp_set_active_display_count(void *handle, uint32_t count)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\treturn phm_set_active_display_count(hwmgr, count);\n}\n\nstatic int pp_get_asic_baco_capability(void *handle, bool *cap)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\t*cap = false;\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!(hwmgr->not_vf && amdgpu_dpm) ||\n\t\t!hwmgr->hwmgr_func->get_asic_baco_capability)\n\t\treturn 0;\n\n\thwmgr->hwmgr_func->get_asic_baco_capability(hwmgr, cap);\n\n\treturn 0;\n}\n\nstatic int pp_get_asic_baco_state(void *handle, int *state)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_asic_baco_state)\n\t\treturn 0;\n\n\thwmgr->hwmgr_func->get_asic_baco_state(hwmgr, (enum BACO_STATE *)state);\n\n\treturn 0;\n}\n\nstatic int pp_set_asic_baco_state(void *handle, int state)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!(hwmgr->not_vf && amdgpu_dpm) ||\n\t\t!hwmgr->hwmgr_func->set_asic_baco_state)\n\t\treturn 0;\n\n\thwmgr->hwmgr_func->set_asic_baco_state(hwmgr, (enum BACO_STATE)state);\n\n\treturn 0;\n}\n\nstatic int pp_get_ppfeature_status(void *handle, char *buf)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en || !buf)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->get_ppfeature_status == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwmgr->hwmgr_func->get_ppfeature_status(hwmgr, buf);\n}\n\nstatic int pp_set_ppfeature_status(void *handle, uint64_t ppfeature_masks)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->set_ppfeature_status == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwmgr->hwmgr_func->set_ppfeature_status(hwmgr, ppfeature_masks);\n}\n\nstatic int pp_asic_reset_mode_2(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->asic_reset == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwmgr->hwmgr_func->asic_reset(hwmgr, SMU_ASIC_RESET_MODE_2);\n}\n\nstatic int pp_smu_i2c_bus_access(void *handle, bool acquire)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->smu_i2c_bus_access == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn hwmgr->hwmgr_func->smu_i2c_bus_access(hwmgr, acquire);\n}\n\nstatic int pp_set_df_cstate(void *handle, enum pp_df_cstate state)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->pm_en || !hwmgr->hwmgr_func->set_df_cstate)\n\t\treturn 0;\n\n\thwmgr->hwmgr_func->set_df_cstate(hwmgr, state);\n\n\treturn 0;\n}\n\nstatic int pp_set_xgmi_pstate(void *handle, uint32_t pstate)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->pm_en || !hwmgr->hwmgr_func->set_xgmi_pstate)\n\t\treturn 0;\n\n\thwmgr->hwmgr_func->set_xgmi_pstate(hwmgr, pstate);\n\n\treturn 0;\n}\n\nstatic ssize_t pp_get_gpu_metrics(void *handle, void **table)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr)\n\t\treturn -EINVAL;\n\n\tif (!hwmgr->pm_en || !hwmgr->hwmgr_func->get_gpu_metrics)\n\t\treturn -EOPNOTSUPP;\n\n\treturn hwmgr->hwmgr_func->get_gpu_metrics(hwmgr, table);\n}\n\nstatic int pp_gfx_state_change_set(void *handle, uint32_t state)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\n\tif (!hwmgr || !hwmgr->pm_en)\n\t\treturn -EINVAL;\n\n\tif (hwmgr->hwmgr_func->gfx_state_change == NULL) {\n\t\tpr_info_ratelimited(\"%s was not implemented.\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thwmgr->hwmgr_func->gfx_state_change(hwmgr, state);\n\treturn 0;\n}\n\nstatic int pp_get_prv_buffer_details(void *handle, void **addr, size_t *size)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint err;\n\n\tif (!addr || !size)\n\t\treturn -EINVAL;\n\n\t*addr = NULL;\n\t*size = 0;\n\tif (adev->pm.smu_prv_buffer) {\n\t\terr = amdgpu_bo_kmap(adev->pm.smu_prv_buffer, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*size = adev->pm.smu_prv_buffer_size;\n\t}\n\n\treturn 0;\n}\n\nstatic void pp_pm_compute_clocks(void *handle)\n{\n\tstruct pp_hwmgr *hwmgr = handle;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tif (!adev->dc_enabled) {\n\t\tamdgpu_dpm_get_active_displays(adev);\n\t\tadev->pm.pm_display_cfg.num_display = adev->pm.dpm.new_active_crtc_count;\n\t\tadev->pm.pm_display_cfg.vrefresh = amdgpu_dpm_get_vrefresh(adev);\n\t\tadev->pm.pm_display_cfg.min_vblank_time = amdgpu_dpm_get_vblank_time(adev);\n\t\t \n\t\tif (adev->pm.pm_display_cfg.vrefresh > 120)\n\t\t\tadev->pm.pm_display_cfg.min_vblank_time = 0;\n\n\t\tpp_display_configuration_change(handle,\n\t\t\t\t\t\t&adev->pm.pm_display_cfg);\n\t}\n\n\tpp_dpm_dispatch_tasks(handle,\n\t\t\t      AMD_PP_TASK_DISPLAY_CONFIG_CHANGE,\n\t\t\t      NULL);\n}\n\nstatic const struct amd_pm_funcs pp_dpm_funcs = {\n\t.load_firmware = pp_dpm_load_fw,\n\t.wait_for_fw_loading_complete = pp_dpm_fw_loading_complete,\n\t.force_performance_level = pp_dpm_force_performance_level,\n\t.get_performance_level = pp_dpm_get_performance_level,\n\t.get_current_power_state = pp_dpm_get_current_power_state,\n\t.dispatch_tasks = pp_dpm_dispatch_tasks,\n\t.set_fan_control_mode = pp_dpm_set_fan_control_mode,\n\t.get_fan_control_mode = pp_dpm_get_fan_control_mode,\n\t.set_fan_speed_pwm = pp_dpm_set_fan_speed_pwm,\n\t.get_fan_speed_pwm = pp_dpm_get_fan_speed_pwm,\n\t.get_fan_speed_rpm = pp_dpm_get_fan_speed_rpm,\n\t.set_fan_speed_rpm = pp_dpm_set_fan_speed_rpm,\n\t.get_pp_num_states = pp_dpm_get_pp_num_states,\n\t.get_pp_table = pp_dpm_get_pp_table,\n\t.set_pp_table = pp_dpm_set_pp_table,\n\t.force_clock_level = pp_dpm_force_clock_level,\n\t.emit_clock_levels = pp_dpm_emit_clock_levels,\n\t.print_clock_levels = pp_dpm_print_clock_levels,\n\t.get_sclk_od = pp_dpm_get_sclk_od,\n\t.set_sclk_od = pp_dpm_set_sclk_od,\n\t.get_mclk_od = pp_dpm_get_mclk_od,\n\t.set_mclk_od = pp_dpm_set_mclk_od,\n\t.read_sensor = pp_dpm_read_sensor,\n\t.get_vce_clock_state = pp_dpm_get_vce_clock_state,\n\t.switch_power_profile = pp_dpm_switch_power_profile,\n\t.set_clockgating_by_smu = pp_set_clockgating_by_smu,\n\t.set_powergating_by_smu = pp_set_powergating_by_smu,\n\t.get_power_profile_mode = pp_get_power_profile_mode,\n\t.set_power_profile_mode = pp_set_power_profile_mode,\n\t.set_fine_grain_clk_vol = pp_set_fine_grain_clk_vol,\n\t.odn_edit_dpm_table = pp_odn_edit_dpm_table,\n\t.set_mp1_state = pp_dpm_set_mp1_state,\n\t.set_power_limit = pp_set_power_limit,\n\t.get_power_limit = pp_get_power_limit,\n \n\t.get_sclk = pp_dpm_get_sclk,\n\t.get_mclk = pp_dpm_get_mclk,\n\t.display_configuration_change = pp_display_configuration_change,\n\t.get_display_power_level = pp_get_display_power_level,\n\t.get_current_clocks = pp_get_current_clocks,\n\t.get_clock_by_type = pp_get_clock_by_type,\n\t.get_clock_by_type_with_latency = pp_get_clock_by_type_with_latency,\n\t.get_clock_by_type_with_voltage = pp_get_clock_by_type_with_voltage,\n\t.set_watermarks_for_clocks_ranges = pp_set_watermarks_for_clocks_ranges,\n\t.display_clock_voltage_request = pp_display_clock_voltage_request,\n\t.get_display_mode_validation_clocks = pp_get_display_mode_validation_clocks,\n\t.notify_smu_enable_pwe = pp_notify_smu_enable_pwe,\n\t.enable_mgpu_fan_boost = pp_enable_mgpu_fan_boost,\n\t.set_active_display_count = pp_set_active_display_count,\n\t.set_min_deep_sleep_dcefclk = pp_set_min_deep_sleep_dcefclk,\n\t.set_hard_min_dcefclk_by_freq = pp_set_hard_min_dcefclk_by_freq,\n\t.set_hard_min_fclk_by_freq = pp_set_hard_min_fclk_by_freq,\n\t.get_asic_baco_capability = pp_get_asic_baco_capability,\n\t.get_asic_baco_state = pp_get_asic_baco_state,\n\t.set_asic_baco_state = pp_set_asic_baco_state,\n\t.get_ppfeature_status = pp_get_ppfeature_status,\n\t.set_ppfeature_status = pp_set_ppfeature_status,\n\t.asic_reset_mode_2 = pp_asic_reset_mode_2,\n\t.smu_i2c_bus_access = pp_smu_i2c_bus_access,\n\t.set_df_cstate = pp_set_df_cstate,\n\t.set_xgmi_pstate = pp_set_xgmi_pstate,\n\t.get_gpu_metrics = pp_get_gpu_metrics,\n\t.gfx_state_change_set = pp_gfx_state_change_set,\n\t.get_smu_prv_buf_details = pp_get_prv_buffer_details,\n\t.pm_compute_clocks = pp_pm_compute_clocks,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}