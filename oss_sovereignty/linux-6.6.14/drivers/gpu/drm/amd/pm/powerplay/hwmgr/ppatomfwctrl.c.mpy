{
  "module_name": "ppatomfwctrl.c",
  "hash_id": "55d15dee12240f77791d4f660843ba68be0467b409d11ac7ed665ba4fe6d2dee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/ppatomfwctrl.c",
  "human_readable_source": " \n\n#include \"ppatomfwctrl.h\"\n#include \"atomfirmware.h\"\n#include \"atom.h\"\n#include \"pp_debug.h\"\n\nstatic const union atom_voltage_object_v4 *pp_atomfwctrl_lookup_voltage_type_v4(\n\t\tconst struct atom_voltage_objects_info_v4_1 *voltage_object_info_table,\n\t\tuint8_t voltage_type, uint8_t voltage_mode)\n{\n\tunsigned int size = le16_to_cpu(\n\t\t\tvoltage_object_info_table->table_header.structuresize);\n\tunsigned int offset =\n\t\t\toffsetof(struct atom_voltage_objects_info_v4_1, voltage_object[0]);\n\tunsigned long start = (unsigned long)voltage_object_info_table;\n\n\twhile (offset < size) {\n\t\tconst union atom_voltage_object_v4 *voltage_object =\n\t\t\t(const union atom_voltage_object_v4 *)(start + offset);\n\n\t\tif (voltage_type == voltage_object->gpio_voltage_obj.header.voltage_type &&\n\t\t    voltage_mode == voltage_object->gpio_voltage_obj.header.voltage_mode)\n\t\t\treturn voltage_object;\n\n\t\toffset += le16_to_cpu(voltage_object->gpio_voltage_obj.header.object_size);\n\n\t}\n\n\treturn NULL;\n}\n\nstatic struct atom_voltage_objects_info_v4_1 *pp_atomfwctrl_get_voltage_info_table(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tconst void *table_address;\n\tuint16_t idx;\n\n\tidx = GetIndexIntoMasterDataTable(voltageobject_info);\n\ttable_address = smu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\t\tidx, NULL, NULL, NULL);\n\n\tPP_ASSERT_WITH_CODE(table_address,\n\t\t\t\"Error retrieving BIOS Table Address!\",\n\t\t\treturn NULL);\n\n\treturn (struct atom_voltage_objects_info_v4_1 *)table_address;\n}\n\n \nbool pp_atomfwctrl_is_voltage_controlled_by_gpio_v4(struct pp_hwmgr *hwmgr,\n\t\tuint8_t voltage_type, uint8_t voltage_mode)\n{\n\tstruct atom_voltage_objects_info_v4_1 *voltage_info =\n\t\t\t(struct atom_voltage_objects_info_v4_1 *)\n\t\t\tpp_atomfwctrl_get_voltage_info_table(hwmgr);\n\tbool ret;\n\n\t \n\tPP_ASSERT_WITH_CODE(voltage_info,\n\t\t\t\"Could not find Voltage Table in BIOS.\",\n\t\t\treturn false);\n\n\tret = (pp_atomfwctrl_lookup_voltage_type_v4(voltage_info,\n\t\t\tvoltage_type, voltage_mode)) ? true : false;\n\n\treturn ret;\n}\n\nint pp_atomfwctrl_get_voltage_table_v4(struct pp_hwmgr *hwmgr,\n\t\tuint8_t voltage_type, uint8_t voltage_mode,\n\t\tstruct pp_atomfwctrl_voltage_table *voltage_table)\n{\n\tstruct atom_voltage_objects_info_v4_1 *voltage_info =\n\t\t\t(struct atom_voltage_objects_info_v4_1 *)\n\t\t\tpp_atomfwctrl_get_voltage_info_table(hwmgr);\n\tconst union atom_voltage_object_v4 *voltage_object;\n\tunsigned int i;\n\tint result = 0;\n\n\tPP_ASSERT_WITH_CODE(voltage_info,\n\t\t\t\"Could not find Voltage Table in BIOS.\",\n\t\t\treturn -1);\n\n\tvoltage_object = pp_atomfwctrl_lookup_voltage_type_v4(voltage_info,\n\t\t\tvoltage_type, voltage_mode);\n\n\tif (!voltage_object)\n\t\treturn -1;\n\n\tvoltage_table->count = 0;\n\tif (voltage_mode == VOLTAGE_OBJ_GPIO_LUT) {\n\t\tPP_ASSERT_WITH_CODE(\n\t\t\t\t(voltage_object->gpio_voltage_obj.gpio_entry_num <=\n\t\t\t\tPP_ATOMFWCTRL_MAX_VOLTAGE_ENTRIES),\n\t\t\t\t\"Too many voltage entries!\",\n\t\t\t\tresult = -1);\n\n\t\tif (!result) {\n\t\t\tfor (i = 0; i < voltage_object->gpio_voltage_obj.\n\t\t\t\t\t\t\tgpio_entry_num; i++) {\n\t\t\t\tvoltage_table->entries[i].value =\n\t\t\t\t\t\tle16_to_cpu(voltage_object->gpio_voltage_obj.\n\t\t\t\t\t\tvoltage_gpio_lut[i].voltage_level_mv);\n\t\t\t\tvoltage_table->entries[i].smio_low =\n\t\t\t\t\t\tle32_to_cpu(voltage_object->gpio_voltage_obj.\n\t\t\t\t\t\tvoltage_gpio_lut[i].voltage_gpio_reg_val);\n\t\t\t}\n\t\t\tvoltage_table->count =\n\t\t\t\t\tvoltage_object->gpio_voltage_obj.gpio_entry_num;\n\t\t\tvoltage_table->mask_low =\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\tvoltage_object->gpio_voltage_obj.gpio_mask_val);\n\t\t\tvoltage_table->phase_delay =\n\t\t\t\t\tvoltage_object->gpio_voltage_obj.phase_delay_us;\n\t\t}\n\t} else if (voltage_mode == VOLTAGE_OBJ_SVID2) {\n\t\tvoltage_table->psi1_enable =\n\t\t\t(voltage_object->svid2_voltage_obj.loadline_psi1 & 0x20) >> 5;\n\t\tvoltage_table->psi0_enable =\n\t\t\tvoltage_object->svid2_voltage_obj.psi0_enable & 0x1;\n\t\tvoltage_table->max_vid_step =\n\t\t\tvoltage_object->svid2_voltage_obj.maxvstep;\n\t\tvoltage_table->telemetry_offset =\n\t\t\tvoltage_object->svid2_voltage_obj.telemetry_offset;\n\t\tvoltage_table->telemetry_slope =\n\t\t\tvoltage_object->svid2_voltage_obj.telemetry_gain;\n\t} else\n\t\tPP_ASSERT_WITH_CODE(false,\n\t\t\t\t\"Unsupported Voltage Object Mode!\",\n\t\t\t\tresult = -1);\n\n\treturn result;\n}\n\n \nstatic struct atom_gpio_pin_lut_v2_1 *pp_atomfwctrl_get_gpio_lookup_table(\n\t\tstruct pp_hwmgr *hwmgr)\n{\n\tconst void *table_address;\n\tuint16_t idx;\n\n\tidx = GetIndexIntoMasterDataTable(gpio_pin_lut);\n\ttable_address =\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\tidx, NULL, NULL, NULL);\n\tPP_ASSERT_WITH_CODE(table_address,\n\t\t\t\"Error retrieving BIOS Table Address!\",\n\t\t\treturn NULL);\n\n\treturn (struct atom_gpio_pin_lut_v2_1 *)table_address;\n}\n\nstatic bool pp_atomfwctrl_lookup_gpio_pin(\n\t\tstruct atom_gpio_pin_lut_v2_1 *gpio_lookup_table,\n\t\tconst uint32_t pin_id,\n\t\tstruct pp_atomfwctrl_gpio_pin_assignment *gpio_pin_assignment)\n{\n\tunsigned int size = le16_to_cpu(\n\t\t\tgpio_lookup_table->table_header.structuresize);\n\tunsigned int offset =\n\t\t\toffsetof(struct atom_gpio_pin_lut_v2_1, gpio_pin[0]);\n\tunsigned long start = (unsigned long)gpio_lookup_table;\n\n\twhile (offset < size) {\n\t\tconst struct  atom_gpio_pin_assignment *pin_assignment =\n\t\t\t\t(const struct  atom_gpio_pin_assignment *)(start + offset);\n\n\t\tif (pin_id == pin_assignment->gpio_id)  {\n\t\t\tgpio_pin_assignment->uc_gpio_pin_bit_shift =\n\t\t\t\t\tpin_assignment->gpio_bitshift;\n\t\t\tgpio_pin_assignment->us_gpio_pin_aindex =\n\t\t\t\t\tle16_to_cpu(pin_assignment->data_a_reg_index);\n\t\t\treturn true;\n\t\t}\n\t\toffset += offsetof(struct atom_gpio_pin_assignment, gpio_id) + 1;\n\t}\n\treturn false;\n}\n\n \nbool pp_atomfwctrl_get_pp_assign_pin(struct pp_hwmgr *hwmgr,\n\t\tconst uint32_t pin_id,\n\t\tstruct pp_atomfwctrl_gpio_pin_assignment *gpio_pin_assignment)\n{\n\tbool ret = false;\n\tstruct atom_gpio_pin_lut_v2_1 *gpio_lookup_table =\n\t\t\tpp_atomfwctrl_get_gpio_lookup_table(hwmgr);\n\n\t \n\tPP_ASSERT_WITH_CODE(gpio_lookup_table,\n\t\t\t\"Could not find GPIO lookup Table in BIOS.\",\n\t\t\treturn false);\n\n\tret = pp_atomfwctrl_lookup_gpio_pin(gpio_lookup_table,\n\t\t\tpin_id, gpio_pin_assignment);\n\n\treturn ret;\n}\n\n \nint pp_atomfwctrl_enter_self_refresh(struct pp_hwmgr *hwmgr)\n{\n\t \n\treturn 0;\n}\n\n \nint pp_atomfwctrl_get_gpu_pll_dividers_vega10(struct pp_hwmgr *hwmgr,\n\t\tuint32_t clock_type, uint32_t clock_value,\n\t\tstruct pp_atomfwctrl_clock_dividers_soc15 *dividers)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct compute_gpu_clock_input_parameter_v1_8 pll_parameters;\n\tstruct compute_gpu_clock_output_parameter_v1_8 *pll_output;\n\tuint32_t idx;\n\n\tpll_parameters.gpuclock_10khz = (uint32_t)clock_value;\n\tpll_parameters.gpu_clock_type = clock_type;\n\n\tidx = GetIndexIntoMasterCmdTable(computegpuclockparam);\n\n\tif (amdgpu_atom_execute_table(\n\t\tadev->mode_info.atom_context, idx, (uint32_t *)&pll_parameters))\n\t\treturn -EINVAL;\n\n\tpll_output = (struct compute_gpu_clock_output_parameter_v1_8 *)\n\t\t\t&pll_parameters;\n\tdividers->ulClock = le32_to_cpu(pll_output->gpuclock_10khz);\n\tdividers->ulDid = le32_to_cpu(pll_output->dfs_did);\n\tdividers->ulPll_fb_mult = le32_to_cpu(pll_output->pll_fb_mult);\n\tdividers->ulPll_ss_fbsmult = le32_to_cpu(pll_output->pll_ss_fbsmult);\n\tdividers->usPll_ss_slew_frac = le16_to_cpu(pll_output->pll_ss_slew_frac);\n\tdividers->ucPll_ss_enable = pll_output->pll_ss_enable;\n\n\treturn 0;\n}\n\nint pp_atomfwctrl_get_avfs_information(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_atomfwctrl_avfs_parameters *param)\n{\n\tuint16_t idx;\n\tuint8_t format_revision, content_revision;\n\n\tstruct atom_asic_profiling_info_v4_1 *profile;\n\tstruct atom_asic_profiling_info_v4_2 *profile_v4_2;\n\n\tidx = GetIndexIntoMasterDataTable(asic_profiling_info);\n\tprofile = (struct atom_asic_profiling_info_v4_1 *)\n\t\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tidx, NULL, NULL, NULL);\n\n\tif (!profile)\n\t\treturn -1;\n\n\tformat_revision = ((struct atom_common_table_header *)profile)->format_revision;\n\tcontent_revision = ((struct atom_common_table_header *)profile)->content_revision;\n\n\tif (format_revision == 4 && content_revision == 1) {\n\t\tparam->ulMaxVddc = le32_to_cpu(profile->maxvddc);\n\t\tparam->ulMinVddc = le32_to_cpu(profile->minvddc);\n\t\tparam->ulMeanNsigmaAcontant0 =\n\t\t\t\tle32_to_cpu(profile->avfs_meannsigma_acontant0);\n\t\tparam->ulMeanNsigmaAcontant1 =\n\t\t\t\tle32_to_cpu(profile->avfs_meannsigma_acontant1);\n\t\tparam->ulMeanNsigmaAcontant2 =\n\t\t\t\tle32_to_cpu(profile->avfs_meannsigma_acontant2);\n\t\tparam->usMeanNsigmaDcTolSigma =\n\t\t\t\tle16_to_cpu(profile->avfs_meannsigma_dc_tol_sigma);\n\t\tparam->usMeanNsigmaPlatformMean =\n\t\t\t\tle16_to_cpu(profile->avfs_meannsigma_platform_mean);\n\t\tparam->usMeanNsigmaPlatformSigma =\n\t\t\t\tle16_to_cpu(profile->avfs_meannsigma_platform_sigma);\n\t\tparam->ulGbVdroopTableCksoffA0 =\n\t\t\t\tle32_to_cpu(profile->gb_vdroop_table_cksoff_a0);\n\t\tparam->ulGbVdroopTableCksoffA1 =\n\t\t\t\tle32_to_cpu(profile->gb_vdroop_table_cksoff_a1);\n\t\tparam->ulGbVdroopTableCksoffA2 =\n\t\t\t\tle32_to_cpu(profile->gb_vdroop_table_cksoff_a2);\n\t\tparam->ulGbVdroopTableCksonA0 =\n\t\t\t\tle32_to_cpu(profile->gb_vdroop_table_ckson_a0);\n\t\tparam->ulGbVdroopTableCksonA1 =\n\t\t\t\tle32_to_cpu(profile->gb_vdroop_table_ckson_a1);\n\t\tparam->ulGbVdroopTableCksonA2 =\n\t\t\t\tle32_to_cpu(profile->gb_vdroop_table_ckson_a2);\n\t\tparam->ulGbFuseTableCksoffM1 =\n\t\t\t\tle32_to_cpu(profile->avfsgb_fuse_table_cksoff_m1);\n\t\tparam->ulGbFuseTableCksoffM2 =\n\t\t\t\tle32_to_cpu(profile->avfsgb_fuse_table_cksoff_m2);\n\t\tparam->ulGbFuseTableCksoffB =\n\t\t\t\tle32_to_cpu(profile->avfsgb_fuse_table_cksoff_b);\n\t\tparam->ulGbFuseTableCksonM1 =\n\t\t\t\tle32_to_cpu(profile->avfsgb_fuse_table_ckson_m1);\n\t\tparam->ulGbFuseTableCksonM2 =\n\t\t\t\tle32_to_cpu(profile->avfsgb_fuse_table_ckson_m2);\n\t\tparam->ulGbFuseTableCksonB =\n\t\t\t\tle32_to_cpu(profile->avfsgb_fuse_table_ckson_b);\n\n\t\tparam->ucEnableGbVdroopTableCkson =\n\t\t\t\tprofile->enable_gb_vdroop_table_ckson;\n\t\tparam->ucEnableGbFuseTableCkson =\n\t\t\t\tprofile->enable_gb_fuse_table_ckson;\n\t\tparam->usPsmAgeComfactor =\n\t\t\t\tle16_to_cpu(profile->psm_age_comfactor);\n\n\t\tparam->ulDispclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile->dispclk2gfxclk_a);\n\t\tparam->ulDispclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile->dispclk2gfxclk_b);\n\t\tparam->ulDispclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile->dispclk2gfxclk_c);\n\t\tparam->ulDcefclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile->dcefclk2gfxclk_a);\n\t\tparam->ulDcefclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile->dcefclk2gfxclk_b);\n\t\tparam->ulDcefclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile->dcefclk2gfxclk_c);\n\t\tparam->ulPixelclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile->pixclk2gfxclk_a);\n\t\tparam->ulPixelclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile->pixclk2gfxclk_b);\n\t\tparam->ulPixelclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile->pixclk2gfxclk_c);\n\t\tparam->ulPhyclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile->phyclk2gfxclk_a);\n\t\tparam->ulPhyclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile->phyclk2gfxclk_b);\n\t\tparam->ulPhyclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile->phyclk2gfxclk_c);\n\t\tparam->ulAcgGbVdroopTableA0           = 0;\n\t\tparam->ulAcgGbVdroopTableA1           = 0;\n\t\tparam->ulAcgGbVdroopTableA2           = 0;\n\t\tparam->ulAcgGbFuseTableM1             = 0;\n\t\tparam->ulAcgGbFuseTableM2             = 0;\n\t\tparam->ulAcgGbFuseTableB              = 0;\n\t\tparam->ucAcgEnableGbVdroopTable       = 0;\n\t\tparam->ucAcgEnableGbFuseTable         = 0;\n\t} else if (format_revision == 4 && content_revision == 2) {\n\t\tprofile_v4_2 = (struct atom_asic_profiling_info_v4_2 *)profile;\n\t\tparam->ulMaxVddc = le32_to_cpu(profile_v4_2->maxvddc);\n\t\tparam->ulMinVddc = le32_to_cpu(profile_v4_2->minvddc);\n\t\tparam->ulMeanNsigmaAcontant0 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfs_meannsigma_acontant0);\n\t\tparam->ulMeanNsigmaAcontant1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfs_meannsigma_acontant1);\n\t\tparam->ulMeanNsigmaAcontant2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfs_meannsigma_acontant2);\n\t\tparam->usMeanNsigmaDcTolSigma =\n\t\t\t\tle16_to_cpu(profile_v4_2->avfs_meannsigma_dc_tol_sigma);\n\t\tparam->usMeanNsigmaPlatformMean =\n\t\t\t\tle16_to_cpu(profile_v4_2->avfs_meannsigma_platform_mean);\n\t\tparam->usMeanNsigmaPlatformSigma =\n\t\t\t\tle16_to_cpu(profile_v4_2->avfs_meannsigma_platform_sigma);\n\t\tparam->ulGbVdroopTableCksoffA0 =\n\t\t\t\tle32_to_cpu(profile_v4_2->gb_vdroop_table_cksoff_a0);\n\t\tparam->ulGbVdroopTableCksoffA1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->gb_vdroop_table_cksoff_a1);\n\t\tparam->ulGbVdroopTableCksoffA2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->gb_vdroop_table_cksoff_a2);\n\t\tparam->ulGbVdroopTableCksonA0 =\n\t\t\t\tle32_to_cpu(profile_v4_2->gb_vdroop_table_ckson_a0);\n\t\tparam->ulGbVdroopTableCksonA1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->gb_vdroop_table_ckson_a1);\n\t\tparam->ulGbVdroopTableCksonA2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->gb_vdroop_table_ckson_a2);\n\t\tparam->ulGbFuseTableCksoffM1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfsgb_fuse_table_cksoff_m1);\n\t\tparam->ulGbFuseTableCksoffM2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfsgb_fuse_table_cksoff_m2);\n\t\tparam->ulGbFuseTableCksoffB =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfsgb_fuse_table_cksoff_b);\n\t\tparam->ulGbFuseTableCksonM1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfsgb_fuse_table_ckson_m1);\n\t\tparam->ulGbFuseTableCksonM2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfsgb_fuse_table_ckson_m2);\n\t\tparam->ulGbFuseTableCksonB =\n\t\t\t\tle32_to_cpu(profile_v4_2->avfsgb_fuse_table_ckson_b);\n\n\t\tparam->ucEnableGbVdroopTableCkson =\n\t\t\t\tprofile_v4_2->enable_gb_vdroop_table_ckson;\n\t\tparam->ucEnableGbFuseTableCkson =\n\t\t\t\tprofile_v4_2->enable_gb_fuse_table_ckson;\n\t\tparam->usPsmAgeComfactor =\n\t\t\t\tle16_to_cpu(profile_v4_2->psm_age_comfactor);\n\n\t\tparam->ulDispclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->dispclk2gfxclk_a);\n\t\tparam->ulDispclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->dispclk2gfxclk_b);\n\t\tparam->ulDispclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile_v4_2->dispclk2gfxclk_c);\n\t\tparam->ulDcefclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->dcefclk2gfxclk_a);\n\t\tparam->ulDcefclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->dcefclk2gfxclk_b);\n\t\tparam->ulDcefclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile_v4_2->dcefclk2gfxclk_c);\n\t\tparam->ulPixelclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile_v4_2->pixclk2gfxclk_a);\n\t\tparam->ulPixelclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->pixclk2gfxclk_b);\n\t\tparam->ulPixelclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile_v4_2->pixclk2gfxclk_c);\n\t\tparam->ulPhyclk2GfxclkM1 =\n\t\t\t\tle32_to_cpu(profile->phyclk2gfxclk_a);\n\t\tparam->ulPhyclk2GfxclkM2 =\n\t\t\t\tle32_to_cpu(profile_v4_2->phyclk2gfxclk_b);\n\t\tparam->ulPhyclk2GfxclkB =\n\t\t\t\tle32_to_cpu(profile_v4_2->phyclk2gfxclk_c);\n\t\tparam->ulAcgGbVdroopTableA0 = le32_to_cpu(profile_v4_2->acg_gb_vdroop_table_a0);\n\t\tparam->ulAcgGbVdroopTableA1 = le32_to_cpu(profile_v4_2->acg_gb_vdroop_table_a1);\n\t\tparam->ulAcgGbVdroopTableA2 = le32_to_cpu(profile_v4_2->acg_gb_vdroop_table_a2);\n\t\tparam->ulAcgGbFuseTableM1 = le32_to_cpu(profile_v4_2->acg_avfsgb_fuse_table_m1);\n\t\tparam->ulAcgGbFuseTableM2 = le32_to_cpu(profile_v4_2->acg_avfsgb_fuse_table_m2);\n\t\tparam->ulAcgGbFuseTableB = le32_to_cpu(profile_v4_2->acg_avfsgb_fuse_table_b);\n\t\tparam->ucAcgEnableGbVdroopTable = le32_to_cpu(profile_v4_2->enable_acg_gb_vdroop_table);\n\t\tparam->ucAcgEnableGbFuseTable = le32_to_cpu(profile_v4_2->enable_acg_gb_fuse_table);\n\t} else {\n\t\tpr_info(\"Invalid VBIOS AVFS ProfilingInfo Revision!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint pp_atomfwctrl_get_gpio_information(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_atomfwctrl_gpio_parameters *param)\n{\n\tstruct atom_smu_info_v3_1 *info;\n\tuint16_t idx;\n\n\tidx = GetIndexIntoMasterDataTable(smu_info);\n\tinfo = (struct atom_smu_info_v3_1 *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\tidx, NULL, NULL, NULL);\n\n\tif (!info) {\n\t\tpr_info(\"Error retrieving BIOS smu_info Table Address!\");\n\t\treturn -1;\n\t}\n\n\tparam->ucAcDcGpio       = info->ac_dc_gpio_bit;\n\tparam->ucAcDcPolarity   = info->ac_dc_polarity;\n\tparam->ucVR0HotGpio     = info->vr0hot_gpio_bit;\n\tparam->ucVR0HotPolarity = info->vr0hot_polarity;\n\tparam->ucVR1HotGpio     = info->vr1hot_gpio_bit;\n\tparam->ucVR1HotPolarity = info->vr1hot_polarity;\n\tparam->ucFwCtfGpio      = info->fw_ctf_gpio_bit;\n\tparam->ucFwCtfPolarity  = info->fw_ctf_polarity;\n\n\treturn 0;\n}\n\nint pp_atomfwctrl_get_clk_information_by_clkid(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t       uint8_t clk_id, uint8_t syspll_id,\n\t\t\t\t\t       uint32_t *frequency)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tstruct atom_get_smu_clock_info_parameters_v3_1   parameters;\n\tstruct atom_get_smu_clock_info_output_parameters_v3_1 *output;\n\tuint32_t ix;\n\n\tparameters.clk_id = clk_id;\n\tparameters.syspll_id = syspll_id;\n\tparameters.command = GET_SMU_CLOCK_INFO_V3_1_GET_CLOCK_FREQ;\n\tparameters.dfsdid = 0;\n\n\tix = GetIndexIntoMasterCmdTable(getsmuclockinfo);\n\n\tif (amdgpu_atom_execute_table(\n\t\tadev->mode_info.atom_context, ix, (uint32_t *)&parameters))\n\t\treturn -EINVAL;\n\n\toutput = (struct atom_get_smu_clock_info_output_parameters_v3_1 *)&parameters;\n\t*frequency = le32_to_cpu(output->atom_smu_outputclkfreq.smu_clock_freq_hz) / 10000;\n\n\treturn 0;\n}\n\nstatic void pp_atomfwctrl_copy_vbios_bootup_values_3_2(struct pp_hwmgr *hwmgr,\n\t\t\tstruct pp_atomfwctrl_bios_boot_up_values *boot_values,\n\t\t\tstruct atom_firmware_info_v3_2 *fw_info)\n{\n\tuint32_t frequency = 0;\n\n\tboot_values->ulRevision = fw_info->firmware_revision;\n\tboot_values->ulGfxClk   = fw_info->bootup_sclk_in10khz;\n\tboot_values->ulUClk     = fw_info->bootup_mclk_in10khz;\n\tboot_values->usVddc     = fw_info->bootup_vddc_mv;\n\tboot_values->usVddci    = fw_info->bootup_vddci_mv;\n\tboot_values->usMvddc    = fw_info->bootup_mvddc_mv;\n\tboot_values->usVddGfx   = fw_info->bootup_vddgfx_mv;\n\tboot_values->ucCoolingID = fw_info->coolingsolution_id;\n\tboot_values->ulSocClk   = 0;\n\tboot_values->ulDCEFClk   = 0;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU11_SYSPLL0_SOCCLK_ID, SMU11_SYSPLL0_ID, &frequency))\n\t\tboot_values->ulSocClk   = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU11_SYSPLL0_DCEFCLK_ID, SMU11_SYSPLL0_ID, &frequency))\n\t\tboot_values->ulDCEFClk  = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU11_SYSPLL0_ECLK_ID, SMU11_SYSPLL0_ID, &frequency))\n\t\tboot_values->ulEClk     = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU11_SYSPLL0_VCLK_ID, SMU11_SYSPLL0_ID, &frequency))\n\t\tboot_values->ulVClk     = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU11_SYSPLL0_DCLK_ID, SMU11_SYSPLL0_ID, &frequency))\n\t\tboot_values->ulDClk     = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU11_SYSPLL1_0_FCLK_ID, SMU11_SYSPLL1_2_ID, &frequency))\n\t\tboot_values->ulFClk     = frequency;\n}\n\nstatic void pp_atomfwctrl_copy_vbios_bootup_values_3_1(struct pp_hwmgr *hwmgr,\n\t\t\tstruct pp_atomfwctrl_bios_boot_up_values *boot_values,\n\t\t\tstruct atom_firmware_info_v3_1 *fw_info)\n{\n\tuint32_t frequency = 0;\n\n\tboot_values->ulRevision = fw_info->firmware_revision;\n\tboot_values->ulGfxClk   = fw_info->bootup_sclk_in10khz;\n\tboot_values->ulUClk     = fw_info->bootup_mclk_in10khz;\n\tboot_values->usVddc     = fw_info->bootup_vddc_mv;\n\tboot_values->usVddci    = fw_info->bootup_vddci_mv;\n\tboot_values->usMvddc    = fw_info->bootup_mvddc_mv;\n\tboot_values->usVddGfx   = fw_info->bootup_vddgfx_mv;\n\tboot_values->ucCoolingID = fw_info->coolingsolution_id;\n\tboot_values->ulSocClk   = 0;\n\tboot_values->ulDCEFClk   = 0;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU9_SYSPLL0_SOCCLK_ID, 0, &frequency))\n\t\tboot_values->ulSocClk   = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU9_SYSPLL0_DCEFCLK_ID, 0, &frequency))\n\t\tboot_values->ulDCEFClk  = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU9_SYSPLL0_ECLK_ID, 0, &frequency))\n\t\tboot_values->ulEClk     = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU9_SYSPLL0_VCLK_ID, 0, &frequency))\n\t\tboot_values->ulVClk     = frequency;\n\n\tif (!pp_atomfwctrl_get_clk_information_by_clkid(hwmgr, SMU9_SYSPLL0_DCLK_ID, 0, &frequency))\n\t\tboot_values->ulDClk     = frequency;\n}\n\nint pp_atomfwctrl_get_vbios_bootup_values(struct pp_hwmgr *hwmgr,\n\t\t\tstruct pp_atomfwctrl_bios_boot_up_values *boot_values)\n{\n\tstruct atom_firmware_info_v3_2 *fwinfo_3_2;\n\tstruct atom_firmware_info_v3_1 *fwinfo_3_1;\n\tstruct atom_common_table_header *info = NULL;\n\tuint16_t ix;\n\n\tix = GetIndexIntoMasterDataTable(firmwareinfo);\n\tinfo = (struct atom_common_table_header *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\tix, NULL, NULL, NULL);\n\n\tif (!info) {\n\t\tpr_info(\"Error retrieving BIOS firmwareinfo!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((info->format_revision == 3) && (info->content_revision == 2)) {\n\t\tfwinfo_3_2 = (struct atom_firmware_info_v3_2 *)info;\n\t\tpp_atomfwctrl_copy_vbios_bootup_values_3_2(hwmgr,\n\t\t\t\tboot_values, fwinfo_3_2);\n\t} else if ((info->format_revision == 3) && (info->content_revision == 1)) {\n\t\tfwinfo_3_1 = (struct atom_firmware_info_v3_1 *)info;\n\t\tpp_atomfwctrl_copy_vbios_bootup_values_3_1(hwmgr,\n\t\t\t\tboot_values, fwinfo_3_1);\n\t} else {\n\t\tpr_info(\"Fw info table revision does not match!\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint pp_atomfwctrl_get_smc_dpm_information(struct pp_hwmgr *hwmgr,\n\t\tstruct pp_atomfwctrl_smc_dpm_parameters *param)\n{\n\tstruct atom_smc_dpm_info_v4_1 *info;\n\tuint16_t ix;\n\n\tix = GetIndexIntoMasterDataTable(smc_dpm_info);\n\tinfo = (struct atom_smc_dpm_info_v4_1 *)\n\t\tsmu_atom_get_data_table(hwmgr->adev,\n\t\t\t\tix, NULL, NULL, NULL);\n\tif (!info) {\n\t\tpr_info(\"Error retrieving BIOS Table Address!\");\n\t\treturn -EINVAL;\n\t}\n\n\tparam->liquid1_i2c_address = info->liquid1_i2c_address;\n\tparam->liquid2_i2c_address = info->liquid2_i2c_address;\n\tparam->vr_i2c_address = info->vr_i2c_address;\n\tparam->plx_i2c_address = info->plx_i2c_address;\n\n\tparam->liquid_i2c_linescl = info->liquid_i2c_linescl;\n\tparam->liquid_i2c_linesda = info->liquid_i2c_linesda;\n\tparam->vr_i2c_linescl = info->vr_i2c_linescl;\n\tparam->vr_i2c_linesda = info->vr_i2c_linesda;\n\n\tparam->plx_i2c_linescl = info->plx_i2c_linescl;\n\tparam->plx_i2c_linesda = info->plx_i2c_linesda;\n\tparam->vrsensorpresent = info->vrsensorpresent;\n\tparam->liquidsensorpresent = info->liquidsensorpresent;\n\n\tparam->maxvoltagestepgfx = info->maxvoltagestepgfx;\n\tparam->maxvoltagestepsoc = info->maxvoltagestepsoc;\n\n\tparam->vddgfxvrmapping = info->vddgfxvrmapping;\n\tparam->vddsocvrmapping = info->vddsocvrmapping;\n\tparam->vddmem0vrmapping = info->vddmem0vrmapping;\n\tparam->vddmem1vrmapping = info->vddmem1vrmapping;\n\n\tparam->gfxulvphasesheddingmask = info->gfxulvphasesheddingmask;\n\tparam->soculvphasesheddingmask = info->soculvphasesheddingmask;\n\n\tparam->gfxmaxcurrent = info->gfxmaxcurrent;\n\tparam->gfxoffset = info->gfxoffset;\n\tparam->padding_telemetrygfx = info->padding_telemetrygfx;\n\n\tparam->socmaxcurrent = info->socmaxcurrent;\n\tparam->socoffset = info->socoffset;\n\tparam->padding_telemetrysoc = info->padding_telemetrysoc;\n\n\tparam->mem0maxcurrent = info->mem0maxcurrent;\n\tparam->mem0offset = info->mem0offset;\n\tparam->padding_telemetrymem0 = info->padding_telemetrymem0;\n\n\tparam->mem1maxcurrent = info->mem1maxcurrent;\n\tparam->mem1offset = info->mem1offset;\n\tparam->padding_telemetrymem1 = info->padding_telemetrymem1;\n\n\tparam->acdcgpio = info->acdcgpio;\n\tparam->acdcpolarity = info->acdcpolarity;\n\tparam->vr0hotgpio = info->vr0hotgpio;\n\tparam->vr0hotpolarity = info->vr0hotpolarity;\n\n\tparam->vr1hotgpio = info->vr1hotgpio;\n\tparam->vr1hotpolarity = info->vr1hotpolarity;\n\tparam->padding1 = info->padding1;\n\tparam->padding2 = info->padding2;\n\n\tparam->ledpin0 = info->ledpin0;\n\tparam->ledpin1 = info->ledpin1;\n\tparam->ledpin2 = info->ledpin2;\n\n\tparam->pllgfxclkspreadenabled = info->pllgfxclkspreadenabled;\n\tparam->pllgfxclkspreadpercent = info->pllgfxclkspreadpercent;\n\tparam->pllgfxclkspreadfreq = info->pllgfxclkspreadfreq;\n\n\tparam->uclkspreadenabled = info->uclkspreadenabled;\n\tparam->uclkspreadpercent = info->uclkspreadpercent;\n\tparam->uclkspreadfreq = info->uclkspreadfreq;\n\n\tparam->socclkspreadenabled = info->socclkspreadenabled;\n\tparam->socclkspreadpercent = info->socclkspreadpercent;\n\tparam->socclkspreadfreq = info->socclkspreadfreq;\n\n\tparam->acggfxclkspreadenabled = info->acggfxclkspreadenabled;\n\tparam->acggfxclkspreadpercent = info->acggfxclkspreadpercent;\n\tparam->acggfxclkspreadfreq = info->acggfxclkspreadfreq;\n\n\tparam->Vr2_I2C_address = info->Vr2_I2C_address;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}