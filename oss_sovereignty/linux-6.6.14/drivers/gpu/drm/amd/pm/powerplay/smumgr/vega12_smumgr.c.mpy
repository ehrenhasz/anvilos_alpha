{
  "module_name": "vega12_smumgr.c",
  "hash_id": "7f8ea5e24d950a728c036774dab1e1ecf3b080b40294ba9f0bd4eba6f4421a77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/vega12_smumgr.c",
  "human_readable_source": " \n\n#include \"smumgr.h\"\n#include \"vega12_inc.h\"\n#include \"soc15_common.h\"\n#include \"smu9_smumgr.h\"\n#include \"vega12_smumgr.h\"\n#include \"vega12_ppsmc.h\"\n#include \"vega12/smu9_driver_if.h\"\n#include \"ppatomctrl.h\"\n#include \"pp_debug.h\"\n\n\n \nstatic int vega12_copy_table_from_smc(struct pp_hwmgr *hwmgr,\n\t\t\t\t      uint8_t *table, int16_t table_id)\n{\n\tstruct vega12_smumgr *priv =\n\t\t\t(struct vega12_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tPP_ASSERT_WITH_CODE(table_id < TABLE_COUNT,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL) == 0,\n\t\t\t\"[CopyTableFromSMC] Attempt to Set Dram Addr High Failed!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL) == 0,\n\t\t\t\"[CopyTableFromSMC] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn -EINVAL);\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableSmu2Dram,\n\t\t\ttable_id,\n\t\t\tNULL) == 0,\n\t\t\t\"[CopyTableFromSMC] Attempt to Transfer Table From SMU Failed!\",\n\t\t\treturn -EINVAL);\n\n\tamdgpu_asic_invalidate_hdp(adev, NULL);\n\n\tmemcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\treturn 0;\n}\n\n \nstatic int vega12_copy_table_to_smc(struct pp_hwmgr *hwmgr,\n\t\t\t\t    uint8_t *table, int16_t table_id)\n{\n\tstruct vega12_smumgr *priv =\n\t\t\t(struct vega12_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tPP_ASSERT_WITH_CODE(table_id < TABLE_COUNT,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL);\n\n\tmemcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\tamdgpu_asic_flush_hdp(adev, NULL);\n\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL) == 0,\n\t\t\t\"[CopyTableToSMC] Attempt to Set Dram Addr High Failed!\",\n\t\t\treturn -EINVAL;);\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL) == 0,\n\t\t\t\"[CopyTableToSMC] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn -EINVAL);\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableDram2Smu,\n\t\t\ttable_id,\n\t\t\tNULL) == 0,\n\t\t\t\"[CopyTableToSMC] Attempt to Transfer Table To SMU Failed!\",\n\t\t\treturn -EINVAL);\n\n\treturn 0;\n}\n\nint vega12_enable_smc_features(struct pp_hwmgr *hwmgr,\n\t\tbool enable, uint64_t feature_mask)\n{\n\tuint32_t smu_features_low, smu_features_high;\n\n\tsmu_features_low = (uint32_t)((feature_mask & SMU_FEATURES_LOW_MASK) >> SMU_FEATURES_LOW_SHIFT);\n\tsmu_features_high = (uint32_t)((feature_mask & SMU_FEATURES_HIGH_MASK) >> SMU_FEATURES_HIGH_SHIFT);\n\n\tif (enable) {\n\t\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_EnableSmuFeaturesLow, smu_features_low, NULL) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to enable SMU features Low failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_EnableSmuFeaturesHigh, smu_features_high, NULL) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to enable SMU features High failed!\",\n\t\t\t\treturn -EINVAL);\n\t} else {\n\t\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_DisableSmuFeaturesLow, smu_features_low, NULL) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to disable SMU features Low failed!\",\n\t\t\t\treturn -EINVAL);\n\t\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_DisableSmuFeaturesHigh, smu_features_high, NULL) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to disable SMU features High failed!\",\n\t\t\t\treturn -EINVAL);\n\t}\n\n\treturn 0;\n}\n\nint vega12_get_enabled_smc_features(struct pp_hwmgr *hwmgr,\n\t\tuint64_t *features_enabled)\n{\n\tuint32_t smc_features_low, smc_features_high;\n\n\tif (features_enabled == NULL)\n\t\treturn -EINVAL;\n\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetEnabledSmuFeaturesLow,\n\t\t\t&smc_features_low) == 0,\n\t\t\t\"[GetEnabledSMCFeatures] Attempt to get SMU features Low failed!\",\n\t\t\treturn -EINVAL);\n\n\tPP_ASSERT_WITH_CODE(smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetEnabledSmuFeaturesHigh,\n\t\t\t&smc_features_high) == 0,\n\t\t\t\"[GetEnabledSMCFeatures] Attempt to get SMU features High failed!\",\n\t\t\treturn -EINVAL);\n\n\t*features_enabled = ((((uint64_t)smc_features_low << SMU_FEATURES_LOW_SHIFT) & SMU_FEATURES_LOW_MASK) |\n\t\t\t(((uint64_t)smc_features_high << SMU_FEATURES_HIGH_SHIFT) & SMU_FEATURES_HIGH_MASK));\n\n\treturn 0;\n}\n\nstatic bool vega12_is_dpm_running(struct pp_hwmgr *hwmgr)\n{\n\tuint64_t features_enabled = 0;\n\n\tvega12_get_enabled_smc_features(hwmgr, &features_enabled);\n\n\tif (features_enabled & SMC_DPM_FEATURES)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int vega12_set_tools_address(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega12_smumgr *priv =\n\t\t\t(struct vega12_smumgr *)(hwmgr->smu_backend);\n\n\tif (priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr) {\n\t\tif (!smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetToolsDramAddrHigh,\n\t\t\t\tupper_32_bits(priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr),\n\t\t\t\tNULL))\n\t\t\tsmum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetToolsDramAddrLow,\n\t\t\t\t\tlower_32_bits(priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr),\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}\n\nstatic int vega12_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega12_smumgr *priv;\n\tunsigned long tools_size;\n\tstruct cgs_firmware_info info = {0};\n\tint ret;\n\n\tret = cgs_get_firmware_info(hwmgr->device, CGS_UCODE_ID_SMU,\n\t\t\t\t&info);\n\tif (ret || !info.kptr)\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(struct vega12_smumgr), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = priv;\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(PPTable_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].table);\n\tif (ret)\n\t\tgoto free_backend;\n\n\tpriv->smu_tables.entry[TABLE_PPTABLE].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_PPTABLE].size = sizeof(PPTable_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\t      sizeof(Watermarks_t),\n\t\t\t\t      PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_WATERMARKS].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_WATERMARKS].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_WATERMARKS].table);\n\n\tif (ret)\n\t\tgoto err0;\n\n\tpriv->smu_tables.entry[TABLE_WATERMARKS].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_WATERMARKS].size = sizeof(Watermarks_t);\n\n\ttools_size = 0x19000;\n\tif (tools_size) {\n\t\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\t\t      tools_size,\n\t\t\t\t\t      PAGE_SIZE,\n\t\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t\t      &priv->smu_tables.entry[TABLE_PMSTATUSLOG].handle,\n\t\t\t\t\t      &priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr,\n\t\t\t\t\t      &priv->smu_tables.entry[TABLE_PMSTATUSLOG].table);\n\t\tif (ret)\n\t\t\tgoto err1;\n\n\t\tpriv->smu_tables.entry[TABLE_PMSTATUSLOG].version = 0x01;\n\t\tpriv->smu_tables.entry[TABLE_PMSTATUSLOG].size = tools_size;\n\t}\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\t      sizeof(AvfsFuseOverride_t),\n\t\t\t\t      PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].table);\n\n\tif (ret)\n\t\tgoto err2;\n\n\tpriv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].size = sizeof(AvfsFuseOverride_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\t      sizeof(OverDriveTable_t),\n\t\t\t\t      PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_OVERDRIVE].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_OVERDRIVE].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_OVERDRIVE].table);\n\tif (ret)\n\t\tgoto err3;\n\n\tpriv->smu_tables.entry[TABLE_OVERDRIVE].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_OVERDRIVE].size = sizeof(OverDriveTable_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\t\t      sizeof(SmuMetrics_t),\n\t\t\t\t      PAGE_SIZE,\n\t\t\t\t      AMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_SMU_METRICS].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_SMU_METRICS].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_SMU_METRICS].table);\n\tif (ret)\n\t\tgoto err4;\n\n\tpriv->smu_tables.entry[TABLE_SMU_METRICS].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_SMU_METRICS].size = sizeof(SmuMetrics_t);\n\n\treturn 0;\n\nerr4:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_OVERDRIVE].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].table);\nerr3:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].table);\nerr2:\n\tif (priv->smu_tables.entry[TABLE_PMSTATUSLOG].table)\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PMSTATUSLOG].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].table);\nerr1:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_WATERMARKS].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].table);\nerr0:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PPTABLE].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].table);\nfree_backend:\n\tkfree(hwmgr->smu_backend);\n\n\treturn -EINVAL;\n}\n\nstatic int vega12_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega12_smumgr *priv =\n\t\t\t(struct vega12_smumgr *)(hwmgr->smu_backend);\n\n\tif (priv) {\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PPTABLE].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_PPTABLE].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_PPTABLE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_WATERMARKS].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_WATERMARKS].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_WATERMARKS].table);\n\t\tif (priv->smu_tables.entry[TABLE_PMSTATUSLOG].table)\n\t\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PMSTATUSLOG].handle,\n\t\t\t\t\t      &priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr,\n\t\t\t\t\t      &priv->smu_tables.entry[TABLE_PMSTATUSLOG].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_AVFS_FUSE_OVERRIDE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_OVERDRIVE].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_OVERDRIVE].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_OVERDRIVE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_SMU_METRICS].handle,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_SMU_METRICS].mc_addr,\n\t\t\t\t      &priv->smu_tables.entry[TABLE_SMU_METRICS].table);\n\t\tkfree(hwmgr->smu_backend);\n\t\thwmgr->smu_backend = NULL;\n\t}\n\treturn 0;\n}\n\nstatic int vega12_start_smu(struct pp_hwmgr *hwmgr)\n{\n\tPP_ASSERT_WITH_CODE(smu9_is_smc_ram_running(hwmgr),\n\t\t\t\"SMC is not running!\",\n\t\t\treturn -EINVAL);\n\n\tvega12_set_tools_address(hwmgr);\n\n\treturn 0;\n}\n\nstatic int vega12_smc_table_manager(struct pp_hwmgr *hwmgr, uint8_t *table,\n\t\t\t\t    uint16_t table_id, bool rw)\n{\n\tint ret;\n\n\tif (rw)\n\t\tret = vega12_copy_table_from_smc(hwmgr, table, table_id);\n\telse\n\t\tret = vega12_copy_table_to_smc(hwmgr, table, table_id);\n\n\treturn ret;\n}\n\nconst struct pp_smumgr_func vega12_smu_funcs = {\n\t.name = \"vega12_smu\",\n\t.smu_init = &vega12_smu_init,\n\t.smu_fini = &vega12_smu_fini,\n\t.start_smu = &vega12_start_smu,\n\t.request_smu_load_specific_fw = NULL,\n\t.send_msg_to_smc = &smu9_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = &smu9_send_msg_to_smc_with_parameter,\n\t.download_pptable_settings = NULL,\n\t.upload_pptable_settings = NULL,\n\t.is_dpm_running = vega12_is_dpm_running,\n\t.get_argument = smu9_get_argument,\n\t.smc_table_manager = vega12_smc_table_manager,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}