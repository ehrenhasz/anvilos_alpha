{
  "module_name": "vega20_smumgr.c",
  "hash_id": "94cd164224059eae5029c453c431276f96a5df27c231ab2a0317bda2ecae0805",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/smumgr/vega20_smumgr.c",
  "human_readable_source": " \n\n#include \"smumgr.h\"\n#include \"vega20_inc.h\"\n#include \"soc15_common.h\"\n#include \"vega20_smumgr.h\"\n#include \"vega20_ppsmc.h\"\n#include \"smu11_driver_if.h\"\n#include \"ppatomctrl.h\"\n#include \"pp_debug.h\"\n#include \"smu_ucode_xfer_vi.h\"\n#include \"smu7_smumgr.h\"\n#include \"vega20_hwmgr.h\"\n\n#include \"smu_v11_0_i2c.h\"\n\n \n#define MP0_Public\t\t\t0x03800000\n#define MP0_SRAM\t\t\t0x03900000\n#define MP1_Public\t\t\t0x03b00000\n#define MP1_SRAM\t\t\t0x03c00004\n\n \n#define smnMP1_FIRMWARE_FLAGS\t\t0x3010024\n#define smnMP0_FW_INTF\t\t\t0x30101c0\n#define smnMP1_PUB_CTRL\t\t\t0x3010b14\n\nbool vega20_is_smc_ram_running(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t mp1_fw_flags;\n\n\tmp1_fw_flags = RREG32_PCIE(MP1_Public |\n\t\t\t\t   (smnMP1_FIRMWARE_FLAGS & 0xffffffff));\n\n\tif ((mp1_fw_flags & MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED_MASK) >>\n\t    MP1_FIRMWARE_FLAGS__INTERRUPTS_ENABLED__SHIFT)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic uint32_t vega20_wait_for_response(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tuint32_t reg;\n\n\treg = SOC15_REG_OFFSET(MP1, 0, mmMP1_SMN_C2PMSG_90);\n\n\tphm_wait_for_register_unequal(hwmgr, reg,\n\t\t\t0, MP1_C2PMSG_90__CONTENT_MASK);\n\n\treturn RREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_90);\n}\n\n \nstatic int vega20_send_msg_to_smc_without_waiting(struct pp_hwmgr *hwmgr,\n\t\tuint16_t msg)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_66, msg);\n\n\treturn 0;\n}\n\n \nstatic int vega20_send_msg_to_smc(struct pp_hwmgr *hwmgr, uint16_t msg)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret = 0;\n\n\tvega20_wait_for_response(hwmgr);\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_90, 0);\n\n\tvega20_send_msg_to_smc_without_waiting(hwmgr, msg);\n\n\tret = vega20_wait_for_response(hwmgr);\n\tif (ret != PPSMC_Result_OK)\n\t\tdev_err(adev->dev, \"Failed to send message 0x%x, response 0x%x\\n\", msg, ret);\n\n\treturn (ret == PPSMC_Result_OK) ? 0 : -EIO;\n}\n\n \nstatic int vega20_send_msg_to_smc_with_parameter(struct pp_hwmgr *hwmgr,\n\t\tuint16_t msg, uint32_t parameter)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret = 0;\n\n\tvega20_wait_for_response(hwmgr);\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_90, 0);\n\n\tWREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_82, parameter);\n\n\tvega20_send_msg_to_smc_without_waiting(hwmgr, msg);\n\n\tret = vega20_wait_for_response(hwmgr);\n\tif (ret != PPSMC_Result_OK)\n\t\tdev_err(adev->dev, \"Failed to send message 0x%x, response 0x%x\\n\", msg, ret);\n\n\treturn (ret == PPSMC_Result_OK) ? 0 : -EIO;\n}\n\nstatic uint32_t vega20_get_argument(struct pp_hwmgr *hwmgr)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\treturn RREG32_SOC15(MP1, 0, mmMP1_SMN_C2PMSG_82);\n}\n\n \nstatic int vega20_copy_table_from_smc(struct pp_hwmgr *hwmgr,\n\t\t\t\t      uint8_t *table, int16_t table_id)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE(table_id < TABLE_COUNT,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL);\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[CopyTableFromSMC] Attempt to Set Dram Addr High Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[CopyTableFromSMC] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableSmu2Dram, table_id, NULL)) == 0,\n\t\t\t\"[CopyTableFromSMC] Attempt to Transfer Table From SMU Failed!\",\n\t\t\treturn ret);\n\n\tamdgpu_asic_invalidate_hdp(adev, NULL);\n\n\tmemcpy(table, priv->smu_tables.entry[table_id].table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\treturn 0;\n}\n\n \nstatic int vega20_copy_table_to_smc(struct pp_hwmgr *hwmgr,\n\t\t\t\t    uint8_t *table, int16_t table_id)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE(table_id < TABLE_COUNT,\n\t\t\t\"Invalid SMU Table ID!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].version != 0,\n\t\t\t\"Invalid SMU Table version!\", return -EINVAL);\n\tPP_ASSERT_WITH_CODE(priv->smu_tables.entry[table_id].size != 0,\n\t\t\t\"Invalid SMU Table Length!\", return -EINVAL);\n\n\tmemcpy(priv->smu_tables.entry[table_id].table, table,\n\t\t\tpriv->smu_tables.entry[table_id].size);\n\n\tamdgpu_asic_flush_hdp(adev, NULL);\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[CopyTableToSMC] Attempt to Set Dram Addr High Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[table_id].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[CopyTableToSMC] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableDram2Smu, table_id, NULL)) == 0,\n\t\t\t\"[CopyTableToSMC] Attempt to Transfer Table To SMU Failed!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nint vega20_set_activity_monitor_coeff(struct pp_hwmgr *hwmgr,\n\t\tuint8_t *table, uint16_t workload_type)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret = 0;\n\n\tmemcpy(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table, table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size);\n\n\tamdgpu_asic_flush_hdp(adev, NULL);\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[SetActivityMonitor] Attempt to Set Dram Addr High Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[SetActivityMonitor] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableDram2Smu,\n\t\t\tTABLE_ACTIVITY_MONITOR_COEFF | (workload_type << 16),\n\t\t\tNULL)) == 0,\n\t\t\t\"[SetActivityMonitor] Attempt to Transfer Table To SMU Failed!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nint vega20_get_activity_monitor_coeff(struct pp_hwmgr *hwmgr,\n\t\tuint8_t *table, uint16_t workload_type)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[GetActivityMonitor] Attempt to Set Dram Addr High Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[GetActivityMonitor] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_TransferTableSmu2Dram,\n\t\t\tTABLE_ACTIVITY_MONITOR_COEFF | (workload_type << 16), NULL)) == 0,\n\t\t\t\"[GetActivityMonitor] Attempt to Transfer Table From SMU Failed!\",\n\t\t\treturn ret);\n\n\tamdgpu_asic_invalidate_hdp(adev, NULL);\n\n\tmemcpy(table, priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table,\n\t\t\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size);\n\n\treturn 0;\n}\n\nint vega20_enable_smc_features(struct pp_hwmgr *hwmgr,\n\t\tbool enable, uint64_t feature_mask)\n{\n\tuint32_t smu_features_low, smu_features_high;\n\tint ret = 0;\n\n\tsmu_features_low = (uint32_t)((feature_mask & SMU_FEATURES_LOW_MASK) >> SMU_FEATURES_LOW_SHIFT);\n\tsmu_features_high = (uint32_t)((feature_mask & SMU_FEATURES_HIGH_MASK) >> SMU_FEATURES_HIGH_SHIFT);\n\n\tif (enable) {\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_EnableSmuFeaturesLow, smu_features_low, NULL)) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to enable SMU features Low failed!\",\n\t\t\t\treturn ret);\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_EnableSmuFeaturesHigh, smu_features_high, NULL)) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to enable SMU features High failed!\",\n\t\t\t\treturn ret);\n\t} else {\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_DisableSmuFeaturesLow, smu_features_low, NULL)) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to disable SMU features Low failed!\",\n\t\t\t\treturn ret);\n\t\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_DisableSmuFeaturesHigh, smu_features_high, NULL)) == 0,\n\t\t\t\t\"[EnableDisableSMCFeatures] Attempt to disable SMU features High failed!\",\n\t\t\t\treturn ret);\n\t}\n\n\treturn 0;\n}\n\nint vega20_get_enabled_smc_features(struct pp_hwmgr *hwmgr,\n\t\tuint64_t *features_enabled)\n{\n\tuint32_t smc_features_low, smc_features_high;\n\tint ret = 0;\n\n\tif (features_enabled == NULL)\n\t\treturn -EINVAL;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetEnabledSmuFeaturesLow,\n\t\t\t&smc_features_low)) == 0,\n\t\t\t\"[GetEnabledSMCFeatures] Attempt to get SMU features Low failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc(hwmgr,\n\t\t\tPPSMC_MSG_GetEnabledSmuFeaturesHigh,\n\t\t\t&smc_features_high)) == 0,\n\t\t\t\"[GetEnabledSMCFeatures] Attempt to get SMU features High failed!\",\n\t\t\treturn ret);\n\n\t*features_enabled = ((((uint64_t)smc_features_low << SMU_FEATURES_LOW_SHIFT) & SMU_FEATURES_LOW_MASK) |\n\t\t\t(((uint64_t)smc_features_high << SMU_FEATURES_HIGH_SHIFT) & SMU_FEATURES_HIGH_MASK));\n\n\treturn 0;\n}\n\nstatic int vega20_set_tools_address(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tint ret = 0;\n\n\tif (priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr) {\n\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\tPPSMC_MSG_SetToolsDramAddrHigh,\n\t\t\t\tupper_32_bits(priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr),\n\t\t\t\tNULL);\n\t\tif (!ret)\n\t\t\tret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_SetToolsDramAddrLow,\n\t\t\t\t\tlower_32_bits(priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr),\n\t\t\t\t\tNULL);\n\t}\n\n\treturn ret;\n}\n\nint vega20_set_pptable_driver_address(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tint ret = 0;\n\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrHigh,\n\t\t\tupper_32_bits(priv->smu_tables.entry[TABLE_PPTABLE].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[SetPPtabeDriverAddress] Attempt to Set Dram Addr High Failed!\",\n\t\t\treturn ret);\n\tPP_ASSERT_WITH_CODE((ret = smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\tPPSMC_MSG_SetDriverDramAddrLow,\n\t\t\tlower_32_bits(priv->smu_tables.entry[TABLE_PPTABLE].mc_addr),\n\t\t\tNULL)) == 0,\n\t\t\t\"[SetPPtabeDriverAddress] Attempt to Set Dram Addr Low Failed!\",\n\t\t\treturn ret);\n\n\treturn ret;\n}\n\nstatic int vega20_smu_init(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_smumgr *priv;\n\tunsigned long tools_size = 0x19000;\n\tint ret = 0;\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tstruct cgs_firmware_info info = {0};\n\n\tret = cgs_get_firmware_info(hwmgr->device,\n\t\t\t\tsmu7_convert_fw_type_to_cgs(UCODE_ID_SMU),\n\t\t\t\t&info);\n\tif (ret || !info.kptr)\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(struct vega20_smumgr), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\thwmgr->smu_backend = priv;\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(PPTable_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].table);\n\tif (ret)\n\t\tgoto free_backend;\n\n\tpriv->smu_tables.entry[TABLE_PPTABLE].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_PPTABLE].size = sizeof(PPTable_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(Watermarks_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].table);\n\tif (ret)\n\t\tgoto err0;\n\n\tpriv->smu_tables.entry[TABLE_WATERMARKS].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_WATERMARKS].size = sizeof(Watermarks_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\ttools_size,\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].table);\n\tif (ret)\n\t\tgoto err1;\n\n\tpriv->smu_tables.entry[TABLE_PMSTATUSLOG].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_PMSTATUSLOG].size = tools_size;\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(OverDriveTable_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].table);\n\tif (ret)\n\t\tgoto err2;\n\n\tpriv->smu_tables.entry[TABLE_OVERDRIVE].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_OVERDRIVE].size = sizeof(OverDriveTable_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(SmuMetrics_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].table);\n\tif (ret)\n\t\tgoto err3;\n\n\tpriv->smu_tables.entry[TABLE_SMU_METRICS].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_SMU_METRICS].size = sizeof(SmuMetrics_t);\n\n\t \n\tret = amdgpu_bo_create_kernel((struct amdgpu_device *)hwmgr->adev,\n\t\t\tsizeof(DpmActivityMonitorCoeffInt_t),\n\t\t\tPAGE_SIZE,\n\t\t\tAMDGPU_GEM_DOMAIN_VRAM,\n\t\t\t&priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table);\n\tif (ret)\n\t\tgoto err4;\n\n\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].version = 0x01;\n\tpriv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].size = sizeof(DpmActivityMonitorCoeffInt_t);\n\n\tret = smu_v11_0_i2c_control_init(adev);\n\tif (ret)\n\t\tgoto err4;\n\n\treturn 0;\n\nerr4:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_SMU_METRICS].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].table);\nerr3:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_OVERDRIVE].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].table);\nerr2:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PMSTATUSLOG].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].table);\nerr1:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_WATERMARKS].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].table);\nerr0:\n\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PPTABLE].handle,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].mc_addr,\n\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].table);\nfree_backend:\n\tkfree(hwmgr->smu_backend);\n\n\treturn -EINVAL;\n}\n\nstatic int vega20_smu_fini(struct pp_hwmgr *hwmgr)\n{\n\tstruct vega20_smumgr *priv =\n\t\t\t(struct vega20_smumgr *)(hwmgr->smu_backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tsmu_v11_0_i2c_control_fini(adev);\n\n\tif (priv) {\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PPTABLE].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_PPTABLE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_WATERMARKS].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_WATERMARKS].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_PMSTATUSLOG].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_PMSTATUSLOG].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_OVERDRIVE].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_OVERDRIVE].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_SMU_METRICS].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_SMU_METRICS].table);\n\t\tamdgpu_bo_free_kernel(&priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].handle,\n\t\t\t\t&priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].mc_addr,\n\t\t\t\t&priv->smu_tables.entry[TABLE_ACTIVITY_MONITOR_COEFF].table);\n\t\tkfree(hwmgr->smu_backend);\n\t\thwmgr->smu_backend = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int vega20_start_smu(struct pp_hwmgr *hwmgr)\n{\n\tint ret;\n\n\tret = vega20_is_smc_ram_running(hwmgr);\n\tPP_ASSERT_WITH_CODE(ret,\n\t\t\t\"[Vega20StartSmu] SMC is not running!\",\n\t\t\treturn -EINVAL);\n\n\tret = vega20_set_tools_address(hwmgr);\n\tPP_ASSERT_WITH_CODE(!ret,\n\t\t\t\"[Vega20StartSmu] Failed to set tools address!\",\n\t\t\treturn ret);\n\n\treturn 0;\n}\n\nstatic bool vega20_is_dpm_running(struct pp_hwmgr *hwmgr)\n{\n\tuint64_t features_enabled = 0;\n\n\tvega20_get_enabled_smc_features(hwmgr, &features_enabled);\n\n\tif (features_enabled & SMC_DPM_FEATURES)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int vega20_smc_table_manager(struct pp_hwmgr *hwmgr, uint8_t *table,\n\t\t\t\t    uint16_t table_id, bool rw)\n{\n\tint ret;\n\n\tif (rw)\n\t\tret = vega20_copy_table_from_smc(hwmgr, table, table_id);\n\telse\n\t\tret = vega20_copy_table_to_smc(hwmgr, table, table_id);\n\n\treturn ret;\n}\n\nconst struct pp_smumgr_func vega20_smu_funcs = {\n\t.name = \"vega20_smu\",\n\t.smu_init = &vega20_smu_init,\n\t.smu_fini = &vega20_smu_fini,\n\t.start_smu = &vega20_start_smu,\n\t.request_smu_load_specific_fw = NULL,\n\t.send_msg_to_smc = &vega20_send_msg_to_smc,\n\t.send_msg_to_smc_with_parameter = &vega20_send_msg_to_smc_with_parameter,\n\t.download_pptable_settings = NULL,\n\t.upload_pptable_settings = NULL,\n\t.is_dpm_running = vega20_is_dpm_running,\n\t.get_argument = vega20_get_argument,\n\t.smc_table_manager = vega20_smc_table_manager,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}