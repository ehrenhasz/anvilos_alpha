{
  "module_name": "processpptables.c",
  "hash_id": "d393b6a122d4b064953a8c157cde7ab2c59d4167a2a8c3ebfda4c49d6635c379",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/processpptables.c",
  "human_readable_source": " \n#include \"pp_debug.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n\n#include <drm/amdgpu_drm.h>\n#include \"processpptables.h\"\n#include <atom-types.h>\n#include <atombios.h>\n#include \"pptable.h\"\n#include \"power_state.h\"\n#include \"hwmgr.h\"\n#include \"hardwaremanager.h\"\n\n\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2 12\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3 14\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4 16\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5 18\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6 20\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7 22\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V8 24\n#define SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V9 26\n\n#define NUM_BITS_CLOCK_INFO_ARRAY_INDEX 6\n\nstatic uint16_t get_vce_table_offset(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t vce_table_offset = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t   sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\n\t\tif (powerplay_table3->usExtendendedHeaderOffset > 0) {\n\t\t\tconst ATOM_PPLIB_EXTENDEDHEADER  *extended_header =\n\t\t\t\t\t\t(const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t\t\t(((unsigned long)powerplay_table3) +\n\t\t\t\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\t\t\tif (le16_to_cpu(extended_header->usSize) >=\n\t\t\t   SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V2)\n\t\t\t\tvce_table_offset = le16_to_cpu(extended_header->usVCETableOffset);\n\t\t}\n\t}\n\n\treturn vce_table_offset;\n}\n\nstatic uint16_t get_vce_clock_info_array_offset(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_vce_table_offset(hwmgr,\n\t\t\t\t\t\tpowerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn table_offset + 1;\n\n\treturn 0;\n}\n\nstatic uint16_t get_vce_clock_info_array_size(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_vce_clock_info_array_offset(hwmgr,\n\t\t\t\t\t\t\tpowerplay_table);\n\tuint16_t table_size = 0;\n\n\tif (table_offset > 0) {\n\t\tconst VCEClockInfoArray *p = (const VCEClockInfoArray *)\n\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\ttable_size = sizeof(uint8_t) + p->ucNumEntries * sizeof(VCEClockInfo);\n\t}\n\n\treturn table_size;\n}\n\nstatic uint16_t get_vce_clock_voltage_limit_table_offset(struct pp_hwmgr *hwmgr,\n\t\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_vce_clock_info_array_offset(hwmgr,\n\t\t\t\t\t\t\tpowerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn table_offset + get_vce_clock_info_array_size(hwmgr,\n\t\t\t\t\t\t\tpowerplay_table);\n\n\treturn 0;\n}\n\nstatic uint16_t get_vce_clock_voltage_limit_table_size(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_vce_clock_voltage_limit_table_offset(hwmgr, powerplay_table);\n\tuint16_t table_size = 0;\n\n\tif (table_offset > 0) {\n\t\tconst ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *ptable =\n\t\t\t(const ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)(((unsigned long) powerplay_table) + table_offset);\n\n\t\ttable_size = sizeof(uint8_t) + ptable->numEntries * sizeof(ATOM_PPLIB_VCE_Clock_Voltage_Limit_Record);\n\t}\n\treturn table_size;\n}\n\nstatic uint16_t get_vce_state_table_offset(struct pp_hwmgr *hwmgr, const ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_vce_clock_voltage_limit_table_offset(hwmgr, powerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn table_offset + get_vce_clock_voltage_limit_table_size(hwmgr, powerplay_table);\n\n\treturn 0;\n}\n\nstatic const ATOM_PPLIB_VCE_State_Table *get_vce_state_table(\n\t\t\t\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\t\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_vce_state_table_offset(hwmgr, powerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn (const ATOM_PPLIB_VCE_State_Table *)(((unsigned long) powerplay_table) + table_offset);\n\n\treturn NULL;\n}\n\nstatic uint16_t get_uvd_table_offset(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t uvd_table_offset = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\t\tif (powerplay_table3->usExtendendedHeaderOffset > 0) {\n\t\t\tconst ATOM_PPLIB_EXTENDEDHEADER  *extended_header =\n\t\t\t\t\t(const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t\t(((unsigned long)powerplay_table3) +\n\t\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\t\t\tif (le16_to_cpu(extended_header->usSize) >=\n\t\t\t    SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V3)\n\t\t\t\tuvd_table_offset = le16_to_cpu(extended_header->usUVDTableOffset);\n\t\t}\n\t}\n\treturn uvd_table_offset;\n}\n\nstatic uint16_t get_uvd_clock_info_array_offset(struct pp_hwmgr *hwmgr,\n\t\t\t const ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_uvd_table_offset(hwmgr,\n\t\t\t\t\t\t    powerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn table_offset + 1;\n\treturn 0;\n}\n\nstatic uint16_t get_uvd_clock_info_array_size(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_uvd_clock_info_array_offset(hwmgr,\n\t\t\t\t\t\t    powerplay_table);\n\tuint16_t table_size = 0;\n\n\tif (table_offset > 0) {\n\t\tconst UVDClockInfoArray *p = (const UVDClockInfoArray *)\n\t\t\t\t\t(((unsigned long) powerplay_table)\n\t\t\t\t\t+ table_offset);\n\t\ttable_size = sizeof(UCHAR) +\n\t\t\t     p->ucNumEntries * sizeof(UVDClockInfo);\n\t}\n\n\treturn table_size;\n}\n\nstatic uint16_t get_uvd_clock_voltage_limit_table_offset(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_uvd_clock_info_array_offset(hwmgr,\n\t\t\t\t\t\t     powerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn table_offset +\n\t\t\tget_uvd_clock_info_array_size(hwmgr, powerplay_table);\n\n\treturn 0;\n}\n\nstatic uint16_t get_samu_table_offset(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t samu_table_offset = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\t\tif (powerplay_table3->usExtendendedHeaderOffset > 0) {\n\t\t\tconst ATOM_PPLIB_EXTENDEDHEADER  *extended_header =\n\t\t\t\t(const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t(((unsigned long)powerplay_table3) +\n\t\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\t\t\tif (le16_to_cpu(extended_header->usSize) >=\n\t\t\t    SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V4)\n\t\t\t\tsamu_table_offset = le16_to_cpu(extended_header->usSAMUTableOffset);\n\t\t}\n\t}\n\n\treturn samu_table_offset;\n}\n\nstatic uint16_t get_samu_clock_voltage_limit_table_offset(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t table_offset = get_samu_table_offset(hwmgr,\n\t\t\t\t\t    powerplay_table);\n\n\tif (table_offset > 0)\n\t\treturn table_offset + 1;\n\n\treturn 0;\n}\n\nstatic uint16_t get_acp_table_offset(struct pp_hwmgr *hwmgr,\n\t\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t acp_table_offset = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\t\tif (powerplay_table3->usExtendendedHeaderOffset > 0) {\n\t\t\tconst ATOM_PPLIB_EXTENDEDHEADER  *pExtendedHeader =\n\t\t\t\t(const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t(((unsigned long)powerplay_table3) +\n\t\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\t\t\tif (le16_to_cpu(pExtendedHeader->usSize) >=\n\t\t\t    SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V6)\n\t\t\t\tacp_table_offset = le16_to_cpu(pExtendedHeader->usACPTableOffset);\n\t\t}\n\t}\n\n\treturn acp_table_offset;\n}\n\nstatic uint16_t get_acp_clock_voltage_limit_table_offset(\n\t\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t tableOffset = get_acp_table_offset(hwmgr, powerplay_table);\n\n\tif (tableOffset > 0)\n\t\treturn tableOffset + 1;\n\n\treturn 0;\n}\n\nstatic uint16_t get_cacp_tdp_table_offset(\n\t\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t cacTdpTableOffset = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\t\tif (powerplay_table3->usExtendendedHeaderOffset > 0) {\n\t\t\tconst ATOM_PPLIB_EXTENDEDHEADER  *pExtendedHeader =\n\t\t\t\t\t(const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t\t(((unsigned long)powerplay_table3) +\n\t\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\t\t\tif (le16_to_cpu(pExtendedHeader->usSize) >=\n\t\t\t    SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V7)\n\t\t\t\tcacTdpTableOffset = le16_to_cpu(pExtendedHeader->usPowerTuneTableOffset);\n\t\t}\n\t}\n\n\treturn cacTdpTableOffset;\n}\n\nstatic int get_cac_tdp_table(struct pp_hwmgr *hwmgr,\n\t\t\t\tstruct phm_cac_tdp_table **ptable,\n\t\t\t\tconst ATOM_PowerTune_Table *table,\n\t\t\t\tuint16_t us_maximum_power_delivery_limit)\n{\n\tunsigned long table_size;\n\tstruct phm_cac_tdp_table *tdp_table;\n\n\ttable_size = sizeof(unsigned long) + sizeof(struct phm_cac_tdp_table);\n\n\ttdp_table = kzalloc(table_size, GFP_KERNEL);\n\tif (NULL == tdp_table)\n\t\treturn -ENOMEM;\n\n\ttdp_table->usTDP = le16_to_cpu(table->usTDP);\n\ttdp_table->usConfigurableTDP = le16_to_cpu(table->usConfigurableTDP);\n\ttdp_table->usTDC = le16_to_cpu(table->usTDC);\n\ttdp_table->usBatteryPowerLimit = le16_to_cpu(table->usBatteryPowerLimit);\n\ttdp_table->usSmallPowerLimit = le16_to_cpu(table->usSmallPowerLimit);\n\ttdp_table->usLowCACLeakage = le16_to_cpu(table->usLowCACLeakage);\n\ttdp_table->usHighCACLeakage = le16_to_cpu(table->usHighCACLeakage);\n\ttdp_table->usMaximumPowerDeliveryLimit = us_maximum_power_delivery_limit;\n\n\t*ptable = tdp_table;\n\n\treturn 0;\n}\n\nstatic uint16_t get_sclk_vdd_gfx_table_offset(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t sclk_vdd_gfx_table_offset = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\t\tif (powerplay_table3->usExtendendedHeaderOffset > 0) {\n\t\t\tconst ATOM_PPLIB_EXTENDEDHEADER  *pExtendedHeader =\n\t\t\t\t(const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t(((unsigned long)powerplay_table3) +\n\t\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\t\t\tif (le16_to_cpu(pExtendedHeader->usSize) >=\n\t\t\t    SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V8)\n\t\t\t\tsclk_vdd_gfx_table_offset =\n\t\t\t\t\tle16_to_cpu(pExtendedHeader->usSclkVddgfxTableOffset);\n\t\t}\n\t}\n\n\treturn sclk_vdd_gfx_table_offset;\n}\n\nstatic uint16_t get_sclk_vdd_gfx_clock_voltage_dependency_table_offset(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tuint16_t tableOffset = get_sclk_vdd_gfx_table_offset(hwmgr, powerplay_table);\n\n\tif (tableOffset > 0)\n\t\treturn tableOffset;\n\n\treturn 0;\n}\n\n\nstatic int get_clock_voltage_dependency_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_clock_voltage_dependency_table **ptable,\n\t\tconst ATOM_PPLIB_Clock_Voltage_Dependency_Table *table)\n{\n\n\tunsigned long i;\n\tstruct phm_clock_voltage_dependency_table *dep_table;\n\n\tdep_table = kzalloc(struct_size(dep_table, entries, table->ucNumEntries),\n\t\t\t    GFP_KERNEL);\n\tif (NULL == dep_table)\n\t\treturn -ENOMEM;\n\n\tdep_table->count = (unsigned long)table->ucNumEntries;\n\n\tfor (i = 0; i < dep_table->count; i++) {\n\t\tdep_table->entries[i].clk =\n\t\t\t((unsigned long)table->entries[i].ucClockHigh << 16) |\n\t\t\tle16_to_cpu(table->entries[i].usClockLow);\n\t\tdep_table->entries[i].v =\n\t\t\t(unsigned long)le16_to_cpu(table->entries[i].usVoltage);\n\t}\n\n\t*ptable = dep_table;\n\n\treturn 0;\n}\n\nstatic int get_valid_clk(struct pp_hwmgr *hwmgr,\n\t\t\tstruct phm_clock_array **ptable,\n\t\t\tconst struct phm_clock_voltage_dependency_table *table)\n{\n\tunsigned long i;\n\tstruct phm_clock_array *clock_table;\n\n\tclock_table = kzalloc(struct_size(clock_table, values, table->count), GFP_KERNEL);\n\tif (!clock_table)\n\t\treturn -ENOMEM;\n\n\tclock_table->count = (unsigned long)table->count;\n\n\tfor (i = 0; i < clock_table->count; i++)\n\t\tclock_table->values[i] = (unsigned long)table->entries[i].clk;\n\n\t*ptable = clock_table;\n\n\treturn 0;\n}\n\nstatic int get_clock_voltage_limit(struct pp_hwmgr *hwmgr,\n\t\t\tstruct phm_clock_and_voltage_limits *limits,\n\t\t\tconst ATOM_PPLIB_Clock_Voltage_Limit_Table *table)\n{\n\tlimits->sclk = ((unsigned long)table->entries[0].ucSclkHigh << 16) |\n\t\t\tle16_to_cpu(table->entries[0].usSclkLow);\n\tlimits->mclk = ((unsigned long)table->entries[0].ucMclkHigh << 16) |\n\t\t\tle16_to_cpu(table->entries[0].usMclkLow);\n\tlimits->vddc = (unsigned long)le16_to_cpu(table->entries[0].usVddc);\n\tlimits->vddci = (unsigned long)le16_to_cpu(table->entries[0].usVddci);\n\n\treturn 0;\n}\n\n\nstatic void set_hw_cap(struct pp_hwmgr *hwmgr, bool enable,\n\t\t       enum phm_platform_caps cap)\n{\n\tif (enable)\n\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps, cap);\n\telse\n\t\tphm_cap_unset(hwmgr->platform_descriptor.platformCaps, cap);\n}\n\nstatic int set_platform_caps(struct pp_hwmgr *hwmgr,\n\t\t\tunsigned long powerplay_caps)\n{\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_POWERPLAY),\n\t\tPHM_PlatformCaps_PowerPlaySupport\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_SBIOSPOWERSOURCE),\n\t\tPHM_PlatformCaps_BiosPowerSourceControl\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_ASPM_L0s),\n\t\tPHM_PlatformCaps_EnableASPML0s\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_ASPM_L1),\n\t\tPHM_PlatformCaps_EnableASPML1\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_BACKBIAS),\n\t\tPHM_PlatformCaps_EnableBackbias\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_HARDWAREDC),\n\t\tPHM_PlatformCaps_AutomaticDCTransition\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_GEMINIPRIMARY),\n\t\tPHM_PlatformCaps_GeminiPrimary\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_STEPVDDC),\n\t\tPHM_PlatformCaps_StepVddc\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_VOLTAGECONTROL),\n\t\tPHM_PlatformCaps_EnableVoltageControl\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_SIDEPORTCONTROL),\n\t\tPHM_PlatformCaps_EnableSideportControl\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1),\n\t\tPHM_PlatformCaps_TurnOffPll_ASPML1\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_HTLINKCONTROL),\n\t\tPHM_PlatformCaps_EnableHTLinkControl\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_MVDDCONTROL),\n\t\tPHM_PlatformCaps_EnableMVDDControl\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL),\n\t\tPHM_PlatformCaps_ControlVDDCI\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_REGULATOR_HOT),\n\t\tPHM_PlatformCaps_RegulatorHot\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_GOTO_BOOT_ON_ALERT),\n\t\tPHM_PlatformCaps_BootStateOnAlert\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_DONT_WAIT_FOR_VBLANK_ON_ALERT),\n\t\tPHM_PlatformCaps_DontWaitForVBlankOnAlert\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_BACO),\n\t\tPHM_PlatformCaps_BACO\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_NEW_CAC_VOLTAGE),\n\t\tPHM_PlatformCaps_NewCACVoltage\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_REVERT_GPIO5_POLARITY),\n\t\tPHM_PlatformCaps_RevertGPIO5Polarity\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_OUTPUT_THERMAL2GPIO17),\n\t\tPHM_PlatformCaps_Thermal2GPIO17\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_VRHOT_GPIO_CONFIGURABLE),\n\t\tPHM_PlatformCaps_VRHotGPIOConfigurable\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_TEMP_INVERSION),\n\t\tPHM_PlatformCaps_TempInversion\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_EVV),\n\t\tPHM_PlatformCaps_EVV\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_COMBINE_PCC_WITH_THERMAL_SIGNAL),\n\t\tPHM_PlatformCaps_CombinePCCWithThermalSignal\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_LOAD_POST_PRODUCTION_FIRMWARE),\n\t\tPHM_PlatformCaps_LoadPostProductionFirmware\n\t);\n\n\tset_hw_cap(\n\t\thwmgr,\n\t\t0 != (powerplay_caps & ATOM_PP_PLATFORM_CAP_DISABLE_USING_ACTUAL_TEMPERATURE_FOR_POWER_CALC),\n\t\tPHM_PlatformCaps_DisableUsingActualTemperatureForPowerCalc\n\t);\n\n\treturn 0;\n}\n\nstatic PP_StateClassificationFlags make_classification_flags(\n\t\t\t\t\t\t   struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\t    USHORT classification,\n\t\t\t\t\t\t   USHORT classification2)\n{\n\tPP_StateClassificationFlags result = 0;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_BOOT)\n\t\tresult |= PP_StateClassificationFlag_Boot;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_THERMAL)\n\t\tresult |= PP_StateClassificationFlag_Thermal;\n\n\tif (classification &\n\t\t\tATOM_PPLIB_CLASSIFICATION_LIMITEDPOWERSOURCE)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_REST)\n\t\tresult |= PP_StateClassificationFlag_Rest;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_FORCED)\n\t\tresult |= PP_StateClassificationFlag_Forced;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_3DPERFORMANCE)\n\t\tresult |= PP_StateClassificationFlag_3DPerformance;\n\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_OVERDRIVETEMPLATE)\n\t\tresult |= PP_StateClassificationFlag_ACOverdriveTemplate;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\n\t\tresult |= PP_StateClassificationFlag_Uvd;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_HDSTATE)\n\t\tresult |= PP_StateClassificationFlag_UvdHD;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_SDSTATE)\n\t\tresult |= PP_StateClassificationFlag_UvdSD;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_HD2STATE)\n\t\tresult |= PP_StateClassificationFlag_HD2;\n\n\tif (classification & ATOM_PPLIB_CLASSIFICATION_ACPI)\n\t\tresult |= PP_StateClassificationFlag_ACPI;\n\n\tif (classification2 & ATOM_PPLIB_CLASSIFICATION2_LIMITEDPOWERSOURCE_2)\n\t\tresult |= PP_StateClassificationFlag_LimitedPowerSource_2;\n\n\n\tif (classification2 & ATOM_PPLIB_CLASSIFICATION2_ULV)\n\t\tresult |= PP_StateClassificationFlag_ULV;\n\n\tif (classification2 & ATOM_PPLIB_CLASSIFICATION2_MVC)\n\t\tresult |= PP_StateClassificationFlag_UvdMVC;\n\n\treturn result;\n}\n\nstatic int init_non_clock_fields(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\tstruct pp_power_state *ps,\n\t\t\t\t\t\t\t    uint8_t version,\n\t\t\t const ATOM_PPLIB_NONCLOCK_INFO *pnon_clock_info) {\n\tunsigned long rrr_index;\n\tunsigned long tmp;\n\n\tps->classification.ui_label = (le16_to_cpu(pnon_clock_info->usClassification) &\n\t\t\t\t\tATOM_PPLIB_CLASSIFICATION_UI_MASK) >> ATOM_PPLIB_CLASSIFICATION_UI_SHIFT;\n\tps->classification.flags = make_classification_flags(hwmgr,\n\t\t\t\tle16_to_cpu(pnon_clock_info->usClassification),\n\t\t\t\tle16_to_cpu(pnon_clock_info->usClassification2));\n\n\tps->classification.temporary_state = false;\n\tps->classification.to_be_deleted = false;\n\ttmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\tATOM_PPLIB_SINGLE_DISPLAY_ONLY;\n\n\tps->validation.singleDisplayOnly = (0 != tmp);\n\n\ttmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\tATOM_PPLIB_DISALLOW_ON_DC;\n\n\tps->validation.disallowOnDC = (0 != tmp);\n\n\tps->pcie.lanes = ((le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\t\t\tATOM_PPLIB_PCIE_LINK_WIDTH_MASK) >>\n\t\t\t\tATOM_PPLIB_PCIE_LINK_WIDTH_SHIFT) + 1;\n\n\tps->pcie.lanes = 0;\n\n\tps->display.disableFrameModulation = false;\n\n\trrr_index = (le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\t\tATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_MASK) >>\n\t\t\tATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_SHIFT;\n\n\tif (rrr_index != ATOM_PPLIB_LIMITED_REFRESHRATE_UNLIMITED) {\n\t\tstatic const uint8_t look_up[(ATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_MASK >> ATOM_PPLIB_LIMITED_REFRESHRATE_VALUE_SHIFT) + 1] = \\\n\t\t\t\t\t\t\t\t{ 0, 50, 0 };\n\n\t\tps->display.refreshrateSource = PP_RefreshrateSource_Explicit;\n\t\tps->display.explicitRefreshrate = look_up[rrr_index];\n\t\tps->display.limitRefreshrate = true;\n\n\t\tif (ps->display.explicitRefreshrate == 0)\n\t\t\tps->display.limitRefreshrate = false;\n\t} else\n\t\tps->display.limitRefreshrate = false;\n\n\ttmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\tATOM_PPLIB_ENABLE_VARIBRIGHT;\n\n\tps->display.enableVariBright = (0 != tmp);\n\n\ttmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\tATOM_PPLIB_SWSTATE_MEMORY_DLL_OFF;\n\n\tps->memory.dllOff = (0 != tmp);\n\n\tps->memory.m3arb = (le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\t\t    ATOM_PPLIB_M3ARB_MASK) >> ATOM_PPLIB_M3ARB_SHIFT;\n\n\tps->temperatures.min = PP_TEMPERATURE_UNITS_PER_CENTIGRADES *\n\t\t\t\t     pnon_clock_info->ucMinTemperature;\n\n\tps->temperatures.max = PP_TEMPERATURE_UNITS_PER_CENTIGRADES *\n\t\t\t\t     pnon_clock_info->ucMaxTemperature;\n\n\ttmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\tATOM_PPLIB_SOFTWARE_DISABLE_LOADBALANCING;\n\n\tps->software.disableLoadBalancing = tmp;\n\n\ttmp = le32_to_cpu(pnon_clock_info->ulCapsAndSettings) &\n\t\tATOM_PPLIB_SOFTWARE_ENABLE_SLEEP_FOR_TIMESTAMPS;\n\n\tps->software.enableSleepForTimestamps = (0 != tmp);\n\n\tps->validation.supportedPowerLevels = pnon_clock_info->ucRequiredPower;\n\n\tif (ATOM_PPLIB_NONCLOCKINFO_VER1 < version) {\n\t\tps->uvd_clocks.VCLK = le32_to_cpu(pnon_clock_info->ulVCLK);\n\t\tps->uvd_clocks.DCLK = le32_to_cpu(pnon_clock_info->ulDCLK);\n\t} else {\n\t\tps->uvd_clocks.VCLK = 0;\n\t\tps->uvd_clocks.DCLK = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic ULONG size_of_entry_v2(ULONG num_dpm_levels)\n{\n\treturn (sizeof(UCHAR) + sizeof(UCHAR) +\n\t\t\t(num_dpm_levels * sizeof(UCHAR)));\n}\n\nstatic const ATOM_PPLIB_STATE_V2 *get_state_entry_v2(\n\t\t\t\t\tconst StateArray * pstate_arrays,\n\t\t\t\t\t\t\t ULONG entry_index)\n{\n\tULONG i;\n\tconst ATOM_PPLIB_STATE_V2 *pstate;\n\n\tpstate = pstate_arrays->states;\n\tif (entry_index <= pstate_arrays->ucNumEntries) {\n\t\tfor (i = 0; i < entry_index; i++)\n\t\t\tpstate = (ATOM_PPLIB_STATE_V2 *)(\n\t\t\t\t\t\t  (unsigned long)pstate +\n\t\t\t     size_of_entry_v2(pstate->ucNumDPMLevels));\n\t}\n\treturn pstate;\n}\n\nstatic const unsigned char soft_dummy_pp_table[] = {\n\t0xe1, 0x01, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0x4a, 0x00, 0x6c, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x42, 0x00, 0x02, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,\n\t0x00, 0x4e, 0x00, 0x88, 0x00, 0x00, 0x9e, 0x00, 0x17, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00,\n\t0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,\n\t0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x18, 0x05, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe1, 0x00, 0x43, 0x01, 0x00, 0x00, 0x00, 0x00,\n\t0x8e, 0x01, 0x00, 0x00, 0xb8, 0x01, 0x00, 0x00, 0x08, 0x30, 0x75, 0x00, 0x80, 0x00, 0xa0, 0x8c,\n\t0x00, 0x7e, 0x00, 0x71, 0xa5, 0x00, 0x7c, 0x00, 0xe5, 0xc8, 0x00, 0x70, 0x00, 0x91, 0xf4, 0x00,\n\t0x64, 0x00, 0x40, 0x19, 0x01, 0x5a, 0x00, 0x0e, 0x28, 0x01, 0x52, 0x00, 0x80, 0x38, 0x01, 0x4a,\n\t0x00, 0x00, 0x09, 0x30, 0x75, 0x00, 0x30, 0x75, 0x00, 0x40, 0x9c, 0x00, 0x40, 0x9c, 0x00, 0x59,\n\t0xd8, 0x00, 0x59, 0xd8, 0x00, 0x91, 0xf4, 0x00, 0x91, 0xf4, 0x00, 0x0e, 0x28, 0x01, 0x0e, 0x28,\n\t0x01, 0x90, 0x5f, 0x01, 0x90, 0x5f, 0x01, 0x00, 0x77, 0x01, 0x00, 0x77, 0x01, 0xca, 0x91, 0x01,\n\t0xca, 0x91, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x00, 0x00, 0x7e, 0x00, 0x01,\n\t0x7c, 0x00, 0x02, 0x70, 0x00, 0x03, 0x64, 0x00, 0x04, 0x5a, 0x00, 0x05, 0x52, 0x00, 0x06, 0x4a,\n\t0x00, 0x07, 0x08, 0x08, 0x00, 0x08, 0x00, 0x01, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02, 0x03,\n\t0x02, 0x04, 0x02, 0x00, 0x08, 0x40, 0x9c, 0x00, 0x30, 0x75, 0x00, 0x74, 0xb5, 0x00, 0xa0, 0x8c,\n\t0x00, 0x60, 0xea, 0x00, 0x74, 0xb5, 0x00, 0x0e, 0x28, 0x01, 0x60, 0xea, 0x00, 0x90, 0x5f, 0x01,\n\t0x40, 0x19, 0x01, 0xb2, 0xb0, 0x01, 0x90, 0x5f, 0x01, 0xc0, 0xd4, 0x01, 0x00, 0x77, 0x01, 0x5e,\n\t0xff, 0x01, 0xca, 0x91, 0x01, 0x08, 0x80, 0x00, 0x00, 0x7e, 0x00, 0x01, 0x7c, 0x00, 0x02, 0x70,\n\t0x00, 0x03, 0x64, 0x00, 0x04, 0x5a, 0x00, 0x05, 0x52, 0x00, 0x06, 0x4a, 0x00, 0x07, 0x00, 0x08,\n\t0x80, 0x00, 0x30, 0x75, 0x00, 0x7e, 0x00, 0x40, 0x9c, 0x00, 0x7c, 0x00, 0x59, 0xd8, 0x00, 0x70,\n\t0x00, 0xdc, 0x0b, 0x01, 0x64, 0x00, 0x80, 0x38, 0x01, 0x5a, 0x00, 0x80, 0x38, 0x01, 0x52, 0x00,\n\t0x80, 0x38, 0x01, 0x4a, 0x00, 0x80, 0x38, 0x01, 0x08, 0x30, 0x75, 0x00, 0x80, 0x00, 0xa0, 0x8c,\n\t0x00, 0x7e, 0x00, 0x71, 0xa5, 0x00, 0x7c, 0x00, 0xe5, 0xc8, 0x00, 0x74, 0x00, 0x91, 0xf4, 0x00,\n\t0x66, 0x00, 0x40, 0x19, 0x01, 0x58, 0x00, 0x0e, 0x28, 0x01, 0x52, 0x00, 0x80, 0x38, 0x01, 0x4a,\n\t0x00\n};\n\nstatic const ATOM_PPLIB_POWERPLAYTABLE *get_powerplay_table(\n\t\t\t\t     struct pp_hwmgr *hwmgr)\n{\n\tconst void *table_addr = hwmgr->soft_pp_table;\n\tuint8_t frev, crev;\n\tuint16_t size;\n\n\tif (!table_addr) {\n\t\tif (hwmgr->chip_id == CHIP_RAVEN) {\n\t\t\ttable_addr = &soft_dummy_pp_table[0];\n\t\t\thwmgr->soft_pp_table = &soft_dummy_pp_table[0];\n\t\t\thwmgr->soft_pp_table_size = sizeof(soft_dummy_pp_table);\n\t\t} else {\n\t\t\ttable_addr = smu_atom_get_data_table(hwmgr->adev,\n\t\t\t\t\tGetIndexIntoMasterTable(DATA, PowerPlayInfo),\n\t\t\t\t\t&size, &frev, &crev);\n\t\t\thwmgr->soft_pp_table = table_addr;\n\t\t\thwmgr->soft_pp_table_size = size;\n\t\t}\n\t}\n\n\treturn (const ATOM_PPLIB_POWERPLAYTABLE *)table_addr;\n}\n\nint pp_tables_get_response_times(struct pp_hwmgr *hwmgr,\n\t\t\t\tuint32_t *vol_rep_time, uint32_t *bb_rep_time)\n{\n\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_tab = get_powerplay_table(hwmgr);\n\n\tPP_ASSERT_WITH_CODE(NULL != powerplay_tab,\n\t\t\t    \"Missing PowerPlay Table!\", return -EINVAL);\n\n\t*vol_rep_time = (uint32_t)le16_to_cpu(powerplay_tab->usVoltageTime);\n\t*bb_rep_time = (uint32_t)le16_to_cpu(powerplay_tab->usBackbiasTime);\n\n\treturn 0;\n}\n\nint pp_tables_get_num_of_entries(struct pp_hwmgr *hwmgr,\n\t\t\t\t     unsigned long *num_of_entries)\n{\n\tconst StateArray *pstate_arrays;\n\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table = get_powerplay_table(hwmgr);\n\n\tif (powerplay_table == NULL)\n\t\treturn -1;\n\n\tif (powerplay_table->sHeader.ucTableFormatRevision >= 6) {\n\t\tpstate_arrays = (StateArray *)(((unsigned long)powerplay_table) +\n\t\t\t\t\tle16_to_cpu(powerplay_table->usStateArrayOffset));\n\n\t\t*num_of_entries = (unsigned long)(pstate_arrays->ucNumEntries);\n\t} else\n\t\t*num_of_entries = (unsigned long)(powerplay_table->ucNumStates);\n\n\treturn 0;\n}\n\nint pp_tables_get_entry(struct pp_hwmgr *hwmgr,\n\t\t\t\tunsigned long entry_index,\n\t\t\t\tstruct pp_power_state *ps,\n\t\t\t pp_tables_hw_clock_info_callback func)\n{\n\tint i;\n\tconst StateArray *pstate_arrays;\n\tconst ATOM_PPLIB_STATE_V2 *pstate_entry_v2;\n\tconst ATOM_PPLIB_NONCLOCK_INFO *pnon_clock_info;\n\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table = get_powerplay_table(hwmgr);\n\tint result = 0;\n\tint res = 0;\n\n\tconst ClockInfoArray *pclock_arrays;\n\n\tconst NonClockInfoArray *pnon_clock_arrays;\n\n\tconst ATOM_PPLIB_STATE *pstate_entry;\n\n\tif (powerplay_table == NULL)\n\t\treturn -1;\n\n\tps->classification.bios_index = entry_index;\n\n\tif (powerplay_table->sHeader.ucTableFormatRevision >= 6) {\n\t\tpstate_arrays = (StateArray *)(((unsigned long)powerplay_table) +\n\t\t\t\t\tle16_to_cpu(powerplay_table->usStateArrayOffset));\n\n\t\tif (entry_index > pstate_arrays->ucNumEntries)\n\t\t\treturn -1;\n\n\t\tpstate_entry_v2 = get_state_entry_v2(pstate_arrays, entry_index);\n\t\tpclock_arrays = (ClockInfoArray *)(((unsigned long)powerplay_table) +\n\t\t\t\t\tle16_to_cpu(powerplay_table->usClockInfoArrayOffset));\n\n\t\tpnon_clock_arrays = (NonClockInfoArray *)(((unsigned long)powerplay_table) +\n\t\t\t\t\t\tle16_to_cpu(powerplay_table->usNonClockInfoArrayOffset));\n\n\t\tpnon_clock_info = (ATOM_PPLIB_NONCLOCK_INFO *)((unsigned long)(pnon_clock_arrays->nonClockInfo) +\n\t\t\t\t\t(pstate_entry_v2->nonClockInfoIndex * pnon_clock_arrays->ucEntrySize));\n\n\t\tresult = init_non_clock_fields(hwmgr, ps, pnon_clock_arrays->ucEntrySize, pnon_clock_info);\n\n\t\tfor (i = 0; i < pstate_entry_v2->ucNumDPMLevels; i++) {\n\t\t\tconst void *pclock_info = (const void *)(\n\t\t\t\t\t\t\t(unsigned long)(pclock_arrays->clockInfo) +\n\t\t\t\t\t\t\t(pstate_entry_v2->clockInfoIndex[i] * pclock_arrays->ucEntrySize));\n\t\t\tres = func(hwmgr, &ps->hardware, i, pclock_info);\n\t\t\tif ((0 == result) && (0 != res))\n\t\t\t\tresult = res;\n\t\t}\n\t} else {\n\t\tif (entry_index > powerplay_table->ucNumStates)\n\t\t\treturn -1;\n\n\t\tpstate_entry = (ATOM_PPLIB_STATE *)((unsigned long)powerplay_table +\n\t\t\t\t\t\t    le16_to_cpu(powerplay_table->usStateArrayOffset) +\n\t\t\t\t\t\t    entry_index * powerplay_table->ucStateEntrySize);\n\n\t\tpnon_clock_info = (ATOM_PPLIB_NONCLOCK_INFO *)((unsigned long)powerplay_table +\n\t\t\t\t\t\tle16_to_cpu(powerplay_table->usNonClockInfoArrayOffset) +\n\t\t\t\t\t\tpstate_entry->ucNonClockStateIndex *\n\t\t\t\t\t\tpowerplay_table->ucNonClockSize);\n\n\t\tresult = init_non_clock_fields(hwmgr, ps,\n\t\t\t\t\t\t\tpowerplay_table->ucNonClockSize,\n\t\t\t\t\t\t\tpnon_clock_info);\n\n\t\tfor (i = 0; i < powerplay_table->ucStateEntrySize-1; i++) {\n\t\t\tconst void *pclock_info = (const void *)((unsigned long)powerplay_table +\n\t\t\t\t\t\tle16_to_cpu(powerplay_table->usClockInfoArrayOffset) +\n\t\t\t\t\t\tpstate_entry->ucClockStateIndices[i] *\n\t\t\t\t\t\tpowerplay_table->ucClockInfoSize);\n\n\t\t\tint res = func(hwmgr, &ps->hardware, i, pclock_info);\n\n\t\t\tif ((0 == result) && (0 != res))\n\t\t\t\t\tresult = res;\n\t\t}\n\t}\n\n\tif ((0 == result) && (0 != (ps->classification.flags & PP_StateClassificationFlag_Boot))) {\n\t\tif (hwmgr->chip_family < AMDGPU_FAMILY_RV)\n\t\t\tresult = hwmgr->hwmgr_func->patch_boot_state(hwmgr, &(ps->hardware));\n\t}\n\n\treturn result;\n}\n\nstatic int init_powerplay_tables(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table\n)\n{\n\treturn 0;\n}\n\n\nstatic int init_thermal_controller(\n\t\t\tstruct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\thwmgr->thermal_controller.ucType =\n\t\t\tpowerplay_table->sThermalController.ucType;\n\thwmgr->thermal_controller.ucI2cLine =\n\t\t\tpowerplay_table->sThermalController.ucI2cLine;\n\thwmgr->thermal_controller.ucI2cAddress =\n\t\t\tpowerplay_table->sThermalController.ucI2cAddress;\n\n\thwmgr->thermal_controller.fanInfo.bNoFan =\n\t\t(0 != (powerplay_table->sThermalController.ucFanParameters &\n\t\t\tATOM_PP_FANPARAMETERS_NOFAN));\n\n\thwmgr->thermal_controller.fanInfo.ucTachometerPulsesPerRevolution =\n\t\tpowerplay_table->sThermalController.ucFanParameters &\n\t\tATOM_PP_FANPARAMETERS_TACHOMETER_PULSES_PER_REVOLUTION_MASK;\n\n\thwmgr->thermal_controller.fanInfo.ulMinRPM\n\t\t= powerplay_table->sThermalController.ucFanMinRPM * 100UL;\n\thwmgr->thermal_controller.fanInfo.ulMaxRPM\n\t\t= powerplay_table->sThermalController.ucFanMaxRPM * 100UL;\n\n\tset_hw_cap(hwmgr,\n\t\t   ATOM_PP_THERMALCONTROLLER_NONE != hwmgr->thermal_controller.ucType,\n\t\t   PHM_PlatformCaps_ThermalController);\n\n        if (powerplay_table->usTableSize >= sizeof(ATOM_PPLIB_POWERPLAYTABLE3)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3 =\n\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\n\t\tif (0 == le16_to_cpu(powerplay_table3->usFanTableOffset)) {\n\t\t\thwmgr->thermal_controller.use_hw_fan_control = 1;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst ATOM_PPLIB_FANTABLE *fan_table =\n\t\t\t\t(const ATOM_PPLIB_FANTABLE *)(((unsigned long)powerplay_table) +\n\t\t\t\t\t\t\t      le16_to_cpu(powerplay_table3->usFanTableOffset));\n\n\t\t\tif (1 <= fan_table->ucFanTableFormat) {\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.ucTHyst =\n\t\t\t\t\tfan_table->ucTHyst;\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMin =\n\t\t\t\t\tle16_to_cpu(fan_table->usTMin);\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMed =\n\t\t\t\t\tle16_to_cpu(fan_table->usTMed);\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTHigh =\n\t\t\t\t\tle16_to_cpu(fan_table->usTHigh);\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMin =\n\t\t\t\t\tle16_to_cpu(fan_table->usPWMMin);\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMMed =\n\t\t\t\t\tle16_to_cpu(fan_table->usPWMMed);\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usPWMHigh =\n\t\t\t\t\tle16_to_cpu(fan_table->usPWMHigh);\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax = 10900;\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.ulCycleDelay = 100000;\n\n\t\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\t    PHM_PlatformCaps_MicrocodeFanControl);\n\t\t\t}\n\n\t\t\tif (2 <= fan_table->ucFanTableFormat) {\n\t\t\t\tconst ATOM_PPLIB_FANTABLE2 *fan_table2 =\n\t\t\t\t\t(const ATOM_PPLIB_FANTABLE2 *)(((unsigned long)powerplay_table) +\n\t\t\t\t\t\t\t\t       le16_to_cpu(powerplay_table3->usFanTableOffset));\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usTMax =\n\t\t\t\t\tle16_to_cpu(fan_table2->usTMax);\n\t\t\t}\n\n\t\t\tif (3 <= fan_table->ucFanTableFormat) {\n\t\t\t\tconst ATOM_PPLIB_FANTABLE3 *fan_table3 =\n\t\t\t\t\t(const ATOM_PPLIB_FANTABLE3 *) (((unsigned long)powerplay_table) +\n\t\t\t\t\t\t\t\t\tle16_to_cpu(powerplay_table3->usFanTableOffset));\n\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.ucFanControlMode =\n\t\t\t\t\tfan_table3->ucFanControlMode;\n\n\t\t\t\tif ((3 == fan_table->ucFanTableFormat) &&\n\t\t\t\t    (0x67B1 == adev->pdev->device))\n\t\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM =\n\t\t\t\t\t\t47;\n\t\t\t\telse\n\t\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanPWM =\n\t\t\t\t\t\tle16_to_cpu(fan_table3->usFanPWMMax);\n\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultFanOutputSensitivity =\n\t\t\t\t\t4836;\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanOutputSensitivity =\n\t\t\t\t\tle16_to_cpu(fan_table3->usFanOutputSensitivity);\n\t\t\t}\n\n\t\t\tif (6 <= fan_table->ucFanTableFormat) {\n\t\t\t\tconst ATOM_PPLIB_FANTABLE4 *fan_table4 =\n\t\t\t\t\t(const ATOM_PPLIB_FANTABLE4 *)(((unsigned long)powerplay_table) +\n\t\t\t\t\t\t\t\t       le16_to_cpu(powerplay_table3->usFanTableOffset));\n\n\t\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\t    PHM_PlatformCaps_FanSpeedInTableIsRPM);\n\n\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usDefaultMaxFanRPM =\n\t\t\t\t\tle16_to_cpu(fan_table4->usFanRPMMax);\n\t\t\t}\n\n\t\t\tif (7 <= fan_table->ucFanTableFormat) {\n\t\t\t\tconst ATOM_PPLIB_FANTABLE5 *fan_table5 =\n\t\t\t\t\t(const ATOM_PPLIB_FANTABLE5 *)(((unsigned long)powerplay_table) +\n\t\t\t\t\t\t\t\t       le16_to_cpu(powerplay_table3->usFanTableOffset));\n\n\t\t\t\tif (0x67A2 == adev->pdev->device ||\n\t\t\t\t    0x67A9 == adev->pdev->device ||\n\t\t\t\t    0x67B9 == adev->pdev->device) {\n\t\t\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\t\t    PHM_PlatformCaps_GeminiRegulatorFanControlSupport);\n\t\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanCurrentLow =\n\t\t\t\t\t\tle16_to_cpu(fan_table5->usFanCurrentLow);\n\t\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanCurrentHigh =\n\t\t\t\t\t\tle16_to_cpu(fan_table5->usFanCurrentHigh);\n\t\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanRPMLow =\n\t\t\t\t\t\tle16_to_cpu(fan_table5->usFanRPMLow);\n\t\t\t\t\thwmgr->thermal_controller.advanceFanControlParameters.usFanRPMHigh =\n\t\t\t\t\t\tle16_to_cpu(fan_table5->usFanRPMHigh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int init_overdrive_limits_V1_4(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table,\n\t\t\tconst ATOM_FIRMWARE_INFO_V1_4 *fw_info)\n{\n\thwmgr->platform_descriptor.overdriveLimit.engineClock =\n\t\t\t\tle32_to_cpu(fw_info->ulASICMaxEngineClock);\n\n\thwmgr->platform_descriptor.overdriveLimit.memoryClock =\n\t\t\t\tle32_to_cpu(fw_info->ulASICMaxMemoryClock);\n\n\thwmgr->platform_descriptor.maxOverdriveVDDC =\n\t\tle32_to_cpu(fw_info->ul3DAccelerationEngineClock) & 0x7FF;\n\n\thwmgr->platform_descriptor.minOverdriveVDDC =\n\t\t\t   le16_to_cpu(fw_info->usBootUpVDDCVoltage);\n\n\thwmgr->platform_descriptor.maxOverdriveVDDC =\n\t\t\t   le16_to_cpu(fw_info->usBootUpVDDCVoltage);\n\n\thwmgr->platform_descriptor.overdriveVDDCStep = 0;\n\treturn 0;\n}\n\nstatic int init_overdrive_limits_V2_1(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table,\n\t\t\tconst ATOM_FIRMWARE_INFO_V2_1 *fw_info)\n{\n\tconst ATOM_PPLIB_POWERPLAYTABLE3 *powerplay_table3;\n\tconst ATOM_PPLIB_EXTENDEDHEADER *header;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) <\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE3))\n\t\treturn 0;\n\n\tpowerplay_table3 = (const ATOM_PPLIB_POWERPLAYTABLE3 *)powerplay_table;\n\n\tif (0 == powerplay_table3->usExtendendedHeaderOffset)\n\t\treturn 0;\n\n\theader = (ATOM_PPLIB_EXTENDEDHEADER *)(((unsigned long) powerplay_table) +\n\t\t\tle16_to_cpu(powerplay_table3->usExtendendedHeaderOffset));\n\n\thwmgr->platform_descriptor.overdriveLimit.engineClock = le32_to_cpu(header->ulMaxEngineClock);\n\thwmgr->platform_descriptor.overdriveLimit.memoryClock = le32_to_cpu(header->ulMaxMemoryClock);\n\n\n\thwmgr->platform_descriptor.minOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.maxOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.overdriveVDDCStep = 0;\n\n\treturn 0;\n}\n\nstatic int init_overdrive_limits(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tint result = 0;\n\tuint8_t frev, crev;\n\tuint16_t size;\n\n\tconst ATOM_COMMON_TABLE_HEADER *fw_info = NULL;\n\n\thwmgr->platform_descriptor.overdriveLimit.engineClock = 0;\n\thwmgr->platform_descriptor.overdriveLimit.memoryClock = 0;\n\thwmgr->platform_descriptor.minOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.maxOverdriveVDDC = 0;\n\thwmgr->platform_descriptor.overdriveVDDCStep = 0;\n\n\tif (hwmgr->chip_id == CHIP_RAVEN)\n\t\treturn 0;\n\n\t \n\tfw_info = smu_atom_get_data_table(hwmgr->adev,\n\t\t\t GetIndexIntoMasterTable(DATA, FirmwareInfo),\n\t\t\t &size, &frev, &crev);\n\n\tif ((fw_info->ucTableFormatRevision == 1)\n\t    && (le16_to_cpu(fw_info->usStructureSize) >= sizeof(ATOM_FIRMWARE_INFO_V1_4)))\n\t\tresult = init_overdrive_limits_V1_4(hwmgr,\n\t\t\t\tpowerplay_table,\n\t\t\t\t(const ATOM_FIRMWARE_INFO_V1_4 *)fw_info);\n\n\telse if ((fw_info->ucTableFormatRevision == 2)\n\t\t && (le16_to_cpu(fw_info->usStructureSize) >= sizeof(ATOM_FIRMWARE_INFO_V2_1)))\n\t\tresult = init_overdrive_limits_V2_1(hwmgr,\n\t\t\t\tpowerplay_table,\n\t\t\t\t(const ATOM_FIRMWARE_INFO_V2_1 *)fw_info);\n\n\treturn result;\n}\n\nstatic int get_uvd_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_uvd_clock_voltage_dependency_table **ptable,\n\t\tconst ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *table,\n\t\tconst UVDClockInfoArray *array)\n{\n\tunsigned long i;\n\tstruct phm_uvd_clock_voltage_dependency_table *uvd_table;\n\n\tuvd_table = kzalloc(struct_size(uvd_table, entries, table->numEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!uvd_table)\n\t\treturn -ENOMEM;\n\n\tuvd_table->count = table->numEntries;\n\n\tfor (i = 0; i < table->numEntries; i++) {\n\t\tconst UVDClockInfo *entry =\n\t\t\t&array->entries[table->entries[i].ucUVDClockInfoIndex];\n\t\tuvd_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\n\t\tuvd_table->entries[i].vclk = ((unsigned long)entry->ucVClkHigh << 16)\n\t\t\t\t\t | le16_to_cpu(entry->usVClkLow);\n\t\tuvd_table->entries[i].dclk = ((unsigned long)entry->ucDClkHigh << 16)\n\t\t\t\t\t | le16_to_cpu(entry->usDClkLow);\n\t}\n\n\t*ptable = uvd_table;\n\n\treturn 0;\n}\n\nstatic int get_vce_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_vce_clock_voltage_dependency_table **ptable,\n\t\tconst ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *table,\n\t\tconst VCEClockInfoArray    *array)\n{\n\tunsigned long i;\n\tstruct phm_vce_clock_voltage_dependency_table *vce_table;\n\n\tvce_table = kzalloc(struct_size(vce_table, entries, table->numEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!vce_table)\n\t\treturn -ENOMEM;\n\n\tvce_table->count = table->numEntries;\n\tfor (i = 0; i < table->numEntries; i++) {\n\t\tconst VCEClockInfo *entry = &array->entries[table->entries[i].ucVCEClockInfoIndex];\n\n\t\tvce_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\n\t\tvce_table->entries[i].evclk = ((unsigned long)entry->ucEVClkHigh << 16)\n\t\t\t\t\t| le16_to_cpu(entry->usEVClkLow);\n\t\tvce_table->entries[i].ecclk = ((unsigned long)entry->ucECClkHigh << 16)\n\t\t\t\t\t| le16_to_cpu(entry->usECClkLow);\n\t}\n\n\t*ptable = vce_table;\n\n\treturn 0;\n}\n\nstatic int get_samu_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\n\t\t struct phm_samu_clock_voltage_dependency_table **ptable,\n\t\t const ATOM_PPLIB_SAMClk_Voltage_Limit_Table *table)\n{\n\tunsigned long i;\n\tstruct phm_samu_clock_voltage_dependency_table *samu_table;\n\n\tsamu_table = kzalloc(struct_size(samu_table, entries, table->numEntries),\n\t\t\t     GFP_KERNEL);\n\tif (!samu_table)\n\t\treturn -ENOMEM;\n\n\tsamu_table->count = table->numEntries;\n\n\tfor (i = 0; i < table->numEntries; i++) {\n\t\tsamu_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\n\t\tsamu_table->entries[i].samclk = ((unsigned long)table->entries[i].ucSAMClockHigh << 16)\n\t\t\t\t\t | le16_to_cpu(table->entries[i].usSAMClockLow);\n\t}\n\n\t*ptable = samu_table;\n\n\treturn 0;\n}\n\nstatic int get_acp_clock_voltage_limit_table(struct pp_hwmgr *hwmgr,\n\t\tstruct phm_acp_clock_voltage_dependency_table **ptable,\n\t\tconst ATOM_PPLIB_ACPClk_Voltage_Limit_Table *table)\n{\n\tunsigned long i;\n\tstruct phm_acp_clock_voltage_dependency_table *acp_table;\n\n\tacp_table = kzalloc(struct_size(acp_table, entries, table->numEntries),\n\t\t\t    GFP_KERNEL);\n\tif (!acp_table)\n\t\treturn -ENOMEM;\n\n\tacp_table->count = (unsigned long)table->numEntries;\n\n\tfor (i = 0; i < table->numEntries; i++) {\n\t\tacp_table->entries[i].v = (unsigned long)le16_to_cpu(table->entries[i].usVoltage);\n\t\tacp_table->entries[i].acpclk = ((unsigned long)table->entries[i].ucACPClockHigh << 16)\n\t\t\t\t\t | le16_to_cpu(table->entries[i].usACPClockLow);\n\t}\n\n\t*ptable = acp_table;\n\n\treturn 0;\n}\n\nstatic int init_clock_voltage_dependency(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tATOM_PPLIB_Clock_Voltage_Dependency_Table *table;\n\tATOM_PPLIB_Clock_Voltage_Limit_Table *limit_table;\n\tint result = 0;\n\n\tuint16_t vce_clock_info_array_offset;\n\tuint16_t uvd_clock_info_array_offset;\n\tuint16_t table_offset;\n\n\thwmgr->dyn_state.vddc_dependency_on_sclk = NULL;\n\thwmgr->dyn_state.vddci_dependency_on_mclk = NULL;\n\thwmgr->dyn_state.vddc_dependency_on_mclk = NULL;\n\thwmgr->dyn_state.vddc_dep_on_dal_pwrl = NULL;\n\thwmgr->dyn_state.mvdd_dependency_on_mclk = NULL;\n\thwmgr->dyn_state.vce_clock_voltage_dependency_table = NULL;\n\thwmgr->dyn_state.uvd_clock_voltage_dependency_table = NULL;\n\thwmgr->dyn_state.samu_clock_voltage_dependency_table = NULL;\n\thwmgr->dyn_state.acp_clock_voltage_dependency_table = NULL;\n\thwmgr->dyn_state.ppm_parameter_table = NULL;\n\thwmgr->dyn_state.vdd_gfx_dependency_on_sclk = NULL;\n\n\tvce_clock_info_array_offset = get_vce_clock_info_array_offset(\n\t\t\t\t\t\thwmgr, powerplay_table);\n\ttable_offset = get_vce_clock_voltage_limit_table_offset(hwmgr,\n\t\t\t\t\t\tpowerplay_table);\n\tif (vce_clock_info_array_offset > 0 && table_offset > 0) {\n\t\tconst VCEClockInfoArray *array = (const VCEClockInfoArray *)\n\t\t\t\t(((unsigned long) powerplay_table) +\n\t\t\t\tvce_clock_info_array_offset);\n\t\tconst ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *table =\n\t\t\t\t(const ATOM_PPLIB_VCE_Clock_Voltage_Limit_Table *)\n\t\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\tresult = get_vce_clock_voltage_limit_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.vce_clock_voltage_dependency_table,\n\t\t\t\ttable, array);\n\t}\n\n\tuvd_clock_info_array_offset = get_uvd_clock_info_array_offset(hwmgr, powerplay_table);\n\ttable_offset = get_uvd_clock_voltage_limit_table_offset(hwmgr, powerplay_table);\n\n\tif (uvd_clock_info_array_offset > 0 && table_offset > 0) {\n\t\tconst UVDClockInfoArray *array = (const UVDClockInfoArray *)\n\t\t\t\t(((unsigned long) powerplay_table) +\n\t\t\t\tuvd_clock_info_array_offset);\n\t\tconst ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *ptable =\n\t\t\t\t(const ATOM_PPLIB_UVD_Clock_Voltage_Limit_Table *)\n\t\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\tresult = get_uvd_clock_voltage_limit_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.uvd_clock_voltage_dependency_table, ptable, array);\n\t}\n\n\ttable_offset = get_samu_clock_voltage_limit_table_offset(hwmgr,\n\t\t\t\t\t\t\t    powerplay_table);\n\n\tif (table_offset > 0) {\n\t\tconst ATOM_PPLIB_SAMClk_Voltage_Limit_Table *ptable =\n\t\t\t\t(const ATOM_PPLIB_SAMClk_Voltage_Limit_Table *)\n\t\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\tresult = get_samu_clock_voltage_limit_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.samu_clock_voltage_dependency_table, ptable);\n\t}\n\n\ttable_offset = get_acp_clock_voltage_limit_table_offset(hwmgr,\n\t\t\t\t\t\t\t     powerplay_table);\n\n\tif (table_offset > 0) {\n\t\tconst ATOM_PPLIB_ACPClk_Voltage_Limit_Table *ptable =\n\t\t\t\t(const ATOM_PPLIB_ACPClk_Voltage_Limit_Table *)\n\t\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\tresult = get_acp_clock_voltage_limit_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.acp_clock_voltage_dependency_table, ptable);\n\t}\n\n\ttable_offset = get_cacp_tdp_table_offset(hwmgr, powerplay_table);\n\tif (table_offset > 0) {\n\t\tUCHAR rev_id = *(UCHAR *)(((unsigned long)powerplay_table) + table_offset);\n\n\t\tif (rev_id > 0) {\n\t\t\tconst ATOM_PPLIB_POWERTUNE_Table_V1 *tune_table =\n\t\t\t\t(const ATOM_PPLIB_POWERTUNE_Table_V1 *)\n\t\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\t\tresult = get_cac_tdp_table(hwmgr, &hwmgr->dyn_state.cac_dtp_table,\n\t\t\t\t&tune_table->power_tune_table,\n\t\t\t\tle16_to_cpu(tune_table->usMaximumPowerDeliveryLimit));\n\t\t\thwmgr->dyn_state.cac_dtp_table->usDefaultTargetOperatingTemp =\n\t\t\t\tle16_to_cpu(tune_table->usTjMax);\n\t\t} else {\n\t\t\tconst ATOM_PPLIB_POWERTUNE_Table *tune_table =\n\t\t\t\t(const ATOM_PPLIB_POWERTUNE_Table *)\n\t\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\t\tresult = get_cac_tdp_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.cac_dtp_table,\n\t\t\t\t&tune_table->power_tune_table, 255);\n\t\t}\n\t}\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t\tsizeof(ATOM_PPLIB_POWERPLAYTABLE4)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE4 *powerplay_table4 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE4 *)powerplay_table;\n\t\tif (0 != powerplay_table4->usVddcDependencyOnSCLKOffset) {\n\t\t\ttable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(((unsigned long) powerplay_table4) +\n\t\t\t\t le16_to_cpu(powerplay_table4->usVddcDependencyOnSCLKOffset));\n\t\t\tresult = get_clock_voltage_dependency_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.vddc_dependency_on_sclk, table);\n\t\t}\n\n\t\tif (result == 0 && (0 != powerplay_table4->usVddciDependencyOnMCLKOffset)) {\n\t\t\ttable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(((unsigned long) powerplay_table4) +\n\t\t\t\t le16_to_cpu(powerplay_table4->usVddciDependencyOnMCLKOffset));\n\t\t\tresult = get_clock_voltage_dependency_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.vddci_dependency_on_mclk, table);\n\t\t}\n\n\t\tif (result == 0 && (0 != powerplay_table4->usVddcDependencyOnMCLKOffset)) {\n\t\t\ttable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(((unsigned long) powerplay_table4) +\n\t\t\t\t le16_to_cpu(powerplay_table4->usVddcDependencyOnMCLKOffset));\n\t\t\tresult = get_clock_voltage_dependency_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.vddc_dependency_on_mclk, table);\n\t\t}\n\n\t\tif (result == 0 && (0 != powerplay_table4->usMaxClockVoltageOnDCOffset)) {\n\t\t\tlimit_table = (ATOM_PPLIB_Clock_Voltage_Limit_Table *)\n\t\t\t\t(((unsigned long) powerplay_table4) +\n\t\t\t\t le16_to_cpu(powerplay_table4->usMaxClockVoltageOnDCOffset));\n\t\t\tresult = get_clock_voltage_limit(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.max_clock_voltage_on_dc, limit_table);\n\t\t}\n\n\t\tif (result == 0 && (NULL != hwmgr->dyn_state.vddc_dependency_on_mclk) &&\n\t\t\t(0 != hwmgr->dyn_state.vddc_dependency_on_mclk->count))\n\t\t\tresult = get_valid_clk(hwmgr, &hwmgr->dyn_state.valid_mclk_values,\n\t\t\t\t\thwmgr->dyn_state.vddc_dependency_on_mclk);\n\n\t\tif(result == 0 && (NULL != hwmgr->dyn_state.vddc_dependency_on_sclk) &&\n\t\t\t(0 != hwmgr->dyn_state.vddc_dependency_on_sclk->count))\n\t\t\tresult = get_valid_clk(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.valid_sclk_values,\n\t\t\t\thwmgr->dyn_state.vddc_dependency_on_sclk);\n\n\t\tif (result == 0 && (0 != powerplay_table4->usMvddDependencyOnMCLKOffset)) {\n\t\t\ttable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t\t(((unsigned long) powerplay_table4) +\n\t\t\t\t le16_to_cpu(powerplay_table4->usMvddDependencyOnMCLKOffset));\n\t\t\tresult = get_clock_voltage_dependency_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.mvdd_dependency_on_mclk, table);\n\t\t}\n\t}\n\n\ttable_offset = get_sclk_vdd_gfx_clock_voltage_dependency_table_offset(hwmgr,\n\t\t\t\t\t\t\t\tpowerplay_table);\n\n\tif (table_offset > 0) {\n\t\ttable = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)\n\t\t\t(((unsigned long) powerplay_table) + table_offset);\n\t\tresult = get_clock_voltage_dependency_table(hwmgr,\n\t\t\t&hwmgr->dyn_state.vdd_gfx_dependency_on_sclk, table);\n\t}\n\n\treturn result;\n}\n\nstatic int get_cac_leakage_table(struct pp_hwmgr *hwmgr,\n\t\t\t\t struct phm_cac_leakage_table **ptable,\n\t\t\t\tconst ATOM_PPLIB_CAC_Leakage_Table *table)\n{\n\tstruct phm_cac_leakage_table  *cac_leakage_table;\n\tunsigned long i;\n\n\tif (!hwmgr || !table || !ptable)\n\t\treturn -EINVAL;\n\n\tcac_leakage_table = kzalloc(struct_size(cac_leakage_table, entries, table->ucNumEntries),\n\t\t\t\t    GFP_KERNEL);\n\tif (!cac_leakage_table)\n\t\treturn -ENOMEM;\n\n\tcac_leakage_table->count = (ULONG)table->ucNumEntries;\n\n\tfor (i = 0; i < cac_leakage_table->count; i++) {\n\t\tif (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\tPHM_PlatformCaps_EVV)) {\n\t\t\tcac_leakage_table->entries[i].Vddc1 = le16_to_cpu(table->entries[i].usVddc1);\n\t\t\tcac_leakage_table->entries[i].Vddc2 = le16_to_cpu(table->entries[i].usVddc2);\n\t\t\tcac_leakage_table->entries[i].Vddc3 = le16_to_cpu(table->entries[i].usVddc3);\n\t\t} else {\n\t\t\tcac_leakage_table->entries[i].Vddc    = le16_to_cpu(table->entries[i].usVddc);\n\t\t\tcac_leakage_table->entries[i].Leakage = le32_to_cpu(table->entries[i].ulLeakageValue);\n\t\t}\n\t}\n\n\t*ptable = cac_leakage_table;\n\n\treturn 0;\n}\n\nstatic int get_platform_power_management_table(struct pp_hwmgr *hwmgr,\n\t\t\tATOM_PPLIB_PPM_Table *atom_ppm_table)\n{\n\tstruct phm_ppm_table *ptr = kzalloc(sizeof(struct phm_ppm_table), GFP_KERNEL);\n\n\tif (NULL == ptr)\n\t\treturn -ENOMEM;\n\n\tptr->ppm_design            = atom_ppm_table->ucPpmDesign;\n\tptr->cpu_core_number        = le16_to_cpu(atom_ppm_table->usCpuCoreNumber);\n\tptr->platform_tdp          = le32_to_cpu(atom_ppm_table->ulPlatformTDP);\n\tptr->small_ac_platform_tdp   = le32_to_cpu(atom_ppm_table->ulSmallACPlatformTDP);\n\tptr->platform_tdc          = le32_to_cpu(atom_ppm_table->ulPlatformTDC);\n\tptr->small_ac_platform_tdc   = le32_to_cpu(atom_ppm_table->ulSmallACPlatformTDC);\n\tptr->apu_tdp               = le32_to_cpu(atom_ppm_table->ulApuTDP);\n\tptr->dgpu_tdp              = le32_to_cpu(atom_ppm_table->ulDGpuTDP);\n\tptr->dgpu_ulv_power         = le32_to_cpu(atom_ppm_table->ulDGpuUlvPower);\n\tptr->tj_max                = le32_to_cpu(atom_ppm_table->ulTjmax);\n\thwmgr->dyn_state.ppm_parameter_table = ptr;\n\n\treturn 0;\n}\n\nstatic int init_dpm2_parameters(struct pp_hwmgr *hwmgr,\n\t\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tint result = 0;\n\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE5)) {\n\t\tconst  ATOM_PPLIB_POWERPLAYTABLE5 *ptable5 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE5 *)powerplay_table;\n\t\tconst  ATOM_PPLIB_POWERPLAYTABLE4 *ptable4 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE4 *)\n\t\t\t\t(&ptable5->basicTable4);\n\t\tconst  ATOM_PPLIB_POWERPLAYTABLE3 *ptable3 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE3 *)\n\t\t\t\t(&ptable4->basicTable3);\n\t\tconst  ATOM_PPLIB_EXTENDEDHEADER  *extended_header;\n\t\tuint16_t table_offset;\n\t\tATOM_PPLIB_PPM_Table *atom_ppm_table;\n\n\t\thwmgr->platform_descriptor.TDPLimit     = le32_to_cpu(ptable5->ulTDPLimit);\n\t\thwmgr->platform_descriptor.nearTDPLimit = le32_to_cpu(ptable5->ulNearTDPLimit);\n\n\t\thwmgr->platform_descriptor.TDPODLimit   = le16_to_cpu(ptable5->usTDPODLimit);\n\t\thwmgr->platform_descriptor.TDPAdjustment = 0;\n\n\t\thwmgr->platform_descriptor.VidAdjustment = 0;\n\t\thwmgr->platform_descriptor.VidAdjustmentPolarity = 0;\n\t\thwmgr->platform_descriptor.VidMinLimit     = 0;\n\t\thwmgr->platform_descriptor.VidMaxLimit     = 1500000;\n\t\thwmgr->platform_descriptor.VidStep         = 6250;\n\n\t\thwmgr->platform_descriptor.nearTDPLimitAdjusted = le32_to_cpu(ptable5->ulNearTDPLimit);\n\n\t\tif (hwmgr->platform_descriptor.TDPODLimit != 0)\n\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\tPHM_PlatformCaps_PowerControl);\n\n\t\thwmgr->platform_descriptor.SQRampingThreshold = le32_to_cpu(ptable5->ulSQRampingThreshold);\n\n\t\thwmgr->platform_descriptor.CACLeakage = le32_to_cpu(ptable5->ulCACLeakage);\n\n\t\thwmgr->dyn_state.cac_leakage_table = NULL;\n\n\t\tif (0 != ptable5->usCACLeakageTableOffset) {\n\t\t\tconst ATOM_PPLIB_CAC_Leakage_Table *pCAC_leakage_table =\n\t\t\t\t(ATOM_PPLIB_CAC_Leakage_Table *)(((unsigned long)ptable5) +\n\t\t\t\tle16_to_cpu(ptable5->usCACLeakageTableOffset));\n\t\t\tresult = get_cac_leakage_table(hwmgr,\n\t\t\t\t&hwmgr->dyn_state.cac_leakage_table, pCAC_leakage_table);\n\t\t}\n\n\t\thwmgr->platform_descriptor.LoadLineSlope = le16_to_cpu(ptable5->usLoadLineSlope);\n\n\t\thwmgr->dyn_state.ppm_parameter_table = NULL;\n\n\t\tif (0 != ptable3->usExtendendedHeaderOffset) {\n\t\t\textended_header = (const ATOM_PPLIB_EXTENDEDHEADER *)\n\t\t\t\t\t(((unsigned long)powerplay_table) +\n\t\t\t\t\tle16_to_cpu(ptable3->usExtendendedHeaderOffset));\n\t\t\tif ((extended_header->usPPMTableOffset > 0) &&\n\t\t\t\tle16_to_cpu(extended_header->usSize) >=\n\t\t\t\t    SIZE_OF_ATOM_PPLIB_EXTENDEDHEADER_V5) {\n\t\t\t\ttable_offset = le16_to_cpu(extended_header->usPPMTableOffset);\n\t\t\t\tatom_ppm_table = (ATOM_PPLIB_PPM_Table *)\n\t\t\t\t\t(((unsigned long)powerplay_table) + table_offset);\n\t\t\t\tif (0 == get_platform_power_management_table(hwmgr, atom_ppm_table))\n\t\t\t\t\tphm_cap_set(hwmgr->platform_descriptor.platformCaps,\n\t\t\t\t\t\tPHM_PlatformCaps_EnablePlatformPowerManagement);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic int init_phase_shedding_table(struct pp_hwmgr *hwmgr,\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table)\n{\n\tif (le16_to_cpu(powerplay_table->usTableSize) >=\n\t    sizeof(ATOM_PPLIB_POWERPLAYTABLE4)) {\n\t\tconst ATOM_PPLIB_POWERPLAYTABLE4 *powerplay_table4 =\n\t\t\t\t(const ATOM_PPLIB_POWERPLAYTABLE4 *)powerplay_table;\n\n\t\tif (0 != powerplay_table4->usVddcPhaseShedLimitsTableOffset) {\n\t\t\tconst ATOM_PPLIB_PhaseSheddingLimits_Table *ptable =\n\t\t\t\t(ATOM_PPLIB_PhaseSheddingLimits_Table *)\n\t\t\t\t(((unsigned long)powerplay_table4) +\n\t\t\t\tle16_to_cpu(powerplay_table4->usVddcPhaseShedLimitsTableOffset));\n\t\t\tstruct phm_phase_shedding_limits_table *table;\n\t\t\tunsigned long i;\n\n\n\t\t\ttable = kzalloc(struct_size(table, entries, ptable->ucNumEntries),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!table)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\ttable->count = (unsigned long)ptable->ucNumEntries;\n\n\t\t\tfor (i = 0; i < table->count; i++) {\n\t\t\t\ttable->entries[i].Voltage = (unsigned long)le16_to_cpu(ptable->entries[i].usVoltage);\n\t\t\t\ttable->entries[i].Sclk    = ((unsigned long)ptable->entries[i].ucSclkHigh << 16)\n\t\t\t\t\t\t\t| le16_to_cpu(ptable->entries[i].usSclkLow);\n\t\t\t\ttable->entries[i].Mclk    = ((unsigned long)ptable->entries[i].ucMclkHigh << 16)\n\t\t\t\t\t\t\t| le16_to_cpu(ptable->entries[i].usMclkLow);\n\t\t\t}\n\t\t\thwmgr->dyn_state.vddc_phase_shed_limits_table = table;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int get_number_of_vce_state_table_entries(\n\t\t\t\t\t\t  struct pp_hwmgr *hwmgr)\n{\n\tconst ATOM_PPLIB_POWERPLAYTABLE *table =\n\t\t\t\t\t     get_powerplay_table(hwmgr);\n\tconst ATOM_PPLIB_VCE_State_Table *vce_table =\n\t\t\t\t    get_vce_state_table(hwmgr, table);\n\n\tif (vce_table)\n\t\treturn vce_table->numEntries;\n\n\treturn 0;\n}\n\nstatic int get_vce_state_table_entry(struct pp_hwmgr *hwmgr,\n\t\t\t\t\t\t\tunsigned long i,\n\t\t\t\t\t\t\tstruct amd_vce_state *vce_state,\n\t\t\t\t\t\t\tvoid **clock_info,\n\t\t\t\t\t\t\tunsigned long *flag)\n{\n\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table = get_powerplay_table(hwmgr);\n\n\tconst ATOM_PPLIB_VCE_State_Table *vce_state_table = get_vce_state_table(hwmgr, powerplay_table);\n\n\tunsigned short vce_clock_info_array_offset = get_vce_clock_info_array_offset(hwmgr, powerplay_table);\n\n\tconst VCEClockInfoArray *vce_clock_info_array = (const VCEClockInfoArray *)(((unsigned long) powerplay_table) + vce_clock_info_array_offset);\n\n\tconst ClockInfoArray *clock_arrays = (ClockInfoArray *)(((unsigned long)powerplay_table) +\n\t\t\t\t\t\t\t\tle16_to_cpu(powerplay_table->usClockInfoArrayOffset));\n\n\tconst ATOM_PPLIB_VCE_State_Record *record = &vce_state_table->entries[i];\n\n\tconst VCEClockInfo *vce_clock_info = &vce_clock_info_array->entries[record->ucVCEClockInfoIndex];\n\n\tunsigned long clockInfoIndex = record->ucClockInfoIndex & 0x3F;\n\n\t*flag = (record->ucClockInfoIndex >> NUM_BITS_CLOCK_INFO_ARRAY_INDEX);\n\n\tvce_state->evclk = ((uint32_t)vce_clock_info->ucEVClkHigh << 16) | le16_to_cpu(vce_clock_info->usEVClkLow);\n\tvce_state->ecclk = ((uint32_t)vce_clock_info->ucECClkHigh << 16) | le16_to_cpu(vce_clock_info->usECClkLow);\n\n\t*clock_info = (void *)((unsigned long)(clock_arrays->clockInfo) + (clockInfoIndex * clock_arrays->ucEntrySize));\n\n\treturn 0;\n}\n\n\nstatic int pp_tables_initialize(struct pp_hwmgr *hwmgr)\n{\n\tint result;\n\tconst ATOM_PPLIB_POWERPLAYTABLE *powerplay_table;\n\n\tif (hwmgr->chip_id == CHIP_RAVEN)\n\t\treturn 0;\n\n\thwmgr->need_pp_table_upload = true;\n\n\tpowerplay_table = get_powerplay_table(hwmgr);\n\n\tresult = init_powerplay_tables(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_powerplay_tables failed\", return result);\n\n\tresult = set_platform_caps(hwmgr,\n\t\t\t\tle32_to_cpu(powerplay_table->ulPlatformCaps));\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"set_platform_caps failed\", return result);\n\n\tresult = init_thermal_controller(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_thermal_controller failed\", return result);\n\n\tresult = init_overdrive_limits(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_overdrive_limits failed\", return result);\n\n\tresult = init_clock_voltage_dependency(hwmgr,\n\t\t\t\t\t       powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_clock_voltage_dependency failed\", return result);\n\n\tresult = init_dpm2_parameters(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_dpm2_parameters failed\", return result);\n\n\tresult = init_phase_shedding_table(hwmgr, powerplay_table);\n\n\tPP_ASSERT_WITH_CODE((result == 0),\n\t\t\t    \"init_phase_shedding_table failed\", return result);\n\n\treturn result;\n}\n\nstatic int pp_tables_uninitialize(struct pp_hwmgr *hwmgr)\n{\n\tif (hwmgr->chip_id == CHIP_RAVEN)\n\t\treturn 0;\n\n\tkfree(hwmgr->dyn_state.vddc_dependency_on_sclk);\n\thwmgr->dyn_state.vddc_dependency_on_sclk = NULL;\n\n\tkfree(hwmgr->dyn_state.vddci_dependency_on_mclk);\n\thwmgr->dyn_state.vddci_dependency_on_mclk = NULL;\n\n\tkfree(hwmgr->dyn_state.vddc_dependency_on_mclk);\n\thwmgr->dyn_state.vddc_dependency_on_mclk = NULL;\n\n\tkfree(hwmgr->dyn_state.mvdd_dependency_on_mclk);\n\thwmgr->dyn_state.mvdd_dependency_on_mclk = NULL;\n\n\tkfree(hwmgr->dyn_state.valid_mclk_values);\n\thwmgr->dyn_state.valid_mclk_values = NULL;\n\n\tkfree(hwmgr->dyn_state.valid_sclk_values);\n\thwmgr->dyn_state.valid_sclk_values = NULL;\n\n\tkfree(hwmgr->dyn_state.cac_leakage_table);\n\thwmgr->dyn_state.cac_leakage_table = NULL;\n\n\tkfree(hwmgr->dyn_state.vddc_phase_shed_limits_table);\n\thwmgr->dyn_state.vddc_phase_shed_limits_table = NULL;\n\n\tkfree(hwmgr->dyn_state.vce_clock_voltage_dependency_table);\n\thwmgr->dyn_state.vce_clock_voltage_dependency_table = NULL;\n\n\tkfree(hwmgr->dyn_state.uvd_clock_voltage_dependency_table);\n\thwmgr->dyn_state.uvd_clock_voltage_dependency_table = NULL;\n\n\tkfree(hwmgr->dyn_state.samu_clock_voltage_dependency_table);\n\thwmgr->dyn_state.samu_clock_voltage_dependency_table = NULL;\n\n\tkfree(hwmgr->dyn_state.acp_clock_voltage_dependency_table);\n\thwmgr->dyn_state.acp_clock_voltage_dependency_table = NULL;\n\n\tkfree(hwmgr->dyn_state.cac_dtp_table);\n\thwmgr->dyn_state.cac_dtp_table = NULL;\n\n\tkfree(hwmgr->dyn_state.ppm_parameter_table);\n\thwmgr->dyn_state.ppm_parameter_table = NULL;\n\n\tkfree(hwmgr->dyn_state.vdd_gfx_dependency_on_sclk);\n\thwmgr->dyn_state.vdd_gfx_dependency_on_sclk = NULL;\n\n\treturn 0;\n}\n\nconst struct pp_table_func pptable_funcs = {\n\t.pptable_init = pp_tables_initialize,\n\t.pptable_fini = pp_tables_uninitialize,\n\t.pptable_get_number_of_vce_state_table_entries =\n\t\t\t\tget_number_of_vce_state_table_entries,\n\t.pptable_get_vce_state_table_entry =\n\t\t\t\t\t\tget_vce_state_table_entry,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}