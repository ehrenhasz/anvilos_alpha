{
  "module_name": "vega20_baco.c",
  "hash_id": "d6e827433199f3da0cd9e1f92490d22178c89f593eb29680c473f25f0c72012f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/gpu/drm/amd/pm/powerplay/hwmgr/vega20_baco.c",
  "human_readable_source": " \n#include \"amdgpu.h\"\n#include \"soc15.h\"\n#include \"soc15_hw_ip.h\"\n#include \"soc15_common.h\"\n#include \"vega20_inc.h\"\n#include \"vega20_ppsmc.h\"\n#include \"vega20_baco.h\"\n#include \"vega20_smumgr.h\"\n\n#include \"amdgpu_ras.h\"\n\nstatic const struct soc15_baco_cmd_entry clean_baco_tbl[] = {\n\t{CMD_WRITE, SOC15_REG_ENTRY(NBIF, 0, mmBIOS_SCRATCH_6), 0, 0, 0, 0},\n\t{CMD_WRITE, SOC15_REG_ENTRY(NBIF, 0, mmBIOS_SCRATCH_7), 0, 0, 0, 0},\n};\n\nint vega20_baco_get_capability(struct pp_hwmgr *hwmgr, bool *cap)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tuint32_t reg;\n\n\t*cap = false;\n\tif (!phm_cap_enabled(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_BACO))\n\t\treturn 0;\n\n\tif (((RREG32(0x17569) & 0x20000000) >> 29) == 0x1) {\n\t\treg = RREG32_SOC15(NBIF, 0, mmRCC_BIF_STRAP0);\n\n\t\tif (reg & RCC_BIF_STRAP0__STRAP_PX_CAPABLE_MASK)\n\t\t\t*cap = true;\n\t}\n\n\treturn 0;\n}\n\nint vega20_baco_get_state(struct pp_hwmgr *hwmgr, enum BACO_STATE *state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tuint32_t reg;\n\n\treg = RREG32_SOC15(NBIF, 0, mmBACO_CNTL);\n\n\tif (reg & BACO_CNTL__BACO_MODE_MASK)\n\t\t \n\t\t*state = BACO_STATE_IN;\n\telse\n\t\t*state = BACO_STATE_OUT;\n\treturn 0;\n}\n\nint vega20_baco_set_state(struct pp_hwmgr *hwmgr, enum BACO_STATE state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)(hwmgr->adev);\n\tstruct amdgpu_ras *ras = amdgpu_ras_get_context(adev);\n\tenum BACO_STATE cur_state;\n\tuint32_t data;\n\n\tvega20_baco_get_state(hwmgr, &cur_state);\n\n\tif (cur_state == state)\n\t\t \n\t\treturn 0;\n\n\tif (state == BACO_STATE_IN) {\n\t\tif (!ras || !adev->ras_enabled) {\n\t\t\tdata = RREG32_SOC15(THM, 0, mmTHM_BACO_CNTL);\n\t\t\tdata |= 0x80000000;\n\t\t\tWREG32_SOC15(THM, 0, mmTHM_BACO_CNTL, data);\n\n\t\t\tif (smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_EnterBaco, 0, NULL))\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (smum_send_msg_to_smc_with_parameter(hwmgr,\n\t\t\t\t\tPPSMC_MSG_EnterBaco, 1, NULL))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else if (state == BACO_STATE_OUT) {\n\t\tif (smum_send_msg_to_smc(hwmgr, PPSMC_MSG_ExitBaco, NULL))\n\t\t\treturn -EINVAL;\n\t\tif (!soc15_baco_program_registers(hwmgr, clean_baco_tbl,\n\t\t\t\t\t\t     ARRAY_SIZE(clean_baco_tbl)))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint vega20_baco_apply_vdci_flush_workaround(struct pp_hwmgr *hwmgr)\n{\n\tint ret = 0;\n\n\tret = vega20_set_pptable_driver_address(hwmgr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn smum_send_msg_to_smc(hwmgr, PPSMC_MSG_BacoWorkAroundFlushVDCI, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}